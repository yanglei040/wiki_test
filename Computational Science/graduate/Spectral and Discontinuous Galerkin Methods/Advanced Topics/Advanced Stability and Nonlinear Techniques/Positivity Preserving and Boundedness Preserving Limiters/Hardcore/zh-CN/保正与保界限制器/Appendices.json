{
    "hands_on_practices": [
        {
            "introduction": "高阶数值方法（如间断伽辽金方法）在逼近解的过程中，可能会产生非物理的振荡，导致密度或浓度等必须为正的物理量出现负值。为了解决这个问题，我们引入了保正限制器。本练习  将带你通过一个具体的二维二次多项式例子，亲手计算一个线性缩放限制器的关键参数 $\\theta$，从而直观地理解限制器是如何通过将解拉向单元平均值来恢复解的物理相容性的。",
            "id": "3409716",
            "problem": "考虑双曲守恒律的间断伽辽金 (DG) 方法中的一个三角形单元，其中单元上的近似解表示一个非负标量场（例如密度）。该单元是参考三角形，其顶点为 $(0,0)$、$(1,0)$ 和 $(0,1)$。多项式次数为 $p=2$。单元上的近似解为\n$$\nu_h(x,y) \\;=\\; 1 \\;-\\; \\frac{5}{2}\\,x^2.\n$$\n应用一个线性缩放的保正限制器，其形式为围绕单元平均值的标准重缩放，因此对于选定的参数 $\\theta \\in [0,1]$，限制后的场为\n$$\nu^{\\theta}(x,y) \\;=\\; \\bar{u} \\;+\\; \\theta\\,\\big(u_h(x,y) - \\bar{u}\\big).\n$$\n此处 $\\bar{u}$ 是 $u_h$ 在该单元上的精确单元平均值。要求该限制器在由2次 Dunavant 求积节点给出的体积校验点上强制非负性，即 $(2/3,1/6,1/6)$ 的三个重心坐标置换，对于此参考三角形，其笛卡尔坐标为\n$$\n(x_1,y_1)=\\Big(\\frac{1}{6},\\frac{1}{6}\\Big),\\quad (x_2,y_2)=\\Big(\\frac{2}{3},\\frac{1}{6}\\Big),\\quad (x_3,y_3)=\\Big(\\frac{1}{6},\\frac{2}{3}\\Big).\n$$\n从线性缩放限制器的第一性原理出发，确定最大的 $\\theta \\in [0,1]$，使得在上面列出的所有三个 Dunavant 节点 $(x_q,y_q)$ 处，都有 $u^{\\theta}(x_q,y_q)\\ge 0$。根据单元平均值的定义精确计算 $\\bar{u}$，并精确执行所有求值。将最终的 $\\theta$ 以精确有理数的形式给出。不需要四舍五入，也不涉及单位。",
            "solution": "该问题要求找到一个线性缩放保正限制器的最大参数 $\\theta \\in [0,1]$，使得限制后的近似解 $u^{\\theta}(x,y)$ 在一组指定的校验点上保持非负。\n\n给定的单元是参考三角形 $K$，其顶点为 $(0,0)$、$(1,0)$ 和 $(0,1)$。其面积为 $|K| = \\frac{1}{2} \\times \\text{底} \\times \\text{高} = \\frac{1}{2}(1)(1) = \\frac{1}{2}$。\n\n未限制的近似解由以下二次多项式给出：\n$$\nu_h(x,y) = 1 - \\frac{5}{2}x^2\n$$\n\n限制后的近似解定义为：\n$$\nu^{\\theta}(x,y) = \\bar{u} + \\theta \\left( u_h(x,y) - \\bar{u} \\right)\n$$\n其中 $\\bar{u}$ 是 $u_h$ 在单元 $K$ 上的单元平均值。\n\n需要强制执行的约束是在三个指定的 Dunavant 求积节点 $(x_q, y_q)$ 处 $u^{\\theta}(x_q,y_q) \\ge 0$。这可以转化为：\n$$\n\\bar{u} + \\theta \\left( u_h(x_q, y_q) - \\bar{u} \\right) \\ge 0\n$$\n对每个校验点 $q \\in \\{1,2,3\\}$ 成立。可以重排此不等式以找到对 $\\theta$ 的约束。约束的性质取决于项 $u_h(x_q, y_q) - \\bar{u}$ 的符号。\n\n我们来分析这个不等式：\n1.  如果 $u_h(x_q, y_q) - \\bar{u} > 0$，不等式为 $\\theta \\ge \\frac{-\\bar{u}}{u_h(x_q, y_q) - \\bar{u}}$。如果我们发现 $\\bar{u} > 0$，这将为 $\\theta$ 提供一个非正的下界。由于 $\\theta \\in [0,1]$，此条件自然满足，并且没有对 $\\theta$ 施加上界。\n2.  如果 $u_h(x_q, y_q) - \\bar{u}  0$，我们必须除以一个负数，这会反转不等号：\n    $$\n    \\theta \\le \\frac{-\\bar{u}}{u_h(x_q, y_q) - \\bar{u}} = \\frac{\\bar{u}}{\\bar{u} - u_h(x_q, y_q)}\n    $$\n    这对 $\\theta$ 施加了一个上界。\n\n为了在所有校验点上都满足非负性，$\\theta$ 必须小于或等于所有相关点上所有这些上界的最小值。因此，允许的最大 $\\theta$\n为：\n$$\n\\theta_{\\text{max}} = \\min\\left(1, \\min_{q \\text{ s.t. } u_h(x_q,y_q)  \\bar{u}} \\left\\{ \\frac{\\bar{u}}{\\bar{u} - u_h(x_q,y_q)} \\right\\} \\right)\n$$\n\n求解过程分三步：\n1.  计算精确的单元平均值 $\\bar{u}$。\n2.  在三个校验点上计算 $u_h(x,y)$ 的值。\n3.  使用这些值来确定对 $\\theta$ 的约束，并找到其最大可能值。\n\n**第 1 步：计算单元平均值 $\\bar{u}$**\n单元平均值定义为 $\\bar{u} = \\frac{1}{|K|} \\int_K u_h(x,y) \\,dA$。\n$$\n\\bar{u} = \\frac{1}{1/2} \\int_0^1 \\int_0^{1-x} \\left(1 - \\frac{5}{2}x^2\\right) \\,dy\\,dx\n$$\n$$\n\\bar{u} = 2 \\int_0^1 \\left[ \\left(1 - \\frac{5}{2}x^2\\right)y \\right]_{y=0}^{y=1-x} \\,dx = 2 \\int_0^1 \\left(1 - \\frac{5}{2}x^2\\right)(1-x) \\,dx\n$$\n展开被积函数：\n$$\n\\bar{u} = 2 \\int_0^1 \\left(1 - x - \\frac{5}{2}x^2 + \\frac{5}{2}x^3\\right) \\,dx\n$$\n逐项积分：\n$$\n\\bar{u} = 2 \\left[ x - \\frac{x^2}{2} - \\frac{5}{2}\\frac{x^3}{3} + \\frac{5}{2}\\frac{x^4}{4} \\right]_0^1 = 2 \\left( 1 - \\frac{1}{2} - \\frac{5}{6} + \\frac{5}{8} \\right)\n$$\n$$\n\\bar{u} = 2 \\left( \\frac{1}{2} - \\frac{5}{6} + \\frac{5}{8} \\right) = 2 \\left( \\frac{12}{24} - \\frac{20}{24} + \\frac{15}{24} \\right) = 2 \\left( \\frac{12 - 20 + 15}{24} \\right) = 2 \\left( \\frac{7}{24} \\right)\n$$\n$$\n\\bar{u} = \\frac{14}{24} = \\frac{7}{12}\n$$\n由于 $\\bar{u} = 7/12 > 0$，我们对不等式的分析是正确的。\n\n**第 2 步：在校验点上计算 $u_h(x,y)$ 的值**\n校验点为 $(x_1,y_1)=(1/6,1/6)$、$(x_2,y_2)=(2/3,1/6)$ 和 $(x_3,y_3)=(1/6,2/3)$。\n函数为 $u_h(x,y) = 1 - \\frac{5}{2}x^2$。注意 $u_h$ 与 $y$ 无关。\n\n对于 $(x_1,y_1) = (1/6, 1/6)$：\n$$\nu_{h,1} = u_h\\left(\\frac{1}{6}, \\frac{1}{6}\\right) = 1 - \\frac{5}{2}\\left(\\frac{1}{6}\\right)^2 = 1 - \\frac{5}{2}\\left(\\frac{1}{36}\\right) = 1 - \\frac{5}{72} = \\frac{67}{72}\n$$\n\n对于 $(x_2,y_2) = (2/3, 1/6)$：\n$$\nu_{h,2} = u_h\\left(\\frac{2}{3}, \\frac{1}{6}\\right) = 1 - \\frac{5}{2}\\left(\\frac{2}{3}\\right)^2 = 1 - \\frac{5}{2}\\left(\\frac{4}{9}\\right) = 1 - \\frac{10}{9} = -\\frac{1}{9}\n$$\n\n对于 $(x_3,y_3) = (1/6, 2/3)$：\n$$\nu_{h,3} = u_h\\left(\\frac{1}{6}, \\frac{2}{3}\\right) = 1 - \\frac{5}{2}\\left(\\frac{1}{6}\\right)^2 = 1 - \\frac{5}{72} = \\frac{67}{72}\n$$\n\n**第 3 步：确定对 $\\theta$ 的约束**\n我们必须找到满足 $u_h(x_q, y_q)  \\bar{u}$ 的点。\n我们有 $\\bar{u} = \\frac{7}{12} = \\frac{42}{72}$。\n校验点上的值为 $u_{h,1} = \\frac{67}{72}$、$u_{h,2} = -\\frac{1}{9} = -\\frac{8}{72}$ 和 $u_{h,3} = \\frac{67}{72}$。\n\n- 对于点 1 和 3：$u_h = \\frac{67}{72} > \\frac{42}{72} = \\bar{u}$。如前所述，这些点不对 $\\theta$ 施加上界。\n\n- 对于点 2：$u_{h,2} = -\\frac{8}{72}  \\frac{42}{72} = \\bar{u}$。该点对 $\\theta$ 施加一个上界：\n$$\n\\theta \\le \\frac{\\bar{u}}{\\bar{u} - u_{h,2}}\n$$\n代入数值：\n$$\n\\theta \\le \\frac{\\frac{7}{12}}{\\frac{7}{12} - \\left(-\\frac{1}{9}\\right)} = \\frac{\\frac{7}{12}}{\\frac{7}{12} + \\frac{1}{9}}\n$$\n为了计算分母，我们找到 12 和 9 的一个公倍数，即 36：\n$$\n\\frac{7}{12} + \\frac{1}{9} = \\frac{7 \\times 3}{36} + \\frac{1 \\times 4}{36} = \\frac{21+4}{36} = \\frac{25}{36}\n$$\n将此结果代回关于 $\\theta$ 的不等式：\n$$\n\\theta \\le \\frac{\\frac{7}{12}}{\\frac{25}{36}} = \\frac{7}{12} \\times \\frac{36}{25} = \\frac{7 \\times 3}{25} = \\frac{21}{25}\n$$\n\n由非负性约束得到的唯一上界是 $\\theta \\le \\frac{21}{25}$。我们还有定义上的约束 $\\theta \\in [0,1]$。\n最终条件是 $\\theta \\le \\min\\left(1, \\frac{21}{25}\\right)$。由于 $\\frac{21}{25}  1$，最小值为 $\\frac{21}{25}$。\n因此，$\\theta$ 允许的最大值为 $\\frac{21}{25}$。",
            "answer": "$$ \\boxed{\\frac{21}{25}} $$"
        },
        {
            "introduction": "保正或保界属性不仅对于高阶方法中的静态多项式至关重要，它更是演化方程数值格式稳定性的基石。本练习  将背景设定在一个简单的一阶有限体积格式（即 $DG-P0$）中，要求你实现局部 Lax-Friedrichs 通量并分析其数值耗散的作用。通过亲手编码和测试，你将深刻体会到为何必须有足够的数值耗散才能保证数值解不产生新的极值，从而为理解高阶格式中限制器的必要性奠定基础。",
            "id": "3409629",
            "problem": "考虑一维标量守恒律 $u_t + f(u)_x = 0$，该方程在一个尺寸为 $\\Delta x > 0$ 的均匀网格上，使用双网格间断伽辽金（DG）方法进行离散，并采用分段常数基函数（多项式次数 $p=0$），使得网格平均值仅通过界面上的数值通量进行演化。采用局部Lax–Friedrichs（LLF）数值通量作为任意具有左状态 $u^{-}$ 和右状态 $u^{+}$ 的界面上的低阶单调通量：\n$$\nF_{\\mathrm{LLF}}(u^{-},u^{+};\\alpha) = \\frac{1}{2}\\left[f(u^{-}) + f(u^{+})\\right] - \\frac{1}{2}\\,\\alpha\\,(u^{+}-u^{-}),\n$$\n其中，迎面耗散参数 $\\alpha$ 的选择必须能够主导跨界面的局部特征速度。在标量情况下，雅可比矩阵为 $f'(u)$，因此一个充分的迎面选择是\n$$\n\\alpha(u^{-},u^{+}) = \\sup_{s \\in [\\min(u^{-},u^{+}),\\,\\max(u^{-},u^{+})]} \\left| f'(s) \\right|.\n$$\n你需要为以下两种通量实现这种迎面 $\\alpha$ 的计算：\n- 线性平流：$f(u) = a\\,u$，其中 $a \\in \\mathbb{R}$ 为常数。\n- 无粘伯格斯方程：$f(u) = \\frac{1}{2}u^2$。\n\n使用一个具有初始化为黎曼阶跃状态的双网格区域：网格 $0$ 的值为常数 $u_L$，网格 $1$ 的值为常数 $u_R$。假设左边界处的远场状态恒为 $u_L$，右边界处恒为 $u_R$。在这种 $p=0$ 的设置下，网格平均值在单个时间步长 $\\Delta t$ 内的前向欧拉更新为\n$$\n\\bar{u}_0^{n+1} = \\bar{u}_0^{n} - \\frac{\\Delta t}{\\Delta x}\\left(F_{\\mathrm{mid}} - f(u_L)\\right),\\qquad\n\\bar{u}_1^{n+1} = \\bar{u}_1^{n} - \\frac{\\Delta t}{\\Delta x}\\left(f(u_R) - F_{\\mathrm{mid}}\\right),\n$$\n其中 $F_{\\mathrm{mid}} = F_{\\mathrm{LLF}}(u_L,u_R;\\alpha_{\\mathrm{mid}})$ 是两个网格之间内部界面上的 LLF 通量，其迎面 $\\alpha$ 为 $\\alpha_{\\mathrm{mid}}$。对于这种双网格黎曼构型，根据 Courant–Friedrichs–Lewy (CFL) 数 $0  \\mathrm{CFL} \\le 1$ 选择时间步长\n$$\n\\Delta t = \\begin{cases}\n\\mathrm{CFL}\\,\\dfrac{\\Delta x}{\\alpha_{\\mathrm{mid}}},  \\alpha_{\\mathrm{mid}} > 0,\\\\[1.0ex]\n\\Delta x,  \\alpha_{\\mathrm{mid}} = 0,\n\\end{cases}\n$$\n注意，如果 $\\alpha_{\\mathrm{mid}}=0$，则 $u_L=u_R$ 且 $F_{\\mathrm{mid}}=f(u_L)$，因此不会发生更新。\n\n你的任务：\n1. 为每个通量族，通过计算 $\\left|f'(s)\\right|$ 在连接 $u^{-}$ 和 $u^{+}$ 的区间上的上确界，实现迎面计算 $\\alpha(u^{-},u^{+})$。这必须基于上述定义从第一性原理出发，而不是通过硬编码特定情况的“快捷”值。\n2. 使用计算出的 $\\alpha_{\\mathrm{mid}}$ 和 LLF 通量，为上述双网格问题实现单步前向欧拉更新。\n3. 通过使用 $\\tilde{\\alpha}_{\\mathrm{mid}} = \\sigma\\,\\alpha_{\\mathrm{mid}}$ 重复相同的更新，研究将 $\\alpha$ 低估一个因子 $0  \\sigma  1$ 的影响。\n4. 对每次运行，通过检查 $\\bar{u}_0^{n+1}$ 和 $\\bar{u}_1^{n+1}$ 是否都位于闭区间 $[m_0,M_0]$ 内，来验证网格平均值相对于初始全局界\n$$\nm_0 = \\min(u_L,u_R),\\qquad M_0 = \\max(u_L,u_R),\n$$\n的离散保界性。为每次运行报告一个布尔值。\n\n使用以下黎曼问题测试套件，其中 $\\Delta x = 1$ 并指定了 $\\mathrm{CFL}$ 和低估因子 $\\sigma$：\n- 测试 1：伯格斯通量，$u_L=1.0$，$u_R=2.0$，$\\mathrm{CFL}=0.9$，$\\sigma=0.5$。\n- 测试 2：伯格斯通量，$u_L=2.0$，$u_R=1.0$，$\\mathrm{CFL}=0.9$，$\\sigma=0.5$。\n- 测试 3：线性平流，$a=1.0$，$u_L=1.0$，$u_R=0.0$，$\\mathrm{CFL}=0.9$，$\\sigma=0.5$。\n- 测试 4：伯格斯通量，$u_L=-1.5$，$u_R=-0.5$，$\\mathrm{CFL}=0.9$，$\\sigma=0.5$。\n- 测试 5：伯格斯通量，$u_L=1.234$，$u_R=1.234$，$\\mathrm{CFL}=0.9$，$\\sigma=0.5$。\n\n对于每个测试，按顺序生成两个布尔值：第一个使用上述定义的正确 $\\alpha_{\\mathrm{mid}}$，第二个使用低估的 $\\tilde{\\alpha}_{\\mathrm{mid}}=\\sigma\\,\\alpha_{\\mathrm{mid}}$。因此，在五个测试中，你的程序应生成单行输出，其中包含一个聚合到单个列表中的十个布尔值。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[true1,false1,true2,false2,...]”）。不允许有其他输出。\n\n角度、单位和物理量纲不适用于此纯数学任务；所有量均为无量纲实数。每个测试的最终答案都是布尔值。",
            "solution": "该问题要求实现并分析一个用于一维标量守恒律的一阶数值格式，该守恒律由下式给出：\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0\n$$\n空间离散化被指定为使用分段常数基函数（$p=0$）的双网格间断伽辽金（DG）方法，这等效于一阶有限体积法。两个网格，标记为 $0$ 和 $1$，其初始常数状态分别为 $\\bar{u}_0^n = u_L$ 和 $\\bar{u}_1^n = u_R$。该区域定义在一个均匀网格上，网格宽度为 $\\Delta x$。\n\n半离散有限体积公式根据通量平衡更新网格 $i$ 中的网格平均值 $\\bar{u}_i$：\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x}\\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\n其中 $F_{i\\pm1/2}$ 是网格界面处的数值通量。对于双网格设置，这变为：\n- 网格 0：$\\frac{d\\bar{u}_0}{dt} = -\\frac{1}{\\Delta x}\\left( F_{1/2} - F_{-1/2} \\right)$\n- 网格 1：$\\frac{d\\bar{u}_1}{dt} = -\\frac{1}{\\Delta x}\\left( F_{3/2} - F_{1/2} \\right)$\n\n通量 $F_{1/2} = F_{\\mathrm{mid}}$ 在网格 0 和网格 1 之间的内部界面上计算。边界通量由 $F_{-1/2} = f(u_L)$ 和 $F_{3/2} = f(u_R)$ 给出，对应于固定的远场边界条件。时间积分通过单步前向欧拉法执行。这导致了问题陈述中提供的完全离散更新方程：\n$$\n\\bar{u}_0^{n+1} = \\bar{u}_0^{n} - \\frac{\\Delta t}{\\Delta x}\\left(F_{\\mathrm{mid}} - f(u_L)\\right)\n$$\n$$\n\\bar{u}_1^{n+1} = \\bar{u}_1^{n} - \\frac{\\Delta t}{\\Delta x}\\left(f(u_R) - F_{\\mathrm{mid}}\\right)\n$$\n其中初始状态为 $\\bar{u}_0^n = u_L$ 和 $\\bar{u}_1^n = u_R$。\n\n内部界面处的数值通量 $F_{\\mathrm{mid}}$ 是局部Lax-Friedrichs（LLF）通量，它取决于左状态 $u^{-} = u_L$ 和右状态 $u^{+} = u_R$：\n$$\nF_{\\mathrm{mid}} = F_{\\mathrm{LLF}}(u_L, u_R; \\alpha_{\\mathrm{mid}}) = \\frac{1}{2}\\left[f(u_L) + f(u_R)\\right] - \\frac{1}{2}\\,\\alpha_{\\mathrm{mid}}\\,(u_R - u_L)\n$$\n参数 $\\alpha_{\\mathrm{mid}}$ 表示数值耗散。为使格式单调，从而保证不产生新的极值（即保界），$\\alpha_{\\mathrm{mid}}$ 必须足够大。一个充分条件是 $\\alpha_{\\mathrm{mid}}$ 必须大于或等于在界面上相互作用的状态范围内的最大局部波速。对于标量守恒律，波速（特征速度）是 $f'(u)$。因此，迎面耗散参数定义为：\n$$\n\\alpha_{\\mathrm{mid}} = \\alpha(u_L, u_R) = \\sup_{s \\in [\\min(u_L, u_R),\\,\\max(u_L, u_R)]} \\left| f'(s) \\right|\n$$\n\n我们现在将为两种指定的通量函数确定 $\\alpha_{\\mathrm{mid}}$ 的表达式。\n1.  **线性平流**：通量为 $f(u) = a u$，其中 $a \\in \\mathbb{R}$ 为某个常数。导数为 $f'(u) = a$。其绝对值为 $|f'(u)| = |a|$，是一个常数。因此，在任何区间上的上确界就是这个常数值：\n    $$\n    \\alpha(u_L, u_R) = \\sup_{s \\in [\\min(u_L, u_R),\\,\\max(u_L, u_R)]} |a| = |a|\n    $$\n2.  **无粘伯格斯方程**：通量为 $f(u) = \\frac{1}{2}u^2$。导数为 $f'(u) = u$。我们需要在区间 $I = [\\min(u_L, u_R), \\max(u_L, u_R)]$ 上找到 $|f'(s)| = |s|$ 的上确界。函数 $g(s) = |s|$ 是凸函数。凸函数的一个性质是其在闭区间上的最大值必定出现在区间的某个端点上。因此，我们只需要检查 $s = \\min(u_L, u_R)$ 和 $s = \\max(u_L, u_R)$ 处的 $|s|$ 值，这些值按某种顺序就是 $u_L$ 和 $u_R$。\n    $$\n    \\alpha(u_L, u_R) = \\max\\left(\\left|\\min(u_L, u_R)\\right|, \\left|\\max(u_L, u_R)\\right|\\right) = \\max(|u_L|, |u_R|)\n    $$\n该逻辑构成了从第一性原理出发的推导，因为它依赖于函数 $|f'(s)|$ 的基本数学性质，而不是一个预先指定的公式。\n\n时间步长 $\\Delta t$ 由 Courant–Friedrichs–Lewy (CFL) 条件确定。对于 $\\alpha_{\\mathrm{mid}} > 0$，时间步长为 $\\Delta t = \\mathrm{CFL}\\,\\frac{\\Delta x}{\\alpha_{\\mathrm{mid}}}$。这个选择确保了系数 $\\frac{\\Delta t}{\\Delta x}\\alpha_{\\mathrm{mid}} = \\mathrm{CFL} \\le 1$。根据单调格式理论，这个条件是前向欧拉时间步进格式保界的必要条件，前提是 LLF 通量本身是单调的（这一点通过我们对 $\\alpha_{\\mathrm{mid}}$ 的选择得到保证）。如果 $\\alpha_{\\mathrm{mid}} = 0$（对于给定的通量函数，当且仅当 $u_L = u_R$ 时发生），更新项变为零，解是稳态的。\n\n任务的核心是验证保界性。初始界限为 $m_0 = \\min(u_L, u_R)$ 和 $M_0 = \\max(u_L, u_R)$。在一个时间步后，我们检查新的网格平均值 $\\bar{u}_0^{n+1}$ 和 $\\bar{u}_1^{n+1}$ 是否保持在这些界限内，即 $m_0 \\le \\bar{u}_0^{n+1} \\le M_0$ 和 $m_0 \\le \\bar{u}_1^{n+1} \\le M_0$。此检查在两种情况下进行：\n1.  使用正确计算的耗散 $\\alpha_{\\mathrm{mid}}$。在 $\\mathrm{CFL} \\le 1$ 的情况下，该格式预期是保界的。\n2.  使用低估的耗散 $\\tilde{\\alpha}_{\\mathrm{mid}} = \\sigma \\alpha_{\\mathrm{mid}}$，其中 $0  \\sigma  1$。在这种情况下，数值通量的单调性准则可能被违反，可能导致产生新的极值（过冲或下冲），从而违反初始界限 $[m_0, M_0]$。时间步长 $\\Delta t$ 是使用正确的 $\\alpha_{\\mathrm{mid}}$ 计算的，并在两次计算中保持不变，以便隔离耗散项在通量中的影响。\n\n对于每个测试用例，将执行以下步骤：\n1.  确定通量函数 $f(u)$ 及其导数 $f'(u)$。\n2.  给定 $u_L$ 和 $u_R$，通过在区间 $[\\min(u_L, u_R), \\max(u_L, u_R)]$ 上找到 $|f'(s)|$ 的上确界来计算正确的耗散 $\\alpha_{\\mathrm{mid}}$。\n3.  使用 $\\alpha_{\\mathrm{mid}}$、$\\Delta x$ 和 $\\mathrm{CFL}$ 计算时间步长 $\\Delta t$。如果 $\\alpha_{\\mathrm{mid}}=0$，则不发生更新，解是平凡保界的。\n4.  **运行 1（正确的 $\\alpha$）**：使用 $\\alpha_{\\mathrm{mid}}$ 计算 $F_{\\mathrm{mid}}$。计算 $\\bar{u}_0^{n+1}$ 和 $\\bar{u}_1^{n+1}$。检查两个值是否都在 $[m_0, M_0]$ 内，并记录布尔结果。\n5.  **运行 2（低估的 $\\alpha$）**：计算 $\\tilde{\\alpha}_{\\mathrm{mid}} = \\sigma \\alpha_{\\mathrm{mid}}$。使用 $\\tilde{\\alpha}_{\\mathrm{mid}}$ 计算新的通量 $\\tilde{F}_{\\mathrm{mid}}$。使用与之前相同的 $\\Delta t$，计算新的状态 $\\bar{u}_0^{n+1}$ 和 $\\bar{u}_1^{n+1}$。检查两个值是否都在 $[m_0, M_0]$ 内，并记录布尔结果。\n实现将系统地将此过程应用于所有指定的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-cell DG-P0 problem for various test cases, checking for\n    bound-preservation with correct and underestimated numerical dissipation.\n    \"\"\"\n\n    test_cases = [\n        {'flux_type': 'burgers', 'ul': 1.0, 'ur': 2.0, 'cfl': 0.9, 'sigma': 0.5},\n        {'flux_type': 'burgers', 'ul': 2.0, 'ur': 1.0, 'cfl': 0.9, 'sigma': 0.5},\n        {'flux_type': 'linear', 'a': 1.0, 'ul': 1.0, 'ur': 0.0, 'cfl': 0.9, 'sigma': 0.5},\n        {'flux_type': 'burgers', 'ul': -1.5, 'ur': -0.5, 'cfl': 0.9, 'sigma': 0.5},\n        {'flux_type': 'burgers', 'ul': 1.234, 'ur': 1.234, 'cfl': 0.9, 'sigma': 0.5},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Run simulation for one test case and append results\n        res1, res2 = run_test_case(case)\n        results.extend([res1, res2])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\n\ndef get_flux_functions(flux_type, a=None):\n    \"\"\"Factory for flux function f and its derivative f_prime.\"\"\"\n    if flux_type == 'burgers':\n        f = lambda u: 0.5 * u**2\n        f_prime = lambda u: u\n    elif flux_type == 'linear':\n        if a is None:\n            raise ValueError(\"Parameter 'a' must be provided for linear advection.\")\n        f = lambda u: a * u\n        f_prime = lambda u: a\n    else:\n        raise ValueError(f\"Unknown flux type: {flux_type}\")\n    return f, f_prime\n\ndef compute_alpha(f_prime, u_minus, u_plus):\n    \"\"\"\n    Computes the facewise dissipation alpha from first principles.\n    alpha = sup |f'(s)| for s in [min(u-,u+), max(u-,u+)].\n    For the monotonic/convex functions |f'| used here, the supremum\n    is at one of the interval endpoints.\n    \"\"\"\n    if u_minus == u_plus:\n        return np.abs(f_prime(u_minus))\n\n    u_min = min(u_minus, u_plus)\n    u_max = max(u_minus, u_plus)\n    \n    # For linear advection, f_prime is constant.\n    # For Burgers, f_prime(s)=s, so |f_prime(s)|=|s| is convex.\n    # Its maximum on an interval [u_min, u_max] is at an endpoint.\n    # This logic is general for any f' where |f'|'s max is at an endpoint.\n    val1 = np.abs(f_prime(u_min))\n    val2 = np.abs(f_prime(u_max))\n    \n    return max(val1, val2)\n\ndef run_test_case(params):\n    \"\"\"Runs a single test case with correct and underestimated alpha.\"\"\"\n    ul, ur = params['ul'], params['ur']\n    cfl, sigma = params['cfl'], params['sigma']\n    flux_type = params['flux_type']\n    a = params.get('a')\n    dx = 1.0\n\n    f, f_prime = get_flux_functions(flux_type, a)\n\n    # Initial bounds for checking preservation\n    m0 = min(ul, ur)\n    M0 = max(ul, ur)\n\n    # Compute correct alpha and the time step\n    alpha_mid_correct = compute_alpha(f_prime, ul, ur)\n\n    if alpha_mid_correct > 0:\n        dt = cfl * dx / alpha_mid_correct\n    else:\n        # If alpha is 0, states are equal, no update occurs. Bounds are preserved.\n        return True, True\n\n    # --- Run 1: Correct alpha ---\n    alpha1 = alpha_mid_correct\n    f_mid_1 = 0.5 * (f(ul) + f(ur)) - 0.5 * alpha1 * (ur - ul)\n    \n    u0_new_1 = ul - (dt / dx) * (f_mid_1 - f(ul))\n    u1_new_1 = ur - (dt / dx) * (f(ur) - f_mid_1)\n    \n    # Check bounds for Run 1\n    # Add a small tolerance for floating point comparisons\n    tol = 1e-9\n    bound_preserved_1 = (m0 - tol = u0_new_1 = M0 + tol) and \\\n                        (m0 - tol = u1_new_1 = M0 + tol)\n\n    # --- Run 2: Underestimated alpha ---\n    alpha2 = sigma * alpha_mid_correct\n    f_mid_2 = 0.5 * (f(ul) + f(ur)) - 0.5 * alpha2 * (ur - ul)\n\n    u0_new_2 = ul - (dt / dx) * (f_mid_2 - f(ul))\n    u1_new_2 = ur - (dt / dx) * (f(ur) - f_mid_2)\n    \n    # Check bounds for Run 2\n    bound_preserved_2 = (m0 - tol = u0_new_2 = M0 + tol) and \\\n                        (m0 - tol = u1_new_2 = M0 + tol)\n\n    return bound_preserved_1, bound_preserved_2\n\nsolve()\n```"
        },
        {
            "introduction": "前面的练习介绍了一种基本的缩放限制器，但在实际应用中，尤其是对于更高阶的方法，我们需要更稳健和高效的策略。伯恩斯坦基多项式因其优越的凸包性质，为保界限制器提供了一个极为优雅的框架。本练习  将引导你实现一个基于基变换的先进限制器：将解从常用的模态基（如勒让德基）变换到伯恩斯坦基，在伯恩斯坦系数上直接进行裁剪以保证物理边界，然后再变换回原基底。这个过程不仅能让你掌握一种强大的限制器技术，还能加深你对不同多项式基函数性质的理解。",
            "id": "3409697",
            "problem": "考虑一个一维参考单元，其坐标为 $x \\in [-1,1]$，以及到单位区间 $t \\in [0,1]$ 的仿射映射 $t = (x+1)/2$。在间断Galerkin (DG) 方法中，单元上的近似解 $u_h$ 表示为在选定基下展开的 $n$ 次多项式。三种经典的基是：Legendre多项式基 $\\{P_k(x)\\}_{k=0}^n$、第一类Chebyshev多项式基 $\\{T_k(x)\\}_{k=0}^n$ 以及Bernstein多项式基 $\\{B_k^n(t)\\}_{k=0}^n$，其中 $B_k^n(t) = \\binom{n}{k} t^k (1-t)^{n-k}$。已知Bernstein基函数在 $t \\in [0,1]$ 上是非负的，并构成单位分解，而Legendre和Chebyshev模态函数在 $x \\in [-1,1]$ 上会改变符号。保正限制器确保 $u_h \\ge 0$，而保界限制器确保对于给定的界 $U$ 有 $0 \\le u_h \\le U$。在Legendre或Chebyshev等模态基中施加的逐系数非负约束不足以保证 $u_h$ 的点态非负性，而在Bernstein基中施加的逐系数约束则可以。\n\n从以下基本基函数和性质出发：\n- Legendre多项式的三项递推关系：$P_0(x)=1$, $P_1(x)=x$，以及对于 $k \\ge 1$，$P_{k+1}(x) = \\frac{(2k+1)x P_k(x) - k P_{k-1}(x)}{k+1}$。\n- 第一类Chebyshev多项式的三项递推关系：$T_0(x)=1$, $T_1(x)=x$，以及对于 $k \\ge 1$，$T_{k+1}(x)=2x T_k(x) - T_{k-1}(x)$。\n- Bernstein基的定义 $B_k^n(t) = \\binom{n}{k} t^k (1-t)^{n-k}$，其中在 $t \\in [0,1]$ 上 $B_k^n(t) \\ge 0$ 且 $\\sum_{k=0}^n B_k^n(t) = 1$。\n- 在$n+1$个不同点上对多项式求值，可通过一个基变换线性系统唯一确定其在任何$n$次基下的系数这一事实。\n\n实现一个快速的基变换，用于将多项式变换到Bernstein基以进行限制，然后再变换回原始模态基。使用以下方法：\n- 选择 $n+1$ 个Bernstein节点 $t_j = j/n$（其中 $j=0,1,\\dots,n$，全部在 $[0,1]$ 内），并将它们映射到 $x_j = 2t_j - 1 \\in [-1,1]$。\n- 使用所述的三项递推关系，构建在点集 $\\{x_j\\}$ 上求值的Legendre多项式的求值矩阵 $E^{\\text{L}} \\in \\mathbb{R}^{(n+1)\\times(n+1)}$，并类似地构建在 $\\{x_j\\}$ 上求值的Chebyshev多项式的求值矩阵 $E^{\\text{C}}$。\n- 构建在点集 $\\{t_j\\}$ 上求值的Bernstein多项式的求值矩阵 $E^{\\text{B}} \\in \\mathbb{R}^{(n+1)\\times(n+1)}$。\n- 对于模态基中的任意系数向量，通过乘以相应的求值矩阵来计算在所选节点上的多项式值，然后求解以 $E^{\\text{B}}$ 为系数矩阵的线性系统以获得Bernstein系数。类似地，要从Bernstein基变换回模态基，则乘以 $E^{\\text{B}}$ 并求解以模态求值矩阵为系数矩阵的线性系统。\n\n使用这些变换来：\n- 通过构造反例，证明Legendre或Chebyshev基中的非负模态系数并不意味着在 $x \\in [-1,1]$ 上 $u_h \\ge 0$。\n- 证明Bernstein基中的非负系数确实意味着在 $t \\in [0,1]$ 上 $u_h \\ge 0$（通过仿射映射等价于在 $x \\in [-1,1]$ 上）。\n- 实现一个保正限制器，它将模态表示变换为Bernstein系数，将所有小于0的Bernstein系数裁剪为0，然后变换回去。\n- 实现一个保界限制器，它将Bernstein系数裁剪到 $[0,U]$ 范围内（对于给定的界 $U$），然后变换回去。\n\n构建以下测试套件，其中每个测试都需要在 $[-1,1]$ 区间内包含1001个等距点的密集网格上评估生成的多项式：\n- 测试 $1$（$n=1$ 次）：\n  - Legendre情况：系数为 $[0,1]$（即 $u_h(x) = P_1(x)$）。报告一个布尔值，指示在 $[-1,1]$ 上是否有 $u_h(x) \\ge 0$。\n  - Chebyshev情况：系数为 $[0,1]$（即 $u_h(x) = T_1(x)$）。报告一个布尔值，指示在 $[-1,1]$ 上是否有 $u_h(x) \\ge 0$。\n  - Bernstein情况：系数为 $[0,1]$（即 $u_h(t) = B_1^1(t)$）。报告一个布尔值，指示在 $[0,1]$ 上是否有 $u_h(t) \\ge 0$。\n- 测试 $2$（$n=3$ 次）：\n  - Legendre情况：系数为 $[0,0,1,0]$（即 $u_h(x) = P_2(x)$）。报告一个布尔值，指示在 $[-1,1]$ 上是否有 $u_h(x) \\ge 0$。\n  - Chebyshev情况：系数为 $[0,0,1,0]$（即 $u_h(x) = T_2(x)$）。报告一个布尔值，指示在 $[-1,1]$ 上是否有 $u_h(x) \\ge 0$。\n  - Bernstein情况：系数为 $[0.2,0.3,0.4,0.5]$。报告一个布尔值，指示在 $[0,1]$ 上是否有 $u_h(t) \\ge 0$。\n- 测试 $3$（$n=5$ 次）：Legendre情况，系数为 $[0.1,1.0,0.0,0.0,0.0,0.0]$。计算两个浮点数：在限制之前的 $u_h(x)$ 在 $[-1,1]$ 上的最小值，以及通过Bernstein裁剪应用保正限制器后的最小值。报告这两个浮点数，保留六位小数。\n- 测试 $4$（$n=4$ 次）：Legendre情况，系数为 $[0.3,0.9,-0.2,0.1,0.5]$，界为 $U=0.8$。通过Bernstein裁剪将系数限制在 $[0,U]$，变换回去，并在 $x \\in [-1,1]$ 上求值。报告两个布尔值：限制后的多项式在 $[-1,1]$ 上是否满足 $u_h(x) \\ge 0$，以及是否满足 $u_h(x) \\le U$。\n- 测试 $5$（$n=0$ 次）：Legendre情况，系数为 $[-0.2]$。应用保正限制器。报告一个浮点数：限制后在 $[-1,1]$ 上的最小值，保留六位小数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[$测试1 Legendre布尔值, 测试1 Chebyshev布尔值, 测试1 Bernstein布尔值, 测试2 Legendre布尔值, 测试2 Chebyshev布尔值, 测试2 Bernstein布尔值, 测试3 限制前的最小值（浮点数，保留六位小数）, 测试3 限制后的最小值（浮点数，保留六位小数）, 测试4 非负性布尔值, 测试4 有界性布尔值, 测试5 限制后的最小值（浮点数，保留六位小数）$]$。",
            "solution": "该问题陈述是数值分析领域中一个有效的计算练习，具体涉及用于双曲型偏微分方程的间断Galerkin (DG) 方法。它具有科学依据、是适定的、客观的，并包含构建唯一、可验证解所需的所有信息。其基本原理——Legendre、Chebyshev和Bernstein多项式基的性质，以及使用基变换实现保性质限制器——是高等数值方法中的基本概念。\n\n问题的核心是实现并利用模态多项式基（Legendre、Chebyshev）与Bernstein多项式基之间的基变换。这种变换对于在数值解 $u_h$ 上强制实施诸如保正性或保界性等物理约束至关重要。\n\n一个 $n$ 次多项式 $u_h$ 可以在不同的基中表示。在参考单元 $x \\in [-1,1]$ 上的模态基 $\\{\\phi_k(x)\\}_{k=0}^n$ 中，其表示为：\n$$\nu_h(x) = \\sum_{k=0}^n \\hat{u}_k^{\\text{M}} \\phi_k(x)\n$$\n其中 $\\hat{u}_k^{\\text{M}}$ 是模态系数（例如Legendre或Chebyshev系数）。\n\n同一个多项式可以在单位区间 $t \\in [0,1]$ 上的Bernstein基 $\\{B_k^n(t)\\}_{k=0}^n$ 中表示，其中 $t=(x+1)/2$ 是从 $x \\in [-1,1]$ 出发的仿射映射。其表示为：\n$$\nu_h(t) = \\sum_{k=0}^n \\hat{u}_k^{\\text{B}} B_k^n(t)\n$$\n其中 $B_k^n(t) = \\binom{n}{k} t^k (1-t)^{n-k}$ 且 $\\hat{u}_k^{\\text{B}}$ 是Bernstein系数。\n\n这些表示之间的变换是通过在一组 $n+1$ 个不同点上配置多项式的值来实现的。问题指定使用Bernstein节点 $t_j = j/n$（其中 $j=0, 1, \\dots, n$），它们映射到 $x_j = 2t_j - 1$。在这些节点上，两种表示必须相等：\n$$\n\\sum_{k=0}^n \\hat{u}_k^{\\text{M}} \\phi_k(x_j) = \\sum_{k=0}^n \\hat{u}_k^{\\text{B}} B_k^n(t_j) \\quad \\text{其中 } j=0, \\dots, n\n$$\n对所有 $j$ 的这个等式构成一个线性方程组：\n$$\n\\mathbf{E}^{\\text{M}} \\mathbf{\\hat{u}}^{\\text{M}} = \\mathbf{E}^{\\text{B}} \\mathbf{\\hat{u}}^{\\text{B}}\n$$\n这里，$\\mathbf{\\hat{u}}^{\\text{M}}$ 和 $\\mathbf{\\hat{u}}^{\\text{B}}$ 分别是模态系数和Bernstein系数的列向量。$\\mathbf{E}^{\\text{M}}$ 和 $\\mathbf{E}^{\\text{B}}$ 是 $(n+1) \\times (n+1)$ 的求值矩阵，其元素为 $(\\mathbf{E}^{\\text{M}})_{jk} = \\phi_k(x_j)$ 和 $(\\mathbf{E}^{\\text{B}})_{jk} = B_k^n(t_j)$。这些矩阵是可逆的。因此，变换通过求解这些线性系统给出：\n-   **模态到Bernstein**：$\\mathbf{\\hat{u}}^{\\text{B}} = (\\mathbf{E}^{\\text{B}})^{-1} \\mathbf{E}^{\\text{M}} \\mathbf{\\hat{u}}^{\\text{M}}$\n-   **Bernstein到模态**：$\\mathbf{\\hat{u}}^{\\text{M}} = (\\mathbf{E}^{\\text{M}})^{-1} \\mathbf{E}^{\\text{B}} \\mathbf{\\hat{u}}^{\\text{B}}$\n\nBernstein基的效用源于两个关键性质：\n$1$. **非负性**：对于所有 $k$ 和所有 $t \\in [0,1]$，$B_k^n(t) \\ge 0$。\n$2$. **单位分解**：对于所有 $t \\in [0,1]$，$\\sum_{k=0}^n B_k^n(t) = 1$。\n\n这些性质意味着多项式 $u_h(t)$ 包含在其Bernstein系数 $\\hat{u}_k^{\\text{B}}$ 的凸包内。具体来说，$\\min_k(\\hat{u}_k^{\\text{B}}) \\le u_h(t) \\le \\max_k(\\hat{u}_k^{\\text{B}})$。这提供了一种通过操作其Bernstein系数来强制多项式边界的直接方法。\n\n-   **保正限制器**：为确保 $u_h(x) \\ge 0$，我们将模态系数 $\\mathbf{\\hat{u}}^{\\text{M}}$ 变换为Bernstein系数 $\\mathbf{\\hat{u}}^{\\text{B}}$。然后我们将任何负系数裁剪为零，生成一组新系数 $\\hat{u}_k^{\\text{B}'} = \\max(0, \\hat{u}_k^{\\text{B}})$。生成的多项式 $u_h'(t) = \\sum_k \\hat{u}_k^{\\text{B}'} B_k^n(t)$ 保证是非负的，因为它是一个非负基函数的非负加权和。这组新的Bernstein系数随后被变换回原始模态基，以获得受限的模态系数 $\\mathbf{\\hat{u}}^{\\text{M}'}$。\n\n-   **保界限制器**：为确保对于某个上界 $U$ 有 $0 \\le u_h(x) \\le U$，遵循类似的过程。Bernstein系数被裁剪到 $[0, U]$ 范围内，即 $\\hat{u}_k^{\\text{B}'} = \\min(U, \\max(0, \\hat{u}_k^{\\text{B}}))$。非负性 $u_h'(t) \\ge 0$ 的保证与之前相同。上界则由单位分解性质保证：\n$$\nu_h'(t) = \\sum_{k=0}^n \\hat{u}_k^{\\text{B}'} B_k^n(t) \\le \\sum_{k=0}^n U \\cdot B_k^n(t) = U \\sum_{k=0}^n B_k^n(t) = U \\cdot 1 = U\n$$\n\n实现将首先通过构建函数，根据系数来评估多项式，并使用指定的三项递推关系生成必要的求值矩阵。然后，对每个测试用例，应用适当的变换和限制程序，并在 $x \\in [-1,1]$ 上的1001个点的密集网格上评估结果。\n\n测试用例旨在系统地展示这些原理：\n-   **测试 $1$ 和 $2$**：显示Legendre和Chebyshev多项式的非负模态系数可以产生带有负值的多项式，而非负的Bernstein系数则保证多项式非负。\n-   **测试 $3$**：量化保正限制器对违反非负性约束的多项式的影响。\n-   **测试 $4$**：展示保界限制器正确地强制执行下界（$0$）和上界（$U$）。\n-   **测试 $5$**：一个 $n=0$（常数函数）的简单情况，以验证限制器在最基本场景下的行为。\n\n以下Python代码实现了解决所述问题的完整过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\n\ndef eval_legendre(coeffs, x):\n    \"\"\"Evaluates a polynomial in the Legendre basis.\"\"\"\n    n = len(coeffs) - 1\n    if n  0:\n        return np.zeros_like(x)\n    \n    p_prev = np.ones_like(x)\n    val = coeffs[0] * p_prev\n    \n    if n > 0:\n        p_curr = np.copy(x)\n        val += coeffs[1] * p_curr\n    \n    for k in range(1, n):\n        # P_{k+1}(x) = ((2k+1)x P_k(x) - k P_{k-1}(x)) / (k+1)\n        p_next = ((2 * k + 1) * x * p_curr - k * p_prev) / (k + 1)\n        val += coeffs[k + 1] * p_next\n        p_prev = p_curr\n        p_curr = p_next\n        \n    return val\n\ndef eval_chebyshev(coeffs, x):\n    \"\"\"Evaluates a polynomial in the Chebyshev basis.\"\"\"\n    n = len(coeffs) - 1\n    if n  0:\n        return np.zeros_like(x)\n    \n    t_prev = np.ones_like(x)\n    val = coeffs[0] * t_prev\n    \n    if n > 0:\n        t_curr = np.copy(x)\n        val += coeffs[1] * t_curr\n        \n    for k in range(1, n):\n        # T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x)\n        t_next = 2 * x * t_curr - t_prev\n        val += coeffs[k + 1] * t_next\n        t_prev = t_curr\n        t_curr = t_next\n        \n    return val\n\ndef eval_bernstein(coeffs, t, n):\n    \"\"\"Evaluates a polynomial in the Bernstein basis.\"\"\"\n    if n  0:\n        return np.zeros_like(t)\n    \n    val = np.zeros_like(t, dtype=float)\n    for k in range(n + 1):\n        # B_k^n(t) = comb(n, k) * t^k * (1-t)^(n-k)\n        basis_func = comb(n, k) * (t**k) * ((1 - t)**(n - k))\n        val += coeffs[k] * basis_func\n        \n    return val\n\ndef get_eval_matrix(n, basis, nodes):\n    \"\"\"Generates the evaluation matrix for a given basis at specified nodes.\"\"\"\n    num_nodes = len(nodes)\n    num_coeffs = n + 1\n    E = np.zeros((num_nodes, num_coeffs))\n    \n    if basis == 'legendre':\n        p_prev = np.ones(num_nodes)\n        E[:, 0] = p_prev\n        if n > 0:\n            p_curr = np.copy(nodes)\n            E[:, 1] = p_curr\n        for k in range(1, n):\n            p_next = ((2 * k + 1) * nodes * p_curr - k * p_prev) / (k + 1)\n            E[:, k + 1] = p_next\n            p_prev = p_curr\n            p_curr = p_next\n    elif basis == 'chebyshev':\n        t_prev = np.ones(num_nodes)\n        E[:, 0] = t_prev\n        if n > 0:\n            t_curr = np.copy(nodes)\n            E[:, 1] = t_curr\n        for k in range(1, n):\n            t_next = 2 * nodes * t_curr - t_prev\n            E[:, k + 1] = t_next\n            t_prev = t_curr\n            t_curr = t_next\n    elif basis == 'bernstein':\n        for k in range(num_coeffs):\n            E[:, k] = comb(n, k) * (nodes**k) * ((1 - nodes)**(n - k))\n            \n    return E\n\ndef solve():\n    results = []\n    x_eval = np.linspace(-1, 1, 1001)\n    t_eval = (x_eval + 1) / 2\n\n    # --- Test 1 (n=1) ---\n    n1 = 1\n    # Legendre case\n    coeffs_l1 = np.array([0.0, 1.0])\n    u_h_l1 = eval_legendre(coeffs_l1, x_eval)\n    results.append(np.all(u_h_l1 >= -1e-9))\n    # Chebyshev case\n    coeffs_c1 = np.array([0.0, 1.0])\n    u_h_c1 = eval_chebyshev(coeffs_c1, x_eval)\n    results.append(np.all(u_h_c1 >= -1e-9))\n    # Bernstein case\n    coeffs_b1 = np.array([0.0, 1.0])\n    u_h_b1 = eval_bernstein(coeffs_b1, t_eval, n1)\n    results.append(np.all(u_h_b1 >= -1e-9))\n\n    # --- Test 2 (n=3) ---\n    n2 = 3\n    # Legendre case\n    coeffs_l2 = np.array([0.0, 0.0, 1.0, 0.0])\n    u_h_l2 = eval_legendre(coeffs_l2, x_eval)\n    results.append(np.all(u_h_l2 >= -1e-9))\n    # Chebyshev case\n    coeffs_c2 = np.array([0.0, 0.0, 1.0, 0.0])\n    u_h_c2 = eval_chebyshev(coeffs_c2, x_eval)\n    results.append(np.all(u_h_c2 >= -1e-9))\n    # Bernstein case\n    coeffs_b2 = np.array([0.2, 0.3, 0.4, 0.5])\n    u_h_b2 = eval_bernstein(coeffs_b2, t_eval, n2)\n    results.append(np.all(u_h_b2 >= -1e-9))\n\n    # --- Test 3 (n=5) ---\n    n3 = 5\n    coeffs_l3 = np.array([0.1, 1.0, 0.0, 0.0, 0.0, 0.0])\n    u_h_l3_before = eval_legendre(coeffs_l3, x_eval)\n    min_before = np.min(u_h_l3_before)\n    results.append(f\"{min_before:.6f}\")\n    \n    # Limiter\n    t_nodes3 = np.linspace(0, 1, n3 + 1)\n    x_nodes3 = 2 * t_nodes3 - 1\n    E_L3 = get_eval_matrix(n3, 'legendre', x_nodes3)\n    E_B3 = get_eval_matrix(n3, 'bernstein', t_nodes3)\n    \n    u_hat_B3 = np.linalg.solve(E_B3, E_L3 @ coeffs_l3)\n    u_hat_B3_limited = np.maximum(0, u_hat_B3)\n    coeffs_l3_limited = np.linalg.solve(E_L3, E_B3 @ u_hat_B3_limited)\n    \n    u_h_l3_after = eval_legendre(coeffs_l3_limited, x_eval)\n    min_after = np.min(u_h_l3_after)\n    results.append(f\"{min_after:.6f}\")\n\n    # --- Test 4 (n=4) ---\n    n4 = 4\n    U4 = 0.8\n    coeffs_l4 = np.array([0.3, 0.9, -0.2, 0.1, 0.5])\n    \n    t_nodes4 = np.linspace(0, 1, n4 + 1)\n    x_nodes4 = 2 * t_nodes4 - 1\n    E_L4 = get_eval_matrix(n4, 'legendre', x_nodes4)\n    E_B4 = get_eval_matrix(n4, 'bernstein', t_nodes4)\n    \n    u_hat_B4 = np.linalg.solve(E_B4, E_L4 @ coeffs_l4)\n    u_hat_B4_limited = np.clip(u_hat_B4, 0, U4)\n    coeffs_l4_limited = np.linalg.solve(E_L4, E_B4 @ u_hat_B4_limited)\n    \n    u_h_l4_limited = eval_legendre(coeffs_l4_limited, x_eval)\n    is_nonnegative = np.all(u_h_l4_limited >= -1e-9)\n    is_bounded = np.all(u_h_l4_limited = U4 + 1e-9)\n    results.append(is_nonnegative)\n    results.append(is_bounded)\n    \n    # --- Test 5 (n=0) ---\n    n5 = 0\n    coeffs_l5 = np.array([-0.2])\n    \n    # For n=0, the transformation is trivial. u_hat_B = u_hat_L\n    u_hat_B5_limited = np.maximum(0, coeffs_l5)\n    coeffs_l5_limited = u_hat_B5_limited\n\n    u_h_l5_limited = eval_legendre(coeffs_l5_limited, x_eval)\n    min_after_5 = np.min(u_h_l5_limited)\n    results.append(f\"{min_after_5:.6f}\")\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}