{
    "hands_on_practices": [
        {
            "introduction": "The effectiveness of a Strong Stability Preserving (SSP) method is quantified by its SSP coefficient, which dictates the maximum allowable time step. This practice delves into the theoretical foundations of SSP methods by framing the search for the optimal scheme as a constrained optimization problem. By analyzing a general three-step linear multistep method, you will derive the maximum possible SSP coefficient, revealing fundamental limits that govern this class of integrators .",
            "id": "3420318",
            "problem": "Consider a method-of-lines semi-discretization of a scalar hyperbolic conservation law by a Discontinuous Galerkin (DG) spatial discretization that is monotone under Forward Euler time stepping with time step bound $\\Delta t \\leq \\Delta t_{\\mathrm{FE}}$. That is, for the semi-discrete system $\\frac{\\mathrm{d}}{\\mathrm{d}t} y(t) = f(y(t))$, the Forward Euler update $y^{n+1} = y^{n} + \\Delta t f(y^{n})$ is monotone for $\\Delta t \\leq \\Delta t_{\\mathrm{FE}}$. An explicit 3-step linear multistep method is of the form\n$$\ny^{n+1} = a_{0} y^{n} + a_{1} y^{n-1} + a_{2} y^{n-2} + \\Delta t\\big(b_{0} f(y^{n}) + b_{1} f(y^{n-1}) + b_{2} f(y^{n-2})\\big).\n$$\nThe strong stability preserving (SSP) coefficient $C$ of this method is the largest value such that the method is monotone under the CFL-like restriction $\\Delta t \\leq C\\,\\Delta t_{\\mathrm{FE}}$, provided the method can be written as a convex combination of Forward Euler steps applied to previously available solution values. Under the sufficient SSP conditions that the coefficients associated with convex combination and Forward Euler substeps are nonnegative, the method must satisfy $a_{j} \\geq 0$, $b_{j} \\geq 0$ for $j \\in \\{0,1,2\\}$, and there must exist $r \\geq 0$ such that $a_{j} - r b_{j} \\geq 0$ for $j \\in \\{0,1,2\\}$. Imposing first-order consistency by requiring exactness on $y(t) = 1$ and $y(t) = t$ gives the constraints $\\sum_{j=0}^{2} a_{j} = 1$ and $\\sum_{j=0}^{2} b_{j} = 1 + \\sum_{j=0}^{2} j a_{j}$.\n\nSet up the problem of finding the maximal SSP coefficient $C$ for this 3-step, first-order explicit SSP linear multistep method as a linear program in the sense that for a fixed $r$, feasibility is determined by linear inequalities and equalities in the unknown coefficients. Then solve this optimization problem exactly to determine the maximal achievable $C$ under these nonnegativity and consistency constraints. Your final answer must be a single exact number. Do not round. Express the final answer without units.",
            "solution": "The problem asks for the maximal strong stability preserving (SSP) coefficient $C$ for a class of 3-step explicit linear multistep methods. The method must be first-order consistent and satisfy a set of sufficient conditions for being SSP.\n\nFirst, we formalize the optimization problem. The variables are the method coefficients $a_0, a_1, a_2, b_0, b_1, b_2$ and the SSP coefficient $C$. We seek to maximize $C$ subject to the given constraints.\n\nThe method is given by:\n$$ y^{n+1} = \\sum_{j=0}^{2} a_{j} y^{n-j} + \\Delta t\\sum_{j=0}^{2} b_{j} f(y^{n-j}) $$\n\nThe constraints are:\n1.  First-order consistency:\n    a. Exactness on $y(t) = 1$: $\\sum_{j=0}^{2} a_{j} = 1$. Let's label this (C1).\n    b. Exactness on $y(t) = t$: $\\sum_{j=0}^{2} b_{j} = 1 + \\sum_{j=0}^{2} j a_{j} = 1 + a_1 + 2a_2$. Let's label this (C2).\n\n2.  Sufficient SSP conditions:\n    a. Non-negativity of coefficients in the convex combination: $a_{j} \\geq 0$ for $j \\in \\{0,1,2\\}$. Let's label this (S1).\n    b. Non-negativity of coefficients for Forward Euler steps: $b_{j} \\geq 0$ for $j \\in \\{0,1,2\\}$. Let's label this (S2).\n    c. The existence of a parameter $r \\geq 0$ such that $a_{j} - r b_{j} \\geq 0$ for $j \\in \\{0,1,2\\}$. This parameter $r$ is the SSP coefficient, which we denote by $C$. So, $a_j - C b_j \\ge 0$ for $j \\in \\{0,1,2\\}$, and we seek to maximize $C \\geq 0$. Let's label this (S3).\n\nThe problem asks to formulate this as a linear program for a fixed value of the SSP coefficient, denoted as $r$ in the problem description. Let us fix $C = C_{\\text{fixed}} > 0$. The problem then becomes a feasibility problem: to find if there exist coefficients $\\{a_j, b_j\\}_{j=0}^2$ that satisfy all the constraints. This can be expressed as a linear program by setting an arbitrary constant objective function, e.g., maximizing $0$.\n\nThe linear program for a fixed $C_{\\text{fixed}}$ is:\nFind $a_0, a_1, a_2, b_0, b_1, b_2$.\nObjective: Maximize $0$.\nSubject to:\n- $a_0 + a_1 + a_2 = 1$\n- $b_0 + b_1 + b_2 - a_1 - 2 a_2 = 1$\n- $a_j \\geq 0$ for $j \\in \\{0, 1, 2\\}$\n- $b_j \\geq 0$ for $j \\in \\{0, 1, 2\\}$\n- $a_j - C_{\\text{fixed}} b_j \\geq 0$ for $j \\in \\{0, 1, 2\\}$\n\nThe overall goal is to find the maximum value of $C$ for which this linear program is feasible. We can solve this optimization problem analytically.\n\nLet's combine the constraints to derive an upper bound on $C$.\nFrom (S3), we have $a_j \\geq C b_j$ for each $j \\in \\{0, 1, 2\\}$.\nSumming this inequality over $j=0, 1, 2$:\n$$ \\sum_{j=0}^{2} a_j \\geq \\sum_{j=0}^{2} C b_j = C \\sum_{j=0}^{2} b_j $$\nNow, we substitute the consistency conditions (C1) and (C2) into this inequality:\n$$ 1 \\geq C (1 + a_1 + 2a_2) $$\nSince we are maximizing $C$, we can assume $C > 0$. For this inequality to hold, we must have $1 + a_1 + 2a_2 > 0$. The condition (S1) requires $a_1 \\geq 0$ and $a_2 \\geq 0$, so this is always satisfied.\nWe can rearrange the inequality to find an upper bound for $C$:\n$$ C \\leq \\frac{1}{1 + a_1 + 2a_2} $$\nThis inequality must be satisfied by any method of the given form. To find the maximum possible value of $C$, we must find the tightest possible upper bound. This is achieved by maximizing the expression on the right-hand side, which is equivalent to minimizing its denominator, $g(a_1, a_2) = 1 + a_1 + 2a_2$.\n\nThe minimization of $g(a_1, a_2)$ is subject to the constraints on the coefficients $a_j$. From (S1), we have $a_1 \\geq 0$ and $a_2 \\geq 0$. From (C1) and (S1), we have $a_0 = 1 - a_1 - a_2 \\geq 0$, which implies $a_1 + a_2 \\leq 1$.\nThe domain for the variables $(a_1, a_2)$ is a closed and bounded triangle in the plane with vertices at $(0,0)$, $(1,0)$, and $(0,1)$. The function $g(a_1, a_2)$ is a linear function of $a_1$ and $a_2$. The minimum of a linear function over a convex polygon must occur at one of its vertices. We evaluate $g$ at each vertex:\n- At $(a_1, a_2) = (0,0)$: $g(0,0) = 1 + 0 + 2(0) = 1$.\n- At $(a_1, a_2) = (1,0)$: $g(1,0) = 1 + 1 + 2(0) = 2$.\n- At $(a_1, a_2) = (0,1)$: $g(0,1) = 1 + 0 + 2(1) = 3$.\n\nThe minimum value of the denominator $1 + a_1 + 2a_2$ is $1$, which occurs when $a_1 = 0$ and $a_2 = 0$.\nSubstituting this minimum value into the inequality for $C$, we obtain the maximal possible value for the upper bound:\n$$ C \\leq \\frac{1}{1} = 1 $$\nThis demonstrates that no method within the specified class can have an SSP coefficient greater than $1$.\n\nTo prove that $1$ is indeed the maximum achievable SSP coefficient, we must show that there exists a set of coefficients $\\{a_j, b_j\\}$ that satisfies all the given conditions for $C=1$. Let's try to construct such a method using the values that yielded the upper bound:\nSet $C=1$. From our minimization, we should choose $a_1=0$ and $a_2=0$.\nFrom (C1), $a_0 = 1 - a_1 - a_2 = 1 - 0 - 0 = 1$.\nSo, we have $a_0 = 1, a_1 = 0, a_2 = 0$.\n\nNow we must find coefficients $b_j$ that satisfy the remaining constraints:\n- (S2): $b_j \\geq 0$ for $j \\in \\{0, 1, 2\\}$.\n- (S3) with $C=1$: $a_j \\geq b_j$.\n    - For $j=0$: $1 \\geq b_0$.\n    - For $j=1$: $0 \\geq b_1$.\n    - For $j=2$: $0 \\geq b_2$.\n- (C2): $\\sum_{j=0}^{2} b_j = 1 + a_1 + 2a_2 = 1 + 0 + 2(0) = 1$.\n\nFrom $b_1 \\geq 0$ and $0 \\geq b_1$, we must have $b_1 = 0$.\nSimilarly, from $b_2 \\geq 0$ and $0 \\geq b_2$, we must have $b_2 = 0$.\nSubstituting these into the sum from (C2):\n$b_0 + 0 + 0 = 1 \\implies b_0 = 1$.\n\nLet's verify this set of coefficients: $a_0=1, a_1=0, a_2=0$ and $b_0=1, b_1=0, b_2=0$, with $C=1$.\n- (C1): $1+0+0 = 1$. (OK)\n- (C2): $1+0+0 = 1$ and $1+0+2(0)=1$. (OK)\n- (S1): $a_j \\geq 0$. (OK)\n- (S2): $b_j \\geq 0$. (OK)\n- (S3): $a_0 - Cb_0 = 1 - 1(1) = 0 \\geq 0$. $a_1 - Cb_1 = 0 - 1(0) = 0 \\geq 0$. $a_2 - Cb_2 = 0 - 1(0) = 0 \\geq 0$. (OK)\n\nAll conditions are satisfied. The method corresponding to these coefficients is:\n$$ y^{n+1} = 1 \\cdot y^n + \\Delta t(1 \\cdot f(y^n)) = y^n + \\Delta t f(y^n) $$\nThis is the Forward Euler method. By the definition of the problem, Forward Euler is monotone for $\\Delta t \\leq \\Delta t_{\\mathrm{FE}}$, which means its SSP coefficient is $C=1$.\n\nSince we have shown that $C \\leq 1$ for any method in the specified class and we have explicitly constructed a method for which $C=1$, the maximal achievable SSP coefficient is $1$.",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "Theoretical properties like strong stability are most meaningful when they translate to improved behavior in numerical simulations. This hands-on coding exercise is designed to visually and quantitatively demonstrate the practical advantage of using an SSP time integrator for hyperbolic problems. You will implement and compare an SSP Runge-Kutta method against a classical non-SSP counterpart, verifying that only the SSP scheme preserves the Total Variation Diminishing (TVD) property essential for capturing sharp features without spurious oscillations .",
            "id": "3420259",
            "problem": "Consider the scalar linear advection equation on a periodic domain,\n$$u_t + a\\,u_x = 0,$$\nposed on the interval $[0,1]$ with periodic boundary conditions and constant advection speed $a>0$. Discretize the spatial domain into $N$ uniform cells of width $\\Delta x = 1/N$ and consider the Discontinuous Galerkin (DG) formulation with polynomial degree zero (piecewise constant basis), together with the upwind numerical flux. Derive the semi-discrete ordinary differential equation for the cell averages from the DG weak form using the following fundamental elements:\n- the definition of the DG method with piecewise constant basis functions,\n- the construction of numerical fluxes at cell interfaces consistent with upwinding for $a>0$,\n- periodic boundary conditions interpreted in the flux evaluation.\n\nUsing the derived semi-discrete operator, implement two explicit time integrators:\n- the Strong Stability Preserving Runge-Kutta method of order three with three stages (SSPRK($3,3$)), based on its property that it can be expressed as a convex combination of forward Euler steps when the forward Euler method is stable under a time-step restriction,\n- a comparable non-Strong Stability Preserving method, the classical fourth-order explicit Runge-Kutta method (RK4).\n\nDefine the discrete total variation of the cell averages at time $t^n$ as\n$$TV(u^n) = \\sum_{i=0}^{N-1} \\left|u_{i+1}^n - u_i^n\\right|,$$\nwith periodic indexing so that $u_N^n = u_0^n$.\n\nYour task is to numerically verify the Total Variation Diminishing (TVD) behavior for SSPRK($3,3$) and demonstrate a violation for RK4 by integrating the semi-discrete system forward in time. For each time step, compute $TV(u^n)$ and check that the sequence $\\{TV(u^n)\\}_{n\\ge 0}$ is nonincreasing, that is, $TV(u^{n+1}) \\le TV(u^n)$ up to a small numerical tolerance.\n\nUse the following test suite, each specified by $N$, the Courant number $\\nu = a\\,\\Delta t/\\Delta x$ with $a=1$, the number of time steps $n_\\text{steps}$, and the initial data:\n- Test Case 1 (happy path with sharp discontinuity at coarse resolution): $N=50$, $\\nu=0.99$, $n_\\text{steps}=12$, initial data\n  $$u(x,0) = \\begin{cases}\n  0 & \\text{if } x \\in [0,0.45),\\\\\n  1 & \\text{if } x \\in [0.45,0.55),\\\\\n  0 & \\text{if } x \\in [0.55,1),\n  \\end{cases}$$\n  interpreted cellwise with periodic boundary conditions.\n- Test Case 2 (moderate resolution square pulse): $N=200$, $\\nu=0.90$, $n_\\text{steps}=20$, initial data\n  $$u(x,0) = \\begin{cases}\n  1 & \\text{if } x \\in [0.30,0.70),\\\\\n  0 & \\text{otherwise},\n  \\end{cases}$$\n  interpreted cellwise with periodic boundary conditions.\n- Test Case 3 (three-level piecewise constant): $N=100$, $\\nu=1.00$, $n_\\text{steps}=15$, initial data\n  $$u(x,0) = \\begin{cases}\n  -0.5 & \\text{if } x \\in [0.00,0.20),\\\\\n  1.0 & \\text{if } x \\in [0.20,0.50),\\\\\n  0.0 & \\text{if } x \\in [0.50,1.00),\n  \\end{cases}$$\n  interpreted cellwise with periodic boundary conditions.\n\nFor each test case, compute two boolean outputs:\n- a boolean indicating whether the SSPRK($3,3$) method produced a nonincreasing total variation sequence over all time steps,\n- a boolean indicating whether the RK4 method produced a nonincreasing total variation sequence over all time steps.\n\nThe final time step size must satisfy $\\Delta t = \\nu\\,\\Delta x/a$. The program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test result is a two-element list $[b_\\text{SSP}, b_\\text{RK4}]$. For the three test cases above, the final output format must be\n$[[b_{1,\\text{SSP}},b_{1,\\text{RK4}}],\\,[b_{2,\\text{SSP}},b_{2,\\text{RK4}}],\\,[b_{3,\\text{SSP}},b_{3,\\text{RK4}}]],$\nwith booleans printed in the language's native boolean literals. No physical units or angles are involved in this problem; all quantities are nondimensional.",
            "solution": "The problem is to numerically investigate the Total Variation Diminishing (TVD) property of two time integration schemes, SSPRK($3,3$) and classical RK4, when applied to a semi-discretization of the linear advection equation. The spatial discretization is a Discontinuous Galerkin (DG) method with piecewise constant basis functions ($p=0$) and an upwind flux.\n\n**1. Semi-Discretization using the Discontinuous Galerkin Method**\n\nThe governing partial differential equation (PDE) is the linear advection equation:\n$$\nu_t + a\\,u_x = 0\n$$\non the domain $[0,1]$ with periodic boundary conditions and constant advection speed $a>0$.\n\nThe domain is partitioned into $N$ cells $I_i = [x_{i-1/2}, x_{i+1/2}]$ for $i=0, \\dots, N-1$, each of width $\\Delta x = 1/N$. The cell interfaces are at $x_{i+1/2} = (i+1)\\Delta x$. Within each cell $I_i$, the solution is approximated by a piecewise constant function (polynomial degree $p=0$):\n$$\nu_h(x,t) = u_i(t) \\quad \\text{for } x \\in I_i\n$$\nThe value $u_i(t)$ represents the cell average of the solution in cell $I_i$.\n\nThe DG weak formulation is obtained by multiplying the PDE by a test function $v_h$, integrating over a cell $I_i$, and performing integration by parts on the spatial term:\n$$\n\\int_{I_i} (u_h)_t v_h \\,dx - \\int_{I_i} a\\,u_h (v_h)_x \\,dx + [a\\,u_h v_h]_{x_{i-1/2}}^{x_{i+1/2}} = 0\n$$\nSince the basis and test functions are piecewise constant, $(v_h)_x=0$ inside the cell. The equation simplifies to:\n$$\n\\int_{I_i} \\frac{du_i}{dt} v_h \\,dx + \\left( a\\,u_h(x_{i+1/2}, t)v_h(x_{i+1/2}^-) - a\\,u_h(x_{i-1/2}, t)v_h(x_{i-1/2}^+) \\right) = 0\n$$\nThe term $a\\,u_h$ at the cell interfaces is discontinuous and must be replaced by a single-valued numerical flux, denoted $\\hat{f}(u_L, u_R)$, where $u_L$ and $u_R$ are the states on the left and right of the interface, respectively. For the physical flux $f(u) = au$, the weak form becomes:\n$$\n\\int_{I_i} \\frac{du_i}{dt} v_h \\,dx + \\left( \\hat{f}(u_h(x_{i+1/2}^-), u_h(x_{i+1/2}^+)) v_h(x_{i+1/2}^-) - \\hat{f}(u_h(x_{i-1/2}^-), u_h(x_{i-1/2}^+)) v_h(x_{i-1/2}^+) \\right) = 0\n$$\nChoosing the test function $v_h$ to be $1$ in cell $I_i$ and $0$ elsewhere, we have $v_h(x_{i+1/2}^-) = 1$ and $v_h(x_{i-1/2}^+) = 1$. The integral of the time derivative is $\\Delta x \\frac{du_i}{dt}$. The states at the interfaces are $u_h(x_{i+1/2}^-) = u_i$, $u_h(x_{i+1/2}^+) = u_{i+1}$, $u_h(x_{i-1/2}^-) = u_{i-1}$, and $u_h(x_{i-1/2}^+) = u_i$. This leads to:\n$$\n\\Delta x \\frac{du_i}{dt} + \\hat{f}(u_i, u_{i+1}) - \\hat{f}(u_{i-1}, u_i) = 0\n$$\nThe problem specifies an upwind flux for $a > 0$, which is $\\hat{f}(u_L, u_R) = f(u_L) = a u_L$. Applying this to our interfaces:\n- At $x_{i+1/2}$: $\\hat{f}(u_i, u_{i+1}) = a u_i$.\n- At $x_{i-1/2}$: $\\hat{f}(u_{i-1}, u_i) = a u_{i-1}$.\n\nSubstituting these fluxes into the equation gives:\n$$\n\\Delta x \\frac{du_i}{dt} + a u_i - a u_{i-1} = 0\n$$\nRearranging, we obtain the semi-discrete system of ordinary differential equations (ODEs) for the cell averages:\n$$\n\\frac{du_i}{dt} = -\\frac{a}{\\Delta x} (u_i - u_{i-1})\n$$\nwith periodic indexing such that $u_{-1} \\equiv u_{N-1}$. This is the well-known first-order upwind finite difference scheme. We can write this system in vector form as $\\frac{d\\mathbf{u}}{dt} = L(\\mathbf{u})$, where $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$ and $(L(\\mathbf{u}))_i = -\\frac{a}{\\Delta x} (u_i - u_{i-1})$.\n\n**2. Time Integration Schemes**\n\nThe forward Euler method applied to this system, $u_i^{n+1} = u_i^n + \\Delta t L(u^n)_i$, results in:\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n) = (1-\\nu)u_i^n + \\nu u_{i-1}^n\n$$\nwhere $\\nu = \\frac{a \\Delta t}{\\Delta x}$ is the Courant number. This scheme is TVD if $0 \\le \\nu \\le 1$.\n\n**a) Strong Stability Preserving Runge-Kutta (SSPRK(3,3))**\nThis third-order, three-stage method is designed to preserve stability properties like TVD of the forward Euler method. Its formulation is:\n$$\n\\mathbf{u}^{(1)} = \\mathbf{u}^n + \\Delta t L(\\mathbf{u}^n)\n$$\n$$\n\\mathbf{u}^{(2)} = \\frac{3}{4} \\mathbf{u}^n + \\frac{1}{4} \\left( \\mathbf{u}^{(1)} + \\Delta t L(\\mathbf{u}^{(1)}) \\right)\n$$\n$$\n\\mathbf{u}^{n+1} = \\frac{1}{3} \\mathbf{u}^n + \\frac{2}{3} \\left( \\mathbf{u}^{(2)} + \\Delta t L(\\mathbf{u}^{(2)}) \\right)\n$$\nSSPRK($3,3$) can be viewed as a convex combination of forward Euler steps. It is TVD if the forward Euler method is TVD and the time step satisfies $\\Delta t \\le c \\cdot \\Delta t_{\\text{FE,TVD}}$, where $c$ is the SSP coefficient. For this scheme, $c=1$. Therefore, SSPRK($3,3$) is expected to be TVD for our semi-discretization whenever $\\nu \\le 1$. All test cases satisfy this condition.\n\n**b) Classical Fourth-Order Runge-Kutta (RK4)**\nThe standard RK4 method is given by:\n$$\n\\mathbf{k}_1 = L(\\mathbf{u}^n)\n$$\n$$\n\\mathbf{k}_2 = L(\\mathbf{u}^n + \\frac{\\Delta t}{2} \\mathbf{k}_1)\n$$\n$$\n\\mathbf{k}_3 = L(\\mathbf{u}^n + \\frac{\\Delta t}{2} \\mathbf{k}_2)\n$$\n$$\n\\mathbf{k}_4 = L(\\mathbf{u}^n + \\Delta t \\mathbf{k}_3)\n$$\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nRK4 is not an SSP method. It is not guaranteed to be TVD for nonlinear problems or even for linear problems with non-smooth solutions, as it can introduce spurious oscillations near discontinuities, which increases the total variation.\n\n**3. Total Variation and Numerical Verification**\n\nThe discrete total variation is defined as:\n$$\nTV(\\mathbf{u}^n) = \\sum_{i=0}^{N-1} |u_{i+1}^n - u_i^n|\n$$\nwhere periodic indexing implies $u_N^n = u_0^n$. A scheme is TVD if $TV(\\mathbf{u}^{n+1}) \\le TV(\\mathbf{u}^n)$ for all $n$. For the numerical verification, we will check this condition at each time step for both SSPRK($3,3$) and RK4. Due to floating-point arithmetic, the check is implemented as $TV(\\mathbf{u}^{n+1}) \\le TV(\\mathbf{u}^n) + \\epsilon$, where $\\epsilon$ is a small tolerance (e.g., $10^{-12}$). A boolean flag for each method will record whether the TVD property holds for the entire simulation.\n\nThe implementation will proceed by defining the initial conditions for each test case, setting up the spatial operator $L(\\mathbf{u})$, and then iterating for the specified number of steps with each time integration scheme, checking the total variation at each step.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by running three test cases to verify the TVD property\n    of SSPRK(3,3) and the violation of this property by RK4 for a DG-discretized\n    advection equation.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"N\": 50, \"nu\": 0.99, \"n_steps\": 12,\n            \"u0_func\": lambda x: np.where((x >= 0.45) & (x < 0.55), 1.0, 0.0)\n        },\n        {\n            \"N\": 200, \"nu\": 0.90, \"n_steps\": 20,\n            \"u0_func\": lambda x: np.where((x >= 0.30) & (x < 0.70), 1.0, 0.0)\n        },\n        {\n            \"N\": 100, \"nu\": 1.00, \"n_steps\": 15,\n            \"u0_func\": lambda x: np.select(\n                [x < 0.20, (x >= 0.20) & (x < 0.50), x >= 0.50],\n                [-0.5, 1.0, 0.0]\n            )\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        N = params[\"N\"]\n        nu = params[\"nu\"]\n        n_steps = params[\"n_steps\"]\n        u0_func = params[\"u0_func\"]\n        \n        # SSPRK(3,3) and RK4 have different stability regions for advection.\n        # However, the problem sets nu <= 1, which for the first-order upwind\n        # operator is within the stability regions of both methods.\n        b_ssp, b_rk4 = run_test_case(N, nu, n_steps, u0_func)\n        results.append([b_ssp, b_rk4])\n\n    # Convert native Python bools to lowercase strings for the final output.\n    # The problem description's example `[b_SSP, b_RK4]` suggests a list of lists of booleans,\n    # which in Python's f-string formatting would be `[[True, False], ...]`.\n    # Let's adjust to match the required `print` format.\n    formatted_results = [f\"[{str(r[0])}, {str(r[1])}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef get_spatial_operator(a, dx):\n    \"\"\"Returns the spatial operator L(u) for the semi-discretization.\"\"\"\n    def L(u):\n        # u_i - u_{i-1} with periodic boundaries\n        diff = u - np.roll(u, 1)\n        return -a / dx * diff\n    return L\n    \ndef total_variation(u):\n    \"\"\"Computes the total variation of a 1D array with periodic boundaries.\"\"\"\n    return np.sum(np.abs(u - np.roll(u, -1)))\n\ndef run_test_case(N, nu, n_steps, u0_func):\n    \"\"\"\n    Runs a single test case for both SSPRK(3,3) and RK4, checking the TVD property.\n\n    Returns:\n        A tuple of two booleans: (ssp_is_tvd, rk4_is_tvd)\n    \"\"\"\n    a = 1.0\n    dx = 1.0 / N\n    dt = nu * dx / a\n\n    # Define cell centers and initial condition\n    x = (np.arange(N) + 0.5) * dx\n    u0 = u0_func(x)\n\n    L = get_spatial_operator(a, dx)\n    \n    # Tolerance for floating point comparison of TV\n    tolerance = 1e-12\n\n    # --- SSPRK(3,3) Simulation ---\n    u_ssp = u0.copy()\n    ssp_is_tvd = True\n    tv_old = total_variation(u_ssp)\n    for _ in range(n_steps):\n        # SSPRK(3,3) steps\n        u1 = u_ssp + dt * L(u_ssp)\n        u2 = 0.75 * u_ssp + 0.25 * (u1 + dt * L(u1))\n        u_ssp = (1/3.0) * u_ssp + (2/3.0) * (u2 + dt * L(u2))\n        \n        tv_new = total_variation(u_ssp)\n        if tv_new > tv_old + tolerance:\n            ssp_is_tvd = False\n        tv_old = tv_new\n\n    # --- RK4 Simulation ---\n    u_rk4 = u0.copy()\n    rk4_is_tvd = True\n    tv_old = total_variation(u_rk4)\n    for _ in range(n_steps):\n        # RK4 steps\n        k1 = L(u_rk4)\n        k2 = L(u_rk4 + 0.5 * dt * k1)\n        k3 = L(u_rk4 + 0.5 * dt * k2)\n        k4 = L(u_rk4 + dt * k3)\n        u_rk4 = u_rk4 + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n        \n        tv_new = total_variation(u_rk4)\n        if tv_new > tv_old + tolerance:\n            rk4_is_tvd = False\n        tv_old = tv_new\n        \n    return ssp_is_tvd, rk4_is_tvd\n\nsolve()\n```"
        },
        {
            "introduction": "The guarantee provided by SSP methods is powerful but conditional: it relies on the underlying forward Euler step possessing the desired stability property. This exercise explores what happens when this condition is broken, a common scenario when dealing with nonlinear source terms. By constructing a counterexample, you will demonstrate the failure of a standard SSP method to preserve positivity and then implement a robust fix, illustrating a crucial technique for handling complex physical models where the standard SSP framework is insufficient .",
            "id": "3420247",
            "problem": "Consider the semi-discrete discontinuous Galerkin (DG) method of polynomial degree zero (piecewise constant) for the scalar linear advection-reaction equation in one spatial dimension,\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = S(u),\n$$\nwhere $a \\in \\mathbb{R}$ is a constant advection speed and $S(u)$ is a nonlinear source term applied pointwise to cell averages. The DG semi-discretization with an upwind numerical flux for $a \\ge 0$ on a uniform mesh of cells of width $h$ yields the ordinary differential equation (ODE) for the vector of cell-averaged unknowns $u(t) \\in \\mathbb{R}^N$,\n$$\n\\frac{d u_i}{d t} = L_i(u) + S(u_i), \\quad L_i(u) = -\\frac{a}{h}\\left(u_i - u_{i-1}\\right),\n$$\nfor $i = 0, 1, \\dots, N-1$, with periodic indexing $u_{-1} := u_{N-1}$. The forward Euler method applied to the full operator $F(u) := L(u) + S(u)$ is\n$$\nu^{n+1} = u^n + \\Delta t \\, F(u^n).\n$$\nStrong Stability Preserving (SSP) explicit Runge–Kutta methods are defined by the property that the numerical update can be written as a convex combination of forward Euler steps applied to $F(u)$, which guarantees the preservation of any convex stability property that forward Euler preserves under a time-step restriction. In particular, a method is SSP with respect to a convex functional $\\Phi(u)$ if there exists a coefficient $c > 0$ such that, whenever forward Euler satisfies $\\Phi\\left(u^n + \\Delta t \\, F(u^n)\\right) \\le \\Phi(u^n)$ for all $0 \\le \\Delta t \\le \\Delta t_{\\mathrm{FE}}$, then the SSP method satisfies $\\Phi(u^{n+1}) \\le \\Phi(u^n)$ for all $0 \\le \\Delta t \\le c \\, \\Delta t_{\\mathrm{FE}}$.\n\nThis problem asks you to construct a counterexample, within the DG context above, showing that SSP fails when a nonlinear source term breaks forward Euler monotonicity with respect to the positivity cone\n$$\n\\mathcal{C}_+ := \\left\\{ u \\in \\mathbb{R}^N \\,:\\, u_i \\ge 0 \\text{ for all } i \\right\\}.\n$$\nSpecifically, take the nonlinear source\n$$\nS(u) = -k \\sqrt{u}, \\quad k > 0,\n$$\nacting componentwise on $u$ with the convention $S(0) = 0$. The exact evolution under the source-only ODE $\\dot{u} = S(u)$ preserves the nonnegativity invariant set $\\mathcal{C}_+$, i.e., $u(t) \\in \\mathcal{C}_+$ for all $t \\ge 0$ if $u(0) \\in \\mathcal{C}_+$. However, the forward Euler method applied to $S(u)$ can violate nonnegativity for arbitrarily small time steps $\\Delta t > 0$ when $u$ is sufficiently small.\n\nYou must:\n- Implement the DG forward Euler flux update\n$$\n\\mathrm{FE\\_flux}(u) := u + \\Delta t \\, L(u),\n$$\nwith $L(u)$ defined above for periodic boundary conditions.\n- Implement the forward Euler update for the full operator $F(u) = L(u) + S(u)$.\n- Implement the Strong Stability Preserving third-order Runge–Kutta method (Shu–Osher form) applied to the full operator $F(u)$:\n  1. $u^{(1)} = u^n + \\Delta t \\, F(u^n)$,\n  2. $u^{(2)} = \\frac{3}{4} u^n + \\frac{1}{4}\\left(u^{(1)} + \\Delta t \\, F(u^{(1)})\\right)$,\n  3. $u^{n+1} = \\frac{1}{3} u^n + \\frac{2}{3}\\left(u^{(2)} + \\Delta t \\, F(u^{(2)})\\right)$.\n- Derive and implement the exact source evolution over a time step $\\Delta t$ for the ODE $\\dot{u} = -k \\sqrt{u}$ applied componentwise:\n  Starting from the separable equation $2 \\frac{d}{dt} \\sqrt{u} = -k$, one obtains the exact update\n  $$\n  \\sqrt{u^{n+1}} = \\max\\left( \\sqrt{u^n} - \\frac{k \\Delta t}{2}, \\, 0 \\right), \\quad\\text{thus}\\quad\n  u^{n+1} = \\left( \\max\\left( \\sqrt{u^n} - \\tfrac{k \\Delta t}{2}, \\, 0 \\right) \\right)^2.\n  $$\n- Build a positivity-preserving correction step by a convex blend of exact source evolution with a forward Euler flux update,\n$$\nu^{n+1}_{\\mathrm{blend}} = \\theta \\, \\mathrm{ExactSource}(u^n) + (1 - \\theta) \\, \\mathrm{FE\\_flux}(u^n), \\quad \\theta \\in [0,1],\n$$\nand argue why it preserves $\\mathcal{C}_+$ when $\\mathrm{FE\\_flux}$ preserves nonnegativity (e.g., under a Courant–Friedrichs–Lewy condition such as $a \\Delta t / h \\le 1$) and ExactSource preserves nonnegativity.\n\nYour program shall generate a counterexample that demonstrates violation of nonnegativity by the forward Euler method and by SSP Runge–Kutta on the full operator $F$, and then show that the convex blend correction preserves nonnegativity. Use the following test suite. For each test case, you are given:\n- $N$: number of DG cells,\n- $a$: advection speed,\n- $h$: cell width,\n- $\\Delta t$: time step,\n- $k$: source strength,\n- $\\theta$: blend parameter,\n- $u^0$: initial vector of cell averages.\n\nTest suite:\n1. $N=1$, $a=0.0$, $h=1.0$, $\\Delta t=0.1$, $k=10.0$, $\\theta=0.5$, $u^0 = [10^{-8}]$.\n2. $N=3$, $a=1.0$, $h=1.0$, $\\Delta t=0.2$, $k=10.0$, $\\theta=0.5$, $u^0 = [1.0, 10^{-6}, 0.5]$.\n3. $N=3$, $a=1.0$, $h=1.0$, $\\Delta t=0.5$, $k=10.0$, $\\theta=0.5$, $u^0 = [0.0, 0.0, 0.0]$.\n4. $N=3$, $a=1.0$, $h=1.0$, $\\Delta t=10^{-4}$, $k=10.0$, $\\theta=0.5$, $u^0 = [1.0, 10^{-2}, 0.5]$.\n\nFor each test case, compute three booleans indicating whether the minimum of $u^{n+1}$ is nonnegative for:\n- the forward Euler update applied to $F(u)$,\n- the third-order SSP Runge–Kutta update applied to $F(u)$,\n- the blended correction $u^{n+1}_{\\mathrm{blend}}$.\n\nThe final output format must be a single line containing a list of lists, one inner list per test case, each inner list containing exactly three booleans in the order described above. For example,\n$[\\mathrm{True}, \\mathrm{False}, \\mathrm{True}], [\\dots], \\dots$\n\nNo physical units are required for this problem. Angles are not involved. Percentages are not involved. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with Python boolean literals.",
            "solution": "The problem requires the construction of a numerical counterexample to demonstrate the failure of Strong Stability Preserving (SSP) time integration methods for a system where the underlying Forward Euler (FE) method does not preserve a desired convexity property, specifically non-negativity of the solution. The context is a semi-discrete discontinuous Galerkin (DG) method for a scalar advection-reaction equation.\n\nThe governing partial differential equation is the one-dimensional advection-reaction equation:\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = S(u)\n$$\nwhere $a \\in \\mathbb{R}$ is a constant advection speed and $S(u)$ is a nonlinear source term.\n\nUpon discretization with a DG method of order zero (piecewise constant basis functions) on a uniform grid with cell width $h$ and an upwind flux for $a \\ge 0$, the system of ordinary differential equations (ODEs) for the cell averages $u_i(t)$ is given by:\n$$\n\\frac{d u_i}{d t} = L_i(u) + S(u_i), \\quad \\text{for } i = 0, 1, \\dots, N-1\n$$\nThis can be written in vector form as $\\frac{d u}{d t} = F(u)$, where $F(u) = L(u) + S(u)$. The spatial operator $L(u)$ and source operator $S(u)$ are defined component-wise as:\n$$\nL_i(u) = -\\frac{a}{h}\\left(u_i - u_{i-1}\\right) \\quad (\\text{with periodic indexing } u_{-1} := u_{N-1})\n$$\n$$\nS(u_i) = -k \\sqrt{u_i}, \\quad k > 0 \\quad (\\text{with the convention } S(0) = 0)\n$$\nThe goal is to analyze the preservation of the non-negativity property, i.e., whether $u^n \\in \\mathcal{C}_+$ implies $u^{n+1} \\in \\mathcal{C}_+$, where $\\mathcal{C}_+ = \\{ u \\in \\mathbb{R}^N : u_i \\ge 0 \\text{ for all } i \\}$.\n\nWe will analyze three time-stepping methods:\n1.  **Forward Euler (FE) Method**:\n    The FE method applied to the full operator $F(u)$ is:\n    $$\n    u^{n+1} = u^n + \\Delta t \\, F(u^n) = u^n + \\Delta t \\, (L(u^n) + S(u^n))\n    $$\n    For a component $u_i$, this is $u_i^{n+1} = u_i^n + \\Delta t \\left(-\\frac{a}{h}(u_i^n - u_{i-1}^n) - k\\sqrt{u_i^n}\\right)$. Non-negativity is not guaranteed. The source term itself can cause a loss of positivity. The source-only update $u_i^{n+1} = u_i^n - \\Delta t k \\sqrt{u_i^n}$ remains non-negative only if $u_i^n - \\Delta t k \\sqrt{u_i^n} \\ge 0$, which requires $\\Delta t \\le \\frac{\\sqrt{u_i^n}}{k}$. This time-step restriction depends on the state $u_i^n$ and approaches $0$ as $u_i^n \\to 0$. Therefore, for any fixed $\\Delta t > 0$, one can find a sufficiently small $u_i^n > 0$ that violates this condition.\n\n2.  **Third-Order SSP Runge-Kutta (SSP-RK3)**:\n    This method is given by the three stages:\n    $$\n    \\begin{aligned}\n    u^{(1)} &= u^n + \\Delta t \\, F(u^n) \\\\\n    u^{(2)} &= \\frac{3}{4} u^n + \\frac{1}{4}\\left(u^{(1)} + \\Delta t \\, F(u^{(1)})\\right) \\\\\n    u^{n+1} &= \\frac{1}{3} u^n + \\frac{2}{3}\\left(u^{(2)} + \\Delta t \\, F(u^{(2)})\\right)\n    \\end{aligned}\n    $$\n    The SSP property guarantees that if the FE step $v \\mapsto v + \\delta t F(v)$ preserves a convex set for all time steps $0 \\le \\delta t \\le \\Delta t_{\\mathrm{FE}}$, then the SSP-RK3 method will preserve that set for time steps $0 \\le \\Delta t \\le c \\Delta t_{\\mathrm{FE}}$ (with SSP coefficient $c > 0$). However, as established above, there is no uniform time-step limit $\\Delta t_{\\mathrm{FE}} > 0$ for which FE preserves positivity for all $u \\in \\mathcal{C}_+$. The premise for the SSP guarantee is not met, and thus the SSP-RK3 method is not guaranteed to preserve positivity. We expect it to fail in cases where the FE method fails.\n\n3.  **Blended Positivity-Preserving Method**:\n    This method uses an operator splitting-like approach, blending a non-negativity-preserving advection update with a non-negativity-preserving exact source update. The formula is:\n    $$\n    u^{n+1}_{\\mathrm{blend}} = \\theta \\, \\mathrm{ExactSource}(u^n) + (1 - \\theta) \\, \\mathrm{FE\\_flux}(u^n), \\quad \\theta \\in [0,1]\n    $$\n    The two components are:\n    - **Forward Euler Flux Update**: $\\mathrm{FE\\_flux}(u^n) := u^n + \\Delta t \\, L(u^n)$. Component-wise, this is $u_i^{n+1} = u_i^n - \\frac{a \\Delta t}{h}(u_i^n - u_{i-1}^n) = (1 - \\frac{a \\Delta t}{h})u_i^n + (\\frac{a \\Delta t}{h})u_{i-1}^n$. If the Courant-Friedrichs-Lewy (CFL) condition $a \\Delta t / h \\le 1$ holds and $u^n \\in \\mathcal{C}_+$, then both coefficients $(1-a\\Delta t/h)$ and $a\\Delta t/h$ are non-negative. The update is a convex combination of non-negative values, hence $\\mathrm{FE\\_flux}(u^n) \\in \\mathcal{C}_+$.\n    - **Exact Source Update**: Starting from the ODE $\\frac{d\\sqrt{u}}{dt} = -\\frac{k}{2}$, integration over $[t^n, t^{n+1}]$ yields $\\sqrt{u(t^{n+1})} = \\sqrt{u(t^n)} - k\\Delta t/2$. Since the solution cannot become negative, the exact update is $u^{n+1} = \\left( \\max\\left( \\sqrt{u^n} - \\frac{k \\Delta t}{2}, \\, 0 \\right) \\right)^2$. This update, by construction, maps non-negative values to non-negative values, so $\\mathrm{ExactSource}(u^n) \\in \\mathcal{C}_+$.\n\n    The blended update is a convex combination (since $\\theta \\in [0,1]$) of two vectors, $\\mathrm{ExactSource}(u^n)$ and $\\mathrm{FE\\_flux}(u^n)$, both of which lie in the convex cone $\\mathcal{C}_+$. Therefore, $u^{n+1}_{\\mathrm{blend}}$ is guaranteed to be in $\\mathcal{C}_+$, provided the CFL condition holds for the flux part. The test cases provided satisfy this condition. The implementation will demonstrate this robustness.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and generate the final output.\n    \"\"\"\n\n    test_cases = [\n        # (N, a, h, dt, k, theta, u0)\n        (1, 0.0, 1.0, 0.1, 10.0, 0.5, np.array([1e-8])),\n        (3, 1.0, 1.0, 0.2, 10.0, 0.5, np.array([1.0, 1e-6, 0.5])),\n        (3, 1.0, 1.0, 0.5, 10.0, 0.5, np.array([0.0, 0.0, 0.0])),\n        (3, 1.0, 1.0, 1e-4, 10.0, 0.5, np.array([1.0, 1e-2, 0.5])),\n    ]\n\n    # --- Operator Definitions ---\n\n    def L_op(u, a, h):\n        \"\"\"Computes the spatial operator L(u) with periodic BCs.\"\"\"\n        if a == 0.0:\n            return np.zeros_like(u)\n        u_prev = np.roll(u, 1)\n        return -(a / h) * (u - u_prev)\n\n    def S_op(u, k):\n        \"\"\"\n        Computes the nonlinear source term S(u).\n        Uses np.maximum(0, u) to avoid NaN for negative inputs that may\n        arise in intermediate stages of RK methods.\n        \"\"\"\n        return -k * np.sqrt(np.maximum(0, u))\n\n    def F_op(u, a, h, k):\n        \"\"\"Computes the full RHS operator F(u) = L(u) + S(u).\"\"\"\n        return L_op(u, a, h) + S_op(u, k)\n\n    # --- Time Stepping Methods ---\n\n    def fe_step(u0, dt, a, h, k):\n        \"\"\"Performs one Forward Euler step on the full operator F(u).\"\"\"\n        return u0 + dt * F_op(u0, a, h, k)\n\n    def ssprk3_step(u0, dt, a, h, k):\n        \"\"\"Performs one SSP-RK3 step on the full operator F(u).\"\"\"\n        # Stage 1\n        u1 = u0 + dt * F_op(u0, a, h, k)\n        # Stage 2\n        u2 = 0.75 * u0 + 0.25 * (u1 + dt * F_op(u1, a, h, k))\n        # Stage 3 (Final)\n        u_final = (1.0 / 3.0) * u0 + (2.0 / 3.0) * (u2 + dt * F_op(u2, a, h, k))\n        return u_final\n\n    def blended_method(u0, dt, a, h, k, theta):\n        \"\"\"Performs one step of the blended positivity-preserving method.\"\"\"\n        # FE flux-only update\n        fe_flux_update = u0 + dt * L_op(u0, a, h)\n\n        # Exact source update\n        # Use np.maximum on the input u0 to be safe, although it should be non-negative.\n        sqrt_u0 = np.sqrt(np.maximum(0, u0))\n        exact_source_update = np.square(np.maximum(sqrt_u0 - 0.5 * k * dt, 0))\n\n        # Convex blending\n        return theta * exact_source_update + (1.0 - theta) * fe_flux_update\n\n    # --- Main Loop ---\n    \n    results = []\n    for N, a, h, dt, k, theta, u0 in test_cases:\n        \n        # 1. Forward Euler update\n        u_fe = fe_step(u0, dt, a, h, k)\n        fe_is_positive = np.all(u_fe >= 0)\n\n        # 2. SSP-RK3 update\n        u_ssprk3 = ssprk3_step(u0, dt, a, h, k)\n        ssprk3_is_positive = np.all(u_ssprk3 >= 0)\n\n        # 3. Blended correction update\n        u_blend = blended_method(u0, dt, a, h, k, theta)\n        blend_is_positive = np.all(u_blend >= 0)\n\n        results.append([fe_is_positive, ssprk3_is_positive, blend_is_positive])\n    \n    # Format the output as a string representation of a list of lists of Python booleans\n    # str(True) -> 'True'\n    # str(False) -> 'False'\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}