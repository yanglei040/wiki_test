{
    "hands_on_practices": [
        {
            "introduction": "理论学习的最佳伙伴是动手实践。我们从一个基础但至关重要的问题开始：使用分部求和（SBP）算子和同步近似项（SAT）对线性平流方程进行离散化。这个练习将帮助您亲手构建一个保证能量稳定性的数值格式，并直观地理解为何 SBP 属性是实现结构保持的关键。通过这个简单的有限差分例子，您将为后续更复杂的高阶方法打下坚实的基础。",
            "id": "3421651",
            "problem": "考虑空间域 $[0,1]$ 上的线性平流方程 $u_t + a\\,u_x = 0$，其中平流速度为常数 $a=1$，且具有齐次流入边界条件 $u(0,t)=0$。使用包含 $N$ 个点的均匀网格对该域进行离散化，点坐标为 $x_i = i h$，$i=0,1,\\ldots,N-1$，其中 $h = 1/(N-1)$。实现一个二阶对角模分部求和（SBP）算子，并使用同步近似项（SAT）以一种稳定的、能量守恒的方式施加流入边界条件。然后计算半离散能量增长率，并验证对于所有给定的测试用例，该增长率都是非增的。\n\n定义和要求：\n- 分部求和（SBP）性质由一个对角模矩阵 $H \\in \\mathbb{R}^{N \\times N}$ 和一个微分算子 $D \\in \\mathbb{R}^{N \\times N}$ 定义，它们满足 $D = H^{-1} Q$，其中某个矩阵 $Q \\in \\mathbb{R}^{N \\times N}$ 满足\n$$\nQ + Q^\\top = B,\n$$\n其中 $B = \\mathrm{diag}(-1, 0, \\ldots, 0, 1)$ 对应于离散的边界通量。\n- 对于均匀网格上的二阶对角模算子，选择 $H$ 为对角矩阵，其元素为\n$$\nH_{ii} = \\begin{cases}\n\\frac{h}{2},  i=0 \\text{ or } i=N-1,\\\\\nh,  \\text{otherwise},\n\\end{cases}\n$$\n并选择 $Q$ 使得 $D = H^{-1} Q$ 在内部再现标准的中心差分，并在边界处使用与二阶精度一致的单边闭包。最简单的选择是\n$$\nQ_{i,i+1} = \\frac{1}{2},\\quad Q_{i+1,i} = -\\frac{1}{2}\\quad \\text{for } i=0,1,\\ldots,N-2,\n$$\n以及边界对角元 $Q_{00} = -\\frac{1}{2}$ 和 $Q_{N-1,N-1} = \\frac{1}{2}$，所有未指定的元素均为零。这个选择满足 $Q + Q^\\top = B$。\n- 使用以下形式的同步近似项（SAT）来施加齐次流入边界条件 $u(0,t)=0$：\n$$\n\\text{SAT} = -a\\,H^{-1} e_1 (u_0 - g),\n$$\n其中 $e_1$ 是第一个标准基向量，$g=0$，$a=1$。于是，半离散系统为\n$$\nu_t = -a D u - a H^{-1} e_1 u_0,\n$$\n其中 $u \\in \\mathbb{R}^N$ 表示解在网格点上的值。\n- 定义离散能量模\n$$\n\\|u\\|_H^2 = u^\\top H u,\n$$\n并计算其对于半离散系统的时间导数：\n$$\n\\frac{d}{dt}\\|u\\|_H^2 = 2\\,u^\\top H\\,u_t.\n$$\n\n任务：\n- 实现上述在均匀网格上的二阶对角模 SBP 算子以及针对 $a=1$ 和 $g=0$ 的 SAT 边界处理。\n- 对于下面指定的每个测试用例，计算半离散能量增长率 $\\frac{d}{dt}\\|u\\|_H^2$，并返回其是否为非增的，定义为小于或等于 $10^{-12}$（以考虑浮点舍入误差）。\n\n测试套件：\n- 用例 1：$N=2$, $u = [1.0, 0.0]$。\n- 用例 2：$N=2$, $u = [0.0, 2.0]$。\n- 用例 3：$N=5$, $u = [0,0,0,0,0]$。\n- 用例 4：$N=5$，$u$ 仅有齐次流入值，$u_0=1.0$，$u_i=0$ for $i \\neq 0$。\n- 用例 5：$N=5$，$u$ 仅有流出值，$u_{N-1}=1.0$，$u_i=0$ for $i \\neq N-1$。\n- 用例 6：$N=10$，使用固定的随机种子从 $[-1,1]$ 上的均匀分布中确定性地抽取 $u$。\n- 用例 7：$N=10$，$u_i = x_i$，其中 $x_i = i h$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如“[True,False,True,False]”。每个条目按上述顺序对应一个测试用例，表示该用例的 $\\frac{d}{dt}\\|u\\|_H^2 \\le 10^{-12}$ 是否成立。\n- 不涉及物理单位或角度；所有计算均以纯数值进行。",
            "solution": "该问题要求为线性平流方程 $u_t + a\\,u_x = 0$ 实现并验证一个稳定的半离散化方案。该方案使用二阶对角模分部求和（SBP）算子处理空间导数，并使用同步近似项（SAT）来施加边界条件。目标是计算离散能量模的时间变化率，并确认对于一系列测试用例，该变化率是非增的。\n\n代表网格点 $x_i$ 处解的解向量 $u(t) \\in \\mathbb{R}^N$ 的半离散系统由下式给出：\n$$\n\\frac{du}{dt} = -a D u + \\text{SAT}\n$$\n这里，$D$ 是 SBP 微分矩阵，$a=1$ 是平流速度，SAT 项用于施加齐次流入边界条件 $u(0,t)=0$。指定的 SAT 项为：\n$$\n\\text{SAT} = -a\\,H^{-1} e_1 (u_0 - g)\n$$\n当 $a=1$ 且边界数据 $g=0$ 时，系统变为：\n$$\n\\frac{du}{dt} = -D u - H^{-1} e_1 u_0\n$$\n其中 $u_0$ 是向量 $u$ 的第一个分量，对应于流入边界 $x=0$ 处的解，而 $e_1 = [1, 0, \\ldots, 0]^\\top$ 是第一个标准基向量。\n\n该格式的稳定性使用由矩阵 $H$ 定义的离散能量模进行分析：\n$$\n\\|u\\|_H^2 = u^\\top H u\n$$\n矩阵 $H$ 是一个正定对角矩阵，它定义了一个离散内积和求积法则。其时间导数给出了能量增长率：\n$$\n\\frac{d}{dt}\\|u(t)\\|_H^2 = \\frac{d}{dt}(u^\\top H u) = \\left(\\frac{du}{dt}\\right)^\\top H u + u^\\top H \\left(\\frac{du}{dt}\\right)\n$$\n由于结果是一个标量，这两项是相等的，因此我们有：\n$$\n\\frac{d}{dt}\\|u\\|_H^2 = 2 u^\\top H \\frac{du}{dt}\n$$\n将半离散方程代入 $\\frac{du}{dt}$：\n$$\n\\frac{d}{dt}\\|u\\|_H^2 = 2 u^\\top H (-D u - H^{-1} e_1 u_0) = -2 u^\\top H D u - 2 u^\\top H H^{-1} e_1 u_0\n$$\n我们分别分析右侧的两项。\n\n对于第一项，我们使用 SBP 性质。微分算子 $D$ 定义为 $D = H^{-1}Q$，其中矩阵 $Q$ 满足 $Q+Q^\\top=B=\\mathrm{diag}(-1, 0, \\ldots, 0, 1)$。\n$$\n-2 u^\\top H D u = -2 u^\\top H (H^{-1}Q) u = -2 u^\\top Q u\n$$\n利用标量等于其自身转置的性质（$u^\\top Q u = (u^\\top Q u)^\\top = u^\\top Q^\\top u$），我们可以写出：\n$$\n-2 u^\\top Q u = - (u^\\top Q u + u^\\top Q^\\top u) = -u^\\top(Q+Q^\\top)u = -u^\\top B u\n$$\n代入 $B$ 的定义：\n$$\n-u^\\top B u = -\\begin{pmatrix} u_0  \\dots  u_{N-1} \\end{pmatrix} \\begin{pmatrix} -1   \\\\  0  \\\\   \\ddots  \\\\    1 \\end{pmatrix} \\begin{pmatrix} u_0 \\\\ \\vdots \\\\ u_{N-1} \\end{pmatrix} = -(-u_0^2 + u_{N-1}^2) = u_0^2 - u_{N-1}^2\n$$\n该项代表了穿过边界的净能量通量。\n\n对于源自 SAT 的第二项，我们有：\n$$\n-2 u^\\top H H^{-1} e_1 u_0 = -2 u^\\top I e_1 u_0 = -2 u^\\top e_1 u_0\n$$\n乘积 $u^\\top e_1$ 提取了 $u$ 的第一个分量，即 $u_0$。所以，该项变为：\n$$\n-2 (u_0) u_0 = -2 u_0^2\n$$\n该项代表了为施加边界条件而由 SAT 引入的能量耗散。\n\n结合两个结果，总的能量增长率为：\n$$\n\\frac{d}{dt}\\|u\\|_H^2 = (u_0^2 - u_{N-1}^2) - 2 u_0^2 = -u_0^2 - u_{N-1}^2\n$$\n由于 $u_0^2 \\ge 0$ 且 $u_{N-1}^2 \\ge 0$，能量增长率始终为非正（$\\le 0$）。这证明了 SBP-SAT 半离散格式是能量稳定的（或者更准确地说，是耗散的）。\n\n实现部分将为给定的网格点数 $N$ 构建指定的矩阵 $H$ 和 $Q$。然后，它将根据半离散方程计算向量 $\\frac{du}{dt}$，并最终对每个测试用例数值计算能量增长率表达式 $2 u^\\top H \\frac{du}{dt}$。结果将与 $10^{-12}$ 的容差进行比较，以考虑浮点运算误差。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_energy_rate(N, u_vec):\n    \"\"\"\n    Computes the semidiscrete energy growth rate for the linear advection equation\n    using a second-order SBP-SAT scheme.\n\n    Args:\n        N (int): The number of grid points.\n        u_vec (np.ndarray): The solution vector of size N.\n\n    Returns:\n        float: The computed energy growth rate, d/dt ||u||_H^2.\n    \"\"\"\n    if N  2:\n        # The SBP operator definition is for N>=2.\n        # For N2, h is undefined. A trivial case.\n        return 0.0\n\n    a = 1.0\n    h = 1.0 / (N - 1)\n\n    # 1. Construct the diagonal norm matrix H as a 1D array of its diagonal entries.\n    H_diag = np.full(N, h, dtype=float)\n    H_diag[0] = h / 2.0\n    H_diag[-1] = h / 2.0\n\n    # 2. Construct the matrix Q.\n    Q = np.zeros((N, N), dtype=float)\n    # Diagonal entries\n    Q[0, 0] = -0.5\n    Q[-1, -1] = 0.5\n    # Off-diagonal entries\n    idx = np.arange(N - 1)\n    Q[idx, idx + 1] = 0.5\n    Q[idx + 1, idx] = -0.5\n\n    # 3. Construct the differentiation matrix D = H^-1 * Q.\n    # We do this without explicitly forming the inverse of H.\n    H_inv_diag = 1.0 / H_diag\n    D = H_inv_diag[:, np.newaxis] * Q\n\n    # 4. Compute the time derivative of the solution vector, u_t.\n    # u_t = -a * D * u + SAT\n    Du = D @ u_vec\n    u_t = -a * Du\n\n    # The SAT term for u_t = -a*D*u - a*H^-1*e1*(u0-g) with g=0.\n    # This term simplifies to a vector with only the first component being non-zero.\n    # SAT_vector = -a * H_inv_diag[0] * u_vec[0]\n    sat_penalty = a * H_inv_diag[0] * u_vec[0]\n    u_t[0] -= sat_penalty\n\n    # 5. Compute the energy growth rate: d/dt ||u||^2_H = 2 * u^T * H * u_t.\n    # Since H is diagonal, H*u_t is an element-wise product.\n    H_u_t = H_diag * u_t\n    energy_rate = 2.0 * u_vec.T @ H_u_t\n    \n    return energy_rate\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (2, np.array([1.0, 0.0])),\n        # Case 2\n        (2, np.array([0.0, 2.0])),\n        # Case 3\n        (5, np.array([0.0, 0.0, 0.0, 0.0, 0.0])),\n        # Case 4\n        (5, np.array([1.0, 0.0, 0.0, 0.0, 0.0])),\n        # Case 5\n        (5, np.array([0.0, 0.0, 0.0, 0.0, 1.0])),\n    ]\n\n    # Case 6: Deterministic \"random\" vector\n    N6 = 10\n    rng = np.random.default_rng(seed=12345)\n    u6 = rng.uniform(-1, 1, size=N6)\n    test_cases.append((N6, u6))\n\n    # Case 7: Linear profile\n    N7 = 10\n    h7 = 1.0 / (N7 - 1)\n    u7 = np.arange(N7) * h7\n    test_cases.append((N7, u7))\n\n    results = []\n    # Tolerance for floating-point comparison\n    tolerance = 1e-12\n\n    for N, u_vec in test_cases:\n        rate = calculate_energy_rate(N, u_vec)\n        is_non_increasing = rate = tolerance\n        results.append(is_non_increasing)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在掌握了 SBP-SAT 的基本思想后，我们将挑战一个更高级的非线性问题。本练习要求您为非粘性伯格斯方程实现一个基于高斯节点的间断伽辽金谱元法（DGSEM）。您将使用一种特殊的熵守恒数值通量来处理非线性项，并验证最终半离散格式的雅可比矩阵的加权反对称性，这是能量守恒的核心机制。这个实践将 SBP 思想从有限差分推广到了现代高阶 DG 方法，展示了其在复杂流动问题中的威力。",
            "id": "3421735",
            "problem": "考虑一维周期性定义域上的标量守恒律，由无粘性 Burgers’ 方程给出，\n$$\n\\partial_t u(x,t) + \\partial_x\\left(\\tfrac{1}{2}u(x,t)^2\\right) = 0 \\quad \\text{for} \\quad x \\in [0,1],\n$$\n其具有周期性边界条件和光滑解。设区间被划分为 $K$ 个大小为 $h = 1/K$ 的均匀单元，并将每个物理单元映射到参考区间 $[-1,1]$，其雅可比行列式为 $J = h/2$。在每个单元上，使用在 Legendre-Gauss 节点上配置的不连续伽辽金谱元法 (Discontinuous Galerkin Spectral Element Method, DGSEM)，通过 $N=3$ 次多项式来近似 $u$。将 $N+1$ 个参考节点记为 $\\{\\xi_i\\}_{i=1}^{N+1}$，正求积权重记为 $\\{w_i\\}_{i=1}^{N+1}$。\n\n在参考单元上构造广义分部求和 (Summation-By-Parts, SBP) 算子如下：\n- 对角质量矩阵 $M \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 的元素为 $M_{ii} = w_i$。\n- 节点微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 由 Lagrange 基函数在节点 $\\{\\xi_i\\}$ 处的导数得到。\n- 定义 $Q = M D$。\n- 设 $R \\in \\mathbb{R}^{2\\times(N+1)}$ 为到边界 $\\xi=-1$ 和 $\\xi=1$ 的插值矩阵，即 $R = \\begin{bmatrix} \\ell_1(-1)  \\cdots  \\ell_{N+1}(-1) \\\\ \\ell_1(1)  \\cdots  \\ell_{N+1}(1)\\end{bmatrix}$，其中 $\\{\\ell_j\\}$ 是节点 Lagrange 基多项式。\n- 设 $B = \\operatorname{diag}(-1,1)$。\n\n这些算子满足广义 SBP 恒等式\n$$\nQ + Q^\\top = R^\\top B R.\n$$\n\n使用针对 Burgers’ 方程的两点对称且相容的熵守恒体积通量来离散化平流项。定义两点通量\n$$\nf_S(a,b) = \\tfrac{1}{6}\\left(a^2 + a\\,b + b^2\\right),\n$$\n该通量对其参数是对称的，并且在 $f_S(u,u) = f(u)$ 的意义上与物理通量 $f(u) = \\tfrac{1}{2}u^2$ 相容。使用相同的两点通量来定义单元间界面的数值通量（中心/熵守恒界面通量）。对于一个节点解向量为 $u \\in \\mathbb{R}^{N+1}$ 的单元，通过 $F_{ij} = f_S(u_i,u_j)$ 定义逐对通量矩阵 $F \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，并通过按行求和定义体积贡献\n$$\nG(u) = (Q \\circ F)\\,\\mathbf{1},\n$$\n其中 $\\circ$ 表示 Hadamard (逐元素) 乘积，$\\mathbf{1} \\in \\mathbb{R}^{N+1}$ 是全1向量。设 $\\widehat{f}\\in\\mathbb{R}^2$ 汇集了单元左右边界的界面数值通量，这些通量是通过在插值得到的边界迹上使用 $R$ 和周期性相邻耦合计算 $f_S$ 得到的。\n\n每个单元上的半离散强形式 DGSEM 为\n$$\n\\frac{d u}{dt} \\;=\\; -\\frac{2}{J}\\, M^{-1}\\left(G(u) - R^\\top B\\, \\widehat{f}\\right),\n$$\n全局半离散系统通过在定义域端点处组装所有具有周期性边界条件的单元得到。\n\n对于一个全局状态向量 $u \\in \\mathbb{R}^{K(N+1)}$，通过如上所述组装所有单元贡献来定义全局右端项 $\\mathcal{R}(u)$。对于一个常数状态 $u \\equiv c$，将在 $u=c\\,\\mathbf{1}$ 处计算的右端项的雅可比矩阵定义为半离散算子矩阵 $A(c) \\in \\mathbb{R}^{K(N+1)\\times K(N+1)}$，\n$$\nA(c) \\;=\\; \\left.\\frac{\\partial \\mathcal{R}(u)}{\\partial u}\\right|_{u = c\\,\\mathbf{1}}.\n$$\n将全局物理质量矩阵 $M_{\\text{phys}}$ 定义为块对角矩阵，每个单元对应一个块 $J M$，即 $M_{\\text{phys}} = \\operatorname{blkdiag}(J M,\\dots,J M) \\in \\mathbb{R}^{K(N+1)\\times K(N+1)}$。\n\n需要验证的结构保持性质是，对于周期性边界条件，平流部分在 $M_{\\text{phys}}$ 内积下的加权反对称性：\n$$\nM_{\\text{phys}}\\,A(c) + A(c)^\\top\\,M_{\\text{phys}} \\;=\\; 0.\n$$\n\n程序要求：\n- 在定义域 $[0,1]$ 上，使用 Legendre-Gauss 点，实现次数为 $N=3$ 的不连续伽辽金谱元法 (Discontinuous Galerkin Spectral Element Method, DGSEM)，并采用周期性边界条件和指定的两点通量 $f_S$。\n- 组装全局右端项 $\\mathcal{R}(u)$，并通过中心有限差分及小扰动 $ \\varepsilon $ 计算在常数状态 $u \\equiv c$ 下的雅可比矩阵 $A(c)$，即\n$$\nA(c)\\,e_k \\;\\approx\\; \\frac{\\mathcal{R}(c\\,\\mathbf{1} + \\varepsilon\\, e_k) - \\mathcal{R}(c\\,\\mathbf{1} - \\varepsilon\\, e_k)}{2\\varepsilon},\n$$\n其中 $e_k$ 为每个标准基向量。\n- 通过计算偏差矩阵 $S(c) = M_{\\text{phys}}A(c) + A(c)^\\top M_{\\text{phys}}$ 的无穷范数，并将其与一个容差进行比较，来验证加权反对称性。\n\n测试套件：\n- 使用以下 $(K,c)$ 测试用例，其中 $N=3$ 固定并采用周期性边界条件：\n    1. $(K,c) = (1, 0.8)$\n    2. $(K,c) = (3, 0.0)$\n    3. $(K,c) = (4, -1.0)$\n- 对每个测试用例，计算谓词\n$$\n\\|S(c)\\|_{\\infty} \\leq 10^{-9},\n$$\n的布尔结果，其中 $\\|\\cdot\\|_{\\infty}$ 表示逐项最大绝对值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试套件的三个布尔结果，格式为逗号分隔的 Python 风格列表，例如“[True,False,True]”。不应打印任何额外文本。",
            "solution": "我们从无粘性 Burgers’ 方程的标量守恒律开始，\n$$\n\\partial_t u(x,t) + \\partial_x f(u(x,t)) = 0,\\quad f(u) = \\tfrac{1}{2}u^2,\n$$\n该方程定义在周期性定义域 $x \\in [0,1]$ 上，并被划分为 $K$ 个大小为 $h=1/K$ 的均匀单元。在每个单元上，从参考坐标 $\\xi \\in [-1,1]$ 到物理坐标 $x$ 的映射是仿射的，其雅可比行列式为 $J = h/2$，因此 $\\partial_x = (1/J)\\partial_\\xi$，参考单元上的方程可写为\n$$\n\\partial_t u(\\xi,t) + \\frac{1}{J}\\,\\partial_\\xi f(u(\\xi,t)) = 0.\n$$\n\n在参考单元上，我们选择在 Legendre-Gauss 节点 $\\{\\xi_i\\}_{i=1}^{N+1}$ 处进行配置的次数为 $N=3$ 的不连续伽辽金谱元法 (Discontinuous Galerkin Spectral Element Method, DGSEM)，其求积权重为 $\\{w_i\\}_{i=1}^{N+1}$。设 $\\{\\ell_j(\\xi)\\}_{j=1}^{N+1}$ 为这些节点上的 Lagrange 插值多项式。我们定义对角质量矩阵 $M \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，其元素为 $M_{ii} = w_i$，以及节点微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，其元素为 $D_{ij} = \\ell_j'(\\xi_i)$。矩阵 $Q = M D$ 与由下式给出的边界插值矩阵 $R \\in \\mathbb{R}^{2\\times(N+1)}$\n$$\nR = \\begin{bmatrix}\n\\ell_1(-1)  \\cdots  \\ell_{N+1}(-1)\\\\\n\\ell_1(1)  \\cdots  \\ell_{N+1}(1)\n\\end{bmatrix},\n$$\n以及 $B = \\operatorname{diag}(-1,1)$ 一起满足广义分部求和 (Summation-By-Parts, SBP) 恒等式\n$$\nQ + Q^\\top = R^\\top B R.\n$$\n该恒等式确保了当通过适当的同步近似项 (Simultaneous Approximation Terms, SATs) 耦合单元时，离散分部积分成立。\n\n为了对非线性通量进行稳定且保持结构的离散化，我们采用一个对 Burgers’ 方程而言熵守恒的对称且相容的两点体积通量 $f_S$：\n$$\nf_S(a,b) = \\tfrac{1}{6}\\left(a^2 + a\\,b + b^2\\right) = f_S(b,a), \\quad f_S(u,u) = f(u).\n$$\n使用通量差分形式，对于一个节点状态向量为 $u \\in \\mathbb{R}^{N+1}$ 的单元，其体积贡献通过构建元素为 $F_{ij} = f_S(u_i,u_j)$ 的矩阵 $F \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，然后进行按行求和来计算\n$$\nG(u) = (Q \\circ F)\\,\\mathbf{1},\n$$\n其中 $\\circ$ 表示 Hadamard 乘积，$\\mathbf{1}$ 是全1向量。单元边界处的数值通量也取为在左右迹 $u^-, u^+$ 上计算的 $f_S$，得到界面向量 $\\widehat{f} \\in \\mathbb{R}^2$。一个单元内的半离散强形式 DGSEM 为\n$$\n\\frac{d u}{dt} \\;=\\; -\\frac{1}{J}\\, M^{-1}\\left(2\\,G(u) - R^\\top B\\, \\widehat{f}\\right).\n$$\n通过循环耦合相邻单元之间的迹来在每个面上定义 $\\widehat{f}$，从而实现具有周期性边界条件的单元的粘合。\n\n能量分析使用由块对角全局质量矩阵 $M_{\\text{phys}} = \\operatorname{blkdiag}(J M,\\dots,J M)$ 导出的物理内积，该内积是网格上物理 $L^2$ 内积的求积表示。广义 SBP 恒等式意味着离散能量平衡。特别地，对于周期性边界和对称的两点通量，离散能量\n$$\nE(u) = \\tfrac{1}{2} u^\\top M_{\\text{phys}} u\n$$\n满足\n$$\n\\frac{dE}{dt} = u^\\top M_{\\text{phys}} \\frac{du}{dt} = 0,\n$$\n因此平流算子在 $M_{\\text{phys}}$ 内积下是反对称的。当在常数状态 $u \\equiv c$ 附近将半离散右端项 $\\mathcal{R}(u)$ 线性化时，雅可比矩阵 $A(c) = \\left.\\frac{\\partial \\mathcal{R}}{\\partial u}\\right|_{u=c\\mathbf{1}}$ 代表该状态下的半离散平流算子，结构保持性质变为\n$$\nM_{\\text{phys}}\\,A(c) + A(c)^\\top\\,M_{\\text{phys}} = 0.\n$$\n该恒等式反映了在 $M_{\\text{phys}}$ 内积下的精确反对称性，并意味着在周期性边界条件下离散能量是守恒的。\n\n算法构造：\n- 计算 $N=3$ 时的 Legendre-Gauss 节点和权重 $\\{\\xi_i,w_i\\}_{i=1}^{N+1}$。\n- 构建重心权以计算 Lagrange 基函数及其在节点处的导数，从而得到 $D$ 和插值矩阵 $R$。\n- 构建 $M = \\operatorname{diag}(w)$ 和 $Q = M D$，并验证 $Q+Q^\\top \\approx R^\\top B R$。\n- 通过遍历单元、利用通量差分计算 $G(u)$、利用 $f_S$ 和 $R$ 计算界面通量 $\\widehat{f}$，并周期性地耦合单元，来组装全局右端项 $\\mathcal{R}(u)$。\n- 使用中心有限差分及小扰动 $\\varepsilon$ 来近似常数状态 $u \\equiv c$ 下的雅可比矩阵 $A(c)$：\n$$\nA(c)\\,e_k \\approx \\frac{\\mathcal{R}(c\\,\\mathbf{1} + \\varepsilon\\, e_k) - \\mathcal{R}(c\\,\\mathbf{1} - \\varepsilon\\, e_k)}{2\\varepsilon}.\n$$\n- 将 $M_{\\text{phys}}$ 构建为每个块上为 $J M$ 的块对角矩阵，并评估反对称性偏差\n$$\nS(c) = M_{\\text{phys}}A(c) + A(c)^\\top M_{\\text{phys}}.\n$$\n- 计算 $\\|S(c)\\|_{\\infty}$ 并与容差 $10^{-9}$ 进行比较，以获得每个测试用例的布尔结果。\n\n测试套件与输出：\n- 使用 $(K,c)=(1,0.8)$、$(K,c)=(3,0.0)$ 和 $(K,c)=(4,-1.0)$，其中 $N=3$ 固定。\n- 对于每种情况，输出 $\\|S(c)\\|_{\\infty} \\le 10^{-9}$ 是否成立。\n- 程序必须打印单行，其中包含三个布尔结果，格式为 Python 风格的列表，例如“[True,False,True]”。\n\n该构造从基本的离散 SBP 性质和用于 Burgers’ 方程的对称、相容的两点通量出发，这些是确保结构保持的核心设计原则。通过在 $M_{\\text{phys}}$ 内积下验证 $A(c)$ 的加权反对称性，表明 DGSEM 离散化方法在周期性边界条件下保持了离散能量结构。\n*注：在原始 `solution` 中，半离散方程的表述 `\\partial_t u(\\xi,t) + \\frac{2}{J}\\,\\partial_\\xi f(u(\\xi,t)) = 0` 和 `\\frac{d u}{dt} \\;=\\; -\\frac{2}{J}\\, M^{-1}\\left(G(u) - R^\\top B\\, \\widehat{f}\\right)` 存在一个不一致的 `2` 因子。根据标准 DGSEM 弱形式推导，`\\partial_x = (1/J)\\partial_\\xi`，且体积项为 `\\int \\partial_\\xi \\phi_j f d\\xi`。在强形式 `M^{-1}(...)` 中，体积项通常写作 `-M^{-1} D^T (M f)` 或 `-2 M^{-1} G(u)` 等，其中 `2` 来自于 flux differencing 的形式。但无论如何，最终的 $\\mathcal{R}(u)$ 应该是 `-(1/J) ...`。为了保持与问题描述 `\\frac{d u}{dt} \\;=\\; -\\frac{2}{J}\\, M^{-1}\\left(G(u) - R^\\top B\\, \\widehat{f}\\right)` 的一致性，代码实现中将采用 `-(2.0/J)` 因子，但这可能是一个轻微的理论不一致之处。然而，由于雅可比矩阵是线性的，这个常数因子不影响最终的加权反对称性验证。为了忠实于问题描述，我们保留了 `2/J` 的形式。*",
            "answer": "```python\nimport numpy as np\n\n# DGSEM on Gauss points for Burgers' equation, N=3, periodic domain [0,1]\n# Verify weighted skew-symmetry of the advective operator Jacobian at constant states.\n\ndef legendre_gauss_nodes_weights(n):\n    # Returns nodes and weights for Legendre-Gauss quadrature on [-1,1]\n    from numpy.polynomial.legendre import leggauss\n    x, w = leggauss(n)\n    return x, w\n\ndef barycentric_weights(nodes):\n    # Compute first-form barycentric weights for distinct nodes\n    n = len(nodes)\n    w = np.ones(n)\n    for j in range(n):\n        prod = 1.0\n        xj = nodes[j]\n        for k in range(n):\n            if k != j:\n                prod *= (xj - nodes[k])\n        w[j] = 1.0 / prod\n    return w\n\ndef lagrange_interp_row(t, nodes, bary_w):\n    # Returns the row vector [l_1(t),...,l_n(t)] for Lagrange basis at t\n    n = len(nodes)\n    # Check if t coincides with a node\n    for j in range(n):\n        if np.isclose(t, nodes[j], atol=1e-14, rtol=0.0):\n            row = np.zeros(n)\n            row[j] = 1.0\n            return row\n    diff = t - nodes\n    alpha = bary_w / diff\n    denom = np.sum(alpha)\n    row = alpha / denom\n    return row\n\ndef differentiation_matrix(nodes, bary_w):\n    # Build the nodal differentiation matrix using barycentric weights\n    n = len(nodes)\n    D = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                D[i, j] = (bary_w[j] / bary_w[i]) / (nodes[i] - nodes[j])\n    D[np.diag_indices(n)] = -np.sum(D, axis=1)\n    return D\n\ndef burgers_two_point_flux(a, b):\n    # Entropy-conserving symmetric two-point flux: (a^2 + a b + b^2)/6\n    return (a*a + a*b + b*b) / 6.0\n\ndef build_reference_operators(N):\n    # Build reference element operators for degree N using Gauss nodes\n    n = N + 1\n    xi, wq = legendre_gauss_nodes_weights(n)\n    bw = barycentric_weights(xi)\n    D = differentiation_matrix(xi, bw)\n    M = np.diag(wq)\n    Q = M @ D\n    # Interpolation to boundaries -1 and 1\n    R = np.vstack([\n        lagrange_interp_row(-1.0, xi, bw),\n        lagrange_interp_row( 1.0, xi, bw)\n    ])\n    B = np.diag(np.array([-1.0, 1.0]))\n    return xi, wq, M, D, Q, R, B\n\ndef assemble_rhs(u, K, N, M, Q, R, B, J):\n    # Assemble the global RHS for Burgers' equation with periodic BCs using flux differencing on Gauss DGSEM\n    nloc = N + 1\n    total = K * nloc\n    rhs = np.zeros(total)\n    ones_loc = np.ones(nloc)\n\n    # Helper to extract element dofs\n    def elem_slice(e):\n        return slice(e*nloc, (e+1)*nloc)\n\n    # Compute boundary trace values per element\n    # left trace is at xi=-1 from inside element, right trace at xi=+1\n    u_left = np.zeros(K)\n    u_right = np.zeros(K)\n    for e in range(K):\n        ue = u[elem_slice(e)]\n        u_left[e] = R[0, :] @ ue\n        u_right[e] = R[1, :] @ ue\n\n    # Interface fluxes: for element e, left interface between e-1 (right) and e (left), right interface between e (right) and e+1 (left)\n    fhat_left = np.zeros(K)\n    fhat_right = np.zeros(K)\n    for e in range(K):\n        eL = (e - 1) % K\n        eR = (e + 1) % K\n        # left interface of element e: left neighbor right trace, current left trace\n        fhat_left[e] = burgers_two_point_flux(u_right[eL], u_left[e])\n        # right interface of element e: current right trace, right neighbor left trace\n        fhat_right[e] = burgers_two_point_flux(u_right[e], u_left[eR])\n\n    # Element contributions\n    Minv_diag = 1.0 / np.diag(M)\n    for e in range(K):\n        ue = u[elem_slice(e)]\n        # Volume flux differencing\n        # Build matrix F with F_ij = f_S(u_i, u_j)\n        ui = ue[:, None]\n        uj = ue[None, :]\n        F = burgers_two_point_flux(ui, uj)\n        G = (Q * F) @ ones_loc  # row-wise sum\n        # Surface term\n        fhat = np.array([fhat_left[e], fhat_right[e]])\n        surf = R.T @ (B @ fhat)\n        # RHS local\n        rhs_e = -(2.0 / J) * (Minv_diag * (G - surf))\n        rhs[elem_slice(e)] = rhs_e\n\n    return rhs\n\ndef compute_jacobian_at_constant(K, N, c, M, Q, R, B, J, eps=1e-8):\n    # Compute Jacobian A at u=c via centered finite differences\n    nloc = N + 1\n    total = K * nloc\n    u0 = np.full(total, c)\n    rhs0 = assemble_rhs(u0, K, N, M, Q, R, B, J)  # not used directly but ensures any caches warm\n    A = np.zeros((total, total))\n    for k in range(total):\n        ek = np.zeros(total)\n        ek[k] = 1.0\n        up = u0 + eps * ek\n        um = u0 - eps * ek\n        rp = assemble_rhs(up, K, N, M, Q, R, B, J)\n        rm = assemble_rhs(um, K, N, M, Q, R, B, J)\n        A[:, k] = (rp - rm) / (2.0 * eps)\n    return A\n\ndef build_global_mass(K, M, J):\n    # Global physical mass matrix block diagonal with J * M per element\n    nloc = M.shape[0]\n    total = K * nloc\n    Mphys = np.zeros((total, total))\n    block = J * M\n    for e in range(K):\n        s = slice(e*nloc, (e+1)*nloc)\n        Mphys[s, s] = block\n    return Mphys\n\ndef skew_symmetry_defect_norm(Mphys, A):\n    # Compute infinity norm (max abs entry) of Mphys A + A^T Mphys\n    S = Mphys @ A + A.T @ Mphys\n    return np.max(np.abs(S))\n\ndef solve():\n    # Fixed degree N=3\n    N = 3\n    xi, wq, M, D, Q, R, B = build_reference_operators(N)\n\n    # Optional: check SBP property residual (not printed)\n    # sbp_res = np.max(np.abs(Q + Q.T - R.T @ B @ R))\n\n    # Test suite: (K, c)\n    test_cases = [\n        (1, 0.8),\n        (3, 0.0),\n        (4, -1.0),\n    ]\n\n    results = []\n    for K, c in test_cases:\n        h = 1.0 / K\n        J = 0.5 * h\n        # Build Jacobian at constant state\n        A = compute_jacobian_at_constant(K, N, c, M, Q, R, B, J, eps=1e-8)\n        Mphys = build_global_mass(K, M, J)\n        defect = skew_symmetry_defect_norm(Mphys, A)\n        results.append(defect = 1e-9)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "结构保持的实现往往隐藏在细节之中。最后一个练习将引导我们探索模态间断伽辽金方法中的一个关键点：非线性项的求积法则。您将比较“欠积分”（under-integration，通常由配置点方法导致）与“过积分”（over-integration，精确积分）两种策略对离散能量守恒性的影响。通过定量计算两种方法在能量演化上的差异，您将深刻体会到求积误差（或混淆误差）是如何破坏数值格式的守恒性质的，从而理解为何在实现非线性格式时需要格外谨慎。",
            "id": "3421658",
            "problem": "考虑周期域上的一维无粘伯格斯方程 (inviscid Burgers equation)，\n$$\n\\partial_t u(x,t) + \\partial_x \\left( \\tfrac{1}{2} u(x,t)^2 \\right) = 0,\\qquad x \\in [0,2\\pi],\\ t \\ge 0,\n$$\n该方程具有周期性边界条件和下文指定的 dla'g光滑初始条件。您将分析使用模态勒让德多项式基的半离散间断伽辽金 (Discontinuous Galerkin, DG) 方法，并比较当非线性体积积分分别使用欠积分的高斯-洛巴托 (Gauss–Lobatto) 求积或过积分的高斯 (Gauss) 求积进行近似时，离散能量的演化。目标是定量计算这两种求积选择在 $t=0$ 时离散能量时间导数的差异。\n\n定义与设置：\n\n- 将域划分为 $K$ 个长度相等的非重叠单元，并通过仿射映射将每个单元映射到参考区间 $[-1,1]$。设每个单元的索引为 $e = 0,1,\\dots,K-1$。\n\n- 在参考区间上，使用 $L^2$ 正交归一的勒让德多项式基 $\\{\\phi_j(\\xi)\\}_{j=0}^N$，其中 $\\xi \\in [-1,1]$，$\\phi_j(\\xi) = \\sqrt{\\frac{2j+1}{2}}\\,P_j(\\xi)$，$P_j(\\xi)$ 是 $j$ 次勒让德多项式。局部 DG 近似为 $u_h^e(\\xi,t) = \\sum_{j=0}^N a_{e,j}(t)\\,\\phi_j(\\xi)$。\n\n- 每个单元上的半离散 DG 弱形式（在界面处带有数值通量）为\n$$\n\\int_{-1}^1 \\phi_j(\\xi)\\,J\\,\\partial_t u_h^e(\\xi,t)\\,d\\xi + \\int_{-1}^1 \\partial_\\xi \\phi_j(\\xi)\\,f(u_h^e(\\xi,t))\\,d\\xi - \\left[\\phi_j(\\xi)\\,f^\\star\\right]_{\\xi=-1}^{\\xi=1} = 0,\n$$\n其中 $J$ 是从 $[-1,1]$ 到物理单元的仿射映射的雅可比行列式，$f(u) = \\frac{1}{2}u^2$ 是物理通量，$f^\\star$ 是单元界面处的两点数值通量。\n\n- 在每个界面处，对伯格斯方程使用能量守恒的两点数值通量，\n$$\nf^\\star(u^-,u^+) = \\frac{1}{6}\\left((u^-)^2 + u^-\\,u^+ + (u^+)^2\\right),\n$$\n其中 $u^-$ 和 $u^+$ 分别表示界面处左右单元的迹。假设存在周期性，因此界面从最后一个单元环绕到第一个单元。\n\n- 将离散能量定义为\n$$\nE_h(t) = \\frac{1}{2}\\sum_{e=0}^{K-1}\\int_{x \\in \\text{element } e} \\left(u_h^e(x,t)\\right)^2\\,dx = \\frac{1}{2}\\sum_{e=0}^{K-1} J \\int_{-1}^1 \\left(u_h^e(\\xi,t)\\right)^2\\,d\\xi.\n$$\n\n- 根据在参考区间上的正交归一性可得\n$$\n\\frac{dE_h}{dt} = \\sum_{e=0}^{K-1} \\sum_{j=0}^N a_{e,j}(t)\\,\\left(J\\,\\frac{d a_{e,j}}{dt}\\right).\n$$\n在使用所选数值通量的半离散弱形式中，$J\\,\\frac{d a_{e,j}}{dt}$ 等于一个体积项和界面贡献项之和：\n$$\nJ\\,\\frac{d a_{e,j}}{dt} = - \\int_{-1}^1 \\partial_\\xi \\phi_j(\\xi)\\, f\\left(u_h^e(\\xi,t)\\right)\\,d\\xi + \\phi_j(1)\\,f^\\star\\big(u_h^e(1,t), u_h^{e+1}(-1,t)\\big) - \\phi_j(-1)\\,f^\\star\\big(u_h^{e-1}(1,t), u_h^e(-1,t)\\big),\n$$\n由于周期性，下标对 $K$ 取模。\n\n- 在 $t=0$ 时，通过在每个单元上对初始条件进行精确的 $L^2$ 投影，得到模态系数 $\\{a_{e,j}(0)\\}$：\n$$\na_{e,j}(0) = \\int_{-1}^1 u_0\\!\\left(x_e(\\xi)\\right)\\,\\phi_j(\\xi)\\,d\\xi,\n$$\n其中 $x_e(\\xi)$ 是单元 $e$ 中参考点 $\\xi$ 的物理坐标。为对此投影积分进行数值计算，请使用具有足够多点数的高斯-勒让德求积以确保精度远超多项式次数；每个单元使用至少 $Q_{\\text{proj}} = 5N+5$ 个高斯点来实现。\n\n- 在 $t=0$ 时定义两个半离散的右端项，它们仅在非线性项的体积积分所使用的求积方法上有所不同：\n    - 欠积分高斯-洛巴托 (Under-integrated Gauss–Lobatto)：使用在 $[-1,1]$ 上的 $Q_{\\text{GL}} = N+1$ 个点的高斯-洛巴托求积来近似 $\\int_{-1}^1 \\partial_\\xi \\phi_j(\\xi)\\, f(u_h^e(\\xi,0))\\,d\\xi$。\n    - 过积分高斯 (Over-integrated Gauss)：使用在 $[-1,1]$ 上的 $Q_{\\text{G}} = 2N+1$ 个点的高斯-勒让德求积来近似相同的体积积分。\n\n- 在两种情况下，都使用模态展开和在 $\\xi=\\pm 1$ 处的基函数值精确计算界面迹 $u_h^e(\\pm 1,0)$，并在界面处使用相同的能量守恒两点数值通量 $f^\\star$。\n\n- 对于每种求积选择，在 $t=0$ 时的离散能量时间导数为\n$$\n\\left.\\frac{dE_h}{dt}\\right|_{t=0} = \\sum_{e=0}^{K-1}\\sum_{j=0}^N a_{e,j}(0)\\,\\left(J\\,\\left.\\frac{d a_{e,j}}{dt}\\right|_{t=0}\\right),\n$$\n其中 $J\\,\\left.\\frac{d a_{e,j}}{dt}\\right|_{t=0}$ 是由所选的体积积分求积和如上所述的精确界面贡献组装而成。\n\n- 我们关注的量是欠积分高斯-洛巴托和过积分高斯体积求积在 $t=0$ 时离散能量时间导数之间的差值：\n$$\n\\Delta = \\left(\\left.\\frac{dE_h}{dt}\\right|_{\\text{GL},\\,t=0}\\right) - \\left(\\left.\\frac{dE_h}{dt}\\right|_{\\text{G},\\,t=0}\\right).\n$$\n\n初始条件与测试套件：\n\n- 使用初始条件\n$$\nu_0(x) = A \\sin(m x),\\qquad x \\in [0,2\\pi],\n$$\n带有周期性边界条件。\n\n- 对于每个测试用例 $(N,K,m,A)$，计算上面定义的单个实数输出 $\\Delta$。\n\n- 待使用的测试套件参数集：\n    1. $N=2$, $K=4$, $m=2$, $A=0.5$。\n    2. $N=3$, $K=3$, $m=3$, $A=1.0$。\n    3. $N=1$, $K=2$, $m=1$, $A=0.3$。\n    4. $N=5$, $K=2$, $m=5$, $A=1.0$。\n\n编程要求：\n\n- 使用 $L^2$ 正交归一的勒让德基，在 $[-1,1]$ 上实现模态 DG 组装，并利用仿射映射到物理单元。确保界面项的周期性连接。\n\n- 在 $[-1,1]$ 上实现具有 $Q_{\\text{GL}} = N+1$ 个节点和权重的高斯-洛巴托求积（对最高 $2N-1$ 次多项式精确），以及具有 $Q_{\\text{G}} = 2N+1$ 个节点和权重的高斯-勒让德求积。\n\n- 在每个单元中，使用 $Q_{\\text{proj}} = 5N+5$ 个点的高斯-勒让德求积，实现 $u_0(x)$ 在模态基上的 $L^2$ 投影。\n\n- 按规定计算 $\\left.\\frac{dE_h}{dt}\\right|_{\\text{GL},\\,t=0}$ 和 $\\left.\\frac{dE_h}{dt}\\right|_{\\text{G},\\,t=0}$，并为每个测试用例输出差值 $\\Delta$。\n\n- 最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，\"[result1,result2,result3,result4]\"）。每个结果必须是机器默认字符串格式的浮点数。不应打印任何额外文本。\n\n本问题不需要物理单位或角度转换。所有角度均以弧度为单位。每个测试用例的最终答案必须是浮点数。",
            "solution": "该问题旨在通过比较两种不同的数值求积方法，量化求积误差（即混叠误差）对模态间断伽辽金（DG）方法离散能量守恒性的影响。具体来说，我们将计算使用欠积分的高斯-洛巴托（GL）求积和过积分的高斯-勒让德（G）求积时，在 $t=0$ 时刻离散能量时间导数的差异。\n\n问题的核心在于离散能量导数的表达式：\n$$\n\\frac{dE_h}{dt} = \\sum_{e,j} a_{e,j} \\left(J\\,\\frac{da_{e,j}}{dt}\\right).\n$$\n将半离散弱形式代入，我们得到：\n$$\n\\frac{dE_h}{dt} = \\sum_{e,j} a_{e,j} \\left( - \\int_{-1}^1 \\partial_\\xi \\phi_j f(u_h^e) d\\xi + \\text{界面项}_j^e \\right).\n$$\n由于两种方法都使用相同的精确计算的界面项，它们在计算差值 $\\Delta$ 时会相互抵消。因此，$\\Delta$ 完全由体积积分项的差异决定：\n$$\n\\Delta = \\left(\\frac{dE_h}{dt}\\right)_{\\text{GL}} - \\left(\\frac{dE_h}{dt}\\right)_{\\text{G}} = \\sum_{e=0}^{K-1} \\sum_{j=0}^{N} a_{e,j}(0) \\left( \\left(\\text{Vol}_j^e\\right)_{\\text{G}} - \\left(\\text{Vol}_j^e\\right)_{\\text{GL}} \\right),\n$$\n其中 $a_{e,j}(0)$ 是初始条件的 $L^2$ 投影得到的模态系数，而\n$$\n\\left(\\text{Vol}_j^e\\right)_{\\text{method}} = \\int_{-1}^1 \\partial_\\xi \\phi_j(\\xi)\\, f(u_h^e(\\xi,0))\\,d\\xi,\n$$\n该积分由指定的方法（G 或 GL）进行数值计算。\n\n被积函数 $\\partial_\\xi \\phi_j(\\xi)\\, f(u_h^e(\\xi,0))$ 的多项式次数为 $(\\text{deg}(\\phi_j)-1) + 2 \\times \\text{deg}(u_h^e) = (j-1) + 2N$，最大次数为 $(N-1)+2N = 3N-1$。\n- **过积分高斯（G）求积**：使用 $Q_G = 2N+1$ 个点的高斯-勒让德求积，它对最高 $2(2N+1)-1 = 4N+1$ 次的多项式是精确的。由于 $4N+1 \\ge 3N-1$ 对于所有 $N \\ge 0$ 都成立，该方法能精确计算体积积分，即 $(\\text{Vol}_j^e)_{\\text{G}}$ 是积分的精确值。\n- **欠积分高斯-洛巴托（GL）求积**：使用 $Q_{GL} = N+1$ 个点的高斯-洛巴托求积，它仅对最高 $2(N+1)-3 = 2N-1$ 次的多项式是精确的。由于 $3N-1 > 2N-1$ 对于 $N>0$ 成立，该方法无法精确计算积分，从而引入了混叠误差。这个误差正是导致离散能量不守恒的根源。\n\n因此，$\\Delta$ 精确地量化了由欠积分（一种常见的节约计算成本的策略，例如在配置点 DG 方法中）引入的能量不守恒量。\n\n算法步骤如下：\n1.  对于每个测试用例 $(N, K, m, A)$，确定几何参数 $h=2\\pi/K$ 和 $J=h/2$。\n2.  **初始投影**：对于每个单元 $e=0, \\dots, K-1$，使用高阶高斯-勒让德求积（$Q_{\\text{proj}}=5N+5$ 点）计算初始模态系数 $a_{e,j}(0)$。\n3.  **计算体积积分**：对于每个单元 $e$，\n    a. 在两种求积点集（$Q_G$ 个高斯点和 $Q_{GL}$ 个高斯-洛巴托点）上，使用 $a_{e,j}(0)$ 重构多项式解 $u_h^e(\\xi, 0)$。\n    b. 计算非线性通量 $f(u_h^e) = (u_h^e)^2/2$。\n    c. 使用相应的求积法则计算 $(\\text{Vol}_j^e)_{\\text{G}}$ 和 $(\\text{Vol}_j^e)_{\\text{GL}}$。\n4.  **计算 $\\Delta$**：使用上面推导的公式，将所有单元和模态的贡献求和，得到最终的差值。\n\n对于某些具有对称性的特定情况（如测试用例 1、3、4），由于初始条件在相邻单元间的反对称性以及偶数个单元的设置，$\\Delta$ 的理论值为零。程序的数值结果应反映这一点（即得到一个接近机器精度的零值）。",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import Legendre\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the difference in discrete energy time derivatives\n    between two quadrature schemes for the DG method on the Burgers' equation.\n    \"\"\"\n\n    # Helper class for L2-orthonormal Legendre polynomials and their derivatives\n    class OrthonormalLegendre:\n        \"\"\"\n        Provides evaluation of orthonormal Legendre basis functions and their derivatives.\n        Caches polynomial objects for efficiency.\n        \"\"\"\n        def __init__(self, N_max):\n            self._N_max = N_max\n            self._P = []\n            self._dP = []\n            for j in range(N_max + 1):\n                coeffs = np.zeros(j + 1)\n                coeffs[j] = 1.0\n                poly = Legendre(coeffs)\n                self._P.append(poly)\n                self._dP.append(poly.deriv())\n\n        def phi(self, j, xi):\n            if j  0 or j > self._N_max:\n                raise ValueError(f\"Degree j={j} is out of range [0, {self._N_max}]\")\n            norm_const = np.sqrt((2 * j + 1) / 2.0)\n            return norm_const * self._P[j](xi)\n\n        def dphi_dxi(self, j, xi):\n            if j  0 or j > self._N_max:\n                raise ValueError(f\"Degree j={j} is out of range [0, {self._N_max}]\")\n            norm_const = np.sqrt((2 * j + 1) / 2.0)\n            return norm_const * self._dP[j](xi)\n\n    # Helper function to compute Gauss-Lobatto quadrature nodes and weights\n    def get_gauss_lobatto_quadrature(N):\n        \"\"\"\n        Computes nodes and weights for N+1 point Gauss-Lobatto quadrature.\n        Exact for polynomials of degree up to 2N-1.\n        \"\"\"\n        num_points = N + 1\n        \n        if num_points == 1: # N=0 case\n            return np.array([0.0]), np.array([2.0])\n        \n        # N_poly represents the degree of the Legendre polynomial P_N whose\n        # derivative's roots are the interior nodes. For N+1 points, this is N.\n        N_poly = N\n\n        if N_poly == 1: # N=1, 2 points\n             return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n\n        c = np.zeros(N_poly + 1)\n        c[N_poly] = 1.0\n        P_N = Legendre(c)\n        \n        interior_nodes = P_N.deriv().roots()\n        nodes = np.concatenate(([-1.0], np.sort(interior_nodes), [1.0]))\n        \n        # Weight formula: w_k = 2 / (N(N+1) * [P_N(xi_k)]^2)\n        weights = 2 / (N_poly * (N_poly + 1) * P_N(nodes)**2)\n        return nodes, weights\n\n    def compute_delta(params):\n        \"\"\"\n        Computes the target quantity Delta for a given set of parameters.\n        \"\"\"\n        N, K, m, A = params\n        \n        h = 2 * np.pi / K\n        J = h / 2.0  # Jacobian of the affine map\n\n        # Instantiate basis function helper for the given polynomial degree N\n        basis = OrthonormalLegendre(N)\n\n        # Step 1: Project initial condition u_0(x) onto the basis\n        # Use high-order Gauss-Legendre quadrature for accuracy\n        Q_proj = 5 * N + 5\n        xi_proj, w_proj = np.polynomial.legendre.leggauss(Q_proj)\n        \n        a0 = np.zeros((K, N + 1))\n        for e in range(K):\n            x_coords = (e * h) + J * (xi_proj + 1.0)\n            u0_vals = A * np.sin(m * x_coords)\n            for j in range(N + 1):\n                phi_vals = basis.phi(j, xi_proj)\n                a0[e, j] = np.sum(w_proj * u0_vals * phi_vals)\n\n        # Step 2: Compute the volume integrals using both quadrature schemes.\n        \n        # Setup for over-integrated Gauss-Legendre quadrature (G)\n        Q_g = 2 * N + 1\n        xi_g, w_g = np.polynomial.legendre.leggauss(Q_g)\n        phi_at_g = np.array([basis.phi(j, xi_g) for j in range(N + 1)])\n        dphi_at_g = np.array([basis.dphi_dxi(j, xi_g) for j in range(N + 1)])\n\n        # Setup for under-integrated Gauss-Lobatto quadrature (GL)\n        xi_gl, w_gl = get_gauss_lobatto_quadrature(N)\n        phi_at_gl = np.array([basis.phi(j, xi_gl) for j in range(N + 1)])\n        dphi_at_gl = np.array([basis.dphi_dxi(j, xi_gl) for j in range(N + 1)])\n\n        Vol_g = np.zeros((K, N + 1))\n        Vol_gl = np.zeros((K, N + 1))\n\n        # Loop over each element to compute the integrals\n        for e in range(K):\n            # Reconstruct solution at G points and compute f(u_h) = 0.5 * u_h^2\n            uh_at_g = a0[e, :] @ phi_at_g\n            f_uh_at_g = 0.5 * uh_at_g**2\n            \n            # Reconstruct solution at GL points and compute f(u_h)\n            uh_at_gl = a0[e, :] @ phi_at_gl\n            f_uh_at_gl = 0.5 * uh_at_gl**2\n\n            # Compute volume integral for each basis function j\n            for j in range(N + 1):\n                # Integral with Gauss quadrature\n                integrand_g = dphi_at_g[j, :] * f_uh_at_g\n                Vol_g[e, j] = np.sum(w_g * integrand_g)\n                \n                # Integral with Gauss-Lobatto quadrature\n                integrand_gl = dphi_at_gl[j, :] * f_uh_at_gl\n                Vol_gl[e, j] = np.sum(w_gl * integrand_gl)\n            \n        # Step 3: Compute the final difference Delta\n        # Delta = (dE/dt)_GL - (dE/dt)_G = sum_{e,j} a_{e,j}(0) * (Vol_G - Vol_GL)\n        delta = np.sum(a0 * (Vol_g - Vol_gl))\n        \n        return delta\n\n\n    test_cases = [\n        (2, 4, 2, 0.5),\n        (3, 3, 3, 1.0),\n        (1, 2, 1, 0.3),\n        (5, 2, 5, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_delta(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}