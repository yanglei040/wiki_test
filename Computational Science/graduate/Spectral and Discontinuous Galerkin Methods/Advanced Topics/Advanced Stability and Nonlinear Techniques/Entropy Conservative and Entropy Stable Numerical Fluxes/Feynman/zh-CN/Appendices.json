{
    "hands_on_practices": [
        {
            "introduction": "要深刻理解熵守恒数值通量，最有效的方法之一是从其最基本的数学构造入手。本练习将指导您针对伯格斯方程（Burgers' equation）——一个典型的非线性守恒律模型——逐步推导出一个熵守恒通量。通过完成这个推导，您将具体地理解熵函数、熵变量以及熵守恒通量的最终形式之间的内在联系 。",
            "id": "3384448",
            "problem": "考虑无粘流的标量守恒律，即伯格斯方程 (Burgers’ equation) $u_{t} + \\left(f(u)\\right)_{x} = 0$，其中$f(u) = \\frac{u^{2}}{2}$，并采用间断伽辽金（DG）方法进行离散。设一个熵对$(U(u), q(u))$由严格凸熵$U(u)$和满足相容性条件$q^{\\prime}(u) = v(u) f^{\\prime}(u)$的相应熵通量$q(u)$定义，其中熵变量为$v(u) = U^{\\prime}(u)$。对于一个两点数值通量$f^{ec}(u_{L},u_{R})$，Tadmor 熵守恒条件是界面贡献满足一个使用通量势$\\psi(u)$的离散链式法则，即$\\left(v_{R} - v_{L}\\right) f^{ec}(u_{L},u_{R}) = \\psi(u_{R}) - \\psi(u_{L})$，其中$\\psi(u)$根据熵对和物理通量定义。\n\n仅使用熵对的定义和上述离散熵守恒条件，针对二次熵$U(u) = \\frac{u^{2}}{2}$执行以下步骤：\n- 从相容性条件$q^{\\prime}(u) = v(u) f^{\\prime}(u)$推导熵通量$q(u)$。\n- 使用恒等式$\\psi(u) = v(u) f(u) - q(u)$，根据熵对和物理通量定义通量势$\\psi(u)$。\n- 使用 Tadmor 条件构建两点熵守恒通量$f^{ec}(u_{L},u_{R})$的一个闭式表达式，该表达式在极限$u_{L} \\to u_{R}$下是对称、相容且连续的。\n\n将你的最终答案表述为$f^{ec}(u_{L},u_{R})$的单个闭式解析表达式。无需进行数值计算或四舍五入。",
            "solution": "问题陈述被评估为有效，因为它具有科学依据、适定且客观。它展示了双曲守恒律数值方法领域的一个标准推导过程，特别是熵守恒通量的构建。所有提供的定义和条件都是文献中的标准内容（例如，Tadmor, 1987）。\n\n我们按要求进行推导。问题指明了伯格斯方程，其物理通量为$f(u) = \\frac{u^{2}}{2}$。我们将使用特定的二次熵函数$U(u) = \\frac{u^{2}}{2}$。\n\n首先，我们推导相应的熵变量$v(u)$和熵通量$q(u)$。\n熵变量$v(u)$定义为熵函数$U(u)$对守恒变量$u$的导数：\n$$v(u) = U^{\\prime}(u) = \\frac{d}{du}\\left(\\frac{u^{2}}{2}\\right) = u$$\n熵通量$q(u)$由相容性条件$q^{\\prime}(u) = v(u)f^{\\prime}(u)$确定。首先，我们求物理通量$f(u)$的导数：\n$$f^{\\prime}(u) = \\frac{d}{du}\\left(\\frac{u^{2}}{2}\\right) = u$$\n现在我们将$v(u)$和$f^{\\prime}(u)$代入相容性条件：\n$$q^{\\prime}(u) = (u)(u) = u^{2}$$\n为了求得$q(u)$，我们对$q^{\\prime}(u)$关于$u$进行积分。我们可以将积分常数设为零，因为熵通量的定义允许相差一个可加常数，这个常数在作差时会被抵消：\n$$q(u) = \\int u^{2} \\, du = \\frac{u^{3}}{3}$$\n\n接下来，我们使用给定的恒等式$\\psi(u) = v(u)f(u) - q(u)$来定义通量势$\\psi(u)$。我们代入$v(u)$、$f(u)$和$q(u)$的表达式：\n$$\\psi(u) = (u)\\left(\\frac{u^{2}}{2}\\right) - \\frac{u^{3}}{3} = \\frac{u^{3}}{2} - \\frac{u^{3}}{3}$$\n合并各项得到通量势的表达式：\n$$\\psi(u) = \\frac{3u^{3} - 2u^{3}}{6} = \\frac{u^{3}}{6}$$\n\n最后，我们使用 Tadmor 熵守恒条件来构建两点熵守恒通量$f^{ec}(u_{L}, u_{R})$：\n$$\\left(v(u_{R}) - v(u_{L})\\right)f^{ec}(u_{L}, u_{R}) = \\psi(u_{R}) - \\psi(u_{L})$$\n代入我们为$v(u)$和$\\psi(u)$求得的表达式，我们有$v(u_{L}) = u_{L}$，$v(u_{R}) = u_{R}$，$\\psi(u_{L}) = \\frac{u_{L}^{3}}{6}$和$\\psi(u_{R}) = \\frac{u_{R}^{3}}{6}$。该条件变为：\n$$\\left(u_{R} - u_{L}\\right)f^{ec}(u_{L}, u_{R}) = \\frac{u_{R}^{3}}{6} - \\frac{u_{L}^{3}}{6}$$\n为了求得通量，我们通过除以$(u_{R} - u_{L})$来求解$f^{ec}(u_{L}, u_{R})$，假设$u_{R} \\neq u_{L}$：\n$$f^{ec}(u_{L}, u_{R}) = \\frac{1}{u_{R} - u_{L}}\\left(\\frac{u_{R}^{3} - u_{L}^{3}}{6}\\right) = \\frac{u_{R}^{3} - u_{L}^{3}}{6(u_{R} - u_{L})}$$\n为了获得一个即使在$u_{L} = u_{R}$时也连续且良定义的闭式表达式，我们使用立方差的代数恒等式$a^{3} - b^{3} = (a-b)(a^{2} + ab + b^{2})$：\n$$u_{R}^{3} - u_{L}^{3} = (u_{R} - u_{L})(u_{R}^{2} + u_{R}u_{L} + u_{L}^{2})$$\n将这个因式分解后的形式代入通量表达式中：\n$$f^{ec}(u_{L}, u_{R}) = \\frac{(u_{R} - u_{L})(u_{R}^{2} + u_{R}u_{L} + u_{L}^{2})}{6(u_{R} - u_{L})}$$\n消去$(u_{R} - u_{L})$项，我们得到熵守恒通量的最终表达式：\n$$f^{ec}(u_{L}, u_{R}) = \\frac{u_{L}^{2} + u_{L}u_{R} + u_{R}^{2}}{6}$$\n这个表达式是对称的，因为交换$u_{L}$和$u_{R}$不会改变表达式。它也是相容的，因为在极限$u_{L} \\to u_{R} = u$的情况下，我们有：\n$$f^{ec}(u, u) = \\frac{u^{2} + u \\cdot u + u^{2}}{6} = \\frac{3u^{2}}{6} = \\frac{u^{2}}{2} = f(u)$$\n这满足了问题的所有要求。",
            "answer": "$$\\boxed{\\frac{u_{L}^{2} + u_{L}u_{R} + u_{R}^{2}}{6}}$$"
        },
        {
            "introduction": "将数值方法从简单的一维直角网格推广到更真实的曲线坐标系，会引入新的挑战。本实践将探讨在曲线网格上如何保持熵守恒性质，特别是几何守恒律（Geometric Conservation Law, GCL）在其中扮演的关键角色。您将通过编程数值地验证，不一致的网格度量计算将如何导致虚假的熵产生，从而深刻体会离散守恒格式的重要性 。",
            "id": "3384461",
            "problem": "考虑在曲线映射的方形参考单元上的二维标量线性平流方程，\n$$\\frac{\\partial u}{\\partial t} + \\nabla \\cdot (\\mathbf{c} u) = 0,$$\n其中$\\mathbf{c} = (c_x, c_y)$是一个恒定的平流速度矢量，$u(x,y,t)$是一个标量场。物理坐标$(x,y)$是通过对参考坐标$(\\xi, \\eta) \\in [-1,1]^2$进行多项式曲线映射得到的：\n$$x(\\xi,\\eta) = \\xi + \\alpha\\left(\\xi^2\\eta - \\frac{1}{2}\\xi\\eta^2\\right), \\quad y(\\xi,\\eta) = \\eta + \\alpha\\left(\\xi\\eta^2 - \\frac{1}{2}\\xi^2\\eta\\right),$$\n其中$\\alpha$是一个控制映射扭曲的实数参数。变换的雅可比行列式为\n$$J = x_\\xi y_\\eta - x_\\eta y_\\xi.$$\n定义逆变度量分量\n$$\\mathbf{a}^\\xi = \\left(y_\\eta, -x_\\eta\\right), \\quad \\mathbf{a}^\\eta = \\left(-y_\\xi, x_\\xi\\right),$$\n以及相应的变换后标量系数\n$$\\beta^\\xi = \\mathbf{c} \\cdot \\mathbf{a}^\\xi = c_x y_\\eta - c_y x_\\eta, \\quad \\beta^\\eta = \\mathbf{c} \\cdot \\mathbf{a}^\\eta = -c_x y_\\xi + c_y x_\\xi.$$\n对于多项式阶数为$N$的高斯-勒让德-洛巴托（GLL）节点离散化，每个坐标方向有$N+1$个GLL节点，记一维微分矩阵为$D$，求积权重为$w$。采用分裂形式和对称两点通量差分的间断伽辽金谱元法（DGSEM）的体项定义如下：沿每个坐标方向，使用算术平均形成一个对称的两点通量函数，并用微分矩阵$D$计算其离散散度。当离散度量恒等式和几何守恒律（GCL）通过在每个方向上使用相同的$D$进行一致的度量离散化来强制执行时，这种构造对于自由流常数解是熵守恒的。\n\n在本练习中，你将：\n- 使用上述曲线映射上的DGSEM分裂形式体离散化，为标量线性平流方程构建自由流离散残差。\n- 通过沿每个相应坐标使用相同的微分矩阵$D$计算$x_\\xi$、$x_\\eta$、$y_\\xi$、$y_\\eta$来强制执行离散度量恒等式，从而确保混合导数的可交换性并满足离散GCL $D_\\xi \\mathbf{a}^\\xi + D_\\eta \\mathbf{a}^\\eta = \\mathbf{0}$。\n- 通过在度量计算中有意使用混合和朴素微分算子来破坏度量一致性，从而量化对度量混叠的敏感性，并测量由此产生的自由流常数$u$的离散熵产生。\n\n使用以下基本基础和定义：\n- 具有恒定速度$\\mathbf{c}$的标量守恒律和标量守恒系统的熵定义$s(u) = \\frac{1}{2}u^2$，以及相应的体项半离散熵产生，\n$$\\frac{d}{dt}\\int_\\Omega J s(u)\\, d\\xi d\\eta \\approx \\sum_{i=0}^{N}\\sum_{j=0}^{N} w_i w_j J_{ij} u_{ij} R_{ij},$$\n其中$R_{ij}$表示由分裂形式体离散化在节点$(i,j)$处产生的半离散残差。\n- 在每个坐标方向上的对称两点通量差分，使用状态$u$和度量系数$\\beta^\\xi$、$\\beta^\\eta$的算术平均，以及沿相应张量积索引应用的一维微分矩阵$D$，使得分裂形式的离散散度是具有对称平均的$D$加权成对通量之和。\n\n你的程序必须：\n- 为$[-1,1]$上的每个一维坐标方向构建$N+1$个GLL节点和权重，以及相应的配置微分矩阵$D$。\n- 在张量积网格上构建曲线映射$x(\\xi,\\eta)$和$y(\\xi,\\eta)$。\n- 以三种不同模式计算度量项：\n    1. 一致模式（Consistent）：对所有坐标导数$x_\\xi$、$x_\\eta$、$y_\\xi$、$y_\\eta$，沿$\\xi$和$\\eta$方向都使用$D$。\n    2. 不匹配模式（Mismatch）：沿$\\eta$方向对$y_\\eta$使用朴素有限差分矩阵$E$，同时沿$\\eta$方向对$x_\\eta$使用$D$；沿$\\xi$方向对$y_\\xi$使用$D$，同时沿$\\xi$方向对$x_\\xi$使用$E$。\n    3. 有限差分模式（Finite-difference）：对所有坐标导数，沿两个方向都使用朴素有限差分矩阵$E$。\n- 根据所选的度量模式，一致地形成逆变矢量、标量系数$\\beta^\\xi$和$\\beta^\\eta$，以及雅可比行列式$J$。\n- 对于自由流常数解$u=u_0$（其中$u_0 = 1$），使用两个方向上两点通量的对称算术平均和沿各相应方向的微分矩阵$D$，评估分裂形式DGSEM体残差$R$。\n- 计算标量离散熵产生代理，\n$$\\Delta = \\left| \\sum_{i=0}^{N}\\sum_{j=0}^{N} w_i w_j J_{ij} u_{ij} R_{ij} \\right|,$$\n当离散度量恒等式和GCL被满足时，对于一致的度量模式，该值必须精确为零；当通过不匹配或有限差分模式引入度量混叠时，该值通常不为零。\n\n将平流速度设置为一个固定的非平凡常数$\\mathbf{c} = (1, \\frac{1}{2})$。概念上使用周期性边界条件；对于具有对称分裂形式体离散化的自由流常数解，面积分项消失，你只需要评估体残差。\n\n测试套件：\n对于以下每个参数集$(N, \\alpha, \\text{mode})$，计算并返回标量$\\Delta$作为浮点数：\n- $(6, 0.2, \\text{consistent})$。\n- $(6, 0.2, \\text{mismatch})$。\n- $(6, 0.6, \\text{mismatch})$。\n- $(4, 0.2, \\text{fd})$。\n- $(6, 0.0, \\text{mismatch})$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$\n[r_1, r_2, r_3, r_4, r_5]\n$），其中每个$r_k$是对应测试用例计算出的$\\Delta$，以机器精度单位的浮点数表示。不应打印任何其他文本。",
            "solution": "用户希望分析间断伽辽金谱元法（DGSEM）对二维标量线性平流方程的熵产生，\n$$\\frac{\\partial u}{\\partial t} + \\nabla \\cdot (\\mathbf{c} u) = 0,$$\n该方程在曲线网格上求解。问题的核心在于理解几何项的离散近似如何影响数值格式的守恒性质。一个精心设计的DGSEM的一个关键特性是其能够保持熵守恒，特别是对于像常数自由流这样的简单解，这是一个基本的一致性检验。\n\n### 第1步：理论框架\n\n**1.1. 变换坐标系下的控制方程**\n\n物理域$(x,y)$通过以下多项式映射从一个方形参考单元$(\\xi, \\eta) \\in [-1,1]^2$映射而来：\n$$x(\\xi,\\eta) = \\xi + \\alpha\\left(\\xi^2\\eta - \\frac{1}{2}\\xi\\eta^2\\right)$$\n$$y(\\xi,\\eta) = \\eta + \\alpha\\left(\\xi\\eta^2 - \\frac{1}{2}\\xi^2\\eta\\right)$$\n标量平流方程变换到这些参考坐标系后变为：\n$$\\frac{\\partial (Ju)}{\\partial t} + \\frac{\\partial (\\beta^\\xi u)}{\\partial \\xi} + \\frac{\\partial (\\beta^\\eta u)}{\\partial \\eta} = 0$$\n其中$J = x_\\xi y_\\eta - x_\\eta y_\\xi$是变换的雅可比行列式，$\\beta^\\xi = c_x y_\\eta - c_y x_\\eta$和$\\beta^\\eta = -c_x y_\\xi + c_y x_\\xi$是逆变通量系数。\n\n**1.2. 几何守恒律（GCL）**\n\n对于不随时间变化的（定常）网格，度量项满足几何守恒律（GCL）：\n$$\\frac{\\partial \\mathbf{a}^\\xi}{\\partial \\xi} + \\frac{\\partial \\mathbf{a}^\\eta}{\\partial \\eta} = \\mathbf{0}$$\n其中$\\mathbf{a}^\\xi = (y_\\eta, -x_\\eta)$和$\\mathbf{a}^\\eta = (-y_\\xi, x_\\xi)$。对于光滑映射，这个恒等式等价于混合偏导数的可交换性（例如，$x_{\\xi\\eta} = x_{\\eta\\xi}$）。将GCL与常数速度矢量$\\mathbf{c}$做点积可得：\n$$\\frac{\\partial \\beta^\\xi}{\\partial \\xi} + \\frac{\\partial \\beta^\\eta}{\\partial \\eta} = 0$$\n这个恒等式至关重要。对于常数自由流解$u=u_0$，变换后的方程简化为$u_0 \\left( \\frac{\\partial \\beta^\\xi}{\\partial \\xi} + \\frac{\\partial \\beta^\\eta}{\\partial \\eta} \\right) = 0$，这在连续层面因GCL而自然满足。一个数值格式应在离散层面复制此行为。\n\n**1.3. 分裂形式DGSEM与熵守恒**\n\n问题指定了分裂形式DGSEM。对于线性平流方程，空间算子的一种常见分裂形式是$\\frac{1}{2} (\\nabla \\cdot (\\mathbf{c}u) + \\mathbf{c} \\cdot \\nabla u)$。节点值$u_{ij}$的半离散方程为$\\frac{du_{ij}}{dt} = -R_{ij}$，其中$R_{ij}$是离散残差。对于常数自由流解（$u=u_0=1$），分裂形式体积分的离散残差显著简化。由于常数的离散导数为零（对于常数矩阵$U$，$D_\\xi U = \\mathbf{0}$，$D_\\eta U = \\mathbf{0}$），残差变为：\n$$R_{ij} = \\frac{1}{2J_{ij}} \\left( (D_\\xi \\beta^\\xi)_{ij} + (D_\\eta \\beta^\\eta)_{ij} \\right)$$\n这里，$D_\\xi$和$D_\\eta$分别表示$\\xi$和$\\eta$方向上的离散微分算子，它们基于在张量积网格上操作的一维微分矩阵$D$。\n\n离散熵的变化率由以下公式给出：\n$$\\frac{d}{dt}\\sum_{i=0}^{N}\\sum_{j=0}^{N} w_i w_j J_{ij} s(u_{ij}) = -\\sum_{i=0}^{N}\\sum_{j=0}^{N} w_i w_j J_{ij} u_{ij} R_{ij}$$\n要计算的量是这个和的绝对值，记为$\\Delta$。对于$u=u_0=1$：\n$$\\Delta = \\left| \\sum_{i,j} w_i w_j J_{ij} (1) R_{ij} \\right| = \\left| \\sum_{i,j} w_i w_j J_{ij} \\frac{1}{2J_{ij}} \\left( (D_\\xi \\beta^\\xi)_{ij} + (D_\\eta \\beta^\\eta)_{ij} \\right) \\right|$$\n$$\\Delta = \\frac{1}{2} \\left| \\sum_{i,j} w_i w_j \\left( (D_\\xi \\beta^\\xi)_{ij} + (D_\\eta \\beta^\\eta)_{ij} \\right) \\right|$$\n项$(D_\\xi \\beta^\\xi)_{ij} + (D_\\eta \\beta^\\eta)_{ij}$是GCL恒等式的离散版本。\n\n### 第2步：实现策略\n\n**2.1. 节点离散化**\n\n首先，我们在$[-1,1]$上生成$N+1$个高斯-勒让德-洛巴托（GLL）节点$\\xi_i$和相应的求积权重$w_i$。从这些节点，我们构建配置微分矩阵$D$。我们还在相同的GLL节点分布上构建一个“朴素”的二阶有限差分矩阵$E$。\n\n**2.2. 度量项计算**\n\n分析的核心在于如何计算度量导数（$x_\\xi, x_\\eta, y_\\xi, y_\\eta$）。\n- **一致模式（Consistent Mode）**：所有四个导数都使用相同的GLL微分矩阵$D$计算。例如，$x_\\xi$是通过将$D$沿$\\xi$方向应用于$x$坐标网格来找到的。在这种情况下，离散微分算子是可交换的（$D_\\xi D_\\eta = D_\\eta D_\\xi$），确保离散GCL得到满足：$D_\\xi \\beta^\\xi + D_\\eta \\beta^\\eta = \\mathbf{0}$。因此，残差$R$为零，熵产生$\\Delta$必须在机器精度内为零。\n- **不匹配模式（Mismatch Mode）**：导数是使用混合算子计算的。如问题所述，$x_\\xi$和$y_\\eta$使用朴素矩阵$E$，而$y_\\xi$和$x_\\eta$使用GLL矩阵$D$。这种不一致性破坏了可交换属性，导致非零的离散GCL项（$D_\\xi \\beta^\\xi + D_\\eta \\beta^\\eta \\neq \\mathbf{0}$）、非零残差$R$，因此产生非零的熵$\\Delta$。\n- **有限差分模式（fd Mode）**：所有四个导数都使用朴素矩阵$E$计算。虽然每个导数都使用了相同的算子，但残差计算中的离散散度仍然使用GLL矩阵$D$。用于度量的算子与用于散度的算子之间的这种不匹配也破坏了离散GCL，导致非零的熵产生。\n\n**2.3. 熵产生计算**\n\n对于每个测试用例$(N, \\alpha, \\text{mode})$，执行以下过程：\n1.  为给定的多项式阶数$N$生成GLL节点、权重和微分矩阵$D$和$E$。\n2.  使用指定的映射参数$\\alpha$构建二维网格坐标$(X, Y)$。\n3.  根据指定的 `mode` 计算度量导数矩阵（$x_\\xi, x_\\eta, y_\\xi, y_\\eta$）。\n4.  计算雅可比行列式$J$和通量系数矩阵$\\beta^\\xi$和$\\beta^\\eta$。\n5.  计算离散GCL残差项：$Res_{GCL} = (D_\\xi \\beta^\\xi) + (D_\\eta \\beta^\\eta)$，其矩阵形式为$(\\beta^\\xi \\cdot D^T) + (D \\cdot \\beta^\\eta)$。\n6.  将其代入$\\Delta$的公式中：$\\Delta = \\frac{1}{2} |\\sum_{i,j} w_i w_j (Res_{GCL})_{ij}|$。这等价于对矩阵$\\frac{1}{2} W_{2D} \\circ Res_{GCL}$的所有元素求和，其中$W_{2D}$是1D权重向量$w$的外积，$\\circ$是逐元素乘积。\n最终的Python代码为所提供的每个测试用例实现了这一逻辑。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\ndef solve():\n    \"\"\"\n    Main solver function to compute entropy production for the given test cases.\n    \"\"\"\n\n    def gll_nodes_weights(N):\n        \"\"\"\n        Computes Gauss-Legendre-Lobatto (GLL) nodes and weights for polynomial degree N.\n        \"\"\"\n        if N == 1:\n            return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n        \n        # GLL nodes are -1, 1, and the roots of the derivative of the N-th Legendre polynomial.\n        p_N = legendre(N)\n        \n        # numpy.polyder returns coefficients for a numpy.poly1d object (descending powers).\n        p_N_prime_coeffs = np.polyder(p_N.coef)\n        \n        # numpy.polynomial.polynomial.polyroots expects ascending powers, so we reverse the array.\n        interior_nodes = np.polynomial.polynomial.polyroots(p_N_prime_coeffs[::-1])\n        \n        nodes = np.concatenate(([-1.0], np.sort(np.real(interior_nodes)), [1.0]))\n        \n        # GLL weights formula\n        weights = 2.0 / (N * (N + 1) * p_N(nodes)**2)\n        \n        return nodes, weights\n\n    def differentiation_matrix(nodes):\n        \"\"\"\n        Computes the GLL collocation differentiation matrix using a barycentric formula.\n        \"\"\"\n        N = len(nodes) - 1\n        D = np.zeros((N + 1, N + 1))\n        \n        # Barycentric weights\n        bary_weights = np.ones(N + 1)\n        for j in range(N + 1):\n            for k in range(N + 1):\n                if j != k:\n                    bary_weights[j] *= (nodes[j] - nodes[k])\n        bary_weights = 1.0 / bary_weights\n\n        # Off-diagonal entries\n        for i in range(N + 1):\n            for j in range(N + 1):\n                if i != j:\n                    D[i, j] = (bary_weights[j] / bary_weights[i]) / (nodes[i] - nodes[j])\n        \n        # Diagonal entries (sum of row is zero)\n        for i in range(N + 1):\n           D[i, i] = -np.sum(D[i, :])\n\n        return D\n\n    def naive_fd_matrix(nodes):\n        \"\"\"\n        Computes a naive finite difference matrix (2nd-order interior, 1st-order boundary) on the GLL nodes.\n        \"\"\"\n        N = len(nodes) - 1\n        E = np.zeros((N + 1, N + 1))\n\n        # Forward difference at the first point\n        E[0, 0] = -1.0 / (nodes[1] - nodes[0])\n        E[0, 1] = 1.0 / (nodes[1] - nodes[0])\n\n        # Backward difference at the last point\n        if N > 0:\n            E[N, N] = 1.0 / (nodes[N] - nodes[N-1])\n            E[N, N-1] = -1.0 / (nodes[N] - nodes[N-1])\n\n        # Centered difference for interior points\n        for i in range(1, N):\n            E[i, i-1] = -1.0 / (nodes[i+1] - nodes[i-1])\n            E[i, i+1] = 1.0 / (nodes[i+1] - nodes[i-1])\n\n        return E\n\n    def compute_entropy_production(N, alpha, mode):\n        \"\"\"\n        Computes the discrete entropy production proxy Delta for a given configuration.\n        \"\"\"\n        c = np.array([1.0, 0.5])\n        u0 = 1.0\n\n        xi, w = gll_nodes_weights(N)\n        D = differentiation_matrix(xi)\n        \n        XI, ETA = np.meshgrid(xi, xi)\n        X = XI + alpha * (XI**2 * ETA - 0.5 * XI * ETA**2)\n        Y = ETA + alpha * (XI * ETA**2 - 0.5 * XI**2 * ETA)\n\n        # Derivatives w.r.t. xi are applied to columns (index 1), so op.T is right-multiplied.\n        # Derivatives w.r.t. eta are applied to rows (index 0), so op is left-multiplied.\n        if mode == 'consistent':\n            x_xi = X @ D.T\n            y_xi = Y @ D.T\n            x_eta = D @ X\n            y_eta = D @ Y\n        elif mode == 'mismatch':\n            E = naive_fd_matrix(xi)\n            x_xi = X @ E.T\n            y_xi = Y @ D.T\n            x_eta = D @ X\n            y_eta = E @ Y\n        elif mode == 'fd':\n            E = naive_fd_matrix(xi)\n            x_xi = X @ E.T\n            y_xi = Y @ E.T\n            x_eta = E @ X\n            y_eta = E @ Y\n        else:\n            raise ValueError(f\"Unknown mode: {mode}\")\n\n        J = x_xi * y_eta - x_eta * y_xi\n        beta_xi = c[0] * y_eta - c[1] * x_eta\n        beta_eta = -c[0] * y_xi + c[1] * x_xi\n        \n        # The split-form residual for a constant state (u=u0) simplifies. The rate of change\n        # of entropy is proportional to the discrete integral of the GCL residual term.\n        # R_ij = (1/(2J_ij)) * ( (D_xi beta_xi)_ij + (D_eta beta_eta)_ij )\n        # Delta = | sum(w_i w_j J u R) | = | sum(w_i w_j * 0.5 * GCL_residual) |\n        \n        gcl_residual_term = (beta_xi @ D.T) + (D @ beta_eta)\n\n        W_2d = np.outer(w, w)\n        \n        # The sum is over the elements of (W_2d * 0.5 * gcl_residual_term)\n        delta = np.abs(0.5 * np.sum(W_2d * gcl_residual_term))\n        \n        return delta\n\n    test_cases = [\n        (6, 0.2, 'consistent'),\n        (6, 0.2, 'mismatch'),\n        (6, 0.6, 'mismatch'),\n        (4, 0.2, 'fd'),\n        (6, 0.0, 'mismatch'),\n    ]\n\n    results = []\n    for N, alpha, mode in test_cases:\n        result = compute_entropy_production(N, alpha, mode)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "熵守恒的原理不仅适用于标量方程，更可以推广到复杂系统，例如用于模拟气体动力学的可压缩欧拉方程。这项综合性练习要求您构建一个完整的不连续伽辽金谱元法（DGSEM）求解器，其中包含一个为欧拉方程组专门设计的熵守恒通量。通过在周期性区域上验证总熵的守恒性，您将展示这些先进数值方法在模拟复杂物理现象中的强大能力与理论自洽性 。",
            "id": "3384472",
            "problem": "考虑针对比热比为$\\gamma \\in (1,2)$的理想气体的一维可压缩欧拉方程，其守恒变量向量$u = [\\rho, \\rho u, \\rho E]^T$的守恒形式写作：\n$$\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0,$$\n其中物理通量$f(u)$为：\n$$\nf(u) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\nu (\\rho E + p)\n\\end{bmatrix},\n$$\n且压力$p$满足理想气体状态方程：\n$$p = (\\gamma - 1)\\left(\\rho E - \\tfrac{1}{2}\\rho u^2\\right).$$\n设数学熵为一个由下式定义的凸标量$\\eta(u)$：\n$$\\eta(u) = -\\frac{\\rho}{\\gamma - 1}\\left(\\ln p - \\gamma \\ln \\rho\\right),$$\n其关联的熵变量为$v(u) = \\nabla_u \\eta(u)$，熵通量为$\\phi(u)$，满足：\n$$\\nabla_u \\eta(u)^T \\nabla_u f(u) = \\nabla_u \\phi(u).$$\n如果一个两点数值通量$h_{EC}(u_L,u_R)$满足 Tadmor 恒等式，则称其为熵守恒的：\n$$\\left(v(u_R) - v(u_L)\\right)^T h_{EC}(u_L,u_R) = \\psi(u_R) - \\psi(u_L),$$\n其中$\\psi(u) = v(u)^T f(u) - \\phi(u)$为熵势。\n\n在一个将计算域$[0,1]$划分为$K_{\\text{el}}$个相等段的周期性网格的每个单元$K$上，考虑一个多项式阶数为$N$的间断 Galerkin 谱元法 (DGSEM)，该方法在参考区间$[-1,1]$上使用 Legendre–Gauss–Lobatto 求积点$\\{x_i\\}_{i=0}^N$和权重$\\{w_i\\}_{i=0}^N$。设$D$为在 Legendre–Gauss–Lobatto 节点上 Lagrange 基的节点微分矩阵，并设$B = \\text{diag}(-1,0,\\dots,0,1)$。分裂形式通量差分的 DGSEM 半离散强形式可以对单元$K$中的每个节点$i$写为：\n$$\\frac{\\partial u_i}{\\partial t} = -\\frac{2}{J_K}\\sum_{j=0}^N D_{ij}\\,h_{EC}(u_i,u_j) + \\frac{1}{J_K} B_{ii}\\left(f^\\ast_{\\partial K} - f(u_i)\\right),$$\n其中$J_K$是从$[-1,1]$到物理单元$K$的仿射映射雅可比，$f^\\ast_{\\partial K}$是单元$K$左/右面上的界面数值通量，通过将相同的两点熵守恒通量$h_{EC}$应用于每个面上的左右迹来构造。\n\n您必须：\n\n1. 使用 Chandrashekar 的熵守恒两点通量$h_{EC}(u_L,u_R)$和上文定义的理想气体熵$\\eta(u)$，为一维可压缩欧拉方程构建具有分裂形式通量差分的 DGSEM。使用$N \\ge 2$和$K_{\\text{el}} \\ge 2$。\n\n2. 在周期性网格上，实现半离散 DGSEM 并计算离散总熵率\n$$\\frac{d}{dt}\\sum_{K}\\int_{K}\\eta(u)\\,dx \\approx \\sum_K J_K \\sum_{i=0}^N w_i \\, v(u_{K,i})^T \\frac{\\partial u_{K,i}}{\\partial t},$$\n并数值验证其等于所有单元边界上熵通量贡献的负和\n$$-\\sum_{\\partial K}\\widehat{\\Phi}_\\eta,$$\n其中边界熵通量$\\widehat{\\Phi}_\\eta$是由相同的熵守恒界面通量导出的，并且在周期性网格上必须为零。因此，在周期性网格上，对于物理上允许的状态，离散总熵率必须近似为零。\n\n您的推导和构建必须基于以下基本原理，不得使用问题陈述中提供的快捷公式：\n- 可压缩欧拉方程的守恒形式、理想气体定律以及带有关联熵变量和熵通量的凸熵。\n- 在$[-1,1]$上，使用 Lagrange 基的 Legendre–Gauss–Lobatto 求积及其微分矩阵的分部求和 (SBP) 性质。\n- 用于两点通量和通量差分的 Tadmor 熵守恒框架。\n\n实现一个完整的程序，该程序：\n- 为指定的多项式阶数$N$计算 Legendre–Gauss–Lobatto 节点和权重，构造重心微分矩阵$D$，并在内部验证 SBP 恒等式$M D + D^T M = B$，其中$M = \\text{diag}(w_0,\\dots,w_N)$。\n- 使用对数平均和适当的平均值，为一维欧拉方程实现 Chandrashekar 的熵守恒两点通量$h_{EC}(u_L,u_R)$。\n- 为具有$K_{\\text{el}}$个单元的周期性网格组装 DGSEM 残差，并使用熵变量计算离散总熵率。\n- 对于一系列光滑的、物理上允许的测试状态，数值验证周期性网格上的离散总熵率近似为零。\n\n在$[0,1]$上使用以下参数值和初始状态的测试套件：\n- 测试用例 1 (常数状态，理想路径)：$\\gamma=1.4$, $N=4$, $K_{\\text{el}}=4$, $\\rho(x)=1$, $u(x)=0.3$, $p(x)=1$。\n- 测试用例 2 (光滑扰动)：$\\gamma=1.4$, $N=5$, $K_{\\text{el}}=3$, $\\rho(x)=1+0.01\\cos(2\\pi x)$, $u(x)=0.5+0.05\\sin(2\\pi x)$, $p(x)=1+0.02\\cos(2\\pi x+0.3)$。\n- 测试用例 3 (围绕常数状态的小随机扰动)：$\\gamma=1.4$, $N=3$, $K_{\\text{el}}=5$, $\\rho(x)=1+10^{-3}\\,\\xi_1(x)$, $u(x)=0.2+10^{-3}\\,\\xi_2(x)$, $p(x)=1+10^{-3}\\,\\xi_3(x)$ 其中$\\xi_k(x)$是独立的和光滑随机场，通过对每个单元采样独立的均匀随机值并使用$N$阶 Lagrange 插值多项式插值到节点生成；如有必要，通过平移确保各处的$p(x) > 0.5$。\n- 测试用例 4 (边界解析度边缘情况)：$\\gamma=1.4$, $N=2$, $K_{\\text{el}}=2$, $\\rho(x)=1+0.005\\sin(4\\pi x)$, $u(x)=0.1+0.005\\cos(4\\pi x)$, $p(x)=1+0.005\\sin(4\\pi x)$，如有需要进行调整以保持正性。\n\n对于每个测试用例，您的程序必须使用 DGSEM 残差计算周期性网格上的离散总熵率，并确定其大小是否小于容差$\\tau = 10^{-10}$，为每个用例返回一个布尔结果。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3,result4]\"），其中每个结果都是一个布尔值，指示相应测试用例的离散总熵率是否近似为零。",
            "solution": "用户旨在验证用于一维可压缩欧拉方程的间断 Galerkin 谱元法 (DGSEM) 的熵守恒性质。该方法基于一种分裂形式通量差分方法，使用 Legendre-Gauss-Lobatto (LGL) 节点和 Chandrashekar 的熵守恒两点通量。问题要求进行数值验证，即对于周期性域上的光滑、物理上允许的初始状态，离散总熵产生率近似为零，正如熵守恒格式理论所规定的那样。\n\n解决方案的结构如下：\n1.  **数学和数值准备**：建立函数来处理 DGSEM 框架的必要组件。这包括：\n    *   为给定的多项式阶数$N$生成 Legendre-Gauss-Lobatto (LGL) 节点和求积权重。节点是$(1-x^2)P_N'(x)$的根，其中$P_N(x)$是$N$阶 Legendre 多项式。\n    *   为定义在 LGL 节点上的 Lagrange 基构建节点微分矩阵$D$。非对角线元素使用 Legendre 多项式的性质计算，而对角线元素则由常数的导数必须为零（$\\sum_j D_{ij} = 0$）的条件确定。\n    *   对分部求和 (SBP) 性质进行内部验证，$M D + D^T M = B$，其中$M$是求积权重的对角质量矩阵，$B$是边界算子$\\text{diag}(-1, 0, \\dots, 0, 1)$。这确认了离散算子的正确性。\n\n2.  **物理建模**：实现函数以根据一维可压缩欧拉方程描述理想气体的物理特性。\n    *   在守恒变量$u=[\\rho, \\rho u, \\rho E]^T$和原始变量$[\\rho, u, p]$之间进行转换。\n    *   物理通量$f(u) = [\\rho u, \\rho u^2 + p, u (\\rho E + p)]^T$。\n    *   从守恒状态$u$计算熵变量$v(u) = \\nabla_u \\eta(u)$。熵变量从指定的凸熵函数$\\eta(u)$导出，结果为$v = [(\\gamma-s)/(\\gamma-1) - \\rho u^2/(2p), \\rho u/p, -\\rho/p]^T$，其中$s = \\ln(p/\\rho^\\gamma)$。\n\n3.  **熵守恒通量**：实现了 Chandrashekar 的熵守恒两点通量$h_{EC}(u_L, u_R)$。该通量对格式的稳定性至关重要。其公式依赖于左 ($L$) 和右 ($R$) 状态的流体属性的特定平均值。具体来说，我们使用算术平均$\\overline{(\\cdot)}$、对数平均$\\overline{(\\cdot)}^{\\ln}$和一个特殊的压力平均$\\overline{p} = (\\rho_L+\\rho_R) / (\\rho_L/p_L + \\rho_R/p_R)$。通量分量为：\n    $$\n    \\begin{aligned}\n    f_1^* &= \\overline{\\rho}^{\\ln} \\overline{u} \\\\\n    f_2^* &= \\overline{p} + \\overline{u} f_1^* \\\\\n    f_3^* &= \\overline{u}\\left( \\frac{\\gamma\\overline{p}}{\\gamma-1} + \\frac{1}{2}\\overline{\\rho}^{\\ln}\\overline{u^2} \\right)\n    \\end{aligned}\n    $$\n\n4.  **DGSEM 残差组装**：组装 DGSEM 的半离散形式以计算每个节点$i$处解的时间导数$\\partial u_i / \\partial t$。这对每个单元涉及两个主要部分：\n    *   **体积分**：一个通量差分项$-\\frac{2}{J_K}\\sum_{j=0}^N D_{ij}\\,h_{EC}(u_i,u_j)$，它近似了单元内部通量的散度。\n    *   **面积分**：一个用于耦合相邻单元的项$\\frac{1}{J_K} B_{ii}\\left(f^\\ast_{\\partial K} - f(u_i)\\right)$，用于惩罚单元边界处界面通量$f^\\ast$和物理通量$f(u_i)$之间的差异。对于周期性边界条件，单元边界处的界面通量是使用 Chandrashekar 通量$h_{EC}$应用于内部状态和来自相应周期性邻居的状态来构造的。\n\n5.  **熵守恒验证**：核心任务是计算离散总熵产生率并验证其值可忽略不计。该率由应用于总离散熵的链式法则给出：\n    $$ \\frac{d\\mathcal{E}}{dt} = \\frac{d}{dt}\\sum_{K} J_K \\sum_{i=0}^N w_i \\eta(u_{K,i}) = \\sum_K J_K \\sum_{i=0}^N w_i \\, v(u_{K,i})^T \\frac{\\partial u_{K,i}}{\\partial t} $$\n    项$\\partial u_{K,i} / \\partial t$是上一步计算的 DGSEM 残差。对于周期性域上的熵守恒格式，该量理论上为零。实现中计算这个总和，并检查其大小是否低于数值容差$\\tau=10^{-10}$。\n\n6.  **测试执行**：将该程序应用于问题陈述中指定的四个测试用例，涵盖常数状态、光滑扰动和随机扰动。对于每个用例，设置初始条件，计算 DGSEM 残差，计算熵率，并将结果与容差进行比较。然后生成一个布尔结果列表。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre, roots_jacobi\n\ndef solve():\n    \"\"\"\n    Main function to run the DGSEM entropy conservation verification.\n    \"\"\"\n    \n    # Test suite from problem statement\n    TEST_SUITE = [\n        {'gamma': 1.4, 'N': 4, 'K_el': 4, 'case': 'constant'},\n        {'gamma': 1.4, 'N': 5, 'K_el': 3, 'case': 'smooth_pert'},\n        {'gamma': 1.4, 'N': 3, 'K_el': 5, 'case': 'random_pert'},\n        {'gamma': 1.4, 'N': 2, 'K_el': 2, 'case': 'bdy_res'}\n    ]\n    TOLERANCE = 1e-10\n    LOGMEAN_EPS = 1e-5\n\n    # --- Start of Helper Functions ---\n    \n    def legendre_gauss_lobatto(N):\n        \"\"\"\n        Computes Legendre-Gauss-Lobatto nodes and weights on [-1, 1].\n        \"\"\"\n        if N == 0:\n            return np.array([0.0]), np.array([2.0])\n        if N == 1:\n            return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n\n        interior_nodes, _ = roots_jacobi(N - 1, 1, 1)\n        nodes = np.sort(np.concatenate(([-1.0], interior_nodes, [1.0])))\n        \n        Pn = legendre(N)\n        weights = 2 / (N * (N + 1) * Pn(nodes)**2)\n        return nodes, weights\n\n    def differentiation_matrix(N, nodes):\n        \"\"\"\n        Computes the differentiation matrix for Lagrange basis on LGL nodes.\n        \"\"\"\n        D = np.zeros((N + 1, N + 1))\n        Pn = legendre(N)\n        for i in range(N + 1):\n            for j in range(N + 1):\n                if i != j:\n                    D[i, j] = Pn(nodes[i]) / (Pn(nodes[j]) * (nodes[i] - nodes[j]))\n        \n        for i in range(N + 1):\n            D[i, i] = -np.sum(D[i, :])\n        return D\n\n    def sbp_check(N, D, M, B):\n        \"\"\"\n        Verifies the SBP property: M D + D^T M = B.\n        \"\"\"\n        err = np.linalg.norm(M @ D + D.T @ M - B)\n        if err > 1e-12:\n            raise RuntimeError(f\"SBP property check failed for N={N}. Error: {err}\")\n\n    def prim_to_cons(rho, u, p, gamma):\n        rho_u = rho * u\n        rho_E = p / (gamma - 1) + 0.5 * rho * u**2\n        return np.stack([rho, rho_u, rho_E], axis=-1)\n\n    def cons_to_prim(U, gamma):\n        rho = U[..., 0]\n        rho_u = U[..., 1]\n        rho_E = U[..., 2]\n        \n        # Add a small stabilization for division by zero\n        rho_stable = rho + 1e-40\n\n        u = rho_u / rho_stable\n        p = (gamma - 1) * (rho_E - 0.5 * rho * u**2)\n        return rho, u, p\n\n    def cons_to_entropy_vars(U, gamma):\n        rho, u, p = cons_to_prim(U, gamma)\n        s = np.log(p) - gamma * np.log(rho)\n        v1 = (gamma - s) / (gamma - 1) - 0.5 * rho * u**2 / p\n        v2 = rho * u / p\n        v3 = -rho / p\n        return np.stack([v1, v2, v3], axis=-1)\n\n    def physical_flux(U, gamma):\n        rho, u, p = cons_to_prim(U, gamma)\n        rho_E = U[..., 2]\n        \n        f1 = rho * u\n        f2 = rho * u**2 + p\n        f3 = (rho_E + p) * u\n        return np.stack([f1, f2, f3], axis=-1)\n\n    def logmean(a, b, epsilon=LOGMEAN_EPS):\n        a_ = np.asarray(a)\n        b_ = np.asarray(b)\n        out = np.zeros_like(a_, dtype=np.promote_types(a_.dtype, b_.dtype))\n\n        ratio = np.divide(b_, a_, where=a_!=0)\n        idx_close = np.abs(ratio - 1.0) < epsilon\n\n        # Non-broadcasted part\n        if a_.ndim == 0:\n            if idx_close: return (a_ + b_) / 2.0\n            return (a_ - b_) / (np.log(a_) - np.log(b_))\n        \n        out[idx_close] = (a_[idx_close] + b_[idx_close]) / 2.0\n        \n        idx_not_close = ~idx_close\n        a_nc, b_nc = a_[idx_not_close], b_[idx_not_close]\n        \n        # Handle cases where a_nc or b_nc could be zero\n        log_a = np.log(a_nc, where=a_nc>0)\n        log_b = np.log(b_nc, where=b_nc>0)\n\n        out[idx_not_close] = (a_nc - b_nc) / (log_a - log_b)\n        \n        return out\n\n    def chandrashekar_ec_flux(u_L, u_R, gamma):\n        rho_L, u_L, p_L = cons_to_prim(u_L, gamma)\n        rho_R, u_R, p_R = cons_to_prim(u_R, gamma)\n\n        rho_ln = logmean(rho_L, rho_R)\n        u_mean = 0.5 * (u_L + u_R)\n        u_sq_mean = 0.5 * (u_L**2 + u_R**2)\n\n        # Harmonic mean of pressure weighted by density\n        p_mean = (rho_L + rho_R) / (rho_L / p_L + rho_R / p_R)\n        \n        f1 = rho_ln * u_mean\n        f2 = p_mean + u_mean * f1\n        f3 = u_mean * (gamma * p_mean / (gamma - 1) + 0.5 * rho_ln * u_sq_mean)\n        \n        return np.stack([f1, f2, f3], axis=-1)\n\n    def dgsem_residual(u_all, K_el, N, D, gamma, Jk):\n        residual = np.zeros_like(u_all)\n        \n        for k in range(K_el):\n            u_k = u_all[k, :, :]\n            h_matrix = np.array([[chandrashekar_ec_flux(u_k[i], u_k[j], gamma) for j in range(N + 1)] for i in range(N + 1)])\n            vol_term = -2.0 / Jk * np.einsum('ij,ijk->ik', D, h_matrix)\n            residual[k, :, :] += vol_term\n\n        for k in range(K_el):\n            k_neighbor_L = (k - 1 + K_el) % K_el\n            u_inner_L = u_all[k, 0, :]\n            u_outer_L = u_all[k_neighbor_L, N, :]\n            f_star_L = chandrashekar_ec_flux(u_outer_L, u_inner_L, gamma)\n            f_inner_L = physical_flux(u_inner_L, gamma)\n            residual[k, 0, :] += (1.0 / Jk) * (-1.0) * (f_star_L - f_inner_L)\n\n            k_neighbor_R = (k + 1) % K_el\n            u_inner_R = u_all[k, N, :]\n            u_outer_R = u_all[k_neighbor_R, 0, :]\n            f_star_R = chandrashekar_ec_flux(u_inner_R, u_outer_R, gamma)\n            f_inner_R = physical_flux(u_inner_R, gamma)\n            residual[k, N, :] += (1.0 / Jk) * (1.0) * (f_star_R - f_inner_R)\n            \n        return residual\n\n    def compute_total_entropy_rate(u_all, dudt, weights, Jk, gamma):\n        v_all = cons_to_entropy_vars(u_all, gamma)\n        integrand = np.einsum('kni,kni->kn', v_all, dudt)\n        elementwise_sum = np.sum(integrand * weights, axis=1)\n        total_rate = Jk * np.sum(elementwise_sum)\n        return total_rate\n\n    def run_test_case(params, test_seed):\n        gamma, N, K_el, case = params['gamma'], params['N'], params['K_el'], params['case']\n        \n        nodes_ref, weights = legendre_gauss_lobatto(N)\n        D = differentiation_matrix(N, nodes_ref)\n        \n        M = np.diag(weights)\n        B = np.diag([-1.] + [0.]*(N-1) + [1.]) if N > 0 else np.diag([-1.0])\n        sbp_check(N, D, M, B)\n        \n        dx = 1.0 / K_el\n        Jk = dx / 2.0\n        x_nodes = np.array([k * dx + dx * (nodes_ref + 1) / 2.0 for k in range(K_el)])\n\n        u_all = np.zeros((K_el, N + 1, 3))\n        \n        rho_vals, u_vals, p_vals = None, None, None\n\n        if case == 'constant':\n            rho_vals = np.full_like(x_nodes, 1.0)\n            u_vals = np.full_like(x_nodes, 0.3)\n            p_vals = np.full_like(x_nodes, 1.0)\n        elif case == 'smooth_pert':\n            rho_vals = 1.0 + 0.01 * np.cos(2 * np.pi * x_nodes)\n            u_vals = 0.5 + 0.05 * np.sin(2 * np.pi * x_nodes)\n            p_vals = 1.0 + 0.02 * np.cos(2 * np.pi * x_nodes + 0.3)\n        elif case == 'random_pert':\n            rng = np.random.default_rng(test_seed)\n            rho_vals = 1.0 + 1e-3 * rng.uniform(-1, 1, size=(K_el, N + 1))\n            u_vals = 0.2 + 1e-3 * rng.uniform(-1, 1, size=(K_el, N + 1))\n            p_vals = 1.0 + 1e-3 * rng.uniform(-1, 1, size=(K_el, N + 1))\n        elif case == 'bdy_res':\n            rho_vals = 1.0 + 0.005 * np.sin(4 * np.pi * x_nodes)\n            u_vals = 0.1 + 0.005 * np.cos(4 * np.pi * x_nodes)\n            p_vals = 1.0 + 0.005 * np.sin(4 * np.pi * x_nodes)\n\n        # Ensure positivity of pressure (and density)\n        min_p = np.min(p_vals)\n        if min_p < 0.5:\n            p_vals += (0.5 - min_p)\n        min_rho = np.min(rho_vals)\n        if min_rho <= 0:\n            rho_vals += (-min_rho + 1e-6)\n\n        u_all = prim_to_cons(rho_vals, u_vals, p_vals, gamma)\n\n        dudt = dgsem_residual(u_all, K_el, N, D, gamma, Jk)\n        rate = compute_total_entropy_rate(u_all, dudt, weights, Jk, gamma)\n        \n        return abs(rate) < TOLERANCE\n\n    # --- End of Helper Functions ---\n\n    results = []\n    # Use a fixed seed for the random test case to ensure reproducibility\n    random_test_seed = 42\n    for params in TEST_SUITE:\n        result = run_test_case(params, random_test_seed)\n        results.append(str(result).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}