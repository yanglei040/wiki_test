{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of designing entropy-stable discontinuous Galerkin (DG) schemes is ensuring that the analytical entropy identity is mimicked discretely within each element. This often hinges on the exact integration of nonlinear terms. This first practice  challenges you to determine the minimum numerical precision required to achieve this for the inviscid Burgers' equation, a fundamental model for nonlinear wave phenomena. By calculating the necessary quadrature order, you will gain a concrete understanding of the interplay between polynomial approximation degree and the structure of nonlinear fluxes.",
            "id": "3380666",
            "problem": "Consider the scalar one-dimensional inviscid Burgers equation\n$$\nu_{t} + \\partial_{x} f(u) = 0, \\qquad f(u) = \\tfrac{1}{2} u^{2},\n$$\nposed on a partition of the domain into nonoverlapping elements, with an affine mapping from each physical element to the reference element. On each element, approximate the solution by a polynomial $u_{h}$ in the space $\\mathbb{P}^{N}$ of degree at most $N$, with $N \\geq 1$. Let the Discontinuous Galerkin (DG) method be formulated in a standard weak form on each element, and consider the discrete entropy analysis based on a convex entropy $U(u)$ and its associated entropy flux $F(u)$ defined by the relation\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}u} F(u) \\;=\\; \\frac{\\mathrm{d}}{\\mathrm{d}u} U(u) \\; \\frac{\\mathrm{d}}{\\mathrm{d}u} f(u).\n$$\nFor inviscid Burgers, take the canonical quadratic entropy $U(u) = \\tfrac{1}{2} u^{2}$, so that the entropy variable is $v(u) = \\tfrac{\\mathrm{d}}{\\mathrm{d}u}U(u) = u$ and the associated entropy flux satisfies $\\tfrac{\\mathrm{d}}{\\mathrm{d}u}F(u) = u \\cdot \\tfrac{\\mathrm{d}}{\\mathrm{d}u}f(u) = u \\cdot u = u^{2}$.\n\nIn the element-wise discrete entropy balance, a key volume contribution is the integral\n$$\nI \\;=\\; \\int_{K} v(u_{h}) \\, \\partial_{x} f(u_{h}) \\, \\mathrm{d}x \\;=\\; \\int_{K} \\frac{\\mathrm{d}}{\\mathrm{d}u}U(u_{h}) \\; \\frac{\\mathrm{d}}{\\mathrm{d}u}f(u_{h}) \\; \\partial_{x} u_{h} \\, \\mathrm{d}x,\n$$\nwhich equals $\\int_{K} \\partial_{x} F(u_{h}) \\, \\mathrm{d}x$ if the pointwise chain rule is realized. Suppose that this volume integral is evaluated using a Gauss–Legendre quadrature with $Q$ points on the reference element, which is exact for all polynomials of degree up to $2Q-1$, and assume the affine element mapping so that polynomial degrees are preserved.\n\nDetermine, as a function of $N$, the minimal number of Gauss–Legendre points $Q$ needed so that the quadrature exactly integrates the entropy flux contribution $I$ on each element. Express your final answer as a single closed-form analytic expression in terms of $N$.",
            "solution": "The objective is to find the minimal number of Gauss-Legendre quadrature points, $Q$, required to exactly evaluate the volume integral $I = \\int_{K} v(u_{h}) \\, \\partial_{x} f(u_{h}) \\, \\mathrm{d}x$ on a given element $K$. The numerical approximation to the solution, $u_h$, is a polynomial of degree at most $N$ within the space $\\mathbb{P}^{N}$, where $N \\ge 1$.\n\nA Gauss-Legendre quadrature rule with $Q$ points is exact for the integral of any polynomial of degree up to $2Q-1$. To ensure the exact evaluation of $I$, the degree of the integrand must be less than or equal to this value. Let the integrand be denoted by $\\mathcal{I}(x) = v(u_{h}(x)) \\, \\partial_{x} f(u_{h}(x))$. Our first step is to determine the polynomial degree of $\\mathcal{I}(x)$.\n\nThe problem provides the following definitions for the inviscid Burgers' equation:\n1.  The flux function is $f(u) = \\frac{1}{2} u^{2}$.\n2.  The entropy function is $U(u) = \\frac{1}{2} u^{2}$.\n3.  The entropy variable is $v(u) = \\frac{\\mathrm{d}}{\\mathrm{d}u}U(u) = u$.\n\nWhen evaluated for the approximate solution $u_h$, the entropy variable becomes $v(u_h(x)) = u_h(x)$. Since $u_h(x) \\in \\mathbb{P}^{N}$, the degree of $v(u_h(x))$ is at most $N$.\n$$\n\\text{deg}(v(u_h)) = N.\n$$\nNext, we analyze the term $\\partial_{x} f(u_{h}(x))$. The composite function $f(u_h(x))$ is $f(u_h(x)) = \\frac{1}{2} (u_h(x))^{2}$, which is a polynomial of degree $2N$. Using the chain rule, its spatial derivative is:\n$$\n\\partial_{x} f(u_{h}(x)) = \\frac{\\mathrm{d}}{\\mathrm{d}x} \\left( \\frac{1}{2} (u_h(x))^{2} \\right) = u_h(x) \\, \\partial_{x} u_h(x).\n$$\nThe degree of $u_h(x)$ is $N$, and the degree of its derivative, $\\partial_{x} u_h(x)$, is $N-1$ (since $N \\ge 1$). The degree of their product is the sum of their degrees:\n$$\n\\text{deg}(\\partial_{x} f(u_h)) = N + (N-1) = 2N-1.\n$$\nNow we can determine the degree of the full integrand $\\mathcal{I}(x) = v(u_h(x)) \\, \\partial_{x} f(u_h(x)) = u_h(x) \\, (u_h(x) \\, \\partial_x u_h(x)) = (u_h(x))^2 \\, \\partial_x u_h(x)$:\n$$\n\\text{deg}(\\mathcal{I}) = \\text{deg}((u_h)^2) + \\text{deg}(\\partial_x u_h) = 2N + (N-1) = 3N-1.\n$$\nFor the $Q$-point Gauss-Legendre quadrature to be exact, its degree of precision must be at least the degree of the integrand:\n$$\n2Q - 1 \\ge 3N - 1.\n$$\nThis inequality simplifies to:\n$$\n2Q \\ge 3N\n$$\n$$\nQ \\ge \\frac{3N}{2}.\n$$\nThe problem asks for the minimal number of points $Q$, which must be an integer. Therefore, we must take the smallest integer that is greater than or equal to $\\frac{3N}{2}$. This is given by the ceiling function:\n$$\nQ = \\left\\lceil \\frac{3N}{2} \\right\\rceil.\n$$\nThis is the required closed-form analytic expression.",
            "answer": "$$\n\\boxed{\\left\\lceil \\frac{3N}{2} \\right\\rceil}\n$$"
        },
        {
            "introduction": "While handling the homogeneous part of a conservation law is crucial, the introduction of source terms presents a new challenge to maintaining discrete entropy stability. A naive, pointwise evaluation of a source term can introduce spurious entropy production, violating the physical principle we aim to preserve. This exercise  provides a direct comparison between a simple pointwise approach and a carefully constructed \"entropy-balanced\" discretization. By computing the resulting entropy residual for both, you will see firsthand why specialized source term treatments are essential for robust, stable simulations of balance laws.",
            "id": "3380676",
            "problem": "Consider the one-dimensional nonlinear scalar balance law\n$$\nu_{t} + f(u)_{x} = s(u,x),\n$$\non the reference element $x \\in [-1,1]$ with periodic boundary conditions, and suppose the advective flux contribution is identically zero, $f(u)_{x} \\equiv 0$, so that only the source term contributes to the entropy balance. Let the entropy/entropy-flux pair be given by $U(u) = \\frac{1}{2} u^{2}$ and $F(u) = \\frac{1}{3} u^{3}$, with entropy variable $v(u) = U'(u) = u$.\n\nIn a spectral Galerkin semi-discretization of total polynomial degree $N=2$ on $[-1,1]$, the discrete inner products are computed using Gauss–Lobatto–Legendre (GLL) quadrature with nodes $x_{1}=-1$, $x_{2}=0$, $x_{3}=1$ and weights $w_{1}=\\frac{1}{3}$, $w_{2}=\\frac{4}{3}$, $w_{3}=\\frac{1}{3}$. Assume the approximate solution at a fixed time is the polynomial\n$$\nu(x) = 1 + x + x^{2}.\n$$\nConsider the nonlinear source $s(u,x) = u(x)^{3}$.\n\nDefine the discrete entropy residual for a source discretization $s^{d}$ as\n$$\nR[s^{d}] = v^{T} W \\,\\dot{u} - v^{T} W \\, s^{d},\n$$\nwhere $v$ is the vector of entropy variables evaluated at the GLL nodes, $W = \\mathrm{diag}(w_{1}, w_{2}, w_{3})$ is the diagonal quadrature weight matrix, and $\\dot{u}$ is the semi-discrete time derivative provided by the spectral Galerkin method. In the absence of advection, the spectral Galerkin method produces $\\dot{u}$ as the $L^{2}$ projection of $s(u,x)$ onto the polynomial subspace of degree at most $2$.\n\nYou will compare two source discretizations:\n- A pointwise (collocation) source discretization $s^{\\mathrm{pw}}$ that uses nodal evaluation, i.e., $s^{\\mathrm{pw}}(x_{i}) = s(u(x_{i}),x_{i})$.\n- An entropy-balanced source discretization $s^{\\mathrm{bal}}$ that uses the entropy variable $v$ and enforces discrete entropy consistency by taking $\\dot{u}$ equal to the $L^{2}$ projection of $s(u,x)$ onto degree $\\leq 2$, and the right-hand side in the discrete entropy equation equal to $v^{T} W$ applied to the same $L^{2}$ projection.\n\nCompute the two discrete entropy residuals\n$$\nR[s^{\\mathrm{pw}}] \\quad \\text{and} \\quad R[s^{\\mathrm{bal}}],\n$$\nfor the given $u(x)$ and quadrature, using Legendre polynomials up to degree $2$ to form the $L^{2}$ projection on $[-1,1]$. Explicitly, use $P_{0}(x)=1$, $P_{1}(x)=x$, and $P_{2}(x)=\\frac{1}{2}(3x^{2}-1)$, with $\\int_{-1}^{1} P_{m}(x) P_{n}(x) \\,\\mathrm{d}x = \\frac{2}{2n+1} \\delta_{mn}$. Express your final answers in exact form. No rounding is required. The final output must be the two residuals as a single row matrix in the order $\\big(R[s^{\\mathrm{pw}}] \\;\\; R[s^{\\mathrm{bal}}]\\big)$.",
            "solution": "The problem asks for the computation of two discrete entropy residuals, $R[s^{\\mathrm{pw}}]$ and $R[s^{\\mathrm{bal}}]$. The discrete entropy residual is defined as $R[s^{d}] = v^{T} W \\dot{u} - v^{T} W s^{d}$.\n\n**1. GLL Nodes, Weights, and Nodal Values**\nThe GLL nodes ($N=2$) are $x_1 = -1$, $x_2 = 0$, $x_3 = 1$. The weights are $w_1 = \\frac{1}{3}$, $w_2 = \\frac{4}{3}$, $w_3 = \\frac{1}{3}$, so $W = \\mathrm{diag}(\\frac{1}{3}, \\frac{4}{3}, \\frac{1}{3})$.\nThe solution is $u(x) = 1 + x + x^2$. At the nodes:\n$u_1 = u(-1) = 1 - 1 + 1 = 1$.\n$u_2 = u(0) = 1$.\n$u_3 = u(1) = 1 + 1 + 1 = 3$.\nThe entropy variable is $v(u) = u$, so the vector of nodal entropy variables is $v = (1, 1, 3)^T$.\n\n**2. Pointwise Source Term ($s^{\\mathrm{pw}}$)**\nThe source term is $s(u,x) = u(x)^3$. The pointwise discretization is $s^{\\mathrm{pw}}_i = (u_i)^3$.\n$s^{\\mathrm{pw}}_1 = 1^3 = 1$.\n$s^{\\mathrm{pw}}_2 = 1^3 = 1$.\n$s^{\\mathrm{pw}}_3 = 3^3 = 27$.\nThe vector is $s^{\\mathrm{pw}} = (1, 1, 27)^T$.\n\n**3. Semi-discrete Time Derivative ($\\dot{u}$)**\nThe time derivative $\\dot{u}$ is the vector of nodal values of the $L^2$ projection of $s(u(x),x)$ onto the space of polynomials of degree at most 2, $\\mathcal{P}_2$. Let this projection be $\\dot{u}_{\\mathrm{proj}}(x)$.\nThe full source term is $s(x) = (1+x+x^2)^3 = 1+3x+6x^2+7x^3+6x^4+3x^5+x^6$.\nWe project $s(x)$ onto the Legendre basis $\\{P_0, P_1, P_2\\}$. The projection is $\\dot{u}_{\\mathrm{proj}}(x) = c_0 P_0(x) + c_1 P_1(x) + c_2 P_2(x)$, where $c_k = \\frac{\\langle s, P_k \\rangle}{\\langle P_k, P_k \\rangle}$.\n$c_0 = \\frac{1}{2} \\int_{-1}^{1} s(x) dx = \\frac{1}{2} \\cdot \\frac{304}{35} = \\frac{152}{35}$.\n$c_1 = \\frac{3}{2} \\int_{-1}^{1} s(x) x dx = \\frac{3}{2} \\cdot \\frac{198}{35} = \\frac{297}{35}$.\n$c_2 = \\frac{5}{2} \\int_{-1}^{1} s(x) \\frac{1}{2}(3x^2-1) dx = \\frac{5}{2} \\cdot \\frac{332}{105} = \\frac{166}{21}$.\nThe projected polynomial is $\\dot{u}_{\\mathrm{proj}}(x) = \\frac{152}{35} P_0(x) + \\frac{297}{35} P_1(x) + \\frac{166}{21} P_2(x) = \\frac{41}{105} + \\frac{297}{35}x + \\frac{83}{7}x^2$.\nEvaluating at the GLL nodes:\n$\\dot{u}_1 = \\dot{u}_{\\mathrm{proj}}(-1) = \\frac{41}{105} - \\frac{297}{35} + \\frac{83}{7} = \\frac{395}{105} = \\frac{79}{21}$.\n$\\dot{u}_2 = \\dot{u}_{\\mathrm{proj}}(0) = \\frac{41}{105}$.\n$\\dot{u}_3 = \\dot{u}_{\\mathrm{proj}}(1) = \\frac{41}{105} + \\frac{297}{35} + \\frac{83}{7} = \\frac{2177}{105}$.\nThe vector is $\\dot{u} = (79/21, 41/105, 2177/105)^T$.\n\n**4. Computation of Residual for Pointwise Source ($R[s^{\\mathrm{pw}}]$)**\n$$R[s^{\\mathrm{pw}}] = v^T W (\\dot{u} - s^{\\mathrm{pw}})$$\nThe difference vector is $\\dot{u} - s^{\\mathrm{pw}} = (\\frac{79}{21}-1, \\frac{41}{105}-1, \\frac{2177}{105}-27)^T = (\\frac{58}{21}, -\\frac{64}{105}, -\\frac{658}{105})^T$.\nThe residual is the weighted sum:\n$R[s^{\\mathrm{pw}}] = \\sum_{i=1}^3 v_i w_i (\\dot{u}_i - s^{\\mathrm{pw}}_i) = (1)(\\frac{1}{3})(\\frac{58}{21}) + (1)(\\frac{4}{3})(-\\frac{64}{105}) + (3)(\\frac{1}{3})(-\\frac{658}{105})$\n$R[s^{\\mathrm{pw}}] = \\frac{58}{63} - \\frac{256}{315} - \\frac{658}{105} = \\frac{290 - 256 - 1974}{315} = \\frac{34 - 1974}{315} = -\\frac{1940}{315}$.\nSimplifying the fraction gives:\n$$\nR[s^{\\mathrm{pw}}] = -\\frac{388}{63}.\n$$\n\n**5. Computation of Residual for Balanced Source ($R[s^{\\mathrm{bal}}]$)**\nThe entropy-balanced source discretization $s^{\\mathrm{bal}}$ is defined such that the right-hand side of the discrete entropy equation, $v^{T} W s^{\\mathrm{bal}}$, is equal to $v^{T} W$ applied to the $L^2$ projection of the source, which is $v^{T} W \\dot{u}$.\nBy definition, $v^{T} W s^{\\mathrm{bal}} \\equiv v^{T} W \\dot{u}$.\nSubstituting this into the residual definition:\n$$\nR[s^{\\mathrm{bal}}] = v^{T} W \\dot{u} - v^{T} W s^{\\mathrm{bal}} = v^{T} W \\dot{u} - v^{T} W \\dot{u} = 0.\n$$\nThe entropy-balanced source term is constructed specifically to make this residual vanish.\n\n**Conclusion**\nThe two discrete entropy residuals are $R[s^{\\mathrm{pw}}] = -\\frac{388}{63}$ and $R[s^{\\mathrm{bal}}] = 0$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-\\frac{388}{63} & 0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "In practical applications, such as simulating the compressible Euler equations, a numerical scheme must satisfy multiple physical constraints, including entropy stability and the positivity of density and pressure. While entropy-stable fluxes are designed to guarantee the former, separate limiters are often required to enforce the latter. This final practice  presents a fascinating and realistic scenario where these two components can conflict. By simulating a two-cell interaction with an entropy-stable flux and a positivity-preserving limiter, you will investigate whether enforcing physical admissibility can paradoxically lead to a violation of the discrete entropy inequality, a key challenge in developing truly robust numerical methods.",
            "id": "3380723",
            "problem": "Consider the one-dimensional compressible Euler equations for a single species ideal gas with ratio of specific heats $\\gamma \\in \\mathbb{R}$, $\\gamma > 1$. Let the conservative variables be $u = [\\rho, m, E]^T$, where $\\rho$ is the mass density, $m = \\rho u$ is the momentum with $u$ the velocity, and $E$ is the total energy. The thermodynamic pressure is given by the equation of state $p = (\\gamma - 1)\\left(E - \\frac{1}{2}\\frac{m^2}{\\rho}\\right)$. The physical admissibility constraints require $\\rho > 0$ and $p > 0$. The inviscid flux is $f(u) = [m,\\; \\frac{m^2}{\\rho} + p,\\; (E + p)\\frac{m}{\\rho}]^T$.\n\nFor discrete entropy analysis, define the mathematical entropy (a convex entropy function) for the Euler system as $\\eta(u) = -\\frac{\\rho s}{\\gamma - 1}$, where $s = \\ln(p) - \\gamma \\ln(\\rho)$ is the physical specific entropy. In a semi-discrete entropy-stable scheme, the total discrete entropy should be non-increasing under an update driven by an entropy-stable flux. The Local Lax-Friedrichs (LLF) numerical flux (also known as the Rusanov flux) is given by\n$$\nF_{\\mathrm{LLF}}(u_L, u_R) = \\frac{1}{2}\\left(f(u_L) + f(u_R)\\right) - \\frac{1}{2}\\alpha(u_L, u_R)\\left(u_R - u_L\\right),\n$$\nwhere $\\alpha(u_L, u_R)$ is a bound on the maximum characteristic speed, e.g., $\\alpha(u_L,u_R) = \\max\\left(|u_L| + c_L,\\; |u_R| + c_R\\right)$ with $c = \\sqrt{\\gamma p / \\rho}$ the sound speed computed from the primitive variables associated with $u_L$ and $u_R$. This flux is entropy-stable for the Euler equations when $\\alpha$ is chosen as above.\n\nIn a representative two-cell periodic discretization (as arises from a symmetric nodal Spectral method or from a lowest-order Discontinuous Galerkin method when reduced to a single interface coupling), consider two adjacent cells with states $u_L$ and $u_R$. Let the update for a single forward Euler step of size $\\Delta t$ over uniform grid spacing $\\Delta x$ use the two numerical flux evaluations at the shared interface with reversed arguments:\n$$\nF_{LR} = F_{\\mathrm{LLF}}(u_L, u_R), \\quad F_{RL} = F_{\\mathrm{LLF}}(u_R, u_L).\n$$\nThe periodic two-cell update is\n$$\nu_L^{\\mathrm{new}} = u_L - \\frac{\\Delta t}{\\Delta x}\\left(F_{LR} - F_{RL}\\right), \\quad\nu_R^{\\mathrm{new}} = u_R - \\frac{\\Delta t}{\\Delta x}\\left(F_{RL} - F_{LR}\\right).\n$$\n\nTo enforce positivity of density and pressure after the update, apply a positivity-preserving limiter by convexly blending each candidate updated state $u^{\\mathrm{new}}$ with its original admissible state $u^{\\mathrm{safe}}$ (the pre-update state) as\n$$\nu^{\\mathrm{lim}}(\\theta) = \\theta\\, u^{\\mathrm{new}} + (1 - \\theta)\\, u^{\\mathrm{safe}}, \\quad \\theta \\in [0,1],\n$$\nand choose the largest $\\theta$ that satisfies $\\rho^{\\mathrm{lim}}(\\theta) \\ge \\rho_{\\min}$ and $p^{\\mathrm{lim}}(\\theta) \\ge p_{\\min}$ for given floors $\\rho_{\\min} > 0$ and $p_{\\min} > 0$. The limited states in the two cells are $u_L^{\\mathrm{lim}}$ and $u_R^{\\mathrm{lim}}$ obtained by this procedure.\n\nDefine the \"entropy increase violation\" as the event where the sum of the mathematical entropies across the two cells increases after applying the positivity limiter, that is, where\n$$\n\\eta(u_L^{\\mathrm{lim}}) + \\eta(u_R^{\\mathrm{lim}}) > \\eta(u_L) + \\eta(u_R).\n$$\nIn this setting, investigate the compatibility of the positivity-preserving limiter with the entropy-stable LLF flux and identify scenarios where limiter-induced overshoots cause an increase in the total mathematical entropy.\n\nYour task is to implement a program that, for each test case provided below, performs the following steps:\n- Converts the given primitive variables $(\\rho, u, p)$ to conservative variables $u$.\n- Computes the LLF flux in both argument orders at the shared interface and updates the two cells with the periodic two-cell scheme above.\n- Applies the positivity-preserving limiter with given floors $\\rho_{\\min}$ and $p_{\\min}$ by selecting the largest $\\theta \\in [0,1]$ that enforces the constraints in each cell.\n- Computes the sum of the mathematical entropies before and after the limited update.\n- Returns a boolean indicating whether the total mathematical entropy has increased due to the limited update.\n\nAll quantities are dimensionless. Use the following test suite; each test case is specified by $(\\gamma,\\; \\Delta t,\\; \\Delta x,\\; \\rho_L,\\; u_L,\\; p_L,\\; \\rho_R,\\; u_R,\\; p_R,\\; \\rho_{\\min},\\; p_{\\min})$:\n- Case 1 (baseline smooth states): $(1.4,\\; 0.1,\\; 1.0,\\; 1.0,\\; 0.0,\\; 1.0,\\; 0.9,\\; 0.1,\\; 1.1,\\; 10^{-10},\\; 10^{-10})$.\n- Case 2 (strong jump with potential overshoot): $(1.4,\\; 1.0,\\; 1.0,\\; 0.2,\\; 5.0,\\; 0.01,\\; 1.0,\\; -2.0,\\; 2.0,\\; 10^{-12},\\; 10^{-12})$.\n- Case 3 (shock-like contrast): $(1.4,\\; 0.5,\\; 1.0,\\; 1.0,\\; 3.0,\\; 0.5,\\; 4.0,\\; 0.0,\\; 2.0,\\; 10^{-12},\\; 10^{-12})$.\n- Case 4 (near-vacuum on one side): $(1.4,\\; 0.7,\\; 1.0,\\; 10^{-3},\\; 0.0,\\; 10^{-5},\\; 1.0,\\; 0.0,\\; 1.0,\\; 10^{-12},\\; 10^{-12})$.\n- Case 5 (counter-propagating high Mach): $(1.4,\\; 0.3,\\; 1.0,\\; 0.5,\\; 10.0,\\; 0.1,\\; 0.5,\\; -10.0,\\; 0.1,\\; 10^{-12},\\; 10^{-12})$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"), where each result is a boolean (True or False) indicating whether the total mathematical entropy increased after applying the positivity limiter for that test case.",
            "solution": "The problem is scientifically grounded in computational fluid dynamics for the compressible Euler equations. It investigates the compatibility between entropy-stable schemes and positivity-preserving limiters. The solution requires a direct simulation of the described process for a set of test cases. The core of the analysis lies in the potential incompatibility between the local, state-wise positivity enforcement and the global, system-wide entropy dissipation property. The entropy function is convex, and while the flux is entropy-stable and the limiter is a convex combination, the fact that the limiter coefficient $\\theta$ can differ between cells ($\\theta_L \\neq \\theta_R$) breaks the simple argument that would guarantee entropy stability of the combined scheme.\n\nThe computational procedure is implemented as follows:\n\n1.  **State Conversion**: Initial states in primitive variables $(\\rho, u, p)$ are converted to the vector of conservative variables $u = [\\rho, m, E]^T$, where $m = \\rho u$ and $E = \\frac{p}{\\gamma - 1} + \\frac{1}{2}\\rho u^2$.\n\n2.  **Semi-Discrete Update**: The two-cell periodic update simplifies due to the symmetry of the LLF stabilization parameter $\\alpha(u_L, u_R)$. The updates for the candidate states $u_L^{\\mathrm{new}}$ and $u_R^{\\mathrm{new}}$ become:\n    $$\n    u_L^{\\mathrm{new}} = u_L + \\frac{\\Delta t}{\\Delta x}\\alpha(u_L, u_R)(u_R - u_L) \\\\\n    u_R^{\\mathrm{new}} = u_R - \\frac{\\Delta t}{\\Delta x}\\alpha(u_L, u_R)(u_R - u_L)\n    $$\n    The wave speed is $\\alpha(u_L, u_R) = \\max(|u_L| + c_L, |u_R| + c_R)$, with $c = \\sqrt{\\gamma p / \\rho}$.\n\n3.  **Positivity-Preserving Limiter**: For each cell, we find the largest blending factor $\\theta \\in [0, 1]$ such that the limited state $u^{\\mathrm{lim}}(\\theta) = \\theta u^{\\mathrm{new}} + (1 - \\theta) u^{\\mathrm{safe}}$ is admissible.\n    *   **Density Constraint**: $\\rho^{\\mathrm{lim}}(\\theta) \\ge \\rho_{\\min}$ is a linear inequality in $\\theta$. If $\\rho^{\\mathrm{new}} < \\rho_{\\min}$, it provides an upper bound $\\theta_{\\rho}$.\n    *   **Pressure Constraint**: $p^{\\mathrm{lim}}(\\theta) \\ge p_{\\min}$ results in a quadratic inequality for $\\theta$ of the form $A\\theta^2 + B\\theta + C \\ge 0$. If the new state $u^{\\mathrm{new}}$ is already pressure-positive, no blending is needed. Otherwise, we solve the quadratic equation for its roots to find the upper bound $\\theta_p$. Since the safe state is admissible ($p^{\\mathrm{safe}} > p_{\\min}$) and the new state is not ($p^{\\mathrm{new}} < p_{\\min}$), a single root typically exists in $(0, 1)$.\n    The final blending factor for each cell is $\\theta = \\min(1.0, \\theta_{\\rho}, \\theta_{p})$. This is performed independently for each cell.\n\n4.  **Entropy Violation Check**: The mathematical entropy is $\\eta(u) = -\\frac{\\rho s}{\\gamma - 1}$, with $s = \\ln(p) - \\gamma \\ln(\\rho)$. The total initial entropy is $\\Sigma \\eta_{\\mathrm{initial}} = \\eta(u_L) + \\eta(u_R)$. The total final entropy is $\\Sigma \\eta_{\\mathrm{final}} = \\eta(u_L^{\\mathrm{lim}}) + \\eta(u_R^{\\mathrm{lim}})$. The \"entropy increase violation\" occurs if $\\Sigma \\eta_{\\mathrm{final}} > \\Sigma \\eta_{\\mathrm{initial}}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    test_cases = [\n        # (gamma, dt, dx, rho_L, u_L, p_L, rho_R, u_R, p_R, rho_min, p_min)\n        (1.4, 0.1, 1.0, 1.0, 0.0, 1.0, 0.9, 0.1, 1.1, 1e-10, 1e-10),\n        (1.4, 1.0, 1.0, 0.2, 5.0, 0.01, 1.0, -2.0, 2.0, 1e-12, 1e-12),\n        (1.4, 0.5, 1.0, 1.0, 3.0, 0.5, 4.0, 0.0, 2.0, 1e-12, 1e-12),\n        (1.4, 0.7, 1.0, 1e-3, 0.0, 1e-5, 1.0, 0.0, 1.0, 1e-12, 1e-12),\n        (1.4, 0.3, 1.0, 0.5, 10.0, 0.1, 0.5, -10.0, 0.1, 1e-12, 1e-12),\n    ]\n\n    results = []\n    for case in test_cases:\n        violation = run_simulation(*case)\n        results.append(violation)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(gamma, dt, dx, rho_L, v_L, p_L, rho_R, v_R, p_R, rho_min, p_min):\n    \"\"\"\n    Runs the simulation for a single test case.\n    \"\"\"\n    # 1. Convert primitive to conservative variables\n    uL_safe = prim_to_cons(rho_L, v_L, p_L, gamma)\n    uR_safe = prim_to_cons(rho_R, v_R, p_R, gamma)\n\n    # 2. Calculate initial total entropy\n    eta_initial = entropy_function(uL_safe, gamma) + entropy_function(uR_safe, gamma)\n\n    # 3. Compute LLF wave speed\n    cL = np.sqrt(gamma * p_L / rho_L)\n    cR = np.sqrt(gamma * p_R / rho_R)\n    alpha = max(abs(v_L) + cL, abs(v_R) + cR)\n    \n    # 4. Compute candidate updated states\n    diff_u = uR_safe - uL_safe\n    uL_new = uL_safe + (dt / dx) * alpha * diff_u\n    uR_new = uR_safe - (dt / dx) * alpha * diff_u\n\n    # 5. Apply positivity-preserving limiter\n    theta_L = find_limiter_theta(uL_new, uL_safe, gamma, rho_min, p_min)\n    uL_lim = theta_L * uL_new + (1 - theta_L) * uL_safe\n\n    theta_R = find_limiter_theta(uR_new, uR_safe, gamma, rho_min, p_min)\n    uR_lim = theta_R * uR_new + (1 - theta_R) * uR_safe\n    \n    # 6. Calculate final total entropy\n    eta_final = entropy_function(uL_lim, gamma) + entropy_function(uR_lim, gamma)\n    \n    # 7. Check for entropy violation\n    return eta_final > eta_initial\n\ndef prim_to_cons(rho, v, p, gamma):\n    \"\"\"Converts primitive variables (rho, v, p) to conservative vector u.\"\"\"\n    m = rho * v\n    E = p / (gamma - 1) + 0.5 * rho * v**2\n    return np.array([rho, m, E])\n\ndef get_pressure(u, gamma):\n    \"\"\"Computes pressure from the conservative state vector.\"\"\"\n    rho, m, E = u\n    if rho <= 0:\n        return -1.0\n    p = (gamma - 1) * (E - 0.5 * m**2 / rho)\n    return p\n\ndef entropy_function(u, gamma):\n    \"\"\"Computes the mathematical entropy eta(u).\"\"\"\n    rho, m, E = u\n    p = get_pressure(u, gamma)\n    if rho <= 0 or p <= 0:\n        # Invalid state, return a large number to signify error\n        return np.inf\n    s = np.log(p) - gamma * np.log(rho)\n    eta = -rho * s / (gamma - 1)\n    return eta\n\ndef find_limiter_theta(u_new, u_safe, gamma, rho_min, p_min):\n    \"\"\"\n    Finds the largest theta in [0, 1] for the positivity-preserving limiter.\n    \"\"\"\n    rho_new, m_new, E_new = u_new\n    rho_safe, m_safe, E_safe = u_safe\n    \n    # --- Density constraint ---\n    theta_rho = 1.0\n    if rho_new < rho_min:\n        # Since rho_safe >= rho_min, rho_new - rho_safe is negative.\n        # This check avoids division by zero if rho_new is somehow equal to rho_safe.\n        if rho_new - rho_safe < -1e-14:\n            theta_rho = (rho_min - rho_safe) / (rho_new - rho_safe)\n        else: # Cannot satisfy constraint if rho_new < rho_min and rho_new >= rho_safe\n            return 0.0\n\n    # --- Pressure constraint ---\n    p_new = get_pressure(u_new, gamma)\n    theta_p = 1.0\n    if p_new < p_min:\n        d_rho = rho_new - rho_safe\n        d_m = m_new - m_safe\n        d_E = E_new - E_safe\n        \n        # Coefficients of the quadratic A*theta^2 + B*theta + C >= 0\n        A = 2 * d_rho * d_E - d_m**2\n        B = 2 * (rho_safe * d_E + E_safe * d_rho) - 2 * m_safe * d_m - (2 * p_min / (gamma - 1)) * d_rho\n        C = 2 * rho_safe * E_safe - m_safe**2 - (2 * p_min / (gamma - 1)) * rho_safe\n\n        # C is guaranteed to be >= 0 because p_safe >= p_min\n        if C < 0: C = 0\n\n        # Find the smallest positive real root of the quadratic.\n        # This root is the upper bound on theta for pressure positivity.\n        if abs(A) < 1e-14:  # Linear case\n            if abs(B) > 1e-14:\n                root = -C / B\n                # If root > 0, it's our candidate theta_p\n                # If root <= 0, and we need to limit, no positive theta will solve it\n                theta_p = root if root > 1e-14 else 0.0\n            else: # B=0, C >= 0, constraint is always satified or never\n                theta_p = 1.0 if C >= 0 else 0.0\n        else:  # Quadratic case\n            roots = np.roots([A, B, C])\n            pos_real_roots = sorted([r.real for r in roots if abs(r.imag) < 1e-14 and r.real > 1e-14])\n            if pos_real_roots:\n                # Theory guarantees a root in (0,1) when p_new < p_min\n                theta_p = pos_real_roots[0]\n            else:\n                # Failsafe: if no positive roots, means parabola is always positive (since C>=0),\n                # which contradicts p_new < p_min. Something is numerically unstable.\n                # Reverting fully is the safest option.\n                theta_p = 0.0\n\n    # The final theta is the minimum of the bounds, clipped to [0, 1]\n    return min(1.0, max(0.0, theta_rho), max(0.0, theta_p))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}