{
    "hands_on_practices": [
        {
            "introduction": "Before tackling complex systems, it is crucial to build intuition with a simple, illustrative case. This practice connects the abstract algebraic definition of the Schur complement to the more tangible concept of a discrete harmonic extension . By calculating the energy of a solution that is \"as simple as possible\" in the element interiors while satisfying given interface values, you will see firsthand that this energy is precisely what the Schur complement operator, $S$, measures.",
            "id": "3404183",
            "problem": "Consider the symmetric interior penalty Galerkin (SIPG) discretization of the homogeneous diffusion equation $-u''=0$ on the one-dimensional domain $\\Omega=[0,1]$ with homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$. The mesh consists of two equal subdomains (elements) $E_{1}=[0,\\frac{1}{2}]$ and $E_{2}=[\\frac{1}{2},1]$, each equipped with a polynomial basis of degree $1$ given by the local Legendre polynomials on the reference interval $[-1,1]$, namely $\\phi_{0}(\\xi)=1$ and $\\phi_{1}(\\xi)=\\xi$, with the affine mapping $x=\\frac{h}{2}(\\xi+1)$ where $h=\\frac{1}{2}$ is the element length. On each element $E_{i}$ the discrete function is $u_{i}(\\xi)=a_{i}\\phi_{0}(\\xi)+b_{i}\\phi_{1}(\\xi)$.\n\nLet the symmetric interior penalty Galerkin bilinear form $a(\\cdot,\\cdot)$ be defined in one dimension by\n$$\na(u,v)=\\sum_{E}\\int_{E}u'(x)v'(x)\\,dx-\\sum_{F\\in\\mathcal{F}_{\\mathrm{int}}}\\left(\\{u'\\}\\,[v]+\\{v'\\}\\,[u]\\right)+\\sum_{F\\in\\mathcal{F}_{\\mathrm{int}}}\\frac{\\sigma}{h_{F}}[u][v]+\\sum_{F\\in\\mathcal{F}_{\\partial\\Omega}}\\left(-u' n\\, v - v' n\\, u + \\frac{\\sigma}{h_{F}}u v\\right),\n$$\nwhere $\\mathcal{F}_{\\mathrm{int}}$ is the set of interior faces, $\\mathcal{F}_{\\partial\\Omega}$ is the set of boundary faces, $h_{F}$ is the adjacent element length, $n$ is the outward unit normal on faces, $[u]$ denotes the jump of $u$ across an interior face, and $\\{u'\\}$ denotes the average of the normal derivatives across that face. The penalty parameter $\\sigma>0$ is a given positive constant.\n\nIn the nonoverlapping Schur complement framework for discontinuous Galerkin methods, one condenses interior element coefficients and obtains a skeletal operator $S$ acting on a vector of face values. In this two-element case, the skeletal vector reduces to a single scalar interface value. Denote this interface vector by $\\mathbf{x}\\in\\mathbb{R}$ and its sole component by $x$, representing the common trace value imposed on both sides of the shared interior face at $x=\\frac{1}{2}$.\n\nDefine the discrete harmonic extension as the minimizer $u_{h}\\in V_{h}$ of the SIPG energy $a(u,u)$ over the discrete space $V_{h}$ of piecewise degree-$1$ polynomials on $E_{1}$ and $E_{2}$, subject to the trace constraints $u(0)=0$, $u(\\tfrac{1}{2}^{-})=x$, $u(\\tfrac{1}{2}^{+})=x$, and $u(1)=0$. For the particular case of unit displacement $x=1$, compute the corresponding discrete harmonic extension and evaluate the Schur complement energy $x^{T}S x=a(u_{h},u_{h})$.\n\nProvide your final answer exactly as a single real number. No rounding is required, and no units are necessary.",
            "solution": "The problem requires the computation of the Schur complement energy, $x^{T}S x$, for a specific case of a symmetric interior penalty Galerkin (SIPG) discretization. The problem states that this energy is equal to the SIPG energy of the discrete harmonic extension, i.e., $x^{T}S x = a(u_{h}, u_{h})$. We are asked to compute this value for a unit displacement at the interface, which corresponds to setting the interface value $x$ to $1$.\n\nFirst, we must determine the discrete harmonic extension $u_h$ for the interface value $x=1$. The function $u_h$ belongs to the discrete space $V_h$ of piecewise polynomials of degree $1$ on the mesh elements $E_{1}=[0,\\frac{1}{2}]$ and $E_{2}=[\\frac{1}{2},1]$. The harmonic extension is defined as the minimizer of the energy $a(u,u)$ subject to a set of trace constraints. For our case with $x=1$, these constraints are:\n$1$. $u(0)=0$\n$2$. $u(\\frac{1}{2}^{-})=1$\n$3$. $u(\\frac{1}{2}^{+})=1$\n$4$. $u(1)=0$\n\nThe space $V_h$ consists of functions that are linear on each element. Let's represent the function $u_h$ on each element $E_i$ as a linear polynomial of the spatial coordinate $x$.\nOn element $E_1 = [0, \\frac{1}{2}]$, let $u_1(x) = c_1 x + d_1$. The constraints are:\n$u_1(0) = 0 \\implies c_1(0) + d_1 = 0 \\implies d_1 = 0$.\n$u_1(\\frac{1}{2}) = 1 \\implies c_1(\\frac{1}{2}) = 1 \\implies c_1 = 2$.\nThus, on $E_1$, the function is $u_1(x) = 2x$. The derivative is $u_1'(x) = 2$.\n\nOn element $E_2 = [\\frac{1}{2}, 1]$, let $u_2(x) = c_2 x + d_2$. The constraints are:\n$u_2(\\frac{1}{2}) = 1 \\implies c_2(\\frac{1}{2}) + d_2 = 1$.\n$u_2(1) = 0 \\implies c_2(1) + d_2 = 0 \\implies d_2 = -c_2$.\nSubstituting the second equation into the first gives $\\frac{1}{2}c_2 - c_2 = 1$, which simplifies to $-\\frac{1}{2}c_2 = 1$, so $c_2 = -2$. This implies $d_2 = -(-2) = 2$.\nThus, on $E_2$, the function is $u_2(x) = -2x+2 = 2(1-x)$. The derivative is $u_2'(x) = -2$.\n\nThe discrete function $u_h$ is uniquely determined by these constraints. The minimization aspect of the definition is fulfilled trivially as the set of admissible functions contains only one element. So, the discrete harmonic extension for $x=1$ is:\n$$\nu_h(x) = \\begin{cases} 2x & \\text{for } x \\in [0, \\frac{1}{2}] \\\\ 2(1-x) & \\text{for } x \\in [\\frac{1}{2}, 1] \\end{cases}\n$$\nAnd its derivative is:\n$$\nu_h'(x) = \\begin{cases} 2 & \\text{for } x \\in (0, \\frac{1}{2}) \\\\ -2 & \\text{for } x \\in (\\frac{1}{2}, 1) \\end{cases}\n$$\nNow we must compute $a(u_h, u_h)$ using the provided bilinear form:\n$$\na(u,v)=\\sum_{E}\\int_{E}u'(x)v'(x)\\,dx-\\sum_{F\\in\\mathcal{F}_{\\mathrm{int}}}\\left(\\{u'\\}\\,[v]+\\{v'\\}\\,[u]\\right)+\\sum_{F\\in\\mathcal{F}_{\\mathrm{int}}}\\frac{\\sigma}{h_{F}}[u][v]+\\sum_{F\\in\\mathcal{F}_{\\partial\\Omega}}\\left(-u' n\\, v - v' n\\, u + \\frac{\\sigma}{h_{F}}u v\\right)\n$$\nWe evaluate $a(u_h, u_h)$ term by term.\n\n$1$. Volume integral term: $\\sum_{E}\\int_{E}(u_h'(x))^2\\,dx$\nThis is the sum of integrals over the two elements $E_1$ and $E_2$.\n$$\n\\int_{E_1} (u_1'(x))^2 \\,dx = \\int_{0}^{1/2} (2)^2 \\,dx = 4 \\int_{0}^{1/2} dx = 4 \\left(\\frac{1}{2}\\right) = 2.\n$$\n$$\n\\int_{E_2} (u_2'(x))^2 \\,dx = \\int_{1/2}^{1} (-2)^2 \\,dx = 4 \\int_{1/2}^{1} dx = 4 \\left(1-\\frac{1}{2}\\right) = 2.\n$$\nThe sum is $2+2=4$.\n\n$2$. Interior face terms: contributions from $F \\in \\mathcal{F}_{\\mathrm{int}} = \\{\\frac{1}{2}\\}$.\nThese terms involve jumps $[u_h]$ and averages $\\{u_h'\\}$ at the interior face $x=\\frac{1}{2}$. Let's define the jump at a face as the difference between the values on the left ($L$) and right ($R$) elements, i.e., $[q] = q_L - q_R$.\nThe jump of the function $u_h$ is:\n$$\n[u_h] = u_1(\\tfrac{1}{2}) - u_2(\\tfrac{1}{2}) = 1 - 1 = 0.\n$$\nSince $[u_h]=0$, all terms containing it as a factor are zero. Specifically, the terms $-\\sum (\\{u_h'\\}[u_h] + \\{u_h'\\}[u_h])$ and $\\sum \\frac{\\sigma}{h_F} [u_h][u_h]$ are both zero.\n$$\n-2\\{u_h'\\} [u_h] + \\frac{\\sigma}{h_F}[u_h]^2 = -2\\{u_h'\\}(0) + \\frac{\\sigma}{h_F}(0)^2 = 0.\n$$\nThus, the contribution from the interior face is $0$.\n\n$3$. Boundary face terms: contributions from $F \\in \\mathcal{F}_{\\partial\\Omega} = \\{0, 1\\}$.\nThe term is $\\sum_{F\\in\\mathcal{F}_{\\partial\\Omega}}\\left(-2u' n\\, u + \\frac{\\sigma}{h_{F}}u^2\\right)$.\nAt the boundary face $F=\\{0\\}$, the function value is $u_h(0)=0$. The outward normal is $n=-1$.\nThe contribution is $-2u_h'(0)n u_h(0) + \\frac{\\sigma}{h}u_h(0)^2 = -2(2)(-1)(0) + \\frac{\\sigma}{1/2}(0)^2 = 0$.\nAt the boundary face $F=\\{1\\}$, the function value is $u_h(1)=0$. The outward normal is $n=1$.\nThe contribution is $-2u_h'(1)n u_h(1) + \\frac{\\sigma}{h}u_h(1)^2 = -2(-2)(1)(0) + \\frac{\\sigma}{1/2}(0)^2 = 0$.\nThus, the total contribution from the boundary faces is $0$.\n\nFinally, we sum all contributions to find the total energy $a(u_h, u_h)$:\n$$\na(u_h, u_h) = 4 + 0 + 0 = 4.\n$$\nThe Schur complement energy $x^T S x$ for $x=1$ is therefore $4$.",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "The true power of Schur complement methods lies in solving large-scale problems by assembling information from local subdomains. This hands-on coding exercise guides you through building the global Schur complement system, $S$, from local discrete Steklov operators, $T^{(e)}$, and analyzing its spectral properties . You will discover how local eigenvalue analysis on each subdomain provides a powerful tool to estimate and bound the eigenvalues of the global system, forming the basis for designing effective preconditioners.",
            "id": "3404164",
            "problem": "Consider the one-dimensional symmetric diffusion model problem in the form $-(a(x) u'(x))' = f(x)$ posed on the closed interval $[0,1]$ with homogeneous Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$. Let the interval be partitioned into $N$ nonoverlapping subdomains (elements) of equal length. On each subdomain, use a spectral element discretization with Legendre-Gauss-Lobatto (LGL) nodes of polynomial degree $p$ and quadrature weights that render the Galerkin bilinear form consistent for polynomial data. Assume the diffusion coefficient $a(x)$ is constant on each subdomain, taking value $a_e > 0$ on subdomain $e$, and that $f(x)$ plays no role in the matrix condition number.\n\nWithin each subdomain $e$, let the nodal basis be the Lagrange interpolants at the LGL nodes in the reference coordinate $\\xi \\in [-1,1]$, mapped affinely to the physical subdomain $[x_L^e, x_R^e]$ via $x(\\xi) = \\frac{x_L^e + x_R^e}{2} + \\frac{h_e}{2} \\xi$ with $h_e = x_R^e - x_L^e$. Denote by $D$ the derivative matrix of the Lagrange basis evaluated at the LGL nodes in the reference coordinate, by $\\{w_i\\}_{i=0}^p$ the LGL quadrature weights on $[-1,1]$, and by $W = \\operatorname{diag}(w_0, w_1, \\dots, w_p)$ the diagonal quadrature matrix. The element stiffness matrix $K^{(e)} \\in \\mathbb{R}^{(p+1) \\times (p+1)}$ is defined by the quadrature formula for the Galerkin bilinear form,\n$$\nK^{(e)} = \\frac{2}{h_e} \\, D^\\top \\, W \\, a_e \\, D,\n$$\nwhere $a_e$ multiplies the weights since it is constant on subdomain $e$. Partition the degrees of freedom on each subdomain into boundary nodes $b$ (the two endpoints) and interior nodes $i$ (the remaining nodes), yielding the block decomposition\n$$\nK^{(e)} = \\begin{bmatrix} K^{(e)}_{bb} & K^{(e)}_{bi} \\\\ K^{(e)}_{ib} & K^{(e)}_{ii} \\end{bmatrix}.\n$$\nDefine the local discrete Dirichlet-to-Neumann map (also known as the local discrete Steklov operator) on the boundary trace space by static condensation of interior degrees of freedom,\n$$\nT^{(e)} = K^{(e)}_{bb} - K^{(e)}_{bi} \\left(K^{(e)}_{ii}\\right)^{-1} K^{(e)}_{ib} \\in \\mathbb{R}^{2 \\times 2}.\n$$\n\nAssemble the nonoverlapping Schur complement $S$ on the global interface trace degrees of freedom by summing the contributions from each subdomain’s $T^{(e)}$ to the interface nodes they touch and enforcing the homogeneous Dirichlet boundary values at $x=0$ and $x=1$ directly (these boundary values are set to zero and therefore do not contribute unknowns to $S$). The global Schur complement $S \\in \\mathbb{R}^{(N-1) \\times (N-1)}$ is symmetric positive definite. Define its spectral condition number by\n$$\n\\kappa(S) = \\frac{\\lambda_{\\max}(S)}{\\lambda_{\\min}(S)},\n$$\nwhere $\\lambda_{\\max}(\\cdot)$ and $\\lambda_{\\min}(\\cdot)$ are the largest and smallest eigenvalues, respectively.\n\nOn each subdomain, define the local discrete Steklov eigenproblem on the boundary trace space as\n$$\nT^{(e)} v_b = \\lambda \\, v_b,\n$$\nwith $v_b \\in \\mathbb{R}^2$. Let $\\lambda_{\\max}\\!\\left(T^{(e)}\\right)$ denote the largest eigenvalue of $T^{(e)}$. In one spatial dimension, each interior interface is shared by at most $2$ subdomains. Using a norm subadditivity or Gershgorin-type argument, one can show the upper bound\n$$\n\\lambda_{\\max}(S) \\le 2 \\, \\max_{e=1,\\dots,N} \\lambda_{\\max}\\!\\left(T^{(e)}\\right).\n$$\nThis provides a computable surrogate bound based purely on local Steklov eigenvalues.\n\nTask:\n- Implement the described spectral element construction for the one-dimensional problem in a programmatic form that builds the element stiffness matrices $K^{(e)}$, performs static condensation to obtain $T^{(e)}$, assembles the global Schur complement $S$, and computes the exact $\\lambda_{\\max}(S)$ and $\\kappa(S)$ numerically.\n- Compute the surrogate upper bound $U = 2 \\, \\max_{e} \\lambda_{\\max}\\!\\left(T^{(e)}\\right)$ and evaluate the sharpness of the bound by reporting the ratio $R = \\lambda_{\\max}(S)/U$.\n- No physical units are required for this purely mathematical problem; report all floating-point results as raw decimal values.\n\nUse the following test suite of parameter sets, where each test case is specified by the triple $(N, p, \\{a_e\\}_{e=1}^N)$:\n- Test case $1$: $N = 2$, $p = 4$, $\\{a_e\\} = [1.0, 1.0]$.\n- Test case $2$: $N = 2$, $p = 4$, $\\{a_e\\} = [10^{-3}, 10^{3}]$.\n- Test case $3$: $N = 5$, $p = 3$, $\\{a_e\\} = [1.0, 2.0, 3.0, 4.0, 5.0]$.\n- Test case $4$: $N = 3$, $p = 6$, $\\{a_e\\} = [1.0, 0.1, 10.0]$.\n- Test case $5$: $N = 4$, $p = 2$, $\\{a_e\\} = [1.0, 1.0, 1.0, 1.0]$.\n\nYour program should produce a single line of output containing the results of all test cases aggregated into a list of lists, where each inner list is $[\\lambda_{\\max}(S), U, R, \\kappa(S)]$ for the corresponding test case. The exact text format must be a single line with a Python-style list literal, for example $[[x_1, y_1, z_1, w_1],[x_2, y_2, z_2, w_2],\\dots]$, with no additional text.",
            "solution": "The problem is valid. It constitutes a well-defined exercise in numerical analysis, specifically within the domain of spectral element methods and nonoverlapping domain decomposition. All parameters are provided, the theoretical basis is sound, and the objectives are clear and computationally verifiable.\n\nThe solution proceeds by programmatically implementing the defined mathematical objects and procedures. The overall process can be divided into four main stages: (1) computation of reference element data, (2) construction of local element matrices and their static condensation, (3) assembly of the global interface problem, and (4) computation of the specified spectral properties.\n\n**1. Reference Spectral Element Data**\n\nThe method is based on a reference element defined on the interval $\\xi \\in [-1, 1]$. All computations for a physical element are performed by mapping from this reference element. For a given polynomial degree $p$, we require three fundamental components on the reference element:\n\n- **Legendre-Gauss-Lobatto (LGL) Nodes $\\{\\xi_i\\}_{i=0}^p$**: These are the $p+1$ nodes used for interpolation and quadrature. They are the roots of the polynomial $(1-\\xi^2)P'_p(\\xi)$, where $P'_p(\\xi)$ is the derivative of the Legendre polynomial of degree $p$. The set of nodes includes the endpoints $\\xi_0 = -1$ and $\\xi_p = 1$.\n\n- **LGL Quadrature Weights $\\{w_i\\}_{i=0}^p$**: Associated with each node $\\xi_i$ is a quadrature weight $w_i$, used for numerical integration. The weights are given by the formula:\n$$w_i = \\frac{2}{p(p+1) [P_p(\\xi_i)]^2}$$\nThis quadrature rule is exact for polynomials of degree up to $2p-1$.\n\n- **Lagrange Derivative Matrix $D$**: The local solution within an element is represented as a linear combination of Lagrange basis functions $L_j(\\xi)$, each non-zero only at a single node $\\xi_j$. The derivative matrix $D \\in \\mathbb{R}^{(p+1) \\times (p+1)}$ contains the values of the derivatives of these basis functions evaluated at all the nodes. An entry $D_{ij}$ is given by $D_{ij} = L'_j(\\xi_i)$. A standard formula for its entries is:\n$$\nD_{ij} = \\begin{cases}\n    \\frac{P_p(\\xi_i)}{P_p(\\xi_j)(\\xi_i - \\xi_j)} & \\text{if } i \\neq j \\\\\n    -\\frac{p(p+1)}{4} & \\text{if } i=j=0 \\\\\n    \\frac{p(p+1)}{4} & \\text{if } i=j=p \\\\\n    0 & \\text{otherwise for diagonal entries}\n\\end{cases}\n$$\nThese three components, $\\{\\xi_i\\}$, $\\{w_i\\}$, and $D$, depend only on the polynomial degree $p$ and are computed once.\n\n**2. Element Stiffness Matrix and Static Condensation**\n\nThe continuous problem is $-(a(x)u'(x))' = f(x)$. The corresponding weak form involves the bilinear form $B(u, v) = \\int_0^1 a(x) u'(x) v'(x) dx$. For a single element $e$ with domain $[x_L^e, x_R^e]$ and constant coefficient $a_e$, this integral becomes $a_e \\int_{x_L^e}^{x_R^e} u'(x) v'(x) dx$. Using an affine map from the reference element, $x(\\xi) = x_L^e + \\frac{h_e}{2}(1+\\xi)$, where $h_e = x_R^e - x_L^e$, the chain rule gives $u'(x) = \\frac{du}{d\\xi}\\frac{d\\xi}{dx} = u'(\\xi) \\frac{2}{h_e}$. The integral transforms to:\n$$ B^{(e)}(u, v) = a_e \\int_{-1}^{1} u'(\\xi) \\frac{2}{h_e} \\cdot v'(\\xi) \\frac{2}{h_e} \\cdot \\frac{h_e}{2} d\\xi = \\frac{2a_e}{h_e} \\int_{-1}^{1} u'(\\xi) v'(\\xi) d\\xi $$\nDiscretizing with the Lagrange basis and using LGL quadrature, we obtain the element stiffness matrix $K^{(e)}$. The integral $\\int (L'_j(\\xi)) (L'_k(\\xi)) d\\xi$ is approximated by $\\sum_m w_m L'_j(\\xi_m) L'_k(\\xi_m)$. This corresponds to the matrix expression:\n$$ K^{(e)} = \\frac{2a_e}{h_e} D^\\top W D $$\nwhere $W = \\mathrm{diag}(w_0, \\dots, w_p)$.\n\nThe nodes are partitioned into boundary nodes (indices $b = \\{0, p\\}$) and interior nodes (indices $i = \\{1, \\dots, p-1\\}$). This induces a block structure on $K^{(e)}$:\n$$ K^{(e)} = \\begin{bmatrix} K^{(e)}_{bb} & K^{(e)}_{bi} \\\\ K^{(e)}_{ib} & K^{(e)}_{ii} \\end{bmatrix} $$\nStatic condensation eliminates the interior degrees of freedom to find the relationship between nodal values and generalized forces on the element boundary. This yields the local Schur complement, or discrete Dirichlet-to-Neumann map, $T^{(e)} \\in \\mathbb{R}^{2 \\times 2}$:\n$$ T^{(e)} = K^{(e)}_{bb} - K^{(e)}_{bi} \\left(K^{(e)}_{ii}\\right)^{-1} K^{(e)}_{ib} $$\nThe matrix $T^{(e)}$ represents the stiffness contribution of element $e$ to its boundary nodes. We compute $T^{(e)}$ and its largest eigenvalue, $\\lambda_{\\max}(T^{(e)})$, for each element.\n\n**3. Global Schur Complement Assembly**\n\nThe global Schur complement matrix $S$ operates on the vector of unknown values at the $N-1$ interior interfaces of the domain partition. The interfaces are located at $x_j = j/N$ for $j=1, \\dots, N-1$. The matrix $S$ is assembled by summing the contributions from the local $T^{(e)}$ matrices. An interface at $x_j$ is the right boundary of element $j-1$ and the left boundary of element $j$. Its stiffness is the sum of stiffnesses from both sides.\nThe matrix $S$ is tridiagonal:\n- The diagonal entries are $S_{j,j} = T^{(j)}_{11} + T^{(j+1)}_{00}$ for $j=0, \\dots, N-2$. (Note: $T_{11}$ is the right-node contribution, $T_{00}$ is the left-node contribution).\n- The off-diagonal entries are $S_{j, j+1} = T^{(j+1)}_{01}$ and $S_{j+1, j} = T^{(j+1)}_{10}$ for $j=0, \\dots, N-3$.\n\n**4. Computation of Spectral Quantities**\n\nWith the global Schur complement matrix $S$ assembled, we compute the required quantities:\n- The eigenvalues of the symmetric matrix $S$ are computed numerically. We find the largest eigenvalue $\\lambda_{\\max}(S)$ and the smallest eigenvalue $\\lambda_{\\min}(S)$.\n- The spectral condition number is $\\kappa(S) = \\frac{\\lambda_{\\max}(S)}{\\lambda_{\\min}(S)}$.\n- The surrogate upper bound for $\\lambda_{\\max}(S)$ is calculated as $U = 2 \\cdot \\max_{e=1, \\dots, N} \\lambda_{\\max}(T^{(e)})$.\n- The sharpness of this bound is evaluated by the ratio $R = \\frac{\\lambda_{\\max}(S)}{U}$.\n\nThis procedure is applied to each test case specified in the problem statement.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre, roots_jacobi\n\nclass SpectralElementSolver:\n    \"\"\"\n    Implements a 1D spectral element method to analyze the Schur complement condition number.\n    \"\"\"\n    \n    def __init__(self, N, p, a_vals):\n        \"\"\"\n        Initializes the solver with problem parameters.\n\n        Args:\n            N (int): Number of nonoverlapping subdomains.\n            p (int): Polynomial degree of LGL approximation.\n            a_vals (list or np.array): Diffusion coefficient values on each subdomain.\n        \"\"\"\n        self.N = N\n        self.p = p\n        self.a_vals = np.array(a_vals)\n        self.h = 1.0 / N\n\n        # Precompute reference element data that depends only on p\n        self._nodes, self._weights = self._lgl_nodes_weights()\n        self._D = self._derivative_matrix()\n        \n        # Will store local and global matrices during computation\n        self.T_elements = []  # List of local Schur complements T^(e)\n        self.S = None         # Global Schur complement\n\n    def _lgl_nodes_weights(self):\n        \"\"\"\n        Computes the Legendre-Gauss-Lobatto (LGL) nodes and weights for a given degree p.\n        \"\"\"\n        if self.p == 0:\n            return np.array([-1.0, 1.0]), np.array([1.0, 1.0]) # Linear element\n        if self.p == 1:\n            nodes = np.array([-1.0, 1.0])\n            weights = np.array([1.0, 1.0])\n            return nodes, weights\n\n        # Interior LGL nodes are the roots of the derivative of the Legendre polynomial P_p.\n        # These are also the roots of the Jacobi polynomial P_{p-1}^{(1,1)}.\n        jacobi_roots, _ = roots_jacobi(self.p - 1, 1, 1)\n        nodes = np.concatenate(([-1.0], jacobi_roots, [1.0]))\n        nodes = np.sort(nodes)\n\n        # LGL weights formula\n        p_poly = legendre(self.p)\n        weights = 2.0 / (self.p * (self.p + 1) * (p_poly(nodes))**2)\n        \n        return nodes, weights\n\n    def _derivative_matrix(self):\n        \"\"\"\n        Computes the differentiation matrix for the Lagrange basis on LGL nodes.\n        \"\"\"\n        n_pts = self.p + 1\n        D = np.zeros((n_pts, n_pts))\n        p_poly = legendre(self.p)\n        p_vals = p_poly(self._nodes)\n        nodes = self._nodes\n\n        # Off-diagonal entries\n        for i in range(n_pts):\n            for j in range(n_pts):\n                if i != j:\n                    D[i, j] = p_vals[i] / (p_vals[j] * (nodes[i] - nodes[j]))\n        \n        # Diagonal entries for endpoints\n        D[0, 0] = -self.p * (self.p + 1) / 4.0\n        D[self.p, self.p] = self.p * (self.p + 1) / 4.0\n        # Interior diagonal entries are 0, which is the default from np.zeros.\n\n        return D\n\n    def build_and_solve(self):\n        \"\"\"\n        Builds all matrices and computes the required spectral quantities.\n        \"\"\"\n        max_lambda_T_list = []\n\n        # 1. Compute local Schur complements (T_e) for each element\n        for e in range(self.N):\n            a_e = self.a_vals[e]\n            \n            # Form element stiffness matrix K_e\n            W_diag = np.diag(self._weights)\n            K_e = (a_e * 2.0 / self.h) * (self._D.T @ W_diag @ self._D)\n\n            # Partition into boundary and interior DoFs\n            b_indices = [0, self.p]\n            i_indices = list(range(1, self.p))\n\n            K_bb = K_e[np.ix_(b_indices, b_indices)]\n            \n            if self.p > 1: # If there are interior nodes\n                K_bi = K_e[np.ix_(b_indices, i_indices)]\n                K_ib = K_e[np.ix_(i_indices, b_indices)]\n                K_ii = K_e[np.ix_(i_indices, i_indices)]\n                # Static condensation\n                T_e = K_bb - K_bi @ np.linalg.inv(K_ii) @ K_ib\n            else: # No interior nodes to condense\n                T_e = K_bb\n\n            self.T_elements.append(T_e)\n\n            # Compute and store max eigenvalue of T_e\n            if T_e.shape[0] > 0:\n                eigvals_T = np.linalg.eigvalsh(T_e)\n                max_lambda_T_list.append(np.max(eigvals_T))\n        \n        # 2. Assemble and analyze global Schur complement S\n        if self.N > 1:\n            self.S = np.zeros((self.N - 1, self.N - 1))\n            \n            # Diagonal entries: sum contributions from adjacent elements\n            for i in range(self.N - 1):\n                # Interface i is shared by element i (right) and i+1 (left)\n                self.S[i, i] = self.T_elements[i][1, 1] + self.T_elements[i+1][0, 0]\n\n            # Off-diagonal entries: from shared element\n            for i in range(self.N - 2):\n                self.S[i, i+1] = self.T_elements[i+1][0, 1]\n                self.S[i+1, i] = self.T_elements[i+1][1, 0]\n\n            eigvals_S = np.linalg.eigvalsh(self.S)\n            lambda_max_S = np.max(eigvals_S)\n            lambda_min_S = np.min(eigvals_S)\n            kappa_S = lambda_max_S / lambda_min_S if lambda_min_S > 0 else np.inf\n        else: # Case with only one element, no interfaces.\n             lambda_max_S = 0.0\n             kappa_S = 1.0\n\n        # 3. Compute the surrogate bound U and the sharpness ratio R\n        U = 2.0 * np.max(max_lambda_T_list) if max_lambda_T_list else 0.0\n        R = lambda_max_S / U if U > 0 else 0.0\n\n        return [lambda_max_S, U, R, kappa_S]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (2, 4, [1.0, 1.0]),\n        (2, 4, [1.0e-3, 1.0e3]),\n        (5, 3, [1.0, 2.0, 3.0, 4.0, 5.0]),\n        (3, 6, [1.0, 0.1, 10.0]),\n        (4, 2, [1.0, 1.0, 1.0, 1.0])\n    ]\n\n    results = []\n    for N, p, a_vals in test_cases:\n        solver = SpectralElementSolver(N, p, a_vals)\n        result = solver.build_and_solve()\n        results.append(result)\n\n    # Print in the specified single-line list-of-lists format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With an assembled Schur complement system, the final challenge is to solve it efficiently. This advanced practice explores a powerful strategy for structured grids, where the Schur complement $S_n$ becomes a Toeplitz matrix that can be approximated by a circulant matrix $\\tilde{S}_n$ . You will learn to calibrate this circulant preconditioner and leverage the Fast Fourier Transform (FFT) for nearly optimal solves, revealing the deep connection between matrix structure, Fourier analysis, and high-performance computing.",
            "id": "3404114",
            "problem": "Consider the interface Schur complement arising from a nonoverlapping domain decomposition of a one-dimensional symmetric Interior Penalty Discontinuous Galerkin (SIPDG) discretization of the scalar diffusion operator. On a uniform mesh, after static condensation of elemental interior degrees of freedom, the interface operator restricted to a periodic, structured mesh can be modeled as a Toeplitz matrix of bandwidth at most three. This model is consistent with the translation invariance and short-range coupling induced by polynomial traces on faces. Concretely, let $S_n \\in \\mathbb{R}^{n \\times n}$ be the Toeplitz matrix with entries\n$$\n(S_n)_{i,j} = c_0 \\delta_{i,j} + c_1 (\\delta_{|i-j|,1}) + c_2 (\\delta_{|i-j|,2}) + c_3 (\\delta_{|i-j|,3}),\n$$\nfor indices $i,j \\in \\{0,1,\\dots,n-1\\}$, where $\\delta_{k,\\ell}$ denotes the Kronecker delta. Assume the coefficients satisfy the strict diagonal dominance condition $c_0 > 2(|c_1|+|c_2|+|c_3|)$ so that $S_n$ is symmetric positive definite for all $n \\ge 1$. The associated generating function (symbol) is the trigonometric polynomial\n$$\n\\hat{S}(\\theta) = c_0 + 2 c_1 \\cos(\\theta) + 2 c_2 \\cos(2\\theta) + 2 c_3 \\cos(3\\theta), \\quad \\theta \\in [0,2\\pi).\n$$\nWe seek a block-circulant (here, scalar circulant) approximation $\\tilde{S}_n$ with bandwidth at most two,\n$$\n\\tilde{S}_n = \\operatorname{Circ}(\\tilde{c}_0,\\tilde{c}_1,\\tilde{c}_2) \\in \\mathbb{R}^{n \\times n},\n$$\nwhose first row is $[\\tilde{c}_0, \\tilde{c}_1, \\tilde{c}_2, 0, \\dots, 0, \\tilde{c}_2, \\tilde{c}_1]$, and whose symbol is\n$$\n\\hat{\\tilde{S}}(\\theta) = \\tilde{c}_0 + 2 \\tilde{c}_1 \\cos(\\theta) + 2 \\tilde{c}_2 \\cos(2\\theta).\n$$\nThe calibration is defined by matching moments of the true symbol at selected angles: choose $\\Theta = \\{0,\\tfrac{\\pi}{2},\\pi\\}$ and determine $(\\tilde{c}_0,\\tilde{c}_1,\\tilde{c}_2)$ such that\n$$\n\\hat{\\tilde{S}}(\\theta) = \\hat{S}(\\theta) \\quad \\text{for all } \\theta \\in \\Theta.\n$$\nYour tasks are:\n\n1) Derive, from first principles of Toeplitz and circulant operators on structured meshes, a linear system that determines $(\\tilde{c}_0,\\tilde{c}_1,\\tilde{c}_2)$ from $(c_0,c_1,c_2,c_3)$ by enforcing $\\hat{\\tilde{S}}(\\theta) = \\hat{S}(\\theta)$ at $\\theta \\in \\{0,\\tfrac{\\pi}{2},\\pi\\}$, and solve this system symbolically to express $(\\tilde{c}_0,\\tilde{c}_1,\\tilde{c}_2)$ in terms of $(c_0,c_1,c_2,c_3)$.\n\n2) Using the calibrated $\\hat{\\tilde{S}}(\\theta)$, propose an a priori upper bound for the preconditioning error operator in the symbol sense,\n$$\nE_{\\infty} := \\sup_{\\theta \\in [0,2\\pi)} \\left| 1 - \\frac{\\hat{S}(\\theta)}{\\hat{\\tilde{S}}(\\theta)} \\right|.\n$$\nExplain, starting from the Fourier diagonalization of circulant matrices and the definition of the Schur complement preconditioner in the circulant energy norm, why $E_{\\infty}$ controls the error of the operator $I - \\tilde{S}_n^{-1} S_n$ in an appropriate energy norm, and discuss the relationship to the Euclidean operator norm.\n\n3) Demonstrate Fast Fourier Transform (FFT) acceleration of $\\tilde{S}_n$ solves by implementing the following:\n   - Build $S_n$ and the calibrated $\\tilde{S}_n$ for each test case below.\n   - Compute the numerical value of $E_{\\infty}$ by sampling $\\theta$ uniformly on a fine grid over $[0,2\\pi)$.\n   - Compute the Euclidean operator $2$-norm $\\|I - \\tilde{S}_n^{-1} S_n\\|_2$ by direct dense linear algebra.\n   - Verify the FFT-accelerated solution $x = \\tilde{S}_n^{-1} b$ obtained via discrete Fourier transforms against a direct dense solve for a random right-hand side $b$, by reporting the relative $\\ell^2$-error $\\|x_{\\text{FFT}} - x_{\\text{direct}}\\|_2 / \\|x_{\\text{direct}}\\|_2$.\n\nAngles must be in radians. There are no physical units in this problem.\n\nTest Suite:\n- Case A (happy path): $n = 128$, $c_0 = 6.0$, $c_1 = -2.0$, $c_2 = 0.5$, $c_3 = 0.3$.\n- Case B (near-diagonal-dominance boundary): $n = 64$, $c_0 = 4.6$, $c_1 = -2.0$, $c_2 = -0.2$, $c_3 = -0.05$.\n- Case C (small size, stronger longer-range coupling): $n = 16$, $c_0 = 7.0$, $c_1 = 1.5$, $c_2 = 1.0$, $c_3 = 0.8$.\n\nAnswer specification:\n- For each case, your program must output a list of three floating-point numbers:\n  - The computed upper bound $E_{\\infty}$ as defined above.\n  - The computed Euclidean operator $2$-norm $\\|I - \\tilde{S}_n^{-1} S_n\\|_2$.\n  - The relative $\\ell^2$-error of the FFT solve versus the direct dense solve.\n- The final output must be a single line containing a list of the three case results in order A, B, C. Each case result must itself be a list with the three numbers, rounded to six decimal places. The exact format is a single line:\n  \"[[A_bound,A_norm,A_err],[B_bound,B_norm,B_err],[C_bound,C_norm,C_err]]\"\n\nYour program must implement all computations self-containedly, using only the stated libraries, and must not read input. The Fast Fourier Transform (FFT) must be used to accelerate $\\tilde{S}_n$ solves, and the calibration must be performed by solving the linear system arising from matching the three symbol moments at $\\theta \\in \\{0,\\tfrac{\\pi}{2},\\pi\\}$.",
            "solution": "The problem requires the design and analysis of a circulant preconditioner $\\tilde{S}_n$ for a symmetric banded Toeplitz matrix $S_n$. The process involves three main tasks: deriving the preconditioner's coefficients, analyzing the preconditioning error, and implementing a numerical verification.\n\n### Part 1: Derivation of the Calibrated Circulant Preconditioner\nThe given Toeplitz matrix $S_n \\in \\mathbb{R}^{n \\times n}$ has entries defined by four coefficients $(c_0, c_1, c_2, c_3)$ and is associated with the generating function, or symbol:\n$$\n\\hat{S}(\\theta) = c_0 + 2 c_1 \\cos(\\theta) + 2 c_2 \\cos(2\\theta) + 2 c_3 \\cos(3\\theta), \\quad \\theta \\in [0, 2\\pi)\n$$\nWe seek a symmetric circulant approximation $\\tilde{S}_n \\in \\mathbb{R}^{n \\times n}$ with a smaller bandwidth, defined by three coefficients $(\\tilde{c}_0, \\tilde{c}_1, \\tilde{c}_2)$. Its symbol is:\n$$\n\\hat{\\tilde{S}}(\\theta) = \\tilde{c}_0 + 2 \\tilde{c}_1 \\cos(\\theta) + 2 \\tilde{c}_2 \\cos(2\\theta)\n$$\nThe calibration of the preconditioner is performed by matching the symbols at a set of discrete angles $\\Theta = \\{0, \\frac{\\pi}{2}, \\pi\\}$. This imposes the condition $\\hat{\\tilde{S}}(\\theta) = \\hat{S}(\\theta)$ for each $\\theta \\in \\Theta$. This yields a system of three linear equations for the three unknown coefficients $(\\tilde{c}_0, \\tilde{c}_1, \\tilde{c}_2)$.\n\nLet's evaluate the symbols at the specified angles:\n\\begin{enumerate}\n    \\item For $\\theta = 0$: We have $\\cos(0) = 1$, $\\cos(2 \\cdot 0) = 1$, and $\\cos(3 \\cdot 0) = 1$. The condition becomes:\n    $$\n    \\tilde{c}_0 + 2\\tilde{c}_1(1) + 2\\tilde{c}_2(1) = c_0 + 2c_1(1) + 2c_2(1) + 2c_3(1) \\\\\n    \\Rightarrow \\tilde{c}_0 + 2\\tilde{c}_1 + 2\\tilde{c}_2 = c_0 + 2c_1 + 2c_2 + 2c_3\n    $$\n\n    \\item For $\\theta = \\frac{\\pi}{2}$: We have $\\cos(\\frac{\\pi}{2}) = 0$, $\\cos(\\pi) = -1$, and $\\cos(\\frac{3\\pi}{2}) = 0$. The condition becomes:\n    $$\n    \\tilde{c}_0 + 2\\tilde{c}_1(0) + 2\\tilde{c}_2(-1) = c_0 + 2c_1(0) + 2c_2(-1) + 2c_3(0) \\\\\n    \\Rightarrow \\tilde{c}_0 - 2\\tilde{c}_2 = c_0 - 2c_2\n    $$\n\n    \\item For $\\theta = \\pi$: We have $\\cos(\\pi) = -1$, $\\cos(2\\pi) = 1$, and $\\cos(3\\pi) = -1$. The condition becomes:\n    $$\n    \\tilde{c}_0 + 2\\tilde{c}_1(-1) + 2\\tilde{c}_2(1) = c_0 + 2c_1(-1) + 2c_2(1) + 2c_3(-1) \\\\\n    \\Rightarrow \\tilde{c}_0 - 2\\tilde{c}_1 + 2\\tilde{c}_2 = c_0 - 2c_1 + 2c_2 - 2c_3\n    $$\n\\end{enumerate}\n\nThis system of three equations can be written in matrix form as:\n$$\n\\begin{pmatrix} 1 & 2 & 2 \\\\ 1 & 0 & -2 \\\\ 1 & -2 & 2 \\end{pmatrix}\n\\begin{pmatrix} \\tilde{c}_0 \\\\ \\tilde{c}_1 \\\\ \\tilde{c}_2 \\end{pmatrix}\n=\n\\begin{pmatrix} c_0 + 2c_1 + 2c_2 + 2c_3 \\\\ c_0 - 2c_2 \\\\ c_0 - 2c_1 + 2c_2 - 2c_3 \\end{pmatrix}\n$$\nThe determinant of the $3 \\times 3$ matrix is $1(0 - 4) - 2(2 - (-2)) + 2(-2 - 0) = -4 - 8 - 4 = -16$, which is non-zero. Hence, a unique solution exists. We solve this system.\nFrom the second equation, $\\tilde{c}_0 - 2\\tilde{c}_2 = c_0 - 2c_2$.\nAdding the first and third equations gives:\n$( \\tilde{c}_0 + 2\\tilde{c}_1 + 2\\tilde{c}_2 ) + ( \\tilde{c}_0 - 2\\tilde{c}_1 + 2\\tilde{c}_2 ) = ( c_0 + 2c_1 + 2c_2 + 2c_3 ) + ( c_0 - 2c_1 + 2c_2 - 2c_3 )$\n$2\\tilde{c}_0 + 4\\tilde{c}_2 = 2c_0 + 4c_2 \\Rightarrow \\tilde{c}_0 + 2\\tilde{c}_2 = c_0 + 2c_2$.\nWe now have a $2 \\times 2$ system for $\\tilde{c}_0$ and $\\tilde{c}_2$:\n$$\n\\begin{cases}\n\\tilde{c}_0 - 2\\tilde{c}_2 = c_0 - 2c_2 \\\\\n\\tilde{c}_0 + 2\\tilde{c}_2 = c_0 + 2c_2\n\\end{cases}\n$$\nAdding these two equations yields $2\\tilde{c}_0 = 2c_0 \\Rightarrow \\tilde{c}_0 = c_0$.\nSubstituting $\\tilde{c}_0 = c_0$ back gives $2\\tilde{c}_2 = 2c_2 \\Rightarrow \\tilde{c}_2 = c_2$.\nFinally, substituting $\\tilde{c}_0=c_0$ and $\\tilde{c}_2=c_2$ into the first original equation:\n$c_0 + 2\\tilde{c}_1 + 2c_2 = c_0 + 2c_1 + 2c_2 + 2c_3 \\Rightarrow 2\\tilde{c}_1 = 2c_1 + 2c_3 \\Rightarrow \\tilde{c}_1 = c_1 + c_3$.\n\nThus, the calibrated coefficients are:\n$$\n\\tilde{c}_0 = c_0, \\quad \\tilde{c}_1 = c_1 + c_3, \\quad \\tilde{c}_2 = c_2\n$$\nThis result shows that the calibration effectively folds the coefficient $c_3$ of the $\\cos(3\\theta)$ term into the coefficient of the $\\cos(\\theta)$ term.\n\n### Part 2: Analysis of the Preconditioning Error\nThe quality of a preconditioner $\\tilde{S}_n$ for $S_n$ can be analyzed by examining the preconditioned operator $I - \\tilde{S}_n^{-1} S_n$. The convergence of iterative methods like PCG is governed by the spectral properties of this operator.\n\nThe eigenvalues of an $n \\times n$ circulant matrix $C = \\operatorname{Circ}(c_0, c_1, \\dots, c_{n-1})$ are given by the discrete Fourier transform of its first row. For our symmetric circulant preconditioner $\\tilde{S}_n$, whose first row is $[\\tilde{c}_0, \\tilde{c}_1, \\tilde{c}_2, 0, \\dots, 0, \\tilde{c}_2, \\tilde{c}_1]$, the eigenvalues are the samples of its symbol at the Fourier frequencies $\\theta_k = 2\\pi k/n$ for $k=0, \\dots, n-1$:\n$$\n\\lambda_k(\\tilde{S}_n) = \\hat{\\tilde{S}}(\\theta_k) = \\tilde{c}_0 + 2\\tilde{c}_1\\cos(\\theta_k) + 2\\tilde{c}_2\\cos(2\\theta_k)\n$$\nThe strict diagonal dominance condition $c_0 > 2(|c_1|+|c_2|+|c_3|)$ ensures that $\\hat{S}(\\theta) > 0$. It also ensures that $\\hat{\\tilde{S}}(\\theta) > 0$, since $\\hat{\\tilde{S}}(\\theta) \\ge c_0 - 2|\\tilde{c}_1| - 2|\\tilde{c}_2| = c_0 - 2|c_1+c_3| - 2|c_2| \\ge c_0 - 2(|c_1|+|c_3|+|c_2|) > 0$. This guarantees $\\tilde{S}_n$ is symmetric positive definite (SPD).\n\nThe eigenvalues of the Toeplitz matrix $S_n$ do not have a simple closed-form expression. However, according to Szegő's theorem, as $n \\to \\infty$, the eigenvalues of $S_n$ become densely distributed according to the values of its symbol $\\hat{S}(\\theta)$. For any finite $n$, the eigenvalues of $S_n$ are contained in the interval $[\\min_\\theta \\hat{S}(\\theta), \\max_\\theta \\hat{S}(\\theta)]$.\n\nThe eigenvalues of the preconditioned matrix $\\tilde{S}_n^{-1} S_n$ are asymptotically described by the ratio of the symbols, $\\hat{S}(\\theta)/\\hat{\\tilde{S}}(\\theta)$. The spread of these eigenvalues around $1$ determines the effectiveness of the preconditioner. The eigenvalues of the error operator $I - \\tilde{S}_n^{-1} S_n$ are then given by $1 - \\lambda_k(\\tilde{S}_n^{-1} S_n)$, which are asymptotically described by $1 - \\hat{S}(\\theta)/\\hat{\\tilde{S}}(\\theta)$.\nThe maximum absolute value of this function over $\\theta$ provides an a priori bound on the spectral radius of the error operator:\n$$\nE_{\\infty} := \\sup_{\\theta \\in [0,2\\pi)} \\left| 1 - \\frac{\\hat{S}(\\theta)}{\\hat{\\tilde{S}}(\\theta)} \\right| \\ge \\rho(I - \\tilde{S}_n^{-1} S_n) \\text{ for large } n\n$$\nThe Euclidean operator $2$-norm is related to the spectral radius. For any matrix $A$, $\\|A\\|_2 \\ge \\rho(A)$. Equality holds if $A$ is a normal matrix. While $I - \\tilde{S}_n^{-1} S_n$ is not normal in general (as $S_n$ and $\\tilde{S}_n^{-1}$ do not commute), Toeplitz matrices are \"asymptotically circulant\" in the sense that $S_n$ can be written as a circulant matrix plus a low-rank correction. For large $n$, this correction becomes negligible, and thus $\\|I - \\tilde{S}_n^{-1} S_n\\|_2$ is expected to be close to $\\rho(I - \\tilde{S}_n^{-1} S_n)$, and therefore well-approximated by $E_{\\infty}$.\n\nIn the context of the Preconditioned Conjugate Gradient (PCG) method, the convergence rate depends on the condition number of $\\tilde{S}_n^{-1} S_n$, which is bounded by $\\sup_k \\lambda_k / \\inf_k \\lambda_k$, where $\\lambda_k$ are the eigenvalues of $\\tilde{S}_n^{-1} S_n$. These are in turn bounded by $\\sup_\\theta (\\hat{S}/\\hat{\\tilde{S}})$ and $\\inf_\\theta (\\hat{S}/\\hat{\\tilde{S}})$. More directly, the convergence rate is controlled by the norm of the error operator in the $\\tilde{S}_n$-energy norm:\n$$\n\\|I - \\tilde{S}_n^{-1} S_n\\|_{\\tilde{S}_n} = \\|I - \\tilde{S}_n^{-1/2} S_n \\tilde{S}_n^{-1/2}\\|_2 = \\max_k |1 - \\lambda_k(\\tilde{S}_n^{-1} S_n)|\n$$\nThis norm is bounded by $E_\\infty$. Hence, $E_{\\infty}$ provides a direct upper bound on the reduction factor of the error in the $\\tilde{S}_n$-energy norm per PCG iteration.\n\n### Part 3: Numerical Implementation Strategy\nThe numerical tasks are performed as follows:\n\\begin{enumerate}\n    \\item \\textbf{Matrix Construction}: For each test case, we first calculate $(\\tilde{c}_0, \\tilde{c}_1, \\tilde{c}_2)$ from $(c_0, c_1, c_2, c_3)$. The Toeplitz matrix $S_n$ is built using `scipy.linalg.toeplitz` from its first column $[c_0, c_1, c_2, c_3, 0, \\dots]^T$. The symmetric circulant preconditioner $\\tilde{S}_n$ is built using `scipy.linalg.circulant` from its first row/column $[\\tilde{c}_0, \\tilde{c}_1, \\tilde{c}_2, 0, \\dots, 0, \\tilde{c}_2, \\tilde{c}_1]^T$.\n    \\item \\textbf{Error Bound $E_\\infty$}: We compute $E_\\infty$ by numerically approximating the supremum. The interval $[0, 2\\pi)$ is discretized into a fine grid of points for $\\theta$. The symbols $\\hat{S}(\\theta)$ and $\\hat{\\tilde{S}}(\\theta)$ are evaluated on this grid, and the maximum of $|1 - \\hat{S}(\\theta)/\\hat{\\tilde{S}}(\\theta)|$ is taken as the value of $E_\\infty$.\n    \\item \\textbf{Operator Norm}: The Euclidean $2$-norm $\\|I - \\tilde{S}_n^{-1} S_n\\|_2$ is computed directly. We form the matrix $K = I - \\tilde{S}_n^{-1} S_n$ using dense matrix operations (`numpy.linalg.inv`, matrix multiplication) and then find its $2$-norm using `numpy.linalg.norm(K, ord=2)`.\n    \\item \\textbf{FFT-Accelerated Solve}: To solve $\\tilde{S}_n x = b$, we leverage the property that circulant matrices are diagonalized by the Discrete Fourier Transform (DFT). The solution is $x = \\tilde{S}_n^{-1}b = F_n^{-1} \\Lambda_n^{-1} F_n b$, where $F_n$ is the DFT matrix and $\\Lambda_n$ is the diagonal matrix of eigenvalues of $\\tilde{S}_n$. This translates to the following algorithm:\n        \\begin{enumerate}\n            \\item Compute the eigenvalues $\\lambda$ of $\\tilde{S}_n$ by taking the FFT of its first row.\n            \\item Compute the FFT of the right-hand side vector $b$: $\\hat{b} = \\text{FFT}(b)$.\n            \\item Solve in the frequency domain by element-wise division: $\\hat{x} = \\hat{b} / \\lambda$.\n            \\item Transform the solution back to the physical domain: $x = \\text{IFFT}(\\hat{x})$.\n        \\end{enumerate}\n    This FFT-based solution $x_{\\text{FFT}}$ is then compared against a solution $x_{\\text{direct}}$ from a standard dense solver (`numpy.linalg.solve`). The relative $\\ell^2$-error $\\|x_{\\text{FFT}} - x_{\\text{direct}}\\|_2 / \\|x_{\\text{direct}}\\|_2$ is computed to verify the implementation. A random vector $b$ is used for this verification.\n\\end{enumerate}\nThis principled approach combines analytical derivations with numerical algorithms to fully address the problem.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import toeplitz, circulant, solve\nfrom scipy.fft import fft, ifft\n\ndef solve_problem():\n    \"\"\"\n    Solves the problem for all test cases and prints the results in the specified format.\n    \"\"\"\n\n    test_cases = [\n        # Case A (happy path)\n        {'n': 128, 'c0': 6.0, 'c1': -2.0, 'c2': 0.5, 'c3': 0.3, 'name': 'A'},\n        # Case B (near-diagonal-dominance boundary)\n        {'n': 64, 'c0': 4.6, 'c1': -2.0, 'c2': -0.2, 'c3': -0.05, 'name': 'B'},\n        # Case C (small size, stronger longer-range coupling)\n        {'n': 16, 'c0': 7.0, 'c1': 1.5, 'c2': 1.0, 'c3': 0.8, 'name': 'C'},\n    ]\n\n    # Seed the random number generator for reproducibility\n    np.random.seed(0)\n    \n    all_results = []\n\n    for case in test_cases:\n        n, c0, c1, c2, c3 = case['n'], case['c0'], case['c1'], case['c2'], case['c3']\n\n        # 1. Derive calibrated coefficients\n        tilde_c0 = c0\n        tilde_c1 = c1 + c3\n        tilde_c2 = c2\n\n        # 2. Build matrices S_n and tilde_S_n\n        # Build Toeplitz matrix S_n\n        r_S = np.zeros(n)\n        r_S[0] = c0\n        if n > 1: r_S[1] = c1\n        if n > 2: r_S[2] = c2\n        if n > 3: r_S[3] = c3\n        S_n = toeplitz(r_S)\n\n        # Build circulant matrix tilde_S_n\n        r_tilde = np.zeros(n)\n        r_tilde[0] = tilde_c0\n        if n > 1: r_tilde[1] = tilde_c1\n        if n > 2:\n            r_tilde[2] = tilde_c2\n            r_tilde[n - 2] = tilde_c2\n        if n > 1: r_tilde[n - 1] = tilde_c1\n        \n        tilde_S_n = circulant(r_tilde)\n\n        # 3. Compute the error bound E_infty\n        theta = np.linspace(0, 2 * np.pi, 20000, endpoint=False)\n        cos_theta = np.cos(theta)\n        cos_2theta = np.cos(2 * theta)\n        cos_3theta = np.cos(3 * theta)\n\n        S_hat = c0 + 2 * c1 * cos_theta + 2 * c2 * cos_2theta + 2 * c3 * cos_3theta\n        tilde_S_hat = tilde_c0 + 2 * tilde_c1 * cos_theta + 2 * tilde_c2 * cos_2theta\n        \n        # Check positivity of denominator\n        if np.any(tilde_S_hat <= 0):\n            # This should not happen given the problem constraints\n            raise ValueError(\"Symbol of preconditioner is not positive definite.\")\n\n        e_infty = np.max(np.abs(1 - S_hat / tilde_S_hat))\n\n        # 4. Compute the Euclidean operator 2-norm ||I - tilde_S_n^{-1} S_n||_2\n        # Direct computation using dense linear algebra\n        I = np.eye(n)\n        tilde_S_n_inv = np.linalg.inv(tilde_S_n)\n        K = I - tilde_S_n_inv @ S_n\n        norm_K = np.linalg.norm(K, ord=2)\n\n        # 5. Verify FFT-accelerated solve\n        b = np.random.rand(n)\n        \n        # Direct solve\n        x_direct = solve(tilde_S_n, b)\n\n        # FFT-accelerated solve\n        lambda_vals = fft(r_tilde) # Eigenvalues are FFT of the first row\n        b_hat = fft(b)\n        x_hat = b_hat / lambda_vals\n        x_fft = ifft(x_hat)\n\n        # The result should be real; take real part to discard negligible imag parts\n        x_fft_real = x_fft.real\n\n        rel_err = np.linalg.norm(x_fft_real - x_direct) / np.linalg.norm(x_direct)\n\n        all_results.append([e_infty, norm_K, rel_err])\n\n    # Format the final output string as specified\n    case_results_str = []\n    for r in all_results:\n        case_results_str.append(f\"[{r[0]:.6f},{r[1]:.6f},{r[2]:.6f}]\")\n    \n    final_output = f\"[{','.join(case_results_str)}]\"\n    print(final_output)\n\nsolve_problem()\n```"
        }
    ]
}