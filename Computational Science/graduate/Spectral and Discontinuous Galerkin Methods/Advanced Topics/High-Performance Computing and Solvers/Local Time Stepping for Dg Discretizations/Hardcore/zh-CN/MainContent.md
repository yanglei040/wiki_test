## 引言
在求解时间依赖的[偏微分方程](@entry_id:141332)时，不连续伽辽金（DG）方法因其[高阶精度](@entry_id:750325)、局部守恒性和处理复杂几何的灵活性而备受青睐。然而，当与[显式时间积分](@entry_id:165797)方案结合使用时，[DG方法](@entry_id:748369)面临一个严峻的效率瓶颈：全局时间步长受限于网格中最苛刻的单元，即尺寸最小或多项式阶数最高的单元。这种全局同步策略导致在大部分计算域上浪费了大量计算资源。[局部时间步进](@entry_id:751409)（Local Time Stepping, LTS）技术应运而生，旨在通过为计算域的不同部分分配各自最优的时间步长，从而根本性地解决这一问题。

本文将系统性地剖析用于[DG离散化](@entry_id:748366)的LTS方法。读者将通过以下三个章节，构建对此项技术的全面理解：
*   **第一章：原理与机制**，将深入探讨LTS背后的基本原理，阐明其为保证数值格式的守恒性、精度和稳定性所依赖的核心机制，如[界面耦合](@entry_id:750728)与高阶插值。
*   **第二章：应用与跨学科联系**，将展示LTS-[DG方法](@entry_id:748369)在[流体力学](@entry_id:136788)、地球物理学等多个领域的实际应用，并讨论其如何与[自适应网格加密](@entry_id:143852)、[隐式-显式格式](@entry_id:750545)以及[高性能计算](@entry_id:169980)策略相结合，以解决前沿科学问题。
*   **第三章：动手实践**，将提供一系列具体的编程练习，引导读者从计算局部稳定步长开始，逐步构建并分析一个完整的LTS格式，从而将理论知识转化为实践能力。

通过本文的学习，读者将掌握设计、分析和实现高效且鲁棒的LTS-DG求解器的关键知识，为应对复杂的[多尺度模拟](@entry_id:752335)挑战打下坚实的基础。

## 原理与机制

在不连续伽辽金 (Discontinuous Galerkin, DG) 方法的框架内，[局部时间步进](@entry_id:751409) (Local Time Stepping, LTS) 是一种旨在克服[显式时间积分](@entry_id:165797)方案中全局[时间步长限制](@entry_id:756010)的关键技术。当空间网格在尺寸或多项式阶数上表现出显著变化时，显式方法的稳定性通常受到最小或最[高阶单元](@entry_id:750328)的严格约束。LTS 通过允许计算域中的每个单元或单元组采用其自身的最优局部时间步长来解决这一效率瓶颈。本章旨在阐述支持这些多速率方案的基本原理，并探讨为确保其稳定性、守恒性和[高阶精度](@entry_id:750325)而设计的核心机制。

### [局部时间步进](@entry_id:751409)的基本原理

[局部时间步进](@entry_id:751409)的根本动机源于[显式时间积分](@entry_id:165797)方法应用于 DG 空间离散时所固有的稳定性约束，即 Courant–Friedrichs–Lewy (CFL) 条件。对于一个[半离散化](@entry_id:163562)的双曲问题，其形式为 $\frac{d\mathbf{u}}{dt} = \mathcal{L}(\mathbf{u})$，其中 $\mathcal{L}$ 是 DG 空间算子，一个[显式时间积分](@entry_id:165797)方案的稳定性要求时间步长 $\Delta t$ 必须满足与 $\mathcal{L}$ 的谱半径 $\rho(\mathcal{L})$ 相关的条件。

对于一维线性平流方程 $u_t + a u_x = 0$，当使用 $p$ 阶多项式的 DG 方法时，谱分析表明，在单元 $K_e$ 上的最大允许时间步长 $\Delta t_e$ 遵循以下标度关系  ：
$$
\Delta t_e \le C \frac{h_e}{|a|(2p_e+1)}
$$
其中，$h_e$ 是单元 $K_e$ 的尺寸，$p_e$ 是该单元上的[多项式逼近](@entry_id:137391)阶数，$a$ 是[平流](@entry_id:270026)速度，$C$ 是一个取决于所用[时间积分](@entry_id:267413)方案（例如，一个强稳定性保持龙格－库塔方法）和[基函数](@entry_id:170178)的常数。

这个 **CFL 条件** 揭示了两个关键依赖关系：$\Delta t_e$ 与单元尺寸 $h_e$ 成正比，并与多项式阶数 $p_e$ 的一个超线性函数成反比（通常是 $O(p_e^{-2})$，但在某些特定情况下，如一维平流问题，可以是 $O(p_e^{-1})$）。因此，在包含显著变化的单元尺寸（例如，在[自适应网格加密](@entry_id:143852)中）或变化的逼近阶数（$hp$-自适应）的网格中，全局时间步长将被最受限制的单元（即最小的 $h_e$ 或最高的 $p_e$）所支配。这种全局同步策略在计算上是极其浪费的，因为大多数单元被迫采用远小于其自身稳定性极限的时间步长。[局部时间步进](@entry_id:751409)通过允许每个单元 $K_e$ 以其自身的[局部时](@entry_id:194383)间步长 $\Delta t_e$ 演化来直接应对这一挑战，从而显著提高整体[计算效率](@entry_id:270255)。

### 守恒、精度与稳定性的核心原则

虽然[局部时间步进](@entry_id:751409)在效率上具有巨大优势，但其实现必须小心处理，以维护数值格式的三个基本属性：守恒性、精度和稳定性。

#### 守恒性

对于守恒律的离散化，**守恒性** 是一个至关重要的物理原则，它确保了离散解在全局上能够保持守恒量。DG 方法通过其基于[数值通量](@entry_id:752791)的公式来保证空间上的守恒性。然而，在 LTS 方案中，相邻单元在不同的时间点上进行更新，这给时间上的守恒性带来了挑战。

为了在 LTS 中实现离散守恒，必须满足一个基本原则：在任何共同的同步时间区间 $[t^n, t^{n+1}]$ 内，跨越两个相邻单元（例如 $A$ 和 $B$）之间界面的时间积分数值通量对于这两个单元必须是大小相等、方向相反的 。数学上，这表示：
$$
\int_{t^n}^{t^{n+1}} \int_{\Gamma_{AB}} \widehat{\mathbf{F}}(\mathbf{u}_A, \mathbf{u}_B; \mathbf{n}_{A}) \, dS \, dt = - \int_{t^n}^{t^{n+1}} \int_{\Gamma_{AB}} \widehat{\mathbf{F}}(\mathbf{u}_B, \mathbf{u}_A; \mathbf{n}_{B}) \, dS \, dt
$$
其中 $\widehat{\mathbf{F}}$ 是[数值通量](@entry_id:752791)，$\mathbf{n}_A$ 和 $\mathbf{n}_B = -\mathbf{n}_A$ 是单元 $A$ 和 $B$ 在共享界面 $\Gamma_{AB}$ 上的外[法向量](@entry_id:264185)。由于数值通量本身是守恒的（即 $\widehat{\mathbf{F}}(\mathbf{u}_A, \mathbf{u}_B; \mathbf{n}_{A}) = -\widehat{\mathbf{F}}(\mathbf{u}_B, \mathbf{u}_A; \mathbf{n}_{B})$），这一条件简化为要求两个单元在计算其各自状态更新时，必须使用对界面通量随[时间演化](@entry_id:153943)的**相同**[数值积分](@entry_id:136578)近似。当两个单元的积分方法或时间点不匹配时，就会产生一个**守恒缺陷**。我们将在后续章节中探讨诸如通量累加和通量修正等机制如何精确地满足这一条件。

#### 精度

为了使整个 LTS 方案达到全局 $q$ 阶精度，单元内部的时间积分器和[界面耦合](@entry_id:750728)机制都必须足够精确。一个 $q$ 阶龙格－库塔 ([Runge-Kutta](@entry_id:140452), RK) 方法在每个步长为 $H$ 的演化中产生的[局部截断误差](@entry_id:147703) (Local Truncation Error, LTE) 为 $O(H^{q+1})$。在 LTS 框架中，界面通量的处理是额外误差的来源。

关键的精度原则是：为了保持全局 $q$ 阶精度，用于近似界面上[时间积分](@entry_id:267413)通量的**时间求积规则必须至少对 $q-1$ 次多项式是精确的** 。这是因为一个 $q$ 阶 RK 方法在时间步内自然地提供了对解的一个 $q-1$ 次多项式近似。为了不引入低于方法阶数的误差，对这个多项式通量的积分必须足够精确。

例如，考虑一个使用[梯形法则](@entry_id:145375)（一种二阶方法，即 $p_t = 2$）的 LTS 方案。其 LTE 为 $O(\Delta t^3)$。如果粗细单元界面上的[通量积分](@entry_id:138365)也使用[梯形法则](@entry_id:145375)，但步长不同（例如，粗单元一步，细单元 $q$ 步复合），它们之间的积分失配（即守恒缺陷）的量级为 $O(\Delta t^3)$ 。由于这个失配误差的阶数不低于基准方法的 LTE，它不会污染解，全局[二阶精度](@entry_id:137876)得以保持。如果界面求积的精度低于 $q-1$ 阶，它将成为主要的误差来源，导致全局精度的降低。

#### 稳定性

在 LTS 中确保稳定[性比](@entry_id:172643)在[全局时间步进](@entry_id:749933)中更为复杂。对于许多双曲问题，特别是在存在激波或其他[不连续性](@entry_id:144108)的情况下，**强稳定性保持 (Strong Stability Preserving, SSP)** 特性至关重要。SSP 时间积分器保证在某些范数（如总变差范数）下，只要向前欧拉法是稳定的，高阶方法就不会放大解中的[振荡](@entry_id:267781)。

一个 SSP-RK 方法可以被看作是一系列向前欧拉步骤的**[凸组合](@entry_id:635830)** 。这意味着整个更新过程可以通过对具有非负系数的有效向前欧拉步进行加权平均来表示。为了在 LTS 框架下保持 SSP 特性，整个多速率更新方案，包括界面上的耦合，必须能够分解为一个大的、统一的[凸组合](@entry_id:635830)。

这引出了一个严格的稳定性原则：当一个单元需要其邻居在某个中间时间点的状态来进行通量计算时，这个被提供的**界面状态本身必须是一个有效状态的[凸组合](@entry_id:635830)**。有效状态是指通过满足局部 CFL 条件的向前欧拉步骤可以达到的状态。任何涉及负权重（如某些高阶外插）或违反局部 CFL 条件的界面状态构造方法，通常会破坏 SSP 特性，并可能导致非物理[振荡](@entry_id:267781)或彻底的不稳定性 。

### [界面耦合](@entry_id:750728)机制

为了同时满足守恒性、精度和稳定性的要求，已经发展出多种[界面耦合](@entry_id:750728)机制。这些机制的核心任务是在时间步长和时间点不匹配的相邻单元之间，以一种一致的方式交换信息。

#### [子循环](@entry_id:755594)与通量累加

[子循环](@entry_id:755594) (subcycling) 是最直观的 LTS 方法之一，通常用于粗细单元时间步长之比为整数 $r = \Delta t_c / \Delta t_f$ 的情况 。其工作流程如下：
1.  在粗单元 $K_c$ 的一个大步长 $\Delta t_c$ 内，细单元 $K_f$ 执行 $r$ 个小步长 $\Delta t_f$ 的演化。
2.  在 $K_f$ 的每一个子步中，它都需要来自 $K_c$ 在当前子步时间点上的界面状态以计算[数值通量](@entry_id:752791)。由于 $K_c$ 在整个 $\Delta t_c$ 内“冻结”，其状态必须通过高阶时间**预测**或**插值**来提供。
3.  在每个子步中计算出的界面通量被用来更新细单元 $K_f$。
4.  为了保证守恒性，这些在 $r$ 个子步中计算出的时间积分通量贡献被累加到一个**通量寄存器** (flux register) 中。
5.  在粗步长 $\Delta t_c$ 结束时，这个累加的总通量被传递给粗单元 $K_c$，用于其单步更新。通过确保粗细单元在整个同步区间内使用相同的总时间积分通量（符号相反），离散守恒性得以精确保持 。

在一个简化的假设下，即每个微步内的通量是时间上的分段常数，那么要精确地对这个分段[常数函数](@entry_id:152060)进行积分，就需要 $r$ 个时间求积点，每个微步区间一个 。这直观地展示了对界面通量进行充[分时](@entry_id:274419)间分辨的需求。

#### 通量修正

作为一种替代或补充策略，**通量修正** (flux correction) 提供了一种在事后强制执行守恒性的方法。其思想是允许粗细单元首先使用各自的[积分器](@entry_id:261578)独立计算其状态更新，这可能会导致通量不匹配。然后，计算出这个守恒缺陷，并将其作为修正量施加到一个单元（通常是粗单元）上。

修正增量的推导非常直接 。粗单元的修正量 $\Delta \boldsymbol{U}_{c}^{\mathrm{corr}}$ 等于由粗单元计算的总[时间积分](@entry_id:267413)通量与由细单元计算的总时间积分通量之间的差值，再除以粗单元的体积（或面积）：
$$
\Delta \boldsymbol{U}_{c}^{\mathrm{corr}} = \frac{1}{|K_{c}|} \left( \Delta t_{c} \boldsymbol{\phi}_{c} - \sum_{m=1}^{r} \Delta t_{f} \boldsymbol{\phi}_{f}^{(m)} \right)
$$
其中 $\boldsymbol{\phi}_c$ 是粗单元使用的平均通量，而 $\boldsymbol{\phi}_f^{(m)}$ 是细单元在第 $m$ 个子步使用的平均通量。这种方法可以保证守恒性达到机器精度。

#### 用于多速率方法的高阶插值

对于更一般的情况，例如非整数步长比或更复杂的[积分器](@entry_id:261578)，[界面耦合](@entry_id:750728)依赖于高阶[时间插值](@entry_id:755845)。

*   **多速率龙格－库塔 (Multirate [Runge-Kutta](@entry_id:140452), MRK)** 方法的核心是在需要时能够提供邻居在任意中间**阶段时间**的状态。这通常通过所谓的**[密集输出](@entry_id:139023) (dense output)** 来实现，即利用邻居 RK 方法的阶段值构造一个高阶[插值多项式](@entry_id:750764)。通过这种方式，两个单元都能在各自的求积点上获得一致的界面状态，从而计算出一致的数值通量，并最终得到一致的[时间积分](@entry_id:267413)通量  。

*   **多速率亚当斯－巴什福思 (Multirate [Adams-Bashforth](@entry_id:168783), MRAB)** 方法是[多步法](@entry_id:147097)，它利用历史解信息进行外插。在多速率环境中，一个单元需要其邻居在自己过去时间点上的状态。这同样需要通过对邻居的历史解进行高阶插值来实现 。

*   **多速率谱延迟修正 (Multirate Spectral Deferred Correction, MRSDC)** 方法在每个时间步内的一组[配置点](@entry_id:169000)上迭代地修正解。当相邻单元的[配置点](@entry_id:169000)不重合时，一个单元可以通过对其邻居的解多项式（该多项式穿过其自身的[配置点](@entry_id:169000)）进行求值，来获得在自己[配置点](@entry_id:169000)上所需的状态。这种高阶插值交换使得界面通量可以在整个时间步上得到一致且高精度的定义 。

#### [非线性](@entry_id:637147)问题的处理

当将 LTS 应用于[非线性](@entry_id:637147)守恒律（如[欧拉方程](@entry_id:177914)或[伯格斯方程](@entry_id:177995)）时，上述机制依然适用，但界面通量的计算变得更加复杂。[数值通量](@entry_id:752791) $\widehat{\mathbf{F}}$ 的计算通常需要求解一个**黎曼问题**。

在异步界面上，这意味着在需要通量的每个时间点 $t$，我们必须用来自左右单元的（可能经过插值或预测的）状态 $u_L(t)$ 和 $u_R(t)$ 来构建并求解一个瞬时[黎曼问题](@entry_id:171440)。例如，对于[伯格斯方程](@entry_id:177995)，戈杜诺夫 (Godunov) 通量是物理通量 $f(u) = \frac{1}{2}u^2$ 在黎曼问题解的界面值 $u_{RP}(0; t)$ 上的取值。由于 $u_L(t)$ 和 $u_R(t)$ 随时间变化，波的结构（激波或[稀疏波](@entry_id:168428)）和界面值 $u_{RP}(0;t)$ 也可能随时间变化。总的[时间积分](@entry_id:267413)通量就是对这个随时间变化的[戈杜诺夫通量](@entry_id:634733)进行积分的结果 。这进一步凸显了在界面上拥有一个精确且一致的时间表示的极端重要性。