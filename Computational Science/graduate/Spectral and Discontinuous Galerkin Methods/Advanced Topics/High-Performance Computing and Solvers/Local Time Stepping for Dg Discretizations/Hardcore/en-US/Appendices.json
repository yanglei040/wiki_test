{
    "hands_on_practices": [
        {
            "introduction": "The core motivation for local time stepping (LTS) is to assign each element a time step tailored to its own stability limit. This practice provides the foundational skill of calculating this local limit based on the element's properties and the chosen numerical scheme. By working through the relationship between mesh size, polynomial degree, and the stable time step for a Discontinuous Galerkin discretization , you will master the fundamental calculation that underpins all explicit LTS methods.",
            "id": "3396758",
            "problem": "Consider the one-dimensional linear advection equation $u_{t} + a\\,u_{x} = 0$ on a nonuniform mesh consisting of three elements with sizes $h_{1} = 1$, $h_{2} = 1/2$, and $h_{3} = 1/4$. The spatial discretization is performed using the Discontinuous Galerkin (DG) method with polynomial degree $p = 2$ on each element and an upwind numerical flux. Time integration is performed using the Strong Stability Preserving Runge–Kutta method of order $3$ (SSP-RK3). Assume the advection speed is $a = 1$ and that the computation is non-dimensionalized so that time is reported without physical units.\n\nLet $\\Delta t_{K}$ denote the maximal stable local time step on element $K$ under a local time stepping strategy. Starting from the stability requirement for explicit time integration of linear systems and standard DG estimates for the spectral radius under upwind fluxes, derive the functional dependence of $\\Delta t_{K}$ on $h_{K}$, $a$, and $p$, using only the following assumption: there exists a stability constant $C(p)$ such that the forward Euler stable time step satisfies $\\Delta t_{\\mathrm{FE},K} \\le C(p)\\,h_{K}/|a|$, with $C(p) = 1/(2p+1)$. Then, accounting for SSP-RK3, compute the three local time steps $\\Delta t_{1}$, $\\Delta t_{2}$, and $\\Delta t_{3}$ for the given mesh.\n\nExpress each $\\Delta t_{K}$ as an exact fraction; do not round or decimalize. Provide your final answer as a row vector $\\bigl[\\Delta t_{1},\\Delta t_{2},\\Delta t_{3}\\bigr]$.",
            "solution": "The user wants me to solve a numerical analysis problem involving local time stepping for a Discontinuous Galerkin (DG) discretization of the linear advection equation. First, I must validate the problem statement.\n\n### Step 1: Extract Givens\n- **Governing Equation**: The one-dimensional linear advection equation, $u_{t} + a\\,u_{x} = 0$.\n- **Advection Speed**: $a = 1$.\n- **Mesh**: A nonuniform mesh of three elements with sizes $h_{1} = 1$, $h_{2} = 1/2$, and $h_{3} = 1/4$.\n- **Spatial Discretization**: Discontinuous Galerkin (DG) method with polynomial degree $p = 2$ on each element.\n- **Numerical Flux**: Upwind flux.\n- **Time Integration**: Strong Stability Preserving Runge–Kutta method of order $3$ (SSP-RK3).\n- **Stability Assumption**: The forward Euler stable time step for an element $K$ is given by $\\Delta t_{\\mathrm{FE},K} \\le C(p)\\,h_{K}/|a|$.\n- **Stability Constant**: The function $C(p)$ is defined as $C(p) = 1/(2p+1)$.\n- **Objective**: Compute the three maximal stable local time steps $\\Delta t_{1}$, $\\Delta t_{2}$, and $\\Delta t_{3}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to validation against the established criteria.\n- **Scientific Grounding**: The problem is well-grounded in the established theory of numerical methods for partial differential equations. The DG method, SSP time integrators, and Courant-Friedrichs-Lewy (CFL) stability conditions are all standard concepts in computational science and engineering. The provided stability estimate $\\Delta t_{\\mathrm{FE},K} \\le \\frac{h_K}{(2p+1)|a|}$ is a known result for the 1D linear advection equation discretized with DG and an upwind flux.\n- **Well-Posedness**: The problem is well-posed. It provides all necessary parameters ($a$, $p$, $h_K$) and definitions (the specific time integrator and the base stability condition) to determine a unique solution for the local time steps.\n- **Objectivity**: The problem is stated in precise, objective, and unambiguous mathematical terms.\n- **Flaw Checklist**: The problem does not violate any of the specified invalidity criteria. It is scientifically sound, formalizable, complete, realistic, and well-structured.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A full solution will be provided.\n\nThe semi-discretization of the partial differential equation $u_{t} + a\\,u_{x} = 0$ using the Discontinuous Galerkin method results in a system of ordinary differential equations (ODEs) for the degrees of freedom on each element. This system can be written abstractly as $\\frac{d\\mathbf{u}}{dt} = \\mathbf{L}_h(\\mathbf{u})$, where $\\mathbf{L}_h$ is the spatial discretization operator. For an explicit time integration scheme to be stable, the time step $\\Delta t$ must be chosen such that $\\Delta t$ scaled by the spectral radius of $\\mathbf{L}_h$ lies within the stability region of the time integrator.\n\nThe problem provides the stability constraint for the simplest explicit time integrator, the Forward Euler (FE) method. For an element $K$ in the mesh, the maximal stable time step under the FE method is given as:\n$$ \\Delta t_{\\mathrm{FE},K}^{\\max} = C(p)\\,\\frac{h_{K}}{|a|} $$\nWith the provided definition $C(p) = 1/(2p+1)$, this becomes:\n$$ \\Delta t_{\\mathrm{FE},K}^{\\max} = \\frac{1}{2p+1} \\frac{h_{K}}{|a|} $$\nThis is a form of the CFL condition, specific to the DG discretization.\n\nThe problem specifies the use of a Strong Stability Preserving Runge–Kutta method of order $3$ (SSP-RK3). SSP methods are designed such that they remain stable for a given ODE system under any time step $\\Delta t$ that is stable for the Forward Euler method, scaled by a factor known as the SSP coefficient, $c$. The stability condition for an SSP method is:\n$$ \\Delta t \\le c \\cdot \\Delta t_{\\mathrm{FE}}^{\\max} $$\nThe specific method, SSP-RK3, refers to the popular third-order, three-stage scheme developed by Shu and Osher. A fundamental and defining property of this method is that its SSP coefficient is $c=1$. Therefore, for this method, the maximum stable time step is identical to the maximum stable Forward Euler time step.\n\nLet $\\Delta t_K$ be the maximal stable local time step on element $K$ using the SSP-RK3 integrator. We can write:\n$$ \\Delta t_{K} = c_{\\mathrm{SSP-RK3}} \\cdot \\Delta t_{\\mathrm{FE},K}^{\\max} $$\nSince $c_{\\mathrm{SSP-RK3}} = 1$, we have:\n$$ \\Delta t_{K} = \\Delta t_{\\mathrm{FE},K}^{\\max} = \\frac{1}{2p+1} \\frac{h_{K}}{|a|} $$\nThis expression provides the functional dependence of the local time step $\\Delta t_K$ on the element size $h_K$, the advection speed $a$, and the polynomial degree $p$.\n\nNow, we can substitute the specific values given in the problem statement:\n- Polynomial degree: $p = 2$\n- Advection speed: $a = 1$\n\nFirst, we compute the constant factor in the expression for $\\Delta t_K$:\n$$ \\frac{1}{(2p+1)|a|} = \\frac{1}{(2(2)+1)|1|} = \\frac{1}{4+1} = \\frac{1}{5} $$\nThus, the formula for the local time steps simplifies to:\n$$ \\Delta t_{K} = \\frac{h_{K}}{5} $$\n\nWe now apply this formula to each of the three elements using their specified sizes:\n- For element $1$, with $h_{1} = 1$:\n$$ \\Delta t_{1} = \\frac{h_{1}}{5} = \\frac{1}{5} $$\n\n- For element $2$, with $h_{2} = 1/2$:\n$$ \\Delta t_{2} = \\frac{h_{2}}{5} = \\frac{1/2}{5} = \\frac{1}{10} $$\n\n- For element $3$, with $h_{3} = 1/4$:\n$$ \\Delta t_{3} = \\frac{h_{3}}{5} = \\frac{1/4}{5} = \\frac{1}{20} $$\n\nThe three local time steps are $\\Delta t_{1} = 1/5$, $\\Delta t_{2} = 1/10$, and $\\Delta t_{3} = 1/20$. The final answer should be presented as a row vector.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{5} & \\frac{1}{10} & \\frac{1}{20}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "With an understanding of how to determine individual local time steps, the next challenge is to construct a coherent algorithm that evolves the coupled system accurately. This hands-on coding exercise guides you through the implementation of two distinct multirate schemes: one based on an Adams-Bashforth method and the other on a Runge-Kutta method . By implementing the necessary coupling strategies and comparing the resulting local truncation errors, you will gain practical insight into the design and performance of different LTS algorithms.",
            "id": "3396684",
            "problem": "Consider the one-dimensional linear advection equation with constant advection speed, semi-discretized by a Discontinuous Galerkin (DG) method using piecewise constants (polynomial degree zero) and an upwind numerical flux on a periodic mesh with two elements. Let the left element be designated as the \"fine\" partition with size $\\Delta x_f$ and the right element be the \"coarse\" partition with size $\\Delta x_c$. For advection speed $a$, this semi-discretization yields a linear system of ordinary differential equations\n$$\n\\frac{d}{dt} \\begin{bmatrix} u_f \\\\ u_c \\end{bmatrix} = L \\begin{bmatrix} u_f \\\\ u_c \\end{bmatrix}, \\quad L = \\begin{bmatrix} -\\frac{a}{\\Delta x_f} & \\frac{a}{\\Delta x_f} \\\\ \\frac{a}{\\Delta x_c} & -\\frac{a}{\\Delta x_c} \\end{bmatrix},\n$$\nwhere $u_f$ is the cell average on the fine element and $u_c$ is the cell average on the coarse element. The periodic boundary condition closes the system by making the neighbor of the fine cell on its left be the coarse cell.\n\nYou will implement and compare two explicit multirate local time stepping (LTS) schemes for this semi-discrete system with a step ratio $r=2$ between the fine and coarse elements. The step sizes are $H$ for the coarse macro-step and $h = H / 2$ for the fine micro-step. Both methods must be run for a single coarse macro-step starting from an initial condition at time $t=0$.\n\nDefinitions and requirements:\n\n- Discontinuous Galerkin (DG) is the method producing the semi-discrete operator $L$ above.\n- Local Time Stepping (LTS) means different partitions (fine and coarse) use different time steps.\n- Adams-Bashforth (AB) refers to the explicit multistep Adams-Bashforth method.\n- Runge-Kutta (RK) refers to an explicit Runge-Kutta method.\n\nPartitioned right-hand sides are defined by the rows of $L$: for the fine partition,\n$$\nf_f(t) = L_{ff} u_f(t) + L_{fc} u_c(t),\n$$\nand for the coarse partition,\n$$\nf_c(t) = L_{cf} u_f(t) + L_{cc} u_c(t).\n$$\n\nYou must implement the following two multirate schemes with step ratio $r=2$:\n\n1. Multirate Adams-Bashforth of order two (MRAB2) with linear extrapolation coupling for the fine partition:\n   - For the fine partition, use two micro-steps of size $h$ over $[0,H]$ with the two-step Adams-Bashforth update. At any time $\\tau$ at which the fine right-hand side requires the coarse value, approximate the coarse value by a linear polynomial constructed from exact coarse values at the previous two coarse times, $\\tau = 0$ and $\\tau = -H$:\n     $$\n     \\tilde{u}_c(\\tau) = u_c(0) + \\frac{\\tau}{H}\\left(u_c(0) - u_c(-H)\\right).\n     $$\n     Use this $\\tilde{u}_c(\\tau)$ inside $f_f(\\tau)=L_{ff}u_f(\\cdot)+L_{fc}\\tilde{u}_c(\\tau)$.\n     The first fine micro-step from $t=0$ uses the exact past fine value at $t=-h$ to evaluate the second history term in Adams-Bashforth. The second fine micro-step uses the first micro-step’s output for the history at $t=h$.\n   - For the coarse partition, perform a single Adams-Bashforth two-step update with step size $H$ using exact past values at $t=0$ and $t=-H$ for both fine and coarse components in the right-hand side evaluations $f_c(0)$ and $f_c(-H)$.\n\n2. Multirate explicit second-order Runge-Kutta (Heun) with subcycling (MR-RK2):\n   - For the fine partition, perform two Heun micro-steps of size $h$ over $[0,H]$. At any time $\\tau$ needed by a fine-stage evaluation, approximate the coarse value with the same linear polynomial $\\tilde{u}_c(\\tau)$ as above. Within each fine Heun step over an interval $[t_n,t_{n+1}]$ with step $h$, use the standard two-stage update\n     $$\n     k_1 = f_f(t_n), \\quad u_f^{\\star} = u_f(t_n) + h\\,k_1, \\quad k_2 = f_f(t_n+h)\\text{ evaluated at }(u_f^{\\star},\\tilde{u}_c(t_n+h)),\n     $$\n     $$\n     u_f(t_{n+1}) = u_f(t_n) + \\frac{h}{2}\\left(k_1 + k_2\\right).\n     $$\n     Initialize with $u_f(0)$ and proceed sequentially for two micro-steps to reach $t=H$.\n   - For the coarse partition, perform a single Heun step of size $H$. Use\n     $$\n     k_1 = f_c(0)\\text{ evaluated at exact }(u_f(0),u_c(0)), \\quad u_c^{\\star} = u_c(0) + H\\,k_1,\n     $$\n     $$\n     k_2 = f_c(H)\\text{ evaluated at }(u_f(H)\\text{ from the fine subcycling result},\\,u_c^{\\star}),\n     $$\n     $$\n     u_c(H) = u_c(0) + \\frac{H}{2}\\left(k_1 + k_2\\right).\n     $$\n\nLocal truncation error definition to be computed:\n\n- Let the exact semi-discrete solution be $u(t) = \\exp(t L) u(0)$, where $\\exp$ is the matrix exponential. The local truncation error for one coarse macro-step $H$ of a given scheme applied to the exact initial and historical data is the Euclidean norm of the difference between the exact solution at $t=H$ and the numerical result after one macro-step,\n  $$\n  \\mathrm{LTE} = \\left\\| u(H) - u_{\\text{num}}(H) \\right\\|_2,\n  $$\n  where $u_{\\text{num}}(H)$ is the scheme’s output constructed as specified above. For any required past time values at $t=-h$ or $t=-H$, use the exact values $u(-h)$ and $u(-H)$. No physical units are required.\n\nImplementation constraints:\n\n- Use the matrix $L$ as defined above.\n- Use the linear extrapolation $\\tilde{u}_c(\\tau)$ only for the fine-partition right-hand side evaluations at times $\\tau$ in $[-H,H]$.\n- For the coarse MRAB2 right-hand sides at $t=0$ and $t=-H$, use exact values for both $u_f$ and $u_c$.\n- For the coarse MR-RK2 stage at $t=H$, use the fine-partition value $u_f(H)$ computed by the fine subcycling Heun method; do not use an exact value at $t=H$ for this stage.\n\nTest suite:\n\nRun your program for the following four cases. In all cases, take $a=1$ and initial condition $u(0) = \\begin{bmatrix} u_f(0) \\\\ u_c(0) \\end{bmatrix}$ as specified. Report the pair $\\left[\\mathrm{LTE}_{\\text{MRAB2}}, \\mathrm{LTE}_{\\text{MR-RK2}}\\right]$ for each case.\n\n- Case A: $\\Delta x_f = 0.5$, $\\Delta x_c = 1.0$, $H = 0.2$, $u(0) = \\begin{bmatrix} 1.0 \\\\ -0.5 \\end{bmatrix}$.\n- Case B: $\\Delta x_f = 0.5$, $\\Delta x_c = 1.0$, $H = 0.05$, $u(0) = \\begin{bmatrix} 1.0 \\\\ -0.5 \\end{bmatrix}$.\n- Case C: $\\Delta x_f = 0.25$, $\\Delta x_c = 0.5$, $H = 0.05$, $u(0) = \\begin{bmatrix} 0.3 \\\\ -0.1 \\end{bmatrix}$.\n- Case D (edge case: constant mode): $\\Delta x_f = 1.0$, $\\Delta x_c = 1.0$, $H = 0.1$, $u(0) = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list of four items, each item being a two-element list with the two truncation error floats for the corresponding case, in the order A, B, C, D. For example, the output must look like\n\"[ [eA_AB,eA_RK], [eB_AB,eB_RK], [eC_AB,eC_RK], [eD_AB,eD_RK] ]\"\nwith no additional text. Replace each placeholder with the computed float.",
            "solution": "We begin from the Discontinuous Galerkin (DG) semi-discretization of the linear advection equation using piecewise constants and upwind flux on a two-cell periodic mesh. Let the advection speed be $a$, the fine cell size be $\\Delta x_f$, and the coarse cell size be $\\Delta x_c$. With piecewise constants, the standard upwind DG flux for $a>0$ gives the semi-discrete evolution for the two cell averages $u_f$ and $u_c$:\n$$\n\\frac{d}{dt} u_f = -\\frac{a}{\\Delta x_f} u_f + \\frac{a}{\\Delta x_f} u_c, \\quad\n\\frac{d}{dt} u_c = \\frac{a}{\\Delta x_c} u_f - \\frac{a}{\\Delta x_c} u_c,\n$$\nwhich compactly writes as\n$$\n\\frac{d}{dt} \\begin{bmatrix} u_f \\\\ u_c \\end{bmatrix} = L \\begin{bmatrix} u_f \\\\ u_c \\end{bmatrix}, \\quad\nL = \\begin{bmatrix} -\\frac{a}{\\Delta x_f} & \\frac{a}{\\Delta x_f} \\\\ \\frac{a}{\\Delta x_c} & -\\frac{a}{\\Delta x_c} \\end{bmatrix}.\n$$\nThis linear constant-coefficient system is well-posed; one eigenvalue is $0$ (constant mode) and one is negative real, $-\\left(\\frac{a}{\\Delta x_f} + \\frac{a}{\\Delta x_c}\\right)$, hence the system is non-stiff for moderate time steps when using explicit integrators.\n\nFor a Local Time Stepping (LTS) configuration with step ratio $r=2$, we designate the fine partition to use step size $h$ and the coarse partition to use step size $H = 2h$. The multirate aspect means the fine partition advances in two micro-steps over one coarse macro-step. Because the right-hand sides are partitioned by rows of $L$, write\n$$\nf_f(t, u_f(\\cdot), u_c(\\cdot)) = L_{ff} u_f(t) + L_{fc} u_c(t), \\quad\nf_c(t, u_f(\\cdot), u_c(\\cdot)) = L_{cf} u_f(t) + L_{cc} u_c(t).\n$$\n\nTo define consistent multirate coupling with second-order accuracy, we approximate the coarse variable when needed by the fine partition at off-grid times via a degree-one extrapolant constructed from exact coarse values at two previous coarse time nodes $t=0$ and $t=-H$. Specifically, for any time $\\tau$ within the macro-step or slightly before it, define\n$$\n\\tilde{u}_c(\\tau) = u_c(0) + \\frac{\\tau}{H}\\left(u_c(0) - u_c(-H)\\right).\n$$\nThis is a linear polynomial in time reproducing the exact coarse solution at $t=0$ and $t=-H$ and extrapolating into $(0,H]$.\n\nThe local truncation error of a one-step propagator over a macro-step $H$ is defined by starting from the exact initial value at $t=0$, applying the numerical scheme for exactly one macro-step (using exact history whenever the scheme requires past data at $t<0$), and measuring the discrepancy with the exact solution at $t=H$:\n$$\n\\mathrm{LTE} = \\left\\| u(H) - u_{\\text{num}}(H) \\right\\|_2,\n$$\nwhere $u(H) = \\exp(HL) u(0)$, and $\\|\\cdot\\|_2$ denotes the Euclidean norm. When the scheme requires exact past values, we use $u(-h) = \\exp(-hL) u(0)$ and $u(-H) = \\exp(-HL) u(0)$.\n\nWe now specify the two multirate schemes.\n\n1. Multirate Adams-Bashforth of order two (MRAB2):\n   - Fine partition, first micro-step from $t=0$ to $t=h$:\n     The two-step Adams-Bashforth formula requires the right-hand sides at $t=0$ and $t=-h$. For the fine partition, we use\n     $$\n     k_f(0) = L_{ff} u_f(0) + L_{fc} \\tilde{u}_c(0) = L_{ff} u_f(0) + L_{fc} u_c(0),\n     $$\n     $$\n     k_f(-h) = L_{ff} u_f(-h) + L_{fc} \\tilde{u}_c(-h) = L_{ff} u_f(-h) + L_{fc}\\left(u_c(0) + \\frac{-h}{H}\\left(u_c(0) - u_c(-H)\\right)\\right).\n     $$\n     Then\n     $$\n     u_f(h) = u_f(0) + h\\left(\\frac{3}{2}k_f(0) - \\frac{1}{2} k_f(-h)\\right).\n     $$\n   - Fine partition, second micro-step from $t=h$ to $t=H$:\n     Now the two-step Adams-Bashforth uses the right-hand sides at $t=h$ and $t=0$, with the value at $t=h$ supplied by the previous micro-step:\n     $$\n     k_f(h) = L_{ff} u_f(h) + L_{fc} \\tilde{u}_c(h), \\quad k_f(0)\\text{ as above},\n     $$\n     $$\n     u_f(H) = u_f(h) + h\\left(\\frac{3}{2}k_f(h) - \\frac{1}{2}k_f(0)\\right).\n     $$\n   - Coarse partition, one macro-step $H$ using two-step Adams-Bashforth with exact past data:\n     $$\n     k_c(0) = L_{cf} u_f(0) + L_{cc} u_c(0), \\quad k_c(-H) = L_{cf} u_f(-H) + L_{cc} u_c(-H),\n     $$\n     $$\n     u_c(H) = u_c(0) + H\\left(\\frac{3}{2}k_c(0) - \\frac{1}{2} k_c(-H)\\right).\n     $$\n\n2. Multirate explicit second-order Runge-Kutta (Heun) with subcycling (MR-RK2):\n   - Fine partition, two micro-steps, each a Heun step with extrapolated coarse neighbor:\n     For a micro-step from $t_n$ to $t_{n+1} = t_n + h$,\n     $$\n     k_1 = L_{ff} u_f(t_n) + L_{fc} \\tilde{u}_c(t_n), \\quad u_f^{\\star} = u_f(t_n) + h\\,k_1,\n     $$\n     $$\n     k_2 = L_{ff} u_f^{\\star} + L_{fc} \\tilde{u}_c(t_{n+1}), \\quad u_f(t_{n+1}) = u_f(t_n) + \\frac{h}{2}(k_1 + k_2).\n     $$\n     Initialize with $u_f(0)$, apply once to get $u_f(h)$, then again to get $u_f(H)$ using $\\tilde{u}_c(h)$ and $\\tilde{u}_c(H)$ as needed.\n   - Coarse partition, one Heun macro-step:\n     $$\n     k_1 = L_{cf} u_f(0) + L_{cc} u_c(0), \\quad u_c^{\\star} = u_c(0) + H\\,k_1,\n     $$\n     $$ \n     k_2 = L_{cf} u_f(H) + L_{cc} u_c^{\\star}, \\quad u_c(H) = u_c(0) + \\frac{H}{2}(k_1 + k_2),\n     $$\n     where $u_f(H)$ is the fine value obtained from the two micro-steps.\n\nThese algorithmic prescriptions integrate the underlying scientific principles with the algorithmic design: the semi-discrete DG operator provides a linear system whose exact evolution is given by the matrix exponential, while the explicit multirate schemes employ subcycling and coupling via extrapolation or stage synchronization in a manner typical of Local Time Stepping.\n\nFor each test case, we proceed as follows:\n- Construct $L$ from $a$, $\\Delta x_f$, and $\\Delta x_c$.\n- Compute exact initial $u(0)$, exact past $u(-h)$ and $u(-H)$ by $u(-\\theta) = \\exp(-\\theta L) u(0)$.\n- Apply MRAB2 and MR-RK2 for one macro-step $H$ as defined above to obtain $u_{\\text{num}}(H)$ for each scheme.\n- Compute the exact $u(H) = \\exp(HL) u(0)$.\n- Compute $\\mathrm{LTE} = \\|u(H) - u_{\\text{num}}(H)\\|_2$ for each scheme.\n\nThe four test cases are:\n- Case A: $\\Delta x_f = 0.5$, $\\Delta x_c = 1.0$, $H = 0.2$, $u(0) = [1.0, -0.5]^T$.\n- Case B: $\\Delta x_f = 0.5$, $\\Delta x_c = 1.0$, $H = 0.05$, $u(0) = [1.0, -0.5]^T$.\n- Case C: $\\Delta x_f = 0.25$, $\\Delta x_c = 0.5$, $H = 0.05$, $u(0) = [0.3, -0.1]^T$.\n- Case D: $\\Delta x_f = 1.0$, $\\Delta x_c = 1.0$, $H = 0.1$, $u(0) = [1.0, 1.0]^T$.\n\nBecause the constant mode is an eigenvector with eigenvalue $0$, Case D should produce vanishing right-hand sides and hence essentially zero local truncation error up to roundoff, serving as an edge case. Cases A and B share geometry but use different $H$ values and therefore illustrate the second-order time-accuracy scaling of both schemes. Case C modifies mesh sizes, testing the sensitivity to different coupling strengths through $L$.\n\nFinally, aggregate the results into a single line printout of the list\n$$\n\\left[ [\\mathrm{LTE}_A^{\\text{AB2}}, \\mathrm{LTE}_A^{\\text{RK2}}], [\\mathrm{LTE}_B^{\\text{AB2}}, \\mathrm{LTE}_B^{\\text{RK2}}], [\\mathrm{LTE}_C^{\\text{AB2}}, \\mathrm{LTE}_C^{\\text{RK2}}], [\\mathrm{LTE}_D^{\\text{AB2}}, \\mathrm{LTE}_D^{\\text{RK2}}] \\right].\n$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef build_L(a, dx_f, dx_c):\n    \"\"\"Construct the 2x2 DG p=0 semi-discrete operator L for linear advection.\"\"\"\n    L = np.array([[-a/dx_f,  a/dx_f],\n                  [ a/dx_c, -a/dx_c]], dtype=float)\n    return L\n\ndef exact_state(L, t, u0):\n    \"\"\"Exact solution u(t) = exp(t L) u0.\"\"\"\n    return expm(t * L) @ u0\n\ndef coarse_extrap(u_c_0, u_c_minusH, tau, H):\n    \"\"\"Linear polynomial based on u_c(0) and u_c(-H), evaluated at time tau.\"\"\"\n    return u_c_0 + (tau / H) * (u_c_0 - u_c_minusH)\n\ndef mrab2_lts_one_macrostep(L, H, u0):\n    \"\"\"\n    One macro-step for MRAB2 with step ratio 2.\n    Fine partition index = 0, coarse = 1.\n    Fine uses two AB2 micro-steps with coarse extrapolation from t=0 and t=-H.\n    Coarse uses one AB2 macro-step with exact past values at t=0 and t=-H.\n    \"\"\"\n    h = H / 2.0\n    # Partitioned L entries\n    L_ff, L_fc = L[0, 0], L[0, 1]\n    L_cf, L_cc = L[1, 0], L[1, 1]\n\n    # Exact required history\n    u_exact_0 = u0.copy()\n    u_exact_minus_h = exact_state(L, -h, u0)\n    u_exact_minus_H = exact_state(L, -H, u0)\n\n    # Prepare coarse extrapolation values from exact coarse at 0 and -H\n    u_c_0 = u_exact_0[1]\n    u_c_minusH = u_exact_minus_H[1]\n\n    # Fine micro-step 1: from t=0 to t=h using AB2 with history at t=0 and t=-h\n    # k_f(0)\n    kf_0 = L_ff * u_exact_0[0] + L_fc * coarse_extrap(u_c_0, u_c_minusH, 0.0, H)\n    # k_f(-h)\n    kf_minus_h = L_ff * u_exact_minus_h[0] + L_fc * coarse_extrap(u_c_0, u_c_minusH, -h, H)\n    u_f_h = u_exact_0[0] + h * (1.5 * kf_0 - 0.5 * kf_minus_h)\n\n    # Fine micro-step 2: from t=h to t=H using AB2 with history at t=h (computed) and t=0\n    kf_h = L_ff * u_f_h + L_fc * coarse_extrap(u_c_0, u_c_minusH, h, H)\n    # k_f(0) already computed: kf_0\n    u_f_H = u_f_h + h * (1.5 * kf_h - 0.5 * kf_0)\n\n    # Coarse macro-step AB2: from t=0 to t=H using exact past values at 0 and -H\n    kc_0 = L_cf * u_exact_0[0] + L_cc * u_exact_0[1]\n    kc_minus_H = L_cf * u_exact_minus_H[0] + L_cc * u_exact_minus_H[1]\n    u_c_H = u_exact_0[1] + H * (1.5 * kc_0 - 0.5 * kc_minus_H)\n\n    return np.array([u_f_H, u_c_H], dtype=float)\n\ndef mrrk2_lts_one_macrostep(L, H, u0):\n    \"\"\"\n    One macro-step for MR-RK2 (Heun) with step ratio 2.\n    Fine partition: two Heun micro-steps with coarse extrapolation at needed times.\n    Coarse partition: one Heun step, with k2 using the fine solution at t=H produced by subcycling.\n    \"\"\"\n    h = H / 2.0\n    L_ff, L_fc = L[0, 0], L[0, 1]\n    L_cf, L_cc = L[1, 0], L[1, 1]\n\n    # Exact required history at t=0 and t=-H\n    u_exact_0 = u0.copy()\n    u_exact_minus_H = exact_state(L, -H, u0)\n\n    # Coarse extrapolation baseline\n    u_c_0 = u_exact_0[1]\n    u_c_minusH = u_exact_minus_H[1]\n\n    # Fine Heun micro-step 1: [0, h]\n    u_f_n = u_exact_0[0]\n    # k1 at t=0\n    k1 = L_ff * u_f_n + L_fc * coarse_extrap(u_c_0, u_c_minusH, 0.0, H)\n    u_f_star = u_f_n + h * k1\n    # k2 at t=h\n    k2 = L_ff * u_f_star + L_fc * coarse_extrap(u_c_0, u_c_minusH, h, H)\n    u_f_1 = u_f_n + 0.5 * h * (k1 + k2)\n\n    # Fine Heun micro-step 2: [h, H]\n    u_f_n2 = u_f_1\n    k1b = L_ff * u_f_n2 + L_fc * coarse_extrap(u_c_0, u_c_minusH, h, H)\n    u_f_star2 = u_f_n2 + h * k1b\n    k2b = L_ff * u_f_star2 + L_fc * coarse_extrap(u_c_0, u_c_minusH, H, H)\n    u_f_H = u_f_n2 + 0.5 * h * (k1b + k2b)\n\n    # Coarse Heun macro-step: [0, H]\n    # k1 at t=0 uses exact values\n    k1c = L_cf * u_exact_0[0] + L_cc * u_exact_0[1]\n    u_c_star = u_exact_0[1] + H * k1c\n    # k2 at t=H uses fine value from subcycling, and coarse stage value u_c_star\n    k2c = L_cf * u_f_H + L_cc * u_c_star\n    u_c_H = u_exact_0[1] + 0.5 * H * (k1c + k2c)\n\n    return np.array([u_f_H, u_c_H], dtype=float)\n\ndef compute_lte(L, H, u0, scheme_func):\n    \"\"\"Compute local truncation error norm-2 for one macro-step for the provided scheme.\"\"\"\n    u_exact_H = exact_state(L, H, u0)\n    u_num_H = scheme_func(L, H, u0)\n    return float(np.linalg.norm(u_exact_H - u_num_H, ord=2))\n\ndef solve():\n    # Advection speed\n    a = 1.0\n\n    # Test cases: (dx_f, dx_c, H, u0_vector)\n    test_cases = [\n        (0.5, 1.0, 0.2,  np.array([1.0, -0.5], dtype=float)),  # Case A\n        (0.5, 1.0, 0.05, np.array([1.0, -0.5], dtype=float)),  # Case B\n        (0.25, 0.5, 0.05, np.array([0.3, -0.1], dtype=float)), # Case C\n        (1.0, 1.0, 0.1,  np.array([1.0, 1.0], dtype=float)),   # Case D (constant mode)\n    ]\n\n    results = []\n    for dx_f, dx_c, H, u0 in test_cases:\n        L = build_L(a, dx_f, dx_c)\n        lte_mrab2 = compute_lte(L, H, u0, mrab2_lts_one_macrostep)\n        lte_mrrk2 = compute_lte(L, H, u0, mrrk2_lts_one_macrostep)\n        results.append([lte_mrab2, lte_mrrk2])\n\n    # Final print statement in the exact required format.\n    # Ensure a single line with Python-list-like formatting.\n    # Convert to string with default float formatting.\n    print(\"[\" + \",\".join(\"[\" + \",\".join(str(x) for x in pair) + \"]\" for pair in results) + \"]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Applying local time stepping to physical models with source terms, such as the shallow water equations, can reveal subtle but critical challenges. Many such systems exhibit important physical equilibria, or \"well-balanced\" states, which a robust numerical scheme must preserve. This advanced practice first asks you to demonstrate how a naive LTS implementation can break such an equilibrium due to inconsistent time integration of flux and source terms , before guiding you to engineer a corrected time quadrature that restores this crucial property.",
            "id": "3396698",
            "problem": "Consider the one-dimensional shallow water equations linearized about a quiescent state of constant mean depth $H>0$ over a stationary bed $b(x)$,\n$$\n\\eta_{t} + m_{x} = 0,\\qquad m_{t} + g H\\, \\eta_{x} = - g H\\, b_{x},\n$$\nwhere $\\eta(x,t)$ is the free-surface elevation relative to $H$, $m(x,t)$ is the discharge, and $g$ is gravitational acceleration. The lake-at-rest equilibrium is defined by $m(x,t)\\equiv 0$ and $\\eta(x,t) + b(x) \\equiv \\text{const}$, which is a steady solution of the partial differential equations.\n\nDiscretize this system by a piecewise-constant Discontinuous Galerkin (DG) method on two adjacent cells $K_{L}$ and $K_{R}$ with a shared interface at $x_{1/2}$. Assume a spatially well-balanced semi-discretization so that the semi-discrete residual vanishes for the lake-at-rest equilibrium. Now apply explicit time integration with Local Time Stepping (LTS): the left cell $K_{L}$ advances with a macro-step of size $\\Delta>0$, while the right cell $K_{R}$ subcycles with three equal substeps of size $\\Delta/3$. Denote the midpoints of the three substeps by $t_{1}=\\Delta/6$, $t_{2}=\\Delta/2$, and $t_{3}=5\\Delta/6$.\n\nAt the shared interface, let the (right-going) numerical momentum flux contribution entering $K_{L}$ be represented, due to a local in-time predictor used on $K_{R}$, by a quadratic-in-time dependence over $[0,\\Delta]$,\n$$\nF(t)\\;=\\;A + B\\, t + C\\, t^{2},\n$$\nwith constants $A$, $B$, and $C$ (independent of $t$ over $[0,\\Delta]$). In exact lake-at-rest conditions, cancellation with the bed-slope source term over $K_{L}$ requires that the time integral of $F(t)$ over $[0,\\Delta]$ matches the time integral of the (equally quadratic) source term contribution $S(t)$, but a naive LTS coupling uses mismatched time quadratures:\n- For the face flux entering $K_{L}$, the slow cell naively consumes an equal-weight average of the three fast substep flux values, i.e., it uses the composite rectangle rule $\\frac{\\Delta}{3}\\sum_{k=1}^{3}F(t_{k})$.\n- For the bed-slope source in $K_{L}$, the slow cell uses a single-stage midpoint rule $\\Delta\\, S(t_{2})$.\n\nAssume $S(t)\\equiv F(t)$ for $t\\in[0,\\Delta]$ to reflect the well-balanced target at the continuum level. Starting from $m\\equiv 0$ at $t=0$, the naive LTS update of $m$ over $K_{L}$ will, in general, not remain zero. First, present a steady-state counterexample by computing the spurious net update\n$$\n\\Delta m_{L}^{\\text{naive}} \\;=\\; \\frac{\\Delta}{\\Delta x}\\left(\\frac{\\Delta}{3}\\sum_{k=1}^{3}F(t_{k}) \\;-\\; \\Delta\\, F(t_{2})\\right),\n$$\nexpressed in terms of the coefficient $C$ and the time step $\\Delta$ (you may regard $\\Delta x>0$ as a constant scaling factor and extract the factor $1/\\Delta x$), thereby showing explicitly that the naive LTS breaks the lake-at-rest equilibrium when $C\\neq 0$.\n\nNext, to fix the imbalance without altering substep times $\\{t_{k}\\}_{k=1}^{3}$, design a face-and-source time quadrature on the slow cell $K_{L}$ supported at the same nodes $\\{t_{1},t_{2},t_{3}\\}$ with weights $\\{w_{1},w_{2},w_{3}\\}$ such that, for any quadratic polynomial in time $Q(t)=\\alpha+\\beta t+\\gamma t^{2}$, the quadrature\n$$\n\\Delta \\sum_{k=1}^{3} w_{k}\\, Q(t_{k})\n$$\nis exactly equal to the exact time integral $\\int_{0}^{\\Delta} Q(t)\\, dt$. This condition enforces exact cancellation of face and source contributions for any quadratic-in-time $F(t)$ and $S(t)$, thereby restoring the discrete well-balanced property under the given LTS.\n\nCompute the exact weights $\\{w_{1},w_{2},w_{3}\\}$ as rational numbers. Report your final answer as the row vector $\\bigl(w_{1},\\,w_{2},\\,w_{3}\\bigr)$, written in exact fractional form. No rounding is required, and no physical units are to be included in the final answer.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It poses a standard question in the numerical analysis of partial differential equations, specifically concerning well-balanced schemes under local time stepping. The prompt contains all necessary information to proceed.\n\nThe problem consists of two parts. First, we must demonstrate that a naive Local Time Stepping (LTS) scheme breaks the lake-at-rest-preserving (well-balanced) property. Second, we must compute a set of quadrature weights that restore this property.\n\nPart 1: Spurious update in the naive LTS scheme.\n\nThe problem asks to compute the spurious net update $\\Delta m_{L}^{\\text{naive}}$ given by the formula:\n$$\n\\Delta m_{L}^{\\text{naive}} = \\frac{\\Delta}{\\Delta x}\\left(\\frac{\\Delta}{3}\\sum_{k=1}^{3}F(t_{k}) - \\Delta F(t_{2})\\right)\n$$\nWe are given $F(t) = A + B t + C t^2$ and the quadrature points $t_1 = \\frac{\\Delta}{6}$, $t_2 = \\frac{\\Delta}{2}$, and $t_3 = \\frac{5\\Delta}{6}$. We need to compute the term in the parenthesis, which represents the difference between the two naive quadrature approximations of the time integral. Let's call this difference $E_{quad}$.\n$$\nE_{quad} = \\frac{\\Delta}{3}\\sum_{k=1}^{3}F(t_{k}) - \\Delta F(t_{2})\n$$\nFirst, we evaluate $F(t)$ at the given time points:\n$F(t_1) = A + B\\left(\\frac{\\Delta}{6}\\right) + C\\left(\\frac{\\Delta}{6}\\right)^2 = A + \\frac{B\\Delta}{6} + \\frac{C\\Delta^2}{36}$\n$F(t_2) = A + B\\left(\\frac{\\Delta}{2}\\right) + C\\left(\\frac{\\Delta}{2}\\right)^2 = A + \\frac{B\\Delta}{2} + \\frac{C\\Delta^2}{4}$\n$F(t_3) = A + B\\left(\\frac{5\\Delta}{6}\\right) + C\\left(\\frac{5\\Delta}{6}\\right)^2 = A + \\frac{5B\\Delta}{6} + \\frac{25C\\Delta^2}{36}$\n\nNext, we compute the sum required for the composite rectangle rule:\n$$\n\\sum_{k=1}^{3}F(t_{k}) = (A+A+A) + B\\Delta\\left(\\frac{1}{6}+\\frac{3}{6}+\\frac{5}{6}\\right) + C\\Delta^2\\left(\\frac{1}{36}+\\frac{9}{36}+\\frac{25}{36}\\right)\n$$\n$$\n\\sum_{k=1}^{3}F(t_{k}) = 3A + B\\Delta\\left(\\frac{9}{6}\\right) + C\\Delta^2\\left(\\frac{35}{36}\\right) = 3A + \\frac{3}{2}B\\Delta + \\frac{35}{36}C\\Delta^2\n$$\nThe first quadrature term is:\n$$\n\\frac{\\Delta}{3}\\sum_{k=1}^{3}F(t_{k}) = \\frac{\\Delta}{3}\\left(3A + \\frac{3}{2}B\\Delta + \\frac{35}{36}C\\Delta^2\\right) = A\\Delta + \\frac{1}{2}B\\Delta^2 + \\frac{35}{108}C\\Delta^3\n$$\nThe second quadrature term is:\n$$\n\\Delta F(t_2) = \\Delta\\left(A + \\frac{B\\Delta}{2} + \\frac{C\\Delta^2}{4}\\right) = A\\Delta + \\frac{1}{2}B\\Delta^2 + \\frac{1}{4}C\\Delta^3\n$$\nNow we compute the difference $E_{quad}$:\n$$\nE_{quad} = \\left(A\\Delta + \\frac{1}{2}B\\Delta^2 + \\frac{35}{108}C\\Delta^3\\right) - \\left(A\\Delta + \\frac{1}{2}B\\Delta^2 + \\frac{1}{4}C\\Delta^3\\right)\n$$\nThe terms with coefficients $A$ and $B$ cancel out, as both quadrature rules are exact for constant and linear functions over $[0, \\Delta]$ (the composite midpoint rule is exact for linear functions, and the single midpoint rule is also exact for linear functions over the interval). The error arises from the quadratic term:\n$$\nE_{quad} = \\left(\\frac{35}{108} - \\frac{1}{4}\\right)C\\Delta^3 = \\left(\\frac{35}{108} - \\frac{27}{108}\\right)C\\Delta^3 = \\frac{8}{108}C\\Delta^3 = \\frac{2}{27}C\\Delta^3\n$$\nSubstituting this into the expression for the spurious update:\n$$\n\\Delta m_{L}^{\\text{naive}} = \\frac{\\Delta}{\\Delta x} E_{quad} = \\frac{\\Delta}{\\Delta x} \\left(\\frac{2}{27}C\\Delta^3\\right) = \\frac{2 C \\Delta^4}{27 \\Delta x}\n$$\nThis expression is non-zero if $C \\neq 0$. Since the momentum in cell $K_L$ was initially zero, this non-zero update $\\Delta m_L^{\\text{naive}}$ demonstrates that the naive LTS coupling breaks the well-balanced property for the lake-at-rest state when the temporal dependency of the flux and source terms has a non-zero quadratic component.\n\nPart 2: Design of a well-balanced quadrature.\n\nTo restore the well-balanced property, we need a single quadrature rule for both flux and source terms that is exact for any quadratic polynomial in time. Let the quadrature be defined by weights $\\{w_1, w_2, w_3\\}$ at nodes $\\{t_1, t_2, t_3\\}$. The condition is:\n$$\n\\int_{0}^{\\Delta} Q(t)\\, dt = \\Delta \\sum_{k=1}^{3} w_{k}\\, Q(t_{k})\n$$\nfor any polynomial $Q(t) = \\alpha + \\beta t + \\gamma t^2$. By linearity, it is sufficient to enforce this condition for the basis polynomials $Q(t)=1$, $Q(t)=t$, and $Q(t)=t^2$.\n\n1. For $Q(t)=1$:\n$\\int_0^\\Delta 1\\, dt = \\Delta$. The quadrature gives $\\Delta(w_1 \\cdot 1 + w_2 \\cdot 1 + w_3 \\cdot 1)$.\nThis yields our first equation:\n$$w_1 + w_2 + w_3 = 1$$\n\n2. For $Q(t)=t$:\n$\\int_0^\\Delta t\\, dt = \\frac{\\Delta^2}{2}$. The quadrature gives $\\Delta(w_1 t_1 + w_2 t_2 + w_3 t_3)$.\nSubstituting $t_1=\\frac{\\Delta}{6}$, $t_2=\\frac{\\Delta}{2}$, $t_3=\\frac{5\\Delta}{6}$:\n$\\frac{\\Delta^2}{2} = \\Delta\\left(w_1\\frac{\\Delta}{6} + w_2\\frac{\\Delta}{2} + w_3\\frac{5\\Delta}{6}\\right) = \\frac{\\Delta^2}{6}(w_1 + 3w_2 + 5w_3)$.\nThis yields our second equation:\n$$w_1 + 3w_2 + 5w_3 = 3$$\n\n3. For $Q(t)=t^2$:\n$\\int_0^\\Delta t^2\\, dt = \\frac{\\Delta^3}{3}$. The quadrature gives $\\Delta(w_1 t_1^2 + w_2 t_2^2 + w_3 t_3^2)$.\nSubstituting the squares of the nodes $t_1^2=\\frac{\\Delta^2}{36}$, $t_2^2=\\frac{\\Delta^2}{4}$, $t_3^2=\\frac{25\\Delta^2}{36}$:\n$\\frac{\\Delta^3}{3} = \\Delta\\left(w_1\\frac{\\Delta^2}{36} + w_2\\frac{\\Delta^2}{4} + w_3\\frac{25\\Delta^2}{36}\\right) = \\frac{\\Delta^3}{36}(w_1 + 9w_2 + 25w_3)$.\nThis yields our third equation:\n$$w_1 + 9w_2 + 25w_3 = 12$$\n\nWe now solve the linear system for $(w_1, w_2, w_3)$:\n(1) $w_1 + w_2 + w_3 = 1$\n(2) $w_1 + 3w_2 + 5w_3 = 3$\n(3) $w_1 + 9w_2 + 25w_3 = 12$\n\nSubtracting (1) from (2):\n$(3-1)w_2 + (5-1)w_3 = 3-1 \\implies 2w_2 + 4w_3 = 2 \\implies w_2 + 2w_3 = 1$ (4)\n\nSubtracting (2) from (3):\n$(9-3)w_2 + (25-5)w_3 = 12-3 \\implies 6w_2 + 20w_3 = 9$ (5)\n\nNow we solve the $2 \\times 2$ system for $w_2$ and $w_3$. From (4), we have $w_2 = 1 - 2w_3$. Substituting this into (5):\n$6(1-2w_3) + 20w_3 = 9$\n$6 - 12w_3 + 20w_3 = 9$\n$8w_3 = 3 \\implies w_3 = \\frac{3}{8}$\n\nNow we find $w_2$:\n$w_2 = 1 - 2w_3 = 1 - 2\\left(\\frac{3}{8}\\right) = 1 - \\frac{6}{8} = 1 - \\frac{3}{4} = \\frac{1}{4}$\n\nFinally, we find $w_1$ using (1):\n$w_1 = 1 - w_2 - w_3 = 1 - \\frac{1}{4} - \\frac{3}{8} = \\frac{8-2-3}{8} = \\frac{3}{8}$\n\nThe required weights are $(w_1, w_2, w_3) = \\left(\\frac{3}{8}, \\frac{1}{4}, \\frac{3}{8}\\right)$.\nWith this choice of weights, the time integral approximation is exact for any quadratic polynomial. Therefore, if $S(t) \\equiv F(t)$, the numerical integrals for the flux and source will be identical, ensuring their cancellation in the momentum update and restoring the well-balanced property for the LTS scheme.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{3}{8} & \\frac{1}{4} & \\frac{3}{8}\n\\end{pmatrix}\n}\n$$"
        }
    ]
}