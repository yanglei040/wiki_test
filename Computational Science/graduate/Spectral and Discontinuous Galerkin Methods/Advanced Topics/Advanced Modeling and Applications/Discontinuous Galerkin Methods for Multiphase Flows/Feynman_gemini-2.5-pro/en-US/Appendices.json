{
    "hands_on_practices": [
        {
            "introduction": "A critical requirement in multiphase flow simulation is ensuring that physical quantities, such as the volume fraction $\\alpha$, remain within their valid range (e.g., $0 \\le \\alpha \\le 1$). This hands-on exercise  addresses the common issue of non-physical oscillations in high-order Discontinuous Galerkin schemes by having you implement and test a bound-preserving limiter. You will gain practical experience in making a DG scheme robust while analyzing its impact on the fundamental property of mass conservation.",
            "id": "3380118",
            "problem": "Consider the one-dimensional conservative transport of a volume fraction field $\\alpha(x,t)$ satisfying the scalar linear advection equation $\\partial_t \\alpha + u \\,\\partial_x \\alpha = 0$ on the periodic domain $x \\in [0,1]$ with constant velocity $u \\in \\mathbb{R}$. The volume fraction is physically bounded by $0 \\le \\alpha \\le 1$. Discretize the domain into $N$ uniform cells of width $\\Delta x = 1/N$. Within each cell, approximate $\\alpha(x,t)$ using a degree-$1$ discontinuous Galerkin (DG) polynomial in the local reference coordinate $\\xi \\in [-1,1]$, mapped as $x = x_i + (\\Delta x/2)\\,\\xi$, and represented as $\\alpha_i(\\xi,t) = a_{0,i}(t) + a_{1,i}(t)\\xi$, where $a_{0,i}$ is the cell average and $a_{1,i}$ is the slope coefficient.\n\nStarting from the conservation law and the definition of the DG weak form with an upwind numerical flux, derive from first principles the semi-discrete system for the modal coefficients $\\{a_{0,i},a_{1,i}\\}$ for each cell. Use the basis $\\{\\phi_0(\\xi)=1,\\phi_1(\\xi)=\\xi\\}$ and the exact $L^2$ inner products on each element. Then, implement a single explicit forward Euler time step of size $\\Delta t$, with $\\Delta t$ constrained by a Courant-Friedrichs-Lewy (CFL) number $\\mathrm{CFL} \\in (0,1)$ via $\\Delta t = \\mathrm{CFL}\\,\\Delta x/|u|$ when $|u| \\ne 0$; if $|u|=0$, use $\\Delta t=0$. Take the upwind numerical flux for the face value: at an interface, if $u>0$ the upwind state is the value from the left cell, and if $u<0$ the upwind state is the value from the right cell.\n\nAfter advancing one time step without any limiting (the \"unlimited\" update), apply a bound-preserving limiter based on scaling with respect to the cell average to enforce the bounds at the cell faces (which, in one spatial dimension, coincide with face averages). Specifically, for each cell $i$, compute the interior face values $\\alpha_{i}^{L+} = a_{0,i} - a_{1,i}$ and $\\alpha_{i}^{R-} = a_{0,i} + a_{1,i}$ after the unlimited update. Define the lower and upper physical bounds $m=0$ and $M=1$. Set\n$$\n\\theta_i \\;=\\; \\min\\left\\{1,\\; \\frac{a_{0,i}-m}{a_{0,i}-\\min(\\alpha_{i}^{L+},\\alpha_{i}^{R-})}\\;\\text{ if } a_{0,i}>\\min(\\alpha_{i}^{L+},\\alpha_{i}^{R-}),\\; \\frac{M-a_{0,i}}{\\max(\\alpha_{i}^{L+},\\alpha_{i}^{R-})-a_{0,i}}\\;\\text{ if } a_{0,i}<\\max(\\alpha_{i}^{L+},\\alpha_{i}^{R-})\\right\\},\n$$\nwith the convention that any fraction with a non-positive denominator is ignored and replaced by $1$. Then set the limited slope $a_{1,i}^{\\mathrm{lim}} = \\theta_i\\, a_{1,i}$ while keeping the cell average unchanged, $a_{0,i}^{\\mathrm{lim}}=a_{0,i}$. This limiter is designed to preserve the cell average while enforcing the bounds $m \\le \\alpha \\le M$ at the faces.\n\nDefine the total mass at time $t^n$ as $M^n = \\sum_{i=1}^{N} a_{0,i}^n \\,\\Delta x$. For a single time step from $t^0$ to $t^1=t^0+\\Delta t$, quantify the global mass conservation error as the absolute change in total mass, $E = |M^1 - M^0|$. Compute and report the error for both the unlimited and the limited updates.\n\nYour program must implement the described method and produce outputs for the following test suite. Each test case is defined by $(N,u,\\mathrm{CFL},\\alpha_0(x))$:\n- Test A (happy path, smooth bounded): $N=40$, $u=1$, $\\mathrm{CFL}=0.20$, $\\alpha_0(x) = 0.5 + 0.49 \\sin(2\\pi x)$.\n- Test B (discontinuity, potential face overshoots): $N=40$, $u=1$, $\\mathrm{CFL}=0.30$, $\\alpha_0(x) = 1$ for $x<0.5$, and $\\alpha_0(x)=0$ for $x \\ge 0.5$.\n- Test C (edge case, single element periodic): $N=1$, $u=0.7$, $\\mathrm{CFL}=0.20$, $\\alpha_0(x) = 0.3 + 0.2 \\cos(2\\pi x)$.\n- Test D (negative velocity): $N=30$, $u=-1$, $\\mathrm{CFL}=0.25$, $\\alpha_0(x) = 0.5 + 0.49 \\sin(4\\pi x)$.\n\nAdditional requirements:\n- For each test case, perform exactly one forward Euler time step from $t^0$ to $t^1$.\n- Use the exact $L^2$ projection to initialize $\\{a_{0,i},a_{1,i}\\}$ from $\\alpha_0(x)$ by numerical integration with adequate Gaussian quadrature to resolve the given initial condition.\n- Report two floating-point numbers for each test case: the unlimited mass error $E_{\\mathrm{unlim}}$ and the limited mass error $E_{\\mathrm{lim}}$, each expressed as a real number.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to a test case and is itself a two-element list $[E_{\\mathrm{unlim}},E_{\\mathrm{lim}}]$. Use scientific notation with $12$ significant digits for each floating-point value. For example, an output for two hypothetical test cases would look like `[[1.234000000000e-12,1.234000000000e-12],[5.678000000000e-14,5.678000000000e-14]]`.",
            "solution": "The user has provided a well-posed problem in computational physics, specifically concerning the numerical solution of the one-dimensional linear advection equation using a discontinuous Galerkin (DG) method. The problem is scientifically grounded, requires the derivation and implementation of a standard numerical scheme, and includes all necessary parameters and definitions. The problem is valid and I will proceed with a full solution.\n\n### 1. Derivation of the Semi-Discrete DG Formulation\n\nThe governing equation is the scalar linear advection equation for a volume fraction field $\\alpha(x,t)$:\n$$\n\\partial_t \\alpha + u \\,\\partial_x \\alpha = 0\n$$\non a periodic domain $x \\in [0,1]$ with a constant velocity $u$.\n\nThe domain is discretized into $N$ cells $I_i = [x_{i-1/2}, x_{i+1/2}]$ of uniform width $\\Delta x = 1/N$. Within each cell, the solution $\\alpha(x,t)$ is approximated by a degree-1 polynomial $\\alpha_i(\\xi, t)$, where $\\xi \\in [-1,1]$ is the local reference coordinate defined by the mapping $x(\\xi) = x_i + (\\Delta x/2)\\xi$, with $x_i$ being the cell center. The approximation is:\n$$\n\\alpha_i(\\xi,t) = a_{0,i}(t)\\phi_0(\\xi) + a_{1,i}(t)\\phi_1(\\xi) = a_{0,i}(t) + a_{1,i}(t)\\xi\n$$\nusing the orthogonal basis functions $\\phi_0(\\xi)=1$ and $\\phi_1(\\xi)=\\xi$.\n\nTo derive the weak form, we multiply the PDE by a test function $\\phi_k(\\xi)$ and integrate over cell $I_i$:\n$$\n\\int_{I_i} (\\partial_t \\alpha_i) \\phi_k \\,dx + \\int_{I_i} u (\\partial_x \\alpha_i) \\phi_k \\,dx = 0\n$$\nTransforming to the reference coordinate $\\xi$ (with $dx = (\\Delta x/2)d\\xi$ and $\\partial_x = (2/\\Delta x)\\partial_\\xi$), we obtain:\n$$\n\\frac{\\Delta x}{2} \\int_{-1}^1 (\\partial_t \\alpha_i) \\phi_k \\,d\\xi + \\frac{\\Delta x}{2} \\int_{-1}^1 u \\left(\\frac{2}{\\Delta x}\\partial_\\xi \\alpha_i\\right) \\phi_k \\,d\\xi = 0\n$$\nApplying integration by parts to the spatial term gives:\n$$\n\\int_{-1}^1 u (\\partial_\\xi \\alpha_i) \\phi_k \\,d\\xi = \\left[ u \\, \\alpha_i \\phi_k \\right]_{-1}^{1} - \\int_{-1}^1 u \\alpha_i (\\partial_\\xi \\phi_k) \\,d\\xi\n$$\nThe boundary term $\\left[ u \\, \\alpha_i \\phi_k \\right]_{-1}^{1}$ is replaced by a numerical flux term evaluated at the cell faces. The flux $u\\alpha$ is represented by $u\\hat{\\alpha}$, where $\\hat{\\alpha}$ is the numerical flux for $\\alpha$. The term becomes $u(\\hat{\\alpha}_{i+1/2}\\phi_k(1) - \\hat{\\alpha}_{i-1/2}\\phi_k(-1))$, where $\\hat{\\alpha}_{i\\pm1/2}$ represents the numerical flux at the right/left faces of cell $i$.\n\nThe semi-discrete weak form is then:\n$$\n\\frac{\\Delta x}{2} \\int_{-1}^1 (\\partial_t \\alpha_i) \\phi_k \\,d\\xi + u(\\hat{\\alpha}_{i+1/2}\\phi_k(1) - \\hat{\\alpha}_{i-1/2}\\phi_k(-1)) - u \\int_{-1}^1 \\alpha_i (\\partial_\\xi \\phi_k) \\,d\\xi = 0\n$$\nSubstituting $\\alpha_i = a_{0,i}\\phi_0 + a_{1,i}\\phi_1$ and evaluating for $k=0,1$:\n\n**For $k=0$ (test function $\\phi_0 = 1$):**\n$\\phi_0(1)=1, \\phi_0(-1)=1, \\partial_\\xi\\phi_0=0$.\n$$\n\\frac{\\Delta x}{2} \\frac{d a_{0,i}}{dt} \\int_{-1}^1 \\phi_0^2 \\,d\\xi + u(\\hat{\\alpha}_{i+1/2} - \\hat{\\alpha}_{i-1/2}) - 0 = 0\n$$\nWith $\\int_{-1}^1 \\phi_0^2 \\,d\\xi = 2$, this simplifies to:\n$$\n\\Delta x \\frac{d a_{0,i}}{dt} = -u (\\hat{\\alpha}_{i+1/2} - \\hat{\\alpha}_{i-1/2})\n$$\n\n**For $k=1$ (test function $\\phi_1 = \\xi$):**\n$\\phi_1(1)=1, \\phi_1(-1)=-1, \\partial_\\xi\\phi_1=1$.\n$$\n\\frac{\\Delta x}{2} \\frac{d a_{1,i}}{dt} \\int_{-1}^1 \\phi_1^2 \\,d\\xi + u(\\hat{\\alpha}_{i+1/2} - \\hat{\\alpha}_{i-1/2}(-1)) - u \\int_{-1}^1 (a_{0,i}\\phi_0+a_{1,i}\\phi_1)(\\partial_\\xi \\phi_1) \\,d\\xi = 0\n$$\nWith $\\int_{-1}^1 \\phi_1^2 \\,d\\xi = 2/3$ and $\\int_{-1}^1 (a_{0,i}+a_{1,i}\\xi)(1) \\,d\\xi=2a_{0,i}$:\n$$\n\\frac{\\Delta x}{3} \\frac{d a_{1,i}}{dt} + u(\\hat{\\alpha}_{i+1/2} + \\hat{\\alpha}_{i-1/2}) - 2ua_{0,i} = 0\n$$\nThis gives the ODE for the slope coefficient:\n$$\n\\frac{\\Delta x}{3} \\frac{d a_{1,i}}{dt} = -u (\\hat{\\alpha}_{i+1/2} + \\hat{\\alpha}_{i-1/2} - 2a_{0,i})\n$$\n\n### 2. Numerical Flux and Time-Stepping\n\nThe problem specifies an upwind flux. At an interface $x_{i+1/2}$ between cells $i$ and $i+1$, the solution has two values: $\\alpha_{i+1/2}^- = \\alpha_i(\\xi=1) = a_{0,i} + a_{1,i}$ from the left, and $\\alpha_{i+1/2}^+ = \\alpha_{i+1}(\\xi=-1) = a_{0,i+1} - a_{1,i+1}$ from the right. The upwind flux is:\n$$\n\\hat{\\alpha}_{i+1/2} = \\begin{cases} \\alpha_{i+1/2}^- & \\text{if } u > 0 \\\\ \\alpha_{i+1/2}^+ & \\text{if } u < 0 \\end{cases}\n$$\nThe same logic applies to the interface $x_{i-1/2}$. We use an explicit forward Euler scheme for time integration:\n$$\n\\mathbf{a}_i^{n+1} = \\mathbf{a}_i^n + \\Delta t \\cdot \\frac{d\\mathbf{a}_i^n}{dt}, \\quad \\text{where } \\mathbf{a}_i = (a_{0,i}, a_{1,i})^T\n$$\nThe time step is $\\Delta t = \\mathrm{CFL}\\,\\Delta x/|u|$. This leads to the update formulas:\n$$\na_{0,i}^{n+1} = a_{0,i}^n - \\frac{u\\Delta t}{\\Delta x} (\\hat{\\alpha}_{i+1/2}^n - \\hat{\\alpha}_{i-1/2}^n)\n$$\n$$\na_{1,i}^{n+1} = a_{1,i}^n - \\frac{3u\\Delta t}{\\Delta x} (\\hat{\\alpha}_{i+1/2}^n + \\hat{\\alpha}_{i-1/2}^n - 2a_{0,i}^n)\n$$\nwhere the superscript $n$ denotes values at time $t^n$.\n\n### 3. Initialization by $L^2$ Projection\n\nThe initial coefficients $\\{a_{0,i}^0, a_{1,i}^0\\}$ are determined by an $L^2$ projection of the initial condition $\\alpha_0(x)$ onto the DG basis space in each cell:\n$$\n\\int_{I_i} \\alpha_i(\\xi,0)\\phi_k(\\xi) \\,dx = \\int_{I_i} \\alpha_0(x)\\phi_k(\\xi) \\,dx \\quad \\text{for } k=0,1\n$$\nDue to the orthogonality of the basis on $[-1,1]$, this yields explicit formulas for the coefficients:\n$$\na_{0,i}^0 = \\frac{\\int_{-1}^1 \\alpha_0(x(\\xi)) \\,d\\xi}{\\int_{-1}^1 \\phi_0^2 \\,d\\xi} = \\frac{1}{2} \\int_{-1}^1 \\alpha_0(x_i + \\frac{\\Delta x}{2}\\xi) \\,d\\xi\n$$\n$$\na_{1,i}^0 = \\frac{\\int_{-1}^1 \\alpha_0(x(\\xi))\\xi \\,d\\xi}{\\int_{-1}^1 \\phi_1^2 \\,d\\xi} = \\frac{3}{2} \\int_{-1}^1 \\alpha_0(x_i + \\frac{\\Delta x}{2}\\xi) \\xi \\,d\\xi\n$$\nThese integrals are computed using high-order Gaussian quadrature for smooth $\\alpha_0(x)$ or analytically for piecewise constant cases.\n\n### 4. Bound-Preserving Limiter\n\nAfter the unlimited forward Euler step, which yields coefficients $a_{0,i}^{\\mathrm{unlim}}$ and $a_{1,i}^{\\mathrm{unlim}}$, a bound-preserving limiter is applied. This limiter ensures that the polynomial values at the cell faces, $\\alpha_{i}^{L+} = a_{0,i} - a_{1,i}$ and $\\alpha_{i}^{R-} = a_{0,i} + a_{1,i}$, remain within the physical bounds $[m, M] = [0, 1]$. The limiter preserves the cell average $a_{0,i}$ while scaling the slope $a_{1,i}$ by a factor $\\theta_i \\in [0,1]$.\n$$\na_{0,i}^{\\mathrm{lim}} = a_{0,i}^{\\mathrm{unlim}}, \\quad a_{1,i}^{\\mathrm{lim}} = \\theta_i a_{1,i}^{\\mathrm{unlim}}\n$$\nwhere $\\theta_i$ is computed as:\n$$\n\\theta_i \\;=\\; \\min\\left(1,\\; R_1, \\; R_2 \\right)\n$$\nwith\n$$\nR_1 = \\begin{cases} \\frac{a_{0,i}-m}{a_{0,i}-\\min(\\alpha_{i}^{L+},\\alpha_{i}^{R-})} & \\text{if } a_{0,i}>\\min(\\alpha_{i}^{L+},\\alpha_{i}^{R-}) \\\\ 1 & \\text{otherwise} \\end{cases}\n$$\n$$\nR_2 = \\begin{cases} \\frac{M-a_{0,i}}{\\max(\\alpha_{i}^{L+},\\alpha_{i}^{R-})-a_{0,i}} & \\text{if } a_{0,i}<\\max(\\alpha_{i}^{L+},\\alpha_{i}^{R-}) \\\\ 1 & \\text{otherwise} \\end{cases}\n$$\nHere, $a_{0,i}, \\alpha_{i}^{L+}, \\alpha_{i}^{R-}$ refer to the values from the unlimited update.\n\n### 5. Mass Conservation Analysis\n\nThe total mass at time $t^n$ is $M^n = \\sum_{i=1}^{N} a_{0,i}^n \\,\\Delta x$. The global mass conservation error after one time step is $E = |M^1 - M^0|$.\nFrom the semi-discrete equation for the cell average, the rate of change of total mass is:\n$$\n\\frac{dM}{dt} = \\sum_{i=1}^N \\Delta x \\frac{da_{0,i}}{dt} = \\sum_{i=1}^N -u(\\hat{\\alpha}_{i+1/2} - \\hat{\\alpha}_{i-1/2})\n$$\nDue to the periodic boundary conditions, this sum is a telescoping series that evaluates to exactly zero. Thus, the semi-discrete DG scheme is exactly mass-conservative.\nThe forward Euler time-step preserves this property algebraically:\n$$\nM^1 - M^0 = \\sum_{i=1}^N \\Delta x (a_{0,i}^1 - a_{0,i}^0) = \\sum_{i=1}^N \\Delta x (\\Delta t \\frac{da_{0,i}^0}{dt}) = \\Delta t \\frac{dM^0}{dt} = 0\n$$\nTherefore, the mass conservation error $E_{\\mathrm{unlim}}$ for the unlimited scheme should be zero up to floating-point precision.\nSince the limiter is designed to be conservative by only modifying the slope coefficient ($a_{0,i}^{\\mathrm{lim}} = a_{0,i}^{\\mathrm{unlim}}$), the total mass is unaffected. Consequently, $M^1_{\\mathrm{lim}} = M^1_{\\mathrm{unlim}}$, and the mass conservation error for the limited scheme, $E_{\\mathrm{lim}}$, is expected to be identical to $E_{\\mathrm{unlim}}$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import fixed_quad\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the DG solver.\n    \"\"\"\n    # Test cases defined as (N, u, CFL, alpha0_func, case_name)\n    test_cases = [\n        (40, 1.0, 0.20, lambda x: 0.5 + 0.49 * np.sin(2 * np.pi * x), 'A'),\n        (40, 1.0, 0.30, lambda x: 1.0 if x < 0.5 else 0.0, 'B'),\n        (1, 0.7, 0.20, lambda x: 0.3 + 0.2 * np.cos(2 * np.pi * x), 'C'),\n        (30, -1.0, 0.25, lambda x: 0.5 + 0.49 * np.sin(4 * np.pi * x), 'D'),\n    ]\n\n    results = []\n    for N, u, CFL, alpha0_func, case_name in test_cases:\n        e_unlim, e_lim = run_dg_step(N, u, CFL, alpha0_func, case_name)\n        results.append([e_unlim, e_lim])\n\n    # Format the final output string\n    formatted_results = []\n    for res_pair in results:\n        formatted_pair = f\"[{res_pair[0]:.12e},{res_pair[1]:.12e}]\"\n        formatted_results.append(formatted_pair)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_dg_step(N, u, CFL, alpha0_func, case_name):\n    \"\"\"\n    Performs a single time step of the P1 Discontinuous Galerkin method.\n    \"\"\"\n    # Quadrature order for initial condition projection\n    QUAD_ORDER = 16\n\n    # --- 1. Setup grid and time step ---\n    dx = 1.0 / N\n    dt = 0.0 if u == 0.0 else CFL * dx / abs(u)\n\n    # Cell centers are used for coordinate mapping in projection\n    x_nodes = np.linspace(0, 1, N + 1)\n    x_centers = x_nodes[:-1] + dx / 2\n\n    # --- 2. Initialize coefficients via L2 projection ---\n    a0 = np.zeros(N)\n    a1 = np.zeros(N)\n\n    if case_name == 'B':  # Analytical initialization for the step function\n        # The discontinuity is at x=0.5, which is an interface for N=40\n        discontinuity_idx = int(round(0.5 / dx))\n        a0[:discontinuity_idx] = 1.0\n        a0[discontinuity_idx:] = 0.0\n        # Slope is zero for a piecewise constant function\n        a1.fill(0.0)\n    else:  # L2 projection using numerical quadrature\n        for i in range(N):\n            # Integrands for projection in reference coordinates\n            integrand_a0 = lambda xi: alpha0_func(x_centers[i] + dx / 2 * xi)\n            integrand_a1 = lambda xi: alpha0_func(x_centers[i] + dx / 2 * xi) * xi\n            \n            # Use fixed-order Gaussian quadrature\n            integral_a0, _ = fixed_quad(integrand_a0, -1.0, 1.0, n=QUAD_ORDER)\n            integral_a1, _ = fixed_quad(integrand_a1, -1.0, 1.0, n=QUAD_ORDER)\n            \n            a0[i] = 0.5 * integral_a0\n            a1[i] = 1.5 * integral_a1\n\n    # --- 3. Calculate initial total mass ---\n    M0 = np.sum(a0) * dx\n\n    # --- 4. Perform a single DG time step (unlimited) ---\n    if u == 0.0:\n        a0_unlim, a1_unlim = a0.copy(), a1.copy()\n    else:\n        # Vectorized implementation using np.roll for periodic boundaries\n        if u > 0:\n            flux_l = np.roll(a0, 1) + np.roll(a1, 1)  # upwind from left neighbor\n            flux_r = a0 + a1                         # upwind from self\n        else:  # u < 0\n            flux_l = a0 - a1                         # upwind from self\n            flux_r = np.roll(a0, -1) - np.roll(a1, -1) # upwind from right neighbor\n        \n        cfl_signed = CFL * np.sign(u)\n        \n        # RHS for cell average and slope updates\n        rhs_a0_term = -(flux_r - flux_l)\n        rhs_a1_term = -(flux_r + flux_l - 2 * a0)\n        \n        # Forward Euler update\n        a0_unlim = a0 + cfl_signed * rhs_a0_term\n        a1_unlim = a1 + 3 * cfl_signed * rhs_a1_term\n\n    # --- 5. Calculate mass conservation error for the unlimited solution ---\n    M1_unlim = np.sum(a0_unlim) * dx\n    E_unlim = abs(M1_unlim - M0)\n\n    # --- 6. Apply the bound-preserving limiter ---\n    m, M = 0.0, 1.0\n    \n    # Compute face values from the unlimited update\n    alpha_Lplus = a0_unlim - a1_unlim\n    alpha_Rminus = a0_unlim + a1_unlim\n    \n    min_face_vals = np.minimum(alpha_Lplus, alpha_Rminus)\n    max_face_vals = np.maximum(alpha_Lplus, alpha_Rminus)\n    \n    # Calculate the scaling factor theta\n    theta = np.ones(N)\n    \n    # First ratio for the lower bound\n    den1 = a0_unlim - min_face_vals\n    ratio1 = np.ones_like(a0_unlim)\n    valid_mask1 = den1 > 1e-15  # Check for positive denominator\n    ratio1[valid_mask1] = (a0_unlim[valid_mask1] - m) / den1[valid_mask1]\n    \n    # Second ratio for the upper bound\n    den2 = max_face_vals - a0_unlim\n    ratio2 = np.ones_like(a0_unlim)\n    valid_mask2 = den2 > 1e-15 # Check for positive denominator\n    ratio2[valid_mask2] = (M - a0_unlim[valid_mask2]) / den2[valid_mask2]\n    \n    # Combine the limiters\n    theta = np.minimum(theta, ratio1)\n    theta = np.minimum(theta, ratio2)\n    \n    # Apply the limiter\n    a0_lim = a0_unlim  # Cell average is preserved\n    a1_lim = theta * a1_unlim\n\n    # --- 7. Calculate mass conservation error for the limited solution ---\n    M1_lim = np.sum(a0_lim) * dx\n    E_lim = abs(M1_lim - M0)\n\n    return E_unlim, E_lim\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "High-order methods are known for generating spurious Gibbs oscillations near sharp interfaces, which can degrade solution quality and contaminate the flow field. This exercise  provides hands-on experience with an advanced stabilization technique: localized spectral filtering. You will first implement a sensor to identify \"troubled\" cells containing discontinuities and then apply a spectral filter designed to damp oscillations while crucially preserving the total mass of the system.",
            "id": "3380109",
            "problem": "Consider the one-dimensional conservative advection of a volume fraction field $\\alpha(x,t)$ for a two-phase mixture, governed by the conservation law $\\partial_t \\alpha + \\partial_x (u \\alpha) = 0$ with constant positive velocity $u > 0$. Work on the periodic domain $x \\in [0,1]$ and represent $\\alpha(x,t)$ using a Discontinuous Galerkin (DG) method with polynomial degree $p$ Legendre basis functions on each of $N_e$ uniform elements. Let the initial condition be a piecewise-constant volume fraction:\n$$\n\\alpha(x,0) = \\begin{cases}\n1, & x \\in [a,b], \\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\nwith $a = 0.35$ and $b = 0.65$, so the exact initial mass is $\\int_0^1 \\alpha(x,0)\\,dx = b-a$.\n\nUse the DG weak form derived from the fundamental conservation law and numerical fluxes to advance the modal coefficients by one explicit Euler time step of size $\\Delta t$ consistent with a Courant-Friedrichs-Lewy (CFL) number $\\text{CFL} = 0.2$, that is $\\Delta t = \\text{CFL} \\cdot h / u$ where $h = 1/N_e$ is the element size. Employ upwind flux consistent with $u>0$. Express all integrals required for projections and interior terms using Gauss-Legendre quadrature with sufficiently high order to ensure accuracy.\n\nAfter advancing one time step without any limiter, design and apply a localized spectral filter in modal space near detected interfaces to suppress Gibbs oscillations while preserving conservative advection of $\\alpha$. Localize the filter using an interface sensor based on modal energy, specifically a Persson-type indicator $S_e = \\log_{10}\\left( \\frac{|c_{e,p}|^2}{\\sum_{k=0}^{p} |c_{e,k}|^2 + \\varepsilon} \\right)$ where $c_{e,k}$ are the modal coefficients in element $e$, $p$ is the highest degree, and $\\varepsilon$ is a small positive constant to avoid division by zero. Elements with $S_e$ greater than a given threshold are \"troubled\" and must be filtered; other elements remain unchanged. The filter must be spectrally acting on modes $k=1,\\dots,p$ and be conservative in the sense that it leaves the zeroth mode unchanged to preserve the element mass, i.e., the filtered coefficient $\\tilde{c}_{e,0} = c_{e,0}$. The family of filters should be parameterized by a strength and an order, and optionally allow a nonconservative variant where the zeroth mode is multiplied by a factor different from $1$ to illustrate the impact on mass conservation.\n\nDefine the $L^1$ mass error for a configuration as the absolute difference between the total mass after the time step and filtering and the initial mass, namely\n$$\nE_{L^1} = \\left| \\sum_{e=1}^{N_e} h \\, \\tilde{c}_{e,0} \\;-\\; \\sum_{e=1}^{N_e} h \\, c_{e,0}^{\\text{initial}} \\right|,\n$$\nwhere $\\tilde{c}_{e,0}$ are the zeroth modal coefficients after advancing one time step and applying the filter, and $c_{e,0}^{\\text{initial}}$ are the initial zeroth modal coefficients obtained by projection.\n\nImplement the following in your program:\n- Partition $[0,1]$ into $N_e = 20$ elements with degree $p = 5$. Use $u = 1$ and $\\text{CFL} = 0.2$.\n- Project the initial condition onto modal coefficients using exact Legendre projection integrals computed by Gauss-Legendre quadrature with at least $200$ points.\n- Advance the modal coefficients by one explicit Euler time step using the DG weak form with upwind numerical flux and exact interior integrals computed by quadrature.\n- Compute the interface sensor $S_e$ in each element.\n- Apply a localized spectral filter in \"troubled\" elements only. The filter must be conservative if configured to preserve mass (zeroth mode invariant), and nonconservative otherwise by multiplying the zeroth mode by a specified factor. The filter acts on higher modes with a spectral damping profile controlled by a strength and order parameter.\n\nDesign a test suite to assess different filter behaviors and their impact on $L^1$ mass error. Use the following test cases, each described by a tuple $(\\beta, s, \\text{preserve\\_avg}, \\text{threshold}, \\sigma_0)$:\n1. $(0.0, 8, \\text{True}, -2.5, 1.0)$: no filtering.\n2. $(12.0, 8, \\text{True}, -3.0, 1.0)$: moderate localized filtering that preserves the zeroth mode.\n3. $(36.0, 8, \\text{True}, -2.0, 1.0)$: aggressive localized filtering that preserves the zeroth mode.\n4. $(36.0, 8, \\text{False}, -2.0, 0.95)$: aggressive localized filtering that does not preserve the zeroth mode; the zeroth mode is multiplied by $\\sigma_0 = 0.95$.\n5. $(12.0, 8, \\text{True}, -10.0, 1.0)$: global filtering applied in all elements that preserves the zeroth mode.\n\nFor all cases, set the small positive constant in the sensor to $\\varepsilon = 10^{-14}$. Treat all quantities as dimensionless; no physical units are required. Your program should compute $E_{L^1}$ for each test case and produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, `[r1,r2,r3,r4,r5]`), where each $r_i$ is a floating-point number representing the $L^1$ mass error for the corresponding test case. Ensure the output uses the exact format and ordering of the test suite above.",
            "solution": "The problem is assessed to be valid. It is a well-posed, scientifically grounded problem in the field of numerical methods for partial differential equations. All necessary parameters and definitions are provided, and the task is a standard exercise in implementing and analyzing a Discontinuous Galerkin (DG) method with a spectral filter.\n\n### 1. Discontinuous Galerkin (DG) Formulation\n\nThe problem considers the one-dimensional linear advection equation, a prototype for a hyperbolic conservation law:\n$$ \\partial_t \\alpha + \\partial_x (u \\alpha) = 0 $$\nwhere $\\alpha(x,t)$ is the conserved quantity (volume fraction), and $u$ is a constant positive advection velocity. The spatial domain is $x \\in [0,1]$ with periodic boundary conditions.\n\nThe domain is partitioned into $N_e$ non-overlapping elements $I_e = [x_{e-1/2}, x_{e+1/2}]$ of uniform size $h = 1/N_e$. On each element, the solution $\\alpha(x,t)$ is approximated by a polynomial of degree $p$ in a local reference coordinate $\\xi = \\frac{x-x_e}{h/2} \\in [-1,1]$, where $x_e$ is the center of element $I_e$:\n$$ \\alpha_h(x,t)|_{I_e} = \\sum_{k=0}^{p} c_{e,k}(t) \\phi_k(\\xi) $$\nThe basis functions $\\phi_k(\\xi)$ are the standard Legendre polynomials $P_k(\\xi)$. The coefficients $c_{e,k}(t)$ are the modal degrees of freedom for element $e$.\n\nTo derive the semi-discrete equations for the coefficients $c_{e,k}$, we multiply the PDE by a test function $v_h$ from the same polynomial space and integrate over an element $I_e$:\n$$ \\int_{I_e} v_h (\\partial_t \\alpha_h) \\,dx + \\int_{I_e} v_h \\partial_x (u \\alpha_h) \\,dx = 0 $$\nIntegrating the second term by parts yields the weak formulation:\n$$ \\int_{I_e} v_h (\\partial_t \\alpha_h) \\,dx = \\int_{I_e} (u \\alpha_h) (\\partial_x v_h) \\,dx - [ v_h (u \\alpha_h)^* ]_{x_{e-1/2}}^{x_{e+1/2}} $$\nHere, $(u \\alpha_h)^*$ is the numerical flux, which is necessary because the solution $\\alpha_h$ is discontinuous at element interfaces. For $u > 0$, the upwind flux is used:\n$$ (u \\alpha_h)^*(x_{j+1/2}) = u \\cdot \\alpha_h(x_{j+1/2}^-, t) $$\nwhere $\\alpha_h(x_{j+1/2}^-, t)$ is the value of the solution at the interface $x_{j+1/2}$ approached from the left (i.e., from within element $j$).\n\nSubstituting $\\alpha_h = \\sum_k c_{e,k} \\phi_k$ and $v_h = \\phi_j$ and changing variables to the reference coordinate $\\xi$, we obtain a system of ordinary differential equations (ODEs) for the modal coefficients in each element $e$:\n$$ \\frac{dc_{e,j}}{dt} = \\frac{2j+1}{h} \\left( u \\sum_{k=0}^p c_{e,k} \\int_{-1}^1 \\phi_k(\\xi) \\phi_j'(\\xi) d\\xi - \\left[ u \\alpha_h^* \\phi_j(\\xi) \\right]_{\\xi=-1}^{\\xi=1} \\right) $$\nThe integral term can be precomputed and stored in a stiffness matrix $\\mathbf{S}$, where $S_{jk} = \\int_{-1}^1 \\phi_k(\\xi) \\phi_j'(\\xi) d\\xi$. Analytically, $S_{jk} = 2$ if $k<j$ and $j-k$ is odd, and $0$ otherwise. The flux term for element $e$ becomes:\n$$ \\left[ u \\alpha_h^* \\phi_j(\\xi) \\right]_{\\xi=-1}^{\\xi=1} = u \\alpha_h(x_{e+1/2}^-) \\phi_j(1) - u \\alpha_h(x_{e-1/2}^-) \\phi_j(-1) $$\nwhere $\\alpha_h(x_{e+1/2}^-) = \\sum_k c_{e,k} \\phi_k(1)$ is computed using coefficients from element $e$, and $\\alpha_h(x_{e-1/2}^-) = \\sum_k c_{e-1,k} \\phi_k(1)$ is computed using coefficients from the neighboring element $e-1$ (with periodicity for $e=0$). Using the property $\\phi_j(1)=1$ and $\\phi_j(-1)=(-1)^j$, the semi-discrete system for element $e$ becomes:\n$$ \\frac{d\\vec{c}_e}{dt} = \\mathbf{RHS}(\\vec{c}_{e-1}, \\vec{c}_e) $$\n\n### 2. Numerical Implementation\n\n**Initial Condition**: The initial piecewise-constant function $\\alpha(x,0)$ is projected onto the polynomial basis in each element to find the initial coefficients $c_{e,k}(0)$:\n$$ c_{e,k}(0) = \\frac{2k+1}{2} \\int_{-1}^1 \\alpha(x_e + \\frac{h}{2}\\xi, 0) \\phi_k(\\xi) d\\xi $$\nThis integral is computed numerically using high-order Gauss-Legendre quadrature with $200$ points, as specified. The total initial mass is $M_{\\text{initial}} = \\sum_{e=0}^{N_e-1} h c_{e,0}(0)$.\n\n**Time Integration**: A single explicit Euler step is used to advance the solution from time $t=0$ to $t=\\Delta t$:\n$$ \\vec{c}_e(t=\\Delta t) = \\vec{c}_e(t=0) + \\Delta t \\cdot \\mathbf{RHS}(\\vec{c}_{e-1}(0), \\vec{c}_e(0)) $$\nThe time step is set by the CFL condition: $\\Delta t = \\text{CFL} \\cdot h / u$. With $N_e=20$, $u=1$, and $\\text{CFL}=0.2$, we have $h = 1/20 = 0.05$ and $\\Delta t = 0.2 \\cdot 0.05 / 1 = 0.01$.\n\n**Spectral Filtering for Oscillation Control**: After the time step, spurious Gibbs oscillations near discontinuities are addressed using a localized spectral filter.\n1.  **Interface Sensing**: An interface sensor $S_e$ identifies \"troubled\" elements containing high-frequency content indicative of unresolved features:\n    $$ S_e = \\log_{10}\\left( \\frac{|c_{e,p}|^2}{\\sum_{k=0}^{p} |c_{e,k}|^2 + \\varepsilon} \\right) $$\n    An element $e$ is marked as troubled if $S_e$ exceeds a given test-case-specific `threshold`.\n2.  **Filter Application**: A spectral filter is applied to the modal coefficients of troubled elements. A standard exponential filter is used, defined by the damping function:\n    $$ \\sigma(k) = \\exp\\left(-\\beta \\left(\\frac{k}{p}\\right)^s\\right) $$\n    where $\\beta$ is the filter strength and $s$ is the order. The filtered coefficients $\\tilde{c}_{e,k}$ are:\n    $$ \\tilde{c}_{e,k} = \\begin{cases} \\sigma_0 \\cdot c_{e,k} & \\text{for } k=0 \\text{ in non-conservative case} \\\\ c_{e,k} & \\text{for } k=0 \\text{ in conservative case} \\\\ \\sigma(k) \\cdot c_{e,k} & \\text{for } k=1, \\dots, p \\end{cases} $$\n    The filter is localized, meaning coefficients in untroubled elements are not modified.\n\n**Mass Error Calculation**: The DG scheme without filtering is exactly conservative for the mean value $c_{e,0}$. Any mass change arises from the filtering step. The $L^1$ mass error is the absolute difference between the total mass after filtering and the initial total mass:\n$$ E_{L^1} = \\left| \\sum_{e=0}^{N_e-1} h \\, \\tilde{c}_{e,0} - \\sum_{e=0}^{N_e-1} h \\, c_{e,0}^{\\text{initial}} \\right| $$\nFor conservative filtering (`preserve_avg=True`), $\\tilde{c}_{e,0}$ is unchanged, so this error is expected to be near machine precision. For non-conservative filtering, a significant error is expected.\n\nThe overall algorithm proceeds by looping through the five test cases. For each case, it initializes the solution, performs one time step, applies the specified filter, calculates the resulting $L^1$ mass error, and stores it. The final output is the list of these five error values.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection problem using a Discontinuous Galerkin method\n    and evaluates the L1 mass error for different spectral filtering strategies.\n    \"\"\"\n\n    # Problem Parameters\n    Ne = 20  # Number of elements\n    p = 5    # Polynomial degree\n    u = 1.0  # Advection velocity\n    cfl = 0.2 # CFL number\n    a = 0.35 # Initial condition start\n    b = 0.65 # Initial condition end\n    epsilon_sensor = 1e-14\n\n    # Derived parameters\n    h = 1.0 / Ne\n    dt = cfl * h / u\n    element_boundaries = np.linspace(0, 1, Ne + 1)\n    element_centers = (element_boundaries[:-1] + element_boundaries[1:]) / 2.0\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (beta, s, preserve_avg, threshold, sigma0)\n        (0.0, 8, True, -2.5, 1.0),\n        (12.0, 8, True, -3.0, 1.0),\n        (36.0, 8, True, -2.0, 1.0),\n        (36.0, 8, False, -2.0, 0.95),\n        (12.0, 8, True, -10.0, 1.0),\n    ]\n\n    # Legendre polynomials and derivatives\n    poly_coeffs = [legendre(k) for k in range(p + 1)]\n    deriv_coeffs = [p.deriv() for p in poly_coeffs]\n\n    def eval_poly(coeffs, x):\n        return np.array([c(x) for c in coeffs]).T\n\n    # Pre-compute stiffness matrix S_jk = integral(P_k * P_j') dx\n    S = np.zeros((p + 1, p + 1))\n    for j in range(p + 1):\n        for k in range(j):\n            if (j - k) % 2 != 0:\n                S[j, k] = 2.0\n    \n    # Pre-compute values of Legendre polynomials at element boundaries\n    phi_at_plus_one = eval_poly(poly_coeffs, 1.0)\n    phi_at_minus_one = eval_poly(poly_coeffs, -1.0)\n    \n    # Initial Condition function\n    def alpha0(x):\n        return np.where((x >= a) & (x <= b), 1.0, 0.0)\n\n    # High-order quadrature for projection\n    nq_proj = 200\n    xi_proj, w_proj = np.polynomial.legendre.leggauss(nq_proj)\n\n    # Initial modal coefficients\n    c0 = np.zeros((Ne, p + 1))\n    for e in range(Ne):\n        x_map = element_centers[e] + 0.5 * h * xi_proj\n        alpha_vals = alpha0(x_map)\n        for k in range(p + 1):\n            pk_vals = poly_coeffs[k](xi_proj)\n            integral_val = np.sum(w_proj * alpha_vals * pk_vals)\n            c0[e, k] = (2 * k + 1) / 2.0 * integral_val\n            \n    initial_mass = np.sum(c0[:, 0]) * h\n    \n    results = []\n    \n    # --- Main loop over test cases ---\n    for beta, s_filter, preserve_avg, threshold, sigma0 in test_cases:\n        \n        # --- DG Time Step ---\n        c_step = np.copy(c0)\n        rhs = np.zeros_like(c_step)\n\n        for e in range(Ne):\n            e_left = (e - 1 + Ne) % Ne\n            \n            # Flux contributions\n            alpha_right = np.dot(c_step[e, :], phi_at_plus_one)\n            alpha_left = np.dot(c_step[e_left, :], phi_at_plus_one)\n            \n            # Volume integral (stiffness matrix term)\n            vol_integral = u * np.dot(S, c_step[e, :])\n            \n            # Surface integral (flux term)\n            surf_integral = u * (alpha_right * phi_at_plus_one - alpha_left * phi_at_minus_one)\n            \n            # Combine for RHS\n            for j in range(p + 1):\n                mass_inv = (2 * j + 1) / h\n                rhs[e, j] = mass_inv * (vol_integral[j] - surf_integral[j])\n\n        c_step += dt * rhs\n\n        # --- Spectral Filtering ---\n        c_filtered = np.copy(c_step)\n\n        for e in range(Ne):\n            # Compute sensor\n            num = c_step[e, p]**2\n            den = np.sum(c_step[e, :]**2) + epsilon_sensor\n            sensor_val = np.log10(num / den)\n\n            if sensor_val > threshold:\n                # This is a troubled element, apply filter\n                for k in range(1, p + 1):\n                    sigma_k = np.exp(-beta * (k / p)**s_filter)\n                    c_filtered[e, k] = sigma_k * c_step[e, k]\n\n                if not preserve_avg:\n                    c_filtered[e, 0] = sigma0 * c_step[e, 0]\n        \n        # --- L1 Mass Error Calculation ---\n        final_mass = np.sum(c_filtered[:, 0]) * h\n        l1_mass_error = np.abs(final_mass - initial_mass)\n        results.append(l1_mass_error)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The accurate modeling of surface tension forces is paramount in multiphase flow simulations and hinges on the precise calculation of interface curvature, $\\kappa$. This practice  challenges you to assess the geometric fidelity of a DG scheme using the benchmark static bubble problem, where errors in curvature can manifest as non-physical \"spurious\" forces. By implementing this test, you will directly investigate how increasing the polynomial order ($p$-enrichment) improves the representation of curved interfaces and the resulting surface tension forces.",
            "id": "3380182",
            "problem": "Consider a two-dimensional static bubble test in the context of Discontinuous Galerkin (DG) methods for multiphase flows. The interface is represented by a level-set function defined on the square domain $[-L,L]^2$ with $L=1.5$. Let the level-set function be $\\phi(x,y) = \\sqrt{x^2 + y^2} - R$ with bubble radius $R=1$, and suppose the surface tension coefficient is $\\sigma=1$. The exact interface is the circle $\\{(x,y) \\mid \\phi(x,y) = 0\\}$ and the exact curvature along the interface is $\\kappa_{\\text{exact}} = 1$ (for two-dimensional curvature of a circle), which yields an exact Laplace pressure jump $\\Delta p_{\\text{exact}} = \\sigma \\kappa_{\\text{exact}} = 1$.\n\nStarting from the fundamental definitions:\n- Curvature in the level-set formulation is given by $\\kappa = \\nabla \\cdot \\left(\\dfrac{\\nabla \\phi}{\\|\\nabla \\phi\\|}\\right)$.\n- The net surface tension force per unit thickness in two dimensions is $\\mathbf{F} = \\oint_{\\phi=0} \\sigma \\kappa \\mathbf{n}\\, \\mathrm{d}s$, where $\\mathbf{n}$ is the unit normal and $\\mathrm{d}s$ is the line element along the interface.\n- The line element along the circle is $\\mathrm{d}s = R\\,\\mathrm{d}\\theta$, and the unit normal for the exact circle is $\\mathbf{n}_{\\text{exact}} = [\\cos\\theta, \\sin\\theta]^\\top$.\n\nUse a Discontinuous Galerkin approximation with a fixed uniform Cartesian mesh of square elements of size $h=0.3$ over $[-L,L]^2$. In each element, approximate $\\phi$ by a polynomial of total degree $p$ in local coordinates via a weighted least-squares fit using Gauss–Legendre quadrature points. Let local coordinates $(\\xi,\\eta) \\in [-1,1]^2$ map affinely to each element, and let the polynomial approximation be\n$$\n\\phi_h(\\xi,\\eta) = \\sum_{i+j \\le p} c_{ij} \\,\\xi^i \\eta^j.\n$$\nThe coefficients $c_{ij}$ are determined by minimizing a quadrature-weighted least-squares mismatch to the exact $\\phi$ evaluated at tensor-product Gauss–Legendre points of order $n_q = p+2$ in each element. The gradients and Hessians are obtained analytically from $\\phi_h$, and physical-space derivatives follow by the chain rule with the affine map. The curvature approximation is computed pointwise from $\\phi_h$ as\n$$\n\\kappa_h = \\frac{\\phi_{xx}\\,\\phi_y^2 - 2\\,\\phi_x\\,\\phi_y\\,\\phi_{xy} + \\phi_{yy}\\,\\phi_x^2}{\\left(\\phi_x^2 + \\phi_y^2\\right)^{3/2}}.\n$$\n\nEvaluate the curvature and force using the DG approximation as follows:\n- Sample the interface at $N_\\theta$ uniformly spaced angles $\\theta \\in [0,2\\pi)$ with $N_\\theta = 720$ (angles in radians).\n- For each sample point $(x,y) = (R\\cos\\theta, R\\sin\\theta)$, select the element containing $(x,y)$, evaluate $\\phi_h$ and its derivatives at that point, compute $\\kappa_h$, and compute the DG unit normal $\\mathbf{n}_h = \\dfrac{\\nabla \\phi_h}{\\|\\nabla \\phi_h\\|}$.\n- Approximate the line integral by the composite trapezoidal rule in $\\theta$ (which is exact for equally spaced sampling on the circle for smooth integrands), i.e., with uniform weight $\\mathrm{d}s = R\\,\\mathrm{d}\\theta$.\n\nFor each polynomial degree $p \\in \\{2,3,5\\}$ at fixed $h$, compute:\n1. The interface $L^2$ curvature error\n$$\nE_\\kappa(p) = \\sqrt{\\frac{1}{2\\pi R}\\int_{0}^{2\\pi} \\left(\\kappa_h(\\theta) - \\kappa_{\\text{exact}}\\right)^2 R\\, \\mathrm{d}\\theta}.\n$$\n2. The magnitude of the net surface tension force\n$$\n\\|\\mathbf{F}(p)\\| = \\left\\|\\int_{0}^{2\\pi} \\sigma\\,\\kappa_h(\\theta)\\,\\mathbf{n}_h(\\theta)\\, R\\, \\mathrm{d}\\theta\\right\\|.\n$$\n\nAssume dimensionless units throughout (no physical units required beyond the nondimensional parameters given), and use angles in radians. Your program should implement the above DG approximation and report, for the test suite $p \\in \\{2,3,5\\}$, the two metrics $E_\\kappa(p)$ and $\\|\\mathbf{F}(p)\\|$ as floating-point numbers for each $p$.\n\nTest Suite:\n- Case 1 (happy path): $p=2$.\n- Case 2 (improved accuracy): $p=3$.\n- Case 3 (higher-order edge case): $p=5$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list of three lists, each inner list in the order $[E_\\kappa(p), \\|\\mathbf{F}(p)\\|]$ for $p=2$, $p=3$, and $p=5$, respectively. For example, the output should look like:\n`[[e_2,f_2],[e_3,f_3],[e_5,f_5]]`.",
            "solution": "The posed problem is valid as it is scientifically grounded, well-posed, and objective. It specifies a clear numerical task within the established field of computational fluid dynamics, providing all necessary parameters, equations, and definitions to construct a unique solution.\n\nThe solution involves implementing a Discontinuous Galerkin (DG) method to approximate a level-set function, and from it, derive geometric quantities of a circular interface. The process is broken down into several logical steps:\n\n1.  **Domain Discretization and Local Coordinate System**:\n    The computational domain, a square defined by $[-L, L]^2 = [-1.5, 1.5]^2$, is partitioned into a uniform Cartesian mesh of $10 \\times 10$ square elements. Each element has a side length of $h=0.3$. Within each element, a local coordinate system $(\\xi, \\eta) \\in [-1, 1]^2$ is defined. The transformation from this local system to the global physical coordinates $(x,y)$ for an element centered at $(x_c, y_c)$ is an affine map:\n    $$\n    x = x_c + \\frac{h}{2}\\xi, \\quad y = y_c + \\frac{h}{2}\\eta\n    $$\n\n2.  **Piecewise Polynomial Approximation**:\n    In each element, the exact level-set function, $\\phi(x,y) = \\sqrt{x^2 + y^2} - R$, is approximated by a polynomial $\\phi_h(\\xi, \\eta)$ of total degree $p$. The polynomial is constructed from a basis of monomials $\\{\\xi^i \\eta^j\\}$ such that $i+j \\le p$:\n    $$\n    \\phi_h(\\xi,\\eta) = \\sum_{i+j \\le p} c_{ij} \\,\\xi^i \\eta^j\n    $$\n    The coefficients $c_{ij}$ are unique to each element and are determined via a weighted least-squares fit. This fit minimizes the difference between $\\phi_h$ and the exact function $\\phi$ at a grid of $n_q \\times n_q$ tensor-product Gauss-Legendre quadrature points within the element, where $n_q = p+2$. The minimization problem is:\n    $$\n    \\min_{c_{ij}} \\sum_{k=1}^{n_q^2} w_k \\left( \\phi_h(\\xi_k, \\eta_k) - \\phi(x_k, y_k) \\right)^2\n    $$\n    where $(\\xi_k, \\eta_k)$ are the local coordinates of the quadrature nodes, $(x_k, y_k)$ are the corresponding physical coordinates, and $w_k$ are the quadrature weights. This formulation leads to an overdetermined linear system for the coefficients $c_{ij}$ in each element, which is solved using a standard least-squares algorithm.\n\n3.  **Computation of Physical Derivatives**:\n    Once the polynomial approximation $\\phi_h$ is established in each element, its spatial derivatives in physical coordinates $(\\phi_x, \\phi_y, \\phi_{xx}, \\phi_{xy}, \\phi_{yy})$ are required to compute curvature. These are obtained by first analytically differentiating the polynomial $\\phi_h$ with respect to the local coordinates $(\\xi, \\eta)$ and then applying the chain rule. Given the affine mapping, the derivatives transform with constant factors related to the element size $h$:\n    $$\n    \\phi_x = \\frac{\\partial \\phi_h}{\\partial x} = \\frac{2}{h} \\frac{\\partial \\phi_h}{\\partial \\xi}, \\quad \\phi_y = \\frac{\\partial \\phi_h}{\\partial y} = \\frac{2}{h} \\frac{\\partial \\phi_h}{\\partial \\eta}\n    $$\n    $$\n    \\phi_{xx} = \\frac{\\partial^2 \\phi_h}{\\partial x^2} = \\left(\\frac{2}{h}\\right)^2 \\frac{\\partial^2 \\phi_h}{\\partial \\xi^2}, \\quad \\phi_{xy} = \\frac{\\partial^2 \\phi_h}{\\partial x \\partial y} = \\left(\\frac{2}{h}\\right)^2 \\frac{\\partial^2 \\phi_h}{\\partial \\xi \\partial \\eta}, \\quad \\phi_{yy} = \\frac{\\partial^2 \\phi_h}{\\partial y^2} = \\left(\\frac{2}{h}\\right)^2 \\frac{\\partial^2 \\phi_h}{\\partial \\eta^2}\n    $$\n    With these derivatives, the approximate curvature $\\kappa_h$ is computed at any point using its definition in terms of level-set derivatives.\n\n4.  **Evaluation of Metrics via Numerical Integration**:\n    The two target metrics, the $L^2$ curvature error $E_\\kappa(p)$ and the magnitude of the net surface tension force $\\|\\mathbf{F}(p)\\|$, are defined as line integrals over the interface $\\phi=0$. These integrals are approximated numerically. The exact circular interface is sampled at $N_\\theta = 720$ equally spaced points, given by $(x_k, y_k) = (R\\cos\\theta_k, R\\sin\\theta_k)$ for $k=0, \\dots, N_\\theta-1$. At each sample point, the following steps are performed:\n    a. The element containing $(x_k, y_k)$ is identified.\n    b. The physical coordinates are mapped to the element's local coordinates $(\\xi_k, \\eta_k)$.\n    c. The stored coefficients $c_{ij}$ for that element are used to evaluate $\\phi_h$ derivatives and, consequently, the approximate curvature $\\kappa_h(\\theta_k)$ and normal vector $\\mathbf{n}_h(\\theta_k)$.\n    \n    The integrals are then approximated as sums over these sample points. The $L^2$ curvature error is computed as the Root Mean Square (RMS) error of the curvature samples:\n    $$\n    E_\\kappa(p) = \\sqrt{\\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} (\\kappa_h(\\theta_k) - \\kappa_{\\text{exact}})^2}\n    $$\n    The net force vector $\\mathbf{F}(p)$ is approximated by a sum based on the composite trapezoidal rule, which for uniform sampling simplifies to:\n    $$\n    \\mathbf{F}(p) \\approx \\sum_{k=0}^{N_\\theta-1} \\sigma\\,\\kappa_h(\\theta_k)\\,\\mathbf{n}_h(\\theta_k)\\, R \\Delta\\theta, \\quad \\text{where } \\Delta\\theta = \\frac{2\\pi}{N_\\theta}\n    $$\n    The magnitude of this resulting vector, $\\|\\mathbf{F}(p)\\|$, is then calculated. This entire computational procedure is executed for each polynomial degree $p \\in \\{2, 3, 5\\}$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\nimport math\n\ndef _get_basis_indices(p):\n    \"\"\"Generates basis monomial powers (i, j) for total degree p.\"\"\"\n    indices = []\n    for total_degree in range(p + 1):\n        for i in range(total_degree + 1):\n            j = total_degree - i\n            indices.append((i, j))\n    return indices\n\ndef _eval_basis_derivatives(xi, eta, basis_indices, deriv_xi, deriv_eta):\n    \"\"\"\n    Evaluates the derivatives of basis functions at a point (xi, eta).\n    Returns a vector of derivative values for all basis functions.\n    \"\"\"\n    values = np.zeros(len(basis_indices))\n    for k, (i, j) in enumerate(basis_indices):\n        if i < deriv_xi or j < deriv_eta:\n            val = 0.0\n        else:\n            term_xi = math.perm(i, deriv_xi) * (xi ** (i - deriv_xi))\n            term_eta = math.perm(j, deriv_eta) * (eta ** (j - deriv_eta))\n            val = term_xi * term_eta\n        values[k] = val\n    return values\n\ndef _get_element_coeffs(p, L, R, H):\n    \"\"\"\n    Computes the polynomial coefficients for phi_h in each element.\n    \"\"\"\n    n_q = p + 2\n    basis_indices = _get_basis_indices(p)\n    num_basis_fns = len(basis_indices)\n\n    num_elements_dim = int(round(2 * L / H))\n    coeffs_grid = np.zeros((num_elements_dim, num_elements_dim, num_basis_fns))\n    \n    xi_q, w_q = roots_legendre(n_q)\n    xi_q_2d, eta_q_2d = np.meshgrid(xi_q, xi_q)\n    quad_points_local = np.vstack([xi_q_2d.ravel(), eta_q_2d.ravel()]).T\n    w_q_2d = np.outer(w_q, w_q).ravel()\n\n    A = np.zeros((n_q**2, num_basis_fns))\n    for i in range(n_q**2):\n        xi_val, eta_val = quad_points_local[i]\n        A[i, :] = _eval_basis_derivatives(xi_val, eta_val, basis_indices, 0, 0)\n    \n    A_w = A * np.sqrt(w_q_2d)[:, np.newaxis]\n\n    for i in range(num_elements_dim):\n        for j in range(num_elements_dim):\n            xc = -L + H * (i + 0.5)\n            yc = -L + H * (j + 0.5)\n            \n            x_phys = xc + (H / 2) * quad_points_local[:, 0]\n            y_phys = yc + (H / 2) * quad_points_local[:, 1]\n            \n            phi_exact_vals = np.sqrt(x_phys**2 + y_phys**2) - R\n            b_w = phi_exact_vals * np.sqrt(w_q_2d)\n            \n            c, _, _, _ = np.linalg.lstsq(A_w, b_w, rcond=None)\n            coeffs_grid[i, j, :] = c\n            \n    return coeffs_grid, basis_indices\n\ndef _compute_metrics_for_p(p, L, R, H, SIGMA, N_THETA, KAPPA_EXACT, coeffs_grid, basis_indices):\n    \"\"\"\n    Computes curvature error and net force magnitude for a given polynomial degree p.\n    \"\"\"\n    num_elements_dim = int(round(2 * L / H))\n    \n    theta = np.linspace(0, 2 * np.pi, N_THETA, endpoint=False)\n    x_s, y_s = R * np.cos(theta), R * np.sin(theta)\n\n    kappa_h_vals = np.zeros(N_THETA)\n    force_integrand_vals = np.zeros((N_THETA, 2))\n\n    for k in range(N_THETA):\n        x, y = x_s[k], y_s[k]\n        \n        i = int(np.floor((x + L) / H))\n        j = int(np.floor((y + L) / H))\n        i = min(max(i, 0), num_elements_dim - 1)\n        j = min(max(j, 0), num_elements_dim - 1)\n        \n        xc = -L + H * (i + 0.5)\n        yc = -L + H * (j + 0.5)\n        xi = (x - xc) / (H / 2)\n        eta = (y - yc) / (H / 2)\n        \n        c = coeffs_grid[i, j, :]\n        \n        deriv_vectors = {\n            (1, 0): _eval_basis_derivatives(xi, eta, basis_indices, 1, 0),\n            (0, 1): _eval_basis_derivatives(xi, eta, basis_indices, 0, 1),\n            (2, 0): _eval_basis_derivatives(xi, eta, basis_indices, 2, 0),\n            (1, 1): _eval_basis_derivatives(xi, eta, basis_indices, 1, 1),\n            (0, 2): _eval_basis_derivatives(xi, eta, basis_indices, 0, 2),\n        }\n        \n        phi_h_xi = np.dot(c, deriv_vectors[(1, 0)])\n        phi_h_eta = np.dot(c, deriv_vectors[(0, 1)])\n        phi_h_xixi = np.dot(c, deriv_vectors[(2, 0)])\n        phi_h_xieta = np.dot(c, deriv_vectors[(1, 1)])\n        phi_h_etaeta = np.dot(c, deriv_vectors[(0, 2)])\n        \n        h_inv2 = 2.0 / H\n        h_inv2_sq = h_inv2**2\n        \n        phi_x = phi_h_xi * h_inv2\n        phi_y = phi_h_eta * h_inv2\n        phi_xx = phi_h_xixi * h_inv2_sq\n        phi_xy = phi_h_xieta * h_inv2_sq\n        phi_yy = phi_h_etaeta * h_inv2_sq\n        \n        phi_x2 = phi_x**2\n        phi_y2 = phi_y**2\n        denom = (phi_x2 + phi_y2)**1.5\n        \n        kappa_h = (phi_xx*phi_y2 - 2*phi_x*phi_y*phi_xy + phi_yy*phi_x2) / denom if denom > 1e-12 else 0.0\n        kappa_h_vals[k] = kappa_h\n        \n        grad_phi_norm = np.sqrt(phi_x2 + phi_y2)\n        n_h = np.array([phi_x, phi_y]) / grad_phi_norm if grad_phi_norm > 1e-12 else np.array([0.0, 0.0])\n        force_integrand_vals[k, :] = SIGMA * kappa_h * n_h\n        \n    error_sq = (kappa_h_vals - KAPPA_EXACT)**2\n    E_kappa = np.sqrt(np.mean(error_sq))\n    \n    d_theta = 2 * np.pi / N_THETA\n    F_net_vec = np.sum(force_integrand_vals, axis=0) * R * d_theta\n    F_norm = np.linalg.norm(F_net_vec)\n    \n    return [E_kappa, F_norm]\n\ndef solve():\n    # Define test cases\n    test_cases = [2, 3, 5]  # Polynomial degrees p\n\n    # --- Problem Constants ---\n    L = 1.5\n    R = 1.0\n    SIGMA = 1.0\n    H = 0.3\n    N_THETA = 720\n    KAPPA_EXACT = 1.0\n    \n    results = []\n    for p in test_cases:\n        coeffs_grid, basis_indices = _get_element_coeffs(p, L, R, H)\n        metrics = _compute_metrics_for_p(p, L, R, H, SIGMA, N_THETA, KAPPA_EXACT, coeffs_grid, basis_indices)\n        results.append(metrics)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}