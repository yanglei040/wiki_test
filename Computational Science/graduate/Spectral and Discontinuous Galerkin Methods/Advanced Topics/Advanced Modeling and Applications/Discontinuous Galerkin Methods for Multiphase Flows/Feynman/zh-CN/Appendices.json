{
    "hands_on_practices": [
        {
            "introduction": "在多相流模拟中，精确地输运体积分数等相指示函数是基础。本练习将指导您为纯平流方程实现一个间断 Galerkin (DG) 方法，并重点关注一个关键的实际问题：如何通过有界限制器来强制物理约束（例如，体积分数 $ \\alpha $ 必须保持在 $ [0, 1] $ 区间内），同时不破坏方法的质量守恒性 。通过这个实践，您将掌握保证数值解物理真实性的基本技术。",
            "id": "3380118",
            "problem": "考虑一维守恒输运问题，其中体积分数场 $\\alpha(x,t)$ 在周期性定义域 $x \\in [0,1]$ 上满足标量线性平流方程 $\\partial_t \\alpha + u \\,\\partial_x \\alpha = 0$，速度 $u \\in \\mathbb{R}$ 为常数。体积分数在物理上受限于 $0 \\le \\alpha \\le 1$。将该域离散为 $N$ 个宽度为 $\\Delta x = 1/N$ 的均匀单元。在每个单元内，使用1次间断 Galerkin (DG) 多项式在局部参考坐标 $\\xi \\in [-1,1]$ 中近似 $\\alpha(x,t)$。该坐标通过映射 $x = x_i + (\\Delta x/2)\\,\\xi$ 定义，近似表示为 $\\alpha_i(\\xi,t) = a_{0,i}(t) + a_{1,i}(t)\\,\\xi$，其中 $a_{0,i}$ 是单元平均值，$a_{1,i}$ 是斜率系数。\n\n从守恒律和带有迎风数值通量的 DG 弱形式的定义出发，根据第一性原理推导每个单元的模态系数 $\\{a_{0,i},a_{1,i}\\}$ 的半离散系统。使用基函数 $\\{\\phi_0(\\xi)=1,\\phi_1(\\xi)=\\xi\\}$ 和每个单元上的精确 $L^2$ 内积。然后，实现一个大小为 $\\Delta t$ 的单步显式向前 Euler 时间步进。当 $|u| \\ne 0$ 时，$\\Delta t$ 受 Courant-Friedrichs-Lewy (CFL) 数 $\\mathrm{CFL} \\in (0,1)$ 的约束，即 $\\Delta t = \\mathrm{CFL}\\,\\Delta x/|u|$；如果 $|u|=0$，则使用 $\\Delta t=0$。数值通量采用迎风格式：在界面处，如果 $u>0$，迎风状态取自左侧单元的值；如果 $u0$，迎风状态取自右侧单元的值。\n\n在进行一步无任何限制（“无限制”更新）的时间步进后，应用一个基于单元平均值进行缩放的保界限制器，以在单元面处（在一维空间中，这与面平均值一致）强制执行边界条件。具体来说，对于每个单元 $i$，在无限制更新后计算内部面值 $\\alpha_{i}^{L+} = a_{0,i} - a_{1,i}$ 和 $\\alpha_{i}^{R-} = a_{0,i} + a_{1,i}$。定义物理下界和上界为 $m=0$ 和 $M=1$。设\n$$\n\\theta_i \\;=\\; \\min\\left\\{1,\\; \\frac{a_{0,i}-m}{a_{0,i}-\\min(\\alpha_{i}^{L+},\\alpha_{i}^{R-})}\\;\\text{ if } a_{0,i}\\min(\\alpha_{i}^{L+},\\alpha_{i}^{R-}),\\; \\frac{M-a_{0,i}}{\\max(\\alpha_{i}^{L+},\\alpha_{i}^{R-})-a_{0,i}}\\;\\text{ if } a_{0,i}\\max(\\alpha_{i}^{L+},\\alpha_{i}^{R-})\\right\\},\n$$\n约定任何分母为非正数的分式都将被忽略并替换为 $1$。然后设置限制后的斜率 $a_{1,i}^{\\mathrm{lim}} = \\theta_i\\, a_{1,i}$，同时保持单元平均值不变，$a_{0,i}^{\\mathrm{lim}}=a_{0,i}$。该限制器旨在保持单元平均值，同时在单元面处强制执行边界 $m \\le \\alpha \\le M$。\n\n将在时间 $t^n$ 的总质量定义为 $M^n = \\sum_{i=1}^{N} a_{0,i}^n \\,\\Delta x$。对于从 $t^0$ 到 $t^1=t^0+\\Delta t$ 的单个时间步，将全局质量守恒误差量化为总质量的绝对变化量 $E = |M^1 - M^0|$。计算并报告无限制更新和限制后更新的误差。\n\n你的程序必须实现所述方法，并为以下测试套件生成输出。每个测试用例由 $(N,u,\\mathrm{CFL},\\alpha_0(x))$ 定义：\n- 测试 A (正常路径，光滑有界): $N=40$, $u=1$, $\\mathrm{CFL}=0.20$, $\\alpha_0(x) = 0.5 + 0.49 \\sin(2\\pi x)$。\n- 测试 B (不连续性，可能存在面超调): $N=40$, $u=1$, $\\mathrm{CFL}=0.30$, $\\alpha_0(x) = 1$ for $x0.5$, and $\\alpha_0(x)=0$ for $x \\ge 0.5$。\n- 测试 C (边界情况，单单元周期性): $N=1$, $u=0.7$, $\\mathrm{CFL}=0.20$, $\\alpha_0(x) = 0.3 + 0.2 \\cos(2\\pi x)$。\n- 测试 D (负速度): $N=30$, $u=-1$, $\\mathrm{CFL}=0.25$, $\\alpha_0(x) = 0.5 + 0.49 \\sin(4\\pi x)$。\n\n附加要求：\n- 对每个测试用例，从 $t^0$ 到 $t^1$ 执行恰好一个向前 Euler 时间步。\n- 使用精确的 $L^2$ 投影，通过数值积分（使用足够的 Gaussian 求积点数以解析给定的初始条件）从 $\\alpha_0(x)$ 初始化 $\\{a_{0,i},a_{1,i}\\}$。\n- 为每个测试用例报告两个浮点数：无限制质量误差 $E_{\\mathrm{unlim}}$ 和限制后质量误差 $E_{\\mathrm{lim}}$，每个都表示为一个实数。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目对应一个测试用例，其本身是一个双元素列表 $[E_{\\mathrm{unlim}},E_{\\mathrm{lim}}]$。对每个浮点值使用具有 $12$ 位有效数字的科学记数法。例如，两个假设的测试用例的输出应如下所示：$[[1.234000000000e-12,1.234000000000e-12],[5.678000000000e-14,5.678000000000e-14]]$。",
            "solution": "用户提供了一个计算物理领域中定义明确的问题，具体涉及使用间断 Galerkin (DG) 方法对一维线性平流方程进行数值求解。该问题具有科学依据，需要推导和实现一个标准的数值格式，并包含了所有必要的参数和定义。该问题是有效的，我将着手提供一个完整的解决方案。\n\n### 1. 半离散 DG 公式的推导\n\n控制方程是体积分数场 $\\alpha(x,t)$ 的标量线性平流方程：\n$$\n\\partial_t \\alpha + u \\,\\partial_x \\alpha = 0\n$$\n在周期性定义域 $x \\in [0,1]$ 上，速度 $u$ 为常数。\n\n该域被离散为 $N$ 个单元 $I_i = [x_{i-1/2}, x_{i+1/2}]$，其宽度均匀为 $\\Delta x = 1/N$。在每个单元内，解 $\\alpha(x,t)$ 由一个1次多项式 $\\alpha_i(\\xi, t)$ 近似，其中 $\\xi \\in [-1,1]$ 是通过映射 $x(\\xi) = x_i + (\\Delta x/2)\\xi$ 定义的局部参考坐标，$x_i$ 是单元中心。近似式为：\n$$\n\\alpha_i(\\xi,t) = a_{0,i}(t)\\phi_0(\\xi) + a_{1,i}(t)\\phi_1(\\xi) = a_{0,i}(t) + a_{1,i}(t)\\xi\n$$\n使用正交基函数 $\\phi_0(\\xi)=1$ 和 $\\phi_1(\\xi)=\\xi$。\n\n为推导弱形式，我们将偏微分方程乘以一个检验函数 $\\phi_k(\\xi)$，并在单元 $I_i$ 上积分：\n$$\n\\int_{I_i} (\\partial_t \\alpha_i) \\phi_k \\,dx + \\int_{I_i} u (\\partial_x \\alpha_i) \\phi_k \\,dx = 0\n$$\n变换到参考坐标 $\\xi$（其中 $dx = (\\Delta x/2)d\\xi$ 且 $\\partial_x = (2/\\Delta x)\\partial_\\xi$），我们得到：\n$$\n\\frac{\\Delta x}{2} \\int_{-1}^1 (\\partial_t \\alpha_i) \\phi_k \\,d\\xi + \\frac{\\Delta x}{2} \\int_{-1}^1 u \\left(\\frac{2}{\\Delta x}\\partial_\\xi \\alpha_i\\right) \\phi_k \\,d\\xi = 0\n$$\n对空间项进行分部积分得到：\n$$\n\\int_{-1}^1 u (\\partial_\\xi \\alpha_i) \\phi_k \\,d\\xi = \\left[ u \\, \\alpha_i \\phi_k \\right]_{-1}^{1} - \\int_{-1}^1 u \\alpha_i (\\partial_\\xi \\phi_k) \\,d\\xi\n$$\n边界项 $\\left[ u \\, \\alpha_i \\phi_k \\right]_{-1}^{1}$ 被替换为在单元面处计算的数值通量项。通量 $u\\alpha$ 由 $u\\hat{\\alpha}$ 表示，其中 $\\hat{\\alpha}$ 是 $\\alpha$ 的数值通量。该项变为 $u(\\hat{\\alpha}_{i+1/2}\\phi_k(1) - \\hat{\\alpha}_{i-1/2}\\phi_k(-1))$，其中 $\\hat{\\alpha}_{i\\pm1/2}$ 表示在单元 $i$ 的右/左侧面上的数值通量。\n\n半离散弱形式则为：\n$$\n\\frac{\\Delta x}{2} \\int_{-1}^1 (\\partial_t \\alpha_i) \\phi_k \\,d\\xi + u(\\hat{\\alpha}_{i+1/2}\\phi_k(1) - \\hat{\\alpha}_{i-1/2}\\phi_k(-1)) - u \\int_{-1}^1 \\alpha_i (\\partial_\\xi \\phi_k) \\,d\\xi = 0\n$$\n代入 $\\alpha_i = a_{0,i}\\phi_0 + a_{1,i}\\phi_1$ 并对 $k=0,1$ 进行计算：\n\n**对于 $k=0$ (检验函数 $\\phi_0 = 1$):**\n$\\phi_0(1)=1, \\phi_0(-1)=1, \\partial_\\xi\\phi_0=0$。\n$$\n\\frac{\\Delta x}{2} \\frac{d a_{0,i}}{dt} \\int_{-1}^1 \\phi_0^2 \\,d\\xi + u(\\hat{\\alpha}_{i+1/2} - \\hat{\\alpha}_{i-1/2}) - 0 = 0\n$$\n由于 $\\int_{-1}^1 \\phi_0^2 \\,d\\xi = 2$，上式简化为：\n$$\n\\Delta x \\frac{d a_{0,i}}{dt} = -u (\\hat{\\alpha}_{i+1/2} - \\hat{\\alpha}_{i-1/2})\n$$\n\n**对于 $k=1$ (检验函数 $\\phi_1 = \\xi$):**\n$\\phi_1(1)=1, \\phi_1(-1)=-1, \\partial_\\xi\\phi_1=1$。\n$$\n\\frac{\\Delta x}{2} \\frac{d a_{1,i}}{dt} \\int_{-1}^1 \\phi_1^2 \\,d\\xi + u(\\hat{\\alpha}_{i+1/2} - \\hat{\\alpha}_{i-1/2}(-1)) - u \\int_{-1}^1 (a_{0,i}\\phi_0+a_{1,i}\\phi_1)(\\partial_\\xi \\phi_1) \\,d\\xi = 0\n$$\n由于 $\\int_{-1}^1 \\phi_1^2 \\,d\\xi = 2/3$ 且 $\\int_{-1}^1 (a_{0,i}+a_{1,i}\\xi)(1) \\,d\\xi=2a_{0,i}$：\n$$\n\\frac{\\Delta x}{3} \\frac{d a_{1,i}}{dt} + u(\\hat{\\alpha}_{i+1/2} + \\hat{\\alpha}_{i-1/2}) - 2ua_{0,i} = 0\n$$\n这给出了斜率系数的常微分方程：\n$$\n\\frac{\\Delta x}{3} \\frac{d a_{1,i}}{dt} = -u (\\hat{\\alpha}_{i+1/2} + \\hat{\\alpha}_{i-1/2} - 2a_{0,i})\n$$\n\n### 2. 数值通量与时间步进\n\n问题指定了迎风通量。在单元 $i$ 和 $i+1$ 之间的界面 $x_{i+1/2}$ 处，解有两个值：来自左侧的 $\\alpha_{i+1/2}^- = \\alpha_i(\\xi=1) = a_{0,i} + a_{1,i}$，和来自右侧的 $\\alpha_{i+1/2}^+ = \\alpha_{i+1}(\\xi=-1) = a_{0,i+1} - a_{1,i+1}$。迎风通量为：\n$$\n\\hat{\\alpha}_{i+1/2} = \\begin{cases} \\alpha_{i+1/2}^-  \\text{if } u > 0 \\\\ \\alpha_{i+1/2}^+  \\text{if } u  0 \\end{cases}\n$$\n同样的逻辑适用于界面 $x_{i-1/2}$。我们使用显式向前 Euler 格式进行时间积分：\n$$\n\\mathbf{a}_i^{n+1} = \\mathbf{a}_i^n + \\Delta t \\cdot \\frac{d\\mathbf{a}_i^n}{dt}, \\quad \\text{where } \\mathbf{a}_i = (a_{0,i}, a_{1,i})^T\n$$\n时间步长为 $\\Delta t = \\mathrm{CFL}\\,\\Delta x/|u|$。这导致更新公式为：\n$$\na_{0,i}^{n+1} = a_{0,i}^n - \\frac{u\\Delta t}{\\Delta x} (\\hat{\\alpha}_{i+1/2}^n - \\hat{\\alpha}_{i-1/2}^n)\n$$\n$$\na_{1,i}^{n+1} = a_{1,i}^n - \\frac{3u\\Delta t}{\\Delta x} (\\hat{\\alpha}_{i+1/2}^n + \\hat{\\alpha}_{i-1/2}^n - 2a_{0,i}^n)\n$$\n其中上标 $n$ 表示在时间 $t^n$ 的值。\n\n### 3. $L^2$ 投影初始化\n\n初始系数 $\\{a_{0,i}^0, a_{1,i}^0\\}$ 通过将初始条件 $\\alpha_0(x)$ 在每个单元中投影到 DG 基空间上来确定：\n$$\n\\int_{I_i} \\alpha_i(\\xi,0)\\phi_k(\\xi) \\,dx = \\int_{I_i} \\alpha_0(x)\\phi_k(\\xi) \\,dx \\quad \\text{for } k=0,1\n$$\n由于基函数在 $[-1,1]$ 上的正交性，这为系数提供了显式公式：\n$$\na_{0,i}^0 = \\frac{\\int_{-1}^1 \\alpha_0(x(\\xi)) \\,d\\xi}{\\int_{-1}^1 \\phi_0^2 \\,d\\xi} = \\frac{1}{2} \\int_{-1}^1 \\alpha_0(x_i + \\frac{\\Delta x}{2}\\xi) \\,d\\xi\n$$\n$$\na_{1,i}^0 = \\frac{\\int_{-1}^1 \\alpha_0(x(\\xi))\\xi \\,d\\xi}{\\int_{-1}^1 \\phi_1^2 \\,d\\xi} = \\frac{3}{2} \\int_{-1}^1 \\alpha_0(x_i + \\frac{\\Delta x}{2}\\xi) \\xi \\,d\\xi\n$$\n对于光滑的 $\\alpha_0(x)$，这些积分使用高阶 Gaussian 求积进行计算；对于分段常数情况，则进行解析计算。\n\n### 4. 保界限制器\n\n在无限制的向前 Euler 步进（得到系数 $a_{0,i}^{\\mathrm{unlim}}$ 和 $a_{1,i}^{\\mathrm{unlim}}$）之后，应用一个保界限制器。该限制器确保单元面处的 polynomial 值 $\\alpha_{i}^{L+} = a_{0,i} - a_{1,i}$ 和 $\\alpha_{i}^{R-} = a_{0,i} + a_{1,i}$ 保持在物理边界 $[m, M] = [0, 1]$ 内。限制器保持单元平均值 $a_{0,i}$ 不变，同时将斜率 $a_{1,i}$ 乘以一个因子 $\\theta_i \\in [0,1]$。\n$$\na_{0,i}^{\\mathrm{lim}} = a_{0,i}^{\\mathrm{unlim}}, \\quad a_{1,i}^{\\mathrm{lim}} = \\theta_i a_{1,i}^{\\mathrm{unlim}}\n$$\n其中 $\\theta_i$ 计算如下：\n$$\n\\theta_i \\;=\\; \\min\\left(1,\\; R_1, \\; R_2 \\right)\n$$\n其中\n$$\nR_1 = \\begin{cases} \\frac{a_{0,i}-m}{a_{0,i}-\\min(\\alpha_{i}^{L+},\\alpha_{i}^{R-})}  \\text{if } a_{0,i}\\min(\\alpha_{i}^{L+},\\alpha_{i}^{R-}) \\\\ 1  \\text{otherwise} \\end{cases}\n$$\n$$\nR_2 = \\begin{cases} \\frac{M-a_{0,i}}{\\max(\\alpha_{i}^{L+},\\alpha_{i}^{R-})-a_{0,i}}  \\text{if } a_{0,i}\\max(\\alpha_{i}^{L+},\\alpha_{i}^{R-}) \\\\ 1  \\text{otherwise} \\end{cases}\n$$\n这里的 $a_{0,i}, \\alpha_{i}^{L+}, \\alpha_{i}^{R-}$ 指的是无限制更新后的值。\n\n### 5. 质量守恒分析\n\n在时间 $t^n$ 的总质量为 $M^n = \\sum_{i=1}^{N} a_{0,i}^n \\,\\Delta x$。一个时间步后的全局质量守恒误差为 $E = |M^1 - M^0|$。\n从单元平均值的半离散方程可知，总质量的变化率为：\n$$\n\\frac{dM}{dt} = \\sum_{i=1}^N \\Delta x \\frac{da_{0,i}}{dt} = \\sum_{i=1}^N -u(\\hat{\\alpha}_{i+1/2} - \\hat{\\alpha}_{i-1/2})\n$$\n由于周期性边界条件，这个和是一个伸缩级数，其结果恰好为零。因此，半离散 DG 格式是精确质量守恒的。\n向前 Euler 时间步进在代数上保持了此性质：\n$$\nM^1 - M^0 = \\sum_{i=1}^N \\Delta x (a_{0,i}^1 - a_{0,i}^0) = \\sum_{i=1}^N \\Delta x (\\Delta t \\frac{da_{0,i}^0}{dt}) = \\Delta t \\frac{dM^0}{dt} = 0\n$$\n因此，无限制格式的质量守恒误差 $E_{\\mathrm{unlim}}$ 应在浮点精度范围内为零。\n由于限制器通过仅修改斜率系数 ($a_{0,i}^{\\mathrm{lim}} = a_{0,i}^{\\mathrm{unlim}}$) 来保持守恒性，总质量不受影响。因此，$M^1_{\\mathrm{lim}} = M^1_{\\mathrm{unlim}}$，并且限制后格式的质量守恒误差 $E_{\\mathrm{lim}}$ 预计与 $E_{\\mathrm{unlim}}$ 相同。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import fixed_quad\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the DG solver.\n    \"\"\"\n    # Test cases defined as (N, u, CFL, alpha0_func, case_name)\n    test_cases = [\n        (40, 1.0, 0.20, lambda x: 0.5 + 0.49 * np.sin(2 * np.pi * x), 'A'),\n        (40, 1.0, 0.30, lambda x: 1.0 if x  0.5 else 0.0, 'B'),\n        (1, 0.7, 0.20, lambda x: 0.3 + 0.2 * np.cos(2 * np.pi * x), 'C'),\n        (30, -1.0, 0.25, lambda x: 0.5 + 0.49 * np.sin(4 * np.pi * x), 'D'),\n    ]\n\n    results = []\n    for N, u, CFL, alpha0_func, case_name in test_cases:\n        e_unlim, e_lim = run_dg_step(N, u, CFL, alpha0_func, case_name)\n        results.append([e_unlim, e_lim])\n\n    # Format the final output string\n    formatted_results = []\n    for res_pair in results:\n        formatted_pair = f\"[{res_pair[0]:.12e},{res_pair[1]:.12e}]\"\n        formatted_results.append(formatted_pair)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_dg_step(N, u, CFL, alpha0_func, case_name):\n    \"\"\"\n    Performs a single time step of the P1 Discontinuous Galerkin method.\n    \"\"\"\n    # Quadrature order for initial condition projection\n    QUAD_ORDER = 16\n\n    # --- 1. Setup grid and time step ---\n    dx = 1.0 / N\n    dt = 0.0 if u == 0.0 else CFL * dx / abs(u)\n\n    # Cell centers are used for coordinate mapping in projection\n    x_nodes = np.linspace(0, 1, N + 1)\n    x_centers = x_nodes[:-1] + dx / 2\n\n    # --- 2. Initialize coefficients via L2 projection ---\n    a0 = np.zeros(N)\n    a1 = np.zeros(N)\n\n    if case_name == 'B':  # Analytical initialization for the step function\n        # The discontinuity is at x=0.5, which is an interface for N=40\n        discontinuity_idx = int(round(0.5 / dx))\n        a0[:discontinuity_idx] = 1.0\n        a0[discontinuity_idx:] = 0.0\n        # Slope is zero for a piecewise constant function\n        a1.fill(0.0)\n    else:  # L2 projection using numerical quadrature\n        for i in range(N):\n            # Integrands for projection in reference coordinates\n            integrand_a0 = lambda xi: alpha0_func(x_centers[i] + dx / 2 * xi)\n            integrand_a1 = lambda xi: alpha0_func(x_centers[i] + dx / 2 * xi) * xi\n            \n            # Use fixed-order Gaussian quadrature\n            integral_a0, _ = fixed_quad(integrand_a0, -1.0, 1.0, n=QUAD_ORDER)\n            integral_a1, _ = fixed_quad(integrand_a1, -1.0, 1.0, n=QUAD_ORDER)\n            \n            a0[i] = 0.5 * integral_a0\n            a1[i] = 1.5 * integral_a1\n\n    # --- 3. Calculate initial total mass ---\n    M0 = np.sum(a0) * dx\n\n    # --- 4. Perform a single DG time step (unlimited) ---\n    if u == 0.0:\n        a0_unlim, a1_unlim = a0.copy(), a1.copy()\n    else:\n        # Vectorized implementation using np.roll for periodic boundaries\n        if u > 0:\n            flux_l = np.roll(a0, 1) + np.roll(a1, 1)  # upwind from left neighbor\n            flux_r = a0 + a1                         # upwind from self\n        else:  # u  0\n            flux_l = a0 - a1                         # upwind from self\n            flux_r = np.roll(a0, -1) - np.roll(a1, -1) # upwind from right neighbor\n        \n        cfl_signed = CFL * np.sign(u)\n        \n        # RHS for cell average and slope updates\n        rhs_a0_term = -(flux_r - flux_l)\n        rhs_a1_term = -(flux_r + flux_l - 2 * a0)\n        \n        # Forward Euler update\n        a0_unlim = a0 + cfl_signed * rhs_a0_term\n        a1_unlim = a1 + 3 * cfl_signed * rhs_a1_term\n\n    # --- 5. Calculate mass conservation error for the unlimited solution ---\n    M1_unlim = np.sum(a0_unlim) * dx\n    E_unlim = abs(M1_unlim - M0)\n\n    # --- 6. Apply the bound-preserving limiter ---\n    m, M = 0.0, 1.0\n    \n    # Compute face values from the unlimited update\n    alpha_Lplus = a0_unlim - a1_unlim\n    alpha_Rminus = a0_unlim + a1_unlim\n    \n    min_face_vals = np.minimum(alpha_Lplus, alpha_Rminus)\n    max_face_vals = np.maximum(alpha_Lplus, alpha_Rminus)\n    \n    # Calculate the scaling factor theta\n    theta = np.ones(N)\n    \n    # First ratio for the lower bound\n    den1 = a0_unlim - min_face_vals\n    ratio1 = np.ones_like(a0_unlim)\n    valid_mask1 = den1 > 1e-15  # Check for positive denominator\n    ratio1[valid_mask1] = (a0_unlim[valid_mask1] - m) / den1[valid_mask1]\n    \n    # Second ratio for the upper bound\n    den2 = max_face_vals - a0_unlim\n    ratio2 = np.ones_like(a0_unlim)\n    valid_mask2 = den2 > 1e-15 # Check for positive denominator\n    ratio2[valid_mask2] = (M - a0_unlim[valid_mask2]) / den2[valid_mask2]\n    \n    # Combine the limiters\n    theta = np.minimum(theta, ratio1)\n    theta = np.minimum(theta, ratio2)\n    \n    # Apply the limiter\n    a0_lim = a0_unlim  # Cell average is preserved\n    a1_lim = theta * a1_unlim\n\n    # --- 7. Calculate mass conservation error for the limited solution ---\n    M1_lim = np.sum(a0_lim) * dx\n    E_lim = abs(M1_lim - M0)\n\n    return E_unlim, E_lim\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "高阶方法（如 DG）在模拟具有尖锐界面的流动时，容易在界面附近产生非物理的吉布斯振荡。本练习旨在解决这一难题，您将学习如何实现一个基于模态能量的“问题单元”传感器，并对检测到的单元应用局部谱滤波来抑制振荡 。此项实践对于在保持高阶精度的同时提高解的稳定性和质量至关重要。",
            "id": "3380109",
            "problem": "考虑两相混合物体积分数场 $ \\alpha(x,t) $ 的一维守恒平流，该平流由守恒律 $ \\partial_t \\alpha + \\partial_x (u \\alpha) = 0 $ 控制，其中速度 $ u  0 $ 为正常数。在周期性域 $ x \\in [0,1] $ 上进行计算，并使用非连续伽辽金（DG）方法（Discontinuous Galerkin (DG)），在 $ N_e $ 个均匀单元上使用多项式次数为 $ p $ 的勒让德基函数来表示 $ \\alpha(x,t) $。设初始条件为分段常数体积分数：\n$$\n\\alpha(x,0) = \\begin{cases}\n1,  x \\in [a,b], \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中 $ a = 0.35 $，$ b = 0.65 $，因此初始总质量为 $ \\int_0^1 \\alpha(x,0)\\,dx = b-a $。\n\n使用从基本守恒律和数值通量推导出的 DG 弱形式，通过一个大小为 $ \\Delta t $ 的显式欧拉时间步长来推进模态系数，该步长与 Courant-Friedrichs-Lewy (CFL) 数 $ \\text{CFL} = 0.2 $ 一致，即 $ \\Delta t = \\text{CFL} \\cdot h / u $，其中 $ h = 1/N_e $ 是单元大小。采用与 $ u0 $ 一致的迎风通量。使用具有足够高阶精度的高斯-勒让德求积法来计算投影和内部项所需的所有积分，以确保准确性。\n\n在不使用任何限制器的情况下推进一个时间步后，设计并在检测到的界面附近应用模态空间中的局部谱滤波器，以抑制吉布斯振荡，同时保持 $ \\alpha $ 的守恒平流。使用基于模态能量的界面传感器来定位滤波器，具体为 Persson 型指示器 $ S_e = \\log_{10}\\left( \\frac{|c_{e,p}|^2}{\\sum_{k=0}^{p} |c_{e,k}|^2 + \\varepsilon} \\right) $，其中 $ c_{e,k} $ 是单元 $ e $ 中的模态系数，$ p $ 是最高次数，而 $ \\varepsilon $ 是一个小的正常数以避免除以零。$ S_e $ 大于给定阈值的单元是“问题”单元，必须进行滤波；其他单元保持不变。滤波器必须在谱上作用于模态 $ k=1,\\dots,p $，并且是守恒的，即它保持零阶模态不变以保持单元质量，即滤波后的系数 $ \\tilde{c}_{e,0} = c_{e,0} $。该滤波器族应由强度和阶数参数化，并可选地允许一个非守恒变体，其中零阶模态乘以一个不同于 $ 1 $ 的因子，以说明对质量守恒的影响。\n\n将一个配置的 $ L^1 $ 质量误差定义为时间步和滤波后的总质量与初始质量之间的绝对差，即\n$$\nE_{L^1} = \\left| \\sum_{e=1}^{N_e} h \\, \\tilde{c}_{e,0} \\;-\\; \\sum_{e=1}^{N_e} h \\, c_{e,0}^{\\text{initial}} \\right|,\n$$\n其中 $ \\tilde{c}_{e,0} $ 是推进一个时间步并应用滤波器后的零阶模态系数，$ c_{e,0}^{\\text{initial}} $ 是通过投影获得的初始零阶模态系数。\n\n在您的程序中实现以下内容：\n- 将 $ [0,1] $ 划分为 $ N_e = 20 $ 个单元，次数为 $ p = 5 $。使用 $ u = 1 $ 和 $ \\text{CFL} = 0.2 $。\n- 使用至少 $ 200 $ 个点的高斯-勒让德求积法计算精确的勒让德投影积分，将初始条件投影到模态系数上。\n- 使用带有迎风数值通量的 DG 弱形式，通过一个显式欧拉时间步长推进模态系数，并使用求积法计算精确的内部积分。\n- 在每个单元中计算界面传感器 $ S_e $。\n- 仅在“问题”单元中应用局部谱滤波器。如果配置为保持质量（零阶模态不变），则滤波器必须是守恒的；否则，通过将零阶模态乘以指定因子，使其为非守恒的。滤波器以由强度和阶数参数控制的谱阻尼剖面作用于高阶模态。\n\n设计一个测试套件以评估不同滤波器的行为及其对 $ L^1 $ 质量误差的影响。使用以下测试用例，每个用例由一个元组 $ (\\beta, s, \\text{preserve\\_avg}, \\text{threshold}, \\sigma_0) $ 描述：\n1. $ (0.0, 8, \\text{True}, -2.5, 1.0) $：无滤波。\n2. $ (12.0, 8, \\text{True}, -3.0, 1.0) $：保持零阶模态的中度局部滤波。\n3. $ (36.0, 8, \\text{True}, -2.0, 1.0) $：保持零阶模态的强力局部滤波。\n4. $ (36.0, 8, \\text{False}, -2.0, 0.95) $：不保持零阶模态的强力局部滤波；零阶模态乘以 $ \\sigma_0 = 0.95 $。\n5. $ (12.0, 8, \\text{True}, -10.0, 1.0) $：在所有单元中应用并保持零阶模态的全局滤波。\n\n对于所有情况，将传感器中的小的正常数设置为 $ \\varepsilon = 10^{-14} $。将所有量视为无量纲；不需要物理单位。您的程序应计算每个测试用例的 $ E_{L^1} $，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$ [r_1,r_2,r_3,r_4,r_5] $），其中每个 $ r_i $ 是表示相应测试用例的 $ L^1 $ 质量误差的浮点数。确保输出使用上面测试套件的精确格式和顺序。",
            "solution": "该问题被评估为有效。这是一个在偏微分方程数值方法领域内定义明确、具有科学依据的问题。所有必要的参数和定义都已提供，该任务是实现和分析带谱滤波器的非连续伽辽金（DG）方法的标准练习。\n\n### 1. 非连续伽辽金（DG）公式\n\n该问题考虑一维线性平流方程，这是双曲守恒律的一个原型：\n$$ \\partial_t \\alpha + \\partial_x (u \\alpha) = 0 $$\n其中 $ \\alpha(x,t) $ 是守恒量（体积分数），$ u $ 是一个恒定的正平流速度。空间域为 $ x \\in [0,1] $，具有周期性边界条件。\n\n该域被划分为 $ N_e $ 个不重叠的单元 $ I_e = [x_{e-1/2}, x_{e+1/2}] $，单元大小均匀为 $ h = 1/N_e $。在每个单元上，解 $ \\alpha(x,t) $ 由一个次数为 $ p $ 的多项式在局部参考坐标 $ \\xi = \\frac{x-x_e}{h/2} \\in [-1,1] $ 中近似，其中 $ x_e $ 是单元 $ I_e $ 的中心：\n$$ \\alpha_h(x,t)|_{I_e} = \\sum_{k=0}^{p} c_{e,k}(t) \\phi_k(\\xi) $$\n基函数 $ \\phi_k(\\xi) $ 是标准的勒让德多项式 $ P_k(\\xi) $。系数 $ c_{e,k}(t) $ 是单元 $ e $ 的模态自由度。\n\n为推导系数 $ c_{e,k} $ 的半离散方程，我们将偏微分方程乘以来自同一多项式空间的测试函数 $ v_h $，并在一个单元 $ I_e $ 上积分：\n$$ \\int_{I_e} v_h (\\partial_t \\alpha_h) \\,dx + \\int_{I_e} v_h \\partial_x (u \\alpha_h) \\,dx = 0 $$\n对第二项进行分部积分得到弱形式：\n$$ \\int_{I_e} v_h (\\partial_t \\alpha_h) \\,dx = \\int_{I_e} (u \\alpha_h) (\\partial_x v_h) \\,dx - [ v_h (u \\alpha_h)^* ]_{x_{e-1/2}}^{x_{e+1/2}} $$\n这里，$ (u \\alpha_h)^* $ 是数值通量，这是必需的，因为解 $ \\alpha_h $ 在单元界面处是不连续的。对于 $ u  0 $，使用迎风通量：\n$$ (u \\alpha_h)^*(x_{j+1/2}) = u \\cdot \\alpha_h(x_{j+1/2}^-, t) $$\n其中 $ \\alpha_h(x_{j+1/2}^-, t) $ 是从左侧（即从单元 $ j $ 内部）逼近界面 $ x_{j+1/2} $ 时的解的值。\n\n将 $ \\alpha_h = \\sum_k c_{e,k} \\phi_k $ 和 $ v_h = \\phi_j $ 代入，并变换变量到参考坐标 $ \\xi $，我们得到每个单元 $ e $ 中模态系数的常微分方程（ODE）组：\n$$ \\frac{dc_{e,j}}{dt} = \\frac{2j+1}{h} \\left( u \\sum_{k=0}^p c_{e,k} \\int_{-1}^1 \\phi_k(\\xi) \\phi_j'(\\xi) d\\xi - \\left[ u \\alpha_h^* \\phi_j(\\xi) \\right]_{\\xi=-1}^{\\xi=1} \\right) $$\n积分项可以预先计算并存储在一个刚度矩阵 $ \\mathbf{S} $ 中，其中 $ S_{jk} = \\int_{-1}^1 \\phi_k(\\xi) \\phi_j'(\\xi) d\\xi $。解析上，$ S_{jk} = 2 $ 如果 $ k  j $ 且 $ (j-k) $ 是奇数，否则为 $ 0 $。这导致了常微分方程组的显式表达式，可以用显式欧拉方法进行时间步进。\n\n### 2. 初始条件投影\n\n初始模态系数 $ c_{e,k}(0) $ 是通过将初始条件 $ \\alpha(x,0) $ 在每个单元上 $ L^2 $-投影到勒让德多项式空间上获得的：\n$$ c_{e,k}(0) = \\frac{2k+1}{2} \\int_{-1}^1 \\alpha(x_e + \\frac{h}{2}\\xi, 0) \\phi_k(\\xi) \\,d\\xi $$\n对于分段常数初始条件，这些积分可以在每个单元上解析地计算。然而，为了通用性，使用高阶高斯-勒让德求积法来逼近这些积分。\n\n### 3. 模态滤波器\n\n时间步进后，识别出不连续点（即“问题”单元）。这通过计算每个单元 $ e $ 的模态能量指示器 $ S_e $ 来完成：\n$$ S_e = \\log_{10}\\left( \\frac{|c_{e,p}|^2}{\\sum_{k=0}^{p} |c_{e,k}|^2 + \\varepsilon} \\right) $$\n如果 $ S_e $ 超过预定义的阈值，则该单元被标记为需要滤波。\n\n对标记的单元，应用一个谱滤波器。滤波器通过一个衰减函数 $ \\sigma(k) $ 来修改高阶模态系数：\n$$ \\tilde{c}_{e,k} = \\sigma(k) c_{e,k} \\quad \\text{for } k=1, \\dots, p $$\n其中 $ \\tilde{c}_{e,k} $ 是滤波后的系数。为了质量守恒，零阶模态（单元平均值）保持不变：$ \\tilde{c}_{e,0} = c_{e,0} $。衰减函数的形式为：\n$$ \\sigma(k) = \\exp\\left(-\\beta \\left(\\frac{k}{p}\\right)^s\\right) $$\n其中 $ \\beta $ 是滤波强度，$ s $ 控制衰减剖面的形状。对于非守恒测试用例，零阶模态被修改为 $ \\tilde{c}_{e,0} = \\sigma_0 c_{e,0} $。\n\n### 4. 质量守恒误差\n\n在时间步进和滤波之后，通过比较初始总质量和最终总质量来计算 $ L^1 $ 质量误差。总质量由单元平均值（零阶模态系数）之和给出：\n$$ M(t) = \\sum_{e=1}^{N_e} h \\, c_{e,0}(t) $$\n因此，误差为 $ E_{L^1} = |M(\\Delta t) - M(0)| $。对于守恒滤波器，预计此误差将接近机器精度，因为 DG 格式本身和滤波器都被设计为质量守恒的。对于非守恒滤波器，预计会观察到一个非零误差。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection problem using a Discontinuous Galerkin method\n    and evaluates the L1 mass error for different spectral filtering strategies.\n    \"\"\"\n\n    # Problem Parameters\n    Ne = 20  # Number of elements\n    p = 5    # Polynomial degree\n    u = 1.0  # Advection velocity\n    cfl = 0.2 # CFL number\n    a = 0.35 # Initial condition start\n    b = 0.65 # Initial condition end\n    epsilon_sensor = 1e-14\n\n    # Derived parameters\n    h = 1.0 / Ne\n    dt = cfl * h / u\n    element_boundaries = np.linspace(0, 1, Ne + 1)\n    element_centers = (element_boundaries[:-1] + element_boundaries[1:]) / 2.0\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (beta, s, preserve_avg, threshold, sigma0)\n        (0.0, 8, True, -2.5, 1.0),\n        (12.0, 8, True, -3.0, 1.0),\n        (36.0, 8, True, -2.0, 1.0),\n        (36.0, 8, False, -2.0, 0.95),\n        (12.0, 8, True, -10.0, 1.0),\n    ]\n\n    # Legendre polynomials and derivatives\n    poly_coeffs = [legendre(k) for k in range(p + 1)]\n\n    def eval_poly(coeffs, x):\n        return np.array([c(x) for c in coeffs]).T\n\n    # Pre-compute stiffness matrix S_jk = integral(P_k * P_j') d_xi\n    S = np.zeros((p + 1, p + 1))\n    for j in range(p + 1):\n        for k in range(j):\n            if (j - k) % 2 != 0:\n                S[j, k] = 2.0\n    \n    # Pre-compute values of Legendre polynomials at element boundaries\n    phi_at_plus_one = eval_poly(poly_coeffs, 1.0)\n    phi_at_minus_one = eval_poly(poly_coeffs, -1.0)\n    \n    # Initial Condition function\n    def alpha0(x):\n        return np.where((x >= a)  (x = b), 1.0, 0.0)\n\n    # High-order quadrature for projection\n    nq_proj = 200\n    xi_proj, w_proj = np.polynomial.legendre.leggauss(nq_proj)\n\n    # Initial modal coefficients\n    c0 = np.zeros((Ne, p + 1))\n    for e in range(Ne):\n        x_map = element_centers[e] + 0.5 * h * xi_proj\n        alpha_vals = alpha0(x_map)\n        for k in range(p + 1):\n            pk_vals = poly_coeffs[k](xi_proj)\n            integral_val = np.sum(w_proj * alpha_vals * pk_vals)\n            c0[e, k] = (2 * k + 1) / 2.0 * integral_val\n            \n    initial_mass = np.sum(c0[:, 0]) * h\n    \n    results = []\n    \n    # --- Main loop over test cases ---\n    for beta, s_filter, preserve_avg, threshold, sigma0 in test_cases:\n        \n        # --- DG Time Step ---\n        c_step = np.copy(c0)\n        rhs = np.zeros_like(c_step)\n\n        for e in range(Ne):\n            e_left = (e - 1 + Ne) % Ne\n            \n            # Flux contributions (upwind since u > 0)\n            alpha_right_face_val = np.dot(c_step[e, :], phi_at_plus_one)\n            alpha_left_face_val_neighbor = np.dot(c_step[e_left, :], phi_at_plus_one)\n            \n            # Numerical flux at element boundaries\n            flux_right = u * alpha_right_face_val\n            flux_left = u * alpha_left_face_val_neighbor\n            \n            # Volume integral (stiffness matrix term)\n            vol_integral = u * np.dot(S, c_step[e, :])\n            \n            # Surface integral (flux term)\n            surf_integral = flux_right * phi_at_plus_one - flux_left * phi_at_minus_one\n            \n            # Combine for RHS\n            for j in range(p + 1):\n                mass_inv_factor = (2 * j + 1) / h\n                rhs[e, j] = mass_inv_factor * (vol_integral[j] - surf_integral[j])\n\n        c_step += dt * rhs\n\n        # --- Spectral Filtering ---\n        c_filtered = np.copy(c_step)\n\n        for e in range(Ne):\n            # Compute sensor\n            num_sensor = c_step[e, p]**2\n            den_sensor = np.sum(c_step[e, :]**2) + epsilon_sensor\n            sensor_val = np.log10(num_sensor / den_sensor)\n\n            if sensor_val > threshold:\n                # This is a troubled element, apply filter\n                for k in range(1, p + 1):\n                    sigma_k = np.exp(-beta * (k / p)**s_filter)\n                    c_filtered[e, k] = sigma_k * c_step[e, k]\n\n                if not preserve_avg:\n                    c_filtered[e, 0] = sigma0 * c_step[e, 0]\n        \n        # --- L1 Mass Error Calculation ---\n        final_mass = np.sum(c_filtered[:, 0]) * h\n        l1_mass_error = np.abs(final_mass - initial_mass)\n        results.append(l1_mass_error)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "超越简单的平流，多相流的真实物理过程通常由表面张力主导，而表面张力的大小取决于界面的曲率。本练习聚焦于从离散的水平集函数（level-set）中精确计算曲率这一几何挑战，您将通过一个静态气泡测试案例，研究不同多项式阶数（$p$）对曲率精度和所产生的非物理“伪力”的影响 。掌握这项技能是成功模拟毛细驱动流的关键一步。",
            "id": "3380182",
            "problem": "考虑一个在多相流的间断 Galerkin (DG) 方法背景下的二维静态气泡测试。界面由定义在方形域 $[-L,L]^2$（其中 $L=1.5$）上的水平集函数表示。设水平集函数为 $\\phi(x,y) = \\sqrt{x^2 + y^2} - R$，气泡半径 $R=1$，并假设表面张力系数为 $\\sigma=1$。精确界面是圆周 $\\{(x,y) \\mid \\phi(x,y) = 0\\}$，沿界面的精确曲率为 $\\kappa_{\\text{exact}} = 1$（对于圆的二维曲率），由此产生的精确拉普拉斯压力跳跃为 $\\Delta p_{\\text{exact}} = \\sigma \\kappa_{\\text{exact}} = 1$。\n\n从基本定义出发：\n- 在水平集公式中，曲率由 $\\kappa = \\nabla \\cdot \\left(\\dfrac{\\nabla \\phi}{\\|\\nabla \\phi\\|}\\right)$ 给出。\n- 在二维中，单位厚度的净表面张力为 $\\mathbf{F} = \\oint_{\\phi=0} \\sigma \\kappa \\mathbf{n}\\, \\mathrm{d}s$，其中 $\\mathbf{n}$ 是单位法向量，$\\mathrm{d}s$ 是沿界面的线元。\n- 沿圆周的线元是 $\\mathrm{d}s = R\\,\\mathrm{d}\\theta$，精确圆周的单位法向量是 $\\mathbf{n}_{\\text{exact}} = [\\cos\\theta, \\sin\\theta]^\\top$。\n\n在 $[-L,L]^2$ 上使用间断 Galerkin 逼近，该逼近采用尺寸为 $h=0.3$ 的方形单元组成的固定均匀笛卡尔网格。在每个单元中，通过使用高斯-勒让德求积点进行加权最小二乘拟合，用局部坐标系中总次数为 $p$ 的多项式来逼近 $\\phi$。设局部坐标 $(\\xi,\\eta) \\in [-1,1]^2$ 通过仿射映射到每个单元，多项式逼近为\n$$\n\\phi_h(\\xi,\\eta) = \\sum_{i+j \\le p} c_{ij} \\,\\xi^i \\eta^j.\n$$\n系数 $c_{ij}$ 是通过在每个单元内最小化与在阶数为 $n_q=p+2$ 的张量积高斯-勒让德点上计算的精确 $\\phi$ 值的求积加权最小二乘失配来确定的。梯度和黑塞矩阵从 $\\phi_h$ 解析获得，物理空间导数通过仿射映射的链式法则得出。曲率逼近从 $\\phi_h$ 逐点计算，公式为\n$$\n\\kappa_h = \\frac{\\phi_{xx}\\,\\phi_y^2 - 2\\,\\phi_x\\,\\phi_y\\,\\phi_{xy} + \\phi_{yy}\\,\\phi_x^2}{\\left(\\phi_x^2 + \\phi_y^2\\right)^{3/2}}.\n$$\n\n使用 DG 逼近按如下方式评估曲率和力：\n- 在 $N_\\theta=720$ 个均匀分布的角度 $\\theta \\in [0,2\\pi)$ 上对界面进行采样（角度以弧度为单位）。\n- 对于每个采样点 $(x,y) = (R\\cos\\theta, R\\sin\\theta)$，选择包含 $(x,y)$ 的单元，在该点评估 $\\phi_h$ 及其导数，计算 $\\kappa_h$，并计算 DG 单位法向量 $\\mathbf{n}_h = \\dfrac{\\nabla \\phi_h}{\\|\\nabla \\phi_h\\|}$。\n- 通过 $\\theta$ 的复合梯形法则来逼近线积分（对于光滑被积函数，在圆上进行等距采样时，该法则是精确的），即使用均匀权重 $\\mathrm{d}s = R\\,\\mathrm{d}\\theta$。\n\n对于固定的 $h$，为每个多项式次数 $p \\in \\{2,3,5\\}$ 计算：\n1. 界面曲率的 $L^2$ 误差\n$$\nE_\\kappa(p) = \\sqrt{\\frac{1}{2\\pi R}\\int_{0}^{2\\pi} \\left(\\kappa_h(\\theta) - \\kappa_{\\text{exact}}\\right)^2 R\\, \\mathrm{d}\\theta}.\n$$\n2. 净表面张力的模\n$$\n\\|\\mathbf{F}(p)\\| = \\left\\|\\int_{0}^{2\\pi} \\sigma\\,\\kappa_h(\\theta)\\,\\mathbf{n}_h(\\theta)\\, R\\, \\mathrm{d}\\theta\\right\\|.\n$$\n\n假设全程使用无量纲单位（除了给定的无量纲参数外，不需要物理单位），并使用弧度作为角度单位。您的程序应实现上述 DG 逼近，并针对测试集 $p \\in \\{2,3,5\\}$，报告每个 $p$ 对应的两个指标 $E_\\kappa(p)$ 和 $\\|\\mathbf{F}(p)\\|$（作为浮点数）。\n\n测试集：\n- 情况 1 (happy path): $p=2$。\n- 情况 2 (提高精度): $p=3$。\n- 情况 3 (高阶边缘情况): $p=5$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个由三个列表组成的逗号分隔列表，每个内部列表按 $p=2, p=3, p=5$ 的顺序包含 $[E_\\kappa(p), \\|\\mathbf{F}(p)\\|]$。例如，输出应如下所示：\n$[[e_2,f_2],[e_3,f_3],[e_5,f_5]]$。",
            "solution": "所提出的问题是有效的，因为它具有科学依据、适定且客观。它在计算流体力学这一成熟领域内指定了一项清晰的数值任务，提供了构建唯一解所需的所有必要参数、方程和定义。\n\n该解决方案涉及实现一种间断 Galerkin (DG) 方法来逼近水平集函数，并由此推导出圆形界面的几何量。该过程分为几个逻辑步骤：\n\n1.  **域离散化和局部坐标系**：\n    计算域是一个由 $[-L, L]^2 = [-1.5, 1.5]^2$ 定义的正方形，它被划分为一个由 $10 \\times 10$ 个方形单元组成的均匀笛卡尔网格。每个单元的边长为 $h=0.3$。在每个单元内部，定义了一个局部坐标系 $(\\xi, \\eta) \\in [-1, 1]^2$。从这个局部坐标系到以 $(x_c, y_c)$ 为中心的单元的全局物理坐标 $(x,y)$ 的转换是一个仿射映射：\n    $$\n    x = x_c + \\frac{h}{2}\\xi, \\quad y = y_c + \\frac{h}{2}\\eta\n    $$\n\n2.  **分片多项式逼近**：\n    在每个单元中，精确的水平集函数 $\\phi(x,y) = \\sqrt{x^2 + y^2} - R$ 被一个总次数为 $p$ 的多项式 $\\phi_h(\\xi, \\eta)$ 所逼近。该多项式由满足 $i+j \\le p$ 的单项式基 $\\{\\xi^i \\eta^j\\}$ 构建：\n    $$\n    \\phi_h(\\xi,\\eta) = \\sum_{i+j \\le p} c_{ij} \\,\\xi^i \\eta^j\n    $$\n    系数 $c_{ij}$ 对每个单元都是唯一的，并通过加权最小二乘拟合确定。此拟合在单元内一个 $n_q \\times n_q$ 的张量积高斯-勒让德求积点网格上，最小化 $\\phi_h$ 与精确函数 $\\phi$ 之间的差异，其中 $n_q = p+2$。最小化问题是：\n    $$\n    \\min_{c_{ij}} \\sum_{k=1}^{n_q^2} w_k \\left( \\phi_h(\\xi_k, \\eta_k) - \\phi(x_k, y_k) \\right)^2\n    $$\n    其中 $(\\xi_k, \\eta_k)$ 是求积节点的局部坐标，$(x_k, y_k)$ 是相应的物理坐标，而 $w_k$ 是求积权重。该公式导致每个单元中关于系数 $c_{ij}$ 的一个超定线性系统，该系统使用标准最小二乘算法求解。\n\n3.  **物理导数的计算**：\n    一旦在每个单元中建立了多项式逼近 $\\phi_h$，就需要其在物理坐标系中的空间导数 $(\\phi_x, \\phi_y, \\phi_{xx}, \\phi_{xy}, \\phi_{yy})$ 来计算曲率。这些导数是通过首先对多项式 $\\phi_h$ 关于局部坐标 $(\\xi, \\eta)$ 进行解析微分，然后应用链式法则得到的。给定仿射映射，导数通过与单元尺寸 $h$ 相关的常数因子进行变换：\n    $$\n    \\phi_x = \\frac{\\partial \\phi_h}{\\partial x} = \\frac{2}{h} \\frac{\\partial \\phi_h}{\\partial \\xi}, \\quad \\phi_y = \\frac{\\partial \\phi_h}{\\partial y} = \\frac{2}{h} \\frac{\\partial \\phi_h}{\\partial \\eta}\n    $$\n    $$\n    \\phi_{xx} = \\frac{\\partial^2 \\phi_h}{\\partial x^2} = \\left(\\frac{2}{h}\\right)^2 \\frac{\\partial^2 \\phi_h}{\\partial \\xi^2}, \\quad \\phi_{xy} = \\frac{\\partial^2 \\phi_h}{\\partial x \\partial y} = \\left(\\frac{2}{h}\\right)^2 \\frac{\\partial^2 \\phi_h}{\\partial \\xi \\partial \\eta}, \\quad \\phi_{yy} = \\frac{\\partial^2 \\phi_h}{\\partial y^2} = \\left(\\frac{2}{h}\\right)^2 \\frac{\\partial^2 \\phi_h}{\\partial \\eta^2}\n    $$\n    利用这些导数，可以使用曲率以水平集导数表示的定义，在任意点计算近似曲率 $\\kappa_h$。\n\n4.  **通过数值积分评估指标**：\n    两个目标指标，即 $L^2$ 曲率误差 $E_\\kappa(p)$ 和净表面张力的模 $\\|\\mathbf{F}(p)\\|$，被定义为沿界面 $\\phi=0$ 的线积分。这些积分通过数值方法进行逼近。精确的圆形界面在 $N_\\theta = 720$ 个等距点上进行采样，这些点由 $(x_k, y_k) = (R\\cos\\theta_k, R\\sin\\theta_k)$ 给出，其中 $k=0, \\dots, N_\\theta-1$。在每个采样点，执行以下步骤：\n    a. 识别包含 $(x_k, y_k)$ 的单元。\n    b. 将物理坐标映射到该单元的局部坐标 $(\\xi_k, \\eta_k)$。\n    c. 使用该单元存储的系数 $c_{ij}$ 来评估 $\\phi_h$ 的导数，从而计算出近似曲率 $\\kappa_h(\\theta_k)$ 和法向量 $\\mathbf{n}_h(\\theta_k)$。\n    \n    然后将积分近似为在这些采样点上的求和。$L^2$ 曲率误差计算为曲率样本的均方根 (RMS) 误差：\n    $$\n    E_\\kappa(p) = \\sqrt{\\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} (\\kappa_h(\\theta_k) - \\kappa_{\\text{exact}})^2}\n    $$\n    净力向量 $\\mathbf{F}(p)$ 通过基于复合梯形法则的求和来逼近，对于均匀采样，该法则简化为：\n    $$\n    \\mathbf{F}(p) \\approx \\sum_{k=0}^{N_\\theta-1} \\sigma\\,\\kappa_h(\\theta_k)\\,\\mathbf{n}_h(\\theta_k)\\, R \\Delta\\theta, \\quad \\text{where } \\Delta\\theta = \\frac{2\\pi}{N_\\theta}\n    $$\n    然后计算这个结果向量的模 $\\|\\mathbf{F}(p)\\|$。对每个多项式次数 $p \\in \\{2, 3, 5\\}$ 执行这整个计算过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\nimport math\n\ndef _get_basis_indices(p):\n    \"\"\"Generates basis monomial powers (i, j) for total degree p.\"\"\"\n    indices = []\n    for total_degree in range(p + 1):\n        for i in range(total_degree + 1):\n            j = total_degree - i\n            indices.append((i, j))\n    return indices\n\ndef _eval_basis_derivatives(xi, eta, basis_indices, deriv_xi, deriv_eta):\n    \"\"\"\n    Evaluates the derivatives of basis functions at a point (xi, eta).\n    Returns a vector of derivative values for all basis functions.\n    \"\"\"\n    values = np.zeros(len(basis_indices))\n    for k, (i, j) in enumerate(basis_indices):\n        if i  deriv_xi or j  deriv_eta:\n            val = 0.0\n        else:\n            term_xi = math.perm(i, deriv_xi) * (xi ** (i - deriv_xi))\n            term_eta = math.perm(j, deriv_eta) * (eta ** (j - deriv_eta))\n            val = term_xi * term_eta\n        values[k] = val\n    return values\n\ndef _get_element_coeffs(p, L, R, H):\n    \"\"\"\n    Computes the polynomial coefficients for phi_h in each element.\n    \"\"\"\n    n_q = p + 2\n    basis_indices = _get_basis_indices(p)\n    num_basis_fns = len(basis_indices)\n\n    num_elements_dim = int(round(2 * L / H))\n    coeffs_grid = np.zeros((num_elements_dim, num_elements_dim, num_basis_fns))\n    \n    xi_q, w_q = roots_legendre(n_q)\n    xi_q_2d, eta_q_2d = np.meshgrid(xi_q, xi_q)\n    quad_points_local = np.vstack([xi_q_2d.ravel(), eta_q_2d.ravel()]).T\n    w_q_2d = np.outer(w_q, w_q).ravel()\n\n    A = np.zeros((n_q**2, num_basis_fns))\n    for i in range(n_q**2):\n        xi_val, eta_val = quad_points_local[i]\n        A[i, :] = _eval_basis_derivatives(xi_val, eta_val, basis_indices, 0, 0)\n    \n    A_w = A * np.sqrt(w_q_2d)[:, np.newaxis]\n\n    for i in range(num_elements_dim):\n        for j in range(num_elements_dim):\n            xc = -L + H * (i + 0.5)\n            yc = -L + H * (j + 0.5)\n            \n            x_phys = xc + (H / 2) * quad_points_local[:, 0]\n            y_phys = yc + (H / 2) * quad_points_local[:, 1]\n            \n            phi_exact_vals = np.sqrt(x_phys**2 + y_phys**2) - R\n            b_w = phi_exact_vals * np.sqrt(w_q_2d)\n            \n            c, _, _, _ = np.linalg.lstsq(A_w, b_w, rcond=None)\n            coeffs_grid[i, j, :] = c\n            \n    return coeffs_grid, basis_indices\n\ndef _compute_metrics_for_p(p, L, R, H, SIGMA, N_THETA, KAPPA_EXACT, coeffs_grid, basis_indices):\n    \"\"\"\n    Computes curvature error and net force magnitude for a given polynomial degree p.\n    \"\"\"\n    num_elements_dim = int(round(2 * L / H))\n    \n    theta = np.linspace(0, 2 * np.pi, N_THETA, endpoint=False)\n    x_s, y_s = R * np.cos(theta), R * np.sin(theta)\n\n    kappa_h_vals = np.zeros(N_THETA)\n    force_integrand_vals = np.zeros((N_THETA, 2))\n\n    for k in range(N_THETA):\n        x, y = x_s[k], y_s[k]\n        \n        i = int(np.floor((x + L) / H))\n        j = int(np.floor((y + L) / H))\n        i = min(max(i, 0), num_elements_dim - 1)\n        j = min(max(j, 0), num_elements_dim - 1)\n        \n        xc = -L + H * (i + 0.5)\n        yc = -L + H * (j + 0.5)\n        xi = (x - xc) / (H / 2)\n        eta = (y - yc) / (H / 2)\n        \n        c = coeffs_grid[i, j, :]\n        \n        deriv_vectors = {\n            (1, 0): _eval_basis_derivatives(xi, eta, basis_indices, 1, 0),\n            (0, 1): _eval_basis_derivatives(xi, eta, basis_indices, 0, 1),\n            (2, 0): _eval_basis_derivatives(xi, eta, basis_indices, 2, 0),\n            (1, 1): _eval_basis_derivatives(xi, eta, basis_indices, 1, 1),\n            (0, 2): _eval_basis_derivatives(xi, eta, basis_indices, 0, 2),\n        }\n        \n        phi_h_xi = np.dot(c, deriv_vectors[(1, 0)])\n        phi_h_eta = np.dot(c, deriv_vectors[(0, 1)])\n        phi_h_xixi = np.dot(c, deriv_vectors[(2, 0)])\n        phi_h_xieta = np.dot(c, deriv_vectors[(1, 1)])\n        phi_h_etaeta = np.dot(c, deriv_vectors[(0, 2)])\n        \n        h_inv2 = 2.0 / H\n        h_inv2_sq = h_inv2**2\n        \n        phi_x = phi_h_xi * h_inv2\n        phi_y = phi_h_eta * h_inv2\n        phi_xx = phi_h_xixi * h_inv2_sq\n        phi_xy = phi_h_xieta * h_inv2_sq\n        phi_yy = phi_h_etaeta * h_inv2_sq\n        \n        phi_x2 = phi_x**2\n        phi_y2 = phi_y**2\n        denom = (phi_x2 + phi_y2)**1.5\n        \n        kappa_h = (phi_xx*phi_y2 - 2*phi_x*phi_y*phi_xy + phi_yy*phi_x2) / denom if denom > 1e-12 else 0.0\n        kappa_h_vals[k] = kappa_h\n        \n        grad_phi_norm = np.sqrt(phi_x2 + phi_y2)\n        n_h = np.array([phi_x, phi_y]) / grad_phi_norm if grad_phi_norm > 1e-12 else np.array([0.0, 0.0])\n        force_integrand_vals[k, :] = SIGMA * kappa_h * n_h\n        \n    error_sq = (kappa_h_vals - KAPPA_EXACT)**2\n    E_kappa = np.sqrt(np.mean(error_sq))\n    \n    d_theta = 2 * np.pi / N_THETA\n    F_net_vec = np.sum(force_integrand_vals, axis=0) * R * d_theta\n    F_norm = np.linalg.norm(F_net_vec)\n    \n    return [E_kappa, F_norm]\n\ndef solve():\n    # Define test cases\n    test_cases = [2, 3, 5]  # Polynomial degrees p\n\n    # --- Problem Constants ---\n    L = 1.5\n    R = 1.0\n    SIGMA = 1.0\n    H = 0.3\n    N_THETA = 720\n    KAPPA_EXACT = 1.0\n    \n    results = []\n    for p in test_cases:\n        coeffs_grid, basis_indices = _get_element_coeffs(p, L, R, H)\n        metrics = _compute_metrics_for_p(p, L, R, H, SIGMA, N_THETA, KAPPA_EXACT, coeffs_grid, basis_indices)\n        results.append(metrics)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}