{
    "hands_on_practices": [
        {
            "introduction": "像不连续伽辽金 (DG) 法这样的高阶方法在处理多相流中常见的尖锐界面时，会产生非物理性的吉布斯振荡 (Gibbs phenomenon)。本练习将指导您实现一种局部谱滤波器，这是一种在抑制这些振荡的同时，又能保持该方法在光滑区域高阶精度的常用技术。您将学习如何使用“问题单元”指示器，仅在需要时应用滤波器，从而确保计算的效率和准确性 。",
            "id": "3380109",
            "problem": "考虑二维相混合物的体积分数场 $ \\alpha(x,t) $ 的一维守恒平流，该过程由守恒律 $ \\partial_t \\alpha + \\partial_x (u \\alpha) = 0 $ 控制，其中速度 $ u > 0 $ 为正常数。计算在周期性域 $ x \\in [0,1] $ 上进行，并使用间断伽辽金（DG）方法，在 $ N_e $ 个均匀单元上使用 $ p $ 次勒让德基函数来表示 $ \\alpha(x,t) $。设初始条件为分段常数体积分数：\n$$\n\\alpha(x,0) = \\begin{cases}\n1,  x \\in [a,b], \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中 $ a = 0.35 $ 且 $ b = 0.65 $，因此初始总质量为 $ \\int_0^1 \\alpha(x,0)\\,dx = b-a $。\n\n使用从基本守恒律和数值通量推导出的DG弱形式，通过一个大小为 $ \\Delta t $ 的显式欧拉时间步来推进模态系数。该时间步长与Courant-Friedrichs-Lewy (CFL)数 $ \\text{CFL} = 0.2 $ 一致，即 $ \\Delta t = \\text{CFL} \\cdot h / u $，其中 $ h = 1/N_e $ 是单元尺寸。采用与 $ u>0 $ 一致的迎风通量。使用阶数足够高的高斯-勒让德求积来表示投影和内部项所需的所有积分，以确保精度。\n\n在不使用任何限制器的情况下推进一个时间步后，设计并应用一个在检测到的界面附近的模态空间中的局部谱滤波器，以抑制吉布斯振荡，同时保持 $ \\alpha $ 的守恒平流。使用基于模态能量的界面传感器来定位滤波器，具体为一个Persson型指示器 $ S_e = \\log_{10}\\left( \\frac{|c_{e,p}|^2}{\\sum_{k=0}^{p} |c_{e,k}|^2 + \\varepsilon} \\right) $，其中 $ c_{e,k} $ 是单元 $ e $ 中的模态系数，$ p $ 是最高次数，$ \\varepsilon $ 是一个小的正常数以避免除以零。$ S_e $ 大于给定阈值的单元被视为“问题”单元，必须进行滤波；其他单元保持不变。该滤波器必须在谱上作用于模态 $ k=1,\\dots,p $，并且在保留零阶模态不变的意义上是守恒的，以保持单元质量，即滤波后的系数 $ \\tilde{c}_{e,0} = c_{e,0} $。该滤波器族应由一个强度和一个阶数参数化，并可选地允许一个非守恒变体，其中零阶模态乘以一个不同于 $ 1 $ 的因子，以说明其对质量守恒的影响。\n\n将一个配置的 $ L^1 $ 质量误差定义为时间步推进和滤波后的总质量与初始质量之间的绝对差，即\n$$\nE_{L^1} = \\left| \\sum_{e=1}^{N_e} h \\, \\tilde{c}_{e,0} \\;-\\; \\sum_{e=1}^{N_e} h \\, c_{e,0}^{\\text{initial}} \\right|,\n$$\n其中 $ \\tilde{c}_{e,0} $ 是推进一个时间步并应用滤波器后的零阶模态系数，$ c_{e,0}^{\\text{initial}} $ 是通过投影得到的初始零阶模态系数。\n\n在您的程序中实现以下内容：\n- 将 $ [0,1] $ 划分为 $ N_e = 20 $ 个单元，次数为 $ p = 5 $。使用 $ u = 1 $ 和 $ \\text{CFL} = 0.2 $。\n- 使用至少 $ 200 $ 个点的高斯-勒让德求积计算精确的勒让德投影积分，将初始条件投影到模态系数上。\n- 使用带有迎风数值通量和通过求积计算的精确内部积分的DG弱形式，通过一个显式欧拉时间步推进模态系数。\n- 在每个单元中计算界面传感器 $ S_e $。\n- 仅在“问题”单元中应用局部谱滤波器。如果配置为保持质量（零阶模态不变），则滤波器必须是守恒的；否则，通过将零阶模态乘以指定因子，使其为非守恒。该滤波器以由强度和阶数参数控制的谱阻尼剖面作用于高阶模态。\n\n设计一个测试套件以评估不同滤波器行为及其对 $ L^1 $ 质量误差的影响。使用以下测试用例，每个用例由一个元组 $ (\\beta, s, \\text{preserve\\_avg}, \\text{threshold}, \\sigma_0) $ 描述：\n1. $ (0.0, 8, \\text{True}, -2.5, 1.0) $: 无滤波。\n2. $ (12.0, 8, \\text{True}, -3.0, 1.0) $: 保留零阶模态的中等强度局部滤波。\n3. $ (36.0, 8, \\text{True}, -2.0, 1.0) $: 保留零阶模态的强局部滤波。\n4. $ (36.0, 8, \\text{False}, -2.0, 0.95) $: 不保留零阶模态的强局部滤波；零阶模态乘以 $ \\sigma_0 = 0.95 $。\n5. $ (12.0, 8, \\text{True}, -10.0, 1.0) $: 在所有单元中应用保留零阶模态的全局滤波。\n\n对于所有情况，将传感器中的小正常数设置为 $ \\varepsilon = 10^{-14} $。将所有量视为无量纲；不需要物理单位。您的程序应为每个测试用例计算 $ E_{L^1} $，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$ [r_1,r_2,r_3,r_4,r_5] $），其中每个 $ r_i $ 是一个浮点数，代表相应测试用例的 $ L^1 $ 质量误差。确保输出使用上面测试套件的精确格式和顺序。",
            "solution": "该问题被评估为有效。这是一个在偏微分方程数值方法领域中定义明确、具有科学依据的问题。所有必要的参数和定义都已提供，该任务是实现和分析带谱滤波器的间断伽辽金（DG）方法的标准练习。\n\n### 1. 间断伽辽金（DG）公式\n\n该问题考虑一维线性平流方程，这是一个双曲守恒律的原型：\n$$ \\partial_t \\alpha + \\partial_x (u \\alpha) = 0 $$\n其中 $ \\alpha(x,t) $ 是守恒量（体积分数），$ u $ 是一个恒定的正平流速度。空间域为 $ x \\in [0,1] $，具有周期性边界条件。\n\n将域划分为 $ N_e $ 个不重叠的单元 $ I_e = [x_{e-1/2}, x_{e+1/2}] $，其大小均匀为 $ h = 1/N_e $。在每个单元上，解 $ \\alpha(x,t) $ 由一个在局部参考坐标 $ \\xi = \\frac{x-x_e}{h/2} \\in [-1,1] $ 中的 $ p $ 次多项式近似，其中 $ x_e $ 是单元 $ I_e $ 的中心：\n$$ \\alpha_h(x,t)|_{I_e} = \\sum_{k=0}^{p} c_{e,k}(t) \\phi_k(\\xi) $$\n基函数 $ \\phi_k(\\xi) $ 是标准的勒让德多项式 $ P_k(\\xi) $。系数 $ c_{e,k}(t) $ 是单元 $ e $ 的模态自由度。\n\n为了推导系数 $ c_{e,k} $ 的半离散方程，我们将偏微分方程乘以一个来自相同多项式空间的测试函数 $ v_h $，并在一个单元 $ I_e $ 上积分：\n$$ \\int_{I_e} v_h (\\partial_t \\alpha_h) \\,dx + \\int_{I_e} v_h \\partial_x (u \\alpha_h) \\,dx = 0 $$\n对第二项进行分部积分，得到弱形式：\n$$ \\int_{I_e} v_h (\\partial_t \\alpha_h) \\,dx = \\int_{I_e} (u \\alpha_h) (\\partial_x v_h) \\,dx - [ v_h (u \\alpha_h)^* ]_{x_{e-1/2}}^{x_{e+1/2}} $$\n这里，$ (u \\alpha_h)^* $ 是数值通量，这是必需的，因为解 $ \\alpha_h $ 在单元界面处是不连续的。对于 $ u > 0 $，使用迎风通量：\n$$ (u \\alpha_h)^*(x_{j+1/2}) = u \\cdot \\alpha_h(x_{j+1/2}^-, t) $$\n其中 $ \\alpha_h(x_{j+1/2}^-, t) $ 是从左侧（即从单元 $ j $ 内部）逼近界面 $ x_{j+1/2} $ 时的解的值。\n\n代入 $ \\alpha_h = \\sum_k c_{e,k} \\phi_k $ 和 $ v_h = \\phi_j $，并变换到参考坐标 $ \\xi $，我们得到了每个单元 $ e $ 中模态系数的常微分方程（ODE）组：\n$$ \\frac{dc_{e,j}}{dt} = \\frac{2j+1}{h} \\left( u \\sum_{k=0}^p c_{e,k} \\int_{-1}^1 \\phi_k(\\xi) \\phi_j'(\\xi) d\\xi - \\left[ u \\alpha_h^* \\phi_j(\\xi) \\right]_{\\xi=-1}^{\\xi=1} \\right) $$\n积分项可以预先计算并存储在刚度矩阵 $ \\mathbf{S} $ 中，其中 $ S_{jk} = \\int_{-1}^1 \\phi_k(\\xi) \\phi_j'(\\xi) d\\xi $。解析上，$ S_{jk} = 2 $ 如果 $k  j$ 且 $j-k$ 为奇数，否则为0。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection problem using a Discontinuous Galerkin method\n    and evaluates the L1 mass error for different spectral filtering strategies.\n    \"\"\"\n\n    # Problem Parameters\n    Ne = 20  # Number of elements\n    p = 5    # Polynomial degree\n    u = 1.0  # Advection velocity\n    cfl = 0.2 # CFL number\n    a = 0.35 # Initial condition start\n    b = 0.65 # Initial condition end\n    epsilon_sensor = 1e-14\n\n    # Derived parameters\n    h = 1.0 / Ne\n    dt = cfl * h / u\n    element_boundaries = np.linspace(0, 1, Ne + 1)\n    element_centers = (element_boundaries[:-1] + element_boundaries[1:]) / 2.0\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (beta, s, preserve_avg, threshold, sigma0)\n        (0.0, 8, True, -2.5, 1.0),\n        (12.0, 8, True, -3.0, 1.0),\n        (36.0, 8, True, -2.0, 1.0),\n        (36.0, 8, False, -2.0, 0.95),\n        (12.0, 8, True, -10.0, 1.0),\n    ]\n\n    # Legendre polynomials and derivatives\n    poly_coeffs = [legendre(k) for k in range(p + 1)]\n    deriv_coeffs = [p.deriv() for p in poly_coeffs]\n\n    def eval_poly(coeffs, x):\n        return np.array([c(x) for c in coeffs]).T\n\n    # Pre-compute stiffness matrix S_jk = integral(P_k * P_j') dx\n    S = np.zeros((p + 1, p + 1))\n    for j in range(p + 1):\n        for k in range(j):\n            if (j - k) % 2 != 0:\n                S[j, k] = 2.0\n    \n    # Pre-compute values of Legendre polynomials at element boundaries\n    phi_at_plus_one = eval_poly(poly_coeffs, 1.0)\n    phi_at_minus_one = eval_poly(poly_coeffs, -1.0)\n    \n    # Initial Condition function\n    def alpha0(x):\n        return np.where((x = a)  (x = b), 1.0, 0.0)\n\n    # High-order quadrature for projection\n    nq_proj = 200\n    xi_proj, w_proj = np.polynomial.legendre.leggauss(nq_proj)\n\n    # Initial modal coefficients\n    c0 = np.zeros((Ne, p + 1))\n    for e in range(Ne):\n        x_map = element_centers[e] + 0.5 * h * xi_proj\n        alpha_vals = alpha0(x_map)\n        for k in range(p + 1):\n            pk_vals = poly_coeffs[k](xi_proj)\n            integral_val = np.sum(w_proj * alpha_vals * pk_vals)\n            c0[e, k] = (2 * k + 1) / 2.0 * integral_val\n            \n    initial_mass = np.sum(c0[:, 0]) * h\n    \n    results = []\n    \n    # --- Main loop over test cases ---\n    for beta, s_filter, preserve_avg, threshold, sigma0 in test_cases:\n        \n        # --- DG Time Step ---\n        c_step = np.copy(c0)\n        rhs = np.zeros_like(c_step)\n\n        for e in range(Ne):\n            e_left = (e - 1 + Ne) % Ne\n            \n            # Flux contributions\n            alpha_right = np.dot(c_step[e, :], phi_at_plus_one)\n            alpha_left = np.dot(c_step[e_left, :], phi_at_plus_one)\n            \n            # Volume integral (stiffness matrix term)\n            vol_integral = u * np.dot(S, c_step[e, :])\n            \n            # Surface integral (flux term)\n            surf_integral = u * (alpha_right * phi_at_plus_one - alpha_left * phi_at_minus_one)\n            \n            # Combine for RHS\n            for j in range(p + 1):\n                mass_inv = (2 * j + 1) / h\n                rhs[e, j] = mass_inv * (vol_integral[j] - surf_integral[j])\n\n        c_step += dt * rhs\n\n        # --- Spectral Filtering ---\n        c_filtered = np.copy(c_step)\n\n        for e in range(Ne):\n            # Compute sensor\n            num = c_step[e, p]**2\n            den = np.sum(c_step[e, :]**2) + epsilon_sensor\n            sensor_val = np.log10(num / den)\n\n            if sensor_val  threshold:\n                # This is a troubled element, apply filter\n                for k in range(1, p + 1):\n                    sigma_k = np.exp(-beta * (k / p)**s_filter)\n                    c_filtered[e, k] = sigma_k * c_step[e, k]\n\n                if not preserve_avg:\n                    c_filtered[e, 0] = sigma0 * c_step[e, 0]\n        \n        # --- L1 Mass Error Calculation ---\n        final_mass = np.sum(c_filtered[:, 0]) * h\n        l1_mass_error = np.abs(final_mass - initial_mass)\n        results.append(l1_mass_error)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在使用流体体积 (VOF) 法模拟多相流时，体积分数 $ \\alpha $ 必须保持在其物理界限内，通常是 $ [0, 1] $。然而，标准的高阶 DG 格式本身并不能保证这一特性。本练习  提供了实现保界限制器的实践经验，这是构建稳健多相流求解器的关键组成部分。您将研究这种限制器如何影响质量守恒，这是数值格式的另一个关键属性。",
            "id": "3380118",
            "problem": "考虑一维保守输运的体积分数场 $\\alpha(x,t)$，它在周期性域 $x \\in [0,1]$ 上满足标量线性平流方程 $\\partial_t \\alpha + u \\,\\partial_x \\alpha = 0$，其中速度 $u \\in \\mathbb{R}$ 为常数。物理上，体积分数有界，满足 $0 \\le \\alpha \\le 1$。将域离散为 $N$ 个宽度为 $\\Delta x = 1/N$ 的均匀单元。在每个单元内，使用局部参考坐标 $\\xi \\in [-1,1]$ 中的1次间断Galerkin（DG）多项式来近似 $\\alpha(x,t)$，通过映射 $x = x_i + (\\Delta x/2)\\,\\xi$ 建立联系，表示为 $\\alpha_i(\\xi,t) = a_{0,i}(t) + a_{1,i}(t)\\,\\xi$，其中 $a_{0,i}$ 是单元平均值，$a_{1,i}$ 是斜率系数。\n\n从守恒律和使用迎风数值通量的DG弱形式定义出发，根据第一性原理推导每个单元的模态系数 $\\{a_{0,i},a_{1,i}\\}$ 的半离散系统。使用基底 $\\{\\phi_0(\\xi)=1,\\phi_1(\\xi)=\\xi\\}$ 和每个单元上的精确 $L^2$ 内积。然后，实现一个大小为 $\\Delta t$ 的显式前向欧拉时间步长，其中当 $|u| \\ne 0$ 时，$\\Delta t$ 受Courant-Friedrichs-Lewy (CFL) 数 $\\mathrm{CFL} \\in (0,1)$ 的约束，即 $\\Delta t = \\mathrm{CFL}\\,\\Delta x/|u|$；如果 $|u|=0$，则使用 $\\Delta t=0$。对于界面值，采用迎风数值通量：在界面处，如果 $u0$，迎风状态是左侧单元的值；如果 $u  0$，迎风状态是右侧单元的值。\n\n在进行一个没有任何限制（“无限制”更新）的时间步后，应用一个基于相对于单元平均值的缩放的保界限制器，以在单元界面处强制施加边界（在一维空间中，这与界面平均值重合）。具体来说，对于每个单元 $i$，在无限制更新后，计算内部界面值 $\\alpha_{i}^{L+} = a_{0,i} - a_{1,i}$ 和 $\\alpha_{i}^{R-} = a_{0,i} + a_{1,i}$。定义物理下界和上界 $m=0$ 和 $M=1$。设置\n$$\n\\theta_i \\;=\\; \\min\\left\\{1,\\; \\frac{a_{0,i}-m}{a_{0,i}-\\min(\\alpha_{i}^{L+},\\alpha_{i}^{R-})}\\;\\text{ if } a_{0,i}\\min(\\alpha_{i}^{L+},\\alpha_{i}^{R-}),\\; \\frac{M-a_{0,i}}{\\max(\\alpha_{i}^{L+},\\alpha_{i}^{R-})-a_{0,i}}\\;\\text{ if } a_{0,i}\\max(\\alpha_{i}^{L+},\\alpha_{i}^{R-})\\right\\},\n$$\n约定任何分母为非正的分数都将被忽略并替换为 $1$。然后设置受限斜率 $a_{1,i}^{\\mathrm{lim}} = \\theta_i\\, a_{1,i}$，同时保持单元平均值不变，$a_{0,i}^{\\mathrm{lim}}=a_{0,i}$。该限制器旨在保持单元平均值，同时在界面处强制满足边界 $m \\le \\alpha \\le M$。\n\n将时间 $t^n$ 的总质量定义为 $M^n = \\sum_{i=1}^{N} a_{0,i}^n \\,\\Delta x$。对于从 $t^0$ 到 $t^1=t^0+\\Delta t$ 的单个时间步，将全局质量守恒误差量化为总质量的绝对变化，$E = |M^1 - M^0|$。计算并报告无限制更新和受限更新的误差。\n\n您的程序必须实现所述方法，并为以下测试套件生成输出。每个测试用例由 $(N,u,\\mathrm{CFL},\\alpha_0(x))$ 定义：\n- 测试 A (理想情况，平滑有界): $N=40$, $u=1$, $\\mathrm{CFL}=0.20$, $\\alpha_0(x) = 0.5 + 0.49 \\sin(2\\pi x)$。\n- 测试 B (间断，潜在的界面过冲): $N=40$, $u=1$, $\\mathrm{CFL}=0.30$, $\\alpha_0(x) = 1$ for $x  0.5$, and $\\alpha_0(x)=0$ for $x \\ge 0.5$。\n- 测试 C (边界情况，单单元周期性): $N=1$, $u=0.7$, $\\mathrm{CFL}=0.20$, $\\alpha_0(x) = 0.3 + 0.2 \\cos(2\\pi x)$。\n- 测试 D (负速度): $N=30$, $u=-1$, $\\mathrm{CFL}=0.25$, $\\alpha_0(x) = 0.5 + 0.49 \\sin(4\\pi x)$。\n\n附加要求：\n- 对于每个测试用例，从 $t^0$ 到 $t^1$ 执行恰好一个前向欧拉时间步。\n- 使用精确的 $L^2$ 投影，通过具有足够高斯求积阶数的数值积分，从 $\\alpha_0(x)$ 初始化 $\\{a_{0,i},a_{1,i}\\}$，以解析给定的初始条件。\n- 为每个测试用例报告两个浮点数：无限制质量误差 $E_{\\mathrm{unlim}}$ 和受限质量误差 $E_{\\mathrm{lim}}$，每个都表示为实数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，其中每个条目对应一个测试用例，并且本身是一个双元素列表 $[E_{\\mathrm{unlim}},E_{\\mathrm{lim}}]$。对每个浮点值使用具有 $12$ 位有效数字的科学记数法。例如，两个假设测试用例的输出将如下所示：$[[1.234000000000e-12,1.234000000000e-12],[5.678000000000e-14,5.678000000000e-14]]$。",
            "solution": "用户提供了一个计算物理学中的适定问题，具体涉及使用间断Galerkin（DG）方法对一维线性平流方程进行数值求解。该问题具有科学依据，要求推导和实现一个标准的数值格式，并包含了所有必要的参数和定义。此问题有效，下面将给出完整解答。\n\n### 1. 半离散DG公式的推导\n\n控制方程是体积分数场 $\\alpha(x,t)$ 的标量线性平流方程：\n$$\n\\partial_t \\alpha + u \\,\\partial_x \\alpha = 0\n$$\n在周期性域 $x \\in [0,1]$ 上，速度 $u$ 为常数。\n\n域被离散为 $N$ 个宽度为 $\\Delta x = 1/N$ 的单元 $I_i = [x_{i-1/2}, x_{i+1/2}]$。在每个单元内，解 $\\alpha(x,t)$ 由一个1次多项式 $\\alpha_i(\\xi, t)$ 近似，其中 $\\xi \\in [-1,1]$ 是由映射 $x(\\xi) = x_i + (\\Delta x/2)\\xi$ 定义的局部参考坐标，$x_i$ 是单元中心。近似为：\n$$\n\\alpha_i(\\xi,t) = a_{0,i}(t)\\phi_0(\\xi) + a_{1,i}(t)\\phi_1(\\xi) = a_{0,i}(t) + a_{1,i}(t)\\xi\n$$\n使用正交基函数 $\\phi_0(\\xi)=1$ 和 $\\phi_1(\\xi)=\\xi$。\n\n为推导弱形式，我们将偏微分方程乘以一个检验函数 $\\phi_k(\\xi)$ 并在单元 $I_i$ 上积分：\n$$\n\\int_{I_i} (\\partial_t \\alpha_i) \\phi_k \\,dx + \\int_{I_i} u (\\partial_x \\alpha_i) \\phi_k \\,dx = 0\n$$\n变换到参考坐标 $\\xi$（其中 $dx = (\\Delta x/2)d\\xi$ 且 $\\partial_x = (2/\\Delta x)\\partial_\\xi$），我们得到：\n$$\n\\frac{\\Delta x}{2} \\int_{-1}^1 (\\partial_t \\alpha_i) \\phi_k \\,d\\xi + \\frac{\\Delta x}{2} \\int_{-1}^1 u \\left(\\frac{2}{\\Delta x}\\partial_\\xi \\alpha_i\\right) \\phi_k \\,d\\xi = 0\n$$\n对空间项应用分部积分得到：\n$$\n\\int_{-1}^1 u (\\partial_\\xi \\alpha_i) \\phi_k \\,d\\xi = \\left[ u \\, \\alpha_i \\phi_k \\right]_{-1}^{1} - \\int_{-1}^1 u \\alpha_i (\\partial_\\xi \\phi_k) \\,d\\xi\n$$\n边界项 $\\left[ u \\, \\alpha_i \\phi_k \\right]_{-1}^{1}$ 被替换为在单元界面处计算的数值通量项。通量 $u\\alpha$ 由 $u\\hat{\\alpha}$ 表示，其中 $\\hat{\\alpha}$ 是 $\\alpha$ 的数值通量。该项变为 $u(\\hat{\\alpha}_{i+1/2}\\phi_k(1) - \\hat{\\alpha}_{i-1/2}\\phi_k(-1))$，其中 $\\hat{\\alpha}_{i\\pm1/2}$ 表示单元 $i$ 的右/左界面处的数值通量。\n\n半离散弱形式则为：\n$$\n\\frac{\\Delta x}{2} \\int_{-1}^1 (\\partial_t \\alpha_i) \\phi_k \\,d\\xi + u(\\hat{\\alpha}_{i+1/2}\\phi_k(1) - \\hat{\\alpha}_{i-1/2}\\phi_k(-1)) - u \\int_{-1}^1 \\alpha_i (\\partial_\\xi \\phi_k) \\,d\\xi = 0\n$$\n代入 $\\alpha_i = a_{0,i}\\phi_0 + a_{1,i}\\phi_1$ 并对 $k=0,1$ 进行计算：\n\n**对于 $k=0$ (检验函数 $\\phi_0 = 1$)：**\n$\\phi_0(1)=1, \\phi_0(-1)=1, \\partial_\\xi\\phi_0=0$。\n$$\n\\frac{\\Delta x}{2} \\frac{d a_{0,i}}{dt} \\int_{-1}^1 \\phi_0^2 \\,d\\xi + u(\\hat{\\alpha}_{i+1/2} - \\hat{\\alpha}_{i-1/2}) - 0 = 0\n$$\n由于 $\\int_{-1}^1 \\phi_0^2 \\,d\\xi = 2$，这简化为：\n$$\n\\Delta x \\frac{d a_{0,i}}{dt} = -u (\\hat{\\alpha}_{i+1/2} - \\hat{\\alpha}_{i-1/2})\n$$\n\n**对于 $k=1$ (检验函数 $\\phi_1 = \\xi$)：**\n$\\phi_1(1)=1, \\phi_1(-1)=-1, \\partial_\\xi\\phi_1=1$。\n$$\n\\frac{\\Delta x}{2} \\frac{d a_{1,i}}{dt} \\int_{-1}^1 \\phi_1^2 \\,d\\xi + u(\\hat{\\alpha}_{i+1/2} - \\hat{\\alpha}_{i-1/2}(-1)) - u \\int_{-1}^1 (a_{0,i}\\phi_0+a_{1,i}\\phi_1)(\\partial_\\xi \\phi_1) \\,d\\xi = 0\n$$\n由于 $\\int_{-1}^1 \\phi_1^2 \\,d\\xi = 2/3$ 且 $\\int_{-1}^1 (a_{0,i}+a_{1,i}\\xi)(1) \\,d\\xi=2a_{0,i}$：\n$$\n\\frac{\\Delta x}{3} \\frac{d a_{1,i}}{dt} + u(\\hat{\\alpha}_{i+1/2} + \\hat{\\alpha}_{i-1/2}) - 2ua_{0,i} = 0\n$$\n这给出了斜率系数的常微分方程：\n$$\n\\frac{\\Delta x}{3} \\frac{d a_{1,i}}{dt} = -u (\\hat{\\alpha}_{i+1/2} + \\hat{\\alpha}_{i-1/2} - 2a_{0,i})\n$$\n\n### 2. 数值通量和时间步进\n\n问题指定了迎风通量。在单元 $i$ 和 $i+1$ 之间的界面 $x_{i+1/2}$ 处，解有两个值：来自左侧的 $\\alpha_{i+1/2}^- = \\alpha_i(\\xi=1) = a_{0,i} + a_{1,i}$，和来自右侧的 $\\alpha_{i+1/2}^+ = \\alpha_{i+1}(\\xi=-1) = a_{0,i+1} - a_{1,i+1}$。迎风通量为：\n$$\n\\hat{\\alpha}_{i+1/2} = \\begin{cases} \\alpha_{i+1/2}^-  \\text{if } u  0 \\\\ \\alpha_{i+1/2}^+  \\text{if } u  0 \\end{cases}\n$$\n同样的逻辑适用于界面 $x_{i-1/2}$。我们使用显式前向欧拉格式进行时间积分：\n$$\n\\mathbf{a}_i^{n+1} = \\mathbf{a}_i^n + \\Delta t \\cdot \\frac{d\\mathbf{a}_i^n}{dt}, \\quad \\text{其中 } \\mathbf{a}_i = (a_{0,i}, a_{1,i})^T\n$$\n时间步长为 $\\Delta t = \\mathrm{CFL}\\,\\Delta x/|u|$。这导致更新公式：\n$$\na_{0,i}^{n+1} = a_{0,i}^n - \\frac{u\\Delta t}{\\Delta x} (\\hat{\\alpha}_{i+1/2}^n - \\hat{\\alpha}_{i-1/2}^n)\n$$\n$$\na_{1,i}^{n+1} = a_{1,i}^n - \\frac{3u\\Delta t}{\\Delta x} (\\hat{\\alpha}_{i+1/2}^n + \\hat{\\alpha}_{i-1/2}^n - 2a_{0,i}^n)\n$$\n其中上标 $n$ 表示在时间 $t^n$ 的值。\n\n### 3. 通过$L^2$投影进行初始化\n\n初始系数 $\\{a_{0,i}^0, a_{1,i}^0\\}$ 是通过在每个单元中将初始条件 $\\alpha_0(x)$ $L^2$ 投影到DG基空间来确定的：\n$$\n\\int_{I_i} \\alpha_i(\\xi,0)\\phi_k(\\xi) \\,dx = \\int_{I_i} \\alpha_0(x)\\phi_k(\\xi) \\,dx \\quad \\text{对于 } k=0,1\n$$\n由于基在 $[-1,1]$ 上的正交性，这为系数提供了显式公式：\n$$\na_{0,i}^0 = \\frac{\\int_{-1}^1 \\alpha_0(x(\\xi)) \\,d\\xi}{\\int_{-1}^1 \\phi_0^2 \\,d\\xi} = \\frac{1}{2} \\int_{-1}^1 \\alpha_0(x_i + \\frac{\\Delta x}{2}\\xi) \\,d\\xi\n$$\n$$\na_{1,i}^0 = \\frac{\\int_{-1}^1 \\alpha_0(x(\\xi))\\xi \\,d\\xi}{\\int_{-1}^1 \\phi_1^2 \\,d\\xi} = \\frac{3}{2} \\int_{-1}^1 \\alpha_0(x_i + \\frac{\\Delta x}{2}\\xi) \\xi \\,d\\xi\n$$\n对于平滑的 $\\alpha_0(x)$，这些积分使用高阶高斯求积进行计算，或者对于分段常数情况进行解析计算。\n\n### 4. 保界限制器\n\n在无限制的前向欧拉步之后，得到系数 $a_{0,i}^{\\mathrm{unlim}}$ 和 $a_{1,i}^{\\mathrm{unlim}}$，然后应用保界限制器。该限制器确保单元界面处的多项式值 $\\alpha_{i}^{L+} = a_{0,i} - a_{1,i}$ 和 $\\alpha_{i}^{R-} = a_{0,i} + a_{1,i}$ 保持在物理边界 $[m, M] = [0, 1]$ 内。限制器通过一个因子 $\\theta_i \\in [0,1]$ 缩放斜率 $a_{1,i}$，同时保持单元平均值 $a_{0,i}$ 不变。\n$$\na_{0,i}^{\\mathrm{lim}} = a_{0,i}^{\\mathrm{unlim}}, \\quad a_{1,i}^{\\mathrm{lim}} = \\theta_i a_{1,i}^{\\mathrm{unlim}}\n$$\n其中 $\\theta_i$ 计算如下：\n$$\n\\theta_i \\;=\\; \\min\\left(1,\\; R_1, \\; R_2 \\right)\n$$\n其中\n$$\nR_1 = \\begin{cases} \\frac{a_{0,i}-m}{a_{0,i}-\\min(\\alpha_{i}^{L+},\\alpha_{i}^{R-})}  \\text{if } a_{0,i}\\min(\\alpha_{i}^{L+},\\alpha_{i}^{R-}) \\\\ 1  \\text{otherwise} \\end{cases}\n$$\n$$\nR_2 = \\begin{cases} \\frac{M-a_{0,i}}{\\max(\\alpha_{i}^{L+},\\alpha_{i}^{R-})-a_{0,i}}  \\text{if } a_{0,i}\\max(\\alpha_{i}^{L+},\\alpha_{i}^{R-}) \\\\ 1  \\text{otherwise} \\end{cases}\n$$\n这里的 $a_{0,i}, \\alpha_{i}^{L+}, \\alpha_{i}^{R-}$ 指的是无限制更新后的值。\n\n### 5. 质量守恒分析\n\n在时间 $t^n$ 的总质量是 $M^n = \\sum_{i=1}^{N} a_{0,i}^n \\,\\Delta x$。一个时间步后的全局质量守恒误差为 $E = |M^1 - M^0|$。\n从单元平均值的半离散方程，总质量的变化率为：\n$$\n\\frac{dM}{dt} = \\sum_{i=1}^N \\Delta x \\frac{da_{0,i}}{dt} = \\sum_{i=1}^N -u(\\hat{\\alpha}_{i+1/2} - \\hat{\\alpha}_{i-1/2})\n$$\n由于周期性边界条件，这个和是一个伸缩级数，其值恰好为零。因此，半离散DG格式是精确质量守恒的。\n前向欧拉时间步在代数上保持了此属性：\n$$\nM^1 - M^0 = \\sum_{i=1}^N \\Delta x (a_{0,i}^1 - a_{0,i}^0) = \\sum_{i=1}^N \\Delta x (\\Delta t \\frac{da_{0,i}^0}{dt}) = \\Delta t \\frac{dM^0}{dt} = 0\n$$\n因此，无限制格式的质量守恒误差 $E_{\\mathrm{unlim}}$ 应该在浮点精度范围内为零。\n由于限制器被设计为是守恒的，仅修改斜率系数（$a_{0,i}^{\\mathrm{lim}} = a_{0,i}^{\\mathrm{unlim}}$），总质量不受影响。因此，$M^1_{\\mathrm{lim}} = M^1_{\\mathrm{unlim}}$，并且受限格式的质量守恒误差 $E_{\\mathrm{lim}}$ 预计将与 $E_{\\mathrm{unlim}}$ 相同。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import fixed_quad\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the DG solver.\n    \"\"\"\n    # Test cases defined as (N, u, CFL, alpha0_func, case_name)\n    test_cases = [\n        (40, 1.0, 0.20, lambda x: 0.5 + 0.49 * np.sin(2 * np.pi * x), 'A'),\n        (40, 1.0, 0.30, lambda x: 1.0 if x  0.5 else 0.0, 'B'),\n        (1, 0.7, 0.20, lambda x: 0.3 + 0.2 * np.cos(2 * np.pi * x), 'C'),\n        (30, -1.0, 0.25, lambda x: 0.5 + 0.49 * np.sin(4 * np.pi * x), 'D'),\n    ]\n\n    results = []\n    for N, u, CFL, alpha0_func, case_name in test_cases:\n        e_unlim, e_lim = run_dg_step(N, u, CFL, alpha0_func, case_name)\n        results.append([e_unlim, e_lim])\n\n    # Format the final output string\n    formatted_results = []\n    for res_pair in results:\n        formatted_pair = f\"[{res_pair[0]:.12e},{res_pair[1]:.12e}]\"\n        formatted_results.append(formatted_pair)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_dg_step(N, u, CFL, alpha0_func, case_name):\n    \"\"\"\n    Performs a single time step of the P1 Discontinuous Galerkin method.\n    \"\"\"\n    # Quadrature order for initial condition projection\n    QUAD_ORDER = 16\n\n    # --- 1. Setup grid and time step ---\n    dx = 1.0 / N\n    dt = 0.0 if u == 0.0 else CFL * dx / abs(u)\n\n    # Cell centers are used for coordinate mapping in projection\n    x_nodes = np.linspace(0, 1, N + 1)\n    x_centers = x_nodes[:-1] + dx / 2\n\n    # --- 2. Initialize coefficients via L2 projection ---\n    a0 = np.zeros(N)\n    a1 = np.zeros(N)\n\n    if case_name == 'B':  # Analytical initialization for the step function\n        # The discontinuity is at x=0.5, which is an interface for N=40\n        discontinuity_idx = int(round(0.5 / dx))\n        a0[:discontinuity_idx] = 1.0\n        a0[discontinuity_idx:] = 0.0\n        # Slope is zero for a piecewise constant function\n        a1.fill(0.0)\n    else:  # L2 projection using numerical quadrature\n        for i in range(N):\n            # Integrands for projection in reference coordinates\n            integrand_a0 = lambda xi: alpha0_func(x_centers[i] + dx / 2 * xi)\n            integrand_a1 = lambda xi: alpha0_func(x_centers[i] + dx / 2 * xi) * xi\n            \n            # Use fixed-order Gaussian quadrature\n            integral_a0, _ = fixed_quad(integrand_a0, -1.0, 1.0, n=QUAD_ORDER)\n            integral_a1, _ = fixed_quad(integrand_a1, -1.0, 1.0, n=QUAD_ORDER)\n            \n            a0[i] = 0.5 * integral_a0\n            a1[i] = 1.5 * integral_a1\n\n    # --- 3. Calculate initial total mass ---\n    M0 = np.sum(a0) * dx\n\n    # --- 4. Perform a single DG time step (unlimited) ---\n    if u == 0.0:\n        a0_unlim, a1_unlim = a0.copy(), a1.copy()\n    else:\n        # Vectorized implementation using np.roll for periodic boundaries\n        if u  0:\n            flux_l = np.roll(a0, 1) + np.roll(a1, 1)  # upwind from left neighbor\n            flux_r = a0 + a1                         # upwind from self\n        else:  # u  0\n            flux_l = a0 - a1                         # upwind from self\n            flux_r = np.roll(a0, -1) - np.roll(a1, -1) # upwind from right neighbor\n        \n        cfl_signed = CFL * np.sign(u)\n        \n        # RHS for cell average and slope updates\n        rhs_a0_term = -(flux_r - flux_l)\n        rhs_a1_term = -(flux_r + flux_l - 2 * a0)\n        \n        # Forward Euler update\n        a0_unlim = a0 + cfl_signed * rhs_a0_term\n        a1_unlim = a1 + 3 * cfl_signed * rhs_a1_term\n\n    # --- 5. Calculate mass conservation error for the unlimited solution ---\n    M1_unlim = np.sum(a0_unlim) * dx\n    E_unlim = abs(M1_unlim - M0)\n\n    # --- 6. Apply the bound-preserving limiter ---\n    m, M = 0.0, 1.0\n    \n    # Compute face values from the unlimited update\n    alpha_Lplus = a0_unlim - a1_unlim\n    alpha_Rminus = a0_unlim + a1_unlim\n    \n    min_face_vals = np.minimum(alpha_Lplus, alpha_Rminus)\n    max_face_vals = np.maximum(alpha_Lplus, alpha_Rminus)\n    \n    # Calculate the scaling factor theta\n    theta = np.ones(N)\n    \n    # First ratio for the lower bound\n    den1 = a0_unlim - min_face_vals\n    ratio1 = np.ones_like(a0_unlim)\n    valid_mask1 = den1  1e-15  # Check for positive denominator\n    ratio1[valid_mask1] = (a0_unlim[valid_mask1] - m) / den1[valid_mask1]\n    \n    # Second ratio for the upper bound\n    den2 = max_face_vals - a0_unlim\n    ratio2 = np.ones_like(a0_unlim)\n    valid_mask2 = den2  1e-15 # Check for positive denominator\n    ratio2[valid_mask2] = (M - a0_unlim[valid_mask2]) / den2[valid_mask2]\n    \n    # Combine the limiters\n    theta = np.minimum(theta, ratio1)\n    theta = np.minimum(theta, ratio2)\n    \n    # Apply the limiter\n    a0_lim = a0_unlim  # Cell average is preserved\n    a1_lim = theta * a1_unlim\n\n    # --- 7. Calculate mass conservation error for the limited solution ---\n    M1_lim = np.sum(a0_lim) * dx\n    E_lim = abs(M1_lim - M0)\n\n    return E_unlim, E_lim\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在许多多相流系统中，表面张力是主导力，其精确计算依赖于对界面曲率的精确表示。水平集 (Level-set) 方法与 DG 方法相结合，为描述复杂的界面几何形状提供了一种强大的途径。通过这个静态气泡测试 ，您将探索在 DG 框架中提高多项式阶数（$p$-enrichment）如何提高曲率计算的精度。这一实践突出了界面数值近似与表面张力等物理力计算精度之间的联系。",
            "id": "3380182",
            "problem": "在多相流的间断 Galerkin (DG) 方法背景下，考虑一个二维静态气泡测试。界面由定义在方形域 $[-L,L]^2$（其中 $L=1.5$）上的一个水平集函数表示。设水平集函数为 $\\phi(x,y) = \\sqrt{x^2 + y^2} - R$，其中气泡半径 $R=1$，并假设表面张力系数为 $\\sigma=1$。精确界面是圆 $\\{(x,y) \\mid \\phi(x,y) = 0\\}$，沿界面的精确曲率为 $\\kappa_{\\text{exact}} = 1$（对于圆的二维曲率），这产生精确的 Laplace 压力跳跃 $\\Delta p_{\\text{exact}} = \\sigma \\kappa_{\\text{exact}} = 1$。\n\n从基本定义出发：\n- 在水平集公式中，曲率由 $\\kappa = \\nabla \\cdot \\left(\\dfrac{\\nabla \\phi}{\\|\\nabla \\phi\\|}\\right)$ 给出。\n- 在二维中，每单位厚度的净表面张力为 $\\mathbf{F} = \\oint_{\\phi=0} \\sigma \\kappa \\mathbf{n}\\, \\mathrm{d}s$，其中 $\\mathbf{n}$ 是单位法向量，$\\mathrm{d}s$ 是沿界面的线元。\n- 沿圆的线元为 $\\mathrm{d}s = R\\,\\mathrm{d}\\theta$，精确圆的单位法向量为 $\\mathbf{n}_{\\text{exact}} = [\\cos\\theta, \\sin\\theta]^\\top$。\n\n在 $[-L,L]^2$ 上使用一个固定的均匀笛卡尔网格，网格由尺寸为 $h=0.3$ 的方形单元组成，并采用间断 Galerkin 近似。在每个单元中，通过使用 Gauss–Legendre 求积点进行加权最小二乘拟合，用局部坐标下总阶数为 $p$ 的多项式来近似 $\\phi$。设局部坐标 $(\\xi,\\eta) \\in [-1,1]^2$ 通过仿射映射到每个单元，且多项式近似为\n$$\n\\phi_h(\\xi,\\eta) = \\sum_{i+j \\le p} c_{ij} \\,\\xi^i \\eta^j.\n$$\n系数 $c_{ij}$ 是通过在每个单元内，最小化在阶数为 $n_q=p+2$ 的张量积 Gauss–Legendre 点上计算的精确 $\\phi$ 与近似值之间的求积加权最小二乘不匹配来确定的。梯度和 Hessian 矩阵从 $\\phi_h$ 解析地获得，物理空间导数通过带有仿射映射的链式法则得出。曲率近似值 $\\kappa_h$ 由 $\\phi_h$ 逐点计算得出：\n$$\n\\kappa_h = \\frac{\\phi_{xx}\\,\\phi_y^2 - 2\\,\\phi_x\\,\\phi_y\\,\\phi_{xy} + \\phi_{yy}\\,\\phi_x^2}{\\left(\\phi_x^2 + \\phi_y^2\\right)^{3/2}}.\n$$\n\n使用 DG 近似按如下方式评估曲率和力：\n- 在 $N_\\theta = 720$ 个均匀分布的角度 $\\theta \\in [0,2\\pi)$（角度以弧度为单位）上对界面进行采样。\n- 对于每个采样点 $(x,y) = (R\\cos\\theta, R\\sin\\theta)$，选择包含 $(x,y)$ 的单元，在该点计算 $\\phi_h$ 及其导数，计算 $\\kappa_h$，并计算 DG 单位法向量 $\\mathbf{n}_h = \\dfrac{\\nabla \\phi_h}{\\|\\nabla \\phi_h\\|}$。\n- 使用关于 $\\theta$ 的复合梯形法则来近似线积分（对于光滑被积函数，在圆上进行等距采样时，该法则是精确的），即使用均匀权重 $\\mathrm{d}s = R\\,\\mathrm{d}\\theta$。\n\n对于固定的 $h$ 和每个多项式阶数 $p \\in \\{2,3,5\\}$，计算：\n1. 界面 $L^2$ 曲率误差\n$$\nE_\\kappa(p) = \\sqrt{\\frac{1}{2\\pi R}\\int_{0}^{2\\pi} \\left(\\kappa_h(\\theta) - \\kappa_{\\text{exact}}\\right)^2 R\\, \\mathrm{d}\\theta}.\n$$\n2. 净表面张力的大小\n$$\n\\|\\mathbf{F}(p)\\| = \\left\\|\\int_{0}^{2\\pi} \\sigma\\,\\kappa_h(\\theta)\\,\\mathbf{n}_h(\\theta)\\, R\\, \\mathrm{d}\\theta\\right\\|.\n$$\n\n假设全文使用无量纲单位（除了给定的无量纲参数外，不需要其他物理单位），并使用弧度作为角度单位。您的程序应实现上述 DG 近似，并针对测试套件 $p \\in \\{2,3,5\\}$，报告每个 $p$ 对应的两个度量指标 $E_\\kappa(p)$ 和 $\\|\\mathbf{F}(p)\\|$，结果为浮点数。\n\n测试套件：\n- 情况 1（理想情况）：$p=2$。\n- 情况 2（精度提升）：$p=3$。\n- 情况 3（高阶边界情况）：$p=5$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由三个列表组成的逗号分隔列表，每个内部列表按顺序为 $[E_\\kappa(p), \\|\\mathbf{F}(p)\\|]$，分别对应 $p=2, p=3, p=5$。例如，输出应如下所示：\n$[[e_2,f_2],[e_3,f_3],[e_5,f_5]]$。",
            "solution": "所提出的问题是有效的，因为它具有科学依据、是适定的且客观的。它在计算流体力学这一成熟领域内指定了一个清晰的数值任务，并提供了构建唯一解所需的所有必要参数、方程和定义。\n\n解决方案涉及实现一种间断 Galerkin (DG) 方法来近似一个水平集函数，并由此推导出一个圆形界面的几何量。该过程分为几个逻辑步骤：\n\n1.  **区域离散化与局部坐标系**：\n    计算域是一个由 $[-L, L]^2 = [-1.5, 1.5]^2$ 定义的正方形，它被划分为一个 $10 \\times 10$ 的均匀笛卡尔网格，网格由方形单元组成。每个单元的边长为 $h=0.3$。在每个单元内，定义了一个局部坐标系 $(\\xi, \\eta) \\in [-1, 1]^2$。从此局部坐标系到中心位于 $(x_c, y_c)$ 的单元的全局物理坐标 $(x,y)$ 的变换是一个仿射映射：\n    $$\n    x = x_c + \\frac{h}{2}\\xi, \\quad y = y_c + \\frac{h}{2}\\eta\n    $$\n\n2.  **分片多项式近似**：\n    在每个单元中，精确的水平集函数 $\\phi(x,y) = \\sqrt{x^2 + y^2} - R$ 由一个总阶数为 $p$ 的多项式 $\\phi_h(\\xi, \\eta)$ 近似。该多项式由满足 $i+j \\le p$ 的单项式基 $\\{\\xi^i \\eta^j\\}$ 构建：\n    $$\n    \\phi_h(\\xi,\\eta) = \\sum_{i+j \\le p} c_{ij} \\,\\xi^i \\eta^j\n    $$\n    系数 $c_{ij}$ 对每个单元都是唯一的，并通过加权最小二乘拟合确定。此拟合在单元内的一个 $n_q \\times n_q$ 的张量积 Gauss-Legendre 求积点网格上，最小化了 $\\phi_h$ 与精确函数 $\\phi$ 之间的差异，其中 $n_q = p+2$。该最小化问题是：\n    $$\n    \\min_{c_{ij}} \\sum_{k=1}^{n_q^2} w_k \\left( \\phi_h(\\xi_k, \\eta_k) - \\phi(x_k, y_k) \\right)^2\n    $$\n    其中 $(\\xi_k, \\eta_k)$ 是求积节点的局部坐标，$(x_k, y_k)$ 是对应的物理坐标，$w_k$ 是求积权重。此公式导致每个单元中系数 $c_{ij}$ 的一个超定线性系统，该系统使用标准最小二乘算法求解。\n\n3.  **物理导数的计算**：\n    一旦在每个单元中建立了多项式近似 $\\phi_h$，就需要其在物理坐标下的空间导数 $(\\phi_x, \\phi_y, \\phi_{xx}, \\phi_{xy}, \\phi_{yy})$ 来计算曲率。这些导数首先通过对多项式 $\\phi_h$ 关于局部坐标 $(\\xi, \\eta)$ 进行解析求导，然后应用链式法则获得。给定仿射映射，导数通过与单元尺寸 $h$ 相关的常数因子进行变换：\n    $$\n    \\phi_x = \\frac{\\partial \\phi_h}{\\partial x} = \\frac{2}{h} \\frac{\\partial \\phi_h}{\\partial \\xi}, \\quad \\phi_y = \\frac{\\partial \\phi_h}{\\partial y} = \\frac{2}{h} \\frac{\\partial \\phi_h}{\\partial \\eta}\n    $$\n    $$\n    \\phi_{xx} = \\frac{\\partial^2 \\phi_h}{\\partial x^2} = \\left(\\frac{2}{h}\\right)^2 \\frac{\\partial^2 \\phi_h}{\\partial \\xi^2}, \\quad \\phi_{xy} = \\frac{\\partial^2 \\phi_h}{\\partial x \\partial y} = \\left(\\frac{2}{h}\\right)^2 \\frac{\\partial^2 \\phi_h}{\\partial \\xi \\partial \\eta}, \\quad \\phi_{yy} = \\frac{\\partial^2 \\phi_h}{\\partial y^2} = \\left(\\frac{2}{h}\\right)^2 \\frac{\\partial^2 \\phi_h}{\\partial \\eta^2}\n    $$\n    利用这些导数，可以使用曲率以水平集导数表示的定义，在任意点计算近似曲率 $\\kappa_h$。\n\n4.  **通过数值积分评估度量指标**：\n    两个目标度量指标，即 $L^2$ 曲率误差 $E_\\kappa(p)$ 和净表面张力的大小 $\\|\\mathbf{F}(p)\\|$，被定义为在界面 $\\phi=0$ 上的线积分。这些积分将进行数值近似。精确的圆形界面在 $N_\\theta = 720$ 个等距点上进行采样，这些点由 $(x_k, y_k) = (R\\cos\\theta_k, R\\sin\\theta_k)$ 给出，其中 $k=0, \\dots, N_\\theta-1$。在每个采样点执行以下步骤：\n    a. 确定包含 $(x_k, y_k)$ 的单元。\n    b. 将物理坐标映射到该单元的局部坐标 $(\\xi_k, \\eta_k)$。\n    c. 使用为该单元存储的系数 $c_{ij}$ 来计算 $\\phi_h$ 的导数，并从而计算出近似曲率 $\\kappa_h(\\theta_k)$ 和法向量 $\\mathbf{n}_h(\\theta_k)$。\n    \n    然后，积分被近似为在这些采样点上的求和。$L^2$ 曲率误差计算为曲率样本的均方根 (RMS) 误差：\n    $$\n    E_\\kappa(p) = \\sqrt{\\frac{1}{N_\\theta} \\sum_{k=0}^{N_\\theta-1} (\\kappa_h(\\theta_k) - \\kappa_{\\text{exact}})^2}\n    $$\n    净力向量 $\\mathbf{F}(p)$ 通过基于复合梯形法则的求和来近似，对于均匀采样，该求和简化为：\n    $$\n    \\mathbf{F}(p) \\approx \\sum_{k=0}^{N_\\theta-1} \\sigma\\,\\kappa_h(\\theta_k)\\,\\mathbf{n}_h(\\theta_k)\\, R \\Delta\\theta, \\quad \\text{where } \\Delta\\theta = \\frac{2\\pi}{N_\\theta}\n    $$\n    然后计算所得向量的大小 $\\|\\mathbf{F}(p)\\|$。对每个多项式阶数 $p \\in \\{2, 3, 5\\}$ 执行这整个计算过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\nimport math\n\ndef _get_basis_indices(p):\n    \"\"\"Generates basis monomial powers (i, j) for total degree p.\"\"\"\n    indices = []\n    for total_degree in range(p + 1):\n        for i in range(total_degree + 1):\n            j = total_degree - i\n            indices.append((i, j))\n    return indices\n\ndef _eval_basis_derivatives(xi, eta, basis_indices, deriv_xi, deriv_eta):\n    \"\"\"\n    Evaluates the derivatives of basis functions at a point (xi, eta).\n    Returns a vector of derivative values for all basis functions.\n    \"\"\"\n    values = np.zeros(len(basis_indices))\n    for k, (i, j) in enumerate(basis_indices):\n        if i  deriv_xi or j  deriv_eta:\n            val = 0.0\n        else:\n            term_xi = math.perm(i, deriv_xi) * (xi ** (i - deriv_xi))\n            term_eta = math.perm(j, deriv_eta) * (eta ** (j - deriv_eta))\n            val = term_xi * term_eta\n        values[k] = val\n    return values\n\ndef _get_element_coeffs(p, L, R, H):\n    \"\"\"\n    Computes the polynomial coefficients for phi_h in each element.\n    \"\"\"\n    n_q = p + 2\n    basis_indices = _get_basis_indices(p)\n    num_basis_fns = len(basis_indices)\n\n    num_elements_dim = int(round(2 * L / H))\n    coeffs_grid = np.zeros((num_elements_dim, num_elements_dim, num_basis_fns))\n    \n    xi_q, w_q = roots_legendre(n_q)\n    xi_q_2d, eta_q_2d = np.meshgrid(xi_q, xi_q)\n    quad_points_local = np.vstack([xi_q_2d.ravel(), eta_q_2d.ravel()]).T\n    w_q_2d = np.outer(w_q, w_q).ravel()\n\n    A = np.zeros((n_q**2, num_basis_fns))\n    for i in range(n_q**2):\n        xi_val, eta_val = quad_points_local[i]\n        A[i, :] = _eval_basis_derivatives(xi_val, eta_val, basis_indices, 0, 0)\n    \n    A_w = A * np.sqrt(w_q_2d)[:, np.newaxis]\n\n    for i in range(num_elements_dim):\n        for j in range(num_elements_dim):\n            xc = -L + H * (i + 0.5)\n            yc = -L + H * (j + 0.5)\n            \n            x_phys = xc + (H / 2) * quad_points_local[:, 0]\n            y_phys = yc + (H / 2) * quad_points_local[:, 1]\n            \n            phi_exact_vals = np.sqrt(x_phys**2 + y_phys**2) - R\n            b_w = phi_exact_vals * np.sqrt(w_q_2d)\n            \n            c, _, _, _ = np.linalg.lstsq(A_w, b_w, rcond=None)\n            coeffs_grid[i, j, :] = c\n            \n    return coeffs_grid, basis_indices\n\ndef _compute_metrics_for_p(p, L, R, H, SIGMA, N_THETA, KAPPA_EXACT, coeffs_grid, basis_indices):\n    \"\"\"\n    Computes curvature error and net force magnitude for a given polynomial degree p.\n    \"\"\"\n    num_elements_dim = int(round(2 * L / H))\n    \n    theta = np.linspace(0, 2 * np.pi, N_THETA, endpoint=False)\n    x_s, y_s = R * np.cos(theta), R * np.sin(theta)\n\n    kappa_h_vals = np.zeros(N_THETA)\n    force_integrand_vals = np.zeros((N_THETA, 2))\n\n    for k in range(N_THETA):\n        x, y = x_s[k], y_s[k]\n        \n        i = int(np.floor((x + L) / H))\n        j = int(np.floor((y + L) / H))\n        i = min(max(i, 0), num_elements_dim - 1)\n        j = min(max(j, 0), num_elements_dim - 1)\n        \n        xc = -L + H * (i + 0.5)\n        yc = -L + H * (j + 0.5)\n        xi = (x - xc) / (H / 2)\n        eta = (y - yc) / (H / 2)\n        \n        c = coeffs_grid[i, j, :]\n        \n        deriv_vectors = {\n            (1, 0): _eval_basis_derivatives(xi, eta, basis_indices, 1, 0),\n            (0, 1): _eval_basis_derivatives(xi, eta, basis_indices, 0, 1),\n            (2, 0): _eval_basis_derivatives(xi, eta, basis_indices, 2, 0),\n            (1, 1): _eval_basis_derivatives(xi, eta, basis_indices, 1, 1),\n            (0, 2): _eval_basis_derivatives(xi, eta, basis_indices, 0, 2),\n        }\n        \n        phi_h_xi = np.dot(c, deriv_vectors[(1, 0)])\n        phi_h_eta = np.dot(c, deriv_vectors[(0, 1)])\n        phi_h_xixi = np.dot(c, deriv_vectors[(2, 0)])\n        phi_h_xieta = np.dot(c, deriv_vectors[(1, 1)])\n        phi_h_etaeta = np.dot(c, deriv_vectors[(0, 2)])\n        \n        h_inv2 = 2.0 / H\n        h_inv2_sq = h_inv2**2\n        \n        phi_x = phi_h_xi * h_inv2\n        phi_y = phi_h_eta * h_inv2\n        phi_xx = phi_h_xixi * h_inv2_sq\n        phi_xy = phi_h_xieta * h_inv2_sq\n        phi_yy = phi_h_etaeta * h_inv2_sq\n        \n        phi_x2 = phi_x**2\n        phi_y2 = phi_y**2\n        denom = (phi_x2 + phi_y2)**1.5\n        \n        kappa_h = (phi_xx*phi_y2 - 2*phi_x*phi_y*phi_xy + phi_yy*phi_x2) / denom if denom  1e-12 else 0.0\n        kappa_h_vals[k] = kappa_h\n        \n        grad_phi_norm = np.sqrt(phi_x2 + phi_y2)\n        n_h = np.array([phi_x, phi_y]) / grad_phi_norm if grad_phi_norm  1e-12 else np.array([0.0, 0.0])\n        force_integrand_vals[k, :] = SIGMA * kappa_h * n_h\n        \n    error_sq = (kappa_h_vals - KAPPA_EXACT)**2\n    E_kappa = np.sqrt(np.mean(error_sq))\n    \n    d_theta = 2 * np.pi / N_THETA\n    F_net_vec = np.sum(force_integrand_vals, axis=0) * R * d_theta\n    F_norm = np.linalg.norm(F_net_vec)\n    \n    return [E_kappa, F_norm]\n\ndef solve():\n    # Define test cases\n    test_cases = [2, 3, 5]  # Polynomial degrees p\n\n    # --- Problem Constants ---\n    L = 1.5\n    R = 1.0\n    SIGMA = 1.0\n    H = 0.3\n    N_THETA = 720\n    KAPPA_EXACT = 1.0\n    \n    results = []\n    for p in test_cases:\n        coeffs_grid, basis_indices = _get_element_coeffs(p, L, R, H)\n        metrics = _compute_metrics_for_p(p, L, R, H, SIGMA, N_THETA, KAPPA_EXACT, coeffs_grid, basis_indices)\n        results.append(metrics)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}