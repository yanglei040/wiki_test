{
    "hands_on_practices": [
        {
            "introduction": "我们从任意拉格朗日-欧拉（ALE）方法的基础构建模块开始。这项练习要求您通过纸笔推导，为一个简单的一维移动单元建立从参考坐标到物理坐标的仿射映射，并计算其雅可比行列式和网格速度。通过这项实践，您将清晰地理解物理单元的运动如何直接转化为参考单元中的关键几何量，这是后续更复杂数值实现的基础。",
            "id": "3364740",
            "problem": "考虑在任意拉格朗日-欧拉（ALE）框架下的单个一维间断伽辽金元，其中物理元的端点由随时间变化的位置 $x_{L}(t)$ 和 $x_{R}(t)$ 给出，参考元坐标 $X$ 位于 $[-1,1]$ 内。ALE 映射旨在寻求一个从固定参考元到移动物理元的时间相关变换 $x(X,t)$。假设在每个固定的时间 $t$，该映射在 $X$ 上是仿射的，并满足端点条件 $x(-1,t)=x_{L}(t)$ 和 $x(1,t)=x_{R}(t)$。\n\n从闭区间上的仿射映射、映射的雅可比 $J(X,t)$（作为偏导数 $J(X,t)=\\partial x/\\partial X$）以及网格速度 $w(X,t)$（作为固定参考坐标下的时间偏导数 $w(X,t)=\\partial x/\\partial t\\big|_{X}$）的定义出发，推导 $x(X,t)$、$J(X,t)$ 和 $w(X,t)$ 关于 $x_{L}(t)$、$x_{R}(t)$ 及其时间导数的显式闭式表达式。\n\n将最终结果表示为包含所有三个量的行矩阵形式的单个解析表达式。不需要进行数值评估，最终表达式中也不应包含单位。",
            "solution": "首先对问题进行验证，以确保其是自洽的、有科学依据且适定的。\n\n### 步骤 1：提取已知条件\n-   框架：针对单个一维间断伽辽金元的任意拉格朗日-欧拉（ALE）框架。\n-   物理元端点：随时间变化的位置 $x_{L}(t)$ 和 $x_{R}(t)$。\n-   参考元：坐标 $X$ 位于固定区间 $[-1, 1]$ 内。\n-   映射：一个从参考元到物理元的时间相关变换 $x(X,t)$。\n-   映射性质：对于任意固定的时间 $t$，$x(X,t)$ 在 $X$ 上是仿射的。\n-   映射边界条件：$x(-1,t) = x_{L}(t)$ 和 $x(1,t) = x_{R}(t)$。\n-   雅可比定义：$J(X,t) = \\frac{\\partial x}{\\partial X}$。\n-   网格速度定义：$w(X,t) = \\frac{\\partial x}{\\partial t}\\big|_{X}$。\n-   目标：推导 $x(X,t)$、$J(X,t)$ 和 $w(X,t)$ 关于 $x_{L}(t)$、$x_{R}(t)$ 及其时间导数的显式闭式表达式。\n\n### 步骤 2：使用已知条件进行验证\n该问题是偏微分方程计算方法领域中的一个标准推导，特别适用于像 ALE 这样的移动网格方法。\n-   **科学依据：** ALE 映射、参考元、雅可比和网格速度等概念是数值分析和计算力学中的基本概念，且定义正确。该问题具有科学合理性。\n-   **适定性：** 问题提供了足够的约束条件（一个带有两个边界条件的仿射映射），以唯一确定未知函数 $x(X,t)$ 及其导数。存在唯一解。\n-   **目标：** 问题陈述使用了精确的数学语言，没有歧义或主观因素。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。将进行求解。\n\n### 映射 $x(X,t)$ 的推导\n问题陈述，对于任意固定的时间 $t$，映射 $x(X,t)$ 在参考坐标 $X$ 上是仿射的。一个通用的一维仿射函数可以写成：\n$$x(X,t) = A(t)X + B(t)$$\n其中系数 $A(t)$ 和 $B(t)$ 依赖于时间 $t$，但不依赖于参考坐标 $X$。\n\n我们使用给定的两个边界条件来确定 $A(t)$ 和 $B(t)$。\n当 $X = -1$ 时：\n$$x(-1,t) = A(t)(-1) + B(t) = -A(t) + B(t) = x_{L}(t) \\quad (1)$$\n当 $X = 1$ 时：\n$$x(1,t) = A(t)(1) + B(t) = A(t) + B(t) = x_{R}(t) \\quad (2)$$\n\n这是一个关于 $A(t)$ 和 $B(t)$ 的二元线性方程组。为了求解 $B(t)$，我们将方程 (1) 和 (2) 相加：\n$$(-A(t) + B(t)) + (A(t) + B(t)) = x_{L}(t) + x_{R}(t)$$\n$$2B(t) = x_{L}(t) + x_{R}(t)$$\n$$B(t) = \\frac{x_{R}(t) + x_{L}(t)}{2}$$\n该项表示在时间 $t$ 时物理元的中心。\n\n为了求解 $A(t)$，我们从方程 (2) 中减去方程 (1)：\n$$(A(t) + B(t)) - (-A(t) + B(t)) = x_{R}(t) - x_{L}(t)$$\n$$2A(t) = x_{R}(t) - x_{L}(t)$$\n$$A(t) = \\frac{x_{R}(t) - x_{L}(t)}{2}$$\n该项表示在时间 $t$ 时物理元长度的一半。\n\n将 $A(t)$ 和 $B(t)$ 的表达式代回仿射映射方程，我们得到 $x(X,t)$ 的显式形式：\n$$x(X,t) = \\left(\\frac{x_{R}(t) - x_{L}(t)}{2}\\right)X + \\frac{x_{R}(t) + x_{L}(t)}{2}$$\n\n### 雅可比 $J(X,t)$ 的推导\n一维映射的雅可比定义为 $J(X,t) = \\frac{\\partial x}{\\partial X}$。我们将 $x(X,t)$ 的表达式对 $X$ 求导，同时保持 $t$ 不变：\n$$J(X,t) = \\frac{\\partial}{\\partial X} \\left[ \\left(\\frac{x_{R}(t) - x_{L}(t)}{2}\\right)X + \\frac{x_{R}(t) + x_{L}(t)}{2} \\right]$$\n项 $\\frac{x_{R}(t) + x_{L}(t)}{2}$ 与 $X$ 无关，因此其偏导数为零。关于 $X$ 的线性项的导数是其系数：\n$$J(X,t) = \\frac{x_{R}(t) - x_{L}(t)}{2}$$\n正如仿射映射所预期的那样，雅可比在整个元上空间上是常数。\n\n### 网格速度 $w(X,t)$ 的推导\n网格速度定义为具有固定参考坐标 $X$ 的点的物理位置的时间导数，即 $w(X,t) = \\frac{\\partial x}{\\partial t}\\big|_{X}$。我们将 $x(X,t)$ 的表达式对 $t$ 求导，同时保持 $X$ 不变。令 $\\dot{x}_{L}(t) = \\frac{dx_{L}}{dt}$ 和 $\\dot{x}_{R}(t) = \\frac{dx_{R}}{dt}$ 表示端点位置的时间导数。\n$$w(X,t) = \\frac{\\partial}{\\partial t} \\left[ \\left(\\frac{x_{R}(t) - x_{L}(t)}{2}\\right)X + \\frac{x_{R}(t) + x_{L}(t)}{2} \\right]$$\n利用微分算子的线性性质：\n$$w(X,t) = \\frac{1}{2}\\left(\\frac{dx_{R}}{dt} - \\frac{dx_{L}}{dt}\\right)X + \\frac{1}{2}\\left(\\frac{dx_{R}}{dt} + \\frac{dx_{L}}{dt}\\right)$$\n$$w(X,t) = \\frac{\\dot{x}_{R}(t) - \\dot{x}_{L}(t)}{2} X + \\frac{\\dot{x}_{R}(t) + \\dot{x}_{L}(t)}{2}$$\n网格速度也是参考坐标 $X$ 的仿射函数。它表示端点速度 $\\dot{x}_{L}(t)$ 和 $\\dot{x}_{R}(t)$ 在参考元上的线性插值。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{x_{R}(t) - x_{L}(t)}{2} X + \\frac{x_{R}(t) + x_{L}(t)}{2}  \\frac{x_{R}(t) - x_{L}(t)}{2}  \\frac{\\dot{x}_{R}(t) - \\dot{x}_{L}(t)}{2} X + \\frac{\\dot{x}_{R}(t) + \\dot{x}_{L}(t)}{2}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在掌握了基本理论之后，我们将转向一个常见的数值陷阱。本编码练习将向您展示，在弯曲网格的间断伽辽金（DG）格式中，对度量项的天真实现如何导致几何守恒律（Geometric Conservation Law, GCL）的违反。您将通过构建一个反例，看到即使对于一个简单的均匀流场，也会产生非零的数值残差，从而深刻理解为何必须谨慎处理几何项的计算与积分。",
            "id": "3364695",
            "problem": "考虑守恒形式的标量平流方程，该方程定义在一个由参考正方形映射产生的具有曲线坐标的物理域上。设参考单元为坐标 $(\\xi,\\eta) \\in [-1,1]^2$ 的正方形，物理坐标 $(x,y)$ 由一个光滑映射 $(x(\\xi,\\eta),y(\\xi,\\eta))$ 给出。守恒律为 $\\partial_t u + \\nabla \\cdot \\mathbf{F} = 0$，其中 $\\mathbf{F} = \\mathbf{a} u$ 且 $\\mathbf{a} \\in \\mathbb{R}^2$ 是一个常数平流速度向量。从 $(x,y)$ 到 $(\\xi,\\eta)$ 的任意拉格朗日-欧拉（ALE）变量变换产生如下形式的映射散度\n$$\n\\nabla \\cdot \\mathbf{F} = \\frac{1}{J}\\left( \\frac{\\partial \\widehat{F}^\\xi}{\\partial \\xi} + \\frac{\\partial \\widehat{F}^\\eta}{\\partial \\eta} \\right),\n$$\n其中 $J = x_\\xi y_\\eta - x_\\eta y_\\xi$ 是雅可比行列式，逆变通量分量定义为\n$$\n\\widehat{F}^\\xi = \\mathbf{G}^\\xi \\cdot \\mathbf{F}, \\quad \\widehat{F}^\\eta = \\mathbf{G}^\\eta \\cdot \\mathbf{F},\n$$\n度量项为\n$$\n\\mathbf{G}^\\xi = \\begin{bmatrix} y_\\eta \\\\ -x_\\eta \\end{bmatrix}, \\quad \\mathbf{G}^\\eta = \\begin{bmatrix} -y_\\xi \\\\ x_\\xi \\end{bmatrix},\n$$\n且 $x_\\xi = \\frac{\\partial x}{\\partial \\xi}$, $x_\\eta = \\frac{\\partial x}{\\partial \\eta}$, $y_\\xi = \\frac{\\partial y}{\\partial \\xi}$, $y_\\eta = \\frac{\\partial y}{\\partial \\eta}$。对于常数自由流 $u = u_0$ 和常数 $\\mathbf{a}$，精确的连续计算满足强制 $\\nabla \\cdot \\mathbf{F} = 0$ 的几何恒等式。\n\n在一个多项式次数为 $N$ 的谱间断伽辽金（DG）单元中，通常对体积项使用 Legendre-Gauss-Lobatto 节点上的多项式插值及相关的求积法。然而，如果度量项是通过将 $(x(\\xi,\\eta),y(\\xi,\\eta))$ 插值到次数为 $N$ 的多项式空间上，并用离散微分矩阵进行微分来朴素地计算，同时使用 $(N+1)$ 点的张量积 Legendre-Gauss-Lobatto 求积法，那么当映射包含的阶数高于所选多项式空间能精确表示的阶数时，可能会发生混叠。这种欠积分导致了对自由流守恒的违反，表现为常数自由流的非零离散残差。\n\n你的任务是通过在参考正方形上实现一个具有以下曲线映射的谱 DG 单元来构造一个反例：\n$$\nx(\\xi,\\eta) = \\xi + \\alpha \\xi^3 + \\beta \\xi \\eta^2, \\quad y(\\xi,\\eta) = \\eta + \\gamma \\eta^3 + \\delta \\xi^2 \\eta,\n$$\n其中 $\\alpha$、$\\beta$、$\\gamma$ 和 $\\delta$ 是实系数，其选择应使映射在 $[-1,1]^2$ 上光滑且 $J > 0$。设自由流平流速度为 $\\mathbf{a} = (a_x,a_y)$，其中 $a_x$ 和 $a_y$ 是常数。体积项的离散残差定义为下式的 Legendre-Gauss-Lobatto 求积近似\n$$\nR = \\iint_{-1}^1 \\frac{1}{J(\\xi,\\eta)}\\left( \\frac{\\partial \\widehat{F}^\\xi}{\\partial \\xi} + \\frac{\\partial \\widehat{F}^\\eta}{\\partial \\eta} \\right)\\, d\\xi\\, d\\eta,\n$$\n如果度量恒等式在离散层面得到满足，对于常数自由流，该值应精确为零。\n\n实现两种计算策略：\n- 朴素的欠积分策略：使用每个方向 $(N+1)$ 个 Legendre-Gauss-Lobatto 节点将 $(x,y)$ 插值到次数为 $N$ 的多项式空间上，在该网格上使用离散微分矩阵计算 $x_\\xi$, $x_\\eta$, $y_\\xi$, $y_\\eta$，在同一网格上构造 $\\widehat{F}^\\xi$ 和 $\\widehat{F}^\\eta$，使用相同的微分矩阵近似 $\\partial_\\xi \\widehat{F}^\\xi$ 和 $\\partial_\\eta \\widehat{F}^\\eta$，并使用 $(N+1)$ 点的张量积 Legendre-Gauss-Lobatto 求积法进行积分。当映射的次数高于 $N$ 时，这是一种故意的欠积分。\n- 精确度量策略：从映射公式中解析地计算导数 $x_\\xi, x_\\eta, y_\\xi, y_\\eta$，解析地计算 $\\widehat{F}^\\xi$ 和 $\\widehat{F}^\\eta$ 及其导数，然后使用每个方向 $Q$ 个 Legendre-Gauss-Lobatto 点进行高阶求积，其中 $Q$ 的选择要足够大以消除求积误差。该策略保留了连续的度量恒等式。\n\n使用这些策略，为以下四个测试用例计算残差大小 $|R|$：\n- 测试用例 1（反例，欠积分）：$N = 3$，$\\alpha = 0.3$，$\\beta = 0.2$，$\\gamma = -0.25$，$\\delta = 0.15$， $a_x = 0.7$, $a_y = -0.4$，朴素欠积分策略。\n- 测试用例 2（适定积分，恒等式保持）：$N = 3$，与测试用例 1 相同的 $\\alpha$, $\\beta$, $\\gamma$, $\\delta$, $a_x$, $a_y$，使用 $Q = 20$ 的精确度量策略。\n- 测试用例 3（仿射映射边界情况）：$N = 3$，$\\alpha = 0$，$\\beta = 0$，$\\gamma = 0$，$\\delta = 0$， $a_x = 0.7$, $a_y = -0.4$，朴素欠积分策略。\n- 测试用例 4（更强的欠积分）：$N = 2$，$\\alpha = 0.3$，$\\beta = 0.2$，$\\gamma = -0.25$，$\\delta = 0.15$， $a_x = 0.7$, $a_y = -0.4$，朴素欠积分策略。\n\n对于每个测试用例，计算标量浮点数 $|R|$。最终输出必须是单行格式，为一个方括号括起来的逗号分隔列表，包含对应于四个测试用例的四个残差大小，例如 $\\left[ r_1, r_2, r_3, r_4 \\right]$，其中每个 $r_i$ 是一个 Python 浮点数表示。\n\n你的程序必须生成单行输出，包含一个方括号括起来的逗号分隔列表形式的结果（例如 $[result1,result2,result3,result4]$）。本问题不涉及物理单位、角度或百分比。通过保持所有计算与定义的映射和数值过程一致来确保科学真实性。你的实现不应依赖任何外部输入或文件，并且必须能按原样运行。",
            "solution": "该问题要求计算离散残差，以证明在曲线单元上的谱间断伽辽金（DG）方法中自由流守恒被违反的情况。当度量项处理不当时，这种违反是任意拉格朗日-欧拉（ALE）公式中一个众所周知的数值伪影。\n\n所涉及的基本原理是几何守恒律（GCL）。对于具有常数自由流（$u=u_0$）和常数平流速度（$\\mathbf{a}$）的稳态标量平流方程 $\\nabla \\cdot (\\mathbf{a} u) = 0$，其散度必须恒为零。变换到参考单元 $(\\xi, \\eta)$ 后，该条件变为\n$$\n\\frac{1}{J}\\left( \\frac{\\partial \\widehat{F}^\\xi}{\\partial \\xi} + \\frac{\\partial \\widehat{F}^\\eta}{\\partial \\eta} \\right) = 0\n$$\n其中 $J$ 是映射的雅可比行列式，$\\widehat{F}^\\xi, \\widehat{F}^\\eta$ 是逆变通量。对于常数自由流 $u=u_0$ 和 $\\mathbf{a}=(a_x, a_y)$，括号中的项可以展开为：\n$$\n\\frac{\\partial \\widehat{F}^\\xi}{\\partial \\xi} + \\frac{\\partial \\widehat{F}^\\eta}{\\partial \\eta} = u_0 \\left[ a_x \\left(\\frac{\\partial y_\\eta}{\\partial \\xi} - \\frac{\\partial y_\\xi}{\\partial \\eta}\\right) + a_y \\left(\\frac{\\partial x_\\xi}{\\partial \\eta} - \\frac{\\partial x_\\eta}{\\partial \\xi}\\right) \\right]\n$$\n该表达式解析上为零，因为对于任何足够光滑的映射 $(x(\\xi,\\eta), y(\\xi,\\eta))$，混合偏导数是相等的（Clairaut 定理），即 $\\frac{\\partial}{\\partial \\xi} \\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\frac{\\partial y}{\\partial \\xi}$，对于 $x$ 也类似。这个解析恒等式就是连续的 GCL。\n\n任务是展示一个朴素的数值实现未能保持此恒等式，从而导致一个非零残差 $R$，定义为强形式残差在参考单元上的数值求积：\n$$\nR = \\iint_{-1}^1 \\frac{1}{J(\\xi,\\eta)}\\left( \\frac{\\partial \\widehat{F}^\\xi}{\\partial \\xi} + \\frac{\\partial \\widehat{F}^\\eta}{\\partial \\eta} \\right)\\, d\\xi\\, d\\eta\n$$\n\n该解决方案通过遵循两种不同的策略来计算此残差来实现。\n\n**策略 1：朴素的欠积分策略**\n此策略模仿了节点 DG 代码中一种常见但有缺陷的实现方式。\n1.  **离散化：** 使用一个 $(N+1) \\times (N+1)$ 的 Legendre-Gauss-Lobatto (LGL) 节点的张量积网格对参考单元 $[-1,1]^2$ 进行离散化。函数由其在此网格上的值表示，这对应于每个变量上次数为 $N$ 的多项式插值。\n2.  **度量计算：** 在 LGL 节点上计算几何映射坐标 $(x,y)$。然后通过将一维微分矩阵 $D$ 应用于节点坐标值来近似映射的导数（度量项 $x_\\xi, x_\\eta, y_\\xi, y_\\eta$）。对于一个 $j$ 索引对应 $\\xi$、$i$ 索引对应 $\\eta$ 的网格，离散导数计算为 $(x_\\xi)_{ij} \\approx (D \\cdot x^T)^T_{ij}$ 和 $(x_\\eta)_{ij} \\approx (D \\cdot x)_{ij}$。\n3.  **通量和雅可比行列式计算：** 逆变通量和雅可比行列式在 LGL 节点上根据先前计算的离散度量项进行逐元素计算。例如，$J_{ij} = (x_\\xi)_{ij} (y_\\eta)_{ij} - (x_\\eta)_{ij} (y_\\xi)_{ij}$。这一步是误差的主要来源。如果解析度量项是多项式，它们的乘积是更高次的多项式。仅通过其在 $N+1$ 个 LGL 节点上的值来表示这个乘积是一种混叠行为——高频内容被错误地表示为低频内容。\n4.  **散度计算：** 通过将微分矩阵 $D$ 应用于节点通量值来计算逆变通量的导数。这是对通量的*混叠*多项式表示进行微分。\n5.  **GCL 违反：** 由于微分应用于乘积的混叠表示，GCL 的离散等价形式不再满足。表示 $(D_\\xi \\widehat{F}^\\xi + D_\\eta \\widehat{F}^\\eta)$ 的离散分子项在数值上不再为零。\n6.  **求积：** 最终残差 $R$ 使用 LGL 求积规则计算，该规则将积分函数（非零分子除以混叠的雅可比行列式）的值与 LGL 求积权重相乘后求和。结果是一个非零残差，表明未能保持自由流。\n\n**策略 2：精确度量策略**\n此策略作为对照，证明如果 GCL 得到满足，残差为零。\n1.  **解析计算：** 度量项及其导数根据映射公式解析计算。\n2.  **GCL 满足：** 如最初所示，$\\frac{\\partial \\widehat{F}^\\xi}{\\partial \\xi} + \\frac{\\partial \\widehat{F}^\\eta}{\\partial \\eta}$ 项处处恒为零。\n3.  **求积：** 一个解析上为零的函数的数值积分，在机器精度内，为零。选择 $Q=20$ 个求积点足以证实这一点。\n\n**测试用例分析：**\n-   **用例 1（$N=3$，非线性映射，朴素策略）：** 三次映射可以由 $P_3$ 多项式精确表示。度量项是二次的。它们的乘积，例如雅可比行列式 $J$，是四次的。这些乘积被混叠到 $P_3$ 空间中。通量是二次的。使用 $N=3$ 的微分矩阵可以精确地对它们进行微分。然而，在节点上计算乘积然后对该乘积的插值函数进行微分的过程违反了 GCL。预期会得到非零残差。\n-   **用例 2（$N=3$，非线性映射，精确策略）：** 解析被积函数为零，因此残差为零。\n-   **用例 3（$N=3$，仿射映射，朴素策略）：** 映射为 $x=\\xi, y=\\eta$。度量项是常数（$x_\\xi=1, y_\\eta=1, x_\\eta=y_\\xi=0$）。所有乘积和导数保持为常数。没有产生次数大于 0 的多项式，因此不会发生混叠。GCL 在离散层面得到满足，残差为零。\n-   **用例 4（$N=2$，非线性映射，朴素策略）：** 这个用例比用例 1 的欠积分更严重。三次映射不能由 $P_2$ 多项式精确表示。这在表示几何本身时就引入了初始误差，此外还有乘积带来的混叠误差。预期会得到比用例 1 更大的残差。\n\n该实现根据指定的步骤计算这四个用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre, roots_jacobi\n\ndef get_lgl(N):\n    \"\"\"\n    Computes the (N+1)-point Legendre-Gauss-Lobatto nodes, weights, and\n    the corresponding differentiation matrix.\n\n    Args:\n        N (int): Polynomial degree. The number of points will be N+1.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: LGL nodes.\n            - np.ndarray: LGL weights.\n            - np.ndarray: LGL differentiation matrix.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0]), np.array([2.0]), np.array([[0.0]])\n\n    # Nodes are roots of (1-x^2) * P_N'(x)\n    # The interior nodes are roots of the Jacobi polynomial P_{N-1}^{(1,1)}(x)\n    x_nodes = np.zeros(N + 1)\n    if N > 1:\n        x_nodes[1:-1] = roots_jacobi(N - 1, alpha=1, beta=1)[0]\n    x_nodes[0], x_nodes[-1] = -1.0, 1.0\n\n    # Legendre polynomial of degree N\n    Pn = legendre(N)\n\n    # Differentiation Matrix D_{ij} = P_N(x_i) / (P_N(x_j) * (x_i - x_j)) for i!=j\n    D = np.zeros((N + 1, N + 1))\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = Pn(x_nodes[i]) / (Pn(x_nodes[j]) * (x_nodes[i] - x_nodes[j]))\n\n    # Diagonal entries\n    D[0, 0] = -N * (N + 1) / 4.0\n    D[N, N] = N * (N + 1) / 4.0\n    # Interior diagonal elements are 0, which is the default from np.zeros.\n\n    # Quadrature weights w_i = 2 / (N*(N+1) * P_N(x_i)^2)\n    weights = 2.0 / (N * (N + 1) * Pn(x_nodes)**2)\n    \n    return x_nodes, weights, D\n\ndef solve():\n    \"\"\"\n    Main function to compute residuals for the four test cases.\n    \"\"\"\n    test_cases = [\n        # (N, params, a, strategy)\n        {'N': 3, 'params': (0.3, 0.2, -0.25, 0.15), 'a': (0.7, -0.4), 'strategy': 'naive'},\n        {'N': 3, 'params': (0.3, 0.2, -0.25, 0.15), 'a': (0.7, -0.4), 'strategy': 'exact'},\n        {'N': 3, 'params': (0.0, 0.0, 0.0, 0.0), 'a': (0.7, -0.4), 'strategy': 'naive'},\n        {'N': 2, 'params': (0.3, 0.2, -0.25, 0.15), 'a': (0.7, -0.4), 'strategy': 'naive'}\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['strategy'] == 'exact':\n            # In the exact metric strategy, the analytical integrand is identically zero\n            # due to the satisfaction of the Geometric Conservation Law (GCL).\n            # A high-order quadrature of zero is zero (to machine precision).\n            result = 0.0\n        else: # strategy == 'naive'\n            N = case['N']\n            alpha, beta, gamma, delta = case['params']\n            ax, ay = case['a']\n            \n            # Get LGL nodes, weights, and differentiation matrix for degree N\n            xi_nodes, weights, D = get_lgl(N)\n            \n            # Create 2D grid and quadrature weights\n            # XI[i, j] = xi_nodes[j], ETA[i, j] = xi_nodes[i]\n            # j-index corresponds to xi, i-index corresponds to eta\n            XI, ETA = np.meshgrid(xi_nodes, xi_nodes)\n            W_grid = np.outer(weights, weights)\n\n            # Evaluate mapping on the LGL grid\n            X = XI + alpha * XI**3 + beta * XI * ETA**2\n            Y = ETA + gamma * ETA**3 + delta * XI**2 * ETA\n            \n            # Compute discrete metric derivatives using the differentiation matrix D.\n            # D acts on columns, which corresponds to the 'eta' direction.\n            # To differentiate w.r.t 'xi', we transpose, differentiate rows, and transpose back.\n            x_eta = D @ X\n            x_xi = (D @ X.T).T\n            y_eta = D @ Y\n            y_xi = (D @ Y.T).T\n\n            # Jacobian on the grid (computed via element-wise products)\n            J = x_xi * y_eta - x_eta * y_xi\n            \n            # Contravariant fluxes for u=1 (computed via element-wise products)\n            F_hat_xi = y_eta * ax - x_eta * ay\n            F_hat_eta = -y_xi * ax + x_xi * ay\n            \n            # Discrete derivatives of contravariant fluxes\n            dF_hat_eta_deta = D @ F_hat_eta\n            dF_hat_xi_dxi = (D @ F_hat_xi.T).T\n            \n            # Form the integrand at quadrature points.\n            # The numerator is the discrete GCL term, which is non-zero due to aliasing.\n            # The denominator is the aliased Jacobian.\n            numerator = dF_hat_xi_dxi + dF_hat_eta_deta\n            integrand = numerator / J\n            \n            # Perform tensor-product LGL quadrature\n            residual = np.sum(W_grid * integrand)\n            result = abs(residual)\n\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "基于前一个实践中发现的问题，本练习将探索维持GCL的解决方案和最佳实践。通过在一个具有挑战性的高频振荡网格上进行计算实验，您将研究不同的求积规则和度量项计算策略如何确保格式能够精确地保持常数解（即“自由流”）。这项实践加强了离散算子的理论性质（如分部求和特性）与数值格式鲁棒性之间的联系。",
            "id": "3364720",
            "problem": "考虑定义在物理坐标 $x \\in \\mathbb{R}$ 上的一维周期性守恒律 $u_t + a u_x = 0$，该方程在参考坐标 $\\xi \\in [0,L]$ 上，于任意拉格朗日-欧拉 (ALE) 框架中，采用间断Galerkin (DG) 方法进行离散。参考坐标与物理坐标之间的映射由一个随时间变化的变形 $x = \\chi(\\xi,t)$ 给出。设全局参考域被划分为 $N_e$ 个等长的仿射单元，并在每个单元上使用 $p$ 次多项式基。\n\n定义网格雅可比 $J(\\xi,t) = \\partial x / \\partial \\xi$ 和网格速度 $w(\\xi,t) = \\partial x / \\partial t$。在ALE守恒形式中，对于恒定解 $u(\\xi,t) = u_0$ 和恒定平流速度 $a$，连续自由流保持性可简化为恒等式 $\\partial J / \\partial t - \\partial w / \\partial \\xi = 0$。在实际的DG离散化中，能否保持恒定的 $u_0$ 关键取决于离散几何守恒律、所选求积法下分部积分的一致性以及边界通量的处理。\n\n您的任务是为恒定自由流的残差实现一个一维节点DG离散（在ALE框架下），并评估在不同求积法和度量计算方法下，对于一个高频变形，离散残差是否在指定容差内消失。具体而言：\n\n1. 使用映射\n$$\nx(\\xi,t) = \\xi + \\alpha \\sin(k \\xi)\\sin(\\omega t),\n$$\n其中参数 $\\alpha  0$， $k \\in \\mathbb{N}$， $\\omega  0$，参考域为 $\\xi \\in [0,L]$ 且 $L = 2\\pi$。该映射是光滑且周期性的。雅可比和网格速度为\n$$\nJ(\\xi,t) = 1 + \\alpha k \\cos(k \\xi)\\sin(\\omega t), \\quad\nw(\\xi,t) = \\alpha \\omega \\sin(k \\xi)\\cos(\\omega t),\n$$\n雅可比的时间导数为\n$$\n\\frac{\\partial J}{\\partial t}(\\xi,t) = \\alpha k \\omega \\cos(k \\xi) \\cos(\\omega t).\n$$\n\n2. 在每个单元上，使用参考单元上的弱形式，为恒定解 $u(\\xi,t) = u_0$ 构建一个节点DG残差。设 $\\{\\phi_i(\\xi)\\}_{i=0}^p$ 表示在所选节点上的拉格朗日基函数。对于每个单元，根据节点求积法构建对角质量权重，并根据节点基函数构建微分矩阵。恒定自由流的离散残差向量 $\\mathbf{R}$ 应组装为\n$$\n\\mathbf{R} \\approx u_0\\, \\mathbf{W}\\, \\left( \\frac{\\partial J}{\\partial t}\\right)\n- \\mathbf{D}^\\top \\mathbf{W}\\, \\left( -u_0 w \\right) + \\boldsymbol{\\phi}(1)\\,F^*_{\\text{right}} - \\boldsymbol{\\phi}(-1)\\,F^*_{\\text{left}},\n$$\n其中 $\\mathbf{W}$ 是对角质量权重，$\\mathbf{D}$ 是关于 $\\xi$ 的节点微分矩阵，$\\boldsymbol{\\phi}(\\pm 1)$ 是基函数在单元边界上的取值。数值通量 $F^*$ 应取为物理迹 $F^* = -u_0\\, w$，在 $\\xi$ 坐标系中相应的边界位置处计算，用于此恒定状态。全局残差是所有单元残差的拼接，诊断量是全局残差的最大绝对值项。\n\n3. 实现两种求积/节点选择：\n   - 高斯-勒让德-洛巴托 (GLL) 节点和权重，定义在 $[-1,1]$ 上，并仿射映射到每个单元。权重应为标准的GLL权重，微分矩阵应根据这些节点上的拉格朗日基函数构建。GLL节点集包含端点。\n   - 高斯-勒让德 (GL) 节点和权重，定义在 $[-1,1]$ 上，并仿射映射到每个单元。权重应为标准的GL权重，微分矩阵应根据这些节点上的拉格朗日基函数构建。GL节点集不包含端点；边界基函数求值 $\\boldsymbol{\\phi}(\\pm 1)$ 必须通过在 $\\pm 1$ 处对拉格朗日基函数求值来计算。\n\n4. 实现两种度量计算模式：\n   - \"discrete-GCL\"：通过将微分矩阵应用于网格速度来计算节点上的 $\\partial J/\\partial t$，即 $\\left(\\partial J/\\partial t\\right)_{\\text{disc}} \\approx \\mathbf{D}\\, \\mathbf{w}$，这强制执行了离散几何守恒律。\n   - \"analytic\"：通过对上述解析表达式进行采样来计算节点上的 $\\partial J/\\partial t$。\n\n5. 使用平流速度 $a=1$ 和恒定解 $u_0=1$（无单位）。使用 $\\omega=1$（弧度/单位时间）。三角函数中的角度以弧度为单位。确保所选的 $\\alpha$ 和 $k$ 在测试中对所有 $\\xi,t$ 满足 $J(\\xi,t)0$，以避免网格折叠。\n\n6. 对于数值评估，定义以下测试套件。每个测试用例是一个元组 $(p, N_e, k, \\alpha, \\text{quad}, \\text{mode}, t_0)$:\n   - 用例 A (理想情况，一致的SBP和离散GCL)：$(5, 4, 12, 0.05, \\text{\"GLL\"}, \\text{\"discrete-GCL\"}, 0.3)$\n   - 用例 B (与A相同，但在GLL下使用解析度量，变形未充分解析)：$(5, 4, 12, 0.05, \\text{\"GLL\"}, \\text{\"analytic\"}, 0.3)$\n   - 用例 C (GL求积法与解析度量，变形温和)：$(3, 2, 2, 0.05, \\text{\"GL\"}, \\text{\"analytic\"}, 0.3)$\n   - 用例 D (GL求积法与解析度量，严重未充分解析)：$(3, 2, 15, 0.05, \\text{\"GL\"}, \\text{\"analytic\"}, 0.3)$\n\n7. 对于每个用例，计算所有单元和节点上的最大绝对残差，如果残差严格小于容差 $\\tau = 10^{-6}$，则返回一个布尔值，表示自由流保持性得以维持。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[True,False,True,False]\"），按顺序对应于用例A–D的结果。此问题中没有物理单位；所有量都是无量纲的，所有三角函数参数都以弧度为单位。",
            "solution": "该问题要求评估一维间断Galerkin (DG) 任意拉格朗日-欧拉 (ALE) 离散化中的自由流保持性。该评估取决于恒定解 $u_0=1$ 的离散残差是否为零。问题的核心在于几何守恒律 (GCL)，对于连续情况，其形式为 $\\partial J/\\partial t - \\partial w/\\partial \\xi = 0$。该恒等式的DG离散化结果也必须为零（在一定容差范围内），这样格式才能保持恒定解。\n\n求解过程如下：\n1.  **参考单元设置**：我们在一个规范的参考单元 $\\xi_{ref} \\in [-1,1]$ 上，为 $p$ 次多项式基定义节点、权重和微分矩阵。需要两种类型的节点：\n    - **高斯-勒让德-洛巴托 (GLL)**：这 $p+1$ 个节点包括端点 $\\pm 1$。节点是 $(1-\\xi_{ref}^2)L'_p(\\xi_{ref})=0$ 的根，其中 $L_p$ 是 $p$ 次勒让德多项式。相应的求积权重和微分矩阵具有分部求和 (SBP) 性质，这对于离散守恒至关重要。\n    - **高斯-勒让德 (GL)**：这 $p+1$ 个节点是 $L_{p+1}(\\xi_{ref})$ 的根，全部位于开区间 $(-1,1)$ 内。对于相同数量的点，这种求积法在计算体积分时比GLL更精确，但它不具备与GLL相同形式的SBP性质。\n\n2.  **微分和基函数求值**：一个关键组成部分是参考单元上的节点微分矩阵 $\\mathbf{D}_{ref}$。其元素为 $D_{ij} = \\ell'_j(\\xi_i)$，其中 $\\{\\ell_j\\}$ 是在节点上定义的拉格朗日基。对于GL节点，还必须在非节点的边界点 $\\xi_{ref}=\\pm 1$ 处对基函数求值，以计算通量贡献。\n\n3.  **单元残差计算**：全局参考域 $\\xi \\in [0, 2\\pi]$ 被划分为 $N_e$ 个单元。对于每个单元，我们执行从参考单元 $\\xi_{ref} \\in [-1,1]$ 到全局参考域中单元 $[\\xi_j, \\xi_{j+1}]$ 的仿射映射。单元宽度为 $\\Delta\\xi = \\xi_{j+1} - \\xi_j = L/N_e$。此映射会缩放微分矩阵和求积权重：\n    - 单元微分矩阵：$\\mathbf{D}_{elem} = \\frac{2}{\\Delta\\xi} \\mathbf{D}_{ref}$。\n    - 单元求积权重：$\\mathbf{w}_{elem} = \\frac{\\Delta\\xi}{2} \\mathbf{w}_{ref}$。\n\n4.  **组装残差**：对于每个单元，根据给定公式组装残差向量 $\\mathbf{R}_{elem}$。设 $u_0=1$。\n    $$ \\mathbf{R}_{elem} = \\mathbf{W}_{elem}\\, \\left( \\frac{\\partial \\mathbf{J}}{\\partial t}\\right) + \\mathbf{D}_{elem}^\\top \\mathbf{W}_{elem}\\, (\\mathbf{w}) - \\left[ \\boldsymbol{\\phi}(1)\\, (w)_{\\text{right}} - \\boldsymbol{\\phi}(-1)\\,(w)_{\\text{left}} \\right] $$\n    - 向量 $\\partial\\mathbf{J}/\\partial t$ 和 $\\mathbf{w}$ 包含了在时间 $t_0$ 时，在单元节点上求值的相应函数值。\n    - $\\partial\\mathbf{J}/\\partial t$ 的计算取决于 `mode`：\n        - 在 `\"analytic\"` 模式下，对精确的解析公式进行采样。\n        - 在 `\"discrete-GCL\"` 模式下，其计算方式为 $\\partial\\mathbf{J}/\\partial t \\approx \\mathbf{D}_{elem} \\mathbf{w}$，这在离散层面强制执行了GCL。\n    - 边通量项涉及到在单元精确边界 $\\xi_j$ 和 $\\xi_{j+1}$ 处求值的网格速度 $w$，以及在 $\\pm 1$ 处求值的拉格朗日基函数。\n\n5.  **全局诊断**：全局残差是所有 $\\mathbf{R}_{elem}$ 向量的拼接。将该全局向量的最大绝对值与容差 $\\tau = 10^{-6}$ 进行比较，以确定自由流是否得到保持。\n\n**预期结果：**\n- **用例 A (GLL, discrete-GCL)**：GLL微分矩阵和求积法的SBP性质确保离散GCL能满足到机器精度。体积分项和边界项将完全抵消。残差应接近于零。\n- **用例 B (GLL, analytic)**：`analytic` 模式破坏了离散抵消。残差现在取决于 $p=5$ 次多项式基能否解析高频网格变形 ($k=12$)。仅用 $N_e=4$ 个单元，每个单元必须捕捉 $2\\pi/4 \\div 2\\pi/12 = 3$ 个波长，这将导致显著的混叠和求积误差。预计残差会很大。\n- **用例 C (GL, analytic)**：相对于离散化 ($p=3, N_e=2$)，变形 ($k=2$) 是温和的。每个单元覆盖一个波长 ($2\\pi/2 \\div 2\\pi/2 = 1$)。GL求积法对于光滑函数非常精确，因此误差应该很小，可能低于容差。\n- **用例 D (GL, analytic)**：在 $N_e=2$ 个单元上，变形 ($k=15$) 被 $p=3$ 次多项式严重欠解析。每个单元必须捕捉 $2\\pi/2 \\div 2\\pi/15 = 7.5$ 个波长。求积和微分误差将非常大。预计残差会很大。\n\n实现过程将创建函数以生成必要的矩阵和节点，然后遍历测试用例来计算结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi, eval_legendre\nfrom numpy.polynomial.legendre import leggauss\n\ndef gll_nodes_weights(p):\n    \"\"\"\n    Computes Gauss-Legendre-Lobatto nodes and weights for polynomial degree p.\n    \"\"\"\n    if p == 0:\n        return np.array([-1.0]), np.array([2.0])\n    \n    # Nodes are endpoints and roots of L_p'(x)\n    # Roots of L_p'(x) are roots of Jacobi polynomial P_{p-1}^{(1,1)}(x)\n    inner_nodes, _ = roots_jacobi(p - 1, 1, 1)\n    nodes = np.sort(np.concatenate(([-1.0], inner_nodes, [1.0])))\n    \n    # Weights\n    weights = 2.0 / (p * (p + 1) * eval_legendre(p, nodes)**2)\n    \n    return nodes, weights\n\ndef gl_nodes_weights(p):\n    \"\"\"\n    Computes Gauss-Legendre nodes and weights for polynomial degree p (p+1 points).\n    \"\"\"\n    nodes, weights = leggauss(p + 1)\n    return nodes, weights\n\ndef differentiation_matrix(nodes):\n    \"\"\"\n    Computes the nodal differentiation matrix for Lagrange basis on given nodes.\n    \"\"\"\n    n = len(nodes)\n    D = np.zeros((n, n))\n    \n    # Use barycentric formula for stability and clarity\n    # w_j = 1 / product(x_j - x_k for k!=j)\n    bary_weights = np.ones(n)\n    for j in range(n):\n        for k in range(n):\n            if k != j:\n                bary_weights[j] /= (nodes[j] - nodes[k])\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                D[i, j] = (bary_weights[j] / bary_weights[i]) / (nodes[i] - nodes[j])\n        D[i, i] = -np.sum(D[i, :])\n        \n    return D\n\ndef lagrange_basis_eval(nodes, x_eval):\n    \"\"\"\n    Evaluates the Lagrange basis functions defined on `nodes` at point `x_eval`.\n    \"\"\"\n    n = len(nodes)\n    evals = np.zeros(n)\n    for j in range(n):\n        num, den = 1.0, 1.0\n        for m in range(n):\n            if m == j:\n                continue\n            num *= (x_eval - nodes[m])\n            den *= (nodes[j] - nodes[m])\n        evals[j] = num / den\n    return evals\n\ndef solve():\n    \"\"\"\n    Main solver to run the test cases for free-stream preservation.\n    \"\"\"\n    test_cases = [\n        (5, 4, 12, 0.05, \"GLL\", \"discrete-GCL\", 0.3),  # Case A\n        (5, 4, 12, 0.05, \"GLL\", \"analytic\", 0.3),    # Case B\n        (3, 2, 2, 0.05, \"GL\", \"analytic\", 0.3),       # Case C\n        (3, 2, 15, 0.05, \"GL\", \"analytic\", 0.3),     # Case D\n    ]\n\n    results = []\n    L = 2.0 * np.pi\n    u0 = 1.0\n    omega = 1.0\n    tolerance = 1e-6\n\n    for p, Ne, k, alpha, quad_type, mode, t0 in test_cases:\n        num_nodes = p + 1\n\n        # 1. Get reference element properties\n        if quad_type == \"GLL\":\n            nodes_ref, weights_ref = gll_nodes_weights(p)\n            phi_at_minus1 = np.zeros(num_nodes); phi_at_minus1[0] = 1.0\n            phi_at_plus1 = np.zeros(num_nodes); phi_at_plus1[-1] = 1.0\n        else: # \"GL\"\n            nodes_ref, weights_ref = gl_nodes_weights(p)\n            phi_at_minus1 = lagrange_basis_eval(nodes_ref, -1.0)\n            phi_at_plus1 = lagrange_basis_eval(nodes_ref, 1.0)\n            \n        D_ref = differentiation_matrix(nodes_ref)\n\n        # 2. Main loop over elements\n        delta_xi = L / Ne\n        global_residual = np.zeros(Ne * num_nodes)\n\n        for i in range(Ne):\n            xi_left = i * delta_xi\n            xi_right = (i + 1) * delta_xi\n            \n            # Affine mapping: xi_ref in [-1,1] to xi in [xi_left, xi_right]\n            xi_nodes = xi_left + (delta_xi / 2.0) * (nodes_ref + 1.0)\n            \n            # Element matrices\n            D_elem = D_ref * (2.0 / delta_xi)\n            W_elem_weights = weights_ref * (delta_xi / 2.0)\n\n            # Compute metric terms at nodes\n            w_vals = alpha * omega * np.sin(k * xi_nodes) * np.cos(omega * t0)\n            \n            if mode == \"discrete-GCL\":\n                dJdt_vals = D_elem @ w_vals\n            else: # \"analytic\"\n                dJdt_vals = alpha * k * omega * np.cos(k * xi_nodes) * np.cos(omega * t0)\n            \n            # Assemble element residual\n            time_term = u0 * W_elem_weights * dJdt_vals\n            volume_term = u0 * D_elem.T @ (W_elem_weights * w_vals)\n            \n            # Boundary flux terms\n            w_left_bnd = alpha * omega * np.sin(k * xi_left) * np.cos(omega * t0)\n            w_right_bnd = alpha * omega * np.sin(k * xi_right) * np.cos(omega * t0)\n            F_star_left = -u0 * w_left_bnd\n            F_star_right = -u0 * w_right_bnd\n            \n            flux_term = phi_at_plus1 * F_star_right - phi_at_minus1 * F_star_left\n            \n            R_elem = time_term + volume_term + flux_term\n            global_residual[i * num_nodes:(i + 1) * num_nodes] = R_elem\n        \n        max_abs_residual = np.max(np.abs(global_residual))\n        results.append(max_abs_residual  tolerance)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}