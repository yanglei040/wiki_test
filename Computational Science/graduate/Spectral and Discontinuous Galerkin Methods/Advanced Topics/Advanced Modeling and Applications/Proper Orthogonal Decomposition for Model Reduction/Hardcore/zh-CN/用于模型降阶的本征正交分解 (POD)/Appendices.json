{
    "hands_on_practices": [
        {
            "introduction": "在处理高维系统时，当状态维度 $N$ 远大于快照数量 $m$ 时，快照方法是计算本征正交分解（POD）的关键算法。这项练习  将指导你从第一性原理出发，推导并实现一个通用的加权POD算法，其中权重由一个对称正定矩阵 $M$（例如，有限元或间断Galerkin方法中的质量矩阵）定义。通过这个实践，你将掌握将高维特征值问题转化为低维问题并进行数值验证的核心技术。",
            "id": "3410811",
            "problem": "给定一个快照矩阵 $X\\in\\mathbb{R}^{N\\times m}$（其中 $m\\ll N$）和一个对称正定矩阵 $M\\in\\mathbb{R}^{N\\times N}$，该矩阵导出加权内积 $\\langle u,v\\rangle_M = u^\\top M v$ 和范数 $\\|u\\|_M = \\sqrt{u^\\top M u}$。在本征正交分解（POD）问题中，需要寻找一个 $M$-正交标准基，以最大化快照的均方投影，其中 $M$ 例如代表由谱方法或间断 Galerkin 离散化产生的质量矩阵。快照法通过快照空间中的一个特征值问题来构建 POD 模态。\n\n从 POD 子空间的定义（即作为正交标准基向量所捕获的平均 $M$-能量的约束最大化问题的解）出发，基于基本线性代数原理，推导一个使用快照法计算 $M$-正交标准 POD 模态的显式算法。您的推导必须从 $M$-内积下的最优性变分表征开始，并将问题简化为在 $m$ 维快照空间中构建的一个特征值问题。该算法必须基于一个有原则的容差自动确定数值秩，并且在 $X$ 是秩亏的情况下必须是鲁棒的。\n\n然后将您的算法实现为一个程序，该程序：\n- 给定几个测试用例 $(M,X)$，计算 POD 模态并验证其 $M$-正交标准性。具体来说，如果 $\\Phi\\in\\mathbb{R}^{N\\times r}$ 表示计算出的 POD 基（其中 $r$ 等于确定的数值秩），请验证 $\\Phi^\\top M \\Phi$ 在一致的数值容差内是大小为 $r$ 的单位矩阵。\n- 对于每个测试用例，返回一个布尔值，该值指示 $M$-正交标准性检查是否通过，并且返回的模态数量是否等于根据您的容差从快照空间特征值问题确定的数值秩。\n\n此问题不涉及物理单位或角度。所有输出均为无量纲。您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[{\\rm True},{\\rm False},\\dots]$。\n\n使用以下测试套件。对于以下所有情况，$N$ 和 $m$ 由矩阵维度可知。\n\n测试用例一（理想情况）：\n- $M_1 = I_6$，即大小为 6 的单位矩阵。\n- $X_1 = \\begin{bmatrix}\n1 & 2 & 3\\\\\n0 & 1 & 0\\\\\n1 & 0 & 1\\\\\n2 & 1 & 0\\\\\n0 & 1 & 2\\\\\n1 & 0 & 0\n\\end{bmatrix}$。\n\n测试用例二（非平凡对角矩阵 $M$）：\n- $M_2 = \\mathrm{diag}(2,\\,0.5,\\,3,\\,1.5,\\,4,\\,1)$。\n- $X_2 = \\begin{bmatrix}\n0.5 & 1.0 & -1.0\\\\\n2.0 & -1.0 & 0.0\\\\\n1.5 & 0.0 & 2.0\\\\\n0.0 & 1.0 & 1.0\\\\\n-1.0 & 0.5 & 0.0\\\\\n1.0 & -0.5 & 2.0\n\\end{bmatrix}$。\n\n测试用例三（秩亏快照，以及由给定 $A$ 构造的对称正定矩阵 $M$）：\n- 定义 $A_3 = \\begin{bmatrix}\n1 & 0 & 2 & 0 & 1 & 0\\\\\n0 & 1 & 0 & 2 & 0 & 1\\\\\n1 & 1 & 0 & 0 & 1 & 0\\\\\n0 & 0 & 1 & 1 & 0 & 1\\\\\n1 & 0 & 0 & 1 & 1 & 0\\\\\n0 & 1 & 1 & 0 & 0 & 1\n\\end{bmatrix}$ 并设置 $M_3 = A_3^\\top A_3 + 0.1\\,I_6$。\n- 令 $c_1 = \\begin{bmatrix}1\\\\0\\\\1\\\\0\\\\1\\\\0\\end{bmatrix}$ 且 $c_2 = \\begin{bmatrix}0\\\\1\\\\0\\\\1\\\\0\\\\1\\end{bmatrix}$，并构成 $X_3 = \\begin{bmatrix} c_1 & c_2 & (c_1+c_2) & (2\\,c_2)\\end{bmatrix}$。\n\n测试用例四（单个快照）：\n- $M_4 = \\mathrm{diag}(1,\\,2,\\,3,\\,4,\\,5)$。\n- $X_4 = \\begin{bmatrix}1\\\\-1\\\\2\\\\0\\\\3\\end{bmatrix}$。\n\n测试用例五（病态对角矩阵 $M$）：\n- $M_5 = \\mathrm{diag}(10^{-6},\\,10^{-3},\\,1,\\,10^{3},\\,10^{6},\\,2)$。\n- $X_5 = \\begin{bmatrix}\n1.0 & 0.0 & 0.5\\\\\n0.0 & 1.0 & -0.5\\\\\n0.5 & -0.5 & 1.0\\\\\n1.0 & 0.0 & -1.0\\\\\n0.0 & 1.0 & 0.0\\\\\n1.0 & -1.0 & 0.0\n\\end{bmatrix}$。\n\n算法和验证要求：\n- 在 $M$-内积下，从第一性原理推导快照法，将构造过程简化为快照空间中的特征值问题，并通过回代形成模态。\n- 通过对快照空间相关矩阵的特征值（相对于其最大特征值和机器精度）进行阈值处理，实现数值秩的数值稳定选择。如果 $r$ 是高于阈值的特征值数量，则精确返回 $r$ 个模态。\n- 通过验证 $\\Phi^\\top M \\Phi - I_r$ 的 Frobenius 范数小于一个随问题规模和机器精度适当缩放的容差，来检验 $M$-正交标准性。\n- 对于每个测试用例，如果正交标准性验证通过且返回的模态数量等于确定的数值秩，则输出布尔值 ${\\rm True}$，否则输出 ${\\rm False}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[{\\rm True},{\\rm False},{\\rm True},{\\rm True},{\\rm True}]$。",
            "solution": "计算本征正交分解（POD）模态的问题本质上是一个优化问题。给定由矩阵 $X \\in \\mathbb{R}^{N \\times m}$ 的列表示的一组快照，以及一个定义了加权内积 $\\langle u, v \\rangle_M = u^\\top M v$ 的对称正定（SPD）矩阵 $M \\in \\mathbb{R}^{N \\times N}$，我们寻求一个 $M$-正交标准基 $\\{\\phi_k\\}_{k=1}^r$ 来最优地捕获快照的“能量”。当快照数量 $m$ 远小于状态维数 $N$ (即 $m \\ll N$) 时，“快照法”是解决此问题的一种高效算法。\n\n我们从其变分基础开始推导该算法。第一个 POD 模态 $\\phi_1$ 是在 $M$-范数下归一化的约束下，最大化快照均方投影的向量。这可以表示为以下优化问题：\n$$\n\\max_{\\phi \\in \\mathbb{R}^N} \\frac{1}{m} \\sum_{j=1}^{m} |\\langle x_j, \\phi \\rangle_M|^2 \\quad \\text{subject to} \\quad \\|\\phi\\|_M^2 = 1\n$$\n其中 $x_j$ 是快照矩阵 $X$ 的第 $j$ 列。\n\n目标函数可以用矩阵表示法重写。内积的平方为 $|\\langle x_j, \\phi \\rangle_M|^2 = (\\phi^\\top M x_j)(x_j^\\top M \\phi)$。对所有快照求和得到：\n$$\n\\frac{1}{m} \\sum_{j=1}^{m} \\phi^\\top M x_j x_j^\\top M \\phi = \\phi^\\top M \\left( \\frac{1}{m} \\sum_{j=1}^{m} x_j x_j^\\top \\right) M \\phi = \\phi^\\top M \\left( \\frac{1}{m} X X^\\top \\right) M \\phi\n$$\n令 $C_X = \\frac{1}{m} X X^\\top$ 为空间相关矩阵。约束条件是 $\\|\\phi\\|_M^2 = \\phi^\\top M \\phi = 1$。$\\phi_1$ 的优化问题是：\n$$\n\\max_{\\phi \\in \\mathbb{R}^N} \\phi^\\top M C_X M \\phi \\quad \\text{subject to} \\quad \\phi^\\top M \\phi = 1\n$$\n这是一个标准的 Rayleigh 商问题。使用 Lagrange 乘子法，我们定义拉格朗日函数 $\\mathcal{L}(\\phi, \\sigma) = \\phi^\\top M C_X M \\phi - \\sigma (\\phi^\\top M \\phi - 1)$。对 $\\phi^\\top$ 求梯度并令其为零，得到广义特征值问题：\n$$\nM C_X M \\phi = \\sigma M \\phi\n$$\n由于 $M$ 是可逆的，这等价于 $C_X M \\phi = \\sigma \\phi$。这是一个 $N \\times N$ 的特征值问题，如果 $N$ 很大，直接求解的计算成本会非常高。\n\n快照法通过利用任何 POD 模态 $\\phi$ 都必须位于快照的张成空间中这一事实，提供了一种高效的替代方法。要理解这一点，请注意从特征值方程可知，$\\phi = \\frac{1}{\\sigma} C_X M \\phi = \\frac{1}{\\sigma m} (XX^\\top) M \\phi$。这可以写成 $\\phi = \\sum_{j=1}^m \\alpha_j x_j$，其中系数为 $\\alpha_j = \\frac{1}{\\sigma m} x_j^\\top M \\phi$。这表明 $\\phi \\in \\text{span}\\{x_1, \\dots, x_m\\}$。\n\n因此，我们可以寻求形如快照线性组合的 POD 模态：\n$$\n\\phi = X a = \\sum_{j=1}^{m} a_j x_j\n$$\n其中 $a \\in \\mathbb{R}^m$ 是某个系数向量。将此 ansatz 形式代入原始变分问题，目标函数变为：\n$$\n\\phi^\\top M C_X M \\phi = (Xa)^\\top M \\left(\\frac{1}{m}XX^\\top\\right) M (Xa) = \\frac{1}{m} a^\\top (X^\\top M X) (X^\\top M X) a\n$$\n我们定义快照 Gram 矩阵 $K_m = X^\\top M X \\in \\mathbb{R}^{m \\times m}$。该矩阵是对称半正定的。目标函数简化为 $\\frac{1}{m} a^\\top K_m^2 a$。约束条件 $\\phi^\\top M \\phi = 1$ 变为：\n$$\n(Xa)^\\top M (Xa) = a^\\top (X^\\top M X) a = a^\\top K_m a = 1\n$$\n问题简化为系数向量 $a$ 的一个 $m$ 维优化问题：\n$$\n\\max_{a \\in \\mathbb{R}^m} \\frac{1}{m} a^\\top K_m^2 a \\quad \\text{subject to} \\quad a^\\top K_m a = 1\n$$\n再次，我们构造拉格朗日函数 $\\mathcal{L}(a, \\lambda) = \\frac{1}{m} a^\\top K_m^2 a - \\lambda(a^\\top K_m a - 1)$。平稳性条件是 $\\frac{1}{m} K_m^2 a - \\lambda K_m a = 0$。由于我们寻求的是非平凡模态，我们对 $K_m$ 的零空间（其中 $K_m a = 0$）不感兴趣。对于零空间之外的 $a$，我们可以简化为：\n$$\nK_m a = m \\lambda a\n$$\n这是一个标准的 $m \\times m$ 特征值问题。令 $(\\lambda_k, a_k)$（其中 $k=1, \\dots, r$）为 $K_m$ 的特征对，其中 $r \\le m$ 是 $K_m$ 的秩。特征值 $\\lambda_k$ 是模态的 $M$-加权能量，而特征向量 $a_k$ 提供了构建 POD 模态的系数。由于 $K_m$ 是对称的，其特征向量可以选择为正交标准的，即 $a_k^\\top a_j = \\delta_{kj}$。\n\nPOD 模态 $\\phi_k$ 是由特征向量 $a_k$ 构建的。首先，我们构造“预模态” $\\tilde{\\phi}_k = X a_k$。它们的 $M$-内积为：\n$$\n\\langle \\tilde{\\phi}_k, \\tilde{\\phi}_j \\rangle_M = (Xa_k)^\\top M (Xa_j) = a_k^\\top (X^\\top M X) a_j = a_k^\\top K_m a_j = a_k^\\top (\\lambda_j a_j) = \\lambda_j (a_k^\\top a_j) = \\lambda_j \\delta_{kj}\n$$\n这表明预模态是 $M$-正交的。预模态的 $M$-范数是 $\\|\\tilde{\\phi}_k\\|_M = \\sqrt{\\lambda_k}$。为了获得一个 $M$-正交标准基，我们对每个预模态进行归一化：\n$$\n\\phi_k = \\frac{\\tilde{\\phi}_k}{\\|\\tilde{\\phi}_k\\|_M} = \\frac{X a_k}{\\sqrt{\\lambda_k}}\n$$\n这对于所有严格为正的特征值 $\\lambda_k > 0$ 均有效。\n\n完整的算法如下：\n1.  **构造快照 Gram 矩阵**：计算 $m \\times m$ 矩阵 $K_m = X^\\top M X$。\n2.  **求解特征值问题**：求解对称特征值问题 $K_m a_k = \\lambda_k a_k$，得到特征值 $\\lambda_k$ 和正交标准的特征向量 $a_k$。\n3.  **确定秩**：将特征值按降序排序：$\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_m \\ge 0$。数值秩 $r$ 是通过保留相对于最大特征值而言显著的特征值来确定的。一个有原则的容差是 $\\tau = \\lambda_1 \\cdot m \\cdot \\epsilon_{\\text{mach}}$，其中 $\\epsilon_{\\text{mach}}$ 是机器 epsilon。秩 $r$ 是满足 $\\lambda_k > \\tau$ 的特征值的数量。\n4.  **构建模态**：对于选定的 $r$ 个特征对 $(\\lambda_k, a_k)$，构建 POD 模态 $\\phi_k = \\frac{1}{\\sqrt{\\lambda_k}} X a_k$。最终的基为 $\\Phi = [\\phi_1, \\dots, \\phi_r] \\in \\mathbb{R}^{N \\times r}$。\n5.  **验证**：通过检查矩阵 $\\Phi^\\top M \\Phi$ 是否接近单位矩阵 $I_r$ 来确认计算出的基 $\\Phi$ 确实是 $M$-正交标准的。偏差由 Frobenius 范数 $\\|\\Phi^\\top M \\Phi - I_r\\|_F$ 来衡量，该值应低于一个验证容差。一个鲁棒的容差必须考虑到问题的数值条件，这与被求逆的有效矩阵的条件数有关，即 $\\kappa(K_m) = \\lambda_1 / \\lambda_r$。\n\n此推导及其得到的算法提供了一个完整、鲁棒的流程，用于使用快照法计算 $M$-正交标准 POD 模态，包括有原则的秩确定和验证。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the POD algorithm on them.\n    \"\"\"\n\n    def compute_pod_modes(M: np.ndarray, X: np.ndarray) -> bool:\n        \"\"\"\n        Computes M-orthonormal POD modes using the method of snapshots and verifies the result.\n        \n        Args:\n            M: The symmetric positive definite mass matrix (N x N).\n            X: The snapshot matrix (N x m).\n        \n        Returns:\n            A boolean that is True if the M-orthonormality check passes and the\n            number of returned modes equals the determined numerical rank.\n        \"\"\"\n        N, m = X.shape\n\n        if m == 0:\n            # Vacuously true: numerical rank is 0, 0 modes are returned,\n            # and orthonormality of an empty set is trivial.\n            return True\n\n        # Step 1: Form the snapshot-space Gram matrix Km = X^T * M * X\n        Km = X.T @ M @ X\n\n        # Step 2: Solve the eigenvalue problem for the symmetric matrix Km\n        try:\n            # eigh returns eigenvalues in ascending order and orthonormal eigenvectors\n            eigenvalues, eigenvectors = eigh(Km)\n        except np.linalg.LinAlgError:\n            # This can occur if Km contains non-finite values, indicating an invalid setup.\n            return False\n\n        # Sort eigenvalues and corresponding eigenvectors in descending order\n        sorted_indices = np.argsort(eigenvalues)[::-1]\n        lambdas = eigenvalues[sorted_indices]\n        A = eigenvectors[:, sorted_indices]\n\n        # Step 3: Determine the numerical rank r based on a principled tolerance\n        lambda_max = lambdas[0] if m > 0 and len(lambdas) > 0 else 0.0\n        \n        if lambda_max == 0:\n            # This happens if all snapshots are in the null space of M or are zero vectors.\n            r = 0\n        else:\n            # Rank tolerance relative to the largest eigenvalue, machine precision, and problem size\n            rank_tol = lambda_max * m * np.finfo(float).eps\n            r = np.sum(lambdas > rank_tol)\n\n        if r == 0:\n            # No significant modes were found. The number of modes returned (0) matches rank (0).\n            return True\n\n        # Step 4: Select the top r eigenvalues and eigenvectors\n        top_lambdas = lambdas[:r]\n        top_A = A[:, :r]\n\n        # Step 5: Construct the POD modes\n        # phi_k = (1/sqrt(lambda_k)) * X @ a_k\n        # In matrix form: Phi = X @ A_r @ Lambda_r^(-1/2)\n        Phi = (X @ top_A) / np.sqrt(top_lambdas)\n\n        # Step 6: Verification\n        # 6a: The number of returned modes must match the determined rank.\n        num_modes_ok = (Phi.shape[1] == r)\n\n        # 6b: The computed basis Phi must be M-orthonormal.\n        # We check if Phi^T @ M @ Phi is close to the identity matrix.\n        check_matrix = Phi.T @ M @ Phi\n        Id_r = np.eye(r)\n        frob_norm_diff = np.linalg.norm(check_matrix - Id_r, 'fro')\n\n        # A principled verification tolerance that adapts to the problem's conditioning.\n        # The condition number of the snapshot Gram matrix subproblem.\n        lambda_min_r = top_lambdas[-1]\n        cond_Km_r = lambda_max / lambda_min_r if lambda_min_r > 0 else np.inf\n\n        # The tolerance scales with problem size, machine epsilon, and conditioning.\n        # We also set a minimum tolerance floor for well-conditioned problems.\n        verify_tol = max(1e-9, np.sqrt(r) * cond_Km_r * m * np.finfo(float).eps)\n        \n        orthonormality_ok = (frob_norm_diff  verify_tol)\n\n        return orthonormality_ok and num_modes_ok\n\n    # Define test cases\n    # Test case one\n    M1 = np.eye(6)\n    X1 = np.array([\n        [1, 2, 3], [0, 1, 0], [1, 0, 1],\n        [2, 1, 0], [0, 1, 2], [1, 0, 0]\n    ], dtype=float)\n\n    # Test case two\n    M2 = np.diag([2.0, 0.5, 3.0, 1.5, 4.0, 1.0])\n    X2 = np.array([\n        [0.5, 1.0, -1.0], [2.0, -1.0, 0.0], [1.5, 0.0, 2.0],\n        [0.0, 1.0, 1.0], [-1.0, 0.5, 0.0], [1.0, -0.5, 2.0]\n    ], dtype=float)\n\n    # Test case three\n    A3 = np.array([\n        [1, 0, 2, 0, 1, 0], [0, 1, 0, 2, 0, 1], [1, 1, 0, 0, 1, 0],\n        [0, 0, 1, 1, 0, 1], [1, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 1]\n    ], dtype=float)\n    M3 = A3.T @ A3 + 0.1 * np.eye(6)\n    c1 = np.array([1, 0, 1, 0, 1, 0], dtype=float)\n    c2 = np.array([0, 1, 0, 1, 0, 1], dtype=float)\n    X3 = np.array([c1, c2, c1 + c2, 2 * c2]).T\n\n    # Test case four\n    M4 = np.diag([1.0, 2.0, 3.0, 4.0, 5.0])\n    X4 = np.array([[1], [-1], [2], [0], [3]], dtype=float)\n\n    # Test case five\n    M5 = np.diag([1e-6, 1e-3, 1.0, 1e3, 1e6, 2.0])\n    X5 = np.array([\n        [1.0, 0.0, 0.5], [0.0, 1.0, -0.5], [0.5, -0.5, 1.0],\n        [1.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, -1.0, 0.0]\n    ], dtype=float)\n\n    test_cases = [\n        (M1, X1),\n        (M2, X2),\n        (M3, X3),\n        (M4, X4),\n        (M5, X5),\n    ]\n\n    results = []\n    for M, X in test_cases:\n        result = compute_pod_modes(M, X)\n        results.append(str(result))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "实际工程和物理问题常常涉及非齐次的边界条件，这给标准POD方法的直接应用带来了挑战。这项练习  介绍了一种有效的处理策略：使用提升函数将问题分解为一个满足非齐次边界的已知部分和一个满足齐次边界的未知部分。通过推导修正后的降阶模型，你将学会如何将POD框架应用于更广泛、更现实的偏微分方程问题。",
            "id": "3410807",
            "problem": "考虑单位区间上具有非齐次狄利克雷边界条件的一维热方程，\n$$\nu_t(x,t) = u_{xx}(x,t) + f(x,t), \\quad x \\in (0,1), \\; t0,\n$$\n满足\n$$\nu(0,t) = g_0(t), \\qquad u(1,t) = g_1(t),\n$$\n以及与边界数据一致的给定初始条件 $u(x,0) = u_0(x)$。在谱伽辽金 (spectral Galerkin) 或间断伽辽金 (Discontinuous Galerkin, DG) 离散化中，将使用本征正交分解 (Proper Orthogonal Decomposition, POD) 进行模型降阶。为了处理非齐次边界条件，引入形式为 $u = \\ell + \\tilde{u}$ 的提升，其中提升函数 $\\ell$ 强制施加边界值，而齐次分量 $\\tilde{u}$ 满足齐次狄利克雷边界条件。\n\n1) 从强形式和作为边界提升的 $\\ell$ 的定义出发，推导控制 $\\tilde{u}$ 的偏微分方程及其适用于到齐次狄利克雷测试函数上进行伽辽金投影的弱形式。清晰地表达强迫项如何被提升所修正，并指明来自 $\\ell_t$ 和 $\\ell_{xx}$ 的贡献。\n\n2) 设 $\\{\\varphi_i(x)\\}_{i=1}^r$ 是在强制施加齐次狄利克雷边界条件的降阶空间中计算出的 POD 模态。设 $L^2(0,1)$ 内积为伽辽金内积。推导由展开式 $\\tilde{u}(x,t) = \\sum_{i=1}^r a_i(t)\\,\\varphi_i(x)$ 定义的模态系数 $a_i(t)$ 的降阶模型。你的推导必须从弱形式出发，得到一个形如下式的常微分方程组\n$$\n\\mathbf{M}\\,\\dot{\\mathbf{a}}(t) + \\mathbf{S}\\,\\mathbf{a}(t) = \\mathbf{F}(t),\n$$\n并用所选内积和由提升引起的修正强迫项来确定降阶质量矩阵 $\\mathbf{M}$、刚度矩阵 $\\mathbf{S}$ 和降阶强迫向量 $\\mathbf{F}(t)$。\n\n3) 从第一性原理阐明，如何从一个通过数值通量强制施加非齐次边界条件的 DG 模拟产生的全阶快照 $u$ 中，计算齐次分量 $\\tilde{u}$ 的快照。指明如何为 POD 构建快照集合和相关算子，以使模态满足齐次狄利克雷边界条件，且内积与离散 DG 质量矩阵一致。\n\n4) 现在特化到以下数据，你必须使用这些数据进行具体计算。取边界数据和源项\n$$\ng_0(t) = \\sin(t), \\qquad g_1(t) = 0, \\qquad f(x,t) = x,\n$$\n并选择线性提升函数\n$$\n\\ell(x,t) = g_0(t)\\,(1-x) + g_1(t)\\,x.\n$$\n设降阶基由前两个 $L^2(0,1)$ 正交归一的正弦函数组成，\n$$\n\\varphi_1(x) = \\sqrt{2}\\,\\sin(\\pi x), \\qquad \\varphi_2(x) = \\sqrt{2}\\,\\sin(2\\pi x).\n$$\n使用你的通用降阶模型，计算降阶强迫项的第一个分量 $F_1(t)$，然后在 $t = \\ln(2)$ 处求其值。将你的最终答案表示为以初等函数构成的闭式解析表达式。不要近似；不需要四舍五入。要求的最终答案是 $F_1(\\ln 2)$ 的值，以无单位的单个闭式表达式给出。",
            "solution": "该问题是有效的，因为它在偏微分方程理论和数值方法方面具有科学依据，是适定的、客观的，并包含了完整求解所需的所有信息。\n\n该问题要求给出一个分为四部分的解答，涉及使用本征正交分解 (POD) 对带非齐次边界条件的一维热方程进行模型降阶。\n\n**1) 齐次分量的偏微分方程及其弱形式的推导**\n\n给定的偏微分方程 (PDE) 是热方程：\n$$\nu_t(x,t) = u_{xx}(x,t) + f(x,t), \\quad x \\in (0,1), \\; t0\n$$\n带有非齐次狄利克雷边界条件：\n$$\nu(0,t) = g_0(t), \\qquad u(1,t) = g_1(t)\n$$\n我们引入一个提升分解 $u(x,t) = \\ell(x,t) + \\tilde{u}(x,t)$。函数 $\\ell(x,t)$ 是提升函数，旨在满足非齐次边界条件，即 $\\ell(0,t) = g_0(t)$ 和 $\\ell(1,t) = g_1(t)$。因此，新的未知函数 $\\tilde{u}(x,t)$ 必须满足齐次狄利克雷边界条件：\n$$\n\\tilde{u}(0,t) = u(0,t) - \\ell(0,t) = g_0(t) - g_0(t) = 0\n$$\n$$\n\\tilde{u}(1,t) = u(1,t) - \\ell(1,t) = g_1(t) - g_1(t) = 0\n$$\n为了找到控制 $\\tilde{u}$ 的偏微分方程，我们将分解式 $u = \\ell + \\tilde{u}$ 代入原始热方程。我们计算 $u$ 的偏导数：\n$$\nu_t = \\frac{\\partial}{\\partial t}(\\ell + \\tilde{u}) = \\ell_t + \\tilde{u}_t\n$$\n$$\nu_{xx} = \\frac{\\partial^2}{\\partial x^2}(\\ell + \\tilde{u}) = \\ell_{xx} + \\tilde{u}_{xx}\n$$\n将这些代入 PDE 得到：\n$$\n\\ell_t + \\tilde{u}_t = (\\ell_{xx} + \\tilde{u}_{xx}) + f(x,t)\n$$\n整理各项以分离出关于 $\\tilde{u}$ 的方程，我们得到：\n$$\n\\tilde{u}_t - \\tilde{u}_{xx} = f(x,t) - \\ell_t(x,t) + \\ell_{xx}(x,t)\n$$\n这是齐次分量 $\\tilde{u}$ 的偏微分方程的强形式。右侧的项是修正后的强迫项，其中 $-\\ell_t$ 和 $\\ell_{xx}$ 是来自提升函数的贡献。\n\n为了推导弱形式，我们将此 PDE 乘以一个测试函数 $v(x)$，该函数属于适用于齐次狄利克雷边界条件的函数空间，通常为 $v \\in H_0^1(0,1)$，这意味着 $v$ 是平方可积的，其导数也是平方可积的，并且 $v(0)=v(1)=0$。然后我们在空间域 $[0,1]$ 上积分：\n$$\n\\int_0^1 (\\tilde{u}_t - \\tilde{u}_{xx}) v \\, dx = \\int_0^1 (f - \\ell_t + \\ell_{xx}) v \\, dx\n$$\n利用积分的线性性质，我们分离左边的项：\n$$\n\\int_0^1 \\tilde{u}_t v \\, dx - \\int_0^1 \\tilde{u}_{xx} v \\, dx = \\int_0^1 (f - \\ell_t + \\ell_{xx}) v \\, dx\n$$\n我们对左边的第二项应用分部积分：\n$$\n- \\int_0^1 \\tilde{u}_{xx} v \\, dx = - \\left[ \\tilde{u}_x v \\right]_0^1 + \\int_0^1 \\tilde{u}_x v_x \\, dx\n$$\n由于测试函数 $v$ 满足齐次狄利克雷边界条件, $v(0)=v(1)=0$，边界项 $\\left[ \\tilde{u}_x v \\right]_0^1$ 为零。因此弱形式是找到 $\\tilde{u}(\\cdot, t) \\in H_0^1(0,1)$，使得对于所有 $v \\in H_0^1(0,1)$：\n$$\n\\int_0^1 \\tilde{u}_t v \\, dx + \\int_0^1 \\tilde{u}_x v_x \\, dx = \\int_0^1 (f - \\ell_t + \\ell_{xx}) v \\, dx\n$$\n\n**2) 降阶模型 (ROM) 的推导**\n\n降阶模型是通过将弱形式伽辽金投影到一个由 POD 模态 $\\{\\varphi_i(x)\\}_{i=1}^r$ 张成的低维子空间上得到的。这些模态满足齐次狄利克雷边界条件，因此它们构成了 $\\tilde{u}$ 所在空间的有效基。我们寻求以下形式的近似解：\n$$\n\\tilde{u}(x,t) \\approx \\sum_{j=1}^r a_j(t)\\,\\varphi_j(x)\n$$\n其中 $a_j(t)$ 是随时间变化的模态系数。我们将此展开式代入第一部分推导出的弱形式。对于伽辽金方法，我们选择基函数本身作为测试函数，即对于 $i=1, \\dots, r$，$v(x) = \\varphi_i(x)$。\n\n将展开式和 $v=\\varphi_i$ 代入弱形式，对每个 $i \\in \\{1, \\dots, r\\}$ 得到：\n$$\n\\int_0^1 \\frac{\\partial}{\\partial t}\\left(\\sum_{j=1}^r a_j(t)\\varphi_j(x)\\right) \\varphi_i(x) \\, dx + \\int_0^1 \\frac{\\partial}{\\partial x}\\left(\\sum_{j=1}^r a_j(t)\\varphi_j(x)\\right) \\frac{d\\varphi_i}{dx}(x) \\, dx = \\int_0^1 (f - \\ell_t + \\ell_{xx}) \\varphi_i(x) \\, dx\n$$\n利用微分和积分的线性性质，我们得到：\n$$\n\\sum_{j=1}^r \\dot{a}_j(t) \\int_0^1 \\varphi_j(x) \\varphi_i(x) \\, dx + \\sum_{j=1}^r a_j(t) \\int_0^1 \\frac{d\\varphi_j}{dx}(x) \\frac{d\\varphi_i}{dx}(x) \\, dx = \\int_0^1 (f - \\ell_t + \\ell_{xx}) \\varphi_i(x) \\, dx\n$$\n我们定义 $L^2(0,1)$ 内积为 $(w,z) = \\int_0^1 w(x)z(x) \\, dx$。该方程组可以写为：\n$$\n\\sum_{j=1}^r (\\varphi_j, \\varphi_i) \\dot{a}_j(t) + \\sum_{j=1}^r (\\varphi_j', \\varphi_i') a_j(t) = (f - \\ell_t + \\ell_{xx}, \\varphi_i)\n$$\n这是一个关于系数 $\\mathbf{a}(t) = [a_1(t), \\dots, a_r(t)]^T$ 的 $r$ 个常微分方程 (ODE) 组成的方程组。我们可以将此方程组写成矩阵形式 $\\mathbf{M}\\,\\dot{\\mathbf{a}}(t) + \\mathbf{S}\\,\\mathbf{a}(t) = \\mathbf{F}(t)$，其中矩阵和向量的元素为：\n-   **降阶质量矩阵 $\\mathbf{M}$**：$M_{ij} = (\\varphi_i, \\varphi_j)$。注意，这里的下标有时会互换，但由于内积是对称的，$M_{ij}=M_{ji}$。\n-   **降阶刚度矩阵 $\\mathbf{S}$**：$S_{ij} = (\\varphi_i', \\varphi_j')$。\n-   **降阶强迫向量 $\\mathbf{F}(t)$**：$F_i(t) = (f - \\ell_t + \\ell_{xx}, \\varphi_i)$。\n\n如果 POD 基 $\\{\\varphi_i\\}$ 被选择为关于 $L^2$ 内积是正交归一的，那么 $(\\varphi_i, \\varphi_j) = \\delta_{ij}$ (克罗内克δ)。在这种情况下，质量矩阵 $\\mathbf{M}$ 成为单位矩阵 $\\mathbf{I}$，从而将方程组简化为 $\\dot{\\mathbf{a}}(t) + \\mathbf{S}\\,\\mathbf{a}(t) = \\mathbf{F}(t)$。\n\n**3) 从 DG 模拟计算快照**\n\n在间断伽辽金 (DG) 模拟中，全阶解 $u_h(x,t)$ 在一组离散时间点 $\\{t_k\\}_{k=1}^{N_s}$ 上计算，从而产生一组快照 $\\{u_h(x, t_k)\\}$。非齐次边界条件 $u(0,t_k)=g_0(t_k)$ 和 $u(1,t_k)=g_1(t_k)$ 通常通过在区域边界上的数值通量被弱施加。\n\n为了生成齐次分量 $\\tilde{u}$ 的快照，我们执行以下步骤：\n1.  对于每个快照时间 $t_k$，在用于 DG 模拟的相同离散网格上构造相应的提升函数 $\\ell(x, t_k)$。这是一个对已知解析函数 $\\ell(x,t)$ 的简单求值。\n2.  从全阶 DG 解快照中减去提升函数，以获得齐次分量的快照：$\\tilde{u}_h(x, t_k) = u_h(x, t_k) - \\ell(x, t_k)$。根据构造，$\\tilde{u}_h(x, t_k)$ 将在与 $u_h$ 满足非齐次边界条件相同的弱意义下满足齐次边界条件。集合 $\\{\\tilde{u}_h(x, t_k)\\}_{k=1}^{N_s}$ 构成了快照集合。\n3.  为了构造 POD 模态，我们使用快照法。目标是找到一个基，该基在快照中捕获的能量（以适当的范数衡量）方面是最优的。问题指定了一个与离散 DG 质量矩阵 $\\mathbf{M}_{DG}$ 一致的内积。设 $\\tilde{\\mathbf{u}}_k$ 是表示快照 $\\tilde{u}_h(x, t_k)$ 的自由度向量。两个快照 $\\tilde{u}_h(\\cdot, t_k)$ 和 $\\tilde{u}_h(\\cdot, t_l)$ 之间的离散内积由 $\\tilde{\\mathbf{u}}_k^T \\mathbf{M}_{DG} \\tilde{\\mathbf{u}}_l$ 给出。\n4.  快照相关矩阵（或格拉姆矩阵）$\\mathbf{C}$ 是一个 $N_s \\times N_s$ 矩阵，其元素是快照的内积：$C_{kl} = (\\tilde{u}_h(\\cdot, t_k), \\tilde{u}_h(\\cdot, t_l))_{\\mathrm{DG}} = \\tilde{\\mathbf{u}}_k^T \\mathbf{M}_{DG} \\tilde{\\mathbf{u}}_l$。\n5.  求解相关矩阵的特征值问题：$\\mathbf{C} \\mathbf{v}_i = \\lambda_i \\mathbf{v}_i$，其中 $\\lambda_i$ 是特征值，$\\mathbf{v}_i$ 是对应的特征向量。\n6.  第 $i$ 个 POD 模态 $\\varphi_i(x)$ 被构造为快照的线性组合，其系数由特征向量 $\\mathbf{v}_i$ 的分量给出：\n$$\n\\varphi_i(x) = \\frac{1}{\\sqrt{\\lambda_i}} \\sum_{k=1}^{N_s} (\\mathbf{v}_i)_k \\, \\tilde{u}_h(x, t_k)\n$$\n由于每个快照 $\\tilde{u}_h$ 都满足齐次边界条件，它们的任何线性组合，包括 POD 模态 $\\varphi_i$，也将满足这些条件。此外，该过程保证了所得到的模态 $\\{\\varphi_i\\}$ 在 DG 诱导的内积下是正交归一的：$(\\varphi_i, \\varphi_j)_{\\mathrm{DG}} = \\delta_{ij}$。\n\n**4) 降阶强迫项分量的具体计算**\n\n我们被给予了以下具体数据：\n-   边界数据：$g_0(t) = \\sin(t)$，$g_1(t) = 0$。\n-   源项：$f(x,t) = x$。\n-   提升函数：$\\ell(x,t) = g_0(t)\\,(1-x) + g_1(t)\\,x = \\sin(t)(1-x)$。\n-   降阶基函数：$\\varphi_1(x) = \\sqrt{2}\\,\\sin(\\pi x)$，$\\varphi_2(x) = \\sqrt{2}\\,\\sin(2\\pi x)$。\n\n我们需要计算降阶强迫向量的第一个分量 $F_1(t)$，并在 $t = \\ln(2)$ 处求值。\n根据第 2 部分，公式为 $F_1(t) = (f - \\ell_t + \\ell_{xx}, \\varphi_1)$。\n\n首先，我们计算提升函数 $\\ell(x,t)$ 的导数：\n$$\n\\ell_t(x,t) = \\frac{\\partial}{\\partial t} [\\sin(t)(1-x)] = (1-x)\\cos(t)\n$$\n$$\n\\ell_x(x,t) = \\frac{\\partial}{\\partial x} [\\sin(t)(1-x)] = -\\sin(t)\n$$\n$$\n\\ell_{xx}(x,t) = \\frac{\\partial}{\\partial x} [-\\sin(t)] = 0\n$$\n修正后的强迫项是：\n$$\nf(x,t) - \\ell_t(x,t) + \\ell_{xx}(x,t) = x - (1-x)\\cos(t)\n$$\n现在我们计算与 $\\varphi_1(x)$ 的内积：\n$$\nF_1(t) = \\int_0^1 \\left( x - (1-x)\\cos(t) \\right) \\sqrt{2}\\,\\sin(\\pi x) \\, dx\n$$\n我们可以拆分这个积分：\n$$\nF_1(t) = \\sqrt{2} \\int_0^1 x \\sin(\\pi x) \\, dx - \\sqrt{2} \\cos(t) \\int_0^1 (1-x) \\sin(\\pi x) \\, dx\n$$\n让我们计算这两个定积分。对于第一个积分，我们使用分部积分法，令 $u=x$ 和 $dv=\\sin(\\pi x)dx$：\n$$\n\\int_0^1 x \\sin(\\pi x) \\, dx = \\left[ -x \\frac{\\cos(\\pi x)}{\\pi} \\right]_0^1 - \\int_0^1 \\left(-\\frac{\\cos(\\pi x)}{\\pi}\\right) dx = -\\frac{1}{\\pi}\\cos(\\pi) + \\frac{1}{\\pi} \\left[ \\frac{\\sin(\\pi x)}{\\pi} \\right]_0^1 = \\frac{1}{\\pi} + 0 = \\frac{1}{\\pi}\n$$\n对于第二个积分：\n$$\n\\int_0^1 (1-x) \\sin(\\pi x) \\, dx = \\int_0^1 \\sin(\\pi x) \\, dx - \\int_0^1 x \\sin(\\pi x) \\, dx\n$$\n第一部分是 $\\int_0^1 \\sin(\\pi x) dx = \\left[-\\frac{\\cos(\\pi x)}{\\pi}\\right]_0^1 = -\\frac{1}{\\pi}(\\cos(\\pi) - \\cos(0)) = -\\frac{1}{\\pi}(-1 - 1) = \\frac{2}{\\pi}$。\n我们已经求出第二部分是 $\\frac{1}{\\pi}$。 所以，第二个积分是 $\\frac{2}{\\pi} - \\frac{1}{\\pi} = \\frac{1}{\\pi}$。\n\n将这些结果代回 $F_1(t)$ 的表达式中：\n$$\nF_1(t) = \\sqrt{2} \\left( \\frac{1}{\\pi} \\right) - \\sqrt{2} \\cos(t) \\left( \\frac{1}{\\pi} \\right) = \\frac{\\sqrt{2}}{\\pi} (1 - \\cos(t))\n$$\n最后，我们在 $t=\\ln(2)$ 处计算 $F_1(t)$：\n$$\nF_1(\\ln(2)) = \\frac{\\sqrt{2}}{\\pi} (1 - \\cos(\\ln(2)))\n$$\n这就是所要求的闭式解析表达式。",
            "answer": "$$\n\\boxed{\\frac{\\sqrt{2}}{\\pi} (1 - \\cos(\\ln(2)))}\n$$"
        }
    ]
}