{
    "hands_on_practices": [
        {
            "introduction": "理解降阶基方法计算效率的来源是掌握该方法的关键第一步。本实践旨在阐明实现离线/在线策略的核心机制——仿射参数分解。您将通过一个具体的间断 Galerkin (DG) 离散化问题，推导如何将依赖于参数的系统矩阵分解为一系列与参数无关的矩阵和仅与参数相关的标量函数 。这一过程揭示了为何我们可以在“离线”阶段完成大部分繁重的计算，而在“在线”阶段能以极高的效率求解新参数下的问题。",
            "id": "3411778",
            "problem": "考虑在有界Lipschitz域 $\\Omega \\subset \\mathbb{R}^{d}$（其中 $d \\in \\{1,2,3\\}$）上提出的线性、矫顽、参数化扩散模型，\n$$\n- \\nabla \\cdot \\big(k(x;\\mu) \\nabla u(x;\\mu)\\big) = f(x) \\quad \\text{in } \\Omega,\n$$\n该模型在 $\\partial \\Omega$ 上具有齐次Dirichlet边界条件。假设 $\\Omega$ 上有一个形正网格 $\\mathcal{T}_{h}$，并采用对称内罚不连续Galerkin (DG) 离散化，单元上使用p次多项式，内部面上的跳跃和平均采用标准定义。系数 $k(x;\\mu)$ 允许仿射参数分解\n$$\nk(x;\\mu) = \\sum_{q=1}^{Q_{a}} \\theta_{q}^{a}(\\mu)\\, k_{q}(x),\n$$\n其中标量系数函数 $\\theta_{q}^{a}(\\mu)$ 仅依赖于参数 $\\mu$，而空间系数快照 $k_{q}(x)$ 与参数无关。\n\n令 $V_{h}$ 表示DG有限元空间，令 $a(\\cdot,\\cdot;\\mu)$ 是与对称内罚DG方法相关的双线性形式（罚参数 $\\sigma>0$ 被选择得足够大以保证矫顽性），由微分算子 $-\\nabla \\cdot (k(x;\\mu) \\nabla \\cdot)$ 构造。假设一个降阶基 $V_{N} = \\operatorname{span}\\{\\zeta_{1},\\dots,\\zeta_{N}\\} \\subset V_{h}$ 已经通过贪心算法在参数空间的训练集上离线生成，其基向量 $\\zeta_{i} \\in V_{h}$ 在DG空间中表示。\n\n仅从对称内罚DG双线性形式 $a(\\cdot,\\cdot;\\mu)$ 的定义属性和 $k(x;\\mu)$ 的仿射分解出发，推导与参数无关的降阶矩阵 $A_{q}^{N} \\in \\mathbb{R}^{N \\times N}$ 的显式离线表达式，其元素仅依赖于降阶基函数和空间系数分量 $k_{q}(x)$。并说明如何根据这些离线矩阵和标量 $\\theta_{q}^{a}(\\mu)$ 在线组装降阶刚度矩阵 $A^{N}(\\mu) \\in \\mathbb{R}^{N \\times N}$，而无需在线访问高维DG空间。为具体起见，使用标准的对称内罚DG双线性形式，其包含内部面贡献和针对齐次Dirichlet数据的Nitsche型边界项：\n$$\na(u,v;\\mu) \n= \\sum_{K \\in \\mathcal{T}_{h}} \\int_{K} k(x;\\mu)\\, \\nabla u \\cdot \\nabla v \\,\\mathrm{d}x\n- \\sum_{F \\in \\mathcal{F}_{i}} \\int_{F} \\big\\{ k(x;\\mu)\\nabla u \\cdot n_{F} \\big\\} \\,[v] \\,\\mathrm{d}s\n- \\sum_{F \\in \\mathcal{F}_{i}} \\int_{F} \\big\\{ k(x;\\mu)\\nabla v \\cdot n_{F} \\big\\} \\,[u] \\,\\mathrm{d}s\n+ \\sum_{F \\in \\mathcal{F}_{i}} \\int_{F} \\frac{\\sigma\\, k(x;\\mu)}{h_{F}}\\, [u]\\, [v] \\,\\mathrm{d}s\n$$\n$$\n- \\sum_{F \\in \\mathcal{F}_{b}} \\int_{F} k(x;\\mu)\\, \\nabla u \\cdot n \\, v \\,\\mathrm{d}s\n- \\sum_{F \\in \\mathcal{F}_{b}} \\int_{F} k(x;\\mu)\\, \\nabla v \\cdot n \\, u \\,\\mathrm{d}s\n+ \\sum_{F \\in \\mathcal{F}_{b}} \\int_{F} \\frac{\\sigma\\, k(x;\\mu)}{h_{F}}\\, u\\, v \\,\\mathrm{d}s,\n$$\n其中 $\\mathcal{F}_{i}$ 表示内部面集合，$\\mathcal{F}_{b}$ 表示边界面集合，$n_{F}$ 是面 $F$ 上的固定单位法向量，$n$ 是 $\\partial \\Omega$ 上的外单位法向量，$h_{F}$ 是与面相关的网格尺寸，$[\\,\\cdot\\,]$ 表示面上的跳跃，$\\{\\,\\cdot\\,\\}$ 表示面上的平均。\n\n你的最终答案必须是关于在线降阶刚度矩阵 $A^{N}(\\mu)$ 的单一闭式解析表达式，用离线矩阵和与参数相关的标量表示。不需要进行数值计算。以符号方式表达最终的矩阵表达式；不需要四舍五入，也不涉及物理单位。",
            "solution": "问题陈述经核实具有科学依据、是适定且客观的。这是偏微分方程降阶基方法领域的一个标准问题。所有必要信息均已提供，目标明确。\n\n目标是推导与参数化扩散问题的对称内罚不连续Galerkin (SIPG) 离散化相关的降阶刚度矩阵的离线/在线分解。\n\n对于给定的参数 $\\mu$，高保真问题旨在寻找一个解 $u(x;\\mu) \\in V_h$。基于所提供的SIPG双线性形式 $a(\\cdot,\\cdot;\\mu)$ 的相应弱形式是：寻找 $u \\in V_h$ 使得\n$$\na(u,v;\\mu) = L(v) \\quad \\forall v \\in V_h,\n$$\n其中 $L(v) = \\int_{\\Omega} f(x)v(x)\\,\\mathrm{d}x$。\n\n降阶基方法在低维空间 $V_N = \\operatorname{span}\\{\\zeta_{1},\\dots,\\zeta_{N}\\} \\subset V_h$ 中构造一个近似解 $u_N(x;\\mu)$。降阶解表示为预先计算的基函数 $\\zeta_j$ 的线性组合：\n$$\nu_N(x;\\mu) = \\sum_{j=1}^{N} u_j^N(\\mu) \\zeta_j(x),\n$$\n其中 $u_j^N(\\mu)$ 是未知标量系数。\n\n应用Galerkin投影原理，我们要求弱形式的残差与降阶空间 $V_N$ 正交。这等价于对所有基函数 $v_N = \\zeta_i(x)$（其中 $i=1,\\dots,N$）强制执行弱形式：\n$$\na(u_N, \\zeta_i; \\mu) = L(\\zeta_i) \\quad \\text{for } i=1,\\dots,N.\n$$\n代入 $u_N(x;\\mu)$ 的展开式，并利用 $a(\\cdot,\\cdot;\\mu)$ 在其第一个参数上的线性性质，我们得到：\n$$\n\\sum_{j=1}^{N} u_j^N(\\mu) \\, a(\\zeta_j, \\zeta_i; \\mu) = L(\\zeta_i) \\quad \\text{for } i=1,\\dots,N.\n$$\n这是一个大小为 $N \\times N$ 的稠密线性方程组，可以写成矩阵形式：\n$$\nA^N(\\mu) \\mathbf{u}^N(\\mu) = F^N,\n$$\n其中 $\\mathbf{u}^N(\\mu) = [u_1^N(\\mu), \\dots, u_N^N(\\mu)]^T$ 是未知系数向量，$F^N$ 是降阶载荷向量，其元素为 $(F^N)_i = L(\\zeta_i)$，而 $A^N(\\mu)$ 是降阶刚度矩阵。降阶刚度矩阵的元素由下式给出：\n$$\n(A^N(\\mu))_{ij} = a(\\zeta_j, \\zeta_i; \\mu).\n$$\n离线/在线分解的核心在于利用双线性形式 $a(\\cdot,\\cdot;\\mu)$ 和扩散系数 $k(x;\\mu)$ 的特定结构。SIPG双线性形式 $a(\\cdot,\\cdot;\\mu)$ 如下所示：\n$$\na(u,v;\\mu) \n= \\sum_{K \\in \\mathcal{T}_{h}} \\int_{K} k(x;\\mu)\\, \\nabla u \\cdot \\nabla v \\,\\mathrm{d}x\n- \\sum_{F \\in \\mathcal{F}_{i}} \\int_{F} \\big\\{ k(x;\\mu)\\nabla u \\cdot n_{F} \\big\\} \\,[v] \\,\\mathrm{d}s\n- \\sum_{F \\in \\mathcal{F}_{i}} \\int_{F} \\big\\{ k(x;\\mu)\\nabla v \\cdot n_{F} \\big\\} \\,[u] \\,\\mathrm{d}s\n+ \\sum_{F \\in \\mathcal{F}_{i}} \\int_{F} \\frac{\\sigma\\, k(x;\\mu)}{h_{F}}\\, [u]\\, [v] \\,\\mathrm{d}s\n$$\n$$\n- \\sum_{F \\in \\mathcal{F}_{b}} \\int_{F} k(x;\\mu)\\, \\nabla u \\cdot n \\, v \\,\\mathrm{d}s\n- \\sum_{F \\in \\mathcal{F}_{b}} \\int_{F} k(x;\\mu)\\, \\nabla v \\cdot n \\, u \\,\\mathrm{d}s\n+ \\sum_{F \\in \\mathcal{F}_{b}} \\int_{F} \\frac{\\sigma\\, k(x;\\mu)}{h_{F}}\\, u\\, v \\,\\mathrm{d}s.\n$$\n通过观察，此形式中的每一项都关于扩散系数函数 $k(x;\\mu)$ 是线性的。这意味着如果 $k(x;\\mu)$ 可以表示为函数的线性组合，则双线性形式也将遵循相同的线性组合。让我们将双线性形式对系数的依赖性表示为 $a[k](u,v)$。那么，对于任意标量常数 $c_1, c_2$ 和函数 $k_1, k_2$，我们有 $a[c_1 k_1 + c_2 k_2](u,v) = c_1 a[k_1](u,v) + c_2 a[k_2](u,v)$。\n\n问题陈述指出，系数 $k(x;\\mu)$ 允许仿射参数分解：\n$$\nk(x;\\mu) = \\sum_{q=1}^{Q_{a}} \\theta_{q}^{a}(\\mu)\\, k_{q}(x).\n$$\n在这里，函数 $\\theta_{q}^{a}(\\mu)$ 仅依赖于参数 $\\mu$，而函数 $k_{q}(x)$ 仅依赖于空间变量 $x$。\n\n现在我们可以将此分解代入降阶刚度矩阵元素的表达式中。利用双线性形式相对于系数函数的线性性质，我们得到：\n$$\n(A^N(\\mu))_{ij} = a(\\zeta_j, \\zeta_i; \\mu) = a[k(\\cdot;\\mu)](\\zeta_j, \\zeta_i) = a\\left[\\sum_{q=1}^{Q_{a}} \\theta_{q}^{a}(\\mu) k_{q}(\\cdot)\\right](\\zeta_j, \\zeta_i)\n$$\n$$\n(A^N(\\mu))_{ij} = \\sum_{q=1}^{Q_{a}} \\theta_{q}^{a}(\\mu) \\, a[k_{q}(\\cdot)](\\zeta_j, \\zeta_i).\n$$\n这个表达式将依赖于参数的部分与不依赖于参数的部分分离开来。项 $a[k_{q}(\\cdot)](\\zeta_j, \\zeta_i)$ 仅依赖于固定的空间函数 $k_q(x)$ 和固定的降阶基函数 $\\zeta_j(x)$ 和 $\\zeta_i(x)$。它们不依赖于参数 $\\mu$。\n\n这使得离线/在线计算策略成为可能。\n\n**离线阶段：** 我们预先计算并存储 $q=1, \\dots, Q_a$ 的 $Q_a$ 个与参数无关的矩阵 $A_q^N \\in \\mathbb{R}^{N \\times N}$。这些矩阵的元素定义为：\n$$\n(A_q^N)_{ij} = a[k_q(\\cdot)](\\zeta_j, \\zeta_i).\n$$\n具体来说，这是用系数函数 $k_q(x)$ 对基函数对 $(\\zeta_j, \\zeta_i)$ 求值的SIPG双线性形式。这是一个计算密集型步骤，因为它涉及在所有基函数对和每个系数分量 $k_q(x)$ 的高维有限元网格上进行积分。然而，这个步骤只需执行一次。\n\n**在线阶段：** 对于任何新的参数值 $\\mu$，可以非常迅速地组装降阶刚度矩阵 $A^N(\\mu)$。首先，我们计算 $Q_a$ 个标量函数 $\\theta_q^a(\\mu)$。然后，我们将 $A^N(\\mu)$ 构造为预先计算的离线矩阵的线性组合：\n$$\n(A^N(\\mu))_{ij} = \\sum_{q=1}^{Q_{a}} \\theta_{q}^{a}(\\mu) (A_q^N)_{ij}.\n$$\n这是关于矩阵元素的陈述。在矩阵表示法中，这变成了一个简单而快速的矩阵求和：\n$$\nA^N(\\mu) = \\sum_{q=1}^{Q_{a}} \\theta_{q}^{a}(\\mu) A_q^N.\n$$\n这个在线组装过程仅需要 $Q_a-1$ 次 $N \\times N$ 矩阵的加法和 $Q_a$ 次标量-矩阵乘法。由于 $N$ 很小（通常 $N \\ll \\dim(V_h)$），这个步骤极其高效，并且不需要任何对高维DG空间 $V_h$ 的访问，从而实现了期望的计算加速。\n\n最终的表达式展示了对于任何参数值 $\\mu$ 的降阶刚度矩阵是如何由预先计算的、与参数无关的矩阵 $A_q^N$ 和与参数相关的标量函数 $\\theta_q^a(\\mu)$ 在线构建的。",
            "answer": "$$\n\\boxed{A^{N}(\\mu) = \\sum_{q=1}^{Q_{a}} \\theta_{q}^{a}(\\mu)\\, A_{q}^{N}}\n$$"
        },
        {
            "introduction": "在掌握了离线/在线分解的理论后，下一个关键是理解贪婪算法如何逐步构建降阶基。本实践将引导您从理论走向代码，为一个典型的间断 Galerkin 能量内积实现基向量的正交化过程 。您将需要推导并组装非标准的 DG 内积矩阵，并实现一个修正的 Gram-Schmidt 算法，以确保新加入的快照与现有基底在该能量范数下正交。这个练习将贪婪算法中抽象的基富集步骤具体化，并突出了其核心的数值线性代数操作。",
            "id": "3411758",
            "problem": "考虑在区间 $[0,1]$ 上的一个一维对称内罚伽辽金 (Symmetric Interior Penalty Galerkin, SIPG) 离散化的标量模型问题，该问题使用包含 $N_e$ 个单元的均匀网格，单元尺寸为 $h = 1/N_e$。在每个单元上，使用分片线性间断伽辽金 (Discontinuous Galerkin, DG) 基函数，每个单元有两个局部自由度，对应于单元左右端点处的值。令间断伽辽金 (DG) 能量内积由以下双线性形式定义：\n$$\n\\langle u, v \\rangle_E \\;=\\; \\sum_{K} \\int_{K} u'(x)\\,v'(x)\\,dx \\;+\\; \\sum_{F} \\frac{\\alpha}{h} \\,[u]_F\\,[v]_F,\n$$\n其中 $u'(x)$ 表示 $u$ 在每个单元 $K$ 上的导数，$\\alpha > 0$ 是内部罚参数，$[u]_F$ 是 $u$ 穿过一个内部面 $F$ 的跳跃。在边界面上，将跳跃解释为函数的迹，从而在每个边界面上增加一个罚项 $\\frac{\\alpha}{h}\\,u^2$。\n\n1. 通过将参考单元 $[-1,1]$ 映射到物理单元 $K$ 并使用恒等式 $u'(x) = \\frac{2}{h}\\, \\frac{du}{d\\xi}$（其中 $\\xi \\in [-1,1]$ 是参考坐标），推导导数项内积的矩阵表示的单元贡献。证明对于参考单元上的分片线性基函数，$\\int_{K} u'(x)\\,v'(x)\\,dx$ 的单元矩阵贡献具有以下形式：\n$$\n\\frac{1}{h}\\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}.\n$$\n\n2. 表示每个内部面对罚项矩阵表示的贡献。对于单元 $e$ 和单元 $e+1$ 之间的一个面，令 $u_{e,R}$ 表示单元 $e$ 的右端点自由度，$u_{e+1,L}$ 表示单元 $e+1$ 的左端点自由度。使用跳跃的定义 $[u]_F = u_{e,R} - u_{e+1,L}$ 来证明作用于自由度对 $\\left(u_{e,R}, u_{e+1,L}\\right)$ 的对称 $2 \\times 2$ 矩阵模板为：\n$$\n\\frac{\\alpha}{h}\\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}.\n$$\n对于边界面，将标量罚项 $\\frac{\\alpha}{h}$ 加到与边界自由度对应的对角线元素上。\n\n3. 组装表示 DG 能量内积 $\\langle u, v \\rangle_E = u^\\top G v$ 的完整对称正定矩阵 $G \\in \\mathbb{R}^{(2N_e)\\times(2N_e)}$。假设连续函数 $f(x)$ 通过在每个单元的端点处采样来映射为 DG 快照 $s \\in \\mathbb{R}^{2N_e}$：单元 $e$ 的左自由度存储 $f(e/N_e)$，右自由度存储 $f((e+1)/N_e)$。\n\n4. 在一个受正交性约束的、采用贪婪选择的降阶基 (Reduced Basis, RB) 方法中，当前降阶空间由一个矩阵 $V \\in \\mathbb{R}^{(2N_e)\\times r}$ 表示，其列向量关于 $\\langle \\cdot, \\cdot \\rangle_E$ 已经是标准正交的，即 $V^\\top G V = I_r$。给定一个新的快照 $s \\in \\mathbb{R}^{2N_e}$，通过以下步骤将 $s$ 相对于当前基 $V$ 就 $\\langle \\cdot, \\cdot \\rangle_E$ 进行标准正交化：\n- 计算投影系数 $c = V^\\top G s$，\n- 构造残差 $r = s - V c$，\n- 计算 DG 能量范数 $\\|r\\|_E = \\sqrt{r^\\top G r}$，\n- 基于一个容差 $\\tau > 0$ 决定是否接受：如果 $\\|r\\|_E \\le \\tau$，则拒绝该快照；否则，定义 $v_{\\text{new}} = r/\\|r\\|_E$ 并验证 $V^\\top G v_{\\text{new}} \\approx 0$。\n\n实现一个程序，执行步骤1-4，并为每个测试用例输出三元组 $[\\|r\\|_E, \\max\\left(|V^\\top G v_{\\text{new}}|\\right), \\text{accepted\\_flag}]$，其中 $\\text{accepted\\_flag}$ 是一个整数，如果接受则为 $1$，如果拒绝则为 $0$。如果快照被拒绝，则将第二个条目 $\\max\\left(|V^\\top G v_{\\text{new}}|\\right)$ 设置为 $0.0$。\n\n使用以下测试套件（每个测试用例指定 $(N_e, \\alpha, \\tau, \\text{basis-snapshots}, \\text{new-snapshot})$）：\n- 测试用例A（一般情况）：$N_e = 4$，$\\alpha = 10$，$\\tau = 10^{-10}$，基快照来自 $f_1(x) = \\sin(\\pi x)$ 和 $f_2(x) = \\cos(2\\pi x)$，新快照来自 $f_3(x) = e^{-x}$。\n- 测试用例B（边界尺寸情况，单个单元）：$N_e = 1$，$\\alpha = 10$，$\\tau = 10^{-10}$，空基 $V$（无列向量），新快照明确给定为向量 $s = [1.0, -0.5]$。\n- 测试用例C（近共线性边界情况）：$N_e = 4$，$\\alpha = 50$，$\\tau = 10^{-8}$，基快照来自 $f_1(x) = \\sin(\\pi x)$ 和 $f_2(x) = \\cos(2\\pi x)$，新快照为 $s = v_1 + \\varepsilon w$，其中 $v_1$ 是已标准正交化的基 $V$ 的第一列，$w \\in \\mathbb{R}^{2N_e}$ 是一个确定性向量，其元素交替为 $1,-1,1,-1,\\dots$，且 $\\varepsilon = 10^{-12}$。\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例对外部列表贡献一个子列表 $[\\|r\\|_E,\\max(|V^\\top G v_{\\text{new}}|),\\text{accepted\\_flag}]$。例如，输出格式必须类似于 $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]$，且仅包含数值和整数。",
            "solution": "该问题陈述是适定的，具有科学依据，并提供了推导和实现解决方案所需的所有信息。它包括四个部分：对称内罚伽辽金 (SIPG) 离散化的单元和面矩阵的推导，代表 DG 能量内积的全局矩阵的组装，以及用于降阶基生成的贪婪算法单步实现的实现。我们将系统地处理每个部分。\n\n### 第1部分：单元导数矩阵的推导\n我们需要推导项 $\\int_{K} u'(x)\\,v'(x)\\,dx$ 的单元矩阵贡献。我们考虑一个参考单元 $\\xi \\in [-1, 1]$，其线性基函数为 $\\hat{\\phi}_L(\\xi) = \\frac{1-\\xi}{2}$ 和 $\\hat{\\phi}_R(\\xi) = \\frac{1+\\xi}{2}$。它们的导数是 $\\frac{d\\hat{\\phi}_L}{d\\xi} = -1/2$ 和 $\\frac{d\\hat{\\phi}_R}{d\\xi} = 1/2$。\n\n一个长度为 $h$ 的物理单元 $K$ 是从参考单元映射而来的。问题给出了物理坐标和参考坐标中导数之间的关系：$u'(x) = \\frac{2}{h} \\frac{du}{d\\xi}$。微分长度元素也变换为 $dx = \\frac{h}{2} d\\xi$。\n\n$2 \\times 2$ 单元矩阵 $A^K$ 的元素由 $A^K_{ij} = \\int_{K} \\phi_i'(x) \\phi_j'(x) dx$ 给出，其中 $\\phi_i$ 和 $\\phi_j$ 是对应于左 (L) 和右 (R) 自由度的物理基函数。通过将积分变量更改为 $\\xi$，我们得到：\n$$\nA^K_{ij} = \\int_{-1}^{1} \\left(\\frac{2}{h} \\frac{d\\hat{\\phi}_i}{d\\xi}\\right) \\left(\\frac{2}{h} \\frac{d\\hat{\\phi}_j}{d\\xi}\\right) \\left(\\frac{h}{2} d\\xi\\right) = \\frac{2}{h} \\int_{-1}^{1} \\frac{d\\hat{\\phi}_i}{d\\xi} \\frac{d\\hat{\\phi}_j}{d\\xi} d\\xi.\n$$\n我们计算矩阵的四个元素：\n$A^K_{LL} = \\frac{2}{h} \\int_{-1}^{1} \\left(-\\frac{1}{2}\\right) \\left(-\\frac{1}{2}\\right) d\\xi = \\frac{2}{h} \\cdot \\frac{1}{4} \\int_{-1}^{1} d\\xi = \\frac{2}{h} \\cdot \\frac{1}{4} \\cdot 2 = \\frac{1}{h}$。\n$A^K_{RR} = \\frac{2}{h} \\int_{-1}^{1} \\left(\\frac{1}{2}\\right) \\left(\\frac{1}{2}\\right) d\\xi = \\frac{2}{h} \\cdot \\frac{1}{4} \\cdot 2 = \\frac{1}{h}$。\n$A^K_{LR} = A^K_{RL} = \\frac{2}{h} \\int_{-1}^{1} \\left(-\\frac{1}{2}\\right) \\left(\\frac{1}{2}\\right) d\\xi = \\frac{2}{h} \\cdot \\left(-\\frac{1}{4}\\right) \\cdot 2 = -\\frac{1}{h}$。\n\n组合这些元素，导数项的单元矩阵为：\n$$\nA^K = \\frac{1}{h}\\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix},\n$$\n这证实了问题中给出的形式。\n\n### 第2部分：罚项的贡献\nDG 能量内积中的罚项是 $\\sum_{F} \\frac{\\alpha}{h} [u]_F [v]_F$。\n对于位于单元 $e$ 和单元 $e+1$ 之间的内部面 $F$，跳跃定义为 $[u]_F = u_{e,R} - u_{e+1,L}$，其中 $u_{e,R}$ 是单元 $e$ 右端点的值，$u_{e+1,L}$ 是单元 $e+1$ 左端点的值。对双线性形式的贡献是 $\\frac{\\alpha}{h} (u_{e,R} - u_{e+1,L})(v_{e,R} - v_{e+1,L})$。\n这对应于自由度向量 $\\mathbf{u} = \\begin{pmatrix} u_{e,R}  u_{e+1,L} \\end{pmatrix}^\\top$ 上的一个二次型。对能量的贡献是 $\\frac{\\alpha}{h} ([u]_F)^2 = \\frac{\\alpha}{h} (u_{e,R} - u_{e+1,L})^2 = \\frac{\\alpha}{h} (u_{e,R}^2 - 2u_{e,R}u_{e+1,L} + u_{e+1,L}^2)$。这个二次型可以用矩阵形式表示为 $\\mathbf{u}^\\top M_F \\mathbf{u}$。产生这种形式的对称矩阵 $M_F$ 是：\n$$\nM_F = \\frac{\\alpha}{h}\\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}.\n$$\n这是作用于自由度对 $(u_{e,R}, u_{e+1,L})$ 的 $2 \\times 2$ 模板。\n\n对于边界面，跳跃被解释为函数的迹。在左边界 ($x=0$)，该面涉及自由度 $u_{0,L}$。罚项是 $\\frac{\\alpha}{h} u_{0,L}^2$。这将在全局矩阵中对应于 $u_{0,L}$ 自由度的对角线元素上增加一个标量值 $\\frac{\\alpha}{h}$。类似地，在右边界 ($x=1$)，罚项是 $\\frac{\\alpha}{h} u_{N_e-1,R}^2$，这将在 $u_{N_e-1,R}$ 自由度的对角线元素上增加 $\\frac{\\alpha}{h}$。\n\n### 第3部分：全局矩阵 $G$ 的组装\n全局矩阵 $G \\in \\mathbb{R}^{(2N_e) \\times (2N_e)}$ 是通过将所有单元和面的贡献相加来组装的。自由度按单元逐个排序：$(u_{0,L}, u_{0,R}, u_{1,L}, u_{1,R}, \\dots, u_{N_e-1,L}, u_{N_e-1,R})$。自由度 $u_{e,L}$ 的全局索引是 $2e$，而 $u_{e,R}$ 的全局索引是 $2e+1$。\n\n组装过程如下：\n1.  将 $G$ 初始化为一个大小为 $(2N_e) \\times (2N_e)$ 的零矩阵。\n2.  对于每个单元 $e = 0, \\dots, N_e-1$：\n    将单元导数矩阵 $A^K = \\frac{1}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$ 加到 $G$ 中对应于索引 $(2e, 2e+1)$ 的子矩阵上。\n3.  对于单元 $e$ 和 $e+1$ 之间的每个内部面 $f$（其中 $e = 0, \\dots, N_e-2$）：\n    将面罚分矩阵 $M_F = \\frac{\\alpha}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$ 加到 $G$ 中对应于索引 $(2e+1, 2e+2)$ 的子矩阵上。这些索引对应于自由度 $u_{e,R}$ 和 $u_{e+1,L}$。\n4.  添加边界罚分：\n    将 $\\frac{\\alpha}{h}$ 加到 $G[0,0]$ 以处理左边界。\n    将 $\\frac{\\alpha}{h}$ 加到 $G[2N_e-1, 2N_e-1]$ 以处理右边界。\n\n得到的矩阵 $G$ 是对称的，并且对于 $\\alpha > 0$，是正定的，因此定义了一个有效的内积 $\\langle u, v \\rangle_E = u^\\top G v$。\n\n对于连续函数 $f(x)$ 的快照 $s \\in \\mathbb{R}^{2N_e}$ 是通过在自由度的物理位置处对 $f(x)$ 进行采样生成的。对于单元 $e$，其左右节点位于 $x_e = eh$ 和 $x_{e+1} = (e+1)h$。因此，快照向量 $s$ 的分量为 $s_{2e} = f(eh)$ 和 $s_{2e+1} = f((e+1)h)$，对于 $e = 0, \\dots, N_e-1$。\n\n### 第4部分：降阶基正交化\n所描述的过程是关于由 $G$ 定义的能量内积的修正格拉姆-施密特标准正交化。给定一个现有的标准正交基 $V \\in \\mathbb{R}^{(2N_e) \\times r}$（满足 $V^\\top G V = I_r$）和一个新的快照 $s \\in \\mathbb{R}^{2N_e}$，我们将 $s$ 投影到由 $V$ 的列张成的空间上，并求出残差。\n1.  $s$ 到基 $V$ 上的投影是 $s_{\\text{proj}} = Vc$，其中 $c$ 是投影系数。这些系数通过确保残差 $r=s-s_{\\text{proj}}$ 与基 $G$-正交来计算：$V^\\top G (s-Vc)=0$。这得到 $V^\\top G s - (V^\\top G V)c = 0$。由于 $V^\\top G V = I_r$，我们有 $c = V^\\top G s$。\n2.  残差是 $r = s - Vc = s - V(V^\\top G s)$。\n3.  残差的 DG 能量范数是 $\\|r\\|_E = \\sqrt{\\langle r, r \\rangle_E} = \\sqrt{r^\\top G r}$。\n4.  如果快照的正交分量足够大，即 $\\|r\\|_E > \\tau$，则认为该快照足够线性无关，可以添加到基中。如果满足此条件，则快照被“接受”（标志=1），新的归一化基向量为 $v_{\\text{new}} = r / \\|r\\|_E$。否则，它被“拒绝”（标志=0）。\n5.  接受后，我们通过计算 $\\max(|V^\\top G v_{\\text{new}}|)$ 来验证新向量与旧基的正交性。由于有限精度算术，这将接近于零，但不会完全为零。如果快照被拒绝，则此值设置为 $0.0$。\n\n对于具有预定义“基快照”的测试用例，我们首先通过将此贪婪过程顺序应用于每个基快照（从空基开始）来构建基 $V$。然后，我们将该过程再应用于“新快照”与完全构建的基 $V$，以获得所需的三元组输出。",
            "answer": "```python\nimport numpy as np\n\ndef assemble_G(Ne, alpha):\n    \"\"\"\n    Assembles the global matrix G for the DG energy inner product.\n    \"\"\"\n    h = 1.0 / Ne\n    h_inv = 1.0 / h\n    alpha_h = alpha / h\n    dim = 2 * Ne\n    G = np.zeros((dim, dim))\n\n    # Part 1: Element derivative contributions\n    element_mat = h_inv * np.array([[1, -1], [-1, 1]])\n    for e in range(Ne):\n        G[2*e:2*e+2, 2*e:2*e+2] += element_mat\n\n    # Part 2: Face penalty contributions\n    face_mat = alpha_h * np.array([[1, -1], [-1, 1]])\n    # Interior faces\n    for e in range(Ne - 1):\n        G[2*e+1:2*e+3, 2*e+1:2*e+3] += face_mat\n    \n    # Boundary faces\n    G[0, 0] += alpha_h  # Left boundary at x=0\n    G[dim-1, dim-1] += alpha_h  # Right boundary at x=1\n    \n    return G\n\ndef generate_snapshot(func, Ne):\n    \"\"\"\n    Generates a DG snapshot vector from a continuous function.\n    \"\"\"\n    h = 1.0 / Ne\n    dim = 2 * Ne\n    s = np.zeros(dim)\n    for e in range(Ne):\n        x_left = e * h\n        x_right = (e + 1) * h\n        s[2*e] = func(x_left)\n        s[2*e+1] = func(x_right)\n    return s\n\ndef orthonormalization_step(s, V, G, tau):\n    \"\"\"\n    Performs one step of G-orthonormalization of snapshot s against basis V.\n    V is a numpy matrix with basis vectors as columns.\n    Returns: (residual_norm, max_ortho_error, accepted_flag, new_vector)\n    \"\"\"\n    r = s\n    if V.shape[1] > 0:\n        Gs = G @ s\n        c = V.T @ Gs\n        r = s - V @ c\n\n    Gr = G @ r\n    # Use max(0, ...) to handle potential small negative values from floating point errors\n    norm_r_sq = r.T @ Gr\n    norm_r = np.sqrt(max(0, norm_r_sq))\n\n    if norm_r = tau:\n        accepted_flag = 0\n        max_ortho_err = 0.0\n        v_new = None\n    else:\n        accepted_flag = 1\n        v_new = r / norm_r\n        if V.shape[1] > 0:\n            Gv_new = G @ v_new\n            d = V.T @ Gv_new\n            max_ortho_err = np.max(np.abs(d)) if d.size > 0 else 0.0\n        else:\n            max_ortho_err = 0.0\n\n    return norm_r, max_ortho_err, accepted_flag, v_new\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases.\n    \"\"\"\n    # Define test cases: (Ne, alpha, tau, basis_funcs, new_snapshot_spec)\n    test_cases = [\n        # Test Case A\n        (4, 10, 1e-10, \n         [lambda x: np.sin(np.pi * x), lambda x: np.cos(2 * np.pi * x)], \n         {'type': 'func', 'def': lambda x: np.exp(-x)}),\n        # Test Case B\n        (1, 10, 1e-10, \n         [], \n         {'type': 'vector', 'def': np.array([1.0, -0.5])}),\n        # Test Case C\n        (4, 50, 1e-8, \n         [lambda x: np.sin(np.pi * x), lambda x: np.cos(2 * np.pi * x)], \n         {'type': 'special', 'eps': 1e-12})\n    ]\n\n    all_results = []\n\n    for Ne, alpha, tau, basis_funcs, new_snapshot_spec in test_cases:\n        \n        G = assemble_G(Ne, alpha)\n        dim = 2 * Ne\n\n        # Build orthonormal basis V\n        V_list = []\n        V_matrix = np.empty((dim, 0))\n        for func in basis_funcs:\n            s_basis = generate_snapshot(func, Ne)\n            _, _, accepted, v_new = orthonormalization_step(s_basis, V_matrix, G, 1e-12) # Use small tol for basis build\n            if accepted:\n                V_list.append(v_new)\n                V_matrix = np.array(V_list).T\n        \n        # Prepare the new snapshot for processing\n        if new_snapshot_spec['type'] == 'func':\n            s_new = generate_snapshot(new_snapshot_spec['def'], Ne)\n        elif new_snapshot_spec['type'] == 'vector':\n            s_new = new_snapshot_spec['def']\n        elif new_snapshot_spec['type'] == 'special':\n            if not V_list:\n                s_new = np.zeros(dim)\n            else:\n                v1 = V_list[0]\n                eps = new_snapshot_spec['eps']\n                w = np.array([(-1)**i for i in range(dim)])\n                s_new = v1 + eps * w\n\n        # Process the new snapshot against the final basis V\n        norm_r, max_ortho_err, accepted_flag, _ = orthonormalization_step(s_new, V_matrix, G, tau)\n        \n        all_results.append([norm_r, max_ortho_err, accepted_flag])\n\n    # Format output\n    output_str = \"[\" + \",\".join([f\"[{r},{e},{f}]\" for r, e, f in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "最后，本综合实践将前面的概念融合成一个完整且更高级的自适应算法。您将不再依赖于一个固定的参数训练集，而是实现一个自适应贪婪算法，该算法能够根据后验误差估计的分布情况，智能地加密参数空间中的训练点 。这个练习不仅要求您实现一个完整的降阶基方法求解器，还展示了一种强大的策略，即通过将计算资源集中在误差最大的区域，从而显著提高贪婪搜索的效率和效果，这是迈向实际复杂应用的关键一步。",
            "id": "3411750",
            "problem": "考虑区间 $[0,1]$ 上的参数化、矫顽、对称边值问题，其具有齐次狄利克雷边界条件：求 $u(\\cdot;\\mu)$ 使得\n$$\n-\\mu\\,u''(x;\\mu) + \\gamma\\,u(x;\\mu) = f(x), \\quad x\\in (0,1), \\quad u(0;\\mu)=u(1;\\mu)=0,\n$$\n其中参数 $\\mu$ 在一个紧参数域 $\\mathcal{P}=[\\mu_{\\min},\\mu_{\\max}]$ 内变化，反应系数 $\\gamma0$ 是固定的且与 $\\mu$ 无关，源项为 $f(x)=1$。在正交正弦基 $\\{\\varphi_k(x)\\}_{k=1}^{\\mathcal{N}_h}$（其中 $\\varphi_k(x)=\\sqrt{2}\\sin(k\\pi x)$）中进行谱 Galerkin 全阶离散化，得到一个对角化的刚度加质量结构，其对角线元素为 $\\mu\\,(k\\pi)^2+\\gamma$（对于 $k\\in\\{1,\\dots,\\mathcal{N}_h\\}$），右端项系数为 $b_k=\\sqrt{2}\\int_0^1 \\sin(k\\pi x)\\,dx=\\sqrt{2}(1-(-1)^k)/(k\\pi)$。因此，对于每个 $\\mu\\in\\mathcal{P}$，全阶系数向量 $u^{\\mathrm{truth}}(\\mu)\\in\\mathbb{R}^{\\mathcal{N}_h}$ 满足一个对称正定系统。\n\n定义一个降阶基空间 $V_N=\\mathrm{span}\\{u^{\\mathrm{truth}}(\\mu_n)\\}_{n=1}^N$，该空间通过在一个有限训练集 $\\Xi\\subset\\mathcal{P}$ 上使用贪心算法构建。在每个贪心步骤中，选择使当前降阶基后验误差估计器最大化的参数 $\\mu^\\star\\in\\Xi$，并将相应的全阶快照在关于谱刚度矩阵导出的、与参数无关的内积下进行正交规范化后，附加到基中。该误差估计器是基于全阶算子的残差的对偶范数，在此对称矫顽设定下，它等价于能量范数误差。假设基于残差的估计器通过对谱算子进行对角求逆，在全阶空间中精确计算。\n\n您的任务是：\n\n1) 从以下基本事实出发：(i) 谱 Galerkin 方法在正弦基中产生算子的对角表示，对角线元素为 $\\mu\\,(k\\pi)^2+\\gamma$；(ii) Galerkin 正交性对对称矫顽问题成立；(iii) 残差的对偶范数为对称矫顽问题的能量范数误差提供了一个精确的后验估计器。请您推导出一个在训练集 $\\Xi$ 上的有原则的贪心选择规则，以及一个适用于此问题的严谨的、基于残差的误差估计器映射 $\\mu\\mapsto \\Delta_N(\\mu)$。您的推导必须从这些基本原理开始，不得假定任何未经证实的捷径。\n\n2) 设计并实现一个针对训练集 $\\Xi$ 的自适应加密策略，该策略由当前的估计器误差映射 $\\mu\\mapsto \\Delta_N(\\mu)$ 驱动。该加密策略必须：\n- 将 $\\mathcal{P}$ 划分为由 $\\Xi$ 中排序后的点所构成的子区间。\n- 对于每个子区间，通过在一个稠密的、均匀的探测网格 $\\mathcal{G}\\subset\\mathcal{P}$ 上评估 $\\Delta_N(\\mu)$ 来估计其局部最大误差。\n- 根据一个量化标准，在子区间中点添加新的参数点：选择最多 $\\mathcal{K}$ 个子区间，其局部最大误差超过当前全局最大误差的一部分 $\\theta\\in(0,1)$，若出现平局则优先选择局部最大值较大的子区间。如果某个子区间不包含任何探测网格点，则在其中心点评估估计器以决定是否加密。\n- 重复加密过程 $\\mathcal{R}$ 轮，在每一轮中通过贪心程序重建降阶基，直到基的大小达到预设上限 $N_{\\max}$ 或训练集上的最大估计器值低于容差 $\\varepsilon_{\\mathrm{tol}}$。\n\n3) 将上述内容实现为一个完整的程序，该程序使用具有 $\\mathcal{N}_h$ 个正弦模态的谱 Galerkin 全阶模型，通过在刚度诱导内积中进行正交规范化的贪心选择来构建降阶基，通过对角求逆精确评估基于残差的估计器，并根据所述标准自适应地加密 $\\Xi$。\n\n您的程序必须执行以下测试套件并产生所要求的最终输出。\n\n测试套件：\n- 案例 A（理想路径，宽变化范围）：$\\mathcal{N}_h=80$，$\\gamma=1$，$\\mathcal{P}=[\\mu_{\\min},\\mu_{\\max}]=[0.1,1.0]$，初始均匀训练集大小 $M_0=5$（包括端点），探测网格大小 $|\\mathcal{G}|=400$，贪心上限 $N_{\\max}=6$，容差 $\\varepsilon_{\\mathrm{tol}}=10^{-6}$，加密轮次 $\\mathcal{R}=2$，每轮添加上限 $\\mathcal{K}=2$，阈值分数 $\\theta=0.6$。\n- 案例 B（较窄域）：$\\mathcal{N}_h=80$，$\\gamma=1$，$\\mathcal{P}=[0.5,1.0]$，$M_0=4$，$|\\mathcal{G}|=300$，$N_{\\max}=5$，$\\varepsilon_{\\mathrm{tol}}=10^{-8}$，$\\mathcal{R}=2$，$\\mathcal{K}=1$，$\\theta=0.7$。\n- 案例 C（在小扩散率附近强调边界）：$\\mathcal{N}_h=80$，$\\gamma=1$，$\\mathcal{P}=[0.05,0.2]$，$M_0=6$，$|\\mathcal{G}|=500$，$N_{\\max}=8$，$\\varepsilon_{\\mathrm{tol}}=10^{-7}$，$\\mathcal{R}=3$，$\\mathcal{K}=2$，$\\theta=0.5$。\n\n答案规格：\n- 对于每个案例，在完成所有加密轮次后，为最终的训练集通过贪心算法重建降阶基，并使用最终的基计算探测网格 $\\mathcal{G}$ 上的最终最坏情况估计器 $\\max_{\\mu\\in\\mathcal{G}}\\Delta_N(\\mu)$。将此最大值作为浮点数返回。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[r_A,r_B,r_C]$，其中 $r_A$、$r_B$ 和 $r_C$ 是案例 A、B 和 C 的三个浮点数结果。\n\n角度单位不适用。不需要物理单位。所有数值量必须以默认浮点单位报告。通过使用谱 Galerkin 离散化所隐含的精确对角逆来评估基于残差的估计器，以确保科学真实性。",
            "solution": "我们从对称、矫顽、参数化的偏微分方程的核心原理开始，这些方程通过谱方法或间断 Galerkin 方法进行离散化。对于每个参数 $\\mu\\in\\mathcal{P}$，与该边值问题相关的算子是双线性形式\n$$\na_\\mu(u,v) = \\mu \\int_0^1 u'(x)\\,v'(x)\\,dx + \\gamma \\int_0^1 u(x)\\,v(x)\\,dx,\n$$\n对于任何 $\\mu0$ 和 $\\gamma0$，该形式都是对称且矫顽的。在使用正弦基 $\\{\\varphi_k(x)\\}_{k=1}^{\\mathcal{N}_h}$（其中 $\\varphi_k(x)=\\sqrt{2}\\sin(k\\pi x)$）的谱 Galerkin 方法中，刚度部分和质量部分是对角的，因为 $\\{\\varphi_k\\}$ 是狄利克雷拉普拉斯算子的特征函数，并且在 $L^2(0,1)$ 中是正交规范的。具体来说，\n$$\n\\int_0^1 \\varphi_k'(x)\\,\\varphi_j'(x)\\,dx = (k\\pi)^2\\,\\delta_{kj},\\qquad \\int_0^1 \\varphi_k(x)\\,\\varphi_j(x)\\,dx = \\delta_{kj}.\n$$\n因此，谱 Galerkin 全阶离散算子是对角的，其元素为 $d_k(\\mu)=\\mu\\,(k\\pi)^2 + \\gamma$（对于 $k\\in\\{1,\\dots,\\mathcal{N}_h\\}$）。对于 $f(x)=1$ 的右端项系数为\n$$\nb_k = \\int_0^1 f(x)\\,\\varphi_k(x)\\,dx = \\sqrt{2}\\int_0^1 \\sin(k\\pi x)\\,dx = \\frac{\\sqrt{2}\\,\\bigl(1-(-1)^k\\bigr)}{k\\pi}.\n$$\n因此，全阶离散解的系数由下式明确给出\n$$\nu^{\\mathrm{truth}}_k(\\mu) = \\frac{b_k}{\\mu\\,(k\\pi)^2 + \\gamma}.\n$$\n\n对于一个由选定的全阶快照张成的 $N$ 维降阶基 $V_N=\\mathrm{span}\\{u^{\\mathrm{truth}}(\\mu_n)\\}_{n=1}^N$，Galerkin 降阶系统为\n$$\nA_N(\\mu)\\,\\alpha(\\mu) = B_N, \\qquad A_N(\\mu) = V^\\top A(\\mu)\\,V,\\quad B_N=V^\\top b,\n$$\n其中 $V\\in\\mathbb{R}^{\\mathcal{N}_h\\times N}$ 的列是 $V_N$ 的一个基，$A(\\mu)\\in\\mathbb{R}^{\\mathcal{N}_h\\times \\mathcal{N}_h}$ 是全阶对角算子，其元素为 $d_k(\\mu)$，而 $b\\in\\mathbb{R}^{\\mathcal{N}_h}$ 是全阶右端项向量。降阶解为 $u_N(\\mu)=V\\,\\alpha(\\mu)$。\n\n降阶解的残差是线性泛函\n$$\nr_\\mu(v) = f(v) - a_\\mu(u_N(\\mu),v) = \\langle b - A(\\mu)u_N(\\mu),\\,v\\rangle,\n$$\n其系数向量形式为 $r(\\mu) = b - A(\\mu)\\,u_N(\\mu)$。对于对称矫顽问题，残差相对于由 $a_\\mu(\\cdot,\\cdot)$ 生成的能量范数的对偶范数等于能量范数误差。具体而言，由于 $A(\\mu)$ 是对称正定的，且 $u^{\\mathrm{truth}}(\\mu)$ 满足 $A(\\mu)\\,u^{\\mathrm{truth}}(\\mu)=b$，则误差 $e(\\mu)=u^{\\mathrm{truth}}(\\mu)-u_N(\\mu)$ 满足 $A(\\mu)e(\\mu)=r(\\mu)$。于是\n$$\n\\|e(\\mu)\\|_{a_\\mu}^2 = a_\\mu(e(\\mu),e(\\mu)) = e(\\mu)^\\top A(\\mu)\\,e(\\mu) = e(\\mu)^\\top r(\\mu) = r(\\mu)^\\top A(\\mu)^{-1} r(\\mu),\n$$\n这显示了精确的恒等式\n$$\n\\Delta_N(\\mu) := \\|r(\\mu)\\|_{A(\\mu)^{-1}} = \\sqrt{r(\\mu)^\\top A(\\mu)^{-1} r(\\mu)} = \\|e(\\mu)\\|_{a_\\mu}.\n$$\n由于在此谱设定下全阶算子 $A(\\mu)$ 是对角的，因此 $A(\\mu)^{-1}$ 的计算是精确、鲁棒且成本低廉的：它相当于对对角元素 $d_k(\\mu)$ 进行逐项取倒数。\n\n在有限训练集 $\\Xi\\subset\\mathcal{P}$ 上的贪心选择规则遵循基于这些原理的标准范式。给定当前的降阶基 $V_N$，下一个参数通过以下方式选择\n$$\n\\mu_{N+1} \\in \\operatorname*{arg\\,max}_{\\mu\\in\\Xi} \\Delta_N(\\mu),\n$$\n并将相应的快照 $u^{\\mathrm{truth}}(\\mu_{N+1})$ 与 $V_N$ 进行正交规范化以得到 $V_{N+1}$。正交规范化是关于一个与参数无关的内积进行的，该内积反映了双线性形式的刚度部分；这里我们使用内积 $\\langle u,v\\rangle_K = u^\\top K\\,v$，其中 $K$ 是对角线元素为 $(k\\pi)^2$ 的对角矩阵，因为 $A(\\mu)=\\mu K + \\gamma I$ 并且 $K$ 编码了与参数无关的微分算子。这种选择保持了数值稳定性，并与矫顽性结构保持一致。\n\n训练集 $\\Xi$ 的自适应加密由当前映射 $\\mu\\mapsto \\Delta_N(\\mu)$ 驱动，该映射在一个稠密的探测网格 $\\mathcal{G}$ 上进行评估。设排序后的训练集为 $\\Xi=\\{\\mu^{(0)},\\mu^{(1)},\\dots,\\mu^{(m)}\\}$，其中 $\\mu^{(0)}=\\mu_{\\min}$ 且 $\\mu^{(m)}=\\mu_{\\max}$。定义子区间 $I_j=[\\mu^{(j)},\\mu^{(j+1)}]$，其中 $j\\in\\{0,\\dots,m-1\\}$。对每个 $I_j$，计算一个局部指标\n$$\nE_j = \\max_{\\mu\\in \\mathcal{G}\\cap I_j}\\Delta_N(\\mu),\n$$\n约定如果 $\\mathcal{G}\\cap I_j=\\emptyset$，我们就在中点 $\\frac{1}{2}(\\mu^{(j)}+\\mu^{(j+1)})$ 处评估 $\\Delta_N$ 来定义 $E_j$。令 $E_{\\max}=\\max_j E_j$。给定一个阈值分数 $\\theta\\in(0,1)$ 和每轮上限 $\\mathcal{K}\\in\\mathbb{N}$，我们选择最多 $\\mathcal{K}$ 个满足 $E_j\\ge \\theta E_{\\max}$ 的索引 $j$，若有平局则优先选择 $E_j$ 较大的，并通过将所选区间的中点插入到 $\\Xi$ 中来进行加密。此过程重复预定数量 $\\mathcal{R}$ 的轮次。在每一轮中，使用当前的 $\\Xi$ 通过贪心算法重建降阶基，直到训练集上的最大估计器值低于预设容差 $\\varepsilon_{\\mathrm{tol}}$ 或降阶基的大小达到上限 $N_{\\max}$。\n\n算法设计：\n\n- 全阶模型组装：构建对角元素 $d_k(\\mu)=\\mu\\,(k\\pi)^2+\\gamma$（对于 $k\\in\\{1,\\dots,\\mathcal{N}_h\\}$）的向量和右端项 $b_k=\\sqrt{2}(1-(-1)^k)/(k\\pi)$。同时构建刚度特征值向量 $\\kappa_k=(k\\pi)^2$。\n\n- 内积和正交规范化：使用关于 $\\langle \\cdot,\\cdot\\rangle_K$ 的修正 Gram–Schmidt 方法，即 $\\langle u,v\\rangle_K = \\sum_{k=1}^{\\mathcal{N}_h} \\kappa_k\\,u_k\\,v_k$。通过诱导范数 $\\|v\\|_K=\\sqrt{\\langle v,v\\rangle_K}$ 进行归一化。\n\n- 降阶 Galerkin 求解：对于给定的 $\\mu$，组装 $A_N(\\mu) = \\mu I + \\gamma G$，其中由于 $K$-正交规范性，$V^\\top K V=I$，所以 $G=V^\\top V$。计算 $B_N=V^\\top b$，求解 $A_N(\\mu)\\alpha(\\mu)=B_N$，并设置 $u_N(\\mu)=V\\,\\alpha(\\mu)$。\n\n- 基于残差的估计器：构建残差 $r(\\mu)=b - (\\mu K + \\gamma I) u_N(\\mu)$ 并计算\n$$\n\\Delta_N(\\mu) = \\left(\\sum_{k=1}^{\\mathcal{N}_h} \\frac{r_k(\\mu)^2}{\\mu\\,(k\\pi)^2+\\gamma}\\right)^{1/2},\n$$\n由于谱表示，对角求逆是精确的。\n\n- 贪心选择：在 $\\Xi$ 上迭代以选择使 $\\Delta_N(\\mu)$ 最大化的 $\\mu^\\star$，在 $K$-正交规范化后附加快照 $u^{\\mathrm{truth}}(\\mu^\\star)$，并在 $N=N_{\\max}$ 或 $\\max_{\\mu\\in\\Xi}\\Delta_N(\\mu)\\le \\varepsilon_{\\mathrm{tol}}$ 时停止。\n\n- 自适应加密：在 $\\mathcal{G}$ 上评估 $\\Delta_N(\\mu)$，计算子区间指标 $E_j$，选择最多 $\\mathcal{K}$ 个满足 $E_j\\ge \\theta E_{\\max}$ 的子区间（按 $E_j$ 降序排列），插入中点，并进入下一轮。\n\n测试套件指定了三个具有不同参数域和加密设置的案例。对于每个案例，在完成所有加密轮次后，我们使用最终的训练集重建降阶基，并计算探测网格上的最终最坏情况估计器 $\\max_{\\mu\\in\\mathcal{G}}\\Delta_N(\\mu)$。程序将这三个浮点值输出为单行列表 $[r_A,r_B,r_C]$。\n\n此设计基于 $a_\\mu(\\cdot,\\cdot)$ 的对称性和矫顽性、Galerkin 正交性以及谱 Galerkin 离散化中对偶残差范数的可精确计算性。自适应加密标准针对那些对当前最大误差贡献最大的子区间，通过在估计器景观陡峭或凸起的区域丰富 $\\Xi$ 来确保有效降低上确界误差。使用刚度诱导的内积进行正交规范化，可以稳定跨 $\\mu$ 的贪心基构建，并与主导微分算子对齐，这在算子诱导范数很自然的谱方法和间断 Galerkin 方法的背景下尤其合适。",
            "answer": "```python\nimport numpy as np\n\ndef sine_spectral_operators(Nh):\n    k = np.arange(1, Nh + 1, dtype=float)\n    kappa = (np.pi * k)**2\n    b = np.zeros(Nh)\n    odd_k = k[::2]\n    b[::2] = np.sqrt(2.0) * 2.0 / (np.pi * odd_k)\n    return kappa, b\n\ndef truth_snapshot(mu, kappa, b, gamma):\n    denom = mu * kappa + gamma\n    return b / denom\n\ndef mgs_K(u, V, kappa):\n    proj_coeffs = V.T @ (kappa * u)\n    u_orth = u - V @ proj_coeffs\n    norm_u_orth = np.sqrt(u_orth.T @ (kappa * u_orth))\n    return u_orth, norm_u_orth\n\ndef rb_solve(mu, V, kappa, b, gamma):\n    Nh, N = V.shape\n    G = V.T @ V\n    An = mu * np.identity(N) + gamma * G\n    Bn = V.T @ b\n    alpha = np.linalg.solve(An, Bn)\n    u_N = V @ alpha\n    return u_N\n\ndef error_estimator(mu, u_N, kappa, b, gamma):\n    residual = b - (mu * kappa * u_N + gamma * u_N)\n    A_inv_r = residual / (mu * kappa + gamma)\n    error_norm_sq = residual.T @ A_inv_r\n    return np.sqrt(max(0, error_norm_sq))\n\ndef greedy_build(train_set, N_max, eps_tol, Nh, kappa, b, gamma):\n    V = np.empty((Nh, 0))\n    mu_1 = train_set[0]\n    s1 = truth_snapshot(mu_1, kappa, b, gamma)\n    norm_s1 = np.sqrt(s1.T @ (kappa * s1))\n    v1 = s1 / norm_s1\n    V = np.hstack([V, v1.reshape(-1, 1)])\n\n    for N in range(1, N_max):\n        errors = []\n        for mu_train in train_set:\n            u_N = rb_solve(mu_train, V, kappa, b, gamma)\n            err = error_estimator(mu_train, u_N, kappa, b, gamma)\n            errors.append(err)\n        \n        max_error = np.max(errors)\n        if max_error  eps_tol:\n            break\n        \n        mu_star_idx = np.argmax(errors)\n        mu_star = train_set[mu_star_idx]\n        \n        new_snapshot = truth_snapshot(mu_star, kappa, b, gamma)\n        s_orth, norm_s_orth = mgs_K(new_snapshot, V, kappa)\n        \n        if norm_s_orth > 1e-10: # Avoid adding linearly dependent vectors\n            v_new = s_orth / norm_s_orth\n            V = np.hstack([V, v_new.reshape(-1, 1)])\n    \n    return V\n\ndef solve():\n    test_cases = [\n        {'Nh': 80, 'gamma': 1, 'P': [0.1, 1.0], 'M0': 5, 'G_size': 400, 'N_max': 6, 'eps_tol': 1e-6, 'R': 2, 'K': 2, 'theta': 0.6},\n        {'Nh': 80, 'gamma': 1, 'P': [0.5, 1.0], 'M0': 4, 'G_size': 300, 'N_max': 5, 'eps_tol': 1e-8, 'R': 2, 'K': 1, 'theta': 0.7},\n        {'Nh': 80, 'gamma': 1, 'P': [0.05, 0.2], 'M0': 6, 'G_size': 500, 'N_max': 8, 'eps_tol': 1e-7, 'R': 3, 'K': 2, 'theta': 0.5},\n    ]\n    \n    final_results = []\n\n    for case in test_cases:\n        Nh, gamma = case['Nh'], case['gamma']\n        mu_min, mu_max = case['P']\n        kappa, b = sine_spectral_operators(Nh)\n        \n        train_set = list(np.linspace(mu_min, mu_max, case['M0']))\n        probe_grid = np.linspace(mu_min, mu_max, case['G_size'])\n\n        for r in range(case['R']):\n            V = greedy_build(train_set, case['N_max'], case['eps_tol'], Nh, kappa, b, gamma)\n            \n            probe_errors = []\n            for mu_probe in probe_grid:\n                u_N = rb_solve(mu_probe, V, kappa, b, gamma)\n                err = error_estimator(mu_probe, u_N, kappa, b, gamma)\n                probe_errors.append(err)\n            probe_errors = np.array(probe_errors)\n            \n            E_max_global = np.max(probe_errors)\n            \n            sorted_train_set = sorted(train_set)\n            subintervals = []\n            for i in range(len(sorted_train_set) - 1):\n                subintervals.append((sorted_train_set[i], sorted_train_set[i+1]))\n\n            local_max_errors = []\n            for i, (mu_j, mu_j1) in enumerate(subintervals):\n                mask = (probe_grid >= mu_j)  (probe_grid = mu_j1)\n                if np.any(mask):\n                    local_max = np.max(probe_errors[mask])\n                else: # Interval contains no probe points\n                    mu_mid = (mu_j + mu_j1) / 2\n                    u_N_mid = rb_solve(mu_mid, V, kappa, b, gamma)\n                    local_max = error_estimator(mu_mid, u_N_mid, kappa, b, gamma)\n                local_max_errors.append((local_max, i))\n            \n            local_max_errors.sort(key=lambda x: x[0], reverse=True)\n\n            points_to_add = []\n            for j in range(min(case['K'], len(local_max_errors))):\n                err_val, interval_idx = local_max_errors[j]\n                if err_val >= case['theta'] * E_max_global:\n                    mu_j, mu_j1 = subintervals[interval_idx]\n                    points_to_add.append((mu_j + mu_j1) / 2.0)\n            \n            for pt in points_to_add:\n                if pt not in train_set:\n                    train_set.append(pt)\n\n        # Final build and evaluation\n        final_V = greedy_build(train_set, case['N_max'], case['eps_tol'], Nh, kappa, b, gamma)\n        final_probe_errors = []\n        for mu_probe in probe_grid:\n            u_N = rb_solve(mu_probe, final_V, kappa, b, gamma)\n            err = error_estimator(mu_probe, u_N, kappa, b, gamma)\n            final_probe_errors.append(err)\n            \n        final_results.append(np.max(final_probe_errors))\n        \n    print(f\"[{final_results[0]},{final_results[1]},{final_results[2]}]\")\n\nsolve()\n```"
        }
    ]
}