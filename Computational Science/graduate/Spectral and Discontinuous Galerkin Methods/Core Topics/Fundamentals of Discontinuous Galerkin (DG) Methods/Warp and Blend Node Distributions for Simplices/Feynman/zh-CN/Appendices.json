{
    "hands_on_practices": [
        {
            "introduction": "扭曲与融合（warp-and-blend）策略的核心在于一个一维变换，它将等距节点映射到高斯-洛巴托-勒让德（GLL）节点，从而改善节点分布的质量。这项实践将引导你通过一个具体的例子（$N=3$），从第一性原理出发，手动推导一维扭曲函数的所有组成部分 。通过这个“纸笔”练习，你将对勒让德多项式、GLL 节点和拉格朗日插值等基本概念建立深刻的直观理解。",
            "id": "3427539",
            "problem": "在高阶谱方法和间断伽辽金（DG）方法中，扭曲-融合策略通过一维扭曲将等距边节点映射到雅可比-高斯-洛巴托节点，然后将其融合到单元内部，从而构建高质量的节点集。考虑区间 $\\left[-1,1\\right]$ 上的一维边。令 $\\left\\{r_{\\mathrm{eq},j}\\right\\}_{j=0}^{N}$ 为等距节点 $r_{\\mathrm{eq},j}=-1+\\dfrac{2j}{N}$，令 $\\left\\{r_{\\mathrm{gll},j}\\right\\}_{j=0}^{N}$ 为高斯-洛巴托-勒让德（GLL）节点，其定义为端点 $\\{-1,1\\}$ 与由勒让德多项式 $P_{N}(x)$ 的导数的根给出的内点的并集，其中 $P_{N}$ 表示雅可比多项式 $P_{N}^{(0,0)}$。定义与 $\\{r_{\\mathrm{eq},j}\\}_{j=0}^{N}$ 相关联的等距拉格朗日基 $\\{\\ell_{j}^{\\mathrm{eq}}(x)\\}_{j=0}^{N}$ 和一维扭曲\n$$\nW(x)\\;=\\;\\sum_{j=0}^{N}\\ell_{j}^{\\mathrm{eq}}(x)\\,\\big(r_{\\mathrm{gll},j}-r_{\\mathrm{eq},j}\\big).\n$$\n\n仅从区间 $\\left[-1,1\\right]$ 上权重为 $(1-x)^{\\alpha}(1+x)^{\\beta}$ 的雅可比多项式 $P_{n}^{(\\alpha,\\beta)}(x)$ 的标准性质出发，包括当 $(\\alpha,\\beta)=(0,0)$ 时得到勒让德多项式 $P_{n}(x)$，以及 GLL 内节点是 $P_{N}'(x)$ 的根，对多项式阶数 $N=3$ 进行以下操作：\n\n- 通过求解 $P_{3}'(x)=0$ 显式地导出 GLL 内节点。\n- 构建等距节点 $\\{r_{\\mathrm{eq},j}\\}_{j=0}^{3}$。\n- 构造等距拉格朗日多项式 $\\ell_{j}^{\\mathrm{eq}}(x)$ 并在 $x=\\dfrac{1}{2}$ 处计算 $W(x)$ 的值。\n\n以精确的封闭形式表达您对 $W\\!\\left(\\dfrac{1}{2}\\right)$ 的最终答案。无需四舍五入。不包括单位。",
            "solution": "该问题是适定的且科学上是合理的，设置在偏微分方程数值方法的标准框架内。所有定义和条件都是标准的和自洽的。我们继续求解多项式阶数 $N=3$ 的情况。\n\n主要任务是推导 $N=3$ 时扭曲函数 $W(x)$ 的必要组成部分，然后在 $x=\\frac{1}{2}$ 处对其求值。扭曲函数定义为：\n$$\nW(x) = \\sum_{j=0}^{N} \\ell_{j}^{\\mathrm{eq}}(x) (r_{\\mathrm{gll},j} - r_{\\mathrm{eq},j})\n$$\n其中 $\\{r_{\\mathrm{eq},j}\\}$ 是等距节点，$\\{r_{\\mathrm{gll},j}\\}$ 是高斯-洛巴托-勒让德（GLL）节点，而 $\\{\\ell_{j}^{\\mathrm{eq}}(x)\\}$ 是与等距节点相关联的拉格朗日基多项式。\n\n**步骤 1：确定勒让德多项式 $P_3(x)$ 及其导数**\n\n勒让德多项式 $P_n(x)$ 是雅可比多项式 $P_n^{(\\alpha,\\beta)}(x)$ 在 $\\alpha=0$ 和 $\\beta=0$ 时的特例。满足标准归一化 $P_n(1)=1$ 的前几个勒让德多项式是：\n$P_0(x) = 1$\n$P_1(x) = x$\n$P_2(x) = \\frac{1}{2}(3x^2 - 1)$\n我们可以使用 Bonnet 递推关系找到 $P_3(x)$：$(n+1)P_{n+1}(x) = (2n+1)xP_n(x) - nP_{n-1}(x)$。对于 $n=2$：\n$$\n(2+1)P_3(x) = (2(2)+1)xP_2(x) - 2P_1(x)\n$$\n$$\n3P_3(x) = 5x \\left( \\frac{1}{2}(3x^2 - 1) \\right) - 2x = \\frac{15}{2}x^3 - \\frac{5}{2}x - 2x = \\frac{15}{2}x^3 - \\frac{9}{2}x\n$$\n$$\nP_3(x) = \\frac{1}{3} \\left( \\frac{15}{2}x^3 - \\frac{9}{2}x \\right) = \\frac{1}{2}(5x^3 - 3x)\n$$\n$P_3(x)$ 的导数是：\n$$\nP_3'(x) = \\frac{d}{dx} \\left( \\frac{1}{2}(5x^3 - 3x) \\right) = \\frac{1}{2}(15x^2 - 3)\n$$\n\n**步骤 2：导出高斯-洛巴托-勒让德（GLL）节点**\n\n对于 $N=3$，GLL 节点 $\\{r_{\\mathrm{gll},j}\\}_{j=0}^3$ 由区间 $[-1, 1]$ 的端点和 $P_3'(x)=0$ 的根组成。我们求解内节点：\n$$\nP_3'(x) = 0 \\implies \\frac{1}{2}(15x^2 - 3) = 0 \\implies 15x^2 = 3 \\implies x^2 = \\frac{3}{15} = \\frac{1}{5}\n$$\n根是 $x = \\pm\\frac{1}{\\sqrt{5}}$。\n按升序排列的完整 GLL 节点集是：\n$r_{\\mathrm{gll},0} = -1$\n$r_{\\mathrm{gll},1} = -\\frac{1}{\\sqrt{5}}$\n$r_{\\mathrm{gll},2} = \\frac{1}{\\sqrt{5}}$\n$r_{\\mathrm{gll},3} = 1$\n\n**步骤 3：构建等距节点**\n\n对于 $N=3$，等距节点由 $r_{\\mathrm{eq},j} = -1 + \\frac{2j}{3}$ 给出，其中 $j \\in \\{0, 1, 2, 3\\}$：\n$r_{\\mathrm{eq},0} = -1 + \\frac{2(0)}{3} = -1$\n$r_{\\mathrm{eq},1} = -1 + \\frac{2(1)}{3} = -\\frac{1}{3}$\n$r_{\\mathrm{eq},2} = -1 + \\frac{2(2)}{3} = \\frac{1}{3}$\n$r_{\\mathrm{eq},3} = -1 + \\frac{2(3)}{3} = 1$\n等距节点集是 $\\{-1, -\\frac{1}{3}, \\frac{1}{3}, 1\\}$。\n\n**步骤 4：计算节点差**\n\n我们计算差值 $\\Delta r_j = r_{\\mathrm{gll},j} - r_{\\mathrm{eq},j}$：\n$\\Delta r_0 = r_{\\mathrm{gll},0} - r_{\\mathrm{eq},0} = -1 - (-1) = 0$\n$\\Delta r_1 = r_{\\mathrm{gll},1} - r_{\\mathrm{eq},1} = -\\frac{1}{\\sqrt{5}} - (-\\frac{1}{3}) = \\frac{1}{3} - \\frac{1}{\\sqrt{5}}$\n$\\Delta r_2 = r_{\\mathrm{gll},2} - r_{\\mathrm{eq},2} = \\frac{1}{\\sqrt{5}} - \\frac{1}{3}$\n$\\Delta r_3 = r_{\\mathrm{gll},3} - r_{\\mathrm{eq},3} = 1 - 1 = 0$\n\n**步骤 5：在 $x=\\frac{1}{2}$ 处计算等距拉格朗日基多项式的值**\n\n拉格朗日基多项式 $\\ell_{j}^{\\mathrm{eq}}(x)$ 定义为 $\\ell_{j}^{\\mathrm{eq}}(x) = \\prod_{k=0, k\\neq j}^{3} \\frac{x-r_{\\mathrm{eq},k}}{r_{\\mathrm{eq},j}-r_{\\mathrm{eq},k}}$。我们需要在 $x=\\frac{1}{2}$ 处计算它们的值。\n等距节点是 $\\{r_0, r_1, r_2, r_3\\} = \\{-1, -\\frac{1}{3}, \\frac{1}{3}, 1\\}$。\n\n对于 $j=0$: $\\ell_{0}^{\\mathrm{eq}}(\\frac{1}{2}) = \\frac{(\\frac{1}{2}-(-\\frac{1}{3}))(\\frac{1}{2}-\\frac{1}{3})(\\frac{1}{2}-1)}{(-1-(-\\frac{1}{3}))(-1-\\frac{1}{3})(-1-1)} = \\frac{(\\frac{5}{6})(\\frac{1}{6})(-\\frac{1}{2})}{(-\\frac{2}{3})(-\\frac{4}{3})(-2)} = \\frac{-5/72}{-16/9} = \\frac{5}{128}$。\n\n对于 $j=1$: $\\ell_{1}^{\\mathrm{eq}}(\\frac{1}{2}) = \\frac{(\\frac{1}{2}-(-1))(\\frac{1}{2}-\\frac{1}{3})(\\frac{1}{2}-1)}{(-\\frac{1}{3}-(-1))(-\\frac{1}{3}-\\frac{1}{3})(-\\frac{1}{3}-1)} = \\frac{(\\frac{3}{2})(\\frac{1}{6})(-\\frac{1}{2})}{(\\frac{2}{3})(-\\frac{2}{3})(-\\frac{4}{3})} = \\frac{-1/8}{16/27} = -\\frac{27}{128}$。\n\n对于 $j=2$: $\\ell_{2}^{\\mathrm{eq}}(\\frac{1}{2}) = \\frac{(\\frac{1}{2}-(-1))(\\frac{1}{2}-(-\\frac{1}{3}))(\\frac{1}{2}-1)}{(\\frac{1}{3}-(-1))(\\frac{1}{3}-(-\\frac{1}{3}))(\\frac{1}{3}-1)} = \\frac{(\\frac{3}{2})(\\frac{5}{6})(-\\frac{1}{2})}{(\\frac{4}{3})(\\frac{2}{3})(-\\frac{2}{3})} = \\frac{-5/8}{-16/27} = \\frac{135}{128}$。\n\n对于 $j=3$: $\\ell_{3}^{\\mathrm{eq}}(\\frac{1}{2}) = \\frac{(\\frac{1}{2}-(-1))(\\frac{1}{2}-(-\\frac{1}{3}))(\\frac{1}{2}-\\frac{1}{3})}{(1-(-1))(1-(-\\frac{1}{3}))(1-\\frac{1}{3})} = \\frac{(\\frac{3}{2})(\\frac{5}{6})(\\frac{1}{6})}{(2)(\\frac{4}{3})(\\frac{2}{3})} = \\frac{5/24}{16/9} = \\frac{15}{128}$。\n\n**步骤 6：计算 $W(\\frac{1}{2})$**\n\n我们现在将计算出的各分量代入 $W(x)$ 在 $x=\\frac{1}{2}$ 处的定义中：\n$$\nW(\\frac{1}{2}) = \\sum_{j=0}^{3} \\ell_{j}^{\\mathrm{eq}}(\\frac{1}{2}) \\Delta r_j = \\ell_{0}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_0 + \\ell_{1}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_1 + \\ell_{2}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_2 + \\ell_{3}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_3\n$$\n由于 $\\Delta r_0 = 0$ 且 $\\Delta r_3 = 0$，表达式简化为：\n$$\nW(\\frac{1}{2}) = \\ell_{1}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_1 + \\ell_{2}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_2\n$$\n代入计算出的值：\n$$\nW(\\frac{1}{2}) = \\left(-\\frac{27}{128}\\right)\\left(\\frac{1}{3} - \\frac{1}{\\sqrt{5}}\\right) + \\left(\\frac{135}{128}\\right)\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right)\n$$\n我们可以将 $(\\frac{1}{\\sqrt{5}} - \\frac{1}{3})$ 作为公因式提取出来：\n$$\nW(\\frac{1}{2}) = \\left(\\frac{27}{128}\\right)\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right) + \\left(\\frac{135}{128}\\right)\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right)\n$$\n$$\nW(\\frac{1}{2}) = \\left(\\frac{27}{128} + \\frac{135}{128}\\right)\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right) = \\left(\\frac{162}{128}\\right)\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right)\n$$\n简化分数 $\\frac{162}{128} = \\frac{81}{64}$：\n$$\nW(\\frac{1}{2}) = \\frac{81}{64}\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right) = \\frac{81}{64\\sqrt{5}} - \\frac{81}{64 \\cdot 3} = \\frac{81\\sqrt{5}}{64 \\cdot 5} - \\frac{27}{64} = \\frac{81\\sqrt{5}}{320} - \\frac{27}{64}\n$$\n为了合并这些项，我们使用公分母 $320$：\n$$\nW(\\frac{1}{2}) = \\frac{81\\sqrt{5}}{320} - \\frac{27 \\cdot 5}{64 \\cdot 5} = \\frac{81\\sqrt{5}}{320} - \\frac{135}{320} = \\frac{81\\sqrt{5} - 135}{320}\n$$\n提取 $81$ 和 $135$ 的最大公约数 $27$：\n$$\nW(\\frac{1}{2}) = \\frac{27(3\\sqrt{5} - 5)}{320}\n$$\n这是最终的精确封闭形式答案。",
            "answer": "$$\n\\boxed{\\frac{27(3\\sqrt{5} - 5)}{320}}\n$$"
        },
        {
            "introduction": "在理解了手动计算的过程之后，下一步是将其推广为通用的算法实现。这项实践要求你编写一个程序，为任意多项式阶数 $N$ 构建一维扭曲函数 。这个过程不仅能巩固你的理论知识，还将锻炼你实现数值算法的能力，例如使用牛顿法求解 GLL 节点，以及利用重心拉格朗日插值法进行稳定求值。",
            "id": "3427542",
            "problem": "实现一个程序，该程序构建一维扭曲函数。此函数用于谱方法和间断伽辽金方法中，在单纯形上的节点分布所采用的“扭曲与融合”(warp-and-blend)策略中。一维扭曲函数的定义如下：对于一个固定的插值阶数 $N \\in \\mathbb{N}$，考虑区间 $[-1,1]$ 上的等距节点，由 $r^{\\mathrm{eq}}_j = -1 + \\dfrac{2j}{N}$ 给出，其中 $j=0,1,\\dots,N$。同时考虑 Gauss–Lobatto–Legendre 节点 $r^{\\mathrm{gl}}_j$，其定义为端点 $\\{-1,1\\}$ 与 $(1-x^2)P'_N(x)$ 的 $N-1$ 个内部根的并集，其中 $P_N(x)$ 表示 $N$ 次 Legendre 多项式。定义节点位移为 $\\Delta_j = r^{\\mathrm{gl}}_j - r^{\\mathrm{eq}}_j$，其中 $j=0,1,\\dots,N$。一维扭曲函数 $W_N(r)$ 是唯一的最高次数不超过 $N$ 的多项式，满足对于所有 $j=0,1,\\dots,N$，都有 $W_N(r^{\\mathrm{eq}}_j) = \\Delta_j$。这个 $W_N(r)$ 稍后将用作高维“扭曲与融合”构造中的边扭曲分量。\n\n您的程序必须从第一性原理出发构建 $W_N(r)$，仅使用以下基本定义和事实：\n- Legendre 多项式 $\\{P_n(x)\\}_{n=0}^\\infty$ 由三项递推关系定义：$P_0(x)=1$，$P_1(x)=x$，以及对于 $n \\ge 2$，$P_n(x) = \\dfrac{(2n-1)xP_{n-1}(x) - (n-1)P_{n-2}(x)}{n}$。\n- 阶数为 $N$ 的 Gauss–Lobatto–Legendre 节点由 $x=-1$、$x=1$ 以及 $(1-x^2)P'_N(x)$ 在 $(-1,1)$ 内的 $N-1$ 个内部根组成。\n- 经过节点 $\\{x_j\\}_{j=0}^N$ 且带有数据 $\\{y_j\\}_{j=0}^N$ 的、次数最高为 $N$ 的唯一插值多项式，由满足 $\\ell_j(x_k)=\\delta_{jk}$ 的 Lagrange 基 $\\{\\ell_j(x)\\}_{j=0}^N$ 所刻画。您必须实现一个算法上稳定的方法，用于在任意 $x \\in [-1,1]$ 处计算该插值多项式的值。\n\n从这些基础出发，推导并实现：\n1. 一个鲁棒的例程，通过求解 $(1-x^2)P'_N(x)$ 的内部根来计算 $N+1$ 个 Gauss–Lobatto–Legendre 节点。这需要使用 Newton 方法，并将其应用于一个平滑的等价系统，以避免在 $x=\\pm 1$ 处的数值问题。\n2. $[-1,1]$ 上的等距节点和位移 $\\Delta_j$。\n3. 一个用于计算 $W_N(r)$ 的例程，该例程基于在等距节点上用数据 $\\Delta_j$ 构建的 Lagrange 插值多项式。您的求值过程必须能正确处理当 $r=r^{\\mathrm{eq}}_j$ (对于某个 $j$) 的情况。\n\n角度单位不相关。此问题中没有物理单位。\n\n测试套件：\n您必须评估以下五个测试用例，每个用例返回一个实数：\n- 测试 1：$N=1$，计算 $|W_N(0)|$。\n- 测试 2：$N=5$，通过计算 $\\max_{0\\le j \\le N} \\left| W_N\\!\\left(r^{\\mathrm{eq}}_j\\right) - \\Delta_j \\right|$ 来验证在等距节点上的插值属性。\n- 测试 3：$N=8$，计算奇对称性残差 $\\max_{x \\in \\{-0.9,-0.31,0.17,0.53,0.9\\}} \\left| W_N(x) + W_N(-x) \\right|$。\n- 测试 4：$N=10$，端点检查 $\\max\\left( |W_N(-1)|,\\ |W_N(1)| \\right)$。\n- 测试 5：$N=7$，中心值 $|W_N(0)|$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果按上述五个测试的顺序排列。例如，它必须打印形如 $[r_1,r_2,r_3,r_4,r_5]$ 的一行，其中每个 $r_k$ 是您的程序为相应测试计算出的浮点数。",
            "solution": "用户希望构建在谱方法和间断伽辽金方法中使用的一维扭曲函数 $W_N(r)$，并针对几个测试用例进行评估。该解决方案要求根据问题陈述中定义的第一性原理来实现必要的组件。这涉及三个主要步骤：\n1.  计算 Gauss-Lobatto-Legendre (GLL) 节点。\n2.  定义节点位移。\n3.  使用稳定的多项式插值构建并评估扭曲函数。\n\n### 步骤 1：Legendre 多项式及其导数\n\n这个问题的基础是 Legendre 多项式 $P_N(x)$。我们不仅需要多项式本身，还需要它的一阶和二阶导数，以便使用 Newton 方法找到 GLL 节点。多项式由三项递推关系定义：\n$P_0(x) = 1$\n$P_1(x) = x$\n$$P_n(x) = \\frac{(2n-1)xP_{n-1}(x) - (n-1)P_{n-2}(x)}{n}, \\quad \\text{for } n \\ge 2$$\n\n通过对这个递推关系关于 $x$ 求导，我们可以得到导数 $P'_n(x)$ 和 $P''_n(x)$ 的递推关系：\n$$n P'_n(x) = (2n-1)P_{n-1}(x) + (2n-1)xP'_{n-1}(x) - (n-1)P'_{n-2}(x)$$\n$$n P''_n(x) = 2(2n-1)P'_{n-1}(x) + (2n-1)xP''_{n-1}(x) - (n-1)P''_{n-2}(x)$$\n\n一个单一的例程可以通过从 $n=0$ 和 $n=1$ 的基本情况开始，并迭代应用这些公式直到所需的阶数 $N$，来计算 $(P_N(x), P'_N(x), P''_N(x))$。对于测试套件所需的小阶数（$N \\leq 10$），此方法在数值上是稳定且高效的。\n\n### 步骤 2：Gauss–Lobatto–Legendre (GLL) 节点\n\n对于一个阶数为 $N$ 的多项式逼近，其 GLL 节点 $r^{\\mathrm{gl}}_j$ 是多项式 $(1-x^2)P'_N(x)$ 的 $N+1$ 个根。这些根包括固定的端点 $x=\\pm 1$ 和 $P'_N(x)$ 的 $N-1$ 个内部根，这些内部根严格位于区间 $(-1, 1)$ 内。\n\n为了找到这些内部根，我们对函数 $f(x) = P'_N(x)$ 应用 Newton 方法。迭代更新规则是：\n$$x_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)} = x_k - \\frac{P'_N(x_k)}{P''_N(x_k)}$$\n这需要 $P'_N(x)$ 和 $P''_N(x)$ 的值，这些值由步骤 1 中的函数提供。\n\n为了使 Newton 方法收敛到正确的根，良好的初始猜测至关重要。$P'_N(x)$ 的 $N-1$ 个内部根是 $P_N(x)$ 的极值点。可以使用已知的这些位置的近似值。对于第 $j$ 个内部根（按降序排列）的初始猜测，一个可靠的选择是 $x_j^{(0)} = \\cos\\left(\\frac{j\\pi}{N}\\right)$，其中 $j=1, 2, \\dots, N-1$。\n\n完整的 $N+1$ 个 GLL 节点集合是通过将这 $N-1$ 个计算出的根与端点 $-1$ 和 $1$ 结合，并按升序排序而形成的。我们将排序后的节点表示为 $\\{r^{\\mathrm{gl}}_j\\}_{j=0}^N$。\n\n### 步骤 3：扭曲函数的构建与评估\n\n扭曲函数 $W_N(r)$ 是一个最高次数不超过 $N$ 的多项式，它将等距节点映射到 GLL 节点。它由插值条件定义：\n$$W_N(r^{\\mathrm{eq}}_j) = \\Delta_j, \\quad j=0, 1, \\dots, N$$\n其中节点和位移是：\n-   **等距节点**：$r^{\\mathrm{eq}}_j = -1 + \\frac{2j}{N}$\n-   **节点位移**：$\\Delta_j = r^{\\mathrm{gl}}_j - r^{\\mathrm{eq}}_j$\n\n为了以数值稳定的方式评估这个插值多项式，我们使用重心 Lagrange 插值公式（第二形式）：\n$$W_N(r) = \\frac{\\displaystyle\\sum_{j=0}^{N} \\frac{w_j}{r - r^{\\mathrm{eq}}_j} \\Delta_j}{\\displaystyle\\sum_{j=0}^{N} \\frac{w_j}{r - r^{\\mathrm{eq}}_j}}$$\n这个公式对于任何节点选择都特别稳定，避免了在使用单项式基表示时可能发生的灾难性抵消。\n\n对于等距节点，重心权重 $w_j$ 可以选择为：\n$$w_j = (-1)^j \\binom{N}{j}$$\n这些权重可以通过递推关系 $w_0 = 1$ 和 $w_{j+1} = -w_j \\frac{N-j}{j+1}$（对于 $j=0, \\dots, N-1$）高效地计算。\n\n实现的一个关键部分是处理评估点 $r$ 与某个插值节点 $r^{\\mathrm{eq}}_k$ 重合的情况。在这种情况下，公式会变成 $0/0$ 的不定形式。根据插值的定义，如果 $r = r^{\\mathrm{eq}}_k$，则函数值就是 $W_N(r^{\\mathrm{eq}}_k) = \\Delta_k$。评估例程必须检查这种情况，以避免除以零并返回正确的值。\n\n### 测试用例分析\n\n对函数性质的理论分析揭示了测试用例的预期结果：\n-   **对称性**：GLL 节点和等距节点都关于原点对称（$r_{N-j} = -r_j$）。这意味着位移是反对称的：$\\Delta_{N-j} = -\\Delta_j$。在对称点上插值反对称数据的多项式必须是奇函数，即对于所有 $r$，$W_N(r) = -W_N(-r)$。\n-   **测试 1 ($N=1, |W_1(0)|$)**：当 $N=1$ 时，$r^{\\mathrm{gl}} = r^{\\mathrm{eq}} = \\{-1, 1\\}$，所以 $\\Delta = \\{0, 0\\}$。插值多项式是 $W_1(r) \\equiv 0$，因此 $|W_1(0)| = 0$。实际上，对于 $N \\le 2$，GLL 节点是等距的，所以 $W_N(r) \\equiv 0$。\n-   **测试 2 ($N=5, \\max|W_5(r^{\\mathrm{eq}}_j) - \\Delta_j|$)**：这测试了基本的插值属性。根据构造，$W_5(r^{\\mathrm{eq}}_j) = \\Delta_j$。结果应为零，误差在机器精度范围内。\n-   **测试 3 ($N=8, \\max|W_8(x) + W_8(-x)|$)**：这测试了奇对称性。由于 $W_8(r)$ 是一个奇函数，所以 $W_8(x) + W_8(-x) = 0$。结果应为零，误差在机器精度范围内。\n-   **测试 4 ($N=10, \\max(|W_{10}(-1)|, |W_{10}(1)|)$)**：这测试了边界值。端点 $r^{\\mathrm{eq}}_0=-1$ 和 $r^{\\mathrm{eq}}_{10}=1$ 是插值节点。$W_{10}(-1) = \\Delta_0 = r^{\\mathrm{gl}}_0 - r^{\\mathrm{eq}}_0 = -1 - (-1) = 0$。同样地，$W_{10}(1) = \\Delta_{10} = 1 - 1 = 0$。结果必须为零。\n-   **测试 5 ($N=7, |W_7(0)|$)**：由于 $W_7(r)$ 是一个奇函数，所以 $W_7(0) = -W_7(-0) \\implies 2W_7(0)=0 \\implies W_7(0)=0$。结果为零。\n\n所有测试用例都被设计为产生零结果，从而对数值实现的正确性和稳定性提供了严格的验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of constructing and evaluating the 1D warp function.\n    \"\"\"\n\n    class WarpAndBlend1D:\n        \"\"\"\n        Constructs and evaluates the 1D warp function W_N(r).\n        \"\"\"\n        def __init__(self, N: int):\n            if not isinstance(N, int) or N  1:\n                raise ValueError(\"Degree N must be a positive integer.\")\n            \n            self.N = N\n            self.r_eq = np.linspace(-1.0, 1.0, N + 1)\n            \n            if N > 0:\n                self.r_gl = self._compute_gll_nodes(N)\n            else: # N=0 case, though problem implies N>=1\n                self.r_gl = np.array([-1.0])\n\n            # Ensure GLL nodes are correctly sorted for displacement calculation\n            self.r_gl.sort()\n\n            self.delta = self.r_gl - self.r_eq\n            self.weights = self._compute_barycentric_weights(N)\n\n        def _legendre_and_derivs(self, N: int, x: float):\n            \"\"\"Computes P_N(x), P'_N(x), and P''_N(x) via recurrence.\"\"\"\n            if N == 0:\n                return 1.0, 0.0, 0.0\n            \n            p_nm2, p_prime_nm2, p_double_prime_nm2 = 1.0, 0.0, 0.0\n            p_nm1, p_prime_nm1, p_double_prime_nm1 = x, 1.0, 0.0\n            \n            if N == 1:\n                return p_nm1, p_prime_nm1, p_double_prime_nm1\n\n            for n in range(2, N + 1):\n                # Recurrence for P_n(x)\n                p_n = ((2 * n - 1) * x * p_nm1 - (n - 1) * p_nm2) / n\n                \n                # Recurrence for P'_n(x)\n                p_prime_n = ((2 * n - 1) * (p_nm1 + x * p_prime_nm1) - (n - 1) * p_prime_nm2) / n\n                \n                # Recurrence for P''_n(x)\n                p_double_prime_n = ((2 * n - 1) * (2 * p_prime_nm1 + x * p_double_prime_nm1) - (n - 1) * p_double_prime_nm2) / n\n                \n                p_nm2, p_prime_nm2, p_double_prime_nm2 = p_nm1, p_prime_nm1, p_double_prime_nm1\n                p_nm1, p_prime_nm1, p_double_prime_nm1 = p_n, p_prime_n, p_double_prime_n\n            \n            return p_nm1, p_prime_nm1, p_double_prime_nm1\n\n        def _compute_gll_nodes(self, N: int):\n            \"\"\"Computes the N+1 Gauss-Lobatto-Legendre nodes for degree N.\"\"\"\n            if N == 1:\n                return np.array([-1.0, 1.0])\n\n            nodes = np.zeros(N + 1)\n            nodes[0], nodes[N] = -1.0, 1.0\n            \n            # Find N-1 interior roots of P'_N(x) using Newton's method\n            for j in range(1, N):\n                # Initial guess for the j-th root\n                x = np.cos(j * np.pi / N)\n                \n                # Newton's method iteration\n                for _ in range(20): # 20 iterations is more than enough\n                    _, p_prime, p_double_prime = self._legendre_and_derivs(N, x)\n                    if abs(p_prime)  1e-15:\n                        break\n                    dx = p_prime / p_double_prime\n                    x -= dx\n                    if abs(dx)  1e-15:\n                        break\n                nodes[j] = x\n            \n            return nodes\n\n        def _compute_barycentric_weights(self, N: int):\n            \"\"\"Computes barycentric weights for equidistant nodes.\"\"\"\n            weights = np.zeros(N + 1)\n            weights[0] = 1.0\n            for j in range(N):\n                weights[j + 1] = -weights[j] * (N - j) / (j + 1)\n            return weights\n\n        def evaluate(self, r_eval):\n            \"\"\"Evaluates the warp function W_N(r) at given points r.\"\"\"\n            r_eval = np.atleast_1d(r_eval)\n            results = np.zeros_like(r_eval, dtype=float)\n            \n            for i, r in enumerate(r_eval):\n                # Check if evaluation point is close to an interpolation node\n                is_node = np.isclose(r, self.r_eq)\n                if np.any(is_node):\n                    idx = np.where(is_node)[0][0]\n                    results[i] = self.delta[idx]\n                else:\n                    # Use barycentric interpolation formula\n                    terms = self.weights / (r - self.r_eq)\n                    numerator = np.sum(terms * self.delta)\n                    denominator = np.sum(terms)\n                    if denominator == 0:\n                        results[i] = 0.0 # Should not happen if check above is robust\n                    else:\n                        results[i] = numerator / denominator\n            \n            return results\n\n    # Define the test cases from the problem statement.\n    test_specs = [\n        {'N': 1, 'type': 'eval', 'points': [0.0], 'op': 'abs'},\n        {'N': 5, 'type': 'interp_check'},\n        {'N': 8, 'type': 'symmetry_check', 'points': [-0.9, -0.31, 0.17, 0.53, 0.9]},\n        {'N': 10, 'type': 'endpoint_check'},\n        {'N': 7, 'type': 'eval', 'points': [0.0], 'op': 'abs'}\n    ]\n\n    results = []\n    # Using a cache for constructed objects to avoid re-computation\n    warp_objects = {}\n\n    for spec in test_specs:\n        N = spec['N']\n        if N not in warp_objects:\n            warp_objects[N] = WarpAndBlend1D(N)\n        \n        w = warp_objects[N]\n        \n        if spec['type'] == 'eval':\n            val = w.evaluate(spec['points'])[0]\n            if spec['op'] == 'abs':\n                results.append(np.abs(val))\n        \n        elif spec['type'] == 'interp_check':\n            vals_at_nodes = w.evaluate(w.r_eq)\n            error = np.max(np.abs(vals_at_nodes - w.delta))\n            results.append(error)\n\n        elif spec['type'] == 'symmetry_check':\n            x = np.array(spec['points'])\n            residual = np.max(np.abs(w.evaluate(x) + w.evaluate(-x)))\n            results.append(residual)\n\n        elif spec['type'] == 'endpoint_check':\n            val = np.max(np.abs(w.evaluate(np.array([-1.0, 1.0]))))\n            results.append(val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这项综合性实践是前面练习的顶峰，它将一维扭曲函数的概念应用到二维三角单纯形上，构建完整的高阶节点分布。你将学习如何将一维的扭曲位移通过“融合”函数平滑地延拓到三角形内部，生成高质量的二维节点集 。更重要的是，本练习将展示这些节点的最终用途：构建高阶插值和微分算子，这是谱元法和间断伽辽金方法等现代数值方法的核心工具。",
            "id": "3427543",
            "problem": "构建一个完整、可运行的程序，该程序针对参考二维单纯形（三角形），实现一种扭曲与融合（warp-and-blend）节点分布，然后使用这些节点来构建适用于高阶谱方法和间断伽辽金方法的插值和微分算子。该程序必须仅依赖于基本定义和经过充分检验的事实，且不得假定目标算子有任何预先推导的封闭形式。\n\n使用以下基本定义和要求。\n\n1. 参考几何、重心坐标和边。\n   - 考虑具有以下顶点的等边参考三角形\n     $$\\mathbf{V}_1 = (-1, -1/\\sqrt{3}), \\quad \\mathbf{V}_2 = (1, -1/\\sqrt{3}), \\quad \\mathbf{V}_3 = (0, 2/\\sqrt{3}).$$\n   - 对于三角形内的任意点，令其重心坐标为 $$\\lambda_1, \\lambda_2, \\lambda_3 \\ge 0, \\quad \\lambda_1 + \\lambda_2 + \\lambda_3 = 1,$$ 且仿射映射为\n     $$\\mathbf{x}(\\lambda_1,\\lambda_2,\\lambda_3) = \\lambda_1 \\mathbf{V}_1 + \\lambda_2 \\mathbf{V}_2 + \\lambda_3 \\mathbf{V}_3.$$\n   - 顶点对边表示为\n     $$\\text{edge } 1: \\overline{\\mathbf{V}_2 \\mathbf{V}_3}, \\quad \\text{edge } 2: \\overline{\\mathbf{V}_1 \\mathbf{V}_3}, \\quad \\text{edge } 3: \\overline{\\mathbf{V}_1 \\mathbf{V}_2}.$$\n\n2. 一维 Gauss–Lobatto–Legendre 节点和边参数的扭曲。\n   - 对于一个多项式次数 $$N \\in \\mathbb{N}_0,$$，通过参数 $$t \\in [0,1]$$ 定义边上的一维等距参数化，其等距节点为 $$t_k = k/N$$（对于 $$k=0,\\dots,N$$）（对于 $$N=0,$$，将唯一的节点解释为边中点）。\n   - 令 $$x^{\\mathrm{GL}}_k \\in [-1,1]$$（对于 $$k=0,\\dots,N$$）表示 Gauss–Lobatto–Legendre 节点，即该集合包含端点 $$-1, 1$$，内部节点是 $$N$$ 次 Legendre 多项式导数的根。定义相应的边参数 $$t^{\\mathrm{GL}}_k = (x^{\\mathrm{GL}}_k + 1)/2 \\in [0,1].$$\n   - 定义一维扭曲函数 $$D_N(t)$$ 为次数最多为 $$N$$ 的唯一多项式，满足插值条件\n     $$D_N(t_k) = t^{\\mathrm{GL}}_k - t_k, \\quad k=0,\\dots,N.$$\n     该函数编码了为实现 Gauss–Lobatto–Legendre 间距，沿边等距参数所需的位移。\n\n3. 三角形上的扭曲与融合节点。\n   - 从等距重心晶格节点\n     $$\\mathcal{L}_N = \\left\\{ (\\lambda_1,\\lambda_2,\\lambda_3) \\,\\middle|\\, \\lambda_i = \\frac{\\ell_i}{N}, \\ \\ell_i \\in \\mathbb{N}_0, \\ \\ell_1+\\ell_2+\\ell_3=N \\right\\}$$\n     开始（对于 $$N \\ge 1$$），对于 $$N=0$$，则使用位于形心的单个节点 $$\\lambda_1=\\lambda_2=\\lambda_3=1/3.$$\n   - 对于每个具有重心坐标 $$\\lambda_1,\\lambda_2,\\lambda_3$$ 的节点，通过投影到每条边上来为其定义一个局部边参数：\n     $$t_1 = \\frac{\\lambda_3}{\\lambda_2+\\lambda_3} \\ \\text{on edge } 1 \\ (\\text{if } \\lambda_2+\\lambda_30), \\quad\n       t_2 = \\frac{\\lambda_1}{\\lambda_1+\\lambda_3} \\ \\text{on edge } 2 \\ (\\text{if } \\lambda_1+\\lambda_30), \\quad\n       t_3 = \\frac{\\lambda_2}{\\lambda_1+\\lambda_2} \\ \\text{on edge } 3 \\ (\\text{if } \\lambda_1+\\lambda_20),$$\n     并在相应分母为零时将 $$t_i=0$$。\n   - 为每条边 $$i \\in \\{1,2,3\\}$$ 定义二次混合因子\n     $$B_i(\\lambda_1,\\lambda_2,\\lambda_3) = (1 - \\lambda_i)^2.$$\n     该因子在边 $$i$$ 上等于 $$1$$，在接近对顶点时趋向于 $$0$$，并在三角形内部平滑衰减。\n   - 令边切向量为\n     $$\\mathbf{e}_1 = \\mathbf{V}_3 - \\mathbf{V}_2, \\quad \\mathbf{e}_2 = \\mathbf{V}_3 - \\mathbf{V}_1, \\quad \\mathbf{e}_3 = \\mathbf{V}_2 - \\mathbf{V}_1.$$\n     然后通过以下方式获得扭曲与融合后的物理坐标\n     $$\\mathbf{x}_{\\mathrm{WB}} = \\mathbf{x}(\\lambda_1,\\lambda_2,\\lambda_3) \\;+\\; \\mathbf{e}_1 \\, B_1 \\, D_N(t_1) \\;+\\; \\mathbf{e}_2 \\, B_2 \\, D_N(t_2) \\;+\\; \\mathbf{e}_3 \\, B_3 \\, D_N(t_3).$$\n     此构造在每条边 $$i$$ 上产生 Gauss–Lobatto–Legendre 间距，因为在边 $$i$$ 上 $$B_i=1$$，且 $$D_N(t)$$ 实现了所需的一维重参数化，而来自其他边的贡献由于 $$D_N(0)=D_N(1)=0$$ 而在端点处消失。\n\n4. 多项式基、插值和微分算子。\n   - 令 $$\\mathcal{P}_N(\\mathbb{R}^2)$$ 表示 $$x,y$$ 中总次数最多为 $$N$$ 的多项式空间。\n   - 使用分次单项式集合 $$\\{ x^i y^j : i \\ge 0, j \\ge 0, i+j \\le N \\}$$ 作为基。如果有 $$M = (N+1)(N+2)/2$$ 个节点 $$\\{\\mathbf{x}_m\\}_{m=1}^M$$，则构造方形 Vandermonde 矩阵 $$\\mathbf{V} \\in \\mathbb{R}^{M \\times M}$$，其元素为\n     $$V_{m,p} = x_m^{i_p} \\, y_m^{j_p},$$\n     其中 $$p$$ 索引了单项式指数 $$\\{(i_p,j_p)\\}.$$\n   - 在任意目标点集 $$\\{\\hat{\\mathbf{x}}_q\\}_{q=1}^{Q}$$ 上求值的节点 Lagrange 基由插值矩阵\n     $$\\mathbf{I} = \\mathbf{V}(\\{\\hat{\\mathbf{x}}_q\\}) \\, \\mathbf{V}^{-1},$$\n     捕获，其中 $$\\mathbf{V}(\\{\\hat{\\mathbf{x}}_q\\})$$ 是在目标点上构建的 Vandermonde 矩阵。\n   - 将标量场 $$f$$ 的节点值映射到其偏导数的节点值的微分矩阵 $$\\mathbf{D}_x, \\mathbf{D}_y \\in \\mathbb{R}^{M \\times M}$$，是通过对单项式基求导并投影回节点基得到的：\n     $$\\mathbf{D}_x = \\mathbf{V}_x \\, \\mathbf{V}^{-1}, \\quad \\mathbf{D}_y = \\mathbf{V}_y \\, \\mathbf{V}^{-1},$$\n     其元素为\n     $$\\left(\\mathbf{V}_x\\right)_{m,p} = \\frac{\\partial}{\\partial x}\\left(x^{i_p} y^{j_p}\\right)\\Big|_{\\mathbf{x}_m} = i_p \\, x_m^{i_p-1} y_m^{j_p}, \\quad\n       \\left(\\mathbf{V}_y\\right)_{m,p} = \\frac{\\partial}{\\partial y}\\left(x^{i_p} y^{j_p}\\right)\\Big|_{\\mathbf{x}_m} = j_p \\, x_m^{i_p} y_m^{j_p-1},$$\n     当相应指数为零时，将 $$x^{-1}=0$$ 和 $$y^{-1}=0$$。\n\n5. 测试套件、目标点和度量标准。\n   - 使用以下多项式次数和测试函数：\n     - 情况 $$A$$：$$N=0$$，标量场 $$f(\\mathbf{x}) = 3.$$ 精确梯度恒等于零。\n     - 情况 $$B$$：$$N=1$$，标量场 $$f(\\mathbf{x}) = 1 + x - 2y.$$ 精确梯度为 $$\\nabla f = (1, -2).$$\n     - 情况 $$C$$：$$N=3$$，标量场 $$f(\\mathbf{x}) = e^{x} \\sin(y).$$ 精确梯度为 $$\\nabla f = \\left(e^{x} \\sin(y), \\ e^{x} \\cos(y)\\right).$$\n   - 使用以下三个固定的目标重心点进行插值测试：\n     $$\\text{T}_1: (\\lambda_1,\\lambda_2,\\lambda_3) = \\left(\\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{3}\\right), \\quad\n       \\text{T}_2: (0.2, 0.3, 0.5), \\quad\n       \\text{T}_3: (0.8, 0.1, 0.1).$$\n     使用第 $$1$$ 项中的仿射映射将每个点映射到物理坐标。\n   - 对于每种情况，计算：\n     - 在三个目标点上的插值均方根误差，\n       $$E_{\\mathrm{int}} = \\sqrt{\\frac{1}{3} \\sum_{q=1}^3 \\left( \\hat{f}_q - f(\\hat{\\mathbf{x}}_q) \\right)^2 },$$\n       其中 $$\\hat{f}_q$$ 是使用 $$\\mathbf{I}$$ 得到的插值。\n     - 在节点上的梯度均方根误差，\n       $$E_{\\nabla} = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} \\left[ \\left( (\\mathbf{D}_x \\mathbf{f})_m - \\frac{\\partial f}{\\partial x}(\\mathbf{x}_m) \\right)^2 + \\left( (\\mathbf{D}_y \\mathbf{f})_m - \\frac{\\partial f}{\\partial y}(\\mathbf{x}_m) \\right)^2 \\right] },$$\n       其中 $$\\mathbf{f}$$ 是 $$f$$ 的节点值。\n\n6. 程序输出格式。\n   - 您的程序必须按顺序为三种情况 $$A,B,C$$ 中的每一种计算 $$[E_{\\mathrm{int}}, E_{\\nabla}]$$，并生成单行输出，其中包含这三个双元素列表的列表，形式为用方括号括起来的逗号分隔列表。例如，输出结构为\n     $$\\left[ [E_{\\mathrm{int}}^{(A)}, E_{\\nabla}^{(A)}], [E_{\\mathrm{int}}^{(B)}, E_{\\nabla}^{(B)}], [E_{\\mathrm{int}}^{(C)}, E_{\\nabla}^{(C)}] \\right].$$\n   - 不涉及物理单位，并且在您自己的推导中出现的任何角度（如果有）都必须以弧度为单位。所有数值输出必须是实值标量。\n\n您的实现必须从所述的基本定义和事实开始，遵循上述步骤，必须是完全自包含的，并且不需要用户输入。程序打印的最后一行必须是上面描述的列表，占单行，无任何附加文本。",
            "solution": "问题陈述是完整的、科学上合理且适定的。它为在参考三角形上生成扭曲与融合节点分布，并随后构建相应的高阶插值和微分算子提供了一个细致的、分步的过程。该方法的基础，包括重心坐标、多项式插值、Vandermonde 矩阵以及特定的扭曲与融合构造，在谱方法和间断伽辽金方法领域内是标准且成熟的。测试用例选择得当，可用于验证实现：测试函数为多项式且其次数可由基（$N=0, 1$）精确表示的用例，其误差应接近机器精度，从而提供有力的验证检查；而使用超越函数（$N=3$）的用例将测试该方案的近似性质。所有定义在数学上都是精确的，没有矛盾或模糊之处。因此，该问题被认为是有效的，可以构建一个解决方案。\n\n解决方案通过实现指定的算法步骤来进行。\n\n首先，对于给定的多项式次数 $N \\in \\mathbb{N}_0$，在参考二维单纯形上生成一组节点。该过程从重心坐标 $(\\lambda_1, \\lambda_2, \\lambda_3)$ 中的一个等距晶格开始。对于 $N \\ge 1$，这些点是 $\\left\\{ (\\ell_1/N, \\ell_2/N, \\ell_3/N) \\mid \\ell_i \\in \\mathbb{N}_0, \\sum \\ell_i = N \\right\\}$。对于 $N=0$，单个节点是形心 $(1/3, 1/3, 1/3)$。这些重心坐标最初通过 $\\mathbf{x}(\\lambda_1, \\lambda_2, \\lambda_3) = \\lambda_1 \\mathbf{V}_1 + \\lambda_2 \\mathbf{V}_2 + \\lambda_3 \\mathbf{V}_3$ 映射到物理坐标，其中 $\\mathbf{V}_i$ 是参考等边三角形的顶点。\n\n为了改善后续算子的插值特性和条件数，这些等距节点使用扭曲与融合技术进行位移。该技术旨在沿三角形的边复制一维 Gauss-Lobatto-Legendre (GLL) 节点分布。其核心是一维扭曲函数 $D_N(t)$。对于区间 $[0,1]$ 上的等距参数化 $t_k = k/N$（$k=0,\\dots,N$）以及相应的 GLL 参数化 $t_k^{\\mathrm{GL}}$，函数 $D_N(t)$ 被定义为次数最多为 $N$ 的唯一多项式，它对位移进行插值：$D_N(t_k) = t_k^{\\mathrm{GL}} - t_k$。对于 $N=0$ 和 $N=1$，GLL 节点和等距节点重合，因此 $D_N(t) \\equiv 0$。\n\n对于三角形中的每个点，通过投影为每条边 $i \\in \\{1,2,3\\}$ 计算一个局部参数 $t_i$。然后，沿每条边的切向量 $\\mathbf{e}_i$ 的扭曲位移计算为 $D_N(t_i)$。这些基于边的位移使用混合函数 $B_i(\\lambda_1,\\lambda_2,\\lambda_3) = (1 - \\lambda_i)^2$ 进行组合，确保扭曲在相应的边上（其中 $B_i=1$）完全激活，并在对顶点和内部平滑衰减至零。最终的扭曲物理坐标由初始仿射位置与混合扭曲位移之和给出：\n$$\n\\mathbf{x}_{\\mathrm{WB}} = \\mathbf{x}(\\lambda_1,\\lambda_2,\\lambda_3) \\;+\\; \\sum_{i=1}^{3} \\mathbf{e}_i \\, B_i(\\lambda_1,\\lambda_2,\\lambda_3) \\, D_N(t_i).\n$$\n\n第二，在建立 $M = (N+1)(N+2)/2$ 个扭曲节点 $\\{\\mathbf{x}_m\\}_{m=1}^M$ 的集合后，我们构建算子。总次数最多为 $N$ 的多项式空间 $\\mathcal{P}_N(\\mathbb{R}^2)$ 的基选择为分次单项式集合 $\\{x^i y^j : i+j \\le N\\}$。Vandermonde 矩阵 $\\mathbf{V}$ 的构造方式是其元素为 $V_{m,p} = x_m^{i_p} y_m^{j_p}$，其中 $m$ 索引节点，$p$ 索引单项式基函数。该矩阵将单项式基中多项式的系数映射到其在节点上的值。因此，其逆矩阵 $\\mathbf{V}^{-1}$ 执行反向映射：从节点值映射到单项式系数。\n\n微分算子是通过首先对单项式基函数关于 $x$ 和 $y$ 求导，在节点上求值以形成矩阵 $\\mathbf{V}_x$ 和 $\\mathbf{V}_y$，然后将得到的系数映射回节点值而得到的。这产生了微分矩阵：\n$$\n\\mathbf{D}_x = \\mathbf{V}_x \\mathbf{V}^{-1}, \\quad \\mathbf{D}_y = \\mathbf{V}_y \\mathbf{V}^{-1}.\n$$\n这些矩阵将节点上的函数值向量直接转换为同一节点上相应的偏导数值向量。\n\n类似地，可以创建一个插值矩阵 $\\mathbf{I}$，用于在任意目标点集 $\\{\\hat{\\mathbf{x}}_q\\}_{q=1}^Q$ 上求值多项式插值。这是通过在目标点上构建一个类 Vandermonde 矩阵 $\\mathbf{V}(\\{\\hat{\\mathbf{x}}_q\\})$ 并应用从系数到节点值的映射来完成的：\n$$\n\\mathbf{I} = \\mathbf{V}(\\{\\hat{\\mathbf{x}}_q\\}) \\mathbf{V}^{-1}.\n$$\n\n最后，使用指定的测试用例对实现进行验证。对于每种情况，在扭曲与混合节点上计算测试函数 $f$ 的节点值 $\\mathbf{f}$。在目标点上的插值通过 $\\hat{\\mathbf{f}} = \\mathbf{I} \\mathbf{f}$ 计算，并与精确值 $f(\\hat{\\mathbf{x}}_q)$进行比较，以求出插值误差 $E_{\\mathrm{int}}$。偏导数的节点值通过 $(\\mathbf{D}_x \\mathbf{f})$ 和 $(\\mathbf{D}_y \\mathbf{f})$ 计算，并与精确导数 $\\frac{\\partial f}{\\partial x}(\\mathbf{x}_m)$ 和 $\\frac{\\partial f}{\\partial y}(\\mathbf{x}_m)$进行比较，以计算梯度误差 $E_{\\nabla}$。对于情况 A ($N=0$) 和情况 B ($N=1$) ，其中测试函数是次数 $\\le N$ 的多项式，两个误差预计都接近于零，从而证实所构建算子的正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_jacobi\n\ndef solve():\n    \"\"\"\n    Implements the warp-and-blend node generation for a 2D simplex, constructs\n    interpolation and differentiation operators, and evaluates their accuracy\n    on a suite of test cases.\n    \"\"\"\n\n    # 1. Reference geometry, test functions, and target points.\n    V1 = np.array([-1.0, -1.0 / np.sqrt(3.0)])\n    V2 = np.array([1.0, -1.0 / np.sqrt(3.0)])\n    V3 = np.array([0.0, 2.0 / np.sqrt(3.0)])\n    \n    E1 = V3 - V2\n    E2 = V3 - V1\n    E3 = V2 - V1\n\n    target_bary = np.array([\n        [1.0/3.0, 1.0/3.0, 1.0/3.0],\n        [0.2, 0.3, 0.5],\n        [0.8, 0.1, 0.1]\n    ])\n    \n    target_phys = target_bary @ np.array([V1, V2, V3])\n\n    test_cases = [\n        (0, lambda x, y: 3.0 + 0*x, lambda x, y: (0.0, 0.0)),\n        (1, lambda x, y: 1.0 + x - 2.0*y, lambda x, y: (1.0, -2.0)),\n        (3, lambda x, y: np.exp(x) * np.sin(y), \n         lambda x, y: (np.exp(x) * np.sin(y), np.exp(x) * np.cos(y)))\n    ]\n\n    # Helper functions for algorithm steps\n    \n    def get_gll_nodes(N):\n        \"\"\"Computes 1D Gauss-Lobatto-Legendre nodes on [-1, 1].\"\"\"\n        if N == 0:\n            return np.array([0.0])\n        if N == 1:\n            return np.array([-1.0, 1.0])\n        # Interior nodes are roots of P_N'(x), which are roots of Jacobi P_{N-1}^{(1,1)}(x)\n        roots, _ = roots_jacobi(N - 1, 1, 1)\n        return np.sort(np.concatenate(([-1.0], roots, [1.0])))\n\n    def construct_warp_poly(N):\n        \"\"\"Constructs the 1D warping polynomial D_N(t).\"\"\"\n        if N == 0: # No displacement for N=0\n            return np.poly1d([0.0])\n            \n        t_equi = np.linspace(0.0, 1.0, N + 1)\n        x_gll = get_gll_nodes(N)\n        t_gll = (x_gll + 1.0) / 2.0\n        \n        displacement = t_gll - t_equi\n\n        if np.allclose(displacement, 0):\n            return np.poly1d([0.0])\n\n        # Solve Vandermonde system for polynomial coefficients\n        V = np.vander(t_equi, N + 1, increasing=True)\n        coeffs = np.linalg.solve(V, displacement)\n        return np.poly1d(coeffs[::-1])\n\n    def get_equidistant_bary_nodes(N):\n        \"\"\"Generates the equidistant barycentric lattice.\"\"\"\n        if N == 0:\n            return np.array([[1.0/3.0, 1.0/3.0, 1.0/3.0]])\n        \n        nodes = []\n        for i in range(N + 1):\n            for j in range(N - i + 1):\n                k = N - i - j\n                nodes.append([k/N, j/N, i/N]) # Order to match common literature (l3,l2,l1)\n        return np.array(nodes)\n        \n    def get_warp_and_blend_nodes(N, warp_poly):\n        \"\"\"Computes the final 2D warped node coordinates.\"\"\"\n        bary_nodes = get_equidistant_bary_nodes(N)\n        phys_nodes_equi = bary_nodes @ np.array([V1, V2, V3])\n        \n        if N == 0: # No warping for N=0 case.\n            return phys_nodes_equi\n\n        displacements = np.zeros_like(phys_nodes_equi)\n\n        for i, (l1, l2, l3) in enumerate(bary_nodes):\n            # Denominators for edge parameters\n            d1 = l2 + l3\n            d2 = l1 + l3\n            d3 = l1 + l2\n\n            # Local edge parameters, with safe division\n            t1 = l3 / d1 if d1 > 1e-12 else 0.0\n            t2 = l1 / d2 if d2 > 1e-12 else 0.0\n            t3 = l2 / d3 if d3 > 1e-12 else 0.0\n           \n            # Blending factors\n            B1 = (1 - l1)**2\n            B2 = (1 - l2)**2\n            B3 = (1 - l3)**2\n            \n            # Warping displacement\n            warp1 = E1 * B1 * warp_poly(t1)\n            warp2 = E2 * B2 * warp_poly(t2)\n            warp3 = E3 * B3 * warp_poly(t3)\n            \n            displacements[i,:] = warp1 + warp2 + warp3\n        \n        return phys_nodes_equi + displacements\n\n    def get_monomial_exponents(N):\n        \"\"\"Generates exponents (i,j) for the monomial basis x^i y^j.\"\"\"\n        exponents = []\n        for i in range(N + 1):\n            for j in range(N - i + 1):\n                exponents.append((i, j))\n        return exponents\n\n    def build_vandermonde(nodes, exponents):\n        \"\"\"Builds the 2D Vandermonde matrix.\"\"\"\n        M = len(nodes)\n        P = len(exponents)\n        V = np.zeros((M, P))\n        for m in range(M):\n            for p in range(P):\n                i, j = exponents[p]\n                V[m, p] = nodes[m, 0]**i * nodes[m, 1]**j\n        return V\n\n    def build_vandermonde_derivatives(nodes, exponents):\n        \"\"\"Builds Vandermonde matrices for partial derivatives.\"\"\"\n        M = len(nodes)\n        P = len(exponents)\n        Vx = np.zeros((M, P))\n        Vy = np.zeros((M, P))\n        for m in range(M):\n            for p in range(P):\n                i, j = exponents[p]\n                # d/dx (x^i y^j) = i * x^(i-1) y^j\n                if i > 0:\n                    Vx[m, p] = i * nodes[m, 0]**(i-1) * nodes[m, 1]**j\n                # d/dy (x^i y^j) = j * x^i y^(j-1)\n                if j > 0:\n                    Vy[m, p] = j * nodes[m, 0]**i * nodes[m, 1]**(j-1)\n        return Vx, Vy\n\n    all_results = []\n    \n    # Main loop over test cases\n    for N, f, grad_f in test_cases:\n        # 2. Node Generation\n        warp_poly = construct_warp_poly(N)\n        wb_nodes = get_warp_and_blend_nodes(N, warp_poly)\n        M = len(wb_nodes)\n        \n        # 3. Operator Construction\n        exponents = get_monomial_exponents(N)\n        V = build_vandermonde(wb_nodes, exponents)\n        V_inv = np.linalg.inv(V)\n        \n        Vx, Vy = build_vandermonde_derivatives(wb_nodes, exponents)\n        Dx = Vx @ V_inv\n        Dy = Vy @ V_inv\n\n        # 4. Error Calculation\n        f_nodal = f(wb_nodes[:, 0], wb_nodes[:, 1])\n\n        # Interpolation Error\n        V_target = build_vandermonde(target_phys, exponents)\n        I = V_target @ V_inv\n        f_interp = I @ f_nodal\n        f_exact_target = f(target_phys[:, 0], target_phys[:, 1])\n        E_int = np.sqrt(np.mean((f_interp - f_exact_target)**2))\n\n        # Gradient Error\n        dfdx_num = Dx @ f_nodal\n        dfdy_num = Dy @ f_nodal\n        \n        dfdx_exact, dfdy_exact = grad_f(wb_nodes[:, 0], wb_nodes[:, 1])\n\n        err_dx_sq = (dfdx_num - dfdx_exact)**2\n        err_dy_sq = (dfdy_num - dfdy_exact)**2\n        E_nabla = np.sqrt(np.mean(err_dx_sq + err_dy_sq))\n        \n        all_results.append([E_int, E_nabla])\n\n    # Final print statement in the exact required format.\n    print(str(all_results))\n\nsolve()\n```"
        }
    ]
}