{
    "hands_on_practices": [
        {
            "introduction": "为了从根本上理解扭曲与混合（warp-and-blend）方法的原理，我们首先从最简单的一维情形入手。这个练习将指导你手动计算一个特定阶数下的“扭曲”函数，通过这个过程，你将亲身体验等距节点如何被映射到优化后的高斯-洛巴托-勒让德（GLL）节点上。这种基础计算是掌握更复杂高维应用前的重要一步 ()。",
            "id": "3427539",
            "problem": "在单纯形上的高阶谱元和间断 Galerkin (DG) 方法中，扭曲-混合策略通过一维扭曲将等距边节点映射到 Jacobi–Gauss–Lobatto 节点，然后将其混合到单元内部，从而构造出高质量的节点集。考虑区间 $\\left[-1,1\\right]$ 上的一维边。设 $\\left\\{r_{\\mathrm{eq},j}\\right\\}_{j=0}^{N}$ 为等距节点 $r_{\\mathrm{eq},j}=-1+\\dfrac{2j}{N}$，并设 $\\left\\{r_{\\mathrm{gll},j}\\right\\}_{j=0}^{N}$ 为 Gauss–Lobatto–Legendre (GLL) 节点，其定义为端点 $\\{-1,1\\}$ 与 Legendre 多项式 $P_{N}(x)$ 导数的根所给出的内点的并集，其中 $P_{N}$ 表示 Jacobi 多项式 $P_{N}^{(0,0)}$。定义与 $\\{r_{\\mathrm{eq},j}\\}_{j=0}^{N}$ 相关联的等距 Lagrange 基 $\\{\\ell_{j}^{\\mathrm{eq}}(x)\\}_{j=0}^{N}$ 和一维扭曲\n$$\nW(x)\\;=\\;\\sum_{j=0}^{N}\\ell_{j}^{\\mathrm{eq}}(x)\\,\\big(r_{\\mathrm{gll},j}-r_{\\mathrm{eq},j}\\big).\n$$\n\n仅从 $\\left[-1,1\\right]$ 上带权函数 $(1-x)^{\\alpha}(1+x)^{\\beta}$ 的 Jacobi 多项式 $P_{n}^{(\\alpha,\\beta)}(x)$ 的标准性质出发，包括当 $(\\alpha,\\beta)=(0,0)$ 时得到 Legendre 多项式 $P_{n}(x)$，以及 GLL 内点是 $P_{N}'(x)$ 的根，对多项式阶数 $N=3$ 完成以下任务：\n\n- 通过求解 $P_{3}'(x)=0$ 显式推导 GLL 内点。\n- 构造等距节点 $\\{r_{\\mathrm{eq},j}\\}_{j=0}^{3}$。\n- 形成等距 Lagrange 多项式 $\\ell_{j}^{\\mathrm{eq}}(x)$ 并在 $x=\\dfrac{1}{2}$ 处对 $W(x)$ 求值。\n\n将您对 $W\\!\\left(\\dfrac{1}{2}\\right)$ 的最终答案以精确的封闭形式表示。无需四舍五入。不要包含单位。",
            "solution": "该问题是适定的且在科学上是合理的，设置在偏微分方程数值方法的标准框架内。所有定义和条件都是标准的和自洽的。我们对多项式阶数 $N=3$ 的情况进行求解。\n\n主要任务是推导 $N=3$ 时扭曲函数 $W(x)$ 所需的各个分量，然后在 $x=\\frac{1}{2}$ 处对其求值。扭曲函数定义为：\n$$\nW(x) = \\sum_{j=0}^{N} \\ell_{j}^{\\mathrm{eq}}(x) (r_{\\mathrm{gll},j} - r_{\\mathrm{eq},j})\n$$\n其中 $\\{r_{\\mathrm{eq},j}\\}$ 是等距节点，$\\{r_{\\mathrm{gll},j}\\}$ 是 Gauss–Lobatto–Legendre (GLL) 节点，$\\{\\ell_{j}^{\\mathrm{eq}}(x)\\}$ 是与等距节点相关联的 Lagrange 基多项式。\n\n**步骤1：确定 Legendre 多项式 $P_3(x)$ 及其导数**\n\nLegendre 多项式 $P_n(x)$ 是 Jacobi 多项式 $P_n^{(\\alpha,\\beta)}(x)$ 在 $\\alpha=0$ 和 $\\beta=0$ 时的特例。满足标准归一化 $P_n(1)=1$ 的前几个 Legendre 多项式是：\n$P_0(x) = 1$\n$P_1(x) = x$\n$P_2(x) = \\frac{1}{2}(3x^2 - 1)$\n我们可以使用 Bonnet 递推关系找到 $P_3(x)$：$(n+1)P_{n+1}(x) = (2n+1)xP_n(x) - nP_{n-1}(x)$。对于 $n=2$：\n$$\n(2+1)P_3(x) = (2(2)+1)xP_2(x) - 2P_1(x)\n$$\n$$\n3P_3(x) = 5x \\left( \\frac{1}{2}(3x^2 - 1) \\right) - 2x = \\frac{15}{2}x^3 - \\frac{5}{2}x - 2x = \\frac{15}{2}x^3 - \\frac{9}{2}x\n$$\n$$\nP_3(x) = \\frac{1}{3} \\left( \\frac{15}{2}x^3 - \\frac{9}{2}x \\right) = \\frac{1}{2}(5x^3 - 3x)\n$$\n$P_3(x)$ 的导数是：\n$$\nP_3'(x) = \\frac{d}{dx} \\left( \\frac{1}{2}(5x^3 - 3x) \\right) = \\frac{1}{2}(15x^2 - 3)\n$$\n\n**步骤2：推导 Gauss–Lobatto–Legendre (GLL) 节点**\n\n对于 $N=3$，GLL 节点 $\\{r_{\\mathrm{gll},j}\\}_{j=0}^3$ 由区间 $[-1, 1]$ 的端点和 $P_3'(x)=0$ 的根组成。我们求解内点：\n$$\nP_3'(x) = 0 \\implies \\frac{1}{2}(15x^2 - 3) = 0 \\implies 15x^2 = 3 \\implies x^2 = \\frac{3}{15} = \\frac{1}{5}\n$$\n根是 $x = \\pm\\frac{1}{\\sqrt{5}}$。\n完整的 GLL 节点集，按升序排列，是：\n$r_{\\mathrm{gll},0} = -1$\n$r_{\\mathrm{gll},1} = -\\frac{1}{\\sqrt{5}}$\n$r_{\\mathrm{gll},2} = \\frac{1}{\\sqrt{5}}$\n$r_{\\mathrm{gll},3} = 1$\n\n**步骤3：构造等距节点**\n\n对于 $N=3$，等距节点由 $r_{\\mathrm{eq},j} = -1 + \\frac{2j}{3}$ 给出，其中 $j \\in \\{0, 1, 2, 3\\}$：\n$r_{\\mathrm{eq},0} = -1 + \\frac{2(0)}{3} = -1$\n$r_{\\mathrm{eq},1} = -1 + \\frac{2(1)}{3} = -\\frac{1}{3}$\n$r_{\\mathrm{eq},2} = -1 + \\frac{2(2)}{3} = \\frac{1}{3}$\n$r_{\\mathrm{eq},3} = -1 + \\frac{2(3)}{3} = 1$\n等距节点集是 $\\{-1, -\\frac{1}{3}, \\frac{1}{3}, 1\\}$。\n\n**步骤4：计算节点差**\n\n我们计算差值 $\\Delta r_j = r_{\\mathrm{gll},j} - r_{\\mathrm{eq},j}$：\n$\\Delta r_0 = r_{\\mathrm{gll},0} - r_{\\mathrm{eq},0} = -1 - (-1) = 0$\n$\\Delta r_1 = r_{\\mathrm{gll},1} - r_{\\mathrm{eq},1} = -\\frac{1}{\\sqrt{5}} - (-\\frac{1}{3}) = \\frac{1}{3} - \\frac{1}{\\sqrt{5}}$\n$\\Delta r_2 = r_{\\mathrm{gll},2} - r_{\\mathrm{eq},2} = \\frac{1}{\\sqrt{5}} - \\frac{1}{3}$\n$\\Delta r_3 = r_{\\mathrm{gll},3} - r_{\\mathrm{eq},3} = 1 - 1 = 0$\n\n**步骤5：在 $x=\\frac{1}{2}$ 处计算等距 Lagrange 基多项式的值**\n\nLagrange 基多项式 $\\ell_{j}^{\\mathrm{eq}}(x)$ 定义为 $\\ell_{j}^{\\mathrm{eq}}(x) = \\prod_{k=0, k\\neq j}^{3} \\frac{x-r_{\\mathrm{eq},k}}{r_{\\mathrm{eq},j}-r_{\\mathrm{eq},k}}$。我们需要在 $x=\\frac{1}{2}$ 处计算它们的值。\n等距节点是 $\\{r_0, r_1, r_2, r_3\\} = \\{-1, -\\frac{1}{3}, \\frac{1}{3}, 1\\}$。\n\n对于 $j=0$: $\\ell_{0}^{\\mathrm{eq}}(\\frac{1}{2}) = \\frac{(\\frac{1}{2}-(-\\frac{1}{3}))(\\frac{1}{2}-\\frac{1}{3})(\\frac{1}{2}-1)}{(-1-(-\\frac{1}{3}))(-1-\\frac{1}{3})(-1-1)} = \\frac{(\\frac{5}{6})(\\frac{1}{6})(-\\frac{1}{2})}{(-\\frac{2}{3})(-\\frac{4}{3})(-2)} = \\frac{-5/72}{-16/9} = \\frac{5}{128}$。\n\n对于 $j=1$: $\\ell_{1}^{\\mathrm{eq}}(\\frac{1}{2}) = \\frac{(\\frac{1}{2}-(-1))(\\frac{1}{2}-\\frac{1}{3})(\\frac{1}{2}-1)}{(-\\frac{1}{3}-(-1))(-\\frac{1}{3}-\\frac{1}{3})(-\\frac{1}{3}-1)} = \\frac{(\\frac{3}{2})(\\frac{1}{6})(-\\frac{1}{2})}{(\\frac{2}{3})(-\\frac{2}{3})(-\\frac{4}{3})} = \\frac{-1/8}{16/27} = -\\frac{27}{128}$。\n\n对于 $j=2$: $\\ell_{2}^{\\mathrm{eq}}(\\frac{1}{2}) = \\frac{(\\frac{1}{2}-(-1))(\\frac{1}{2}-(-\\frac{1}{3}))(\\frac{1}{2}-1)}{(\\frac{1}{3}-(-1))(\\frac{1}{3}-(-\\frac{1}{3}))(\\frac{1}{3}-1)} = \\frac{(\\frac{3}{2})(\\frac{5}{6})(-\\frac{1}{2})}{(\\frac{4}{3})(\\frac{2}{3})(-\\frac{2}{3})} = \\frac{-5/8}{-16/27} = \\frac{135}{128}$。\n\n对于 $j=3$: $\\ell_{3}^{\\mathrm{eq}}(\\frac{1}{2}) = \\frac{(\\frac{1}{2}-(-1))(\\frac{1}{2}-(-\\frac{1}{3}))(\\frac{1}{2}-\\frac{1}{3})}{(1-(-1))(1-(-\\frac{1}{3}))(1-\\frac{1}{3})} = \\frac{(\\frac{3}{2})(\\frac{5}{6})(\\frac{1}{6})}{(2)(\\frac{4}{3})(\\frac{2}{3})} = \\frac{5/24}{16/9} = \\frac{15}{128}$。\n\n**步骤6：计算 $W(\\frac{1}{2})$**\n\n现在我们将计算出的各分量代入 $W(x)$ 在 $x=\\frac{1}{2}$ 处的定义中：\n$$\nW(\\frac{1}{2}) = \\sum_{j=0}^{3} \\ell_{j}^{\\mathrm{eq}}(\\frac{1}{2}) \\Delta r_j = \\ell_{0}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_0 + \\ell_{1}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_1 + \\ell_{2}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_2 + \\ell_{3}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_3\n$$\n由于 $\\Delta r_0 = 0$ 和 $\\Delta r_3 = 0$，表达式简化为：\n$$\nW(\\frac{1}{2}) = \\ell_{1}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_1 + \\ell_{2}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_2\n$$\n代入计算出的值：\n$$\nW(\\frac{1}{2}) = \\left(-\\frac{27}{128}\\right)\\left(\\frac{1}{3} - \\frac{1}{\\sqrt{5}}\\right) + \\left(\\frac{135}{128}\\right)\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right)\n$$\n我们可以将 $(\\frac{1}{\\sqrt{5}} - \\frac{1}{3})$ 作为公因式提取出来：\n$$\nW(\\frac{1}{2}) = \\left(\\frac{27}{128}\\right)\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right) + \\left(\\frac{135}{128}\\right)\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right)\n$$\n$$\nW(\\frac{1}{2}) = \\left(\\frac{27}{128} + \\frac{135}{128}\\right)\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right) = \\left(\\frac{162}{128}\\right)\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right)\n$$\n简化分数 $\\frac{162}{128} = \\frac{81}{64}$：\n$$\nW(\\frac{1}{2}) = \\frac{81}{64}\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right) = \\frac{81}{64\\sqrt{5}} - \\frac{81}{64 \\cdot 3} = \\frac{81\\sqrt{5}}{64 \\cdot 5} - \\frac{27}{64} = \\frac{81\\sqrt{5}}{320} - \\frac{27}{64}\n$$\n为了合并这些项，我们使用公分母 $320$：\n$$\nW(\\frac{1}{2}) = \\frac{81\\sqrt{5}}{320} - \\frac{27 \\cdot 5}{64 \\cdot 5} = \\frac{81\\sqrt{5}}{320} - \\frac{135}{320} = \\frac{81\\sqrt{5} - 135}{320}\n$$\n提取 $81$ 和 $135$ 的最大公约数 $27$：\n$$\nW(\\frac{1}{2}) = \\frac{27(3\\sqrt{5} - 5)}{320}\n$$\n这就是最终的精确封闭形式答案。",
            "answer": "$$\n\\boxed{\\frac{27(3\\sqrt{5} - 5)}{320}}\n$$"
        },
        {
            "introduction": "在理解了一维扭曲函数的基本计算后，下一步是将其推广为一种通用的算法。这个编程练习要求你为任意多项式阶数 $N$ 实现一维扭曲函数的构造，这需要运用牛顿法求根和重心拉格朗日插值等关键数值技术。通过这个实践 ()，你将把理论概念转化为稳定且可复用的代码，这是计算科学中的一项核心技能。",
            "id": "3427542",
            "problem": "实现一个程序，该程序构建用于谱方法和间断 Galerkin 方法中单纯形上节点分布的扭曲-混合策略 (warp-and-blend strategy) 所使用的一维扭曲函数。一维扭曲定义如下：对于一个固定的插值次数 $N \\in \\mathbb{N}$，考虑区间 $[-1,1]$ 上的等距节点 $r^{\\mathrm{eq}}_j = -1 + \\dfrac{2j}{N}$（其中 $j=0,1,\\dots,N$），以及 Gauss–Lobatto–Legendre 节点 $r^{\\mathrm{gl}}_j$。$r^{\\mathrm{gl}}_j$ 定义为端点 $\\{-1,1\\}$ 与 $(1-x^2)P'_N(x)$ 的 $N-1$ 个内部根的并集，其中 $P_N(x)$ 表示 $N$ 次勒让德多项式。定义节点位移 $\\Delta_j = r^{\\mathrm{gl}}_j - r^{\\mathrm{eq}}_j$（其中 $j=0,1,\\dots,N$）。一维扭曲函数 $W_N(r)$ 是满足 $W_N(r^{\\mathrm{eq}}_j) = \\Delta_j$（对所有 $j=0,1,\\dots,N$）的唯一的、次数至多为 $N$ 的多项式。这个 $W_N(r)$ 稍后将用作高维扭曲-混合构造中的边扭曲分量。\n\n您的程序必须从第一性原理出发构建 $W_N(r)$，仅使用以下基本定义和事实：\n- 勒让德多项式 $\\{P_n(x)\\}_{n=0}^\\infty$ 由三项递推关系定义：$P_0(x)=1$，$P_1(x)=x$，以及当 $n \\ge 2$ 时，$P_n(x) = \\dfrac{(2n-1)xP_{n-1}(x) - (n-1)P_{n-2}(x)}{n}$。\n- 次数为 $N$ 的 Gauss–Lobatto–Legendre 节点由 $x=-1$，$x=1$ 以及 $(1-x^2)P'_N(x)$ 在 $(-1,1)$ 内的 $N-1$ 个内部根组成。\n- 经过节点 $\\{x_j\\}_{j=0}^N$ 且带有数据 $\\{y_j\\}_{j=0}^N$ 的唯一的、次数至多为 $N$ 的插值多项式由满足 $\\ell_j(x_k)=\\delta_{jk}$ 的拉格朗日基 $\\{\\ell_j(x)\\}_{j=0}^N$ 来刻画。您必须实现该插值多项式在任意 $x \\in [-1,1]$ 处的算法上稳定的求值方法。\n\n从这些基础出发，推导并实现：\n1. 一个鲁棒的例程，通过对一个避免了在 $x=\\pm 1$ 处出现数值问题的平滑等效系统应用牛顿法，求解 $(1-x^2)P'_N(x)$ 的内部根，从而计算出 $N+1$ 个 Gauss–Lobatto–Legendre 节点。\n2. $[-1,1]$ 上的等距节点以及位移 $\\Delta_j$。\n3. 一个基于在等距节点上建立并使用数据 $\\Delta_j$ 的拉格朗日插值的 $W_N(r)$ 求值例程。您的求值过程必须正确处理当 $r=r^{\\mathrm{eq}}_j$（对于某个 $j$）的情况。\n\n角度单位不相关。此问题中没有物理单位。\n\n测试套件：\n您必须评估以下五个测试用例，每个用例返回一个实数：\n- 测试 1：$N=1$，评估 $|W_N(0)|$。\n- 测试 2：$N=5$，通过计算 $\\max_{0\\le j \\le N} \\left| W_N\\!\\left(r^{\\mathrm{eq}}_j\\right) - \\Delta_j \\right|$ 来验证在等距节点上的插值属性。\n- 测试 3：$N=8$，计算奇对称性残差 $\\max_{x \\in \\{-0.9,-0.31,0.17,0.53,0.9\\}} \\left| W_N(x) + W_N(-x) \\right|$。\n- 测试 4：$N=10$，端点检查 $\\max\\left( |W_N(-1)|,\\ |W_N(1)| \\right)$。\n- 测试 5：$N=7$，中心值 $|W_N(0)|$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，顺序与上述五个测试的顺序相同。例如，它必须打印形如 $[r_1,r_2,r_3,r_4,r_5]$ 的一行，其中每个 $r_k$ 是您的程序为相应测试计算出的浮点数。",
            "solution": "用户希望构造用于谱方法和间断 Galerkin 方法的一维扭曲函数 $W_N(r)$，并针对几个测试用例对其进行求值。该解决方案要求根据问题陈述中的定义，从第一性原理出发实现必要的组件。这涉及三个主要步骤：\n1.  计算 Gauss-Lobatto-Legendre (GLL) 节点。\n2.  定义节点位移。\n3.  使用稳定的多项式插值构造并求值扭曲函数。\n\n### 步骤 1：勒让德多项式及其导数\n\n这个问题的基础是勒让德多项式 $P_N(x)$。我们不仅需要多项式本身，还需要它的一阶和二阶导数，以便使用牛顿法找到 GLL 节点。多项式由三项递推关系定义：\n$P_0(x) = 1$\n$P_1(x) = x$\n$$P_n(x) = \\frac{(2n-1)xP_{n-1}(x) - (n-1)P_{n-2}(x)}{n}, \\quad \\text{对于 } n \\ge 2$$\n\n通过对这个递推关系关于 $x$ 求导，我们可以得到导数 $P'_n(x)$ 和 $P''_n(x)$ 的递推关系：\n$$n P'_n(x) = (2n-1)P_{n-1}(x) + (2n-1)xP'_{n-1}(x) - (n-1)P'_{n-2}(x)$$\n$$n P''_n(x) = 2(2n-1)P'_{n-1}(x) + (2n-1)xP''_{n-1}(x) - (n-1)P''_{n-2}(x)$$\n\n一个单一的例程可以通过从 $n=0$ 和 $n=1$ 的基本情况开始，并迭代应用这些公式直到所需的次数 $N$，来计算 $(P_N(x), P'_N(x), P''_N(x))$。对于测试套件所需的小次数（$N \\leq 10$），此方法在数值上是稳定且高效的。\n\n### 步骤 2：Gauss–Lobatto–Legendre (GLL) 节点\n\n对于一个 $N$ 次多项式逼近，GLL 节点 $r^{\\mathrm{gl}}_j$ 是多项式 $(1-x^2)P'_N(x)$ 的 $N+1$ 个根。这些根包括固定的端点 $x=\\pm 1$ 和 $P'_N(x)$ 在区间 $(-1, 1)$ 内的 $N-1$ 个内部根。\n\n为了找到这些内部根，我们对函数 $f(x) = P'_N(x)$ 应用牛顿法。迭代更新法则是：\n$$x_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)} = x_k - \\frac{P'_N(x_k)}{P''_N(x_k)}$$\n这需要 $P'_N(x)$ 和 $P''_N(x)$ 的值，这些值由步骤 1 中的函数提供。\n\n为使牛顿法收敛到正确的根，好的初始猜测至关重要。$P'_N(x)$ 的 $N-1$ 个内部根是 $P_N(x)$ 的极值点。可以使用众所周知的对这些位置的近似值。对于第 $j$ 个内部根（按降序排列）的初始猜测，一个可靠的选择是 $x_j^{(0)} = \\cos\\left(\\frac{j\\pi}{N}\\right)$，其中 $j=1, 2, \\dots, N-1$。\n\n然后，将这 $N-1$ 个计算出的根与端点 $-1$ 和 $1$ 结合，并按升序排序，就构成了完整的 $N+1$ 个 GLL 节点集。我们用 $\\{r^{\\mathrm{gl}}_j\\}_{j=0}^N$ 表示排序后的节点。\n\n### 步骤 3：扭曲函数的构造与求值\n\n扭曲函数 $W_N(r)$ 是一个次数至多为 $N$ 的多项式，它将等距节点映射到 GLL 节点。它由插值条件定义：\n$$W_N(r^{\\mathrm{eq}}_j) = \\Delta_j, \\quad j=0, 1, \\dots, N$$\n其中节点和位移为：\n-   **等距节点**：$r^{\\mathrm{eq}}_j = -1 + \\frac{2j}{N}$\n-   **节点位移**：$\\Delta_j = r^{\\mathrm{gl}}_j - r^{\\mathrm{eq}}_j$\n\n为了以数值稳定的方式求值这个插值多项式，我们使用重心拉格朗日插值公式（第二形式）：\n$$W_N(r) = \\frac{\\displaystyle\\sum_{j=0}^{N} \\frac{w_j}{r - r^{\\mathrm{eq}}_j} \\Delta_j}{\\displaystyle\\sum_{j=0}^{N} \\frac{w_j}{r - r^{\\mathrm{eq}}_j}}$$\n这个公式对于任何节点的选择都特别稳定，避免了使用单项式基表示时可能发生的灾难性抵消。\n\n对于等距节点，重心权重 $w_j$ 可以选择为：\n$$w_j = (-1)^j \\binom{N}{j}$$\n这些权重可以通过递推式 $w_0 = 1$ 和 $w_{j+1} = -w_j \\frac{N-j}{j+1}$（$j=0, \\dots, N-1$）高效计算。\n\n实现的一个关键部分是处理求值点 $r$ 与某个插值节点 $r^{\\mathrm{eq}}_k$ 重合的情况。在这种情况下，公式会变成 $0/0$ 的不定形式。根据插值的定义，如果 $r = r^{\\mathrm{eq}}_k$，函数值就是 $W_N(r^{\\mathrm{eq}}_k) = \\Delta_k$。求值例程必须检查这种情况，以避免除以零并返回正确的值。\n\n### 测试用例分析\n\n对该函数性质的理论分析揭示了测试用例的预期结果：\n-   **对称性**：GLL 节点和等距节点都关于原点对称（$r_{N-j} = -r_j$）。这意味着位移是反对称的：$\\Delta_{N-j} = -\\Delta_j$。在对称点上插值反对称数据的多项式必须是奇函数，即对所有 $r$ 都有 $W_N(r) = -W_N(-r)$。\n-   **测试 1 ($N=1, |W_1(0)|$)**：对于 $N=1$，$r^{\\mathrm{gl}} = r^{\\mathrm{eq}} = \\{-1, 1\\}$，所以 $\\Delta = \\{0, 0\\}$。插值多项式为 $W_1(r) \\equiv 0$，因此 $|W_1(0)| = 0$。实际上，对于 $N \\le 2$，GLL 节点是等距的，所以 $W_N(r) \\equiv 0$。\n-   **测试 2 ($N=5, \\max|W_5(r^{\\mathrm{eq}}_j) - \\Delta_j|$)**：这测试了基本的插值属性。根据构造，$W_5(r^{\\mathrm{eq}}_j) = \\Delta_j$。结果应为零，直到机器精度。\n-   **测试 3 ($N=8, \\max|W_8(x) + W_8(-x)|$)**：这测试了奇对称性。因为 $W_8(r)$ 是一个奇函数，$W_8(x) + W_8(-x) = 0$。结果应为零，直到机器精度。\n-   **测试 4 ($N=10, \\max(|W_{10}(-1)|, |W_{10}(1)|)$)**：这测试了边界值。端点 $r^{\\mathrm{eq}}_0=-1$ 和 $r^{\\mathrm{eq}}_{10}=1$ 是插值节点。$W_{10}(-1) = \\Delta_0 = r^{\\mathrm{gl}}_0 - r^{\\mathrm{eq}}_0 = -1 - (-1) = 0$。类似地，$W_{10}(1) = \\Delta_{10} = 1 - 1 = 0$。结果必须为零。\n-   **测试 5 ($N=7, |W_7(0)|$)**：由于 $W_7(r)$ 是一个奇函数，$W_7(0) = -W_7(-0) \\implies 2W_7(0)=0 \\implies W_7(0)=0$。结果为零。\n\n所有测试用例都被设计为产生零的结果，从而为数值实现的正确性和稳定性提供了严格的验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of constructing and evaluating the 1D warp function.\n    \"\"\"\n\n    class WarpAndBlend1D:\n        \"\"\"\n        Constructs and evaluates the 1D warp function W_N(r).\n        \"\"\"\n        def __init__(self, N: int):\n            if not isinstance(N, int) or N  1:\n                raise ValueError(\"Degree N must be a positive integer.\")\n            \n            self.N = N\n            self.r_eq = np.linspace(-1.0, 1.0, N + 1)\n            \n            if N > 0:\n                self.r_gl = self._compute_gll_nodes(N)\n            else: # N=0 case, though problem implies N>=1\n                self.r_gl = np.array([-1.0])\n\n            # Ensure GLL nodes are correctly sorted for displacement calculation\n            self.r_gl.sort()\n\n            self.delta = self.r_gl - self.r_eq\n            self.weights = self._compute_barycentric_weights(N)\n\n        def _legendre_and_derivs(self, N: int, x: float):\n            \"\"\"Computes P_N(x), P'_N(x), and P''_N(x) via recurrence.\"\"\"\n            if N == 0:\n                return 1.0, 0.0, 0.0\n            \n            p_nm2, p_prime_nm2, p_double_prime_nm2 = 1.0, 0.0, 0.0\n            p_nm1, p_prime_nm1, p_double_prime_nm1 = x, 1.0, 0.0\n            \n            if N == 1:\n                return p_nm1, p_prime_nm1, p_double_prime_nm1\n\n            for n in range(2, N + 1):\n                # Recurrence for P_n(x)\n                p_n = ((2 * n - 1) * x * p_nm1 - (n - 1) * p_nm2) / n\n                \n                # Recurrence for P'_n(x)\n                p_prime_n = ((2 * n - 1) * (p_nm1 + x * p_prime_nm1) - (n - 1) * p_prime_nm2) / n\n                \n                # Recurrence for P''_n(x)\n                p_double_prime_n = ((2 * n - 1) * (2 * p_prime_nm1 + x * p_double_prime_nm1) - (n - 1) * p_double_prime_nm2) / n\n                \n                p_nm2, p_prime_nm2, p_double_prime_nm2 = p_nm1, p_prime_nm1, p_double_prime_nm1\n                p_nm1, p_prime_nm1, p_double_prime_nm1 = p_n, p_prime_n, p_double_prime_n\n            \n            return p_nm1, p_prime_nm1, p_double_prime_nm1\n\n        def _compute_gll_nodes(self, N: int):\n            \"\"\"Computes the N+1 Gauss-Lobatto-Legendre nodes for degree N.\"\"\"\n            if N == 1:\n                return np.array([-1.0, 1.0])\n\n            nodes = np.zeros(N + 1)\n            nodes[0], nodes[N] = -1.0, 1.0\n            \n            # Find N-1 interior roots of P'_N(x) using Newton's method\n            for j in range(1, N):\n                # Initial guess for the j-th root\n                x = np.cos(j * np.pi / N)\n                \n                # Newton's method iteration\n                for _ in range(20): # 20 iterations is more than enough\n                    _, p_prime, p_double_prime = self._legendre_and_derivs(N, x)\n                    if abs(p_prime)  1e-15:\n                        break\n                    dx = p_prime / p_double_prime\n                    x -= dx\n                    if abs(dx)  1e-15:\n                        break\n                nodes[j] = x\n            \n            return nodes\n\n        def _compute_barycentric_weights(self, N: int):\n            \"\"\"Computes barycentric weights for equidistant nodes.\"\"\"\n            weights = np.zeros(N + 1)\n            weights[0] = 1.0\n            for j in range(N):\n                weights[j + 1] = -weights[j] * (N - j) / (j + 1)\n            return weights\n\n        def evaluate(self, r_eval):\n            \"\"\"Evaluates the warp function W_N(r) at given points r.\"\"\"\n            r_eval = np.atleast_1d(r_eval)\n            results = np.zeros_like(r_eval, dtype=float)\n            \n            for i, r in enumerate(r_eval):\n                # Check if evaluation point is close to an interpolation node\n                is_node = np.isclose(r, self.r_eq)\n                if np.any(is_node):\n                    idx = np.where(is_node)[0][0]\n                    results[i] = self.delta[idx]\n                else:\n                    # Use barycentric interpolation formula\n                    terms = self.weights / (r - self.r_eq)\n                    numerator = np.sum(terms * self.delta)\n                    denominator = np.sum(terms)\n                    if denominator == 0:\n                        results[i] = 0.0 # Should not happen if check above is robust\n                    else:\n                        results[i] = numerator / denominator\n            \n            return results\n\n    # Define the test cases from the problem statement.\n    test_specs = [\n        {'N': 1, 'type': 'eval', 'points': [0.0], 'op': 'abs'},\n        {'N': 5, 'type': 'interp_check'},\n        {'N': 8, 'type': 'symmetry_check', 'points': [-0.9, -0.31, 0.17, 0.53, 0.9]},\n        {'N': 10, 'type': 'endpoint_check'},\n        {'N': 7, 'type': 'eval', 'points': [0.0], 'op': 'abs'}\n    ]\n\n    results = []\n    # Using a cache for constructed objects to avoid re-computation\n    warp_objects = {}\n\n    for spec in test_specs:\n        N = spec['N']\n        if N not in warp_objects:\n            warp_objects[N] = WarpAndBlend1D(N)\n        \n        w = warp_objects[N]\n        \n        if spec['type'] == 'eval':\n            val = w.evaluate(spec['points'])[0]\n            if spec['op'] == 'abs':\n                results.append(np.abs(val))\n        \n        elif spec['type'] == 'interp_check':\n            vals_at_nodes = w.evaluate(w.r_eq)\n            error = np.max(np.abs(vals_at_nodes - w.delta))\n            results.append(error)\n\n        elif spec['type'] == 'symmetry_check':\n            x = np.array(spec['points'])\n            residual = np.max(np.abs(w.evaluate(x) + w.evaluate(-x)))\n            results.append(residual)\n\n        elif spec['type'] == 'endpoint_check':\n            val = np.max(np.abs(w.evaluate(np.array([-1.0, 1.0]))))\n            results.append(val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将一维的扭曲概念应用到二维的三角形单元上，展示扭曲与混合方法的完整威力。这个综合性练习 () 不仅指导你如何在三角形上生成高质量的节点分布，更重要的是，它揭示了这些节点的最终目的：构建精确稳定的插值和微分算子。这些算子是高阶数值方法求解偏微分方程的核心引擎。",
            "id": "3427543",
            "problem": "构造一个完整、可运行的程序，该程序针对参考二维单纯形（三角形），实现一种“扭曲与混合”(warp-and-blend)节点分布，然后使用这些节点来构建适用于高阶谱方法和间断 Galerkin 方法的插值和微分算子。程序必须仅依赖于基本定义和经过充分检验的事实，并且不得假定目标算子有任何预先推导的闭式解。\n\n请使用以下基本定义和要求。\n\n1. 参考几何、重心坐标和边。\n   - 考虑具有以下顶点的等边参考三角形：\n     $$\\mathbf{V}_1 = (-1, -1/\\sqrt{3}), \\quad \\mathbf{V}_2 = (1, -1/\\sqrt{3}), \\quad \\mathbf{V}_3 = (0, 2/\\sqrt{3}).$$\n   - 对于三角形内的任意点，设其重心坐标为 $$\\lambda_1, \\lambda_2, \\lambda_3 \\ge 0, \\quad \\lambda_1 + \\lambda_2 + \\lambda_3 = 1,$$ 仿射映射为\n     $$\\mathbf{x}(\\lambda_1,\\lambda_2,\\lambda_3) = \\lambda_1 \\mathbf{V}_1 + \\lambda_2 \\mathbf{V}_2 + \\lambda_3 \\mathbf{V}_3.$$\n   - 顶点所对的边表示为：\n     $$\\text{edge } 1: \\overline{\\mathbf{V}_2 \\mathbf{V}_3}, \\quad \\text{edge } 2: \\overline{\\mathbf{V}_1 \\mathbf{V}_3}, \\quad \\text{edge } 3: \\overline{\\mathbf{V}_1 \\mathbf{V}_2}.$$\n\n2. 一维 Gauss–Lobatto–Legendre 节点和边参数的弯曲。\n   - 对于多项式次数 $$N \\in \\mathbb{N}_0,$$ 通过参数 $$t \\in [0,1]$$ 定义边上的一维等距参数化，其等距节点为 $$t_k = k/N$$（对于 $$k=0,\\dots,N$$）（对于 $$N=0,$$，将唯一的节点解释为边的中点）。\n   - 令 $$x^{\\mathrm{GL}}_k \\in [-1,1]$$（对于 $$k=0,\\dots,N$$）表示 Gauss–Lobatto–Legendre 节点，即该集合包含端点 $$-1, 1$$，内部节点是 $$N$$ 次 Legendre 多项式导数的根。定义相应的边参数 $$t^{\\mathrm{GL}}_k = (x^{\\mathrm{GL}}_k + 1)/2 \\in [0,1].$$\n   - 定义一维弯曲函数 $$D_N(t)$$ 为满足插值条件的至多 $$N$$ 次的唯一多项式：\n     $$D_N(t_k) = t^{\\mathrm{GL}}_k - t_k, \\quad k=0,\\dots,N.$$\n     该函数编码了沿一条边移动等距参数以达到 Gauss–Lobatto–Legendre 间距所需的位移。\n\n3. 三角形上的“扭曲与混合”(warp-and-blend)节点。\n   - 从等距的重心晶格节点开始\n     $$\\mathcal{L}_N = \\left\\{ (\\lambda_1,\\lambda_2,\\lambda_3) \\,\\middle|\\, \\lambda_i = \\frac{\\ell_i}{N}, \\ \\ell_i \\in \\mathbb{N}_0, \\ \\ell_1+\\ell_2+\\ell_3=N \\right\\}$$\n     对于 $$N \\ge 1$$，而对于 $$N=0$$ 使用形心处的单个节点 $$\\lambda_1=\\lambda_2=\\lambda_3=1/3.$$\n   - 对于每个具有重心坐标 $$\\lambda_1,\\lambda_2,\\lambda_3$$ 的节点，通过投影到每条边上来为其定义一个局部边参数：\n     $$t_1 = \\frac{\\lambda_3}{\\lambda_2+\\lambda_3} \\ \\text{on edge } 1 \\ (\\text{if } \\lambda_2+\\lambda_30), \\quad\n       t_2 = \\frac{\\lambda_1}{\\lambda_1+\\lambda_3} \\ \\text{on edge } 2 \\ (\\text{if } \\lambda_1+\\lambda_30), \\quad\n       t_3 = \\frac{\\lambda_2}{\\lambda_1+\\lambda_2} \\ \\text{on edge } 3 \\ (\\text{if } \\lambda_1+\\lambda_20),$$\n     并在相应分母为零时将 $$t_i=0$$ 解释。\n   - 对每条边 $$i \\in \\{1,2,3\\}$$ 定义二次混合因子 $$B_i(\\lambda_1,\\lambda_2,\\lambda_3)$$ 为\n     $$B_i(\\lambda_1,\\lambda_2,\\lambda_3) = (1 - \\lambda_i)^2.$$\n     该因子在边 $$i$$ 上等于 $$1$$，在接近对顶点时趋于 $$0$$，并在三角形内部平滑衰减。\n   - 设边切向向量为\n     $$\\mathbf{e}_1 = \\mathbf{V}_3 - \\mathbf{V}_2, \\quad \\mathbf{e}_2 = \\mathbf{V}_3 - \\mathbf{V}_1, \\quad \\mathbf{e}_3 = \\mathbf{V}_2 - \\mathbf{V}_1.$$\n     然后通过以下公式获得扭曲与混合后的物理坐标：\n     $$\\mathbf{x}_{\\mathrm{WB}} = \\mathbf{x}(\\lambda_1,\\lambda_2,\\lambda_3) \\;+\\; \\mathbf{e}_1 \\, B_1 \\, D_N(t_1) \\;+\\; \\mathbf{e}_2 \\, B_2 \\, D_N(t_2) \\;+\\; \\mathbf{e}_3 \\, B_3 \\, D_N(t_3).$$\n     该构造在每条边 $$i$$ 上产生 Gauss–Lobatto–Legendre 间距，因为在边 $$i$$ 上 $$B_i=1$$ 且 $$D_N(t)$$ 实现了所需的一维重参数化，而由于 $$D_N(0)=D_N(1)=0$$，来自其他边的贡献在端点处消失。\n\n4. 多项式基、插值和微分算子。\n   - 令 $$\\mathcal{P}_N(\\mathbb{R}^2)$$ 表示 $$x,y$$ 中总次数至多为 $$N$$ 的多项式空间。\n   - 使用分级单项式集合 $$\\{ x^i y^j : i \\ge 0, j \\ge 0, i+j \\le N \\}$$ 作为基。如果有 $$M = (N+1)(N+2)/2$$ 个节点 $$\\{\\mathbf{x}_m\\}_{m=1}^M$$，构造一个方阵 Vandermonde 矩阵 $$\\mathbf{V} \\in \\mathbb{R}^{M \\times M}$$，其元素为\n     $$V_{m,p} = x_m^{i_p} \\, y_m^{j_p},$$\n     其中 $$p$$ 索引了单项式指数 $$\\{(i_p,j_p)\\}.$$\n   - 在任意目标点集 $$\\{\\hat{\\mathbf{x}}_q\\}_{q=1}^{Q}$$ 上求值的节点 Lagrange 基由插值矩阵捕获\n     $$\\mathbf{I} = \\mathbf{V}(\\{\\hat{\\mathbf{x}}_q\\}) \\, \\mathbf{V}^{-1},$$\n     其中 $$\\mathbf{V}(\\{\\hat{\\mathbf{x}}_q\\})$$ 是在目标点上构建的 Vandermonde 矩阵。\n   - 将标量场 $$f$$ 的节点值映射到其偏导数节点值的微分矩阵 $$\\mathbf{D}_x, \\mathbf{D}_y \\in \\mathbb{R}^{M \\times M}$$ 通过对单项式基求导并投影回节点基得到：\n     $$\\mathbf{D}_x = \\mathbf{V}_x \\, \\mathbf{V}^{-1}, \\quad \\mathbf{D}_y = \\mathbf{V}_y \\, \\mathbf{V}^{-1},$$\n     其元素为\n     $$\\left(\\mathbf{V}_x\\right)_{m,p} = \\frac{\\partial}{\\partial x}\\left(x^{i_p} y^{j_p}\\right)\\Big|_{\\mathbf{x}_m} = i_p \\, x_m^{i_p-1} y_m^{j_p}, \\quad\n       \\left(\\mathbf{V}_y\\right)_{m,p} = \\frac{\\partial}{\\partial y}\\left(x^{i_p} y^{j_p}\\right)\\Big|_{\\mathbf{x}_m} = j_p \\, x_m^{i_p} y_m^{j_p-1},$$\n     当相应指数为零时，将 $$x^{-1}=0$$ 和 $$y^{-1}=0$$ 解释。\n\n5. 测试套件、目标点和度量。\n   - 使用以下多项式次数和测试函数：\n     - 情况 A：$$N=0,$$，标量场 $$f(\\mathbf{x}) = 3.$$ 精确梯度恒为零。\n     - 情况 B：$$N=1,$$，标量场 $$f(\\mathbf{x}) = 1 + x - 2y.$$ 精确梯度为 $$\\nabla f = (1, -2).$$\n     - 情况 C：$$N=3,$$，标量场 $$f(\\mathbf{x}) = e^{x} \\sin(y).$$ 精确梯度为 $$\\nabla f = \\left(e^{x} \\sin(y), \\ e^{x} \\cos(y)\\right).$$\n   - 使用以下三个固定的目标重心点进行插值测试：\n     $$\\text{T}_1: (\\lambda_1,\\lambda_2,\\lambda_3) = \\left(\\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{3}\\right), \\quad\n       \\text{T}_2: (0.2, 0.3, 0.5), \\quad\n       \\text{T}_3: (0.8, 0.1, 0.1).$$\n     使用第 1 项中的仿射映射将每个点映射到物理坐标。\n   - 对每种情况，计算：\n     - 三个目标点上的插值均方根误差，\n       $$E_{\\mathrm{int}} = \\sqrt{\\frac{1}{3} \\sum_{q=1}^3 \\left( \\hat{f}_q - f(\\hat{\\mathbf{x}}_q) \\right)^2 },$$\n       其中 $$\\hat{f}_q$$ 是使用 $$\\mathbf{I}$$ 得到的插值。\n     - 节点上的梯度均方根误差，\n       $$E_{\\nabla} = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} \\left[ \\left( (\\mathbf{D}_x \\mathbf{f})_m - \\frac{\\partial f}{\\partial x}(\\mathbf{x}_m) \\right)^2 + \\left( (\\mathbf{D}_y \\mathbf{f})_m - \\frac{\\partial f}{\\partial y}(\\mathbf{x}_m) \\right)^2 \\right] },$$\n       其中 $$\\mathbf{f}$$ 是 $$f$$ 的节点值。\n\n6. 程序输出格式。\n   - 你的程序必须按顺序为三种情况 $$A,B,C$$ 中的每一种计算 $$[E_{\\mathrm{int}}, E_{\\nabla}]$$，并生成单行输出，其中包含这三个双元素列表的列表，形式为用方括号括起来的逗号分隔列表。例如，输出结构为\n     $$\\left[ [E_{\\mathrm{int}}^{(A)}, E_{\\nabla}^{(A)}], [E_{\\mathrm{int}}^{(B)}, E_{\\nabla}^{(B)}], [E_{\\mathrm{int}}^{(C)}, E_{\\nabla}^{(C)}] \\right].$$\n   - 不涉及物理单位，如果在你自己的推导中出现任何角度，都必须以弧度为单位。所有数值输出必须是实值标量。\n\n你的实现必须遵循上述步骤，从给定的基本定义和事实出发，必须是完全自包含的，并且不需要用户输入。程序打印的最后一行必须是上面描述的列表，占单行，没有附加文本。",
            "solution": "问题陈述是完整的、科学上合理的且定义明确的。它为在参考三角形上生成“扭曲与混合”(warp-and-blend)节点分布以及随后构建相应的高阶插值和微分算子提供了一个细致的、分步的过程。该方法的基础，包括重心坐标、多项式插值、Vandermonde 矩阵以及特定的“扭曲与混合”构造，在谱方法和间断 Galerkin 方法领域是标准且成熟的。测试用例的选择很恰当，可以验证实现：对于次数可以被基函数精确表示的多项式测试函数（$N=0, 1$），其误差应接近机器精度，这提供了一个强有力的验证检查；而对于超越函数的情况（$N=3$），将测试该方案的逼近性质。所有定义在数学上都是精确的，没有矛盾或歧义。因此，该问题被认为是有效的，可以构建一个解决方案。\n\n解决方案通过实现指定的算法步骤来进行。\n\n首先，对于给定的多项式次数 $N \\in \\mathbb{N}_0$，在参考二维单纯形上生成一组节点。该过程从重心坐标 $(\\lambda_1, \\lambda_2, \\lambda_3)$ 中的一个等距晶格开始。对于 $N \\ge 1$，这些点是 $\\left\\{ (\\ell_1/N, \\ell_2/N, \\ell_3/N) \\,\\middle|\\, \\ell_i \\in \\mathbb{N}_0, \\sum \\ell_i = N \\right\\}$。对于 $N=0$，单个节点是形心 $(1/3, 1/3, 1/3)$。这些重心坐标首先被映射到物理坐标 $\\mathbf{x}(\\lambda_1, \\lambda_2, \\lambda_3) = \\lambda_1 \\mathbf{V}_1 + \\lambda_2 \\mathbf{V}_2 + \\lambda_3 \\mathbf{V}_3$，其中 $\\mathbf{V}_i$ 是参考等边三角形的顶点。\n\n为了改善后续算子的插值性质和条件数，这些等距节点通过“扭曲与混合”技术进行位移。该技术旨在沿三角形的边复制一维 Gauss-Lobatto-Legendre (GLL) 节点分布。其核心是一维弯曲函数 $D_N(t)$。对于区间 $[0,1]$ 上的等距参数化 $t_k = k/N$（对于 $k=0,\\dots,N$），以及相应的 GLL 参数化 $t_k^{\\mathrm{GL}}$，函数 $D_N(t)$ 被定义为插值位移的至多 $N$ 次的唯一多项式：$D_N(t_k) = t_k^{\\mathrm{GL}} - t_k$。对于 $N=0$ 和 $N=1$，GLL 点和等距点重合，因此 $D_N(t) \\equiv 0$。\n\n对于三角形中的每个点，通过投影为每条边 $i \\in \\{1,2,3\\}$ 计算一个局部参数 $t_i$。沿每条边切向向量 $\\mathbf{e}_i$ 的弯曲位移然后计算为 $D_N(t_i)$。这些基于边的位移使用混合函数 $B_i(\\lambda_1,\\lambda_2,\\lambda_3) = (1 - \\lambda_i)^2$ 进行组合，这确保了弯曲在相应的边上（其中 $B_i=1$）是完全激活的，并在对顶点和内部平滑衰减到零。最终的弯曲物理坐标由初始仿射位置和混合弯曲位移的总和给出：\n$$\n\\mathbf{x}_{\\mathrm{WB}} = \\mathbf{x}(\\lambda_1,\\lambda_2,\\lambda_3) \\;+\\; \\sum_{i=1}^{3} \\mathbf{e}_i \\, B_i(\\lambda_1,\\lambda_2,\\lambda_3) \\, D_N(t_i).\n$$\n\n其次，在建立了 $M = (N+1)(N+2)/2$ 个弯曲节点集 $\\{\\mathbf{x}_m\\}_{m=1}^M$ 之后，我们构建算子。总次数至多为 $N$ 的多项式空间 $\\mathcal{P}_N(\\mathbb{R}^2)$ 的基选择为分级单项式集合 $\\{x^i y^j : i+j \\le N\\}$。Vandermonde 矩阵 $\\mathbf{V}$ 由元素 $V_{m,p} = x_m^{i_p} y_m^{j_p}$ 构造，其中 $m$ 索引节点， $p$ 索引单项式基函数。该矩阵将单项式基中多项式的系数映射到其在节点处的值。因此，其逆矩阵 $\\mathbf{V}^{-1}$ 执行反向映射：从节点值到单项式系数。\n\n微分算子是通过首先对单项式基函数关于 $x$ 和 $y$ 求导，在节点上求值以形成矩阵 $\\mathbf{V}_x$ 和 $\\mathbf{V}_y$，然后将得到的系数映射回节点值来推导的。这就得到了微分矩阵：\n$$\n\\mathbf{D}_x = \\mathbf{V}_x \\mathbf{V}^{-1}, \\quad \\mathbf{D}_y = \\mathbf{V}_y \\mathbf{V}^{-1}.\n$$\n这些矩阵将节点上的函数值向量直接转换为同一节点上相应偏导数值的向量。\n\n类似地，可以创建一个插值矩阵 $\\mathbf{I}$ 来在任意目标点集 $\\{\\hat{\\mathbf{x}}_q\\}_{q=1}^Q$ 上求值多项式插值。这是通过在目标点上构建一个类 Vandermonde 矩阵 $\\mathbf{V}(\\{\\hat{\\mathbf{x}}_q\\})$ 并应用从系数到节点值的映射来完成的：\n$$\n\\mathbf{I} = \\mathbf{V}(\\{\\hat{\\mathbf{x}}_q\\}) \\mathbf{V}^{-1}.\n$$\n\n最后，使用指定的测试用例验证实现。对于每种情况，在“扭曲与混合”节点上计算测试函数 $f$ 的节点值 $\\mathbf{f}$。在目标点上的插值计算为 $\\hat{\\mathbf{f}} = \\mathbf{I} \\mathbf{f}$，并与精确值 $f(\\hat{\\mathbf{x}}_q)$ 进行比较以找出插值误差 $E_{\\mathrm{int}}$。偏导数的节点值通过 $(\\mathbf{D}_x \\mathbf{f})$ 和 $(\\mathbf{D}_y \\mathbf{f})$ 计算，并与精确导数 $\\frac{\\partial f}{\\partial x}(\\mathbf{x}_m)$ 和 $\\frac{\\partial f}{\\partial y}(\\mathbf{x}_m)$ 进行比较以计算梯度误差 $E_{\\nabla}$。对于情况 A ($N=0$) 和 B ($N=1$)，其中测试函数是次数 $\\le N$ 的多项式，预计两个误差都接近于零，从而证实所构建算子的正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_jacobi\n\ndef solve():\n    \"\"\"\n    Implements the warp-and-blend node generation for a 2D simplex, constructs\n    interpolation and differentiation operators, and evaluates their accuracy\n    on a suite of test cases.\n    \"\"\"\n\n    # 1. Reference geometry, test functions, and target points.\n    V1 = np.array([-1.0, -1.0 / np.sqrt(3.0)])\n    V2 = np.array([1.0, -1.0 / np.sqrt(3.0)])\n    V3 = np.array([0.0, 2.0 / np.sqrt(3.0)])\n    \n    E1 = V3 - V2\n    E2 = V3 - V1\n    E3 = V2 - V1\n\n    target_bary = np.array([\n        [1.0/3.0, 1.0/3.0, 1.0/3.0],\n        [0.2, 0.3, 0.5],\n        [0.8, 0.1, 0.1]\n    ])\n    \n    target_phys = target_bary @ np.array([V1, V2, V3])\n\n    test_cases = [\n        (0, lambda x, y: 3.0 + 0*x, lambda x, y: (0.0, 0.0)),\n        (1, lambda x, y: 1.0 + x - 2.0*y, lambda x, y: (1.0, -2.0)),\n        (3, lambda x, y: np.exp(x) * np.sin(y), \n         lambda x, y: (np.exp(x) * np.sin(y), np.exp(x) * np.cos(y)))\n    ]\n\n    # Helper functions for algorithm steps\n    \n    def get_gll_nodes(N):\n        \"\"\"Computes 1D Gauss-Lobatto-Legendre nodes on [-1, 1].\"\"\"\n        if N == 0:\n            return np.array([0.0])\n        if N == 1:\n            return np.array([-1.0, 1.0])\n        # Interior nodes are roots of P_N'(x), which are roots of Jacobi P_{N-1}^{(1,1)}(x)\n        roots, _ = roots_jacobi(N - 1, 1, 1)\n        return np.sort(np.concatenate(([-1.0], roots, [1.0])))\n\n    def construct_warp_poly(N):\n        \"\"\"Constructs the 1D warping polynomial D_N(t).\"\"\"\n        if N == 0: # No displacement for N=0\n            return np.poly1d([0.0])\n            \n        t_equi = np.linspace(0.0, 1.0, N + 1)\n        x_gll = get_gll_nodes(N)\n        t_gll = (x_gll + 1.0) / 2.0\n        \n        displacement = t_gll - t_equi\n\n        if np.allclose(displacement, 0):\n            return np.poly1d([0.0])\n\n        # Solve Vandermonde system for polynomial coefficients\n        V = np.vander(t_equi, N + 1, increasing=True)\n        coeffs = np.linalg.solve(V, displacement)\n        return np.poly1d(coeffs[::-1])\n\n    def get_equidistant_bary_nodes(N):\n        \"\"\"Generates the equidistant barycentric lattice.\"\"\"\n        if N == 0:\n            return np.array([[1.0/3.0, 1.0/3.0, 1.0/3.0]])\n        \n        nodes = []\n        for i in range(N + 1):\n            for j in range(N - i + 1):\n                k = N - i - j\n                nodes.append([k/N, j/N, i/N]) # Order to match common literature (l3,l2,l1)\n        return np.array(nodes)\n        \n    def get_warp_and_blend_nodes(N, warp_poly):\n        \"\"\"Computes the final 2D warped node coordinates.\"\"\"\n        bary_nodes = get_equidistant_bary_nodes(N)\n        phys_nodes_equi = bary_nodes @ np.array([V1, V2, V3])\n        \n        if N == 0: # No warping for N=0 case.\n            return phys_nodes_equi\n\n        displacements = np.zeros_like(phys_nodes_equi)\n\n        for i, (l1, l2, l3) in enumerate(bary_nodes):\n            # Denominators for edge parameters\n            d1 = l2 + l3\n            d2 = l1 + l3\n            d3 = l1 + l2\n\n            # Local edge parameters, with safe division\n            t1 = l3 / d1 if d1 > 1e-12 else 0.0\n            t2 = l1 / d2 if d2 > 1e-12 else 0.0\n            t3 = l2 / d3 if d3 > 1e-12 else 0.0\n           \n            # Blending factors\n            B1 = (1 - l1)**2\n            B2 = (1 - l2)**2\n            B3 = (1 - l3)**2\n            \n            # Warping displacement\n            warp1 = E1 * B1 * warp_poly(t1)\n            warp2 = E2 * B2 * warp_poly(t2)\n            warp3 = E3 * B3 * warp_poly(t3)\n            \n            displacements[i,:] = warp1 + warp2 + warp3\n        \n        return phys_nodes_equi + displacements\n\n    def get_monomial_exponents(N):\n        \"\"\"Generates exponents (i,j) for the monomial basis x^i y^j.\"\"\"\n        exponents = []\n        for i in range(N + 1):\n            for j in range(N - i + 1):\n                exponents.append((i, j))\n        return exponents\n\n    def build_vandermonde(nodes, exponents):\n        \"\"\"Builds the 2D Vandermonde matrix.\"\"\"\n        M = len(nodes)\n        P = len(exponents)\n        V = np.zeros((M, P))\n        for m in range(M):\n            for p in range(P):\n                i, j = exponents[p]\n                V[m, p] = nodes[m, 0]**i * nodes[m, 1]**j\n        return V\n\n    def build_vandermonde_derivatives(nodes, exponents):\n        \"\"\"Builds Vandermonde matrices for partial derivatives.\"\"\"\n        M = len(nodes)\n        P = len(exponents)\n        Vx = np.zeros((M, P))\n        Vy = np.zeros((M, P))\n        for m in range(M):\n            for p in range(P):\n                i, j = exponents[p]\n                # d/dx (x^i y^j) = i * x^(i-1) y^j\n                if i > 0:\n                    Vx[m, p] = i * nodes[m, 0]**(i-1) * nodes[m, 1]**j\n                # d/dy (x^i y^j) = j * x^i y^(j-1)\n                if j > 0:\n                    Vy[m, p] = j * nodes[m, 0]**i * nodes[m, 1]**(j-1)\n        return Vx, Vy\n\n    all_results = []\n    \n    # Main loop over test cases\n    for N, f, grad_f in test_cases:\n        # 2. Node Generation\n        warp_poly = construct_warp_poly(N)\n        wb_nodes = get_warp_and_blend_nodes(N, warp_poly)\n        M = len(wb_nodes)\n        \n        # 3. Operator Construction\n        exponents = get_monomial_exponents(N)\n        V = build_vandermonde(wb_nodes, exponents)\n        V_inv = np.linalg.inv(V)\n        \n        Vx, Vy = build_vandermonde_derivatives(wb_nodes, exponents)\n        Dx = Vx @ V_inv\n        Dy = Vy @ V_inv\n\n        # 4. Error Calculation\n        f_nodal = f(wb_nodes[:, 0], wb_nodes[:, 1])\n\n        # Interpolation Error\n        V_target = build_vandermonde(target_phys, exponents)\n        I = V_target @ V_inv\n        f_interp = I @ f_nodal\n        f_exact_target = f(target_phys[:, 0], target_phys[:, 1])\n        E_int = np.sqrt(np.mean((f_interp - f_exact_target)**2))\n\n        # Gradient Error\n        dfdx_num = Dx @ f_nodal\n        dfdy_num = Dy @ f_nodal\n        \n        dfdx_exact, dfdy_exact = grad_f(wb_nodes[:, 0], wb_nodes[:, 1])\n\n        err_dx_sq = (dfdx_num - dfdx_exact)**2\n        err_dy_sq = (dfdy_num - dfdy_exact)**2\n        E_nabla = np.sqrt(np.mean(err_dx_sq + err_dy_sq))\n        \n        all_results.append([E_int, E_nabla])\n\n    # Final print statement in the exact required format.\n    print(str(all_results))\n\nsolve()\n```"
        }
    ]
}