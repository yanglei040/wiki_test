{
    "hands_on_practices": [
        {
            "introduction": "We begin with a fundamental exercise that connects the algebraic formulation of a time-stepping scheme to its stability properties. By deriving the stability polynomial for a popular low-storage scheme and analyzing the eigenvalues of a simple discontinuous Galerkin operator, you will determine the maximum stable time step from the ground up. This practice  is crucial for understanding the core mechanism of Courant–Friedrichs–Lewy (CFL) stability constraints within the method of lines framework.",
            "id": "3397065",
            "problem": "Consider the one-dimensional linear advection equation $u_{t} + a\\,u_{x} = 0$ with constant advection speed $a > 0$ on a periodic domain $x \\in [0,L]$. Discretize in space using a discontinuous Galerkin (DG) method with piecewise constants (polynomial degree $p=0$) on a uniform mesh with $K$ elements, element size $h = L/K$, numerical flux equal to the upwind flux, and standard $L^{2}$ mass-lumping within each element. This yields a semi-discrete method of lines $\\frac{\\mathrm{d}}{\\mathrm{d}t}\\mathbf{u}(t) = L\\,\\mathbf{u}(t)$ with a block-circulant matrix $L$.\n\nTime advance is performed by the following two-register low-storage three-stage, third-order scheme (equivalent to the Shu–Osher strong-stability-preserving Runge–Kutta method of order three), written for any right-hand side $F(\\mathbf{u})$:\n- Stage $1$: $\\mathbf{u}^{(1)} = \\mathbf{u}^{n} + \\Delta t\\,F(\\mathbf{u}^{n})$.\n- Stage $2$: $\\mathbf{u}^{(2)} = \\frac{3}{4}\\,\\mathbf{u}^{n} + \\frac{1}{4}\\left(\\mathbf{u}^{(1)} + \\Delta t\\,F(\\mathbf{u}^{(1)})\\right)$.\n- Stage $3$: $\\mathbf{u}^{n+1} = \\frac{1}{3}\\,\\mathbf{u}^{n} + \\frac{2}{3}\\left(\\mathbf{u}^{(2)} + \\Delta t\\,F(\\mathbf{u}^{(2)})\\right)$.\n\nYour tasks are:\n1. Starting from the definition of the absolute stability function for a Runge–Kutta method applied to the linear test equation $y'(t) = \\lambda\\,y(t)$, derive the stability function $R(z)$ of the above low-storage scheme, where $z = \\lambda\\,\\Delta t$.\n2. For the DG semi-discretization with $p=0$ and upwind flux on a uniform periodic grid, derive the eigenvalue set $\\Lambda(L)$ of the semi-discrete operator $L$ by applying a Fourier mode ansatz. Then, using the Courant number $C = a\\,\\Delta t/h$, express the stability condition $\\max_{\\lambda \\in \\Lambda(L)}\\left|R(\\Delta t\\,\\lambda)\\right| \\le 1$ as a condition on $C$ involving an explicit univariate extremization with respect to a Fourier phase $\\theta \\in [0,2\\pi]$.\n3. Determine the largest admissible Courant number $C_{\\max}$ such that the absolute stability condition is satisfied for all $\\lambda \\in \\Lambda(L)$. Your final answer must be a single real number. Round your answer to four significant figures.\n\nNo further simplifications or prederived formulas may be used beyond the above definitions and the stated scheme. State clearly any intermediate transformations you make and justify each step from first principles of the method of lines, the DG semi-discretization with upwind flux, and the definition of a Runge–Kutta absolute stability function. The final answer must be the single value of $C_{\\max}$ (no units).",
            "solution": "The user has provided a three-part problem concerning the stability analysis of a discontinuous Galerkin (DG) finite element method combined with a low-storage Runge-Kutta (RK) time integration scheme for the linear advection equation. First, the problem's validity must be established.\n\n### Step 1: Extract Givens\n- **Equation**: One-dimensional linear advection equation $u_{t} + a\\,u_{x} = 0$, with constant advection speed $a > 0$.\n- **Domain**: Periodic, $x \\in [0,L]$.\n- **Spatial Discretization**:\n    - Method: Discontinuous Galerkin (DG).\n    - Polynomial Degree: $p=0$ (piecewise constants).\n    - Mesh: Uniform with $K$ elements, element size $h = L/K$.\n    - Numerical Flux: Upwind flux.\n    - Mass Matrix: Standard $L^2$ mass-lumping.\n- **Semi-Discrete Form**: $\\frac{\\mathrm{d}}{\\mathrm{d}t}\\mathbf{u}(t) = L\\,\\mathbf{u}(t)$, where $L$ is a block-circulant matrix.\n- **Time Integration Scheme**: A two-register low-storage three-stage, third-order scheme (SSP-RK3):\n    - Stage $1$: $\\mathbf{u}^{(1)} = \\mathbf{u}^{n} + \\Delta t\\,F(\\mathbf{u}^{n})$.\n    - Stage $2$: $\\mathbf{u}^{(2)} = \\frac{3}{4}\\,\\mathbf{u}^{n} + \\frac{1}{4}\\left(\\mathbf{u}^{(1)} + \\Delta t\\,F(\\mathbf{u}^{(1)})\\right)$.\n    - Stage $3$: $\\mathbf{u}^{n+1} = \\frac{1}{3}\\,\\mathbf{u}^{n} + \\frac{2}{3}\\left(\\mathbf{u}^{(2)} + \\Delta t\\,F(\\mathbf{u}^{(2)})\\right)$.\n- **Definitions**: Courant number $C = a\\,\\Delta t/h$.\n- **Tasks**:\n    1. Derive the stability function $R(z)$ of the scheme for $z = \\lambda\\,\\Delta t$.\n    2. Derive the eigenvalue set $\\Lambda(L)$ of the DG semi-discretization and express the stability condition $\\max_{\\lambda \\in \\Lambda(L)}\\left|R(\\Delta t\\,\\lambda)\\right| \\le 1$ as an extremization problem for $C$ over a Fourier phase $\\theta$.\n    3. Determine the largest admissible Courant number $C_{\\max}$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is firmly rooted in the field of numerical analysis for partial differential equations. The DG method, Runge-Kutta schemes, and stability analysis are standard, well-established topics. The linear advection equation is a canonical model problem. All elements are scientifically sound.\n2.  **Well-Posed**: The problem is structured as a sequence of derivations leading to a final numerical value. Each part is clearly defined and builds upon the previous one, leading to a unique and meaningful solution ($C_{\\max}$).\n3.  **Objective**: The problem is stated in precise, objective mathematical language. There are no subjective or opinion-based claims.\n4.  **Completeness**: The problem provides all necessary information: the PDE, the discretization details (DG, $p=0$, upwind flux, periodic BC), the time-stepping scheme, and the definition of the Courant number. While the problem labels the matrix $L$ as \"block-circulant\", for $p=0$ it is a simple (non-block) circulant matrix. This is a minor terminological imprecision but does not affect the solvability or create a contradiction, as the structure is fully determined by the other specifications.\n5.  **Other Flaws**: The problem is not metaphorical, trivial, ill-posed, or unverifiable. It is a standard, albeit detailed, problem in numerical analysis.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A complete, reasoned solution will now be provided.\n\n### Solution\n\nThe problem is addressed in three sequential parts as requested.\n\n**Part 1: Derivation of the Stability Function $R(z)$**\n\nThe stability function $R(z)$ for a Runge-Kutta method is defined by the relation $y^{n+1} = R(z) y^n$ when the method is applied to the linear test equation $y'(t) = \\lambda y(t)$. Here, the right-hand side function is $F(y) = \\lambda y$, and we define $z = \\lambda \\Delta t$. We apply this to the given three-stage scheme.\n\nFor the first stage:\n$$y^{(1)} = y^n + \\Delta t F(y^n) = y^n + \\Delta t (\\lambda y^n) = (1 + \\lambda \\Delta t) y^n = (1+z) y^n$$\n\nFor the second stage, we first compute the argument of $F$, which is $y^{(1)}$, and then substitute the expression for $y^{(1)}$:\n$$y^{(2)} = \\frac{3}{4} y^n + \\frac{1}{4} \\left( y^{(1)} + \\Delta t F(y^{(1)}) \\right) = \\frac{3}{4} y^n + \\frac{1}{4} \\left( y^{(1)} + \\Delta t (\\lambda y^{(1)}) \\right)$$\n$$y^{(2)} = \\frac{3}{4} y^n + \\frac{1}{4} (1 + \\lambda \\Delta t) y^{(1)} = \\frac{3}{4} y^n + \\frac{1}{4} (1+z) y^{(1)}$$\nSubstituting $y^{(1)} = (1+z)y^n$:\n$$y^{(2)} = \\frac{3}{4} y^n + \\frac{1}{4} (1+z)(1+z) y^n = \\left[ \\frac{3}{4} + \\frac{1}{4}(1+z)^2 \\right] y^n$$\nExpanding the polynomial in $z$:\n$$y^{(2)} = \\left[ \\frac{3}{4} + \\frac{1}{4}(1 + 2z + z^2) \\right] y^n = \\left[ \\frac{3}{4} + \\frac{1}{4} + \\frac{2}{4}z + \\frac{1}{4}z^2 \\right] y^n = \\left( 1 + \\frac{1}{2}z + \\frac{1}{4}z^2 \\right) y^n$$\n\nFor the third and final stage:\n$$y^{n+1} = \\frac{1}{3} y^n + \\frac{2}{3} \\left( y^{(2)} + \\Delta t F(y^{(2)}) \\right) = \\frac{1}{3} y^n + \\frac{2}{3} (1 + \\lambda \\Delta t) y^{(2)}$$\n$$y^{n+1} = \\frac{1}{3} y^n + \\frac{2}{3} (1+z) y^{(2)}$$\nSubstituting the expression for $y^{(2)}$:\n$$y^{n+1} = \\left[ \\frac{1}{3} + \\frac{2}{3} (1+z) \\left( 1 + \\frac{1}{2}z + \\frac{1}{4}z^2 \\right) \\right] y^n$$\nThe expression in the square brackets is the stability function $R(z)$. We expand it:\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} \\left( 1 \\cdot (1 + \\frac{1}{2}z + \\frac{1}{4}z^2) + z \\cdot (1 + \\frac{1}{2}z + \\frac{1}{4}z^2) \\right)$$\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} \\left( 1 + \\frac{1}{2}z + \\frac{1}{4}z^2 + z + \\frac{1}{2}z^2 + \\frac{1}{4}z^3 \\right)$$\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} \\left( 1 + \\frac{3}{2}z + \\frac{3}{4}z^2 + \\frac{1}{4}z^3 \\right)$$\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3$$\n$$R(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3$$\nThis is the Taylor series expansion of $\\exp(z)$ up to the third-order term, confirming the method's third-order accuracy.\n\n**Part 2: Eigenvalue Spectrum and Stability Condition**\n\nWe first derive the semi-discrete system for the DG method with $p=0$. The DG weak formulation on an element $I_j = [x_{j-1/2}, x_{j+1/2}]$ is to find $u_h$ such that for all test functions $v_h$:\n$$\\int_{I_j} \\frac{\\partial u_h}{\\partial t} v_h \\,dx + \\int_{I_j} a \\frac{\\partial u_h}{\\partial x} v_h \\,dx = 0$$\nUsing integration by parts on the second term:\n$$\\int_{I_j} \\frac{\\partial u_h}{\\partial t} v_h \\,dx - \\int_{I_j} a u_h \\frac{\\partial v_h}{\\partial x} \\,dx + [a u_h^* v_h]_{x_{j-1/2}}^{x_{j+1/2}} = 0$$\nFor $p=0$, $u_h(x,t) = u_j(t)$ and $v_h(x) = v_j$ are constants on $I_j$. Let $v_j=1$. The derivatives inside the integrals vanish. The equation becomes:\n$$h \\frac{du_j}{dt} + a u^*(x_{j+1/2}) - a u^*(x_{j-1/2}) = 0$$\nThe problem specifies the upwind flux. Since $a>0$, the wind blows from left to right. The numerical flux $u^*$ at an interface is the value from the left (upwind) side.\nAt interface $x_{j+1/2}$, the left state is $u_j$ and the right state is $u_{j+1}$. So, $u^*(x_{j+1/2}) = u_j$.\nAt interface $x_{j-1/2}$, the left state is $u_{j-1}$ and the right state is $u_j$. So, $u^*(x_{j-1/2}) = u_{j-1}$.\nSubstituting these fluxes into the semi-discrete equation:\n$$h \\frac{du_j}{dt} + a u_j - a u_{j-1} = 0 \\implies \\frac{du_j}{dt} = -\\frac{a}{h} (u_j - u_{j-1})$$\nThis defines the action of the operator $L$: $(L\\mathbf{u})_j = -\\frac{a}{h} (u_j - u_{j-1})$.\nTo find the eigenvalues $\\lambda$ of $L$, we use a Fourier mode ansatz for the grid function $\\mathbf{u}$, accounting for periodicity. Let $u_j(t) = \\hat{u}(t) e^{i k x_j}$ where $x_j = j h$ and $k$ is the wavenumber.\n$$\\frac{d}{dt} (\\hat{u} e^{ikjh}) = -\\frac{a}{h} (\\hat{u} e^{ikjh} - \\hat{u} e^{ik(j-1)h})$$\n$$\\frac{d\\hat{u}}{dt} e^{ikjh} = -\\frac{a}{h} \\hat{u} e^{ikjh} (1 - e^{-ikh})$$\n$$\\frac{d\\hat{u}}{dt} = \\left[-\\frac{a}{h} (1 - e^{-ikh})\\right] \\hat{u}$$\nThe eigenvalues of the operator $L$ are thus $\\lambda(k) = -\\frac{a}{h} (1 - e^{-ikh})$.\nThe periodic domain $[0, L]$ with grid size $h=L/K$ requires that the wavenumbers satisfy $kL = 2\\pi m$ for integer $m$. Thus, $k = \\frac{2\\pi m}{L} = \\frac{2\\pi m}{Kh}$.\nLet $\\theta_m = kh = \\frac{2\\pi m}{K}$ be the discrete Fourier phase, where $m = 0, 1, \\dots, K-1$. For a large number of elements $K \\to \\infty$, $\\theta$ can be treated as a continuous variable in $[0, 2\\pi]$.\nThe eigenvalues are $\\lambda(\\theta) = -\\frac{a}{h}(1 - e^{-i\\theta}) = \\frac{a}{h}(e^{-i\\theta} - 1)$.\nThe argument of the stability function $R(z)$ is $z = \\Delta t \\lambda$.\n$$z(\\theta) = \\Delta t \\lambda(\\theta) = \\frac{a \\Delta t}{h} (e^{-i\\theta} - 1) = C(e^{-i\\theta} - 1)$$\nwhere $C = a \\Delta t/h$ is the Courant number.\nThe stability condition is that for all eigenvalues $\\lambda$ of $L$, the amplification factor $|R(\\Delta t \\lambda)|$ must be no greater than $1$. In the limit $K \\to \\infty$, this becomes an extremization problem over the continuous phase $\\theta$:\n$$\\max_{\\theta \\in [0, 2\\pi]} |R(z(\\theta))| \\le 1$$\nSubstituting the expressions for $R(z)$ and $z(\\theta)$, the condition is:\n$$\\max_{\\theta \\in [0, 2\\pi]} \\left| 1 + C(e^{-i\\theta}-1) + \\frac{1}{2} C^2(e^{-i\\theta}-1)^2 + \\frac{1}{6} C^3(e^{-i\\theta}-1)^3 \\right| \\le 1$$\n\n**Part 3: Maximum Admissible Courant Number $C_{\\max}$**\n\nThe set of points $z(\\theta) = C(e^{-i\\theta} - 1)$ for $\\theta \\in [0, 2\\pi]$ traces a circle in the complex plane. Writing $z = x+iy$, we have $x = C(\\cos\\theta - 1)$ and $y = -C\\sin\\theta$. It follows that $(x+C)^2 + y^2 = C^2\\cos^2\\theta + C^2\\sin^2\\theta = C^2$. This is a circle of radius $C$ centered at $-C$.\n\nThe stability condition demands that this entire circle lies within the absolute stability region of the RK method, defined by $\\{z \\in \\mathbb{C} : |R(z)| \\le 1\\}$. The largest admissible Courant number $C_{\\max}$ is the value of $C$ for which this circle is tangent to the boundary of the stability region from within.\n\nFor many dissipative numerical schemes, the most restrictive stability constraint arises from the highest frequency mode representable on the grid. For the upwind scheme, this corresponds to $\\theta=\\pi$, where the eigenvalue has the largest negative real part. Let us assume the maximum of $|R(z(\\theta))|$ occurs at $\\theta=\\pi$.\nAt $\\theta = \\pi$, we have $e^{-i\\pi} = -1$. The corresponding value of $z$ is:\n$$z(\\pi) = C(-1-1) = -2C$$\nThis point lies on the negative real axis. The stability condition for this point is $|R(-2C)| \\leq 1$.\nThe stability function for a real negative argument $-x$ (with $x > 0$) is real:\n$$R(-x) = 1 - x + \\frac{1}{2}x^2 - \\frac{1}{6}x^3$$\nSo, we require $|R(-2C)| \\le 1$, which is equivalent to $-1 \\le R(-2C) \\le 1$. Let's check these two inequalities.\n1. $R(-2C) \\le 1$:\n$$1 - 2C + \\frac{1}{2}(-2C)^2 - \\frac{1}{6}(-2C)^3 \\le 1$$\n$$ -2C + 2C^2 + \\frac{4}{3}C^3 \\le 0$$\nThis is the recalculation from the original solution's thought process. The correct expression is:\n$$R(-2C) = 1 - 2C + 2C^2 - \\frac{4}{3}C^3$$\n1. The inequality $R(-2C) \\le 1$:\n$$1 - 2C + 2C^2 - \\frac{4}{3}C^3 \\le 1 \\implies -2C + 2C^2 - \\frac{4}{3}C^3 \\le 0$$\nDividing by $-2C$ (and flipping the inequality sign as $-2C0$):\n$$1 - C + \\frac{2}{3}C^2 \\ge 0$$\nThe discriminant of this quadratic is $D = (-1)^2 - 4(\\frac{2}{3})(1) = 1 - \\frac{8}{3}  0$. Since the leading coefficient is positive, the quadratic is always positive. This inequality is satisfied for all $C$.\n\n2. The inequality $R(-2C) \\ge -1$:\n$$1 - 2C + 2C^2 - \\frac{4}{3}C^3 \\ge -1$$\n$$2 - 2C + 2C^2 - \\frac{4}{3}C^3 \\ge 0$$\nLet $f(C) = 2 - 2C + 2C^2 - \\frac{4}{3}C^3$. We need to find the largest $C$ that satisfies $f(C) \\ge 0$. Let's examine the derivative:\n$$f'(C) = -2 + 4C - 4C^2 = -2(1 - 2C + 2C^2)$$\nThe discriminant of the quadratic $1 - 2C + 2C^2$ is $D = (-2)^2 - 4(2)(1) = 4 - 8 = -4  0$. Since the leading coefficient is positive, the quadratic is always positive. Therefore, $f'(C)$ is always negative, and $f(C)$ is a strictly decreasing function for all $C$.\nThe maximum allowed value of $C$, denoted $C_{\\max}$, will be the root of the equation $f(C) = 0$.\n$$2 - 2C_{\\max} + 2C_{\\max}^2 - \\frac{4}{3}C_{\\max}^3 = 0$$\nMultiplying by $-\\frac{3}{2}$ to simplify:\n$$2C_{\\max}^3 - 3C_{\\max}^2 + 3C_{\\max} - 3 = 0$$\nThis is a cubic equation for $C_{\\max}$. We must solve it numerically. Let $g(C) = 2C^3 - 3C^2 + 3C - 3$.\n$g(1) = 2-3+3-3 = -1$.\n$g(1.5) = 2(3.375) - 3(2.25) + 3(1.5) - 3 = 6.75 - 6.75 + 4.5 - 3 = 1.5$.\nThe root lies between $1$ and $1.5$. Using a numerical solver (e.g., Newton's method):\nLet's start with an initial guess $C_0 = 1.2$.\n$g(1.2) = 2(1.728) - 3(1.44) + 3(1.2) - 3 = 3.456 - 4.32 + 3.6 - 3 = -0.264$.\n$g'(C) = 6C^2 - 6C + 3$.\n$g'(1.2) = 6(1.44) - 6(1.2) + 3 = 8.64 - 7.2 + 3 = 4.44$.\n$C_1 = C_0 - \\frac{g(C_0)}{g'(C_0)} = 1.2 - \\frac{-0.264}{4.44} \\approx 1.2 + 0.059459 = 1.259459$.\nFurther iteration gives a more accurate value for the root:\n$C_{\\max} \\approx 1.2564115$.\nRounding the answer to four significant figures, we get $C_{\\max} = 1.256$.",
            "answer": "$$\\boxed{1.256}$$"
        },
        {
            "introduction": "Building on the analytical foundation, this practice moves into a more realistic computational scenario. You will implement a high-order discontinuous Galerkin operator and numerically investigate the stability limits for both the classical fourth-order Runge-Kutta method and a modern low-storage alternative. This exercise  provides direct, hands-on experience comparing practical stability boundaries, highlighting why specific LSRK schemes are often selected for their superior performance in high-order simulations.",
            "id": "3397159",
            "problem": "Consider the one-dimensional linear advection initial value problem on the periodic domain $[0,1]$ with advection speed $a = 1$, given by $u_t + a u_x = 0$. Discretize the spatial domain using a high-order discontinuous Galerkin (DG) method with a uniform partition into $N$ elements of size $h = 1/N$, and on each element use a nodal basis at the Legendre–Gauss–Lobatto points of polynomial degree $p$ (so that there are $p+1$ nodes per element). Use the upwind numerical flux consistent with $a = 1$.\n\nThe semi-discrete DG operator can be written in the strong form using the Summation-By-Parts property, where the derivative matrix $D$ and quadrature weight matrix $W$ on the reference element satisfy $Q = W D$ and $Q + Q^\\top = B$, with $B$ diagonal selecting the boundary nodes. In this formulation, the semi-discrete system is of the form $u_t = L u$, where $L$ is the global DG matrix assembled from element-wise volume terms and face coupling terms due to the upwind flux and periodic boundary conditions. For explicit time stepping, stability of a one-step method applied to the semi-discrete system $u_t = L u$ is governed by the absolute stability function $R(z)$ evaluated at $z = \\Delta t \\lambda$, where $\\lambda$ ranges over the eigenvalues of $L$. Stability requires $\\max_{\\lambda \\in \\Lambda(L)} |R(\\Delta t \\lambda)| \\le 1$. It is well-established in high-order DG analysis that the spectral radius of the advection operator scales as $\\mathcal{O}(p^2/h)$ due to inverse inequalities and trace estimates, motivating a Courant–Friedrichs–Lewy (CFL) condition of the form $\\Delta t \\le C/(p^2 h)$ for explicit Runge–Kutta-type methods.\n\nYour task is to implement and compare the stability-limited time step coefficient $C$ when switching from the classical fourth-order Runge–Kutta method (RK4) to a two-register low-storage Runge–Kutta method of five stages and fourth order (commonly referred to as a Carpenter–Kennedy 2N-storage low-storage scheme). The classical fourth-order Runge–Kutta method has a known stability function, and the low-storage method can be represented by a stage-recursive update using two registers and constant coefficients. In all cases, the temporal stability must be verified against the full complex spectrum of the assembled DG operator for the given $p$ and $N$.\n\nBase your derivation on the following fundamental facts:\n- The semi-discrete DG formulation for linear advection with upwind flux and periodic boundary conditions yields a linear system $u_t = L u$ with eigenvalues scaling in magnitude as $\\mathcal{O}(p^2/h)$.\n- For explicit Runge–Kutta methods applied to $u_t = L u$, stability is determined by the magnitude of the stability function $R(z)$ on the set $z = \\Delta t \\lambda$, where $\\lambda$ are the eigenvalues of $L$.\n\nFrom these bases, derive an algorithm to compute, for fixed $p$ and $N$, the largest $\\Delta t$ such that the method remains stable, and report the corresponding $C$ via $C = \\Delta t \\cdot p^2 / h$. Implement $L$ by assembling:\n- The reference-element Legendre–Gauss–Lobatto nodes and weights of degree $p$.\n- The nodal differentiation matrix $D$ on the reference element constructed via barycentric weights.\n- The global strong-form DG advection operator $L$ with upwind flux and periodic boundary conditions over $N$ elements.\n\nThen, for each Runge–Kutta scheme:\n- Compute the eigenvalues of $L$.\n- Determine the maximal stable $\\Delta t$ via a monotone bisection on $\\Delta t$ checking $\\max_{\\lambda} |R(\\Delta t \\lambda)| \\le 1$ at each step.\n- Compute $C = \\Delta t \\cdot p^2 / h$.\n\nAngle measurements are not required, and no physical units are needed; all quantities are nondimensional.\n\nTest Suite:\n- Use $N = 16$ elements, advection speed $a = 1$, and periodic boundary conditions.\n- Evaluate the schemes for $p \\in \\{2,4,8\\}$.\n- Schemes:\n  1. Classical fourth-order Runge–Kutta (denote by the code string \"RK4\").\n  2. Two-register low-storage five-stage fourth-order Runge–Kutta (denote by the code string \"LSRK54\").\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be ordered as $[C_{\\mathrm{RK4}}(p{=}2), C_{\\mathrm{LSRK54}}(p{=}2), C_{\\mathrm{RK4}}(p{=}4), C_{\\mathrm{LSRK54}}(p{=}4), C_{\\mathrm{RK4}}(p{=}8), C_{\\mathrm{LSRK54}}(p{=}8)]$.",
            "solution": "The user has provided a scientifically valid and well-posed problem. The task is to compute the stability-limited Courant–Friedrichs–Lewy (CFL) coefficient, denoted as $C$, for a high-order discontinuous Galerkin (DG) discretization of the one-dimensional linear advection equation. This analysis will be performed for two different explicit Runge-Kutta time-stepping schemes.\n\nThe problem is governed by the initial value problem:\n$$ u_t + a u_x = 0, \\quad x \\in [0,1], \\quad t > 0 $$\nwith advection speed $a=1$ and periodic boundary conditions.\n\nThe solution proceeds in several steps:\n1.  **Construct the Semi-Discrete DG Operator**: The spatial domain is discretized into $N$ elements, and a nodal polynomial basis of degree $p$ on the Legendre-Gauss-Lobatto (LGL) points is used within each element. The semi-discrete system is a system of ordinary differential equations of the form $\\frac{d\\vec{U}}{dt} = L\\vec{U}$, where $\\vec{U}$ is the global vector of nodal values and $L$ is the global DG operator. The matrix $L$ is constructed by assembling local operators from each element, incorporating both the volume derivative and the inter-element flux contributions. For this problem, an upwind flux is used.\n\n2.  **Derive the DG Operator Matrix ($L$)**: The global operator $L$ is an $N(p+1) \\times N(p+1)$ matrix.\n    -   **LGL Nodes and Weights**: For a polynomial degree $p$, we require the $p+1$ LGL nodes $\\xi_j$ and quadrature weights $w_j$ on the reference element $[-1,1]$. The nodes are the roots of $(1-x^2)P_p'(x)$, where $P_p(x)$ is the Legendre polynomial of degree $p$.\n    -   **Differentiation Matrix ($D$)**: A differentiation matrix $D$ on the reference element is constructed such that for a vector of nodal values $\\vec{v}$, $D\\vec{v}$ approximates the derivative at the nodes.\n    -   **Strong Form Operator**: The strong form of the DG operator applied to the solution $\\vec{u}_k$ on element $k$ (of size $h=1/N$) is composed of a volume term and a surface flux correction term. The time evolution of the nodal values $\\vec{u}_k$ on element $k$ is given by:\n        $$ \\frac{d\\vec{u}_k}{dt} = -\\frac{2a}{h} D \\vec{u}_k + \\text{FluxCorrection}(\\vec{u}_k, \\vec{u}_{neighbors}) $$\n    -   **Upwind Flux**: For $a=1>0$, the upwind flux at an interface is the value from the element to the left. At the right boundary of element $k$ (interface $k+1/2$), the numerical flux equals the interior trace $u_{k,p}$, so the correction is zero. At the left boundary (interface $k-1/2$), the numerical flux is the exterior trace $u_{k-1,p}$. The flux correction term affects only the first node of the element, $u_{k,0}$. This correction to $\\frac{du_{k,0}}{dt}$ is given by:\n        $$ M_0^{-1} a ( u_{k,0} - u_{k-1,p} ) = \\frac{a}{w_0 h/2} ( u_{k,0} - u_{k-1,p} ) = \\frac{2a}{h w_0} ( u_{k,0} - u_{k-1,p} ) $$\n        This term is added to the right-hand side.\n    -   **Assembling L**: The global matrix $L$ is assembled by distributing these local contributions. For each element $k$, a block corresponding to $-\\frac{2a}{h}D$ is placed on the diagonal. Then, the flux correction term adds a value of $\\frac{2a}{h w_0}$ to the matrix entry mapping $u_{k,0}$ to $\\dot{u}_{k,0}$ and a value of $-\\frac{2a}{h w_0}$ to the entry mapping $u_{k-1,p}$ to $\\dot{u}_{k,0}$. Periodic boundary conditions dictate that the \"previous\" element for $k=0$ is $k=N-1$.\n\n3.  **Analyze Temporal Stability**: The stability of an explicit Runge-Kutta method applied to $\\frac{d\\vec{U}}{dt} = L\\vec{U}$ is determined by its stability function $R(z)$. The method is stable if and only if $|R(\\Delta t \\lambda)| \\le 1$ for all eigenvalues $\\lambda$ of $L$.\n    -   **Eigenvalues of L**: The eigenvalues $\\lambda$ are computed numerically.\n    -   **Stability Functions**:\n        -   For the classical fourth-order Runge-Kutta method (RK4), the stability polynomial is the Taylor expansion of $e^z$ up to degree $4$:\n            $$ R_{\\mathrm{RK4}}(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!} $$\n        -   For the specified five-stage, fourth-order, two-register low-storage Runge-Kutta scheme (LSRK54), the stability polynomial is constructed from its recurrence relations. The scheme can be written as:\n            $$ d_0 = 0, \\quad q_0 = U_n $$\n            $$ d_i = A_i d_{i-1} + \\Delta t f(q_{i-1}), \\quad q_i = q_{i-1} + B_i d_i \\quad \\text{for } i=1,\\dots,5 $$\n            $$ U_{n+1} = q_5 $$\n            Applying this to the test equation $u'=\\lambda u$ (so $f(u)=\\lambda u$), with $z = \\Delta t \\lambda$, allows one to recursively construct the stability polynomial $R_{\\mathrm{LSRK54}}(z) = q_5/q_0$.\n\n4.  **Compute Maximum Stable Time Step and C**: For each scheme, we must find the largest $\\Delta t$ that maintains stability. This is equivalent to finding the maximum $\\Delta t$ such that the scaled spectrum $\\Delta t \\Lambda(L)$ remains within the stability region $\\{z \\in \\mathbb{C} : |R(z)| \\le 1\\}$.\n    -   A bisection search is performed on $\\Delta t$. For a given $\\Delta t$, stability is checked by evaluating $|R(z)|$ for all $z \\in \\Delta t \\Lambda(L)$ and ensuring the maximum magnitude does not exceed $1$.\n    -   Once the maximum stable time step, $\\Delta t_{\\mathrm{max}}$, is found, the stability-limited coefficient $C$ is calculated using the problem-defined scaling relation:\n        $$ C = \\Delta t_{\\mathrm{max}} \\cdot p^2 \\cdot h^{-1} = \\Delta t_{\\mathrm{max}} \\cdot p^2 \\cdot N $$\n\nThe implementation will carry out these steps for the specified parameters ($N=16$, $a=1$) and polynomial degrees ($p \\in \\{2,4,8\\}$), reporting the coefficient $C$ for each case.",
            "answer": "```python\nimport numpy as np\nimport scipy.special\n\ndef solve():\n    \"\"\"\n    Computes the stability-limited CFL coefficient C for a DG discretization of\n    the linear advection equation using RK4 and LSRK54 time-stepping schemes.\n    \"\"\"\n\n    def leg_gauss_lobatto(p):\n        \"\"\"\n        Computes the Legendre-Gauss-Lobatto nodes and weights on [-1, 1].\n\n        Args:\n            p (int): Polynomial degree.\n\n        Returns:\n            tuple: A tuple containing:\n                - np.ndarray: LGL nodes.\n                - np.ndarray: LGL weights.\n        \"\"\"\n        if p == 0:\n            return np.array([0.0]), np.array([2.0])\n        if p == 1:\n            return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n        \n        # Nodes are -1, 1, and the roots of P_p'(x).\n        # Roots of P_p'(x) are roots of the Jacobi polynomial P_{p-1}^{(1,1)}(x).\n        roots_jacobi, _ = scipy.special.roots_jacobi(p - 1, 1, 1)\n        nodes = np.concatenate(([-1.0], np.sort(roots_jacobi), [1.0]))\n        \n        # Weights are given by w_i = 2 / (p*(p+1) * [P_p(x_i)]^2).\n        P_p_at_nodes = scipy.special.eval_legendre(p, nodes)\n        weights = 2.0 / (p * (p + 1) * P_p_at_nodes**2)\n        \n        return nodes, weights\n\n    def diff_matrix(p, nodes):\n        \"\"\"\n        Computes the 1D nodal differentiation matrix on LGL nodes.\n\n        Args:\n            p (int): Polynomial degree.\n            nodes (np.ndarray): LGL nodes.\n\n        Returns:\n            np.ndarray: The (p+1)x(p+1) differentiation matrix.\n        \"\"\"\n        n_pts = p + 1\n        D = np.zeros((n_pts, n_pts))\n        P_p_at_nodes = scipy.special.eval_legendre(p, nodes)\n        \n        for i in range(n_pts):\n            for j in range(n_pts):\n                if i != j:\n                    D[i, j] = P_p_at_nodes[i] / (P_p_at_nodes[j] * (nodes[i] - nodes[j]))\n        \n        D[0, 0] = -p * (p + 1) / 4.0\n        D[p, p] = p * (p + 1) / 4.0\n        # For i=1..p-1, D[i,i] = 0, which is the default from np.zeros.\n        \n        return D\n\n    def build_L_matrix(p, N, a, D, weights):\n        \"\"\"\n        Builds the global strong-form DG operator matrix L.\n\n        Args:\n            p (int): Polynomial degree.\n            N (int): Number of elements.\n            a (float): Advection speed.\n            D (np.ndarray): Reference element differentiation matrix.\n            weights (np.ndarray): LGL quadrature weights.\n\n        Returns:\n            np.ndarray: The global DG operator matrix.\n        \"\"\"\n        n_pts = p + 1\n        total_dofs = N * n_pts\n        L = np.zeros((total_dofs, total_dofs), dtype=np.float64)\n        h = 1.0 / N\n        w0 = weights[0]\n        \n        flux_coeff = 2.0 * a / (h * w0)\n\n        for k in range(N):\n            start_idx = k * n_pts\n            end_idx = start_idx + n_pts\n            \n            # Volume term (block diagonal part)\n            L[start_idx:end_idx, start_idx:end_idx] = - (2.0 * a / h) * D\n            \n            # Surface flux correction term (upwind for a>0)\n            # This adds to the row for u_{k,0} from u_{k,0} and u_{k-1,p}.\n            row_idx = start_idx\n            \n            # Contribution from u_{k,0}\n            L[row_idx, row_idx] += flux_coeff\n            \n            # Contribution from u_{k-1, p} (periodic boundary)\n            prev_k = (k - 1 + N) % N\n            col_idx = prev_k * n_pts + p\n            L[row_idx, col_idx] -= flux_coeff\n            \n        return L\n\n    def get_stability_poly(scheme):\n        \"\"\"\n        Returns the stability polynomial for a given RK scheme.\n        \n        Args:\n            scheme (str): The scheme identifier (\"RK4\" or \"LSRK54\").\n\n        Returns:\n            np.poly1d: The stability polynomial.\n        \"\"\"\n        if scheme == \"RK4\":\n            # R(z) = 1 + z + z^2/2! + z^3/3! + z^4/4!\n            coeffs = [1/24.0, 1/6.0, 1/2.0, 1.0, 1.0]\n            return np.poly1d(coeffs)\n        elif scheme == \"LSRK54\":\n            # 2-register, 5-stage, 4th-order scheme (Carpenter-Kennedy)\n            # Recurrence: d_i = A_i*d_{i-1} + dt*f(q_{i-1}), q_i = q_{i-1} + B_i*d_i\n            B = np.array([0.118888066885314, 0.281111933114686, 0.5, 0.6, 1.0])\n            A = np.array([0.0, 0.0, -0.0911516952733231, -1.0911516952733231, -1.2])\n\n            z = np.poly1d([1, 0])\n            q_poly = np.poly1d([1.0])\n            d_poly = np.poly1d([0.0])\n\n            for i in range(5):\n                d_poly_new = A[i] * d_poly + q_poly\n                q_poly = q_poly + B[i] * z * d_poly_new\n                d_poly = d_poly_new\n            return q_poly\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n\n    def find_max_dt(eigs, stability_poly):\n        \"\"\"\n        Finds the maximum stable time step using bisection.\n\n        Args:\n            eigs (np.ndarray): Eigenvalues of the DG operator.\n            stability_poly (np.poly1d): The stability polynomial.\n\n        Returns:\n            float: The maximum stable time step.\n        \"\"\"\n        def is_stable(dt):\n            if dt = 1e-12: return True\n            z = dt * eigs\n            R_z = stability_poly(z)\n            return np.max(np.abs(R_z)) = 1.000000001 # Numerical tolerance\n\n        max_eig_mag = np.max(np.abs(eigs))\n        if max_eig_mag  1e-9: return np.inf\n        \n        dt_low = 0.0\n        dt_high = 10.0 / max_eig_mag\n        \n        for _ in range(100):\n            dt_mid = (dt_low + dt_high) / 2.0\n            if is_stable(dt_mid):\n                dt_low = dt_mid\n            else:\n                dt_high = dt_mid\n        \n        return dt_low\n\n    # Problem parameters\n    N = 16\n    a = 1.0\n    p_values = [2, 4, 8]\n    schemes = [\"RK4\", \"LSRK54\"]\n    \n    results = []\n\n    for p in p_values:\n        nodes, weights = leg_gauss_lobatto(p)\n        D = diff_matrix(p, nodes)\n        L = build_L_matrix(p, N, a, D, weights)\n        \n        eigenvalues = np.linalg.eigvals(L)\n        \n        for scheme_name in schemes:\n            poly = get_stability_poly(scheme_name)\n            dt_max = find_max_dt(eigenvalues, poly)\n            h = 1.0 / N\n            C = dt_max * p**2 / h\n            results.append(f\"{C:.6f}\")\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The \"low storage\" aspect of LSRK methods is primarily motivated by performance on modern computer architectures with hierarchical memory. This final practice  challenges you to build a predictive performance model to quantify the benefits of minimizing memory traffic on a GPU. By comparing an implementation that fuses operations in registers against one that stages data through shared memory, you will see precisely how algorithmic choices impact hardware efficiency in high-performance DG codes.",
            "id": "3397049",
            "problem": "You are asked to construct a principled, predictive model for the memory traffic and performance of a $2$-register Low-Storage Runge–Kutta (LSRK) time integrator applied to a Runge–Kutta Discontinuous Galerkin (RKDG) method on a Graphics Processing Unit (GPU). The purpose is to contrast two implementation strategies within a single kernel launch for one Runge–Kutta (RK) stage $i$: a fused update that applies the residual immediately, versus staging the residual in shared memory. You must derive a performance model from first principles and validate it using a roofline bound expressed in bytes per degree of freedom (DOF).\n\nBackground and requirements:\n- Consider a semi-discrete system of Ordinary Differential Equations (ODEs) from the Discontinuous Galerkin (DG) semi-discretization, with state vector $u$ of $C$ components per degree of freedom (DOF), advanced in time by a Low-Storage Runge–Kutta (LSRK) scheme using $s$ stages.\n- In a $2$-register scheme, the per-stage update is of the form $u \\leftarrow u + \\beta_i r$, where $r$ is the residual computed from the current state. Treat $\\beta_i$ as a scalar coefficient that does not materially change memory traffic at the level of bytes per DOF. Assume double precision so that each scalar is $b=8$ bytes, unless otherwise specified.\n- Let $B_{\\mathrm{res}}$ denote the global-memory bytes per DOF required to form the residual $r$ for one stage, excluding the final update store of $u$. This incorporates all global-memory traffic to read input field values, geometry, and any other necessary data from global memory for forming $r$.\n- Assume that the final update of $u$ is a streaming global store of $b\\cdot C$ bytes per DOF per stage (no write-allocate penalty).\n- Two strategies are to be contrasted:\n  1. Fused update: compute $r$ and immediately apply $u \\leftarrow u + \\beta_i r$ in registers. This avoids writing $r$ to global or shared memory.\n  2. Staged in shared memory: compute $r$, store it to shared memory, later load it from shared memory, and then apply the update to $u$. This adds shared memory write and read of $b\\cdot C$ bytes each per DOF per stage, for a total of $2 b C$ shared-memory bytes per DOF per stage.\n- Adopt a roofline-inspired additive timing model that accounts for the time contributions from global-memory traffic, shared-memory traffic, and floating-point computation, assuming these three contributions do not overlap:\n$$t_{\\mathrm{g}} = \\dfrac{B_{\\mathrm{res}} + b C}{\\mathrm{BW}_{\\mathrm{g}}}$$\n$$t_{\\mathrm{s}} = \\dfrac{2 b C}{\\mathrm{BW}_{\\mathrm{s}}}$$\n$$t_{\\mathrm{f}} = \\dfrac{F_{\\mathrm{stage}}}{\\mathrm{FLOP}_{\\max}}$$\n- Then the total time per DOF for $s$ stages is\n$$T_{\\mathrm{fused}} = s \\left( \\dfrac{B_{\\mathrm{res}} + b C}{\\mathrm{BW}_{\\mathrm{g}}} + \\dfrac{F_{\\mathrm{stage}}}{\\mathrm{FLOP}_{\\max}} \\right)$$\n$$T_{\\mathrm{staged}} = s \\left( \\dfrac{B_{\\mathrm{res}} + b C}{\\mathrm{BW}_{\\mathrm{g}}} + \\dfrac{2 b C}{\\mathrm{BW}_{\\mathrm{s}}} + \\dfrac{F_{\\mathrm{stage}}}{\\mathrm{FLOP}_{\\max}} \\right)$$\n- The predicted throughput in DOF per second is the reciprocal time per DOF:\n$$\\Theta_{\\mathrm{fused}} = \\dfrac{1}{T_{\\mathrm{fused}}}$$\n$$\\Theta_{\\mathrm{staged}} = \\dfrac{1}{T_{\\mathrm{staged}}}$$\n- For validation against a roofline bound using bytes per DOF, note that a global-memory-only roofline upper bound for either strategy is $\\Theta_{\\mathrm{roof,g}} = \\dfrac{\\mathrm{BW}_{\\mathrm{g}}}{s(B_{\\mathrm{res}} + b C)}$. Your model must not exceed this bound. The final reported throughputs should be expressed in giga-DOF per second, i.e., divided by $10^9$.\n\nTask:\n- Implement a program that, given a small test suite of parameter sets, computes for each test case:\n  - The fused throughput $\\Theta_{\\mathrm{fused}}$ in giga-DOF per second,\n  - The staged throughput $\\Theta_{\\mathrm{staged}}$ in giga-DOF per second,\n  - The ratio $\\rho = \\dfrac{\\Theta_{\\mathrm{fused}}}{\\Theta_{\\mathrm{staged}}}$ (unitless).\n- Use the following test suite (all bytes are in units of bytes, bandwidths in bytes per second, floating-point throughputs in floating-point operations per second). Unless otherwise stated, use double precision $b=8$:\n  1. Case A (typical memory-bound RKDG):\n     - $s=5$, $C=5$, $b=8$, $B_{\\mathrm{res}}=512$, $F_{\\mathrm{stage}}=1000$,\n     - $\\mathrm{BW}_{\\mathrm{g}}=1.0\\times 10^{12}$, $\\mathrm{BW}_{\\mathrm{s}}=5.0\\times 10^{12}$, $\\mathrm{FLOP}_{\\max}=1.0\\times 10^{13}$.\n  2. Case B (shared memory is relatively slow):\n     - $s=5$, $C=5$, $b=8$, $B_{\\mathrm{res}}=512$, $F_{\\mathrm{stage}}=1000$,\n     - $\\mathrm{BW}_{\\mathrm{g}}=1.0\\times 10^{12}$, $\\mathrm{BW}_{\\mathrm{s}}=0.5\\times 10^{12}$, $\\mathrm{FLOP}_{\\max}=1.0\\times 10^{13}$.\n  3. Case C (more compute-heavy stage):\n     - $s=5$, $C=5$, $b=8$, $B_{\\mathrm{res}}=256$, $F_{\\mathrm{stage}}=10000$,\n     - $\\mathrm{BW}_{\\mathrm{g}}=1.0\\times 10^{12}$, $\\mathrm{BW}_{\\mathrm{s}}=5.0\\times 10^{12}$, $\\mathrm{FLOP}_{\\max}=1.0\\times 10^{13}$.\n  4. Case D (boundary case with one stage and one component):\n     - $s=1$, $C=1$, $b=8$, $B_{\\mathrm{res}}=64$, $F_{\\mathrm{stage}}=100$,\n     - $\\mathrm{BW}_{\\mathrm{g}}=0.5\\times 10^{12}$, $\\mathrm{BW}_{\\mathrm{s}}=5.0\\times 10^{12}$, $\\mathrm{FLOP}_{\\max}=1.0\\times 10^{13}$.\n- Your program should produce a single line of output containing all results as a comma-separated list enclosed in square brackets. For each test case, append three floats in order: fused throughput in giga-DOF per second, staged throughput in giga-DOF per second, and the ratio $\\rho$. Therefore, with four test cases, the output must contain $12$ comma-separated floating-point numbers in a single list. Report each float rounded to six digits after the decimal point.\n\nScientific realism:\n- Ensure that global-memory and shared-memory bandwidths, as well as floating-point peaks, are used consistently and that your computed throughputs do not exceed the global roofline bound $\\Theta_{\\mathrm{roof,g}}$ for each case.\n\nAngle units are not applicable. No physical units other than bytes and seconds are used. The outputs are floats as specified. The program must be self-contained and require no input.",
            "solution": "The problem requires the construction and application of a performance model to compare two implementation strategies for a Low-Storage Runge–Kutta (LSRK) time integration scheme applied to a Discontinuous Galerkin (DG) discretization on a Graphics Processing Unit (GPU). The two strategies are a *fused* update, where the residual is computed and used immediately within registers, and a *staged* update, where the residual is temporarily stored in shared memory. The model is based on an additive, non-overlapping accounting of time spent on global memory access, shared memory access, and floating-point computation.\n\nThe performance model is founded on calculating the total time per degree of freedom (DOF) over the $s$ stages of the Runge–Kutta method. Let $C$ be the number of components per DOF, and let each scalar value be represented by $b$ bytes. The model defines three primary time components per DOF for a single stage:\n1.  The time for global-memory operations, $t_{\\mathrm{g}}$, is given by the total global-memory bytes transferred per DOF divided by the global-memory bandwidth, $\\mathrm{BW}_{\\mathrm{g}}$. This traffic includes $B_{\\mathrm{res}}$ bytes for computing the residual and $bC$ bytes for storing the updated state vector $u$. Thus, $t_{\\mathrm{g}} = \\dfrac{B_{\\mathrm{res}} + b C}{\\mathrm{BW}_{\\mathrm{g}}}$.\n2.  The time for shared-memory operations, $t_{\\mathrm{s}}$, is relevant only for the staged strategy. It involves writing the residual to and reading it from shared memory, amounting to $2bC$ bytes per DOF. This time is given by $t_{\\mathrm{s}} = \\dfrac{2 b C}{\\mathrm{BW}_{\\mathrm{s}}}$, where $\\mathrm{BW}_{\\mathrm{s}}$ is the shared-memory bandwidth. For the fused strategy, $t_{\\mathrm{s}}=0$.\n3.  The time for floating-point computation, $t_{\\mathrm{f}}$, is the number of floating-point operations per DOF per stage, $F_{\\mathrm{stage}}$, divided by the peak theoretical floating-point performance of the hardware, $\\mathrm{FLOP}_{\\max}$. Hence, $t_{\\mathrm{f}} = \\dfrac{F_{\\mathrm{stage}}}{\\mathrm{FLOP}_{\\max}}$.\n\nBased on this additive model, the total time per DOF for $s$ stages is calculated for each strategy. For the fused strategy, the time is $T_{\\mathrm{fused}} = s (t_{\\mathrm{g}} + t_{\\mathrm{f}})$. For the staged strategy, the additional shared memory access time is included, resulting in $T_{\\mathrm{staged}} = s (t_{\\mathrm{g}} + t_{\\mathrm{s}} + t_{\\mathrm{f}})$. The equations are explicitly:\n$$T_{\\mathrm{fused}} = s \\left( \\frac{B_{\\mathrm{res}} + b C}{\\mathrm{BW}_{\\mathrm{g}}} + \\frac{F_{\\mathrm{stage}}}{\\mathrm{FLOP}_{\\max}} \\right)$$\n$$T_{\\mathrm{staged}} = s \\left( \\frac{B_{\\mathrm{res}} + b C}{\\mathrm{BW}_{\\mathrm{g}}} + \\frac{2 b C}{\\mathrm{BW}_{\\mathrm{s}}} + \\frac{F_{\\mathrm{stage}}}{\\mathrm{FLOP}_{\\max}} \\right)$$\n\nThe performance is quantified by the throughput, $\\Theta$, defined as the number of DOFs processed per second. It is the reciprocal of the total time per DOF: $\\Theta = 1/T$. The throughputs for the two strategies are therefore $\\Theta_{\\mathrm{fused}} = 1/T_{\\mathrm{fused}}$ and $\\Theta_{\\mathrm{staged}} = 1/T_{\\mathrm{staged}}$. To compare the strategies, we define the performance ratio $\\rho = \\dfrac{\\Theta_{\\mathrm{fused}}}{\\Theta_{\\mathrm{staged}}}$. Substituting the expressions for throughput, this ratio is equivalent to the ratio of total times:\n$$\\rho = \\frac{T_{\\mathrm{staged}}}{T_{\\mathrm{fused}}} = \\frac{s (t_{\\mathrm{g}} + t_{\\mathrm{s}} + t_{\\mathrm{f}})}{s (t_{\\mathrm{g}} + t_{\\mathrm{f}})} = 1 + \\frac{t_{\\mathrm{s}}}{t_{\\mathrm{g}} + t_{\\mathrm{f}}}$$\nThis expression reveals the core trade-off. Since all time components ($t_{\\mathrm{g}}$, $t_{\\mathrm{s}}$, $t_{\\mathrm{f}}$) are non-negative, it is evident that $T_{\\mathrm{staged}} \\ge T_{\\mathrm{fused}}$, which implies $\\Theta_{\\mathrm{staged}} \\le \\Theta_{\\mathrm{fused}}$ and $\\rho \\ge 1$. The fused strategy is, under this model, always superior or equivalent in performance. The magnitude of its advantage, given by $\\rho$, depends on the shared-memory time penalty $t_{\\mathrm{s}}$ relative to the baseline time cost of global-memory access and computation, $t_{\\mathrm{g}} + t_{\\mathrm{f}}$. A large performance gain ($\\rho \\gg 1$) is expected when the shared memory access time is significant compared to the other operations, which can occur if the shared memory bandwidth $\\mathrm{BW}_{\\mathrm{s}}$ is low, or if the kernel is heavily memory-bound with very little computation (i.e., $t_{\\mathrm{g}}$ and $t_{\\mathrm{f}}$ are small). Conversely, in a compute-bound scenario where $t_{\\mathrm{f}}$ dominates, the relative cost of $t_{\\mathrm{s}}$ becomes negligible, and the performance ratio $\\rho$ approaches $1$.\n\nThis principled model is now implemented to calculate the throughputs ($\\Theta_{\\mathrm{fused}}$, $\\Theta_{\\mathrm{staged}}$) in giga-DOF per second and the performance ratio $\\rho$ for the specified test cases. The results are computed by substituting the given parameters for each case into the derived equations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates and prints the performance comparison for fused vs. staged\n    LSRK-DG implementations based on a provided performance model.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (typical memory-bound RKDG)\n        {'s': 5, 'C': 5, 'b': 8, 'B_res': 512, 'F_stage': 1000,\n         'BW_g': 1.0e12, 'BW_s': 5.0e12, 'FLOP_max': 1.0e13},\n        # Case B (shared memory is relatively slow)\n        {'s': 5, 'C': 5, 'b': 8, 'B_res': 512, 'F_stage': 1000,\n         'BW_g': 1.0e12, 'BW_s': 0.5e12, 'FLOP_max': 1.0e13},\n        # Case C (more compute-heavy stage)\n        {'s': 5, 'C': 5, 'b': 8, 'B_res': 256, 'F_stage': 10000,\n         'BW_g': 1.0e12, 'BW_s': 5.0e12, 'FLOP_max': 1.0e13},\n        # Case D (boundary case with one stage and one component)\n        {'s': 1, 'C': 1, 'b': 8, 'B_res': 64, 'F_stage': 100,\n         'BW_g': 0.5e12, 'BW_s': 5.0e12, 'FLOP_max': 1.0e13},\n    ]\n\n    results = []\n\n    def calculate_performance(params):\n        \"\"\"\n        Computes performance metrics for a single parameter set.\n        \"\"\"\n        s = params['s']\n        C = params['C']\n        b = params['b']\n        B_res = params['B_res']\n        F_stage = params['F_stage']\n        BW_g = params['BW_g']\n        BW_s = params['BW_s']\n        FLOP_max = params['FLOP_max']\n\n        # Calculate the time components per DOF per stage\n        t_g = (B_res + b * C) / BW_g\n        t_s = (2 * b * C) / BW_s\n        t_f = F_stage / FLOP_max\n        \n        # Calculate total time per DOF for s stages\n        T_fused = s * (t_g + t_f)\n        T_staged = s * (t_g + t_s + t_f)\n        \n        # Calculate throughput in DOF/s\n        theta_fused = 1.0 / T_fused\n        theta_staged = 1.0 / T_staged\n        \n        # Convert throughput to Giga-DOF/s\n        giga_dof_converter = 1e-9\n        theta_fused_g = theta_fused * giga_dof_converter\n        theta_staged_g = theta_staged * giga_dof_converter\n\n        # Calculate the performance ratio\n        # rho = T_staged / T_fused numerically more stable than theta_fused / theta_staged\n        if T_fused > 0:\n            rho = T_staged / T_fused\n        else:\n            rho = 1.0 # Should not happen with positive time components\n\n        return theta_fused_g, theta_staged_g, rho\n\n    for case in test_cases:\n        theta_fused_g, theta_staged_g, rho = calculate_performance(case)\n        \n        # Append formatted results to the list\n        results.append(f\"{theta_fused_g:.6f}\")\n        results.append(f\"{theta_staged_g:.6f}\")\n        results.append(f\"{rho:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}