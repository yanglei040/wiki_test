{
    "hands_on_practices": [
        {
            "introduction": "我们实践的第一步是掌握制造解方法（MMS）中最基本也是最关键的技能：为一个给定的偏微分方程和人造解推导源项。这个练习  使用了简单的线性平流方程，旨在揭示一个核心原则：你选择的解的性质直接决定了验证一个数值方法所需的条件。通过为一个光滑的正弦解计算源项，我们将探讨混叠效应（aliasing）如何影响谱方法和间断Galerkin（DG）方法的验证计划，从而强调了在设计数值实验时，必须确保网格或基函数能充分解析人造解及其导数。",
            "id": "3397583",
            "problem": "考虑常系数线性平流方程 $u_t + a\\,u_x = f$，定义在周期区间 $x \\in [0,2]$ 上，周期为 $2$，其中 $a$ 是一个实常数平流速度。在使用人造解方法验证谱方法和间断伽辽金 (DG) 离散化时，设人造解为 $u(x,t) = \\cos(3\\pi x)\\,\\sin(t)$。从控制方程和人造解的定义出发，推导使 $u(x,t)$ 成为精确解的强迫项 $f(x,t)$ 的解析表达式。然后，讨论在周期性边界条件下，均匀间隔点上的谱配置法的混叠效应，并概述在傅里叶谱配置法和模态多项式 DG 离散化的验证计划中应如何考虑这些因素。您的讨论应基于混叠的基本定义，并与周期区间 $[0,2]$ 一致，但不应产生除所需强迫项之外的额外计算数值输出。请以单一闭合形式的解析表达式给出最终的强迫项 $f(x,t)$。最终表达式无需四舍五入。",
            "solution": "该问题要求为线性平流方程的人造解推导强迫项，然后讨论其对使用谱方法和间断伽辽金 (DG) 方法进行数值验证的影响。\n\n控制方程是常系数线性平流方程：\n$$\nu_t + a u_x = f\n$$\n其中 $u(x,t)$ 是解变量，$t$ 是时间，$x$ 是空间坐标，$a$ 是常数平流速度，$f(x,t)$ 是源项或强迫项。空间域指定为周期区间 $x \\in [0, 2]$。\n\n给定的人造解为：\n$$\nu(x,t) = \\cos(3\\pi x)\\sin(t)\n$$\n\n第一步是推导强迫项 $f(x,t)$，使给定的人造解 $u(x,t)$ 成为控制偏微分方程 (PDE) 的精确解。这可以通过计算 $u(x,t)$ 的偏导数并将其代入 PDE 来完成。\n\n$u(x,t)$ 关于时间 $t$ 的偏导数为：\n$$\nu_t = \\frac{\\partial}{\\partial t} \\left( \\cos(3\\pi x)\\sin(t) \\right) = \\cos(3\\pi x) \\frac{d}{dt}(\\sin(t)) = \\cos(3\\pi x)\\cos(t)\n$$\n\n$u(x,t)$ 关于空间 $x$ 的偏导数为：\n$$\nu_x = \\frac{\\partial}{\\partial x} \\left( \\cos(3\\pi x)\\sin(t) \\right) = \\sin(t) \\frac{d}{dx}(\\cos(3\\pi x)) = \\sin(t) \\left( -3\\pi\\sin(3\\pi x) \\right) = -3\\pi\\sin(3\\pi x)\\sin(t)\n$$\n\n将这些导数代入平流方程 $u_t + a u_x = f$，我们可以解出 $f(x,t)$：\n$$\nf(x,t) = u_t + a u_x = \\left( \\cos(3\\pi x)\\cos(t) \\right) + a \\left( -3\\pi\\sin(3\\pi x)\\sin(t) \\right)\n$$\n化简后得到强迫项的最终解析表达式：\n$$\nf(x,t) = \\cos(3\\pi x)\\cos(t) - 3a\\pi\\sin(3\\pi x)\\sin(t)\n$$\n\n任务的第二部分是讨论使用傅里叶谱配置法和模态多项式 DG 方法进行验证时的混叠效应。\n\n对于周期区间 $[0, L]$ 上的傅里叶谱配置法，这里 $L=2$，我们使用一组 $N$ 个等距配置点 $x_j = j \\frac{L}{N}$，其中 $j=0, 1, \\dots, N-1$。如果一个函数的所有组成傅里叶模式都在网格可分辨的波数范围内，那么它就可以在该网格上无混叠地表示。域 $[0,2]$ 的基本波数为 $k_{fund} = \\frac{2\\pi}{L} = \\frac{2\\pi}{2} = \\pi$。一个通用的傅里叶模式可以写成 $\\exp(i m k_{fund} x) = \\exp(i m \\pi x)$，其中 $m$ 是整数模式数。人造解的空间分量是 $\\cos(3\\pi x)$。使用 Euler 公式，它可以写成：\n$$\n\\cos(3\\pi x) = \\frac{1}{2}\\left( \\exp(i3\\pi x) + \\exp(-i3\\pi x) \\right)\n$$\n这表明解是由整数模式数 $m=3$ 和 $m=-3$ 的傅里叶模式组成的。\n根据实值信号的 Nyquist-Shannon 采样定理，要分辨一个整数波数为 $|m|$ 的模式，网格点数 $N$ 必须满足 $N > 2|m|$。在这种情况下，要分辨模式 $m=3$，我们需要 $N > 2 \\times 3$，即 $N > 6$。如果 $N \\le 6$，就会发生混叠。例如，如果我们选择 $N=4$ 个点，模式 $m=3$ 将与模式 $m' = m - N = 3 - 4 = -1$ 发生混叠。在网格上，函数 $\\cos(3\\pi x)$ 变得与 $\\cos(\\pi x)$ 无法区分。这会破坏解及其导数的数值表示，验证测试将显示一个很大的误差平台，从而无法观察到预期的谱收敛率。\n因此，使用该人造解的傅里叶谱方法代码的验证计划必须确保收敛性研究从足够数量的点开始，例如 $N=8, 16, 32, \\dots$，以完全分辨解 $u(x,t)$ 和强迫项 $f(x,t)$（其包含相同的空间模式）中的模式。\n\n对于模态多项式间断伽辽金 (DG) 方法，域被划分为大小为 $h$ 的单元（网格）。在每个单元内，解由一个基组（例如 Legendre 多项式）中最高次数为 $p$ 的多项式来近似。PDE 的弱形式涉及在每个单元上的积分。对于给定的问题，这些被积函数包含基多项式和非多项式人造解的乘积，例如 $\\int_{\\text{cell}} \\cos(3\\pi x) P_k(x) dx$，其中 $P_k(x)$ 是一个基多项式。这些积分使用求积法则进行数值计算，通常是高斯求积，它对一定次数以下的多项式是精确的。由于被积函数不是多项式，任何有限阶的求积法则都会引入求积误差。\n在 DG 代码的验证计划中，我们通常进行 $h$-细化研究（固定 $p$ 并减小 $h$），以确认在合适的范数（例如 $L^2$）下误差的理论收敛率为 $O(h^{p+1})$。要观察到这个收敛率，数值求积的误差必须小于多项式逼近误差。如果求积法则不够精确，求积误差将占主导地位，观察到的收敛率将受到污染或停滞。\n因此，DG 方法的验证计划必须指定一个足够高阶的求积法则。通常的做法是使用一个对次数为 $2p+1$ 或更高的多项式精确的法则。这确保了对人造解非多项式部分的近似足够精确，不会干扰底层 DG 多项式逼近空间的收敛率测量。该计划必须明确说明对求积阶数的要求，以确保验证测试的有效性。",
            "answer": "$$\n\\boxed{\\cos(3\\pi x)\\cos(t) - 3a\\pi\\sin(3\\pi x)\\sin(t)}\n$$"
        },
        {
            "introduction": "在掌握了线性问题的基本操作后，我们转向一个更具挑战性也更贴近现实的领域：非线性动力学。这个练习  采用了粘性Burgers方程，它包含一个二次非线性通量项，这是导致高阶方法中数值不稳定的常见原因。通过这个实践，你将不仅仅是推导一个源项，更重要的是深入理解非线性项如何产生混叠误差，以及为什么直接离散化可能会失败，同时探索如何通过使用分裂形式（split-form）的离散格式来恢复数值稳定性，这是确保高阶格式鲁棒性的高级技巧。",
            "id": "3397542",
            "problem": "考虑一维粘性伯格斯方程，其定义在周期性域 $x \\in [0,1]$ 和时间 $t \\ge 0$ 上，\n$$\nu_{t} + \\frac{1}{2}\\left(u^{2}\\right)_{x} = \\nu\\, u_{xx} + f(x,t),\n$$\n其中 $u(x,t)$ 是未知解，$\\nu > 0$ 是给定的粘性系数，$f(x,t)$ 是一个待确定的未知强迫项。在人工解方法（MMS）中，选择人工解\n$$\nu(x,t) = \\sin\\!\\left(2\\pi x\\right)\\cos t,\n$$\n并在 $x$ 方向上施加周期性边界条件。从控制方程以及时间和空间导数的定义出发，为强迫项 $f(x,t)$ 推导出一个闭式表达式，使得 $u(x,t)$ 对于所有 $t \\ge 0$ 都是精确解。\n\n然后，运用谱方法和间断伽辽金（DG）方法的核心概念，解释为何在使用多项式基和欠积分求积时，MMS 中的非线性通量会产生混叠误差，以及为何需要使用分裂形式（也称为斜对称或熵守恒）的离散化来减轻这些误差。您的讨论应基于基本原理：非线性乘积如何提高多项式阶数，离散乘积法则在配置和欠积分下如何失效，以及分裂形式如何恢复守恒或能量稳定性的离散模拟。您可以参考分部求和（SBP）性质以及伯格斯方程的熵守恒两点通量思想，但除了标准的多项式逼近和求积概念外，不应假定任何特定的离散化细节。\n\n以 $x$、$t$ 和 $\\nu$ 的函数形式，给出强迫项 $f(x,t)$ 的最终闭式表达式。无需四舍五入，最终答案没有单位。最终答案必须是单一的解析表达式。",
            "solution": "该问题是有效的，因为它在流体动力学和数值分析领域有科学依据，是适定且客观的。它包含一个在人工解方法（MMS）中的标准推导，以及对高阶数值方法中既定原理的概念性解释的要求。\n\n该问题要求完成两个不同的任务：第一，为给定的粘性伯格斯方程人工解推导强迫项 $f(x,t)$；第二，解释基于多项式的数值方法中非线性项的混叠误差的本质，以及分裂形式离散化在减轻这些误差中的作用。\n\n**第一部分：强迫项 $f(x,t)$ 的推导**\n\n控制方程是一维粘性伯格斯方程：\n$$u_{t} + \\frac{1}{2}\\left(u^{2}\\right)_{x} = \\nu\\, u_{xx} + f(x,t)$$\n强迫项 $f(x,t)$ 可以通过整理方程分离出来：\n$$f(x,t) = u_{t} + \\frac{1}{2}\\left(u^{2}\\right)_{x} - \\nu\\, u_{xx}$$\n指定的人工解是：\n$$u(x,t) = \\sin(2\\pi x)\\cos t$$\n为了求得 $f(x,t)$，我们必须计算 $u(x,t)$ 的偏导数，并将它们代入 $f(x,t)$ 的表达式中。\n\n首先，我们计算时间导数 $u_t$：\n$$u_t = \\frac{\\partial}{\\partial t} \\left( \\sin(2\\pi x)\\cos t \\right) = \\sin(2\\pi x) (-\\sin t) = -\\sin(2\\pi x)\\sin t$$\n\n接下来，我们处理非线性对流项 $\\frac{1}{2}(u^2)_x$。这等价于 $u u_x$。我们首先求空间导数 $u_x$：\n$$u_x = \\frac{\\partial}{\\partial x} \\left( \\sin(2\\pi x)\\cos t \\right) = \\cos(2\\pi x) \\cdot 2\\pi \\cdot \\cos t = 2\\pi \\cos(2\\pi x)\\cos t$$\n现在我们可以构成乘积 $u u_x$：\n$$\\frac{1}{2}(u^2)_x = u u_x = \\left( \\sin(2\\pi x)\\cos t \\right) \\left( 2\\pi \\cos(2\\pi x)\\cos t \\right) = 2\\pi \\sin(2\\pi x)\\cos(2\\pi x)\\cos^2 t$$\n使用三角恒等式 $\\sin(2\\theta) = 2\\sin\\theta\\cos\\theta$，令 $\\theta = 2\\pi x$，我们简化此项：\n$$\\frac{1}{2}(u^2)_x = \\pi \\left( 2\\sin(2\\pi x)\\cos(2\\pi x) \\right) \\cos^2 t = \\pi \\sin(4\\pi x)\\cos^2 t$$\n\n最后，我们为粘性项计算二阶空间导数 $u_{xx}$。从 $u_x$ 开始：\n$$u_{xx} = \\frac{\\partial}{\\partial x} u_x = \\frac{\\partial}{\\partial x} \\left( 2\\pi \\cos(2\\pi x)\\cos t \\right) = 2\\pi \\cos t \\left( -\\sin(2\\pi x) \\cdot 2\\pi \\right)$$\n$$u_{xx} = -4\\pi^2 \\sin(2\\pi x)\\cos t$$\n\n现在我们将所有计算出的导数代入 $f(x,t)$ 的表达式中：\n$$f(x,t) = u_{t} + \\frac{1}{2}\\left(u^{2}\\right)_{x} - \\nu u_{xx}$$\n$$f(x,t) = \\left( -\\sin(2\\pi x)\\sin t \\right) + \\left( \\pi \\sin(4\\pi x)\\cos^2 t \\right) - \\nu\\left( -4\\pi^2 \\sin(2\\pi x)\\cos t \\right)$$\n合并各项，得到强迫项的最终闭式表达式：\n$$f(x,t) = -\\sin(2\\pi x)\\sin t + \\pi \\sin(4\\pi x)\\cos^2 t + 4\\nu\\pi^2 \\sin(2\\pi x)\\cos t$$\n\n**第二部分：混叠误差与分裂形式离散化**\n\n问题的第二部分要求解释为什么在基于多项式的方法中，MMS 中的非线性通量会导致混叠误差，以及分裂形式离散化如何解决这个问题。这一解释根植于多项式逼近、求积法则和微分算子基本性质之间的相互作用。\n\n在谱方法和间断伽辽金（DG）方法等高阶方法中，域或单元内的解 $u(x)$ 被一个阶数至多为 $N$ 的多项式 $u_N(x)$ 逼近。这种逼近可以写成基函数的和，$u_N(x) = \\sum_{j=0}^{N} \\hat{u}_j \\phi_j(x)$，其中 $\\phi_j$ 是阶数为 $j$ 的多项式。\n\n伯格斯方程中的非线性项是对流通量项 $F(u)=\\frac{1}{2}u^2$。当我们代入多项式逼近 $u_N(x)$ 时，得到 $F(u_N) = \\frac{1}{2}u_N^2(x)$。两个阶数为 $N$ 的多项式的乘积是一个阶数为 $2N$ 的多项式。因此，离散通量 $F(u_N)$ 是一个阶数为 $2N$ 的多项式，它位于阶数最高为 $N$ 的多项式的原始逼近空间之外。\n\n数值方法通常在一组离散点（称为求积点或配置点）上计算积分或强制满足微分方程。例如，DG 方法的弱形式涉及像 $\\int_K \\nabla v_N \\cdot F(u_N) dx$ 这样的积分，这些积分使用求积法则进行计算。一个常见的选择是使用 $Q$ 个点的高斯求积法则，它对阶数最高为 $2Q-1$ 的多项式是精确的。在许多实际实现中，特别是那些旨在提高计算效率（一个被称为“欠积分”的概念）的实现中，会使用不足以精确积分非线性项的求积法则。例如，如果使用的法则是仅对阶数最高为 $2N-1$ 的多项式精确的（例如，具有 $N+1$ 个点的高斯-洛巴托法则），它就不能精确地表示阶数为 $2N$ 的多项式 $u_N^2$。\n\n这种无法精确表示高阶多项式 $u_N^2$ 的情况会导致**混叠**。本应存在于阶数为 $N+1$ 到 $2N$ 的多项式模态中的能量，被错误地投影或“混叠”到数值格式可以表示的从 $0$ 到 $N$ 的低阶模态上。在配置法中，问题在于我们使用非线性项导数 $(u_N^2)_x$（其阶数为 $2N-1$）在 $N+1$ 个配置点上的值来表示它。这强制用一个低阶多项式来表示一个高阶多项式，同样导致了混叠。\n\n这种现象是**离散乘积法则失效**的直接后果。在连续情况下，链式法则表明 $(u^2)_x = 2 u u_x$。在离散情况下，如果 $D$ 是一个微分矩阵，并使用逐点相乘，通常 $D(u_N \\circ u_N) = 2 u_N \\circ (D u_N)$ 是不成立的，其中 $\\circ$ 表示在网格点上函数值向量的逐元素乘积。混叠误差正是这两个表达式之间的差异。\n\n混叠的后果通常是灾难性的：它可能导致能量虚假地、非物理地传递到高频模态，最终导致**非线性不稳定性**。在连续层面上，对于无粘伯格斯方程，对流项 $\\frac{1}{2}(u^2)_x$ 在周期性域上守恒动能 $\\int u^2 dx$。这是因为 $\\int u \\cdot \\frac{1}{2}(u^2)_x dx = \\int \\frac{1}{3}(u^3)_x dx = 0$。混叠在离散层面上破坏了这种守恒性质，使得离散能量可以无界增长。\n\n**分裂形式离散化**旨在纠正这种不稳定性。其思想是将非线性项重写为一个数学上等价但在离散化后具有更优稳定性的形式。对于伯格斯方程，标准的“守恒”形式 $\\frac{1}{2}(u^2)_x$ 可以被重写为一系列“分裂形式”：$\\alpha(u^2)_x + (1-\\alpha)uu_x$。一个特别重要的版本是斜对称形式 $\\frac{1}{3}(u^2)_x + \\frac{2}{3}uu_x$。\n\n关键的见解是，即使存在混叠，这些形式也可以被构造成相对于某个选定的范数（如对应于能量或熵的L2范数）是离散守恒或耗散的。这与**分部求和（SBP）**性质密切相关。一个 SBP 算子是模拟分部积分性质的离散微分算子。当一个斜对称公式与一个 SBP 算子结合时，得到的离散对流项作为一个矩阵算子是斜对称的，即 $(v, \\text{Conv}(u)) = -(\\text{Conv}(v), u)$，其中 $(\\cdot,\\cdot)$ 是离散内积。这意味着 $(u, \\text{Conv}(u)) = 0$，表明离散能量被精确守恒，非线性稳定性得以恢复，即使在存在欠积分混叠的情况下也是如此。\n\n从另一个角度看，这些稳定的分裂形式通常对应于由**熵守恒两点通量**构建的离散化。对于一个标量守恒律，如果一个数值通量离散地守恒某个选定的熵函数，那么它就是熵守恒的。对于伯格斯方程，自然熵是 $u^2/2$。上面给出的分裂形式可以从这样一个原理推导出来。通过在离散层面上强制执行一个基本的守恒性质，这些形式可以防止困扰标准公式的非物理能量增长，从而确保数值模拟的稳定性和鲁棒性。\n\n这种方法对MMS至关重要，因为如果数值格式非线性不稳定，由这种不稳定性引起的误差将占主导地位，使得观察预期的收敛率和正确验证代码的实现变得不可能。使用一个稳定的分裂形式离散化确保了观察到的误差是由截断误差引起的，正如MMS程序所期望的那样。",
            "answer": "$$\n\\boxed{-\\sin(2\\pi x)\\sin t + \\pi \\sin(4\\pi x)\\cos^2 t + 4\\nu\\pi^2 \\sin(2\\pi x)\\cos t}\n$$"
        },
        {
            "introduction": "最后，我们将MMS应用于一个在科学与工程计算中极为常见的复杂场景：带有不连续材料属性的问题。这个实践  模拟了一个二维扩散问题，其中扩散系数在区域内部发生跳变，形成一个材料界面。你的任务是构建一个分片多项式解，它在界面上是连续的（$C^0$），但其梯度不连续，以此来精确测试数值通量在处理界面物理条件时的正确性和一致性。这项练习展示了如何精心设计人造解来探查数值格式的特定行为，这是验证复杂多物理场代码时的一项宝贵技能。",
            "id": "3397611",
            "problem": "考虑在方形域 $\\Omega = [0,1]\\times[0,1]$ 上的二维椭圆扩散方程，其中有一条垂直材料界面 $\\Gamma = \\{(x,y)\\in\\Omega \\mid x = 0.5\\}$，该界面将 $\\Omega$ 划分为左右两个子域 $\\Omega_L = \\{(x,y)\\in\\Omega \\mid x  0.5\\}$ 和 $\\Omega_R = \\{(x,y)\\in\\Omega \\mid x  0.5\\}$。控制偏微分方程为守恒型扩散方程\n$$\n-\\nabla\\cdot\\left(k(x)\\,\\nabla u(x,y)\\right) = f(x,y) \\quad \\text{in } \\Omega,\n$$\n其中 $k(x)$ 是一个分段常数扩散系数，$u(x,y)$ 是未知的标量场，$f(x,y)$ 是一个给定的源（强迫）项。扩散系数满足：当 $(x,y)\\in\\Omega_L$ 时 $k(x) = k_L$，当 $(x,y)\\in\\Omega_R$ 时 $k(x) = k_R$，且 $k_L0$ 和 $k_R0$。在 $\\partial\\Omega$ 上的边界条件是Dirichlet类型，\n$$\nu(x,y) = u_{\\partial}(x,y),\n$$\n其中 $u_{\\partial}(x,y)$ 是给定的，并将通过制造解的方法来选择。在界面 $\\Gamma$ 两侧，通量守恒意味着满足以下界面条件\n$$\n[u] = 0 \\quad \\text{和}\\quad \\left[k\\,\\nabla u\\cdot n\\right] = 0 \\quad \\text{on } \\Gamma,\n$$\n其中 $[\\,\\cdot\\,]$ 表示跨越 $\\Gamma$ 的跳跃，而 $n$ 是指向从 $\\Omega_L$ 到 $\\Omega_R$ 的 $\\Gamma$ 的单位法向量。对于在 $x=0.5$ 处的垂直界面 $\\Gamma$，取 $n=(1,0)$。\n\n您需要制造一个分段多项式函数 $u(x,y)$，它在界面 $\\Gamma$ 上是连续的（$C^0$），但在 $\\Gamma$ 处的梯度 $\\nabla u(x,y)$ 是不连续的。令\n$$\nu_L(x,y) = a_L\\,(x-0.5)^2 + b_L\\,(x-0.5) + g(y), \\quad (x,y)\\in\\Omega_L,\n$$\n$$\nu_R(x,y) = a_R\\,(x-0.5)^2 + b_R\\,(x-0.5) + g(y), \\quad (x,y)\\in\\Omega_R,\n$$\n其中\n$$\ng(y) = c_0 + c_1\\,y + c_2\\,y^2 + c_3\\,y^3,\n$$\n且 $a_L,a_R,b_L,b_R,c_0,c_1,c_2,c_3$ 是实数参数。制造解为\n$$\nu(x,y)=\\begin{cases}\nu_L(x,y),  (x,y)\\in\\Omega_L,\\\\\nu_R(x,y),  (x,y)\\in\\Omega_R,\n\\end{cases}\n$$\n制造的边界条件是 $u_{\\partial}(x,y)=u(x,y)$ 在 $\\partial\\Omega$ 上成立。强迫项通过将扩散算子应用于制造解来分段定义，\n$$\nf(x,y)=\\begin{cases}\n-k_L\\,\\Delta u_L(x,y),  (x,y)\\in\\Omega_L,\\\\\n-k_R\\,\\Delta u_R(x,y),  (x,y)\\in\\Omega_R,\n\\end{cases}\n$$\n其中拉普拉斯算子为 $\\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$。此设置旨在测试间断Galerkin (DG) 方法在 $k$ 存在跳跃的情况下数值通量的一致性。\n\n您的程序需要执行以下验证任务：\n(1) 对于每个测试用例，按上述方式构造 $u_L$、$u_R$ 和 $g$，并在一组离散的采样点 $y\\in\\{0,\\,0.25,\\,0.5,\\,0.75,\\,1\\}$ 上计算界面法向通量残差\n$$\nR(y) = k_L\\,\\frac{\\partial u_L}{\\partial x}(0.5^{-},y) - k_R\\,\\frac{\\partial u_R}{\\partial x}(0.5^{+},y),\n$$\n然后计算最大绝对残差\n$$\n\\mathcal{R}_{\\max} = \\max_{y\\in\\{0,\\,0.25,\\,0.5,\\,0.75,\\,1\\}} \\left|R(y)\\right|.\n$$\n一个接近 $0$ 的 $\\mathcal{R}_{\\max}$ 值表明制造的界面通量连续性条件得到满足；一个非零的 $\\mathcal{R}_{\\max}$ 则为测试鲁棒性提供了一个受控的不一致性。\n\n(2) 在内部，通过上述公式计算分段强迫项 $f(x,y)$（不需要输出 $f$），从而确保制造解在每个子域内满足具有给定 $k$ 的扩散方程。\n\n所有量都是无量纲的；不涉及物理单位和角度单位。\n\n使用以下测试套件，每个测试用例由 $(k_L,k_R,a_L,a_R,b_L,b_R,c_0,c_1,c_2,c_3)$ 指定：\n案例 A（典型对比度，构造上通量一致）：\n$(\\,1.0,\\,5.0,\\,1.0,\\,-1.0,\\,2.0,\\,0.4,\\,0.0,\\,1.0,\\,0.5,\\,0.25\\,)$.\n案例 B（高对比度，构造上通量一致，降低了 $y$ 的多项式次数）：\n$(\\,0.1,\\,10.0,\\,0.0,\\,2.0,\\,3.0,\\,0.03,\\,1.0,\\,0.0,\\,0.25,\\,0.0\\,)$.\n案例 C（中等对比度，有意构造成通量不一致）：\n$(\\,2.0,\\,3.0,\\,1.5,\\,-0.5,\\,1.0,\\,1.0,\\,0.5,\\,-1.0,\\,0.1,\\,-0.2\\,)$.\n\n您的程序应生成单行输出，其中包含案例 A、B 和 C 的 $\\mathcal{R}_{\\max}$ 值，按顺序排列，形式为用方括号括起来的逗号分隔列表（例如，$[r_A,r_B,r_C]$）。每个条目必须是浮点数。程序必须是完全自包含的，并且不需要任何输入。",
            "solution": "问题陈述已经过验证，并被确定为是合理的。它在科学上基于偏微分方程理论和用于数值验证的制造解方法。该问题是适定的、客观的且自包含的，提供了计算所需量的所有必要定义、参数和公式。此设置，包括一个“有意构造成通量不一致”的案例，是测试像间断Galerkin方法这类数值方法的鲁棒性的标准且有效的技术。\n\n主要任务是为三个不同的测试用例计算最大绝对界面通量残差 $\\mathcal{R}_{\\max}$。残差 $R(y)$ 在界面 $\\Gamma$（即 $x=0.5$ 处）定义为：\n$$\nR(y) = k_L\\,\\frac{\\partial u_L}{\\partial x}(0.5^{-},y) - k_R\\,\\frac{\\partial u_R}{\\partial x}(0.5^{+},y)\n$$\n左右子域 $\\Omega_L$ 和 $\\Omega_R$ 的制造解由下式给出：\n$$\nu_L(x,y) = a_L\\,(x-0.5)^2 + b_L\\,(x-0.5) + g(y)\n$$\n$$\nu_R(x,y) = a_R\\,(x-0.5)^2 + b_R\\,(x-0.5) + g(y)\n$$\n其中 $g(y) = c_0 + c_1\\,y + c_2\\,y^2 + c_3\\,y^3$。\n\n我们首先计算 $u_L$ 关于 $x$ 的偏导数：\n$$\n\\frac{\\partial u_L}{\\partial x}(x,y) = \\frac{\\partial}{\\partial x} \\left[ a_L\\,(x-0.5)^2 + b_L\\,(x-0.5) + g(y) \\right] = 2a_L\\,(x-0.5) + b_L\n$$\n为了找到来自左子域在界面处的通量，我们计算当 $x$ 从下方趋近于 $0.5$（$x \\to 0.5^{-}$）时该导数的极限：\n$$\n\\frac{\\partial u_L}{\\partial x}(0.5^{-},y) = \\lim_{x\\to 0.5^{-}} \\left( 2a_L\\,(x-0.5) + b_L \\right) = b_L\n$$\n类似地，对于右子域，$u_R$ 关于 $x$ 的偏导数是：\n$$\n\\frac{\\partial u_R}{\\partial x}(x,y) = \\frac{\\partial}{\\partial x} \\left[ a_R\\,(x-0.5)^2 + b_R\\,(x-0.5) + g(y) \\right] = 2a_R\\,(x-0.5) + b_R\n$$\n来自右子域在界面处的通量通过计算当 $x$ 从上方趋近于 $0.5$（$x \\to 0.5^{+}$）时该导数的极限得到：\n$$\n\\frac{\\partial u_R}{\\partial x}(0.5^{+},y) = \\lim_{x\\to 0.5^{+}} \\left( 2a_R\\,(x-0.5) + b_R \\right) = b_R\n$$\n将这些表达式代入残差 $R(y)$ 的定义中：\n$$\nR(y) = k_L b_L - k_R b_R\n$$\n一个关键的观察是，对于所选的 $u_L$ 和 $u_R$ 的多项式形式，界面通量残差 $R(y)$ 是一个常数，与变量 $y$ 无关。这极大地简化了 $\\mathcal{R}_{\\max}$ 的计算。问题要求在一组离散的点 $y\\in\\{0,\\,0.25,\\,0.5,\\,0.75,\\,1\\}$ 上计算最大绝对残差。由于 $R(y)$ 是常数，其最大绝对值就是该常数本身的绝对值：\n$$\n\\mathcal{R}_{\\max} = \\max_{y\\in\\{0,..,1\\}} |R(y)| = |k_L b_L - k_R b_R|\n$$\n我们现在将此公式应用于三个测试用例中的每一个。\n\n案例 A：参数为 $(k_L, k_R, b_L, b_R) = (1.0, 5.0, 2.0, 0.4)$。\n$$\n\\mathcal{R}_{\\max, A} = |(1.0) \\cdot (2.0) - (5.0) \\cdot (0.4)| = |2.0 - 2.0| = |0.0| = 0.0\n$$\n这个结果证实了问题描述中案例A是“构造上通量一致”的说法。\n\n案例 B：参数为 $(k_L, k_R, b_L, b_R) = (0.1, 10.0, 3.0, 0.03)$。\n$$\n\\mathcal{R}_{\\max, B} = |(0.1) \\cdot (3.0) - (10.0) \\cdot (0.03)| = |0.3 - 0.3| = |0.0| = 0.0\n$$\n这也证实了案例B是“构造上通量一致”的描述。\n\n案例 C：参数为 $(k_L, k_R, b_L, b_R) = (2.0, 3.0, 1.0, 1.0)$。\n$$\n\\mathcal{R}_{\\max, C} = |(2.0) \\cdot (1.0) - (3.0) \\cdot (1.0)| = |2.0 - 3.0| = |-1.0| = 1.0\n$$\n这个非零结果证实了案例C是“有意构造成通量不一致”的描述，为跨界面的法向通量提供了一个受控的跳跃。\n\n最终要报告的值是 $\\mathcal{R}_{\\max, A}=0.0$、$\\mathcal{R}_{\\max, B}=0.0$ 和 $\\mathcal{R}_{\\max, C}=1.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum absolute interface flux residual for three test cases\n    of a manufactured solution to a 2D elliptic diffusion equation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (k_L, k_R, a_L, a_R, b_L, b_R, c_0, c_1, c_2, c_3)\n    test_cases = [\n        # Case A: (1.0, 5.0, 1.0, -1.0, 2.0, 0.4, 0.0, 1.0, 0.5, 0.25)\n        (1.0, 5.0, 1.0, -1.0, 2.0, 0.4, 0.0, 1.0, 0.5, 0.25),\n        # Case B: (0.1, 10.0, 0.0, 2.0, 3.0, 0.03, 1.0, 0.0, 0.25, 0.0)\n        (0.1, 10.0, 0.0, 2.0, 3.0, 0.03, 1.0, 0.0, 0.25, 0.0),\n        # Case C: (2.0, 3.0, 1.5, -0.5, 1.0, 1.0, 0.5, -1.0, 0.1, -0.2)\n        (2.0, 3.0, 1.5, -0.5, 1.0, 1.0, 0.5, -1.0, 0.1, -0.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for the current case.\n        # Only k_L, k_R, b_L, b_R are needed for the residual calculation.\n        k_L, k_R, _, _, b_L, b_R, _, _, _, _ = case\n        \n        # The interface normal flux residual R(y) is defined as:\n        # R(y) = k_L * (∂u_L/∂x)(0.5⁻, y) - k_R * (∂u_R/∂x)(0.5⁺, y)\n        #\n        # For the given piecewise polynomial forms:\n        # u_L(x,y) = a_L*(x-0.5)² + b_L*(x-0.5) + g(y)\n        # u_R(x,y) = a_R*(x-0.5)² + b_R*(x-0.5) + g(y)\n        #\n        # The partial derivatives with respect to x at the interface are:\n        # (∂u_L/∂x)(0.5⁻, y) = b_L\n        # (∂u_R/∂x)(0.5⁺, y) = b_R\n        #\n        # Therefore, the residual simplifies to a constant independent of y:\n        # R(y) = k_L * b_L - k_R * b_R\n        \n        residual = k_L * b_L - k_R * b_R\n        \n        # The maximum absolute residual, R_max, is requested over a set of y points.\n        # Since the residual is constant, R_max is simply its absolute value.\n        R_max = abs(residual)\n        \n        results.append(R_max)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}