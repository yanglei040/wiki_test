{
    "hands_on_practices": [
        {
            "introduction": "这项基础练习旨在探究数值通量（间断伽辽金方法中的一个关键要素）的选择如何直接影响整个格式的稳定性。通过分析线性平流方程的空间算子谱，我们可以理解耗散与稳定性之间的权衡，并为通量参数做出明智选择以最大化允许的时间步长。这项实践对于掌握格式的代数性质与其CFL极限之间的联系至关重要。",
            "id": "3374451",
            "problem": "考虑一个周期性区域上标量场的一维线性平流问题，由偏微分方程 $u_{t} + a\\,u_{x} = 0$ 控制，其中 $a > 0$ 为恒定速度。将区域 $\\Omega = [0,L]$ 离散化为一个由 $N$ 个宽度为 $h = L/N$ 的单元组成的均匀网格。在每个单元上，使用间断 Galerkin (DG) 方法，以模态 Legendre 基和精确质量矩阵，通过 $p \\geq 1$ 次多项式来逼近 $u$。通过数值通量施加单元间的耦合：\n$$\nF^{*}(u^{-},u^{+}) = a\\,\\{u\\} \\;-\\; \\frac{a\\,\\theta}{2}\\,[u], \\quad \\theta \\in [0,1],\n$$\n其中 $\\{u\\} = \\tfrac{1}{2}(u^{-} + u^{+})$ 和 $[u] = u^{+} - u^{-}$ 分别表示每个界面上的平均和跳跃，上标 $-$ 和 $+$ 分别表示来自左侧和右侧单元的迹。假设为周期性边界条件。\n\n跨单元采用 Fourier 模态 ansatz $u^{n}(x,t) = \\widehat{u}(x,t)\\,\\exp(i\\,n\\,\\xi)$，其中 $n$ 为单元索引，$\\xi \\in [0,2\\pi)$ 为无量纲波数。由于块循环结构，半离散 DG 算子对于每个 $\\xi$ 可对角化为一个 $(p+1)\\times(p+1)$ 矩阵，其特征值 $\\lambda_{j}(\\xi;\\theta,p)$（DG Fourier 符号）决定了稳定性。使用三阶强稳定性保持 Runge–Kutta 方法（SSP-RK3）进行时间推进，并回想一下，线性稳定性要求缩放后的特征值 $z_{j} = \\Delta t\\,\\lambda_{j}(\\xi;\\theta,p)$ 位于 SSP-RK3 的绝对稳定区域 $\\{z \\in \\mathbb{C} : |R(z)| \\leq 1\\}$ 内，其中 $R(z)$ 是该方法的稳定性多项式。\n\n基于以上基础：\n- 推导参数 $\\theta$ 如何通过引入一个与界面跳跃成正比的实部（耗散）平移来修改 DG Fourier 符号，并根据其实部和虚部来刻画每个 $\\xi$ 的符号，强调实部对 $\\theta$ 的单调依赖性。\n- 使用区间上 $p$ 次多项式的精确逆不等式和界面耦合结构，将谱的大小限定为一个与 $(2p+1)\\,a/h$ 成正比的常数。解释此缩放关系如何进入显式时间步进的 Courant–Friedrichs–Lewy (CFL) 限制中。\n- 使用 SSP-RK3 绝对稳定区域，将允许的时间步长 $\\Delta t$ 与符号在复平面中的朝向联系起来，并量化由 $\\theta$ 引起的负实部平移的增加如何影响允许的 $\\Delta t$ 与 $p$ 的关系。\n\n找出 $\\theta \\in [0,1]$ 中的唯一值，该值在此均匀网格上，对于所有多项式次数 $p \\geq 1$，在 SSP-RK3 方法下能使允许的 $\\Delta t$ 最大化。您的最终答案必须是一个单一的实数。无需四舍五入。如果在推导过程中产生了任何关于稳定区域交点的中间数值，请保持它们的符号形式，并且不要在最终答案中包含物理单位。",
            "solution": "首先评估问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n- **控制方程**：$u_{t} + a\\,u_{x} = 0$，用于标量场 $u$，平流速度 $a > 0$ 为常数。\n- **区域与离散化**：一个一维周期性区域 $\\Omega = [0,L]$ 被一个由 $N$ 个宽度为 $h = L/N$ 的单元组成的均匀网格离散化。\n- **数值方法**：使用间断 Galerkin (DG) 方法，每个单元上的近似为 $p \\geq 1$ 次多项式。基底为模态 Legendre 基，质量矩阵为精确计算。\n- **数值通量**：界面处的通量由 $F^{*}(u^{-},u^{+}) = a\\,\\{u\\} \\;-\\; \\frac{a\\,\\theta}{2}\\,[u]$ 给出，其中 $\\{u\\} = \\tfrac{1}{2}(u^{-} + u^{+})$ 是平均值，$[u] = u^{+} - u^{-}$ 是跳跃，$\\theta \\in [0,1]$ 是一个参数。\n- **分析框架**：采用 Fourier 模态 ansatz $u^{n}(x,t) = \\widehat{u}(x,t)\\,\\exp(i\\,n\\,\\xi)$，其中 $n$ 是单元索引，$\\xi$ 是无量纲波数。这将半离散算子简化为对每个 $\\xi$ 的一个 $(p+1)\\times(p+1)$ 矩阵，其特征值记为 $\\lambda_{j}(\\xi;\\theta,p)$。\n- **时间积分**：使用三阶强稳定性保持 Runge–Kutta (SSP-RK3) 方法。\n- **稳定性条件**：线性稳定性要求 $z_{j} = \\Delta t\\,\\lambda_{j}(\\xi;\\theta,p)$ 位于 SSP-RK3 的绝对稳定区域内，该区域定义为 $\\{z \\in \\mathbb{C} : |R(z)| \\leq 1\\}$，其中 $R(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6}$ 是稳定性多项式。\n- **指导信息**：问题陈述通过以下建议来指导分析：(1) $\\theta$ 为 DG Fourier 符号引入一个实部的、耗散的平移；(2) 谱的大小受一个与 $(2p+1)\\,a/h$ 成正比的项的限制；(3) 这种缩放关系进入了显式时间步进格式的 Courant–Friedrichs–Lewy (CFL) 限制中。\n- **目标**：找出 $\\theta \\in [0,1]$ 中的唯一值，该值对所有多项式次数 $p \\geq 1$ 都能使允许的时间步长 $\\Delta t$ 最大化。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学基础扎实**：该问题牢固地植根于偏微分方程数值方法的理论，特别是双曲守恒律的间断 Galerkin 方法的稳定性分析。所有概念——DG 方法、数值通量、Fourier 分析（von Neumann 分析）和 SSP-RK 方法——在计算科学中都是标准的、成熟的概念。\n- **适定的**：问题是适定的。它要求在一个明确定义的准则（最大化稳定时间步长 $\\Delta t$）和一组特定约束（DG 离散、SSP-RK3 时间积分、对所有 $p \\ge 1$ 稳定）下，优化一个参数（$\\theta$）。\n- **客观的**：问题以精确的数学语言陈述，没有主观或模糊的术语。\n- **完整性和一致性**：问题提供了进行分析所需的所有必要组成部分：偏微分方程、离散化细节、数值通量、时间积分器和稳定性准则。内部没有矛盾。\n\n### 步骤 3：结论与行动\n问题有效。将提供一个完整、合理的解答。\n\n### 解答\n问题要求找出参数 $\\theta \\in [0,1]$ 的值，该值对于线性平流方程的 DG 离散，在使用 SSP-RK3 方法进行时间积分时，对所有多项式次数 $p \\ge 1$ 都能使允许的时间步长 $\\Delta t$ 最大化。\n\n在均匀周期网格上，线性平流方程的半离散 DG 格式可表示为一个常微分方程组：\n$$ \\frac{d\\vec{u}}{dt} = \\mathcal{L}_{DG}\\vec{u} $$\n其中 $\\vec{u}$ 是全局自由度向量，$\\mathcal{L}_{DG}$ 是空间离散算子。显式时间步进格式的稳定性取决于该算子的特征值 $\\lambda_j$。Fourier 分析通过对 $\\mathcal{L}_{DG}$ 进行块对角化来简化此问题，使我们能够针对每个无量纲波数 $\\xi$ 研究一个 $(p+1)\\times(p+1)$ 矩阵。其特征值 $\\lambda_j(\\xi; \\theta, p)$ 构成了 DG Fourier 符号。\n\n首先，我们刻画参数 $\\theta$ 对这些特征值的影响。数值通量 $F^{*}(u^{-},u^{+}) = a\\,\\{u\\} \\;-\\; \\frac{a\\,\\theta}{2}\\,[u]$ 在 $\\theta=0$ 时退化为中心通量 $a\\{u\\}$，而在 $\\theta=1$ 时则变为迎风通量 $a u^-$（对于 $a>0$）。当 $\\theta=0$ 时，使用中心通量的 DG 格式在合适的内积下是反伴随的（skew-adjoint），其算子 $\\mathcal{L}_{DG}$ 的特征值 $\\lambda_j(\\xi; 0, p)$ 是纯虚数。当 $\\theta$ 从 $0$ 增加到 $1$ 时，通量中引入了迎风类型的耗散。这个耗散项会使空间算子的特征值向复平面的左半部分移动，即为其增加负实部。因此，$\\theta$ 控制着谱的位置：$\\theta=0$ 将谱约束在虚轴上，而增加 $\\theta$ 则会将其推入左半平面。\n\n问题陈述指出，对于显式时间步进格式，稳定性要求 $\\Delta t |\\lambda_{\\max}| \\leq C_{\\text{stab}}$，其中 $C_{\\text{stab}}$ 是由该格式的稳定区域决定的常数。根据给定的缩放关系 $|\\lambda_{\\max}| \\propto (2p+1)a/h$，CFL 条件变为：\n$$ \\frac{a \\Delta t}{h} \\le \\frac{C_{\\text{stab}}}{C(2p+1)} $$\n对于某些常数 $C$ 和 $C_{\\text{stab}}$。这表明随着多项式次数 $p$ 的增加，时间步长的限制变得更加严格。\n\n问题的核心在于 DG 谱与 SSP-RK3 稳定区域之间的相互作用。稳定性条件是缩放后的特征值集合 $\\{ z_j = \\Delta t \\lambda_j \\}$ 必须包含在 $\\mathcal{S}_{RK3} = \\{ z \\in \\mathbb{C} : |R(z)| \\le 1 \\}$ 中。$\\mathcal{S}_{RK3}$ 的形状至关重要。\n- 它关于实轴对称。\n- 它与虚轴的交集是区间 $[-i\\sqrt{3}, i\\sqrt{3}]$。\n- 它与负实轴的交集是近似区间 $[-2.5127, 0]$。\n与沿负实轴的延伸范围相比，该区域沿虚轴的方向明显更窄。\n\n让我们分析对于不同的 $\\theta$ 和大的 $p$ 值的行为：\n- **情况 $\\theta=0$（中心通量）**：谱 $\\{\\lambda_j\\}$ 完全位于虚轴上。谱半径随 $p$ 缩放；我们记作 $\\omega_{\\max}(p) \\propto (2p+1)a/h$。稳定性条件为 $\\Delta t \\, \\omega_{\\max}(p) \\le \\sqrt{3}$。允许的时间步长受到 $\\mathcal{S}_{RK3}$ 沿虚轴的狭窄范围的严重限制。CFL 数 $\\frac{a \\Delta t}{h}$ 按 $1/(2p+1)$ 的比例缩放。\n\n- **情况 $\\theta \\in [0, 1)$（混合通量）**：对于任何小于 $1$ 的 $\\theta$ 值，数值通量都保留了中心通量的分量。算子 $\\mathcal{L}_{DG}(\\theta)$ 可以看作是反伴随中心通量算子的一个扰动。对于大的 $p$，中心通量算子的高频模式主导了谱的虚部范围。因此，对于任何 $\\theta  1$，大 $p$ 值的谱将在虚轴方向（或其附近）延伸很远。允许的时间步长将继续受到 SSP-RK3 稳定区域在虚轴周围的“窄颈”的限制。最大允许 Courant 数仍将按 $1/(2p+1)$ 缩放，其比例常数取决于 $\\theta$，但由于谱的虚部很大，这种缩放仍然具有根本性的限制。\n\n- **情况 $\\theta=1$（迎风通量）**：当 $\\theta=1$ 时，中心通量分量被完全消除。数值通量变为完全迎风通量 $F^* = a u^-$。DG 谱的性质发生了根本性改变。已知迎风格式的特征值位于复平面左半部分一个与原点相切的圆形或心形区域内。关键是，对于大的 $p$，这个谱足迹不会沿虚轴无限延伸。相反，整个缩放后的谱 $\\frac{h}{a(2p+1)}\\sigma_p(1)$ 仍然局限于一个有界区域内。这个有界区域能更有效地“嵌入”到 SSP-RK3 稳定区域较宽的部分，远离了限制性的虚轴。由此产生的 CFL 限制，虽然仍然按 $1/(2p+1)$ 缩放，但在大 $p$ 的极限下，其比例常数比任何 $\\theta  1$ 的情况都要大得多。\n\n问题要求找到一个单一的 $\\theta$ 值，该值能对*所有* $p \\ge 1$ 最大化允许的 $\\Delta t$。对于任何 $\\theta'  1$ 的选择，我们都可以找到一个足够大的多项式次数 $p$，使得由大的虚部特征值（源于残余的中心通量分量）施加的时间步长限制比纯迎风格式（$\\theta=1$）的限制更为严格。在 $p \\to \\infty$ 的极限下，$\\theta=1$ 与任何 $\\theta'  1$ 的允许时间步长之比趋于无穷大。因此，为了确保在所有多项式次数上（特别是对于高阶方法）都有一个鲁棒且不过于严格的 CFL 条件，唯一合理的选择是完全消除限制性行为的来源，即中心通量分量。这通过设置 $\\theta=1$ 来实现。\n\n这个选择在以下意义上最大化了允许的 $\\Delta t$：它为大的 $p$ 提供了最佳的渐进行为缩放，使其成为旨在适用于所有 $p \\ge 1$ 的方法的更优选择。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "这项实践从理想化的线性问题深入到非线性方程的复杂性中，特别是在谱元法中因积分点不足而产生的混叠不稳定性挑战。你将推导不精确积分如何引入非物理的能量增长，从而有效地收紧CFL条件，并量化这种惩罚。这个练习提供了一个关键的教训：即实际的实现选择会如何削弱理论上的稳定性，以及为何充分的超积分对于稳健的非线性模拟至关重要。",
            "id": "3374378",
            "problem": "考虑在长度为 $L$ 的周期性区域上的标量守恒律 $u_{t} + \\partial_{x} f(u) = 0$，其通量为 $f(u) = \\alpha\\,u + \\tfrac{1}{2}u^{2}$（带有线性偏差的非线性平流）。使用节点间断伽辽金谱元法 (DGSEM) 在一个包含 $N_{e}$ 个单元的均匀网格上进行离散化，单元尺寸为 $h=L/N_{e}$，多项式次数为 $p$，并采用勒让德-高斯-洛巴托 (LGL) 节点。令数值表面通量为迎风黎曼通量，使用特征速度界 $a_{\\max} := \\max_{x,t} |f'(u)|$ 计算。对于半离散格式，采用每个单元 $Q$ 个点的求积法则计算体积分，并考虑使用三阶强稳定保持龙格-库塔 (SSPRK(3,3)) 方法进行显式时间积分，该方法在负实轴上的绝对稳定区间半径为 $r_{s}=2$。\n\n您将分析当非线性体积分项被欠积分（即 $Q=p+1$）时，Courant–Friedrichs–Lewy (CFL) 稳定性条件与混叠之间的相互作用，并展示充分的过积分如何消除混叠罚项。\n\n在单元上的 $L^{2}$ 能量框架下进行分析，利用 LGL 配置的分部求和 (SBP) 性质和迎风通量来控制界面贡献。假设在每个单元 $K$ 上，标准逆不等式在常数为1的映射物理坐标中成立，\n$$\n\\|\\partial_{x} v\\|_{L^{2}(K)} \\le \\frac{(p+1)^{2}}{h}\\,\\|v\\|_{L^{2}(K)} \\quad \\text{for all } v \\in \\mathbb{P}_{p}(K),\n$$\n并通过到 $\\mathbb{P}_{p}(K)$ 上的 $L^{2}$ 正交投影 $\\Pi_{p}$ 来对欠积分引起的被积函数混叠进行建模：对于乘积 $g(u):=f'(u)\\,u$，求积缺陷在体积分项中表现为 $(I-\\Pi_{p})g(u)$。令未解析能量分数 $\\theta \\in [0,1]$ 定义为\n$$\n\\theta := \\frac{\\sum_{K} \\|(I-\\Pi_{p})u\\|_{L^{2}(K)}^{2}}{\\sum_{K} \\|u\\|_{L^{2}(K)}^{2}},\n$$\n并假设对于二次非线性， $g(u)$ 的未解析部分可以被一个与 $a_{\\max}$ 和 $u$ 的未解析能量成比例的界所约束，即\n$$\n\\sum_{K} \\|(I-\\Pi_{p})g(u)\\|_{L^{2}(K)} \\le a_{\\max}\\,\\theta^{1/2}\\,\\Big(\\sum_{K}\\|u\\|_{L^{2}(K)}^{2}\\Big)^{1/2}.\n$$\n\n仅从这些假设和 DGSEM 的 SBP 能量方法出发：\n- 在已解析（无混叠）情况下，通过关联界面耗散和离散迹/逆不等式，推导平流算子的标称半离散谱半径 $\\rho_{\\mathrm{nom}}$ 的一个上界，其尺度关系为 $(2p+1)a_{\\max}/h$。\n- 证明欠积分的非线性体积分项会产生一个非负的能量，该能量可以被一个加到标称谱半径上的有效混叠罚项 $\\sigma_{\\mathrm{alias}}$ 所约束，其界为\n$$\n\\sigma_{\\mathrm{alias}} \\le \\frac{(p+1)^{2}}{h}\\,a_{\\max}\\,\\theta.\n$$\n- 总结出 SSPRK(3,3) 的一个保守显式步长限制，形式为\n$$\n\\Delta t_{\\max} \\le \\frac{r_{s}}{\\rho_{\\mathrm{nom}}+\\sigma_{\\mathrm{alias}}}.\n$$\n- 最后，论证为什么使用 $Q\\ge 2p$ 的过积分会使得二次乘积在 $\\mathbb{P}_{p}$ 上的投影精确，即 $(I-\\Pi_{p})g(u)=0$，从而恢复 $\\sigma_{\\mathrm{alias}}=0$ 和标称CFL条件。\n\n对以下具体参数和模型选择，评估最大稳定时间步长：\n- 区域长度 $L=1$，$N_{e}=20$ 个单元，因此 $h=1/20$。\n- 多项式次数 $p=5$，体积分和面积分均使用 LGL 配置。\n- 线性系数 $\\alpha=1$，解的振幅先验界为 $|u(x,t)|\\le U_{\\max}=0.5$，因此 $a_{\\max}=\\alpha+U_{\\max}$。\n- 体积分项使用 $Q=p+1$ 进行欠积分。\n- 未解析能量分数 $\\theta=0.2$。\n- SSPRK(3,3) 的 $r_{s}=2$。\n\n将您的最终答案表示为单个无量纲数 $\\Delta t_{\\max}$，并四舍五入到四位有效数字。",
            "solution": "该问题要求对一个标量守恒律的间断伽辽金谱元法 (DGSEM) 进行稳定性分析，包括欠积分所导致的混叠效应，并计算一个特定情况下的最大稳定时间步长。\n\n问题陈述已经过验证，被认为是有效的。它在科学上基于偏微分方程的数值分析，作为一个推导后进行计算的序列，其问题是适定的，并且以客观、正式的语言陈述。所有必要的数据和模型假设均已提供。\n\n分析过程遵循问题中概述的四个推导步骤。\n\n首先，我们推导在没有混叠情况下的标称半离散谱半径 $\\rho_{\\mathrm{nom}}$ 的一个上界。半离散方程为 $\\frac{d}{dt}u_h = \\mathcal{L}_h(u_h)$，其中 $\\mathcal{L}_h$ 是空间离散算子。显式时间步进格式的稳定性取决于 $\\mathcal{L}_h$ 的谱半径。对于利用分部求和 (SBP) 性质的 DGSEM 格式，特别是那些基于勒让德-高斯-洛巴托 (LGL) 节点的格式，已知其对能量演化 $\\frac{d}{dt}\\|u_h\\|^2$ 的体积分贡献可以构造成斜对称的。因此，稳定性由单元界面上的数值通量决定。对于迎风通量，这会导致耗散。对于线性平流方程 $u_t + a u_x = 0$，完整算子的谱半径受离散微分算子和界面耦合性质的约束。对于 LGL 节点上的 DGSEM 格式，一个标准结果是算子的谱半径受最大波速 $a_{\\max}$ 以及一个依赖于多项式次数 $p$ 和单元尺寸 $h$ 的因子的约束。该因子源于对离散算子范数的界定，这涉及到迹不等式，对于 LGL 节点集，迹不等式将单元边界上的值与单元内部的范数关联起来。对于与之密切相关的分裂形式 DGSEM，其谱半径的一个尖锐估计给出了一个与 $(2p+1)$ 成正比的界。根据问题的指引，我们采用这种尺度关系。因此，已解析情况下的标称谱半径 $\\rho_{\\mathrm{nom}}$ 的界为：\n$$\n\\rho_{\\mathrm{nom}} \\le \\frac{(2p+1)a_{\\max}}{h}\n$$\n为了保守估计，我们将其视为等式，得到 $\\rho_{\\mathrm{nom}} = \\frac{(2p+1)a_{\\max}}{h}$。\n\n其次，我们分析由于欠积分（即求积点数 $Q=p+1$ 不足以精确计算非线性体积分）而产生的混叠效应。在一个单元 $K$ 上，离散能量的变化率可以通过在弱形式中将测试函数设为解 $u_h$ 得到：\n$$\n\\frac{1}{2}\\frac{d}{dt}\\|u_h\\|^2_{h,K} = (\\partial_x u_h, f(u_h))_{Q,K} - [u_h^* \\hat{f}]_{\\partial K}\n$$\n其中 $(\\cdot,\\cdot)_{Q,K}$ 是基于 $Q$ 点求积法则的内积。在没有混叠的情况下，体积分项 $\\sum_K (\\partial_x u_h, f(u_h))_{\\text{exact},K}$ 与表面项结合以确保能量稳定（或对于非守恒通量，能量有界增长）。在欠积分情况下，通量的非线性部分 $f(u) = \\alpha u + \\frac{1}{2}u^2$ 会产生求积误差。这个误差会引入一个非物理的能量产生项。问题通过考虑其非守恒形式的项来对此进行建模，即 $-\\int u_h \\partial_x f(u_h) dx = -\\int u_h f'(u_h) \\partial_x u_h dx$。令 $g(u_h) = u_h f'(u_h)$。此项求积中的混叠误差，记为 $P_{\\mathrm{alias}}$，是可以被约束的。遵循问题的物理直觉，这个能量产生项被建模为 $g(u_h)$ 的混叠部分与解的导数 $\\partial_x u_h$ 之间的相互作用。\n$$\nP_{\\mathrm{alias}} \\approx \\sum_K \\left( (I-\\Pi_p)g(u_h), \\partial_x u_h \\right)_{Q,K}\n$$\n其中 $\\Pi_p$ 是到多项式空间 $\\mathbb{P}_p(K)$ 上的 $L^2$ 投影。使用柯西-施瓦茨不等式、离散求积范数与连续 $L^2$ 范数之间的范数等价性以及给定的每个单元上的逆不等式，我们对该项进行约束：\n$$\nP_{\\mathrm{alias}} \\le \\sum_K \\|(I-\\Pi_p)g(u_h)\\|_{L^2(K)} \\|\\partial_x u_h\\|_{L^2(K)} \\le \\sum_K \\|(I-\\Pi_p)g(u_h)\\|_{L^2(K)} \\frac{(p+1)^2}{h} \\|u_h\\|_{L^2(K)}\n$$\n为了继续推导，我们对所有单元 $K$ 的和应用柯西-施瓦茨不等式：\n$$\nP_{\\mathrm{alias}} \\le \\frac{(p+1)^2}{h} \\left( \\sum_K \\|(I-\\Pi_p)g(u_h)\\|_{L^2(K)}^2 \\right)^{1/2} \\left( \\sum_K \\|u_h\\|_{L^2(K)}^2 \\right)^{1/2}\n$$\n问题为混叠效应提供了一个特定的模型，约束了范数的和，而不是范数的平方和。遵循一条略有不同的路径，通过用总解范数约束每个单元的解范数，即 $\\|u_h\\|_{L^2(K)} \\le \\|u_h\\|_{L^2(\\Omega)}$，可以得到：\n$$\nP_{\\mathrm{alias}} \\le \\frac{(p+1)^2}{h} \\|u_h\\|_{L^2(\\Omega)} \\sum_K \\|(I-\\Pi_p)g(u_h)\\|_{L^2(K)}\n$$\n使用提供的混叠项模型 $\\sum_{K} \\|(I-\\Pi_{p})g(u)\\|_{L^{2}(K)} \\le a_{\\max}\\,\\theta^{1/2}\\,\\left(\\sum_{K}\\|u\\|_{L^{2}(K)}^{2}\\right)^{1/2}$，我们得到：\n$$\nP_{\\mathrm{alias}} \\le \\frac{(p+1)^2}{h} \\|u_h\\|_{L^2(\\Omega)} \\left( a_{\\max} \\theta^{1/2} \\|u_h\\|_{L^2(\\Omega)} \\right) = \\frac{(p+1)^2}{h} a_{\\max} \\theta^{1/2} \\|u_h\\|_{L^2(\\Omega)}^2\n$$\n这个推导得出了一个与 $\\theta^{1/2}$ 成正比的界。由于 $\\theta \\in [0,1]$，我们有 $\\theta \\le \\theta^{1/2}$。因此，问题所要求的界 $\\sigma_{\\mathrm{alias}} \\le \\frac{(p+1)^2}{h} a_{\\max} \\theta$ 代表了一个更紧的估计，这可能依赖于比这个一般性推导中所假设的更详细的二次非线性混叠机制模型。遵从问题陈述，我们采用指定的 $\\sigma_{\\mathrm{alias}}$ 的界。该项作为一个额外的能量增长率，有效地增加了算子的谱半径。\n$$\n\\sigma_{\\mathrm{alias}} = \\frac{(p+1)^{2}}{h}\\,a_{\\max}\\,\\theta\n$$\n\n第三，我们构建 CFL 条件。半离散算子的总有效谱半径受标称谱半径和混叠罚项之和的约束：$\\rho_{\\mathrm{eff}} \\le \\rho_{\\mathrm{nom}} + \\sigma_{\\mathrm{alias}}$。为了使显式时间积分方法稳定，时间步长 $\\Delta t$ 与离散算子任意特征值 $\\lambda$ 的乘积必须位于该方法的绝对稳定区域内。问题指定了一个简化的稳定性判据，基于负实轴上稳定区域的半径 $r_s$。因此我们必须满足 $\\Delta t \\cdot \\rho_{\\mathrm{eff}} \\le r_s$。这得出了保守的时间步长限制：\n$$\n\\Delta t_{\\max} \\le \\frac{r_s}{\\rho_{\\mathrm{nom}} + \\sigma_{\\mathrm{alias}}}\n$$\n\n第四，我们论证为什么充分的过积分可以消除混叠罚项。混叠误差源于非线性体积分项 $(\\partial_x u_h, f(u_h))_h$ 的不精确求积。对于给定的通量 $f(u_h) = \\alpha u_h + \\frac{1}{2}u_h^2$，被积函数是一个多项式。由于 $u_h \\in \\mathbb{P}_p$，因此 $\\partial_x u_h \\in \\mathbb{P}_{p-1}$ 且 $f(u_h) \\in \\mathbb{P}_{2p}$。所以，乘积 $(\\partial_x u_h) f(u_h)$ 是一个次数至多为 $(p-1)+2p = 3p-1$ 的多项式。一个具有 $Q$ 个点的 LGL 求积法则可以精确地积分次数高达 $2Q-1$ 的多项式。为了确保体积分精确，我们需要 $2Q-1 \\ge 3p-1$，这可以简化为 $Q \\ge \\frac{3}{2}p$。因此，对于所有 $p \\ge 1$，给定的条件 $Q \\ge 2p$ 足以保证体积分的精确计算。当积分被精确计算时，SBP 性质完全成立，由混叠引起的能量产生被消除。因此，$\\sigma_{\\mathrm{alias}}=0$，时间步长限制恢复到标称（已解析）的 CFL 条件，即 $\\Delta t_{\\max} \\le r_s / \\rho_{\\mathrm{nom}}$。问题中关于 $(I-\\Pi_p)g(u)=0$ 的表述有点不精确；过积分的关键结果是体积分的精确性，从而导致 $\\sigma_{\\mathrm{alias}}=0$。\n\n最后，我们对给定参数计算最大稳定时间步长：\n- 区域长度 $L=1$，单元数 $N_e=20$，所以单元尺寸 $h = L/N_e = 1/20 = 0.05$。\n- 多项式次数 $p=5$。\n- 通量参数 $\\alpha=1$，解的界为 $|u| \\le U_{\\max}=0.5$。特征速度为 $f'(u) = \\alpha+u = 1+u$。在解的范围内的最大绝对值为 $a_{\\max} = \\max_{u \\in [-0.5, 0.5]} |1+u| = 1+0.5 = 1.5$。\n- 未解析能量分数 $\\theta=0.2$。\n- SSPRK(3,3) 稳定半径 $r_s=2$。\n\n我们计算标称谱半径的界：\n$$\n\\rho_{\\mathrm{nom}} = \\frac{(2p+1)a_{\\max}}{h} = \\frac{(2(5)+1)(1.5)}{0.05} = \\frac{11 \\times 1.5}{0.05} = \\frac{16.5}{0.05} = 330\n$$\n接下来，我们计算混叠罚项：\n$$\n\\sigma_{\\mathrm{alias}} = \\frac{(p+1)^2}{h} a_{\\max} \\theta = \\frac{(5+1)^2}{0.05} (1.5)(0.2) = \\frac{36}{0.05} \\times 0.3 = 720 \\times 0.3 = 216\n$$\n那么最大稳定时间步长为：\n$$\n\\Delta t_{\\max} = \\frac{r_s}{\\rho_{\\mathrm{nom}} + \\sigma_{\\mathrm{alias}}} = \\frac{2}{330 + 216} = \\frac{2}{546} = \\frac{1}{273} \\approx 0.00366300366...\n$$\n四舍五入到四位有效数字，得到 $\\Delta t_{\\max} = 0.003663$。",
            "answer": "$$\\boxed{0.003663}$$"
        },
        {
            "introduction": "这项高级实践展示了如何主动利用CFL条件，不仅仅将其视为一个限制，而是作为计算自适应的指导原则。你将设计并实现一个控制器，该控制器在整个网格上动态调整多项式阶数（$p$-自适应），以平衡局部库朗数。这种“注水”方法旨在优化计算资源的使用，确保没有单个单元不必要地限制全局时间步长，从而提高模拟的整体效率。",
            "id": "3374373",
            "problem": "设计并实现一个程序，为一维间断 Galerkin 方法构建一个基于 Courant–Friedrichs–Lewy 稳定性条件的自适应多项式阶数控制器。考虑一个网格，其单元由 $K$ 索引，每个单元具有特征尺寸 $h_K$（单位：米）、局部最大特征速度 $a_K$（单位：米/秒）和局部多项式阶数 $p_K$（无量纲）。时间步长是全局的，记为 $\\Delta t$（单位：秒）。将局部 Courant 数定义为 $C_K = \\dfrac{a_K \\,\\Delta t\\, (p_K + 1)}{h_K}$，这是一个无量纲量，用于衡量数值依赖域与按局部解析度缩放后的物理依赖域之间的比率。假设一个显式时间积分器施加了一个稳定性容许阈值 $C_{\\mathrm{crit}}$（无量纲），使得对于每个单元 $K$，必要的线性稳定性条件为 $C_K \\le C_{\\mathrm{crit}}$。整数多项式阶数受 $p_{\\min} \\le p_K \\le p_{\\max}$ 的限制。\n\n从 $C_K$ 的基本定义以及 $p_K$ 对 $C_K$ 的单调效应（当 $a_K \\Delta t / h_K  0$ 时对 $p_K$ 严格递增，当 $a_K = 0$ 时为常数）出发，设计一个控制器，该控制器：\n- 在局部稳定性条件被违反的地方降低 $p_K$。\n- 在局部稳定性条件允许且 $\\Delta t$ 不是限制因素的地方提高 $p_K$。\n- 旨在约束条件下尽可能地均衡整个网格的局部 Courant 数。\n\n为了使任务适定且可通过编程测试，请实现以下精确的控制器语义，这些语义源于上述原则和均衡 Courant 数的要求：\n- 稳定化阶段：对于每个单元 $K$，当 $C_K  C_{\\mathrm{crit}}$ 且 $p_K  p_{\\min}$ 时，递减 $p_K \\leftarrow p_K - 1$ 并相应地更新 $C_K$。此阶段结束后，每个单元都满足 $C_K \\le C_{\\mathrm{crit}}$ 或 $p_K = p_{\\min}$。\n- 均衡化阶段（带稳定性的注水算法）：重复执行以下步骤，直到无法再进行任何更改：\n  - 识别符合提升条件的单元索引集合 $S$，即 $p_K  p_{\\max}$ 且增加后的 Courant 数 $C_K^{\\mathrm{new}} = \\dfrac{a_K \\,\\Delta t\\, (p_K + 2)}{h_K}$ 满足 $C_K^{\\mathrm{new}} \\le C_{\\mathrm{crit}}$。\n  - 如果 $S$ 为空，则终止。否则，在 $S$ 中选择当前 $C_K$ 最小的单元；若出现平局，则选择索引 $K$ 最小的单元。\n  - 增加其阶数：$p_K \\leftarrow p_K + 1$ 并更新 $C_K$。\n该控制器在 $C_K \\le C_{\\mathrm{crit}}$ 和 $p_{\\min} \\le p_K \\le p_{\\max}$ 的约束下，最大化了最小的 $C_K$，并强制执行确定性的平局打破规则，从而产生唯一的结果。\n\n您的程序必须精确实现上述控制器，并为每个测试用例返回两个阶段收敛后的最终整数向量 $[p_1,\\dots,p_{N}]$。所有物理量必须使用其指定的单位：$h_K$ 单位为米，$a_K$ 单位为米/秒，$\\Delta t$ 单位为秒。输出的阶数 $p_K$ 是无量纲整数。\n\n使用以下测试套件。对于每个测试用例，输入按以下顺序给出：列表 $[h_K]$、列表 $[a_K]$、初始阶数列表 $[p_K^{(0)}]$、标量 $\\Delta t$、标量 $C_{\\mathrm{crit}}$、整数 $p_{\\min}$ 和 $p_{\\max}$。所有列表均按单元索引递增排序。\n- 测试用例 A（异构网格，其中一个紧凑单元必须降阶）：$[h_K] = [0.1,\\,0.05,\\,0.2,\\,0.04,\\,0.12]$，$[a_K] = [1.0,\\,0.8,\\,1.2,\\,1.5,\\,0.5]$，$[p_K^{(0)}] = [1,\\,2,\\,1,\\,3,\\,0]$，$\\Delta t = 0.01$，$C_{\\mathrm{crit}} = 0.9$，$p_{\\min} = 0$，$p_{\\max} = 5$。\n- 测试用例 B（零速度单元，测试在 $p_{\\max}$ 处的饱和情况）：$[h_K] = [0.1,\\,0.1,\\,0.1]$，$[a_K] = [0.0,\\,1.0,\\,0.0]$，$[p_K^{(0)}] = [0,\\,0,\\,0]$，$\\Delta t = 0.02$，$C_{\\mathrm{crit}} = 0.6$，$p_{\\min} = 0$，$p_{\\max} = 7$。\n- 测试用例 C（极小单元迫使阶数降低）：$[h_K] = [0.005,\\,0.01,\\,0.03]$，$[a_K] = [2.0,\\,2.0,\\,2.0]$，$[p_K^{(0)}] = [3,\\,3,\\,3]$，$\\Delta t = 0.002$，$C_{\\mathrm{crit}} = 0.9$，$p_{\\min} = 0$，$p_{\\max} = 5$。\n- 测试用例 D（已均衡，所有单元均可提升至稳定性极限）：$[h_K] = [1.0,\\,1.0,\\,1.0,\\,1.0]$，$[a_K] = [1.0,\\,1.0,\\,1.0,\\,1.0]$，$[p_K^{(0)}] = [1,\\,1,\\,1,\\,1]$，$\\Delta t = 0.1$，$C_{\\mathrm{crit}} = 0.5$，$p_{\\min} = 0$，$p_{\\max} = 4$。\n\n您的程序应生成单行输出，其中包含所有测试用例的最终阶数列表，格式为方括号括起来的逗号分隔列表（例如 `[rA,rB,rC,rD]`），其中每个 `r·` 本身是其测试用例的整数列表 `[p_1,...,p_N]`。不应打印任何额外文本。",
            "solution": "用户提供了一个问题，要求设计并实现一个用于一维间断 Galerkin (DG) 方法的自适应多项式阶数控制器。该控制器的逻辑基于满足 Courant–Friedrichs–Lewy (CFL) 稳定性条件。\n\n### 第 1 步：提取已知条件\n- **网格单元**：由 $K$ 索引。\n- **单元尺寸**：$h_K$（米）。\n- **特征速度**：$a_K$（米/秒）。\n- **多项式阶数**：$p_K$（无量纲整数）。\n- **全局时间步长**：$\\Delta t$（秒）。\n- **局部 Courant 数**：$C_K = \\dfrac{a_K \\,\\Delta t\\, (p_K + 1)}{h_K}$。\n- **稳定性条件**：对所有 $K$，$C_K \\le C_{\\mathrm{crit}}$。\n- **稳定性阈值**：$C_{\\mathrm{crit}}$（无量纲）。\n- **阶数界限**：$p_{\\min} \\le p_K \\le p_{\\max}$。\n- **控制器逻辑**：\n    1.  **稳定化阶段**：对于每个单元 $K$，如果 $C_K  C_{\\mathrm{crit}}$ 且 $p_K  p_{\\min}$，则重复递减 $p_K$ 直到满足条件。\n    2.  **均衡化阶段**：迭代执行以下步骤，直到没有变化发生：\n        a. 识别满足 $p_K  p_{\\max}$ 且增加 $p_K$ 不会违反稳定性条件（即 $C_K^{\\mathrm{new}} = \\frac{a_K \\Delta t (p_K + 2)}{h_K} \\le C_{\\mathrm{crit}}$）的单元集合 $S$。\n        b. 如果 $S$ 为空，则终止。\n        c. 否则，从 $S$ 中选择当前 $C_K$ 最小的单元。平局由最小的索引 $K$ 打破。\n        d. 为所选单元增加 $p_K$ 并更新其 $C_K$。\n- **输入**：提供 $[h_K]$、$[a_K]$、初始 $[p_K^{(0)}]$ 列表以及标量参数 $\\Delta t$、$C_{\\mathrm{crit}}$、$p_{\\min}$、$p_{\\max}$ 的测试用例。\n- **输出**：一个列表，包含每个测试用例的最终整数阶数向量 $[p_1, \\dots, p_N]$。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题在偏微分方程的数值分析领域有坚实的基础。CFL 条件和 p-自适应 DG 方法的概念是标准的且科学有效。提供的 Courant 数 $C_K$ 公式是 DG 方法的常用模型，它与多项式阶数 $p_K$ 成比例。\n- **适定性**：控制器逻辑由一个确定性算法描述。稳定化阶段必须终止，因为 $p_K$ 是一个有下界 $p_{\\min}$ 的整数。均衡化阶段是一个在有限状态空间上运行的贪心算法（因为每个 $p_K$ 都有界），并且每一步都会单调增加其中一个 $p_K$ 的值。严格的平局打破规则确保了唯一的执行路径和唯一的最终状态。因此，存在唯一解。\n- **客观性**：问题以精确、正式的语言陈述。控制器的行为被明确定义，没有主观解释的余地。\n- **完整性与一致性**：为每个测试用例提供了所有必要的参数和初始条件。单位是一致的（$a_K \\Delta t / h_K$ 是无量纲的）。问题是自洽的，没有矛盾。\n\n### 第 3 步：结论与行动\n问题有效。这是一个基于可靠科学原理的、定义明确的计算任务。将根据指定的算法开发一个解决方案。\n\n### 算法设计\n\n该解决方案将作为一个 Python 程序实现，用于处理一系列测试用例。对于每个案例，一个函数将执行两阶段的控制器逻辑。\n\n1.  **初始化**：\n    - 输入的 $h_K$、$a_K$ 和 $p_K^{(0)}$ 列表将被转换为 NumPy 数组，以实现高效的向量化计算。将它们设为 `h`、`a` 和 `p`。\n    - 为优化性能，将为每个单元 $K$ 预计算 Courant 数计算中的常数因子 $c_{\\mathrm{factor},K} = \\dfrac{a_K \\Delta t}{h_K}$。然后 Courant 数为 $C_K = c_{\\mathrm{factor},K} (p_K + 1)$。\n    - 根据初始阶数 $p_K^{(0)}$ 计算初始 Courant 数 $C_K$。\n\n2.  **阶段 1：稳定化**：\n    - 程序将遍历每个单元 $K$。\n    - 一个 `while` 循环检查单元是否违反稳定性条件（$C_K  C_{\\mathrm{crit}}$）以及其阶数是否可以降低（$p_K  p_{\\min}$）。\n    - 如果两者都为真，则递减 $p_K$，并重新计算 $C_K$。此循环继续，直到单元稳定或其阶数达到 $p_{\\min}$。\n\n3.  **阶段 2：均衡化（注水算法）**：\n    - 此阶段在一个主 `while` 循环内实现，该循环只要至少有一个单元的阶数可以增加就继续执行。\n    - 在此主循环的每次迭代中：\n        a. 构建一个 `eligible_candidates` 列表。如果一个单元 $K$ 的阶数 $p_K$ 小于 $p_{\\max}$，并且其增加 $p_K$ 后的潜在新 Courant 数不超过 $C_{\\mathrm{crit}}$，则该单元是合格的。\n        b. 每个候选者都存储为一个元组 `(C_K, K)`，包含其当前的 Courant 数和索引。\n        c. 如果候选者列表为空，则主循环终止，因为系统已达到稳定、优化的状态。\n        d. 如果有候选者，则对列表进行排序。主排序键是 $C_K$（升序），次排序键是索引 $K$（升序）。Python 的默认排序是稳定的，当应用于通过按升序迭代索引创建的元组列表 `(value, index)` 时，会自动遵守平局打破规则。\n        e. 排序后列表中的第一个元素（$C_K$ 最小，平局时按索引打破）的阶数 $p_K$ 将被增加，并更新其 $C_K$。\n    - 这个迭代过程类似于“注水算法”，我们在稳定性约束下，贪婪地将阶数“注入”到具有最大“容量”（即最低 $C_K$）的单元中。\n\n4.  **最终输出**：\n    - 控制器收敛后，最终的 NumPy 阶数数组 `p` 将被转换回 Python 的整数列表。\n    - 所有测试用例的结果将被收集并按问题指定的格式格式化为单个字符串，例如 `[[p1,p2,...],[q1,q2,...]]`。\n\n这种设计确保了对指定确定性控制器的正确和高效实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_controller(h_k_list, a_k_list, p_k_initial_list, delta_t, c_crit, p_min, p_max):\n    \"\"\"\n    Implements the adaptive polynomial-degree controller based on the CFL condition.\n    \n    The controller operates in two phases:\n    1. Stabilization: Decrements polynomial degrees to satisfy the stability condition.\n    2. Equalization: Iteratively increases degrees for elements with the most\n       stability headroom, aiming to balance Courant numbers across the mesh.\n    \"\"\"\n    # Convert input lists to NumPy arrays for efficient vectorized operations.\n    h_k = np.array(h_k_list, dtype=np.float64)\n    a_k = np.array(a_k_list, dtype=np.float64)\n    p_k = np.array(p_k_initial_list, dtype=np.int64)\n    \n    num_elements = len(h_k)\n    \n    # Pre-calculate the constant part of the Courant number for each element.\n    # This avoids repeated floating-point divisions inside loops.\n    # Characteristic size h_k is assumed to be > 0.\n    c_factor = np.divide(a_k * delta_t, h_k, out=np.zeros_like(a_k, dtype=float), where=h_k!=0)\n\n    # Initialize local Courant numbers.\n    c_k = c_factor * (p_k.astype(np.float64) + 1.0)\n\n    # Phase 1: Stabilization\n    # For each element K, while C_K > C_crit and p_K > p_min, decrement p_K.\n    for k in range(num_elements):\n        while c_k[k] > c_crit and p_k[k] > p_min:\n            p_k[k] -= 1\n            c_k[k] = c_factor[k] * (p_k[k] + 1.0)\n\n    # Phase 2: Equalization (water-filling with stability)\n    # Repeatedly increase p_K for the most \"roomy\" eligible element.\n    while True:\n        eligible_candidates = []\n        for k in range(num_elements):\n            # Check eligibility: p_K  p_max...\n            if p_k[k]  p_max:\n                # ...and ensure the incremented Courant number is within the stability limit.\n                c_new = c_factor[k] * (p_k[k] + 2.0)\n                if c_new = c_crit:\n                    # A candidate is stored as a tuple (current C_K, index K)\n                    # for sorting according to the specified criteria.\n                    eligible_candidates.append((c_k[k], k))\n        \n        # If no elements are eligible for a degree increase, the process has converged.\n        if not eligible_candidates:\n            break\n\n        # Sort candidates to find the one with the smallest current C_K.\n        # Python's list.sort() is stable, so in case of a tie in C_K,\n        # the original order (by increasing index K) is preserved,\n        # fulfilling the tie-breaking rule.\n        eligible_candidates.sort()\n        \n        # Select the element to update (the first one after sorting).\n        k_to_increase = eligible_candidates[0][1]\n        \n        # Increase its polynomial degree and update its Courant number.\n        p_k[k_to_increase] += 1\n        c_k[k_to_increase] = c_factor[k_to_increase] * (p_k[k_to_increase] + 1.0)\n\n    return p_k.tolist()\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the controller for each case,\n    and prints the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {'h_k': [0.1, 0.05, 0.2, 0.04, 0.12], 'a_k': [1.0, 0.8, 1.2, 1.5, 0.5], 'p_k_initial': [1, 2, 1, 3, 0], 'delta_t': 0.01, 'c_crit': 0.9, 'p_min': 0, 'p_max': 5},\n        # Test Case B\n        {'h_k': [0.1, 0.1, 0.1], 'a_k': [0.0, 1.0, 0.0], 'p_k_initial': [0, 0, 0], 'delta_t': 0.02, 'c_crit': 0.6, 'p_min': 0, 'p_max': 7},\n        # Test Case C\n        {'h_k': [0.005, 0.01, 0.03], 'a_k': [2.0, 2.0, 2.0], 'p_k_initial': [3, 3, 3], 'delta_t': 0.002, 'c_crit': 0.9, 'p_min': 0, 'p_max': 5},\n        # Test Case D\n        {'h_k': [1.0, 1.0, 1.0, 1.0], 'a_k': [1.0, 1.0, 1.0, 1.0], 'p_k_initial': [1, 1, 1, 1], 'delta_t': 0.1, 'c_crit': 0.5, 'p_min': 0, 'p_max': 4}\n    ]\n\n    results = []\n    for case in test_cases:\n        final_p_k = run_controller(\n            case['h_k'],\n            case['a_k'],\n            case['p_k_initial'],\n            case['delta_t'],\n            case['c_crit'],\n            case['p_min'],\n            case['p_max']\n        )\n        results.append(final_p_k)\n\n    # Format the results into the required string format \"[[...],[...],...]\".\n    # The str() representation of a list includes brackets. Spaces are removed\n    # to match the compact output format example.\n    results_str = ','.join([str(res).replace(' ', '') for res in results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        }
    ]
}