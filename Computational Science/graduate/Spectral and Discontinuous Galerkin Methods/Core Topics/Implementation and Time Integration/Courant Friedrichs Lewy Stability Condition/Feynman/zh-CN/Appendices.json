{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在深入探讨间断Galerkin方法中数值通量格式与稳定性之间的根本联系。通过分析线性平流方程的DG算子谱，你将观察到上游参数 $\\theta$ 的选择如何直接影响在使用SSP-RK3等显式时间步进格式时的稳定性。这项练习  是理解空间离散化选择如何影响时间CFL约束，以及如何优化这些选择以获得更佳性能的关键。",
            "id": "3374451",
            "problem": "考虑周期域上一维标量场的线性平流，其控制偏微分方程为 $u_{t} + a\\,u_{x} = 0$，其中常数速度 $a  0$。将域 $\\Omega = [0,L]$ 离散化为 $N$ 个宽度为 $h = L/N$ 的均匀网格单元。在每个单元上，使用非连续伽辽金 (DG) 方法，以模态勒让德基和精确质量矩阵，通过 $p \\geq 1$ 次多项式来近似 $u$。通过数值通量施加单元间的耦合\n$$\nF^{*}(u^{-},u^{+}) = a\\,\\{u\\} \\;-\\; \\frac{a\\,\\theta}{2}\\,[u], \\quad \\theta \\in [0,1],\n$$\n其中 $\\{u\\} = \\tfrac{1}{2}(u^{-} + u^{+})$ 和 $[u] = u^{+} - u^{-}$ 分别表示每个界面上的平均值和跳跃，上标 $-$ 和 $+$ 分别表示来自左侧和右侧单元的迹。假设周期性边界条件。\n\n跨单元采用傅里叶模态 ansatz $u^{n}(x,t) = \\widehat{u}(x,t)\\,\\exp(i\\,n\\,\\xi)$，其中 $n$ 是单元索引，$\\xi \\in [0,2\\pi)$ 是无量纲波数。根据块循环结构，半离散 DG 算子对每个 $\\xi$ 对角化为一个 $(p+1)\\times(p+1)$ 矩阵，其特征值 $\\lambda_{j}(\\xi;\\theta,p)$（DG 傅里叶符号）决定了稳定性。使用三阶强保稳龙格-库塔方法 (SSP-RK3) 进行时间推进，并回顾线性稳定性要求缩放后的特征值 $z_{j} = \\Delta t\\,\\lambda_{j}(\\xi;\\theta,p)$ 位于 SSP-RK3 的绝对稳定区域 $\\{z \\in \\mathbb{C} : |R(z)| \\leq 1\\}$ 内，其中 $R(z)$ 是该方法的稳定性多项式。\n\n从这些基础出发：\n- 推导参数 $\\theta$ 如何通过引入一个与界面跳跃成比例的实部（耗散）偏移来修改 DG 傅里叶符号，并根据其实部和虚部来刻画每个 $\\xi$ 的符号，强调实部对 $\\theta$ 的单调依赖性。\n- 使用区间上 $p$ 次多项式的尖锐逆不等式和界面耦合结构，将谱幅度限制在一个与 $(2p+1)\\,a/h$ 成比例的常数内。解释此缩放关系如何进入显式时间步进的 Courant–Friedrichs–Lewy (CFL) 限制。\n- 利用 SSP-RK3 绝对稳定区域，将允许的时间步长 $\\Delta t$ 与符号在复平面中的方向联系起来，并量化由 $\\theta$ 引起的负实部偏移的增加如何影响允许的 $\\Delta t$ 与 $p$ 的关系。\n\n找出在 SSP-RK3 下，对于该均匀网格上所有多项式次数 $p \\geq 1$，能够最大化允许时间步长 $\\Delta t$ 的唯一 $\\theta \\in [0,1]$ 值。你的最终答案必须是一个实数。无需四舍五入。如果在推导过程中产生任何稳定性区域交点的中间数值，请保持其符号形式，并且不要在最终答案中包含物理单位。",
            "solution": "首先评估问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n- **控制方程**：标量场 $u$ 的方程为 $u_{t} + a\\,u_{x} = 0$，其中平流速度 $a  0$ 为常数。\n- **域与离散化**：一维周期域 $\\Omega = [0,L]$ 被离散化为 $N$ 个宽度为 $h = L/N$ 的均匀网格单元。\n- **数值方法**：使用非连续伽辽金 (DG) 方法，每个单元上的近似为 $p \\geq 1$ 次多项式。基函数为模态勒让德基，质量矩阵被精确计算。\n- **数值通量**：界面处的通量由 $F^{*}(u^{-},u^{+}) = a\\,\\{u\\} \\;-\\; \\frac{a\\,\\theta}{2}\\,[u]$ 给出，其中 $\\{u\\} = \\tfrac{1}{2}(u^{-} + u^{+})$ 是平均值，$[u] = u^{+} - u^{-}$ 是跳跃，$\\theta \\in [0,1]$ 是一个参数。\n- **分析框架**：采用傅里叶模态 ansatz $u^{n}(x,t) = \\widehat{u}(x,t)\\,\\exp(i\\,n\\,\\xi)$，其中 $n$ 是单元索引，$\\xi$ 是无量纲波数。这将半离散算子对每个 $\\xi$ 简化为一个 $(p+1)\\times(p+1)$ 矩阵，其特征值记为 $\\lambda_{j}(\\xi;\\theta,p)$。\n- **时间积分**：使用三阶强保稳龙格-库塔 (SSP-RK3) 方法。\n- **稳定性条件**：线性稳定性要求缩放后的特征值 $z_{j} = \\Delta t\\,\\lambda_{j}(\\xi;\\theta,p)$ 位于 SSP-RK3 的绝对稳定区域内，该区域定义为 $\\{z \\in \\mathbb{C} : |R(z)| \\leq 1\\}$，其中 $R(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6}$ 是稳定性多项式。\n- **引导信息**：问题陈述通过以下建议引导分析：(1) $\\theta$ 为 DG 傅里叶符号引入一个实的、耗散的偏移；(2) 谱幅度受一个与 $(2p+1)\\,a/h$ 成比例的项的限制；(3) 此缩放关系进入显式时间步进格式的 Courant–Friedrichs–Lewy (CFL) 限制。\n- **目标**：找出对于所有多项式次数 $p \\geq 1$，能最大化允许时间步长 $\\Delta t$ 的唯一 $\\theta \\in [0,1]$ 值。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题牢固地植根于偏微分方程数值方法的理论，特别是双曲守恒律的非连续伽辽金方法的稳定性分析。所有概念——DG 方法、数值通量、傅里叶分析（冯·诺依曼分析）和 SSP-RK 方法——在计算科学中都是标准且成熟的。\n- **适定性**：该问题是适定的。它要求在一个明确定义的准则（最大化稳定时间步长 $\\Delta t$）和一组特定约束（DG 离散化、SSP-RK3 时间积分、对所有 $p \\ge 1$ 稳定）下，优化一个参数（$\\theta$）。\n- **客观性**：问题以精确的数学语言陈述，没有主观或模糊的术语。\n- **完整性与一致性**：问题提供了进行分析所需的所有组成部分：偏微分方程、离散化细节、数值通量、时间积分器和稳定性准则。内部没有矛盾。\n\n### 步骤 3：结论与行动\n问题有效。将提供一个完整、合理的解答。\n\n### 解答\n问题要求找出参数 $\\theta \\in [0,1]$ 的值，该值对于线性平流方程的 DG 离散化，在使用 SSP-RK3 方法进行时间积分时，对所有多项式次数 $p \\ge 1$ 都能最大化允许的时间步长 $\\Delta t$。\n\n在均匀周期网格上，线性平流方程的半离散 DG 格式可表示为一个常微分方程组：\n$$ \\frac{d\\vec{u}}{dt} = \\mathcal{L}_{DG}\\vec{u} $$\n其中 $\\vec{u}$ 是自由度的全局向量，$\\mathcal{L}_{DG}$ 是空间离散化算子。显式时间步进格式的稳定性取决于该算子的特征值 $\\lambda_j$。傅里叶分析通过对 $\\mathcal{L}_{DG}$ 进行块对角化来简化此问题，使我们能够研究每个无量纲波数 $\\xi$ 对应的一个 $(p+1)\\times(p+1)$ 矩阵。其特征值 $\\lambda_j(\\xi; \\theta, p)$ 构成了 DG 傅里叶符号。\n\n首先，我们刻画参数 $\\theta$ 对这些特征值的影响。数值通量为 $F^{*}(u^{-},u^{+}) = a\\,\\{u\\} \\;-\\; \\frac{a\\,\\theta}{2}\\,[u]$。此通量可以看作是包含非耗散的中心通量 $a\\{u\\}$ 和耗散的跳跃项 $-\\frac{a\\theta}{2}[u]$ 的线性组合。\n当 $\\theta=0$ 时，通量是纯中心的，$F^*=a\\{u\\}$。对于像带有中心通量的 DG 这样的斜对称方法，算子 $\\mathcal{L}_{DG}$ 在一个合适的内积下是反伴随的。因此，其特征值 $\\lambda_j(\\xi; 0, p)$ 是纯虚数。\n通量的耗散部分 $-\\frac{a\\theta}{2}[u]$ 会给空间算子增加一个项。它对能量平衡 $\\frac{d}{dt} \\frac{1}{2} \\|u_h\\|^2$ 的贡献可以被分析。此贡献与 $\\theta$ 成比例，并且随着 $\\theta$ 从 $0$ 增加到 $1$，它将特征值从纯虚轴移动到复平面的左半部分。$\\theta=0$ 对应无耗散的中心通量，而 $\\theta=1$ 对应完全迎风通量 $F^* = a u^-$（因为 $a>0$），它具有最大的耗散性。\n\n问题指出，对于显式时间步进格式，稳定性要求 $\\Delta t |\\lambda_{\\max}| \\leq C_{\\text{stab}}$，其中 $C_{\\text{stab}}$ 是由格式的稳定区域决定的常数。给定谱半径的缩放关系 $|\\lambda_{\\max}| \\propto (2p+1)a/h$，CFL 条件变为：\n$$ \\frac{a \\Delta t}{h} \\le \\frac{C_{\\text{stab}}}{C(2p+1)} $$\n对于某些常数 $C$ 和 $C_{\\text{stab}}$。这表明随着多项式次数 $p$ 的增加，时间步长的限制变得更加严格。\n\n问题的核心在于 DG 谱与 SSP-RK3 稳定区域之间的相互作用。稳定性条件是缩放后的特征值集合 $\\{ z_j = \\Delta t \\lambda_j \\}$ 必须包含在 $\\mathcal{S}_{RK3} = \\{ z \\in \\mathbb{C} : |R(z)| \\le 1 \\}$ 内。$\\mathcal{S}_{RK3}$ 的形状至关重要。\n- 它关于实轴对称。\n- 它与虚轴的交集是区间 $[-i\\sqrt{3}, i\\sqrt{3}]$。\n- 它与负实轴的交集大约是区间 $[-2.5127, 0]$。\n与沿负实轴的范围相比，该区域沿虚轴方向明显更窄。\n\n让我们分析不同 $\\theta$ 和大 $p$ 时的行为：\n- **情况 $\\theta=0$ (中心通量)**：谱 $\\{\\lambda_j\\}$ 完全位于虚轴上。谱半径随 $p$ 缩放；我们记作 $\\omega_{\\max}(p) \\propto (2p+1)a/h$。稳定性条件是 $\\Delta t \\, \\omega_{\\max}(p) \\le \\sqrt{3}$。允许的时间步长受到 $\\mathcal{S}_{RK3}$ 沿虚轴的狭窄范围的严重限制。CFL 数 $\\frac{a \\Delta t}{h}$ 按 $1/(2p+1)$ 缩放。\n\n- **情况 $\\theta \\in [0, 1)$ (混合通量)**：对于任何小于 1 的 $\\theta$ 值，数值通量都保留了中心通量的分量。算子 $\\mathcal{L}_{DG}(\\theta)$ 可被视为反伴随中心通量算子的一个扰动。对于大的 $p$，中心通量算子的高频模态主导了谱的虚部范围。因此，对于任何 $\\theta  1$，大 $p$ 的谱将沿虚轴方向（或其附近）延伸很远。允许的时间步长将继续受到 SSP-RK3 稳定区域围绕虚轴的狭窄“颈部”的限制。最大允许 Courant 数仍将按 $1/(2p+1)$ 缩放，其比例常数依赖于 $\\theta$，但由于谱具有大的虚部，这种缩放关系在根本上仍然是限制性的。\n\n- **情况 $\\theta=1$ (迎风通量)**：当 $\\theta=1$ 时，中心通量分量被完全消除。数值通量变为完全迎風通量，$F^* = a u^-$。DG 谱的特性发生了根本性变化。已知迎风格式的特征值位于复平面左半部分一个与原点相切的圆形或心形区域内。关键是，对于大的 $p$，这个谱足迹不会沿虚轴无限延伸。相反，整个缩放后的谱 $\\frac{h}{a(2p+1)}\\sigma_p(1)$ 仍然局限于一个有界区域。这个有界区域能更有效地“嵌入”到 SSP-RK3 稳定区域较宽的部分，远离了限制性的虚轴。由此产生的 CFL 限制，虽然仍然按 $1/(2p+1)$ 缩放，但在大 $p$ 的极限下，其比例常数显著大于任何 $\\theta  1$ 的情况。\n\n问题要求找到一个能对*所有* $p \\ge 1$ 最大化允许时间步长 $\\Delta t$ 的单一 $\\theta$ 值。对于任何 $\\theta'  1$ 的选择，我们总能找到一个足够大的多项式次数 $p$，使得由大的虚部特征值（源于残余的中心通量分量）施加的时间步长限制比纯迎风格式（$\\theta=1$）的限制更为严格。在 $p \\to \\infty$ 的极限下，$\\theta=1$ 与任何 $\\theta'  1$ 的允许时间步长之比趋于无穷大。因此，为了确保在所有多项式次数上（特别是对于高阶方法）都有一个鲁棒且不过于严格的 CFL 条件，唯一合理的选择是完全消除导致这种限制性行为的根源，即中心通量分量。这通过设置 $\\theta=1$ 来实现。\n\n这个选择在为大 $p$ 产生最佳渐进行为的意义上最大化了允许的 $\\Delta t$，使其成为一个旨在适用于所有 $p \\ge 1$ 的方法的优越选择。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "从线性理论转向非线性实践，本练习要求你为无粘伯格斯方程实现一个实用的、基于单元的CFL估算器。你将开发一个控制器，它既要考虑依赖于解本身的平流速度，也要顾及人工粘性的稳定化效应。这个动手编程问题  突出了在复杂模拟中应用CFL条件的现实挑战，包括因采样不足可能导致的陷阱。",
            "id": "3374433",
            "problem": "考虑一维无粘性伯格斯方程（inviscid Burgers equation），这是一个双曲守恒律，由 $u_t + \\left(\\frac{u^2}{2}\\right)_x = 0$ 给出，使用间断伽辽金（Discontinuous Galerkin, DG）方法在区域的一个剖分上进行离散，该剖分由长度为 $h_K$ 的单元 $K$ 组成，每个单元上使用 $p$ 次分段多项式。显式时间积分的 Courant Friedrichs Lewy (CFL) 条件必须确保离散数值的依赖域包含偏微分方程的依赖域。您的任务是为无粘性伯格斯方程的 DG 离散推导一个非线性 CFL 估计器，然后定量测试其对两种实现选择的敏感性：欠积分混叠（under-integrated aliasing）与过采样精确求积代理（oversampled exact quadrature surrogate），以及存在与不存在激波捕捉人工粘性（shock-capturing artificial viscosity）。\n\n从适用于双曲守恒律和 DG 方法的基本原理出发：\n- 无粘性伯格斯方程的特征速度为 $a(u) = u$，因此显式方法的对流稳定性限制必须由一个涉及 $h_K$、$p$ 和每个单元上最大特征速度的单元界限来控制。\n- 多项式反演不等式和迹不等式意味着，对于类对流项，DG 半离散算子的单元谱半径与 $(2p+1)$ 成比例。\n- 用于激波捕捉的人工粘性会增加一个扩散算子；扩散的显式稳定化通常会施加一个抛物线型限制，该限制与 $h_K^2$ 成比例，并带有一个与多项式次数相关的因子。\n\n您必须：\n1. 推导一个与这些基本事实一致的非线性 CFL 估计器，该估计器得出一个依赖于 $h_K$、$p$ 和 $|u|$ 的单元界限的单元对流时间步长限制。\n2. 为基于梯度传感器的人工粘性 $\\nu_K$ 推导一个附带的扩散时间步长限制，该限制对 $h_K$、$p$ 和 $\\nu_K$ 的依赖性与抛物线型缩放成比例。\n3. 实现两种方法来估计所需的每个单元上的最大值：\n   - 一种欠积分混叠估计，每个单元使用 $N_{\\text{alias}} = p+1$ 个均匀分布的采样点（包括两个端点）来估计 $|u|$ 和 $|u_x|$ 的最大值。\n   - 一种过采样“精确求积代理”估计，每个单元使用 $N_{\\text{exact}} = 200p + 50$ 个均匀分布的采样点（包括两个端点）来估计 $|u|$ 和 $|u_x|$ 的最大值。\n4. 对每个测试用例，计算四个标量：\n   - 使用混叠估计的全局对流时间步长。\n   - 使用精确求积代理估计的全局对流时间步长。\n   - 使用混叠估计的全局总时间步长（对流和扩散限制的最小值）。\n   - 使用精确求积代理估计的全局总时间步长。\n\n在您的程序中使用的定义：\n- 对流特征速度为 $|u|$。\n- 人工粘性在每个单元上定义为 $\\nu_K = \\kappa\\, h_K \\max_{x \\in K} |u_x(x)|$，其中 $\\kappa$ 是一个给定的常数。\n- 全局总时间步长是所有单元的对流限制和扩散限制的最小值中的最小值。\n\n测试套件（所有情况下的定义域均为 $[0,1]$）：\n- 情况 1 (平滑的“理想情况”，无激波捕捉):\n  - 网格：四个等长单元，因此对所有 $K$，$h_K = 0.25$。\n  - 多项式次数：$p = 3$。\n  - 场：$u(x) = \\sin(2\\pi x)$ 且 $u_x(x) = 2\\pi \\cos(2\\pi x)$。\n  - 常数：使用 $C_{\\text{adv}} = 0.5$, $C_{\\text{visc}} = 0.25$ 和 $\\kappa = 0$。\n  - 采样：$N_{\\text{alias}} = p+1$ 和 $N_{\\text{exact}} = 200p + 50$。\n- 情况 2 (近间断剖面，有激波捕捉):\n  - 网格：八个等长单元，因此对所有 $K$，$h_K = 0.125$。\n  - 多项式次数：$p = 5$。\n  - 场：$u(x) = \\tanh\\left(100(x - 0.5)\\right)$ 且 $u_x(x) = 100\\,\\text{sech}^2\\left(100(x - 0.5)\\right)$。\n  - 常数：使用 $C_{\\text{adv}} = 0.4$, $C_{\\text{visc}} = 0.25$ 和 $\\kappa = 0.05$。\n  - 采样：$N_{\\text{alias}} = p+1$ 和 $N_{\\text{exact}} = 200p + 50$。\n- 情况 3 (边缘情况，有一个非常小的单元，无激波捕捉):\n  - 网格：两个单元，其中 $h_1 = 10^{-3}$ 和 $h_2 = 1 - 10^{-3}$。\n  - 多项式次数：$p = 1$。\n  - 场：$u(x) = 10 + \\tfrac{1}{2}\\sin(2\\pi x)$ 且 $u_x(x) = \\pi \\cos(2\\pi x)$。\n  - 常数：使用 $C_{\\text{adv}} = 0.9$, $C_{\\text{visc}} = 0.25$ 和 $\\kappa = 0$。\n  - 采样：$N_{\\text{alias}} = p+1$ 和 $N_{\\text{exact}} = 200p + 50$。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，这些结果汇总在一个用方括号括起来的逗号分隔列表中，顺序如下：\n  $[$情况1对流混叠, 情况1对流精确, 情况1总混叠, 情况1总精确, 情况2对流混叠, 情况2对流精确, 情况2总混叠, 情况2总精确, 情况3对流混叠, 情况3对流精确, 情况3总混叠, 情况3总精确$]$。\n- 所有输出必须是实数（浮点数）。不需要物理单位；所有量均为无量纲。\n\n您的程序必须实现所推导的估计器，并使用指定的常数和采样规则为上述三种情况计算所要求的输出。不允许用户输入；将测试套件硬编码在程序内部。该程序必须是一个完整的、可运行的脚本，且只打印上面指定的单行内容。",
            "solution": "该问题是有效且适定的。它解决了为无粘性伯格斯方程的显式间断伽辽金（DG）离散化确定稳定时间步长的问题，这是双曲守恒律数值分析中的一个典型问题。我们将首先推导必要的时间步长估计器，然后实现它们来分析指定的测试用例。\n\n### 时间步长估计器的推导\n\n对于半离散化的偏微分方程 $\\frac{d\\mathbf{u}}{dt} = \\mathbf{L}(\\mathbf{u})$，显式时间步进格式的稳定性由 Courant-Friedrichs-Lewy (CFL) 条件控制，该条件要求时间步长 $\\Delta t$ 满足 $\\Delta t \\le \\frac{C}{\\rho(\\mathbf{L})}$，其中 $\\rho(\\mathbf{L})$ 是空间算子 $\\mathbf{L}$ 的谱半径，而 $C$ 是一个取决于时间积分格式的常数。对于一个同时涉及对流和扩散的系统，$\\mathbf{L} = \\mathbf{L}_{\\text{adv}} + \\mathbf{L}_{\\text{visc}}$，时间步长通常受到谱半径之和的限制，导致限制条件为 $\\frac{1}{\\Delta t} \\approx \\frac{1}{\\Delta t_{\\text{adv}}} + \\frac{1}{\\Delta t_{\\text{visc}}}$。一个更直接和常见的做法是取各个限制中的最小值：$\\Delta t = \\min(\\Delta t_{\\text{adv}}, \\Delta t_{\\text{visc}})$。\n\n全局时间步长是网格 $\\mathcal{T}_h$ 中所有单元 $K$ 的单元时间步长的最小值：\n$$ \\Delta t_{\\text{global}} = \\min_{K \\in \\mathcal{T}_h} \\Delta t_K $$\n\n#### 1. 对流时间步长限制 ($\\Delta t_{\\text{adv}}$)\n\n对于一维双曲问题，DG 空间算子在单元 $K$ 上的谱半径受一个量所界定，该量与该单元上的最大特征速度以及几何和多项式次数相关的因子成正比。问题指出，对于对流，谱半径与 $(2p+1)/h_K$ 成比例。无粘性伯格斯方程 $u_t + (u^2/2)_x = 0$ 的特征速度是 $a(u) = u$。\n\n因此，对流部分的单元谱半径模型为：\n$$ \\rho(\\mathbf{L}_{\\text{adv}, K}) \\propto \\frac{(2p+1)}{h_K} \\max_{x \\in K} |a(u(x))| = \\frac{(2p+1)}{h_K} \\max_{x \\in K} |u(x)| $$\n相应的时间步长限制与此谱半径成反比。包含所提供的无量纲常数 $C_{\\text{adv}}$，我们将单元对流时间步长限制定义为：\n$$ \\Delta t_{\\text{adv}, K} = C_{\\text{adv}} \\frac{h_K}{(2p+1) \\max_{x \\in K} |u(x)|} $$\n该公式正确地捕捉了预期的行为：对于更小的单元 ($h_K$)、更高的多项式次数 ($p$) 和更大的波速 ($|u|$)，稳定时间步长必须减小。\n\n#### 2. 扩散时间步长限制 ($\\Delta t_{\\text{visc}}$)\n\n人工粘性项为系统增加了一个用于激波捕捉的抛物线型、类扩散算子。对于显式方法，这会施加一个更严格的时间步长限制，通常与 $h_K^2$ 成比例。对抛物线问题的 DG 方法的标准分析表明，DG 拉普拉斯算子的谱半径的缩放关系为 $\\rho(\\mathbf{L}_{\\text{visc}, K}) \\propto \\nu_K (p+1)^4 / h_K^2$ 或 $\\nu_K (2p+1)^2 / h_K^2$。鉴于在对流缩放中使用了 $(2p+1)$，为扩散项使用 $(2p+1)^2$ 的缩放是一致且标准的，这是两次应用多项式反演不等式的结果。\n\n因此，我们将粘性部分的单元谱半径模型为：\n$$ \\rho(\\mathbf{L}_{\\text{visc}, K}) \\propto \\frac{\\nu_K (2p+1)^2}{h_K^2} $$\n因此，时间步长限制为：\n$$ \\Delta t_{\\text{visc}, K} = C_{\\text{visc}} \\frac{h_K^2}{\\nu_K (2p+1)^2} $$\n问题将单元人工粘性定义为 $\\nu_K = \\kappa\\, h_K \\max_{x \\in K} |u_x(x)|$。将其代入限制条件，得到：\n$$ \\Delta t_{\\text{visc}, K} = C_{\\text{visc}} \\frac{h_K^2}{\\left(\\kappa\\, h_K \\max_{x \\in K} |u_x(x)|\\right) (2p+1)^2} = \\frac{C_{\\text{visc}} h_K}{\\kappa (2p+1)^2 \\max_{x \\in K} |u_x(x)|} $$\n此限制仅在 $\\kappa > 0$ 时适用。如果 $\\kappa=0$，则不存在人工粘性，且 $\\Delta t_{\\text{visc}, K} = \\infty$。\n\n#### 3. 单元总时间步长\n\n单个单元 $K$ 的总时间步长限制是对流和扩散限制的最小值：\n$$ \\Delta t_K = \\min(\\Delta t_{\\text{adv}, K}, \\Delta t_{\\text{visc}, K}) $$\n整个模拟的全局时间步长则是所有单元中的最小值：\n$$ \\Delta t = \\min_{K \\in \\mathcal{T}_h} \\Delta t_K $$\n\n### 实现与分析\n\n该问题要求为每个测试用例计算四个标量时间步长，基于两种不同的方法来估计每个单元上 $|u|$ 和 $|u_x|$ 的最大值：一种是欠积分的“混叠”估计，另一种是过采样的“精确代理”估计。\n\n每个测试用例的步骤如下：\n1.  对于网格中的每个单元 $K$：\n    a.  为混叠（$N_{\\text{alias}}=p+1$）和精确代理（$N_{\\text{exact}}=200p+50$）两种方法定义采样点。\n    b.  在这些采样点上计算 $|u(x)|$ 和 $|u_x(x)|$，以找到每种方法各自的最大值：$\\max_{\\text{alias}}|u|$、$\\max_{\\text{alias}}|u_x|$、$\\max_{\\text{exact}}|u|$、$\\max_{\\text{exact}}|u_x|$。\n    c.  计算四个单元时间步长：$\\Delta t_{\\text{adv}, K, \\text{alias}}$、$\\Delta t_{\\text{total}, K, \\text{alias}}$、$\\Delta t_{\\text{adv}, K, \\text{exact}}$ 和 $\\Delta t_{\\text{total}, K, \\text{exact}}$。\n2.  对四个时间步长类别中的每一个，计算所有单元的全局最小值，以获得最终所需的标量。\n\n此过程将被编码到一个 Python 脚本中，以计算三个指定测试用例的值。该问题的一个关键方面是，全局时间步长是*所有单元中的最小值*。这意味着，如果时间步长是由另一个估计准确的单元所限制，那么估计最大值时的局部误差（例如，混叠错过了峰值）可能不会影响最终的全局时间步长。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes nonlinear CFL estimators for a DG discretization of the\n    inviscid Burgers equation based on the specified problem statement.\n    \"\"\"\n    \n    # Helper for sech(x) = 1/cosh(x)\n    def sech(x):\n        return 1.0 / np.cosh(x)\n\n    def compute_all_time_steps(h_k, p, u_func, du_dx_func, element_bounds,\n                               C_adv, C_visc, kappa):\n        \"\"\"\n        Computes the four required global time-step scalars for a given test case.\n        \"\"\"\n        num_elements = len(h_k)\n        \n        # p is uniform across elements for all test cases\n        P = p \n        p_vals = [P] * num_elements\n        \n        N_alias_vals = [p_val + 1 for p_val in p_vals]\n        N_exact_vals = [200 * p_val + 50 for p_val in p_vals]\n\n        # Initialize lists to store element-wise time steps\n        elem_dt_adv_alias = np.zeros(num_elements)\n        elem_dt_total_alias = np.zeros(num_elements)\n        elem_dt_adv_exact = np.zeros(num_elements)\n        elem_dt_total_exact = np.zeros(num_elements)\n\n        for i in range(num_elements):\n            x_left, x_right = element_bounds[i]\n\n            # 1. Aliasing sampling\n            x_alias = np.linspace(x_left, x_right, N_alias_vals[i])\n            u_samples_alias = u_func(x_alias)\n            du_dx_samples_alias = du_dx_func(x_alias)\n            max_u_alias = np.max(np.abs(u_samples_alias)) if u_samples_alias.size > 0 else 0.0\n            max_du_dx_alias = np.max(np.abs(du_dx_samples_alias)) if du_dx_samples_alias.size > 0 else 0.0\n\n            # 2. Exact surrogate sampling\n            x_exact = np.linspace(x_left, x_right, N_exact_vals[i])\n            u_samples_exact = u_func(x_exact)\n            du_dx_samples_exact = du_dx_func(x_exact)\n            max_u_exact = np.max(np.abs(u_samples_exact))\n            max_du_dx_exact = np.max(np.abs(du_dx_samples_exact))\n\n            # --- Calculate dt for aliasing ---\n            # Advective time step\n            # Use a small tolerance to avoid division by zero\n            if max_u_alias > 1e-14:\n                dt_adv_k_alias = C_adv * h_k[i] / ((2 * P + 1) * max_u_alias)\n            else:\n                dt_adv_k_alias = np.inf\n            elem_dt_adv_alias[i] = dt_adv_k_alias\n\n            # Viscous time step\n            if kappa > 0 and max_du_dx_alias > 1e-14:\n                dt_visc_k_alias = (C_visc * h_k[i]) / (kappa * max_du_dx_alias * (2 * P + 1)**2)\n            else:\n                dt_visc_k_alias = np.inf\n            \n            elem_dt_total_alias[i] = min(dt_adv_k_alias, dt_visc_k_alias)\n\n            # --- Calculate dt for exact surrogate ---\n            # Advective time step\n            if max_u_exact > 1e-14:\n                dt_adv_k_exact = C_adv * h_k[i] / ((2 * P + 1) * max_u_exact)\n            else:\n                dt_adv_k_exact = np.inf\n            elem_dt_adv_exact[i] = dt_adv_k_exact\n\n            # Viscous time step\n            if kappa > 0 and max_du_dx_exact > 1e-14:\n                dt_visc_k_exact = (C_visc * h_k[i]) / (kappa * max_du_dx_exact * (2 * P + 1)**2)\n            else:\n                dt_visc_k_exact = np.inf\n            \n            elem_dt_total_exact[i] = min(dt_adv_k_exact, dt_visc_k_exact)\n\n        # Find global minimums\n        global_dt_adv_alias = np.min(elem_dt_adv_alias)\n        global_dt_adv_exact = np.min(elem_dt_adv_exact)\n        global_dt_total_alias = np.min(elem_dt_total_alias)\n        global_dt_total_exact = np.min(elem_dt_total_exact)\n        \n        return [global_dt_adv_alias, global_dt_adv_exact, global_dt_total_alias, global_dt_total_exact]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (smooth, no viscosity)\n        {\n            \"p\": 3, \"h_k\": [0.25, 0.25, 0.25, 0.25],\n            \"u_func\": lambda x: np.sin(2 * np.pi * x),\n            \"du_dx_func\": lambda x: 2 * np.pi * np.cos(2 * np.pi * x),\n            \"C_adv\": 0.5, \"C_visc\": 0.25, \"kappa\": 0.0,\n            \"element_bounds\": [(0, 0.25), (0.25, 0.5), (0.5, 0.75), (0.75, 1.0)]\n        },\n        # Case 2 (near-discontinuous, with viscosity)\n        {\n            \"p\": 5, \"h_k\": [0.125] * 8,\n            \"u_func\": lambda x: np.tanh(100 * (x - 0.5)),\n            \"du_dx_func\": lambda x: 100 * sech(100 * (x - 0.5))**2,\n            \"C_adv\": 0.4, \"C_visc\": 0.25, \"kappa\": 0.05,\n            \"element_bounds\": [(i * 0.125, (i + 1) * 0.125) for i in range(8)]\n        },\n        # Case 3 (small element, no viscosity)\n        {\n            \"p\": 1, \"h_k\": [1e-3, 1-1e-3],\n            \"u_func\": lambda x: 10 + 0.5 * np.sin(2 * np.pi * x),\n            \"du_dx_func\": lambda x: np.pi * np.cos(2 * np.pi * x),\n            \"C_adv\": 0.9, \"C_visc\": 0.25, \"kappa\": 0.0,\n            \"element_bounds\": [(0, 1e-3), (1e-3, 1.0)]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_results = compute_all_time_steps(\n            h_k=case[\"h_k\"],\n            p=case[\"p\"],\n            u_func=case[\"u_func\"],\n            du_dx_func=case[\"du_dx_func\"],\n            element_bounds=case[\"element_bounds\"],\n            C_adv=case[\"C_adv\"],\n            C_visc=case[\"C_visc\"],\n            kappa=case[\"kappa\"]\n        )\n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这项高级实践将视角从仅仅满足CFL条件，转变为为了计算效率而主动控制它。你将设计并实现一个p-自适应控制器，它能动态调整网格上多项式的阶数 $p_K$，以平衡各单元的局部Courant数。这种“注水”算法  展示了现代高阶程序中使用的一种强大策略，即在稳定性不是限制因素的区域分配更高的多项式阶数，从而优化计算资源。",
            "id": "3374373",
            "problem": "设计并实现一个程序，为一维间断 Galerkin 方法构建一个基于 Courant–Friedrichs–Lewy 稳定性条件的自适应多项式阶数控制器。考虑一个网格，其单元以 $K$ 为索引，每个单元具有特征尺寸 $h_K$（单位：米）、局部最大特征速度 $a_K$（单位：米/秒）和局部多项式阶数 $p_K$（无量纲）。时间步长是全局的，表示为 $\\Delta t$（单位：秒）。将局部库朗数定义为 $C_K = \\frac{a_K \\,\\Delta t\\, (p_K + 1)}{h_K}$，这是一个无量纲量，用于衡量数值依赖域与按局部解析度缩放后的物理依赖域之比。假设使用一个显式时间积分器，它施加了一个稳定性容许阈值 $C_{\\mathrm{crit}}$（无量纲），使得对于每个单元 $K$，必要的线性稳定性条件为 $C_K \\le C_{\\mathrm{crit}}$。整数多项式阶数受限于 $p_{\\min} \\le p_K \\le p_{\\max}$。\n\n从 $C_K$ 的基本定义以及 $p_K$ 对 $C_K$ 的单调效应（当 $a_K \\Delta t / h_K  0$ 时，对 $p_K$ 严格递增；当 $a_K = 0$ 时为常数）出发，设计一个控制器，该控制器：\n- 在局部稳定性条件被违反的地方降低 $p_K$。\n- 在局部稳定性条件允许且 $\\Delta t$ 不是限制因素的地方增加 $p_K$。\n- 旨在约束条件下尽可能地均衡整个网格上的局部库朗数。\n\n为了使任务适定且可通过编程测试，请实现以下源于上述原则和均衡库朗数要求的精确控制器语义：\n- 稳定化阶段：对于每个单元 $K$，当 $C_K  C_{\\mathrm{crit}}$ 且 $p_K  p_{\\min}$ 时，递减 $p_K \\leftarrow p_K - 1$ 并相应地更新 $C_K$。此阶段之后，每个单元都满足 $C_K \\le C_{\\mathrm{crit}}$ 或 $p_K = p_{\\min}$。\n- 均衡化阶段（带稳定性的注水法）：重复执行以下步骤，直到无法进行任何更改：\n  - 识别符合增加条件的单元索引集合 $S$，即 $p_K  p_{\\max}$ 并且增加后的库朗数 $C_K^{\\mathrm{new}} = \\frac{a_K \\,\\Delta t\\, (p_K + 2)}{h_K}$ 会满足 $C_K^{\\mathrm{new}} \\le C_{\\mathrm{crit}}$。\n  - 如果 $S$ 为空，则终止。否则，在 $S$ 中，选择当前 $C_K$ 最小的单元；若出现平局，则以最小的索引 $K$ 为准。\n  - 增加其阶数：$p_K \\leftarrow p_K + 1$ 并更新 $C_K$。\n该控制器在满足 $C_K \\le C_{\\mathrm{crit}}$ 和 $p_{\\min} \\le p_K \\le p_{\\max}$ 的约束条件下，最大化了最小的 $C_K$，并强制执行确定性的平局打破规则，从而产生唯一的结果。\n\n您的程序必须精确实现上述控制器，并为每个测试用例返回两个阶段都收敛后的最终整数向量 $[p_1,\\dots,p_{N}]$。所有物理量必须使用其指定单位：$h_K$ 以米为单位， $a_K$ 以米/秒为单位，$\\Delta t$ 以秒为单位。输出的阶数 $p_K$ 是无量纲整数。\n\n使用以下测试套件。对于每个测试用例，输入按以下顺序给出：列表 $[h_K]$、列表 $[a_K]$、初始阶数列表 $[p_K^{(0)}]$、标量 $\\Delta t$、标量 $C_{\\mathrm{crit}}$、整数 $p_{\\min}$ 和 $p_{\\max}$。所有列表均按单元索引递增排序。\n- 测试用例 A（非均匀网格，有一个必须降低阶数的紧凑单元）：$[h_K] = [0.1,\\,0.05,\\,0.2,\\,0.04,\\,0.12]$，$[a_K] = [1.0,\\,0.8,\\,1.2,\\,1.5,\\,0.5]$，$[p_K^{(0)}] = [1,\\,2,\\,1,\\,3,\\,0]$，$\\Delta t = 0.01$，$C_{\\mathrm{crit}} = 0.9$，$p_{\\min} = 0$，$p_{\\max} = 5$。\n- 测试用例 B（零速度单元，测试在 $p_{\\max}$ 处的饱和情况）：$[h_K] = [0.1,\\,0.1,\\,0.1]$，$[a_K] = [0.0,\\,1.0,\\,0.0]$，$[p_K^{(0)}] = [0,\\,0,\\,0]$，$\\Delta t = 0.02$，$C_{\\mathrm{crit}} = 0.6$，$p_{\\min} = 0$，$p_{\\max} = 7$。\n- 测试用例 C（极小单元迫使阶数降低）：$[h_K] = [0.005,\\,0.01,\\,0.03]$，$[a_K] = [2.0,\\,2.0,\\,2.0]$，$[p_K^{(0)}] = [3,\\,3,\\,3]$，$\\Delta t = 0.002$，$C_{\\mathrm{crit}} = 0.9$，$p_{\\min} = 0$，$p_{\\max} = 5$。\n- 测试用例 D（已平衡，所有单元均可提升至稳定性极限）：$[h_K] = [1.0,\\,1.0,\\,1.0,\\,1.0]$，$[a_K] = [1.0,\\,1.0,\\,1.0,\\,1.0]$，$[p_K^{(0)}] = [1,\\,1,\\,1,\\,1]$，$\\Delta t = 0.1$，$C_{\\mathrm{crit}} = 0.5$，$p_{\\min} = 0$，$p_{\\max} = 4$。\n\n您的程序应生成单行输出，其中包含所有测试用例的最终阶数列表，格式为方括号括起来的逗号分隔列表（例如，$[rA,rB,rC,rD]$），其中每个 $r\\cdot$ 本身是其测试用例的整数列表 $[p_1,\\dots,p_{N}]$。不应打印任何额外文本。",
            "solution": "用户提供了一个问题，要求为一维间断 Galerkin (DG) 方法设计并实现一个自适应多项式阶数控制器。该控制器的逻辑基于满足 Courant–Friedrichs–Lewy (CFL) 稳定性条件。\n\n### 第 1 步：提取已知信息\n- **网格单元**：以 $K$ 为索引。\n- **单元尺寸**：$h_K$（米）。\n- **特征速度**：$a_K$（米/秒）。\n- **多项式阶数**：$p_K$（无量纲整数）。\n- **全局时间步长**：$\\Delta t$（秒）。\n- **局部库朗数**：$C_K = \\frac{a_K \\,\\Delta t\\, (p_K + 1)}{h_K}$。\n- **稳定性条件**：对所有 $K$，$C_K \\le C_{\\mathrm{crit}}$。\n- **稳定性阈值**：$C_{\\mathrm{crit}}$（无量纲）。\n- **阶数界限**：$p_{\\min} \\le p_K \\le p_{\\max}$。\n- **控制器逻辑**：\n    1.  **稳定化阶段**：对每个单元 $K$，如果 $C_K  C_{\\mathrm{crit}}$ 且 $p_K  p_{\\min}$，则重复将 $p_K$ 减 1，直到满足条件。\n    2.  **均衡化阶段**：迭代执行以下步骤，直到不再发生变化：\n        a. 识别 $S$ 集合，即 $p_K  p_{\\max}$ 且增加 $p_K$ 不会违反稳定性条件的单元（即 $C_K^{\\mathrm{new}} = \\frac{a_K \\Delta t (p_K + 2)}{h_K} \\le C_{\\mathrm{crit}}$）。\n        b. 如果 $S$ 为空，则终止。\n        c. 否则，从 $S$ 中选择当前 $C_K$ 最小的单元。若出现平局，则选择索引 $K$ 最小的单元。\n        d. 为所选单元增加 $p_K$ 并更新其 $C_K$。\n- **输入**：提供 $[h_K]$、$[a_K]$、初始 $[p_K^{(0)}]$ 列表以及标量参数 $\\Delta t$、$C_{\\mathrm{crit}}$、$p_{\\min}$、$p_{\\max}$ 的测试用例。\n- **输出**：一个列表，包含每个测试用例的最终整数阶数向量 $[p_1, \\dots, p_N]$。\n\n### 第 2 步：使用提取的已知信息进行验证\n- **科学依据**：该问题在偏微分方程的数值分析领域有充分的依据。CFL 条件和 p-自适应 DG 方法的概念是标准且科学有效的。所提供的库朗数公式 $C_K$ 是 DG 方法的常用模型，其值随多项式阶数 $p_K$ 变化。\n- **适定性**：控制器逻辑由一个确定性算法描述。稳定化阶段必然会终止，因为 $p_K$ 是一个有下界 $p_{\\min}$ 的整数。均衡化阶段是一个在有限状态空间上运行的贪心算法（因为每个 $p_K$ 都有界），并且每一步都会单调地增加其中一个 $p_K$ 值。严格的平局打破规则确保了唯一的执行路径和唯一的最终状态。因此，存在唯一的解。\n- **客观性**：问题以精确、形式化的语言陈述。控制器的行为被明确定义，没有主观解释的余地。\n- **完整性和一致性**：为每个测试用例提供了所有必要的参数和初始条件。单位是一致的（$a_K \\Delta t / h_K$ 是无量纲的）。问题是自洽的，没有矛盾。\n\n### 第 3 步：结论和行动\n该问题是有效的。它是一个基于可靠科学原理、定义明确的计算任务。将基于指定的算法来开发一个解决方案。\n\n### 算法设计\n\n该解决方案将以一个处理一系列测试用例的 Python 程序实现。对于每个用例，一个函数将执行两阶段的控制器逻辑。\n\n1.  **初始化**：\n    - 将输入的 $h_K$、$a_K$ 和 $p_K^{(0)}$ 列表转换为 NumPy 数组，以实现高效的向量化计算。将这些数组命名为 `h`、`a` 和 `p`。\n    - 为了优化性能，将为每个单元 $K$ 预先计算库朗数计算中的常数因子 $c_{\\mathrm{factor},K} = \\frac{a_K \\Delta t}{h_K}$。那么库朗数就是 $C_K = c_{\\mathrm{factor},K} (p_K + 1)$。\n    - 根据初始阶数 $p_K^{(0)}$ 计算初始库朗数 $C_K$。\n\n2.  **阶段 1：稳定化**：\n    - 程序将遍历每个单元 $K$。\n    - 一个 `while` 循环检查单元是否违反稳定性条件（$C_K  C_{\\mathrm{crit}}$）以及其阶数是否可以降低（$p_K  p_{\\min}$）。\n    - 如果两者都为真，则递减 $p_K$，并重新计算 $C_K$。此循环持续进行，直到单元稳定或其阶数达到 $p_{\\min}$。\n\n3.  **阶段 2：均衡化（注水法）**：\n    - 此阶段在一个主 `while` 循环中实现，该循环只要至少有一个单元的阶数可以增加就继续进行。\n    - 在此主循环的每次迭代中：\n        a. 构建一个 `eligible_candidates` 列表。一个单元 $K$ 如果其阶数 $p_K$ 小于 $p_{\\max}$ 且其增加 $p_K$ 后的潜在新库朗数不超过 $C_{\\mathrm{crit}}$，则符合条件。\n        b. 每个候选者都存储为一个元组 `(C_K, K)`，包含其当前的库朗数和索引。\n        c. 如果候选者列表为空，则主循环终止，因为系统已达到稳定、优化的状态。\n        d. 如果有候选者，则对列表进行排序。主排序键是 $C_K$（升序），次排序键是索引 $K$（升序）。Python 的默认排序是稳定的，当应用于按升序索引迭代创建的元组 `(value, index)` 列表时，会自动遵守平局打破规则。\n        e. 排序后列表中第一个元素（即 $C_K$ 最小，平局时按索引排序的那个）的阶数 $p_K$ 将被增加，并更新其 $C_K$。\n    - 这个迭代过程类似于“注水法”，我们贪婪地将“阶数”倒入具有最大“容量”（最低 $C_K$）且在稳定性约束下的单元中。\n\n4.  **最终输出**：\n    - 控制器收敛后，将最终的 NumPy 阶数数组 `p` 转换回 Python 整数列表。\n    - 收集所有测试用例的结果，并按照问题指定的格式格式化为单个字符串，例如 `[[p1,p2,...],[q1,q2,...]]`。\n\n此设计确保了对指定确定性控制器的正确且高效的实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_controller(h_k_list, a_k_list, p_k_initial_list, delta_t, c_crit, p_min, p_max):\n    \"\"\"\n    Implements the adaptive polynomial-degree controller based on the CFL condition.\n    \n    The controller operates in two phases:\n    1. Stabilization: Decrements polynomial degrees to satisfy the stability condition.\n    2. Equalization: Iteratively increases degrees for elements with the most\n       stability headroom, aiming to balance Courant numbers across the mesh.\n    \"\"\"\n    # Convert input lists to NumPy arrays for efficient vectorized operations.\n    h_k = np.array(h_k_list, dtype=np.float64)\n    a_k = np.array(a_k_list, dtype=np.float64)\n    p_k = np.array(p_k_initial_list, dtype=np.int64)\n    \n    num_elements = len(h_k)\n    \n    # Pre-calculate the constant part of the Courant number for each element.\n    # This avoids repeated floating-point divisions inside loops.\n    # Characteristic size h_k is assumed to be > 0.\n    c_factor = np.divide(a_k * delta_t, h_k, out=np.zeros_like(a_k, dtype=float), where=h_k!=0)\n\n    # Initialize local Courant numbers.\n    c_k = c_factor * (p_k.astype(np.float64) + 1.0)\n\n    # Phase 1: Stabilization\n    # For each element K, while C_K > C_crit and p_K > p_min, decrement p_K.\n    for k in range(num_elements):\n        while c_k[k] > c_crit and p_k[k] > p_min:\n            p_k[k] -= 1\n            c_k[k] = c_factor[k] * (p_k[k] + 1.0)\n\n    # Phase 2: Equalization (water-filling with stability)\n    # Repeatedly increase p_K for the most \"roomy\" eligible element.\n    while True:\n        eligible_candidates = []\n        for k in range(num_elements):\n            # Check eligibility: p_K  p_max...\n            if p_k[k]  p_max:\n                # ...and ensure the incremented Courant number is within the stability limit.\n                c_new = c_factor[k] * (p_k[k] + 2.0)\n                if c_new = c_crit:\n                    # A candidate is stored as a tuple (current C_K, index K)\n                    # for sorting according to the specified criteria.\n                    eligible_candidates.append((c_k[k], k))\n        \n        # If no elements are eligible for a degree increase, the process has converged.\n        if not eligible_candidates:\n            break\n\n        # Sort candidates to find the one with the smallest current C_K.\n        # Python's list.sort() is stable, so in case of a tie in C_K,\n        # the original order (by increasing index K) is preserved,\n        # fulfilling the tie-breaking rule.\n        eligible_candidates.sort()\n        \n        # Select the element to update (the first one after sorting).\n        k_to_increase = eligible_candidates[0][1]\n        \n        # Increase its polynomial degree and update its Courant number.\n        p_k[k_to_increase] += 1\n        c_k[k_to_increase] = c_factor[k_to_increase] * (p_k[k_to_increase] + 1.0)\n\n    return p_k.tolist()\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the controller for each case,\n    and prints the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {'h_k': [0.1, 0.05, 0.2, 0.04, 0.12], 'a_k': [1.0, 0.8, 1.2, 1.5, 0.5], 'p_k_initial': [1, 2, 1, 3, 0], 'delta_t': 0.01, 'c_crit': 0.9, 'p_min': 0, 'p_max': 5},\n        # Test Case B\n        {'h_k': [0.1, 0.1, 0.1], 'a_k': [0.0, 1.0, 0.0], 'p_k_initial': [0, 0, 0], 'delta_t': 0.02, 'c_crit': 0.6, 'p_min': 0, 'p_max': 7},\n        # Test Case C\n        {'h_k': [0.005, 0.01, 0.03], 'a_k': [2.0, 2.0, 2.0], 'p_k_initial': [3, 3, 3], 'delta_t': 0.002, 'c_crit': 0.9, 'p_min': 0, 'p_max': 5},\n        # Test Case D\n        {'h_k': [1.0, 1.0, 1.0, 1.0], 'a_k': [1.0, 1.0, 1.0, 1.0], 'p_k_initial': [1, 1, 1, 1], 'delta_t': 0.1, 'c_crit': 0.5, 'p_min': 0, 'p_max': 4}\n    ]\n\n    results = []\n    for case in test_cases:\n        final_p_k = run_controller(\n            case['h_k'],\n            case['a_k'],\n            case['p_k_initial'],\n            case['delta_t'],\n            case['c_crit'],\n            case['p_min'],\n            case['p_max']\n        )\n        results.append(final_p_k)\n\n    # Format the results into the required string format \"[[...],[...],...]\".\n    # The str() representation of a list includes brackets. Spaces are removed\n    # to match the compact output format example.\n    results_str = ','.join([str(res).replace(' ', '') for res in results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        }
    ]
}