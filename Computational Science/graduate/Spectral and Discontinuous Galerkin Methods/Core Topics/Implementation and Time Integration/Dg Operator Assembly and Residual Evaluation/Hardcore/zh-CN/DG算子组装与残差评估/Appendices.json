{
    "hands_on_practices": [
        {
            "introduction": "本练习为DG格式提供了一个基础的验证测试。通过为一个简单的平流问题实现强形式残差，您将从数值上确认总质量（离散积分）随时间守恒，这对于任何可靠的模拟方法而言都是一个至关重要的特性。",
            "id": "3377756",
            "problem": "考虑一个一维周期性域上的线性平流初值问题，\n$$\nu_t + a\\,u_x = 0 \\quad \\text{on} \\quad x \\in [0,L],\n$$\n该问题具有周期性边界条件和无量纲常数平流速度 $a$。目标是构建一个间断 Galerkin (DG) 验证测试，以表明当使用中心数值通量时，$u$ 的离散积分在 DG 残差作用下是随时间不变的。\n\n在节点配置设置下使用 Legendre-Gauss-Lobatto (LGL) 节点进行求解。设每个单元是从参考区间 $r \\in [-1,1]$ 到长度均匀为 $L_e$ 的物理单元 $x \\in [x_{e}, x_{e+1}]$ 的仿射映射，其雅可比为 $J_e = L_e/2$。在每个单元内部，使用拉格朗日插值在 $N+1$ 个 LGL 节点 $\\{r_i\\}_{i=0}^N$ 上表示 $u(r,t)$，并使用 LGL 求积权重 $\\{w_i\\}_{i=0}^N$。设 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 为微分矩阵，其定义为在 LGL 节点上求值的拉格朗日基多项式的导数。\n\n将单元 $e$ 和节点 $i$ 上标量平流通量 $f(u) = a\\,u$ 的强形式 DG 残差定义为\n$$\nR_i^{(e)} = -\\frac{2}{L_e}\\sum_{j=0}^N D_{ij}\\,f\\!\\left(u_j^{(e)}\\right) \\;+\\; \\frac{2}{L_e\\,w_i}\n\\Big( \\delta_{i,N}\\big(f^{*}_{\\text{right}} - f(u_N^{(e)})\\big) \\;-\\; \\delta_{i,0}\\big(f^{*}_{\\text{left}} - f(u_0^{(e)})\\big) \\Big),\n$$\n其中 $f^{*}_{\\text{left}}$ 和 $f^{*}_{\\text{right}}$ 分别是单元 $e$ 左右界面上的一致性数值通量，$\\delta_{i,k}$ 是克罗内克 δ (delta)。使用中心数值通量\n$$\nf^{*} = \\frac{1}{2}\\Big(f(u^{-}) + f(u^{+})\\Big) = \\frac{a}{2}\\Big(u^{-} + u^{+}\\Big),\n$$\n其中 $u^{-}$ 和 $u^{+}$ 表示界面内侧和外侧的迹。通过从网格的另一端取域边界处的外侧迹来施加周期性。\n\n将 DG 场 $u$ 的离散积分（使用 LGL 求积）定义为\n$$\nI[u] \\;=\\; \\sum_{e=1}^{E} \\sum_{i=0}^{N} J_e\\, w_i\\, u_i^{(e)}.\n$$\n你的任务是实现一个程序，该程序：\n1. 为任意多项式阶数 $N \\geq 1$ 构建 LGL 节点、LGL 权重和拉格朗日微分矩阵 $D$。\n2. 在 $[0,L]$ 上构建一个包含 $E$ 个单元的周期性网格，单元大小均匀，为 $L_e = L/E$。\n3. 使用中心数值通量组装 DG 强形式残差 $R_i^{(e)}$，并按如下方式计算积分的离散时间导数\n$$\n\\frac{d}{dt} I[u] \\;=\\; \\sum_{e=1}^{E} \\sum_{i=0}^{N} J_e\\, w_i\\, R_i^{(e)}.\n$$\n4. 通过检查 $\\left|\\frac{d}{dt}I[u]\\right|$ 对几个测试用例是否低于规定的容差，来验证离散积分的不变性。\n\n所有量均视为无量纲。此问题不涉及角度。使用以下测试套件，其中指定了网格、多项式阶数、域长度、平流速度和初始条件。对于每种情况，通过在 LGL 节点的物理坐标处计算给定的初始条件来构建节点值 $u_i^{(e)}$。\n\n测试套件：\n- 情况 1 (光滑的“理想”情况): $E=4$, $N=3$, $L=1$, $a=1$, $u(x)=\\sin(2\\pi x/L)$。\n- 情况 2 (间断剖面，负速度): $E=3$, $N=2$, $L=2$, $a=-0.7$, $u(x)=\\begin{cases} 1 & \\text{if } x  L/2 \\\\ 0  \\text{otherwise} \\end{cases}$。\n- 情况 3 (单单元，高阶，随机节点值): $E=1$, $N=5$, $L=1.0$, $a=0.3$, 初始条件为在每个节点上赋予随机值。\n- 情况 4 (多单元，最低阶): $E=8$, $N=1$, $L=1.0$, $a=3.0$, 初始条件为在每个节点上赋予随机值。\n- 情况 5 (不同域长度的光滑函数): $E=5$, $N=4$, $L=\\pi$, $a=2.0$, $u(x)=\\cos(x)$。",
            "solution": "该问题要求验证应用于一维线性平流方程 $u_t + a\\,u_x = 0$ 的节点间断 Galerkin (DG) 方法的守恒性质。具体来说，我们必须证明当使用规定的强形式 DG 残差和中心数值通量时，解的离散空间积分 $I[u]$ 是随时间不变的。离散积分的时间导数由下式给出\n$$\n\\frac{d}{dt} I[u] \\;=\\; \\sum_{e=1}^{E} \\sum_{i=0}^{N} J_e\\, w_i\\, R_i^{(e)}\n$$\n我们将首先解析地证明该量在机器精度范围内为零，然后实施一个数值测试，以对所提供的测试用例验证此结论。\n\n**积分不变性的理论验证**\n\n验证的核心在于对周期性域中所有单元的残差贡献进行仔细求和。离散积分 $I[u]$ 的时间导数由每个单元内变化的总和给出。我们来分析单个单元 $e$ 的贡献。此贡献为 $Q^{(e)} = \\sum_{i=0}^{N} J_e\\, w_i\\, R_i^{(e)}$。\n\n代入强形式残差 $R_i^{(e)}$ 的给定定义：\n$$\nR_i^{(e)} = -\\frac{1}{J_e}\\sum_{j=0}^N D_{ij}\\,f_j^{(e)} \\;+\\; \\frac{1}{J_e\\,w_i} \\Big( \\delta_{i,N}\\big(f^{*}_{\\text{right}} - f_N^{(e)}\\big) \\;-\\; \\delta_{i,0}\\big(f^{*}_{\\text{left}} - f_0^{(e)}\\big) \\Big),\n$$\n其中我们使用符号 $f_j^{(e)} = f(u_j^{(e)})$ 并代入了 $J_e = L_e/2$。贡献 $Q^{(e)}$ 变为：\n$$\nQ^{(e)} = \\sum_{i=0}^{N} J_e w_i \\left[ -\\frac{1}{J_e}\\sum_{j=0}^N D_{ij}\\,f_j^{(e)} \\;+\\; \\frac{1}{J_e\\,w_i} \\Big( \\delta_{i,N}(f^{*}_{\\text{right}} - f_N^{(e)}) - \\delta_{i,0}(f^{*}_{\\text{left}} - f_0^{(e)}) \\Big) \\right]\n$$\n雅可比 $J_e$ 在两项中都消掉了：\n$$\nQ^{(e)} = -\\sum_{i=0}^{N} w_i \\sum_{j=0}^{N} D_{ij}\\,f_j^{(e)} \\;+\\; \\sum_{i=0}^{N} \\Big( \\delta_{i,N}(f^{*}_{\\text{right}} - f_N^{(e)}) - \\delta_{i,0}(f^{*}_{\\text{left}} - f_0^{(e)}) \\Big)\n$$\n由于克罗内克 δ (delta) $\\delta_{i,k}$（当 $i=k$ 时为 1，否则为 0），第二项得以简化。对 $i$ 的求和会收缩，只留下 $i=0$ 和 $i=N$ 的项：\n$$\n\\sum_{i=0}^{N} \\Big( \\dots \\Big) = (f^{*}_{\\text{right}} - f_N^{(e)}) - (f^{*}_{\\text{left}} - f_0^{(e)})\n$$\n第一项涉及微分矩阵 $D$ 和求积权重 $w$。对于基于 Legendre-Gauss-Lobatto (LGL) 节点和相应求积权重的微分矩阵，它们满足分部求和 (SBP) 性质。具体而言，对于代表至多 $N$ 阶多项式的任意节点值向量 $\\mathbf{g} = [g_0, \\dots, g_N]^T$，其导数的离散积分是精确的：\n$$\n\\sum_{i=0}^{N} w_i (D\\mathbf{g})_i = \\sum_{i=0}^{N} w_i \\sum_{j=0}^{N} D_{ij} g_j = g_N - g_0\n$$\n将此 SBP 性质应用于我们的通量向量 $\\mathbf{f}^{(e)}$，由于 $f(u)=a\\,u$ 是线性的，它代表一个 $N$ 阶多项式，我们得到：\n$$\n\\sum_{i=0}^{N} w_i \\sum_{j=0}^{N} D_{ij}\\,f_j^{(e)} = f_N^{(e)} - f_0^{(e)}\n$$\n将这些结果代回 $Q^{(e)}$ 的表达式中：\n$$\nQ^{(e)} = -(f_N^{(e)} - f_0^{(e)}) + (f^{*}_{\\text{right}} - f_N^{(e)}) - (f^{*}_{\\text{left}} - f_0^{(e)})\n$$\n这可以重新排列为：\n$$\nQ^{(e)} = (f_0^{(e)} - f^{*}_{\\text{left}}) - (f_N^{(e)} - f^{*}_{\\text{right}})\n$$\n现在，我们引入中心数值通量的定义，$f^{*} = \\frac{1}{2}(f(u^{-}) + f(u^{+}))$. 在单元 $e$ 的左界面，内侧迹为 $u^{-} = u_0^{(e)}$，外侧迹 $u^{+}$ 是来自左边相邻单元右边界的解值，我们记为 $u_N^{(e-1)}$。因此，\n$$\nf^{*}_{\\text{left}} = f^{*}_{e-1/2} = \\frac{1}{2}\\Big(f(u_0^{(e)}) + f(u_N^{(e-1)})\\Big) = \\frac{1}{2}\\Big(f_0^{(e)} + f_N^{(e-1)}\\Big)\n$$\n类似地，在单元 $e$ 的右界面，内侧迹为 $u^{-} = u_N^{(e)}$，外侧迹为 $u^{+} = u_0^{(e+1)}$。因此，\n$$\nf^{*}_{\\text{right}} = f^{*}_{e+1/2} = \\frac{1}{2}\\Big(f(u_N^{(e)}) + f(u_0^{(e+1)})\\Big) = \\frac{1}{2}\\Big(f_N^{(e)} + f_0^{(e+1)}\\Big)\n$$\n将这些代入 $Q^{(e)}$ 的表达式中：\n$$\nQ^{(e)} = \\left(f_0^{(e)} - \\frac{1}{2}(f_0^{(e)} + f_N^{(e-1)})\\right) - \\left(f_N^{(e)} - \\frac{1}{2}(f_N^{(e)} + f_0^{(e+1)})\\right)\n$$\n$$\nQ^{(e)} = \\frac{1}{2}\\Big(f_0^{(e)} - f_N^{(e-1)}\\Big) - \\frac{1}{2}\\Big(f_N^{(e)} - f_0^{(e+1)}\\Big)\n$$\n总变化率是所有单元的总和，$\\frac{d}{dt}I[u] = \\sum_{e=1}^{E} Q^{(e)}$。由于是周期性域，单元索引以 $E$ 为模。\n$$\n\\frac{d}{dt}I[u] = \\frac{1}{2} \\sum_{e=1}^{E} \\left[ \\Big(f_0^{(e)} - f_N^{(e-1)}\\Big) - \\Big(f_N^{(e)} - f_0^{(e+1)}\\Big) \\right]\n$$\n我们来检查这个求和中的各项。项 $\\frac{1}{2}(f_0^{(e)} - f_N^{(e-1)})$ 与单元 $e-1$ 和 $e$ 之间的界面相关。项 $-\\frac{1}{2}(f_N^{(e)} - f_0^{(e+1)})$ 与单元 $e$ 和 $e+1$ 之间的界面相关。当我们对所有 $e$ 求和时，每个界面都会被访问两次。对于单元 $k$ 和 $k+1$ 之间的界面，我们从 $Q^{(k)}$ 和 $Q^{(k+1)}$ 得到贡献：\n- 来自 $Q^{(k)}$ (作为右界面): $-\\frac{1}{2}(f_N^{(k)} - f_0^{(k+1)})$\n- 来自 $Q^{(k+1)}$ (作为左界面): $+\\frac{1}{2}(f_0^{(k+1)} - f_N^{(k)})$\n这两项大小相等，方向相反，相加为零。这种抵消发生在域内的每个界面上。由于周期性，单元 $E$ 和单元 $1$ 之间的界面也表现出这种抵消。因此，整个和是一个伸缩求和，其结果恰好为零。\n\n这证明了对于给定的使用中心通量的 DG 公式，无论初始数据如何，离散积分都是守恒的。数值实现应该证实这一点，任何非零结果都可归因于浮点运算误差。\n\n**算法实现**\n\n数值验证过程如下：\n$1$. **LGL 工具**：对于每个所需的多项式阶数 $N$，我们生成 $N+1$ 个 Legendre-Gauss-Lobatto (LGL) 节点 $\\{r_i\\}$、求积权重 $\\{w_i\\}$ 和微分矩阵 $D$。\n    - 节点 $r_i$ 是 $(1-r^2)L'_N(r)$ 的根，其中 $L_N$ 是 $N$ 阶勒让德多项式。外部节点总是 $r_0=-1$ 和 $r_N=1$。内部节点是 $L'_N(r)$ 的根。\n    - 权重由公式 $w_i = \\frac{2}{N(N+1)L_N(r_i)^2}$ 给出。\n    - 微分矩阵的非对角线元素为 $D_{ij} = \\frac{L_N(r_i)}{L_N(r_j)(r_i-r_j)}$（当 $i \\neq j$ 时）。对角线元素为 $D_{00} = -\\frac{N(N+1)}{4}$，$D_{NN} = \\frac{N(N+1)}{4}$，以及 $D_{ii}=0$（当 $i \\in \\{1,\\dots,N-1\\}$ 时）。\n$2$. **网格与状态初始化**：在 $[0, L]$ 上创建一个包含 $E$ 个单元的均匀周期性网格。所有 LGL 节点的物理坐标通过仿射映射 $x_i^{(e)} = x_e + (r_i+1)J_e$ 确定，其中 $J_e = L_e/2 = L/(2E)$。通过在这些物理坐标上计算指定的初始条件函数来初始化节点解值 $u_i^{(e)}$。对于随机情况，使用带有固定种子的伪随机数生成器来填充这些值。\n$3$. **残差与积分求值**：程序遍历每个单元 $e=1, \\dots, E$，以计算其对 $\\frac{d}{dt}I[u]$ 的贡献。\n    - 对每个单元 $e$，使用节点解向量 $\\mathbf{u}^{(e)}$ 构成通量向量 $\\mathbf{f}^{(e)} = a\\,\\mathbf{u}^{(e)}$。\n    - 识别内侧迹 $u_0^{(e)}$ 和 $u_N^{(e)}$。从相邻单元中检索外侧迹值 $u_N^{(e-1)}$ 和 $u_0^{(e+1)}$，并遵守网格的周期性。\n    - 使用中心通量公式计算左右数值通量 $f^{*}_{\\text{left}}$ 和 $f^{*}_{\\text{right}}$。\n    - 根据提供的方程组装强形式残差向量 $\\mathbf{R}^{(e)}$。\n    - 计算该单元对积分时间导数的贡献 $Q^{(e)} = J_e \\mathbf{w}^T \\mathbf{R}^{(e)}$，并将其加入一个累加和中。\n$4$. **验证**：对所有单元的贡献求和后，将总和 $\\frac{d}{dt}I[u]$ 的绝对值与指定的容差 $\\varepsilon = 5 \\times 10^{-12}$ 进行比较。每个测试用例的结果是一个布尔值，指示计算出的值是否在此容差范围内。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\ndef get_lgl_basis(N):\n    \"\"\"\n    Computes LGL nodes, weights, and differentiation matrix for a given degree N.\n    \"\"\"\n    if N == 0:\n        return np.array([-1.0]), np.array([2.0]), np.array([[0.0]])\n    \n    # Nodes are roots of (1-x^2) * L_N'(x)\n    # Interior nodes are roots of L_N'(x)\n    p_N = legendre(N)\n    p_N_prime_roots = p_N.deriv().roots\n    nodes = np.concatenate(([-1.0], np.sort(p_N_prime_roots), [1.0]))\n\n    # Weights\n    weights = 2.0 / (N * (N + 1) * (p_N(nodes)**2))\n\n    # Differentiation matrix\n    D = np.zeros((N + 1, N + 1))\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = p_N(nodes[i]) / (p_N(nodes[j]) * (nodes[i] - nodes[j]))\n    \n    D[0, 0] = -N * (N + 1) / 4.0\n    D[N, N] = N * (N + 1) / 4.0\n    \n    return nodes, weights, D\n\n# Cache for LGL basis to avoid recomputation\nLGL_CACHE = {}\n\ndef get_cached_lgl_basis(N):\n    if N not in LGL_CACHE:\n        LGL_CACHE[N] = get_lgl_basis(N)\n    return LGL_CACHE[N]\n\ndef calculate_dIdt(E, N, L, a, u_func, is_random=False, rng=None):\n    \"\"\"\n    Calculates the discrete time derivative of the integral I[u] for a given test case.\n    \"\"\"\n    # 1. Construct LGL basis\n    r, w, D = get_cached_lgl_basis(N)\n    \n    # 2. Build periodic mesh and initialize solution\n    Le = L / E\n    Je = Le / 2.0\n    \n    # Element boundaries\n    x_bounds = np.linspace(0, L, E + 1)\n    \n    # Store all nodal values for easy access to neighbors\n    u_all = np.zeros((E, N + 1))\n    \n    if is_random:\n        u_all = rng.random((E, N + 1))\n    else:\n        for e in range(E):\n            x_e_start = x_bounds[e]\n            # Map reference nodes to physical nodes for this element\n            x_nodes_e = x_e_start + (r + 1) * Je\n            u_all[e, :] = u_func(x_nodes_e, L)\n\n    # 3. Assemble residual and evaluate discrete time derivative of the integral\n    dIdt = 0.0\n    \n    for e in range(E):\n        u_e = u_all[e, :]\n        f_e = a * u_e\n        \n        # Volume term contribution to the residual\n        R_vol = -(1.0 / Je) * (D @ f_e)\n        \n        # Surface term contribution (flux corrections)\n        \n        # Left interface of element e\n        u_minus_left = u_e[0]\n        # Find left neighbor (periodic)\n        e_left = (e - 1 + E) % E\n        u_plus_left = u_all[e_left, N]\n        f_star_left = (a / 2.0) * (u_minus_left + u_plus_left)\n        \n        # Right interface of element e\n        u_minus_right = u_e[N]\n        # Find right neighbor (periodic)\n        e_right = (e + 1) % E\n        u_plus_right = u_all[e_right, 0]\n        f_star_right = (a / 2.0) * (u_minus_right + u_plus_right)\n        \n        # Complete residual R for element e\n        R_e = np.copy(R_vol)\n        R_e[N] += (1.0 / (Je * w[N])) * (f_star_right - f_e[N])\n        R_e[0] -= (1.0 / (Je * w[0])) * (f_star_left - f_e[0])\n        \n        # Add element's contribution to dI/dt\n        # This is sum_{i=0 to N} J_e * w_i * R_i^(e)\n        dIdt += Je * np.dot(w, R_e)\n        \n    return dIdt\n\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (smooth “happy path”)\n        {'E': 4, 'N': 3, 'L': 1.0, 'a': 1.0, 'u_func': lambda x, L: np.sin(2 * np.pi * x / L)},\n        # Case 2 (discontinuous profile, negative speed)\n        {'E': 3, 'N': 2, 'L': 2.0, 'a': -0.7, 'u_func': lambda x, L: np.where(x  L / 2.0, 1.0, 0.0)},\n        # Case 3 (single element, higher order, random nodal values)\n        {'E': 1, 'N': 5, 'L': 1.0, 'a': 0.3, 'u_func': None, 'is_random': True, 'seed': 42},\n        # Case 4 (many elements, lowest order)\n        {'E': 8, 'N': 1, 'L': 1.0, 'a': 3.0, 'u_func': None, 'is_random': True, 'seed': 123},\n         # Case 5 (smooth with different domain length)\n        {'E': 5, 'N': 4, 'L': np.pi, 'a': 2.0, 'u_func': lambda x, L: np.cos(x)},\n    ]\n    \n    tolerance = 5e-12\n    results = []\n\n    for case in test_cases:\n        rng = None\n        if case.get('is_random', False):\n            rng = np.random.default_rng(seed=case['seed'])\n            \n        dIdt_val = calculate_dIdt(\n            E=case['E'], \n            N=case['N'], \n            L=case['L'], \n            a=case['a'], \n            u_func=case['u_func'],\n            is_random=case.get('is_random', False),\n            rng=rng\n        )\n        \n        results.append(abs(dIdt_val) = tolerance)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在守恒概念的基础上，本实践将深入探讨保证其成立的底层数学结构。您将研究分部求和（Summation-By-Parts, SBP）性质，并了解节点（高斯-洛巴托 vs. 高斯）的选择如何直接影响离散算子是否满足此性质，进而决定该格式是否内蕴守恒。",
            "id": "3377712",
            "problem": "研究对于一维线性平流方程，节点分布的选择如何影响间断伽辽金 (DG) 方法中的算子组装和残差评估。具体而言，当使用分部求和 (SBP) 恒等式从弱形式离散组装强形式 DG 残差时，比较 Gauss–Lobatto–Legendre 节点与 Gauss–Legendre 节点在面-体耦合和离散守恒性质方面的差异。\n\n考虑一维线性平流方程\n$$\nu_t + a\\,u_x = 0\n$$\n在定义域 $[0,1]$ 上，采用周期性边界条件，其中 $a$ 是一个常数平流速度。将该定义域划分为 $N_e$ 个大小为 $h = 1/N_e$ 的均匀单元，每个单元通过 $x = x_L + \\tfrac{h}{2}(r+1)$ 映射到参考区间 $[-1,1]$，其中 $x_L$ 是单元的左端点，$r \\in [-1,1]$ 是参考坐标。映射的雅可比行列式为 $J = h/2$。\n\n在每个单元上使用 $p$ 次的节点拉格朗日多项式基，包含 $N = p+1$ 个节点。研究两种节点分布：\n- Gauss–Lobatto–Legendre 节点，包含端点 $-1$ 和 $1$。\n- Gauss–Legendre 节点，不包含端点。\n\n定义基于求积的对角质量矩阵 $M \\in \\mathbb{R}^{N \\times N}$，其元素由求积权重给出；与拉格朗日基相关的节点微分矩阵 $D \\in \\mathbb{R}^{N \\times N}$；在两个面 $r=-1$ 和 $r=1$ 处评估节点多项式的限制算子 $R \\in \\mathbb{R}^{2 \\times N}$；以及面方向矩阵 $B = \\mathrm{diag}(-1,1)$。参考单元上的分部求和 (SBP) 恒等式为\n$$\nD^\\top M = - M D + R^\\top B R.\n$$\n该恒等式对于 Gauss–Lobatto–Legendre 配置精确成立，但对于 Gauss–Legendre 配置不成立。\n\n从参考单元上的弱形式 DG 离散出发，\n$$\nM\\,J\\,\\dot{u} = -a\\,D^\\top M\\,u + R^\\top B\\,f^\\ast,\n$$\n其中 $f^\\ast$ 是单元面上的双分量数值通量向量，通过代入 SBP 恒等式推导强形式 DG 残差，得到\n$$\n\\dot{u} = \\frac{a}{J} D\\,u + \\frac{1}{J} M^{-1} R^\\top B \\left(f^\\ast - a\\,R\\,u\\right).\n$$\n使用周期性边界条件和 $a0$ 时的迎风数值通量（即在每个面上 $f^\\ast = a\\,u^{-}$，其中 $u^{-}$ 是来自迎风侧的内部迹），逐单元组装此强形式残差。对于周期性边界，一个单元的左面通量取自其左邻居单元的右面内部迹。\n\n您必须量化：\n1. 每种节点分布的面-体失配，定义为 Frobenius 范数\n$$\n\\left\\| M D + D^\\top M - R^\\top B R \\right\\|_F,\n$$\n在参考单元上计算。\n2. 使用 SBP 代换组装强形式残差所引起的离散守恒误差。这定义为全局质量变化率的绝对值\n$$\n\\left|\\sum_{e=1}^{N_e} J \\sum_{i=1}^{N} w_i\\,\\dot{u}_i^{(e)}\\right|,\n$$\n其中 $w_i$ 是求积权重，$J$ 是单元雅可比行列式，$\\dot{u}_i^{(e)}$ 是由强形式残差计算出的单元 $e$ 中的节点时间导数。对于周期性边界和精确的弱形式，此量应精确为零；任何非零值都反映了在强形式组装中由于面-体失配导致的离散守恒性损失。\n\n角度单位（用于三角函数初始数据）必须是弧度。\n\n您的程序必须实现：\n- 构造 Gauss–Legendre 节点和权重。\n- 构造 Gauss–Lobatto–Legendre 节点和权重，内部节点使用勒让德多项式 $P_{p}'$ 的根（等价于雅可比多项式 $P_{p-2}^{(1,1)}$ 的根），并精确包含端点。\n- 用于节点拉格朗日插值的重心权重。\n- 通过重心权重计算节点微分矩阵 $D$。\n- 通过重心插值计算在 $r=-1$ 和 $r=1$ 处评估节点多项式的限制算子 $R$。\n- 使用上述公式、周期性连接和 $a0$ 时的迎风通量组装强形式 DG 残差。\n\n测试套件：\n提供三个测试用例以评估不同方面：\n- 用例 1（通用/正常路径）：$p=4$，$N_e=4$，$a=1.0$，初始条件 $u(x)=\\sin(2\\pi x)$。\n- 用例 2（单单元周期性边界）：$p=5$，$N_e=1$，$a=1.0$，初始条件 $u(x)$ 等于在每个单元的参考坐标 $r$ 上评估的勒让德多项式 $P_p(r)$。\n- 用例 3（欠分辨率的边界情况）：$p=2$，$N_e=3$，$a=1.0$，初始条件 $u(x)=\\sin(10\\pi x)$。\n\n对于每个用例，按以下固定顺序计算并报告四个浮点数：\n- Gauss–Lobatto–Legendre 节点的面-体失配范数。\n- Gauss–Legendre 节点的面-体失配范数。\n- Gauss–Lobatto–Legendre 节点的离散守恒误差（绝对全局质量变化率）。\n- Gauss–Legendre 节点的离散守恒误差（绝对全局质量变化率）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，按顺序连接用例 1、用例 2 和用例 3 的四个输出：\n$$\n[\\text{C1\\_GLL\\_mismatch},\\text{C1\\_GL\\_mismatch},\\text{C1\\_GLL\\_cons\\_err},\\text{C1\\_GL\\_cons\\_err},\\text{C2\\_GLL\\_mismatch},\\text{C2\\_GL\\_mismatch},\\text{C2\\_GLL\\_cons\\_err},\\text{C2\\_GL\\_cons\\_err},\\text{C3\\_GLL\\_mismatch},\\text{C3\\_GL\\_mismatch},\\text{C3\\_GLL\\_cons\\_err},\\text{C3\\_GL\\_cons\\_err}]\n$$\n所有输出必须是实数（浮点数）。",
            "solution": "该问题要求研究节点分布——特别是 Gauss–Lobatto–Legendre (GLL) 节点与 Gauss–Legendre (GL) 节点——在间断伽辽金 (DG) 方法中对算子组装和守恒性质的影响。该分析针对一维线性平流方程 $u_t + a\\,u_x = 0$ 进行，该方程在参考单元区间 $r \\in [-1,1]$ 上使用节点 DG 方法进行离散化。\n\n**1. 节点基与求积**\n\n每个单元上的解由一个 $p$ 次多项式逼近，该多项式由定义在一组 $N=p+1$ 个节点上的拉格朗日基构成。\n- **Gauss–Lobatto–Legendre (GLL) 节点：** 这 $N$ 个节点包括端点 $r=\\{-1, 1\\}$。$N-2$ 个内部节点是 $p$ 次勒让德多项式导数 $P_p'(r)$ 的根，这等价于雅可比多项式 $P_{p-2}^{(1,1)}(r)$ 的根。这个选择至关重要，因为它能导出一个精确的分部求和 (SBP) 性质。\n- **Gauss–Legendre (GL) 节点：** 这 $N$ 个节点是 $(p+1)$ 次勒让德多项式 $P_{p+1}(r)$ 的根。它们都位于区间 $(-1,1)$ 的内部。这个选择能得到一个更高阶精度的求积法则，但不能精确满足 SBP 性质。\n\n对于每个节点集，我们定义一个对角质量矩阵 $M$，其对角元 $M_{ii}$ 是相应的求积权重 $w_i$。\n\n**2. 微分与限制算子**\n\n- **微分矩阵 ($D$)：** 节点微分矩阵 $D$ 的构造方式是，对于一个节点值向量 $u$，$D u$ 给出相应插值多项式导数的节点值。它可以使用重心插值权重高效计算。\n- **限制算子 ($R$)：** 限制算子 $R \\in \\mathbb{R}^{2 \\times N}$ 在单元面 $r=-1$ 和 $r=1$ 处评估多项式的值。对于包含端点的 GLL 节点，$R$ 是一个稀疏矩阵，其在对应端点节点的列中为 1，其余为 0。对于 GL 节点，$R$ 是一个稠密矩阵，其元素使用拉格朗日插值的重心公式在 $r=\\{-1, 1\\}$ 处计算。\n\n**3. 分部求和 (SBP) 性质与面-体失配**\n\nSBP 性质是分部积分的离散模拟，是证明高阶数值格式稳定性和守恒性的基础。对于我们的节点 DG 设置，它表示为：\n$$\nD^\\top M + M D = R^\\top B R\n$$\n其中 $B = \\mathrm{diag}(-1,1)$ 是面方向矩阵。这个恒等式表明微分算子在边界项意义下是反对称的。一个关键的理论结果是，这个恒等式对于 GLL 节点及其相应的求积法则是*精确*成立的。对于 GL 节点，则不成立。\n\n为了量化这一点，我们计算**面-体失配**，其定义为 SBP 误差矩阵的 Frobenius 范数：\n$$\n\\text{mismatch} = \\left\\| M D + D^\\top M - R^\\top B R \\right\\|_F\n$$\n对于 GLL 节点，此范数将在机器精度范围内为零。对于 GL 节点，它将非零，表明在离散分部积分恒等式中，体积分项（左侧）与面积分项（右侧）之间存在差异。\n\n**4. 弱形式与强形式以及 SBP 的作用**\n\n问题提供了一个起始的参考单元上的弱形式 DG 离散：\n$$\nM\\,J\\,\\dot{u} = -a\\,D^\\top M\\,u + R^\\top B\\,f^\\ast\n$$\n这里，$J$ 是映射的雅可比行列式，$\\dot{u}$ 是节点时间导数向量，$f^\\ast$ 是单元面上的数值通量向量。\n\n通过将 SBP 恒等式（$D^\\top M = -MD + R^\\top B R$）形式上代入弱形式，可以推导出“强形式”。这得到了计算中使用的残差表达式：\n$$\n\\dot{u} = \\frac{a}{J} D\\,u + \\frac{1}{J} M^{-1} R^\\top B \\left(f^\\ast - a\\,R\\,u\\right)\n$$\n项 $f^\\ast - a\\,R\\,u$ 表示数值通量与物理通量 $f(u)=au$ 在单元边界上的迹之差。对于周期性单元上的迎风通量（$f^\\ast = au^-$ 且 $a0$），该差异仅在每个单元的左面非零，其大小与解的跳跃成正比。\n\n**5. 离散守恒及其误差**\n\n全局质量变化率由 $\\frac{d}{dt} \\sum_{e} \\int_{K_e} u \\,dx$ 给出，其离散形式为 $\\sum_e J \\sum_i w_i \\dot{u}_i^{(e)}$。问题指出，对于具有周期性边界的精确弱形式，此量为零，意味着该方法是离散守恒的。\n\n当我们使用通过 SBP 代换推导出的强形式计算 $\\dot{u}$ 时，我们可以测量由此引发的**离散守恒误差**：\n$$\n\\text{error} = \\left|\\sum_{e=1}^{N_e} J \\sum_{i=1}^{N} w_i\\,\\dot{u}_i^{(e)}\\right|\n$$\n- 对于 **GLL 节点**，SBP 代换是精确的。推导出的强形式在代数上等价于守恒的弱形式。因此，计算出的守恒误差预计接近于零（机器精度）。\n- 对于 **GL 节点**，由于非零的面-体失配，SBP 代换是不精确的。因此，推导出的强形式不等价于原始的弱形式。这种代数不一致性破坏了确保守恒的项的抵消，导致非零的守恒误差。\n\n该实现系统地为两种节点类型构造这些算子，逐单元地用周期性连接组装强形式残差，然后为每个测试用例计算两个指定的度量（失配范数和守恒误差）。这定量地展示了 SBP 性质在将算子结构与 DG 方法中基本守恒律联系起来的关键作用。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_jacobi, eval_legendre, roots_legendre, legendre\n\ndef gauss_lobatto_legendre_nodes_weights(p):\n    \"\"\"\n    Computes Gauss-Lobatto-Legendre nodes and weights for polynomial degree p.\n    Nodes are roots of (1-x^2)P_p'(x).\n    \"\"\"\n    N = p + 1\n    if N == 1:\n        return np.array([0.0]), np.array([2.0])\n    \n    # Nodes are -1, 1, and roots of P_p'(x), which are roots of Jacobi P_{p-1}^{(1,1)}(x)\n    # The degree of the Jacobi polynomial is p-1.\n    interior_nodes = roots_jacobi(p - 1, 1, 1)[0] if p > 1 else np.array([])\n    nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n    \n    # Weights using formula: w_i = 2 / (p*(p+1) * [P_p(x_i)]^2)\n    Pn = legendre(p)\n    weights = 2 / (p * N * Pn(nodes)**2)\n    \n    idx = np.argsort(nodes)\n    nodes = nodes[idx]\n    weights = weights[idx]\n    \n    return nodes, weights\n\ndef gauss_legendre_nodes_weights(p):\n    \"\"\"\n    Computes Gauss-Legendre nodes and weights for polynomial degree p.\n    Uses N=p+1 points. Nodes are roots of P_{p+1}(x).\n    \"\"\"\n    N = p + 1\n    nodes, weights = roots_legendre(N)\n    \n    idx = np.argsort(nodes)\n    nodes = nodes[idx]\n    weights = weights[idx]\n    \n    return nodes, weights\n\ndef barycentric_weights(nodes):\n    \"\"\"\n    Computes barycentric weights for Lagrange interpolation.\n    \"\"\"\n    N = len(nodes)\n    weights = np.ones(N)\n    for j in range(N):\n        for k in range(N):\n            if k != j:\n                weights[j] /= (nodes[j] - nodes[k])\n    return weights\n\ndef differentiation_matrix(nodes, bary_weights):\n    \"\"\"\n    Computes the nodal differentiation matrix using the barycentric formula.\n    \"\"\"\n    N = len(nodes)\n    D = np.zeros((N, N))\n    for i in range(N):\n        sum_row = 0.0\n        for j in range(N):\n            if i != j:\n                D[i, j] = (bary_weights[j] / bary_weights[i]) / (nodes[i] - nodes[j])\n                sum_row += D[i, j]\n        D[i, i] = -sum_row\n    return D\n\ndef restriction_operator(nodes, bary_weights):\n    \"\"\"\n    Computes the restriction operator R for evaluating polynomials at r=-1 and r=1.\n    \"\"\"\n    N = len(nodes)\n    R = np.zeros((2, N))\n    \n    # Evaluation at r = -1\n    # Check if -1 is a node to avoid division by zero\n    if np.any(np.isclose(nodes, -1.0)):\n        idx = np.where(np.isclose(nodes, -1.0))[0][0]\n        R[0, idx] = 1.0\n    else:\n        # Use barycentric formula for L_j(-1)\n        terms = bary_weights / (-1.0 - nodes)\n        R[0, :] = terms / np.sum(terms)\n\n    # Evaluation at r = 1\n    if np.any(np.isclose(nodes, 1.0)):\n        idx = np.where(np.isclose(nodes, 1.0))[0][0]\n        R[1, idx] = 1.0\n    else:\n        # Use barycentric formula for L_j(1)\n        terms = bary_weights / (1.0 - nodes)\n        R[1, :] = terms / np.sum(terms)\n        \n    return R\n\ndef run_case(p, Ne, a, ic_func):\n    \"\"\"\n    Runs a single test case for both GLL and GL nodes, returning a list of 4 results.\n    \"\"\"\n    N = p + 1\n    h = 1.0 / Ne\n    J = h / 2.0\n    B = np.diag([-1.0, 1.0])\n    \n    case_results = []\n    \n    # --- Process for both GLL and GL node types ---\n    node_types = ['GLL', 'GL']\n    for node_type in node_types:\n        if node_type == 'GLL':\n            nodes, weights = gauss_lobatto_legendre_nodes_weights(p)\n            R = np.zeros((2, N))\n            R[0, 0] = 1.0 # Node 0 is at -1\n            R[1, -1] = 1.0 # Node N-1 is at 1\n        else: # GL\n            nodes, weights = gauss_legendre_nodes_weights(p)\n            bary_w = barycentric_weights(nodes)\n            R = restriction_operator(nodes, bary_w)\n\n        bary_weights = barycentric_weights(nodes)\n        D = differentiation_matrix(nodes, bary_weights)\n        M = np.diag(weights)\n\n        # 1. Face-volume mismatch norm\n        mismatch_norm = np.linalg.norm(M @ D + D.T @ M - R.T @ B @ R, 'fro')\n        \n        # 2. Discrete conservation error\n        # Initialize solution vector over all elements\n        u_global = np.zeros((Ne, N))\n        for e in range(Ne):\n            x_L = e * h\n            x_phys = x_L + J * (nodes + 1.0)\n            u_global[e, :] = ic_func(x_phys, x_L, h)\n            \n        u_dot_global = np.zeros((Ne, N))\n        M_inv = np.diag(1.0 / weights)\n    \n        # Assemble strong-form residual for all elements\n        for e in range(Ne):\n            u_e = u_global[e, :]\n            e_minus = (e - 1 + Ne) % Ne # Periodic neighbor\n            u_e_minus = u_global[e_minus, :]\n            \n            # For a > 0, upwind flux is determined by the state on the left.\n            # Upwind value for left face of element 'e' is trace from right face of 'e_minus'.\n            u_trace_left_neighbor_right = (R @ u_e_minus)[1]\n            # Interior value for left face of element 'e'.\n            u_trace_self_left = (R @ u_e)[0]\n\n            # The flux difference term: f* - a*R*u\n            flux_diff = np.zeros(2)\n            # At left face (r=-1): a*u_upwind - a*u_self = a * (u_from_left - u_self)\n            flux_diff[0] = a * (u_trace_left_neighbor_right - u_trace_self_left)\n            # At right face (r=+1): upwind flux is a*u_self, so difference is 0.\n            flux_diff[1] = 0.0\n            \n            # Strong form residual calculation\n            vol_term = (a / J) * (D @ u_e)\n            surf_term = (1.0 / J) * (M_inv @ R.T @ B @ flux_diff)\n            u_dot_global[e, :] = vol_term + surf_term\n            \n        # Compute global mass rate\n        global_mass_rate = 0.0\n        for e in range(Ne):\n            global_mass_rate += J * np.sum(weights * u_dot_global[e, :])\n        cons_err = np.abs(global_mass_rate)\n        \n        case_results.extend([mismatch_norm, cons_err])\n        \n    # Reorder to match GLL_mismatch, GL_mismatch, GLL_cons_err, GL_cons_err\n    return [case_results[0], case_results[2], case_results[1], case_results[3]]\n\ndef solve():\n    # Define test cases: (p, Ne, a, initial_condition_function)\n    test_cases = [\n        # Case 1: General case\n        (4, 4, 1.0, lambda x, x_L, h: np.sin(2 * np.pi * x)),\n        # Case 2: Single element, polynomial IC\n        (5, 1, 1.0, lambda x, x_L, h: eval_legendre(5, 2 * (x - x_L) / h - 1)),\n        # Case 3: Under-resolved wave\n        (2, 3, 1.0, lambda x, x_L, h: np.sin(10 * np.pi * x))\n    ]\n\n    final_results = []\n    for p, Ne, a, ic_func in test_cases:\n        # returns [GLL_mismatch, GL_mismatch, GLL_cons_err, GL_cons_err]\n        case_results = run_case(p, Ne, a, ic_func)\n        final_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}