{
    "hands_on_practices": [
        {
            "introduction": "刚度矩阵是将拉普拉斯算子等微分算子离散化的基石。本练习将通过一个具体实例，指导您为一维问题和低阶基函数手动计算刚度矩阵的每个元素。通过这种方式，您可以直观地理解其定义，并为处理更复杂的问题打下坚实的基础。",
            "id": "3398573",
            "problem": "考虑在参考单元 $[-1,1]$ 上具有单位扩散系数的一维泊松算子。在谱/间断 Galerkin 公式中，与多项式基 $\\{\\phi_{i}(x)\\}_{i=0}^{p}$ 相关联的局部刚度矩阵 $\\mathbf{K}$ 由弱形式的双线性形式定义为 $K_{ij} = \\int_{-1}^{1} \\frac{d \\phi_{i}}{d x}(x) \\frac{d \\phi_{j}}{d x}(x) \\, dx$。令 $\\{\\phi_{0}, \\phi_{1}, \\phi_{2}\\}$ 为 $[-1,1]$ 上次数为 $p=2$ 的 Legendre 基，其中 $\\phi_{n}(x) = P_{n}(x)$ 且 $P_{n}(x)$ 表示 $[-1,1]$ 上的 $n$ 次标准 Legendre 多项式，满足正交关系 $\\int_{-1}^{1} P_{m}(x) P_{n}(x) \\, dx = \\frac{2}{2n+1} \\delta_{mn}$。使用精确积分（即，精确计算定义积分），计算局部刚度矩阵 $\\mathbf{K}$ 并按 $\\{P_{0}, P_{1}, P_{2}\\}$ 的顺序列出其元素。你的最终答案必须是完整的$3 \\times 3$矩阵，以单一闭合形式解析表达式给出。无需四舍五入。",
            "solution": "该问题是有效的，因为它具有科学依据、良定、客观，并包含唯一解所需的所有必要信息。这是偏微分方程数值方法领域的一个标准问题。我们开始求解。\n\n任务是计算参考单元 $[-1, 1]$ 上一维泊松算子的局部刚度矩阵 $\\mathbf{K}$。刚度矩阵的元素由以下积分定义：\n$$\nK_{ij} = \\int_{-1}^{1} \\frac{d \\phi_{i}}{d x}(x) \\frac{d \\phi_{j}}{d x}(x) \\, dx\n$$\n基函数 $\\{\\phi_{i}\\}_{i=0}^{2}$ 被选为区间 $[-1, 1]$ 上的标准 Legendre 多项式 $\\{P_{i}\\}_{i=0}^{2}$。我们考虑 $p=2$ 的基组，它由 $\\{P_{0}(x), P_{1}(x), P_{2}(x)\\}$ 组成。\n\n首先，我们列出所需的 Legendre 多项式及其导数。前三个标准 Legendre 多项式是：\n$$\n\\phi_{0}(x) = P_{0}(x) = 1\n$$\n$$\n\\phi_{1}(x) = P_{1}(x) = x\n$$\n$$\n\\phi_{2}(x) = P_{2}(x) = \\frac{1}{2}(3x^2 - 1)\n$$\n接下来，我们计算这些基函数关于 $x$ 的导数：\n$$\n\\frac{d \\phi_{0}}{d x} = \\frac{d P_{0}}{d x} = 0\n$$\n$$\n\\frac{d \\phi_{1}}{d x} = \\frac{d P_{1}}{d x} = 1\n$$\n$$\n\\frac{d \\phi_{2}}{d x} = \\frac{d P_{2}}{d x} = \\frac{d}{dx} \\left( \\frac{1}{2}(3x^2 - 1) \\right) = \\frac{1}{2}(6x) = 3x\n$$\n\n现在，我们可以使用积分定义来计算刚度矩阵 $\\mathbf{K}$ 的 $3 \\times 3$ 个元素。该矩阵是对称的，即 $K_{ij} = K_{ji}$，因此我们只需要计算上三角元素。\n\n对于 $i=0$：\n由于 $\\frac{d \\phi_{0}}{dx} = 0$，矩阵的第一行和第一列中的所有元素都将为零。\n$$\nK_{00} = \\int_{-1}^{1} (0)(0) \\, dx = 0\n$$\n$$\nK_{01} = \\int_{-1}^{1} (0)(1) \\, dx = 0\n$$\n$$\nK_{02} = \\int_{-1}^{1} (0)(3x) \\, dx = 0\n$$\n根据对称性， $K_{10} = K_{01} = 0$ 且 $K_{20} = K_{02} = 0$。\n\n对于 $i=1$：\n$$\nK_{11} = \\int_{-1}^{1} \\left( \\frac{d \\phi_{1}}{d x} \\right)^2 \\, dx = \\int_{-1}^{1} (1)^2 \\, dx = \\int_{-1}^{1} 1 \\, dx = [x]_{-1}^{1} = 1 - (-1) = 2\n$$\n$$\nK_{12} = \\int_{-1}^{1} \\frac{d \\phi_{1}}{d x} \\frac{d \\phi_{2}}{d x} \\, dx = \\int_{-1}^{1} (1)(3x) \\, dx = 3 \\int_{-1}^{1} x \\, dx = 3 \\left[ \\frac{x^2}{2} \\right]_{-1}^{1} = 3 \\left( \\frac{1^2}{2} - \\frac{(-1)^2}{2} \\right) = 0\n$$\n根据对称性， $K_{21} = K_{12} = 0$。\n\n对于 $i=2$：\n$$\nK_{22} = \\int_{-1}^{1} \\left( \\frac{d \\phi_{2}}{d x} \\right)^2 \\, dx = \\int_{-1}^{1} (3x)^2 \\, dx = 9 \\int_{-1}^{1} x^2 \\, dx = 9 \\left[ \\frac{x^3}{3} \\right]_{-1}^{1} = 9 \\left( \\frac{1^3}{3} - \\frac{(-1)^3}{3} \\right) = 9 \\left( \\frac{1}{3} - \\left(-\\frac{1}{3}\\right) \\right) = 9 \\left( \\frac{2}{3} \\right) = 6\n$$\n另外，对于 $K_{22}$，我们可以使用 Legendre 多项式的正交性。注意 $\\frac{d \\phi_{2}}{dx} = 3x = 3P_{1}(x)$。\n$$\nK_{22} = \\int_{-1}^{1} (3 P_{1}(x))(3 P_{1}(x)) \\, dx = 9 \\int_{-1}^{1} P_{1}(x) P_{1}(x) \\, dx\n$$\n使用给定的正交关系 $\\int_{-1}^{1} P_{m}(x) P_{n}(x) \\, dx = \\frac{2}{2n+1} \\delta_{mn}$，其中 $m=n=1$：\n$$\n\\int_{-1}^{1} P_{1}(x) P_{1}(x) \\, dx = \\frac{2}{2(1)+1} = \\frac{2}{3}\n$$\n因此， $K_{22} = 9 \\times \\frac{2}{3} = 6$，这证实了我们直接积分的结果。\n\n将计算出的元素组装成矩阵 $\\mathbf{K}$：\n$$\n\\mathbf{K} =\n\\begin{pmatrix}\nK_{00} & K_{01} & K_{02} \\\\\nK_{10} & K_{11} & K_{12} \\\\\nK_{20} & K_{21} & K_{22}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 & 0 & 0 \\\\\n0 & 2 & 0 \\\\\n0 & 0 & 6\n\\end{pmatrix}\n$$\n这就是基 $\\{P_0, P_1, P_2\\}$ 的局部刚度矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & 0 & 0 \\\\\n0 & 2 & 0 \\\\\n0 & 0 & 6\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在理想情况下，精确积分可以保证离散格式继承连续问题的重要性质，例如能量守恒。然而，在实践中我们通常使用数值求积，本练习将探讨这对平流问题中对流矩阵的影响。您将通过一个数值实验，亲眼见证不精确的求积（即“混淆误差”）如何破坏算子的反对称性，导致系统能量出现虚假的增长或衰减，从而深刻理解保证数值稳定性的重要性。",
            "id": "3398522",
            "problem": "考虑区间 $[-1,1]$ 上的带周期性边界条件的一维线性平流方程，\n$$\n\\partial_t u(x,t) + \\partial_x u(x,t) = 0,\n$$\n及其在模态勒让德基 $\\{\\phi_i(x)\\}_{i=0}^p$ 中的谱伽辽金半离散化，其中 $\\phi_i(x)$ 是 $[-1,1]$ 上的第 $i$ 个勒让德多项式。令 $u_h(x,t) = \\sum_{j=0}^p \\hat{u}_j(t)\\,\\phi_j(x)$ 表示谱近似，其系数为 $\\hat{u}_j(t)$。\n\n通过伽辽金弱形式定义质量矩阵 $M \\in \\mathbb{R}^{(p+1)\\times(p+1)}$ 和对流（刚度）矩阵 $K\\in \\mathbb{R}^{(p+1)\\times(p+1)}$\n$$\nM_{ij} = \\int_{-1}^{1} \\phi_i(x)\\,\\phi_j(x)\\,dx,\\qquad\nK_{ij} = \\int_{-1}^{1} \\phi_i(x)\\,\\partial_x \\phi_j(x)\\,dx,\n$$\n并设半离散算子为 $C = M^{-1}K$。半离散系统可写为\n$$\n\\frac{d\\hat{\\mathbf{u}}}{dt} + C\\,\\hat{\\mathbf{u}} = 0,\\quad \\hat{\\mathbf{u}}(0) = \\hat{\\mathbf{u}}_0.\n$$\n\n在精确算术和对 $M$ 与 $K$ 进行精确积分的情况下，周期性边界条件意味着 $M$-斜对称性\n$$\nM C + C^\\top M = \\mathbf{0},\n$$\n因此离散 $L^2$ 能量 $E(t) = \\tfrac{1}{2}\\,\\hat{\\mathbf{u}}(t)^\\top M\\,\\hat{\\mathbf{u}}(t)$ 是守恒的，即 $\\frac{dE}{dt} = 0$。然而，如果使用不精确的求积法则组装 $K$，$M$-斜对称性通常会失效，这可能导致离散能量的伪增长或衰减。\n\n您的任务是通过组装 $M$ 和 $K$ 来演示谱伽辽金方法中的求积混叠现象。使用以下步骤：\n\n- 使用 $Q$ 阶高斯-勒让德求积，通过 $\\sum_{q=1}^{Q} w_q\\,f(x_q)$ 来近似任何积分 $\\int_{-1}^1 f(x)\\,dx$，其中 $\\{x_q,w_q\\}_{q=1}^Q$ 是高斯-勒让德节点和权重。\n- 使用 $Q_M = p+1$ 组装 $M$，以确保多项式质量积分的精确性。\n- 使用可变法则 $Q_K$（可能小于 $p+1$）组装 $K$，以在对流算子中故意引入不精确性，从而产生混叠。\n- 定义 $C = M^{-1}K$。\n- 选择初始条件 $u(x,0) = \\sin(\\pi x)$，并通过求解 $M\\,\\hat{\\mathbf{u}}_0 = \\mathbf{b}$ 来计算其 $L^2$ 投影系数 $\\hat{\\mathbf{u}}_0$，其中 $b_i = \\int_{-1}^1 \\phi_i(x)\\,u(x,0)\\,dx$。使用足够高的求积阶数 $Q_{\\text{proj}} = 2p+5$ 来近似这些投影积分。\n- 使用显式四阶龙格-库塔（Runge–Kutta (RK) of order 4）方法对常微分方程组进行时间演化，直到最终时间 $T$。根据谱半径 $\\rho(C)$ 选择时间步长 $\\Delta t$，使得 $\\Delta t = \\text{CFL}/\\max(\\rho(C),\\varepsilon)$，其中 $\\text{CFL} = 0.1$，$\\varepsilon = 10^{-14}$；使用固定的步数 $N = \\lceil T/\\Delta t \\rceil$ 并调整 $\\Delta t$ 以精确达到 $T$。\n- 使用以 $Q_{\\text{en}}=2p+5$ 组装的高阶能量评估质量矩阵 $M_{\\text{en}}$ 和以下公式，来测量在时间 $T$ 的相对能量误差：\n$$\n\\mathcal{E}_{\\text{rel}} = \\frac{\\tfrac{1}{2}\\,\\hat{\\mathbf{u}}(T)^\\top M_{\\text{en}}\\,\\hat{\\mathbf{u}}(T) - \\tfrac{1}{2}\\,\\hat{\\mathbf{u}}(0)^\\top M_{\\text{en}}\\,\\hat{\\mathbf{u}}(0)}{\\tfrac{1}{2}\\,\\hat{\\mathbf{u}}(0)^\\top M_{\\text{en}}\\,\\hat{\\mathbf{u}}(0)}.\n$$\n\n实现一个程序，对于下面的每个测试用例 $(p,Q_K,T)$，使用 $Q_M=p+1$ 构建 $M$，使用指定的 $Q_K$ 构建 $K$，形成 $C=M^{-1}K$，投影初始数据，用四阶龙格-库塔方法将系统推进到时间 $T$，并返回 $\\mathcal{E}_{\\text{rel}}$ 作为一个浮点数。\n\n使用以下测试套件：\n- 测试 $1$：$(p,Q_K,T) = (0,1,0.1)$。\n- 测试 $2$：$(p,Q_K,T) = (3,2,0.2)$。\n- 测试 $3$：$(p,Q_K,T) = (7,5,0.2)$。\n- 测试 $4$：$(p,Q_K,T) = (7,8,0.2)$。\n- 测试 $5$：$(p,Q_K,T) = (9,6,0.15)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[\\text{result}_1,\\text{result}_2,\\dots]$，其中每个条目是按顺序列出的相应测试用例的 $\\mathcal{E}_{\\text{rel}}$ 值。不应打印其他任何文本。",
            "solution": "我们从区间 $[-1,1]$ 上带周期性边界条件的一维平流方程 $\\partial_t u + \\partial_x u = 0$ 的伽辽金弱形式开始。使用模态勒让德基 $\\{\\phi_i\\}_{i=0}^p$，半离散近似 $u_h(x,t) = \\sum_{j=0}^p \\hat{u}_j(t)\\,\\phi_j(x)$ 强制满足\n$$\n\\int_{-1}^{1} \\phi_i(x)\\,\\partial_t u_h(x,t)\\,dx + \\int_{-1}^{1} \\phi_i(x)\\,\\partial_x u_h(x,t)\\,dx = 0,\\quad \\forall i\\in\\{0,\\dots,p\\}.\n$$\n利用线性性并定义质量矩阵和对流矩阵，\n$$\nM_{ij} = \\int_{-1}^{1} \\phi_i(x)\\,\\phi_j(x)\\,dx,\\qquad\nK_{ij} = \\int_{-1}^{1} \\phi_i(x)\\,\\partial_x \\phi_j(x)\\,dx,\n$$\n我们得到系数向量 $\\hat{\\mathbf{u}}(t)$ 的常微分方程：\n$$\nM\\,\\frac{d\\hat{\\mathbf{u}}}{dt} + K\\,\\hat{\\mathbf{u}} = 0\\quad\\Longleftrightarrow\\quad \\frac{d\\hat{\\mathbf{u}}}{dt} + C\\,\\hat{\\mathbf{u}} = 0,\\quad C = M^{-1}K.\n$$\n当使用精确积分时，我们可以通过分部积分来检验该方案的能量守恒特性。离散能量 $E(t) = \\tfrac{1}{2}\\hat{\\mathbf{u}}^\\top M \\hat{\\mathbf{u}}$ 的时间导数为：\n$$\n\\frac{dE}{dt} = \\hat{\\mathbf{u}}^\\top M \\frac{d\\hat{\\mathbf{u}}}{dt} = -\\hat{\\mathbf{u}}^\\top M (M^{-1}K) \\hat{\\mathbf{u}} = -\\hat{\\mathbf{u}}^\\top K \\hat{\\mathbf{u}} = -\\frac{1}{2} \\hat{\\mathbf{u}}^\\top (K + K^\\top) \\hat{\\mathbf{u}}\n$$\n矩阵 $K+K^\\top$ 的元素为：\n$$\n(K+K^\\top)_{ij} = \\int_{-1}^1 (\\phi_i \\partial_x \\phi_j + \\phi_j \\partial_x \\phi_i) dx = \\int_{-1}^1 \\partial_x(\\phi_i \\phi_j) dx = [\\phi_i \\phi_j]_{-1}^1\n$$\n由于勒让德基函数在边界 $x=\\pm 1$ 上的值通常不为零（且不具有周期性），所以边界项 $[\\phi_i \\phi_j]_{-1}^1$ 通常不为零。这意味着即使使用精确积分，该半离散格式也不是严格能量守恒的，能量的变化率 $\\frac{dE}{dt}$ 反映了通过区域边界的能量通量。问题描述中提到的周期性边界条件意味着这个边界项会消失，从而实现能量守恒，但标准的勒让德基不满足此条件。\n\n然而，如果使用不精确的求积（即混淆）来组装 $K$ 为 $\\tilde{K}$，那么计算出的矩阵 $\\tilde{K} + \\tilde{K}^\\top$ 将偏离其真实值。这种偏差会引入一个虚假的、纯数值的能量源或汇，导致能量随时间的漂移，这正是本练习旨在演示的求积混叠现象。\n\n算法构建：\n\n- 基和求积。我们选择勒让德基 $\\phi_i = P_i$，其中 $P_i$ 是 $[-1,1]$ 上的第 $i$ 个勒让德多项式。对于任何求积阶数 $Q$，高斯-勒让德节点和权重 $\\{x_q,w_q\\}_{q=1}^Q$ 都能精确地对最高为 $2Q-1$ 次的多项式进行积分。\n\n- 质量矩阵。为确保质量矩阵可逆且精确，我们使用 $Q_M = p+1$ 来组装 $M$，这样任何乘积 $\\phi_i\\,\\phi_j$（次数最高为 $2p$）都能被精确积分，因为 $2(p+1)-1 = 2p+1 \\ge 2p$。数值上，\n$$\nM_{ij} \\approx \\sum_{q=1}^{Q_M} w_q\\,\\phi_i(x_q)\\,\\phi_j(x_q).\n$$\n\n- 对流矩阵。我们通过使用可能较低的求积阶数 $Q_K$ 来组装 $K$ 以引入不精确性：\n$$\nK_{ij} \\approx \\sum_{q=1}^{Q_K} w_q\\,\\phi_i(x_q)\\,\\partial_x \\phi_j(x_q).\n$$\n如果 $Q_K$ 不足以精确积分次数最高达 $2p-1$ 的被积函数 $\\phi_i \\partial_x \\phi_j$，就会产生混叠误差。\n\n- 半离散算子。我们通过求解 $M C = K$ 来得到 $C = M^{-1}K$。\n\n- 初始条件和投影。我们设置 $u(x,0)=\\sin(\\pi x)$ 并计算其在 $\\{\\phi_i\\}_{i=0}^p$ 张成的空间上的 $L^2$ 投影：\n$$\nb_i = \\int_{-1}^1 \\phi_i(x)\\,u(x,0)\\,dx\\approx \\sum_{q=1}^{Q_{\\text{proj}}} w_q\\,\\phi_i(x_q)\\,u(x_q,0),\n$$\n其中 $Q_{\\text{proj}}=2p+5$，然后求解 $M\\,\\hat{\\mathbf{u}}_0 = \\mathbf{b}$。\n\n- 时间步进。我们使用四阶显式龙格-库塔方法求解 $\\frac{d\\hat{\\mathbf{u}}}{dt} = -C\\,\\hat{\\mathbf{u}}$。为减小时间离散误差并避免不稳定性，我们根据谱半径 $\\rho(C)$ 选择步长：\n$$\n\\Delta t = \\frac{\\text{CFL}}{\\max(\\rho(C),\\varepsilon)},\\quad \\text{CFL} = 0.1,\\ \\varepsilon=10^{-14},\n$$\n取 $N=\\lceil T/\\Delta t\\rceil$ 步，并调整 $\\Delta t=T/N$ 以精确达到最终时间。\n\n- 能量测量。为了稳健地量化能量漂移，我们使用以 $Q_{\\text{en}}=2p+5$ 组装的高阶质量矩阵 $M_{\\text{en}}$ 来评估能量：\n$$\nE(0) = \\tfrac{1}{2}\\,\\hat{\\mathbf{u}}_0^\\top M_{\\text{en}}\\,\\hat{\\mathbf{u}}_0,\\quad E(T) = \\tfrac{1}{2}\\,\\hat{\\mathbf{u}}(T)^\\top M_{\\text{en}}\\,\\hat{\\mathbf{u}}(T),\n$$\n并报告相对误差 $\\mathcal{E}_{\\text{rel}} = \\frac{E(T)-E(0)}{E(0)}$。\n\n测试设计和覆盖范围：\n\n- 测试 $1$：$(p,Q_K,T)=(0,1,0.1)$。这里 $\\phi_0$ 是常数，$\\partial_x \\phi_0=0$，因此无论 $Q_K$ 如何，$K=\\mathbf{0}$，且 $\\mathcal{E}_{\\text{rel}}=0$（在舍入误差范围内），这作为一个边界情况。\n\n- 测试 $2$：$(p,Q_K,T)=(3,2,0.2)$。质量是精确的，而 $K$ 是欠积分的（$Q_K",
            "answer": "```python\nimport numpy as np\n\ndef gauss_legendre(n):\n    # Gauss-Legendre nodes and weights on [-1,1]\n    x, w = np.polynomial.legendre.leggauss(n)\n    return x, w\n\ndef legendre_and_derivative_values(p, x):\n    # Evaluate Legendre polynomials P_0..P_p and their derivatives at points x\n    # Returns arrays of shape (p+1, len(x))\n    x = np.asarray(x)\n    vals = np.zeros((p + 1, x.size))\n    ders = np.zeros((p + 1, x.size))\n    for i in range(p + 1):\n        P = np.polynomial.legendre.Legendre.basis(i)\n        dP = P.deriv()\n        vals[i, :] = P(x)\n        ders[i, :] = dP(x)\n    return vals, ders\n\ndef assemble_mass(p, Q):\n    # Assemble mass matrix M using Gauss-Legendre quadrature of order Q\n    xq, wq = gauss_legendre(Q)\n    V, _ = legendre_and_derivative_values(p, xq)\n    # M = V W V^T\n    M = V @ (wq[:, None] * V.T)\n    return M\n\ndef assemble_stiffness_K(p, QK):\n    # Assemble convection (stiffness) matrix K_ij = ∫ phi_i * d(phi_j)/dx dx\n    xq, wq = gauss_legendre(QK)\n    V, dV = legendre_and_derivative_values(p, xq)\n    K = V @ (wq[:, None] * dV.T)\n    return K\n\ndef project_initial_condition(p, Qproj, u_func):\n    # Compute L2 projection coefficients of u_func onto span{phi_0..phi_p}\n    xq, wq = gauss_legendre(Qproj)\n    V, _ = legendre_and_derivative_values(p, xq)\n    uvals = u_func(xq)\n    # b_i = ∫ phi_i * u dx ≈ sum wq * phi_i(xq) * u(xq)\n    b = V @ (wq * uvals)\n    # Mass matrix for projection (exact for polynomials if Qproj large)\n    Mproj = V @ (wq[:, None] * V.T)\n    coeffs = np.linalg.solve(Mproj, b)\n    return coeffs\n\ndef rk4_linear(C, u0, dt, nsteps):\n    u = u0.copy()\n    for _ in range(nsteps):\n        k1 = -C @ u\n        k2 = -C @ (u + 0.5 * dt * k1)\n        k3 = -C @ (u + 0.5 * dt * k2)\n        k4 = -C @ (u + dt * k3)\n        u = u + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n    return u\n\ndef energy(u, M):\n    return 0.5 * float(u.T @ (M @ u))\n\ndef solve_case(p, QK, T):\n    # Assemble mass with exact quadrature QM = p+1\n    QM = p + 1\n    M = assemble_mass(p, QM)\n    # Assemble stiffness with possibly inexact quadrature QK\n    K = assemble_stiffness_K(p, QK)\n    # Operator C = M^{-1} K\n    C = np.linalg.solve(M, K)\n    # Initial condition u(x,0) = sin(pi x)\n    u_func = lambda x: np.sin(np.pi * x)\n    Qproj = max(2 * p + 5, 10)\n    u0 = project_initial_condition(p, Qproj, u_func)\n    # Energy evaluation mass matrix with high-order quadrature\n    Men = assemble_mass(p, Qproj)\n    E0 = energy(u0, Men)\n    if np.abs(E0) < 1e-14:\n        return 0.0\n\n    # Time step based on spectral radius\n    if p == 0:\n        rho = 0.0\n    else:\n        eigvals = np.linalg.eigvals(C)\n        rho = float(np.max(np.abs(eigvals))) if eigvals.size > 0 else 0.0\n    \n    CFL = 0.1\n    eps = 1e-14\n    dt = CFL / max(rho, eps)\n    nsteps = max(1, int(np.ceil(T / dt)))\n    dt = T / nsteps\n    \n    # Time integration\n    uT = rk4_linear(C, u0, dt, nsteps)\n    ET = energy(uT, Men)\n    rel_err = (ET - E0) / E0\n    return rel_err\n\ndef solve():\n    # Define the test cases (p, QK, T)\n    test_cases = [\n        (0, 1, 0.1),\n        (3, 2, 0.2),\n        (7, 5, 0.2),\n        (7, 8, 0.2),\n        (9, 6, 0.15),\n    ]\n    results = []\n    for p, QK, T in test_cases:\n        rel_err = solve_case(p, QK, T)\n        results.append(rel_err)\n    # Print in exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在二维和三维问题中，尤其是在使用高阶多项式时，完全组装的刚度矩阵的规模会变得异常庞大，给存储和计算带来巨大挑战。本练习将引导您分析一种高效的“和因子分解”算法，该算法利用基函数的张量积结构，无需显式构造矩阵即可完成算子与向量的乘积。通过推导和比较其与传统稠密矩阵方法的计算复杂度，您将量化地理解为何这种无矩阵技术是高阶谱方法在实际应用中不可或缺的关键。",
            "id": "3398537",
            "problem": "考虑在谱元法 (SEM) 和间断伽辽金 (DG) 离散化中，将在单个参考六面体单元 $\\hat{\\Omega}=[-1,1]^{3}$ 上由拉普拉斯算子弱形式产生的刚度算子 $K$ 的应用。设标量试探空间和检验空间由在三个坐标方向上每个方向的 $p+1$ 个高斯-洛巴托-勒让德 (GLL) 节点上构建的张量积拉格朗日基函数张成，因此每个单元的自由度数为 $N=(p+1)^{3}$。假设一个配置公式，其中质量矩阵在 GLL 求积下是对角的，几何是具有单位雅可比矩阵和常系数的仿射映射，因此度量项是平凡的，并且单元级的刚度算子简化为三个可分离的一维贡献之和。\n\n定义一维微分矩阵 $D\\in\\mathbb{R}^{n\\times n}$，其中 $n=p+1$，其元素为 $D_{ij}=l_{j}'(\\xi_{i})$，其中 $l_{j}$ 是 GLL 节点 $\\{\\xi_{i}\\}_{i=1}^{n}$ 上的拉格朗日基多项式。设 $\\{w_{i}\\}_{i=1}^{n}$ 为一维 GLL 求积权重，并设张量积节点 $(i,j,k)$ 处的三维求积权重为 $w_{i}w_{j}w_{k}$。根据这些定义，单元刚度算子可以写成张量积形式，即对坐标方向上的一维导数转置、对角加权和一维导数应用的求和。\n\n考虑两种应用策略：\n- 一种无矩阵的和因子分解应用，它利用张量积可分离性，在每个坐标方向上沿线执行一系列一维矩阵向量乘积，并进行对角缩放和累加。\n- 与完全组合的 $N\\times N$ 刚度矩阵进行的朴素稠密矩阵向量乘积。\n\n假设采用以下浮点运算 (flop) 模型：一次标量乘法或一次标量加法均计为一次 flop；一个稠密的 $n\\times n$ 矩阵向量乘法耗费 $2n^{2}$ flops (输出向量的每个元素需要 $n$ 次乘法和 $n-1$ 次加法)；一个长度为 $n$ 的向量的对角缩放耗费 $n$ flops；对三个逐元素贡献求和每个自由度耗费 2 次加法。忽略通量项、罚项和边界项，以及除上述对角求积权重之外的任何几何因子收缩。\n\n从可分离弱形式和这些运算假设出发，推导：\n1. 对 $K$ 的和因子分解应用，每个单元的总 flop 计数，作为 $p$ 的函数。\n2. 对朴素稠密矩阵向量应用，每个单元的总 flop 计数，作为 $p$ 的函数。\n3. 朴素稠密 flop 计数与和因子分解 flop 计数的比率，作为 $p$ 的闭式解析表达式。\n\n将最终答案表示为关于 $p$ 的单一比率。无需四舍五入，不涉及物理单位。首次使用时定义所有缩写，包括间断伽辽金 (DG) 和谱元法 (SEM)。",
            "solution": "该问题要求推导在参考六面体上应用谱元刚度算子的两种方法的浮点运算 (flop) 计数，并求出这些计数的比率。\n\n首先，我们建立数学背景和符号。离散化使用了在三个空间方向 $\\xi$、$\\eta$ 和 $\\zeta$ 上，每个方向的 $n=p+1$ 个高斯-洛巴托-勒让德 (GLL) 节点上构建的 $p$ 次张量积拉格朗日多项式基。每个单元的总自由度 (DoF) 数为 $N = n^3 = (p+1)^3$。单元上的解向量 $u$ 可以表示为一个大小为 $n \\times n \\times n$ 的三维数组。\n\n刚度算子 $K$ 来自负拉普拉斯算子 $-\\nabla^2$ 的弱形式，对于参考单元 $\\hat{\\Omega}=[-1,1]^3$ 上的检验函数 $v$ 和试探函数 $u$，该弱形式由积分 $\\int_{\\hat{\\Omega}} \\nabla v \\cdot \\nabla u \\, d\\hat{\\Omega}$ 给出。在单位雅可比矩阵的假设下，这可以分解为三项：\n$$ \\int_{\\hat{\\Omega}} \\frac{\\partial v}{\\partial \\xi}\\frac{\\partial u}{\\partial \\xi} \\, d\\hat{\\Omega} + \\int_{\\hat{\\Omega}} \\frac{\\partial v}{\\partial \\eta}\\frac{\\partial u}{\\partial \\eta} \\, d\\hat{\\Omega} + \\int_{\\hat{\\Omega}} \\frac{\\partial v}{\\partial \\zeta}\\frac{\\partial u}{\\partial \\zeta} \\, d\\hat{\\Omega} $$\n当使用 GLL 基函数并在 GLL 节点处进行配置（这使得质量矩阵成为对角矩阵）进行离散化时，算子作用 $Ku$ 可以写成三个分量的和，$Ku = K_\\xi u + K_\\eta u + K_\\zeta u$。每个分量对应一个空间方向。\n\n在配置公式中，离散的拉普拉斯算子作用在向量 $u$ 上可以被符号化地写为 $M^{-1} S u$，其中 $S$ 是刚度矩阵 $S_{ij} = \\int \\nabla \\phi_i \\cdot \\nabla \\phi_j dx$，而 $M$ 是对角质量（求积权重）矩阵。和因子分解方法直接计算 $S u$ 的作用。$S$ 分解为 $S = S_\\xi + S_\\eta + S_\\zeta$。$S_\\xi u$ 的作用通过一维算子 $D$（微分矩阵）和 $B$（对角质量矩阵）的张量积来计算。具体来说，$S_\\xi$ 作用于三维数据数组 $U$ 的过程可以写成：\n1.  对每个 $(\\eta_j, \\zeta_k)$ 平面，沿 $\\xi$ 方向应用一维微分矩阵 $D$：$U' = DU$。\n2.  对结果进行逐点（对角）加权：$U'' = B U'$。\n3.  沿 $\\xi$ 方向应用转置微分矩阵 $D^T$：$V_\\xi = D^T U''$。\n在我们的 flop 模型中，$B$ 的应用对应于对角质量矩阵的缩放。\n\n1.  **和因子分解应用的 Flop 计数 ($C_{SF}$)**\n和因子分解方法计算算子作用 $Ku$ 时无需组合完整矩阵 $K$。它分别计算每个方向的贡献然后求和：$v = (K_\\xi u) + (K_\\eta u) + (K_\\zeta u)$。我们来分析一项 $v_\\xi = D_\\xi^T M (D_\\xi u)$ 的 flop 计数，其中 $D_\\xi = D \\otimes I \\otimes I$，$M$ 是对角求积权重矩阵。\n\n-   **步骤 1：应用 $D_\\xi$。** 运算 $u' = D_\\xi u$ 对应于将一维微分矩阵 $D$ 应用于沿 $\\xi$-纤维的数据。共有 $n^2$ 条这样的纤维（每对 $(\\eta_j, \\zeta_k)$ 索引对应一条），每条长度为 $n$。一次稠密 $n \\times n$ 矩阵向量乘积的耗费为 $2n^2$ flops。\n    -   $D_\\xi u$ 的耗费：$n^2 \\times (2n^2) = 2n^4$ flops。\n\n-   **步骤 2：应用 $M$。** 运算 $u'' = M u'$ 是通过对角质量矩阵 $M$ 进行缩放。这对应于将长度为 $N=n^3$ 的向量 $u'$ 与 $M$ 的对角元进行逐元素乘法。\n    -   $M u'$ 的耗费：$N = n^3$ flops。\n\n-   **步骤 3：应用 $D_\\xi^T$。** 运算 $v_\\xi = D_\\xi^T u''$ 与步骤 1 类似，即沿 $\\xi$-纤维应用转置微分矩阵 $D^T$。\n    -   $D_\\xi^T u''$ 的耗费：$n^2 \\times (2n^2) = 2n^4$ flops。\n\n计算一个方向贡献 ($v_\\xi$) 的总耗费是这三个步骤耗费的总和：$2n^4 + n^3 + 2n^4 = 4n^4 + n^3$ flops。\n根据对称性，计算 $v_\\eta$ 和 $v_\\zeta$ 的耗费是相同的。计算所有三个贡献的总耗费是 $3 \\times (4n^4 + n^3) = 12n^4 + 3n^3$ flops。\n\n-   **步骤 4：累加结果。** 最终结果是 $v = v_\\xi + v_\\eta + v_\\zeta$。这涉及对三个长度为 $N=n^3$ 的向量求和。这需要两次向量加法。问题指定这耗费每个自由度 2 次加法。\n    -   累加的耗费：$2N = 2n^3$ flops。\n\n和因子分解应用的总 flop 计数是所有步骤的总和：\n$$C_{SF} = (12n^4 + 3n^3) + 2n^3 = 12n^4 + 5n^3$$\n代入 $n=p+1$，我们得到 $C_{SF} = 12(p+1)^4 + 5(p+1)^3$。\n\n2.  **朴素稠密应用的 Flop 计数 ($C_{Naive}$)**\n朴素方法涉及形成完整的 $N \\times N$ 刚度矩阵 $K$ 并执行标准的矩阵向量乘积 $Ku$。\n-   矩阵的大小为 $N \\times N$，其中 $N=n^3 = (p+1)^3$。\n-   问题陈述一个稠密的 $M \\times M$ 矩阵向量乘法耗费 $2M^2$ flops。在我们的情况下，大小为 $N$。\n-   因此耗费为 $2N^2$。\n$$C_{Naive} = 2N^2 = 2(n^3)^2 = 2n^6$$\n代入 $n=p+1$，我们得到 $C_{Naive} = 2(p+1)^6$。\n\n3.  **Flop 计数比率**\n朴素稠密 flop 计数与和因子分解 flop 计数的比率为：\n$$ \\text{Ratio} = \\frac{C_{Naive}}{C_{SF}} = \\frac{2n^6}{12n^4 + 5n^3} $$\n对于任何有效的离散化，$p \\ge 1$ 因而 $n \\ge 2$，所以我们可以通过将分子和分母同除以 $n^3$ 来简化表达式：\n$$ \\text{Ratio} = \\frac{2n^3}{12n + 5} $$\n最后，我们通过代入 $n=p+1$ 将比率表示为多项式次数 $p$ 的函数：\n$$ \\text{Ratio} = \\frac{2(p+1)^3}{12(p+1) + 5} = \\frac{2(p+1)^3}{12p + 12 + 5} = \\frac{2(p+1)^3}{12p + 17} $$\n这个表达式量化了和因子分解技术相对于朴素稠密矩阵方法的显著计算优势，这种优势随着多项式次数 $p$ 的增加而迅速增长。",
            "answer": "$$ \\boxed{\\frac{2(p+1)^3}{12p+17}} $$"
        }
    ]
}