{
    "hands_on_practices": [
        {
            "introduction": "数值通量的选择直接影响最终离散系统的代数性质。本练习将引导你为一个对称的LDG通量选择，显式地构建界面罚矩阵。通过这个过程，你将亲手验证这一选择如何保证了罚矩阵的对称性，从而将抽象的公式与具体的矩阵属性联系起来。",
            "id": "3405412",
            "problem": "考虑在一个双单元片区上的一维泊松方程，写成一阶局部不连续伽辽金 (LDG) 形式：\n$$\nq = u_x, \\qquad -q_x = f,\n$$\n在区域 $\\Omega = [0,2h]$上，该区域被划分为单元 $K^{-} = [0,h]$ 和 $K^{+} = [h,2h]$。在每个单元上，在由参考单元 $\\hat{K} = [-1,1]$ 上的模态勒让德基函数张成的相同 $p=1$ 次多项式空间中近似 $u$ 和 $q$：\n$$\n\\phi_0(\\xi) = \\frac{1}{\\sqrt{2}}, \\qquad \\phi_1(\\xi) = \\sqrt{\\frac{3}{2}}\\,\\xi,\n$$\n通过仿射映射 $x = x_c + \\frac{h}{2}\\,\\xi$ 从 $\\hat{K}$ 映射到每个物理单元。在内部界面 $F = \\{x=h\\}$ 处，采用外法线约定，$K^{-}$ 上 $n^{-}=+1$，$K^{+}$ 上 $n^{+}=-1$。对于任意标量迹 $w$，定义平均和跳跃为\n$$\n\\{w\\} = \\frac{w^{-} + w^{+}}{2}, \\qquad [w] = w^{-} - w^{+},\n$$\n其中上标 $(-)$ 和 $(+)$ 分别表示来自 $K^{-}$ 和 $K^{+}$ 的迹。\n\n通过分部积分在每个单元上建立 LDG 弱形式：\n- 将 $q = u_x$ 乘以测试函数 $r$，并在每个单元上进行分部积分，以获得边界项 $\\int_{\\partial K} \\hat{u}\\, r\\, n\\, ds$。\n- 将 $-q_x = f$ 乘以测试函数 $v$，并在每个单元上进行分部积分，以获得边界项 $-\\int_{\\partial K} \\hat{q}\\, n\\, v\\, ds$。\n\n在内表面 $F$ 上，为此一阶 LDG 系统采用对称内部罚 (symmetric LDG) 数值通量：\n$$\n\\hat{u} = \\{u\\}, \\qquad \\hat{q}\\,n = \\{q\\} - \\sigma\\,[u],\n$$\n其中 $\\sigma > 0$ 是一个对称的、与单元无关的罚参数。\n\n使用这些定义：\n1. 根据在 $\\xi=\\pm 1$ 处的基函数迹，显式地组装 $F$ 局部界面通量贡献矩阵，用于以下三个贡献：\n   - 来自 $\\int_{F} \\hat{u}\\,[r]\\,ds$ 的 $u$ 到 $r$ 的一致性块，\n   - 来自 $-\\int_{F} \\{q\\}\\,[v]\\,ds$ 的 $q$ 到 $v$ 的一致性块，\n   - 来自 $+\\int_{F} \\sigma\\,[u]\\,[v]\\,ds$ 的 $u$ 到 $v$ 的罚块。\n   在面上使用由 $u$ 系数向量 $\\big(u_0^{-},u_1^{-},u_0^{+},u_1^{+}\\big)$ 给出的自由度排序，对 $q$ 也类似，并对 $r$ 和 $v$ 的测试函数系数使用相应的排序。\n2. 关注 $u$ 到 $v$ 的罚块矩阵，记为 $P(\\sigma)$。通过量化其斜对称部分的弗罗贝尼乌斯范数来确认其在对称罚选择下的对称性，\n$$\nS(\\sigma) = \\frac{1}{2}\\left(P(\\sigma) - P(\\sigma)^{\\top}\\right), \\qquad \\|S(\\sigma)\\|_{F}.\n$$\n\n$\\|S(\\sigma)\\|_{F}$ 的值是多少？以单个精确数字给出最终答案。无需四舍五入，此量无单位。",
            "solution": "该问题要求计算在一维泊松方程的局部不连续伽辽金 (LDG) 公式中，由界面项产生的罚矩阵 $P(\\sigma)$ 的斜对称部分的弗罗贝尼乌斯范数。\n\n首先，我们建立计算所需的必要组件。在两个单元 $K^{-} = [0,h]$ 和 $K^{+} = [h,2h]$ 上，未知场 $u$ 和测试函数 $v$ 的近似是在一个 $p=1$ 次的多项式空间中完成的。参考单元 $\\hat{K} = [-1,1]$ 上的基函数为 $\\phi_0(\\xi) = \\frac{1}{\\sqrt{2}}$ 和 $\\phi_1(\\xi) = \\sqrt{\\frac{3}{2}}\\,\\xi$。\n\n场 $u$ 的自由度 (DoFs) 是每个单元上基展开的系数：$K^{-}$ 上为 $(u_0^{-}, u_1^{-})$，$K^{+}$ 上为 $(u_0^{+}, u_1^{+})$。在双单元片区上 $u$ 的完整系数向量是 $\\mathbf{U} = (u_0^{-}, u_1^{-}, u_0^{+}, u_1^{+})^{\\top}$。类似地，对于测试函数 $v$，系数向量是 $\\mathbf{V} = (v_0^{-}, v_1^{-}, v_0^{+}, v_1^{+})^{\\top}$。\n\n每个物理单元上的函数 $u$ 和 $v$ 由下式给出：\n在 $K^{-}$ 上，其中 $x = \\frac{h}{2} + \\frac{h}{2}\\xi$：\n$u(x)|_{K^{-}} = u_h^{-}(\\xi) = u_0^{-} \\phi_0(\\xi) + u_1^{-} \\phi_1(\\xi)$\n$v(x)|_{K^{-}} = v_h^{-}(\\xi) = v_0^{-} \\phi_0(\\xi) + v_1^{-} \\phi_1(\\xi)$\n\n在 $K^{+}$ 上，其中 $x = \\frac{3h}{2} + \\frac{h}{2}\\xi$：\n$u(x)|_{K^{+}} = u_h^{+}(\\xi) = u_0^{+} \\phi_0(\\xi) + u_1^{+} \\phi_1(\\xi)$\n$v(x)|_{K^{+}} = v_h^{+}(\\xi) = v_0^{+} \\phi_0(\\xi) + v_1^{+} \\phi_1(\\xi)$\n\n问题指明，罚项对弱形式的贡献是 $I_p = \\int_{F} \\sigma\\,[u]\\,[v]\\,ds$。界面 $F$ 是点 $\\{x=h\\}$。对于一维问题，此积分简化为在该点处被积函数的值，因此 $I_p = \\sigma [u][v] |_{x=h}$。\n\n跳跃算子定义为 $[w] = w^{-} - w^{+}$，其中 $w^{-}$ 是来自 $K^{-}$ 的迹，$w^{+}$ 是来自 $K^{+}$ 的迹。界面 $x=h$ 对应于 $K^{-}$ 上的 $\\xi=1$ 和 $K^{+}$ 上的 $\\xi=-1$。\n首先，我们计算这些点上的基函数值：\n$\\phi_0(1) = \\frac{1}{\\sqrt{2}}$\n$\\phi_1(1) = \\sqrt{\\frac{3}{2}}$\n$\\phi_0(-1) = \\frac{1}{\\sqrt{2}}$\n$\\phi_1(-1) = -\\sqrt{\\frac{3}{2}}$\n\n$u$ 在 $x=h$ 处的迹为：\n$u^{-} = u_h^{-}(\\xi=1) = u_0^{-} \\phi_0(1) + u_1^{-} \\phi_1(1) = u_0^{-} \\frac{1}{\\sqrt{2}} + u_1^{-} \\sqrt{\\frac{3}{2}}$\n$u^{+} = u_h^{+}(\\xi=-1) = u_0^{+} \\phi_0(-1) + u_1^{+} \\phi_1(-1) = u_0^{+} \\frac{1}{\\sqrt{2}} - u_1^{+} \\sqrt{\\frac{3}{2}}$\n\n因此，跳跃 $[u]$ 为：\n$[u] = u^{-} - u^{+} = \\left(u_0^{-} \\frac{1}{\\sqrt{2}} + u_1^{-} \\sqrt{\\frac{3}{2}}\\right) - \\left(u_0^{+} \\frac{1}{\\sqrt{2}} - u_1^{+} \\sqrt{\\frac{3}{2}}\\right)$\n$[u] = u_0^{-} \\frac{1}{\\sqrt{2}} + u_1^{-} \\sqrt{\\frac{3}{2}} - u_0^{+} \\frac{1}{\\sqrt{2}} + u_1^{+} \\sqrt{\\frac{3}{2}}$\n\n这可以写成点积 $\\mathbf{b}^{\\top}\\mathbf{U}$，其中 $\\mathbf{U} = (u_0^{-}, u_1^{-}, u_0^{+}, u_1^{+})^{\\top}$，而 $\\mathbf{b}$ 是基函数迹值的向量：\n$\\mathbf{b} = \\begin{pmatrix} \\phi_0(1) \\\\ \\phi_1(1) \\\\ -\\phi_0(-1) \\\\ -\\phi_1(-1) \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{\\sqrt{2}} \\\\ \\sqrt{\\frac{3}{2}} \\\\ -\\frac{1}{\\sqrt{2}} \\\\ \\sqrt{\\frac{3}{2}} \\end{pmatrix}$\n\n所以，$[u] = \\mathbf{b}^{\\top}\\mathbf{U}$。类似地，对于测试函数 $v$，$[v] = \\mathbf{b}^{\\top}\\mathbf{V}$。\n\n现在可以用系数向量表示罚项 $I_p$：\n$I_p = \\sigma [u][v] = \\sigma (\\mathbf{b}^{\\top}\\mathbf{U}) (\\mathbf{b}^{\\top}\\mathbf{V})$\n由于这些项是标量，我们可以重新排列：\n$I_p = \\sigma (\\mathbf{V}^{\\top}\\mathbf{b}) (\\mathbf{b}^{\\top}\\mathbf{U}) = \\mathbf{V}^{\\top} (\\sigma\\,\\mathbf{b}\\mathbf{b}^{\\top}) \\mathbf{U}$\n\n这个双线性形式的矩阵，我们记为 $P(\\sigma)$，是中间的量：\n$P(\\sigma) = \\sigma\\,\\mathbf{b}\\mathbf{b}^{\\top}$\n\n这是向量 $\\mathbf{b}$ 与自身的向量外积，并由 $\\sigma$ 缩放。让我们显式计算这个 $4 \\times 4$ 矩阵：\n$P(\\sigma) = \\sigma \\begin{pmatrix} \\frac{1}{\\sqrt{2}} \\\\ \\sqrt{\\frac{3}{2}} \\\\ -\\frac{1}{\\sqrt{2}} \\\\ \\sqrt{\\frac{3}{2}} \\end{pmatrix} \\begin{pmatrix} \\frac{1}{\\sqrt{2}} & \\sqrt{\\frac{3}{2}} & -\\frac{1}{\\sqrt{2}} & \\sqrt{\\frac{3}{2}} \\end{pmatrix}$\n\n$P(\\sigma) = \\sigma \\begin{pmatrix}\n\\frac{1}{2} & \\frac{\\sqrt{3}}{2} & -\\frac{1}{2} & \\frac{\\sqrt{3}}{2} \\\\\n\\frac{\\sqrt{3}}{2} & \\frac{3}{2} & -\\frac{\\sqrt{3}}{2} & \\frac{3}{2} \\\\\n-\\frac{1}{2} & -\\frac{\\sqrt{3}}{2} & \\frac{1}{2} & -\\frac{\\sqrt{3}}{2} \\\\\n\\frac{\\sqrt{3}}{2} & \\frac{3}{2} & -\\frac{\\sqrt{3}}{2} & \\frac{3}{2}\n\\end{pmatrix}$\n\n问题要求我们量化该矩阵的对称性缺陷。如果 $A = A^{\\top}$，则矩阵 $A$ 是对称的。任何实数列向量 $\\mathbf{b}$ 与其转置的外积 $\\mathbf{b}\\mathbf{b}^{\\top}$ 总会得到一个对称矩阵。设 $A = \\mathbf{b}\\mathbf{b}^{\\top}$。那么元素 $A_{ij} = b_i b_j$。转置矩阵的元素是 $(A^{\\top})_{ij} = A_{ji} = b_j b_i$。由于标量乘法是可交换的，所以 $b_i b_j = b_j b_i$，因此 $A_{ij}=(A^{\\top})_{ij}$。所以，$A = A^{\\top}$。\n\n这意味着我们的矩阵 $P(\\sigma) = \\sigma \\mathbf{b}\\mathbf{b}^{\\top}$ 是对称的。我们也可以通过检查其显式矩阵形式看到这一点。\n\n$P(\\sigma)$ 的斜对称部分定义为 $S(\\sigma) = \\frac{1}{2}\\left(P(\\sigma) - P(\\sigma)^{\\top}\\right)$。\n由于 $P(\\sigma)$ 是对称的，所以 $P(\\sigma) = P(\\sigma)^{\\top}$。\n因此，\n$S(\\sigma) = \\frac{1}{2}\\left(P(\\sigma) - P(\\sigma)\\right) = \\frac{1}{2} \\mathbf{0} = \\mathbf{0}$\n其中 $\\mathbf{0}$ 是 $4 \\times 4$ 的零矩阵。\n\n最后一步是计算 $S(\\sigma)$ 的弗罗贝尼乌斯范数。矩阵 $A$ 的弗罗贝尼乌斯范数是 $\\|A\\|_{F} = \\sqrt{\\sum_{i,j} |A_{ij}|^2}$。\n对于零矩阵，其所有元素都为 0，所以总和为 0。\n$\\|S(\\sigma)\\|_{F} = \\|\\mathbf{0}\\|_{F} = \\sqrt{0^2 + 0^2 + \\dots + 0^2} = 0$。\n\n对称性缺陷的值，由罚矩阵斜对称部分的弗罗贝尼乌斯范数量化，恰好为 0。这证实了该特定罚项对公式的贡献是对称的。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "守恒性是数值通量的一个关键性质，它确保离散格式能正确地模拟物理守恒律。本练习通过一个精心设计的反例，展示了非守恒（即双值）的数值通量选择如何导致守恒量（总质量）的人为增减。这个计算将深刻揭示为何单值通量对于保证格式的物理真实性至关重要。",
            "id": "3405510",
            "problem": "考虑一维纯扩散方程 $u_{t} = \\kappa u_{xx}$，其定义域为 $[0,1]$，边界条件为齐次诺伊曼边界条件 $u_{x}(0,t) = 0$ 和 $u_{x}(1,t) = 0$。引入一阶系统 $q = u_{x}$ 和 $u_{t} = \\kappa q_{x}$。使用局部间断伽辽金(LDG)方法（Local Discontinuous Galerkin (LDG)）在由两个均匀单元 $K_{1} = [0,\\tfrac{1}{2}]$ 和 $K_{2} = [\\tfrac{1}{2},1]$ 组成的网格上离散化该系统，对 $u$ 和 $q$ 均使用分片常数试探函数和检验函数。将单元上的常数值表示为 $u$ 的 $u_{1}(t)$ 和 $u_{2}(t)$，以及 $q$ 的 $q_{1}(t)$ 和 $q_{2}(t)$。设每个单元端点的单位外法向量在左端点为 $n = -1$，在右端点为 $n = +1$。\n\n使用 $q - u_{x} = 0$ 和 $u_{t} - (\\kappa q)_{x} = 0$ 的LDG弱形式，并采用以下数值通量。在内部界面 $x = \\tfrac{1}{2}$ 处，选择一个非守恒的数值迹 $\\widehat{u}$，该迹是逐单元的（双值的）：对于 $K_{1}$ 的右侧面，设 $\\widehat{u} = u_{1}$；对于 $K_{2}$ 的左侧面，设 $\\widehat{u} = u_{2}$。在区域边界 $x = 0$ 和 $x = 1$ 处，设 $\\widehat{u} = 0$。通过在 $x = 0$ 和 $x = 1$ 处取 $\\widehat{\\kappa q} = 0$ 来施加守恒律的齐次诺伊曼边界条件。在内部界面 $x = \\tfrac{1}{2}$ 处，令扩散数值通量也为逐单元的（双值的）：对于 $K_{1}$ 的右侧面，设 $\\widehat{\\kappa q} = \\kappa q_{1}$；对于 $K_{2}$ 的左侧面，设 $\\widehat{\\kappa q} = \\kappa q_{2}$。\n\n从LDG弱形式表述和这些通量选择出发，推导 $q_{1}(t)$ 和 $q_{2}(t)$ 的半离散方程以及总质量 $\\int_{0}^{1} u(x,t)\\,dx$ 的全局变化率。对于具体数据 $\\kappa = 1$，$h = \\tfrac{1}{2}$，$u_{1}(0) = 1$ 和 $u_{2}(0) = 0$，计算在 $t = 0$ 时总质量的瞬时变化率 $\\dfrac{d}{dt}\\int_{0}^{1} u(x,t)\\,dx$。将最终答案表示为单个实数。无需四舍五入。",
            "solution": "我们从一阶系统在单元 $K_j$ 上的弱形式表述开始。\n令 $v$ 为 $u$ 方程的检验函数，$p$ 为 $q$ 方程的检验函数。由于试探函数和检验函数在每个单元上都是分片常数，因此对于 $x \\in K_j$，有 $u(x,t) = u_j(t)$、$q(x,t) = q_j(t)$、$v(x) = v_j$ 和 $p(x) = p_j$。\n\n**1. $q - u_x = 0$ 的弱形式：**\n乘以检验函数 $p$ 并在单元 $K_j$ 上积分：\n$$ \\int_{K_j} q p \\,dx - \\int_{K_j} u_x p \\,dx = 0 $$\n对第二项进行分部积分：\n$$ \\int_{K_j} q p \\,dx + \\int_{K_j} u p_x \\,dx - [u p]_{\\partial K_j} = 0 $$\n用数值通量替换边界值，得到：\n$$ \\int_{K_j} q p \\,dx + \\int_{K_j} u p_x \\,dx - [\\widehat{u} p n]_{\\partial K_j} = 0 $$\n由于 $p$ 在 $K_j$ 上是常数，其导数 $p_x = 0$。我们选择检验函数 $p$ 在 $K_j$ 上为 $1$，在其他地方为 $0$，因此 $p_j=1$。这可将方程简化为：\n$$ q_j \\int_{K_j} dx - [\\widehat{u} n]_{\\partial K_j} = 0 $$\n$$ h q_j - (\\widehat{u}(x_{j,R}) n(x_{j,R}) + \\widehat{u}(x_{j,L}) n(x_{j,L})) = 0 $$\n其中 $x_{j,L}$ 和 $x_{j,R}$ 是 $K_j$ 的左端点和右端点。\n\n对于单元 $K_1 = [0, \\tfrac{1}{2}]$，有 $h=\\tfrac{1}{2}$，$x_{1,L}=0$，$x_{1,R}=\\tfrac{1}{2}$，$n(0)=-1$，$n(\\tfrac{1}{2})=+1$：\n$$ \\tfrac{1}{2} q_1 - (\\widehat{u}(\\tfrac{1}{2}) \\cdot (+1) + \\widehat{u}(0) \\cdot (-1)) = 0 $$\n使用给定的通量，$\\widehat{u}(\\tfrac{1}{2}) = u_1$（$K_1$ 的右侧面）和 $\\widehat{u}(0)=0$：\n$$ \\tfrac{1}{2} q_1 - (u_1 \\cdot 1 + 0 \\cdot (-1)) = 0 \\implies \\tfrac{1}{2} q_1 = u_1 \\implies q_1(t) = 2 u_1(t) $$\n\n对于单元 $K_2 = [\\tfrac{1}{2}, 1]$，有 $h=\\tfrac{1}{2}$，$x_{2,L}=\\tfrac{1}{2}$，$x_{2,R}=1$，$n(\\tfrac{1}{2})=-1$，$n(1)=+1$：\n$$ \\tfrac{1}{2} q_2 - (\\widehat{u}(1) \\cdot (+1) + \\widehat{u}(\\tfrac{1}{2}) \\cdot (-1)) = 0 $$\n使用给定的通量，$\\widehat{u}(1) = 0$ 和 $\\widehat{u}(\\tfrac{1}{2}) = u_2$（$K_2$ 的左侧面）：\n$$ \\tfrac{1}{2} q_2 - (0 \\cdot 1 + u_2 \\cdot (-1)) = 0 \\implies \\tfrac{1}{2} q_2 = -u_2 \\implies q_2(t) = -2 u_2(t) $$\n因此，$q_1(t)$ 和 $q_2(t)$ 的半离散方程是代数关系：\n$$ q_1(t) = \\frac{u_1(t)}{h}, \\quad q_2(t) = -\\frac{u_2(t)}{h} $$\n\n**2. $u_t - \\kappa q_x = 0$ 的弱形式：**\n乘以检验函数 $v$ 并在 $K_j$ 上积分：\n$$ \\int_{K_j} u_t v \\,dx - \\int_{K_j} (\\kappa q)_x v \\,dx = 0 $$\n对第二项进行分部积分并引入数值通量 $\\widehat{\\kappa q}$：\n$$ \\int_{K_j} u_t v \\,dx + \\int_{K_j} \\kappa q v_x \\,dx - [\\widehat{\\kappa q} v n]_{\\partial K_j} = 0 $$\n对于分片常数 $v$，$v_x=0$。选择 $v=1$ 在 $K_j$ 上，在其他地方为 0：\n$$ \\frac{du_j}{dt} \\int_{K_j} dx - [\\widehat{\\kappa q} n]_{\\partial K_j} = 0 $$\n$$ h \\frac{du_j}{dt} - (\\widehat{\\kappa q}(x_{j,R}) n(x_{j,R}) + \\widehat{\\kappa q}(x_{j,L}) n(x_{j,L})) = 0 $$\n\n对于单元 $K_1 = [0, \\tfrac{1}{2}]$：\n$$ \\tfrac{1}{2} \\frac{du_1}{dt} - (\\widehat{\\kappa q}(\\tfrac{1}{2}) \\cdot (+1) + \\widehat{\\kappa q}(0) \\cdot (-1)) = 0 $$\n使用通量 $\\widehat{\\kappa q}(\\tfrac{1}{2}) = \\kappa q_1$ 和 $\\widehat{\\kappa q}(0) = 0$：\n$$ \\tfrac{1}{2} \\frac{du_1}{dt} - (\\kappa q_1 \\cdot 1 + 0 \\cdot (-1)) = 0 \\implies \\frac{du_1}{dt} = 2 \\kappa q_1 = \\frac{\\kappa}{h} q_1 $$\n\n对于单元 $K_2 = [\\tfrac{1}{2}, 1]$：\n$$ \\tfrac{1}{2} \\frac{du_2}{dt} - (\\widehat{\\kappa q}(1) \\cdot (+1) + \\widehat{\\kappa q}(\\tfrac{1}{2}) \\cdot (-1)) = 0 $$\n使用通量 $\\widehat{\\kappa q}(1) = 0$ 和 $\\widehat{\\kappa q}(\\tfrac{1}{2}) = \\kappa q_2$：\n$$ \\tfrac{1}{2} \\frac{du_2}{dt} - (0 \\cdot 1 + \\kappa q_2 \\cdot (-1)) = 0 \\implies \\frac{du_2}{dt} = -2 \\kappa q_2 = -\\frac{\\kappa}{h} q_2 $$\n\n### 总质量全局变化率的推导\n\n总质量由 $M(t) = \\int_0^1 u(x,t) \\,dx$ 给出。对于分片常数近似，这变为：\n$$ M(t) = \\int_0^{1/2} u_1(t) \\,dx + \\int_{1/2}^1 u_2(t) \\,dx = u_1(t) h + u_2(t) h = h(u_1(t)+u_2(t)) $$\n总质量的变化率是：\n$$ \\frac{dM}{dt} = h \\left( \\frac{du_1}{dt} + \\frac{du_2}{dt} \\right) $$\n代入推导出的 $u_1$ 和 $u_2$ 的常微分方程：\n$$ \\frac{dM}{dt} = h \\left( \\frac{\\kappa q_1}{h} - \\frac{\\kappa q_2}{h} \\right) = \\kappa (q_1(t) - q_2(t)) $$\n这是总质量变化率的一般表达式。这证实了在该格式中质量是不守恒的，除非 $q_1=q_2$，这是对 $\\widehat{\\kappa q}$ 采用非守恒数值通量选择的直接结果。\n\n### 计算 $t=0$ 时的瞬时变化率\n\n我们需要计算 $\\frac{dM}{dt}$ 在 $t=0$ 时的值，即 $\\kappa(q_1(0) - q_2(0))$。\n给定的参数和初始条件如下：\n- $\\kappa = 1$\n- $h = \\tfrac{1}{2}$\n- $u_1(0) = 1$\n- $u_2(0) = 0$\n\n首先，我们使用前面推导的半离散关系计算 $q_1$ 和 $q_2$ 的初始值：\n$$ q_1(0) = \\frac{u_1(0)}{h} = \\frac{1}{1/2} = 2 $$\n$$ q_2(0) = -\\frac{u_2(0)}{h} = -\\frac{0}{1/2} = 0 $$\n现在，我们可以计算 $t=0$ 时总质量的瞬时变化率：\n$$ \\left. \\frac{dM}{dt} \\right|_{t=0} = \\kappa (q_1(0) - q_2(0)) = 1 \\cdot (2 - 0) = 2 $$\n$t=0$ 时总质量的瞬时变化率为 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "间断Galerkin方法的一个核心优势在于，当使用守恒通量时，所有内部界面上的通量贡献在全局求和中会精确抵消，如同伸缩求和。本练习要求你编写一个简短的程序，在二维网格上数值验证这一基本性质。这个实践将从代码层面展示局部通量的定义如何确保全局守恒性，将理论与计算实现联系起来。",
            "id": "3405476",
            "problem": "考虑一个二维片状域 $\\Omega = [0,1] \\times [0,1]$，该域被划分为一个包含 $N_x \\times N_y$ 个矩形单元的均匀笛卡尔网格。令 $u : \\Omega \\to \\mathbb{R}$ 是一个光滑函数，并通过引入辅助通量场 $q = \\nabla u$ 和散度方程 $- \\nabla \\cdot q = f$ 来定义泊松问题的一阶局部间断伽辽金 (LDG) 系统。在间断伽辽金 (DG) 离散化中，单元间的耦合仅通过使用在每个网格面上为单值的数值通量进行的面积分来实现。\n\n您将需要在单元面贡献的代数层面上进行数值验证，证明当对散度块使用LDG型守恒数值通量时，所有内部面通量贡献的总和在全局平衡中精确抵消，仅剩下边界面贡献。此验证必须使用场的间断近似来执行，以便在单元面上出现非零的数值跳跃。\n\n基本定义：\n- 对每个网格单元 $K$，通过对精确解 $u$ 和 $q=\\nabla u$ 进行单元平均，定义分片常数近似 $u_h|_K$ 和 $q_h|_K$：\n$$\nu_h|_K \\;=\\; \\frac{1}{|K|} \\int_K u(x,y)\\,dx\\,dy, \n\\qquad\nq_h|_K \\;=\\; \\frac{1}{|K|} \\int_K \\nabla u(x,y)\\,dx\\,dy.\n$$\n- 在任意由两个相邻单元共享的内部面 $F$ 上，指定一个固定的全局单位法向量 $\\mathbf{n}$，其方向从“负”侧指向“正”侧。将在负侧的迹记为 $u_h^- , q_h^-$，在正侧的迹记为 $u_h^+ , q_h^+$。令 $\\boldsymbol{\\beta} \\in \\mathbb{R}^2$ 为一个固定的通量偏置向量，$\\tau \\ge 0$ 为一个罚参数。将用于散度方程的LDG型数值通量定义为单值标量\n$$\n\\widehat{\\phi} \\;=\\; \\mathbf{n} \\cdot \\widehat{q} \n\\;=\\; \\mathbf{n} \\cdot q_h^{\\boldsymbol{\\beta}} \\;-\\; \\tau \\, \\big(u_h^+ - u_h^-\\big),\n\\quad\\text{其中}\\quad\nq_h^{\\boldsymbol{\\beta}} \\;=\\; \n\\begin{cases}\nq_h^- & \\text{若 } \\boldsymbol{\\beta} \\cdot \\mathbf{n} \\ge 0,\\\\\nq_h^+ & \\text{若 } \\boldsymbol{\\beta} \\cdot \\mathbf{n}  0.\n\\end{cases}\n$$\n- 在任意边界上的面 $F \\subset \\partial \\Omega$ 上，其外单位法向量 $\\mathbf{n}$ 指向唯一相邻单元的外部，使用由下式定义的齐次诺伊曼数值通量\n$$\n\\widehat{\\phi} \\;=\\; \\mathbf{n} \\cdot q_h^{-}.\n$$\n- 对每个单元 $K$，其数值净通量通过对定向面积分求和来定义\n$$\n\\Phi(K) \\;=\\; \\sum_{F \\subset \\partial K} \\int_F \\mathbf{n}_K \\cdot \\widehat{q} \\; ds,\n$$\n其中 $\\mathbf{n}_K$ 是从 $K$ 指向外部并限制在面 $F$ 上的单位法向量。每个面 $F$ 上的单值数值通量 $\\widehat{\\phi} = \\mathbf{n}\\cdot \\widehat{q}$ 是用固定的全局面方向 $\\mathbf{n}$ 定义的，并以相反的符号对两个相邻单元产生贡献：对负单元为 $+ \\widehat{\\phi}$，对正单元为 $- \\widehat{\\phi}$。\n\n验证任务：\n- 使用上述定义，通过计算证明单元净通量的全局总和等于边界面通量的总和，\n$$\n\\sum_{K} \\Phi(K) \\;=\\; \\sum_{F \\subset \\partial \\Omega} \\int_F \\widehat{\\phi}\\, ds,\n$$\n并因此证明内部面贡献的总和通过单值通量的构造在数值上抵消为零。\n\n实现要求：\n- 使用精确场 $u(x,y)$ 来定义 $u_h$ 和 $q_h$ 作为跨面不连续的单元平均场。在构造 $q_h$ 时使用 $q = \\nabla u$。\n- 在 $[0,1]^2$ 上用等间距的网格线构造一个包含 $N_x \\times N_y$ 个矩形的网格。每个面只表示一次，并具有固定的方向：对于内部面，垂直面的单位法向量 $\\mathbf{n}=(1,0)$ 从左指向右；对于边界面，垂直面在 $x=0$ 处使用外法向量 $\\mathbf{n} = (-1,0)$，在 $x=1$ 处使用 $\\mathbf{n} = (1,0)$。对于内部面，水平面的单位法向量 $\\mathbf{n}=(0,1)$ 从下指向上；对于边界面，水平面在 $y=0$ 处使用外法向量 $\\mathbf{n} = (0,-1)$，在 $y=1$ 处使用 $\\mathbf{n} = (0,1)$。\n- 对于分片常数近似，精确计算面积分；对于长度为 $\\ell(F)$ 且 $\\widehat{\\phi}$ 沿其为常数的面 $F$，取 $\\int_F \\widehat{\\phi}\\, ds = \\widehat{\\phi}\\,\\ell(F)$。\n- 对每个测试用例，计算绝对差异\n$$\nE \\;=\\; \\left| \\sum_{K} \\Phi(K) \\;-\\; \\sum_{F \\subset \\partial \\Omega} \\int_F \\widehat{\\phi}\\, ds \\right|.\n$$\n\n使用以下参数值测试套件以涵盖不同的行为：\n- 用例 A (理想情况，混合方向): $(N_x, N_y, \\tau, \\boldsymbol{\\beta}, u) = (2, 2, 1.7, (1.0, 0.3), u_1)$。\n- 用例 B (仅边界片块，无内部面): $(N_x, N_y, \\tau, \\boldsymbol{\\beta}, u) = (1, 1, 10.0, (-1.0, 0.0), u_2)$。\n- 用例 C (强罚，垂直面上交替选择通量): $(N_x, N_y, \\tau, \\boldsymbol{\\beta}, u) = (3, 1, 50.0, (-2.0, 1.0), u_3)$。\n- 用例 D ($q$ 的中心通量，零罚): $(N_x, N_y, \\tau, \\boldsymbol{\\beta}, u) = (2, 3, 0.0, (0.0, 0.0), u_4)$。\n\n使用以下光滑场及其梯度：\n- $u_1(x,y) = x^3 - y^2 + x y + 1$, $\\nabla u_1(x,y) = \\big(3x^2 + y,\\; -2y + x\\big)$。\n- $u_2(x,y) = x + 2 y + \\tfrac{1}{2}$, $\\nabla u_2(x,y) = \\big(1,\\; 2\\big)$。\n- $u_3(x,y) = x^2 y - y^3 + 2$, $\\nabla u_3(x,y) = \\big(2 x y,\\; x^2 - 3 y^2\\big)$。\n- $u_4(x,y) = x^4 - y^4 + x y$, $\\nabla u_4(x,y) = \\big(4 x^3 + y,\\; -4 y^3 + x\\big)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述四个用例的顺序给出数值结果，即 $[E_A, E_B, E_C, E_D]$，其中每个 $E_\\cdot$ 是编程语言原生表示的浮点数。",
            "solution": "目标是利用间断伽辽金(DG)方法的基本原理和用于散度方程的局部间断伽辽金(LDG)数值通量，来验证在所有单元的全局求和中，内部面的通量会相互抵消，只留下边界面贡献。此验证是通过对一个光滑函数 $u$ 及其梯度 $q=\\nabla u$ 进行不连续的单元平均近似来执行的，因此数值跳跃 $u_h^+ - u_h^-$ 可能不为零，且罚项是有效的。\n\n原理与定义：\n1. DG框架在每个面上用一个单值的数值通量取代精确的法向通量。对于一阶LDG公式的散度块，一个标准的选择是\n$$\n\\widehat{\\phi} \\;=\\; \\mathbf{n} \\cdot \\widehat{q} \\;=\\; \\mathbf{n} \\cdot q_h^{\\boldsymbol{\\beta}} - \\tau \\, \\big(u_h^+ - u_h^-\\big),\n$$\n其中 $q_h^{\\boldsymbol{\\beta}}$ 是基于偏置向量 $\\boldsymbol{\\beta}$ 从迹中选择的一个：\n$$\nq_h^{\\boldsymbol{\\beta}} \\;=\\; \n\\begin{cases}\nq_h^-  \\text{若 } \\boldsymbol{\\beta} \\cdot \\mathbf{n} \\ge 0,\\\\\nq_h^+  \\text{其他情况}.\n\\end{cases}\n$$\n当面方向 $\\mathbf{n}$ 固定时，这个 $\\widehat{\\phi}$ 在每个面上是单值的。这是一个基本的DG守恒要求，即相邻的两个单元必须使用相同通量值但符号相反。\n\n2. 单元级的数值净通量由定向面积分的和定义：\n$$\n\\Phi(K) \\;=\\; \\sum_{F \\subset \\partial K} \\int_F \\mathbf{n}_K \\cdot \\widehat{q} \\; ds.\n$$\n如果一个由两个相邻单元 $K^-$ 和 $K^+$ 共享的面 $F$ 使用了相同的单值数值通量 $\\widehat{\\phi}$，并且 $\\mathbf{n}$ 是从 $K^-$ 指向 $K^+$ 的固定面法向量，那么\n$$\n\\int_{F} \\mathbf{n}_{K^-}\\cdot \\widehat{q}\\, ds \\;=\\; \\int_F \\widehat{\\phi}\\, ds, \n\\qquad\n\\int_{F} \\mathbf{n}_{K^+}\\cdot \\widehat{q}\\, ds \\;=\\; \\int_F (-\\widehat{\\phi})\\, ds,\n$$\n因此，穿过该内部面的成对和为\n$$\n\\int_F \\widehat{\\phi}\\, ds \\;+\\; \\int_F (-\\widehat{\\phi})\\, ds \\;=\\; 0.\n$$\n因此，当对所有单元 $K$ 的 $\\Phi(K)$求和时，所有内部面的贡献都成对抵消，只剩下边界面贡献：\n$$\n\\sum_K \\Phi(K) \\;=\\; \\sum_{F \\subset \\partial \\Omega} \\int_F \\widehat{\\phi}\\, ds.\n$$\n这个守恒恒等式纯粹源于数值通量的单值性以及使用相反的外法向量，而无需援引除通量定义之外的任何特定偏微分方程。\n\n3. 为确保不连续性和非平凡的跳跃，我们不使用 $u$ 和 $q$ 在每个面上的精确迹。相反，我们将不连续近似 $u_h$ 和 $q_h$ 定义为单元平均值：\n$$\nu_h|_K \\;=\\; \\frac{1}{|K|} \\int_K u(x,y)\\,dx\\,dy,\\qquad\nq_h|_K \\;=\\; \\frac{1}{|K|} \\int_K \\nabla u(x,y)\\,dx\\,dy,\n$$\n这样，即使精确解 $u$ 是光滑的，跨越两个相邻单元的值 $u_h^-, u_h^+$ 和 $q_h^-, q_h^+$ 通常也不同。这会产生非零的跳跃 $u_h^+ - u_h^-$，并激活数值通量中的罚项 $\\tau \\big(u_h^+ - u_h^-\\big)$。\n\n算法设计：\n- 网格构建：将 $[0,1]^2$ 划分为 $N_x \\times N_y$ 个具有均匀间距 $\\Delta x = 1/N_x, \\Delta y = 1/N_y$ 的矩形。枚举单元并构建一个具有固定全局方向的面列表。对于内部垂直面，取 $\\mathbf{n}=(1,0)$；对于内部水平面，取 $\\mathbf{n}=(0,1)$。对于边界面，使用外法向量：在 $x=0$ 处为 $\\mathbf{n} = (-1,0)$，在 $x=1$ 处为 $\\mathbf{n}=(1,0)$，在 $y=0$ 处为 $\\mathbf{n}=(0,-1)$，在 $y=1$ 处为 $\\mathbf{n}=(0,1)$。\n\n- 单元平均值：对每个单元 $K=[x_i,x_{i+1}]\\times [y_j,y_{j+1}]$，通过映射到 $K$ 的 $[0,1]^2$ 上的张量积高斯-勒让德求积来计算 $u_h|_K$ 和 $q_h|_K$。鉴于测试函数 $u$ 的多项式性质，一个中等阶数的求积就足以达到舍入误差级别的精度。\n\n- 面积分：由于 $u_h$ 和 $q_h$ 是分片常数，数值通量 $\\widehat{\\phi}$ 在一个面上是常数。因此，$\\int_F \\widehat{\\phi}\\, ds = \\widehat{\\phi} \\, \\ell(F)$，其中 $\\ell(F)$ 是面长，对于垂直面为 $\\Delta y$，对于水平面为 $\\Delta x$。\n\n- 全局和的汇编：构建两个累加器：\n  - 单元净通量的全局和 $\\sum_K \\Phi(K)$，通过对每个内部面，将 $+\\widehat{\\phi}\\,\\ell(F)$ 加到负单元，将 $-\\widehat{\\phi}\\,\\ell(F)$ 加到正单元来计算；对于边界面（只有一个相邻单元），则加上 $+\\widehat{\\phi}\\,\\ell(F)$。对所有单元求和等同于对这些定向贡献求和。\n  - 仅边界面和 $\\sum_{F \\subset \\partial \\Omega} \\int_F \\widehat{\\phi}\\, ds$，通过直接对边界面上的 $\\widehat{\\phi}\\,\\ell(F)$ 求和来计算。\n\n- 差异度量：计算 $E = \\left| \\sum_{K} \\Phi(K) - \\sum_{F \\subset \\partial \\Omega} \\int_F \\widehat{\\phi}\\, ds \\right|$。对于正确实现的单值通量，内部面的贡献成对抵消，$E$ 的计算结果应为数值零，这与 $\\tau$、$\\boldsymbol{\\beta}$、网格分辨率 $(N_x,N_y)$ 以及用于定义单元平均值的光滑场 $u$ 的选择无关。\n\n测试套件和预期行为：\n- 用例 A: $(N_x,N_y,\\tau,\\boldsymbol{\\beta},u)=(2,2,1.7,(1.0,0.3),u_1)$。存在混合方向的面；由于 $u_h$ 不连续，应用非零罚项。\n- 用例 B: $(1,1,10.0,(-1.0,0.0),u_2)$。不存在内部面，因此两个和显然相等。\n- 用例 C: $(3,1,50.0,(-2.0,1.0),u_3)$。强罚和在垂直面上交替选择 $q_h^{\\boldsymbol{\\beta}}$；抵消仍然成立。\n- 用例 D: $(2,3,0.0,(0.0,0.0),u_4)$。零罚；通量简化为基于规则 $\\boldsymbol{\\beta}\\cdot \\mathbf{n} \\ge 0$ 对 $q_h$ 的偏置选择（平局时解释为“负侧”选择），守恒性仍然成立。\n\n程序精确地实现了这些定义，构建了具有固定方向的网格和面列表，用高斯求积计算了单元平均值，在每个面上构造了单值LDG通量，汇编了定向和，并报告了每个情况下的 $E$。根据单值通量的守恒性质，所有四个报告的差异 $E$ 都应在舍入误差水平，由于实现汇编中内部项的严格代数抵消，在精确算术下打印为 $0.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Define the test functions u and their gradients grad_u\ndef u1(x, y):\n    return x**3 - y**2 + x*y + 1.0\n\ndef grad_u1(x, y):\n    return np.array([3.0*x**2 + y, -2.0*y + x])\n\ndef u2(x, y):\n    return x + 2.0*y + 0.5\n\ndef grad_u2(x, y):\n    return np.array([1.0, 2.0])\n\ndef u3(x, y):\n    return x**2 * y - y**3 + 2.0\n\ndef grad_u3(x, y):\n    return np.array([2.0*x*y, x**2 - 3.0*y**2])\n\ndef u4(x, y):\n    return x**4 - y**4 + x*y\n\ndef grad_u4(x, y):\n    return np.array([4.0*x**3 + y, -4.0*y**3 + x])\n\nU_FUNCS = {\n    1: (u1, grad_u1),\n    2: (u2, grad_u2),\n    3: (u3, grad_u3),\n    4: (u4, grad_u4),\n}\n\ndef gauss_legendre_1d(n):\n    # Nodes and weights on [-1,1]\n    x, w = np.polynomial.legendre.leggauss(n)\n    # Map to [0,1]\n    nodes = 0.5*(x + 1.0)\n    weights = 0.5*w\n    return nodes, weights\n\ndef cell_average_u_and_q(u_fun, grad_u_fun, x0, x1, y0, y1, qorder=4):\n    # Tensor-product quadrature on the cell\n    xs, wx = gauss_legendre_1d(qorder)\n    ys, wy = gauss_legendre_1d(qorder)\n    dx = x1 - x0\n    dy = y1 - y0\n    # Map [0,1]x[0,1] to cell\n    u_acc = 0.0\n    q_acc = np.array([0.0, 0.0])\n    for i, xi in enumerate(xs):\n        x = x0 + dx*xi\n        for j, yj in enumerate(ys):\n            y = y0 + dy*yj\n            w = wx[i]*wy[j]*dx*dy\n            u_acc += w * u_fun(x, y)\n            q_acc += w * grad_u_fun(x, y)\n    area = dx*dy\n    u_bar = u_acc / area\n    q_bar = q_acc / area\n    return u_bar, q_bar\n\ndef build_mesh_faces(nx, ny):\n    \"\"\"\n    Build faces with fixed global orientation:\n    - Interior vertical faces: n=(1,0), minus=left cell, plus=right cell\n    - Boundary vertical faces: n=(-1,0) at x=0 (outward), n=(1,0) at x=1 (outward)\n    - Interior horizontal faces: n=(0,1), minus=bottom cell, plus=top cell\n    - Boundary horizontal faces: n=(0,-1) at y=0, n=(0,1) at y=1\n    Returns a list of faces, each as a dict with keys:\n    - 'minus': (i,j) index of minus element\n    - 'plus': (i,j) index of plus element or None for boundary\n    - 'n': np.array([nx, ny]) unit normal\n    - 'length': face length\n    - 'orientation': 'vertical' or 'horizontal'\n    - 'location': float coordinate of the face (for reference, not used)\n    - 'span_index': index of the strip along the span direction (for reference)\n    \"\"\"\n    faces = []\n    dx = 1.0 / nx\n    dy = 1.0 / ny\n    # Vertical faces\n    for i in range(nx+1):\n        x_face = i*dx\n        for j in range(ny):\n            if i == 0:\n                # Left boundary: outward normal (-1,0), only right neighbor exists\n                minus = (0, j)  # element adjacent with outward normal\n                faces.append({\n                    'minus': minus,\n                    'plus': None,\n                    'n': np.array([-1.0, 0.0]),\n                    'length': dy,\n                    'orientation': 'vertical',\n                    'location': x_face,\n                    'span_index': j\n                })\n            elif i == nx:\n                # Right boundary: outward normal (1,0), only left neighbor exists\n                minus = (nx-1, j)\n                faces.append({\n                    'minus': minus,\n                    'plus': None,\n                    'n': np.array([1.0, 0.0]),\n                    'length': dy,\n                    'orientation': 'vertical',\n                    'location': x_face,\n                    'span_index': j\n                })\n            else:\n                # Interior vertical face: normal (1,0), minus=left cell, plus=right cell\n                minus = (i-1, j)\n                plus = (i, j)\n                faces.append({\n                    'minus': minus,\n                    'plus': plus,\n                    'n': np.array([1.0, 0.0]),\n                    'length': dy,\n                    'orientation': 'vertical',\n                    'location': x_face,\n                    'span_index': j\n                })\n    # Horizontal faces\n    for j in range(ny+1):\n        y_face = j*dy\n        for i in range(nx):\n            if j == 0:\n                # Bottom boundary: outward normal (0,-1)\n                minus = (i, 0)\n                faces.append({\n                    'minus': minus,\n                    'plus': None,\n                    'n': np.array([0.0, -1.0]),\n                    'length': dx,\n                    'orientation': 'horizontal',\n                    'location': y_face,\n                    'span_index': i\n                })\n            elif j == ny:\n                # Top boundary: outward normal (0,1)\n                minus = (i, ny-1)\n                faces.append({\n                    'minus': minus,\n                    'plus': None,\n                    'n': np.array([0.0, 1.0]),\n                    'length': dx,\n                    'orientation': 'horizontal',\n                    'location': y_face,\n                    'span_index': i\n                })\n            else:\n                # Interior horizontal face: normal (0,1), minus=bottom, plus=top\n                minus = (i, j-1)\n                plus = (i, j)\n                faces.append({\n                    'minus': minus,\n                    'plus': plus,\n                    'n': np.array([0.0, 1.0]),\n                    'length': dx,\n                    'orientation': 'horizontal',\n                    'location': y_face,\n                    'span_index': i\n                })\n    return faces\n\ndef compute_cell_averages(nx, ny, u_fun, grad_u_fun, qorder=4):\n    dx = 1.0 / nx\n    dy = 1.0 / ny\n    u_bar = np.zeros((nx, ny))\n    q_bar = np.zeros((nx, ny, 2))\n    for i in range(nx):\n        x0 = i*dx\n        x1 = (i+1)*dx\n        for j in range(ny):\n            y0 = j*dy\n            y1 = (j+1)*dy\n            u_avg, q_avg = cell_average_u_and_q(u_fun, grad_u_fun, x0, x1, y0, y1, qorder=qorder)\n            u_bar[i, j] = u_avg\n            q_bar[i, j, :] = q_avg\n    return u_bar, q_bar\n\ndef ldg_flux_on_face(u_minus, q_minus, u_plus, q_plus, n_vec, tau, beta):\n    \"\"\"\n    Single-valued LDG-type numerical flux for divergence equation:\n    phi = n . q_beta - tau * (u_plus - u_minus)\n    with q_beta chosen based on beta . n = 0 ? minus : plus.\n    On boundary (u_plus,q_plus) can be None; we use Neumann: phi = n . q_minus.\n    \"\"\"\n    if u_plus is None or q_plus is None:\n        # Boundary Neumann flux\n        return float(np.dot(n_vec, q_minus))\n    # Determine side based on beta . n\n    if float(np.dot(beta, n_vec)) = 0.0:\n        q_beta = q_minus\n    else:\n        q_beta = q_plus\n    phi = float(np.dot(n_vec, q_beta)) - tau * (u_plus - u_minus)\n    return phi\n\ndef run_case(nx, ny, tau, beta_vec, u_id):\n    u_fun, grad_u_fun = U_FUNCS[u_id]\n    # Compute cell averages for u_h and q_h\n    u_bar, q_bar = compute_cell_averages(nx, ny, u_fun, grad_u_fun, qorder=5)\n    # Build faces\n    faces = build_mesh_faces(nx, ny)\n    # Accumulate sums\n    sum_elements = 0.0\n    sum_boundary = 0.0\n    for face in faces:\n        mi, mj = face['minus']\n        if face['plus'] is None:\n            # Boundary face\n            u_minus = u_bar[mi, mj]\n            q_minus = q_bar[mi, mj, :]\n            n_vec = face['n']\n            phi = ldg_flux_on_face(u_minus, q_minus, None, None, n_vec, tau, beta_vec)\n            contrib = phi * face['length']\n            # Contributes only once (outward normal of the sole adjacent element)\n            sum_elements += contrib\n            sum_boundary += contrib\n        else:\n            # Interior face: single-valued flux with fixed orientation\n            pi, pj = face['plus']\n            u_minus = u_bar[mi, mj]\n            q_minus = q_bar[mi, mj, :]\n            u_plus = u_bar[pi, pj]\n            q_plus = q_bar[pi, pj, :]\n            n_vec = face['n']\n            phi = ldg_flux_on_face(u_minus, q_minus, u_plus, q_plus, n_vec, tau, beta_vec)\n            contrib = phi * face['length']\n            # Add contributions to both elements with opposite signs in the global sum\n            sum_elements += contrib   # minus element outward normal matches n_vec\n            sum_elements += -contrib  # plus element outward normal is -n_vec\n            # Boundary sum does not include interior faces\n    # Discrepancy\n    E = abs(sum_elements - sum_boundary)\n    return E\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # (N_x, N_y, tau, (beta_x, beta_y), u_id)\n    test_cases = [\n        (2, 2, 1.7, (1.0, 0.3), 1),   # Case A\n        (1, 1, 10.0, (-1.0, 0.0), 2), # Case B\n        (3, 1, 50.0, (-2.0, 1.0), 3), # Case C\n        (2, 3, 0.0, (0.0, 0.0), 4),   # Case D\n    ]\n\n    results = []\n    for nx, ny, tau, beta, uid in test_cases:\n        beta_vec = np.array(beta, dtype=float)\n        E = run_case(nx, ny, tau, beta_vec, uid)\n        results.append(E)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}