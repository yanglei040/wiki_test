{
    "hands_on_practices": [
        {
            "introduction": "对称内罚伽辽金（SIPG）方法的核心是在单元交界面上引入积分项，包括罚项和一致性项。在实际计算中，这些积分通常通过数值求积来近似。为了保证离散格式的精度和稳定性，我们必须选择一个足够精确的求积法则，以避免引入混叠误差。本练习旨在引导你分析这些积分项中被积函数的多项式次数，从而确定保证精确积分所需的最小求积阶数，这是任何DG方法正确实施的基础。",
            "id": "3377370",
            "problem": "考虑一个多边形或多面体区域 $\\Omega \\subset \\mathbb{R}^{d}$，$d \\ge 1$，其上配有由仿射单元构成的保形、形状规则的网格 $\\mathcal{T}_{h}$。令 $\\mathcal{F}_{h}$ 表示 $(d-1)$ 维面元的集合。假设扩散系数 $\\alpha > 0$ 是各向同性的常数。令 $V_{h}$ 为 $\\mathcal{T}_{h}$ 上的间断 Galerkin 有限元空间，由总次数至多为 $p \\in \\mathbb{N}$ 的分片多项式构成。\n\n在由单元 $K^{+}$ 和 $K^{-}$ 共享的每个内部面元 $F \\in \\mathcal{F}_{h}$ 上，设单位法向量为 $\\boldsymbol{n}$（在 $F$ 上取为固定的，并从 $K^{+}$ 指向 $K^{-}$），则二阶椭圆问题的对称内部罚 (SIP) 间断 Galerkin 方法涉及以下面元积分：罚项 $\\int_{F} \\sigma\\,[u_{h}]\\,[v_{h}] \\,\\mathrm{d}s$ 和一致性项 $-\\int_{F} \\{\\alpha \\nabla u_{h}\\}\\cdot \\boldsymbol{n}\\,[v_{h}]\\,\\mathrm{d}s - \\int_{F} \\{\\alpha \\nabla v_{h}\\}\\cdot \\boldsymbol{n}\\,[u_{h}]\\,\\mathrm{d}s$，其中 $u_{h}, v_{h} \\in V_{h}$ 是试探函数和测试函数，$[\\,\\cdot\\,]$ 表示在 $F$ 上的跳跃，$\\{\\,\\cdot\\,\\}$ 表示在 $F$ 上的平均，$\\sigma > 0$ 是每个面元上的常数罚参数（可能依赖于 $p$ 和局部网格尺寸，但与面元坐标无关）。在边界面元上，类似项会相应简化，但你可以忽略特定于边界的修改，并专注于内部面元上出现的最坏情况下的多项式次数。\n\n假设每个面元积分都由 $F$ 上的一个求积法则计算，该法则对 $F$ 上所有总次数至多为 $q$ 的标量多项式都是精确的。网格是仿射的，因此单元和面元的雅可比矩阵以及面元法向量在每个 $F$ 上都是常数，所以不会增加被积函数的多项式次数。\n\n仅使用多项式次数、乘积次数、迹、面元上的跳跃和平均的基本定义，确定面元上所需的最小总次数精确度 $q$，以保证对于任何 $u_{h}, v_{h} \\in V_{h}$，罚项和一致性项在每个面元 $F \\in \\mathcal{F}_{h}$ 上都能被精确积分，从而消除这些面元贡献中的求积混叠。通过确定每个被积函数在 $F$ 上的最大多项式次数来证明你的选择是正确的。\n\n将你的最终答案表示为关于 $p$ 的精确符号表达式。",
            "solution": "该问题要求确定网格 $\\mathcal{T}_h$ 的一个面元 $F$ 上的求积法则所需的最小总次数精确度 $q$，以使得对称内部罚 (SIP) 间断 Galerkin (DG) 方法的面元积分能被精确计算。问题设定在区域 $\\Omega \\subset \\mathbb{R}^{d}$（$d \\ge 1$）上，具有常数扩散系数 $\\alpha > 0$。DG 有限元空间 $V_h$ 由总次数至多为 $p \\in \\mathbb{N}$ 的分片多项式构成。\n\n令 $u_h, v_h \\in V_h$ 为 DG 空间中的任意函数。我们必须分析内部面元 $F \\in \\mathcal{F}_h$ 上罚项和一致性项的被积函数的多项式次数。设 $F$ 是两个单元 $K^+$ 和 $K^-$ 之间的界面。令 $\\mathcal{P}_k(S)$ 表示区域 $S$ 上总次数至多为 $k$ 的多项式空间。\n\n根据空间 $V_h$ 的定义，$u_h$ 在 $K^+$ 和 $K^-$ 上的限制 $u_h|_{K^+}$ 和 $u_h|_{K^-}$ 是总次数至多为 $p$ 的多项式。网格 $\\mathcal{T}_h$ 由仿射单元构成，这意味着从参考单元到任意单元 $K \\in \\mathcal{T}_h$ 的映射是仿射的。一个关键的推论是，单元 $K$ 上总次数为 $p$ 的多项式在其平的 $(d-1)$ 维面元 $F$ 上的迹，是 $F$ 上总次数至多为 $p$ 的多项式。因此，$u_h$ 从相邻单元在 $F$ 上的迹，记作 $u_h^+ = u_h|_{K^+}|_F$ 和 $u_h^- = u_h|_{K^-}|_F$，都是 $\\mathcal{P}_p(F)$ 中的元素。\n\n首先，我们分析罚项：$\\int_{F} \\sigma\\,[u_{h}]\\,[v_{h}] \\,\\mathrm{d}s$。\n被积函数是 $\\sigma\\,[u_{h}]\\,[v_{h}]$。标量罚参数 $\\sigma$ 在面元 $F$ 上是给定的常数。标量函数 $w_h$ 在 $F$ 上的跳跃定义为 $[w_h] = w_h^+ - w_h^-$。\n由于 $u_h^+, u_h^- \\in \\mathcal{P}_p(F)$，它们的差 $[u_h] = u_h^+ - u_h^-$ 也是 $\\mathcal{P}_p(F)$ 中的一个多项式。类似地，对于 $v_h \\in V_h$，其跳跃 $[v_h]$ 也属于 $\\mathcal{P}_p(F)$。\n罚项的被积函数是 $[u_h] \\in \\mathcal{P}_p(F)$ 和 $[v_h] \\in \\mathcal{P}_p(F)$ 的乘积。两个总次数至多为 $p$ 的多项式的乘积是一个总次数至多为 $p+p=2p$ 的多项式。因此，被积函数 $\\sigma\\,[u_{h}]\\,[v_{h}]$ 是 $F$ 上总次数至多为 $2p$ 的多项式。这个最大次数是可以达到的，例如，通过选择 $u_h$ 和 $v_h$，使其在 $F$ 上的迹是次数为 $p$ 的非零多项式。\n\n接下来，我们分析一致性项：$-\\int_{F} \\{\\alpha \\nabla u_{h}\\}\\cdot \\boldsymbol{n}\\,[v_{h}]\\,\\mathrm{d}s - \\int_{F} \\{\\alpha \\nabla v_{h}\\}\\cdot \\boldsymbol{n}\\,[u_{h}]\\,\\mathrm{d}s$。\n由于对称性，只需分析其中一项的被积函数即可，例如 $\\{\\alpha \\nabla u_{h}\\}\\cdot \\boldsymbol{n}\\,[v_{h}]$。\n如前所述，$[v_h]$ 是 $\\mathcal{P}_p(F)$ 中的一个多项式。\n现在我们考察 $\\{\\alpha \\nabla u_{h}\\}\\cdot \\boldsymbol{n}$ 这一项。单元 $K$ 上的函数 $u_h$ 是 $\\mathcal{P}_p(K)$ 中的一个多项式。其梯度 $\\nabla u_h|_K$ 是一个向量，其分量是总次数至多为 $p-1$ 的多项式。\n该梯度向量在面元 $F$ 上的迹，例如 $(\\nabla u_h)^+ = (\\nabla u_h)|_{K^+}|_F$，是一个向量，其分量是 $\\mathcal{P}_{p-1}(F)$ 中的多项式。\n向量场 $\\alpha \\nabla u_h$ 的平均定义为 $\\{\\alpha \\nabla u_h\\} = \\frac{1}{2}(\\alpha (\\nabla u_h)^+ + \\alpha (\\nabla u_h)^-)$。由于 $\\alpha$ 是常数，向量 $\\{\\alpha \\nabla u_h\\}$ 的每个分量都是 $\\mathcal{P}_{p-1}(F)$ 中的多项式。\n问题陈述中提到网格是仿射的，这意味着单位法向量 $\\boldsymbol{n}$ 在每个面元 $F$ 上是常数。点积 $\\{\\alpha \\nabla u_h\\} \\cdot \\boldsymbol{n}$ 是 $\\{\\alpha \\nabla u_h\\}$ 各分量以 $\\boldsymbol{n}$ 的常数分量为系数的线性组合。此运算得到 $F$ 上一个总次数至多为 $p-1$ 的标量多项式。\n第一个一致性项的完整被积函数是 $\\{\\alpha \\nabla u_{h}\\}\\cdot \\boldsymbol{n} \\in \\mathcal{P}_{p-1}(F)$ 和 $[v_{h}] \\in \\mathcal{P}_p(F)$ 的乘积。一个次数至多为 $p-1$ 的多项式和一个次数至多为 $p$ 的多项式的乘积是一个次数至多为 $(p-1)+p = 2p-1$ 的多项式。\n因此，两个一致性项的被积函数都是 $F$ 上总次数至多为 $2p-1$ 的多项式。\n\n为确保数值积分是精确的，求积法则必须对所有遇到的被积函数中的最高次数的多项式都精确。\n罚项被积函数的最大次数为 $2p$。\n一致性项被积函数的最大次数为 $2p-1$。\n这两个次数的最大值为 $\\max(2p, 2p-1) = 2p$。\n因此，为保证对于任意选择的 $u_h, v_h \\in V_h$，所有面元贡献都能被精确积分， $F$ 上的求积法则必须对所有总次数至多为 $2p$ 的标量多项式都精确。\n因此，所需的最小总次数精确度是 $q = 2p$。",
            "answer": "$$\n\\boxed{2p}\n$$"
        },
        {
            "introduction": "不连续伽辽金方法的一大优势在于其能够自然地处理系数不连续的问题，例如在模拟复合材料或多相流时遇到的情况。本练习提供了一个具有分片常数、各向异性扩散张量的具体物理场景。你将应用一个为处理非连续系数而专门设计的数值通量公式，来计算跨越材料界面的通量值，从而亲身体验DG方法如何在这些挑战性问题中保持局部守恒性和稳定性。",
            "id": "3377389",
            "problem": "考虑二阶椭圆模型问题 $-\\nabla \\cdot (\\boldsymbol{\\kappa} \\nabla u) = f$，其定义域被划分为两个矩形 $K^{-} = (-1,0) \\times (0,1)$ 和 $K^{+} = (0,1) \\times (0,1)$，它们的公共界面为 $e = \\{0\\} \\times (0,1)$。系数张量是分片常数和各向异性的，在 $K^{-}$ 上为 $\\boldsymbol{\\kappa}^{-} = \\begin{pmatrix} 3  1 \\\\[4pt] 1  2 \\end{pmatrix}$，在 $K^{+}$ 上为 $\\boldsymbol{\\kappa}^{+} = \\begin{pmatrix} 2  0 \\\\[4pt] 0  5 \\end{pmatrix}$。设 $K^{-}$ 在 $e$ 上的单位外法向量为 $\\boldsymbol{n}_{e} = (1,0)^{\\top}$，因此 $K^{+}$ 在 $e$ 上的单位外法向量为 $-\\boldsymbol{n}_{e}$。\n\n一个分片仿射间断 Galerkin (DG) 近似解 $u_{h}$ 由下式给出：在 $K^{-}$ 上为 $u_{h}^{-}(x,y) = 1 + 2x + y$，在 $K^{+}$ 上为 $u_{h}^{+}(x,y) = -1 - x + y$。假设从 $K^{-}$ 到 $K^{+}$ 穿过 $e$ 的对称内部罚 Galerkin (SIPG) 界面法向数值通量采用一种 $\\boldsymbol{\\kappa}$ 加权形式，该形式能确保对不连续系数的正确处理和局部守恒。具体来说，定义法向扩散率 $\\kappa_{n}^{\\pm} = \\boldsymbol{n}_{e}^{\\top} \\boldsymbol{\\kappa}^{\\pm} \\boldsymbol{n}_{e}$、$\\boldsymbol{\\kappa}$ 加权平均系数 $\\omega^{-} = \\dfrac{\\kappa_{n}^{+}}{\\kappa_{n}^{-} + \\kappa_{n}^{+}}$ 和 $\\omega^{+} = \\dfrac{\\kappa_{n}^{-}}{\\kappa_{n}^{-} + \\kappa_{n}^{+}}$，以及调和罚函数缩放 $\\tau_{e} = \\dfrac{2 \\kappa_{n}^{-} \\kappa_{n}^{+}}{\\kappa_{n}^{-} + \\kappa_{n}^{+}}$ (假设面大小 $h_{e} = 1$ 且稳定化因子 $\\alpha = 1$)。那么，从 $K^{-}$ 指向 $K^{+}$ 穿过 $e$ 的法向数值通量为\n$$\n\\phi_{e}(u_{h}) \\;=\\; -\\left( \\omega^{-} \\,\\boldsymbol{\\kappa}^{-} \\nabla u_{h}^{-} + \\omega^{+} \\,\\boldsymbol{\\kappa}^{+} \\nabla u_{h}^{+} \\right) \\cdot \\boldsymbol{n}_{e} \\;+\\; \\tau_{e}\\,\\big(u_{h}^{-}|_{e} - u_{h}^{+}|_{e}\\big).\n$$\n此处 $u_{h}^{\\pm}|_{e}$ 是 $u_{h}^{\\pm}$ 在 $e$ 上的迹。\n\n计算 $\\phi_{e}(u_{h})$ 的精确值。最终答案必须是一个精确值（不要四舍五入）。",
            "solution": "该问题是有效的，因为它在科学上基于间断 Galerkin 方法的理论，是适定的，并且所有必要的数据和定义都是以客观且无矛盾的方式给出的。我们接下来计算法向数值通量 $\\phi_{e}(u_{h})$ 的值。\n\n从单元 $K^{-}$ 到 $K^{+}$ 穿过界面 $e$ 的数值通量由以下公式给出：\n$$\n\\phi_{e}(u_{h}) \\;=\\; -\\left( \\omega^{-} \\,\\boldsymbol{\\kappa}^{-} \\nabla u_{h}^{-} + \\omega^{+} \\,\\boldsymbol{\\kappa}^{+} \\nabla u_{h}^{+} \\right) \\cdot \\boldsymbol{n}_{e} \\;+\\; \\tau_{e}\\,\\big(u_{h}^{-}|_{e} - u_{h}^{+}|_{e}\\big)\n$$\n我们将一步一步地计算这个公式的每个组成部分。\n\n$1$. **分片仿射近似 $u_{h}$ 的梯度**：\nDG 近似解 $u_h$ 由 $u_{h}^{-}(x,y) = 1 + 2x + y$（在 $K^{-}$ 上）和 $u_{h}^{+}(x,y) = -1 - x + y$（在 $K^{+}$ 上）给出。在每个单元内，梯度是常数向量：\n$$\n\\nabla u_{h}^{-} = \\begin{pmatrix} \\frac{\\partial}{\\partial x}(1 + 2x + y) \\\\ \\frac{\\partial}{\\partial y}(1 + 2x + y) \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}\n$$\n$$\n\\nabla u_{h}^{+} = \\begin{pmatrix} \\frac{\\partial}{\\partial x}(-1 - x + y) \\\\ \\frac{\\partial}{\\partial y}(-1 - x + y) \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix}\n$$\n\n$2$. **$u_{h}$ 在界面 $e$ 上的迹和跳跃**：\n界面 $e$ 是由 $\\{ (x,y) \\mid x=0, y \\in (0,1) \\}$ 定义的线段。我们通过令 $x=0$ 来计算 $u_h^{-}$ 和 $u_h^{+}$ 在 $e$ 上的迹：\n$$\nu_{h}^{-}|_{e} = u_{h}^{-}(0,y) = 1 + 2(0) + y = 1 + y\n$$\n$$\nu_{h}^{+}|_{e} = u_{h}^{+}(0,y) = -1 - (0) + y = -1 + y\n$$\n$u_h$ 穿过 $e$ 的跳跃是从 $K^{-}$ 的迹与从 $K^{+}$ 的迹之差：\n$$\nu_{h}^{-}|_{e} - u_{h}^{+}|_{e} = (1+y) - (-1+y) = 1 + y + 1 - y = 2\n$$\n在整个界面 $e$ 上，跳跃是一个常数值 $2$。\n\n$3$. **法向扩散率 $\\kappa_{n}^{\\pm}$**：\n$K^{-}$ 在 $e$ 上的单位外法向量为 $\\boldsymbol{n}_{e} = (1,0)^{\\top}$。系数张量为 $\\boldsymbol{\\kappa}^{-} = \\begin{pmatrix} 3  1 \\\\ 1  2 \\end{pmatrix}$ 和 $\\boldsymbol{\\kappa}^{+} = \\begin{pmatrix} 2  0 \\\\ 0  5 \\end{pmatrix}$。\n法向扩散率计算如下 $\\kappa_{n}^{\\pm} = \\boldsymbol{n}_{e}^{\\top} \\boldsymbol{\\kappa}^{\\pm} \\boldsymbol{n}_{e}$：\n$$\n\\kappa_{n}^{-} = \\begin{pmatrix} 1  0 \\end{pmatrix} \\begin{pmatrix} 3  1 \\\\ 1  2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\end{pmatrix} \\begin{pmatrix} 3 \\\\ 1 \\end{pmatrix} = 3\n$$\n$$\n\\kappa_{n}^{+} = \\begin{pmatrix} 1  0 \\end{pmatrix} \\begin{pmatrix} 2  0 \\\\ 0  5 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 0 \\end{pmatrix} = 2\n$$\n\n$4$. **平均系数 $\\omega^{\\pm}$**：\n$\\boldsymbol{\\kappa}$ 加权平均系数定义为 $\\omega^{-} = \\frac{\\kappa_{n}^{+}}{\\kappa_{n}^{-} + \\kappa_{n}^{+}}$ 和 $\\omega^{+} = \\frac{\\kappa_{n}^{-}}{\\kappa_{n}^{-} + \\kappa_{n}^{+}}$。\n$$\n\\kappa_{n}^{-} + \\kappa_{n}^{+} = 3 + 2 = 5\n$$\n$$\n\\omega^{-} = \\frac{2}{5}\n$$\n$$\n\\omega^{+} = \\frac{3}{5}\n$$\n\n$5$. **罚函数缩放 $\\tau_{e}$**：\n调和罚函数缩放由 $\\tau_{e} = \\frac{2 \\kappa_{n}^{-} \\kappa_{n}^{+}}{\\kappa_{n}^{-} + \\kappa_{n}^{+}}$ 给出。\n$$\n\\tau_{e} = \\frac{2 \\cdot 3 \\cdot 2}{3+2} = \\frac{12}{5}\n$$\n\n$6$. **数值通量 $\\phi_{e}(u_{h})$ 的计算**：\n现在我们将所有计算出的量代入 $\\phi_{e}(u_{h})$ 的公式中。我们可以分别计算两个主要项。\n\n首先，加权平均通量项：\n$$\n-\\left( \\omega^{-} \\,\\boldsymbol{\\kappa}^{-} \\nabla u_{h}^{-} + \\omega^{+} \\,\\boldsymbol{\\kappa}^{+} \\nabla u_{h}^{+} \\right) \\cdot \\boldsymbol{n}_{e}\n$$\n我们来计算括号内的向量：\n$$\n\\omega^{-} \\,\\boldsymbol{\\kappa}^{-} \\nabla u_{h}^{-} + \\omega^{+} \\,\\boldsymbol{\\kappa}^{+} \\nabla u_{h}^{+} = \\frac{2}{5} \\begin{pmatrix} 3  1 \\\\ 1  2 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} + \\frac{3}{5} \\begin{pmatrix} 2  0 \\\\ 0  5 \\end{pmatrix} \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix}\n$$\n$$\n= \\frac{2}{5} \\begin{pmatrix} 3(2) + 1(1) \\\\ 1(2) + 2(1) \\end{pmatrix} + \\frac{3}{5} \\begin{pmatrix} 2(-1) + 0(1) \\\\ 0(-1) + 5(1) \\end{pmatrix} = \\frac{2}{5} \\begin{pmatrix} 7 \\\\ 4 \\end{pmatrix} + \\frac{3}{5} \\begin{pmatrix} -2 \\\\ 5 \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} 14/5 \\\\ 8/5 \\end{pmatrix} + \\begin{pmatrix} -6/5 \\\\ 15/5 \\end{pmatrix} = \\begin{pmatrix} (14-6)/5 \\\\ (8+15)/5 \\end{pmatrix} = \\begin{pmatrix} 8/5 \\\\ 23/5 \\end{pmatrix}\n$$\n与 $\\boldsymbol{n}_{e} = (1,0)^{\\top}$ 做点积并取负号：\n$$\n-\\begin{pmatrix} 8/5 \\\\ 23/5 \\end{pmatrix} \\cdot \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = -\\frac{8}{5}\n$$\n\n其次，罚函数项：\n$$\n\\tau_{e}\\,\\big(u_{h}^{-}|_{e} - u_{h}^{+}|_{e}\\big) = \\frac{12}{5} \\cdot 2 = \\frac{24}{5}\n$$\n\n最后，我们将两项相加得到总的数值通量：\n$$\n\\phi_{e}(u_{h}) = -\\frac{8}{5} + \\frac{24}{5} = \\frac{16}{5}\n$$\n数值通量的值在整个界面 $e$ 上是恒定的。",
            "answer": "$$\\boxed{\\frac{16}{5}}$$"
        },
        {
            "introduction": "实际工程问题中的求解域常常包含凹角等几何奇异性，导致解的正则性降低，从而影响数值方法的收敛效率。对于这类奇异问题，标准的均匀网格加密策略往往是次优的。本练习是一个高级实践，要求你编写代码来评估DG方法在处理一个典型角点奇异问题时的性能，通过计算一个基于插值的DG能量范数误差，来对比均匀网格加密（$h$-refinement）、提升多项式阶数（$p$-refinement）以及使用分级网格的效果。这让你能够深入理解如何为奇异问题设计高效的自适应加密策略。",
            "id": "3377347",
            "problem": "考虑在一个内角等于 $3\\pi/2$ 的凹角楔形域上的、带有齐次狄利克雷边界条件的拉普拉斯方程：\n$$\n-\\Delta u = 0 \\quad \\text{in } \\Omega, \\qquad u=0 \\quad \\text{on } \\partial\\Omega,\n$$\n其中该域在极坐标中描述为\n$$\n\\Omega = \\{(r,\\theta) \\mid r \\in [r_{\\min},1],\\ \\theta \\in [0,3\\pi/2]\\}.\n$$\n为了避免数值积分中的退化，同时保留奇异结构，通过一个小的内半径 $r_{\\min}$ 将顶点 $r=0$ 排除在外；径向坐标取 $r_{\\min} = 10^{-8}$。此楔形域的一个已知奇异解为\n$$\nu(r,\\theta) = r^{2/3}\\sin\\left(\\tfrac{2}{3}\\theta\\right),\n$$\n该解在 $r=0$ 附近表现出正则性降低，并模拟了由凹角引起的典范奇异性。\n\n您将通过测量基于插值的 DG 能量半范数误差，来评估在存在这种奇异正则性时间断伽辽金（DG）方法的加密策略。此评估无需解全局线性系统：而是在每个单元上使用勒让德-高斯-洛巴托（LGL）点构建局部张量积多项式插值，并定义一个在对称内罚格式中标准的类能量量。具体来说，将域划分为极坐标变量下的张量积网格，径向有 $N_r$ 个单元，角向有 $N_\\theta$ 个单元，单元边界为\n$$\nr_0=r_{\\min}, r_1, \\dots, r_{N_r}=1,\\qquad \\theta_0=0, \\theta_1, \\dots, \\theta_{N_\\theta}=3\\pi/2.\n$$\n在每个单元 $K=[r_i,r_{i+1}]\\times[\\theta_j,\\theta_{j+1}]$ 上，通过在每个坐标方向上进行 $p$ 次的张量积 LGL 插值来定义局部插值 $u_h$。使用极坐标恒等式，\n$$\n|\\nabla e|^2 = \\left|\\frac{\\partial e}{\\partial r}\\right|^2 + \\frac{1}{r^2}\\left|\\frac{\\partial e}{\\partial \\theta}\\right|^2,\\qquad dA = r\\, dr\\, d\\theta,\n$$\n以及由单元贡献和内界面罚项组成的 DG 能量半范数，\n$$\n\\|e\\|_{DG}^2 = \\sum_{K} \\int_{K} \\left( \\left|\\frac{\\partial e}{\\partial r}\\right|^2 + \\frac{1}{r^2}\\left|\\frac{\\partial e}{\\partial \\theta}\\right|^2 \\right) r\\, dr\\, d\\theta \\;+\\; \\sum_{F\\in\\mathcal{F}_\\text{int}} \\frac{\\sigma}{h_F}\\int_{F} |[u_h]|^2\\, ds,\n$$\n对如上构造的插值误差 $e=u-u_h$ 计算 $\\|e\\|_{DG}$。此处 $[u_h]$ 表示插值在内界面上的跳跃项，$\\sigma$ 是一个正罚参数，$h_F$ 是一个依赖于界面的法向长度尺度。使用以下物理和数值上一致的选择：\n- 对于常数 $r=r^\\star$ 的内界面（相邻角向单元之间的交界），使用 $ds = r^\\star\\, d\\theta$，$h_F = r^\\star\\, \\Delta\\theta$，其中 $\\Delta\\theta$ 表示该界面上的局部角向单元尺寸。\n- 对于常数 $\\theta=\\theta^\\star$ 的内界面（相邻径向单元之间的交界），使用 $ds = dr$，$h_F = \\Delta r$，其中 $\\Delta r$ 表示该界面上的局部径向单元尺寸。\n取对称内罚参数 $\\sigma = 10$。所有角度量必须以弧度处理。\n\n在每个单元内，使用与插值节点相关的张量积 LGL 求积法计算能量项，并使用相应的一维 LGL 求积法沿界面计算每个界面罚项。插值的导数应通过使用 LGL 微分矩阵的谱配置法计算。单元能量计算所需 $u$ 的精确导数为\n$$\n\\frac{\\partial u}{\\partial r}(r,\\theta) = \\frac{2}{3} r^{-1/3}\\sin\\left(\\tfrac{2}{3}\\theta\\right),\\qquad\n\\frac{\\partial u}{\\partial \\theta}(r,\\theta) = \\frac{2}{3} r^{2/3}\\cos\\left(\\tfrac{2}{3}\\theta\\right).\n$$\n\n设计一个基准测试，利用基于插值的 DG 半范数误差 $\\|e\\|_{DG}$，比较在 $u(r,\\theta)$ 所隐含的奇异正则性约束下的 $h$-加密与 $p$-加密策略。通过在对数-对数尺度上使用有限差分斜率计算经验收敛率：\n- 对于 $h$-加密，将单元数量加倍，并报告斜率\n$$\n\\alpha_h = -\\frac{\\log\\left(E_{2}/E_{1}\\right)}{\\log\\left(H_{2}/H_{1}\\right)},\n$$\n其中 $E_k$ 是在加密级别 $k$ 测得的半范数误差，$H_k$ 是特征网格尺寸（当 $N_r$ 和 $N_\\theta$ 都加倍时，使用比率 $H_{2}/H_{1}=1/2$）。\n- 对于 $p$-加密，在固定网格上将 $p$ 从 $p_1$ 增加到 $p_2$，并报告斜率\n$$\n\\alpha_p = -\\frac{\\log\\left(E_{2}/E_{1}\\right)}{\\log\\left(p_{2}/p_{1}\\right)},\n$$\n并根据降低的正则性解释观察到的行为。\n\n使用以下测试套件以确保覆盖典型和边缘行为：\n- 测试 1（低多项式次数下的均匀 $h$-加密）：$p=1$，$(N_r,N_\\theta)\\in\\{(8,8),(16,16),(32,32)\\}$。报告在 $(16,16)$ 和 $(32,32)$ 之间计算的 $\\alpha_h$。\n- 测试 2（固定网格上的 $p$-加密）：$(N_r,N_\\theta)=(16,16)$，$p\\in\\{1,2,3,4\\}$。报告在 $p=3$ 和 $p=4$ 之间计算的 $\\alpha_p$。\n- 测试 3（较高多项式次数下的均匀 $h$-加密）：$p=3$，$(N_r,N_\\theta)\\in\\{(8,8),(16,16),(32,32)\\}$。报告在 $(16,16)$ 和 $(32,32)$ 之间计算的 $\\alpha_h$。\n- 测试 4（为减轻角点奇异性在径向进行分级 $h$-加密）：$p=1$，$(N_r,N_\\theta)\\in\\{(8,8),(16,16),(32,32)\\}$，径向边界为\n$$\nr_k = r_{\\min} + (1-r_{\\min})\\left(\\frac{k}{N_r}\\right)^{\\gamma},\\quad \\gamma=2,\\quad k=0,1,\\dots,N_r,\n$$\n且角向边界均匀。报告在 $(16,16)$ 和 $(32,32)$ 之间计算的 $\\alpha_h$。\n\n您的程序必须实现所述的基于插值的 DG 半范数误差计算，并为上述四个测试生成经验斜率。最终输出必须是单行，包含四个浮点数结果，形式为逗号分隔的列表并用方括号括起，角度以弧度为单位，不涉及物理单位。例如，输出格式必须为\n$$\n[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4].\n$$",
            "solution": "我们从二维楔形域上的拉普拉斯方程 $-\\Delta u=0$ 开始，该域具有一个凹角和齐次狄利克雷边界条件。典范奇异解\n$$\nu(r,\\theta)=r^{2/3}\\sin\\left(\\tfrac{2}{3}\\theta\\right)\n$$\n是通过在极坐标中对角度为 $3\\pi/2$ 的楔形域进行变量分离得到的，并且该解是调和的。其正则性有所降低：$u\\in H^{1+s}(\\Omega)$，其中 $s=2/3$，这反映了由角点引起的奇异性。这种降低的正则性限制了诸如间断伽辽金（DG）法等基于多项式逼近的方法所能达到的最优收敛率，特别是在均匀加密的情况下。\n\n为了在不组装全局 DG 系统的情况下评估加密策略，我们计算一个基于插值的 DG 能量半范数误差。对于一个由单元 $K=[r_i,r_{i+1}]\\times[\\theta_j,\\theta_{j+1}]$ 构成的网格，我们使用每个坐标方向上 $p$ 次的张量积勒让德-高斯-洛巴托（LGL）点构建一个局部插值 $u_h$。极坐标中的梯度满足\n$$\n|\\nabla e|^2 = \\left|\\frac{\\partial e}{\\partial r}\\right|^2 + \\frac{1}{r^2}\\left|\\frac{\\partial e}{\\partial \\theta}\\right|^2,\\quad dA=r\\,dr\\,d\\theta,\n$$\n所以单元能量贡献为\n$$\n\\int_{K} \\left( \\left|\\frac{\\partial e}{\\partial r}\\right|^2 + \\frac{1}{r^2}\\left|\\frac{\\partial e}{\\partial \\theta}\\right|^2 \\right) r\\, dr\\, d\\theta.\n$$\n我们用张量积 LGL 求积法在每个单元上使用与插值相同的节点来近似此积分。$u_h$ 的导数通过谱配置法计算：如果 $x\\in[-1,1]$ 表示一维参考坐标，LGL 节点为 $\\{x_\\ell\\}_{\\ell=0}^p$，重心权为 $\\{c_\\ell\\}_{\\ell=0}^p$，微分矩阵 $D\\in\\mathbb{R}^{(p+1)\\times(p+1)}$ 定义为\n$$\nD_{\\ell m} = \\begin{cases}\n\\dfrac{c_m}{c_\\ell}\\dfrac{1}{x_\\ell - x_m},  \\ell\\ne m,\\\\[6pt]\n-\\displaystyle\\sum_{m\\ne \\ell} D_{\\ell m},  \\ell=m,\n\\end{cases}\n$$\n那么，在张量网格上，相对于参考变量的微分是通过沿各轴的矩阵乘法完成的，而物理导数则通过仿射缩放恢复：\n$$\n\\frac{\\partial u_h}{\\partial r} = \\frac{2}{r_{i+1}-r_i}\\,\\frac{\\partial u_h}{\\partial \\xi},\\qquad\n\\frac{\\partial u_h}{\\partial \\theta} = \\frac{2}{\\theta_{j+1}-\\theta_j}\\,\\frac{\\partial u_h}{\\partial \\eta}.\n$$\n能量计算所需的精确导数为\n$$\n\\frac{\\partial u}{\\partial r}(r,\\theta) = \\frac{2}{3} r^{-1/3}\\sin\\left(\\tfrac{2}{3}\\theta\\right),\\qquad\n\\frac{\\partial u}{\\partial \\theta}(r,\\theta) = \\frac{2}{3} r^{2/3}\\cos\\left(\\tfrac{2}{3}\\theta\\right).\n$$\n\n在对称内罚间断伽辽金（SIPDG）框架中，能量半范数通过界面罚项进行增强，以控制内界面上的不连续性。设 $\\mathcal{F}_\\text{int}$ 表示内界面。对于常数 $r=r^\\star$ 的界面，它分隔两个角向相邻单元，弧长元为 $ds=r^\\star\\, d\\theta$，相关的法向（角向）界面尺寸为 $h_F=r^\\star\\, \\Delta\\theta$。对于常数 $\\theta=\\theta^\\star$ 的界面，它位于径向相邻单元之间，线元为 $ds=dr$，法向（径向）界面尺寸为 $h_F=\\Delta r$。罚项形式为\n$$\n\\sum_{F\\in\\mathcal{F}_\\text{int}} \\frac{\\sigma}{h_F}\\int_{F} |[u_h]|^2\\, ds,\n$$\n其中罚参数 $\\sigma=10$。基于插值的 $u_h$ 产生的跳跃项 $[u_h]$ 在每个界面上的 LGL 节点处很容易计算，界面积分通过一维 LGL 求积法近似。\n\n为了比较加密策略，我们在对数-对数尺度上通过有限差分斜率计算经验收敛率。对于 $h$-加密，当 $N_r$ 和 $N_\\theta$ 在不同级别之间都加倍时，特征网格尺寸减半，因此 $H_2/H_1=1/2$，观察到的收敛率为\n$$\n\\alpha_h = -\\frac{\\log\\left(E_{2}/E_{1}\\right)}{\\log\\left(1/2\\right)}.\n$$\n对于固定网格上的 $p$-加密，观察到的代数 $p$-收敛率为\n$$\n\\alpha_p = -\\frac{\\log\\left(E_{2}/E_{1}\\right)}{\\log\\left(p_2/p_1\\right)}.\n$$\n在奇异正则性 $u\\in H^{1+2/3}(\\Omega)$ 下，均匀 $h$-加密预计会受限于降低的光滑性，导致斜率受奇异性强度约束；同样，随着 $p$ 的增长，$p$-加密会饱和，因为解不是任意光滑的。在径向坐标上使用分级网格，将单元聚集在顶点附近，通过更有效地解析 $r^{2/3}$ 行为来减轻奇异性，这会提高观察到的 $h$-收敛率。\n\n程序中的算法步骤：\n- 对于给定的多项式次数 $p$，构造 LGL 节点、权重和微分矩阵。\n- 在 $(r,\\theta)$ 中构建张量积网格，可以是均匀的，也可以是径向分级的 $r_k = r_{\\min} + (1-r_{\\min})(k/N_r)^\\gamma$，其中 $\\gamma$ 为指定值。\n- 在每个单元上，将 LGL 节点映射到物理坐标，在张量网格上对 $u$ 进行插值，计算谱配置导数，并使用极坐标雅可比行列式 $r$ 累加单元能量积分。\n- 对于每个内界面，使用共享的 LGL 节点沿界面计算跳跃项 $[u_h]$，并使用指定的与界面相关的缩放因子累加罚分积分。\n- 将能量和罚分贡献相加以获得 $\\|e\\|_{DG}$。\n- 对于测试套件中的每个测试，计算指定加密级别的误差，形成经验斜率，并以要求的单行格式输出四个结果。\n\n这种基于原理的设计将数值评估直接与奇异解的结构和 DG 能量度量联系起来，从而能够在不构造和求解完整全局 DG 系统的情况下，对不同加密策略在正则性降低的情况下的性能进行严格比较。这些测试涵盖了低次和高次均匀加密、$p$-加密饱和行为以及凹角顶点附近的径向分级效应，所有计算均以弧度为单位，输出无单位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Constants\nR_MIN = 1e-8  # inner radius to avoid singular quadrature\nTHETA_MAX = 1.5 * np.pi  # 3π/2 radians\nSIGMA = 10.0  # SIPDG penalty parameter\n\ndef legendre_lobatto_nodes_weights(p):\n    \"\"\"\n    Compute Legendre-Gauss-Lobatto (LGL) nodes, weights, and derivative matrix for degree p.\n\n    Nodes include endpoints -1 and 1 and the roots of the derivative of Legendre polynomial P_p'(x).\n    Weights use the classical LGL formula.\n    Derivative matrix uses barycentric formula for Lagrange interpolants at LGL nodes.\n    \"\"\"\n    # Legendre polynomial of degree p in Legendre basis\n    Lp = np.polynomial.legendre.Legendre([0]*p + [1])\n    dLp = Lp.deriv()\n    # Convert derivative to power basis to compute roots\n    dLp_poly = dLp.convert(kind=np.polynomial.Polynomial)\n    roots = dLp_poly.roots()\n    # Filter real roots in (-1, 1)\n    roots_real = roots[np.isreal(roots)].real\n    roots_in = roots_real[(roots_real  -1.0)  (roots_real  1.0)]\n    # Sort nodes\n    x = np.concatenate(([-1.0], np.sort(roots_in), [1.0]))\n    n = p + 1\n    # Weights: w0 = wN = 2/(p(p+1)); interior wi = 2/(p(p+1)) / [P_p(x_i)]^2\n    w = np.empty(n)\n    if p == 0:\n        # Trivial case: single node at -1=1? For p=0, LGL isn't standard; handle p=1 in our usage.\n        w[0] = 2.0\n        return x, w, np.array([[0.0]])\n    const = 2.0 / (p * (p + 1))\n    # Evaluate Legendre polynomial at nodes\n    P_vals = Lp(x)\n    w[:] = const / (P_vals**2)\n    # Derivative matrix via barycentric weights\n    c = barycentric_weights(x)\n    D = derivative_matrix_barycentric(x, c)\n    return x, w, D\n\ndef barycentric_weights(x):\n    \"\"\"\n    Compute barycentric weights for given nodes x (general formula).\n    c_i = 1 / product_{j != i} (x_i - x_j)\n    \"\"\"\n    n = x.size\n    c = np.ones(n)\n    for i in range(n):\n        diff = x[i] - np.delete(x, i)\n        c[i] = 1.0 / np.prod(diff)\n    return c\n\ndef derivative_matrix_barycentric(x, c):\n    \"\"\"\n    Construct spectral collocation derivative matrix D for Lagrange interpolants at nodes x\n    using barycentric weights c. Formula:\n        D_{ij} = c_j / (c_i * (x_i - x_j)) for i != j\n        D_{ii} = -sum_{j != i} D_{ij}\n    \"\"\"\n    n = x.size\n    D = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                D[i, j] = c[j] / (c[i] * (x[i] - x[j]))\n    D[np.diag_indices(n)] = -np.sum(D, axis=1)\n    return D\n\n# Exact solution and derivatives\ndef u_exact(r, th):\n    return np.power(r, 2.0/3.0) * np.sin((2.0/3.0) * th)\n\ndef ur_exact(r, th):\n    return (2.0/3.0) * np.power(r, -1.0/3.0) * np.sin((2.0/3.0) * th)\n\ndef uth_exact(r, th):\n    return (2.0/3.0) * np.power(r, 2.0/3.0) * np.cos((2.0/3.0) * th)\n\ndef build_edges(N_r, N_th, graded=False, gamma=2.0):\n    \"\"\"\n    Build radial and angular edges.\n    Radial: either uniform in [R_MIN, 1] or graded by r_k = R_MIN + (1-R_MIN) (k/N_r)^gamma.\n    Angular: uniform in [0, THETA_MAX].\n    \"\"\"\n    if graded:\n        k = np.arange(N_r + 1, dtype=float)\n        r_edges = R_MIN + (1.0 - R_MIN) * (k / N_r) ** gamma\n    else:\n        r_edges = np.linspace(R_MIN, 1.0, N_r + 1)\n    th_edges = np.linspace(0.0, THETA_MAX, N_th + 1)\n    return r_edges, th_edges\n\ndef element_energy_and_store_U(r_l, r_u, th_l, th_u, xi, wi, eta, wj, Dxi, Deta):\n    \"\"\"\n    Compute energy contribution for one element, and store U for face penalty evaluation.\n    \"\"\"\n    n = xi.size\n    # Affine maps from reference [-1,1] to physical\n    # r(xi) = r_l + (xi+1)/2 * (r_u - r_l)\n    # theta(eta) = th_l + (eta+1)/2 * (th_u - th_l)\n    r = r_l + 0.5 * (xi[:, None] + 1.0) * (r_u - r_l)\n    th = th_l + 0.5 * (eta[None, :] + 1.0) * (th_u - th_l)\n    # Interpolant values at nodes\n    U = u_exact(r, th)\n    # Derivatives via spectral collocation\n    dU_dxi = Dxi @ U  # derivative along xi\n    dU_deta = U @ Deta.T  # derivative along eta\n    # Physical derivatives scaling\n    s_r = 2.0 / (r_u - r_l)\n    s_th = 2.0 / (th_u - th_l)\n    Ur_h = dU_dxi * s_r\n    Uth_h = dU_deta * s_th\n    # Exact derivatives\n    Ur_ex = ur_exact(r, th)\n    Uth_ex = uth_exact(r, th)\n    # Error derivatives\n    e_r = Ur_ex - Ur_h\n    e_th = Uth_ex - Uth_h\n    # Integrand: (e_r^2 + e_th^2 / r^2) * r\n    integrand = (e_r**2 + (e_th**2) / (r**2)) * r\n    # Tensor-product LGL quadrature\n    # Jacobian factor from affine map: J = (r_u - r_l)/2 * (th_u - th_l)/2\n    J = 0.25 * (r_u - r_l) * (th_u - th_l)\n    # sum_{i,j} integrand[i,j] * wi[i] * wj[j]\n    energy = J * np.sum((integrand * (wi[:, None] * wj[None, :])))\n    return energy, U\n\ndef wedge_dg_interpolation_error(N_r, N_th, p, graded=False, gamma=2.0):\n    \"\"\"\n    Compute the interpolation-based DG energy seminorm error for the wedge domain with\n    given mesh parameters and polynomial degree p.\n    \"\"\"\n    # LGL nodes, weights, derivative matrices\n    xi, wi, Dxi = legendre_lobatto_nodes_weights(p)\n    eta, wj, Deta = legendre_lobatto_nodes_weights(p)\n    n = p + 1\n\n    r_edges, th_edges = build_edges(N_r, N_th, graded=graded, gamma=gamma)\n    # Store U values for all elements for face penalties\n    U_elems = [[None for _ in range(N_th)] for __ in range(N_r)]\n    energy_sum = 0.0\n\n    # Element loop: compute energy and store U\n    for i in range(N_r):\n        r_l, r_u = r_edges[i], r_edges[i+1]\n        for j in range(N_th):\n            th_l, th_u = th_edges[j], th_edges[j+1]\n            energy, U = element_energy_and_store_U(r_l, r_u, th_l, th_u, xi, wi, eta, wj, Dxi, Deta)\n            energy_sum += energy\n            U_elems[i][j] = U\n\n    # Interior face penalties\n    penalty_sum = 0.0\n\n    # Faces at constant r (between radial neighbors): integrate along theta\n    for k in range(1, N_r):\n        r_face = r_edges[k]\n        for j in range(N_th):\n            # Left element (radial index k-1), right element (radial index k), both at angular index j\n            U_left = U_elems[k-1][j]\n            U_right = U_elems[k][j]\n            # Values along xi=+1 (left) and xi=-1 (right)\n            vals_left = U_left[n-1, :]    # xi = +1\n            vals_right = U_right[0, :]    # xi = -1\n            jump = vals_left - vals_right\n            dth = th_edges[j+1] - th_edges[j]\n            hF = r_face * dth\n            dsJac = r_face * 0.5 * dth  # ds = r_face dtheta; map from [-1,1] gives factor 0.5*dth\n            # 1D LGL quadrature along theta\n            penalty_sum += (SIGMA / hF) * dsJac * np.sum(jump**2 * wj)\n\n    # Faces at constant theta (between angular neighbors): integrate along r\n    for j in range(1, N_th):\n        th_face = th_edges[j]\n        for i in range(N_r):\n            U_lower = U_elems[i][j-1]\n            U_upper = U_elems[i][j]\n            # Values along eta=+1 (lower top edge) and eta=-1 (upper bottom edge)\n            vals_lower = U_lower[:, n-1]  # eta = +1\n            vals_upper = U_upper[:, 0]    # eta = -1\n            jump = vals_lower - vals_upper\n            dr = r_edges[i+1] - r_edges[i]\n            hF = dr\n            dsJac = 0.5 * dr  # ds = dr; map from [-1,1] gives factor 0.5*dr\n            penalty_sum += (SIGMA / hF) * dsJac * np.sum(jump**2 * wi)\n\n    error_sq = energy_sum + penalty_sum\n    error = np.sqrt(error_sq)\n    return error\n\ndef rate_h_refinement(errors):\n    \"\"\"\n    Compute h-refinement rate between last two levels when mesh size halves (H2/H1 = 1/2).\n    \"\"\"\n    e1, e2 = errors[-2], errors[-1]\n    # rate = -log(e2/e1) / log(1/2)\n    return -np.log(e2 / e1) / np.log(0.5)\n\ndef rate_p_refinement(errors, p_vals):\n    \"\"\"\n    Compute p-refinement algebraic rate between last two degrees: -log(e2/e1)/log(p2/p1).\n    \"\"\"\n    e1, e2 = errors[-2], errors[-1]\n    p1, p2 = p_vals[-2], p_vals[-1]\n    return -np.log(e2 / e1) / np.log(p2 / p1)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Test 1: h-refinement, p=1, uniform mesh\n    test1_levels = [(8, 8), (16, 16), (32, 32)]\n    errors1 = []\n    for Nr, Nt in test1_levels:\n        errors1.append(wedge_dg_interpolation_error(Nr, Nt, p=1, graded=False))\n    rate1 = rate_h_refinement(errors1)\n\n    # Test 2: p-refinement on fixed mesh Nr=Nt=16, p=1..4\n    p_vals2 = [1, 2, 3, 4]\n    errors2 = []\n    for p in p_vals2:\n        errors2.append(wedge_dg_interpolation_error(16, 16, p=p, graded=False))\n    rate2 = rate_p_refinement(errors2, p_vals2)\n\n    # Test 3: h-refinement, p=3, uniform mesh\n    test3_levels = [(8, 8), (16, 16), (32, 32)]\n    errors3 = []\n    for Nr, Nt in test3_levels:\n        errors3.append(wedge_dg_interpolation_error(Nr, Nt, p=3, graded=False))\n    rate3 = rate_h_refinement(errors3)\n\n    # Test 4: h-refinement, p=1, graded radial mesh gamma=2\n    test4_levels = [(8, 8), (16, 16), (32, 32)]\n    errors4 = []\n    for Nr, Nt in test4_levels:\n        errors4.append(wedge_dg_interpolation_error(Nr, Nt, p=1, graded=True, gamma=2.0))\n    rate4 = rate_h_refinement(errors4)\n\n    results = [rate1, rate2, rate3, rate4]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}