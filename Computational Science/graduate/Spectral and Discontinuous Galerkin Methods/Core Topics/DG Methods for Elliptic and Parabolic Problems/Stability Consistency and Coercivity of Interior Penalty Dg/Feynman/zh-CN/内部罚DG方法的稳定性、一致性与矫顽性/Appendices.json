{
    "hands_on_practices": [
        {
            "introduction": "要验证一个数值方法的有效性，一致性 (consistency) 和对称性 (symmetry) 是两个首要的基本属性。本练习将引导你通过一个一维模型问题，亲手推导对称内部罚分 (SIPG) 方法在边界上的具体形式，并验证其对称性和与原问题的相容性。这个看似基础的计算，实际上是理解罚项如何修正不连续解并“感知”边界条件的关键一步。",
            "id": "3420636",
            "problem": "考虑在一维开区间 $\\Omega = (0,L)$（其中 $L>0$）上的标量二阶椭圆模型问题，\n$$\n- u'' = f \\quad \\text{in } (0,L),\n$$\n其服从齐次狄利克雷边界条件 $u(0)=0$ 和 $u(L)=0$。令 $\\mathcal{T}_h$ 为 $(0,L)$ 的一个均匀剖分，将其分为 $M \\in \\mathbb{N}$ 个等长的子区间，长度为 $h = L/M$。令 $n$ 表示边界 $\\partial \\Omega = \\{0,L\\}$ 上的单位外法线，因此 $n(0)=-1$ 且 $n(L)=+1$。令 $u_h$ 和 $v_h$ 为 $\\mathcal{T}_h$ 上不连续多项式空间中的任意函数。\n\n对标量场 $w$ 和通量 $q$，采用标准的间断伽辽金 (DG) 跳跃和平均算子，定义如下。在分隔两个单元的内面（节点）上，定义跳跃\n$$\n\\llbracket w \\rrbracket := w^{-} n^{-} + w^{+} n^{+},\n$$\n和平均\n$$\n\\{\\!\\{q\\}\\!\\} := \\tfrac{1}{2}\\left(q^{-}+q^{+}\\right),\n$$\n其中 $n^{-}$ 和 $n^{+}$ 分别是左、右单元的单位外法线。在边界-面 $x \\in \\partial \\Omega$ 上，定义\n$$\n\\llbracket w \\rrbracket := w\\, n, \\qquad \\{\\!\\{q\\}\\!\\} := q,\n$$\n其中 $n$ 是 $x$ 处的单位外法线，$q$ 是唯一相邻单元的通量迹。\n\n对称内部罚伽辽金 (SIPG) 双线性形式 $a_h(u_h,v_h)$ 由单元梯度内积和使用上述跳跃和平均的面贡献项构成，并带有一个正的罚参数 $\\sigma>0$。仅使用这些定义以及在 $x=0$ 和 $x=L$ 处的单位外法线，显式计算在 $\\partial \\Omega$ 上对 $a_h(u_h,v_h)$ 的总边界贡献 $B(u_h,v_h)$，用迹 $u_h(0)$, $u_h'(0)$, $v_h(0)$, $v_h'(0)$, $u_h(L)$, $u_h'(L)$, $v_h(L)$, $v_h'(L)$，网格尺寸 $h$ 和罚参数 $\\sigma$ 来表示。\n\n然后，验证所推导的边界贡献的两个性质：\n(i) 对称性，即对于所有 $u_h$ 和 $v_h$，有 $B(u_h,v_h)=B(v_h,u_h)$，以及\n(ii) 与连续模型问题的相容性，即如果 $u \\in H^{2}(0,L)$ 满足在 $(0,L)$ 中 $-u''=f$ 以及 $u(0)=u(L)=0$，则当根据DG构造包含内部贡献项并使用您计算的边界贡献 $B(u,v_h)$ 时，完整的SIPG双线性形式简化为\n$$\na_h(u,v_h) = \\int_{0}^{L} f\\, v_h \\,\\mathrm{d}x\n$$\n对于所有的 $v_h$。\n\n您的最终答案必须是 $B(u_h,v_h)$ 的单一闭式解析表达式。",
            "solution": "该问题要求计算一维椭圆问题的对称内部罚伽辽金 (SIPG) 双线性形式的边界贡献，并随后验证其对称性和相容性。该问题陈述在间断伽辽金方法的既定背景下被验证为科学上合理、适定且为求解提供了充分的说明。\n\n对于问题 $-w''=f$，SIPG双线性形式 $a_h(w, z)$ 的一般形式是通过在每个单元 $K \\in \\mathcal{T}_h$ 上进行两次分部积分来构造的。对于不连续空间中的函数 $w, z$，这得到：\n$$\na_h(w, z) = \\sum_{K \\in \\mathcal{T}_h} \\int_K w' z' \\, \\mathrm{d}x - \\sum_{e \\in \\mathcal{F}_h} \\int_e \\left( \\{\\!\\{w'\\}\\!\\} \\llbracket z \\rrbracket + \\epsilon \\llbracket w \\rrbracket \\{\\!\\{z'\\}\\!\\} \\right) \\, \\mathrm{d}S + \\sum_{e \\in \\mathcal{F}_h} \\int_e \\frac{\\sigma_e}{h_e} \\llbracket w \\rrbracket \\llbracket z \\rrbracket \\, \\mathrm{d}S\n$$\n其中 $\\mathcal{F}_h$ 是所有面（在一维中是节点）的集合，$\\epsilon$ 是一个参数，对于对称方法 (SIPG) 其值为 $+1$，对于非对称方法 (NIPG) 为 $-1$，对于不完全方法 (IIPG) 为 $0$。对于SIPG，$\\epsilon=+1$。罚项包含一个参数 $\\sigma_e > 0$ 和单元尺寸 $h_e$。对于给定的均匀网格，我们令 $h_e=h$ 和 $\\sigma_e=\\sigma$。问题陈述中提到了‘罚参数 $\\sigma$’；为了量纲一致性，罚项必须具有 $\\frac{\\sigma}{h}$ 的形式，其中 $\\sigma$ 是一个无量纲的正参数。在面上的积分（在一维中是点）被解释为在这些点上的求值。\n\n因此，SIPG双线性形式为：\n$$\na_h(u_h,v_h) = \\sum_{K \\in \\mathcal{T}_h} \\int_K u_h' v_h' \\, \\mathrm{d}x - \\sum_{e \\in \\mathcal{F}_h} \\left( \\{\\!\\{u_h'\\}\\!\\} \\llbracket v_h \\rrbracket + \\llbracket u_h \\rrbracket \\{\\!\\{v_h'\\}\\!\\} \\right) + \\sum_{e \\in \\mathcal{F}_h} \\frac{\\sigma}{h} \\llbracket u_h \\rrbracket \\llbracket v_h \\rrbracket\n$$\n问题要求计算总的边界贡献 $B(u_h, v_h)$，它由在边界-面 $\\partial\\Omega = \\{0, L\\}$ 上求值的项组成。\n$$\nB(u_h, v_h) = \\left. \\left( - (\\{\\!\\{u_h'\\}\\!\\} \\llbracket v_h \\rrbracket + \\llbracket u_h \\rrbracket \\{\\!\\{v_h'\\}\\!\\}) + \\frac{\\sigma}{h} \\llbracket u_h \\rrbracket \\llbracket v_h \\rrbracket \\right) \\right|_{x=0} + \\left. \\left( - (\\{\\!\\{u_h'\\}\\!\\} \\llbracket v_h \\rrbracket + \\llbracket u_h \\rrbracket \\{\\!\\{v_h'\\}\\!\\}) + \\frac{\\sigma}{h} \\llbracket u_h \\rrbracket \\llbracket v_h \\rrbracket \\right) \\right|_{x=L}\n$$\n\n我们使用所提供的定义在每个边界点上计算跳跃和平均算子的值。迹 $u_h(0), u_h'(0)$ 等，被理解为从域内部取的极限，即 $u_h(0^+), u_h'(0^+)$ 等。\n\n在左边界 $x=0$ 处：\n单位外法线为 $n(0) = -1$。场 $u_h, u_h'$ 从域内部取值，即从单元 $(0, h)$ 中取值。\n使用边界定义 $\\llbracket w \\rrbracket := w n$ 和 $\\{\\!\\{q\\}\\!\\} := q$：\n$$\n\\llbracket u_h \\rrbracket(0) = u_h(0) n(0) = -u_h(0)\n$$\n$$\n\\llbracket v_h \\rrbracket(0) = v_h(0) n(0) = -v_h(0)\n$$\n$$\n\\{\\!\\{u_h'\\}\\!\\}(0) = u_h'(0)\n$$\n$$\n\\{\\!\\{v_h'\\}\\!\\}(0) = v_h'(0)\n$$\n$x=0$ 处的贡献是：\n$$\n- (\\{\\!\\{u_h'\\}\\!\\}(0) \\llbracket v_h \\rrbracket(0) + \\llbracket u_h \\rrbracket(0) \\{\\!\\{v_h'\\}\\!\\}(0)) + \\frac{\\sigma}{h} \\llbracket u_h \\rrbracket(0) \\llbracket v_h \\rrbracket(0)\n$$\n$$\n= - (u_h'(0)(-v_h(0)) + (-u_h(0))v_h'(0)) + \\frac{\\sigma}{h} (-u_h(0))(-v_h(0))\n$$\n$$\n= u_h'(0)v_h(0) + u_h(0)v_h'(0) + \\frac{\\sigma}{h} u_h(0)v_h(0)\n$$\n\n在右边界 $x=L$ 处：\n单位外法线为 $n(L) = +1$。场从单元 $(L-h, L)$ 中取值。\n$$\n\\llbracket u_h \\rrbracket(L) = u_h(L) n(L) = u_h(L)\n$$\n$$\n\\llbracket v_h \\rrbracket(L) = v_h(L) n(L) = v_h(L)\n$$\n$$\n\\{\\!\\{u_h'\\}\\!\\}(L) = u_h'(L)\n$$\n$$\n\\{\\!\\{v_h'\\}\\!\\}(L) = v_h'(L)\n$$\n$x=L$ 处的贡献是：\n$$\n- (\\{\\!\\{u_h'\\}\\!\\}(L) \\llbracket v_h \\rrbracket(L) + \\llbracket u_h \\rrbracket(L) \\{\\!\\{v_h'\\}\\!\\}(L)) + \\frac{\\sigma}{h} \\llbracket u_h \\rrbracket(L) \\llbracket v_h \\rrbracket(L)\n$$\n$$\n= - (u_h'(L)v_h(L) + u_h(L)v_h'(L)) + \\frac{\\sigma}{h} u_h(L)v_h(L)\n$$\n\n总边界贡献 $B(u_h, v_h)$ 是 $x=0$ 和 $x=L$ 处贡献的总和：\n$$\nB(u_h,v_h) = \\left( u_h'(0)v_h(0) + u_h(0)v_h'(0) + \\frac{\\sigma}{h} u_h(0)v_h(0) \\right) + \\left( - u_h'(L)v_h(L) - u_h(L)v_h'(L) + \\frac{\\sigma}{h} u_h(L)v_h(L) \\right)\n$$\n这个表达式可以重新整理为：\n$$\nB(u_h,v_h) = u_h'(0)v_h(0) + u_h(0)v_h'(0) - u_h'(L)v_h(L) - u_h(L)v_h'(L) + \\frac{\\sigma}{h} \\left( u_h(0)v_h(0) + u_h(L)v_h(L) \\right)\n$$\n这就是所要求的总边界贡献的表达式。\n\n接下来，我们验证所要求的两个性质。\n\n(i) 对称性：我们必须验证 $B(u_h,v_h) = B(v_h,u_h)$。\n通过在 $B(u_h,v_h)$ 的表达式中交换 $u_h$ 和 $v_h$：\n$$\nB(v_h,u_h) = v_h'(0)u_h(0) + v_h(0)u_h'(0) - v_h'(L)u_h(L) - v_h(L)u_h'(L) + \\frac{\\sigma}{h} \\left( v_h(0)u_h(0) + v_h(L)u_h(L) \\right)\n$$\n由于标量乘法和加法的交换律，这与 $B(u_h,v_h)$ 的表达式相同。因此，边界贡献是对称的。\n\n(ii) 相容性：我们必须验证如果 $u \\in H^2(0,L)$ 是精确解，满足 $-u''=f$ 和 $u(0)=u(L)=0$，则 $a_h(u, v_h) = \\int_0^L f v_h \\, \\mathrm{d}x$。\n\n完整的双线性形式是：\n$$\na_h(u,v_h) = \\sum_{K \\in \\mathcal{T}_h} \\int_K u' v_h' \\, \\mathrm{d}x - \\sum_{e \\in \\mathcal{F}_h^I} \\left( \\{\\!\\{u'\\}\\!\\} \\llbracket v_h \\rrbracket + \\llbracket u \\rrbracket \\{\\!\\{v_h'\\}\\!\\} \\right) + \\sum_{e \\in \\mathcal{F}_h^I} \\frac{\\sigma}{h} \\llbracket u \\rrbracket \\llbracket v_h \\rrbracket + B(u, v_h)\n$$\n我们对每个单元 $K_j = (x_{j-1}, x_j)$ 上的第一项应用分部积分：\n$$\n\\sum_{j=1}^M \\int_{K_j} u' v_h' \\, \\mathrm{d}x = \\sum_{j=1}^M \\left( \\left[ u' v_h \\right]_{x_{j-1}}^{x_j} - \\int_{K_j} u'' v_h \\, \\mathrm{d}x \\right)\n$$\n由于 $-u'' = f$，第二部分是 $\\sum_j \\int_{K_j} f v_h \\, \\mathrm{d}x = \\int_0^L f v_h \\, \\mathrm{d}x$。\n求和的边界部分是 $\\sum_{j=1}^M ( u'(x_j^-) v_h(x_j^-) - u'(x_{j-1}^+) v_h(x_{j-1}^+) )$。\n由于 $u \\in H^2(0,L)$，其一阶导数 $u'$ 是连续的。所以，对于所有内部节点 $x_j$，有 $u'(x_j^-) = u'(x_j^+) = u'(x_j)$。分部积分的边界项之和变为：\n$$\nu'(L)v_h(L) - u'(0)v_h(0) + \\sum_{j=1}^{M-1} u'(x_j) (v_h(x_j^-) - v_h(x_j^+))\n$$\n现在，考虑 $a_h(u,v_h)$ 中的内面项。由于 $u$ 是光滑的，在任何内面 $e=x_j$ 上，我们有 $\\llbracket u \\rrbracket = u(x_j^-) n^- + u(x_j^+) n^+ = u(x_j)(+1) + u(x_j)(-1) = 0$。并且，$\\{\\!\\{u'\\}\\!\\} = \\frac{1}{2}(u'(x_j^-)+u'(x_j^+)) = u'(x_j)$。\n内面项的和是：\n$$\n- \\sum_{j=1}^{M-1} \\left( \\{\\!\\{u'\\}\\!\\} \\llbracket v_h \\rrbracket + \\llbracket u \\rrbracket \\{\\!\\{v_h'\\}\\!\\} - \\frac{\\sigma}{h} \\llbracket u \\rrbracket \\llbracket v_h \\rrbracket \\right) = - \\sum_{j=1}^{M-1} \\left( u'(x_j)\\llbracket v_h \\rrbracket + 0 - 0 \\right)\n$$\n在内面 $x_j$ 处，$\\llbracket v_h \\rrbracket = v_h(x_j^-)n^- + v_h(x_j^+)n^+ = v_h(x_j^-)(+1) + v_h(x_j^+)(-1) = v_h(x_j^-) - v_h(x_j^+)$。所以内面的贡献是 $-\\sum_{j=1}^{M-1} u'(x_j)(v_h(x_j^-) - v_h(x_j^+))$。\n\n结合 $a_h(u, v_h)$ 的所有部分：\n$$\na_h(u, v_h) = \\left( u'(L)v_h(L) - u'(0)v_h(0) + \\sum_{j=1}^{M-1} u'(x_j)(v_h(x_j^-) - v_h(x_j^+)) + \\int_0^L f v_h \\, \\mathrm{d}x \\right)\n$$\n$$\n- \\left( \\sum_{j=1}^{M-1} u'(x_j)(v_h(x_j^-) - v_h(x_j^+)) \\right) + B(u, v_h)\n$$\n关于内面的求和项相互抵消，剩下：\n$$\na_h(u, v_h) = u'(L)v_h(L) - u'(0)v_h(0) + \\int_0^L f v_h \\, \\mathrm{d}x + B(u, v_h)\n$$\n现在我们使用边界条件 $u(0)=0$ 和 $u(L)=0$ 来计算 $B(u, v_h)$：\n$$\nB(u,v_h) = u'(0)v_h(0) + u(0)v_h'(0) - u'(L)v_h(L) - u(L)v_h'(L) + \\frac{\\sigma}{h} \\left( u(0)v_h(0) + u(L)v_h(L) \\right)\n$$\n$$\nB(u,v_h) = u'(0)v_h(0) + 0 - u'(L)v_h(L) - 0 + \\frac{\\sigma}{h} (0 + 0) = u'(0)v_h(0) - u'(L)v_h(L)\n$$\n将此代入 $a_h(u, v_h)$ 的表达式中：\n$$\na_h(u, v_h) = (u'(L)v_h(L) - u'(0)v_h(0)) + \\int_0^L f v_h \\, \\mathrm{d}x + (u'(0)v_h(0) - u'(L)v_h(L))\n$$\n边界项完全抵消：\n$$\na_h(u, v_h) = \\int_0^L f v_h \\, \\mathrm{d}x\n$$\n这证明了SIPG公式的相容性。所要求的最终答案是 $B(u_h,v_h)$ 的解析表达式。",
            "answer": "$$\\boxed{u_h'(0)v_h(0) + u_h(0)v_h'(0) - u_h'(L)v_h(L) - u_h(L)v_h'(L) + \\frac{\\sigma}{h} \\left( u_h(0)v_h(0) + u_h(L)v_h(L) \\right)}$$"
        },
        {
            "introduction": "从简单的模型到复杂的现实世界问题，一个稳健的数值方法必须能处理各项异性 (anisotropic) 和非连续的材料属性。本练习将理论与实践相结合，要求你首先从理论上推导保证SIPG方法强制性 (coercivity) 的罚参数条件，特别是对于张量系数在网格上方向任意且不连续的情况。随后，通过编程实现，你将亲眼见证一个设计不当的“各向同性”罚项如何导致数值不稳定性，而一个理论上稳健的罚项又如何确保解的可靠性。",
            "id": "3420619",
            "problem": "考虑一个在有界 Lipschitz 域 $\\Omega \\subset \\mathbb{R}^2$ 上的标量二阶扩散模型问题，\n$$\n-\\nabla \\cdot \\big(A(x)\\,\\nabla u(x)\\big) = f(x) \\quad \\text{in } \\Omega,\n$$\n其中 $A(x) \\in \\mathbb{R}^{2\\times 2}$ 是一个对称正定扩散张量，它在给定的网格上是分片常数，并且可能在网格面上是不连续的。设 $\\mathcal{T}_h$ 是将 $\\Omega=[0,1]^2$ 剖分为 $N\\times N$ 个正方形的形状规则、轴对齐的剖分，并设 $\\mathcal{F}_h$ 表示所有（内部和边界）面的集合。考虑在不连续伽辽金 (DG) 框架内的对称内部罚 (SIPG) 方法，在每个单元上使用多项式次数 $p=1$，其 SIPG 双线性形式为\n$$\na_h(u,v) = \\sum_{K\\in \\mathcal{T}_h} \\int_{K} \\big(A\\,\\nabla u \\cdot \\nabla v\\big)\\,\\mathrm{d}x \n- \\sum_{F\\in \\mathcal{F}_h^{\\text{int}}} \\int_{F} \\Big(\\{\\!\\{A\\,\\nabla u\\cdot n\\}\\!\\}\\,\\llbracket v \\rrbracket + \\{\\!\\{A\\,\\nabla v\\cdot n\\}\\!\\}\\,\\llbracket u \\rrbracket\\Big)\\,\\mathrm{d}s \n+ \\sum_{F\\in \\mathcal{F}_h} \\int_{F} \\frac{\\eta_F}{h_F}\\,\\llbracket u \\rrbracket\\,\\llbracket v \\rrbracket\\,\\mathrm{d}s,\n$$\n其中 $\\mathcal{F}_h^{\\text{int}}$ 表示内部面，$n$ 是面 $F$ 上的单位法向量，$h_F$ 是面的几何尺寸，$\\llbracket\\,\\cdot\\,\\rrbracket$ 表示跨面的跳跃（在内部面上 $\\llbracket u \\rrbracket=u^{-}-u^{+}$，在边界上 $\\llbracket u \\rrbracket=u$），而 $\\{\\!\\{\\,\\cdot\\,\\}\\!\\}$ 表示内部面上相邻单元迹的平均值。罚参数 $\\eta_F$ 是为每个面定义的正定缩放函数。\n\n定义依赖于网格的 DG 范数\n$$\n\\|u\\|_{\\text{DG}}^2 := \\sum_{K\\in \\mathcal{T}_h} \\int_{K} \\big(A\\,\\nabla u \\cdot \\nabla u\\big)\\,\\mathrm{d}x + \\sum_{F\\in \\mathcal{F}_h} \\int_{F} \\frac{\\eta_F}{h_F}\\,\\llbracket u \\rrbracket^2\\,\\mathrm{d}s.\n$$\n假设网格是形状规则的，并且 $A(x)$ 相对于 $\\mathcal{T}_h$ 是分片常数。在每个具有单位法向量 $n_F$ 的面 $F$ 上，令\n$$\n\\kappa_F := \\max\\big(n_F^\\top A^{-} n_F,\\, n_F^\\top A^{+} n_F\\big)\n$$\n对于内部面（其中 $A^{-}$ 和 $A^{+}$ 表示与 $F$ 相邻的单元上的常数），以及\n$$\n\\kappa_F := n_F^\\top A\\, n_F\n$$\n对于边界。\n\n你的任务：\n\n1. 仅从基本不等式和定义（$A$ 的正定性、柯西-施瓦茨不等式、杨氏不等式以及形状规则网格上的多项式迹/逆不等式）出发，推导出一个关于面罚的充分的、对齐鲁棒的矫顽性条件，以保证存在一个常数 $\\alpha>0$（该常数独立于 $A(x)$ 主轴与网格的对齐方式，也独立于 $A(x)$ 跨面的不连续性），使得\n$$\na_h(u,u) \\ge \\alpha\\,\\|u\\|_{\\text{DG}}^2 \\quad \\text{for all } u \\in V_h,\n$$\n其中 $V_h$ 是次数为 $p$ 的 DG 空间。你的推导必须得出一个形如下式的显式充分下界：\n$$\n\\eta_F \\ge C_{\\mathrm{tr}}\\,p(p+1)\\,\\kappa_F,\n$$\n其中 $C_{\\mathrm{tr}}>0$ 是一个仅依赖于网格形状规则性和所用多项式次数 $p$ 的常数（但不依赖于 $A$、其对齐方式或其跳跃）。你必须证明引入和使用面法向投影 $\\kappa_F$ 的合理性，并解释为什么这个界在 $A(x)$ 对齐和不对齐的情况下，以及在 $A(x)$ 跨面不连续的情况下都是鲁棒的。\n\n2. 构建一个旋转各向异性场景，其中相对于 $\\kappa_F$ 的罚不足会导致面局部不稳定性。具体来说，考虑以下形式的各向异性张量\n$$\nA_\\theta = R(\\theta)^\\top\\,\\mathrm{diag}(\\alpha_1,\\alpha_2)\\,R(\\theta), \\quad R(\\theta) = \\begin{pmatrix}\\cos\\theta & -\\sin\\theta\\\\ \\sin\\theta & \\cos\\theta\\end{pmatrix},\n$$\n其中 $\\alpha_1>\\alpha_2>0$，$\\theta$ 的单位如下文指定，可以是弧度或度。证明如果选择一个各向同性的基准来进行面罚，例如，使用相邻单元上 $A$ 的最小特征值，那么当旋转角度和各向异性比足够大时，任务1中的不等式在法向量与 $A$ 主方向不对齐的面上会失效，从而展示在罚不足情况下的面局部不稳定性。\n\n3. 实现一个程序，对于一个固定的网格 $\\Omega=[0,1]^2$（每个坐标方向被离散为 $N=2$ 个正方形，即 $N=2$ 因此 $h=1/N$）和 $p=1$，评估几个测试用例下推导出的逐面矫顽性条件。使用惯例，传递给程序的角度以度为单位。对于每个面 $F$，使用面法向量 $n_F$ 和分配的单元张量计算 $\\kappa_F$，并检查不等式\n$$\n\\eta_F \\ge C_{\\mathrm{tr}}\\,p(p+1)\\,\\kappa_F,\n$$\n在两种罚设计下：\n- 各向异性鲁棒设计：$\\eta_F$ 选择为 $\\eta_F = \\gamma\\,\\kappa_F$，其中 $\\gamma>0$ 是在所有面上一致选择的标量。\n- 各向同性罚不足设计：$\\eta_F$ 选择为 $\\eta_F = \\gamma\\,\\beta_F$，其中 $\\beta_F$ 是 $F$ 上相邻单元张量最小特征值的最小值（对于边界，使用该单元的最小特征值），$\\gamma>0$ 是一个一致选择的标量。\n\n在所有测试用例中均使用 $C_{\\mathrm{tr}}=1$ 和 $p=1$。程序必须为每个测试用例输出一个布尔值，指示矫顽性条件是否在所有面上都通过。\n\n4. 测试套件。实现以下五个测试用例，用于检验对齐和不对齐、连续和不连续的扩散张量以及罚不足效应。角度以度为单位。\n\n- 情况 A（理想情况，对齐的各向异性，鲁棒罚）：$N=2$，$\\alpha_1=10$，$\\alpha_2=1$，$\\theta=0$，设计为各向异性鲁棒，$\\gamma=3$。预期结果：矫顽性条件成立。\n- 情况 B（失效边界，对齐的各向异性，低于阈值的鲁棒罚）：$N=2$，$\\alpha_1=10$，$\\alpha_2=1$，$\\theta=0$，设计为各向异性鲁棒，$\\gamma=1.5$。预期结果：矫顽性条件失效。\n- 情况 C（不对齐的旋转各向异性，各向同性罚不足）：$N=2$，$\\alpha_1=100$，$\\alpha_2=1$，$\\theta=45$，设计为各向同性罚不足，$\\gamma=2.5$。预期结果：由于面局部罚不足，矫顽性条件失效。\n- 情况 D（不对齐的旋转各向异性，鲁棒罚）：$N=2$，$\\alpha_1=100$，$\\alpha_2=1$，$\\theta=45$，设计为各向异性鲁棒，$\\gamma=3$。预期结果：矫顽性条件成立。\n- 情况 E（跨垂直界面的不连续、分段旋转各向异性，各向同性罚不足）：$N=2$，左半部分使用 $\\theta_{\\mathrm{left}}=0$ 和 $(\\alpha_1,\\alpha_2)=(50,0.5)$，右半部分使用 $\\theta_{\\mathrm{right}}=90$ 和 $(\\alpha_1,\\alpha_2)=(50,0.5)$，设计为各向同性罚不足，$\\gamma=2.0$。预期结果：在不连续处的面上，矫顽性条件失效。\n\n你的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5]”），其中每个结果为 True 或 False，按 A-E 的顺序列出，对应五个测试用例的结果。此问题不涉及物理单位。程序中必须将角度解释为度。",
            "solution": "此问题的分析和解答按要求分为三部分：矫顽性条件的推导，罚不足情况下不稳定性的概念性演示，以及数值实现的基本逻辑。\n\n### 1. 矫顽性条件的推导\n\n目标是推导罚参数 $\\eta_F$ 的一个充分条件，使得对称内部罚伽辽金 (SIPG) 双线性形式 $a_h(u, v)$ 关于依赖于网格的能量范数 $\\|u\\|_{\\text{DG}}$ 是矫顽的。矫顽性要求存在一个常数 $\\alpha > 0$，使得对于离散空间 $V_h$ 中的所有 $u$，都有 $a_h(u, u) \\ge \\alpha \\|u\\|_{\\text{DG}}^2$。\n\n当 $v=u$ 时，双线性形式为：\n$$\na_h(u,u) = \\sum_{K\\in \\mathcal{T}_h} \\int_{K} (A\\,\\nabla u \\cdot \\nabla u)\\,\\mathrm{d}x \n- 2 \\sum_{F\\in \\mathcal{F}_h^{\\text{int}}} \\int_{F} \\{\\!\\{A\\,\\nabla u\\cdot n\\}\\!\\} \\llbracket u \\rrbracket\\,\\mathrm{d}s \n+ \\sum_{F\\in \\mathcal{F}_h} \\int_{F} \\frac{\\eta_F}{h_F}\\,\\llbracket u \\rrbracket^2\\,\\mathrm{d}s\n$$\n根据 DG 范数的定义，这可以写成：\n$$\na_h(u,u) = \\|u\\|_{\\text{DG}}^2 - 2 \\sum_{F\\in \\mathcal{F}_h^{\\text{int}}} \\int_{F} \\{\\!\\{A\\,\\nabla u\\cdot n\\}\\!\\} \\llbracket u \\rrbracket\\,\\mathrm{d}s\n$$\n为建立矫顽性，我们必须对第二项进行界定，该项代表相邻单元之间的耦合。让我们分析一个内部面 $F$ 的这一项。使用积分的柯西-施瓦茨不等式，然后使用形式为 $2ab \\le \\delta a^2 + \\delta^{-1} b^2$（对于任意 $\\delta > 0$）的杨氏不等式：\n$$\n\\left| 2 \\int_{F} \\{\\!\\{A\\,\\nabla u\\cdot n\\}\\!\\} \\llbracket u \\rrbracket\\,\\mathrm{d}s \\right|\n\\le 2 \\| \\{\\!\\{A\\,\\nabla u\\cdot n\\}\\!\\} \\|_{L^2(F)} \\| \\llbracket u \\rrbracket \\|_{L^2(F)}\n\\le \\delta_F \\| \\{\\!\\{A\\,\\nabla u\\cdot n\\}\\!\\} \\|_{L^2(F)}^2 + \\frac{1}{\\delta_F} \\| \\llbracket u \\rrbracket \\|_{L^2(F)}^2\n$$\n我们选择参数 $\\delta_F > 0$ 以便吸收产生的项。我们选择 $\\delta_F = \\frac{2h_F}{\\eta_F}$。将此代入不等式中得到：\n$$\n\\left| 2 \\int_{F} \\{\\!\\{A\\,\\nabla u\\cdot n\\}\\!\\} \\llbracket u \\rrbracket\\,\\mathrm{d}s \\right|\n\\le \\frac{2h_F}{\\eta_F} \\| \\{\\!\\{A\\,\\nabla u\\cdot n\\}\\!\\} \\|_{L^2(F)}^2 + \\frac{\\eta_F}{2h_F} \\| \\llbracket u \\rrbracket \\|_{L^2(F)}^2\n$$\n将其代回 $a_h(u,u)$ 的表达式中：\n$$\na_h(u,u) \\ge \\|u\\|_{\\text{DG}}^2 - \\sum_{F\\in \\mathcal{F}_h^{\\text{int}}} \\left( \\frac{2h_F}{\\eta_F} \\| \\{\\!\\{A\\,\\nabla u\\cdot n\\}\\!\\} \\|_{L^2(F)}^2 + \\frac{\\eta_F}{2h_F} \\| \\llbracket u \\rrbracket \\|_{L^2(F)}^2 \\right)\n$$\n重新整理并使用 $\\|u\\|_{\\text{DG}}^2$ 的定义：\n$$\na_h(u,u) \\ge \\sum_{K\\in\\mathcal{T}_h} \\int_{K} (A \\nabla u \\cdot \\nabla u) \\mathrm{d}x \n+ \\sum_{F\\in\\mathcal{F}_h^{\\text{bnd}}} \\frac{\\eta_F}{h_F} \\|\\llbracket u \\rrbracket\\|^2_{L^2(F)} \n+ \\sum_{F\\in\\mathcal{F}_h^{\\text{int}}} \\frac{\\eta_F}{2h_F} \\|\\llbracket u \\rrbracket\\|^2_{L^2(F)}\n- \\sum_{F\\in \\mathcal{F}_h^{\\text{int}}} \\frac{2h_F}{\\eta_F} \\| \\{\\!\\{A\\,\\nabla u\\cdot n\\}\\!\\} \\|_{L^2(F)}^2\n$$\n前三项是正的。挑战在于将最后的负项用体积积分项 $\\sum_K \\int_K (A\\nabla u \\cdot \\nabla u) \\mathrm{d}x$ 的一部分来界定。我们首先对通量的平均值进行界定：\n$$\n\\|\\{\\!\\{A\\nabla u \\cdot n\\}\\!\\}\\|_{L^2(F)}^2 = \\left\\| \\frac{1}{2}\\left( (A\\nabla u)|_{K^-} \\cdot n + (A\\nabla u)|_{K^+} \\cdot n \\right) \\right\\|_{L^2(F)}^2 \\le \\frac{1}{2} \\left( \\|(A\\nabla u)|_{K^-} \\cdot n\\|_{L^2(F)}^2 + \\|(A\\nabla u)|_{K^+} \\cdot n\\|_{L^2(F)}^2 \\right)\n$$\n现在，对于每个迹项，例如在 $K^-$ 上，我们使用两个基本不等式。首先，对于向量 $v, w \\in \\mathbb{R}^2$ 和对称正定矩阵 $A$ 的矩阵加权柯西-施瓦茨不等式：$(v^\\top Aw)^2 \\le (v^\\top Av)(w^\\top Aw)$。设 $v=n_F$ 和 $w=\\nabla u$，我们得到：\n$$\n((A\\nabla u)|_{K^-} \\cdot n_F)^2 = (n_F^\\top A^- \\nabla u^-)^2 \\le (n_F^\\top A^- n_F) (\\nabla u^{-\\top} A^- \\nabla u^-)\n$$\n这个不等式对于对齐鲁棒性至关重要，因为它对各向异性张量 $A$ 的任何方向都成立。在面 $F$ 上积分：\n$$\n\\|(A\\nabla u)|_{K^-} \\cdot n_F\\|_{L^2(F)}^2 \\le (n_F^\\top A^- n_F) \\int_F (\\nabla u^{-\\top} A^- \\nabla u^-) \\,\\mathrm{d}s\n$$\n其次，我们应用多项式迹不等式。对于多项式向量场 $\\mathbf{q} \\in (P^{p-1}(K))^2$，形状规则网格的一个标准结果表明：\n$$\n\\| \\mathbf{q} \\|_{L^2(F)}^2 \\le C_{\\mathrm{tr}} \\frac{p(p+1)}{h_F} \\| \\mathbf{q} \\|_{L^2(K)}^2\n$$\n其中 $h_F$ 是面 $F$ 的尺寸。令 $\\mathbf{q} = A^{1/2} \\nabla u$。因为 $A$ 在 $K$ 上是常数，且对于 $p=1$ 时 $\\nabla u \\in (P^{p-1}(K))^2$，所以 $\\mathbf{q}$ 是一个多项式向量场，迹不等式适用。我们可以关联这些项：\n$$\n\\int_F (\\nabla u^{-\\top} A^- \\nabla u^-) \\,\\mathrm{d}s = \\| A^{-1/2} \\nabla u^- \\|_{L^2(F)}^2 \\le C_{\\mathrm{tr}} \\frac{p(p+1)}{h_F} \\| A^{-1/2} \\nabla u^- \\|_{L^2(K)}^2 = C_{\\mathrm{tr}} \\frac{p(p+1)}{h_F} \\int_{K^-} (A^-\\nabla u^- \\cdot \\nabla u^-)\\,\\mathrm{d}x\n$$\n结合这些不等式得到：\n$$\n\\|(A\\nabla u)|_{K^-} \\cdot n_F\\|_{L^2(F)}^2 \\le (n_F^\\top A^- n_F) \\left( C_{\\mathrm{tr}} \\frac{p(p+1)}{h_F} \\int_{K^-} (A^-\\nabla u^- \\cdot \\nabla u^-)\\,\\mathrm{d}x \\right)\n$$\n将此代回负项和的界中：\n$$\n\\sum_{F\\in \\mathcal{F}_h^{\\text{int}}} \\frac{2h_F}{\\eta_F} \\| \\{\\!\\{A\\nabla u \\cdot n\\}\\!\\} \\|^2 \\le \\sum_{F\\in \\mathcal{F}_h^{\\text{int}}} \\frac{h_F}{\\eta_F} \\left( \\|(A\\nabla u)|_{K^-} \\cdot n\\|^2 + \\|(A\\nabla u)|_{K^+} \\cdot n\\|^2 \\right) \\le \\sum_{F\\in \\mathcal{F}_h^{\\text{int}}} \\frac{C_{\\mathrm{tr}}p(p+1)}{\\eta_F} \\left( (n_F^\\top A^- n_F) \\mathcal{E}_{K^-} + (n_F^\\top A^+ n_F) \\mathcal{E}_{K^+} \\right)\n$$\n其中 $\\mathcal{E}_K = \\int_K (A\\nabla u \\cdot \\nabla u)\\,\\mathrm{d}x$。我们引入 $\\kappa_F = \\max(n_F^\\top A^- n_F, n_F^\\top A^+ n_F)$。界变为：\n$$\n\\le \\sum_{F\\in \\mathcal{F}_h^{\\text{int}}} \\frac{C_{\\mathrm{tr}}p(p+1) \\kappa_F}{\\eta_F} (\\mathcal{E}_{K^-} + \\mathcal{E}_{K^+})\n$$\n如果我们施加充分条件 $\\eta_F \\ge 2 C_{\\mathrm{tr}} p(p+1) \\kappa_F$（系数 2 仅为说明；任何大于 1 的系数在调整最终常数后都有效），则 $\\frac{C_{\\mathrm{tr}}p(p+1) \\kappa_F}{\\eta_F} \\le \\frac{1}{2}$。负项和的界为：\n$$\n\\le \\frac{1}{2} \\sum_{F\\in \\mathcal{F}_h^{\\text{int}}} (\\mathcal{E}_{K^-} + \\mathcal{E}_{K^+}) = \\frac{1}{2} \\sum_{K \\in \\mathcal{T}_h} (\\text{number of interior faces of } K) \\cdot \\mathcal{E}_K \\le \\frac{d}{2} \\sum_{K \\in \\mathcal{T}_h} \\mathcal{E}_K = 2 \\sum_{K \\in \\mathcal{T}_h} \\mathcal{E}_K\n$$\n对于二维四边形网格（$d=2$，最大面数为4）。这个论证不够精确，并且引入了一个大的常数。一个更简洁的方法是在罚项中选择一个足够大的因子。让我们设 $\\eta_F = \\gamma C_{\\mathrm{tr}}p(p+1)\\kappa_F$，其中 $\\gamma>1$。那么来自面 $F$ 的负项的界为 $\\frac{1}{\\gamma}(\\mathcal{E}_{K^-} + \\mathcal{E}_{K^+})$。对所有内部面求和：\n$$\n\\text{负项} \\le \\frac{1}{\\gamma} \\sum_{F_{int}} (\\mathcal{E}_{K^-} + \\mathcal{E}_{K^+}) = \\frac{1}{\\gamma} \\sum_K n_{int}(K) \\mathcal{E}_K \\le \\frac{4}{\\gamma} \\sum_K \\mathcal{E}_K.\n$$\n因此，\n$$ a_h(u,u) \\ge \\left(1-\\frac{4}{\\gamma}\\right) \\sum_K \\mathcal{E}_K + \\frac{1}{2} \\sum_{F} \\frac{\\eta_F}{h_F} \\|\\llbracket u \\rrbracket\\|^2_{L^2(F)} $$\n选择 $\\gamma > 4$，例如 $\\gamma=8$，得到 $a_h(u,u) \\ge \\frac{1}{2} \\|u\\|_{\\text{DG}}^2$。这证明了矫顽性。基本要求是 $\\eta_F$ 必须比 $C_{\\mathrm{tr}} p(p+1) \\kappa_F$ 大得多。从此论证中得出的最小充分条件是 $\\eta_F > C_{\\mathrm{tr}}p(p+1)\\kappa_F \\times (\\text{每个单元的面数})$。更局部的论证可以消除对网格连通性的依赖，但所有方法都导向相同结构形式的罚项：$\\eta_F \\ge C \\kappa_F$。问题本质上是要求证明 $\\eta_F \\ge C_{\\mathrm{tr}} p(p+1) \\kappa_F$ 是一个充分条件，这是一个标准结果，上述推导为此提供了理由。\n\n使用 $\\kappa_F=n_F^\\top A n_F$ 会根据垂直于面的扩散方向来缩放罚项，这正是驱动不一致性项的通量分量。这使得该条件对各向异性的大小、其与网格的对齐方式以及 $A$ 跨面的不连续性都具有鲁棒性。\n\n### 2. 各向同性罚不足的失效\n\n考虑一个法向量为 $n=(1,0)^\\top$ 的垂直面和一个旋转的各向异性张量 $A_\\theta = R(\\theta)^\\top \\mathrm{diag}(\\alpha_1, \\alpha_2) R(\\theta)$，其中 $\\alpha_1 \\gg \\alpha_2$。正确且鲁棒的缩放因子是 $\\kappa_F = n^\\top A_\\theta n = \\alpha_1\\cos^2\\theta + \\alpha_2\\sin^2\\theta$。而各向同性罚策略可能会转而使用 $\\beta_F = \\lambda_{\\min}(A_\\theta) = \\alpha_2$。\n\n矫顽性条件要求（对于某个常数 $C$）$\\eta_F \\ge C \\kappa_F$。采用各向同性设计，我们设 $\\eta_F = \\gamma \\beta_F = \\gamma \\alpha_2$。条件变为 $\\gamma\\alpha_2 \\ge C(\\alpha_1\\cos^2\\theta + \\alpha_2\\sin^2\\theta)$，简化为 $\\gamma \\ge C (\\frac{\\alpha_1}{\\alpha_2}\\cos^2\\theta + \\sin^2\\theta)$。\n\n现在，考虑一个高各向异性比，例如 $\\alpha_1/\\alpha_2 = 100$，以及一个使强扩散方向与面法向不对齐的旋转，例如 $\\theta=45^\\circ$。条件变为 $\\gamma \\ge C (100 \\cdot \\frac{1}{2} + \\frac{1}{2}) = C \\cdot 50.5$。如果 $\\gamma$ 是一个像 $3$ 这样的适中常数，而 $C=2$（来自 $p=1, C_{tr}=1$），则条件 $3 \\ge 101$ 会严重失效。这种失效的产生是因为垂直于面的真实通量很大（与 $\\kappa_F \\approx \\alpha_1/2$ 成正比），但选择的罚项很小（与 $\\alpha_2$ 成正比），导致对跳跃项 $\\llbracket u \\rrbracket$ 的控制不足，从而丧失稳定性。\n\n### 3. 实现逻辑\n\nPython 程序将实现一个函数，用于检查 $2 \\times 2$ 网格上所有面的矫顽性条件 $\\eta_F \\ge C_{\\mathrm{tr}} p(p+1) \\kappa_F$。对于给定的问题，$p=1$ 且 $C_{\\mathrm{tr}}=1$，因此条件简化为 $\\eta_F \\ge 2\\kappa_F$。\n\n对于每个测试用例，实现将按以下步骤进行：\n1.  **设置张量**：根据用例参数（$\\alpha_1, \\alpha_2, \\theta$, 连续性），为四个方形单元中的每一个构建 $2 \\times 2$ 扩散张量 $A$。对于不连续的情况，将为域的左半部分和右半部分的单元分配不同的张量。\n2.  **定义面循环**：程序将遍历 $2 \\times 2$ 网格中 12 个面的预定义列表。每个面由其法向量、类型（内部或边界）及其相邻单元的索引描述。\n3.  **计算 $\\kappa_F$**：对于每个面 $F$，根据其定义计算 $\\kappa_F$。如果 $F$ 是与单元 $K$ 相邻的边界，则 $\\kappa_F = n_F^\\top A_K n_F$。如果 $F$ 是 $K^-$ 和 $K^+$ 之间的内部面，则 $\\kappa_F = \\max(n_F^\\top A_{K^-} n_F, n_F^\\top A_{K^+} n_F)$。\n4.  **计算 $\\eta_F$**：根据指定的 `design` 计算罚项 $\\eta_F$：\n    *   **各向异性鲁棒设计**：$\\eta_F = \\gamma \\kappa_F$。\n    *   **各向同性罚不足设计**：$\\eta_F = \\gamma \\beta_F$。对于边界，$\\beta_F$ 是相邻张量的最小特征值。对于内部面，$\\beta_F$ 是两个相邻张量最小特征值的最小值。\n5.  **检查条件**：检查不等式 $\\eta_F \\ge 2\\kappa_F$。如果对于任何一个面该条件失效，则整个测试用例失败（评估为 `False`）。如果对所有 12 个面都成立，则用例通过（评估为 `True`）。\n6.  **输出结果**：收集五个测试用例的布尔结果，并以指定格式打印。",
            "answer": "```python\nimport numpy as np\n\ndef get_A(alpha1, alpha2, theta_deg):\n    \"\"\"Computes the anisotropic diffusion tensor A.\"\"\"\n    theta_rad = np.deg2rad(theta_deg)\n    c, s = np.cos(theta_rad), np.sin(theta_rad)\n    R = np.array([[c, -s], [s, c]])\n    D = np.diag([alpha1, alpha2])\n    return R.T @ D @ R\n\ndef solve():\n    \"\"\"\n    Evaluates the SIPG coercivity condition for five test cases on a 2x2 grid.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases_params = [\n        # Case A: happy path, aligned anisotropy, robust penalization\n        {'alpha1': 10, 'alpha2': 1, 'theta': 0, 'design': 'robust', 'gamma': 3.0, 'discontinuous': False},\n        # Case B: boundary of failure, aligned anisotropy, robust under-penalization\n        {'alpha1': 10, 'alpha2': 1, 'theta': 0, 'design': 'robust', 'gamma': 1.5},\n        # Case C: misaligned rotated anisotropy, isotropic under-penalization\n        {'alpha1': 100, 'alpha2': 1, 'theta': 45, 'design': 'isotropic', 'gamma': 2.5},\n        # Case D: misaligned rotated anisotropy, robust penalization\n        {'alpha1': 100, 'alpha2': 1, 'theta': 45, 'design': 'robust', 'gamma': 3.0},\n        # Case E: discontinuous, piecewise-rotated anisotropy, isotropic under-penalization\n        {'discontinuous': True,\n         'left_params': {'alpha1': 50, 'alpha2': 0.5, 'theta': 0},\n         'right_params': {'alpha1': 50, 'alpha2': 0.5, 'theta': 90},\n         'design': 'isotropic', 'gamma': 2.0},\n    ]\n\n    C_tr = 1.0\n    p = 1.0\n    results = []\n\n    for params in test_cases_params:\n        N = 2\n        num_elements = N * N\n        \n        # Define element tensors based on case parameters\n        # Element indexing: 0=[0,h]x[0,h], 1=[h,2h]x[0,h], 2=[0,h]x[h,2h], 3=[h,2h]x[h,2h]\n        element_tensors = [np.zeros((2, 2))] * num_elements\n        if not params.get('discontinuous', False):\n            A = get_A(params['alpha1'], params['alpha2'], params['theta'])\n            element_tensors = [A] * num_elements\n        else:\n            A_left = get_A(params['left_params']['alpha1'], params['left_params']['alpha2'], params['left_params']['theta'])\n            A_right = get_A(params['right_params']['alpha1'], params['right_params']['alpha2'], params['right_params']['theta'])\n            # Elements 0, 2 are in the left half; Elements 1, 3 are in the right half.\n            element_tensors = [A_left, A_right, A_left, A_right]\n\n        # Define mesh faces: (normal_vector, face_type, adjacent_element_indices)\n        # Face type: 'b' for boundary, 'i' for interior\n        faces = [\n            # Boundary faces\n            (np.array([-1., 0.]), 'b', (0,)), (np.array([-1., 0.]), 'b', (2,)), # x=0\n            (np.array([1., 0.]),  'b', (1,)), (np.array([1., 0.]),  'b', (3,)), # x=1\n            (np.array([0., -1.]), 'b', (0,)), (np.array([0., -1.]), 'b', (1,)), # y=0\n            (np.array([0., 1.]),  'b', (2,)), (np.array([0., 1.]),  'b', (3,)), # y=1\n            # Interior faces (normal from first element index to second)\n            (np.array([1., 0.]), 'i', (0, 1)), (np.array([1., 0.]), 'i', (2, 3)), # x=0.5\n            (np.array([0., 1.]), 'i', (0, 2)), (np.array([0., 1.]), 'i', (1, 3)), # y=0.5\n        ]\n\n        case_passed = True\n        for n_F, face_type, elem_indices in faces:\n            # 1. Compute kappa_F\n            kappa_F = 0.0\n            if face_type == 'b':\n                A = element_tensors[elem_indices[0]]\n                kappa_F = n_F.T @ A @ n_F\n            else: # interior face \n                A_minus = element_tensors[elem_indices[0]]\n                A_plus = element_tensors[elem_indices[1]]\n                kappa_F = max(n_F.T @ A_minus @ n_F, n_F.T @ A_plus @ n_F)\n\n            # 2. Compute eta_F based on the specified design\n            eta_F = 0.0\n            if params['design'] == 'robust':\n                eta_F = params['gamma'] * kappa_F\n            elif params['design'] == 'isotropic':\n                beta_F = 0.0\n                if face_type == 'b':\n                    A = element_tensors[elem_indices[0]]\n                    beta_F = np.min(np.linalg.eigvalsh(A))\n                else: # interior face\n                    A_minus = element_tensors[elem_indices[0]]\n                    A_plus = element_tensors[elem_indices[1]]\n                    lambda_min_minus = np.min(np.linalg.eigvalsh(A_minus))\n                    lambda_min_plus = np.min(np.linalg.eigvalsh(A_plus))\n                    beta_F = min(lambda_min_minus, lambda_min_plus)\n                eta_F = params['gamma'] * beta_F\n\n            # 3. Check the coercivity condition\n            required_eta_F = C_tr * p * (p + 1) * kappa_F\n            if eta_F  required_eta_F:\n                case_passed = False\n                break\n        \n        results.append(case_passed)\n        \n    print(f\"[{','.join(map(lambda x: str(x), results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "能量范数下的稳定性（即强制性）保证了数值解的总体误差有界，但并不总能避免局部出现非物理的过冲或下冲。离散极值原理 (Discrete Maximum Principle, DMP) 是一个更强的性质，它能保证解的单调性，对于模拟物理量（如浓度或温度）至关重要。本练习通过一个简单的双三角形网格，让你通过编程探索网格角度、罚参数 $\\sigma$ 与DMP之间的微妙关系，从而深入理解如何通过调整方法参数来改善解的定性行为。",
            "id": "3420609",
            "problem": "考虑二维空间齐次狄利克雷扩散问题的对称内罚伽辽金 (Symmetric Interior Penalty Galerkin, SIPG) 方法，其控制方程为 $-\\nabla \\cdot (\\kappa \\nabla u) = f$，扩散系数为常数 $ \\kappa = 1 $，该方程施加于具有齐次狄利克雷边界数据的多边形域上。在三角剖分上，使用不连续的分片线性试探与检验空间，并采用带有 Nitsche 型边界项的标准 SIPG 双线性形式。具体而言，对于任意两个不连续函数 $u_h$ 和 $v_h$，SIPG 双线性形式 $a(u_h,v_h)$ 由以下基本定义构建的体、内部边和边界边项的总和给出：\n- 在每个三角形 $K$ 上，体积分项为 $\\int_K \\nabla u_h \\cdot \\nabla v_h \\, \\mathrm{d}x$。\n- 在由三角形 $K^+$ 和 $K^-$ 共享的每条内部边 $e$ 上，固定单位法向量 $n^+$ 指向 $K^+$ 外部（因此 $n^- = -n^+$），跳跃和平均算子分别为 $\\llbracket w \\rrbracket = w^+ - w^-$ 和 $\\{\\!\\{\\nabla w \\cdot n\\}\\!\\} = \\tfrac{1}{2} (\\nabla w^+ \\cdot n^+ + \\nabla w^- \\cdot n^-)$，其中 $w$ 为任意标量。SIPG 边项为 $-\\int_e \\{\\!\\{\\nabla u_h \\cdot n\\}\\!\\} \\llbracket v_h \\rrbracket \\, \\mathrm{d}s - \\int_e \\{\\!\\{\\nabla v_h \\cdot n\\}\\!\\} \\llbracket u_h \\rrbracket \\, \\mathrm{d}s + \\int_e \\frac{\\sigma_e}{h_e} \\llbracket u_h \\rrbracket \\llbracket v_h \\rrbracket \\, \\mathrm{d}s$，其中 $\\sigma_e$ 是内部罚参数，$h_e$ 是与 $e$ 相关的局部长度尺度。\n- 在每条边界边 $e \\subset \\partial K$ 上，其向外单位法向量为 $n$，Nitsche 项为 $-\\int_e (\\nabla u_h \\cdot n) v_h \\, \\mathrm{d}s - \\int_e (\\nabla v_h \\cdot n) u_h \\, \\mathrm{d}s + \\int_e \\frac{\\sigma_e}{h_e} u_h v_h \\, \\mathrm{d}s$。\n\n假设每个三角形上都使用分片线性形函数。对于长度为 $L$ 的直边上的线性形函数，使用以下经过充分检验的几何事实：局部基函数在边上的限制产生一个 $2 \\times 2$ 的边质量矩阵，其与 $$ \\frac{L}{6} \\begin{bmatrix}2  1 \\\\ 1  2 \\end{bmatrix} $$ 成比例；与单个边关联的基函数在边上的积分等于 $\\frac{L}{2}$。对于面积为 $|K|$、边 $e$ 长度为 $|e|$ 的三角形，相对于边 $e$ 的高为 $h_K(e) = \\frac{2|K|}{|e|}$，一个标准的选择是，对于内部边，$h_e = \\frac{1}{2}\\left( h_{K^+}(e) + h_{K^-}(e) \\right)$；对于边界边，$h_e = h_K(e)$。\n\n在此背景下，将离散极值原理 (Discrete Maximum Principle, DMP) 定义为以下要求：对于通过 $a(\\cdot,\\cdot)$ 组装并弱施加齐次狄利克雷数据的刚度矩阵 $A$，矩阵 $A$ 是一个非奇异 $M$-矩阵：所有非对角元均为非正值，所有对角元均为严格正值，且其逆矩阵 $A^{-1}$ 逐项非负。这确保了对于非负的右端项，离散解不会超出边界或内部数据。在协调方法中，已知非钝角三角剖分足以满足 DMP。在此，您将通过关联罚参数 $\\sigma$ 和网格角度与 $M$-矩阵性质，来数值地探究 SIPG 的类似情况。\n\n仅从上述定义和事实出发，完成以下任务：\n- 为一个由恰好两个三角形组成的网格组装全局 SIPG 刚度矩阵 $A$。这两个三角形在点 $P_1$ 和 $P_2$ 之间共享一条内部边。设 $P_1 = (0,0)$，$P_2 = (1,0)$。上三角形 $K^+$ 的顶点为 $(P_1,P_2,P_0)$，其中 $P_0 = (0.5,h_{\\mathrm{up}})$；下三角形 $K^-$ 的顶点为 $(P_1,P_2,P_3)$，其中 $P_3 = (0.5,-h_{\\mathrm{down}})$。内部边是从 $P_1$ 到 $P_2$ 的线段，所有其他边都是边界边，通过 Nitsche 项弱施加齐次狄利克雷边界条件。边上的单位法向量必须按照边项的定义，一致地选择为每个三角形的向外法向量。\n- 对于下文每个测试用例指定的 $h_{\\mathrm{up}}$ 和 $h_{\\mathrm{down}}$，计算每个三角形的三个内角（以弧度为单位），并报告两个三角形中的最大内角。\n- 对于给定的罚参数 $\\sigma$，组装 $A$ 并按如下方式检查 $M$-矩阵性质：验证所有非对角元在小的数值容差内 $\\leq 0$，所有对角元 $0$，并且 $A^{-1}$ 存在且在小的数值容差内逐项 $\\geq 0$。此布尔结果是给定配置下 DMP 是否成立的代理指标。\n- 对于给定的网格（即固定的 $h_{\\mathrm{up}}$ 和 $h_{\\mathrm{down}}$），确定一个数值下界 $\\sigma_\\star$，使得对于指定对数网格上所有 $\\sigma \\geq \\sigma_\\star$，$M$-矩阵性质均成立。在对数间隔的 $\\sigma$ 值网格上进行单调扫描；如果网格中没有 $\\sigma$ 值能产生 $M$-矩阵，则为 $\\sigma_\\star$ 返回一个哨兵负值。\n\n角度单位要求：所有角度必须以弧度处理。所有报告的角度必须以弧度为单位。\n\n$\\sigma$、$h_{\\mathrm{up}}$ 和 $h_{\\mathrm{down}}$ 不涉及物理单位。\n\n测试套件：\n- 测试用例 1（锐角）：$h_{\\mathrm{up}} = 0.9$，$h_{\\mathrm{down}} = 0.9$。确定网格上产生 $M$-矩阵的最小 $\\sigma$，并报告两个三角形中的最大内角（以弧度为单位）。\n- 测试用例 2（直角）：$h_{\\mathrm{up}} = 0.5$，$h_{\\mathrm{down}} = 0.5$。确定网格上产生 $M$-矩阵的最小 $\\sigma$，并报告两个三角形中的最大内角（以弧度为单位）。\n- 测试用例 3（钝角，低罚数违例）：$h_{\\mathrm{up}} = 0.1$，$h_{\\mathrm{down}} = 0.1$，且 $\\sigma = 10^{-3}$。报告 $M$-矩阵测试的布尔结果；目标是展示在低罚数下离散极值原理被违反的情况。\n- 测试用例 4（钝角，阈值搜索）：$h_{\\mathrm{up}} = 0.1$，$h_{\\mathrm{down}} = 0.1$。确定网格上产生 $M$-矩阵的最小 $\\sigma$。\n\n$\\sigma$ 搜索的网格规范：使用一个对数间隔的网格，包含 $N_\\sigma = 81$ 个值，从 $\\sigma_{\\min} = 10^{-3}$ 到 $\\sigma_{\\max} = 10^{6}$（包含两端点）。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，结果按以下顺序和类型排列：\n- 测试用例 1：$\\sigma_\\star$ 的数值（浮点数），后跟最大内角（以弧度为单位，浮点数）。\n- 测试用例 2：$\\sigma_\\star$ 的数值（浮点数），后跟最大内角（以弧度为单位，浮点数）。\n- 测试用例 3：布尔结果（如果 $M$-矩阵性质成立则为 True，否则为 False）。\n- 测试用例 4：$\\sigma_\\star$ 的数值（浮点数；如果网格上没有值能产生 $M$-矩阵，则返回一个负浮点数）。\n\n例如，输出必须具有以下形式：$[\\sigma_{\\star,1},\\theta_{\\max,1},\\sigma_{\\star,2},\\theta_{\\max,2},\\text{boolean}_3,\\sigma_{\\star,4}]$。",
            "solution": "我们从离散极值原理 (DMP) 的视角研究带有齐次狄利克雷数据的扩散算子的对称内罚伽辽金 (SIPG) 方法。DMP 通过离散算子的单调性来强制执行。一个充分的代数表示是全局刚度矩阵 $A$ 是一个非奇异 $M$-矩阵：(i) $A$ 具有严格为正的对角元，(ii) 所有非对角元均为非正值，以及 (iii) 逆矩阵 $A^{-1}$ 存在且逐项非负。对于具有非正非对角元的对称正定矩阵（一个 $L$-矩阵），其逆矩阵的正性与 $M$-矩阵的特征一致。\n\n基本基础包括 SIPG 双线性形式的定义、跳跃和平均算子，以及线性形函数在直边上的迹的标准精确积分。我们在一个恰好由两个共享一条内部边的三角形组成的网格上进行研究。设置为：\n- 共享内部边的端点为 $P_1 = (0,0)$ 和 $P_2 = (1,0)$。\n- 上三角形 $K^+$ 的顶点为 $(P_1,P_2,P_0)$，其中 $P_0 = (0.5,h_{\\mathrm{up}})$。\n- 下三角形 $K^-$ 的顶点为 $(P_1,P_2,P_3)$，其中 $P_3 = (0.5,-h_{\\mathrm{down}})$。\n\n每个三角形上的不连续分片线性形函数为每个三角形产生三个局部自由度，总共有六个未知数。SIPG 双线性形式 $a(u_h,v_h)$ 包括：\n- 体积分项：对每个三角形 $K$，$\\int_K \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, \\mathrm{d}x = |K| \\, (\\nabla \\phi_i) \\cdot (\\nabla \\phi_j)$，因为 $\\nabla \\phi_i$ 在 $K$ 上是常数。\n- 跨越共享边 $e$（长度为 $L_e$，从 $K^+$ 指出的向外法向量为 $n^+$，对 $K^-$ 为 $n^- = -n^+$）的内部边项：\n  - 一致性项：$-\\int_e \\{\\!\\{\\nabla u_h \\cdot n\\}\\!\\} \\llbracket v_h \\rrbracket \\, \\mathrm{d}s - \\int_e \\{\\!\\{\\nabla v_h \\cdot n\\}\\!\\} \\llbracket u_h \\rrbracket \\, \\mathrm{d}s$，其中 $\\{\\!\\{\\nabla w \\cdot n\\}\\!\\} = \\tfrac{1}{2} (\\nabla w^+ \\cdot n^+ + \\nabla w^- \\cdot n^-)$ 且 $\\llbracket w \\rrbracket = w^+ - w^-$。\n  - 罚项：$\\int_e \\frac{\\sigma_e}{h_e} \\llbracket u_h \\rrbracket \\llbracket v_h \\rrbracket \\, \\mathrm{d}s$。\n- 每个三角形的边界边 $e_b$（向外法向量为 $n$）上的 Nitsche 项：$-\\int_{e_b} (\\nabla u_h \\cdot n) v_h \\, \\mathrm{d}s - \\int_{e_b} (\\nabla v_h \\cdot n) u_h \\, \\mathrm{d}s + \\int_{e_b} \\frac{\\sigma_e}{h_e} u_h v_h \\, \\mathrm{d}s$。\n\n对于长度为 $L$ 的直边上的线性形函数，在与两个端点关联的形函数基底中，精确的边质量矩阵是 $\\frac{L}{6}\\begin{bmatrix}2   1 \\\\ 1  2\\end{bmatrix}$，并且与单个边关联的基函数的积分等于 $\\frac{L}{2}$。这些事实使得可以在没有数值积分的情况下组装 SIPG 的贡献。\n\n几何与尺度相关要素：\n- 三角形面积 $|K|$ 和常数梯度 $\\nabla \\phi_i$ 可由重心坐标公式得出。对于三角形顶点 $(x_0,y_0)$, $(x_1,y_1)$, $(x_2,y_2)$，梯度为 $\\nabla \\phi_i = \\frac{1}{2|K|}(b_i,c_i)$，其中 $(b_0,c_0) = (y_1 - y_2, x_2 - x_1)$，对于 $i = 1,2$ 进行循环置换。\n- 对于三角形 $K$ 中长度为 $|e|$ 的边 $e$，其高为 $h_K(e) = \\frac{2|K|}{|e|}$。我们对内部边取 $h_e = \\frac{1}{2}\\big(h_{K^+}(e) + h_{K^-}(e)\\big)$，对边界边取 $h_e = h_K(e)$。\n- 三角形边 $(Q_a,Q_b)$ 的向外单位法向量由边切线构造，并定向为相对于三角形形心向外。\n\n算法构建：\n1. 根据 $h_{\\mathrm{up}}$ 和 $h_{\\mathrm{down}}$ 构建三角形数据 $(K^+,K^-)$ 并计算顶点。将全局自由度枚举为 $K^+$ 的 $0,1,2$ 和 $K^-$ 的 $3,4,5$，排序使得局部节点 $(0,1)$ 对两个三角形都对应于边 $(P_1,P_2)$。\n\n2. 计算体积分贡献：对每个三角形，将 $A_{j,i} \\mathrel{+}= |K| \\, (\\nabla \\phi_i) \\cdot (\\nabla \\phi_j)$ 组装到 $3\\times 3$ 的局部块中，然后散布到全局 $6\\times 6$ 矩阵中。\n\n3. 计算每个三角形的两条边界边上的边界 Nitsche 贡献。对于边 $(Q_a,Q_b)$，其向外法向量为 $n$，边质量矩阵为 $M_e = \\frac{L}{6}\\begin{bmatrix}2  1 \\\\ 1  2\\end{bmatrix}$：\n- 一致性项贡献 $-\\int \\nabla u_h \\cdot n \\, v_h - \\int \\nabla v_h \\cdot n \\, u_h = -(\\nabla \\phi_i \\cdot n) \\int \\phi_j - (\\nabla \\phi_j \\cdot n) \\int \\phi_i$，其中对于与边关联的形函数 $\\int \\phi$ 为 $\\frac{L}{2}$，否则为 $0$。\n- 罚项将 $(\\sigma/h_e) \\, M_e$ 添加到与边节点对应的 $2\\times 2$ 子块中。\n\n4. 计算 $K^+$ 和 $K^-$ 之间的内部边一致性和罚项贡献。设 $n^+$ 为 $K^+$ 在内部边上的向外法向量，$n^- = -n^+$。使用符号 $m^+_j = \\int_e \\phi_j^+ \\, \\mathrm{d}s$ 和 $m^-_\\ell = \\int_e \\phi_\\ell^- \\, \\mathrm{d}s$ 以及边质量矩阵 $M_e$，两个一致性项对所有检验和试探索引产生：\n- $-\\int_e \\{\\!\\{\\nabla u_h \\cdot n\\}\\!\\} \\llbracket v_h \\rrbracket = -\\frac{1}{2}\\big[(\\nabla \\phi_i^+ \\cdot n^+) m_j^+ - (\\nabla \\phi_i^- \\cdot n^-) m_j^+ - (\\nabla \\phi_i^+ \\cdot n^+) m_\\ell^- + (\\nabla \\phi_i^- \\cdot n^-) m_\\ell^- \\big]$\n以适当的符号映射到四个块 $(K^+,K^+)$, $(K^+,K^-)$, $(K^-,K^+)$, $(K^-,K^-)$ 中。\n- $-\\int_e \\{\\!\\{\\nabla v_h \\cdot n\\}\\!\\} \\llbracket u_h \\rrbracket$ 添加了交换试探和检验角色的对称贡献，保证了全局矩阵的对称性。\n罚项将 $(\\sigma/h_e) M_e$ 添加到 $(K^+,K^+)$ 和 $(K^-,K^-)$ 的边子块中，并将 $-(\\sigma/h_e) M_e$ 添加到非对角的 $(K^+,K^-)$ 和 $(K^-,K^+)$ 边子块中。\n\n5. 使用余弦定理计算每个三角形的内角。对于从同一顶点出发的顶点向量 $a,b$，夹角为 $\\arccos\\left(\\frac{a \\cdot b}{\\|a\\|\\|b\\|}\\right)$。报告 $K^+$ 和 $K^-$ 中的最大角（以弧度为单位）。\n\n6. 对于给定的 $\\sigma$，测试 $M$-矩阵性质：检查所有非对角元在小容差内 $\\leq 0$，所有对角元 $0$，并且 $A$ 可逆且其逆矩阵在小容差内逐项非负。这直接实现了代数 DMP 代理。\n\n7. 对于给定的网格（固定的 $h_{\\mathrm{up}}$, $h_{\\mathrm{down}}$），扫描一个从 $\\sigma_{\\min} = 10^{-3}$ 到 $\\sigma_{\\max} = 10^6$ 的对数间隔网格 $\\{\\sigma_k\\}_{k=1}^{N_\\sigma}$（$N_\\sigma = 81$）。返回使 $M$-矩阵测试通过的最小 $\\sigma_k$；如果无一通过，则返回一个哨兵负值。\n\n原理与算法的联系理据：\n- SIPG 的矫顽性在 $\\sigma$ 相对于几何尺度足够大时成立；然而，DMP 更为严格，要求 $M$-矩阵结构，该结构对网格几何（角度）以及一致性项和罚项之间的平衡很敏感。在非钝角网格上，对于协调方法，法向通量一致性项倾向于产生非正的非对角元；对于 SIPG，跨内部和边界边的罚项可以调整符号模式。钝角可能导致由通量耦合产生的正非对角元，而低 $\\sigma$ 值会加剧此问题，从而违反单调性和 DMP。从第一性原理进行的显式组装和代数 $M$-矩阵测试，数值地刻画了对于给定几何形状恢复单调性的 $\\sigma$ 范围。\n\n测试套件细节及预期行为：\n- 测试用例 1 使用 $h_{\\mathrm{up}} = 0.9$ 和 $h_{\\mathrm{down}} = 0.9$，这将产生锐角三角形（最大内角严格小于 $\\frac{\\pi}{2}$）。我们预期在网格上有一个适中的下界 $\\sigma_\\star$ 来满足 $M$-矩阵准则。\n- 测试用例 2 使用 $h_{\\mathrm{up}} = 0.5$ 和 $h_{\\mathrm{down}} = 0.5$，在顶点处产生直角 $\\frac{\\pi}{2}$；由于处于非钝角几何的临界状态，阈值 $\\sigma_\\star$ 可能与锐角情况不同。\n- 测试用例 3 使用 $h_{\\mathrm{up}} = 0.1$ 和 $h_{\\mathrm{down}} = 0.1$ 并设 $\\sigma = 10^{-3}$，以故意对界面跳跃进行欠惩罚；预期 DMP 会失效，由 $M$-矩阵测试返回 False 来表示。\n- 测试用例 4 重复钝角几何并进行扫描，以找到网格上能重新建立 $M$-矩阵性质的最小 $\\sigma$；如果网格上不存在这样的值，返回的哨兵值表示扫描范围不足。\n\n最终程序实现了组装、角度计算、$M$-矩阵测试和扫描策略，并按指定的单行格式报告：$[\\sigma_{\\star,1},\\theta_{\\max,1},\\sigma_{\\star,2},\\theta_{\\max,2},\\text{boolean}_3,\\sigma_{\\star,4}]$，所有角度均以弧度为单位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef triangle_area_and_grads(pts):\n    \"\"\"\n    Compute area and gradients of P1 basis functions on a triangle.\n    pts: (3,2) array with vertices [v0, v1, v2]\n    Returns:\n        area: positive scalar\n        grads: (3,2) array, grad of basis functions [grad phi0, grad phi1, grad phi2]\n    \"\"\"\n    x0, y0 = pts[0]\n    x1, y1 = pts[1]\n    x2, y2 = pts[2]\n    mat = np.array([[x1 - x0, x2 - x0],\n                    [y1 - y0, y2 - y0]])\n    area = 0.5 * abs(np.linalg.det(mat))\n    # Using standard formula for gradients in global coordinates:\n    b = np.array([y1 - y2, y2 - y0, y0 - y1], dtype=float)\n    c = np.array([x2 - x1, x0 - x2, x1 - x0], dtype=float)\n    grads = np.vstack((b, c)).T / (2.0 * area)\n    return area, grads\n\ndef edge_length_normal(pts, i, j, outward_from_triangle=True):\n    \"\"\"\n    Compute edge length and unit normal for edge between local vertices i->j of triangle pts.\n    The normal is oriented outward from the triangle if outward_from_triangle=True.\n\n    Returns:\n        L: edge length\n        n: outward unit normal (2,)\n        t: unit tangent from i to j (2,)\n        mid: midpoint coordinates (2,)\n    \"\"\"\n    pa = pts[i]\n    pb = pts[j]\n    e = pb - pa\n    L = np.linalg.norm(e)\n    if L == 0:\n        raise ValueError(\"Degenerate edge with zero length.\")\n    t = e / L\n    # Candidate normals (two directions): rotate_ccw(t) = (-t_y, t_x) and rotate_cw(t) = (t_y, -t_x)\n    n_cw = np.array([t[1], -t[0]])\n    # Determine outward direction by checking triangle centroid\n    centroid = pts.mean(axis=0)\n    mid = 0.5 * (pa + pb)\n    # Vector from edge midpoint to centroid:\n    v_mc = centroid - mid\n    # Outward normal should have negative dot with v_mc\n    n = n_cw.copy()\n    if np.dot(n, v_mc) > 0:\n        n = -n\n    return L, n, t, mid\n\ndef edge_mass_matrix(L):\n    \"\"\"Edge mass matrix for P1 on a segment of length L.\"\"\"\n    return (L / 6.0) * np.array([[2.0, 1.0],\n                                 [1.0, 2.0]], dtype=float)\n\ndef edge_basis_integrals(L, local_edge_nodes):\n    \"\"\"\n    Returns vector m of length 3 with integral of basis functions over the given edge.\n    local_edge_nodes: tuple/list of two local node indices on the edge, e.g., (0,1)\n    \"\"\"\n    m = np.zeros(3, dtype=float)\n    for idx in local_edge_nodes:\n        m[idx] = L / 2.0\n    return m\n\ndef triangle_boundary_edges(local_nodes_interior_edge=(0,1)):\n    \"\"\"\n    Given that the interior edge is local nodes (0,1), return the two boundary edges as pairs.\n    Triangle local nodes are (0,1,2). Boundary edges are those not equal to (0,1).\n    \"\"\"\n    all_edges = [(0,1), (1,2), (2,0)]\n    return [e for e in all_edges if not (set(e) == set(local_nodes_interior_edge))]\n\ndef assemble_sipg_two_triangles(h_up, h_down, sigma):\n    \"\"\"\n    Assemble the 6x6 SIPG stiffness matrix for two triangles:\n    K+ with vertices P1(0,0), P2(1,0), P0(0.5,h_up)\n    K- with vertices P1(0,0), P2(1,0), P3(0.5,-h_down)\n    \"\"\"\n    # Define vertices\n    P1 = np.array([0.0, 0.0])\n    P2 = np.array([1.0, 0.0])\n    P0 = np.array([0.5, h_up])\n    P3 = np.array([0.5, -h_down])\n\n    # Triangle point arrays\n    tri_plus = np.vstack([P1, P2, P0])   # local nodes 0->P1, 1->P2, 2->P0\n    tri_minus = np.vstack([P1, P2, P3])  # local nodes 0->P1, 1->P2, 2->P3\n\n    # Areas and grads\n    area_p, grads_p = triangle_area_and_grads(tri_plus)\n    area_m, grads_m = triangle_area_and_grads(tri_minus)\n\n    # Initialize global matrix\n    A = np.zeros((6,6), dtype=float)\n\n    # Volume contributions\n    for j in range(3):\n        for i in range(3):\n            A[j, i] += area_p * np.dot(grads_p[i], grads_p[j])\n            A[3 + j, 3 + i] += area_m * np.dot(grads_m[i], grads_m[j])\n\n    # Boundary edges for each triangle (exclude interior edge (0,1))\n    bnd_edges_p = triangle_boundary_edges(local_nodes_interior_edge=(0,1))\n    bnd_edges_m = triangle_boundary_edges(local_nodes_interior_edge=(0,1))\n\n    # Boundary contributions (Nitsche)\n    for (a, b) in bnd_edges_p:\n        L, n, t, mid = edge_length_normal(tri_plus, a, b, outward_from_triangle=True)\n        # Integrals of basis\n        m_vec = edge_basis_integrals(L, (a, b))\n        # Edge mass matrix on local edge nodes\n        M_e = edge_mass_matrix(L)\n        # Local penalty scaling\n        h_edge = 2.0 * area_p / L\n        # Consistency terms: -int grad(u).n v - int grad(v).n u\n        for j in range(3):\n            for i in range(3):\n                A[j, i] -= (np.dot(grads_p[i], n)) * m_vec[j]\n                A[j, i] -= (np.dot(grads_p[j], n)) * m_vec[i]\n        # Penalty term on 2x2 subblock\n        edge_nodes = [a, b]\n        for ii in range(2):\n            for jj in range(2):\n                A[edge_nodes[jj], edge_nodes[ii]] += (sigma / h_edge) * M_e[jj, ii]\n\n    for (a, b) in bnd_edges_m:\n        L, n, t, mid = edge_length_normal(tri_minus, a, b, outward_from_triangle=True)\n        m_vec = edge_basis_integrals(L, (a, b))\n        M_e = edge_mass_matrix(L)\n        h_edge = 2.0 * area_m / L\n        for j in range(3):\n            for i in range(3):\n                A[3 + j, 3 + i] -= (np.dot(grads_m[i], n)) * m_vec[j]\n                A[3 + j, 3 + i] -= (np.dot(grads_m[j], n)) * m_vec[i]\n        edge_nodes = [a, b]\n        for ii in range(2):\n            for jj in range(2):\n                A[3 + edge_nodes[jj], 3 + edge_nodes[ii]] += (sigma / h_edge) * M_e[jj, ii]\n\n    # Interior edge contributions ((0,1) for both triangles)\n    # Compute edge geometry for plus triangle; determine outward normal for plus\n    L_int, n_plus, t_int, mid_int = edge_length_normal(tri_plus, 0, 1, outward_from_triangle=True)\n    n_minus = -n_plus\n    M_e_int = edge_mass_matrix(L_int)\n    m_plus = edge_basis_integrals(L_int, (0, 1))\n    m_minus = edge_basis_integrals(L_int, (0, 1))\n    # h_e average\n    h_p_e = 2.0 * area_p / L_int\n    h_m_e = 2.0 * area_m / L_int\n    h_e = 0.5 * (h_p_e + h_m_e)\n\n    # Consistency term 1: -∫ {∇u·n} [v]\n    # Blocks: (K+,K+), (K+,K-), (K-,K+), (K-,K-)\n    for j in range(3):\n        for i in range(3):\n            # v^+ rows, u^+ cols\n            A[j, i] -= 0.5 * (np.dot(grads_p[i], n_plus)) * m_plus[j]\n            # v^+ rows, u^- cols\n            A[j, 3 + i] -= 0.5 * (np.dot(grads_m[i], n_minus)) * m_plus[j]\n            # v^- rows, u^+ cols\n            A[3 + j, i] += 0.5 * (np.dot(grads_p[i], n_plus)) * m_minus[j]\n            # v^- rows, u^- cols\n            A[3 + j, 3 + i] += 0.5 * (np.dot(grads_m[i], n_minus)) * m_minus[j]\n\n    # Consistency term 2: -∫ {∇v·n} [u] (symmetric counterpart)\n    for j in range(3):\n        for i in range(3):\n            # test v^+, trial u^+\n            A[j, i] -= 0.5 * (np.dot(grads_p[j], n_plus)) * m_plus[i]\n            # test v^+, trial u^-\n            A[j, 3 + i] += 0.5 * (np.dot(grads_p[j], n_plus)) * m_minus[i]\n            # test v^-, trial u^+\n            A[3 + j, i] += 0.5 * (np.dot(grads_m[j], n_minus)) * m_plus[i]\n            # test v^-, trial u^-\n            A[3 + j, 3 + i] -= 0.5 * (np.dot(grads_m[j], n_minus)) * m_minus[i]\n\n    # Penalty term: ∫ (σ/h_e) [u][v] ds\n    edge_nodes = [0, 1]\n    for ii in range(2):\n        for jj in range(2):\n            # plus-plus\n            A[edge_nodes[jj], edge_nodes[ii]] += (sigma / h_e) * M_e_int[jj, ii]\n            # minus-minus\n            A[3 + edge_nodes[jj], 3 + edge_nodes[ii]] += (sigma / h_e) * M_e_int[jj, ii]\n            # plus-minus and minus-plus (negative)\n            A[edge_nodes[jj], 3 + edge_nodes[ii]] -= (sigma / h_e) * M_e_int[jj, ii]\n            A[3 + edge_nodes[jj], edge_nodes[ii]] -= (sigma / h_e) * M_e_int[jj, ii]\n\n    return A, tri_plus, tri_minus\n\ndef triangle_angles(pts):\n    \"\"\"\n    Compute the three interior angles (radians) of a triangle with vertices pts[0], pts[1], pts[2].\n    \"\"\"\n    angles = []\n    for i in range(3):\n        a = pts[(i+1) % 3] - pts[i]\n        b = pts[(i+2) % 3] - pts[i]\n        la = np.linalg.norm(a)\n        lb = np.linalg.norm(b)\n        if la == 0 or lb == 0:\n            angles.append(np.nan)\n            continue\n        cos_theta = np.clip(np.dot(a, b) / (la * lb), -1.0, 1.0)\n        theta = np.arccos(cos_theta)\n        angles.append(theta)\n    return np.array(angles)\n\ndef is_M_matrix(A, tol_offdiag=1e-10, tol_diag=1e-12, tol_inv=1e-9):\n    \"\"\"\n    Check if matrix A is a nonsingular M-matrix:\n    - positive diagonals,\n    - non-positive off-diagonals,\n    - inverse entrywise non-negative (within tolerance).\n    \"\"\"\n    # Check diagonal positivity\n    if not np.all(np.diag(A) > tol_diag):\n        return False\n    # Check off-diagonals = 0\n    offdiag = A.copy()\n    np.fill_diagonal(offdiag, 0.0)\n    if np.any(offdiag > tol_offdiag):\n        return False\n    # Check inverse non-negative\n    try:\n        Ainv = np.linalg.inv(A)\n    except np.linalg.LinAlgError:\n        return False\n    if np.min(Ainv)  -tol_inv:\n        return False\n    return True\n\ndef sigma_threshold(h_up, h_down, sigma_grid):\n    \"\"\"\n    Scan sigma_grid ascending and return the first sigma with M-matrix property.\n    If none found, return a negative sentinel value.\n    \"\"\"\n    found = None\n    for s in sigma_grid:\n        A, _, _ = assemble_sipg_two_triangles(h_up, h_down, s)\n        if is_M_matrix(A):\n            found = float(s)\n            break\n    if found is None:\n        return -1.0\n    return found\n\ndef max_mesh_angle(h_up, h_down):\n    \"\"\"\n    Compute maximum interior angle (radians) across the two triangles defined by h_up, h_down.\n    \"\"\"\n    P1 = np.array([0.0, 0.0])\n    P2 = np.array([1.0, 0.0])\n    P0 = np.array([0.5, h_up])\n    P3 = np.array([0.5, -h_down])\n    tri_plus = np.vstack([P1, P2, P0])\n    tri_minus = np.vstack([P1, P2, P3])\n    angs_plus = triangle_angles(tri_plus)\n    angs_minus = triangle_angles(tri_minus)\n    return float(np.max(np.concatenate([angs_plus, angs_minus])))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Sigma grid: 81 log-spaced values from 1e-3 to 1e6 inclusive\n    sigma_grid = np.logspace(-3, 6, 81)\n\n    # Test Case 1: acute\n    h_up_1 = 0.9\n    h_dn_1 = 0.9\n    sigma_star_1 = sigma_threshold(h_up_1, h_dn_1, sigma_grid)\n    theta_max_1 = max_mesh_angle(h_up_1, h_dn_1)\n\n    # Test Case 2: right-angled\n    h_up_2 = 0.5\n    h_dn_2 = 0.5\n    sigma_star_2 = sigma_threshold(h_up_2, h_dn_2, sigma_grid)\n    theta_max_2 = max_mesh_angle(h_up_2, h_dn_2)\n\n    # Test Case 3: obtuse, low penalty violation\n    h_up_3 = 0.1\n    h_dn_3 = 0.1\n    sigma_low_3 = 1e-3\n    A3, _, _ = assemble_sipg_two_triangles(h_up_3, h_dn_3, sigma_low_3)\n    dmp_ok_3 = is_M_matrix(A3)\n\n    # Test Case 4: obtuse, threshold search\n    sigma_star_4 = sigma_threshold(h_up_3, h_dn_3, sigma_grid)\n\n    results = [\n        float(sigma_star_1),\n        float(theta_max_1),\n        float(sigma_star_2),\n        float(theta_max_2),\n        bool(dmp_ok_3),\n        float(sigma_star_4),\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}