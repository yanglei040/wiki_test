{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在构建谱伽辽金方法的基本构件。通过从第一性原理出发实现质量矩阵和刚度矩阵的组装，您将对如何使用高阶基函数和数值求积来形成离散算子有一个实践性的理解。这项练习对于建立关于离散系统结构和性质的直觉至关重要。",
            "id": "3418566",
            "problem": "考虑参考区间 $[-1,1]$ 以及在 高斯-洛巴托-勒让德 节点上使用拉格朗日插值节点基的谱伽辽金方法。设多项式阶数为 $N=4$，因此有 $N+1=5$ 个节点。此构造的基础是一维泊松算子的变分形式和拉格朗日节点基函数的定义。具体而言，对于在节点上表示的函数 $v$，离散质量矩阵 $M$ 近似于 $\\int_{-1}^{1} \\ell_i(x)\\,\\ell_j(x)\\,dx$，离散刚度矩阵 $K$ 近似于 $\\int_{-1}^{1} \\ell_i'(x)\\,\\ell_j'(x)\\,dx$，其中 $\\ell_i$ 是与 高斯-洛巴托-勒让德 节点相关联的拉格朗日基多项式。离散能量范数定义为 $\\|v\\|_K=\\sqrt{v^\\top K v}$。\n\n您的任务是编写一个完整的程序，该程序：\n- 利用勒让德多项式及其导数的性质，计算在 $[-1,1]$ 上当 $N=4$ 时的高斯-洛巴托-勒让德节点（包括端点）及其相关的求积权重。\n- 通过对拉格朗日基一致地使用重心权重，在这些节点上构建拉格朗日节点微分矩阵 $D$，确保 $D$ 是节点插值函数微分的矩阵表示。\n- 基于高斯-洛巴托-勒让德求积法则和上述基，在 $[-1,1]$ 上组装质量矩阵 $M$ 和刚度矩阵 $K$。\n- 对每个指定的节点向量 $v$ 计算离散能量范数 $\\|v\\|_K=\\sqrt{v^\\top K v}$。\n\n您必须仅使用与谱伽辽金框架一致的、数学上合理的程序以及勒让德多项式、拉格朗日插值和高斯-洛巴托-勒让德求积的性质。不涉及角度，也不需要物理单位。\n\n测试套件：\n使用 $N=4$ 和由此产生的 $N+1=5$ 个节点。对以下节点向量 $v$（每个长度为 $5$）评估离散能量范数，其中 $x$ 表示按升序排列的节点位置：\n1. $v^{(1)}=\\mathbf{1}$ (在节点上采样的常数函数)。\n2. $v^{(2)}=x$ (在节点上采样的线性函数)。\n3. $v^{(3)}=x^2$ (在节点上采样的二次函数)。\n4. $v^{(4)}=P_4(x)$ (在节点上求值的4阶勒让德多项式)。\n5. $v^{(5)}=[\\,0.1,\\,-0.5,\\,0.3,\\,-0.1,\\,0.7\\,]$ (一个自定义向量，并非由单一多项式导出)。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是对应测试用例 $v^{(i)}$ 计算出的离散能量范数，形式为浮点数。",
            "solution": "该问题要求使用谱伽辽金方法在参考区间 $[-1, 1]$ 上为几个节点向量计算离散能量范数。该方法由多项式阶数 $N=4$、在高斯-洛巴托-勒让德 (GLL) 节点上的拉格朗日基，以及基于求积的质量矩阵和刚度矩阵的组装来定义。\n\n解决方案分四个阶段进行：\n1.  计算高斯-洛巴托-勒让德节点和求积权重。\n2.  构建节点微分矩阵。\n3.  组装离散质量矩阵和刚度矩阵。\n4.  为指定的测试向量计算离散能量范数。\n\n### 1. 高斯-洛巴托-勒让德 (GLL) 节点和权重\n\n对于多项式阶数 $N$，$N+1$ 个 GLL 节点（记为 $x_j$，其中 $j=0, \\dots, N$）是多项式 $(1-x^2)P_N'(x)$ 的根，其中 $P_N(x)$ 是 $N$ 阶勒让德多项式。该节点集包括端点 $x_0 = -1$ 和 $x_{N} = 1$。内部节点是 $P_N'(x) = 0$ 的根。\n\n对于 $N=4$，我们需要勒让德多项式 $P_4(x)$ 及其导数。勒让德多项式可以通过递推关系 $(n+1)P_{n+1}(x) = (2n+1)xP_n(x) - nP_{n-1}(x)$ 生成，其中 $P_0(x)=1$ 和 $P_1(x)=x$。对于 $N=4$，这得到：\n$$P_4(x) = \\frac{1}{8}(35x^4 - 30x^2 + 3)$$\n其导数为：\n$$P_4'(x) = \\frac{1}{8}(140x^3 - 60x) = \\frac{5}{2}x(7x^2 - 3)$$\n$P_4'(x)=0$ 的根是 $x=0$ 和 $x=\\pm\\sqrt{3/7}$。包括端点在内，$N=4$ 的五个 GLL 节点按升序排列为：\n$$x = \\{x_0, x_1, x_2, x_3, x_4\\} = \\left\\{-1, -\\sqrt{\\frac{3}{7}}, 0, \\sqrt{\\frac{3}{7}}, 1\\right\\}$$\n其数值近似为 $\\{-1, -0.65465, 0, 0.65465, 1\\}$。\n\n相应的 GLL 求积权重 $w_j$ 由以下公式给出：\n$$w_j = \\frac{2}{N(N+1)[P_N(x_j)]^2}$$\n对于 $N=4$，我们有 $N(N+1)=20$。我们在每个节点 $x_j$ 处计算 $P_4(x)$ 的值：\n-   $P_4(\\pm 1) = 1$\n-   $P_4(\\pm\\sqrt{3/7}) = \\frac{1}{8}(35(\\frac{3}{7})^2 - 30(\\frac{3}{7}) + 3) = -3/7$\n-   $P_4(0) = 3/8$\n\n将这些值代入权重公式：\n-   $w_0 = w_4 = \\frac{2}{20 \\cdot 1^2} = \\frac{1}{10}$\n-   $w_1 = w_3 = \\frac{2}{20 \\cdot (-3/7)^2} = \\frac{2}{20 \\cdot 9/49} = \\frac{49}{90}$\n-   $w_2 = \\frac{2}{20 \\cdot (3/8)^2} = \\frac{2}{20 \\cdot 9/64} = \\frac{32}{45}$\n\n这些权重的总和是 $\\frac{1}{10} + \\frac{49}{90} + \\frac{32}{45} + \\frac{49}{90} + \\frac{1}{10} = \\frac{9+49+64+49+9}{90} = \\frac{180}{90}=2$，这正确地等于 $\\int_{-1}^{1} 1 \\, dx$。\n\n### 2. 节点微分矩阵\n\n该问题采用拉格朗日节点基 $\\{\\ell_j(x)\\}_{j=0}^N$，其中 $\\ell_j(x)$ 是唯一的 $N$ 阶多项式，满足 $\\ell_j(x_k) = \\delta_{jk}$。节点值 $v_j$ 的任意多项式插值函数 $v_N(x)$ 由 $v_N(x) = \\sum_{j=0}^N v_j \\ell_j(x)$ 给出。\n$(N+1) \\times (N+1)$ 微分矩阵 $D$ 的元素定义为 $D_{ij} = \\ell_j'(x_i)$。该矩阵将节点函数值的向量映射到节点导数值的向量：$(v_N')_{i} = \\sum_{j=0}^{N} D_{ij} v_j$。\n\n对于 GLL 节点，$D$ 的元素可以使用以下标准公式高效计算：\n$$D_{ij} = \\frac{P_N(x_i)}{P_N(x_j)(x_i - x_j)} \\quad \\text{for } i \\neq j$$\n$$D_{ii} = 0 \\quad \\text{for } i=1, \\dots, N-1$$\n$$D_{00} = -\\frac{N(N+1)}{4} \\quad \\text{and} \\quad D_{NN} = \\frac{N(N+1)}{4}$$\n对于 $N=4$，$D_{00} = -5$ 且 $D_{44} = 5$，而 $D_{11}=D_{22}=D_{33}=0$。非对角线元素使用节点位置和上面导出的 $P_4(x_j)$ 值计算。\n\n### 3. 质量矩阵和刚度矩阵\n\n在谱伽辽金方法中，质量矩阵 $M$ 和刚度矩阵 $K$ 的元素由积分给出：\n$$M_{ij} = \\int_{-1}^{1} \\ell_i(x)\\ell_j(x)\\,dx, \\quad K_{ij} = \\int_{-1}^{1} \\ell_i'(x)\\ell_j'(x)\\,dx$$\n这些积分使用 GLL 求积法则 $\\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{k=0}^{N} f(x_k)w_k$ 进行数值计算。\n\n对于质量矩阵，这得到：\n$$M_{ij} \\approx \\sum_{k=0}^N \\ell_i(x_k)\\ell_j(x_k) w_k = \\sum_{k=0}^N \\delta_{ik}\\delta_{jk} w_k = \\delta_{ij} w_i$$\n这产生了一个对角或“集总”质量矩阵 $M = \\text{diag}(w_0, w_1, \\dots, w_N)$。对于 $M_{ij}$，GLL 求积是一个近似，因为被积函数 $\\ell_i(x)\\ell_j(x)$ 是一个最高达 $2N=8$ 阶的多项式，而该求积法则仅对最高 $2N-1=7$ 阶的多项式是精确的。\n\n对于刚度矩阵，求积给出：\n$$K_{ij} = \\int_{-1}^{1} \\ell_i'(x)\\ell_j'(x)\\,dx \\approx \\sum_{k=0}^N \\ell_i'(x_k)\\ell_j'(x_k) w_k$$\n被积函数 $\\ell_i'(x)\\ell_j'(x)$ 是一个最高达 $2(N-1)=6$ 阶的多项式。由于 $6 \\leq 2N-1=7$，GLL 求积是精确的。使用微分矩阵的定义 $\\ell_j'(x_k) = D_{kj}$，刚度矩阵的元素为：\n$$K_{ij} = \\sum_{k=0}^N D_{ki} D_{kj} w_k$$\n以矩阵形式，这可以紧凑地表示为 $K = D^T M D$。\n\n### 4. 离散能量范数计算\n\n节点向量 $v$ 的离散能量范数为 $\\|v\\|_K = \\sqrt{v^T K v}$。使用 $K$ 的矩阵公式，这变为：\n$$\\|v\\|_K = \\sqrt{v^T (D^T M D) v} = \\sqrt{(Dv)^T M (Dv)}$$\n令 $v' = Dv$ 为节点上的导数值向量。范数的平方变为 $(v')^T M v' = \\sum_{k=0}^N (v'_k)^2 w_k$。这是连续能量范数分部积分形式 $\\int_{-1}^{1} (v_N'(x))^2 dx$ 的 GLL 求积近似。\n\n对于指定的测试向量，我们计算这个范数。\n1.  $v^{(1)}$ 代表 $f(x)=1$。其精确导数为 $0$。$D v^{(1)}$ 将是一个零向量（在机器精度范围内），因此 $\\|v^{(1)}\\|_K = 0$。\n2.  $v^{(2)}$ 代表 $f(x)=x$。其精确导数为 $1$。$D v^{(2)}$ 将是一个全为1的向量。对于被积函数 $(1)^2=1$，求积是精确的。因此，$\\|v^{(2)}\\|_K^2 = \\int_{-1}^1 1^2 dx = 2$，所以 $\\|v^{(2)}\\|_K = \\sqrt{2}$。\n3.  $v^{(3)}$ 代表 $f(x)=x^2$。其精确导数为 $2x$。对于被积函数 $(2x)^2=4x^2$，求积是精确的。因此，$\\|v^{(3)}\\|_K^2 = \\int_{-1}^1 4x^2 dx = 4[x^3/3]_{-1}^1 = 8/3$，所以 $\\|v^{(3)}\\|_K = \\sqrt{8/3}$。\n4.  $v^{(4)}$ 代表 $f(x)=P_4(x)$。其导数为 $P_4'(x)$。对于 $(P_4'(x))^2$（一个6阶多项式），求积是精确的。因此，$\\|v^{(4)}\\|_K^2 = \\int_{-1}^1 (P_4'(x))^2 dx = 20$，所以 $\\|v^{(4)}\\|_K = \\sqrt{20}$。\n5.  $v^{(5)}$ 是一个通用向量，其范数需要数值计算，没有简单的先验解析值。\n\n实现将遵循这些步骤来构建矩阵并计算范数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre\n\ndef solve():\n    \"\"\"\n    Computes the discrete energy norm ||v||_K for a spectral Galerkin method\n    with N=4 on Gauss-Lobatto-Legendre nodes.\n    \"\"\"\n    N = 4\n    N_plus_1 = N + 1\n\n    # Step 1: Compute Gauss-Lobatto-Legendre nodes and weights for N=4\n    \n    # The interior GLL nodes are the roots of the derivative of the N-th Legendre polynomial, P_N'(x).\n    # We use scipy.special.legendre to get the polynomial P_N(x)\n    # and its derivative to find the roots robustly.\n    P_N = legendre(N)\n    P_N_prime = P_N.deriv()\n    \n    # Find the roots of P_N'(x) to get the interior nodes.\n    interior_nodes = np.roots(P_N_prime)\n    \n    # Combine with endpoints and sort to get all GLL nodes.\n    nodes = np.concatenate(([-1.0], np.sort(interior_nodes), [1.0]))\n\n    # The GLL quadrature weights are given by w_j = 2 / (N*(N+1)*[P_N(x_j)]^2)\n    P_N_at_nodes = P_N(nodes)\n    weights = 2.0 / (N * N_plus_1 * P_N_at_nodes**2)\n\n    # Step 2: Construct the Lagrange nodal differentiation matrix D\n    D = np.zeros((N_plus_1, N_plus_1))\n    \n    # Off-diagonal entries\n    for i in range(N_plus_1):\n        for j in range(N_plus_1):\n            if i != j:\n                D[i, j] = P_N_at_nodes[i] / (P_N_at_nodes[j] * (nodes[i] - nodes[j]))\n\n    # Diagonal entries\n    D[0, 0] = -N * N_plus_1 / 4.0\n    D[N, N] = N * N_plus_1 / 4.0\n    # Interior diagonal entries are already 0 from initialization.\n\n    # Step 3: Assemble Mass M and Stiffness K matrices\n    # The mass matrix M is the lumped mass matrix, diagonal with quadrature weights.\n    M = np.diag(weights)\n    \n    # The stiffness matrix K is assembled using GLL quadrature, which is exact.\n    # K = D^T * M * D\n    K = D.T @ M @ D\n\n    # Step 4: Define test vectors and compute discrete energy norm\n    test_cases = [\n        # Case 1: v^(1) = 1 (constant function)\n        np.ones(N_plus_1),\n        # Case 2: v^(2) = x (linear function)\n        nodes,\n        # Case 3: v^(3) = x^2 (quadratic function)\n        nodes**2,\n        # Case 4: v^(4) = P_4(x) (Legendre polynomial of degree 4)\n        P_N_at_nodes,\n        # Case 5: v^(5) (custom vector)\n        np.array([0.1, -0.5, 0.3, -0.1, 0.7]),\n    ]\n\n    results = []\n    for v in test_cases:\n        # The discrete energy norm is sqrt(v^T * K * v)\n        # Add a small epsilon for cases where the result is zero to avoid sqrt(-ve) from precision errors.\n        energy_norm_sq = v.T @ K @ v\n        if abs(energy_norm_sq)  1e-15:\n            energy_norm_sq = 0.0\n        energy_norm = np.sqrt(energy_norm_sq)\n        results.append(energy_norm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本矩阵的构建后，本练习将应用谱元法来求解一个完整的边值问题。您将探索“精确性”这一概念，这是谱方法的一个显著特征，即在特定条件下，数值解可以与解析解完全吻合。本练习通过将抽象的弱形式与具体的、可验证的解联系起来，展示了谱方法的强大功能和高精度。",
            "id": "3418627",
            "problem": "考虑区间 $[-1,1]$ 上的一维泊松问题：求 $u$ 使得在 $(-1,1)$ 内有 $-u''=1$，并满足齐次狄利克雷边界条件 $u(-1)=0$ 和 $u(1)=0$。使用谱伽辽金框架，从弱形式出发，构建一个包含两个等长单元 $[-1,0]$ 和 $[0,1]$ 的协调谱元离散。在每个单元上，使用由勒让德-高斯-洛巴托 (LGL) 节点上的拉格朗日基函数张成的 $N=3$ 次多项式逼近空间，其中LGL节点为单元端点以及参考单元上 $N$ 次勒让德多项式导数的零点所给出的内部节点。使用从参考单元 $[-1,1]$ 到每个物理单元的标准仿射等参映射，并使用与节点集同阶的LGL求积法计算所有单元积分。\n\n根据弱形式和伽辽金原理，解释在此情况下为何离散谱元解与精确解一致。然后，使用 $N=3$ 时LGL节点的明确位置，将这些节点映射到两个单元的物理坐标上，组装 $[-1,1]$ 区间上所有不同的高斯-洛巴托点的全局集合，并计算离散解在这些点上的节点值。将节点解值按物理坐标从 $x=-1$ 到 $x=1$ 递增的顺序列为一个行矩阵。不允许四舍五入；请提供精确值。",
            "solution": "该问题要求解释为何特定一维泊松问题的谱元解是精确的，并计算该解的节点值。\n\n首先，我们验证问题陈述的有效性。该问题定义了一个标准的一维泊松方程 $-u''=1$ 在区间 $[-1,1]$ 上，并带有齐次狄利克雷边界条件 $u(-1)=0$ 和 $u(1)=0$。它指定了一个协调谱元法，包含两个单元，多项式次数为 $N=3$，在勒让德-高斯-洛巴托 (LGL) 节点上使用拉格朗日基函数，并采用LGL求积法进行积分计算。所有组成部分在谱方法理论中都有明确定义。该问题具有科学依据，是适定的、客观的、自洽的和一致的。这是一个有效的问题。\n\n我们首先求解边值问题的精确解析解。将方程 $-u''=1$ 对 $x$ 积分两次，得到：\n$u'(x) = -x + C_1$\n$u(x) = -\\frac{1}{2}x^2 + C_1 x + C_2$\n积分常数 $C_1$ 和 $C_2$ 由边界条件确定：\n$u(-1) = -\\frac{1}{2} - C_1 + C_2 = 0$\n$u(1) = -\\frac{1}{2} + C_1 + C_2 = 0$\n将这两个方程相加，得到 $-1 + 2C_2 = 0$，这意味着 $C_2 = \\frac{1}{2}$。用第二个方程减去第一个方程，得到 $2C_1 = 0$，这意味着 $C_1 = 0$。因此，精确解为：\n$$u(x) = \\frac{1}{2}(1-x^2)$$\n该精确解是一个2次多项式。\n\n接下来，我们建立弱形式。设解空间为 $V = H_0^1(-1,1) = \\{v \\in H^1(-1,1) | v(-1)=v(1)=0\\}$。我们将偏微分方程乘以一个测试函数 $v \\in V$，并在定义域 $[-1,1]$ 上积分：\n$$-\\int_{-1}^{1} u''(x)v(x) dx = \\int_{-1}^{1} 1 \\cdot v(x) dx$$\n对左侧应用分部积分，并利用 $v(-1)=v(1)=0$：\n$$\\int_{-1}^{1} u'(x)v'(x) dx - [u'(x)v(x)]_{-1}^{1} = \\int_{-1}^{1} v(x) dx$$\n$$\\int_{-1}^{1} u'(x)v'(x) dx = \\int_{-1}^{1} v(x) dx$$\n弱形式是：求 $u \\in V$ 使得对所有 $v \\in V$ 都有 $a(u,v) = f(v)$，其中双线性形式 $a(u,v)$ 和线性泛函 $f(v)$ 为：\n$$a(u,v) = \\int_{-1}^{1} u'(x)v'(x) dx \\quad \\text{和} \\quad f(v) = \\int_{-1}^{1} v(x) dx$$\n在谱元法中，我们定义一个有限维逼近空间 $V_N \\subset V$。定义域 $[-1,1]$ 被划分为两个单元，$\\Omega_1 = [-1,0]$ 和 $\\Omega_2 = [0,1]$。逼近空间定义为：\n$$V_N = \\{v_N \\in C^0([-1,1]) \\cap V \\mid v_N|_{\\Omega_e} \\in \\mathbb{P}_N(\\Omega_e) \\text{ for } e=1,2\\}$$\n其中 $\\mathbb{P}_N$ 是次数至多为 $N$ 的多项式空间。在本问题中，$N=3$。伽辽金问题是：求一个离散解 $u_N \\in V_N$ 使得：\n$$a(u_N, v_N) = f(v_N) \\quad \\text{对所有 } v_N \\in V_N$$\n问题陈述中说明，所有积分都使用基于 $N=3$ LGL节点集的LGL求积法计算。这引入了数值积分，导致了一个离散系统 $a_N(u_N, v_N) = f_N(v_N)$，其中 $a_N$ 和 $f_N$ 表示将其中的积分替换为求积和的形式。一个具有 $N+1$ 个点（$N$ 次）的LGL求积法则对次数最高为 $2N-1$ 的多项式是精确的。对于 $N=3$，该求积法对次数最高为 $2(3)-1=5$ 的多项式是精确的。\n\n离散谱元解与精确解一致有两个关键原因：\n1. 精确解 $u(x) = \\frac{1}{2}(1-x^2)$ 是一个2次多项式。对于 $N=3$ 的逼近空间 $V_N$ 由次数最高为3的连续分片多项式组成。由于全局精确解是一个2次单项式，它自然是该空间的成员，即 $u(x) \\in V_N$。\n2. 所使用的数值求积对于涉及的积分是精确的。对于任何测试函数 $v_N \\in V_N$，$v_N$ 是一个次数最高为3的分片多项式。\n   - 双线性形式 $a(u,v_N)$ 中的被积函数是 $u'(x)v'_N(x)$。由于 $u(x)$ 是2次的，其导数 $u'(x)=-x$ 是1次的。由于 $v_N(x)$ 在每个单元上是3次的，其导数 $v'_N(x)$ 是2次的。乘积 $u'(x)v'_N(x)$ 在每个单元上是次数为 $1+2=3$ 的多项式。\n   - 线性泛函 $f(v_N)$ 中的被积函数是 $1 \\cdot v_N(x)$，它在每个单元上是次数为3的多项式。\n由于两个被积函数都是3次多项式，且 $3 \\le 5$，$N=3$ 的LGL求积能精确计算这些积分。因此，对于所有 $v_N \\in V_N$，有 $a_N(u, v_N) = a(u, v_N)$ 和 $f_N(v_N) = f(v_N)$。\n精确解 $u$ 满足对所有 $v \\in V$ 都有 $a(u,v) = f(v)$，因此也对所有 $v_N \\in V_N$ 成立。由于求积是精确的，可得 $a_N(u, v_N) = f_N(v_N)$。这意味着精确解 $u$ 满足离散方程组。由于该问题的离散系统有唯一解，计算出的离散解 $u_N$ 必须与精确解 $u$ 完全相同。\n\n现在我们计算节点值。首先，我们求参考单元 $\\hat{\\Omega}=[-1,1]$ 上 $N=3$ 的LGL节点。内部节点是勒让德多项式 $P_3(\\xi) = \\frac{1}{2}(5\\xi^3 - 3\\xi)$ 导数的零点。其导数为 $P'_3(\\xi) = \\frac{3}{2}(5\\xi^2 - 1)$。零点由 $5\\xi^2 - 1 = 0$ 给出，所以 $\\xi = \\pm 1/\\sqrt{5}$。包括端点在内，LGL节点为：\n$$\\xi_0 = -1, \\quad \\xi_1 = -\\frac{1}{\\sqrt{5}}, \\quad \\xi_2 = \\frac{1}{\\sqrt{5}}, \\quad \\xi_3 = 1$$\n接下来，我们将这些节点映射到物理单元 $\\Omega_1 = [-1,0]$ 和 $\\Omega_2 = [0,1]$。\n对于 $\\Omega_1 = [-1,0]$，映射为 $x(\\xi) = \\frac{\\xi-1}{2}$。节点为：\n$x_0^1 = -1$，$x_1^1 = \\frac{-1/\\sqrt{5}-1}{2} = -\\frac{1}{2}(1+\\frac{1}{\\sqrt{5}})$，$x_2^1 = \\frac{1/\\sqrt{5}-1}{2} = -\\frac{1}{2}(1-\\frac{1}{\\sqrt{5}})$，$x_3^1 = 0$。\n对于 $\\Omega_2 = [0,1]$，映射为 $x(\\xi) = \\frac{\\xi+1}{2}$。节点为：\n$x_0^2 = 0$，$x_1^2 = \\frac{-1/\\sqrt{5}+1}{2} = \\frac{1}{2}(1-\\frac{1}{\\sqrt{5}})$，$x_2^2 = \\frac{1/\\sqrt{5}+1}{2} = \\frac{1}{2}(1+\\frac{1}{\\sqrt{5}})$，$x_3^2 = 1$。\n从 $x=-1$ 到 $x=1$ 排序的全局不同节点集合为：\n$$X_0 = -1$$\n$$X_1 = -\\frac{1}{2}(1+\\frac{1}{\\sqrt{5}})$$\n$$X_2 = -\\frac{1}{2}(1-\\frac{1}{\\sqrt{5}})$$\n$$X_3 = 0$$\n$$X_4 = \\frac{1}{2}(1-\\frac{1}{\\sqrt{5}})$$\n$$X_5 = \\frac{1}{2}(1+\\frac{1}{\\sqrt{5}})$$\n$$X_6 = 1$$\n由于离散解 $u_N$ 与精确解 $u(x)=\\frac{1}{2}(1-x^2)$ 完全相同，节点值可以通过在这些全局节点位置上计算 $u(x)$ 来得到。\n$u(X_0) = u(-1) = \\frac{1}{2}(1 - (-1)^2) = 0$。\n$u(X_1) = u(-\\frac{1}{2}(1+\\frac{1}{\\sqrt{5}})) = \\frac{1}{2}\\left(1 - \\frac{1}{4}(1+\\frac{1}{\\sqrt{5}})^2\\right) = \\frac{1}{2}\\left(1 - \\frac{1}{4}(1+\\frac{2}{\\sqrt{5}}+\\frac{1}{5})\\right) = \\frac{1}{2}\\left(1 - \\frac{1}{4}(\\frac{6}{5}+\\frac{2}{\\sqrt{5}})\\right) = \\frac{1}{2}\\left(1 - \\frac{3}{10} - \\frac{1}{2\\sqrt{5}}\\right) = \\frac{1}{2}(\\frac{7}{10} - \\frac{\\sqrt{5}}{10}) = \\frac{7-\\sqrt{5}}{20}$。\n$u(X_2) = u(-\\frac{1}{2}(1-\\frac{1}{\\sqrt{5}})) = \\frac{1}{2}\\left(1 - \\frac{1}{4}(1-\\frac{1}{\\sqrt{5}})^2\\right) = \\frac{1}{2}\\left(1 - \\frac{1}{4}(1-\\frac{2}{\\sqrt{5}}+\\frac{1}{5})\\right) = \\frac{1}{2}\\left(1 - \\frac{1}{4}(\\frac{6}{5}-\\frac{2}{\\sqrt{5}})\\right) = \\frac{1}{2}\\left(1 - \\frac{3}{10} + \\frac{1}{2\\sqrt{5}}\\right) = \\frac{1}{2}(\\frac{7}{10} + \\frac{\\sqrt{5}}{10}) = \\frac{7+\\sqrt{5}}{20}$。\n$u(X_3) = u(0) = \\frac{1}{2}(1 - 0^2) = \\frac{1}{2}$。\n由于精确解的对称性 $u(x)=u(-x)$ 和节点的对称分布，我们有：\n$u(X_4) = u(-X_2) = u(X_2) = \\frac{7+\\sqrt{5}}{20}$。\n$u(X_5) = u(-X_1) = u(X_1) = \\frac{7-\\sqrt{5}}{20}$。\n$u(X_6) = u(1) = \\frac{1}{2}(1 - 1^2) = 0$。\n按坐标递增顺序排列的节点解值为：\n$\\{0, \\frac{7-\\sqrt{5}}{20}, \\frac{7+\\sqrt{5}}{20}, \\frac{1}{2}, \\frac{7+\\sqrt{5}}{20}, \\frac{7-\\sqrt{5}}{20}, 0\\}$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 0  \\frac{7-\\sqrt{5}}{20}  \\frac{7+\\sqrt{5}}{20}  \\frac{1}{2}  \\frac{7+\\sqrt{5}}{20}  \\frac{7-\\sqrt{5}}{20}  0 \\end{pmatrix}}$$"
        },
        {
            "introduction": "现实世界的问题通常是非线性的，这带来了线性系统中不存在的挑战。本练习以伯格斯方程为模型，解决了混叠（aliasing）这一关键问题，这是一种因非线性项的离散表示而产生的误差。通过实现和比较不同的求积策略，您将亲眼看到混叠如何污染解，以及如何使用“3/2规则”等技术来消除它，从而确保模拟的准确性。",
            "id": "3418551",
            "problem": "实现一个完整的程序，为一维粘性伯格斯方程 $u_t + \\frac{1}{2}(u^2)_x = \\nu u_{xx}$ 在区间 $[-1,1]$ 上构建一个勒让德-伽辽金右端项投影。其中，通过选择 $u(x)$ 的形式为 $u(x)=(1-x^2)p(x)$（其中 $p(x)$ 是一个多项式）来施加齐次狄利克雷边界条件，以使得 $u(-1)=u(1)=0$。未知函数 $u(x)$ 是一个多项式，检验函数是勒让德多项式 $\\{P_j(x)\\}_{j=0}^N$。对非线性项使用分部积分弱形式以避免对 $u^2$ 求导，也即，将非线性项和粘性项投影到勒让德基上：\n$$\nr_j = -\\frac{1}{2}\\int_{-1}^1 u(x)^2 P_j'(x)\\, dx + \\nu \\int_{-1}^1 u_{xx}(x) P_j(x)\\, dx,\\quad j=0,1,\\dots,N,\n$$\n其中 $P_j'(x)$ 表示第 $j$ 个勒让德多项式的导数。分部积分公式中的边界项因 $u(\\pm 1)=0$ 而为零。\n\n您的程序必须通过三种方式计算系数向量 $\\{r_j\\}_{j=0}^N$：\n- 使用具有 $Q=3N$ 个节点的勒让德-高斯求积，得到一个基本精确的参考值。该方法对于最高 $2Q-1 \\ge 3N-1$ 次的多项式是精确的，与弱形式中当 $u$ 的次数最高为 $N$ 时被积函数的最高次数相匹配。\n- 使用具有 $N+1$ 个节点的标准勒让德-高斯-洛巴托 (GLL) 求积，该方法对最高 $2N-1$ 次的多项式是精确的。这可能会对最高次数达 $3N-1$ 的非线性被积函数造成欠积分，从而产生混叠。\n- 使用具有 $M+1$ 个节点的 $3/2$ 规则去混叠GLL求积，其中 $M=\\lceil \\frac{3N}{2}\\rceil$。该方法对最高 $2M-1 \\ge 3N-1$ 次的多项式是精确的，从而消除了分部积分公式中的非线性混叠。\n\n通过将非线性被积函数 $R_j(x)=u(x)^2 P_j'(x)$ 表示为其勒让德级数 $R_j(x)=\\sum_{k=0}^{3N-1} c_k^{(j)} P_k(x)$，并利用GLL求积对次数 $\\le 2N-1$ 是精确的这一性质，来解析地估计标准GLL求积下的残余混叠误差。证明非线性投影的求积误差满足\n$$\nE_j = \\left|\\sum_{i=0}^N w_i R_j(x_i) - \\int_{-1}^1 R_j(x)\\, dx\\right| = \\left|\\sum_{k=2N}^{3N-1} c_k^{(j)}\\delta_k^{(N)}\\right|,\n$$\n其中 $(x_i, w_i)$ 是GLL节点和权重，$\\delta_k^{(N)}=\\sum_{i=0}^N w_i P_k(x_i)$ 是求积混叠权重，且当 $k \\le 2N-1$ 时 $\\delta_k^{(N)}=0$。通过使用已知的勒让德-高斯-洛巴托求积中 $\\delta_k^{(N)}$ 的界以及在 $x\\in[-1,1]$ 上 $|P_k(x)| \\le 1$ 的事实，推导出以下形式的界：\n$$\n|E_j| \\le \\frac{C}{N^2}\\sum_{k=2N}^{3N-1} \\left|c_k^{(j)}\\right|,\n$$\n其中 $C$ 是一个与 $N$ 无关的常数。由此得出结论：对于具有有界模态内容的多项式 $u$，GLL下的残余混叠关于 $j \\le N$ 一致地服从渐进行为 $|E_j|=\\mathcal{O}(N^{-1})$，而 $3/2$ 规则在弱形式下产生零混叠。\n\n算法要求：\n- 在单项式基中表示 $p(x)$，并定义 $u(x)=(1-x^2)p(x)$ 以施加 $u(\\pm 1)=0$。\n- 通过对单项式多项式系数求导两次来精确计算 $u_{xx}(x)$。\n- 使用勒让德多项式计算 $P_j(x)$，并使用精确的端点值 $P_j'(\\pm 1)=\\pm\\frac{j(j+1)}{2}$ 和恒等式 $P_j'(x)=\\frac{j}{1-x^2}(P_{j-1}(x)-xP_j(x))$（对于内部点，该式在代数上等价于一个 $j-1$ 次多项式）来计算 $P_j'(x)$。\n- 实现具有 $Q=3N$ 个节点的勒让德-高斯求积，以及对于 $K=N$ 和 $K=M=\\lceil \\frac{3N}{2}\\rceil$ 两种情况、具有 $K+1$ 个节点的勒让德-高斯-洛巴托求积。\n\n对于每个测试用例，计算残余混叠范数：\n$$\n\\|E^{\\mathrm{GLL}}\\|_2 = \\left(\\sum_{j=0}^N \\left[r_j^{\\mathrm{GLL},N} - r_j^{\\mathrm{exact}}\\right]^2\\right)^{1/2},\\quad\n\\|E^{3/2}\\|_2 = \\left(\\sum_{j=0}^N \\left[r_j^{\\mathrm{GLL},M} - r_j^{\\mathrm{exact}}\\right]^2\\right)^{1/2}.\n$$\n\n使用以下测试套件，其中 $N$ 是 $u(x)$ 的最高多项式次数，$\\deg(p)$ 是 $p(x)$ 的次数，$\\mathrm{seed}$ 初始化 $p(x)$ 的随机系数生成器，$\\nu$ 是粘度。在所有情况下，取 $p(x)=\\sum_{k=0}^{\\deg(p)} c_k x^k$，其系数 $c_k$ 使用给定的种子从 $[-\\frac{1}{2}, \\frac{1}{2}]$ 中均匀抽取。角度单位不适用。此处没有物理单位。\n\n测试套件参数：\n- 用例 1: $N=8$, $\\deg(p)=6$, $\\mathrm{seed}=1$, $\\nu=0.1$。\n- 用例 2: $N=2$, $\\deg(p)=0$, $\\mathrm{seed}=2$, $\\nu=1.0$。\n- 用例 3: $N=16$, $\\deg(p)=14$, $\\mathrm{seed}=3$, $\\nu=0.0$。\n- 用例 4: $N=24$, $\\deg(p)=22$, $\\mathrm{seed}=4$, $\\nu=0.01$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，值按以下顺序排列：\n$[\\|E^{\\mathrm{GLL}}\\|_2^{(1)},\\|E^{3/2}\\|_2^{(1)},\\|E^{\\mathrm{GLL}}\\|_2^{(2)},\\|E^{3/2}\\|_2^{(2)},\\|E^{\\mathrm{GLL}}\\|_2^{(3)},\\|E^{3/2}\\|_2^{(3)},\\|E^{\\mathrm{GLL}}\\|_2^{(4)},\\|E^{3/2}\\|_2^{(4)}]$，其中上标表示测试用例编号。每个条目必须是浮点数。",
            "solution": "用户希望分析粘性伯格斯方程的谱伽辽金投影中的混叠误差。我将首先执行所要求的解析推导，然后描述数值实现。\n\n问题的核心是计算来自粘性伯格斯方程 $u_t + \\frac{1}{2}(u^2)_x = \\nu u_{xx}$ 的空间算子在勒让德多项式基上的投影。试验函数 $u(x)$ 是在区间 $x \\in [-1, 1]$ 上的一个最高次数为 $N$ 的多项式，满足齐次狄利克雷边界条件 $u(\\pm 1) = 0$。这是通过将 $u(x)$ 表示为 $u(x)=(1-x^2)p(x)$ 来施加的，其中 $p(x)$ 是一个 $N-2$ 次的多项式。检验函数是勒让德多项式 $\\{P_j(x)\\}_{j=0}^N$。\n\n投影后的右端项向量 $\\{r_j\\}_{j=0}^N$ 的弱形式由下式给出：\n$$\nr_j = \\int_{-1}^1 \\left( -\\frac{1}{2}\\frac{\\partial}{\\partial x}(u^2) + \\nu u_{xx} \\right) P_j(x) \\, dx\n$$\n对非线性项使用分部积分，并注意到边界项因 $u(\\pm 1)=0$ 而为零，我们得到指定的弱形式：\n$$\nr_j = -\\frac{1}{2}\\int_{-1}^1 u(x)^2 P_j'(x)\\, dx + \\nu \\int_{-1}^1 u_{xx}(x) P_j(x)\\, dx\n$$\n其中 $P_j'(x)$ 是第j个勒让德多项式的导数。我们来分析被积函数的多项式次数。由于 $\\deg(u) \\le N$，我们有 $\\deg(u^2) \\le 2N$。$P_j'(x)$ 的次数是 $j-1$，所以对于 $j \\le N$，$\\deg(P_j') \\le N-1$。因此，非线性项的被积函数 $u(x)^2 P_j'(x)$ 的最高次数为 $2N + (N-1) = 3N-1$。粘性项的被积函数 $u_{xx}(x) P_j(x)$ 的次数最高为 $(N-2) + N = 2N-2$。因此，需要积分的最高次多项式是 $3N-1$。\n\n问题要求比较三种求积方法对这些积分的计算：\n1.  一个使用 $Q=3N$ 个节点的“精确”勒让德-高斯 (LG) 求积，它对最高 $2Q-1 = 6N-1$ 次的多项式是精确的。这足以精确积分最高 $3N-1$ 次的多项式。\n2.  一个使用 $N+1$ 个节点的标准勒让德-高斯-洛巴托 (GLL) 求积，它对最高 $2(N+1)-3 = 2N-1$ 次的多项式是精确的。这对粘性项足够，但对非线性项不足，从而导致混叠误差。\n3.  一个使用 $M+1$ 个节点的 $3/2$ 规则去混叠 GLL 求积，其中 $M=\\lceil 3N/2 \\rceil$。它对最高 $2(M+1)-3 = 2M-1$ 次的多项式是精确的。由于 $M \\ge 3N/2$，我们有 $2M \\ge 3N$，所以 $2M-1 \\ge 3N-1$。这个求积规则对两项都是精确的，因此它是“去混叠的”。\n\n### 混叠误差的解析估计\n\n我们关注由标准 $(N+1)$ 点 GLL 求积计算的非线性项投影中的混叠误差。第 $j$ 个分量的误差为：\n$$\nE_j = \\left| \\sum_{i=0}^N w_i R_j(x_i) - \\int_{-1}^1 R_j(x) dx \\right|\n$$\n其中 $(x_i, w_i)$ 是 GLL 节点和权重，而 $R_j(x) = -\\frac{1}{2} u(x)^2 P_j'(x)$。\n\n我们将被积函数 $R_j(x)$ 展开为勒让德级数。由于其次数最高为 $3N-1$，这是一个有限和：\n$$\nR_j(x) = \\sum_{k=0}^{3N-1} c_k^{(j)} P_k(x)\n$$\n由于勒让德多项式是正交的，精确积分由 $k=0$ 的系数给出：\n$$\n\\int_{-1}^1 R_j(x) dx = c_0^{(j)} \\int_{-1}^1 P_0(x) dx = 2c_0^{(j)}\n$$\nGLL 求积和为：\n$$\n\\sum_{i=0}^N w_i R_j(x_i) = \\sum_{i=0}^N w_i \\left( \\sum_{k=0}^{3N-1} c_k^{(j)} P_k(x_i) \\right) = \\sum_{k=0}^{3N-1} c_k^{(j)} \\left(\\sum_{i=0}^N w_i P_k(x_i)\\right)\n$$\n令 $\\delta_k^{(N)} = \\sum_{i=0}^N w_i P_k(x_i)$ 为混叠权重。具有 $N+1$ 个节点的 GLL 求积对于任何次数不超过 $2N-1$ 的多项式都是精确的。这意味着对于任何这样的多项式 $\\phi(x)$，$\\sum w_i \\phi(x_i) = \\int \\phi(x) dx$。将此应用于 $\\phi(x) = P_k(x)$ 且 $k \\le 2N-1$：\n$$\n\\delta_k^{(N)} = \\int_{-1}^1 P_k(x) dx = 2\\delta_{k0} \\quad \\text{对于 } k \\le 2N-1\n$$\n其中 $\\delta_{k0}$ 是克罗内克δ符号。\n求积和变为：\n$$\n\\sum_{i=0}^N w_i R_j(x_i) = c_0^{(j)} \\delta_0^{(N)} + \\sum_{k=1}^{2N-1} c_k^{(j)} \\delta_k^{(N)} + \\sum_{k=2N}^{3N-1} c_k^{(j)} \\delta_k^{(N)} = 2c_0^{(j)} + \\sum_{k=2N}^{3N-1} c_k^{(j)} \\delta_k^{(N)}\n$$\n求积误差 $E_j$ 是求积和与精确积分之间的绝对差：\n$$\nE_j = \\left| \\left( 2c_0^{(j)} + \\sum_{k=2N}^{3N-1} c_k^{(j)} \\delta_k^{(N)} \\right) - 2c_0^{(j)} \\right| = \\left| \\sum_{k=2N}^{3N-1} c_k^{(j)} \\delta_k^{(N)} \\right|\n$$\n这证实了问题中给出的表达式。为了推导该界，我们使用三角不等式：\n$$\nE_j \\le \\sum_{k=2N}^{3N-1} |c_k^{(j)}| |\\delta_k^{(N)}|\n$$\n根据谱方法理论的一个已知结果，当 $k > 2N-1$ 时，GLL 混叠权重 $\\delta_k^{(N)}$ 是有界的。例如，一些分析表明，在感兴趣的 $k$ 值范围内， $|\\delta_k^{(N)}| = \\mathcal{O}(N^{-3})$。问题建议使用 $|\\delta_k^{(N)}| \\le C/N^2$ 形式的界，其中常数 $C$ 与 $N$ 无关。接受这个已知界可以得到：\n$$\nE_j \\le \\frac{C}{N^2} \\sum_{k=2N}^{3N-1} |c_k^{(j)}|\n$$\n这就是所求的界。为了得出渐进行为的结论，我们考虑系数的和。对于一个具有“有界模态内容”的多项式 $u$，乘积 $u^2 P_j'$ 的系数 $c_k^{(j)}$ 在 $[2N, 3N-1]$ 范围内不衰减到零，但通常表现良好。该和包含大约 $N$ 个项。如果它们的平均量级相对于 $N$ 大致恒定，则该和的标度为 $\\mathcal{O}(N)$。因此，单个分量 $j$ 的混叠误差标度为：\n$$\n|E_j| = \\mathcal{O}\\left(\\frac{1}{N^2} \\cdot N\\right) = \\mathcal{O}(N^{-1})\n$$\n$3/2$ 规则 GLL 求积使用 $M+1$ 个节点，其中 $M=\\lceil 3N/2 \\rceil$。此求积对于最高 $2M-1$ 次的多项式是精确的。由于 $M \\ge 3N/2$，因此 $2M-1 \\ge 3N-1$。因为任何被积函数的最高次数是 $3N-1$，所以这个求积规则能精确地积分所有项。因此，混叠误差 $\\|E^{3/2}\\|_2$ 预期为零（在浮点精度范围内）。\n\n### 算法实现\n\n该 Python 程序按照以下步骤实现了所需的计算：\n1.  **多项式表示**：多项式 $p(x) = \\sum_{k=0}^{\\deg(p)} c_k x^k$ 是使用 `numpy.polynomial.Polynomial` 创建的。系数 $c_k$ 按规定从 $[-\\frac{1}{2}, \\frac{1}{2}]$ 的均匀分布中抽取。然后通过将 $p(x)$ 与 $(1-x^2)$（也表示为一个多项式对象）相乘来构造试验函数 $u(x)$：$u(x)=(1-x^2)p(x)$。这自动施加了边界条件 $u(\\pm 1)=0$。$u(x)$ 的二阶导数 $u_{xx}(x)$ 通过对 $u(x)$ 的多项式对象应用符号化的 `deriv(2)` 方法来解析计算。\n\n2.  **求积规则**：\n    -   勒让德-高斯节点和权重使用 `numpy.polynomial.legendre.leggauss(Q)` 获得。\n    -   勒让德-高斯-洛巴托节点和权重在一个辅助函数中计算。$K+1$ 个节点由端点 $\\{-1, 1\\}$ 和 $P_K'(x)$ 的 $K-1$ 个根组成。这些内部节点等价于雅可比多项式 $P_{K-1}^{(1,1)}(x)$ 的根，使用 `scipy.special.roots_jacobi` 找到。然后使用标准公式 $w_i = \\frac{2}{K(K+1) P_K(x_i)^2}$ 计算权重。\n\n3.  **勒让德多项式及其导数**：$P_j(x)$ 的值用 `scipy.special.eval_legendre(j, x)` 计算。导数 $P_j'(x)$ 使用恒等式 $P_j'(x)=\\frac{j}{1-x^2}(P_{j-1}(x)-xP_j(x))$ 来求值。为避免数值不稳定，此实现需要小心处理：对于节点 $x = \\pm 1$，使用精确的端点值 $P_j'(1) = \\frac{j(j+1)}{2}$ 和 $P_j'(-1)=(-1)^{j+1}\\frac{j(j+1)}{2}$。$j=0$ 的情况分开处理，因为 $P_0'(x)=0$。\n\n4.  **右端项向量计算**：对于三种求积规则中的每一种，程序在各自的求积节点上计算非线性项和粘性项的被积函数的值。然后通过计算被积函数值与求积权重的点积来近似积分。将相应分量 $r_j$ 相加，形成右端项向量 $r^{\\mathrm{exact}}$, $r^{\\mathrm{GLL},N}$ 和 $r^{\\mathrm{GLL},M}$。\n\n5.  **误差计算**：最后，程序计算混叠/去混叠的右端项向量与“精确”参考向量之间差的欧几里得范数（$L_2$ 范数），从而得到误差量 $\\|E^{\\mathrm{GLL}}\\|_2$ 和 $\\|E^{3/2}\\|_2$。对问题陈述中指定的每个测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre, roots_jacobi\n\ndef legendre_gauss_lobatto(K):\n    \"\"\"\n    Computes the K+1 Legendre-Gauss-Lobatto nodes and weights on [-1, 1].\n    \"\"\"\n    if K == 0:\n        return np.array([0.]), np.array([2.])\n    if K == 1:\n        return np.array([-1., 1.]), np.array([1., 1.])\n    \n    # Interior nodes are roots of P_K'(x), which are roots of Jacobi P_{K-1}^{(1,1)}(x)\n    interior_nodes, _ = roots_jacobi(K - 1, 1, 1)\n    \n    # Full set of nodes including endpoints\n    nodes = np.concatenate(([-1.0], np.sort(interior_nodes), [1.0]))\n    \n    # Weights calculation\n    weights = 2 / (K * (K + 1) * eval_legendre(K, nodes)**2)\n    \n    return nodes, weights\n\ndef legendre_derivative_eval(j, x):\n    \"\"\"\n    Evaluates the derivative of the j-th Legendre polynomial P_j'(x).\n    \"\"\"\n    if j == 0:\n        if isinstance(x, np.ndarray):\n            return np.zeros_like(x, dtype=float)\n        return 0.0\n\n    x = np.atleast_1d(x)\n    res = np.zeros_like(x, dtype=float)\n\n    # Use isclose for robust floating point comparison at endpoints\n    mask_m1 = np.isclose(x, -1.0)\n    mask_p1 = np.isclose(x, 1.0)\n    \n    # Exact endpoint values\n    res[mask_m1] = ((-1.0)**(j + 1)) * j * (j + 1) / 2.0\n    res[mask_p1] = j * (j + 1) / 2.0\n\n    # Interior points using recurrence relation\n    mask_int = ~ (mask_m1 | mask_p1)\n    x_int = x[mask_int]\n\n    if x_int.size > 0:\n        p_j_minus_1 = eval_legendre(j - 1, x_int)\n        p_j = eval_legendre(j, x_int)\n        res[mask_int] = j / (1 - x_int**2) * (p_j_minus_1 - x_int * p_j)\n\n    return res\n\ndef compute_rhs_vector(N, nu, u_poly, quad_rule):\n    \"\"\"\n    Computes the RHS vector {r_j} using a specified quadrature rule.\n    \"\"\"\n    x_nodes, w_nodes = quad_rule\n    u_xx_poly = u_poly.deriv(2)\n\n    u_vals = u_poly(x_nodes)\n    u_xx_vals = u_xx_poly(x_nodes)\n\n    r_vec = np.zeros(N + 1)\n    for j in range(N + 1):\n        P_j_vals = eval_legendre(j, x_nodes)\n        dP_j_vals = legendre_derivative_eval(j, x_nodes)\n        \n        # Nonlinear term: -0.5 * integral(u^2 * P_j')\n        nl_term = -0.5 * np.dot(w_nodes, u_vals**2 * dP_j_vals)\n        \n        # Viscous term: nu * integral(u_xx * P_j)\n        visc_term = nu * np.dot(w_nodes, u_xx_vals * P_j_vals)\n        \n        r_vec[j] = nl_term + visc_term\n    \n    return r_vec\n\ndef solve():\n    test_cases = [\n        # (N, deg(p), seed, nu)\n        (8, 6, 1, 0.1),\n        (2, 0, 2, 1.0),\n        (16, 14, 3, 0.0),\n        (24, 22, 4, 0.01),\n    ]\n\n    results = []\n    for N, deg_p, seed, nu in test_cases:\n        # 1. Setup polynomial u(x) = (1-x^2)p(x)\n        rng = np.random.default_rng(seed)\n        p_coeffs = rng.uniform(-0.5, 0.5, size=deg_p + 1)\n        p_poly = np.polynomial.Polynomial(p_coeffs)\n        u_poly = p_poly * np.polynomial.Polynomial([1, 0, -1])\n\n        # 2. Define quadrature schemes\n        # \"Exact\" reference using Legendre-Gauss quadrature\n        Q = 3 * N\n        x_exact, w_exact = np.polynomial.legendre.leggauss(Q)\n        \n        # Standard GLL quadrature\n        x_gll_n, w_gll_n = legendre_gauss_lobatto(N)\n        \n        # 3/2-rule dealiased GLL quadrature\n        M = int(np.ceil(3 * N / 2))\n        x_gll_m, w_gll_m = legendre_gauss_lobatto(M)\n        \n        # 3. Compute RHS vectors with each scheme\n        r_exact = compute_rhs_vector(N, nu, u_poly, (x_exact, w_exact))\n        r_gll_n = compute_rhs_vector(N, nu, u_poly, (x_gll_n, w_gll_n))\n        r_gll_m = compute_rhs_vector(N, nu, u_poly, (x_gll_m, w_gll_m))\n        \n        # 4. Compute aliasing error norms\n        err_gll = np.linalg.norm(r_gll_n - r_exact)\n        err_3_2 = np.linalg.norm(r_gll_m - r_exact)\n        \n        results.extend([err_gll, err_3_2])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}