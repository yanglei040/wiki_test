{
    "hands_on_practices": [
        {
            "introduction": "本练习是实现任何谱方法的起点。你将从头开始，在参考单元上构建基本矩阵——质量矩阵 ($M$)、刚度矩阵 ($K$) 和微分矩阵 ($D$)。掌握这一过程至关重要，因为这些矩阵是内积和微分算子的离散表示，构成了数值求解微分方程的支柱。",
            "id": "3418566",
            "problem": "考虑参考区间 $[-1,1]$ 以及在 高斯-洛巴托-勒让德 节点上使用拉格朗日插值节点基的谱Galerkin方法。设多项式阶数为 $N=4$，因此有 $N+1=5$ 个节点。此构造的基础是一维泊松算子的变分形式以及拉格朗日节点基函数的定义。具体而言，对于一个在节点上表示的函数 $v$，离散质量矩阵 $M$ 近似 $\\int_{-1}^{1} \\ell_i(x)\\,\\ell_j(x)\\,dx$，离散刚度矩阵 $K$ 近似 $\\int_{-1}^{1} \\ell_i'(x)\\,\\ell_j'(x)\\,dx$，其中 $\\ell_i$ 是与高斯-洛巴托-勒让德节点相关的拉格朗日基多项式。离散能量范数定义为 $\\|v\\|_K=\\sqrt{v^\\top K v}$。\n\n你的任务是编写一个完整的程序，该程序：\n- 使用勒让德多项式及其导数的性质，计算 $[-1,1]$ 上当 $N=4$ 时的高斯-洛巴托-勒让德节点（包括端点）及其相关的求积权重。\n- 通过一致使用拉格朗日基的重心权重，在这些节点上构建拉格朗日节点微分矩阵 $D$，确保 $D$ 是节点插值函数微分的矩阵表示。\n- 基于高斯-洛巴托-勒让德求积法则和上述基，在 $[-1,1]$ 上组装质量矩阵 $M$ 和刚度矩阵 $K$。\n- 对每个指定的节点向量 $v$，计算离散能量范数 $\\|v\\|_K=\\sqrt{v^\\top K v}$。\n\n你必须仅使用与谱Galerkin框架一致的、数学上合理的程序和勒让德多项式、拉格朗日插值以及高斯-洛巴托-勒让德求积的性质。不涉及角度，也不需要物理单位。\n\n测试套件：\n使用 $N=4$ 以及由此产生的 $N+1=5$ 个节点。对以下节点向量 $v$（每个长度为 $5$）评估离散能量范数，其中 $x$ 表示按升序排列的节点位置：\n1. $v^{(1)}=\\mathbf{1}$ (在节点上采样的常数函数)。\n2. $v^{(2)}=x$ (在节点上采样的线性函数)。\n3. $v^{(3)}=x^2$ (在节点上采样的二次函数)。\n4. $v^{(4)}=P_4(x)$ (在节点上求值的4阶勒让德多项式)。\n5. $v^{(5)}=[\\,0.1,\\,-0.5,\\,0.3,\\,-0.1,\\,0.7\\,]$ (一个自定义向量，并非由单一多项式派生)。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是对应测试用例 $v^{(i)}$ 计算出的离散能量范数，形式为浮点数。",
            "solution": "该问题要求使用谱Galerkin方法，在参考区间 $[-1, 1]$ 上为几个节点向量计算离散能量范数。该方法由多项式阶数 $N=4$、高斯-洛巴托-勒让德 (GLL) 节点上的拉格朗日基以及基于求积的质量和刚度矩阵组装来定义。\n\n解决方案分四个阶段进行：\n1. 计算高斯-洛巴托-勒让德节点和求积权重。\n2. 构建节点微分矩阵。\n3. 组装离散质量和刚度矩阵。\n4. 为指定的测试向量计算离散能量范数。\n\n### 1. 高斯-洛巴托-勒让德 (GLL) 节点和权重\n\n对于一个多项式阶数 $N$，其 $N+1$ 个 GLL 节点（记为 $x_j$，$j=0, \\dots, N$）是多项式 $(1-x^2)P_N'(x)$ 的根，其中 $P_N(x)$ 是 $N$ 阶勒让德多项式。该集合包括端点 $x_0 = -1$ 和 $x_{N} = 1$。内部节点是 $P_N'(x) = 0$ 的根。\n\n对于 $N=4$，我们需要勒让德多项式 $P_4(x)$ 及其导数。勒让德多项式可以通过递推关系 $(n+1)P_{n+1}(x) = (2n+1)xP_n(x) - nP_{n-1}(x)$ 生成，其中 $P_0(x)=1$ 和 $P_1(x)=x$。对于 $N=4$，这得到：\n$$P_4(x) = \\frac{1}{8}(35x^4 - 30x^2 + 3)$$\n其导数为：\n$$P_4'(x) = \\frac{1}{8}(140x^3 - 60x) = \\frac{5}{2}x(7x^2 - 3)$$\n$P_4'(x)=0$ 的根是 $x=0$ 和 $x=\\pm\\sqrt{3/7}$。包括端点在内，对于 $N=4$ 的五个 GLL 节点按升序排列为：\n$$x = \\{x_0, x_1, x_2, x_3, x_4\\} = \\left\\{-1, -\\sqrt{\\frac{3}{7}}, 0, \\sqrt{\\frac{3}{7}}, 1\\right\\}$$\n数值上，它们约等于 $\\{-1, -0.65465, 0, 0.65465, 1\\}$。\n\n相应的 GLL 求积权重 $w_j$ 由以下公式给出：\n$$w_j = \\frac{2}{N(N+1)[P_N(x_j)]^2}$$\n对于 $N=4$，我们有 $N(N+1)=20$。我们在每个节点 $x_j$ 处计算 $P_4(x)$ 的值：\n-   $P_4(\\pm 1) = 1$\n-   $P_4(\\pm\\sqrt{3/7}) = \\frac{1}{8}(35(\\frac{3}{7})^2 - 30(\\frac{3}{7}) + 3) = -3/7$\n-   $P_4(0) = 3/8$\n\n将这些值代入权重公式：\n-   $w_0 = w_4 = \\frac{2}{20 \\cdot 1^2} = \\frac{1}{10}$\n-   $w_1 = w_3 = \\frac{2}{20 \\cdot (-3/7)^2} = \\frac{2}{20 \\cdot 9/49} = \\frac{49}{90}$\n-   $w_2 = \\frac{2}{20 \\cdot (3/8)^2} = \\frac{2}{20 \\cdot 9/64} = \\frac{32}{45}$\n\n这些权重的总和为 $\\frac{1}{10} + \\frac{49}{90} + \\frac{32}{45} + \\frac{49}{90} + \\frac{1}{10} = \\frac{9+49+64+49+9}{90} = \\frac{180}{90}=2$，这正确地等于 $\\int_{-1}^{1} 1 \\, dx$。\n\n### 2. 节点微分矩阵\n\n该问题采用拉格朗日节点基 $\\{\\ell_j(x)\\}_{j=0}^N$，其中 $\\ell_j(x)$ 是唯一的 $N$ 阶多项式，使得 $\\ell_j(x_k) = \\delta_{jk}$。节点值 $v_j$ 的任意多项式插值函数 $v_N(x)$ 由 $v_N(x) = \\sum_{j=0}^N v_j \\ell_j(x)$ 给出。\n$(N+1) \\times (N+1)$ 微分矩阵 $D$ 的元素定义为 $D_{ij} = \\ell_j'(x_i)$。该矩阵将节点函数值的向量映射到节点导数值的向量：$(v_N')_{i} = \\sum_{j=0}^{N} D_{ij} v_j$。\n\n对于 GLL 节点，$D$ 的元素可以使用以下标准公式高效计算：\n$$D_{ij} = \\frac{P_N(x_i)}{P_N(x_j)(x_i - x_j)} \\quad \\text{for } i \\neq j$$\n$$D_{ii} = 0 \\quad \\text{for } i=1, \\dots, N-1$$\n$$D_{00} = -\\frac{N(N+1)}{4} \\quad \\text{and} \\quad D_{NN} = \\frac{N(N+1)}{4}$$\n对于 $N=4$，$D_{00} = -5$ 且 $D_{44} = 5$，而 $D_{11}=D_{22}=D_{33}=0$。非对角线元素使用上面推导的节点位置和 $P_4(x_j)$ 的值计算。\n\n### 3. 质量和刚度矩阵\n\n在谱Galerkin方法中，质量矩阵 $M$ 和刚度矩阵 $K$ 的元素由积分给出：\n$$M_{ij} = \\int_{-1}^{1} \\ell_i(x)\\ell_j(x)\\,dx, \\quad K_{ij} = \\int_{-1}^{1} \\ell_i'(x)\\ell_j'(x)\\,dx$$\n这些积分使用 GLL 求积法则 $\\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{k=0}^{N} f(x_k)w_k$ 进行数值计算。\n\n对于质量矩阵，这得到：\n$$M_{ij} \\approx \\sum_{k=0}^N \\ell_i(x_k)\\ell_j(x_k) w_k = \\sum_{k=0}^N \\delta_{ik}\\delta_{jk} w_k = \\delta_{ij} w_i$$\n这产生一个对角的，或称为“集总”的质量矩阵 $M = \\text{diag}(w_0, w_1, \\dots, w_N)$。对于 $M_{ij}$ 的 GLL 求积是一个近似，因为被积函数 $\\ell_i(x)\\ell_j(x)$ 是一个最高阶为 $2N=8$ 的多项式，而求积法则仅对最高阶为 $2N-1=7$ 的多项式是精确的。\n\n对于刚度矩阵，求积给出：\n$$K_{ij} = \\int_{-1}^{1} \\ell_i'(x)\\ell_j'(x)\\,dx \\approx \\sum_{k=0}^N \\ell_i'(x_k)\\ell_j'(x_k) w_k$$\n被积函数 $\\ell_i'(x)\\ell_j'(x)$ 是一个最高阶为 $2(N-1)=6$ 的多项式。由于 $6 \\leq 2N-1=7$，GLL 求积是精确的。使用微分矩阵的定义，$\\ell_j'(x_k) = D_{kj}$，刚度矩阵的元素为：\n$$K_{ij} = \\sum_{k=0}^N D_{ki} D_{kj} w_k$$\n以矩阵形式，这可以紧凑地表示为 $K = D^T M D$。\n\n### 4. 离散能量范数计算\n\n节点向量 $v$ 的离散能量范数为 $\\|v\\|_K = \\sqrt{v^T K v}$。使用 $K$ 的矩阵公式，这变为：\n$$\\|v\\|_K = \\sqrt{v^T (D^T M D) v} = \\sqrt{(Dv)^T M (Dv)}$$\n令 $v' = Dv$ 为节点处的导数值向量。范数的平方变为 $(v')^T M v' = \\sum_{k=0}^N (v'_k)^2 w_k$。这是连续能量范数分部积分形式 $\\int_{-1}^{1} (v_N'(x))^2 dx$ 的 GLL 求积近似。\n\n对于指定的测试向量，我们计算此范数。\n1. $v^{(1)}$ 代表 $f(x)=1$。其精确导数为 $0$。$D v^{(1)}$ 将是一个零向量（在机器精度范围内），所以 $\\|v^{(1)}\\|_K = 0$。\n2. $v^{(2)}$ 代表 $f(x)=x$。其精确导数为 $1$。$D v^{(2)}$ 将是一个元素全为1的向量。对于被积函数 $(1)^2=1$，求积是精确的。因此，$\\|v^{(2)}\\|_K^2 = \\int_{-1}^1 1^2 dx = 2$，所以 $\\|v^{(2)}\\|_K = \\sqrt{2}$。\n3. $v^{(3)}$ 代表 $f(x)=x^2$。其精确导数为 $2x$。对于被积函数 $(2x)^2=4x^2$，求积是精确的。因此，$\\|v^{(3)}\\|_K^2 = \\int_{-1}^1 4x^2 dx = 4[x^3/3]_{-1}^1 = 8/3$，所以 $\\|v^{(3)}\\|_K = \\sqrt{8/3}$。\n4. $v^{(4)}$ 代表 $f(x)=P_4(x)$。其导数为 $P_4'(x)$。对于 $(P_4'(x))^2$（一个6阶多项式），求积是精确的。因此，$\\|v^{(4)}\\|_K^2 = \\int_{-1}^1 (P_4'(x))^2 dx = 20$，所以 $\\|v^{(4)}\\|_K = \\sqrt{20}$。\n5. $v^{(5)}$ 是一个通用向量，其范数通过数值计算得出，没有一个简单的先验解析值。\n\n实现将遵循这些步骤来构建矩阵并计算范数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre\n\ndef solve():\n    \"\"\"\n    Computes the discrete energy norm ||v||_K for a spectral Galerkin method\n    with N=4 on Gauss-Lobatto-Legendre nodes.\n    \"\"\"\n    N = 4\n    N_plus_1 = N + 1\n\n    # Step 1: Compute Gauss-Lobatto-Legendre nodes and weights for N=4\n    \n    # The interior GLL nodes are the roots of the derivative of the N-th Legendre polynomial, P_N'(x).\n    # We use scipy.special.legendre to get the polynomial P_N(x)\n    # and its derivative to find the roots robustly.\n    P_N = legendre(N)\n    P_N_prime = P_N.deriv()\n    \n    # Find the roots of P_N'(x) to get the interior nodes.\n    interior_nodes = np.roots(P_N_prime)\n    \n    # Combine with endpoints and sort to get all GLL nodes.\n    nodes = np.concatenate(([-1.0], np.sort(interior_nodes), [1.0]))\n\n    # The GLL quadrature weights are given by w_j = 2 / (N*(N+1)*[P_N(x_j)]^2)\n    P_N_at_nodes = P_N(nodes)\n    weights = 2.0 / (N * N_plus_1 * P_N_at_nodes**2)\n\n    # Step 2: Construct the Lagrange nodal differentiation matrix D\n    D = np.zeros((N_plus_1, N_plus_1))\n    \n    # Off-diagonal entries\n    for i in range(N_plus_1):\n        for j in range(N_plus_1):\n            if i != j:\n                D[i, j] = P_N_at_nodes[i] / (P_N_at_nodes[j] * (nodes[i] - nodes[j]))\n\n    # Diagonal entries\n    D[0, 0] = -N * N_plus_1 / 4.0\n    D[N, N] = N * N_plus_1 / 4.0\n    # Interior diagonal entries are already 0 from initialization.\n\n    # Step 3: Assemble Mass M and Stiffness K matrices\n    # The mass matrix M is the lumped mass matrix, diagonal with quadrature weights.\n    M = np.diag(weights)\n    \n    # The stiffness matrix K is assembled using GLL quadrature, which is exact.\n    # K = D^T * M * D\n    K = D.T @ M @ D\n\n    # Step 4: Define test vectors and compute discrete energy norm\n    test_cases = [\n        # Case 1: v^(1) = 1 (constant function)\n        np.ones(N_plus_1),\n        # Case 2: v^(2) = x (linear function)\n        nodes,\n        # Case 3: v^(3) = x^2 (quadratic function)\n        nodes**2,\n        # Case 4: v^(4) = P_4(x) (Legendre polynomial of degree 4)\n        P_N_at_nodes,\n        # Case 5: v^(5) (custom vector)\n        np.array([0.1, -0.5, 0.3, -0.1, 0.7]),\n    ]\n\n    results = []\n    for v in test_cases:\n        # The discrete energy norm is sqrt(v^T * K * v)\n        # Add a small epsilon for cases where the result is zero to avoid sqrt(-ve) from precision errors.\n        energy_norm_sq = v.T @ K @ v\n        if abs(energy_norm_sq)  1e-15:\n            energy_norm_sq = 0.0\n        energy_norm = np.sqrt(energy_norm_sq)\n        results.append(energy_norm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界的问题很少被定义在方便的参考区间 $[-1,1]$ 上。本练习旨在弥补理论与实践之间的差距，它将引导你探索离散算子在仿射坐标映射下的变换规律。通过推导和数值验证矩阵与特征值的缩放规则，你将对谱*元*方法的核心思想——即组合多个从参考单元映射而来的物理单元——获得深刻的理解。",
            "id": "3418582",
            "problem": "实现拉普拉斯特征问题的一维谱Galerkin离散化，该问题具有齐次Dirichlet边界条件，并量化当从参考区间移动到物理区间时仿射映射对离散谱的影响。考虑以下连续问题：求特征对 $\\{\\lambda,u\\}$，使得在区间上 $-u''=\\lambda u$，且在端点处 $u=0$。请使用以下规范。\n\n1) 参考弱形式与基。在参考区间 $\\hat{I}=[-1,1]$ 上进行计算。从弱形式 $\\int_{\\hat{I}} u' v' \\, d\\xi = \\lambda \\int_{\\hat{I}} u v \\, d\\xi$（其中 $u(\\pm 1)=v(\\pm 1)=0$）出发，构造一个强制施加齐次Dirichlet边界条件的模态基。令 $L_n(\\xi)$ 表示 $[-1,1]$ 上的 $n$ 次Legendre多项式。使用Dirichlet模态基 $\\{\\phi_n(\\xi)\\}_{n=2}^N$，其中 $\\phi_n(\\xi)=L_n(\\xi)-L_{n-2}(\\xi)$（对于 $n\\ge 2$），该基满足 $\\phi_n(\\pm 1)=0$。使用足够精确的Gauss–Legendre求积法组装参考刚度矩阵和质量矩阵\n$$\n\\hat{K}_{ij}=\\int_{-1}^{1} \\phi_i'(\\xi)\\,\\phi_j'(\\xi)\\,d\\xi,\\qquad\n\\hat{M}_{ij}=\\int_{-1}^{1} \\phi_i(\\xi)\\,\\phi_j(\\xi)\\,d\\xi,\n$$\n然后在参考单元上形成离散广义特征值问题（Generalized Eigenvalue Problem, GEP），\n$$\n\\hat{K}\\,\\hat{c}=\\hat{\\lambda}\\,\\hat{M}\\,\\hat{c}.\n$$\n\n2) 仿射映射与物理单元。通过 $x(\\xi)=\\alpha\\,\\xi+\\beta$ 将 $\\hat{I}$ 仿射映射到物理区间 $I=[0,2]$，其中 $\\alpha$ 和 $\\beta$ 为适当的常数。从链式法则和变量替换公式出发，推导双线性形式以及离散刚度矩阵和质量矩阵在从 $\\hat{I}$ 到 $I$ 的映射下如何变换，并由此推断出 $I$ 和 $\\hat{I}$ 上离散特征值之间的关系。推导过程中不要省略步骤；从变量替换下的导数和积分定义开始。\n\n3) 数值实现细节。在 $\\hat{I}$ 上实现基和求积法，并通过数值积分组装 $\\hat{K}$ 和 $\\hat{M}$。在 $I=[0,2]$ 上，使用 $\\hat{I}$ 上的相同求积法组装映射后的刚度矩阵和质量矩阵，但要包含映射的雅可比行列式和链式法则所蕴含的导数缩放。求解相应的GEP，以获得 $\\hat{I}$ 和 $I$ 的离散特征值。\n\n4) 量化映射效应。对于给定的多项式阶数 $N$，令 $p=N-1$ 为Dirichlet基的维度。对于指定的整数 $k$（$1\\le k\\le p$），计算：\n- 对于前 $k$ 个特征值，数值比率 $\\lambda^{(I)}_j/\\hat{\\lambda}_j$ 与您从仿射映射推导出的解析缩放因子之间的最大绝对偏差。\n- 对于前 $k$ 个特征值，通过在 $I$ 上组装得到的物理特征值与将解析缩放因子直接应用于参考特征值所得到的特征值之间的最大绝对差。\n\n5) 测试套件。您的程序必须对以下在 $I=[0,2]$ 上由 $(N,k)$ 对定义的测试用例执行上述计算：\n- 用例 A: $(N,k)=(6,3)$。\n- 用例 B: $(N,k)=(2,1)$。\n- 用例 C: $(N,k)=(12,5)$。\n\n6) 输出格式。您的程序应生成一行输出，其中包含一个结果列表，每个测试用例一个结果，顺序与上面列出的一致。每个结果必须是一个包含两个浮点数的列表 $[e_1,e_2]$，其中 $e_1$ 是第4项中定义的比率与解析缩放比较的最大绝对偏差，而 $e_2$ 是第4项中定义的组装物理特征值与解析缩放参考特征值比较的最大绝对差。最终输出必须是形如\n$[[e_{A,1},e_{A,2}],[e_{B,1},e_{B,2}],[e_{C,1},e_{C,2}]]$\n的单行字符串，所有浮点数均使用十进制表示。\n\n不涉及物理单位。如果存在角度，应以弧度为单位进行解释，但此处未使用角度。确保您的程序完全自包含，不需要任何输入。仅使用适用于对称正定广义特征问题的稳定数值线性代数例程。",
            "solution": "用户要求实现拉普拉斯特征问题 $-u'' = \\lambda u$ 的一维谱Galerkin方法，该问题具有齐次Dirichlet边界条件。问题的核心是推导并数值验证参考区间 $\\hat{I}=[-1,1]$ 和物理区间 $I=[0,2]$ 之间的仿射映射对离散谱的影响。\n\n### 步骤 1：问题陈述的验证\n\n我将首先根据指定的标准验证该问题。\n\n**1.1. 提取的已知条件**\n- **连续问题：** 求解特征对 $\\{\\lambda,u\\}$，满足 $-u''=\\lambda u$，在区间端点处有齐次Dirichlet条件 $u=0$。\n- **参考域：** 参考区间为 $\\hat{I}=[-1,1]$。\n- **参考弱形式：** 在 $\\hat{I}$ 上的变分形式为 $\\int_{\\hat{I}} u' v' \\, d\\xi = \\lambda \\int_{\\hat{I}} u v \\, d\\xi$，其中函数 $u,v$ 属于一个合适的空间，并满足 $u(\\pm 1)=v(\\pm 1)=0$。\n- **基函数：** 在 $\\hat{I}$ 上定义了一个模态基 $\\{\\phi_n(\\xi)\\}_{n=2}^N$，其形式为 $\\phi_n(\\xi)=L_n(\\xi)-L_{n-2}(\\xi)$，其中 $L_n(\\xi)$ 是 $n$ 次Legendre多项式。该基满足Dirichlet边界条件。\n- **参考离散系统：** 在 $\\hat{I}$ 上的广义特征值问题 (GEP) 是 $\\hat{K}\\,\\hat{c}=\\hat{\\lambda}\\,\\hat{M}\\,\\hat{c}$，其中刚度矩阵和质量矩阵为 $\\hat{K}_{ij}=\\int_{-1}^{1} \\phi_i'(\\xi)\\,\\phi_j'(\\xi)\\,d\\xi$ 和 $\\hat{M}_{ij}=\\int_{-1}^{1} \\phi_i(\\xi)\\,\\phi_j(\\xi)\\,d\\xi$。这些矩阵将使用Gauss-Legendre求积法进行组装。\n- **物理域和映射：** 物理区间为 $I=[0,2]$。从 $\\hat{I}$到 $I$ 的映射是仿射的，由 $x(\\xi)=\\alpha\\,\\xi+\\beta$ 给出。\n- **推导任务：** 推导离散刚度矩阵和质量矩阵在仿射映射下的变换，并推断出 $I$ 和 $\\hat{I}$ 上离散特征值之间的关系。\n- **数值实现：** 使用 $\\hat{I}$ 上的数值求积组装参考矩阵 $\\hat{K}, \\hat{M}$ 和物理矩阵 $K, M$，并求解相应的GEP。\n- **量化任务：** 对于给定的多项式阶数 $N$ 和整数 $k \\le p=N-1$，计算两个度量：\n    1. $e_1$：对于前 $k$ 个特征值，数值特征值比率 $\\lambda^{(I)}_j/\\hat{\\lambda}_j$ 与推导出的解析缩放因子之间的最大绝对偏差。\n    2. $e_2$：对于前 $k$ 个特征值，在 $I$ 上组装的物理特征值 $\\lambda^{(I)}_j$ 与通过将解析缩放因子应用于参考特征值 $\\hat{\\lambda}_j$ 得到的特征值之间的最大绝对差。\n- **测试套件：** 该过程必须对三个用例运行：$(N,k)=(6,3)$，$(N,k)=(2,1)$ 和 $(N,k)=(12,5)$。\n- **输出格式：** 一个单行字符串，表示一个包含两个元素列表的列表：`[[e_{A,1},e_{A,2}],[e_{B,1},e_{B,2}],[e_{C,1},e_{C,2}]]`。\n\n**1.2. 验证结论**\n该问题在科学上是合理的、适定的和客观的。它描述了谱方法和有限元方法理论与应用中的一个标准且重要的过程：坐标变换分析。所选的基是谱方法中施加边界条件的标准元素。所要求的推导是微积分中链式法则和变量替换的基本应用。数值任务定义明确，旨在检验理论理解。所有必要的参数和定义均已提供。没有矛盾、歧义或伪科学主张。\n\n因此，该问题是**有效的**。\n\n### 步骤 2：推导与求解方法\n\n**2.1. 仿射映射分析**\n我们有一个仿射映射 $x(\\xi) = \\alpha\\xi + \\beta$，它将参考区间 $\\hat{I}=[-1,1]$ 映射到物理区间 $I=[0,2]$。常数 $\\alpha$ 和 $\\beta$ 由边界映射确定：\n- $x(-1) = 0 \\implies -\\alpha + \\beta = 0$\n- $x(1) = 2 \\implies \\alpha + \\beta = 2$\n将这两个方程相加得到 $2\\beta = 2$，所以 $\\beta=1$。将其代回第一个方程得到 $\\alpha=\\beta=1$。因此，映射为 $x(\\xi) = \\xi + 1$。从 $\\hat{I}=[-1,1]$ 到任意区间 $[a,b]$ 的通用映射是 $x(\\xi) = \\frac{b-a}{2}\\xi + \\frac{a+b}{2}$，对于 $[a,b]=[0,2]$，这证实了 $\\alpha = (2-0)/2 = 1$ 和 $\\beta = (2+0)/2 = 1$。\n\n在物理区间 $I$ 上的特征问题的弱形式是寻找 $\\lambda \\in \\mathbb{R}$ 和 $u \\in H_0^1(I)$，使得\n$$\n\\int_I \\frac{du}{dx} \\frac{dv}{dx} \\, dx = \\lambda \\int_I u v \\, dx \\quad \\forall v \\in H_0^1(I).\n$$\n我们将 $I$ 上的导数和积分与 $\\hat{I}$ 上的导数和积分联系起来。令 $\\hat{u}(\\xi) = u(x(\\xi))$ 和 $\\hat{v}(\\xi) = v(x(\\xi))$。\n- **导数的链式法则：** $\\frac{d\\hat{u}}{d\\xi} = \\frac{du}{dx} \\frac{dx}{d\\xi}$。映射的导数是 $\\frac{dx}{d\\xi} = \\alpha$。因此，$\\frac{du}{dx} = \\frac{1}{\\alpha}\\frac{d\\hat{u}}{d\\xi}$。对于我们到 $I=[0,2]$ 的特定映射，$\\alpha=1$，所以 $\\frac{du}{dx} = \\frac{d\\hat{u}}{d\\xi}$。\n- **积分的变量替换：** 微分元变换为 $dx = \\frac{dx}{d\\xi} d\\xi = \\alpha \\, d\\xi$。量 $\\alpha$ 是一维变换的雅可比行列式。对于我们的映射，$\\alpha=1$，所以 $dx=d\\xi$。\n\n将这些代入物理弱形式中：\n- **刚度双线性形式：** $k(u,v) = \\int_I \\frac{du}{dx}\\frac{dv}{dx}\\,dx = \\int_{-1}^{1} \\left(\\frac{1}{\\alpha}\\frac{d\\hat{u}}{d\\xi}\\right) \\left(\\frac{1}{\\alpha}\\frac{d\\hat{v}}{d\\xi}\\right) (\\alpha\\,d\\xi) = \\frac{1}{\\alpha} \\int_{-1}^1 \\frac{d\\hat{u}}{d\\xi}\\frac{d\\hat{v}}{d\\xi}\\,d\\xi = \\frac{1}{\\alpha}\\hat{k}(\\hat{u},\\hat{v})$。\n- **质量双线性形式：** $m(u,v) = \\int_I uv\\,dx = \\int_{-1}^1 \\hat{u}(\\xi)\\hat{v}(\\xi) (\\alpha\\,d\\xi) = \\alpha \\int_{-1}^1 \\hat{u}(\\xi)\\hat{v}(\\xi)\\,d\\xi = \\alpha\\hat{m}(\\hat{u},\\hat{v})$。\n\n**2.2. 离散系统的变换**\n离散化是通过将 $u$ 和 $v$ 在基函数上展开来形成的。物理基函数是 $\\varphi_j(x) = \\phi_j(\\xi(x))$，其中 $\\xi(x)$ 是逆映射。矩阵元素是 $K_{ij} = k(\\varphi_j, \\varphi_i)$ 和 $M_{ij} = m(\\varphi_j, \\varphi_i)$。使用上面推导的关系，矩阵之间的关系为：\n$$\nK = \\frac{1}{\\alpha} \\hat{K}, \\qquad M = \\alpha \\hat{M}.\n$$\n物理域上的GEP是 $K c = \\lambda M c$。代入变换后的矩阵得到：\n$$\n\\left(\\frac{1}{\\alpha}\\hat{K}\\right)c = \\lambda \\left(\\alpha\\hat{M}\\right)c.\n$$\n从左边乘以 $\\alpha$，我们得到：\n$$\n\\hat{K}c = (\\lambda\\alpha^2)\\hat{M}c.\n$$\n这与参考GEP $\\hat{K}\\hat{c}=\\hat{\\lambda}\\hat{M}\\hat{c}$ 的形式相同。通过比较两者，我们推导出特征值之间的关系：\n$$\n\\hat{\\lambda}_j = \\lambda^{(I)}_j \\alpha^2 \\implies \\lambda^{(I)}_j = \\frac{1}{\\alpha^2} \\hat{\\lambda}_j.\n$$\n因此，解析缩放因子是 $S = 1/\\alpha^2$。对于从 $\\hat{I}=[-1,1]$ 到 $I=[0,2]$ 的映射，我们发现 $\\alpha=1$，所以解析缩放因子是 $S = 1/1^2 = 1$。\n\n**2.3. 数值离散化细节**\n实现需要以下组件：\n- **基函数：** 基由 $\\{\\phi_n(\\xi)\\}_{n=2}^N$ 给出，其中 $\\phi_n(\\xi) = L_n(\\xi) - L_{n-2}(\\xi)$。该空间的维度是 $p = N-1$。矩阵 $\\hat{K}$ 和 $\\hat{M}$ 的大小将是 $p \\times p$。\n- **数值求积：** 矩阵元素是多项式的积分。对于 $\\hat{M}_{ij}$，被积函数的最高次数是 $\\text{deg}(\\phi_i \\phi_j) = i+j \\le 2N$。对于 $\\hat{K}_{ij}$，最高次数是 $\\text{deg}(\\phi_i' \\phi_j') = (i-1)+(j-1) \\le 2N-2$。具有 $N_q$ 个点的Gauss-Legendre求积规则可以精确积分最高达 $2N_q-1$ 次的多项式。为确保质量矩阵的精确积分，我们需要 $2N_q-1 \\ge 2N$，这意味着 $N_q \\ge N+1/2$。我们选择 $N_q = N+1$。\n- **矩阵组装：** 参考矩阵组装如下：\n$$\n\\hat{K}_{ij} = \\sum_{q=1}^{N_q} w_q \\phi_i'(\\xi_q)\\phi_j'(\\xi_q), \\qquad \\hat{M}_{ij} = \\sum_{q=1}^{N_q} w_q \\phi_i(\\xi_q)\\phi_j(\\xi_q),\n$$\n其中 $\\{\\xi_q, w_q\\}$ 是 $[-1,1]$ 上的Gauss-Legendre求积点和权重。索引 $i,j$ 的范围是从 $2$ 到 $N$，它们将被映射到从 $0$ 到 $N-2$ 的矩阵索引。\n- **物理矩阵组装：** 问题要求通过变换被积函数并在参考单元上应用求积规则来组装物理矩阵 $K$ 和 $M$。\n$$\nK_{ij} = \\sum_{q=1}^{N_q} w_q \\left(\\frac{1}{\\alpha}\\phi_i'(\\xi_q)\\right)\\left(\\frac{1}{\\alpha}\\phi_j'(\\xi_q)\\right)\\alpha = \\frac{1}{\\alpha} \\hat{K}_{ij}.\n$$\n$$\nM_{ij} = \\sum_{q=1}^{N_q} w_q \\left(\\phi_i(\\xi_q)\\right)\\left(\\phi_j(\\xi_q)\\right)\\alpha = \\alpha \\hat{M}_{ij}.\n$$\n这证实了组装物理矩阵在数值上等同于缩放参考矩阵，直到浮点精度。\n- **特征求解器：** 参考域和物理域的GEP都是 $Ac=\\lambda Bc$ 的形式，其中 $A$ 和 $B$ 是对称的，且 $B$ 是正定的。一个专门的特征求解器，如 `scipy.linalg.eigh`，是合适的。\n\n**2.4. 量化映射效应的算法**\n对于每个测试用例 $(N, k)$：\n1.  定义问题维度 $p = N-1$。\n2.  为 $I=[0,2]$ 设置仿射映射参数：$\\alpha=1, \\beta=1$。解析缩放因子为 $S=1/\\alpha^2=1$。\n3.  设置求积阶数 $N_q = N+1$ 并获取Gauss-Legendre点 $\\xi_q$ 和权重 $w_q$。\n4.  在所有求积点上计算基函数 $\\phi_n(\\xi_q)$ 及其导数 $\\phi_n'(\\xi_q)$，其中 $n=2, \\dots, N$。\n5.  组装 $p \\times p$ 的参考矩阵 $\\hat{K}$ 和 $\\hat{M}$。\n6.  求解GEP $\\hat{K}\\hat{c}=\\hat{\\lambda}\\hat{M}\\hat{c}$ 以找到特征值 $\\{\\hat{\\lambda}_j\\}_{j=1}^p$，并按升序排序。\n7.  组装 $p \\times p$ 的物理矩阵 $K = (1/\\alpha)\\hat{K}$ 和 $M = \\alpha\\hat{M}$。\n8.  求解GEP $Kc=\\lambda M c$ 以找到特征值 $\\{\\lambda^{(I)}_j\\}_{j=1}^p$，并按升序排序。\n9.  从两组中选择前 $k$ 个特征值：$\\{\\hat{\\lambda}_j\\}_{j=1}^k$ 和 $\\{\\lambda^{(I)}_j\\}_{j=1}^k$。\n10. 计算误差统计量：\n    - $e_1 = \\max_{j=1,\\dots,k} |\\lambda^{(I)}_j / \\hat{\\lambda}_j - S|$\n    - $e_2 = \\max_{j=1,\\dots,k} |\\lambda^{(I)}_j - S \\cdot \\hat{\\lambda}_j|$\n    由于解析缩放因子 $S=1$ 且数值组装过程反映了解析缩放，预计 $e_1$ 和 $e_2$ 都在机器精度量级。\n11. 存储结果对 $[e_1, e_2]$ 并进行下一个测试用例。\n最后，将收集到的结果格式化为指定的字符串输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef evaluate_legendre_and_derivs(N_max, pts):\n    \"\"\"\n    Evaluates Legendre polynomials L_n and their derivatives L'_n up to degree N_max.\n    \n    Uses stable three-term recurrence relations.\n    L_{n+1}(x) = ( (2n+1)x L_n(x) - n L_{n-1}(x) ) / (n+1)\n    L'_{n+1}(x) = (2n+1)L_n(x) + L'_{n-1}(x)\n\n    Args:\n        N_max (int): Maximum degree of polynomials to evaluate.\n        pts (np.ndarray): Points at which to evaluate the polynomials.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: \n            - L_vals: array of shape (N_max+1, len(pts)) with L_n values.\n            - L_deriv_vals: array of shape (N_max+1, len(pts)) with L'_n values.\n    \"\"\"\n    num_pts = len(pts)\n    L_vals = np.zeros((N_max + 1, num_pts))\n    L_deriv_vals = np.zeros((N_max + 1, num_pts))\n\n    # Base cases for n=0 and n=1\n    L_vals[0, :] = 1.0\n    L_deriv_vals[0, :] = 0.0\n    \n    if N_max > 0:\n        L_vals[1, :] = pts\n        L_deriv_vals[1, :] = 1.0\n\n    # Recurrence for L_n for n >= 2\n    for n in range(1, N_max):\n        L_vals[n + 1, :] = ((2 * n + 1) * pts * L_vals[n, :] - n * L_vals[n - 1, :]) / (n + 1)\n    \n    # Recurrence for L'_n for n >= 2\n    for n in range(1, N_max):\n        L_deriv_vals[n + 1, :] = (2 * n + 1) * L_vals[n, :] + L_deriv_vals[n - 1, :]\n        \n    return L_vals, L_deriv_vals\n\ndef get_dirichlet_basis_evaluations(N, pts):\n    \"\"\"\n    Evaluates the Dirichlet basis functions phi_n = L_n - L_{n-2} and their derivatives.\n    \n    Args:\n        N (int): Max polynomial degree in the expansion, defining basis phi_2 to phi_N.\n        pts (np.ndarray): Points at which to evaluate the basis.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]:\n            - phi_vals: array of shape (N-1, len(pts)) with phi_n values for n=2..N.\n            - phi_deriv_vals: array of shape (N-1, len(pts)) with phi'_n values for n=2..N.\n    \"\"\"\n    if N  2:\n        return np.array([]), np.array([])\n        \n    p = N - 1 # Dimension of the basis\n    L_vals, L_deriv_vals = evaluate_legendre_and_derivs(N, pts)\n    \n    phi_vals = np.zeros((p, len(pts)))\n    phi_deriv_vals = np.zeros((p, len(pts)))\n    \n    for n in range(2, N + 1):\n        # Matrix index i corresponds to basis function n=i+2\n        i = n - 2\n        phi_vals[i, :] = L_vals[n, :] - L_vals[n - 2, :]\n        phi_deriv_vals[i, :] = L_deriv_vals[n, :] - L_deriv_vals[n - 2, :]\n        \n    return phi_vals, phi_deriv_vals\n\ndef solve_gep(N, physical_interval):\n    \"\"\"\n    Assembles matrices and solves the GEP for both reference and physical domains.\n    \"\"\"\n    p = N - 1 # Dimension of discrete space\n    if p == 0:\n        return np.array([]), np.array([]), 1.0\n\n    # 1. Setup quadrature\n    # To integrate M_ij exactly, need 2*Nq - 1 >= 2N, so Nq >= N + 1/2.\n    Nq = N + 1\n    xi_q, w_q = np.polynomial.legendre.leggauss(Nq)\n\n    # 2. Evaluate basis functions at quadrature points\n    phi_vals, phi_deriv_vals = get_dirichlet_basis_evaluations(N, xi_q)\n\n    # 3. Assemble reference matrices K_hat, M_hat\n    K_hat = np.einsum('iq,q,jq->ij', phi_deriv_vals, w_q, phi_deriv_vals)\n    M_hat = np.einsum('iq,q,jq->ij', phi_vals, w_q, phi_vals)\n\n    # 4. Solve reference GEP\n    eigvals_hat = eigh(K_hat, M_hat, eigvals_only=True)\n\n    # 5. Setup affine mapping and assemble physical matrices\n    a, b = physical_interval\n    alpha = (b - a) / 2.0\n    \n    # Assembling K and M directly using the transformation rules\n    K = (1.0 / alpha) * K_hat\n    M = alpha * M_hat\n    \n    # 6. Solve physical GEP\n    eigvals_I = eigh(K, M, eigvals_only=True)\n    \n    # 7. Analytic scaling factor\n    analytic_scaling_factor = 1.0 / alpha**2\n    \n    return eigvals_hat, eigvals_I, analytic_scaling_factor\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (6, 3),  # Case A\n        (2, 1),  # Case B\n        (12, 5), # Case C\n    ]\n    \n    physical_interval = [0.0, 2.0]\n    \n    results = []\n    for N, k in test_cases:\n        p = N - 1\n        if k > p:\n            # This case is not in the problem spec but is a good guard\n            raise ValueError(f\"k={k} cannot be larger than the basis dimension p={p}\")\n\n        # Solve the GEPs for both domains\n        eigvals_hat, eigvals_I, S = solve_gep(N, physical_interval)\n\n        # Truncate to the first k eigenvalues\n        first_k_eigvals_hat = eigvals_hat[:k]\n        first_k_eigvals_I = eigvals_I[:k]\n        \n        # Quantify the mapping effect\n        # e1: Maximum absolute deviation of the ratio from the analytic scaling factor\n        ratios = first_k_eigvals_I / first_k_eigvals_hat\n        e1 = np.max(np.abs(ratios - S))\n        \n        # e2: Maximum absolute difference between assembled and analytically scaled eigenvalues\n        scaled_hat_eigvals = S * first_k_eigvals_hat\n        e2 = np.max(np.abs(first_k_eigvals_I - scaled_hat_eigvals))\n\n        results.append([e1, e2])\n\n    # Final print statement in the exact required format.\n    # The str() of a list automatically includes brackets and commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然线性问题是基础，但许多物理现象本质上是非线性的。本练习将探讨谱方法中的一个关键挑战：如何精确表示如 $u^2$ 这样的非线性项。你将分析一种被称为“混叠误差”的数值现象，并推导出消除这种误差所需的精确求积或数据填充规则。掌握“去混叠”技术对于确保非线性方程数值模拟的稳定性和准确性至关重要。",
            "id": "3418568",
            "problem": "考虑一维区间上使用两种典型近似空间的标准谱 Galerkin 方法。\n\n1. 有界区间上的多项式空间：\n令 $\\mathcal{P}_{N}$ 表示区间 $[-1,1]$ 上次数至多为 $N$ 的多项式空间，使用标准 Lebesgue 权重。令 $\\{L_{k}(x)\\}_{k=0}^{N}$ 为 $\\mathcal{P}_{N}$ 的一个 $L^{2}([-1,1])$-标准正交基，例如经过适当归一化的 Legendre 多项式。将到 $\\mathcal{P}_{N}$ 上的 $L^{2}$ 投影定义为\n$$\nP_{N}f = \\sum_{k=0}^{N} \\left( \\int_{-1}^{1} f(x)\\, L_{k}(x)\\, \\mathrm{d}x \\right) L_{k}(x).\n$$\n假设 $u \\in \\mathcal{P}_{N}$。您希望使用具有 $Q$ 个点的 Gauss–Legendre 求积法精确计算 $P_{N}(u^{2})$。使用一个熟知的结论：具有 $Q$ 个点的 Gauss–Legendre 求积法对于次数至多为 $2Q-1$ 的所有多项式都是精确的。请用 $N$ 表示，确定为使 $P_{N}(u^{2})$ 得以精确计算所需的最小求积点数 $Q_{\\min}$。\n\n2. 周期区间上的三角多项式空间：\n令 $\\mathcal{T}_{N}$ 表示在区间 $[-\\pi,\\pi]$ 上波数满足 $|k| \\leq N$ 的三角多项式空间，因此 $\\dim(\\mathcal{T}_{N}) = 2N+1$。在由 $M_{0} = 2N+1$ 个点组成的等距网格上表示 $u \\in \\mathcal{T}_{N}$，并通过变换到物理空间、逐点相乘后再变换回来的伪谱方法来计算二次非线性项。为消除混叠并获得 $u^{2}$ 到 $\\mathcal{T}_{N}$ 上的精确 $L^{2}$ 投影，您需要在变换前补零至 $M$ 个点，在此分辨率下执行非线性运算，然后投影回波数带 $|k|\\leq N$ 上。\n\n使用离散 Fourier 变换卷积的核心定义：在 $M$ 点网格上的乘积的 Fourier 系数对应于模 $M$ 的循环卷积。请用 $N$ 推导所需的最小填充因子\n$$\ns(N) = \\frac{M}{M_{0}}\n$$\n以确保 $u^{2}$ 回到 $\\mathcal{T}_{N}$ 的 $L^{2}$ 投影是精确的（即无混叠）。\n\n答案规格：\n- 将最终答案表示为两个关于 $N$ 的闭式表达式，一个用于 $Q_{\\min}$，一个用于 $s(N)$。\n- 以一个二元行矩阵的形式提供您的最终答案。",
            "solution": "该问题包含两个独立部分，都涉及在谱方法框架内精确计算二次非线性项 $u^2$。第一部分处理多项式近似空间，而第二部分处理三角多项式空间。\n\n### 第一部分：多项式空间与 Gauss 求积\n\n目标是找到 Gauss-Legendre 求积法则所需的最小求积点数 $Q_{\\min}$，以便精确计算 $u^2$ 到多项式空间 $\\mathcal{P}_N$ 上的 $L^2$ 投影，其中 $u \\in \\mathcal{P}_N$。\n\n一个函数 $f$ 到 $\\mathcal{P}_N$ 上的 $L^2$ 投影由下式给出\n$$\nP_{N}f = \\sum_{k=0}^{N} \\hat{f}_k L_{k}(x)\n$$\n其中 $\\{L_k(x)\\}_{k=0}^N$ 是 $\\mathcal{P}_N$ 的一个 $L^2([-1,1])$-标准正交基，系数 $\\hat{f}_k$ 通过内积计算：\n$$\n\\hat{f}_k = \\int_{-1}^{1} f(x) L_k(x) \\, \\mathrm{d}x\n$$\n在本问题中，要投影的函数是 $f(x) = u^2(x)$，其中 $u \\in \\mathcal{P}_N$。因此，我们需要计算积分\n$$\n\\widehat{(u^2)}_k = \\int_{-1}^{1} u^2(x) L_k(x) \\, \\mathrm{d}x \\quad \\text{for } k=0, 1, \\dots, N.\n$$\n为了使用 Gauss-Legendre 求积法精确计算这些积分，我们必须确定被积函数 $u^2(x) L_k(x)$ 的最大可能多项式次数。\n\n1.  函数 $u(x)$ 是一个次数至多为 $N$ 的多项式，即 $u \\in \\mathcal{P}_N$。\n2.  $u(x)$ 的平方，即 $u^2(x)$，因此是一个次数至多为 $2N$ 的多项式。\n3.  基函数 $L_k(x)$ 是次数为 $k$ 的多项式。因为我们需要计算直到 $k=N$ 的系数，所涉及的最高次数的基函数是 $L_N(x)$，其次数为 $N$。\n4.  被积函数是乘积 $u^2(x) L_k(x)$。该乘积的次数是其因子次数之和。当 $u^2(x)$ 和 $L_k(x)$ 都达到其可能的最大次数时，总次数达到最大。这发生在 $k=N$ 且 $u(x)$ 的次数恰好为 $N$ 的情况下。\n    $$\n    \\text{deg}(u^2(x) L_k(x)) \\le \\text{deg}(u^2(x)) + \\text{deg}(L_k(x)) \\le 2N + k\n    $$\n    在所有被积函数中（对于 $k = 0, \\dots, N$），最大次数为\n    $$\n    \\max_{k \\in \\{0, \\dots, N\\}} \\text{deg}(u^2(x) L_k(x)) = 2N + N = 3N.\n    $$\n\n问题指出，具有 $Q$ 个点的 Gauss-Legendre 求积法对于次数至多为 $2Q-1$ 的所有多项式都是精确的。为确保所有必需的积分系数都能被精确计算，该求积法则必须对我们可能遇到的最高次多项式是精确的。因此，我们需要：\n$$\n2Q - 1 \\ge 3N\n$$\n对 $Q$ 求解此不等式可得：\n$$\n2Q \\ge 3N + 1\n$$\n$$\nQ \\ge \\frac{3N+1}{2}\n$$\n由于求积点数 $Q$ 必须是整数，我们需要满足此条件的最小整数 $Q$。这由向上取整函数（ceiling function）给出：\n$$\nQ_{\\min} = \\left\\lceil \\frac{3N+1}{2} \\right\\rceil\n$$\n\n### 第二部分：三角多项式空间与去混叠\n\n目标是找到所需的最小填充因子 $s(N) = M/M_0$，以便精确计算 $u^2$ 到三角多项式空间 $\\mathcal{T}_N$ 上的 $L^2$ 投影，其中 $u \\in \\mathcal{T}_N$。这通过在伪谱计算中消除混叠误差来实现。\n\n函数 $u(x) \\in \\mathcal{T}_N$ 是一个波数范围为 $|k| \\le N$ 的三角多项式。它可以写成 Fourier 级数形式：\n$$\nu(x) = \\sum_{k=-N}^{N} \\hat{u}_k e^{ikx}\n$$\n两个此类函数的乘积，$u^2(x) = u(x) \\cdot u(x)$，是：\n$$\nu^2(x) = \\left(\\sum_{j=-N}^{N} \\hat{u}_j e^{ijx}\\right) \\left(\\sum_{l=-N}^{N} \\hat{u}_l e^{ilx}\\right) = \\sum_{j=-N}^{N} \\sum_{l=-N}^{N} \\hat{u}_j \\hat{u}_l e^{i(j+l)x}\n$$\n得到的波数形式为 $k' = j+l$，其中 $j, l \\in \\{-N, \\dots, N\\}$。这些波数的范围是从 $(-N)+(-N)=-2N$ 到 $N+N=2N$。因此，$u^2(x)$ 是空间 $\\mathcal{T}_{2N}$ 中的一个三角多项式，其非零 Fourier 系数 $\\widehat{(u^2)}_{k'}$ 仅在 $|k'| \\le 2N$ 时存在。\n\n伪谱方法使用 $M$ 个网格点上的值在物理空间中计算乘积。这个逐点乘积的 Fourier 系数通过离散 Fourier 变换（DFT）获得。DFT 卷积定理意味着计算出的系数（我们称之为 $\\tilde{c}_k$）会受到混叠的影响：\n$$\n\\tilde{c}_k = \\sum_{p=-\\infty}^{\\infty} \\widehat{(u^2)}_{k+pM}\n$$\n我们想要计算 $u^2$ 到 $\\mathcal{T}_N$ 上的 $L^2$ 投影，这意味着我们想要求出目标波数 $|k| \\le N$ 的精确 Fourier 系数 $\\widehat{(u^2)}_k$。为了无混叠误差地做到这一点，我们必须使 $\\tilde{c}_k = \\widehat{(u^2)}_k$ 对所有 $|k| \\le N$ 成立。这要求对于此范围内的 $k$，关于 $p \\neq 0$ 的求和为零：\n$$\n\\sum_{p \\in \\mathbb{Z} \\setminus \\{0\\}} \\widehat{(u^2)}_{k+pM} = 0 \\quad \\text{for } |k| \\le N\n$$\n如果和中的每一项都为零，则此条件将得到满足。由于真实的系数 $\\widehat{(u^2)}_{k'}$ 仅在 $|k'| \\le 2N$ 时非零，我们必须确保对于所有 $|k| \\le N$ 和所有非零整数 $p$，混叠的索引 $k+pM$ 都落在此范围之外。\n也就是说，我们需要对于所有 $|k| \\le N$ 和 $p \\in \\mathbb{Z} \\setminus \\{0\\}$，都有 $|k+pM|  2N$。\n\n我们来检查最严格的情况，即 $p = \\pm 1$。\n\n情况 $p=1$：我们需要对于所有 $|k| \\le N$，都有 $|k+M|  2N$。由于 $M$（网格点数）必须为正，当 $k$ 取最小值，即 $k=-N$ 时，$k+M$ 最小。该条件变为：\n$$\n-N + M  2N \\implies M  3N\n$$\n\n情况 $p=-1$：我们需要对于所有 $|k| \\le N$，都有 $|k-M|  2N$。由于 $M$ 将远大于 $N$，因此 $k-M$ 将为负。绝对值 $|k-M| = M-k$ 在 $k$ 取最小值（$k=-N$）时最大，在 $k$ 取最大值（$k=N$）时最小。为了确保该条件对所有 $|k| \\le N$ 都成立，我们必须检查“最坏”情况，即 $|k-M|$ 最小时。这发生在 $k=N$ 时。该条件变为：\n$$\n|N-M|  2N \\implies M-N  2N \\implies M  3N\n$$\n两种情况都得出相同的条件，$M  3N$。对于 $|p| \\ge 2$，对 $M$ 的约束变得不那么严格（例如，对于 $p=2$，我们需要 $M  (3/2)N$），所以 $M  3N$ 是最终的要求。\n\n满足 $M  3N$ 的最小整数网格点数 $M$ 是 $M = 3N+1$。\n\n问题将初始网格点数定义为 $M_0 = 2N+1$，并要求最小填充因子 $s(N) = M/M_0$。使用我们对最小 $M$ 的结果：\n$$\ns(N) = \\frac{M}{M_0} = \\frac{3N+1}{2N+1}\n$$\n这就是众所周知的用于二次非线性项去混叠的“3/2 法则”，因为当 $N$ 很大时，$s(N) \\to 3/2$。\n\n两个最终表达式是 $Q_{\\min}(N)$ 和 $s(N)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\left\\lceil \\frac{3N+1}{2} \\right\\rceil  \\frac{3N+1}{2N+1}\n\\end{pmatrix}\n}\n$$"
        }
    ]
}