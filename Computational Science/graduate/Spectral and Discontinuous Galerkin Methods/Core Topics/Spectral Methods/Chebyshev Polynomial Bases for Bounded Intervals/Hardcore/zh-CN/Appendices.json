{
    "hands_on_practices": [
        {
            "introduction": "在实际应用中，我们经常需要计算由切比雪夫多项式展开的有限项级数。直接对每一项求值再相加可能会因为浮点误差累积而导致数值不稳定，尤其是在接近区间端点时。本练习将指导您实现Clenshaw算法，这是一种利用切比雪夫多项式的三项递推关系进行稳定高效求和的经典方法，是谱方法计算中的一项基本技能。",
            "id": "3370007",
            "problem": "在给定有界区间和多项式基的情况下，谱方法和间断伽辽金 (DG) 方法中的一个关键任务是在指定点对截断级数进行数值稳定的求值。考虑第一类 Chebyshev 多项式，对于 $x \\in [-1,1]$，其定义为 $T_n(x) := \\cos(n \\arccos x)$，其中角度以弧度为单位。这些多项式满足三项递推关系 $T_0(x) = 1$，$T_1(x) = x$，以及对于所有整数 $n \\ge 1$，$T_{n+1}(x) = 2 x T_n(x) - T_{n-1}(x)$。它们在 $[-1,1]$ 上关于权重 $w(x) = (1-x^2)^{-1/2}$ 正交。对于一个一般的物理区间 $[a,b]$，从 $x \\in [a,b]$ 到 Chebyshev 域的典范仿射映射为 $z(x) = \\frac{2x-(a+b)}{b-a}$。\n\n你的任务是实现一个数值稳定的后向递推（Clenshaw 算法），用于在给定点 $x \\in [-1,1]$ 处对截断的 Chebyshev 级数 $S_N(x) = \\sum_{n=0}^N a_n T_n(x)$ 求值，并且当 $x \\in [a,b]$ 时，在仿射映射下进行求值。你还必须使用定义恒等式 $T_n(x) = \\cos(n \\arccos x)$ 对同一级数进行基准“朴素”求值，并报告每个测试用例中 Clenshaw 结果与朴素结果之间的绝对误差。\n\n从上述核心定义出发，推导出使 Clenshaw 算法在 $[-1,1]$ 上对 Chebyshev 级数保持稳定的必要后向递推结构，并将此结构整合到你的实现中。请使用双精度浮点数运算。\n\n角度必须以弧度处理。\n\n测试套件：\n- 用例 1（一般内部点）：设 $N = 20$，系数为 $a_n = \\frac{(-1)^n}{n+1}$，其中 $n = 0,1,\\dots,20$。在 $x = 0.3$ 处求值。\n- 用例 2（右端点）：$N$ 和 $a_n$ 与用例 1 相同，在 $x = 1$ 处求值。\n- 用例 3（左端点）：$N$ 和 $a_n$ 与用例 1 相同，在 $x = -1$ 处求值。\n- 用例 4（近端点压力测试）：$N$ 和 $a_n$ 与用例 1 相同，在 $x = 1 - 10^{-12}$ 处求值。\n- 用例 5（映射区间求值）：考虑物理区间 $[a,b] = [2,5]$。设 $N = 7$，系数 $b_n$ 满足 $b_7 = 1$ 且当 $n \\ne 7$ 时 $b_n = 0$。首先将 $x = 3.5$ 映射到 $z(x) = \\frac{2x-(a+b)}{b-a}$，然后对 $z(x) \\in [-1,1]$ 使用 Clenshaw 算法求级数值。将 Clenshaw 结果与朴素值 $T_7(z(x)) = \\cos(7 \\arccos(z(x)))$ 进行比较。\n\n对每个用例，计算浮点数形式的绝对误差 $E = |S_N^{\\mathrm{Clenshaw}}(x) - S_N^{\\mathrm{naive}}(x)|$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含五个误差，以逗号分隔的列表形式用方括号括起来，顺序与上述用例描述的顺序一致，例如 $[e_1,e_2,e_3,e_4,e_5]$，其中每个 $e_i$ 是一个表示用例 i 绝对误差的浮点数。",
            "solution": "该问题要求实现并比较两种计算截断 Chebyshev 级数 $S_N(x) = \\sum_{n=0}^N a_n T_n(x)$ 的方法。第一种方法是 Clenshaw 算法，这是一种数值稳定的后向递推方法。第二种是基于三角函数定义 $T_n(x) = \\cos(n \\arccos x)$ 的“朴素”求值方法。我们必须为几个测试用例计算这两种方法结果之间的绝对误差。\n\n### 基于原理的设计与推导\n\n对于满足三项递推关系的函数之和的求值，通常可以使用 Clenshaw 算法高效且稳定地执行。该算法是用于多项式求值的 Horner 方法的推广，它避免了直接对各项求和可能带来的数值不稳定性，因为直接求和容易出现相消误差和误差累积。\n\n#### 1. Chebyshev 级数的 Clenshaw 算法推导\n\n第一类 Chebyshev 多项式 $T_n(x)$ 满足三项递推关系：\n$$ T_{n+1}(x) = 2x T_n(x) - T_{n-1}(x) \\quad \\text{for } n \\ge 1 $$\n此关系在 $T_0(x) = 1$ 和 $T_1(x) = x$ 时成立。\n\n我们希望计算和 $S_N(x) = \\sum_{n=0}^N a_n T_n(x)$。我们可以将递推关系重写为 $T_{n-1}(x) = 2x T_n(x) - T_{n+1}(x)$。\n\nClenshaw 算法使用后向递推定义了一个辅助序列，我们称之为 $y_k$。让我们将 $n=0$ 的项从和中分离出来，并关注剩余部分 $S'_N(x) = \\sum_{n=1}^N a_n T_n(x)$。\n\n我们如下定义序列 $y_k$（对于 $k = N, N-1, \\dots, 1$）：\n初始化 $y_{N+2} = 0$ 和 $y_{N+1} = 0$。\n递推关系是：\n$$ y_k = a_k + 2x y_{k+1} - y_{k+2} \\quad \\text{for } k = N, N-1, \\dots, 1 $$\n这使我们可以写出 $a_k = y_k - 2x y_{k+1} + y_{k+2}$。将此代入和 $S'_N(x)$ 中：\n$$ S'_N(x) = \\sum_{n=1}^N (y_n - 2x y_{n+1} + y_{n+2}) T_n(x) $$\n我们可以将其拆分为三个和：\n$$ S'_N(x) = \\sum_{n=1}^N y_n T_n(x) - 2x \\sum_{n=1}^N y_{n+1} T_n(x) + \\sum_{n=1}^N y_{n+2} T_n(x) $$\n通过对第二个和第三个和重新索引，并对每个 $y_k$ 合并项：\n- 对于 $k \\in [3, N]$，$y_k$ 的系数是 $T_k(x) - 2x T_{k-1}(x) + T_{k-2}(x)$。根据递推关系，此式恰好为 $0$。\n- 我们需要检查 $k=1, 2$ 的边界项以及涉及 $y_{N+1}, y_{N+2}$ 的项，这些项被定义为零。\n\n等等，重新索引没有做对。让我们更正式一些。\n$ \\sum_{n=1}^N y_n T_n(x) = y_1 T_1 + y_2 T_2 + \\sum_{n=3}^N y_n T_n(x) $\n$ -2x\\sum_{n=1}^N y_{n+1} T_n(x) = -2x y_2 T_1 -2x \\sum_{n=2}^{N-1} y_{n+1} T_n(x) -2x y_{N+1}T_N(x) $。改变索引 $k=n+1$：$-2x \\sum_{k=3}^N y_k T_{k-1}(x)$。\n$ \\sum_{n=1}^N y_{n+2} T_n(x) = \\sum_{k=3}^{N+2} y_k T_{k-2}(x) = \\sum_{k=3}^N y_k T_{k-2}(x) $ 因为 $y_{N+1}=y_{N+2}=0$。\n\n合并所有项：\n$$ S'_N(x) = y_1 T_1(x) + y_2 T_2(x) - 2x y_2 T_1(x) + \\sum_{k=3}^N y_k (T_k(x) - 2x T_{k-1}(x) + T_{k-2}(x)) $$\n由于递推关系，从 $k=3$ 到 $N$ 的和消失了。剩余部分是：\n$$ S'_N(x) = y_1 T_1(x) + y_2 (T_2(x) - 2x T_1(x)) $$\n使用 $T_1(x)=x$ 和 $T_2(x)=2x^2-1$，我们得到 $T_2(x) - 2x T_1(x) = (2x^2-1) - 2x(x) = -1 = -T_0(x)$。\n所以，$S'_N(x) = y_1 T_1(x) - y_2 T_0(x) = x y_1 - y_2$。\n\n总和为 $S_N(x) = a_0 T_0(x) + S'_N(x)$。由于 $T_0(x)=1$，我们有：\n$$ S_N(x) = a_0 + x y_1 - y_2 $$\n这是 Clenshaw 求值的最终公式。该算法是：\n1.  初始化 $y_{N+1} = 0$, $y_{N+2} = 0$。\n2.  对于 $k = N, N-1, \\dots, 1$，计算 $y_k = a_k + (2x) y_{k+1} - y_{k+2}$。\n3.  和为 $S_N(x) = a_0 + x y_1 - y_2$。\n\n#### 2. 朴素求值方法\n\n朴素方法直接使用定义 $T_n(x) = \\cos(n \\arccos x)$。和的计算方式如下：\n$$ S_N(x) = \\sum_{n=0}^N a_n \\cos(n \\arccos x) $$\n该算法是：\n1.  计算 $\\theta = \\arccos(x)$。\n2.  初始化和 $S = 0$。\n3.  对于 $n = 0, 1, \\dots, N$，计算 $T_n(x) = \\cos(n\\theta)$ 并将 $a_n T_n(x)$ 加到 $S$ 上。\n\n这种方法可能会有数值不精确的问题。当 $x$ 接近 $\\pm 1$ 时，函数 $\\arccos(x)$ 是病态的， $x$ 中的小误差可能导致 $\\theta$ 中的较大误差。随后对各项进行求和，特别是当这些项符号交替且幅值相近时（如用例 1-4），可能导致精度损失。\n\n### 测试用例的实现\n\n实现将包括两个函数 `eval_clenshaw` 和 `eval_naive`，对应于上面推导的算法。这两个函数都将系数数组和求值点 $x$ 作为输入。\n\n-   对于用例 1-4，我们使用 $N=20$ 和系数 $a_n = \\frac{(-1)^n}{n+1}$，在给定的点 $x \\in [-1,1]$ 进行求值。\n-   对于用例 5，物理区间为 $[a,b] = [2,5]$。求值点为 $x_{\\text{phys}} = 3.5$。我们首先使用给定的仿射映射将其映射到典范区间 $[-1,1]$：\n    $$ z(x) = \\frac{2x-(a+b)}{b-a} \\implies z(3.5) = \\frac{2(3.5)-(2+5)}{5-2} = \\frac{7-7}{3} = 0 $$\n    该级数的系数 $b_n$ 满足 $b_7=1$ 且对于 $n \\in [0,7]$ 的所有其他 $b_n=0$。因此，我们在点 $z=0$ 处用这些系数对 $N=7$ 的和进行求值。\n\n对每个用例，绝对误差计算为 $E = |S_N^{\\mathrm{Clenshaw}}(x) - S_N^{\\mathrm{naive}}(x)|$。我们在所有计算中使用双精度浮点数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing and comparing Clenshaw's algorithm and a naive\n    evaluation for Chebyshev series, then reporting the absolute errors.\n    \"\"\"\n\n    def eval_clenshaw(coeffs: np.ndarray, x: float) -> float:\n        \"\"\"\n        Evaluates a Chebyshev series using Clenshaw's algorithm.\n        S_N(x) = sum_{n=0 to N} coeffs[n] * T_n(x)\n        \"\"\"\n        N = len(coeffs) - 1\n        if N < 0:\n            return 0.0\n        if N == 0:\n            return coeffs[0]\n\n        # In correspondence with the derivation: y_{N+1} and y_{N+2} are 0.\n        # d1 holds y_{k+1} and d2 holds y_{k+2} in the loop.\n        d1 = 0.0\n        d2 = 0.0\n        x2 = 2.0 * x\n        \n        # Backward recurrence for k = N, N-1, ..., 1\n        for k in range(N, 0, -1):\n            d_new = coeffs[k] + x2 * d1 - d2\n            d2 = d1\n            d1 = d_new\n        \n        # After the loop, d1 corresponds to y_1 and d2 to y_2.\n        # The sum is a_0 + x*y_1 - y_2\n        return coeffs[0] + x * d1 - d2\n\n    def eval_naive(coeffs: np.ndarray, x: float) -> float:\n        \"\"\"\n        Evaluates a Chebyshev series using the direct definition T_n(x) = cos(n*arccos(x)).\n        \"\"\"\n        N = len(coeffs) - 1\n        if N < 0:\n            return 0.0\n\n        # Clip x to avoid domain errors in arccos due to floating point inaccuracies\n        x_clipped = np.clip(x, -1.0, 1.0)\n        theta = np.arccos(x_clipped)\n        \n        s = 0.0\n        for n in range(N + 1):\n            T_n = np.cos(n * theta)\n            s += coeffs[n] * T_n\n        \n        return s\n\n    test_cases = [\n        # (N, coeffs_generator, x, mapping_params)\n        (20, lambda n: (-1)**n / (n + 1), 0.3, None),  # Case 1\n        (20, lambda n: (-1)**n / (n + 1), 1.0, None),  # Case 2\n        (20, lambda n: (-1)**n / (n + 1), -1.0, None), # Case 3\n        (20, lambda n: (-1)**n / (n + 1), 1.0 - 1e-12, None), # Case 4\n        (7, lambda n: 1.0 if n == 7 else 0.0, 3.5, (2.0, 5.0)), # Case 5\n    ]\n\n    results = []\n    for N, coeff_gen, x_val, mapping in test_cases:\n        coeffs = np.array([coeff_gen(n) for n in range(N + 1)], dtype=np.float64)\n        \n        x_eval = x_val\n        if mapping:\n            a, b = mapping\n            x_eval = (2.0 * x_val - (a + b)) / (b - a)\n\n        val_clenshaw = eval_clenshaw(coeffs, x_eval)\n        val_naive = eval_naive(coeffs, x_eval)\n        \n        error = np.abs(val_clenshaw - val_naive)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "切比雪夫多项式不仅用于函数逼近，更是求解微分方程谱方法中的核心工具。本练习将通过Tau方法探讨如何求解一个带有边界条件的常微分方程。您将学习如何利用问题内在的奇偶对称性来解耦线性系统，从而简化计算并改善问题的数值适定性，这是谱方法实践中提高效率和精度的重要技巧。",
            "id": "3370039",
            "problem": "考虑区间 $[-1,1]$ 和第一类切比雪夫多项式 $T_{n}(x)$，其定义为 $T_{n}(\\cos\\theta)=\\cos(n\\theta)$，其中 $\\theta\\in[0,\\pi]$。它们满足奇偶关系 $T_{n}(-x)=(-1)^{n}T_{n}(x)$ 和带权正交关系\n$$\n\\int_{-1}^{1}\\frac{T_{m}(x)T_{n}(x)}{\\sqrt{1-x^{2}}}\\,\\mathrm{d}x = \\begin{cases} \\pi, & n=m=0, \\\\ \\frac{\\pi}{2}, & n=m\\ge 1, \\\\ 0, & n\\ne m. \\end{cases}\n$$\n定义关于内积 $\\langle u,v\\rangle=\\int_{-1}^{1}u(x)v(x)\\,(1-x^{2})^{-1/2}\\,\\mathrm{d}x$ 的标准正交切比雪夫基为 $\\widehat{T}_{0}(x)=T_{0}(x)/\\sqrt{\\pi}$ 和 $\\widehat{T}_{n}(x)=T_{n}(x)/\\sqrt{\\pi/2}$（对于 $n\\ge 1$）。考虑 $[-1,1]$ 上的对称边值问题，其具有狄利克雷边界条件 $u(-1)=0$ 和 $u(1)=0$，且右端项为偶函数，因此精确解为偶函数。在 $(N+1)$ 维试验空间 $\\mathcal{V}_{N}=\\operatorname{span}\\{\\widehat{T}_{0},\\widehat{T}_{1},\\ldots,\\widehat{T}_{N}\\}$（其中 $N=3$）中，使用 Tau 方法逼近 $u$：对前 $N-1$ 个测试模态，使用恒等算子作为模型双线性形式 $\\langle u,v\\rangle$，在带权 $L^{2}$ 意义下施加内部方程；并将两个狄利克雷边界条件作为 Tau 约束施加在最后两个方程中。这为 $u$ 在基 $\\{\\widehat{T}_{n}\\}_{n=0}^{3}$ 中的系数产生了一个方形线性系统 $A_{\\text{full}}\\in\\mathbb{R}^{4\\times 4}$。\n\n仅使用上述基本定义，完成以下任务：\n\n1. 对于 $N=3$，通过写出对应于使用 $\\widehat{T}_{0}$ 和 $\\widehat{T}_{1}$ 进行测试的两个内部方程，以及用 $u$ 在基 $\\{\\widehat{T}_{n}\\}_{n=0}^{3}$ 中的系数向量表示的两个边界方程 $u(1)=0$ 和 $u(-1)=0$，来推导 $A_{\\text{full}}$ 的显式元素。然后说明奇偶性如何将该系统解耦为偶子空间和奇子空间。\n\n2. 利用精确解的偶对称性，将逼近空间简化为偶子空间 $\\mathcal{V}_{N}^{\\text{even}}=\\operatorname{span}\\{\\widehat{T}_{0},\\widehat{T}_{2}\\}$ 及相应的测试空间，用适用于偶函数的单个约束 $u(1)=0$ 替代两个边界方程。推导简化的 $2\\times 2$ 系统矩阵 $A_{\\text{even}}$。\n\n3. 通过构建 $A_{\\text{full}}^{\\mathsf{T}}A_{\\text{full}}$ 和 $A_{\\text{even}}^{\\mathsf{T}}A_{\\text{even}}$，求出其闭式特征值，并取平方根，直接根据 $A_{\\text{full}}$ 和 $A_{\\text{even}}$ 的奇异值计算谱二范数条件数 $\\kappa_{2}(A_{\\text{full}})$ 和 $\\kappa_{2}(A_{\\text{even}})$。最后给出比率\n$$\nR \\equiv \\frac{\\kappa_{2}(A_{\\text{full}})}{\\kappa_{2}(A_{\\text{even}})}.\n$$\n的精确解析表达式。\n\n你的最终答案必须是 $R$ 作为 $\\pi$ 的函数的闭式表达式。不允许进行数值取整，也不需要单位。在你的推导过程中，请明确说明你引入的任何辅助代数量，但最终答案必须是 $R$ 的单个解析表达式。",
            "solution": "### 解答\n\n按照要求，解答分为三部分。未知系数向量对于完整系统是 $\\hat{\\mathbf{u}} = [\\hat{u}_0, \\hat{u}_1, \\hat{u}_2, \\hat{u}_3]^{\\mathsf{T}}$，对于简化系统是 $\\hat{\\mathbf{u}}_{\\text{even}} = [\\hat{u}_0, \\hat{u}_2]^{\\mathsf{T}}$。\n\n#### 1. $A_{\\text{full}}$ 的推导与奇偶性解耦\n\n逼近式为 $u_3(x) = \\sum_{n=0}^{3} \\hat{u}_n \\widehat{T}_n(x)$。用于求解系数 $\\hat{u}_n$ 的 $4 \\times 4$ 线性系统构建如下：\n\n前两个方程来自内部问题，通过对 $\\widehat{T}_0$ 和 $\\widehat{T}_1$ 进行测试得到：\n- 对于 $k=0$：$\\langle u_3, \\widehat{T}_0 \\rangle = \\sum_{n=0}^{3} \\hat{u}_n \\langle \\widehat{T}_n, \\widehat{T}_0 \\rangle = \\hat{u}_0$。方程为 $\\hat{u}_0 = \\hat{f}_0$。\n- 对于 $k=1$：$\\langle u_3, \\widehat{T}_1 \\rangle = \\sum_{n=0}^{3} \\hat{u}_n \\langle \\widehat{T}_n, \\widehat{T}_1 \\rangle = \\hat{u}_1$。方程为 $\\hat{u}_1 = \\hat{f}_1$。\n这给出了 $A_{\\text{full}}$ 的前两行是 $[1, 0, 0, 0]$ 和 $[0, 1, 0, 0]$。\n\n接下来两个方程是边界约束。我们使用性质 $T_n(1)=1$（对于所有 $n \\ge 0$）和 $T_n(-1)=(-1)^n$。边界上的标准正交基函数为：\n$\\widehat{T}_0(1) = 1/\\sqrt{\\pi}$，$\\widehat{T}_n(1) = \\sqrt{2/\\pi}$（对于 $n \\ge 1$）。\n$\\widehat{T}_0(-1) = 1/\\sqrt{\\pi}$，$\\widehat{T}_n(-1) = (-1)^n \\sqrt{2/\\pi}$（对于 $n \\ge 1$）。\n\n- 在 $x=1$ 处的边界条件：$u_3(1) = \\sum_{n=0}^{3} \\hat{u}_n \\widehat{T}_n(1) = \\hat{u}_0 \\frac{1}{\\sqrt{\\pi}} + \\hat{u}_1 \\frac{\\sqrt{2}}{\\sqrt{\\pi}} + \\hat{u}_2 \\frac{\\sqrt{2}}{\\sqrt{\\pi}} + \\hat{u}_3 \\frac{\\sqrt{2}}{\\sqrt{\\pi}} = 0$。\n- 在 $x=-1$ 处的边界条件：$u_3(-1) = \\sum_{n=0}^{3} \\hat{u}_n \\widehat{T}_n(-1) = \\hat{u}_0 \\frac{1}{\\sqrt{\\pi}} - \\hat{u}_1 \\frac{\\sqrt{2}}{\\sqrt{\\pi}} + \\hat{u}_2 \\frac{\\sqrt{2}}{\\sqrt{\\pi}} - \\hat{u}_3 \\frac{\\sqrt{2}}{\\sqrt{\\pi}} = 0$。\n\n完整的系统矩阵 $A_{\\text{full}}$ 是：\n$$\nA_{\\text{full}} = \\begin{pmatrix}\n1  & 0  & 0  & 0 \\\\\n0  & 1  & 0  & 0 \\\\\n\\frac{1}{\\sqrt{\\pi}}  & \\frac{\\sqrt{2}}{\\sqrt{\\pi}}  & \\frac{\\sqrt{2}}{\\sqrt{\\pi}}  & \\frac{\\sqrt{2}}{\\sqrt{\\pi}} \\\\\n\\frac{1}{\\sqrt{\\pi}}  & -\\frac{\\sqrt{2}}{\\sqrt{\\pi}}  & \\frac{\\sqrt{2}}{\\sqrt{\\pi}}  & -\\frac{\\sqrt{2}}{\\sqrt{\\pi}}\n\\end{pmatrix}.\n$$\n\n为了展示奇偶性解耦，我们通过对原始两个边界方程求和与求差来考虑一组新的边界方程：\n1. $u_3(1) + u_3(-1) = 2 \\left( \\hat{u}_0 \\frac{1}{\\sqrt{\\pi}} + \\hat{u}_2 \\frac{\\sqrt{2}}{\\sqrt{\\pi}} \\right) = 0$。该方程只涉及偶基函数（$\\widehat{T}_0, \\widehat{T}_2$）的系数。\n2. $u_3(1) - u_3(-1) = 2 \\left( \\hat{u}_1 \\frac{\\sqrt{2}}{\\sqrt{\\pi}} + \\hat{u}_3 \\frac{\\sqrt{2}}{\\sqrt{\\pi}} \\right) = 0$。该方程只涉及奇基函数（$\\widehat{T}_1, \\widehat{T}_3$）的系数。\n\n完整系统解耦为一个关于 $(\\hat{u}_0, \\hat{u}_2)$ 的偶模态系统和一个关于 $(\\hat{u}_1, \\hat{u}_3)$ 的奇模态系统。由于精确解是偶函数，我们期望 $\\hat{u}_1=0$ 和 $\\hat{u}_3=0$。确实，由于右端项 $f(x)$ 是偶函数，其在奇模态 $\\widehat{T}_1$ 上的投影为零，因此 $\\hat{f}_1=0$，系统的第二个方程给出 $\\hat{u}_1=0$。第二个解耦的边界方程则给出 $\\hat{u}_3=0$。\n\n#### 2. $A_{\\text{even}}$ 的推导\n\n我们利用偶对称性，将试验空间限制为 $\\mathcal{V}_{3}^{\\text{even}}=\\operatorname{span}\\{\\widehat{T}_{0},\\widehat{T}_{2}\\}$。逼近式为 $u_{\\text{even}}(x) = \\hat{u}_0 \\widehat{T}_0(x) + \\hat{u}_2 \\widehat{T}_2(x)$。我们需要两个方程来求解两个未知数 $\\hat{u}_0, \\hat{u}_2$。\n对于偶函数，两个边界条件 $u(1)=0$ 和 $u(-1)=0$ 不是独立的，因为 $u(-1)=u(1)$。我们使用一个内部方程和一个边界约束。\n- 内部方程通过对第一个偶基函数 $\\widehat{T}_0$ 进行测试得到：$\\langle u_{\\text{even}}, \\widehat{T}_0 \\rangle = \\hat{u}_0$。这给出行向量 $[1, 0]$。\n- 边界约束是 $u_{\\text{even}}(1) = \\hat{u}_0 \\widehat{T}_0(1) + \\hat{u}_2 \\widehat{T}_2(1) = \\hat{u}_0 \\frac{1}{\\sqrt{\\pi}} + \\hat{u}_2 \\frac{\\sqrt{2}}{\\sqrt{\\pi}} = 0$。这给出行向量 $[\\frac{1}{\\sqrt{\\pi}}, \\frac{\\sqrt{2}}{\\sqrt{\\pi}}]$。\n\n简化的系统矩阵 $A_{\\text{even}}$ 是：\n$$\nA_{\\text{even}} = \\begin{pmatrix}\n1  & 0 \\\\\n\\frac{1}{\\sqrt{\\pi}}  & \\frac{\\sqrt{2}}{\\sqrt{\\pi}}\n\\end{pmatrix}.\n$$\n\n#### 3. 条件数与比值 $R$\n\n谱条件数是 $\\kappa_2(A) = \\sigma_{\\max}(A)/\\sigma_{\\min}(A)$，其中奇异值 $\\sigma_i(A)$ 是 $A^{\\mathsf{T}}A$ 的特征值的平方根。\n\n**$A_{\\text{full}}$ 的条件数**：\n我们计算 $A_{\\text{full}}^{\\mathsf{T}}A_{\\text{full}}$：\n$$\nA_{\\text{full}}^{\\mathsf{T}}A_{\\text{full}} = \\frac{1}{\\pi} \\begin{pmatrix}\n\\pi+2  & 0  & 2\\sqrt{2}  & 0 \\\\\n0  & \\pi+4  & 0  & 4 \\\\\n2\\sqrt{2}  & 0  & 4  & 0 \\\\\n0  & 4  & 0  & 4\n\\end{pmatrix}.\n$$\n在置换索引后，该矩阵是块对角的。特征值是这两个 $2 \\times 2$ 子矩阵块的特征值。\n偶块：$M_e = \\frac{1}{\\pi}\\begin{pmatrix} \\pi+2 & 2\\sqrt{2} \\\\ 2\\sqrt{2} & 4 \\end{pmatrix}$。其关于特征值 $\\lambda$ 的特征方程是 $\\lambda^2 - \\frac{\\pi+6}{\\pi}\\lambda + \\frac{4}{\\pi} = 0$。\n特征值为 $\\lambda_{e, \\pm} = \\frac{1}{2\\pi} (\\pi+6 \\pm \\sqrt{\\pi^2 - 4\\pi + 36})$。\n奇块：$M_o = \\frac{1}{\\pi}\\begin{pmatrix} \\pi+4 & 4 \\\\ 4 & 4 \\end{pmatrix}$。其特征方程是 $\\lambda^2 - \\frac{\\pi+8}{\\pi}\\lambda + \\frac{4}{\\pi} = 0$。\n特征值为 $\\lambda_{o, \\pm} = \\frac{1}{2\\pi} (\\pi+8 \\pm \\sqrt{\\pi^2 + 64})$。\n\n为了找到 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$，我们必须找出这四个特征值中的最大值和最小值。通过观察和分析，对于 $\\pi > 0$，我们有 $\\pi+8+\\sqrt{\\pi^2+64} > \\pi+6+\\sqrt{\\pi^2-4\\pi+36}$ 和 $\\pi+8-\\sqrt{\\pi^2+64} < \\pi+6-\\sqrt{\\pi^2-4\\pi+36}$，后者等价于 $16\\pi > 0$。因此，最大和最小特征值都来自奇块。\n$\\sigma_{\\max}^2(A_{\\text{full}}) = \\lambda_{o,+} = \\frac{\\pi+8 + \\sqrt{\\pi^2+64}}{2\\pi}$。\n$\\sigma_{\\min}^2(A_{\\text{full}}) = \\lambda_{o,-} = \\frac{\\pi+8 - \\sqrt{\\pi^2+64}}{2\\pi}$。\n\n条件数的平方是这些特征值的比值：\n$$\n\\kappa_2(A_{\\text{full}})^2 = \\frac{\\lambda_{o,+}}{\\lambda_{o,-}} = \\frac{\\pi+8 + \\sqrt{\\pi^2+64}}{\\pi+8 - \\sqrt{\\pi^2+64}} = \\frac{(\\pi+8 + \\sqrt{\\pi^2+64})^2}{(\\pi+8)^2 - (\\pi^2+64)} = \\frac{(\\pi+8 + \\sqrt{\\pi^2+64})^2}{16\\pi}.\n$$\n取平方根得到：\n$$\n\\kappa_2(A_{\\text{full}}) = \\frac{\\pi+8 + \\sqrt{\\pi^2+64}}{4\\sqrt{\\pi}}.\n$$\n\n**$A_{\\text{even}}$ 的条件数**：\n我们计算 $A_{\\text{even}}^{\\mathsf{T}}A_{\\text{even}}$：\n$$\nA_{\\text{even}}^{\\mathsf{T}}A_{\\text{even}} = \\begin{pmatrix} 1 & \\frac{1}{\\sqrt{\\pi}} \\\\ 0 & \\frac{\\sqrt{2}}{\\sqrt{\\pi}} \\end{pmatrix} \\begin{pmatrix} 1 & 0 \\\\ \\frac{1}{\\sqrt{\\pi}} & \\frac{\\sqrt{2}}{\\sqrt{\\pi}} \\end{pmatrix} = \\begin{pmatrix} 1+\\frac{1}{\\pi} & \\frac{\\sqrt{2}}{\\pi} \\\\ \\frac{\\sqrt{2}}{\\pi} & \\frac{2}{\\pi} \\end{pmatrix} = \\frac{1}{\\pi} \\begin{pmatrix} \\pi+1 & \\sqrt{2} \\\\ \\sqrt{2} & 2 \\end{pmatrix}.\n$$\n该矩阵的特征值 $\\lambda$ 满足 $\\lambda^2 - \\frac{\\pi+3}{\\pi}\\lambda + \\frac{2}{\\pi}=0$。\n特征值为 $\\lambda_{\\pm} = \\frac{1}{2\\pi} (\\pi+3 \\pm \\sqrt{(\\pi+3)^2 - 8\\pi}) = \\frac{1}{2\\pi} (\\pi+3 \\pm \\sqrt{\\pi^2 - 2\\pi + 9})$。\n这些是 $\\sigma_{\\max}^2(A_{\\text{even}})$ 和 $\\sigma_{\\min}^2(A_{\\text{even}})$。条件数的平方是：\n$$\n\\kappa_2(A_{\\text{even}})^2 = \\frac{\\lambda_{+}}{\\lambda_{-}} = \\frac{\\pi+3 + \\sqrt{\\pi^2 - 2\\pi + 9}}{\\pi+3 - \\sqrt{\\pi^2 - 2\\pi + 9}} = \\frac{(\\pi+3 + \\sqrt{\\pi^2 - 2\\pi + 9})^2}{(\\pi+3)^2 - (\\pi^2 - 2\\pi + 9)} = \\frac{(\\pi+3 + \\sqrt{\\pi^2 - 2\\pi + 9})^2}{8\\pi}.\n$$\n取平方根得到：\n$$\n\\kappa_2(A_{\\text{even}}) = \\frac{\\pi+3 + \\sqrt{\\pi^2 - 2\\pi + 9}}{2\\sqrt{2\\pi}}.\n$$\n\n**比值 $R$**：\n最后，我们计算比值 $R = \\kappa_{2}(A_{\\text{full}}) / \\kappa_{2}(A_{\\text{even}})$：\n$$\nR = \\frac{\\frac{\\pi+8 + \\sqrt{\\pi^2+64}}{4\\sqrt{\\pi}}}{\\frac{\\pi+3 + \\sqrt{\\pi^2 - 2\\pi + 9}}{2\\sqrt{2\\pi}}} = \\frac{\\pi+8 + \\sqrt{\\pi^2+64}}{4\\sqrt{\\pi}} \\cdot \\frac{2\\sqrt{2}\\sqrt{\\pi}}{\\pi+3 + \\sqrt{\\pi^2 - 2\\pi + 9}}.\n$$\n简化表达式得到：\n$$\nR = \\frac{2\\sqrt{2}}{4} \\frac{\\pi+8 + \\sqrt{\\pi^2+64}}{\\pi+3 + \\sqrt{\\pi^2 - 2\\pi + 9}} = \\frac{\\sqrt{2}}{2} \\frac{\\pi+8 + \\sqrt{\\pi^2+64}}{\\pi+3 + \\sqrt{\\pi^2 - 2\\pi + 9}}.\n$$",
            "answer": "$$ \\boxed{ \\frac{\\sqrt{2}}{2} \\frac{\\pi+8 + \\sqrt{\\pi^2+64}}{\\pi+3 + \\sqrt{\\pi^2 - 2\\pi + 9}} } $$"
        },
        {
            "introduction": "本练习将引导您进入一个更高级的综合性应用：一个逆时问题。我们将从带有噪声的观测数据出发，反演一个扩散过程的初始状态，这在许多科学和工程领域都有重要应用。您将看到切比雪夫多项式作为Sturm-Liouville算子特征函数的优越性，并理解谱截断如何作为一种正则化手段来平衡近似解中的偏差（bias）和方差（variance）。",
            "id": "3370042",
            "problem": "考虑有界区间 $[-1,1]$ 和切比雪夫多项式基 $\\{T_k(x)\\}_{k=0}^{\\infty}$，其中 $T_k(x) = \\cos(k \\arccos x)$。设带权内积由切比雪夫权重 $w(x) = (1-x^2)^{-1/2}$ 定义，因此正交关系为 $\\int_{-1}^{1} T_m(x) T_n(x) w(x)\\,dx = 0$（对于 $m \\neq n$），其中 $\\int_{-1}^{1} T_0(x)^2 w(x)\\,dx = \\pi$ 且 $\\int_{-1}^{1} T_k(x)^2 w(x)\\,dx = \\pi/2$（对于 $k \\ge 1$）。考虑由切比雪夫Sturm–Liouville算子 $\\mathcal{L} u = (1 - x^2) u_{xx} - x u_x$ 生成的扩散，其中 $T_k$ 是满足 $\\mathcal{L} T_k = -k^2 T_k$ 的特征函数。\n\n设初始条件为 $u_0(x) = \\sum_{k=0}^{\\infty} a_k T_k(x)$，其中 $\\{a_k\\}_{k=0}^{\\infty}$ 是未知的切比雪夫系数，并设时间 $t>0$ 时的正向模型为 $u(x,t)$，它是 $u_t = \\mathcal{L} u$ 在 $u(x,0) = u_0(x)$ 条件下的解。通过在切比雪夫基中的谱分解，系数上的正向映射为 $b_k(t) = a_k e^{-k^2 t}$（对于 $k \\in \\mathbb{N}_0$）。假设我们在系数空间中观测到含噪谱数据，\n$$\n\\tilde{b}_k(t) = b_k(t) + \\varepsilon_k,\n$$\n其中 $\\{\\varepsilon_k\\}$ 是独立的、零均值的随机变量，其方差 $\\mathbb{V}[\\varepsilon_k] = \\sigma^2$ 对所有 $k$ 都相同。\n\n我们通过在截断值 $k_c \\in \\mathbb{N}_0$ 处进行谱截断来正则化从 $\\{\\tilde{b}_k(t)\\}$ 估计 $\\{a_k\\}$ 的逆问题。定义估计量\n$$\n\\hat{a}_k =\n\\begin{cases}\n\\tilde{b}_k(t)\\, e^{k^2 t}, & 0 \\le k \\le k_c,\\\\\n0, & k > k_c.\n\\end{cases}\n$$\n重构为 $\\hat{u}_0(x) = \\sum_{k=0}^{\\infty} \\hat{a}_k T_k(x)$。考虑在与切比雪夫权重相关的带权$L^2$范数下度量的误差，\n$$\n\\|f\\|_{L^2_w}^2 := \\int_{-1}^{1} f(x)^2 w(x)\\,dx.\n$$\n\n任务：\n1. 仅从上述算子-特征函数关系、正交性和噪声模型出发，推导预期重构平方误差 $\\mathbb{E}\\left[\\| \\hat{u}_0 - u_0 \\|_{L^2_w}^2\\right]$ 的精确表达式，该表达式是截断值 $k_c$、时间 $t$、噪声水平 $\\sigma^2$ 以及系数 $\\{a_k\\}$ 的函数。\n2. 将真实值具体化为以下系数序列：\n$$\na_0 = 1,\\quad a_k = \\frac{(-1)^k}{(k+1)^2}\\ \\text{for}\\ k \\ge 1.\n$$\n由于求和是无穷的，通过在一个足够大的 $K_{\\max}$ 处截断级数来进行数值近似。就此问题而言，您必须在程序中设置 $K_{\\max} = 500$，并完全如上所述处理 $\\{a_k\\}_{k=0}^{K_{\\max}}$，忽略所有超过 $K_{\\max}$ 的项。\n\n3. 实现一个程序，为以下测试套件中的每个参数集计算预期平方误差 $\\mathbb{E}\\left[\\| \\hat{u}_0 - u_0 \\|_{L^2_w}^2\\right]$，其中每个测试用例是一个元组 $(t, \\sigma, k_c)$：\n- $(t,\\sigma,k_c) = (0.02, 10^{-4}, 0)$，\n- $(t,\\sigma,k_c) = (0.02, 10^{-4}, 5)$，\n- $(t,\\sigma,k_c) = (0.02, 10^{-4}, 20)$，\n- $(t,\\sigma,k_c) = (0.02, 10^{-2}, 20)$，\n- $(t,\\sigma,k_c) = (0.10, 10^{-4}, 10)$。\n\n所有角度（如果出现）必须以弧度为单位。不涉及物理单位。最终输出必须是实数。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），$r_i$ 是按给定顺序的第 $i$ 个测试用例的预期平方误差。输出元素必须是浮点数。",
            "solution": "目标是推导预期重构平方误差的表达式，即 $\\mathbb{E}\\left[\\| \\hat{u}_0 - u_0 \\|_{L^2_w}^2\\right]$。\n\n首先，我们用切比雪夫基 $\\{T_k(x)\\}$ 来表示重构误差 $e(x) = \\hat{u}_0(x) - u_0(x)$。\n给定 $u_0(x) = \\sum_{k=0}^{\\infty} a_k T_k(x)$ 和 $\\hat{u}_0(x) = \\sum_{k=0}^{\\infty} \\hat{a}_k T_k(x)$，差值为：\n$$\ne(x) = \\hat{u}_0(x) - u_0(x) = \\sum_{k=0}^{\\infty} (\\hat{a}_k - a_k) T_k(x)\n$$\n接下来，我们计算关于切比雪夫权重 $w(x)=(1-x^2)^{-1/2}$ 的误差的平方范数：\n$$\n\\|e\\|_{L^2_w}^2 = \\int_{-1}^{1} \\left( \\sum_{k=0}^{\\infty} (\\hat{a}_k - a_k) T_k(x) \\right)^2 w(x) \\, dx\n$$\n通过展开平方并利用切比雪夫多项式的正交性质，即当 $m \\neq n$ 时 $\\int_{-1}^{1} T_m(x) T_n(x) w(x) \\, dx = 0$，该表达式简化为系数平方与基函数范数平方的乘积之和：\n$$\n\\|e\\|_{L^2_w}^2 = \\sum_{k=0}^{\\infty} (\\hat{a}_k - a_k)^2 \\|T_k\\|_{L^2_w}^2\n$$\n平方范数由 $\\|T_0\\|_{L^2_w}^2 = \\pi$ 和 $\\|T_k\\|_{L^2_w}^2 = \\pi/2$（对于 $k \\ge 1$）给出。我们记 $\\gamma_k = \\|T_k\\|_{L^2_w}^2$。因此，$\\gamma_0 = \\pi$，而 $\\gamma_k = \\pi/2$（对于 $k \\ge 1$）。\n$$\n\\|e\\|_{L^2_w}^2 = \\sum_{k=0}^{\\infty} (\\hat{a}_k - a_k)^2 \\gamma_k\n$$\n现在我们取期望 $\\mathbb{E}[\\cdot]$。由于期望是线性算子，它可以移到求和号内部：\n$$\n\\mathbb{E}\\left[\\|e\\|_{L^2_w}^2\\right] = \\sum_{k=0}^{\\infty} \\mathbb{E}\\left[(\\hat{a}_k - a_k)^2\\right] \\gamma_k\n$$\n项 $\\mathbb{E}\\left[(\\hat{a}_k - a_k)^2\\right]$ 是估计量 $\\hat{a}_k$ 的均方误差（MSE）。均方误差可以分解为偏差的平方加上方差：$MSE(\\hat{a}_k) = (\\mathbb{E}[\\hat{a}_k] - a_k)^2 + \\mathbb{V}[\\hat{a}_k]$。我们根据 $\\hat{a}_k$ 的定义分两种情况进行分析。\n\n情况1：$k > k_c$（被截断的模态）\n在这种情况下，估计量为 $\\hat{a}_k = 0$。系数误差为 $\\hat{a}_k - a_k = -a_k$。这是一个确定性量。\n均方误差为 $\\mathbb{E}[(-a_k)^2] = a_k^2$。此误差纯粹来自偏差，因为该估计量没有方差。\n\n情况2：$0 \\le k \\le k_c$（被估计的模态）\n估计量为 $\\hat{a}_k = \\tilde{b}_k(t) e^{k^2 t}$。代入含噪数据模型 $\\tilde{b}_k(t) = b_k(t) + \\varepsilon_k = a_k e^{-k^2 t} + \\varepsilon_k$，我们得到：\n$$\n\\hat{a}_k = (a_k e^{-k^2 t} + \\varepsilon_k)e^{k^2 t} = a_k + \\varepsilon_k e^{k^2 t}\n$$\n为了计算均方误差，我们首先求偏差：\n$$\n\\text{Bias}(\\hat{a}_k) = \\mathbb{E}[\\hat{a}_k] - a_k = \\mathbb{E}[a_k + \\varepsilon_k e^{k^2 t}] - a_k\n$$\n利用期望的线性性质以及 $\\mathbb{E}[\\varepsilon_k] = 0$ 这一事实：\n$$\n\\text{Bias}(\\hat{a}_k) = (a_k + \\mathbb{E}[\\varepsilon_k] e^{k^2 t}) - a_k = a_k + 0 - a_k = 0\n$$\n对于 $0 \\le k \\le k_c$，该估计量是无偏的。\n接下来，我们求方差：\n$$\n\\mathbb{V}[\\hat{a}_k] = \\mathbb{V}[a_k + \\varepsilon_k e^{k^2 t}] = \\mathbb{V}[\\varepsilon_k e^{k^2 t}]\n$$\n使用方差缩放性质 $\\mathbb{V}[cX] = c^2 \\mathbb{V}[X]$：\n$$\n\\mathbb{V}[\\hat{a}_k] = (e^{k^2 t})^2 \\mathbb{V}[\\varepsilon_k] = e^{2k^2 t} \\sigma^2\n$$\n由于偏差为零，对于 $0 \\le k \\le k_c$ 的均方误差等于方差：$\\mathbb{E}[(\\hat{a}_k - a_k)^2] = \\sigma^2 e^{2k^2 t}$。\n\n现在我们通过在 $k_c$ 处分割求和来组合得到总预期误差：\n$$\n\\mathbb{E}\\left[\\|e\\|_{L^2_w}^2\\right] = \\sum_{k=0}^{k_c} \\mathbb{E}\\left[(\\hat{a}_k - a_k)^2\\right] \\gamma_k + \\sum_{k=k_c+1}^{\\infty} \\mathbb{E}\\left[(\\hat{a}_k - a_k)^2\\right] \\gamma_k\n$$\n代入推导出的均方误差表达式：\n$$\n\\mathbb{E}\\left[\\|e\\|_{L^2_w}^2\\right] = \\sum_{k=0}^{k_c} \\left(\\sigma^2 e^{2k^2 t}\\right) \\gamma_k + \\sum_{k=k_c+1}^{\\infty} a_k^2 \\gamma_k\n$$\n此表达式代表了经典的偏差-方差权衡。第一项是方差贡献（噪声误差），它随着 $k_c$ 和 $t$ 的增加而增加。第二项是偏差贡献（截断误差），它随着包含更多模态（即随着 $k_c$ 增加）而减少。\n\n我们可以用 $\\gamma_k$ 的值更明确地写出这个表达式：\n$$\n\\text{噪声误差} = \\sigma^2 e^{2(0)^2 t} \\gamma_0 + \\sum_{k=1}^{k_c} \\sigma^2 e^{2k^2 t} \\gamma_k = \\pi \\sigma^2 + \\frac{\\pi}{2} \\sigma^2 \\sum_{k=1}^{k_c} e^{2k^2 t}\n$$\n如果我们视空和为 $0$，此公式对任何 $k_c \\ge 0$ 都有效。\n偏差误差项对 $k \\ge k_c+1$ 进行求和。由于 $k_c \\ge 0$，这个和总是从 $k \\ge 1$ 开始，所以此和中所有项的 $\\gamma_k = \\pi/2$。\n$$\n\\text{偏差误差} = \\sum_{k=k_c+1}^{\\infty} a_k^2 \\frac{\\pi}{2} = \\frac{\\pi}{2} \\sum_{k=k_c+1}^{\\infty} a_k^2\n$$\n总预期平方误差是这两个分量的和。\n\n对于数值实现（任务2和3），我们针对给定的系数 $a_0 = 1$ 和 $a_k = (-1)^k/(k+1)^2$（对于 $k \\ge 1$）进行具体化。问题指出，无穷和必须在 $K_{\\max}=500$ 处截断。这意味着我们实际上是为 $k>K_{\\max}$ 设定 $a_k=0$。偏差和变为：\n$$\n\\text{偏差误差} \\approx \\frac{\\pi}{2} \\sum_{k=k_c+1}^{K_{\\max}} a_k^2\n$$\n用于计算的最终公式为：\n$$\n\\mathbb{E}\\left[\\|e\\|_{L^2_w}^2\\right] \\approx \\left(\\pi \\sigma^2 + \\frac{\\pi}{2} \\sigma^2 \\sum_{k=1}^{k_c} e^{2k^2 t}\\right) + \\left(\\frac{\\pi}{2} \\sum_{k=k_c+1}^{K_{\\max}} \\left(\\frac{(-1)^k}{(k+1)^2}\\right)^2\\right)\n$$\n\n此公式将用于计算给定测试用例的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the expected squared reconstruction error\n    for a regularized inverse problem involving a Chebyshev spectral representation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple (t, sigma, k_c).\n    test_cases = [\n        (0.02, 1e-4, 0),\n        (0.02, 1e-4, 5),\n        (0.02, 1e-4, 20),\n        (0.02, 1e-2, 20),\n        (0.10, 1e-4, 10),\n    ]\n\n    # Global parameter from the problem statement\n    K_max = 500\n\n    # Pre-compute the ground truth coefficients a_k up to K_max\n    # a_k = 0 for k > K_max is implicitly handled by the summation limits.\n    a = np.zeros(K_max + 1)\n    a[0] = 1.0\n    k_vals_for_a = np.arange(1, K_max + 1)\n    a[1:] = ((-1.0)**k_vals_for_a) / ((k_vals_for_a + 1.0)**2)\n\n    results = []\n    for t, sigma, kc in test_cases:\n        # 1. Calculate the Noise Error contribution\n        # Noise Error = sum_{k=0}^{k_c} (sigma^2 * exp(2*k^2*t)) * gamma_k\n        # where gamma_0 = pi and gamma_k = pi/2 for k >= 1.\n        \n        # We can write this as:\n        # pi * sigma^2 + (pi/2) * sigma^2 * sum_{k=1}^{k_c} exp(2*k^2*t)\n        \n        noise_error = 0.0\n        # The term for k=0 is always present as long as kc >= 0\n        noise_error_k0 = np.pi * sigma**2\n        \n        noise_error_k_gt_0 = 0.0\n        if kc > 0:\n            k_noise = np.arange(1, kc + 1)\n            sum_exp = np.sum(np.exp(2 * k_noise**2 * t))\n            noise_error_k_gt_0 = (np.pi / 2.0) * sigma**2 * sum_exp\n            \n        noise_error = noise_error_k0 + noise_error_k_gt_0\n\n        # 2. Calculate the Bias Error contribution\n        # Bias Error = sum_{k=k_c+1}^{K_max} a_k^2 * gamma_k\n        # Since the sum starts from k >= 1, gamma_k is always pi/2.\n        \n        bias_error = 0.0\n        if kc < K_max:\n            # Slicing goes up to K_max, so the upper index is K_max + 1\n            a_sq_sum = np.sum(a[kc + 1 : K_max + 1]**2)\n            bias_error = (np.pi / 2.0) * a_sq_sum\n\n        # 3. Total expected squared error\n        total_error = noise_error + bias_error\n        results.append(total_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}