{
    "hands_on_practices": [
        {
            "introduction": "勒让德多项式的一个核心优势在于其正交性，这极大地简化了伽辽金投影的计算。本练习将引导你通过推导来理解，在一个正交基中，展开式的系数是彼此独立的，这使得增加近似解的阶数变得异常高效 。掌握这一原理对于理解谱方法为何高效至关重要。",
            "id": "3395701",
            "problem": "考虑一维参考单元 $\\Omega = [-1,1]$，其具有标准勒让德多项式基 $\\{P_{n}(x)\\}_{n\\geq 0}$，其中 $P_{n}(1)=1$，内积定义为 $\\langle f,g\\rangle = \\int_{-1}^{1} f(x)\\,g(x)\\,\\mathrm{d}x$。假设一个谱方法或间断伽辽金离散化，其中模态逼近使用非标准正交的勒让德基 $\\{P_{n}\\}$。\n\n设精确目标函数为 $u(x)=\\exp(\\beta x)$，其中 $\\beta\\in\\mathbb{R}$ 是一个固定参数。你已有一个通过在$L^{2}(\\Omega)$范数下到 $\\operatorname{span}\\{P_{0},P_{1},\\dots,P_{p}\\}$ 上的最小二乘投影构造的$p$阶模态解。现要求将逼近空间扩充到$p+2$阶（即包含 $P_{p+1}$ 和 $P_{p+2}$），并仅使用正交性和内积关系，以闭合形式确定新模态 $P_{p+1}$ 和 $P_{p+2}$ 的最小二乘系数。\n\n请推导这两个扩充系数作为 $p$ 和 $\\beta$ 的解析函数的表达式，并以包含这两个系数的单行矩阵形式提供最终答案。无需进行数值四舍五入。",
            "solution": "该问题要求当函数 $u(x) = \\exp(\\beta x)$ 的$p$阶谱逼近被扩充到$(p+2)$阶逼近时，确定基函数 $P_{p+1}(x)$ 和 $P_{p+2}(x)$ 的系数。该逼近被定义为在 $L^2(\\Omega)$ 范数下的最小二乘投影，其中 $\\Omega = [-1,1]$。\n\n令 $u(x)$ 的$N$阶逼近记为 $u_N(x)$，表示为勒让德基多项式 $\\{P_n(x)\\}_{n=0}^N$ 的线性组合：\n$$u_N(x) = \\sum_{n=0}^{N} \\hat{u}_n P_n(x)$$\n系数 $\\hat{u}_n$ 由最小二乘投影确定，这等价于伽辽金条件，即误差 $u(x) - u_N(x)$ 与逼近空间 $\\operatorname{span}\\{P_0, \\dots, P_N\\}$ 正交。该条件表示为：\n$$\\langle u - u_N, v \\rangle = 0, \\quad \\forall v \\in \\operatorname{span}\\{P_0, \\dots, P_N\\}$$\n通过为 $k \\in \\{0, 1, \\dots, N\\}$ 选择基函数 $v = P_k(x)$，我们得到一组方程：\n$$\\langle u(x) - \\sum_{n=0}^{N} \\hat{u}_n P_n(x), P_k(x) \\rangle = 0$$\n$$\\langle u, P_k \\rangle - \\sum_{n=0}^{N} \\hat{u}_n \\langle P_n, P_k \\rangle = 0$$\n标准勒让德多项式在区间 $[-1,1]$ 上关于给定的内积 $\\langle f,g\\rangle = \\int_{-1}^{1} f(x)g(x)\\,\\mathrm{d}x$ 构成一个正交基。它们的正交性质是：\n$$\\langle P_n, P_k \\rangle = \\int_{-1}^{1} P_n(x) P_k(x) \\,\\mathrm{d}x = \\frac{2}{2n+1} \\delta_{nk}$$\n其中 $\\delta_{nk}$ 是克罗内克（Kronecker）delta函数。问题中“非标准正交”的表述意为基向量未被归一化为单位范数（即 $\\langle P_n, P_n\\rangle \\neq 1$）但它们是正交的，这是正确的。这种正交性是至关重要的，并且题目明确要求使用它。\n\n将正交性质代入伽辽金条件，求和式坍缩为 $n=k$ 的单项：\n$$\\langle u, P_k \\rangle - \\hat{u}_k \\langle P_k, P_k \\rangle = 0$$\n这允许独立地直接计算每个系数 $\\hat{u}_k$：\n$$\\hat{u}_k = \\frac{\\langle u, P_k \\rangle}{\\langle P_k, P_k \\rangle} = \\frac{\\int_{-1}^{1} u(x) P_k(x) \\,\\mathrm{d}x}{\\frac{2}{2k+1}} = \\frac{2k+1}{2} \\int_{-1}^{1} u(x) P_k(x) \\,\\mathrm{d}x$$\n该公式对展开式中的任何系数 $\\hat{u}_k$ 都有效。正交性的一个关键推论是，系数 $\\hat{u}_k$ 仅取决于 $u(x)$ 和 $P_k(x)$，而不取决于逼近空间的维度。因此，当将逼近从$p$阶扩充到$p+2$阶时，系数 $\\hat{u}_0, \\dots, \\hat{u}_p$ 保持不变。我们需要找到的新系数是针对模态 $P_{p+1}(x)$ 和 $P_{p+2}(x)$ 的系数，它们就是 $\\hat{u}_{p+1}$ 和 $\\hat{u}_{p+2}$。\n\n目标函数是 $u(x) = \\exp(\\beta x)$。系数为：\n$$\\hat{u}_{p+1} = \\frac{2(p+1)+1}{2} \\int_{-1}^{1} \\exp(\\beta x) P_{p+1}(x) \\,\\mathrm{d}x = \\frac{2p+3}{2} \\int_{-1}^{1} \\exp(\\beta x) P_{p+1}(x) \\,\\mathrm{d}x$$\n$$\\hat{u}_{p+2} = \\frac{2(p+2)+1}{2} \\int_{-1}^{1} \\exp(\\beta x) P_{p+2}(x) \\,\\mathrm{d}x = \\frac{2p+5}{2} \\int_{-1}^{1} \\exp(\\beta x) P_{p+2}(x) \\,\\mathrm{d}x$$\n为了继续，我们需要计算积分 $\\int_{-1}^{1} \\exp(\\beta x) P_n(x) \\,\\mathrm{d}x$。这是特殊函数理论中的一个标准积分。结果以第一类修正球贝塞尔函数给出，记为 $i_n(z)$：\n$$\\int_{-1}^{1} \\exp(\\beta x) P_n(x) \\,\\mathrm{d}x = 2 i_n(\\beta)$$\n函数 $i_n(\\beta)$ 是 $\\beta$ 的解析函数，并且可以用初等函数（双曲函数和 $\\beta$ 的幂）表示。例如，$i_0(\\beta) = \\frac{\\sinh(\\beta)}{\\beta}$ 和 $i_1(\\beta) = \\frac{\\cosh(\\beta)}{\\beta} - \\frac{\\sinh(\\beta)}{\\beta^2}$。问题要求系数是 $p$ 和 $\\beta$ 的解析函数，用 $i_n(\\beta)$ 来表示它们是标准的、最紧凑的闭合形式。\n\n将此恒等式代入系数表达式中：\n对于 $P_{p+1}(x)$ 的系数：\n$$\\hat{u}_{p+1} = \\frac{2p+3}{2} \\left( 2 i_{p+1}(\\beta) \\right) = (2p+3) i_{p+1}(\\beta)$$\n对于 $P_{p+2}(x)$ 的系数：\n$$\\hat{u}_{p+2} = \\frac{2p+5}{2} \\left( 2 i_{p+2}(\\beta) \\right) = (2p+5) i_{p+2}(\\beta)$$\n这些就是所需的扩充系数，以 $p$ 和 $\\beta$ 的解析函数的闭合形式给出。最终答案应表示为一个包含这两个表达式的行矩阵。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} (2p+3) i_{p+1}(\\beta) & (2p+5) i_{p+2}(\\beta) \\end{pmatrix} } $$"
        },
        {
            "introduction": "从理论到实践，一个关键步骤是如何处理伽辽金方法中的积分项。本练习将聚焦于间断伽辽金（DG）方法，并引导你分析如何为非线性数值通量的边界积分选择合适的求积法则 。通过精确追踪被积函数的多项式阶数，你将推导出保证积分精确计算所需的最小求积点数，这是确保数值格式稳定性和准确性的关键一环。",
            "id": "3395757",
            "problem": "考虑在一维参考单元（坐标为 $x \\in [-1,1]$）上标量守恒律的间断伽辽金 (DG) 半离散格式。假设试探空间和检验空间由勒让德多项式 $\\{P_{k}(x)\\}_{k=0}^{p}$ 张成，因此任何解 $u_{h}$ 或检验函数 $v_{h}$ 在一个由局部坐标 $s \\in [-1,1]$ 参数化的面上的迹是次数至多为 $p$ 的单变量多项式。假设数值通量是一个两点函数 $\\widehat{f}(u^{-},u^{+})$，当物理通量 $f(u)$ 是次数至多为 $r \\in \\mathbb{N}$ 的多项式时，它本身是关于其自变量总次数至多为 $r$ 的多项式。沿着一个面，DG 面积分涉及检验函数迹 $v_{h}(s)$ 与 $\\widehat{f}(u_{h}^{-}(s),u_{h}^{+}(s))$ 的乘积。\n\n仅使用关于代数运算下多项式次数的基本原理以及勒让德多项式空间的定义性质，确定在一个面上保证对所有 $u_{h},v_{h} \\in \\mathbb{P}_{p}$ 的面积分进行精确计算所需的 Gauss–Legendre 求积点 $N_{q}$ 的最小数量，此时 $\\widehat{f}$ 关于其自变量的总多项式次数至多为 $r$。然后，将您的结果具体化到精确积分次数至多为 $2p$ 的乘积的要求。\n\n以一个双元素行向量的形式提供您的最终答案：第一个元素是作为 $p$ 和 $r$ 的函数的 $N_{q}$，第二个元素是精确积分所有次数不超过 $2p$ 的乘积所需的最小 $N_{q}$。不需要进行数值计算，也不涉及单位。最终答案必须是闭式表达式。",
            "solution": "支配此问题的基本原理是高斯-勒让德（Gauss-Legendre）求积的精确性。在区间 $[-1,1]$ 上的一个 $N_q$ 点高斯-勒让德求积法则可以精确地积分任何次数至多为 $2N_q - 1$ 的多项式。为了找到最小点数 $N_q$，我们必须首先确定多项式被積函数的最大可能次数。\n\n**第 1 部分：面积分求积**\n\n需要计算的面积分形式如下\n$$\nI = \\int_{-1}^{1} v_{h}(s) \\widehat{f}(u_{h}^{-}(s), u_{h}^{+}(s)) \\,ds\n$$\n令被积函数记为 $g(s) = v_{h}(s) \\widehat{f}(u_{h}^{-}(s), u_{h}^{+}(s))$。我们需要找到 $g(s)$ 的最大可能多项式次数，记为 $\\deg(g)$。\n\n1.  **检验函数迹的次数**：检验函数 $v_h$ 属于空间 $\\mathbb{P}_p$，该空间由次数至多为 $p$ 的多项式组成。因此，它在面上的迹 $v_h(s)$ 是面坐标 $s$ 的一个多项式，其次数 $\\deg(v_h(s)) \\le p$。\n\n2.  **解的迹的次数**：类似地，解 $u_h$ 属于 $\\mathbb{P}_p$。它在面上的内部和外部迹 $u_h^-(s)$ 和 $u_h^+(s)$ 是 $s$ 的多项式，各自的次数至多为 $p$。因此，$\\deg(u_h^-(s)) \\le p$ 且 $\\deg(u_h^+(s)) \\le p$。\n\n3.  **数值通量项的次数**：已知数值通量 $\\widehat{f}(A,B)$ 是关于其自变量 $A$ 和 $B$ 的总次数至多为 $r$ 的多项式。这意味着它可以表示为形如 $c_{ij}A^i B^j$（其中 $i+j \\le r$）的项之和。\n    在我们的情况中，自变量是多项式迹，$A = u_h^-(s)$ 和 $B = u_h^+(s)$。在 $\\widehat{f}(u_h^-(s), u_h^+(s))$ 的展开式中，单个项的次数为：\n    $$\n    \\deg\\left( (u_h^-(s))^i (u_h^+(s))^j \\right) = i \\cdot \\deg(u_h^-(s)) + j \\cdot \\deg(u_h^+(s))\n    $$\n    为了找到最大可能次数，我们取迹的最大次数：\n    $$\n    \\deg\\left( (u_h^-(s))^i (u_h^+(s))^j \\right) \\le i \\cdot p + j \\cdot p = (i+j)p\n    $$\n    整个数值通量多项式 $\\widehat{f}(u_h^-(s), u_h^+(s))$ 的次数是其构成项次数的最大值。当和 $i+j$ 最大化时达到此最大值。根据问题陈述， $i+j$ 的最大值为 $r$。\n    因此，作为 $s$ 的多项式，数值通量的最大次数是 $r \\cdot p$。我们将其表示为 $\\deg(\\widehat{f}(\\cdot, \\cdot))_s \\le rp$。\n\n4.  **完整被积函数的次数**：被积函数是乘积 $g(s) = v_h(s) \\cdot \\widehat{f}(u_h^-(s), u_h^+(s))$。多项式乘积的次数是它们次数的和。\n    $$\n    \\deg(g(s)) = \\deg(v_h(s)) + \\deg(\\widehat{f}(u_h^-(s), u_h^+(s)))_s\n    $$\n    因此，被积函数的最大可能次数 $D_{\\text{max}}$ 为：\n    $$\n    D_{\\text{max}} \\le p + rp = p(r+1)\n    $$\n\n5.  **所需的求积点数量**：为了保证精确积分，高斯-勒让德求积法则必须对任何次数高达 $D_{\\text{max}} = p(r+1)$ 的多项式都精确。我们必须满足条件：\n    $$\n    2N_q - 1 \\ge p(r+1)\n    $$\n    对 $N_q$ 求解，我们得到：\n    $$\n    N_q \\ge \\frac{p(r+1) + 1}{2}\n    $$\n    由于 $N_q$ 必须是整数，所需的最小求积点数是满足此不等式的最小整数，由向上取整函数给出：\n    $$\n    N_q = \\left\\lceil \\frac{p(r+1) + 1}{2} \\right\\rceil\n    $$\n\n**第 2 部分：对次数至多为 $2p$ 的乘积的具体化**\n\n第二部分要求计算精确积分总多项式次数至多为 $2p$ 的乘积所需的最小 $N_q$。这是同一求积原理的直接应用。\n\n1.  **被积函数的最大次数**：待积分多项式的最大次数给定为 $D = 2p$。\n\n2.  **所需的求积点数量**：我们直接应用高斯-勒让德求积的精确性条件：\n    $$\n    2N_q - 1 \\ge 2p\n    $$\n    对 $N_q$ 求解：\n    $$\n    2N_q \\ge 2p+1 \\implies N_q \\ge p + \\frac{1}{2}\n    $$\n    由于 $N_q$ 必须是整数，最小点数是大于或等于 $p + 1/2$ 的最小整数，即：\n    $$\n    N_q = p+1\n    $$\n这个结果对应于间断伽辽金方法中精确计算体积积分（例如质量矩阵项 $\\int u_h v_h dx$）的标准要求，其中被积函数是两个来自 $\\mathbb{P}_p$ 的多项式的乘积，结果是一个次数至多为 $2p$ 的多项式。\n\n最终答案是一个包含第 1 部分和第 2 部分结果的双元素行向量。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\left\\lceil \\frac{p(r+1)+1}{2} \\right\\rceil & p+1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "谱方法在逼近光滑函数时表现优异，但在处理间断时则会引发著名的吉布斯（Gibbs）振荡。本练习是一个动手编程任务，要求你量化勒让德级数在逼近一个间断函数时产生的过冲，并检验模态滤波对抑制这种非物理振荡的实际效果 。通过这个实践，你将连接理论与计算，并掌握一种提升谱近似解质量的实用方法。",
            "id": "3395740",
            "problem": "考虑区间 $[-1,1]$ 上的一维参考单元和勒让德多项式基 $\\{P_n(x)\\}_{n=0}^\\infty$，其具有权重为 $1$ 的标准 $L^2([-1,1])$ 内积。设目标函数为阶跃函数 $f(x)=\\operatorname{sign}(x)$，当 $x<0$ 时取值为 $-1$，当 $x\\ge 0$ 时取值为 $+1$。将 $N$ 次勒让德部分和定义为 $f(x)$ 在最高次数为 $N$ 的多项式空间上的 $L^2([-1,1])$ 投影，即\n$$\nS_N(x)=\\sum_{n=0}^N a_n P_n(x),\n$$\n其中勒让德系数由正交关系定义\n$$\na_n=\\frac{2n+1}{2}\\int_{-1}^1 f(x)\\,P_n(x)\\,dx.\n$$\n通过模态系数上的对角乘子定义一个 $s$ 阶模态滤波器：\n$$\n\\sigma_n^{(s)}=\\exp\\!\\left(-\\alpha\\left(\\frac{n}{N}\\right)^s\\right),\\quad n=0,1,\\dots,N,\n$$\n其中 $\\alpha>0$ 为固定值，并将滤波后的部分和设置为\n$$\nS_N^{(s)}(x)=\\sum_{n=0}^N \\big(\\sigma_n^{(s)} a_n\\big) P_n(x).\n$$\n采用以下定量度量来评估吉布斯现象以及模态滤波对其的缓解效果：\n\n1. $x=0$ 处跳跃附近的过冲幅度：对于选定的窗口半宽 $w\\in(0,1)$，定义\n$$\n\\mathcal{O}(N,s;w)=\\max\\Big\\{\\,\\max_{x\\in[0,w]}\\big(S_N^{(s)}(x)-1\\big),\\ \\max_{x\\in[-w,0]}\\big(-S_N^{(s)}(x)-1\\big),\\ 0\\Big\\}.\n$$\n该度量衡量了在间断点周围窗口内，超出局部有界值 $\\pm 1$ 的最大正向偏移。\n\n2. 在 $[-1,1]$ 上 $M$ 个点的均匀网格上，近似的离散 $L^1$ 全变分：对于网格点 $x_i=-1+\\frac{2i}{M-1}$（$i=0,1,\\dots,M-1$）及对应的值 $u_i=S_N^{(s)}(x_i)$，定义\n$$\n\\operatorname{TV}(N,s;M)=\\sum_{i=0}^{M-2} \\big|u_{i+1}-u_i\\big|.\n$$\n\n你的任务是编写一个完整、可运行的程序，该程序能够：\n- 仅使用 $L^2$ 投影的基本正交性定义和经过充分检验的勒让德多项式恒等式，计算 $f(x)=\\operatorname{sign}(x)$ 的勒让德系数 $a_n$。\n- 使用滤波器权重 $\\sigma_n^{(s)}$ 构建滤波后的模态系数。\n- 在网格点上计算 $S_N^{(s)}(x)$ 的值。\n- 计算过冲幅度 $\\mathcal{O}(N,s;w)$ 和离散全变分 $\\operatorname{TV}(N,s;M)$。\n\n你可以使用的科学和算法基础：\n- 勒让德多项式在 $[-1,1]$ 上关于权重 $1$ 的正交性：\n$$\n\\int_{-1}^1 P_m(x)P_n(x)\\,dx=\\frac{2}{2n+1}\\delta_{mn}.\n$$\n- 上述给出的系数 $a_n$ 的 $L^2$ 投影定义。\n- $f(x)=\\operatorname{sign}(x)$ 是奇函数，以及 $P_n(x)$ 的奇偶性为 $(-1)^n$ 这一事实。\n- 一个经过充分检验的勒让德多项式不定积分恒等式：\n$$\n\\int P_n(x)\\,dx=\\frac{P_{n+1}(x)-P_{n-1}(x)}{2n+1}+C,\n$$\n你可以使用它来计算 $P_n(x)$ 在 $[-1,1]$ 子区间上的积分。\n\n除非作为测试套件的一部分进行更改，否则所有计算均使用以下固定参数：\n- 滤波器强度 $\\alpha=36$。\n- 窗口半宽 $w=0.2$。\n- $[-1,1]$ 上的均匀网格大小 $M=10001$ 个点。\n\n测试套件：\n计算并按所列顺序报告以下 $(N,s)$ 对的结果：\n1. $(N,s)=(16,0)$，解释为不进行滤波，即对所有 $n$，$\\sigma_n^{(0)}\\equiv 1$。\n2. $(N,s)=(16,4)$。\n3. $(N,s)=(16,8)$。\n4. $(N,s)=(32,0)$，同上，解释为不进行滤波。\n5. $(N,s)=(32,8)$。\n6. $(N,s)=(64,16)$。\n\n对于每个测试用例，你的程序必须计算 $\\mathcal{O}(N,s;w)$ 和 $\\operatorname{TV}(N,s;M)$ 这两个数。最终输出格式必须是单行文本，包含一个由逗号分隔的所有测试用例结果的列表，该列表包含在一个外层括号中，其中每个测试用例的结果是一个按 $[\\mathcal{O}(N,s;w),\\operatorname{TV}(N,s;M)]$ 顺序排列的包含两个条目的列表。例如，输出格式必须为\n$$\n[\\,[o_1,t_1],[o_2,t_2],\\dots,[o_6,t_6]\\,],\n$$\n其中每个 $o_j$ 和 $t_j$ 都是一个浮点数。不应打印任何其他文本。\n\n本问题不涉及物理单位和角度。所有数值答案必须以浮点数形式报告，不带任何百分比符号。",
            "solution": "### 1. 勒让德系数的计算\n\n目标函数是定义在区间 $[-1, 1]$ 上的符号函数 $f(x) = \\operatorname{sign}(x)$。我们寻求其在勒让德多项式基 $\\{P_n(x)\\}_{n=0}^\\infty$ 下的展开。$N$ 次勒让德部分和由下式给出\n$$\nS_N(x) = \\sum_{n=0}^N a_n P_n(x)\n$$\n其中系数 $a_n$ 由 $L^2([-1,1])$ 投影确定：\n$$\na_n = \\frac{\\langle f, P_n \\rangle}{\\langle P_n, P_n \\rangle} = \\frac{\\int_{-1}^1 f(x) P_n(x) \\,dx}{\\int_{-1}^1 P_n(x)^2 \\,dx} = \\frac{2n+1}{2} \\int_{-1}^1 f(x) P_n(x) \\,dx.\n$$\n函数 $f(x) = \\operatorname{sign}(x)$ 是一个奇函数，即 $f(-x) = -f(x)$。勒让德多项式 $P_n(x)$ 具有确定的奇偶性：$P_n(-x) = (-1)^n P_n(x)$。\n因此，如果 $n$ 是偶数，则乘积 $f(x) P_n(x)$ 是奇函数；如果 $n$ 是奇数，则乘积是偶函数。\n奇函数在对称区间 $[-1, 1]$ 上的积分为零。因此，对于偶数 $n$：\n$$\na_n = \\frac{2n+1}{2} \\int_{-1}^1 \\underbrace{f(x) P_n(x)}_{\\text{odd function}} \\,dx = 0.\n$$\n对于奇数 $n$，被积函数是偶函数，所以积分变为：\n$$\na_n = \\frac{2n+1}{2} \\cdot 2 \\int_0^1 f(x) P_n(x) \\,dx = (2n+1) \\int_0^1 (1) \\cdot P_n(x) \\,dx.\n$$\n我们使用给定的不定积分恒等式：\n$$\n\\int P_n(x) \\,dx = \\frac{P_{n+1}(x) - P_{n-1}(x)}{2n+1} + C.\n$$\n计算从 $0$ 到 $1$ 的定积分：\n$$\n\\int_0^1 P_n(x) \\,dx = \\left[ \\frac{P_{n+1}(x) - P_{n-1}(x)}{2n+1} \\right]_0^1 = \\frac{(P_{n+1}(1) - P_{n-1}(1)) - (P_{n+1}(0) - P_{n-1}(0))}{2n+1}.\n$$\n使用对于所有整数 $k \\ge 0$ 均成立的标准性质 $P_k(1) = 1$，第一项 $(P_{n+1}(1) - P_{n-1}(1)) = (1 - 1) = 0$。这可将积分简化为：\n$$\n\\int_0^1 P_n(x) \\,dx = -\\frac{P_{n+1}(0) - P_{n-1}(0)}{2n+1} = \\frac{P_{n-1}(0) - P_{n+1}(0)}{2n+1}.\n$$\n将此结果代回到奇数 $n$ 的 $a_n$ 表达式中：\n$$\na_n = (2n+1) \\left( \\frac{P_{n-1}(0) - P_{n+1}(0)}{2n+1} \\right) = P_{n-1}(0) - P_{n+1}(0).\n$$\n由于 $n$ 是奇数，所以 $n-1$ 和 $n+1$ 都是偶数。对于偶数 $k$，$P_k(0)$ 的值非零，并且可以使用标准库函数（如 `scipy.special.eval_legendre`）可靠地计算。\n\n综上所述，勒让德系数为：\n$$\na_n = \\begin{cases}\n0  \\text{if } n \\text{ is even} \\\\\nP_{n-1}(0) - P_{n+1}(0)  \\text{if } n \\text{ is odd}\n\\end{cases}\n$$\n\n### 2. 模态滤波与滤波和\n\n吉布斯现象表现为在 $x=0$ 间断点附近出现的持续振荡和过冲。为缓解此现象，对系数应用一个模态滤波器。该滤波器由以下权重定义：\n$$\n\\sigma_n^{(s)} = \\exp\\left(-\\alpha\\left(\\frac{n}{N}\\right)^s\\right), \\quad n=0, 1, \\dots, N.\n$$\n这里，$s$ 是滤波器的阶数，控制衰减的形状，$\\alpha$ 是滤波器强度。高阶模态（大的 $n$）被更强烈地衰减。对于 $s=0$ 的测试用例，问题指明这对应于不进行滤波，即对所有 $n$，$\\sigma_n^{(0)} \\equiv 1$。\n\n滤波后的部分和 $S_N^{(s)}(x)$ 是使用滤波后的系数 $b_n = \\sigma_n^{(s)} a_n$ 构建的：\n$$\nS_N^{(s)}(x) = \\sum_{n=0}^N b_n P_n(x) = \\sum_{n=0}^N \\left(\\sigma_n^{(s)} a_n\\right) P_n(x).\n$$\n\n### 3. 数值计算与度量标准\n\n分析需要计算 $S_N^{(s)}(x)$ 的值并计算两个定量度量。\n\n**求值：** 在一个包含 $M=10001$ 个点的精细均匀网格上对和 $S_N^{(s)}(x)$进行求值，其中 $x_i = -1 + \\frac{2i}{M-1}$（$i=0, \\dots, M-1$）。令 $u_i = S_N^{(s)}(x_i)$。此求值可通过矩阵-向量乘积高效完成。设 $\\mathbf{b}$ 是滤波后系数的列向量 $[b_0, b_1, \\dots, b_N]^T$，$\\mathbf{V}$ 是一个类范德蒙矩阵，其元素为 $V_{in} = P_n(x_i)$。则值向量 $\\mathbf{u} = [u_0, u_1, \\dots, u_{M-1}]^T$ 由 $\\mathbf{u} = \\mathbf{V} \\mathbf{b}$ 给出。\n\n**过冲幅度 $\\mathcal{O}(N,s;w)$：** 此度量用于量化在 $x=0$ 处跳跃点附近、窗口 $[-w, w]$（其中 $w=0.2$）内的最大过冲。其定义为：\n$$\n\\mathcal{O}(N,s;w) = \\max\\Big\\{\\,\\max_{x\\in[0,w]}\\big(S_N^{(s)}(x)-1\\big),\\ \\max_{x\\in[-w,0]}\\big(-S_N^{(s)}(x)-1\\big),\\ 0\\Big\\}.\n$$\n在数值上，这是通过找出对于网格点 $x_i \\in [0, w]$ 的 $(u_i-1)$ 的最大值，以及对于 $x_i \\in [-w, 0]$ 的 $(-u_i-1)$ 的最大值，然后取这两个值与 $0$ 的最大值来计算的。\n\n**全变分 $\\operatorname{TV}(N,s;M)$：** 此度量衡量了近似在整个定义域上的总振荡。离散全变分为：\n$$\n\\operatorname{TV}(N,s;M)=\\sum_{i=0}^{M-2} \\big|u_{i+1}-u_i\\big|.\n$$\n一个从 $-1$ 跳到 $+1$ 的理想阶跃函数的全变分为 $2$。吉布斯现象引入了伪振荡，这会增加全变分（TV）。一个成功的滤波器将减小全变分，使其更接近 $2$。这是通过对值数组 $\\mathbf{u}$ 中连续元素的绝对差求和来计算的。\n\n### 4. 算法实现\n\n整体算法按以下步骤进行：\n1.  设置全局参数 $\\alpha=36$、$w=0.2$ 和 $M=10001$。\n2.  从测试套件中确定最大多项式次数 $N_{max}$（即 $64$）。\n3.  使用推导出的公式，预计算 $n=0, \\dots, N_{max}$ 的勒让德系数 $a_n$。\n4.  在 $[-1, 1]$ 上创建均匀求值网格 $x_i$。\n5.  遍历测试套件中的每个 $(N, s)$ 对：\n    a.  提取所需的系数 $a_0, \\dots, a_N$。\n    b.  计算 $n=0, \\dots, N$ 的滤波器权重 $\\sigma_n^{(s)}$。\n    c.  计算滤波后的系数 $b_n = \\sigma_n^{(s)} a_n$。\n    d.  在所有网格点 $x_i$ 上对滤波后的和 $S_N^{(s)}(x)$ 求值，得到 $u_i$。\n    e.  根据指定窗口内的值 $u_i$ 计算过冲 $\\mathcal{O}(N,s;w)$。\n    f.  根据所有值 $u_i$ 计算全变分 $\\operatorname{TV}(N,s;M)$。\n    g.  存储结果对 $[\\mathcal{O}, \\operatorname{TV}]$。\n6.  将所有结果对的列表格式化为所需的单行字符串格式。\n\n这种结构化方法将解析推导与数值实现分开，从而确保了正确性，而数值实现本身也为效率和准确性而设计。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import eval_legendre\n\ndef solve():\n    \"\"\"\n    Computes overshoot and total variation for filtered Legendre series approximations\n    of a step function, demonstrating Gibbs phenomenon mitigation.\n    \"\"\"\n    # Define fixed parameters from the problem statement.\n    alpha = 36.0\n    w = 0.2\n    M = 10001\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (16, 0),  # No filtering\n        (16, 4),\n        (16, 8),\n        (32, 0),  # No filtering\n        (32, 8),\n        (64, 16),\n    ]\n\n    # --- Step 1: Pre-compute Legendre coefficients a_n for f(x) = sign(x) ---\n    max_N = max(N for N, s in test_cases)\n\n    def compute_an(n):\n        \"\"\"\n        Computes the n-th Legendre coefficient for f(x) = sign(x).\n        \"\"\"\n        # For even n, the integral of an odd function (sign(x)*P_n(x)) is 0.\n        if n % 2 == 0:\n            return 0.0\n        # For odd n, a_n = P_{n-1}(0) - P_{n+1}(0).\n        # We use scipy's well-tested function for evaluating Legendre polynomials.\n        p_n_minus_1_at_0 = eval_legendre(n - 1, 0)\n        p_n_plus_1_at_0 = eval_legendre(n + 1, 0)\n        return p_n_minus_1_at_0 - p_n_plus_1_at_0\n\n    a_coeffs = np.array([compute_an(n) for n in range(max_N + 1)])\n\n    # --- Step 2: Set up the evaluation grid ---\n    x_grid = np.linspace(-1.0, 1.0, M)\n\n    # Determine indices for the overshoot calculation window [-w, w]\n    center_idx = (M - 1) // 2\n    # Number of grid points from the center to the window edge\n    w_pts = int(w * (M - 1) / 2)\n    idx_w_neg = center_idx - w_pts\n    idx_w_pos = center_idx + w_pts\n\n    results = []\n    \n    # --- Loop through each test case ---\n    for N, s in test_cases:\n        # --- Step 3: Form filtered modal coefficients ---\n        a_N = a_coeffs[:N + 1]\n        \n        # The case s=0 is explicitly defined as \"no filtering\".\n        if s == 0:\n            sigma = np.ones(N + 1)\n        else:\n            n_vals = np.arange(N + 1)\n            sigma = np.exp(-alpha * (n_vals / N)**s)\n        \n        b_coeffs = a_N * sigma\n        \n        # --- Step 4: Evaluate the filtered sum S_N^{(s)}(x) on the grid ---\n        n_range = np.arange(N + 1)\n        # Create a Vandermonde-like matrix where V[i, j] = P_j(x_i)\n        # Shape: (M, N+1)\n        leg_matrix = eval_legendre(n_range, x_grid[:, None])\n        # u_vals[i] = S_N^{(s)}(x_i), shape (M,)\n        u_vals = leg_matrix.dot(b_coeffs)\n\n        # --- Step 5: Compute the overshoot amplitude O ---\n        # Window for x in [0, w]\n        u_pos_window = u_vals[center_idx : idx_w_pos + 1]\n        # Window for x in [-w, 0]\n        u_neg_window = u_vals[idx_w_neg : center_idx + 1]\n        \n        # Max excursion beyond +1 in the positive window\n        overshoot_pos = np.max(u_pos_window - 1.0)\n        # Max excursion beyond -1 in the negative window\n        overshoot_neg = np.max(-u_neg_window - 1.0)\n        \n        O = np.max([overshoot_pos, overshoot_neg, 0.0])\n        \n        # --- Step 6: Compute the discrete total variation TV ---\n        TV = np.sum(np.abs(np.diff(u_vals)))\n        \n        results.append([O, TV])\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(res) for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}