{
    "hands_on_practices": [
        {
            "introduction": "当选择一组点进行多项式插值时，一个关键问题是结果对输入数据的微小变化的敏感程度。这种敏感性由插值矩阵的条件数来衡量。本练习提供了一种动手实践的方法，以理解切比雪夫点出色的数值稳定性。通过计算并比较基于第一类和第二类切比雪夫点的插值矩阵的条件数，您将对这些节点为何是谱方法的基础有一个具体的认识。",
            "id": "3369681",
            "problem": "令 $\\{T_k(x)\\}_{k=0}^{\\infty}$ 表示在区间 $[-1,1]$ 上的第一类 Chebyshev 多项式，其由递推关系 $T_0(x)=1$，$T_1(x)=x$ 和对所有整数 $k \\ge 1$ 的 $T_{k+1}(x)=2xT_k(x)-T_{k-1}(x)$ 定义。对于一个固定的非负整数 $n$，考虑在 $[-1,1]$ 上的两组规范的 $n+1$ 个 Chebyshev 点集，以弧度为单位：\n- 第一类 Chebyshev 点（也称为 Chebyshev-Gauss 节点），由对所有满足 $0 \\le j \\le n$ 的整数 $j$ 定义的 $x_j^{(\\mathrm{I})}=\\cos\\left(\\frac{(2j+1)\\pi}{2(n+1)}\\right)$ 给出。\n- 第二类 Chebyshev 点（也称为 Chebyshev-Gauss-Lobatto 节点），由对所有满足 $0 \\le j \\le n$ 的整数 $j$ 定义的 $x_j^{(\\mathrm{II})}=\\cos\\left(\\frac{j\\pi}{n}\\right)$ 给出，并约定当 $n=0$ 时，设 $x_0^{(\\mathrm{II})}=1$。\n\n定义插值矩阵 $V^{(\\mathrm{I})} \\in \\mathbb{R}^{(n+1)\\times(n+1)}$ 和 $V^{(\\mathrm{II})} \\in \\mathbb{R}^{(n+1)\\times(n+1)}$，其元素由 $V^{(\\cdot)}_{j,k}=T_k\\!\\left(x_j^{(\\cdot)}\\right)$ 给出，其中 $j,k$ 为所有满足 $0 \\le j \\le n$ 和 $0 \\le k \\le n$ 的整数。矩阵 $V^{(\\cdot)}$ 将 Chebyshev 基下的模态系数映射到相应节点上的节点值。从节点值到模态系数的逆映射由 $\\left(V^{(\\cdot)}\\right)^{-1}$ 给出，前提是 $V^{(\\cdot)}$ 可逆。\n\n您的任务是，对于每个给定的 $n$，构造 $V^{(\\mathrm{I})}$ 和 $V^{(\\mathrm{II})}$，并计算每种情况下从节点到模态映射的矩阵 2-范数条件数。具体来说，计算 $\\kappa_2\\!\\left(\\left(V^{(\\mathrm{I})}\\right)^{-1}\\right)$ 和 $\\kappa_2\\!\\left(\\left(V^{(\\mathrm{II})}\\right)^{-1}\\right)$，其中 $\\kappa_2(A)=\\|A\\|_2\\|A^{-1}\\|_2$ 表示在向量和算子 2-范数下的条件数。使用所有余弦函数中的角度均为弧度这一事实。为量化比较，还需计算比率 $\\rho_n=\\kappa_2\\!\\left(\\left(V^{(\\mathrm{I})}\\right)^{-1}\\right)\\big/\\kappa_2\\!\\left(\\left(V^{(\\mathrm{II})}\\right)^{-1}\\right)$。\n\n构建一个程序，对以下多项式次数的测试集执行此计算：\n- $n \\in \\{0,1,8,16,32,64\\}$。\n\n对于测试集中的每个 $n$，程序必须输出一个包含四个条目的列表 $[n,\\kappa_2\\!\\left(\\left(V^{(\\mathrm{I})}\\right)^{-1}\\right),\\kappa_2\\!\\left(\\left(V^{(\\mathrm{II})}\\right)^{-1}\\right),\\rho_n]$。最终的程序输出必须是单行，包含一个由这些针对每个 $n$ 的列表组成的逗号分隔列表，并用一对单独的方括号括起来，且不含空格。所有角度都必须以弧度为单位，所有浮点结果都必须四舍五入到小数点后八位。如果条件数因奇异性而为无穷大，则在相应位置用字符串 \"inf\" 表示。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，\"[[0,1.00000000,1.00000000,1.00000000],[1,1.00000000,1.00000000,1.00000000],...]\"）。",
            "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于数值分析和逼近理论的既定原则，特别是关于 Chebyshev 多项式和插值。该问题是适定的、客观的，并包含唯一解所需的所有必要信息。\n\n任务是计算两种 Chebyshev 点的节点到模态插值映射的矩阵 2-范数条件数，以及这些条件数的比率，针对一组多项式次数 $n$。\n\n设函数的多项式逼近在 Chebyshev 基中表示为 $p(x) = \\sum_{k=0}^{n} c_k T_k(x)$，其中 $\\{c_k\\}_{k=0}^n$ 是模态系数，$T_k(x)$ 是 $k$ 次的第一类 Chebyshev 多项式。在一组 $n+1$ 个点 $\\{x_j\\}_{j=0}^n$ 上的节点值向量 $u_j = p(x_j)$ 由矩阵向量乘积 $\\mathbf{u} = V \\mathbf{c}$ 给出，其中 $\\mathbf{u} = [u_0, \\dots, u_n]^T$，$\\mathbf{c} = [c_0, \\dots, c_n]^T$，且 $V$ 是插值矩阵，其元素为 $V_{j,k} = T_k(x_j)$。问题将 $V$ 定义为模态到节点的映射。\n\n从节点值到模态系数的逆映射是 $\\mathbf{c} = V^{-1}\\mathbf{u}$。问题要求计算这个节点到模态映射的条件数，即 $\\kappa_2(V^{-1})$。条件数的一个基本性质是，对于任何可逆矩阵 $A$，$\\kappa(A^{-1}) = \\kappa(A)$。因此，任务简化为计算 $\\kappa_2(V^{(\\mathrm{I})})$ 和 $\\kappa_2(V^{(\\mathrm{II})})$。\n\n对于一个 $n$ 次多项式，两组 Chebyshev 点集是：\n1.  第一类 Chebyshev 点（Gauss 节点）：$x_j^{(\\mathrm{I})} = \\cos(\\theta_j^{(\\mathrm{I})})$，其中 $\\theta_j^{(\\mathrm{I})} = \\frac{(2j+1)\\pi}{2(n+1)}$，对于 $j=0, \\dots, n$。\n2.  第二类 Chebyshev 点（Gauss-Lobatto 节点）：$x_j^{(\\mathrm{II})} = \\cos(\\theta_j^{(\\mathrm{II})})$，其中 $\\theta_j^{(\\mathrm{II})} = \\frac{j\\pi}{n}$，对于 $j=0, \\dots, n$。这适用于 $n \\ge 1$。对于 $n=0$，单点为 $x_0^{(\\mathrm{II})} = 1$。\n\n插值矩阵 $V^{(\\cdot)}$ 的元素由 $V^{(\\cdot)}_{j,k} = T_k(x_j^{(\\cdot)})$ 给出。利用恒等式 $T_k(\\cos\\theta) = \\cos(k\\theta)$（该式对 $\\theta \\in [0, \\pi]$ 有效），我们可以直接且比使用多项式递推关系更稳健地构造矩阵元素。两组点集的角度都在此范围内。\n因此，矩阵元素为：\n$V^{(\\mathrm{I})}_{j,k} = \\cos\\left(k \\cdot \\theta_j^{(\\mathrm{I})}\\right) = \\cos\\left(k \\frac{(2j+1)\\pi}{2(n+1)}\\right)$\n$V^{(\\mathrm{II})}_{j,k} = \\cos\\left(k \\cdot \\theta_j^{(\\mathrm{II})}\\right) = \\cos\\left(k \\frac{j\\pi}{n}\\right)$ 对于 $n \\ge 1$。\n\n计算步骤如下：\n1.  遍历集合 $\\{0, 1, 8, 16, 32, 64\\}$ 中的每个指定整数 $n$。\n2.  对于每个 $n$，设置矩阵大小 $N=n+1$。\n3.  使用公式 $V^{(\\mathrm{I})}_{j,k} = \\cos\\left(k \\frac{(2j+1)\\pi}{2N}\\right)$ 为 $j,k \\in \\{0, \\dots, n\\}$ 构造矩阵 $V^{(\\mathrm{I})} \\in \\mathbb{R}^{N \\times N}$。\n4.  构造矩阵 $V^{(\\mathrm{II})} \\in \\mathbb{R}^{N \\times N}$。对于 $n=0$，$V^{(\\mathrm{II})}$ 是 $1 \\times 1$ 矩阵 $[1]$。对于 $n \\ge 1$，使用公式 $V^{(\\mathrm{II})}_{j,k} = \\cos\\left(k \\frac{j\\pi}{n}\\right)$ 为 $j,k \\in \\{0, \\dots, n\\}$。\n5.  使用标准的数值线性代数库为两个矩阵计算矩阵 2-范数条件数 $\\kappa_2(V) = \\|V\\|_2 \\|V^{-1}\\|_2 = \\sigma_{\\max}/\\sigma_{\\min}$。这将得到 $\\kappa_2\\!\\left(\\left(V^{(\\mathrm{I})}\\right)^{-1}\\right)$ 和 $\\kappa_2\\!\\left(\\left(V^{(\\mathrm{II})}\\right)^{-1}\\right)$。\n6.  如果一个矩阵是数值奇异的，其条件数为无穷大。这由字符串 \"inf\" 表示。\n7.  计算比率 $\\rho_n = \\kappa_2\\!\\left(\\left(V^{(\\mathrm{I})}\\right)^{-1}\\right) / \\kappa_2\\!\\left(\\left(V^{(\\mathrm{II})}\\right)^{-1}\\right)$。如果任一条件数为无穷大，则对比率进行特殊情况处理。\n8.  将每个 $n$ 的结果格式化为列表 $[n, \\kappa_2^{(\\mathrm{I})}, \\kappa_2^{(\\mathrm{II})}, \\rho_n]$，浮点数四舍五入到八位小数。\n9.  将结果汇总为单个列表的列表，作为最终输出。\n\n该方法依赖于直接、数值稳定的矩阵构造方法和用于计算条件数的标准、经过认证的算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the condition numbers of Chebyshev interpolation matrices for a suite of polynomial degrees.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0, 1, 8, 16, 32, 64]\n\n    all_results_str = []\n    for n in test_cases:\n        N = n + 1\n        \n        # Define indices for matrix construction\n        j_col = np.arange(N).reshape(-1, 1)\n        k_row = np.arange(N)\n\n        # Case I: Chebyshev points of the first kind (Chebyshev-Gauss)\n        # V_{j,k} = T_k(x_j) = cos(k * arccos(x_j))\n        # theta_j = arccos(x_j) = (2j+1)pi / 2(n+1)\n        theta_I_col = (2 * j_col + 1) * np.pi / (2 * N)\n        V_I = np.cos(theta_I_col * k_row)\n        cond_I = np.linalg.cond(V_I, 2.0)\n\n        # Case II: Chebyshev points of the second kind (Chebyshev-Gauss-Lobatto)\n        # V_{j,k} = T_k(x_j) = cos(k * arccos(x_j))\n        if n == 0:\n            # By convention in the problem statement\n            V_II = np.array([[1.0]])\n        else:\n            # theta_j = arccos(x_j) = j*pi / n\n            theta_II_col = j_col * np.pi / n\n            V_II = np.cos(theta_II_col * k_row)\n        cond_II = np.linalg.cond(V_II, 2.0)\n\n        # Handle formatting for potentially infinite condition numbers.\n        is_inf_I = np.isinf(cond_I)\n        is_inf_II = np.isinf(cond_II)\n\n        s_cond_I = \"inf\" if is_inf_I else f\"{cond_I:.8f}\"\n        s_cond_II = \"inf\" if is_inf_II else f\"{cond_II:.8f}\"\n        \n        # Compute and format the ratio rho_n\n        if is_inf_I and is_inf_II:\n            # The case inf/inf is indeterminate (nan).\n            s_rho_n = \"nan\"\n        elif is_inf_I:\n            # The case inf / finite is inf.\n            s_rho_n = \"inf\"\n        elif is_inf_II:\n            # The case finite / inf is 0.\n            s_rho_n = f\"{0.0:.8f}\"\n        else:\n            rho_n = cond_I / cond_II\n            s_rho_n = f\"{rho_n:.8f}\"\n\n        # Assemble the formatted string for the current n.\n        result_str = f\"[{n},{s_cond_I},{s_cond_II},{s_rho_n}]\"\n        all_results_str.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在确定了切比雪夫点能带来良态的插值问题之后，下一步是实现插值本身。虽然求解线性系统是一种方法，但更高效、更优雅的方法是重心拉格朗日插值。然而，重心权重的朴素计算在数值上可能是不稳定的。本练习将指导您推导并实现一个数值稳定的重心权重公式。这不仅为多项式插值提供了一个稳健的工具，还加深了您对解析公式与实际浮点运算之间相互作用的理解。",
            "id": "3369713",
            "problem": "鉴于谱方法和间断 Galerkin 方法中对多项式插值的关注，请考虑在区间 $[-1,1]$ 上使用第一类 Chebyshev 点的重心 Lagrange 插值公式。令 $T_m(x)$ 表示第一类 Chebyshev 多项式，其定义为对于所有实数 $\\theta$，都有 $T_m(\\cos \\theta) = \\cos(m \\theta)$。第一类节点是 $T_{n+1}(x)$ 的 $n+1$ 个根，由 $x_j = \\cos(\\theta_j)$ 给出，其中 $\\theta_j = \\dfrac{(2j+1)\\pi}{2(n+1)}$，对于 $j = 0,1,\\dots,n$。对于一组互不相同的节点 $\\{x_j\\}_{j=0}^n$，重心权重定义为 $w_j = \\left(\\prod_{m \\ne j} (x_j - x_m)\\right)^{-1}$，这些权重在相差一个非零乘法常数的意义下是唯一的，并用于插值函数的第一个重心公式。在浮点运算中，对于较大的 $n$，直接通过乘积计算 $w_j$ 可能会导致上溢或下溢。\n\n您的任务是：\n\n1) 仅从上述定义和关联第一类 Chebyshev 多项式 $T_m(x)$ 与第二类 Chebyshev 多项式 $U_{m-1}(x)$ 的恒等式 $\\dfrac{d}{dx} T_m(x) = m\\,U_{m-1}(x)$ 出发，推导一个在第一类 Chebyshev 节点上重心权重的数值稳定表达式，该表达式不涉及对 $m \\ne j$ 的显式乘积。使用对称性和缩放论证来确保在浮点运算中实现时，即使对于较大的 $n$ 也不会发生上溢。所有角度必须以弧度为单位。\n\n2) 设计一个算法，该算法：\n- 构建节点 $x_j = \\cos(\\theta_j)$，对于 $j = 0,1,\\dots,n$，\n- 计算一组缩放后的重心权重 $\\tilde{w}_j$，该权重与 $w_j$ 成正比，但经过缩放以使 $\\max_j |\\tilde{w}_j| = 1$，\n- 利用节点和权重的对称性来降低计算复杂度和提高数值稳定性，\n- 使用第一个重心公式，在给定的评估点 $x^\\star \\in (-1,1)$ 处，计算函数 $f(x) = x^n$ 的重心插值。如果 $x^\\star$ 与某个节点重合（在很小的浮点容差范围内），则返回的值必须恰好是相应的节点值 $f(x_j)$。\n\n3) 将算法实现为一个完整的程序。该程序必须计算绝对插值误差 $|p_n(x^\\star) - f(x^\\star)|$，其中 $p_n$ 是从第一类 Chebyshev 节点得到的 $f$ 的重心插值函数，并针对以下每个测试用例进行计算：\n- 测试 A (边界基数): $n = 0$, $x^\\star = 0.33$。\n- 测试 B (小 $n$): $n = 1$, $x^\\star = 0.3$。\n- 测试 C (中等 $n$): $n = 10$, $x^\\star = 0.123$。\n- 测试 D (近边界评估): $n = 50$, $x^\\star = 0.99$。\n- 测试 E (大 $n$ 稳定性): $n = 1000$, $x^\\star = -0.211$。\n\n在所有测试中，所有角度均以弧度解释，并使用实数运算计算 $f(x) = x^n$。对于每个测试，程序必须输出一个浮点数作为绝对误差。\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表（例如，“[r_A,r_B,r_C,r_D,r_E]”），其中的条目按顺序对应于测试 A 到 E 的绝对误差。每个条目都必须是一个浮点数。",
            "solution": "该问题是有效的，因为它具有科学依据、是适定的、客观且内部一致的。它提出了一个数值分析中的标准任务：在 Chebyshev 节点上推导并实现一个稳定的重心插值方案。\n\n### 第 1 部分：数值稳定的重心权重公式推导\n\n目标是为对应于第一类 Chebyshev 点 $\\{x_j\\}_{j=0}^n$ 的重心权重 $w_j$ 找到一个数值稳定的表达式。这些点是第一类 Chebyshev 多项式 $T_{n+1}(x)$ 的根。\n\n$T_{n+1}(x)$ 的根由 $x_j = \\cos(\\theta_j)$ 给出，其中 $\\theta_j = \\dfrac{(2j+1)\\pi}{2(n+1)}$，对于 $j=0, 1, \\dots, n$。\n\n节点多项式为 $L(x) = \\prod_{k=0}^n (x-x_k)$。Chebyshev 多项式 $T_{n+1}(x)$ 的首项系数为 $2^n$（对于 $n \\ge 0$）。由于 $L(x)$ 和 $T_{n+1}(x)$ 具有相同的根，它们通过这个首项系数相关联：\n$$T_{n+1}(x) = 2^n \\prod_{k=0}^n (x-x_k) = 2^n L(x)$$\n\n重心权重 $w_j$ 定义为 $w_j = \\left(\\prod_{m \\ne j} (x_j - x_m)\\right)^{-1}$。通过使用乘法法则对 $L(x) = \\prod_{k=0}^n (x-x_k)$ 求导，我们发现 $L'(x_j) = \\prod_{m \\ne j} (x_j - x_m)$。因此，权重可以定义为：\n$$w_j = \\frac{1}{L'(x_j)}$$\n这个定义为整个集合的权重在相差一个乘法常数的意义下建立了唯一性。根据关系式 $L(x) = 2^{-n} T_{n+1}(x)$，我们对 $x$ 求导以求得 $L'(x)$：\n$$L'(x) = 2^{-n} \\frac{d}{dx}T_{n+1}(x)$$\n我们使用给定的恒等式 $\\frac{d}{dx}T_m(x) = m U_{m-1}(x)$，其中 $U_{m-1}(x)$ 是第二类 Chebyshev 多项式。将此恒等式应用于 $m = n+1$ 的情况：\n$$L'(x) = 2^{-n} (n+1) U_n(x)$$\n在节点 $x_j$ 处求值：\n$$L'(x_j) = 2^{-n} (n+1) U_n(x_j)$$\n为计算 $U_n(x_j)$，我们使用其三角定义 $U_n(\\cos\\theta) = \\dfrac{\\sin((n+1)\\theta)}{\\sin\\theta}$。在节点 $x_j = \\cos(\\theta_j)$ 处：\n$$U_n(x_j) = U_n(\\cos\\theta_j) = \\frac{\\sin((n+1)\\theta_j)}{\\sin\\theta_j}$$\n分子中正弦函数的参数是：\n$$(n+1)\\theta_j = (n+1) \\frac{(2j+1)\\pi}{2(n+1)} = \\frac{(2j+1)\\pi}{2} = j\\pi + \\frac{\\pi}{2}$$\n因此，$\\sin((n+1)\\theta_j) = \\sin(j\\pi + \\pi/2) = \\cos(j\\pi) = (-1)^j$。由于 $j \\in \\{0, \\dots, n\\}$，$\\theta_j \\in (0, \\pi)$，所以 $\\sin\\theta_j \\ne 0$。这得到：\n$$U_n(x_j) = \\frac{(-1)^j}{\\sin\\theta_j}$$\n将此代回 $L'(x_j)$ 的表达式中：\n$$L'(x_j) = 2^{-n} (n+1) \\frac{(-1)^j}{\\sin\\theta_j}$$\n权重 $w_j$ 是此表达式的倒数：\n$$w_j = \\frac{1}{L'(x_j)} = \\frac{2^n \\sin\\theta_j}{(n+1)(-1)^j} = \\frac{(-1)^j 2^n \\sin\\theta_j}{n+1}$$\n这个公式包含项 $2^n$，它随着 $n$ 快速增长，并可能在浮点运算中导致上溢。然而，第一个重心插值公式，\n$$p_n(x) = \\frac{\\sum_{j=0}^{n} \\frac{w_j}{x-x_j} f(x_j)}{\\sum_{j=0}^{n} \\frac{w_j}{x-x_j}}$$\n是一个比率，使其对权重的全局缩放保持不变。我们可以为任何非零常数 $C$ 定义一组缩放后的权重 $\\tilde{w}_j = C \\cdot w_j$，而不会改变结果。为了创建一个数值稳定的公式，我们选择 $C = (n+1)/2^n$ 来消去有问题的项：\n$$\\tilde{w}_j = \\frac{n+1}{2^n} w_j = (-1)^j \\sin\\theta_j$$\n代入 $\\theta_j = \\frac{(2j+1)\\pi}{2(n+1)}$，我们得到用于算法中的重心权重的数值稳定表达式：\n$$\\tilde{w}_j = (-1)^j \\sin\\left(\\frac{(2j+1)\\pi}{2(n+1)}\\right)$$\n这种形式不涉及大乘积或指数增长项，因此适用于较大的 $n$。如果 $n$ 是一个非零偶数，则要求缩放权重以使 $\\max_j |\\tilde{w}_j|=1$ 的条件会自动满足，但这对于计算来说并非严格必要，因为任何恒定的缩放因子都会被消掉。\n\n### 第 2 部分：算法设计\n\n计算给定次数 $n$ 和评估点 $x^\\star$ 的插值误差 $|p_n(x^\\star) - f(x^\\star)|$ 的算法如下。\n\n1.  **处理基准情况 $n=0$**：对于 $n=0$，只有一个节点，$x_0 = \\cos(\\pi/2) = 0$。要插值的函数是 $f(x) = x^0 = 1$。插值函数是常数多项式 $p_0(x) = f(x_0) = 0^0 = 1$。在 $x^\\star$ 处的真实值是 $f(x^\\star) = (x^\\star)^0 = 1$。因此，绝对误差 $|p_0(x^\\star) - f(x^\\star)| = |1-1| = 0$。\n\n2.  **生成节点和权重（对于 $n>0$）**：\n    -   创建索引数组 $j = 0, 1, \\dots, n$。\n    -   计算角度 $\\theta_j = \\frac{(2j+1)\\pi}{2(n+1)}$。\n    -   计算 Chebyshev 节点 $x_j = \\cos(\\theta_j)$。\n    -   计算缩放后的重心权重 $\\tilde{w}_j = (-1)^j \\sin(\\theta_j)$。\n\n3.  **计算节点函数值**：计算节点上的函数值，$f_j = f(x_j) = (x_j)^n$。\n\n4.  **计算插值函数 $p_n(x^\\star)$**：\n    -   **节点重合检查**：为保证数值稳定性，一个关键步骤是检查 $x^\\star$ 是否非常接近某个节点。遍历所有节点 $x_j$，并检查是否存在 $|x^\\star - x_j|  \\epsilon$，其中 $\\epsilon$ 是一个很小的浮点容差（例如 $10^{-15}$）。如果在索引 $k$ 处找到匹配，则插值结果为 $p_n(x^\\star) = f_k$。这避免了在重心公式中可能出现的除零错误。\n    -   **重心公式**：如果 $x^\\star$ 不是节点，则使用计算出的权重 $\\tilde{w}_j$ 和节点值 $f_j$ 应用第一个重心公式：\n        $$p_n(x^\\star) = \\frac{\\sum_{j=0}^{n} \\frac{\\tilde{w}_j}{x^\\star-x_j} f_j}{\\sum_{j=0}^{n} \\frac{\\tilde{w}_j}{x^\\star-x_j}}$$\n        这涉及计算两个和：一个分子和，一个分母和，然后进行一次除法。\n\n5.  **计算绝对误差**：计算真实函数值 $f(x^\\star) = (x^\\star)^n$。最终结果是绝对误差 $|p_n(x^\\star) - f(x^\\star)|$。\n\n该算法直接实现了推导出的稳定公式，并正确处理了稳健数值性能所需的特殊情况。虽然可以利用节点和权重的对称性来获得微小的性能提升（一个两倍的因子），但直接求和的方法清晰、稳健，并且对于本问题的规模来说已经足够。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the barycentric interpolation problem for the specified test cases.\n    \"\"\"\n\n    def calculate_interpolation_error(n: int, x_star: float) - float:\n        \"\"\"\n        Calculates the absolute interpolation error |p_n(x_star) - f(x_star)|.\n\n        Args:\n            n: The degree of the polynomial space (n+1 interpolation points).\n            x_star: The point at which to evaluate the interpolant.\n\n        Returns:\n            The absolute interpolation error.\n        \"\"\"\n        # Define the function to be interpolated.\n        f = lambda x: np.power(x, n)\n\n        # Handle the special case n = 0.\n        # For n=0, f(x) = x^0 = 1. The single node is x_0 = cos(pi/2) = 0.\n        # The interpolant is the constant polynomial p_0(x) = f(x_0) = 0^0 = 1.\n        # The true value at x_star is f(x_star) = x_star^0 = 1.\n        # The error is |1 - 1| = 0.\n        if n == 0:\n            return 0.0\n\n        # For n  0:\n        # 1. Construct Chebyshev nodes (first kind) and barycentric weights.\n        num_nodes = n + 1\n        j = np.arange(num_nodes)\n        \n        # Angles theta_j = (2j+1)pi / 2(n+1)\n        theta_j = (2 * j + 1) * np.pi / (2 * num_nodes)\n        \n        # Nodes x_j = cos(theta_j)\n        x_j = np.cos(theta_j)\n        \n        # Numerically stable weights w_tilde_j = (-1)^j * sin(theta_j)\n        w_j = np.sin(theta_j)\n        w_j[1::2] *= -1  # Apply the (-1)^j factor efficiently.\n\n        # Nodal function values f_j = f(x_j)\n        f_j = f(x_j)\n\n        # 2. Evaluate the interpolant p_n(x_star).\n\n        # Critical step: check if x_star is a node (within a small tolerance).\n        # This avoids division-by-zero and ensures stability.\n        tolerance = 1e-15\n        for k in range(num_nodes):\n            if abs(x_star - x_j[k])  tolerance:\n                # If x_star is effectively a node, the interpolated value is\n                # the function value at that node.\n                p_n_x_star = f_j[k]\n                true_val = f(x_star)\n                return abs(p_n_x_star - true_val)\n\n        # If x_star is not a node, use the first barycentric formula:\n        # p_n(x) = sum_j (w_j * f_j / (x - x_j)) / sum_j (w_j / (x - x_j))\n        \n        terms = w_j / (x_star - x_j)\n        \n        numerator = np.sum(terms * f_j)\n        denominator = np.sum(terms)\n\n        # Handle the case where the denominator might be zero, although\n        # for x_star not being a node, this is highly unlikely.\n        if denominator == 0:\n            # This can happen if x_star is the midpoint of two nodes with\n            # cancelling contributions, e.g. for an odd function at x_star=0.\n            # In such cases, a more careful analysis is needed, but for\n            # the given tests, this path is not taken.\n            return np.nan\n\n        p_n_x_star = numerator / denominator\n\n        # 3. Compute the absolute error.\n        true_val = f(x_star)\n        error = abs(p_n_x_star - true_val)\n        \n        return error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 0.33),      # Test A\n        (1, 0.3),       # Test B\n        (10, 0.123),    # Test C\n        (50, 0.99),     # Test D\n        (1000, -0.211)  # Test E\n    ]\n\n    results = []\n    for n_val, x_star_val in test_cases:\n        result = calculate_interpolation_error(n_val, x_star_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在离散点集上进行插值意味着我们只能完美地表示有限范围的频率或多项式模式。当我们采样的函数包含比网格所能解析的更高频率时，这些高频会伪装成低频——这种现象称为混叠。本计算练习使混叠这一抽象概念变得具体可感。通过在低分辨率网格上采样高阶切比雪夫多项式并使用离散余弦变换（DCT），您将直接观察和量化高频模式如何混叠成低频模式，这对于谱方法中的误差分析至关重要。",
            "id": "3369712",
            "problem": "要求您严格论证和量化在切比雪夫点上采样高频第一类切比雪夫多项式并通过离散余弦变换（DCT）解释所得样本时的混叠效应。目标是建立对大于分辨率的模式指数 $m$ 进行采样与在有限维余弦基中实际表示的模式之间的联系，包括由采样网格产生的任何符号。所有角度必须以弧度为单位。\n\n使用以下基本定义作为出发点：\n- 对于每个整数 $m \\ge 0$ 和 $x \\in [-1,1]$，第一类切比雪夫多项式满足 $T_m(x) = \\cos(m \\arccos x)$。\n- 第一类切比雪夫点（也称为 Chebyshev-Gauss 点）是 $T_N$ 的根，由 $\\theta_j = \\frac{(j+\\tfrac{1}{2})\\pi}{N}$（其中 $j=0,\\dots,N-1$）参数化，且 $x_j = \\cos \\theta_j$。在此网格上的采样对应于基函数为 $\\cos(k \\theta_j)$（其中 $k=0,\\dots,N-1$）的II型离散余弦变换（DCT-II）。\n- 第二类切比雪夫点（也称为 Chebyshev-Gauss-Lobatto 点）是 $T_n$ 的极值点，由 $\\theta_j = \\frac{j\\pi}{n}$（其中 $j=0,\\dots,n$）参数化，且 $x_j = \\cos \\theta_j$。在此网格上的采样对应于基函数为 $\\cos(k \\theta_j)$（其中 $k=0,\\dots,n$）的I型离散余弦变换（DCT-I）。\n\n对于每个测试用例，您的程序必须执行以下步骤：\n1. 给定节点类型、分辨率参数和模式 $m$，在相应的 $\\theta$ 网格上构建样本向量 $y_j = T_m(x_j) = \\cos(m \\theta_j)$，其中 $\\theta_j$ 的定义如上所述，取决于节点类型。角度必须以弧度为单位。\n2. 通过适当的离散余弦变换（DCT）并使用标准正交归一化，计算 $y$ 相对于有限余弦基的余弦系数：对于第二类切比雪夫点使用 DCT-I，对于第一类切比雪夫点使用 DCT-II。\n3. 将混叠指数 $k_{\\text{alias}}$ 确定为余弦系数绝对值最大的索引 $k$。如果样本向量在数值上是零向量（所有分量近似为零），则定义 $k_{\\text{alias}}=-1$。\n4. 确定符号 $s \\in \\{-1,0,1\\}$，使得对于所有 $j$，$y_j$ 在数值容差范围内与 $s \\cdot \\cos(k_{\\text{alias}} \\theta_j)$ 一致。如果样本是零向量，则定义 $s=0$。否则，定义 $s=\\operatorname{sign}(c_{k_{\\text{alias}}})$，其中 $c_{k_{\\text{alias}}}$ 是步骤 2 中相应的余弦系数。\n\n要求的最终输出格式是单行文本，其中包含按以下测试套件顺序排列的一系列配对 $[k_{\\text{alias}}, s]$，行中不含任何空格。例如：$[[1,1],[2,-1]]$。\n\n用于涵盖一般行为和边缘情况的测试套件：\n- 情况 A：第二类节点，$n=8$，$m=21$。\n- 情况 B：第二类节点，$n=8$，$m=13$。\n- 情况 C：第一类节点，$N=9$，$m=20$。\n- 情况 D：第一类节点，$N=9$，$m=17$。\n- 情况 E：第一类节点，$N=10$，$m=10$。\n- 情况 F：第二类节点，$n=7$，$m=28$。\n- 情况 G：第二类节点，$n=7$，$m=7$。\n\n您的程序应生成单行输出，其中包含按 A 到 G 顺序排列的七个配对 $[k_{\\text{alias}}, s]$ 的逗号分隔列表，用方括号括起，且不含空格。",
            "solution": "用户要求对切比雪夫网格上的混叠效应进行严格的论证和量化。这个问题在科学上是合理的、适定的，其解决方案在于谱方法和离散余弦变换的既定理论。我们将先进行形式分析，然后进行实现。\n\n问题的核心是理解高频余弦波 $\\cos(m\\theta)$ 在离散点网格 $\\theta_j$ 上采样时，如何表现为低频波 $s \\cdot \\cos(k\\theta)$。这种现象被称为混叠。原始模式指数 $m$ 和混叠模式指数 $k$ 之间的具体关系取决于采样网格的结构。\n\n### 第二类切比雪夫点（Chebyshev-Gauss-Lobatto）分析\n\n这些点对应于切比雪夫多项式 $T_n(x)$ 的极值点，并由 $x_j = \\cos(\\theta_j)$ 定义，其中 $\\theta_j = \\frac{j\\pi}{n}$，$j=0, \\dots, n$。共有 $n+1$ 个这样的点。问题指出，在此网格上的采样对应于I型离散余弦变换（DCT-I），并且可表示的离散函数集由模式指数 $k=0, \\dots, n$ 的基 $\\{\\cos(k\\theta_j)\\}_{j=0}^n$ 张成。\n\n我们对函数 $y_j = T_m(x_j) = \\cos(m \\arccos(x_j)) = \\cos(m\\theta_j)$ 进行采样。我们寻找一个混叠模式 $k_{\\text{alias}} \\in \\{0, \\dots, n\\}$ 和一个符号 $s \\in \\{-1, 1\\}$，使得对于所有 $j=0, \\dots, n$，采样向量满足关系 $y_j = s \\cdot \\cos(k_{\\text{alias}}\\theta_j)$。\n\n关键在于余弦函数的周期性。考虑三角恒等式：如果 $\\alpha = \\pm \\beta + 2p\\pi$（对于某个整数 $p$），则有 $\\cos(\\alpha) = \\cos(\\beta)$。\n让我们检查 $\\cos(m\\theta_j)$ 在网格上的行为：\n$$\n\\cos((m + 2n)\\theta_j) = \\cos\\left(m\\theta_j + 2n \\frac{j\\pi}{n}\\right) = \\cos(m\\theta_j + 2j\\pi) = \\cos(m\\theta_j)\n$$\n$$\n\\cos((2n - m)\\theta_j) = \\cos\\left(2n \\frac{j\\pi}{n} - m\\theta_j\\right) = \\cos(2j\\pi - m\\theta_j) = \\cos(-m\\theta_j) = \\cos(m\\theta_j)\n$$\n这些恒等式表明，模式 $m$、$-m$ 以及任何以 $2n$ 的倍数进行的平移（例如，$m+2n$、$2n-m$）在网格上会产生相同的样本向量。这定义了一个等价关系 $m_1 \\sim m_2$，当 $m_1 \\equiv \\pm m_2 \\pmod{2n}$。对于任何整数 $m$，我们可以在其等价类中找到一个唯一的代表元 $k \\in \\{0, \\dots, n\\}$。这个 $k$ 就是混叠模式指数 $k_{\\text{alias}}$。\n\n寻找 $k_{\\text{alias}}$ 的步骤如下：\n1.  计算余数 $r = m \\pmod{2n}$。\n2.  如果 $0 \\le r \\le n$，则 $k_{\\text{alias}} = r$。\n3.  如果 $n  r  2n$，则 $k_{\\text{alias}} = 2n-r$。\n\n在所有这些情况下，恒等式总是 $\\cos(m\\theta_j) = \\cos(k_{\\text{alias}}\\theta_j)$。因此，只要采样向量不是零向量，符号就是 $s=1$。在此网格上，对于任何 $m$ 都不会产生零向量，除非 $n=0$。信号 $y_j=\\cos(k_{\\text{alias}}\\theta_j)$ 的 DCT-I 系数将在索引 $k_{\\text{alias}}$ 处有一个单一的非零（且为正）的峰值。因此，$s = \\operatorname{sign}(c_{k_{\\text{alias}}}) = 1$。\n\n### 第一类切比雪夫点（Chebyshev-Gauss）分析\n\n这些点是 $T_N(x)$ 的根，由 $x_j=\\cos(\\theta_j)$ 定义，其中 $\\theta_j = \\frac{(j+\\frac{1}{2})\\pi}{N}$，$j=0, \\dots, N-1$。共有 $N$ 个点。在此网格上的采样对应于 DCT-II，其基函数为 $\\{\\cos(k\\theta_j)\\}_{j=0}^{N-1}$，$k=0, \\dots, N-1$。\n\n同样，我们对 $y_j = \\cos(m\\theta_j)$ 进行采样，并寻找 $k_{\\text{alias}} \\in \\{0, \\dots, N-1\\}$ 和 $s \\in \\{-1, 1, 0\\}$。由于网格结构的不同，混叠关系也有所不同：\n$$\n\\cos((m + 2N)\\theta_j) = \\cos\\left(m\\theta_j + 2N \\frac{(j+\\frac{1}{2})\\pi}{N}\\right) = \\cos(m\\theta_j + (2j+1)\\pi) = -\\cos(m\\theta_j)\n$$\n$$\n\\cos((2N - m)\\theta_j) = \\cos\\left(2N \\frac{(j+\\frac{1}{2})\\pi}{N} - m\\theta_j\\right) = \\cos((2j+1)\\pi - m\\theta_j) = -\\cos(m\\theta_j)\n$$\n这些恒等式揭示，将模式指数增加 $2N$ 会翻转采样向量的符号。通过将 $m$ 写为 $m = q(2N) + r$ 可以找到一个更通用的关系，其中 $q = \\lfloor m/(2N) \\rfloor$ 是商，$r=m \\pmod{2N}$ 是余数（$0 \\le r  2N$）。\n$$\n\\cos(m\\theta_j) = \\cos((q \\cdot 2N + r)\\theta_j) = \\cos\\left(q(2j+1)\\pi + r\\theta_j\\right) = (-1)^q \\cos(r\\theta_j)\n$$\n现在我们必须将中间模式 $r$ 映射到范围 $\\{0, \\dots, N-1\\}$。\n1.  如果 $0 \\le r  N$，则 $k_{\\text{alias}} = r$，总符号为 $s=(-1)^q$。恒等式为 $\\cos(m\\theta_j) = (-1)^q \\cos(k_{\\text{alias}}\\theta_j)$。\n2.  如果 $r=N$，则对于所有 $j$，$\\cos(N\\theta_j) = \\cos(N \\frac{(j+1/2)\\pi}{N}) = \\cos((j+1/2)\\pi) = 0$。采样向量恒等于零。在这种情况下，根据问题定义，$k_{\\text{alias}} = -1$ 且 $s=0$。\n3.  如果 $N  r  2N$，我们令 $k_{\\text{alias}} = 2N-r$，因此 $0  k_{\\text{alias}}  N$。使用推导出的第二个恒等式：$\\cos(r\\theta_j) = \\cos((2N-k_{\\text{alias}})\\theta_j) = -\\cos(k_{\\text{alias}}\\theta_j)$。\n    将此代入通用关系中得到：\n    $$\n    \\cos(m\\theta_j) = (-1)^q \\cos(r\\theta_j) = (-1)^q (-\\cos(k_{\\text{alias}}\\theta_j)) = (-1)^{q+1} \\cos(k_{\\text{alias}}\\theta_j)\n    $$\n    因此，在这种情况下，混叠模式是 $k_{\\text{alias}} = 2N-r$，符号是 $s=(-1)^{q+1}$。\n\nDCT-II 系数 $c_{k_{\\text{alias}}}$ 的符号将与这个推导出的符号 $s$ 相匹配。\n\n### 应用于测试用例\n\n基于上述分析，我们可以确定每个用例的结果。\n\n- **情况 A：第二类，$n=8, m=21$**\n  - $2n=16$。$r=21 \\pmod{16} = 5$。由于 $5 \\le 8$，$k_{\\text{alias}}=5$。符号 $s=1$。结果：$[5, 1]$。\n\n- **情况 B：第二类，$n=8, m=13$**\n  - $2n=16$。$r=13 \\pmod{16} = 13$。由于 $13>8$，$k_{\\text{alias}}=16-13=3$。符号 $s=1$。结果：$[3, 1]$。\n\n- **情况 C：第一类，$N=9, m=20$**\n  - $2N=18$。$m=20 = 1 \\cdot 18 + 2$。所以 $q=1, r=2$。由于 $r=29$，$k_{\\text{alias}}=r=2$。符号 $s=(-1)^q = (-1)^1=-1$。结果：$[2, -1]$。\n\n- **情况 D：第一类，$N=9, m=17$**\n  - $2N=18$。$m=17 = 0 \\cdot 18 + 17$。所以 $q=0, r=17$。由于 $r=17>9$，$k_{\\text{alias}}=18-17=1$。符号 $s=(-1)^{q+1}=(-1)^{0+1}=-1$。结果：$[1, -1]$。\n\n- **情况 E：第一类，$N=10, m=10$**\n  - $2N=20$。$m=10 = 0 \\cdot 20 + 10$。所以 $q=0, r=10$。由于 $r=N=10$，采样向量为零向量。结果：$[-1, 0]$。\n\n- **情况 F：第二类，$n=7, m=28$**\n  - $2n=14$。$r=28 \\pmod{14} = 0$。由于 $0 \\le 7$，$k_{\\text{alias}}=0$。符号 $s=1$。结果：$[0, 1]$。\n\n- **情况 G：第二类，$n=7, m=7$**\n  - $2n=14$。$r=7 \\pmod{14} = 7$。由于 $7 \\le 7$，$k_{\\text{alias}}=7$。符号 $s=1$。结果：$[7, 1]$。\n\n以下程序将实现指定的数值过程来验证这些结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import dct\n\ndef solve():\n    \"\"\"\n    Solves for aliasing index and sign for a suite of test cases\n    involving sampling Chebyshev polynomials on Chebyshev grids.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (node_type, resolution, mode_m)\n        ('second', 8, 21), # Case A\n        ('second', 8, 13), # Case B\n        ('first', 9, 20),  # Case C\n        ('first', 9, 17),  # Case D\n        ('first', 10, 10), # Case E\n        ('second', 7, 28), # Case F\n        ('second', 7, 7),  # Case G\n    ]\n\n    results = []\n    for node_type, res, m in test_cases:\n        k_alias = 0\n        s = 0\n\n        if node_type == 'second':\n            # Chebyshev points of the second kind (Chebyshev-Gauss-Lobatto)\n            # n = resolution parameter, n+1 points\n            n = res\n            num_points = n + 1\n            # theta_j = j*pi/n, for j=0,...,n\n            theta = np.arange(num_points) * np.pi / n\n            # y_j = T_m(x_j) = cos(m*theta_j)\n            y = np.cos(m * theta)\n            \n            # Check if sample vector is numerically zero\n            if np.allclose(y, 0):\n                k_alias = -1\n                s = 0\n            else:\n                # Compute DCT-I coefficients with orthonormal normalization\n                coeffs = dct(y, type=1, norm='ortho')\n                # Find the index of the maximal coefficient (in absolute value)\n                k_alias = np.argmax(np.abs(coeffs))\n                # Determine the sign based on the coefficient\n                s = np.sign(coeffs[k_alias])\n\n        elif node_type == 'first':\n            # Chebyshev points of the first kind (Chebyshev-Gauss)\n            # N = resolution parameter, N points\n            N = res\n            num_points = N\n            # theta_j = (j+1/2)*pi/N, for j=0,...,N-1\n            theta = (np.arange(num_points) + 0.5) * np.pi / N\n            # y_j = T_m(x_j) = cos(m*theta_j)\n            y = np.cos(m * theta)\n\n            # Check if sample vector is numerically zero\n            if np.allclose(y, 0):\n                k_alias = -1\n                s = 0\n            else:\n                # Compute DCT-II coefficients with orthonormal normalization\n                coeffs = dct(y, type=2, norm='ortho')\n                # Find the index of the maximal coefficient (in absolute value)\n                k_alias = np.argmax(np.abs(coeffs))\n                # Determine the sign based on the coefficient\n                s = np.sign(coeffs[k_alias])\n\n        results.append([int(k_alias), int(s)])\n\n    # Format the results into the required single-line string format.\n    # e.g., [[k1,s1],[k2,s2],...] with no spaces.\n    formatted_results = [f\"[{k},{s}]\" for k, s in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}