{
    "hands_on_practices": [
        {
            "introduction": "处理混叠误差有多种策略，最常见的包括网格填充和谱截断。本练习将引导您对二次非线性的两种经典去混叠方法——“$3/2$ 填充规则”和“$2/3$ 截断规则”——进行量化比较。此外，我们还将探索如何将这些思想推广到更复杂的三次非线性问题，并评估一个假设的“$4/3$ 填充规则”的有效性。",
            "id": "3374815",
            "problem": "考虑一个长度为 $2\\pi$ 的一维周期域和使用 $N$ 个等距网格点的伪谱离散化，其中 $N$ 为偶数。设 $u(x)$ 是一个在此网格上表示的实值带限函数。$u(x)$ 的离散傅里叶变换（DFT）产生谱系数 $\\widehat{u}_k$，其支持集为整数波数集 $k \\in \\{-N/2,\\ldots,N/2-1\\}$，并理解DFT约定和奈奎斯特波数索引是一致采用的。\n\n基本原理：\n- 傅里叶变换的卷积定理指出，逐点乘积 $f(x)g(x)$ 的傅里叶变换是各个傅里叶谱的离散卷积：如果 $\\widehat{f}_k$ 和 $\\widehat{g}_k$ 分别是 $f$ 和 $g$ 的谱系数，那么乘积 $h(x)=f(x)g(x)$ 的谱系数为 $\\widehat{h}_k = \\sum_{p+q=k} \\widehat{f}_p \\widehat{g}_q$。对于多项式非线性 $f(u)=u^m$，这可以扩展为 $u$ 的谱的 $m$ 重离散卷积。\n- 在离散傅里叶表示中，当卷积产生的波数超出奈奎斯特极限 $|k|  N/2$ 时，会出现混叠。这些波数会以模 $N$ 的方式回卷到解析频带内，从而污染频谱。\n- 在傅里叶空间中进行补零，对应于在物理空间中进行傅里叶插值，这会提高奈奎斯特极限，并且如果补零足够大，可以在非线性乘积过程中防止回卷。\n- 经典的 Orszag $3/2$ 规则用于二次非线性，它在物理空间相乘之前，将数据补零至 $M=\\frac{3}{2}N$，然后在计算后截断回 $N$。经典的 $2/3$ 截断规则在非线性乘积前后将所有 $|k|  \\lfloor N/3 \\rfloor$ 的模式置零，从而防止在保留的频带内产生混叠。\n- 对于三次非线性，通过类比，可以假设一个 $4/3$ 补零规则（$M=\\frac{4}{3}N$）来减轻混叠，但其充分性必须被检验；对于一个截断波数 $K_c$， $u^3$ 的谱的三重卷积可以达到高达 $3K_c$ 的波数。\n\n任务：\n1. 实现一个程序，该程序在周期域 $[0,2\\pi)$ 上用 $N$ 个点采样，构建测试函数 $u(x)$，其形式为指定振幅和整数波数的余弦函数之和：\n   $$u(x) = \\sum_{j} a_j \\cos(k_j x),$$\n   其中 $x$ 的单位是弧度。\n2. 对于 $f(u)=u^2$，实现：\n   - $3/2$ 补零方法：将 $u$ 变换到 $N$ 个点的傅里叶空间，补零到 $M=\\frac{3}{2}N$，逆变换到 $M$ 个点，在物理空间中计算 $u^2$，再变换回 $M$ 个点的傅里叶空间，最后截断回 $N$。\n   - $2/3$ 截断方法：通过将 $|k|  \\lfloor N/3 \\rfloor$ 的模式置零来过滤 $u$，在 $N$ 个点的物理空间中计算 $u^2$，变换回傅里叶空间，并再次过滤至 $|k| \\le \\lfloor N/3 \\rfloor$。\n3. 对于 $f(u)=u^3$，实现假设的 $4/3$ 补零方法：补零到 $M=\\frac{4}{3}N$，并以类似于 $3/2$ 方法处理 $u^3$ 的方式进行处理。\n4. 通过在足够大的网格上（使用 $M_{\\text{gt}}=4N$）执行非线性运算来建立一个无混叠的基准真相，然后将得到的谱截断回 $N$（在与 $2/3$ 截断方法比较时，截断至 $|k| \\le \\lfloor N/3 \\rfloor$）以获得参考谱。\n5. 按如下方式量化误差：\n   - 对于二次情况，对于 $3/2$ 补零方法，计算去混叠谱与无混叠基准真相谱在 $N$ 点频带上的无穷范数（最大绝对差）；对于 $2/3$ 截断方法，在保留的 $|k| \\le \\lfloor N/3 \\rfloor$ 频带上计算该值。\n   - 对于三次情况，通过奈奎斯特波数附近顶部解析模式中的最大绝对误差来量化残留混叠。具体来说，将高波数集定义为低于 $N/2$ 的最后 $W=5$ 个正模式和高于 $-N/2$ 的前 $W=5$ 个负模式的索引并集，并报告假设的 $4/3$ 补零结果与无混叠基准真相在此集合上的最大绝对差。\n\n测试套件：\n- 情况1（二次，接近 $2/3$ 截断点）：$N=96$，$u(x) = \\cos(31x) + 0.8\\cos(32x)$。计算：\n  - $E_{\\text{quad},3/2}$：$3/2$ 补零方法相对于无混叠基准真相在整个 $N$ 点频带上的无穷范数误差。\n  - $E_{\\text{quad},2/3}$：$2/3$ 截断方法相对于截断至 $|k| \\le \\lfloor N/3 \\rfloor$ 的无混叠基准真相的无穷范数误差。\n- 情况2（三次，假设的 $4/3$ 补零）：$N=96$，与情况1相同的 $u(x)$。计算：\n  - $P_{\\text{cubic},4/3,96}$：如上所述定义的奈奎斯特波数附近的残留混叠峰值。\n- 情况3（三次，边界压力测试）：$N=128$，$u(x) = \\cos(41x) + 0.9\\cos(42x)$。计算：\n  - $P_{\\text{cubic},4/3,128}$：奈奎斯特波数附近的残留混叠峰值。\n\n答案规格：\n- 所有角度均以弧度为单位。\n- 单位是无量纲的；不涉及物理单位。\n- 对于每种情况，输出均为浮点数。\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔结果列表，顺序如下：\n  $$[E_{\\text{quad},3/2}, E_{\\text{quad},2/3}, P_{\\text{cubic},4/3,96}, P_{\\text{cubic},4/3,128}].$$",
            "solution": "该问题要求实现和验证几种用于非线性偏微分方程伪谱方法的去混叠技术。问题的核心在于混叠，这是一种离散傅里叶表示的产物，其中由非线性运算产生的高频内容被错误地表示为低频内容。我们将分析用于二次 ($u^2$) 和三次 ($u^3$) 非线性的方法。\n\n一个定义在周期域 $[0, 2\\pi)$ 上并在 $N$ 个等距网格点 $x_j = j (2\\pi/N)$（其中 $j=0, \\ldots, N-1$）上离散化的函数 $u(x)$，可以用其离散傅里叶变换（DFT）系数 $\\widehat{u}_k$ 来表示。对于实值函数 $u$，这些系数对应于范围 $\\{-N/2, \\ldots, N/2-1\\}$ 内的波数 $k$。DFT对（未归一化）由下式给出：\n$$ \\widehat{u}_k = \\sum_{j=0}^{N-1} u(x_j) e^{-ikx_j} \\quad \\text{和} \\quad u(x_j) = \\frac{1}{N} \\sum_{k=-N/2}^{N/2-1} \\widehat{u}_k e^{ikx_j} $$\n物理空间中的逐点乘积，如 $h(x) = u(x)^m$，对应于谱空间中的m重离散卷积：\n$$ \\widehat{h}_k = \\frac{1}{N^{m-1}} (\\widehat{u} * \\widehat{u} * \\ldots * \\widehat{u})_k = \\frac{1}{N^{m-1}} \\sum_{k_1+\\ldots+k_m=k \\pmod N} \\widehat{u}_{k_1} \\ldots \\widehat{u}_{k_m} $$\n求和中的模 $N$ 运算是混叠的来源。如果波数之和 $k_{true} = k_1+\\ldots+k_m$ 超出可表示范围 $[ -N/2, N/2-1 ]$，它将“回卷”并污染一个系数 $\\widehat{h}_k$，其中 $k = k_{true} \\pmod N$。\n\n为了提供一个准确性基准，我们建立一个无混叠的基准真相。这是通过在明显更大的网格（大小为 $M_{\\text{gt}} = 4N$）上执行非线性运算来实现的。补零因子为 $4$ 确保了对于二次 ($m=2$) 和三次 ($m=3$) 非线性，所有乘积波数（高达约 $m N/2$）都远在补零网格的奈奎斯特极限 ($M_{\\text{gt}}/2 = 2N$) 之内。在 $M_{\\text{gt}}$ 点网格上计算得到的谱，然后被截断回原始的 $N$ 个模式，作为参考。\n\n待评估的去混叠方法如下：\n\n1.  **用于 $u^2$ 的 Orszag $3/2$ 补零规则**：\n    信号的谱 $\\widehat{u}_N$ 被补零至大小 $M = \\lceil 3/2 N \\rceil$。这对应于将信号插值到物理空间中一个更精细的 $M$ 点网格上。平方运算在该网格上执行，结果被变换回谱空间。由于 $u^2$ 中的最高波数大约是 $2 \\times (N/2) = N$，而补零网格的奈奎斯特极限是 $M/2 \\approx 3N/4$，所以这种方法对于任意信号并非完美去混叠。然而，如果信号经过预滤波，它是有效的。本问题要求在没有预滤波的情况下测试它。得到的 $M$ 点谱被截断回 $N$ 个模式以进行比较。\n\n2.  **用于 $u^2$ 的 $2/3$ 截断规则**：\n    该方法完全在原始的 $N$ 点网格上操作。首先，通过将所有 $|k|  K_c = \\lfloor N/3 \\rfloor$ 的系数 $\\widehat{u}_k$ 置零来过滤 $u$ 的谱。然后在物理空间中计算乘积，得到的谱再次使用相同的截断波数 $K_c$ 进行过滤。该规则保证了保留的模式（$|k| \\le K_c$）没有混叠，前提是 $N$ 不是 $3$ 的倍数。如果 $N$ 是 $3$ 的倍数，混叠可能在截断波数 $k=\\pm K_c$ 处发生。\n\n3.  **假设的用于 $u^3$ 的 $4/3$ 补零规则**：\n    与二次项的 $3/2$ 规则类比，提出了一个用于三次非线性的 $4/3$ 补零规则。过程是相同的：将 $u$ 的谱补零至大小 $M = \\lceil 4/3 N \\rceil$，在M点网格上的物理空间中计算 $u^3$，变换回来，并截断为 $N$ 个模式。我们将注意到，对于 $N=128$，补零后的大小 $M=\\lceil 4/3 \\times 128 \\rceil = 171$ 不是一个偶数，这是一个轻微的不规则性，但在计算上是可处理的。此规则的有效性将通过检查奈奎斯特极限附近的残留混叠误差来量化。\n\n实现过程首先在各自的网格上定义测试函数 $u(x) = \\sum_j a_j \\cos(k_j x)$。然后，为每种情况计算基准真值谱。随后，执行每个去混叠算法，并将其结果谱与使用指定误差度量的基准真相进行比较。对于二次情况，使用谱系数的 $L_\\infty$ 范数（最大绝对差）。对于三次情况，峰值误差是在一组特定的高波数模式上测量的：最接近正奈奎斯特频率的 $W=5$ 个模式和最接近负奈奎斯特频率的 $W=5$ 个模式。用于谱补零和截断的辅助函数使用 `fftshift` 来实现，以确保正确处理波数索引。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft, fftshift, ifftshift, fftfreq\n\ndef solve():\n    \"\"\"\n    Implements and evaluates several dealiasing techniques for pseudospectral methods.\n    The problem is divided into three test scenarios evaluating quadratic and cubic nonlinearities.\n    \"\"\"\n\n    def pad_spectrum(spec_n, N, M):\n        \"\"\"Pads a 1D spectrum from size N to M > N using fftshift for clarity.\"\"\"\n        if N > M:\n            raise ValueError(\"Padding size M must be greater than original size N.\")\n        spec_n_shifted = fftshift(spec_n)\n        spec_m_padded_shifted = np.zeros(M, dtype=complex)\n        \n        # Calculate the slice in the padded array to place the original spectrum.\n        # This handles both even and odd N, M correctly.\n        start_idx = (M - N) // 2\n        end_idx = start_idx + N\n        \n        spec_m_padded_shifted[start_idx:end_idx] = spec_n_shifted\n        \n        return ifftshift(spec_m_padded_shifted)\n\n    def truncate_spectrum(spec_m, M, N):\n        \"\"\"Truncates a 1D spectrum from size M to N  M using fftshift.\"\"\"\n        if M  N:\n            raise ValueError(\"Original size M must be greater than truncation size N.\")\n        spec_m_shifted = fftshift(spec_m)\n        \n        # Calculate the slice of the original spectrum to keep.\n        start_idx = (M - N) // 2\n        end_idx = start_idx + N\n        \n        spec_n_truncated_shifted = spec_m_shifted[start_idx:end_idx]\n        \n        return ifftshift(spec_n_truncated_shifted)\n    \n    results = []\n    \n    # --- Case 1: Quadratic nonlinearity with N=96 ---\n    N_96 = 96\n    u_def_96 = [(1.0, 31), (0.8, 32)]\n    x_96 = np.linspace(0, 2*np.pi, N_96, endpoint=False)\n    u_96 = np.zeros(N_96)\n    for amp, k_val in u_def_96:\n        u_96 += amp * np.cos(k_val * x_96)\n    u_spec_96 = fft(u_96)\n    \n    power_quad = 2\n    \n    # Ground Truth for quadratic case (M_gt = 4N)\n    M_gt_quad = 4 * N_96\n    u_spec_gt_quad_padded = pad_spectrum(u_spec_96, N_96, M_gt_quad)\n    u_gt_quad = ifft(u_spec_gt_quad_padded)\n    u_pow_gt_quad = u_gt_quad ** power_quad\n    u_pow_spec_gt_quad_padded = fft(u_pow_gt_quad)\n    u_pow_spec_gt_quad = truncate_spectrum(u_pow_spec_gt_quad_padded, M_gt_quad, N_96)\n\n    # 1a) 3/2 Padding Method ($E_{quad,3/2}$)\n    padding_factor_32 = 3 / 2\n    M_pad_32 = int(np.ceil(padding_factor_32 * N_96))\n    u_spec_padded_32 = pad_spectrum(u_spec_96, N_96, M_pad_32)\n    u_padded_32 = ifft(u_spec_padded_32)\n    u_pow_padded_32 = u_padded_32 ** power_quad\n    u_pow_spec_padded_32 = fft(u_pow_padded_32)\n    u_pow_spec_dealiased_32 = truncate_spectrum(u_pow_spec_padded_32, M_pad_32, N_96)\n    \n    E_quad_3_2 = np.max(np.abs(u_pow_spec_dealiased_32 - u_pow_spec_gt_quad))\n    results.append(E_quad_3_2)\n    \n    # 1b) 2/3 Truncation Method ($E_{quad,2/3}$)\n    trunc_factor_23 = 1 / 3\n    K_c_23 = int(np.floor(N_96 * trunc_factor_23))\n    k_N_96 = fftshift(fftfreq(N_96, d=1/N_96))\n    \n    mask_retained = np.abs(k_N_96) = K_c_23\n    u_pow_spec_gt_quad_trunc = fftshift(u_pow_spec_gt_quad)[mask_retained]\n\n    u_spec_96_shifted = fftshift(u_spec_96)\n    mask_filter = np.abs(k_N_96) > K_c_23\n    u_spec_96_shifted[mask_filter] = 0.0\n    u_spec_filt_23 = ifftshift(u_spec_96_shifted)\n    u_filt_23 = ifft(u_spec_filt_23)\n    \n    u_pow_filt_23 = u_filt_23 ** power_quad\n    u_pow_spec_filt_23 = fft(u_pow_spec_filt_23)\n    \n    u_pow_spec_filt_23_shifted = fftshift(u_pow_spec_filt_23)\n    u_pow_spec_dealiased_trunc_23 = u_pow_spec_filt_23_shifted[mask_retained]\n    \n    E_quad_2_3 = np.max(np.abs(u_pow_spec_dealiased_trunc_23 - u_pow_spec_gt_quad_trunc))\n    results.append(E_quad_2_3)\n\n    # --- Case 2: Cubic nonlinearity with N=96 ($P_{cubic,4/3,96}$) ---\n    power_cubic = 3\n    \n    M_gt_cubic_96 = 4 * N_96\n    u_spec_gt_cubic_padded_96 = pad_spectrum(u_spec_96, N_96, M_gt_cubic_96)\n    u_gt_cubic_96 = ifft(u_spec_gt_cubic_padded_96)\n    u_pow_gt_cubic_96 = u_gt_cubic_96 ** power_cubic\n    u_pow_spec_gt_cubic_padded_96 = fft(u_pow_gt_cubic_96)\n    u_pow_spec_gt_cubic_96 = truncate_spectrum(u_pow_spec_gt_cubic_padded_96, M_gt_cubic_96, N_96)\n    \n    padding_factor_43 = 4 / 3\n    M_pad_43_96 = int(np.ceil(padding_factor_43 * N_96))\n    u_spec_padded_43_96 = pad_spectrum(u_spec_96, N_96, M_pad_43_96)\n    u_padded_43_96 = ifft(u_spec_padded_43_96)\n    u_pow_padded_43_96 = u_padded_43_96 ** power_cubic\n    u_pow_spec_padded_43_96 = fft(u_pow_spec_padded_43_96)\n    u_pow_spec_dealiased_43_96 = truncate_spectrum(u_pow_spec_padded_43_96, M_pad_43_96, N_96)\n\n    W = 5\n    spec_diff_96 = u_pow_spec_dealiased_43_96 - u_pow_spec_gt_cubic_96\n    spec_diff_shifted_96 = fftshift(spec_diff_96)\n    error_neg_96 = np.max(np.abs(spec_diff_shifted_96[0:W]))\n    error_pos_96 = np.max(np.abs(spec_diff_shifted_96[N_96-W:N_96]))\n    P_cubic_4_3_96 = max(error_neg_96, error_pos_96)\n    results.append(P_cubic_4_3_96)\n    \n    # --- Case 3: Cubic nonlinearity with N=128 ($P_{cubic,4/3,128}$) ---\n    N_128 = 128\n    u_def_128 = [(1.0, 41), (0.9, 42)]\n    x_128 = np.linspace(0, 2*np.pi, N_128, endpoint=False)\n    u_128 = np.zeros(N_128)\n    for amp, k_val in u_def_128:\n        u_128 += amp * np.cos(k_val * x_128)\n    u_spec_128 = fft(u_128)\n    \n    M_gt_cubic_128 = 4 * N_128\n    u_spec_gt_cubic_padded_128 = pad_spectrum(u_spec_128, N_128, M_gt_cubic_128)\n    u_gt_cubic_128 = ifft(u_spec_gt_cubic_padded_128)\n    u_pow_gt_cubic_128 = u_gt_cubic_128 ** power_cubic\n    u_pow_spec_gt_cubic_padded_128 = fft(u_pow_gt_cubic_128)\n    u_pow_spec_gt_cubic_128 = truncate_spectrum(u_pow_spec_gt_cubic_padded_128, M_gt_cubic_128, N_128)\n\n    M_pad_43_128 = int(np.ceil(padding_factor_43 * N_128)) # This will be 171\n    u_spec_padded_43_128 = pad_spectrum(u_spec_128, N_128, M_pad_43_128)\n    u_padded_43_128 = ifft(u_spec_padded_43_128)\n    u_pow_padded_43_128 = u_padded_43_128 ** power_cubic\n    u_pow_spec_padded_43_128 = fft(u_pow_spec_padded_43_128)\n    u_pow_spec_dealiased_43_128 = truncate_spectrum(u_pow_spec_padded_43_128, M_pad_43_128, N_128)\n\n    spec_diff_128 = u_pow_spec_dealiased_43_128 - u_pow_spec_gt_cubic_128\n    spec_diff_shifted_128 = fftshift(spec_diff_128)\n    error_neg_128 = np.max(np.abs(spec_diff_shifted_128[0:W]))\n    error_pos_128 = np.max(np.abs(spec_diff_shifted_128[N_128-W:N_128]))\n    P_cubic_4_3_128 = max(error_neg_128, error_pos_128)\n    results.append(P_cubic_4_3_128)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "混叠现象并非傅里叶谱方法所独有，它同样存在于其他基于投影的数值方法中，例如在单元上使用多项式基的间断伽辽金（DG）方法。本练习将把去混叠的概念从周期性问题推广到 DG 方法的参考单元上。您将研究如何通过在勒让德多项式空间中进行填充，来精确处理由泰勒级数逼近的非线性源项，并量化不充分填充所导致的残余混叠误差。",
            "id": "3374730",
            "problem": "考虑一个在间断 Galerkin (DG) 方法中使用的、定义域为 $[-1,1]$ 的单个参考单元。令 $\\{P_{n}(x)\\}_{n=0}^{\\infty}$ 表示 $[-1,1]$ 上的 Legendre 多项式基，其标准 $L^{2}$ 内积为 $\\langle f,g\\rangle=\\int_{-1}^{1} f(x)g(x)\\,\\mathrm{d}x$，满足 $\\int_{-1}^{1} P_{n}(x)P_{m}(x)\\,\\mathrm{d}x=\\frac{2}{2n+1}\\delta_{nm}$。固定一个整数多项式次数 $N\\ge 0$，并定义一个模态多项式\n$$\nu_{N}(x)=\\sum_{k=0}^{N} a_{k}P_{k}(x),\\qquad a_{k}=\\frac{1}{k+1}.\n$$\n考虑非线性源映射 $S(u)=\\exp(u)$，其由 $m$ 阶截断 Taylor 级数近似\n$$\nS_{m}(u)=\\sum_{p=0}^{m}\\frac{u^{p}}{p!},\n$$\n其中 $m\\ge 0$ 是一个整数。逐单元的填充-截断过程定义如下：\n- 选择一个填充次数 $M\\ge N$，并令 $Q=M+1$。\n- 在具有权重 $\\{w_{i}\\}_{i=1}^{Q}$ 的 $Q$ 点 Gauss–Legendre 求积 (GL) 节点 $\\{x_{i}\\}_{i=1}^{Q}$ 上计算 $u_{N}(x)$，以获得节点值 $\\{u_{N}(x_{i})\\}_{i=1}^{Q}$。\n- 计算 $S_{m}(u_{N})$ 的节点值，即 $\\left\\{S_{m}(u_{N}(x_{i}))\\right\\}_{i=1}^{Q}$。\n- 使用 GL 法则将 $S_{m}(u_{N})$ 投影回 Legendre 模态系数，即计算\n$$\n\\widehat{c}_{n}^{(M)}=\\frac{2n+1}{2}\\sum_{i=1}^{Q} w_{i}\\,S_{m}\\!\\left(u_{N}(x_{i})\\right)P_{n}(x_{i}),\\qquad n=0,1,\\dots,N,\n$$\n然后通过仅保留 $\\left\\{\\widehat{c}_{n}^{(M)}\\right\\}_{n=0}^{N}$ 来截断至次数 $N$。这得到了次数最高为 $N$ 的填充并截断后的系数。\n\n为了得到数学上精确的参考值，定义精确的 $N$ 次投影系数 $c_{n}^{\\star}$ 为\n$$\nc_{n}^{\\star}=\\frac{2n+1}{2}\\int_{-1}^{1} S_{m}\\!\\left(u_{N}(x)\\right)P_{n}(x)\\,\\mathrm{d}x,\\qquad n=0,1,\\dots,N,\n$$\n使用具有 $Q_{\\mathrm{ref}}$ 个点的 Gauss–Legendre 求积法计算，该方法对次数最高为 $(m+1)N$ 的多项式是精确的，即任何满足 $2Q_{\\mathrm{ref}}-1\\ge (m+1)N$ 的 $Q_{\\mathrm{ref}}$ 均可。\n\n任务 A (推导)。从 $u_{N}(x)$ 是一个次数至多为 $N$ 的多项式以及 $u_{N}(x)^{p}$ 的次数至多为 $pN$ 这两个事实出发，推导最小填充次数 $M$，使得填充表示能够在截断前精确地捕捉 $S_{m}(u_{N})$。仅使用多项式复合的次数计算和 Gauss–Legendre 求积的精确性性质来证明你的结果。\n\n任务 B (残余混叠的量化)。对于以下测试组中的每个三元组 $(N,m,M)$：\n- $(N,m,M)=(4,3,12)$,\n- $(N,m,M)=(4,3,11)$,\n- $(N,m,M)=(5,2,10)$,\n- $(N,m,M)=(5,2,9)$,\n- $(N,m,M)=(1,5,5)$,\n- $(N,m,M)=(0,7,0)$,\n计算截断回次数 $N$ 后的最大绝对系数误差，\n$$\nE_{\\infty}(N,m,M)=\\max_{0\\le n\\le N}\\left|\\widehat{c}_{n}^{(M)}-c_{n}^{\\star}\\right|.\n$$\n对精确参考的 Gauss–Legendre 求积使用 $Q_{\\mathrm{ref}}=\\max\\!\\left(N+1,\\left\\lceil\\frac{(m+1)N+1}{2}\\right\\rceil\\right)$，以便定义 $c_{n}^{\\star}$ 的积分能够被精确计算。\n\n您的程序必须：\n- 实现上述逐单元的填充-截断过程。\n- 使用指定的 $Q_{\\mathrm{ref}}$ 个点，通过 Gauss–Legendre 求积法实现精确参考投影。\n- 按所列顺序为每个测试用例计算 $E_{\\infty}(N,m,M)$，并生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[e_{1},e_{2},\\dots]$），其中每个 $e_{j}$ 是对应于第 $j$ 个测试用例的浮点数。\n\n所有计算都是纯数学的；不出现物理单位。不涉及角度。唯一的输出是针对指定测试用例的浮点误差 $E_{\\infty}$。",
            "solution": "该问题被评估为具有科学依据、良定且客观，所有必要的数据和定义都已提供，以获得唯一且有意义的解。问题陈述有效。\n\n解决方案按要求分为两部分呈现：任务 A 的理论推导和任务 B 的数值程序描述。\n\n### 任务 A：最小填充次数的推导\n\n目标是找到最小填充次数 $M$，使得非线性项 $S_{m}(u_{N}(x))$ 的填充表示是精确的。\n\n我们来分析所涉及函数的性质。\n1. 输入多项式 $u_{N}(x) = \\sum_{k=0}^{N} a_{k}P_{k}(x)$ 是一个关于 $x$ 的次数至多为 $N$ 的多项式。\n2. 近似源项 $S_{m}(u)=\\sum_{p=0}^{m}\\frac{u^{p}}{p!}$ 是一个关于变量 $u$ 的次数为 $m$ 的多项式。\n3. 复合函数 $f(x) = S_{m}(u_{N}(x))$ 是一个关于 $x$ 的多项式。由于将一个次数为 $N$ 的多项式提升到 $p$ 次幂会得到一个次数为 $pN$ 的多项式，因此复合函数中的最高次项来自 $(u_N(x))^m$。因此，$f(x)$ 的次数恰好是 $mN$（假设 $a_N \\neq 0$ 且 $N  0$；如果 $N=0$，则次数为 $0$）。\n\n填充-截断过程涉及在一个 Gauss-Legendre 求积法则的 $Q=M+1$ 个节点 $\\{x_i\\}$ 上计算 $f(x)$。令这些节点值为 $f_i = f(x_i)$。\n\n“填充表示” 指的是次数至多为 $M$ 的唯一多项式，我们称之为 $\\mathcal{I}_{M}f(x)$，它穿过这 $Q$ 个点。这是点集 $\\{(x_i, f_i)\\}_{i=1}^{Q}$ 的 Lagrange 插值多项式。\n\n短语“精确地捕捉 $S_{m}(u_{N})$”意味着这个插值多项式必须与原函数完全相同，即对于所有 $x \\in [-1, 1]$，都有 $\\mathcal{I}_{M}f(x) \\equiv f(x)$。\n\n多项式插值的一个基本定理指出，如果一个函数 $f(x)$ 本身是一个次数为 $D$ 的多项式，那么其通过 $M+1$ 个不同点的插值函数 $\\mathcal{I}_M f(x)$ 与 $f(x)$ 相同的充要条件是，插值多项式的次数至少等于原多项式的次数。也就是说，我们必须有 $M \\ge D$。\n\n在我们的情况下，要捕捉的函数是 $f(x)=S_{m}(u_{N}(x))$，其次数为 $D = mN$。因此，为了使填充表示精确，我们必须满足条件：\n$$\nM \\ge mN\n$$\n满足此条件的最小整数填充次数 $M$ 因此为 $M_{\\min} = mN$。\n\n当满足此条件 ($M \\ge mN$) 时，节点值集合 $\\{ S_m(u_N(x_i)) \\}_{i=1}^{Q}$ 在整个区间上唯一确定了多项式 $S_m(u_N(x))$。因此，任何基于这些节点值的投影积分（前提是求积对于插值函数本身足够精确，而事实确实如此）都将产生 $S_m(u_N(x))$ 的精确投影系数。误差 $E_{\\infty}(N, m, M)$ 将为零（在机器精度范围内）。如果 $M  mN$，插值多项式 $\\mathcal{I}_{M}f(x)$ 通常会因混叠而与 $S_{m}(u_{N}(x))$ 不同，从而导致非零误差。\n\n### 任务 B：残余混叠的量化\n\n该任务是为一组给定的测试用例计算最大绝对系数误差 $E_{\\infty}(N,m,M)=\\max_{0\\le n\\le N}\\left|\\widehat{c}_{n}^{(M)}-c_{n}^{\\star}\\right|$。这需要实现两种不同的程序来计算 $S_m(u_N(x))$ 的 Legendre 系数：一种使用参考高阶求积，另一种使用指定的填充求积。\n\n对于每个测试用例 $(N, m, M)$，总体算法如下：\n\n1. **构造多项式**：\n   - 模态多项式 $u_{N}(x)$ 构造为 $u_{N}(x)=\\sum_{k=0}^{N} \\frac{1}{k+1}P_{k}(x)$，其中 $P_k(x)$ 是 $k$ 次 Legendre 多项式。\n   - 非线性函数 $S_{m}(u)$ 实现为 Taylor 级数和 $S_{m}(u)=\\sum_{p=0}^{m}\\frac{u^{p}}{p!}$。\n\n2. **计算精确参考系数 ($c_{n}^{\\star}$)**：\n   - 参考系数由积分 $c_{n}^{\\star}=\\frac{2n+1}{2}\\int_{-1}^{1} S_{m}(u_{N}(x))P_{n}(x)\\,\\mathrm{d}x$ 定义。\n   - 被积函数 $S_{m}(u_{N}(x))P_{n}(x)$ 是一个次数至多为 $mN+n$ 的多项式。为了计算所有直到 $n=N$ 的系数，最高次的被积函数次数为 $(m+1)N$。\n   - 具有 $Q_{\\mathrm{pts}}$ 个点的 Gauss-Legendre 求积对于次数至多为 $2Q_{\\mathrm{pts}}-1$ 的多项式是精确的。为了保证积分的精确性，我们需要 $2Q_{\\mathrm{pts}}-1 \\ge (m+1)N$。\n   - 问题指定使用 $Q_{\\mathrm{ref}}=\\max\\!\\left(N+1,\\left\\lceil\\frac{(m+1)N+1}{2}\\right\\rceil\\right)$ 个点，这满足了精确性条件。\n   - 我们获得 $Q_{\\mathrm{ref}}$ 个 Gauss-Legendre 节点 $\\{x_i^{\\mathrm{ref}}\\}$ 和权重 $\\{w_i^{\\mathrm{ref}}\\}$。\n   - 系数通过数值求积计算：\n     $$\n     c_{n}^{\\star} = \\frac{2n+1}{2}\\sum_{i=1}^{Q_{\\mathrm{ref}}} w_{i}^{\\mathrm{ref}}\\,S_{m}\\!\\left(u_{N}(x_{i}^{\\mathrm{ref}})\\right)P_{n}(x_{i}^{\\mathrm{ref}}), \\quad n=0,\\dots,N.\n     $$\n\n3. **计算填充并截断后的系数 ($\\widehat{c}_{n}^{(M)}$)**：\n   - 此过程使用不同数量的求积点，$Q=M+1$。\n   - 我们获得 $Q$ 个 Gauss-Legendre 节点 $\\{x_j^{\\mathrm{pad}}\\}$ 和权重 $\\{w_j^{\\mathrm{pad}}\\}$。\n   - 系数以类似方式计算，但使用填充求积法则：\n     $$\n     \\widehat{c}_{n}^{(M)} = \\frac{2n+1}{2}\\sum_{j=1}^{Q} w_{j}^{\\mathrm{pad}}\\,S_{m}\\!\\left(u_{N}(x_{j}^{\\mathrm{pad}})\\right)P_{n}(x_{j}^{\\mathrm{pad}}), \\quad n=0,\\dots,N.\n     $$\n   - 如果 $M  mN$，此计算会涉及混叠误差，因为 $Q=M+1$ 个点不足以唯一确定次数为 $mN$ 的多项式 $S_m(u_N(x))$。\n\n4. **计算误差**：\n   - 对于每个测试用例，通过比较两组系数找到最大绝对误差：\n     $$\n     E_{\\infty}(N,m,M) = \\max_{0 \\le n \\le N} \\left| \\widehat{c}_{n}^{(M)} - c_{n}^{\\star} \\right|.\n     $$\n\n根据任务 A 的推导，我们预期在 $M \\ge mN$ 的情况下误差接近于零，而在 $M  mN$ 的情况下误差为非零。\n- $(N,m,M)=(4,3,12)$: $mN=12$。由于 $M \\ge mN$，预期 $E_{\\infty} \\approx 0$。\n- $(N,m,M)=(4,3,11)$: $mN=12$。由于 $M  mN$，预期 $E_{\\infty}  0$。\n- $(N,m,M)=(5,2,10)$: $mN=10$。由于 $M \\ge mN$，预期 $E_{\\infty} \\approx 0$。\n- $(N,m,M)=(5,2,9)$: $mN=10$。由于 $M  mN$，预期 $E_{\\infty}  0$。\n- $(N,m,M)=(1,5,5)$: $mN=5$。由于 $M \\ge mN$，预期 $E_{\\infty} \\approx 0$。\n- $(N,m,M)=(0,7,0)$: $mN=0$。由于 $M \\ge mN$，预期 $E_{\\infty} \\approx 0$。\n\n实现将使用 `numpy` 进行数组操作，使用 `numpy.polynomial.legendre.leggauss` 获取求积节点和权重，并使用 `scipy.special.eval_legendre` 计算 Legendre 多项式。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre\nfrom numpy.polynomial.legendre import leggauss\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the dealiasing problem by computing the maximal absolute coefficient error\n    for a series of test cases.\n    \"\"\"\n    \n    test_cases = [\n        (4, 3, 12),\n        (4, 3, 11),\n        (5, 2, 10),\n        (5, 2, 9),\n        (1, 5, 5),\n        (0, 7, 0),\n    ]\n\n    results = []\n\n    for N, m, M in test_cases:\n        \n        # 1. Define the polynomial u_N(x) and the source term S_m(u)\n\n        # Coefficients for u_N(x) are a_k = 1/(k+1)\n        u_N_coeffs = [1.0 / (k + 1) for k in range(N + 1)]\n\n        def u_N(x: np.ndarray) -> np.ndarray:\n            \"\"\"Evaluates u_N(x) = sum_{k=0 to N} a_k P_k(x) at points x.\"\"\"\n            val = np.zeros_like(x, dtype=np.float64)\n            for k in range(N + 1):\n                val += u_N_coeffs[k] * eval_legendre(k, x)\n            return val\n\n        # Precompute factorials for S_m(u)\n        factorials = [math.factorial(p) for p in range(m + 1)]\n\n        def S_m(u: np.ndarray) -> np.ndarray:\n            \"\"\"Evaluates S_m(u) = sum_{p=0 to m} u^p/p! at values u.\"\"\"\n            val = np.zeros_like(u, dtype=np.float64)\n            for p in range(m + 1):\n                val += (u**p) / factorials[p]\n            return val\n\n        def compute_legendre_coeffs(\n            deg_N: int, \n            func_vals: np.ndarray, \n            nodes: np.ndarray, \n            weights: np.ndarray\n        ) -> np.ndarray:\n            \"\"\"\n            Computes Legendre coefficients of a function from its values at quadrature nodes.\n            \"\"\"\n            coeffs = np.zeros(deg_N + 1, dtype=np.float64)\n            for n in range(deg_N + 1):\n                P_n_vals = eval_legendre(n, nodes)\n                integral = np.sum(weights * func_vals * P_n_vals)\n                coeffs[n] = (2 * n + 1) / 2.0 * integral\n            return coeffs\n\n        # 2. Compute the exact reference coefficients c_n_star\n\n        # Determine the number of quadrature points for the reference calculation\n        # to exactly integrate a polynomial of degree up to (m+1)*N.\n        deg_to_integrate = (m + 1) * N\n        Q_ref = max(N + 1, int(np.ceil((deg_to_integrate + 1) / 2.0)))\n        \n        # Get reference quadrature nodes and weights\n        x_ref, w_ref = leggauss(Q_ref)\n\n        # Evaluate S_m(u_N(x)) at reference nodes\n        u_N_vals_ref = u_N(x_ref)\n        S_m_u_N_vals_ref = S_m(u_N_vals_ref)\n\n        # Compute reference coefficients\n        c_star = compute_legendre_coeffs(N, S_m_u_N_vals_ref, x_ref, w_ref)\n\n        # 3. Compute the padded-and-truncated coefficients c_n_hat\n\n        # Number of points for the padded representation\n        Q_pad = M + 1\n\n        # Get padded quadrature nodes and weights\n        x_pad, w_pad = leggauss(Q_pad)\n\n        # Evaluate S_m(u_N(x)) at padded nodes\n        u_N_vals_pad = u_N(x_pad)\n        S_m_u_N_vals_pad = S_m(u_N_vals_pad)\n        \n        # Compute padded coefficients\n        c_hat = compute_legendre_coeffs(N, S_m_u_N_vals_pad, x_pad, w_pad)\n        \n        # 4. Compute the maximal absolute coefficient error E_infinity\n        \n        error = np.max(np.abs(c_hat - c_star))\n        results.append(error)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(f'{r:.18e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}