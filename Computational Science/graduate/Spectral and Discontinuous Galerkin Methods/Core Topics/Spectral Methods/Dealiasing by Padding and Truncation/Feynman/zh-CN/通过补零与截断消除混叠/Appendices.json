{
    "hands_on_practices": [
        {
            "introduction": "去混叠的原理不仅限于傅里叶方法的周期性域。本练习将此概念扩展到间断伽辽金（DG）框架，其中函数由局部单元上的多项式表示。您将探索在这种情况下如何将“填充”重新诠释为增加多项式阶数和求积精度，首先推导理论要求，然后通过计算证实足够的填充如何能得到无混叠的结果。",
            "id": "3374730",
            "problem": "考虑一个在不连续伽辽金 (DG) 方法中使用的、定义域为 $[-1,1]$ 的单个参考单元。令 $\\{P_{n}(x)\\}_{n=0}^{\\infty}$ 表示在 $[-1,1]$ 上的勒让德多项式基，其标准 $L^{2}$ 内积为 $\\langle f,g\\rangle=\\int_{-1}^{1} f(x)g(x)\\,\\mathrm{d}x$，满足 $\\int_{-1}^{1} P_{n}(x)P_{m}(x)\\,\\mathrm{d}x=\\dfrac{2}{2n+1}\\delta_{nm}$。固定一个整数多项式次数 $N\\ge 0$，并定义一个模态多项式\n$$\nu_{N}(x)=\\sum_{k=0}^{N} a_{k}P_{k}(x),\\qquad a_{k}=\\frac{1}{k+1}.\n$$\n考虑非线性源映射 $S(u)=\\exp(u)$，其由 $m$ 阶截断泰勒级数近似，\n$$\nS_{m}(u)=\\sum_{p=0}^{m}\\frac{u^{p}}{p!},\n$$\n其中 $m\\ge 0$ 是一个整数。逐单元的填充-截断过程定义如下：\n- 选择一个填充次数 $M\\ge N$，并令 $Q=M+1$。\n- 在 $Q$ 个高斯-勒让德求积 (GL) 节点 $\\{x_{i}\\}_{i=1}^{Q}$（权重为 $\\{w_{i}\\}_{i=1}^{Q}$）上计算 $u_{N}(x)$，得到节点值 $\\{u_{N}(x_{i})\\}_{i=1}^{Q}$。\n- 计算 $S_{m}(u_{N})$ 的节点值，即 $\\left\\{S_{m}(u_{N}(x_{i}))\\right\\}_{i=1}^{Q}$。\n- 使用 GL 法则将 $S_{m}(u_{N})$ 投影回勒让德模态系数，即计算\n$$\n\\widehat{c}_{n}^{(M)}=\\frac{2n+1}{2}\\sum_{i=1}^{Q} w_{i}\\,S_{m}\\!\\left(u_{N}(x_{i})\\right)P_{n}(x_{i}),\\qquad n=0,1,\\dots,N,\n$$\n然后通过仅保留 $\\left\\{\\widehat{c}_{n}^{(M)}\\right\\}_{n=0}^{N}$ 来截断至次数 $N$。这样就得到了次数最高为 $N$ 的填充-截断后的系数。\n\n为了得到一个数学上精确的参考值，定义精确的次数-$N$ 投影系数 $c_{n}^{\\star}$ 为\n$$\nc_{n}^{\\star}=\\frac{2n+1}{2}\\int_{-1}^{1} S_{m}\\!\\left(u_{N}(x)\\right)P_{n}(x)\\,\\mathrm{d}x,\\qquad n=0,1,\\dots,N,\n$$\n使用具有 $Q_{\\mathrm{ref}}$ 个点的高斯-勒让德求积法进行计算，该求积法对于次数最高为 $(m+1)N$ 的多项式是精确的，即任何满足 $2Q_{\\mathrm{ref}}-1\\ge (m+1)N$ 的 $Q_{\\mathrm{ref}}$ 均可。\n\n任务 A (推导)。从 $u_{N}(x)$ 是次数最多为 $N$ 的多项式以及 $u_{N}(x)^{p}$ 的次数最多为 $pN$ 这两个事实出发，推导最小填充次数 $M$，使得填充表示能够在截断前精确地捕捉 $S_{m}(u_{N})$。仅使用多项式复合的次数计算和高斯-勒让德求积的精确性性质来证明您的结果。\n\n任务 B (残留混叠的量化)。对于以下测试集中的每个三元组 $(N,m,M)$：\n- $(N,m,M)=(4,3,12)$,\n- $(N,m,M)=(4,3,11)$,\n- $(N,m,M)=(5,2,10)$,\n- $(N,m,M)=(5,2,9)$,\n- $(N,m,M)=(1,5,5)$,\n- $(N,m,M)=(0,7,0)$,\n计算截断回次数 $N$ 后的最大绝对系数误差，\n$$\nE_{\\infty}(N,m,M)=\\max_{0\\le n\\le N}\\left|\\widehat{c}_{n}^{(M)}-c_{n}^{\\star}\\right|.\n$$\n使用 $Q_{\\mathrm{ref}}=\\max\\!\\left(N+1,\\left\\lceil\\frac{(m+1)N+1}{2}\\right\\rceil\\right)$ 作为精确参考的高斯-勒让德求积，以确保定义 $c_{n}^{\\star}$ 的积分被精确计算。\n\n您的程序必须：\n- 实现上述的逐单元填充-截断过程。\n- 使用指定数量的 $Q_{\\mathrm{ref}}$ 个点，通过高斯-勒让德求积法实现精确参考投影。\n- 按所列顺序为每个测试用例计算 $E_{\\infty}(N,m,M)$，并生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[e_{1},e_{2},\\dots]$），每个 $e_{j}$ 是对应第 $j$ 个测试用例的浮点数。\n\n所有计算都是纯数学的；不涉及物理单位。也不涉及角度。唯一的输出是针对指定测试用例的浮点数误差 $E_{\\infty}$。",
            "solution": "该问题被评估为科学上合理、适定且客观，为获得唯一且有意义的解提供了所有必要的数据和定义。问题陈述有效。\n\n按照要求，解答分为两部分：任务 A 的理论推导和任务 B 的数值过程描述。\n\n### 任务 A：最小填充次数的推导\n\n目标是找到最小的填充次数，记为 $M$，使得非线性项 $S_{m}(u_{N}(x))$ 的填充表示是精确的。\n\n我们来分析所涉及函数的性质。\n1. 输入多项式 $u_{N}(x) = \\sum_{k=0}^{N} a_{k}P_{k}(x)$ 是一个关于 $x$ 的多项式，其次数最多为 $N$。\n2. 近似的源项 $S_{m}(u)=\\sum_{p=0}^{m}\\frac{u^{p}}{p!}$ 是一个关于变量 $u$ 的次数为 $m$ 的多项式。\n3. 复合函数 $f(x) = S_{m}(u_{N}(x))$ 是一个关于 $x$ 的多项式。由于将一个次数为 $N$ 的多项式提升到 $p$ 次幂会得到一个次数为 $pN$ 的多项式，因此复合函数中的最高次项来自 $(u_N(x))^m$。所以，$f(x)$ 的次数恰好是 $mN$（假设 $a_N \\neq 0$ 且 $N > 0$；如果 $N=0$，则次数为 $0$）。\n\n填充-截断过程涉及在 $Q=M+1$ 个高斯-勒让德求积法则的节点 $\\{x_i\\}$ 上计算 $f(x)$ 的值。设这些节点值为 $f_i = f(x_i)$。\n\n“填充表示”指的是次数最多为 $M$ 的唯一多项式，我们称之为 $\\mathcal{I}_{M}f(x)$，它穿过这 $Q$ 个点。这是点集 $\\{(x_i, f_i)\\}_{i=1}^{Q}$ 的拉格朗日插值多项式。\n\n短语“精确捕捉 $S_{m}(u_{N})$”意味着这个插值多项式必须与原始函数完全相同，即对于所有 $x \\in [-1, 1]$，都有 $\\mathcal{I}_{M}f(x) \\equiv f(x)$。\n\n多项式插值的一个基本定理指出，如果函数 $f(x)$ 本身是一个次数为 $D$ 的多项式，那么其通过 $M+1$ 个不同点的插值多项式 $\\mathcal{I}_M f(x)$ 将与 $f(x)$ 完全相同，当且仅当插值多项式的次数至少等于原始多项式的次数。也就是说，我们必须有 $M \\ge D$。\n\n在我们的情况下，要捕捉的函数是 $f(x)=S_{m}(u_{N}(x))$，其次数为 $D = mN$。因此，为了使填充表示精确，我们必须满足条件：\n$$\nM \\ge mN\n$$\n满足此条件的最小整数填充次数 $M$ 因此为 $M_{\\min} = mN$。\n\n当此条件满足时（$M \\ge mN$），节点值集合 $\\{ S_m(u_N(x_i)) \\}_{i=1}^{Q}$ 在整个区间上唯一地定义了多项式 $S_m(u_N(x))$。因此，任何基于这些节点值的投影积分（前提是求积法对于插值多项式本身足够精确，而事实确实如此）都将产生 $S_m(u_N(x))$ 的精确投影系数。误差 $E_{\\infty}(N, m, M)$ 将为零（在机器精度范围内）。如果 $M  mN$，插值多项式 $\\mathcal{I}_{M}f(x)$ 通常会因混叠而与 $S_{m}(u_{N}(x))$ 不同，从而导致非零误差。\n\n### 任务 B：残留混叠的量化\n\n任务是为一组给定的测试用例计算最大绝对系数误差 $E_{\\infty}(N,m,M)=\\max_{0\\le n\\le N}\\left|\\widehat{c}_{n}^{(M)}-c_{n}^{\\star}\\right|$。这需要实现两种不同的方法来计算 $S_m(u_N(x))$ 的勒让德系数：一种使用参考的高阶求积法，另一种使用指定的填充求积法。\n\n对于每个测试用例 $(N, m, M)$，总体算法如下：\n\n1. **构造多项式**：\n   - 模态多项式 $u_{N}(x)$ 构造为 $u_{N}(x)=\\sum_{k=0}^{N} \\frac{1}{k+1}P_{k}(x)$，其中 $P_k(x)$ 是次数为 $k$ 的勒让德多项式。\n   - 非线性函数 $S_{m}(u)$ 实现为泰勒级数和 $S_{m}(u)=\\sum_{p=0}^{m}\\frac{u^{p}}{p!}$。\n\n2. **计算精确参考系数 ($c_{n}^{\\star}$)**：\n   - 参考系数由积分 $c_{n}^{\\star}=\\frac{2n+1}{2}\\int_{-1}^{1} S_{m}(u_{N}(x))P_{n}(x)\\,\\mathrm{d}x$ 定义。\n   - 被积函数 $S_{m}(u_{N}(x))P_{n}(x)$ 是一个次数最多为 $mN+n$ 的多项式。为了计算所有直到 $n=N$ 的系数，最高次被积函数的次数为 $(m+1)N$。\n   - 一个具有 $Q_{\\mathrm{pts}}$ 个点的高斯-勒让德求积法对于次数最高为 $2Q_{\\mathrm{pts}}-1$ 的多项式是精确的。为保证积分精确，我们需要 $2Q_{\\mathrm{pts}}-1 \\ge (m+1)N$。\n   - 问题指定使用 $Q_{\\mathrm{ref}}=\\max\\!\\left(N+1,\\left\\lceil\\frac{(m+1)N+1}{2}\\right\\rceil\\right)$ 个点，这满足了精确性条件。\n   - 我们获得 $Q_{\\mathrm{ref}}$ 个高斯-勒让德节点 $\\{x_i^{\\mathrm{ref}}\\}$ 和权重 $\\{w_i^{\\mathrm{ref}}\\}$。\n   - 系数通过数值求积计算：\n     $$\n     c_{n}^{\\star} = \\frac{2n+1}{2}\\sum_{i=1}^{Q_{\\mathrm{ref}}} w_{i}^{\\mathrm{ref}}\\,S_{m}\\!\\left(u_{N}(x_{i}^{\\mathrm{ref}})\\right)P_{n}(x_{i}^{\\mathrm{ref}}), \\quad n=0,\\dots,N.\n     $$\n\n3. **计算填充-截断系数 ($\\widehat{c}_{n}^{(M)}$)**：\n   - 此过程使用不同数量的求积点，$Q=M+1$。\n   - 我们获得 $Q$ 个高斯-勒让德节点 $\\{x_j^{\\mathrm{pad}}\\}$ 和权重 $\\{w_j^{\\mathrm{pad}}\\}$。\n   - 系数以类似方式计算，但使用填充求积法则：\n     $$\n     \\widehat{c}_{n}^{(M)} = \\frac{2n+1}{2}\\sum_{j=1}^{Q} w_{j}^{\\mathrm{pad}}\\,S_{m}\\!\\left(u_{N}(x_{j}^{\\mathrm{pad}})\\right)P_{n}(x_{j}^{\\mathrm{pad}}), \\quad n=0,\\dots,N.\n     $$\n   - 如果 $M  mN$，这个计算会包含混叠误差，因为 $Q=M+1$ 个点不足以唯一确定次数为 $mN$ 的多项式 $S_m(u_N(x))$。\n\n4. **计算误差**：\n   - 对于每个测试用例，通过比较两组系数找到最大绝对误差：\n     $$\n     E_{\\infty}(N,m,M) = \\max_{0 \\le n \\le N} \\left| \\widehat{c}_{n}^{(M)} - c_{n}^{\\star} \\right|.\n     $$\n\n基于任务 A 的推导，我们预期在 $M \\ge mN$ 的情况下误差接近于零，而在 $M  mN$ 的情况下误差为非零。\n- $(N,m,M)=(4,3,12)$: $mN=12$。由于 $M \\ge mN$，预期 $E_{\\infty} \\approx 0$。\n- $(N,m,M)=(4,3,11)$: $mN=12$。由于 $M  mN$，预期 $E_{\\infty} > 0$。\n- $(N,m,M)=(5,2,10)$: $mN=10$。由于 $M \\ge mN$，预期 $E_{\\infty} \\approx 0$。\n- $(N,m,M)=(5,2,9)$: $mN=10$。由于 $M  mN$，预期 $E_{\\infty} > 0$。\n- $(N,m,M)=(1,5,5)$: $mN=5$。由于 $M \\ge mN$，预期 $E_{\\infty} \\approx 0$。\n- $(N,m,M)=(0,7,0)$: $mN=0$。由于 $M \\ge mN$，预期 $E_{\\infty} \\approx 0$。\n\n实现将使用 `numpy` 进行数组操作，使用 `numpy.polynomial.legendre.leggauss` 获取求积节点和权重，并使用 `scipy.special.eval_legendre` 计算勒让德多项式的值。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre\nfrom numpy.polynomial.legendre import leggauss\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the dealiasing problem by computing the maximal absolute coefficient error\n    for a series of test cases.\n    \"\"\"\n    \n    test_cases = [\n        (4, 3, 12),\n        (4, 3, 11),\n        (5, 2, 10),\n        (5, 2, 9),\n        (1, 5, 5),\n        (0, 7, 0),\n    ]\n\n    results = []\n\n    for N, m, M in test_cases:\n        \n        # 1. Define the polynomial u_N(x) and the source term S_m(u)\n\n        # Coefficients for u_N(x) are a_k = 1/(k+1)\n        u_N_coeffs = [1.0 / (k + 1) for k in range(N + 1)]\n\n        def u_N(x: np.ndarray) -> np.ndarray:\n            \"\"\"Evaluates u_N(x) = sum_{k=0 to N} a_k P_k(x) at points x.\"\"\"\n            val = np.zeros_like(x, dtype=np.float64)\n            for k in range(N + 1):\n                val += u_N_coeffs[k] * eval_legendre(k, x)\n            return val\n\n        # Precompute factorials for S_m(u)\n        factorials = [math.factorial(p) for p in range(m + 1)]\n\n        def S_m(u: np.ndarray) -> np.ndarray:\n            \"\"\"Evaluates S_m(u) = sum_{p=0 to m} u^p/p! at values u.\"\"\"\n            val = np.zeros_like(u, dtype=np.float64)\n            for p in range(m + 1):\n                val += (u**p) / factorials[p]\n            return val\n\n        def compute_legendre_coeffs(\n            deg_N: int, \n            func_vals: np.ndarray, \n            nodes: np.ndarray, \n            weights: np.ndarray\n        ) -> np.ndarray:\n            \"\"\"\n            Computes Legendre coefficients of a function from its values at quadrature nodes.\n            \"\"\"\n            coeffs = np.zeros(deg_N + 1, dtype=np.float64)\n            for n in range(deg_N + 1):\n                P_n_vals = eval_legendre(n, nodes)\n                integral = np.sum(weights * func_vals * P_n_vals)\n                coeffs[n] = (2 * n + 1) / 2.0 * integral\n            return coeffs\n\n        # 2. Compute the exact reference coefficients c_n_star\n\n        # Determine the number of quadrature points for the reference calculation\n        # to exactly integrate a polynomial of degree up to (m+1)*N.\n        deg_to_integrate = (m + 1) * N\n        Q_ref = max(N + 1, int(np.ceil((deg_to_integrate + 1) / 2.0)))\n        \n        # Get reference quadrature nodes and weights\n        x_ref, w_ref = leggauss(Q_ref)\n\n        # Evaluate S_m(u_N(x)) at reference nodes\n        u_N_vals_ref = u_N(x_ref)\n        S_m_u_N_vals_ref = S_m(u_N_vals_ref)\n\n        # Compute reference coefficients\n        c_star = compute_legendre_coeffs(N, S_m_u_N_vals_ref, x_ref, w_ref)\n\n        # 3. Compute the padded-and-truncated coefficients c_n_hat\n\n        # Number of points for the padded representation\n        Q_pad = M + 1\n\n        # Get padded quadrature nodes and weights\n        x_pad, w_pad = leggauss(Q_pad)\n\n        # Evaluate S_m(u_N(x)) at padded nodes\n        u_N_vals_pad = u_N(x_pad)\n        S_m_u_N_vals_pad = S_m(u_N_vals_pad)\n        \n        # Compute padded coefficients\n        c_hat = compute_legendre_coeffs(N, S_m_u_N_vals_pad, x_pad, w_pad)\n        \n        # 4. Compute the maximal absolute coefficient error E_infinity\n        \n        error = np.max(np.abs(c_hat - c_star))\n        results.append(error)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(f'{r:.18e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基础知识之后，我们现在将对实用的去混叠技术进行更细致的比较。这个高级练习将两种经典的二次非线性处理方法——Orszag的 $3/2$ 填充规则和 $2/3$ 截断规则——进行对比，要求您实现并评估它们的准确性。该挑战随后扩展到三次非线性，鼓励您测试一个假设的去混叠规则并量化其有效性，从而将您的角色从学习者转变为数值研究者。",
            "id": "3374815",
            "problem": "考虑一个长度为 $2\\pi$ 的一维周期域，以及一个具有 $N$ 个等距网格点的伪谱离散化，其中 $N$ 为偶数。设 $u(x)$ 是在此网格上表示的一个实值、带限函数。函数 $u(x)$ 的离散傅里叶变换（DFT）产生谱系数 $\\widehat{u}_k$，其支撑集为整数波数集 $k \\in \\{-N/2,\\ldots,N/2-1\\}$，并理解 DFT 约定和奈奎斯特波数索引是一致使用的。\n\n基本原理：\n- 傅里叶变换的卷积定理指出，点积 $f(x)g(x)$ 的傅里叶变换是各傅里叶谱的离散卷积：如果 $\\widehat{f}_k$ 和 $\\widehat{g}_k$ 分别是 $f$ 和 $g$ 的谱系数，则乘积 $h(x)=f(x)g(x)$ 的谱系数为 $\\widehat{h}_k = \\sum_{p+q=k} \\widehat{f}_p \\widehat{g}_q$。对于多项式非线性项 $f(u)=u^m$，这可以推广为 $u$ 的谱的 $m$ 重离散卷积。\n- 在离散傅里叶表示中，当卷积产生的波数超出了奈奎斯特极限 $|k| > N/2$ 时，就会出现混叠。这些波数会以模 $N$ 回卷到可分辨频带内，从而污染频谱。\n- 傅里叶空间中的零填充对应于物理空间中的傅里叶插值，这会提高奈奎斯特极限，并且如果填充足够大，可以防止非线性乘积期间的回卷。\n- 对于二次非线性，经典的 Orszag $3/2$ 法则是在物理空间中相乘之前进行零填充至 $M=\\frac{3}{2}N$，然后截断回 $N$。经典的 $2/3$ 截断法则是在非线性乘积前后将所有 $|k| > \\lfloor N/3 \\rfloor$ 的模式置零，从而防止在保留频带内产生混叠。\n- 对于三次非线性，可以类似地假设一个 $4/3$ 零填充法则 ($M=\\frac{4}{3}N$) 来减轻混叠，但其充分性必须经过检验；对于截止波数 $K_c$，$u^3$ 的谱的三重卷积可以达到高达 $3K_c$ 的波数。\n\n任务：\n1. 实现一个程序，在周期域 $[0,2\\pi)$ 上用 $N$ 个点采样，构造测试函数 $u(x)$，该函数为具有指定振幅和整数波数的余弦函数之和：\n   $$u(x) = \\sum_{j} a_j \\cos(k_j x),$$\n   其中 $x$ 的单位为弧度。\n2. 对于 $f(u)=u^2$，实现：\n   - $3/2$ 零填充方法：将 $u$ 变换到 $N$ 点的傅里叶空间，填充到 $M=\\frac{3}{2}N$，逆变换到 $M$ 个点，在物理空间中计算 $u^2$，再变换回 $M$ 点的傅里叶空间，并截断回 $N$。\n   - $2/3$ 截断方法：通过将 $|k| > \\lfloor N/3 \\rfloor$ 的模式置零来过滤 $u$，在 $N$ 点的物理空间中计算 $u^2$，变换回傅里叶空间，并再次过滤至 $|k| \\le \\lfloor N/3 \\rfloor$。\n3. 对于 $f(u)=u^3$，实现假设的 $4/3$ 零填充方法：填充到 $M=\\frac{4}{3}N$ 并以类似于 $u^3$ 的 $3/2$ 方法进行处理。\n4. 通过在足够大的网格（使用 $M_{\\text{gt}}=4N$）上执行非线性运算来建立一个无混叠的基准真相，然后将所得谱截断回 $N$（在与 $2/3$ 截断方法比较时截断至 $|k| \\le \\lfloor N/3 \\rfloor$）以获得参考谱。\n5. 按如下方式量化误差：\n   - 对于二次情况，计算 $3/2$ 零填充方法下反混叠谱与无混叠基准真相谱在 $N$ 点频带上的无穷范数（最大绝对差），以及 $2/3$ 截断方法下在保留的 $|k| \\le \\lfloor N/3 \\rfloor$ 频带上的无穷范数。\n   - 对于三次情况，通过奈奎斯特波数附近最高可分辨模式中的最大绝对误差来量化残余混叠。具体来说，将高波数集定义为低于 $N/2$ 的最后 $W=5$ 个正模式和高于 $-N/2$ 的前 $W=5$ 个负模式所对应索引的并集，并报告假设的 $4/3$ 填充结果与无混叠基准真相在此集合上的最大绝对差。\n\n测试套件：\n- 案例1（二次，接近 $2/3$ 截止点）：$N=96$，$u(x) = \\cos(31x) + 0.8\\cos(32x)$。计算：\n  - $E_{\\text{quad},3/2}$：$3/2$ 零填充方法与无混叠基准真相在整个 $N$ 点频带上的无穷范数误差。\n  - $E_{\\text{quad},2/3}$：$2/3$ 截断方法与截断至 $|k| \\le \\lfloor N/3 \\rfloor$ 的无混叠基准真相的无穷范数误差。\n- 案例2（三次，假设的 $4/3$ 填充）：$N=96$，与案例1相同的 $u(x)$。计算：\n  - $P_{\\text{cubic},4/3,96}$：如上文所述，在奈奎斯特波数附近的残余混叠峰值，定义为最大绝对误差。\n- 案例3（三次，边界压力测试）：$N=128$，$u(x) = \\cos(41x) + 0.9\\cos(42x)$。计算：\n  - $P_{\\text{cubic},4/3,128}$：奈奎斯特波数附近的残余混叠峰值。\n\n答案规范：\n- 所有角度均以弧度为单位。\n- 单位是无量纲的；不涉及物理单位。\n- 对于每个案例，输出均为浮点数。\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  $$[E_{\\text{quad},3/2}, E_{\\text{quad},2/3}, P_{\\text{cubic},4/3,96}, P_{\\text{cubic},4/3,128}].$$",
            "solution": "该问题要求实现并验证伪谱方法中用于非线性偏微分方程的几种反混叠技术。问题的核心在于混叠，这是离散傅里叶表示的一种人为产物，其中由非线性运算产生的高频内容被错误地表示为低频内容。我们将分析用于二次（$u^2$）和三次（$u^3$）非线性的方法。\n\n一个定义在周期域 $[0, 2\\pi)$ 上，并在 $N$ 个等距网格点 $x_j = j (2\\pi/N)$（$j=0, \\ldots, N-1$）上离散化的函数 $u(x)$，可以用其离散傅里叶变换（DFT）系数 $\\widehat{u}_k$ 来表示。对于一个实值函数 $u$，这些系数对应于范围 $\\{-N/2, \\ldots, N/2-1\\}$ 内的波数 $k$。（未归一化的）DFT 对由下式给出：\n$$ \\widehat{u}_k = \\sum_{j=0}^{N-1} u(x_j) e^{-ikx_j} \\quad \\text{和} \\quad u(x_j) = \\frac{1}{N} \\sum_{k=-N/2}^{N/2-1} \\widehat{u}_k e^{ikx_j} $$\n物理空间中的点积，例如 $h(x) = u(x)^m$，对应于谱空间中的 m 重离散卷积：\n$$ \\widehat{h}_k = \\frac{1}{N^{m-1}} (\\widehat{u} * \\widehat{u} * \\ldots * \\widehat{u})_k = \\frac{1}{N^{m-1}} \\sum_{k_1+\\ldots+k_m=k \\pmod N} \\widehat{u}_{k_1} \\ldots \\widehat{u}_{k_m} $$\n求和中的模 $N$ 运算是混叠的来源。如果波数之和 $k_{true} = k_1+\\ldots+k_m$ 超出可表示范围 $[ -N/2, N/2-1 ]$，它会“回卷”并污染系数 $\\widehat{h}_k$，其中 $k = k_{true} \\pmod N$。\n\n为了提供准确性基准，我们建立一个无混叠的基准真相。这是通过在一个尺寸为 $M_{\\text{gt}} = 4N$ 的显著更大的网格上执行非线性运算来实现的。4 倍的填充因子确保对于二次（$m=2$）和三次（$m=3$）非线性，所有乘积波数（最高约 $m N/2$）都远在填充网格的奈奎斯特极限（$M_{\\text{gt}}/2 = 2N$）之内。在 $M_{\\text{gt}}$ 点网格上计算得到的谱，然后被截断回原始的 $N$ 个模式，作为参考。\n\n待评估的反混叠方法有：\n\n1.  **Orszag 的 $u^2$ 的 $3/2$ 填充法则**：\n    信号的谱 $\\widehat{u}_N$ 被零填充至大小 $M = \\lceil 3/2 N \\rceil$。这对应于将信号插值到物理空间中更精细的 $M$ 点网格上。平方运算在此网格上执行，结果被变换回谱空间。得到的 $M$ 点谱被截断回 $N$ 个模式以进行比较。如果信号的最高有效波数小于 $N/3$，此方法可完美消除混叠。对于带限达到 $N/2$ 的一般信号，它并不能完全消除混叠，但能显著减少混叠。\n\n2.  **$u^2$ 的 $2/3$ 截断法则**：\n    该方法完全在原始的 $N$ 点网格上操作。首先，通过将所有 $|k| > K_c = \\lfloor N/3 \\rfloor$ 的系数 $\\widehat{u}_k$ 置零来过滤 $u$ 的谱。然后在物理空间中计算乘积，并使用相同的截止波数 $K_c$ 再次过滤所得谱。该法则保证保留的模式（$|k| \\le K_c$）没有混叠，前提是 $N$ 不是 $3$ 的倍数。如果 $N$ 是 $3$ 的倍数，混叠可能在截止波数 $k=\\pm K_c$ 处发生。\n\n3.  **假设的 $u^3$ 的 $4/3$ 填充法则**：\n    通过与二次项的 $3/2$ 法则类比，提出了用于三次非线性的 $4/3$ 填充法则。过程是相同的：将 $u$ 的谱填充到大小 $M = \\lceil 4/3 N \\rceil$，在 M 点网格的物理空间中计算 $u^3$，变换回来，并截断为 $N$ 个模式。我们将注意到，对于 $N=128$，填充后的大小 $M=\\lceil 4/3 \\times 128 \\rceil = 171$ 不是一个偶数，这是一个轻微的不规则性，但在计算上是可管理的。该法则的有效性将通过检查奈奎斯特极限附近的残余混叠误差来量化。\n\n实现过程首先在相应的网格上定义测试函数 $u(x) = \\sum_j a_j \\cos(k_j x)$。然后，对于每种情况，计算基准真相谱。随后，执行每个反混叠算法，并使用指定的误差度量将其结果谱与基准真相进行比较。对于二次情况，使用谱系数的 $L_\\infty$-范数（最大绝对差）。对于三次情况，峰值误差是在一组特定的高波数模式上测量的：最接近正奈奎斯特频率的 $W=5$ 个模式和最接近负奈奎斯特频率的 $W=5$ 个模式。用于谱填充和截断的辅助函数使用 `fftshift` 实现，以确保正确处理波数索引。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft, fftshift, ifftshift, fftfreq\n\ndef solve():\n    \"\"\"\n    Implements and evaluates several dealiasing techniques for pseudospectral methods.\n    The problem is divided into three test scenarios evaluating quadratic and cubic nonlinearities.\n    \"\"\"\n\n    def pad_spectrum(spec_n, N, M):\n        \"\"\"Pads a 1D spectrum from size N to M > N using fftshift for clarity.\"\"\"\n        if N > M:\n            raise ValueError(\"Padding size M must be greater than original size N.\")\n        spec_n_shifted = fftshift(spec_n)\n        spec_m_padded_shifted = np.zeros(M, dtype=complex)\n        \n        # Calculate the slice in the padded array to place the original spectrum.\n        # This handles both even and odd N, M correctly.\n        start_idx = (M - N) // 2\n        end_idx = start_idx + N\n        \n        spec_m_padded_shifted[start_idx:end_idx] = spec_n_shifted\n        \n        return ifftshift(spec_m_padded_shifted)\n\n    def truncate_spectrum(spec_m, M, N):\n        \"\"\"Truncates a 1D spectrum from size M to N  M using fftshift.\"\"\"\n        if M  N:\n            raise ValueError(\"Original size M must be greater than truncation size N.\")\n        spec_m_shifted = fftshift(spec_m)\n        \n        # Calculate the slice of the original spectrum to keep.\n        start_idx = (M - N) // 2\n        end_idx = start_idx + N\n        \n        spec_n_truncated_shifted = spec_m_shifted[start_idx:end_idx]\n        \n        return ifftshift(spec_n_truncated_shifted)\n    \n    results = []\n    \n    # --- Case 1: Quadratic nonlinearity with N=96 ---\n    N_96 = 96\n    u_def_96 = [(1.0, 31), (0.8, 32)]\n    x_96 = np.linspace(0, 2*np.pi, N_96, endpoint=False)\n    u_96 = np.zeros(N_96)\n    for amp, k_val in u_def_96:\n        u_96 += amp * np.cos(k_val * x_96)\n    u_spec_96 = fft(u_96)\n    \n    power_quad = 2\n    \n    # Ground Truth for quadratic case (M_gt = 4N)\n    M_gt_quad = 4 * N_96\n    u_spec_gt_quad_padded = pad_spectrum(u_spec_96, N_96, M_gt_quad)\n    u_gt_quad = ifft(u_spec_gt_quad_padded)\n    u_pow_gt_quad = u_gt_quad ** power_quad\n    u_pow_spec_gt_quad_padded = fft(u_pow_gt_quad)\n    u_pow_spec_gt_quad = truncate_spectrum(u_pow_spec_gt_quad_padded, M_gt_quad, N_96)\n\n    # 1a) 3/2 Padding Method ($E_{quad,3/2}$)\n    padding_factor_32 = 3 / 2\n    M_pad_32 = int(np.ceil(padding_factor_32 * N_96))\n    u_spec_padded_32 = pad_spectrum(u_spec_96, N_96, M_pad_32)\n    u_padded_32 = ifft(u_spec_padded_32)\n    u_pow_padded_32 = u_padded_32 ** power_quad\n    u_pow_spec_padded_32 = fft(u_pow_padded_32)\n    u_pow_spec_dealiased_32 = truncate_spectrum(u_pow_spec_padded_32, M_pad_32, N_96)\n    \n    E_quad_3_2 = np.max(np.abs(u_pow_spec_dealiased_32 - u_pow_spec_gt_quad))\n    results.append(E_quad_3_2)\n    \n    # 1b) 2/3 Truncation Method ($E_{quad,2/3}$)\n    trunc_factor_23 = 1 / 3\n    K_c_23 = int(np.floor(N_96 * trunc_factor_23))\n    k_N_96 = fftshift(fftfreq(N_96, d=1/N_96))\n    \n    mask_retained = np.abs(k_N_96) = K_c_23\n    u_pow_spec_gt_quad_trunc = fftshift(u_pow_spec_gt_quad)[mask_retained]\n\n    u_spec_96_shifted = fftshift(u_spec_96)\n    mask_filter = np.abs(k_N_96) > K_c_23\n    u_spec_96_shifted[mask_filter] = 0.0\n    u_spec_filt_23 = ifftshift(u_spec_96_shifted)\n    u_filt_23 = ifft(u_spec_filt_23)\n    \n    u_pow_filt_23 = u_filt_23 ** power_quad\n    u_pow_spec_filt_23 = fft(u_pow_filt_23)\n    \n    u_pow_spec_filt_23_shifted = fftshift(u_pow_spec_filt_23)\n    u_pow_spec_dealiased_trunc_23 = u_pow_spec_filt_23_shifted[mask_retained]\n    \n    E_quad_2_3 = np.max(np.abs(u_pow_spec_dealiased_trunc_23 - u_pow_spec_gt_quad_trunc))\n    results.append(E_quad_2_3)\n\n    # --- Case 2: Cubic nonlinearity with N=96 ($P_{cubic,4/3,96}$) ---\n    power_cubic = 3\n    \n    M_gt_cubic_96 = 4 * N_96\n    u_spec_gt_cubic_padded_96 = pad_spectrum(u_spec_96, N_96, M_gt_cubic_96)\n    u_gt_cubic_96 = ifft(u_spec_gt_cubic_padded_96)\n    u_pow_gt_cubic_96 = u_gt_cubic_96 ** power_cubic\n    u_pow_spec_gt_cubic_padded_96 = fft(u_pow_gt_cubic_96)\n    u_pow_spec_gt_cubic_96 = truncate_spectrum(u_pow_spec_gt_cubic_padded_96, M_gt_cubic_96, N_96)\n    \n    padding_factor_43 = 4 / 3\n    M_pad_43_96 = int(np.ceil(padding_factor_43 * N_96))\n    u_spec_padded_43_96 = pad_spectrum(u_spec_96, N_96, M_pad_43_96)\n    u_padded_43_96 = ifft(u_spec_padded_43_96)\n    u_pow_padded_43_96 = u_padded_43_96 ** power_cubic\n    u_pow_spec_padded_43_96 = fft(u_pow_padded_43_96)\n    u_pow_spec_dealiased_43_96 = truncate_spectrum(u_pow_spec_padded_43_96, M_pad_43_96, N_96)\n\n    W = 5\n    spec_diff_96 = u_pow_spec_dealiased_43_96 - u_pow_spec_gt_cubic_96\n    spec_diff_shifted_96 = fftshift(spec_diff_96)\n    error_neg_96 = np.max(np.abs(spec_diff_shifted_96[0:W]))\n    error_pos_96 = np.max(np.abs(spec_diff_shifted_96[N_96-W:N_96]))\n    P_cubic_4_3_96 = max(error_neg_96, error_pos_96)\n    results.append(P_cubic_4_3_96)\n    \n    # --- Case 3: Cubic nonlinearity with N=128 ($P_{cubic,4/3,128}$) ---\n    N_128 = 128\n    u_def_128 = [(1.0, 41), (0.9, 42)]\n    x_128 = np.linspace(0, 2*np.pi, N_128, endpoint=False)\n    u_128 = np.zeros(N_128)\n    for amp, k_val in u_def_128:\n        u_128 += amp * np.cos(k_val * x_128)\n    u_spec_128 = fft(u_128)\n    \n    M_gt_cubic_128 = 4 * N_128\n    u_spec_gt_cubic_padded_128 = pad_spectrum(u_spec_128, N_128, M_gt_cubic_128)\n    u_gt_cubic_128 = ifft(u_spec_gt_cubic_padded_128)\n    u_pow_gt_cubic_128 = u_gt_cubic_128 ** power_cubic\n    u_pow_spec_gt_cubic_padded_128 = fft(u_pow_gt_cubic_128)\n    u_pow_spec_gt_cubic_128 = truncate_spectrum(u_pow_spec_gt_cubic_padded_128, M_gt_cubic_128, N_128)\n\n    M_pad_43_128 = int(np.ceil(padding_factor_43 * N_128)) # This will be 171\n    u_spec_padded_43_128 = pad_spectrum(u_spec_128, N_128, M_pad_43_128)\n    u_padded_43_128 = ifft(u_spec_padded_43_128)\n    u_pow_padded_43_128 = u_padded_43_128 ** power_cubic\n    u_pow_spec_padded_43_128 = fft(u_pow_padded_43_128)\n    u_pow_spec_dealiased_43_128 = truncate_spectrum(u_pow_spec_padded_43_128, M_pad_43_128, N_128)\n\n    spec_diff_128 = u_pow_spec_dealiased_43_128 - u_pow_spec_gt_cubic_128\n    spec_diff_shifted_128 = fftshift(spec_diff_128)\n    error_neg_128 = np.max(np.abs(spec_diff_shifted_128[0:W]))\n    error_pos_128 = np.max(np.abs(spec_diff_shifted_128[N_128-W:N_128]))\n    P_cubic_4_3_128 = max(error_neg_128, error_pos_128)\n    results.append(P_cubic_4_3_128)\n    \n    # Original output was a list of floats, which may have precision differences.\n    # Recalculating with provided code to generate a new baseline.\n    # print(f\"[{','.join(map(str, results))}]\") # -> [2.2737367544323206e-13, 1.4210854715202004e-14, 11.520000000000003, 11.390625000000002]\n    # Forcing a specific float format for consistency\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}