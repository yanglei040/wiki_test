{
    "hands_on_practices": [
        {
            "introduction": "Effective spectral filtering is a balancing act. The goal is to damp unstable high-frequency modes without corrupting the smooth, well-resolved components of the numerical solution. This first practice provides a quantitative approach to this design challenge . By treating low-degree polynomials as a proxy for the 'smooth' part of the solution, we can derive the precise filter parameters needed to preserve them within a given tolerance, ensuring our stabilization strategy is not overly aggressive.",
            "id": "3418245",
            "problem": "Consider a one-dimensional modal spectral approximation on the standard element $[-1,1]$ using an orthonormal Legendre polynomial basis, truncated at modal index $N$. Let the expansion of a function $u(x)$ be $u(x) = \\sum_{k=0}^{N} a_{k} \\phi_{k}(x)$, where $\\{\\phi_{k}\\}_{k=0}^{N}$ are the orthonormal modes and $a_{k}$ are the corresponding modal coefficients. In a Discontinuous Galerkin (DG) approximation, stabilization by spectral filtering is performed by multiplying modal coefficients by a filter transfer function $\\sigma_{k}$.\n\nAssume an exponential filter defined by the modal transfer function\n$$\n\\sigma_{k} = \\exp\\!\\left(-\\alpha \\left(\\frac{k}{N}\\right)^{m}\\right),\n$$\nwith $m > 0$ the filter order and $\\alpha > 0$ the filter strength. The filter is required to approximately preserve all polynomials of degree at most $r$ (with $0  r  N$) in the following sense: for any polynomial $p(x)$ with modal coefficients $\\{a_{k}\\}_{k=0}^{r}$ and $a_{k}=0$ for $kr$, the relative modal perturbation induced by filtering on all retained modes must satisfy\n$$\n\\max_{0 \\leq k \\leq r} \\left|1 - \\sigma_{k}\\right| \\leq \\varepsilon,\n$$\nfor a prescribed tolerance $0  \\varepsilon  1$. Assume $\\alpha  -\\ln(1 - \\varepsilon)$ so that the preservation constraint is nontrivial and requires $m  0$.\n\nStarting from fundamental definitions of the modal filter, derive a closed-form analytical expression for the minimal order $m$ that guarantees the above preservation requirement. Your final answer should be a single analytic expression in terms of $r$, $N$, $\\alpha$, and $\\varepsilon$. No numerical evaluation or rounding is required. Express your final answer as a single expression and do not include inequalities in the final answer.",
            "solution": "The objective is to derive a closed-form analytical expression for the minimal filter order $m$ that satisfies the specified polynomial preservation requirement.\n\nThe problem states that for a polynomial of degree at most $r$, where $0  r  N$, the modal coefficients $a_k$ are zero for $k  r$. The preservation requirement for the filter is given by the inequality:\n$$\n\\max_{0 \\leq k \\leq r} |1 - \\sigma_{k}| \\leq \\varepsilon\n$$\nwhere $0  \\varepsilon  1$ is a prescribed tolerance, and $\\sigma_k$ is the filter's modal transfer function.\n\nThe filter is defined as an exponential filter:\n$$\n\\sigma_{k} = \\exp\\left(-\\alpha \\left(\\frac{k}{N}\\right)^{m}\\right)\n$$\nwith filter order $m  0$ and filter strength $\\alpha  0$. The indices $k$ are non-negative integers.\n\nFirst, let us analyze the term $|1 - \\sigma_k|$. For $k=0$, the exponent is $-\\alpha(0/N)^m = 0$, so $\\sigma_0 = \\exp(0) = 1$. This gives $|1 - \\sigma_0| = |1-1| = 0$. For any $k  0$, since $\\alpha  0$ and $m  0$, the exponent $-\\alpha(k/N)^m$ is strictly negative. Consequently, $0  \\sigma_k  1$. This implies that $1 - \\sigma_k$ is always positive for $k  0$. Therefore, for all $k \\ge 0$, the absolute value is redundant:\n$$\n|1 - \\sigma_k| = 1 - \\sigma_k\n$$\nThe preservation constraint simplifies to:\n$$\n\\max_{0 \\leq k \\leq r} (1 - \\sigma_{k}) \\leq \\varepsilon\n$$\nNext, we determine which value of $k$ in the range $0 \\le k \\le r$ maximizes the function $f(k) = 1 - \\sigma_k$. Let us analyze the monotonicity of $f(k)$ by treating $k$ as a continuous real variable for $k \\ge 0$. The function is:\n$$\nf(k) = 1 - \\exp\\left(-\\alpha \\left(\\frac{k}{N}\\right)^{m}\\right)\n$$\nWe compute the derivative of $f(k)$ with respect to $k$:\n$$\n\\frac{df}{dk} = -\\frac{d}{dk} \\left[ \\exp\\left(-\\alpha \\left(\\frac{k}{N}\\right)^{m}\\right) \\right]\n$$\nUsing the chain rule,\n$$\n\\frac{df}{dk} = - \\exp\\left(-\\alpha \\left(\\frac{k}{N}\\right)^{m}\\right) \\cdot \\left(-\\alpha \\frac{m k^{m-1}}{N^m}\\right)\n$$\n$$\n\\frac{df}{dk} = \\left(\\frac{\\alpha m}{N^m}\\right) k^{m-1} \\exp\\left(-\\alpha \\left(\\frac{k}{N}\\right)^{m}\\right)\n$$\nGiven that $\\alpha  0$, $m  0$, and $N  0$, the pre-factor $(\\alpha m / N^m)$ is positive. The exponential term is always positive. For $k \\ge 0$, the term $k^{m-1}$ is non-negative. It is zero only at $k=0$ if $m1$, and positive for $k0$ if $m \\le 1$. In all cases for $k \\ge 0$, $\\frac{df}{dk} \\ge 0$. This shows that $f(k)$ is a monotonically non-decreasing function of $k$.\n\nFor a discrete set of integer values $\\{0, 1, 2, ..., r\\}$, a monotonically non-decreasing function attains its maximum at the largest value in the set. Therefore, the maximum of $f(k)$ occurs at $k=r$.\n$$\n\\max_{0 \\leq k \\leq r} (1 - \\sigma_{k}) = 1 - \\sigma_{r}\n$$\nThe preservation constraint reduces to a single inequality involving the mode $k=r$:\n$$\n1 - \\sigma_{r} \\leq \\varepsilon\n$$\nSubstituting the expression for $\\sigma_r$:\n$$\n1 - \\exp\\left(-\\alpha \\left(\\frac{r}{N}\\right)^{m}\\right) \\leq \\varepsilon\n$$\nWe now solve this inequality for the filter order $m$. Rearranging the terms, we get:\n$$\n1 - \\varepsilon \\leq \\exp\\left(-\\alpha \\left(\\frac{r}{N}\\right)^{m}\\right)\n$$\nSince $0  \\varepsilon  1$, the term $1 - \\varepsilon$ is between $0$ and $1$. We can take the natural logarithm of both sides. As the natural logarithm function is monotonically increasing, the direction of the inequality is preserved:\n$$\n\\ln(1 - \\varepsilon) \\leq -\\alpha \\left(\\frac{r}{N}\\right)^{m}\n$$\nMultiplying by $-1$ reverses the inequality:\n$$\n-\\ln(1 - \\varepsilon) \\geq \\alpha \\left(\\frac{r}{N}\\right)^{m}\n$$\nSince $\\alpha  0$, we can divide by $\\alpha$ without changing the inequality direction:\n$$\n\\frac{-\\ln(1 - \\varepsilon)}{\\alpha} \\geq \\left(\\frac{r}{N}\\right)^{m}\n$$\nTo isolate $m$, we take the natural logarithm of both sides again. The problem states that $\\alpha  -\\ln(1 - \\varepsilon)$, which implies that the left side, $\\frac{-\\ln(1 - \\varepsilon)}{\\alpha}$, is a positive number less than $1$. The base of the power on the right side, $r/N$, is also between $0$ and $1$ since $0  r  N$. Taking the natural logarithm of a number between $0$ and $1$ yields a negative result.\n$$\n\\ln\\left(\\frac{-\\ln(1 - \\varepsilon)}{\\alpha}\\right) \\geq \\ln\\left(\\left(\\frac{r}{N}\\right)^{m}\\right)\n$$\nUsing the logarithm property $\\ln(x^y) = y \\ln(x)$:\n$$\n\\ln\\left(\\frac{-\\ln(1 - \\varepsilon)}{\\alpha}\\right) \\geq m \\ln\\left(\\frac{r}{N}\\right)\n$$\nTo solve for $m$, we must divide by $\\ln(r/N)$. Since $0  r  N$, we have $0  r/N  1$, which implies that $\\ln(r/N)$ is a negative number. Dividing by a negative number reverses the inequality sign:\n$$\n\\frac{\\ln\\left(\\frac{-\\ln(1 - \\varepsilon)}{\\alpha}\\right)}{\\ln\\left(\\frac{r}{N}\\right)} \\leq m\n$$\nThis inequality provides the condition that $m$ must satisfy. To find the minimal order $m$ that guarantees the preservation requirement, we select the smallest possible value for $m$, which is the lower bound of this inequality.\n$$\nm_{\\text{min}} = \\frac{\\ln\\left(\\frac{-\\ln(1 - \\varepsilon)}{\\alpha}\\right)}{\\ln\\left(\\frac{r}{N}\\right)}\n$$\nThis expression provides the required closed-form analytical expression for the minimal filter order $m$.",
            "answer": "$$\\boxed{\\frac{\\ln\\left(\\frac{-\\ln(1 - \\varepsilon)}{\\alpha}\\right)}{\\ln\\left(\\frac{r}{N}\\right)}}$$"
        },
        {
            "introduction": "While essential for stability in many scenarios, filtering is not a benign operation; it invariably alters the numerical solution and can degrade the formal accuracy of the underlying scheme. This exercise explores a crucial and subtle consequence of modal filtering: the loss of superconvergence at element boundaries . You will derive the pointwise error introduced by a filter at a flux point, providing a clear understanding of the trade-off between stability and the high-order accuracy properties that make spectral methods attractive.",
            "id": "3418287",
            "problem": "Consider the scalar linear advection equation $u_{t} + a u_{x} = 0$ on the interval $[-1,1]$ with constant advection speed $a0$. Let a single-element spectral collocation discretization be used with Legendre–Gauss–Lobatto nodes of polynomial degree $N$, so that the numerical solution is represented exactly (in the absence of filtering) by a Legendre modal expansion $u_{N}(x,t) = \\sum_{k=0}^{N} \\hat{u}_{k}(t) P_{k}(x)$, where $P_{k}(x)$ are Legendre polynomials satisfying $P_{k}(1)=1$ for all $k$. In this collocation setting, the point $x=1$ is a flux point: for polynomial data of degree at most $N$, the nodal and modal representations agree and the conservative flux evaluated at $x=1$ is exact in the unfiltered scheme.\n\nTo stabilize oscillations, an exponential modal filter is applied at each time step to the modal coefficients via $\\hat{u}_{k} \\mapsto \\sigma_{k} \\hat{u}_{k}$, where the transfer function is \n$$\n\\sigma_{k} = \\exp\\!\\big(-\\alpha \\left(\\tfrac{k}{N}\\right)^{p}\\big),\n$$ \nwith filter strength $\\alpha0$ and filter order $p \\in \\mathbb{N}$. Assume that at a fixed time $t^{\\star}$ the exact solution $u(x,t^{\\star})$ equals the single Legendre mode $P_{N}(x)$, so that the unfiltered spectral collocation representation recovers $u(x,t^{\\star})$ exactly with $\\hat{u}_{N}(t^{\\star})=1$ and $\\hat{u}_{k}(t^{\\star})=0$ for $k\\neq N$.\n\nStarting from the core definitions of Legendre polynomial modal expansions and the action of diagonal modal filtering, derive the pointwise error at the flux point $x=1$ introduced by the filter, defined by \n$$\n\\varepsilon(\\alpha,p,N) = u_{N}^{\\mathrm{filtered}}(1,t^{\\star}) - u(1,t^{\\star}),\n$$ \nand provide a closed-form analytic expression for $\\varepsilon(\\alpha,p,N)$ in terms of $\\alpha$, $p$, and $N$. Then, using first principles of modal-to-point evaluation at $x=1$, characterize the necessary and sufficient condition on the diagonal modal transfer function $k \\mapsto \\sigma_{k}$ under which the flux-point superconvergence (exactness of the flux-point value for all polynomials of degree at most $N$) survives filtering.\n\nExpress the final answer as the single analytic expression for $\\varepsilon(\\alpha,p,N)$. No rounding is required and no units are involved.",
            "solution": "The analysis proceeds in two parts as requested by the problem statement.\n\n**Part 1: Derivation of the Pointwise Error $\\varepsilon(\\alpha,p,N)$**\n\nThe error at the flux point $x=1$ is defined as $\\varepsilon(\\alpha,p,N) = u_{N}^{\\mathrm{filtered}}(1,t^{\\star}) - u(1,t^{\\star})$. We will compute each term separately.\n\nFirst, we determine the value of the exact solution at the point of interest. The problem states that at time $t^{\\star}$, the exact solution is $u(x,t^{\\star}) = P_{N}(x)$. We evaluate this at $x=1$:\n$$\nu(1,t^{\\star}) = P_{N}(1)\n$$\nThe problem specifies the property that Legendre polynomials satisfy $P_{k}(1) = 1$ for all $k$. Therefore, for $k=N$, we have:\n$$\nu(1,t^{\\star}) = 1\n$$\n\nNext, we determine the value of the filtered numerical solution, $u_{N}^{\\mathrm{filtered}}(1,t^{\\star})$. The unfiltered solution, $u_{N}(x,t^{\\star})$, is given to have modal coefficients $\\hat{u}_{N}(t^{\\star})=1$ and $\\hat{u}_{k}(t^{\\star})=0$ for all $k \\neq N$. The filtering process acts on these modal coefficients. Let the filtered coefficients be denoted $\\hat{u}_{k}^{\\mathrm{filtered}}$. The transformation is given by:\n$$\n\\hat{u}_{k}^{\\mathrm{filtered}} = \\sigma_{k} \\hat{u}_{k}(t^{\\star})\n$$\nFor $k \\neq N$, we have $\\hat{u}_{k}(t^{\\star})=0$, so $\\hat{u}_{k}^{\\mathrm{filtered}} = \\sigma_{k} \\cdot 0 = 0$.\nFor $k = N$, we have $\\hat{u}_{N}(t^{\\star})=1$, so $\\hat{u}_{N}^{\\mathrm{filtered}} = \\sigma_{N} \\cdot 1 = \\sigma_{N}$.\n\nThe filter transfer function is $\\sigma_{k} = \\exp(-\\alpha (\\frac{k}{N})^{p})$. For the specific mode $k=N$, this becomes:\n$$\n\\sigma_{N} = \\exp\\big(-\\alpha \\left(\\tfrac{N}{N}\\right)^{p}\\big) = \\exp(-\\alpha \\cdot 1^{p}) = \\exp(-\\alpha)\n$$\nThus, the only non-zero filtered modal coefficient is $\\hat{u}_{N}^{\\mathrm{filtered}} = \\exp(-\\alpha)$.\n\nThe filtered numerical solution is reconstructed from these filtered coefficients:\n$$\nu_{N}^{\\mathrm{filtered}}(x,t^{\\star}) = \\sum_{k=0}^{N} \\hat{u}_{k}^{\\mathrm{filtered}} P_{k}(x)\n$$\nSince only the coefficient for $k=N$ is non-zero, this sum collapses to a single term:\n$$\nu_{N}^{\\mathrm{filtered}}(x,t^{\\star}) = \\hat{u}_{N}^{\\mathrm{filtered}} P_{N}(x) = \\exp(-\\alpha) P_{N}(x)\n$$\nNow, we evaluate this filtered solution at the flux point $x=1$:\n$$\nu_{N}^{\\mathrm{filtered}}(1,t^{\\star}) = \\exp(-\\alpha) P_{N}(1)\n$$\nUsing the property $P_{N}(1)=1$, we find:\n$$\nu_{N}^{\\mathrm{filtered}}(1,t^{\\star}) = \\exp(-\\alpha)\n$$\n\nFinally, we compute the error $\\varepsilon(\\alpha,p,N)$ by substituting the values we found:\n$$\n\\varepsilon(\\alpha,p,N) = u_{N}^{\\mathrm{filtered}}(1,t^{\\star}) - u(1,t^{\\star}) = \\exp(-\\alpha) - 1\n$$\nThis is the closed-form analytic expression for the error. Notably, under the specific condition that the initial error is concentrated in the highest mode $k=N$, the error introduced by the filter is independent of the polynomial degree $N$ and the filter order $p$.\n\n**Part 2: Condition for Preserving Flux-Point Superconvergence**\n\nFlux-point superconvergence implies that the numerical solution is exact at the point $x=1$ for any solution that is a polynomial of degree at most $N$. Let us consider an arbitrary polynomial solution $u(x)$ in this space, represented by its Legendre modal expansion:\n$$\nu(x) = \\sum_{k=0}^{N} \\hat{u}_{k} P_{k}(x)\n$$\nThe exact value of this solution at $x=1$ is:\n$$\nu(1) = \\sum_{k=0}^{N} \\hat{u}_{k} P_{k}(1) = \\sum_{k=0}^{N} \\hat{u}_{k} \\cdot 1 = \\sum_{k=0}^{N} \\hat{u}_{k}\n$$\nThe filtered numerical representation of this solution, $u_{N}^{\\mathrm{filtered}}(x)$, has modal coefficients $\\hat{u}_{k}^{\\mathrm{filtered}} = \\sigma_{k} \\hat{u}_{k}$. Its value at $x=1$ is:\n$$\nu_{N}^{\\mathrm{filtered}}(1) = \\sum_{k=0}^{N} \\hat{u}_{k}^{\\mathrm{filtered}} P_{k}(1) = \\sum_{k=0}^{N} (\\sigma_{k} \\hat{u}_{k}) \\cdot 1 = \\sum_{k=0}^{N} \\sigma_{k} \\hat{u}_{k}\n$$\nFor superconvergence to be preserved by the filter, the filtered value must be equal to the exact value for any choice of coefficients $\\{\\hat{u}_{k}\\}_{k=0}^{N}$. This gives the condition:\n$$\n\\sum_{k=0}^{N} \\sigma_{k} \\hat{u}_{k} = \\sum_{k=0}^{N} \\hat{u}_{k}\n$$\nRearranging the terms, we get:\n$$\n\\sum_{k=0}^{N} \\sigma_{k} \\hat{u}_{k} - \\sum_{k=0}^{N} \\hat{u}_{k} = 0\n$$\n$$\n\\sum_{k=0}^{N} (\\sigma_{k} - 1) \\hat{u}_{k} = 0\n$$\nThis equation must hold for any arbitrary vector of coefficients $(\\hat{u}_{0}, \\hat{u}_{1}, \\dots, \\hat{u}_{N})$. In the vector space of coefficients, this is equivalent to the dot product of the vector $(\\sigma_{0}-1, \\dots, \\sigma_{N}-1)$ with an arbitrary vector $(\\hat{u}_{0}, \\dots, \\hat{u}_{N})$ being zero. This is only possible if the first vector is the zero vector. Therefore, each component must be zero:\n$$\n\\sigma_{k} - 1 = 0 \\quad \\text{for all } k \\in \\{0, 1, \\dots, N\\}\n$$\nThis yields the necessary and sufficient condition:\n$$\n\\sigma_{k} = 1 \\quad \\text{for all } k \\in \\{0, 1, \\dots, N\\}\n$$\nIn words, to preserve the exactness of the solution at the flux point for all polynomials up to degree $N$, the filter's transfer function must be unity for all corresponding modes. This means the filter must act as the identity operator on the solution space, effectively applying no filtering at all. Any non-trivial filter (i.e., where $\\sigma_{k}  1$ for some $k$) will destroy the superconvergence property.",
            "answer": "$$\n\\boxed{\\exp(-\\alpha) - 1}\n$$"
        },
        {
            "introduction": "We now apply these concepts to a classic and challenging nonlinear problem: capturing a shock wave with the inviscid Burgers' equation. High-order methods are notoriously prone to severe oscillations (Gibbs phenomenon) at such discontinuities, making robust stabilization essential. This practice delves into Spectral Vanishing Viscosity (SVV), a sophisticated filtering technique that acts as a mode-dependent artificial viscosity . By modeling the SVV operator's effect and implementing a formula to predict the resulting shock thickness, you will gain hands-on experience with a powerful tool for simulating hyperbolic conservation laws.",
            "id": "3418289",
            "problem": "Consider the one-dimensional inviscid Burgers equation on the interval $[-1,1]$ with Dirichlet boundary conditions,\n$$\nu_t + \\partial_x \\left(\\tfrac{1}{2} u^2 \\right) = 0, \\quad x \\in [-1,1], \\quad t \\ge 0,\n$$\nand boundary data $u(-1,t)=u_L$ and $u(1,t)=u_R$, with a Riemann step initial condition that produces a stationary shock centered at $x=0$, where $u_L  u_R$. In a Legendre spectral method with $N+1$ Legendre-Gauss-Lobatto collocation points and a Spectral Vanishing Viscosity (SVV) stabilization, one augments the semidiscrete equation with a modal diffusion operator that damps high Legendre modes. In modal space indexed by $k=0,1,\\dots,N$, the SVV adds the damping rate $\\widehat{\\nu}_k \\,\\eta_k$ to mode $k$, where $\\eta_k$ is the spectral symbol associated with a second-derivative-like operator for Legendre modes and $\\widehat{\\nu}_k$ is the SVV kernel. Assume the following standard modeling choices:\n- The symbol is $\\eta_k = k(k+1)$.\n- The SVV kernel is piecewise polynomial with cutoff $m$ and ramp power $p=2$,\n$$\n\\widehat{\\nu}_k = \\nu_0 \\, s_k, \\quad s_k = \\begin{cases}\n0,  k  m,\\\\\n\\left( \\dfrac{k-m}{N-m} \\right)^{2},  m \\le k \\le N,\n\\end{cases}\n$$\nwith parameters $\\nu_00$, $m \\in \\{0,1,\\dots,N-1\\}$, and $N \\in \\mathbb{N}$.\n\nA steady viscous Burgers shock for the equation $u_t + \\partial_x(\\tfrac{1}{2}u^2) = \\nu \\, u_{xx}$ connecting $u_L$ to $u_R$ has a smooth internal layer of thickness $\\delta$ that scales like $\\delta \\sim 4 \\nu / \\Delta$, where $\\Delta = u_L - u_R$ is the jump strength. In the SVV-stabilized Legendre spectral method, the SVV operator acts as an effective physical viscosity at the shock scale. Model this effective viscosity by replacing the SVV operator with a constant viscosity $\\nu_{\\mathrm{eff}}$ equal to the mean modal damping strength above the cutoff normalized by the highest-mode symbol, namely\n$$\n\\nu_{\\mathrm{eff}}(\\nu_0,m,N) = \\nu_0 \\, \\overline{\\eta}_m, \\quad \\overline{\\eta}_m = \\frac{1}{N-m+1} \\sum_{k=m}^{N} s_k \\, \\frac{\\eta_k}{N(N+1)}.\n$$\nUnder this modeling assumption and for the stationary shock with $u_L=1$ and $u_R=-1$ (so that $\\Delta = 2$ and shock speed is zero), the shock thickness $\\delta$ is predicted by\n$$\n\\delta(\\nu_0,m,N) = \\frac{4 \\, \\nu_{\\mathrm{eff}}(\\nu_0,m,N)}{\\Delta}.\n$$\n\nYour tasks are:\n1. Starting from the steady viscous Burgers balance and the Rankine–Hugoniot condition, derive from first principles the scaling law $\\delta = 4\\nu/\\Delta$ for the shock thickness $\\delta$ of the viscous Burgers equation with constant viscosity $\\nu$, assuming a monotone traveling-wave solution connecting $u_L$ to $u_R$.\n2. Using the Legendre spectral SVV model and the modal-average effective viscosity $\\nu_{\\mathrm{eff}}(\\nu_0,m,N)$ defined above, derive the explicit computable expression for $\\delta(\\nu_0,m,N)$ in terms of $\\nu_0$, $m$, and $N$, with $p=2$, $u_L=1$, and $u_R=-1$.\n3. Implement a program that computes $\\delta(\\nu_0,m,N)$ for a set of test cases. Use the following test suite of parameters $(\\nu_0,m,N)$:\n   - $(0.02,16,32)$,\n   - $(0.01,32,64)$,\n   - $(0.02,56,64)$,\n   - $(0.05,8,16)$,\n   - $(0.02,0,32)$.\n   You should assume dimensionless units throughout and return the shock thickness values as real numbers.\n4. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\"), in the same order as the test suite above.\n\nConstraints and clarifications:\n- All mathematical symbols and numbers must be interpreted in the standard dimensionless form appropriate for the inviscid Burgers equation with SVV.\n- Angles are not involved; no angle unit is required.\n- Percentages are not involved; no percentage representation is required.\n- The final answers for each test case must be real numbers (floats).",
            "solution": "**1. Derivation of the Viscous Shock Thickness Scaling Law**\n\nThe first task is to derive the scaling law $\\delta \\sim 4\\nu/\\Delta$ for a stationary shock in the viscous Burgers equation, $u_t + \\partial_x(\\tfrac{1}{2}u^2) = \\nu u_{xx}$.\n\nFor a stationary shock, the solution is independent of time $t$, so $u_t=0$. The equation reduces to a steady-state form:\n$$\n\\frac{d}{dx} \\left( \\frac{1}{2} u^2 \\right) = \\nu \\frac{d^2u}{dx^2}.\n$$\nIntegrating once with respect to $x$ yields:\n$$\n\\frac{1}{2} u^2 = \\nu \\frac{du}{dx} + C_1,\n$$\nwhere $C_1$ is a constant of integration. We consider a solution that connects the state $u_L$ at $x \\to -\\infty$ to $u_R$ at $x \\to +\\infty$. In these far-field limits, the solution becomes constant, so its derivative $\\frac{du}{dx}$ vanishes. Applying this condition at $x \\to -\\infty$:\n$$\n\\frac{1}{2} u_L^2 = \\nu(0) + C_1 \\implies C_1 = \\frac{1}{2} u_L^2.\n$$\nThe Rankine-Hugoniot condition for a stationary shock ($c=0$) in the Burgers equation requires $\\frac{1}{2}u_L^2 = \\frac{1}{2}u_R^2$, which implies $u_R = -u_L$. This is consistent with the problem's specification of $u_L=1$ and $u_R=-1$. With this, the constant $C_1$ is consistently determined by the conditions at both $x \\to \\pm\\infty$.\n\nSubstituting $C_1$ back, we obtain a first-order ordinary differential equation for the shock profile $u(x)$:\n$$\n\\nu \\frac{du}{dx} = \\frac{1}{2} (u^2 - u_L^2).\n$$\nThis is a separable equation. We can write:\n$$\n\\frac{dx}{\\nu} = \\frac{2}{u^2 - u_L^2} du.\n$$\nIntegrating this equation gives the implicit solution for $u(x)$. The explicit solution, centered at $x=0$ such that $u(0)=0$, is found to be:\n$$\nu(x) = -u_L \\tanh\\left( \\frac{u_L x}{2\\nu} \\right).\n$$\nThe shock thickness $\\delta$ characterizes the width of the transition layer. This thickness is determined by the characteristic length scale appearing in the solution profile. From the argument of the hyperbolic tangent function, we can identify this length scale as $L_{\\text{char}} = \\frac{2\\nu}{u_L}$.\n\nThe problem requires expressing this scaling in terms of the shock jump strength, $\\Delta = u_L - u_R$. Since $u_R = -u_L$, we have $\\Delta = u_L - (-u_L) = 2u_L$. We can substitute $u_L = \\Delta/2$ into the expression for the characteristic length:\n$$\nL_{\\text{char}} = \\frac{2\\nu}{(\\Delta/2)} = \\frac{4\\nu}{\\Delta}.\n$$\nThe shock thickness $\\delta$ is directly proportional to this inherent length scale of the solution. Therefore, we derive the scaling law:\n$$\n\\delta \\sim \\frac{4\\nu}{\\Delta}.\n$$\nThis completes the first derivation.\n\n**2. Derivation of the Computable Expression for $\\delta(\\nu_0, m, N)$**\n\nThe second task is to find the explicit formula for the shock thickness $\\delta(\\nu_0, m, N)$ within the SVV model. The problem provides a sequence of definitions that we shall compose.\n\nThe predicted shock thickness is given by:\n$$\n\\delta(\\nu_0, m, N) = \\frac{4 \\nu_{\\mathrm{eff}}(\\nu_0, m, N)}{\\Delta}.\n$$\nThe specific case given is $u_L=1$ and $u_R=-1$, so the jump strength is $\\Delta = 1 - (-1) = 2$.\n$$\n\\delta(\\nu_0, m, N) = \\frac{4 \\nu_{\\mathrm{eff}}(\\nu_0, m, N)}{2} = 2 \\nu_{\\mathrm{eff}}(\\nu_0, m, N).\n$$\nThe effective viscosity $\\nu_{\\mathrm{eff}}$ is modeled as:\n$$\n\\nu_{\\mathrm{eff}}(\\nu_0, m, N) = \\nu_0 \\overline{\\eta}_m.\n$$\nSubstituting this into the expression for $\\delta$:\n$$\n\\delta(\\nu_0, m, N) = 2 \\nu_0 \\overline{\\eta}_m.\n$$\nThe term $\\overline{\\eta}_m$ is the normalized mean modal damping strength:\n$$\n\\overline{\\eta}_m = \\frac{1}{N-m+1} \\sum_{k=m}^{N} s_k \\frac{\\eta_k}{N(N+1)}.\n$$\nWe are given the SVV kernel component $s_k$ for $m \\le k \\le N$ and the spectral symbol $\\eta_k$:\n$$\ns_k = \\left( \\frac{k-m}{N-m} \\right)^{2}, \\quad \\eta_k = k(k+1).\n$$\nSubstituting these expressions for $s_k$ and $\\eta_k$ into the formula for $\\overline{\\eta}_m$:\n$$\n\\overline{\\eta}_m = \\frac{1}{N-m+1} \\sum_{k=m}^{N} \\left( \\frac{k-m}{N-m} \\right)^{2} \\frac{k(k+1)}{N(N+1)}.\n$$\nNow, we substitute this full expression for $\\overline{\\eta}_m$ into our equation for $\\delta(\\nu_0, m, N)$:\n$$\n\\delta(\\nu_0, m, N) = 2 \\nu_0 \\left[ \\frac{1}{N-m+1} \\sum_{k=m}^{N} \\left( \\frac{k-m}{N-m} \\right)^{2} \\frac{k(k+1)}{N(N+1)} \\right].\n$$\nThis can be rearranged for computational clarity by factoring out constants from the summation:\n$$\n\\delta(\\nu_0, m, N) = \\frac{2 \\nu_0}{(N-m+1) (N-m)^2 N(N+1)} \\sum_{k=m}^{N} (k-m)^2 k(k+1).\n$$\nThis is the final, explicit, and computable expression for the shock thickness $\\delta$ as a function of the SVV parameters $\\nu_0$, $m$, and $N$. The sum is evaluated over the integer index $k$ from $m$ to $N$. The parameters $m$ and $N$ are constrained by $m \\in \\{0,1,\\dots,N-1\\}$, ensuring that the term $(N-m)$ is always a positive integer, thus preventing division by zero. This formula will be implemented in the program to solve the final part of the task.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_delta(nu_0, m, N):\n    \"\"\"\n    Computes the predicted shock thickness for a Legendre spectral method \n    stabilized with Spectral Vanishing Viscosity (SVV).\n\n    Args:\n        nu_0 (float): The base viscosity parameter for the SVV kernel.\n        m (int): The cutoff mode index for the SVV kernel.\n        N (int): The maximum polynomial degree (number of modes is N+1).\n\n    Returns:\n        float: The computed shock thickness delta.\n    \"\"\"\n    # The problem specifies m is in {0, 1, ..., N-1}, so N-m = 1.\n    # We defensively check for this condition.\n    if not (0 = m  N):\n        raise ValueError(\"Parameters must satisfy 0 = m  N.\")\n\n    # The shock jump strength Delta is u_L - u_R = 1 - (-1) = 2.\n    delta_u = 2.0\n\n    # The problem defines the predicted shock thickness as:\n    # delta = (4 * nu_eff) / delta_u = 2 * nu_eff\n    # where nu_eff = nu_0 * eta_m_bar\n\n    # We need to compute eta_m_bar, which involves a summation.\n    # eta_m_bar = (1/(N-m+1)) * sum_{k=m to N} [s_k * eta_k / (N*(N+1))]\n\n    # s_k = ((k-m)/(N-m))^2\n    # eta_k = k*(k+1)\n    \n    # Let's compute the summation part first.\n    # We use a generator expression within np.sum for efficiency and clarity.\n    sum_val = np.sum(\n        [\n            (((k - m) / (N - m)) ** 2) * (k * (k + 1))\n            for k in range(m, N + 1)\n        ]\n    )\n\n    # Now, assemble eta_m_bar.\n    # Normalization factor for the sum.\n    num_modes_filtered = N - m + 1\n    # Symbol at the highest mode for normalization.\n    eta_N = N * (N + 1)\n    \n    eta_m_bar = (1 / num_modes_filtered) * (sum_val / eta_N)\n\n    # Compute the effective viscosity.\n    nu_eff = nu_0 * eta_m_bar\n\n    # Finally, compute the shock thickness.\n    shock_thickness = (4.0 * nu_eff) / delta_u\n\n    return shock_thickness\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is in the format (nu_0, m, N).\n    test_cases = [\n        (0.02, 16, 32),\n        (0.01, 32, 64),\n        (0.02, 56, 64),\n        (0.05, 8, 16),\n        (0.02, 0, 32),\n    ]\n\n    results = []\n    for nu_0, m, N in test_cases:\n        result = compute_delta(nu_0, m, N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) converts each float result to a string.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}