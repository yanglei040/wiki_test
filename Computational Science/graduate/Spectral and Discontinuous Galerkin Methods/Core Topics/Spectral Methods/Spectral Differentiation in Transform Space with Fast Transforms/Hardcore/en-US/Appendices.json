{
    "hands_on_practices": [
        {
            "introduction": "To begin, we will implement the fundamental algorithm for spectral differentiation. This practice solidifies the core principle that differentiation in the physical domain is equivalent to multiplication by the imaginary unit and the wavenumber, $ik$, in the Fourier domain. By completing this exercise , you will build a robust tool and gain insight into crucial implementation details like wavenumber ordering and Nyquist frequency handling.",
            "id": "3417201",
            "problem": "You are asked to design and implement a program that computes the first derivative of a periodic function using spectral differentiation in transform space with a Fast Fourier Transform (FFT). The underlying principle is that differentiation in the physical domain corresponds to multiplication by the imaginary unit times the angular wavenumber in the Fourier domain. All angles must be in radians.\n\nThe fundamental basis to use is as follows. Consider a periodic function sampled on a uniform grid over a periodic interval of length $L$. Let the grid be $x_j = j\\Delta x$ for $j = 0, 1, \\dots, N-1$, where $\\Delta x = L/N$. The Discrete Fourier Transform (DFT) and its inverse are defined (up to normalization constants chosen by library conventions) by\n$$\nU_k = \\sum_{j=0}^{N-1} u_j \\, e^{-i \\kappa_k x_j}, \\quad\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} U_k \\, e^{i \\kappa_k x_j},\n$$\nwhere $u_j = u(x_j)$ and $\\kappa_k$ are the angular wavenumbers corresponding to the integer Fourier modes indexed by $k$. For a periodic domain of length $L$, the continuous Fourier modes are $e^{i m (2\\pi/L) x}$ with integer $m$, hence the angular wavenumbers are $\\kappa = (2\\pi/L) m$.\n\nThe key well-tested fact to use is that for each Fourier mode $e^{i \\kappa x}$, the derivative satisfies\n$$\n\\frac{d}{dx} \\left( e^{i \\kappa x} \\right) = i \\kappa \\, e^{i \\kappa x}.\n$$\nTherefore, differentiation in the Fourier domain corresponds to multiplication by $i \\kappa$.\n\nConstruct the angular wavenumber array $\\kappa_k = (2\\pi/L) m_k$ by mapping the DFT indices to the integer wavenumbers $m_k$. For even $N$, the ordering of integer wavenumbers $m_k$ corresponding to the DFT indices $k=0, \\dots, N-1$ is conventionally $0, 1, \\dots, N/2-1, -N/2, -N/2+1, \\dots, -1$. The Nyquist mode at $|m| = N/2$ occurs only when $N$ is even; the conventional choice in spectral differentiation is to set the derivative multiplier of the Nyquist coefficient to zero to maintain real-valuedness of the physical derivative for real input data.\n\nYour implementation must proceed in the following logical steps, strictly adhering to the principles above without using any unmotivated shortcut formulas:\n1. Sample the function $u(x)$ on an equispaced grid $x_j$ over $[0, L)$ with $N$ points.\n2. Compute the DFT coefficients $U_k$ using a Fast Fourier Transform (FFT).\n3. Construct the angular wavenumber array $\\kappa_k$ from the DFT frequency bins for the given $L$ and $N$, ensuring correct ordering for negative frequencies. For even $N$, set the derivative multiplier at the Nyquist index to zero.\n4. Form the differentiated spectrum $\\widehat{u'}_k = i \\, \\kappa_k \\, U_k$.\n5. Compute the inverse DFT of $\\widehat{u'}_k$ to obtain the differentiated values $u'_j$ in the physical domain. Use the convention of your FFT library consistently.\n6. Extract the real part of $u'_j$ and report errors or diagnostic values as required.\n\nTest suite. Your program must compute and aggregate the following test cases, each producing a single real number. Use $N = 16$ unless otherwise stated, and angles in radians.\n\n- Case A (happy path, exact resolvability): Let $L = 2\\pi$. Define $u(x) = \\sin(3x) + 0.5 \\cos(5x)$. Compute the spectral derivative and the analytic derivative $u'(x) = 3 \\cos(3x) - 2.5 \\sin(5x)$. Report the maximum absolute error $\\max_j |u'_j - u'_{\\text{analytic}}(x_j)|$ as a float.\n\n- Case B (Nyquist mode handling): Let $L = 2\\pi$. Define $u(x) = \\cos\\!\\big((N/2) x\\big) = \\cos(8x)$. Compute the spectral derivative, which should be identically zero on the sample grid due to the derivative being proportional to $\\sin\\!\\big((N/2) x\\big)$ evaluated at $x_j = 2\\pi j/N$, where it vanishes. Report $\\max_j |u'_j|$ as a float.\n\n- Case C (aliasing beyond Nyquist): Let $L = 2\\pi$. Define $u(x) = \\sin(9x)$. On the discrete grid with $N = 16$, this aliases to $-\\sin(7x)$. The spectral method will return the derivative consistent with the aliased representation, i.e., approximately $-7 \\cos(7x)$ on the grid. Report the maximum absolute error between the spectral derivative and the aliased derivative,\n$$\n\\max_j \\left| u'_j - \\left( -7 \\cos(7 x_j) \\right) \\right|,\n$$\nas a float.\n\n- Case D (non-unit domain length scaling): Let $L = 4\\pi$. Define\n$$\nu(x) = \\sin\\!\\left( 3 \\cdot \\frac{2\\pi}{L} x \\right) + 0.5 \\cos\\!\\left( 5 \\cdot \\frac{2\\pi}{L} x \\right).\n$$\nThe analytic derivative is\n$$\nu'(x) = \\left(3 \\cdot \\frac{2\\pi}{L}\\right) \\cos\\!\\left( 3 \\cdot \\frac{2\\pi}{L} x \\right) - 0.5 \\left(5 \\cdot \\frac{2\\pi}{L}\\right) \\sin\\!\\left( 5 \\cdot \\frac{2\\pi}{L} x \\right).\n$$\nReport the maximum absolute error $\\max_j |u'_j - u'_{\\text{analytic}}(x_j)|$ as a float.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order [Case A, Case B, Case C, Case D]. For example, a line of the form \"[resultA,resultB,resultC,resultD]\".",
            "solution": "The problem statement has been rigorously validated and is determined to be sound. It is scientifically grounded, well-posed, objective, and provides a complete and consistent set of requirements for implementing a spectral differentiation algorithm. The problem is a standard exercise in numerical spectral methods and is directly relevant to the specified topic. We may therefore proceed with a formal solution.\n\nThe core principle of spectral differentiation for a periodic function $u(x)$ on a domain of length $L$ is based on its Fourier series representation. Any sufficiently smooth periodic function can be expressed as a sum of complex exponentials:\n$$\nu(x) = \\sum_{m=-\\infty}^{\\infty} \\hat{u}_m e^{i \\kappa_m x}\n$$\nwhere $\\hat{u}_m$ are the Fourier coefficients and $\\kappa_m = m \\frac{2\\pi}{L}$ are the angular wavenumbers for integer modes $m$. The key property of the Fourier basis is that differentiation is diagonal in this basis. Differentiating the series term-by-term yields:\n$$\n\\frac{d u(x)}{dx} = \\sum_{m=-\\infty}^{\\infty} (i \\kappa_m) \\hat{u}_m e^{i \\kappa_m x}\n$$\nThis demonstrates that in the Fourier domain, differentiation of the function $u(x)$ corresponds to the multiplication of its Fourier coefficients $\\hat{u}_m$ by the factor $i\\kappa_m$.\n\nFor a computational implementation, we work with a discretized version of the function. The function $u(x)$ is sampled on a uniform grid of $N$ points, $x_j = j \\Delta x$ for $j = 0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/N$. The discrete function values are $u_j = u(x_j)$. The continuous Fourier series is replaced by the Discrete Fourier Transform (DFT), which relates the physical space values $u_j$ to a set of $N$ discrete Fourier coefficients $U_k$. The forward and inverse DFT pair, as implemented in standard numerical libraries like `numpy`, are defined as:\n$$\nU_k = \\sum_{j=0}^{N-1} u_j e^{-i 2\\pi j k / N} \\quad (\\text{FFT})\n$$\n$$\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} U_k e^{i 2\\pi j k / N} \\quad (\\text{iFFT})\n$$\nHere, the index $k$ ranges from $0$ to $N-1$ and represents the discrete frequency bins. To apply the differentiation principle, we must map these indices to the correct physical angular wavenumbers $\\kappa_k$. The set of integer wavenumbers $m$ that can be uniquely represented on a grid of $N$ points spans from negative to positive values. For an even number of points $N$, the standard convention arranges the corresponding integer modes $m_k$ for DFT indices $k=0, 1, \\dots, N-1$ as $m_k \\in \\{0, 1, \\dots, N/2-1, -N/2, -N/2+1, \\dots, -1\\}$. The physical angular wavenumber associated with each DFT index $k$ is then given by:\n$$\n\\kappa_k = m_k \\frac{2\\pi}{L}\n$$\nThis array of wavenumbers can be algorithmically generated. A critical aspect of spectral differentiation is the handling of the Nyquist frequency, which corresponds to the integer mode $|m| = N/2$ for even $N$. As stipulated, the derivative multiplier for the Nyquist mode coefficient is set to zero. This practice ensures that the computed derivative of a real-valued function remains real-valued and helps to stabilize the numerical scheme. While the problem statement describes an integer wavenumber set containing $+N/2$, standard FFT libraries associate the Nyquist index with $-N/2$. This distinction is immaterial because the instruction to set the corresponding derivative multiplier $i\\kappa_{N/2}$ to $0$ makes the sign irrelevant.\n\nThe complete algorithm for spectral differentiation is as follows:\n1.  **Discretize**: Given a function $u(x)$, a domain length $L$, and the number of points $N$, generate the grid values $u_j = u(x_j)$ for $x_j = j L/N$, where $j=0, \\dots, N-1$.\n2.  **Forward Transform**: Compute the DFT coefficients $U_k$ of the discrete signal $u_j$ using a Fast Fourier Transform (FFT) algorithm: $U_k = \\text{FFT}(u_j)$.\n3.  **Construct Wavenumbers**: Construct the array of angular wavenumbers $\\kappa_k$ corresponding to the FFT frequency bins. For each index $k \\in \\{0, \\dots, N-1\\}$, calculate $\\kappa_k$. If $N$ is even, enforce the condition $\\kappa_{N/2} = 0$.\n4.  **Differentiate in Fourier Space**: Multiply the Fourier coefficients $U_k$ by $i\\kappa_k$ to obtain the coefficients of the derivative, $\\widehat{u'}_k = i \\kappa_k U_k$.\n5.  **Inverse Transform**: Compute the inverse FFT of the differentiated coefficients $\\widehat{u'}_k$ to transform back to physical space, yielding the discrete values of the derivative: $u'_j = \\text{iFFT}(\\widehat{u'}_k)$.\n6.  **Final Result**: For a real-valued input function $u(x)$, the computed derivative $u'_j$ should be real. Due to finite precision arithmetic, a negligible imaginary component may arise, which is discarded by taking the real part of the result.\n\nThis procedure is applied to each test case.\n-   **Case A** and **Case D** test the accuracy of the method for well-resolved functions (those containing frequencies well below the Nyquist limit), with Case D specifically testing the implementation's handling of non-standard domain length $L$. For such functions, the spectral derivative is expected to be accurate to machine precision.\n-   **Case B** tests the specified handling of the Nyquist frequency. The function $u(x) = \\cos(8x)$ on a grid with $N=16$ and $L=2\\pi$ corresponds exactly to the Nyquist frequency. The algorithm must produce a zero derivative, as its analytical derivative, $-8\\sin(8x)$, is zero at all grid points $x_j=j\\pi/8$.\n-   **Case C** tests the phenomenon of aliasing. The function $u(x) = \\sin(9x)$ has a frequency higher than the Nyquist limit for $N=16$. On the discrete grid, it is indistinguishable from (i.e., aliases to) the lower-frequency function $-\\sin(7x)$. The spectral method, operating on the grid data, correctly computes the derivative of this aliased representation, which is $-7\\cos(7x)$.",
            "answer": "```python\nimport numpy as np\n\ndef spectral_derivative(u: np.ndarray, L: float) - np.ndarray:\n    \"\"\"\n    Computes the first derivative of a periodic function u on a domain of length L\n    using the Fourier spectral method.\n\n    Args:\n        u: A numpy array of function values sampled on a uniform grid.\n        L: The length of the periodic domain.\n\n    Returns:\n        A numpy array containing the values of the spectral derivative on the grid.\n    \"\"\"\n    N = len(u)\n    \n    # 1. Construct the angular wavenumber array.\n    # The sample spacing is d = L/N. np.fft.fftfreq returns frequencies in\n    # cycles per unit of d. Here, this is cycles/distance.\n    # The angular wavenumber is kappa = 2*pi*frequency.\n    # The fftfreq function correctly orders positive and negative frequencies\n    # for the DFT output.\n    freq = np.fft.fftfreq(N, d=L/N)\n    kappa = 2 * np.pi * freq\n\n    # 2. Handle the Nyquist frequency for even N.\n    # As per the problem specification, the derivative multiplier for the Nyquist\n    # coefficient must be zeroed out. This corresponds to the FFT index N//2.\n    if N % 2 == 0:\n        kappa[N//2] = 0.0\n\n    # 3. Compute the FFT of the function.\n    U = np.fft.fft(u)\n\n    # 4. Multiply by i*kappa in Fourier space to perform differentiation.\n    U_prime = 1j * kappa * U\n\n    # 5. Compute the Inverse FFT to return to physical space.\n    u_prime = np.fft.ifft(U_prime)\n\n    # 6. For a real input, the derivative is real. Return the real part\n    # to discard any imaginary noise from floating-point inaccuracies.\n    return u_prime.real\n\n\ndef solve():\n    \"\"\"\n    Executes the test suite for the spectral differentiation algorithm and\n    prints the results in the specified format.\n    \"\"\"\n    # Globally specified parameter for test cases\n    N_global = 16\n\n    results = []\n\n    # Case A: Happy path, exact resolvability\n    L_A = 2.0 * np.pi\n    x_A = np.arange(N_global) * L_A / N_global\n    u_A = np.sin(3.0 * x_A) + 0.5 * np.cos(5.0 * x_A)\n    u_prime_analytic_A = 3.0 * np.cos(3.0 * x_A) - 2.5 * np.sin(5.0 * x_A)\n    u_prime_spectral_A = spectral_derivative(u_A, L_A)\n    error_A = np.max(np.abs(u_prime_spectral_A - u_prime_analytic_A))\n    results.append(error_A)\n\n    # Case B: Nyquist mode handling\n    L_B = 2.0 * np.pi\n    x_B = np.arange(N_global) * L_B / N_global\n    u_B = np.cos((N_global / 2.0) * x_B)\n    u_prime_spectral_B = spectral_derivative(u_B, L_B)\n    # The spectral derivative should be identically zero due to Nyquist handling.\n    # We report the maximum absolute value of the computed derivative.\n    error_B = np.max(np.abs(u_prime_spectral_B))\n    results.append(error_B)\n\n    # Case C: Aliasing beyond Nyquist\n    L_C = 2.0 * np.pi\n    x_C = np.arange(N_global) * L_C / N_global\n    u_C = np.sin(9.0 * x_C)\n    # On the grid, sin(9x) aliases to -sin(7x). The spectral method\n    # differentiates this aliased representation, yielding -7*cos(7x).\n    u_aliased_deriv_C = -7.0 * np.cos(7.0 * x_C)\n    u_prime_spectral_C = spectral_derivative(u_C, L_C)\n    error_C = np.max(np.abs(u_prime_spectral_C - u_aliased_deriv_C))\n    results.append(error_C)\n\n    # Case D: Non-unit domain length scaling\n    L_D = 4.0 * np.pi\n    x_D = np.arange(N_global) * L_D / N_global\n    # Fundamental wavenumber for this domain\n    k0_D = 2.0 * np.pi / L_D\n    u_D = np.sin(3.0 * k0_D * x_D) + 0.5 * np.cos(5.0 * k0_D * x_D)\n    u_prime_analytic_D = \\\n        (3.0 * k0_D) * np.cos(3.0 * k0_D * x_D) - \\\n        0.5 * (5.0 * k0_D) * np.sin(5.0 * k0_D * x_D)\n    u_prime_spectral_D = spectral_derivative(u_D, L_D)\n    error_D = np.max(np.abs(u_prime_spectral_D - u_prime_analytic_D))\n    results.append(error_D)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world applications often involve nonlinear terms, such as products of functions, which introduce a new challenge: aliasing error. This exercise  demonstrates how to compute the derivative of a product and tackles the aliasing that arises by implementing the two-thirds de-aliasing rule, a crucial technique for ensuring accuracy in nonlinear simulations. You will quantify the error reduction and appreciate why such methods are indispensable for robust spectral calculations.",
            "id": "3417276",
            "problem": "Consider the $2\\pi$-periodic functions $u(x)=\\sin(ax)$ and $v(x)=\\cos(bx)$ sampled on a uniform periodic grid with $N$ points on the interval $[0,2\\pi)$, where $x_j=\\frac{2\\pi j}{N}$ for $j=0,1,\\dots,N-1$ and angles are measured in radians. The goal is to compute the spatial derivative $\\partial_x(uv)$ by a spectral method in transform space using the Fast Fourier Transform (FFT), both without de-aliasing and with the two-thirds-rule de-aliasing implemented via $3/2$ zero-padding, and then to quantify the aliasing error by comparison to the exact analytical derivative obtained from first principles.\n\nStart from the following fundamental principles:\n- The Fourier series representation of a $2\\pi$-periodic function $f(x)$ and the Discrete Fourier Transform (DFT) computed via the Fast Fourier Transform (FFT).\n- The identity for derivatives in transform space: for each Fourier mode $e^{\\mathrm{i}kx}$ it holds that $\\partial_x e^{\\mathrm{i}kx}=\\mathrm{i}k e^{\\mathrm{i}kx}$.\n- The product rule $\\partial_x(uv)=u_x v + u v_x$.\n\nDesign a program that, for each test case described below, performs the following tasks:\n1. Compute $w(x)=u(x)v(x)$ at the $N$ grid points and then compute $\\partial_x w$ at those points by transforming $w$ into Fourier space, multiplying by $\\mathrm{i}k$, and transforming back. Use the angular wavenumbers $k$ consistent with the $[0,2\\pi)$ domain. This is the computation without de-aliasing.\n2. Compute $\\partial_x w$ with de-aliasing using the two-thirds rule implemented via $3/2$ zero-padding: zero-pad the discrete Fourier transforms of $u$ and $v$ from length $N$ to length $M=\\frac{3N}{2}$ (ensure correct coefficient scaling so that inverse transforms evaluate the same continuous Fourier content on the finer grid), inverse transform to the $M$-point grid, form the product $w$ pointwise on the $M$-point grid, transform $w$ back to Fourier space, multiply by $\\mathrm{i}k$ at resolution $M$, truncate the resulting spectrum back to length $N$ (with the inverse scaling to preserve low-frequency content), and inverse transform to the original $N$-point grid.\n3. Compute the exact analytical derivative $\\partial_x(uv)$ using the product rule and the definitions of $u$ and $v$, evaluated at the $N$ grid points.\n4. Quantify the aliasing error for both the non-de-aliased and de-aliased computations as the relative discrete $\\ell^2$ error with respect to the exact analytical derivative, defined as\n$$\nE_{\\ell^2} = \\frac{\\left\\| \\partial_x w_{\\text{computed}} - \\partial_x w_{\\text{exact}} \\right\\|_2}{\\left\\| \\partial_x w_{\\text{exact}} \\right\\|_2},\n$$\nwhere $\\|\\cdot\\|_2$ is the Euclidean norm over the $N$ sampled grid points.\n\nYour program must implement the FFT-based spectral differentiation with appropriate angular wavenumbers $k$ constructed from the DFT frequency array for a sampling spacing $\\Delta x = \\frac{2\\pi}{N}$ so that the angular wavenumbers are integers. It must also implement the $3/2$ zero-padding procedure with consistent scaling when padding and truncating spectra to preserve the amplitudes of low-frequency Fourier modes.\n\nTest Suite:\nUse the following five test cases to exercise different aliasing regimes. Each test case is a tuple $(N,a,b)$ with angles in radians:\n- Case 1 (no aliasing, low wavenumbers): $(16,3,4)$.\n- Case 2 (strong aliasing, high-but-resolvable inputs whose product excites modes above Nyquist): $(16,7,7)$.\n- Case 3 (no aliasing at higher resolution): $(32,12,13)$.\n- Case 4 (aliasing near the resolution limit): $(32,15,17)$.\n- Case 5 (aliasing at moderate resolution): $(24,8,10)$.\n\nAnswer Specification:\nFor each test case, compute the pair of relative $\\ell^2$ errors $[E_{\\ell^2}^{\\text{no-dealias}}, E_{\\ell^2}^{\\text{dealias}}]$. Aggregate the results for all five cases into a single line of output containing a list of five such pairs. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces, where each pair is itself a comma-separated list enclosed in square brackets. For example: \"[[e11,e12],[e21,e22],[e31,e32],[e41,e42],[e51,e52]]\". All angles must be treated in radians. No physical units other than radians are involved, and no conversions are necessary.",
            "solution": "The problem requires computing the derivative of a product of two functions, $\\partial_x(uv)$, using spectral methods and comparing a naive approach with a de-aliased one.\n\n**1. Analytical Ground Truth**\nThe exact derivative is found using the product rule, providing a baseline for accuracy assessment:\n$$\n\\partial_x (u v) = (\\partial_x u) v + u (\\partial_x v)\n$$\nFor $u(x) = \\sin(ax)$ and $v(x) = \\cos(bx)$, this yields:\n$$\n\\partial_x (\\sin(ax)\\cos(bx)) = a\\cos(ax)\\cos(bx) - b\\sin(ax)\\sin(bx)\n$$\nThis continuous function is evaluated on the grid to provide the exact discrete solution.\n\n**2. Non-De-aliased Spectral Method**\nThis approach computes the product in physical space and then differentiates the result in Fourier space.\n1.  Form the product pointwise on the $N$-point grid: $w_j = u(x_j)v(x_j)$.\n2.  Compute the Discrete Fourier Transform (DFT) of $w_j$ to get its spectrum, $\\hat{w}_k$.\n3.  In Fourier space, differentiation is multiplication by $\\mathrm{i}k$, where $k$ are the integer wavenumbers. Compute the derivative's spectrum: $\\widehat{\\partial_x w}_k = \\mathrm{i}k \\hat{w}_k$.\n4.  Compute the Inverse DFT (IDFT) to get the derivative $(\\partial_x w)_j$ in physical space.\n\nThe product of two trigonometric functions $\\sin(ax)$ and $\\cos(bx)$ creates new frequencies at the sum and difference of the original frequencies, $a \\pm b$. If $|a+b|$ exceeds the Nyquist frequency $N/2$, the resulting high-frequency component is \"aliased\"—misrepresented as a lower frequency on the grid—which introduces a significant error into the computed derivative.\n\n**3. De-aliased Spectral Method (Two-Thirds Rule)**\nTo prevent aliasing, the product must be computed on a finer grid that can resolve the high-frequency content. The two-thirds rule, implemented here via zero-padding to a grid of size $M = 3N/2$, achieves this.\n1.  Compute the DFTs of $u$ and $v$ individually, yielding $\\hat{u}_k$ and $\\hat{v}_k$.\n2.  \"Pad\" these spectra with zeros to create new spectra of length $M$. The original coefficients are placed at the corresponding low-frequency locations in the larger arrays. This must be accompanied by a scaling factor of $M/N$ to ensure the inverse transform yields the correctly interpolated function on the finer grid.\n3.  Perform an IDFT on the padded, scaled spectra to obtain $u$ and $v$ on the $M$-point grid.\n4.  Compute the product pointwise on this finer grid: $w_{padded, j} = u_{padded, j} v_{padded, j}$. Since $M$ is large enough, this product is not aliased.\n5.  Compute the DFT of $w_{padded, j}$ to get its spectrum $\\hat{w}_{padded, k}$.\n6.  Differentiate in the $M$-dimensional Fourier space by multiplying by $\\mathrm{i}k$ (using wavenumbers for the $M$-grid).\n7.  \"Truncate\" the resulting spectrum by extracting only the first $N$ frequency components (in DFT order). This is accompanied by an inverse scaling factor of $N/M$.\n8.  Perform an IDFT on this truncated, scaled spectrum to obtain the final de-aliased derivative on the original $N$-point grid.\n\nThe relative $\\ell^2$ error metric then quantifies the improvement gained by the de-aliasing procedure, especially in cases where the naive method suffers from significant aliasing.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spectral differentiation problem for a suite of test cases.\n    \"\"\"\n\n    def compute_errors(N, a, b):\n        \"\"\"\n        Computes the derivative of u(x)v(x) and its error for a given (N, a, b).\n\n        Args:\n            N (int): Number of grid points.\n            a (int): Wavenumber for sin(ax).\n            b (int): Wavenumber for cos(bx).\n\n        Returns:\n            list: A pair of floats [error_no_dealias, error_dealias].\n        \"\"\"\n        # 1. Grid, functions, and analytical derivative\n        x = 2 * np.pi * np.arange(N) / N\n        u = np.sin(a * x)\n        v = np.cos(b * x)\n        \n        # Exact analytical derivative evaluated on the grid\n        dw_dx_exact = a * np.cos(a * x) * np.cos(b * x) - b * np.sin(a * x) * np.sin(b * x)\n        norm_exact = np.linalg.norm(dw_dx_exact)\n\n        # Handle case where the exact derivative is zero to avoid division by zero.\n        if norm_exact  1e-15:\n            # If the exact derivative is zero, the absolute error is the norm of the computed one.\n            # Relative error is not well-defined, but we can check if the computed is also zero.\n            # For this problem's test cases, norm_exact is never zero.\n            pass\n\n        # 2. Method 1: No De-aliasing\n        w = u * v\n        k_N = np.fft.fftfreq(N) * N\n        dw_dx_hat_no_dealias = 1j * k_N * np.fft.fft(w)\n        dw_dx_no_dealias = np.fft.ifft(dw_dx_hat_no_dealias)\n\n        error_no_dealias = np.linalg.norm(dw_dx_no_dealias.real - dw_dx_exact) / norm_exact\n\n        # 3. Method 2: De-aliasing with 3/2 zero-padding\n        M = 3 * N // 2\n        \n        u_hat = np.fft.fft(u)\n        v_hat = np.fft.fft(v)\n        \n        # Padded spectra\n        u_hat_padded = np.zeros(M, dtype=np.complex128)\n        v_hat_padded = np.zeros(M, dtype=np.complex128)\n        \n        # Slicing indices for even N\n        # Positive frequencies (and zero) go at the beginning.\n        # Negative frequencies (including Nyquist) go at the end.\n        n_pos_freqs = N // 2\n        \n        # Copy positive frequencies\n        u_hat_padded[:n_pos_freqs] = u_hat[:n_pos_freqs]\n        v_hat_padded[:n_pos_freqs] = v_hat[:n_pos_freqs]\n\n        # Copy negative frequencies\n        u_hat_padded[M - (N - n_pos_freqs):] = u_hat[n_pos_freqs:]\n        v_hat_padded[M - (N - n_pos_freqs):] = v_hat[n_pos_freqs:]\n        \n        # Scale for IFFT to finer grid\n        u_hat_padded *= M / N\n        v_hat_padded *= M / N\n        \n        # Transform to fine grid, multiply, and transform back\n        u_padded = np.fft.ifft(u_hat_padded)\n        v_padded = np.fft.ifft(v_hat_padded)\n        w_padded = u_padded * v_padded\n        w_padded_hat = np.fft.fft(w_padded)\n        \n        # Differentiate in padded Fourier space\n        k_M = np.fft.fftfreq(M) * M\n        dw_dx_padded_hat = 1j * k_M * w_padded_hat\n        \n        # Truncate spectrum back to size N\n        dw_dx_hat_dealias = np.zeros(N, dtype=np.complex128)\n        dw_dx_hat_dealias[:n_pos_freqs] = dw_dx_padded_hat[:n_pos_freqs]\n        dw_dx_hat_dealias[n_pos_freqs:] = dw_dx_padded_hat[M - (N - n_pos_freqs):]\n\n        # Scale for IFFT to original grid\n        dw_dx_hat_dealias *= N / M\n        \n        dw_dx_dealias = np.fft.ifft(dw_dx_hat_dealias)\n        \n        error_dealias = np.linalg.norm(dw_dx_dealias.real - dw_dx_exact) / norm_exact\n        \n        return [error_no_dealias, error_dealias]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (16, 3, 4),   # Case 1\n        (16, 7, 7),   # Case 2\n        (32, 12, 13), # Case 3\n        (32, 15, 17), # Case 4\n        (24, 8, 10),  # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        N, a, b = case\n        errors = compute_errors(N, a, b)\n        results.append(errors)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists is very close.\n    # We just need to remove spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "While spectral methods offer exceptional accuracy for smooth functions, their performance degrades in the presence of discontinuities, leading to the persistent Gibbs phenomenon. This hands-on practice  explores this limitation by differentiating a piecewise constant function, allowing you to observe the resulting oscillations. You will then implement and apply a modal filter to suppress these spurious oscillations, learning a vital technique for improving the quality of spectral solutions for non-smooth data.",
            "id": "3417221",
            "problem": "Consider the periodic interval $[0,2\\pi)$ with angles measured in radians. Let $f(x)$ be the piecewise constant function with a single jump at $x=\\pi$ defined by\n$$\nf(x)=\\begin{cases}\n1,  x\\in[0,\\pi),\\\\\n0,  x\\in[\\pi,2\\pi).\n\\end{cases}\n$$\nOn an equispaced grid of $N$ points $x_j=\\frac{2\\pi j}{N}$ for $j=0,1,\\dots,N-1$, you will approximate the spectral derivative of $f$ using the Discrete Fourier Transform computed via the Fast Fourier Transform (FFT), leveraging the fundamental property that differentiation in physical space corresponds to multiplication by the wavenumber in transform space. Specifically, implement the following two variants.\n1. An unfiltered spectral derivative obtained by transforming $f$ to Fourier space, multiplying each modal coefficient by the wavenumber factor corresponding to differentiation with respect to $x$, and transforming back to physical space.\n2. A filtered spectral derivative obtained by applying an exponential modal filter in Fourier space to the differentiated modal coefficients. The filter is defined by\n$$\n\\sigma(k) = \\exp\\left(-\\left(\\alpha \\left(\\frac{|k|}{k_{\\max}}\\right)^p\\right)\\right),\n$$\nwhere $k$ is the integer wavenumber, $k_{\\max}=\\frac{N}{2}$, $p$ is a positive even integer (the filter order), and $\\alpha0$ is a user-specified constant. Set the Nyquist mode (i.e., the mode with $|k|=k_{\\max}$ when $N$ is even) to zero in the differentiation step to avoid ambiguity in representing that mode’s derivative on the grid.\n\nDefine the periodic distance from a point $x$ to the jump location $x=\\pi$ as\n$$\nd(x,\\pi) = \\min\\left(|x-\\pi|,\\, 2\\pi-|x-\\pi|\\right).\n$$\nFor a given exclusion half-width $\\varepsilon\\in(0,\\pi)$, define the exterior set of grid points\n$$\nS_\\varepsilon = \\left\\{x_j:\\ d(x_j,\\pi)\\ge \\varepsilon\\right\\}.\n$$\nQuantify the Gibbs-type overshoot amplitude and the $L^2$-norm of the approximate derivative away from the jump by the following two metrics computed over $S_\\varepsilon$:\n- Overshoot amplitude $O = \\max_{x_j\\in S_\\varepsilon}\\left|g(x_j)\\right|$, where $g$ is the approximate derivative.\n- Discrete $L^2$ norm $E = \\left(\\sum_{x_j\\in S_\\varepsilon} |g(x_j)|^2\\,\\Delta x\\right)^{1/2}$ with $\\Delta x=\\frac{2\\pi}{N}$.\n\nFor each test case below, compute:\n- The overshoot reduction ratio $R = \\dfrac{O_{\\mathrm{filtered}}}{O_{\\mathrm{unfiltered}}}$.\n- The unfiltered $L^2$ norm $E_{\\mathrm{unfiltered}}$ over $S_\\varepsilon$.\n- The filtered $L^2$ norm $E_{\\mathrm{filtered}}$ over $S_\\varepsilon$.\n\nUse the following test suite of parameters $(N,p,\\alpha,\\varepsilon)$:\n- $(N,p,\\alpha,\\varepsilon)=(32,8,36,0.3)$,\n- $(N,p,\\alpha,\\varepsilon)=(128,8,36,0.2)$,\n- $(N,p,\\alpha,\\varepsilon)=(256,16,36,0.15)$,\n- $(N,p,\\alpha,\\varepsilon)=(256,4,18,0.15)$.\n\nYour program must:\n- Construct $f$ on the grid for each $N$.\n- Compute the unfiltered and filtered spectral derivatives using the Fourier differentiation property described above and the specified exponential filter.\n- Compute $R$, $E_{\\mathrm{unfiltered}}$, and $E_{\\mathrm{filtered}}$ for each test case using the definitions above, with all angles in radians.\n- Produce a single line of output containing a flat list of floating-point results in the order\n$$\n\\left[R_1,\\,E_{\\mathrm{unfiltered},1},\\,E_{\\mathrm{filtered},1},\\,R_2,\\,E_{\\mathrm{unfiltered},2},\\,E_{\\mathrm{filtered},2},\\,R_3,\\,E_{\\mathrm{unfiltered},3},\\,E_{\\mathrm{filtered},3},\\,R_4,\\,E_{\\mathrm{unfiltered},4},\\,E_{\\mathrm{filtered},4}\\right].\n$$\nThe line must be formatted exactly as a Python list with comma-separated values and enclosed in square brackets. All answers are dimensionless and must be reported as floating-point numbers.\n\nThe test suite is designed to cover a low-resolution case ($N=32$), two higher-resolution cases ($N=128$ and $N=256$), and a comparison of stronger versus weaker filters (different $p$ and $\\alpha$) to assess overshoot reduction and $L^2$ convergence away from the jump.",
            "solution": "The fundamental basis is the Fourier representation of periodic functions and the well-tested property that differentiation in physical space corresponds to multiplication by the imaginary unit times the wavenumber in Fourier space. Let $f(x)$ be $2\\pi$-periodic with Fourier series\n$$f(x)=\\sum_{k\\in\\mathbb{Z}} c_k e^{i k x},$$\nwith $x\\in[0,2\\pi)$. Then the derivative is\n$$f'(x)=\\sum_{k\\in\\mathbb{Z}} (i k) c_k e^{i k x}.$$\nFor equispaced nodes $x_j=\\frac{2\\pi j}{N}$, sampling the Fourier series and applying the Discrete Fourier Transform (DFT) maps the samples $\\{f(x_j)\\}$ to modal coefficients proportional to $\\{c_k\\}$, and the inverse DFT maps modal coefficients back to nodal values. Therefore, a spectral differentiation algorithm on the grid proceeds by:\n1. Computing the DFT $\\{F_k\\}$ of $\\{f(x_j)\\}$ using the Fast Fourier Transform (FFT) algorithm.\n2. Multiplying each mode by the factor $i k$ to represent differentiation with respect to $x$ (with the convention that the Nyquist mode $|k|=k_{\\max}=\\frac{N}{2}$ for even $N$ is set to zero to avoid ambiguity in representing its derivative on the grid).\n3. Applying the inverse DFT to return to physical space values $\\{g(x_j)\\}$ that approximate $f'(x)$ spectrally.\n\nBecause the given function $f$ is piecewise constant with a single jump discontinuity, the exact derivative in the distributional sense is a Dirac delta at the jump location $x=\\pi$ scaled by the jump magnitude, and $0$ elsewhere. The Dirac delta is not in the square-integrable space $L^2([0,2\\pi])$, so classical global $L^2$ convergence of $g$ to $f'$ is not meaningful over the full domain. However, away from the jump, where $f$ is smooth (in fact constant), spectral differentiation should approximate the exact derivative $0$ and hence should converge to $0$ in the $L^2$ norm over any fixed subdomain that excludes a neighborhood of the jump. To measure this, we define an exclusion region around $x=\\pi$ of half-width $\\varepsilon$ and evaluate the discrete $L^2$ norm of $g$ over the complement $S_\\varepsilon$.\n\nGibbs-type oscillations arise due to the jump and manifest as non-zero oscillatory behavior of the spectral derivative away from the jump. Modal filtering reduces these oscillations by damping high-wavenumber modes. An exponential filter of order $p$ with strength $\\alpha$ is applied to the differentiated modal coefficients $\\{D_k\\}$, with\n$$\\sigma(k)=\\exp\\left(-\\left(\\alpha\\left(\\frac{|k|}{k_{\\max}}\\right)^p\\right)\\right),$$\n$$D^{(\\mathrm{filtered})}_k=\\sigma(k) D_k,$$\nwhere $k_{\\max}=\\frac{N}{2}$. This preserves low modes while exponentially damping the high modes that primarily cause Gibbs oscillations, thereby reducing overshoot and the $L^2$ norm away from the jump.\n\nAlgorithmic design:\n- Grid and function: For each $N$, construct $x_j=\\frac{2\\pi j}{N}$ for $j=0,\\dots,N-1$, and set $f(x_j)=1$ for $x_j\\in[0,\\pi)$ and $f(x_j)=0$ for $x_j\\in[\\pi,2\\pi)$.\n- Wavenumbers: Use the standard DFT ordering of wavenumbers $k\\in\\{0,1,\\dots,\\frac{N}{2},-\\frac{N}{2}+1,\\dots,-1\\}$ provided by the frequency utility, or equivalently by scaling the normalized DFT frequencies by $N$. Set the derivative factor for the Nyquist mode $k=\\pm \\frac{N}{2}$ to $0$.\n- Unfiltered derivative: Compute $F_k=\\mathrm{FFT}(f)$, form $D_k=(i k)F_k$ with the Nyquist treatment above, and set $g_{\\mathrm{unfiltered}}(x_j)=\\mathrm{Re}\\left(\\mathrm{IFFT}(D_k)\\right)$.\n- Filtered derivative: Apply the exponential filter $\\sigma(k)$ to $D_k$ to obtain $D^{(\\mathrm{filtered})}_k=\\sigma(k) D_k$, then compute $g_{\\mathrm{filtered}}(x_j)=\\mathrm{Re}\\left(\\mathrm{IFFT}(D^{(\\mathrm{filtered})}_k)\\right)$.\n- Metrics away from the jump: Define the periodic distance $d(x,\\pi)=\\min(|x-\\pi|,2\\pi-|x-\\pi|)$ and the exterior set $S_\\varepsilon=\\{x_j:\\ d(x_j,\\pi)\\ge \\varepsilon\\}$. With $\\Delta x=\\frac{2\\pi}{N}$, compute:\n  - $O_{\\mathrm{unfiltered}}=\\max_{x_j\\in S_\\varepsilon} |g_{\\mathrm{unfiltered}}(x_j)|$,\n  - $O_{\\mathrm{filtered}}=\\max_{x_j\\in S_\\varepsilon} |g_{\\mathrm{filtered}}(x_j)|$,\n  - $E_{\\mathrm{unfiltered}}=\\left(\\sum_{x_j\\in S_\\varepsilon} |g_{\\mathrm{unfiltered}}(x_j)|^2\\,\\Delta x\\right)^{1/2}$,\n  - $E_{\\mathrm{filtered}}=\\left(\\sum_{x_j\\in S_\\varepsilon} |g_{\\mathrm{filtered}}(x_j)|^2\\,\\Delta x\\right)^{1/2}$,\n  - $R=\\frac{O_{\\mathrm{filtered}}}{O_{\\mathrm{unfiltered}}}$ (define $R=0$ if $O_{\\mathrm{unfiltered}}=0$).\n- Numerical complexity: Each FFT and inverse FFT has complexity $\\mathcal{O}(N\\log N)$, and the operations are vectorized. For the test suite, the total cost is modest.\n\nExpected behavior:\n- For fixed $\\varepsilon$, as $N$ increases, both $E_{\\mathrm{unfiltered}}$ and $E_{\\mathrm{filtered}}$ over $S_\\varepsilon$ should decrease because the spectral derivative better resolves the constant regions away from the jump. The filtered version typically achieves smaller overshoot and $L^2$ error than the unfiltered, so $R$ should be less than $1$, and $E_{\\mathrm{filtered}}E_{\\mathrm{unfiltered}}$ in most cases. Stronger filters (larger $p$ and/or $\\alpha$) usually yield stronger damping and thus smaller overshoot, but may also broaden the effective smoothing near the jump.\n\nThe program implements these steps exactly and outputs a flat Python list containing, for each test case in the given order, the overshoot reduction ratio $R$, the unfiltered $L^2$ norm over $S_\\varepsilon$, and the filtered $L^2$ norm over $S_\\varepsilon$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef periodic_distance(x, a, L=2*np.pi):\n    # Compute periodic distance on [0,L)\n    d = np.abs(x - a)\n    return np.minimum(d, L - d)\n\ndef spectral_derivative(values):\n    \"\"\"\n    Compute unfiltered spectral derivative on equispaced grid over [0, 2pi).\n    values: array of f(x_j) samples, length N.\n    Returns real-valued derivative approximation g(x_j).\n    \"\"\"\n    N = values.size\n    F = np.fft.fft(values)\n    # Integer wavenumbers in FFT ordering\n    k = np.fft.fftfreq(N) * N  # yields [0,1,2,...,N/2,-N/2+1,...,-1]\n    # Handle Nyquist mode for even N by zeroing its derivative\n    k = k.astype(float)\n    if N % 2 == 0:\n        k[int(N//2)] = 0.0\n    D = 1j * k * F\n    g = np.fft.ifft(D).real\n    return g\n\ndef filtered_spectral_derivative(values, p, alpha):\n    \"\"\"\n    Compute filtered spectral derivative using an exponential modal filter\n    applied to the differentiated modal coefficients.\n    p: even integer filter order\n    alpha: positive filter strength\n    \"\"\"\n    N = values.size\n    F = np.fft.fft(values)\n    k = np.fft.fftfreq(N) * N\n    k = k.astype(float)\n    if N % 2 == 0:\n        k[int(N//2)] = 0.0\n    # Differentiate in spectral space\n    D = 1j * k * F\n    # Exponential filter\n    kmax = N / 2.0\n    # Avoid division by zero at k=0\n    ksi = np.abs(k) / kmax\n    sigma = np.exp(- (alpha * (ksi ** p)))\n    # Ensure exact preservation of mean mode\n    sigma[0] = 1.0\n    Df = sigma * D\n    g = np.fft.ifft(Df).real\n    return g\n\ndef compute_metrics(N, p, alpha, eps):\n    \"\"\"\n    For given parameters, build f, compute unfiltered and filtered derivatives,\n    and compute overshoot reduction ratio and L2 norms over S_eps.\n    Returns (R, E_unf, E_fil).\n    \"\"\"\n    # Grid\n    x = np.linspace(0.0, 2*np.pi, N, endpoint=False)\n    dx = 2*np.pi / N\n    # Piecewise constant f\n    f = np.where(x  np.pi, 1.0, 0.0)\n    # Derivatives\n    g_unf = spectral_derivative(f)\n    g_fil = filtered_spectral_derivative(f, p=p, alpha=alpha)\n    # Exterior set S_eps\n    dist = periodic_distance(x, np.pi, L=2*np.pi)\n    mask = dist >= eps\n    if not np.any(mask):\n        # Degenerate case: no points outside exclusion\n        return (0.0, 0.0, 0.0)\n    # Overshoot amplitudes\n    O_unf = float(np.max(np.abs(g_unf[mask])))\n    O_fil = float(np.max(np.abs(g_fil[mask])))\n    R = 0.0 if O_unf == 0.0 else (O_fil / O_unf)\n    # Discrete L2 norms over S_eps\n    E_unf = float(np.sqrt(np.sum(np.abs(g_unf[mask])**2) * dx))\n    E_fil = float(np.sqrt(np.sum(np.abs(g_fil[mask])**2) * dx))\n    return (R, E_unf, E_fil)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, p, alpha, epsilon)\n    test_cases = [\n        (32, 8, 36.0, 0.3),\n        (128, 8, 36.0, 0.2),\n        (256, 16, 36.0, 0.15),\n        (256, 4, 18.0, 0.15),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, p, alpha, eps = case\n        R, E_unf, E_fil = compute_metrics(N, p, alpha, eps)\n        results.extend([R, E_unf, E_fil])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}