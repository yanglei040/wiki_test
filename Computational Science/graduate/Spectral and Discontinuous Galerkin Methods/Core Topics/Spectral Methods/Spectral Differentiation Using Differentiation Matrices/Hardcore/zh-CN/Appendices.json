{
    "hands_on_practices": [
        {
            "introduction": "谱方法的核心优势在于其“谱精度”。对于那些能够被计算网格完全解析的函数（即，其波数低于奈奎斯特极限的三角多项式），傅里叶谱微分不仅仅是一种近似，而是精确的。本练习提供了一个具体的例子，让您亲手验证这一基本原则，从而深刻理解谱方法为何在处理光滑周期函数时如此强大。",
            "id": "3417589",
            "problem": "考虑周期区间 $[0,2\\pi]$ 以及具有 $N=8$ 个节点的等距网格 $x_{j}=\\frac{2\\pi j}{N}$，其中 $j=0,1,\\dots,7$。设节点值为 $u_{j}=\\sin(x_{j})+\\frac{1}{2}\\cos(3x_{j})$。角度以弧度为单位。在傅里叶谱方法中，一阶微分矩阵 $D$ 是作用于节点值上的线性算子，其作用定义为：通过离散三角展开表示周期函数在网格节点上的值，并在谱（频率）域中应用与微分相对应的适当运算。仅使用此表示方法以及物理空间中的微分与谱空间中运算的对应关系，执行以下操作：\n\n1. 构造傅里叶谱微分矩阵 $D$ 对向量 $u=\\{u_{j}\\}_{j=0}^{7}$ 的作用，并计算在各节点上的 $Du$。\n2. 推导基函数 $u(x)=\\sin(x)+\\frac{1}{2}\\cos(3x)$ 的精确导数 $u^{\\prime}(x)$，并计算其在各节点上的值 $u^{\\prime}(x_{j})$。\n3. 根据等距周期网格上离散傅里叶表示的第一性原理，论证对于此处的 $N$ 和 $u(x)$，$Du$ 是否必然与 $\\{u^{\\prime}(x_{j})\\}_{j=0}^{7}$ 一致。\n4. 定义离散无穷范数误差 $E=\\max_{0\\leq j\\leq 7}\\left| (Du)_{j}-u^{\\prime}(x_{j}) \\right|$ 并计算 $E$。\n\n将 $E$ 的值作为最终答案报告。如果需要数值近似，题目会给出保留特定有效数字的说明；但对于本题，请提供作为实数的精确值。",
            "solution": "本题要求分析傅里叶谱微分法应用于特定函数在等距网格上的情况。我们必须验证该问题，若问题有效，则遵循四个指定步骤进行求解，并报告最终的误差值。\n\n首先，验证问题。\n**提取的已知条件：**\n- 域：周期区间 $[0, 2\\pi]$。\n- 网格：$N=8$ 个等距节点 $x_{j}=\\frac{2\\pi j}{N}$，其中 $j=0,1,\\dots,7$。\n- 节点值：$u_{j}=\\sin(x_{j})+\\frac{1}{2}\\cos(3x_{j})$。\n- 基函数：$u(x)=\\sin(x)+\\frac{1}{2}\\cos(3x)$。\n- 算子：一阶傅里叶谱微分矩阵 $D$。\n- 任务1：计算 $D$ 对节点值向量的作用 $Du$。\n- 任务2：计算节点上的精确导数 $u^{\\prime}(x_j)$。\n- 任务3：论证任务1和任务2的结果是否一致。\n- 任务4：计算离散无穷范数误差 $E=\\max_{0\\leq j\\leq 7}\\left| (Du)_{j}-u^{\\prime}(x_{j}) \\right|$。\n\n**验证结论：**\n该问题具有科学依据、适定且客观。它是数值分析领域的标准问题，具体涉及谱方法。所使用的概念，如离散傅里叶变换（DFT）、谱微分和混叠，是该领域的基础。问题是自洽的，提供了得到唯一解所需的所有信息（$N$、$u(x)$、网格定义）。不存在矛盾、歧义或违反科学原理之处。该问题被判定为**有效**。我们继续求解。\n\n解决方案是通过依次解决问题陈述的四个部分来构建的。\n\n**1. 构造傅里叶谱微分矩阵 $D$ 对 $u$ 的作用。**\n\n傅里叶谱微分算子的作用是在频域中定义的。首先，函数 $u(x)$ 由其傅里叶级数表示。我们使用复指数来表示 $u(x)$：\n$$u(x) = \\sin(x) + \\frac{1}{2}\\cos(3x) = \\frac{e^{ix} - e^{-ix}}{2i} + \\frac{1}{2}\\left(\\frac{e^{i3x} + e^{-i3x}}{2}\\right)$$\n$$u(x) = -\\frac{i}{2}e^{ix} + \\frac{i}{2}e^{-ix} + \\frac{1}{4}e^{i3x} + \\frac{1}{4}e^{-i3x}$$\n这是 $u(x)$ 的连续傅里叶级数表示，它是一个三角多项式。在展开式 $u(x) = \\sum_{k=-\\infty}^{\\infty} c_k e^{ikx}$ 中，非零的傅里叶系数 $c_k$ 为：\n$$c_1 = -\\frac{i}{2}, \\quad c_{-1} = \\frac{i}{2}, \\quad c_3 = \\frac{1}{4}, \\quad c_{-3} = \\frac{1}{4}$$\n所有其他系数 $c_k$ 均为零。\n\n离散值 $u_j = u(x_j)$ 是在 $N=8$ 个点的网格上采样的。$u(x)$ 中存在的最高波数大小为 $k_{max}=3$。对于一个 $N$ 点网格，周期函数的奈奎斯特-香农采样定理表明，如果一个三角多项式的最大波数大小 $k_{max}$ 满足 $|k_{max}| < N/2$，那么它就能被完美解析（即不发生混叠）。\n在我们的例子中，$N=8$，因此 $N/2 = 4$。条件是 $3 < 4$，成立。因此，函数 $u(x)$ 在网格 $\\{x_j\\}$ 上不发生混叠。无混叠确保了从节点值 $\\{u_j\\}$ 计算出的离散傅里叶系数 $\\hat{u}_k$ 与所有可分辨波数的连续傅里叶系数 $c_k$ 完全相同。\n\n谱微分对应于将傅里叶系数 $\\hat{u}_k$ 乘以 $ik$。设 $v(x)$ 是对 $u(x)$ 进行谱微分得到的函数。其傅里叶系数 $\\hat{v}_k$ 由 $\\hat{v}_k = ik\\hat{u}_k$ 给出。使用 $u(x)$ 的系数：\n$$\\hat{v}_1 = i(1)\\hat{u}_1 = i\\left(-\\frac{i}{2}\\right) = \\frac{1}{2}$$\n$$\\hat{v}_{-1} = i(-1)\\hat{u}_{-1} = (-i)\\left(\\frac{i}{2}\\right) = \\frac{1}{2}$$\n$$\\hat{v}_3 = i(3)\\hat{u}_3 = 3i\\left(\\frac{1}{4}\\right) = \\frac{3i}{4}$$\n$$\\hat{v}_{-3} = i(-3)\\hat{u}_{-3} = -3i\\left(\\frac{1}{4}\\right) = -\\frac{3i}{4}$$\n所有其他系数 $\\hat{v}_k$ 均为零。\n\n在网格点上的谱微分函数值，我们记为 $(Du)_j$，是通过傅里叶逆变换得到的：\n$$(Du)_j = v(x_j) = \\sum_{k} \\hat{v}_k e^{ikx_j}$$\n$$(Du)_j = \\hat{v}_{-3}e^{-i3x_j} + \\hat{v}_{-1}e^{-ix_j} + \\hat{v}_{1}e^{ix_j} + \\hat{v}_{3}e^{i3x_j}$$\n$$(Du)_j = \\left(-\\frac{3i}{4}\\right)e^{-i3x_j} + \\left(\\frac{1}{2}\\right)e^{-ix_j} + \\left(\\frac{1}{2}\\right)e^{ix_j} + \\left(\\frac{3i}{4}\\right)e^{i3x_j}$$\n合并各项：\n$$(Du)_j = \\frac{1}{2}\\left(e^{ix_j} + e^{-ix_j}\\right) + \\frac{3i}{4}\\left(e^{i3x_j} - e^{-i3x_j}\\right)$$\n使用欧拉公式 $2\\cos(\\theta) = e^{i\\theta} + e^{-i\\theta}$ 和 $2i\\sin(\\theta) = e^{i\\theta} - e^{-i\\theta}$：\n$$(Du)_j = \\cos(x_j) + \\frac{3i}{4}(2i\\sin(3x_j))$$\n$$(Du)_j = \\cos(x_j) - \\frac{3}{2}\\sin(3x_j)$$\n\n**2. 推导精确导数 $u^{\\prime}(x)$ 并计算其在节点上的值。**\n\n基函数是 $u(x) = \\sin(x) + \\frac{1}{2}\\cos(3x)$。我们使用标准微积分法则计算它关于 $x$ 的一阶导数：\n$$u^{\\prime}(x) = \\frac{d}{dx}\\left(\\sin(x) + \\frac{1}{2}\\cos(3x)\\right)$$\n$$u^{\\prime}(x) = \\frac{d}{dx}(\\sin(x)) + \\frac{1}{2}\\frac{d}{dx}(\\cos(3x))$$\n$$u^{\\prime}(x) = \\cos(x) + \\frac{1}{2}(-\\sin(3x) \\cdot 3)$$\n$$u^{\\prime}(x) = \\cos(x) - \\frac{3}{2}\\sin(3x)$$\n计算这个精确导数在网格节点 $x_j$ 上的值：\n$$u^{\\prime}(x_j) = \\cos(x_j) - \\frac{3}{2}\\sin(3x_j)$$\n\n**3. 论证 $(Du)_j$ 和 $u^{\\prime}(x_j)$ 的一致性。**\n\n从第1部分，我们得到 $(Du)_j = \\cos(x_j) - \\frac{3}{2}\\sin(3x_j)$。\n从第2部分，我们得到 $u^{\\prime}(x_j) = \\cos(x_j) - \\frac{3}{2}\\sin(3x_j)$。\n显然，对于所有 $j=0, 1, \\dots, 7$，都有 $(Du)_j = u^{\\prime}(x_j)$。\n\n从第一性原理出发的论证基于傅里叶谱方法的性质。对于任何其波数能被网格完全解析的三角多项式函数，该方法都是精确的。\n函数 $u(x)=\\sin(x)+\\frac{1}{2}\\cos(3x)$ 是一个三角多项式，其最高波数大小为 $k_{max}=3$。\n网格包含 $N=8$ 个点。周期信号的采样定理指出，所有波数大小 $|k| < N/2$ 的频率分量都可以被唯一表示。对于偶数 $N$，这个条件确保不发生混叠。\n在本题中，$N/2=4$。条件是 $|k_{max}| < 4$，即 $3<4$。此条件得到满足。\n由于没有混叠，采样值 $\\{u_j\\}$ 的离散傅里叶变换产生的离散傅里叶系数 $\\hat{u}_k$ 与函数 $u(x)$ 的连续傅里叶级数系数 $c_k$ 完全相等（在相关 $k$ 的范围内）。\n$u(x) = \\sum_k c_k e^{ikx}$ 的解析微分得到 $u'(x) = \\sum_k (ik c_k) e^{ikx}$。\n数值谱微分过程计算 $\\hat{v}_k = ik \\hat{u}_k = ik c_k$，然后通过逆变换重构导数，得到 $\\sum_k (ik c_k) e^{ikx_j}$。\n由于谱系数是精确的，在网格点上重构的导数与在这些相同点上计算的精确导数是相同的。因此，$(Du)_j$ 必须与 $u^{\\prime}(x_j)$ 一致。\n\n**4. 计算误差 $E$。**\n\n离散无穷范数误差定义为：\n$$E = \\max_{0\\leq j\\leq 7}\\left| (Du)_{j}-u^{\\prime}(x_{j}) \\right|$$\n正如第3部分所证，对于这个特定的函数和网格，谱导数和精确导数在每个网格节点上都是相同的。\n因此，对于每个 $j \\in \\{0, 1, \\dots, 7\\}$：\n$$(Du)_j - u^{\\prime}(x_j) = 0$$\n这个差的绝对值也为零：\n$$\\left| (Du)_{j}-u^{\\prime}(x_{j}) \\right| = 0$$\n一组零的最大值是零。\n$$E = \\max \\{0, 0, 0, 0, 0, 0, 0, 0\\} = 0$$\n误差恰好为 $0$。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "尽管谱方法对光滑函数极为精确，但其全局逼近的特性在处理含间断点的函数时会遇到挑战。在间断点附近，多项式插值会产生过冲，导致整个计算域出现伪振荡，即“吉布斯现象”，这会严重污染导数的计算结果。本实践将展示这一现象，并引入谱滤波作为一种强大的技术来抑制这些振荡，从而恢复在远离间断点区域的计算精度。",
            "id": "3417608",
            "problem": "设计并实现一个程序，该程序基于 Chebyshev–Lobatto 配点法构建谱微分，并研究当对节点值应用指数滤波器时，Gibbs 振荡对一个带有跳跃间断点的函数求导的影响。您的程序必须以数学上严谨的方式执行以下任务，并为指定的测试套件报告定量结果。\n\n从以下基本概念出发：\n- 在不同节点上使用 Lagrange 基多项式 $\\ell_j(x)$，$0 \\le j \\le N$ 进行 Lagrange 形式的多项式插值，定义插值多项式 $p_N(x)$ 在节点 $x_i$ 处满足 $p_N(x_i) = f(x_i)$。\n- 与节点 $\\{x_j\\}_{j=0}^N$ 相关的微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 定义为 $D_{ij} = \\ell_j'(x_i)$，因此对于任何节点数据向量 $\\mathbf{f} = \\bigl(f(x_0),\\dots,f(x_N)\\bigr)^\\top$，插值多项式在节点处的导数由 $\\mathbf{p}_N'(x_i) = \\sum_{j=0}^N D_{ij} f(x_j)$ 给出。\n- $[-1,1]$ 上的 Chebyshev–Lobatto 节点为 $x_j = \\cos\\!\\left(\\frac{\\pi j}{N}\\right)$，其中 $0 \\le j \\le N$。\n- Chebyshev–Lobatto 节点的重心权重为 $\\lambda_j = (-1)^j \\nu_j$，其中 $\\nu_0 = \\nu_N = \\tfrac{1}{2}$ 且当 $1 \\le j \\le N-1$ 时 $\\nu_j = 1$；对应的 N 次插值多项式 $p_N(x)$ 的重心插值公式为\n$$\np_N(x) = \\frac{\\displaystyle \\sum_{j=0}^N \\frac{\\lambda_j}{x - x_j} f(x_j)}{\\displaystyle \\sum_{j=0}^N \\frac{\\lambda_j}{x - x_j}},\n$$\n该公式在节点处是精确的，并且对于 $x \\notin \\{x_j\\}$ 是稳定的。\n- 作用于 Chebyshev 模态的 p 阶指数滤波器由模态乘子 $\\sigma_k = \\exp\\!\\left(-\\alpha \\bigl(k/N\\bigr)^p\\right)$ 定义，其中 $0 \\le k \\le N$，强度 $\\alpha > 0$ 的选择应使得 $\\sigma_N = \\varepsilon_{\\text{mach}}$，而 $\\varepsilon_{\\text{mach}}$ 是双精度下的机器浮点数精度。滤波操作通过 I 型离散余弦变换（DCT-I）将节点值转换为 Chebyshev 系数，然后乘以 $\\sigma_k$，再通过 I 型离散余弦逆变换转换回节点值。\n\n需要实现的问题任务：\n1. 对每个给定整数 $N \\ge 2$ 的测试用例，构建 $[-1,1]$ 上的 Chebyshev–Lobatto 网格 $\\{x_j\\}_{j=0}^N$ 和由上述 Lagrange 基定义所隐含的规范 Chebyshev–Lobatto 微分矩阵 $D$。\n2. 定义在 $x=0$ 处有跳跃的间断函数如下\n$$\nf(x) = \\begin{cases} -1, & x  0 \\\\ 1,  x \\ge 0 \\end{cases}\n$$\n3. 给定一个候选偶数滤波器阶数 $p \\in \\{2,4,8,16,32\\}$ 以及被解释为“不进行滤波”的基准 $p=0$，使用带有正交归一化的 DCT-I 对 $f(x)$ 的节点值应用 p 阶指数滤波器，以获得滤波后的节点值 $\\tilde{\\mathbf{f}}^{(p)}$。\n4. 使用 $\\tilde{\\mathbf{f}}^{(p)}$ 作为节点数据，定义相应的插值多项式 $\\tilde{p}_N^{(p)}(x)$ 及其导数 $\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x)$。通过导数在远离跳跃点处的 $L^2$ 范数量化微分中的 Gibbs 现象引起的误差，即\n$$\nE_p(N,\\varepsilon) \\;=\\; \\left(\\int_{-1}^{-\\varepsilon} \\left(\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x)\\right)^2 \\, dx \\;+\\; \\int_{\\varepsilon}^{1} \\left(\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x)\\right)^2 \\, dx \\right)^{1/2}.\n$$\n$f(x)$ 的精确导数在 $[-1,0)$ 和 $(0,1]$ 上为零，因此上述量是在间断点周围一个半宽度为 $\\varepsilon$ 的对称排除层之外计算出的导数的 $L^2$ 范数。您必须在两个子区间上分别使用 Q 点（取 $Q=200$）的 Gauss–Legendre 求积法来近似每个积分。\n5. 对每个测试用例，在候选阶数 $\\mathcal{P}=\\{0,2,4,8,16,32\\}$ 中，找到使 $E_p(N,\\varepsilon)$ 最小化的阶数 $p^\\star \\in \\mathcal{P}$。如果目标值在 $10^{-12}$ 的数值容差内出现相同结果，则报告达到最小值的最小的 $p$。\n\n需要遵守的实现细节：\n- 用于求积的一般点上的微分必须是根据滤波后的节点值构建的 N 次插值多项式的微分。您可以通过求重心插值多项式的导数来计算。如果 $S(x) = \\sum_{j=0}^N \\frac{\\lambda_j}{x - x_j}$ 和 $T(x) = \\sum_{j=0}^N \\frac{\\lambda_j}{(x - x_j)^2}$，以及 $\\beta_j(x) = \\frac{\\lambda_j}{x - x_j}$，那么 Lagrange 基的导数满足\n$$\n\\ell_j'(x) \\;=\\; \\frac{\\beta_j(x)}{S(x)^2}\\left(T(x) - \\frac{S(x)}{x - x_j}\\right),\n$$\n因此\n$$\n\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x) \\;=\\; \\sum_{j=0}^N \\tilde{f}^{(p)}_j \\, \\ell_j'(x).\n$$\n- 角度测量使用弧度。不涉及物理单位。\n- 使用编程语言提供的双精度机器浮点数精度 $\\varepsilon_{\\text{mach}}$ 来设置 $\\alpha = -\\ln(\\varepsilon_{\\text{mach}})$。\n\n测试套件：\n- 用例 1：$N=16$，$\\varepsilon = \\frac{3}{N}$。\n- 用例 2：$N=15$，$\\varepsilon = \\frac{3}{N}$。\n- 用例 3：$N=64$，$\\varepsilon = \\frac{6}{N}$。\n- 用例 4：$N=8$，$\\varepsilon = 0.1$。\n\n对每个用例，在 $\\mathcal{P}=\\{0,2,4,8,16,32\\}$ 中搜索并返回最优阶数 $p^\\star$ 和相应的最小误差 $E_{p^\\star}(N,\\varepsilon)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述测试用例的顺序排列，每对结果由整数 $p^\\star$ 及其紧随的浮点数值 $E_{p^\\star}(N,\\varepsilon)$ 组成。例如，输出格式必须为 $[p_1^\\star,E_1,p_2^\\star,E_2,p_3^\\star,E_3,p_4^\\star,E_4]$ 的形式。",
            "solution": "该问题的解决方案涉及设计一个数值算法，以研究指数滤波对间断函数谱微分的影响。任务的核心是量化滤波如何减轻 Gibbs 现象，该现象表现为谱插值间断函数导数中的伪振荡。该方法分解为几个独特且原理清晰的步骤：离散化、滤波、微分、误差计算和优化。\n\n首先，使用一组 $N+1$ 个 Chebyshev–Lobatto 节点对空间域 $[-1, 1]$ 进行离散化，节点定义为 $x_j = \\cos(\\frac{\\pi j}{N})$，其中 $j = 0, 1, \\dots, N$。这些节点是 N 次第一类 Chebyshev 多项式 $T_N(x)$ 的极值点，由于其在边界附近聚集的特性，有助于减轻 Runge 现象，因此特别适合多项式插值。待分析的间断函数由下式给出\n$$\nf(x) = \\begin{cases} -1,  x  0 \\\\ 1,  x \\ge 0 \\end{cases}\n$$\n该函数在 Chebyshev 节点上进行采样，生成节点值向量 $\\mathbf{f} = (f(x_0), f(x_1), \\dots, f(x_N))^\\top$。此向量代表了谱方法物理空间中的函数。\n\n其次，对节点数据应用指数滤波器。这一操作在谱空间或模态空间中进行，该空间通过 I 型离散余弦变换（DCT-I）与物理空间相关联。节点值向量 $\\mathbf{f}$ 使用正交归一化的 DCT-I 变换为 Chebyshev 系数向量 $\\mathbf{a}$。然后，通过将系数与一组乘子 $\\sigma_k$ 进行逐元素相乘来应用滤波器。对于偶数阶滤波器 $p$，这些乘子定义为 $\\sigma_k = \\exp(-\\alpha (k/N)^p)$，其中 $k = 0, 1, \\dots, N$。参数 $\\alpha  0$ 控制滤波器的强度，并设置为 $\\alpha = -\\ln(\\varepsilon_{\\text{mach}})$，其中 $\\varepsilon_{\\text{mach}}$ 是机器浮点数精度。这个选择确保了滤波器能强力衰减最高频模态（对应于 $k=N$），有效地将 $\\sigma_N$ 设置为接近零的值。滤波器阶数 $p$ 控制滤波器的形状：阶数越高，滤波器越平坦，过渡到零时越急剧，从而在积极切断高频模态的同时保留更多低频模态。相乘后，滤波后的系数 $\\tilde{a}_k = \\sigma_k a_k$ 使用 I 型离散余弦逆变换（对于正交归一化变体，它就是 DCT-I 本身）变换回物理空间，产生滤波后的节点值向量 $\\tilde{\\mathbf{f}}^{(p)}$。$p=0$ 的情况对应于所有 $k$ 的 $\\sigma_k=1$，即不应用滤波。\n\n第三，必须计算与滤波后节点值相对应的插值多项式 $\\tilde{p}_N^{(p)}$ 的导数。虽然可以构建一个微分矩阵 $D$，但通过对重心插值公式求导，可以更精确、更稳定地在任意点（求积所需）上计算导数值。通过滤波后数据 $\\{ (x_j, \\tilde{f}^{(p)}_j) \\}_{j=0}^N$ 的 N 次多项式插值由下式给出\n$$\n\\tilde{p}_N^{(p)}(x) = \\frac{\\displaystyle\\sum_{j=0}^{N} \\frac{\\lambda_j}{x - x_j} \\tilde{f}^{(p)}_j}{\\displaystyle\\sum_{k=0}^{N} \\frac{\\lambda_k}{x - x_k}},\n$$\n其中 $\\lambda_j$ 是 Chebyshev-Lobatto 节点的重心权重：$\\lambda_j = (-1)^j \\nu_j$，其中 $\\nu_0 = \\nu_N = \\frac{1}{2}$ 且当 $1 \\le j \\le N-1$ 时 $\\nu_j = 1$。通过应用商法则，该插值多项式的导数可以表示为一个数值稳定的形式：\n$$\n\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x) = \\frac{1}{\\sum_{k=0}^{N} \\frac{\\lambda_k}{x-x_k}} \\sum_{j=0}^{N} \\frac{\\lambda_j}{(x-x_j)^2} \\left( \\tilde{p}_N^{(p)}(x) - \\tilde{f}^{(p)}_j \\right).\n$$\n此公式用于计算在任何不与节点重合的点 $x$ 处的导数。\n\n第四，量化导数中由 Gibbs 振荡引起的误差。$f(x)$ 的真实导数除了在 $x=0$ 处是一个 Dirac δ 函数外，在其他地方都为零。计算出的导数 $\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x)$ 在排除跳跃点周围的小区间 $[-\\varepsilon, \\varepsilon]$ 的域上的 $L^2$ 范数，可作为伪振荡的度量。该误差定义为\n$$\nE_p(N,\\varepsilon) = \\left( \\int_{-1}^{-\\varepsilon} \\left(\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x)\\right)^2 \\, dx + \\int_{\\varepsilon}^{1} \\left(\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x)\\right)^2 \\, dx \\right)^{1/2}.\n$$\n这些积分使用 Gauss–Legendre 求积法进行数值计算。对于两个子区间 $[-1, -\\varepsilon]$ 和 $[\\varepsilon, 1]$ 中的每一个，都采用一个具有 $Q=200$ 个点的高阶求积法则。在每个求积点上，使用重心公式计算导数 $\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x)$ 的值。\n\n最后，对于每个测试用例 $(N, \\varepsilon)$，对每个候选滤波器阶数 $p \\in \\mathcal{P}=\\{0,2,4,8,16,32\\}$ 执行整个过程。比较得到的误差 $E_p(N,\\varepsilon)$。最优滤波器阶数 $p^\\star$ 被确定为使该误差最小化的阶数。比较时使用 $10^{-12}$ 的数值容差，如果结果相同，则选择最小的阶数 $p$。该算法使用 Python 实现，利用 `numpy` 进行数组操作，并利用 `scipy.fft` 进行 DCT-I 变换。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import dct, idct\n\ndef barycentric_derivative(x_eval, f_nodes, x_nodes, lambda_weights):\n    \"\"\"\n    Computes the derivative of a polynomial interpolant in barycentric form.\n\n    Args:\n        x_eval (np.ndarray): Points at which to evaluate the derivative.\n        f_nodes (np.ndarray): Function values at the interpolation nodes.\n        x_nodes (np.ndarray): Interpolation nodes.\n        lambda_weights (np.ndarray): Barycentric weights.\n\n    Returns:\n        np.ndarray: The derivative of the interpolant at x_eval points.\n    \"\"\"\n    # Vectorized computation for efficiency.\n    # The dimensions are (num_eval_points, num_nodes).\n    xdiff = np.subtract.outer(x_eval, x_nodes)\n    \n    # Add a small epsilon to denominator to avoid runtime warnings for divisions\n    # by almost zero, though in this problem x_eval points never equal x_nodes.\n    xdiff[xdiff == 0] = 1e-30\n\n    beta = lambda_weights / xdiff\n    \n    # S is the denominator of barycentric formula, shape (num_eval_points,).\n    S = np.sum(beta, axis=1)\n    \n    # U is the numerator, shape (num_eval_points,).\n    # Broadcasting f_nodes across rows of beta.\n    U = np.sum(beta * f_nodes, axis=1)\n    \n    # p_at_x is the interpolated value, p(x), shape (num_eval_points,).\n    p_at_x = U / S\n    \n    # Derivative formula: (1/S) * sum_j [lambda_j/(x-xj)^2 * (p(x) - f_j)]\n    term1 = lambda_weights / (xdiff**2)\n    # Broadcasting p_at_x and f_nodes to create a (num_eval_points, num_nodes) matrix.\n    term2 = p_at_x[:, np.newaxis] - f_nodes[np.newaxis, :]\n    summand = term1 * term2\n    \n    # Sum over j (axis=1) and divide by S.\n    derivs = np.sum(summand, axis=1) / S\n    \n    return derivs\n\n\ndef calculate_error(N, epsilon, f_tilde, x_nodes, Q, lambda_weights):\n    \"\"\"\n    Calculates the L2-norm of the derivative error away from the discontinuity.\n\n    Args:\n        N (int): Degree of the polynomial interpolant.\n        epsilon (float): Half-width of the exclusion zone around the jump.\n        f_tilde (np.ndarray): Filtered nodal values.\n        x_nodes (np.ndarray): Chebyshev nodes.\n        Q (int): Number of quadrature points.\n        lambda_weights (np.ndarray): Barycentric weights.\n\n    Returns:\n        float: The calculated L2 error.\n    \"\"\"\n    gl_nodes, gl_weights = np.polynomial.legendre.leggauss(Q)\n    total_integral = 0.0\n\n    # Integral over [-1, -epsilon]\n    a1, b1 = -1.0, -epsilon\n    if b1  a1: # Interval is valid\n        quad_points1 = 0.5 * (b1 - a1) * gl_nodes + 0.5 * (b1 + a1)\n        deriv_vals1 = barycentric_derivative(quad_points1, f_tilde, x_nodes, lambda_weights)\n        integral1 = 0.5 * (b1 - a1) * np.sum(gl_weights * (deriv_vals1**2))\n        total_integral += integral1\n\n    # Integral over [epsilon, 1]\n    a2, b2 = epsilon, 1.0\n    if b2  a2: # Interval is valid\n        quad_points2 = 0.5 * (b2 - a2) * gl_nodes + 0.5 * (b2 + a1)\n        deriv_vals2 = barycentric_derivative(quad_points2, f_tilde, x_nodes, lambda_weights)\n        integral2 = 0.5 * (b2 - a2) * np.sum(gl_weights * (deriv_vals2**2))\n        total_integral += integral2\n\n    return np.sqrt(total_integral) if total_integral  0 else 0.0\n\n\ndef run_case(N, epsilon):\n    \"\"\"\n    Executes the analysis for a single test case (N, epsilon).\n\n    Args:\n        N (int): The polynomial degree.\n        epsilon (float): The exclusion half-width.\n\n    Returns:\n        tuple: (p_star, E_star) optimal filter order and corresponding error.\n    \"\"\"\n    p_candidates = [0, 2, 4, 8, 16, 32]\n    Q = 200\n    mach_eps = np.finfo(float).eps\n    alpha = -np.log(mach_eps)\n\n    # Step 1: Define grid and sample function\n    j = np.arange(N + 1)\n    x_nodes = np.cos(np.pi * j / N)\n    f_vals = np.where(x_nodes  0, -1.0, 1.0)\n    \n    # Step 2: Define barycentric weights\n    lambda_weights = (-1.0)**j\n    lambda_weights[0] *= 0.5\n    lambda_weights[N] *= 0.5\n\n    errors = {}\n    for p in p_candidates:\n        # Step 3: Apply filter\n        if p == 0:\n            f_tilde = f_vals\n        else:\n            k = np.arange(N + 1)\n            sigma = np.exp(-alpha * (k / N)**p)\n            coeffs = dct(f_vals, type=1, norm='ortho')\n            coeffs_tilde = coeffs * sigma\n            f_tilde = idct(coeffs_tilde, type=1, norm='ortho')\n        \n        # Step 4: Calculate error\n        Ep = calculate_error(N, epsilon, f_tilde, x_nodes, Q, lambda_weights)\n        errors[p] = Ep\n    \n    # Step 5: Find optimal p\n    min_error_val = min(errors.values())\n    tolerance = 1e-12\n    best_p = -1\n    min_error = float('inf')\n\n    for p in p_candidates: # p_candidates are already sorted ascendingly\n        if np.abs(errors[p] - min_error_val) = tolerance:\n            best_p = p\n            min_error = errors[p]\n            # Since we iterate in increasing p, the first match is the smallest p.\n            break\n\n    return best_p, min_error\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        (16, 3.0/16.0),\n        (15, 3.0/15.0),\n        (64, 6.0/64.0),\n        (8, 0.1)\n    ]\n\n    results = []\n    for N, epsilon in test_cases:\n        p_star, E_star = run_case(N, epsilon)\n        results.append(p_star)\n        results.append(E_star)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在求解非线性偏微分方程时，我们常常会遇到诸如 $u(x)^2$ 这样的非线性项。在伪谱方法中，这个乘积通常在物理空间中直接计算，但这会产生网格无法解析的高频分量，导致“混叠误差”。本练习将对比一种易于实现但会产生混叠误差的“朴素”计算方法与一种使用经典“3/2规则”的去混叠方法，突显了这项确保非线性模拟稳定性和准确性的关键技术。",
            "id": "3417612",
            "problem": "你需要实现周期域上的傅里叶谱微分，该方法使用一个通过傅里叶空间中的对角化隐式定义的微分矩阵，并结合三分之二法则（也称为 $3/2$ 法则）通过在谱空间中补零来进行去混叠。你的实现必须计算一个非线性项在有和没有去混叠情况下的空间导数，并通过与在相同网格上采样的已知精确导数进行比较，来量化去混叠对误差的影响。\n\n问题设定是纯数学的，并使用以下基本依据：\n- 在长度为 $L = 2\\pi$（角度以弧度为单位）的周期域上，一个 $N$ 点的等距网格为 $x_j = j \\Delta x$，其中 $\\Delta x = L/N$。\n- 离散傅里叶变换（快速傅里叶变换，FFT）及其逆变换通过离散傅里叶系数来表示一个函数。网格上的傅里叶微分算子可以表示为一个微分矩阵 $\\mathbf{D}_N = \\mathbf{F}_N^{-1} \\operatorname{diag}(\\mathrm{i} k) \\mathbf{F}_N$，其中 $\\mathbf{F}_N$ 是离散傅里叶变换矩阵，$k$ 是与网格相符的角波数向量，$\\mathrm{i}$ 是虚数单位。将 $\\mathbf{D}_N$ 应用于网格上的函数值，等价于变换到谱空间，乘以 $\\mathrm{i} k$，然后再变换回来。\n- 物理空间中函数的乘积对应于其傅里叶系数的卷积。在具有 $N$ 个模态的有限网格上，此卷积是模 $N$ 计算的，除非采取缓解措施，否则会引起混叠。三分之二法则通过在变换到物理空间计算乘积之前，将傅里叶系数补零至 $M = \\tfrac{3}{2} N$ 的长度，然后截断回 $N$ 的长度，从而减轻二次非线性的混叠。\n\n你的任务：\n1. 实现一个例程，通过傅里叶空间中的对角化隐式地应用傅里叶微分矩阵 $\\mathbf{D}_N$，以计算在 $[0,2\\pi)$（弧度）上的 $N$ 点网格上给定的函数的导数。使用由适合网格和域长 $L=2\\pi$ 的离散频率生成的标准角波数向量 $k$。\n2. 通过以下步骤，在 $N$ 点网格上实现非线性项 $g(x) = u(x)^2$ 的朴素伪谱导数：\n   - 在网格上计算 $u$ 的值，\n   - 在物理空间中形成 $g = u^2$，\n   - 将傅里叶微分矩阵应用于 $g$ 以近似 $g'(x)$。\n3. 通过以下步骤，为 $g(x) = u(x)^2$ 的导数实现三分之二法则（$3/2$ 法则）的去混叠版本：\n   - 将 $N$ 点网格上的 $u$ 变换到谱空间，\n   - 通过对称嵌入低阶模态并将谱补零至长度 $M = \\tfrac{3}{2} N$，并进行适当的归一化，使得在 $M$ 点网格上的逆变换能再现于 $M$ 个点采样的连续三角插值函数，\n   - 变换到 $M$ 点网格上的物理空间，\n   - 在 $M$ 点网格上的物理空间中形成 $g_M = u_M^2$，\n   - 将 $g_M$ 变换回长度为 $M$ 的谱空间，\n   - 将谱截断回长度 $N$，并使用逆归一化以与 $N$ 点网格保持一致，\n   - 将 $N$ 点网格上的傅里叶微分矩阵应用于 $g$ 的截断谱，以获得在 $N$ 点网格上 $g'(x)$ 的去混叠近似。\n\n你必须使用以下测试套件，所有测试都在域 $[0,2\\pi)$ 上，角度以弧度为单位：\n- 案例 A（理想情况，中等非线性）：$N = 32$，定义 $u(x) = \\sin(3 x) + 0.5 \\cos(5 x)$。\n- 案例 B（高频内容接近 $N$ 点网格的奈奎斯特极限）：$N = 32$，定义 $u(x) = 0.7 \\sin(10 x) + 0.6 \\cos(11 x)$。\n- 案例 C（非常粗糙的网格，强混叠）：$N = 8$，定义 $u(x) = \\sin(3 x)$。\n- 案例 D（模态接近截断位置的中等网格）：$N = 48$，定义 $u(x) = \\sin(12 x) + 0.3 \\sin(13 x)$。\n\n对于每个案例，计算：\n- 在网格点处 $g(x) = u(x)^2$ 的精确导数，使用 $g'(x) = 2 u(x) u'(x)$ 和精确的解析导数 $u'(x)$。\n- 如上所述，在 $N$ 点网格上 $g'(x)$ 的朴素伪谱近似。\n- 如上所述，在 $N$ 点网格上 $g'(x)$ 的去混叠（$3/2$ 法则）伪谱近似。\n\n对于每个案例，报告两个数值：\n- 朴素近似相对于精确采样导数的相对离散 $L^2$ 误差，定义为\n  $$ \\varepsilon_{\\mathrm{naive}} = \\frac{\\left( \\sum_{j=0}^{N-1} \\left| g'_{\\mathrm{naive}}(x_j) - g'_{\\mathrm{exact}}(x_j) \\right|^2 \\Delta x \\right)^{1/2}}{\\left( \\sum_{j=0}^{N-1} \\left| g'_{\\mathrm{exact}}(x_j) \\right|^2 \\Delta x \\right)^{1/2}}. $$\n- 去混叠近似的相对离散 $L^2$ 误差\n  $$ \\varepsilon_{3/2} = \\frac{\\left( \\sum_{j=0}^{N-1} \\left| g'_{3/2}(x_j) - g'_{\\mathrm{exact}}(x_j) \\right|^2 \\Delta x \\right)^{1/2}}{\\left( \\sum_{j=0}^{N-1} \\left| g'_{\\mathrm{exact}}(x_j) \\right|^2 \\Delta x \\right)^{1/2}}. $$\n\n你的程序必须输出一行，其中包含汇总四个案例的结果，格式如下：\n- 一个包含四个条目的单一列表，按 A、B、C、D 的顺序排列。\n- 每个条目本身必须是一个包含 $[\\varepsilon_{\\mathrm{naive}}, \\varepsilon_{3/2}]$ 作为十进制浮点数的双元素列表。\n- 例如，输出应类似于：[[eA_naive,eA_3over2],[eB_naive,eB_3over2],[eC_naive,eC_3over2],[eD_naive,eD_3over2]]。\n\n无需用户输入。角度必须以弧度解释。除弧度外，不涉及其他物理单位。程序必须是遵循所述过程的完整、可运行的实现。",
            "solution": "该问题是有效的，因为它在科学上基于数值分析和谱方法的原理，问题适定且目标明确，并且不包含任何歧义或矛盾。\n\n任务是使用傅里叶伪谱方法，在周期域 $[0, 2\\pi)$ 上计算二次非线性项 $g(x) = u(x)^2$ 的空间导数。我们将比较两种方法：一种是容易产生混叠误差的朴素计算，另一种是使用三分之二法则进行去混叠的计算。每种方法的准确性通过相对于精确解析导数的相对离散 $L^2$ 误差来量化。\n\n### 傅里叶谱微分原理\n\n在长度为 $L=2\\pi$ 的域上的周期函数 $f(x)$ 可以用傅里叶级数表示：\n$$\nf(x) = \\sum_{k=-\\infty}^{\\infty} c_k e^{ikx}\n$$\n其中 $k$ 是整数波数，$c_k$ 是傅里叶系数。其导数则为：\n$$\nf'(x) = \\sum_{k=-\\infty}^{\\infty} ik c_k e^{ikx}\n$$\n在数值计算中，我们处理一个由 $N$ 个等距网格点 $x_j = 2\\pi j/N$（其中 $j=0, \\dots, N-1$）组成的有限集合。一个函数由其在该网格上的值 $f_j = f(x_j)$ 表示。离散傅里叶变换（DFT）及其逆变换提供了物理空间表示 $f_j$ 和谱空间表示 $\\hat{f}_k$ 之间的映射，后者近似于缩放后的傅里叶系数 $N c_k$。可表示的整数波数集合是有限的，对于偶数 $N$，通常为 $k \\in \\{0, \\pm 1, \\dots, \\pm(N/2-1), -N/2\\}$。\n\n导数 $f'(x_j)$ 可以通过将 $f_j$ 变换到谱域，将每个系数 $\\hat{f}_k$ 乘以 $ik$，然后变换回物理空间来计算：\n$$\nf'_j = \\mathcal{F}^{-1}\\{ ik \\hat{f}_k \\}_{k} \\quad \\text{其中} \\quad \\hat{f}_k = \\mathcal{F}\\{f_j\\}_{j}\n$$\n这里，$\\mathcal{F}$ 表示 DFT（通过快速傅里叶变换，FFT 实现），$\\mathcal{F}^{-1}$ 是其逆变换。这个过程等价于应用一个稠密的微分矩阵 $\\mathbf{D}_N$，但其计算复杂度为 $\\mathcal{O}(N \\log N)$。\n\n### 非线性项的混叠问题\n\n在使用伪谱方法计算像 $g(x) = u(x)^2$ 这样的非线性项时，乘积是在物理空间的网格上计算的：$g_j = (u_j)^2$。如果 $u(x)$ 的傅里叶级数包含最高波数为 $k_{max}$ 的模态，那么乘积 $u(x)^2$ 将包含最高达 $2k_{max}$ 的模态。如果 $2k_{max}$ 超过了 $N$ 点网格上可表示的最高波数（对于非混叠模态是 $N/2-1$），高频内容就会“折叠”到低频上，污染它们的系数。这种现象称为混叠。\n\n例如，在 $N$ 点网格上，模态 $e^{i(k+N)x_j} = e^{ikx_j}e^{iNx_j} = e^{ikx_j}e^{i2\\pi j} = e^{ikx_j}$。因此，波数 $k+N$ 与波数 $k$ 无法区分，或者说混叠为波数 $k$。\n\n### 使用三分之二法则去混叠\n\n三分之二（$3/2$）法则是一种可以精确计算二次非线性而无混叠的技术。其步骤如下：\n1.  从 $N$ 点网格上的函数值 $u_j$ 开始。\n2.  变换到谱空间以获得系数 $\\hat{u}_k$，其中 $|k|  N/2$。\n3.  将谱用零填充到一个更大的尺寸 $M \\ge \\frac{3}{2}N$。这会创建一个新的谱填充向量 $\\hat{u}^{(M)}_k$。原始系数被放置在长向量中相应的位置，而新的高频位置则用零填充。系数必须按比例因子 $M/N$ 进行缩放，以确保逆变换表示的是在更精细网格上采样的相同底层连续函数。\n4.  将 $\\hat{u}^{(M)}_k$ 逆变换到 $M$ 个点的物理网格上，得到 $u^{(M)}_j$。这等价于在更精细的网格上计算 $u$ 的三角插值函数。\n5.  在这个更精细的网格上计算二次乘积：$g^{(M)}_j = (u^{(M)}_j)^2$。由于网格更精细，它可以表示乘积产生的高频而不会发生混叠。对于二次乘积，如果 $u$ 中的原始模态限于 $|k|  N/2$，则乘积模态限于 $|k|  N$。选择 $M \\ge \\frac{3}{2}N$ 确保最高乘积模态（最高到 $N-1$）远在 M 网格的非混叠范围（$|k|  M/2$）之内。\n6.  将 $g^{(M)}_j$ 变换回谱域，得到 $\\hat{g}^{(M)}_k$。\n7.  通过丢弃乘积产生的高频系数，将谱 $\\hat{g}^{(M)}_k$ 截断回大小 $N$。这分离出了可以在原始 $N$ 点网格上表示的谱部分。系数通过乘以 $N/M$ 进行重新缩放。得到的向量 $\\hat{g}_k$ 是乘积的去混叠表示。\n8.  将谱微分算子 ($ik$) 应用于 $\\hat{g}_k$，然后进行逆变换，以获得在 $N$ 点网格上的去混叠导数。\n\n### 实现步骤\n\n对于每个测试案例，我们执行以下计算：\n1.  **网格和波数**：定义 $N$ 点网格 $x_j = 2\\pi j/N$ 和相应的整数波数向量 $k$，使用 `numpy.fft.fftfreq`。\n2.  **精确导数**：解析地求出 $u'(x)$，计算 $g'(x) = 2u(x)u'(x)$，并在网格 $x_j$ 上求值以得到向量 $g'_{\\mathrm{exact}}$。\n3.  **朴素导数**：\n    a. 在网格上计算 $u(x)$ 得到 $u_j$。\n    b. 计算逐元素平方：$g_j = u_j^2$。\n    c. 计算导数 $g'_{\\mathrm{naive}, j} = \\mathcal{F}^{-1}\\{ik \\cdot \\mathcal{F}\\{g_j\\}\\}$。\n4.  **去混叠导数（$3/2$ 法则）**：\n    a. 计算 $\\hat{u}_k = \\mathcal{F}\\{u_j\\}$。\n    b. 创建一个大小为 $M = 3N/2$ 的零向量 $\\hat{u}^{(M)}_k$。通过将 $\\hat{u}_k$ 中的低半部分正负频率系数复制到 $\\hat{u}^{(M)}_k$ 中并按 $M/N$ 缩放来进行填充。\n    c. 计算 $u^{(M)}_j = \\mathcal{F}^{-1}\\{\\hat{u}^{(M)}_k\\}$。\n    d. 计算 $g^{(M)}_j = (u^{(M)}_j)^2$。\n    e. 计算 $\\hat{g}^{(M)}_k = \\mathcal{F}\\{g^{(M)}_j\\}$。\n    f. 通过创建一个大小为 $N$ 的向量 $\\hat{g}_k$，用 $\\hat{g}^{(M)}_k$ 中相应的低频系数填充它并按 $N/M$ 缩放来进行截断。\n    g. 计算导数 $g'_{3/2, j} = \\mathcal{F}^{-1}\\{ik \\cdot \\hat{g}_k\\}$。\n5.  **误差计算**：对于朴素和去混叠方法，计算相对离散 $L^2$ 误差：\n    $$ \\varepsilon = \\frac{\\| g'_{\\mathrm{approx}} - g'_{\\mathrm{exact}} \\|_2}{\\| g'_{\\mathrm{exact}} \\|_2} $$\n    其中 $\\|\\cdot\\|_2$ 是标准的欧几里得范数，使用 `numpy.linalg.norm` 计算。\n\n此过程应用于所有四个测试案例，并收集产生的误差对 $[\\varepsilon_{\\mathrm{naive}}, \\varepsilon_{3/2}]$。正如预期的，结果将表明，当发生混叠时（案例 B、C、D），朴素方法的误差很大，而 $3/2$ 法则去混叠有效地消除了这一误差，得到接近机器精度的结果。在案例 A 中，由于没有发生混叠，预计两种方法都将高度准确。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    def run_case(N, u_func, u_prime_func):\n        \"\"\"\n        Computes naive and dealiased derivatives for a single test case\n        and returns their relative L2 errors.\n        \"\"\"\n        # 1. Setup grid, wavenumbers, and exact derivative\n        L = 2 * np.pi\n        x = np.linspace(0, L, N, endpoint=False)\n        k_N = np.fft.fftfreq(N) * N\n\n        u_vec = u_func(x)\n        u_prime_vec = u_prime_func(x)\n        g_prime_exact_vec = 2 * u_vec * u_prime_vec\n\n        # 2. Naive pseudo-spectral derivative\n        g_vec_naive = u_vec**2\n        g_hat_naive = np.fft.fft(g_vec_naive)\n        g_prime_hat_naive = 1j * k_N * g_hat_naive\n        g_prime_naive_vec = np.fft.ifft(g_prime_hat_naive)\n\n        # 3. 3/2-rule dealiased derivative\n        M = 3 * N // 2\n        \n        # Pad u from N to M grid\n        u_hat_N = np.fft.fft(u_vec)\n        u_hat_padded = np.zeros(M, dtype=np.complex128)\n        \n        N_half = N // 2\n        \n        # Copy low-frequency coefficients. The fft output for even N has\n        # k = 0, 1, ..., N/2-1 at indices 0..N/2-1\n        # k = -N/2, -N/2+1, ..., -1 at indices N/2..N-1\n        u_hat_padded[0:N_half] = u_hat_N[0:N_half]\n        u_hat_padded[M - (N - N_half):] = u_hat_N[N_half:]\n        \n        # Rescale coefficients for the larger transform size\n        u_hat_padded *= (M / N)\n\n        # Compute product on the padded grid\n        u_M_vec = np.fft.ifft(u_hat_padded)\n        # Taking .real to discard negligible imaginary parts from round-off\n        g_M_vec = u_M_vec.real**2\n        \n        # Truncate g from M back to N grid\n        g_hat_M = np.fft.fft(g_M_vec)\n        g_hat_N_dealiased = np.zeros(N, dtype=np.complex128)\n        \n        g_hat_N_dealiased[0:N_half] = g_hat_M[0:N_half]\n        g_hat_N_dealiased[N_half:] = g_hat_M[M - (N - N_half):]\n\n        # Rescale coefficients back to the original transform size\n        g_hat_N_dealiased *= (N / M)\n\n        # Differentiate the dealiased spectrum\n        g_prime_hat_32 = 1j * k_N * g_hat_N_dealiased\n        g_prime_32_vec = np.fft.ifft(g_prime_hat_32)\n\n        # 4. Error calculation\n        norm_exact = np.linalg.norm(g_prime_exact_vec)\n        \n        if norm_exact == 0:\n            err_naive = np.linalg.norm(g_prime_naive_vec.real - g_prime_exact_vec)\n            err_32 = np.linalg.norm(g_prime_32_vec.real - g_prime_exact_vec)\n        else:\n            err_naive = np.linalg.norm(g_prime_naive_vec.real - g_prime_exact_vec) / norm_exact\n            err_32 = np.linalg.norm(g_prime_32_vec.real - g_prime_exact_vec) / norm_exact\n\n        return [err_naive, err_32]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Happy path, moderate nonlinearity\n        (32, lambda x: np.sin(3 * x) + 0.5 * np.cos(5 * x), \n             lambda x: 3 * np.cos(3 * x) - 2.5 * np.sin(5 * x)),\n        # Case B: High-frequency content near Nyquist limit on N\n        (32, lambda x: 0.7 * np.sin(10 * x) + 0.6 * np.cos(11 * x), \n             lambda x: 7 * np.cos(10 * x) - 6.6 * np.sin(11 * x)),\n        # Case C: Very coarse grid, strong aliasing\n        (8,  lambda x: np.sin(3 * x), \n             lambda x: 3 * np.cos(3 * x)),\n        # Case D: Moderate grid with modes near truncation\n        (48, lambda x: np.sin(12 * x) + 0.3 * np.sin(13 * x), \n             lambda x: 12 * np.cos(12 * x) + 3.9 * np.cos(13 * x))\n    ]\n\n    results = []\n    for N, u_func, u_prime_func in test_cases:\n        result = run_case(N, u_func, u_prime_func)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}