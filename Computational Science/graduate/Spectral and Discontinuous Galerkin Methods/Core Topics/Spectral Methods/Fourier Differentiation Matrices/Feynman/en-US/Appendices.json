{
    "hands_on_practices": [
        {
            "introduction": "The power of Fourier spectral methods lies in transforming complex calculus operations into simple algebra. This first practice provides a hands-on implementation of this core principle. By using the Fast Fourier Transform (FFT), you will compute the derivative of a periodic function not by finite differences, but by multiplying its frequency components by their corresponding wavenumbers, demonstrating the method's remarkable accuracy firsthand. ",
            "id": "3387455",
            "problem": "Consider a periodic grid on the interval $[0,2\\pi)$ defined by $x_j = \\frac{2\\pi j}{N}$ for $j \\in \\{0,1,\\dots,N-1\\}$, where $N \\in \\mathbb{N}$ and angles are measured in radians. Let $u_j = \\sin(5 x_j)$ for all grid points. The goal is to compute the discrete derivative $v = D u$ using the Fast Fourier Transform (FFT), where $D$ denotes the Fourier differentiation matrix acting on grid values of a $2\\pi$-periodic function. The derivation and computation must be based on first principles: start from the definition of the discrete Fourier transform of a $2\\pi$-periodic trigonometric interpolant on the equispaced grid, and use only foundational properties of Fourier series and linear operators. No pre-derived differentiation formulas are permitted in the problem statement.\n\nYour task is to write a complete, runnable program that:\n- Constructs the grid $x_j = \\frac{2\\pi j}{N}$ and the data $u_j = \\sin(5 x_j)$.\n- Computes the action of the Fourier differentiation matrix $D$ on $u$ by transforming $u$ to Fourier space, applying the differentiation operator in that basis consistent with the periodic setting, and transforming back to physical space.\n- Verifies numerically that the computed discrete derivative $v_j$ equals the analytical derivative $5 \\cos(5 x_j)$ to machine precision, and reports the maximum absolute error $\\max_j |v_j - 5\\cos(5 x_j)|$ for each test case.\n\nUse angles in radians. No physical units are involved. The answers must be expressed as real-valued floating-point numbers.\n\nTest Suite:\n- Use the set of grid sizes $N \\in \\{11, 12, 64, 128, 1001\\}$ to exercise different regimes, including the smallest allowed grid ($N=11$), even grids with a Nyquist mode ($N=12$), and larger grids where resolution is high ($N=64$, $N=128$, $N=1001$).\n\nFinal Output Format:\n- Your program should produce a single line of output containing the maximum absolute errors for the test suite as a comma-separated list enclosed in square brackets. For example, the output must be of the form $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_5]$, where each $\\text{result}_i$ is the maximum absolute error for the corresponding $N$ in the order $[11,12,64,128,1001]$.",
            "solution": "The problem is evaluated as valid. It is scientifically grounded in the principles of Fourier analysis and spectral methods, is well-posed with all necessary information provided, and is formulated objectively. The solution proceeds as follows.\n\nThe core of the problem is to compute the derivative of a function $u(x)$ on a periodic grid using Fourier spectral methods. This method relies on representing the function by a trigonometric polynomial and then performing differentiation in the frequency domain, where it simplifies to a multiplication operation. The process involves three main steps: transforming the function from the physical domain to the frequency domain, applying the differentiation operator in the frequency domain, and transforming the result back to the physical domain.\n\nLet the domain be the interval $[0, 2\\pi)$, discretized by $N$ equispaced points $x_j = \\frac{2\\pi j}{N}$ for $j \\in \\{0, 1, \\dots, N-1\\}$. The function values on this grid are given by $u_j = u(x_j)$. For this problem, $u(x) = \\sin(5x)$, so $u_j = \\sin(5x_j)$.\n\n**Principle 1: Trigonometric Interpolation**\n\nThe set of $N$ data points $(x_j, u_j)$ uniquely defines a trigonometric polynomial interpolant, $p(x)$, of degree at most $\\lfloor N/2 \\rfloor$, such that $p(x_j) = u_j$ for all $j$. This interpolant can be expressed as a finite complex Fourier series:\n$$\np(x) = \\sum_{k \\in \\mathbb{K}_N} \\hat{u}_k e^{ikx}\n$$\nwhere $\\mathbb{K}_N$ is the set of integer wavenumbers appropriate for a grid of size $N$.\nFor $N$ odd, $\\mathbb{K}_N = \\{-(N-1)/2, \\dots, (N-1)/2\\}$.\nFor $N$ even, $\\mathbb{K}_N = \\{-N/2+1, \\dots, N/2\\}$. The mode $k=-N/2$ is aliased with $k=N/2$ on the grid, and they are typically combined into a single cosine term.\n\nThe complex Fourier coefficients $\\hat{u}_k$ are related to the grid values $u_j$ by the Discrete Fourier Transform (DFT). The standard definition is:\n$$\n\\hat{u}_k = \\frac{1}{N} \\sum_{j=0}^{N-1} u_j e^{-ikx_j} = \\frac{1}{N} \\sum_{j=0}^{N-1} u_j e^{-i k \\frac{2\\pi j}{N}}\n$$\n\n**Principle 2: Differentiation in the Fourier Domain**\n\nThe key advantage of the Fourier representation is that differentiation of the function in physical space corresponds to a simple multiplication of its Fourier coefficients by $ik$ in the frequency domain. Differentiating the interpolant $p(x)$ with respect to $x$ yields:\n$$\nv(x) = p'(x) = \\frac{d}{dx} \\left( \\sum_{k \\in \\mathbb{K}_N} \\hat{u}_k e^{ikx} \\right)\n$$\nBy linearity, we can interchange differentiation and summation:\n$$\nv(x) = \\sum_{k \\in \\mathbb{K}_N} \\hat{u}_k \\frac{d}{dx} (e^{ikx}) = \\sum_{k \\in \\mathbb{K}_N} (ik) \\hat{u}_k e^{ikx}\n$$\nThis demonstrates that the Fourier coefficients of the derivative, denoted $\\hat{v}_k$, are given by:\n$$\n\\hat{v}_k = ik \\hat{u}_k\n$$\nThe values of the derivative on the grid, $v_j = v(x_j)$, are then found by evaluating this new series, which is equivalent to performing an Inverse Discrete Fourier Transform (IDFT) on the coefficients $\\hat{v}_k$.\n\n**Algorithmic Implementation using the Fast Fourier Transform (FFT)**\n\nThe DFT and IDFT can be computed efficiently using the FFT algorithm. The procedure is as follows:\n\n1.  **Forward Transform**: Given the vector of function values $u = [u_0, u_1, \\dots, u_{N-1}]$, compute its DFT using an FFT algorithm. Let the result be $\\hat{U} = \\text{fft}(u)$. Standard numerical libraries like NumPy compute $\\hat{U}_m = \\sum_{j=0}^{N-1} u_j e^{-i 2\\pi mj / N}$ for $m \\in \\{0, \\dots, N-1\\}$. The relationship to our physical coefficients is $\\hat{u}_k = \\frac{1}{N}\\hat{U}_k$, where the FFT index $m$ is mapped to the physical wavenumber $k$.\n\n2.  **Wavenumber Vector**: It is necessary to construct the vector of physical wavenumbers $k$ that corresponds to the ordering of the FFT output. For an $N$-point FFT, the wavenumbers are $k \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$ for even $N$, and $k \\in \\{0, 1, \\dots, (N-1)/2, -(N-1)/2, \\dots, -1\\}$ for odd $N$. This vector can be readily generated using library functions such as `numpy.fft.fftfreq(N) * N`.\n\n3.  **Applying the Differentiator**: The Fourier coefficients of the derivative, $\\hat{v}_k$, are computed by element-wise multiplication: $\\hat{v}_k = ik \\hat{u}_k$. In terms of the un-normalized coefficients from the FFT, this is $\\hat{V}_k = ik \\hat{U}_k$.\n    A special case arises for even $N$ at the Nyquist frequency, which corresponds to the wavenumber $k=N/2$ (or $k=-N/2$ depending on convention). A real-valued signal's interpolant on the grid contains only the $\\cos((N/2)x)$ component for this mode. The derivative of this cosine, $-(N/2)\\sin((N/2)x)$, is zero at all grid points $x_j$. Therefore, for a robust differentiation algorithm, the multiplier for the Nyquist frequency coefficient must be set to $0$.\n\n4.  **Inverse Transform**: The derivative values on the grid, $v = [v_0, v_1, \\dots, v_{N-1}]$, are obtained by applying the inverse FFT to the modified coefficients $\\hat{V}$: $v = \\text{ifft}(\\hat{V})$. Since the derivative of a real function is real, any residual imaginary part in the result is due to floating-point error and should be discarded.\n\n**Verification**\nThe computed discrete derivative $v_j$ is compared to the analytical derivative of $u(x) = \\sin(5x)$, which is $u'(x) = 5\\cos(5x)$. The maximum absolute error, $\\max_j |v_j - 5\\cos(5x_j)|$, is calculated. Since the function $\\sin(5x)$ is band-limited with wavenumber $k=5$, and all test cases use $N > 2k = 10$, the trigonometric interpolant is identical to the function itself. Consequently, the Fourier differentiation should be exact up to machine precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the derivative of u(x) = sin(5x) on a periodic grid\n    using the Fourier spectral method for a suite of grid sizes N,\n    and reports the maximum absolute error against the analytical derivative.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [11, 12, 64, 128, 1001]\n\n    results = []\n    \n    for N in test_cases:\n        # Step 1: Construct the grid and the function data.\n        # Grid points on [0, 2*pi).\n        x = 2 * np.pi * np.arange(N) / N\n        \n        # Function values on the grid for u(x) = sin(5x).\n        u = np.sin(5 * x)\n        \n        # Analytical derivative u'(x) = 5*cos(5x) on the grid for verification.\n        u_analytic_deriv = 5 * np.cos(5 * x)\n        \n        # Step 2: Transform to Fourier space using FFT.\n        # This gives the un-normalized Fourier coefficients.\n        u_hat = np.fft.fft(u)\n        \n        # Step 3: Apply the differentiation operator in Fourier space.\n        \n        # Generate the vector of physical wavenumbers corresponding to the FFT output array.\n        # np.fft.fftfreq(N) returns frequencies f_k = k/N.\n        # Multiplying by N gives the integer wavenumbers k.\n        wavenumbers = np.fft.fftfreq(N) * N\n        \n        # The differentiation operator in Fourier space is multiplication by ik.\n        d_hat = 1j * wavenumbers\n        \n        # For even N, the Nyquist frequency component requires special handling.\n        # The derivative of the cos(N/2 * x) basis function is zero on the grid points.\n        # Therefore, the corresponding multiplier must be set to 0.\n        # In numpy's fftfreq, the Nyquist frequency corresponds to index N//2.\n        if N % 2 == 0:\n            d_hat[N // 2] = 0.0\n            \n        # Apply the differentiation operator.\n        v_hat = d_hat * u_hat\n        \n        # Step 4: Transform back to physical space using inverse FFT.\n        v = np.fft.ifft(v_hat)\n        \n        # The result should be real. We take the real part to discard\n        # any small imaginary noise from floating-point inaccuracies.\n        v_real = v.real\n        \n        # Step 5: Verify the result by comparing with the analytical derivative.\n        # Calculate the maximum absolute error across all grid points.\n        max_error = np.max(np.abs(v_real - u_analytic_deriv))\n        \n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # The map function converts each float error into a string for joining.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While the FFT provides an elegant way to perform differentiation, its practical importance is rooted in its computational efficiency. This exercise contrasts the $O(N \\log N)$ FFT-based approach with the explicit construction of an $O(N^2)$ dense differentiation matrix. By implementing both, you will verify their mathematical equivalence and gain a concrete appreciation for why the FFT is indispensable for applying spectral methods to large-scale problems. ",
            "id": "3387466",
            "problem": "Consider a periodic function sampled on an equispaced grid over one period and the task of computing its first derivative using two spectrally accurate approaches that are central to spectral and Discontinuous Galerkin (DG) methods. Starting from the Fourier series representation, use the following fundamental base.\n\n1. Let $f(x)$ be $2\\pi$-periodic and sampled at $N$ equispaced points $x_j = \\frac{2\\pi j}{N}$ for $j \\in \\{0,1,\\dots,N-1\\}$. Denote the samples by $f_j = f(x_j)$.\n\n2. The Discrete Fourier Transform (DFT) (implemented by the Fast Fourier Transform (FFT)) and its inverse are defined, for frequency indices $m \\in \\{0,1,\\dots,N-1\\}$, by\n$$\n\\widehat{f}_m = \\sum_{j=0}^{N-1} f_j \\, e^{-2\\pi i \\frac{j m}{N}}, \\qquad \nf_j = \\frac{1}{N} \\sum_{m=0}^{N-1} \\widehat{f}_m \\, e^{2\\pi i \\frac{j m}{N}}.\n$$\n\n3. For a Fourier mode $e^{i k x}$, the derivative with respect to $x$ is given by\n$$\n\\frac{d}{dx} e^{i k x} = i k \\, e^{i k x}.\n$$\nOn the $2\\pi$-periodic grid, represent the wave numbers by the integer vector $k$ arranged in the standard DFT order so that multiplication by $i k$ in Fourier space corresponds to differentiation in physical space.\n\nYour tasks are:\n\nA. Implement Algorithm A (FFT-based spectral differentiation) as follows: compute $\\widehat{f}$ via the DFT of $f$, multiply by $i k$, and transform back with the inverse DFT to obtain the derivative approximation.\n\nB. Implement Algorithm B (dense Fourier differentiation matrix) by explicitly forming the DFT matrix from the above definitions and using it, together with the property $\\frac{d}{dx} e^{i k x} = i k e^{i k x}$, to construct a dense $N \\times N$ matrix that maps the sample vector $f$ to its derivative samples.\n\nC. For each test case below, compute:\n- The relative $\\ell^2$ error of Algorithm A with respect to the analytical derivative sampled on the grid:\n$$\nE_A = \\frac{\\left\\| d_A - d_{\\text{true}} \\right\\|_2}{\\left\\| d_{\\text{true}} \\right\\|_2}.\n$$\n- The relative $\\ell^2$ error of Algorithm B with respect to the analytical derivative sampled on the grid:\n$$\nE_B = \\frac{\\left\\| d_B - d_{\\text{true}} \\right\\|_2}{\\left\\| d_{\\text{true}} \\right\\|_2}.\n$$\n- The $\\ell^\\infty$ norm of the difference between the two numerical derivatives:\n$$\n\\Delta = \\left\\| d_A - d_B \\right\\|_\\infty.\n$$\n- The complexity ratio $R$ defined by\n$$\nR = \\frac{N^2}{N \\log_2 N} = \\frac{N}{\\log_2 N},\n$$\nas a dimensionless indicator comparing dense matrix multiplication complexity $O(N^2)$ to the Fast Fourier Transform complexity $O(N \\log N)$.\n\nAll angles must be in radians.\n\nTest suite:\n1. Case $1$: $N = 64$, $f(x) = \\sin(3x) + \\frac{1}{2}\\cos(5x)$, so $d_{\\text{true}}(x) = 3\\cos(3x) - \\frac{5}{2}\\sin(5x)$.\n2. Case $2$: $N = 63$, $f(x) = \\cos(7x) + \\sin(12x)$, so $d_{\\text{true}}(x) = -7\\sin(7x) + 12\\cos(12x)$.\n3. Case $3$ (Nyquist aliasing demonstration): $N = 32$, $f(x) = \\sin\\!\\left(\\frac{N}{2} x\\right) = \\sin(16x)$, so $d_{\\text{true}}(x) = 16\\cos(16x)$.\n4. Case $4$: $N = 32$, $f(x) = \\sin(15x)$, so $d_{\\text{true}}(x) = 15\\cos(15x)$.\n5. Case $5$: $N = 4$, $f(x) = \\sin(x)$, so $d_{\\text{true}}(x) = \\cos(x)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered per test case as\n$$\n\\left[ E_A^{(1)}, E_B^{(1)}, \\Delta^{(1)}, R^{(1)}, E_A^{(2)}, E_B^{(2)}, \\Delta^{(2)}, R^{(2)}, E_A^{(3)}, E_B^{(3)}, \\Delta^{(3)}, R^{(3)}, E_A^{(4)}, E_B^{(4)}, \\Delta^{(4)}, R^{(4)}, E_A^{(5)}, E_B^{(5)}, \\Delta^{(5)}, R^{(5)} \\right].\n$$\nAll outputs must be floating point numbers. Angles are in radians, and no physical units are involved. The numerical norms are to be computed directly on the discrete samples on the grid without any additional scaling. The final output must exactly follow this format on a single line.",
            "solution": "### Step 1: Extract Givens\n- **Domain**: A $2\\pi$-periodic function $f(x)$.\n- **Grid**: $N$ equispaced points $x_j = \\frac{2\\pi j}{N}$ for $j \\in \\{0, 1, \\dots, N-1\\}$.\n- **Samples**: $f_j = f(x_j)$.\n- **Discrete Fourier Transform (DFT)**: $\\widehat{f}_m = \\sum_{j=0}^{N-1} f_j \\, e^{-2\\pi i \\frac{j m}{N}}$ for $m \\in \\{0,1,\\dots,N-1\\}$.\n- **Inverse DFT (IDFT)**: $f_j = \\frac{1}{N} \\sum_{m=0}^{N-1} \\widehat{f}_m \\, e^{2\\pi i \\frac{j m}{N}}$.\n- **Differentiation in Fourier Space**: $\\frac{d}{dx} e^{i k x} = i k \\, e^{i k x}$. The wave numbers $k$ are to be arranged in standard DFT order.\n- **Algorithm A**: Differentiate using DFT, multiplication by $ik$ in Fourier space, and IDFT.\n- **Algorithm B**: Construct a dense $N \\times N$ matrix that maps the sample vector $f$ to its derivative samples.\n- **Metrics to Compute**:\n  - Algorithm A relative $\\ell^2$ error: $E_A = \\frac{\\left\\| d_A - d_{\\text{true}} \\right\\|_2}{\\left\\| d_{\\text{true}} \\right\\|_2}$.\n  - Algorithm B relative $\\ell^2$ error: $E_B = \\frac{\\left\\| d_B - d_{\\text{true}} \\right\\|_2}{\\left\\| d_{\\text{true}} \\right\\|_2}$.\n  - Difference norm: $\\Delta = \\left\\| d_A - d_B \\right\\|_\\infty$.\n  - Complexity ratio: $R = \\frac{N}{\\log_2 N}$.\n- **Test Cases**:\n  1. $N = 64$, $f(x) = \\sin(3x) + \\frac{1}{2}\\cos(5x)$, $d_{\\text{true}}(x) = 3\\cos(3x) - \\frac{5}{2}\\sin(5x)$.\n  2. $N = 63$, $f(x) = \\cos(7x) + \\sin(12x)$, $d_{\\text{true}}(x) = -7\\sin(7x) + 12\\cos(12x)$.\n  3. $N = 32$, $f(x) = \\sin(\\frac{N}{2} x) = \\sin(16x)$, $d_{\\text{true}}(x) = 16\\cos(16x)$.\n  4. $N = 32$, $f(x) = \\sin(15x)$, $d_{\\text{true}}(x) = 15\\cos(15x)$.\n  5. $N = 4$, $f(x) = \\sin(x)$, $d_{\\text{true}}(x) = \\cos(x)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the principles of Fourier analysis and its application to numerical differentiation, a cornerstone of spectral methods. The definitions for the DFT/IDFT are standard. The task of implementing spectral differentiation via two different but mathematically equivalent algorithms is a well-defined problem in computational science. The test cases are specific and designed to probe different aspects of the method, including accuracy for well-resolved functions, behavior for odd vs. even $N$, and the aliasing phenomenon at the Nyquist frequency. The error metrics are standard and objectively defined. The problem is self-contained, consistent, and well-posed. A subtle but crucial point is the differentiation of the Nyquist frequency for even $N$. To ensure the derivative of a real-valued function remains real-valued, the Fourier coefficient of the derivative at the Nyquist frequency must be set to zero. This is a standard convention in spectral methods, and a rigorous implementation must account for it. The problem is valid.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n---\n\n### Principle-Based Design of the Solution\nThe core principle of spectral differentiation is that differentiation in physical space is equivalent to multiplication by a simple factor in Fourier space. We will implement and compare two computational approaches based on this principle.\n\n**1. Grid and Function Representation**\nThe function $f(x)$ is represented by a vector of its samples $f$ of length $N$ on the equispaced grid $x_j = \\frac{2\\pi j}{N}$ for $j=0, \\dots, N-1$. The vector of samples is denoted by $f = [f_0, f_1, \\dots, f_{N-1}]^T$.\n\n**2. Wave Number Vector**\nThe mapping between frequency indices $m$ from the DFT and the continuous wave numbers $k$ must be established. For a grid of size $N$, the resolvable wave numbers are integers. The standard DFT ordering of wave numbers, as implemented in libraries like NumPy, is crucial. This vector $k$ consists of integer wave numbers corresponding to the indices $m = 0, \\dots, N-1$.\n- For odd $N$, $k = [0, 1, \\dots, \\frac{N-1}{2}, -\\frac{N-1}{2}, \\dots, -1]$.\n- For even $N$, $k = [0, 1, \\dots, \\frac{N}{2}-1, -\\frac{N}{2}, -\\frac{N}{2}+1, \\dots, -1]$.\n\nA critical consideration for even $N$ arises with the Nyquist frequency, which corresponds to the wave number $\\pm N/2$. The differentiation operator in Fourier space is multiplication by $ik$. For a real-valued function $f(x)$, its Fourier transform $\\widehat{f}$ must be conjugate symmetric ($\\widehat{f}_m = \\overline{\\widehat{f}_{N-m}}$). This implies that $\\widehat{f}_{N/2}$ is real. Multiplication by $i k_{N/2}$ would make this coefficient purely imaginary, breaking the conjugate symmetry and resulting in a complex-valued derivative for a real-valued function. To preserve the real-valued nature of the derivative, the standard convention is to set the derivative of the Nyquist mode to zero. Therefore, for even $N$, the wave number vector used for differentiation, $k_{diff}$, is modified such that its element corresponding to the Nyquist frequency is $0$.\n\n**3. Algorithm A: FFT-based Spectral Differentiation**\nThis algorithm leverages the Fast Fourier Transform (FFT) for computational efficiency, with a complexity of $O(N \\log N)$.\n- **Step 1: Forward Transform.** Compute the Fourier coefficients $\\widehat{f}$ of the sample vector $f$ using the FFT: $\\widehat{f} = \\text{FFT}(f)$.\n- **Step 2: Differentiate in Fourier Space.** Multiply the vector of Fourier coefficients element-wise by the differentiation operator $i k_{diff}$: $\\widehat{d}_A = i k_{diff} \\odot \\widehat{f}$.\n- **Step 3: Inverse Transform.** Transform the result back to physical space using the inverse FFT (iFFT) to obtain the derivative samples $d_A$: $d_A = \\text{iFFT}(\\widehat{d}_A)$. The real part of the result is taken to discard negligible imaginary components arising from floating-point inaccuracies.\n\n**4. Algorithm B: Dense Fourier Differentiation Matrix**\nThis algorithm explicitly constructs the $N \\times N$ matrix that performs differentiation in a single matrix-vector multiplication. While computationally expensive with a complexity of $O(N^2)$, it makes the linear operator explicit. The differentiation matrix $D_{\\text{mat}}$ is formed by composing the matrices for the forward DFT ($F$), differentiation in Fourier space ($D$), and the inverse DFT ($F^{-1}$).\n$$ D_{\\text{mat}} = F^{-1} D F $$\n- **Step 1: Construct DFT Matrix $F$.** The element $(m, j)$ of matrix $F$ is $F_{mj} = e^{-2\\pi i \\frac{mj}{N}}$.\n- **Step 2: Construct Inverse DFT Matrix $F^{-1}$.** The element $(j, m)$ of matrix $F^{-1}$ is $(F^{-1})_{jm} = \\frac{1}{N} e^{2\\pi i \\frac{jm}{N}}$.\n- **Step 3: Construct Fourier Differentiation Operator $D$.** This is a diagonal matrix whose diagonal entries are the elements of the vector $i k_{diff}$: $D = \\text{diag}(i k_{diff})$.\n- **Step 4: Compute Derivative.** The derivative vector $d_B$ is computed by the matrix-vector product $d_B = D_{\\text{mat}} f$. Again, the real part is taken.\n\n**5. Error and Complexity Analysis**\nThe two algorithms are mathematically identical. The difference $\\Delta = \\|d_A - d_B\\|_\\infty$ quantifies the numerical discrepancy between the highly optimized FFT algorithm and the direct matrix multiplication approach, which should be on the order of machine precision. The relative $\\ell^2$ errors $E_A$ and $E_B$ measure the accuracy of the spectral method against the exact analytical derivative sampled on the grid. The ratio $R = N / \\log_2 N$ serves as a theoretical indicator of the performance advantage of Algorithm A over Algorithm B for large $N$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares spectral derivatives of periodic functions\n    using two different algorithms: one based on the Fast Fourier Transform (FFT)\n    and another based on a dense differentiation matrix.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, lambda x: np.sin(3*x) + 0.5*np.cos(5*x), lambda x: 3*np.cos(3*x) - 2.5*np.sin(5*x)),\n        (63, lambda x: np.cos(7*x) + np.sin(12*x), lambda x: -7*np.sin(7*x) + 12*np.cos(12*x)),\n        (32, lambda x: np.sin(16*x), lambda x: 16*np.cos(16*x)),\n        (32, lambda x: np.sin(15*x), lambda x: 15*np.cos(15*x)),\n        (4, lambda x: np.sin(x), lambda x: np.cos(x))\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, f_func, d_true_func = case\n        \n        # 1. Setup grid and data vectors\n        x_grid = 2 * np.pi * np.arange(N) / N\n        f_vec = f_func(x_grid)\n        d_true_vec = d_true_func(x_grid)\n        \n        # 2. Define the wave number vector for differentiation\n        # The wave numbers must be ordered according to the FFT output.\n        # np.fft.fftfreq provides this standard ordering.\n        k_vec = np.fft.fftfreq(N) * N\n        \n        # For even N, to ensure the derivative of a real function is real,\n        # the derivative of the Nyquist frequency component is set to zero.\n        if N % 2 == 0:\n            k_vec[N//2] = 0.0\n\n        # --- Algorithm A: FFT-based spectral differentiation ---\n        f_hat = np.fft.fft(f_vec)\n        d_hat_A = 1j * k_vec * f_hat\n        d_A = np.real(np.fft.ifft(d_hat_A))\n        \n        # --- Algorithm B: Dense Fourier differentiation matrix ---\n        # Construct the constituent matrices: F, F_inv, and D_fourier.\n        m_indices = np.arange(N)\n        j_indices = np.arange(N)\n        \n        # DFT Matrix F_{mj} = exp(-2*pi*i*m*j/N)\n        m_grid, j_grid = np.meshgrid(m_indices, j_indices, indexing='ij')\n        F_mat = np.exp(-2j * np.pi * m_grid * j_grid / N)\n        \n        # Inverse DFT Matrix F_inv_{jm} = (1/N) * exp(2*pi*i*j*m/N)\n        j_grid_inv, m_grid_inv = np.meshgrid(j_indices, m_indices, indexing='ij')\n        Finv_mat = (1/N) * np.exp(2j * np.pi * j_grid_inv * m_grid_inv / N)\n\n        # Diagonal differentiation matrix in Fourier space\n        D_fourier = np.diag(1j * k_vec)\n\n        # Full differentiation matrix in physical space: D_mat = F_inv * D * F\n        Dmat = Finv_mat @ D_fourier @ F_mat\n        \n        d_B = np.real(Dmat @ f_vec)\n        \n        # --- Compute metrics ---\n        norm_d_true = np.linalg.norm(d_true_vec)\n\n        # Avoid division by zero if the true derivative norm is zero.\n        if norm_d_true < 1e-15:\n            # If norm is zero, absolute error is used.\n            E_A = np.linalg.norm(d_A - d_true_vec)\n            E_B = np.linalg.norm(d_B - d_true_vec)\n        else:\n            # Otherwise, relative l2 error is used.\n            E_A = np.linalg.norm(d_A - d_true_vec) / norm_d_true\n            E_B = np.linalg.norm(d_B - d_true_vec) / norm_d_true\n            \n        # l-infinity norm of the difference between the two numerical results\n        Delta = np.linalg.norm(d_A - d_B, ord=np.inf)\n        \n        # Complexity ratio\n        R = N / np.log2(N)\n        \n        results.extend([E_A, E_B, Delta, R])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After mastering differentiation, the natural next step is to tackle integration and solve differential equations. This practice guides you through constructing a spectral integration matrix, which acts as a pseudo-inverse to the differentiation operator. You will confront the singularity associated with the zero-frequency mode (the constant of integration) and implement a stable solver for the equation $u_x = f$, a fundamental task in computational science. ",
            "id": "3387474",
            "problem": "Consider the periodic interval $[0,2\\pi)$ and an equispaced collocation grid $x_j = \\frac{2\\pi j}{N}$ for $j = 0,1,\\ldots,N-1$. Let $u \\in \\mathbb{C}^N$ be the vector of nodal values $u_j = u(x_j)$ of a sufficiently smooth $2\\pi$-periodic function $u(x)$. The Discrete Fourier Transform (DFT) gives a representation of $u$ in terms of complex Fourier modes. Use the following foundational facts as the derivation base:\n\n- The complex exponential functions $e^{\\mathrm{i} k x}$ are eigenfunctions of the differentiation operator with eigenvalues $\\mathrm{i} k$, that is, $\\frac{d}{dx}\\left(e^{\\mathrm{i} k x}\\right) = \\mathrm{i} k e^{\\mathrm{i} k x}$ for any integer $k$.\n- In a periodic discretization using the Discrete Fourier Transform (DFT) on an equispaced grid, differentiation acts diagonally in Fourier space, with diagonal entries determined by the corresponding integer wave numbers.\n- The Fast Fourier Transform (FFT) provides a numerically stable and exact (up to floating point) implementation of the DFT and its inverse for $N$-point sequences.\n\nFrom these, derive the Fourier differentiation matrix $D \\in \\mathbb{C}^{N \\times N}$ that maps nodal values $u$ to nodal derivatives $u_x$, by diagonalizing the action of differentiation in Fourier space and transforming back to physical space. Next, derive a spectral integration matrix $I \\in \\mathbb{C}^{N \\times N}$ that left-inverts $D$ on the mean-free subspace, i.e., $I D$ acts as the identity on all components orthogonal to the constant mode, and annihilates the constant mode. Then formulate a stable solver for the linear equation $u_x = f$ with $u$ periodic, by projecting out the zero wave number (the $k=0$ mode) to enforce compatibility with periodicity, and choosing the mean of $u$ consistently.\n\nYou must implement a complete program that:\n- Constructs the Fourier differentiation matrix $D$ and the spectral integration matrix $I$ for given $N$, using the DFT and its inverse without relying on any shortcut formulas beyond the foundational facts stated.\n- Implements a stable solver for $u_x = f$ by explicitly projecting out the $k=0$ mode in Fourier space before integrating, yielding the mean-zero periodic solution.\n- Validates the property that $I D u = u - \\overline{u}$, where $\\overline{u}$ denotes the constant vector with entries equal to the average of the nodal values of $u$.\n- Tests the sensitivity of the solver when $f$ has nonzero mean by reporting the residual $\\|D u - f\\|_\\infty$ for such cases.\n\nAll angles must be in radians. The program must evaluate the following test suite, each on the interval $[0,2\\pi)$:\n\n- Test $1$ (composition check): $N = 16$, $u(x) = 2 + \\cos(3x)$. Compute the maximum absolute error between $I D u$ and $u - \\overline{u}$, reported as a single floating-point number.\n- Test $2$ (mean-zero right-hand side): $N = 32$, $f(x) = -3 \\sin(3x)$. Solve $u_x = f$ with periodic $u$ via the stable solver. Report $\\|D u - f\\|_\\infty$ as a single floating-point number.\n- Test $3$ (nonzero mean right-hand side): $N = 32$, $f(x) = 1 + \\sin(x)$. Solve using the same stable solver. Report $\\|D u - f\\|_\\infty$ as a single floating-point number, which quantifies sensitivity to the nonzero mean of $f$.\n- Test $4$ (zero right-hand side): $N = 10$, $f(x) \\equiv 0$. Solve using the stable solver and report $\\|D u - f\\|_\\infty$ as a single floating-point number.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$\\text{result1}$,$\\text{result2}$,$\\text{result3}$,$\\text{result4}$]\"). Each result must be a floating-point number computed in radians on the specified grid.",
            "solution": "The problem requires the derivation and implementation of Fourier spectral differentiation and integration methods for periodic functions on the interval $[0, 2\\pi)$. This will be accomplished by leveraging the properties of the Discrete Fourier Transform (DFT), which diagonalizes the differentiation operator.\n\n### Theoretical Foundation\n\nLet $u(x)$ be a $2\\pi$-periodic function sampled on an equispaced grid $x_j = \\frac{2\\pi j}{N}$ for $j = 0, 1, \\ldots, N-1$. The vector of nodal values is $u = [u(x_0), \\ldots, u(x_{N-1})]^T \\in \\mathbb{C}^N$.\n\nThe DFT and its inverse (IDFT) provide a transformation between the function's representation in physical space (nodal values $u$) and frequency space (Fourier coefficients $\\hat{u}$). These transforms are defined as:\n$$\n\\hat{u}_k = \\sum_{j=0}^{N-1} u_j e^{-2\\pi\\mathrm{i}jk/N} \\quad (\\text{DFT})\n$$\n$$\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{u}_k e^{2\\pi\\mathrm{i}jk/N} \\quad (\\text{IDFT})\n$$\nWe use the notation of the `numpy.fft` library, where the IDFT contains the $1/N$ scaling factor. The relationship can be expressed using a DFT matrix operator $\\mathcal{F}$ and its inverse $\\mathcal{F}^{-1}$, where $\\hat{u} = \\mathcal{F}u$ and $u = \\mathcal{F}^{-1}\\hat{u}$.\n\nA key principle is that differentiation in physical space corresponds to multiplication in frequency space. The derivative of a single Fourier mode $e^{\\mathrm{i}kx}$ is $\\frac{d}{dx} e^{\\mathrm{i}kx} = \\mathrm{i}k e^{\\mathrm{i}kx}$. For the discrete set of wave numbers $k_{eff}$ corresponding to the grid, the nodal values of the derivative, $u_x$, can be obtained by:\n1. Transforming $u$ to frequency space: $\\hat{u} = \\mathcal{F}u$.\n2. Multiplying each Fourier coefficient $\\hat{u}_k$ by its corresponding scaled wave number $\\mathrm{i}k_{eff, k}$.\n3. Transforming back to physical space: $u_x = \\mathcal{F}^{-1}(\\mathrm{i}k_{eff} \\odot \\hat{u})$, where $\\odot$ denotes element-wise multiplication.\n\nThe vector of effective integer wave numbers, $k_{eff}$, for an $N$-point DFT is given by $k_{eff} = [0, 1, \\ldots, N/2-1, -N/2, \\ldots, -1]$ for even $N$, and a similar sequence for odd $N$. This sequence is readily provided by `numpy.fft.fftfreq(N) * N`.\n\n### Derivations\n\n**1. Fourier Differentiation Matrix $D$**\n\nThe process of spectral differentiation can be encapsulated in a matrix $D \\in \\mathbb{C}^{N \\times N}$ such that $u_x = Du$. Following the steps outlined above, we can write:\n$$\nD u = \\mathcal{F}^{-1}(\\Lambda_D (\\mathcal{F}u)) = (\\mathcal{F}^{-1} \\Lambda_D \\mathcal{F}) u\n$$\nwhere $\\Lambda_D$ is a diagonal matrix with the eigenvalues of differentiation on its diagonal: $(\\Lambda_D)_{kk} = \\mathrm{i}k_{eff, k}$. Thus, the differentiation matrix is $D = \\mathcal{F}^{-1} \\Lambda_D \\mathcal{F}$.\nTo construct this matrix, we can apply the differentiation operator to each canonical basis vector $e_j \\in \\mathbb{R}^N$ (a vector of zeros with a $1$ at index $j$). The $j$-th column of $D$ is $D e_j$.\n\n**2. Spectral Integration Matrix $I$**\n\nTo solve the differential equation $u_x = f$, we can perform the inverse operation in frequency space. The equation becomes $\\mathrm{i}k_{eff,k} \\hat{u}_k = \\hat{f}_k$, which implies $\\hat{u}_k = \\frac{\\hat{f}_k}{\\mathrm{i}k_{eff,k}}$.\nThis division is singular for the $k=0$ mode (the mean), where $k_{eff,0}=0$.\nFor a periodic solution to exist, the compatibility condition $\\int_0^{2\\pi} f(x) dx = 0$ must hold. In the discrete case, this corresponds to $\\sum_{j=0}^{N-1} f_j \\approx 0$, or more precisely, $\\hat{f}_0 = 0$. If this holds, $\\hat{u}_0$ is undetermined, representing the constant of integration. We obtain a unique solution by requiring the solution to have zero mean, i.e., $\\hat{u}_0 = 0$.\n\nIf $\\hat{f}_0 \\neq 0$, no periodic solution exists. A \"stable solver\" proceeds by solving for the mean-zero part of the solution, effectively solving $u_x = f - \\bar{f}$, where $\\bar{f}$ is the mean of $f$. This is done by setting $\\hat{u}_0=0$ and calculating $\\hat{u}_k = \\hat{f}_k / (\\mathrm{i}k_{eff,k})$ for all other $k$.\n\nThis procedure defines a spectral integration matrix $I$. Similar to $D$, it can be expressed as $I = \\mathcal{F}^{-1} \\Lambda_I \\mathcal{F}$, where $\\Lambda_I$ is a diagonal matrix with entries $(\\Lambda_I)_{kk} = 1/(\\mathrm{i}k_{eff,k})$ for $k_{eff,k} \\neq 0$, and $(\\Lambda_I)_{00} = 0$.\n\n**3. Composition Property $IDu = u - \\bar{u}$**\n\nThe composition $ID$ is a projection operator.\n$$\nID = (\\mathcal{F}^{-1} \\Lambda_I \\mathcal{F}) (\\mathcal{F}^{-1} \\Lambda_D \\mathcal{F}) = \\mathcal{F}^{-1} (\\Lambda_I \\Lambda_D) \\mathcal{F}\n$$\nThe product of the diagonal matrices $\\Lambda_I \\Lambda_D$ is a diagonal matrix $\\Pi$ with entries:\n$$ \\Pi_{kk} = \\begin{cases} \\frac{1}{\\mathrm{i}k_{eff,k}} \\cdot \\mathrm{i}k_{eff,k} = 1 & \\text{if } k_{eff,k} \\neq 0 \\\\ 0 \\cdot 0 = 0 & \\text{if } k_{eff,k} = 0 \\end{cases} $$\nSo, $\\Pi$ is a projection matrix that annihilates the $k=0$ Fourier mode. Applying $ID$ to a vector $u$ yields:\n$$\nIDu = \\mathcal{F}^{-1} \\Pi (\\mathcal{F} u) = \\mathcal{F}^{-1}(\\Pi \\hat{u})\n$$\nThis operation sets the zero-frequency coefficient of $u$ to zero and transforms back. This is equivalent to subtracting the mean from $u$. The mean of $u$ is $\\bar{u} = \\frac{1}{N}\\sum u_j = \\frac{1}{N}\\hat{u}_0$. The vector $\\bar{u}_{vec}$ with all entries equal to $\\bar{u}$ has a DFT with only a $k=0$ component equal to $\\hat{u}_0$. Thus, $\\mathcal{F}(u - \\bar{u}_{vec}) = \\hat{u} - \\mathcal{F}(\\bar{u}_{vec}) = \\Pi\\hat{u}$. Applying $\\mathcal{F}^{-1}$ confirms that $IDu = u - \\bar{u}_{vec}$.\n\n### Implementation for Test Suite\n\nThe program implements these concepts to construct $D$ and $I$ and to solve $u_x=f$.\n\n- **Matrices Construction**: A function `construct_matrices(N)` computes $D$ and $I$ by applying the transform-multiply-transform sequence to the columns of the identity matrix.\n- **Stable Solver**: A function `solve_pde(f, N)` implements the stable solver by transforming $f$ to Fourier space, dividing by $\\mathrm{i}k_{eff}$ (with the $k=0$ mode handled by setting its coefficient to zero), and transforming back.\n- **Test 1**: For $u(x) = 2+\\cos(3x)$, $IDu$ is computed and compared to $u-\\bar{u}$. The mean of $\\cos(3x)$ on the symmetric grid is zero, so $\\bar{u}=2$ and $u-\\bar{u}=\\cos(3x)$. The composition $IDu$ should recover $\\cos(3x)$ with high accuracy.\n- **Test 2**: For $f(x)=-3\\sin(3x)$, the mean is zero, so the problem is well-posed. The solver finds the unique mean-zero solution $u(x)=\\cos(3x)$. The residual $\\|Du - f\\|_\\infty$ should be near machine precision.\n- **Test 3**: For $f(x)=1+\\sin(x)$, the mean is $\\bar{f}=1$. The problem is incompatible. The stable solver effectively solves $u_x = f-\\bar{f} = \\sin(x)$, yielding $u(x)=-\\cos(x)$. The residual $\\|Du-f\\|_\\infty$ will be $\\|(f-\\bar{f}) - f\\|_\\infty = \\|-\\bar{f}\\|_\\infty = 1$.\n- **Test 4**: For $f(x)=0$, the solver returns $u=0$, and the residual $\\|D \\cdot 0 - 0\\|_\\infty$ is exactly $0$.",
            "answer": "```python\nimport numpy as np\n\ndef construct_matrices(N):\n    \"\"\"\n    Constructs the Fourier differentiation matrix D and spectral integration matrix I.\n    \n    Args:\n        N (int): The number of grid points.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the (D, I) matrices.\n    \"\"\"\n    if not isinstance(N, int) or N <= 0:\n        raise ValueError(\"N must be a positive integer.\")\n    \n    # Effective integer wave numbers for an N-point DFT.\n    k_vec = np.fft.fftfreq(N) * N\n    \n    # Diagonal entries for the differentiation operator in Fourier space.\n    diag_D = 1j * k_vec\n    \n    # Diagonal entries for the integration operator in Fourier space.\n    # We use a pseudo-inverse, setting the 1/0 term to 0.\n    diag_I = np.zeros(N, dtype=complex)\n    non_zero_k = k_vec != 0\n    diag_I[non_zero_k] = 1.0 / diag_D[non_zero_k]\n\n    # Construct matrices by applying the operators to basis vectors.\n    D = np.zeros((N, N), dtype=complex)\n    I = np.zeros((N, N), dtype=complex)\n    \n    identity_matrix = np.identity(N)\n    for j in range(N):\n        e_j = identity_matrix[:, j]\n        e_j_hat = np.fft.fft(e_j)\n        \n        # Column j of D is the derivative of the j-th basis vector\n        D[:, j] = np.fft.ifft(diag_D * e_j_hat)\n        \n        # Column j of I is the integral of the j-th basis vector\n        I[:, j] = np.fft.ifft(diag_I * e_j_hat)\n        \n    return D, I\n\ndef solve_pde(f, N):\n    \"\"\"\n    Solves the equation u_x = f for periodic u using a stable spectral method.\n    The solver finds the unique solution with zero mean.\n    \n    Args:\n        f (np.ndarray): The vector of nodal values of the right-hand side function.\n        N (int): The number of grid points.\n        \n    Returns:\n        np.ndarray: The vector of nodal values of the solution u(x).\n    \"\"\"\n    # Effective integer wave numbers\n    k_vec = np.fft.fftfreq(N) * N\n    \n    # Transform f to Fourier space\n    f_hat = np.fft.fft(f)\n    \n    # Allocate space for solution in Fourier space\n    u_hat = np.zeros(N, dtype=complex)\n    \n    # Find indices of non-zero wave numbers\n    non_zero_k = k_vec != 0\n    \n    # Solve for u_hat components where k is not zero\n    u_hat[non_zero_k] = f_hat[non_zero_k] / (1j * k_vec[non_zero_k])\n    \n    # The k=0 component (mean) of u_hat remains zero.\n    \n    # Transform back to physical space\n    u = np.fft.ifft(u_hat)\n    \n    return u\n\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        {'id': 1, 'N': 16, 'u_func': lambda x: 2 + np.cos(3 * x)},\n        {'id': 2, 'N': 32, 'f_func': lambda x: -3 * np.sin(3 * x)},\n        {'id': 3, 'N': 32, 'f_func': lambda x: 1 + np.sin(x)},\n        {'id': 4, 'N': 10, 'f_func': lambda x: np.zeros_like(x)},\n    ]\n\n    results = []\n    \n    # Test 1: Composition check IDu = u - u_bar\n    N1 = test_cases[0]['N']\n    u_func1 = test_cases[0]['u_func']\n    \n    D1, I1 = construct_matrices(N1)\n    x1 = 2 * np.pi * np.arange(N1) / N1\n    u1 = u_func1(x1)\n    \n    # Compute IDu\n    computed1 = (I1 @ D1 @ u1).real\n    \n    # Compute u - u_bar\n    u_mean1 = np.mean(u1)\n    expected1 = u1 - u_mean1\n    \n    # Maximum absolute error\n    error1 = np.max(np.abs(computed1 - expected1))\n    results.append(error1)\n\n    # Tests 2, 3, 4: Solve u_x = f and check residual\n    for case in test_cases[1:]:\n        N = case['N']\n        f_func = case['f_func']\n\n        D, _ = construct_matrices(N)\n        x = 2 * np.pi * np.arange(N) / N\n        f = f_func(x)\n        \n        # Solve u_x = f to get the mean-zero solution u\n        u_sol = solve_pde(f, N)\n        \n        # Compute the numerical derivative Du\n        f_computed = (D @ u_sol).real\n        \n        # Calculate the residual ||Du - f||_inf\n        # Take real part of f for cases where it's specified as real\n        residual = np.max(np.abs(f_computed - f.real))\n        results.append(residual)\n\n    # Format and print the final results\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}