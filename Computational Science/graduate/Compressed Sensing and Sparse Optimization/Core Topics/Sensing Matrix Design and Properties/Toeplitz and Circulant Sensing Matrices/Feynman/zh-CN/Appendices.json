{
    "hands_on_practices": [
        {
            "introduction": "在压缩感知中，使用循环和托普利茨矩阵的主要优势在于其计算效率。对于大规模问题，直接进行矩阵向量乘法运算速度过慢，不切实际。本练习将是您掌握这种强大能力的第一步：您将使用快速傅里叶变换（FFT）来实现基本的矩阵向量乘法 $Ax$ 和其伴随运算 $A^*y$，从而用接近线性时间的卷积运算取代缓慢的矩阵乘法。掌握这项技能对于构建任何基于这些结构化矩阵的可扩展算法至关重要 。",
            "id": "3490937",
            "problem": "给定一个由向量 $g \\in \\mathbb{C}^n$ 生成的 $n \\times n$ 循环传感矩阵 $C(g)$，以及一个采样算子 $P \\in \\{0,1\\}^{m \\times n}$，它根据索引集 $S \\subset \\{0,1,\\dots,n-1\\}$ 从输入矩阵中选择 $m$ 个不同的行。定义 $A = P C(g)$。算子 $C(g)$ 通过与 $g$ 进行循环卷积来作用于向量 $x \\in \\mathbb{C}^n$，而算子 $P$ 则按顺序选择向量中索引在 $S$ 内的条目。令 $A^*$ 表示 $A$ 的共轭转置。\n\n您的任务是：\n- 设计使用快速傅里叶变换 (FFT) 计算 $A x$ 和 $A^* y$ 的例程，而无需显式构造矩阵 $A$。\n- 为您基于 FFT 的例程以及显式构造 $A$ 并进行乘法的朴素密集矩阵方法，提供一个关于 $n$ 和 $m$ 的清晰复杂度分析。\n\n从以下基本原理出发：\n- 循环矩阵 $C(g)$ 对向量的作用等同于与 $g$ 进行循环卷积。\n- 在离散傅里叶变换 (DFT) 下，时域中的循环卷积对应于频域中的逐点相乘。\n- 采样算子 $P$ 按顺序选择由 $S$ 索引的 $m$ 个条目，其伴随算子 $P^*$ 将一个长度为 $m$ 的向量嵌入到 $\\mathbb{C}^n$ 中，方法是将其条目放置在索引 $S$ 处，其余位置补零。\n\n您编写的程序必须：\n- 实现使用 FFT 计算 $A x$ 和 $A^* y$ 的例程，而无需构造 $A$。\n- 为了验证，使用显式密集矩阵（构造循环矩阵，以及在需要时构造采样算子或其伴随算子）计算参考结果，并与基于 FFT 的输出进行比较。\n- 对每个测试用例，返回一个浮点数，该数等于 $A x$ 和 $A^* y$ 两个相对误差中的最大值。相对误差定义为 $\\lVert u_{\\mathrm{FFT}} - u_{\\mathrm{dense}} \\rVert_2 / \\lVert u_{\\mathrm{dense}} \\rVert_2$，并约定如果分母为 $0$，则相对误差为分子。\n\n测试套件：\n使用以下五个测试用例及指定的随机种子以确保可复现性。在每个案例中，$S$ 是 $P$ 的索引集，向量按指定从标准正态分布中抽取。\n\n- 案例 1：$n = 64$，$m = 32$，$S$ 是从 $\\{0,1,\\dots,63\\}$ 中均匀随机抽取的 32 个元素组成的子集，按升序排列（种子为 $0$）。$g \\in \\mathbb{C}^{64}$ 和 $x \\in \\mathbb{C}^{64}$ 是复数向量，其实部和虚部分别独立地从 $\\mathcal{N}(0,1)$ 中抽取；$y \\in \\mathbb{C}^{32}$ 是复数向量，其实部和虚部分别独立地从 $\\mathcal{N}(0,1)$ 中抽取。\n- 案例 2：$n = 64$，$m = 64$，$S = \\{0,1,\\dots,63\\}$（种子为 $1$）。$g \\in \\mathbb{R}^{64}$ 和 $x \\in \\mathbb{R}^{64}$ 是实数向量，其条目从 $\\mathcal{N}(0,1)$ 中抽取；$y \\in \\mathbb{R}^{64}$ 是实数向量，其条目从 $\\mathcal{N}(0,1)$ 中抽取。\n- 案例 3：$n = 17$，$m = 1$，$S = \\{5\\}$（种子为 $2$）。$g \\in \\mathbb{C}^{17}$ 和 $x \\in \\mathbb{C}^{17}$ 是复数向量，其实部和虚部分别独立地从 $\\mathcal{N}(0,1)$ 中抽取；$y \\in \\mathbb{C}$ 是复数，其实部和虚部分别独立地从 $\\mathcal{N}(0,1)$ 中抽取。\n- 案例 4：$n = 50$，$m = 25$，$S = \\{0,1,\\dots,24\\}$（种子为 $3$）。$g \\in \\mathbb{R}^{50}$ 和 $x \\in \\mathbb{R}^{50}$ 是实数向量，其条目从 $\\mathcal{N}(0,1)$ 中抽取；$y \\in \\mathbb{R}^{25}$ 是实数向量，其条目从 $\\mathcal{N}(0,1)$ 中抽取。\n- 案例 5：$n = 128$，$m = 60$，$S$ 是从 $\\{0,1,\\dots,127\\}$ 中均匀随机抽取的 60 个元素组成的子集，按升序排列（种子为 $4$）。$g \\in \\mathbb{R}^{128}$ 是实数向量，其条目从 $\\mathcal{N}(0,1)$ 中抽取；$x \\in \\mathbb{R}^{128}$ 是 $k$-稀疏向量，$k = 5$，其非零条目是均匀随机选择的（种子为 $4$），其值从 $\\mathcal{N}(0,1)$ 中抽取；$y \\in \\mathbb{R}^{60}$ 是实数向量，其条目从 $\\mathcal{N}(0,1)$ 中抽取。\n\n复杂度分析要求：\n- 假设 $g$ 的 DFT 已预先计算，推导使用 FFT 计算 $A x$ 和 $A^* y$ 的渐进复杂度。\n- 将此与显式构造 $A$ 并执行密集矩阵向量乘法的复杂度进行对比。\n- 清晰地说明其对 $n$ 和 $m$ 的依赖关系。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，第 $i$ 个条目是测试用例 $i$（$i = 1,2,3,4,5$）的浮点数结果，例如 $[r_1,r_2,r_3,r_4,r_5]$。",
            "solution": "该问题要求设计和分析用于计算矩阵向量积 $A x$ 和 $A^* y$ 的高效算法，其中 $A$ 是一个定义为 $A = P C(g)$ 的结构化传感矩阵。矩阵 $C(g)$ 是一个由向量 $g \\in \\mathbb{C}^n$ 生成的 $n \\times n$ 循环矩阵，而 $P$ 是一个 $m \\times n$ 的采样算子，它根据给定的索引集 $S$ 选择 $m$ 行。关键在于利用快速傅里叶变换 (FFT) 来避免显式构造和存储可能涉及的巨大矩阵。\n\n### $A x$ 的快速计算\n\n操作 $A x$ 定义为 $A x = P (C(g) x)$。我们可以分两个阶段计算：\n1.  计算中间向量 $z = C(g) x$。\n2.  将采样算子 $P$ 应用于 $z$ 以获得最终结果。\n\n循环矩阵 $C(g)$ 对向量 $x$ 的作用等价于其生成向量 $g$ 与向量 $x$ 的循环卷积。这表示为 $z = g * x$。卷积定理指出，时域中的循环卷积对应于频域中的逐元素相乘。设 $\\mathcal{F}$ 表示离散傅里叶变换 (DFT)，$\\mathcal{F}^{-1}$ 表示其逆变换。该定理表示为：\n$$\n\\mathcal{F}(g * x) = \\mathcal{F}(g) \\odot \\mathcal{F}(x)\n$$\n其中 $\\odot$ 表示哈达玛（逐元素）积。\n\n因此，向量 $z$ 可以高效地计算为：\n$$\nz = \\mathcal{F}^{-1}(\\mathcal{F}(g) \\odot \\mathcal{F}(x))\n$$\n\n第二步是应用采样算子 $P$。算子 $P$ 选择 $z$ 中对应于集合 $S \\subset \\{0, 1, \\dots, n-1\\}$ 中索引的条目。如果 $z = [z_0, z_1, \\dots, z_{n-1}]^T$，那么 $Pz$ 是一个长度为 $m$ 的向量，包含元素 $\\{z_i\\}_{i \\in S}$。\n\n计算 $A x$ 的完整基于 FFT 的算法如下：\n1.  计算生成向量的 DFT，$\\hat{g} = \\mathcal{F}(g)$。如果 $A$ 被多次应用，可以预先计算并存储此结果。\n2.  计算输入向量的 DFT，$\\hat{x} = \\mathcal{F}(x)$。\n3.  在频域中执行逐元素相乘：$\\hat{z} = \\hat{g} \\odot \\hat{x}$。\n4.  计算逆 DFT 以返回到时域：$z = \\mathcal{F}^{-1}(\\hat{z})$。\n5.  提取 $z$ 中由 $S$ 指定索引的 $m$ 个元素。\n\n### $A^* y$ 的快速计算\n\n伴随算子 $A^*$ 由 $A^* = (P C(g))^* = C(g)^* P^*$ 给出。因此，它对向量 $y \\in \\mathbb{C}^m$ 的作用是 $A^* y = C(g)^* (P^* y)$。这也可以分阶段计算。\n\n1.  计算中间向量 $v = P^* y$。算子 $P^*$ 是采样算子 $P$ 的伴随算子。它执行一个嵌入操作：取一个长度为 $m$ 的向量 $y$，并创建一个长度为 $n$ 的向量 $v$，方法是将 $y$ 的元素放置在由 $S$ 指定的索引处，并在其余条目填充零。也就是说，对于 $i \\in \\{0, 1, \\dots, n-1\\}$，如果 $i$ 是排序后索引集 $S$ 中的第 $k$ 个元素，则 $v_i = y_k$，如果 $i \\notin S$，则 $v_i = 0$。\n\n2.  计算乘积 $w = C(g)^* v$。我们必须首先描述矩阵 $C(g)^*$ 的特性。循环矩阵的共轭转置也是一个循环矩阵。如果 $C(g)$ 由向量 $g$ 生成，那么 $C(g)^*$ 由向量 $g'$ 生成，其中 $g'_k = \\overline{g_{(-k) \\pmod{n}}}$，对于 $k \\in \\{0, 1, \\dots, n-1\\}$。这个向量 $g'$ 是 $g$ 的共轭和时间反转版本。\n\n因此，操作 $C(g)^* v$ 等价于循环卷积 $g' * v$。我们可以再次应用卷积定理：\n$$\nw = g' * v = \\mathcal{F}^{-1}(\\mathcal{F}(g') \\odot \\mathcal{F}(v))\n$$\n一个关键性质将 $g'$ 的 DFT 与 $g$ 的 DFT 联系起来。$g'$ 的 DFT 是 $g$ 的 DFT 的逐元素复共轭：\n$$\n\\mathcal{F}(g')_k = \\sum_{j=0}^{n-1} g'_j e^{-2\\pi i jk / n} = \\sum_{j=0}^{n-1} \\overline{g_{(-j) \\pmod n}} e^{-2\\pi i jk / n}\n$$\n令 $l = (-j) \\pmod n$，我们有 $j = (-l) \\pmod n$。求和变为：\n$$\n\\sum_{l=0}^{n-1} \\overline{g_l} e^{-2\\pi i (-l)k / n} = \\sum_{l=0}^{n-1} \\overline{g_l} e^{2\\pi i lk / n} = \\overline{\\sum_{l=0}^{n-1} g_l e^{-2\\pi i lk / n}} = \\overline{\\mathcal{F}(g)_k}\n$$\n因此，$\\mathcal{F}(g') = \\overline{\\mathcal{F}(g)}$。将此代入 $w$ 的表达式中得到：\n$$\nw = \\mathcal{F}^{-1}(\\overline{\\mathcal{F}(g)} \\odot \\mathcal{F}(v))\n$$\n\n计算 $A^* y$ 的完整基于 FFT 的算法如下：\n1.  计算生成向量的 DFT，$\\hat{g} = \\mathcal{F}(g)$。这与计算 $A x$ 时的预计算相同。\n2.  通过在索引 $S$ 处嵌入 $y \\in \\mathbb{C}^m$ 来构造稀疏向量 $v \\in \\mathbb{C}^n$。\n3.  计算嵌入向量的 DFT，$\\hat{v} = \\mathcal{F}(v)$。\n4.  在频域中计算逐元素乘积：$\\hat{w} = \\overline{\\hat{g}} \\odot \\hat{v}$。\n5.  计算逆 DFT 以获得最终结果：$w = \\mathcal{F}^{-1}(\\hat{w})$。\n\n### 复杂度分析\n\n我们分析基于 FFT 的方法和朴素的密集矩阵方法的计算复杂度。一个 $N$ 点 FFT 或 IFFT 的复杂度是 $\\mathcal{O}(N \\log N)$。\n\n**基于 FFT 的方法：**\n-   **预计算：** 计算 $\\hat{g} = \\mathcal{F}(g)$ 需要 $\\mathcal{O}(n \\log n)$ 次操作。这是一次性成本。\n-   **$A x$ 的计算：**\n    1.  $\\mathcal{F}(x)$: $\\mathcal{O}(n \\log n)$。\n    2.  $\\hat{g} \\odot \\hat{x}$: $\\mathcal{O}(n)$。\n    3.  $\\mathcal{F}^{-1}(\\hat{z})$: $\\mathcal{O}(n \\log n)$。\n    4.  采样 $Pz$: $\\mathcal{O}(m)$。\n    假设 $\\hat{g}$ 已预先计算，总复杂度由 FFT 主导，为 **$\\mathcal{O}(n \\log n)$**。\n-   **$A^* y$ 的计算：**\n    1.  嵌入 $P^*y$：初始化零向量需要 $\\mathcal{O}(n)$，放置元素需要 $\\mathcal{O}(m)$。总计 $\\mathcal{O}(n)$。\n    2.  $\\mathcal{F}(v)$: $\\mathcal{O}(n \\log n)$。\n    3.  $\\overline{\\hat{g}} \\odot \\hat{v}$: $\\mathcal{O}(n)$。\n    4.  $\\mathcal{F}^{-1}(\\hat{w})$: $\\mathcal{O}(n \\log n)$。\n    假设 $\\hat{g}$ 已预先计算，总复杂度同样由 FFT 主导，为 **$\\mathcal{O}(n \\log n)$**。\n\n**密集矩阵方法：**\n-   **构造矩阵 $A$：** 完整的循环矩阵 $C(g)$ 有 $n^2$ 个条目。构造它需要 $\\mathcal{O}(n^2)$ 的时间。矩阵 $A = P C(g)$ 是一个通过从 $C(g)$ 中选择 $m$ 行而形成的 $m \\times n$ 矩阵。这个子采样可以在 $\\mathcal{O}(mn)$ 时间内完成。\n-   **$A x$ 的计算：** 这是一个 $m \\times n$ 矩阵与一个 $n \\times 1$ 向量的乘法。这需要 $m$ 次长度为 $n$ 的内积，复杂度为 **$\\mathcal{O}(mn)$**。\n-   **$A^* y$ 的计算：** 矩阵 $A^*$ 是 $n \\times m$ 的。将其与一个 $m \\times 1$ 的向量相乘需要 $n$ 次长度为 $m$ 的内积，复杂度也为 **$\\mathcal{O}(mn)$**。\n\n**比较：**\n基于 FFT 的方法对于前向 ($A x$) 和伴随 ($A^* y$) 操作的复杂度均为 $\\mathcal{O}(n \\log n)$。密集矩阵方法的复杂度为 $\\mathcal{O}(mn)$。只要 $n \\log n  mn$，即 $m > \\log n$，基于 FFT 的方法在计算上就更优越。在典型的压缩感知场景中，$m$ 与信号的稀疏度和对数因子成正比，即 $m \\approx k \\log(n/k)$，这几乎总是大于 $\\log n$。对于 $m$ 不是微不足道的小的大规模问题，基于 FFT 的例程提供了显著的性能优势，将一个平方时间问题（如果 $m=\\mathcal{O}(n)$）转变为一个近线性时间问题。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft\nfrom scipy.linalg import circulant\n\ndef compute_Ax_fft(g, x, S):\n    \"\"\"Computes A @ x using FFT, where A = P @ C(g).\"\"\"\n    n = g.shape[0]\n    # Step 1: Compute z = C(g) @ x via FFT\n    # This corresponds to circular convolution g * x\n    g_hat = fft(g)\n    x_hat = fft(x)\n    z_hat = g_hat * x_hat\n    z = ifft(z_hat)\n    \n    # Step 2: Apply sampling operator P\n    # Select entries of z at indices S\n    return z[S]\n\ndef compute_A_star_y_fft(g, y, S, n):\n    \"\"\"Computes A.conj().T @ y using FFT, where A = P @ C(g).\"\"\"\n    # Adjoint is A* = C(g)* @ P*\n    \n    # Step 1: Apply P*, which embeds y into a sparse vector of size n\n    v = np.zeros(n, dtype=y.dtype)\n    v[S] = y\n    \n    # Step 2: Apply C(g)*, which is convolution with conj(g_timereversed)\n    # In frequency domain, this is multiplication with conj(fft(g))\n    g_hat = fft(g)\n    v_hat = fft(v)\n    w_hat = np.conj(g_hat) * v_hat\n    w = ifft(w_hat)\n    \n    return w\n\ndef relative_error(u_test, u_ref):\n    \"\"\"\n    Calculates the relative error ||u_test - u_ref|| / ||u_ref||.\n    If ||u_ref|| is 0, returns ||u_test - u_ref||.\n    \"\"\"\n    diff_norm = np.linalg.norm(u_test - u_ref)\n    ref_norm = np.linalg.norm(u_ref)\n    \n    if ref_norm == 0:\n        return diff_norm\n    return diff_norm / ref_norm\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute errors.\n    \"\"\"\n    test_cases = [\n        {'n': 64, 'm': 32, 's_type': 'random', 'seed': 0, 'cplx': True, 'sparse_x': False},\n        {'n': 64, 'm': 64, 's_type': 'full', 'seed': 1, 'cplx': False, 'sparse_x': False},\n        {'n': 17, 'm': 1, 's_type': 'single', 'seed': 2, 'cplx': True, 'sparse_x': False},\n        {'n': 50, 'm': 25, 's_type': 'first_m', 'seed': 3, 'cplx': False, 'sparse_x': False},\n        {'n': 128, 'm': 60, 's_type': 'random', 'seed': 4, 'cplx': False, 'sparse_x': True, 'k': 5},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        n, m, seed = case['n'], case['m'], case['seed']\n        rng = np.random.default_rng(seed)\n\n        # Generate index set S\n        if case['s_type'] == 'random':\n            S = rng.choice(n, m, replace=False)\n            S.sort()\n        elif case['s_type'] == 'full':\n            S = np.arange(n)\n        elif case['s_type'] == 'single':\n            S = np.array([5])\n        elif case['s_type'] == 'first_m':\n            S = np.arange(m)\n        \n        # Determine data type\n        dtype = np.complex128 if case['cplx'] else np.float64\n\n        # Generate vectors g, x, y\n        if case['cplx']:\n            g = rng.standard_normal(n) + 1j * rng.standard_normal(n)\n            y = rng.standard_normal(m) + 1j * rng.standard_normal(m)\n            if case.get('sparse_x', False):\n                 k = case['k']\n                 x = np.zeros(n, dtype=dtype)\n                 nonzero_indices = rng.choice(n, k, replace=False)\n                 nonzero_values = rng.standard_normal(k) + 1j * rng.standard_normal(k)\n                 x[nonzero_indices] = nonzero_values\n            else:\n                 x = rng.standard_normal(n) + 1j * rng.standard_normal(n)\n        else:\n            g = rng.standard_normal(n)\n            y = rng.standard_normal(m)\n            if case.get('sparse_x', False):\n                 k = case['k']\n                 x = np.zeros(n, dtype=dtype)\n                 # Use a different seed for x's sparsity pattern for reproducibility as per problem \n                 # (even if seed is the same, this is good practice).\n                 rng_sparse = np.random.default_rng(seed)\n                 nonzero_indices = rng_sparse.choice(n, k, replace=False)\n                 nonzero_values = rng_sparse.standard_normal(k)\n                 x[nonzero_indices] = nonzero_values\n            else:\n                 x = rng.standard_normal(n)\n        \n        # --- FFT-based computation ---\n        ax_fft = compute_Ax_fft(g, x, S)\n        a_star_y_fft = compute_A_star_y_fft(g, y, S, n)\n\n        # --- Dense matrix computation for verification ---\n        C_dense = circulant(g)\n        A_dense = C_dense[S, :]\n        \n        ax_dense = A_dense @ x\n        \n        # Using A_dense.conj().T for A*\n        a_star_y_dense = A_dense.conj().T @ y\n\n        # --- Compare results and compute error ---\n        err_ax = relative_error(ax_fft, ax_dense)\n        err_a_star_y = relative_error(a_star_y_fft, a_star_y_dense)\n        \n        results.append(max(err_ax, err_a_star_y))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了基本的矩阵乘法，许多稀疏恢复算法及其理论分析都需要了解传感矩阵的性质。例如，“丹齐格选择器”（Dantzig selector）需要一个参数 $\\lambda$，该参数的设定依赖于噪声水平和矩阵 $A$ 的列范数。本练习  表明，同样基于 FFT 的技术也可用于更复杂的算子分析。您将通过巧妙地将计算问题转化为可通过 FFT 求解的互相关运算，从而开发出一种高效计算最大列范数 $\\|A\\|_{2,\\infty}$ 的方法，而这一数值是设定理论界限和算法参数的关键。",
            "id": "3490910",
            "problem": "考虑在具有结构化传感算子的压缩感知中的以下设置。设 $n \\in \\mathbb{N}$ 且 $h \\in \\mathbb{C}^n$ 定义循环卷积算子 $C_h:\\mathbb{C}^n \\to \\mathbb{C}^n$，其由 $C_h x = h \\circledast x$ 给出，其中 $\\circledast$ 表示在 $\\mathbb{Z}_n$ 上的循环卷积。设 $S \\in \\{0,1\\}^{m \\times n}$ 是一个行选择矩阵，它提取一个由基数为 $m$ 的子集 $\\Omega \\subset \\{0,\\dots,n-1\\}$ 索引的向量条目，其中 $m \\le n$。传感矩阵为 $A = S C_h$。对于具有方差为 $\\sigma^2$ 的独立正态分量条目的加性噪声 $e \\in \\mathbb{R}^m$，Dantzig选择器约束要求高效地评估 $\\|A^* e\\|_\\infty$ 并根据 $\\sigma$ 和 $\\log n$ 选择 $\\lambda$。\n\n从以下基本依据出发：\n- 离散傅里叶变换可将循环算子对角化：如果 $\\mathcal{F}$ 表示离散傅里叶变换算子且 $\\widehat{h} = \\mathcal{F} h$，则 $C_h = \\mathcal{F}^{-1} \\operatorname{diag}(\\widehat{h}) \\mathcal{F}$，其伴随算子为 $C_h^* = \\mathcal{F}^{-1} \\operatorname{diag}(\\overline{\\widehat{h}}) \\mathcal{F}$。\n- 行选择算子 $S$ 的伴随算子是零插入算子 $S^*$，它将一个向量 $e \\in \\mathbb{R}^m$ 映射到一个向量 $z \\in \\mathbb{R}^n$，其中对于 $i \\in \\Omega$（对应于第 $j$ 个选定索引），$z_i = e_j$，否则 $z_i = 0$。\n- 对于方差为 $\\sigma^2$ 的独立高斯噪声，对于 $A$ 的第 $j$ 列 $a_j$，随机变量 $\\langle a_j, e\\rangle$ 是方差为 $\\sigma^2 \\|a_j\\|_2^2$ 的高斯变量，因此联合界（union bound）意味着以高概率 $\\|A^* e\\|_\\infty \\le \\sigma \\sqrt{2 \\log n} \\, \\|A\\|_{2,\\infty}$，其中 $\\|A\\|_{2,\\infty} = \\max_j \\|a_j\\|_2$。\n\n你的任务是：\n- 推导一个 $\\mathcal{O}(n \\log n)$ 算法，使用快速傅里叶变换 (FFT) 计算 $g = A^* e$ 而无需显式构造 $A$。用 $\\mathcal{F}$、$\\widehat{h}$ 和补零向量 $z = S^* e$ 来表示 $g$。\n- 推导一个使用 FFT 计算 $\\|A\\|_{2,\\infty}$ 的 $\\mathcal{O}(n \\log n)$ 方法。论证列的 $\\ell_2$ 范数的平方是由 $|h|^2$ 与 $\\Omega$ 的二进制掩码的循环互相关给出的，并展示如何通过 FFT 评估此互相关。\n- 根据 $\\sigma$ 和 $\\log n$ 选择 $\\lambda$，使得在所述高斯噪声模型下，Dantzig选择器约束 $\\|A^* e\\|_\\infty \\le \\lambda$ 以高概率成立。\n\n你的程序必须为每个测试用例实现以下过程：\n- 从 $h$ 和 $\\Omega$ 隐式构造 $A = S C_h$。\n- 对每个测试，使用指定的种子初始化的伪随机数生成器，生成 $e \\in \\mathbb{R}^m$，其条目独立同分布于 $\\mathcal{N}(0,\\sigma^2)$。\n- 使用 FFT 和补零向量 $z = S^* e$ 计算 $g = A^* e$。\n- 通过评估 $|h|^2$ 与 $\\Omega$ 的二进制掩码的循环互相关，并取其最大值的平方根，来通过 FFT 计算 $\\|A\\|_{2,\\infty}$。\n- 设置 $\\lambda = \\sigma \\sqrt{2 \\log n} \\, \\|A\\|_{2,\\infty}$。\n- 返回比率 $r = \\|g\\|_\\infty / \\lambda$，作为浮点数，四舍五入到小数点后六位。\n\n测试套件规范：\n- 测试 1 (一般情况): $n = 64$, $m = 32$。集合 $\\Omega$ 是通过使用种子 $2$ 进行无放回均匀随机抽样 $m$ 个不同索引而选择的。向量 $h$ 具有使用种子 $1$ 生成的独立标准正态分布条目。噪声标准差为 $\\sigma = 0.1$，噪声 $e$ 使用种子 $3$ 生成。\n- 测试 2 (全循环，边界情况): $n = 64$, $m = 64$。集合 $\\Omega$ 等于 $\\{0,1,\\dots,63\\}$。向量 $h$ 具有使用种子 $4$ 生成的独立标准正态分布条目。噪声标准差为 $\\sigma = 0.2$，噪声 $e$ 使用种子 $5$ 生成。\n- 测试 3 (小 $m$，确定性滤波器): $n = 128$, $m = 8$。集合 $\\Omega$ 等于 $\\{0,1,\\dots,7\\}$。向量 $h$ 是确定性的，其条目为 $h[i] = \\exp(-i/20)$，其中 $i \\in \\{0,\\dots,127\\}$。噪声标准差为 $\\sigma = 0.05$，噪声 $e$ 使用种子 $6$ 生成。\n- 测试 4 (更密集的随机抽样): $n = 128$, $m = 80$。集合 $\\Omega$ 是通过使用种子 $8$ 进行无放回均匀随机抽样 $m$ 个不同索引而选择的。向量 $h$ 具有使用种子 $7$ 生成的独立标准正态分布条目。噪声标准差为 $\\sigma = 0.5$，噪声 $e$ 使用种子 $9$ 生成。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。第 $k$ 个条目必须是测试 $k$ 的比率 $r$，四舍五入到小数点后六位，因此输出格式为 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 表示为小数点后恰好有六位的小数。",
            "solution": "该问题被评估为有效，因为它科学地基于压缩感知和稀疏优化的原理，问题陈述清晰，目标明确，并为每个测试用例提供了完整且一致的设置。\n\n任务是分析一个结构化传感矩阵 $A = S C_h$，其中 $C_h$ 是一个循环卷积算子，$S$ 是一个行选择算子。我们必须开发并实现高效的算法，以计算与给定噪声向量 $e$ 的Dantzig选择器约束 $\\|A^* e\\|_\\infty \\le \\lambda$ 相关的量。\n\n### 推导计算 $g = A^* e$ 的 $\\mathcal{O}(n \\log n)$ 算法\n\n向量 $g$ 定义为 $g = A^* e$。传感矩阵为 $A = S C_h$，其中 $S$ 是行选择算子，$C_h$ 是循环卷积算子。伴随算子 $A^*$ 由伴随算子以相反顺序复合而成：\n$$A^* = (S C_h)^* = C_h^* S^*$$\n因此，我们需要计算 $g = C_h^* (S^* e)$。这个计算可以分两步进行。\n\n首先，我们将 $S^*$ 应用于向量 $e \\in \\mathbb{R}^m$。算子 $S$ 选择与集合 $\\Omega \\subset \\{0, \\dots, n-1\\}$ 中索引对应的 $m$ 行。其伴随算子 $S^*$ 是一个补零算子。它将一个向量 $e \\in \\mathbb{R}^m$ 映射到一个向量 $z \\in \\mathbb{R}^n$（或在一般情况下为 $\\mathbb{C}^n$）。$z$ 的条目由以下公式给出：\n$$\nz_i = \\begin{cases} e_j  \\text{if } i \\in \\Omega \\text{ (where } i \\text{ is the } j\\text{-th index in } \\Omega\\text{)} \\\\ 0  \\text{if } i \\notin \\Omega \\end{cases}\n$$\n此操作需要创建一个大小为 $n$ 的零向量并填充其 $m$ 个条目，这需要 $\\mathcal{O}(n)$ 的时间。\n\n其次，我们将 $C_h^*$ 应用于所得向量 $z$。问题陈述中提到，循环算子 $C_h$ 可由离散傅里叶变换 ($\\mathcal{F}$) 对角化。具体来说，$C_h = \\mathcal{F}^{-1} \\operatorname{diag}(\\widehat{h}) \\mathcal{F}$，其中 $\\widehat{h} = \\mathcal{F} h$ 是向量 $h \\in \\mathbb{C}^n$ 的DFT，$\\operatorname{diag}(\\widehat{h})$ 是对角线上为 $\\widehat{h}$ 的对角矩阵。其伴随算子为 $C_h^* = (\\mathcal{F}^{-1} \\operatorname{diag}(\\widehat{h}) \\mathcal{F})^* = \\mathcal{F}^* \\operatorname{diag}(\\widehat{h})^* (\\mathcal{F}^{-1})^*$。由于 $\\mathcal{F}^{-1} = \\frac{1}{n}\\mathcal{F}^*$，我们有 $\\mathcal{F}^* = n \\mathcal{F}^{-1}$。同时 $\\mathcal{F}^* = \\mathcal{F}^{-1 *}$。对于DFT矩阵，$\\mathcal{F}^*$ 是具有复共轭条目的矩阵。对角矩阵的伴随是复共轭的对角矩阵。因此，$C_h^* = \\mathcal{F}^{-1} \\operatorname{diag}(\\overline{\\widehat{h}}) \\mathcal{F}$，其中 $\\overline{\\widehat{h}}$ 表示 $\\widehat{h}$ 的逐元素复共轭。\n\n将此应用于 $z$，我们得到：\n$$g = C_h^* z = \\mathcal{F}^{-1} \\operatorname{diag}(\\overline{\\widehat{h}}) (\\mathcal{F} z)$$\n该表达式表明可以使用快速傅里叶变换 (FFT) 设计一个高效算法，它能在 $\\mathcal{O}(n \\log n)$ 时间内计算DFT及其逆变换。\n\n计算 $g = A^*e$ 的算法如下：\n1.  构造补零向量 $z = S^*e$。（$\\mathcal{O}(n)$）\n2.  使用FFT计算 $\\widehat{h} = \\mathcal{F} h$。（$\\mathcal{O}(n \\log n)$）\n3.  使用FFT计算 $\\widehat{z} = \\mathcal{F} z$。（$\\mathcal{O}(n \\log n)$）\n4.  在傅里叶域中执行逐元素乘积：$v = \\overline{\\widehat{h}} \\odot \\widehat{z}$。（$\\mathcal{O}(n)$）\n5.  通过逆FFT计算最终结果：$g = \\mathcal{F}^{-1} v$。（$\\mathcal{O}(n \\log n)$）\n\n总复杂度由FFT和IFFT步骤主导，因此整体复杂度为 $\\mathcal{O}(n \\log n)$。\n\n### 推导计算 $\\|A\\|_{2,\\infty}$ 的 $\\mathcal{O}(n \\log n)$ 算法\n\n量 $\\|A\\|_{2,\\infty}$ 是 $A$ 的列的最大 $\\ell_2$-范数。设 $a_j$ 为 $A$ 的第 $j$ 列，其中 $j \\in \\{0, \\dots, n-1\\}$。则 $\\|A\\|_{2,\\infty} = \\max_j \\|a_j\\|_2$。\n第 $j$ 列 $a_j$ 是通过将 $A$ 应用于第 $j$ 个标准基向量 $\\delta_j$ 得到的：\n$$a_j = A \\delta_j = S C_h \\delta_j$$\n$C_h$ 在 $\\delta_j$ 上的作用是循环卷积 $h \\circledast \\delta_j$，其结果是 $h$ 的一个循环移位版本。具体来说，$(h \\circledast \\delta_j)_k = h_{k-j \\pmod n}$。我们将这个移位后的向量表示为 $h^{(j)}$。因此，$C_h$ 的列是 $h$ 的循环移位版本。\n$A$ 的列 $a_j$ 因此是 $a_j = S h^{(j)}$，这是向量 $h^{(j)}$ 中仅保留由 $\\Omega$ 索引的条目后得到的向量。\n\n$a_j$ 的 $\\ell_2$-范数平方为：\n$$\\|a_j\\|_2^2 = \\sum_{k \\in \\Omega} |(h^{(j)})_k|^2 = \\sum_{k \\in \\Omega} |h_{k-j \\pmod n}|^2$$\n设 $p \\in \\{0, 1\\}^n$ 为集合 $\\Omega$ 的二进制掩码，即如果 $k \\in \\Omega$ 则 $p_k=1$，否则 $p_k=0$。设 $q \\in \\mathbb{R}^n$ 为 $h$ 的模的平方构成的向量，即 $q_k = |h_k|^2$。我们可以将该和重写为：\n$$\\|a_j\\|_2^2 = \\sum_{k=0}^{n-1} p_k q_{k-j \\pmod n}$$\n令 $l=k-j \\pmod n$，则 $k=l+j \\pmod n$。该和变为 $\\sum_{l=0}^{n-1} p_{l+j \\pmod n} q_l$。这是 $q$ 和 $p$ 在延迟 $j$ 处的循环互相关的定义：\n$$\\|a_j\\|_2^2 = (q \\star p)_j = \\sum_{l=0}^{n-1} q_l p_{l+j \\pmod n}$$（由于 $q$ 和 $p$ 都是实数，因此不需要对 $q_l$ 取复共轭）。\n\n相关定理（卷积定理的推论）指出，互相关的DFT是第一个信号的DFT的共轭与第二个信号的DFT的逐元素乘积：\n$$\\mathcal{F}(q \\star p) = \\overline{\\mathcal{F}(q)} \\odot \\mathcal{F}(p)$$\n设 $v$ 是一个向量，其中 $v_j = \\|a_j\\|_2^2$。则 $v = q \\star p$。我们可以高效地计算 $v$：\n$$v = \\mathcal{F}^{-1}(\\overline{\\mathcal{F}(q)} \\odot \\mathcal{F}(p))$$\n\n计算 $\\|A\\|_{2,\\infty}$ 的算法是：\n1.  构造向量 $q$，其条目为 $q_k = |h_k|^2$。（$\\mathcal{O}(n)$）\n2.  构造 $\\Omega$ 的二进制掩码向量 $p$。（$\\mathcal{O}(n)$）\n3.  使用FFT计算 $\\widehat{q} = \\mathcal{F}q$ 和 $\\widehat{p} = \\mathcal{F}p$。（$\\mathcal{O}(n \\log n)$）\n4.  执行逐元素乘积：$w = \\overline{\\widehat{q}} \\odot \\widehat{p}$。（$\\mathcal{O}(n)$）\n5.  通过逆FFT计算范数平方的向量：$v = \\mathcal{F}^{-1} w$。这应该是一个实向量；我们取其实部以消除数值噪声。（$\\mathcal{O}(n \\log n)$）\n6.  找到最大范数平方：$v_{\\max} = \\max_j v_j$。（$\\mathcal{O}(n)$）\n7.  最终结果是 $\\|A\\|_{2,\\infty} = \\sqrt{v_{\\max}}$。\n\n总复杂度为 $\\mathcal{O}(n \\log n)$。\n\n### Dantzig选择器参数 $\\lambda$ 的选择\n\nDantzig选择器约束为 $\\|A^*e\\|_\\infty \\le \\lambda$。向量 $g = A^*e$ 的分量为 $g_j = \\langle a_j, e \\rangle$。给定 $e \\in \\mathbb{R}^m$ 具有独立同分布的条目 $e_k \\sim \\mathcal{N}(0, \\sigma^2)$，每个 $g_j$ 都是一个均值为 $0$、方差为 $\\operatorname{Var}(g_j) = \\sigma^2 \\|a_j\\|_2^2$ 的高斯随机变量。\n\n问题指导我们使用从 $n$ 个随机变量 $g_j$ 的联合界（union bound）推导出的标准高概率界。这种方法导致选择的 $\\lambda$ 与 $g_j$ 的最大标准差成正比，并按与 $\\log n$ 相关的因子进行缩放。问题明确给出了形式：\n$$\\lambda = \\sigma \\sqrt{2 \\log n} \\, \\|A\\|_{2,\\infty}$$\n这种选择确保了约束 $\\|A^* e\\|_\\infty \\le \\lambda$ 以高概率成立。我们在实现中直接使用这个公式。计算出的比率 $r = \\|g\\|_\\infty / \\lambda$ 预期是一个随机变量，其值通常小于或等于 $1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_test_case(n, m, h, Omega, sigma, e_seed):\n    \"\"\"\n    Solves a single test case for the structured compressed sensing problem.\n\n    Args:\n        n (int): Ambient dimension.\n        m (int): Number of measurements.\n        h (np.ndarray): The filter for the circulant matrix, of shape (n,).\n        Omega (np.ndarray): The set of selected indices, of shape (m,).\n        sigma (float): Standard deviation of the Gaussian noise.\n        e_seed (int): Seed for the pseudorandom noise generator.\n\n    Returns:\n        float: The ratio r = ||A*e||_inf / lambda.\n    \"\"\"\n    # Generate the noise vector e\n    rng_e = np.random.default_rng(e_seed)\n    e = rng_e.normal(loc=0.0, scale=sigma, size=m)\n\n    # 1. Compute g = A*e using FFTs.\n    # A*e = C_h* S* e. First, compute z = S* e.\n    # Using complex type for z is important for general complex h.\n    z = np.zeros(n, dtype=np.complex128)\n    # Sort Omega to ensure deterministic mapping, although not strictly needed\n    # for random choice since order is fixed by rng.choice.\n    Omega.sort() \n    z[Omega] = e\n    \n    # Compute g = F_inv(conj(F(h)) * F(z))\n    h_fft = np.fft.fft(h)\n    z_fft = np.fft.fft(z)\n    g_fft = np.conj(h_fft) * z_fft\n    g = np.fft.ifft(g_fft)\n    \n    # Compute the infinity norm of g\n    norm_g_inf = np.max(np.abs(g))\n\n    # 2. Compute ||A||_{2,inf} using FFTs via cross-correlation.\n    # The squared column norms are given by the circular cross-correlation\n    # of q = |h|^2 with p = mask of Omega.\n    q = np.abs(h)**2\n    p = np.zeros(n)\n    p[Omega] = 1.0\n    \n    # Use correlation theorem: F(q star p) = conj(F(q)) * F(p)\n    q_fft = np.fft.fft(q)\n    p_fft = np.fft.fft(p)\n    col_norms_sq_fft = np.conj(q_fft) * p_fft\n    col_norms_sq = np.fft.ifft(col_norms_sq_fft)\n    \n    # The result must be real. Take the real part to discard numerical noise.\n    # Max value of this vector is max(||a_j||_2^2).\n    max_col_norm_sq = np.max(col_norms_sq.real)\n    norm_A_2_inf = np.sqrt(max_col_norm_sq)\n\n    # 3. Set lambda based on the derived quantities.\n    lambda_val = sigma * np.sqrt(2 * np.log(n)) * norm_A_2_inf\n    \n    # 4. Compute the final ratio r.\n    # Handle the case where lambda_val might be zero to avoid division by zero.\n    if lambda_val == 0:\n        r = 0.0 if norm_g_inf == 0 else np.inf\n    else:\n        r = norm_g_inf / lambda_val\n    \n    return r\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run them, and print the results.\n    \"\"\"\n    test_specs = [\n        {'n': 64, 'm': 32, 'h_type': 'random', 'h_seed': 1, 'omega_type': 'random', 'omega_seed': 2, 'sigma': 0.1, 'e_seed': 3},\n        {'n': 64, 'm': 64, 'h_type': 'random', 'h_seed': 4, 'omega_type': 'full', 'sigma': 0.2, 'e_seed': 5},\n        {'n': 128, 'm': 8, 'h_type': 'deterministic', 'omega_type': 'contiguous', 'omega_start': 0, 'sigma': 0.05, 'e_seed': 6},\n        {'n': 128, 'm': 80, 'h_type': 'random', 'h_seed': 7, 'omega_type': 'random', 'omega_seed': 8, 'sigma': 0.5, 'e_seed': 9},\n    ]\n\n    results = []\n    for spec in test_specs:\n        n, m, sigma, e_seed = spec['n'], spec['m'], spec['sigma'], spec['e_seed']\n        \n        # Generate h vector\n        if spec['h_type'] == 'random':\n            rng_h = np.random.default_rng(spec['h_seed'])\n            h = rng_h.standard_normal(n)\n        else: # deterministic\n            h = np.exp(-np.arange(n) / 20.0)\n            \n        # Generate Omega index set\n        if spec['omega_type'] == 'random':\n            rng_omega = np.random.default_rng(spec['omega_seed'])\n            Omega = rng_omega.choice(n, m, replace=False)\n        elif spec['omega_type'] == 'full':\n            Omega = np.arange(n)\n        else: # contiguous\n            Omega = np.arange(spec['omega_start'], spec['omega_start'] + m)\n        \n        r = run_test_case(n, m, h, Omega, sigma, e_seed)\n        results.append(f\"{r:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们的最终目标是解决大规模的稀疏恢复问题。交替方向乘子法（ADMM）是解决此类问题的一个强大框架，但其效率取决于能否快速求解其子问题。在最后的这个实践中 ，您将把高效的 FFT 运算集成到一个完整的 ADMM 求解器中，用于解决基追踪（Basis Pursuit）问题。您将看到，傅里叶变换对循环矩阵的对角化特性，如何使得 ADMM 中涉及矩阵求逆的投影步骤在计算上变得可行，从而将一个复杂的优化问题转化为一系列高效的计算步骤。",
            "id": "3490941",
            "problem": "考虑压缩感知中的约束基追踪问题：最小化信号的逐项一范数，约束条件为精确的线性测量，\n$$\n\\min_{x \\in \\mathbb{R}^n} \\ \\|x\\|_1 \\quad \\text{subject to} \\quad A x = y,\n$$\n其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个实值循环传感矩阵，由一个实核 $a \\in \\mathbb{R}^n$ 通过循环卷积生成。循环矩阵 $A$ 代表线性算子 $x \\mapsto a \\star x$（循环卷积），并且可由离散傅里叶变换 (DFT) 对角化。令 $F \\in \\mathbb{C}^{n \\times n}$ 表示酉DFT矩阵，其元素为\n$$\nF_{k\\ell} = \\frac{1}{\\sqrt{n}} \\exp\\left(-\\mathrm{i} \\frac{2\\pi k \\ell}{n}\\right), \\quad 0 \\le k,\\ell \\le n-1,\n$$\n因此 $A$ 具有傅里叶对角化形式\n$$\nA = F^{\\ast} \\ \\mathrm{diag}(\\widehat{a}) \\ F,\n$$\n其中 $\\widehat{a} = F a$ 是 $a$ 的DFT，而 $F^{\\ast}$ 是 $F$ 的共轭转置。这意味着 $A x = F^{\\ast} \\left( \\widehat{a} \\odot (F x) \\right)$ 和 $A^{\\top} r = F^{\\ast} \\left( \\overline{\\widehat{a}} \\odot (F r) \\right)$，其中 $\\odot$ 表示逐元素乘法，$\\overline{\\widehat{a}}$ 是复共轭。此外，$A A^{\\top} = F^{\\ast} \\ \\mathrm{diag}(|\\widehat{a}|^2) \\ F$，因此当 $|\\widehat{a}|$ 的所有项都严格为正时，$(A A^{\\top})^{-1}$ 在傅里叶域中是对角的。\n\n要求您实现交替方向乘子法 (ADMM) 来求解约束基追踪问题，利用循环结构通过快速傅里叶变换 (FFT) 高效地计算更新。使用如下分裂方法\n$$\n\\min_{x,z \\in \\mathbb{R}^n} \\ \\underbrace{I_{\\{u \\in \\mathbb{R}^n : A u = y\\}}(x)}_{f(x)} + \\underbrace{\\|z\\|_1}_{g(z)} \\quad \\text{subject to} \\quad x = z,\n$$\n其中 $I_{\\mathcal{C}}$ 是集合 $\\mathcal{C}$ 的指示函数，并应用带有参数 $\\rho  0$ 的缩放形式ADMM。需要使用的基本要素如下：\n- 一范数的近端算子是逐项软阈值：对于 $\\lambda  0$，\n$$\n\\mathrm{prox}_{\\lambda \\|\\cdot\\|_1}(v)_i = \\mathrm{sign}(v_i) \\cdot \\max\\{|v_i| - \\lambda, 0\\}.\n$$\n- 到仿射子空间 $\\{x \\in \\mathbb{R}^n : A x = y\\}$ 上的欧几里得范数投影由下式给出\n$$\n\\Pi_{\\{A x = y\\}}(w) = w + A^{\\top} (A A^{\\top})^{-1} (y - A w).\n$$\n- 循环矩阵可由DFT对角化，因此与 $A$、$A^{\\top}$ 和 $(A A^{\\top})^{-1}$ 的乘积可以通过FFT计算。\n\n从第一性原理推导 $x$、$z$ 和缩放对偶变量 $u$ 的ADMM更新过程，展示每一步如何计算，并说明为什么对于循环矩阵 $A$，FFT可以实现高效计算。特别地，将 $x$ 的更新表示为利用 $A A^{\\top}$ 在傅里叶域中的对角化到仿射集上的投影，并将 $z$ 的更新表示为软阈值。阐明缩放对偶变量的作用以及基于原始残差和对偶残差的停止准则。\n\n然后实现一个完整的、可运行的程序，该程序：\n- 通过核 $a$ 隐式地构建循环矩阵，并使用FFT计算所有必需的线性运算。\n- 使用前述分裂方法，通过ADMM求解约束基追踪问题。\n- 在 $A A^{\\top}$ 的求逆中使用一个小的岭参数 $\\gamma \\ge 0$ 来处理潜在的近奇异情况，即用 $(A A^{\\top} + \\gamma I)^{-1}$ 替换 $(A A^{\\top})^{-1}$，这在傅里叶域中仍然是对角的。\n- 在以下包含三种情况的测试套件上验证解决方案，每种情况由 $(n, a, x^{\\star})$ 指定，其中 $y = A x^{\\star}$：\n  1. 一个常规的“顺利”情况：$n = 64$。选择 $a \\in \\mathbb{R}^n$，其元素为独立的标准正态分布。选择 $x^{\\star}$ 为一个3-稀疏向量，其非零项在随机位置上从标准正态分布中抽取。设置 $\\gamma = 10^{-12}$ 和 $\\rho = 1$。\n  2. 一个边界情况（单位算子）：$n = 32$。令 $a = e_1 \\in \\mathbb{R}^n$（第一个标准基向量），这会得到 $A = I_n$。选择任意一个5-稀疏的 $x^{\\star}$，其非零项在随机位置上从标准正态分布中抽取。设置 $\\gamma = 0$ 和 $\\rho = 1$。\n  3. 一个边缘情况（近奇异谱）：$n = 64$。选择 $a$ 使得 $a_0 = 10^{-3}$，$a_1 = 1$，且对于 $k \\ge 2$ 有 $a_k = 0$。选择 $x^{\\star}$ 为一个4-稀疏向量，其非零项在随机位置上从标准正态分布中抽取。设置 $\\gamma = 10^{-8}$ 和 $\\rho = 1$。\n\n对于每个测试用例，运行ADMM直到收敛或达到固定的迭代上限。当且仅当以下两个条件都满足时，声明成功：\n- 相对恢复误差满足\n$$\n\\frac{\\|x^{(K)} - x^{\\star}\\|_2}{\\max\\{\\|x^{\\star}\\|_2, 10^{-12}\\}} \\le 10^{-3},\n$$\n其中 $x^{(K)}$ 是最终的ADMM估计。\n- 测量残差满足\n$$\n\\|A x^{(K)} - y\\|_2 \\le 10^{-8}.\n$$\n\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为方括号内以逗号分隔的列表（例如，“[true_case1,true_case2,true_case3]”），其中每个条目都是一个布尔值，表示该用例是否成功。角度和物理单位不适用；所有量都纯粹是数学量。除此单行输出外，不要打印任何其他内容。",
            "solution": "该问题要求推导并实现交替方向乘子法（ADMM），以解决约束基追踪问题，并利用传感矩阵 $A$ 的循环结构，通过快速傅里叶变换（FFT）来提高计算效率。\n\n优化问题是：\n$$\n\\min_{x \\in \\mathbb{R}^n} \\|x\\|_1 \\quad \\text{subject to} \\quad A x = y\n$$\n这里，$A \\in \\mathbb{R}^{n \\times n}$ 是由核 $a \\in \\mathbb{R}^n$ 生成的循环矩阵，使得运算 $Ax$ 对应于循环卷积 $a \\star x$。\n\n为了应用ADMM，我们引入一个分裂变量 $z \\in \\mathbb{R}^n$ 和一个辅助约束 $x=z$。问题被重新表述为：\n$$\n\\min_{x,z \\in \\mathbb{R}^n} f(x) + g(z) \\quad \\text{subject to} \\quad x - z = 0\n$$\n其中 $f(x) = I_{\\{u \\in \\mathbb{R}^n : A u = y\\}}(x)$ 是测量一致性仿射集的指示函数，$g(z) = \\|z\\|_1$ 是促进稀疏性的一范数。指示函数 $I_{\\mathcal{C}}(x)$ 在 $x \\in \\mathcal{C}$ 时为 $0$，否则为 $+\\infty$。\n\n对于这个问题，带有惩罚参数 $\\rho  0$ 和缩放对偶变量 $u$ 的缩放形式增广拉格朗日量是：\n$$\n\\mathcal{L}_{\\rho}(x, z, u) = f(x) + g(z) + \\frac{\\rho}{2} \\|x - z + u\\|_2^2 - \\frac{\\rho}{2} \\|u\\|_2^2\n$$\nADMM通过交替最小化关于 $x$ 和 $z$ 的 $\\mathcal{L}_{\\rho}$，然后更新对偶变量 $u$ 来进行。在第 $k+1$ 次迭代时的更新序列是：\n1.  $x^{(k+1)} := \\arg\\min_x \\mathcal{L}_{\\rho}(x, z^{(k)}, u^{(k)})$\n2.  $z^{(k+1)} := \\arg\\min_z \\mathcal{L}_{\\rho}(x^{(k+1)}, z, u^{(k)})$\n3.  $u^{(k+1)} := u^{(k)} + x^{(k+1)} - z^{(k+1)}$\n\n我们现在详细推导每个更新步骤。\n\n**1. x-更新**\n\n关于 $x$ 的最小化是：\n$$\nx^{(k+1)} = \\arg\\min_x \\left( I_{\\{x : Ax=y\\}}(x) + \\frac{\\rho}{2} \\|x - z^{(k)} + u^{(k)}\\|_2^2 \\right)\n$$\n此更新等价于寻找一个点 $x$，该点满足约束 $Ax=y$，同时在欧几里得意义上最接近向量 $w^{(k)} = z^{(k)} - u^{(k)}$。这正是 $w^{(k)}$ 到仿射子空间 $\\mathcal{C} = \\{x \\in \\mathbb{R}^n : A x = y\\}$ 上的正交投影。\n$$\nx^{(k+1)} = \\Pi_{\\mathcal{C}}(w^{(k)})\n$$\n该投影的公式为 $\\Pi_{\\mathcal{C}}(w) = w + A^{\\top} (A A^{\\top})^{-1} (y - A w)$。为了处理潜在的奇异或病态的 $A A^{\\top}$，增加了一个小的岭参数 $\\gamma \\ge 0$，从而得到正则化投影：\n$$\nx^{(k+1)} = w^{(k)} + A^{\\top}(A A^{\\top} + \\gamma I)^{-1}(y - A w^{(k)})\n$$\n这一步的效率来源于 $A$ 的循环结构。循环矩阵可由离散傅里叶变换对角化。令 $\\text{fft}(\\cdot)$ 和 $\\text{ifft}(\\cdot)$ 表示快速傅里叶变换及其逆变换。循环卷积性质表明 $a \\star x = \\text{ifft}(\\text{fft}(a) \\odot \\text{fft}(x))$，其中 $\\odot$ 是逐元素乘法。令 $\\hat{v} = \\text{fft}(v)$。\n-   $A$ 的作用是 $Ax = \\text{ifft}(\\hat{a} \\odot \\hat{x})$。\n-   转置矩阵 $A^{\\top}$（它是由翻转的核生成的循环矩阵）的作用对应于 $A^{\\top}r = \\text{ifft}(\\overline{\\hat{a}} \\odot \\hat{r})$，其中 $\\overline{\\hat{a}}$ 是 $\\hat{a}$ 的复共轭。\n-   算子 $AA^{\\top}$ 对应于在傅里叶域中乘以 $\\hat{a} \\odot \\overline{\\hat{a}} = |\\hat{a}|^2$。\n-   算子 $(AA^{\\top} + \\gamma I)$ 对应于在傅里叶域中乘以 $|\\hat{a}|^2 + \\gamma$。\n-   因此，逆算子 $(AA^{\\top} + \\gamma I)^{-1}$ 对应于在傅里叶域中逐元素除以 $|\\hat{a}|^2 + \\gamma$。\n\n令 $r^{(k)} = y - A w^{(k)}$。校正项 $c^{(k)} = A^{\\top}(A A^{\\top} + \\gamma I)^{-1} r^{(k)}$ 可以被高效计算。\n首先，将逆算子应用于 $r^{(k)}$：$v^{(k)} = (A A^{\\top} + \\gamma I)^{-1} r^{(k)}$。在傅里叶域中，这表示为 $\\hat{v}^{(k)} = \\hat{r}^{(k)} \\oslash (|\\hat{a}|^2 + \\gamma)$，其中 $\\oslash$ 表示逐元素除法。\n然后，将 $A^\\top$ 应用于 $v^{(k)}$：$c^{(k)} = A^\\top v^{(k)}$。在傅里叶域中，这表示为 $\\hat{c}^{(k)} = \\overline{\\hat{a}} \\odot \\hat{v}^{(k)}$。\n结合这些，校正项的傅里叶变换是：\n$$\n\\hat{c}^{(k)} = \\overline{\\hat{a}} \\odot \\left( \\frac{\\text{fft}(y - A w^{(k)})}{|\\hat{a}|^2 + \\gamma} \\right)\n$$\n完整的 $x$-更新包括计算 $w^{(k)} = z^{(k)} - u^{(k)}$，然后计算 $c^{(k)} = \\text{ifft}(\\hat{c}^{(k)})$，最后设置 $x^{(k+1)} = w^{(k)} + c^{(k)}$。由于所有输入向量都是实数，更新后的 $x^{(k+1)}$ 也必须是实数；任何虚部都是由数值噪声引起的，应当被舍弃。\n\n**2. z-更新**\n\n关于 $z$ 的最小化是：\n$$\nz^{(k+1)} = \\arg\\min_z \\left( \\|z\\|_1 + \\frac{\\rho}{2} \\|x^{(k+1)} - z + u^{(k)}\\|_2^2 \\right)\n$$\n整理二次项得到：\n$$\nz^{(k+1)} = \\arg\\min_z \\left( \\|z\\|_1 + \\frac{\\rho}{2} \\|z - (x^{(k+1)} + u^{(k)})\\|_2^2 \\right)\n$$\n这是一范数近端算子的定义。具体来说，它是 $\\mathrm{prox}_{\\frac{1}{\\rho}\\|\\cdot\\|_1}(x^{(k+1)} + u^{(k)})$。$\\lambda \\|\\cdot\\|_1$ 的近端算子是逐元素软阈值算子 $S_{\\lambda}(v)_i = \\mathrm{sign}(v_i) \\max(|v_i| - \\lambda, 0)$。对于我们的问题，函数是 $1 \\cdot \\|\\cdot\\|_1$，惩罚参数是 $\\rho/2$，这对应于一个 $1/\\rho$ 的近端参数。\n因此，更新由逐项软阈值给出：\n$$\nz^{(k+1)} = S_{1/\\rho}(x^{(k+1)} + u^{(k)})\n$$\n\n**3. u-更新**\n\n缩放对偶变量 $u$ 的更新很简单：\n$$\nu^{(k+1)} = u^{(k)} + x^{(k+1)} - z^{(k+1)}\n$$\n这一步强制执行约束 $x=z$。项 $x^{(k+1)} - z^{(k+1)}$ 是当前迭代的原始残差。\n\n**停止准则**\n\nADMM的收敛性可以通过原始残差和对偶残差来监控。原始残差是 $r_{\\text{primal}}^{(k+1)} = x^{(k+1)} - z^{(k+1)}$，衡量了对约束 $x-z=0$ 的违反程度。对偶残差 $r_{\\text{dual}}^{(k+1)} = \\rho A^\\top A (z^{(k+1)} - z^{(k)})$，衡量了对偶目标的变化。在实践中，通常使用一个更简单的形式 $r_{\\text{dual}}^{(k+1)} = \\rho(z^{(k+1)} - z^{(k)})$。当两个残差的范数都低于某个容差时，算法被认为已经收敛。对于当前问题，我们运行算法固定的迭代次数，然后根据指定的质量标准检查最终解。\n对偶变量 $u$ 可以被解释为原始误差的累加和，提供一个积分式的校正，将原始残差驱动至零。\n\n**算法总结**\n初始化 $x^{(0)}$、$z^{(0)}$、$u^{(0)}$（例如，设为零向量），并选择 $\\rho  0$、$\\gamma  0$。对于 $k=0, 1, 2, \\ldots$\n1.  $w^{(k)} = z^{(k)} - u^{(k)}$\n2.  $r^{(k)} = y - \\text{ifft}(\\hat{a} \\odot \\text{fft}(w^{(k)}))$\n3.  $\\hat{c}^{(k)} = \\overline{\\hat{a}} \\odot \\text{fft}(r^{(k)}) \\oslash (|\\hat{a}|^2 + \\gamma)$\n4.  $c^{(k)} = \\text{ifft}(\\hat{c}^{(k)})$\n5.  $x^{(k+1)} = \\text{real}(w^{(k)} + c^{(k)})$\n6.  $v^{(k)} = x^{(k+1)} + u^{(k)}$\n7.  $z^{(k+1)} = \\text{sign}(v^{(k)}) \\odot \\max(\\text{abs}(v^{(k)}) - 1/\\rho, 0)$\n8.  $u^{(k+1)} = u^{(k)} + x^{(k+1)} - z^{(k+1)}$\n这个迭代过程被实现来解决给定的问题。",
            "answer": "```python\nimport numpy as np\nfrom numpy.fft import fft, ifft\n\ndef admm_basis_pursuit(a, y, rho, gamma, max_iter=1000):\n    \"\"\"\n    Solves the constrained Basis Pursuit problem using ADMM.\n\n    min ||x||_1 subject to Ax=y, where A is a circulant matrix.\n\n    Args:\n        a (np.ndarray): The real kernel generating the circulant matrix A.\n        y (np.ndarray): The measurement vector.\n        rho (float): The ADMM penalty parameter.\n        gamma (float): The ridge regularization parameter for matrix inversion.\n        max_iter (int): The maximum number of iterations.\n\n    Returns:\n        np.ndarray: The estimated sparse signal x.\n    \"\"\"\n    n = len(a)\n    \n    # Pre-compute Fourier transform of the kernel and related quantities\n    a_hat = fft(a)\n    a_hat_conj = np.conj(a_hat)\n    a_hat_mag_sq = np.abs(a_hat)**2\n\n    # Denominator for the x-update, pre-computed for efficiency\n    x_update_denom = a_hat_mag_sq + gamma\n\n    # Initialize variables\n    x = np.zeros(n)\n    z = np.zeros(n)\n    u = np.zeros(n)\n\n    # Soft-thresholding lambda\n    lambda_st = 1.0 / rho\n\n    for _ in range(max_iter):\n        # x-update (projection onto {x | Ax=y})\n        w = z - u\n        \n        # Aw = ifft(fft(a) * fft(w))\n        Aw = np.real(ifft(a_hat * fft(w)))\n        \n        # residual r = y - Aw\n        r = y - Aw\n        \n        # FFT of residual\n        r_hat = fft(r)\n        \n        # Correction term in Fourier domain\n        # c_hat = conj(a_hat) * r_hat / (|a_hat|^2 + gamma)\n        c_hat = a_hat_conj * r_hat / x_update_denom\n        \n        # Correction term in signal domain\n        c = np.real(ifft(c_hat))\n        \n        x = w + c\n\n        # z-update (soft-thresholding)\n        v = x + u\n        z = np.sign(v) * np.maximum(np.abs(v) - lambda_st, 0)\n        \n        # u-update (dual variable update)\n        u = u + x - z\n        \n    return x\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    rng = np.random.default_rng(42)  # Seed for reproducibility\n    results = []\n\n    # --- Test Case 1: General \"happy path\" case ---\n    n1 = 64\n    k1 = 3\n    a1 = rng.standard_normal(n1)\n    x_star1 = np.zeros(n1)\n    indices1 = rng.choice(n1, k1, replace=False)\n    x_star1[indices1] = rng.standard_normal(k1)\n    y1 = np.real(ifft(fft(a1) * fft(x_star1)))\n    gamma1 = 1e-12\n    rho1 = 1.0\n\n    x_final1 = admm_basis_pursuit(a1, y1, rho1, gamma1)\n    \n    err_norm1 = np.linalg.norm(x_final1 - x_star1)\n    x_star_norm1 = np.linalg.norm(x_star1)\n    rel_err1 = err_norm1 / max(x_star_norm1, 1e-12)\n    \n    y_final1 = np.real(ifft(fft(a1) * fft(x_final1)))\n    res_norm1 = np.linalg.norm(y_final1 - y1)\n    \n    success1 = rel_err1 = 1e-3 and res_norm1 = 1e-8\n    results.append(success1)\n    \n    # --- Test Case 2: Boundary case (identity operator) ---\n    n2 = 32\n    k2 = 5\n    a2 = np.zeros(n2)\n    a2[0] = 1.0  # a = e_1 => A = I\n    x_star2 = np.zeros(n2)\n    indices2 = rng.choice(n2, k2, replace=False)\n    x_star2[indices2] = rng.standard_normal(k2)\n    y2 = np.real(ifft(fft(a2) * fft(x_star2))) # y2 = x_star2\n    gamma2 = 0.0\n    rho2 = 1.0\n    \n    # For A=I, problem is min ||x||_1 s.t. x=y. Solution is x=y.\n    # ADMM should converge very quickly.\n    x_final2 = admm_basis_pursuit(a2, y2, rho2, gamma2, max_iter=20)\n    \n    err_norm2 = np.linalg.norm(x_final2 - x_star2)\n    x_star_norm2 = np.linalg.norm(x_star2)\n    rel_err2 = err_norm2 / max(x_star_norm2, 1e-12)\n    \n    y_final2 = np.real(ifft(fft(a2) * fft(x_final2)))\n    res_norm2 = np.linalg.norm(y_final2 - y2)\n    \n    success2 = rel_err2 = 1e-3 and res_norm2 = 1e-8\n    results.append(success2)\n\n    # --- Test Case 3: Edge case (near singular spectrum) ---\n    n3 = 64\n    k3 = 4\n    a3 = np.zeros(n3)\n    a3[0] = 1e-3\n    a3[1] = 1.0\n    x_star3 = np.zeros(n3)\n    indices3 = rng.choice(n3, k3, replace=False)\n    x_star3[indices3] = rng.standard_normal(k3)\n    y3 = np.real(ifft(fft(a3) * fft(x_star3)))\n    gamma3 = 1e-8\n    rho3 = 1.0\n    \n    x_final3 = admm_basis_pursuit(a3, y3, rho3, gamma3, max_iter=2000)\n    \n    err_norm3 = np.linalg.norm(x_final3 - x_star3)\n    x_star_norm3 = np.linalg.norm(x_star3)\n    rel_err3 = err_norm3 / max(x_star_norm3, 1e-12)\n    \n    y_final3 = np.real(ifft(fft(a3) * fft(x_final3)))\n    res_norm3 = np.linalg.norm(y_final3 - y3)\n    \n    success3 = rel_err3 = 1e-3 and res_norm3 = 1e-8\n    results.append(success3)\n    \n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```"
        }
    ]
}