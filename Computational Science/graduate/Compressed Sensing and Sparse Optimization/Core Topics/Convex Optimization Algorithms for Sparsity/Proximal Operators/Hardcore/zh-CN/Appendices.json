{
    "hands_on_practices": [
        {
            "introduction": "本练习将带你计算一个在机器学习和统计学中至关重要的函数——负熵函数的近端算子。这个练习不仅能让你从头开始推导出其解析解，还能揭示它与朗伯W函数 (Lambert W function) 的联系。此外，通过这个过程 ，你将理解它与保持非负性的乘性更新算法之间的深刻关系。",
            "id": "3470855",
            "problem": "设 $\\lambda > 0$，定义可分凸函数 $f : \\mathbb{R}^{n} \\to \\mathbb{R} \\cup \\{+\\infty\\}$ 如下：\n$$\nf(x) \\triangleq \\lambda \\sum_{i=1}^{n} \\big(x_{i} \\ln x_{i} - x_{i}\\big) + \\iota_{\\{x \\in \\mathbb{R}^{n} : x \\ge 0\\}}(x),\n$$\n其中 $\\iota_{\\{x \\ge 0\\}}$ 是非负象限的指示函数，并且 $x \\ln x$ 通过在 $x=0$ 处的连续性进行扩展，使得当 $x \\downarrow 0$ 时，$x \\ln x \\to 0$。考虑在给定点 $y \\in \\mathbb{R}^{n}$ 处 $f$ 的近端算子：\n$$\n\\operatorname{prox}_{f}(y) \\triangleq \\arg\\min_{x \\in \\mathbb{R}^{n}} \\left\\{ \\frac{1}{2} \\|x - y\\|_{2}^{2} + f(x) \\right\\}.\n$$\n仅从近端算子的定义、凸函数的基本性质以及标准的一阶最优性条件出发，完成以下任务：\n\n- 证明该最小化问题按坐标可分，并且唯一最小化子满足对所有 $i \\in \\{1,\\dots,n\\}$ 都有 $x_{i}^{\\star} > 0$。\n\n- 推导每个坐标的最优性条件，并根据需要使用标准的特殊函数以闭式形式求解，从而得到 $\\operatorname{prox}_{f}(y)$ 作为 $y$ 和 $\\lambda$ 的函数的显式解析公式。\n\n- 展示如何将标量最优性条件重排为 $x_{i} = c_{i} \\exp(-x_{i}/\\lambda)$ 类型的不动点形式（其中 $c_{i} > 0$），并解释这如何产生一个收敛到近端点的乘性更新迭代 $x_{i}^{(t+1)} = c_{i} \\exp\\!\\big(-x_{i}^{(t)}/\\lambda\\big)$。简要讨论这种乘性结构与基于负熵正则化和 Kullback–Leibler 散度 (KLD) 的算法之间的关系。\n\n- 当所得项非常小（即 $x_{i}^{\\star} \\ll 1$）时，分析计算您的闭式表达式的数值稳定性。在产生 $x_{i}^{\\star} \\to 0^{+}$ 的情况下，给出 $x_{i}^{\\star}$ 关于 $y_{i}$ 和 $\\lambda$ 的主阶渐近展开，并讨论在该情况下的数值稳定计算策略。\n\n您的最终答案必须是 $\\operatorname{prox}_{f}(y)$ 关于 $y$ 和 $\\lambda$ 的单个闭式解析表达式（您可以使用标准的特殊函数）。不要包含任何单位。不要提供不等式或方程作为最终答案。",
            "solution": "该问题陈述经核实具有科学依据、适定且客观。这是一个关于负熵正则化子近端算子的凸优化标准问题。所有定义和条件均已提供，不存在矛盾或歧义。该问题可使用已建立的数学原理解答。\n\n目标是计算函数 $f : \\mathbb{R}^{n} \\to \\mathbb{R} \\cup \\{+\\infty\\}$ 的近端算子，其定义为\n$$\nf(x) \\triangleq \\lambda \\sum_{i=1}^{n} \\big(x_{i} \\ln x_{i} - x_{i}\\big) + \\iota_{\\{x \\in \\mathbb{R}^{n} : x \\ge 0\\}}(x)\n$$\n对于参数 $\\lambda > 0$。在点 $y \\in \\mathbb{R}^{n}$ 处的近端算子定义为\n$$\n\\operatorname{prox}_{f}(y) \\triangleq \\arg\\min_{x \\in \\mathbb{R}^{n}} \\left\\{ \\frac{1}{2} \\|x - y\\|_{2}^{2} + f(x) \\right\\}.\n$$\n设该最小化问题的目标函数为 $G(x)$。代入 $f(x)$ 的定义，我们有\n$$\nG(x) = \\frac{1}{2} \\|x - y\\|_{2}^{2} + \\lambda \\sum_{i=1}^{n} \\big(x_{i} \\ln x_{i} - x_{i}\\big) + \\iota_{\\{x \\ge 0\\}}(x).\n$$\n指示函数 $\\iota_{\\{x \\ge 0\\}}(x)$ 将最小化的定义域限制在非负象限，即对所有 $i=1, \\dots, n$ 都有 $x_i \\ge 0$。\n\n**解的可分性与正性**\n\n通过展开欧几里得范数的平方，目标函数 $G(x)$ 可以写成可分形式：\n$$\nG(x) = \\frac{1}{2} \\sum_{i=1}^{n} (x_i - y_i)^2 + \\lambda \\sum_{i=1}^{n} (x_i \\ln x_i - x_i)\n$$\n约束条件为对所有 $i$ 都有 $x_i \\ge 0$。可以将求和项合并：\n$$\nG(x) = \\sum_{i=1}^{n} \\left( \\frac{1}{2} (x_i - y_i)^2 + \\lambda (x_i \\ln x_i - x_i) \\right).\n$$\n令 $g_i(x_i) = \\frac{1}{2} (x_i - y_i)^2 + \\lambda (x_i \\ln x_i - x_i)$。总的最小化问题 $\\min_{x \\ge 0} G(x)$ 分解为 $n$ 个独立的标量最小化问题：\n$$\n\\min_{x_i \\ge 0} g_i(x_i) \\quad \\text{对每个 } i \\in \\{1, \\dots, n\\}.\n$$\n这证明了该最小化问题按坐标可分。\n\n为了证明唯一最小化子 $x_i^\\star$ 是严格正的，我们分析标量函数 $g_i(x_i)$（对于 $x_i \\ge 0$）。函数 $\\phi(t) = t \\ln t - t$ 在 $t>0$ 时是严格凸的。其二阶导数为 $\\phi''(t) = 1/t > 0$。函数 $\\frac{1}{2}(x_i-y_i)^2$ 也是严格凸的。由于 $\\lambda > 0$， $g_i(x_i)$ 是一个严格凸函数和一个凸函数的和，因此它在其定义域 $\\{x_i : x_i \\ge 0\\}$ 上是严格凸的。一个严格凸函数在闭凸集上有一个唯一的最小值。\n\n我们考察当 $x_i > 0$ 时 $g_i(x_i)$ 的导数：\n$$\ng_i'(x_i) = \\frac{d}{dx_i} \\left( \\frac{1}{2}(x_i - y_i)^2 + \\lambda(x_i \\ln x_i - x_i) \\right) = (x_i - y_i) + \\lambda(\\ln x_i + 1 - 1) = x_i - y_i + \\lambda \\ln x_i.\n$$\n我们考虑当 $x_i$ 从右侧趋近于 $0$ 时导数的极限：\n$$\n\\lim_{x_i \\to 0^+} g_i'(x_i) = \\lim_{x_i \\to 0^+} (x_i - y_i + \\lambda \\ln x_i) = -\\infty.\n$$\n由于当 $x_i$ 的值接近 $0$ 时导数为负，函数 $g_i(x_i)$ 在 $x_i$ 趋近于 $0$ 时是递减的。因此，最小值不可能出现在边界点 $x_i=0$ 处。唯一的最小化子 $x_i^\\star$ 必须位于定义域的内部，即 $x_i^\\star > 0$。\n\n**闭式解的推导**\n\n由于最小化子 $x_i^\\star$ 是正的，它必须满足一阶最优性条件 $g_i'(x_i^\\star) = 0$：\n$$\nx_i^\\star - y_i + \\lambda \\ln x_i^\\star = 0.\n$$\n这个超越方程可以求解 $x_i^\\star$。整理各项，我们得到：\n$$\n\\lambda \\ln x_i^\\star + x_i^\\star = y_i.\n$$\n为了求解该方程，我们将其化为与朗伯 W 函数相容的形式，该函数由关系式 $W(z) \\exp(W(z)) = z$ 定义。\n将方程两边除以 $\\lambda$：\n$$\n\\ln x_i^\\star + \\frac{x_i^\\star}{\\lambda} = \\frac{y_i}{\\lambda}.\n$$\n对两边取指数可得：\n$$\n\\exp\\left(\\ln x_i^\\star + \\frac{x_i^\\star}{\\lambda}\\right) = \\exp\\left(\\frac{y_i}{\\lambda}\\right)\n$$\n$$\n\\exp(\\ln x_i^\\star) \\exp\\left(\\frac{x_i^\\star}{\\lambda}\\right) = \\exp\\left(\\frac{y_i}{\\lambda}\\right)\n$$\n$$\nx_i^\\star \\exp\\left(\\frac{x_i^\\star}{\\lambda}\\right) = \\exp\\left(\\frac{y_i}{\\lambda}\\right).\n$$\n为了匹配 $Z \\exp(Z) = C$ 的形式，我们乘以 $1/\\lambda$：\n$$\n\\frac{x_i^\\star}{\\lambda} \\exp\\left(\\frac{x_i^\\star}{\\lambda}\\right) = \\frac{1}{\\lambda} \\exp\\left(\\frac{y_i}{\\lambda}\\right).\n$$\n令 $Z_i = \\frac{x_i^\\star}{\\lambda}$。方程变为 $Z_i \\exp(Z_i) = \\frac{1}{\\lambda} \\exp\\left(\\frac{y_i}{\\lambda}\\right)$。$Z_i$ 的解由朗伯 W 函数给出：\n$$\nZ_i = W\\left(\\frac{1}{\\lambda} \\exp\\left(\\frac{y_i}{\\lambda}\\right)\\right).\n$$\n将 $Z_i = \\frac{x_i^\\star}{\\lambda}$ 代回，我们得到 $x_i^\\star$ 的解：\n$$\nx_i^\\star = \\lambda W\\left(\\frac{1}{\\lambda} \\exp\\left(\\frac{y_i}{\\lambda}\\right)\\right).\n$$\n朗伯 W 函数的自变量总是正的，因此我们使用其主分支，记为 $W$。该公式给出了每个分量的唯一正最小化子。完整的近端算子结果是一个向量，其每个分量都由该表达式给出。\n\n**不动点形式与乘性更新**\n\n最优性条件 $x_{i} - y_{i} + \\lambda \\ln x_{i} = 0$ 可以重排为一个不动点方程。\n$$\n\\lambda \\ln x_i = y_i - x_i\n$$\n$$\n\\ln x_i = \\frac{y_i - x_i}{\\lambda}\n$$\n对两边取指数得到：\n$$\nx_i = \\exp\\left(\\frac{y_i - x_i}{\\lambda}\\right) = \\exp\\left(\\frac{y_i}{\\lambda}\\right) \\exp\\left(-\\frac{x_i}{\\lambda}\\right).\n$$\n该方程的形式为 $x_i = c_i \\exp(-x_i/\\lambda)$，其中 $c_i = \\exp(y_i/\\lambda)$。由于 $y_i \\in \\mathbb{R}$，常数 $c_i$ 总是正的。这种不动点形式自然地引出了一种迭代更新规则：\n$$\nx_{i}^{(t+1)} = c_{i} \\exp\\left(-\\frac{x_{i}^{(t)}}{\\lambda}\\right) = \\exp\\left(\\frac{y_i}{\\lambda}\\right) \\exp\\left(-\\frac{x_{i}^{(t)}}{\\lambda}\\right).\n$$\n这是一种乘性更新，因为新值是通过乘以一个依赖于旧值的因子得到的。只要初始值 $x_i^{(0)}$ 是正的，这种更新就能内在地保持 $x_i$ 的非负性。\n这种结构在通过负熵正则化的优化问题算法中很常见。函数 $f(x)$ 在差一个缩放因子和一个线性项的情况下，就是负熵。与凸生成元 $\\sum_i (x_i \\ln x_i - x_i)$ 相关联的 Bregman 散度是未归一化的 Kullback-Leibler 散度 (KLD)。诸如用于 KLD 几何的镜像下降或指数梯度等算法会导出乘性更新。所推导的迭代可以看作是解决这一特定近端问题的此类方法的一个特例。\n\n**数值稳定性分析**\n\n闭式解为 $x_{i}^{\\star} = \\lambda W\\left(\\frac{1}{\\lambda} \\exp\\left(\\frac{y_i}{\\lambda}\\right)\\right)$。我们分析当 $x_i^\\star$ 非常小，即 $x_i^\\star \\to 0^+$ 时，其数值行为。这对应于朗伯 W 函数的自变量变得非常小。令 $z_i = \\frac{1}{\\lambda} \\exp\\left(\\frac{y_i}{\\lambda}\\right)$。对于 $z_i \\to 0$，我们必须有 $y_i \\to -\\infty$。\n朗伯 W 函数在 $z=0$ 附近的泰勒级数展开是 $W(z) = z - z^2 + O(z^3)$。利用这一点，我们可以找到 $x_i^\\star$ 的主阶渐近展开：\n$$\nx_i^\\star = \\lambda W(z_i) \\approx \\lambda z_i = \\lambda \\left(\\frac{1}{\\lambda} \\exp\\left(\\frac{y_i}{\\lambda}\\right)\\right) = \\exp\\left(\\frac{y_i}{\\lambda}\\right).\n$$\n此近似在 $y_i \\ll -\\lambda$ 时有效。\n在数值上，如果 $y_i/\\lambda$ 是一个大的负数（例如 $y_i/\\lambda < -100$），项 $\\exp(y_i/\\lambda)$ 在标准浮点运算中可能会下溢为零。直接计算朗伯 W 函数可能会返回 $W(0)=0$，导致不正确的结果 $x_i^\\star=0$。\n一个数值稳定的计算策略应该在 $z_i$ 很小时切换到渐近近似。因此，对于足够负的 $y_i/\\lambda$，应该将 $x_i^\\star$ 计算为 $\\exp(y_i/\\lambda)$。这个表达式是数值稳定的；如果它下溢为零，这意味着真实值小于机器精度，零是最好的浮点表示。\n例如，一个实用的策略是：\n如果 $y_i/\\lambda < T$（对于某个阈值 $T$，例如 $T=-30$）：\n  $x_i^\\star = \\exp(y_i/\\lambda)$\n否则：\n  $x_i^\\star = \\lambda W(\\frac{1}{\\lambda} \\exp(y_i/\\lambda))$ （使用 $W$ 的库实现）\n不动点迭代 $x_{i}^{(t+1)} = \\exp(y_i/\\lambda) \\exp(-x_{i}^{(t)}/\\lambda)$ 也是计算小的 $x_i^\\star$ 值的稳定方法。从 $x_i^{(0)}=0$ 开始，第一步得到 $x_i^{(1)} = \\exp(y_i/\\lambda)$，这已经是主阶近似了。\n\n所要求的最终答案是近端算子的单个闭式表达式。将其解释为对输入向量 $y$ 的逐元素操作，解如下所示。",
            "answer": "$$\n\\boxed{\\lambda W\\left(\\frac{1}{\\lambda} \\exp\\left(\\frac{y}{\\lambda}\\right)\\right)}\n$$"
        },
        {
            "introduction": "Moreau恒等式是凸分析中的一个基本而优美的结果，它将一个函数的近端算子与其共轭函数的近端算子联系起来。这个练习  为你提供了一个亲手验证该恒等式的机会，我们将以非平凡的$\\ell_\\infty$范数为例。通过这个实践，你将加深对对偶性的理解，并了解它在算法设计中的实际应用。",
            "id": "3470868",
            "problem": "考虑一个具有标准欧几里得内积的实数有限维向量空间。设 $f : \\mathbb{R}^n \\to \\mathbb{R}$ 是一个正常的、下半连续的凸函数。函数 $f$ 的邻近算子（参数为 $\\lambda \\ge 0$）定义为\n$$\n\\operatorname{prox}_{\\lambda f}(x) := \\arg\\min_{u \\in \\mathbb{R}^n} \\left\\{ \\tfrac{1}{2} \\|u - x\\|_2^2 + \\lambda f(u) \\right\\},\n$$\n函数 $f$ 的凸共轭（Fenchel共轭）定义为\n$$\nf^*(y) := \\sup_{u \\in \\mathbb{R}^n} \\left\\{ \\langle y, u \\rangle - f(u) \\right\\}.\n$$\n用 $\\|\\cdot\\|_p$ 表示 $\\mathbb{R}^n$ 上的常规 $\\ell_p$ 范数，并令 $\\mathbb{B}_1 := \\{ y \\in \\mathbb{R}^n : \\|y\\|_1 \\le 1 \\}$ 为单位 $\\ell_1$ 球。集合 $C \\subseteq \\mathbb{R}^n$ 的指示函数定义为：如果 $x \\in C$，则 $I_C(x) = 0$；否则 $I_C(x) = +\\infty$。向量 $v \\in \\mathbb{R}^n$ 到 $\\mathbb{B}_1$ 上的精确投影是 $\\tfrac{1}{2} \\|z - v\\|_2^2$ 在约束 $\\|z\\|_1 \\le 1$ 下的唯一最小化子。\n\n任务是为一个非平凡函数验证 Moreau 恒等式。取 $f(x) = \\|x\\|_\\infty$，即 $\\ell_\\infty$ 范数，并证明恒等式\n$$\nx = \\operatorname{prox}_{\\lambda \\| \\cdot \\|_\\infty}(x) + \\lambda \\operatorname{prox}_{f^*/\\lambda}\\left(\\tfrac{x}{\\lambda}\\right),\n$$\n对所有 $x \\in \\mathbb{R}^n$ 和 $\\lambda \\ge 0$ 成立，其中 $f^*$ 是 $f$ 的凸共轭。然后，在一个程序中使用两种独立的算法对等式两边进行数值实现：一种算法用于计算 $\\operatorname{prox}_{\\lambda \\| \\cdot \\|_\\infty}(x)$，且不调用 Moreau 恒等式；另一种算法通过到单位 $\\ell_1$ 球上的精确投影来计算 $\\operatorname{prox}_{f^*/\\lambda}(x/\\lambda)$。您的实现必须对任意有限向量都具有鲁棒性。\n\n您的程序必须使用以下 $(x,\\lambda)$ 对的测试套件：\n- 测试用例 1：$x = [3.2, -1.1, 0.0, 5.5, -2.2]$，$\\lambda = 1.7$。\n- 测试用例 2：$x = [0.0, 0.0, 0.0, 0.0]$，$\\lambda = 2.5$。\n- 测试用例 3：$x = [10.0, -10.0]$，$\\lambda = 0.0$。\n- 测试用例 4：$x = [-0.3, 0.3, -0.3, 0.3, -0.3, 0.3]$，$\\lambda = 0.5$。\n- 测试用例 5：对于 $n = 20$，逐分量定义 $x \\in \\mathbb{R}^{20}$ 为 $x_i = \\sin(i) + \\tfrac{1}{2} \\cos(2 i)$，其中 $i = 1,2,\\dots,20$，正弦和余弦函数的参数以弧度为单位，并设 $\\lambda = 3.0$。\n\n对于每个测试用例，数值检验是否\n$$\nx \\stackrel{?}{=} \\operatorname{prox}_{\\lambda \\|\\cdot\\|_\\infty}(x) + \\lambda \\operatorname{prox}_{f^*/\\lambda}\\left(\\tfrac{x}{\\lambda}\\right),\n$$\n在每个坐标上的数值容差为绝对误差 $10^{-9}$ 和相对误差 $10^{-10}$ 的范围内成立（在所有测试中使用相同的容差）。每个测试用例的输出必须是一个布尔值，指示该恒等式是否在指定容差内成立。\n\n您的程序应生成单行输出，其中包含用逗号分隔并括在方括号中的结果（例如，$[result_1, result_2, result_3, result_4, result_5]$）。不允许外部输入。所有角度都必须以弧度为单位。不涉及物理单位。程序必须是完全自包含的，并且可以用现代语言执行，无需任何外部文件或网络访问。只允许使用标准的数值线性代数运算。",
            "solution": "该问题要求验证函数 $f(x) = \\|x\\|_\\infty$（即 $\\mathbb{R}^n$ 上的 $\\ell_\\infty$ 范数）的 Moreau 恒等式。该恒等式表明，对于任意 $x \\in \\mathbb{R}^n$ 和 $\\lambda \\ge 0$，\n$$\nx = \\operatorname{prox}_{\\lambda f}(x) + \\lambda \\operatorname{prox}_{f^*/\\lambda}\\left(\\tfrac{x}{\\lambda}\\right)\n$$\n其中 $f^*$ 是 $f$ 的凸共轭。我们将为右侧的两个邻近项开发独立的算法，并对一组测试用例进行数值验证。\n\n$\\lambda=0$ 的情况是平凡的。邻近算子 $\\operatorname{prox}_{0 \\cdot f}(x)$ 简化为 $\\arg\\min_u \\frac{1}{2}\\|u-x\\|_2^2$，其唯一解为 $u=x$。Moreau 恒等式变为 $x = x + 0 \\cdot \\operatorname{prox}_{f^*/0}(x/0) = x$，该式恒成立。我们将单独处理这种情况。在推导的其余部分，我们假设 $\\lambda > 0$。\n\n### 第 1 项：$\\operatorname{prox}_{\\lambda \\|\\cdot\\|_\\infty}(x)$\n\n根据定义，第一项是以下优化问题的解：\n$$\nu = \\operatorname{prox}_{\\lambda \\|\\cdot\\|_\\infty}(x) := \\arg\\min_{v \\in \\mathbb{R}^n} \\left\\{ \\tfrac{1}{2} \\|v - x\\|_2^2 + \\lambda \\|v\\|_\\infty \\right\\}\n$$\n令 $t = \\|v\\|_\\infty$。该问题等价于求解\n$$\n\\min_{t \\ge 0} \\left( \\min_{\\|v\\|_\\infty \\le t} \\tfrac{1}{2} \\|v - x\\|_2^2 + \\lambda t \\right)\n$$\n内部的最小化问题是将 $x$ 投影到半径为 $t$ 的 $\\ell_\\infty$ 球（一个超立方体）上，这可以逐分量求解：$v_i = \\operatorname{sign}(x_i) \\min(|x_i|, t)$。将其代回，我们得到一个关于单变量 $t$ 的问题：\n$$\n\\min_{t \\ge 0} g(t) \\quad \\text{其中} \\quad g(t) = \\tfrac{1}{2} \\sum_{i=1}^n (\\operatorname{sign}(x_i) \\min(|x_i|, t) - x_i)^2 + \\lambda t\n$$\n简化平方项，我们得到 $(\\min(|x_i|, t) - |x_i|)^2 = (\\max(0, |x_i|-t))^2$。所以，\n$$\ng(t) = \\tfrac{1}{2} \\sum_{i=1}^n (\\max(0, |x_i|-t))^2 + \\lambda t\n$$\n函数 $g(t)$ 是凸函数，其导数为 $g'(t) = -\\sum_{i=1}^n \\max(0, |x_i|-t) + \\lambda$。令导数为零，得到阈值 $t^*$ 的最优性条件：\n$$\n\\sum_{i=1}^n \\max(0, |x_i|-t^*) = \\lambda\n$$\n函数 $\\phi(t) = \\sum_{i=1}^n \\max(0, |x_i|-t)$ 是连续且单调递减的。如果 $\\phi(0) = \\sum |x_i| = \\|x\\|_1 \\le \\lambda$，则 $g(t)$ 的最小值在 $t^*=0$ 处取得，这意味着 $u=0$。否则，存在一个唯一的根 $t^* \\in (0, \\max_i|x_i|]$。我们可以使用像二分法或 Brent 方法这样的数值方法来找到这个根。一旦找到 $t^*$，解就由 $u_i = \\operatorname{sign}(x_i) \\min(|x_i|, t^*)$ 给出。这提供了一个无需调用 Moreau 恒等式即可计算第一项的算法。\n\n### 第 2 项：$\\lambda \\operatorname{prox}_{f^*/\\lambda}\\left(\\tfrac{x}{\\lambda}\\right)$\n\n首先，我们必须求出 $f(x) = \\|x\\|_\\infty$ 的凸共轭 $f^*$：\n$$\nf^*(y) = \\sup_{u \\in \\mathbb{R}^n} \\{ \\langle y, u \\rangle - \\|u\\|_\\infty \\}\n$$\n根据 Hölder 不等式，有 $|\\langle y, u \\rangle| \\le \\|y\\|_1 \\|u\\|_\\infty$。\n如果 $\\|y\\|_1 \\le 1$，则 $\\langle y, u \\rangle \\le \\|y\\|_1 \\|u\\|_\\infty \\le \\|u\\|_\\infty$，这意味着 $\\langle y, u \\rangle - \\|u\\|_\\infty \\le 0$。其上确界为 $0$。\n如果 $\\|y\\|_1 > 1$，我们可以选择分量为 $u_i = K \\cdot \\operatorname{sign}(y_i)$ 的向量 $u$（对于某个 $K>0$）。那么 $\\langle y, u \\rangle - \\|u\\|_\\infty = K\\|y\\|_1 - K = K(\\|y\\|_1 - 1)$。当 $K \\to \\infty$ 时，该式趋于 $+\\infty$。\n因此，$f^*$ 是单位 $\\ell_1$ 球 $\\mathbb{B}_1 = \\{y \\in \\mathbb{R}^n : \\|y\\|_1 \\le 1\\}$ 的指示函数：\n$$\nf^*(y) = I_{\\mathbb{B}_1}(y) = \\begin{cases} 0  \\text{如果 } \\|y\\|_1 \\le 1 \\\\ +\\infty  \\text{如果 } \\|y\\|_1 > 1 \\end{cases}\n$$\n现在我们分析邻近算子 $\\operatorname{prox}_{f^*/\\lambda}\\left(\\frac{x}{\\lambda}\\right)$。令 $g(v) = \\frac{1}{\\lambda}f^*(v)$。对于 $\\lambda > 0$，$g(v) = I_{\\mathbb{B}_1}(v)$。该邻近算子为：\n$$\n\\operatorname{prox}_{g}\\left(\\tfrac{x}{\\lambda}\\right) = \\arg\\min_{v \\in \\mathbb{R}^n} \\left\\{ \\tfrac{1}{2}\\left\\|v - \\tfrac{x}{\\lambda}\\right\\|_2^2 + I_{\\mathbb{B}_1}(v) \\right\\}\n$$\n指示函数 $I_{\\mathbb{B}_1}(v)$ 将最小化域限制在集合 $\\mathbb{B}_1$ 内。因此，该问题等价于求向量 $z=x/\\lambda$ 到单位 $\\ell_1$ 球上的欧几里得投影：\n$$\n\\operatorname{prox}_{f^*/\\lambda}\\left(\\tfrac{x}{\\lambda}\\right) = \\operatorname{proj}_{\\mathbb{B}_1}\\left(\\tfrac{x}{\\lambda}\\right)\n$$\n这个投影可以被高效地计算。如果 $\\|z\\|_1 \\le 1$，投影就是 $z$ 本身。否则，投影位于 $\\ell_1$ 球的边界上。存在一个高效的算法来解决这个问题，该算法涉及对 $z$ 的各分量的绝对值进行排序，并找到一个阈值 $\\theta$，使得解由逐分量的软阈值给出：$v_i = \\operatorname{sign}(z_i)\\max(0, |z_i| - \\theta)$。这为第二项提供了所需的独立算法。\n\n### 方法总结\n程序将实现两个不同的函数：\n1.  一个通过数值方法求解方程 $\\sum_{i=1}^n \\max(0, |x_i|-t) = \\lambda$ 的根 $t^*$ 来计算 $u = \\operatorname{prox}_{\\lambda \\|\\cdot\\|_\\infty}(x)$ 的函数。\n2.  一个通过实现将向量 $x/\\lambda$ 投影到单位 $\\ell_1$ 球上的高效算法来计算 $v = \\operatorname{prox}_{f^*/\\lambda}(x/\\lambda)$ 的函数。\n\n对于每个测试用例 $(x, \\lambda)$，我们使用这些独立的方法计算 $u$ 和 $v$，并在每个坐标上验证 $x$ 是否在指定的数值容差内等于 $u + \\lambda v$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef compute_prox_linf(x: np.ndarray, lambda_val: float) -> np.ndarray:\n    \"\"\"\n    Computes prox_{lambda * ||.||_inf}(x) using a root-finding method.\n    This is the first term in Moreau's identity.\n    \n    The proximal operator is defined as the solution u to:\n    argmin_u { 1/2 ||u - x||_2^2 + lambda * ||u||_inf }\n\n    The solution is a soft-thresholding of x by a value t_star, where t_star is the root of\n    sum(max(0, |x_i| - t)) = lambda.\n    \"\"\"\n    if lambda_val == 0.0:\n        return x.copy()\n    \n    # Use np.float64 for precision in sums and comparisons\n    x_abs = np.abs(x, dtype=np.float64)\n    norm1_x = np.sum(x_abs)\n\n    if lambda_val >= norm1_x:\n        return np.zeros_like(x, dtype=np.float64)\n\n    # Define the function whose root we need to find\n    def phi(t: float, x_abs_in: np.ndarray, lambda_in: float) -> float:\n        return np.sum(np.maximum(0., x_abs_in - t)) - lambda_in\n\n    t_max = np.max(x_abs)\n    if t_max == 0:  # Happens if x is the zero vector\n        return np.zeros_like(x, dtype=np.float64)\n    \n    # The root must lie in [0, t_max].\n    # phi(0) = norm1_x - lambda_val > 0.\n    # phi(t_max) = -lambda_val < 0.\n    # The interval [0, t_max] is guaranteed to bracket the root.\n    try:\n        t_star = brentq(phi, 0.0, t_max, args=(x_abs, lambda_val))\n    except ValueError:\n        # This may occur if t_max is very close to 0 and phi(t_max) evaluates to a non-negative\n        # number due to floating point inaccuracies. In this case, t_star is effectively t_max.\n        if phi(t_max) >= 0:\n            t_star = t_max\n        else:\n            raise\n\n    # The solution u is found by component-wise operations\n    u = np.sign(x) * np.minimum(x_abs, t_star)\n    return u\n\ndef project_l1_ball(z: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the Euclidean projection of vector z onto the unit L1 ball.\n    Implements the algorithm by Duchi et al. (2008).\n    \"\"\"\n    z = np.asarray(z, dtype=np.float64)\n    if np.sum(np.abs(z)) <= 1.0:\n        return z\n\n    n = len(z)\n    mu = np.sort(np.abs(z))[::-1]\n    S_mu = np.cumsum(mu)\n    \n    j_vals = np.arange(1, n + 1)\n    test_vals = mu - (S_mu - 1.0) / j_vals\n    \n    try:\n        # Find the index of the last positive value in test_vals.\n        # This corresponds to rho.\n        rho_idx = np.flatnonzero(test_vals > 0)[-1]\n        rho = rho_idx + 1\n    except IndexError:\n        # This block should be unreachable if ||z||_1 > 1.\n        # It's included for robustness.\n        return z\n\n    theta = (S_mu[rho - 1] - 1.0) / rho\n    \n    # The projection w is a soft-thresholding of z by theta\n    w = np.sign(z) * np.maximum(0., np.abs(z) - theta)\n    return w\n\ndef compute_prox_conjugate_linf(x: np.ndarray, lambda_val: float) -> np.ndarray:\n    \"\"\"\n    Computes prox_{f*/lambda}(x/lambda), where f = ||.||_inf.\n    This is equivalent to projecting x/lambda onto the L1 ball.\n    This is the second term (without the lambda multiplier) in Moreau's identity.\n    \"\"\"\n    if lambda_val == 0.0:\n        # The function becomes infinity * I_B1(v). The prox operator projects\n        # onto the domain which is the L1 ball. The problem is argmin{1/2||v-z||^2 + inf*I_B1(v)}.\n        # For this to be finite, v must be in the L1 ball. The formal definition of prox_{inf*g}\n        # can be interpreted as projection onto dom(g) ∩ {0}, which gives {0}.\n        return np.zeros_like(x, dtype=np.float64)\n\n    z = x / lambda_val\n    return project_l1_ball(z)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify Moreau's identity.\n    \"\"\"\n    test_cases = [\n        (np.array([3.2, -1.1, 0.0, 5.5, -2.2]), 1.7),\n        (np.array([0.0, 0.0, 0.0, 0.0]), 2.5),\n        (np.array([10.0, -10.0]), 0.0),\n        (np.array([-0.3, 0.3, -0.3, 0.3, -0.3, 0.3]), 0.5),\n        (np.array([np.sin(i) + 0.5 * np.cos(2*i) for i in range(1, 21)]), 3.0)\n    ]\n\n    results = []\n    atol = 1e-9\n    rtol = 1e-10\n\n    for x_orig, lambda_val in test_cases:\n        # Ensure data types are consistent for high precision\n        x = np.asarray(x_orig, dtype=np.float64)\n\n        # First term of Moreau's identity\n        prox1 = compute_prox_linf(x, lambda_val)\n\n        # Second term (the proximal part only)\n        prox2 = compute_prox_conjugate_linf(x, lambda_val)\n\n        # Right-hand side of Moreau's identity\n        rhs = prox1 + lambda_val * prox2\n        \n        # Numerical verification per coordinate\n        # |x_i - rhs_i| <= atol + rtol * |x_i| for all i\n        is_close = np.all(np.abs(x - rhs) <= atol + rtol * np.abs(x))\n        results.append(is_close)\n    \n    # Format the boolean results as lowercase strings\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在科学研究中，严谨性至关重要，而数学恒等式通常依赖于特定的前提条件。这个练习旨在培养这种严谨的思维习惯。你将通过一个具体的反例 ，证明近端算子与线性算子复合的某个法则在算子非正交时失效，从而学会审慎地应用理论。",
            "id": "3470880",
            "problem": "考虑一个正常闭凸函数 $f:\\mathbb{R}^{n}\\to\\mathbb{R}\\cup\\{+\\infty\\}$ 的近端算子，其定义为\n$$\n\\operatorname{prox}_{f}(x) \\triangleq \\arg\\min_{y\\in\\mathbb{R}^{n}} \\left\\{ f(y) + \\frac{1}{2}\\|y - x\\|_{2}^{2} \\right\\}。\n$$\n一个常被引用的近端算子复合恒等式，已知在线性算子 $U\\in\\mathbb{R}^{n\\times n}$ 是正交的情况下成立。在本题中，你将通过从基本定义出发的显式计算来证明，当 $U$ 仅仅是可逆但非正交时，该恒等式不成立。\n\n考虑维度 $n=2$ 的情况，给定函数 $f:\\mathbb{R}^{2}\\to\\mathbb{R}$ 为 $f(y)=\\frac{1}{2}\\|y\\|_{2}^{2}$，线性算子为 $U=\\operatorname{diag}(2,1)$，点为 $x=\\begin{pmatrix}5\\\\ 2\\end{pmatrix}$。仅使用近端算子的基本定义以及欧几里得范数和梯度的标准性质，计算下面两个量\n$$\n\\operatorname{prox}_{f\\circ U}(x)\n\\quad\\text{和}\\quad\nx + U^{\\top}\\big(\\operatorname{prox}_{f}(Ux) - Ux\\big),\n$$\n然后给出它们的差的精确值\n$$\n\\Delta \\triangleq \\operatorname{prox}_{f\\circ U}(x) - \\left[x + U^{\\top}\\big(\\operatorname{prox}_{f}(Ux) - Ux\\big)\\right]。\n$$\n你的最终答案必须是表示为行矩阵的精确向量 $\\Delta$。无需四舍五入，也不涉及单位。",
            "solution": "本题要求对于 $\\mathbb{R}^{2}$ 中的特定函数 $f$、线性算子 $U$ 和点 $x$，计算两个量及其差值。我们将从基本定义出发进行这些计算。\n\n设给定函数为 $f:\\mathbb{R}^{2}\\to\\mathbb{R}$，定义为 $f(y) = \\frac{1}{2}\\|y\\|_{2}^{2}$。\n线性算子为 $U = \\operatorname{diag}(2,1) = \\begin{pmatrix} 2 & 0 \\\\ 0 & 1 \\end{pmatrix}$。\n点为 $x = \\begin{pmatrix} 5 \\\\ 2 \\end{pmatrix}$。\n\n首先，我们计算 $\\operatorname{prox}_{f\\circ U}(x)$。\n复合函数为 $(f\\circ U)(y) = f(Uy) = \\frac{1}{2}\\|Uy\\|_{2}^{2}$。\n根据近端算子的定义，\n$$\n\\operatorname{prox}_{f\\circ U}(x) \\triangleq \\arg\\min_{y\\in\\mathbb{R}^{2}} \\left\\{ (f\\circ U)(y) + \\frac{1}{2}\\|y - x\\|_{2}^{2} \\right\\}。\n$$\n设目标函数为 $h(y)$：\n$$\nh(y) = \\frac{1}{2}\\|Uy\\|_{2}^{2} + \\frac{1}{2}\\|y-x\\|_{2}^{2}。\n$$\n为求最小值点，我们可以计算 $h(y)$ 关于 $y$ 的梯度并令其为零。首先，我们将范数的平方用向量乘积表示：\n$$\nh(y) = \\frac{1}{2}(Uy)^{\\top}(Uy) + \\frac{1}{2}(y-x)^{\\top}(y-x) = \\frac{1}{2}y^{\\top}U^{\\top}Uy + \\frac{1}{2}(y^{\\top}y - 2x^{\\top}y + x^{\\top}x)。\n$$\n这个二次函数的梯度为：\n$$\n\\nabla h(y) = \\frac{1}{2}(2U^{\\top}Uy + 2y - 2x) = U^{\\top}Uy + y - x。\n$$\n将梯度设为零以求最小值：\n$$\nU^{\\top}Uy + y - x = 0 \\implies (U^{\\top}U + I)y = x,\n$$\n其中 $I$ 是 $2 \\times 2$ 的单位矩阵。因此，最小值点 $y_{opt}$ 为：\n$$\ny_{opt} = \\operatorname{prox}_{f\\circ U}(x) = (U^{\\top}U + I)^{-1}x。\n$$\n现在，我们代入给定的 $U$ 和 $x$ 的值。$U$ 的转置是 $U^{\\top} = \\begin{pmatrix} 2 & 0 \\\\ 0 & 1 \\end{pmatrix}$。\n乘积 $U^{\\top}U$ 为：\n$$\nU^{\\top}U = \\begin{pmatrix} 2 & 0 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 2 & 0 \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 4 & 0 \\\\ 0 & 1 \\end{pmatrix}。\n$$\n那么，$U^{\\top}U+I$ 为：\n$$\nU^{\\top}U+I = \\begin{pmatrix} 4 & 0 \\\\ 0 & 1 \\end{pmatrix} + \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 5 & 0 \\\\ 0 & 2 \\end{pmatrix}。\n$$\n对于对角矩阵，其逆矩阵的计算很简单：\n$$\n(U^{\\top}U+I)^{-1} = \\begin{pmatrix} \\frac{1}{5} & 0 \\\\ 0 & \\frac{1}{2} \\end{pmatrix}。\n$$\n最后，我们计算 $\\operatorname{prox}_{f\\circ U}(x)$：\n$$\n\\operatorname{prox}_{f\\circ U}(x) = \\begin{pmatrix} \\frac{1}{5} & 0 \\\\ 0 & \\frac{1}{2} \\end{pmatrix} \\begin{pmatrix} 5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{5} \\cdot 5 \\\\ \\frac{1}{2} \\cdot 2 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}。\n$$\n\n接下来，我们计算第二个量 $x + U^{\\top}\\big(\\operatorname{prox}_{f}(Ux) - Ux\\big)$。\n这需要我们首先求出 $f(y) = \\frac{1}{2}\\|y\\|_2^2$ 的近端算子。\n$$\n\\operatorname{prox}_{f}(z) = \\arg\\min_{y\\in\\mathbb{R}^{2}} \\left\\{ \\frac{1}{2}\\|y\\|_{2}^{2} + \\frac{1}{2}\\|y-z\\|_{2}^{2} \\right\\}。\n$$\n设目标函数为 $k(y) = \\frac{1}{2}\\|y\\|_{2}^{2} + \\frac{1}{2}\\|y-z\\|_{2}^{2}$。其梯度为：\n$$\n\\nabla k(y) = y + (y-z) = 2y - z。\n$$\n将梯度设为零可得 $2y-z=0$，所以 $y = \\frac{1}{2}z$。因此，$\\operatorname{prox}_{f}(z) = \\frac{1}{2}z$。\n\n现在我们计算第二个量所需的各项。首先，我们计算 $Ux$：\n$$\nUx = \\begin{pmatrix} 2 & 0 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 10 \\\\ 2 \\end{pmatrix}。\n$$\n使用我们关于 $\\operatorname{prox}_{f}$ 的公式，我们得到：\n$$\n\\operatorname{prox}_{f}(Ux) = \\frac{1}{2}(Ux) = \\frac{1}{2}\\begin{pmatrix} 10 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 5 \\\\ 1 \\end{pmatrix}。\n$$\n接下来，我们计算括号内的差值：\n$$\n\\operatorname{prox}_{f}(Ux) - Ux = \\begin{pmatrix} 5 \\\\ 1 \\end{pmatrix} - \\begin{pmatrix} 10 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} -5 \\\\ -1 \\end{pmatrix}。\n$$\n然后我们乘以 $U^{\\top}$：\n$$\nU^{\\top}\\big(\\operatorname{prox}_{f}(Ux) - Ux\\big) = \\begin{pmatrix} 2 & 0 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} -5 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} -10 \\\\ -1 \\end{pmatrix}。\n$$\n最后，我们将 $x$ 加到这个结果上，得到第二个量：\n$$\nx + U^{\\top}\\big(\\operatorname{prox}_{f}(Ux) - Ux\\big) = \\begin{pmatrix} 5 \\\\ 2 \\end{pmatrix} + \\begin{pmatrix} -10 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} -5 \\\\ 1 \\end{pmatrix}。\n$$\n\n最后一步是计算差值 $\\Delta$：\n$$\n\\Delta \\triangleq \\operatorname{prox}_{f\\circ U}(x) - \\left[x + U^{\\top}\\big(\\operatorname{prox}_{f}(Ux) - Ux\\big)\\right]。\n$$\n$$\n\\Delta = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} - \\begin{pmatrix} -5 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 - (-5) \\\\ 1 - 1 \\end{pmatrix} = \\begin{pmatrix} 6 \\\\ 0 \\end{pmatrix}。\n$$\n$\\Delta$ 的非零结果明确地证明了恒等式 $\\operatorname{prox}_{f\\circ U}(x) = x + U^{\\top}\\big(\\operatorname{prox}_{f}(Ux) - Ux\\big)$ 对于这个非正交矩阵 $U$ 不成立。这个恒等式是标准复合规则的一种变形，而该规则仅对正交算子有效。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 6 & 0 \\end{pmatrix}}\n$$"
        }
    ]
}