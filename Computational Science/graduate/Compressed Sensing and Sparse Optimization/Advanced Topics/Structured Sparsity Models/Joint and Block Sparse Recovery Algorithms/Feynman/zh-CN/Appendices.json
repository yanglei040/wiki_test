{
    "hands_on_practices": [
        {
            "introduction": "联合稀疏恢复中的一个基本方法是贪婪算法，它通过迭代选择与当前残差最相关的“原子”（即字典矩阵的列）来构建稀疏解。本练习  聚焦于同步正交匹配追踪（SOMP）算法，这是一种为多测量向量（MMV）问题设计的经典贪婪算法。通过从第一性原理推导其选择准则，并将其应用于一个具体实例，你将深入理解贪婪选择过程的内在机制和数学原理。",
            "id": "3455704",
            "problem": "考虑一个联合稀疏恢复设定，其中感知维度 $m=3$，测量向量数量 $L=3$。设字典 $A \\in \\mathbb{R}^{3 \\times 5}$ 具有单位范数列 $A_{:,j}$，由下式给出\n$$\nA \\;=\\; \\begin{pmatrix}\n1  \\frac{1}{\\sqrt{2}}  0  \\frac{1}{\\sqrt{3}}  0 \\\\\n0  \\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{3}}  0 \\\\\n0  0  \\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{3}}  1\n\\end{pmatrix},\n$$\n因此 $A_{:,1} = (1,0,0)^\\top$, $A_{:,2} = \\big(\\tfrac{1}{\\sqrt{2}},\\tfrac{1}{\\sqrt{2}},0\\big)^\\top$, $A_{:,3} = \\big(0,\\tfrac{1}{\\sqrt{2}},\\tfrac{1}{\\sqrt{2}}\\big)^\\top$, $A_{:,4} = \\big(\\tfrac{1}{\\sqrt{3}},\\tfrac{1}{\\sqrt{3}},\\tfrac{1}{\\sqrt{3}}\\big)^\\top$ 以及 $A_{:,5} = (0,0,1)^\\top$。未知的联合稀疏系数矩阵 $X^\\star \\in \\mathbb{R}^{5 \\times 3}$ 在索引 $\\{2,4\\}$ 处恰好有两个非零行，其中第2行等于\n$$\nv_2 \\;=\\; \\begin{pmatrix} 2  0  -1 \\end{pmatrix}\n$$\n第4行等于\n$$\nv_4 \\;=\\; \\begin{pmatrix} 1  -2  2 \\end{pmatrix},\n$$\n所有其他行均为零行。无噪声测量值由 $Y = A X^\\star \\in \\mathbb{R}^{3 \\times 3}$ 给出。\n\n在同时正交匹配追踪（SOMP）算法的初始化阶段，残差为 $R = Y - A X$，其中 $X$ 等于零矩阵，因此 $R=Y$。该算法通过贪婪地最大化由限制在单个列子空间上的最小二乘更新所产生的残差弗罗贝尼乌斯范数 $\\|R\\|_{F}$ 的瞬时减小量来选择第一个列（原子）。\n\n任务：\n- 仅从弗罗贝尼乌斯范数和到一维子空间的正交投影的定义出发，推导出一-步贪婪选择规则，用 $A$、$R$ 和内积表示；不要假设任何预先给定的SOMP公式。\n- 然后，将您推导出的规则应用于上面给出的具体 $A$ 和 $X^\\star$，计算第一个选定原子的索引 $j^\\star \\in \\{1,2,3,4,5\\}$。您可以利用线性性质来计算 $A^\\top Y$，而无需显式地构建 $Y$。\n\n将您的最终答案以单个整数 $j^\\star$ 的形式给出；不需要四舍五入，也不涉及单位。",
            "solution": "该问题是有效的，因为它在科学上基于稀疏恢复理论，问题设定良好，目标明确，并为其解决提供了一套完整且一致的数据。\n\n第一个任务是为同时正交匹配追踪（SOMP）算法的第一步推导贪婪选择规则。该算法从一个空的支持集 $S_0 = \\emptyset$、一个零系数矩阵估计 $X_0 = \\mathbf{0}_{5 \\times 3}$ 和一个初始残差 $R_0 = Y - A X_0 = Y$ 开始。目标是选择一个索引 $j \\in \\{1, 2, 3, 4, 5\\}$，当将其添加到支持集中时，能导致残差的弗罗贝尼乌斯范数最大程度地减小。\n\n我们考虑将单个原子（对应于索引 $j$）添加到支持集中。新的支持集将是 $S_1 = \\{j\\}$。更新后的系数矩阵，我们记为 $X_1^{(j)}$，将只有其第 $j$ 行为非零。设该行为 $x_j^\\top \\in \\mathbb{R}^{1 \\times 3}$。相应的信号估计为 $A X_1^{(j)} = A_{:,j} x_j^\\top$。\n\n为了找到最优系数行 $x_j^\\top$，我们求解一个最小二乘问题，以最小化新残差的范数，$R_1^{(j)} = R_0 - A_{:,j} x_j^\\top = Y - A_{:,j} x_j^\\top$：\n$$\n\\min_{x_j^\\top \\in \\mathbb{R}^{1 \\times 3}} \\|Y - A_{:,j} x_j^\\top\\|_F^2\n$$\n弗罗贝尼乌斯范数的平方是矩阵各列的欧几里得范数平方之和。设 $Y = \\begin{pmatrix} y_1  y_2  y_3 \\end{pmatrix}$ 且 $x_j^\\top = \\begin{pmatrix} x_{j,1}  x_{j,2}  x_{j,3} \\end{pmatrix}$。该优化问题可以针对每一列 $l \\in \\{1, 2, 3\\}$ 进行解耦：\n$$\n\\min_{x_{j,1}, x_{j,2}, x_{j,3}} \\sum_{l=1}^{3} \\|y_l - A_{:,j} x_{j,l}\\|_2^2\n$$\n这等价于求解三个独立的一维最小二乘问题：\n$$\n\\min_{x_{j,l} \\in \\mathbb{R}} \\|y_l - A_{:,j} x_{j,l}\\|_2^2 \\quad \\text{for } l \\in \\{1, 2, 3\\}\n$$\n每个问题的解是向量 $y_l$ 在由向量 $A_{:,j}$ 张成的子空间上的正交投影。最优系数 $x_{j,l}^{\\text{opt}}$ 由下式给出：\n$$\nx_{j,l}^{\\text{opt}} = \\frac{A_{:,j}^\\top y_l}{\\|A_{:,j}\\|_2^2}\n$$\n问题说明 $A$ 的所有列都是单位范数，所以 $\\|A_{:,j}\\|_2^2 = 1$。这使最优系数简化为 $x_{j,l}^{\\text{opt}} = A_{:,j}^\\top y_l$。\n\n结合所有列 $l$ 的结果，最优系数行向量 $x_j^{\\text{opt}\\top}$ 由下式给出：\n$$\nx_j^{\\text{opt}\\top} = \\begin{pmatrix} A_{:,j}^\\top y_1  A_{:,j}^\\top y_2  A_{:,j}^\\top y_3 \\end{pmatrix} = A_{:,j}^\\top Y\n$$\n新的残差为 $R_1^{(j)} = Y - A_{:,j} (A_{:,j}^\\top Y)$。项 $A_{:,j} (A_{:,j}^\\top Y)$ 表示 $Y$ 的各列在由 $A_{:,j}$ 张成的子空间上的正交投影。设 $P_j = A_{:,j} A_{:,j}^\\top$ 为到该子空间上的投影矩阵。则 $R_1^{(j)} = (I - P_j) Y$。\n\n根据正交投影的勾股定理，$Y$ 的能量可以分解为：\n$$\n\\|Y\\|_F^2 = \\|P_j Y\\|_F^2 + \\|(I - P_j) Y\\|_F^2 = \\|P_j Y\\|_F^2 + \\|R_1^{(j)}\\|_F^2\n$$\n残差的弗罗贝尼乌斯范数平方的减小量为 $\\|R_0\\|_F^2 - \\|R_1^{(j)}\\|_F^2 = \\|Y\\|_F^2 - \\|R_1^{(j)}\\|_F^2 = \\|P_j Y\\|_F^2$。\n\nSOMP 的选择规则是选择使该减小量最大化的索引 $j$：\n$$\nj^\\star = \\arg\\max_{j \\in \\{1, \\ldots, 5\\}} \\|P_j Y\\|_F^2 = \\arg\\max_{j \\in \\{1, \\ldots, 5\\}} \\|A_{:,j} (A_{:,j}^\\top Y)\\|_F^2\n$$\n我们来分析被最大化的项。设 $c_j^\\top = A_{:,j}^\\top Y$ 为系数行向量。矩阵 $A_{:,j} c_j^\\top$ 是一个秩一矩阵。其弗罗贝尼乌斯范数的平方是：\n$$\n\\|A_{:,j} c_j^\\top\\|_F^2 = \\mathrm{Tr}((A_{:,j} c_j^\\top)^\\top (A_{:,j} c_j^\\top)) = \\mathrm{Tr}(c_j A_{:,j}^\\top A_{:,j} c_j^\\top) = \\mathrm{Tr}(c_j \\|A_{:,j}\\|_2^2 c_j^\\top)\n$$\n由于 $\\|A_{:,j}\\|_2^2=1$，这变为 $\\mathrm{Tr}(c_j c_j^\\top) = \\mathrm{Tr}(c_j^\\top c_j) = \\|c_j\\|_2^2$。\n所以，选择规则是选择使系数行向量 $c_j^\\top = A_{:,j}^\\top Y$ 的欧几里得范数平方最大化的索引 $j$。该行向量是矩阵乘积 $A^\\top Y$ 的第 $j$ 行。因此，选择规则是：\n$$\nj^\\star = \\arg\\max_{j \\in \\{1, \\ldots, 5\\}} \\| (A^\\top R_0)_{j,:} \\|_2^2 = \\arg\\max_{j \\in \\{1, \\ldots, 5\\}} \\| (A^\\top Y)_{j,:} \\|_2^2\n$$\n推导到此完成。\n\n第二个任务是应用此规则。我们需要计算 $C = A^\\top Y$ 并找到具有最大 $\\ell_2$-范数的行。题目建议我们使用线性性质。测量矩阵 $Y$ 由 $Y = A X^\\star$ 给出。$X^\\star$ 的结构是只有其第二行和第四行为非零。设这些行为 $v_2 = \\begin{pmatrix} 2  0  -1 \\end{pmatrix}$ 和 $v_4 = \\begin{pmatrix} 1  -2  2 \\end{pmatrix}$。我们可以将 $Y$ 写成外积之和：\n$$\nY = \\sum_{k=1}^{5} A_{:,k} (X^\\star)_{k,:} = A_{:,2} v_2 + A_{:,4} v_4\n$$\n现在，我们计算 $C = A^\\top Y$：\n$$\nC = A^\\top (A_{:,2} v_2 + A_{:,4} v_4) = (A^\\top A_{:,2}) v_2 + (A^\\top A_{:,4}) v_4\n$$\n设 $G = A^\\top A$ 为 $A$ 的格拉姆矩阵。项 $A^\\top A_{:,k}$ 是 $G$ 的第 $k$ 列，记为 $G_{:,k}$。因此：\n$$\nC = G_{:,2} v_2 + G_{:,4} v_4\n$$\n$C$ 的第 $j$ 行，记为 $C_{j,:}$，是一个由下式给出的行向量：\n$$\nC_{j,:} = G_{j2} v_2 + G_{j4} v_4\n$$\n其中 $G_{jk}$ 是 $G$ 的第 $j$ 行第 $k$ 列的元素。我们需要计算 $\\|C_{j,:}\\|_2^2$：\n$$\n\\|C_{j,:}\\|_2^2 = \\|G_{j2} v_2 + G_{j4} v_4\\|_2^2 = G_{j2}^2 \\|v_2\\|_2^2 + G_{j4}^2 \\|v_4\\|_2^2 + 2 G_{j2} G_{j4} \\langle v_2, v_4 \\rangle\n$$\n我们来计算 $v_2$ 和 $v_4$ 的范数和内积：\n$\\|v_2\\|_2^2 = 2^2 + 0^2 + (-1)^2 = 4 + 1 = 5$。\n$\\|v_4\\|_2^2 = 1^2 + (-2)^2 + 2^2 = 1 + 4 + 4 = 9$。\n$\\langle v_2, v_4 \\rangle = (2)(1) + (0)(-2) + (-1)(2) = 2 - 2 = 0$。\n由于 $v_2$ 和 $v_4$ 是正交的，范数平方的表达式简化为：\n$$\n\\|C_{j,:}\\|_2^2 = 5 G_{j2}^2 + 9 G_{j4}^2\n$$\n接下来，我们计算格拉姆矩阵 $G=A^\\top A$ 的必要元素，其中 $A_{:,j}^\\top A_{:,k} = G_{jk}$。\n$A = \\begin{pmatrix} 1  \\frac{1}{\\sqrt{2}}  0  \\frac{1}{\\sqrt{3}}  0 \\\\ 0  \\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{3}}  0 \\\\ 0  0  \\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{3}}  1 \\end{pmatrix}$。\n所需的项来自 $G$ 的第二列和第四列。对角线元素为 $G_{jj}=1$。\n$G_{12} = A_{:,1}^\\top A_{:,2} = \\frac{1}{\\sqrt{2}}$。\n$G_{22} = 1$。\n$G_{32} = A_{:,3}^\\top A_{:,2} = \\frac{1}{2}$。\n$G_{42} = A_{:,4}^\\top A_{:,2} = \\frac{1}{\\sqrt{3}}\\frac{1}{\\sqrt{2}} + \\frac{1}{\\sqrt{3}}\\frac{1}{\\sqrt{2}} = \\frac{2}{\\sqrt{6}} = \\sqrt{\\frac{2}{3}}$。\n$G_{52} = A_{:,5}^\\top A_{:,2} = 0$。\n\n$G_{14} = A_{:,1}^\\top A_{:,4} = \\frac{1}{\\sqrt{3}}$。\n$G_{24} = G_{42} = \\sqrt{\\frac{2}{3}}$。\n$G_{34} = A_{:,3}^\\top A_{:,4} = \\frac{1}{\\sqrt{2}}\\frac{1}{\\sqrt{3}} + \\frac{1}{\\sqrt{2}}\\frac{1}{\\sqrt{3}} = \\frac{2}{\\sqrt{6}} = \\sqrt{\\frac{2}{3}}$。\n$G_{44} = 1$。\n$G_{54} = A_{:,5}^\\top A_{:,4} = \\frac{1}{\\sqrt{3}}$。\n\n现在我们对每个 $j \\in \\{1, 2, 3, 4, 5\\}$ 计算 $f(j) = 5 G_{j2}^2 + 9 G_{j4}^2$。\n对于 $j=1$：$f(1) = 5(G_{12})^2 + 9(G_{14})^2 = 5(\\frac{1}{\\sqrt{2}})^2 + 9(\\frac{1}{\\sqrt{3}})^2 = 5(\\frac{1}{2}) + 9(\\frac{1}{3}) = \\frac{5}{2} + 3 = 5.5$。\n对于 $j=2$：$f(2) = 5(G_{22})^2 + 9(G_{24})^2 = 5(1)^2 + 9(\\sqrt{\\frac{2}{3}})^2 = 5(1) + 9(\\frac{2}{3}) = 5 + 6 = 11$。\n对于 $j=3$：$f(3) = 5(G_{32})^2 + 9(G_{34})^2 = 5(\\frac{1}{2})^2 + 9(\\sqrt{\\frac{2}{3}})^2 = 5(\\frac{1}{4}) + 9(\\frac{2}{3}) = \\frac{5}{4} + 6 = 7.25$。\n对于 $j=4$：$f(4) = 5(G_{42})^2 + 9(G_{44})^2 = 5(\\sqrt{\\frac{2}{3}})^2 + 9(1)^2 = 5(\\frac{2}{3}) + 9 = \\frac{10}{3} + 9 = \\frac{10+27}{3} = \\frac{37}{3} \\approx 12.33$。\n对于 $j=5$：$f(5) = 5(G_{52})^2 + 9(G_{54})^2 = 5(0)^2 + 9(\\frac{1}{\\sqrt{3}})^2 = 0 + 9(\\frac{1}{3}) = 3$。\n\n比较这些值：\n$f(1) = 5.5$\n$f(2) = 11$\n$f(3) = 7.25$\n$f(4) = \\frac{37}{3} \\approx 12.33$\n$f(5) = 3$\n最大值是 $f(4) = \\frac{37}{3}$。这对应于索引 $j=4$。因此，SOMP选择的第一个原子是 $j^\\star = 4$。",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "什么样的测量矩阵 $A$ 才能保证稀疏恢复的成功？块限制等距性质（Block Restricted Isometry Property, BRIP）为回答这一问题提供了强有力的理论框架，它刻画了测量矩阵在作用于任意块稀疏向量时近似保持其范数的能力。本练习  将引导你通过编程来经验性地计算一个矩阵的块限制等距常数（BRIC），从对特定信号的分析转向对测量矩阵普适性能的评估，从而深化对稀疏恢复理论保证的理解。",
            "id": "3455725",
            "problem": "考虑一个实数或复数传感矩阵 $A \\in \\mathbb{C}^{m \\times n}$，其列被划分为 $G$ 个不相交的组（块）$\\{ \\mathcal{B}_1, \\ldots, \\mathcal{B}_G \\}$，使得 $\\bigcup_{g=1}^G \\mathcal{B}_g = \\{1,2,\\ldots,n\\}$ 且对于所有 $g \\neq g'$ 都有 $\\mathcal{B}_g \\cap \\mathcal{B}_{g'} = \\emptyset$。如果一个向量 $x \\in \\mathbb{C}^n$ 的支撑集包含在最多 $s$ 个块的并集中，则称该向量是 $s$-块稀疏的。块限制等距性质（Block Restricted Isometry Property, RIP）常数，也称为块限制等距常数（Block Restricted Isometry Constant, BRIC），记作 $\\delta_s^B$，定义为满足以下不等式的最小 $\\delta \\ge 0$，该不等式对每个 $s$-块稀疏的 $x \\in \\mathbb{C}^n$ 均成立：\n$$\n(1 - \\delta)\\,\\|x\\|_2^2 \\le \\|A x\\|_2^2 \\le (1 + \\delta)\\,\\|x\\|_2^2.\n$$\n等价地，对于最多 $s$ 个块的每个并集 $S \\subseteq \\{1,\\ldots,G\\}$，令 $A_S$ 表示由 $A$ 中索引为 $\\bigcup_{g \\in S} \\mathcal{B}_g$ 的列构成的子矩阵，格拉姆矩阵 $A_S^* A_S$ 的极值二次型通过其特征值 $\\{\\lambda_i\\}$（即 $A_S$ 的奇异值 $\\{\\sigma_i\\}$ 的平方）来控制 $\\delta_s^B$：\n$$\n\\delta_s^B = \\sup_{\\substack{S \\subseteq \\{1,\\ldots,G\\} \\\\ |S| \\le s}} \\max\\left\\{\\lambda_{\\max}(A_S^*A_S) - 1,\\; 1 - \\lambda_{\\min}(A_S^*A_S)\\right\\} = \\sup_{\\substack{S \\subseteq \\{1,\\ldots,G\\} \\\\ |S| \\le s}} \\max\\left\\{\\sigma_{\\max}(A_S)^2 - 1,\\; 1 - \\sigma_{\\min}(A_S)^2\\right\\}.\n$$\n在实践中，对于固定的 $A$ 和块划分，通常通过枚举所有由 $s$ 个块组成的支撑集，计算每个对应子矩阵的奇异值，并取与 $1$ 的最坏情况偏差来经验性地估计 $\\delta_s^B$。为了将结果置于统一的尺度上，在计算块限制等距常数之前，标准的做法是首先将 $A$ 的每一列归一化为单位 $\\ell_2$-范数。\n\n你的任务是编写一个完整的、可运行的程序，通过评估所有由恰好两个块组成的支撑集上的最大和最小奇异值，来计算一个小矩阵 $A$ 和给定组划分的 $\\delta_2^B$ 的经验估计值，并报告所得的界 $\\widehat{\\delta}_2^B = \\max\\{\\beta - 1,\\, 1 - \\alpha\\}$，其中\n$$\n\\alpha = \\min_{\\substack{S \\subseteq \\{1,\\ldots,G\\} \\\\ |S| = 2}} \\sigma_{\\min}(A_S)^2, \\quad \\beta = \\max_{\\substack{S \\subseteq \\{1,\\ldots,G\\} \\\\ |S| = 2}} \\sigma_{\\max}(A_S)^2.\n$$\n程序必须在计算之前对 $A$ 进行列归一化（即，缩放每列使其 $\\ell_2$-范数等于 $1$）。\n\n设计程序以处理以下测试套件，其中每个测试用例都指定了如何构造 $A$ 和块划分：\n\n- 测试用例 1 (一般情况)：令 $m = 20$，$n = 24$，$G = 6$ 个大小相等的块，即 $|\\mathcal{B}_g| = 4$。使用固定的随机种子 $0$，从 $\\mathcal{N}(0,1)$ 分布中抽取独立同分布的实高斯项来构造 $A$。将列归一化为单位 $\\ell_2$-范数，然后通过枚举所有块对来计算 $\\widehat{\\delta}_2^B$。\n\n- 测试用例 2 (秩亏缺边界情况)：令 $m = 3$，$n = 5$，$G = 3$ 个块，大小分别为 $|\\mathcal{B}_1| = 2$，$|\\mathcal{B}_2| = 2$，$|\\mathcal{B}_3| = 1$。使用固定的随机种子 $1$，从 $\\mathcal{N}(0,1)$ 分布中抽取独立同分布的实高斯项来构造 $A$。将列归一化并计算 $\\widehat{\\delta}_2^B$。请注意，任何选择 $4$ 列并入一个只有 $3$ 行的矩阵的两个块的并集，都将产生至少一个零奇异值，导致对于此类支撑集有 $1 - \\sigma_{\\min}(A_S)^2 \\ge 1$。\n\n- 测试用例 3 (理想情况)：令 $m = 12$，$n = 12$，$G = 3$ 个大小相等的块，即 $|\\mathcal{B}_g| = 4$。设 $A$ 等于 $12 \\times 12$ 的单位矩阵。其列已经归一化。通过枚举所有块对来计算 $\\widehat{\\delta}_2^B$。在这种情况下，$\\widehat{\\delta}_2^B$ 应恰好为 $0$，因为由单位矩阵的列构成的任何子矩阵的所有奇异值都等于 $1$。\n\n你的程序应生成单行输出，其中包含三个测试用例的结果，格式为方括号内以逗号分隔的浮点数列表，保留六位小数，并按上述测试用例的顺序排列（例如，“[0.123456,1.000000,0.000000]”）。不应产生任何其他输出。",
            "solution": "该问题要求计算给定传感矩阵 $A \\in \\mathbb{C}^{m \\times n}$ 及其列到 $G$ 个块的指定划分的块限制等距常数（BRIC）的经验估计值，记作 $\\widehat{\\delta}_2^B$。该常数是针对所有由恰好选择两个列块构成的子矩阵定义的。\n\n所提供的经验常数的定义是：\n$$\n\\widehat{\\delta}_2^B = \\max\\{\\beta - 1,\\, 1 - \\alpha\\}\n$$\n其中\n$$\n\\alpha = \\min_{\\substack{S \\subseteq \\{1,\\ldots,G\\} \\\\ |S| = 2}} \\sigma_{\\min}(A_S)^2, \\quad \\beta = \\max_{\\substack{S \\subseteq \\{1,\\ldots,G\\} \\\\ |S| = 2}} \\sigma_{\\max}(A_S)^2\n$$\n在这里，$S$ 是两个块索引的集合，$A_S$ 是由 $A$ 中来自 $S$ 中各块的列所构成的子矩阵，而 $\\sigma_{\\min}(A_S)$ 和 $\\sigma_{\\max}(A_S)$ 分别是 $A_S$ 的最小和最大奇异值。$A_S$ 的奇异值与格拉姆矩阵 $A_S^* A_S$ 的特征值之间的关系由 $\\sigma_i(A_S)^2 = \\lambda_i(A_S^* A_S)$ 给出。\n\n计算过程涉及几个不同的步骤，每个测试用例都将遵循这些步骤。\n\n**步骤 1：列归一化**\n作为限制等距性质（Restricted Isometry Property）上下文中的一个标准预处理步骤，矩阵 $A$ 的每一列都必须被归一化为单位 $\\ell_2$-范数。对于 $A$ 的每一列 $a_j$（其中 $j \\in \\{1, \\ldots, n\\}$），归一化后的列 $a'_j$ 计算如下：\n$$\na'_j = \\frac{a_j}{\\|a_j\\|_2}\n$$\n这确保了单列子矩阵 $A_{\\{j\\}}$ 的平凡情况具有 $\\sigma_{\\max}(A_{\\{j\\}})^2 = \\|a'_j\\|_2^2 = 1$，从而为 RIP 条件校准了基线。所有后续计算都在这个归一化后的矩阵上进行，为简单起见，我们仍将其记为 $A$。\n\n**步骤 2：块划分和子矩阵枚举**\n$m \\times n$ 矩阵 $A$ 的列被划分为 $G$ 个不相交的索引集 $\\{\\mathcal{B}_1, \\ldots, \\mathcal{B}_G\\}$。计算 $\\widehat{\\delta}_2^B$ 需要检查所有由恰好两个这些块的并集构成的可能子矩阵。这种块对的数量由二项式系数 $\\binom{G}{2}$ 给出。对于每一对块索引 $\\{g_1, g_2\\}$（其中 $1 \\le g_1  g_2 \\le G$），我们形成一个列索引集 $I_S = \\mathcal{B}_{g_1} \\cup \\mathcal{B}_{g_2}$。然后通过选择 $A$ 中索引在 $I_S$ 内的列来构造子矩阵 $A_S$。\n\n**步骤 3：奇异值分析和极值跟踪**\n对于上一步中构造的每个子矩阵 $A_S$，我们必须计算其奇异值。奇异值的平方 $\\sigma_i(A_S)^2$ 对应于格拉姆矩阵 $A_S^* A_S$ 的特征值。我们关心的是极值奇异值的平方：$\\sigma_{\\min}(A_S)^2$ 和 $\\sigma_{\\max}(A_S)^2$。\n\n为了找到 $\\alpha$ 和 $\\beta$，我们初始化两个变量：将 $\\alpha$ 初始化为一个比任何可能的奇异值平方都大的值（例如 $\\infty$），将 $\\beta$ 初始化为一个比任何可能的奇异值平方都小的值（例如 $0$，因为它们是非负的）。然后我们遍历所有 $\\binom{G}{2}$ 个唯一的块对。对于每个对应的子矩阵 $A_S$，我们执行以下更新：\n$$\n\\alpha \\leftarrow \\min(\\alpha, \\sigma_{\\min}(A_S)^2)\n$$\n$$\n\\beta \\leftarrow \\max(\\beta, \\sigma_{\\max}(A_S)^2)\n$$\n在遍历所有对之后，$\\alpha$ 将持有最小奇异值平方的全局最小值，而 $\\beta$ 将持有最大奇异值平方的全局最大值。\n\n**步骤 4：最终计算**\n利用 $\\alpha$ 和 $\\beta$ 的最终值，根据其定义计算经验常数 $\\widehat{\\delta}_2^B$：\n$$\n\\widehat{\\delta}_2^B = \\max(\\beta - 1, 1 - \\alpha)\n$$\n\n此算法将应用于三个测试用例中的每一个。\n\n**测试用例 1 (一般情况)：**\n$m = 20$，$n = 24$，$G = 6$ 个大小为 $4$ 的块。使用种子 $0$ 从高斯分布 $\\mathcal{N}(0,1)$ 生成一个随机矩阵 $A$。归一化后，我们遍历 $\\binom{6}{2} = 15$ 个块对。每个子矩阵 $A_S$ 的维度为 $20 \\times 8$。由于 $m > n_S$（其中 $n_S=8$），这些子矩阵是“高”矩阵，很可能是满秩的，从而产生非零的最小奇异值。算法如上所述进行。\n\n**测试用例 2 (秩亏缺边界情况)：**\n$m = 3$，$n = 5$，$G = 3$，块大小分别为 $2$、$2$ 和 $1$。块索引为 $\\mathcal{B}_1 = \\{1, 2\\}$，$\\mathcal{B}_2 = \\{3, 4\\}$，$\\mathcal{B}_3 = \\{5\\}$。有 $\\binom{3}{2} = 3$ 个块对需要考虑。\n\\begin{enumerate}\n    \\item $S = \\{1, 2\\}$: $A_S$ 由索引为 $\\mathcal{B}_1 \\cup \\mathcal{B}_2$ 的列构成，其大小为 $4$。矩阵 $A_S$ 是 $3 \\times 4$ 的。由于列数（$4$）超过行数（$3$），$A_S$ 的秩最多为 $3$。因此，$A_S$ 必须有至少 $4-3=1$ 个零奇异值。这意味着 $\\sigma_{\\min}(A_S) = 0$。\n    \\item $S = \\{1, 3\\}$: $A_S$ 由索引为 $\\mathcal{B}_1 \\cup \\mathcal{B}_3$ 的列构成，其大小为 $3$。矩阵 $A_S$ 是 $3 \\times 3$ 的。\n    \\item $S = \\{2, 3\\}$: $A_S$ 由索引为 $\\mathcal{B}_2 \\cup \\mathcal{B}_3$ 的列构成，其大小为 $3$。矩阵 $A_S$ 是 $3 \\times 3$ 的。\n\\end{enumerate}\n对于 $S = \\{1, 2\\}$，秩亏缺子矩阵的存在保证了全局最小奇异值平方为 $\\alpha = 0$。因此，$1 - \\alpha = 1$。最终值将是 $\\widehat{\\delta}_2^B = \\max(\\beta - 1, 1)$，该值必须至少为 $1$。\n\n**测试用例 3 (理想情况)：**\n$m = 12$，$n = 12$，$G = 3$ 个大小为 $4$ 的块。矩阵 $A$ 是 $12 \\times 12$ 的单位矩阵 $I_{12}$。其列已经归一化。任何通过选取两个块形成的子矩阵 $A_S$ 都将由单位矩阵中 $8$ 个不同的列组成。根据定义，这些列是标准正交的。对于任何这样的 $12 \\times 8$ 子矩阵 $A_S$，其格拉姆矩阵为 $A_S^* A_S = I_8$，即 $8 \\times 8$ 的单位矩阵。$I_8$ 的所有特征值都等于 $1$。因此，对于每个可能的 $S$ 选择，我们都有 $\\sigma_{\\max}(A_S)^2 = 1$ 和 $\\sigma_{\\min}(A_S)^2 = 1$。这导致全局值为 $\\alpha = 1$ 和 $\\beta = 1$。所得常数为 $\\widehat{\\delta}_2^B = \\max(1 - 1, 1 - 1) = 0$，这是一个表示没有失真的理想值。",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef compute_empirical_bric(A: np.ndarray, block_partition: list[list[int]]) -> float:\n    \"\"\"\n    Computes the empirical Block Restricted Isometry Constant (BRIC) for s=2.\n\n    Args:\n        A: The sensing matrix (m x n).\n        block_partition: A list of lists, where each inner list contains the\n                         column indices for a block.\n\n    Returns:\n        The empirical BRIC value, delta_hat_2^B.\n    \"\"\"\n    # Step 1: Normalize columns to unit l2-norm.\n    # We add a small epsilon to avoid division by zero for potential zero columns,\n    # though not expected with the given test cases.\n    col_norms = np.linalg.norm(A, axis=0, keepdims=True)\n    epsilon = 1e-12\n    A_norm = A / (col_norms + epsilon)\n\n    num_blocks = len(block_partition)\n    \n    # Step 3: Initialize alpha and beta for extremal value tracking.\n    # Squared singular values are non-negative.\n    # min of min_squared_svd\n    alpha = np.inf\n    # max of max_squared_svd\n    beta = 0.0\n\n    # Step 2: Enumerate all pairs of blocks.\n    block_indices = range(num_blocks)\n    for g1, g2 in combinations(block_indices, 2):\n        # Form the submatrix index set\n        s_indices = block_partition[g1] + block_partition[g2]\n        \n        # Construct the submatrix A_S\n        A_S = A_norm[:, s_indices]\n\n        # Step 3 (cont.): Compute singular values of A_S.\n        # np.linalg.svd returns singular values in descending order.\n        s_values = np.linalg.svd(A_S, compute_uv=False)\n        \n        # Get squared extremal singular values\n        sigma_min_sq = s_values[-1]**2\n        sigma_max_sq = s_values[0]**2\n        \n        # Update alpha and beta\n        if sigma_min_sq  alpha:\n            alpha = sigma_min_sq\n        if sigma_max_sq > beta:\n            beta = sigma_max_sq\n            \n    # Step 4: Final calculation\n    # For a valid BRIC, alpha must be non-negative.\n    # The value 1-alpha represents the deviation from isometry on the lower bound.\n    # The value beta-1 represents the deviation from isometry on the upper bound.\n    delta_hat = max(beta - 1, 1 - alpha)\n    \n    return delta_hat\n\n\ndef solve():\n    \"\"\"\n    Solves the problem for the three specified test cases.\n    \"\"\"\n    results = []\n\n    # Test Case 1: General case\n    m1, n1, G1 = 20, 24, 6\n    seed1 = 0\n    rng1 = np.random.default_rng(seed1)\n    A1 = rng1.standard_normal((m1, n1))\n    block_size1 = n1 // G1\n    partition1 = [list(range(i * block_size1, (i + 1) * block_size1)) for i in range(G1)]\n    result1 = compute_empirical_bric(A1, partition1)\n    results.append(f\"{result1:.6f}\")\n\n    # Test Case 2: Rank-deficient edge case\n    m2, n2, G2 = 3, 5, 3\n    seed2 = 1\n    rng2 = np.random.default_rng(seed2)\n    A2 = rng2.standard_normal((m2, n2))\n    partition2 = [\n        [0, 1],\n        [2, 3],\n        [4]\n    ]\n    result2 = compute_empirical_bric(A2, partition2)\n    results.append(f\"{result2:.6f}\")\n\n    # Test Case 3: Ideal case\n    m3, n3, G3 = 12, 12, 3\n    A3 = np.identity(n3)\n    block_size3 = n3 // G3\n    partition3 = [list(range(i * block_size3, (i + 1) * block_size3)) for i in range(G3)]\n    result3 = compute_empirical_bric(A3, partition3)\n    results.append(f\"{result3:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}