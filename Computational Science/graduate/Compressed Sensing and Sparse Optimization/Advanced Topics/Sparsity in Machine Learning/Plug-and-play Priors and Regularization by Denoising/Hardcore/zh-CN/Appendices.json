{
    "hands_on_practices": [
        {
            "introduction": "即插即用（PnP）和去噪正则化（RED）方法为复杂的逆问题提供了一个灵活的框架，但它们的理论性质有时可能显得抽象。为了建立坚实的直观理解，将这些现代方法与经典的正则化技术联系起来是至关重要的。本练习旨在通过一个基础性的推导，揭示当先验由一个二次势函数定义时，PnP和RED框架如何精确地简化为经典的吉洪诺夫正则化，从而帮助我们理解它们隐式施加的正则化形式。",
            "id": "3466500",
            "problem": "考虑一个线性逆问题，其测量值建模为 $y \\in \\mathbb{R}^{m}$，前向算子为 $A \\in \\mathbb{R}^{m \\times n}$，并伴有方差为 $\\sigma^{2}$ 的加性高斯白噪声。数据保真项为 $f(x) = \\frac{1}{2 \\sigma^{2}} \\|A x - y\\|_{2}^{2}$，其中 $x \\in \\mathbb{R}^{n}$。设 $L \\in \\mathbb{R}^{n \\times n}$ 是一个对称半正定矩阵，并定义二次势函数 $\\phi(x) = \\frac{1}{2} x^{\\top} L x$。设 $\\tau > 0$，$\\rho > 0$ 和 $\\beta > 0$ 为给定的标量。\n\n- 在通过交替方向乘子法 (ADMM) 实现的即插即用 (PnP) 方法中，$z$ 更新步骤使用一个去噪器，该去噪器是 $\\tau \\phi$ 的近端算子，即对于任何 $v \\in \\mathbb{R}^{n}$，\n$$\nD_{\\tau}(v) = \\operatorname{prox}_{\\tau \\phi}(v) = \\arg\\min_{z \\in \\mathbb{R}^{n}} \\left\\{ \\frac{1}{2} \\|z - v\\|_{2}^{2} + \\tau \\phi(z) \\right\\}。\n$$\n假设 ADMM 的惩罚参数为 $\\rho$，并考虑标准的变量分裂 $x=z$。\n\n- 在去噪正则化 (RED) 方法中，考虑变分公式\n$$\n\\min_{x \\in \\mathbb{R}^{n}} \\; f(x) + \\beta R(x),\n$$\n其中与同一个去噪器 $D_{\\tau}$ 相关联的 RED 正则化项是\n$$\nR(x) = \\frac{1}{2} x^{\\top} \\left( x - D_{\\tau}(x) \\right),\n$$\n并假设该去噪器是线性的、对称的且非扩张的。\n\n仅从第一性原理和核心定义出发（凸函数的近端算子、变量分裂为 $x=z$ 且惩罚参数为 $\\rho$ 的 ADMM，以及 RED 的构造），推导出每种情况下等效的吉洪诺夫正则化矩阵的显式闭式表达式。具体而言，证明使用 $\\tau \\phi$ 的近端去噪器的 PnP-ADMM 和使用相同去噪器的 RED 均可简化为经典的吉洪诺夫正则化形式\n$$\n\\min_{x \\in \\mathbb{R}^{n}} \\; \\frac{1}{2 \\sigma^{2}} \\|A x - y\\|_{2}^{2} + \\frac{1}{2} x^{\\top} \\Gamma x,\n$$\n并计算每种方法的等效正则化矩阵 $\\Gamma$ 关于 $\\rho$、$\\tau$、$\\beta$ 和 $L$ 的显式表达式。\n\n您的最终答案必须是一个包含这两个等效矩阵的单行矩阵，顺序为 $\\left(\\Gamma_{\\mathrm{PnP}}, \\Gamma_{\\mathrm{RED}}\\right)$，以闭式解析表达式的形式给出。不需要数值近似，也不涉及单位。",
            "solution": "所给问题是有效的。它在科学上基于计算成像和优化理论的原理，是适定的、客观的，并包含了唯一解所需的所有必要信息。我们开始推导。\n\n目标是证明在指定条件下，即插即用交替方向乘子法 (PnP-ADMM) 和去噪正则化 (RED) 均等价于以下形式的吉洪诺夫正则化问题：\n$$\n\\min_{x \\in \\mathbb{R}^{n}} \\; \\frac{1}{2 \\sigma^{2}} \\|A x - y\\|_{2}^{2} + \\frac{1}{2} x^{\\top} \\Gamma x\n$$\n并确定每种情况下等效正则化矩阵 $\\Gamma$ 的显式表达式。\n\n首先，我们推导去噪器 $D_{\\tau}(v)$ 的显式形式。该去噪器被定义为函数 $\\tau \\phi(z)$ 的近端算子，其中 $\\phi(z) = \\frac{1}{2} z^{\\top} L z$。根据定义：\n$$\nD_{\\tau}(v) = \\operatorname{prox}_{\\tau \\phi}(v) = \\arg\\min_{z \\in \\mathbb{R}^{n}} \\left\\{ \\frac{1}{2} \\|z - v\\|_{2}^{2} + \\tau \\phi(z) \\right\\} = \\arg\\min_{z \\in \\mathbb{R}^{n}} \\left\\{ \\frac{1}{2} \\|z - v\\|_{2}^{2} + \\frac{\\tau}{2} z^{\\top} L z \\right\\}.\n$$\n目标函数是二次且严格凸的，因为 $L$ 是半正定的且 $\\tau > 0$，这保证了海森矩阵 $I + \\tau L$ 是正定的。通过将关于 $z$ 的梯度设为零，可以找到唯一的最小化子：\n$$\n\\nabla_{z} \\left( \\frac{1}{2} (z - v)^{\\top}(z - v) + \\frac{\\tau}{2} z^{\\top} L z \\right) = (z - v) + \\tau L z = 0.\n$$\n整理各项，我们得到 $(I + \\tau L)z = v$。由于 $I + \\tau L$ 是可逆的，我们可以解出 $z$：\n$$\nz = (I + \\tau L)^{-1} v.\n$$\n因此，该去噪器是一个由矩阵 $(I + \\tau L)^{-1}$ 表示的线性算子：\n$$\nD_{\\tau}(v) = (I + \\tau L)^{-1} v.\n$$\n\n我们现在将分别分析每种方法。\n\n**第一部分：即插即用 ADMM (PnP-ADMM)**\n\nPnP-ADMM 算法通过变量分裂 $x=z$ 来解决形如 $\\min_x f(x) + g(x)$ 的逆问题。标准的 ADMM 算法涉及对 $x$、$z$ 和一个缩放的对偶变量 $u$ 的迭代。问题指出，$z$ 更新步骤（通常是 $\\operatorname{prox}_{g/\\rho}$）被替换为一个去噪器 $D_{\\tau}$。该算法的不动点 $(x^*, z^*, u^*)$（假定迭代收敛于此点）必须满足以下条件：\n1. $x$ 更新：$x^* = \\arg\\min_x \\left\\{ f(x) + \\frac{\\rho}{2} \\|x - (z^* - u^*)\\|_2^2 \\right\\}$。此步骤的一阶最优性条件是 $\\nabla f(x^*) + \\rho(x^* - z^* + u^*) = 0$。\n2. $z$ 更新 (PnP 步骤)：$z^* = D_{\\tau}(x^* + u^*)$。\n3. 对偶更新：$u^* = u^* + x^* - z^*$，这意味着不动点约束为 $x^* = z^*$。\n\n我们利用这些不动点关系来找出该算法所求解的隐式优化问题。\n将 $x^* = z^*$ 代入 $x$ 更新的一阶条件中：\n$$\n\\nabla f(x^*) + \\rho(x^* - x^* + u^*) = 0 \\implies \\nabla f(x^*) + \\rho u^* = 0.\n$$\n这给出了不动点处对偶变量的表达式：\n$$\nu^* = -\\frac{1}{\\rho} \\nabla f(x^*).\n$$\n现在，将 $z^* = x^*$ 和 $u^*$ 的表达式代入 $z$ 更新方程中：\n$$\nx^* = D_{\\tau}\\left(x^* - \\frac{1}{\\rho} \\nabla f(x^*)\\right).\n$$\n这就是刻画解 $x^*$ 的不动点方程。我们现在代入已推导出的去噪器表达式 $D_{\\tau}(v) = (I + \\tau L)^{-1} v$：\n$$\nx^* = (I + \\tau L)^{-1} \\left(x^* - \\frac{1}{\\rho} \\nabla f(x^*)\\right).\n$$\n两边同乘以可逆矩阵 $(I + \\tau L)$：\n$$\n(I + \\tau L)x^* = x^* - \\frac{1}{\\rho} \\nabla f(x^*).\n$$\n展开左侧得到 $x^* + \\tau L x^* = x^* - \\frac{1}{\\rho} \\nabla f(x^*)$。\n化简后，我们得到 $\\tau L x^* = -\\frac{1}{\\rho} \\nabla f(x^*)$，可以重写为：\n$$\n\\nabla f(x^*) + \\rho \\tau L x^* = 0.\n$$\n这个方程是一个凸最小化问题的一阶充要最优性条件。我们可以通过找到一个函数，使其梯度与左侧对应，从而识别出这个问题。设这个函数为 $J_{\\mathrm{PnP}}(x)$：\n$$\n\\nabla J_{\\mathrm{PnP}}(x) = \\nabla f(x) + \\rho \\tau L x.\n$$\n对 $x$ 积分，我们找到目标函数（相差一个常数）：\n$$\nJ_{\\mathrm{PnP}}(x) = f(x) + \\frac{1}{2} x^{\\top} (\\rho \\tau L) x = \\frac{1}{2 \\sigma^{2}} \\|A x - y\\|_{2}^{2} + \\frac{\\rho \\tau}{2} x^{\\top} L x.\n$$\n这是一个吉洪诺夫正则化问题。通过将其与目标形式 $\\frac{1}{2 \\sigma^{2}} \\|A x - y\\|_{2}^{2} + \\frac{1}{2} x^{\\top} \\Gamma_{\\mathrm{PnP}} x$ 进行比较，我们可以直接确定 PnP-ADMM 的等效正则化矩阵：\n$$\n\\Gamma_{\\mathrm{PnP}} = \\rho \\tau L.\n$$\n\n**第二部分：去噪正则化 (RED)**\n\nRED 框架显式地提出了一个变分问题。该问题如下：\n$$\n\\min_{x \\in \\mathbb{R}^{n}} \\; f(x) + \\beta R(x),\n$$\n其中 $f(x) = \\frac{1}{2 \\sigma^{2}} \\|A x - y\\|_{2}^{2}$ 且 RED 正则化项为 $R(x) = \\frac{1}{2} x^{\\top} (x - D_{\\tau}(x))$。\n为了找到等效的吉洪诺夫矩阵，我们将 $f(x)$ 和 $R(x)$ 的表达式代入最小化问题中：\n$$\n\\min_{x \\in \\mathbb{R}^{n}} \\; \\frac{1}{2 \\sigma^{2}} \\|A x - y\\|_{2}^{2} + \\frac{\\beta}{2} x^{\\top} (x - D_{\\tau}(x)).\n$$\n我们使用和之前相同的去噪器表达式：$D_{\\tau}(x) = (I + \\tau L)^{-1} x$。将其代入正则化项得到：\n$$\n\\frac{\\beta}{2} x^{\\top} (x - (I + \\tau L)^{-1} x) = \\frac{\\beta}{2} x^{\\top} (I - (I + \\tau L)^{-1}) x.\n$$\n我们简化矩阵表达式 $I - (I + \\tau L)^{-1}$：\n$$\nI - (I + \\tau L)^{-1} = (I + \\tau L)(I + \\tau L)^{-1} - (I + \\tau L)^{-1} = ((I + \\tau L) - I)(I + \\tau L)^{-1} = \\tau L (I + \\tau L)^{-1}.\n$$\n将这个简化后的矩阵代回正则化项，我们得到：\n$$\n\\frac{\\beta}{2} x^{\\top} (\\tau L (I + \\tau L)^{-1}) x = \\frac{\\beta \\tau}{2} x^{\\top} L (I + \\tau L)^{-1} x.\n$$\n因此，完整的 RED 优化问题是：\n$$\n\\min_{x \\in \\mathbb{R}^{n}} \\; \\frac{1}{2 \\sigma^{2}} \\|A x - y\\|_{2}^{2} + \\frac{1}{2} x^{\\top} \\left( \\beta \\tau L (I + \\tau L)^{-1} \\right) x.\n$$\n这也具有吉洪诺夫正则化的形式。通过将其与目标形式 $\\frac{1}{2 \\sigma^{2}} \\|A x - y\\|_{2}^{2} + \\frac{1}{2} x^{\\top} \\Gamma_{\\mathrm{RED}} x$ 进行比较，我们确定 RED 的等效正则化矩阵：\n$$\n\\Gamma_{\\mathrm{RED}} = \\beta \\tau L (I + \\tau L)^{-1}.\n$$\n由于 $L$ 是一个对称矩阵，所推导出的两个正则化矩阵 $\\Gamma_{\\mathrm{PnP}}$ 和 $\\Gamma_{\\mathrm{RED}}$ 都是对称的，这与吉洪诺夫正则化的二次型是一致的。\n\n**结论**\n\n我们已经证明，在指定的二次势函数下，PnP-ADMM 和 RED 都可以简化为吉洪诺夫正则化。等效的正则化矩阵分别为 $\\Gamma_{\\mathrm{PnP}} = \\rho \\tau L$ 和 $\\Gamma_{\\mathrm{RED}} = \\beta \\tau L (I + \\tau L)^{-1}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\rho \\tau L  \\beta \\tau L(I + \\tau L)^{-1}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "即插即用（PnP）算法的强大之处在于其模块化，但这种灵活性也带来了关于收敛性的关键问题。并非任何去噪器都能保证算法的稳定运行，理解其失效模式对于可靠应用至关重要。本练习通过构建一个清晰的反例，让您亲手验证一个“扩张性”去噪器（其增益大于1）如何导致PnP-ADMM算法发散，从而深刻体会去噪器的非扩张性等性质对确保算法收敛的重要性。",
            "id": "3466533",
            "problem": "考虑交替方向乘子法 (ADMM)，它通过分裂变量并引入约束 $\\mathbf{x} = \\mathbf{v}$ 来求解形如 $\\min_{\\mathbf{x}} \\, g(\\mathbf{x}) + h(\\mathbf{x})$ 的问题。缩放形式的交替方向乘子法 (ADMM)，其中 ADMM 代表交替方向乘子法，对三个变量进行迭代：原始变量 $\\mathbf{x}$、辅助变量 $\\mathbf{v}$ 和缩放对偶变量 $\\mathbf{u}$。即插即用 (PnP) 方法，其中 PnP 代表即插即用，用去噪器 $D$ 替代 $h$ 的近端算子，从而得到 PnP-ADMM。在一维情况下，假设数据保真项是二次的，前向算子是单位算子，去噪器是线性的。\n\n从以下基本出发点开始：\n\n- 用于求解 $\\min_{\\mathbf{x}} \\, g(\\mathbf{x}) + h(\\mathbf{x})$ 且约束为 $\\mathbf{x} = \\mathbf{v}$ 的 ADMM 变量分裂形式使用增广拉格朗日函数，其中惩罚参数为 $\\rho  0$，并使用缩放对偶变量 $\\mathbf{u}$。\n- 在 PnP-ADMM 中，与 $h$ 的近端算子相对应的更新步骤被替换为在适当参数下求值的去噪操作 $D$。\n- 对于一维二次数据保真项 $g(x) = \\frac{\\gamma}{2} (x - y)^2$ (其中 $\\gamma  0$)、单位前向算子和增益为 $\\alpha  0$ 的线性去噪器 $D(z) = \\alpha z$，每次迭代都是良定义的，并产生一个确定性的线性仿射递推关系。\n\n您的任务是构造一个反例，证明扩张性去噪器（即增益 $\\alpha  1$ 的去噪器）会导致 PnP-ADMM 发散，并且可能产生振荡行为。请严格按照以下步骤，从上述基础出发进行推导：\n\n1. 使用二次项 $g(x)$、线性去噪器 $D(z)$ 和惩罚参数 $\\rho$，从第一性原理出发，推导三元组 $(x^{k+1}, v^{k+1}, u^{k+1})$ 的一维 PnP-ADMM 迭代。用 $x^k, v^k, u^k, \\gamma, \\rho, y, \\alpha$ 表示迭代的闭式解。\n2. 证明该迭代可以写成关于某个适当状态的线性仿射动力系统，并导出控制其线性部分的矩阵。计算该矩阵的谱半径，并仅使用此推导，用 $\\alpha, \\gamma, \\rho$ 给出精确的发散条件。\n3. 根据主导特征值的符号，解释何时会发生振荡行为（迭代过程中符号交替）。\n4. 实现一个完整、可运行的程序，该程序：\n   - 使用推导出的闭式更新，在一维上模拟 PnP-ADMM 迭代。\n   - 对每个测试用例，计算线性部分的谱半径，确定序列是否发散（基于推导的充要条件），并通过计算模拟迭代过程中缩放对偶变量的符号交替次数来检测振荡行为。\n   - 对每个测试用例，返回一个包含三项的列表：谱半径（浮点数，保留六位小数）、一个指示是否发散的布尔值，以及一个指示是否存在振荡行为的布尔值。\n\n使用以下测试套件，其一维参数为 $(\\alpha, \\gamma, \\rho, y, x^0, v^0, u^0, K)$，其中 $K$ 是迭代次数：\n\n- 测试用例 1（扩张性，单调发散）：$(\\alpha, \\gamma, \\rho, y, x^0, v^0, u^0, K) = (1.2, 0.1, 1.0, 1.0, 0.0, 0.0, 0.0, 50)$。\n- 测试用例 2（扩张性，振荡发散）：$(\\alpha, \\gamma, \\rho, y, x^0, v^0, u^0, K) = (5.0, 1.0, 0.1, 1.0, 0.0, 0.0, 0.0, 50)$。\n- 测试用例 3（临界扩张性，线性增长发散）：$(\\alpha, \\gamma, \\rho, y, x^0, v^0, u^0, K) = \\left(\\frac{1}{1 - 0.1}, 0.1, 1.0, 1.0, 0.0, 0.0, 0.0, 50\\right)$。\n- 测试用例 4（收缩性，收敛）：$(\\alpha, \\gamma, \\rho, y, x^0, v^0, u^0, K) = (0.8, 2.0, 1.0, 1.0, 0.0, 0.0, 0.0, 50)$。\n- 测试用例 5（非扩张性，收敛）：$(\\alpha, \\gamma, \\rho, y, x^0, v^0, u^0, K) = (1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 50)$。\n\n发散的判定必须纯粹基于您推导的仿射系统的谱半径和常数项，而不仅仅是数值上的爆炸。振荡的判定必须基于在 $K$ 次迭代中观察到的缩放对偶变量的符号交替，并使用合理的阈值来宣告振荡。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例对应一个格式为 $[\\text{spectral\\_radius}, \\text{diverges}, \\text{oscillatory}]$ 的子列表。例如，输出应精确地看起来像 $[[r_1,b_1,o_1],[r_2,b_2,o_2],\\dots]$，不含空格。此问题不涉及角度。不涉及物理单位。所有值都是无量纲的。唯一需要报告的数值是谱半径（应四舍五入到六位小数）和布尔值。",
            "solution": "该问题要求针对特定的二次数据保真项和线性去噪器，对一维即插即用交替方向乘子法 (PnP-ADMM) 算法进行分析。任务是推导迭代更新方程，分析其作为线性仿射动力系统的稳定性，并实现一个仿真来展示扩张性去噪器导致的发散和振荡行为。\n\n首先验证问题。\n\n**第1步：提取已知条件**\n- 优化问题：$\\min_{\\mathbf{x}} \\, g(\\mathbf{x}) + h(\\mathbf{x})$。\n- ADMM 分裂形式：$\\min_{\\mathbf{x}, \\mathbf{v}} \\, g(\\mathbf{x}) + h(\\mathbf{v})$，约束条件为 $\\mathbf{x} = \\mathbf{v}$。\n- 算法：缩放形式的 PnP-ADMM，包含原始变量 $\\mathbf{x}$、辅助变量 $\\mathbf{v}$ 和缩放对偶变量 $\\mathbf{u}$。\n- 增广拉格朗日函数：使用惩罚参数 $\\rho  0$。\n- 一维特例：\n  - 数据保真项：$g(x) = \\frac{\\gamma}{2} (x - y)^2$，其中 $\\gamma  0$。\n  - 去噪器（替代 h 的近端算子）：$D(z) = \\alpha z$，增益为 $\\alpha  0$。\n- 任务：\n  1. 推导 PnP-ADMM 迭代 $(x^{k+1}, v^{k+1}, u^{k+1})$ 的闭式解。\n  2. 将迭代表示为线性仿射系统，推导其控制矩阵、谱半径和发散条件。\n  3. 解释振荡行为的条件。\n  4. 实现一个仿真，以在指定的测试用例上验证理论。\n\n**第2步：验证**\n该问题在优化理论和信号处理的数学框架内是良定义的。它在科学上是合理的、客观的且自洽的。使用带线性去噪器的简化一维模型是进行迭代算法解析稳定性分析的标准技术。该问题没有任何科学缺陷、歧义或矛盾。\n\n**第3步：结论**\n问题有效。解题过程如下。\n\n**1. PnP-ADMM 迭代推导**\n\n缩放形式的 ADMM 算法通过对增广拉格朗日函数进行迭代来解决问题 $\\min_{x,v} g(x) + h(v)$ 且约束为 $x = v$：\n$$ \\mathcal{L}_{\\rho}(x, v, u) = g(x) + h(v) + \\frac{\\rho}{2} \\|x - v + u\\|^2_2 - \\frac{\\rho}{2} \\|u\\|^2_2 $$\n一维 ADMM 迭代包括三个步骤：\n\n**x-更新：** 通过最小化 $\\mathcal{L}_{\\rho}$ 来更新变量 $x$：\n$$ x^{k+1} = \\arg\\min_x \\left( g(x) + \\frac{\\rho}{2} (x - v^k + u^k)^2 \\right) $$\n代入 $g(x) = \\frac{\\gamma}{2} (x - y)^2$：\n$$ x^{k+1} = \\arg\\min_x \\left( \\frac{\\gamma}{2} (x - y)^2 + \\frac{\\rho}{2} (x - v^k + u^k)^2 \\right) $$\n为求最小值，我们将关于 $x$ 的导数设为零：\n$$ \\frac{\\partial}{\\partial x} \\left[ \\dots \\right] = \\gamma(x-y) + \\rho(x - v^k + u^k) = 0 $$\n$$ (\\gamma + \\rho)x = \\gamma y + \\rho(v^k - u^k) $$\n解出 $x$ 得到闭式更新：\n$$ x^{k+1} = \\frac{\\gamma y + \\rho(v^k - u^k)}{\\gamma + \\rho} $$\n\n**v-更新：** 标准的 $v$-更新是 $v^{k+1} = \\text{prox}_{h/\\rho}(x^{k+1} + u^k)$。在 PnP-ADMM 中，此步骤被替换为将去噪器 $D$ 应用于近端算子的参数：\n$$ v^{k+1} = D(x^{k+1} + u^k) $$\n使用指定的线性去噪器 $D(z) = \\alpha z$，更新变为：\n$$ v^{k+1} = \\alpha (x^{k+1} + u^k) $$\n\n**u-更新：** 缩放对偶变量的更新如下：\n$$ u^{k+1} = u^k + x^{k+1} - v^{k+1} $$\n\n这三个方程以闭式形式定义了 PnP-ADMM 迭代。\n\n**2. 线性仿射系统与稳定性分析**\n\n为了分析收敛性，我们将迭代公式化为一个线性仿射动力系统。系统的状态可以由迭代之间传递的变量 $v^k$ 和 $u^k$ 定义。我们将 $(v^{k+1}, u^{k+1})$ 表示为 $(v^k, u^k)$ 的函数。\n\n首先，将 $v^{k+1}$ 的表达式代入 $u$ 的更新式中：\n$$ u^{k+1} = u^k + x^{k+1} - \\alpha (x^{k+1} + u^k) = (1 - \\alpha)u^k + (1 - \\alpha)x^{k+1} $$\n现在，将 $x^{k+1}$ 的表达式代入 $v^{k+1}$ 和 $u^{k+1}$ 的更新式中。令 $c_x = \\frac{\\gamma y}{\\gamma + \\rho}$。\n$$ x^{k+1} = \\frac{\\rho}{\\gamma + \\rho}v^k - \\frac{\\rho}{\\gamma + \\rho}u^k + c_x $$\n$v^{k+1}$ 的更新变为：\n$$ v^{k+1} = \\alpha \\left( \\left[ \\frac{\\rho}{\\gamma + \\rho}v^k - \\frac{\\rho}{\\gamma + \\rho}u^k + c_x \\right] + u^k \\right) $$\n$$ v^{k+1} = \\alpha \\left( \\frac{\\rho}{\\gamma + \\rho}v^k + \\left(1 - \\frac{\\rho}{\\gamma + \\rho}\\right)u^k + c_x \\right) $$\n$$ v^{k+1} = \\frac{\\alpha\\rho}{\\gamma + \\rho}v^k + \\frac{\\alpha\\gamma}{\\gamma + \\rho}u^k + \\alpha c_x $$\n$u^{k+1}$ 的更新变为：\n$$ u^{k+1} = (1 - \\alpha)u^k + (1 - \\alpha)\\left( \\frac{\\rho}{\\gamma + \\rho}v^k - \\frac{\\rho}{\\gamma + \\rho}u^k + c_x \\right) $$\n$$ u^{k+1} = \\frac{\\rho(1 - \\alpha)}{\\gamma + \\rho}v^k + \\left( (1 - \\alpha) - \\frac{\\rho(1 - \\alpha)}{\\gamma + \\rho} \\right)u^k + (1 - \\alpha)c_x $$\n$$ u^{k+1} = \\frac{\\rho(1 - \\alpha)}{\\gamma + \\rho}v^k + (1 - \\alpha)\\left( \\frac{\\gamma + \\rho - \\rho}{\\gamma + \\rho} \\right)u^k + (1 - \\alpha)c_x $$\n$$ u^{k+1} = \\frac{\\rho(1 - \\alpha)}{\\gamma + \\rho}v^k + \\frac{\\gamma(1 - \\alpha)}{\\gamma + \\rho}u^k + (1 - \\alpha)c_x $$\n设状态向量为 $z^k = [v^k, u^k]^T$。该迭代是一个线性仿射系统 $z^{k+1} = M z^k + b$，其中矩阵 $M$ 和向量 $b$ 为：\n$$ M = \\frac{1}{\\gamma + \\rho} \\begin{pmatrix} \\alpha\\rho  \\alpha\\gamma \\\\ \\rho(1-\\alpha)  \\gamma(1-\\alpha) \\end{pmatrix}, \\quad b = c_x \\begin{pmatrix} \\alpha \\\\ 1-\\alpha \\end{pmatrix} = \\frac{\\gamma y}{\\gamma + \\rho} \\begin{pmatrix} \\alpha \\\\ 1-\\alpha \\end{pmatrix} $$\n该系统的稳定性由 $M$ 的谱半径 $\\rho(M)$ 决定，即其特征值的最大绝对值。我们通过求解 $\\det(M - \\lambda I) = 0$ 来找到特征值 $\\lambda$。令 $\\lambda' = (\\gamma+\\rho)\\lambda$ 为 $(\\gamma+\\rho)M$ 的特征值。\n$$ \\det \\begin{pmatrix} \\alpha\\rho - \\lambda'  \\alpha\\gamma \\\\ \\rho(1-\\alpha)  \\gamma(1-\\alpha) - \\lambda' \\end{pmatrix} = 0 $$\n$$ (\\alpha\\rho - \\lambda')(\\gamma(1-\\alpha) - \\lambda') - \\alpha\\gamma\\rho(1-\\alpha) = 0 $$\n$$ \\lambda'^2 - (\\alpha\\rho + \\gamma(1-\\alpha))\\lambda' + \\alpha\\rho\\gamma(1-\\alpha) - \\alpha\\gamma\\rho(1-\\alpha) = 0 $$\n$$ \\lambda'^2 - (\\alpha\\rho + \\gamma - \\alpha\\gamma)\\lambda' = 0 $$\n$$ \\lambda'(\\lambda' - (\\alpha\\rho + \\gamma - \\alpha\\gamma)) = 0 $$\n$(\\gamma+\\rho)M$ 的特征值为 $\\lambda'_1 = 0$ 和 $\\lambda'_2 = \\alpha(\\rho - \\gamma) + \\gamma$。因此，$M$ 的特征值为：\n$$ \\lambda_1 = 0, \\quad \\lambda_2 = \\frac{\\alpha(\\rho - \\gamma) + \\gamma}{\\gamma + \\rho} $$\n谱半径为 $\\rho(M) = \\max(|\\lambda_1|, |\\lambda_2|) = |\\lambda_2|$。\n$$ \\rho(M) = \\left| \\frac{\\alpha(\\rho - \\gamma) + \\gamma}{\\gamma + \\rho} \\right| $$\n如果 $\\rho(M)  1$，PnP-ADMM 迭代收敛；如果 $\\rho(M)  1$，则发散。在临界情况 $\\rho(M) = 1$ 时，如果常数项 $b$ 不在 $(I-M)$ 的像空间中（对于给定的参数即是如此），迭代可能表现出线性增长，因此发散。所以，发散的精确条件是 $\\rho(M) \\ge 1$。\n\n**3. 振荡行为的条件**\n\n振荡行为的特征是误差项在迭代过程中符号交替，当主导特征值为实数且为负时会发生。由于 $\\lambda_1 = 0$，动力学由 $\\lambda_2$ 控制。当 $\\lambda_2  0$ 时发生振荡。\n$$ \\frac{\\alpha(\\rho - \\gamma) + \\gamma}{\\gamma + \\rho}  0 $$\n因为 $\\gamma  0$ 且 $\\rho  0$，分母 $\\gamma + \\rho$ 为正。条件简化为：\n$$ \\alpha(\\rho - \\gamma) + \\gamma  0 \\implies \\alpha(\\rho - \\gamma)  -\\gamma $$\n这个不等式只有在 $\\rho - \\gamma  0$（即 $\\gamma  \\rho$）时才能满足，因为如果 $\\rho - \\gamma \\ge 0$，对于 $\\alpha  0$，左侧非负，不可能小于负值 $-\\gamma$。如果 $\\gamma  \\rho$，振荡的条件变为：\n$$ \\alpha  \\frac{-\\gamma}{\\rho - \\gamma} \\implies \\alpha  \\frac{\\gamma}{\\gamma - \\rho} $$\n因此，当 $\\gamma  \\rho$ 且去噪器增益 $\\alpha$ 足够大时，特别是当 $\\alpha  \\gamma / (\\gamma - \\rho)$ 时，预计会发生振荡行为。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    分析并模拟 PnP-ADMM 的几个测试用例。\n\n    对于每个用例，它计算迭代矩阵的谱半径，\n    根据谱半径确定是否发散，并通过模拟序列和\n    计算符号变化次数来检测振荡行为。\n    \"\"\"\n    # 测试用例：(alpha, gamma, rho, y, x0, v0, u0, K)\n    test_cases = [\n        (1.2, 0.1, 1.0, 1.0, 0.0, 0.0, 0.0, 50),\n        (5.0, 1.0, 0.1, 1.0, 0.0, 0.0, 0.0, 50),\n        (1.0 / (1.0 - 0.1), 0.1, 1.0, 1.0, 0.0, 0.0, 0.0, 50),\n        (0.8, 2.0, 1.0, 1.0, 0.0, 0.0, 0.0, 50),\n        (1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 50),\n    ]\n\n    results = []\n    for alpha, gamma, rho, y, x0, v0, u0, K in test_cases:\n        # 1. 理论分析\n        # 计算迭代矩阵的非零特征值。\n        lambda2 = (alpha * (rho - gamma) + gamma) / (gamma + rho)\n        \n        # 谱半径是主导特征值的绝对值。\n        spectral_radius = abs(lambda2)\n        \n        # 如果谱半径大于或等于 1，则发生发散。\n        diverges = spectral_radius >= 1.0\n\n        # 2. 模拟\n        x, v, u = float(x0), float(v0), float(u0)\n        u_history = [u]\n        \n        for _ in range(K):\n            # 一维 PnP-ADMM 更新\n            x_next = (gamma * y + rho * (v - u)) / (gamma + rho)\n            v_next = alpha * (x_next + u)\n            u_next = u + x_next - v_next\n            \n            x, v, u = x_next, v_next, u_next\n            u_history.append(u)\n        \n        # 3. 振荡检查\n        # 通过计算对偶变量 u 的符号交替次数来检测振荡。\n        sign_changes = 0\n        for i in range(1, len(u_history)):\n            # 如果 u_k 和 u_{k-1} 符号相反，则发生符号变化。\n            # np.sign 会正确处理零的情况。\n            if np.sign(u_history[i]) * np.sign(u_history[i-1]) == -1:\n                sign_changes += 1\n        \n        # 一个合理的振荡阈值：超过四分之一的步骤中发生符号变化。\n        oscillatory = sign_changes > K / 4\n\n        results.append([spectral_radius, diverges, oscillatory])\n\n    # 4. 格式化输出\n    # 输出必须是单行，格式化为无空格的列表之列表。\n    formatted_results = []\n    for r, b, o in results:\n        r_str = f\"{r:.6f}\"\n        b_str = str(b).lower()\n        o_str = str(o).lower()\n        formatted_results.append(f\"[{r_str},{b_str},{o_str}]\")\n    \n    # 最后的打印语句必须是精确的所需格式。\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在解决欠定逆问题（如压缩感知或图像修复）时，一个常见的挑战是算法可能在测量算子的零空间中“幻化”出伪影，因为这些伪影不会影响数据保真度。本实践练习将引导您量化这一现象，即所谓的“零空间漂移”，并设计一种惩罚项来主动抑制去噪器在零空间中引入的不必要变化。通过这个练习，您将学习如何从诊断问题发展到设计解决方案，这是高级信号处理中的一项关键技能。",
            "id": "3466556",
            "problem": "考虑压缩感知中的线性逆问题模型：一个信号 $\\mathbf{x} \\in \\mathbb{R}^n$ 通过测量 $\\mathbf{y} = A \\mathbf{x} + \\mathbf{w}$ 被观测到，其中 $A \\in \\mathbb{R}^{m \\times n}$ 是一个已知的传感矩阵（$m \\le n$），而 $\\mathbf{w}$ 是测量噪声。令 $D_\\sigma: \\mathbb{R}^n \\to \\mathbb{R}^n$ 是一个由噪声水平 $\\sigma  0$ 参数化的去噪器，如同在即插即用交替方向乘子法 (Plug-and-Play Alternating Direction Method of Multipliers, ADMM) 和通过去噪实现正则化 (Regularization by Denoising, RED) 中所使用的那样。在欠定情况下，零空间 $\\mathcal{N}(A) = \\{\\mathbf{z} \\in \\mathbb{R}^n : A \\mathbf{z} = \\mathbf{0}\\}$ 是非平凡的，并且对 $\\mathbf{x}$ 在 $\\mathcal{N}(A)$ 中分量的改变不会影响数据一致性项 $\\|A \\mathbf{x} - \\mathbf{y}\\|_2$。这可能导致失效模式，即去噪器 $D_\\sigma$ 在零空间中产生幻觉内容，也就是说，沿着测量不可见的方向修改 $\\mathbf{x}$。\n\n您必须仅使用线性代数和优化中的基本定义和经过充分检验的事实来完成以下任务：\n\n1. 定义到零空间 $\\mathcal{N}(A)$ 的正交投影算子 $P_{\\mathcal{N}(A)}$，并计算由去噪器引起的零空间漂移：\n   $$\\Delta_{\\text{ns}}(\\mathbf{x}; A, D_\\sigma) = \\left\\| P_{\\mathcal{N}(A)} \\left( D_\\sigma(\\mathbf{x}) \\right) - P_{\\mathcal{N}(A)} \\left( \\mathbf{x} \\right) \\right\\|_2.$$\n   您的程序应为每个测试用例数值计算此量。\n\n2. 设计一种惩罚项来抑制零空间的变化，通过求解以下问题（对于给定的 $\\lambda_{\\text{ns}} \\ge 0$）：\n   $$\\mathbf{z}^\\star = \\arg\\min_{\\mathbf{z} \\in \\mathbb{R}^n} \\; \\frac{1}{2} \\left\\| \\mathbf{z} - D_\\sigma(\\mathbf{x}) \\right\\|_2^2 \\;+\\; \\frac{\\lambda_{\\text{ns}}}{2} \\left\\| P_{\\mathcal{N}(A)} \\left( \\mathbf{z} - \\mathbf{x} \\right) \\right\\|_2^2.$$\n   仅使用 $P_{\\mathcal{N}(A)}$ 是正交投影算子（对称且幂等）的性质以及二次最小化的基本规则，从第一性原理推导出 $\\mathbf{z}^\\star$ 关于 $D_\\sigma(\\mathbf{x})$、$P_{\\mathcal{N}(A)}$、$\\mathbf{x}$ 和 $\\lambda_{\\text{ns}}$ 的显式表达式。\n\n3. 实现推导出的 $\\mathbf{z}^\\star$ 表达式，并测量带惩罚的零空间漂移：\n   $$\\Delta_{\\text{ns}}^{\\text{pen}}(\\mathbf{x}; A, D_\\sigma, \\lambda_{\\text{ns}}) = \\left\\| P_{\\mathcal{N}(A)} \\left( \\mathbf{z}^\\star \\right) - P_{\\mathcal{N}(A)} \\left( \\mathbf{x} \\right) \\right\\|_2.$$\n   您的程序必须验证当 $\\lambda_{\\text{ns}}  0$ 时，与未惩罚的漂移相比，零空间漂移是否减少。\n\n使用的基本原理：\n- 零空间定义 $\\mathcal{N}(A) = \\{\\mathbf{z} : A \\mathbf{z} = \\mathbf{0}\\}$。\n- 正交投影算子性质：$P_{\\mathcal{N}(A)}^\\top = P_{\\mathcal{N}(A)}$ 和 $P_{\\mathcal{N}(A)}^2 = P_{\\mathcal{N}(A)}$。\n- 使用奇异值分解 (SVD) 来计算 $\\mathcal{N}(A)$ 的标准正交基，从而计算 $P_{\\mathcal{N}(A)}$。\n- 对称半正定矩阵的二次最小化。\n\n需实现的去噪器定义：\n- 对于 $\\sigma \\ge 0$，使用逐元素软阈值去噪器：\n  $$\\left[ D_\\sigma(\\mathbf{x}) \\right]_i = \\operatorname{sign}(x_i) \\cdot \\max\\left( |x_i| - \\sigma, \\; 0 \\right), \\quad i = 1, \\dots, n.$$\n\n$P_{\\mathcal{N}(A)}$ 的数值计算：\n- 计算奇异值分解 $A = U \\Sigma V^\\top$，其中 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵。令 $r$ 为 $A$ 的数值秩（大于一个容差的奇异值数量）。那么 $\\mathcal{N}(A)$ 的一个标准正交基由 $V$ 的最后 $n - r$ 列给出。如果 $V_{\\text{null}} \\in \\mathbb{R}^{n \\times (n-r)}$ 汇集了这些列，则设置\n  $$P_{\\mathcal{N}(A)} = V_{\\text{null}} V_{\\text{null}}^\\top.$$\n- 如果 $\\mathcal{N}(A) = \\{\\mathbf{0}\\}$，则 $P_{\\mathcal{N}(A)}$ 是 $\\mathbb{R}^{n \\times n}$ 中的零矩阵。\n\n测试套件：\n为以下五个测试用例实现计算。矩阵和向量已明确指定，必须完全按照给定的使用。\n\n- 用例 1（欠定，中等惩罚）：\n  $$A_1 = \\begin{bmatrix}\n  1  0  -1  2  0  1  0  0 \\\\\n  0  1  0  -1  2  0  1  0 \\\\\n  1  1  0  0  1  -1  0  1 \\\\\n  0  0  1  1  -1  0  2  0 \\\\\n  2  -1  0  0  1  1  0  -1\n  \\end{bmatrix}, \\quad \\mathbf{x}_1 = \\begin{bmatrix} 0.3 \\\\ -0.7 \\\\ 1.2 \\\\ -0.1 \\\\ 0.0 \\\\ 0.5 \\\\ -0.4 \\\\ 0.9 \\end{bmatrix}, \\quad \\sigma_1 = 0.2, \\quad \\lambda_{\\text{ns},1} = 0.5.$$\n\n- 用例 2（与用例 1 相同，无惩罚）：\n  $$A_1 \\text{ 如上}, \\quad \\mathbf{x}_1 \\text{ 如上}, \\quad \\sigma_2 = 0.2, \\quad \\lambda_{\\text{ns},2} = 0.$$\n\n- 用例 3（与用例 1 相同，强惩罚）：\n  $$A_1 \\text{ 如上}, \\quad \\mathbf{x}_1 \\text{ 如上}, \\quad \\sigma_3 = 0.2, \\quad \\lambda_{\\text{ns},3} = 10.$$\n\n- 用例 4（方阵，满秩矩阵，零空间平凡）：\n  $$A_2 = \\begin{bmatrix}\n  2  0  0  0  0  0 \\\\\n  1  3  0  0  0  0 \\\\\n  0  -1  1  0  0  0 \\\\\n  0  0  2  4  0  0 \\\\\n  0  0  0  -2  5  0 \\\\\n  0  0  0  0  1  6\n  \\end{bmatrix}, \\quad \\mathbf{x}_2 = \\begin{bmatrix} 1.0 \\\\ -0.5 \\\\ 0.25 \\\\ -1.5 \\\\ 0.75 \\\\ 0.0 \\end{bmatrix}, \\quad \\sigma_4 = 0.3, \\quad \\lambda_{\\text{ns},4} = 0.7.$$\n\n- 用例 5（欠定，恒等去噪器）：\n  $$A_1 \\text{ 如上}, \\quad \\mathbf{x}_3 = \\begin{bmatrix} -0.05 \\\\ 0.04 \\\\ -0.8 \\\\ 0.12 \\\\ -0.33 \\\\ 0.55 \\\\ 0.0 \\\\ -0.1 \\end{bmatrix}, \\quad \\sigma_5 = 0.0, \\quad \\lambda_{\\text{ns},5} = 5.0.$$\n\n每个用例的任务：\n- 计算投影算子 $P_{\\mathcal{N}(A)}$。\n- 计算未经惩罚的去噪器输出 $D_\\sigma(\\mathbf{x})$。\n- 计算零空间漂移 $\\Delta_{\\text{ns}}(\\mathbf{x}; A, D_\\sigma)$。\n- 推导并实现带惩罚的输出 $\\mathbf{z}^\\star$。\n- 计算带惩罚的零空间漂移 $\\Delta_{\\text{ns}}^{\\text{pen}}(\\mathbf{x}; A, D_\\sigma, \\lambda_{\\text{ns}})$。\n- 判断漂移是否减少，即检查是否 $\\Delta_{\\text{ns}}^{\\text{pen}} \\le \\Delta_{\\text{ns}}$。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须表示为一个包含四个条目的列表，顺序如下：\n$$\\left[ \\Delta_{\\text{ns}}, \\; \\Delta_{\\text{ns}}^{\\text{pen}}, \\; r, \\; b \\right],$$\n其中 $r$ 是浮点数缩减比率 $\\Delta_{\\text{ns}}^{\\text{pen}} / \\Delta_{\\text{ns}}$（如果 $\\Delta_{\\text{ns}} = 0$，则使用 $r = 1.0$），$b$ 是一个布尔值，指示零空间漂移是否减少。例如：\n$$\\left[ [d_1, d_1^{\\text{pen}}, r_1, b_1], [d_2, d_2^{\\text{pen}}, r_2, b_2], \\dots \\right].$$",
            "solution": "在尝试解决问题之前，需对问题进行验证。\n\n### 步骤 1：提取已知条件\n\n- **模型**：线性逆问题 $\\mathbf{y} = A \\mathbf{x} + \\mathbf{w}$，其中 $\\mathbf{x} \\in \\mathbb{R}^n$，$\\mathbf{y} \\in \\mathbb{R}^m$，$A \\in \\mathbb{R}^{m \\times n}$ ($m \\le n$)，以及噪声 $\\mathbf{w}$。\n- **去噪器**：一个函数 $D_\\sigma: \\mathbb{R}^n \\to \\mathbb{R}^n$，由噪声水平 $\\sigma  0$ 参数化。具体实现是逐元素软阈值算子：$\\left[ D_\\sigma(\\mathbf{x}) \\right]_i = \\operatorname{sign}(x_i) \\cdot \\max\\left( |x_i| - \\sigma, \\; 0 \\right)$。\n- **零空间**：$\\mathcal{N}(A) = \\{\\mathbf{z} \\in \\mathbb{R}^n : A \\mathbf{z} = \\mathbf{0}\\}$。\n- **投影算子**：$P_{\\mathcal{N}(A)}$ 是到 $\\mathcal{N}(A)$ 上的正交投影算子。\n- **投影算子计算**：给定 SVD 分解 $A = U \\Sigma V^\\top$，其中 $V = [\\mathbf{v}_1, \\dots, \\mathbf{v}_n]$ 是正交矩阵，且 $A$ 的秩为 $r$。零空间的基是 $V_{\\text{null}} = [\\mathbf{v}_{r+1}, \\dots, \\mathbf{v}_n]$。投影算子为 $P_{\\mathcal{N}(A)} = V_{\\text{null}} V_{\\text{null}}^\\top$。\n- **投影算子性质**：$P_{\\mathcal{N}(A)}^\\top = P_{\\mathcal{N}(A)}$ (对称性) 和 $P_{\\mathcal{N}(A)}^2 = P_{\\mathcal{N}(A)}$ (幂等性)。\n- **零空间漂移**：$\\Delta_{\\text{ns}}(\\mathbf{x}; A, D_\\sigma) = \\left\\| P_{\\mathcal{N}(A)} \\left( D_\\sigma(\\mathbf{x}) \\right) - P_{\\mathcal{N}(A)} \\left( \\mathbf{x} \\right) \\right\\|_2$。\n- **带惩罚的优化问题**：\n  $$\\mathbf{z}^\\star = \\arg\\min_{\\mathbf{z} \\in \\mathbb{R}^n} \\; \\frac{1}{2} \\left\\| \\mathbf{z} - D_\\sigma(\\mathbf{x}) \\right\\|_2^2 \\;+\\; \\frac{\\lambda_{\\text{ns}}}{2} \\left\\| P_{\\mathcal{N}(A)} \\left( \\mathbf{z} - \\mathbf{x} \\right) \\right\\|_2^2, \\quad \\text{对于给定的 } \\lambda_{\\text{ns}} \\ge 0。$$\n- **带惩罚的零空间漂移**：$\\Delta_{\\text{ns}}^{\\text{pen}}(\\mathbf{x}; A, D_\\sigma, \\lambda_{\\text{ns}}) = \\left\\| P_{\\mathcal{N}(A)} \\left( \\mathbf{z}^\\star \\right) - P_{\\mathcal{N}(A)} \\left( \\mathbf{x} \\right) \\right\\|_2$。\n- **测试用例**：提供了五个具体用例，包括矩阵 $A_1, A_2$，向量 $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3$，以及参数 $\\sigma_k, \\lambda_{\\text{ns},k}$。\n- **要求输出**：对于每个用例，计算 $\\Delta_{\\text{ns}}$，$\\Delta_{\\text{ns}}^{\\text{pen}}$，缩减比率 $r$，以及一个布尔值 $b$ 指示漂移是否减少。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n- **科学依据**：该问题牢固地植根于线性代数（零空间、正交投影算子、SVD）和凸优化（二次最小化）。应用背景是压缩感知和图像重建，其中即插即用方法和零空间行为是成熟的研究领域。模型和定义都是标准的。\n- **良构性**：求解 $\\mathbf{z}^\\star$ 的优化问题涉及最小化两个平方 $\\ell_2$-范数之和。该目标函数是严格凸的，保证了唯一解的存在。计算步骤规定明确。\n- **客观性**：问题陈述具有数学上的精确性。所有变量、矩阵和任务都进行了正式定义。没有主观或含糊不清的语言。\n\n该问题没有表现出验证标准中列出的任何缺陷。它在科学上是合理的、良构的且客观的。\n\n### 步骤 3：结论与行动\n\n此问题是**有效的**。将提供完整解答。\n\n### 求解推导与方法\n\n该问题要求推导带惩罚的估计 $\\mathbf{z}^\\star$ 并分析其对零空间漂移的影响。\n\n**1. 零空间投影算子与漂移计算**\n\n到零空间 $\\mathcal{N}(A)$ 的正交投影算子是一个对称且幂等的矩阵 $P_{\\mathcal{N}(A)}$。它可以从 $\\mathcal{N}(A)$ 的一个标准正交基构建。根据题目要求，可以从矩阵 A 的奇异值分解 (SVD) 中找到这样的一个基。设 $A = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是奇异值 $\\sigma_1 \\geq \\sigma_2 \\geq \\dots \\geq 0$ 组成的对角矩阵。如果 $A$ 的数值秩为 $r$，那么 $V$ 的最后 $n-r$ 列（对应于零或数值上可忽略的奇异值）构成了 $\\mathcal{N}(A)$ 的一个标准正交基。将这个基汇集在矩阵 $V_{\\text{null}} \\in \\mathbb{R}^{n \\times (n-r)}$ 中。则投影算子由 $P_{\\mathcal{N}(A)} = V_{\\text{null}}V_{\\text{null}}^\\top$ 给出。如果 $n=r$，则零空间是平凡的，即 $\\mathcal{N}(A) = \\{\\mathbf{0}\\}$，且 $P_{\\mathcal{N}(A)}$ 是 $n \\times n$ 的零矩阵。\n\n未惩罚的零空间漂移定义为 $\\Delta_{\\text{ns}} = \\| P_{\\mathcal{N}(A)}(D_\\sigma(\\mathbf{x})) - P_{\\mathcal{N}(A)}(\\mathbf{x}) \\|_2$。利用投影算子的线性性质，这可以简化为：\n$$ \\Delta_{\\text{ns}} = \\left\\| P_{\\mathcal{N}(A)} \\left( D_\\sigma(\\mathbf{x}) - \\mathbf{x} \\right) \\right\\|_2 $$\n\n**2. 带惩罚解 $\\mathbf{z}^\\star$ 的推导**\n\n解 $\\mathbf{z}^\\star$ 最小化目标函数：\n$$ J(\\mathbf{z}) = \\frac{1}{2} \\left\\| \\mathbf{z} - D_\\sigma(\\mathbf{x}) \\right\\|_2^2 \\;+\\; \\frac{\\lambda_{\\text{ns}}}{2} \\left\\| P_{\\mathcal{N}(A)} \\left( \\mathbf{z} - \\mathbf{x} \\right) \\right\\|_2^2 $$\n这个函数是二次且凸的。通过将其关于 $\\mathbf{z}$ 的梯度设为零来找到最小值。首先，我们使用内积展开平方范数：\n$$ J(\\mathbf{z}) = \\frac{1}{2} (\\mathbf{z} - D_\\sigma(\\mathbf{x}))^\\top (\\mathbf{z} - D_\\sigma(\\mathbf{x})) + \\frac{\\lambda_{\\text{ns}}}{2} (\\mathbf{z} - \\mathbf{x})^\\top P_{\\mathcal{N}(A)}^\\top P_{\\mathcal{N}(A)} (\\mathbf{z} - \\mathbf{x}) $$\n利用性质 $P_{\\mathcal{N}(A)}^\\top = P_{\\mathcal{N}(A)}$ 和 $P_{\\mathcal{N}(A)}^2 = P_{\\mathcal{N}(A)}$，上式变为：\n$$ J(\\mathbf{z}) = \\frac{1}{2} (\\mathbf{z} - D_\\sigma(\\mathbf{x}))^\\top (\\mathbf{z} - D_\\sigma(\\mathbf{x})) + \\frac{\\lambda_{\\text{ns}}}{2} (\\mathbf{z} - \\mathbf{x})^\\top P_{\\mathcal{N}(A)} (\\mathbf{z} - \\mathbf{x}) $$\n关于 $\\mathbf{z}$ 的梯度是：\n$$ \\nabla_{\\mathbf{z}} J(\\mathbf{z}) = (\\mathbf{z} - D_\\sigma(\\mathbf{x})) + \\lambda_{\\text{ns}} P_{\\mathcal{N}(A)} (\\mathbf{z} - \\mathbf{x}) $$\n设 $\\nabla_{\\mathbf{z}} J(\\mathbf{z}^\\star) = \\mathbf{0}$：\n$$ \\mathbf{z}^\\star - D_\\sigma(\\mathbf{x}) + \\lambda_{\\text{ns}} P_{\\mathcal{N}(A)} \\mathbf{z}^\\star - \\lambda_{\\text{ns}} P_{\\mathcal{N}(A)} \\mathbf{x} = \\mathbf{0} $$\n将含 $\\mathbf{z}^\\star$ 的项组合在一起：\n$$ (I + \\lambda_{\\text{ns}} P_{\\mathcal{N}(A)}) \\mathbf{z}^\\star = D_\\sigma(\\mathbf{x}) + \\lambda_{\\text{ns}} P_{\\mathcal{N}(A)} \\mathbf{x} $$\n其中 $I$ 是单位矩阵。为了求解 $\\mathbf{z}^\\star$，我们需要找到矩阵 $(I + \\lambda_{\\text{ns}} P_{\\mathcal{N}(A)})$ 的逆。我们可以假设一个形式为 $(I + \\alpha P_{\\mathcal{N}(A)})$ 的逆，并求解 $\\alpha$。\n$$ (I + \\lambda_{\\text{ns}} P_{\\mathcal{N}(A)})(I + \\alpha P_{\\mathcal{N}(A)}) = I + \\alpha P_{\\mathcal{N}(A)} + \\lambda_{\\text{ns}} P_{\\mathcal{N}(A)} + \\alpha \\lambda_{\\text{ns}} P_{\\mathcal{N}(A)}^2 \\\\ = I + (\\alpha + \\lambda_{\\text{ns}} + \\alpha \\lambda_{\\text{ns}}) P_{\\mathcal{N}(A)} $$\n为了使此表达式等于 $I$，$P_{\\mathcal{N}(A)}$ 的系数必须为零：\n$$ \\alpha(1 + \\lambda_{\\text{ns}}) + \\lambda_{\\text{ns}} = 0 \\implies \\alpha = -\\frac{\\lambda_{\\text{ns}}}{1+\\lambda_{\\text{ns}}} $$\n这是有效的，因为 $\\lambda_{\\text{ns}} \\ge 0$。因此，$(I + \\lambda_{\\text{ns}} P_{\\mathcal{N}(A)})^{-1} = I - \\frac{\\lambda_{\\text{ns}}}{1+\\lambda_{\\text{ns}}} P_{\\mathcal{N}(A)}$。\n应用这个逆矩阵：\n$$ \\mathbf{z}^\\star = \\left(I - \\frac{\\lambda_{\\text{ns}}}{1+\\lambda_{\\text{ns}}} P_{\\mathcal{N}(A)}\\right) \\left( D_\\sigma(\\mathbf{x}) + \\lambda_{\\text{ns}} P_{\\mathcal{N}(A)} \\mathbf{x} \\right) $$\n展开并简化（使用 $P_{\\mathcal{N}(A)}^2=P_{\\mathcal{N}(A)}$）：\n$$ \\mathbf{z}^\\star = D_\\sigma(\\mathbf{x}) + \\lambda_{\\text{ns}} P_{\\mathcal{N}(A)}\\mathbf{x} - \\frac{\\lambda_{\\text{ns}}}{1+\\lambda_{\\text{ns}}} P_{\\mathcal{N}(A)}D_\\sigma(\\mathbf{x}) - \\frac{\\lambda_{\\text{ns}}^2}{1+\\lambda_{\\text{ns}}} P_{\\mathcal{N}(A)}\\mathbf{x} $$\n$$ \\mathbf{z}^\\star = D_\\sigma(\\mathbf{x}) - \\frac{\\lambda_{\\text{ns}}}{1+\\lambda_{\\text{ns}}} P_{\\mathcal{N}(A)}D_\\sigma(\\mathbf{x}) + \\left(\\lambda_{\\text{ns}} - \\frac{\\lambda_{\\text{ns}}^2}{1+\\lambda_{\\text{ns}}}\\right) P_{\\mathcal{N}(A)}\\mathbf{x} $$\n括号中的项简化为 $\\frac{\\lambda_{\\text{ns}}}{1+\\lambda_{\\text{ns}}}$。所以，我们得到最终表达式：\n$$ \\mathbf{z}^\\star = D_\\sigma(\\mathbf{x}) - \\frac{\\lambda_{\\text{ns}}}{1+\\lambda_{\\text{ns}}} P_{\\mathcal{N}(A)} \\left( D_\\sigma(\\mathbf{x}) - \\mathbf{x} \\right) $$\n这个表达式计算效率很高，并将在实现中使用。\n\n**3. 带惩罚的零空间漂移分析**\n\n带惩罚的零空间漂移是 $\\Delta_{\\text{ns}}^{\\text{pen}} = \\| P_{\\mathcal{N}(A)}(\\mathbf{z}^\\star) - P_{\\mathcal{N}(A)}(\\mathbf{x}) \\|_2 = \\| P_{\\mathcal{N}(A)}(\\mathbf{z}^\\star - \\mathbf{x}) \\|_2$。\n我们来求投影后的差值 $P_{\\mathcal{N}(A)}(\\mathbf{z}^\\star - \\mathbf{x})$：\n$$ \\mathbf{z}^\\star - \\mathbf{x} = (D_\\sigma(\\mathbf{x}) - \\mathbf{x}) - \\frac{\\lambda_{\\text{ns}}}{1+\\lambda_{\\text{ns}}} P_{\\mathcal{N}(A)} ( D_\\sigma(\\mathbf{x}) - \\mathbf{x} ) $$\n从左侧应用 $P_{\\mathcal{N}(A)}$ 并使用 $P_{\\mathcal{N}(A)}^2 = P_{\\mathcal{N}(A)}$：\n$$ P_{\\mathcal{N}(A)}(\\mathbf{z}^\\star - \\mathbf{x}) = P_{\\mathcal{N}(A)}(D_\\sigma(\\mathbf{x}) - \\mathbf{x}) - \\frac{\\lambda_{\\text{ns}}}{1+\\lambda_{\\text{ns}}} P_{\\mathcal{N}(A)}^2 ( D_\\sigma(\\mathbfx) - \\mathbf{x} ) $$\n$$ P_{\\mathcal{N}(A)}(\\mathbf{z}^\\star - \\mathbf{x}) = \\left(1 - \\frac{\\lambda_{\\text{ns}}}{1+\\lambda_{\\text{ns}}}\\right) P_{\\mathcal{N}(A)} ( D_\\sigma(\\mathbf{x}) - \\mathbf{x} ) = \\frac{1}{1+\\lambda_{\\text{ns}}} P_{\\mathcal{N}(A)} ( D_\\sigma(\\mathbf{x}) - \\mathbf{x} ) $$\n取 $\\ell_2$-范数得到带惩罚的漂移：\n$$ \\Delta_{\\text{ns}}^{\\text{pen}} = \\left\\| \\frac{1}{1+\\lambda_{\\text{ns}}} P_{\\mathcal{N}(A)} ( D_\\sigma(\\mathbf{x}) - \\mathbf{x} ) \\right\\|_2 = \\frac{1}{1+\\lambda_{\\text{ns}}} \\left\\| P_{\\mathcal{N}(A)} ( D_\\sigma(\\mathbf{x}) - \\mathbf{x} ) \\right\\|_2 $$\n这导出了一个显著的解析关系：\n$$ \\Delta_{\\text{ns}}^{\\text{pen}} = \\frac{1}{1+\\lambda_{\\text{ns}}} \\Delta_{\\text{ns}} $$\n缩减比率为 $r = \\Delta_{\\text{ns}}^{\\text{pen}} / \\Delta_{\\text{ns}} = \\frac{1}{1+\\lambda_{\\text{ns}}}$，前提是 $\\Delta_{\\text{ns}} \\neq 0$。根据要求，如果 $\\Delta_{\\text{ns}} = 0$，我们设 $r=1.0$。\n由于 $\\lambda_{\\text{ns}} \\ge 0$，因子 $\\frac{1}{1+\\lambda_{\\text{ns}}}$ 总是小于或等于 $1$。因此，$\\Delta_{\\text{ns}}^{\\text{pen}} \\le \\Delta_{\\text{ns}}$ 总是成立，这意味着该惩罚永远不会增加零空间漂移。对于 $\\lambda_{\\text{ns}}  0$ 且 $\\Delta_{\\text{ns}}  0$ 的情况，漂移被严格减小。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    # --- Test Case Definitions ---\n    A1 = np.array([\n        [1, 0, -1, 2, 0, 1, 0, 0],\n        [0, 1, 0, -1, 2, 0, 1, 0],\n        [1, 1, 0, 0, 1, -1, 0, 1],\n        [0, 0, 1, 1, -1, 0, 2, 0],\n        [2, -1, 0, 0, 1, 1, 0, -1]\n    ], dtype=np.float64)\n\n    x1 = np.array([0.3, -0.7, 1.2, -0.1, 0.0, 0.5, -0.4, 0.9], dtype=np.float64)\n\n    A2 = np.array([\n        [2, 0, 0, 0, 0, 0],\n        [1, 3, 0, 0, 0, 0],\n        [0, -1, 1, 0, 0, 0],\n        [0, 0, 2, 4, 0, 0],\n        [0, 0, 0, -2, 5, 0],\n        [0, 0, 0, 0, 1, 6]\n    ], dtype=np.float64)\n\n    x2 = np.array([1.0, -0.5, 0.25, -1.5, 0.75, 0.0], dtype=np.float64)\n\n    x3 = np.array([-0.05, 0.04, -0.8, 0.12, -0.33, 0.55, 0.0, -0.1], dtype=np.float64)\n\n    test_cases = [\n        # Case 1: underdetermined, moderate penalization\n        {'A': A1, 'x': x1, 'sigma': 0.2, 'lambda_ns': 0.5},\n        # Case 2: same as Case 1, no penalization\n        {'A': A1, 'x': x1, 'sigma': 0.2, 'lambda_ns': 0.0},\n        # Case 3: same as Case 1, strong penalization\n        {'A': A1, 'x': x1, 'sigma': 0.2, 'lambda_ns': 10.0},\n        # Case 4: square, full-rank matrix\n        {'A': A2, 'x': x2, 'sigma': 0.3, 'lambda_ns': 0.7},\n        # Case 5: underdetermined, identity denoiser\n        {'A': A1, 'x': x3, 'sigma': 0.0, 'lambda_ns': 5.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        res = compute_drift_metrics(**case)\n        results.append(list(res))\n    \n    # Custom string representation to match the required format\n    # \"[ [d_1, d_1^pen, r_1, b_1], [d_2, d_2^pen, r_2, b_2], ... ]\"\n    # Python's default `str(list)` includes spaces after commas.\n    # We construct the string manually for precise formatting.\n    outer_list = []\n    for res_list in results:\n        # Format each item in the inner list\n        d_ns_str = f\"{res_list[0]:.16g}\"\n        d_pen_str = f\"{res_list[1]:.16g}\"\n        r_str = f\"{res_list[2]:.16g}\"\n        b_str = 'true' if res_list[3] else 'false'\n        inner_str = f\"[{d_ns_str},{d_pen_str},{r_str},{b_str}]\"\n        outer_list.append(inner_str)\n    \n    final_output = f\"[{','.join(outer_list)}]\"\n    print(final_output)\n\n\ndef soft_thresholding_denoiser(x, sigma):\n    \"\"\"\n    Computes the elementwise soft-thresholding denoiser.\n    [D_sigma(x)]_i = sign(x_i) * max(|x_i| - sigma, 0)\n    \"\"\"\n    if sigma  0:\n        raise ValueError(\"Sigma must be non-negative.\")\n    return np.sign(x) * np.maximum(np.abs(x) - sigma, 0)\n\ndef get_null_space_projector(A, tol=1e-12):\n    \"\"\"\n    Computes the orthogonal projector onto the null space of A.\n    \"\"\"\n    n = A.shape[1]\n    # U, s, Vt are standard names for SVD components. V is Vt.T\n    _, s, Vt = np.linalg.svd(A)\n    \n    # Determine numerical rank\n    rank = np.sum(s  tol)\n    \n    # Get the basis for the null space (last n-r columns of V)\n    V_null = Vt[rank:].T\n    \n    # The projector P = V_null @ V_null.T\n    if V_null.shape[1] == 0: # Trivial null space\n        return np.zeros((n, n), dtype=A.dtype)\n    else:\n        return V_null @ V_null.T\n\ndef compute_drift_metrics(A, x, sigma, lambda_ns):\n    \"\"\"\n    Computes all required metrics for a single test case.\n    \n    Returns:\n        tuple: (delta_ns, delta_ns_pen, r, b)\n    \"\"\"\n    # 1. Compute the projector\n    P_ns = get_null_space_projector(A)\n    \n    # 2. Compute the denoiser output\n    Dx = soft_thresholding_denoiser(x, sigma)\n    \n    # 3. Compute the unpenalized null-space drift\n    diff_unpenalized = Dx - x\n    projected_diff_unpenalized = P_ns @ diff_unpenalized\n    delta_ns = np.linalg.norm(projected_diff_unpenalized)\n    \n    # 4. Compute the penalized solution z_star from the derived expression\n    # z_star = Dx - (lambda_ns / (1 + lambda_ns)) * P_ns @ (Dx - x)\n    if 1 + lambda_ns == 0: # Should not happen as lambda_ns >= 0\n        factor = np.inf\n    else:\n        factor = lambda_ns / (1 + lambda_ns)\n        \n    z_star = Dx - factor * projected_diff_unpenalized\n    \n    # 5. Compute the penalized null-space drift\n    diff_penalized = z_star - x\n    projected_diff_penalized = P_ns @ diff_penalized\n    delta_ns_pen = np.linalg.norm(projected_diff_penalized)\n    \n    # 6. Compute reduction ratio r\n    if delta_ns  1e-15: # Treat numerically zero drift as a special case\n        r = 1.0\n    else:\n        r = delta_ns_pen / delta_ns\n        \n    # 7. Check if drift decreased\n    # Use a small tolerance for floating point comparison\n    b = (delta_ns_pen = delta_ns + 1e-15)\n    \n    return delta_ns, delta_ns_pen, r, b\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}