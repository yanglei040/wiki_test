{
    "hands_on_practices": [
        {
            "introduction": "将雷诺输运定理应用于推导机械能平衡方程是一项基本练习。此实践练习  要求您精确地计算移动的无滑移壁面所做的功，这是计算流体动力学中的一个常见情景。通过正确识别壁面功项，您将对流固界面的能量传递获得更深刻的物理直觉，并理解一个用于验证数值求解器能量守恒性的关键细节。",
            "id": "3358314",
            "problem": "考虑一个毗邻运动的、不可渗透的、无滑移壁面的粘性不可压缩流体，壁面的瞬时速度表示为 $\\boldsymbol{U}_w(t)$。选取一个紧贴壁面并随壁面沿其表面移动的控制体 $\\mathsf{CV}$，使得与壁面重合的控制面部分的边界速度等于 $\\boldsymbol{U}_w(t)$。你的任务是从第一性原理出发，使用雷诺输运定理为 $\\mathsf{CV}$ 内的流体建立机械能平衡方程，并明确指出移动无滑移壁面的精确壁面功项。\n\n使用的基本依据和定义：\n- 牛顿第二定律和 Cauchy 应力张量 $\\boldsymbol{\\sigma} = -p \\boldsymbol{I} + 2 \\mu \\boldsymbol{S}$，其中 $\\mu$ 是动力粘度，$p$ 是压力，$\\boldsymbol{S} = \\tfrac{1}{2} \\left( \\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^{\\mathsf{T}} \\right)$ 是应变率张量。\n- 单位体积的总机械能密度为 $e_m = \\tfrac{1}{2} \\rho \\lvert \\boldsymbol{u} \\rvert^2 + \\rho \\Phi$，其中 $\\rho$ 是质量密度，$\\Phi$ 是单位质量势能（在验证案例中取 $\\Phi = 0$）。\n- 对于一般标量 $\\phi(\\boldsymbol{x},t)$ 的雷诺输运定理：$\\dfrac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\mathsf{CV}} \\rho \\, \\phi \\, \\mathrm{d}V = \\int_{\\mathsf{CV}} \\dfrac{\\partial}{\\partial t}(\\rho \\phi) \\, \\mathrm{d}V + \\int_{\\mathsf{CS}} \\rho \\, \\phi \\, (\\boldsymbol{u} - \\boldsymbol{u}_{\\mathsf{CS}}) \\cdot \\boldsymbol{n} \\, \\mathrm{d}A$，其中 $\\boldsymbol{u}_{\\mathsf{CS}}$ 是局部控制面速度，$\\boldsymbol{n}$ 是从 $\\mathsf{CV}$ 指出的单位外法向量。\n\n要求 A：基于这些依据，推导紧贴无滑移壁面的移动控制体的机械能平衡方程，并确定精确的壁面功项。清楚地说明为什么在控制面的壁面部分 $A_w$ 上，正确的壁面功项是 $\\int_{A_w} \\boldsymbol{t}_w \\cdot \\boldsymbol{U}_w \\, \\mathrm{d}A$，其中 $\\boldsymbol{t}_w = \\boldsymbol{\\sigma} \\cdot \\boldsymbol{n}$ 是壁面对流体施加的曳力（$\\boldsymbol{n}$ 是从流体指向壁面的外法向量）。\n\n要求 B（验证案例）：考虑半无限半空间 $y \\ge 0$ 中的 Stokes 第一问题，其中位于 $y=0$ 的平板在 $t>0$ 时开始以恒定切向速度 $U$ 沿 $x$ 方向运动。流体初始静止 $\\boldsymbol{u}(\\boldsymbol{x},0) = \\boldsymbol{0}$，且忽略重力，因此 $\\Phi = 0$。使用 Stokes 第一问题的精确速度场，计算单位壁面面积的三个量：\n- 单位面积的壁面功率输入 $P_{\\text{wall}}(t) = \\int_{A_w} \\boldsymbol{t}_w \\cdot \\boldsymbol{U}_w \\, \\mathrm{d}A$，用 $\\mu$、$U$、运动粘度 $\\nu = \\mu/\\rho$ 和时间 $t$ 表示。\n- 单位面积的粘性耗散率 $D(t) = \\mu \\int_0^\\infty \\left( \\dfrac{\\partial u}{\\partial y} \\right)^2 \\mathrm{d}y$。\n- 单位面积的流体内机械能的精确变化率 $E'(t) = \\dfrac{\\mathrm{d}}{\\mathrm{d}t} \\int_0^\\infty \\tfrac{1}{2} \\rho u(y,t)^2 \\, \\mathrm{d}y$。\n验证平衡关系 $E'(t) = P_{\\text{wall}}(t) - D(t)$。\n\n要求 C（误差量化）：假设一个不正确的实现使用了壁面处的相对速度，将壁面功 $\\int_{A_w} \\boldsymbol{t}_w \\cdot \\boldsymbol{U}_w \\, \\mathrm{d}A$ 替换为 $\\int_{A_w} \\boldsymbol{t}_w \\cdot (\\boldsymbol{u} - \\boldsymbol{U}_w) \\, \\mathrm{d}A$。对于无滑移壁面，在 $A_w$ 上有 $\\boldsymbol{u} = \\boldsymbol{U}_w$，这将错误地将壁面功率置为零。通过将不正确的壁面功率代入机械能平衡方程来定义不正确的变化率 $E'_{\\text{wrong}}(t)$。计算无量纲相对误差\n$$\\varepsilon(t) = \\frac{E'_{\\text{wrong}}(t) - E'(t)}{E'(t)},$$\n和无量纲归一化预算残差\n$$R(t) = \\frac{E'(t) - \\big( P_{\\text{wall}}(t) - D(t) \\big)}{E'(t)}.$$\n\n你的程序必须实现验证案例，并为以下参数值 $(\\rho,\\mu,U,t)$ 的测试套件计算 $\\varepsilon(t)$ 和 $R(t)$：\n- 案例 1：$(1000, 0.001, 0.5, 0.1)$，\n- 案例 2：$(1000, 1.0, 0.3, 0.5)$，\n- 案例 3：$(1.225, 1.8 \\times 10^{-5}, 2.0, 10^{-4})$，\n- 案例 4：$(1.225, 1.8 \\times 10^{-5}, 2.0, 0.05)$，\n- 案例 5：$(860, 0.05, 1.2, 10)$。\n\n所有输出必须是无量纲数。你的程序应生成单行输出，包含一个逗号分隔的列表形式的结果，其中每个元素对应一个测试案例，并且本身是一个双元素列表 $[\\varepsilon(t), R(t)]$。例如，输出必须具有以下确切格式：\n$$\\big[ [\\varepsilon_1, R_1], [\\varepsilon_2, R_2], \\ldots \\big].$$",
            "solution": "该问题经评估是有效的，因为它科学地基于连续介质力学原理，是适定的、客观的且内部一致的。\n\n解答分为三部分，对应于问题的要求。\n\n### 要求 A：机械能平衡的推导\n\n我们的目标是为毗邻无滑移壁面的移动控制体 $\\mathsf{CV}$ 推导机械能平衡方程。我们从 Cauchy 动量方程开始，这是流体连续介质的牛顿第二定律的微分形式。对于密度为 $\\rho$、速度为 $\\boldsymbol{u}$、受到体积力 $\\rho \\boldsymbol{g}$ 和由 Cauchy 应力张量 $\\boldsymbol{\\sigma}$ 描述的表面力的不可压缩流体，方程为：\n$$\n\\rho \\frac{D\\boldsymbol{u}}{D t} = \\nabla \\cdot \\boldsymbol{\\sigma} + \\rho \\boldsymbol{g}\n$$\n其中 $\\frac{D}{Dt} = \\frac{\\partial}{\\partial t} + \\boldsymbol{u} \\cdot \\nabla$ 是物质导数。\n\n为了获得能量方程，我们将动量方程与流体速度 $\\boldsymbol{u}$ 进行点乘：\n$$\n\\rho \\boldsymbol{u} \\cdot \\frac{D\\boldsymbol{u}}{D t} = \\boldsymbol{u} \\cdot (\\nabla \\cdot \\boldsymbol{\\sigma}) + \\rho \\boldsymbol{u} \\cdot \\boldsymbol{g}\n$$\n左边的项可以重写为单位质量动能 $\\frac{1}{2}|\\boldsymbol{u}|^2$ 的物质导数：\n$$\n\\rho \\frac{D}{Dt} \\left( \\frac{1}{2} |\\boldsymbol{u}|^2 \\right) = \\boldsymbol{u} \\cdot (\\nabla \\cdot \\boldsymbol{\\sigma}) + \\rho \\boldsymbol{u} \\cdot \\boldsymbol{g}\n$$\n我们假设体积力是保守的，即 $\\boldsymbol{g} = -\\nabla\\Phi$，其中 $\\Phi$ 是单位质量势能。如果 $\\Phi$ 与时间无关，则 $\\rho \\boldsymbol{u} \\cdot \\boldsymbol{g} = -\\rho \\boldsymbol{u} \\cdot \\nabla\\Phi = -\\rho \\frac{D\\Phi}{Dt}$。将此项移到左侧，我们得到总机械能密度 $e_m = \\frac{1}{2}\\rho|\\boldsymbol{u}|^2 + \\rho\\Phi$ 的变化率：\n$$\n\\rho \\frac{D}{Dt} \\left( \\frac{1}{2} |\\boldsymbol{u}|^2 + \\Phi \\right) = \\frac{D e_m}{Dt} = \\boldsymbol{u} \\cdot (\\nabla \\cdot \\boldsymbol{\\sigma})\n$$\n右边的项表示单位体积内应力所做的功的速率。使用向量恒等式 $\\nabla \\cdot (\\boldsymbol{A} \\cdot \\boldsymbol{v}) = (\\nabla \\cdot \\boldsymbol{A}^{\\mathsf{T}}) \\cdot \\boldsymbol{v} + \\boldsymbol{A}^{\\mathsf{T}} : (\\nabla \\boldsymbol{v})$ 和应力张量的对称性（$\\boldsymbol{\\sigma}^{\\mathsf{T}} = \\boldsymbol{\\sigma}$），我们可以写出：\n$$\n\\boldsymbol{u} \\cdot (\\nabla \\cdot \\boldsymbol{\\sigma}) = \\nabla \\cdot (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{u}) - \\boldsymbol{\\sigma} : \\nabla\\boldsymbol{u}\n$$\n机械能密度方程变为：\n$$\n\\frac{D e_m}{Dt} = \\nabla \\cdot (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{u}) - \\boldsymbol{\\sigma} : \\nabla\\boldsymbol{u}\n$$\n项 $\\boldsymbol{\\sigma} : \\nabla\\boldsymbol{u}$ 是变形功的速率。对于牛顿流体，$\\boldsymbol{\\sigma} = -p\\boldsymbol{I} + 2\\mu\\boldsymbol{S}$。对于不可压缩流体，$\\nabla \\cdot \\boldsymbol{u} = 0$，所以功的压力部分为 $-p\\boldsymbol{I}:\\nabla\\boldsymbol{u} = -p(\\nabla \\cdot \\boldsymbol{u}) = 0$。粘性部分是 $2\\mu\\boldsymbol{S}:\\nabla\\boldsymbol{u}$。由于 $\\nabla\\boldsymbol{u} = \\boldsymbol{S} + \\boldsymbol{\\Omega}$，其中 $\\boldsymbol{S}$ 是对称的应变率张量，$\\boldsymbol{\\Omega}$ 是反对称的自旋张量，且一个对称张量和一个反对称张量的双点积为零（$\\boldsymbol{S}:\\boldsymbol{\\Omega}=0$），我们有 $2\\mu\\boldsymbol{S}:\\nabla\\boldsymbol{u} = 2\\mu\\boldsymbol{S}:\\boldsymbol{S}$。这个项，通常表示为 $\\Psi_v$，代表单位体积内机械能因粘性耗散为热量的不可逆速率。它总是非负的。\n\n展开物质导数，机械能平衡的微分形式是：\n$$\n\\frac{\\partial e_m}{\\partial t} + \\nabla \\cdot (e_m \\boldsymbol{u}) = \\nabla \\cdot (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{u}) - \\Psi_v\n$$\n现在，我们在移动控制体 $\\mathsf{CV}(t)$ 上对该方程进行积分：\n$$\n\\int_{\\mathsf{CV}} \\frac{\\partial e_m}{\\partial t} \\, \\mathrm{d}V + \\int_{\\mathsf{CV}} \\nabla \\cdot (e_m \\boldsymbol{u}) \\, \\mathrm{d}V = \\int_{\\mathsf{CV}} \\nabla \\cdot (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{u}) \\, \\mathrm{d}V - \\int_{\\mathsf{CV}} \\Psi_v \\, \\mathrm{d}V\n$$\n对通量项应用散度定理：\n$$\n\\int_{\\mathsf{CV}} \\frac{\\partial e_m}{\\partial t} \\, \\mathrm{d}V + \\int_{\\mathsf{CS}} e_m (\\boldsymbol{u} \\cdot \\boldsymbol{n}) \\, \\mathrm{d}A = \\int_{\\mathsf{CS}} (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{u}) \\cdot \\boldsymbol{n} \\, \\mathrm{d}A - \\int_{\\mathsf{CV}} \\Psi_v \\, \\mathrm{d}V\n$$\n对于标量（这里是 $e_m$）的雷诺输运定理是：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\mathsf{CV}} e_m \\, \\mathrm{d}V = \\int_{\\mathsf{CV}} \\frac{\\partial e_m}{\\partial t} \\, \\mathrm{d}V + \\int_{\\mathsf{CS}} e_m (\\boldsymbol{u}_{\\mathsf{CS}} \\cdot \\boldsymbol{n}) \\, \\mathrm{d}A\n$$\n重新整理得到：$\\int_{\\mathsf{CV}} \\frac{\\partial e_m}{\\partial t} \\, \\mathrm{d}V = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\mathsf{CV}} e_m \\, \\mathrm{d}V - \\int_{\\mathsf{CS}} e_m (\\boldsymbol{u}_{\\mathsf{CS}} \\cdot \\boldsymbol{n}) \\, \\mathrm{d}A$。将此代入我们的积分能量方程，得到：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\mathsf{CV}} e_m \\, \\mathrm{d}V + \\int_{\\mathsf{CS}} e_m (\\boldsymbol{u} - \\boldsymbol{u}_{\\mathsf{CS}}) \\cdot \\boldsymbol{n} \\, \\mathrm{d}A = \\int_{\\mathsf{CS}} (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{u}) \\cdot \\boldsymbol{n} \\, \\mathrm{d}A - \\int_{\\mathsf{CV}} \\Psi_v \\, \\mathrm{d}V\n$$\n这就是最终的积分形式的机械能平衡方程。项 $\\int_{\\mathsf{CS}} (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{u}) \\cdot \\boldsymbol{n} \\, \\mathrm{d}A$ 是表面力对控制体内流体做功的总速率。曳力向量定义为 $\\boldsymbol{t} = \\boldsymbol{\\sigma} \\cdot \\boldsymbol{n}$。所以此项为 $\\int_{\\mathsf{CS}} \\boldsymbol{t} \\cdot \\boldsymbol{u} \\, \\mathrm{d}A$。\n\n我们现在关注与壁面重合的控制面部分 $A_w$。壁面功项是这个积分在 $A_w$ 上的部分：\n$$\nP_w = \\int_{A_w} \\boldsymbol{t}_w \\cdot \\boldsymbol{u} \\, \\mathrm{d}A\n$$\n其中 $\\boldsymbol{t}_w$ 是壁面对流体施加的曳力。由于无滑移条件，壁面处的流体速度等于壁面速度：在 $A_w$ 上 $\\boldsymbol{u} = \\boldsymbol{U}_w$。将此代入积分，我们得到精确的壁面功项：\n$$\nP_w = \\int_{A_w} \\boldsymbol{t}_w \\cdot \\boldsymbol{U}_w \\, \\mathrm{d}A\n$$\n该项表示移动壁面对流体做功的速率。另一种形式 $\\int_{A_w} \\boldsymbol{t}_w \\cdot (\\boldsymbol{u} - \\boldsymbol{U}_w) \\mathrm{d}A$ 在计算功输入方面是根本错误的。功是力与作用点速度的点积，对于壁面边界，该速度是 $\\boldsymbol{U}_w$。相对速度项 $(\\boldsymbol{u} - \\boldsymbol{U}_w)$ 在无滑移壁面上恒为零，这将错误地意味着功输入为零。\n\n### 要求 B：Stokes 第一问题的验证案例\n\n我们考虑由一个位于 $y=0$ 的平板在 $x$ 方向以速度 $U$ 开始运动所产生的流动。速度场为 $\\boldsymbol{u}(y,t) = u(y,t)\\boldsymbol{i}$，其中\n$$\nu(y,t) = U \\operatorname{erfc}\\left(\\frac{y}{2\\sqrt{\\nu t}}\\right)\n$$\n我们计算单位壁面面积所需的量。控制体包含单位面积内的整个流体域，因此积分范围是从 $y=0$ 到 $\\infty$。\n\n1.  **壁面功率输入 $P_{\\text{wall}}(t)$：**\n    $P_{\\text{wall}}(t) = \\boldsymbol{t}_w \\cdot \\boldsymbol{U}_w$。壁面速度为 $\\boldsymbol{U}_w = U\\boldsymbol{i}$。在壁面处从流体指出的外法向量是 $\\boldsymbol{n} = -\\boldsymbol{j}$。对流体施加的曳力是 $\\boldsymbol{t}_w = \\boldsymbol{\\sigma}|_{y=0} \\cdot \\boldsymbol{n}$。唯一的非零应力剪切分量是 $\\sigma_{yx} = \\mu \\frac{\\partial u}{\\partial y}$。曳力向量是 $\\boldsymbol{t}_w = -\\sigma_{yx}|_{y=0} \\boldsymbol{i} = -\\mu \\left(\\frac{\\partial u}{\\partial y}\\right)_{y=0} \\boldsymbol{i}$。\n    我们计算速度梯度：\n    $$\n    \\frac{\\partial u}{\\partial y} = U \\frac{\\mathrm{d}}{\\mathrm{d}y}\\left(\\frac{2}{\\sqrt{\\pi}}\\int_{y/(2\\sqrt{\\nu t})}^\\infty e^{-\\xi^2} d\\xi \\right) = U \\left(-\\frac{2}{\\sqrt{\\pi}} e^{-y^2/(4\\nu t)}\\right) \\frac{1}{2\\sqrt{\\nu t}} = -\\frac{U}{\\sqrt{\\pi \\nu t}} e^{-y^2/(4\\nu t)}\n    $$\n    在壁面（$y=0$）处：$\\left(\\frac{\\partial u}{\\partial y}\\right)_{y=0} = -\\frac{U}{\\sqrt{\\pi \\nu t}}$。\n    单位面积的功率输入是：\n    $$\n    P_{\\text{wall}}(t) = \\left(-\\mu \\left(-\\frac{U}{\\sqrt{\\pi \\nu t}}\\right) \\boldsymbol{i}\\right) \\cdot (U\\boldsymbol{i}) = \\frac{\\mu U^2}{\\sqrt{\\pi \\nu t}}\n    $$\n\n2.  **粘性耗散率 $D(t)$：**\n    $D(t) = \\mu \\int_0^\\infty \\left( \\frac{\\partial u}{\\partial y} \\right)^2 \\mathrm{d}y$。\n    $$\n    D(t) = \\mu \\int_0^\\infty \\left(-\\frac{U}{\\sqrt{\\pi \\nu t}} e^{-y^2/(4\\nu t)}\\right)^2 \\mathrm{d}y = \\frac{\\mu U^2}{\\pi \\nu t} \\int_0^\\infty e^{-y^2/(2\\nu t)} \\mathrm{d}y\n    $$\n    这是一个标准的高斯积分，$\\int_0^\\infty e^{-ay^2} \\mathrm{d}y = \\frac{1}{2}\\sqrt{\\frac{\\pi}{a}}$。当 $a = 1/(2\\nu t)$ 时，该积分为 $\\frac{1}{2}\\sqrt{2\\pi\\nu t}$。\n    $$\n    D(t) = \\frac{\\mu U^2}{\\pi \\nu t} \\left(\\frac{\\sqrt{2\\pi\\nu t}}{2}\\right) = \\frac{\\mu U^2}{\\sqrt{2\\pi \\nu t}}\n    $$\n\n3.  **机械能变化率 $E'(t)$：**\n    $E'(t) = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_0^\\infty \\frac{1}{2} \\rho u(y,t)^2 \\mathrm{d}y$。首先，我们计算总动能 $E(t)$：\n    $$\n    E(t) = \\frac{1}{2}\\rho U^2 \\int_0^\\infty \\left[\\operatorname{erfc}\\left(\\frac{y}{2\\sqrt{\\nu t}}\\right)\\right]^2 \\mathrm{d}y\n    $$\n    令 $z = y/(2\\sqrt{\\nu t})$，则 $\\mathrm{d}y = 2\\sqrt{\\nu t} \\, \\mathrm{d}z$。\n    $$\n    E(t) = \\frac{1}{2}\\rho U^2 (2\\sqrt{\\nu t}) \\int_0^\\infty [\\operatorname{erfc}(z)]^2 \\mathrm{d}z = \\rho U^2 \\sqrt{\\nu t} \\int_0^\\infty [\\operatorname{erfc}(z)]^2 \\mathrm{d}z\n    $$\n    该定积分为一个已知常数：$\\int_0^\\infty [\\operatorname{erfc}(z)]^2 \\mathrm{d}z = \\frac{2-\\sqrt{2}}{\\sqrt{\\pi}}$。\n    $$\n    E(t) = \\rho U^2 \\sqrt{\\nu t} \\left(\\frac{2-\\sqrt{2}}{\\sqrt{\\pi}}\\right)\n    $$\n    现在，对时间 $t$ 求导：\n    $$\n    E'(t) = \\frac{\\mathrm{d}E}{\\mathrm{d}t} = \\rho U^2 \\left(\\frac{2-\\sqrt{2}}{\\sqrt{\\pi}}\\right) \\sqrt{\\nu} \\cdot \\frac{1}{2\\sqrt{t}} = \\frac{\\rho U^2(2-\\sqrt{2})}{2\\sqrt{\\pi}}\\sqrt{\\frac{\\nu}{t}}\n    $$\n    验证：我们检查是否 $E'(t) = P_{\\text{wall}}(t) - D(t)$。使用 $\\mu = \\rho\\nu$：\n    $$\n    P_{\\text{wall}}(t) - D(t) = \\frac{\\rho\\nu U^2}{\\sqrt{\\pi\\nu t}} - \\frac{\\rho\\nu U^2}{\\sqrt{2\\pi\\nu t}} = \\rho U^2 \\sqrt{\\frac{\\nu}{\\pi t}} \\left(1-\\frac{1}{\\sqrt{2}}\\right) = \\rho U^2 \\sqrt{\\frac{\\nu}{t}} \\frac{\\sqrt{2}-1}{\\sqrt{2\\pi}}\n    $$\n    分子和分母同乘以 $\\sqrt{2}$：\n    $$\n    P_{\\text{wall}}(t) - D(t) = \\rho U^2 \\sqrt{\\frac{\\nu}{t}} \\frac{2-\\sqrt{2}}{2\\sqrt{\\pi}}\n    $$\n    这个表达式与我们对 $E'(t)$ 的结果完全相同。能量平衡得到验证。\n\n### 要求 C：误差量化\n\n不正确的实现使用壁面功率 $P'_{\\text{wall}} = \\int_{A_w} \\boldsymbol{t}_w \\cdot (\\boldsymbol{u} - \\boldsymbol{U}_w) \\, \\mathrm{d}A$。对于无滑移壁面，在 $A_w$ 上有 $\\boldsymbol{u} = \\boldsymbol{U}_w$，因此 $P'_{\\text{wall}}=0$。\n不正确的能量变化率是 $E'_{\\text{wrong}}(t) = P'_{\\text{wall}}(t) - D(t) = -D(t)$。\n\n1.  **无量纲相对误差 $\\varepsilon(t)$：**\n    $$\n    \\varepsilon(t) = \\frac{E'_{\\text{wrong}}(t) - E'(t)}{E'(t)} = \\frac{-D(t) - (P_{\\text{wall}}(t) - D(t))}{P_{\\text{wall}}(t) - D(t)} = \\frac{-P_{\\text{wall}}(t)}{P_{\\text{wall}}(t) - D(t)}\n    $$\n    我们代入 $P_{\\text{wall}}(t)$ 和 $D(t)$ 的表达式：\n    $$\n    \\varepsilon(t) = \\frac{-\\frac{\\mu U^2}{\\sqrt{\\pi \\nu t}}}{\\frac{\\mu U^2}{\\sqrt{\\pi \\nu t}} - \\frac{\\mu U^2}{\\sqrt{2\\pi \\nu t}}} = \\frac{-1}{1 - 1/\\sqrt{2}} = \\frac{-\\sqrt{2}}{\\sqrt{2}-1}\n    $$\n    对分母进行有理化处理得到：\n    $$\n    \\varepsilon(t) = \\frac{-\\sqrt{2}(\\sqrt{2}+1)}{(\\sqrt{2}-1)(\\sqrt{2}+1)} = -(2+\\sqrt{2})\n    $$\n    这是一个常数，与所有问题参数 $(\\rho, \\mu, U, t)$ 无关。\n\n2.  **无量纲归一化预算残差 $R(t)$：**\n    $$\n    R(t) = \\frac{E'(t) - \\big( P_{\\text{wall}}(t) - D(t) \\big)}{E'(t)}\n    $$\n    正如在 B 部分所验证的，对于精确解，分子恒为零，因为 $E'(t) = P_{\\text{wall}}(t) - D(t)$。只要 $E'(t) \\neq 0$（对于任何有限的 $t>0$ 都成立），残差就是：\n    $$\n    R(t) = 0\n    $$\n    这也是一个常数，与所有问题参数无关。\n\n下面的程序将为每个测试案例计算这些常数值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes error metrics for an energy balance calculation in a fluid mechanics problem.\n\n    The problem analyzes the mechanical energy balance for Stokes' first problem.\n    It's shown analytically that the dimensionless relative error (epsilon) and\n    the normalized budget residual (R) are constants, independent of the physical\n    parameters of the specific test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1000, 0.001, 0.5, 0.1),\n        (1000, 1.0, 0.3, 0.5),\n        (1.225, 1.8e-5, 2.0, 1e-4),\n        (1.225, 1.8e-5, 2.0, 0.05),\n        (860, 0.05, 1.2, 10),\n    ]\n\n    # As derived in the solution, the dimensionless relative error epsilon\n    # is a constant value. The derivation is as follows:\n    # epsilon = -P_wall / (P_wall - D)\n    # The ratio of dissipation to wall power is D/P_wall = 1/sqrt(2).\n    # So, epsilon = -1 / (1 - 1/sqrt(2))\n    # Simplifying this expression gives epsilon = -(2 + sqrt(2)).\n    epsilon = -(2.0 + np.sqrt(2.0))\n\n    # The normalized budget residual R(t) is defined as:\n    # R(t) = (E'(t) - (P_wall(t) - D(t))) / E'(t)\n    # The analytical solution demonstrated that the energy balance\n    # E'(t) = P_wall(t) - D(t) holds exactly.\n    # Therefore, the numerator is zero, and R(t) = 0 for all t > 0.\n    residual = 0.0\n\n    results = []\n    # The loop is maintained to match the specified output format,\n    # even though the results are identical for all test cases.\n    for _ in test_cases:\n        results.append([epsilon, residual])\n\n    # Format the final output string as a comma-separated list of two-element lists,\n    # matching the format [[e1, R1], [e2, R2], ...].\n    result_str = \",\".join([f\"[{e},{r}]\" for e, r in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "雷诺输运定理不仅是一个理论工具，它对于解释真实世界的数据也至关重要。此实践练习  模拟了一个物理海洋学中的场景，其中拉格朗日浮子定义了一个移动且变形的控制体。您将使用守恒定律的积分形式来开发一种算法，从稀疏的点测量中推断出如表面散度和示踪剂源项等大尺度特性，从而展示雷诺输运定理如何连接离散观测和连续场属性。",
            "id": "3358328",
            "problem": "给定一组漂移点观测数据，这些点在每个时刻构成一个在水平二维流体域中的简单多边形移动控制体。这些点是理想的中性浮力拉格朗日漂流浮标，因此每个点都随着当地的水平速度移动。每个漂流浮标在其瞬时位置对一个标量示踪剂场进行采样。你的任务是，使用适用于移动控制体的雷诺输运定理，从第一性原理出发，推导如何从稀疏的拉格朗日数据中推断出面积平均的表面辐散和示踪剂的面积平均源率，然后实现一个数值算法，根据两个连续快照来估计这些量。\n\n你可以使用的基本出发点：\n- 对于一个随速度场 $\\boldsymbol{u}(\\boldsymbol{x},t)$ 移动的物质区域，其几何面积的守恒，以及辐散 $\\nabla \\cdot \\boldsymbol{u}$ 的定义。\n- 对于单位面积示踪剂密度 $c(\\boldsymbol{x},t)$，其被速度场 $\\boldsymbol{u}$ 输运并带有一个源项 $\\sigma(\\boldsymbol{x},t)$ 时的标量守恒，不得使用任何简便公式。\n- 在二维空间中成立的基本向量微积分定理。\n\n你必须：\n- 仅基于上述基本原理，推导将控制体面积的时间变化率与控制区域上 $\\nabla \\cdot \\boldsymbol{u}$ 的空间平均值联系起来的表达式，以及将面积积分示踪剂量的时间变化率与面积平均源率联系起来的表达式。\n- 设计一个离散算法，该算法仅使用两个时刻 $t_0$ 和 $t_1=t_0+\\Delta t$ 的漂流浮标位置及其示踪剂测量值来估计：\n  - 中间时刻 $t_{1/2}=t_0+\\Delta t/2$ 的面积平均辐散 $\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle$，单位为 $\\mathrm{s}^{-1}$，\n  - 中间时刻 $t_{1/2}$ 的面积平均源率 $\\overline{\\sigma}$，单位为示踪剂单位/秒。\n- 你的算法必须使用鞋带公式近似多边形面积，通过多边形的三角剖分（扇形三角剖分）近似面积平均示踪剂量，并用在 $\\Delta t$ 上的有限差分来近似时间导数。所有漂流浮标数据都是稀疏的，并且只在顶点上给出；没有内部信息可用。\n\n数值测试套件：\n对于每个测试，漂流浮标在 $t_0$ 时刻被初始化，形成一个简单的凸多边形，其顶点坐标以米为单位，按逆时针顺序列出。速度场和示踪剂演化是科学上可信且自洽的。对于每个测试，从指定的场生成 $t_1$ 时刻的漂流浮标位置及其在 $t_0$ 和 $t_1$ 时刻的示踪剂值，然后应用你的算法来估计 $t_{1/2}$ 时刻的面积平均辐散和面积平均源。角度（如果使用）以弧度为单位。\n\n- 测试 A（均匀面积扩张，无源物质示踪剂）：\n  - 参数：$\\lambda = 2\\times 10^{-5}\\ \\mathrm{s}^{-1}$，$\\Delta t = 10000\\ \\mathrm{s}$。\n  - 速度：$\\boldsymbol{u}(x,y,t) = \\left(\\frac{\\lambda}{2} x,\\ \\frac{\\lambda}{2} y\\right)$。\n  - 漂流浮标运动：$\\Delta t$ 后的精确值为 $(x_1,y_1) = \\left(x_0 e^{\\lambda \\Delta t/2},\\ y_0 e^{\\lambda \\Delta t/2}\\right)$。\n  - 示踪剂动力学：无源物质，因此沿着轨迹 $c$ 满足 $\\mathrm{d}c/\\mathrm{d}t + c\\,\\nabla \\cdot \\boldsymbol{u} = 0$。对于均匀的初始值 $c_0=5$（任意单位），在每个漂流浮标处，$t_1$ 时刻的精确示踪剂值为 $c_1 = c_0 e^{-\\lambda \\Delta t}$。\n  - $t_0$ 时刻的初始多边形顶点（米）：$(0,0)$, $(1000,0)$, $(1000,500)$, $(0,500)$。\n\n- 测试 B（不可压缩剪切，均匀示踪剂源）：\n  - 参数：$S = 10^{-4}\\ \\mathrm{s}^{-1}$，$\\Delta t = 5000\\ \\mathrm{s}$，均匀源 $\\sigma_0=10^{-2}$（任意示踪剂单位/秒）。\n  - 速度：$\\boldsymbol{u}(x,y,t) = (S y,\\ 0)$。\n  - 漂流浮标运动：$\\Delta t$ 后的精确值为 $(x_1,y_1) = (x_0 + S y_0 \\Delta t,\\ y_0)$。\n  - 示踪剂动力学：$\\partial_t c + \\nabla \\cdot (c \\boldsymbol{u}) = \\sigma_0$，初始 $c_0=1$ 均匀。在每个漂流浮标处的精确示踪剂值为 $c_1 = c_0 + \\sigma_0 \\Delta t$。\n  - $t_0$ 时刻的初始多边形顶点（米）：$(0,0)$, $(1000,0)$, $(1500,500)$, $(500,500)$。\n\n- 测试 C（刚体旋转，轴对称示踪剂，无源）：\n  - 参数：$\\Omega = 10^{-4}\\ \\mathrm{s}^{-1}$，$\\Delta t = 2000\\ \\mathrm{s}$。\n  - 速度：$\\boldsymbol{u}(x,y,t) = (-\\Omega y,\\ \\Omega x)$。\n  - 漂流浮标运动：$\\Delta t$ 后的精确值为 $(x_1,y_1) = (x_0 \\cos(\\Omega \\Delta t) - y_0 \\sin(\\Omega \\Delta t),\\ x_0 \\sin(\\Omega \\Delta t) + y_0 \\cos(\\Omega \\Delta t))$。\n  - 示踪剂：$c(x,y,t) = c_0 + \\alpha (x^2+y^2)$，其中 $c_0=2$ 且 $\\alpha=10^{-5}$（任意单位/$\\mathrm{m}^2$）。在刚体旋转且无源的情况下，该示踪剂是稳定的且物质守恒，因此每个漂流浮标的示踪剂值保持不变。\n  - $t_0$ 时刻的初始多边形顶点（米）：$(1000,0)$, $(1500,500)$, $(1000,1000)$, $(500,500)$。\n\n实现要求：\n- 使用鞋带公式计算 $t_0$ 和 $t_1$ 时的多边形面积。使用面积的绝对值，单位为 $\\mathrm{m}^2$。\n- 通过从第一个顶点扇形展开，将多边形三角剖分成不重叠的三角形，来计算 $t_0$ 和 $t_1$ 时的面积平均示踪剂量 $\\bar{c}$，假设 $c$ 在每个三角形上线性变化，且三角形内的平均值等于其顶点值的平均值。\n- 通过将面积变化率的有限差分除以中点面积，来估计 $t_{1/2}$ 时的面积平均辐散（单位 $\\mathrm{s}^{-1}$）。通过将面积平均示踪剂变化率的有限差分与中点面积平均示踪剂和估计的面积平均辐散的乘积相结合，来估计 $t_{1/2}$ 时的面积平均源（单位 示踪剂单位/秒）。\n- 单位：位置以米为单位，时间以秒为单位，辐散以 $\\mathrm{s}^{-1}$ 为单位，源以示踪剂单位/秒为单位。将最终的数值输出表示为浮点数。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个以逗号分隔的 Python 风格的列表的列表：每个内部列表对应一个测试（按 A、B、C 的顺序），每个内部列表包含两个数字，顺序为 [$\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle$, $\\overline{\\sigma}$]。例如，一个语法上有效的输出看起来像 “[[0.0,0.0],[0.0,0.0],[0.0,0.0]]”，但应使用你计算出的数字。",
            "solution": "任务是推导并实现一种方法，用于从定义移动多边形控制体的拉格朗日漂流浮标数据中，估计面积平均辐散 $\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle$ 和面积平均示踪剂源率 $\\overline{\\sigma}$。推导从连续介质力学和向量微积分的基本原理开始。\n\n### 1. 理论推导\n\n分析的基础是应用于二维移动控制区域的雷诺输运定理 (RTT)。该控制体由一组拉格朗日漂流浮标定义，这意味着其边界随当地流体速度移动。这样的体积被称为物质体积。\n\n#### 1.1 物质区域的雷诺输运定理\n设 $A_c(t)$ 是一个随流体速度场 $\\boldsymbol{u}(\\boldsymbol{x}, t)$ 移动的物质控制区域，并设 $S_c(t)$ 为其边界。对于任何内含性质 $f(\\boldsymbol{x}, t)$，$A_c(t)$ 内 $f$ 总量的时间变化率由 RTT 的积分形式给出。对于物质体积，其边界随流体速度 $\\boldsymbol{u}$ 移动，RTT 简化为：\n$$\n\\frac{d}{dt} \\int_{A_c(t)} f \\, dA = \\int_{A_c(t)} \\left( \\frac{\\partial f}{\\partial t} + \\nabla \\cdot (f \\boldsymbol{u}) \\right) \\, dA\n$$\n\n#### 1.2 面积平均辐散\n为了将控制体面积的变化率与流体辐散联系起来，我们将 RTT 应用于内含性质设为单位 1 的情况，即 $f=1$。在区域 $A_c(t)$ 上对 $f=1$ 的积分就是该区域本身，$A_c$。\n$$\n\\frac{d A_c}{dt} = \\frac{d}{dt} \\int_{A_c(t)} 1 \\, dA\n$$\n将 $f=1$ 代入物质区域的 RTT：\n$$\n\\frac{d A_c}{dt} = \\int_{A_c(t)} \\left( \\frac{\\partial 1}{\\partial t} + \\nabla \\cdot (1 \\cdot \\boldsymbol{u}) \\right) \\, dA = \\int_{A_c(t)} (\\nabla \\cdot \\boldsymbol{u}) \\, dA\n$$\n控制区域上的辐散的空间平均值，记为 $\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle$，定义为：\n$$\n\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle = \\frac{1}{A_c} \\int_{A_c(t)} (\\nabla \\cdot \\boldsymbol{u}) \\, dA\n$$\n通过结合前两个方程，我们得到了所需的关系：\n$$\n\\frac{d A_c}{dt} = A_c \\langle \\nabla \\cdot \\boldsymbol{u} \\rangle\n$$\n或者，表示为面积平均辐散：\n$$\n\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle = \\frac{1}{A_c} \\frac{d A_c}{dt} = \\frac{d (\\ln A_c)}{dt}\n$$\n这个结果表明，物质区域的面积分数变化率等于速度场的面积平均辐散。\n\n#### 1.3 面积平均示踪剂源率\n对于单位面积的标量示踪剂浓度 $c(\\boldsymbol{x}, t)$，其受速度 $\\boldsymbol{u}$ 输运和源项 $\\sigma(\\boldsymbol{x}, t)$ 影响的守恒定律为：\n$$\n\\frac{\\partial c}{\\partial t} + \\nabla \\cdot (c \\boldsymbol{u}) = \\sigma\n$$\n我们将此守恒方程在物质控制区域 $A_c(t)$ 上积分：\n$$\n\\int_{A_c(t)} \\left( \\frac{\\partial c}{\\partial t} + \\nabla \\cdot (c \\boldsymbol{u}) \\right) \\, dA = \\int_{A_c(t)} \\sigma \\, dA\n$$\n根据物质区域的 RTT（其中 $f=c$），左侧恰好是积分量的全时间导数：\n$$\n\\frac{d}{dt} \\int_{A_c(t)} c \\, dA = \\int_{A_c(t)} \\left( \\frac{\\partial c}{\\partial t} + \\nabla \\cdot (c \\boldsymbol{u}) \\right) \\, dA\n$$\n因此，我们得到一个简单而有力的结果：物质体积中示踪剂总量的变化率等于该体积内的总源量：\n$$\n\\frac{d}{dt} \\int_{A_c(t)} c \\, dA = \\int_{A_c(t)} \\sigma \\, dA\n$$\n我们定义面积平均示踪剂浓度 $\\bar{c} = \\frac{1}{A_c} \\int_{A_c(t)} c \\, dA$ 和面积平均源率 $\\overline{\\sigma} = \\frac{1}{A_c} \\int_{A_c(t)} \\sigma \\, dA$。上述方程可以重写为：\n$$\n\\frac{d (A_c \\bar{c})}{dt} = A_c \\overline{\\sigma}\n$$\n对左侧应用乘法法则求导，得到：\n$$\n\\bar{c} \\frac{d A_c}{dt} + A_c \\frac{d \\bar{c}}{dt} = A_c \\overline{\\sigma}\n$$\n除以面积 $A_c$（假设 $A_c > 0$）：\n$$\n\\bar{c} \\left( \\frac{1}{A_c} \\frac{d A_c}{dt} \\right) + \\frac{d \\bar{c}}{dt} = \\overline{\\sigma}\n$$\n最后，代入面积平均辐散的表达式 $\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle = \\frac{1}{A_c} \\frac{d A_c}{dt}$：\n$$\n\\overline{\\sigma} = \\frac{d \\bar{c}}{dt} + \\bar{c} \\langle \\nabla \\cdot \\boldsymbol{u} \\rangle\n$$\n这就是所需的关系，它将面积平均源率与面积平均示踪剂的变化率以及面积平均辐散的稀释/浓缩效应联系起来。\n\n### 2. 数值算法设计\n\n必须将连续关系离散化，以便应用于两个离散时间点 $t_0$ 和 $t_1=t_0+\\Delta t$ 的观测。我们使用在中间时刻 $t_{1/2} = t_0 + \\Delta t/2$ 计算的二阶精度中心有限差分格式。\n\n#### 2.1 辐散估计器\n公式 $\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle = \\frac{1}{A_c} \\frac{dA_c}{dt}$ 的离散化如下：\n在 $t_{1/2}$ 处的时间导数 $\\frac{dA_c}{dt}$ 用中心差分近似：\n$$ \\left. \\frac{d A_c}{dt} \\right|_{t_{1/2}} \\approx \\frac{A_c(t_1) - A_c(t_0)}{\\Delta t} $$\n在 $t_{1/2}$ 处的面积 $A_c$ 用平均值近似：\n$$ A_c(t_{1/2}) \\approx \\frac{A_c(t_0) + A_c(t_1)}{2} $$\n结合这些，在 $t_{1/2}$ 处面积平均辐散的估计值为：\n$$\n\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle_{1/2} \\approx \\frac{(A_1 - A_0) / \\Delta t}{(A_0 + A_1) / 2} = \\frac{2}{\\Delta t} \\frac{A_1 - A_0}{A_1 + A_0}\n$$\n其中 $A_0 = A_c(t_0)$ 且 $A_1 = A_c(t_1)$。\n\n#### 2.2 源率估计器\n公式 $\\overline{\\sigma} = \\frac{d\\bar{c}}{dt} + \\bar{c} \\langle \\nabla \\cdot \\boldsymbol{u} \\rangle$ 同样在 $t_{1/2}$ 处进行离散化：\n平均示踪剂的时间导数近似为：\n$$ \\left. \\frac{d \\bar{c}}{dt} \\right|_{t_{1/2}} \\approx \\frac{\\bar{c}_1 - \\bar{c}_0}{\\Delta t} $$\n中点处的平均示踪剂用平均值近似：\n$$ \\bar{c}(t_{1/2}) \\approx \\frac{\\bar{c}_0 + \\bar{c}_1}{2} $$\n面积平均辐散取自上一步的估计值 $\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle_{1/2}$。结合这些，得到面积平均源率的估计器：\n$$\n\\overline{\\sigma}_{1/2} \\approx \\frac{\\bar{c}_1 - \\bar{c}_0}{\\Delta t} + \\left( \\frac{\\bar{c}_0 + \\bar{c}_1}{2} \\right) \\langle \\nabla \\cdot \\boldsymbol{u} \\rangle_{1/2}\n$$\n其中 $\\bar{c}_0 = \\bar{c}(t_0)$ 且 $\\bar{c}_1 = \\bar{c}(t_1)$。\n\n#### 2.3 几何与示踪剂计算\n离散估计器需要面积（$A_0, A_1$）和平均示踪剂浓度（$\\bar{c}_0, \\bar{c}_1$）的值。\n- **多边形面积：** 由 $N$ 个顶点 $(x_1, y_1), \\dots, (x_N, y_N)$ 定义的多边形面积使用鞋带公式计算：\n$$ A = \\frac{1}{2} \\left| \\sum_{i=1}^{N} (x_i y_{i+1} - x_{i+1} y_i) \\right| $$\n其中 $(x_{N+1}, y_{N+1}) = (x_1, y_1)$。此公式应用于 $t_0$ 和 $t_1$ 时的顶点坐标。\n\n- **面积平均示踪剂：** 面积平均示踪剂 $\\bar{c}$ 通过对多边形进行三角剖分和平均来计算。从第一个顶点 $P_1$ 进行的扇形三角剖分将 $N$ 个顶点的多边形划分为 $N-2$ 个三角形 $T_j = (P_1, P_{j+1}, P_{j+2})$，其中 $j=1, \\dots, N-2$。\n每个三角形 $T_j$ 上的平均示踪剂值，其顶点示踪剂值为 $c_a, c_b, c_d$，近似为顶点值的平均值：$\\bar{c}_{T_j} = (c_a+c_b+c_d)/3$。计算每个三角形的面积 $A_{T_j}$。\n多边形内的示踪剂总量是每个三角形中示踪剂量的总和，$C = \\sum_{j=1}^{N-2} \\bar{c}_{T_j} A_{T_j}$。\n面积平均示踪剂则是总量除以总面积：\n$$ \\bar{c} = \\frac{C}{A} = \\frac{\\sum_{j=1}^{N-2} \\bar{c}_{T_j} A_{T_j}}{\\sum_{j=1}^{N-2} A_{T_j}} $$\n此过程应用于 $t_0$ 和 $t_1$ 时的数据以获得 $\\bar{c}_0$ 和 $\\bar{c}_1$。\n对于测试中指定的凸多边形，$\\sum_{j} A_{T_j}$ 等于通过鞋带公式计算的总面积 $A$。\n\n这些步骤构成了一个完整的算法，用于处理稀疏的拉格朗日数据并估计所需的物理量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef shoelace_area(vertices: np.ndarray) -> float:\n    \"\"\"\n    Calculates the area of a polygon using the shoelace formula.\n    The input vertices are assumed to be in counterclockwise or clockwise order.\n\n    Args:\n        vertices: A NumPy array of shape (N, 2) where N is the number of vertices.\n\n    Returns:\n        The area of the polygon.\n    \"\"\"\n    x = vertices[:, 0]\n    y = vertices[:, 1]\n    # The formula is 0.5 * |(x1y2 + x2y3 + ... + xNy1) - (y1x2 + y2x3 + ... + yNx1)|\n    # which can be vectorized using np.roll.\n    area = 0.5 * np.abs(np.dot(x, np.roll(y, -1)) - np.dot(y, np.roll(x, -1)))\n    return area\n\ndef area_mean_tracer(vertices: np.ndarray, tracer_values: np.ndarray) -> float:\n    \"\"\"\n    Calculates the area-mean tracer concentration for a polygon.\n    The calculation is based on a fan triangulation from the first vertex.\n    The mean tracer in each triangle is the average of its vertex values.\n\n    Args:\n        vertices: A NumPy array of shape (N, 2) for polygon vertices.\n        tracer_values: A NumPy array of shape (N,) with tracer values at each vertex.\n\n    Returns:\n        The area-weighted mean tracer concentration.\n    \"\"\"\n    num_vertices = len(vertices)\n    if num_vertices < 3:\n        # Not a valid polygon for triangulation\n        return np.mean(tracer_values) if len(tracer_values) > 0 else 0.0\n\n    total_tracer_amount = 0.0\n    total_area = 0.0\n\n    # The fan triangulation originates from the first vertex (p1).\n    p1 = vertices[0]\n    c1 = tracer_values[0]\n\n    # Iterate through the vertices to form triangles (p1, p_i, p_{i+1})\n    for i in range(1, num_vertices - 1):\n        p2 = vertices[i]\n        c2 = tracer_values[i]\n        p3 = vertices[i+1]\n        c3 = tracer_values[i+1]\n\n        # Area of triangle (p1, p2, p3) using the determinant formula\n        # 0.5 * |(x1(y2-y3) + x2(y3-y1) + x3(y1-y2))|\n        area_tri = 0.5 * abs(p1[0]*(p2[1] - p3[1]) + p2[0]*(p3[1] - p1[1]) + p3[0]*(p1[1] - p2[1]))\n\n        # Mean tracer in the triangle is the average of vertex values\n        mean_c_tri = (c1 + c2 + c3) / 3.0\n\n        total_tracer_amount += mean_c_tri * area_tri\n        total_area += area_tri\n    \n    if total_area == 0:\n        # Fallback for degenerate polygons, though not expected in tests.\n        return np.mean(tracer_values)\n\n    return total_tracer_amount / total_area\n\ndef estimate_divergence_and_source(v0, c0, v1, c1, dt):\n    \"\"\"\n    Estimates area-mean divergence and source rate from two snapshots.\n\n    Args:\n        v0: Vertices at time t0.\n        c0: Tracer values at time t0.\n        v1: Vertices at time t1.\n        c1: Tracer values at time t1.\n        dt: Time step (t1 - t0).\n\n    Returns:\n        A tuple containing the estimated mean divergence and mean source rate.\n    \"\"\"\n    # Step 1: Compute areas at t0 and t1\n    A0 = shoelace_area(v0)\n    A1 = shoelace_area(v1)\n\n    # Step 2: Estimate area-mean divergence at t_{1/2}\n    # Using the centered finite difference approximation of d(ln A)/dt\n    if (A0 + A1) == 0:\n        mean_div = 0.0\n    else:\n        mean_div = (2.0 / dt) * (A1 - A0) / (A0 + A1)\n\n    # Step 3: Compute area-mean tracer at t0 and t1\n    c_bar_0 = area_mean_tracer(v0, c0)\n    c_bar_1 = area_mean_tracer(v1, c1)\n\n    # Step 4: Estimate area-mean source rate at t_{1/2}\n    dc_bar_dt = (c_bar_1 - c_bar_0) / dt\n    c_bar_mid = (c_bar_0 + c_bar_1) / 2.0\n    mean_sigma = dc_bar_dt + c_bar_mid * mean_div\n    \n    return mean_div, mean_sigma\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            'name': 'A',\n            'params': {'lambda': 2e-5, 'dt': 10000.0, 'c0_val': 5.0},\n            'v0': np.array([[0.0, 0.0], [1000.0, 0.0], [1000.0, 500.0], [0.0, 500.0]]),\n        },\n        {\n            'name': 'B',\n            'params': {'S': 1e-4, 'dt': 5000.0, 'sigma0': 1e-2, 'c0_val': 1.0},\n            'v0': np.array([[0.0, 0.0], [1000.0, 0.0], [1500.0, 500.0], [500.0, 500.0]]),\n        },\n        {\n            'name': 'C',\n            'params': {'Omega': 1e-4, 'dt': 2000.0, 'c0_base': 2.0, 'alpha': 1e-5},\n            'v0': np.array([[1000.0, 0.0], [1500.0, 500.0], [1000.0, 1000.0], [500.0, 500.0]]),\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        v0 = case['v0']\n        params = case['params']\n        dt = params['dt']\n\n        if case['name'] == 'A':\n            lam = params['lambda']\n            c0 = np.full(len(v0), params['c0_val'])\n            \n            # Evolve drifters and tracer to t1\n            v1 = v0 * np.exp(lam * dt / 2.0)\n            c1 = c0 * np.exp(-lam * dt)\n\n        elif case['name'] == 'B':\n            S = params['S']\n            c0 = np.full(len(v0), params['c0_val'])\n            \n            # Evolve drifters and tracer to t1\n            v1 = v0.copy()\n            v1[:, 0] = v0[:, 0] + S * v0[:, 1] * dt\n            c1 = np.full(len(v1), params['c0_val'] + params['sigma0'] * dt)\n\n        elif case['name'] == 'C':\n            Omega = params['Omega']\n            c0 = params['c0_base'] + params['alpha'] * (v0[:, 0]**2 + v0[:, 1]**2)\n\n            # Evolve drifters and tracer to t1\n            x0, y0 = v0[:, 0], v0[:, 1]\n            cos_dt = np.cos(Omega * dt)\n            sin_dt = np.sin(Omega * dt)\n            v1 = np.array([x0 * cos_dt - y0 * sin_dt, x0 * sin_dt + y0 * cos_dt]).T\n            # Tracer is materially conserved, so each drifter keeps its initial value\n            c1 = c0.copy()\n\n        # Apply the estimation algorithm\n        mean_div, mean_sigma = estimate_divergence_and_source(v0, c0, v1, c1, dt)\n        results.append([mean_div, mean_sigma])\n    \n    # Print the formatted output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在现代计算流体动力学中，确保在移动和变形网格上的守恒性至关重要。这个高级实践练习  介绍了基于离散雷诺输运定理残差的“后验”误差估计器的概念。通过为随机采样的控制体计算此残差，您可以量化数值守恒误差，并发现任意拉格朗日-欧拉（ALE）框架中网格速度的最优选择如何能够最小化此误差，从而将该定理与模拟的准确性和鲁棒性直接联系起来。",
            "id": "3358284",
            "problem": "考虑一个长度为 $L$ 的一维周期性域，其坐标为 $x \\in [0,L]$，无量纲时间为 $t \\in \\mathbb{R}_{\\ge 0}$。一个光滑的人造流由一个恒定速度场 $u(x,t) = u$（其中 $u > 0$）和一个由行波剖面给出的密度场 $\\rho(x,t)$ 定义。该域、场和参数均为无量纲。目标是通过计算在随机采样的移动控制体上的雷诺输运定理 (RTT) 的离散残差，来构建一个守恒误差的后验估计器，并利用该估计器自适应地调整时间步长和网格运动，以最小化质量和动量的全局漂移。\n\n从基本平衡律和雷诺输运定理 (RTT) 出发，必须使用以下物理和数学基础：\n- 无外部源项的一维空间中的微分形式的质量守恒和微分形式的动量守恒。\n- 移动控制体的定义，其边界以指定的网格速度移动。\n- 雷诺输运定理，它将移动控制体上积分的变化率表示为一个体积项和一个与物质和控制体边界之间的相对速度成正比的通量项。\n\n您的程序必须实现以下设置和任务：\n- 域和场：\n  - 设域长度为 $L = 1$。\n  - 设恒定流速为 $u = 0.7$。\n  - 设密度场为 $\\rho(x,t) = 1 + A \\sin\\!\\big(2\\pi (x - u t)\\big)$，振幅 $A = 0.2$。\n  - 设动量密度为 $m(x,t) = \\rho(x,t)\\,u$。\n  - 网格（控制体边界）速度由 $w = \\alpha\\,u$ 指定，其中 $\\alpha \\in \\mathbb{R}$ 是一个可调的网格运动参数。\n- 离散RTT残差估计器：\n  - 对于给定的时间步长 $\\Delta t$ 和网格运动参数 $\\alpha$，考虑一组 $N_{\\mathrm{cv}}$ 个随机采样的、以边界速度 $w$ 移动的控制体 $V_i(t)$。\n  - 在时刻 $t_n$ 定义一个控制体 $V_i(t)$，其随机中心 $c_i$ 在 $[0,L)$ 中均匀采样，随机长度 $\\ell_i$ 在 $[\\ell_{\\min}, \\ell_{\\max}]$ 中均匀采样，其中 $\\ell_{\\min} = 0.05$ 且 $\\ell_{\\max} = 0.35$。在时刻 $t_n$ 的区间端点为 $a_i^n = c_i - \\ell_i/2$ 和 $b_i^n = c_i + \\ell_i/2$。在时刻 $t_{n+1} = t_n + \\Delta t$ 的端点为 $a_i^{n+1} = a_i^n + w\\,\\Delta t$ 和 $b_i^{n+1} = b_i^n + w\\,\\Delta t$。中间时刻为 $t_{n+\\frac{1}{2}} = t_n + \\Delta t/2$，中间边界位置为 $a_i^{n+\\frac{1}{2}} = a_i^n + w\\,\\Delta t/2$ 和 $b_i^{n+\\frac{1}{2}} = b_i^n + w\\,\\Delta t/2$。所有位置都在周期为 $L$ 的周期性域上解释，但积分和点求值必须使用 $\\sin(\\cdot)$ 和 $\\cos(\\cdot)$ 的周期性，而无需进行显式的模运算包装。\n  - 对于每个控制体，通过移动控制体上积分的差商加上中间时刻边界处的净相对通量，计算质量的离散RTT残差，记为 $R_{\\rho,i}$。类似地，使用动量密度计算动量的离散残差 $R_{m,i}$。\n  - 通过平均绝对值汇集 $N_{\\mathrm{cv}}$ 个控制体上的残差，以获得全局漂移度量 $D_{\\rho} = \\frac{1}{N_{\\mathrm{cv}}}\\sum_{i=1}^{N_{\\mathrm{cv}}} |R_{\\rho,i}|$ 和 $D_m = \\frac{1}{N_{\\mathrm{cv}}}\\sum_{i=1}^{N_{\\mathrm{cv}}} |R_{m,i}|$。\n- 通过残差估计器进行自适应调整：\n  - 给定初始 $(\\Delta t_0, \\alpha_0)$，定义候选时间步长 $\\{\\Delta t_0/2, \\Delta t_0, 2\\Delta t_0\\}$ 和候选网格运动参数 $\\{\\alpha_0, 0, 0.5, 1.0, 1.5\\}$。\n  - 应用限幅以确保 $\\Delta t \\in [10^{-4}, 0.5]$ 和 $\\alpha \\in [-1.0, 2.0]$。\n  - 在给定测试用例下，对所有候选者使用同一组随机采样的 $N_{\\mathrm{cv}}$ 个控制体，为每个候选对 $(\\Delta t, \\alpha)$ 评估 $(D_{\\rho}, D_m)$，并选择使目标函数 $J = D_{\\rho} + D_m$ 最小化的对。\n  - 报告自适应调整后的对 $(\\Delta t^*, \\alpha^*)$ 和相应的 $(D_{\\rho}, D_m)$。\n- 随机采样：\n  - 使用 $N_{\\mathrm{cv}} = 64$ 和一个确定性的随机数生成器种子（每个测试用例唯一），以确保可复现性。\n- 测试套件：\n  - 所有测试均使用 $t_n = 0.2$。\n  - 测试用例 1：$(\\Delta t_0, \\alpha_0) = (0.1, 0.0)$。\n  - 测试用例 2：$(\\Delta t_0, \\alpha_0) = (0.4, -0.5)$。\n  - 测试用例 3：$(\\Delta t_0, \\alpha_0) = (0.05, 1.0)$。\n  - 测试用例 4：$(\\Delta t_0, \\alpha_0) = (0.001, 0.5)$。\n- 所需输出：\n  - 对于每个测试用例，您的程序必须计算出自适应调整后的 $(\\Delta t^*, \\alpha^*)$ 和相应的 $(D_{\\rho}, D_m)$，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个包含四个浮点数的列表 $[\\Delta t^*, \\alpha^*, D_{\\rho}, D_m]$，最终输出行必须是这些四元列表按测试套件顺序组成的列表，例如 $[[\\Delta t^*, \\alpha^*, D_{\\rho}, D_m], [\\dots], [\\dots], [\\dots]]$。\n\n所有量均为无量纲；无需进行物理单位转换。三角函数内的角度以弧度为单位。",
            "solution": "该问题要求基于移动控制体的雷诺输运定理 (RTT) 构建一个用于质量和动量守恒的后验误差估计器。然后，该估计器用于自适应地调整时间步长 $\\Delta t$ 和网格运动参数 $\\alpha$，以最小化给定人造流问题的数值守恒误差。\n\n首先，我们建立基于 RTT 的理论基础。对于一个密度为 $\\phi(x,t)$、通量为 $f_\\phi(x,t)$ 的通用守恒量 $\\phi$，假设没有源项，其一维微分形式的守恒律为 $\\frac{\\partial \\phi}{\\partial t} + \\frac{\\partial f_\\phi}{\\partial x} = 0$。\n\nRTT 描述了移动控制体 $V(t) = [a(t), b(t)]$ 内 $\\phi$ 的总量的时间演化。控制体的边界以指定的网格速度 $w$ 移动，使得 $a'(t) = w$ 和 $b'(t) = w$。RTT 表述为：\n$$\n\\frac{d}{dt} \\int_{a(t)}^{b(t)} \\phi(x,t) \\, dx = \\int_{a(t)}^{b(t)} \\frac{\\partial \\phi}{\\partial t} \\, dx + \\phi(b(t),t)w - \\phi(a(t),t)w\n$$\n将守恒律 $\\frac{\\partial \\phi}{\\partial t} = -\\frac{\\partial f_\\phi}{\\partial x}$ 代入 RTT，得到：\n$$\n\\frac{d}{dt} \\int_{a(t)}^{b(t)} \\phi(x,t) \\, dx = -\\int_{a(t)}^{b(t)} \\frac{\\partial f_\\phi}{\\partial x} \\, dx + [\\phi(x,t)w]_{a(t)}^{b(t)} = -[f_\\phi(x,t)]_{a(t)}^{b(t)} + [\\phi(x,t)w]_{a(t)}^{b(t)}\n$$\n整理各项，我们得到移动控制体的精确积分守恒律：\n$$\n\\frac{d}{dt} \\int_{a(t)}^{b(t)} \\phi(x,t) \\, dx + [f_\\phi(x,t) - \\phi(x,t)w]_{a(t)}^{b(t)} = 0\n$$\n项 $f_\\phi - \\phi w$ 表示 $\\phi$ 相对于移动边界的通量。对于给定问题，流体速度为常数 $u$。\n对于质量守恒，$\\phi = \\rho$，通量为 $f_\\rho = \\rho u$。\n对于动量守恒，$\\phi = m = \\rho u$，通量为 $f_m = m u = \\rho u^2$。\n在这两种情况下，都有 $f_\\phi = \\phi u$。相对通量为 $\\phi u - \\phi w = \\phi(u-w)$。精确的定律是：\n$$\n\\frac{d}{dt} \\int_{a(t)}^{b(t)} \\phi(x,t) \\, dx + [\\phi(x,t)(u-w)]_{a(t)}^{b(t)} = 0\n$$\n问题定义了一个离散残差 $R_{\\phi,i}$，它是这个连续定律的有限差分近似。对积分的时间导数使用一阶前向差分，并在中间时刻 $t_{n+\\frac{1}{2}} = t_n + \\Delta t/2$ 计算通量项，则控制体 $V_i$ 的残差为：\n$$\nR_{\\phi,i} = \\frac{1}{\\Delta t} \\left( \\int_{V_i(t_{n+1})} \\phi(x,t_{n+1}) dx - \\int_{V_i(t_n)} \\phi(x,t_n) dx \\right) + [\\phi(x,t_{n+\\frac{1}{2}})(u-w)]_{x=a_i^{n+\\frac{1}{2}}}^{x=b_i^{n+\\frac{1}{2}}}\n$$\n由于所提供的人造解 $\\rho(x,t) = 1 + A \\sin(2\\pi (x - ut))$ 是底层偏微分方程（$\\frac{\\partial \\rho}{\\partial t} + u \\frac{\\partial \\rho}{\\partial x} = 0$ 和 $\\frac{\\partial m}{\\partial t} + u \\frac{\\partial m}{\\partial x} = 0$）的精确解，因此连续定律被完全满足。因此，离散残差 $R_{\\phi,i}$ 的任何非零值都纯粹源于时间离散化误差。\n\n为精确计算积分并分离出此时间误差，我们可以使用密度场的解析积分。$\\rho(x,t)$ 对 $x$ 的不定积分为：\n$$\n\\int \\rho(x,t) \\, dx = \\int \\left(1 + A \\sin(2\\pi(x-ut))\\right) dx = x - \\frac{A}{2\\pi}\\cos(2\\pi(x-ut)) + C\n$$\n这使得在任何区间 $[a,b]$ 上的定积分都可以精确计算。动量密度 $m = \\rho u$ 的积分就是 $\\rho$ 的积分乘以 $u$。这样可以避免数值积分误差，这与通过人造解方法获得时间步进误差的后验估计器的目标是一致的。\n\n当分析控制体随流体移动的特殊情况，即 $w = u$ 时，会出现一个关键的洞见。在这个问题中，这对应于网格运动参数 $\\alpha = 1$。网格是所谓的任意拉格朗日-欧拉 (ALE) 框架的一部分，设置 $w=u$ 使得从网格的角度来看，描述是纯拉格朗日的。\n当 $w=u$ 时：\n1. 相对通量项 $[\\phi(x,t)(u-w)]$ 变为零。\n2. 对于行波解，积分项的时间变化率也变为零。$\\phi(x,t) = \\phi_0(x-ut)$ 在一个同样以速度 $u$ 移动的控制体 $[a(t), b(t)]$（即 $a(t) = a_0+ut, b(t)=b_0+ut$）上的积分不随时间变化：\n$$\n\\int_{a_0+ut}^{b_0+ut} \\phi_0(x-ut) \\, dx = \\int_{a_0}^{b_0} \\phi_0(y) \\, dy = \\text{const.}\n$$\n其中 $y = x-ut$。\n这意味着 $\\int_{V_i(t_{n+1})} \\phi(x,t_{n+1}) dx = \\int_{V_i(t_n)} \\phi(x,t_n) dx$。因此，对于 $\\alpha = 1$，残差 $R_{\\phi,i}$ 中的积分差和通量项都恒等于零。因此，漂移度量 $D_\\rho$ 和 $D_m$ 以及目标函数 $J = D_\\rho + D_m$ 均为零。\n\n由于 $J \\ge 0$，因此 $J=0$ 是全局最小值。在所有测试用例中，$\\alpha=1.0$ 都在候选参数集合中。因此，最优网格运动参数将始终是 $\\alpha^* = 1.0$。\n当 $\\alpha^*=1.0$ 时，对于任何候选时间步长 $\\Delta t$ 的选择，目标函数 $J$ 都为零。为确保确定性的解，需要一个平局打破规则。我们采用一个标准惯例：将候选的 $\\Delta t$ 和 $\\alpha$ 值按升序排序，并选择产生最小 $J$ 值的第一个对 $(\\Delta t, \\alpha)$。这意味着最小的候选 $\\Delta t$ 将被选为 $\\Delta t^*$。\n\n算法按以下步骤进行：\n1. 对于每个测试用例 $(\\Delta t_0, \\alpha_0)$，生成候选时间步长集合 $\\{\\Delta t_0/2, \\Delta t_0, 2\\Delta t_0\\}$ 和网格运动参数集合 $\\{\\alpha_0, 0, 0.5, 1.0, 1.5\\}$。\n2. 对两组候选者应用指定的限幅。\n3. 为确保确定性的平局打破，将唯一的、被限幅的 $\\Delta t$ 和 $\\alpha$ 候选值按升序排序。\n4. 对于给定的测试用例，使用指定的种子生成一个包含 $N_{\\mathrm{cv}}=64$ 个随机控制体的固定集合。\n5. 遍历已排序的候选对 $(\\Delta t, \\alpha)$ 并计算目标函数 $J=D_\\rho+D_m$。\n6. 产生最小 $J$ 值（将是 $(\\Delta t_{\\min}, 1.0)$）的第一个对被选为最优解 $(\\Delta t^*, \\alpha^*)$。\n7. 存储相应的漂移值 $(D_\\rho, D_m)$。根据上述分析，这些值将为零（或在机器精度范围内）。\n8. 收集所有测试用例的结果，并将其格式化为所要求的输出字符串。",
            "answer": "```python\nimport numpy as np\n\n# Global constants as per the problem statement.\nL = 1.0\nU = 0.7\nA = 0.2\nL_MIN = 0.05\nL_MAX = 0.35\nN_CV = 64\nTN = 0.2\nDT_CLAMP_MIN, DT_CLAMP_MAX = 1e-4, 0.5\nALPHA_CLAMP_MIN, ALPHA_CLAMP_MAX = -1.0, 2.0\n\n\ndef rho(x, t):\n    \"\"\"Computes the density field rho at position x and time t.\"\"\"\n    return 1.0 + A * np.sin(2.0 * np.pi * (x - U * t))\n\n\ndef m(x, t):\n    \"\"\"Computes the momentum density field m at position x and time t.\"\"\"\n    return rho(x, t) * U\n\n\ndef analytical_integral_rho(a, b, t):\n    \"\"\"\n    Computes the exact integral of the density rho(x, t) from a to b.\n    The anti-derivative of rho w.r.t. x is x - A/(2*pi) * cos(2*pi*(x-u*t)).\n    \"\"\"\n    cos_term = -A / (2.0 * np.pi) * (\n        np.cos(2.0 * np.pi * (b - U * t)) - np.cos(2.0 * np.pi * (a - U * t))\n    )\n    return (b - a) + cos_term\n\n\ndef analytical_integral_m(a, b, t):\n    \"\"\"\n    Computes the exact integral of the momentum density m(x, t) from a to b.\n    \"\"\"\n    return U * analytical_integral_rho(a, b, t)\n\n\ndef calculate_drifts(dt, alpha, cv_definitions):\n    \"\"\"\n    Calculates the drift metrics D_rho and D_m for a given dt and alpha.\n    \"\"\"\n    w = alpha * U\n    t_n1 = TN + dt\n    t_mid = TN + dt / 2.0\n\n    total_abs_R_rho = 0.0\n    total_abs_R_m = 0.0\n\n    for c, l in cv_definitions:\n        a_n = c - l / 2.0\n        b_n = c + l / 2.0\n\n        # Control volume boundaries at different times\n        a_n1 = a_n + w * dt\n        b_n1 = b_n + w * dt\n        a_mid = a_n + w * dt / 2.0\n        b_mid = b_n + w * dt / 2.0\n\n        # --- Mass residual calculation ---\n        I_rho_n = analytical_integral_rho(a_n, b_n, TN)\n        I_rho_n1 = analytical_integral_rho(a_n1, b_n1, t_n1)\n        \n        flux_term_rho = (rho(b_mid, t_mid) - rho(a_mid, t_mid)) * (U - w)\n        \n        R_rho = (I_rho_n1 - I_rho_n) / dt + flux_term_rho\n        total_abs_R_rho += abs(R_rho)\n\n        # --- Momentum residual calculation ---\n        I_m_n = analytical_integral_m(a_n, b_n, TN)\n        I_m_n1 = analytical_integral_m(a_n1, b_n1, t_n1)\n\n        flux_term_m = (m(b_mid, t_mid) - m(a_mid, t_mid)) * (U - w)\n        \n        R_m = (I_m_n1 - I_m_n) / dt + flux_term_m\n        total_abs_R_m += abs(R_m)\n\n    D_rho = total_abs_R_rho / N_CV\n    D_m = total_abs_R_m / N_CV\n    \n    return D_rho, D_m\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        (0.1, 0.0),    # Case 1\n        (0.4, -0.5),   # Case 2\n        (0.05, 1.0),   # Case 3\n        (0.001, 0.5),  # Case 4\n    ]\n\n    all_results = []\n\n    for i, (dt0, alpha0) in enumerate(test_cases):\n        seed = i  # Use a unique seed for each test case for reproducibility\n\n        # Generate and clamp candidate parameters\n        dt_candidates_raw = {dt0 / 2.0, dt0, dt0 * 2.0}\n        alpha_candidates_raw = {alpha0, 0.0, 0.5, 1.0, 1.5}\n\n        dt_candidates = sorted(list({\n            max(DT_CLAMP_MIN, min(DT_CLAMP_MAX, v)) for v in dt_candidates_raw\n        }))\n        alpha_candidates = sorted(list({\n            max(ALPHA_CLAMP_MIN, min(ALPHA_CLAMP_MAX, v)) for v in alpha_candidates_raw\n        }))\n\n        # Generate the set of random control volumes for this test case\n        rng = np.random.default_rng(seed)\n        centers = rng.uniform(0, L, size=N_CV)\n        lengths = rng.uniform(L_MIN, L_MAX, size=N_CV)\n        cv_definitions = list(zip(centers, lengths))\n\n        min_J = float('inf')\n        best_result = None\n\n        # Iterate through candidates to find the one minimizing the objective J\n        for dt_i in dt_candidates:\n            for alpha_j in alpha_candidates:\n                D_rho, D_m = calculate_drifts(dt_i, alpha_j, cv_definitions)\n                J = D_rho + D_m\n\n                if J < min_J:\n                    min_J = J\n                    best_result = [dt_i, alpha_j, D_rho, D_m]\n        \n        all_results.append(best_result)\n\n    # Format the final output string as specified\n    inner_strings = [\n        f\"[{','.join(f'{v:.7f}' for v in res)}]\" for res in all_results\n    ]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}