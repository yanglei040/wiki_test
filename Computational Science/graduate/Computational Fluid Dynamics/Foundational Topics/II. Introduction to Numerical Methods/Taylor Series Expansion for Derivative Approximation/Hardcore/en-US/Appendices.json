{
    "hands_on_practices": [
        {
            "introduction": "Accurate approximation of derivatives is the cornerstone of finite difference methods in CFD. High-order schemes are particularly crucial for resolving complex flow features and minimizing numerical errors like artificial diffusion. This first exercise  provides a foundational walkthrough of the \"method of undetermined coefficients,\" where you will use Taylor series expansions as a tool to systematically derive a fourth-order accurate approximation for a second derivative. Mastering this technique is the first step toward designing and analyzing custom numerical schemes for any partial differential equation.",
            "id": "3370259",
            "problem": "In Computational Fluid Dynamics (CFD), higher-order accurate discretizations of spatial derivatives are essential for resolving viscous effects with minimal numerical dissipation. Consider a smooth scalar field $f(x)$ representing, for example, a velocity component in a one-dimensional laminar flow. The pointwise second derivative $f''(x)$ is needed in the discretization of the viscous term of the Navier–Stokes equations. Suppose $f$ is sampled at the symmetric locations $x-2h$, $x-h$, $x$, $x+h$, and $x+2h$, where $h>0$ is the uniform grid spacing.\n\nStarting from the Taylor series expansion of $f(x\\pm h)$ and $f(x\\pm 2h)$ about $x$, construct a symmetric linear combination of the sampled values at the stencil $\\{x-2h, x-h, x, x+h, x+2h\\}$ that yields a fourth-order accurate approximation of $f''(x)$. Then, by carrying the Taylor series one order beyond the achieved accuracy, compute the leading truncation error term and express it explicitly in terms of $f^{(6)}(x)$ and $h$.\n\nYour final answer must consist of:\n1. A single closed-form analytic expression giving the fourth-order accurate finite-difference formula for $f''(x)$ using the given stencil.\n2. A single closed-form analytic expression for the leading truncation error term proportional to $f^{(6)}(x)$.\n\nProvide both expressions. No numerical rounding is required, and no units are needed.",
            "solution": "The user wants to derive a fourth-order accurate finite difference approximation for the second derivative, $f''(x)$, using a five-point symmetric stencil.\n\n### Step 1: Extract Givens\n- The function to be differentiated is a smooth scalar field $f(x)$.\n- The derivative to be approximated is the second derivative, $f''(x)$.\n- The stencil of points is symmetric: $\\{x-2h, x-h, x, x+h, x+2h\\}$.\n- $h>0$ is the uniform grid spacing.\n- The method to be used is constructing a linear combination of the function values at the stencil points, based on Taylor series expansions.\n- The required order of accuracy for the approximation of $f''(x)$ is fourth-order, i.e., the truncation error is $O(h^4)$.\n- The final result must include the finite difference formula and its leading truncation error term.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, being a standard and fundamental task in the field of numerical analysis, particularly as applied to computational fluid dynamics. It is well-posed, providing all necessary information (stencil, desired derivative, order of accuracy) to uniquely determine the coefficients of the linear combination and the leading error term. The language is objective and precise. The problem is free of any scientific or logical flaws, contradictions, or ambiguities.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Derivation of the Finite Difference Formula and Truncation Error\n\nWe seek an approximation for $f''(x)$ of the form:\n$$\nf''(x) \\approx \\frac{c_{-2}f(x-2h) + c_{-1}f(x-h) + c_0f(x) + c_1f(x+h) + c_2f(x+2h)}{k}\n$$\nFor a symmetric approximation on a symmetric stencil, we expect the coefficients to be symmetric, i.e., $c_{-i} = c_i$. Furthermore, for approximating a second derivative, the scaling factor $k$ is typically $h^2$. Let us define the coefficients as $c_0$, $c_1=c_{-1}$, and $c_2=c_{-2}$. The approximation, denoted $D_h^2 f(x)$, is:\n$$\nD_h^2 f(x) = \\frac{c_2 f(x-2h) + c_1 f(x-h) + c_0 f(x) + c_1 f(x+h) + c_2 f(x+2h)}{h^2}\n$$\nThis can be rewritten as:\n$$\nD_h^2 f(x) = \\frac{c_2[f(x+2h) + f(x-2h)] + c_1[f(x+h) + f(x-h)] + c_0 f(x)}{h^2}\n$$\nTo determine the coefficients $c_0$, $c_1$, and $c_2$, we use Taylor series expansions of $f(x \\pm h)$ and $f(x \\pm 2h)$ about the point $x$. Since the final error term involves $f^{(6)}(x)$, we must carry the expansions to a sufficiently high order to capture this term. The combination of $f(x+kh)$ and $f(x-kh)$ conveniently cancels all odd-order derivative terms.\n\nThe expansions for the sums are:\n$$\nf(x+h) + f(x-h) = 2 \\sum_{n=0}^{\\infty} \\frac{h^{2n}}{(2n)!} f^{(2n)}(x) = 2f(x) + h^2 f''(x) + \\frac{h^4}{12}f^{(4)}(x) + \\frac{h^6}{360}f^{(6)}(x) + O(h^8)\n$$\n$$\nf(x+2h) + f(x-2h) = 2 \\sum_{n=0}^{\\infty} \\frac{(2h)^{2n}}{(2n)!} f^{(2n)}(x) = 2f(x) + 4h^2 f''(x) + \\frac{16h^4}{12}f^{(4)}(x) + \\frac{64h^6}{360}f^{(6)}(x) + O(h^8)\n$$\nSimplifying the fractions in the second expansion:\n$$\nf(x+2h) + f(x-2h) = 2f(x) + 4h^2 f''(x) + \\frac{4h^4}{3}f^{(4)}(x) + \\frac{8h^6}{45}f^{(6)}(x) + O(h^8)\n$$\nNow, substitute these expansions into the expression for $D_h^2 f(x)$:\n\\begin{align*}\nh^2 D_h^2 f(x) &= c_2\\left[2f(x) + 4h^2 f''(x) + \\frac{4}{3}h^4f^{(4)}(x) + \\frac{8}{45}h^6f^{(6)}(x) + \\dots\\right] \\\\\n&+ c_1\\left[2f(x) + h^2 f''(x) + \\frac{1}{12}h^4f^{(4)}(x) + \\frac{1}{360}h^6f^{(6)}(x) + \\dots\\right] \\\\\n&+ c_0 f(x)\n\\end{align*}\nGroup terms by the derivatives of $f(x)$:\n\\begin{align*}\nh^2 D_h^2 f(x) &= f(x) [2c_2 + 2c_1 + c_0] \\\\\n&+ f''(x) h^2 [4c_2 + c_1] \\\\\n&+ f^{(4)}(x) h^4 \\left[\\frac{4}{3}c_2 + \\frac{1}{12}c_1\\right] \\\\\n&+ f^{(6)}(x) h^6 \\left[\\frac{8}{45}c_2 + \\frac{1}{360}c_1\\right] \\\\\n&+ O(h^8)\n\\end{align*}\nDividing by $h^2$, we get:\n$$\nD_h^2 f(x) = \\frac{f(x)}{h^2}[2c_2+2c_1+c_0] + f''(x)[4c_2+c_1] + f^{(4)}(x)h^2\\left[\\frac{4}{3}c_2+\\frac{1}{12}c_1\\right] + f^{(6)}(x)h^4\\left[\\frac{8}{45}c_2+\\frac{1}{360}c_1\\right] + O(h^6)\n$$\nFor $D_h^2 f(x)$ to be a fourth-order accurate approximation of $f''(x)$, we require the following conditions:\n$1$. The coefficient of $f(x)$ must be $0$: $2c_2 + 2c_1 + c_0 = 0$.\n$2$. The coefficient of $f''(x)$ must be $1$: $4c_2 + c_1 = 1$.\n$3$. The coefficient of the $h^2$ term (containing $f^{(4)}(x)$) must be $0$ to achieve at least fourth-order accuracy: $\\frac{4}{3}c_2 + \\frac{1}{12}c_1 = 0 \\implies 16c_2 + c_1 = 0$.\n\nWe now have a system of three linear equations for the three unknown coefficients:\n\\begin{cases}\n2c_2 + 2c_1 + c_0 = 0 \\\\\n4c_2 + c_1 = 1 \\\\\n16c_2 + c_1 = 0\n\\end{cases}\nFrom the third equation, we have $c_1 = -16c_2$.\nSubstituting this into the second equation: $4c_2 + (-16c_2) = 1 \\implies -12c_2 = 1 \\implies c_2 = -\\frac{1}{12}$.\nNow we can find $c_1$: $c_1 = -16\\left(-\\frac{1}{12}\\right) = \\frac{16}{12} = \\frac{4}{3}$.\nFinally, using the first equation to find $c_0$: $c_0 = -2c_2 - 2c_1 = -2\\left(-\\frac{1}{12}\\right) - 2\\left(\\frac{4}{3}\\right) = \\frac{1}{6} - \\frac{8}{3} = \\frac{1}{6} - \\frac{16}{6} = -\\frac{15}{6} = -\\frac{5}{2}$.\n\nThe coefficients are $c_2 = -\\frac{1}{12}$, $c_1 = \\frac{4}{3}$, and $c_0 = -\\frac{5}{2}$.\nThe finite difference formula for $f''(x)$ is:\n$$\nf''(x) \\approx \\frac{-\\frac{1}{12}f(x-2h) + \\frac{4}{3}f(x-h) - \\frac{5}{2}f(x) + \\frac{4}{3}f(x+h) - \\frac{1}{12}f(x+2h)}{h^2}\n$$\nTo eliminate fractions in the numerator, we multiply the numerator and denominator by $12$:\n$$\nf''(x) \\approx \\frac{-f(x-2h) + 16f(x-h) - 30f(x) + 16f(x+h) - f(x+2h)}{12h^2}\n$$\n\nThe truncation error $T$ is given by $T = D_h^2 f(x) - f''(x)$. With the derived coefficients, the terms involving $f(x)$, $f''(x)$, and $f^{(4)}(x)$ are correctly set. The leading error term is the first non-zero term in the expansion, which is the term containing $f^{(6)}(x)$:\n$$\nT = f^{(6)}(x)h^4\\left[\\frac{8}{45}c_2 + \\frac{1}{360}c_1\\right] + O(h^6)\n$$\nSubstituting the values for $c_1$ and $c_2$:\n$$\nT = f^{(6)}(x)h^4\\left[\\frac{8}{45}\\left(-\\frac{1}{12}\\right) + \\frac{1}{360}\\left(\\frac{4}{3}\\right)\\right] + O(h^6)\n$$\n$$\nT = f^{(6)}(x)h^4\\left[-\\frac{8}{540} + \\frac{4}{1080}\\right] = f^{(6)}(x)h^4\\left[-\\frac{16}{1080} + \\frac{4}{1080}\\right] = f^{(6)}(x)h^4\\left(-\\frac{12}{1080}\\right)\n$$\nSimplifying the fraction $-\\frac{12}{1080} = -\\frac{1}{90}$.\nThus, the leading truncation error term is:\n$$\nT = -\\frac{h^4}{90}f^{(6)}(x)\n$$\nThe approximation is indeed fourth-order accurate, as the error is $O(h^4)$.\n\nThe two required expressions are:\n$1$. The finite difference formula for $f''(x)$: $\\frac{-f(x-2h) + 16f(x-h) - 30f(x) + 16f(x+h) - f(x+2h)}{12h^2}$\n$2$. The leading truncation error term: $-\\frac{h^4}{90}f^{(6)}(x)$",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{-f(x-2h) + 16f(x-h) - 30f(x) + 16f(x+h) - f(x+2h)}{12h^2} & -\\frac{h^4}{90}f^{(6)}(x) \\end{pmatrix}}$$"
        },
        {
            "introduction": "While the previous exercise demonstrated how to construct schemes for a general function $f(x)$, real-world CFD problems often involve nonlinear conservation laws with flux functions of the form $F(g(x))$. Naively applying standard finite difference formulas to this composite structure can lead to subtle but significant \"commutation errors,\" where the discretization and differentiation operators do not commute. This practice  guides you through a Taylor series analysis to expose this discrete chain rule error, a crucial consideration when discretizing nonlinear hyperbolic systems.",
            "id": "3370227",
            "problem": "Consider a one-dimensional, uniform grid with nodes $x_i = x_0 + i h$ and constant spacing $h > 0$, used in computational fluid dynamics (CFD). Let $g : \\mathbb{R} \\to \\mathbb{R}$ be a sufficiently smooth scalar field and let $f : \\mathbb{R} \\to \\mathbb{R}$ be a sufficiently smooth nonlinear flux function. Define $F(x) = f(g(x))$. The objective is to approximate $\\partial_x F(x)$ at $x_i$.\n\nStarting from the fundamental definition of the derivative and the Taylor series expansion about $x_i$, address the following:\n\n1) Using second-order central differences on the grid, the two discrete approximations\n$$D_c F(x_i) \\equiv \\frac{F(x_{i+1}) - F(x_{i-1})}{2 h} \\quad \\text{and} \\quad f'(g(x_i))\\,D_c g(x_i) \\equiv f'(g(x_i))\\,\\frac{g(x_{i+1}) - g(x_{i-1})}{2 h}$$\nboth converge to $\\partial_x F(x_i)$ as $h \\to 0$, but they are not equal at finite $h$. Using Taylor series expansions of $g(x)$ about $x_i$ and then expanding $f(g(x))$ about the point $g(x_i)$, derive the leading-order expression (up to and including terms of order $h^2$) for the discrete chain rule error\n$$E_i \\equiv D_c F(x_i) - f'(g(x_i))\\,D_c g(x_i).$$\nExpress $E_i$ in terms of derivatives of $f$ with respect to its argument evaluated at $g(x_i)$ and derivatives of $g$ with respect to $x$ evaluated at $x_i$.\n\n2) Propose a symmetric five-point centered linear stencil\n$$\\mathcal{D}_h[F]_i \\equiv \\sum_{m=-2}^{2} c_m\\,F(x_{i+m})$$\nto approximate $\\partial_x F(x_i)$, where the coefficients $c_m$ depend on $h$ and are to be chosen so that the stencil is consistent with the continuous derivative and cancels all $\\mathcal{O}(h^2)$ truncation error terms that arise in the Taylor expansion of $\\mathcal{D}_h[F]_i$ for general analytic $f$ and smooth $g$. Determine the coefficients $c_{-2}, c_{-1}, c_0, c_1, c_2$ as closed-form expressions in $h$.\n\nYour final answer should be the row matrix of the five coefficients $c_{-2}, c_{-1}, c_0, c_1, c_2$, written in terms of $h$.",
            "solution": "The user has provided a problem in numerical analysis, specifically concerning the finite difference approximation of derivatives for a composite function, a common task in computational fluid dynamics (CFD).\n\nFirst, I will validate the problem statement as per the specified protocol.\n\n### Step 1: Extract Givens\n- **Grid:** A one-dimensional, uniform grid with nodes $x_i = x_0 + i h$ and constant spacing $h > 0$.\n- **Functions:** $g : \\mathbb{R} \\to \\mathbb{R}$ is a sufficiently smooth scalar field. $f : \\mathbb{R} \\to \\mathbb{R}$ is a sufficiently smooth nonlinear flux function.\n- **Composite Function:** $F(x) = f(g(x))$.\n- **Objective:** Approximate the derivative $\\partial_x F(x)$ at the grid node $x_i$.\n- **Part 1 Task:** Derive the leading-order expression for the discrete chain rule error $E_i \\equiv D_c F(x_i) - f'(g(x_i))\\,D_c g(x_i)$. The derivation should be carried out up to and including terms of order $h^2$.\n- **Discrete Operators:**\n  - Second-order central difference for $F$: $D_c F(x_i) \\equiv \\frac{F(x_{i+1}) - F(x_{i-1})}{2 h}$.\n  - Second-order central difference for $g$: $D_c g(x_i) \\equiv \\frac{g(x_{i+1}) - g(x_{i-1})}{2 h}$.\n- **Part 2 Task:** Determine the coefficients $c_m$ for a symmetric five-point a centered linear stencil $\\mathcal{D}_h[F]_i \\equiv \\sum_{m=-2}^{2} c_m\\,F(x_{i+m})$ that approximates $\\partial_x F(x_i)$ such that the stencil is consistent and all $\\mathcal{O}(h^2)$ truncation error terms are cancelled.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to rigorous validation.\n- **Scientific Grounding:** The problem is firmly rooted in the mathematical field of numerical analysis, specifically the theory of finite differences. Taylor series expansions are the fundamental tool for analyzing the accuracy of such schemes. The concept of a discrete chain rule and the associated commutation error is a standard topic in the numerical solution of conservation laws. The problem is scientifically and mathematically sound.\n- **Well-Posedness:** The problem is well-posed. Part 1 asks for a specific derivation, which has a unique result based on standard Taylor series calculus. Part 2 asks for the determination of coefficients for a finite difference stencil with specified properties (5-point, symmetric, 4th-order accurate). This leads to a well-defined system of linear equations for the coefficients, which has a unique solution.\n- **Objectivity:** The problem is stated in precise, objective mathematical language.\n- **Completeness and Consistency:** The problem provides all necessary definitions and constraints. The assumption that $f$ and $g$ are \"sufficiently smooth\" is standard and appropriate, as it guarantees the existence of the required higher-order derivatives for the Taylor series expansions.\n- **Other Flaws:** The problem does not exhibit any other flaws such as being unrealistic, ill-structured, trivial, or unverifiable. It is a standard, non-trivial exercise in numerical methods.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n### Solution\n\nThe problem is addressed in two parts. For clarity, we will denote derivatives of $g$ with respect to $x$ evaluated at $x_i$ as $g_i' = \\frac{dg}{dx}(x_i)$, $g_i'' = \\frac{d^2g}{dx^2}(x_i)$, etc. Similarly, derivatives of $f$ with respect to its argument, evaluated at $g(x_i)$, will be denoted as $f_i' = \\frac{df}{dg}(g(x_i))$, $f_i'' = \\frac{d^2f}{dg^2}(g(x_i))$, etc.\n\n**Part 1: Derivation of the Discrete Chain Rule Error**\n\nThe error is defined as $E_i \\equiv D_c F(x_i) - f_i'\\,D_c g(x_i)$. We will expand each term using Taylor series up to the required order.\n\nFirst, we expand the operator $D_c g(x_i)$:\nThe Taylor series expansions of $g(x)$ around $x_i$ are:\n$$g(x_{i+1}) = g(x_i+h) = g(x_i) + h g_i' + \\frac{h^2}{2} g_i'' + \\frac{h^3}{6} g_i''' + \\mathcal{O}(h^4)$$\n$$g(x_{i-1}) = g(x_i-h) = g(x_i) - h g_i' + \\frac{h^2}{2} g_i'' - \\frac{h^3}{6} g_i''' + \\mathcal{O}(h^4)$$\nSubstituting into the definition of $D_c g(x_i)$:\n$$D_c g(x_i) = \\frac{g(x_{i+1}) - g(x_{i-1})}{2h} = \\frac{(g(x_i) + h g_i' + \\frac{h^2}{2} g_i'' + \\frac{h^3}{6} g_i''') - (g(x_i) - h g_i' + \\frac{h^2}{2} g_i'' - \\frac{h^3}{6} g_i''')}{2h} + \\mathcal{O}(h^3)$$\n$$D_c g(x_i) = \\frac{2 h g_i' + \\frac{h^3}{3} g_i'''}{2h} + \\mathcal{O}(h^3) = g_i' + \\frac{h^2}{6} g_i''' + \\mathcal{O}(h^3)$$\nThus, the second term in the error expression is:\n$$f_i'\\,D_c g(x_i) = f_i'(g_i' + \\frac{h^2}{6} g_i''') + \\mathcal{O}(h^3) = f_i'g_i' + \\frac{h^2}{6} f_i'g_i''' + \\mathcal{O}(h^3)$$\n\nNext, we analyze the term $D_c F(x_i)$. The true derivative is $\\partial_x F(x_i) = \\frac{d}{dx}f(g(x))|_{x=x_i} = f_i' g_i'$. The central difference operator is known to have a truncation error that depends on the third derivative of the function it is applied to. The third derivative of $F(x)$ is:\n$$F'(x) = f'(g(x)) g'(x)$$\n$$F''(x) = f''(g(x)) (g'(x))^2 + f'(g(x)) g''(x)$$\n$$F'''(x) = f'''(g(x)) (g'(x))^3 + 3 f''(g(x)) g'(x) g''(x) + f'(g(x)) g'''(x)$$\nThe Taylor expansion for the central difference operator is:\n$$D_c F(x_i) = F'(x_i) + \\frac{h^2}{6} F'''(x_i) + \\mathcal{O}(h^4)$$\nSubstituting the expressions for $F'(x_i)$ and $F'''(x_i)$:\n$$D_c F(x_i) = (f_i' g_i') + \\frac{h^2}{6} (f_i''' (g_i')^3 + 3 f_i'' g_i' g_i'' + f_i' g_i''') + \\mathcal{O}(h^4)$$\n$$D_c F(x_i) = f_i' g_i' + \\frac{h^2}{6} f_i' g_i''' + \\frac{h^2}{2} f_i'' g_i' g_i'' + \\frac{h^2}{6} f_i''' (g_i')^3 + \\mathcal{O}(h^4)$$\n\nFinally, we compute the error $E_i = D_c F(x_i) - f_i'\\,D_c g(x_i)$:\n$$E_i = \\left( f_i' g_i' + \\frac{h^2}{6} f_i' g_i''' + \\frac{h^2}{2} f_i'' g_i' g_i'' + \\frac{h^2}{6} f_i''' (g_i')^3 \\right) - \\left( f_i'g_i' + \\frac{h^2}{6} f_i'g_i''' \\right) + \\mathcal{O}(h^4)$$\nThe terms $f_i' g_i'$ and $\\frac{h^2}{6} f_i' g_i'''$ cancel out. The leading-order error is:\n$$E_i = \\frac{h^2}{2} f_i'' g_i' g_i'' + \\frac{h^2}{6} f_i''' (g_i')^3 + \\mathcal{O}(h^4)$$\nThe expression for the error, up to and including terms of order $h^2$, is:\n$$E_i = h^2 \\left( \\frac{1}{2} \\frac{d^2f}{dg^2}(g(x_i)) \\frac{dg}{dx}(x_i) \\frac{d^2g}{dx^2}(x_i) + \\frac{1}{6} \\frac{d^3f}{dg^3}(g(x_i)) \\left(\\frac{dg}{dx}(x_i)\\right)^3 \\right)$$\nThis error, arising from the non-commutation of differentiation and discretization, is a critical issue in the numerical simulation of nonlinear phenomena.\n\n**Part 2: Determination of the Five-Point Stencil Coefficients**\n\nWe seek coefficients $c_m$ for the stencil $\\mathcal{D}_h[F]_i = \\sum_{m=-2}^{2} c_m\\,F(x_{i+m})$ such that $\\mathcal{D}_h[F]_i = \\partial_x F(x_i) + \\mathcal{O}(h^4)$. This is a fourth-order accurate scheme. We Taylor expand $F(x_{i+m}) = F(x_i+mh)$ about $x_i$:\n$$F(x_{i+m}) = F(x_i) + (mh)F'(x_i) + \\frac{(mh)^2}{2!}F''(x_i) + \\frac{(mh)^3}{3!}F'''(x_i) + \\frac{(mh)^4}{4!}F^{(4)}(x_i) + \\dots$$\nSubstituting this into the stencil definition:\n$$\\mathcal{D}_h[F]_i = \\sum_{m=-2}^{2} c_m \\left( F_i + mh F'_i + \\frac{m^2h^2}{2} F''_i + \\frac{m^3h^3}{6} F'''_i + \\frac{m^4h^4}{24} F^{(4)}_i + \\mathcal{O}(h^5) \\right)$$\nGrouping terms by derivatives of $F$:\n$$\\mathcal{D}_h[F]_i = F_i \\left(\\sum c_m\\right) + F'_i \\left(h \\sum m c_m\\right) + F''_i \\left(\\frac{h^2}{2} \\sum m^2 c_m\\right) + F'''_i \\left(\\frac{h^3}{6} \\sum m^3 c_m\\right) + F^{(4)}_i \\left(\\frac{h^4}{24} \\sum m^4 c_m\\right) + \\mathcal{O}(h^5)$$\nTo approximate $F'_i$ with an error of $\\mathcal{O}(h^4)$, we must satisfy the following system of equations:\n1. Coefficient of $F_i$: $\\sum_{m=-2}^{2} c_m = 0$\n2. Coefficient of $F'_i$: $h \\sum_{m=-2}^{2} m c_m = 1$\n3. Coefficient of $F''_i$ (source of $\\mathcal{O}(h)$ error): $\\sum_{m=-2}^{2} m^2 c_m = 0$\n4. Coefficient of $F'''_i$ (source of $\\mathcal{O}(h^2)$ error): $\\sum_{m=-2}^{2} m^3 c_m = 0$\n5. Coefficient of $F^{(4)}_i$ (source of $\\mathcal{O}(h^3)$ error): $\\sum_{m=-2}^{2} m^4 c_m = 0$\n\nThe problem specifies a \"symmetric centered linear stencil\". For approximating an odd-order derivative (the first derivative), this implies anti-symmetric coefficients: $c_{-m} = -c_m$. This gives:\n$$c_0 = 0, \\quad c_{-1} = -c_1, \\quad c_{-2} = -c_2$$\nLet's check how this simplifies our system of equations:\n1. $\\sum c_m = c_{-2}+c_{-1}+c_0+c_1+c_2 = -c_2-c_1+0+c_1+c_2 = 0$. This is automatically satisfied.\n3. $\\sum m^2 c_m = (-2)^2 c_{-2} + (-1)^2 c_{-1} + 1^2 c_1 + 2^2 c_2 = 4(-c_2) + 1(-c_1) + c_1 + 4c_2 = 0$. This is also automatically satisfied.\n5. $\\sum m^4 c_m = (-2)^4 c_{-2} + (-1)^4 c_{-1} + 1^4 c_1 + 2^4 c_2 = 16(-c_2) + 1(-c_1) + c_1 + 16c_2 = 0$. This is also automatically satisfied.\n\nThe anti-symmetry condition automatically removes all even-powered error terms. We are left with two non-trivial equations for the two unknowns $c_1$ and $c_2$:\n2. $h \\sum m c_m = h( (-2)c_{-2} + (-1)c_{-1} + 1 c_1 + 2 c_2 ) = h( (-2)(-c_2) + (-1)(-c_1) + c_1 + 2c_2 ) = h(2c_2 + c_1 + c_1 + 2c_2) = h(2c_1 + 4c_2) = 1$.\n   $$ \\implies 2c_1 + 4c_2 = \\frac{1}{h} $$\n4. $\\sum m^3 c_m = (-2)^3 c_{-2} + (-1)^3 c_{-1} + 1^3 c_1 + 2^3 c_2 = -8(-c_2) -1(-c_1) + c_1 + 8c_2 = 8c_2 + c_1 + c_1 + 8c_2 = 2c_1 + 16c_2 = 0$.\n   $$ \\implies c_1 + 8c_2 = 0 $$\n\nWe now solve this $2 \\times 2$ linear system. From the second equation, we have $c_1 = -8 c_2$. Substituting this into the first equation:\n$$2(-8c_2) + 4c_2 = \\frac{1}{h}$$\n$$-16c_2 + 4c_2 = \\frac{1}{h}$$\n$$-12c_2 = \\frac{1}{h} \\implies c_2 = -\\frac{1}{12h}$$\nNow, we find $c_1$:\n$$c_1 = -8c_2 = -8 \\left(-\\frac{1}{12h}\\right) = \\frac{8}{12h} = \\frac{2}{3h}$$\nThe full set of coefficients is:\n$$c_2 = -\\frac{1}{12h}$$\n$$c_1 = \\frac{2}{3h}$$\n$$c_0 = 0$$\n$$c_{-1} = -c_1 = -\\frac{2}{3h}$$\n$$c_{-2} = -c_2 = \\frac{1}{12h}$$\nArranging them in the required order $(c_{-2}, c_{-1}, c_0, c_1, c_2)$, we get the final result.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{12h} & -\\frac{2}{3h} & 0 & \\frac{2}{3h} & -\\frac{1}{12h}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "So far, our analysis has focused on the *local truncation error*—the error made at a single point in space when approximating a derivative. But in a time-dependent simulation, how does this local error accumulate and propagate through the domain? This advanced practice  connects local error analysis to global error dynamics by introducing the concept of the *modified equation*. You will use Taylor series to derive an advection equation for the discretization error itself, revealing how local errors are transported along characteristics and providing a powerful tool for predicting and controlling numerical inaccuracies in a full simulation.",
            "id": "3370224",
            "problem": "Consider the one-dimensional linear advection equation from Computational Fluid Dynamics (CFD)\n$$\n\\partial_t u + a\\,\\partial_x u = 0\n$$\nposed on a periodic domain of length $L$, discretized in space on a uniform grid with spacing $h$ via the method of lines (MOL). The spatial derivative $\\partial_x u$ is approximated by a linear finite-difference (FD) stencil of the form\n$$\nD_h u(x_i) \\equiv \\frac{1}{h} \\sum_{j=1}^{J} w_j\\,u(x_i + r_j h),\n$$\nwhere $r_j \\in \\mathbb{Z}$ are integer offsets, $w_j \\in \\mathbb{R}$ are fixed weights, and $J \\in \\mathbb{N}$ is the number of stencil points.\n\nStarting from the fundamental definitions of the Taylor series and the conservation form of the advection equation, derive the Taylor-based modified equation for the semi-discrete MOL system in which $D_h u$ replaces $\\partial_x u$. From that modified equation, systematically derive a transport equation for the pointwise discretization error $e \\equiv u_h - u$, where $u_h$ denotes the semi-discrete solution and $u$ denotes the exact solution, that is valid to leading order in $h$. Use characteristic curves of the advection operator to express the accumulation of the leading-order truncation error of order $O(h^p)$ along characteristics for a general stencil order $p \\in \\mathbb{N}$ with a leading coefficient $\\alpha \\in \\mathbb{R}$ determined by the stencil weights and offsets.\n\nYour derivation must begin from:\n- The definition of the Taylor series expansion of a smooth function.\n- The conservation law form $\\partial_t u + \\partial_x (a u) = 0$ specialized to constant $a$.\n- The method of lines semi-discretization that replaces $\\partial_x u$ by $D_h u$.\n\nNo other formulas may be taken as given. The result must show how the error is transported and accumulated along characteristics and must identify how $\\alpha$ and $p$ are determined from the stencil without assuming any pre-tabulated results.\n\nThen, implement a program that, for each test case below, does all of the following in a completely self-contained manner:\n\n$1.$ Given $\\{(r_j, w_j)\\}_{j=1}^J$, automatically computes the formal order $p$ and the leading truncation coefficient $\\alpha$ by matching the Taylor moments implied by the stencil.\n\n$2.$ Uses the derived error transport equation to predict the pointwise error at a probe location $x_f$ at time $T$ by integrating the leading-order source term along characteristics. Assume exact time integration of the semi-discrete system so that only the spatial discretization error contributes at leading order.\n\n$3.$ Performs one step of adaptive mesh refinement driven by the predicted transported error:\n- Start from a uniform mesh with $N_0$ cells of width $h = L/N_0$ and cell centers $x_i = (i+\\tfrac{1}{2})h$ for $i \\in \\{0,\\dots,N_0-1\\}$.\n- Define the cellwise error indicator $I_i$ as the absolute value of the predicted leading-order pointwise error at time $T$ evaluated at $x_i$ using the characteristic transport of the leading $O(h^p)$ term.\n- Flag every cell with $I_i > \\text{tol}$ for refinement (with $\\text{tol} > 0$ given), and refine each flagged cell by bisecting it into two equal children (uniform $h/2$ on that cell only).\n- Let $N_{\\text{new}}$ be the new total number of cells after this single refinement sweep. Compute a post-refinement predicted global $L^\\infty$ error at time $T$ by evaluating the leading-order transported error on the refined mesh as follows: for each unrefined cell, evaluate the indicator at its center with width $h$; for each refined cell, evaluate the indicator at both children centers with width $h/2$, and take the maximum absolute value over all evaluation points.\n\n$4.$ Returns, for each test case, the tuple consisting of:\n- the predicted pointwise error at the probe location before refinement,\n- the new total number of cells $N_{\\text{new}}$ after refinement,\n- the post-refinement predicted global $L^\\infty$ error at time $T$.\n\nAssume $a$ is constant, $L > 0$, and that the initial condition is a smooth trigonometric signal\n$$\nu_0(x) = \\sum_{m=1}^{M} A_m \\sin(k_m x), \\quad A_m \\in \\mathbb{R}, \\; k_m \\in \\mathbb{N},\n$$\non the periodic interval $x \\in [0,L)$, with advection solution $u(x,t) = u_0(x - a t)$.\n\nYour program must hard-code and solve the following test suite exactly:\n\n- Test case $1$ (happy path, mixed scales, second-order central stencil):\n  - Domain length $L = 2\\pi$.\n  - Advection speed $a = 1$.\n  - Final time $T = 0.7$.\n  - Initial condition coefficients: $M = 2$, $(A_1, k_1) = (1, 1)$, $(A_2, k_2) = (0.1, 8)$.\n  - Stencil: $J = 2$, offsets $(r_1, r_2) = (-1, 1)$, weights $(w_1, w_2) = (-0.5, 0.5)$.\n  - Initial cell count $N_0 = 64$ and tolerance $\\text{tol} = 0.02$.\n  - Probe location $x_f = 1.0$.\n\n- Test case $2$ (edge case with strong numerical diffusion from upwind, first-order upwind stencil):\n  - Domain length $L = 2\\pi$.\n  - Advection speed $a = 1$.\n  - Final time $T = 0.5$.\n  - Initial condition: $M = 1$, $(A_1, k_1) = (1, 3)$.\n  - Stencil: $J = 2$, offsets $(r_1, r_2) = (0, -1)$, weights $(w_1, w_2) = (1, -1)$.\n  - Initial cell count $N_0 = 32$ and tolerance $\\text{tol} = 0.3$.\n  - Probe location $x_f = 2.2$.\n\n- Test case $3$ (high-order dispersion, fourth-order central stencil):\n  - Domain length $L = 2\\pi$.\n  - Advection speed $a = 1$.\n  - Final time $T = 0.4$.\n  - Initial condition: $M = 1$, $(A_1, k_1) = (1, 5)$.\n  - Stencil: $J = 4$, offsets $(r_1, r_2, r_3, r_4) = (-2, -1, 1, 2)$, weights $(w_1, w_2, w_3, w_4) = (1/12, -2/3, 2/3, -1/12)$.\n  - Initial cell count $N_0 = 40$ and tolerance $\\text{tol} = 0.01$.\n  - Probe location $x_f = 0.3$.\n\nAngle is measured in radians throughout. There are no physical units involved in the numerical outputs.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results aggregated over the three test cases as a flat comma-separated list enclosed in square brackets:\n$$\n[\\text{err}_1, N_{\\text{new},1}, \\|e\\|_{\\infty,1}^{\\text{post}}, \\text{err}_2, N_{\\text{new},2}, \\|e\\|_{\\infty,2}^{\\text{post}}, \\text{err}_3, N_{\\text{new},3}, \\|e\\|_{\\infty,3}^{\\text{post}}].\n$$\n- Here $\\text{err}_i$ is the predicted pointwise error at the probe location before refinement (a float), $N_{\\text{new},i}$ is the new integer cell count after the single refinement step, and $\\|e\\|_{\\infty,i}^{\\text{post}}$ is the post-refinement predicted global $L^\\infty$ error (a float). All floats must be rounded to exactly $8$ decimal places in the printed output.",
            "solution": "The task is to derive a transport equation for the leading-order spatial discretization error of a semi-discretized linear advection equation and use it to predict and adapt to this error. The derivation must proceed from first principles.\n\nThe one-dimensional linear advection equation is given by\n$$\n\\partial_t u + a\\,\\partial_x u = 0\n$$\non a periodic domain of length $L$, where $a$ is a constant advection speed. The problem requires starting from the conservation form, $\\partial_t u + \\partial_x (a u) = 0$. For a constant advection speed $a$, this is equivalent to $\\partial_t u + a \\partial_x u + u \\partial_x a = \\partial_t u + a \\partial_x u = 0$, which is consistent with the initial equation.\n\nThe Method of Lines (MOL) is employed, where the spatial derivative $\\partial_x u$ is approximated by a finite-difference stencil $D_h u$, leading to a system of ordinary differential equations (ODEs) in time for the solution values $u_h(x_i, t)$ at grid points $x_i$. The semi-discrete system is\n$$\n\\frac{d u_h(x_i, t)}{dt} + a D_h u_h(x_i, t) = 0\n$$\nThe stencil is defined as\n$$\nD_h u(x_i) \\equiv \\frac{1}{h} \\sum_{j=1}^{J} w_j u(x_i + r_j h)\n$$\nwhere $h$ is the grid spacing, $\\{r_j\\}_{j=1}^J$ are integer offsets, and $\\{w_j\\}_{j=1}^J$ are real-valued weights.\n\n### Step 1: Derivation of the Modified Equation\n\nThe core of the analysis is to determine what partial differential equation the semi-discrete solution $u_h$ *actually* solves, to a certain order of accuracy. This equation is known as the modified equation.\n\nWe begin by expanding each term $u(x_i + r_j h)$ in the stencil definition using a Taylor series around the point $x_i$:\n$$\nu(x_i + r_j h) = \\sum_{k=0}^{\\infty} \\frac{(r_j h)^k}{k!} \\partial_x^k u(x_i)\n$$\nSubstituting this into the definition of $D_h u(x_i)$ yields:\n$$\nD_h u(x_i) = \\frac{1}{h} \\sum_{j=1}^{J} w_j \\left( \\sum_{k=0}^{\\infty} \\frac{(r_j h)^k}{k!} \\partial_x^k u(x_i) \\right)\n$$\nBy swapping the order of summation, which is permissible for a convergent series, and factoring out terms that do not depend on $j$:\n$$\nD_h u(x_i) = \\sum_{k=0}^{\\infty} \\left( \\frac{1}{k!} \\sum_{j=1}^{J} w_j r_j^k \\right) h^{k-1}  \\partial_x^k u(x_i)\n$$\nLet's define the moments of the stencil as $C_k = \\frac{1}{k!} \\sum_{j=1}^{J} w_j r_j^k$. The expression becomes:\n$$\nD_h u(x_i) = C_0 \\frac{u(x_i)}{h} + C_1 \\partial_x u(x_i) + C_2 h \\partial_x^2 u(x_i) + C_3 h^2 \\partial_x^3 u(x_i) + \\dots\n$$\nFor $D_h u$ to be a consistent approximation of $\\partial_x u$, we require that, as $h \\to 0$, $D_h u \\to \\partial_x u$. This imposes conditions on the leading moments:\n1.  $C_0 = \\sum_{j=1}^J w_j = 0$ (to eliminate the $O(h^{-1})$ term).\n2.  $C_1 = \\sum_{j=1}^J w_j r_j = 1$ (so the $O(h^0)$ term is exactly $\\partial_x u$).\n\nA finite difference stencil is said to be of order $p$ if it is consistent and if the error term is of order $O(h^p)$. This means the coefficients of the lower-order error terms must vanish:\n$$\nC_k = \\frac{1}{k!} \\sum_{j=1}^{J} w_j r_j^k = 0 \\quad \\text{for } k = 2, 3, \\dots, p\n$$\nThe first non-vanishing moment for $k > 1$ determines the leading-order truncation error. If $C_{p+1} \\neq 0$, then the stencil is of order $p$, and its expansion is:\n$$\nD_h u = \\partial_x u + C_{p+1} h^p \\partial_x^{p+1} u + O(h^{p+1})\n$$\nThe coefficient $\\alpha \\equiv C_{p+1}$ is the leading truncation error coefficient.\n\nNow, we replace $\\partial_x$ with $D_h$ in the advection equation. The semi-discrete solution $u_h$ is assumed to be sufficiently smooth to be represented by the modified equation. Substituting the expansion of the operator $D_h$ into the semi-discrete equation gives the modified equation for $u_h$:\n$$\n\\partial_t u_h + a \\left( \\partial_x u_h + \\alpha h^p \\partial_x^{p+1} u_h + O(h^{p+1}) \\right) = 0\n$$\nRearranging, we get\n$$\n\\partial_t u_h + a \\partial_x u_h = -a \\alpha h^p \\partial_x^{p+1} u_h + O(h^{p+1})\n$$\nThis is the modified equation. It shows that the numerical solution $u_h$ does not satisfy the original PDE, but rather a perturbed version, where the perturbation term on the right-hand side represents the leading-order effect of the spatial discretization.\n\n### Step 2: Derivation of the Error Transport Equation\n\nLet the pointwise discretization error be $e(x, t) \\equiv u_h(x, t) - u(x, t)$, where $u(x, t)$ is the exact solution to the original PDE, $\\partial_t u + a \\partial_x u = 0$.\n\nWe subtract the original PDE from the modified equation:\n$$\n(\\partial_t u_h - \\partial_t u) + a (\\partial_x u_h - \\partial_x u) = -a \\alpha h^p \\partial_x^{p+1} u_h + O(h^{p+1})\n$$\nThis simplifies to an equation for the error $e$:\n$$\n\\partial_t e + a \\partial_x e = -a \\alpha h^p \\partial_x^{p+1} u_h + O(h^{p+1})\n$$\nThis is a transport equation for the error $e$. The term on the right-hand side acts as a source term, continuously generating error. To obtain an equation valid to leading order, we can approximate $u_h$ with $u$ in the source term, because $u_h = u + e = u + O(h^p)$. The difference, $\\partial_x^{p+1}(u_h - u) = \\partial_x^{p+1}e$, is of higher order in $h$ when multiplied by $h^p$. Thus, the leading-order error transport equation is:\n$$\n\\partial_t e + a \\partial_x e \\approx -a \\alpha h^p \\partial_x^{p+1} u(x, t)\n$$\n\n### Step 3: Solution by the Method of Characteristics\n\nThe operator on the left-hand side, $\\mathcal{L} \\equiv \\partial_t + a \\partial_x$, is the total derivative along the characteristic curves defined by $\\frac{dx}{dt} = a$. Integrating this gives the characteristic lines $x(t) = x_0 + at$, where $x_0$ is the position at $t=0$.\n\nAlong a characteristic, the error equation becomes an ordinary differential equation:\n$$\n\\frac{d}{dt} e(x(t), t) \\approx S(x(t), t)\n$$\nwhere $S(x,t) = -a \\alpha h^p \\partial_x^{p+1} u(x, t)$ is the error source term. Assuming zero initial error, $e(x, 0) = 0$, we can find the error at a point $(x_f, T)$ by integrating the source term along the characteristic curve that passes through this point. The characteristic is parameterized by $\\tau \\in [0, T]$ as $x(\\tau) = x_f - a(T-\\tau)$.\n$$\ne(x_f, T) \\approx \\int_0^T S(x(\\tau), \\tau) d\\tau = \\int_0^T -a \\alpha h^p \\partial_x^{p+1} u(x_f - a(T-\\tau), \\tau) d\\tau\n$$\nThe exact solution to the advection equation is $u(x, t) = u_0(x - at)$, where $u_0(x)$ is the initial condition. Its $(p+1)$-th spatial derivative is $\\partial_x^{p+1} u(x, t) = u_0^{(p+1)}(x-at)$. Substituting this into the integral:\n$$\ne(x_f, T) \\approx \\int_0^T -a \\alpha h^p u_0^{(p+1)}\\left( (x_f - aT + a\\tau) - a\\tau \\right) d\\tau\n$$\nThe argument of the function $u_0^{(p+1)}$ simplifies to $x_f - aT$, which is the starting point on the $x$-axis of the characteristic that arrives at $x_f$ at time $T$. Since this argument is constant with respect to the integration variable $\\tau$, the integrand is constant. The integral evaluates to:\n$$\ne(x_f, T) \\approx -a \\alpha h^p T u_0^{(p+1)}(x_f - aT)\n$$\nThis is the final expression for the leading-order pointwise error.\n\nFor the given initial condition $u_0(x) = \\sum_{m=1}^{M} A_m \\sin(k_m x)$, the $(p+1)$-th derivative is found using the general rule $D^n \\sin(kx) = k^n \\sin(kx + n\\pi/2)$:\n$$\nu_0^{(p+1)}(x) = \\sum_{m=1}^{M} A_m k_m^{p+1} \\sin(k_m x + (p+1)\\frac{\\pi}{2})\n$$\nThe periodic nature of the domain is handled by evaluating the argument of $u_0^{(p+1)}$ modulo $L$.\n\n### Step 4: Algorithmic Implementation\n\nThe derived error formula is implemented to solve the computational part of the problem.\n1.  **Stencil Analysis**: For a given stencil $\\{(r_j, w_j)\\}$, the order $p$ and coefficient $\\alpha$ are found by systematically calculating the moments $C_k = \\frac{1}{k!} \\sum_j w_j r_j^k$ for $k=0, 1, 2, \\dots$ until the first $k > 1$ is found for which $C_k \\neq 0$. Then $p = k-1$ and $\\alpha = C_k$.\n2.  **Error Prediction**: The formula $e(x_f, T) \\approx -a \\alpha h^p T u_0^{(p+1)}((x_f - aT) \\pmod L)$ is used to calculate the pointwise error at a specific location $(x_f, T)$.\n3.  **Adaptive Mesh Refinement (AMR)**:\n    - An error indicator $I_i$ for each cell $i$ with center $x_i$ and width $h$ is defined as the absolute value of the predicted error, $I_i = |e(x_i, T)|$.\n    - Cells where $I_i > \\text{tol}$ are flagged for refinement. Each flagged cell is bisected, increasing the total cell count.\n    - The post-refinement global $L^\\infty$ error is predicted by taking the maximum of error estimates over all cells in the new mesh. For unrefined cells, the error is calculated using the original width $h$. For refined cells, the error is calculated at the centers of the two new child cells, using the refined width $h/2$. This reflects the expected error reduction on a finer grid.\n\nThis completes the theoretical derivation and outlines the plan for the numerical implementation.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the complete problem as specified, including derivation of stencil properties,\n    error prediction, adaptive mesh refinement, and post-refinement error estimation.\n    \"\"\"\n\n    def get_stencil_properties(stencil_r, stencil_w, max_k=15):\n        \"\"\"\n        Computes the order p and leading truncation error coefficient alpha for a given stencil.\n        \"\"\"\n        stencil_r = np.array(stencil_r, dtype=float)\n        stencil_w = np.array(stencil_w, dtype=float)\n        \n        for k in range(max_k + 1):\n            moment = np.sum(stencil_w * (stencil_r ** k))\n            \n            if k == 0:\n                if not np.isclose(moment, 0.0, atol=1e-12):\n                    raise ValueError(f\"Stencil fails C0=0 condition, C0={moment}\")\n            elif k == 1:\n                if not np.isclose(moment, 1.0, atol=1e-12):\n                    raise ValueError(f\"Stencil fails C1=1 condition, C1={moment}\")\n            else:  # k >= 2\n                if not np.isclose(moment, 0.0, atol=1e-12):\n                    p = k - 1\n                    alpha = moment / math.factorial(k)\n                    return p, alpha\n        raise ValueError(\"Could not determine stencil order within max_k.\")\n\n    def u0_derivative(x, n, A_k_pairs, L):\n        \"\"\"\n        Computes the n-th derivative of the initial condition u0 at points x.\n        x can be a scalar or a numpy array.\n        \"\"\"\n        x_mod = np.mod(x, L)\n        # Ensure x_mod is an array for broadcasting\n        x_arr = np.atleast_1d(x_mod)\n        \n        # Prepare A and k vectors for vectorized computation\n        A_vec = np.array([pair[0] for pair in A_k_pairs])\n        k_vec = np.array([pair[1] for pair in A_k_pairs])\n        \n        # Broadcasting: (M,) * (M,1) * sin((M,1) * (N,) + scalar) -> (M,N)\n        # M is number of sin terms, N is number of points in x\n        terms = (A_vec * (k_vec**n))[:, np.newaxis] * np.sin(k_vec[:, np.newaxis] * x_arr[np.newaxis, :] + n * np.pi / 2.0)\n        \n        # Sum over the M-axis to get a result of shape (N,)\n        val = np.sum(terms, axis=0)\n        \n        return val if val.size > 1 else val.item()\n\n    def predict_error(x, t, h, p, alpha, a, A_k_pairs, L):\n        \"\"\"\n        Predicts the leading-order pointwise discretization error using the derived formula.\n        \"\"\"\n        deriv_order = p + 1\n        x_start = x - a * t\n        u0_deriv_val = u0_derivative(x_start, deriv_order, A_k_pairs, L)\n        error = -a * alpha * (h**p) * t * u0_deriv_val\n        return error\n\n    test_cases = [\n        {\n            \"L\": 2 * np.pi, \"a\": 1.0, \"T\": 0.7,\n            \"A_k_pairs\": [(1.0, 1), (0.1, 8)],\n            \"stencil_r\": [-1, 1], \"stencil_w\": [-0.5, 0.5],\n            \"N0\": 64, \"tol\": 0.02, \"xf\": 1.0\n        },\n        {\n            \"L\": 2 * np.pi, \"a\": 1.0, \"T\": 0.5,\n            \"A_k_pairs\": [(1.0, 3)],\n            \"stencil_r\": [0, -1], \"stencil_w\": [1, -1],\n            \"N0\": 32, \"tol\": 0.3, \"xf\": 2.2\n        },\n        {\n            \"L\": 2 * np.pi, \"a\": 1.0, \"T\": 0.4,\n            \"A_k_pairs\": [(1.0, 5)],\n            \"stencil_r\": [-2, -1, 1, 2], \"stencil_w\": [1/12, -2/3, 2/3, -1/12],\n            \"N0\": 40, \"tol\": 0.01, \"xf\": 0.3\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L, a, T = case[\"L\"], case[\"a\"], case[\"T\"]\n        A_k_pairs = case[\"A_k_pairs\"]\n        stencil_r, stencil_w = case[\"stencil_r\"], case[\"stencil_w\"]\n        N0, tol, xf = case[\"N0\"], case[\"tol\"], case[\"xf\"]\n\n        # 1. Compute stencil properties\n        p, alpha = get_stencil_properties(stencil_r, stencil_w)\n        h0 = L / N0\n\n        # 2. Predict pointwise error at the probe location (before refinement)\n        probe_error = predict_error(xf, T, h0, p, alpha, a, A_k_pairs, L)\n\n        # 3. Perform one step of AMR\n        cell_indices = np.arange(N0)\n        x_centers = (cell_indices + 0.5) * h0\n        error_indicators = np.abs(predict_error(x_centers, T, h0, p, alpha, a, A_k_pairs, L))\n\n        refined_mask = error_indicators > tol\n        num_refined = np.sum(refined_mask)\n        N_new = N0 + num_refined\n        \n        # 4. Compute post-refinement predicted global L-infinity error\n        post_errors_max = []\n        \n        # Unrefined cells\n        unrefined_mask = ~refined_mask\n        if np.any(unrefined_mask):\n            unrefined_centers = x_centers[unrefined_mask]\n            errs_unrefined = np.abs(predict_error(unrefined_centers, T, h0, p, alpha, a, A_k_pairs, L))\n            post_errors_max.append(np.max(errs_unrefined))\n\n        # Refined cells\n        if np.any(refined_mask):\n            refined_indices = cell_indices[refined_mask]\n            h1 = h0 / 2.0\n            \n            child1_centers = (refined_indices + 0.25) * h0\n            child2_centers = (refined_indices + 0.75) * h0\n            \n            errs_child1 = np.abs(predict_error(child1_centers, T, h1, p, alpha, a, A_k_pairs, L))\n            errs_child2 = np.abs(predict_error(child2_centers, T, h1, p, alpha, a, A_k_pairs, L))\n            \n            post_errors_max.append(np.max(errs_child1))\n            post_errors_max.append(np.max(errs_child2))\n\n        L_inf_post = max(post_errors_max) if post_errors_max else 0.0\n\n        results.extend([probe_error, N_new, L_inf_post])\n\n    # Format the final output string\n    formatted_results = []\n    for i, res in enumerate(results):\n        if i % 3 == 1:  # N_new is an integer\n            formatted_results.append(str(res))\n        else:  # probe_error and L_inf_post are floats\n            formatted_results.append(f\"{res:.8f}\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}