{
    "hands_on_practices": [
        {
            "introduction": "MMS 的一个主要应用是严格验证数值代码中的时间积分方案是否达到了其设计的收敛阶。本练习通过为人为设定的平流扩散方程构造一个解析解，来分离出时间离散误差。通过关注时间步进方法本身的残差，我们可以精确地衡量其性能，并确认其实现的正确性 。",
            "id": "3376840",
            "problem": "考虑周期性区域 $x \\in [0, 2\\pi]$ 上的一维线性平流-扩散方程，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = -a \\frac{\\partial u}{\\partial x}(x,t) + \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t) + s(x,t),\n$$\n其中 $a$ 和 $\\nu$ 是常系数，$s(x,t)$ 是一个待定的源项。通过指定精确解\n$$\nu(x,t) = \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x),\n$$\n使用制造解方法（MMS）推导出一个一致的源项，其中 $\\alpha$ 和 $\\beta$ 是实常数，$k$ 是一个正整数。三角函数中的所有角度都必须以弧度为单位。您可以假设解足够光滑，以支持所有进行的操作。\n\n任务 1. 从偏导数的基本定义和给定的精确解出发，推导源项 $s(x,t)$，使得 $u(x,t)$ 是该平流-扩散方程的一个精确解。推导必须从计算时间导数 $\\frac{\\partial u}{\\partial t}$、一阶空间导数 $\\frac{\\partial u}{\\partial x}$ 和二阶空间导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 开始，然后将它们代入控制方程以分离出 $s(x,t)$。\n\n任务 2. 定义一个 Runge–Kutta 时间积分器的单步离散时间残差（也称为局部误差），方法是将精确制造解沿其内部级横坐标代入。对于从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个时间步，沿精确轨迹应用的 Runge–Kutta 更新为\n$$\nu^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i\\,F\\!\\left(x,t_n + c_i \\Delta t\\right),\n$$\n其中 $m$ 是级数，$b_i$ 和 $c_i$ 是方法的权重和横坐标，$F(x,t)$ 表示在精确制造解上求值的偏微分方程右端项。由于源项是通过 MMS 选择以强制该解成立，因此对于制造解，有 $F(x,t) = \\frac{\\partial u}{\\partial t}(x,t)$。定义单步残差范数\n$$\n\\mathcal{R}(\\Delta t) = \\left\\| u^{\\text{RK}}(x) - u\\!\\left(x,t_n + \\Delta t\\right) \\right\\|_{L^2([0,2\\pi])},\n$$\n其中 $L^2$ 范数计算为周期域上逐点差平方的空间平均值的平方根。\n\n任务 3. 使用上述残差定义，通过它们的权重 $b_i$ 和横坐标 $c_i$ 实现以下显式 Runge–Kutta 方法，并评估从 $t_n=0$ 开始的单个时间步的残差：\n- 前向 Euler 法（单级）：$m=1$，$b_1 = 1$，$c_1 = 0$。\n- 显式中点法（二级，二阶）：$m=1$，$b_1 = 1$，$c_1 = \\tfrac{1}{2}$，解释为时间步上 $\\frac{\\partial u}{\\partial t}$ 的单点中点求积。\n- 经典的四阶 Runge–Kutta 法（四级）：$m=4$，$(c_1,c_2,c_3,c_4) = (0, \\tfrac{1}{2}, \\tfrac{1}{2}, 1)$ 且 $(b_1,b_2,b_3,b_4) = \\left(\\tfrac{1}{6}, \\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{6}\\right)$。\n\n任务 4. 对于每种方法和一系列时间步 $\\Delta t_1 > \\Delta t_2 > \\Delta t_3$，根据残差计算经验精度阶\n$$\np_{\\text{est}} = \\frac{\\log\\left(\\mathcal{R}(\\Delta t_1) / \\mathcal{R}(\\Delta t_2)\\right)}{\\log\\left(\\Delta t_1 / \\Delta t_2\\right)}.\n$$\n对时间步对 $\\left(\\Delta t_2, \\Delta t_3\\right)$ 重复此计算。\n\n任务 5. 通过设置 $\\alpha = 0$ 并选择 $\\beta$ 和 $\\Delta t$ 以满足 $\\beta \\Delta t = \\pi$，研究振荡制造动力学中的类超收敛抵消现象。在这种情况下，对于时间因子而言，$u$ 在一个时间步内的精确变化量为零，某些求积法可能会显示出增强的抵消效果。对于经典的四阶 Runge–Kutta 方法，计算时间步对 $\\left(\\Delta t_1,\\Delta t_2\\right)$ 和 $\\left(\\Delta t_2,\\Delta t_3\\right)$ 的经验阶 $p_{\\text{est}}$（其中 $\\Delta t_2$ 满足 $\\beta \\Delta t_2 = \\pi$），并返回一个布尔标志，指示每个经验阶是否超过方法的名义阶加 $0.5$。\n\n实现细节和单位：\n- 使用在 $[0,2\\pi]$ 上均匀分布的 $N$ 个点的周期性空间网格，将 $L^2$ 范数数值近似为网格点上均方差的平方根。\n- 所有三角函数角度必须以弧度解释。\n- 除了为三角函数求值指定角度单位外，不需要其他物理量纲单位。\n\n测试套件。您的程序必须为以下三个参数集实现计算，每个参数集如上所述产生两个经验阶或布尔标志：\n\n1. 一般动力学，四阶方法（顺利路径）：\n   - 参数：$a = 1.0$，$\\nu = 0.05$，$\\alpha = 0.1$，$\\beta = 2.0$，$k = 2$，$N = 256$。\n   - 方法：经典的四阶 Runge–Kutta 法。\n   - 时间步：$\\Delta t_1 = 0.2$，$\\Delta t_2 = 0.1$，$\\Delta t_3 = 0.05$。\n   - 输出：两个浮点数，为 $\\left(\\Delta t_1,\\Delta t_2\\right)$ 和 $\\left(\\Delta t_2,\\Delta t_3\\right)$ 计算的经验阶。\n\n2. 时间主导的制造动力学，二阶方法（强调纯时间变化的边缘情况）：\n   - 参数：$a = 0.0$，$\\nu = 0.0$，$\\alpha = 0.2$，$\\beta = 1.5$，$k = 3$，$N = 256$。\n   - 方法：显式中点法。\n   - 时间步：$\\Delta t_1 = 0.3$，$\\Delta t_2 = 0.15$，$\\Delta t_3 = 0.075$。\n   - 输出：两个浮点数，为 $\\left(\\Delta t_1,\\Delta t_2\\right)$ 和 $\\left(\\Delta t_2,\\Delta t_3\\right)$ 计算的经验阶。\n\n3. 振荡类超收敛抵消，四阶方法：\n   - 参数：$a = 0.5$，$\\nu = 0.01$，$\\alpha = 0.0$，$\\beta = 4\\pi$，$k = 4$，$N = 256$。\n   - 方法：经典的四阶 Runge–Kutta 法。\n   - 时间步：$\\Delta t_1 = 0.5$，$\\Delta t_2 = 0.25$，$\\Delta t_3 = 0.125$，使得 $\\beta \\Delta t_2 = \\pi$。\n   - 输出：两个布尔值，指示 $\\left(\\Delta t_1,\\Delta t_2\\right)$ 和 $\\left(\\Delta t_2,\\Delta t_3\\right)$ 的经验阶是否超过 $4.5$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序如下\n$$\n\\left[ p^{(1)}_{12},\\, p^{(1)}_{23},\\, p^{(2)}_{12},\\, p^{(2)}_{23},\\, \\text{flag}^{(3)}_{12},\\, \\text{flag}^{(3)}_{23} \\right],\n$$\n其中上标表示测试用例编号，下标表示使用的时间步对。每个 $p$ 必须是浮点数，每个标志必须是布尔值。",
            "solution": "该问题根据指定标准进行验证。\n\n### 步骤 1：提取已知条件\n- **控制方程**：周期性区域 $x \\in [0, 2\\pi]$ 上的一维线性平流-扩散方程为\n$$ \\frac{\\partial u}{\\partial t}(x,t) = -a \\frac{\\partial u}{\\partial x}(x,t) + \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t) + s(x,t) $$\n其中 $a$ 和 $\\nu$ 是常系数，$s(x,t)$ 是一个源项。\n- **制造解**：指定的精确解为\n$$ u(x,t) = \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x) $$\n其中 $\\alpha$、$\\beta$ 是实常数，$k$ 是一个正整数。\n- **任务 1**：通过将制造解代入控制方程来推导源项 $s(x,t)$。\n- **任务 2**：定义一个 Runge–Kutta (RK) 积分器的单步离散时间残差。RK 更新为：\n$$ u^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i\\,F\\!\\left(x,t_n + c_i \\Delta t\\right) $$\n其中 $F(x,t) = \\frac{\\partial u}{\\partial t}(x,t)$ 沿精确解轨迹。残差范数定义为：\n$$ \\mathcal{R}(\\Delta t) = \\left\\| u^{\\text{RK}}(x) - u\\!\\left(x,t_n + \\Delta t\\right) \\right\\|_{L^2([0,2\\pi])} $$\n$L^2$ 范数应近似为逐点差平方的空间平均值的平方根。\n- **任务 3**：为从 $t_n = 0$ 开始的三种显式 RK 方法实现并评估残差：\n    - 前向 Euler 法：$m=1$，$b_1 = 1$，$c_1 = 0$。\n    - 显式中点法：$m=1$，$b_1 = 1$，$c_1 = \\tfrac{1}{2}$（解释为单点求积）。\n    - 经典 Runge–Kutta (RK4)：$m=4$，$(c_1,c_2,c_3,c_4) = (0, \\tfrac{1}{2}, \\tfrac{1}{2}, 1)$，$(b_1,b_2,b_3,b_4) = \\left(\\tfrac{1}{6}, \\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{6}\\right)$。\n- **任务 4**：计算经验精度阶：\n$$ p_{\\text{est}} = \\frac{\\log\\left(\\mathcal{R}(\\Delta t_1) / \\mathcal{R}(\\Delta t_2)\\right)}{\\log\\left(\\Delta t_1 / \\Delta t_2\\right)} $$\n- **任务 5**：研究当 $\\alpha = 0$ 且 $\\beta \\Delta t = \\pi$ 时，RK4 方法的超收敛性。\n- **实现细节**：使用在 $[0, 2\\pi]$ 上的 $N$ 个点的周期性空间网格。角度以弧度为单位。\n- **测试套件**：提供了三个特定的测试用例，包含所有必要的参数（$\\alpha, \\beta, k, a, \\nu, N$）、时间步（$\\Delta t_1, \\Delta t_2, \\Delta t_3$）和目标输出（经验阶或布尔标志）。\n\n### 步骤 2：使用提取的已知条件进行验证\n对问题陈述进行严格审查：\n- **科学基础**：该问题基于计算流体动力学和数值分析领域。控制方程是基础的偏微分方程，制造解方法（MMS）是代码验证的标准技术。Runge-Kutta 方法和精度阶的概念是常微分/偏微分方程数值分析的支柱。超收敛性的研究是数值分析中一个有效且具体的主题。所有组成部分在科学上都是合理的。\n- **适定性**：该问题是适定的。任务定义清晰，所有必要的数据、参数和公式均已提供。显式中点法的定义虽然陈述紧凑，但通过其作为单点求积规则的解释得以澄清，消除了歧义。该问题结构导致每个测试用例都有唯一且有意义的数值结果。\n- **客观性**：该问题以精确、客观的数学语言陈述。没有主观或基于意见的主张。\n- **完整性和一致性**：该问题是自洽的。解决问题所需的所有常数、方程和条件都已提供。没有内部矛盾。例如，关键的简化 $F(x,t) = \\frac{\\partial u}{\\partial t}(x,t)$ 在 MMS 的背景下被明确陈述和证明，确保了计算时间积分误差的一致框架。\n- **无其他缺陷**：该问题并非微不足道、不切实际或无法形式化。它代表了验证数值方案时间精度的标准、严谨的练习。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。将提供一个完整、合理的解决方案。\n\n### 解题推导\n\n该解法需要实现问题陈述中描述的逻辑。任务的核心是计算 Runge-Kutta 方法应用于已知解轨迹时的时间误差。\n\n**任务 1：源项的推导**\n\n源项 $s(x,t)$ 是通过强制 $u(x,t) = \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x)$ 成为控制平流-扩散方程的解来推导的。这需要重新整理方程以求解 $s(x,t)$：\n$$ s(x,t) = \\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} - \\nu \\frac{\\partial^2 u}{\\partial x^2} $$\n我们计算 $u(x,t)$ 的必要偏导数。\n\n首先，使用乘法法则对时间部分 $T(t) = \\exp(\\alpha t)\\sin(\\beta t)$ 求时间导数 $\\frac{\\partial u}{\\partial t}$：\n$$ \\frac{d T}{d t} = \\frac{d}{dt} \\left( \\exp(\\alpha t)\\sin(\\beta t) \\right) = \\alpha \\exp(\\alpha t)\\sin(\\beta t) + \\beta \\exp(\\alpha t)\\cos(\\beta t) = \\exp(\\alpha t) \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) $$\n因此，\n$$ \\frac{\\partial u}{\\partial t} = \\exp(\\alpha t) \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) \\sin(k x) $$\n接下来，是空间导数：\n$$ \\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x) \\right) = \\exp(\\alpha t)\\,\\sin(\\beta t) \\left( k \\cos(k x) \\right) $$\n$$ \\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial}{\\partial x} \\left( k \\exp(\\alpha t)\\,\\sin(\\beta t) \\cos(k x) \\right) = k \\exp(\\alpha t)\\,\\sin(\\beta t) \\left( -k \\sin(k x) \\right) = -k^2 u(x,t) $$\n将这些表达式代回 $s(x,t)$ 的方程中：\n$$ s(x,t) = \\left[ \\exp(\\alpha t) \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) \\sin(k x) \\right] + a \\left[ k \\exp(\\alpha t)\\sin(\\beta t) \\cos(k x) \\right] - \\nu \\left[ -k^2 \\exp(\\alpha t)\\sin(\\beta t)\\sin(k x) \\right] $$\n提出公因子，我们得到源项的最终表达式：\n$$ s(x,t) = \\exp(\\alpha t) \\left[ \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) \\sin(k x) + a k \\sin(\\beta t) \\cos(k x) + \\nu k^2 \\sin(\\beta t) \\sin(k x) \\right] $$\n根据构造，该源项确保了给定的 $u(x,t)$ 是 PDE 的一个精确解。请注意，对于问题的其余部分，并不直接使用 $s(x,t)$ 的这个表达式。相反，我们使用的性质是，当在精确解上求值时，完整的右端项简化为其时间导数。\n\n**任务 2 和 3：Runge-Kutta 方法的残差计算**\n\n问题的核心是计算单步残差，它衡量了时间积分器的局部截断误差。沿精确解的更新的一般形式是：\n$$ u^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i\\,F(x,t_n + c_i \\Delta t) $$\n根据问题陈述中为时间积分器进行的 MMS 验证所建立的规则，右端项函数 $F(x,t)$ 在精确解路径上求值，这简化为精确的时间导数：\n$$ F(x, t) = -a \\frac{\\partial u}{\\partial x}(x,t) + \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t) + s(x,t) = \\frac{\\partial u}{\\partial t}(x,t) $$\n因此，RK 更新是作为已知函数 $\\frac{\\partial u}{\\partial t}$ 在时间步 $[t_n, t_{n+1}]$ 上的积分来计算的：\n$$ u^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i \\frac{\\partial u}{\\partial t}(x,t_n + c_i \\Delta t) $$\n残差范数是此数值近似与步末精确解 $u(x, t_{n+1})$ 之间差值的离散 $L^2$ 范数：\n$$ \\mathcal{R}(\\Delta t) = \\sqrt{ \\frac{1}{N} \\sum_{j=1}^{N} \\left( u^{\\text{RK}}(x_j) - u(x_j, t_n + \\Delta t) \\right)^2 } $$\n其中空间网格为 $x_j = (j-1) \\frac{2\\pi}{N}$，对于 $j=1, \\dots, N$。计算从 $t_n = 0$ 开始。\n\n$t_n=0$ 时，所需方法的具体更新如下：\n- **前向 Euler 法**：$m=1, b_1=1, c_1=0$。\n$$ u^{\\text{FE}}(x) = u(x,0) + \\Delta t \\, \\frac{\\partial u}{\\partial t}(x,0) $$\n- **显式中点法**：$m=1, b_1=1, c_1=1/2$。\n$$ u^{\\text{Midpoint}}(x) = u(x,0) + \\Delta t \\, \\frac{\\partial u}{\\partial t}(x, \\Delta t/2) $$\n这对应于使用单点中点求积规则来近似 $\\int_{0}^{\\Delta t} (\\frac{\\partial u}{\\partial t}) dt$。\n- **经典 RK4**：$m=4, b=(\\frac{1}{6}, \\frac{1}{3}, \\frac{1}{3}, \\frac{1}{6}), c=(0, \\frac{1}{2}, \\frac{1}{2}, 1)$。\n$$ u^{\\text{RK4}}(x) = u(x,0) + \\Delta t \\left[ \\frac{1}{6}\\frac{\\partial u}{\\partial t}(x,0) + \\frac{1}{3}\\frac{\\partial u}{\\partial t}(x,\\Delta t/2) + \\frac{1}{3}\\frac{\\partial u}{\\partial t}(x,\\Delta t/2) + \\frac{1}{6}\\frac{\\partial u}{\\partial t}(x,\\Delta t) \\right] $$\n这对应于使用 Simpson 法则进行积分。\n\n**任务 4 和 5：经验阶和超收敛**\n\n经验精度阶 $p_{\\text{est}}$ 是使用来自两个不同时间步 $\\Delta t_1$ 和 $\\Delta t_2$ 的残差计算的：\n$$ p_{\\text{est}} = \\frac{\\log(\\mathcal{R}(\\Delta t_1) / \\mathcal{R}(\\Delta t_2))}{\\log(\\Delta t_1 / \\Delta t_2)} $$\n对于最后一个测试用例，研究了一种特殊情况。当 $\\alpha=0$ 时，解在时间上变为纯振荡的：$u(x,t) = \\sin(\\beta t)\\sin(k x)$。如果我们选择 $\\Delta t$ 使得 $\\beta \\Delta t = \\pi$，会发生有趣的抵消现象。对于 $t_n=0$ 和 $\\Delta t_{special} = \\pi/\\beta$：\n- 在 $t_n=0$ 时的精确解是 $u(x,0) = \\sin(0)\\sin(kx) = 0$。\n- 在 $t_n+\\Delta t_{special}$ 时的精确解是 $u(x,\\pi/\\beta) = \\sin(\\beta \\cdot \\pi/\\beta)\\sin(kx) = \\sin(\\pi)\\sin(kx) = 0$。\n时间导数为 $\\frac{\\partial u}{\\partial t} = \\beta\\cos(\\beta t)\\sin(kx)$。RK4 更新涉及在 $t=0, \\Delta t/2, \\Delta t$ 处的采样。\n- 在 $t=0$ 时，$\\frac{\\partial u}{\\partial t} = \\beta\\cos(0)\\sin(kx)=\\beta\\sin(kx)$。\n- 在 $t=\\Delta t_{special}/2=\\pi/(2\\beta)$ 时，$\\frac{\\partial u}{\\partial t} = \\beta\\cos(\\pi/2)\\sin(kx)=0$。\n- 在 $t=\\Delta t_{special}=\\pi/\\beta$ 时，$\\frac{\\partial u}{\\partial t} = \\beta\\cos(\\pi)\\sin(kx)=-\\beta\\sin(kx)$。\nRK4 增量与 $\\frac{1}{6}(\\beta\\sin(kx)) + \\frac{2}{3}(0) + \\frac{1}{6}(-\\beta\\sin(kx)) = 0$ 成正比。\n因此，对于这个特定的时间步，从零开始，精确解和 RK4 近似在步末都为零。残差 $\\mathcal{R}(\\Delta t_{special})$ 精确为零（在机器精度内）。这导致包含 $\\Delta t_{special}$ 的时间步对计算出的阶数为“无穷大”，表明了超收敛。实现时必须处理残差为零的情况，以避免像 $\\log(0)$ 这样的数值错误。\n\n以下程序为三个指定的测试用例实现了这些计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    # Dictionary defining the Butcher tableau coefficients for the RK methods.\n    # The structure is method_name: {'b': weights, 'c': abscissae}.\n    RK_METHODS = {\n        \"fe\": {\"b\": np.array([1.0]), \"c\": np.array([0.0])},\n        \"midpoint\": {\"b\": np.array([1.0]), \"c\": np.array([0.5])},\n        \"rk4\": {\n            \"b\": np.array([1/6, 1/3, 1/3, 1/6]),\n            \"c\": np.array([0.0, 0.5, 0.5, 1.0]),\n        },\n    }\n\n    # Test suite parameters. Each tuple contains:\n    # (a, nu, alpha, beta, k, N, method_key, [dt1, dt2, dt3], task_type)\n    test_cases = [\n        (1.0, 0.05, 0.1, 2.0, 2, 256, \"rk4\", [0.2, 0.1, 0.05], \"order\"),\n        (0.0, 0.0, 0.2, 1.5, 3, 256, \"midpoint\", [0.3, 0.15, 0.075], \"order\"),\n        (0.5, 0.01, 0.0, 4 * np.pi, 4, 256, \"rk4\", [0.5, 0.25, 0.125], \"super\"),\n    ]\n\n    final_results = []\n\n    for params in test_cases:\n        a_p, nu_p, alpha, beta, k, N, method_key, dts, task_type = params\n        \n        # Spatial grid (uniform on periodic domain [0, 2*pi])\n        x = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n        # Define the manufactured solution u(x,t) and its time derivative du/dt\n        # Note: These are vectorized to operate on the grid 'x'.\n        u_func = lambda t_val: np.exp(alpha * t_val) * np.sin(beta * t_val) * np.sin(k * x)\n        dudt_func = lambda t_val: np.exp(alpha * t_val) * (\n            alpha * np.sin(beta * t_val) + beta * np.cos(beta * t_val)\n        ) * np.sin(k * x)\n\n        residuals = []\n        for dt in dts:\n            # Get RK method coefficients\n            b = RK_METHODS[method_key][\"b\"]\n            c = RK_METHODS[method_key][\"c\"]\n\n            # Exact solution at t_n=0 and t_{n+1}=dt\n            u_exact_tn = u_func(0)\n            u_exact_tn1 = u_func(dt)\n            \n            # Calculate the Runge-Kutta update\n            # u^RK = u(t_n) + dt * sum(b_i * F(t_n + c_i*dt))\n            # where F = du/dt on the exact trajectory\n            rk_sum_term = np.zeros_like(x)\n            for i in range(len(b)):\n                t_stage = 0 + c[i] * dt  # t_n = 0\n                rk_sum_term += b[i] * dudt_func(t_stage)\n            \n            u_rk = u_exact_tn + dt * rk_sum_term\n            \n            # Calculate the L2 norm of the residual\n            # R = ||u^RK - u(t_{n+1})||_L2\n            error_sq = (u_rk - u_exact_tn1)**2\n            l2_norm = np.sqrt(np.mean(error_sq))\n            residuals.append(l2_norm)\n\n        # Unpack time steps and residuals\n        dt1, dt2, dt3 = dts\n        res1, res2, res3 = residuals\n\n        # Calculate empirical order p_est = log(R1/R2) / log(dt1/dt2)\n        # Handle cases where residual is zero (perfect cancellation)\n        if res2 == 0:\n            p_12 = np.inf\n        else:\n            p_12 = np.log(res1 / res2) / np.log(dt1 / dt2)\n\n        if res3 == 0:\n            p_23 = np.inf  # This case is not expected here\n        elif res2 == 0:\n            p_23 = -np.inf\n        else:\n            p_23 = np.log(res2 / res3) / np.log(dt2 / dt3)\n\n        if task_type == \"order\":\n            final_results.extend([p_12, p_23])\n        elif task_type == \"super\":\n            # Nominal order for RK4 is 4. Superconvergence threshold is 4.5\n            nominal_order = 4.0\n            super_threshold = 0.5\n            is_super_12 = p_12 > (nominal_order + super_threshold)\n            is_super_23 = p_23 > (nominal_order + super_threshold)\n            final_results.extend([is_super_12, is_super_23])\n            \n    # Format and print the final output string exactly as required\n    # Booleans are converted to lowercase strings 'true'/'false'\n    formatted_results = []\n    for item in final_results:\n        if isinstance(item, bool) or isinstance(item, np.bool_):\n            formatted_results.append(str(item).lower())\n        else:\n            formatted_results.append(str(item))\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了验证核心离散格式，MMS 也是一个用于测试边界条件实现的宝贵工具，因为边界条件是细微错误的常见来源。本练习聚焦于稳态斯托克斯流（Stokes flow），并演示了如何制造一个解来推导区域边界上的精确曳力。这使得我们能够精确验证诺伊曼（Neumann）或罗宾（Robin）边界条件的实现，确保代码正确处理物理应力条件 。",
            "id": "3376865",
            "problem": "考虑由斯托克斯方程控制的牛顿流体的定常、不可压缩粘性流动，该方程是纳维-斯托克斯方程的低雷诺数极限。其基本原理是线动量守恒和质量守恒。对于动力粘度为 $\\mu$ 的牛顿流体，线动量守恒定律指出，压力梯度、粘性应力和体积力 $\\mathbf{f}$ 之间的平衡由以下偏微分方程给出\n$$\n-\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} = \\mathbf{0},\n$$\n对于不可压缩流体，质量守恒定律给出\n$$\n\\nabla \\cdot \\mathbf{u} = 0.\n$$\n牛顿流体的柯西应力张量为\n$$\n\\boldsymbol{\\sigma} = -p \\mathbf{I} + \\mu\\left(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top\\right),\n$$\n作用在具有外单位法向 $\\mathbf{n}$ 的边界上的牵引力矢量定义为\n$$\n\\mathbf{t} = \\boldsymbol{\\sigma} \\cdot \\mathbf{n}.\n$$\n在制造解方法 (MMS) 中，人们预先指定一个光滑的无散速度场 $\\mathbf{u}$ 和一个压力场 $p$，计算出使这些场精确满足控制方程的相应体积力 $\\mathbf{f}$，然后推导解析边界数据（例如，牵引力）以验证诺伊曼或罗宾边界条件的实现。罗宾边界条件以混合形式给出\n$$\n\\alpha \\,\\mathbf{u} + \\beta \\,\\mathbf{t} = \\mathbf{g},\n$$\n其中 $\\alpha$ 和 $\\beta$ 是给定系数，$\\mathbf{g}$ 是应施加的目标边界函数；当 $\\beta = 0$ 或 $\\alpha = 0$ 时，此条件分别推广为狄利克雷和诺伊曼类型。\n\n设域为单位正方形 $\\Omega = [0,1]\\times[0,1]$。制造以下光滑无散速度场和压力场：\n$$\n\\mathbf{u}(x,y) = \\begin{bmatrix}\n\\sin(\\pi x)\\,\\sin(\\pi y) \\\\\n\\cos(\\pi x)\\,\\cos(\\pi y)\n\\end{bmatrix}, \\qquad\np(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y).\n$$\n仅以上述控制方程和定义为基本依据，推导所需体积力 $\\mathbf{f}(x,y)$ 和边界 $\\partial\\Omega$ 各部分上牵引力矢量 $\\mathbf{t}(x,y)$ 的表达式，其中 $x=0$ 处的外单位法向为 $\\mathbf{n} = (-1,0)$，$x=1$ 处为 $\\mathbf{n} = (1,0)$，$y=0$ 处为 $\\mathbf{n} = (0,-1)$，$y=1$ 处为 $\\mathbf{n} = (0,1)$。然后，使用 $\\mathbf{g} = \\alpha \\mathbf{u} + \\beta \\mathbf{t}$，为给定的系数 $\\alpha$ 和 $\\beta$ 推导制造的罗宾目标 $\\mathbf{g}(x,y)$。\n\n您的程序必须精确实现这些推导出的表达式，并对以下测试套件进行评估。所有答案必须以要求的单位表示，并且您的程序报告的数值必须符合指定的格式。单位：速度分量 $\\mathbf{u}$ 以米/秒 (m/s) 为单位，压力 $p$ 以帕斯卡 (Pa) 为单位，粘度 $\\mu$ 以帕斯卡-秒 (Pa·s) 为单位，牵引力分量 $\\mathbf{t}$ 以帕斯卡 (Pa) 为单位，体积力分量 $\\mathbf{f}$ 以牛顿/立方米 (N/m$^3$) 为单位。不使用角度，因此不需要角度单位。\n\n测试套件规范：\n- 边界测试 1 (左边界)：粘度 $\\mu = 0.7$ Pa·s，系数 $\\alpha = 3.0$ Pa·s/m，$\\beta = 0.5$ (无量纲)，位置 $(x,y) = (0,0.6)$，外单位法向 $\\mathbf{n} = (-1,0)$。计算牵引力分量 $\\mathbf{t}(x,y)$ 和罗宾目标 $\\mathbf{g}(x,y)$。\n- 边界测试 2 (上边界)：粘度 $\\mu = 1.0$ Pa·s，系数 $\\alpha = 2.0$ Pa·s/m，$\\beta = 1.0$ (无量纲)，位置 $(x,y) = (0.3,1)$，外单位法向 $\\mathbf{n} = (0,1)$。计算牵引力分量 $\\mathbf{t}(x,y)$ 和罗宾目标 $\\mathbf{g}(x,y)$。\n- 边界测试 3 (右边界)：粘度 $\\mu = 2.5$ Pa·s，系数 $\\alpha = 0.0$ Pa·s/m，$\\beta = 1.0$ (无量纲)，位置 $(x,y) = (1,0.25)$，外单位法向 $\\mathbf{n} = (1,0)$。计算牵引力分量 $\\mathbf{t}(x,y)$ 和罗宾目标 $\\mathbf{g}(x,y)$。\n- 内部测试 4：粘度 $\\mu = 0.7$ Pa·s，位置 $(x,y) = (0.1,0.9)$。计算体积力分量 $\\mathbf{f}(x,y)$ 和残差向量 $\\mathbf{r}(x,y) = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f}$ 的欧几里得范数，对于正确的制造解，该值应为 $0$。\n- 内部测试 5：粘度 $\\mu = 1.8$ Pa·s，位置 $(x,y) = (0.75,0.35)$。计算体积力分量 $\\mathbf{f}(x,y)$ 和 $\\mathbf{r}(x,y)$ 的欧几里得范数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试的结果本身就是一个列表：\n- 对于每个边界测试，输出列表 $[\\;t_x,\\;t_y,\\;g_x,\\;g_y\\;]$，其中所有分量均为浮点数，$t_x,t_y$ 的单位为帕斯卡，$g_x,g_y$ 的单位也为帕斯卡。\n- 对于每个内部测试，输出列表 $[\\;f_x,\\;f_y,\\;\\|\\mathbf{r}\\|\\;]$，其中 $f_x,f_y$ 的单位为牛顿/立方米，$\\|\\mathbf{r}\\|$ 为一个浮点数。\n\n例如，最终输出格式必须是\n$$\n[\\,[\\text{case1\\_values}],\\,[\\text{case2\\_values}],\\,[\\text{case3\\_values}],\\,[\\text{case4\\_values}],\\,[\\text{case5\\_values}]\\,],\n$$\n不含任何附加文本。",
            "solution": "该问题被评估为有效。它在斯托克斯方程的制造解方法 (MMS) 标准框架内，提出了一个适定的、具有科学依据的任务。所有必要的定义、方程和数据都已提供，并且内部一致。制造的速度场被证实是无散的，这是一个关键的自洽性检查。\n\n求解过程首先推导体积力 $\\mathbf{f}$、牵引力矢量 $\\mathbf{t}$ 和罗宾边界目标 $\\mathbf{g}$ 的解析表达式。然后实现这些表达式，以计算指定测试用例所需的值。\n\n### 步骤 1：不可压缩性验证\n制造的速度场由下式给出\n$$\n\\mathbf{u}(x,y) = \\begin{bmatrix} u(x,y) \\\\ v(x,y) \\end{bmatrix} = \\begin{bmatrix} \\sin(\\pi x)\\,\\sin(\\pi y) \\\\ \\cos(\\pi x)\\,\\cos(\\pi y) \\end{bmatrix}.\n$$\n对于不可压缩流体，$\\mathbf{u}$ 的散度必须为零：$\\nabla \\cdot \\mathbf{u} = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} = 0$。\n偏导数是：\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} (\\sin(\\pi x)\\,\\sin(\\pi y)) = \\pi \\cos(\\pi x)\\,\\sin(\\pi y)\n$$\n$$\n\\frac{\\partial v}{\\partial y} = \\frac{\\partial}{\\partial y} (\\cos(\\pi x)\\,\\cos(\\pi y)) = -\\pi \\cos(\\pi x)\\,\\sin(\\pi y)\n$$\n因此，散度为\n$$\n\\nabla \\cdot \\mathbf{u} = \\pi \\cos(\\pi x)\\,\\sin(\\pi y) - \\pi \\cos(\\pi x)\\,\\sin(\\pi y) = 0.\n$$\n该速度场确实是无散的，从而验证了问题的一个关键前提。\n\n### 步骤 2：制造体积力 $\\mathbf{f}$ 的推导\n体积力 $\\mathbf{f}$ 是通过重新排列斯托克斯动量方程确定的：$\\mathbf{f} = \\nabla p - \\mu \\nabla^2 \\mathbf{u}$。\n\n首先，我们计算 $p(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y)$ 的压力梯度 $\\nabla p$：\n$$\n\\nabla p = \\begin{bmatrix} \\frac{\\partial p}{\\partial x} \\\\ \\frac{\\partial p}{\\partial y} \\end{bmatrix} = \\begin{bmatrix} \\pi \\cos(\\pi x)\\,\\cos(\\pi y) \\\\ -\\pi \\sin(\\pi x)\\,\\sin(\\pi y) \\end{bmatrix}.\n$$\n\n接下来，我们计算速度场的拉普拉斯算子，$\\nabla^2 \\mathbf{u} = \\begin{bmatrix} \\nabla^2 u \\\\ \\nabla^2 v \\end{bmatrix}$。\n对于 x 分量 $u(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$：\n$$\n\\frac{\\partial^2 u}{\\partial x^2} = -\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y), \\qquad \\frac{\\partial^2 u}{\\partial y^2} = -\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y)\n$$\n$$\n\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = -2\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y) = -2\\pi^2 u.\n$$\n对于 y 分量 $v(x,y) = \\cos(\\pi x)\\,\\cos(\\pi y)$：\n$$\n\\frac{\\partial^2 v}{\\partial x^2} = -\\pi^2 \\cos(\\pi x)\\,\\cos(\\pi y), \\qquad \\frac{\\partial^2 v}{\\partial y^2} = -\\pi^2 \\cos(\\pi x)\\,\\cos(\\pi y)\n$$\n$$\n\\nabla^2 v = \\frac{\\partial^2 v}{\\partial x^2} + \\frac{\\partial^2 v}{\\partial y^2} = -2\\pi^2 \\cos(\\pi x)\\,\\cos(\\pi y) = -2\\pi^2 v.\n$$\n所以，矢量拉普拉斯算子是 $\\nabla^2 \\mathbf{u} = -2\\pi^2 \\mathbf{u}$。\n\n结合这些项，体积力 $\\mathbf{f} = [f_x, f_y]^\\top$ 为：\n$$\n\\mathbf{f} = \\nabla p - \\mu(-2\\pi^2 \\mathbf{u}) = \\nabla p + 2\\mu\\pi^2 \\mathbf{u}\n$$\n$$\nf_x(x,y) = \\pi \\cos(\\pi x)\\,\\cos(\\pi y) + 2\\mu\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y)\n$$\n$$\nf_y(x,y) = -\\pi \\sin(\\pi x)\\,\\sin(\\pi y) + 2\\mu\\pi^2 \\cos(\\pi x)\\,\\cos(\\pi y)\n$$\n通过这种构造，残差 $\\mathbf{r} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f}$ 恒等于零，因此其范数 $\\|\\mathbf{r}\\|$ 为 $0$。\n\n### 步骤 3：牵引力矢量 $\\mathbf{t}$ 的推导\n牵引力矢量为 $\\mathbf{t} = \\boldsymbol{\\sigma} \\cdot \\mathbf{n}$，其中 $\\boldsymbol{\\sigma} = -p \\mathbf{I} + \\mu(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top)$。\n\n首先，我们求出速度梯度张量 $\\nabla \\mathbf{u}$：\n$$\n\\nabla \\mathbf{u} = \\begin{bmatrix} \\frac{\\partial u}{\\partial x} & \\frac{\\partial u}{\\partial y} \\\\ \\frac{\\partial v}{\\partial x} & \\frac{\\partial v}{\\partial y} \\end{bmatrix} = \\pi \\begin{bmatrix} \\cos(\\pi x)\\sin(\\pi y) & \\sin(\\pi x)\\cos(\\pi y) \\\\ -\\sin(\\pi x)\\cos(\\pi y) & -\\cos(\\pi x)\\sin(\\pi y) \\end{bmatrix}.\n$$\n应变率张量的对称部分是 $\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top$：\n$$\n\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top = \\pi \\begin{bmatrix} 2\\cos(\\pi x)\\sin(\\pi y) & 0 \\\\ 0 & -2\\cos(\\pi x)\\sin(\\pi y) \\end{bmatrix}.\n$$\n柯西应力张量 $\\boldsymbol{\\sigma}$ 的分量为：\n$$\n\\sigma_{xx} = -p + 2\\mu\\pi\\cos(\\pi x)\\sin(\\pi y) = -\\sin(\\pi x)\\cos(\\pi y) + 2\\mu\\pi\\cos(\\pi x)\\sin(\\pi y)\n$$\n$$\n\\sigma_{yy} = -p - 2\\mu\\pi\\cos(\\pi x)\\sin(\\pi y) = -\\sin(\\pi x)\\cos(\\pi y) - 2\\mu\\pi\\cos(\\pi x)\\sin(\\pi y)\n$$\n$$\n\\sigma_{xy} = \\sigma_{yx} = 0.\n$$\n牵引力矢量 $\\mathbf{t} = [t_x, t_y]^\\top$ 计算为 $\\mathbf{t} = \\boldsymbol{\\sigma}\\mathbf{n} = [\\sigma_{xx}n_x + \\sigma_{xy}n_y, \\sigma_{yx}n_x + \\sigma_{yy}n_y]^\\top$。由于非对角应力为零，这简化为 $t_x = \\sigma_{xx} n_x$ 和 $t_y = \\sigma_{yy} n_y$。\n\n每个边界上牵引力的具体表达式是：\n-   **左边界 ($x=0, \\mathbf{n}=(-1,0)$):**\n    $\\sigma_{xx}(0,y) = 2\\mu\\pi\\sin(\\pi y)$。\n    $t_x(0,y) = \\sigma_{xx}(0,y) \\cdot (-1) = -2\\mu\\pi\\sin(\\pi y)$。\n    $t_y(0,y) = 0$。\n-   **右边界 ($x=1, \\mathbf{n}=(1,0)$):**\n    $\\sigma_{xx}(1,y) = -2\\mu\\pi\\sin(\\pi y)$。\n    $t_x(1,y) = \\sigma_{xx}(1,y) \\cdot (1) = -2\\mu\\pi\\sin(\\pi y)$。\n    $t_y(1,y) = 0$。\n-   **下边界 ($y=0, \\mathbf{n}=(0,-1)$):**\n    $\\sigma_{yy}(x,0) = -\\sin(\\pi x)$。\n    $t_x(x,0) = 0$。\n    $t_y(x,0) = \\sigma_{yy}(x,0) \\cdot (-1) = \\sin(\\pi x)$。\n-   **上边界 ($y=1, \\mathbf{n}=(0,1)$):**\n    $\\sigma_{yy}(x,1) = \\sin(\\pi x)$。\n    $t_x(x,1) = 0$。\n    $t_y(x,1) = \\sigma_{yy}(x,1) \\cdot (1) = \\sin(\\pi x)$。\n\n### 步骤 4：罗宾目标函数 $\\mathbf{g}$ 的推导\n罗宾目标函数 $\\mathbf{g}$ 定义为 $\\mathbf{g} = \\alpha \\mathbf{u} + \\beta \\mathbf{t}$。其分量为：\n$$\ng_x = \\alpha u + \\beta t_x\n$$\n$$\ng_y = \\alpha v + \\beta t_y\n$$\n这些是在边界上使用在指定位置 $(x,y)$ 评估的 $\\mathbf{u}$ 和 $\\mathbf{t}$ 的表达式计算的。\n\n### 步骤 5：算法实现\n推导出的解析表达式直接使用 Python 的 `numpy` 库（用于数学常数和函数）实现。\n1.  一个函数 `vel(x, y)` 计算速度分量 $u$ 和 $v$。\n2.  一个函数 `body_force(x, y, mu)` 计算体积力分量 $f_x$ 和 $f_y$。\n3.  一个函数 `traction(x, y, mu, n)` 使用应力张量表达式和给定的法向量 $\\mathbf{n}$ 计算牵引力分量 $t_x$ 和 $t_y$。\n4.  主脚本遍历指定的测试用例。\n    -   对于边界测试，它调用 `vel` 和 `traction` 函数。然后使用给定的 $\\alpha$ 和 $\\beta$ 系数组合它们的结果，以计算罗宾目标 $\\mathbf{g}$。结果 $[t_x, t_y, g_x, g_y]$ 被存储。\n    -   对于内部测试，它调用 `body_force` 函数。根据构造，残差范数 $\\|\\mathbf{r}\\|$ 已知为 $0$，因此该值被直接追加。结果 $[f_x, f_y, \\|\\mathbf{r}\\|]$ 被存储。\n5.  最后，收集的结果被格式化为表示列表的列表的单个字符串，如问题所指定，并打印到标准输出。",
            "answer": "```python\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the Method of Manufactured Solutions problem for Stokes flow.\n    \"\"\"\n    pi = np.pi\n\n    def get_vel(x, y):\n        \"\"\"Computes the manufactured velocity field components.\"\"\"\n        px, py = pi * x, pi * y\n        u = np.sin(px) * np.sin(py)\n        v = np.cos(px) * np.cos(py)\n        return u, v\n\n    def get_body_force(x, y, mu):\n        \"\"\"Computes the manufactured body force components.\"\"\"\n        px, py = pi * x, pi * y\n        spx, cpx = np.sin(px), np.cos(px)\n        spy, cpy = np.sin(py), np.cos(py)\n        \n        fx = pi * cpx * cpy + 2 * mu * pi**2 * spx * spy\n        fy = -pi * spx * spy + 2 * mu * pi**2 * cpx * cpy\n        return fx, fy\n\n    def get_traction(x, y, mu, n):\n        \"\"\"Computes the traction vector components on a boundary.\"\"\"\n        nx, ny = n\n        px, py = pi * x, pi * y\n        spx, cpx = np.sin(px), np.cos(px)\n        spy, cpy = np.sin(py), np.cos(py)\n\n        sigma_xx = -spx * cpy + 2 * mu * pi * cpx * spy\n        sigma_yy = -spx * cpy - 2 * mu * pi * cpx * spy\n        \n        # sigma_xy is 0, so traction components are simplified\n        tx = sigma_xx * nx\n        ty = sigma_yy * ny\n        return tx, ty\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Boundary test 1 (left)\n        {'type': 'boundary', 'params': {'mu': 0.7, 'alpha': 3.0, 'beta': 0.5, 'x': 0.0, 'y': 0.6, 'n': (-1.0, 0.0)}},\n        # Boundary test 2 (top)\n        {'type': 'boundary', 'params': {'mu': 1.0, 'alpha': 2.0, 'beta': 1.0, 'x': 0.3, 'y': 1.0, 'n': (0.0, 1.0)}},\n        # Boundary test 3 (right)\n        {'type': 'boundary', 'params': {'mu': 2.5, 'alpha': 0.0, 'beta': 1.0, 'x': 1.0, 'y': 0.25, 'n': (1.0, 0.0)}},\n        # Interior test 4\n        {'type': 'interior', 'params': {'mu': 0.7, 'x': 0.1, 'y': 0.9}},\n        # Interior test 5\n        {'type': 'interior', 'params': {'mu': 1.8, 'x': 0.75, 'y': 0.35}},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'boundary':\n            params = case['params']\n            mu, alpha, beta, x, y, n = params['mu'], params['alpha'], params['beta'], params['x'], params['y'], params['n']\n            \n            u_val, v_val = get_vel(x, y)\n            tx_val, ty_val = get_traction(x, y, mu, n)\n            \n            gx_val = alpha * u_val + beta * tx_val\n            gy_val = alpha * v_val + beta * ty_val\n            \n            results.append([tx_val, ty_val, gx_val, gy_val])\n\n        elif case['type'] == 'interior':\n            params = case['params']\n            mu, x, y = params['mu'], params['x'], params['y']\n            \n            fx_val, fy_val = get_body_force(x, y, mu)\n            # The residual is zero by construction in the Method of Manufactured Solutions.\n            residual_norm = 0.0\n            \n            results.append([fx_val, fy_val, residual_norm])\n\n    # Final print statement in the exact required format.\n    # The default str() representation for a list provides the required spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "MMS 的威力可以扩展到复杂的、耦合的、非线性的问题上，这些问题在真实的 CFD 模拟中很典型。本练习将处理一个动量和能量输运耦合的问题，其中流体粘度 $\\mu$ 和导热系数 $k$ 是温度 $T$ 的函数。通过系统地为这个可变物性系统推导必要的源项，您将学会如何构建一个全面的验证测试，以确保所有的耦合项和非线性依赖关系在您的求解器中得到正确实现 。",
            "id": "3376812",
            "problem": "请使用制造解方法（Method of Manufactured Solutions, MMS）为具有随温度变化的动力粘度和热导率的稳态、无量纲、不可压缩二维流动设计一个独立的验证。制造的场在方形域 $\\Omega = [0,1]\\times[0,1]$ 上是光滑且空间周期的。三角函数中的角度必须以弧度为单位。\n\n控制方程是针对具有随温度变化属性的牛顿流体的稳态不可压缩动量和能量方程，采用其标准散度形式，即：\n- 连续性方程：$\\nabla \\cdot \\boldsymbol{u} = 0$。\n- 动量方程：$\\rho (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} = -\\nabla p + \\nabla\\cdot\\left(2\\,\\mu(T)\\,\\boldsymbol{S}(\\boldsymbol{u})\\right) + \\boldsymbol{f}$。\n- 能量方程（含粘性耗散）：$\\rho c_p\\,\\boldsymbol{u}\\cdot\\nabla T = \\nabla\\cdot\\left(k(T)\\,\\nabla T\\right) + \\Phi + Q$。\n\n此处 $\\boldsymbol{u}=(u_x,u_y)$ 是速度， $p$ 是压力， $T$ 是温度， $\\rho$ 是密度， $c_p$ 是定压比热， $\\mu(T)$ 是动力粘度， $k(T)$ 是热导率， $\\boldsymbol{S}(\\boldsymbol{u}) = \\tfrac{1}{2}\\left(\\nabla\\boldsymbol{u} + \\nabla\\boldsymbol{u}^\\top\\right)$ 是应变率张量， $\\Phi = 2\\,\\mu(T)\\,\\boldsymbol{S}:\\boldsymbol{S}$ 是粘性耗散。所有物理量均已无量纲化。\n\n制造以下光滑场：\n- 流函数 $\\psi(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$，它通过 $\\boldsymbol{u}(x,y) = \\left(\\tfrac{\\partial \\psi}{\\partial y},\\,-\\tfrac{\\partial \\psi}{\\partial x}\\right)$ 定义了一个无散速度场。\n- 压力 $p(x,y) = \\sin(\\pi x)\\,\\sin(2\\pi y)$。\n- 温度 $T(x,y) = \\tfrac{1}{2}\\,\\sin(2\\pi x)\\,\\cos(\\pi y) + \\tfrac{1}{4}\\,x\\,y$。\n\n定义严格为正且变化剧烈的随温度变化的材料属性：\n- $\\mu(T) = \\mu_0 \\exp\\left(\\beta\\,T\\right)$。\n- $k(T) = k_0 \\exp\\left(\\alpha\\,T\\right)$。\n\n您的任务：\n1) 从上述基本定律出发，构造动量方程中的源项 $\\boldsymbol{f}(x,y)$ 和能量方程中的源项 $Q(x,y)$，使得制造场 $\\boldsymbol{u},p,T$ 对于任意参数集 $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha)$ 都能精确满足方程。\n2) 实现一个程序，对于下面测试套件中的每个参数集，在域内一组公共点上，使用您构造的 $\\boldsymbol{f}$ 和 $Q$ 来评估动量和能量方程的残差，并报告该案例的最大绝对残差，结果为一个浮点数。\n\n在点 $(x,y)$ 处要评估的残差定义：\n- 动量残差向量：$\\boldsymbol{R}_m = \\rho(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nabla\\cdot\\left(2\\,\\mu(T)\\,\\boldsymbol{S}(\\boldsymbol{u})\\right) - \\boldsymbol{f}$。\n- 能量残差标量：$R_e = \\rho c_p\\,\\boldsymbol{u}\\cdot\\nabla T - \\nabla\\cdot\\left(k(T)\\,\\nabla T\\right) - \\Phi - Q$。\n\n对于每个案例，计算：\n- 在指定点上 $\\boldsymbol{R}_m$ 的分量绝对值和 $R_e$ 的绝对值的最大值。\n- 报告该案例的单一标量值，该值等于这些值的最大值。\n\n测试点（所有案例共用；角度以弧度为单位）：\n- $(x,y) \\in \\{(0.25,0.40),\\,(0.73,0.90),\\,(0.01,0.99),\\,(0.50,0.50)\\}$。\n\n测试套件（每个案例指定 $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha)$）：\n- 案例 A（中等可变性）：$(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha) = (1.0,\\,1.0,\\,0.3,\\,1.5,\\,0.7,\\,1.2)$。\n- 案例 B（具有相反趋势的强可变性）：$(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha) = (2.0,\\,0.5,\\,0.05,\\,3.0,\\,1.1,\\,-2.5)$。\n- 案例 C（恒定属性）：$(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha) = (1.3,\\,2.2,\\,0.2,\\,0.0,\\,0.9,\\,0.0)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_A,r_B,r_C]$），其中每个 $r_\\cdot$ 是一个浮点数，表示相应案例的最大绝对残差。残差是无量纲数。\n\n所有计算必须以双精度进行。不允许用户输入，也不得读写任何外部文件。实现语言和库的限制将另行指定。",
            "solution": "我们从稳态、不可压缩的二维方程开始。通过从流函数构造速度，连续性方程 $\\nabla\\cdot\\boldsymbol{u} = 0$ 被恒等地满足。我们选择流函数 $\\psi(x,y)=\\sin(\\pi x)\\sin(\\pi y)$ 并定义\n$$\n\\boldsymbol{u}(x,y)=\\left(\\frac{\\partial \\psi}{\\partial y},\\, -\\frac{\\partial \\psi}{\\partial x}\\right)\n= \\left(\\pi \\cos(\\pi y)\\sin(\\pi x),\\, -\\pi \\cos(\\pi x)\\sin(\\pi y)\\right).\n$$\n这通过构造确保了 $\\nabla\\cdot\\boldsymbol{u} = \\frac{\\partial u_x}{\\partial x} + \\frac{\\partial u_y}{\\partial y} = 0$。\n\n我们指定压力 $p(x,y)=\\sin(\\pi x)\\sin(2\\pi y)$，使得压力梯度不为零：\n$$\n\\nabla p = \\left(\\pi \\cos(\\pi x)\\sin(2\\pi y),\\, 2\\pi \\sin(\\pi x)\\cos(2\\pi y)\\right).\n$$\n我们制造温度场\n$$\nT(x,y) = \\frac{1}{2}\\,\\sin(2\\pi x)\\,\\cos(\\pi y) + \\frac{1}{4}\\,x\\,y,\n$$\n使其光滑并产生不为零的梯度和曲率。材料属性严格为正且随温度剧烈变化：\n$$\n\\mu(T) = \\mu_0 \\exp(\\beta T), \\qquad k(T) = k_0 \\exp(\\alpha T),\n$$\n其中 $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha)$ 按案例给出。\n\n为使制造场恒等地满足动量方程，我们对稳态动量方程进行重排以求解体力项 $\\boldsymbol{f}$：\n$$\n\\boldsymbol{f} = \\rho (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nabla\\cdot\\left(2\\,\\mu(T)\\,\\boldsymbol{S}(\\boldsymbol{u})\\right).\n$$\n类似地，为使制造场恒等地满足能量方程，我们重排方程以求解 $Q$：\n$$\nQ = \\rho c_p\\,\\boldsymbol{u}\\cdot\\nabla T - \\nabla\\cdot\\left(k(T)\\,\\nabla T\\right) - \\Phi,\n$$\n其中，牛顿不可压缩流体的粘性耗散为 $\\Phi = 2 \\mu(T)\\,\\boldsymbol{S}:\\boldsymbol{S}$。\n\n现在我们解析地计算所有必要的导数。首先，速度梯度：\n$$\n\\nabla\\boldsymbol{u} =\n\\begin{bmatrix}\n\\frac{\\partial u_x}{\\partial x} & \\frac{\\partial u_x}{\\partial y} \\\\\n\\frac{\\partial u_y}{\\partial x} & \\frac{\\partial u_y}{\\partial y}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\pi^2 \\cos(\\pi y)\\cos(\\pi x) & -\\pi^2 \\sin(\\pi y)\\sin(\\pi x) \\\\\n\\pi^2 \\sin(\\pi x)\\sin(\\pi y) & -\\pi^2 \\cos(\\pi x)\\cos(\\pi y)\n\\end{bmatrix}.\n$$\n因此，对称应变率张量为\n$$\n\\boldsymbol{S} = \\frac{1}{2}\\left(\\nabla\\boldsymbol{u} + \\nabla\\boldsymbol{u}^\\top\\right)\n=\n\\begin{bmatrix}\n\\pi^2 \\cos(\\pi x)\\cos(\\pi y) & 0 \\\\\n0 & -\\pi^2 \\cos(\\pi x)\\cos(\\pi y)\n\\end{bmatrix}.\n$$\n非对角线分量相互抵消，因为 $\\tfrac{1}{2}\\left(\\tfrac{\\partial u_x}{\\partial y}+\\tfrac{\\partial u_y}{\\partial x}\\right) = \\tfrac{1}{2}\\left(-\\pi^2 \\sin(\\pi y)\\sin(\\pi x)+\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\\right)=0$。\n因此\n$$\n\\boldsymbol{S}:\\boldsymbol{S} = \\left(\\pi^2 \\cos(\\pi x)\\cos(\\pi y)\\right)^2 + \\left(-\\pi^2 \\cos(\\pi x)\\cos(\\pi y)\\right)^2 = 2\\pi^4 \\cos^2(\\pi x)\\cos^2(\\pi y),\n$$\n粘性耗散变为\n$$\n\\Phi = 2 \\mu(T)\\,\\boldsymbol{S}:\\boldsymbol{S} = 4\\,\\mu(T)\\,\\pi^4 \\cos^2(\\pi x)\\cos^2(\\pi y).\n$$\n\n对于速度的对流项，我们按分量计算 $(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u}$：\n$$\n(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} =\n\\begin{bmatrix}\nu_x \\frac{\\partial u_x}{\\partial x} + u_y \\frac{\\partial u_x}{\\partial y} \\\\\nu_x \\frac{\\partial u_y}{\\partial x} + u_y \\frac{\\partial u_y}{\\partial y}\n\\end{bmatrix}.\n$$\n\n粘性项需要计算 $2\\mu(T)\\boldsymbol{S}$ 的散度。由于 $\\boldsymbol{S}$ 是对角矩阵，只有 $S_{11}$ 和 $S_{22}$ 有贡献。定义 $g(x,y) = 2\\pi^2 \\cos(\\pi x)\\cos(\\pi y)$。那么\n$$\n2\\,\\mu(T)\\,S_{11} = \\mu(T)\\,g(x,y), \\qquad 2\\,\\mu(T)\\,S_{22} = -\\mu(T)\\,g(x,y),\n$$\n因此\n$$\n\\left[\\nabla\\cdot(2\\,\\mu \\boldsymbol{S})\\right]_x = \\frac{\\partial}{\\partial x}\\left(\\mu\\,g\\right) + \\frac{\\partial}{\\partial y}\\left(0\\right) = \\mu_x g + \\mu\\,g_x,\n$$\n$$\n\\left[\\nabla\\cdot(2\\,\\mu \\boldsymbol{S})\\right]_y = \\frac{\\partial}{\\partial x}\\left(0\\right) + \\frac{\\partial}{\\partial y}\\left(-\\mu\\,g\\right) = -\\mu_y g - \\mu\\,g_y.\n$$\n对 $\\mu(T)=\\mu_0 e^{\\beta T}$ 使用链式法则，我们得到 $\\mu_x = \\mu\\,\\beta\\,T_x$ 和 $\\mu_y = \\mu\\,\\beta\\,T_y$。$g$ 的导数是\n$$\ng_x = -2\\pi^3 \\sin(\\pi x)\\cos(\\pi y), \\qquad g_y = -2\\pi^3 \\cos(\\pi x)\\sin(\\pi y).\n$$\n\n对于温度，其导数为\n$$\nT_x = \\pi \\cos(2\\pi x)\\cos(\\pi y) + \\frac{1}{4} y, \\qquad\nT_y = -\\frac{1}{2}\\pi \\sin(2\\pi x)\\sin(\\pi y) + \\frac{1}{4} x,\n$$\n$$\nT_{xx} = - (2\\pi)^2 \\frac{1}{2}\\,\\sin(2\\pi x)\\cos(\\pi y) = -2\\pi^2 \\sin(2\\pi x)\\cos(\\pi y),\n$$\n$$\nT_{yy} = - \\frac{1}{2}\\pi^2 \\sin(2\\pi x)\\cos(\\pi y).\n$$\n因此\n$$\nT_{xx} + T_{yy} = -\\frac{5}{2}\\pi^2 \\sin(2\\pi x)\\cos(\\pi y).\n$$\n温度对流项为 $\\boldsymbol{u}\\cdot\\nabla T = u_x T_x + u_y T_y$。\n\n对于可变热导率的扩散项，我们使用\n$$\n\\nabla\\cdot(k(T)\\nabla T) = \\frac{\\partial}{\\partial x}\\left(k T_x\\right) + \\frac{\\partial}{\\partial y}\\left(k T_y\\right)\n= k \\left(T_{xx} + T_{yy} + \\alpha\\left(T_x^2 + T_y^2\\right)\\right),\n$$\n因为对于 $k(T)=k_0 e^{\\alpha T}$，有 $k_x = k\\,\\alpha\\,T_x$ 和 $k_y = k\\,\\alpha\\,T_y$。\n\n因此，使所选 $(\\boldsymbol{u},p,T)$ 成为精确解的制造源项是：\n$$\n\\boldsymbol{f}(x,y) = \\rho (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\begin{bmatrix}\\mu_x g + \\mu g_x \\\\ -\\mu_y g - \\mu g_y\\end{bmatrix},\n$$\n$$\nQ(x,y) = \\rho c_p \\,\\boldsymbol{u}\\cdot\\nabla T - k\\left(T_{xx}+T_{yy} + \\alpha\\left(T_x^2 + T_y^2\\right)\\right) - 4\\,\\mu\\,\\pi^4 \\cos^2(\\pi x)\\cos^2(\\pi y).\n$$\n\n程序的算法设计：\n- 对于每个参数集 $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha)$ 和每个测试点 $(x,y)$，评估：\n  - $\\boldsymbol{u}$ 及其梯度，然后是 $(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u}$。\n  - $p$ 的梯度 $\\nabla p$。\n  - $T$, $T_x$, $T_y$, $T_{xx}$, $T_{yy}$。\n  - $\\mu(T)$、$k(T)$ 及其通过 $\\mu_x = \\mu \\beta T_x$, $\\mu_y = \\mu \\beta T_y$ 得到的隐式导数；计算 $g$, $g_x$, $g_y$；使用上述简化形式组装 $\\nabla\\cdot(2\\mu \\boldsymbol{S})$。\n  - $\\Phi = 4\\,\\mu\\,\\pi^4 \\cos^2(\\pi x)\\cos^2(\\pi y)$。\n- 根据上述公式构造 $\\boldsymbol{f}$ 和 $Q$。\n- 形成残差：\n  - 动量残差 $\\boldsymbol{R}_m = \\rho(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nabla\\cdot(2\\mu \\boldsymbol{S}) - \\boldsymbol{f}$。\n  - 能量残差 $R_e = \\rho c_p\\,\\boldsymbol{u}\\cdot\\nabla T - \\nabla\\cdot(k \\nabla T) - \\Phi - Q$。\n- 对于每个案例，计算所有分量和所有点的最大绝对残差：\n  - $\\max\\left(\\max_{(x,y)} |R_{m,x}|,\\, \\max_{(x,y)} |R_{m,y}|,\\, \\max_{(x,y)} |R_e|\\right)$。\n- 将三个案例的结果输出为单行 $[r_A,r_B,r_C]$。\n\n因为源项是根据控制方程和制造场精确构造的，所以残差应处于浮点舍入误差的水平，这证明了变系数微分算子与 MMS 构造的一致性。",
            "answer": "```python\nimport numpy as np\n\ndef manufactured_fields(x, y):\n    pi = np.pi\n    # Streamfunction and derived velocity\n    ux = pi * np.cos(pi * y) * np.sin(pi * x)\n    uy = -pi * np.cos(pi * x) * np.sin(pi * y)\n    # Velocity gradients\n    dux_dx = pi**2 * np.cos(pi * y) * np.cos(pi * x)\n    dux_dy = -pi**2 * np.sin(pi * y) * np.sin(pi * x)\n    duy_dx = pi**2 * np.sin(pi * x) * np.sin(pi * y)\n    duy_dy = -pi**2 * np.cos(pi * x) * np.cos(pi * y)\n    # Symmetric strain S and invariants\n    S11 = dux_dx\n    S22 = duy_dy\n    S12 = 0.5 * (dux_dy + duy_dx)  # will be zero analytically\n    # For viscous dissipation, S:S\n    S_contract = S11**2 + 2.0 * S12**2 + S22**2\n\n    # Pressure and gradient\n    dp_dx = pi * np.cos(pi * x) * np.sin(2.0 * pi * y)\n    dp_dy = 2.0 * pi * np.sin(pi * x) * np.cos(2.0 * pi * y)\n\n    # Temperature and derivatives\n    T = 0.5 * np.sin(2.0 * pi * x) * np.cos(pi * y) + 0.25 * x * y\n    Tx = (2.0 * pi) * 0.5 * np.cos(2.0 * pi * x) * np.cos(pi * y) + 0.25 * y  # = pi * cos(2pi x) cos(pi y) + 0.25 y\n    Ty = 0.5 * np.sin(2.0 * pi * x) * (-pi) * np.sin(pi * y) + 0.25 * x       # = -0.5*pi*sin(2pi x) sin(pi y) + 0.25 x\n    Txx = -(2.0 * pi)**2 * 0.5 * np.sin(2.0 * pi * x) * np.cos(pi * y)        # = -2*pi^2 * sin(2pi x) cos(pi y)\n    Tyy = -0.5 * (pi**2) * np.sin(2.0 * pi * x) * np.cos(pi * y)\n\n    # Convection of velocity (u · ∇)u\n    conv_u_x = ux * dux_dx + uy * dux_dy\n    conv_u_y = ux * duy_dx + uy * duy_dy\n\n    # g for viscous divergence and its derivatives\n    g = 2.0 * (pi**2) * np.cos(pi * x) * np.cos(pi * y)\n    gx = -2.0 * (pi**3) * np.sin(pi * x) * np.cos(pi * y)\n    gy = -2.0 * (pi**3) * np.cos(pi * x) * np.sin(pi * y)\n\n    # For dissipation quick evaluation using S:S (consistency check)\n    # S:S analytically equals 2*pi^4 cos^2(pi x) cos^2(pi y); but we use computed S_contract for generality\n    return {\n        \"ux\": ux, \"uy\": uy,\n        \"dux_dx\": dux_dx, \"dux_dy\": dux_dy, \"duy_dx\": duy_dx, \"duy_dy\": duy_dy,\n        \"S11\": S11, \"S22\": S22, \"S12\": S12, \"S_contract\": S_contract,\n        \"dp_dx\": dp_dx, \"dp_dy\": dp_dy,\n        \"T\": T, \"Tx\": Tx, \"Ty\": Ty, \"Txx\": Txx, \"Tyy\": Tyy,\n        \"conv_u_x\": conv_u_x, \"conv_u_y\": conv_u_y,\n        \"g\": g, \"gx\": gx, \"gy\": gy\n    }\n\ndef properties_and_sources(x, y, rho, cp, mu0, beta, k0, alpha):\n    fld = manufactured_fields(x, y)\n    pi = np.pi\n\n    # Temperature-dependent properties\n    T = fld[\"T\"]\n    mu = mu0 * np.exp(beta * T)\n    k = k0 * np.exp(alpha * T)\n\n    # Implicit derivatives via chain rule\n    mu_x = mu * beta * fld[\"Tx\"]\n    mu_y = mu * beta * fld[\"Ty\"]\n\n    # Divergence of 2 mu S using simplified diagonal form\n    g = fld[\"g\"]; gx = fld[\"gx\"]; gy = fld[\"gy\"]\n    div2muS_x = mu_x * g + mu * gx\n    div2muS_y = - (mu_y * g + mu * gy)\n\n    # Momentum source term\n    conv_u_x = fld[\"conv_u_x\"]; conv_u_y = fld[\"conv_u_y\"]\n    dp_dx = fld[\"dp_dx\"]; dp_dy = fld[\"dp_dy\"]\n    fx = rho * conv_u_x + dp_dx - div2muS_x\n    fy = rho * conv_u_y + dp_dy - div2muS_y\n\n    # Energy terms\n    ux = fld[\"ux\"]; uy = fld[\"uy\"]\n    Tx = fld[\"Tx\"]; Ty = fld[\"Ty\"]; Txx = fld[\"Txx\"]; Tyy = fld[\"Tyy\"]\n    u_dot_gradT = ux * Tx + uy * Ty\n\n    # Variable-k diffusion operator\n    diff_T = k * (Txx + Tyy + alpha * (Tx**2 + Ty**2))\n\n    # Viscous dissipation Phi = 2 mu S:S\n    # Use analytical compact form for robustness (equal to computed S_contract form)\n    Phi = 4.0 * mu * (pi**4) * (np.cos(pi * x)**2) * (np.cos(pi * y)**2)\n\n    # Energy source term\n    Q = rho * cp * u_dot_gradT - diff_T - Phi\n\n    return fx, fy, Q, mu, k, div2muS_x, div2muS_y, diff_T, Phi, u_dot_gradT\n\ndef residuals_at_point(x, y, params):\n    rho, cp, mu0, beta, k0, alpha = params\n    # Compute sources using MMS formulas\n    fx, fy, Q, mu, k, div2muS_x, div2muS_y, diff_T, Phi, u_dot_gradT = properties_and_sources(\n        x, y, rho, cp, mu0, beta, k0, alpha\n    )\n    fld = manufactured_fields(x, y)\n\n    # Rebuild PDE terms to form residuals\n    # Momentum residual: rho (u·∇)u + ∇p - div(2 mu S) - f\n    Rm_x = rho * fld[\"conv_u_x\"] + fld[\"dp_dx\"] - div2muS_x - fx\n    Rm_y = rho * fld[\"conv_u_y\"] + fld[\"dp_dy\"] - div2muS_y - fy\n\n    # Energy residual: rho cp u·∇T - div(k grad T) - Phi - Q\n    # div(k grad T) equals diff_T\n    Re = rho * cp * (fld[\"ux\"] * fld[\"Tx\"] + fld[\"uy\"] * fld[\"Ty\"]) - diff_T - Phi - Q\n\n    return Rm_x, Rm_y, Re\n\ndef solve():\n    # Define test cases (rho, cp, mu0, beta, k0, alpha)\n    test_cases = [\n        (1.0, 1.0, 0.3, 1.5, 0.7, 1.2),     # Case A\n        (2.0, 0.5, 0.05, 3.0, 1.1, -2.5),   # Case B\n        (1.3, 2.2, 0.2, 0.0, 0.9, 0.0),     # Case C\n    ]\n    # Test points\n    points = [\n        (0.25, 0.40),\n        (0.73, 0.90),\n        (0.01, 0.99),\n        (0.50, 0.50),\n    ]\n\n    results = []\n    for params in test_cases:\n        max_abs = 0.0\n        for (x, y) in points:\n            Rm_x, Rm_y, Re = residuals_at_point(x, y, params)\n            max_abs = max(max_abs, abs(Rm_x), abs(Rm_y), abs(Re))\n        results.append(max_abs)\n\n    # Final print statement in the exact required format: comma-separated values, no spaces\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}