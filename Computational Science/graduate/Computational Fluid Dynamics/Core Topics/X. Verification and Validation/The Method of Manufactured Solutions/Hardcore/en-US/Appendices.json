{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of code verification is confirming that a numerical scheme achieves its theoretical order of accuracy. This first exercise  demonstrates this fundamental application of the Method of Manufactured Solutions. By manufacturing a smooth, time-dependent solution for the advection-diffusion equation, you will derive the necessary source term and use it to precisely measure the error of common Runge-Kutta time integrators, thereby verifying their convergence rates.",
            "id": "3376840",
            "problem": "Consider the one-dimensional linear advection-diffusion equation on the periodic domain $x \\in [0, 2\\pi]$,\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = -a \\frac{\\partial u}{\\partial x}(x,t) + \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t) + s(x,t),\n$$\nwhere $a$ and $\\nu$ are constant coefficients and $s(x,t)$ is a source term to be determined. Use the Method of Manufactured Solutions (MMS) to derive a consistent source term by prescribing the exact solution\n$$\nu(x,t) = \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x),\n$$\nwhere $\\alpha$ and $\\beta$ are real constants and $k$ is a positive integer. All angles in trigonometric functions must be interpreted in radians. You may assume smoothness sufficient for all operations performed.\n\nTask 1. Starting from the fundamental definitions of partial derivatives and the given exact solution, derive the source term $s(x,t)$ such that $u(x,t)$ is an exact solution of the advection-diffusion equation. The derivation must begin by computing the time derivative $\\partial u/\\partial t$, the first spatial derivative $\\partial u/\\partial x$, and the second spatial derivative $\\partial^2 u/\\partial x^2$, and then substituting these into the governing equation to isolate $s(x,t)$.\n\nTask 2. Define the one-step discrete-time residual (also called the local defect) of a Runge–Kutta time integrator by inserting the exact manufactured solution along its internal stage abscissae. For a single time step from $t_n$ to $t_{n+1} = t_n + \\Delta t$, the Runge–Kutta update applied along the exact trajectory is\n$$\nu^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i\\,F\\!\\left(x,t_n + c_i \\Delta t\\right),\n$$\nwhere $m$ is the number of stages, $b_i$ and $c_i$ are the method weights and abscissae, and $F(x,t)$ denotes the right-hand side of the partial differential equation evaluated at the exact manufactured solution. Because the source term is chosen by MMS to enforce the solution, it holds for the manufactured solution that $F(x,t) = \\partial u/\\partial t(x,t)$. Define the one-step residual norm\n$$\n\\mathcal{R}(\\Delta t) = \\left\\| u^{\\text{RK}}(x) - u\\!\\left(x,t_n + \\Delta t\\right) \\right\\|_{L^2([0,2\\pi])},\n$$\nwhere the $L^2$ norm is computed as the square root of the spatial average of the squared pointwise difference over the periodic domain.\n\nTask 3. Using the above residual definition, implement the following explicit Runge–Kutta methods by their weights $b_i$ and abscissae $c_i$, and evaluate the residual for a single time step starting at $t_n = 0$:\n- Forward Euler (one-stage): $m=1$, $b_1 = 1$, $c_1 = 0$.\n- Explicit midpoint (two-stage, second order): $m=1$, $b_1 = 1$, $c_1 = \\tfrac{1}{2}$, interpreted as the one-point midpoint quadrature of $\\partial u/\\partial t$ over the time step.\n- Classical Runge–Kutta of order four (four-stage): $m=4$, $(c_1,c_2,c_3,c_4) = (0, \\tfrac{1}{2}, \\tfrac{1}{2}, 1)$ and $(b_1,b_2,b_3,b_4) = \\left(\\tfrac{1}{6}, \\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{6}\\right)$.\n\nTask 4. For each method and a sequence of time steps $\\Delta t_1 > \\Delta t_2 > \\Delta t_3$, compute the empirical order of accuracy from the residuals as\n$$\np_{\\text{est}} = \\frac{\\log\\left(\\mathcal{R}(\\Delta t_1) / \\mathcal{R}(\\Delta t_2)\\right)}{\\log\\left(\\Delta t_1 / \\Delta t_2\\right)}.\n$$\nRepeat for the pair $\\left(\\Delta t_2, \\Delta t_3\\right)$.\n\nTask 5. Investigate superconvergence-like cancellation for oscillatory manufactured dynamics by setting $\\alpha = 0$ and selecting $\\beta$ and $\\Delta t$ such that $\\beta \\Delta t = \\pi$. In this case, the exact change of $u$ over one step is zero for the temporal factor, and certain quadratures may display enhanced cancellation. For the classical fourth-order Runge–Kutta method, compute the empirical orders $p_{\\text{est}}$ for the step pairs $\\left(\\Delta t_1,\\Delta t_2\\right)$ and $\\left(\\Delta t_2,\\Delta t_3\\right)$ with $\\Delta t_2$ satisfying $\\beta \\Delta t_2 = \\pi$, and return a boolean flag indicating whether each empirical order exceeds the method’s nominal order plus $0.5$.\n\nImplementation details and units:\n- Use a periodic spatial grid with $N$ points uniformly distributed on $[0,2\\pi]$ to numerically approximate the $L^2$ norm as the square root of the mean squared difference over grid points.\n- All trigonometric angles must be interpreted in radians.\n- No physical dimensional units are required beyond the specification of the angular unit for trigonometric evaluation.\n\nTest Suite. Your program must implement the computations for the following three parameter sets, each producing two empirical orders or boolean flags as described:\n\n1. General dynamics, fourth-order method (happy path):\n   - Parameters: $a = 1.0$, $\\nu = 0.05$, $\\alpha = 0.1$, $\\beta = 2.0$, $k = 2$, $N = 256$.\n   - Method: classical fourth-order Runge–Kutta.\n   - Time steps: $\\Delta t_1 = 0.2$, $\\Delta t_2 = 0.1$, $\\Delta t_3 = 0.05$.\n   - Output: two floats, the empirical orders computed for $\\left(\\Delta t_1,\\Delta t_2\\right)$ and $\\left(\\Delta t_2,\\Delta t_3\\right)$.\n\n2. Time-dominated manufactured dynamics, second-order method (edge case emphasizing time-only variation):\n   - Parameters: $a = 0.0$, $\\nu = 0.0$, $\\alpha = 0.2$, $\\beta = 1.5$, $k = 3$, $N = 256$.\n   - Method: explicit midpoint.\n   - Time steps: $\\Delta t_1 = 0.3$, $\\Delta t_2 = 0.15$, $\\Delta t_3 = 0.075$.\n   - Output: two floats, the empirical orders computed for $\\left(\\Delta t_1,\\Delta t_2\\right)$ and $\\left(\\Delta t_2,\\Delta t_3\\right)$.\n\n3. Oscillatory superconvergence-like cancellation, fourth-order method:\n   - Parameters: $a = 0.5$, $\\nu = 0.01$, $\\alpha = 0.0$, $\\beta = 4\\pi$, $k = 4$, $N = 256$.\n   - Method: classical fourth-order Runge–Kutta.\n   - Time steps: $\\Delta t_1 = 0.5$, $\\Delta t_2 = 0.25$, $\\Delta t_3 = 0.125$ so that $\\beta \\Delta t_2 = \\pi$.\n   - Output: two booleans indicating whether the empirical orders for $\\left(\\Delta t_1,\\Delta t_2\\right)$ and $\\left(\\Delta t_2,\\Delta t_3\\right)$ exceed $4.5$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$$\n\\left[ p^{(1)}_{12},\\, p^{(1)}_{23},\\, p^{(2)}_{12},\\, p^{(2)}_{23},\\, \\text{flag}^{(3)}_{12},\\, \\text{flag}^{(3)}_{23} \\right],\n$$\nwhere superscripts indicate the test case number and subscripts indicate the time step pair used. Each $p$ must be a floating-point number, and each flag must be a boolean.",
            "solution": "The problem is subjected to validation against the specified criteria.\n\n### Step 1: Extract Givens\n- **Governing Equation**: The one-dimensional linear advection-diffusion equation on a periodic domain $x \\in [0, 2\\pi]$ is given by\n$$ \\frac{\\partial u}{\\partial t}(x,t) = -a \\frac{\\partial u}{\\partial x}(x,t) + \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t) + s(x,t) $$\nwhere $a$ and $\\nu$ are constant coefficients and $s(x,t)$ is a source term.\n- **Manufactured Solution**: The prescribed exact solution is\n$$ u(x,t) = \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x) $$\nwhere $\\alpha$, $\\beta$ are real constants and $k$ is a positive integer.\n- **Task 1**: Derive the source term $s(x,t)$ by substituting the manufactured solution into the governing equation.\n- **Task 2**: Define the one-step discrete-time residual of a Runge–Kutta (RK) integrator. The RK update is:\n$$ u^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i\\,F\\!\\left(x,t_n + c_i \\Delta t\\right) $$\nwhere $F(x,t) = \\partial u/\\partial t(x,t)$ along the exact solution trajectory. The residual norm is defined as:\n$$ \\mathcal{R}(\\Delta t) = \\left\\| u^{\\text{RK}}(x) - u\\!\\left(x,t_n + \\Delta t\\right) \\right\\|_{L^2([0,2\\pi])} $$\nThe $L^2$ norm is to be approximated as the square root of the spatial average of the squared pointwise difference.\n- **Task 3**: Implement and evaluate the residual for three explicit RK methods starting at $t_n = 0$:\n    - Forward Euler: $m=1$, $b_1 = 1$, $c_1 = 0$.\n    - Explicit midpoint: $m=1$, $b_1 = 1$, $c_1 = \\tfrac{1}{2}$ (interpreted as one-point quadrature).\n    - Classical Runge–Kutta (RK4): $m=4$, $(c_1,c_2,c_3,c_4) = (0, \\tfrac{1}{2}, \\tfrac{1}{2}, 1)$, $(b_1,b_2,b_3,b_4) = \\left(\\tfrac{1}{6}, \\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{6}\\right)$.\n- **Task 4**: Compute the empirical order of accuracy:\n$$ p_{\\text{est}} = \\frac{\\log\\left(\\mathcal{R}(\\Delta t_1) / \\mathcal{R}(\\Delta t_2)\\right)}{\\log\\left(\\Delta t_1 / \\Delta t_2\\right)} $$\n- **Task 5**: Investigate superconvergence for the RK4 method when $\\alpha = 0$ and $\\beta \\Delta t = \\pi$.\n- **Implementation Details**: Use a periodic spatial grid of $N$ points on $[0, 2\\pi]$. Angles are in radians.\n- **Test Suite**: Three specific test cases are provided with all necessary parameters ($\\alpha, \\beta, k, a, \\nu, N$), time steps ($\\Delta t_1, \\Delta t_2, \\Delta t_3$), and target outputs (empirical orders or boolean flags).\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is critically examined:\n- **Scientifically Grounded**: The problem is grounded in the fields of computational fluid dynamics and numerical analysis. The governing equation is a fundamental PDE, and the Method of Manufactured Solutions (MMS) is a standard technique for code verification. The Runge-Kutta methods and the concept of order of accuracy are pillars of numerical analysis for ODEs/PDEs. The investigation of superconvergence is a valid and specific topic within numerical analysis. All components are scientifically sound.\n- **Well-Posed**: The problem is well-posed. The tasks are clearly defined, and all necessary data, parameters, and formulas are provided. The definition of the explicit midpoint method, though compactly stated, is clarified by its interpretation as a one-point quadrature rule, which removes ambiguity. The problem structure leads to a unique and meaningful numerical result for each test case.\n- **Objective**: The problem is stated in precise, objective mathematical language. There are no subjective or opinion-based claims.\n- **Completeness and Consistency**: The problem is self-contained. All constants, equations, and conditions needed for the solution are provided. There are no internal contradictions. For instance, the crucial simplification $F(x,t) = \\partial u/\\partial t(x,t)$ is explicitly stated and justified within the context of MMS, ensuring a consistent framework for calculating the time integration error.\n- **No Other Flaws**: The problem is not trivial, unrealistic, or un-formalizable. It represents a standard, rigorous exercise in verifying the temporal accuracy of numerical schemes.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A complete, reasoned solution will be provided.\n\n### Solution Derivation\n\nThe solution requires implementing the logic described in the problem statement. The core of the task is to compute the temporal error of Runge-Kutta methods when applied to a known solution trajectory.\n\n**Task 1: Derivation of the Source Term**\n\nThe source term $s(x,t)$ is derived by enforcing that $u(x,t) = \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x)$ is a solution to the governing advection-diffusion equation. This requires rearranging the equation to solve for $s(x,t)$:\n$$ s(x,t) = \\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} - \\nu \\frac{\\partial^2 u}{\\partial x^2} $$\nWe compute the necessary partial derivatives of $u(x,t)$.\n\nFirst, the time derivative $\\partial u / \\partial t$, using the product rule on the temporal part $T(t) = \\exp(\\alpha t)\\sin(\\beta t)$:\n$$ \\frac{d T}{d t} = \\frac{d}{dt} \\left( \\exp(\\alpha t)\\sin(\\beta t) \\right) = \\alpha \\exp(\\alpha t)\\sin(\\beta t) + \\beta \\exp(\\alpha t)\\cos(\\beta t) = \\exp(\\alpha t) \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) $$\nTherefore,\n$$ \\frac{\\partial u}{\\partial t} = \\exp(\\alpha t) \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) \\sin(k x) $$\nNext, the spatial derivatives:\n$$ \\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x) \\right) = \\exp(\\alpha t)\\,\\sin(\\beta t) \\left( k \\cos(k x) \\right) $$\n$$ \\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial}{\\partial x} \\left( k \\exp(\\alpha t)\\,\\sin(\\beta t) \\cos(k x) \\right) = k \\exp(\\alpha t)\\,\\sin(\\beta t) \\left( -k \\sin(k x) \\right) = -k^2 u(x,t) $$\nSubstituting these expressions back into the equation for $s(x,t)$:\n$$ s(x,t) = \\left[ \\exp(\\alpha t) \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) \\sin(k x) \\right] + a \\left[ k \\exp(\\alpha t)\\sin(\\beta t) \\cos(k x) \\right] - \\nu \\left[ -k^2 \\exp(\\alpha t)\\sin(\\beta t)\\sin(k x) \\right] $$\nFactoring out common terms, we obtain the final expression for the source term:\n$$ s(x,t) = \\exp(\\alpha t) \\left[ \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) \\sin(k x) + a k \\sin(\\beta t) \\cos(k x) + \\nu k^2 \\sin(\\beta t) \\sin(k x) \\right] $$\nThis source term, by construction, ensures that the given $u(x,t)$ is an exact solution to the PDE. Note that for the remainder of the problem, this expression for $s(x,t)$ is not directly used. Instead, we use the property that the full right-hand side, when evaluated on the exact solution, simplifies to its time derivative.\n\n**Task 2 & 3: Residual Calculation for Runge-Kutta Methods**\n\nThe core of the problem is to compute the one-step residual, which measures the local truncation error of the time integrator. The general form of the update along the exact solution is:\n$$ u^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i\\,F(x,t_n + c_i \\Delta t) $$\nAs established by the problem statement for MMS verification of a time-integrator, the right-hand side function $F(x,t)$ is evaluated on the exact solution path, which simplifies to the exact time derivative:\n$$ F(x, t) = -a \\frac{\\partial u}{\\partial x}(x,t) + \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t) + s(x,t) = \\frac{\\partial u}{\\partial t}(x,t) $$\nThus, the RK update is computed as an integration of the known function $\\partial u / \\partial t$ over the time step $[t_n, t_{n+1}]$:\n$$ u^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i \\frac{\\partial u}{\\partial t}(x,t_n + c_i \\Delta t) $$\nThe residual norm is the discrete $L^2$ norm of the difference between this numerical approximation and the exact solution at the end of the step, $u(x, t_{n+1})$:\n$$ \\mathcal{R}(\\Delta t) = \\sqrt{ \\frac{1}{N} \\sum_{j=1}^{N} \\left( u^{\\text{RK}}(x_j) - u(x_j, t_n + \\Delta t) \\right)^2 } $$\nwhere the spatial grid is $x_j = (j-1) \\frac{2\\pi}{N}$ for $j=1, \\dots, N$. The calculation starts at $t_n = 0$.\n\nThe specific updates for the required methods with $t_n=0$ are:\n- **Forward Euler**: $m=1, b_1=1, c_1=0$.\n$$ u^{\\text{FE}}(x) = u(x,0) + \\Delta t \\, \\frac{\\partial u}{\\partial t}(x,0) $$\n- **Explicit Midpoint**: $m=1, b_1=1, c_1=1/2$.\n$$ u^{\\text{Midpoint}}(x) = u(x,0) + \\Delta t \\, \\frac{\\partial u}{\\partial t}(x, \\Delta t/2) $$\nThis corresponds to using the one-point midpoint quadrature rule to approximate $\\int_{0}^{\\Delta t} (\\partial u / \\partial t) dt$.\n- **Classical RK4**: $m=4, b=(\\frac{1}{6}, \\frac{1}{3}, \\frac{1}{3}, \\frac{1}{6}), c=(0, \\frac{1}{2}, \\frac{1}{2}, 1)$.\n$$ u^{\\text{RK4}}(x) = u(x,0) + \\Delta t \\left[ \\frac{1}{6}\\frac{\\partial u}{\\partial t}(x,0) + \\frac{1}{3}\\frac{\\partial u}{\\partial t}(x,\\Delta t/2) + \\frac{1}{3}\\frac{\\partial u}{\\partial t}(x,\\Delta t/2) + \\frac{1}{6}\\frac{\\partial u}{\\partial t}(x,\\Delta t) \\right] $$\nThis corresponds to using Simpson's rule for the integral.\n\n**Task 4 & 5: Empirical Order and Superconvergence**\n\nThe empirical order of accuracy $p_{\\text{est}}$ is computed using the residuals from two different time steps, $\\Delta t_1$ and $\\Delta t_2$:\n$$ p_{\\text{est}} = \\frac{\\log(\\mathcal{R}(\\Delta t_1) / \\mathcal{R}(\\Delta t_2))}{\\log(\\Delta t_1 / \\Delta t_2)} $$\nFor the final test case, a special condition is investigated. With $\\alpha=0$, the solution becomes purely oscillatory in time: $u(x,t) = \\sin(\\beta t)\\sin(k x)$. If we choose $\\Delta t$ such that $\\beta \\Delta t = \\pi$, an interesting cancellation occurs. For $t_n=0$ and $\\Delta t_{special} = \\pi/\\beta$:\n- The exact solution at $t_n=0$ is $u(x,0) = \\sin(0)\\sin(kx) = 0$.\n- The exact solution at $t_n+\\Delta t_{special}$ is $u(x,\\pi/\\beta) = \\sin(\\beta \\cdot \\pi/\\beta)\\sin(kx) = \\sin(\\pi)\\sin(kx) = 0$.\nThe time derivative is $\\partial u/\\partial t = \\beta\\cos(\\beta t)\\sin(kx)$. The RK4 update involves samples at $t=0, \\Delta t/2, \\Delta t$.\n- At $t=0$, $\\partial u/\\partial t = \\beta\\cos(0)\\sin(kx)=\\beta\\sin(kx)$.\n- At $t=\\Delta t_{special}/2=\\pi/(2\\beta)$, $\\partial u/\\partial t = \\beta\\cos(\\pi/2)\\sin(kx)=0$.\n- At $t=\\Delta t_{special}=\\pi/\\beta$, $\\partial u/\\partial t = \\beta\\cos(\\pi)\\sin(kx)=-\\beta\\sin(kx)$.\nThe RK4 increment becomes proportional to $\\frac{1}{6}(\\beta\\sin(kx)) + \\frac{2}{3}(0) + \\frac{1}{6}(-\\beta\\sin(kx)) = 0$.\nThus, for this specific time step, both the exact solution and the RK4 approximation are zero at the end of the step, starting from zero. The residual $\\mathcal{R}(\\Delta t_{special})$ is exactly zero (up to machine precision). This leads to an \"infinite\" calculated order for the step pair including $\\Delta t_{special}$, indicating superconvergence. The implementation must handle the case of a zero residual to avoid numerical errors like $\\log(0)$.\n\nThe following program implements these calculations for the three specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    # Dictionary defining the Butcher tableau coefficients for the RK methods.\n    # The structure is method_name: {'b': weights, 'c': abscissae}.\n    RK_METHODS = {\n        \"fe\": {\"b\": np.array([1.0]), \"c\": np.array([0.0])},\n        \"midpoint\": {\"b\": np.array([1.0]), \"c\": np.array([0.5])},\n        \"rk4\": {\n            \"b\": np.array([1/6, 1/3, 1/3, 1/6]),\n            \"c\": np.array([0.0, 0.5, 0.5, 1.0]),\n        },\n    }\n\n    # Test suite parameters. Each tuple contains:\n    # (a, nu, alpha, beta, k, N, method_key, [dt1, dt2, dt3], task_type)\n    test_cases = [\n        (1.0, 0.05, 0.1, 2.0, 2, 256, \"rk4\", [0.2, 0.1, 0.05], \"order\"),\n        (0.0, 0.0, 0.2, 1.5, 3, 256, \"midpoint\", [0.3, 0.15, 0.075], \"order\"),\n        (0.5, 0.01, 0.0, 4 * np.pi, 4, 256, \"rk4\", [0.5, 0.25, 0.125], \"super\"),\n    ]\n\n    final_results = []\n\n    for params in test_cases:\n        a_p, nu_p, alpha, beta, k, N, method_key, dts, task_type = params\n        \n        # Spatial grid (uniform on periodic domain [0, 2*pi])\n        x = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n        # Define the manufactured solution u(x,t) and its time derivative du/dt\n        # Note: These are vectorized to operate on the grid 'x'.\n        u_func = lambda t_val: np.exp(alpha * t_val) * np.sin(beta * t_val) * np.sin(k * x)\n        dudt_func = lambda t_val: np.exp(alpha * t_val) * (\n            alpha * np.sin(beta * t_val) + beta * np.cos(beta * t_val)\n        ) * np.sin(k * x)\n\n        residuals = []\n        for dt in dts:\n            # Get RK method coefficients\n            b = RK_METHODS[method_key][\"b\"]\n            c = RK_METHODS[method_key][\"c\"]\n\n            # Exact solution at t_n=0 and t_{n+1}=dt\n            u_exact_tn = u_func(0)\n            u_exact_tn1 = u_func(dt)\n            \n            # Calculate the Runge-Kutta update\n            # u^RK = u(t_n) + dt * sum(b_i * F(t_n + c_i*dt))\n            # where F = du/dt on the exact trajectory\n            rk_sum_term = np.zeros_like(x)\n            for i in range(len(b)):\n                t_stage = 0 + c[i] * dt  # t_n = 0\n                rk_sum_term += b[i] * dudt_func(t_stage)\n            \n            u_rk = u_exact_tn + dt * rk_sum_term\n            \n            # Calculate the L2 norm of the residual\n            # R = ||u^RK - u(t_{n+1})||_L2\n            error_sq = (u_rk - u_exact_tn1)**2\n            l2_norm = np.sqrt(np.mean(error_sq))\n            residuals.append(l2_norm)\n\n        # Unpack time steps and residuals\n        dt1, dt2, dt3 = dts\n        res1, res2, res3 = residuals\n\n        # Calculate empirical order p_est = log(R1/R2) / log(dt1/dt2)\n        # Handle cases where residual is zero (perfect cancellation)\n        if res2 == 0:\n            p_12 = np.inf\n        else:\n            p_12 = np.log(res1 / res2) / np.log(dt1 / dt2)\n\n        if res3 == 0:\n            p_23 = np.inf  # This case is not expected here\n        elif res2 == 0:\n            p_23 = -np.inf\n        else:\n            p_23 = np.log(res2 / res3) / np.log(dt2 / dt3)\n\n        if task_type == \"order\":\n            final_results.extend([p_12, p_23])\n        elif task_type == \"super\":\n            # Nominal order for RK4 is 4. Superconvergence threshold is 4.5\n            nominal_order = 4.0\n            super_threshold = 0.5\n            is_super_12 = p_12 > (nominal_order + super_threshold)\n            is_super_23 = p_23 > (nominal_order + super_threshold)\n            final_results.extend([is_super_12, is_super_23])\n            \n    # Format and print the final output string exactly as required\n    # Booleans are converted to lowercase strings 'true'/'false'\n    formatted_results = []\n    for item in final_results:\n        if isinstance(item, bool) or isinstance(item, np.bool_):\n            formatted_results.append(str(item).lower())\n        else:\n            formatted_results.append(str(item))\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The utility of MMS extends beyond verifying the order of interior discretization to the critical task of validating boundary condition implementations. In this practice , you will work with the Stokes equations to see how a manufactured velocity and pressure field can be used to derive the exact analytical traction vector on a boundary. This provides the necessary data to rigorously test the implementation of complex Neumann or Robin-type boundary conditions, which are essential in fluid mechanics simulations.",
            "id": "3376865",
            "problem": "Consider the steady, incompressible viscous flow of a Newtonian fluid governed by the Stokes equations as the low Reynolds number limit of the Navier–Stokes equations. The foundational principles are the conservation of linear momentum and mass. The conservation of linear momentum for a Newtonian fluid with dynamic viscosity $\\mu$ states that the balance between pressure gradients, viscous stresses, and body forces $\\mathbf{f}$ is given by the partial differential equation\n$$\n-\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} = \\mathbf{0},\n$$\nand the conservation of mass for an incompressible fluid gives\n$$\n\\nabla \\cdot \\mathbf{u} = 0.\n$$\nThe Cauchy stress tensor for a Newtonian fluid is\n$$\n\\boldsymbol{\\sigma} = -p \\mathbf{I} + \\mu\\left(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top\\right),\n$$\nand the traction vector acting on a boundary with outward unit normal $\\mathbf{n}$ is defined as\n$$\n\\mathbf{t} = \\boldsymbol{\\sigma} \\cdot \\mathbf{n}.\n$$\nIn the Method of Manufactured Solutions (MMS), one specifies a smooth, divergence-free velocity field $\\mathbf{u}$ and a pressure field $p$ a priori, computes the corresponding body force $\\mathbf{f}$ that makes these fields satisfy the governing equations exactly, and then derives the analytical boundary data (e.g., traction) to verify Neumann or Robin boundary condition implementations. The Robin boundary condition is posed in the mixed form\n$$\n\\alpha \\,\\mathbf{u} + \\beta \\,\\mathbf{t} = \\mathbf{g},\n$$\nwhere $\\alpha$ and $\\beta$ are prescribed coefficients and $\\mathbf{g}$ is the target boundary function that should be imposed; this condition generalizes Dirichlet and Neumann types when $\\beta = 0$ or $\\alpha = 0$, respectively.\n\nLet the domain be the unit square $\\Omega = [0,1]\\times[0,1]$. Manufacture the following smooth divergence-free velocity field and pressure field:\n$$\n\\mathbf{u}(x,y) = \\begin{bmatrix}\n\\sin(\\pi x)\\,\\sin(\\pi y) \\\\\n\\cos(\\pi x)\\,\\cos(\\pi y)\n\\end{bmatrix}, \\qquad\np(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y).\n$$\nUsing only the governing equations and definitions stated above as the fundamental base, derive expressions for the required body force $\\mathbf{f}(x,y)$ and for the traction vector $\\mathbf{t}(x,y)$ on each portion of the boundary $\\partial\\Omega$, where the outward unit normal is given by $\\mathbf{n} = (-1,0)$ at $x=0$, $\\mathbf{n} = (1,0)$ at $x=1$, $\\mathbf{n} = (0,-1)$ at $y=0$, and $\\mathbf{n} = (0,1)$ at $y=1$. Then derive the manufactured Robin target $\\mathbf{g}(x,y)$ for given coefficients $\\alpha$ and $\\beta$ using $\\mathbf{g} = \\alpha \\mathbf{u} + \\beta \\mathbf{t}$.\n\nYour program must implement these derived expressions exactly and evaluate them for the following test suite. All answers must be expressed in the requested units and numerical values reported by your program must be in the specified format. Units: velocity components $\\mathbf{u}$ in meters per second (m/s), pressure $p$ in Pascals (Pa), viscosity $\\mu$ in Pascal-seconds (Pa·s), traction components $\\mathbf{t}$ in Pascals (Pa), and body-force components $\\mathbf{f}$ in newtons per cubic meter (N/m$^3$). Angles are not used, and therefore no angle unit is required.\n\nTest suite specification:\n- Boundary test $1$ (left boundary): viscosity $\\mu = 0.7$ Pa·s, coefficients $\\alpha = 3.0$ Pa·s/m, $\\beta = 0.5$ (dimensionless), location $(x,y) = (0,0.6)$ with outward unit normal $\\mathbf{n} = (-1,0)$. Compute the traction components $\\mathbf{t}(x,y)$ and the Robin target $\\mathbf{g}(x,y)$.\n- Boundary test $2$ (top boundary): viscosity $\\mu = 1.0$ Pa·s, coefficients $\\alpha = 2.0$ Pa·s/m, $\\beta = 1.0$ (dimensionless), location $(x,y) = (0.3,1)$ with outward unit normal $\\mathbf{n} = (0,1)$. Compute the traction components $\\mathbf{t}(x,y)$ and the Robin target $\\mathbf{g}(x,y)$.\n- Boundary test $3$ (right boundary): viscosity $\\mu = 2.5$ Pa·s, coefficients $\\alpha = 0.0$ Pa·s/m, $\\beta = 1.0$ (dimensionless), location $(x,y) = (1,0.25)$ with outward unit normal $\\mathbf{n} = (1,0)$. Compute the traction components $\\mathbf{t}(x,y)$ and the Robin target $\\mathbf{g}(x,y)$.\n- Interior test $4$: viscosity $\\mu = 0.7$ Pa·s, location $(x,y) = (0.1,0.9)$. Compute the body force components $\\mathbf{f}(x,y)$ and the Euclidean norm of the residual vector $\\mathbf{r}(x,y) = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f}$, which should evaluate to $0$ for a correct manufactured solution.\n- Interior test $5$: viscosity $\\mu = 1.8$ Pa·s, location $(x,y) = (0.75,0.35)$. Compute the body force components $\\mathbf{f}(x,y)$ and the Euclidean norm of $\\mathbf{r}(x,y)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test’s result is itself a list:\n- For each boundary test, output the list $[\\;t_x,\\;t_y,\\;g_x,\\;g_y\\;]$ with all components as floating-point numbers in Pascals for $t_x,t_y$ and Pascals for $g_x,g_y$.\n- For each interior test, output the list $[\\;f_x,\\;f_y,\\;\\|\\mathbf{r}\\|\\;]$ with $f_x,f_y$ in newtons per cubic meter and $\\|\\mathbf{r}\\|$ as a floating-point number.\n\nFor example, the final output format must be\n$$\n[\\,[\\text{case1\\_values}],\\,[\\text{case2\\_values}],\\,[\\text{case3\\_values}],\\,[\\text{case4\\_values}],\\,[\\text{case5\\_values}]\\,],\n$$\nwith no additional text.",
            "solution": "The problem is evaluated as valid. It presents a well-posed, scientifically grounded task within the standard framework of the Method of Manufactured Solutions (MMS) for the Stokes equations. All necessary definitions, equations, and data are provided, and they are internally consistent. The manufactured velocity field is confirmed to be divergence-free, a critical self-consistency check.\n\nThe solution proceeds by first deriving the analytical expressions for the body force $\\mathbf{f}$, the traction vector $\\mathbf{t}$, and the Robin boundary target $\\mathbf{g}$. These expressions are then implemented to compute the required values for the specified test cases.\n\n### Step 1: Verification of Incompressibility\nThe manufactured velocity field is given by\n$$\n\\mathbf{u}(x,y) = \\begin{bmatrix} u(x,y) \\\\ v(x,y) \\end{bmatrix} = \\begin{bmatrix} \\sin(\\pi x)\\,\\sin(\\pi y) \\\\ \\cos(\\pi x)\\,\\cos(\\pi y) \\end{bmatrix}.\n$$\nThe divergence of $\\mathbf{u}$ must be zero for an incompressible fluid: $\\nabla \\cdot \\mathbf{u} = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} = 0$.\nThe partial derivatives are:\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} (\\sin(\\pi x)\\,\\sin(\\pi y)) = \\pi \\cos(\\pi x)\\,\\sin(\\pi y)\n$$\n$$\n\\frac{\\partial v}{\\partial y} = \\frac{\\partial}{\\partial y} (\\cos(\\pi x)\\,\\cos(\\pi y)) = -\\pi \\cos(\\pi x)\\,\\sin(\\pi y)\n$$\nThus, the divergence is\n$$\n\\nabla \\cdot \\mathbf{u} = \\pi \\cos(\\pi x)\\,\\sin(\\pi y) - \\pi \\cos(\\pi x)\\,\\sin(\\pi y) = 0.\n$$\nThe velocity field is indeed divergence-free, validating a key premise of the problem.\n\n### Step 2: Derivation of the Manufactured Body Force $\\mathbf{f}$\nThe body force $\\mathbf{f}$ is determined by rearranging the Stokes momentum equation: $\\mathbf{f} = \\nabla p - \\mu \\nabla^2 \\mathbf{u}$.\n\nFirst, we compute the pressure gradient $\\nabla p$ for $p(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y)$:\n$$\n\\nabla p = \\begin{bmatrix} \\frac{\\partial p}{\\partial x} \\\\ \\frac{\\partial p}{\\partial y} \\end{bmatrix} = \\begin{bmatrix} \\pi \\cos(\\pi x)\\,\\cos(\\pi y) \\\\ -\\pi \\sin(\\pi x)\\,\\sin(\\pi y) \\end{bmatrix}.\n$$\n\nNext, we compute the Laplacian of the velocity field, $\\nabla^2 \\mathbf{u} = \\begin{bmatrix} \\nabla^2 u \\\\ \\nabla^2 v \\end{bmatrix}$.\nFor the $x$-component $u(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$:\n$$\n\\frac{\\partial^2 u}{\\partial x^2} = -\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y), \\qquad \\frac{\\partial^2 u}{\\partial y^2} = -\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y)\n$$\n$$\n\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = -2\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y) = -2\\pi^2 u.\n$$\nFor the $y$-component $v(x,y) = \\cos(\\pi x)\\,\\cos(\\pi y)$:\n$$\n\\frac{\\partial^2 v}{\\partial x^2} = -\\pi^2 \\cos(\\pi x)\\,\\cos(\\pi y), \\qquad \\frac{\\partial^2 v}{\\partial y^2} = -\\pi^2 \\cos(\\pi x)\\,\\cos(\\pi y)\n$$\n$$\n\\nabla^2 v = \\frac{\\partial^2 v}{\\partial x^2} + \\frac{\\partial^2 v}{\\partial y^2} = -2\\pi^2 \\cos(\\pi x)\\,\\cos(\\pi y) = -2\\pi^2 v.\n$$\nSo, the vector Laplacian is $\\nabla^2 \\mathbf{u} = -2\\pi^2 \\mathbf{u}$.\n\nCombining these terms, the body force $\\mathbf{f} = [f_x, f_y]^\\top$ is:\n$$\n\\mathbf{f} = \\nabla p - \\mu(-2\\pi^2 \\mathbf{u}) = \\nabla p + 2\\mu\\pi^2 \\mathbf{u}\n$$\n$$\nf_x(x,y) = \\pi \\cos(\\pi x)\\,\\cos(\\pi y) + 2\\mu\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y)\n$$\n$$\nf_y(x,y) = -\\pi \\sin(\\pi x)\\,\\sin(\\pi y) + 2\\mu\\pi^2 \\cos(\\pi x)\\,\\cos(\\pi y)\n$$\nBy this construction, the residual $\\mathbf{r} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f}$ is identically zero, so its norm $\\|\\mathbf{r}\\|$ is $0$.\n\n### Step 3: Derivation of the Traction Vector $\\mathbf{t}$\nThe traction vector is $\\mathbf{t} = \\boldsymbol{\\sigma} \\cdot \\mathbf{n}$, where $\\boldsymbol{\\sigma} = -p \\mathbf{I} + \\mu(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top)$.\n\nFirst, we find the velocity gradient tensor $\\nabla \\mathbf{u}$:\n$$\n\\nabla \\mathbf{u} = \\begin{bmatrix} \\frac{\\partial u}{\\partial x} & \\frac{\\partial u}{\\partial y} \\\\ \\frac{\\partial v}{\\partial x} & \\frac{\\partial v}{\\partial y} \\end{bmatrix} = \\pi \\begin{bmatrix} \\cos(\\pi x)\\sin(\\pi y) & \\sin(\\pi x)\\cos(\\pi y) \\\\ -\\sin(\\pi x)\\cos(\\pi y) & -\\cos(\\pi x)\\sin(\\pi y) \\end{bmatrix}.\n$$\nThe symmetric part of the rate of strain tensor is $\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top$:\n$$\n\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top = \\pi \\begin{bmatrix} 2\\cos(\\pi x)\\sin(\\pi y) & 0 \\\\ 0 & -2\\cos(\\pi x)\\sin(\\pi y) \\end{bmatrix}.\n$$\nThe Cauchy stress tensor $\\boldsymbol{\\sigma}$ has components:\n$$\n\\sigma_{xx} = -p + 2\\mu\\pi\\cos(\\pi x)\\sin(\\pi y) = -\\sin(\\pi x)\\cos(\\pi y) + 2\\mu\\pi\\cos(\\pi x)\\sin(\\pi y)\n$$\n$$\n\\sigma_{yy} = -p - 2\\mu\\pi\\cos(\\pi x)\\sin(\\pi y) = -\\sin(\\pi x)\\cos(\\pi y) - 2\\mu\\pi\\cos(\\pi x)\\sin(\\pi y)\n$$\n$$\n\\sigma_{xy} = \\sigma_{yx} = 0.\n$$\nThe traction vector $\\mathbf{t} = [t_x, t_y]^\\top$ is computed as $\\mathbf{t} = \\boldsymbol{\\sigma}\\mathbf{n} = [\\sigma_{xx}n_x + \\sigma_{xy}n_y, \\sigma_{yx}n_x + \\sigma_{yy}n_y]^\\top$. Since the off-diagonal stresses are zero, this simplifies to $t_x = \\sigma_{xx} n_x$ and $t_y = \\sigma_{yy} n_y$.\n\nThe specific expressions for traction on each boundary are:\n-   **Left boundary ($x=0, \\mathbf{n}=(-1,0)$):**\n    $\\sigma_{xx}(0,y) = 2\\mu\\pi\\sin(\\pi y)$.\n    $t_x(0,y) = \\sigma_{xx}(0,y) \\cdot (-1) = -2\\mu\\pi\\sin(\\pi y)$.\n    $t_y(0,y) = 0$.\n-   **Right boundary ($x=1, \\mathbf{n}=(1,0)$):**\n    $\\sigma_{xx}(1,y) = -2\\mu\\pi\\sin(\\pi y)$.\n    $t_x(1,y) = \\sigma_{xx}(1,y) \\cdot (1) = -2\\mu\\pi\\sin(\\pi y)$.\n    $t_y(1,y) = 0$.\n-   **Bottom boundary ($y=0, \\mathbf{n}=(0,-1)$):**\n    $\\sigma_{yy}(x,0) = -\\sin(\\pi x)$.\n    $t_x(x,0) = 0$.\n    $t_y(x,0) = \\sigma_{yy}(x,0) \\cdot (-1) = \\sin(\\pi x)$.\n-   **Top boundary ($y=1, \\mathbf{n}=(0,1)$):**\n    $\\sigma_{yy}(x,1) = \\sin(\\pi x)$.\n    $t_x(x,1) = 0$.\n    $t_y(x,1) = \\sigma_{yy}(x,1) \\cdot (1) = \\sin(\\pi x)$.\n\n### Step 4: Derivation of the Robin Target Function $\\mathbf{g}$\nThe Robin target function $\\mathbf{g}$ is defined as $\\mathbf{g} = \\alpha \\mathbf{u} + \\beta \\mathbf{t}$. Its components are:\n$$\ng_x = \\alpha u + \\beta t_x\n$$\n$$\ng_y = \\alpha v + \\beta t_y\n$$\nThese are computed on the boundary using the expressions for $\\mathbf{u}$ and $\\mathbf{t}$ evaluated at the specified location $(x,y)$.\n\n### Step 5: Algorithmic Implementation\nThe derived analytical expressions are directly implemented in Python using the `numpy` library for mathematical constants and functions.\n1.  A function `vel(x, y)` computes the velocity components $u$ and $v$.\n2.  A function `body_force(x, y, mu)` computes the body force components $f_x$ and $f_y$.\n3.  A function `traction(x, y, mu, n)` computes the traction components $t_x$ and $t_y$ using the stress tensor expressions and the given normal vector $\\mathbf{n}$.\n4.  The main script iterates through the specified test cases.\n    -   For boundary tests, it calls the `vel` and `traction` functions. It then combines their results using the given $\\alpha$ and $\\beta$ coefficients to calculate the Robin target $\\mathbf{g}$. The results $[t_x, t_y, g_x, g_y]$ are stored.\n    -   For interior tests, it calls the `body_force` function. The residual norm $\\|\\mathbf{r}\\|$ is known to be $0$ by construction, so this value is appended directly. The results $[f_x, f_y, \\|\\mathbf{r}\\|]$ are stored.\n5.  Finally, the collected results are formatted into a single string representing a list of lists, as specified by the problem, and printed to standard output.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Method of Manufactured Solutions problem for Stokes flow.\n    \"\"\"\n    pi = np.pi\n\n    def get_vel(x, y):\n        \"\"\"Computes the manufactured velocity field components.\"\"\"\n        px, py = pi * x, pi * y\n        u = np.sin(px) * np.sin(py)\n        v = np.cos(px) * np.cos(py)\n        return u, v\n\n    def get_body_force(x, y, mu):\n        \"\"\"Computes the manufactured body force components.\"\"\"\n        px, py = pi * x, pi * y\n        spx, cpx = np.sin(px), np.cos(px)\n        spy, cpy = np.sin(py), np.cos(py)\n        \n        fx = pi * cpx * cpy + 2 * mu * pi**2 * spx * spy\n        fy = -pi * spx * spy + 2 * mu * pi**2 * cpx * cpy\n        return fx, fy\n\n    def get_traction(x, y, mu, n):\n        \"\"\"Computes the traction vector components on a boundary.\"\"\"\n        nx, ny = n\n        px, py = pi * x, pi * y\n        spx, cpx = np.sin(px), np.cos(px)\n        spy, cpy = np.sin(py), np.cos(py)\n\n        sigma_xx = -spx * cpy + 2 * mu * pi * cpx * spy\n        sigma_yy = -spx * cpy - 2 * mu * pi * cpx * spy\n        \n        # sigma_xy is 0, so traction components are simplified\n        tx = sigma_xx * nx\n        ty = sigma_yy * ny\n        return tx, ty\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Boundary test 1 (left)\n        {'type': 'boundary', 'params': {'mu': 0.7, 'alpha': 3.0, 'beta': 0.5, 'x': 0.0, 'y': 0.6, 'n': (-1.0, 0.0)}},\n        # Boundary test 2 (top)\n        {'type': 'boundary', 'params': {'mu': 1.0, 'alpha': 2.0, 'beta': 1.0, 'x': 0.3, 'y': 1.0, 'n': (0.0, 1.0)}},\n        # Boundary test 3 (right)\n        {'type': 'boundary', 'params': {'mu': 2.5, 'alpha': 0.0, 'beta': 1.0, 'x': 1.0, 'y': 0.25, 'n': (1.0, 0.0)}},\n        # Interior test 4\n        {'type': 'interior', 'params': {'mu': 0.7, 'x': 0.1, 'y': 0.9}},\n        # Interior test 5\n        {'type': 'interior', 'params': {'mu': 1.8, 'x': 0.75, 'y': 0.35}},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'boundary':\n            params = case['params']\n            mu, alpha, beta, x, y, n = params['mu'], params['alpha'], params['beta'], params['x'], params['y'], params['n']\n            \n            u_val, v_val = get_vel(x, y)\n            tx_val, ty_val = get_traction(x, y, mu, n)\n            \n            gx_val = alpha * u_val + beta * tx_val\n            gy_val = alpha * v_val + beta * ty_val\n            \n            results.append([tx_val, ty_val, gx_val, gy_val])\n\n        elif case['type'] == 'interior':\n            params = case['params']\n            mu, x, y = params['mu'], params['x'], params['y']\n            \n            fx_val, fy_val = get_body_force(x, y, mu)\n            # The residual is zero by construction in the Method of Manufactured Solutions.\n            residual_norm = 0.0\n            \n            results.append([fx_val, fy_val, residual_norm])\n\n    # Final print statement in the exact required format.\n    # The default str() representation for a list provides the required spaces.\n    print(str(results).replace(\"], [\", \"],[\").replace(\" \", \"\"))\n\n\n```"
        },
        {
            "introduction": "Real-world fluid dynamics problems are often characterized by coupled physics and temperature-dependent material properties, which introduce non-linearities into the governing equations. This advanced practice  demonstrates how MMS can be used to verify solvers for such complex systems. You will manufacture a full set of flow and thermal fields and derive the corresponding source terms for both the momentum and energy equations, providing a rigorous test for your code's ability to handle variable-coefficient diffusion and physical coupling.",
            "id": "3376812",
            "problem": "Design a self-contained verification using the Method of Manufactured Solutions (MMS) for a steady, dimensionless, incompressible, two-dimensional flow with temperature-dependent dynamic viscosity and thermal conductivity. The manufactured fields are smooth and periodic in space over the square domain $\\Omega = [0,1]\\times[0,1]$. Angles in trigonometric functions must be interpreted in radians.\n\nThe governing equations are the steady incompressible momentum and energy equations in their standard divergence forms for a Newtonian fluid with temperature-dependent properties, namely:\n- Continuity: $\\nabla \\cdot \\boldsymbol{u} = 0$.\n- Momentum: $\\rho (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} = -\\nabla p + \\nabla\\cdot\\left(2\\,\\mu(T)\\,\\boldsymbol{S}(\\boldsymbol{u})\\right) + \\boldsymbol{f}$.\n- Energy (with viscous dissipation): $\\rho c_p\\,\\boldsymbol{u}\\cdot\\nabla T = \\nabla\\cdot\\left(k(T)\\,\\nabla T\\right) + \\Phi + Q$.\n\nHere $\\boldsymbol{u}=(u_x,u_y)$ is the velocity, $p$ is the pressure, $T$ is the temperature, $\\rho$ is the density, $c_p$ is the specific heat at constant pressure, $\\mu(T)$ is the dynamic viscosity, $k(T)$ is the thermal conductivity, $\\boldsymbol{S}(\\boldsymbol{u}) = \\tfrac{1}{2}\\left(\\nabla\\boldsymbol{u} + \\nabla\\boldsymbol{u}^\\top\\right)$ is the rate-of-strain tensor, and $\\Phi = 2\\,\\mu(T)\\,\\boldsymbol{S}:\\boldsymbol{S}$ is the viscous dissipation. All quantities are non-dimensionalized.\n\nManufacture the following smooth fields:\n- Streamfunction $\\psi(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$, which defines a divergence-free velocity via $\\boldsymbol{u}(x,y) = \\left(\\tfrac{\\partial \\psi}{\\partial y},\\,-\\tfrac{\\partial \\psi}{\\partial x}\\right)$.\n- Pressure $p(x,y) = \\sin(\\pi x)\\,\\sin(2\\pi y)$.\n- Temperature $T(x,y) = \\tfrac{1}{2}\\,\\sin(2\\pi x)\\,\\cos(\\pi y) + \\tfrac{1}{4}\\,x\\,y$.\n\nDefine temperature-dependent material properties that are strictly positive and strongly varying:\n- $\\mu(T) = \\mu_0 \\exp\\left(\\beta\\,T\\right)$.\n- $k(T) = k_0 \\exp\\left(\\alpha\\,T\\right)$.\n\nYour task:\n1) Starting from the fundamental laws above, construct source terms $\\boldsymbol{f}(x,y)$ in the momentum equation and $Q(x,y)$ in the energy equation so that the manufactured fields $\\boldsymbol{u},p,T$ satisfy the equations exactly for any parameter set $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha)$.\n2) Implement a program that, for each parameter set in the test suite below, evaluates the residuals of the momentum and energy equations when using your constructed $\\boldsymbol{f}$ and $Q$ at a common set of points in the domain and reports the maximum absolute residual as a single floating-point number for the case.\n\nResidual definitions to be evaluated at a point $(x,y)$:\n- Momentum residual vector: $\\boldsymbol{R}_m = \\rho(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nabla\\cdot\\left(2\\,\\mu(T)\\,\\boldsymbol{S}(\\boldsymbol{u})\\right) - \\boldsymbol{f}$.\n- Energy residual scalar: $R_e = \\rho c_p\\,\\boldsymbol{u}\\cdot\\nabla T - \\nabla\\cdot\\left(k(T)\\,\\nabla T\\right) - \\Phi - Q$.\n\nFor each case, compute:\n- The maximum over the specified points of the componentwise absolute values of $\\boldsymbol{R}_m$ and the absolute value of $R_e$.\n- Report, for that case, the single scalar equal to the maximum of these values.\n\nTest points (shared by all cases; angles in radians):\n- $(x,y) \\in \\{(0.25,0.40),\\,(0.73,0.90),\\,(0.01,0.99),\\,(0.50,0.50)\\}$.\n\nTest suite (each case specifies $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha)$):\n- Case A (moderate variability): $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha) = (1.0,\\,1.0,\\,0.3,\\,1.5,\\,0.7,\\,1.2)$.\n- Case B (strong variability with opposing trends): $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha) = (2.0,\\,0.5,\\,0.05,\\,3.0,\\,1.1,\\,-2.5)$.\n- Case C (constant properties): $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha) = (1.3,\\,2.2,\\,0.2,\\,0.0,\\,0.9,\\,0.0)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_A,r_B,r_C]$), where each $r_\\cdot$ is a floating-point number giving the maximum absolute residual for the corresponding case. The residuals are dimensionless numbers.\n\nAll computations must be performed in double precision. No user input is allowed, and no external files may be read or written. The implementation language and libraries are constrained as specified separately.",
            "solution": "We begin from the steady, incompressible, two-dimensional equations. The continuity equation $\\nabla\\cdot\\boldsymbol{u} = 0$ is identically satisfied by constructing the velocity from a streamfunction. We select the streamfunction $\\psi(x,y)=\\sin(\\pi x)\\sin(\\pi y)$ and define\n$$\n\\boldsymbol{u}(x,y)=\\left(\\frac{\\partial \\psi}{\\partial y},\\, -\\frac{\\partial \\psi}{\\partial x}\\right)\n= \\left(\\pi \\sin(\\pi x)\\cos(\\pi y),\\, -\\pi \\cos(\\pi x)\\sin(\\pi y)\\right).\n$$\nThis ensures $\\nabla\\cdot\\boldsymbol{u} = \\frac{\\partial u_x}{\\partial x} + \\frac{\\partial u_y}{\\partial y} = 0$ by construction.\n\nWe specify the pressure $p(x,y)=\\sin(\\pi x)\\sin(2\\pi y)$ so that the pressure gradient is nontrivial:\n$$\n\\nabla p = \\left(\\pi \\cos(\\pi x)\\sin(2\\pi y),\\, 2\\pi \\sin(\\pi x)\\cos(2\\pi y)\\right).\n$$\nWe manufacture the temperature\n$$\nT(x,y) = \\frac{1}{2}\\,\\sin(2\\pi x)\\,\\cos(\\pi y) + \\frac{1}{4}\\,x\\,y,\n$$\nso that it is smooth and yields nontrivial gradients and curvatures. The material properties are strictly positive and strongly varying with temperature:\n$$\n\\mu(T) = \\mu_0 \\exp(\\beta T), \\qquad k(T) = k_0 \\exp(\\alpha T),\n$$\nwith $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha)$ given per case.\n\nTo enforce that the manufactured fields satisfy the momentum equation identically, we rearrange the steady momentum equation for the body force $\\boldsymbol{f}$:\n$$\n\\boldsymbol{f} = \\rho (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nabla\\cdot\\left(2\\,\\mu(T)\\,\\boldsymbol{S}(\\boldsymbol{u})\\right).\n$$\nSimilarly, to enforce that the manufactured fields satisfy the energy equation identically, we rearrange for $Q$:\n$$\nQ = \\rho c_p\\,\\boldsymbol{u}\\cdot\\nabla T - \\nabla\\cdot\\left(k(T)\\,\\nabla T\\right) - \\Phi,\n$$\nwhere the viscous dissipation for a Newtonian incompressible fluid is $\\Phi = 2 \\mu(T)\\,\\boldsymbol{S}:\\boldsymbol{S}$.\n\nWe now compute all necessary derivatives analytically. First, the velocity gradient:\n$$\n\\nabla\\boldsymbol{u} =\n\\begin{bmatrix}\n\\frac{\\partial u_x}{\\partial x} & \\frac{\\partial u_x}{\\partial y} \\\\\n\\frac{\\partial u_y}{\\partial x} & \\frac{\\partial u_y}{\\partial y}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\pi^2 \\cos(\\pi x)\\cos(\\pi y) & -\\pi^2 \\sin(\\pi x)\\sin(\\pi y) \\\\\n\\pi^2 \\sin(\\pi x)\\sin(\\pi y) & -\\pi^2 \\cos(\\pi x)\\cos(\\pi y)\n\\end{bmatrix}.\n$$\nHence the symmetric rate-of-strain tensor is\n$$\n\\boldsymbol{S} = \\frac{1}{2}\\left(\\nabla\\boldsymbol{u} + \\nabla\\boldsymbol{u}^\\top\\right)\n=\n\\begin{bmatrix}\n\\pi^2 \\cos(\\pi x)\\cos(\\pi y) & 0 \\\\\n0 & -\\pi^2 \\cos(\\pi x)\\cos(\\pi y)\n\\end{bmatrix}.\n$$\nThe off-diagonal components cancel because $\\tfrac{1}{2}\\left(\\tfrac{\\partial u_x}{\\partial y}+\\tfrac{\\partial u_y}{\\partial x}\\right) = \\tfrac{1}{2}\\left(-\\pi^2 \\sin(\\pi x)\\sin(\\pi y)+\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\\right)=0$.\nTherefore\n$$\n\\boldsymbol{S}:\\boldsymbol{S} = \\left(\\pi^2 \\cos(\\pi x)\\cos(\\pi y)\\right)^2 + \\left(-\\pi^2 \\cos(\\pi x)\\cos(\\pi y)\\right)^2 = 2\\pi^4 \\cos^2(\\pi x)\\cos^2(\\pi y),\n$$\nand the viscous dissipation becomes\n$$\n\\Phi = 2 \\mu(T)\\,\\boldsymbol{S}:\\boldsymbol{S} = 4\\,\\mu(T)\\,\\pi^4 \\cos^2(\\pi x)\\cos^2(\\pi y).\n$$\n\nFor the convection of velocity we compute $(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u}$ componentwise:\n$$\n(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} =\n\\begin{bmatrix}\nu_x \\frac{\\partial u_x}{\\partial x} + u_y \\frac{\\partial u_x}{\\partial y} \\\\\nu_x \\frac{\\partial u_y}{\\partial x} + u_y \\frac{\\partial u_y}{\\partial y}\n\\end{bmatrix}.\n$$\n\nThe viscous term requires the divergence of $2\\mu(T)\\boldsymbol{S}$. With $\\boldsymbol{S}$ diagonal, only $S_{11}$ and $S_{22}$ contribute. Define $g(x,y) = 2\\pi^2 \\cos(\\pi x)\\cos(\\pi y)$. Then\n$$\n2\\,\\mu(T)\\,S_{11} = \\mu(T)\\,g(x,y), \\qquad 2\\,\\mu(T)\\,S_{22} = -\\mu(T)\\,g(x,y),\n$$\nand hence\n$$\n\\left[\\nabla\\cdot(2\\,\\mu \\boldsymbol{S})\\right]_x = \\frac{\\partial}{\\partial x}\\left(\\mu\\,g\\right) + \\frac{\\partial}{\\partial y}\\left(0\\right) = \\mu_x g + \\mu\\,g_x,\n$$\n$$\n\\left[\\nabla\\cdot(2\\,\\mu \\boldsymbol{S})\\right]_y = \\frac{\\partial}{\\partial x}\\left(0\\right) + \\frac{\\partial}{\\partial y}\\left(-\\mu\\,g\\right) = -\\mu_y g - \\mu\\,g_y.\n$$\nUsing the chain rule for $\\mu(T)=\\mu_0 e^{\\beta T}$, we have $\\mu_x = \\mu\\,\\beta\\,T_x$ and $\\mu_y = \\mu\\,\\beta\\,T_y$. The derivatives of $g$ are\n$$\ng_x = -2\\pi^3 \\sin(\\pi x)\\cos(\\pi y), \\qquad g_y = -2\\pi^3 \\cos(\\pi x)\\sin(\\pi y).\n$$\n\nFor the temperature, its derivatives are\n$$\nT_x = \\pi \\cos(2\\pi x)\\cos(\\pi y) + \\frac{1}{4} y, \\qquad\nT_y = -\\frac{1}{2}\\pi \\sin(2\\pi x)\\sin(\\pi y) + \\frac{1}{4} x,\n$$\n$$\nT_{xx} = - (2\\pi)^2 \\frac{1}{2}\\,\\sin(2\\pi x)\\cos(\\pi y) = -2\\pi^2 \\sin(2\\pi x)\\cos(\\pi y),\n$$\n$$\nT_{yy} = - \\frac{1}{2}\\pi^2 \\sin(2\\pi x)\\cos(\\pi y).\n$$\nThus\n$$\nT_{xx} + T_{yy} = -\\frac{5}{2}\\pi^2 \\sin(2\\pi x)\\cos(\\pi y).\n$$\nThe temperature convection is $\\boldsymbol{u}\\cdot\\nabla T = u_x T_x + u_y T_y$.\n\nFor the variable conductivity diffusion, we use\n$$\n\\nabla\\cdot(k(T)\\nabla T) = \\frac{\\partial}{\\partial x}\\left(k T_x\\right) + \\frac{\\partial}{\\partial y}\\left(k T_y\\right)\n= k \\left(T_{xx} + T_{yy} + \\alpha\\left(T_x^2 + T_y^2\\right)\\right),\n$$\nsince $k_x = k\\,\\alpha\\,T_x$ and $k_y = k\\,\\alpha\\,T_y$ for $k(T)=k_0 e^{\\alpha T}$.\n\nTherefore, the manufactured source terms that make the chosen $(\\boldsymbol{u},p,T)$ an exact solution are:\n$$\n\\boldsymbol{f}(x,y) = \\rho (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\begin{bmatrix}\\mu_x g + \\mu g_x \\\\ -\\mu_y g - \\mu g_y\\end{bmatrix},\n$$\n$$\nQ(x,y) = \\rho c_p \\,\\boldsymbol{u}\\cdot\\nabla T - k\\left(T_{xx}+T_{yy} + \\alpha\\left(T_x^2 + T_y^2\\right)\\right) - 4\\,\\mu\\,\\pi^4 \\cos^2(\\pi x)\\cos^2(\\pi y).\n$$\n\nAlgorithmic design for the program:\n- For each parameter set $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha)$ and each test point $(x,y)$, evaluate:\n  - $\\boldsymbol{u}$ and its gradient, then $(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u}$.\n  - $p$ gradient $\\nabla p$.\n  - $T$, $T_x$, $T_y$, $T_{xx}$, $T_{yy}$.\n  - $\\mu(T)$, $k(T)$ and their implicit derivatives via $\\mu_x = \\mu \\beta T_x$, $\\mu_y = \\mu \\beta T_y$; compute $g$, $g_x$, $g_y$; assemble $\\nabla\\cdot(2\\mu \\boldsymbol{S})$ using the simplified form above.\n  - $\\Phi = 4\\,\\mu\\,\\pi^4 \\cos^2(\\pi x)\\cos^2(\\pi y)$.\n- Construct $\\boldsymbol{f}$ and $Q$ from the formulas above.\n- Form residuals:\n  - Momentum residual $\\boldsymbol{R}_m = \\rho(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nabla\\cdot(2\\mu \\boldsymbol{S}) - \\boldsymbol{f}$.\n  - Energy residual $R_e = \\rho c_p\\,\\boldsymbol{u}\\cdot\\nabla T - \\nabla\\cdot(k \\nabla T) - \\Phi - Q$.\n- For each case, compute the maximum absolute residual across all components and points:\n  - $\\max\\left(\\max_{(x,y)} |R_{m,x}|,\\, \\max_{(x,y)} |R_{m,y}|,\\, \\max_{(x,y)} |R_e|\\right)$.\n- Output across the three cases as a single line $[r_A,r_B,r_C]$.\n\nBecause the source terms are constructed exactly from the governing equations and manufactured fields, the residuals should be at the level of floating-point roundoff, demonstrating consistency of the variable-coefficient differential operators with the MMS construction.",
            "answer": "```python\nimport numpy as np\n\ndef manufactured_fields(x, y):\n    pi = np.pi\n    # Streamfunction and derived velocity\n    ux = pi * np.sin(pi * x) * np.cos(pi * y)\n    uy = -pi * np.cos(pi * x) * np.sin(pi * y)\n    # Velocity gradients\n    dux_dx = pi**2 * np.cos(pi * x) * np.cos(pi * y)\n    dux_dy = -pi**2 * np.sin(pi * x) * np.sin(pi * y)\n    duy_dx = pi**2 * np.sin(pi * x) * np.sin(pi * y)\n    duy_dy = -pi**2 * np.cos(pi * x) * np.cos(pi * y)\n    # Symmetric strain S and invariants\n    S11 = dux_dx\n    S22 = duy_dy\n    S12 = 0.5 * (dux_dy + duy_dx)  # will be zero analytically\n    # For viscous dissipation, S:S\n    S_contract = S11**2 + 2.0 * S12**2 + S22**2\n\n    # Pressure and gradient\n    dp_dx = pi * np.cos(pi * x) * np.sin(2.0 * pi * y)\n    dp_dy = 2.0 * pi * np.sin(pi * x) * np.cos(2.0 * pi * y)\n\n    # Temperature and derivatives\n    T = 0.5 * np.sin(2.0 * pi * x) * np.cos(pi * y) + 0.25 * x * y\n    Tx = pi * np.cos(2.0 * pi * x) * np.cos(pi * y) + 0.25 * y\n    Ty = -0.5 * pi * np.sin(2.0 * pi * x) * np.sin(pi * y) + 0.25 * x\n    Txx = -2.0 * pi**2 * np.sin(2.0 * pi * x) * np.cos(pi * y)\n    Tyy = -0.5 * pi**2 * np.sin(2.0 * pi * x) * np.cos(pi * y)\n\n    # Convection of velocity (u · ∇)u\n    conv_u_x = ux * dux_dx + uy * dux_dy\n    conv_u_y = ux * duy_dx + uy * duy_dy\n\n    # g for viscous divergence and its derivatives\n    g = 2.0 * pi**2 * np.cos(pi * x) * np.cos(pi * y)\n    gx = -2.0 * pi**3 * np.sin(pi * x) * np.cos(pi * y)\n    gy = -2.0 * pi**3 * np.cos(pi * x) * np.sin(pi * y)\n\n    return {\n        \"ux\": ux, \"uy\": uy,\n        \"dux_dx\": dux_dx, \"dux_dy\": dux_dy, \"duy_dx\": duy_dx, \"duy_dy\": duy_dy,\n        \"S11\": S11, \"S22\": S22, \"S12\": S12, \"S_contract\": S_contract,\n        \"dp_dx\": dp_dx, \"dp_dy\": dp_dy,\n        \"T\": T, \"Tx\": Tx, \"Ty\": Ty, \"Txx\": Txx, \"Tyy\": Tyy,\n        \"conv_u_x\": conv_u_x, \"conv_u_y\": conv_u_y,\n        \"g\": g, \"gx\": gx, \"gy\": gy\n    }\n\ndef properties_and_sources(x, y, rho, cp, mu0, beta, k0, alpha):\n    fld = manufactured_fields(x, y)\n    pi = np.pi\n\n    # Temperature-dependent properties\n    T = fld[\"T\"]\n    mu = mu0 * np.exp(beta * T)\n    k = k0 * np.exp(alpha * T)\n\n    # Implicit derivatives via chain rule\n    mu_x = mu * beta * fld[\"Tx\"]\n    mu_y = mu * beta * fld[\"Ty\"]\n\n    # Divergence of 2 mu S using simplified diagonal form\n    g = fld[\"g\"]; gx = fld[\"gx\"]; gy = fld[\"gy\"]\n    div2muS_x = mu_x * g + mu * gx\n    div2muS_y = - (mu_y * g + mu * gy)\n\n    # Momentum source term\n    conv_u_x = fld[\"conv_u_x\"]; conv_u_y = fld[\"conv_u_y\"]\n    dp_dx = fld[\"dp_dx\"]; dp_dy = fld[\"dp_dy\"]\n    fx = rho * conv_u_x + dp_dx - div2muS_x\n    fy = rho * conv_u_y + dp_dy - div2muS_y\n\n    # Energy terms\n    ux = fld[\"ux\"]; uy = fld[\"uy\"]\n    Tx = fld[\"Tx\"]; Ty = fld[\"Ty\"]; Txx = fld[\"Txx\"]; Tyy = fld[\"Tyy\"]\n    u_dot_gradT = ux * Tx + uy * Ty\n\n    # Variable-k diffusion operator\n    diff_T = k * (Txx + Tyy + alpha * (Tx**2 + Ty**2))\n\n    # Viscous dissipation Phi = 2 mu S:S\n    Phi = 4.0 * mu * (pi**4) * (np.cos(pi * x)**2) * (np.cos(pi * y)**2)\n\n    # Energy source term\n    Q = rho * cp * u_dot_gradT - diff_T - Phi\n\n    return fx, fy, Q\n\ndef residuals_at_point(x, y, params):\n    rho, cp, mu0, beta, k0, alpha = params\n    \n    # Recompute all terms needed for residual calculation\n    fld = manufactured_fields(x, y)\n    T = fld[\"T\"]\n    mu = mu0 * np.exp(beta * T)\n    k = k0 * np.exp(alpha * T)\n    mu_x = mu * beta * fld[\"Tx\"]\n    mu_y = mu * beta * fld[\"Ty\"]\n    \n    g = fld[\"g\"]; gx = fld[\"gx\"]; gy = fld[\"gy\"]\n    div2muS_x = mu_x * g + mu * gx\n    div2muS_y = - (mu_y * g + mu * gy)\n\n    Tx = fld[\"Tx\"]; Ty = fld[\"Ty\"]; Txx = fld[\"Txx\"]; Tyy = fld[\"Tyy\"]\n    diff_T = k * (Txx + Tyy + alpha * (Tx**2 + Ty**2))\n    \n    pi = np.pi\n    Phi = 4.0 * mu * (pi**4) * (np.cos(pi * x)**2) * (np.cos(pi * y)**2)\n\n    # Compute source terms\n    fx, fy, Q = properties_and_sources(x, y, rho, cp, mu0, beta, k0, alpha)\n\n    # Rebuild PDE terms to form residuals\n    # Momentum residual: rho (u·∇)u + ∇p - div(2 mu S) - f\n    Rm_x = rho * fld[\"conv_u_x\"] + fld[\"dp_dx\"] - div2muS_x - fx\n    Rm_y = rho * fld[\"conv_u_y\"] + fld[\"dp_dy\"] - div2muS_y - fy\n\n    # Energy residual: rho cp u·∇T - div(k grad T) - Phi - Q\n    u_dot_gradT = fld[\"ux\"] * fld[\"Tx\"] + fld[\"uy\"] * fld[\"Ty\"]\n    Re = rho * cp * u_dot_gradT - diff_T - Phi - Q\n\n    return Rm_x, Rm_y, Re\n\ndef solve():\n    # Define test cases (rho, cp, mu0, beta, k0, alpha)\n    test_cases = [\n        (1.0, 1.0, 0.3, 1.5, 0.7, 1.2),     # Case A\n        (2.0, 0.5, 0.05, 3.0, 1.1, -2.5),   # Case B\n        (1.3, 2.2, 0.2, 0.0, 0.9, 0.0),     # Case C\n    ]\n    # Test points\n    points = [\n        (0.25, 0.40),\n        (0.73, 0.90),\n        (0.01, 0.99),\n        (0.50, 0.50),\n    ]\n\n    results = []\n    for params in test_cases:\n        max_abs = 0.0\n        for (x, y) in points:\n            Rm_x, Rm_y, Re = residuals_at_point(x, y, params)\n            max_abs = max(max_abs, abs(Rm_x), abs(Rm_y), abs(Re))\n        results.append(max_abs)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}