{
    "hands_on_practices": [
        {
            "introduction": "代码验证是确保计算流体动力学（CFD）模拟可靠性的基石。本实践将介绍一种强大而通用的验证技术——“制造解方法”（Method of Manufactured Solutions, MMS）。通过这个练习，你将亲手实践MMS的完整流程：首先，为一个简化的雷诺平均Navier-Stokes（RANS）模型构建一个解析解；然后，推导出相应的源项；最后，通过数值实验验证你的有限差分代码是否达到了其设计的收敛精度阶数。这项练习将为你提供严格测试任何数值求解器所必备的基础技能。",
            "id": "3295624",
            "problem": "考虑一个一维、完全发展、不可压缩的湍流槽道流，其法向壁面坐标为 $y \\in [0,1]$，流向平均速度为 $U(y)$，无量纲分子运动粘度为恒定的 $\\nu > 0$，以及一个给定的无量纲涡粘度剖面 $\\nu_t(y) \\ge 0$。在此设定下，雷诺平均纳维–斯托克斯 (RANS) 平均动量平衡方程可简化为作用于平均流的稳态一维微分算子：\n$$\n\\mathcal{L}[U](y) \\equiv \\frac{d}{dy}\\left[\\left(\\nu + \\nu_t(y)\\right)\\frac{dU}{dy}(y)\\right].\n$$\n为了构建一个用于代码验证的人工解方法 (MMS) 基准测试，请选择一个光滑、非平凡的人工平均速度剖面 $U(y)$ 和一个光滑、非恒定的给定涡粘度剖面 $\\nu_t(y)$。定义一个源项 $s(y)$，使得精确的人工解满足平均动量方程\n$$\n\\mathcal{L}[U](y) - s(y) = 0 \\quad \\text{for all } y \\in (0,1),\n$$\n无需施加任何特定的边界条件，因为验证将对精确人工解的微分算子残差进行。\n\n您的任务是对此算子在均匀网格中心有限差分下的离散残差的设计精度阶进行纯数值验证。程序必须：\n\n1.  在整个过程中使用无量纲变量和单位。\n2.  采用人工平均速度和给定的涡粘度剖面\n   $$\n   U(y) = \\sin(\\pi y) + 0.1\\,\\sin(3\\pi y),\n   $$\n   $$\n   \\nu_t(y) = a\\,y(1-y) + b\\,[y(1-y)]^2,\n   $$\n   其中 $a$ 和 $b$ 是由测试套件提供的正常数无量纲参数。\n3.  仅使用微积分和上述定义，推导由基本一维平均动量方程 $\\mathcal{L}[U](y) - s(y) = 0$ 所隐含的源项 $s(y)$。\n4.  在 $[0,1]$ 上的一个包含 $N$ 个点的均匀网格上离散化 $\\mathcal{L}[U](y)$，步长为 $h = 1/(N-1)$。对通量的内层导数 $\\frac{dU}{dy}$ 和外层导数 $\\frac{d}{dy}$ 均使用二阶或四阶精度的中心有限差分。对于二阶精度，使用标准的三点中心差分格式计算一阶导数，并将其一致地应用于两个微分运算。对于四阶精度，使用标准的五点中心差分格式计算一阶导数，并将其一致地应用于两个微分运算。只能使用所选格式完全支持的内部点来评估残差。\n5.  在所有有限差分格式适用的内部网格点 $y_i$ 上，评估逐点离散残差\n   $$\n   R_h(y_i) = \\left.\\frac{d}{dy}\\right|_{\\text{FD}}\\!\\left[\\left(\\nu + \\nu_t(y)\\right)\\left.\\frac{dU}{dy}\\right|_{\\text{FD}}\\right]\\!(y_i) \\;-\\; s(y_i),\n   $$\n   并计算离散 $L^2$ 范数\n   $$\n   \\|R_h\\|_2 \\equiv \\sqrt{ \\sum_{i \\in \\mathcal{I}} \\left( R_h(y_i) \\right)^2\\, h },\n   $$\n   其中 $\\mathcal{I}$ 表示用于计算残差的内部点的索引集合。\n6.  对于每个测试用例，使用三个网格尺寸 $(N_1,N_2,N_3)$ 进行网格加密研究，计算 $(h_k,\\|R_{h_k}\\|_2)$（其中 $k=1,2,3$），并通过对 $(\\log h_k, \\log \\|R_{h_k}\\|_2)$ 进行直线拟合来估计观测精度阶 $p_{\\text{obs}}$，并报告斜率的绝对值。\n\n设计测试套件以覆盖验证的不同方面：\n-   一个具有中等涡粘度和二阶离散化的一般情况。\n-   与上述涡粘度相同但采用四阶离散化的情况。\n-   一个具有高涡粘度梯度和二阶离散化的情况。\n-   与上述高梯度情况相同但采用四阶离散化的情况。\n\n使用以下测试套件参数值，其中恒定 $\\nu = 10^{-2}$：\n-   测试 1 (中等剖面，二阶): $(a,b) = (0.25, 0.15)$，$N \\in \\{33,65,129\\}$，二阶格式。\n-   测试 2 (中等剖面，四阶): $(a,b) = (0.25, 0.15)$，$N \\in \\{33,65,129\\}$，四阶格式。\n-   测试 3 (高梯度剖面，二阶): $(a,b) = (1.0, 1.0)$，$N \\in \\{33,65,129\\}$，二阶格式。\n-   测试 4 (高梯度剖面，四阶): $(a,b) = (1.0, 1.0)$，$N \\in \\{33,65,129\\}$，四阶格式。\n\n您的程序应生成单行输出，其中包含四个测试的观测精度阶，格式为一个逗号分隔的列表并用方括号括起来 (例如 $[p_1,p_2,p_3,p_4]$)，其中每个 $p_i$ 是一个四舍五入到三位小数的浮点数。",
            "solution": "该问题是有效的，因为它具有科学依据、良态且客观。它在计算流体力学的既定框架内，概述了一种标准的数值验证程序——人工解方法 (MMS)。所有必要的函数、参数和方法都已明确定义，构成了一个自洽且可解的问题。\n\n任务是验证一维雷诺平均纳维-斯托克斯 (RANS) 算子的有限差分离散的精度阶。这涉及几个步骤：推导解析源项、离散化算子、执行网格加密研究以及计算观测精度阶。\n\n**1. 解析源项推导**\n\n控制方程由 $\\mathcal{L}[U](y) - s(y) = 0$ 给出，其中微分算子为\n$$\n\\mathcal{L}[U](y) \\equiv \\frac{d}{dy}\\left[\\left(\\nu + \\nu_t(y)\\right)\\frac{dU}{dy}(y)\\right].\n$$\n源项 $s(y)$ 的定义必须使人工解 $U(y)$ 精确满足此方程。我们可以通过解析计算 $\\mathcal{L}[U](y)$ 来求得 $s(y)$。令 $\\nu_{\\text{eff}}(y) = \\nu + \\nu_t(y)$。使用乘积法则求导，我们得到：\n$$\ns(y) = \\mathcal{L}[U](y) = \\frac{d\\nu_{\\text{eff}}}{dy}(y) \\frac{dU}{dy}(y) + \\nu_{\\text{eff}}(y) \\frac{d^2U}{dy^2}(y).\n$$\n人工平均速度剖面为：\n$$\nU(y) = \\sin(\\pi y) + 0.1\\,\\sin(3\\pi y).\n$$\n其一阶和二阶导数是：\n$$\n\\frac{dU}{dy}(y) = \\pi \\cos(\\pi y) + 0.3\\pi \\cos(3\\pi y),\n$$\n$$\n\\frac{d^2U}{dy^2}(y) = -\\pi^2 \\sin(\\pi y) - 0.9\\pi^2 \\sin(3\\pi y).\n$$\n给定的涡粘度剖面为：\n$$\n\\nu_t(y) = a\\,y(1-y) + b\\,[y(1-y)]^2.\n$$\n其导数是：\n$$\n\\frac{d\\nu_t}{dy}(y) = a(1-2y) + 2b\\,y(1-y)(1-2y) = (1-2y)\\left(a + 2b\\,y(1-y)\\right).\n$$\n由于 $\\nu$ 是常数，$\\frac{d\\nu_{\\text{eff}}}{dy} = \\frac{d\\nu_t}{dy}$。将这些表达式代入 $s(y)$ 的方程，即可得到解析源项，该源项可在任意点 $y$ 求值。\n\n**2. 数值离散**\n\n算子在 $N$ 个点 $y_i = i h$（其中 $i=0, 1, \\dots, N-1$）的均匀网格上进行离散，步长为 $h=1/(N-1)$。离散化的核心是对一阶导数的近似。\n对于二阶精度，我们使用三点中心差分格式：\n$$\n\\left.\\frac{df}{dy}\\right|_{y_i} \\approx \\frac{f_{i+1} - f_{i-1}}{2h}, \\quad \\text{for } i \\in \\{1, \\dots, N-2\\}.\n$$\n对于四阶精度，我们使用五点中心差分格式：\n$$\n\\left.\\frac{df}{dy}\\right|_{y_i} \\approx \\frac{-f_{i+2} + 8f_{i+1} - 8f_{i-1} + f_{i-2}}{12h}, \\quad \\text{for } i \\in \\{2, \\dots, N-3\\}.\n$$\n离散算子 $\\mathcal{L}_h[U](y_i)$ 通过嵌套应用所选的有限差分格式来计算：\n1.  根据精确值 $U(y_j)$，在适用的内部点 $j$ 计算离散梯度 $U'_h(y_j)$。\n2.  在相同的点 $j$ 构造离散通量项 $\\tau_h(y_j) = (\\nu + \\nu_t(y_j)) U'_h(y_j)$。\n3.  将相同的有限差分格式应用于离散通量 $\\tau_h(y_j)$，以计算离散算子 $\\mathcal{L}_h[U](y_i)$。\n\n可以计算最终残差的内部点集合 $\\mathcal{I}$ 取决于所用的格式。对于二阶格式，连续应用会将有效索引范围缩小到 $\\mathcal{I} = \\{2, 3, \\dots, N-3\\}$。对于四阶格式，范围变为 $\\mathcal{I} = \\{4, 5, \\dots, N-5\\}$。\n\n**3. 误差量化与精度阶**\n\n逐点离散残差是算子的数值近似与精确源项之间的差：\n$$\nR_h(y_i) = \\mathcal{L}_h[U](y_i) - s(y_i), \\quad \\text{for } i \\in \\mathcal{I}.\n$$\n总误差使用残差的离散 $L^2$ 范数量化：\n$$\n\\|R_h\\|_2 \\equiv \\sqrt{ \\sum_{i \\in \\mathcal{I}} \\left( R_h(y_i) \\right)^2\\, h }.\n$$\n对于一个精度阶为 $p$ 的数值方法，只要解足够光滑，误差范数预计会随网格间距 $h$ 按 $\\|R_h\\|_2 \\approx C h^p$ 的规律变化，其中 $C$ 为某个常数。对该关系取对数可得：\n$$\n\\log(\\|R_h\\|_2) \\approx \\log(C) + p \\log(h).\n$$\n这表明 $\\log(\\|R_h\\|_2)$ 与 $\\log(h)$ 之间存在线性关系。通过进行网格加密研究（为一系列减小的网格间距 $h_k$ 计算范数），我们可以将观测精度阶 $p_{\\text{obs}}$ 估计为拟合数据点 $(\\log h_k, \\log \\|R_{h_k}\\|_2)$ 的直线的斜率大小。对指定的四个测试用例都执行此操作。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the MMS verification for all test cases.\n    \"\"\"\n\n    # --- Analytical Functions ---\n\n    def U(y):\n        \"\"\"Manufactured mean velocity profile.\"\"\"\n        return np.sin(np.pi * y) + 0.1 * np.sin(3 * np.pi * y)\n\n    def dU_dy(y):\n        \"\"\"First derivative of the manufactured velocity profile.\"\"\"\n        return np.pi * np.cos(np.pi * y) + 0.3 * np.pi * np.cos(3 * np.pi * y)\n\n    def d2U_dy2(y):\n        \"\"\"Second derivative of the manufactured velocity profile.\"\"\"\n        return -np.pi**2 * np.sin(np.pi * y) - 0.9 * np.pi**2 * np.sin(3 * np.pi * y)\n\n    def nu_t(y, a, b):\n        \"\"\"Prescribed eddy viscosity profile.\"\"\"\n        y1y = y * (1.0 - y)\n        return a * y1y + b * y1y**2\n\n    def d_nut_dy(y, a, b):\n        \"\"\"Derivative of the eddy viscosity profile.\"\"\"\n        y1y = y * (1.0 - y)\n        return (1.0 - 2.0 * y) * (a + 2.0 * b * y1y)\n\n    def source_term(y, nu, a, b):\n        \"\"\"Analytical source term s(y) = L[U](y).\"\"\"\n        term1 = d_nut_dy(y, a, b) * dU_dy(y)\n        term2 = (nu + nu_t(y, a, b)) * d2U_dy2(y)\n        return term1 + term2\n\n    # --- Numerical Functions ---\n\n    def apply_fd_derivative(f, h, order):\n        \"\"\"Applies a central finite difference stencil for the first derivative.\"\"\"\n        if order == 2:\n            # 3-point stencil: (f_{i+1} - f_{i-1}) / (2h)\n            # Input f has length M. Output has length M-2, valid at interior points.\n            return (f[2:] - f[:-2]) / (2.0 * h)\n        elif order == 4:\n            # 5-point stencil: (-f_{i+2} + 8f_{i+1} - 8f_{i-1} + f_{i-2}) / (12h)\n            # Input f has length M. Output has length M-4, valid at interior points.\n            return (-f[4:] + 8 * f[3:-1] - 8 * f[1:-3] + f[:-4]) / (12.0 * h)\n        else:\n            raise ValueError(\"Order must be 2 or 4.\")\n\n    def calculate_observed_order(params, N_vals, order, nu):\n        \"\"\"\n        Performs a grid refinement study for a single test case\n        and computes the observed order of accuracy.\n        \"\"\"\n        a, b = params\n        h_vals, norm_vals = [], []\n\n        for N in N_vals:\n            h = 1.0 / (N - 1.0)\n            y = np.linspace(0.0, 1.0, N)\n\n            # Evaluate exact solution on the grid\n            u_on_grid = U(y)\n\n            # 1. Inner derivative: U'_h = D_h(U)\n            du_dy_h = apply_fd_derivative(u_on_grid, h, order)\n\n            # Determine grid points for inner derivative and final residual\n            if order == 2:\n                # U'_h is defined on y[1:-1].\n                y_inner = y[1:-1]\n                # L_h[U] will be defined on y[2:-2].\n                y_residual = y[2:-2]\n            else:  # order == 4\n                # U'_h is defined on y[2:-2].\n                y_inner = y[2:-2]\n                # L_h[U] will be defined on y[4:-4].\n                y_residual = y[4:-4]\n            \n            if y_residual.size == 0:\n                raise ValueError(f\"Grid size N={N} is too small for order={order} stencil.\")\n\n            # 2. Form flux: tau_h = (nu + nu_t) * U'_h\n            nu_eff_h = nu + nu_t(y_inner, a, b)\n            tau_h = nu_eff_h * du_dy_h\n\n            # 3. Outer derivative: L_h[U] = D_h(tau_h)\n            L_h_U = apply_fd_derivative(tau_h, h, order)\n\n            # 4. Compute residual: R_h = L_h[U] - s(y)\n            s_on_grid = source_term(y_residual, nu, a, b)\n            R_h = L_h_U - s_on_grid\n\n            # 5. Compute L2 norm of the residual\n            norm_R_h = np.sqrt(np.sum(R_h**2) * h)\n\n            h_vals.append(h)\n            norm_vals.append(norm_R_h)\n\n        # 6. Estimate order of accuracy from slope of log-log plot\n        log_h = np.log(h_vals)\n        log_norm = np.log(norm_vals)\n        \n        # Fit a line (degree 1 polynomial) and get the slope.\n        p_obs = np.polyfit(log_h, log_norm, 1)[0]\n\n        return abs(p_obs)\n\n    # --- Test Suite Execution ---\n\n    nu_const = 1.0e-2\n    N_grids = [33, 65, 129]\n    test_cases = [\n        {'a': 0.25, 'b': 0.15, 'order': 2},\n        {'a': 0.25, 'b': 0.15, 'order': 4},\n        {'a': 1.0,  'b': 1.0,  'order': 2},\n        {'a': 1.0,  'b': 1.0,  'order': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        params = (case['a'], case['b'])\n        p_obs = calculate_observed_order(params, N_grids, case['order'], nu_const)\n        results.append(p_obs)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了通用的MMS验证流程后，我们现在将注意力转向不可压缩流CFD中的一个核心算法：投影法。此实践旨在验证一个基于交错网格的实现方案是否能有效保证离散意义上的不可压缩性。通过对比近似的迭代求解器（雅可比法）和精确的直接求解器（FFT法），你将深入理解投影误差的来源，并体会到压力泊松方程求解对于维持无散场的重要性。",
            "id": "3295581",
            "problem": "设计并实现一个自包含程序，在二维均匀 Marker-and-Cell (MAC) 网格上，通过测量散度的离散 $L_{2}$ 范数并研究其在网格加密下的衰减情况，来验证交错网格投影法能够产生一个数值上无散度的速度场。从不可压缩性约束和控制体上的有限体积平衡出发，并使用一致的二阶中心差分。将测试限制在一个周期性方形域内，以隔离离散算子的影响。\n\n需使用的基本依据是：\n- 对于不可压缩流体，其不可压缩性约束为 $ \\nabla \\cdot \\mathbf{u} = 0 $。\n- 投影法思想：给定一个中间的面心速度 $ \\mathbf{u}^{\\star} $，获得一个校正后的速度 $ \\mathbf{u} = \\mathbf{u}^{\\star} - \\nabla p $，使得 $ \\nabla \\cdot \\mathbf{u} = 0 $ 在离散意义下成立，其中 $ p $ 求解一个由离散散度和梯度算子导出的泊松方程。\n- 在均匀网格上使用一致的二阶中心差分格式。\n\n使用以下通用的、数学上指定的设置：\n\n- 域和单位：\n  - 设计算域为 $ \\Omega = [0, 2\\pi) \\times [0, 2\\pi) $，在两个方向上均采用周期性边界条件。\n  - 所有三角函数参数均以弧度为单位。\n- 交错 (MAC) 布局：\n  - 压力 $ p_{i,j} $ 存储在单元中心 $ (x_{c,i}, y_{c,j}) = \\big((i+\\tfrac{1}{2})\\Delta x, (j+\\tfrac{1}{2})\\Delta y\\big) $，其中 $ i = 0,\\dots,N_{x}-1 $，$ j = 0,\\dots,N_{y}-1 $，且 $ \\Delta x = \\frac{2\\pi}{N_{x}} $，$ \\Delta y = \\frac{2\\pi}{N_{y}} $。\n  - x方向速度分量 $ u_{i,j} $ 存储在x方向的面心 $ (x_{u,i}, y_{u,j}) = (i\\Delta x, (j+\\tfrac{1}{2})\\Delta y) $。\n  - y方向速度分量 $ v_{i,j} $ 存储在y方向的面心 $ (x_{v,i}, y_{v,j}) = \\big((i+\\tfrac{1}{2})\\Delta x, j\\Delta y\\big) $。\n- 构造的光滑无散场：\n  - 定义解析速度场 $ \\mathbf{u}_{\\text{exact}}(x,y) = \\big(u_{\\text{exact}}(x,y), v_{\\text{exact}}(x,y)\\big) $ 为\n    $$\n    u_{\\text{exact}}(x,y) = -\\cos(x)\\sin(y), \\quad v_{\\text{exact}}(x,y) = \\sin(x)\\cos(y),\n    $$\n    该场对所有 $ (x,y) $ 均满足 $ \\nabla \\cdot \\mathbf{u}_{\\text{exact}} = 0 $。\n  - 在面上采样 $ \\mathbf{u}_{\\text{exact}} $ 以获得MAC网格上的 $ \\mathbf{u}^{\\star} $。\n- 离散算子 (带周期性环绕)：\n  - 单元中心的离散散度为\n    $$\n    (\\nabla_{h} \\cdot \\mathbf{u})_{i,j} = \\frac{u_{i+1,j} - u_{i,j}}{\\Delta x} + \\frac{v_{i,j+1} - v_{i,j}}{\\Delta y}.\n    $$\n  - 将单元中心压力映射到面心分量的离散梯度为\n    $$\n    (\\nabla_{h} p)^{x}_{i,j} = \\frac{p_{i,j} - p_{i-1,j}}{\\Delta x}, \\quad (\\nabla_{h} p)^{y}_{i,j} = \\frac{p_{i,j} - p_{i,j-1}}{\\Delta y}.\n    $$\n  - 复合运算 $ \\nabla_{h}\\cdot \\nabla_{h} p $ 得到单元中心的标准五点离散拉普拉斯算子。\n- 离散投影：\n  - 在单元中心构建右端项 $ b = \\nabla_{h} \\cdot \\mathbf{u}^{\\star} $。\n  - 求解离散泊松方程\n    $$\n    \\mathcal{L}_{h} p = b,\n    $$\n    其中 $ \\mathcal{L}_{h} $ 是五点周期性拉普拉斯算子，通过减去 $ b $ 在整个网格上的平均值来强制零均值可解性。需使用两种求解器：\n    1. 带固定迭代次数 $ K $ 和松弛参数 $ \\omega \\in (0,1) $ 的加权 Jacobi 迭代法。对于五点拉普拉斯算子，其对角线元素为 $ a_{ii} = -2/\\Delta x^{2} - 2/\\Delta y^{2} $。一次 Jacobi 扫描计算如下\n       $$\n       p^{\\text{new}}_{i,j} = (1-\\omega) p^{\\text{old}}_{i,j} + \\omega \\frac{b_{i,j} - \\frac{1}{\\Delta x^{2}}(p^{\\text{old}}_{i+1,j} + p^{\\text{old}}_{i-1,j}) - \\frac{1}{\\Delta y^{2}}(p^{\\text{old}}_{i,j+1} + p^{\\text{old}}_{i,j-1})}{-2/\\Delta x^{2} - 2/\\Delta y^{2}}.\n       $$\n       在每次迭代中保持 $ p $ 的零均值。\n    2. 使用快速傅里叶变换 (FFT) 的谱方法求解，利用其周期性。离散拉普拉斯算子的特征值为\n       $$\n       \\lambda(k,\\ell) = -\\frac{4}{\\Delta x^{2}} \\sin^{2}\\left( \\frac{\\pi k}{N_{x}} \\right) - \\frac{4}{\\Delta y^{2}} \\sin^{2}\\left( \\frac{\\pi \\ell}{N_{y}} \\right),\n       $$\n       对于 $ k=0,\\dots,N_{x}-1 $，$ \\ell=0,\\dots,N_{y}-1 $，其中零模被设置以强制压力为零均值。\n  - 通过 $ u \\leftarrow u^{\\star} - (\\nabla_{h} p)^{x} $，$ v \\leftarrow v^{\\star} - (\\nabla_{h} p)^{y} $ 来校正速度。\n- 散度的离散 $ L_{2} $ 范数：\n  $$\n  \\| \\nabla_{h} \\cdot \\mathbf{u} \\|_{L_{2,h}} = \\left( \\sum_{i=0}^{N_{x}-1} \\sum_{j=0}^{N_{y}-1} \\big( (\\nabla_{h} \\cdot \\mathbf{u})_{i,j} \\big)^{2} \\, \\Delta x \\, \\Delta y \\right)^{1/2}.\n  $$\n\n实现以下测试套件并计算所需的输出：\n\n- 情况 A (使用近似投影的理想情况加密研究)：\n  - 使用加权 Jacobi 方法，其中 $ \\omega = \\frac{2}{3} $，迭代次数 $ K = 10 $。\n  - 网格：$ (N_{x}, N_{y}) \\in \\{(16,16), (32,32), (64,64), (128,128)\\} $。\n  - 对每个网格，执行投影并计算校正后速度散度的离散 $ L_{2} $ 范数。然后计算连续网格之间的观测加密率\n    $$\n    r_{i \\to i+1} = \\log_{2}\\left( \\frac{\\| \\nabla_{h} \\cdot \\mathbf{u} \\|_{L_{2,h}}^{(N_{i})}}{\\| \\nabla_{h} \\cdot \\mathbf{u} \\|_{L_{2,h}}^{(N_{i+1})}} \\right).\n    $$\n- 情况 B (通过 FFT 进行的精确投影一致性检查)：\n  - 在 $ (N_{x}, N_{y}) = (64,64) $ 的网格上使用谱方法 FFT 求解。计算投影后散度的离散 $ L_{2} $ 范数。\n- 情况 C (使用近似投影的边缘情况各向异性)：\n  - 在 $ (N_{x}, N_{y}) = (48,64) $ 的网格上使用加权 Jacobi 方法，其中 $ \\omega = \\frac{2}{3} $，$ K = 10 $。计算投影后散度的离散 $ L_{2} $ 范数。\n\n你的程序必须输出一行，包含一个用方括号括起来的逗号分隔的扁平列表，按顺序包含以下条目：\n- 情况 A 在 $ (16,16) $、$ (32,32) $、$ (64,64) $ 和 $ (128,128) $ 网格上的四个离散 $ L_{2} $ 范数。\n- 三个观测到的加密率 $ r_{16 \\to 32} $、$ r_{32 \\to 64} $、$ r_{64 \\to 128} $。\n- 情况 B 在 $ (64,64) $ 网格上的离散 $ L_{2} $ 范数。\n- 情况 C 在 $ (48,64) $ 网格上的离散 $ L_{2} $ 范数。\n- 一个布尔值，指示情况 A 中的所有三个观测加密率是否都超过 $ 1.8 $。\n\n所有数值必须以普通十进制数输出，布尔值必须精确地为 True 或 False。角度必须以弧度为单位。输出中不需要物理单位。最终输出必须类似于\n- 示例格式 (非实际值)：$ [n_{16}, n_{32}, n_{64}, n_{128}, r_{16\\to 32}, r_{32\\to 64}, r_{64\\to 128}, n_{\\text{FFT64}}, n_{\\text{aniso}}, \\text{boolean}] $。",
            "solution": "该问题是有效的。它提出了一个来自计算流体力学领域的适定且有科学依据的任务，具体涉及一种数值方法的验证。所提供的参数、方程和测试用例是完整、一致且明确的。\n\n目标是验证交错网格投影法能正确地对流体速度场 $\\mathbf{u}$ 强制施加不可压缩性约束 $\\nabla \\cdot \\mathbf{u} = 0$。验证过程通过在一个 Marker-and-Cell (MAC) 网格上离散化一个已知的无散度解析速度场，应用投影法，然后测量所得数值速度场的离散散度来执行。被测试的核心原理是，投影法通过求解一个类压力标量的离散泊松方程，可以校正一个中间速度场，从而生成一个离散意义上无散的最终场。\n\n在此，我们详细说明构建所需程序的理论和方法步骤。\n\n首先，我们建立计算网格。域是一个周期性方域 $\\Omega = [0, 2\\pi) \\times [0, 2\\pi)$。我们将此域离散化为一个 $N_x \\times N_y$ 单元的均匀网格，网格间距为 $\\Delta x = 2\\pi/N_x$ 和 $\\Delta y = 2\\pi/N_y$。问题指定了一个交错的 MAC 网格。在此网格上，像压力 $p_{i,j}$ 这样的标量位于单元中心 $(x_{c,i}, y_{c,j}) = ((i+\\frac{1}{2})\\Delta x, (j+\\frac{1}{2})\\Delta y)$。然而，矢量分量是交错的，并位于控制体的面上。速度的 $x$ 分量 $u_{i,j}$ 位于垂直面的中心，坐标为 $(x_{u,i}, y_{u,j}) = (i\\Delta x, (j+\\frac{1}{2})\\Delta y)$，而 $y$ 分量 $v_{i,j}$ 位于水平面的中心，坐标为 $(x_{v,i}, y_{v,j}) = ((i+\\frac{1}{2})\\Delta x, j\\Delta y)$。这种交错布局是不可压缩流求解器中的一个关键设计选择，因为它自然地防止了在同位网格上可能出现的压力奇偶解耦不稳定性。\n\n验证过程采用“制造解”方法。我们从一个光滑的、设计为精确无散的解析速度场 $\\mathbf{u}_{\\text{exact}}(x,y)$ 开始。指定的场为：\n$$\nu_{\\text{exact}}(x,y) = -\\cos(x)\\sin(y), \\quad v_{\\text{exact}}(x,y) = \\sin(x)\\cos(y)\n$$\n该场的散度为 $\\nabla \\cdot \\mathbf{u}_{\\text{exact}} = \\frac{\\partial u_{\\text{exact}}}{\\partial x} + \\frac{\\partial v_{\\text{exact}}}{\\partial y} = \\sin(x)\\sin(y) - \\sin(x)\\sin(y) = 0$。该场在 MAC 网格上相应的面位置进行采样，以生成我们初始的、中间的速度场，记为 $\\mathbf{u}^{\\star} = (u^{\\star}, v^{\\star})$。由于离散误差，$\\mathbf{u}^{\\star}$ 的离散散度不会精确为零。\n\n投影法的目标是找到对 $\\mathbf{u}^{\\star}$ 的校正，以生成一个新的场 $\\mathbf{u}$，使其离散散度为零。该过程基于 Hodge-Helmholtz 分解，该分解指出任何矢量场都可以分解为一个无散部分和一个标量势的梯度。我们假设最终速度场 $\\mathbf{u}$ 与中间场 $\\mathbf{u}^{\\star}$ 通过减去一个标量场 $p$ 的梯度相关联：\n$$\n\\mathbf{u} = \\mathbf{u}^{\\star} - \\nabla_{h} p\n$$\n这里，$\\nabla_{h}$ 是离散梯度算子。为了对校正后的场强制施加不可压缩性约束 $\\nabla_{h} \\cdot \\mathbf{u} = 0$，我们代入 $\\mathbf{u}$ 的表达式：\n$$\n\\nabla_{h} \\cdot (\\mathbf{u}^{\\star} - \\nabla_{h} p) = 0 \\implies \\nabla_{h} \\cdot \\mathbf{u}^{\\star} - \\nabla_{h} \\cdot \\nabla_{h} p = 0\n$$\n这为类压力物理量 $p$ 产生了一个离散泊松方程：\n$$\n\\mathcal{L}_{h} p = b\n$$\n其中 $\\mathcal{L}_{h} \\equiv \\nabla_{h} \\cdot \\nabla_{h}$ 是离散拉普拉斯算子，右端项 (RHS) 是中间场的离散散度，$b \\equiv \\nabla_{h} \\cdot \\mathbf{u}^{\\star}$。离散算子使用二阶中心差分定义，与有限体积公式一致。对于一个单元 $(i,j)$：\n- 离散散度：$(\\nabla_{h} \\cdot \\mathbf{u})_{i,j} = \\frac{u_{i+1,j} - u_{i,j}}{\\Delta x} + \\frac{v_{i,j+1} - v_{i,j}}{\\Delta y}$\n- 离散梯度：$(\\nabla_{h} p)^{x}_{i,j} = \\frac{p_{i,j} - p_{i-1,j}}{\\Delta x}$，$(\\nabla_{h} p)^{y}_{i,j} = \\frac{p_{i,j} - p_{i,j-1}}{\\Delta y}$\n\n结合这些，我们得到单元 $(i,j)$ 处拉普拉斯算子的标准五点模板：\n$$\n\\mathcal{L}_{h} p_{i,j} = \\frac{p_{i+1,j} - 2p_{i,j} + p_{i-1,j}}{\\Delta x^2} + \\frac{p_{i,j+1} - 2p_{i,j} + p_{i,j-1}}{\\Delta y^2}\n$$\n\n对于周期性域，离散泊松方程有解的条件是右端项在整个域上的总和为零。由于周期性边界条件，将离散散度 $b_{i,j}$ 在所有单元上求和会得到一个恒等于零的伸缩和。然而，在浮点运算中，这个和可能是一个很小的非零值。为确保可解性，我们通过从 b 自身减去其平均值来强制满足此条件。压力 $p$ 于是被确定，但会相差一个任意常数。我们通过要求 $p$ 具有零均值来强制得到唯一解。\n\n问题指定了两种求解泊松方程的方法：\n\n1.  **加权 Jacobi 迭代法**：这是一种迭代的近似求解器。对于固定的迭代次数 $K$，它不能精确求解方程。更新规则将前一次的迭代结果 $p^{\\text{old}}$ 与从泊松方程导出的新估计值混合。$p$ 解的误差会直接转化为最终速度场 $\\mathbf{u}$ 中的非零散度。\n\n2.  **谱方法 (FFT) 求解器**：这是一种直接的、“精确”的（达到机器精度）求解器，它利用了周期性域的特性。离散傅里叶模式是离散拉普拉斯算子的特征向量。求解过程包括：\n    a. 对右端项进行二维快速傅里叶变换 (FFT)，$\\hat{b} = \\text{FFT}(b)$。\n    b. 将每个傅里叶系数 $\\hat{b}(k,\\ell)$ 除以拉普拉斯算子相应的特征值 $\\lambda(k,\\ell)$，得到 $\\hat{p}(k,\\ell) = \\hat{b}(k,\\ell) / \\lambda(k,\\ell)$。\n    c. 零频模式 $(k,\\ell)=(0,0)$ 的特征值为 $\\lambda(0,0)=0$。可解性条件确保 $\\hat{b}(0,0)=0$。我们设置 $\\hat{p}(0,0)=0$ 来强制施加零均值压力约束。\n    d. 对 $\\hat{p}$ 进行二维逆 FFT，以获得物理空间中的解 $p$。\n\n一旦求得 $p$，就对速度进行校正：$u_{i,j} = u^{\\star}_{i,j} - (\\nabla_h p)^x_{i,j}$ 和 $v_{i,j} = v^{\\star}_{i,j} - (\\nabla_h p)^y_{i,j}$。\n\n最后，为了量化投影的成功程度，我们计算最终速度场 $\\mathbf{u}$ 的散度的离散 $L_2$ 范数：\n$$\n\\| \\nabla_{h} \\cdot \\mathbf{u} \\|_{L_{2,h}} = \\left( \\sum_{i,j} |(\\nabla_{h} \\cdot \\mathbf{u})_{i,j}|^2 \\Delta x \\Delta y \\right)^{1/2}\n$$\n对于“精确的” FFT 求解器，此范数应接近机器精度。对于“近似的” Jacobi 求解器，它会更大，但应随着网格的加密而减小。加密率 $r$ 量化了这种衰减。问题要求我们对指定的测试用例进行此分析。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft2, ifft2\n\ndef run_projection_test(Nx, Ny, solver_type, K=None, omega=None):\n    \"\"\"\n    Performs a single projection method verification test on a MAC grid.\n\n    Args:\n        Nx (int): Number of grid cells in the x-direction.\n        Ny (int): Number of grid cells in the y-direction.\n        solver_type (str): Type of Poisson solver ('jacobi' or 'fft').\n        K (int, optional): Number of Jacobi iterations. Required for 'jacobi'.\n        omega (float, optional): Jacobi relaxation parameter. Required for 'jacobi'.\n\n    Returns:\n        float: The discrete L2 norm of the divergence of the corrected velocity field.\n    \"\"\"\n    # 1. Domain and Grid Setup\n    Lx, Ly = 2 * np.pi, 2 * np.pi\n    dx, dy = Lx / Nx, Ly / Ny\n\n    # Coordinates for pressure (cell centers)\n    xc = (np.arange(Nx) + 0.5) * dx\n    yc = (np.arange(Ny) + 0.5) * dy\n    \n    # Coordinates for u-velocity (x-faces)\n    xu = np.arange(Nx) * dx\n    yu = (np.arange(Ny) + 0.5) * dy\n    xu_grid, yu_grid = np.meshgrid(xu, yu, indexing='ij')\n\n    # Coordinates for v-velocity (y-faces)\n    xv = (np.arange(Nx) + 0.5) * dx\n    yv = np.arange(Ny) * dy\n    xv_grid, yv_grid = np.meshgrid(xv, yv, indexing='ij')\n\n    # 2. Initialize Intermediate Velocity Field u_star\n    # Sample the exact divergence-free field on the MAC grid faces.\n    u_star = -np.cos(xu_grid.T) * np.sin(yu_grid.T)\n    v_star = np.sin(xv_grid.T) * np.cos(yv_grid.T)\n\n    # 3. Compute RHS of Poisson Equation\n    # Discrete divergence of u_star. np.roll handles periodic boundaries.\n    # (u_{i+1,j} - u_{i,j}) / dx\n    div_u = (np.roll(u_star, -1, axis=0) - u_star) / dx\n    # (v_{i,j+1} - v_{i,j}) / dy\n    div_v = (np.roll(v_star, -1, axis=1) - v_star) / dy\n    \n    b = div_u.T + div_v.T # Transpose back to (Ny, Nx)\n    \n    # Enforce solvability condition: zero-mean RHS\n    b -= np.mean(b)\n    \n    # 4. Solve the Poisson Equation: L_h * p = b\n    p = np.zeros((Ny, Nx), dtype=float)\n    if solver_type == 'jacobi':\n        if K is None or omega is None:\n            raise ValueError(\"K and omega must be provided for Jacobi solver.\")\n        \n        diag_coeff = -2.0 / (dx*dx) - 2.0 / (dy*dy)\n        \n        for _ in range(K):\n            # Off-diagonal part of the Laplacian applied to p\n            off_diag_lap_p = (\n                (np.roll(p, -1, axis=1) + np.roll(p, 1, axis=1)) / (dx*dx) +\n                (np.roll(p, -1, axis=0) + np.roll(p, 1, axis=0)) / (dy*dy)\n            )\n            # Jacobi update for L_h * p = b\n            p_update = (b - off_diag_lap_p) / diag_coeff\n            \n            # Apply weighted relaxation\n            p = (1.0 - omega) * p + omega * p_update\n            \n            # Enforce zero-mean pressure at each iteration\n            p -= np.mean(p)\n\n    elif solver_type == 'fft':\n        # Create wavenumbers indices\n        k_indices = np.arange(Nx)\n        l_indices = np.arange(Ny)\n        K_grid, L_grid = np.meshgrid(k_indices, l_indices, indexing='ij')\n\n        # Compute eigenvalues of the discrete Laplacian in Fourier space\n        lambda_kl = (-4.0 / (dx*dx) * np.sin(np.pi * K_grid / Nx)**2 -\n                     -4.0 / (dy*dy) * np.sin(np.pi * L_grid / Ny)**2)\n        \n        # FFT of the RHS\n        b_hat = fft2(b)\n        \n        # Solve for p_hat = b_hat / lambda_kl\n        # Handle the zero-frequency mode (k=0, l=0) where lambda=0\n        p_hat = np.divide(b_hat, lambda_kl, out=np.zeros_like(b_hat), where=lambda_kl != 0)\n        \n        # Inverse FFT to get p in physical space\n        p = np.real(ifft2(p_hat))\n\n    else:\n        raise ValueError(f\"Unknown solver type: {solver_type}\")\n\n    # 5. Correct the Velocity Field\n    # Discrete gradient of p.\n    # (p_{i,j} - p_{i-1,j}) / dx\n    grad_p_x = (p - np.roll(p, 1, axis=1)) / dx\n    # (p_{i,j} - p_{i,j-1}) / dy\n    grad_p_y = (p - np.roll(p, 1, axis=0)) / dy\n    \n    u = u_star - grad_p_x.T # Transpose back to (Nx, Ny)\n    v = v_star - grad_p_y.T # Transpose back to (Nx, Ny)\n\n    # 6. Compute Divergence of the Final Field and its L2 norm\n    final_div = ((np.roll(u, -1, axis=0) - u) / dx +\n                 (np.roll(v, -1, axis=1) - v) / dy)\n    \n    norm_l2 = np.sqrt(np.sum(final_div.T**2 * dx * dy))\n    \n    return norm_l2\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the final results.\n    \"\"\"\n    # Case A: Jacobi refinement study\n    case_a_configs = [(16, 16), (32, 32), (64, 64), (128, 128)]\n    case_a_norms = [run_projection_test(Nx=n, Ny=n, solver_type='jacobi', K=10, omega=2/3) for n, _ in case_a_configs]\n\n    # Calculate refinement rates for Case A\n    rates = []\n    for i in range(len(case_a_norms) - 1):\n        # r = log2(error_coarse / error_fine)\n        if case_a_norms[i] > 0 and case_a_norms[i+1] > 0:\n            rate = np.log2(case_a_norms[i] / case_a_norms[i+1])\n        else:\n            rate = 0.0\n        rates.append(rate)\n\n    # Case B: FFT \"exact\" projection\n    norm_b = run_projection_test(Nx=64, Ny=64, solver_type='fft')\n\n    # Case C: Jacobi on anisotropic grid\n    norm_c = run_projection_test(Nx=48, Ny=64, solver_type='jacobi', K=10, omega=2/3)\n\n    # Final check: do all rates exceed 1.8?\n    rates_exceed_threshold = all(r > 1.8 for r in rates)\n\n    # Assemble final results list\n    all_results = case_a_norms + rates + [norm_b, norm_c, rates_exceed_threshold]\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "数值误差不仅来源于离散格式本身，还源于其与计算网格的相互作用。最后一个实践将孤立地研究网格倾斜（grid skewness）的影响，这是复杂几何模拟中常见的网格质量问题。通过将一个精确的解析解应用于正交和倾斜两种网格，并观察由此产生的非零残差，你将学会如何设计专门的测试来诊断数值方法中与网格质量相关的特定缺陷。",
            "id": "3295638",
            "problem": "设计并实现一个自包含程序，通过比较正交网格和偏斜网格上的离散残差，来验证网格偏斜度如何影响二维平面通道中层流Poiseuille流的离散化，同时在比较对之间保持法向壁面分辨率不变。请从第一性原理和广为接受的事实出发。待验证的连续流是高度为 $H$、长度为 $L$ 的通道中的稳态、完全发展、不可压缩的层流Poiseuille流。在这些条件下，流向动量方程简化为一维平衡方程\n$$\n-\\frac{\\mathrm{d}p}{\\mathrm{d}x} + \\mu \\frac{\\mathrm{d}^2 u}{\\mathrm{d} y^2} = 0,\n$$\n其中 $\\mu$ 是动力粘度，$u(y)$ 是流向速度。压力梯度 $-\\mathrm{d}p/\\mathrm{d}x$ 是一个常数，记为 $G>0$，且在壁面 $y=0$ 和 $y=H$ 处满足无滑移边界条件。其精确解析解是经典的抛物线剖面\n$$\nu(y) = \\frac{G}{2\\mu} y (H - y).\n$$\n\n您必须在两种网格族上，为该解析解评估流向动量方程的离散残差：\n- 一个正交网格族，由大小为 $\\Delta x \\times \\Delta y$ 的均匀矩形单元组成，其中流向有 $N_x$ 个单元，法向壁面方向有 $N_y$ 个单元。\n- 一个偏斜网格族，由均匀平行四边形组成，通过将每个连续的法向壁面层沿流向平移一个恒定的偏移量来构建，使得连接相邻单元中心的法向壁面线与面法线之间的夹角为 $\\alpha$（单位：度）。扭曲度随 $y$ 线性变化，因此 $\\Delta x$ 是流向单元宽度，法向相邻单元的中心间矢量为 $\\boldsymbol{\\delta}_{\\perp} = (\\Delta y \\tan \\alpha, \\Delta y)$，其欧几里得长度为 $\\|\\boldsymbol{\\delta}_{\\perp}\\| = \\Delta y \\sqrt{1+\\tan^2\\alpha} = \\Delta y / \\cos \\alpha$。\n\n对于这两种网格族，使用基于面、单元中心的有限体积法（FVM; Finite Volume Method）对扩散项进行离散化，该方法通过以下方式近似面法向梯度来假设正交性\n$$\n\\left.\\frac{\\partial u}{\\partial n}\\right|_f \\approx \\frac{u_N - u_P}{d_{PN}},\n$$\n其中 $u_P$ 是当前单元中心的值，$u_N$ 是面 $f$ 对面相邻单元中心的值，$d_{PN}$ 是单元中心之间的距离。在正交网格中，该距离等于法向距离。在偏斜网格中，这种正交假设忽略了非正交修正，并使用 $d_{PN} = \\|\\boldsymbol{\\delta}_{\\perp}\\|$。通过每个面的扩散通量为 $\\mu A_f (\\partial u/\\partial n)_f$，单元残差是向外通量之和除以单元面积，再加上恒定的压力梯度源项 $G$。离散化应仅应用于法向壁面方向的内部单元，即索引为 $j=1,\\dots,N_y-2$ 的单元，以避免边界面处理的模糊性；您必须报告所有内部单元残差的均方根（RMS）值。残差的单位是单位长度的压力梯度，必须以帕斯卡/米（$\\mathrm{Pa}/\\mathrm{m}$）为单位报告。\n\n使用以下物理参数：$H = 0.1\\,\\mathrm{m}$，$L = 1.0\\,\\mathrm{m}$，$\\mu = 10^{-3}\\,\\mathrm{Pa}\\cdot\\mathrm{s}$，以及 $G = 1.0\\,\\mathrm{Pa}/\\mathrm{m}$。单元中心位于 $(x_i,y_j)$，其中 $x_i = (i+\\tfrac{1}{2})\\Delta x$，$y_j = (j+\\tfrac{1}{2})\\Delta y$，对于 $i=0,\\dots,N_x-1$ 和 $j=0,\\dots,N_y-1$。在偏斜网格上，中心坐标为 $(x_{i,j}, y_{i,j}) = \\big(x_i + y_j \\tan \\alpha,\\, y_j\\big)$。\n\n您的程序必须计算下述每个测试用例中内部单元的离散残差的RMS值。在计算每个内部单元的离散残差时，仅包括来自北面和南面的贡献，因为解析解仅依赖于 $y$ 且流向梯度为零。对于正交网格，使用 $d_{PN} = \\Delta y$；对于偏斜网格，使用 $d_{PN} = \\|\\boldsymbol{\\delta}_{\\perp}\\|$。对于两种网格族，北面和南面的面积取 $A_f = \\Delta x$，单元面积取 $A_{\\mathrm{cell}} = \\Delta x\\,\\Delta y$。索引为 $(i,j)$ 的内部单元的离散残差为\n$$\nR_{i,j} = G + \\frac{\\mu}{A_{\\mathrm{cell}}}\\left[ A_N \\frac{u_{i,j+1} - u_{i,j}}{d_{PN}^{(N)}} - A_S \\frac{u_{i,j} - u_{i,j-1}}{d_{PN}^{(S)}} \\right],\n$$\n您必须报告RMS值\n$$\n\\mathrm{RMS} = \\sqrt{\\frac{1}{N_{\\mathrm{int}}}\\sum_{i=0}^{N_x-1}\\sum_{j=1}^{N_y-2} R_{i,j}^2},\n$$\n其中 $N_{\\mathrm{int}} = N_x (N_y - 2)$ 是内部单元的数量。\n\n测试套件规范：\n1. 正交网格，$N_x=8, N_y=16, \\alpha=0$ 度。\n2. 偏斜网格，$N_x=8, N_y=16, \\alpha=30$ 度。\n3. 偏斜网格，$N_x=8, N_y=64, \\alpha=30$ 度。\n4. 偏斜网格，$N_x=8, N_y=16, \\alpha=5$ 度。\n5. 偏斜网格，$N_x=8, N_y=16, \\alpha=60$ 度。\n6. 正交网格，$N_x=8, N_y=64, \\alpha=0$ 度。\n\n您的程序应生成单行输出，其中包含RMS残差值（单位为 $\\mathrm{Pa}/\\mathrm{m}$），形式为用方括号括起来的逗号分隔列表，顺序与上述测试用例一致（例如，“[r1,r2,r3,r4,r5,r6]”）。输入测试套件中的角度以度为单位指定，所有其他量必须使用国际单位制（SI）。输出为浮点数，单位是 $\\mathrm{Pa}/\\mathrm{m}$。",
            "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于流体动力学和数值方法的原理，特别是用于计算流体动力学（CFD）的有限体积法（FVM）。该问题是适定的，提供了所有必要的物理参数、几何定义、控制方程、其解析解，以及待计算的离散残差的精确数学公式。该任务是一个标准的代码验证练习，所有提供的信息都是自包含且一致的。\n\n目标是为层流Poiseuille流的解析解计算离散残差的均方根（RMS）值。该解析解在几种正交和偏斜的计算网格上进行评估，以评价网格偏斜度对简化FVM离散化精度的影响。\n\n稳态、完全发展的Poiseuille流的控制方程为 $G + \\mu \\frac{\\mathrm{d}^2 u}{\\mathrm{d} y^2} = 0$，其中 $G = -\\frac{\\mathrm{d}p}{\\mathrm{d}x}$ 是恒定的正压力梯度项。在无滑移边界条件 $u(0)=0$ 和 $u(H)=0$ 下，速度剖面 $u(y)$ 的解析解为：\n$$\nu(y) = \\frac{G}{2\\mu} y (H - y)\n$$\n这是关于 $y$ 的二次函数。其二阶导数是一个常数：\n$$\n\\frac{\\mathrm{d}^2 u}{\\mathrm{d} y^2} = -\\frac{G}{\\mu}\n$$\n代入控制方程可验证：$G + \\mu (-\\frac{G}{\\mu}) = G - G = 0$。因此，方程和解是一致的。\n\n问题将内部单元 $(i,j)$ 的离散残差定义为：\n$$\nR_{i,j} = G + \\frac{\\mu}{A_{\\mathrm{cell}}}\\left[ A_N \\frac{u_{i,j+1} - u_{i,j}}{d_{PN}^{(N)}} - A_S \\frac{u_{i,j} - u_{i,j-1}}{d_{PN}^{(S)}} \\right]\n$$\n解析解 $u(y)$ 仅依赖于法向壁面坐标 $y$。对于 $y$ 方向的均匀网格，单元中心的值 $u_{i,j}$ 仅依赖于索引 $j$，因此我们将其表示为 $u_j$。问题指定，对于北面和南面，面面积为 $A_f = \\Delta x$，单元面积为 $A_{\\mathrm{cell}} = \\Delta x \\Delta y$。对于均匀网格，中心到中心的距离也是均匀的，$d_{PN}^{(N)} = d_{PN}^{(S)} = d_{PN}$。因此，残差与流向索引 $i$ 无关，我们可以写作 $R_j$：\n$$\nR_j = G + \\frac{\\mu}{\\Delta x \\Delta y}\\left[ \\Delta x \\frac{u_{j+1} - u_j}{d_{PN}} - \\Delta x \\frac{u_j - u_{j-1}}{d_{PN}} \\right]\n$$\n这可以简化为：\n$$\nR_j = G + \\frac{\\mu}{d_{PN} \\Delta y} (u_{j+1} - 2u_j + u_{j-1})\n$$\n项 $(u_{j+1} - 2u_j + u_{j-1})$ 是 $u$ 的二阶中心差分。该算子的一个基本性质是，它对于最高三次的多项式都是精确的。由于我们的解析解 $u(y)$ 是一个二次多项式，所以二阶差分精确地等于二阶导数乘以网格间距的平方：\n$$\nu_{j+1} - 2u_j + u_{j-1} = \\left.\\frac{\\mathrm{d}^2 u}{\\mathrm{d} y^2}\\right|_{y_j} (\\Delta y)^2\n$$\n代入已知的二阶导数 $\\frac{\\mathrm{d}^2 u}{\\mathrm{d} y^2} = -G/\\mu$：\n$$\nu_{j+1} - 2u_j + u_{j-1} = \\left(-\\frac{G}{\\mu}\\right) (\\Delta y)^2\n$$\n现在，我们将这个精确结果代回到残差 $R_j$ 的表达式中：\n$$\nR_j = G + \\frac{\\mu}{d_{PN} \\Delta y} \\left[ \\left(-\\frac{G}{\\mu}\\right) (\\Delta y)^2 \\right] = G - G \\frac{\\Delta y}{d_{PN}}\n$$\n$d_{PN}$ 的值取决于网格偏斜角 $\\alpha$。\n对于正交网格（$\\alpha=0$），单元中心在法向壁面方向上对齐，因此距离为 $d_{PN} = \\Delta y$。残差为：\n$$\nR_j = G - G \\frac{\\Delta y}{\\Delta y} = 0\n$$\n这个结果至关重要：在正交网格上，对于二次精确解，二阶离散格式产生的残差精确为零。\n\n对于偏斜网格，法向相邻单元之间的距离指定为 $d_{PN} = \\|\\boldsymbol{\\delta}_{\\perp}\\| = \\Delta y / \\cos\\alpha$。残差为：\n$$\nR_j = G - G \\frac{\\Delta y}{(\\Delta y / \\cos\\alpha)} = G - G \\cos\\alpha = G(1 - \\cos\\alpha)\n$$\n这个非零值是由于正交假设在非正交网格上引入的截断误差。\n\n最后一步是计算所有 $N_{\\mathrm{int}} = N_x (N_y-2)$ 个内部单元上这个恒定残差的RMS值：\n$$\n\\mathrm{RMS} = \\sqrt{\\frac{1}{N_{\\mathrm{int}}}\\sum_{i,j} R_j^2} = \\sqrt{\\frac{1}{N_{\\mathrm{int}}} N_{\\mathrm{int}} R_j^2} = \\sqrt{R_j^2} = |R_j|\n$$\n代入 $R_j$ 的表达式：\n$$\n\\mathrm{RMS} = |G(1 - \\cos\\alpha)|\n$$\n给定 $G=1.0\\,\\mathrm{Pa}/\\mathrm{m} > 0$ 并且 $\\cos\\alpha \\le 1$，项 $1-\\cos\\alpha$ 总是非负的。因此：\n$$\n\\mathrm{RMS} = G(1 - \\cos\\alpha)\n$$\n这个最终的解析表达式允许我们直接计算每个测试用例所需的RMS残差，从而无需进行显式的数值求和，提供了一种更优雅和精确的解法。每个用例的结果仅取决于偏斜角 $\\alpha$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the RMS of the discrete residual for a laminar Poiseuille flow\n    on various orthogonal and skewed meshes.\n\n    The problem asks to evaluate the residual of a finite volume discretization\n    when the analytical solution to the continuous problem is used. \n    A key insight is that for the given quadratic velocity profile, the\n    discretization error can be calculated analytically, which simplifies the\n    problem significantly.\n    \"\"\"\n\n    # Physical parameters given in the problem statement. Only G is needed\n    # for the final analytical result.\n    G = 1.0  # Constant pressure gradient term, in Pa/m.\n\n    # Test suite specification from the problem statement.\n    # Each tuple contains: (Nx, Ny, alpha in degrees).\n    test_cases = [\n        (8, 16, 0),   # Case 1: Orthogonal\n        (8, 16, 30),  # Case 2: Skewed\n        (8, 64, 30),  # Case 3: Skewed, finer y-resolution\n        (8, 16, 5),   # Case 4: Skewed, small angle\n        (8, 16, 60),  # Case 5: Skewed, large angle\n        (8, 64, 0),   # Case 6: Orthogonal, finer y-resolution\n    ]\n\n    results = []\n\n    # The calculation is based on an analytical derivation of the RMS residual.\n    # The governing equation is G + mu * u_yy = 0.\n    # The discrete residual for cell j is defined as R_j = G + (discrete viscous term).\n    # The discrete viscous term is mu * (u_{j+1} - 2*u_j + u_{j-1}) / (d_PN * dy).\n    #\n    # The analytical solution u(y) is a quadratic function. For any quadratic,\n    # the second-order central finite difference is exact:\n    # u_{j+1} - 2*u_j + u_{j-1} = u''(y_j) * dy^2\n    #\n    # From the governing equation, u''(y) = -G/mu. Thus:\n    # u_{j+1} - 2*u_j + u_{j-1} = (-G/mu) * dy^2\n    #\n    # Substituting this back into the residual equation:\n    # R_j = G + (mu / (d_PN * dy)) * ((-G/mu) * dy^2)\n    # R_j = G - G * (dy / d_PN)\n    #\n    # The distance d_PN is dy for orthogonal grids and dy / cos(alpha) for skewed grids.\n    # This can be unified: d_PN = dy / cos(alpha) (since cos(0) = 1).\n    # So, dy/d_PN = cos(alpha).\n    # R_j = G - G * cos(alpha) = G * (1 - cos(alpha)).\n    #\n    # Because this residual value is constant for all interior cells, its RMS is\n    # simply its absolute value:\n    # RMS = |G * (1 - cos(alpha))| = G * (1 - cos(alpha))\n    # This calculation is independent of Nx, Ny, H, L, and mu.\n\n    for case in test_cases:\n        # Unpack the case parameters. Only alpha is needed.\n        _, _, alpha_deg = case\n        \n        # Convert angle to radians for use in trigonometric functions.\n        alpha_rad = np.deg2rad(alpha_deg)\n        \n        # Calculate the RMS residual using the derived analytical formula.\n        rms_residual = G * (1 - np.cos(alpha_rad))\n        \n        results.append(rms_residual)\n\n    # Format the final output as a comma-separated list of floating-point numbers\n    # enclosed in square brackets, with 7 decimal places for precision.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}