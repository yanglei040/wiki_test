{
    "hands_on_practices": [
        {
            "introduction": "To build a solid foundation, we begin with the simplest application of dual time stepping. This exercise explores an explicit pseudo-time integration for a one-dimensional linear advection equation. By working through this fundamental case , you will derive the iterative update from first principles and discover the stability constraint on the pseudo-time step, revealing its direct connection to the underlying physics and grid.",
            "id": "3313256",
            "problem": "Consider a one-dimensional inviscid scalar conservation law on a periodic domain of length $L$ with a constant positive advection speed $a0$, governed by $\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0$ with $f(u) = a u$. Discretize the domain into $N$ uniform finite volumes of width $\\Delta x = \\frac{L}{N}$, and let $u_i$ denote the cell-averaged state in cell $i$. Use the first-order upwind numerical flux for $a0$ and define the finite-volume semi-discrete residual in each cell $i$ as $R_i(U) = F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}$, where $U = (u_1,\\dots,u_N)^{\\top}$ and the periodic boundary condition couples cell $N$ back to cell $1$. Let the mass matrix $M$ be the diagonal matrix of cell volumes, so $M_{ii} = \\Delta x$.\n\nTo accelerate convergence to the steady state $R(U) = 0$, introduce a pseudo-time $\\tau$ and consider explicit forward Euler integration in pseudo-time for the semi-discrete ordinary differential equation $M \\frac{dU}{d\\tau} = - R(U)$. Starting from fundamental finite-volume definitions and the first-order upwind flux for $a0$, derive the explicit componentwise pseudo-time update $u_i^{k+1}$ as a function of $u_i^k$ and its neighbors at iteration $k$.\n\nDefine the discrete residual $\\ell_1$ norm at iteration $k$ by $\\|R(U^k)\\|_1 = \\sum_{i=1}^{N} |R_i(U^k)|$. Using only first principles and well-tested properties of monotone upwind discretizations, identify a condition on the pseudo-time step $\\Delta \\tau$ that is sufficient to guarantee that the sequence $\\|R(U^k)\\|_1$ is monotonically nonincreasing in $k$. Finally, from this condition, determine the largest allowable pseudo-time step $\\Delta \\tau_{\\max}$ that guarantees monotone nonincreasing residual norm in pseudo-time. Express your final answer for $\\Delta \\tau_{\\max}$ in seconds as a closed-form analytic expression (no inequality).",
            "solution": "The problem is first validated against the specified criteria.\n\n### Step 1: Extract Givens\n- **Governing Equation**: A one-dimensional inviscid scalar conservation law, $\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0$.\n- **Flux Function**: $f(u) = a u$, with $a  0$ being a constant advection speed.\n- **Domain**: A periodic domain of length $L$.\n- **Discretization**: Finite volume method with $N$ uniform cells of width $\\Delta x = \\frac{L}{N}$.\n- **State Variable**: $u_i$ is the cell-averaged state in cell $i$. $U = (u_1, \\dots, u_N)^{\\top}$.\n- **Numerical Flux**: First-order upwind numerical flux for $a0$.\n- **Semi-discrete Residual**: $R_i(U) = F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}$, where $F$ is the numerical flux.\n- **Boundary Condition**: Periodic, coupling cell $N$ to cell $1$.\n- **Mass Matrix**: Diagonal matrix $M$ with $M_{ii} = \\Delta x$.\n- **Pseudo-time Integration**: Explicit forward Euler for the ODE $M \\frac{dU}{d\\tau} = -R(U)$, where $\\tau$ is the pseudo-time.\n- **Residual Norm**: Discrete $\\ell_1$ norm at iteration $k$ is $\\|R(U^k)\\|_1 = \\sum_{i=1}^{N} |R_i(U^k)|$.\n- **Objective 1**: Derive the explicit componentwise pseudo-time update $u_i^{k+1}$.\n- **Objective 2**: Find a condition on the pseudo-time step $\\Delta \\tau$ sufficient for $\\|R(U^{k+1})\\|_1 \\leq \\|R(U^k)\\|_1$.\n- **Objective 3**: Determine the largest allowable pseudo-time step $\\Delta \\tau_{\\max}$ from this condition.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem describes a standard technique (dual time stepping with explicit Euler) for finding the steady-state solution of a discretized partial differential equation (the 1D linear advection equation). This is a classical topic in computational fluid dynamics (CFD) and numerical analysis.\n- **Well-Posed**: The problem is well-posed. It asks for the derivation of an update rule and a stability condition, which have unique and meaningful solutions based on the provided framework.\n- **Objective**: The language is precise, mathematical, and free of any subjective or opinion-based statements.\n- **Completeness and Consistency**: All necessary components for the derivation are provided: the governing equation, the flux, the discretization scheme, the time-stepping method, and the objective criteria. The setup is internally consistent.\n\n### Step 3: Verdict and Action\nThe problem is valid. A detailed solution will be provided.\n\nThe semi-discrete form of the governing equation, used for accelerating to a steady state, is given by introducing a pseudo-time variable $\\tau$:\n$$\nM \\frac{dU}{d\\tau} = -R(U)\n$$\nHere, $M$ is the diagonal mass matrix with entries $M_{ii} = \\Delta x$, $U$ is the vector of cell-averaged states, and $R(U)$ is the vector of residuals. Writing this equation for a single cell $i$ gives:\n$$\n\\Delta x \\frac{du_i}{d\\tau} = -R_i(U)\n$$\nDiscretizing this ordinary differential equation in pseudo-time using the explicit forward Euler method with a time step $\\Delta \\tau$ yields:\n$$\n\\Delta x \\frac{u_i^{k+1} - u_i^k}{\\Delta \\tau} = -R_i(U^k)\n$$\nwhere $k$ is the pseudo-time iteration index. Solving for the updated state $u_i^{k+1}$, we get:\n$$\nu_i^{k+1} = u_i^k - \\frac{\\Delta \\tau}{\\Delta x} R_i(U^k)\n$$\nThis is the general form of the pseudo-time update. To make it explicit, we must evaluate the residual term $R_i(U^k)$. The residual for cell $i$ is defined as the net flux across its boundaries:\n$$\nR_i(U) = F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\n$$\nwhere $F_{i+\\frac{1}{2}}$ is the numerical flux at the interface between cell $i$ and cell $i+1$. The problem specifies a first-order upwind scheme. For a constant positive advection speed $a0$, the \"upwind\" direction is from the cell with the lower index. Therefore, the state used to evaluate the flux at interface $i+\\frac{1}{2}$ is the state in cell $i$, which is $u_i$.\n$$\nF_{i+\\frac{1}{2}} = f(u_i) = a u_i\n$$\nSimilarly, the numerical flux at the interface $i-\\frac{1}{2}$ (between cell $i-1$ and cell $i$) depends on the state in cell $i-1$:\n$$\nF_{i-\\frac{1}{2}} = f(u_{i-1}) = a u_{i-1}\n$$\nSubstituting these flux expressions into the residual definition gives:\n$$\nR_i(U^k) = a u_i^k - a u_{i-1}^k = a(u_i^k - u_{i-1}^k)\n$$\n(Due to periodicity, $u_0$ is understood as $u_N$.)\nNow, we substitute this explicit form of the residual into the pseudo-time update equation to obtain the first required result:\n$$\nu_i^{k+1} = u_i^k - \\frac{\\Delta \\tau}{\\Delta x} a(u_i^k - u_{i-1}^k)\n$$\n\nNext, we seek a condition on $\\Delta \\tau$ that guarantees the monotonic non-increase of the discrete residual $\\ell_1$ norm, i.e., $\\|R(U^{k+1})\\|_1 \\le \\|R(U^k)\\|_1$. We begin by finding an evolution equation for the residual itself. The residual at pseudo-time step $k+1$ is:\n$$\nR_i(U^{k+1}) = a(u_i^{k+1} - u_{i-1}^{k+1})\n$$\nWe substitute the update expressions for $u_i^{k+1}$ and $u_{i-1}^{k+1}$:\n$$\nu_i^{k+1} = u_i^k - \\frac{a \\Delta \\tau}{\\Delta x} (u_i^k - u_{i-1}^k) = u_i^k - \\frac{\\Delta \\tau}{\\Delta x} R_i(U^k)\n$$\n$$\nu_{i-1}^{k+1} = u_{i-1}^k - \\frac{a \\Delta \\tau}{\\Delta x} (u_{i-1}^k - u_{i-2}^k) = u_{i-1}^k - \\frac{\\Delta \\tau}{\\Delta x} R_{i-1}(U^k)\n$$\nSubstituting these into the expression for $R_i(U^{k+1})$:\n$$\nR_i(U^{k+1}) = a \\left[ \\left(u_i^k - \\frac{\\Delta \\tau}{\\Delta x} R_i(U^k)\\right) - \\left(u_{i-1}^k - \\frac{\\Delta \\tau}{\\Delta x} R_{i-1}(U^k)\\right) \\right]\n$$\n$$\nR_i(U^{k+1}) = a(u_i^k - u_{i-1}^k) - \\frac{a \\Delta \\tau}{\\Delta x} \\left( R_i(U^k) - R_{i-1}(U^k) \\right)\n$$\nRecognizing that $a(u_i^k - u_{i-1}^k) = R_i(U^k)$, we have:\n$$\nR_i^{k+1} = R_i^k - \\frac{a \\Delta \\tau}{\\Delta x} (R_i^k - R_{i-1}^k)\n$$\nLet's define the non-dimensional parameter $C = \\frac{a \\Delta \\tau}{\\Delta x}$. Rearranging the equation for $R_i^{k+1}$:\n$$\nR_i^{k+1} = (1 - C) R_i^k + C R_{i-1}^k\n$$\nThis is an upwind scheme for the advection of the residual itself. We now analyze the $\\ell_1$ norm of $R^{k+1}$:\n$$\n\\|R^{k+1}\\|_1 = \\sum_{i=1}^{N} |R_i^{k+1}| = \\sum_{i=1}^{N} |(1 - C) R_i^k + C R_{i-1}^k|\n$$\nUsing the triangle inequality, $|x+y| \\le |x|+|y|$:\n$$\n\\|R^{k+1}\\|_1 \\le \\sum_{i=1}^{N} \\left( |1 - C| |R_i^k| + |C| |R_{i-1}^k| \\right)\n$$\nSeparating the sums:\n$$\n\\|R^{k+1}\\|_1 \\le |1 - C| \\sum_{i=1}^{N} |R_i^k| + |C| \\sum_{i=1}^{N} |R_{i-1}^k|\n$$\nDue to the periodic boundary conditions, the sum over the shifted index $i-1$ is equal to the sum over the index $i$: $\\sum_{i=1}^{N} |R_{i-1}^k| = \\sum_{j=0}^{N-1} |R_j^k| = \\sum_{j=1}^{N} |R_j^k| = \\|R^k\\|_1$.\nTherefore, the inequality becomes:\n$$\n\\|R^{k+1}\\|_1 \\le (|1 - C| + |C|) \\|R^k\\|_1\n$$\nFor the residual norm to be monotonically non-increasing ($\\|R^{k+1}\\|_1 \\le \\|R^k\\|_1$), a sufficient condition is:\n$$\n|1 - C| + |C| \\le 1\n$$\nSince $a  0$, $\\Delta \\tau  0$ (for a forward step), and $\\Delta x  0$, the parameter $C = \\frac{a \\Delta \\tau}{\\Delta x}$ is strictly positive. So, $|C| = C$. The condition becomes:\n$$\n|1 - C| + C \\le 1\n$$\nWe analyze this condition for $C  0$.\n- If $0  C \\le 1$, then $1 - C \\ge 0$, so $|1 - C| = 1 - C$. The condition is $(1 - C) + C \\le 1$, which simplifies to $1 \\le 1$. This is always true.\n- If $C  1$, then $1 - C  0$, so $|1 - C| = -(1 - C) = C - 1$. The condition is $(C - 1) + C \\le 1$, which simplifies to $2C - 1 \\le 1$, or $2C \\le 2$, or $C \\le 1$. This contradicts the assumption that $C  1$.\nThus, the sufficient condition for monotonic non-increase of the residual norm is $0  C \\le 1$. In terms of the physical parameters, this is:\n$$\n0  \\frac{a \\Delta \\tau}{\\Delta x} \\le 1\n$$\nFinally, we must determine the largest allowable pseudo-time step, $\\Delta \\tau_{\\max}$, that guarantees this condition. This maximum value is obtained at the upper boundary of the inequality:\n$$\n\\frac{a \\Delta \\tau_{\\max}}{\\Delta x} = 1\n$$\nSolving for $\\Delta \\tau_{\\max}$ gives the final answer:\n$$\n\\Delta \\tau_{\\max} = \\frac{\\Delta x}{a}\n$$\nThe units are $[\\text{Length}] / ([\\text{Length}]/[\\text{Time}]) = [\\text{Time}]$, which is seconds in SI units, as required.",
            "answer": "$$\\boxed{\\frac{\\Delta x}{a}}$$"
        },
        {
            "introduction": "Explicit methods are simple, but their efficiency is often severely limited by stability constraints, especially for 'stiff' problems where different physical processes evolve on vastly different timescales. This practice  uses a scalar model problem to contrast the performance of explicit and implicit pseudo-time integration schemes. You will see firsthand how the conditional stability of explicit methods can lead to failure, while the unconditional stability of implicit methods enables robust and rapid convergence for stiff systems.",
            "id": "3313197",
            "problem": "Consider steady-state acceleration by dual time stepping for a single linearized residual mode. Let the pseudo-time error amplitude $e(\\tau)$ evolve under the scalar test equation derived from linearization of the residual operator about a steady solution, namely the ordinary differential equation $de/d\\tau = -\\lambda\\, e$ with $\\lambda \\gt 0$. The inner (pseudo-time) integration is performed either by the explicit forward Euler method or by the implicit backward Euler method. Starting from the normalized initial condition $e(0)=1$, determine the number of pseudo-time iterations required so that the error amplitude is reduced to at most $10^{-6}$.\n\nYou must derive the iteration counts from first principles, beginning with the scalar test equation $de/d\\tau = -\\lambda e$, and then applying the update of each time integration scheme to obtain the per-iteration error amplification factor. Use the following definitions and constraints:\n- Pseudo-time step size is fixed at $\\Delta \\tau = 10^{-5}$ (in seconds).\n- For the explicit forward Euler scheme, use the update that results from discretizing $de/d\\tau = -\\lambda e$ by a single forward Euler step of size $\\Delta \\tau$.\n- For the implicit backward Euler scheme, use the update that results from discretizing $de/d\\tau = -\\lambda e$ by a single backward Euler step of size $\\Delta \\tau$.\n- The required number of iterations, if convergence occurs, is the smallest integer $n$ such that the magnitude of the error after $n$ iterations is at most $10^{-6}$.\n- If the explicit scheme does not strictly reduce the error magnitude (that is, if the magnitude of its amplification factor is greater than or equal to $1$), declare the explicit iteration count as $+\\infty$.\n\nTest suite:\n- Use the six values $\\lambda \\in \\{10^{2},\\,10^{4},\\,2\\times 10^{5},\\,3\\times 10^{5},\\,5\\times 10^{5},\\,10^{6}\\}$.\n- For each $\\lambda$ in the above set, compute a pair of results $[n_{\\text{explicit}}, n_{\\text{implicit}}]$, where each entry is the integer iteration count if finite, and $+\\infty$ if non-convergent.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the six test cases as a comma-separated list of pairs, enclosed in square brackets, and with no spaces. For example, an admissible format is of the form $[[a,b],[c,d],\\dots]$ where each $a,b,c,d$ is either a nonnegative integer written in decimal or the symbol $\\infty$ represented by the floating-point literal $inf$.\n- The outputs are dimensionless counts; no physical units are required in the output.",
            "solution": "The problem requires the determination of the number of pseudo-time iterations, $n$, needed to reduce the amplitude of a linearized residual error mode to a fraction $10^{-6}$ of its initial value. The error amplitude, $e(\\tau)$, is governed by the scalar ordinary differential equation (ODE):\n$$\n\\frac{de}{d\\tau} = -\\lambda e(\\tau)\n$$\nwith a real, positive eigenvalue $\\lambda  0$ and initial condition $e(0)=1$. The pseudo-time integration is performed using a fixed step size $\\Delta\\tau = 10^{-5}$ with two different schemes: explicit forward Euler and implicit backward Euler.\n\nLet $e_k$ denote the numerical approximation to $e(k\\Delta\\tau)$. The iterative process for both schemes can be expressed in the form $e_{k+1} = G e_k$, where $G$ is the amplification factor. Starting from $e_0 = 1$, the error after $n$ iterations is $e_n = G^n e_0 = G^n$. The convergence criterion is to find the smallest integer $n$ such that $|e_n| \\leq 10^{-6}$, which translates to $|G|^n \\leq 10^{-6}$.\n\nIf $|G|  1$, we can find $n$ by taking the natural logarithm of both sides:\n$$\nn \\ln|G| \\leq \\ln(10^{-6})\n$$\nSince $|G|  1$, $\\ln|G|$ is negative. Dividing by $\\ln|G|$ reverses the inequality sign:\n$$\nn \\geq \\frac{\\ln(10^{-6})}{\\ln|G|}\n$$\nThe required number of iterations is the smallest integer satisfying this condition, which is given by the ceiling function:\n$$\nn = \\left\\lceil \\frac{\\ln(10^{-6})}{\\ln|G|} \\right\\rceil\n$$\nIf $|G| \\geq 1$, the error does not decrease, and the iteration count is considered infinite ($+\\infty$).\n\nWe now derive the amplification factor $G$ for each scheme.\n\n**1. Explicit Forward Euler Scheme**\n\nThe forward Euler method discretizes the ODE by approximating the derivative at the current time level, $\\tau_k$:\n$$\n\\frac{e_{k+1} - e_k}{\\Delta\\tau} = -\\lambda e_k\n$$\nSolving for $e_{k+1}$, we obtain the update rule:\n$$\ne_{k+1} = e_k - \\lambda \\Delta\\tau e_k = (1 - \\lambda \\Delta\\tau) e_k\n$$\nThe amplification factor for the explicit scheme is therefore:\n$$\nG_{\\text{explicit}} = 1 - \\lambda \\Delta\\tau\n$$\nFor convergence, the magnitude of the amplification factor must be strictly less than $1$:\n$$\n|G_{\\text{explicit}}| = |1 - \\lambda \\Delta\\tau|  1\n$$\nSince $\\lambda  0$ and $\\Delta\\tau  0$, the product $\\lambda\\Delta\\tau$ is positive. The inequality is equivalent to $-1  1 - \\lambda\\Delta\\tau  1$.\nThe right-hand side, $1 - \\lambda\\Delta\\tau  1$, implies $-\\lambda\\Delta\\tau  0$, which is always true.\nThe left-hand side, $-1  1 - \\lambda\\Delta\\tau$, implies $\\lambda\\Delta\\tau  2$.\nThus, the explicit forward Euler scheme is stable only if $\\lambda\\Delta\\tau  2$. According to the problem statement, if this condition is not met (i.e., if $|G_{\\text{explicit}}| \\geq 1$, which corresponds to $\\lambda\\Delta\\tau \\geq 2$), the number of iterations is $n_{\\text{explicit}} = +\\infty$.\nWhen the scheme is stable, the number of iterations is:\n$$\nn_{\\text{explicit}} = \\left\\lceil \\frac{\\ln(10^{-6})}{\\ln|1 - \\lambda\\Delta\\tau|} \\right\\rceil\n$$\n\n**2. Implicit Backward Euler Scheme**\n\nThe backward Euler method discretizes the ODE by approximating the derivative at the next time level, $\\tau_{k+1}$:\n$$\n\\frac{e_{k+1} - e_k}{\\Delta\\tau} = -\\lambda e_{k+1}\n$$\nSolving for $e_{k+1}$:\n$$\ne_{k+1} + \\lambda \\Delta\\tau e_{k+1} = e_k \\implies e_{k+1}(1 + \\lambda\\Delta\\tau) = e_k\n$$\nThis gives the update rule:\n$$\ne_{k+1} = \\frac{1}{1 + \\lambda\\Delta\\tau} e_k\n$$\nThe amplification factor for the implicit scheme is:\n$$\nG_{\\text{implicit}} = \\frac{1}{1 + \\lambda\\Delta\\tau}\n$$\nSince $\\lambda  0$ and $\\Delta\\tau  0$, the denominator $1 + \\lambda\\Delta\\tau$ is always greater than $1$. Consequently, $0  G_{\\text{implicit}}  1$ for all valid problem parameters. The implicit backward Euler scheme is unconditionally stable for this ODE. The number of iterations is always finite and is given by:\n$$\nn_{\\text{implicit}} = \\left\\lceil \\frac{\\ln(10^{-6})}{\\ln\\left(\\frac{1}{1 + \\lambda\\Delta\\tau}\\right)} \\right\\rceil = \\left\\lceil \\frac{\\ln(10^{-6})}{-\\ln(1 + \\lambda\\Delta\\tau)} \\right\\rceil = \\left\\lceil \\frac{-\\ln(10^{-6})}{\\ln(1 + \\lambda\\Delta\\tau)} \\right\\rceil\n$$\n\n**Numerical Evaluation**\n\nWe apply these formulas to the given test suite with $\\Delta\\tau = 10^{-5}$ and a tolerance target of $10^{-6}$.\n\n- **Case 1: $\\lambda = 10^2$**\n  - $\\lambda\\Delta\\tau = 10^2 \\times 10^{-5} = 0.001$. This satisfies the explicit stability condition $\\lambda\\Delta\\tau  2$.\n  - $n_{\\text{explicit}} = \\left\\lceil \\frac{\\ln(10^{-6})}{\\ln|1 - 0.001|} \\right\\rceil = \\left\\lceil \\frac{-13.8155}{-0.0010005} \\right\\rceil = \\lceil 13808.6 \\rceil = 13809$.\n  - $n_{\\text{implicit}} = \\left\\lceil \\frac{-\\ln(10^{-6})}{\\ln(1 + 0.001)} \\right\\rceil = \\left\\lceil \\frac{13.8155}{0.0009995} \\right\\rceil = \\lceil 13822.4 \\rceil = 13823$.\n  - Result: $[13809, 13823]$\n\n- **Case 2: $\\lambda = 10^4$**\n  - $\\lambda\\Delta\\tau = 10^4 \\times 10^{-5} = 0.1$. This satisfies $\\lambda\\Delta\\tau  2$.\n  - $n_{\\text{explicit}} = \\left\\lceil \\frac{\\ln(10^{-6})}{\\ln|1 - 0.1|} \\right\\rceil = \\left\\lceil \\frac{-13.8155}{-0.10536} \\right\\rceil = \\lceil 131.12 \\rceil = 132$.\n  - $n_{\\text{implicit}} = \\left\\lceil \\frac{-\\ln(10^{-6})}{\\ln(1 + 0.1)} \\right\\rceil = \\left\\lceil \\frac{13.8155}{0.09531} \\right\\rceil = \\lceil 144.95 \\rceil = 145$.\n  - Result: $[132, 145]$\n\n- **Case 3: $\\lambda = 2 \\times 10^5$**\n  - $\\lambda\\Delta\\tau = 2 \\times 10^5 \\times 10^{-5} = 2$. This is the stability limit. $|G_{\\text{explicit}}| = |1 - 2| = 1$.\n  - $n_{\\text{explicit}} = +\\infty$.\n  - $n_{\\text{implicit}} = \\left\\lceil \\frac{-\\ln(10^{-6})}{\\ln(1 + 2)} \\right\\rceil = \\left\\lceil \\frac{13.8155}{1.0986} \\right\\rceil = \\lceil 12.57 \\rceil = 13$.\n  - Result: $[+\\infty, 13]$\n\n- **Case 4: $\\lambda = 3 \\times 10^5$**\n  - $\\lambda\\Delta\\tau = 3 \\times 10^5 \\times 10^{-5} = 3$. This violates the stability condition $\\lambda\\Delta\\tau  2$.\n  - $n_{\\text{explicit}} = +\\infty$.\n  - $n_{\\text{implicit}} = \\left\\lceil \\frac{-\\ln(10^{-6})}{\\ln(1 + 3)} \\right\\rceil = \\left\\lceil \\frac{13.8155}{1.3863} \\right\\rceil = \\lceil 9.966 \\rceil = 10$.\n  - Result: $[+\\infty, 10]$\n\n- **Case 5: $\\lambda = 5 \\times 10^5$**\n  - $\\lambda\\Delta\\tau = 5 \\times 10^5 \\times 10^{-5} = 5$. This violates the stability condition.\n  - $n_{\\text{explicit}} = +\\infty$.\n  - $n_{\\text{implicit}} = \\left\\lceil \\frac{-\\ln(10^{-6})}{\\ln(1 + 5)} \\right\\rceil = \\left\\lceil \\frac{13.8155}{1.7918} \\right\\rceil = \\lceil 7.71 \\rceil = 8$.\n  - Result: $[+\\infty, 8]$\n\n- **Case 6: $\\lambda = 10^6$**\n  - $\\lambda\\Delta\\tau = 10^6 \\times 10^{-5} = 10$. This violates the stability condition.\n  - $n_{\\text{explicit}} = +\\infty$.\n  - $n_{\\text{implicit}} = \\left\\lceil \\frac{-\\ln(10^{-6})}{\\ln(1 + 10)} \\right\\rceil = \\left\\lceil \\frac{13.8155}{2.3979} \\right\\rceil = \\lceil 5.76 \\rceil = 6$.\n  - Result: $[+\\infty, 6]$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the number of pseudo-time iterations for error reduction\n    using explicit forward Euler and implicit backward Euler schemes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        10**2,\n        10**4,\n        2 * 10**5,\n        3 * 10**5,\n        5 * 10**5,\n        10**6,\n    ]\n\n    delta_tau = 1e-5\n    tolerance = 1e-6\n    # Pre-calculate the natural logarithm of the tolerance for efficiency.\n    log_tolerance = np.log(tolerance)\n\n    results = []\n    for lam in test_cases:\n        # Calculate the dimensionless product lambda * delta_tau\n        lambda_dt = lam * delta_tau\n\n        # --- Explicit Forward Euler ---\n        # The stability condition for the explicit scheme is lambda * delta_tau  2.\n        # If lambda * delta_tau = 2, the amplification factor's magnitude is = 1,\n        # leading to non-convergence.\n        if lambda_dt = 2.0:\n            n_explicit = np.inf\n        else:\n            # Amplification factor G = 1 - lambda * delta_tau\n            # We need |G|^n = tolerance, so n = log(tolerance) / log(|G|).\n            # The result must be the smallest integer, hence the ceiling.\n            g_explicit = abs(1.0 - lambda_dt)\n            n_explicit = int(np.ceil(log_tolerance / np.log(g_explicit)))\n\n        # --- Implicit Backward Euler ---\n        # The implicit scheme is unconditionally stable for this problem.\n        # Amplification factor G = 1 / (1 + lambda * delta_tau)\n        # We need G^n = tolerance, so n = log(tolerance) / log(G).\n        # log(G) = log(1 / (1 + lambda_dt)) = -log(1 + lambda_dt).\n        # Thus, n = log(tolerance) / -log(1 + lambda_dt).\n        n_implicit = int(np.ceil(log_tolerance / -np.log(1.0 + lambda_dt)))\n\n        results.append((n_explicit, n_implicit))\n\n    # Format the output string to match the exact requirement: [[a,b],[c,d],...] with no spaces.\n    formatted_pairs = []\n    for n_exp, n_imp in results:\n        # np.inf stringifies to 'inf' by default, which is required.\n        s_exp = 'inf' if np.isinf(n_exp) else str(int(n_exp))\n        s_imp = str(int(n_imp))\n        formatted_pairs.append(f\"[{s_exp},{s_imp}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_pairs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the robustness of implicit schemes, this final practice addresses a common challenge in CFD: enforcing physical constraints, such as the non-negativity of density or concentration. This problem  demonstrates how to combine an implicit pseudo-time step with a positivity-preserving projection to ensure the solution remains physically admissible. Through both theoretical analysis and numerical implementation, you will explore how this composite scheme forms a contractive mapping, guaranteeing stable convergence to the steady-state solution for any pseudo-time step.",
            "id": "3313179",
            "problem": "Consider a one-dimensional, nondimensional steady-state diffusion-reaction model for a nonnegative scalar conserved density represented by a vector $U \\in \\mathbb{R}^N$ on a uniform grid of $N$ interior points. The spatial residual operator is defined by the second-order central difference approximation of the diffusion term combined with a linear reaction and a nonnegative volumetric source. Specifically, for indices $i \\in \\{1,\\dots,N\\}$, the discrete residual can be written as\n$$\nR_i(U) = -\\nu \\frac{U_{i+1} - 2 U_i + U_{i-1}}{(\\Delta x)^2} + k\\, U_i - q_i,\n$$\nwith homogeneous Dirichlet boundary conditions $U_0 = U_{N+1} = 0$, where $N$ is the number of interior points, $\\Delta x$ is the grid spacing, $\\nu$ is the diffusion coefficient, $k$ is the reaction rate, and $q_i \\ge 0$ is the source term. In vector form, the residual is $R(U) = A U - q$, where $A \\in \\mathbb{R}^{N \\times N}$ is the symmetric positive definite tridiagonal matrix\n$$\nA = \\left(k + \\frac{2 \\nu}{(\\Delta x)^2}\\right) I - \\frac{\\nu}{(\\Delta x)^2} \\left(S + S^\\top\\right),\n$$\nwith $I$ the identity and $S$ the strictly lower bidiagonal shift matrix with ones on the first subdiagonal.\n\nTo accelerate convergence to a steady state $R(U) = 0$, use dual time stepping with implicit backward Euler in the pseudo-time variable $\\tau$. One implicit pseudo-time update from $U^n$ to $U^{n+1}$ with step size $\\Delta \\tau$ solves\n$$\n\\left(I + \\Delta \\tau\\, A\\right) U^{n+1} = U^n + \\Delta \\tau\\, q.\n$$\nThe resulting update can violate the admissibility constraint $U \\ge 0$. To prevent this, apply a positivity-preserving limiter defined as the Euclidean projection onto the closed convex set $\\mathcal{A} = \\{ V \\in \\mathbb{R}^N \\, | \\, V_i \\ge 0 \\ \\text{for all} \\ i \\}$. Denote this projection by $P: \\mathbb{R}^N \\to \\mathcal{A}$, which acts componentwise as $P(U)_i = \\max(U_i, 0)$. The composite one-step map is then\n$$\nT(U) = P\\!\\left(M U + c\\right), \\quad \\text{where} \\quad M = \\left(I + \\Delta \\tau\\, A\\right)^{-1}, \\quad c = \\Delta \\tau \\left(I + \\Delta \\tau\\, A\\right)^{-1} q.\n$$\n\nYour tasks are:\n- Starting from the governing discrete residual $R(U)$ and the implicit backward Euler pseudo-time update, explain why the matrix $A$ is symmetric positive definite for $k  0$ and $\\nu  0$ on a uniform grid with homogeneous Dirichlet boundary conditions. Using this, deduce that the linear operator $M$ has singular values $\\sigma_i(M) = \\frac{1}{1 + \\Delta \\tau\\, \\lambda_i(A)}$, where $\\lambda_i(A)$ are the eigenvalues of $A$, and hence the induced $2$-norm satisfies $\\|M\\|_2 = \\max_i \\sigma_i(M) = \\frac{1}{1 + \\Delta \\tau\\, \\lambda_{\\min}(A)} \\le 1$. Note that the Euclidean projection $P$ onto the closed convex set $\\mathcal{A}$ is nonexpansive in the $2$-norm. Conclude that $T$ is nonexpansive with Lipschitz constant bounded by $\\|M\\|_2 \\le 1$ and explain the implications for stability of dual time stepping with a positivity-preserving projection.\n- Implement the one-step implicit update and the projection $P$ for specified parameters. Evaluate the stability of dual time stepping with and without positivity-preserving projection by computing and reporting specified quantities for a set of test cases.\n\nAll quantities are nondimensional. Angles are not involved. Results must be reported as fundamental types as described below.\n\nUse the following test suite. For each case, construct the matrix $A$, compute the implicit update $U^{n+1}$ by solving $\\left(I + \\Delta \\tau\\, A\\right) U^{n+1} = U^n + \\Delta \\tau\\, q$, then apply the projection $P$ when required, and compute the specified outputs.\n\n- Test case $1$ (happy path positivity after projection):\n  - Parameters: $N = 20$, $\\Delta x = \\frac{1}{N+1}$, $\\nu = 0.1$, $k = 1.0$, $\\Delta \\tau = 0.5$, $q_i = 1.0$ for all $i$.\n  - Initial condition: $U^0_i = -0.3 + 0.02 i$ for $i = 1,\\dots,N$.\n  - Output: a boolean indicating whether $P(U^{n+1})_i \\ge 0$ for all $i$.\n\n- Test case $2$ (edge case illustrating violation without projection):\n  - Same parameters and initial condition as Test case $1$.\n  - Output: a boolean indicating whether the unprojected $U^{n+1}$ contains at least one component $ 0$.\n\n- Test case $3$ (stability factor at moderate pseudo-time step):\n  - Same parameters as Test case $1$.\n  - Output: a float equal to the largest singular value of $M = \\left(I + \\Delta \\tau\\, A\\right)^{-1}$, computed numerically.\n\n- Test case $4$ (boundary condition for large pseudo-time step):\n  - Parameters: $N = 20$, $\\Delta x = \\frac{1}{N+1}$, $\\nu = 0.1$, $k = 1.0$, $\\Delta \\tau = 100.0$, $q_i = 1.0$ for all $i$.\n  - Output: a float equal to the largest singular value of $M = \\left(I + \\Delta \\tau\\, A\\right)^{-1}$, computed numerically.\n\n- Test case $5$ (nonexpansiveness of the composite map):\n  - Same parameters as Test case $1$.\n  - Choose two distinct initial conditions: $U^0_i = -0.3 + 0.02 i$ and $V^0_i = 0.1 + 0.01 i$ for $i = 1,\\dots,N$.\n  - Compute $T(U^0)$ and $T(V^0)$ with $T$ defined above using the same $M$ and $c$ from Test case $1$ and the projection $P$.\n  - Output: a boolean indicating whether\n    $$\n    \\frac{\\|T(U^0) - T(V^0)\\|_2}{\\|U^0 - V^0\\|_2} \\le \\|M\\|_2 + 10^{-12}.\n    $$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the five test cases: $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]$. All booleans must be reported as either $\\text{True}$ or $\\text{False}$ and all floats must be reported in standard decimal notation without units.",
            "solution": "The problem posed is valid as it is scientifically grounded in the principles of numerical analysis and computational fluid dynamics, is well-posed with all necessary information provided, and is expressed in objective, formal language. It is free of contradictions, ambiguities, and factual errors. I will now provide the solution.\n\nThe solution consists of two parts. First, a theoretical explanation of the stability properties of the dual time-stepping scheme with a positivity-preserving projection. Second, the implementation of the numerical algorithm to compute the results for the prescribed test cases.\n\n### Theoretical Analysis\n\nThe one-step map for the dual time-stepping scheme is given by $T(U) = P(M U + c)$, where $P$ is the projection onto the non-negative orthant, $M = (I + \\Delta \\tau\\, A)^{-1}$, and $c = \\Delta \\tau\\, M q$. We will demonstrate that for any pseudo-time step $\\Delta \\tau  0$, this map is a contraction, which guarantees the stability and convergence of the iterative process.\n\n**1. Properties of the System Matrix $A$**\n\nThe matrix $A$ is defined as\n$$A = \\left(k + \\frac{2 \\nu}{(\\Delta x)^2}\\right) I - \\frac{\\nu}{(\\Delta x)^2} \\left(S + S^\\top\\right)$$\nwhere $I$ is the identity matrix and $S$ is the strictly lower bidiagonal shift matrix.\n\n**Symmetry:** The identity matrix $I$ is symmetric. The matrix $S+S^\\top$ is also symmetric by construction. Therefore, $A$, as a linear combination of symmetric matrices, is itself symmetric.\n\n**Positive Definiteness:** To show that $A$ is positive definite for $k  0$ and $\\nu  0$, we examine the quadratic form $v^\\top A v$ for any non-zero vector $v \\in \\mathbb{R}^N$.\n$$\nv^\\top A v = v^\\top \\left( \\left(k + \\frac{2 \\nu}{(\\Delta x)^2}\\right) I - \\frac{\\nu}{(\\Delta x)^2} \\left(S + S^\\top\\right) \\right) v = k v^\\top v + \\frac{\\nu}{(\\Delta x)^2} v^\\top \\left( 2I - S - S^\\top \\right) v\n$$\nThe first term is $k \\|v\\|_2^2$, which is strictly positive for $v \\neq 0$ since $k  0$. The matrix $L = 2I - S - S^\\top$ is the standard $N \\times N$ matrix representation of the one-dimensional discrete Laplacian operator with homogeneous Dirichlet boundary conditions. Its quadratic form can be expressed as a sum of squares. By extending $v$ with boundary values $v_0 = 0$ and $v_{N+1} = 0$, we have:\n\\begin{align*} v^\\top L v = \\sum_{i=1}^{N} v_i (2v_i - v_{i-1} - v_{i+1}) \\\\ = 2 \\sum_{i=1}^{N} v_i^2 - 2 \\sum_{i=1}^{N-1} v_i v_{i+1} \\\\ = v_1^2 + \\sum_{i=1}^{N-1} (v_i^2 - 2v_i v_{i+1} + v_{i+1}^2) + v_N^2 \\\\ = v_1^2 + \\sum_{i=1}^{N-1} (v_i - v_{i+1})^2 + v_N^2 \\end{align*}\nThis expression is a sum of squared real numbers, so $v^\\top L v \\ge 0$. This sum is zero only if $v_1 = 0$ and $v_i = v_{i+1}$ for all $i \\in \\{1, \\dots, N-1\\}$, which recursively implies $v_1 = v_2 = \\dots = v_N = 0$. Thus, for any non-zero vector $v$, $v^\\top L v  0$, meaning $L$ is positive definite.\n\nSince $k  0$, $\\nu  0$, $\\|v\\|_2^2  0$, and $v^\\top L v  0$ for $v \\neq 0$, the quadratic form $v^\\top A v = k \\|v\\|_2^2 + \\frac{\\nu}{(\\Delta x)^2} v^\\top L v$ is strictly positive. Therefore, $A$ is symmetric positive definite (SPD). All eigenvalues of $A$, denoted $\\lambda_i(A)$, are real and positive.\n\n**2. Properties of the Update Matrix $M$**\n\nThe matrix $M$ is defined as $M = (I + \\Delta \\tau A)^{-1}$. Since $A$ is SPD, it has a spectral decomposition $A = Q \\Lambda_A Q^\\top$, where $Q$ is an orthogonal matrix of eigenvectors and $\\Lambda_A$ is a diagonal matrix of positive eigenvalues $\\lambda_i(A)$.\nThen, $I + \\Delta \\tau A = Q (I + \\Delta \\tau \\Lambda_A) Q^\\top$. The inverse is $M = [Q (I + \\Delta \\tau \\Lambda_A) Q^\\top]^{-1} = Q (I + \\Delta \\tau \\Lambda_A)^{-1} Q^\\top$.\nThis is the spectral decomposition of $M$. It shows $M$ is also symmetric. The eigenvalues of $M$ are $\\lambda_i(M) = \\frac{1}{1 + \\Delta \\tau \\lambda_i(A)}$.\nSince $M$ is symmetric, its singular values $\\sigma_i(M)$ are the absolute values of its eigenvalues. As $\\Delta \\tau  0$ and $\\lambda_i(A)  0$, the eigenvalues $\\lambda_i(M)$ are all positive. Thus, the singular values of $M$ are:\n$$\n\\sigma_i(M) = \\lambda_i(M) = \\frac{1}{1 + \\Delta \\tau\\, \\lambda_i(A)}\n$$\n\nThe induced $2$-norm of $M$, $\\|M\\|_2$, is its largest singular value. The function $f(x) = (1 + c x)^{-1}$ for a constant $c  0$ is monotonically decreasing for $x0$. Therefore, the maximum singular value of $M$ corresponds to the minimum eigenvalue of $A$, $\\lambda_{\\min}(A)$:\n$$\n\\|M\\|_2 = \\max_i \\sigma_i(M) = \\frac{1}{1 + \\Delta \\tau\\, \\lambda_{\\min}(A)}\n$$\nSince $\\lambda_{\\min}(A)  0$ and $\\Delta \\tau \\ge 0$, we have $1 + \\Delta \\tau \\lambda_{\\min}(A) \\ge 1$, which implies $\\|M\\|_2 \\le 1$. For any physically meaningful pseudo-time step $\\Delta \\tau  0$, the inequality is strict: $\\|M\\|_2  1$.\n\n**3. Nonexpansiveness of the Composite Map $T$**\n\nThe map $T$ is a composition of a linear transformation and a projection: $T(U) = P(MU + c)$. Let us analyze its Lipschitz constant. Consider two vectors $U$ and $V$ in $\\mathbb{R}^N$.\n$$\n\\|T(U) - T(V)\\|_2 = \\|P(MU+c) - P(MV+c)\\|_2\n$$\nThe Euclidean projection $P$ onto a closed convex set (here, the non-negative orthant $\\mathcal{A}$) is a nonexpansive map. This means $\\|P(X) - P(Y)\\|_2 \\le \\|X - Y\\|_2$ for any vectors $X, Y$. This can be confirmed by noting that its component-wise action $p(x) = \\max(x,0)$ has a Lipschitz constant of $1$, i.e., $|\\max(x_1, 0) - \\max(x_2, 0)| \\le |x_1 - x_2|$.\nApplying this property, we get:\n$$\n\\|P(MU+c) - P(MV+c)\\|_2 \\le \\|(MU+c) - (MV+c)\\|_2 = \\|M(U-V)\\|_2\n$$\nBy the definition of the induced $2$-norm, $\\|M(U-V)\\|_2 \\le \\|M\\|_2 \\|U-V\\|_2$. Combining these inequalities yields:\n$$\n\\|T(U) - T(V)\\|_2 \\le \\|M\\|_2 \\|U-V\\|_2\n$$\nThis shows that $T$ is a Lipschitz continuous map with a Lipschitz constant bounded by $\\|M\\|_2$. Since we have shown that $\\|M\\|_2 \\le 1$, the map $T$ is nonexpansive. For any $\\Delta \\tau  0$, $\\|M\\|_2  1$, which makes $T$ a contraction mapping.\n\n**4. Implications for Stability**\n\nThe iterative update is $U^{n+1} = T(U^n)$. Since $T$ is a contraction mapping on the complete metric space $\\mathbb{R}^N$, the Banach Fixed-Point Theorem applies. This theorem guarantees that the iteration converges to a unique fixed point $U^*$ satisfying $U^* = T(U^*)$, regardless of the initial guess $U^0$. This property implies that the dual time-stepping scheme is unconditionally stable for any choice of $\\Delta \\tau  0$. The projection $P$ ensures that each iterate $U^n$ (for $n \\ge 1$) satisfies the positivity constraint, i.e., $U^n \\in \\mathcal{A}$. The contractivity of the map ensures this stable, positivity-preserving sequence converges to the unique steady-state solution. The convergence rate is determined by the contraction factor $\\|M\\|_2$; smaller values of $\\|M\\|_2$ (achieved with larger $\\Delta \\tau$) lead to faster convergence.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_A(N, dx, nu, k):\n    \"\"\"\n    Constructs the system matrix A for the 1D diffusion-reaction problem.\n    \"\"\"\n    diag_val = k + 2.0 * nu / (dx**2)\n    offdiag_val = -nu / (dx**2)\n    \n    A = np.diag(np.full(N, diag_val))\n    A += np.diag(np.full(N - 1, offdiag_val), k=1)\n    A += np.diag(np.full(N - 1, offdiag_val), k=-1)\n    return A\n\ndef solve():\n    \"\"\"\n    Solves the five test cases specified in the problem statement.\n    \"\"\"\n    results = []\n\n    # --- Common Parameters for Cases 1, 2, 3, 5 ---\n    N = 20\n    dx = 1.0 / (N + 1)\n    nu = 0.1\n    k = 1.0\n    dt_case1 = 0.5\n    q = np.ones(N)\n    i_vals = np.arange(1, N + 1)\n\n    A = build_A(N, dx, nu, k)\n\n    # --- Test Cases 1 and 2: Positivity and Violation ---\n    U0_case1 = -0.3 + 0.02 * i_vals\n    LHS_case1 = np.eye(N) + dt_case1 * A\n    RHS_case1 = U0_case1 + dt_case1 * q\n    \n    # Solve for unprojected U^{n+1}\n    U_np1_unprojected = np.linalg.solve(LHS_case1, RHS_case1)\n\n    # Case 1: Check positivity after projection\n    # The projection is P(U)_i = max(U_i, 0). By definition, all\n    # components of the resulting vector are non-negative.\n    P_U_np1 = np.maximum(U_np1_unprojected, 0)\n    result1 = np.all(P_U_np1 = 0)\n    results.append(result1)\n    \n    # Case 2: Check for negativity before projection\n    result2 = np.any(U_np1_unprojected  0)\n    results.append(result2)\n\n    # --- Test Case 3: Stability Factor (moderate dt) ---\n    # M = (I + dt*A)^{-1} = inv(LHS_case1)\n    M_case1 = np.linalg.inv(LHS_case1)\n    svd_vals_case3 = np.linalg.svd(M_case1, compute_uv=False)\n    # The largest singular value is the first element of the returned array.\n    norm_M_case3 = svd_vals_case3[0]\n    results.append(norm_M_case3)\n\n    # --- Test Case 4: Stability Factor (large dt) ---\n    dt_case4 = 100.0\n    LHS_case4 = np.eye(N) + dt_case4 * A\n    M_case4 = np.linalg.inv(LHS_case4)\n    svd_vals_case4 = np.linalg.svd(M_case4, compute_uv=False)\n    norm_M_case4 = svd_vals_case4[0]\n    results.append(norm_M_case4)\n\n    # --- Test Case 5: Nonexpansiveness of Composite Map T ---\n    # Parameters are from Case 1\n    # U0 is U0_case1\n    V0_case5 = 0.1 + 0.01 * i_vals\n    \n    # T(U) = P(M*U + c) where c = dt * M * q\n    # M is M_case1 from Case 3\n    c = dt_case1 * (M_case1 @ q)\n    \n    # Apply the one-step map T to both initial conditions\n    T_U0 = np.maximum(M_case1 @ U0_case1 + c, 0)\n    T_V0 = np.maximum(M_case1 @ V0_case5 + c, 0)\n    \n    # Calculate the norms to check the inequality\n    norm_diff_T = np.linalg.norm(T_U0 - T_V0)\n    norm_diff_initial = np.linalg.norm(U0_case1 - V0_case5)\n    \n    # Check if a zero-norm vector was produced by chance, to avoid division by zero\n    if norm_diff_initial == 0:\n        # If U0=V0, then T(U0)=T(V0), norm_diff_T=0, so the ratio is 0 or undefined.\n        # But U0 and V0 are distinct.\n        is_nonexpansive = (norm_diff_T = (norm_M_case3 + 1e-12) * norm_diff_initial)\n    else:\n        is_nonexpansive = (norm_diff_T / norm_diff_initial) = (norm_M_case3 + 1e-12)\n        \n    results.append(is_nonexpansive)\n\n    # Final print statement in the exact required format.\n    # Convert booleans to strings 'True'/'False' and format floats\n    formatted_results = []\n    for r in results:\n        if isinstance(r, bool) or isinstance(r, np.bool_):\n            formatted_results.append(str(r))\n        else:\n            # Standard decimal notation for floats\n            formatted_results.append(f\"{r:.15f}\".rstrip('0').rstrip('.'))\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}