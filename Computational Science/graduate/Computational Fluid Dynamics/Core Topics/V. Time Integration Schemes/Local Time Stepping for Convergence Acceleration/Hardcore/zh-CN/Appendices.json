{
    "hands_on_practices": [
        {
            "introduction": "在实施局部时间步长等高级加速策略之前，从根本上理解其为何能加速收敛至关重要。本练习将这一方法简化至最核心的部分：一个简单的一维平流问题。通过从第一性原理出发，您将推导出局部时间步长与经典的加权雅可比迭代法之间的直接联系，从而获得对收敛因子 $\\rho$ 的解析认识。这项实践旨在通过理论分析，揭示局部时间步长加速稳态计算的数学本质。",
            "id": "3341489",
            "problem": "考虑具有恒定平流速度 $a>0$ 的一维线性平流方程，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\n该方程在三个长度分别为 $\\Delta x_1$、$\\Delta x_2$ 和 $\\Delta x_3$ 的连续控制体（单元）上通过有限体积法进行离散化。假设采用与 $a>0$ 一致的一阶迎风数值通量，并在左边界施加流入狄利克雷（Dirichlet）边界条件。令 $u_i(t)$ 表示单元 $i$ 内的单元平均值。单元 $i$ 内的半离散残差是其各个面上数值通量之差。为将解推进至稳态，考虑采用具有单元局部时间步长 $\\Delta t_i$ 的显式前向欧拉伪时间推进格式：\n$$\nu_i^{n+1} \\;=\\; u_i^n \\;-\\; \\frac{\\Delta t_i}{\\Delta x_i}\\, R_i\\!\\left(u^n\\right),\n$$\n其中 $R_i(u)$ 是有限体积残差，$\\Delta x_i$ 是一维情况下的单元体积。\n\n从第一性原理（即针对 $a>0$ 的线性平流问题的有限体积守恒，并采用迎风通量）出发，推导残差 $R_i(u)$。然后，使用Courant–Friedrichs–Lewy（CFL）稳定性判据，并选择一个Courant–Friedrichs–Lewy（CFL）数 $C \\in (0,1]$，来确定以 $(\\Delta x_i, a, C)$ 表示的局部时间步长 $\\Delta t_i$。利用该迭代对应的线性误差传播形式，将此伪时间步进模拟为稳态线性系统的加权雅可比（weighted-Jacobi）松弛，并以 $C$ 来估计单次伪时间迭代的收缩因子 $\\rho$。\n\n将时间步长以秒为单位表示，收缩因子以无量纲小数表示。以单行矩阵的形式给出最终答案，其中依次包含 $\\Delta t_1$、$\\Delta t_2$、$\\Delta t_3$ 和 $\\rho$。无需对 $(\\Delta x_i, a, C)$ 进行数值代入。最终答案必须是单个解析表达式。",
            "solution": "首先验证问题的科学性、适定性和客观性。\n\n已知条件如下：\n- 控制方程：$\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0$，具有恒定平流速度 $a>0$。\n- 空间离散化：在三个长度分别为 $\\Delta x_1$、$\\Delta x_2$、$\\Delta x_3$ 的连续单元上采用有限体积法。\n- 数值通量：一阶迎风格式，与 $a>0$ 一致。\n- 边界条件：左边界为流入狄利克雷（Dirichlet）条件。\n- 时间离散化（伪时间）：采用单元局部时间步长 $\\Delta t_i$ 的显式前向欧拉法。\n- 更新公式：$u_i^{n+1} = u_i^n - \\frac{\\Delta t_i}{\\Delta x_i} R_i(u^n)$，其中 $u_i$ 是单元平均值，$R_i(u)$ 是有限体积残差。\n- 稳定性判据：使用Courant–Friedrichs–Lewy（CFL）条件，CFL数 $C \\in (0,1]$。\n\n该问题具有科学依据，是对一个基本偏微分方程数值方法的标准分析。该问题是适定的，提供了足够的信息来推导所求的量。术语精确且客观。因此，该问题被认为是有效的。\n\n求解过程分为三步：推导残差 $R_i$，确定局部时间步长 $\\Delta t_i$，以及估计收缩因子 $\\rho$。\n\n第一步：推导残差 $R_i(u)$\n将有限体积法应用于一维守恒律 $\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0$ 在长度为 $\\Delta x_i = x_{i+1/2} - x_{i-1/2}$ 的控制体（单元）$\\Omega_i = [x_{i-1/2}, x_{i+1/2}]$ 上，可得：\n$$\n\\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx + f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t)) = 0\n$$\n定义单元平均值 $u_i(t) = \\frac{1}{\\Delta x_i} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx$，方程变为：\n$$\n\\Delta x_i \\frac{du_i}{dt} + F_{i+1/2} - F_{i-1/2} = 0\n$$\n其中 $F_{i \\pm 1/2}$ 是单元界面上的数值通量。线性平流方程的物理通量为 $f(u) = au$。半离散形式为：\n$$\n\\frac{du_i}{dt} = -\\frac{1}{\\Delta x_i} (F_{i+1/2} - F_{i-1/2})\n$$\n问题给出的显式欧拉时间推进格式为 $u_i^{n+1} = u_i^n - \\frac{\\Delta t_i}{\\Delta x_i} R_i(u^n)$。将时间导数近似为 $\\frac{du_i}{dt} \\approx \\frac{u_i^{n+1}-u_i^n}{\\Delta t_i}$（对于单个单元的更新），我们可以将半离散形式与更新公式联系起来：\n$$\nu_i^{n+1} - u_i^n \\approx - \\frac{\\Delta t_i}{\\Delta x_i} (F_{i+1/2} - F_{i-1/2})\n$$\n将其与给定的更新公式进行比较，我们确定残差 $R_i(u)$ 为数值通量之差：\n$$\nR_i(u) = F_{i+1/2} - F_{i-1/2}\n$$\n问题指定了针对 $a>0$ 的一阶迎风通量。这意味着界面上的通量由界面上游（左侧）单元的状态决定。\n对于单元 $i$ 和 $i+1$ 之间的界面 $x_{i+1/2}$，上游单元是单元 $i$。因此，数值通量为 $F_{i+1/2} = f(u_i) = a u_i$。\n对于单元 $i-1$ 和 $i$ 之间的界面 $x_{i-1/2}$，上游单元是单元 $i-1$。因此，数值通量为 $F_{i-1/2} = f(u_{i-1}) = a u_{i-1}$。\n对于内部单元 $i$ 的残差为：\n$$\nR_i(u) = a u_i - a u_{i-1} = a(u_i - u_{i-1})\n$$\n该系统由三个单元组成，$i=1, 2, 3$。对于第一个单元 $i=1$，左边界是流入狄利克雷（Dirichlet）边界。设其值为 $u_L$。该值决定了界面 $x_{1/2}$ 处通量计算的状态，实际上相当于 $u_0$。因此，$F_{1/2} = a u_L$。三个单元的残差分别为：\n$R_1(u) = F_{3/2} - F_{1/2} = a u_1 - a u_L = a(u_1 - u_L)$\n$R_2(u) = F_{5/2} - F_{3/2} = a u_2 - a u_1 = a(u_2 - u_1)$\n$R_3(u) = F_{7/2} - F_{5/2} = a u_3 - a u_2 = a(u_3 - u_2)$\n\n第二步：确定局部时间步长 $\\Delta t_i$\n将推导出的残差代入给定的更新公式：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t_i}{\\Delta x_i} a (u_i^n - u_{i-1}^n)\n$$\n对 $u_i^{n+1}$ 的项进行重排：\n$$\nu_i^{n+1} = \\left(1 - \\frac{a \\Delta t_i}{\\Delta x_i}\\right) u_i^n + \\frac{a \\Delta t_i}{\\Delta x_i} u_{i-1}^n\n$$\n这是一阶显式迎风格式的更新方程。为使此格式稳定（例如，满足正定性条件，确保不产生新的极值），右侧状态的系数必须为非负。这要求：\n$$\n1 - \\frac{a \\Delta t_i}{\\Delta x_i} \\ge 0 \\implies \\frac{a \\Delta t_i}{\\Delta x_i} \\le 1\n$$\n这就是Courant–Friedrichs–Lewy（CFL）稳定性条件。量 $\\frac{a \\Delta t_i}{\\Delta x_i}$ 是局部Courant数。问题指出，选择一个CFL数 $C \\in (0,1]$ 来设置时间步长。这意味着我们将每个单元的局部Courant数设置为该值 $C$：\n$$\n\\frac{a \\Delta t_i}{\\Delta x_i} = C\n$$\n求解局部时间步长 $\\Delta t_i$ 可得：\n$$\n\\Delta t_i = \\frac{C \\Delta x_i}{a}\n$$\n将其应用于三个单元中的每一个，我们得到：\n$\\Delta t_1 = \\frac{C \\Delta x_1}{a}$\n$\\Delta t_2 = \\frac{C \\Delta x_2}{a}$\n$\\Delta t_3 = \\frac{C \\Delta x_3}{a}$\n\n第三步：估计收缩因子 $\\rho$\n伪时间步进是求解稳态解的一种迭代方法，稳态解由 $\\frac{\\partial u}{\\partial t} = 0$ 定义。这意味着半离散残差必须为零：$R_i(u) = 0$。\n稳态线性系统为：\n$a(u_1 - u_L) = 0$\n$a(u_2 - u_1) = 0$\n$a(u_3 - u_2) = 0$\n解为 $u_1 = u_2 = u_3 = u_L$。\n求解该系统的迭代格式由更新公式给出，其中 $\\frac{a \\Delta t_i}{\\Delta x_i} = C$：\n$u_1^{n+1} = (1-C) u_1^n + C u_L$\n$u_2^{n+1} = (1-C) u_2^n + C u_1^n$\n$u_3^{n+1} = (1-C) u_3^n + C u_2^n$\n该系统可以写成矩阵形式 $\\mathbf{u}^{n+1} = G \\mathbf{u}^n + \\mathbf{c}$，其中 $\\mathbf{u}^n = [u_1^n, u_2^n, u_3^n]^T$：\n$$\n\\begin{pmatrix} u_1^{n+1} \\\\ u_2^{n+1} \\\\ u_3^{n+1} \\end{pmatrix} =\n\\begin{pmatrix} 1-C  0  0 \\\\ C  1-C  0 \\\\ 0  C  1-C \\end{pmatrix}\n\\begin{pmatrix} u_1^n \\\\ u_2^n \\\\ u_3^n \\end{pmatrix} +\n\\begin{pmatrix} C u_L \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n矩阵 $G$ 是迭代矩阵。迭代的收敛速度由 $G$ 的谱半径决定，即收缩因子 $\\rho$。\n$$\nG = \\begin{pmatrix} 1-C  0  0 \\\\ C  1-C  0 \\\\ 0  C  1-C \\end{pmatrix}\n$$\n由于 $G$ 是一个下三角矩阵，其特征值即为其对角线元素。\n$$\n\\lambda_1 = \\lambda_2 = \\lambda_3 = 1-C\n$$\n谱半径 $\\rho(G)$ 是特征值绝对值的最大值：\n$$\n\\rho = \\rho(G) = \\max_i |\\lambda_i| = |1-C|\n$$\n问题指定 $C \\in (0, 1]$。对于此范围的 $C$，$1-C$ 的值在范围 $[0, 1)$ 内。因此，$|1-C| = 1-C$。\n收缩因子为：\n$$\n\\rho = 1-C\n$$\n此格式是针对稳态系统的加权雅可比（weighted-Jacobi）迭代，松弛因子为 $\\omega = C$。对于任何 $C \\in (0,1)$，迭代都会收敛，并且当 $C \\to 1$ 时收敛最快，此时 $\\rho \\to 0$。\n\n最终答案整合\n所求的量为 $\\Delta t_1$、$\\Delta t_2$、$\\Delta t_3$ 和 $\\rho$。\n$\\Delta t_1 = \\frac{C \\Delta x_1}{a}$\n$\\Delta t_2 = \\frac{C \\Delta x_2}{a}$\n$\\Delta t_3 = \\frac{C \\Delta x_3}{a}$\n$\\rho = 1-C$\n根据要求，将这些量组合成一个单行矩阵。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{C \\Delta x_1}{a}  \\frac{C \\Delta x_2}{a}  \\frac{C \\Delta x_3}{a}  1 - C \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "将局部时间步长理论应用于实践，一个核心挑战是如何在不同时间步长并存的单元交界面上保证通量的守恒性。本练习  要求您通过编程实现一种保守的多速率积分方案，这是一种特殊的局部时间步长方法。您将构建一个保证通量在子步长时间间隔内协调一致的算法，并验证该方案是否同时满足质量守恒和总变差不增（TVD）的稳定性要求，从而获得处理非均匀时间推进的实践经验。",
            "id": "3341536",
            "problem": "考虑一个长度为 $L$ 的周期性区域上的一维标量双曲守恒律 $u_t + f(u)_x = 0$，该方程通过有限体积法在 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀网格单元上进行离散。设通量为线性平流通量 $f(u) = a u$，其中平流速度 $a > 0$ 为正常数。网格平均值 $u_i(t)$ 的半离散有限体积更新定义为\n$$\n\\frac{d u_i}{d t} = -\\frac{1}{\\Delta x}\\left(F_{i+\\frac{1}{2}}(t) - F_{i-\\frac{1}{2}}(t)\\right),\n$$\n其中数值通量为 $a>0$ 时的单调迎风通量，由下式给出\n$$\nF_{i+\\frac{1}{2}}(t) = a\\, u_i(t).\n$$\n已知对于单调通量，一阶强稳定性保持（SSP）Runge–Kutta 格式（即前向欧拉法）在满足 Courant–Friedrichs–Lewy (CFL) 条件 $a\\,\\Delta t / \\Delta x \\le 1$ 的情况下是总变差递减（TVD）的。在局部时间步进中，为每个网格单元 $i$ 指定一个整数 $m_i \\in \\mathbb{N}$，表示每个宏观步长 $\\Delta t$ 内的子步数，其局部子步长为\n$$\n\\Delta t_i = \\frac{\\Delta t}{m_i}.\n$$\n为了在存在不同局部子步长的情况下确保守恒性并保持 TVD 特性，我们通过根据所有网格单元子步边界的有序并集来划分宏观步长时间区间 $[t^n, t^n+\\Delta t]$，从而在每个界面 $(i+\\frac{1}{2})$ 上构造一个守恒通量插值\n$$\n\\mathcal{T} = \\bigcup_{j=1}^N \\left\\{ t^n + k \\frac{\\Delta t}{m_j} \\,:\\, k=1,2,\\dots,m_j \\right\\},\n$$\n将其升序排序并在开头补充 $t^n$。将连续的时间点表示为 $t^n = \\tau_0  \\tau_1  \\cdots  \\tau_K = t^n+\\Delta t$，并定义子区间长度 $\\delta t_k = \\tau_k - \\tau_{k-1}$，其中 $k=1,\\dots,K$。在每个子区间 $[\\tau_{k-1}, \\tau_k)$ 上，冻结状态 $u(\\tau_{k-1})$ 并计算分段常数的界面通量 $F_{i+\\frac{1}{2}}(\\tau_{k-1}) = a\\, u_i(\\tau_{k-1})$。然后用大小为 $\\delta t_k$ 的前向欧拉步更新所有网格单元：\n$$\nu_i(\\tau_k) = u_i(\\tau_{k-1}) - \\frac{\\delta t_k}{\\Delta x}\\left(F_{i+\\frac{1}{2}}(\\tau_{k-1}) - F_{i-\\frac{1}{2}}(\\tau_{k-1})\\right).\n$$\n这在 $[t^n, t^n+\\Delta t]$ 上产生了一个守恒的时间积分，因为在每个界面和子区间上，相同的通量贡献 $F_{i+\\frac{1}{2}}\\delta t_k$ 从左侧单元减去并加到右侧单元。并且只要对所有的 $k$ 都满足 $a\\,\\delta t_k/\\Delta x \\le 1$，该方法就是 TVD 的。为确保这一点，取宏观步长为\n$$\n\\Delta t = \\frac{\\Delta x}{a},\n$$\n这保证了 $a\\,\\delta t_k/\\Delta x \\le 1$，因为 $\\delta t_k \\le \\Delta t$。\n\n任务：通过所述的守恒通量插值格式，实现上述带有网格单元子步数 $m_i$ 的多速率强稳定性保持 Runge–Kutta (SSPRK(1)) 格式。使用周期性区域 $[0,1]$，其中 $L=1$，平流速度 $a=1$，网格单元数 $N$ 在每个测试用例中指定。初始条件按每个测试指定。将解推进指定的宏观步数，每步时长为 $\\Delta t = \\Delta x/a$。时间积分后，计算：\n\n1. 离散质量\n$$\nM = \\sum_{i=0}^{N-1} u_i\\,\\Delta x,\n$$\n并验证在测试指定的积分时间内，质量守恒在 $10^{-12}$ 的容差范围内（返回一个布尔值表示质量是否守恒）。\n2. 离散总变差\n$$\n\\mathrm{TV}(u) = \\sum_{i=0}^{N-1} \\left| u_{i+1} - u_i \\right|,\n$$\n使用周期性索引 $u_N \\equiv u_0$，并验证其在指定的积分时间内不增加（返回一个布尔值表示是否 TVD，即 $\\mathrm{TV}(u^{\\text{final}}) \\le \\mathrm{TV}(u^{\\text{initial}})$）。\n3. 对于均匀子步测试，计算由时间并集多速率方法（使用均匀 $m_i$）产生的解与使用宏观步长 $\\Delta t$ 的单步前向欧拉法产生的解之间的最大绝对差；将此作为浮点数返回。\n\n测试套件：\n- 测试 1（正常路径）：$N=200$，初始条件 $u(x) = 0.5 + 0.5\\sin(2\\pi x)$ 在网格单元中心采样，对于中心 $x \\in [0.4, 0.6]$ 的网格单元，子步数 $m_i = 3$，其他地方 $m_i = 1$，推进 3 个宏观步。返回两个布尔值：质量守恒和 TVD。\n- 测试 2（均匀情况）：$N=200$，初始条件 $u(x) = \\sin(2\\pi x)$，所有 $i$ 的子步数均为 $m_i = 1$，推进 1 个宏观步。返回一个浮点数：时间并集多速率方法与使用 $\\Delta t$ 的单步前向欧拉法之间的最大绝对差。\n- 测试 3（边界情况）：$N=200$，初始条件 $u(x) = \\mathbf{1}_{[0.25,0.5]}(x)$（区间 $[0.25,0.5]$ 的指示函数，在网格单元中心采样），子步数 $m_i$ 交替为 1 和 4（即，如果 $i$ 是偶数，则 $m_i=1$，如果 $i$ 是奇数，则 $m_i=4$），推进 5 个宏观步。返回两个布尔值：质量守恒和 TVD。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。输出必须按顺序汇总测试 1、测试 2 和测试 3 的结果：$[\\text{mass\\_T1},\\text{TVD\\_T1},\\text{maxdiff\\_T2},\\text{mass\\_T3},\\text{TVD\\_T3}]$。由于该问题是无量纲的，因此无需报告物理单位。",
            "solution": "我们从标量双曲守恒律 $u_t + f(u)_x = 0$ 开始，其中 $f(u) = a u$ 且 $a0$。在均匀网格上，使用网格平均值 $u_i(t)$ 的有限体积半离散形式为\n$$\n\\frac{d u_i}{d t} = -\\frac{1}{\\Delta x}\\left(F_{i+\\frac{1}{2}}(t) - F_{i-\\frac{1}{2}}(t)\\right).\n$$\n对于单调数值通量，前向欧拉格式在 Courant–Friedrichs–Lewy (CFL) 限制条件 $a\\,\\Delta t / \\Delta x \\le 1$ 下是总变差递减（TVD）的。具体来说，对于 $a0$ 的线性平流，迎风通量为 $F_{i+\\frac{1}{2}} = a u_i$。在一个均匀时间步长 $\\delta t$ 上的前向欧拉更新可写作\n$$\nu_i^{n+1} = u_i^n - \\lambda\\,(u_i^n - u_{i-1}^n),\\quad\\text{with}\\quad \\lambda = \\frac{a\\,\\delta t}{\\Delta x}.\n$$\n这是一个凸组合，因为 $u_i^{n+1} = (1-\\lambda) u_i^n + \\lambda u_{i-1}^n$ 且 $\\lambda \\in [0,1]$，因此它不会产生新的极值，并且是 TVD 的。\n\n局部时间步进通过整数 $m_i$ 和局部子步长 $\\Delta t_i = \\Delta t/m_i$ 引入了每个网格单元时间增量的异质性。在单个阶段内直接应用不同的 $\\Delta t_i$ 会在界面处破坏守恒性，因为两边的通量贡献会被不同地缩放。为了保持守恒性和 TVD，我们构造一个守恒的时间通量插值，方法如下。\n\n定义每个网格单元 $i$ 的子步边界集合：\n$$\n\\mathcal{T}_i = \\left\\{ t^n + k \\frac{\\Delta t}{m_i} : k=1,2,\\dots,m_i \\right\\}.\n$$\n令 $\\mathcal{T} = \\bigcup_{i=0}^{N-1} \\mathcal{T}_i$ 并将 $\\mathcal{T}$ 升序排序，在开头补充 $t^n$；记 $\\tau_0 = t^n$，则有 $\\tau_1  \\cdots  \\tau_K = t^n+\\Delta t$。在每个长度为 $\\delta t_k = \\tau_k - \\tau_{k-1}$ 的子区间 $[\\tau_{k-1},\\tau_k)$ 上，我们冻结状态 $u(\\tau_{k-1})$ 并计算界面通量 $F_{i+\\frac{1}{2}}(\\tau_{k-1}) = a\\,u_i(\\tau_{k-1})$。然后应用前向欧拉更新：\n$$\nu_i(\\tau_k) = u_i(\\tau_{k-1}) - \\frac{\\delta t_k}{\\Delta x}\\left(F_{i+\\frac{1}{2}}(\\tau_{k-1}) - F_{i-\\frac{1}{2}}(\\tau_{k-1})\\right).\n$$\n守恒性得以保证，因为在 $[\\tau_{k-1},\\tau_k)$ 上，每个界面通量 $F_{i+\\frac{1}{2}}(\\tau_{k-1})$ 对左侧单元的贡献为 $- \\frac{\\delta t_k}{\\Delta x} F_{i+\\frac{1}{2}}$，对右側单元的贡献为 $+ \\frac{\\delta t_k}{\\Delta x} F_{i+\\frac{1}{2}}$，因此网格平均值与 $\\Delta x$ 乘积的总和保持不变：\n$$\n\\sum_{i} u_i(\\tau_k)\\Delta x = \\sum_{i} u_i(\\tau_{k-1})\\Delta x.\n$$\nTVD 特性得以保持，因为每个子区间的更新都是一个前向欧拉步，其中 $\\lambda_k = a\\,\\delta t_k/\\Delta x$。如果我们取宏观步长 $\\Delta t = \\Delta x / a$，则 $\\delta t_k \\le \\Delta t$ 意味着 $\\lambda_k \\le 1$。因此，更新是每个子区间内邻居状态的凸组合，而 TVD 步的复合仍然是 TVD 的：\n$$\n\\mathrm{TV}\\big(u(\\tau_k)\\big) \\le \\mathrm{TV}\\big(u(\\tau_{k-1})\\big)\\quad\\Rightarrow\\quad \\mathrm{TV}\\big(u(t^n+\\Delta t)\\big) \\le \\mathrm{TV}\\big(u(t^n)\\big).\n$$\n这种构造是一个一阶多速率强稳定性保持 Runge–Kutta 格式（SSPRK(1)），因为它可以被解释为一系列具有可变子区间长度 $\\delta t_k$ 的前向欧拉步，这些子区间长度源于局部子步边界的并集。由于 CFL 限制，每个子区间都满足 SSP 条件。界面通量插值在每个 $[\\tau_{k-1},\\tau_k)$ 上是时间分段常数，确保了相同的通量积分被应用于两个相邻的网格单元，从而保证了守恒性。\n\n算法上：\n- 在网格单元中心 $x_i = (i+0.5)\\Delta x$ 处根据给定的初始条件初始化 $u_i$。\n- 对于每个宏观步，从所有的 $m_i$ 构建集合 $\\mathcal{T}$，对其元素进行排序，并形成子区间 $\\delta t_k$。\n- 对于每个 $\\delta t_k$，使用在子区间开始时冻结的状态计算通量 $F_{i+\\frac{1}{2}} = a u_i$，并通过前向欧拉公式更新所有的 $u_i$。\n- 在指定的宏观步数之后，计算离散质量 $M$ 和总变差 $\\mathrm{TV}(u)$，与初始值进行比较，并生成所要求的输出。\n\n测试 1 在光滑初始条件下使用非均匀的 $m_i$ 模式，以验证多个宏观步上的守恒性和 TVD。测试 2 使用均匀的 $m_i=1$；在这种情况下，$\\mathcal{T}$ 只包含一个边界 $\\tau_1 = t^n+\\Delta t$，因此该方法简化为单步前向欧拉宏观步，与标准前向欧拉宏观步的最大绝对差值预期在浮点运算精度内为零。测试 3 采用具有交替 $m_i$ 的不连续初始条件，以评估在极端多速率划分下守恒性和 TVD 的鲁棒性。\n\n所有量都是无量纲的；没有需要报告的物理单位。测试 1 和 3 的输出是两个布尔值，测试 2 的输出是一个浮点数，按指定的单行格式汇总。",
            "answer": "```python\nimport numpy as np\n\ndef build_union_subintervals(m_vec, dt):\n    # Build the union of substep boundary times from all cells.\n    times = set()\n    for m in m_vec:\n        for k in range(1, m + 1):\n            times.add(k * dt / m)\n    # Include start time 0 and sort\n    sorted_times = sorted(times)\n    # Build subintervals between consecutive times, starting from 0\n    prev = 0.0\n    deltas = []\n    for t in sorted_times:\n        deltas.append(t - prev)\n        prev = t\n    # If the last time is less than dt due to floating tolerance, add the remainder\n    if prev  dt - 1e-16:\n        deltas.append(dt - prev)\n    return deltas\n\ndef forward_euler_union(u, m_vec, dx, a, dt, n_macrosteps):\n    # Advance solution using union-of-times conservative flux interpolation\n    u = u.copy()\n    for _ in range(n_macrosteps):\n        deltas = build_union_subintervals(m_vec, dt)\n        for dtk in deltas:\n            lam = a * dtk / dx\n            # Upwind flux for a>0: F_{i+1/2} = a*u_i; update becomes u_i -= lam*(u_i - u_{i-1})\n            u = u - lam * (u - np.roll(u, 1))\n    return u\n\ndef forward_euler_single(u, dx, a, dt):\n    lam = a * dt / dx\n    return u - lam * (u - np.roll(u, 1))\n\ndef mass(u, dx):\n    return dx * np.sum(u)\n\ndef total_variation(u):\n    return np.sum(np.abs(np.roll(u, -1) - u))\n\ndef initial_condition_sine(N):\n    x = (np.arange(N) + 0.5) / N\n    return 0.5 + 0.5 * np.sin(2 * np.pi * x)\n\ndef initial_condition_sine_zero_mean(N):\n    x = (np.arange(N) + 0.5) / N\n    return np.sin(2 * np.pi * x)\n\ndef initial_condition_indicator(N, a=0.25, b=0.5):\n    x = (np.arange(N) + 0.5) / N\n    return ((x >= a)  (x = b)).astype(float)\n\ndef solve():\n    # Common parameters\n    L = 1.0\n    a = 1.0\n\n    results = []\n\n    # Test 1: mixed m_i, smooth sine, 3 macro-steps\n    N1 = 200\n    dx1 = L / N1\n    dt1 = dx1 / a  # CFL 1\n    u0_1 = initial_condition_sine(N1)\n    # m_i = 3 in [0.4, 0.6], else 1\n    x1 = (np.arange(N1) + 0.5) / N1\n    m_vec1 = np.where((x1 >= 0.4)  (x1 = 0.6), 3, 1).astype(int)\n\n    M0_1 = mass(u0_1, dx1)\n    TV0_1 = total_variation(u0_1)\n    u1 = forward_euler_union(u0_1, m_vec1, dx1, a, dt1, n_macrosteps=3)\n    M1 = mass(u1, dx1)\n    TV1 = total_variation(u1)\n    mass_ok_1 = bool(abs(M1 - M0_1) = 1e-12)\n    tvd_ok_1 = bool(TV1 = TV0_1 + 1e-12)\n    results.append(mass_ok_1)\n    results.append(tvd_ok_1)\n\n    # Test 2: uniform m_i=1, compare to single FE macro-step\n    N2 = 200\n    dx2 = L / N2\n    dt2 = dx2 / a\n    u0_2 = initial_condition_sine_zero_mean(N2)\n    m_vec2 = np.ones(N2, dtype=int)\n    u2_union = forward_euler_union(u0_2, m_vec2, dx2, a, dt2, n_macrosteps=1)\n    u2_single = forward_euler_single(u0_2, dx2, a, dt2)\n    maxdiff_2 = float(np.max(np.abs(u2_union - u2_single)))\n    results.append(maxdiff_2)\n\n    # Test 3: alternating m_i = 1 and 4, indicator initial condition, 5 macro-steps\n    N3 = 200\n    dx3 = L / N3\n    dt3 = dx3 / a\n    u0_3 = initial_condition_indicator(N3, a=0.25, b=0.5)\n    m_vec3 = np.where((np.arange(N3) % 2) == 0, 1, 4).astype(int)\n\n    M0_3 = mass(u0_3, dx3)\n    TV0_3 = total_variation(u0_3)\n    u3 = forward_euler_union(u0_3, m_vec3, dx3, a, dt3, n_macrosteps=5)\n    M3 = mass(u3, dx3)\n    TV3 = total_variation(u3)\n    mass_ok_3 = bool(abs(M3 - M0_3) = 1e-12)\n    tvd_ok_3 = bool(TV3 = TV0_3 + 1e-12)\n    results.append(mass_ok_3)\n    results.append(tvd_ok_3)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在高性能计算流体动力学应用中，仅仅最快地降低残差并非唯一目标；计算效率，特别是并行效率，同样至关重要。本练习  引入了一个更贴近实际的场景：您需要在加速收敛和维持并行计算负载均衡之间做出权衡。通过实施一个“面相干”的局部时间步长策略，并优化其关键参数 $\\gamma$，您将学习如何量化并最大化一个综合了收敛速度和并行效率的目标函数，这反映了现代CFD求解器设计中复杂的决策过程。",
            "id": "3341467",
            "problem": "考虑线性平流方程的一维有限体积离散，其中守恒标量 $u$ 在周期性域上满足守恒律 $\\,\\partial u/\\partial t + \\partial (a(x) u)/\\partial x = 0\\,$。设网格由 $N$ 个单元组成，单元宽度 $\\Delta x_i  0$，特征速度 $a_i  0$，其中 $i \\in \\{0,1,\\dots,N-1\\}$。将面速度 $a_{i+1/2}$ 定义为相邻 $a_i$ 值的相容面插值，并采用标准的迎风数值通量和周期性边界条件。使用显式局部伪时间步进，其中每个单元 $i$ 以其自身的局部时间步长 $\\Delta t_i$ 前进，并遵循一个面相干性约束：对于每个相邻面 $(i,i+1)$，相邻的时间步长必须满足 $\\max\\{\\Delta t_i,\\Delta t_{i+1}\\} \\le \\gamma \\min\\{\\Delta t_i,\\Delta t_{i+1}\\}$，其中给定因子 $\\gamma \\ge 1$。\n\n从每个单元的 Courant–Friedrichs–Lewy (CFL) 限制的时间步长 $\\Delta t^{\\mathrm{CFL}}_i$ 开始，其定义为 $\\Delta t^{\\mathrm{CFL}}_i = \\mathrm{CFL} \\cdot \\Delta x_i / s_i$，其中 $s_i$ 是两个相邻面速度的最大值 $s_i = \\max\\{a_{i-1/2}, a_{i+1/2}\\}$，而 $\\mathrm{CFL} \\in (0,1)$ 是一个选定的 Courant 数。实现 $\\Delta t_i$ 到由给定 $\\gamma$ 导出的可行集上的图相容投影：迭代地修改跨面的相邻 $\\Delta t$ 值中较大的一个，直到每一对相邻值都满足比率界限。目标是选择合适的 $\\gamma$ 以在多速率子循环方案中加速收敛，同时保持并行效率。\n\n将有限体积迎风格式在每个单元 $i$ 中的单步显式更新定义为\n$$\nu_i^{n+1} = u_i^n - \\left(\\frac{\\Delta t_i}{\\Delta x_i}\\right)\\left(F_{i+1/2}(u^n) - F_{i-1/2}(u^n)\\right),\n$$\n其中 $F_{i+1/2}$ 是使用正特征速度和周期性边界条件的迎风数值通量。此单步更新引入一个作用于单元状态向量 $u$ 的线性迭代算子 $M(\\Delta t)$，其谱半径 $\\rho(M(\\Delta t))$ 量化了线性状态下每次迭代的渐近收缩。假设所有 $a_i$ 均为正，因此迎风方向为向右。对于给定的 $\\gamma$，在施加面相干性后，将持续时间等于 $\\max_i \\Delta t_i$ 的一个宏观步长的并行多速率效率定义为\n$$\nE(\\gamma) = \\frac{N}{\\sum_{i=0}^{N-1} \\lceil \\max_j \\Delta t_j / \\Delta t_i \\rceil},\n$$\n该公式估算了子循环下理想并行利用率的分数。为平衡收敛速率和并行效率，定义标量目标函数\n$$\nJ(\\gamma) = E(\\gamma)\\cdot \\max\\{0,\\,1 - \\rho(M(\\Delta t(\\gamma)))\\},\n$$\n使得谱半径 $\\rho(M(\\Delta t)) \\ge 1$ 的不稳定格式得出 $J(\\gamma) = 0$。\n\n您的程序必须：\n- 在所述假设下，对给定的网格和 $\\gamma$，使用面速度插值 $a_{i+1/2} = \\tfrac{1}{2}(a_i + a_{i+1})$ 和周期性索引来构建 $M(\\Delta t)$。\n- 计算 $\\rho(M(\\Delta t))$，即 $M(\\Delta t)$ 的最大绝对特征值。\n- 对提供的一个候选集中的每个候选 $\\gamma$ 计算 $E(\\gamma)$ 和 $J(\\gamma)$。\n- 选择使 $J(\\gamma)$ 最大化的最优 $\\gamma$；如果在数值容差范围内出现平局，则选择最小的 $\\gamma$。\n- 对每个测试用例，输出三元组 $[\\gamma^\\ast, E(\\gamma^\\ast), \\rho(M(\\Delta t(\\gamma^\\ast)))]$，每个浮点数四舍五入到六位小数。\n\n使用以下包含三个网格及其参数和候选 $\\gamma$ 集的测试套件。对于所有三个用例，均使用 $\\mathrm{CFL} = 0.9$。\n\n测试用例 1 (非均匀但适中)：\n- $N = 12$,\n- $\\Delta x = [\\,1.0,\\,0.8,\\,1.2,\\,0.7,\\,1.3,\\,0.9,\\,0.6,\\,1.1,\\,0.95,\\,1.4,\\,0.5,\\,1.0\\,]$,\n- $a = [\\,1.0,\\,2.5,\\,1.2,\\,2.8,\\,0.9,\\,2.2,\\,1.1,\\,2.6,\\,0.8,\\,3.0,\\,1.3,\\,2.4\\,]$,\n- 候选 $\\gamma$ 值 $[\\,1.1,\\,1.25,\\,1.5,\\,2.0,\\,3.0\\,]$.\n\n测试用例 2 (均匀网格和速度)：\n- $N = 10$,\n- $\\Delta x = [\\,1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0\\,]$,\n- $a = [\\,1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0\\,]$,\n- 候选 $\\gamma$ 值 $[\\,1.05,\\,1.2,\\,1.5,\\,2.0\\,]$.\n\n测试用例 3 (强非均匀)：\n- $N = 10$,\n- $\\Delta x = [\\,0.3,\\,1.5,\\,0.4,\\,2.0,\\,0.35,\\,1.8,\\,0.5,\\,2.2,\\,0.45,\\,1.6\\,]$,\n- $a = [\\,0.4,\\,2.8,\\,0.5,\\,3.2,\\,0.6,\\,2.5,\\,0.7,\\,3.0,\\,0.8,\\,2.7\\,]$,\n- 候选 $\\gamma$ 值 $[\\,1.2,\\,1.5,\\,1.8,\\,2.5,\\,3.5\\,]$.\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是每个测试用例（按顺序）的列表 $[\\,\\gamma^\\ast,\\,E(\\gamma^\\ast),\\,\\rho(M(\\Delta t(\\gamma^\\ast)))\\,]$。例如，输出形式为 $[[\\gamma_1^\\ast,E_1,\\rho_1],[\\gamma_2^\\ast,E_2,\\rho_2],[\\gamma_3^\\ast,E_3,\\rho_3]]$。每个浮点数必须四舍五入到六位小数。输出中不需要物理单位，因为所有量都是无量纲的标量。",
            "solution": "该问题是有效的。它是在偏微分方程数值方法领域中一个明确定义的计算任务，特别涉及计算流体动力学中局部时间步进格式的优化。该问题具有科学依据，内容自洽，并且所有术语和目标都已正式指定。\n\n对于每个测试用例，解决方案需要一个多步骤过程。对于面相干性因子 $\\gamma$ 的每个候选值，我们必须计算一个目标函数 $J(\\gamma)$，然后选择使该函数最大化的 $\\gamma$。计算 $J(\\gamma)$ 的步骤如下：\n\n1.  **计算面量**：给定单元中心的特征速度 $a_i$（其中 $i \\in \\{0, \\dots, N-1\\}$），我们首先计算单元面上的速度。问题指定使用算术平均值：$a_{i+1/2} = \\frac{1}{2}(a_i + a_{i+1})$。所有索引都是周期性的，因此 $a_{N-1/2} = \\frac{1}{2}(a_{N-1} + a_0)$。\n\n2.  **计算初始时间步**：每个单元的初始时间步长 $\\Delta t^{\\mathrm{CFL}}_i$ 由局部的 Courant–Friedrichs–Lewy (CFL) 条件确定。其定义为 $\\Delta t^{\\mathrm{CFL}}_i = \\mathrm{CFL} \\cdot \\Delta x_i / s_i$，其中 Courant 数 $\\mathrm{CFL}=0.9$，$\\Delta x_i$ 是单元 $i$ 的宽度，$s_i = \\max\\{a_{i-1/2}, a_{i+1/2}\\}$ 是界定单元 $i$ 的两个面上的速度最大值。\n\n3.  **施加面相干性约束**：初始时间步长 $\\Delta t^{\\mathrm{CFL}}_i$ 必须被调整以满足面相干性约束：对于任意两个相邻单元 $i$ 和 $i+1$，它们的时间步长必须满足 $\\max\\{\\Delta t_i, \\Delta t_{i+1}\\} \\le \\gamma \\min\\{\\Delta t_i, \\Delta t_{i+1}\\}$。这等同于确保任意两个相邻单元的时间步长比率不大于 $\\gamma$。问题指定了一个迭代投影过程：对于任何违反约束的相邻对 $(\\Delta t_i, \\Delta t_{i+1})$，将两者中较大的一个减小到恰好是较小者的 $\\gamma$ 倍。此过程在所有单元面上重复进行，直到没有进一步的变化发生，从而确保所有时间步长都满足该约束。这个松弛过程是收敛的，因为时间步长只会被减小，并且有界于零。将最终得到的时间步长表示为 $\\Delta t_i(\\gamma)$。\n\n4.  **构建迭代算子 $M(\\Delta t)$**：单步显式有限体积更新由下式给出：\n    $$\n    u_i^{n+1} = u_i^n - \\left(\\frac{\\Delta t_i}{\\Delta x_i}\\right)\\left(F_{i+1/2}(u^n) - F_{i-1/2}(u^n)\\right)\n    $$\n    由于所有特征速度 $a_i$ 均为正，面 $i+1/2$（位于单元 $i$ 和 $i+1$ 之间）的迎风通量取决于上游状态，即 $u_i^n$。因此，$F_{i+1/2}(u^n) = a_{i+1/2} u_i^n$。类似地，$F_{i-1/2}(u^n) = a_{i-1/2} u_{i-1}^n$。将这些代入更新方程得到：\n    $$\n    u_i^{n+1} = u_i^n - \\frac{\\Delta t_i(\\gamma)}{\\Delta x_i} \\left(a_{i+1/2} u_i^n - a_{i-1/2} u_{i-1}^n\\right)\n    $$\n    重新整理各项以识别来自 $u_i^n$ 和 $u_{i-1}^n$ 的贡献，得到：\n    $$\n    u_i^{n+1} = \\left(1 - \\frac{\\Delta t_i(\\gamma)}{\\Delta x_i} a_{i+1/2}\\right) u_i^n + \\left(\\frac{\\Delta t_i(\\gamma)}{\\Delta x_i} a_{i-1/2}\\right) u_{i-1}^n\n    $$\n    该方程定义了矩阵方程 $u^{n+1} = M u^n$ 中线性迭代算子 $M(\\Delta t(\\gamma))$ 的第 $i$ 行。对于每一行 $i$，矩阵 $M$ 有两个非零项：\n    -   在主对角线上：$M_{ii} = 1 - \\frac{\\Delta t_i(\\gamma)}{\\Delta x_i} a_{i+1/2}$\n    -   在次对角线上（带周期性环绕）：$M_{i, (i-1)\\pmod N} = \\frac{\\Delta t_i(\\gamma)}{\\Delta x_i} a_{i-1/2}$\n\n5.  **计算谱半径 $\\rho(M)$**：线性迭代的渐近收敛率由 $M$ 的谱半径 $\\rho(M)$ 决定，即其特征值的最大绝对值。这需要通过数值计算得出。\n\n6.  **计算并行效率 $E(\\gamma)$**：在多速率子循环方案下的并行效率由下式给出：\n    $$\n    E(\\gamma) = \\frac{N}{\\sum_{i=0}^{N-1} \\lceil \\max_j \\Delta t_j(\\gamma) / \\Delta t_i(\\gamma) \\rceil}\n    $$\n    该度量考虑了由于单元在持续时间为 $\\max_j \\Delta t_j$ 的全局宏观步长内执行不同数量的子步所引起的工作负载不平衡。\n\n7.  **计算目标函数 $J(\\gamma)$**：最终的目标函数平衡了收敛率（与 $1-\\rho$ 相关）和并行效率（$E$）：\n    $$\n    J(\\gamma) = E(\\gamma) \\cdot \\max\\{0, 1 - \\rho(M(\\Delta t(\\gamma)))\\}\n    $$\n    如果 $\\rho(M) \\ge 1$，则格式不稳定，这正确地得出 $J(\\gamma) = 0$。\n\n8.  **优化**：对每个测试用例，为每个候选 $\\gamma$ 执行上述步骤。最优值 $\\gamma^\\ast$ 是使 $J(\\gamma)$ 最大化的那个值。如果在数值容差范围内出现平局，则选择平局候选者中最小的 $\\gamma$。每个测试用例的最终输出是三元组 $[\\gamma^\\ast, E(\\gamma^\\ast), \\rho(M(\\Delta t(\\gamma^\\ast)))]$。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_objective(N, dx, a, cfl, gamma):\n    \"\"\"\n    Calculates the objective function J for a given set of parameters and gamma.\n\n    This function implements steps 1-7 of the solution methodology:\n    1. Compute face speeds.\n    2. Calculate initial CFL-limited time steps.\n    3. Enforce face coherence via iterative projection.\n    4. Construct the iteration matrix M.\n    5. Compute its spectral radius rho.\n    6. Compute the parallel efficiency E.\n    7. Compute the final objective J.\n    \"\"\"\n    # Step 1: Compute face speeds\n    a_face = 0.5 * (a + np.roll(a, -1))\n\n    # Step 2: Calculate initial CFL-limited time steps\n    s = np.maximum(a_face, np.roll(a_face, 1))\n    # Avoid division by zero if s_i can be zero, though problem states a_i > 0\n    s[s == 0] = 1e-16\n    dt = cfl * dx / s\n\n    # Step 3: Perform face-coherent projection\n    dt_proj = dt.copy()\n    max_iter = 1000 # Safety break for the while loop\n    for _ in range(max_iter):\n        num_changes = 0\n        dt_old = dt_proj.copy()\n        for i in range(N):\n            j = (i + 1) % N\n            dt_i, dt_j = dt_proj[i], dt_proj[j]\n            \n            if dt_i > gamma * dt_j:\n                dt_proj[i] = gamma * dt_j\n                num_changes += 1\n            elif dt_j > gamma * dt_i:\n                dt_proj[j] = gamma * dt_i\n                num_changes += 1\n        \n        if np.allclose(dt_proj, dt_old):\n            break\n    \n    dt_gamma = dt_proj\n    \n    # Step 4: Construct the iteration matrix M\n    M = np.zeros((N, N))\n    diag_vals = 1.0 - (dt_gamma / dx) * a_face\n    np.fill_diagonal(M, diag_vals)\n    \n    subdiag_vals = (dt_gamma / dx) * np.roll(a_face, 1)\n    rows = np.arange(N)\n    cols = (rows - 1) % N\n    M[rows, cols] = subdiag_vals\n    \n    # Step 5: Compute spectral radius of M\n    eigenvalues = np.linalg.eigvals(M)\n    rho = np.max(np.abs(eigenvalues))\n    \n    # Step 6: Compute parallel multirate efficiency E\n    dt_max = np.max(dt_gamma)\n    ratios = dt_max / dt_gamma\n    sum_of_ceilings = np.sum(np.ceil(ratios))\n    E = N / sum_of_ceilings\n    \n    # Step 7: Compute objective function J\n    J = E * np.maximum(0.0, 1.0 - rho)\n    \n    return J, E, rho\n\ndef find_optimal_gamma(N, dx, a, cfl, candidate_gammas):\n    \"\"\"\n    Finds the optimal gamma from a candidate list for a single test case.\n    \"\"\"\n    results_per_gamma = []\n    \n    for gamma in candidate_gammas:\n        J, E, rho = calculate_objective(N, np.array(dx), np.array(a), cfl, gamma)\n        results_per_gamma.append({'gamma': gamma, 'J': J, 'E': E, 'rho': rho})\n        \n    if not results_per_gamma:\n        return None\n        \n    # Find the maximum J value achieved among all candidates\n    max_J = -1.0\n    for r in results_per_gamma:\n        if r['J'] > max_J:\n            max_J = r['J']\n            \n    # Find the first gamma (smallest) that achieves a J value close to the max,\n    # to handle ties according to the problem specification.\n    best_result = None\n    tolerance = 1e-9\n    for result in results_per_gamma:\n        if abs(result['J'] - max_J)  tolerance:\n            best_result = result\n            break\n\n    gamma_star = best_result['gamma']\n    E_star = best_result['E']\n    rho_star = best_result['rho']\n    \n    return [\n        round(float(gamma_star), 6),\n        round(E_star, 6),\n        round(rho_star, 6)\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the optimization, and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 12,\n            \"dx\": [1.0, 0.8, 1.2, 0.7, 1.3, 0.9, 0.6, 1.1, 0.95, 1.4, 0.5, 1.0],\n            \"a\": [1.0, 2.5, 1.2, 2.8, 0.9, 2.2, 1.1, 2.6, 0.8, 3.0, 1.3, 2.4],\n            \"gammas\": [1.1, 1.25, 1.5, 2.0, 3.0]\n        },\n        {\n            \"N\": 10,\n            \"dx\": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n            \"a\": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n            \"gammas\": [1.05, 1.2, 1.5, 2.0]\n        },\n        {\n            \"N\": 10,\n            \"dx\": [0.3, 1.5, 0.4, 2.0, 0.35, 1.8, 0.5, 2.2, 0.45, 1.6],\n            \"a\": [0.4, 2.8, 0.5, 3.2, 0.6, 2.5, 0.7, 3.0, 0.8, 2.7],\n            \"gammas\": [1.2, 1.5, 1.8, 2.5, 3.5]\n        }\n    ]\n    \n    cfl = 0.9\n    \n    final_results = []\n    for case in test_cases:\n        result = find_optimal_gamma(case[\"N\"], case[\"dx\"], case[\"a\"], cfl, case[\"gammas\"])\n        # Format the list as a string for inclusion in the final output string\n        final_results.append(str(result))\n        \n    # Print the final output in the exact required format\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"
        }
    ]
}