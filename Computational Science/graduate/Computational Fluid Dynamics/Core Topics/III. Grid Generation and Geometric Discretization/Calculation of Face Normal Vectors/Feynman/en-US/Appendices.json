{
    "hands_on_practices": [
        {
            "introduction": "We begin our practice with the fundamental building block of many CFD simulations: the two-dimensional rectangular cell. This exercise () bridges the gap between the discrete world of computational meshes and the continuous world of vector calculus by asking you to compute the net flux of a vector field directly from its definition. By evaluating the line integral $\\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell$ edge by edge, you will gain a concrete understanding of how outward normal vectors are used to enforce conservation principles at the single-cell level.",
            "id": "3297266",
            "problem": "Consider a two-dimensional rectangular control volume $\\Omega$ in a Cartesian mesh used in Computational Fluid Dynamics (CFD), with geometric center at $(x_{c}, y_{c})$ and side lengths $\\Delta x$ and $\\Delta y$. The rectangle is axis-aligned, so that its boundary $\\partial \\Omega$ consists of four straight edges located at $x = x_{c} \\pm \\Delta x/2$ and $y = y_{c} \\pm \\Delta y/2$. A linear, spatially varying velocity field is prescribed as $\\mathbf{u}(x,y) = \\begin{pmatrix} a x + b y + c \\\\ d x + e y + f \\end{pmatrix}$, where $a$, $b$, $c$, $d$, $e$, and $f$ are constants. Assume all quantities are nondimensional.\n\nTasks:\n- Identify the outward unit normal vectors for each edge of $\\partial \\Omega$.\n- Using the fundamental definition of the outward normal flux, evaluate the contour integral $\\displaystyle \\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell$ exactly, in closed form.\n\nExpress your final answer as a single, simplified analytic expression in terms of $a$, $b$, $c$, $d$, $e$, $f$, $\\Delta x$, and $\\Delta y$. Do not include units. No rounding is required.",
            "solution": "We begin from the fundamental definition of the flux of a vector field $\\mathbf{u}$ through a boundary $\\partial \\Omega$ with outward unit normal $\\hat{n}$, given by the line integral $\\displaystyle \\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell$. For an axis-aligned rectangle, the four edges have constant outward unit normals.\n\nGeometry and normals:\n- Right (east) edge: $x = x_{c} + \\Delta x/2$, $y \\in [y_{c} - \\Delta y/2, \\, y_{c} + \\Delta y/2]$, outward unit normal $\\hat{n}_{E} = (1, 0)^T$.\n- Left (west) edge: $x = x_{c} - \\Delta x/2$, $y \\in [y_{c} - \\Delta y/2, \\, y_{c} + \\Delta y/2]$, outward unit normal $\\hat{n}_{W} = (-1, 0)^T$.\n- Top (north) edge: $y = y_{c} + \\Delta y/2$, $x \\in [x_{c} - \\Delta x/2, \\, x_{c} + \\Delta x/2]$, outward unit normal $\\hat{n}_{N} = (0, 1)^T$.\n- Bottom (south) edge: $y = y_{c} - \\Delta y/2$, $x \\in [x_{c} - \\Delta x/2, \\, x_{c} + \\Delta x/2]$, outward unit normal $\\hat{n}_{S} = (0, -1)^T$.\n\nWe evaluate the flux as the sum of four edge integrals, using the definition $\\displaystyle \\int_{\\text{edge}} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell$ and parameterizing each straight edge by its coordinate variable.\n\nEast edge:\n- Parameterization: $x = x_{E} := x_{c} + \\Delta x/2$, $y \\in [y_{-}, y_{+}]$ with $y_{\\pm} := y_{c} \\pm \\Delta y/2$, and $d\\ell = dy$.\n- Integrand: $\\mathbf{u} \\cdot \\hat{n}_{E} = u_{x}(x,y) = a x + b y + c$ evaluated at $x = x_{E}$.\n- Integral:\n$$\n\\Phi_{E} = \\int_{y_{-}}^{y_{+}} \\left( a x_{E} + b y + c \\right) \\, dy = \\left( a x_{E} + c \\right) \\Delta y + b \\int_{y_{-}}^{y_{+}} y \\, dy.\n$$\nUsing $\\int_{y_{-}}^{y_{+}} y \\, dy = \\tfrac{1}{2} \\left( y_{+}^{2} - y_{-}^{2} \\right) = y_{c} \\Delta y$, we obtain\n$$\n\\Phi_{E} = \\Delta y \\left( a x_{E} + b y_{c} + c \\right).\n$$\n\nWest edge:\n- Parameterization: $x = x_{W} := x_{c} - \\Delta x/2$, $y \\in [y_{-}, y_{+}]$, $d\\ell = dy$.\n- Integrand: $\\mathbf{u} \\cdot \\hat{n}_{W} = - u_{x}(x,y) = - \\left( a x + b y + c \\right)$ at $x = x_{W}$.\n- Integral:\n$$\n\\Phi_{W} = \\int_{y_{-}}^{y_{+}} \\left( - a x_{W} - b y - c \\right) \\, dy = - \\Delta y \\left( a x_{W} + b y_{c} + c \\right).\n$$\n\nSumming east and west contributions:\n$$\n\\Phi_{E} + \\Phi_{W} = \\Delta y \\left[ a \\left( x_{E} - x_{W} \\right) + \\left( b y_{c} + c \\right) - \\left( b y_{c} + c \\right) \\right] = \\Delta y \\, a \\left( x_{E} - x_{W} \\right).\n$$\nSince $x_{E} - x_{W} = \\left( x_{c} + \\tfrac{\\Delta x}{2} \\right) - \\left( x_{c} - \\tfrac{\\Delta x}{2} \\right) = \\Delta x$, we get\n$$\n\\Phi_{E} + \\Phi_{W} = a \\, \\Delta x \\, \\Delta y.\n$$\n\nNorth edge:\n- Parameterization: $y = y_{N} := y_{c} + \\Delta y/2$, $x \\in [x_{-}, x_{+}]$ with $x_{\\pm} := x_{c} \\pm \\Delta x/2$, and $d\\ell = dx$.\n- Integrand: $\\mathbf{u} \\cdot \\hat{n}_{N} = u_{y}(x,y) = d x + e y + f$ at $y = y_{N}$.\n- Integral:\n$$\n\\Phi_{N} = \\int_{x_{-}}^{x_{+}} \\left( d x + e y_{N} + f \\right) \\, dx = d \\int_{x_{-}}^{x_{+}} x \\, dx + \\left( e y_{N} + f \\right) \\Delta x.\n$$\nUsing $\\int_{x_{-}}^{x_{+}} x \\, dx = \\tfrac{1}{2} \\left( x_{+}^{2} - x_{-}^{2} \\right) = x_{c} \\Delta x$, we obtain\n$$\n\\Phi_{N} = d \\, x_{c} \\, \\Delta x + \\left( e y_{N} + f \\right) \\Delta x.\n$$\n\nSouth edge:\n- Parameterization: $y = y_{S} := y_{c} - \\Delta y/2$, $x \\in [x_{-}, x_{+}]$, $d\\ell = dx$.\n- Integrand: $\\mathbf{u} \\cdot \\hat{n}_{S} = - u_{y}(x,y) = - \\left( d x + e y + f \\right)$ at $y = y_{S}$.\n- Integral:\n$$\n\\Phi_{S} = \\int_{x_{-}}^{x_{+}} \\left( - d x - e y_{S} - f \\right) \\, dx = - d \\int_{x_{-}}^{x_{+}} x \\, dx - \\left( e y_{S} + f \\right) \\Delta x.\n$$\nThus,\n$$\n\\Phi_{S} = - d \\, x_{c} \\, \\Delta x - \\left( e y_{S} + f \\right) \\Delta x.\n$$\n\nSumming north and south contributions:\n$$\n\\Phi_{N} + \\Phi_{S} = \\left[ d x_{c} \\Delta x + \\left( e y_{N} + f \\right) \\Delta x \\right] + \\left[ - d x_{c} \\Delta x - \\left( e y_{S} + f \\right) \\Delta x \\right] = \\Delta x \\, e \\left( y_{N} - y_{S} \\right).\n$$\nSince $y_{N} - y_{S} = \\Delta y$, we have\n$$\n\\Phi_{N} + \\Phi_{S} = e \\, \\Delta x \\, \\Delta y.\n$$\n\nTotal outward flux:\n$$\n\\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell \\;=\\; \\left( \\Phi_{E} + \\Phi_{W} \\right) + \\left( \\Phi_{N} + \\Phi_{S} \\right) \\;=\\; a \\, \\Delta x \\, \\Delta y \\;+\\; e \\, \\Delta x \\, \\Delta y \\;=\\; \\left( a + e \\right) \\Delta x \\, \\Delta y.\n$$\n\nAs a consistency check using the divergence theorem (Gauss’s theorem), for a linear field $\\mathbf{u}(x,y)$ with constant divergence $\\nabla \\cdot \\mathbf{u} = \\partial u_{x}/\\partial x + \\partial u_{y}/\\partial y = a + e$, one has $\\displaystyle \\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell = \\iint_{\\Omega} \\nabla \\cdot \\mathbf{u} \\, dA = \\left( a + e \\right) \\, \\text{area}(\\Omega) = \\left( a + e \\right) \\Delta x \\Delta y$, in agreement with the direct edge-by-edge evaluation above.\n\nTherefore, the exact closed-form expression for the contour integral is $\\left( a + e \\right) \\Delta x \\Delta y$.",
            "answer": "$$\\boxed{(a+e)\\,\\Delta x\\,\\Delta y}$$"
        },
        {
            "introduction": "Real-world computational meshes are rarely composed of perfectly planar faces. This exercise () confronts this practical challenge by exploring how to define a meaningful area vector for a warped, non-planar quadrilateral. You will implement and compare two common approaches: one based on summing the area vectors of a triangulated surface and another based on projecting the polygon onto a best-fit plane, providing insight into the numerical subtleties of handling geometric imperfections.",
            "id": "3297351",
            "problem": "Consider a quadrilateral face embedded in three-dimensional Euclidean space, represented by four vertices ordered to form a simple polygon. In Computational Fluid Dynamics (CFD), face-based flux computations rely on face-normal vectors and face areas. For non-planar faces, two principled constructions for an \"effective\" area vector exist: summation of oriented triangle area vectors that discretize the surface, and the product of a fitted plane's unit normal with the scalar area obtained by orthographic projection onto that plane. This problem asks you to derive both constructions from first principles, implement them, and quantify their discrepancies on a specified warped-quadrilateral test suite.\n\nUse the following foundational bases and definitions.\n\n1. Let the face be a smooth surface patch with parametric representation $\\mathbf{r}(u,v)$, and let its oriented area vector be\n$$\n\\mathbf{A} \\equiv \\iint_{S} \\mathbf{n}\\, \\mathrm{d}S,\n$$\nwhere $\\mathbf{n}$ is the unit normal to the surface and $\\mathrm{d}S$ is the scalar differential area element. For a planar polygonal face with constant unit normal $\\mathbf{n}_{\\mathrm{pl}}$, $\\mathbf{A} = \\mathbf{n}_{\\mathrm{pl}}\\, A_{\\mathrm{pl}}$, where $A_{\\mathrm{pl}}$ is the scalar area of the polygon.\n\n2. For a discrete triangulation of a quadrilateral face into two triangles with vertices $(\\mathbf{p}_0,\\mathbf{p}_1,\\mathbf{p}_2)$ and $(\\mathbf{p}_0,\\mathbf{p}_2,\\mathbf{p}_3)$, the oriented area vector of each triangle is defined by the cross product of its two edge vectors scaled by one-half, and the total triangulated area vector is their sum.\n\n3. To fit a plane to a set of points $\\{\\mathbf{p}_i\\}_{i=0}^{3}$, define the centroid $\\bar{\\mathbf{p}}$ and minimize the sum of squared orthogonal distances from the points to a plane passing through $\\bar{\\mathbf{p}}$. The least-squares unit normal $\\hat{\\mathbf{n}}$ to the fitted plane is the unit eigenvector of the $3\\times 3$ covariance matrix of the demeaned coordinates associated with the smallest eigenvalue. The scalar projected area $A_{\\mathrm{proj}}$ of the quadrilateral on the fitted plane is the signed area of the orthographic projection of the polygon onto that plane.\n\nStarting from these bases, derive algorithms to compute:\n- The triangulation-based area vector, denoted $\\mathbf{A}_{\\triangle}$.\n- The fitted-plane-based area vector, denoted $\\mathbf{A}_{\\mathrm{fit}} \\equiv \\hat{\\mathbf{n}}\\, A_{\\mathrm{proj}}$, with the sign of $\\hat{\\mathbf{n}}$ chosen to maximize $\\hat{\\mathbf{n}}\\cdot \\mathbf{A}_{\\triangle}$.\n\nQuantify, for each face, the discrepancy between the two constructions using:\n- The Euclidean norm of the difference, $\\Delta \\equiv \\lVert \\mathbf{A}_{\\triangle} - \\mathbf{A}_{\\mathrm{fit}} \\rVert$.\n- The relative magnitude error, $\\varepsilon \\equiv \\dfrac{\\lVert \\mathbf{A}_{\\triangle} \\rVert - \\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}{\\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}$.\n- The angle between the vectors, $\\theta \\equiv \\arccos\\!\\left(\\dfrac{\\mathbf{A}_{\\triangle}\\cdot \\mathbf{A}_{\\mathrm{fit}}}{\\lVert \\mathbf{A}_{\\triangle} \\rVert \\,\\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}\\right)$, expressed in radians. If either vector has zero magnitude, define $\\theta$ to be $0$.\n\nImplement a program that, for each test case below, computes $[\\Delta,\\ \\varepsilon,\\ \\theta]$ using the derivations above. Use the vertex ordering as given; use orthographic projection onto the fitted plane to compute $A_{\\mathrm{proj}}$; express angles in radians; no physical units are involved. The output for each test case must be a list of three floating-point numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets of lists, for example, \"[[a,b,c],[d,e,f],...]\".\n\nTest suite of four quadrilateral faces (each is a list of four vertices, in order):\n1. Planar rectangle in the plane $z=0$: $\\left[(0,0,0),(2,0,0),(2,1,0),(0,1,0)\\right]$.\n2. Mildly warped quadrilateral: $\\left[(0,0,0),(1,0,0.1),(1,1,-0.1),(0,1,0)\\right]$.\n3. Strongly warped quadrilateral: $\\left[(0,0,0),(2,0,0.5),(2,2,-0.6),(0,2,0.4)\\right]$.\n4. Nearly degenerate but planar slender quadrilateral: $\\left[(0,0,0),(10^{-6},0,0),(10^{-6},1,0),(0,1,0)\\right]$.\n\nYour program must compute, for each case, the list $[\\Delta,\\ \\varepsilon,\\ \\theta]$ and print a single line that aggregates the results as a comma-separated list of these lists, enclosed in square brackets, exactly like \"[[result_case1],[result_case2],[result_case3],[result_case4]]\".",
            "solution": "The problem is valid as it is scientifically grounded in vector calculus and linear algebra, well-posed with specific and unambiguous definitions, and objective in its formulation. It presents a non-trivial computational geometry task relevant to fields like Computational Fluid Dynamics (CFD). We will proceed to derive the algorithms and compute the requested quantities.\n\nThe core task is to compute and compare two definitions of an area vector for a quadrilateral face defined by four ordered vertices in three-dimensional space, $\\{\\mathbf{p}_0, \\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3\\}$.\n\n**1. Derivation of the Triangulation-based Area Vector ($\\mathbf{A}_{\\triangle}$)**\n\nThis construction defines the area vector as the sum of the area vectors of two triangles that form the quadrilateral. The problem specifies a triangulation using the diagonal connecting vertices $\\mathbf{p}_0$ and $\\mathbf{p}_2$. This forms two triangles, $T_1$ with vertices $(\\mathbf{p}_0, \\mathbf{p}_1, \\mathbf{p}_2)$ and $T_2$ with vertices $(\\mathbf{p}_0, \\mathbf{p}_2, \\mathbf{p}_3)$.\n\nThe oriented area vector of a triangle is given by one-half of the cross product of two of its edge vectors. For $T_1$, we use the edge vectors originating from $\\mathbf{p}_0$, which are $(\\mathbf{p}_1 - \\mathbf{p}_0)$ and $(\\mathbf{p}_2 - \\mathbf{p}_0)$. Its area vector $\\mathbf{A}_1$ is:\n$$\n\\mathbf{A}_1 = \\frac{1}{2} (\\mathbf{p}_1 - \\mathbf{p}_0) \\times (\\mathbf{p}_2 - \\mathbf{p}_0)\n$$\n\nSimilarly, for $T_2$, we use the edge vectors $(\\mathbf{p}_2 - \\mathbf{p}_0)$ and $(\\mathbf{p}_3 - \\mathbf{p}_0)$. Its area vector $\\mathbf{A}_2$ is:\n$$\n\\mathbf{A}_2 = \\frac{1}{2} (\\mathbf{p}_2 - \\mathbf{p}_0) \\times (\\mathbf{p}_3 - \\mathbf{p}_0)\n$$\n\nThe total triangulation-based area vector, $\\mathbf{A}_{\\triangle}$, is the vector sum of $\\mathbf{A}_1$ and $\\mathbf{A}_2$:\n$$\n\\mathbf{A}_{\\triangle} = \\mathbf{A}_1 + \\mathbf{A}_2 = \\frac{1}{2} \\left[ (\\mathbf{p}_1 - \\mathbf{p}_0) \\times (\\mathbf{p}_2 - \\mathbf{p}_0) + (\\mathbf{p}_2 - \\mathbf{p}_0) \\times (\\mathbf{p}_3 - \\mathbf{p}_0) \\right]\n$$\nThis formula provides a direct algorithm for computing $\\mathbf{A}_{\\triangle}$ from the vertex coordinates.\n\n**2. Derivation of the Fitted-Plane-based Area Vector ($\\mathbf{A}_{\\mathrm{fit}}$)**\n\nThis construction involves finding a best-fit plane for the four vertices and then calculating the area of the quadrilateral's projection onto this plane. The final area vector is the product of this projected area and the plane's unit normal.\n\n**Step 2.1: Plane Fitting via Principal Component Analysis (PCA)**\nTo find the best-fit plane for the set of points $\\{\\mathbf{p}_i\\}_{i=0}^3$, we minimize the sum of squared orthogonal distances from the points to the plane. This is a classic application of PCA.\n\nFirst, we compute the centroid of the vertices:\n$$\n\\bar{\\mathbf{p}} = \\frac{1}{4} \\sum_{i=0}^{3} \\mathbf{p}_i\n$$\n\nNext, we find the demeaned coordinates (coordinates relative to the centroid):\n$$\n\\mathbf{q}_i = \\mathbf{p}_i - \\bar{\\mathbf{p}}\n$$\n\nWe then construct the $3 \\times 3$ covariance matrix (or scatter matrix) $C$:\n$$\nC = \\sum_{i=0}^{3} \\mathbf{q}_i \\mathbf{q}_i^T\n$$\nIf $Q$ is the $4 \\times 3$ matrix whose rows are the vectors $\\mathbf{q}_i^T$, then $C = Q^T Q$. The unit normal to the best-fit plane, $\\hat{\\mathbf{n}}$, is the unit eigenvector of $C$ corresponding to its smallest eigenvalue. This eigenvector represents the direction of minimum variance of the point cloud, which is orthogonal to the plane of maximum variance.\n\n**Step 2.2: Orientation of the Normal Vector**\nAn eigensolver will return a unit eigenvector $\\hat{\\mathbf{n}}_{\\text{eig}}$, but its direction (sign) is arbitrary. The problem specifies that the sign must be chosen to maximize the dot product $\\hat{\\mathbf{n}} \\cdot \\mathbf{A}_{\\triangle}$. This ensures consistency between the two area vector definitions. We first compute $\\mathbf{A}_{\\triangle}$ and an initial $\\hat{\\mathbf{n}}_{\\text{eig}}$. Then, the correctly oriented normal $\\hat{\\mathbf{n}}$ is determined as:\n$$\n\\hat{\\mathbf{n}} = \\begin{cases} \\hat{\\mathbf{n}}_{\\text{eig}} & \\text{if } \\hat{\\mathbf{n}}_{\\text{eig}} \\cdot \\mathbf{A}_{\\triangle} \\ge 0 \\\\ -\\hat{\\mathbf{n}}_{\\text{eig}} & \\text{if } \\hat{\\mathbf{n}}_{\\text{eig}} \\cdot \\mathbf{A}_{\\triangle} < 0 \\end{cases}\n$$\n\n**Step 2.3: Calculation of Projected Area ($A_{\\mathrm{proj}}$)**\nThe scalar area $A_{\\mathrm{proj}}$ is the signed area of the quadrilateral's orthographic projection onto the fitted plane. To compute this, we establish a 2D orthonormal basis $\\{\\mathbf{u}_1, \\mathbf{u}_2\\}$ for the plane. A robust choice for this basis can be formed from the other eigenvectors of the covariance matrix $C$. Let the unit eigenvectors corresponding to the largest and middle eigenvalues be $\\mathbf{e}_{\\text{large}}$ and $\\mathbf{e}_{\\text{mid}}$, respectively. We can set $\\mathbf{u}_1 = \\mathbf{e}_{\\text{large}}$ and form a right-handed coordinate system $\\{\\mathbf{u}_1, \\mathbf{u}_2, \\hat{\\mathbf{n}}\\}$ by defining $\\mathbf{u}_2 = \\hat{\\mathbf{n}} \\times \\mathbf{u}_1$.\n\nThe 2D coordinates of each projected vertex in this new basis, relative to the centroid, are:\n$$\n(u_i, v_i) = (\\mathbf{q}_i \\cdot \\mathbf{u}_1, \\mathbf{q}_i \\cdot \\mathbf{u}_2)\n$$\n\nThe signed area of the resulting 2D polygon $\\{(u_0, v_0), (u_1, v_1), (u_2, v_2), (u_3, v_3)\\}$ is computed using the Shoelace formula:\n$$\nA_{\\mathrm{proj}} = \\frac{1}{2} \\sum_{i=0}^{3} (u_i v_{i+1} - u_{i+1} v_i)\n$$\nwhere the index $4$ is taken to be $0$ (i.e., $(u_4, v_4) = (u_0, v_0)$).\n\n**Step 2.4: Assembling $\\mathbf{A}_{\\mathrm{fit}}$**\nFinally, the fitted-plane-based area vector is constructed by combining the signed scalar area and the oriented unit normal:\n$$\n\\mathbf{A}_{\\mathrm{fit}} = A_{\\mathrm{proj}} \\hat{\\mathbf{n}}\n$$\n\n**3. Discrepancy Quantification**\n\nWith both $\\mathbf{A}_{\\triangle}$ and $\\mathbf{A}_{\\mathrm{fit}}$ computed, we quantify the discrepancy between them using the specified metrics.\n\n- The Euclidean norm of the difference:\n$$\n\\Delta = \\lVert \\mathbf{A}_{\\triangle} - \\mathbf{A}_{\\mathrm{fit}} \\rVert\n$$\n\n- The relative magnitude error:\n$$\n\\varepsilon = \\frac{\\lVert \\mathbf{A}_{\\triangle} \\rVert - \\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}{\\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}\n$$\nThis is computed provided $\\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert \\neq 0$.\n\n- The angle between the vectors, in radians:\n$$\n\\theta = \\arccos\\!\\left(\\frac{\\mathbf{A}_{\\triangle}\\cdot \\mathbf{A}_{\\mathrm{fit}}}{\\lVert \\mathbf{A}_{\\triangle} \\rVert \\,\\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}\\right)\n$$\nThis is computed provided both vectors have non-zero magnitude. As per the problem statement, if either vector is the zero vector, we define $\\theta = 0$. For numerical stability, the argument of $\\arccos$ should be clipped to the range $[-1, 1]$.\n\nThese steps provide a complete and rigorous algorithm for solving the problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares two types of area vectors for quadrilateral faces\n    and prints the discrepancy metrics for a suite of test cases.\n    \"\"\"\n    # Test suite of four quadrilateral faces (each is a list of four vertices, in order).\n    # Vertices are given as lists of tuples and converted to numpy arrays.\n    test_cases_raw = [\n        [(0,0,0),(2,0,0),(2,1,0),(0,1,0)],\n        [(0,0,0),(1,0,0.1),(1,1,-0.1),(0,1,0)],\n        [(0,0,0),(2,0,0.5),(2,2,-0.6),(0,2,0.4)],\n        [(0,0,0),(1e-6,0,0),(1e-6,1,0),(0,1,0)],\n    ]\n    test_cases = [np.array(case, dtype=float) for case in test_cases_raw]\n\n    results = []\n    for quad_vertices in test_cases:\n        # --- 1. Compute Triangulation-based Area Vector (A_triangle) ---\n        p0, p1, p2, p3 = quad_vertices[0], quad_vertices[1], quad_vertices[2], quad_vertices[3]\n\n        # Based on triangulation (p0, p1, p2) and (p0, p2, p3)\n        # The sum of vector areas is what's required.\n        \n        vec1 = p1 - p0\n        vec2 = p2 - p0\n        vec3 = p3 - p0\n\n        area_vec1 = 0.5 * np.cross(vec1, vec2)\n        area_vec2 = 0.5 * np.cross(vec2, vec3)\n        A_triangle = area_vec1 + area_vec2\n\n        # --- 2. Compute Fitted-plane-based Area Vector (A_fit) ---\n\n        # 2.1. Plane Fitting via PCA\n        centroid = np.mean(quad_vertices, axis=0)\n        demeaned_pts = quad_vertices - centroid\n        \n        # Covariance matrix C = Q^T Q, where Q is the 4x3 matrix of demeaned points\n        cov_matrix = demeaned_pts.T @ demeaned_pts\n        \n        # eigh for symmetric matrices; returns eigenvalues in ascending order\n        eigenvalues, eigenvectors = np.linalg.eigh(cov_matrix)\n        \n        # The normal is the eigenvector for the smallest eigenvalue\n        n_eig = eigenvectors[:, 0]\n\n        # 2.2. Orient the Normal Vector\n        if np.dot(n_eig, A_triangle) < 0:\n            n_hat = -n_eig\n        else:\n            n_hat = n_eig\n\n        # 2.3. Calculate Projected Area (A_proj)\n        # Form an orthonormal basis for the plane\n        u1_eig = eigenvectors[:, 2]  # Eigenvector for largest eigenvalue\n        u1 = u1_eig / np.linalg.norm(u1_eig)\n        u2 = np.cross(n_hat, u1) # Guarantees a right-handed system {u1, u2, n_hat}\n\n        # Project demeaned points onto the 2D basis\n        coords_2d = np.array([(np.dot(q, u1), np.dot(q, u2)) for q in demeaned_pts])\n        u, v = coords_2d[:, 0], coords_2d[:, 1]\n        \n        # Shoelace formula for signed area of projected 2D polygon\n        A_proj = 0.5 * (u[0]*v[1] - u[1]*v[0] + \n                         u[1]*v[2] - u[2]*v[1] + \n                         u[2]*v[3] - u[3]*v[2] + \n                         u[3]*v[0] - u[0]*v[3])\n\n        # 2.4. Assemble A_fit\n        A_fit = A_proj * n_hat\n\n        # --- 3. Quantify Discrepancy ---\n        \n        # Delta: Euclidean norm of the difference\n        delta = np.linalg.norm(A_triangle - A_fit)\n\n        # Epsilon: Relative magnitude error\n        norm_A_triangle = np.linalg.norm(A_triangle)\n        norm_A_fit = np.linalg.norm(A_fit)\n        \n        if np.isclose(norm_A_fit, 0.0):\n            # If fitted area is zero, relative error is infinite if triangle area is non-zero\n            epsilon = np.inf if not np.isclose(norm_A_triangle, 0.0) else 0.0\n        else:\n            epsilon = (norm_A_triangle - norm_A_fit) / norm_A_fit\n\n        # Theta: Angle between vectors\n        if np.isclose(norm_A_triangle, 0.0) or np.isclose(norm_A_fit, 0.0):\n            theta = 0.0\n        else:\n            dot_product = np.dot(A_triangle, A_fit)\n            # Clip for numerical stability to prevent arccos domain errors\n            cos_theta = np.clip(dot_product / (norm_A_triangle * norm_A_fit), -1.0, 1.0)\n            theta = np.arccos(cos_theta)\n\n        results.append([delta, epsilon, theta])\n\n    # Final print statement in the exact required format.\n    # The format requires a string representation of a list of lists.\n    results_str = ','.join([f\"[{d},{e},{t}]\" for d, e, t in results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A core task in CFD is simulating flow around curved objects, where smooth surfaces are approximated by discrete, faceted meshes. The accuracy of such a simulation depends critically on how well these discrete face normals represent the true surface normals. This computational practice () guides you through building a triangulated sphere and systematically quantifying the geometric error in the face normals as the mesh is refined, a crucial skill for assessing the fidelity of any CFD model.",
            "id": "3297286",
            "problem": "You are tasked with a principled computational study of unit face normal vectors for triangulated approximations of a smooth sphere in the context of Computational Fluid Dynamics (CFD). In finite-volume discretizations on unstructured meshes, the face normal direction is central to flux computations. This exercise requires deriving the analytic normal for an implicitly defined sphere from first principles, constructing a sequence of increasingly refined triangulated approximations, and quantifying angular discrepancies between the analytic and discrete face normals.\n\nStarting from the fundamental definition: a smooth surface can be represented as a level set of a scalar field $F(\\mathbf{x}) = 0$. At any point $\\mathbf{x}$ on the surface where $\\nabla F(\\mathbf{x}) \\neq \\mathbf{0}$, vectors tangent to the surface lie in the null space of the linear functional $\\mathbf{t} \\mapsto \\nabla F(\\mathbf{x}) \\cdot \\mathbf{t}$. Therefore, the unit normal vector is parallel to $\\nabla F(\\mathbf{x})$ and is obtained by normalizing it. Apply this principle to the sphere defined implicitly by $F(\\mathbf{x}) = x^2 + y^2 + z^2 - R^2$ to derive the analytic unit normal, ensuring that it points outward. Do not use or assume any pre-existing closed-form normal for the sphere; instead, derive it explicitly from the gradient definition.\n\nFor a triangulated approximation, use the following well-established geometric construction. Begin with a regular icosahedron inscribed in the sphere of radius $R$ centered at the origin. Perform $s$ recursive subdivisions defined by:\n- For each triangular face with vertices $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{c}$, compute the midpoints of edges, radially project each midpoint back onto the sphere of radius $R$, and subdivide the face into $4$ child triangles.\n- After $s$ rounds, obtain a triangulation whose vertices lie on the sphere.\n\nFor each triangular face at the final resolution:\n- Compute the outward unit face normal via the vector cross product of edge vectors and normalization. If the initially computed direction is inward (determined by a negative dot product with the position vector of the face centroid), flip its sign to enforce outward orientation.\n- Compute the analytic unit normal at the point on the sphere corresponding to the radial projection of the face centroid (defined as the arithmetic mean of the face’s three vertices) onto the sphere.\n- Compute the angular error as the angle between the discrete face unit normal and the analytic unit normal via the inverse cosine of the clamped dot product. Angles must be reported in radians.\n\nOver all faces, quantify the angular error distribution using the following metrics, each defined precisely:\n- The mean angular error $m = \\frac{1}{N}\\sum_{i=1}^{N} \\theta_i$.\n- The maximum angular error $M = \\max_{i \\in \\{1,\\dots,N\\}} \\theta_i$.\n- The $95$th percentile angular error $q_{95}$ defined as the value below which $95$ out of $100$ of the angles fall under the conventional percentile definition.\n- The root-mean-square angular error $r = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\theta_i^2}$.\n\nAngles must be expressed in radians. Your program must implement the entire pipeline described above using only numerical linear algebra and geometry, without reliance on any mesh libraries or external files. The mesh construction must use the icosahedron with the standard golden ratio coordinates, normalized and projected to the sphere of radius $R$ after each midpoint insertion.\n\nTest suite:\n- Use the following ordered set of $(R,s)$ cases, where $R$ is the radius, and $s$ is the number of subdivision levels:\n    1. $(R = 1.0, s = 0)$,\n    2. $(R = 1.0, s = 1)$,\n    3. $(R = 1.0, s = 2)$,\n    4. $(R = 2.75, s = 3)$.\n- For each case, compute and report a list of four floating-point values $[m, M, q_{95}, r]$ in radians, each rounded to $10$ decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing a list of lists, one sublist per test case in the exact order given above. For example, the textual structure must look like $[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],[c_1,c_2,c_3,c_4],[d_1,d_2,d_3,d_4]]$, where each symbol represents a floating-point number rounded to $10$ decimal places. The output must be a single line with no additional text.",
            "solution": "We start from the implicit surface representation. Let the smooth surface be given by $F(\\mathbf{x}) = 0$, with $\\mathbf{x} \\in \\mathbb{R}^3$ and $\\nabla F(\\mathbf{x}) \\neq \\mathbf{0}$ on the surface. Consider any differentiable curve $\\mathbf{x}(t)$ lying on the surface so that $F(\\mathbf{x}(t)) = 0$ for all $t$ in a neighborhood. Differentiating with respect to $t$ yields\n$$\n\\frac{d}{dt} F(\\mathbf{x}(t)) = \\nabla F(\\mathbf{x}(t)) \\cdot \\frac{d\\mathbf{x}}{dt} = 0.\n$$\nThus, for any tangent vector $\\mathbf{t} = \\frac{d\\mathbf{x}}{dt}$, we have $\\nabla F(\\mathbf{x}) \\cdot \\mathbf{t} = 0$. Therefore, $\\nabla F(\\mathbf{x})$ is orthogonal to all tangent vectors at $\\mathbf{x}$ and hence normal to the surface. The unit normal is obtained by normalization:\n$$\n\\hat{\\mathbf{n}}(\\mathbf{x}) = \\frac{\\nabla F(\\mathbf{x})}{\\lVert \\nabla F(\\mathbf{x}) \\rVert}.\n$$\nFor the sphere, take $F(\\mathbf{x}) = x^2 + y^2 + z^2 - R^2$. Then\n$$\n\\nabla F(\\mathbf{x}) = \\begin{bmatrix} 2x \\\\ 2y \\\\ 2z \\end{bmatrix} = 2 \\mathbf{x}.\n$$\nOn the surface, $\\lVert \\mathbf{x} \\rVert = R$, so the outward unit normal is\n$$\n\\hat{\\mathbf{n}}_{\\text{analytic}}(\\mathbf{x}) = \\frac{2 \\mathbf{x}}{\\lVert 2 \\mathbf{x} \\rVert} = \\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert} = \\frac{\\mathbf{x}}{R}.\n$$\nThis derivation shows that the analytic unit normal at any point on the sphere points radially outward and is independent of any particular parameterization.\n\nFor the triangulated approximation, we adopt a standard icosphere construction:\n1. Initialize a regular icosahedron inscribed in the unit sphere. Its $12$ vertices may be defined using the golden ratio $\\varphi = \\frac{1 + \\sqrt{5}}{2}$ with coordinates of the form $(\\pm 1, \\pm \\varphi, 0)$, $(0, \\pm 1, \\pm \\varphi)$, and $(\\pm \\varphi, 0, \\pm 1)$, followed by normalization to unit length. The $20$ faces are fixed by a consistent indexing pattern to ensure coherent orientations.\n2. For each subdivision level $s$, subdivide every triangular face into $4$ smaller triangles by connecting edge midpoints. Each midpoint $\\mathbf{m} = \\frac{\\mathbf{u} + \\mathbf{v}}{2}$ (for edge endpoints $\\mathbf{u}$ and $\\mathbf{v}$) is radially projected back to the sphere of radius $R$ by mapping $\\mathbf{m} \\mapsto R \\frac{\\mathbf{m}}{\\lVert \\mathbf{m} \\rVert}$. A deduplication map on edges ensures midpoint vertices are uniquely created per edge. This preserves the spherical geometry across refinements.\n\nFor a given face with vertices $\\mathbf{a}, \\mathbf{b}, \\mathbf{c}$ on the sphere of radius $R$ centered at the origin:\n- The discrete face unit normal is computed from edge vectors $\\mathbf{e}_1 = \\mathbf{b} - \\mathbf{a}$ and $\\mathbf{e}_2 = \\mathbf{c} - \\mathbf{a}$ via the cross product $\\mathbf{n} = \\mathbf{e}_1 \\times \\mathbf{e}_2$. Normalize to obtain $\\hat{\\mathbf{n}}_{\\text{face}} = \\frac{\\mathbf{n}}{\\lVert \\mathbf{n} \\rVert}$. To ensure outward orientation, compute the (unprojected) centroid $\\mathbf{g} = \\frac{1}{3}(\\mathbf{a} + \\mathbf{b} + \\mathbf{c})$ and enforce $\\hat{\\mathbf{n}}_{\\text{face}} \\cdot \\mathbf{g} \\ge 0$; if not, flip the sign: $\\hat{\\mathbf{n}}_{\\text{face}} \\leftarrow -\\hat{\\mathbf{n}}_{\\text{face}}$.\n- The analytic unit normal is evaluated at the radial projection of the centroid onto the sphere: $\\mathbf{x}_c = R \\frac{\\mathbf{g}}{\\lVert \\mathbf{g} \\rVert}$. Using the derivation above, $\\hat{\\mathbf{n}}_{\\text{analytic}}(\\mathbf{x}_c) = \\frac{\\mathbf{x}_c}{R} = \\frac{\\mathbf{g}}{\\lVert \\mathbf{g} \\rVert}$, revealing independence from $R$ in direction.\n\nDefine the angular error for a face as\n$$\n\\theta = \\arccos\\!\\left( \\operatorname{clip}\\left( \\hat{\\mathbf{n}}_{\\text{face}} \\cdot \\hat{\\mathbf{n}}_{\\text{analytic}}, -1, 1 \\right) \\right),\n$$\nmeasured in radians. Because both inputs are unit vectors and clamped, $\\theta \\in [0, \\pi]$.\n\nOver all faces $\\{\\theta_i\\}_{i=1}^N$, compute:\n- Mean: $m = \\frac{1}{N} \\sum_{i=1}^N \\theta_i$.\n- Maximum: $M = \\max_i \\theta_i$.\n- Percentile: $q_{95}$ as the empirical $95$th percentile.\n- Root-mean-square: $r = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N \\theta_i^2 }$.\n\nNotably, the angular error distribution is invariant under uniform scaling by $R$ because both normals are directions. Nevertheless, test cases include different $R$ to verify scale invariance within numerical precision.\n\nAlgorithmic considerations:\n- The icosphere has $20 \\cdot 4^s$ faces after $s$ subdivisions, so $s \\in \\{0,1,2,3\\}$ yields $N \\in \\{20,80,320,1280\\}$ faces, which is computationally tractable.\n- Midpoint deduplication uses a hash map keyed by sorted edge endpoint indices to avoid duplicating vertices.\n- All vector normalizations guard against division by zero; for a well-formed icosphere, degeneracies do not occur.\n\nTest suite specification:\n- Execute four cases in order: $(R,s) \\in \\{(1.0,0),(1.0,1),(1.0,2),(2.75,3)\\}$.\n- For each case, compute and output $[m, M, q_{95}, r]$ in radians, each rounded to $10$ decimal places.\n\nFinal output specification:\n- Print exactly one line containing the overall result as a list of lists in the specified order. For example, an output will have the textual form $[[0.0000000000,0.1000000000,0.0900000000,0.0600000000],\\dots]$ with each floating-point number rounded to $10$ decimal places, and no additional characters or lines.\n\nThis procedure rigorously connects the fundamental definition of normals via gradients to practical computation of face normals on triangulated meshes and quantifies the discretization-induced angular error.",
            "answer": "```python\nimport numpy as np\n\ndef icosahedron():\n    \"\"\"\n    Construct a unit icosahedron.\n    Returns:\n        V (np.ndarray): (12,3) array of vertex positions on the unit sphere.\n        F (np.ndarray): (20,3) array of triangular face indices (int).\n    \"\"\"\n    phi = (1.0 + np.sqrt(5.0)) / 2.0\n    verts = np.array([\n        [-1,  phi,  0],\n        [ 1,  phi,  0],\n        [-1, -phi,  0],\n        [ 1, -phi,  0],\n        [ 0, -1,  phi],\n        [ 0,  1,  phi],\n        [ 0, -1, -phi],\n        [ 0,  1, -phi],\n        [ phi,  0, -1],\n        [ phi,  0,  1],\n        [-phi,  0, -1],\n        [-phi,  0,  1],\n    ], dtype=float)\n\n    # Normalize to unit sphere\n    V = verts / np.linalg.norm(verts, axis=1)[:, None]\n\n    F = np.array([\n        [0, 11, 5],\n        [0, 5, 1],\n        [0, 1, 7],\n        [0, 7, 10],\n        [0, 10, 11],\n        [1, 5, 9],\n        [5, 11, 4],\n        [11, 10, 2],\n        [10, 7, 6],\n        [7, 1, 8],\n        [3, 9, 4],\n        [3, 4, 2],\n        [3, 2, 6],\n        [3, 6, 8],\n        [3, 8, 9],\n        [4, 9, 5],\n        [2, 4, 11],\n        [6, 2, 10],\n        [8, 6, 7],\n        [9, 8, 1],\n    ], dtype=int)\n    return V, F\n\ndef normalize_rows(X, eps=1e-15):\n    nrm = np.linalg.norm(X, axis=1, keepdims=True)\n    nrm = np.maximum(nrm, eps)\n    return X / nrm\n\ndef subdivide_icosphere(V, F, levels, R):\n    \"\"\"\n    Subdivide an icosahedron-based sphere mesh 'levels' times.\n    Vertices are kept on the sphere of radius R by radial projection.\n    Args:\n        V (np.ndarray): (n,3) vertices on unit sphere initially.\n        F (np.ndarray): (m,3) faces.\n        levels (int): number of subdivision levels.\n        R (float): sphere radius.\n    Returns:\n        V_out (np.ndarray): vertices on sphere of radius R.\n        F_out (np.ndarray): faces.\n    \"\"\"\n    # Start with vertices on sphere of radius R\n    V = normalize_rows(V) * R\n    F = F.copy()\n\n    for _ in range(levels):\n        edge_mid_cache = {}\n        new_faces = []\n\n        def get_midpoint(i, j):\n            key = (i, j) if i < j else (j, i)\n            if key in edge_mid_cache:\n                return edge_mid_cache[key]\n            vi = V[i]\n            vj = V[j]\n            m = (vi + vj) * 0.5\n            # Radial project to sphere of radius R\n            m = m / (np.linalg.norm(m) + 1e-30) * R\n            idx = len(V_list)\n            V_list.append(m)\n            edge_mid_cache[key] = idx\n            return idx\n\n        V_list = [v for v in V]\n        for a, b, c in F:\n            ab = get_midpoint(a, b)\n            bc = get_midpoint(b, c)\n            ca = get_midpoint(c, a)\n            # Create 4 new faces\n            new_faces.append([a, ab, ca])\n            new_faces.append([b, bc, ab])\n            new_faces.append([c, ca, bc])\n            new_faces.append([ab, bc, ca])\n\n        V = np.array(V_list, dtype=float)\n        F = np.array(new_faces, dtype=int)\n\n    return V, F\n\ndef face_normals_outward(V, F):\n    \"\"\"\n    Compute outward-oriented unit face normals for triangles with vertices V and faces F.\n    Uses centroid direction to enforce outward orientation for origin-centered sphere.\n    Args:\n        V (np.ndarray): (n,3) vertices.\n        F (np.ndarray): (m,3) faces, integer indices.\n    Returns:\n        normals (np.ndarray): (m,3) unit normals oriented outward.\n        centroids (np.ndarray): (m,3) centroids of each face (not projected).\n    \"\"\"\n    A = V[F[:, 0], :]\n    B = V[F[:, 1], :]\n    C = V[F[:, 2], :]\n\n    E1 = B - A\n    E2 = C - A\n    N = np.cross(E1, E2)\n    # Normalize normals\n    N = normalize_rows(N)\n    # Face centroids\n    G = (A + B + C) / 3.0\n    # Ensure outward direction for origin-centered sphere\n    s = np.sign(np.sum(N * G, axis=1))\n    s[s == 0] = 1.0\n    N = N * s[:, None]\n    return N, G\n\ndef analytic_normals_at_centroids(G):\n    \"\"\"\n    Compute analytic unit normals at radial projection of centroids G onto sphere.\n    Since the sphere is centered at the origin, the analytic normal at projected centroid\n    is simply the normalized centroid direction.\n    Args:\n        G (np.ndarray): (m,3) centroids (not necessarily on sphere).\n    Returns:\n        A (np.ndarray): (m,3) analytic unit normals.\n    \"\"\"\n    return normalize_rows(G)\n\ndef angular_errors(N_face, N_analytic):\n    \"\"\"\n    Compute angular errors in radians between corresponding unit normals.\n    Args:\n        N_face (np.ndarray): (m,3) face unit normals.\n        N_analytic (np.ndarray): (m,3) analytic unit normals.\n    Returns:\n        angles (np.ndarray): (m,) angles in radians.\n    \"\"\"\n    dots = np.sum(N_face * N_analytic, axis=1)\n    dots = np.clip(dots, -1.0, 1.0)\n    return np.arccos(dots)\n\ndef metrics_from_angles(angles):\n    \"\"\"\n    Compute [mean, max, 95th percentile, RMS] for the angle distribution.\n    Args:\n        angles (np.ndarray): (m,) angles in radians.\n    Returns:\n        tuple: (mean, max, p95, rms)\n    \"\"\"\n    mean = float(np.mean(angles))\n    maxv = float(np.max(angles))\n    p95 = float(np.percentile(angles, 95.0))\n    rms = float(np.sqrt(np.mean(angles**2)))\n    return mean, maxv, p95, rms\n\ndef run_case(R, s):\n    V0, F0 = icosahedron()\n    V, F = subdivide_icosphere(V0, F0, s, R)\n    N_face, G = face_normals_outward(V, F)\n    N_analytic = analytic_normals_at_centroids(G)\n    angles = angular_errors(N_face, N_analytic)\n    return metrics_from_angles(angles)\n\ndef solve():\n    # Define the test suite as specified: ordered (R, s) pairs.\n    test_cases = [\n        (1.0, 0),\n        (1.0, 1),\n        (1.0, 2),\n        (2.75, 3),\n    ]\n\n    results = []\n    for R, s in test_cases:\n        m, M, q95, r = run_case(R, s)\n        # Round to 10 decimal places as strings\n        results.append([\n            f\"{m:.10f}\",\n            f\"{M:.10f}\",\n            f\"{q95:.10f}\",\n            f\"{r:.10f}\",\n        ])\n\n    # Print as a single line list of lists\n    # Ensure no spaces to strictly follow a compact single-line format.\n    inner = \",\".join(\n        \"[\" + \",\".join(vals) + \"]\" for vals in results\n    )\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}