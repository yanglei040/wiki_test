{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在巩固在简单矩形单元上计算面法线的基本定义，并将其与通过线积分计算通量直接联系起来。这个练习在一个离散的背景下验证了高斯散度定理，这是有限体积法的核心，为理解数值通量计算奠定了坚实的基础。",
            "id": "3297266",
            "problem": "考虑一个用于计算流体动力学 (CFD) 的笛卡尔网格中的二维矩形控制体 $\\Omega$，其几何中心位于 $(x_{c}, y_{c})$，边长分别为 $\\Delta x$ 和 $\\Delta y$。该矩形是轴对齐的，因此其边界 $\\partial \\Omega$ 由位于 $x = x_{c} \\pm \\Delta x/2$ 和 $y = y_{c} \\pm \\Delta y/2$ 的四条直边组成。一个线性空间变化的速度场被指定为 $\\mathbf{u}(x,y) = \\begin{pmatrix} a x + b y + c \\\\ d x + e y + f \\end{pmatrix}$，其中 $a$、$b$、$c$、$d$、$e$ 和 $f$ 是常数。假设所有量均为无量纲。\n\n任务：\n- 确定 $\\partial \\Omega$ 每条边的外向单位法向量。\n- 使用外向法向通量的基本定义，精确地以闭合形式计算环路积分 $\\displaystyle \\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell$。\n\n将你的最终答案表示为关于 $a$、$b$、$c$、$d$、$e$、$f$、$\\Delta x$ 和 $\\Delta y$ 的单一、简化的解析表达式。不包含单位。无需四舍五入。",
            "solution": "我们从向量场 $\\mathbf{u}$ 穿过边界 $\\partial \\Omega$ 的通量的基本定义开始，该通量由线积分 $\\displaystyle \\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell$ 给出，其中 $\\hat{n}$ 是外向单位法向量。对于一个轴对齐的矩形，四条边具有恒定的外向单位法向量。\n\n几何与法向量：\n- 右（东）边：$x = x_{c} + \\Delta x/2$, $y \\in [y_{c} - \\Delta y/2, \\, y_{c} + \\Delta y/2]$，外向单位法向量 $\\hat{n}_{E} = (1, 0)^{\\top}$。\n- 左（西）边：$x = x_{c} - \\Delta x/2$, $y \\in [y_{c} - \\Delta y/2, \\, y_{c} + \\Delta y/2]$，外向单位法向量 $\\hat{n}_{W} = (-1, 0)^{\\top}$。\n- 上（北）边：$y = y_{c} + \\Delta y/2$, $x \\in [x_{c} - \\Delta x/2, \\, x_{c} + \\Delta x/2]$，外向单位法向量 $\\hat{n}_{N} = (0, 1)^{\\top}$。\n- 下（南）边：$y = y_{c} - \\Delta y/2$, $x \\in [x_{c} - \\Delta x/2, \\, x_{c} + \\Delta x/2]$，外向单位法向量 $\\hat{n}_{S} = (0, -1)^{\\top}$。\n\n我们通过将通量计算为四个边积分之和来求值，使用定义 $\\displaystyle \\int_{\\text{edge}} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell$ 并将每条直边按其坐标变量参数化。\n\n东边：\n- 参数化：$x = x_{E} := x_{c} + \\Delta x/2$，$y \\in [y_{-}, y_{+}]$，其中 $y_{\\pm} := y_{c} \\pm \\Delta y/2$，$d\\ell = dy$。\n- 被积函数：$\\mathbf{u} \\cdot \\hat{n}_{E} = u_{x}(x,y) = a x + b y + c$，在 $x = x_{E}$ 处求值。\n- 积分：\n$$\n\\Phi_{E} = \\int_{y_{-}}^{y_{+}} \\left( a x_{E} + b y + c \\right) \\, dy = \\left( a x_{E} + c \\right) \\Delta y + b \\int_{y_{-}}^{y_{+}} y \\, dy.\n$$\n使用 $\\int_{y_{-}}^{y_{+}} y \\, dy = \\tfrac{1}{2} \\left( y_{+}^{2} - y_{-}^{2} \\right) = y_{c} \\Delta y$，我们得到\n$$\n\\Phi_{E} = \\Delta y \\left( a x_{E} + b y_{c} + c \\right).\n$$\n\n西边：\n- 参数化：$x = x_{W} := x_{c} - \\Delta x/2$，$y \\in [y_{-}, y_{+}]$，$d\\ell = dy$。\n- 被积函数：$\\mathbf{u} \\cdot \\hat{n}_{W} = - u_{x}(x,y) = - \\left( a x + b y + c \\right)$，在 $x = x_{W}$ 处求值。\n- 积分：\n$$\n\\Phi_{W} = \\int_{y_{-}}^{y_{+}} \\left( - a x_{W} - b y - c \\right) \\, dy = - \\Delta y \\left( a x_{W} + b y_{c} + c \\right).\n$$\n\n对东边和西边的贡献求和：\n$$\n\\Phi_{E} + \\Phi_{W} = \\Delta y \\left[ a \\left( x_{E} - x_{W} \\right) + \\left( b y_{c} + c \\right) - \\left( b y_{c} + c \\right) \\right] = \\Delta y \\, a \\left( x_{E} - x_{W} \\right).\n$$\n由于 $x_{E} - x_{W} = \\left( x_{c} + \\tfrac{\\Delta x}{2} \\right) - \\left( x_{c} - \\tfrac{\\Delta x}{2} \\right) = \\Delta x$，我们得到\n$$\n\\Phi_{E} + \\Phi_{W} = a \\, \\Delta x \\, \\Delta y.\n$$\n\n北边：\n- 参数化：$y = y_{N} := y_{c} + \\Delta y/2$，$x \\in [x_{-}, x_{+}]$，其中 $x_{\\pm} := x_{c} \\pm \\Delta x/2$，$d\\ell = dx$。\n- 被积函数：$\\mathbf{u} \\cdot \\hat{n}_{N} = u_{y}(x,y) = d x + e y + f$，在 $y = y_{N}$ 处求值。\n- 积分：\n$$\n\\Phi_{N} = \\int_{x_{-}}^{x_{+}} \\left( d x + e y_{N} + f \\right) \\, dx = d \\int_{x_{-}}^{x_{+}} x \\, dx + \\left( e y_{N} + f \\right) \\Delta x.\n$$\n使用 $\\int_{x_{-}}^{x_{+}} x \\, dx = \\tfrac{1}{2} \\left( x_{+}^{2} - x_{-}^{2} \\right) = x_{c} \\Delta x$，我们得到\n$$\n\\Phi_{N} = d \\, x_{c} \\, \\Delta x + \\left( e y_{N} + f \\right) \\Delta x.\n$$\n\n南边：\n- 参数化：$y = y_{S} := y_{c} - \\Delta y/2$，$x \\in [x_{-}, x_{+}]$，$d\\ell = dx$。\n- 被积函数：$\\mathbf{u} \\cdot \\hat{n}_{S} = - u_{y}(x,y) = - \\left( d x + e y + f \\right)$，在 $y = y_{S}$ 处求值。\n- 积分：\n$$\n\\Phi_{S} = \\int_{x_{-}}^{x_{+}} \\left( - d x - e y_{S} - f \\right) \\, dx = - d \\int_{x_{-}}^{x_{+}} x \\, dx - \\left( e y_{S} + f \\right) \\Delta x.\n$$\n因此，\n$$\n\\Phi_{S} = - d \\, x_{c} \\, \\Delta x - \\left( e y_{S} + f \\right) \\Delta x.\n$$\n\n对北边和南边的贡献求和：\n$$\n\\Phi_{N} + \\Phi_{S} = \\left[ d x_{c} \\Delta x + \\left( e y_{N} + f \\right) \\Delta x \\right] + \\left[ - d x_{c} \\Delta x - \\left( e y_{S} + f \\right) \\Delta x \\right] = \\Delta x \\, e \\left( y_{N} - y_{S} \\right).\n$$\n由于 $y_{N} - y_{S} = \\Delta y$，我们有\n$$\n\\Phi_{N} + \\Phi_{S} = e \\, \\Delta x \\, \\Delta y.\n$$\n\n总外向通量：\n$$\n\\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell \\;=\\; \\left( \\Phi_{E} + \\Phi_{W} \\right) + \\left( \\Phi_{N} + \\Phi_{S} \\right) \\;=\\; a \\, \\Delta x \\, \\Delta y \\;+\\; e \\, \\Delta x \\, \\Delta y \\;=\\; \\left( a + e \\right) \\Delta x \\, \\Delta y.\n$$\n\n作为一致性检验，我们使用散度定理（高斯定理）。对于一个散度为常数 $\\nabla \\cdot \\mathbf{u} = \\partial u_{x}/\\partial x + \\partial u_{y}/\\partial y = a + e$ 的线性场 $\\mathbf{u}(x,y)$，有 $\\displaystyle \\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell = \\iint_{\\Omega} \\nabla \\cdot \\mathbf{u} \\, dA = \\left( a + e \\right) \\, \\text{area}(\\Omega) = \\left( a + e \\right) \\Delta x \\Delta y$，这与上面逐边直接计算的结果一致。\n\n因此，该环路积分的精确闭合形式表达式为 $\\left( a + e \\right) \\Delta x \\Delta y$。",
            "answer": "$$\\boxed{(a+e)\\,\\Delta x\\,\\Delta y}$$"
        },
        {
            "introduction": "在实际的计算流体动力学应用中，计算网格很少是完美的，经常会遇到非平面的网格单元。本练习聚焦于处理这一常见问题，特别是针对非平面的四边形网格面。通过探索和比较两种用于定义“有效”面积向量的原则性方法，本练习揭示了在实际几何计算中可能出现的细微差别和潜在差异，这对于开发稳健的CFD求解器至关重要。",
            "id": "3297351",
            "problem": "考虑一个嵌入在三维欧几里得空间中的四边形面，由四个有序顶点表示，形成一个简单多边形。在计算流体动力学 (CFD) 中，基于面的通量计算依赖于面法向量和面面积。对于非平面，存在两种构造“有效”面积向量的有原则的方法：一种是对离散化曲面的有向三角形面积向量求和，另一种是拟合平面的单位法向量与通过正交投影到该平面上获得的标量面积的乘积。本问题要求您从第一性原理推导这两种构造方法，实现它们，并在一个指定的扭曲四边形测试套件上量化它们的差异。\n\n使用以下基础依据和定义。\n\n1. 设该面是一个光滑曲面片，其参数表示为 $\\mathbf{r}(u,v)$，其有向面积向量为\n$$\n\\mathbf{A} \\equiv \\iint_{S} \\mathbf{n}\\, \\mathrm{d}S,\n$$\n其中 $\\mathbf{n}$ 是曲面的单位法向量，$\\mathrm{d}S$ 是标量微分面积元。对于具有恒定单位法向量 $\\mathbf{n}_{\\mathrm{pl}}$ 的平面多边形面，$\\mathbf{A} = \\mathbf{n}_{\\mathrm{pl}}\\, A_{\\mathrm{pl}}$，其中 $A_{\\mathrm{pl}}$ 是多边形的标量面积。\n\n2. 对于将一个四边形面离散三角剖分为两个顶点为 $(\\mathbf{p}_0,\\mathbf{p}_1,\\mathbf{p}_2)$ 和 $(\\mathbf{p}_0,\\mathbf{p}_2,\\mathbf{p}_3)$ 的三角形，每个三角形的有向面积向量由其两个边向量的叉积乘以二分之一来定义，而总的三角化面积向量是它们的和。\n\n3. 为了对一组点 $\\{\\mathbf{p}_i\\}_{i=0}^{3}$ 进行平面拟合，定义形心 $\\bar{\\mathbf{p}}$，并最小化这些点到通过 $\\bar{\\mathbf{p}}$ 的平面的平方正交距离之和。拟合平面的最小二乘单位法向量 $\\hat{\\mathbf{n}}$ 是去均值坐标的 $3\\times 3$ 协方差矩阵的与最小特征值相关联的单位特征向量。四边形在拟合平面上的标量投影面积 $A_{\\mathrm{proj}}$ 是多边形在该平面上正交投影的有符号面积。\n\n从这些基础出发，推导计算以下向量的算法：\n- 基于三角剖分的面积向量，记为 $\\mathbf{A}_{\\triangle}$。\n- 基于拟合平面的面积向量，记为 $\\mathbf{A}_{\\mathrm{fit}} \\equiv \\hat{\\mathbf{n}}\\, A_{\\mathrm{proj}}$，其中 $\\hat{\\mathbf{n}}$ 的符号选择应使 $\\hat{\\mathbf{n}}\\cdot \\mathbf{A}_{\\triangle}$ 最大化。\n\n对每个面，使用以下指标量化两种构造方法之间的差异：\n- 差的欧几里得范数，$\\Delta \\equiv \\lVert \\mathbf{A}_{\\triangle} - \\mathbf{A}_{\\mathrm{fit}} \\rVert$。\n- 相对大小误差，$\\varepsilon \\equiv \\dfrac{\\lVert \\mathbf{A}_{\\triangle} \\rVert - \\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}{\\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}$。\n- 向量之间的夹角，$\\theta \\equiv \\arccos\\!\\left(\\dfrac{\\mathbf{A}_{\\triangle}\\cdot \\mathbf{A}_{\\mathrm{fit}}}{\\lVert \\mathbf{A}_{\\triangle} \\rVert \\,\\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}\\right)$，以弧度表示。如果任一向量的模长为零，则定义 $\\theta$ 为 $0$。\n\n实现一个程序，对下面的每个测试用例，使用上述推导计算 $[\\Delta,\\ \\varepsilon,\\ \\theta]$。使用给定的顶点顺序；使用到拟合平面的正交投影来计算 $A_{\\mathrm{proj}}$；以弧度表示角度；不涉及物理单位。每个测试用例的输出必须是一个包含三个浮点数的列表。您的程序应生成单行输出，其中包含结果，格式为用方括号括起来的逗号分隔的列表的列表，例如，“[[a,b,c],[d,e,f],...]”。\n\n四个四边形面的测试套件（每个都是一个按顺序排列的四个顶点的列表）：\n1. 位于平面 $z=0$ 中的平面矩形：$\\left[(0,0,0),(2,0,0),(2,1,0),(0,1,0)\\right]$。\n2. 轻度扭曲的四边形：$\\left[(0,0,0),(1,0,0.1),(1,1,-0.1),(0,1,0)\\right]$。\n3. 强度扭曲的四边形：$\\left[(0,0,0),(2,0,0.5),(2,2,-0.6),(0,2,0.4)\\right]$。\n4. 近似退化但平面的细长四边形：$\\left[(0,0,0),(10^{-6},0,0),(10^{-6},1,0),(0,1,0)\\right]$。\n\n您的程序必须为每个案例计算列表 $[\\Delta,\\ \\varepsilon,\\ \\theta]$，并打印一行将这些列表聚合为逗号分隔的列表，并用方括号括起来，格式与“[[result_case1],[result_case2],[result_case3],[result_case4]]”完全一样。",
            "solution": "该问题是有效的，因为它在向量微积分和线性代数方面有科学依据，定义明确无歧义，问题提法得当，并且其表述是客观的。它提出了一个与计算流体动力学 (CFD) 等领域相关的非平凡的计算几何任务。我们将着手推导算法并计算所要求的量。\n\n核心任务是计算和比较由三维空间中四个有序顶点 $\\{\\mathbf{p}_0, \\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3\\}$ 定义的四边形面的面积向量的两种定义。\n\n**1. 基于三角剖分的面积向量 ($\\mathbf{A}_{\\triangle}$) 的推导**\n\n这种构造方法将面积向量定义为构成该四边形的两个三角形的面积向量之和。问题指定使用连接顶点 $\\mathbf{p}_0$ 和 $\\mathbf{p}_2$ 的对角线进行三角剖分。这形成了两个三角形，$T_1$ 的顶点为 $(\\mathbf{p}_0, \\mathbf{p}_1, \\mathbf{p}_2)$，$T_2$ 的顶点为 $(\\mathbf{p}_0, \\mathbf{p}_2, \\mathbf{p}_3)$。\n\n一个三角形的有向面积向量由其两个边向量叉积的一半给出。对于 $T_1$，我们使用从 $\\mathbf{p}_0$ 出发的边向量，即 $(\\mathbf{p}_1 - \\mathbf{p}_0)$ 和 $(\\mathbf{p}_2 - \\mathbf{p}_0)$。其面积向量 $\\mathbf{A}_1$ 为：\n$$\n\\mathbf{A}_1 = \\frac{1}{2} (\\mathbf{p}_1 - \\mathbf{p}_0) \\times (\\mathbf{p}_2 - \\mathbf{p}_0)\n$$\n\n类似地，对于 $T_2$，我们使用边向量 $(\\mathbf{p}_2 - \\mathbf{p}_0)$ 和 $(\\mathbf{p}_3 - \\mathbf{p}_0)$。其面积向量 $\\mathbf{A}_2$ 为：\n$$\n\\mathbf{A}_2 = \\frac{1}{2} (\\mathbf{p}_2 - \\mathbf{p}_0) \\times (\\mathbf{p}_3 - \\mathbf{p}_0)\n$$\n\n总的基于三角剖分的面积向量 $\\mathbf{A}_{\\triangle}$ 是 $\\mathbf{A}_1$ 和 $\\mathbf{A}_2$ 的向量和：\n$$\n\\mathbf{A}_{\\triangle} = \\mathbf{A}_1 + \\mathbf{A}_2 = \\frac{1}{2} \\left[ (\\mathbf{p}_1 - \\mathbf{p}_0) \\times (\\mathbf{p}_2 - \\mathbf{p}_0) + (\\mathbf{p}_2 - \\mathbf{p}_0) \\times (\\mathbf{p}_3 - \\mathbf{p}_0) \\right]\n$$\n该公式提供了一个从顶点坐标直接计算 $\\mathbf{A}_{\\triangle}$ 的算法。\n\n**2. 基于拟合平面的面积向量 ($\\mathbf{A}_{\\mathrm{fit}}$) 的推导**\n\n这种构造方法涉及为四个顶点找到一个最佳拟合平面，然后计算该四边形在该平面上的投影面积。最终的面积向量是这个投影面积与平面单位法向量的乘积。\n\n**步骤 2.1：通过主成分分析 (PCA) 进行平面拟合**\n为了找到点集 $\\{\\mathbf{p}_i\\}_{i=0}^3$ 的最佳拟合平面，我们最小化这些点到平面的平方正交距离之和。这是 PCA 的一个经典应用。\n\n首先，我们计算顶点的形心：\n$$\n\\bar{\\mathbf{p}} = \\frac{1}{4} \\sum_{i=0}^{3} \\mathbf{p}_i\n$$\n\n接下来，我们找到去均值坐标（相对于形心的坐标）：\n$$\n\\mathbf{q}_i = \\mathbf{p}_i - \\bar{\\mathbf{p}}\n$$\n\n然后我们构建 $3 \\times 3$ 协方差矩阵（或散布矩阵）$C$：\n$$\nC = \\sum_{i=0}^{3} \\mathbf{q}_i \\mathbf{q}_i^T\n$$\n如果 $Q$ 是一个 $4 \\times 3$ 矩阵，其行是向量 $\\mathbf{q}_i^T$，则 $C = Q^T Q$。最佳拟合平面的单位法向量 $\\hat{\\mathbf{n}}$ 是 $C$ 对应于其最小特征值的单位特征向量。此特征向量表示点云的最小方差方向，该方向与最大方差平面正交。\n\n**步骤 2.2：法向量的定向**\n特征求解器将返回一个单位特征向量 $\\hat{\\mathbf{n}}_{\\text{eig}}$，但其方向（符号）是任意的。问题规定，必须选择符号以最大化点积 $\\hat{\\mathbf{n}} \\cdot \\mathbf{A}_{\\triangle}$。这确保了两种面积向量定义之间的一致性。我们首先计算 $\\mathbf{A}_{\\triangle}$ 和一个初始的 $\\hat{\\mathbf{n}}_{\\text{eig}}$。然后，正确定向的法向量 $\\hat{\\mathbf{n}}$ 确定如下：\n$$\n\\hat{\\mathbf{n}} = \\begin{cases} \\hat{\\mathbf{n}}_{\\text{eig}} & \\text{if } \\hat{\\mathbf{n}}_{\\text{eig}} \\cdot \\mathbf{A}_{\\triangle} \\ge 0 \\\\ -\\hat{\\mathbf{n}}_{\\text{eig}} & \\text{if } \\hat{\\mathbf{n}}_{\\text{eig}} \\cdot \\mathbf{A}_{\\triangle}  0 \\end{cases}\n$$\n\n**步骤 2.3：投影面积 ($A_{\\mathrm{proj}}$) 的计算**\n标量面积 $A_{\\mathrm{proj}}$ 是四边形在拟合平面上正交投影的有符号面积。为了计算它，我们为该平面建立一个二维正交基 $\\{\\mathbf{u}_1, \\mathbf{u}_2\\}$。一个稳健的基选择可以由协方差矩阵 $C$ 的其他特征向量构成。设对应于最大和中间特征值的单位特征向量分别为 $\\mathbf{e}_{\\text{large}}$ 和 $\\mathbf{e}_{\\text{mid}}$。我们可以设置 $\\mathbf{u}_1 = \\mathbf{e}_{\\text{large}}$，并通过定义 $\\mathbf{u}_2 = \\hat{\\mathbf{n}} \\times \\mathbf{u}_1$ 来形成一个右手坐标系 $\\{\\mathbf{u}_1, \\mathbf{u}_2, \\hat{\\mathbf{n}}\\}$。\n\n每个投影顶点在这个新基中（相对于形心）的二维坐标是：\n$$\n(u_i, v_i) = (\\mathbf{q}_i \\cdot \\mathbf{u}_1, \\mathbf{q}_i \\cdot \\mathbf{u}_2)\n$$\n\n生成的二维多边形 $\\{(u_0, v_0), (u_1, v_1), (u_2, v_2), (u_3, v_3)\\}$ 的有符号面积使用鞋带公式计算：\n$$\nA_{\\mathrm{proj}} = \\frac{1}{2} \\sum_{i=0}^{3} (u_i v_{i+1} - u_{i+1} v_i)\n$$\n其中索引 $4$ 被视为 $0$（即 $(u_4, v_4) = (u_0, v_0)$）。\n\n**步骤 2.4：组装 $\\mathbf{A}_{\\mathrm{fit}}$**\n最后，通过结合有符号标量面积和有向单位法向量来构造基于拟合平面的面积向量：\n$$\n\\mathbf{A}_{\\mathrm{fit}} = A_{\\mathrm{proj}} \\hat{\\mathbf{n}}\n$$\n\n**3. 差异量化**\n\n在计算出 $\\mathbf{A}_{\\triangle}$ 和 $\\mathbf{A}_{\\mathrm{fit}}$ 后，我们使用指定的度量指标来量化它们之间的差异。\n\n- 差的欧几里得范数：\n$$\n\\Delta = \\lVert \\mathbf{A}_{\\triangle} - \\mathbf{A}_{\\mathrm{fit}} \\rVert\n$$\n\n- 相对大小误差：\n$$\n\\varepsilon = \\frac{\\lVert \\mathbf{A}_{\\triangle} \\rVert - \\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}{\\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}\n$$\n计算此值的前提是 $\\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert \\neq 0$。\n\n- 向量之间的夹角，以弧度为单位：\n$$\n\\theta = \\arccos\\!\\left(\\frac{\\mathbf{A}_{\\triangle}\\cdot \\mathbf{A}_{\\mathrm{fit}}}{\\lVert \\mathbf{A}_{\\triangle} \\rVert \\,\\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}\\right)\n$$\n计算此值的前提是两个向量的模长均不为零。根据问题陈述，如果任一向量为零向量，我们定义 $\\theta = 0$。为确保数值稳定性，$\\arccos$ 的参数应被限制在 $[-1, 1]$ 范围内。\n\n这些步骤为解决该问题提供了一个完整而严谨的算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares two types of area vectors for quadrilateral faces\n    and prints the discrepancy metrics for a suite of test cases.\n    \"\"\"\n    # Test suite of four quadrilateral faces (each is a list of four vertices, in order).\n    # Vertices are given as lists of tuples and converted to numpy arrays.\n    test_cases_raw = [\n        [(0,0,0),(2,0,0),(2,1,0),(0,1,0)],\n        [(0,0,0),(1,0,0.1),(1,1,-0.1),(0,1,0)],\n        [(0,0,0),(2,0,0.5),(2,2,-0.6),(0,2,0.4)],\n        [(0,0,0),(1e-6,0,0),(1e-6,1,0),(0,1,0)],\n    ]\n    test_cases = [np.array(case, dtype=float) for case in test_cases_raw]\n\n    results = []\n    for quad_vertices in test_cases:\n        # --- 1. Compute Triangulation-based Area Vector (A_triangle) ---\n        p0, p1, p2, p3 = quad_vertices[0], quad_vertices[1], quad_vertices[2], quad_vertices[3]\n\n        # Note: The problem states triangulation split is (p0,p1,p2) and (p0,p2,p3).\n        # The cross products are for edges emanating from a common vertex.\n        # Triangle 1: (p0, p1, p2), edges: (p1-p0), (p2-p0)\n        # Triangle 2: (p0, p2, p3), edges: (p2-p0), (p3-p0)\n        # A_triangle = 0.5 * (cross(p1-p0, p2-p0) + cross(p2-p0, p3-p0))\n        # The sum of vector areas is what's required.\n        \n        vec1 = p1 - p0\n        vec2 = p2 - p0\n        vec3 = p3 - p0\n\n        area_vec1 = 0.5 * np.cross(vec1, vec2)\n        area_vec2 = 0.5 * np.cross(vec2, vec3)\n        A_triangle = area_vec1 + area_vec2\n\n        # --- 2. Compute Fitted-plane-based Area Vector (A_fit) ---\n\n        # 2.1. Plane Fitting via PCA\n        centroid = np.mean(quad_vertices, axis=0)\n        demeaned_pts = quad_vertices - centroid\n        \n        # Covariance matrix C = Q^T Q, where Q is the 4x3 matrix of demeaned points\n        cov_matrix = demeaned_pts.T @ demeaned_pts\n        \n        # eigh for symmetric matrices; returns eigenvalues in ascending order\n        eigenvalues, eigenvectors = np.linalg.eigh(cov_matrix)\n        \n        # The normal is the eigenvector for the smallest eigenvalue\n        n_eig = eigenvectors[:, 0]\n\n        # 2.2. Orient the Normal Vector\n        if np.dot(n_eig, A_triangle)  0:\n            n_hat = -n_eig\n        else:\n            n_hat = n_eig\n\n        # 2.3. Calculate Projected Area (A_proj)\n        # Form an orthonormal basis for the plane\n        u1_eig = eigenvectors[:, 2]  # Eigenvector for largest eigenvalue\n        u1 = u1_eig / np.linalg.norm(u1_eig)\n        u2 = np.cross(n_hat, u1) # Guarantees a right-handed system {u1, u2, n_hat}\n\n        # Project demeaned points onto the 2D basis\n        coords_2d = np.array([(np.dot(q, u1), np.dot(q, u2)) for q in demeaned_pts])\n        u, v = coords_2d[:, 0], coords_2d[:, 1]\n        \n        # Shoelace formula for signed area of projected 2D polygon\n        A_proj = 0.5 * (u[0]*v[1] - u[1]*v[0] + \n                         u[1]*v[2] - u[2]*v[1] + \n                         u[2]*v[3] - u[3]*v[2] + \n                         u[3]*v[0] - u[0]*v[3])\n\n        # 2.4. Assemble A_fit\n        A_fit = A_proj * n_hat\n\n        # --- 3. Quantify Discrepancy ---\n        \n        # Delta: Euclidean norm of the difference\n        delta = np.linalg.norm(A_triangle - A_fit)\n\n        # Epsilon: Relative magnitude error\n        norm_A_triangle = np.linalg.norm(A_triangle)\n        norm_A_fit = np.linalg.norm(A_fit)\n        \n        if np.isclose(norm_A_fit, 0.0):\n            # If fitted area is zero, relative error is infinite if triangle area is non-zero\n            epsilon = np.inf if not np.isclose(norm_A_triangle, 0.0) else 0.0\n        else:\n            epsilon = (norm_A_triangle - norm_A_fit) / norm_A_fit\n\n        # Theta: Angle between vectors\n        if np.isclose(norm_A_triangle, 0.0) or np.isclose(norm_A_fit, 0.0):\n            theta = 0.0\n        else:\n            dot_product = np.dot(A_triangle, A_fit)\n            # Clip for numerical stability to prevent arccos domain errors\n            cos_theta = np.clip(dot_product / (norm_A_triangle * norm_A_fit), -1.0, 1.0)\n            theta = np.arccos(cos_theta)\n\n        results.append([delta, epsilon, theta])\n\n    # Final print statement in the exact required format.\n    # The format requires a string representation of a list of lists.\n    results_str = ','.join([f\"[{d},{e},{t}]\" for d, e, t in results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现代的大规模CFD模拟通常在并行计算集群上进行。本练习探讨了一个关键的系统级挑战：如何在跨子域边界的情况下确保全局守恒性。您将通过此练习理解为什么不一致的面法线方向会导致错误的通量计算（例如通量的重复计算），并设计一种分布式算法来强制实现全局一致性，这是开发可靠并行CFD代码的一项核心技能。",
            "id": "3297310",
            "problem": "考虑一个可压缩流体的线性动量守恒的有限体积离散化。穿过一个面的净对流动量通量是通过在该面上对质量通量与速度的乘积进行积分得到的。对于一个平面，这简化为计算一个标量质量通量，然后将一个动量通量矢量与该面关联起来。为任意面 $f$ 定义以下物理量：面上的流体速度矢量 $\\mathbf{u}_f \\in \\mathbb{R}^3$（单位：$\\mathrm{m/s}$），面上的流体密度 $\\rho_f$（单位：$\\mathrm{kg/m^3}$），面面积 $A_f$（单位：$\\mathrm{m^2}$），以及指向相对于局部控制体外部的单位面法向量 $\\mathbf{n}_f$。通过该面的质量通量大小为 $\\dot{m}_f = \\rho_f \\, (\\mathbf{u}_f \\cdot \\mathbf{n}_f) \\, A_f$（单位：$\\mathrm{kg/s}$），相关的对流动量通量矢量为 $\\mathbf{F}_f = \\dot{m}_f \\, \\mathbf{u}_f$（单位：$\\mathrm{N}$）。\n\n在并行区域分解中，内部面在子域边界上被复制：每个子域都拥有共享面的副本及其自身的向外单位法线，对于相邻的子域 $i$ 和 $j$，这导致了 $\\mathbf{n}_f^{(i)}$ 和 $\\mathbf{n}_f^{(j)}$，通常满足 $\\mathbf{n}_f^{(j)} = - \\mathbf{n}_f^{(i)}$。一种朴素的全局动量通量聚合方法，即对所有子域边界面上的 $\\|\\mathbf{F}_f\\|$ 大小求和，如果方向没有全局一致且副本没有被抑制，可能会导致内部面的重复计算。这违反了散度定理和守恒定律所隐含的内部贡献应相互抵消的原则。\n\n您的任务是：\n- 从散度定理和动量守恒的积分形式出发，解释为什么在对子域求和时，如果面法线方向一致且副本得到协调，内部共享面对跨越全局外部边界的净动量通量没有贡献。特别地，推导为确保全局求和中内部对流动量通量贡献相抵消，跨内部面的面法线方向必须满足的条件。\n- 对于三角形面，推导如何使用右手定则从有序顶点位置 $\\mathbf{x}_0$、$\\mathbf{x}_1$、$\\mathbf{x}_2 \\in \\mathbb{R}^3$ 计算规范单位法向量 $\\widehat{\\mathbf{n}}_f$，并计算面面积 $A_f$。\n- 展示不一致的方向和朴素的大小聚合如何导致跨内部面的动量通量被重复计算。\n- 设计一个分布式算法，该算法能保证全局法线方向的一致性，并以最少的相邻子域间通信来抑制重复计算。您的算法必须基于由全局唯一顶点标识符构建的规范面标识符、每个共享面的确定性归属规则，以及一个翻转 $\\mathbf{n}_f$ 符号以匹配规范方向的局部操作。\n\n然后实现一个程序，该程序：\n- 模拟三个子域分解的测试场景，其中三角形面由其顶点坐标（单位：$\\mathrm{m}$）、全局顶点标识符（整数）、每个子域侧的局部向外法线方向（相对于规范方向的符号 $+1$ 或 $-1$）以及均匀的面中心流体状态 $(\\rho_f, \\mathbf{u}_f)$ 指定。\n- 对于每个场景，通过对所有子域边界面（包括两侧的内部共享面）上的 $\\|\\mathbf{F}_f\\|$ 求和，计算朴素的全局总动量通量大小（单位：$\\mathrm{N}$）。\n- 在一致性方向下，通过仅对外部边界面上的 $\\|\\mathbf{F}_f\\|$ 求和（不包括内部共享面），计算正确的全局总动量通量大小（单位：$\\mathrm{N}$）。\n- 应用您的算法以消除重复计算并将局部法线与规范方向对齐，并重新计算修正后的朴素全局总动量通量大小（单位：$\\mathrm{N}$），该值应与正确的全局总动量通量大小相匹配。\n- 报告应用算法前的重复计算内部面数量、朴素的全局总动量通量大小（单位：$\\mathrm{N}$）、正确的全局总动量通量大小（单位：$\\mathrm{N}$）、朴素总和与正确总和之间的绝对误差（单位：$\\mathrm{N}$）、应用算法后的重复计算内部面数量、修正后的朴素全局总动量通量大小（单位：$\\mathrm{N}$）以及修正后的绝对误差（单位：$\\mathrm{N}$）。所有通量大小和误差必须以 $\\mathrm{N}$ 为单位报告，并四舍五入到六位小数。\n\n需要使用的基本原理和定义：\n- 对于控制体积 $\\Omega$ 及其边界 $\\partial \\Omega$ 上的向量场 $\\mathbf{g}$，散度定理为：$\\int_{\\Omega} \\nabla \\cdot \\mathbf{g} \\, dV = \\int_{\\partial \\Omega} \\mathbf{g} \\cdot \\mathbf{n} \\, dS$。\n- 将边界上的净通量与体积内动量变化及外力联系起来的动量守恒积分形式。\n- 对于具有有序顶点 $\\mathbf{x}_0$、$\\mathbf{x}_1$、$\\mathbf{x}_2$ 的三角形面，规范（右手定则）单位法线为 $\\widehat{\\mathbf{n}}_f = \\dfrac{(\\mathbf{x}_1 - \\mathbf{x}_0) \\times (\\mathbf{x}_2 - \\mathbf{x}_0)}{\\left\\|(\\mathbf{x}_1 - \\mathbf{x}_0) \\times (\\mathbf{x}_2 - \\mathbf{x}_0)\\right\\|}$，面积为 $A_f = \\dfrac{1}{2} \\left\\|(\\mathbf{x}_1 - \\mathbf{x}_0) \\times (\\mathbf{x}_2 - \\mathbf{x}_0)\\right\\|$。\n\n测试套件规范：\n- 场景1（两个子域，各有一个内部面和一个外部面）：\n    - 共享内部面 $f_{\\mathrm{int}}$：顶点 $\\mathbf{x}_0 = (0,0,0)$、$\\mathbf{x}_1 = (1,0,0)$、$\\mathbf{x}_2 = (0,1,0)$，顶点标识符 $(0,1,2)$。子域0侧：局部符号 $+1$，$\\rho_f = 1\\,\\mathrm{kg/m^3}$，$\\mathbf{u}_f = (0,0,2)\\,\\mathrm{m/s}$，内部面。子域1侧：局部符号 $-1$，$\\rho_f = 1\\,\\mathrm{kg/m^3}$，$\\mathbf{u}_f = (0,0,2)\\,\\mathrm{m/s}$，内部面。\n    - 子域0的外部面：顶点 $\\mathbf{x}_0 = (0,0,1)$、$\\mathbf{x}_1 = (1,0,1)$、$\\mathbf{x}_2 = (0,1,1)$，顶点标识符 $(3,4,5)$，局部符号 $+1$，$\\rho_f = 1\\,\\mathrm{kg/m^3}$，$\\mathbf{u}_f = (0,0,2)\\,\\mathrm{m/s}$，外部面。\n    - 子域1的外部面：顶点 $\\mathbf{x}_0 = (0,0,2)$、$\\mathbf{x}_1 = (1,0,2)$、$\\mathbf{x}_2 = (0,1,2)$，顶点标识符 $(6,7,8)$，局部符号 $+1$，$\\rho_f = 1\\,\\mathrm{kg/m^3}$，$\\mathbf{u}_f = (0,0,2)\\,\\mathrm{m/s}$，外部面。\n- 场景2（两个子域，各有一个与流向正交的内部面和一个外部面）：\n    - 共享内部面 $f_{\\mathrm{int}}$：顶点 $\\mathbf{x}_0 = (0,0,0)$、$\\mathbf{x}_1 = (1,0,0)$、$\\mathbf{x}_2 = (0,1,0)$，顶点标识符 $(0,1,2)$。子域0侧：局部符号 $+1$，$\\rho_f = 1\\,\\mathrm{kg/m^3}$，$\\mathbf{u}_f = (2,0,0)\\,\\mathrm{m/s}$，内部面。子域1侧：局部符号 $-1$，$\\rho_f = 1\\,\\mathrm{kg/m^3}$，$\\mathbf{u}_f = (2,0,0)\\,\\mathrm{m/s}$，内部面。\n    - 子域0的外部面：顶点 $\\mathbf{x}_0 = (0,0,0)$、$\\mathbf{x}_1 = (0,1,0)$、$\\mathbf{x}_2 = (0,0,1)$，顶点标识符 $(10,11,12)$，局部符号 $+1$，$\\rho_f = 1\\,\\mathrm{kg/m^3}$，$\\mathbf{u}_f = (2,0,0)\\,\\mathrm{m/s}$，外部面。\n    - 子域1的外部面：顶点 $\\mathbf{x}_0 = (0,0,0)$、$\\mathbf{x}_1 = (0,1,0)$、$\\mathbf{x}_2 = (0,0,1)$，顶点标识符 $(13,14,15)$，局部符号 $+1$，$\\rho_f = 1\\,\\mathrm{kg/m^3}$，$\\mathbf{u}_f = (2,0,0)\\,\\mathrm{m/s}$，外部面。\n- 场景3（三个子域呈链状排列，有两个内部面和外部面）：\n    - 子域0和1之间的共享内部面 $f_{01}$：顶点 $\\mathbf{x}_0 = (0,0,0)$、$\\mathbf{x}_1 = (0,0,1)$、$\\mathbf{x}_2 = (1,0,0)$，顶点标识符 $(20,21,22)$。子域0侧：局部符号 $+1$，$\\rho_f = 1\\,\\mathrm{kg/m^3}$，$\\mathbf{u}_f = (0,3,0)\\,\\mathrm{m/s}$，内部面。子域1侧：局部符号 $-1$，$\\rho_f = 1\\,\\mathrm{kg/m^3}$，$\\mathbf{u}_f = (0,3,0)\\,\\mathrm{m/s}$，内部面。\n    - 子域1和2之间的共享内部面 $f_{12}$：顶点 $\\mathbf{x}_0 = (0,0,0)$、$\\mathbf{x}_1 = (0,1,0)$、$\\mathbf{x}_2 = (0,0,1)$，顶点标识符 $(23,24,25)$。子域1侧：局部符号 $+1$，$\\rho_f = 1\\,\\mathrm{kg/m^3}$，$\\mathbf{u}_f = (4,0,0)\\,\\mathrm{m/s}$，内部面。子域2侧：局部符号 $-1$，$\\rho_f = 1\\,\\mathrm{kg/m^3}$，$\\mathbf{u}_f = (4,0,0)\\,\\mathrm{m/s}$，内部面。\n    - 子域0的外部面：顶点 $\\mathbf{x}_0 = (0,0,0)$、$\\mathbf{x}_1 = (1,0,0)$、$\\mathbf{x}_2 = (0,1,0)$，顶点标识符 $(30,31,32)$，局部符号 $+1$，$\\rho_f = 1\\,\\mathrm{kg/m^3}$，$\\mathbf{u}_f = (0,0,2)\\,\\mathrm{m/s}$，外部面。\n    - 子域1的外部面：顶点 $\\mathbf{x}_0 = (0,0,1)$、$\\mathbf{x}_1 = (1,0,1)$、$\\mathbf{x}_2 = (0,1,1)$，顶点标识符 $(33,34,35)$，局部符号 $+1$，$\\rho_f = 1\\,\\mathrm{kg/m^3}$，$\\mathbf{u}_f = (0,0,1)\\,\\mathrm{m/s}$，外部面。\n    - 子域2的外部面：顶点 $\\mathbf{x}_0 = (0,0,0)$、$\\mathbf{x}_1 = (0,1,0)$、$\\mathbf{x}_2 = (0,0,1)$，顶点标识符 $(36,37,38)$，局部符号 $+1$，$\\rho_f = 1\\,\\mathrm{kg/m^3}$，$\\mathbf{u}_f = (2,0,0)\\,\\mathrm{m/s}$，外部面。\n\n您的程序应生成单行输出，其中包含三个场景的结果，格式为方括号内包含的逗号分隔列表，其中每个场景的结果是一个列表，顺序如下：\n$[\\text{算法前重复计算的面数}, \\text{朴素总通量大小_N}, \\text{正确总通量大小_N}, \\text{误差_N}, \\text{算法后重复计算的面数}, \\text{修正后的朴素总通量大小_N}, \\text{修正后的误差_N}]$。\n所有通量值必须以 $\\mathrm{N}$ 为单位，并四舍五入到六位小数。例如，输出格式应如下所示：$[[a_1,b_1,c_1,d_1,e_1,f_1,g_1],[a_2,b_2,c_2,d_2,e_2,f_2,g_2],[a_3,b_3,c_3,d_3,e_3,f_3,g_3]]$，其中 $a_i$ 为整数， $b_i,c_i,d_i,f_i,g_i$ 为浮点数。不应打印任何其他文本。",
            "solution": "该问题是有效的，因为它在科学上基于流体动力学和矢量微积分的原理，问题阐述清晰、客观，并为理论推导和计算实现提供了完整且一致的设置。\n\n### 理论基础与算法设计\n\n**1. 基于散度定理的内部通量抵消**\n\n由雷诺输运定理推导出的守恒定律积分形式，将控制体积 $\\Omega$ 内某物理量的变化率与穿过其边界 $\\partial \\Omega$ 的该物理量的净通量联系起来。对于流体中的线性动量守恒，假设没有体积力，其表达式为：\n$$\n\\frac{\\partial}{\\partial t} \\int_{\\Omega} \\rho \\mathbf{u} \\, dV + \\int_{\\partial \\Omega} (\\rho \\mathbf{u} \\otimes \\mathbf{u}) \\cdot \\mathbf{n} \\, dS = \\int_{\\partial \\Omega} \\boldsymbol{\\sigma} \\cdot \\mathbf{n} \\, dS\n$$\n其中 $\\rho$ 是流体密度，$\\mathbf{u}$ 是速度矢量，$\\mathbf{n}$ 是指向面元 $dS$ 外部的单位法向量，$\\boldsymbol{\\sigma}$ 代表应力张量。项 $\\int_{\\partial \\Omega} (\\rho \\mathbf{u} \\otimes \\mathbf{u}) \\cdot \\mathbf{n} \\, dS$ 表示离开体积 $\\Omega$ 的对流动量通量的净速率。本问题关注此对流项。\n\n在用于并行计算的区域分解方法中，全局计算域 $\\Omega$ 被划分为不重叠的子域 $\\Omega_i$，使得 $\\Omega = \\bigcup_i \\Omega_i$。应用散度定理，穿过全局边界 $\\partial\\Omega$ 的总通量可以表示为所有子域边界 $\\partial\\Omega_i$ 上通量的总和：\n$$\n\\int_{\\partial \\Omega} (\\rho \\mathbf{u} \\otimes \\mathbf{u}) \\cdot \\mathbf{n} \\, dS = \\sum_i \\int_{\\Omega_i} \\nabla \\cdot (\\rho \\mathbf{u} \\otimes \\mathbf{u}) \\, dV = \\sum_i \\int_{\\partial \\Omega_i} (\\rho \\mathbf{u} \\otimes \\mathbf{u}) \\cdot \\mathbf{n}^{(i)} \\, dS\n$$\n其中 $\\mathbf{n}^{(i)}$ 是子域 $\\Omega_i$ 的向外单位法向量。\n\n每个子域的边界 $\\partial\\Omega_i$ 由两部分组成：与全局边界 $\\partial\\Omega$ 重合的外部面，以及与相邻子域 $\\Omega_j$ 共享的内部面。设 $f_{ij}$ 是子域 $\\Omega_i$ 和 $\\Omega_j$ 之间共享的内部面。这个面在边界求和中出现两次：一次作为 $\\partial\\Omega_i$ 的一部分，一次作为 $\\partial\\Omega_j$ 的一部分。该面对全局总和的总贡献为：\n$$\n\\int_{f_{ij}} (\\rho \\mathbf{u} \\otimes \\mathbf{u}) \\cdot \\mathbf{n}^{(i)} \\, dS + \\int_{f_{ij}} (\\rho \\mathbf{u} \\otimes \\mathbf{u}) \\cdot \\mathbf{n}^{(j)} \\, dS\n$$\n为了使所有子域上的总和能正确地简化为仅在全局外部边界上的积分，所有内部面的贡献总和必须为零。由于无论从哪个子域考虑，面 $f_{ij}$ 上的流体状态 $(\\rho, \\mathbf{u})$ 都被认为是相同的，因此抵消的条件是纯几何的：子域 $\\Omega_i$ 的向外法线必须与子域 $\\Omega_j$ 的向外法线完全相反。\n$$\n\\mathbf{n}^{(i)} = - \\mathbf{n}^{(j)}\n$$\n如果所有内部面都满足此条件，那么对于每个共享面 $f_{ij}$，两个通量积分大小相等，符号相反，其和为零。全局总和随后正确地缩减为仅包含来自真实外部边界 $\\partial\\Omega$ 的贡献。\n\n在离散有限体积公式中，对于一个面积为 $A_f$ 且流体状态 $(\\rho_f, \\mathbf{u}_f)$ 恒定的平面 $f$，对流动量通量矢量为 $\\mathbf{F}_f = \\dot{m}_f \\mathbf{u}_f$，其中质量通量为 $\\dot{m}_f = \\rho_f (\\mathbf{u}_f \\cdot \\mathbf{n}_f) A_f$。如果一个内部面被法线 $\\mathbf{n}_f^{(i)}$ 和 $\\mathbf{n}_f^{(j)} = -\\mathbf{n}_f^{(i)}$ 表示两次，则各自的动量通量为：\n$$\n\\mathbf{F}_f^{(i)} = \\rho_f A_f (\\mathbf{u}_f \\cdot \\mathbf{n}_f^{(i)}) \\mathbf{u}_f\n$$\n$$\n\\mathbf{F}_f^{(j)} = \\rho_f A_f (\\mathbf{u}_f \\cdot \\mathbf{n}_f^{(j)}) \\mathbf{u}_f = \\rho_f A_f (\\mathbf{u}_f \\cdot (-\\mathbf{n}_f^{(i)})) \\mathbf{u}_f = - \\mathbf{F}_f^{(i)}\n$$\n它们的矢量和为 $\\mathbf{F}_f^{(i)} + \\mathbf{F}_f^{(j)} = \\mathbf{0}$，确保了正确的抵消。\n\n**2. 三角形面的规范法线和面积**\n\n给定一个由三个有序顶点 $\\mathbf{x}_0$、$\\mathbf{x}_1$ 和 $\\mathbf{x}_2$ 在 $\\mathbb{R}^3$ 中定义的三角形面，我们可以从 $\\mathbf{x}_0$ 出发定义两个边向量：\n$$\n\\mathbf{v}_1 = \\mathbf{x}_1 - \\mathbf{x}_0 \\quad \\text{和} \\quad \\mathbf{v}_2 = \\mathbf{x}_2 - \\mathbf{x}_0\n$$\n这两个向量的叉积产生一个垂直于三角形所在平面的向量 $\\mathbf{N}$：\n$$\n\\mathbf{N} = \\mathbf{v}_1 \\times \\mathbf{v}_2\n$$\n$\\mathbf{N}$ 的方向由应用于有序向量 $\\mathbf{v}_1$ 和 $\\mathbf{v}_2$ 的右手定则确定。该向量的大小 $\\|\\mathbf{N}\\|$ 等于三角形面积 $A_f$ 的两倍。因此，面积为：\n$$\nA_f = \\frac{1}{2} \\|\\mathbf{N}\\| = \\frac{1}{2} \\|(\\mathbf{x}_1 - \\mathbf{x}_0) \\times (\\mathbf{x}_2 - \\mathbf{x}_0)\\|\n$$\n基于此顶点排序的规范单位法向量 $\\widehat{\\mathbf{n}}_f$ 是通过归一化 $\\mathbf{N}$ 得到的：\n$$\n\\widehat{\\mathbf{n}}_f = \\frac{\\mathbf{N}}{\\|\\mathbf{N}\\|} = \\frac{(\\mathbf{x}_1 - \\mathbf{x}_0) \\times (\\mathbf{x}_2 - \\mathbf{x}_0)}{\\|(\\mathbf{x}_1 - \\mathbf{x}_0) \\times (\\mathbf{x}_2 - \\mathbf{x}_0)\\|}\n$$\n\n**3. 朴素大小聚合的误差**\n\n“朴素聚合”方法被定义为对所有子域的所有边界面上的动量通量矢量大小 $\\|\\mathbf{F}_f\\|$ 进行求和。对于一个由子域 $i$ 和 $j$ 共享的内部面，即使法线方向正确配置使得 $\\mathbf{F}_f^{(j)} = -\\mathbf{F}_f^{(i)}$，它们的大小也是相等的：\n$$\n\\|\\mathbf{F}_f^{(j)}\\| = \\|-\\mathbf{F}_f^{(i)}\\| = \\|\\mathbf{F}_f^{(i)}\\|\n$$\n朴素求和将包含项 $\\|\\mathbf{F}_f^{(i)}\\| + \\|\\mathbf{F}_f^{(j)}\\| = 2\\|\\mathbf{F}_f^{(i)}\\|$。这个贡献是非零的，而内部面对全局边界通量求和的正确贡献必须为零。这种未能抵消的现象导致了大小被加了两次，这就是“重复计算”误差。此过程违反了守恒原理，因为它错误地将内部通量添加到一个只应反映与全局域外部交换的量上。\n\n**4. 用于一致性聚合的分布式算法**\n\n为纠正朴素聚合，需要一个分布式算法来确保内部面的贡献得到正确处理。目标是实现面对方向的全局一致视图，并抑制在全局求和中内部通量的重复计算。\n\n该算法按以下步骤进行，在每个子域上本地执行：\n1.  **规范识别**：对于每个边界面，子域计算一个全局唯一的、与方向无关的标识符。由于每个顶点都有一个全局唯一的整数ID，可以通过创建其顶点全局ID的排序元组来构建一个规范面标识符。对于一个顶点ID为 $\\{id_0, id_1, id_2\\}$ 的三角形面，其规范ID为 `tuple(sorted((id_0, id_1, id_2)))`。这确保了共享一个面的两个子域都会为其计算出完全相同的标识符。\n\n2.  **通信与分类**：在真实的并行环境中，子域会与其相邻子域交换它们边界面的规范ID。通过比较交换来的列表，子域可以对其每个边界面进行分类：\n    *   **外部面**：该面的规范ID与任何邻居的面ID都不匹配。\n    *   **内部面**：该面的规范ID与某个邻居的面ID相匹配。\n\n3.  **确定性归属与法线对齐**：对于每个识别出的内部面，必须有一个确定性规则来决定两个子域中哪一个“拥有”该面。一个简单而稳健的规则是将所有权分配给具有最小秩（或进程ID）的子域。对于子域 $i$ 和 $j$ 共享的面，所有者是 $\\min(i, j)$。虽然法线对齐对于矢量求和至关重要（所有者可以强制执行一个规范方向，例如，基于排序的顶点坐标，而非所有者则强制执行反平行方向），但对于大小求和问题是无关紧要的，因为 $\\|\\mathbf{F}\\|=\\|-\\mathbf{F}\\|$。\n\n4.  **通量抑制**：纠正朴素大小求和的关键是抑制来自内部面的贡献。在计算全局边界量时，每个子域应用以下局部规则：\n    *   如果一个面被分类为“外部面”，其动量通量大小 $\\|\\mathbf{F}_f\\|$ 被包含在总和中。\n    *   如果一个面被分类为“内部面”，其对总和的贡献为零。\n这实际上意味着，为了全局边界求和的目的，内部面的两个副本都被忽略了。\n\n“修正后的朴素和”是这些局部计算值的全局聚合。这个总和将只包含来自外部面的贡献，因此将与“正确的全局总动量通量大小”（定义为仅对外部面求和）相同。此过程正确地消除了“重复计算”误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational fluid dynamics problem for three scenarios.\n    \"\"\"\n\n    class Face:\n        \"\"\"\n        Represents a triangular face in a subdomain.\n        \"\"\"\n        def __init__(self, subdomain_id, vertices, vertex_ids, local_sign, rho, u, face_type):\n            self.subdomain_id = int(subdomain_id)\n            self.vertices = np.array(vertices, dtype=float)\n            self.vertex_ids = tuple(vertex_ids)\n            self.local_sign = int(local_sign)\n            self.rho = float(rho)\n            self.u = np.array(u, dtype=float)\n            self.face_type = face_type\n            \n            self.canonical_id = tuple(sorted(self.vertex_ids))\n            \n            self.area = 0.0\n            self.n_hat_ordered = np.zeros(3)\n            self.n_local = np.zeros(3)\n            self.F = np.zeros(3)\n            self.F_mag = 0.0\n            \n            self._compute_geometry()\n            self._compute_flux()\n\n        def _compute_geometry(self):\n            \"\"\"Computes face area and normal vectors.\"\"\"\n            x0, x1, x2 = self.vertices\n            v1 = x1 - x0\n            v2 = x2 - x0\n            cross_prod = np.cross(v1, v2)\n            norm_cross_prod = np.linalg.norm(cross_prod)\n            \n            if norm_cross_prod > 1e-12:\n                self.area = 0.5 * norm_cross_prod\n                self.n_hat_ordered = cross_prod / norm_cross_prod\n            \n            self.n_local = self.local_sign * self.n_hat_ordered\n\n        def _compute_flux(self):\n            \"\"\"Computes the momentum flux vector and its magnitude.\"\"\"\n            if self.area > 1e-12:\n                m_dot = self.rho * np.dot(self.u, self.n_local) * self.area\n                self.F = m_dot * self.u\n                self.F_mag = np.linalg.norm(self.F)\n\n    test_cases = [\n        # Scenario 1 Data\n        [\n            # subdomain_id, vertices, vertex_ids, local_sign, rho, u, face_type\n            (0, [(0,0,0), (1,0,0), (0,1,0)], (0,1,2), 1, 1.0, (0,0,2), 'internal'),\n            (1, [(0,0,0), (1,0,0), (0,1,0)], (0,1,2), -1, 1.0, (0,0,2), 'internal'),\n            (0, [(0,0,1), (1,0,1), (0,1,1)], (3,4,5), 1, 1.0, (0,0,2), 'external'),\n            (1, [(0,0,2), (1,0,2), (0,1,2)], (6,7,8), 1, 1.0, (0,0,2), 'external'),\n        ],\n        # Scenario 2 Data\n        [\n            (0, [(0,0,0), (1,0,0), (0,1,0)], (0,1,2), 1, 1.0, (2,0,0), 'internal'),\n            (1, [(0,0,0), (1,0,0), (0,1,0)], (0,1,2), -1, 1.0, (2,0,0), 'internal'),\n            (0, [(0,0,0), (0,1,0), (0,0,1)], (10,11,12), 1, 1.0, (2,0,0), 'external'),\n            (1, [(0,0,0), (0,1,0), (0,0,1)], (13,14,15), 1, 1.0, (2,0,0), 'external'),\n        ],\n        # Scenario 3 Data\n        [\n            (0, [(0,0,0), (0,0,1), (1,0,0)], (20,21,22), 1, 1.0, (0,3,0), 'internal'),\n            (1, [(0,0,0), (0,0,1), (1,0,0)], (20,21,22), -1, 1.0, (0,3,0), 'internal'),\n            (1, [(0,0,0), (0,1,0), (0,0,1)], (23,24,25), 1, 1.0, (4,0,0), 'internal'),\n            (2, [(0,0,0), (0,1,0), (0,0,1)], (23,24,25), -1, 1.0, (4,0,0), 'internal'),\n            (0, [(0,0,0), (1,0,0), (0,1,0)], (30,31,32), 1, 1.0, (0,0,2), 'external'),\n            (1, [(0,0,1), (1,0,1), (0,1,1)], (33,34,35), 1, 1.0, (0,0,1), 'external'),\n            (2, [(0,0,0), (0,1,0), (0,0,1)], (36,37,38), 1, 1.0, (2,0,0), 'external'),\n        ]\n    ]\n\n    results = []\n    for scenario_data in test_cases:\n        all_faces = [Face(*params) for params in scenario_data]\n\n        # --- Pre-algorithm calculations ---\n\n        # 1. Count double-counted internal faces\n        num_internal_instances = sum(1 for face in all_faces if face.face_type == 'internal')\n        double_counted_before = num_internal_instances // 2\n\n        # 2. Naive global total momentum flux magnitude\n        naive_total_flux_N = sum(face.F_mag for face in all_faces)\n\n        # 3. Correct global total momentum flux magnitude (sum over external faces only)\n        correct_total_flux_N = sum(face.F_mag for face in all_faces if face.face_type == 'external')\n\n        # 4. Absolute error\n        error_N = abs(naive_total_flux_N - correct_total_flux_N)\n\n        # --- Post-algorithm calculations ---\n        # The algorithm suppresses contributions from internal faces.\n        \n        # 5. Number of double-counted faces after suppression\n        double_counted_after = 0\n        \n        # 6. Corrected naive global total momentum flux magnitude\n        # This sum now applies the suppression rule: only include external faces.\n        corrected_total_flux_N = sum(face.F_mag for face in all_faces if face.face_type == 'external')\n\n        # 7. Corrected absolute error\n        corrected_error_N = abs(corrected_total_flux_N - correct_total_flux_N)\n\n        scenario_result = [\n            double_counted_before,\n            round(naive_total_flux_N, 6),\n            round(correct_total_flux_N, 6),\n            round(error_N, 6),\n            double_counted_after,\n            round(corrected_total_flux_N, 6),\n            round(corrected_error_N, 6)\n        ]\n        results.append(scenario_result)\n\n    # Final print statement in the exact required format.\n    print(str(results).replace(\" \", \"\"))\n\n\nsolve()\n```"
        }
    ]
}