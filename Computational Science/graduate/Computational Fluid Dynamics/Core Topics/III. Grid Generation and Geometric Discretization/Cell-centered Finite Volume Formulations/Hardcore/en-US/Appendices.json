{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of any reliable computational fluid dynamics (CFD) solver is rigorous verification. This exercise guides you through the Method of Manufactured Solutions (MMS), a powerful technique to confirm that your code is free of bugs and achieves its designed order of accuracy. By implementing a complete cell-centered finite volume solver for the unsteady Navier-Stokes equations and testing it against a known analytical solution, you will gain fundamental skills in code verification essential for any serious CFD practitioner .",
            "id": "3297768",
            "problem": "You are asked to design and implement a Method of Manufactured Solutions (MMS) verification test for the unsteady incompressible Navier–Stokes equations in a cell-centered finite volume framework on a two-dimensional periodic unit square. Your task is to select an analytic velocity–pressure pair, derive the corresponding body-force source terms and boundary conditions, and then compute the observed order of accuracy by applying the fully discrete operator to the analytic fields and measuring the discrete residual scaling with refinement.\n\nThe fundamental base is the unsteady incompressible Navier–Stokes system on a domain $\\Omega = [0,1]\\times[0,1]$ with periodic boundary conditions in both directions:\n- Momentum: $\\dfrac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nu \\nabla^2 \\boldsymbol{u} = \\boldsymbol{f}$,\n- Continuity: $\\nabla\\cdot\\boldsymbol{u} = 0$,\nwhere $\\boldsymbol{u}=(u,v)$ is the velocity, $p$ is the pressure divided by density, $\\nu$ is the kinematic viscosity, and $\\boldsymbol{f}=(f_u,f_v)$ is a body force. Trigonometric function arguments are in radians.\n\nProceed as follows.\n\n1) Manufactured fields and boundary conditions:\n- Select a streamfunction $\\psi(x,y,t)$ of the form $\\psi(x,y,t) = A \\sin(k x)\\sin(k y)\\cos(\\omega t)$, with $A0$, $k = 2\\pi$, and $\\omega = 2\\pi$; define the manufactured velocity by $\\boldsymbol{u} = (\\partial\\psi/\\partial y,\\ -\\partial\\psi/\\partial x)$, and the manufactured pressure by $p(x,y,t) = P\\cos(k x)\\cos(k y)\\sin(\\omega t)$ with $P0$. This construction enforces $\\nabla\\cdot\\boldsymbol{u} = 0$ identically.\n- Derive the source terms $\\boldsymbol{f}(x,y,t)$ by substituting $(\\boldsymbol{u},p)$ into the momentum equation and rearranging to isolate $\\boldsymbol{f}$. Specify the boundary conditions compatible with the choice; use periodic boundaries in both $x$ and $y$ since the fields are $1$-periodic.\n\n2) Cell-centered finite volume discretization:\n- Use a uniform $N\\times N$ cell-centered grid covering $\\Omega$, with $N\\in\\mathbb{N}$, cell widths $\\Delta x = \\Delta y = h = 1/N$, and cell centers at $(x_i,y_j)=((i+\\tfrac{1}{2})h,(j+\\tfrac{1}{2})h)$ for $i,j\\in\\{0,\\dots,N-1\\}$.\n- Discretize spatial operators with second-order central differences in a conservative finite volume form:\n  - The convective term in conservative form for the $u$-momentum, $\\nabla\\cdot(u\\boldsymbol{u})$, is discretized by computing face-normal fluxes on the east–west faces as $F_{i+1/2,j} = u_{i+1/2,j}^2$ and on the north–south faces as $G_{i,j+1/2} = u_{i,j+1/2}v_{i,j+1/2}$, where $u_{i+1/2,j}$ denotes the arithmetic average of adjacent cell-centered values; the $v$-momentum uses $F_{i+1/2,j} = u_{i+1/2,j}v_{i+1/2,j}$ and $G_{i,j+1/2} = v_{i,j+1/2}^2$. Periodicity is applied by wrap-around at the domain boundaries.\n  - The pressure gradient uses centered differences: $(\\partial p/\\partial x)_{i,j} \\approx \\dfrac{p_{i+1,j}-p_{i-1,j}}{2\\Delta x}$ and $(\\partial p/\\partial y)_{i,j} \\approx \\dfrac{p_{i,j+1}-p_{i,j-1}}{2\\Delta y}$ with periodic indexing.\n  - The Laplacian uses the standard $5$-point stencil: $(\\nabla^2 \\phi)_{i,j} \\approx \\dfrac{\\phi_{i+1,j}+\\phi_{i-1,j}-2\\phi_{i,j}}{\\Delta x^2} + \\dfrac{\\phi_{i,j+1}+\\phi_{i,j-1}-2\\phi_{i,j}}{\\Delta y^2}$ for any scalar field $\\phi$.\n- Discretize time using the one-parameter $\\theta$-scheme for $\\theta \\in [\\tfrac{1}{2},1]$: for any operator $\\mathcal{L}$ acting on $(\\boldsymbol{u},p)$, define $\\mathcal{L}^{n+\\theta} = (1-\\theta)\\mathcal{L}^n + \\theta \\mathcal{L}^{n+1}$, and discretize the unsteady term by $(\\boldsymbol{u}^{n+1}-\\boldsymbol{u}^n)/\\Delta t$. This yields a fully discrete residual at each cell:\n$$\n\\boldsymbol{R}_{i,j} = \\frac{\\boldsymbol{u}_{i,j}^{n+1}-\\boldsymbol{u}_{i,j}^{n}}{\\Delta t} + \\left[\\nabla\\cdot(\\boldsymbol{u}\\otimes\\boldsymbol{u})\\right]_{i,j}^{n+\\theta} + \\left[\\nabla p\\right]_{i,j}^{n+\\theta} - \\nu \\left[\\nabla^2 \\boldsymbol{u}\\right]_{i,j}^{n+\\theta} - \\boldsymbol{f}_{i,j}^{n+\\theta}.\n$$\n\n3) Observed order of accuracy measurement:\n- For a given parameter set $(\\nu,\\theta,A,P,t_0,c)$ with $c0$, define grid sizes $N\\in\\{16,32,64,128\\}$, set $\\Delta t = c\\,h$ with $h=1/N$, and define $t^n = t_0$ and $t^{n+1} = t_0 + \\Delta t$. At each grid size, evaluate the exact fields $(\\boldsymbol{u}^n,p^n)$ and $(\\boldsymbol{u}^{n+1},p^{n+1})$ and the exact source $\\boldsymbol{f}$ at these times, apply the fully discrete residual $\\boldsymbol{R}$, and compute the discrete $L^2$ norm of the vector residual over the domain,\n$$\nE(h) = \\left( \\sum_{i,j} \\left( R_{u,i,j}^2 + R_{v,i,j}^2 \\right) h^2 \\right)^{1/2}.\n$$\n- Fit a line to $(\\log h, \\log E(h))$ across the four grid sizes using least squares; the observed order is the negative slope $p_{\\mathrm{obs}} = -\\dfrac{d\\log E}{d\\log h}$.\n\nYour program must implement all steps above for the following test suite of parameter sets (angles in radians), each expressed as $(\\nu,\\theta,c,A,P,t_0)$:\n- Case $1$ (happy path, mixed convection–diffusion, second-order in time): $(0.1,\\,0.5,\\,0.2,\\,1.0,\\,1.0,\\,0.07)$.\n- Case $2$ (edge case, inviscid limit, second-order in time): $(0.0,\\,0.5,\\,0.2,\\,0.8,\\,1.2,\\,0.13)$.\n- Case $3$ (time-dominated, backward Euler, first-order in time): $(0.1,\\,1.0,\\,0.2,\\,1.0,\\,1.0,\\,0.07)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the three observed orders of accuracy for Cases $1$–$3$ as a comma-separated list of decimal numbers rounded to two decimal places, enclosed in square brackets, for example, \"[2.01,2.00,1.01]\".",
            "solution": "The user has requested a Method of Manufactured Solutions (MMS) verification for a cell-centered finite volume discretization of the unsteady incompressible Navier-Stokes equations on a periodic two-dimensional domain. The process involves deriving an analytic source term for a given manufactured solution, implementing the discrete operators, computing the truncation error, and determining the observed order of accuracy.\n\n### Step 1: Problem Validation\n\n**1.1. Extract Givens**\n\n- **Governing Equations**:\n  - Momentum: $\\dfrac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nu \\nabla^2 \\boldsymbol{u} = \\boldsymbol{f}$\n  - Continuity: $\\nabla\\cdot\\boldsymbol{u} = 0$\n- **Domain**: $\\Omega = [0,1]\\times[0,1]$ with periodic boundaries.\n- **Manufactured Solution**:\n  - Streamfunction: $\\psi(x,y,t) = A \\sin(k x)\\sin(k y)\\cos(\\omega t)$, with $A0, k = 2\\pi, \\omega = 2\\pi$.\n  - Velocity: $\\boldsymbol{u} = (\\partial\\psi/\\partial y,\\ -\\partial\\psi/\\partial x)$.\n  - Pressure: $p(x,y,t) = P\\cos(k x)\\cos(k y)\\sin(\\omega t)$, with $P0$.\n- **Discretization**:\n  - Grid: Uniform $N\\times N$ cell-centered grid, $\\Delta x = \\Delta y = h = 1/N$. Cell centers $(x_i,y_j)=((i+\\tfrac{1}{2})h,(j+\\tfrac{1}{2})h)$.\n  - Time-stepping: $\\theta$-scheme with $\\frac{\\boldsymbol{u}^{n+1}-\\boldsymbol{u}^n}{\\Delta t}$. Spatial operators evaluated as $\\mathcal{L}^{n+\\theta} = (1-\\theta)\\mathcal{L}^n + \\theta \\mathcal{L}^{n+1}$.\n  - Spatial Operators (second-order centered):\n    - Convection $\\nabla\\cdot(\\boldsymbol{u}\\otimes\\boldsymbol{u})$: Conservative form with arithmetic averaging for face velocities.\n    - Pressure Gradient $\\nabla p$: $\\dfrac{p_{i+1,j}-p_{i-1,j}}{2\\Delta x}$ for the x-component.\n    - Laplacian $\\nabla^2 \\boldsymbol{u}$: Standard $5$-point stencil.\n- **Verification Procedure**:\n  - Compute discrete $L^2$ norm of the residual $E(h) = \\left( \\sum_{i,j} \\left( R_{u,i,j}^2 + R_{v,i,j}^2 \\right) h^2 \\right)^{1/2}$ for $N\\in\\{16,32,64,128\\}$.\n  - Time step: $\\Delta t = c\\,h$.\n  - Time levels: $t^n = t_0$, $t^{n+1} = t_0 + \\Delta t$.\n  - Observed order is the negative slope of a least-squares fit to $(\\log h, \\log E(h))$.\n- **Test Cases** $(\\nu,\\theta,c,A,P,t_0)$:\n  - Case 1: $(0.1,\\,0.5,\\,0.2,\\,1.0,\\,1.0,\\,0.07)$\n  - Case 2: $(0.0,\\,0.5,\\,0.2,\\,0.8,\\,1.2,\\,0.13)$\n  - Case 3: $(0.1,\\,1.0,\\,0.2,\\,1.0,\\,1.0,\\,0.07)$\n\n**1.2. Validate Using Extracted Givens**\n\n- **Scientific Grounding**: The problem is based on the fundamental Navier-Stokes equations for incompressible flow, a cornerstone of fluid dynamics. The MMS procedure is a standard and rigorous verification technique in computational science. The chosen manufactured solution is smooth, differentiable, and periodic, making it suitable for this analysis. The problem is scientifically sound.\n- **Well-Posed**: The problem is well-posed. The manufactured solution is given, and the task is to derive the corresponding source term and then measure the convergence of the discrete scheme, which is a well-defined computational procedure. All discretization details and parameters are explicitly specified. The task leads to a unique, meaningful numerical result (the order of accuracy).\n- **Objective**: The problem is stated in precise, objective mathematical and computational terms. It is free of ambiguity, subjectivity, or opinion.\n\n**1.3. Verdict and Action**\n\nThe problem statement is valid. It is scientifically grounded, well-posed, objective, and provides a complete and consistent set of instructions. A solution will be provided.\n\n### Step 2: Analytical Derivations\n\nFirst, we derive the velocity components and confirm incompressibility.\nGiven the streamfunction $\\psi(x,y,t) = A \\sin(kx)\\sin(ky)\\cos(\\omega t)$ with $k=2\\pi, \\omega=2\\pi$:\n- $u(x,y,t) = \\dfrac{\\partial\\psi}{\\partial y} = Ak \\sin(kx)\\cos(ky)\\cos(\\omega t)$\n- $v(x,y,t) = -\\dfrac{\\partial\\psi}{\\partial x} = -Ak \\cos(kx)\\sin(ky)\\cos(\\omega t)$\n\nThe divergence of the velocity field is:\n$$ \\nabla\\cdot\\boldsymbol{u} = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} = Ak^2 \\cos(kx)\\cos(ky)\\cos(\\omega t) - Ak^2 \\cos(kx)\\cos(ky)\\cos(\\omega t) = 0 $$\nThe manufactured velocity field is indeed divergence-free, as required.\n\nNext, we derive the source term $\\boldsymbol{f}=(f_u, f_v)$ by substituting the manufactured solution into the momentum equation:\n$$ \\boldsymbol{f} = \\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nu \\nabla^2 \\boldsymbol{u} $$\nThe terms are derived as follows:\n\n- **Time Derivative**:\n  - $\\dfrac{\\partial u}{\\partial t} = -A k \\omega \\sin(kx)\\cos(ky)\\sin(\\omega t)$\n  - $\\dfrac{\\partial v}{\\partial t} = Ak \\omega \\cos(kx)\\sin(ky)\\sin(\\omega t)$\n\n- **Convective Term**: $(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u}$. Since $\\nabla\\cdot\\boldsymbol{u}=0$, this is equivalent to $\\nabla\\cdot(\\boldsymbol{u}\\otimes\\boldsymbol{u})$.\n  - For $u$-momentum: $(\\boldsymbol{u}\\cdot\\nabla)u = u\\dfrac{\\partial u}{\\partial x} + v\\dfrac{\\partial u}{\\partial y} = \\frac{1}{2}A^2k^3 \\cos^2(\\omega t) \\sin(2kx)$\n  - For $v$-momentum: $(\\boldsymbol{u}\\cdot\\nabla)v = u\\dfrac{\\partial v}{\\partial x} + v\\dfrac{\\partial v}{\\partial y} = \\frac{1}{2}A^2k^3 \\cos^2(\\omega t) \\sin(2ky)$\n\n- **Pressure Gradient**: $\\nabla p$, with $p=P\\cos(kx)\\cos(ky)\\sin(\\omega t)$.\n  - $\\dfrac{\\partial p}{\\partial x} = -Pk \\sin(kx)\\cos(ky)\\sin(\\omega t)$\n  - $\\dfrac{\\partial p}{\\partial y} = -Pk \\cos(kx)\\sin(ky)\\sin(\\omega t)$\n\n- **Viscous Term**: $-\\nu \\nabla^2 \\boldsymbol{u}$.\n  - $\\nabla^2 u = \\dfrac{\\partial^2 u}{\\partial x^2} + \\dfrac{\\partial^2 u}{\\partial y^2} = -2Ak^3 \\sin(kx)\\cos(ky)\\cos(\\omega t) = -2k^2 u$\n  - $\\nabla^2 v = \\dfrac{\\partial^2 v}{\\partial x^2} + \\dfrac{\\partial^2 v}{\\partial y^2} = -2(-Ak\\cos(kx)\\sin(ky)\\cos(\\omega t))k^2 = -2k^2 v$\n  - Thus, $-\\nu \\nabla^2 \\boldsymbol{u} = 2\\nu k^2 \\boldsymbol{u}$.\n\nCombining these terms yields the source terms $f_u$ and $f_v$:\n$$ f_u(x,y,t) = -k\\sin(\\omega t)(A\\omega + P)\\sin(kx)\\cos(ky) + 2A\\nu k^3\\cos(\\omega t)\\sin(kx)\\cos(ky) + \\frac{1}{2}A^2k^3\\cos^2(\\omega t)\\sin(2kx) $$\n$$ f_v(x,y,t) = k\\sin(\\omega t)(A\\omega - P)\\cos(kx)\\sin(ky) - 2A\\nu k^3\\cos(\\omega t)\\cos(kx)\\sin(ky) + \\frac{1}{2}A^2k^3\\cos^2(\\omega t)\\sin(2ky) $$\n\n### Step 3: Discretization and Verification Implementation\n\nThe implementation follows the problem description. A Python program is created to perform the MMS test for the given parameter sets.\n\n1.  **Grid and Fields**: For each grid size $N$, a uniform cell-centered grid is generated. The exact velocity, pressure, and source term fields are evaluated at the cell centers at time levels $t^n = t_0$ and $t^{n+1} = t_0 + \\Delta t$.\n\n2.  **Discrete Operators**: Functions are implemented for the discrete spatial operators (convection, pressure gradient, Laplacian) using second-order central differencing on the periodic grid. `numpy.roll` is used to handle periodic boundary conditions efficiently.\n\n3.  **Residual Calculation**: The full discrete residual $\\boldsymbol{R}$ is assembled.\n    - First, the discrete spatial operators are applied to the exact solution fields at $t^n$ and $t^{n+1}$.\n    - These results are combined using the $\\theta$-weighting: $\\mathcal{L}^{n+\\theta} = (1-\\theta)\\mathcal{L}(\\phi^n) + \\theta\\mathcal{L}(\\phi^{n+1})$.\n    - The source term $\\boldsymbol{f}$ is also evaluated at $t^n$ and $t^{n+1}$ and similarly weighted.\n    - The time derivative is approximated by $\\frac{\\boldsymbol{u}^{n+1}-\\boldsymbol{u}^n}{\\Delta t}$.\n    - Finally, all terms are summed to form the residual vector $\\boldsymbol{R} = (R_u, R_v)$ at each cell.\n\n4.  **Error Norm and Order of Accuracy**: The discrete $L^2$ norm of the residual, $E(h)$, is calculated for each grid resolution $N$. A linear regression is performed on the logarithms of the error and grid spacing, $(\\log h, \\log E(h))$. The observed order of accuracy is the negative of the slope of the best-fit line.\n\nThis procedure is repeated for each of the three test cases.\n\n- **Case 1**: $\\theta=0.5$ (Crank-Nicolson) is second-order in time. The spatial discretizations are second-order. With $\\Delta t \\propto h$, the overall scheme is expected to be second-order accurate, $p_{\\mathrm{obs}} \\approx 2.0$.\n- **Case 2**: Inviscid case ($\\nu=0$), but the discretization scheme is identical to Case 1. The expected order is also $p_{\\mathrm{obs}} \\approx 2.0$.\n- **Case 3**: $\\theta=1.0$ (Backward Euler) is first-order in time. Since the spatial error is $O(h^2)$ and the temporal error is $O(\\Delta t) = O(h)$, the overall accuracy is dominated by the temporal error. The expected order is $p_{\\mathrm{obs}} \\approx 1.0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to run the Method of Manufactured Solutions (MMS) verification\n    for the unsteady incompressible Navier-Stokes equations.\n    \"\"\"\n    \n    # --- Mathematical Constants ---\n    K = 2 * np.pi\n    OMEGA = 2 * np.pi\n\n    # --- Analytical Solution Functions ---\n\n    def u_exact(x, y, t, A):\n        \"\"\"Computes the exact u-velocity component.\"\"\"\n        return A * K * np.sin(K * x) * np.cos(K * y) * np.cos(OMEGA * t)\n\n    def v_exact(x, y, t, A):\n        \"\"\"Computes the exact v-velocity component.\"\"\"\n        return -A * K * np.cos(K * x) * np.sin(K * y) * np.cos(OMEGA * t)\n\n    def p_exact(x, y, t, P):\n        \"\"\"Computes the exact pressure component.\"\"\"\n        return P * np.cos(K * x) * np.cos(K * y) * np.sin(OMEGA * t)\n\n    def fu_exact(x, y, t, nu, A, P):\n        \"\"\"Computes the exact source term for the u-momentum equation.\"\"\"\n        term1 = -K * np.sin(OMEGA * t) * (A * OMEGA + P) * np.sin(K * x) * np.cos(K * y)\n        term2 = 2 * A * nu * K**3 * np.cos(OMEGA * t) * np.sin(K * x) * np.cos(K * y)\n        term3 = 0.5 * A**2 * K**3 * np.cos(OMEGA * t)**2 * np.sin(2 * K * x)\n        return term1 + term2 + term3\n\n    def fv_exact(x, y, t, nu, A, P):\n        \"\"\"Computes the exact source term for the v-momentum equation.\"\"\"\n        term1 = K * np.sin(OMEGA * t) * (A * OMEGA - P) * np.cos(K * x) * np.sin(K * y)\n        term2 = -2 * A * nu * K**3 * np.cos(OMEGA * t) * np.cos(K * x) * np.sin(K * y)\n        term3 = 0.5 * A**2 * K**3 * np.cos(OMEGA * t)**2 * np.sin(2 * K * y)\n        return term1 + term2 + term3\n\n    # --- Discrete Operator Functions ---\n\n    def grad_op(p, h):\n        \"\"\"Computes the pressure gradient using second-order central differences.\"\"\"\n        dp_dx = (np.roll(p, -1, axis=1) - np.roll(p, 1, axis=1)) / (2 * h)\n        dp_dy = (np.roll(p, -1, axis=0) - np.roll(p, 1, axis=0)) / (2 * h)\n        return dp_dx, dp_dy\n\n    def lap_op(phi, h):\n        \"\"\"Computes the Laplacian using the standard 5-point stencil.\"\"\"\n        phi_ip1 = np.roll(phi, -1, axis=1)\n        phi_im1 = np.roll(phi, 1, axis=1)\n        phi_jp1 = np.roll(phi, -1, axis=0)\n        phi_jm1 = np.roll(phi, 1, axis=0)\n        \n        lap_phi_x = (phi_ip1 + phi_im1 - 2 * phi) / h**2\n        lap_phi_y = (phi_jp1 + phi_jm1 - 2 * phi) / h**2\n        return lap_phi_x + lap_phi_y\n\n    def conv_op(u, v, h):\n        \"\"\"Computes the conservative form of the convective term.\"\"\"\n        # East-West face values (axis=1 for x-direction)\n        u_face_E = (u + np.roll(u, -1, axis=1)) / 2\n        v_face_E = (v + np.roll(v, -1, axis=1)) / 2\n        \n        # North-South face values (axis=0 for y-direction)\n        u_face_N = (u + np.roll(u, -1, axis=0)) / 2\n        v_face_N = (v + np.roll(v, -1, axis=0)) / 2\n        \n        # Fluxes for u-momentum: F = u*u, G = u*v\n        flux_F_u = u_face_E**2\n        flux_G_u = u_face_N * v_face_N\n        conv_u = (flux_F_u - np.roll(flux_F_u, 1, axis=1)) / h + \\\n                 (flux_G_u - np.roll(flux_G_u, 1, axis=0)) / h\n\n        # Fluxes for v-momentum: F = v*u, G = v*v\n        flux_F_v = v_face_E * u_face_E\n        flux_G_v = v_face_N**2\n        conv_v = (flux_F_v - np.roll(flux_F_v, 1, axis=1)) / h + \\\n                 (flux_G_v - np.roll(flux_G_v, 1, axis=0)) / h\n        \n        return conv_u, conv_v\n\n    # --- Main verification function ---\n\n    def compute_observed_order(case_params):\n        nu, theta, c, A, P, t0 = case_params\n        grid_sizes = [16, 32, 64, 128]\n        log_h_vals = []\n        log_E_vals = []\n\n        for N in grid_sizes:\n            # 1. Grid and time step setup\n            h = 1.0 / N\n            dt = c * h\n            x_coords = (np.arange(N) + 0.5) * h\n            y_coords = (np.arange(N) + 0.5) * h\n            X, Y = np.meshgrid(x_coords, y_coords, indexing='xy')\n            \n            t_n = t0\n            t_np1 = t0 + dt\n\n            # 2. Evaluate exact solution fields at t_n and t_np1\n            u_n, v_n = u_exact(X, Y, t_n, A), v_exact(X, Y, t_n, A, )\n            p_n = p_exact(X, Y, t_n, P)\n            u_np1, v_np1 = u_exact(X, Y, t_np1, A), v_exact(X, Y, t_np1, A)\n            p_np1 = p_exact(X, Y, t_np1, P)\n\n            # 3. Evaluate and weight source terms\n            f_u_n, f_v_n = fu_exact(X, Y, t_n, nu, A, P), fv_exact(X, Y, t_n, nu, A, P)\n            f_u_np1, f_v_np1 = fu_exact(X, Y, t_np1, nu, A, P), fv_exact(X, Y, t_np1, nu, A, P)\n            f_u_ntheta = (1 - theta) * f_u_n + theta * f_u_np1\n            f_v_ntheta = (1 - theta) * f_v_n + theta * f_v_np1\n            \n            # 4. Compute and weight discrete spatial operators\n            conv_u_n, conv_v_n = conv_op(u_n, v_n, h)\n            grad_px_n, grad_py_n = grad_op(p_n, h)\n            lap_u_n, lap_v_n = lap_op(u_n, h), lap_op(v_n, h)\n            \n            conv_u_np1, conv_v_np1 = conv_op(u_np1, v_np1, h)\n            grad_px_np1, grad_py_np1 = grad_op(p_np1, h)\n            lap_u_np1, lap_v_np1 = lap_op(u_np1, h), lap_op(v_np1, h)\n            \n            conv_u_ntheta = (1-theta)*conv_u_n + theta*conv_u_np1\n            grad_px_ntheta = (1-theta)*grad_px_n + theta*grad_px_np1\n            lap_u_ntheta = (1-theta)*lap_u_n + theta*lap_u_np1\n            \n            conv_v_ntheta = (1-theta)*conv_v_n + theta*conv_v_np1\n            grad_py_ntheta = (1-theta)*grad_py_n + theta*grad_py_np1\n            lap_v_ntheta = (1-theta)*lap_v_n + theta*lap_v_np1\n            \n            # 5. Assemble the residual\n            time_deriv_u = (u_np1 - u_n) / dt\n            R_u = time_deriv_u + conv_u_ntheta + grad_px_ntheta - nu * lap_u_ntheta - f_u_ntheta\n            \n            time_deriv_v = (v_np1 - v_n) / dt\n            R_v = time_deriv_v + conv_v_ntheta + grad_py_ntheta - nu * lap_v_ntheta - f_v_ntheta\n            \n            # 6. Compute discrete L2 norm of the residual\n            E_h = np.sqrt(np.sum(R_u**2 + R_v**2) * h**2)\n            \n            # 7. Store log values for regression\n            log_h_vals.append(np.log(h))\n            log_E_vals.append(np.log(E_h))\n\n        # 8. Perform linear regression and return observed order\n        slope, _, _, _, _ = linregress(log_h_vals, log_E_vals)\n        return -slope\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case 1: (nu, theta, c, A, P, t0) - Expected Order: 2\n        (0.1, 0.5, 0.2, 1.0, 1.0, 0.07),\n        # Case 2: - Expected Order: 2\n        (0.0, 0.5, 0.2, 0.8, 1.2, 0.13),\n        # Case 3: - Expected Order: 1\n        (0.1, 1.0, 0.2, 1.0, 1.0, 0.07),\n    ]\n\n    results = []\n    for case in test_cases:\n        order = compute_observed_order(case)\n        results.append(order)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{order:.2f}\" for order in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Beyond correctness, the quality of a numerical scheme is judged by its ability to respect fundamental physical laws. The nonlinear convective term is particularly critical, and its discretization directly impacts the conservation of kinetic energy in simulations of inviscid or high-Reynolds-number flows. This practice  provides a deep dive into analyzing how different formulations—conservative, skew-symmetric, and upwind—behave with respect to kinetic energy, developing your intuition for how discrete operators mimic (or fail to mimic) continuous physics.",
            "id": "3297733",
            "problem": "Consider the incompressible convective dynamics on a two-dimensional periodic domain, discretized by a cell-centered finite volume method on a uniform Cartesian grid. Let the domain be $\\Omega = [0,L_x] \\times [0,L_y]$ with periodic boundaries in both directions. Let $N_x$ and $N_y$ denote the numbers of control volumes in the $x$ and $y$ directions, respectively, with uniform spacings $\\Delta x = L_x / N_x$ and $\\Delta y = L_y / N_y$. The unknowns are the cell-centered velocity components $u_{i,j}$ and $v_{i,j}$ for $i \\in \\{0,1,\\ldots,N_x-1\\}$ and $j \\in \\{0,1,\\ldots,N_y-1\\}$.\n\nThe fundamental base is the incompressible Euler equations (no forcing, unit density) in conservative form,\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + \\nabla \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u}) + \\nabla p = \\boldsymbol{0}, \\quad \\nabla \\cdot \\boldsymbol{u} = 0,\n$$\nand the kinetic energy\n$$\nK(t) = \\frac{1}{2} \\int_{\\Omega} \\lVert \\boldsymbol{u}(\\boldsymbol{x},t) \\rVert^2 \\, \\mathrm{d}\\Omega,\n$$\nwhich is preserved in time under periodic boundary conditions by the continuous convective term. In a cell-centered finite volume method, we define a discrete inner product for vector fields $\\boldsymbol{a}$ and $\\boldsymbol{b}$ by\n$$\n\\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle_h = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left( a_{i,j}^{(x)} b_{i,j}^{(x)} + a_{i,j}^{(y)} b_{i,j}^{(y)} \\right) \\Delta x \\Delta y,\n$$\nand the discrete kinetic energy by $K_h = \\frac{1}{2} \\langle \\boldsymbol{u}, \\boldsymbol{u} \\rangle_h$.\n\nYou will work with three finite volume discretizations of the convective operator on a collocated grid using face-centered values assembled by arithmetic averages:\n- The conservative central flux form $-\\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})$, where each face flux uses the arithmetic average of neighboring cell values to reconstruct face-centered velocities.\n- The skew-symmetric split form $-\\frac{1}{2} \\left( \\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u}) + (\\boldsymbol{u} \\cdot \\nabla_h) \\boldsymbol{u} \\right)$, where $(\\boldsymbol{u} \\cdot \\nabla_h)$ uses central differences at cell centers and $\\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})$ uses conservative central flux divergence.\n- The first-order upwind flux form $-\\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})$ with face-centered values taken from the upwind donor cell according to the sign of the face-normal velocity.\n\nAll discrete differential operators must use periodic wrap-around indexing on the uniform mesh. On each vertical face, define face-centered values $u_e = \\frac{1}{2}(u_{i,j} + u_{i+1,j})$, $v_e = \\frac{1}{2}(v_{i,j} + v_{i+1,j})$, and on each horizontal face, $u_n = \\frac{1}{2}(u_{i,j} + u_{i,j+1})$, $v_n = \\frac{1}{2}(v_{i,j} + v_{i,j+1})$. The conservative central flux for the $x$-momentum at vertical faces is $F^{(x)}_{\\text{vert}} = u_e^2$ and at horizontal faces is $F^{(x)}_{\\text{horiz}} = u_n v_n$. Analogously, for the $y$-momentum, $F^{(y)}_{\\text{vert}} = u_e v_e$ and $F^{(y)}_{\\text{horiz}} = v_n^2$. The discrete conservative divergence in a control volume is the net flux difference divided by the cell size, for example $(F_e - F_w)/\\Delta x$ for vertical faces, where $F_w$ is the vertical-face flux at the west face of the cell, and $(F_n - F_s)/\\Delta y$ for horizontal faces.\n\nPropose the following periodic test velocity fields parameterized by integers $m$ and $n$, amplitudes $U_0$, and domain lengths $L_x$ and $L_y$:\n- For $m \\ge 1$ and $n \\ge 1$, define wave numbers $k_x = \\frac{2\\pi m}{L_x}$ and $k_y = \\frac{2\\pi n}{L_y}$ and the analytic field\n$$\nu(x,y) = U_0 \\sin(k_x x) \\cos(k_y y), \\qquad v(x,y) = - U_0 \\frac{k_x}{k_y} \\cos(k_x x) \\sin(k_y y),\n$$\nwhich is analytically divergence-free.\n- For the uniform-flow edge case $m = 0$ and $n = 0$, define $u(x,y) = U_0$ and $v(x,y) = 0$, which is constant.\n\nDiscretize $u$ and $v$ by sampling these fields at cell centers $x_i = \\left(i + \\frac{1}{2} \\right) \\Delta x$ and $y_j = \\left(j + \\frac{1}{2} \\right) \\Delta y$. Then, for a chosen convective discretization, define the semi-discrete update\n$$\n\\frac{\\mathrm{d}\\boldsymbol{u}}{\\mathrm{d}t} = \\boldsymbol{R}(\\boldsymbol{u}),\n$$\nand the following diagnostic metrics:\n- The semi-discrete energy production rate normalized by discrete kinetic energy,\n$$\nr_h = \\frac{\\langle \\boldsymbol{u}, \\boldsymbol{R}(\\boldsymbol{u}) \\rangle_h}{K_h}.\n$$\n- The one-step explicit Euler discrete kinetic energy change with time step $\\Delta t$,\n$$\n\\delta_h = \\frac{K_h^{\\star} - K_h}{K_h}, \\quad \\text{where} \\quad \\boldsymbol{u}^{\\star} = \\boldsymbol{u} + \\Delta t \\, \\boldsymbol{R}(\\boldsymbol{u}), \\; K_h^{\\star} = \\frac{1}{2} \\langle \\boldsymbol{u}^{\\star}, \\boldsymbol{u}^{\\star} \\rangle_h.\n$$\n- The discrete divergence magnitude normalized by the velocity $\\ell_2$ norm,\n$$\nd_h = \\frac{\\left( \\sum_{i,j} \\left( \\nabla_h \\cdot \\boldsymbol{u} \\right)_{i,j}^2 \\, \\Delta x \\Delta y \\right)^{1/2}}{\\left( \\sum_{i,j} \\left( u_{i,j}^2 + v_{i,j}^2 \\right) \\, \\Delta x \\Delta y \\right)^{1/2}},\n$$\nwhere $\\nabla_h \\cdot \\boldsymbol{u}$ is the finite volume divergence computed from face-normal velocities $(u_e, v_n)$.\n\nStarting from the fundamental conservation laws and the periodicity assumption, derive why the skew-symmetric split form has $\\langle \\boldsymbol{u}, \\boldsymbol{R}(\\boldsymbol{u}) \\rangle_h = 0$ for central differences and periodic wrap (up to round-off) regardless of $\\nabla_h \\cdot \\boldsymbol{u}$, and why the conservative central flux form has $\\langle \\boldsymbol{u}, \\boldsymbol{R}(\\boldsymbol{u}) \\rangle_h = - \\frac{1}{2} \\langle \\lVert \\boldsymbol{u} \\rVert^2, \\nabla_h \\cdot \\boldsymbol{u} \\rangle_h$ (hence zero if the discrete divergence vanishes). Explain why the first-order upwind form produces non-positive energy production due to numerical dissipation.\n\nImplement a program that constructs the discrete velocity fields and computes $(r_h, \\delta_h, d_h)$ for each of the following test cases (all in a domain with $L_x = 2\\pi$ and $L_y = 2\\pi$):\n- Case $1$: $N_x = 32$, $N_y = 32$, $m = 2$, $n = 3$, $U_0 = 1.1$, $\\Delta t = 10^{-3}$, skew-symmetric split form.\n- Case $2$: $N_x = 32$, $N_y = 32$, $m = 2$, $n = 3$, $U_0 = 1.1$, $\\Delta t = 10^{-3}$, conservative central flux form.\n- Case $3$: $N_x = 32$, $N_y = 32$, $m = 2$, $n = 3$, $U_0 = 1.1$, $\\Delta t = 10^{-3}$, first-order upwind flux form.\n- Case $4$: $N_x = 16$, $N_y = 8$, $m = 0$, $n = 0$, $U_0 = 0.77$, $\\Delta t = 10^{-3}$, first-order upwind flux form (uniform-flow edge case).\n- Case $5$: $N_x = 64$, $N_y = 8$, $m = 3$, $n = 1$, $U_0 = 0.8$, $\\Delta t = 2 \\times 10^{-4}$, skew-symmetric split form (anisotropic grid).\n\nYour program must output the diagnostic triplet $(r_h, \\delta_h, d_h)$ for each test case in the following exact format: a single line containing a JSON-like list of lists with each inner list ordered as $[r_h,\\delta_h,d_h]$ in that order, using Python’s default string formatting for floating-point numbers. For example, the output should look like $[[r_1,\\delta_1,d_1],[r_2,\\delta_2,d_2],\\ldots]$.\n\nAll angles are in radians. There are no physical units required beyond the given non-dimensionalization.\n\nYour program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets (for example, $[[r_1,\\delta_1,d_1],[r_2,\\delta_2,d_2],[r_3,\\delta_3,d_3],[r_4,\\delta_4,d_4],[r_5,\\delta_5,d_5]]$).",
            "solution": "The user has provided a valid, well-posed problem in computational fluid dynamics. The task involves two parts: first, a theoretical derivation of the kinetic energy conservation properties for three different finite volume discretizations of the convective term in the incompressible Euler equations; second, a numerical implementation to compute diagnostic metrics for these schemes on specific test cases.\n\n### Part 1: Derivation of Energy Conservation Properties\n\nThe rate of change of discrete kinetic energy, $K_h = \\frac{1}{2} \\langle \\boldsymbol{u}, \\boldsymbol{u} \\rangle_h$, for the semi-discrete system $\\frac{\\mathrm{d}\\boldsymbol{u}}{\\mathrm{d}t} = \\boldsymbol{R}(\\boldsymbol{u})$ is given by:\n$$\n\\frac{\\mathrm{d}K_h}{\\mathrm{d}t} = \\left\\langle \\boldsymbol{u}, \\frac{\\mathrm{d}\\boldsymbol{u}}{\\mathrm{d}t} \\right\\rangle_h = \\langle \\boldsymbol{u}, \\boldsymbol{R}(\\boldsymbol{u}) \\rangle_h\n$$\nThe normalized energy production rate is $r_h = \\frac{1}{K_h} \\frac{\\mathrm{d}K_h}{\\mathrm{d}t}$. We analyze this quantity for each scheme.\n\n**1. Skew-Symmetric Split Form**\n\nThe convective operator is $\\boldsymbol{R}_{skew}(\\boldsymbol{u}) = -\\frac{1}{2} \\left( \\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u}) + (\\boldsymbol{u} \\cdot \\nabla_h) \\boldsymbol{u} \\right)$. Let $\\boldsymbol{C}(\\boldsymbol{u}) = \\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})$ be the conservative part and $\\boldsymbol{A}(\\boldsymbol{u}) = (\\boldsymbol{u} \\cdot \\nabla_h) \\boldsymbol{u}$ be the advective part. Both are discretized using central differences and arithmetic averaging on a periodic grid.\n\nA fundamental property of such discretizations, provable through summation by parts (the discrete equivalent of integration by parts), is that the discrete operators $\\boldsymbol{C}$ and $\\boldsymbol{A}$ are negative transposes of each other with respect to the discrete inner product. That is, for any two discrete vector fields $\\boldsymbol{\\phi}$ and $\\boldsymbol{\\psi}$:\n$$\n\\langle \\boldsymbol{\\phi}, \\boldsymbol{C}(\\boldsymbol{\\psi}) \\rangle_h = - \\langle \\boldsymbol{A}(\\boldsymbol{\\psi})\\boldsymbol{\\phi}, \\boldsymbol{1} \\rangle_h\n$$\nThe property we need is that the overall operator $\\boldsymbol{R}_{skew}$ is skew-symmetric, meaning for any two fields $\\boldsymbol{\\phi}$ and $\\boldsymbol{\\psi}$:\n$$\n\\langle \\boldsymbol{\\phi}, \\boldsymbol{R}_{skew}(\\boldsymbol{\\psi}) \\rangle_h = - \\langle \\boldsymbol{\\psi}, \\boldsymbol{R}_{skew}(\\boldsymbol{\\phi}) \\rangle_h\n$$\nThis property holds for the specified construction of $\\boldsymbol{R}_{skew}$. Setting $\\boldsymbol{\\phi} = \\boldsymbol{\\psi} = \\boldsymbol{u}$, we get:\n$$\n\\langle \\boldsymbol{u}, \\boldsymbol{R}_{skew}(\\boldsymbol{u}) \\rangle_h = - \\langle \\boldsymbol{u}, \\boldsymbol{R}_{skew}(\\boldsymbol{u}) \\rangle_h\n$$\nThis implies that $\\langle \\boldsymbol{u}, \\boldsymbol{R}_{skew}(\\boldsymbol{u}) \\rangle_h = 0$. Therefore, the semi-discrete kinetic energy is exactly conserved, and the energy production rate $r_h = 0$, regardless of whether the discrete velocity field is divergence-free. This holds up to machine floating-point precision.\n\n**2. Conservative Central Flux Form**\n\nThe operator is $\\boldsymbol{R}_{cons}(\\boldsymbol{u}) = - \\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})$. The energy production is $\\langle \\boldsymbol{u}, \\boldsymbol{R}_{cons}(\\boldsymbol{u}) \\rangle_h$. The derivation follows its continuous counterpart. In the continuous setting, the rate of change of kinetic energy due to convection is:\n$$\n\\frac{\\mathrm{d}K}{\\mathrm{d}t} = - \\int_{\\Omega} \\boldsymbol{u} \\cdot (\\nabla \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})) \\, \\mathrm{d}\\Omega\n$$\nUsing the vector identity $\\boldsymbol{u} \\cdot (\\nabla \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})) = (\\boldsymbol{u} \\cdot \\nabla)\\frac{\\lVert\\boldsymbol{u}\\rVert^2}{2} + \\lVert\\boldsymbol{u}\\rVert^2(\\nabla \\cdot \\boldsymbol{u})$, and applying the divergence theorem to the first term (which vanishes on a periodic domain), one arrives at:\n$$\n\\frac{\\mathrm{d}K}{\\mathrm{d}t} = -\\frac{1}{2} \\int_{\\Omega} \\lVert\\boldsymbol{u}\\rVert^2 (\\nabla \\cdot \\boldsymbol{u}) \\, \\mathrm{d}\\Omega\n$$\nThe central difference scheme is constructed to mimic these continuous properties. Through discrete summation by parts, it can be shown that the discrete scheme satisfies an analogous identity:\n$$\n\\langle \\boldsymbol{u}, \\boldsymbol{R}_{cons}(\\boldsymbol{u}) \\rangle_h = -\\frac{1}{2} \\langle \\lVert \\boldsymbol{u} \\rVert^2, \\nabla_h \\cdot \\boldsymbol{u} \\rangle_h\n$$\nwhere $\\lVert \\boldsymbol{u} \\rVert^2$ is the field of squared velocity magnitudes at cell centers, i.e., $(u_{i,j}^2 + v_{i,j}^2)$. This relation demonstrates that the conservative central flux form only conserves energy if the discrete velocity field is divergence-free, i.e., $(\\nabla_h \\cdot \\boldsymbol{u})_{i,j} = 0$ for all cells. The provided analytic velocity field is divergence-free in the continuous sense, but its discrete sampling is not necessarily discretely divergence-free, leading to potential energy production or dissipation.\n\n**3. First-Order Upwind Flux Form**\n\nThe first-order upwind scheme determines the value of the convected quantity at a cell face based on the direction of the velocity normal to that face. For a face with normal velocity $u_n$, the upwind flux can be written as the sum of a central-difference flux and a dissipative term:\n$$\nF_{upwind} = F_{central} - \\frac{1}{2} |u_n| \\Delta x(\\text{gradient term})\n$$\nThe divergence of this flux introduces a term into the momentum equation that is analogous to physical viscosity, hence it is called \"numerical viscosity\" or \"numerical diffusion.\" The full operator $\\boldsymbol{R}_{upwind}$ can be expressed as:\n$$\n\\boldsymbol{R}_{upwind}(\\boldsymbol{u}) = \\boldsymbol{R}_{central}(\\boldsymbol{u}) + \\boldsymbol{D}(\\boldsymbol{u})\n$$\nwhere $\\boldsymbol{D}(\\boldsymbol{u})$ represents the numerical diffusion operator, which is of the form $\\nabla_h \\cdot (\\nu_h \\nabla_h \\boldsymbol{u})$. The numerical viscosity coefficient $\\nu_h$ is always non-negative, being proportional to the local velocity magnitude and grid spacing.\n\nThe contribution of this dissipative term to the kinetic energy equation is:\n$$\n\\langle \\boldsymbol{u}, \\boldsymbol{D}(\\boldsymbol{u}) \\rangle_h = \\langle \\boldsymbol{u}, \\nabla_h \\cdot (\\nu_h \\nabla_h \\boldsymbol{u}) \\rangle_h\n$$\nUsing summation by parts, this becomes:\n$$\n\\langle \\boldsymbol{u}, \\boldsymbol{D}(\\boldsymbol{u}) \\rangle_h = - \\langle \\nabla_h \\boldsymbol{u}, \\nu_h \\nabla_h \\boldsymbol{u} \\rangle_h = - \\sum_{i,j} \\nu_h \\lVert \\nabla_h \\boldsymbol{u} \\rVert^2_{i,j} \\Delta x \\Delta y \\le 0\n$$\nBecause $\\nu_h \\ge 0$, this term always removes kinetic energy from the flow. The total energy production rate $\\langle \\boldsymbol{u}, \\boldsymbol{R}_{upwind}(\\boldsymbol{u}) \\rangle_h$ is the sum of the central term (which can be positive or negative) and the dissipative term (which is always non-positive). For most flows, the dissipative effect dominates, leading to a net non-positive energy production, $r_h \\le 0$.\n\n### Part 2: Numerical Implementation and Results\n\nThe following Python code implements the specified finite volume schemes and computes the diagnostic metrics for the five given test cases.",
            "answer": "```python\nimport numpy as np\n\ndef compute_convection(u, v, dx, dy, scheme):\n    \"\"\"\n    Computes the convective term R(u) for different schemes.\n    R(u) is the RHS of d(u)/dt = R(u).\n    \"\"\"\n\n    # --- Central Conservative Operator: Op_C(u) = grad_h . (u tensor u) ---\n    def compute_op_central(u, v, dx, dy):\n        # Face-centered velocities (arithmetic average)\n        u_e = 0.5 * (u + np.roll(u, -1, axis=1))\n        v_e = 0.5 * (v + np.roll(v, -1, axis=1))\n        u_n = 0.5 * (u + np.roll(u, -1, axis=0))\n        v_n = 0.5 * (v + np.roll(v, -1, axis=0))\n\n        # Fluxes\n        F_x_vert = u_e**2\n        F_x_horiz = u_n * v_n\n        F_y_vert = u_e * v_e\n        F_y_horiz = v_n**2\n\n        # Divergence of fluxes\n        Op_C_x = (F_x_vert - np.roll(F_x_vert, 1, axis=1)) / dx + \\\n                 (F_x_horiz - np.roll(F_x_horiz, 1, axis=0)) / dy\n        Op_C_y = (F_y_vert - np.roll(F_y_vert, 1, axis=1)) / dx + \\\n                 (F_y_horiz - np.roll(F_y_horiz, 1, axis=0)) / dy\n        return Op_C_x, Op_C_y\n\n    # --- Central Advective Operator: Op_A(u) = (u . grad_h) u ---\n    def compute_op_advective(u, v, dx, dy):\n        du_dx = (np.roll(u, -1, axis=1) - np.roll(u, 1, axis=1)) / (2 * dx)\n        du_dy = (np.roll(u, -1, axis=0) - np.roll(u, 1, axis=0)) / (2 * dy)\n        dv_dx = (np.roll(v, -1, axis=1) - np.roll(v, 1, axis=1)) / (2 * dx)\n        dv_dy = (np.roll(v, -1, axis=0) - np.roll(v, 1, axis=0)) / (2 * dy)\n\n        Op_A_x = u * du_dx + v * du_dy\n        Op_A_y = u * dv_dx + v * dv_dy\n        return Op_A_x, Op_A_y\n\n    if scheme == 'conservative central flux':\n        Op_C_x, Op_C_y = compute_op_central(u, v, dx, dy)\n        return -Op_C_x, -Op_C_y\n\n    elif scheme == 'skew-symmetric split':\n        Op_C_x, Op_C_y = compute_op_central(u, v, dx, dy)\n        Op_A_x, Op_A_y = compute_op_advective(u, v, dx, dy)\n        Rx = -0.5 * (Op_C_x + Op_A_x)\n        Ry = -0.5 * (Op_C_y + Op_A_y)\n        return Rx, Ry\n\n    elif scheme == 'first-order upwind':\n        # East/West faces (normal in x-dir)\n        u_e = 0.5 * (u + np.roll(u, -1, axis=1))\n        u_upwind_e = np.where(u_e = 0, u, np.roll(u, -1, axis=1))\n        v_upwind_e = np.where(u_e = 0, v, np.roll(v, -1, axis=1))\n        F_x_vert = u_e * u_upwind_e\n        F_y_vert = u_e * v_upwind_e\n\n        # North/South faces (normal in y-dir)\n        v_n = 0.5 * (v + np.roll(v, -1, axis=0))\n        u_upwind_n = np.where(v_n = 0, u, np.roll(u, -1, axis=0))\n        v_upwind_n = np.where(v_n = 0, v, np.roll(v, -1, axis=0))\n        F_x_horiz = v_n * u_upwind_n\n        F_y_horiz = v_n * v_upwind_n\n\n        Op_C_x = (F_x_vert - np.roll(F_x_vert, 1, axis=1)) / dx + \\\n                 (F_x_horiz - np.roll(F_x_horiz, 1, axis=0)) / dy\n        Op_C_y = (F_y_vert - np.roll(F_y_vert, 1, axis=1)) / dx + \\\n                 (F_y_horiz - np.roll(F_y_horiz, 1, axis=0)) / dy\n        return -Op_C_x, -Op_C_y\n\n    else:\n        raise ValueError(\"Unknown scheme\")\n\ndef compute_diagnostics(u, v, Rx, Ry, dx, dy, dt):\n    \"\"\"\n    Computes the three diagnostic metrics (r_h, delta_h, d_h).\n    \"\"\"\n    cell_area = dx * dy\n\n    # Discrete kinetic energy K_h\n    kh = 0.5 * np.sum(u**2 + v**2) * cell_area\n\n    # Handle case of zero kinetic energy to avoid division by zero\n    if kh  1e-15:\n        return 0.0, 0.0, 0.0\n\n    # Semi-discrete energy production rate r_h\n    dKh_dt = np.sum(u * Rx + v * Ry) * cell_area\n    rh = dKh_dt / kh\n\n    # One-step Euler discrete energy change delta_h\n    u_star = u + dt * Rx\n    v_star = v + dt * Ry\n    kh_star = 0.5 * np.sum(u_star**2 + v_star**2) * cell_area\n    deltah = (kh_star - kh) / kh\n\n    # Discrete divergence magnitude d_h\n    u_e = 0.5 * (u + np.roll(u, -1, axis=1))\n    v_n = 0.5 * (v + np.roll(v, -1, axis=0))\n    div_u = (u_e - np.roll(u_e, 1, axis=1)) / dx + \\\n            (v_n - np.roll(v_n, 1, axis=0)) / dy\n            \n    norm_div_u_sq = np.sum(div_u**2) * cell_area\n    norm_u_sq = np.sum(u**2 + v**2) * cell_area\n    \n    dh = np.sqrt(norm_div_u_sq / norm_u_sq) if norm_u_sq  1e-15 else 0.0\n    \n    return rh, deltah, dh\n\ndef solve():\n    \"\"\"\n    Main function to set up and run all test cases.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, m, n, U0, dt, scheme_name)\n        (32, 32, 2, 3, 1.1, 1e-3, 'skew-symmetric split'),\n        (32, 32, 2, 3, 1.1, 1e-3, 'conservative central flux'),\n        (32, 32, 2, 3, 1.1, 1e-3, 'first-order upwind'),\n        (16,  8, 0, 0, 0.77, 1e-3, 'first-order upwind'),\n        (64,  8, 3, 1, 0.8, 2e-4, 'skew-symmetric split'),\n    ]\n\n    results = []\n    Lx, Ly = 2 * np.pi, 2 * np.pi\n\n    for case in test_cases:\n        Nx, Ny, m, n, U0, dt, scheme = case\n        \n        # Grid setup\n        dx, dy = Lx / Nx, Ly / Ny\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        y_centers = (np.arange(Ny) + 0.5) * dy\n        xx, yy = np.meshgrid(x_centers, y_centers)\n\n        # Velocity field initialization\n        if m = 1 and n = 1:\n            kx = 2 * np.pi * m / Lx\n            ky = 2 * np.pi * n / Ly\n            u = U0 * np.sin(kx * xx) * np.cos(ky * yy)\n            v = -U0 * (kx / ky) * np.cos(kx * xx) * np.sin(ky * yy)\n        elif m == 0 and n == 0:\n            u = U0 * np.ones((Ny, Nx))\n            v = np.zeros((Ny, Nx))\n        else:\n            # Other cases not specified in the problem\n            raise ValueError(f\"Velocity field for (m,n)=({m},{n}) not defined.\")\n\n        # Compute convective term\n        Rx, Ry = compute_convection(u, v, dx, dy, scheme)\n        \n        # Compute diagnostics\n        rh, deltah, dh = compute_diagnostics(u, v, Rx, Ry, dx, dy, dt)\n        results.append([rh, deltah, dh])\n\n    # Format output\n    output_str = '[' + ','.join([f\"[{r},{d},{div}]\" for r, d, div in results]) + ']'\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world CFD problems are often too large to run on a single processor, necessitating parallel computing. The key to an efficient parallel implementation is minimizing communication between processors, which begins with a careful analysis of the data dependencies of your numerical scheme. This problem  challenges you to think like a parallel programmer by deriving the minimal \"halo\" or \"ghost cell\" data that must be exchanged to correctly compute fluxes at processor boundaries for a second-order accurate scheme, a critical first step in designing scalable solvers.",
            "id": "3297763",
            "problem": "Consider a compressible system of conservation laws for a state vector $\\mathbf{U} \\in \\mathbb{R}^{m}$ posed on a bounded domain in $\\mathbb{R}^{D}$, discretized by a cell-centered unstructured finite volume method. The semi-discrete update for a control volume $C_{i}$ with volume $|C_{i}|$ is obtained by applying the divergence theorem to the conservation law and approximating the face fluxes by a numerical flux function that takes left and right limiting values at each face. Each processor holds a disjoint subset of cells, and the mesh is partitioned across processors such that any face whose adjacent cells lie on different processors is called a partition-interface face. Denote by $N_{\\Gamma}$ the number of partition-interface faces adjacent to a given processor.\n\nThe face-based numerical flux at a face with centroid $\\mathbf{x}_{f}$ requires the left and right face states, $\\mathbf{U}_{L,f}$ and $\\mathbf{U}_{R,f}$, constructed by linear second-order reconstruction from the adjacent cell averages, with a slope limiter whose evaluation for a given cell depends only on that cell and its one-ring set of face-adjacent neighbors. Specifically, for a cell $i$ with centroid $\\mathbf{x}_{i}$ and average $\\overline{\\mathbf{U}}_{i}$, the reconstruction is of the form $\\mathbf{U}(\\mathbf{x}) \\approx \\overline{\\mathbf{U}}_{i} + \\nabla \\mathbf{U}_{i} \\cdot (\\mathbf{x} - \\mathbf{x}_{i})$, where $\\nabla \\mathbf{U}_{i} \\in \\mathbb{R}^{m \\times D}$ is a limited gradient obtained from a least-squares fit over the one-ring neighbor set. Assume that the numerical flux requires both $\\mathbf{U}_{L,f}$ and $\\mathbf{U}_{R,f}$ at each face $f$ on the processor, including partition-interface faces.\n\nA halo exchange (also called ghost exchange) communicates data from neighboring processors to populate ghost cells that mirror off-processor cells. A ghost layer of depth $d$ contains $d$ rings of off-processor cells adjacent to the processor’s subdomain. The processors can choose either to:\n- compute reconstructions for off-processor (ghost) cells locally using received ghost layers of sufficient depth, or\n- receive from neighbors the already-limited gradients of off-processor cells to avoid deeper ghost layers.\n\nStarting from the integral finite volume formulation and the definition of second-order reconstruction and its data dependencies, derive the minimal ghost-layer depth $d_{\\min}$ required so that a processor can compute all of its face-based fluxes with second-order accuracy for faces it owns, without performing any iterative or multi-stage communications within a time step. Under the strategy that minimizes ghost-layer depth, also derive a closed-form expression for the total number $E$ of scalar values that a processor must receive per time step to perform all of its face-based flux computations, expressed in terms of $m$, $D$, and $N_{\\Gamma}$. Assume each scalar is a single real number and that each partition-interface face corresponds to exactly one distinct off-processor neighboring cell across that face.\n\nReport your final answer as a row matrix $\\begin{pmatrix} E  d_{\\min} \\end{pmatrix}$, where $E$ is the total count of received scalar values per time step and $d_{\\min}$ is the minimal ghost-layer depth as an integer. No numerical values are to be substituted for $m$, $D$, or $N_{\\Gamma}$, and no rounding is required.",
            "solution": "The problem statement is scrutinized and found to be valid. It is scientifically grounded in the principles of computational fluid dynamics and parallel computing, well-posed, objective, and internally consistent. It describes a standard scenario for parallel finite volume methods and asks for a derivation of data dependencies and communication costs, which is a formal and solvable problem. No flaws are identified. We may therefore proceed with a full solution.\n\nThe problem asks for two quantities: the minimal ghost-layer depth, $d_{\\min}$, required for a processor to compute its second-order fluxes, and the total number of scalar values, $E$, that must be received per time step under the strategy that achieves this minimal depth.\n\nLet us analyze the data dependencies for the numerical scheme. The semi-discrete finite volume update for a cell $C_i$ on a given processor requires the computation of numerical fluxes at all its faces. For faces internal to the processor's subdomain, all required data is locally available. The critical case is a partition-interface face, let's call it $f$, which separates a local cell $C_i$ from an off-processor cell $C_j$. The cell $C_j$ is a \"ghost cell\" for our processor, belonging to the first layer of the halo, since it is a direct face-neighbor of a local cell.\n\nThe numerical flux at face $f$, denoted $\\mathbf{F}(\\mathbf{U}_{L,f}, \\mathbf{U}_{R,f})$, depends on the left and right reconstructed states at the face centroid $\\mathbf{x}_f$.\nThe left state, $\\mathbf{U}_{L,f}$, is reconstructed from the local cell $C_i$. The second-order reconstruction is given by:\n$$ \\mathbf{U}_{L,f} = \\mathbf{U}_i(\\mathbf{x}_f) = \\overline{\\mathbf{U}}_{i} + \\nabla \\mathbf{U}_{i} \\cdot (\\mathbf{x}_f - \\mathbf{x}_{i}) $$\nHere, $\\overline{\\mathbf{U}}_{i}$ is the cell-average state vector in $C_i$, which is known locally. The term $\\nabla \\mathbf{U}_{i}$ is the limited gradient of the state vector in cell $C_i$. The problem specifies that this gradient is computed using a least-squares fit over the one-ring face-adjacent neighbors of $C_i$, and the subsequent limiting step also depends only on this one-ring neighborhood. Since $C_i$ is adjacent to the partition boundary at face $f$, one of its neighbors is the ghost cell $C_j$. Therefore, to compute $\\nabla \\mathbf{U}_{i}$, the processor must have access to the cell-average state vector $\\overline{\\mathbf{U}}_{j}$ of the ghost cell $C_j$. This establishes a dependency on data from the first ring of ghost cells.\n\nThe right state, $\\mathbf{U}_{R,f}$, is reconstructed from the ghost cell $C_j$:\n$$ \\mathbf{U}_{R,f} = \\mathbf{U}_j(\\mathbf{x}_f) = \\overline{\\mathbf{U}}_{j} + \\nabla \\mathbf{U}_{j} \\cdot (\\mathbf{x}_f - \\mathbf{x}_{j}) $$\nTo evaluate this state, our processor needs access to both the cell-average $\\overline{\\mathbf{U}}_{j}$ and the limited gradient $\\nabla \\mathbf{U}_{j}$ of the ghost cell. The problem presents two strategies for obtaining $\\nabla \\mathbf{U}_{j}$:\n\n1.  **Compute ghost gradients locally:** The local processor computes $\\nabla \\mathbf{U}_{j}$ itself. To do this, it would need access to the cell averages of all one-ring neighbors of $C_j$. The cell $C_j$ is a first-layer ghost cell (a neighbor of local cell $C_i$). Its neighbors, in turn, include $C_i$ (which is local) and other cells on the neighboring processor. These other neighbors of $C_j$ are neighbors-of-a-neighbor to our local domain, and thus constitute a second layer of ghost cells. To compute $\\nabla \\mathbf{U}_{j}$, we would need to receive the cell averages of these second-layer ghost cells. This strategy, therefore, requires a ghost-layer depth of $d=2$.\n\n2.  **Receive pre-computed ghost gradients:** The neighboring processor, which owns cell $C_j$, computes its own limited gradient $\\nabla \\mathbf{U}_{j}$ and sends it to our processor along with the cell-average $\\overline{\\mathbf{U}}_{j}$. In this case, to compute $\\mathbf{U}_{R,f}$, our processor only needs to receive data associated with the first-layer ghost cell $C_j$. To compute $\\mathbf{U}_{L,f}$, as established before, we also only need data from first-layer ghost cells (specifically, $\\overline{\\mathbf{U}}_{j}$). Thus, all flux computations can be completed by receiving data pertaining only to the first ring of ghost cells. This corresponds to a ghost-layer depth of $d=1$.\n\nTo find the minimal ghost-layer depth, $d_{\\min}$, we compare the two strategies. Strategy 2 requires $d=1$, while Strategy 1 requires $d=2$. The minimum of these is 1.\n$$ d_{\\min} = 1 $$\n\nNext, we derive the total number of received scalar values per time step, $E$, under the minimal-depth strategy (Strategy 2).\nThe problem states there are $N_{\\Gamma}$ partition-interface faces. The assumption \"each partition-interface face corresponds to exactly one distinct off-processor neighboring cell\" implies that the processor's subdomain is adjacent to exactly $N_{\\Gamma}$ unique ghost cells, which form the first-layer halo.\n\nUnder the minimal-depth strategy, for each of these $N_{\\Gamma}$ ghost cells (let's use index $j$ for them), the processor must receive the data required for all its computations. As derived above, this entails:\na) The cell-average $\\overline{\\mathbf{U}}_{j}$ is needed to compute the gradients $\\nabla \\mathbf{U}_{i}$ for all local cells $i$ adjacent to the boundary.\nb) The cell-average $\\overline{\\mathbf{U}}_{j}$ and the pre-computed limited gradient $\\nabla \\mathbf{U}_{j}$ are needed to evaluate the reconstructed state $\\mathbf{U}_{R,f}$ at interface faces.\n\nSo, for each of the $N_{\\Gamma}$ ghost cells, the processor must receive the pair $(\\overline{\\mathbf{U}}_{j}, \\nabla \\mathbf{U}_{j})$. Let's count the number of scalars this represents.\n- The state vector $\\mathbf{U}$ is an element of $\\mathbb{R}^{m}$, so the cell-average $\\overline{\\mathbf{U}}_{j}$ consists of $m$ scalar values.\n- The gradient $\\nabla \\mathbf{U}_{j}$ is a matrix in $\\mathbb{R}^{m \\times D}$ (a gradient vector in $\\mathbb{R}^D$ for each of the $m$ state variables). This consists of $m \\times D$ scalar values.\n\nThe total number of scalars to be received for a single ghost cell is $m + mD = m(1+D)$.\nSince there are $N_{\\Gamma}$ such unique ghost cells, the total number of scalars, $E$, that the processor must receive per time step is:\n$$ E = N_{\\Gamma} \\times m(1+D) $$\nThis expression represents the total communication volume for the halo exchange under the optimal strategy for minimizing ghost layer depth.\n\nThe question asks for the final answer as a row matrix $\\begin{pmatrix} E  d_{\\min} \\end{pmatrix}$. Substituting our derived expressions, we obtain the final result.",
            "answer": "$$\\boxed{\\begin{pmatrix} N_{\\Gamma} m (1+D)  1 \\end{pmatrix}}$$"
        }
    ]
}