{
    "hands_on_practices": [
        {
            "introduction": "在将计算流体动力学（CFD）代码用于实际研究之前，我们必须严格验证其实现的正确性。制造解方法（Method of Manufactured Solutions, MMS）是验证代码的金标准，它通过构建一个解析解并将其代入控制方程以推导源项，来检验数值代码能否达到其设计的收敛精度。这项实践将帮助你构建对离散算子实现的信心，并掌握验证代码正确性的核心技能 。",
            "id": "3297768",
            "problem": "要求您为非定常不可压缩纳维-斯托克斯方程设计并实现一个制造解方法（MMS）验证测试。该测试在二维周期性单位正方形上，采用单元中心有限体积框架。您的任务是选择一个解析的速度-压力对，推导出相应的彻体力源项和边界条件，然后通过将全离散算子应用于解析场并测量离散残差随网格细化的缩放情况，来计算观测到的精度阶。\n\n基本方程是在域 $\\Omega = [0,1]\\times[0,1]$ 上，双向均为周期性边界条件的非定常不可压缩纳维-斯托克斯系统：\n- 动量方程：$\\dfrac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nu \\nabla^2 \\boldsymbol{u} = \\boldsymbol{f}$，\n- 连续性方程：$\\nabla\\cdot\\boldsymbol{u} = 0$，\n其中 $\\boldsymbol{u}=(u,v)$ 是速度， $p$ 是压力除以密度，$\\nu$ 是运动粘度，$\\boldsymbol{f}=(f_u,f_v)$ 是彻体力。三角函数的参数以弧度为单位。\n\n请按以下步骤进行。\n\n1) 制造场和边界条件：\n- 选择一个形式为 $\\psi(x,y,t) = A \\sin(k x)\\sin(k y)\\cos(\\omega t)$ 的流函数 $\\psi(x,y,t)$，其中 $A>0$，$k = 2\\pi$，$\\omega = 2\\pi$；通过 $\\boldsymbol{u} = (\\partial\\psi/\\partial y,\\ -\\partial\\psi/\\partial x)$ 定义制造速度，通过 $p(x,y,t) = P\\cos(k x)\\cos(k y)\\sin(\\omega t)$（其中 $P>0$）定义制造压力。这种构造使得 $\\nabla\\cdot\\boldsymbol{u} = 0$ 恒成立。\n- 将 $(\\boldsymbol{u},p)$ 代入动量方程并整理以分离出 $\\boldsymbol{f}$，从而推导出源项 $\\boldsymbol{f}(x,y,t)$。指定与此选择兼容的边界条件；由于场是 $1$-周期的，在 $x$ 和 $y$ 方向均使用周期性边界。\n\n2) 单元中心有限体积离散化：\n- 在覆盖 $\\Omega$ 的区域上使用一个均匀的 $N\\times N$ 单元中心网格，其中 $N\\in\\mathbb{N}$，单元宽度 $\\Delta x = \\Delta y = h = 1/N$，单元中心位于 $(x_i,y_j)=((i+\\tfrac{1}{2})h,(j+\\tfrac{1}{2})h)$，对于 $i,j\\in\\{0,\\dots,N-1\\}$。\n- 使用二阶中心差分以守恒有限体积形式离散化空间算子：\n  - u-动量方程中守恒形式的对流项 $\\nabla\\cdot(u\\boldsymbol{u})$，通过计算面法向通量进行离散化：在东西向面上的通量为 $F_{i+1/2,j} = u_{i+1/2,j}^2$，在南北向面上的通量为 $G_{i,j+1/2} = u_{i,j+1/2}v_{i,j+1/2}$，其中 $u_{i+1/2,j}$ 表示相邻单元中心值的算术平均值；v-动量方程使用 $F_{i+1/2,j} = u_{i+1/2,j}v_{i+1/2,j}$ 和 $G_{i,j+1/2} = v_{i,j+1/2}^2$。在域边界处通过环绕方式应用周期性。\n  - 压力梯度使用中心差分：$(\\partial p/\\partial x)_{i,j} \\approx \\dfrac{p_{i+1,j}-p_{i-1,j}}{2\\Delta x}$ 和 $(\\partial p/\\partial y)_{i,j} \\approx \\dfrac{p_{i,j+1}-p_{i,j-1}}{2\\Delta y}$，使用周期性索引。\n  - 拉普拉斯算子使用标准的 $5$-点模板：$(\\nabla^2 \\phi)_{i,j} \\approx \\dfrac{\\phi_{i+1,j}+\\phi_{i-1,j}-2\\phi_{i,j}}{\\Delta x^2} + \\dfrac{\\phi_{i,j+1}+\\phi_{i,j-1}-2\\phi_{i,j}}{\\Delta y^2}$，适用于任何标量场 $\\phi$。\n- 使用单参数 $\\theta$-格式（其中 $\\theta \\in [\\tfrac{1}{2},1]$）离散化时间：对于作用于 $(\\boldsymbol{u},p)$ 的任何算子 $\\mathcal{L}$，定义 $\\mathcal{L}^{n+\\theta} = (1-\\theta)\\mathcal{L}^n + \\theta \\mathcal{L}^{n+1}$，并通过 $(\\boldsymbol{u}^{n+1}-\\boldsymbol{u}^n)/\\Delta t$ 离散化非定常项。这在每个单元上产生一个全离散残差：\n$$\n\\boldsymbol{R}_{i,j} = \\frac{\\boldsymbol{u}_{i,j}^{n+1}-\\boldsymbol{u}_{i,j}^{n}}{\\Delta t} + \\left[\\nabla\\cdot(\\boldsymbol{u}\\otimes\\boldsymbol{u})\\right]_{i,j}^{n+\\theta} + \\left[\\nabla p\\right]_{i,j}^{n+\\theta} - \\nu \\left[\\nabla^2 \\boldsymbol{u}\\right]_{i,j}^{n+\\theta} - \\boldsymbol{f}_{i,j}^{n+\\theta}.\n$$\n\n3) 观测精度阶的测量：\n- 对于给定的参数集 $(\\nu,\\theta,A,P,t_0,c)$（其中 $c>0$），定义网格尺寸 $N\\in\\{16,32,64,128\\}$，设置 $\\Delta t = c\\,h$（其中 $h=1/N$），并定义 $t^n = t_0$ 和 $t^{n+1} = t_0 + \\Delta t$。在每个网格尺寸下，计算这些时刻的精确场 $(\\boldsymbol{u}^n,p^n)$ 和 $(\\boldsymbol{u}^{n+1},p^{n+1})$ 以及精确源项 $\\boldsymbol{f}$，应用全离散残差 $\\boldsymbol{R}$，并计算残差向量在整个域上的离散 $L^2$ 范数，\n$$\nE(h) = \\left( \\sum_{i,j} \\left( R_{u,i,j}^2 + R_{v,i,j}^2 \\right) h^2 \\right)^{1/2}.\n$$\n- 对四个网格尺寸的 $(\\log h, \\log E(h))$ 数据使用最小二乘法拟合一条直线；观测到的阶数为负斜率 $p_{\\mathrm{obs}} = -\\dfrac{d\\log E}{d\\log h}$。\n\n您的程序必须为以下参数集（角度以弧度为单位）的测试套件实现上述所有步骤，每个参数集表示为 $(\\nu,\\theta,c,A,P,t_0)$：\n- 情况1（标准路径，混合对流-扩散，时间二阶精度）：$(0.1,\\,0.5,\\,0.2,\\,1.0,\\,1.0,\\,0.07)$。\n- 情况2（边缘情况，无粘性极限，时间二阶精度）：$(0.0,\\,0.5,\\,0.2,\\,0.8,\\,1.2,\\,0.13)$。\n- 情况3（时间主导，后向欧拉格式，时间一阶精度）：$(0.1,\\,1.0,\\,0.2,\\,1.0,\\,1.0,\\,0.07)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含情况1-3的三个观测精度阶，格式为逗号分隔的十进制数列表，保留两位小数，并用方括号括起来，例如，“[2.01,2.00,1.01]”。",
            "solution": "用户要求对二维周期性域上的非定常不可压缩纳维-斯托克斯方程的单元中心有限体积离散化进行制造解方法（MMS）验证。该过程涉及为给定的制造解推导解析源项，实现离散算子，计算截断误差，并确定观测到的精度阶。\n\n### 步骤1：问题验证\n\n**1.1. 提取已知条件**\n\n- **控制方程**：\n  - 动量方程：$\\dfrac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nu \\nabla^2 \\boldsymbol{u} = \\boldsymbol{f}$\n  - 连续性方程：$\\nabla\\cdot\\boldsymbol{u} = 0$\n- **域**：$\\Omega = [0,1]\\times[0,1]$，具有周期性边界。\n- **制造解**：\n  - 流函数：$\\psi(x,y,t) = A \\sin(k x)\\sin(k y)\\cos(\\omega t)$，其中 $A>0, k = 2\\pi, \\omega = 2\\pi$。\n  - 速度：$\\boldsymbol{u} = (\\partial\\psi/\\partial y,\\ -\\partial\\psi/\\partial x)$。\n  - 压力：$p(x,y,t) = P\\cos(k x)\\cos(k y)\\sin(\\omega t)$，其中 $P>0$。\n- **离散化**：\n  - 网格：均匀 $N\\times N$ 单元中心网格，$\\Delta x = \\Delta y = h = 1/N$。单元中心 $(x_i,y_j)=((i+\\tfrac{1}{2})h,(j+\\tfrac{1}{2})h)$。\n  - 时间步进：$\\theta$-格式，使用 $\\frac{\\boldsymbol{u}^{n+1}-\\boldsymbol{u}^n}{\\Delta t}$。空间算子计算为 $\\mathcal{L}^{n+\\theta} = (1-\\theta)\\mathcal{L}^n + \\theta \\mathcal{L}^{n+1}$。\n  - 空间算子（二阶中心）：\n    - 对流项 $\\nabla\\cdot(\\boldsymbol{u}\\otimes\\boldsymbol{u})$：守恒形式，使用算术平均计算面速度。\n    - 压力梯度 $\\nabla p$：x分量为 $\\dfrac{p_{i+1,j}-p_{i-1,j}}{2\\Delta x}$。\n    - 拉普拉斯算子 $\\nabla^2 \\boldsymbol{u}$：标准 $5$-点模板。\n- **验证过程**：\n  - 对 $N\\in\\{16,32,64,128\\}$ 计算残差的离散 $L^2$ 范数 $E(h) = \\left( \\sum_{i,j} \\left( R_{u,i,j}^2 + R_{v,i,j}^2 \\right) h^2 \\right)^{1/2}$。\n  - 时间步长：$\\Delta t = c\\,h$。\n  - 时间层：$t^n = t_0$， $t^{n+1} = t_0 + \\Delta t$。\n  - 观测精度阶是对 $(\\log h, \\log E(h))$ 进行最小二乘拟合后的负斜率。\n- **测试用例** $(\\nu,\\theta,c,A,P,t_0)$：\n  - 情况1：$(0.1,\\,0.5,\\,0.2,\\,1.0,\\,1.0,\\,0.07)$\n  - 情况2：$(0.0,\\,0.5,\\,0.2,\\,0.8,\\,1.2,\\,0.13)$\n  - 情况3：$(0.1,\\,1.0,\\,0.2,\\,1.0,\\,1.0,\\,0.07)$\n\n**1.2. 使用提取的已知条件进行验证**\n\n- **科学依据**：该问题基于不可压缩流动的基本纳维-斯托克斯方程，这是流体动力学的基石。MMS过程是计算科学中一种标准而严谨的验证技术。所选的制造解是光滑、可微且周期性的，适合于此分析。该问题在科学上是合理的。\n- **适定性**：该问题是适定的。制造解已给出，任务是推导相应的源项，然后测量离散格式的收敛性，这是一个定义明确的计算过程。所有的离散化细节和参数都已明确指定。该任务会导出一个唯一的、有意义的数值结果（精度阶）。\n- **客观性**：该问题以精确、客观的数学和计算术语陈述。它没有歧义、主观性或观点。\n\n**1.3. 结论与行动**\n\n问题陈述是有效的。它具有科学依据，是适定的、客观的，并提供了一套完整且一致的指令。将提供解决方案。\n\n### 步骤2：解析推导\n\n首先，我们推导速度分量并确认其不可压缩性。\n给定流函数 $\\psi(x,y,t) = A \\sin(kx)\\sin(ky)\\cos(\\omega t)$，其中 $k=2\\pi, \\omega=2\\pi$：\n- $u(x,y,t) = \\dfrac{\\partial\\psi}{\\partial y} = Ak \\sin(kx)\\cos(ky)\\cos(\\omega t)$\n- $v(x,y,t) = -\\dfrac{\\partial\\psi}{\\partial x} = -Ak \\cos(kx)\\sin(ky)\\cos(\\omega t)$\n\n速度场的散度为：\n$$ \\nabla\\cdot\\boldsymbol{u} = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} = Ak^2 \\cos(kx)\\cos(ky)\\cos(\\omega t) - Ak^2 \\cos(kx)\\cos(ky)\\cos(\\omega t) = 0 $$\n制造的速度场确实是无散度的，符合要求。\n\n接下来，我们通过将制造解代入动量方程来推导源项 $\\boldsymbol{f}=(f_u, f_v)$：\n$$ \\boldsymbol{f} = \\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nu \\nabla^2 \\boldsymbol{u} $$\n各项推导如下：\n\n- **时间导数**：\n  - $\\dfrac{\\partial u}{\\partial t} = -A k \\omega \\sin(kx)\\cos(ky)\\sin(\\omega t)$\n  - $\\dfrac{\\partial v}{\\partial t} = Ak \\omega \\cos(kx)\\sin(ky)\\sin(\\omega t)$\n\n- **对流项**：$(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u}$。由于 $\\nabla\\cdot\\boldsymbol{u}=0$，这等价于 $\\nabla\\cdot(\\boldsymbol{u}\\otimes\\boldsymbol{u})$。\n  - 对于 u-动量：$(\\boldsymbol{u}\\cdot\\nabla)u = u\\dfrac{\\partial u}{\\partial x} + v\\dfrac{\\partial u}{\\partial y} = \\frac{1}{2}A^2k^3 \\cos^2(\\omega t) \\sin(2kx)$\n  - 对于 v-动量：$(\\boldsymbol{u}\\cdot\\nabla)v = u\\dfrac{\\partial v}{\\partial x} + v\\dfrac{\\partial v}{\\partial y} = \\frac{1}{2}A^2k^3 \\cos^2(\\omega t) \\sin(2ky)$\n\n- **压力梯度**：$\\nabla p$，其中 $p=P\\cos(kx)\\cos(ky)\\sin(\\omega t)$。\n  - $\\dfrac{\\partial p}{\\partial x} = -Pk \\sin(kx)\\cos(ky)\\sin(\\omega t)$\n  - $\\dfrac{\\partial p}{\\partial y} = -Pk \\cos(kx)\\sin(ky)\\sin(\\omega t)$\n\n- **粘性项**：$-\\nu \\nabla^2 \\boldsymbol{u}$。\n  - $\\nabla^2 u = \\dfrac{\\partial^2 u}{\\partial x^2} + \\dfrac{\\partial^2 u}{\\partial y^2} = -2Ak^3 \\sin(kx)\\cos(ky)\\cos(\\omega t) = -2k^2 u$\n  - $\\nabla^2 v = \\dfrac{\\partial^2 v}{\\partial x^2} + \\dfrac{\\partial^2 v}{\\partial y^2} = -2(-Ak\\cos(kx)\\sin(ky)\\cos(\\omega t))k^2 = -2k^2 v$\n  - 因此，$-\\nu \\nabla^2 \\boldsymbol{u} = 2\\nu k^2 \\boldsymbol{u}$。\n\n结合这些项得到源项 $f_u$ 和 $f_v$：\n$$ f_u(x,y,t) = -k\\sin(\\omega t)(A\\omega + P)\\sin(kx)\\cos(ky) + 2A\\nu k^3\\cos(\\omega t)\\sin(kx)\\cos(ky) + \\frac{1}{2}A^2k^3\\cos^2(\\omega t)\\sin(2kx) $$\n$$ f_v(x,y,t) = k\\sin(\\omega t)(A\\omega - P)\\cos(kx)\\sin(ky) - 2A\\nu k^3\\cos(\\omega t)\\cos(kx)\\sin(ky) + \\frac{1}{2}A^2k^3\\cos^2(\\omega t)\\sin(2ky) $$\n\n### 步骤3：离散化与验证实现\n\n实现遵循问题描述。创建一个Python程序来对给定的参数集执行MMS测试。\n\n1.  **网格和场**：对于每个网格尺寸 $N$，生成一个均匀的单元中心网格。在时间层 $t^n = t_0$ 和 $t^{n+1} = t_0 + \\Delta t$ 上，计算单元中心的精确速度、压力和源项场。\n\n2.  **离散算子**：使用二阶中心差分在周期性网格上实现离散空间算子（对流、压力梯度、拉普拉斯算子）的函数。使用`numpy.roll`来高效处理周期性边界条件。\n\n3.  **残差计算**：组装完整的离散残差 $\\boldsymbol{R}$。\n    - 首先，将离散空间算子应用于 $t^n$ 和 $t^{n+1}$ 处的精确解场。\n    - 使用 $\\theta$-加权组合这些结果：$\\mathcal{L}^{n+\\theta} = (1-\\theta)\\mathcal{L}(\\phi^n) + \\theta\\mathcal{L}(\\phi^{n+1})$。\n    - 源项 $\\boldsymbol{f}$ 也在 $t^n$ 和 $t^{n+1}$ 处计算并类似地加权。\n    - 时间导数用 $\\frac{\\boldsymbol{u}^{n+1}-\\boldsymbol{u}^n}{\\Delta t}$ 近似。\n    - 最后，将所有项相加，形成每个单元的残差向量 $\\boldsymbol{R} = (R_u, R_v)$。\n\n4.  **误差范数和精度阶**：为每个网格分辨率 $N$ 计算残差的离散 $L^2$ 范数 $E(h)$。对误差和网格间距的对数 $(\\log h, \\log E(h))$ 进行线性回归。观测到的精度阶是最佳拟合线的斜率的负值。\n\n对三个测试用例中的每一个重复此过程。\n\n- **情况1**：$\\theta=0.5$ (Crank-Nicolson) 在时间上是二阶的。空间离散化是二阶的。当 $\\Delta t \\propto h$ 时，整个格式预期为二阶精度，$p_{\\mathrm{obs}} \\approx 2.0$。\n- **情况2**：无粘性情况（$\\nu=0$），但离散格式与情况1相同。预期阶数也是 $p_{\\mathrm{obs}} \\approx 2.0$。\n- **情况3**：$\\theta=1.0$ (Backward Euler) 在时间上是一阶的。由于空间误差为 $O(h^2)$，时间误差为 $O(\\Delta t) = O(h)$，因此整体精度由时间误差主导。预期阶数为 $p_{\\mathrm{obs}} \\approx 1.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to run the Method of Manufactured Solutions (MMS) verification\n    for the unsteady incompressible Navier-Stokes equations.\n    \"\"\"\n    \n    # --- Mathematical Constants ---\n    K = 2 * np.pi\n    OMEGA = 2 * np.pi\n\n    # --- Analytical Solution Functions ---\n\n    def u_exact(x, y, t, A):\n        \"\"\"Computes the exact u-velocity component.\"\"\"\n        return A * K * np.sin(K * x) * np.cos(K * y) * np.cos(OMEGA * t)\n\n    def v_exact(x, y, t, A):\n        \"\"\"Computes the exact v-velocity component.\"\"\"\n        return -A * K * np.cos(K * x) * np.sin(K * y) * np.cos(OMEGA * t)\n\n    def p_exact(x, y, t, P):\n        \"\"\"Computes the exact pressure component.\"\"\"\n        return P * np.cos(K * x) * np.cos(K * y) * np.sin(OMEGA * t)\n\n    def fu_exact(x, y, t, nu, A, P):\n        \"\"\"Computes the exact source term for the u-momentum equation.\"\"\"\n        term1 = -K * np.sin(OMEGA * t) * (A * OMEGA + P) * np.sin(K * x) * np.cos(K * y)\n        term2 = 2 * A * nu * K**3 * np.cos(OMEGA * t) * np.sin(K * x) * np.cos(K * y)\n        term3 = 0.5 * A**2 * K**3 * np.cos(OMEGA * t)**2 * np.sin(2 * K * x)\n        return term1 + term2 + term3\n\n    def fv_exact(x, y, t, nu, A, P):\n        \"\"\"Computes the exact source term for the v-momentum equation.\"\"\"\n        term1 = K * np.sin(OMEGA * t) * (A * OMEGA - P) * np.cos(K * x) * np.sin(K * y)\n        term2 = -2 * A * nu * K**3 * np.cos(OMEGA * t) * np.cos(K * x) * np.sin(K * y)\n        term3 = 0.5 * A**2 * K**3 * np.cos(OMEGA * t)**2 * np.sin(2 * K * y)\n        return term1 + term2 + term3\n\n    # --- Discrete Operator Functions ---\n\n    def grad_op(p, h):\n        \"\"\"Computes the pressure gradient using second-order central differences.\"\"\"\n        dp_dx = (np.roll(p, -1, axis=1) - np.roll(p, 1, axis=1)) / (2 * h)\n        dp_dy = (np.roll(p, -1, axis=0) - np.roll(p, 1, axis=0)) / (2 * h)\n        return dp_dx, dp_dy\n\n    def lap_op(phi, h):\n        \"\"\"Computes the Laplacian using the standard 5-point stencil.\"\"\"\n        phi_ip1 = np.roll(phi, -1, axis=1)\n        phi_im1 = np.roll(phi, 1, axis=1)\n        phi_jp1 = np.roll(phi, -1, axis=0)\n        phi_jm1 = np.roll(phi, 1, axis=0)\n        \n        lap_phi_x = (phi_ip1 + phi_im1 - 2 * phi) / h**2\n        lap_phi_y = (phi_jp1 + phi_jm1 - 2 * phi) / h**2\n        return lap_phi_x + lap_phi_y\n\n    def conv_op(u, v, h):\n        \"\"\"Computes the conservative form of the convective term.\"\"\"\n        # East-West face values (axis=1 for x-direction)\n        u_face_E = (u + np.roll(u, -1, axis=1)) / 2\n        v_face_E = (v + np.roll(v, -1, axis=1)) / 2\n        \n        # North-South face values (axis=0 for y-direction)\n        u_face_N = (u + np.roll(u, -1, axis=0)) / 2\n        v_face_N = (v + np.roll(v, -1, axis=0)) / 2\n        \n        # Fluxes for u-momentum: F = u*u, G = u*v\n        flux_F_u = u_face_E**2\n        flux_G_u = u_face_N * v_face_N\n        conv_u = (flux_F_u - np.roll(flux_F_u, 1, axis=1)) / h + \\\n                 (flux_G_u - np.roll(flux_G_u, 1, axis=0)) / h\n\n        # Fluxes for v-momentum: F = v*u, G = v*v\n        flux_F_v = v_face_E * u_face_E\n        flux_G_v = v_face_N**2\n        conv_v = (flux_F_v - np.roll(flux_F_v, 1, axis=1)) / h + \\\n                 (flux_G_v - np.roll(flux_G_v, 1, axis=0)) / h\n        \n        return conv_u, conv_v\n\n    # --- Main verification function ---\n\n    def compute_observed_order(case_params):\n        nu, theta, c, A, P, t0 = case_params\n        grid_sizes = [16, 32, 64, 128]\n        log_h_vals = []\n        log_E_vals = []\n\n        for N in grid_sizes:\n            # 1. Grid and time step setup\n            h = 1.0 / N\n            dt = c * h\n            x_coords = (np.arange(N) + 0.5) * h\n            y_coords = (np.arange(N) + 0.5) * h\n            X, Y = np.meshgrid(x_coords, y_coords, indexing='xy')\n            \n            t_n = t0\n            t_np1 = t0 + dt\n\n            # 2. Evaluate exact solution fields at t_n and t_np1\n            u_n, v_n = u_exact(X, Y, t_n, A), v_exact(X, Y, t_n, A, )\n            p_n = p_exact(X, Y, t_n, P)\n            u_np1, v_np1 = u_exact(X, Y, t_np1, A), v_exact(X, Y, t_np1, A)\n            p_np1 = p_exact(X, Y, t_np1, P)\n\n            # 3. Evaluate and weight source terms\n            f_u_n, f_v_n = fu_exact(X, Y, t_n, nu, A, P), fv_exact(X, Y, t_n, nu, A, P)\n            f_u_np1, f_v_np1 = fu_exact(X, Y, t_np1, nu, A, P), fv_exact(X, Y, t_np1, nu, A, P)\n            f_u_ntheta = (1 - theta) * f_u_n + theta * f_u_np1\n            f_v_ntheta = (1 - theta) * f_v_n + theta * f_v_np1\n            \n            # 4. Compute and weight discrete spatial operators\n            conv_u_n, conv_v_n = conv_op(u_n, v_n, h)\n            grad_px_n, grad_py_n = grad_op(p_n, h)\n            lap_u_n, lap_v_n = lap_op(u_n, h), lap_op(v_n, h)\n            \n            conv_u_np1, conv_v_np1 = conv_op(u_np1, v_np1, h)\n            grad_px_np1, grad_py_np1 = grad_op(p_np1, h)\n            lap_u_np1, lap_v_np1 = lap_op(u_np1, h), lap_op(v_np1, h)\n            \n            conv_u_ntheta = (1-theta)*conv_u_n + theta*conv_u_np1\n            grad_px_ntheta = (1-theta)*grad_px_n + theta*grad_px_np1\n            lap_u_ntheta = (1-theta)*lap_u_n + theta*lap_u_np1\n            \n            conv_v_ntheta = (1-theta)*conv_v_n + theta*conv_v_np1\n            grad_py_ntheta = (1-theta)*grad_py_n + theta*grad_py_np1\n            lap_v_ntheta = (1-theta)*lap_v_n + theta*lap_v_np1\n            \n            # 5. Assemble the residual\n            time_deriv_u = (u_np1 - u_n) / dt\n            R_u = time_deriv_u + conv_u_ntheta + grad_px_ntheta - nu * lap_u_ntheta - f_u_ntheta\n            \n            time_deriv_v = (v_np1 - v_n) / dt\n            R_v = time_deriv_v + conv_v_ntheta + grad_py_ntheta - nu * lap_v_ntheta - f_v_ntheta\n            \n            # 6. Compute discrete L2 norm of the residual\n            E_h = np.sqrt(np.sum(R_u**2 + R_v**2) * h**2)\n            \n            # 7. Store log values for regression\n            log_h_vals.append(np.log(h))\n            log_E_vals.append(np.log(E_h))\n\n        # 8. Perform linear regression and return observed order\n        slope, _, _, _, _ = linregress(log_h_vals, log_E_vals)\n        return -slope\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case 1: (nu, theta, c, A, P, t0) -> Expected Order: 2\n        (0.1, 0.5, 0.2, 1.0, 1.0, 0.07),\n        # Case 2: -> Expected Order: 2\n        (0.0, 0.5, 0.2, 0.8, 1.2, 0.13),\n        # Case 3: -> Expected Order: 1\n        (0.1, 1.0, 0.2, 1.0, 1.0, 0.07),\n    ]\n\n    results = []\n    for case in test_cases:\n        order = compute_observed_order(case)\n        results.append(order)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{order:.2f}\" for order in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "精度并非衡量数值格式优劣的唯一标准。对于某些问题，如湍流或无粘流的长时间模拟，离散地保持动能等物理不变量对于保证计算的长期稳定性和物理保真度至关重要。本实践将探讨对流项的不同离散格式如何影响动能守恒，这是高级数值格式设计中的一个关键考量 。",
            "id": "3297733",
            "problem": "考虑在二维周期性域上的不可压缩对流动力学，该动力学通过在均匀笛卡尔网格上使用单元中心有限体积法进行离散化。设域为 $\\Omega = [0,L_x] \\times [0,L_y]$，在两个方向上均具有周期性边界。设 $N_x$ 和 $N_y$ 分别表示 $x$ 和 $y$ 方向上控制体的数量，均匀间距为 $\\Delta x = L_x / N_x$ 和 $\\Delta y = L_y / N_y$。未知量是单元中心的速度分量 $u_{i,j}$ 和 $v_{i,j}$，其中 $i \\in \\{0,1,\\ldots,N_x-1\\}$ 且 $j \\in \\{0,1,\\ldots,N_y-1\\}$。\n\n基本基础是守恒形式的不可压缩欧拉方程（无外力，单位密度），\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + \\nabla \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u}) + \\nabla p = \\boldsymbol{0}, \\quad \\nabla \\cdot \\boldsymbol{u} = 0,\n$$\n以及动能\n$$\nK(t) = \\frac{1}{2} \\int_{\\Omega} \\lVert \\boldsymbol{u}(\\boldsymbol{x},t) \\rVert^2 \\, \\mathrm{d}\\Omega,\n$$\n在周期性边界条件下，连续对流项使其随时间守恒。在单元中心有限体积法中，我们为向量场 $\\boldsymbol{a}$ 和 $\\boldsymbol{b}$ 定义一个离散内积\n$$\n\\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle_h = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left( a_{i,j}^{(x)} b_{i,j}^{(x)} + a_{i,j}^{(y)} b_{i,j}^{(y)} \\right) \\Delta x \\Delta y,\n$$\n以及离散动能 $K_h = \\frac{1}{2} \\langle \\boldsymbol{u}, \\boldsymbol{u} \\rangle_h$。\n\n您将使用三种在同位网格上对流算子的有限体积离散化方法，这些方法使用通过算术平均组装的面上中心值：\n- 守恒中心通量形式 $-\\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})$，其中每个面通量使用相邻单元值的算术平均来重构面上中心速度。\n- 斜对称分裂形式 $-\\frac{1}{2} \\left( \\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u}) + (\\boldsymbol{u} \\cdot \\nabla_h) \\boldsymbol{u} \\right)$，其中 $(\\boldsymbol{u} \\cdot \\nabla_h)$ 在单元中心使用中心差分，$\\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})$ 使用守恒中心通量散度。\n- 一阶迎风通量形式 $-\\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})$，其中面上中心值根据面法向速度的符号从迎风的施主单元中获取。\n\n所有离散微分算子必须在均匀网格上使用周期性环绕索引。在每个垂直面上，定义面上中心值 $u_e = \\frac{1}{2}(u_{i,j} + u_{i+1,j})$，$v_e = \\frac{1}{2}(v_{i,j} + v_{i+1,j})$；在每个水平面上，定义 $u_n = \\frac{1}{2}(u_{i,j} + u_{i,j+1})$，$v_n = \\frac{1}{2}(v_{i,j} + v_{i,j+1})$。垂直面上的 $x$-动量的守恒中心通量为 $F^{(x)}_{\\text{vert}} = u_e^2$，水平面上的为 $F^{(x)}_{\\text{horiz}} = u_n v_n$。类似地，对于 $y$-动量，$F^{(y)}_{\\text{vert}} = u_e v_e$ 且 $F^{(y)}_{\\text{horiz}} = v_n^2$。一个控制体中的离散守恒散度是净通量差除以单元尺寸，例如对于垂直面是 $(F_e - F_w)/\\Delta x$，其中 $F_w$ 是单元西侧垂直面上的通量；对于水平面是 $(F_n - F_s)/\\Delta y$。\n\n提出以下由整数 $m$ 和 $n$、振幅 $U_0$ 以及域长度 $L_x$ 和 $L_y$ 参数化的周期性测试速度场：\n- 对于 $m \\ge 1$ 和 $n \\ge 1$，定义波数 $k_x = \\frac{2\\pi m}{L_x}$ 和 $k_y = \\frac{2\\pi n}{L_y}$ 以及解析场\n$$\nu(x,y) = U_0 \\sin(k_x x) \\cos(k_y y), \\qquad v(x,y) = - U_0 \\frac{k_x}{k_y} \\cos(k_x x) \\sin(k_y y),\n$$\n该场是解析无散度的。\n- 对于均匀流的边缘情况 $m = 0$ 和 $n = 0$，定义 $u(x,y) = U_0$ 和 $v(x,y) = 0$，这是一个常数场。\n\n通过在单元中心 $x_i = \\left(i + \\frac{1}{2} \\right) \\Delta x$ 和 $y_j = \\left(j + \\frac{1}{2} \\right) \\Delta y$ 对这些场进行采样来离散化 $u$ 和 $v$。然后，对于选定的对流离散化，定义半离散更新\n$$\n\\frac{\\mathrm{d}\\boldsymbol{u}}{\\mathrm{d}t} = \\boldsymbol{R}(\\boldsymbol{u}),\n$$\n以及以下诊断指标：\n- 由离散动能归一化的半离散能量产生率，\n$$\nr_h = \\frac{\\langle \\boldsymbol{u}, \\boldsymbol{R}(\\boldsymbol{u}) \\rangle_h}{K_h}.\n$$\n- 时间步长为 $\\Delta t$ 的单步显式欧拉离散动能变化，\n$$\n\\delta_h = \\frac{K_h^{\\star} - K_h}{K_h}, \\quad \\text{其中} \\quad \\boldsymbol{u}^{\\star} = \\boldsymbol{u} + \\Delta t \\, \\boldsymbol{R}(\\boldsymbol{u}), \\; K_h^{\\star} = \\frac{1}{2} \\langle \\boldsymbol{u}^{\\star}, \\boldsymbol{u}^{\\star} \\rangle_h.\n$$\n- 由速度 $\\ell_2$ 范数归一化的离散散度大小，\n$$\nd_h = \\frac{\\left( \\sum_{i,j} \\left( \\nabla_h \\cdot \\boldsymbol{u} \\right)_{i,j}^2 \\, \\Delta x \\Delta y \\right)^{1/2}}{\\left( \\sum_{i,j} \\left( u_{i,j}^2 + v_{i,j}^2 \\right) \\, \\Delta x \\Delta y \\right)^{1/2}},\n$$\n其中 $\\nabla_h \\cdot \\boldsymbol{u}$ 是根据面法向速度 $(u_e, v_n)$ 计算的有限体积散度。\n\n从基本守恒定律和周期性假设出发，推导为什么对于中心差分和周期性环绕，斜对称分裂形式具有 $\\langle \\boldsymbol{u}, \\boldsymbol{R}(\\boldsymbol{u}) \\rangle_h = 0$（在舍入误差范围内），无论 $\\nabla_h \\cdot \\boldsymbol{u}$ 如何；以及为什么守恒中心通量形式具有 $\\langle \\boldsymbol{u}, \\boldsymbol{R}(\\boldsymbol{u}) \\rangle_h = - \\frac{1}{2} \\langle \\lVert \\boldsymbol{u} \\rVert^2, \\nabla_h \\cdot \\boldsymbol{u} \\rangle_h$（因此如果离散散度为零，则该项也为零）。解释为什么一阶迎风格式由于数值耗散而产生非正的能量。\n\n实现一个程序，构建离散速度场，并为以下每个测试案例计算 $(r_h, \\delta_h, d_h)$（所有案例都在一个域 $L_x = 2\\pi$ 和 $L_y = 2\\pi$ 中）：\n- 案例 1：$N_x = 32$, $N_y = 32$, $m = 2$, $n = 3$, $U_0 = 1.1$, $\\Delta t = 10^{-3}$，斜对称分裂形式。\n- 案例 2：$N_x = 32$, $N_y = 32$, $m = 2$, $n = 3$, $U_0 = 1.1$, $\\Delta t = 10^{-3}$，守恒中心通量形式。\n- 案例 3：$N_x = 32$, $N_y = 32$, $m = 2$, $n = 3$, $U_0 = 1.1$, $\\Delta t = 10^{-3}$，一阶迎风通量形式。\n- 案例 4：$N_x = 16$, $N_y = 8$, $m = 0$, $n = 0$, $U_0 = 0.77$, $\\Delta t = 10^{-3}$，一阶迎风通量形式（均匀流边缘情况）。\n- 案例 5：$N_x = 64$, $N_y = 8$, $m = 3$, $n = 1$, $U_0 = 0.8$, $\\Delta t = 2 \\times 10^{-4}$，斜对称分裂形式（各向异性网格）。\n\n您的程序必须为每个测试案例输出诊断三元组 $(r_h, \\delta_h, d_h)$，格式如下：单行包含一个类 JSON 的列表的列表，其中每个内部列表按 $[r_h,\\delta_h,d_h]$ 的顺序排列，使用 Python 的默认浮点数字符串格式。例如，输出应类似于 $[[r_1,\\delta_1,d_1],[r_2,\\delta_2,d_2],\\ldots]$。\n\n所有角度均以弧度为单位。除了给定的无量纲化之外，不需要任何物理单位。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的、由逗号分隔的列表的列表形式的结果（例如，`[[r_1,δ_1,d_1],[r_2,δ_2,d_2],[r_3,δ_3,d_3],[r_4,δ_4,d_4],[r_5,δ_5,d_5]]`）。",
            "solution": "用户提供了一个有效且适定的计算流体动力学问题。该任务包括两部分：第一部分，对不可压缩欧拉方程中对流项的三种不同有限体积离散格式的动能守恒特性进行理论推导；第二部分，进行数值实现，以计算这些格式在特定测试案例下的诊断指标。\n\n### 第1部分：能量守恒特性的推导\n\n对于半离散系统 $\\frac{\\mathrm{d}\\boldsymbol{u}}{\\mathrm{d}t} = \\boldsymbol{R}(\\boldsymbol{u})$，离散动能 $K_h = \\frac{1}{2} \\langle \\boldsymbol{u}, \\boldsymbol{u} \\rangle_h$ 的变化率由下式给出：\n$$\n\\frac{\\mathrm{d}K_h}{\\mathrm{d}t} = \\left\\langle \\boldsymbol{u}, \\frac{\\mathrm{d}\\boldsymbol{u}}{\\mathrm{d}t} \\right\\rangle_h = \\langle \\boldsymbol{u}, \\boldsymbol{R}(\\boldsymbol{u}) \\rangle_h\n$$\n归一化能量产生率为 $r_h = \\frac{1}{K_h} \\frac{\\mathrm{d}K_h}{\\mathrm{d}t}$。我们对每种格式分析此量。\n\n**1. 斜对称分裂形式**\n\n对流算子为 $\\boldsymbol{R}_{skew}(\\boldsymbol{u}) = -\\frac{1}{2} \\left( \\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u}) + (\\boldsymbol{u} \\cdot \\nabla_h) \\boldsymbol{u} \\right)$。令 $\\boldsymbol{C}(\\boldsymbol{u}) = \\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})$ 为守恒部分，$\\boldsymbol{A}(\\boldsymbol{u}) = (\\boldsymbol{u} \\cdot \\nabla_h) \\boldsymbol{u}$ 为平流部分。两者均在周期性网格上使用中心差分和算术平均进行离散化。\n\n此类离散化的一个基本性质（可通过分部求和法，即分部积分的离散等价形式来证明）是，离散算子 $\\boldsymbol{C}$ 和 $\\boldsymbol{A}$ 相对于离散内积互为负转置。即，对于任意两个离散向量场 $\\boldsymbol{\\phi}$ 和 $\\boldsymbol{\\psi}$：\n$$\n\\langle \\boldsymbol{\\phi}, \\boldsymbol{C}(\\boldsymbol{\\psi}) \\rangle_h = - \\langle \\boldsymbol{A}(\\boldsymbol{\\psi})\\boldsymbol{\\phi}, \\boldsymbol{1} \\rangle_h\n$$\n我们需要的性质是，总算子 $\\boldsymbol{R}_{skew}$ 是斜对称的，即对于任意两个场 $\\boldsymbol{\\phi}$ 和 $\\boldsymbol{\\psi}$：\n$$\n\\langle \\boldsymbol{\\phi}, \\boldsymbol{R}_{skew}(\\boldsymbol{\\psi}) \\rangle_h = - \\langle \\boldsymbol{\\psi}, \\boldsymbol{R}_{skew}(\\boldsymbol{\\phi}) \\rangle_h\n$$\n对于 $\\boldsymbol{R}_{skew}$ 的指定构造，此性质成立。设 $\\boldsymbol{\\phi} = \\boldsymbol{\\psi} = \\boldsymbol{u}$，我们得到：\n$$\n\\langle \\boldsymbol{u}, \\boldsymbol{R}_{skew}(\\boldsymbol{u}) \\rangle_h = - \\langle \\boldsymbol{u}, \\boldsymbol{R}_{skew}(\\boldsymbol{u}) \\rangle_h\n$$\n这意味着 $\\langle \\boldsymbol{u}, \\boldsymbol{R}_{skew}(\\boldsymbol{u}) \\rangle_h = 0$。因此，半离散动能是精确守恒的，能量产生率 $r_h = 0$，无论离散速度场是否无散度。这在机器浮点精度范围内成立。\n\n**2. 守恒中心通量形式**\n\n算子为 $\\boldsymbol{R}_{cons}(\\boldsymbol{u}) = - \\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})$。能量产生为 $\\langle \\boldsymbol{u}, \\boldsymbol{R}_{cons}(\\boldsymbol{u}) \\rangle_h$。推导过程与其连续形式类似。在连续情况下，由对流引起的动能变化率为：\n$$\n\\frac{\\mathrm{d}K}{\\mathrm{d}t} = - \\int_{\\Omega} \\boldsymbol{u} \\cdot (\\nabla \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})) \\, \\mathrm{d}\\Omega\n$$\n使用向量恒等式 $\\boldsymbol{u} \\cdot (\\nabla \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})) = (\\boldsymbol{u} \\cdot \\nabla)\\frac{\\lVert\\boldsymbol{u}\\rVert^2}{2} + \\lVert\\boldsymbol{u}\\rVert^2(\\nabla \\cdot \\boldsymbol{u})$，并对第一项应用散度定理（在周期性域上该项为零），可得：\n$$\n\\frac{\\mathrm{d}K}{\\mathrm{d}t} = -\\frac{1}{2} \\int_{\\Omega} \\lVert\\boldsymbol{u}\\rVert^2 (\\nabla \\cdot \\boldsymbol{u}) \\, \\mathrm{d}\\Omega\n$$\n中心差分格式的构建旨在模仿这些连续性质。通过离散分部求和法，可以证明离散格式满足一个类似的恒等式：\n$$\n\\langle \\boldsymbol{u}, \\boldsymbol{R}_{cons}(\\boldsymbol{u}) \\rangle_h = -\\frac{1}{2} \\langle \\lVert \\boldsymbol{u} \\rVert^2, \\nabla_h \\cdot \\boldsymbol{u} \\rangle_h\n$$\n其中 $\\lVert \\boldsymbol{u} \\rVert^2$ 是单元中心速度大小平方的场，即 $(u_{i,j}^2 + v_{i,j}^2)$。该关系表明，守恒中心通量形式仅在离散速度场无散度时才守恒能量，即对于所有单元 $(\\nabla_h \\cdot \\boldsymbol{u})_{i,j} = 0$。所提供的解析速度场在连续意义上是无散度的，但其离散采样不一定保证离散无散度，这可能导致能量的产生或耗散。\n\n**3. 一阶迎风通量形式**\n\n一阶迎风格式根据垂直于单元面的速度方向来确定该面上对流物理量的值。对于法向速度为 $u_n$ 的面，迎风通量可以写成中心差分通量与一个耗散项之和：\n$$\nF_{upwind} = F_{central} - \\frac{1}{2} |u_n| \\Delta x(\\text{gradient term})\n$$\n该通量的散度在动量方程中引入了一个类似于物理粘性的项，因此被称为“数值粘性”或“数值扩散”。完整的算子 $\\boldsymbol{R}_{upwind}$ 可以表示为：\n$$\n\\boldsymbol{R}_{upwind}(\\boldsymbol{u}) = \\boldsymbol{R}_{central}(\\boldsymbol{u}) + \\boldsymbol{D}(\\boldsymbol{u})\n$$\n其中 $\\boldsymbol{D}(\\boldsymbol{u})$ 代表数值扩散算子，其形式为 $\\nabla_h \\cdot (\\nu_h \\nabla_h \\boldsymbol{u})$。数值粘性系数 $\\nu_h$ 总是非负的，与局部速度大小和网格间距成正比。\n\n这个耗散项对动能方程的贡献是：\n$$\n\\langle \\boldsymbol{u}, \\boldsymbol{D}(\\boldsymbol{u}) \\rangle_h = \\langle \\boldsymbol{u}, \\nabla_h \\cdot (\\nu_h \\nabla_h \\boldsymbol{u}) \\rangle_h\n$$\n使用分部求和法，这变为：\n$$\n\\langle \\boldsymbol{u}, \\boldsymbol{D}(\\boldsymbol{u}) \\rangle_h = - \\langle \\nabla_h \\boldsymbol{u}, \\nu_h \\nabla_h \\boldsymbol{u} \\rangle_h = - \\sum_{i,j} \\nu_h \\lVert \\nabla_h \\boldsymbol{u} \\rVert^2_{i,j} \\Delta x \\Delta y \\le 0\n$$\n因为 $\\nu_h \\ge 0$，该项总是从流场中移除动能。总能量产生率 $\\langle \\boldsymbol{u}, \\boldsymbol{R}_{upwind}(\\boldsymbol{u}) \\rangle_h$ 是中心项（可正可负）和耗散项（始终非正）之和。对于大多数流动，耗散效应占主导地位，导致净能量产生为非正值，$r_h \\le 0$。\n\n### 第2部分：数值实现与结果\n\n以下 Python 代码实现了指定的有限体积格式，并计算了五个给定测试案例的诊断指标。",
            "answer": "```python\nimport numpy as np\n\ndef compute_convection(u, v, dx, dy, scheme):\n    \"\"\"\n    Computes the convective term R(u) for different schemes.\n    R(u) is the RHS of d(u)/dt = R(u).\n    \"\"\"\n\n    # --- Central Conservative Operator: Op_C(u) = grad_h . (u tensor u) ---\n    def compute_op_central(u, v, dx, dy):\n        # Face-centered velocities (arithmetic average)\n        u_e = 0.5 * (u + np.roll(u, -1, axis=1))\n        v_e = 0.5 * (v + np.roll(v, -1, axis=1))\n        u_n = 0.5 * (u + np.roll(u, -1, axis=0))\n        v_n = 0.5 * (v + np.roll(v, -1, axis=0))\n\n        # Fluxes\n        F_x_vert = u_e**2\n        F_x_horiz = u_n * v_n\n        F_y_vert = u_e * v_e\n        F_y_horiz = v_n**2\n\n        # Divergence of fluxes\n        Op_C_x = (F_x_vert - np.roll(F_x_vert, 1, axis=1)) / dx + \\\n                 (F_x_horiz - np.roll(F_x_horiz, 1, axis=0)) / dy\n        Op_C_y = (F_y_vert - np.roll(F_y_vert, 1, axis=1)) / dx + \\\n                 (F_y_horiz - np.roll(F_y_horiz, 1, axis=0)) / dy\n        return Op_C_x, Op_C_y\n\n    # --- Central Advective Operator: Op_A(u) = (u . grad_h) u ---\n    def compute_op_advective(u, v, dx, dy):\n        du_dx = (np.roll(u, -1, axis=1) - np.roll(u, 1, axis=1)) / (2 * dx)\n        du_dy = (np.roll(u, -1, axis=0) - np.roll(u, 1, axis=0)) / (2 * dy)\n        dv_dx = (np.roll(v, -1, axis=1) - np.roll(v, 1, axis=1)) / (2 * dx)\n        dv_dy = (np.roll(v, -1, axis=0) - np.roll(v, 1, axis=0)) / (2 * dy)\n\n        Op_A_x = u * du_dx + v * du_dy\n        Op_A_y = u * dv_dx + v * dv_dy\n        return Op_A_x, Op_A_y\n\n    if scheme == 'conservative central flux':\n        Op_C_x, Op_C_y = compute_op_central(u, v, dx, dy)\n        return -Op_C_x, -Op_C_y\n\n    elif scheme == 'skew-symmetric split':\n        Op_C_x, Op_C_y = compute_op_central(u, v, dx, dy)\n        Op_A_x, Op_A_y = compute_op_advective(u, v, dx, dy)\n        Rx = -0.5 * (Op_C_x + Op_A_x)\n        Ry = -0.5 * (Op_C_y + Op_A_y)\n        return Rx, Ry\n\n    elif scheme == 'first-order upwind':\n        # East/West faces (normal in x-dir)\n        u_e = 0.5 * (u + np.roll(u, -1, axis=1))\n        u_upwind_e = np.where(u_e >= 0, u, np.roll(u, -1, axis=1))\n        v_upwind_e = np.where(u_e >= 0, v, np.roll(v, -1, axis=1))\n        F_x_vert = u_e * u_upwind_e\n        F_y_vert = u_e * v_upwind_e\n\n        # North/South faces (normal in y-dir)\n        v_n = 0.5 * (v + np.roll(v, -1, axis=0))\n        u_upwind_n = np.where(v_n >= 0, u, np.roll(u, -1, axis=0))\n        v_upwind_n = np.where(v_n >= 0, v, np.roll(v, -1, axis=0))\n        F_x_horiz = v_n * u_upwind_n\n        F_y_horiz = v_n * v_upwind_n\n\n        Op_C_x = (F_x_vert - np.roll(F_x_vert, 1, axis=1)) / dx + \\\n                 (F_x_horiz - np.roll(F_x_horiz, 1, axis=0)) / dy\n        Op_C_y = (F_y_vert - np.roll(F_y_vert, 1, axis=1)) / dx + \\\n                 (F_y_horiz - np.roll(F_y_horiz, 1, axis=0)) / dy\n        return -Op_C_x, -Op_C_y\n\n    else:\n        raise ValueError(\"Unknown scheme\")\n\ndef compute_diagnostics(u, v, Rx, Ry, dx, dy, dt):\n    \"\"\"\n    Computes the three diagnostic metrics (r_h, delta_h, d_h).\n    \"\"\"\n    cell_area = dx * dy\n\n    # Discrete kinetic energy K_h\n    kh = 0.5 * np.sum(u**2 + v**2) * cell_area\n\n    # Handle case of zero kinetic energy to avoid division by zero\n    if kh  1e-15:\n        return 0.0, 0.0, 0.0\n\n    # Semi-discrete energy production rate r_h\n    dKh_dt = np.sum(u * Rx + v * Ry) * cell_area\n    rh = dKh_dt / kh\n\n    # One-step Euler discrete energy change delta_h\n    u_star = u + dt * Rx\n    v_star = v + dt * Ry\n    kh_star = 0.5 * np.sum(u_star**2 + v_star**2) * cell_area\n    deltah = (kh_star - kh) / kh\n\n    # Discrete divergence magnitude d_h\n    u_e = 0.5 * (u + np.roll(u, -1, axis=1))\n    v_n = 0.5 * (v + np.roll(v, -1, axis=0))\n    div_u = (u_e - np.roll(u_e, 1, axis=1)) / dx + \\\n            (v_n - np.roll(v_n, 1, axis=0)) / dy\n            \n    norm_div_u_sq = np.sum(div_u**2) * cell_area\n    norm_u_sq = np.sum(u**2 + v**2) * cell_area\n    \n    dh = np.sqrt(norm_div_u_sq / norm_u_sq) if norm_u_sq > 1e-15 else 0.0\n    \n    return rh, deltah, dh\n\ndef solve():\n    \"\"\"\n    Main function to set up and run all test cases.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, m, n, U0, dt, scheme_name)\n        (32, 32, 2, 3, 1.1, 1e-3, 'skew-symmetric split'),\n        (32, 32, 2, 3, 1.1, 1e-3, 'conservative central flux'),\n        (32, 32, 2, 3, 1.1, 1e-3, 'first-order upwind'),\n        (16,  8, 0, 0, 0.77, 1e-3, 'first-order upwind'),\n        (64,  8, 3, 1, 0.8, 2e-4, 'skew-symmetric split'),\n    ]\n\n    results = []\n    Lx, Ly = 2 * np.pi, 2 * np.pi\n\n    for case in test_cases:\n        Nx, Ny, m, n, U0, dt, scheme = case\n        \n        # Grid setup\n        dx, dy = Lx / Nx, Ly / Ny\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        y_centers = (np.arange(Ny) + 0.5) * dy\n        xx, yy = np.meshgrid(y_centers, x_centers)\n        xx = xx.T # Transpose to match x-major indexing\n        yy = yy.T\n\n        # Velocity field initialization\n        if m >= 1 and n >= 1:\n            kx = 2 * np.pi * m / Lx\n            ky = 2 * np.pi * n / Ly\n            u = U0 * np.sin(kx * xx) * np.cos(ky * yy)\n            v = -U0 * (kx / ky) * np.cos(kx * xx) * np.sin(ky * yy)\n        elif m == 0 and n == 0:\n            u = U0 * np.ones((Nx, Ny))\n            v = np.zeros((Nx, Ny))\n        else:\n            # Other cases not specified in the problem\n            raise ValueError(f\"Velocity field for (m,n)=({m},{n}) not defined.\")\n\n        # Compute convective term\n        Rx, Ry = compute_convection(u, v, dx, dy, scheme)\n        \n        # Compute diagnostics\n        rh, deltah, dh = compute_diagnostics(u, v, Rx, Ry, dx, dy, dt)\n        results.append([rh, deltah, dh])\n\n    # Format output\n    output_str = '[' + ','.join([f\"[{r},{d},{div}]\" for r, d, div in results]) + ']'\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的CFD问题通常规模巨大，远超单处理器的计算能力，因此必须依赖并行计算。并行性能的一个关键方面是最小化处理器之间的通信开销。这项实践将深入分析有限体积格式的数据依赖关系，以确定必要的通信模式（即“晕轮”或“影子”层交换），并设计出高效的并行策略 。",
            "id": "3297763",
            "problem": "考虑一个在$\\mathbb{R}^{D}$有界域上定义的可压缩守恒律系统，其状态向量为$\\mathbf{U} \\in \\mathbb{R}^{m}$，该系统通过格心非结构有限体积法进行离散。对于体积为$|C_{i}|$的控制体$C_{i}$，其半离散更新通过对守恒律应用散度定理，并使用一个在每个面上取左右极限值的数值通量函数来近似面通量而得到。每个处理器持有一部分不相交的网格单元子集，网格被划分到不同处理器上，任何相邻网格单元位于不同处理器上的面都称为分区界面。用$N_{\\Gamma}$表示与给定处理器相邻的分区界面的数量。\n\n在形心为$\\mathbf{x}_{f}$的面上的基于面的数值通量需要左右两边的面状态$\\mathbf{U}_{L,f}$和$\\mathbf{U}_{R,f}$。这些状态是通过对相邻网格单元的平均值进行线性二阶重构得到的，并使用了一个斜率限制器，该限制器对给定单元的求值仅依赖于该单元及其一圈面相邻的邻居。具体而言，对于一个形心为$\\mathbf{x}_{i}$、平均值为$\\overline{\\mathbf{U}}_{i}$的单元$i$，其重构形式为$\\mathbf{U}(\\mathbf{x}) \\approx \\overline{\\mathbf{U}}_{i} + \\nabla \\mathbf{U}_{i} \\cdot (\\mathbf{x} - \\mathbf{x}_{i})$，其中$\\nabla \\mathbf{U}_{i} \\in \\mathbb{R}^{m \\times D}$是一个受限梯度，通过对一圈邻居集合进行最小二乘拟合得到。假设处理器上每个面$f$（包括分区界面）的数值通量都需要$\\mathbf{U}_{L,f}$和$\\mathbf{U}_{R,f}$。\n\nhalo交换（也称为ghost交换）从相邻处理器通信数据，以填充反映处理器外单元的ghost单元。深度为$d$的ghost层包含与处理器子域相邻的$d$圈处理器外单元。处理器可以选择：\n- 使用接收到的足够深度的ghost层在本地计算处理器外（ghost）单元的重构，或者\n- 从邻居接收处理器外单元已经限制过的梯度，以避免更深的ghost层。\n\n从积分形式的有限体积公式以及二阶重构及其数据依赖性的定义出发，推导所需的最小ghost层深度$d_{\\min}$，使得处理器能够为其拥有的面计算所有具有二阶精度的基于面的通量，而无需在单个时间步内执行任何迭代或多阶段通信。在最小化ghost层深度的策略下，同时推导一个处理器为执行其所有基于面的通量计算而必须在每个时间步接收的标量值总数$E$的闭式表达式，该表达式用$m$、$D$和$N_{\\Gamma}$表示。假设每个标量是一个实数，并且每个分区界面恰好对应于该界面对面的一个不同的处理器外邻居单元。\n\n将你的最终答案表示为一个行矩阵$\\begin{pmatrix} E  d_{\\min} \\end{pmatrix}$，其中$E$是每个时间步接收的标量值总数，$d_{\\min}$是作为整数的最小ghost层深度。不得为$m$、$D$或$N_{\\Gamma}$代入任何数值，也不需要进行四舍五入。",
            "solution": "对问题陈述进行了审慎分析，认定其有效。该问题基于计算流体力学和并行计算的原理，问题设定良好、客观且内部一致。它描述了并行有限体积方法的标准场景，并要求推导数据依赖性和通信成本，这是一个形式化且可解的问题。未发现任何缺陷。因此，我们可以进行完整求解。\n\n问题要求两个量：处理器计算其二阶通量所需的最小ghost层深度$d_{\\min}$，以及在实现此最小深度的策略下，每个时间步必须接收的标量值总数$E$。\n\n让我们分析该数值格式的数据依赖性。给定处理器上一个单元$C_i$的半离散有限体积更新需要计算其所有面上的数值通量。对于处理器子域内部的面，所有需要的数据都在本地可用。关键情况是分区界面，我们称之为$f$，它将一个本地单元$C_i$与一个处理器外单元$C_j$分开。单元$C_j$是本处理器的“ghost单元”，属于halo的第一层，因为它是本地单元的直接面邻居。\n\n面$f$上的数值通量，记为$\\mathbf{F}(\\mathbf{U}_{L,f}, \\mathbf{U}_{R,f})$，取决于面形心$\\mathbf{x}_f$处的左右重构状态。\n左状态$\\mathbf{U}_{L,f}$由本地单元$C_i$重构得到。其二阶重构由下式给出：\n$$ \\mathbf{U}_{L,f} = \\mathbf{U}_i(\\mathbf{x}_f) = \\overline{\\mathbf{U}}_{i} + \\nabla \\mathbf{U}_{i} \\cdot (\\mathbf{x}_f - \\mathbf{x}_{i}) $$\n此处，$\\overline{\\mathbf{U}}_{i}$是$C_i$中的单元平均状态向量，这是本地已知的。项$\\nabla \\mathbf{U}_{i}$是单元$C_i$中状态向量的受限梯度。问题指明，该梯度是通过对$C_i$的一圈面相邻邻居进行最小二乘拟合计算的，并且随后的限制步骤也只依赖于这一圈邻居。由于$C_i$在面$f$处与分区边界相邻，其邻居之一是ghost单元$C_j$。因此，为了计算$\\nabla \\mathbf{U}_{i}$，处理器必须能访问ghost单元$C_j$的单元平均状态向量$\\overline{\\mathbf{U}}_{j}$。这建立起了对第一圈ghost单元数据的依赖。\n\n右状态$\\mathbf{U}_{R,f}$由ghost单元$C_j$重构得到：\n$$ \\mathbf{U}_{R,f} = \\mathbf{U}_j(\\mathbf{x}_f) = \\overline{\\mathbf{U}}_{j} + \\nabla \\mathbf{U}_{j} \\cdot (\\mathbf{x}_f - \\mathbf{x}_{j}) $$\n为了计算这个状态，我们的处理器需要访问ghost单元的单元平均值$\\overline{\\mathbf{U}}_{j}$和受限梯度$\\nabla \\mathbf{U}_{j}$。问题提出了两种获取$\\nabla \\mathbf{U}_{j}$的策略：\n\n1.  **在本地计算ghost梯度：** 本地处理器自行计算$\\nabla \\mathbf{U}_{j}$。为此，它需要访问$C_j$的所有一圈邻居的单元平均值。单元$C_j$是第一层ghost单元（本地单元$C_i$的邻居）。它的邻居又包括$C_i$（这是本地的）和邻近处理器上的其他单元。$C_j$的这些其他邻居对于我们的本地域来说是邻居的邻居，因此构成了第二层ghost单元。为了计算$\\nabla \\mathbf{U}_{j}$，我们需要接收这些第二层ghost单元的单元平均值。因此，该策略需要$d=2$的ghost层深度。\n\n2.  **接收预先计算好的ghost梯度：** 拥有单元$C_j$的邻近处理器计算自己的受限梯度$\\nabla \\mathbf{U}_{j}$，并将其与单元平均值$\\overline{\\mathbf{U}}_{j}$一起发送给我们的处理器。在这种情况下，要计算$\\mathbf{U}_{R,f}$，我们的处理器只需要接收与第一层ghost单元$C_j$相关的数据。如前所述，要计算$\\mathbf{U}_{L,f}$，我们也只需要来自第一层ghost单元的数据（特别是$\\overline{\\mathbf{U}}_{j}$）。因此，所有通量计算都可以通过接收仅与第一圈ghost单元有关的数据来完成。这对应于$d=1$的ghost层深度。\n\n为了找到最小ghost层深度$d_{\\min}$，我们比较这两种策略。策略2需要$d=1$，而策略1需要$d=2$。这两者中的最小值是$1$。\n$$ d_{\\min} = 1 $$\n\n接下来，我们推导在最小深度策略（策略2）下，每个时间步接收的标量值总数$E$。\n问题陈述中有$N_{\\Gamma}$个分区界面。假设“每个分区界面恰好对应于一个不同的处理器外邻居单元”意味着处理器的子域与恰好$N_{\\Gamma}$个唯一的ghost单元相邻，这些ghost单元构成了第一层halo。\n\n在最小深度策略下，对于这$N_{\\Gamma}$个ghost单元中的每一个（我们用索引$j$表示它们），处理器必须接收其所有计算所需的数据。如上所述，这包括：\na) 需要单元平均值$\\overline{\\mathbf{U}}_{j}$来计算所有与边界相邻的本地单元$i$的梯度$\\nabla \\mathbf{U}_{i}$。\nb) 需要单元平均值$\\overline{\\mathbf{U}}_{j}$和预先计算好的受限梯度$\\nabla \\mathbf{U}_{j}$来计算界面上的重构状态$\\mathbf{U}_{R,f}$。\n\n所以，对于$N_{\\Gamma}$个ghost单元中的每一个，处理器必须接收数据对$(\\overline{\\mathbf{U}}_{j}, \\nabla \\mathbf{U}_{j})$。让我们计算一下这代表了多少个标量。\n- 状态向量$\\mathbf{U}$是$\\mathbb{R}^{m}$中的一个元素，所以单元平均值$\\overline{\\mathbf{U}}_{j}$包含$m$个标量值。\n- 梯度$\\nabla \\mathbf{U}_{j}$是$\\mathbb{R}^{m \\times D}$中的一个矩阵（对于$m$个状态变量中的每一个，都有一个在$\\mathbb{R}^D$中的梯度向量）。这包含$m \\times D$个标量值。\n\n为单个ghost单元接收的标量总数为$m + mD = m(1+D)$。\n由于存在$N_{\\Gamma}$个这样的唯一ghost单元，处理器在每个时间步必须接收的标量总数$E$为：\n$$ E = N_{\\Gamma} \\times m(1+D) $$\n该表达式表示在最小化ghost层深度的最优策略下，halo交换的总通信量。\n\n问题要求最终答案以行矩阵$\\begin{pmatrix} E  d_{\\min} \\end{pmatrix}$的形式给出。代入我们推导出的表达式，我们得到最终结果。",
            "answer": "$$\\boxed{\\begin{pmatrix} N_{\\Gamma} m (1+D)  1 \\end{pmatrix}}$$"
        }
    ]
}