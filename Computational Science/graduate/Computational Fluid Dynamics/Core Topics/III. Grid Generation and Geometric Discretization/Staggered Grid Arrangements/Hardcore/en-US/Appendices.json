{
    "hands_on_practices": [
        {
            "introduction": "Perhaps the most fundamental motivation for the staggered grid arrangement is its ability to prevent the spurious pressure oscillations, known as \"checkerboarding,\" that can plague simpler collocated grids. This hands-on exercise provides a direct, numerical demonstration of this phenomenon. By manufacturing a force that excites the problematic checkerboard mode, you will see how a naive collocated discretization fails to respond, while the Marker-and-Cell (MAC) staggered grid robustly couples pressure to momentum, naturally suppressing the non-physical solution .",
            "id": "3365597",
            "problem": "Consider the steady, incompressible Stokes equations on a two-dimensional periodic domain of length $L=1$ in each direction, with spatial coordinates $(x,y)$ and velocity field $\\mathbf{u}(x,y) = (u(x,y), v(x,y))$:\n$$\n-\\nabla p + \\nu \\nabla^2 \\mathbf{u} = \\mathbf{f}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\nwhere $p(x,y)$ is the pressure, $\\nu$ is the kinematic viscosity, and $\\mathbf{f}(x,y)$ is a given body force. In a fractional-step projection approach, the pressure field $p$ is recovered from the following Poisson equation for pressure associated with enforcing discrete incompressibility:\n$$\n\\nabla^2 p = s,\n$$\nwhere $s$ is a discrete source constructed from the divergence of an intermediate velocity field. On a uniform Cartesian grid with spacing $\\Delta x = \\Delta y$, different grid arrangements lead to different discrete gradient and divergence operators. In particular:\n- The collocated (cell-centered) arrangement places $u$, $v$, and $p$ all at cell centers. A common naive central-difference implementation computes the discrete pressure gradient at centers using nearest neighbors in each coordinate direction:\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{coll}} = \\frac{p_{i+1,j} - p_{i-1,j}}{2 \\Delta x}, \\quad\n\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{coll}} = \\frac{p_{i,j+1} - p_{i,j-1}}{2 \\Delta x}.\n$$\n- The Marker-and-Cell (MAC) staggered arrangement places $u$ on vertical faces at $(i+\\tfrac{1}{2}, j)$, $v$ on horizontal faces at $(i, j+\\tfrac{1}{2})$, and $p$ at cell centers $(i,j)$. The discrete pressure gradient naturally appears at faces:\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i+\\frac{1}{2},j}^{\\text{MAC}} = \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}, \\quad\n\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+\\frac{1}{2}}^{\\text{MAC}} = \\frac{p_{i,j+1} - p_{i,j}}{\\Delta x}.\n$$\n\nIt is known that collocated central differences admit a spurious pressure mode, often called a checkerboard mode, which is defined on an $N_x \\times N_y$ uniform periodic grid by\n$$\np_{i,j}^{\\text{chk}} = (-1)^{i+j}, \\quad i = 0,1,\\dots,N_x-1, \\quad j = 0,1,\\dots,N_y-1,\n$$\nand corresponds to the highest resolvable spatial frequency (the Nyquist mode). This mode can be excited by certain discrete forcings and, on collocated grids, can decouple from the momentum equations under naive interpolation from centers to faces, leading to nonphysical oscillations in $p$ that do not drive momentum. In contrast, the MAC staggering suppresses this decoupling because the face-centered discrete gradient directly samples adjacent cell-center pressures, and the checkerboard difference does not vanish at faces.\n\nYour task is to:\n1. Use a manufactured source $s_{i,j} = (-1)^{i+j}$ to excite the checkerboard mode in the discrete pressure Poisson equation with periodic boundary conditions, discretized by the standard five-point Laplacian. The discrete Fourier symbol of the five-point Laplacian on a uniform grid of spacing $\\Delta x$ is\n$$\n\\lambda(k_x,k_y) = \\frac{2}{\\Delta x^2}\\left(\\cos(k_x \\Delta x)-1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos(k_y \\Delta x)-1\\right),\n$$\nfor discrete wavenumbers $k_x = \\frac{2\\pi m}{L}$, $k_y = \\frac{2\\pi n}{L}$, where $m = 0,1,\\dots,N_x-1$ and $n = 0,1,\\dots,N_y-1$. The checkerboard mode corresponds to $(m,n) = (N_x/2, N_y/2)$ when $N_x$ and $N_y$ are even, giving $\\cos(\\pi) = -1$ and thus\n$$\n\\lambda_{\\text{chk}} = -\\frac{4}{\\Delta x^2} - \\frac{4}{\\Delta x^2} = -\\frac{8}{\\Delta x^2}.\n$$\nFrom this, the pressure amplitude associated with the checkerboard forcing scales as\n$$\nA_p(\\Delta x) = \\frac{1}{|\\lambda_{\\text{chk}}|} = \\frac{\\Delta x^2}{8}.\n$$\n2. Numerically solve the discrete periodic Poisson equation $\\nabla^2 p = s$ using the discrete Laplacian symbol above in the Fourier domain for a sequence of uniform grids, and extract the numerical amplitude $A_p(\\Delta x)$ of the checkerboard component by projecting the computed $p$ onto $p^{\\text{chk}}$.\n3. Compute and compare the root-mean-square (RMS) magnitude of the face-centered pressure gradient that would enter the momentum equations under:\n   - A collocated naive face-gradient obtained by averaging cell-centered gradients at adjacent cells to faces:\n   $$\n   \\left(\\frac{\\partial p}{\\partial x}\\right)_{i+\\frac{1}{2},j}^{\\text{col-face}} = \\frac{1}{2}\\left[\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{col}} + \\left(\\frac{\\partial p}{\\partial x}\\right)_{i+1,j}^{\\text{col}}\\right], \\quad\n   \\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+\\frac{1}{2}}^{\\text{col-face}} = \\frac{1}{2}\\left[\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{col}} + \\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+1}^{\\text{col}}\\right].\n   $$\n   - The MAC face-gradient, as defined above. The RMS magnitude is defined as\n   $$\n   G_{\\text{RMS}} = \\sqrt{\\frac{1}{N_f}\\sum_{f} g_f^2},\n   $$\n   where $g_f$ ranges over all face gradient components in both directions and $N_f$ is the number of faces.\n4. Demonstrate numerically that:\n   - The collocated naive face-gradient is blind to the checkerboard component so that its RMS magnitude is numerically zero for the manufactured forcing, explaining the decoupling.\n   - The MAC face-gradient couples to the checkerboard mode, and its RMS magnitude scales like $\\mathcal{O}(\\Delta x)$ for the manufactured forcing because $A_p(\\Delta x) \\sim \\Delta x^2$ and the face gradient scales like $A_p(\\Delta x)/\\Delta x$.\n\nImplement a program that:\n- Builds the manufactured source $s_{i,j} = (-1)^{i+j}$ on a periodic domain of length $L=1$.\n- Solves the discrete Poisson equation in Fourier space using the discrete Laplacian symbol to obtain $p_{i,j}$.\n- Computes the numerical checkerboard amplitude $A_p(\\Delta x)$ via projection onto $(-1)^{i+j}$.\n- Computes $G_{\\text{RMS}}^{\\text{col-face}}$ and $G_{\\text{RMS}}^{\\text{MAC}}$ for the resulting $p_{i,j}$.\n- Reports the tuple $(A_p(\\Delta x), G_{\\text{RMS}}^{\\text{col-face}}, G_{\\text{RMS}}^{\\text{MAC}})$ for each grid.\n\nTest Suite:\n- Use square grids with $N_x=N_y$ and $L=1$ for the following cases:\n  1. $N_x=N_y=8$ (coarse grid, $\\Delta x = 1/8$).\n  2. $N_x=N_y=16$ (moderate grid, $\\Delta x = 1/16$).\n  3. $N_x=N_y=32$ (fine grid, $\\Delta x = 1/32$).\n  4. $N_x=N_y=64$ (very fine grid, $\\Delta x = 1/64$).\nAll reported quantities are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list of four bracketed tuples, each tuple ordered as $(A_p(\\Delta x), G_{\\text{RMS}}^{\\text{col-face}}, G_{\\text{RMS}}^{\\text{MAC}})$ in the same order as the test cases, for example:\n\"[(a1,b1,c1),(a2,b2,c2),(a3,b3,c3),(a4,b4,c4)]\".",
            "solution": "We begin from the steady incompressible Stokes equations\n$$\n-\\nabla p + \\nu \\nabla^2 \\mathbf{u} = \\mathbf{f}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\nwhich, under a fractional-step approach, leads to enforcing discrete incompressibility via a pressure Poisson equation\n$$\n\\nabla^2 p = s,\n$$\nwhere the source $s$ is obtained from the divergence of an intermediate velocity. On a uniform periodic grid, solving this Poisson equation in the discrete Fourier space is natural and reveals how certain spatial modes propagate into pressure. We focus on the checkerboard (Nyquist) mode,\n$$\np_{i,j}^{\\text{chk}} = (-1)^{i+j},\n$$\nwhich alternates in sign between neighboring cell centers.\n\nFor a uniform grid with spacing $\\Delta x$ and periodic boundary conditions, the standard five-point discrete Laplacian has Fourier symbol\n$$\n\\lambda(k_x,k_y) = \\frac{2}{\\Delta x^2}\\left(\\cos(k_x \\Delta x)-1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos(k_y \\Delta x)-1\\right),\n$$\nwith discrete wavenumbers $k_x = \\frac{2\\pi m}{L}$ and $k_y = \\frac{2\\pi n}{L}$, $m=0,\\dots,N_x-1$, $n=0,\\dots,N_y-1$, and $L=1$. For the checkerboard mode, $(m,n)=(N_x/2, N_y/2)$ and $k_x \\Delta x = \\pi$, $k_y \\Delta x = \\pi$, giving\n$$\n\\lambda_{\\text{chk}} = \\frac{2}{\\Delta x^2}\\left(\\cos \\pi - 1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos \\pi - 1\\right) = \\frac{2}{\\Delta x^2}\\left(-1 - 1\\right) + \\frac{2}{\\Delta x^2}\\left(-1 - 1\\right) = -\\frac{8}{\\Delta x^2}.\n$$\nForcing the Poisson equation with $s_{i,j}=(-1)^{i+j}$ means the right-hand side has only this mode. Therefore the solution is proportional to the same mode:\n$$\np_{i,j} = A_p(\\Delta x)\\, (-1)^{i+j}.\n$$\nPlugging into the discrete Poisson equation in Fourier space yields\n$$\n\\lambda_{\\text{chk}} A_p(\\Delta x) = 1 \\quad \\Rightarrow \\quad A_p(\\Delta x) = -\\frac{1}{\\lambda_{\\text{chk}}} = \\frac{\\Delta x^2}{8}.\n$$\nThus the amplitude of the checkerboard component in the computed pressure scales as $\\Delta x^2$.\n\nThe distinction between collocated and Marker-and-Cell (MAC) staggering enters through how the pressure gradient is represented in the momentum equations:\n- In a collocated (cell-centered) scheme, a common naive implementation uses central differences to estimate $\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{col}}$ and $\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{col}}$ at cell centers. For the checkerboard pressure $p_{i,j} = A_p(\\Delta x)\\,(-1)^{i+j}$,\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{col}} = \\frac{p_{i+1,j} - p_{i-1,j}}{2 \\Delta x}\n= \\frac{A_p(\\Delta x)\\left[(-1)^{i+1+j} - (-1)^{i-1+j}\\right]}{2\\Delta x}\n= \\frac{A_p(\\Delta x)\\,(-1)^{i+j}\\left[-1 - (-1)\\right]}{2\\Delta x} = 0,\n$$\nand a similar calculation shows $\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{col}}=0$. If one then naively forms face gradients by averaging adjacent center gradients, the resulting face pressure gradient that would drive the momentum equations is still zero. This demonstrates the decoupling: the checkerboard pressure produces no face-centered pressure force in the naive collocated scheme.\n- In the MAC staggered arrangement, the face-centered discrete gradient directly takes differences of adjacent center pressures:\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i+\\frac{1}{2},j}^{\\text{MAC}} = \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}\n= \\frac{A_p(\\Delta x)\\left[(-1)^{i+1+j} - (-1)^{i+j}\\right]}{\\Delta x}\n= \\frac{A_p(\\Delta x)\\,(-1)^{i+j}(-1 - 1)}{\\Delta x}\n= -\\frac{2\\,A_p(\\Delta x)}{\\Delta x}\\,(-1)^{i+j}.\n$$\nAn analogous expression holds for $\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+\\frac{1}{2}}^{\\text{MAC}}$. Consequently, the MAC face-gradient couples strongly to the checkerboard and drives momentum corrections that suppress such oscillations. The magnitude of the MAC face-gradient scales like $\\frac{A_p(\\Delta x)}{\\Delta x} \\sim \\frac{\\Delta x^2}{\\Delta x} = \\mathcal{O}(\\Delta x)$ for the manufactured forcing.\n\nAlgorithmic design for the program:\n1. For each test grid with $N_x=N_y$ and $\\Delta x = 1/N_x$, construct the manufactured source $s_{i,j} = (-1)^{i+j}$.\n2. Compute the two-dimensional discrete Fourier transform of $s$ to obtain $\\hat{s}(m,n)$.\n3. For each Fourier mode $(m,n)$, compute the discrete Laplacian symbol $\\lambda(m,n)$ using\n$$\n\\lambda(m,n) = \\frac{2}{\\Delta x^2}\\left(\\cos\\left(\\frac{2\\pi m}{N_x}\\right)-1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos\\left(\\frac{2\\pi n}{N_y}\\right)-1\\right).\n$$\n4. Compute $\\hat{p}(m,n) = \\hat{s}(m,n) / \\lambda(m,n)$ for all $(m,n)$ such that $\\lambda(m,n) \\neq 0$. The zero mode $(m,n)=(0,0)$ is absent in $\\hat{s}$ due to the alternating pattern, so division by zero does not occur.\n5. Inverse transform to obtain $p_{i,j}$ in physical space.\n6. Project $p$ onto the checkerboard pattern to extract the amplitude,\n$$\nA_p(\\Delta x) = \\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} p_{i,j}(-1)^{i+j}.\n$$\n7. Compute collocated center gradients using central differences and then obtain collocated face-gradients by averaging adjacent center gradients to faces. Compute the root-mean-square magnitude over all faces:\n$$\nG_{\\text{RMS}}^{\\text{col-face}} = \\sqrt{\\frac{1}{N_f}\\sum_{f}\\left(g_{f}^{\\text{col-face}}\\right)^2}.\n$$\n8. Compute MAC face-gradients from adjacent center pressures and the corresponding root-mean-square magnitude:\n$$\nG_{\\text{RMS}}^{\\text{MAC}} = \\sqrt{\\frac{1}{N_f}\\sum_{f}\\left(g_{f}^{\\text{MAC}}\\right)^2}.\n$$\n9. Output $(A_p(\\Delta x), G_{\\text{RMS}}^{\\text{col-face}}, G_{\\text{RMS}}^{\\text{MAC}})$ for each grid in the test suite, aggregated into a single line as specified.\n\nExpected behavior:\n- The numerical $A_p(\\Delta x)$ should scale closely with $\\Delta x^2/8$ (up to floating-point and discrete transform normalization).\n- $G_{\\text{RMS}}^{\\text{col-face}}$ should be numerically zero (to machine precision), demonstrating that the naive collocated gradient is blind to checkerboard pressure.\n- $G_{\\text{RMS}}^{\\text{MAC}}$ should scale linearly with $\\Delta x$ for this manufactured forcing because the face gradient magnitude behaves like $2 A_p(\\Delta x)/\\Delta x$.\n\nThis directly exhibits the mechanism by which the Marker-and-Cell (MAC) staggered grid suppresses checkerboard pressure modes: by placing velocities at faces, the discrete pressure gradient is evaluated as a difference of neighboring pressures, which does not vanish for alternating patterns, and thereby couples the spurious mode into momentum where it is damped. In contrast, a naive collocated central difference for the pressure gradient at centers annihilates the alternating component, allowing the spurious pressure mode to persist without influencing the velocity field.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef discrete_laplacian_symbol(nx, ny, dx):\n    \"\"\"\n    Build the discrete Laplacian symbol lambda(m,n) for a periodic grid\n    using the five-point stencil central differences on a uniform grid.\n    \"\"\"\n    # Wavenumber indices m, n\n    m = np.arange(nx)\n    n = np.arange(ny)\n    # Cosine terms for each axis\n    cos_m = np.cos(2.0 * np.pi * m / nx)\n    cos_n = np.cos(2.0 * np.pi * n / ny)\n    # Broadcast to 2D grid of (m,n)\n    lam = (2.0 / dx**2) * (cos_m[:, None] - 1.0) + (2.0 / dx**2) * (cos_n[None, :] - 1.0)\n    return lam\n\ndef solve_poisson_checkerboard(nx, ny, L=1.0):\n    \"\"\"\n    Solve the discrete periodic Poisson equation for s_{i,j} = (-1)^{i+j}\n    using the discrete Laplacian symbol in Fourier space.\n\n    Returns:\n        p: computed pressure field (nx x ny)\n        Ap: numerical checkerboard amplitude via projection onto (-1)^{i+j}\n    \"\"\"\n    dx = L / nx\n    # Manufactured source s = (-1)^{i+j}\n    i = np.arange(nx)[:, None]\n    j = np.arange(ny)[None, :]\n    s = ((-1.0) ** (i + j)).astype(np.float64)\n\n    # FFT of source\n    s_hat = np.fft.fft2(s)\n\n    # Discrete Laplacian symbol\n    lam = discrete_laplacian_symbol(nx, ny, dx)\n\n    # Avoid division by zero: source has zero mean, so lam[0,0] won't be used\n    # Construct p_hat = s_hat / lam\n    # Use where to handle potential zeros robustly (though s_hat[0,0]==0)\n    p_hat = np.zeros_like(s_hat, dtype=np.complex128)\n    mask = lam != 0.0\n    p_hat[mask] = s_hat[mask] / lam[mask]\n\n    # Inverse FFT to get p\n    p = np.real(np.fft.ifft2(p_hat))\n\n    # Compute checkerboard amplitude Ap = mean(p * (-1)^{i+j})\n    pattern = ((-1.0) ** (i + j)).astype(np.float64)\n    Ap = np.sum(p * pattern) / (nx * ny)\n\n    return p, Ap, dx\n\ndef colocated_face_gradient_rms(p, dx):\n    \"\"\"\n    Compute collocated center gradients via central differences and then\n    naive face gradients by averaging adjacent center gradients.\n    Return RMS magnitude over all faces.\n    \"\"\"\n    nx, ny = p.shape\n\n    # Periodic shifts\n    p_ip = np.roll(p, -1, axis=0)\n    p_im = np.roll(p,  1, axis=0)\n    p_jp = np.roll(p, -1, axis=1)\n    p_jm = np.roll(p,  1, axis=1)\n\n    # Center gradients (central difference)\n    gx_c = (p_ip - p_im) / (2.0 * dx)\n    gy_c = (p_jp - p_jm) / (2.0 * dx)  # dx == dy\n\n    # Face gradients: average adjacent center gradients to faces\n    # x-faces at (i+1/2, j): average gx_c[i,j] and gx_c[i+1,j]\n    gx_face = 0.5 * (gx_c + np.roll(gx_c, -1, axis=0))\n    # y-faces at (i, j+1/2): average gy_c[i,j] and gy_c[i,j+1]\n    gy_face = 0.5 * (gy_c + np.roll(gy_c, -1, axis=1))\n\n    # RMS over all faces (both directions)\n    # Number of faces: 2 * nx * ny\n    rms = np.sqrt((np.sum(gx_face**2) + np.sum(gy_face**2)) / (2.0 * nx * ny))\n    return rms\n\ndef mac_face_gradient_rms(p, dx):\n    \"\"\"\n    Compute MAC face gradients directly from adjacent center pressures.\n    Return RMS magnitude over all faces.\n    \"\"\"\n    nx, ny = p.shape\n\n    # x-face gradient: (p_{i+1,j} - p_{i,j}) / dx\n    p_ip = np.roll(p, -1, axis=0)\n    gx_face = (p_ip - p) / dx\n\n    # y-face gradient: (p_{i,j+1} - p_{i,j}) / dx\n    p_jp = np.roll(p, -1, axis=1)\n    gy_face = (p_jp - p) / dx\n\n    rms = np.sqrt((np.sum(gx_face**2) + np.sum(gy_face**2)) / (2.0 * nx * ny))\n    return rms\n\ndef run_test_case(nx):\n    ny = nx\n    p, Ap, dx = solve_poisson_checkerboard(nx, ny, L=1.0)\n    rms_col = colocated_face_gradient_rms(p, dx)\n    rms_mac = mac_face_gradient_rms(p, dx)\n    return (Ap, rms_col, rms_mac)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [8, 16, 32, 64]\n\n    results = []\n    for nx in test_cases:\n        Ap, rms_col, rms_mac = run_test_case(nx)\n        # Format each tuple with reasonable precision\n        results.append(f\"({Ap:.10f},{rms_col:.10e},{rms_mac:.10e})\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond preventing oscillations, a well-designed numerical scheme should accurately represent key physical balances. This practice explores the concept of a \"well-balanced\" scheme, which is a discretization that can exactly preserve important steady-state solutions. You will implement a verification test to show that the MAC grid's discrete pressure gradient perfectly cancels the centrifugal force in a solid-body rotation, demonstrating that the scheme does not introduce numerical errors in this balanced state . This property is crucial for accurately simulating flows dominated by large, opposing forces, such as in geophysical and astrophysical applications.",
            "id": "3365551",
            "problem": "Construct a program that verifies, on a Marker-and-Cell (MAC) staggered grid arrangement, that the discrete pressure gradient exactly cancels the centrifugal force for a rigid-body rotation velocity field. The physical setting is a steady, inviscid flow of a constant-density fluid undergoing rigid-body rotation with angular velocity vector $\\boldsymbol{\\Omega}$, where the velocity is given by $\\mathbf{u} = \\boldsymbol{\\Omega} \\times \\mathbf{r}$, with $\\mathbf{r}$ the position vector. The verification must be performed in the rotating frame where the centrifugal acceleration is modeled as a body force, and the hydrostatic balance is $-\\nabla p + \\rho \\mathbf{a}_{\\mathrm{cf}} = \\mathbf{0}$, for constant density $\\rho$, where $\\mathbf{a}_{\\mathrm{cf}}$ is the centrifugal acceleration. Use the well-tested formula $\\mathbf{a}_{\\mathrm{cf}} = -\\boldsymbol{\\Omega}\\times(\\boldsymbol{\\Omega}\\times \\mathbf{r})$. All quantities must be treated in the International System of Units (SI): positions in meters, time in seconds, mass in kilograms, and angular velocity in radians per second. The final residual must be expressed in $\\mathrm{N/m^3}$.\n\nUse the following MAC grid definitions on a uniform, orthogonal, two-dimensional grid embedded in the plane $z = z_0$:\n- Pressure $p$ is stored at cell centers at coordinates $(x_{i+\\frac{1}{2}}, y_{j+\\frac{1}{2}})$ with $x_{i+\\frac{1}{2}} = x_{\\min} + (i+\\frac{1}{2})\\Delta x$ and $y_{j+\\frac{1}{2}} = y_{\\min} + (j+\\frac{1}{2})\\Delta y$, for integers $i \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$.\n- The $x$-momentum equation is evaluated for the $u$-velocity component, located at the centers of vertical faces at $(x_{i+1}, y_{j+\\frac{1}{2}})$ for $i \\in \\{0,\\dots,N_x-2\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$. The corresponding MAC discrete pressure gradient is $-\\partial p/\\partial x \\approx -\\left(p_{i+1,j} - p_{i,j}\\right)/\\Delta x$.\n- The $y$-momentum equation is evaluated for the $v$-velocity component, located at the centers of horizontal faces at $(x_{i+\\frac{1}{2}}, y_{j+1})$ for $i \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y-2\\}$. The corresponding MAC discrete pressure gradient is $-\\partial p/\\partial y \\approx -\\left(p_{i,j+1} - p_{i,j}\\right)/\\Delta y$.\n\nYou must:\n- Derive from first principles a fluid pressure field $p(\\mathbf{r})$ for constant density $\\rho$ under rigid-body rotation such that the continuous hydrostatic balance $-\\nabla p + \\rho \\mathbf{a}_{\\mathrm{cf}} = \\mathbf{0}$ is satisfied.\n- Using that $p(\\mathbf{r})$, evaluate $p$ at all cell centers, compute the MAC discrete pressure gradients at the face centers, evaluate $\\rho \\mathbf{a}_{\\mathrm{cf}}$ at the same face centers, and then compute the pointwise residuals in the $x$- and $y$-momentum equations: $R_x = -\\left(p_{i+1,j}-p_{i,j}\\right)/\\Delta x + \\rho \\, a_{\\mathrm{cf},x}$ at $x$-faces, and $R_y = -\\left(p_{i,j+1}-p_{i,j}\\right)/\\Delta y + \\rho \\, a_{\\mathrm{cf},y}$ at $y$-faces.\n- Aggregate the result by reporting the maximum absolute residual over all interior faces and both components, i.e., $\\max\\left(\\max_{i,j} |R_x|, \\max_{i,j} |R_y|\\right)$, in $\\mathrm{N/m^3}$.\n\nAngle units: the angular velocity vector components in $\\boldsymbol{\\Omega} = (\\Omega_x,\\Omega_y,\\Omega_z)$ are in radians per second. Distances are in meters. Density is in $\\mathrm{kg/m^3}$. The residuals must be reported in $\\mathrm{N/m^3}$.\n\nTest Suite:\nFor each of the following parameter sets, compute the single scalar output described above.\n\n- Test $1$ (happy path, square cells, axis-aligned angular velocity):\n  - $\\rho = 1000$,\n  - $\\boldsymbol{\\Omega} = (0,0,10)$,\n  - domain: $x \\in [0,1]$, $y \\in [0,1]$, $z_0 = 0$,\n  - grid: $N_x = 64$, $N_y = 64$.\n- Test $2$ (rectangular cells, axis-aligned angular velocity, off-centered domain):\n  - $\\rho = 1$,\n  - $\\boldsymbol{\\Omega} = (0,0,2.5)$,\n  - domain: $x \\in [-2,3]$, $y \\in [-1,1]$, $z_0 = 0$,\n  - grid: $N_x = 50$, $N_y = 20$.\n- Test $3$ (non-axis-aligned angular velocity, nonzero plane offset):\n  - $\\rho = 1.2$,\n  - $\\boldsymbol{\\Omega} = (3,4,5)$,\n  - domain: $x \\in [1,2]$, $y \\in [-0.3,0.7]$, $z_0 = 0.2$,\n  - grid: $N_x = 37$, $N_y = 29$.\n- Test $4$ (minimal interior faces):\n  - $\\rho = 850$,\n  - $\\boldsymbol{\\Omega} = (0,0,0.1)$,\n  - domain: $x \\in [-1,1]$, $y \\in [-1,1]$, $z_0 = 0$,\n  - grid: $N_x = 2$, $N_y = 2$.\n- Test $5$ (larger angular speed, small domain):\n  - $\\rho = 997$,\n  - $\\boldsymbol{\\Omega} = (0,0,1000)$,\n  - domain: $x \\in [0.1,0.2]$, $y \\in [-0.05,0.05]$, $z_0 = 0$,\n  - grid: $N_x = 16$, $N_y = 16$.\n\nYour program must compute, for each test, the single scalar $\\max\\left(\\max_{i,j} |R_x|, \\max_{i,j} |R_y|\\right)$, and finally print a single line containing the results for the tests as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5]$, where each $r_k$ is a floating-point value in $\\mathrm{N/m^3}$.",
            "solution": "The user-provided problem is a well-posed verification exercise in computational fluid dynamics. It is scientifically sound and all required information is provided.\n\nThe problem asks to verify, for a specific case, the property of a Marker-and-Cell (MAC) staggered grid discretization. The physical scenario is a fluid in steady, inviscid rigid-body rotation. In a reference frame rotating with the fluid, the governing equation for a static fluid is the hydrostatic balance between the pressure gradient and the body forces. The only body force considered, besides a uniform gravitational field which can be absorbed into a modified pressure, is the centrifugal force. The balance equation is given as:\n$$-\\nabla p + \\rho \\mathbf{a}_{\\mathrm{cf}} = \\mathbf{0}$$\nwhere $p$ is the pressure, $\\rho$ is the constant fluid density, and $\\mathbf{a}_{\\mathrm{cf}}$ is the centrifugal acceleration. The problem is to demonstrate that the standard MAC grid discretization of this equation results in a zero residual, up to machine precision, when the exact analytical pressure field is used. This is a verification of the discretization's ability to exactly represent a certain class of analytical solutions.\n\n## Principle-Based Design and Derivations\n\n### 1. Analytical Pressure Field Derivation\nFirst, we derive the analytical pressure field $p(\\mathbf{r})$ that satisfies the continuous hydrostatic balance equation. The equation can be written as:\n$$\\nabla p = \\rho \\mathbf{a}_{\\mathrm{cf}}$$\nThe centrifugal acceleration is given by the formula $\\mathbf{a}_{\\mathrm{cf}} = -\\boldsymbol{\\Omega} \\times (\\boldsymbol{\\Omega} \\times \\mathbf{r})$, where $\\boldsymbol{\\Omega}$ is the constant angular velocity vector and $\\mathbf{r}$ is the position vector.\n\nUsing the vector triple product identity $\\mathbf{A} \\times (\\mathbf{B} \\times \\mathbf{C}) = \\mathbf{B}(\\mathbf{A} \\cdot \\mathbf{C}) - \\mathbf{C}(\\mathbf{A} \\cdot \\mathbf{B})$, we expand the expression for $\\mathbf{a}_{\\mathrm{cf}}$:\n$$\\mathbf{a}_{\\mathrm{cf}} = -[\\boldsymbol{\\Omega}(\\boldsymbol{\\Omega} \\cdot \\mathbf{r}) - \\mathbf{r}(\\boldsymbol{\\Omega} \\cdot \\boldsymbol{\\Omega})]$$\n$$\\mathbf{a}_{\\mathrm{cf}} = (\\boldsymbol{\\Omega} \\cdot \\boldsymbol{\\Omega})\\mathbf{r} - (\\boldsymbol{\\Omega} \\cdot \\mathbf{r})\\boldsymbol{\\Omega}$$\nLet $\\Omega^2 = |\\boldsymbol{\\Omega}|^2 = \\boldsymbol{\\Omega} \\cdot \\boldsymbol{\\Omega}$. The pressure gradient is therefore:\n$$\\nabla p = \\rho [ \\Omega^2 \\mathbf{r} - (\\boldsymbol{\\Omega} \\cdot \\mathbf{r})\\boldsymbol{\\Omega} ]$$\nThis vector field is the gradient of a scalar potential. We can find $p(\\mathbf{r})$ by integrating. We recognize parts of the expression as gradients of scalar fields:\n$$\\nabla(\\frac{1}{2} r^2) = \\nabla(\\frac{1}{2} \\mathbf{r} \\cdot \\mathbf{r}) = \\mathbf{r}$$\n$$\\nabla(\\frac{1}{2}(\\boldsymbol{\\Omega} \\cdot \\mathbf{r})^2) = (\\boldsymbol{\\Omega} \\cdot \\mathbf{r}) \\nabla(\\boldsymbol{\\Omega} \\cdot \\mathbf{r}) = (\\boldsymbol{\\Omega} \\cdot \\mathbf{r})\\boldsymbol{\\Omega}$$\nSubstituting these into the expression for $\\nabla p$:\n$$\\nabla p = \\rho [ \\Omega^2 \\nabla(\\frac{1}{2} r^2) - \\nabla(\\frac{1}{2}(\\boldsymbol{\\Omega} \\cdot \\mathbf{r})^2) ] = \\nabla \\left[ \\frac{1}{2}\\rho ( \\Omega^2 r^2 - (\\boldsymbol{\\Omega} \\cdot \\mathbf{r})^2 ) \\right]$$\nIntegrating with respect to $\\mathbf{r}$ yields the pressure field, up to an arbitrary constant $p_0$:\n$$p(\\mathbf{r}) = \\frac{1}{2}\\rho (\\Omega^2 r^2 - (\\boldsymbol{\\Omega} \\cdot \\mathbf{r})^2) + p_0$$\nThis can be expressed more compactly using the identity $|\\mathbf{A} \\times \\mathbf{B}|^2 = |\\mathbf{A}|^2 |\\mathbf{B}|^2 - (\\mathbf{A} \\cdot \\mathbf{B})^2$:\n$$p(\\mathbf{r}) = \\frac{1}{2}\\rho |\\boldsymbol{\\Omega} \\times \\mathbf{r}|^2 + p_0$$\nSince only pressure differences matter, we can set the reference pressure $p_0$ to $0$.\n\n### 2. Discretization and Residual Analysis\nThe problem specifies a 2D MAC grid in the plane $z=z_0$. Pressure $p$ is located at cell centers $(x_{i+1/2}, y_{j+1/2})$, while the velocity components (and thus momentum equation residuals) are at face centers.\nThe residual for the $x$-momentum equation, $R_x$, is evaluated at the centers of the vertical faces, at locations $(x_{i+1}, y_{j+1/2})$. The residual is defined as:\n$$R_x = -\\frac{p_{i+1,j} - p_{i,j}}{\\Delta x} + \\rho \\, a_{\\mathrm{cf},x}|_{(x_{i+1}, y_{j+1/2})}$$\nwhere $p_{i,j}$ denotes the pressure at the center of cell $(i,j)$, i.e., $p(x_{i+1/2}, y_{j+1/2}, z_0)$.\n\nA critical observation is that the analytical pressure field $p(x,y,z_0)$ is a quadratic polynomial of the spatial coordinates $x$ and $y$. Let us expand the expression for $p$ with $\\mathbf{r}=(x,y,z_0)$ and $\\boldsymbol{\\Omega}=(\\Omega_x, \\Omega_y, \\Omega_z)$:\n$$p(x,y) = \\frac{1}{2}\\rho [(\\Omega_x^2+\\Omega_y^2+\\Omega_z^2)(x^2+y^2+z_0^2) - (\\Omega_x x + \\Omega_y y + \\Omega_z z_0)^2]$$\n$$p(x,y) = A x^2 + B y^2 + C xy + D x + E y + F$$\nwhere $A, B, C, D, E, F$ are constants that depend on $\\rho, \\boldsymbol{\\Omega},$ and $z_0$.\n\nThe discrete pressure gradient term $-\\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}$ is a centered finite difference approximation of $-\\frac{\\partial p}{\\partial x}$. The pressure values are taken at cell centers $(x_{i+1/2}, y_{j+1/2})$ and $(x_{i+3/2}, y_{j+1/2})$. The midpoint between these two locations is $(x_{i+1}, y_{j+1/2})$, which is precisely the location where the residual $R_x$ is evaluated.\n\nFor any quadratic polynomial $f(x) = ax^2 + bx + c$, the centered finite difference is exact, meaning it equals the analytical derivative at the midpoint:\n$$\\frac{f(x_0 + h/2) - f(x_0 - h/2)}{h} = \\frac{[a(x_0+h/2)^2 + b(x_0+h/2)+c] - [a(x_0-h/2)^2 + b(x_0-h/2)+c]}{h} = 2ax_0 + b = f'(x_0)$$\nSince our pressure field $p(x,y)$ is quadratic in $x$ (for a fixed $y$), the discrete gradient is exactly equal to the continuous gradient at the face center:\n$$\\frac{p_{i+1,j} - p_{i,j}}{\\Delta x} = \\left. \\frac{\\partial p}{\\partial x} \\right|_{(x_{i+1}, y_{j+1/2})}$$\nFrom our initial derivation, we know that the continuous pressure field exactly balances the centrifugal force, i.e., $\\nabla p = \\rho \\mathbf{a}_{\\mathrm{cf}}$. This implies $\\frac{\\partial p}{\\partial x} = \\rho a_{\\mathrm{cf},x}$ at every point in space.\nTherefore, at the face center $(x_{i+1}, y_{j+1/2})$:\n$$\\frac{p_{i+1,j} - p_{i,j}}{\\Delta x} = \\left. \\rho a_{\\mathrm{cf},x} \\right|_{(x_{i+1}, y_{j+1/2})}$$\nSubstituting this into the definition of the residual $R_x$:\n$$R_x = -\\left(\\rho a_{\\mathrm{cf},x}\\right) + \\rho a_{\\mathrm{cf},x} = 0$$\nThe same logic applies to the $y$-component residual, $R_y$. Thus, the discrete residuals are analytically zero. The numerical implementation should yield results that are zero to within the limits of floating-point precision.\n\n### 3. Algorithmic Implementation\nThe program will implement the verification for each test case by following these steps:\n1.  Parse the test case parameters: $\\rho$, $\\boldsymbol{\\Omega}$, domain boundaries, $z_0$, and grid resolution $N_x, N_y$.\n2.  Calculate grid spacings $\\Delta x$ and $\\Delta y$.\n3.  Generate coordinate arrays for pressure cell centers using NumPy broadcasting for efficiency.\n4.  Evaluate the analytical pressure field $p(\\mathbf{r})$ at all cell centers to populate a 2D pressure array `p_grid`.\n5.  For the $x$-momentum residuals:\n    a. Generate coordinate arrays for the centers of the interior vertical faces.\n    b. Compute the discrete pressure gradient $-\\left(p_{i+1,j}-p_{i,j}\\right)/\\Delta x$ for all relevant faces.\n    c. Evaluate the centrifugal force term $\\rho a_{\\mathrm{cf},x}$ at the same face centers.\n    d. Calculate the residual $R_x$ as the sum of the two terms.\n6.  Repeat the process for the $y$-momentum residuals, $R_y$, on interior horizontal faces.\n7.  Determine the maximum absolute value over all computed $R_x$ and $R_y$ values. This is the final result for the test case.\n8.  Collect the results from all test cases and format them as specified.\n\nThis algorithm directly implements the formulas and definitions from the problem statement and leverages the analytical solution derived above to test the property of the numerical scheme.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the verification for all test cases and print the results.\n    \"\"\"\n\n    def calculate_max_residual(params):\n        \"\"\"\n        Calculates the maximum absolute residual for a single test case.\n\n        Args:\n            params (tuple): A tuple containing all parameters for the test case:\n                (rho, Omega_vec, domain_x, domain_y, z0, Nx, Ny).\n\n        Returns:\n            float: The maximum absolute residual found on the grid.\n        \"\"\"\n        rho, Omega_vec, domain_x, domain_y, z0, Nx, Ny = params\n        Omega_vec = np.array(Omega_vec, dtype=float)\n        x_min, x_max = domain_x\n        y_min, y_max = domain_y\n\n        dx = (x_max - x_min) / Nx\n        dy = (y_max - y_min) / Ny\n\n        # --- 1. Calculate pressure at cell centers ---\n        # Use broadcasting to create coordinate grids implicitly\n        i_p = np.arange(Nx, dtype=float).reshape(-1, 1)\n        j_p = np.arange(Ny, dtype=float).reshape(1, -1)\n        x_p = x_min + (i_p + 0.5) * dx\n        y_p = y_min + (j_p + 0.5) * dy\n\n        # Evaluate analytical pressure field p(r) = 0.5 * rho * |Omega x r|^2\n        omega_sq = np.dot(Omega_vec, Omega_vec)\n        r_sq = x_p**2 + y_p**2 + z0**2\n        omega_dot_r = Omega_vec[0] * x_p + Omega_vec[1] * y_p + Omega_vec[2] * z0\n        p_grid = 0.5 * rho * (omega_sq * r_sq - omega_dot_r**2)\n\n        max_res = 0.0\n\n        # --- 2. Calculate x-momentum residual Rx ---\n        if Nx > 1:\n            # Coordinates of x-face centers (where Rx is evaluated)\n            i_rx = np.arange(Nx - 1, dtype=float).reshape(-1, 1)\n            j_rx = np.arange(Ny, dtype=float).reshape(1, -1)\n            x_fx = x_min + (i_rx + 1.0) * dx\n            y_fx = y_min + (j_rx + 0.5) * dy\n\n            # Discrete pressure gradient component in x\n            grad_p_x = (p_grid[1:, :] - p_grid[:-1, :]) / dx\n\n            # Centrifugal force component at x-faces: rho * a_cf,x\n            # a_cf = Omega^2 * r - (Omega . r) * Omega\n            omega_dot_r_fx = Omega_vec[0] * x_fx + Omega_vec[1] * y_fx + Omega_vec[2] * z0\n            a_cf_x = omega_sq * x_fx - omega_dot_r_fx * Omega_vec[0]\n            force_x = rho * a_cf_x\n\n            # Calculate residual\n            Rx = -grad_p_x + force_x\n            max_res = max(max_res, np.max(np.abs(Rx)))\n\n        # --- 3. Calculate y-momentum residual Ry ---\n        if Ny > 1:\n            # Coordinates of y-face centers (where Ry is evaluated)\n            i_ry = np.arange(Nx, dtype=float).reshape(-1, 1)\n            j_ry = np.arange(Ny - 1, dtype=float).reshape(1, -1)\n            x_fy = x_min + (i_ry + 0.5) * dx\n            y_fy = y_min + (j_ry + 1.0) * dy\n\n            # Discrete pressure gradient component in y\n            grad_p_y = (p_grid[:, 1:] - p_grid[:, :-1]) / dy\n\n            # Centrifugal force component at y-faces: rho * a_cf,y\n            omega_dot_r_fy = Omega_vec[0] * x_fy + Omega_vec[1] * y_fy + Omega_vec[2] * z0\n            a_cf_y = omega_sq * y_fy - omega_dot_r_fy * Omega_vec[1]\n            force_y = rho * a_cf_y\n\n            # Calculate residual\n            Ry = -grad_p_y + force_y\n            max_res = max(max_res, np.max(np.abs(Ry)))\n\n        return max_res\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: rho, Omega, domain_x, domain_y, z0, Nx, Ny\n        (1000.0, (0.0, 0.0, 10.0), (0.0, 1.0), (0.0, 1.0), 0.0, 64, 64),\n        # Test 2\n        (1.0, (0.0, 0.0, 2.5), (-2.0, 3.0), (-1.0, 1.0), 0.0, 50, 20),\n        # Test 3\n        (1.2, (3.0, 4.0, 5.0), (1.0, 2.0), (-0.3, 0.7), 0.2, 37, 29),\n        # Test 4\n        (850.0, (0.0, 0.0, 0.1), (-1.0, 1.0), (-1.0, 1.0), 0.0, 2, 2),\n        # Test 5\n        (997.0, (0.0, 0.0, 1000.0), (0.1, 0.2), (-0.05, 0.05), 0.0, 16, 16),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_max_residual(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The excellent properties of the staggered grid are not accidental; they stem from a deep mathematical structure that mimics continuous vector calculus. This exercise reveals this underlying foundation by treating the grid and its discrete operators as a \"discrete de Rham complex.\" You will implement the discrete gradient, curl, and divergence operators and verify numerically that the fundamental vector identities $\\nabla\\times(\\nabla \\phi)=\\mathbf{0}$ and $\\nabla\\cdot(\\nabla\\times \\mathbf{A})=0$ are satisfied exactly, a property known as \"exactness\" . This demonstrates that the staggered arrangement provides a consistent and robust framework for discretizing vector calculus operations.",
            "id": "3447644",
            "problem": "Consider the Marker-and-Cell (MAC) arrangement for a uniform orthogonal grid in three spatial dimensions. Let the computational domain be $\\Omega = [0,L_x]\\times[0,L_y]\\times[0,L_z]$ with $L_x=L_y=L_z=1$. Discretize $\\Omega$ into $N_x \\times N_y \\times N_z$ cells with spacings $h_x = L_x/N_x$, $h_y = L_y/N_y$, $h_z = L_z/N_z$. Use the canonical discrete de Rham sequence placements:\n- Node-centered (corners) values for $0$-forms: a scalar field $\\phi$ defined at all nodes $(i,j,k)$ with $i\\in\\{0,\\dots,N_x\\}$, $j\\in\\{0,\\dots,N_y\\}$, $k\\in\\{0,\\dots,N_z\\}$.\n- Edge-centered values for $1$-forms: vectors aligned with edges. Let $\\mathbf{e}_x$ be defined on edges parallel to the $x$-direction with shape $(N_x, N_y+1, N_z+1)$, $\\mathbf{e}_y$ on edges parallel to the $y$-direction with shape $(N_x+1, N_y, N_z+1)$, and $\\mathbf{e}_z$ on edges parallel to the $z$-direction with shape $(N_x+1, N_y+1, N_z)$.\n- Face-centered values for $2$-forms: vectors normal to faces. Let $f_x$ be defined on faces normal to the $x$-axis with shape $(N_x+1, N_y, N_z)$, $f_y$ on faces normal to the $y$-axis with shape $(N_x, N_y+1, N_z)$, and $f_z$ on faces normal to the $z$-axis with shape $(N_x, N_y, N_z+1)$.\n- Cell-centered values for $3$-forms: scalars defined per cell with shape $(N_x, N_y, N_z)$.\n\nStarting from fundamental definitions of line, surface, and volume integrals and their discrete counterparts, define the following compatible discrete operators that map between these placements:\n1. Discrete gradient of the scalar $\\phi$ from nodes to edges, denoted $\\nabla \\phi$ on edges via forward differences along the edge directions,\n$$\ne_x[i,j,k] = \\frac{\\phi[i+1,j,k] - \\phi[i,j,k]}{h_x},\\quad\ne_y[i,j,k] = \\frac{\\phi[i,j+1,k] - \\phi[i,j,k]}{h_y},\\quad\ne_z[i,j,k] = \\frac{\\phi[i,j,k+1] - \\phi[i,j,k]}{h_z}.\n$$\n2. Discrete curl from edges to faces, denoted $\\nabla\\times\\mathbf{E}$ on faces (where $\\mathbf{E}$ collects $(e_x,e_y,e_z)$), defined as oriented circulation per unit area around each face,\n$$\n\\begin{aligned}\n(\\nabla\\times\\mathbf{E})_x[i,j,k] &= \\frac{e_z[i,j+1,k]-e_z[i,j,k]}{h_y} - \\frac{e_y[i,j,k+1]-e_y[i,j,k]}{h_z},\\\\\n(\\nabla\\times\\mathbf{E})_y[i,j,k] &= \\frac{e_x[i,j,k+1]-e_x[i,j,k]}{h_z} - \\frac{e_z[i+1,j,k]-e_z[i,j,k]}{h_x},\\\\\n(\\nabla\\times\\mathbf{E})_z[i,j,k] &= \\frac{e_y[i+1,j,k]-e_y[i,j,k]}{h_x} - \\frac{e_x[i,j+1,k]-e_x[i,j,k]}{h_y}.\n\\end{aligned}\n$$\n3. Discrete divergence from faces to cells, denoted $\\nabla\\cdot\\mathbf{F}$ at cell centers (where $\\mathbf{F}$ collects face-normal components $(f_x,f_y,f_z)$), defined as oriented face flux per unit volume,\n$$\n(\\nabla\\cdot\\mathbf{F})[i,j,k] = \\frac{f_x[i+1,j,k]-f_x[i,j,k]}{h_x} + \\frac{f_y[i,j+1,k]-f_y[i,j,k]}{h_y} + \\frac{f_z[i,j,k+1]-f_z[i,j,k]}{h_z}.\n$$\n\nYour tasks:\n- Implement the discrete operators as specified above, exactly respecting the placements and index ranges.\n- Verify analytically that for the interior, on a uniform grid with these forward-difference and circulation definitions, the composite operator $\\nabla\\times(\\nabla \\phi)$ yields the zero vector on faces and the composite operator $\\nabla\\cdot(\\nabla\\times \\mathbf{A})$ yields the zero scalar at cells, for arbitrary sufficiently smooth fields $\\phi$ at nodes and $\\mathbf{A}$ on edges. Explain why these discrete identities hold under periodic-like interior indexing (no ghost access).\n- Construct a numerical test harness to quantify the maximum absolute violation of:\n  - $\\nabla\\times(\\nabla \\phi)=\\mathbf{0}$ on faces,\n  - $\\nabla\\cdot(\\nabla\\times \\mathbf{A}) = 0$ at cells.\n  Use smooth deterministic fields:\n  - Node scalar $\\,\\phi(i,j,k) = \\sin(2\\pi x_i)\\sin(3\\pi y_j)\\sin(5\\pi z_k)\\,$ with $\\,x_i = i h_x\\,$, $\\,y_j = j h_y\\,$, $\\,z_k = k h_z\\,$.\n  - Edge vector potential components evaluated at edge midpoints:\n    $$\n    \\begin{aligned}\n    A_x(i+\\tfrac{1}{2},j,k) &= \\sin(2\\pi y_j)\\sin(3\\pi z_k),\\\\\n    A_y(i,j+\\tfrac{1}{2},k) &= \\sin(2\\pi z_k)\\sin(3\\pi x_i),\\\\\n    A_z(i,j,k+\\tfrac{1}{2}) &= \\sin(2\\pi x_i)\\sin(3\\pi y_j).\n    \\end{aligned}\n    $$\n- Implement three boundary-closure modes to stress the identities:\n  - \"periodic\": do nothing beyond the interior-indexed operators defined above.\n  - \"dirichlet\": after computing $\\nabla \\phi$ on edges, set all edge values that lie on a physical boundary (any index equal to $0$ or at its maximal value along any transverse index) to zero; and, independently, after computing $\\nabla\\times \\mathbf{A}$ on faces, set all boundary faces (any face index equal to $0$ or maximal along its axis) to zero. This models naive clamped closures that generally break the exactness of the complex.\n  - \"neumann\": after computing $\\nabla \\phi$, set to zero all edge components whose orientation is normal to a boundary and whose positional index along that orientation is at the boundary (e.g., for $e_x$, zero slices at $i=0$ and $i=N_x-1$; analogously for $e_y$ and $e_z$); and, independently, after computing $\\nabla\\times \\mathbf{A}$, zero the face-normal component at boundary-aligned indices for each orientation. This models naive flux closures that also typically break exactness.\n\nFor each test case, compute two floats:\n- $v_{\\mathrm{curlgrad}}$: the maximum over all faces of the absolute value of the components of $\\nabla\\times(\\nabla \\phi)$,\n- $v_{\\mathrm{divcurl}}$: the maximum over all cells of the absolute value of $\\nabla\\cdot(\\nabla\\times \\mathbf{A})$.\n\nDesign the following test suite (all with $L_x=L_y=L_z=1$):\n- Case $1$: $N_x=16$, $N_y=12$, $N_z=8$, boundary mode \"periodic\".\n- Case $2$: $N_x=16$, $N_y=12$, $N_z=8$, boundary mode \"dirichlet\".\n- Case $3$: $N_x=16$, $N_y=12$, $N_z=8$, boundary mode \"neumann\".\n- Case $4$: $N_x=2$, $N_y=2$, $N_z=2$, boundary mode \"periodic\" (boundary-dominated coarse grid).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$[v_{\\mathrm{curlgrad}}^{(1)},v_{\\mathrm{divcurl}}^{(1)},v_{\\mathrm{curlgrad}}^{(2)},v_{\\mathrm{divcurl}}^{(2)},v_{\\mathrm{curlgrad}}^{(3)},v_{\\mathrm{divcurl}}^{(3)},v_{\\mathrm{curlgrad}}^{(4)},v_{\\mathrm{divcurl}}^{(4)}]$.\nAll quantities are dimensionless floats. Round nothing; print raw floating-point values as computed.",
            "solution": "The problem as stated is formally sound and addresses a fundamental concept in the numerical solution of partial differential equations, namely, the properties of discrete vector calculus operators on a staggered grid. It is scientifically grounded, well-posed, and objective. All definitions, data, and constraints are provided, allowing for a unique and verifiable solution.\n\nThe problem requires an analytical verification of two key vector identities in their discrete form and a numerical implementation to test these identities under various boundary closures.\n\n### Analytical Verification of Discrete Identities\n\nThe problem defines a sequence of discrete differential operators (gradient, curl, divergence) which are analogous to the operators in continuous vector calculus. This construction is a specific instance of a discrete de Rham complex. A key property of such complexes is that the composition of any two consecutive operators in the sequence yields zero. We will verify this for the combinations $\\nabla\\times(\\nabla\\phi)$ and $\\nabla\\cdot(\\nabla\\times\\mathbf{A})$.\n\n**1. Identity: $\\nabla\\times(\\nabla \\phi) = \\mathbf{0}$**\n\nThis identity is the discrete analogue of \"the curl of a gradient is zero\". We verify the $x$-component of this vector identity; the proofs for the $y$- and $z$-components are analogous by cyclic permutation of indices.\n\nThe $x$-component of the discrete curl of a vector field $\\mathbf{E}$ is defined as:\n$$\n(\\nabla\\times\\mathbf{E})_x[i,j,k] = \\frac{e_z[i,j+1,k]-e_z[i,j,k]}{h_y} - \\frac{e_y[i,j,k+1]-e_y[i,j,k]}{h_z}\n$$\nWe substitute $\\mathbf{E} = \\nabla\\phi$, where the components of the discrete gradient are:\n$$\ne_y[i,j,k] = \\frac{\\phi[i,j+1,k] - \\phi[i,j,k]}{h_y} \\quad \\text{and} \\quad e_z[i,j,k] = \\frac{\\phi[i,j,k+1] - \\phi[i,j,k]}{h_z}\n$$\nSubstituting these into the curl formula:\n$$\n(\\nabla\\times(\\nabla \\phi))_x[i,j,k] = \\frac{1}{h_y} \\left( \\frac{\\phi[i,j+1,k+1] - \\phi[i,j+1,k]}{h_z} - \\frac{\\phi[i,j,k+1] - \\phi[i,j,k]}{h_z} \\right) - \\frac{1}{h_z} \\left( \\frac{\\phi[i,j+1,k+1] - \\phi[i,j,k+1]}{h_y} - \\frac{\\phi[i,j+1,k] - \\phi[i,j,k]}{h_y} \\right)\n$$\nCombining terms with the common denominator $h_y h_z$:\n$$\n= \\frac{1}{h_y h_z} \\left( \\phi[i,j+1,k+1] - \\phi[i,j+1,k] - \\phi[i,j,k+1] + \\phi[i,j,k] \\right) - \\frac{1}{h_y h_z} \\left( \\phi[i,j+1,k+1] - \\phi[i,j,k+1] - \\phi[i,j+1,k] + \\phi[i,j,k] \\right)\n$$\nThe expressions inside the two parentheses are identical. Their difference is therefore identically zero for any scalar field $\\phi$, provided all necessary node values are accessible. This algebraic cancellation is the discrete equivalent of the equality of mixed partial derivatives ($\\partial^2\\phi/\\partial y\\partial z = \\partial^2\\phi/\\partial z\\partial y$). This holds exactly for interior faces where the stencil does not cross a boundary.\n\n**2. Identity: $\\nabla\\cdot(\\nabla\\times \\mathbf{A}) = 0$**\n\nThis identity is the discrete analogue of \"the divergence of a curl is zero\". Let us define the forward finite difference operators:\n$$\n\\delta_x f[i] = \\frac{f[i+1]-f[i]}{h_x}, \\quad \\delta_y f[j] = \\frac{f[j+1]-f[j]}{h_y}, \\quad \\delta_z f[k] = \\frac{f[k+1]-f[k]}{h_z}\n$$\nThe discrete curl and divergence operators can be written compactly:\n$$\n(\\nabla\\times\\mathbf{A})_x = \\delta_y A_z - \\delta_z A_y, \\quad (\\nabla\\times\\mathbf{A})_y = \\delta_z A_x - \\delta_x A_z, \\quad (\\nabla\\times\\mathbf{A})_z = \\delta_x A_y - \\delta_y A_x\n$$\n$$\n\\nabla\\cdot\\mathbf{F} = \\delta_x F_x + \\delta_y F_y + \\delta_z F_z\n$$\nSubstituting the curl expression into the divergence:\n$$\n\\nabla\\cdot(\\nabla\\times \\mathbf{A}) = \\delta_x (\\delta_y A_z - \\delta_z A_y) + \\delta_y (\\delta_z A_x - \\delta_x A_z) + \\delta_z (\\delta_x A_y - \\delta_y A_x)\n$$\nRearranging the terms:\n$$\n= (\\delta_x \\delta_y A_z - \\delta_y \\delta_x A_z) + (\\delta_y \\delta_z A_x - \\delta_z \\delta_y A_x) + (\\delta_z \\delta_x A_y - \\delta_x \\delta_z A_y)\n$$\nOn a uniform orthogonal grid, the finite difference operators commute, i.e., $\\delta_i \\delta_j f = \\delta_j \\delta_i f$ for any field $f$ and directions $i,j \\in \\{x,y,z\\}$. This can be verified by direct expansion, just as was done for the $\\nabla\\times\\nabla\\phi$ case. Each term in parentheses is therefore identically zero. Consequently, the entire expression is zero. This cancellation holds exactly for interior cells where all necessary edge values are defined by the interior stencil.\n\n### Numerical Implementation Strategy\n\nThe numerical verification will be performed by implementing the discrete operators and applying them to smooth, deterministic test fields.\n\n**1. Operator Implementation:** The discrete gradient, curl, and divergence operators are implemented as functions that take NumPy arrays representing the fields on the grid and return the resulting fields on the appropriate staggered locations. These implementations use vectorized NumPy slicing to efficiently compute the finite differences, directly translating the given formulas. For example, a difference like $e_x[i,j,k] = (\\phi[i+1,j,k] - \\phi[i,j,k])/h_x$ is implemented as `(phi[1:,:,:] - phi[:-1,:,:]) / hx` on the relevant slices of the `phi` array.\n\n**2. Test Field Generation:**\n- For the $\\nabla\\times(\\nabla\\phi)$ test, a nodal scalar field $\\phi$ is constructed. First, coordinate arrays for all node locations $(x_i, y_j, z_k)$ are generated. Then, the specified function $\\phi(x,y,z) = \\sin(2\\pi x)\\sin(3\\pi y)\\sin(5\\pi z)$ is evaluated on this nodal grid.\n- For the $\\nabla\\cdot(\\nabla\\times\\mathbf{A})$ test, the vector potential components $A_x, A_y, A_z$ are constructed on their respective edge-centered grids. For each component, coordinates at the center of the relevant edges are computed. The given functions for $A_x, A_y, A_z$ are then evaluated at these specific locations.\n\n**3. Boundary Conditions:**\n- **\"periodic\" mode:** This mode applies the discrete operators as defined, without any modification. This corresponds to computing the identities on the interior stencils where they are expected to hold exactly (to within machine floating-point precision).\n- **\"dirichlet\" and \"neumann\" modes:** These modes are designed to probe the sensitivity of the identities to boundary closures that break the exact sequence property. After an intermediate field is computed (e.g., $\\mathbf{E} = \\nabla\\phi$), certain values at or near the physical boundary of the domain are explicitly set to zero as per the problem's specific instructions. For example, the `dirichlet` mode for the `curl-grad` test artificially sets all edge values on the boundary to zero. Such modifications disrupt the delicate algebraic cancellations shown in the analytical verification, leading to non-zero results for $\\nabla\\times(\\nabla\\phi)$ and $\\nabla\\cdot(\\nabla\\times\\mathbf{A})$, particularly near the boundaries. The distinction between \"dirichlet\" and \"neumann\" lies in *which* components are zeroed (tangential vs. normal orientations relative to the boundary). Based on the problem's specific definitions for modifying face-centered fields, the `dirichlet` and `neumann` instructions happen to be identical for the $\\nabla\\cdot(\\nabla\\times\\mathbf{A})$ test.\n\n**4. Error Quantification:** For each test case, after computing the final field ($\\nabla\\times(\\nabla\\phi)$ on faces or $\\nabla\\cdot(\\nabla\\times\\mathbf{A})$ on cells), the maximum absolute value over all components and all grid points of the resulting field is calculated. This provides a single scalar measure ($v_{\\mathrm{curlgrad}}$ or $v_{\\mathrm{divcurl}}$) of the violation of the identity. For the \"periodic\" cases, these values are expected to be on the order of machine epsilon. For the other cases, they will be significantly larger, demonstrating the breakdown of the discrete identity due to the boundary treatment.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gradient(phi, hx, hy, hz):\n    \"\"\"Computes the discrete gradient of a node-centered scalar field phi.\"\"\"\n    # phi: (Nx+1, Ny+1, Nz+1)\n    # Output ex: (Nx, Ny+1, Nz+1), ey: (Nx+1, Ny, Nz+1), ez: (Nx+1, Ny+1, Nz)\n    ex = (phi[1:, :, :] - phi[:-1, :, :]) / hx\n    ey = (phi[:, 1:, :] - phi[:, :-1, :]) / hy\n    ez = (phi[:, :, 1:] - phi[:, :, :-1]) / hz\n    return ex, ey, ez\n\ndef curl(ex, ey, ez, hx, hy, hz):\n    \"\"\"Computes the discrete curl of an edge-centered vector field e.\"\"\"\n    # ex: (Nx, Ny+1, Nz+1), ey: (Nx+1, Ny, Nz+1), ez: (Nx+1, Ny+1, Nz)\n    # Output fx: (Nx+1, Ny, Nz), fy: (Nx, Ny+1, Nz), fz: (Nx, Ny, Nz+1)\n\n    # (curl E)_x [i,j,k] needs e_z at j, j+1 and e_y at k, k+1\n    d_y_ez = (ez[:, 1:, :] - ez[:, :-1, :]) / hy  # Shape (Nx+1, Ny, Nz)\n    d_z_ey = (ey[:, :, 1:] - ey[:, :, :-1]) / hz  # Shape (Nx+1, Ny, Nz)\n    fx = d_y_ez - d_z_ey\n\n    # (curl E)_y [i,j,k] needs e_x at k, k+1 and e_z at i, i+1\n    d_z_ex = (ex[:, :, 1:] - ex[:, :, :-1]) / hz  # Shape (Nx, Ny+1, Nz)\n    d_x_ez = (ez[1:, :, :] - ez[:-1, :, :]) / hx  # Shape (Nx, Ny+1, Nz)\n    fy = d_z_ex - d_x_ez\n    \n    # (curl E)_z [i,j,k] needs e_y at i, i+1 and e_x at j, j+1\n    d_x_ey = (ey[1:, :, :] - ey[:-1, :, :]) / hx  # Shape (Nx, Ny, Nz+1)\n    d_y_ex = (ex[:, 1:, :] - ex[:, :-1, :]) / hy  # Shape (Nx, Ny, Nz+1)\n    fz = d_x_ey - d_y_ex\n    \n    return fx, fy, fz\n\ndef divergence(fx, fy, fz, hx, hy, hz):\n    \"\"\"Computes the discrete divergence of a face-centered vector field f.\"\"\"\n    # fx: (Nx+1, Ny, Nz), fy: (Nx, Ny+1, Nz), fz: (Nx, Ny, Nz+1)\n    # Output s: (Nx, Ny, Nz)\n    d_x_fx = (fx[1:, :, :] - fx[:-1, :, :]) / hx\n    d_y_fy = (fy[:, 1:, :] - fy[:, :-1, :]) / hy\n    d_z_fz = (fz[:, :, 1:] - fz[:, :, :-1]) / hz\n    \n    s = d_x_fx + d_y_fy + d_z_fz\n    return s\n\ndef compute_errors(Nx, Ny, Nz, mode):\n    \"\"\"\n    Computes curl-grad and div-curl errors for a given grid and boundary mode.\n    \"\"\"\n    Lx, Ly, Lz = 1.0, 1.0, 1.0\n    hx, hy, hz = Lx / Nx, Ly / Ny, Lz / Nz\n\n    # --- Task 1: Verify curl(grad(phi)) = 0 ---\n    \n    # 1.1: Construct node-centered scalar field phi\n    x_nodes = np.linspace(0, Lx, Nx + 1)\n    y_nodes = np.linspace(0, Ly, Ny + 1)\n    z_nodes = np.linspace(0, Lz, Nz + 1)\n    xx, yy, zz = np.meshgrid(x_nodes, y_nodes, z_nodes, indexing='ij')\n    phi = np.sin(2 * np.pi * xx) * np.sin(3 * np.pi * yy) * np.sin(5 * np.pi * zz)\n    \n    # 1.2: Compute gradient\n    ex, ey, ez = gradient(phi, hx, hy, hz)\n    \n    # 1.3: Apply boundary closure to the edge field\n    if mode == \"dirichlet\":\n        # Zero all edge values on a physical boundary\n        ex[:, 0, :] = 0; ex[:, -1, :] = 0  # j=0, j=Ny\n        ex[:, :, 0] = 0; ex[:, :, -1] = 0  # k=0, k=Nz\n        ey[0, :, :] = 0; ey[-1, :, :] = 0  # i=0, i=Nx\n        ey[:, :, 0] = 0; ey[:, :, -1] = 0  # k=0, k=Nz\n        ez[0, :, :] = 0; ez[-1, :, :] = 0  # i=0, i=Nx\n        ez[:, 0, :] = 0; ez[:, -1, :] = 0  # j=0, j=Ny\n    elif mode == \"neumann\":\n        # Zero edge components normal to a boundary at the boundary\n        ex[0, :, :] = 0; ex[-1, :, :] = 0  # i=0, i=Nx-1\n        ey[:, 0, :] = 0; ey[:, -1, :] = 0  # j=0, j=Ny-1\n        ez[:, :, 0] = 0; ez[:, :, -1] = 0  # k=0, k=Nz-1\n\n    # 1.4: Compute curl of the (potentially modified) gradient\n    cg_fx, cg_fy, cg_fz = curl(ex, ey, ez, hx, hy, hz)\n\n    # 1.5: Compute max violation\n    v_curlgrad = np.max([\n        np.max(np.abs(cg_fx)), \n        np.max(np.abs(cg_fy)), \n        np.max(np.abs(cg_fz))\n    ])\n\n    # --- Task 2: Verify div(curl(A)) = 0 ---\n    \n    # 2.1: Construct edge-centered vector potential A\n    # A_x on x-edges: (Nx, Ny+1, Nz+1)\n    y_on_ax = np.linspace(0, Ly, Ny + 1)\n    z_on_ax = np.linspace(0, Lz, Nz + 1)\n    YY_ax, ZZ_ax = np.meshgrid(y_on_ax, z_on_ax, indexing='ij')\n    Ax_slice = np.sin(2 * np.pi * YY_ax) * np.sin(3 * np.pi * ZZ_ax)\n    Ax = np.tile(Ax_slice[np.newaxis, :, :], (Nx, 1, 1))\n\n    # A_y on y-edges: (Nx+1, Ny, Nz+1)\n    x_on_ay = np.linspace(0, Lx, Nx + 1)\n    z_on_ay = np.linspace(0, Lz, Nz + 1)\n    XX_ay, ZZ_ay = np.meshgrid(x_on_ay, z_on_ay, indexing='ij')\n    Ay_slice = np.sin(2 * np.pi * ZZ_ay) * np.sin(3 * np.pi * XX_ay)\n    Ay = np.tile(Ay_slice[:, np.newaxis, :], (1, Ny, 1))\n\n    # A_z on z-edges: (Nx+1, Ny+1, Nz)\n    x_on_az = np.linspace(0, Lx, Nx + 1)\n    y_on_az = np.linspace(0, Ly, Ny + 1)\n    XX_az, YY_az = np.meshgrid(x_on_az, y_on_az, indexing='ij')\n    Az_slice = np.sin(2 * np.pi * XX_az) * np.sin(3 * np.pi * YY_az)\n    Az = np.tile(Az_slice[:, :, np.newaxis], (1, 1, Nz))\n    \n    # 2.2: Compute curl of A\n    dc_fx, dc_fy, dc_fz = curl(Ax, Ay, Az, hx, hy, hz)\n    \n    # 2.3: Apply boundary closure to the face field\n    if mode == \"dirichlet\" or mode == \"neumann\":\n        # For faces, the problem description for dirichlet and neumann modes is identical\n        # Zero all boundary faces\n        dc_fx[0, :, :] = 0; dc_fx[-1, :, :] = 0  # i=0, i=Nx\n        dc_fy[:, 0, :] = 0; dc_fy[:, -1, :] = 0  # j=0, j=Ny\n        dc_fz[:, :, 0] = 0; dc_fz[:, :, -1] = 0  # k=0, k=Nz\n\n    # 2.4: Compute divergence of the (potentially modified) curl field\n    s = divergence(dc_fx, dc_fy, dc_fz, hx, hy, hz)\n\n    # 2.5: Compute max violation\n    v_divcurl = np.max(np.abs(s))\n\n    return v_curlgrad, v_divcurl\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (16, 12, 8, \"periodic\"),\n        (16, 12, 8, \"dirichlet\"),\n        (16, 12, 8, \"neumann\"),\n        (2, 2, 2, \"periodic\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        v_cg, v_dc = compute_errors(*case)\n        results.append(v_cg)\n        results.append(v_dc)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}