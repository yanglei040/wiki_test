{
    "hands_on_practices": [
        {
            "introduction": "交错网格的一个最主要的设计动机是为了解决在同位网格（collocated grid）上出现的非物理性压力振荡，即所谓的“棋盘格”现象。本练习将引导你通过一个数值实验，亲手生成这种伪影，并验证交错网格（MAC grid）的离散格式如何从根本上消除这种压力-速度解耦问题。这个实践将具体地展示交错网格的核心优势及其对计算流体动力学稳定性的重要性。",
            "id": "3365597",
            "problem": "考虑在每个方向长度为 $L=1$ 的二维周期性域上的稳态不可压缩斯托克斯方程，其空间坐标为 $(x,y)$，速度场为 $\\mathbf{u}(x,y) = (u(x,y), v(x,y))$：\n$$\n-\\nabla p + \\nu \\nabla^2 \\mathbf{u} = \\mathbf{f}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n其中 $p(x,y)$ 是压力，$\\nu$ 是运动粘度，$\\mathbf{f}(x,y)$ 是给定的体力。在分数步投影法中，压力场 $p$ 通过求解以下与施加离散不可压缩性相关的压力泊松方程来恢复：\n$$\n\\nabla^2 p = s,\n$$\n其中 $s$ 是由中间速度场的散度构成的离散源项。在间距为 $\\Delta x = \\Delta y$ 的均匀笛卡尔网格上，不同的网格排布会产生不同的离散梯度和散度算子。具体而言：\n- 同位（单元中心）排布将 $u$、$v$ 和 $p$ 全部置于单元中心。一种常见的朴素中心差分实现使用每个坐标方向上的最近邻点来计算中心的离散压力梯度：\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{col}} = \\frac{p_{i+1,j} - p_{i-1,j}}{2 \\Delta x}, \\quad\n\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{col}} = \\frac{p_{i,j+1} - p_{i,j-1}}{2 \\Delta x}.\n$$\n- 标记网格法（Marker-And-Cell, MAC）交错排布将 $u$ 置于 $(i+\\tfrac{1}{2}, j)$ 的垂直面上，$v$ 置于 $(i, j+\\tfrac{1}{2})$ 的水平面上，$p$ 置于 $(i,j)$ 的单元中心。离散压力梯度自然地出现在面上：\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i+\\frac{1}{2},j}^{\\text{MAC}} = \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}, \\quad\n\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+\\frac{1}{2}}^{\\text{MAC}} = \\frac{p_{i,j+1} - p_{i,j}}{\\Delta x}.\n$$\n\n已知同位中心差分会产生一种伪压力模式，通常称为棋盘模式，它在 $N_x \\times N_y$ 均匀周期性网格上定义为\n$$\np_{i,j}^{\\text{chk}} = (-1)^{i+j}, \\quad i = 0,1,\\dots,N_x-1, \\quad j = 0,1,\\dots,N_y-1,\n$$\n并对应于最高可分辨空间频率（奈奎斯特模式）。该模式可由某些离散强迫项激发，并且在同位网格上，通过从中心到面的朴素插值，它会与动量方程解耦，导致 $p$ 中出现不驱动动量的非物理振荡。相比之下，MAC 交错排布抑制了这种解耦，因为面心离散梯度直接采样相邻的单元中心压力，棋盘模式的差分在面上不为零。\n\n您的任务是：\n1. 使用人造源项 $s_{i,j} = (-1)^{i+j}$，在具有周期性边界条件并通过标准五点拉普拉斯算子离散的离散压力泊松方程中激发棋盘模式。五点拉普拉斯算子在间距为 $\\Delta x$ 的均匀网格上的离散傅里叶符号是\n$$\n\\lambda(k_x,k_y) = \\frac{2}{\\Delta x^2}\\left(\\cos(k_x \\Delta x)-1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos(k_y \\Delta x)-1\\right),\n$$\n对于离散波数 $k_x = \\frac{2\\pi m}{L}$，$k_y = \\frac{2\\pi n}{L}$，其中 $m = 0,1,\\dots,N_x-1$ 且 $n = 0,1,\\dots,N_y-1$。当 $N_x$ 和 $N_y$ 为偶数时，棋盘模式对应于 $(m,n) = (N_x/2, N_y/2)$，给出 $\\cos(\\pi) = -1$，因此\n$$\n\\lambda_{\\text{chk}} = -\\frac{4}{\\Delta x^2} - \\frac{4}{\\Delta x^2} = -\\frac{8}{\\Delta x^2}.\n$$\n由此，与棋盘模式强迫项相关的压力振幅与以下成比例\n$$\nA_p(\\Delta x) = \\frac{1}{|\\lambda_{\\text{chk}}|} = \\frac{\\Delta x^2}{8}.\n$$\n2. 对于一系列均匀网格，在傅里叶域中使用上述离散拉普拉斯符号，数值求解离散周期性泊松方程 $\\nabla^2 p = s$，并通过将计算出的 $p$ 投影到 $p^{\\text{chk}}$ 上来提取棋盘模式分量的数值振幅 $A_p(\\Delta x)$。\n3. 计算并比较在以下两种情况下，将进入动量方程的面心压力梯度的均方根（RMS）大小：\n   - 通过将相邻单元的中心梯度平均到面而获得的同位朴素面梯度：\n   $$\n   \\left(\\frac{\\partial p}{\\partial x}\\right)_{i+\\frac{1}{2},j}^{\\text{col-face}} = \\frac{1}{2}\\left[\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{col}} + \\left(\\frac{\\partial p}{\\partial x}\\right)_{i+1,j}^{\\text{col}}\\right], \\quad\n   \\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+\\frac{1}{2}}^{\\text{col-face}} = \\frac{1}{2}\\left[\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{col}} + \\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+1}^{\\text{col}}\\right].\n   $$\n   - 如上定义的 MAC 面梯度。RMS 大小定义为\n   $$\n   G_{\\text{RMS}} = \\sqrt{\\frac{1}{N_f}\\sum_{f} g_f^2},\n   $$\n   其中 $g_f$ 遍历两个方向上的所有面梯度分量，$N_f$ 是面的数量。\n4. 数值上证明：\n   - 同位朴素面梯度对棋盘模式分量不敏感，因此对于人造强迫项，其 RMS 大小在数值上为零，这解释了解耦现象。\n   - MAC 面梯度与棋盘模式耦合，并且对于人造强迫项，其 RMS 大小与 $\\mathcal{O}(\\Delta x)$ 成比例，因为 $A_p(\\Delta x) \\sim \\Delta x^2$ 且面梯度与 $A_p(\\Delta x)/\\Delta x$ 成比例。\n\n实现一个程序，该程序：\n- 在长度为 $L=1$ 的周期性域上构建人造源项 $s_{i,j} = (-1)^{i+j}$。\n- 在傅里叶空间中使用离散拉普拉斯符号求解离散泊松方程以获得 $p_{i,j}$。\n- 通过投影到 $(-1)^{i+j}$ 上计算数值棋盘振幅 $A_p(\\Delta x)$。\n- 为得到的 $p_{i,j}$ 计算 $G_{\\text{RMS}}^{\\text{col-face}}$ 和 $G_{\\text{RMS}}^{\\text{MAC}}$。\n- 报告每个网格的元组 $(A_p(\\Delta x), G_{\\text{RMS}}^{\\text{col-face}}, G_{\\text{RMS}}^{\\text{MAC}})$。\n\n测试套件：\n- 对于以下情况，使用 $N_x=N_y$ 和 $L=1$ 的方形网格：\n  1. $N_x=N_y=8$（粗网格，$\\Delta x = 1/8$）。\n  2. $N_x=N_y=16$（中等网格，$\\Delta x = 1/16$）。\n  3. $N_x=N_y=32$（细网格，$\\Delta x = 1/32$）。\n  4. $N_x=N_y=64$（非常细的网格，$\\Delta x = 1/64$）。\n所有报告的量均为无量纲。您的程序应生成单行输出，其中包含结果，形式为由逗号分隔的四个带括号的元组列表，每个元组按 $(A_p(\\Delta x), G_{\\text{RMS}}^{\\text{col-face}}, G_{\\text{RMS}}^{\\text{MAC}})$ 的顺序排列，与测试用例的顺序相同，例如：\n\"[(a1,b1,c1),(a2,b2,c2),(a3,b3,c3),(a4,b4,c4)]\"。",
            "solution": "我们从稳态不可压缩斯托克斯方程开始\n$$\n-\\nabla p + \\nu \\nabla^2 \\mathbf{u} = \\mathbf{f}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n在分数步法下，这导致通过压力泊松方程来施加离散不可压缩性\n$$\n\\nabla^2 p = s,\n$$\n其中源项 $s$ 从中间速度的散度获得。在均匀周期性网格上，在离散傅里叶空间中求解此泊松方程是很自然的，并且揭示了某些空间模式如何传播到压力中。我们关注棋盘（奈奎斯特）模式，\n$$\np_{i,j}^{\\text{chk}} = (-1)^{i+j},\n$$\n它在相邻的单元中心之间符号交替。\n\n对于间距为 $\\Delta x$ 的均匀周期性网格，标准的五点离散拉普拉斯算子具有傅里叶符号\n$$\n\\lambda(k_x,k_y) = \\frac{2}{\\Delta x^2}\\left(\\cos(k_x \\Delta x)-1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos(k_y \\Delta x)-1\\right),\n$$\n其离散波数为 $k_x = \\frac{2\\pi m}{L}$ 和 $k_y = \\frac{2\\pi n}{L}$，$m=0,\\dots,N_x-1$，$n=0,\\dots,N_y-1$，且 $L=1$。对于棋盘模式，$(m,n)=(N_x/2, N_y/2)$ 且 $k_x \\Delta x = \\pi$, $k_y \\Delta x = \\pi$，得到\n$$\n\\lambda_{\\text{chk}} = \\frac{2}{\\Delta x^2}\\left(\\cos \\pi - 1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos \\pi - 1\\right) = \\frac{2}{\\Delta x^2}\\left(-1 - 1\\right) + \\frac{2}{\\Delta x^2}\\left(-1 - 1\\right) = -\\frac{8}{\\Delta x^2}.\n$$\n用 $s_{i,j}=(-1)^{i+j}$ 强迫泊松方程意味着右侧只有此模式。因此，解与同一模式成比例：\n$$\np_{i,j} = A_p(\\Delta x)\\, (-1)^{i+j}.\n$$\n代入傅里叶空间中的离散泊松方程，得到\n$$\n\\lambda_{\\text{chk}} A_p(\\Delta x) = 1 \\quad \\Rightarrow \\quad A_p(\\Delta x) = -\\frac{1}{\\lambda_{\\text{chk}}} = \\frac{\\Delta x^2}{8}.\n$$\n因此，计算出的压力中棋盘模式分量的振幅与 $\\Delta x^2$ 成比例。\n\n同位排布与标记网格法（MAC）交错排布之间的区别在于压力梯度在动量方程中的表示方式：\n- 在同位（单元中心）格式中，一种常见的朴素实现使用中心差分来估计单元中心的 $\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{col}}$ 和 $\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{col}}$。对于棋盘压力 $p_{i,j} = A_p(\\Delta x)\\,(-1)^{i+j}$，\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{col}} = \\frac{p_{i+1,j} - p_{i-1,j}}{2 \\Delta x}\n= \\frac{A_p(\\Delta x)\\left[(-1)^{i+1+j} - (-1)^{i-1+j}\\right]}{2\\Delta x}\n= \\frac{A_p(\\Delta x)\\,(-1)^{i+j}\\left[-1 - (-1)\\right]}{2\\Delta x} = 0,\n$$\n类似的计算表明 $\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{col}}=0$。如果接着通过平均相邻的中心梯度来朴素地构造面梯度，那么驱动动量方程的最终面压力梯度仍然为零。这证明了解耦：在同位朴素格式中，棋盘压力不产生面心压力梯度。\n- 在 MAC 交错排布中，面心离散梯度直接取相邻中心压力的差值：\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i+\\frac{1}{2},j}^{\\text{MAC}} = \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}\n= \\frac{A_p(\\Delta x)\\left[(-1)^{i+1+j} - (-1)^{i+j}\\right]}{\\Delta x}\n= \\frac{A_p(\\Delta x)\\,(-1)^{i+j}(-1 - 1)}{\\Delta x}\n= -\\frac{2\\,A_p(\\Delta x)}{\\Delta x}\\,(-1)^{i+j}.\n$$\n$\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+\\frac{1}{2}}^{\\text{MAC}}$ 也存在类似的表达式。因此，MAC 面梯度与棋盘模式强耦合，并驱动动量修正以抑制此类振荡。对于人造源项，MAC 面梯度的大小与 $\\frac{A_p(\\Delta x)}{\\Delta x} \\sim \\frac{\\Delta x^2}{\\Delta x} = \\mathcal{O}(\\Delta x)$ 成比例。\n\n程序算法设计：\n1. 对于每个具有 $N_x=N_y$ 和 $\\Delta x = 1/N_x$ 的测试网格，构建人造源项 $s_{i,j} = (-1)^{i+j}$。\n2. 计算 s 的二维离散傅里叶变换以获得 $\\hat{s}(m,n)$。\n3. 对于每个傅里叶模式 $(m,n)$，使用以下公式计算离散拉普拉斯符号 $\\lambda(m,n)$\n$$\n\\lambda(m,n) = \\frac{2}{\\Delta x^2}\\left(\\cos\\left(\\frac{2\\pi m}{N_x}\\right)-1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos\\left(\\frac{2\\pi n}{N_y}\\right)-1\\right).\n$$\n4. 对于所有 $\\lambda(m,n) \\neq 0$ 的 $(m,n)$，计算 $\\hat{p}(m,n) = \\hat{s}(m,n) / \\lambda(m,n)$。由于交替模式，$\\hat{s}$ 中不存在零模式 $(m,n)=(0,0)$，因此不会发生除以零的情况。\n5. 进行逆变换以在物理空间中获得 $p_{i,j}$。\n6. 将 $p$ 投影到棋盘模式上以提取振幅，\n$$\nA_p(\\Delta x) = \\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} p_{i,j}(-1)^{i+j}.\n$$\n7. 使用中心差分计算同位中心梯度，然后通过平均相邻中心梯度获得同位面梯度。计算所有面上的均方根大小：\n$$\nG_{\\text{RMS}}^{\\text{col-face}} = \\sqrt{\\frac{1}{N_f}\\sum_{f}\\left(g_{f}^{\\text{col-face}}\\right)^2}.\n$$\n8. 从相邻中心压力计算 MAC 面梯度，以及相应的均方根大小：\n$$\nG_{\\text{RMS}}^{\\text{MAC}} = \\sqrt{\\frac{1}{N_f}\\sum_{f}\\left(g_{f}^{\\text{MAC}}\\right)^2}.\n$$\n9. 对测试套件中的每个网格，输出 $(A_p(\\Delta x), G_{\\text{RMS}}^{\\text{col-face}}, G_{\\text{RMS}}^{\\text{MAC}})$，并按规定格式汇总为单行。\n\n预期行为：\n- 数值 $A_p(\\Delta x)$ 应与 $\\Delta x^2/8$ 非常接近（在浮点和离散变换归一化误差范围内）。\n- $G_{\\text{RMS}}^{\\text{col-face}}$ 应在数值上为零（达到机器精度），这表明同位朴素梯度对棋盘压力不敏感。\n- 对于此人造源项，$G_{\\text{RMS}}^{\\text{MAC}}$ 应与 $\\Delta x$ 线性相关，因为面梯度大小的行为类似于 $2 A_p(\\Delta x)/\\Delta x$。\n\n这直接展示了标记网格法（MAC）交错网格抑制棋盘压力模式的机制：通过将速度放置在面上，离散压力梯度被计算为相邻压力的差值，该差值对于交替模式不为零，从而将伪模式耦合到动量方程中并被阻尼。相比之下，在中心点使用同位朴素中心差分计算压力梯度会消除交替分量，使得伪压力模式能够在不影响速度场的情况下持续存在。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef discrete_laplacian_symbol(nx, ny, dx):\n    \"\"\"\n    Build the discrete Laplacian symbol lambda(m,n) for a periodic grid\n    using the five-point stencil central differences on a uniform grid.\n    \"\"\"\n    # Wavenumber indices m, n\n    m = np.arange(nx)\n    n = np.arange(ny)\n    # Cosine terms for each axis\n    cos_m = np.cos(2.0 * np.pi * m / nx)\n    cos_n = np.cos(2.0 * np.pi * n / ny)\n    # Broadcast to 2D grid of (m,n)\n    lam = (2.0 / dx**2) * (cos_m[:, None] - 1.0) + (2.0 / dx**2) * (cos_n[None, :] - 1.0)\n    return lam\n\ndef solve_poisson_checkerboard(nx, ny, L=1.0):\n    \"\"\"\n    Solve the discrete periodic Poisson equation for s_{i,j} = (-1)^{i+j}\n    using the discrete Laplacian symbol in Fourier space.\n\n    Returns:\n        p: computed pressure field (nx x ny)\n        Ap: numerical checkerboard amplitude via projection onto (-1)^{i+j}\n    \"\"\"\n    dx = L / nx\n    # Manufactured source s = (-1)^{i+j}\n    i = np.arange(nx)[:, None]\n    j = np.arange(ny)[None, :]\n    s = ((-1.0) ** (i + j)).astype(np.float64)\n\n    # FFT of source\n    s_hat = np.fft.fft2(s)\n\n    # Discrete Laplacian symbol\n    lam = discrete_laplacian_symbol(nx, ny, dx)\n\n    # Avoid division by zero: source has zero mean, so lam[0,0] won't be used\n    # Construct p_hat = s_hat / lam\n    # Use where to handle potential zeros robustly (though s_hat[0,0]==0)\n    p_hat = np.zeros_like(s_hat, dtype=np.complex128)\n    mask = lam != 0.0\n    p_hat[mask] = s_hat[mask] / lam[mask]\n\n    # Inverse FFT to get p\n    p = np.real(np.fft.ifft2(p_hat))\n\n    # Compute checkerboard amplitude Ap = mean(p * (-1)^{i+j})\n    pattern = ((-1.0) ** (i + j)).astype(np.float64)\n    Ap = np.sum(p * pattern) / (nx * ny)\n\n    return p, Ap, dx\n\ndef colocated_face_gradient_rms(p, dx):\n    \"\"\"\n    Compute colocated center gradients via central differences and then\n    naive face gradients by averaging adjacent center gradients.\n    Return RMS magnitude over all faces.\n    \"\"\"\n    nx, ny = p.shape\n\n    # Periodic shifts\n    p_ip = np.roll(p, -1, axis=0)\n    p_im = np.roll(p,  1, axis=0)\n    p_jp = np.roll(p, -1, axis=1)\n    p_jm = np.roll(p,  1, axis=1)\n\n    # Center gradients (central difference)\n    gx_c = (p_ip - p_im) / (2.0 * dx)\n    gy_c = (p_jp - p_jm) / (2.0 * dx)  # dx == dy\n\n    # Face gradients: average adjacent center gradients to faces\n    # x-faces at (i+1/2, j): average gx_c[i,j] and gx_c[i+1,j]\n    gx_face = 0.5 * (gx_c + np.roll(gx_c, -1, axis=0))\n    # y-faces at (i, j+1/2): average gy_c[i,j] and gy_c[i,j+1]\n    gy_face = 0.5 * (gy_c + np.roll(gy_c, -1, axis=1))\n\n    # RMS over all faces (both directions)\n    # Number of faces: 2 * nx * ny\n    rms = np.sqrt((np.sum(gx_face**2) + np.sum(gy_face**2)) / (2.0 * nx * ny))\n    return rms\n\ndef mac_face_gradient_rms(p, dx):\n    \"\"\"\n    Compute MAC face gradients directly from adjacent center pressures.\n    Return RMS magnitude over all faces.\n    \"\"\"\n    nx, ny = p.shape\n\n    # x-face gradient: (p_{i+1,j} - p_{i,j}) / dx\n    p_ip = np.roll(p, -1, axis=0)\n    gx_face = (p_ip - p) / dx\n\n    # y-face gradient: (p_{i,j+1} - p_{i,j}) / dx\n    p_jp = np.roll(p, -1, axis=1)\n    gy_face = (p_jp - p) / dx\n\n    rms = np.sqrt((np.sum(gx_face**2) + np.sum(gy_face**2)) / (2.0 * nx * ny))\n    return rms\n\ndef run_test_case(nx):\n    ny = nx\n    p, Ap, dx = solve_poisson_checkerboard(nx, ny, L=1.0)\n    rms_col = colocated_face_gradient_rms(p, dx)\n    rms_mac = mac_face_gradient_rms(p, dx)\n    return (Ap, rms_col, rms_mac)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [8, 16, 32, 64]\n\n    results = []\n    for nx in test_cases:\n        Ap, rms_col, rms_mac = run_test_case(nx)\n        # Format each tuple with reasonable precision\n        results.append(f\"({Ap:.10f},{rms_col:.10e},{rms_mac:.10e})\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了交错网格的静态特性后，我们将通过一个动态模拟来检验其实用性，即在一个平流涡旋穿过计算域的算例中应用交错网格。本练习的重点是为交错网格上的速度分量实现兼容的边界条件（入口和出口），并验证一个关键的物理原理：质量守恒。你将通过追踪离散散度的全域积分来量化数值格式（包括边界处理）在多大程度上维持了全局质量守恒。",
            "id": "3447644",
            "problem": "考虑在Marker-And-Cell (MAC)网格上离散的二维不可压缩流。MAC网格将$x$方向速度分量$u$存储在垂直单元面（索引$i+\\tfrac{1}{2}, j$），将$y$方向速度分量$v$存储在水平单元面（索引$i, j+\\tfrac{1}{2}$），并将压力$p$存储在单元中心（索引$i, j$）。设计算域为$\\Omega = [0,L_x]\\times[0,L_y]$，其中$x$方向有$N_x$个单元，$y$方向有$N_y$个单元。因此，面心数组的形状为$u\\in\\mathbb{R}^{(N_x+1)\\times N_y}$和$v\\in\\mathbb{R}^{N_x\\times (N_y+1)}$，而单元中心网格的形状为$\\mathbb{R}^{N_x\\times N_y}$。均匀网格间距为$ \\Delta x = L_x/N_x $和$ \\Delta y = L_y/N_y$。\n\n要求您为一个离开计算域右边界（$x=L_x$）的涡实现一个一阶显式对流出流边界条件，并通过追踪离散散度的域积分来数值上验证全局质量守恒。该流场包含一个均匀的背景平流和一个由流函数定义的局部涡。\n\n基础理论：\n- 对于恒定密度，不可压缩连续性方程为$ \\nabla\\cdot \\mathbf{u} = 0 $，其中$\\mathbf{u}=(u,v)$。\n- 涡由流函数$\\psi$指定，使得$ u = \\partial \\psi/\\partial y $和$ v = -\\partial \\psi/\\partial x $，这在连续情况下确保$ \\nabla\\cdot \\mathbf{u}=0 $。\n- 我们考虑速度分量由$+x$方向的均匀背景速度$U_0$输运。每个速度分量都遵循一个线性平流方程$ \\partial \\phi / \\partial t + U_0 \\, \\partial \\phi / \\partial x = 0 $，其中$\\phi$代表$u$或$v$。虽然这种解耦的输运在离散层面上不强制不可压缩性，但连续散度保持为零，散度的数值积分可用于衡量由离散化和边界处理引入的质量守恒误差。\n\n初始条件：\n- 设时刻$t=0$时的流函数为\n$$\n\\psi(x,y,0) = A \\exp\\!\\left( -\\frac{(x-x_0)^2 + (y-y_0)^2}{R^2}\\right),\n$$\n其中幅值$A>0$，核心半径$R>0$。相应的涡速度为\n$$\nu_{\\text{vtx}}(x,y,0) = \\frac{2A}{R^2}\\,(y-y_0)\\,\\exp\\!\\left( -\\frac{(x-x_0)^2 + (y-y_0)^2}{R^2}\\right),\n\\qquad\nv_{\\text{vtx}}(x,y,0) = -\\frac{2A}{R^2}\\,(x-x_0)\\,\\exp\\!\\left( -\\frac{(x-x_0)^2 + (y-y_0)^2}{R^2}\\right).\n$$\n叠加一个均匀的背景$x$方向速度$U_0$，使得初始总速度为$ u(x,y,0) = U_0 + u_{\\text{vtx}}(x,y,0) $和$ v(x,y,0) = v_{\\text{vtx}}(x,y,0) $。\n\n时间推进和边界条件：\n- 每个速度分量都通过$x$方向线性平流方程的显式迎风离散格式进行时间推进，库朗数为$\\text{CFL}= U_0 \\Delta t / \\Delta x$：\n  - $u$的内部$x$方向面：\n    $$\n    u_{i,j}^{n+1} = u_{i,j}^{n} - \\text{CFL}\\,\\left(u_{i,j}^{n} - u_{i-1,j}^{n}\\right), \\quad i=1,\\dots,N_x,\n    $$\n    其中$u_{i,j}$表示在面索引$i$（对应物理位置$x=i\\Delta x$, $y=(j+\\tfrac{1}{2})\\Delta y$）处的值。\n  - $v$的内部$x$方向索引：\n    $$\n    v_{i,j}^{n+1} = v_{i,j}^{n} - \\text{CFL}\\,\\left(v_{i,j}^{n} - v_{i-1,j}^{n}\\right), \\quad i=1,\\dots,N_x-1,\n    $$\n    其中$v_{i,j}$表示在面索引$i$（位置$x=(i+\\tfrac{1}{2})\\Delta x$, $y=j\\Delta y$）处的值。\n- 西侧入流边界（$x=0$）由解析对流的涡和背景流设定。涡中心平流为$x_c(t)=x_0+U_0 t$, $y_c(t)=y_0$。对于$x=0$处的$u$，使用面位置$x=0$, $y=(j+\\tfrac{1}{2})\\Delta y$；对于第一个面索引$i=0$处的$v$，使用$x=\\tfrac{1}{2}\\Delta x$, $y=j\\Delta y$。入流值由下式给出：\n  $$\n  u_{\\text{in}}(y,t)=U_0 + \\frac{2A}{R^2}\\,(y-y_0)\\,\\exp\\!\\left( -\\frac{(0-x_c(t))^2 + (y-y_0)^2}{R^2}\\right),\n  $$\n  $$\n  v_{\\text{in}}(y,t)=-\\frac{2A}{R^2}\\,\\left(\\tfrac{1}{2}\\Delta x - x_c(t)\\right)\\,\\exp\\!\\left( -\\frac{\\left(\\tfrac{1}{2}\\Delta x - x_c(t)\\right)^2 + (y-y_0)^2}{R^2}\\right).\n  $$\n  西侧边界索引的一阶边界更新为\n  $$\n  u_{0,j}^{n+1} = u_{0,j}^{n} - \\text{CFL}\\,\\left(u_{0,j}^{n} - u_{\\text{in}}(y_{j+\\frac{1}{2}},t^n)\\right),\n  \\qquad\n  v_{0,j}^{n+1} = v_{0,j}^{n} - \\text{CFL}\\,\\left(v_{0,j}^{n} - v_{\\text{in}}(y_{j},t^n)\\right).\n  $$\n- 东侧对流出流边界（$x=L_x$）应用与内部迎风格式一致的单边对流更新：\n  $$\n  u_{N_x,j}^{n+1} = u_{N_x,j}^{n} - \\text{CFL}\\,\\left(u_{N_x,j}^{n} - u_{N_x-1,j}^{n}\\right),\n  \\qquad\n  v_{N_x-1,j}^{n+1} = v_{N_x-1,j}^{n} - \\text{CFL}\\,\\left(v_{N_x-1,j}^{n} - v_{N_x-2,j}^{n}\\right).\n  $$\n- 顶部和底部边界对$v$在$y$方向上是周期的：\n  $$\n  v_{i,N_y}^{n} \\equiv v_{i,0}^{n} \\quad \\text{for all } i \\text{ and } n.\n  $$\n  $u$数组已经在$y=(j+\\tfrac{1}{2})\\Delta y$, $j=0,\\dots,N_y-1$处定义，所以$u$不需要显式的$y$方向边界更新。\n\n离散散度及其积分：\n- 定义时刻$t^n$的单元中心离散散度为\n  $$\n  (\\nabla\\cdot \\mathbf{u})_{i,j}^{n} = \\frac{u_{i+1,j}^{n} - u_{i,j}^{n}}{\\Delta x} + \\frac{v_{i,j+1}^{n} - v_{i,j}^{n}}{\\Delta y},\n  \\quad i=0,\\dots,N_x-1,\\quad j=0,\\dots,N_y-1.\n  $$\n- 域积分为\n  $$\n  I^n = \\int_{\\Omega} \\nabla\\cdot\\mathbf{u}\\,d\\Omega \\approx \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} \\left( \\frac{u_{i+1,j}^{n} - u_{i,j}^{n}}{\\Delta x} + \\frac{v_{i,j+1}^{n} - v_{i,j}^{n}}{\\Delta y} \\right)\\,\\Delta x\\,\\Delta y.\n  $$\n- 在连续不可压缩情况下，该积分对所有$t$恒为零。在数值上，$I^n$用于诊断可归因于离散化和边界处理的质量守恒误差。您必须追踪所有$n$的$I^n$直到涡离开计算域，并报告最大绝对值$\\max_n |I^n|$。\n\n单位：\n- $L_x$和$L_y$的单位是米($\\mathrm{m}$)，$U_0$的单位是米/秒($\\mathrm{m/s}$)，$A$的单位是平方米/秒($\\mathrm{m}^2/\\mathrm{s}$)，$R$、$x_0$、$y_0$的单位是米($\\mathrm{m}$)，时间的单位是秒($\\mathrm{s}$)。以$\\mathrm{m}^2/\\mathrm{s}$为单位报告最终输出。\n\n测试套件：\n- 对于每个测试用例，使用时间步长$\\Delta t = \\text{CFL}\\cdot \\Delta x / U_0$进行计算，并推进到最终时间$T$，该时间足以让涡中心越过右边界并超出一段额外距离$m R$（其中$m=1.5$）：\n  $$\n  T = \\frac{L_x - x_0 + m R}{U_0}.\n  $$\n- 测试用例：\n  1. $N_x=64$, $N_y=64$, $L_x=1.0$, $L_y=1.0$, $U_0=1.0$, $A=0.05$, $R=0.10$, $x_0=0.20$, $y_0=0.50$, $\\text{CFL}=0.60$。\n  2. $N_x=32$, $N_y=32$, $L_x=1.0$, $L_y=1.0$, $U_0=1.0$, $A=0.08$, $R=0.08$, $x_0=0.20$, $y_0=0.30$, $\\text{CFL}=0.95$。\n  3. $N_x=48$, $N_y=48$, $L_x=1.0$, $L_y=1.0$, $U_0=0.50$, $A=0.04$, $R=0.06$, $x_0=0.40$, $y_0=0.90$, $\\text{CFL}=0.70$。\n\n您的任务：\n- 在MAC网格上，使用指定的入流和对流出流边界条件以及$v$的$y$方向周期性，实现$u$和$v$的显式迎风平流更新。\n- 使用指定的流函数涡和背景流初始化场。\n- 在每个时间步，计算$I^n$并追踪$\\max_n |I^n|$。\n- 对每个测试用例，返回单个浮点数$\\max_n |I^n|$，单位为$\\mathrm{m}^2/\\mathrm{s}$。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含三个测试用例的结果，格式为包含在方括号中的逗号分隔列表，例如$[r_1,r_2,r_3]$，其中每个$r_k$是一个单位为$\\mathrm{m}^2/\\mathrm{s}$的浮点数。",
            "solution": "用户提供了一个计算流体动力学问题，在尝试求解之前需要进行验证。\n\n### 步骤1：提取已知条件\n\n- **问题域**：一个二维域 $\\Omega = [0,L_x]\\times[0,L_y]$。\n- **网格类型**：Marker-And-Cell (MAC) 交错网格，包含 $N_x \\times N_y$ 个单元。\n- **网格间距**：均匀间距 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。\n- **变量位置**：\n  - $x$方向速度 $u$：位于垂直单元面上，索引为 $(i+\\tfrac{1}{2}, j)$。数组形状为 $u\\in\\mathbb{R}^{(N_x+1)\\times N_y}$。\n  - $y$方向速度 $v$：位于水平单元面上，索引为 $(i, j+\\tfrac{1}{2})$。数组形状为 $v\\in\\mathbb{R}^{N_x\\times (N_y+1)}$。\n  - 压力 $p$：位于单元中心，索引为 $(i, j)$。数组形状为 $\\mathbb{R}^{N_x\\times N_y}$。\n- **控制方程**：\n  - 不可压缩性：$\\nabla\\cdot \\mathbf{u} = 0$。\n  - 每个速度分量的线性平流方程：$\\partial \\phi / \\partial t + U_0 \\, \\partial \\phi / \\partial x = 0$，其中 $\\phi$ 为 $u$ 或 $v$。\n- **初始条件 ($t=0$)**：\n  - 流函数：$\\psi(x,y,0) = A \\exp\\!\\left( -\\frac{(x-x_0)^2 + (y-y_0)^2}{R^2}\\right)$。\n  - 总速度：$u(x,y,0) = U_0 + u_{\\text{vtx}}(x,y,0)$ 和 $v(x,y,0) = v_{\\text{vtx}}(x,y,0)$。\n  - 涡速度分量：\n    $u_{\\text{vtx}}(x,y,0) = \\frac{2A}{R^2}\\,(y-y0)\\,\\exp\\!\\left( -\\frac{(x-x_0)^2 + (y-y_0)^2}{R^2}\\right)$。\n    $v_{\\text{vtx}}(x,y,0) = -\\frac{2A}{R^2}\\,(x-x_0)\\,\\exp\\!\\left( -\\frac{(x-x_0)^2 + (y-y_0)^2}{R^2}\\right)$。\n- **时间推进（显式迎风）**：\n  - 库朗数：$\\text{CFL}= U_0 \\Delta t / \\Delta x$。\n  - 内部 $u$：$u_{i,j}^{n+1} = u_{i,j}^{n} - \\text{CFL}\\,\\left(u_{i,j}^{n} - u_{i-1,j}^{n}\\right)$，对于 $i=1,\\dots,N_x$。\n  - 内部 $v$：$v_{i,j}^{n+1} = v_{i,j}^{n} - \\text{CFL}\\,\\left(v_{i,j}^{n} - v_{i-1,j}^{n}\\right)$，对于 $i=1,\\dots,N_x-1$。\n- **边界条件**：\n  - **西侧入流 ($x=0$)**：基于涡的解析平流。中心位置为 $x_c(t)=x_0+U_0 t$。\n    - 入流剖面：\n      $u_{\\text{in}}(y,t)=U_0 + \\frac{2A}{R^2}\\,(y-y_0)\\,\\exp\\!\\left( -\\frac{(-x_c(t))^2 + (y-y_0)^2}{R^2}\\right)$。\n      $v_{\\text{in}}(y,t)=-\\frac{2A}{R^2}\\,\\left(\\tfrac{1}{2}\\Delta x - x_c(t)\\right)\\,\\exp\\!\\left( -\\frac{\\left(\\tfrac{1}{2}\\Delta x - x_c(t)\\right)^2 + (y-y_0)^2}{R^2}\\right)$。\n    - 更新规则：\n      $u_{0,j}^{n+1} = u_{0,j}^{n} - \\text{CFL}\\,\\left(u_{0,j}^{n} - u_{\\text{in}}(y_{j+\\frac{1}{2}},t^n)\\right)$。\n      $v_{0,j}^{n+1} = v_{0,j}^{n} - \\text{CFL}\\,\\left(v_{0,j}^{n} - v_{\\text{in}}(y_{j},t^n)\\right)$。\n  - **东侧出流 ($x=L_x$)**：对流（单边迎风）。\n    - $u_{N_x,j}^{n+1} = u_{N_x,j}^{n} - \\text{CFL}\\,\\left(u_{N_x,j}^{n} - u_{N_x-1,j}^{n}\\right)$。\n    - $v_{N_x-1,j}^{n+1} = v_{N_x-1,j}^{n} - \\text{CFL}\\,\\left(v_{N_x-1,j}^{n} - v_{N_x-2,j}^{n}\\right)$。\n  - **顶部/底部 ($y$)**：对 $v$ 呈周期性。\n    - $v_{i,N_y}^{n} \\equiv v_{i,0}^{n}$，对所有 $i$ 和 $n$。\n    - $u$ 无需显式 $y$ 方向边界更新。\n- **分析任务**：\n  - 离散散度：$(\\nabla\\cdot \\mathbf{u})_{i,j}^{n} = \\frac{u_{i+1,j}^{n} - u_{i,j}^{n}}{\\Delta x} + \\frac{v_{i,j+1}^{n} - v_{i,j}^{n}}{\\Delta y}$。\n  - 散度的域积分：$I^n = \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} (\\nabla\\cdot \\mathbf{u})_{i,j}^{n}\\,\\Delta x\\,\\Delta y$。\n  - 要求输出：对每个测试用例，报告 $\\max_n |I^n|$。\n- **模拟时间**：在 $T = \\frac{L_x - x_0 + m R}{U_0}$ 时停止，其中 $m=1.5$。\n- **测试用例**：\n  1. $N_x=64$, $N_y=64$, $L_x=1.0$, $L_y=1.0$, $U_0=1.0$, $A=0.05$, $R=0.10$, $x_0=0.20$, $y_0=0.50$, $\\text{CFL}=0.60$。\n  2. $N_x=32$, $N_y=32$, $L_x=1.0$, $L_y=1.0$, $U_0=1.0$, $A=0.08$, $R=0.08$, $x_0=0.20$, $y_0=0.30$, $\\text{CFL}=0.95$。\n  3. $N_x=48$, $N_y=48$, $L_x=1.0$, $L_y=1.0$, $U_0=0.50$, $A=0.04$, $R=0.06$, $x_0=0.40$, $y_0=0.90$, $\\text{CFL}=0.70$。\n\n### 步骤2：使用提取的已知条件进行验证\n\n- **科学基础**：该问题是计算流体动力学（CFD）中的一个标准练习。它涉及线性平流方程、MAC网格离散化、显式迎风格式和标准边界条件。使用流函数导出的涡是生成初始无散流场的常用技术。分析离散散度积分是评估质量守恒误差的标准方法。该问题牢固地植根于已建立的科学原理。\n- **适定的**：该问题是适定的。速度场的初始条件已完全指定。演化由显式数值格式控制。计算域的所有外边界都定义了边界条件。给定的库朗数（$\\text{CFL} \\le 0.95$）在一阶显式迎风格式的稳定性极限 $\\text{CFL} \\le 1$ 之内，确保了数值解的稳定性。任务是找到在模拟时间内某个计算量的最大值，这是一个唯一定义的值。\n- **客观的**：该问题以精确、客观、数学化和算法化的术语陈述。没有主观或含糊的语言。\n- **缺陷清单**：\n  1.  **科学/事实不健全**：无。所涉及的物理和数学是标准的。\n  2.  **非形式化/不相关**：无。该问题是一个直接与CFD和MAC网格相关的形式化数值方法任务。\n  3.  **不完整/矛盾的设置**：问题是详细且自洽的。数组维度、索引约定和更新规则彼此一致。例如，$u_{N_x,j}$ 的出流条件与应用于 $i=N_x$ 的通用内部更新规则相同；$v_{N_x-1,j}$ 也是如此。这代表了在边界上一致地应用迎风模板，而不是矛盾。$v$ 的周期性条件对于顶行单元的离散散度计算是必要的。所有必需的参数都已提供。\n  4.  **不切实际/不可行**：无。这些参数定义了一个标准的“对流涡”测试案例。\n  5.  **不适定/结构不良**：无。存在唯一解且可以计算。\n  6.  **故作高深/琐碎**：无。该问题需要正确实现一个非平凡的数值算法。\n  7.  **超出科学可验证范围**：无。结果是数值上可验证的。\n\n### 步骤3：结论与行动\n\n问题是有效的。我将继续进行求解。\n\n### 解决方案的原理设计\n\n该解决方案涉及模拟一个涡在MAC（Marker-And-Cell）网格上离散化的二维域中的平流过程。实现的核心是一个时间步进循环，该循环对速度分量 $u$ 和 $v$ 应用一阶显式迎风格式。\n\n**1. 网格与初始化：**\n首先，我们根据给定参数（$N_x, N_y, L_x, L_y$）建立计算网格。MAC网格的一个关键特征是变量的交错放置。$u$ 速度分量位于垂直单元面上，$v$ 速度分量位于水平单元面上。这需要创建两组不同的坐标网格。我们将使用NumPy的 `meshgrid` 和 `indexing='ij'` 来生成坐标数组 `(X_u, Y_u)` 和 `(X_v, Y_v)`，分别对应 $u$ 和 $v$ 变量的物理位置。速度场 $u$ 和 $v$ 在 $t=0$ 时通过在这些交错网格位置上评估其解析公式来初始化，这些公式描述了一个叠加在均匀流上的高斯涡。初始化后，将强制执行 $v$ 场在 $y$ 方向上的周期性边界条件 $v_{i,N_y} = v_{i,0}$。\n\n**2. 时间积分与离散化：**\n速度场的演化由线性平流方程控制，该方程使用一阶显式迎风格式进行离散化。由于平流速度 $U_0$ 是正的，对于任何网格变量 $\\phi_i$ 的格式为 $\\phi_i^{n+1} = \\phi_i^n - \\text{CFL}(\\phi_i^n - \\phi_{i-1}^n)$，其中 $\\text{CFL} = U_0 \\Delta t / \\Delta x$。此更新独立地应用于 $u$ 和 $v$ 场。我们将以向量化的方式实现这些更新以提高效率，将它们应用于代表速度场的NumPy数组的适当切片。\n\n**3. 边界条件：**\n- **入流（西侧, $x=0$）：** 问题指定了一种松弛型边界条件，其中边界值根据其前一时刻的值和解析规定的入流值进行更新。该入流值代表了穿过边界的平流涡的精确解。这将在每个时间步计算。\n- **出流（东侧, $x=L_x$）：** 使用了一个简单的对流出流条件，这等同于在边界上应用与内部相同的迎风有限差分模板。这允许信息传播出计算域。我们的向量化内部更新自然地处理了这种情况。\n- **周期性（顶部/底部, $y$）：** $v$ 场的周期性在每个时间步结束时通过将顶部边界（$j=N_y$）的值设置为等于底部边界（$j=0$）的值来强制执行。这是必要的，因为初始涡剖面和入流条件在 $y$ 方向上不是天生周期的。\n\n**4. 质量守恒分析：**\n问题要求通过追踪离散散度的域积分 $I^n$ 来监控全局质量守恒。在具有 $v$ 的顶部/底部周期性边界的MAC网格上，离散形式的散度定理极大地简化了积分计算。积分 $\\int \\nabla \\cdot \\mathbf{u} \\, d\\Omega$ 变为穿过域的东、西边界的净通量：\n$$I^n = \\sum_{j=0}^{N_y-1} (u_{N_x,j}^n - u_{0,j}^n) \\, \\Delta y$$\n这个简化公式避免了在每个单元上计算散度，使得分析步骤非常高效。在每个时间步，我们计算 $I^n$ 并更新其绝对值的运行最大值 $\\max_n|I^n|$。\n\n模拟运行总时间为 $T$，该时间经计算以确保涡完全离开计算域。每个测试用例的最终结果是计算出的 $\\max_n|I^n|$ 值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, Lx, Ly, U0, A, R, x0, y0, CFL)\n        (64, 64, 1.0, 1.0, 1.0, 0.05, 0.10, 0.20, 0.50, 0.60),\n        (32, 32, 1.0, 1.0, 1.0, 0.08, 0.08, 0.20, 0.30, 0.95),\n        (48, 48, 1.0, 1.0, 0.50, 0.04, 0.06, 0.40, 0.90, 0.70),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(*params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_simulation(Nx, Ny, Lx, Ly, U0, A, R, x0, y0, CFL):\n    \"\"\"\n    Executes a single simulation case for the vortex advection problem.\n    \"\"\"\n    # Grid and time parameters\n    dx = Lx / Nx\n    dy = Ly / Ny\n    dt = CFL * dx / U0\n    m = 1.5\n    T_final = (Lx - x0 + m * R) / U0\n    num_steps = int(np.ceil(T_final / dt))\n\n    # --- Grid coordinates ---\n    # U-velocity component grid\n    # u is at (i*dx, (j+0.5)*dy) for i in [0,Nx], j in [0,Ny-1]\n    # Array shape: (Nx+1, Ny) -> u[i, j]\n    x_u_pts = np.arange(Nx + 1) * dx\n    y_u_pts = (np.arange(Ny) + 0.5) * dy\n    X_u, Y_u = np.meshgrid(x_u_pts, y_u_pts, indexing='ij')\n\n    # V-velocity component grid\n    # v is at ((i+0.5)*dx, j*dy) for i in [0,Nx-1], j in [0,Ny]\n    # Array shape: (Nx, Ny+1) -> v[i, j]\n    x_v_pts = (np.arange(Nx) + 0.5) * dx\n    y_v_pts = np.arange(Ny + 1) * dy\n    X_v, Y_v = np.meshgrid(x_v_pts, y_v_pts, indexing='ij')\n\n    # --- Initial Conditions ---\n    # u(x,y,0) = U0 + u_vtx(x,y,0)\n    u_vortex_term = (2 * A / R**2) * (Y_u - y0) * np.exp(-((X_u - x0)**2 + (Y_u - y0)**2) / R**2)\n    u = U0 + u_vortex_term\n\n    # v(x,y,0) = v_vtx(x,y,0)\n    v_vortex_term = -(2 * A / R**2) * (X_v - x0) * np.exp(-((X_v - x0)**2 + (Y_v - y0)**2) / R**2)\n    v = v_vortex_term\n    \n    # Enforce periodic boundary condition for v at t=0\n    v[:, Ny] = v[:, 0]\n\n    max_abs_I = 0.0\n\n    # --- Time-stepping loop ---\n    for n in range(num_steps):\n        # 1. Calculate integral of divergence at time t^n\n        # I^n = Integral(div(u)) dOmega = Sum_j (u_{Nx,j} - u_{0,j}) dy\n        # This uses the discrete divergence theorem and y-periodicity of v.\n        I_n = dy * np.sum(u[Nx, :] - u[0, :])\n        max_abs_I = max(max_abs_I, abs(I_n))\n\n        # 2. Store fields at time t^n for update calculation\n        u_n = u.copy()\n        v_n = v.copy()\n        \n        # 3. Time at current step for analytic BC evaluation\n        current_time = n * dt\n        \n        # 4. Update interior and east boundary (i > 0)\n        # u update for i=1..Nx. Includes east outflow BC at i=Nx.\n        u[1:Nx+1, :] = u_n[1:Nx+1, :] - CFL * (u_n[1:Nx+1, :] - u_n[0:Nx, :])\n        # v update for i=1..Nx-1. Includes east outflow BC at i=Nx-1.\n        v[1:Nx, :]   = v_n[1:Nx, :]   - CFL * (v_n[1:Nx, :]   - v_n[0:Nx-1, :])\n        \n        # 5. Update west inflow boundary (i = 0)\n        x_c_n = x0 + U0 * current_time\n\n        # Calculate u_in at x=0\n        # y_u_pts are the y-coordinates for the u-grid\n        u_in_val = U0 + (2 * A / R**2) * (y_u_pts - y0) * np.exp(-((0.0 - x_c_n)**2 + (y_u_pts - y0)**2) / R**2)\n        u[0, :] = u_n[0, :] - CFL * (u_n[0, :] - u_in_val)\n        \n        # Calculate v_in for v[0,:] at x = 0.5*dx\n        # y_v_pts are the y-coordinates for the v-grid\n        v_in_x_coord = 0.5 * dx\n        v_in_val = -(2 * A / R**2) * (v_in_x_coord - x_c_n) * np.exp(-((v_in_x_coord - x_c_n)**2 + (y_v_pts - y0)**2) / R**2)\n        v[0, :] = v_n[0, :] - CFL * (v_n[0, :] - v_in_val)\n\n        # 6. Enforce y-periodicity for v\n        v[:, Ny] = v[:, 0]\n        \n    return max_abs_I\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "除了稳定性之外，交错网格还拥有一种更深刻的代数和几何性质，即它能在离散层面精确地模拟连续微积分中的基本矢量恒等式。在本练习中，你将实现离散的梯度（$\\nabla$）、旋度（$\\nabla \\times$）和散度（$\\nabla \\cdot$）算子，并验证连续算子的复合运算在离散后仍然为零，例如梯度的旋度恒为零（$\\nabla \\times (\\nabla \\phi) = \\mathbf{0}$）。这个实践揭示了交错网格如何保持了物理定律的内在几何结构，这是所谓“保结构”（mimetic）离散格式的一个关键特征。",
            "id": "3365595",
            "problem": "考虑三维空间中均匀正交网格的标记网格法（Marker-And-Cell, MAC）布局。设计算域为 $\\Omega = [0,L_x]\\times[0,L_y]\\times[0,L_z]$，其中 $L_x=L_y=L_z=1$。将 $\\Omega$ 离散化为 $N_x \\times N_y \\times N_z$ 个单元，其间距为 $h_x = L_x/N_x$，$h_y = L_y/N_y$，$h_z = L_z/N_z$。使用典型的离散 de Rham 序列布局：\n- 节点中心（角点）的 $0$-形式值：在所有节点 $(i,j,k)$ 上定义的标量场 $\\phi$，其中 $i\\in\\{0,\\dots,N_x\\}$，$j\\in\\{0,\\dots,N_y\\}$，$k\\in\\{0,\\dots,N_z\\}$。\n- 边中心的 $1$-形式值：与边对齐的向量。设 $\\mathbf{e}_x$ 定义在与 $x$ 方向平行的边上，形状为 $(N_x, N_y+1, N_z+1)$；$\\mathbf{e}_y$ 定义在与 $y$ 方向平行的边上，形状为 $(N_x+1, N_y, N_z+1)$；$\\mathbf{e}_z$ 定义在与 $z$ 方向平行的边上，形状为 $(N_x+1, N_y+1, N_z)$。\n- 面中心的 $2$-形式值：与面垂直的向量。设 $f_x$ 定义在与 $x$ 轴垂直的面上，形状为 $(N_x+1, N_y, N_z)$；$f_y$ 定义在与 $y$ 轴垂直的面上，形状为 $(N_x, N_y+1, N_z)$；$f_z$ 定义在与 $z$ 轴垂直的面上，形状为 $(N_x, N_y, N_z+1)$。\n- 单元中心的 $3$-形式值：每个单元上定义的标量，形状为 $(N_x, N_y, N_z)$。\n\n从线积分、面积分和体积分及其离散对应形式的基本定义出发，定义以下在这些布局之间进行映射的相容离散算子：\n1. 从节点到边的标量 $\\phi$ 的离散梯度，在边上记为 $\\nabla \\phi$，通过沿边方向的前向差分计算，\n$$\ne_x[i,j,k] = \\frac{\\phi[i+1,j,k] - \\phi[i,j,k]}{h_x},\\quad\ne_y[i,j,k] = \\frac{\\phi[i,j+1,k] - \\phi[i,j,k]}{h_y},\\quad\ne_z[i,j,k] = \\frac{\\phi[i,j,k+1] - \\phi[i,j,k]}{h_z}.\n$$\n2. 从边到面的离散旋度，在面上记为 $\\nabla\\times\\mathbf{E}$（其中 $\\mathbf{E}$ 汇集了 $(e_x,e_y,e_z)$），定义为每个面周围的单位面积有向环流量，\n$$\n\\begin{aligned}\n(\\nabla\\times\\mathbf{E})_x[i,j,k] = \\frac{e_z[i,j+1,k]-e_z[i,j,k]}{h_y} - \\frac{e_y[i,j,k+1]-e_y[i,j,k]}{h_z},\\\\\n(\\nabla\\times\\mathbf{E})_y[i,j,k] = \\frac{e_x[i,j,k+1]-e_x[i,j,k]}{h_z} - \\frac{e_z[i+1,j,k]-e_z[i,j,k]}{h_x},\\\\\n(\\nabla\\times\\mathbf{E})_z[i,j,k] = \\frac{e_y[i+1,j,k]-e_y[i,j,k]}{h_x} - \\frac{e_x[i,j+1,k]-e_x[i,j,k]}{h_y}.\n\\end{aligned}\n$$\n3. 从面到单元的离散散度，在单元中心记为 $\\nabla\\cdot\\mathbf{F}$（其中 $\\mathbf{F}$ 汇集了面法向分量 $(f_x,f_y,f_z)$），定义为单位体积有向面通量，\n$$\n(\\nabla\\cdot\\mathbf{F})[i,j,k] = \\frac{f_x[i+1,j,k]-f_x[i,j,k]}{h_x} + \\frac{f_y[i,j+1,k]-f_y[i,j,k]}{h_y} + \\frac{f_z[i,j,k+1]-f_z[i,j,k]}{h_z}.\n$$\n\n你的任务：\n- 实现上述指定的离散算子，严格遵守其布局和索引范围。\n- 解析地验证，对于内部区域，在均匀网格上使用这些前向差分和环量定义，复合算子 $\\nabla\\times(\\nabla \\phi)$ 在面上得到零向量，复合算子 $\\nabla\\cdot(\\nabla\\times \\mathbf{A})$ 在单元上得到零标量。这对节点上任意足够光滑的场 $\\phi$ 和边上任意足够光滑的场 $\\mathbf{A}$ 都成立。解释为什么这些离散恒等式在类周期性的内部索引（无幽灵单元访问）下成立。\n- 构建一个数值测试框架，以量化以下各项的最大绝对违背值：\n  - 面上的 $\\nabla\\times(\\nabla \\phi)=\\mathbf{0}$，\n  - 单元上的 $\\nabla\\cdot(\\nabla\\times \\mathbf{A}) = 0$。\n  使用光滑的确定性场：\n  - 节点标量 $\\,\\phi(i,j,k) = \\sin(2\\pi x_i)\\sin(3\\pi y_j)\\sin(5\\pi z_k)\\,$，其中 $\\,x_i = i h_x\\,$, $\\,y_j = j h_y\\,$, $\\,z_k = k h_z\\,$。\n  - 在边中点计算的边向量势分量：\n    $$\n    \\begin{aligned}\n    A_x(i+\\tfrac{1}{2},j,k) = \\sin(2\\pi y_j)\\sin(3\\pi z_k),\\\\\n    A_y(i,j+\\tfrac{1}{2},k) = \\sin(2\\pi z_k)\\sin(3\\pi x_i),\\\\\n    A_z(i,j,k+\\tfrac{1}{2}) = \\sin(2\\pi x_i)\\sin(3\\pi y_j).\n    \\end{aligned}\n    $$\n- 实现三种边界闭合模式以检验这些恒等式：\n  - “periodic”：除了上述定义的内部索引算子外，不执行任何操作。\n  - “dirichlet”：在边上计算 $\\nabla \\phi$ 后，将所有位于物理边界上的边值（任何横向索引等于 $0$ 或其最大值）设为零；并且，独立地，在面上计算 $\\nabla\\times \\mathbf{A}$ 后，将所有边界面（任何沿其轴向的索引等于 $0$ 或最大值）设为零。这模拟了通常会破坏复形精确性的朴素钳制闭合。\n  - “neumann”：计算 $\\nabla \\phi$ 后，将所有方向垂直于边界且在该方向上的位置索引位于边界上的边分量设为零（例如，对于 $e_x$，将 $i=0$ 和 $i=N_x-1$ 处的切片置零；对 $e_y$ 和 $e_z$ 也类似）；并且，独立地，计算 $\\nabla\\times \\mathbf{A}$ 后，将每个方向上与边界对齐索引处的面法向分量置零。这模拟了通常也会破坏精确性的朴素通量闭合。\n\n对于每个测试用例，计算两个浮点数：\n- $v_{\\mathrm{curlgrad}}$：在所有面上 $\\nabla\\times(\\nabla \\phi)$ 各分量绝对值的最大值，\n- $v_{\\mathrm{divcurl}}$：在所有单元上 $\\nabla\\cdot(\\nabla\\times \\mathbf{A})$ 绝对值的最大值。\n\n设计以下测试套件（所有用例均设 $L_x=L_y=L_z=1$）：\n- 用例 1：$N_x=16$，$N_y=12$，$N_z=8$，边界模式“periodic”。\n- 用例 2：$N_x=16$，$N_y=12$，$N_z=8$，边界模式“dirichlet”。\n- 用例 3：$N_x=16$，$N_y=12$，$N_z=8$，边界模式“neumann”。\n- 用例 4：$N_x=2$，$N_y=2$，$N_z=2$，边界模式“periodic”（边界主导的粗网格）。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[v_{\\mathrm{curlgrad}}^{(1)},v_{\\mathrm{divcurl}}^{(1)},v_{\\mathrm{curlgrad}}^{(2)},v_{\\mathrm{divcurl}}^{(2)},v_{\\mathrm{curlgrad}}^{(3)},v_{\\mathrm{divcurl}}^{(3)},v_{\\mathrm{curlgrad}}^{(4)},v_{\\mathrm{divcurl}}^{(4)}]$。\n所有量均为无量纲浮点数。不要四舍五入；按计算结果打印原始浮点值。",
            "solution": "所述问题在形式上是合理的，并涉及偏微分方程数值解中的一个基本概念，即交错网格上的离散向量微积分算子的性质。该问题有科学依据、适定且客观。所有定义、数据和约束都已提供，从而可以得到一个唯一且可验证的解。\n\n该问题要求对两个关键向量恒等式的离散形式进行解析验证，并通过数值实现来测试这些恒等式在各种边界闭合条件下的表现。\n\n### 离散恒等式的解析验证\n\n问题定义了一系列离散微分算子（梯度、旋度、散度），它们类似于连续向量微积分中的算子。这种构造是离散 de Rham 复形的一个具体实例。这类复形的一个关键性质是，序列中任意两个连续算子的复合结果为零。我们将对组合 $\\nabla\\times(\\nabla\\phi)$ 和 $\\nabla\\cdot(\\nabla\\times\\mathbf{A})$ 进行验证。\n\n**1. 恒等式：$\\nabla\\times(\\nabla \\phi) = \\mathbf{0}$**\n\n该恒等式是“梯度的旋度为零”的离散模拟。我们验证该向量恒等式的 x 分量；y 和 z 分量的证明可通过对指标进行循环置换而类似地得出。\n\n向量场 $\\mathbf{E}$ 的离散旋度的 x 分量定义为：\n$$\n(\\nabla\\times\\mathbf{E})_x[i,j,k] = \\frac{e_z[i,j+1,k]-e_z[i,j,k]}{h_y} - \\frac{e_y[i,j,k+1]-e_y[i,j,k]}{h_z}\n$$\n我们代入 $\\mathbf{E} = \\nabla\\phi$，其中离散梯度的分量为：\n$$\ne_y[i,j,k] = \\frac{\\phi[i,j+1,k] - \\phi[i,j,k]}{h_y} \\quad \\text{和} \\quad e_z[i,j,k] = \\frac{\\phi[i,j,k+1] - \\phi[i,j,k]}{h_z}\n$$\n将这些代入旋度公式：\n$$\n(\\nabla\\times(\\nabla \\phi))_x[i,j,k] = \\frac{1}{h_y} \\left( \\frac{\\phi[i,j+1,k+1] - \\phi[i,j+1,k]}{h_z} - \\frac{\\phi[i,j,k+1] - \\phi[i,j,k]}{h_z} \\right) - \\frac{1}{h_z} \\left( \\frac{\\phi[i,j+1,k+1] - \\phi[i,j,k+1]}{h_y} - \\frac{\\phi[i,j+1,k] - \\phi[i,j,k]}{h_y} \\right)\n$$\n将各项合并到公分母 $h_y h_z$下：\n$$\n= \\frac{1}{h_y h_z} \\left( \\phi[i,j+1,k+1] - \\phi[i,j+1,k] - \\phi[i,j,k+1] + \\phi[i,j,k] \\right) - \\frac{1}{h_y h_z} \\left( \\phi[i,j+1,k+1] - \\phi[i,j,k+1] - \\phi[i,j+1,k] + \\phi[i,j,k] \\right)\n$$\n两个括号内的表达式是相同的。因此，对于任何标量场 $\\phi$，只要所有必要的节点值都可访问，它们的差就恒等于零。这种代数抵消是混合偏导数相等性（$\\partial^2\\phi/\\partial y\\partial z = \\partial^2\\phi/\\partial z\\partial y$）的离散等价形式。这对于模板不跨越边界的内部面精确成立。\n\n**2. 恒等式：$\\nabla\\cdot(\\nabla\\times \\mathbf{A}) = 0$**\n\n该恒等式是“旋度的散度为零”的离散模拟。让我们定义前向有限差分算子：\n$$\n\\delta_x f[i] = \\frac{f[i+1]-f[i]}{h_x}, \\quad \\delta_y f[j] = \\frac{f[j+1]-f[j]}{h_y}, \\quad \\delta_z f[k] = \\frac{f[k+1]-f[k]}{h_z}\n$$\n离散旋度和散度算子可以紧凑地写成：\n$$\n(\\nabla\\times\\mathbf{A})_x = \\delta_y A_z - \\delta_z A_y, \\quad (\\nabla\\times\\mathbf{A})_y = \\delta_z A_x - \\delta_x A_z, \\quad (\\nabla\\times\\mathbf{A})_z = \\delta_x A_y - \\delta_y A_x\n$$\n$$\n\\nabla\\cdot\\mathbf{F} = \\delta_x F_x + \\delta_y F_y + \\delta_z F_z\n$$\n将旋度表达式代入散度：\n$$\n\\nabla\\cdot(\\nabla\\times \\mathbf{A}) = \\delta_x (\\delta_y A_z - \\delta_z A_y) + \\delta_y (\\delta_z A_x - \\delta_x A_z) + \\delta_z (\\delta_x A_y - \\delta_y A_x)\n$$\n重新排列各项：\n$$\n= (\\delta_x \\delta_y A_z - \\delta_y \\delta_x A_z) + (\\delta_y \\delta_z A_x - \\delta_z \\delta_y A_x) + (\\delta_z \\delta_x A_y - \\delta_x \\delta_z A_y)\n$$\n在均匀正交网格上，有限差分算子是可交换的，即对于任何场 $f$ 和方向 $i,j \\in \\{x,y,z\\}$，都有 $\\delta_i \\delta_j f = \\delta_j \\delta_i f$。这可以通过直接展开来验证，就像对 $\\nabla\\times\\nabla\\phi$ 的情况所做的那样。因此括号中的每一项都恒等于零。所以，整个表达式为零。这种抵消对于所有必要的边值都由内部模板定义的内部单元精确成立。\n\n### 数值实现策略\n\n数值验证将通过实现离散算子并将其应用于光滑的、确定性的测试场来执行。\n\n**1. 算子实现：** 离散梯度、旋度和散度算子被实现为函数，这些函数接收代表网格上场的 NumPy 数组，并返回在相应交错位置上的结果场。这些实现使用向量化的 NumPy 切片来高效地计算有限差分，直接转换给定的公式。例如，像 $e_x[i,j,k] = (\\phi[i+1,j,k] - \\phi[i,j,k])/h_x$ 这样的差分，在 `phi` 数组的相关切片上实现为 `(phi[1:,:,:] - phi[:-1,:,:]) / hx`。\n\n**2. 测试场生成：**\n- 对于 $\\nabla\\times(\\nabla\\phi)$ 测试，构造一个节点标量场 $\\phi$。首先，为所有节点位置 $(x_i, y_j, z_k)$ 生成坐标数组。然后，在节点网格上对指定函数 $\\phi(x,y,z) = \\sin(2\\pi x)\\sin(3\\pi y)\\sin(5\\pi z)$ 进行求值。\n- 对于 $\\nabla\\cdot(\\nabla\\times\\mathbf{A})$ 测试，在各自的边中心网格上构造向量势分量 $A_x, A_y, A_z$。对于每个分量，计算相关边中心的坐标。然后，在这些特定位置上对给定的函数 $A_x, A_y, A_z$ 进行求值。\n\n**3. 边界条件：**\n- **“periodic”模式：** 此模式按定义应用离散算子，不作任何修改。这对应于在内部模板上计算恒等式，在这些模板上，它们预期会精确成立（在机器浮点精度范围内）。\n- **“dirichlet”和“neumann”模式：** 这些模式旨在探测恒等式对破坏精确序列性质的边界闭合的敏感性。在计算出中间场（例如 $\\mathbf{E} = \\nabla\\phi$）后，根据问题的具体说明，将域物理边界上或附近的某些值显式设为零。例如，`curl-grad` 测试的 `dirichlet` 模式人为地将边界上的所有边值设为零。这种修改破坏了在解析验证中展示的精细代数抵消，导致 $\\nabla\\times(\\nabla\\phi)$ 和 $\\nabla\\cdot(\\nabla\\times\\mathbf{A})$ 出现非零结果，尤其是在边界附近。“dirichlet”和“neumann”之间的区别在于将*哪些*分量置零（相对于边界是切向还是法向）。根据问题对修改面中心场的具体定义，`dirichlet` 和 `neumann` 的指令对于 $\\nabla\\cdot(\\nabla\\times\\mathbf{A})$ 测试恰好是相同的。\n\n**4. 误差量化：** 对于每个测试用例，在计算出最终场（面上的 $\\nabla\\times(\\nabla\\phi)$ 或单元上的 $\\nabla\\cdot(\\nabla\\times\\mathbf{A})$）之后，计算结果场在所有分量和所有网格点上的最大绝对值。这提供了对恒等式违背程度的单一标量度量（$v_{\\mathrm{curlgrad}}$ 或 $v_{\\mathrm{divcurl}}$）。对于“periodic”情况，这些值预期在机器精度（epsilon）的量级上。对于其他情况，它们将显著更大，这表明由于边界处理导致了离散恒等式的破坏。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gradient(phi, hx, hy, hz):\n    \"\"\"Computes the discrete gradient of a node-centered scalar field phi.\"\"\"\n    # phi: (Nx+1, Ny+1, Nz+1)\n    # Output ex: (Nx, Ny+1, Nz+1), ey: (Nx+1, Ny, Nz+1), ez: (Nx+1, Ny+1, Nz)\n    ex = (phi[1:, :, :] - phi[:-1, :, :]) / hx\n    ey = (phi[:, 1:, :] - phi[:, :-1, :]) / hy\n    ez = (phi[:, :, 1:] - phi[:, :, :-1]) / hz\n    return ex, ey, ez\n\ndef curl(ex, ey, ez, hx, hy, hz):\n    \"\"\"Computes the discrete curl of an edge-centered vector field e.\"\"\"\n    # ex: (Nx, Ny+1, Nz+1), ey: (Nx+1, Ny, Nz+1), ez: (Nx+1, Ny+1, Nz)\n    # Output fx: (Nx+1, Ny, Nz), fy: (Nx, Ny+1, Nz), fz: (Nx, Ny, Nz+1)\n\n    # (curl E)_x [i,j,k] needs e_z at j, j+1 and e_y at k, k+1\n    d_y_ez = (ez[:, 1:, :] - ez[:, :-1, :]) / hy  # Shape (Nx+1, Ny, Nz)\n    d_z_ey = (ey[:, :, 1:] - ey[:, :, :-1]) / hz  # Shape (Nx+1, Ny, Nz)\n    fx = d_y_ez - d_z_ey\n\n    # (curl E)_y [i,j,k] needs e_x at k, k+1 and e_z at i, i+1\n    d_z_ex = (ex[:, :, 1:] - ex[:, :, :-1]) / hz  # Shape (Nx, Ny+1, Nz)\n    d_x_ez = (ez[1:, :, :] - ez[:-1, :, :]) / hx  # Shape (Nx, Ny+1, Nz)\n    fy = d_z_ex - d_x_ez\n    \n    # (curl E)_z [i,j,k] needs e_y at i, i+1 and e_x at j, j+1\n    d_x_ey = (ey[1:, :, :] - ey[:-1, :, :]) / hx  # Shape (Nx, Ny, Nz+1)\n    d_y_ex = (ex[:, 1:, :] - ex[:, :-1, :]) / hy  # Shape (Nx, Ny, Nz+1)\n    fz = d_x_ey - d_y_ex\n    \n    return fx, fy, fz\n\ndef divergence(fx, fy, fz, hx, hy, hz):\n    \"\"\"Computes the discrete divergence of a face-centered vector field f.\"\"\"\n    # fx: (Nx+1, Ny, Nz), fy: (Nx, Ny+1, Nz), fz: (Nx, Ny, Nz+1)\n    # Output s: (Nx, Ny, Nz)\n    d_x_fx = (fx[1:, :, :] - fx[:-1, :, :]) / hx\n    d_y_fy = (fy[:, 1:, :] - fy[:, :-1, :]) / hy\n    d_z_fz = (fz[:, :, 1:] - fz[:, :, :-1]) / hz\n    \n    s = d_x_fx + d_y_fy + d_z_fz\n    return s\n\ndef compute_errors(Nx, Ny, Nz, mode):\n    \"\"\"\n    Computes curl-grad and div-curl errors for a given grid and boundary mode.\n    \"\"\"\n    Lx, Ly, Lz = 1.0, 1.0, 1.0\n    hx, hy, hz = Lx / Nx, Ly / Ny, Lz / Nz\n\n    # --- Task 1: Verify curl(grad(phi)) = 0 ---\n    \n    # 1.1: Construct node-centered scalar field phi\n    x_nodes = np.linspace(0, Lx, Nx + 1)\n    y_nodes = np.linspace(0, Ly, Ny + 1)\n    z_nodes = np.linspace(0, Lz, Nz + 1)\n    xx, yy, zz = np.meshgrid(x_nodes, y_nodes, z_nodes, indexing='ij')\n    phi = np.sin(2 * np.pi * xx) * np.sin(3 * np.pi * yy) * np.sin(5 * np.pi * zz)\n    \n    # 1.2: Compute gradient\n    ex, ey, ez = gradient(phi, hx, hy, hz)\n    \n    # 1.3: Apply boundary closure to the edge field\n    if mode == \"dirichlet\":\n        # Zero all edge values on a physical boundary\n        ex[:, 0, :] = 0; ex[:, -1, :] = 0  # j=0, j=Ny\n        ex[:, :, 0] = 0; ex[:, :, -1] = 0  # k=0, k=Nz\n        ey[0, :, :] = 0; ey[-1, :, :] = 0  # i=0, i=Nx\n        ey[:, :, 0] = 0; ey[:, :, -1] = 0  # k=0, k=Nz\n        ez[0, :, :] = 0; ez[-1, :, :] = 0  # i=0, i=Nx\n        ez[:, 0, :] = 0; ez[:, -1, :] = 0  # j=0, j=Ny\n    elif mode == \"neumann\":\n        # Zero edge components normal to a boundary at the boundary\n        ex[0, :, :] = 0; ex[-1, :, :] = 0  # i=0, i=Nx-1\n        ey[:, 0, :] = 0; ey[:, -1, :] = 0  # j=0, j=Ny-1\n        ez[:, :, 0] = 0; ez[:, :, -1] = 0  # k=0, k=Nz-1\n\n    # 1.4: Compute curl of the (potentially modified) gradient\n    cg_fx, cg_fy, cg_fz = curl(ex, ey, ez, hx, hy, hz)\n\n    # 1.5: Compute max violation\n    v_curlgrad = np.max([\n        np.max(np.abs(cg_fx)), \n        np.max(np.abs(cg_fy)), \n        np.max(np.abs(cg_fz))\n    ])\n\n    # --- Task 2: Verify div(curl(A)) = 0 ---\n    \n    # 2.1: Construct edge-centered vector potential A\n    # A_x on x-edges: (Nx, Ny+1, Nz+1)\n    y_on_ax = np.linspace(0, Ly, Ny + 1)\n    z_on_ax = np.linspace(0, Lz, Nz + 1)\n    YY_ax, ZZ_ax = np.meshgrid(y_on_ax, z_on_ax, indexing='ij')\n    Ax_slice = np.sin(2 * np.pi * YY_ax) * np.sin(3 * np.pi * ZZ_ax)\n    Ax = np.tile(Ax_slice[np.newaxis, :, :], (Nx, 1, 1))\n\n    # A_y on y-edges: (Nx+1, Ny, Nz+1)\n    x_on_ay = np.linspace(0, Lx, Nx + 1)\n    z_on_ay = np.linspace(0, Lz, Nz + 1)\n    XX_ay, ZZ_ay = np.meshgrid(x_on_ay, z_on_ay, indexing='ij')\n    Ay_slice = np.sin(2 * np.pi * ZZ_ay) * np.sin(3 * np.pi * XX_ay)\n    Ay = np.tile(Ay_slice[:, np.newaxis, :], (1, Ny, 1))\n\n    # A_z on z-edges: (Nx+1, Ny+1, Nz)\n    x_on_az = np.linspace(0, Lx, Nx + 1)\n    y_on_az = np.linspace(0, Ly, Ny + 1)\n    XX_az, YY_az = np.meshgrid(x_on_az, y_on_az, indexing='ij')\n    Az_slice = np.sin(2 * np.pi * XX_az) * np.sin(3 * np.pi * YY_az)\n    Az = np.tile(Az_slice[:, :, np.newaxis], (1, 1, Nz))\n    \n    # 2.2: Compute curl of A\n    dc_fx, dc_fy, dc_fz = curl(Ax, Ay, Az, hx, hy, hz)\n    \n    # 2.3: Apply boundary closure to the face field\n    if mode == \"dirichlet\" or mode == \"neumann\":\n        # For faces, the problem description for dirichlet and neumann modes is identical\n        # Zero all boundary faces\n        dc_fx[0, :, :] = 0; dc_fx[-1, :, :] = 0  # i=0, i=Nx\n        dc_fy[:, 0, :] = 0; dc_fy[:, -1, :] = 0  # j=0, j=Ny\n        dc_fz[:, :, 0] = 0; dc_fz[:, :, -1] = 0  # k=0, k=Nz\n\n    # 2.4: Compute divergence of the (potentially modified) curl field\n    s = divergence(dc_fx, dc_fy, dc_fz, hx, hy, hz)\n\n    # 2.5: Compute max violation\n    v_divcurl = np.max(np.abs(s))\n\n    return v_curlgrad, v_divcurl\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (16, 12, 8, \"periodic\"),\n        (16, 12, 8, \"dirichlet\"),\n        (16, 12, 8, \"neumann\"),\n        (2, 2, 2, \"periodic\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        v_cg, v_dc = compute_errors(*case)\n        results.append(v_cg)\n        results.append(v_dc)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}