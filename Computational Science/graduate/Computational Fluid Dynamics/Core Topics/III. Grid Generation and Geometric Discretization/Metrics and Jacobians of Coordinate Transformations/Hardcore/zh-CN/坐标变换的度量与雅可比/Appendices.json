{
    "hands_on_practices": [
        {
            "introduction": "本练习将聚焦于坐标变换分析的基本工具——雅可比行列式。通过对一个给定的非线性映射进行直接计算，你将学习如何推导雅可比行列式，更重要的是，学会如何识别其值为零的条件。在计算流体力学中，理解雅可比行列式为零的位置至关重要，因为它对应于计算网格发生折叠或坍缩的奇点，这对此类模拟是致命的 。",
            "id": "3345116",
            "problem": "考虑一个从二维计算域（坐标为 $\\xi$ 和 $\\eta$）到物理域（坐标为 $x$ 和 $y$）的光滑映射，由下式给出\n$$\nx(\\xi,\\eta)=\\xi+\\alpha\\,\\xi\\,\\eta,\\qquad y(\\xi,\\eta)=\\eta+\\beta\\,\\xi^{2},\n$$\n其中 $\\alpha$ 和 $\\beta$ 是实常数。在计算流体动力学的背景下，雅可比矩阵定义为物理坐标相对于计算坐标的所有一阶偏导数组成的矩阵，其行列式是标量雅可比，它决定了映射的局部面积缩放、方向和局部可逆性。\n\n仅使用偏导数和多变量变换的雅可比定义，执行以下操作：\n\n1. 推导雅可比矩阵 $\\partial(x,y)/\\partial(\\xi,\\eta)$，用 $\\xi$、$\\eta$、$\\alpha$ 和 $\\beta$ 明确表示。\n2. 计算雅可比行列式 $J(\\xi,\\eta)$。\n3. 确定 $(\\xi,\\eta)$-平面上使 $J(\\xi,\\eta)=0$ 成立的点的轨迹，并讨论特殊参数情况如何改变该轨迹和映射的局部可逆性。\n\n将雅可比行列式 $J(\\xi,\\eta)$ 作为最终答案，以单一闭合形式的解析表达式报告。不需要也不允许进行数值计算。最终答案中不要包含任何单位。",
            "solution": "该问题要求针对给定的坐标变换，推导其雅可比矩阵和行列式，并分析该变换是奇异的条件。\n\n从计算坐标 $(\\xi, \\eta)$ 到物理坐标 $(x, y)$ 的映射由以下函数给出：\n$$\nx(\\xi, \\eta) = \\xi + \\alpha\\,\\xi\\,\\eta\n$$\n$$\ny(\\xi, \\eta) = \\eta + \\beta\\,\\xi^2\n$$\n其中 $\\alpha$ 和 $\\beta$ 是实常数。\n\n**1. 雅可比矩阵的推导**\n\n该变换的雅可比矩阵，记作 $\\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)}$，是一个 $2 \\times 2$ 矩阵，其元素是物理坐标相对于计算坐标的一阶偏导数：\n$$\n\\mathbf{J} = \\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}\n$$\n我们分别计算每个偏导数。\n\n对于 $x(\\xi, \\eta) = \\xi + \\alpha\\,\\xi\\,\\eta$：\n关于 $\\xi$ 的偏导数是：\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} (\\xi + \\alpha\\,\\xi\\,\\eta) = 1 + \\alpha\\,\\eta\n$$\n关于 $\\eta$ 的偏导数是：\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} (\\xi + \\alpha\\,\\xi\\,\\eta) = \\alpha\\,\\xi\n$$\n\n对于 $y(\\xi, \\eta) = \\eta + \\beta\\,\\xi^2$：\n关于 $\\xi$ 的偏导数是：\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} (\\eta + \\beta\\,\\xi^2) = 2\\,\\beta\\,\\xi\n$$\n关于 $\\eta$ 的偏导数是：\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} (\\eta + \\beta\\,\\xi^2) = 1\n$$\n将这些分量组合成矩阵，我们得到雅可比矩阵：\n$$\n\\mathbf{J}(\\xi, \\eta) = \\begin{pmatrix} 1 + \\alpha\\,\\eta  \\alpha\\,\\xi \\\\ 2\\,\\beta\\,\\xi  1 \\end{pmatrix}\n$$\n\n**2. 雅可比行列式的计算**\n\n雅可比行列式 $J(\\xi,\\eta)$ 是雅可比矩阵 $\\mathbf{J}$ 的行列式。对于一个 $2 \\times 2$ 矩阵 $\\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}$，其行列式为 $ad - bc$。\n将此应用于我们的雅可比矩阵：\n$$\nJ(\\xi, \\eta) = \\det(\\mathbf{J}) = (1 + \\alpha\\,\\eta)(1) - (\\alpha\\,\\xi)(2\\,\\beta\\,\\xi)\n$$\n简化此表达式得到雅可比行列式：\n$$\nJ(\\xi, \\eta) = 1 + \\alpha\\,\\eta - 2\\,\\alpha\\,\\beta\\,\\xi^2\n$$\n\n**3. 奇异点轨迹分析**\n\n在雅可比行列式为零的点，该映射是奇异的，意味着它不是局部可逆的。这些点在计算流体动力学中至关重要，因为它们对应于网格的崩溃，即计算域中的有限面积映射到物理域中的零面积线或点。我们通过设置 $J(\\xi, \\eta) = 0$ 来找到这些奇异点的轨迹：\n$$\n1 + \\alpha\\,\\eta - 2\\,\\alpha\\,\\beta\\,\\xi^2 = 0\n$$\n该方程描述了 $(\\xi, \\eta)$ 平面中的一条曲线。我们研究在常数 $\\alpha$ 和 $\\beta$ 的不同条件下该曲线的性质。\n\n情况1：$\\alpha = 0$。\n如果 $\\alpha = 0$，雅可比行列式变为：\n$$\nJ(\\xi, \\eta) = 1 + (0)\\,\\eta - 2\\,(0)\\,\\beta\\,\\xi^2 = 1\n$$\n由于对于所有的 $(\\xi, \\eta)$，$J(\\xi, \\eta) = 1 \\neq 0$，因此该映射处处非奇异。变换为 $x=\\xi$ 和 $y=\\eta+\\beta\\,\\xi^2$，这是一个简单的剪切和抛物线变换，总是局部可逆的。\n\n情况2：$\\beta = 0$（且 $\\alpha \\neq 0$）。\n如果 $\\beta = 0$，雅可比行列式变为：\n$$\nJ(\\xi, \\eta) = 1 + \\alpha\\,\\eta\n$$\n奇异性条件 $J(\\xi, \\eta) = 0$ 意味着 $1 + \\alpha\\,\\eta = 0$，这给出：\n$$\n\\eta = -\\frac{1}{\\alpha}\n$$\n在这种情况下，奇异点的轨迹是 $(\\xi, \\eta)$ 平面中的一条水平线。除这条线上的点外，该映射处处可逆。\n\n情况3：$\\alpha \\neq 0$ 且 $\\beta \\neq 0$。\n这是一般情况。我们求解关于 $\\eta$ 的奇异性方程：\n$$\n\\alpha\\,\\eta = 2\\,\\alpha\\,\\beta\\,\\xi^2 - 1\n$$\n$$\n\\eta = \\frac{2\\,\\alpha\\,\\beta\\,\\xi^2 - 1}{\\alpha} = 2\\,\\beta\\,\\xi^2 - \\frac{1}{\\alpha}\n$$\n该方程描述了 $(\\xi, \\eta)$ 平面中的一条抛物线，其对称轴沿 $\\eta$ 轴，顶点在点 $(0, -1/\\alpha)$。抛物线的开口方向由 $\\beta$ 的符号决定。如果 $\\beta  0$，抛物线向上开口。如果 $\\beta  0$，它向下开口。除了这条抛物线曲线上的点外，该映射处处局部可逆。任何穿过该抛物线的 $(\\xi, \\eta)$ 计算域中的网格将在 $(x, y)$ 物理域中产生折叠的无效网格。",
            "answer": "$$\n\\boxed{1 + \\alpha\\,\\eta - 2\\,\\alpha\\,\\beta\\,\\xi^{2}}\n$$"
        },
        {
            "introduction": "在探讨了描述面积或体积缩放的标量雅可比行列式之后，我们现在转向度量张量，它能捕捉包括长度和角度在内的完整局部几何信息。本练习将指导你为一个剪切坐标系计算度量张量 ($g_{ij}$) 的分量。这里的关键在于学习如何利用这些分量来确定网格线之间的夹角，从而将度量张量这一抽象概念具体化，并将其与网格的非正交性等质量度量直接联系起来 。",
            "id": "3345156",
            "problem": "在计算流体动力学 (CFD) 中，使用曲线坐标将一个简单的计算域映射到一个可能倾斜的物理域，同时便于在结构化网格上进行离散化。考虑从计算坐标 $(\\xi,\\eta)$ 到物理笛卡尔坐标 $(x,y)$ 的二维映射，定义为 $x=\\xi$ 和 $y=\\eta+\\alpha\\,\\xi$，其中 $\\alpha$ 是一个常数且 $\\alpha\\neq 0$。仅使用矢量微积分和张量微积分的基本原理，计算此映射在计算坐标中导出的度量张量分量 $g_{ij}$，并确定与 $\\xi$ 和 $\\eta$ 相关的协变基矢量之间的夹角。以弧度为单位提供该角度。\n\n将您的最终答案表示为一个单行矩阵，其中包含按顺序排列的四个条目 $\\left[g_{\\xi\\xi},\\,g_{\\xi\\eta},\\,g_{\\eta\\eta},\\,\\theta\\right]$，其中 $\\theta$ 是协变基矢量之间的夹角。无需四舍五入，最终表达式中不应包含单位（角度必须以弧度为单位）。",
            "solution": "该问题要求对于一个给定的从计算域 $(\\xi, \\eta)$ 到物理笛卡尔域 $(x, y)$ 的二维坐标变换，计算度量张量分量 $g_{ij}$ 和协变基矢量之间的夹角 $\\theta$。\n\n该变换由以下方程定义：\n$$x = \\xi$$\n$$y = \\eta + \\alpha\\xi$$\n其中 $\\alpha$ 是一个非零常数。\n\n物理域中一点的位置矢量 $\\mathbf{r}$ 可以用标准笛卡尔基矢量 $\\mathbf{i}$ 和 $\\mathbf{j}$ 表示为 $\\mathbf{r} = x\\mathbf{i} + y\\mathbf{j}$。代入变换方程，我们将位置矢量表示为计算坐标 $(\\xi, \\eta)$ 的函数：\n$$\\mathbf{r}(\\xi, \\eta) = \\xi\\mathbf{i} + (\\eta + \\alpha\\xi)\\mathbf{j}$$\n\n协变基矢量，我们记为 $\\mathbf{g}_{\\xi}$ 和 $\\mathbf{g}_{\\eta}$，定义为位置矢量相对于计算坐标的偏导数。这些矢量在物理空间中与坐标线相切。\n\n与 $\\xi$ 坐标相关的协变基矢量为：\n$$\\mathbf{g}_{\\xi} = \\frac{\\partial \\mathbf{r}}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left( \\xi\\mathbf{i} + (\\eta + \\alpha\\xi)\\mathbf{j} \\right) = \\frac{\\partial x}{\\partial \\xi}\\mathbf{i} + \\frac{\\partial y}{\\partial \\xi}\\mathbf{j}$$\n计算偏导数：\n$$\\frac{\\partial x}{\\partial \\xi} = 1$$\n$$\\frac{\\partial y}{\\partial \\xi} = \\alpha$$\n因此，矢量 $\\mathbf{g}_{\\xi}$ 为：\n$$\\mathbf{g}_{\\xi} = 1\\mathbf{i} + \\alpha\\mathbf{j}$$\n\n与 $\\eta$ 坐标相关的协变基矢量为：\n$$\\mathbf{g}_{\\eta} = \\frac{\\partial \\mathbf{r}}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left( \\xi\\mathbf{i} + (\\eta + \\alpha\\xi)\\mathbf{j} \\right) = \\frac{\\partial x}{\\partial \\eta}\\mathbf{i} + \\frac{\\partial y}{\\partial \\eta}\\mathbf{j}$$\n计算偏导数：\n$$\\frac{\\partial x}{\\partial \\eta} = 0$$\n$$\\frac{\\partial y}{\\partial \\eta} = 1$$\n因此，矢量 $\\mathbf{g}_{\\eta}$ 为：\n$$\\mathbf{g}_{\\eta} = 0\\mathbf{i} + 1\\mathbf{j} = \\mathbf{j}$$\n\n协变度量张量的分量 $g_{ij}$ 定义为协变基矢量的标量（点）积：$g_{ij} = \\mathbf{g}_{i} \\cdot \\mathbf{g}_{j}$。在我们的例子中，索引 $i$ 和 $j$ 对应于 $\\xi$ 和 $\\eta$。\n\n分量 $g_{\\xi\\xi}$ 是：\n$$g_{\\xi\\xi} = \\mathbf{g}_{\\xi} \\cdot \\mathbf{g}_{\\xi} = (1\\mathbf{i} + \\alpha\\mathbf{j}) \\cdot (1\\mathbf{i} + \\alpha\\mathbf{j}) = (1)(1) + (\\alpha)(\\alpha) = 1 + \\alpha^{2}$$\n\n分量 $g_{\\eta\\eta}$ 是：\n$$g_{\\eta\\eta} = \\mathbf{g}_{\\eta} \\cdot \\mathbf{g}_{\\eta} = (\\mathbf{j}) \\cdot (\\mathbf{j}) = 1$$\n\n非对角分量 $g_{\\xi\\eta}$ 是：\n$$g_{\\xi\\eta} = \\mathbf{g}_{\\xi} \\cdot \\mathbf{g}_{\\eta} = (1\\mathbf{i} + \\alpha\\mathbf{j}) \\cdot (\\mathbf{j}) = (1)(0) + (\\alpha)(1) = \\alpha$$\n由于度量张量的对称性，$g_{\\eta\\xi} = g_{\\xi\\eta} = \\alpha$。\n\n两个协变基矢量 $\\mathbf{g}_{\\xi}$ 和 $\\mathbf{g}_{\\eta}$ 之间的夹角 $\\theta$ 由点积的几何定义确定：\n$$\\mathbf{g}_{\\xi} \\cdot \\mathbf{g}_{\\eta} = |\\mathbf{g}_{\\xi}| |\\mathbf{g}_{\\eta}| \\cos(\\theta)$$\n其中 $|\\mathbf{v}|$ 表示矢量 $\\mathbf{v}$ 的模。\n\n基矢量的模与度量张量的对角分量有关：\n$$|\\mathbf{g}_{\\xi}| = \\sqrt{\\mathbf{g}_{\\xi} \\cdot \\mathbf{g}_{\\xi}} = \\sqrt{g_{\\xi\\xi}} = \\sqrt{1 + \\alpha^{2}}$$\n$$|\\mathbf{g}_{\\eta}| = \\sqrt{\\mathbf{g}_{\\eta} \\cdot \\mathbf{g}_{\\eta}} = \\sqrt{g_{\\eta\\eta}} = \\sqrt{1} = 1$$\n点积是度量张量的非对角分量：\n$$\\mathbf{g}_{\\xi} \\cdot \\mathbf{g}_{\\eta} = g_{\\xi\\eta} = \\alpha$$\n\n将这些表达式代入角度公式可得：\n$$\\alpha = \\left( \\sqrt{1 + \\alpha^{2}} \\right) (1) \\cos(\\theta)$$\n求解 $\\cos(\\theta)$：\n$$\\cos(\\theta) = \\frac{\\alpha}{\\sqrt{1 + \\alpha^{2}}}$$\n因此，以弧度表示的角度 $\\theta$ 是：\n$$\\theta = \\arccos\\left(\\frac{\\alpha}{\\sqrt{1 + \\alpha^{2}}}\\right)$$\n条件 $\\alpha \\neq 0$ 确保了 $\\arccos$ 函数的参数不等于 $0$，且基矢量不是正交的。对于任何非零的 $\\alpha$，该参数的绝对值始终小于 $1$，因此角度是良定义的，且不等于 $\\frac{\\pi}{2}$。\n\n最终要求的输出是一个包含度量张量分量和角度 $\\theta$ 的行矩阵：$[g_{\\xi\\xi}, g_{\\xi\\eta}, g_{\\eta\\eta}, \\theta]$。\n整理计算出的量：\n$$g_{\\xi\\xi} = 1 + \\alpha^{2}$$\n$$g_{\\xi\\eta} = \\alpha$$\n$$g_{\\eta\\eta} = 1$$\n$$\\theta = \\arccos\\left(\\frac{\\alpha}{\\sqrt{1 + \\alpha^{2}}}\\right)$$\n这就得到了最终的矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 + \\alpha^2  \\alpha  1  \\arccos\\left(\\frac{\\alpha}{\\sqrt{1 + \\alpha^2}}\\right)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "本练习旨在连接解析理论与计算实践，这是任何CFD从业者都必须迈出的关键一步。你将编写一个程序来执行CFD前处理中的一项常见任务：检验网格质量。通过在标准的等参单元背景下应用雅可比行列式的概念，你将学习如何通过编程来自动检测扭曲或退化的网格单元，从而将前面练习中获得的解析性见解转化为一个实用的自动化工具 。",
            "id": "3345162",
            "problem": "您的任务是实现一个完整的、可运行的程序，用于在计算流体动力学（CFD）中分析等参映射的雅可比矩阵行列式。对于给定的一组扭曲单元的节点位置，该程序必须计算从标准参考单元到物理单元的变换的雅可比矩阵行列式 $J$，评估单元上 $J$ 的符号，并检测单元是否反转。\n\n基本原理：\n- 在计算流体动力学（CFD）的有限元法（FEM）和有限体积法（FVM）中，等参单元将二维（对于四边形）的参考坐标系 $(\\xi,\\eta)$ 或三维（对于六面体）的 $(\\xi,\\eta,\\zeta)$ 映射到物理坐标 $(x,y)$ 或 $(x,y,z)$，其所用的形函数与插值场变量的形函数相同。\n- 雅可比矩阵是从参考坐标到物理坐标映射的一阶偏导数矩阵，其行列式 $J$ 表示局部面积（二维中）或体积（三维中）的缩放以及方向。负行列式表示局部方向反转，即单元反转。零行列式表示局部几何退化。\n\n您的程序必须对测试套件中的每个单元执行以下操作：\n1.  对于二维四边形情况，使用标准的双线性形函数进行等参映射；对于三维六面体情况，使用标准的三线性形函数。根据形函数相对于参考坐标的导数和提供的物理节点坐标，推导出雅可比矩阵的各项。\n2.  在参考域内均匀采样：\n   - 对于二维单元，在 $\\xi$ 和 $\\eta$ 方向上，均在区间 $[-1,1]$ 内采样 $n$ 个点，包括端点。使用 $n=9$。\n   - 对于三维单元，在 $\\xi$、$\\eta$ 和 $\\zeta$ 方向上，均在区间 $[-1,1]$ 内采样 $n$ 个点，包括端点。使用 $n=9$。\n3.  在每个采样点，计算雅可比矩阵及其行列式 $J$。对每个单元的所有采样点，计算：\n   - 最小行列式值 $J_{\\min}$。\n   - 最大行列式值 $J_{\\max}$。\n   - 使用容差 $\\varepsilon = 10^{-12}$ 的符号分类码 $s$：\n     - $s=1$：如果所有行列式都满足 $J  \\varepsilon$（处处严格为正方向）。\n     - $s=-1$：如果所有行列式都满足 $J  -\\varepsilon$（处处严格为负方向）。\n     - $s=0$：如果至少有一个行列式满足 $|J| \\le \\varepsilon$，并且没有严格相反符号的行列式（某处退化但无符号变化）。\n     - $s=2$：如果同时存在正负两种符号的行列式，或者混合了零值以及正负值（混合方向）。\n   - 反转标志 $b$ 定义为：如果任何行列式满足 $J  -\\varepsilon$，则 $b=\\text{True}$；否则 $b=\\text{False}$。\n4.  此问题不涉及物理单位；所有坐标都是无量纲的。\n\n测试套件：\n- 二维双线性四边形单元（节点顺序对应于参考角点 $(\\xi,\\eta)=(-1,-1),(1,-1),(1,1),(-1,1)$）：\n  1.  凸的、轻度扭曲的四边形：\n     - 节点：$[(0.0,\\,0.0),\\,(1.2,\\,0.1),\\,(1.1,\\,1.0),\\,(-0.1,\\,0.9)]$。\n  2.  自相交的“领结形”四边形（预计某处会发生反转）：\n     - 节点：$[(0.0,\\,0.0),\\,(1.0,\\,0.0),\\,(0.0,\\,1.0),\\,(1.0,\\,1.0)]$。\n  3.  面积非常小的近退化四边形：\n     - 节点：$[(0.0,\\,0.0),\\,(10^{-6},\\,0.0),\\,(10^{-6},\\,10^{-6}),\\,(0.0,\\,10^{-6})]$。\n- 三维三线性六面体单元（节点顺序对应于参考角点 $(\\xi,\\eta,\\zeta)=(-1,-1,-1),(1,-1,-1),(1,1,-1),(-1,1,-1),(-1,-1,1),(1,-1,1),(1,1,1),(-1,1,1)$）：\n  4.  凸的、中度扭曲的六面体：\n     - 节点：$[(0.0,\\,0.0,\\,0.0),\\,(1.1,\\,0.0,\\,0.0),\\,(1.1,\\,1.0,\\,0.1),\\,(0.0,\\,1.1,\\,0.0),\\,(0.0,\\,0.0,\\,1.0),\\,(1.0,\\,0.0,\\,1.0),\\,(1.0,\\,1.0,\\,1.1),\\,(0.0,\\,1.0,\\,1.0)]$。\n  5.  顶面低于底面的反转六面体（预计为负方向）：\n     - 节点：$[(0.0,\\,0.0,\\,0.0),\\,(1.0,\\,0.0,\\,0.0),\\,(1.0,\\,1.0,\\,0.0),\\,(0.0,\\,1.0,\\,0.0),\\,(0.0,\\,0.0,\\,-1.0),\\,(1.0,\\,0.0,\\,-1.0),\\,(1.0,\\,1.0,\\,-1.0),\\,(0.0,\\,1.0,\\,-1.0)]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每个测试用例，按顺序附加四个值 $[J_{\\min}, J_{\\max}, s, b]$。整个输出必须是一个由数字和布尔值组成的扁平列表。例如，输出应类似于 $[J_{\\min}^{(1)},J_{\\max}^{(1)},s^{(1)},b^{(1)},J_{\\min}^{(2)},J_{\\max}^{(2)},s^{(2)},b^{(2)},\\ldots]$。",
            "solution": "该问题要求实现一个计算工具，用于分析等参单元的几何有效性，这是计算流体动力学中有限元和有限体积方法的一个基石。分析的核心是雅可比矩阵的行列式 $J$，它提供了局部体积扭曲和方向的度量。正行列式表示从参考单元到物理单元的局部方向得以保持，负行列式表示反转（一个“缠结”或“内外翻转”的单元），而零行列式表示几何退化，即单元局部塌陷到更低的维度（例如，四边形退化为一条线）。\n\n解决方案首先为二维四边形和三维六面体单元定义了等参映射和雅可比矩阵的数学框架。然后，概述了一个数值程序，通过在单元域内采样雅可比行列式来对其几何质量进行分类。\n\n**等参映射**\n\n该方法的核心是等参映射，它将一个简单、标准化的参考单元（如正方形或立方体）中点的坐标与复杂、扭曲的物理单元中点的坐标关联起来。该映射使用形函数 $N_i$ 定义，这些函数也用于在单元上插值物理量。\n\n对于参考坐标为 $\\boldsymbol{\\xi}$ 的点，其物理坐标 $\\mathbf{x}$ 由下式给出：\n$$\n\\mathbf{x}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{N_{\\text{nodes}}} N_i(\\boldsymbol{\\xi}) \\mathbf{x}_i\n$$\n其中 $N_{\\text{nodes}}$ 是单元的节点数，$\\mathbf{x}_i$ 是第 $i$ 个节点的物理坐标。\n\n对于一个二维双线性四边形单元（$N_{\\text{nodes}}=4$），参考坐标为 $\\boldsymbol{\\xi} = (\\xi, \\eta)$，其中 $\\xi, \\eta \\in [-1, 1]$。分别对应于参考角点 $(-1,-1)$、$(1,-1)$、$(1,1)$ 和 $(-1,1)$ 处的四个形函数是：\n$$\n\\begin{aligned}\nN_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta) \\\\\nN_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta) \\\\\nN_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) \\\\\nN_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n\\end{aligned}\n$$\n\n对于一个三维三线性六面体单元（$N_{\\text{nodes}}=8$），参考坐标为 $\\boldsymbol{\\xi} = (\\xi, \\eta, \\zeta)$，其中 $\\xi, \\eta, \\zeta \\in [-1, 1]$。对于参考坐标为 $(\\xi_i, \\eta_i, \\zeta_i)$ 的节点 $i$，其八个形函数定义为：\n$$\nN_i(\\xi, \\eta, \\zeta) = \\frac{1}{8}(1 + \\xi\\xi_i)(1 + \\eta\\eta_i)(1 + \\zeta\\zeta_i)\n$$\n\n**雅可比矩阵及其行列式**\n\n雅可比矩阵 $\\mathbf{J}$ 包含了物理坐标相对于参考坐标的一阶偏导数。对于一个 $D$ 维映射，其分量为：\n$$\nJ_{kl} = \\frac{\\partial x_k}{\\partial \\xi_l}\n$$\n其中 $x_k$ 是第 $k$ 个物理坐标，$\\xi_l$ 是第 $l$ 个参考坐标。使用等参映射公式，每个条目计算如下：\n$$\nJ_{kl} = \\frac{\\partial}{\\partial \\xi_l} \\left( \\sum_{i=1}^{N_{\\text{nodes}}} N_i(\\boldsymbol{\\xi}) x_{ik} \\right) = \\sum_{i=1}^{N_{\\text{nodes}}} \\frac{\\partial N_i(\\boldsymbol{\\xi})}{\\partial \\xi_l} x_{ik}\n$$\n其中 $x_{ik}$ 是第 $i$ 个节点的第 $k$ 个坐标。\n\n这种关系可以简洁地用矩阵形式表示。设 $\\mathbf{X}$ 是节点坐标的 $N_{\\text{nodes}} \\times D$ 矩阵，$\\mathbf{G}(\\boldsymbol{\\xi})$ 是在点 $\\boldsymbol{\\xi}$ 处形函数导数的 $N_{\\text{nodes}} \\times D$ 矩阵，其中 $G_{il} = \\frac{\\partial N_i}{\\partial \\xi_l}$。则 $D \\times D$ 的雅可比矩阵由下式给出：\n$$\n\\mathbf{J} = \\mathbf{G}^T \\mathbf{X}\n$$\n\n对于二维情况（$D=2$），$\\mathbf{G}$ 是一个 $4 \\times 2$ 矩阵，包含四个形函数对 $\\xi$ 和 $\\eta$ 的导数。对于三维情况（$D=3$），$\\mathbf{G}$ 是一个 $8 \\times 3$ 矩阵，包含对 $\\xi$、$\\eta$ 和 $\\zeta$ 的导数。该矩阵的行列式 $J = \\det(\\mathbf{J})$ 是我们关心的量。\n\n二维形函数的导数是：\n$$\n\\begin{aligned}\n\\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_1}{\\partial \\eta} = -\\frac{1}{4}(1-\\xi) \\\\\n\\frac{\\partial N_2}{\\partial \\xi} = \\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_2}{\\partial \\eta} = -\\frac{1}{4}(1+\\xi) \\\\\n\\frac{\\partial N_3}{\\partial \\xi} = \\frac{1}{4}(1+\\eta), \\quad \\frac{\\partial N_3}{\\partial \\eta} = \\frac{1}{4}(1+\\xi) \\\\\n\\frac{\\partial N_4}{\\partial \\xi} = -\\frac{1}{4}(1+\\eta), \\quad \\frac{\\partial N_4}{\\partial \\eta} = \\frac{1}{4}(1-\\xi)\n\\end{aligned}\n$$\n三维形函数的导数可以类似地推导出来，例如：\n$$\n\\frac{\\partial N_i}{\\partial \\xi} = \\frac{\\xi_i}{8}(1 + \\eta\\eta_i)(1 + \\zeta\\zeta_i)\n$$\n\n**计算过程与分类**\n\n为了评估一个单元的质量，我们不能只检查中心的行列式。扭曲的单元可能在某些区域有有效的映射，但在其他区域则发生反转。因此，需要对参考域 $[-1, 1]^D$ 进行均匀采样。问题指定了在每个方向上使用 $n=9$ 个点的网格。\n\n对于测试套件中定义的每个单元，执行以下算法：\n1.  根据提供的节点坐标确定单元维度（$D=2$ 或 $D=3$）。\n2.  在参考域 $[-1, 1]^D$ 中生成一个包含 $n^D$ 个采样点的网格。\n3.  对于每个采样点 $\\boldsymbol{\\xi}_k$：\n    a.  计算形函数导数矩阵 $\\mathbf{G}(\\boldsymbol{\\xi}_k)$。\n    b.  构建雅可比矩阵 $\\mathbf{J} = \\mathbf{G}^T \\mathbf{X}$。\n    c.  计算行列式 $J_k = \\det(\\mathbf{J})$。\n4.  收集所有计算出的行列式 $\\{J_k\\}$。\n5.  从这组行列式中，计算所需的度量：\n    -   $J_{\\min} = \\min(\\{J_k\\})$。\n    -   $J_{\\max} = \\max(\\{J_k\\})$。\n    -   如果任何 $J_k  -\\varepsilon$，则反转标志 $b$ 设置为 $\\text{True}$，否则为 $\\text{False}$。容差为 $\\varepsilon = 10^{-12}$。\n    -   符号分类码 $s$ 根据 $\\{J_k\\}$ 中符号的分布来确定：\n        -   $s=2$：如果同时存在正符号和负符号的行列式（超出 $\\pm\\varepsilon$）。\n        -   $s=1$：如果所有行列式都严格为正（$J_k  \\varepsilon$）。\n        -   $s=-1$：如果所有行列式都严格为负（$J_k  -\\varepsilon$）。\n        -   $s=0$：适用于所有其他情况，包括单元中存在接近零的行列式（$|J_k| \\le \\varepsilon$）但没有严格正值和严格负值混合的情况。\n\n此过程应用于每个测试用例，并将得到的四个值（$J_{\\min}, J_{\\max}, s, b$）汇总以形成最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef get_shape_func_derivs_2d(xi, eta):\n    \"\"\"\n    Computes the derivatives of the 2D bilinear shape functions for a Q4 element.\n    The order corresponds to nodes at (-1,-1), (1,-1), (1,1), (-1,1).\n\n    Args:\n        xi (float): Reference coordinate xi.\n        eta (float): Reference coordinate eta.\n\n    Returns:\n        numpy.ndarray: A (4, 2) array where column 0 is dN/dxi and column 1 is dN/deta.\n    \"\"\"\n    dN_dxi = 0.25 * np.array([-(1.0 - eta), (1.0 - eta), (1.0 + eta), -(1.0 + eta)])\n    dN_deta = 0.25 * np.array([-(1.0 - xi), -(1.0 + xi), (1.0 + xi), (1.0 - xi)])\n    return np.vstack([dN_dxi, dN_deta]).T\n\ndef get_shape_func_derivs_3d(xi, eta, zeta):\n    \"\"\"\n    Computes the derivatives of the 3D trilinear shape functions for an H8 element.\n    Node order is per the problem statement.\n\n    Args:\n        xi (float): Reference coordinate xi.\n        eta (float): Reference coordinate eta.\n        zeta (float): Reference coordinate zeta.\n\n    Returns:\n        numpy.ndarray: An (8, 3) array of shape function derivatives w.r.t. xi, eta, zeta.\n    \"\"\"\n    # Node coordinates in reference space, matching the specified order.\n    node_ref_coords = np.array([\n        [-1, -1, -1], [ 1, -1, -1], [ 1,  1, -1], [-1,  1, -1],\n        [-1, -1,  1], [ 1, -1,  1], [ 1,  1,  1], [-1,  1,  1]\n    ], dtype=float)\n    \n    derivs = np.zeros((8, 3))\n    for i in range(8):\n        xi_i, eta_i, zeta_i = node_ref_coords[i]\n        \n        # dN_i/dxi\n        derivs[i, 0] = 0.125 * xi_i * (1.0 + eta * eta_i) * (1.0 + zeta * zeta_i)\n        # dN_i/deta\n        derivs[i, 1] = 0.125 * eta_i * (1.0 + xi * xi_i) * (1.0 + zeta * zeta_i)\n        # dN_i/dzeta\n        derivs[i, 2] = 0.125 * zeta_i * (1.0 + xi * xi_i) * (1.0 + eta * eta_i)\n        \n    return derivs\n\ndef process_element(nodes, n_samples):\n    \"\"\"\n    Analyzes a single element by sampling the Jacobian determinant.\n\n    Args:\n        nodes (list or np.ndarray): Nodal coordinates of the element.\n        n_samples (int): Number of sample points per direction.\n\n    Returns:\n        list: A list containing [J_min, J_max, s, b].\n    \"\"\"\n    nodes_arr = np.array(nodes, dtype=float)\n    n_nodes, dim = nodes_arr.shape\n    \n    eps = 1e-12\n    \n    if dim == 2:\n        if n_nodes != 4: raise ValueError(\"2D element must have 4 nodes.\")\n        sample_coords = np.linspace(-1.0, 1.0, n_samples)\n        xi_grid, eta_grid = np.meshgrid(sample_coords, sample_coords)\n        ref_points = np.vstack([xi_grid.ravel(), eta_grid.ravel()]).T\n        get_derivs_func = get_shape_func_derivs_2d\n    elif dim == 3:\n        if n_nodes != 8: raise ValueError(\"3D element must have 8 nodes.\")\n        sample_coords = np.linspace(-1.0, 1.0, n_samples)\n        xi_grid, eta_grid, zeta_grid = np.meshgrid(sample_coords, sample_coords, sample_coords)\n        ref_points = np.vstack([xi_grid.ravel(), eta_grid.ravel(), zeta_grid.ravel()]).T\n        get_derivs_func = get_shape_func_derivs_3d\n    else:\n        raise ValueError(f\"Unsupported dimension: {dim}\")\n        \n    determinants = []\n    \n    for point in ref_points:\n        # G matrix: Shape function derivatives w.r.t. reference coords\n        G_matrix = get_derivs_func(*point)\n        # Jacobian matrix J = G^T * X\n        jacobian_matrix = G_matrix.T @ nodes_arr\n        det_J = np.linalg.det(jacobian_matrix)\n        determinants.append(det_J)\n        \n    J_values = np.array(determinants)\n    J_min = np.min(J_values)\n    J_max = np.max(J_values)\n    \n    # Perform classification\n    has_pos = np.any(J_values > eps)\n    has_neg = np.any(J_values  -eps)\n    has_zero = np.any(np.abs(J_values) = eps)\n    \n    b = has_neg\n    \n    if has_pos and has_neg:\n        s = 2\n    elif not has_neg and not has_zero:  # All strictly positive\n        s = 1\n    elif not has_pos and not has_zero:  # All strictly negative\n        s = -1\n    else: # Contains zero or near-zero values, but no mix of pos/neg\n        s = 0\n        \n    return [J_min, J_max, s, b]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: 2D Convex, mildly distorted quadrilateral\n        [(0.0, 0.0), (1.2, 0.1), (1.1, 1.0), (-0.1, 0.9)],\n        # Case 2: 2D Self-intersecting \"bow-tie\" quadrilateral\n        [(0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (1.0, 1.0)],\n        # Case 3: 2D Nearly degenerate quadrilateral\n        [(0.0, 0.0), (1e-6, 0.0), (1e-6, 1e-6), (0.0, 1e-6)],\n        # Case 4: 3D Convex, moderately distorted hexahedron\n        [\n            (0.0, 0.0, 0.0), (1.1, 0.0, 0.0), (1.1, 1.0, 0.1), (0.0, 1.1, 0.0),\n            (0.0, 0.0, 1.0), (1.0, 0.0, 1.0), (1.0, 1.0, 1.1), (0.0, 1.0, 1.0)\n        ],\n        # Case 5: 3D Inverted hexahedron\n        [\n            (0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (1.0, 1.0, 0.0), (0.0, 1.0, 0.0),\n            (0.0, 0.0, -1.0), (1.0, 0.0, -1.0), (1.0, 1.0, -1.0), (0.0, 1.0, -1.0)\n        ],\n    ]\n\n    n_samples = 9\n    results = []\n    for nodes in test_cases:\n        case_result = process_element(nodes, n_samples)\n        results.extend(case_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}