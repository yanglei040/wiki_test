{
    "hands_on_practices": [
        {
            "introduction": "In computational fluid dynamics, a primary task is to map a simple, structured computational grid onto a complex physical domain. The Jacobian determinant, $J$, is the fundamental metric for this transformation, indicating how area or volume scales locally. This exercise provides essential practice in computing the Jacobian and identifying the locus of points where $J=0$, which correspond to singular points where the grid collapses or folds, rendering a simulation invalid .",
            "id": "3345116",
            "problem": "Consider a smooth mapping from a two-dimensional computational domain with coordinates $\\xi$ and $\\eta$ to a physical domain with coordinates $x$ and $y$ given by\n$$\nx(\\xi,\\eta)=\\xi+\\alpha\\,\\xi\\,\\eta,\\qquad y(\\xi,\\eta)=\\eta+\\beta\\,\\xi^{2},\n$$\nwhere $\\alpha$ and $\\beta$ are real constants. In the context of computational fluid dynamics, the Jacobian matrix is defined as the matrix of all first-order partial derivatives of the physical coordinates with respect to the computational coordinates, and its determinant is the scalar Jacobian that governs local area scaling, orientation, and local invertibility of the mapping.\n\nUsing only the definitions of partial derivatives and the Jacobian of a multivariable transformation, perform the following:\n\n1. Derive the Jacobian matrix $\\partial(x,y)/\\partial(\\xi,\\eta)$ explicitly in terms of $\\xi$, $\\eta$, $\\alpha$, and $\\beta$.\n2. Compute the Jacobian determinant $J(\\xi,\\eta)$.\n3. Identify the locus in the $(\\xi,\\eta)$-plane on which $J(\\xi,\\eta)=0$, and discuss how special parameter cases modify this locus and the mapping’s local invertibility.\n\nReport the Jacobian determinant $J(\\xi,\\eta)$ as your final answer in a single closed-form analytic expression. No numerical evaluation is required or permitted. Do not include any units in your final answer.",
            "solution": "The problem requires the derivation of the Jacobian matrix and its determinant for a given coordinate transformation, and an analysis of the conditions under which the transformation is singular.\n\nThe mapping from the computational coordinates $(\\xi, \\eta)$ to the physical coordinates $(x, y)$ is given by the functions:\n$$\nx(\\xi, \\eta) = \\xi + \\alpha\\,\\xi\\,\\eta\n$$\n$$\ny(\\xi, \\eta) = \\eta + \\beta\\,\\xi^2\n$$\nwhere $\\alpha$ and $\\beta$ are real constants.\n\n**1. Derivation of the Jacobian Matrix**\n\nThe Jacobian matrix of the transformation, denoted as $\\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)}$, is a $2 \\times 2$ matrix whose elements are the first-order partial derivatives of the physical coordinates with respect to the computational coordinates:\n$$\n\\mathbf{J} = \\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}\n$$\nWe compute each partial derivative individually.\n\nFor $x(\\xi, \\eta) = \\xi + \\alpha\\,\\xi\\,\\eta$:\nThe partial derivative with respect to $\\xi$ is:\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} (\\xi + \\alpha\\,\\xi\\,\\eta) = 1 + \\alpha\\,\\eta\n$$\nThe partial derivative with respect to $\\eta$ is:\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} (\\xi + \\alpha\\,\\xi\\,\\eta) = \\alpha\\,\\xi\n$$\n\nFor $y(\\xi, \\eta) = \\eta + \\beta\\,\\xi^2$:\nThe partial derivative with respect to $\\xi$ is:\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} (\\eta + \\beta\\,\\xi^2) = 2\\,\\beta\\,\\xi\n$$\nThe partial derivative with respect to $\\eta$ is:\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} (\\eta + \\beta\\,\\xi^2) = 1\n$$\nAssembling these components into the matrix, we obtain the Jacobian matrix:\n$$\n\\mathbf{J}(\\xi, \\eta) = \\begin{pmatrix} 1 + \\alpha\\,\\eta & \\alpha\\,\\xi \\\\ 2\\,\\beta\\,\\xi & 1 \\end{pmatrix}\n$$\n\n**2. Computation of the Jacobian Determinant**\n\nThe Jacobian determinant, $J(\\xi,\\eta)$, is the determinant of the Jacobian matrix $\\mathbf{J}$. For a $2 \\times 2$ matrix $\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$, the determinant is $ad - bc$.\nApplying this to our Jacobian matrix:\n$$\nJ(\\xi, \\eta) = \\det(\\mathbf{J}) = (1 + \\alpha\\,\\eta)(1) - (\\alpha\\,\\xi)(2\\,\\beta\\,\\xi)\n$$\nSimplifying this expression gives the Jacobian determinant:\n$$\nJ(\\xi, \\eta) = 1 + \\alpha\\,\\eta - 2\\,\\alpha\\,\\beta\\,\\xi^2\n$$\n\n**3. Analysis of the Locus of Singularity**\n\nThe mapping is singular, meaning it is not locally invertible, at points where the Jacobian determinant is zero. Such points are critical in computational fluid dynamics as they correspond to a collapse of the grid, where a finite area in the computational domain maps to a zero-area line or point in the physical domain. We find the locus of these singular points by setting $J(\\xi, \\eta) = 0$:\n$$\n1 + \\alpha\\,\\eta - 2\\,\\alpha\\,\\beta\\,\\xi^2 = 0\n$$\nThis equation describes a curve in the $(\\xi, \\eta)$ plane. We examine the nature of this curve under different conditions for the constants $\\alpha$ and $\\beta$.\n\nCase 1: $\\alpha = 0$.\nIf $\\alpha = 0$, the Jacobian determinant becomes:\n$$\nJ(\\xi, \\eta) = 1 + (0)\\,\\eta - 2\\,(0)\\,\\beta\\,\\xi^2 = 1\n$$\nSince $J(\\xi, \\eta) = 1 \\neq 0$ for all $(\\xi, \\eta)$, the mapping is non-singular everywhere. The transformation is $x=\\xi$ and $y=\\eta+\\beta\\,\\xi^2$, which is a simple shearing and parabolic transformation that is always locally invertible.\n\nCase 2: $\\beta = 0$ (and $\\alpha \\neq 0$).\nIf $\\beta = 0$, the Jacobian determinant becomes:\n$$\nJ(\\xi, \\eta) = 1 + \\alpha\\,\\eta\n$$\nThe singularity condition $J(\\xi, \\eta) = 0$ implies $1 + \\alpha\\,\\eta = 0$, which gives:\n$$\n\\eta = -\\frac{1}{\\alpha}\n$$\nIn this case, the locus of singular points is a horizontal line in the $(\\xi, \\eta)$ plane. The mapping is invertible everywhere except on this line.\n\nCase 3: $\\alpha \\neq 0$ and $\\beta \\neq 0$.\nThis is the general case. We solve the singularity equation for $\\eta$:\n$$\n\\alpha\\,\\eta = 2\\,\\alpha\\,\\beta\\,\\xi^2 - 1\n$$\n$$\n\\eta = \\frac{2\\,\\alpha\\,\\beta\\,\\xi^2 - 1}{\\alpha} = 2\\,\\beta\\,\\xi^2 - \\frac{1}{\\alpha}\n$$\nThis equation describes a parabola in the $(\\xi, \\eta)$ plane with its axis of symmetry along the $\\eta$-axis and its vertex at the point $(0, -1/\\alpha)$. The direction the parabola opens is determined by the sign of $\\beta$. If $\\beta > 0$, the parabola opens upwards. If $\\beta  0$, it opens downwards. The mapping is locally invertible everywhere except for the points on this parabolic curve. Any computational grid in the $(\\xi, \\eta)$ domain that crosses this parabola will produce a folded, invalid grid in the $(x, y)$ physical domain.",
            "answer": "$$\n\\boxed{1 + \\alpha\\,\\eta - 2\\,\\alpha\\,\\beta\\,\\xi^{2}}\n$$"
        },
        {
            "introduction": "While the Jacobian determinant measures local changes in area, the metric tensor, $g_{ij}$, provides a more complete picture of the local geometry, including lengths and angles. Since practical CFD applications often rely on non-orthogonal grids to model complex shapes, understanding grid skewness is vital. This exercise demonstrates how to compute the components of the metric tensor and use them to quantify the degree of non-orthogonality by calculating the angle between the grid's base vectors .",
            "id": "3345156",
            "problem": "In computational fluid dynamics (CFD), curvilinear coordinates are employed to map a simple computational domain to a possibly skewed physical domain while facilitating discretization on structured grids. Consider the two-dimensional mapping from computational coordinates $(\\xi,\\eta)$ to physical Cartesian coordinates $(x,y)$ defined by $x=\\xi$ and $y=\\eta+\\alpha\\,\\xi$, where $\\alpha$ is a constant with $\\alpha\\neq 0$. Using only first principles from vector calculus and tensor calculus, compute the metric tensor components $g_{ij}$ induced by this mapping in the computational coordinates and determine the angle between the covariant base vectors associated with $\\xi$ and $\\eta$. Provide the angle in radians.\n\nExpress your final answer as a single row matrix containing four entries in the order $\\left[g_{\\xi\\xi},\\,g_{\\xi\\eta},\\,g_{\\eta\\eta},\\,\\theta\\right]$, where $\\theta$ is the angle between the covariant base vectors. No rounding is required, and no units should be included in the final expression (the angle must be in radians).",
            "solution": "The problem requires the calculation of the metric tensor components $g_{ij}$ and the angle $\\theta$ between the covariant base vectors for a given two-dimensional coordinate transformation from a computational domain $(\\xi, \\eta)$ to a physical Cartesian domain $(x, y)$.\n\nThe transformation is defined by the equations:\n$$x = \\xi$$\n$$y = \\eta + \\alpha\\xi$$\nwhere $\\alpha$ is a non-zero constant.\n\nThe position vector $\\mathbf{r}$ of a point in the physical domain can be expressed in terms of the standard Cartesian basis vectors $\\mathbf{i}$ and $\\mathbf{j}$ as $\\mathbf{r} = x\\mathbf{i} + y\\mathbf{j}$. Substituting the transformation equations, we express the position vector as a function of the computational coordinates $(\\xi, \\eta)$:\n$$\\mathbf{r}(\\xi, \\eta) = \\xi\\mathbf{i} + (\\eta + \\alpha\\xi)\\mathbf{j}$$\n\nThe covariant base vectors, which we denote as $\\mathbf{g}_{\\xi}$ and $\\mathbf{g}_{\\eta}$, are defined as the partial derivatives of the position vector with respect to the computational coordinates. These vectors are tangent to the coordinate lines in the physical space.\n\nThe covariant base vector associated with the $\\xi$ coordinate is:\n$$\\mathbf{g}_{\\xi} = \\frac{\\partial \\mathbf{r}}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left( \\xi\\mathbf{i} + (\\eta + \\alpha\\xi)\\mathbf{j} \\right) = \\frac{\\partial x}{\\partial \\xi}\\mathbf{i} + \\frac{\\partial y}{\\partial \\xi}\\mathbf{j}$$\nCalculating the partial derivatives:\n$$\\frac{\\partial x}{\\partial \\xi} = 1$$\n$$\\frac{\\partial y}{\\partial \\xi} = \\alpha$$\nThus, the vector $\\mathbf{g}_{\\xi}$ is:\n$$\\mathbf{g}_{\\xi} = 1\\mathbf{i} + \\alpha\\mathbf{j}$$\n\nThe covariant base vector associated with the $\\eta$ coordinate is:\n$$\\mathbf{g}_{\\eta} = \\frac{\\partial \\mathbf{r}}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left( \\xi\\mathbf{i} + (\\eta + \\alpha\\xi)\\mathbf{j} \\right) = \\frac{\\partial x}{\\partial \\eta}\\mathbf{i} + \\frac{\\partial y}{\\partial \\eta}\\mathbf{j}$$\nCalculating the partial derivatives:\n$$\\frac{\\partial x}{\\partial \\eta} = 0$$\n$$\\frac{\\partial y}{\\partial \\eta} = 1$$\nThus, the vector $\\mathbf{g}_{\\eta}$ is:\n$$\\mathbf{g}_{\\eta} = 0\\mathbf{i} + 1\\mathbf{j} = \\mathbf{j}$$\n\nThe components of the covariant metric tensor, $g_{ij}$, are defined as the scalar (dot) product of the covariant base vectors: $g_{ij} = \\mathbf{g}_{i} \\cdot \\mathbf{g}_{j}$. In our case, the indices $i$ and $j$ correspond to $\\xi$ and $\\eta$.\n\nThe component $g_{\\xi\\xi}$ is:\n$$g_{\\xi\\xi} = \\mathbf{g}_{\\xi} \\cdot \\mathbf{g}_{\\xi} = (1\\mathbf{i} + \\alpha\\mathbf{j}) \\cdot (1\\mathbf{i} + \\alpha\\mathbf{j}) = (1)(1) + (\\alpha)(\\alpha) = 1 + \\alpha^{2}$$\n\nThe component $g_{\\eta\\eta}$ is:\n$$g_{\\eta\\eta} = \\mathbf{g}_{\\eta} \\cdot \\mathbf{g}_{\\eta} = (\\mathbf{j}) \\cdot (\\mathbf{j}) = 1$$\n\nThe off-diagonal component $g_{\\xi\\eta}$ is:\n$$g_{\\xi\\eta} = \\mathbf{g}_{\\xi} \\cdot \\mathbf{g}_{\\eta} = (1\\mathbf{i} + \\alpha\\mathbf{j}) \\cdot (\\mathbf{j}) = (1)(0) + (\\alpha)(1) = \\alpha$$\nDue to the symmetry of the metric tensor, $g_{\\eta\\xi} = g_{\\xi\\eta} = \\alpha$.\n\nThe angle $\\theta$ between the two covariant base vectors $\\mathbf{g}_{\\xi}$ and $\\mathbf{g}_{\\eta}$ is determined by the geometric definition of the dot product:\n$$\\mathbf{g}_{\\xi} \\cdot \\mathbf{g}_{\\eta} = |\\mathbf{g}_{\\xi}| |\\mathbf{g}_{\\eta}| \\cos(\\theta)$$\nwhere $|\\mathbf{v}|$ denotes the magnitude of a vector $\\mathbf{v}$.\n\nThe magnitudes of the base vectors are related to the diagonal components of the metric tensor:\n$$|\\mathbf{g}_{\\xi}| = \\sqrt{\\mathbf{g}_{\\xi} \\cdot \\mathbf{g}_{\\xi}} = \\sqrt{g_{\\xi\\xi}} = \\sqrt{1 + \\alpha^{2}}$$\n$$|\\mathbf{g}_{\\eta}| = \\sqrt{\\mathbf{g}_{\\eta} \\cdot \\mathbf{g}_{\\eta}} = \\sqrt{g_{\\eta\\eta}} = \\sqrt{1} = 1$$\nThe dot product is the off-diagonal component of the metric tensor:\n$$\\mathbf{g}_{\\xi} \\cdot \\mathbf{g}_{\\eta} = g_{\\xi\\eta} = \\alpha$$\n\nSubstituting these expressions into the angle formula gives:\n$$\\alpha = \\left( \\sqrt{1 + \\alpha^{2}} \\right) (1) \\cos(\\theta)$$\nSolving for $\\cos(\\theta)$:\n$$\\cos(\\theta) = \\frac{\\alpha}{\\sqrt{1 + \\alpha^{2}}}$$\nThe angle $\\theta$ in radians is therefore:\n$$\\theta = \\arccos\\left(\\frac{\\alpha}{\\sqrt{1 + \\alpha^{2}}}\\right)$$\nThe condition $\\alpha \\neq 0$ ensures that the argument of the $\\arccos$ function is not equal to $0$ and the base vectors are not orthogonal. The magnitude of the argument is always less than $1$ for any non-zero $\\alpha$, so the angle is well-defined and is not $\\frac{\\pi}{2}$.\n\nThe final requested output is a row matrix containing the metric tensor components and the angle $\\theta$: $[g_{\\xi\\xi}, g_{\\xi\\eta}, g_{\\eta\\eta}, \\theta]$.\nAssembling the calculated quantities:\n$$g_{\\xi\\xi} = 1 + \\alpha^{2}$$\n$$g_{\\xi\\eta} = \\alpha$$\n$$g_{\\eta\\eta} = 1$$\n$$\\theta = \\arccos\\left(\\frac{\\alpha}{\\sqrt{1 + \\alpha^{2}}}\\right)$$\nThis results in the final matrix.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 + \\alpha^2  \\alpha  1  \\arccos\\left(\\frac{\\alpha}{\\sqrt{1 + \\alpha^2}}\\right)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Moving from analytical theory to computational practice, this exercise addresses a critical step in any CFD simulation: verifying grid quality. A valid grid must not contain any \"inverted\" or \"tangled\" elements, a condition detected by checking the sign of the Jacobian determinant. This hands-on coding problem guides you through implementing a standard algorithm used in CFD software to assess element validity, applying the concept of the Jacobian determinant in a practical, computational context .",
            "id": "3345162",
            "problem": "You are tasked with implementing a complete, runnable program to analyze the metric determinant of the Jacobian of isoparametric mappings in Computational Fluid Dynamics (CFD). The program must compute, for a given set of distorted element nodal positions, the determinant $J$ of the Jacobian matrix of the transformation from a standard reference element to the physical element, evaluate the sign of $J$ over the element, and detect whether the element is inverted.\n\nFundamental base:\n- In the Finite Element Method (FEM) and Finite Volume Method (FVM) within Computational Fluid Dynamics (CFD), an isoparametric element maps a reference coordinate system $(\\xi,\\eta)$ in two dimensions (for a quadrilateral) or $(\\xi,\\eta,\\zeta)$ in three dimensions (for a hexahedron) to physical coordinates $(x,y)$ or $(x,y,z)$ via the same shape functions used to interpolate field variables.\n- The Jacobian matrix is the matrix of first-order partial derivatives of the mapping from reference to physical coordinates, and its determinant $J$ represents local area (in two dimensions) or volume (in three dimensions) scaling, together with orientation. A negative determinant indicates a local orientation reversal, i.e., an inverted element. A zero determinant indicates a local geometric degeneracy.\n\nYour program must perform the following for each element in the test suite:\n1. Use the isoparametric mapping with standard bilinear shape functions for the two-dimensional quadrilateral case and standard trilinear shape functions for the three-dimensional hexahedral case. Derive the Jacobian matrix entries from the shape function derivatives with respect to the reference coordinates and the provided physical nodal coordinates.\n2. Sample the reference domain uniformly:\n   - For two-dimensional elements, sample $n$ points per direction in the interval $[-1,1]$ for both $\\xi$ and $\\eta$, including endpoints. Use $n=9$.\n   - For three-dimensional elements, sample $n$ points per direction in the interval $[-1,1]$ for $\\xi$, $\\eta$, and $\\zeta$, including endpoints. Use $n=9$.\n3. At each sample point, compute the Jacobian matrix and its determinant $J$. Over all sample points for each element, compute:\n   - The minimum determinant value $J_{\\min}$.\n   - The maximum determinant value $J_{\\max}$.\n   - A sign classification code $s$ using a tolerance $\\varepsilon = 10^{-12}$:\n     - $s=1$ if all determinants satisfy $J  \\varepsilon$ (strictly positive orientation everywhere).\n     - $s=-1$ if all determinants satisfy $J  -\\varepsilon$ (strictly negative orientation everywhere).\n     - $s=0$ if at least one determinant satisfies $|J| \\le \\varepsilon$, and no determinants are strictly of opposite sign (degenerate somewhere without sign change).\n     - $s=2$ if determinants of both signs are present or a mix including zeros that also includes positive and negative values (mixed orientation).\n   - An inversion flag $b$ defined as $b=\\text{True}$ if any determinant satisfies $J  -\\varepsilon$; otherwise $b=\\text{False}$.\n4. There are no physical units associated with this problem; all coordinates are dimensionless.\n\nTest suite:\n- Two-dimensional bilinear quadrilateral elements (node order corresponds to reference corners $(\\xi,\\eta)=(-1,-1),(1,-1),(1,1),(-1,1)$):\n  1. Convex, mildly distorted quadrilateral:\n     - Nodes: $[(0.0,\\,0.0),\\,(1.2,\\,0.1),\\,(1.1,\\,1.0),\\,(-0.1,\\,0.9)]$.\n  2. Self-intersecting “bow-tie” quadrilateral (expected inversion somewhere):\n     - Nodes: $[(0.0,\\,0.0),\\,(1.0,\\,0.0),\\,(0.0,\\,1.0),\\,(1.0,\\,1.0)]$.\n  3. Nearly degenerate quadrilateral with very small area:\n     - Nodes: $[(0.0,\\,0.0),\\,(10^{-6},\\,0.0),\\,(10^{-6},\\,10^{-6}),\\,(0.0,\\,10^{-6})]$.\n- Three-dimensional trilinear hexahedral elements (node order corresponds to reference corners $(\\xi,\\eta,\\zeta)=(-1,-1,-1),(1,-1,-1),(1,1,-1),(-1,1,-1),(-1,-1,1),(1,-1,1),(1,1,1),(-1,1,1)$):\n  4. Convex, moderately distorted hexahedron:\n     - Nodes: $[(0.0,\\,0.0,\\,0.0),\\,(1.1,\\,0.0,\\,0.0),\\,(1.1,\\,1.0,\\,0.1),\\,(0.0,\\,1.1,\\,0.0),\\,(0.0,\\,0.0,\\,1.0),\\,(1.0,\\,0.0,\\,1.0),\\,(1.0,\\,1.0,\\,1.1),\\,(0.0,\\,1.0,\\,1.0)]$.\n  5. Inverted hexahedron with top face below the bottom face (expected negative orientation):\n     - Nodes: $[(0.0,\\,0.0,\\,0.0),\\,(1.0,\\,0.0,\\,0.0),\\,(1.0,\\,1.0,\\,0.0),\\,(0.0,\\,1.0,\\,0.0),\\,(0.0,\\,0.0,\\,-1.0),\\,(1.0,\\,0.0,\\,-1.0),\\,(1.0,\\,1.0,\\,-1.0),\\,(0.0,\\,1.0,\\,-1.0)]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, append the four values $[J_{\\min}, J_{\\max}, s, b]$ in order. The entire output must be a flat list of numbers and booleans. For example, the output should look like $[J_{\\min}^{(1)},J_{\\max}^{(1)},s^{(1)},b^{(1)},J_{\\min}^{(2)},J_{\\max}^{(2)},s^{(2)},b^{(2)},\\ldots]$.",
            "solution": "The problem requires the implementation of a computational tool to analyze the geometric validity of isoparametric elements, a cornerstone of the Finite Element and Finite Volume methods in Computational Fluid Dynamics. The analysis centers on the determinant of the Jacobian matrix, $J$, which provides a measure of local volume distortion and orientation. A positive determinant indicates that the local orientation is preserved from the reference element to the physical element, a negative determinant indicates an inversion (a \"tangled\" or \"inside-out\" element), and a zero determinant signifies a geometric degeneracy where the element has collapsed locally to a lower dimension (e.g., a quadrilateral to a line).\n\nThe solution proceeds by first defining the mathematical framework for isoparametric mapping and the Jacobian matrix for both two-dimensional quadrilateral and three-dimensional hexahedral elements. Then, a numerical procedure is outlined to sample the Jacobian determinant across the element's domain to classify its geometric quality.\n\n**Isoparametric Mapping**\n\nThe core of the method is the isoparametric mapping, which relates the coordinates of a point in a simple, standardized reference element (e.g., a square or cube) to the coordinates of a point in the complex, distorted physical element. The mapping is defined using shape functions, $N_i$, which are also used to interpolate physical quantities over the element.\n\nFor a point with reference coordinates $\\boldsymbol{\\xi}$, the physical coordinates $\\mathbf{x}$ are given by:\n$$\n\\mathbf{x}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{N_{\\text{nodes}}} N_i(\\boldsymbol{\\xi}) \\mathbf{x}_i\n$$\nwhere $N_{\\text{nodes}}$ is the number of nodes of the element and $\\mathbf{x}_i$ are the physical coordinates of the $i$-th node.\n\nFor a two-dimensional bilinear quadrilateral element ($N_{\\text{nodes}}=4$), the reference coordinates are $\\boldsymbol{\\xi} = (\\xi, \\eta)$, where $\\xi, \\eta \\in [-1, 1]$. The four shape functions, corresponding to the nodes at reference corners $(-1,-1)$, $(1,-1)$, $(1,1)$, and $(-1,1)$ respectively, are:\n$$\n\\begin{aligned}\nN_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta) \\\\\nN_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta) \\\\\nN_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) \\\\\nN_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n\\end{aligned}\n$$\n\nFor a three-dimensional trilinear hexahedral element ($N_{\\text{nodes}}=8$), the reference coordinates are $\\boldsymbol{\\xi} = (\\xi, \\eta, \\zeta)$, where $\\xi, \\eta, \\zeta \\in [-1, 1]$. The eight shape functions are defined for a node $i$ with reference coordinates $(\\xi_i, \\eta_i, \\zeta_i)$ as:\n$$\nN_i(\\xi, \\eta, \\zeta) = \\frac{1}{8}(1 + \\xi\\xi_i)(1 + \\eta\\eta_i)(1 + \\zeta\\zeta_i)\n$$\n\n**The Jacobian Matrix and its Determinant**\n\nThe Jacobian matrix, $\\mathbf{J}$, contains the first-order partial derivatives of the physical coordinates with respect to the reference coordinates. For a $D$-dimensional mapping, its components are:\n$$\nJ_{kl} = \\frac{\\partial x_k}{\\partial \\xi_l}\n$$\nwhere $x_k$ is the $k$-th physical coordinate and $\\xi_l$ is the $l$-th reference coordinate. Using the isoparametric mapping formula, each entry is computed as:\n$$\nJ_{kl} = \\frac{\\partial}{\\partial \\xi_l} \\left( \\sum_{i=1}^{N_{\\text{nodes}}} N_i(\\boldsymbol{\\xi}) x_{ik} \\right) = \\sum_{i=1}^{N_{\\text{nodes}}} \\frac{\\partial N_i(\\boldsymbol{\\xi})}{\\partial \\xi_l} x_{ik}\n$$\nwhere $x_{ik}$ is the $k$-th coordinate of the $i$-th node.\n\nThis relationship can be expressed concisely in matrix form. Let $\\mathbf{X}$ be the $N_{\\text{nodes}} \\times D$ matrix of nodal coordinates and $\\mathbf{G}(\\boldsymbol{\\xi})$ be the $N_{\\text{nodes}} \\times D$ matrix of shape function derivatives at a point $\\boldsymbol{\\xi}$, where $G_{il} = \\frac{\\partial N_i}{\\partial \\xi_l}$. The $D \\times D$ Jacobian matrix is then given by:\n$$\n\\mathbf{J} = \\mathbf{G}^T \\mathbf{X}\n$$\n\nFor the 2D case ($D=2$), $\\mathbf{G}$ is a $4 \\times 2$ matrix containing the derivatives of the four shape functions with respect to $\\xi$ and $\\eta$. For the 3D case ($D=3$), $\\mathbf{G}$ is an $8 \\times 3$ matrix of derivatives with respect to $\\xi$, $\\eta$, and $\\zeta$. The determinant of this matrix, $J = \\det(\\mathbf{J})$, is the quantity of interest.\n\nThe derivatives of the 2D shape functions are:\n$$\n\\begin{aligned}\n\\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta),  \\quad \\frac{\\partial N_1}{\\partial \\eta} = -\\frac{1}{4}(1-\\xi) \\\\\n\\frac{\\partial N_2}{\\partial \\xi} = \\frac{1}{4}(1-\\eta),  \\quad \\frac{\\partial N_2}{\\partial \\eta} = -\\frac{1}{4}(1+\\xi) \\\\\n\\frac{\\partial N_3}{\\partial \\xi} = \\frac{1}{4}(1+\\eta),  \\quad \\frac{\\partial N_3}{\\partial \\eta} = \\frac{1}{4}(1+\\xi) \\\\\n\\frac{\\partial N_4}{\\partial \\xi} = -\\frac{1}{4}(1+\\eta),  \\quad \\frac{\\partial N_4}{\\partial \\eta} = \\frac{1}{4}(1-\\xi)\n\\end{aligned}\n$$\nThe derivatives for the 3D shape functions are similarly derived, for instance:\n$$\n\\frac{\\partial N_i}{\\partial \\xi} = \\frac{\\xi_i}{8}(1 + \\eta\\eta_i)(1 + \\zeta\\zeta_i)\n$$\n\n**Computational Procedure and Classification**\n\nTo assess the quality of an element, we cannot just check the determinant at the center. Distorted elements may have valid mappings in some regions but be inverted in others. Therefore, the reference domain $[-1, 1]^D$ is sampled uniformly. The problem specifies a grid of $n=9$ points in each direction.\n\nFor each element defined in the test suite, the following algorithm is executed:\n1.  Identify the element dimension ($D=2$ or $D=3$) from the provided nodal coordinates.\n2.  Generate a grid of $n^D$ sample points in the reference domain $[-1, 1]^D$.\n3.  For each sample point $\\boldsymbol{\\xi}_k$:\n    a.  Calculate the matrix of shape function derivatives, $\\mathbf{G}(\\boldsymbol{\\xi}_k)$.\n    b.  Form the Jacobian matrix $\\mathbf{J} = \\mathbf{G}^T \\mathbf{X}$.\n    c.  Compute the determinant $J_k = \\det(\\mathbf{J})$.\n4.  Collect all computed determinants $\\{J_k\\}$.\n5.  From this set of determinants, compute the required metrics:\n    -   $J_{\\min} = \\min(\\{J_k\\})$.\n    -   $J_{\\max} = \\max(\\{J_k\\})$.\n    -   The inversion flag $b$ is set to $\\text{True}$ if any $J_k  -\\varepsilon$, and $\\text{False}$ otherwise. The tolerance is $\\varepsilon = 10^{-12}$.\n    -   The sign classification code $s$ is determined by the distribution of signs in $\\{J_k\\}$:\n        -   $s=2$ if determinants of both positive and negative sign (beyond $\\pm\\varepsilon$) are present.\n        -   $s=1$ if all determinants are strictly positive ($J_k  \\varepsilon$).\n        -   $s=-1$ if all determinants are strictly negative ($J_k  -\\varepsilon$).\n        -   $s=0$ for all other cases, which includes elements with some determinants close to zero ($|J_k| \\le \\varepsilon$) but without a mix of strictly positive and strictly negative values.\n\nThis procedure is applied to each test case, and the resulting four values ($J_{\\min}, J_{\\max}, s, b$) are aggregated to form the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef get_shape_func_derivs_2d(xi, eta):\n    \"\"\"\n    Computes the derivatives of the 2D bilinear shape functions for a Q4 element.\n    The order corresponds to nodes at (-1,-1), (1,-1), (1,1), (-1,1).\n\n    Args:\n        xi (float): Reference coordinate xi.\n        eta (float): Reference coordinate eta.\n\n    Returns:\n        numpy.ndarray: A (4, 2) array where column 0 is dN/dxi and column 1 is dN/deta.\n    \"\"\"\n    dN_dxi = 0.25 * np.array([-(1.0 - eta), (1.0 - eta), (1.0 + eta), -(1.0 + eta)])\n    dN_deta = 0.25 * np.array([-(1.0 - xi), -(1.0 + xi), (1.0 + xi), (1.0 - xi)])\n    return np.vstack([dN_dxi, dN_deta]).T\n\ndef get_shape_func_derivs_3d(xi, eta, zeta):\n    \"\"\"\n    Computes the derivatives of the 3D trilinear shape functions for an H8 element.\n    Node order is per the problem statement.\n\n    Args:\n        xi (float): Reference coordinate xi.\n        eta (float): Reference coordinate eta.\n        zeta (float): Reference coordinate zeta.\n\n    Returns:\n        numpy.ndarray: An (8, 3) array of shape function derivatives w.r.t. xi, eta, zeta.\n    \"\"\"\n    # Node coordinates in reference space, matching the specified order.\n    node_ref_coords = np.array([\n        [-1, -1, -1], [ 1, -1, -1], [ 1,  1, -1], [-1,  1, -1],\n        [-1, -1,  1], [ 1, -1,  1], [ 1,  1,  1], [-1,  1,  1]\n    ], dtype=float)\n    \n    derivs = np.zeros((8, 3))\n    for i in range(8):\n        xi_i, eta_i, zeta_i = node_ref_coords[i]\n        \n        # dN_i/dxi\n        derivs[i, 0] = 0.125 * xi_i * (1.0 + eta * eta_i) * (1.0 + zeta * zeta_i)\n        # dN_i/deta\n        derivs[i, 1] = 0.125 * eta_i * (1.0 + xi * xi_i) * (1.0 + zeta * zeta_i)\n        # dN_i/dzeta\n        derivs[i, 2] = 0.125 * zeta_i * (1.0 + xi * xi_i) * (1.0 + eta * eta_i)\n        \n    return derivs\n\ndef process_element(nodes, n_samples):\n    \"\"\"\n    Analyzes a single element by sampling the Jacobian determinant.\n\n    Args:\n        nodes (list or np.ndarray): Nodal coordinates of the element.\n        n_samples (int): Number of sample points per direction.\n\n    Returns:\n        list: A list containing [J_min, J_max, s, b].\n    \"\"\"\n    nodes_arr = np.array(nodes, dtype=float)\n    n_nodes, dim = nodes_arr.shape\n    \n    eps = 1e-12\n    \n    if dim == 2:\n        if n_nodes != 4: raise ValueError(\"2D element must have 4 nodes.\")\n        sample_coords = np.linspace(-1.0, 1.0, n_samples)\n        xi_grid, eta_grid = np.meshgrid(sample_coords, sample_coords)\n        ref_points = np.vstack([xi_grid.ravel(), eta_grid.ravel()]).T\n        get_derivs_func = get_shape_func_derivs_2d\n    elif dim == 3:\n        if n_nodes != 8: raise ValueError(\"3D element must have 8 nodes.\")\n        sample_coords = np.linspace(-1.0, 1.0, n_samples)\n        xi_grid, eta_grid, zeta_grid = np.meshgrid(sample_coords, sample_coords, sample_coords)\n        ref_points = np.vstack([xi_grid.ravel(), eta_grid.ravel(), zeta_grid.ravel()]).T\n        get_derivs_func = get_shape_func_derivs_3d\n    else:\n        raise ValueError(f\"Unsupported dimension: {dim}\")\n        \n    determinants = []\n    \n    for point in ref_points:\n        # G matrix: Shape function derivatives w.r.t. reference coords\n        G_matrix = get_derivs_func(*point)\n        # Jacobian matrix J = G^T * X\n        jacobian_matrix = G_matrix.T @ nodes_arr\n        det_J = np.linalg.det(jacobian_matrix)\n        determinants.append(det_J)\n        \n    J_values = np.array(determinants)\n    J_min = np.min(J_values)\n    J_max = np.max(J_values)\n    \n    # Perform classification\n    has_pos = np.any(J_values  eps)\n    has_neg = np.any(J_values  -eps)\n    has_zero = np.any(np.abs(J_values) = eps)\n    \n    b = has_neg\n    \n    if has_pos and has_neg:\n        s = 2\n    elif not has_neg and not has_zero:  # All strictly positive\n        s = 1\n    elif not has_pos and not has_zero:  # All strictly negative\n        s = -1\n    else: # Contains zero or near-zero values, but no mix of pos/neg\n        s = 0\n        \n    return [J_min, J_max, s, b]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: 2D Convex, mildly distorted quadrilateral\n        [(0.0, 0.0), (1.2, 0.1), (1.1, 1.0), (-0.1, 0.9)],\n        # Case 2: 2D Self-intersecting \"bow-tie\" quadrilateral\n        [(0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (1.0, 1.0)],\n        # Case 3: 2D Nearly degenerate quadrilateral\n        [(0.0, 0.0), (1e-6, 0.0), (1e-6, 1e-6), (0.0, 1e-6)],\n        # Case 4: 3D Convex, moderately distorted hexahedron\n        [\n            (0.0, 0.0, 0.0), (1.1, 0.0, 0.0), (1.1, 1.0, 0.1), (0.0, 1.1, 0.0),\n            (0.0, 0.0, 1.0), (1.0, 0.0, 1.0), (1.0, 1.0, 1.1), (0.0, 1.0, 1.0)\n        ],\n        # Case 5: 3D Inverted hexahedron\n        [\n            (0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (1.0, 1.0, 0.0), (0.0, 1.0, 0.0),\n            (0.0, 0.0, -1.0), (1.0, 0.0, -1.0), (1.0, 1.0, -1.0), (0.0, 1.0, -1.0)\n        ],\n    ]\n\n    n_samples = 9\n    results = []\n    for nodes in test_cases:\n        case_result = process_element(nodes, n_samples)\n        results.extend(case_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}