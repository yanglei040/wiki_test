{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的数据结构之前，理解和应用像欧拉-庞加莱公式这样的基本拓扑不变量是至关重要的。这个练习将帮助你通过一个经典的“纸笔”问题，验证二维非结构化网格的拓扑完整性，例如检查其是否包含意料之外的“孔洞”。通过从第一性原理推导并应用该公式，你将加深对网格基本元素（顶点、边、面）之间关系的理解 。",
            "id": "3303802",
            "problem": "一个计算流体动力学（CFD）求解器使用非结构化二维三角形网格来离散化一个有界平面域。该求解器通过每个单元的顶点索引列表和一份单独的边界边列表来存储连接关系。考虑一个可能包含内部孔洞的平面域的网格。该网格恰好有 $F = 100$ 个三角形单元（仅计算覆盖该域的有界三角形，不包括无界的外部区域），$V = 68$ 个不同的顶点，并且边界边列表包含 $B = 40$ 条不同的边。网格中没有悬挂节点，且每条边界边都恰好属于一个三角形。\n\n请仅从二维单元复形的基本定义、作为0维-1维-2维单元交错计数的欧拉示性数、欧拉示性数在同胚变换下的拓扑不变性以及三角剖分中边与面关联度的双重计数原理出发，推导出一个将网格实体交错计数与边界分量数量联系起来的拓扑不变量。使用这个不变量来计算网格化区域的内部孔洞数 $h$，约定每个孔洞在外部边界之外贡献一个额外的边界分量。\n\n请将 $h$ 的值作为一个单独的数字作为最终答案。无需四舍五入，不涉及单位。假设采用标准平面拓扑，并且所有网格实体均按所述正确计数。",
            "solution": "该问题要求推导一个拓扑不变量，用以关联网格实体（顶点、边、面）的数量与平面域中孔洞的数量，然后利用这个不变量和给定的网格数据计算孔洞的数量。\n\n推导始于欧拉示性数 $\\chi$ 的概念，这是一个基本的拓扑不变量。对于任何将一个闭合、可定向的二维流形（无边界的曲面）分解为 $V$ 个顶点、$E$ 条边和 $F$ 个面的多面体分解（例如三角剖分），欧拉示性数由以下交错和给出：\n$$ \\chi = V - E + F $$\n最简单的此类曲面是球面 $S^2$，其欧拉示性数为 $\\chi(S^2) = 2$。这可以通过一个简单的多面体（如四面体）来验证，其中 $V=4$，$E=6$，$F=4$，得出 $V-E+F=4-6+4=2$。\n\n问题中描述的网格化区域是一个有界的平面区域，可能包含内部孔洞。在拓扑上，这样的区域与一个移除了若干个不相交开圆盘的球面是同胚的。每个被移除的圆盘都会形成一个边界分量。设边界分量的总数为 $k$。根据问题的约定，有一个外部边界和 $h$ 个内部孔洞，因此边界分量的总数为 $k = h+1$。\n\n为了找到这个带边界区域的欧拉示性数，我们可以考虑当我们在一个闭合曲面上“打孔”时 $\\chi$ 如何变化。让我们从一个球面的三角剖分开始，其满足 $V_s - E_s + F_s = 2$。为了创建一个与我们的区域同胚的曲面，我们从这个三角剖分中移除 $k$ 个不相交的面。构成这 $k$ 个面边界的顶点和边仍然是复形的一部分，但面本身被移除了。复形中新的面数为 $F = F_s - k$。顶点和边的数量保持不变，即 $V=V_s$ 和 $E=E_s$。最终得到的带边界曲面的欧拉示性数 $\\chi_{domain}$ 为：\n$$ \\chi_{domain} = V - E + F = V_s - E_s + (F_s - k) = (V_s - E_s + F_s) - k $$\n代入 $\\chi(S^2) = 2$，我们得到：\n$$ \\chi_{domain} = 2 - k $$\n问题陈述中给出的量 $V$、$E$ 和 $F$ 对应于离散化该区域的三角剖分的顶点、边和面。因此，网格的交错和 $V-E+F$ 的值必须等于它所表示的区域的欧拉示性数。这就提供了一般性的不变量：\n$$ V - E + F = 2 - k $$\n现在，我们将其与内部孔洞的数量 $h$ 联系起来。当边界分量为 $k = h+1$ 时，该不变量变为：\n$$ V - E + F = 2 - (h+1) = 1 - h $$\n这就是将网格实体的交错计数与内部孔洞数量联系起来的具体拓扑不变量。\n\n接下来，我们必须为给定的网格计算 $V$、$E$ 和 $F$ 的值。问题提供了：\n- 顶点数（0维单元）：$V = 68$。\n- 三角形面数（2维单元）：$F = 100$。\n- 边界边数：$B = 40$。\n\n总边数 $E$ 没有明确给出。为了求出它，我们采用双重计数原理（一个关于面-边邻接关系的握手引理）。计算每个面的边数之和。由于所有单元都是三角形，每个单元有 $3$ 条边。因此，对所有 $F$ 个面求边数之和，总数为 $3F$。\n在这个求和过程中，每条内部边都恰好被两个面共享，因此被计算了两次。而每条边界边，根据定义以及问题陈述（“每条边界边都恰好属于一个三角形”），在网格中只属于一个面，因此只被计算了一次。\n设 $E_I$ 为内部边的数量，$E_B$ 为边界边的数量。总边数 $E = E_I + E_B$。双重计数关系表示为：\n$$ 3F = 2E_I + E_B $$\n我们已知 $F=100$ 且 $E_B = B = 40$。将这些值代入方程：\n$$ 3(100) = 2E_I + 40 $$\n$$ 300 = 2E_I + 40 $$\n$$ 2E_I = 300 - 40 = 260 $$\n这得出内部边的数量为 $E_I = 130$。\n网格中的总边数为：\n$$ E = E_I + E_B = 130 + 40 = 170 $$\n现在我们拥有了推导出的不变量所需的所有量：\n- $V = 68$\n- $E = 170$\n- $F = 100$\n\n我们将这些值代入公式 $V - E + F = 1 - h$ 中：\n$$ 68 - 170 + 100 = 1 - h $$\n计算左侧：\n$$ 168 - 170 = -2 $$\n方程简化为：\n$$ -2 = 1 - h $$\n最后，我们求解 $h$，即内部孔洞的数量：\n$$ h = 1 - (-2) = 1 + 2 = 3 $$\n因此，该网格化区域有 $3$ 个内部孔洞。",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "在计算流体动力学中，许多网格格式仅存储单元到节点（cell-to-node）的连接信息以节省空间。因此，任何非结构化求解器的首要任务都是重建面的连接性，因为这是计算跨面通量的基础。本练习将让你亲手实现这一核心算法，学习如何从单元数据中提取出唯一的面，并掌握使用“规范化表示”来处理共享面方向不一致问题的关键技巧 。",
            "id": "3303794",
            "problem": "在计算流体动力学 (CFD) 中使用并以可视化工具包 (VTK) 格式存储的非结构化网格通常仅通过单元到节点的连接性来表示。从第一性原理出发，我们认为一个单元是由多个面组成的三维拓扑实体，其中一个面是由构成平面多边形的最小节点子集定义的二维边界实体。网格中的一个唯一面被定义为所有单元中面的等价类，其中如果两个面由相同的节点索引集组成（与顺序无关），则它们是等价的。因此，一个面可以通过其节点索引的排序元组进行规范表示。目标是重建唯一面的集合，并识别边界-面，即那些恰好与一个单元相邻的面。\n\n从核心定义开始：\n- 网格是一个序对 $(\\mathcal{N}, \\mathcal{C})$，其中 $\\mathcal{N}$ 是节点索引的集合，$\\mathcal{C}$ 是单元列表。每个单元 $c \\in \\mathcal{C}$ 由一个类型标识符和一个有序的节点索引列表给出。\n- 对于常见的 VTK 三维单元类型，面模板由离散拓扑定义：一个四面体有 $4$ 个三角形面，一个六面体有 $6$ 个四边形面，一个楔形体（三棱柱）有 $5$ 个面（由 $2$ 个三角形和 $3$ 个四边形组成），一个金字塔体有 $5$ 个面（由 $1$ 个四边形和 $4$ 个三角形组成）。\n- 一个唯一面键是排序后的元组 $\\mathrm{sort}([n_0,\\dots,n_{k-1}])$，它规范地表示了该面的节点集合。\n\n您的任务是设计并实现一个完整的程序，该程序能够：\n1. 仅根据单元到节点的连接性，为以下 VTK 单元类型重建唯一面的集合：VTK_TETRA ($10$)、VTK_HEXAHEDRON ($12$)、VTK_WEDGE ($13$) 和 VTK_PYRAMID ($14$)。\n2. 统计边界-面的数量，边界-面定义为那些恰好与一个单元相邻的唯一面。\n3. 针对几个测试网格，根据预期的边界-面计数验证重建结果。\n\n使用以下测试套件，其中每个测试用例都是一个单元列表。每个单元是一个序对 $(t, \\mathbf{n})$，其中 $t$ 是 VTK 单元类型整数，$\\mathbf{n}$ 是该单元的有序节点索引列表。每个测试用例都提供了预期的边界-面计数：\n\n- 测试用例 1（两个四面体共享一个三角形面，其中一个单元中的面方向相反）：\n  单元：$[(10, [0,1,2,3]),\\ (10, [2,1,0,4])]$。\n  预期边界-面计数：$6$。\n\n- 测试用例 2（一个六面体）：\n  单元：$[(12, [0,1,2,3,4,5,6,7])]$。\n  预期边界-面计数：$6$。\n\n- 测试用例 3（两个楔形体在不同的单元实例间共享一个四边形面）：\n  单元：$[(13, [0,1,2,3,4,5]),\\ (13, [0,1,9,3,4,10])]$。\n  预期边界-面计数：$8$。\n\n- 测试用例 4（一个金字塔体和一个四面体共享一个三角形面）：\n  单元：$[(14, [0,1,2,3,4]),\\ (10, [1,2,4,5])]$。\n  预期边界-面计数：$7$。\n\n- 测试用例 5（两个四面体仅共享一条边，而非一个面）：\n  单元：$[(10, [0,1,2,3]),\\ (10, [2,3,4,5])]$。\n  预期边界-面计数：$8$。\n\n您的程序必须：\n- 仅使用提供的单元到节点列表和给定 VTK 单元类型的拓扑面模板来实现面重建。\n- 通过对其节点索引进行排序来规范化每个面，以确保独立于方向的唯一标识。\n- 通过识别恰好与一个单元相邻的唯一面来统计边界-面的数量。\n- 将计算出的边界-面计数与每个测试用例的预期计数进行比较，并为每个测试用例生成一个布尔结果：如果计数匹配则为 $true$，否则为 $false$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个测试用例的结果，格式为方括号内用逗号分隔的列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是一个布尔值。\n\n此问题不涉及物理单位。角度不适用。百分比不适用。请确保算法源自提供的核心定义和单元-面拓扑，而不是任何外部快捷方式或预先计算的邻接结构。",
            "solution": "从单元到节点的连接性重建面连接并识别边界-面是计算几何中的一项基本任务，特别是在计算流体动力学 (CFD) 等领域的数值求解器预处理阶段。所提供的问题是适定的、科学上合理的且内部一致的，因此可以进行形式化求解。\n\n该解决方案的核心原则是为每个面建立一个规范表示。一个面是由一组节点定义的几何实体。虽然这些节点的排序可能因面相对于其父单元的方向而异，但节点集合本身是不变的。问题陈述正确地将一个唯一面定义为基于此节点集的等价类。因此，一个稳健的规范表示（或键）是构成该面的节点全局索引的排序元组。无论原始节点排序如何，此键都是唯一的。\n\n算法流程如下：\n\n计算网格由序对 $\\mathcal{M} = (\\mathcal{N}, \\mathcal{C})$ 表示，其中 $\\mathcal{N}$ 是节点索引的集合（例如 $\\{0, 1, 2, \\dots\\}$），$\\mathcal{C}$ 是单元列表。每个单元 $c_i \\in \\mathcal{C}$ 由一个序对 $(t_i, \\mathbf{n}_i)$ 定义，其中 $t_i$ 是标识单元拓扑类型的整数，$\\mathbf{n}_i$ 是该单元的全局节点索引的有序列表。\n\n$1$. **拓扑面模板**：对于每种支持的 VTK 单元类型 $t$，我们必须定义一组固定的面模板。每个模板是一个局部索引列表，根据该单元类型的 VTK 标准节点排序，标识出构成单元单个面的节点。设 $F_t$ 为类型 $t$ 单元的面模板集合。\n- 对于 `VTK_TETRA` (类型 $t=10$)，有 $4$ 个三角形面：$F_{10} = \\{ (0,1,2), (0,3,1), (1,3,2), (2,3,0) \\}$。\n- 对于 `VTK_HEXAHEDRON` (类型 $t=12$)，有 $6$ 个四边形面：$F_{12} = \\{ (0,1,2,3), (4,5,6,7), (0,1,5,4), (1,2,6,5), (2,3,7,6), (3,0,4,7) \\}$。\n- 对于 `VTK_WEDGE` (类型 $t=13$)，有 $2$ 个三角形面和 $3$ 个四边形面：$F_{13} = \\{ (0,1,2), (3,4,5), (0,1,4,3), (1,2,5,4), (2,0,3,5) \\}$。\n- 对于 `VTK_PYRAMID` (类型 $t=14$)，有 $1$ 个四边形面和 $4$ 个三角形面：$F_{14} = \\{ (0,1,2,3), (0,1,4), (1,2,4), (2,3,4), (3,0,4) \\}$。\n\n$2$. **面实例生成与计数**：我们需要一个映射数据结构（我们将其表示为 $\\mathcal{A}$）来存储每个唯一面的关联计数。哈希映射（或字典）是合适的，其中键是规范的面表示，值是它们对应的计数。算法遍历列表 $\\mathcal{C}$ 中的每个单元 $c_i = (t_i, \\mathbf{n}_i)$。\n对于每个单元 $c_i$：\n- 检索与其类型 $t_i$ 对应的面模板集合 $F_{t_i}$。\n- 对于每个局部面模板 $f_j = (l_0, l_1, \\dots, l_k) \\in F_{t_i}$：\n    - 通过将这些局部索引映射到 $\\mathbf{n}_i$ 中提供的全局节点索引，形成一个特定的面实例。此面实例的全局节点为 $\\{ \\mathbf{n}_i[l_0], \\mathbf{n}_i[l_1], \\dots, \\mathbf{n}_i[l_k] \\}$。\n    - 此面实例的规范键 $K_f$ 是通过对这些全局节点索引进行排序生成的：$K_f = \\mathrm{tuple}(\\mathrm{sorted}([\\mathbf{n}_i[l_0], \\mathbf{n}_i[l_1], \\dots, \\mathbf{n}_i[l_k]]))$。\n    - 映射 $\\mathcal{A}$ 中此键 $K_f$ 的关联计数会增加。如果该键在 $\\mathcal{A}$ 中不存在，则将其初始化为计数 $1$。\n\n$3$. **边界-面识别**：处理完所有单元后，映射 $\\mathcal{A}$ 包含网格中存在的每个唯一面键及其关联的单元数。根据定义，边界-面是恰好与一个单元相邻的面。因此，边界-面的数量 $N_{bf}$ 是 $\\mathcal{A}$ 中值为 $1$ 的条目数量。\n$$N_{bf} = |\\{K_f \\mid \\mathcal{A}[K_f] = 1\\}|$$\n\n该算法是确定性的，能够从基于单元的连接性精确重建基于面的连接性。它利用内部面由两个或多个单元共享（导致关联计数大于1）的原理，正确识别边界-面。该算法的实现将用于验证所提供的测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the mesh face reconstruction problem for a suite of test cases.\n    \"\"\"\n\n    # Face templates are defined using local node indices for each VTK cell type.\n    # These orderings are based on the standard VTK library definitions.\n    FACE_TEMPLATES = {\n        10: [  # VTK_TETRA (4 nodes)\n            (0, 1, 2), (0, 3, 1), (1, 3, 2), (2, 3, 0)\n        ],\n        12: [  # VTK_HEXAHEDRON (8 nodes)\n            (0, 1, 2, 3), (4, 5, 6, 7), (0, 1, 5, 4), (1, 2, 6, 5),\n            (2, 3, 7, 6), (3, 0, 4, 7)\n        ],\n        13: [  # VTK_WEDGE (6 nodes)\n            (0, 1, 2), (3, 4, 5), (0, 1, 4, 3), (1, 2, 5, 4), (2, 0, 3, 5)\n        ],\n        14: [  # VTK_PYRAMID (5 nodes)\n            (0, 1, 2, 3), (0, 1, 4), (1, 2, 4), (2, 3, 4), (3, 0, 4)\n        ]\n    }\n\n    def count_boundary_faces(cells):\n        \"\"\"\n        Reconstructs unique faces and counts boundary faces from cell-to-node connectivity.\n\n        Args:\n            cells (list): A list of cells, where each cell is a tuple\n                          (cell_type_id, node_indices_list).\n\n        Returns:\n            int: The number of boundary faces.\n        \"\"\"\n        face_counts = {}\n\n        for cell_type, node_indices in cells:\n            if cell_type not in FACE_TEMPLATES:\n                raise ValueError(f\"Unknown cell type: {cell_type}\")\n\n            templates = FACE_TEMPLATES[cell_type]\n            for template in templates:\n                # Map local face template indices to global node indices\n                global_face_nodes = [node_indices[i] for i in template]\n                \n                # Create a canonical key by sorting the node indices.\n                # A tuple is used because it is hashable.\n                canonical_key = tuple(sorted(global_face_nodes))\n\n                # Increment the count for this unique face\n                face_counts[canonical_key] = face_counts.get(canonical_key, 0) + 1\n        \n        # A boundary face is a unique face that appears exactly once.\n        boundary_face_count = 0\n        for count in face_counts.values():\n            if count == 1:\n                boundary_face_count += 1\n        \n        return boundary_face_count\n\n    # Define the test suite from the problem statement.\n    test_cases = [\n        {\n            \"id\": 1,\n            \"cells\": [(10, [0, 1, 2, 3]), (10, [2, 1, 0, 4])],\n            \"expected\": 6\n        },\n        {\n            \"id\": 2,\n            \"cells\": [(12, [0, 1, 2, 3, 4, 5, 6, 7])],\n            \"expected\": 6\n        },\n        {\n            \"id\": 3,\n            \"cells\": [(13, [0, 1, 2, 3, 4, 5]), (13, [0, 1, 9, 3, 4, 10])],\n            \"expected\": 8\n        },\n        {\n            \"id\": 4,\n            \"cells\": [(14, [0, 1, 2, 3, 4]), (10, [1, 2, 4, 5])],\n            \"expected\": 7\n        },\n        {\n            \"id\": 5,\n            \"cells\": [(10, [0, 1, 2, 3]), (10, [2, 3, 4, 5])],\n            \"expected\": 8\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        computed_count = count_boundary_faces(case[\"cells\"])\n        # The result for the case is true if the computed count matches the expected one.\n        is_correct = (computed_count == case[\"expected\"])\n        results.append(str(is_correct).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "成功构建网格连接性之后，验证其拓扑完整性是确保求解器稳定性和物理守恒的关键一步。本练习将指导你实现一套诊断程序，用于检查网格是否满足“水密”（closed manifold）条件，这在有限体积法中至关重要。你将学会如何基于单元-面关联度来识别边界、内部以及非流形面，并检测悬空节点等常见但致命的网格缺陷 。",
            "id": "3303840",
            "problem": "您的任务是为计算流体动力学(CFD)中使用的非结构化有限体积网格表示设计并实现一个连接关系诊断程序。目标是从第一性原理出发，验证给定的网格区域在有限体积法(FVM)下是否表现为闭合流形，并捕捉破坏离散守恒的结构性连接关系缺陷。\n\n此任务的基础是有限体积法(FVM)和离散散度定理，这两者共同意味着，当按单元计数时，闭合流形区域内部面的通量会成对抵消。这一物理原理的组合对应物是单元和面之间的二分关联结构。当一致地对关联进行计数时，闭合流形连接关系要求每个面都恰好被两个单元引用，并且单元-面关联的总数等于面数量的两倍。\n\n定义与要求：\n\n- 令单元、面和节点的集合分别表示为 $C$、$F$ 和 $N$。\n- 对于每个单元 $c \\in C$，令 $n_f(c)$ 为与 $c$ 相关联的面数。\n- 对于每个面 $f \\in F$，令 $d(f)$ 为引用 $f$ 的单元数，也称为面的度。\n- 如果一个面满足 $d(f) = 0$，则称其为孤立面。\n- 如果一个节点不出现在任何面中，即它通过面-节点连接关系与集合 $F$ 的邻接度为零，则称其为悬挂节点。\n- 一个区域在有限体积法下表现为闭合流形，当且仅当每个面的度 $d(f) = 2$ 且单元-面关联的总数等于面数量的两倍；等价地，通过对二分关联关系的双重计数可得 $\\sum_{c \\in C} n_f(c) = \\sum_{f \\in F} d(f)$，而对于闭合流形，所有 $f \\in F$ 都满足 $d(f) = 2$，因此有 $\\sum_{c \\in C} n_f(c) = 2 |F|$。\n\n您的程序必须根据给定的面-节点和单元-面连接关系实现以下诊断功能：\n\n- 计算 $S = \\sum_{c \\in C} n_f(c)$。\n- 通过统计每个面被多少单元引用，来计算所有 $f \\in F$ 的度 $d(f)$。\n- 计算孤立面的数量，即满足 $d(f) = 0$ 的 $f \\in F$ 的计数。\n- 计算悬挂节点的数量，即在面-节点连接关系中不出现于任何面中的节点 $N$ 的计数。\n\n对于每个测试用例，程序必须返回一个布尔值，该值为 $ \\mathrm{True} $ 当且仅当以下所有条件同时成立：\n- 闭合流形条件：每个 $f \\in F$ 的度 $d(f) = 2$，且 $S = 2|F|$。\n- 不存在孤立面。\n- 不存在悬挂节点。\n\n您的实现必须是自包含的，并且只能对下面测试套件中提供的连接关系数组进行操作。不允许使用几何坐标、外部输入和文件访问。\n\n测试套件（每个用例使用从零开始的索引指定 $|N|$、面-节点连接关系和单元-面连接关系）：\n\n- 用例 $1$ (闭合流形组合模型)：\n  - $|N| = 4$。\n  - $F = \\{ [0,1,2], [0,1,3], [0,2,3], [1,2,3] \\}$。\n  - $C = \\{ [0,1,2,3], [0,1,2,3] \\}$。\n  - 预期：$ \\mathrm{True} $。\n\n- 用例 $2$ (带边界面​​的开放区域)：\n  - $|N| = 5$。\n  - $F = \\{ [0,1,2], [0,1,3], [0,2,3], [1,2,3], [0,1,4], [0,2,4], [1,2,4] \\}$。\n  - $C = \\{ [0,1,2,3], [0,4,5,6] \\}$。\n  - 预期：$ \\mathrm{False} $。\n\n- 用例 $3$ (度为 3 的非流形面)：\n  - $|N| = 6$。\n  - $F = \\{ [0,1,2], [0,1,3], [0,2,3], [1,2,3], [0,1,4], [0,2,4], [1,2,4], [0,1,5], [0,2,5], [1,2,5] \\}$。\n  - $C = \\{ [0,1,2,3], [0,4,5,6], [0,7,8,9] \\}$。\n  - 预期：$ \\mathrm{False} $。\n\n- 用例 $4$ (存在孤立面)：\n  - $|N| = 5$。\n  - $F = \\{ [0,1,2], [0,1,3], [0,2,3], [1,2,3], [0,3,4] \\}$。\n  - $C = \\{ [0,1,2,3], [0,1,2,3] \\}$。\n  - 预期：$ \\mathrm{False} $。\n\n- 用例 $5$ (存在悬挂节点)：\n  - $|N| = 5$。\n  - $F = \\{ [0,1,2], [0,1,3], [0,2,3], [1,2,3] \\}$。\n  - $C = \\{ [0,1,2,3], [0,1,2,3] \\}$。\n  - 预期：$ \\mathrm{False} $。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4,result_5]$），其中每个 $result_i$ 为 $ \\mathrm{True} $ 或 $ \\mathrm{False} $，按上述顺​​序对应于各个测试用例。",
            "solution": "该问题要求开发一个诊断工具，用于验证非结构化网格区域的拓扑完整性，特别是从有限体积法(FVM)的角度验证其是否符合闭合流形结构。网格连接关系的验证是在数值模拟中确保离散守恒定律的关键先决条件。解决方案通过实施一系列算法检查来推进，这些检查源于组合拓扑学和离散散度定理的基本原理。\n\n此分析的基石是作为FVM基础的离散形式的散度定理。对于一个控制体 $\\Omega_i$，该定理指出，矢量场 $\\mathbf{v}$ 的散度在体积上的积分等于通过其边界面的通量之和：\n$$ \\int_{\\Omega_i} (\\nabla \\cdot \\mathbf{v}) \\, d\\Omega = \\sum_{f \\in \\partial \\Omega_i} \\int_f \\mathbf{v} \\cdot \\mathbf{n} \\, dA $$\n在一个由单元集合 $C$ 组成的闭合域中，对所有单元的通量求和会导致跨所有内部面的通量相互抵消。每个内部面 $f$ 都恰好由两个相邻单元（例如 $c_i$ 和 $c_j$）共享。从 $c_i$ 穿过 $f$ 的通量是从 $c_j$ 穿过 $f$ 的通量的相反数，因为它们的法向量方向相反。因此，对于一个闭合的流形域，所有内部面上的总通量为零。\n\n这一物理原理有直接的组合对应物。令 $C$ 为单元集， $F$ 为面集。我们可以在这两个集合之间定义一个二分关联关系。对于一个没有边界的闭合流形区域，每个面都必须是内部面。这施加了一个严格的结构约束：每个面 $f \\in F$ 必须恰好被两个单元引用。引用一个面 $f$ 的单元数量是它的度，记作 $d(f)$。因此，闭合流形条件是对于所有 $f \\in F$ 都有 $d(f) = 2$。\n\n这种二分结构中的一个基本恒等式源于对单元-面关联总数的双重计数。令 $n_f(c)$ 为构成单元 $c$ 的面数。对所有单元的 $n_f(c)$ 求和，得到从单元角度看的关联总数。或者，对所有面的度 $d(f)$ 求和，得到从面角度看的相同总数。这得出了恒等式：\n$$ S = \\sum_{c \\in C} n_f(c) = \\sum_{f \\in F} d(f) $$\n如果闭合流形条件 $d(f) = 2$ 对所有 $f \\in F$ 成立，该恒等式简化为 $S = \\sum_{f \\in F} 2 = 2|F|$，其中 $|F|$ 是面的总数。该问题要求我们验证确保此类流形结构的条件，并检查其他常见的连接关系缺陷。\n\n该解决方案通过对提供的连接关系数据执行四项特定的诊断计算来实现。\n\n1.  **计算单元-面关联总数 $S$**：通过遍历单元列表 `cells_faces` 来计算量 $S = \\sum_{c \\in C} n_f(c)$。对每个单元，我们计算与其相连的面数，这即是其对应面索引列表的长度。将这些长度相加得到 $S$。\n\n2.  **计算面的度 $d(f)$ 并统计孤立面**：为确定每个面的度 $d(f)$，我们必须统计每个面索引在所有单元定义中出现的次数。一种高效的方法是初始化一个大小为 $|F|$ 的整数数组，所有条目都设置为零。该数组将存储每个面的度，索引从 $0$到 $|F|-1$。然后我们遍历 `cells_faces` 中每个单元的面索引列表。每遇到一个面索引，我们就在度数组中增加相应的计数器。处理完所有单元后，该数组就包含了最终的度 $d(f)$。如果一个面 $f$ 满足 $d(f) = 0$，则其被定义为孤立面。孤立面的数量可以通过计算度数组中零条目的数量来得到。\n\n3.  **计算悬挂节点的数量**：悬挂节点是存在于网格节点列表中但未构成任何面定义的顶点。为了识别这些节点，我们首先构建一个集合，包含在 `faces_nodes` 连接关系列表中使用的所有唯一节点索引。这通过遍历每个面的节点索引列表并将它们添加到一个 Python `set` 中来完成，以自动处理唯一性。节点的总集合隐式地为 $\\{0, 1, \\dots, |N|-1\\}$，其中 $|N|$ 是节点的总数。悬挂节点的集合是总节点集与已用节点集之间的差集。悬挂节点的数量就是这个结果集的大小。\n\n4.  **最终验证**：问题规定，一个网格区域是有效的，当且仅当三个条件同时成立：\n    a. 满足闭合流形条件。这被定义为两个子条件：每个面 $f \\in F$ 的度必须为 $d(f) = 2$，并且总关联和必须满足 $S = 2|F|$。如前所述，后者是前者的直接推论，但为了严格遵守问题陈述，两者都进行了检查。\n    b. 不存在孤立面，即度为 $d(f) = 0$ 的面数量为零。这也是所有 $f$ 满足 $d(f)=2$ 的一个推论，但仍需明确检查。\n    c. 不存在悬挂节点。\n\n该算法评估这三个条件。仅当所有条件都满足时，才返回布尔结果 $\\mathrm{True}$；否则，返回 $\\mathrm{False}$，表示存在连接关系缺陷。此过程将应用于提供的每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_connectivity(num_nodes, faces_nodes, cells_faces):\n    \"\"\"\n    Performs connectivity diagnostics on an unstructured mesh region.\n\n    Args:\n        num_nodes (int): The total number of nodes in the mesh, |N|.\n        faces_nodes (list of list of int): Face-node connectivity. Each inner list\n            contains the zero-based indices of nodes forming a face.\n        cells_faces (list of list of int): Cell-face connectivity. Each inner list\n            contains the zero-based indices of faces forming a cell.\n\n    Returns:\n        bool: True if the mesh region satisfies all closed-manifold and integrity\n              conditions, False otherwise.\n    \"\"\"\n    num_faces = len(faces_nodes)\n    num_cells = len(cells_faces)\n\n    # 1. Compute S = sum(n_f(c) for c in C)\n    S = sum(len(face_list) for face_list in cells_faces)\n\n    # 2. Compute face degrees d(f) and count isolated faces\n    if num_faces == 0:\n        face_degrees = np.array([], dtype=int)\n    else:\n        face_degrees = np.zeros(num_faces, dtype=int)\n        for cell in cells_faces:\n            for face_idx in cell:\n                # Check for out-of-bounds face index\n                if face_idx  num_faces:\n                    face_degrees[face_idx] += 1\n    \n    isolated_faces_count = np.count_nonzero(face_degrees == 0)\n\n    # 3. Compute dangling nodes\n    all_node_indices = set(range(num_nodes))\n    used_node_indices = set()\n    for face in faces_nodes:\n        for node_idx in face:\n            used_node_indices.add(node_idx)\n    \n    dangling_nodes_count = len(all_node_indices - used_node_indices)\n\n    # 4. Evaluate all conditions\n    # Condition 1: Closed-manifold condition\n    # every f in F has d(f) = 2, and S = 2*|F|\n    all_degrees_are_two = np.all(face_degrees == 2) if num_faces > 0 else True\n    sum_check = (S == 2 * num_faces)\n    manifold_ok = all_degrees_are_two and sum_check\n\n    # Condition 2: No isolated faces\n    no_isolated = (isolated_faces_count == 0)\n\n    # Condition 3: No dangling nodes\n    no_dangling = (dangling_nodes_count == 0)\n\n    # Final result is the conjunction of all three conditions\n    return manifold_ok and no_isolated and no_dangling\n\ndef solve():\n    \"\"\"\n    Runs the connectivity diagnostics on a predefined suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (closed-manifold combinatorial model)\n        (4, [[0,1,2], [0,1,3], [0,2,3], [1,2,3]], [[0,1,2,3], [0,1,2,3]]),\n        \n        # Case 2 (open region with boundary faces)\n        (5, [[0,1,2], [0,1,3], [0,2,3], [1,2,3], [0,1,4], [0,2,4], [1,2,4]], [[0,1,2,3], [0,4,5,6]]),\n\n        # Case 3 (nonmanifold face of degree 3)\n        (6, [[0,1,2], [0,1,3], [0,2,3], [1,2,3], [0,1,4], [0,2,4], [1,2,4], [0,1,5], [0,2,5], [1,2,5]], [[0,1,2,3], [0,4,5,6], [0,7,8,9]]),\n\n        # Case 4 (isolated face present)\n        (5, [[0,1,2], [0,1,3], [0,2,3], [1,2,3], [0,3,4]], [[0,1,2,3], [0,1,2,3]]),\n        \n        # Case 5 (dangling node present)\n        (5, [[0,1,2], [0,1,3], [0,2,3], [1,2,3]], [[0,1,2,3], [0,1,2,3]]),\n    ]\n\n    results = []\n    for case in test_cases:\n        num_nodes, faces_nodes, cells_faces = case\n        result = check_connectivity(num_nodes, faces_nodes, cells_faces)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, str(res).lower())) for res in results}]\")\n\nsolve()\n```"
        }
    ]
}