{
    "hands_on_practices": [
        {
            "introduction": "许多网格数据格式（如VTK）为了紧凑性，仅存储单元到节点的连接关系。本实践将引导你实现一个核心算法，从这些最基本的数据中重建出显式的面连接关系，这是许多基于面进行通量计算的CFD求解器的前提。通过对面的节点进行规范化处理，我们可以唯一地识别每一个面，无论它在相邻单元中的方向如何。",
            "id": "3303794",
            "problem": "在计算流体力学（CFD）中使用并在可视化工具包（VTK）格式中存储的非结构化网格，通常仅用单元到节点的连接关系来表示。从第一性原理出发，我们视一个单元为一个拓扑三维实体，它由多个面组成，而一个面是一个二维边界实体，由形成一个平面多边形的最少节点子集定义。网格中的一个唯一面被定义为所有单元中面的一个等价类，其中两个面如果由相同的节点索引集构成（不考虑顺序），则它们是等价的。因此，一个面可以通过其节点索引的排序元组来进行规范表示。目标是重建唯一面的集合，并识别出边界面，即那些仅与一个单元相邻的面。\n\n从核心定义开始：\n- 一个网格是一个偶对 $(\\mathcal{N}, \\mathcal{C})$，其中 $\\mathcal{N}$ 是节点索引的集合，$\\mathcal{C}$ 是单元的列表。每个单元 $c \\in \\mathcal{C}$ 由一个类型标识符和一个有序的节点索引列表给出。\n- 对于常见的三维 VTK 单元类型，其面模板由离散拓扑定义：一个四面体有 $4$ 个三角形面，一个六面体有 $6$ 个四边形面，一个楔形体（三棱柱）有 $5$ 个面（由 $2$ 个三角形和 $3$ 个四边形组成），一个金字塔体有 $5$ 个面（由 $1$ 个四边形和 $4$ 个三角形组成）。\n- 一个唯一面键是排序后的元组 $\\mathrm{sort}([n_0,\\dots,n_{k-1}])$，它规范地表示了该面的节点集合。\n\n你的任务是设计并实现一个完整的程序，该程序能够：\n1. 仅根据单元到节点的连接关系，为以下 VTK 单元类型重建唯一面的集合：VTK_TETRA (10)、VTK_HEXAHEDRON (12)、VTK_WEDGE (13) 和 VTK_PYRAMID (14)。\n2. 统计边界面（定义为那些仅与一个单元相邻的唯一面）的数量。\n3. 针对几个测试网格，将重建结果与预期的边界面数量进行验证。\n\n使用以下测试套件，其中每个测试用例都是一个单元列表。每个单元是一个偶对 $(t, \\mathbf{n})$，其中 $t$ 是 VTK 单元类型的整数，$\\mathbf{n}$ 是该单元的有序节点索引列表。每个测试用例都提供了预期的边界面数量：\n\n- 测试用例 $1$（两个四面体共享一个三角形面，其中一个单元中的面方向相反）：\n  单元：$[(10, [0,1,2,3]),\\ (10, [2,1,0,4])]$。\n  预期边界面数量：$6$。\n\n- 测试用例 $2$（一个六面体）：\n  单元：$[(12, [0,1,2,3,4,5,6,7])]$。\n  预期边界面数量：$6$。\n\n- 测试用例 $3$（两个楔形体在不同的单元实例间共享一个四边形面）：\n  单元：$[(13, [0,1,2,3,4,5]),\\ (13, [0,1,9,3,4,10])]$。\n  预期边界面数量：$8$。\n\n- 测试用例 $4$（一个金字塔体和一个四面体共享一个三角形面）：\n  单元：$[(14, [0,1,2,3,4]),\\ (10, [1,2,4,5])]$。\n  预期边界面数量：$7$。\n\n- 测试用例 $5$（两个四面体仅共享一条边，而非一个面）：\n  单元：$[(10, [0,1,2,3]),\\ (10, [2,3,4,5])]$。\n  预期边界面数量：$8$。\n\n你的程序必须：\n- 仅使用提供的单元到节点列表和给定 VTK 单元类型的拓扑面模板来实现面重建。\n- 通过对其节点索引进行排序来规范化每个面，以确保独立于方向的唯一识别。\n- 通过识别仅与一个单元相邻的唯一面来统计边界面。\n- 将计算出的边界面数量与每个测试用例的预期数量进行比较，并为每个测试用例生成一个布尔结果：如果数量匹配，则为 $true$，否则为 $false$。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含五个测试用例的结果，格式为方括号内以逗号分隔的列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是一个布尔值。\n\n此问题不涉及物理单位。角度不适用。百分比不适用。确保算法是根据提供的核心定义和单元-面拓扑推导出来的，而不是来自任何外部捷径或预计算的邻接结构。",
            "solution": "从单元到节点的连接关系中重建面的连接性并识别边界面，是计算几何中的一项基本任务，尤其是在计算流体力学（CFD）等领域的数值求解器预处理阶段。所给出的问题是适定的、科学上合理的且内部一致的，因此允许一个形式化的解法。\n\n支撑该解法的核心原则是为每个面建立一个规范表示。面是由一组节点定义的几何实体。虽然这些节点的顺序可能因面相对于其父单元的方向而异，但节点集合本身是不变的。问题陈述正确地将一个唯一面定义为基于此节点集的等价类。因此，一个鲁棒的规范表示（或键）是由构成该面的全局节点索引组成的排序元组。无论原始节点顺序如何，此键都是唯一的。\n\n算法流程如下：\n\n假设计算网格由一个偶对 $\\mathcal{M} = (\\mathcal{N}, \\mathcal{C})$ 表示，其中 $\\mathcal{N}$ 是节点索引的集合（例如，$\\{0, 1, 2, \\dots\\}$），$\\mathcal{C}$ 是单元的列表。每个单元 $c_i \\in \\mathcal{C}$ 由一个偶对 $(t_i, \\mathbf{n}_i)$ 定义，其中 $t_i$ 是标识单元拓扑类型的整数，$\\mathbf{n}_i$ 是该单元的有序全局节点索引列表。\n\n$1$. **拓扑面模板**：对于每个支持的 VTK 单元类型 $t$，我们必须定义一组固定的面模板。每个模板是一个局部索引列表，它根据 VTK 对该单元类型的标准节点排序，标识出构成单元单个面的节点。设 $F_t$ 为类型为 $t$ 的单元的面模板集合。\n- 对于 `VTK_TETRA`（类型 $t=10$），有 $4$ 个三角形面：$F_{10} = \\{ (0,1,2), (0,3,1), (1,3,2), (2,3,0) \\}$。\n- 对于 `VTK_HEXAHEDRON`（类型 $t=12$），有 $6$ 个四边形面：$F_{12} = \\{ (0,1,2,3), (4,5,6,7), (0,1,5,4), (1,2,6,5), (2,3,7,6), (3,0,4,7) \\}$。\n- 对于 `VTK_WEDGE`（类型 $t=13$），有 $2$ 个三角形面和 $3$ 个四边形面：$F_{13} = \\{ (0,1,2), (3,4,5), (0,1,4,3), (1,2,5,4), (2,0,3,5) \\}$。\n- 对于 `VTK_PYRAMID`（类型 $t=14$），有 $1$ 个四边形面和 $4$ 个三角形面：$F_{14} = \\{ (0,1,2,3), (0,1,4), (1,2,4), (2,3,4), (3,0,4) \\}$。\n\n$2$. **面实例生成与计数**：我们需要一个映射数据结构（我们将其表示为 $\\mathcal{A}$）来存储每个唯一面的邻接计数。哈希映射（或字典）是合适的选择，其键是规范的面表示，值是它们对应的计数。算法遍历列表 $\\mathcal{C}$ 中的每个单元 $c_i = (t_i, \\mathbf{n}_i)$。\n对于每个单元 $c_i$：\n- 检索与其类型 $t_i$ 对应的面模板集合 $F_{t_i}$。\n- 对于每个局部面模板 $f_j = (l_0, l_1, \\dots, l_k) \\in F_{t_i}$：\n    - 通过将这些局部索引映射到 $\\mathbf{n}_i$ 中提供的全局节点索引，形成一个特定的面实例。此面实例的全局节点为 $\\{ \\mathbf{n}_i[l_0], \\mathbf{n}_i[l_1], \\dots, \\mathbf{n}_i[l_k] \\}$。\n    - 通过对这些全局节点索引进行排序，生成该面实例的规范键 $K_f$：$K_f = \\mathrm{tuple}(\\mathrm{sorted}([\\mathbf{n}_i[l_0], \\mathbf{n}_i[l_1], \\dots, \\mathbf{n}_i[l_k]]))$。\n    - 在映射 $\\mathcal{A}$ 中，此键 $K_f$ 的邻接计数递增。如果键在 $\\mathcal{A}$ 中不存在，则以计数 $1$ 初始化。\n\n$3$. **边界面识别**：处理完所有单元后，映射 $\\mathcal{A}$ 包含了网格中存在的每个唯一面键及其所邻接的单元数。根据定义，边界面是仅与一个单元相邻的面。因此，边界面的数量 $N_{bf}$ 是 $\\mathcal{A}$ 中值恰好为 $1$ 的条目数。\n$$N_{bf} = |\\{K_f \\mid \\mathcal{A}[K_f] = 1\\}|$$\n\n该算法是确定性的，并能从基于单元的连接关系中精确重建基于面的连接关系。它通过利用内部面由两个或多个单元共享（导致邻接计数大于 $1$）的原理，正确地识别出边界面。此算法的实现将用于验证所提供的测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the mesh face reconstruction problem for a suite of test cases.\n    \"\"\"\n\n    # Face templates are defined using local node indices for each VTK cell type.\n    # These orderings are based on the standard VTK library definitions.\n    FACE_TEMPLATES = {\n        10: [  # VTK_TETRA (4 nodes)\n            (0, 1, 2), (0, 3, 1), (1, 3, 2), (2, 3, 0)\n        ],\n        12: [  # VTK_HEXAHEDRON (8 nodes)\n            (0, 1, 2, 3), (4, 5, 6, 7), (0, 1, 5, 4), (1, 2, 6, 5),\n            (2, 3, 7, 6), (3, 0, 4, 7)\n        ],\n        13: [  # VTK_WEDGE (6 nodes)\n            (0, 1, 2), (3, 4, 5), (0, 1, 4, 3), (1, 2, 5, 4), (2, 0, 3, 5)\n        ],\n        14: [  # VTK_PYRAMID (5 nodes)\n            (0, 1, 2, 3), (0, 1, 4), (1, 2, 4), (2, 3, 4), (3, 0, 4)\n        ]\n    }\n\n    def count_boundary_faces(cells):\n        \"\"\"\n        Reconstructs unique faces and counts boundary faces from cell-to-node connectivity.\n\n        Args:\n            cells (list): A list of cells, where each cell is a tuple\n                          (cell_type_id, node_indices_list).\n\n        Returns:\n            int: The number of boundary faces.\n        \"\"\"\n        face_counts = {}\n\n        for cell_type, node_indices in cells:\n            if cell_type not in FACE_TEMPLATES:\n                raise ValueError(f\"Unknown cell type: {cell_type}\")\n\n            templates = FACE_TEMPLATES[cell_type]\n            for template in templates:\n                # Map local face template indices to global node indices\n                global_face_nodes = [node_indices[i] for i in template]\n                \n                # Create a canonical key by sorting the node indices.\n                # A tuple is used because it is hashable.\n                canonical_key = tuple(sorted(global_face_nodes))\n\n                # Increment the count for this unique face\n                face_counts[canonical_key] = face_counts.get(canonical_key, 0) + 1\n        \n        # A boundary face is a unique face that appears exactly once.\n        boundary_face_count = 0\n        for count in face_counts.values():\n            if count == 1:\n                boundary_face_count += 1\n        \n        return boundary_face_count\n\n    # Define the test suite from the problem statement.\n    test_cases = [\n        {\n            \"id\": 1,\n            \"cells\": [(10, [0, 1, 2, 3]), (10, [2, 1, 0, 4])],\n            \"expected\": 6\n        },\n        {\n            \"id\": 2,\n            \"cells\": [(12, [0, 1, 2, 3, 4, 5, 6, 7])],\n            \"expected\": 6\n        },\n        {\n            \"id\": 3,\n            \"cells\": [(13, [0, 1, 2, 3, 4, 5]), (13, [0, 1, 9, 3, 4, 10])],\n            \"expected\": 8\n        },\n        {\n            \"id\": 4,\n            \"cells\": [(14, [0, 1, 2, 3, 4]), (10, [1, 2, 4, 5])],\n            \"expected\": 7\n        },\n        {\n            \"id\": 5,\n            \"cells\": [(10, [0, 1, 2, 3]), (10, [2, 3, 4, 5])],\n            \"expected\": 8\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        computed_count = count_boundary_faces(case[\"cells\"])\n        # The result for the case is true if the computed count matches the expected one.\n        is_correct = (computed_count == case[\"expected\"])\n        results.append(str(is_correct).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在构建了面的连接性之后，下一步关键是验证网格的拓扑完整性。对于有限体积法等数值方法，确保网格在计算域内部表现为“封闭流形”对于保证离散守恒至关重要。本练习提供了一套诊断工具，用于检查常见的拓扑缺陷，如悬空节点或孤立面，从而保证网格的有效性。",
            "id": "3303840",
            "problem": "您的任务是为计算流体动力学 (CFD) 中使用的非结构化有限体积网格表示设计并实现一个连通性诊断程序。目标是从第一性原理出发，验证给定的网格区域在有限体积法 (FVM) 下是否表现为闭合流形，并捕捉破坏离散守恒的结构性连通缺陷。\n\n该任务的基本依据是有限体积法 (FVM) 和离散散度定理，这两者共同意味着，当按单元进行计数时，闭合流形区域内部面上的通量会成对抵消。这一物理原理的组合对应物是单元和面之间的二分关联结构。在一致地对关联关系进行计数时，闭合流形连通性要求每个面都恰好被两个单元引用，并且单元-面的总关联数等于面总数的两倍。\n\n定义和要求：\n\n- 设单元、面和节点的集合分别用 $C$、$F$ 和 $N$ 表示。\n- 对于每个单元 $c \\in C$，令 $n_f(c)$ 为与 $c$ 相关联的面数。\n- 对于每个面 $f \\in F$，令 $d(f)$ 为引用 $f$ 的单元数，也称为面的度。\n- 如果 $d(f) = 0$，则称该面为孤立面。\n- 如果一个节点未出现在任何面中，即它通过面-节点连通性与集合 $F$ 的邻接关系为零，则称该节点为悬挂节点。\n- 一个区域在有限体积法下表现为闭合流形，当且仅当每个面的度 $d(f) = 2$ 且单元-面总关联数等于面总数的两倍；等价地，对二分关联关系的双重计数得出 $\\sum_{c \\in C} n_f(c) = \\sum_{f \\in F} d(f)$，并且对于闭合流形，所有 $f \\in F$ 都有 $d(f) = 2$，因此 $\\sum_{c \\in C} n_f(c) = 2 |F|$。\n\n您的程序必须根据给定的面-节点和单元-面连通性，实现以下诊断功能：\n\n- 计算 $S = \\sum_{c \\in C} n_f(c)$。\n- 通过计算每个面被多少个单元引用，来计算所有 $f \\in F$ 的度 $d(f)$。\n- 计算孤立面的数量，即满足 $d(f) = 0$ 的 $f \\in F$ 的计数。\n- 计算悬挂节点的数量，即在面-节点连通性中未出现在任何面中的节点 $N$ 的计数。\n\n对于每个测试用例，程序必须返回一个布尔值，当且仅当以下所有条件同时成立时，该值为 $ \\mathrm{True} $：\n- 闭合流形条件：每个 $f \\in F$ 的度 $d(f) = 2$，并且 $S = 2|F|$。\n- 不存在孤立面。\n- 不存在悬挂节点。\n\n您的实现必须是自包含的，并且只能对下面测试套件中提供的连通性数组进行操作。不允许使用几何坐标、外部输入和文件访问。\n\n测试套件（每个用例使用从零开始的索引指定 $|N|$、面-节点连通性和单元-面连通性）：\n\n- 用例 1 (闭合流形组合模型):\n  - $|N| = 4$。\n  - $F = \\{ [0,1,2], [0,1,3], [0,2,3], [1,2,3] \\}$。\n  - $C = \\{ [0,1,2,3], [0,1,2,3] \\}$。\n  - 预期结果: $ \\mathrm{True} $。\n\n- 用例 2 (带有边界面片的开放区域):\n  - $|N| = 5$。\n  - $F = \\{ [0,1,2], [0,1,3], [0,2,3], [1,2,3], [0,1,4], [0,2,4], [1,2,4] \\}$。\n  - $C = \\{ [0,1,2,3], [0,4,5,6] \\}$。\n  - 预期结果: $ \\mathrm{False} $。\n\n- 用例 3 (度为 $3$ 的非流形面):\n  - $|N| = 6$。\n  - $F = \\{ [0,1,2], [0,1,3], [0,2,3], [1,2,3], [0,1,4], [0,2,4], [1,2,4], [0,1,5], [0,2,5], [1,2,5] \\}$。\n  - $C = \\{ [0,1,2,3], [0,4,5,6], [0,7,8,9] \\}$。\n  - 预期结果: $ \\mathrm{False} $。\n\n- 用例 4 (存在孤立面):\n  - $|N| = 5$。\n  - $F = \\{ [0,1,2], [0,1,3], [0,2,3], [1,2,3], [0,3,4] \\}$。\n  - $C = \\{ [0,1,2,3], [0,1,2,3] \\}$。\n  - 预期结果: $ \\mathrm{False} $。\n\n- 用例 5 (存在悬挂节点):\n  - $|N| = 5$。\n  - $F = \\{ [0,1,2], [0,1,3], [0,2,3], [1,2,3] \\}$。\n  - $C = \\{ [0,1,2,3], [0,1,2,3] \\}$。\n  - 预期结果: $ \\mathrm{False} $。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,result_3,result_4,result_5]$），其中每个 $result_i$ 对应于上面列出的测试用例，值为 $ \\mathrm{True} $ 或 $ \\mathrm{False} $。",
            "solution": "该问题要求开发一个诊断工具，用于验证非结构化网格区域的拓扑完整性，特别是从有限体积法 (FVM) 的角度验证其是否符合闭合流形结构。网格连通性的验证是在数值模拟中确保离散守恒定律的关键先决条件。解决方案通过实现一系列源于组合拓扑学和离散散度定理基本原理的算法检查来推进。\n\n该分析的基石是离散形式的散度定理，它也是 FVM 的基础。对于一个控制体 $\\Omega_i$，该定理指出，矢量场 $\\mathbf{v}$ 的散度在整个体积上的积分等于通过其边界面的通量之和：\n$$ \\int_{\\Omega_i} (\\nabla \\cdot \\mathbf{v}) \\, d\\Omega = \\sum_{f \\in \\partial \\Omega_i} \\int_f \\mathbf{v} \\cdot \\mathbf{n} \\, dA $$\n在一个由单元集合 $C$ 组成的闭合域中，对所有单元的通量求和，会导致跨所有内部面的通量相互抵消。每个内部面 $f$ 都由恰好两个相邻的单元（例如 $c_i$ 和 $c_j$）共享。从 $c_i$ 穿过 $f$ 的通量是从 $c_j$ 穿过 $f$ 的通量的负值，因为它们的法向量方向相反。因此，对于一个闭合的流形域，所有内部面上的通量总和为零。\n\n这个物理原理有一个直接的组合对应物。设 $C$ 为单元集， $F$ 为面集。我们可以在这两个集合之间定义一个二分关联关系。对于一个无边界的闭合流形区域，每个面都必须是内部面。这施加了一个严格的结构约束：每个面 $f \\in F$ 必须恰好被两个单元引用。引用一个面 $f$ 的单元数是它的度，记为 $d(f)$。因此，闭合流形条件是对于所有 $f \\in F$，$d(f) = 2$。\n\n在这个二分结构中，一个基本恒等式源于对单元-面总关联数的双重计数。设 $n_f(c)$ 是包围单元 $c$ 的面数。对所有单元的 $n_f(c)$ 求和，得到从单元角度看的所有关联总数。或者，对所有面的度 $d(f)$ 求和，得到从面角度看的相同总数。这就得出了恒等式：\n$$ S = \\sum_{c \\in C} n_f(c) = \\sum_{f \\in F} d(f) $$\n如果闭合流形条件 $d(f) = 2$ 对所有 $f \\in F$ 都成立，该恒等式简化为 $S = \\sum_{f \\in F} 2 = 2|F|$，其中 $|F|$ 是面的总数。问题要求我们验证确保这种流形结构的条件，并检查其他常见的连通性缺陷。\n\n该解决方案通过对提供的连通性数据执行四项特定的诊断计算来实现。\n\n1.  **计算单元-面总关联数 $S$**：通过遍历单元列表 `cells_faces` 来计算 $S = \\sum_{c \\in C} n_f(c)$。对于每个单元，我们计算它所连接的面数，即其对应面索引列表的长度。将这些长度相加得到 $S$。\n\n2.  **计算面的度 $d(f)$ 并统计孤立面**：为了确定每个面的度 $d(f)$，我们必须统计每个面索引在所有单元定义中出现的次数。一个有效的方法是初始化一个大小为 $|F|$ 的整数数组，所有条目都设置为零。该数组将存储每个面的度，索引从 $0$ 到 $|F|-1$。然后我们遍历 `cells_faces` 中每个单元的面索引列表。对于遇到的每个面索引，我们在度数组中增加相应的计数器。处理完所有单元后，该数组就包含了最终的度 $d(f)$。如果一个面 $f$ 的 $d(f)=0$，则它被定义为孤立面。孤立面的数量可以通过计算度数组中零条目的数量来找到。\n\n3.  **计算悬挂节点数**：悬挂节点是存在于网格节点列表中但不是任何面定义一部分的顶点。为了识别这些节点，我们首先构建一个包含在 `faces_nodes` 连通性列表中使用的所有唯一节点索引的集合。这通过遍历每个面的节点索引列表，并将它们添加到一个 Python `set` 中来完成，以自动处理唯一性。总节点集隐含为 $\\{0, 1, \\dots, |N|-1\\}$，其中 $|N|$ 是节点总数。悬挂节点集是总节点集与已用节点集之间的差集。悬挂节点的数量就是这个结果集的大小。\n\n4.  **最终验证**：问题规定，一个网格区域是有效的，当且仅当三个条件同时成立：a. 满足闭合流形条件。这被定义为两个子条件：每个面 $f \\in F$ 的度必须为 $d(f) = 2$，并且总关联和必须满足 $S = 2|F|$。如前所述，后者是前者的直接推论，但为了严格遵守问题陈述，两者都进行检查。b. 不存在孤立面，即度 $d(f) = 0$ 的面数量为零。这也是所有 $f$ 的 $d(f)=2$ 的推论，但仍进行显式检查。c. 不存在悬挂节点。\n\n算法评估这三个条件。仅当所有条件都满足时，才返回布尔结果 $\\mathrm{True}$；否则，返回 $\\mathrm{False}$，表示存在连通性缺陷。此过程应用于所提供的每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_connectivity(num_nodes, faces_nodes, cells_faces):\n    \"\"\"\n    Performs connectivity diagnostics on an unstructured mesh region.\n\n    Args:\n        num_nodes (int): The total number of nodes in the mesh, |N|.\n        faces_nodes (list of list of int): Face-node connectivity. Each inner list\n            contains the zero-based indices of nodes forming a face.\n        cells_faces (list of list of int): Cell-face connectivity. Each inner list\n            contains the zero-based indices of faces forming a cell.\n\n    Returns:\n        bool: True if the mesh region satisfies all closed-manifold and integrity\n              conditions, False otherwise.\n    \"\"\"\n    num_faces = len(faces_nodes)\n    num_cells = len(cells_faces)\n\n    # 1. Compute S = sum(n_f(c) for c in C)\n    S = sum(len(face_list) for face_list in cells_faces)\n\n    # 2. Compute face degrees d(f) and count isolated faces\n    if num_faces == 0:\n        face_degrees = np.array([], dtype=int)\n    else:\n        face_degrees = np.zeros(num_faces, dtype=int)\n        for cell in cells_faces:\n            for face_idx in cell:\n                # Check for out-of-bounds face index\n                if face_idx  num_faces:\n                    face_degrees[face_idx] += 1\n    \n    isolated_faces_count = np.count_nonzero(face_degrees == 0)\n\n    # 3. Compute dangling nodes\n    all_node_indices = set(range(num_nodes))\n    used_node_indices = set()\n    for face in faces_nodes:\n        for node_idx in face:\n            used_node_indices.add(node_idx)\n    \n    dangling_nodes_count = len(all_node_indices - used_node_indices)\n\n    # 4. Evaluate all conditions\n    # Condition 1: Closed-manifold condition\n    # every f in F has d(f) = 2, and S = 2*|F|\n    all_degrees_are_two = np.all(face_degrees == 2)\n    sum_check = (S == 2 * num_faces)\n    manifold_ok = all_degrees_are_two and sum_check\n\n    # Condition 2: No isolated faces\n    no_isolated = (isolated_faces_count == 0)\n\n    # Condition 3: No dangling nodes\n    no_dangling = (dangling_nodes_count == 0)\n\n    # Final result is the conjunction of all three conditions\n    return manifold_ok and no_isolated and no_dangling\n\ndef solve():\n    \"\"\"\n    Runs the connectivity diagnostics on a predefined suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (closed-manifold combinatorial model)\n        (4, [[0,1,2], [0,1,3], [0,2,3], [1,2,3]], [[0,1,2,3], [0,1,2,3]]),\n        \n        # Case 2 (open region with boundary faces)\n        (5, [[0,1,2], [0,1,3], [0,2,3], [1,2,3], [0,1,4], [0,2,4], [1,2,4]], [[0,1,2,3], [0,4,5,6]]),\n\n        # Case 3 (nonmanifold face of degree 3)\n        (6, [[0,1,2], [0,1,3], [0,2,3], [1,2,3], [0,1,4], [0,2,4], [1,2,4], [0,1,5], [0,2,5], [1,2,5]], [[0,1,2,3], [0,4,5,6], [0,7,8,9]]),\n\n        # Case 4 (isolated face present)\n        (5, [[0,1,2], [0,1,3], [0,2,3], [1,2,3], [0,3,4]], [[0,1,2,3], [0,1,2,3]]),\n        \n        # Case 5 (dangling node present)\n        (5, [[0,1,2], [0,1,3], [0,2,3], [1,2,3]], [[0,1,2,3], [0,1,2,3]]),\n    ]\n\n    results = []\n    for case in test_cases:\n        num_nodes, faces_nodes, cells_faces = case\n        result = check_connectivity(num_nodes, faces_nodes, cells_faces)\n        results.append(str(result).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本练习将网格验证提升到一个更高级的层面，即应用拓扑不变量进行检验。著名的 Euler-Poincaré 公式将网格的顶点 $V$、边 $E$ 和面 $F$ 的数量与计算域的全局拓扑结构（例如是否存在孔洞 $h$）联系起来。通过这个练习，你将看到抽象的数学理论如何为验证复杂网格的宏观完整性提供强有力的工具。",
            "id": "3303802",
            "problem": "一个计算流体动力学（CFD）求解器使用非结构化二维三角形网格来离散化一个有界平面域。该求解器通过每个单元的顶点索引列表和一份独立的边界边列表来存储连接关系。考虑一个可能包含内部孔洞的平面域的网格。该网格恰好有 $F = 100$ 个三角形单元（仅计算覆盖该域的有界三角形，不包括无界外部），$V = 68$ 个不同的顶点，且边界边列表包含 $B = 40$ 条不同的边。网格中没有悬挂节点，并且每条边界边都恰好属于一个三角形。\n\n仅从二维单元复形的基本定义、作为0-单元、1-单元和2-单元交错计数的欧拉示性数、欧拉示性数在同胚变换下的拓扑不变性，以及三角剖分中边-面关联的双重计数原理出发，推导出一个将网格实体交錯计数与边界连通分支数量联系起来的拓扑不变量。在每个孔洞除了外部边界之外还额外贡献一个边界连通分支的约定下，使用此不变量计算网格化区域的内部孔洞数量 $h$。\n\n给出 $h$ 的值作为最终答案，它是一个单独的数字。无需四舍五入，不涉及单位。假设采用标准平面拓扑，并且所有网格实体均按所述正确计数。",
            "solution": "该问题要求推导一个将网格实体（顶点、边、面）的数量与平面域中孔洞数量联系起来的拓扑不变量，然后利用该不变量根据给定的网格数据计算孔洞的数量。\n\n推导始于欧拉示性数 $\\chi$ 的概念，这是一个基本的拓扑不变量。对于任何将一个封闭、可定向的二维流形（无边界的曲面）分解为 $V$ 个顶点、$E$ 条边和 $F$ 个面的多面体分解（例如三角剖分），欧拉示性数由以下交错和给出：\n$$ \\chi = V - E + F $$\n最简单的此类曲面是球面 $S^2$，其欧拉示性数为 $\\chi(S^2) = 2$。这可以通过一个简单的多面体（如四面体）来验证，其中 $V=4$，$E=6$，$F=4$，得出 $V-E+F=4-6+4=2$。\n\n问题中描述的网格化区域是一个有界的平面区域，可能包含内部孔洞。在拓扑学上，这样一个区域与一个移除了若干个不相交开圆盘的球面是同胚的。每个被移除的圆盘都会创建一个边界连通分支。设边界连通分支的总数为 $k$。根据问题的约定，有一个外部边界和 $h$ 个内部孔洞，因此边界连通分支的总数是 $k = h+1$。\n\n为了求出这个带边界区域的欧拉示性数，我们可以考虑当我们在一个封闭曲面上“打孔”时 $\\chi$ 如何变化。让我们从一个球面的三角剖分开始，对于它有 $V_s - E_s + F_s = 2$。为了创建一个与我们的区域同胚的曲面，我们从这个三角剖分中移除 $k$ 个不相交的面。构成这 $k$ 个面边界的顶点和边仍然是复形的一部分，但面本身被移除了。复形中新的面数为 $F = F_s - k$。顶点和边的数量保持不变，即 $V=V_s$ 且 $E=E_s$。由此产生的带边界曲面的欧拉示性数 $\\chi_{domain}$ 为：\n$$ \\chi_{domain} = V - E + F = V_s - E_s + (F_s - k) = (V_s - E_s + F_s) - k $$\n代入 $\\chi(S^2) = 2$，我们得到：\n$$ \\chi_{domain} = 2 - k $$\n问题陈述中给出的量 $V$、$E$ 和 $F$ 对应于离散化该区域的三角剖分的顶点、边和面。因此，该网格的交错和 $V-E+F$ 的值必须等于它所代表的区域的欧拉示性数。这提供了普适的不变量：\n$$ V - E + F = 2 - k $$\n现在，我们将其与内部孔洞的数量 $h$ 联系起来。对于 $k = h+1$ 个边界连通分支，该不变量变为：\n$$ V - E + F = 2 - (h+1) = 1 - h $$\n这就是将网格实体的交錯计数与内部孔洞数量联系起来的特定拓扑不变量。\n\n接下来，我们必须计算给定网格的 $V$、$E$ 和 $F$ 的值。问题给出了：\n- 顶点数（0-单元）：$V = 68$。\n- 三角形面数（2-单元）：$F = 100$。\n- 边界边数：$B = 40$。\n\n总边数 $E$ 没有明确给出。为了求出它，我们采用双重计数原理（一个关于面-边邻接关系的握手引理）。计算每个面的边数之和。由于所有单元都是三角形，每个单元有 $3$ 条边。因此，将所有 $F$ 个面的边数相加，得到的总计数为 $3F$。\n在这个求和过程中，每条内部边都恰好被两个面共享，因此被计数两次。根据定义以及问题中的陈述（“每条边界边都恰好属于一个三角形”），每条边界边仅是网格中一个面的一部分，因此被计数一次。\n设 $E_I$ 为内部边的数量，$E_B$ 为边界边的数量。总边数是 $E = E_I + E_B$。双重计数关系表示为：\n$$ 3F = 2E_I + E_B $$\n我们已知 $F=100$ 且 $E_B = B = 40$。将这些值代入方程：\n$$ 3(100) = 2E_I + 40 $$\n$$ 300 = 2E_I + 40 $$\n$$ 2E_I = 300 - 40 = 260 $$\n这得出内部边的数量为 $E_I = 130$。\n网格中的总边数为：\n$$ E = E_I + E_B = 130 + 40 = 170 $$\n现在我们有了推导出的不变量所需的所有量：\n- $V = 68$\n- $E = 170$\n- $F = 100$\n\n我们将这些值代入公式 $V - E + F = 1 - h$ 中：\n$$ 68 - 170 + 100 = 1 - h $$\n计算左侧：\n$$ 168 - 170 = -2 $$\n方程简化为：\n$$ -2 = 1 - h $$\n最后，我们求解 $h$，即内部孔洞的数量：\n$$ h = 1 - (-2) = 1 + 2 = 3 $$\n因此，该网格化区域有 $3$ 个内部孔洞。",
            "answer": "$$\n\\boxed{3}\n$$"
        }
    ]
}