{
    "hands_on_practices": [
        {
            "introduction": "In large-scale computational fluid dynamics, the sheer size of unstructured grids makes memory efficiency a primary concern. A fundamental task is to represent cell-to-vertex connectivity compactly, and the Compressed Sparse Row (CSR) format is a widely adopted standard for this purpose. This practice will develop your ability to analyze the memory footprint of CSR, a critical skill for predicting resource requirements and designing scalable simulations .",
            "id": "3306188",
            "problem": "Consider an unstructured three-dimensional mesh composed of mixed element types, where the mesh connectivity is represented by cell-to-vertex adjacency. The cell-to-vertex arrays store, for each cell, the identifiers of its incident vertices. The connectivity is laid out using Compressed Sparse Row (CSR), where CSR is defined as follows: there are two arrays, a row-pointer array that stores the starting offset of the vertex list for each cell, with exclusive end at the last entry, and a column-index array that stores the concatenated vertex identifiers. The CSR layout is used without any auxiliary padding or per-cell headers.\n\nAssume the following widely accepted facts and definitions:\n- The number of cells is denoted by $N_{c}$, the number of vertices is denoted by $N_{v}$, and the number of connectivity entries is denoted by $N_{e}$, with $N_{e} = \\sum_{i=1}^{N_{c}} k_{i}$, where $k_{i}$ is the number of vertices incident to cell $i$.\n- In CSR, the row-pointer array has length $N_{c}+1$, and the column-index array has length $N_{e}$. The row-pointer values are offsets into the column-index array.\n- One Mebibyte (MiB) is $2^{20}$ bytes.\n\nYou are tasked to do both of the following:\n1. Derive the asymptotic memory cost of the CSR cell-to-vertex connectivity as a function of $N_{c}$ and the element-wise vertex counts, assuming the minimal-width integer types are used to safely address the required ranges, and clearly state the scaling with $N_{c}$ under a fixed mixture of element types.\n2. Compute the actual memory footprint for the following mixed-element mesh, under the design decision that the row-pointer array is stored in $64$-bit signed integers and the column-index array is stored in $32$-bit signed integers. Use the given mesh statistics to determine the required array lengths:\n- Tetrahedra: $13{,}500{,}000$ cells, each with $4$ vertices.\n- Pyramids: $420{,}000$ cells, each with $5$ vertices.\n- Prisms: $720{,}000$ cells, each with $6$ vertices.\n- Hexahedra: $360{,}000$ cells, each with $8$ vertices.\n- Total vertices: $N_{v} = 190{,}000{,}000$.\n\nAssume zero-based indexing, contiguous storage, and no additional metadata beyond the two CSR arrays. For integer widths, use $8$ bytes for $64$-bit values and $4$ bytes for $32$-bit values. Express the final memory footprint in MiB and round your answer to four significant figures. The final answer must be a single real-valued number.",
            "solution": "We begin from the definitions of the cell-to-vertex connectivity and the Compressed Sparse Row (CSR) data structure. In CSR, the connectivity is represented by two arrays:\n- A row-pointer array of length $N_{c}+1$, which stores offsets into the column-index array indicating the start of each cell’s vertex list, with an exclusive terminal pointer at the end.\n- A column-index array of length $N_{e}$, which stores the concatenated vertex identifiers.\n\nBy definition, if cell $i$ has $k_{i}$ incident vertices, then the total number of connectivity entries is\n$$\nN_{e} = \\sum_{i=1}^{N_{c}} k_{i}.\n$$\nThe total memory in bytes for CSR connectivity is therefore\n$$\nM_{\\text{bytes}} = b_{\\mathrm{rp}}(N_{c}+1) + b_{\\mathrm{ci}} N_{e},\n$$\nwhere $b_{\\mathrm{rp}}$ is the number of bytes per entry in the row-pointer array and $b_{\\mathrm{ci}}$ is the number of bytes per entry in the column-index array.\n\nAsymptotic memory cost: Under a fixed mixture of element types, define the average number of vertices per cell as\n$$\n\\bar{k} = \\frac{1}{N_{c}} \\sum_{i=1}^{N_{c}} k_{i}.\n$$\nThen $N_{e} = \\bar{k} N_{c}$, so the total memory becomes\n$$\nM_{\\text{bytes}} = b_{\\mathrm{rp}}(N_{c}+1) + b_{\\mathrm{ci}} \\bar{k} N_{c} = \\left(b_{\\mathrm{ci}} \\bar{k} + b_{\\mathrm{rp}}\\right) N_{c} + b_{\\mathrm{rp}}.\n$$\nFor large $N_{c}$ with fixed mixture (hence fixed $\\bar{k}$ and fixed $b_{\\mathrm{rp}}, b_{\\mathrm{ci}}$), the asymptotic scaling is\n$$\nM_{\\text{bytes}} = \\mathcal{O}(N_{c}).\n$$\n\nNow we compute the actual memory footprint for the specific mesh and integer widths. The mesh statistics are:\n- Tetrahedra: $13{,}500{,}000$ cells, $4$ vertices each.\n- Pyramids: $420{,}000$ cells, $5$ vertices each.\n- Prisms: $720{,}000$ cells, $6$ vertices each.\n- Hexahedra: $360{,}000$ cells, $8$ vertices each.\nThus,\n$$\nN_{c} = 13{,}500{,}000 + 420{,}000 + 720{,}000 + 360{,}000 = 15{,}000{,}000.\n$$\nThe total number of connectivity entries is\n\\begin{align*}\nN_{e} &= 4 \\cdot 13{,}500{,}000 + 5 \\cdot 420{,}000 + 6 \\cdot 720{,}000 + 8 \\cdot 360{,}000 \\\\\n&= 54{,}000{,}000 + 2{,}100{,}000 + 4{,}320{,}000 + 2{,}880{,}000 \\\\\n&= 63{,}300{,}000.\n\\end{align*}\nThe total number of vertices $N_{v} = 190{,}000{,}000$ fits within $32$-bit signed integer range (since $190{,}000{,}000 < 2{,}147{,}483{,}647$), so $32$-bit column indices are adequate. By the design decision, use $64$-bit signed integers for row pointers. Therefore\n$$\nb_{\\mathrm{rp}} = 8, \\quad b_{\\mathrm{ci}} = 4.\n$$\nWe compute the total memory in bytes:\n\\begin{align*}\nM_{\\text{bytes}} &= b_{\\mathrm{rp}}(N_{c}+1) + b_{\\mathrm{ci}} N_{e} \\\\\n&= 8 \\cdot (15{,}000{,}000 + 1) + 4 \\cdot 63{,}300{,}000 \\\\\n&= 8 \\cdot 15{,}000{,}001 + 253{,}200{,}000 \\\\\n&= 120{,}000{,}008 + 253{,}200{,}000 \\\\\n&= 373{,}200{,}008 \\text{ bytes}.\n\\end{align*}\nConvert bytes to Mebibytes (MiB) using $1 \\text{ MiB} = 2^{20} = 1{,}048{,}576$ bytes:\n$$\nM_{\\text{MiB}} = \\frac{373{,}200{,}008}{1{,}048{,}576}.\n$$\nWe now evaluate this quotient. Decomposing,\n\\begin{align*}\n\\frac{120{,}000{,}008}{1{,}048{,}576} &= 114 + \\frac{462{,}344}{1{,}048{,}576} \\approx 114.44097, \\\\\n\\frac{253{,}200{,}000}{1{,}048{,}576} &= 241 + \\frac{493{,}184}{1{,}048{,}576} \\approx 241.47050,\n\\end{align*}\nso\n$$\nM_{\\text{MiB}} \\approx 114.44097 + 241.47050 = 355.91147.\n$$\nRounding to four significant figures yields\n$$\nM_{\\text{MiB}} \\approx 355.9.\n$$\nThis is the requested memory footprint in MiB.",
            "answer": "$$\\boxed{355.9}$$"
        },
        {
            "introduction": "While a unified data structure like CSR is memory-efficient, the optimal design often depends on the computational kernels that access the data. This exercise contrasts the unified CSR approach with an element-type-specific blocked scheme, forcing a critical evaluation of the trade-offs between storage overhead, random access speed, and data locality. Understanding these trade-offs is key to designing high-performance solvers that leverage modern CPU architectures through enhanced cache performance and vectorization .",
            "id": "3306212",
            "problem": "In computational fluid dynamics on unstructured grids, the cell-to-vertex adjacency (denoted $C2V$) for a hybrid mesh can be stored using different data structures. Consider a three-dimensional hybrid unstructured mesh composed of tetrahedra, hexahedra, triangular prisms (also called wedges), and pyramids. Let the cell counts be $N_{\\mathrm{tet}} = 2800000$, $N_{\\mathrm{hex}} = 200000$, $N_{\\mathrm{wedge}} = 120000$, and $N_{\\mathrm{pyr}} = 80000$. The number of vertices per cell is $4$ for a tetrahedron, $8$ for a hexahedron, $6$ for a wedge, and $5$ for a pyramid.\n\nTwo storage schemes for $C2V$ are considered:\n\n- Unified Compressed Sparse Row (CSR) scheme: store a single integer array `idx` of length equal to the total number of vertex references across all cells, and a single integer array `off` of length $N_c + 1$ where $N_c$ is the total number of cells, such that the vertex list of cell $i$ is in $idx[off[i] \\dots off[i+1]-1]$.\n\n- Element-type-specific blocked scheme: for each element type $t \\in \\{\\mathrm{tet, hex, wedge, pyr}\\}$ with fixed arity $k_t$, store a separate flat integer array $idx_t$ of length $k_t N_t$ that concatenates the vertex indices for all cells of that type in a fixed order; to support random access by the original global cell identifier, assume the global cell identifiers are immutable and require storing, for each cell, an auxiliary mapping comprising two integers: a type identifier and the cell’s local index within its type-specific block. Ignore any other metadata or padding; count only the integers explicitly described in this paragraph and in the unified CSR scheme paragraph.\n\nStarting from the definitions of $C2V$, the arities of the element types, and the data-structure descriptions above, derive expressions for the total number of integers required by each scheme, evaluate them for the given mesh, and then compute the exact difference $D$ (in integers) between the element-type-specific blocked scheme and the unified CSR scheme, defined as $D = I_{\\mathrm{blocked}} - I_{\\mathrm{CSR}}$.\n\nAdditionally, explain the fundamental trade-offs between these two schemes in terms of storage overhead, random access, and data locality, justifying your expressions from first principles about how the arrays are indexed and used. Your final reported quantity must be the single integer $D$. No rounding is required and no physical units are to be reported for $D$.",
            "solution": "The problem requires an analysis of two data storage schemes for cell-to-vertex ($C2V$) adjacency information on a hybrid unstructured mesh and the calculation of the difference in their storage costs.\n\nFirst, the given parameters are formally defined:\n- Number of tetrahedra: $N_{\\mathrm{tet}} = 2800000$\n- Number of hexahedra: $N_{\\mathrm{hex}} = 200000$\n- Number of wedges: $N_{\\mathrm{wedge}} = 120000$\n- Number of pyramids: $N_{\\mathrm{pyr}} = 80000$\n\nThe arity (number of vertices per cell) for each element type is:\n- For a tetrahedron: $k_{\\mathrm{tet}} = 4$\n- For a hexahedron: $k_{\\mathrm{hex}} = 8$\n- For a wedge: $k_{\\mathrm{wedge}} = 6$\n- For a pyramid: $k_{\\mathrm{pyr}} = 5$\n\nThe total number of cells in the mesh, $N_c$, is the sum of the counts of each cell type:\n$$N_c = N_{\\mathrm{tet}} + N_{\\mathrm{hex}} + N_{\\mathrm{wedge}} + N_{\\mathrm{pyr}}$$\n\nThe total number of vertex references, which is the sum of the arities over all cells, is:\n$$V_{\\mathrm{refs}} = N_{\\mathrm{tet}} k_{\\mathrm{tet}} + N_{\\mathrm{hex}} k_{\\mathrm{hex}} + N_{\\mathrm{wedge}} k_{\\mathrm{wedge}} + N_{\\mathrm{pyr}} k_{\\mathrm{pyr}}$$\n\nNext, we derive the expression for the total storage in integers for each scheme.\n\n**Scheme 1: Unified Compressed Sparse Row (CSR) Scheme**\nThis scheme consists of two integer arrays: `idx` and `off`.\n1.  The `idx` array stores the concatenated vertex indices for all cells. Its length is equal to the total number of vertex references, $V_{\\mathrm{refs}}$.\n    $$ \\text{Length}(\\text{idx}) = V_{\\mathrm{refs}} $$\n2.  The `off` array stores the starting positions of each cell's vertex list within the `idx` array. For $N_c$ cells, this requires $N_c + 1$ integers to define $N_c$ contiguous intervals.\n    $$ \\text{Length}(\\text{off}) = N_c + 1 $$\n\nThe total number of integers required by the CSR scheme, $I_{\\mathrm{CSR}}$, is the sum of the lengths of these two arrays:\n$$ I_{\\mathrm{CSR}} = \\text{Length}(\\text{idx}) + \\text{Length}(\\text{off}) = V_{\\mathrm{refs}} + (N_c + 1) $$\nSubstituting the expressions for $V_{\\mathrm{refs}}$ and $N_c$:\n$$ I_{\\mathrm{CSR}} = (N_{\\mathrm{tet}} k_{\\mathrm{tet}} + N_{\\mathrm{hex}} k_{\\mathrm{hex}} + N_{\\mathrm{wedge}} k_{\\mathrm{wedge}} + N_{\\mathrm{pyr}} k_{\\mathrm{pyr}}) + (N_{\\mathrm{tet}} + N_{\\mathrm{hex}} + N_{\\mathrm{wedge}} + N_{\\mathrm{pyr}} + 1) $$\n\n**Scheme 2: Element-type-specific Blocked Scheme**\nThis scheme stores vertex indices in separate arrays for each cell type and uses an auxiliary mapping for random access.\n1.  For each element type $t \\in \\{\\mathrm{tet, hex, wedge, pyr}\\}$, there is a flat integer array $idx_t$ of length $k_t N_t$. The total number of integers for these arrays is the sum of their lengths, which is exactly $V_{\\mathrm{refs}}$.\n    $$ \\sum_{t} \\text{Length}(\\text{idx}_t) = N_{\\mathrm{tet}} k_{\\mathrm{tet}} + N_{\\mathrm{hex}} k_{\\mathrm{hex}} + N_{\\mathrm{wedge}} k_{\\mathrm{wedge}} + N_{\\mathrm{pyr}} k_{\\mathrm{pyr}} = V_{\\mathrm{refs}} $$\n2.  An auxiliary mapping is required to find a cell's data from its global identifier. The problem states this mapping requires storing \"for each cell, an auxiliary mapping comprising two integers\". With $N_c$ total cells, the storage cost for this mapping is $2 N_c$.\n    $$ \\text{Storage}(\\text{mapping}) = 2 N_c $$\n\nThe total number of integers required by the blocked scheme, $I_{\\mathrm{blocked}}$, is the sum of these components:\n$$ I_{\\mathrm{blocked}} = V_{\\mathrm{refs}} + 2 N_c $$\nSubstituting the expression for $N_c$:\n$$ I_{\\mathrm{blocked}} = (N_{\\mathrm{tet}} k_{\\mathrm{tet}} + \\ldots) + 2(N_{\\mathrm{tet}} + N_{\\mathrm{hex}} + N_{\\mathrm{wedge}} + N_{\\mathrm{pyr}}) $$\n\n**Calculation of the Difference, $D$**\nThe problem asks for the difference $D = I_{\\mathrm{blocked}} - I_{\\mathrm{CSR}}$.\n$$ D = (V_{\\mathrm{refs}} + 2 N_c) - (V_{\\mathrm{refs}} + N_c + 1) $$\n$$ D = V_{\\mathrm{refs}} + 2 N_c - V_{\\mathrm{refs}} - N_c - 1 $$\n$$ D = N_c - 1 $$\nThis elegant result shows that the difference in storage cost depends only on the total number of cells, not on the mesh composition or cell arities.\n\nNow, we evaluate this expression using the given cell counts.\nFirst, calculate the total number of cells, $N_c$:\n$$ N_c = 2800000 + 200000 + 120000 + 80000 $$\n$$ N_c = 3000000 + 120000 + 80000 = 3120000 + 80000 = 3200000 $$\nNow, compute the difference $D$:\n$$ D = 3200000 - 1 = 3199999 $$\n\n**Trade-offs Between the Schemes**\nThe derived expressions $I_{\\mathrm{CSR}} = V_{\\mathrm{refs}} + N_c + 1$ and $I_{\\mathrm{blocked}} = V_{\\mathrm{refs}} + 2 N_c$ form the basis for analyzing the trade-offs.\n\n1.  **Storage Overhead**: The primary storage for vertex indices, $V_{\\mathrm{refs}}$, is identical in both schemes. The difference lies in the metadata. The CSR scheme uses an offset array, costing $N_c+1$ integers. The blocked scheme uses an auxiliary lookup map, costing $2 N_c$ integers. As calculated, $D = N_c - 1 > 0$, meaning the blocked scheme requires $N_c - 1$ more integers than the CSR scheme. The overhead per cell is approximately $1$ integer for CSR versus $2$ for the blocked scheme.\n\n2.  **Random Access**: To access the vertices of an arbitrary cell $i$ given its global index:\n    -   In the CSR scheme, one needs two memory reads from the `off` array (`off[i]` and `off[i+1]`) to determine the slice of the `idx` array containing the vertex data. This is extremely efficient.\n    -   In the blocked scheme, one must first read the two-integer auxiliary map for cell $i$ to get its type $t$ and its local index $j$ within that type block. Then, based on type $t$, the correct array $idx_t$ is chosen, and the vertices are located at a position calculated from $j$ (e.g., starting at $j \\times k_t$). This involves an extra level of indirection and typically a conditional branch (or function pointer) to handle the different types, which may be slightly slower than the direct CSR lookup.\n\n3.  **Data Locality and Traversal**: This is where the blocked scheme offers a significant advantage.\n    -   In the CSR scheme, if cells are not ordered by type, iterating through the mesh means the accesses into the large, unified `idx` array can be non-sequential, leading to poor cache locality. For example, processing a tetrahedron followed by a hexahedron would cause a jump in memory access within `idx`.\n    -   In the blocked scheme, processing is often done one element type at a time (e.g., in a finite element solver, one integration kernel is run for all tetrahedra, then another for all hexahedra). In this common use case, the code iterates through a type-specific array like `idx_tet`. This array is a dense, contiguous block of memory containing only data for tetrahedra. This access pattern is highly sequential, leading to excellent cache performance and prefetching. Furthermore, because all elements in the block have the same fixed arity $k_t$, the loop structure is simple and regular, which is highly amenable to compiler optimization and Single Instruction, Multiple Data (SIMD) vectorization. The CSR scheme, with its variable arity from one cell to the next, complicates or prevents such vectorization.\n\nIn summary, CSR is more memory-efficient and offers slightly faster generic random access. The blocked scheme incurs a storage penalty but provides superior data locality and performance for type-based traversals, which is a critical access pattern in many computational solvers.\nThe final numerical answer required is the value of $D$.",
            "answer": "$$\\boxed{3199999}$$"
        },
        {
            "introduction": "Data structures are not an end in themselves; they serve to enable the core computations of a numerical method. This final practice connects the abstract representation of a mesh to the concrete geometric calculations required by a finite volume solver. By computing oriented face areas and handling flux assembly across a shared face, you will engage with the geometric foundations that ensure a numerical scheme is conservative and accurate .",
            "id": "3306181",
            "problem": "Consider an unstructured grid used in Computational Fluid Dynamics (CFD). A tetrahedral cell $\\mathcal{T}_0$ has vertices ordered as $(v_0, v_1, v_2, v_3)$ with coordinates $\\mathbf{x}_{v_0} = (0,0,0)$, $\\mathbf{x}_{v_1} = (1,0,0)$, $\\mathbf{x}_{v_2} = (0,2,0)$, and $\\mathbf{x}_{v_3} = (0,0,3)$, all in meters. In this context, the oriented face area vector $\\mathbf{A}_f$ of a triangular face with local vertex ordering $(a,b,c)$ is defined by the right-hand rule as\n$$\n\\mathbf{A}_f = \\frac{1}{2}\\left((\\mathbf{x}_b - \\mathbf{x}_a) \\times (\\mathbf{x}_c - \\mathbf{x}_a)\\right),\n$$\nwhich, when correctly ordered, points outward from the cell. The four faces of $\\mathcal{T}_0$ are stored locally with the following vertex orderings:\n- Face $f_0$ opposite $v_0$: $(v_1, v_2, v_3)$,\n- Face $f_1$ opposite $v_1$: $(v_0, v_2, v_3)$,\n- Face $f_2$ opposite $v_2$: $(v_0, v_1, v_3)$,\n- Face $f_3$ opposite $v_3$: $(v_0, v_2, v_1)$.\n\nA neighboring tetrahedral cell $\\mathcal{T}_1$ shares the face $f_0$ and has vertices $(v_1, v_2, v_3, v_4)$ with $\\mathbf{x}_{v_4} = (1,2,3)$ in meters. In $\\mathcal{T}_1$, the shared face $f_0$ is stored with local vertex ordering $(v_3, v_2, v_1)$. In finite-volume assembly across internal faces, consistency requires that per-cell face flux contributions be combined with a sign $s \\in \\{+1,-1\\}$ that maps each cell’s local face orientation to a unique global face orientation.\n\nTasks:\n1. Compute the outward-directed oriented face area vectors $\\mathbf{A}_{f_0}, \\mathbf{A}_{f_1}, \\mathbf{A}_{f_2}, \\mathbf{A}_{f_3}$ for $\\mathcal{T}_0$, correcting the sign of any locally stored face whose orientation points inward by testing against the opposite vertex.\n2. Determine the sign corrections $s_0$ and $s_1$ required to assemble fluxes consistently on the shared face $f_0$ from $\\mathcal{T}_0$ and $\\mathcal{T}_1$, respectively, when the unique global orientation for $f_0$ is chosen to be $(v_1, v_2, v_3)$.\n3. Using the Divergence Theorem and a suitable choice of vector field, express the volume of $\\mathcal{T}_0$ as a surface flux of that field over the oriented faces and evaluate it exactly using the oriented face area vectors and face centroids.\n\nExpress the final volume in cubic meters (m$^3$). No rounding is required; provide the exact value as a single real number.",
            "solution": "The problem requires performing three tasks related to a tetrahedral cell in an unstructured grid: computing its outward-directed face area vectors, determining sign corrections for flux assembly on a shared face, and calculating the cell's volume using the Divergence Theorem.\n\nThe vertices of the tetrahedron $\\mathcal{T}_0$ are given by their coordinate vectors:\n$\\mathbf{x}_{v_0} = (0,0,0)$\n$\\mathbf{x}_{v_1} = (1,0,0)$\n$\\mathbf{x}_{v_2} = (0,2,0)$\n$\\mathbf{x}_{v_3} = (0,0,3)$\n\nThe oriented face area vector $\\mathbf{A}_f$ is defined as $\\mathbf{A}_f = \\frac{1}{2}((\\mathbf{x}_b - \\mathbf{x}_a) \\times (\\mathbf{x}_c - \\mathbf{x}_a))$ for a face with local vertex ordering $(a,b,c)$.\n\n### Task 1: Outward-Directed Oriented Face Area Vectors for $\\mathcal{T}_0$\n\nFor each face, we first compute a temporary area vector $\\mathbf{A}'_f$ based on the given local vertex ordering. We then determine if this vector points outward or inward. An outward-pointing vector is required. To check the orientation, we form a vector $\\mathbf{d}$ from a vertex on the face to the vertex opposite the face (e.g., $\\mathbf{d} = \\mathbf{x}_{v_{opp}} - \\mathbf{x}_a$). This vector $\\mathbf{d}$ points from the face into the interior of the cell. An outward-pointing normal vector $\\mathbf{A}_{f}$ must form an angle greater than $90^\\circ$ with $\\mathbf{d}$, which means their dot product must be negative ($\\mathbf{A}_{f} \\cdot \\mathbf{d} < 0$).\n- If $\\mathbf{A}'_f \\cdot \\mathbf{d} < 0$, $\\mathbf{A}'_f$ is already pointing outward, so $\\mathbf{A}_f = \\mathbf{A}'_f$.\n- If $\\mathbf{A}'_f \\cdot \\mathbf{d} > 0$, $\\mathbf{A}'_f$ is pointing inward, so we must reverse its direction: $\\mathbf{A}_f = -\\mathbf{A}'_f$.\n\n**Face $f_0$**: ordering $(v_1, v_2, v_3)$, opposite vertex $v_0$.\n- $\\mathbf{x}_{v_2} - \\mathbf{x}_{v_1} = (0-1, 2-0, 0-0) = (-1, 2, 0)$.\n- $\\mathbf{x}_{v_3} - \\mathbf{x}_{v_1} = (0-1, 0-0, 3-0) = (-1, 0, 3)$.\n- $\\mathbf{A}'_{f_0} = \\frac{1}{2} \\left( (-1, 2, 0) \\times (-1, 0, 3) \\right) = \\frac{1}{2}(6, 3, 2) = (3, \\frac{3}{2}, 1)$.\n- Orientation check with $\\mathbf{d} = \\mathbf{x}_{v_0} - \\mathbf{x}_{v_1} = (-1, 0, 0)$.\n- $\\mathbf{A}'_{f_0} \\cdot \\mathbf{d} = (3, \\frac{3}{2}, 1) \\cdot (-1, 0, 0) = -3$. Since the dot product is negative, $\\mathbf{A}'_{f_0}$ points outward.\n- $\\mathbf{A}_{f_0} = (3, \\frac{3}{2}, 1)$.\n\n**Face $f_1$**: ordering $(v_0, v_2, v_3)$, opposite vertex $v_1$.\n- $\\mathbf{x}_{v_2} - \\mathbf{x}_{v_0} = (0, 2, 0)$.\n- $\\mathbf{x}_{v_3} - \\mathbf{x}_{v_0} = (0, 0, 3)$.\n- $\\mathbf{A}'_{f_1} = \\frac{1}{2} \\left( (0, 2, 0) \\times (0, 0, 3) \\right) = \\frac{1}{2}(6, 0, 0) = (3, 0, 0)$.\n- Orientation check with $\\mathbf{d} = \\mathbf{x}_{v_1} - \\mathbf{x}_{v_0} = (1, 0, 0)$.\n- $\\mathbf{A}'_{f_1} \\cdot \\mathbf{d} = (3, 0, 0) \\cdot (1, 0, 0) = 3$. Since the dot product is positive, $\\mathbf{A}'_{f_1}$ points inward.\n- $\\mathbf{A}_{f_1} = -(3, 0, 0) = (-3, 0, 0)$.\n\n**Face $f_2$**: ordering $(v_0, v_1, v_3)$, opposite vertex $v_2$.\n- $\\mathbf{x}_{v_1} - \\mathbf{x}_{v_0} = (1, 0, 0)$.\n- $\\mathbf{x}_{v_3} - \\mathbf{x}_{v_0} = (0, 0, 3)$.\n- $\\mathbf{A}'_{f_2} = \\frac{1}{2} \\left( (1, 0, 0) \\times (0, 0, 3) \\right) = \\frac{1}{2}(0, -3, 0) = (0, -\\frac{3}{2}, 0)$.\n- Orientation check with $\\mathbf{d} = \\mathbf{x}_{v_2} - \\mathbf{x}_{v_0} = (0, 2, 0)$.\n- $\\mathbf{A}'_{f_2} \\cdot \\mathbf{d} = (0, -\\frac{3}{2}, 0) \\cdot (0, 2, 0) = -3$. Since the dot product is negative, $\\mathbf{A}'_{f_2}$ points outward.\n- $\\mathbf{A}_{f_2} = (0, -\\frac{3}{2}, 0)$.\n\n**Face $f_3$**: ordering $(v_0, v_2, v_1)$, opposite vertex $v_3$.\n- $\\mathbf{x}_{v_2} - \\mathbf{x}_{v_0} = (0, 2, 0)$.\n- $\\mathbf{x}_{v_1} - \\mathbf{x}_{v_0} = (1, 0, 0)$.\n- $\\mathbf{A}'_{f_3} = \\frac{1}{2} \\left( (0, 2, 0) \\times (1, 0, 0) \\right) = \\frac{1}{2}(0, 0, -2) = (0, 0, -1)$.\n- Orientation check with $\\mathbf{d} = \\mathbf{x}_{v_3} - \\mathbf{x}_{v_0} = (0, 0, 3)$.\n- $\\mathbf{A}'_{f_3} \\cdot \\mathbf{d} = (0, 0, -1) \\cdot (0, 0, 3) = -3$. Since the dot product is negative, $\\mathbf{A}'_{f_3}$ points outward.\n- $\\mathbf{A}_{f_3} = (0, 0, -1)$.\n\nFor a closed cell, the sum of outward-directed area vectors must be zero:\n$\\sum_{i=0}^3 \\mathbf{A}_{f_i} = (3, \\frac{3}{2}, 1) + (-3, 0, 0) + (0, -\\frac{3}{2}, 0) + (0, 0, -1) = (0, 0, 0)$. This confirms the correctness of the vectors.\n\n### Task 2: Sign Corrections for Flux Assembly\nThe global orientation for face $f_0$ is given by the vertex ordering $(v_1, v_2, v_3)$. The corresponding global area vector is:\n$\\mathbf{A}_{f_0, \\text{global}} = \\frac{1}{2}((\\mathbf{x}_{v_2}-\\mathbf{x}_{v_1})\\times(\\mathbf{x}_{v_3}-\\mathbf{x}_{v_1})) = (3, \\frac{3}{2}, 1)$.\n\nThe sign $s_0$ for cell $\\mathcal{T}_0$ maps the global orientation to the cell's local outward orientation: $s_0 \\mathbf{A}_{f_0, \\text{global}} = \\mathbf{A}_{f_0}$.\n- For $\\mathcal{T}_0$, the outward vector is $\\mathbf{A}_{f_0} = (3, \\frac{3}{2}, 1)$.\n- $s_0 (3, \\frac{3}{2}, 1) = (3, \\frac{3}{2}, 1) \\implies s_0 = 1$.\n\nThe sign $s_1$ for cell $\\mathcal{T}_1$ maps the global orientation to cell $\\mathcal{T}_1$'s local outward orientation for the shared face, $\\mathbf{A}_{f_0, \\mathcal{T}_1}$.\n- In $\\mathcal{T}_1$, face $f_0$ has ordering $(v_3, v_2, v_1)$. The temporary vector is $\\mathbf{A}'_{f_0, \\mathcal{T}_1} = \\frac{1}{2}((\\mathbf{x}_{v_2}-\\mathbf{x}_{v_3})\\times(\\mathbf{x}_{v_1}-\\mathbf{x}_{v_3})) = \\frac{1}{2}((0,2,-3)\\times(1,0,-3)) = \\frac{1}{2}(-6, -3, -2) = (-3, -\\frac{3}{2}, -1)$.\n- The opposite vertex in $\\mathcal{T}_1$ is $v_4$, with $\\mathbf{x}_{v_4}=(1,2,3)$. The orientation check vector is $\\mathbf{d}_1=\\mathbf{x}_{v_4}-\\mathbf{x}_{v_3}=(1,2,0)$.\n- $\\mathbf{A}'_{f_0, \\mathcal{T}_1} \\cdot \\mathbf{d}_1 = (-3, -\\frac{3}{2}, -1) \\cdot (1,2,0) = -3 - 3 = -6$. The dot product is negative, so $\\mathbf{A}'_{f_0, \\mathcal{T}_1}$ is outward for $\\mathcal{T}_1$.\n- The outward-directed vector for $f_0$ on $\\mathcal{T}_1$ is $\\mathbf{A}_{f_0, \\mathcal{T}_1} = (-3, -\\frac{3}{2}, -1)$.\n- The sign $s_1$ is found from $s_1 \\mathbf{A}_{f_0, \\text{global}} = \\mathbf{A}_{f_0, \\mathcal{T}_1}$.\n- $s_1 (3, \\frac{3}{2}, 1) = (-3, -\\frac{3}{2}, -1) \\implies s_1 = -1$.\n\nThus, the sign corrections are $s_0 = 1$ and $s_1 = -1$.\n\n### Task 3: Volume of $\\mathcal{T}_0$ using the Divergence Theorem\nThe Divergence Theorem states that $\\int_V (\\nabla \\cdot \\mathbf{F}) dV = \\oint_{\\partial V} \\mathbf{F} \\cdot d\\mathbf{S}$. To compute the volume $V = \\int_V 1\\,dV$, we choose a vector field $\\mathbf{F}$ such that its divergence is unity, $\\nabla \\cdot \\mathbf{F} = 1$. A convenient choice is $\\mathbf{F}(\\mathbf{x}) = \\frac{1}{3}\\mathbf{x} = \\frac{1}{3}(x, y, z)$, for which $\\nabla \\cdot \\mathbf{F} = \\frac{1}{3} + \\frac{1}{3} + \\frac{1}{3} = 1$.\n\nThe volume is then given by the surface integral over the boundary $\\partial\\mathcal{T}_0$:\n$$V_{\\mathcal{T}_0} = \\oint_{\\partial\\mathcal{T}_0} \\mathbf{F} \\cdot d\\mathbf{S} = \\sum_{i=0}^{3} \\int_{f_i} \\mathbf{F} \\cdot d\\mathbf{S}_i$$\nSince $\\mathbf{F}$ is a linear function and each face is planar, the face integral is exactly evaluated by taking the value of $\\mathbf{F}$ at the face centroid $\\mathbf{x}_{c,i}$ and dotting it with the total face area vector $\\mathbf{A}_{f_i}$:\n$$V_{\\mathcal{T}_0} = \\sum_{i=0}^{3} \\mathbf{F}(\\mathbf{x}_{c,i}) \\cdot \\mathbf{A}_{f_i} = \\sum_{i=0}^{3} \\left(\\frac{1}{3}\\mathbf{x}_{c,i}\\right) \\cdot \\mathbf{A}_{f_i} = \\frac{1}{3} \\sum_{i=0}^{3} (\\mathbf{x}_{c,i} \\cdot \\mathbf{A}_{f_i})$$\nThe centroid of a triangular face with vertices $v_a, v_b, v_c$ is $\\mathbf{x}_c = \\frac{1}{3}(\\mathbf{x}_{v_a} + \\mathbf{x}_{v_b} + \\mathbf{x}_{v_c})$.\n\n- **Face $f_0$** (vertices $v_1, v_2, v_3$):\n  $\\mathbf{x}_{c,0} = \\frac{1}{3}(\\mathbf{x}_{v_1} + \\mathbf{x}_{v_2} + \\mathbf{x}_{v_3}) = \\frac{1}{3}((1,0,0) + (0,2,0) + (0,0,3)) = \\frac{1}{3}(1,2,3)$.\n  $\\mathbf{x}_{c,0} \\cdot \\mathbf{A}_{f_0} = \\frac{1}{3}(1,2,3) \\cdot (3, \\frac{3}{2}, 1) = \\frac{1}{3}(3 + 3 + 3) = \\frac{9}{3} = 3$.\n\n- **Face $f_1$** (vertices $v_0, v_2, v_3$): This face lies in the $x=0$ plane.\n  $\\mathbf{x}_{c,1} = \\frac{1}{3}(\\mathbf{x}_{v_0} + \\mathbf{x}_{v_2} + \\mathbf{x}_{v_3}) = \\frac{1}{3}(0,2,3)$.\n  $\\mathbf{x}_{c,1} \\cdot \\mathbf{A}_{f_1} = \\frac{1}{3}(0,2,3) \\cdot (-3,0,0) = 0$.\n\n- **Face $f_2$** (vertices $v_0, v_1, v_3$): This face lies in the $y=0$ plane.\n  $\\mathbf{x}_{c,2} = \\frac{1}{3}(\\mathbf{x}_{v_0} + \\mathbf{x}_{v_1} + \\mathbf{x}_{v_3}) = \\frac{1}{3}(1,0,3)$.\n  $\\mathbf{x}_{c,2} \\cdot \\mathbf{A}_{f_2} = \\frac{1}{3}(1,0,3) \\cdot (0, -\\frac{3}{2}, 0) = 0$.\n\n- **Face $f_3$** (vertices $v_0, v_2, v_1$): This face lies in the $z=0$ plane.\n  $\\mathbf{x}_{c,3} = \\frac{1}{3}(\\mathbf{x}_{v_0} + \\mathbf{x}_{v_2} + \\mathbf{x}_{v_1}) = \\frac{1}{3}(1,2,0)$.\n  $\\mathbf{x}_{c,3} \\cdot \\mathbf{A}_{f_3} = \\frac{1}{3}(1,2,0) \\cdot (0,0,-1) = 0$.\n\nThe sum of the dot products is $\\sum_{i=0}^{3} (\\mathbf{x}_{c,i} \\cdot \\mathbf{A}_{f_i}) = 3 + 0 + 0 + 0 = 3$.\nFinally, the volume of the tetrahedron is:\n$$V_{\\mathcal{T}_0} = \\frac{1}{3}(3) = 1$$\nThe volume is $1$ cubic meter. This value is confirmed by the standard formula for the volume of a tetrahedron with one vertex at the origin: $V = \\frac{1}{6}|(\\mathbf{x}_{v_1}-\\mathbf{x}_{v_0}) \\cdot ((\\mathbf{x}_{v_2}-\\mathbf{x}_{v_0})\\times(\\mathbf{x}_{v_3}-\\mathbf{x}_{v_0}))| = \\frac{1}{6}|(1,0,0) \\cdot ((0,2,0)\\times(0,0,3))| = \\frac{1}{6}|(1,0,0)\\cdot(6,0,0)| = \\frac{6}{6} = 1$.",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}