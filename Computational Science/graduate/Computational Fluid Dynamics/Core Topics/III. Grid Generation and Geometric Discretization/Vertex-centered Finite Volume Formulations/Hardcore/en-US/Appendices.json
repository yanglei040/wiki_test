{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any finite volume method is the control volume itself, and in a vertex-centered scheme, these volumes are constructed on a mesh that is \"dual\" to the primary grid. This first practice explores the fundamental geometric construction of a circumcentric dual mesh, where control volume boundaries are defined by the circumcenters of the primary mesh cells. By directly calculating the properties of a dual-volume interface, you will gain a concrete understanding of how the primary mesh geometry dictates the discrete surfaces across which physical fluxes are computed .",
            "id": "3387918",
            "problem": "Consider two adjacent triangles in the plane that share the edge $e$ with endpoints $\\boldsymbol{A}=(0,0)$ and $\\boldsymbol{B}=(3,1)$. The first triangle is $T_1=\\triangle(\\boldsymbol{A},\\boldsymbol{B},\\boldsymbol{V}_1)$ with $\\boldsymbol{V}_1=(1,-2)$ and the second triangle is $T_2=\\triangle(\\boldsymbol{A},\\boldsymbol{B},\\boldsymbol{V}_2)$ with $\\boldsymbol{V}_2=(2,3)$. In a vertex-centered finite volume method built from the circumcentric dual (Voronoi dual) of a simplicial mesh, the control-volume interface associated with the primal edge $e$ is the straight segment connecting the circumcenters of $T_1$ and $T_2$, and this interface is orthogonal to $e$. In two spatial dimensions, the flux of any vector field across this interface is evaluated by projecting the flux onto a chosen unit normal to $e$ and multiplying by the interface measure.\n\nUsing only fundamental geometric constructions and definitions consistent with conservation laws and flux projection, do the following:\n- Compute the length of the dual segment (the distance between the circumcenters of $T_1$ and $T_2$), which is orthogonal to $e$.\n- Define the unit normal to $e$ by first forming the unit tangent $\\hat{\\boldsymbol{t}}$ in the direction from $\\boldsymbol{A}$ to $\\boldsymbol{B}$ and then rotating it by $+90^\\circ$ in the plane to obtain $\\boldsymbol{n}_e$. With this convention, compute the scalar projected area used to evaluate the flux across the vertex-centered interface, defined as the scalar projection of the dual segment onto $\\boldsymbol{n}_e$.\n\nProvide both quantities as exact simplified expressions. Express lengths in meters. Report your final answer as a row matrix containing first the dual-segment length and then the scalar projected area, in that order. No rounding is required, and no units should be included in the final boxed answer.",
            "solution": "The problem asks for two quantities related to the vertex-centered finite volume dual mesh construction for two adjacent triangles, $T_1$ and $T_2$. The first quantity is the length of the dual edge connecting the circumcenters of $T_1$ and $T_2$. The second is the scalar projection of this dual edge vector onto a specific normal vector associated with the shared primal edge $e$.\n\nThe vertices of the triangles are given as $\\boldsymbol{A}=(0,0)$, $\\boldsymbol{B}=(3,1)$, $\\boldsymbol{V}_1=(1,-2)$, and $\\boldsymbol{V}_2=(2,3)$. The triangles are $T_1=\\triangle(\\boldsymbol{A},\\boldsymbol{B},\\boldsymbol{V}_1)$ and $T_2=\\triangle(\\boldsymbol{A},\\boldsymbol{B},\\boldsymbol{V}_2)$.\n\nFirst, we compute the circumcenters of $T_1$ and $T_2$. The circumcenter of a triangle is the intersection of the perpendicular bisectors of its sides.\n\nLet $\\boldsymbol{C}_1=(x,y)$ be the circumcenter of $T_1$. $\\boldsymbol{C}_1$ must be equidistant from $\\boldsymbol{A}$, $\\boldsymbol{B}$, and $\\boldsymbol{V}_1$.\nThe equation of the perpendicular bisector of the segment $\\boldsymbol{AB}$ is derived from the condition that any point on it is equidistant from $\\boldsymbol{A}$ and $\\boldsymbol{B}$.\n$|\\boldsymbol{C}_1 - \\boldsymbol{A}|^2 = |\\boldsymbol{C}_1 - \\boldsymbol{B}|^2$\n$x^2 + y^2 = (x-3)^2 + (y-1)^2$\n$x^2 + y^2 = x^2 - 6x + 9 + y^2 - 2y + 1$\n$0 = -6x - 2y + 10$, which simplifies to $3x + y = 5$.\n\nThe equation of the perpendicular bisector of the segment $\\boldsymbol{AV}_1$ is derived similarly.\n$|\\boldsymbol{C}_1 - \\boldsymbol{A}|^2 = |\\boldsymbol{C}_1 - \\boldsymbol{V}_1|^2$\n$x^2 + y^2 = (x-1)^2 + (y-(-2))^2$\n$x^2 + y^2 = x^2 - 2x + 1 + y^2 + 4y + 4$\n$0 = -2x + 4y + 5$, which can be written as $2x - 4y = 5$.\n\nNow we solve the system of linear equations for $(x,y)$:\n1. $y = 5 - 3x$\n2. $2x - 4y = 5$\n\nSubstituting the first equation into the second:\n$2x - 4(5 - 3x) = 5$\n$2x - 20 + 12x = 5$\n$14x = 25 \\implies x = \\frac{25}{14}$\nThen, $y = 5 - 3\\left(\\frac{25}{14}\\right) = \\frac{70}{14} - \\frac{75}{14} = -\\frac{5}{14}$.\nSo, the circumcenter of $T_1$ is $\\boldsymbol{C}_1 = \\left(\\frac{25}{14}, -\\frac{5}{14}\\right)$.\n\nNext, let $\\boldsymbol{C}_2=(x,y)$ be the circumcenter of $T_2$. It lies on the perpendicular bisector of $\\boldsymbol{AB}$, which is $3x+y=5$. We also need the perpendicular bisector of $\\boldsymbol{AV}_2$.\n$|\\boldsymbol{C}_2 - \\boldsymbol{A}|^2 = |\\boldsymbol{C}_2 - \\boldsymbol{V}_2|^2$\n$x^2 + y^2 = (x-2)^2 + (y-3)^2$\n$x^2 + y^2 = x^2 - 4x + 4 + y^2 - 6y + 9$\n$0 = -4x - 6y + 13$, which gives $4x + 6y = 13$.\n\nNow we solve the system for $\\boldsymbol{C}_2$:\n1. $y = 5 - 3x$\n2. $4x + 6y = 13$\n\nSubstituting the first equation into the second:\n$4x + 6(5 - 3x) = 13$\n$4x + 30 - 18x = 13$\n$-14x = -17 \\implies x = \\frac{17}{14}$\nThen, $y = 5 - 3\\left(\\frac{17}{14}\\right) = \\frac{70}{14} - \\frac{51}{14} = \\frac{19}{14}$.\nSo, the circumcenter of $T_2$ is $\\boldsymbol{C}_2 = \\left(\\frac{17}{14}, \\frac{19}{14}\\right)$.\n\nThe first quantity to compute is the length of the dual segment connecting $\\boldsymbol{C}_1$ and $\\boldsymbol{C}_2$. First, we find the vector for this segment:\n$\\vec{\\boldsymbol{S}}_{dual} = \\boldsymbol{C}_2 - \\boldsymbol{C}_1 = \\left(\\frac{17}{14} - \\frac{25}{14}, \\frac{19}{14} - \\left(-\\frac{5}{14}\\right)\\right) = \\left(-\\frac{8}{14}, \\frac{24}{14}\\right) = \\left(-\\frac{4}{7}, \\frac{12}{7}\\right)$.\n\nThe length of this dual segment is its magnitude:\n$L_{dual} = |\\vec{\\boldsymbol{S}}_{dual}| = \\sqrt{\\left(-\\frac{4}{7}\\right)^2 + \\left(\\frac{12}{7}\\right)^2} = \\sqrt{\\frac{16}{49} + \\frac{144}{49}} = \\sqrt{\\frac{160}{49}} = \\frac{\\sqrt{16 \\times 10}}{\\sqrt{49}} = \\frac{4\\sqrt{10}}{7}$.\nThe problem states lengths are in meters, so the length is $\\frac{4\\sqrt{10}}{7}$ meters.\n\nThe second quantity is the scalar projected area, defined as the scalar projection of the dual segment vector $\\vec{\\boldsymbol{S}}_{dual}$ onto the unit normal $\\boldsymbol{n}_e$. We must first construct $\\boldsymbol{n}_e$.\nThe primal edge vector is $\\vec{\\boldsymbol{e}} = \\boldsymbol{B} - \\boldsymbol{A} = (3,1) - (0,0) = (3,1)$.\nThe unit tangent vector $\\hat{\\boldsymbol{t}}$ in the direction from $\\boldsymbol{A}$ to $\\boldsymbol{B}$ is:\n$\\hat{\\boldsymbol{t}} = \\frac{\\vec{\\boldsymbol{e}}}{|\\vec{\\boldsymbol{e}}|} = \\frac{(3,1)}{\\sqrt{3^2 + 1^2}} = \\frac{(3,1)}{\\sqrt{10}} = \\left(\\frac{3}{\\sqrt{10}}, \\frac{1}{\\sqrt{10}}\\right)$.\n\nThe unit normal $\\boldsymbol{n}_e$ is obtained by rotating $\\hat{\\boldsymbol{t}}$ by $+90^\\circ$. A point $(x,y)$ rotated by $+90^\\circ$ becomes $(-y,x)$.\n$\\boldsymbol{n}_e = \\left(-\\frac{1}{\\sqrt{10}}, \\frac{3}{\\sqrt{10}}\\right)$.\n\nThe scalar projected area is the dot product of $\\vec{\\boldsymbol{S}}_{dual}$ and $\\boldsymbol{n}_e$:\n$A_{proj} = \\vec{\\boldsymbol{S}}_{dual} \\cdot \\boldsymbol{n}_e = \\left(-\\frac{4}{7}, \\frac{12}{7}\\right) \\cdot \\left(-\\frac{1}{\\sqrt{10}}, \\frac{3}{\\sqrt{10}}\\right)$\n$A_{proj} = \\left(-\\frac{4}{7}\\right)\\left(-\\frac{1}{\\sqrt{10}}\\right) + \\left(\\frac{12}{7}\\right)\\left(\\frac{3}{\\sqrt{10}}\\right) = \\frac{4}{7\\sqrt{10}} + \\frac{36}{7\\sqrt{10}} = \\frac{40}{7\\sqrt{10}}$.\n\nTo simplify, we rationalize the denominator:\n$A_{proj} = \\frac{40\\sqrt{10}}{7(\\sqrt{10})^2} = \\frac{40\\sqrt{10}}{70} = \\frac{4\\sqrt{10}}{7}$.\nThe scalar projected area is $\\frac{4\\sqrt{10}}{7}$ square meters.\n\nThis result is identical to the dual segment length. This is expected because the dual segment connecting circumcenters is orthogonal to the shared primal edge $e$, and the vector $\\boldsymbol{n}_e$ is also constructed to be orthogonal to $e$. In a 2D plane, two vectors orthogonal to the same line must be parallel (or anti-parallel). In this case, $\\vec{\\boldsymbol{S}}_{dual} = \\left(-\\frac{4}{7}, \\frac{12}{7}\\right) = \\frac{4\\sqrt{10}}{7} \\left(-\\frac{1}{\\sqrt{10}}, \\frac{3}{\\sqrt{10}}\\right) = \\frac{4\\sqrt{10}}{7} \\boldsymbol{n}_e$. Since $\\vec{\\boldsymbol{S}}_{dual}$ is parallel to the unit vector $\\boldsymbol{n}_e$, its scalar projection onto $\\boldsymbol{n}_e$ is simply its own length.\n\nThe two requested quantities are the dual-segment length and the scalar projected area.\nLength = $\\frac{4\\sqrt{10}}{7}$.\nScalar projected area = $\\frac{4\\sqrt{10}}{7}$.",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{4\\sqrt{10}}{7}  \\frac{4\\sqrt{10}}{7} \\end{pmatrix}}$$"
        },
        {
            "introduction": "Once control volumes are defined, the next step is to discretize a governing partial differential equation (PDE). This practice guides you through the implementation of a first-order upwind scheme for the linear advection equation, the simplest model for physical transport, on a vertex-centered grid. You will translate the integral conservation law into a concrete update formula and write code to march the solution forward in time, reinforcing the concepts of numerical flux and the critical requirement of numerical stability governed by the Courant-Friedrichs-Lewy (CFL) condition .",
            "id": "3387973",
            "problem": "Consider the linear advection equation in conservation form for a scalar field $u$,\n$$\n\\partial_t u + \\nabla \\cdot (\\boldsymbol{a}\\,u) = 0,\n$$\nwith constant advection velocity $\\boldsymbol{a} = (1,0)$ on a two-dimensional periodic domain $\\Omega = [0,L_x)\\times[0,L_y)$. Use a vertex-centered Finite Volume Method (FVM) on a uniform Cartesian mesh with $N_x$ vertices in the $x$-direction and $N_y$ vertices in the $y$-direction. The vertex-centered dual control volume around each interior vertex is the rectangle whose corners are the centers of the four surrounding primal cells. Denote the uniform spacings by $h_x = L_x/N_x$ and $h_y = L_y/N_y$, so that the dual volume area is $V_P = h_x h_y$ and the dual face lengths are $h_y$ for east and west faces, and $h_x$ for north and south faces. Because $\\boldsymbol{a}=(1,0)$, only the east and west faces contribute to fluxes.\n\nStarting from the integral conservation law over a dual control volume and using explicit forward Euler time integration with first-order upwind numerical fluxes, implement one explicit time step for $u$ from time level $t^n$ to $t^{n+1} = t^n + \\Delta t$ on the vertex-centered dual mesh. Use periodic boundary conditions in both directions. The initial profile is\n$$\nu_0(x,y) = \\exp\\!\\Bigg(-\\frac{(x - x_c)^2 + (y - y_c)^2}{\\sigma^2}\\Bigg) + \\beta\\,\\sin(2\\pi x)\\,\\cos(2\\pi y),\n$$\nwith parameters $x_c = 0.25$, $y_c = 0.5$, $\\sigma = 0.15$, and $\\beta = 0.25$. Angles in trigonometric functions must be interpreted in radians. All quantities are dimensionless.\n\nYour program must:\n- Construct the uniform vertex grid with coordinates $x_i = i\\,h_x$ for $i = 0,1,\\dots,N_x-1$ and $y_j = j\\,h_y$ for $j = 0,1,\\dots,N_y-1$.\n- Initialize $u^n_{i,j} = u_0(x_i,y_j)$.\n- Perform one explicit time step using the vertex-centered FVM and first-order upwind fluxes with $\\boldsymbol{a}=(1,0)$:\n  - For each vertex $(i,j)$, define its west neighbor index $i_W = (i-1) \\bmod N_x$ and compute\n    $$\n    u^{n+1}_{i,j} = u^n_{i,j} - \\frac{\\Delta t}{h_x}\\big(u^n_{i,j} - u^n_{i_W,j}\\big).\n    $$\n- Determine the Courant–Friedrichs–Lewy (CFL) stability condition for this scheme and velocity. Derive the requirement on $\\Delta t$ in terms of $h_x$ that ensures stability and return whether the given $\\Delta t$ satisfies it.\n\nFor each test case, after advancing one time step, report the updated value at the vertex closest to the evaluation point $(x^\\star,y^\\star)$ and a boolean indicating whether the CFL constraint is satisfied. Given $(x^\\star,y^\\star)$, choose the closest vertex indices by rounding: $i^\\star = \\operatorname{round}(x^\\star/h_x)$ and $j^\\star = \\operatorname{round}(y^\\star/h_y)$, both taken modulo $N_x$ and $N_y$ respectively, and then use $(x_{i^\\star}, y_{j^\\star})$.\n\nTest suite:\n- Case $1$: $N_x=20$, $N_y=20$, $L_x=1$, $L_y=1$, $\\Delta t=0.02$, $(x^\\star,y^\\star)=(0.6,0.3)$.\n- Case $2$: $N_x=50$, $N_y=10$, $L_x=1$, $L_y=1$, $\\Delta t=0.02$, $(x^\\star,y^\\star)=(0.6,0.3)$.\n- Case $3$: $N_x=30$, $N_y=30$, $L_x=1$, $L_y=1$, $\\Delta t=0.06$, $(x^\\star,y^\\star)=(0.6,0.3)$.\n- Case $4$: $N_x=16$, $N_y=16$, $L_x=1$, $L_y=1$, $\\Delta t=0.0$, $(x^\\star,y^\\star)=(0.6,0.3)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must be a two-element list $[u^{n+1}(x_{i^\\star},y_{j^\\star}), \\text{cfl\\_ok}]$, where $u^{n+1}(x_{i^\\star},y_{j^\\star})$ is a floating-point number rounded to $8$ decimal places and $\\text{cfl\\_ok}$ is a boolean. For example, the overall output format should look like\n$$\n\\big[ [\\text{float},\\text{boolean}], [\\text{float},\\text{boolean}], [\\text{float},\\text{boolean}], [\\text{float},\\text{boolean}] \\big].\n$$",
            "solution": "The problem statement has been validated and is deemed sound, well-posed, and objective. It presents a clear task in computational fluid dynamics based on established scientific and mathematical principles.\n\nThe-problem requires the implementation of a single time step for the linear advection equation using a vertex-centered finite volume method (FVM). The derivation of the numerical scheme, the stability analysis, and the implementation details are outlined below.\n\nThe governing equation is the linear advection equation in two dimensions, given in conservative form as:\n$$\n\\partial_t u + \\nabla \\cdot (\\boldsymbol{a}\\,u) = 0\n$$\nwhere $u(x,y,t)$ is a scalar field and $\\boldsymbol{a}$ is the constant advection velocity. For this problem, the velocity is specified as $\\boldsymbol{a} = (1,0)$, which simplifies the equation to:\n$$\n\\partial_t u + \\partial_x u = 0\n$$\nThis equation describes the transport of the quantity $u$ in the positive $x$-direction with unit speed.\n\nThe FVM relies on the integral form of the conservation law. We integrate the equation over a control volume $V_P$ fixed in space:\n$$\n\\int_{V_P} \\partial_t u \\, dV + \\int_{V_P} \\nabla \\cdot (\\boldsymbol{a}\\,u) \\, dV = 0\n$$\nApplying the divergence theorem (also known as Gauss's theorem) to the second term transforms the volume integral of the divergence into a surface integral of the flux over the boundary $\\partial V_P$:\n$$\n\\frac{d}{dt} \\int_{V_P} u \\, dV + \\oint_{\\partial V_P} (\\boldsymbol{a}\\,u) \\cdot \\boldsymbol{n} \\, dS = 0\n$$\nwhere $\\boldsymbol{n}$ is the outward-pointing unit normal vector on the surface element $dS$.\n\nIn a vertex-centered FVM, the domain is first discretized into a grid of vertices, and a dual mesh of control volumes is constructed around each vertex. For the specified uniform Cartesian mesh with vertices $(x_i, y_j)$, where $x_i = i h_x$ and $y_j = j h_y$, the dual control volume $V_{i,j}$ around vertex $(i,j)$ is a rectangle. Its corners are at the centers of the four surrounding primal cells, meaning it extends from $x_i - h_x/2$ to $x_i + h_x/2$ in the $x$-direction and from $y_j - h_y/2$ to $y_j + h_y/2$ in the $y$-direction. The volume (area in 2D) of this control volume is $V_{i,j} = h_x h_y$.\n\nWe define the cell-averaged quantity $\\bar{u}_{i,j}(t) = \\frac{1}{V_{i,j}} \\int_{V_{i,j}} u(x,y,t) \\, dV$. The integral conservation law becomes:\n$$\nV_{i,j} \\frac{d\\bar{u}_{i,j}}{dt} + \\oint_{\\partial V_{i,j}} (\\boldsymbol{a}\\,u) \\cdot \\boldsymbol{n} \\, dS = 0\n$$\nIn a vertex-centered scheme, the cell average $\\bar{u}_{i,j}$ is approximated by the value at the vertex itself, $\\bar{u}_{i,j} \\approx u_{i,j}$.\n\nThe flux integral is evaluated by summing the fluxes over the four faces of the rectangular control volume: East (e), West (w), North (n), and South (s). The velocity vector is $\\boldsymbol{a} = (1, 0)$. The outward normal vectors are $\\boldsymbol{n}_e = (1,0)$, $\\boldsymbol{n}_w = (-1,0)$, $\\boldsymbol{n}_n = (0,1)$, and $\\boldsymbol{n}_s = (0,-1)$. The dot products are:\n- $\\boldsymbol{a} \\cdot \\boldsymbol{n}_e = 1$\n- $\\boldsymbol{a} \\cdot \\boldsymbol{n}_w = -1$\n- $\\boldsymbol{a} \\cdot \\boldsymbol{n}_n = 0$\n- $\\boldsymbol{a} \\cdot \\boldsymbol{n}_s = 0$\n\nThus, fluxes through the north and south faces are zero. The flux integral simplifies to the sum of fluxes through the east and west faces:\n$$\n\\oint_{\\partial V_{i,j}} (\\boldsymbol{a}\\,u) \\cdot \\boldsymbol{n} \\, dS = \\int_e u \\, dS - \\int_w u \\, dS\n$$\nThe lengths of the east and west faces are both $h_y$. Approximating the integral over each face using the midpoint rule gives a numerical flux:\n$$\n\\int_e u \\, dS - \\int_w u \\, dS \\approx (F_e - F_w)\n$$\nwhere $F_e = u_e h_y$ and $F_w = u_w h_y$. Here, $u_e$ and $u_w$ are the values of $u$ at the center of the east and west faces, respectively.\n\nThe problem specifies a first-order upwind scheme. Since the advection velocity in the $x$-direction is positive ($a_x = 1 > 0$), the \"upwind\" direction is from the left (from smaller $x$). Therefore, the value of $u$ at a face is taken from the vertex on the upwind side of that face.\n- For the east face of $V_{i,j}$ (at $x=x_i+h_x/2$), the upwind vertex is $(i,j)$. Thus, $u_e = u_{i,j}$. The flux leaving the east face is $u_{i,j} h_y$.\n- For the west face of $V_{i,j}$ (at $x=x_i-h_x/2$), the upwind vertex is the western neighbor, $(i_W, j)$, where $i_W = (i-1) \\pmod{N_x}$ to handle periodic boundary conditions. Thus, $u_w = u_{i_W,j}$. The flux entering the west face is $u_{i_W,j} h_y$.\n\nThe net flux out of the control volume $V_{i,j}$ is the flux out from the east face minus the flux in from the west face:\n$$\n\\text{Net Flux} = (u_{i,j} h_y) - (u_{i_W,j} h_y) = (u_{i,j} - u_{i_W,j})h_y\n$$\nSubstituting this into the semi-discretized conservation law gives:\n$$\nh_x h_y \\frac{d u_{i,j}}{dt} + (u_{i,j} - u_{i_W,j})h_y = 0\n$$\nDividing by the volume $h_x h_y$ yields the semi-discrete system of ODEs:\n$$\n\\frac{d u_{i,j}}{dt} = - \\frac{1}{h_x} (u_{i,j} - u_{i_W,j})\n$$\nThe problem specifies explicit forward Euler for time integration. Approximating the time derivative as $\\frac{d u_{i,j}}{dt} \\approx \\frac{u_{i,j}^{n+1} - u_{i,j}^{n}}{\\Delta t}$, where $u_{i,j}^n = u(x_i, y_j, t^n)$, we get the fully discrete scheme:\n$$\n\\frac{u_{i,j}^{n+1} - u_{i,j}^{n}}{\\Delta t} = - \\frac{1}{h_x} (u_{i,j}^n - u_{i_W,j}^n)\n$$\nRearranging for $u_{i,j}^{n+1}$ yields the update formula provided in the problem statement:\n$$\nu^{n+1}_{i,j} = u^n_{i,j} - \\frac{\\Delta t}{h_x}\\big(u^n_{i,j} - u^n_{i_W,j}\\big)\n$$\n\nThe stability of this explicit scheme is governed by the Courant–Friedrichs–Lewy (CFL) condition. For the 1D advection equation $u_t + a_x u_x = 0$, the first-order upwind scheme (which is a Forward-Time, Backward-Space scheme for $a_x > 0$) is stable if the Courant number $C = |a_x| \\frac{\\Delta t}{h_x}$ satisfies $C \\le 1$. In our case, $a_x = 1$, so the condition becomes:\n$$\n\\frac{\\Delta t}{h_x} \\le 1 \\quad \\text{or} \\quad \\Delta t \\le h_x\n$$\nThe implementation will verify if this condition is met for the given parameters in each test case.\n\nThe implementation will proceed as follows:\n1. For each test case, define grid parameters $N_x, N_y, L_x, L_y, h_x, h_y$ and the time step $\\Delta t$.\n2. Construct a 2D grid of vertex coordinates $(x_i, y_j)$ for $i \\in [0, N_x-1]$ and $j \\in [0, N_y-1]$.\n3. Initialize the solution field $u^n$ on this grid using the provided initial condition function $u_0(x,y)$.\n4. Compute the updated field $u^{n+1}$ using the vectorized form of the update equation. The periodic shift $u_{i_W,j}$ will be implemented efficiently using `numpy.roll`.\n5. Determine the boolean flag for CFL stability by checking if $\\Delta t \\le h_x$.\n6. Identify the grid indices $(i^\\star, j^\\star)$ closest to the evaluation point $(x^\\star, y^\\star)$ using the specified rounding and modulo arithmetic.\n7. Extract the value of $u^{n+1}$ at $(i^\\star, j^\\star)$, round it to $8$ decimal places, and package it with the CFL boolean flag into the final result list.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the 2D linear advection problem for one time step using a\n    vertex-centered FVM with first-order upwind fluxes.\n    \"\"\"\n    # Parameters for the initial condition\n    x_c = 0.25\n    y_c = 0.5\n    sigma = 0.15\n    beta = 0.25\n\n    # Test cases from the problem statement\n    test_cases = [\n        {'Nx': 20, 'Ny': 20, 'Lx': 1.0, 'Ly': 1.0, 'dt': 0.02, 'x_star': 0.6, 'y_star': 0.3},\n        {'Nx': 50, 'Ny': 10, 'Lx': 1.0, 'Ly': 1.0, 'dt': 0.02, 'x_star': 0.6, 'y_star': 0.3},\n        {'Nx': 30, 'Ny': 30, 'Lx': 1.0, 'Ly': 1.0, 'dt': 0.06, 'x_star': 0.6, 'y_star': 0.3},\n        {'Nx': 16, 'Ny': 16, 'Lx': 1.0, 'Ly': 1.0, 'dt': 0.0, 'x_star': 0.6, 'y_star': 0.3},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack parameters for the current case\n        Nx, Ny = case['Nx'], case['Ny']\n        Lx, Ly = case['Lx'], case['Ly']\n        dt = case['dt']\n        x_star, y_star = case['x_star'], case['y_star']\n\n        # Calculate grid spacings\n        hx = Lx / Nx\n        hy = Ly / Ny\n\n        # Create grid coordinates\n        x_coords = np.arange(Nx) * hx\n        y_coords = np.arange(Ny) * hy\n        X, Y = np.meshgrid(x_coords, y_coords, indexing='ij')\n\n        # Initialize the scalar field u at time t^n\n        # u_n(x,y) = exp(-((x-xc)^2 + (y-yc)^2)/sigma^2) + beta*sin(2*pi*x)*cos(2*pi*y)\n        u_n = np.exp(-((X - x_c)**2 + (Y - y_c)**2) / sigma**2) + \\\n              beta * np.sin(2 * np.pi * X) * np.cos(2 * np.pi * Y)\n\n        # Perform one explicit time step using first-order upwind scheme\n        # u^{n+1}_{i,j} = u^n_{i,j} - dt/hx * (u^n_{i,j} - u^n_{i_W,j})\n        # i_W corresponds to a circular shift in the i-direction (axis 0)\n        u_W = np.roll(u_n, shift=1, axis=0)\n        u_np1 = u_n - (dt / hx) * (u_n - u_W)\n\n        # Determine if the CFL stability condition is satisfied\n        # For a=1, the condition is dt = hx.\n        cfl_ok = (dt = hx)\n\n        # Find the indices of the vertex closest to the evaluation point (x_star, y_star)\n        # i_star = round(x_star / hx) mod Nx\n        # j_star = round(y_star / hy) mod Ny\n        i_star = int(np.round(x_star / hx)) % Nx\n        j_star = int(np.round(y_star / hy)) % Ny\n        \n        # Get the updated value at the evaluation vertex\n        u_eval = u_np1[i_star, j_star]\n        \n        # Append the result for this case\n        results.append([round(u_eval, 8), cfl_ok])\n\n    # Format the final output as a string representing a list of lists\n    # e.g., [[0.12345678, True], [0.98765432, False]]\n    # Python's str() on a boolean gives 'True' or 'False', which is acceptable.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While explicit methods are conceptually straightforward, many real-world problems require the robustness of implicit solvers, particularly for finding steady-state solutions. The core of an implicit method based on Newton's technique is the assembly of a residual vector, which measures the local imbalance of the conservation law, and a Jacobian matrix, which describes how that imbalance changes with the solution. This advanced practice details the assembly process for a nonlinear advection-diffusion equation, teaching you the essential edge-based computational loop that forms the heart of modern implicit finite volume codes .",
            "id": "3387966",
            "problem": "Consider a non-dimensional, steady, nonlinear advection-diffusion equation for a scalar field $q$ posed on a two-dimensional vertex-centered finite volume mesh. Each control volume is associated with a vertex $i$, and fluxes are exchanged across dual faces aligned with mesh edges. The residual at vertex $i$, denoted $R_i$, is the sum of numerical fluxes crossing the faces of the dual control volume, oriented outward from $i$. The discrete Jacobian $J$ is the matrix of partial derivatives $\\partial R_i / \\partial q_j$.\n\nYou must design and implement an edge-based loop that assembles both the residual vector $R$ and the Jacobian matrix $J$ for the following nonlinear model and numerical fluxes. Throughout this problem, all quantities are non-dimensional.\n\nFundamental base and model:\n- Conservation in integral form over the dual control volume $\\mathcal{V}_i$: \n$$\\sum_{f \\subset \\partial \\mathcal{V}_i} F_f(q) = 0,$$\nwhere $F_f(q)$ denotes the total numerical flux through face $f$.\n- The advective velocity depends on the field as\n$$\\mathbf{u}(q) = (u_0 + \\alpha q^2)\\,\\mathbf{v}_{\\mathrm{dir}},$$\nwhere $u_0 > 0$ is a baseline speed, $\\alpha \\ge 0$ controls nonlinearity, and $\\mathbf{v}_{\\mathrm{dir}}$ is a fixed unit direction vector.\n- The diffusion coefficient depends linearly on the field:\n$$k(q) = k_0 + \\beta q,$$\nwith $k_0 > 0$ and $\\beta \\ge 0$.\n\nGeometry and orientation:\n- For each interior edge connecting vertices $i$ and $j$, the dual face has area factor $A_e > 0$, unit normal $\\mathbf{n}_{ij}$ pointing outward from the control volume of $i$ toward $j$, and a metric distance $d_{ij} > 0$ used for gradient approximations.\n\nNumerical fluxes for an interior edge $\\{i,j\\}$:\n- Define the average state $q_{\\mathrm{avg}} = \\frac{q_i + q_j}{2}$, the average speed $s = \\mathbf{u}(q_{\\mathrm{avg}}) \\cdot \\mathbf{n}_{ij}$, and the arithmetic mean $k_{\\mathrm{avg}} = \\frac{k(q_i) + k(q_j)}{2}$.\n- The advective numerical flux uses a Rusanov (Lax-Friedrichs) split:\n$$F_{\\mathrm{adv}}^{ij} = A_e\\left[s\\,\\frac{q_i + q_j}{2} + \\frac{1}{2}\\,\\lvert s \\rvert\\,(q_i - q_j)\\right].$$\n- The diffusive numerical flux uses a two-point approximation:\n$$F_{\\mathrm{diff}}^{ij} = -A_e\\,k_{\\mathrm{avg}}\\,\\frac{q_j - q_i}{d_{ij}}.$$\n- The total flux is $F^{ij} = F_{\\mathrm{adv}}^{ij} + F_{\\mathrm{diff}}^{ij}$. Assembly convention: add $+F^{ij}$ to $R_i$ and $-F^{ij}$ to $R_j$ to ensure conservation.\n\nJacobian for an interior edge $\\{i,j\\}$:\n- Let $\\sigma = \\mathrm{sign}(s)$ for $s \\ne 0$ and $v_n = \\mathbf{v}_{\\mathrm{dir}} \\cdot \\mathbf{n}_{ij}$. Using $\\frac{d}{dq}\\mathbf{u}(q) = 2\\alpha q\\,\\mathbf{v}_{\\mathrm{dir}}$, the derivatives of $s$ with respect to $q_i$ and $q_j$ are\n$$\\frac{\\partial s}{\\partial q_i} = \\alpha\\,q_{\\mathrm{avg}}\\,v_n,\\qquad \\frac{\\partial s}{\\partial q_j} = \\alpha\\,q_{\\mathrm{avg}}\\,v_n.$$\n- Let $q_{\\mathrm{avg}} = \\frac{q_i + q_j}{2}$ and note $\\frac{d}{dq_i}q_{\\mathrm{avg}} = \\frac{1}{2}$, $\\frac{d}{dq_j}q_{\\mathrm{avg}} = \\frac{1}{2}$. Then\n$$\\frac{\\partial F_{\\mathrm{adv}}^{ij}}{\\partial q_i} = A_e\\left[\\left(\\frac{\\partial s}{\\partial q_i}\\right) q_{\\mathrm{avg}} + s\\cdot\\frac{1}{2} + \\frac{1}{2}\\,\\sigma\\,\\left(\\frac{\\partial s}{\\partial q_i}\\right)(q_i - q_j) + \\frac{1}{2}\\,\\lvert s \\rvert\\right],$$\n$$\\frac{\\partial F_{\\mathrm{adv}}^{ij}}{\\partial q_j} = A_e\\left[\\left(\\frac{\\partial s}{\\partial q_j}\\right) q_{\\mathrm{avg}} + s\\cdot\\frac{1}{2} + \\frac{1}{2}\\,\\sigma\\,\\left(\\frac{\\partial s}{\\partial q_j}\\right)(q_i - q_j) - \\frac{1}{2}\\,\\lvert s \\rvert\\right].$$\n- With $k'(q) = \\beta$ and $k_{\\mathrm{avg}} = \\frac{k(q_i) + k(q_j)}{2}$,\n$$\\frac{\\partial F_{\\mathrm{diff}}^{ij}}{\\partial q_i} = -A_e\\left[\\frac{1}{2}\\beta\\,\\frac{q_j - q_i}{d_{ij}} - \\frac{k_{\\mathrm{avg}}}{d_{ij}}\\right],\\qquad \\frac{\\partial F_{\\mathrm{diff}}^{ij}}{\\partial q_j} = -A_e\\left[\\frac{1}{2}\\beta\\,\\frac{q_j - q_i}{d_{ij}} + \\frac{k_{\\mathrm{avg}}}{d_{ij}}\\right].$$\n- The total derivatives are obtained by summation:\n$$\\frac{\\partial F^{ij}}{\\partial q_i} = \\frac{\\partial F_{\\mathrm{adv}}^{ij}}{\\partial q_i} + \\frac{\\partial F_{\\mathrm{diff}}^{ij}}{\\partial q_i},\\qquad \\frac{\\partial F^{ij}}{\\partial q_j} = \\frac{\\partial F_{\\mathrm{adv}}^{ij}}{\\partial q_j} + \\frac{\\partial F_{\\mathrm{diff}}^{ij}}{\\partial q_j}.$$\nAssembly to $J$: add $\\frac{\\partial F^{ij}}{\\partial q_i}$ to $J_{ii}$ and $\\frac{\\partial F^{ij}}{\\partial q_j}$ to $J_{ij}$, and subtract the same from $J_{ji}$ and $J_{jj}$ due to the $-F^{ij}$ contribution in $R_j$.\n\nBoundary edges:\n- Dirichlet boundary at vertex $i$: a prescribed state $q_{\\mathrm{bc}}$ interacts across a boundary dual face with area $A_b$, unit normal $\\mathbf{n}_b$ (outward from the control volume of $i$), and distance $d_{iB}$. With $q_{\\mathrm{avg}} = \\frac{q_i + q_{\\mathrm{bc}}}{2}$, $s = \\mathbf{u}(q_{\\mathrm{avg}})\\cdot \\mathbf{n}_b$, and $v_n = \\mathbf{v}_{\\mathrm{dir}}\\cdot\\mathbf{n}_b$, the fluxes are\n$$F_{\\mathrm{adv}}^{iB} = A_b\\left[s\\,q_{\\mathrm{avg}} + \\frac{1}{2}\\lvert s \\rvert (q_i - q_{\\mathrm{bc}})\\right],\\qquad F_{\\mathrm{diff}}^{iB} = -A_b\\,\\frac{k_{\\mathrm{avg}}(q_i,q_{\\mathrm{bc}})}{d_{iB}}\\,(q_{\\mathrm{bc}} - q_i).$$\nTheir derivatives with respect to $q_i$ are\n$$\\frac{\\partial s}{\\partial q_i} = \\alpha\\,q_{\\mathrm{avg}}\\,v_n,$$\n$$\\frac{\\partial F_{\\mathrm{adv}}^{iB}}{\\partial q_i} = A_b\\left[\\left(\\frac{\\partial s}{\\partial q_i}\\right) q_{\\mathrm{avg}} + s\\cdot\\frac{1}{2} + \\frac{1}{2}\\sigma\\left(\\frac{\\partial s}{\\partial q_i}\\right)(q_i - q_{\\mathrm{bc}}) + \\frac{1}{2}\\lvert s \\rvert\\right],$$\n$$\\frac{\\partial F_{\\mathrm{diff}}^{iB}}{\\partial q_i} = -A_b\\left[\\frac{1}{2}\\beta\\,\\frac{q_{\\mathrm{bc}} - q_i}{d_{iB}} - \\frac{k_{\\mathrm{avg}}(q_i,q_{\\mathrm{bc}})}{d_{iB}}\\right].$$\nThe boundary contribution adds $+F^{iB}$ to $R_i$ and adds only the $q_i$ derivative to $J_{ii}$, since $q_{\\mathrm{bc}}$ is prescribed.\n\n- Neumann boundary at vertex $i$: a prescribed normal diffusive flux $h$ is imposed. Define $s = \\mathbf{u}(q_i)\\cdot \\mathbf{n}_b$, and let $q_{\\mathrm{in}}$ be the boundary state used for inflow advection. The advection flux uses an upwind split:\n$$F_{\\mathrm{adv}}^{iN} = A_b\\left[\\max(s,0)\\,q_i + \\min(s,0)\\,q_{\\mathrm{in}}\\right].$$\nThe diffusive flux is $F_{\\mathrm{diff}}^{iN} = A_b\\,h$. The derivative of $F_{\\mathrm{adv}}^{iN}$ with respect to $q_i$ is piecewise:\n$$\\frac{d s}{d q_i} = 2\\alpha q_i\\,(\\mathbf{v}_{\\mathrm{dir}}\\cdot\\mathbf{n}_b),$$\n$$\\frac{\\partial F_{\\mathrm{adv}}^{iN}}{\\partial q_i} = \\begin{cases}\nA_b\\left(\\frac{d s}{d q_i}\\,q_i + s\\right),  s > 0,\\\\\nA_b\\left(\\frac{d s}{d q_i}\\,q_{\\mathrm{in}}\\right),  s  0,\n\\end{cases}$$\nand $\\frac{\\partial F_{\\mathrm{diff}}^{iN}}{\\partial q_i} = 0$. The boundary contribution adds $+F^{iN}$ to $R_i$ and only the $q_i$ derivative to $J_{ii}$.\n\nData dependencies required for the edge loop:\n- State vector entries $q_i$ at vertices.\n- For each interior edge: indices $(i,j)$, the area factor $A_e$, the unit normal $\\mathbf{n}_{ij}$ oriented from $i$ to $j$, and the metric distance $d_{ij}$.\n- For each Dirichlet boundary edge attached to vertex $i$: $A_b$, $\\mathbf{n}_b$, $d_{iB}$, and $q_{\\mathrm{bc}}$.\n- For each Neumann boundary edge attached to vertex $i$: $A_b$, $\\mathbf{n}_b$, prescribed flux $h$, and inflow state $q_{\\mathrm{in}}$.\n\nYour program must implement this assembly and compute, for each test case, the following two floating-point metrics:\n- The squared two-norm of the residual, $\\lVert R \\rVert_2^2 = \\sum_i R_i^2$.\n- The spectral radius of the Jacobian, defined as $\\rho(J) = \\max_\\lambda \\lvert \\lambda \\rvert$, where $\\lambda$ ranges over the eigenvalues of $J$.\n\nTest suite:\n- Test case 1 (interior-only pair):\n    - Number of vertices: $N = 2$.\n    - State: $q = [0.3, 0.7]$.\n    - Interior edges: one edge from $i=0$ to $j=1$ with $A_e = 1$, $d_{ij} = 1$, and $\\mathbf{n}_{01} = (1, 0)$.\n    - Parameters: $u_0 = 0.5$, $\\alpha = 0.2$, $\\mathbf{v}_{\\mathrm{dir}} = (1, 0)$, $k_0 = 0.05$, $\\beta = 0.1$.\n- Test case 2 (one-dimensional chain with Dirichlet boundaries):\n    - Number of vertices: $N = 3$.\n    - State: $q = [0.4, 0.6, 0.9]$.\n    - Interior edges: $(0,1)$ and $(1,2)$ with $A_e = 1$, $d_{ij} = 1$, and $\\mathbf{n}_{ij} = (1, 0)$ oriented from lower index to higher index.\n    - Dirichlet boundaries: at vertex $0$, $A_b = 1$, $d_{0B} = 0.5$, $\\mathbf{n}_b = (-1, 0)$, $q_{\\mathrm{bc}} = 0.2$; at vertex $2$, $A_b = 1$, $d_{2B} = 0.5$, $\\mathbf{n}_b = (1, 0)$, $q_{\\mathrm{bc}} = 1.0$.\n    - Parameters: $u_0 = 0.3$, $\\alpha = 0.15$, $\\mathbf{v}_{\\mathrm{dir}} = (1, 0)$, $k_0 = 0.03$, $\\beta = 0.05$.\n- Test case 3 (two-dimensional cross with mixed boundaries):\n    - Number of vertices: $N = 4$ with positions implicitly defining orientations as follows.\n    - State: $q = [0.6, 0.9, 0.5, 0.7]$ for vertices $[0,1,2,3]$ corresponding to positions $[(0,0),(1,0),(0,1),(1,1)]$.\n    - Interior edges: $(0,1)$ and $(2,3)$ with $\\mathbf{n}_{ij} = (1,0)$, and $(0,2)$ and $(1,3)$ with $\\mathbf{n}_{ij} = (0,1)$. All have $A_e = 1$, $d_{ij} = 1$, normal oriented from lower index to higher index.\n    - Neumann boundaries: at vertex $2$ with $A_b = 1$, $\\mathbf{n}_b = (0,1)$, prescribed diffusive flux $h = 0.02$, inflow state $q_{\\mathrm{in}} = 0.5$; at vertex $3$ with $A_b = 1$, $\\mathbf{n}_b = (0,1)$, $h = 0.02$, $q_{\\mathrm{in}} = 0.5$; at vertex $0$ with $A_b = 1$, $\\mathbf{n}_b = (0,-1)$, $h = 0.02$, $q_{\\mathrm{in}} = 0.8$; at vertex $1$ with $A_b = 1$, $\\mathbf{n}_b = (0,-1)$, $h = 0.02$, $q_{\\mathrm{in}} = 0.8$.\n    - Parameters: $u_0 = 0.4$, $\\alpha = 0.1$, $\\mathbf{v}_{\\mathrm{dir}} = \\left(\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right)$, $k_0 = 0.04$, $\\beta = 0.08$.\n\nFinal output format:\n- Your program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, in the order $[\\lVert R \\rVert_2^2,\\rho(J)]$ for Test case 1, then for Test case 2, then for Test case 3. For example, an output line should look like\n$$[\\text{r1},\\text{rho1},\\text{r2},\\text{rho2},\\text{r3},\\text{rho3}].$$\nEach entry must be a floating-point number.",
            "solution": "The methodology for assembling the residual vector $R$ and the Jacobian matrix $J$ for the given nonlinear advection-diffusion problem is based on a standard vertex-centered finite volume formulation. The assembly process iterates over all mesh edges and boundary faces, accumulating contributions to $R$ and $J$. All quantities are non-dimensional.\n\nThe overall algorithm for each test case is as follows:\n1. Given $N$ vertices, initialize the residual vector $R$ as a zero vector of size $N$ and the Jacobian matrix $J$ as a zero matrix of size $N \\times N$.\n2. For each interior edge connecting vertices $i$ and $j$, calculate the numerical flux $F^{ij}$ and its derivatives $\\frac{\\partial F^{ij}}{\\partial q_i}$ and $\\frac{\\partial F^{ij}}{\\partial q_j}$. Update $R_i, R_j$ and the $2 \\times 2$ submatrix of $J$ at indices $(i,i), (i,j), (j,i), (j,j)$.\n3. For each boundary face at a vertex $i$, calculate the boundary flux $F_b$ and its derivative $\\frac{\\partial F_b}{\\partial q_i}$. Update $R_i$ and the diagonal entry $J_{ii}$.\n4. After all contributions have been summed, compute the final metrics: the squared $L_2$ norm of the residual, $\\lVert R \\rVert_2^2$, and the spectral radius of the Jacobian, $\\rho(J) = \\max_k |\\lambda_k|$, where $\\lambda_k$ are the eigenvalues of $J$.\n\nThe constitutive relations for advective velocity and diffusion coefficient are $q$-dependent:\n- Advective velocity: $\\mathbf{u}(q) = (u_0 + \\alpha q^2)\\mathbf{v}_{\\mathrm{dir}}$\n- Diffusion coefficient: $k(q) = k_0 + \\beta q$\n\n**1. Interior Edge Contribution**\n\nFor each interior edge connecting vertices $i$ and $j$ with states $q_i$ and $q_j$, the following steps are performed:\n\n- **Compute Averaged Quantities**:\n  - State for nonlinear velocity: $q_{\\mathrm{avg}} = \\frac{q_i + q_j}{2}$.\n  - Normal velocity component: $s = \\mathbf{u}(q_{\\mathrm{avg}}) \\cdot \\mathbf{n}_{ij}$, where $\\mathbf{n}_{ij}$ is the unit normal from control volume $i$ to $j$.\n  - Average diffusion coefficient: $k_{\\mathrm{avg}} = \\frac{k(q_i) + k(q_j)}{2} = k_0 + \\beta q_{\\mathrm{avg}}$.\n\n- **Compute Numerical Flux $F^{ij}$**:\n  - Advective part (Rusanov): $F_{\\mathrm{adv}}^{ij} = A_e\\left[s\\,q_{\\mathrm{avg}} + \\frac{1}{2}\\,\\lvert s \\rvert\\,(q_i - q_j)\\right]$.\n  - Diffusive part (two-point): $F_{\\mathrm{diff}}^{ij} = -A_e\\,k_{\\mathrm{avg}}\\,\\frac{q_j - q_i}{d_{ij}}$.\n  - Total flux out of volume $i$ towards $j$: $F^{ij} = F_{\\mathrm{adv}}^{ij} + F_{\\mathrm{diff}}^{ij}$.\n\n- **Assemble Residual Vector $R$**:\n  The flux $F^{ij}$ is added to $R_i$ and, to ensure conservation, subtracted from $R_j$:\n  $$R_i \\leftarrow R_i + F^{ij}$$\n  $$R_j \\leftarrow R_j - F^{ij}$$\n\n- **Assemble Jacobian Matrix $J$**:\n  The derivatives of the total flux, $\\frac{\\partial F^{ij}}{\\partial q_i}$ and $\\frac{\\partial F^{ij}}{\\partial q_j}$, are computed using the formulas provided, which are derived via the chain rule. This involves derivatives of intermediate terms such as $s$ and $k_{\\mathrm{avg}}$. For instance, a key term is $\\frac{\\partial s}{\\partial q_k} = \\alpha q_{\\mathrm{avg}} (\\mathbf{v}_{\\mathrm{dir}} \\cdot \\mathbf{n}_{ij})$ for $k \\in \\{i,j\\}$. The term $\\sigma = \\mathrm{sign}(s)$ is used in the derivative of the Rusanov artificial dissipation; for $s=0$, we take $\\sigma=0$.\n  The Jacobian is then updated as follows:\n  $$J_{ii} \\leftarrow J_{ii} + \\frac{\\partial F^{ij}}{\\partial q_i}, \\quad J_{ij} \\leftarrow J_{ij} + \\frac{\\partial F^{ij}}{\\partial q_j}$$\n  $$J_{ji} \\leftarrow J_{ji} - \\frac{\\partial F^{ij}}{\\partial q_i}, \\quad J_{jj} \\leftarrow J_{jj} - \\frac{\\partial F^{ij}}{\\partial q_j}$$\n\n**2. Boundary Face Contributions**\n\n- **Dirichlet Boundary at vertex $i$**:\n  A state $q_{\\mathrm{bc}}$ is prescribed. The flux $F^{iB}$ is computed using the same flux functions as for an interior edge, but with $q_j$ replaced by $q_{\\mathrm{bc}}$ and geometric factors $A_b$, $\\mathbf{n}_b$, $d_{iB}$.\n  - Residual update: $R_i \\leftarrow R_i + F^{iB}$.\n  - Jacobian update: The derivative $\\frac{\\partial F^{iB}}{\\partial q_i}$ is computed and added to a single Jacobian entry, as $q_{\\mathrm{bc}}$ is a constant parameter: $J_{ii} \\leftarrow J_{ii} + \\frac{\\partial F^{iB}}{\\partial q_i}$.\n\n- **Neumann Boundary at vertex $i$**:\n  A normal diffusive flux $h$ is prescribed, so $F_{\\mathrm{diff}}^{iN} = A_b h$. The advective flux $F_{\\mathrm{adv}}^{iN}$ is upwinded based on the sign of the local velocity $s = \\mathbf{u}(q_i) \\cdot \\mathbf{n}_b$: $F_{\\mathrm{adv}}^{iN} = A_b[\\max(s,0) q_i + \\min(s,0) q_{\\mathrm{in}}]$.\n  - Total flux: $F^{iN} = F_{\\mathrm{adv}}^{iN} + F_{\\mathrm{diff}}^{iN}$.\n  - Residual update: $R_i \\leftarrow R_i + F^{iN}$.\n  - Jacobian update: The derivative $\\frac{\\partial F^{iN}}{\\partial q_i} = \\frac{\\partial F_{\\mathrm{adv}}^{iN}}{\\partial q_i}$ is computed using the piecewise formula. The derivative is taken to be $0$ at $s=0$. The update is: $J_{ii} \\leftarrow J_{ii} + \\frac{\\partial F^{iN}}{\\partial q_i}$.\n\n**3. Final Metrics**\n\nOnce $R$ and $J$ are fully assembled, the final metrics are calculated:\n- Squared $L_2$ norm of residual: $\\lVert R \\rVert_2^2 = \\sum_{k=0}^{N-1} R_k^2$.\n- Spectral radius of Jacobian: $\\rho(J) = \\max_k |\\lambda_k|$, where the eigenvalues $\\lambda_k$ of $J$ are found numerically.\n\nThis comprehensive procedure is implemented for each test case to obtain the required results.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (interior-only pair)\n        {\n            'N': 2,\n            'q': np.array([0.3, 0.7]),\n            'params': {'u0': 0.5, 'alpha': 0.2, 'v_dir': np.array([1.0, 0.0]), 'k0': 0.05, 'beta': 0.1},\n            'interior_edges': [\n                {'verts': (0, 1), 'Ae': 1.0, 'd': 1.0, 'n': np.array([1.0, 0.0])}\n            ],\n            'dirichlet_bcs': [],\n            'neumann_bcs': []\n        },\n        # Test case 2 (one-dimensional chain with Dirichlet boundaries)\n        {\n            'N': 3,\n            'q': np.array([0.4, 0.6, 0.9]),\n            'params': {'u0': 0.3, 'alpha': 0.15, 'v_dir': np.array([1.0, 0.0]), 'k0': 0.03, 'beta': 0.05},\n            'interior_edges': [\n                {'verts': (0, 1), 'Ae': 1.0, 'd': 1.0, 'n': np.array([1.0, 0.0])},\n                {'verts': (1, 2), 'Ae': 1.0, 'd': 1.0, 'n': np.array([1.0, 0.0])}\n            ],\n            'dirichlet_bcs': [\n                {'vert': 0, 'Ab': 1.0, 'd': 0.5, 'n': np.array([-1.0, 0.0]), 'q_bc': 0.2},\n                {'vert': 2, 'Ab': 1.0, 'd': 0.5, 'n': np.array([1.0, 0.0]), 'q_bc': 1.0}\n            ],\n            'neumann_bcs': []\n        },\n        # Test case 3 (2D cross with mixed boundaries)\n        {\n            'N': 4,\n            'q': np.array([0.6, 0.9, 0.5, 0.7]),\n            'params': {'u0': 0.4, 'alpha': 0.1, 'v_dir': np.array([1/np.sqrt(2), 1/np.sqrt(2)]), 'k0': 0.04, 'beta': 0.08},\n            'interior_edges': [\n                {'verts': (0, 1), 'Ae': 1.0, 'd': 1.0, 'n': np.array([1.0, 0.0])},\n                {'verts': (2, 3), 'Ae': 1.0, 'd': 1.0, 'n': np.array([1.0, 0.0])},\n                {'verts': (0, 2), 'Ae': 1.0, 'd': 1.0, 'n': np.array([0.0, 1.0])},\n                {'verts': (1, 3), 'Ae': 1.0, 'd': 1.0, 'n': np.array([0.0, 1.0])}\n            ],\n            'dirichlet_bcs': [],\n            'neumann_bcs': [\n                {'vert': 2, 'Ab': 1.0, 'n': np.array([0.0, 1.0]), 'h': 0.02, 'q_in': 0.5},\n                {'vert': 3, 'Ab': 1.0, 'n': np.array([0.0, 1.0]), 'h': 0.02, 'q_in': 0.5},\n                {'vert': 0, 'Ab': 1.0, 'n': np.array([0.0, -1.0]), 'h': 0.02, 'q_in': 0.8},\n                {'vert': 1, 'Ab': 1.0, 'n': np.array([0.0, -1.0]), 'h': 0.02, 'q_in': 0.8}\n            ]\n        }\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        N = case['N']\n        q_vec = case['q']\n        params = case['params']\n        \n        R = np.zeros(N)\n        J = np.zeros((N, N))\n        \n        u0, alpha, v_dir, k0, beta = params['u0'], params['alpha'], params['v_dir'], params['k0'], params['beta']\n        \n        # Helper functions for the model\n        def u_vec(q_scalar):\n            return (u0 + alpha * q_scalar**2) * v_dir\n        \n        def k_scal(q_scalar):\n            return k0 + beta * q_scalar\n\n        # Interior Edges\n        for edge in case['interior_edges']:\n            i, j = edge['verts']\n            Ae, d_ij, n_ij = edge['Ae'], edge['d'], edge['n']\n            q_i, q_j = q_vec[i], q_vec[j]\n            \n            q_avg = 0.5 * (q_i + q_j)\n            s = np.dot(u_vec(q_avg), n_ij)\n            s_abs = np.abs(s)\n            sigma = np.sign(s)\n            \n            k_avg = 0.5 * (k_scal(q_i) + k_scal(q_j))\n\n            # Flux calculation\n            F_adv_ij = Ae * (s * q_avg + 0.5 * s_abs * (q_i - q_j))\n            F_diff_ij = -Ae * k_avg * (q_j - q_i) / d_ij\n            F_ij = F_adv_ij + F_diff_ij\n            \n            R[i] += F_ij\n            R[j] -= F_ij\n            \n            # Jacobian calculation\n            v_n = np.dot(v_dir, n_ij)\n            ds_dqi = alpha * q_avg * v_n\n            ds_dqj = ds_dqi\n            \n            dF_adv_dqi = Ae * (ds_dqi * q_avg + 0.5 * s + 0.5 * sigma * ds_dqi * (q_i - q_j) + 0.5 * s_abs)\n            dF_adv_dqj = Ae * (ds_dqj * q_avg + 0.5 * s + 0.5 * sigma * ds_dqj * (q_i - q_j) - 0.5 * s_abs)\n\n            dF_diff_dqi = -Ae * (0.5 * beta * (q_j - q_i) / d_ij - k_avg / d_ij)\n            dF_diff_dqj = -Ae * (0.5 * beta * (q_j - q_i) / d_ij + k_avg / d_ij)\n            \n            dF_dqi = dF_adv_dqi + dF_diff_dqi\n            dF_dqj = dF_adv_dqj + dF_diff_dqj\n\n            J[i, i] += dF_dqi\n            J[i, j] += dF_dqj\n            J[j, i] -= dF_dqi\n            J[j, j] -= dF_dqj\n\n        # Dirichlet BCs\n        for bc in case['dirichlet_bcs']:\n            i = bc['vert']\n            Ab, d_iB, n_b, q_bc = bc['Ab'], bc['d'], bc['n'], bc['q_bc']\n            q_i = q_vec[i]\n            \n            q_avg = 0.5 * (q_i + q_bc)\n            s = np.dot(u_vec(q_avg), n_b)\n            s_abs = np.abs(s)\n            sigma = np.sign(s)\n            k_avg = 0.5 * (k_scal(q_i) + k_scal(q_bc))\n            \n            F_adv_iB = Ab * (s * q_avg + 0.5 * s_abs * (q_i - q_bc))\n            F_diff_iB = -Ab * k_avg * (q_bc - q_i) / d_iB\n            F_iB = F_adv_iB + F_diff_iB\n            \n            R[i] += F_iB\n            \n            v_n = np.dot(v_dir, n_b)\n            ds_dqi = alpha * q_avg * v_n\n            \n            dF_adv_dqi = Ab * (ds_dqi * q_avg + 0.5 * s + 0.5 * sigma * ds_dqi * (q_i - q_bc) + 0.5 * s_abs)\n            dF_diff_dqi = -Ab * (0.5 * beta * (q_bc - q_i) / d_iB - k_avg / d_iB)\n            \n            J[i, i] += dF_adv_dqi + dF_diff_dqi\n\n        # Neumann BCs\n        for bc in case['neumann_bcs']:\n            i = bc['vert']\n            Ab, n_b, h, q_in = bc['Ab'], bc['n'], bc['h'], bc['q_in']\n            q_i = q_vec[i]\n            \n            s = np.dot(u_vec(q_i), n_b)\n            \n            F_adv_iN = Ab * (max(s, 0) * q_i + min(s, 0) * q_in)\n            F_diff_iN = Ab * h\n            F_iN = F_adv_iN + F_diff_iN\n\n            R[i] += F_iN\n            \n            v_n = np.dot(v_dir, n_b)\n            ds_dqi = 2 * alpha * q_i * v_n\n            dF_adv_dqi = 0.0\n            if s  0:\n                dF_adv_dqi = Ab * (ds_dqi * q_i + s)\n            elif s  0:\n                dF_adv_dqi = Ab * (ds_dqi * q_in)\n\n            J[i, i] += dF_adv_dqi\n            \n        # Compute metrics\n        r_norm_sq = np.dot(R, R)\n        if N  0:\n            eigenvalues = np.linalg.eigvals(J)\n            rho_J = np.max(np.abs(eigenvalues))\n        else: # Should not happen with given cases\n            rho_J = 0.0\n            \n        results.extend([r_norm_sq, rho_J])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}