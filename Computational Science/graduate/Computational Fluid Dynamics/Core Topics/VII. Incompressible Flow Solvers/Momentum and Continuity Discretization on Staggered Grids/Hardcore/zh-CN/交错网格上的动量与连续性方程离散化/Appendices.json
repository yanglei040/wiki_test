{
    "hands_on_practices": [
        {
            "introduction": "连续性方程是质量守恒定律的数学表达，也是流体动力学的基石。在交错网格上，对此方程的正确离散化是建立压力-速度耦合关系的基础，而这正是大多数不可压缩流求解器的核心。此练习  将指导你应用有限体积法，将积分形式的守恒律转化为计算机可以求解的、每个控制体都必须满足的代数平衡方程。",
            "id": "3346588",
            "problem": "考虑一个用于计算流体动力学（CFD）的二维笛卡尔域，该域由均匀交错网格离散化。压力和密度存储在以 $(i,j)$ 为索引的单元中心，$x$ 方向动量速度分量 $u$ 存储在以 $(i+\\tfrac{1}{2},j)$ 为索引的垂直面上，$y$ 方向动量速度分量 $v$ 存储在以 $(i,j+\\tfrac{1}{2})$ 为索引的水平面上。以单元为中心的控制体尺寸为 $\\Delta x \\times \\Delta y$。假设单元内没有体积质量源。其控制原理是固定控制体上的积分质量守恒：\n$$\\frac{\\mathrm{d}}{\\mathrm{d} t}\\int_{V}\\rho\\,\\mathrm{d}V+\\oint_{\\partial V}\\rho\\,\\boldsymbol{u}\\cdot \\boldsymbol{n}\\,\\mathrm{d}A=0,$$\n其中 $\\rho$ 是质量密度，$\\boldsymbol{u}$ 是速度矢量。\n\n定义离散的面质量通量\n$$m^{x}_{i+\\tfrac{1}{2},j}=\\rho_{i+\\tfrac{1}{2},j}\\,u_{i+\\tfrac{1}{2},j}\\,\\Delta y,\\qquad m^{x}_{i-\\tfrac{1}{2},j}=\\rho_{i-\\tfrac{1}{2},j}\\,u_{i-\\tfrac{1}{2},j}\\,\\Delta y,$$\n$$m^{y}_{i,j+\\tfrac{1}{2}}=\\rho_{i,j+\\tfrac{1}{2}}\\,v_{i,j+\\tfrac{1}{2}}\\,\\Delta x,\\qquad m^{y}_{i,j-\\tfrac{1}{2}}=\\rho_{i,j-\\tfrac{1}{2}}\\,v_{i,j-\\tfrac{1}{2}}\\,\\Delta x,$$\n约定 $m^{x}_{i+\\tfrac{1}{2},j}$ 在流体沿 $+x$ 方向穿过东面时为正，$m^{x}_{i-\\tfrac{1}{2},j}$ 在流体沿 $+x$ 方向穿过西面时为正，$m^{y}_{i,j+\\tfrac{1}{2}}$ 在流体沿 $+y$ 方向穿过北面时为正，$m^{y}_{i,j-\\tfrac{1}{2}}$ 在流体沿 $+y$ 方向穿过南面时为正。设时间层 $n$ 和 $n+1$ 时以单元为中心的密度分别为 $\\rho^{n}_{i,j}$ 和 $\\rho^{n+1}_{i,j}$，并对单元平均存储项采用时间步长为 $\\Delta t$ 的后向欧拉时间积分。\n\n严格从给定的积分质量守恒原理出发，在交错网格上应用有限体积离散化，推导每个压力单元 $(i,j)$ 的守恒连续性平衡方程，该方程在完全离散形式下必须为零。将最终答案表示为关于 $\\rho^{n+1}_{i,j}$、$\\rho^{n}_{i,j}$、$\\Delta x$、$\\Delta y$、$\\Delta t$、$m^{x}_{i\\pm\\tfrac{1}{2},j}$ 和 $m^{y}_{i,j\\pm\\tfrac{1}{2}}$ 的残差（即等于零的左侧表达式）的单一闭式解析表达式。最终答案中不要包含等号。不需要进行数值计算。",
            "solution": "用户希望我验证问题陈述，如果有效，则提供解答。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **域**：二维笛卡尔域。\n*   **网格**：均匀交错网格。\n*   **变量位置**：\n    *   压力（$p$）和密度（$\\rho$）存储在以 $(i,j)$ 为索引的单元中心。\n    *   $x$ 方向动量速度分量（$u$）存储在以 $(i+\\frac{1}{2},j)$ 为索引的垂直面上。\n    *   $y$ 方向动量速度分量（$v$）存储在以 $(i,j+\\frac{1}{2})$ 为索引的水平面上。\n*   **控制体**：以单元为中心的控制体，尺寸为 $\\Delta x \\times \\Delta y$。\n*   **源项**：单元内没有体积质量源。\n*   **控制原理**：固定控制体 $V$ 上的积分质量守恒方程：\n    $$\\frac{\\mathrm{d}}{\\mathrm{d} t}\\int_{V}\\rho\\,\\mathrm{d}V+\\oint_{\\partial V}\\rho\\,\\boldsymbol{u}\\cdot \\boldsymbol{n}\\,\\mathrm{d}A=0$$\n*   **离散的面质量通量**：\n    *   $m^{x}_{i+\\frac{1}{2},j}=\\rho_{i+\\frac{1}{2},j}\\,u_{i+\\frac{1}{2},j}\\,\\Delta y$ (东面，$+x$ 方向流动为正)\n    *   $m^{x}_{i-\\frac{1}{2},j}=\\rho_{i-\\frac{1}{2},j}\\,u_{i-\\frac{1}{2},j}\\,\\Delta y$ (西面，$+x$ 方向流动为正)\n    *   $m^{y}_{i,j+\\frac{1}{2}}=\\rho_{i,j+\\frac{1}{2}}\\,v_{i,j+\\frac{1}{2}}\\,\\Delta x$ (北面，$+y$ 方向流动为正)\n    *   $m^{y}_{i,j-\\frac{1}{2}}=\\rho_{i,j-\\frac{1}{2}}\\,v_{i,j-\\frac{1}{2}}\\,\\Delta x$ (南面，$+y$ 方向流动为正)\n*   **时间离散化**：\n    *   时间层为 $n$ 和 $n+1$。\n    *   时间步长为 $\\Delta t$。\n    *   以单元为中心的密度为 $\\rho^{n}_{i,j}$ 和 $\\rho^{n+1}_{i,j}$。\n    *   存储项的时间积分方案是后向欧拉法。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据既定标准对问题进行评估：\n\n*   **科学依据**：该问题基于质量守恒基本原理，这是物理学和流体力学的基石。所描述的离散化方法（交错网格上的有限体积法）是计算流体力学（CFD）中的一种标准且成熟的技术。该设置在科学和数学上是合理的。\n*   **适定性**：该问题要求从给定的积分定律和一组定义中推导出一个离散方程。给定的条件充分且一致，可以得出一个唯一的解析表达式。\n*   **客观性**：问题使用了计算流体力学领域的精确、标准的术语来陈述。没有主观或含糊不清的陈述。\n\n该问题没有任何无效性缺陷。它是偏微分方程数值方法领域中的一个标准、定义明确的问题。\n\n**步骤 3：结论与行动**\n\n问题是有效的。将提供一个完整的、有理有据的解答。\n\n### 解答\n\n目标是使用有限体积法在交错网格上，为以 $(i,j)$ 为中心的控制体推导质量守恒方程的完全离散形式。出发点是固定控制体 $V$ 的连续性方程的积分形式：\n$$ \\frac{\\mathrm{d}}{\\mathrm{d} t}\\int_{V}\\rho\\,\\mathrm{d}V+\\oint_{\\partial V}\\rho\\,\\boldsymbol{u}\\cdot \\boldsymbol{n}\\,\\mathrm{d}A=0 $$\n该方程表明，控制体内质量的增加率等于净质量流入率。\n\n我们将此原理应用于与单元中心 $(i,j)$ 相关联的控制体 $V_{i,j}$。该控制体是一个尺寸为 $\\Delta x \\times \\Delta y$ 的矩形区域。对于二维分析，我们假设单位深度，因此单元的体积为 $\\Delta V = \\Delta x \\Delta y$。\n\n守恒定律中的两项分别进行离散化。\n\n**1. 存储项的离散化**\n\n第一项 $\\frac{\\mathrm{d}}{\\mathrm{d} t}\\int_{V}\\rho\\,\\mathrm{d}V$ 表示控制体内质量的变化率。对于控制体 $V_{i,j}$，我们通过假设以单元为中心的密度 $\\rho_{i,j}$ 代表单元上的平均密度来近似该积分：\n$$ \\int_{V_{i,j}}\\rho\\,\\mathrm{d}V \\approx \\rho_{i,j} \\Delta V = \\rho_{i,j} \\Delta x \\Delta y $$\n然后对该表达式应用时间导数。由于网格是固定的，$\\Delta x$ 和 $\\Delta y$ 不随时间变化：\n$$ \\frac{\\mathrm{d}}{\\mathrm{d} t}\\int_{V_{i,j}}\\rho\\,\\mathrm{d}V \\approx \\frac{\\mathrm{d}}{\\mathrm{d} t}(\\rho_{i,j} \\Delta x \\Delta y) = \\Delta x \\Delta y \\frac{\\mathrm{d}\\rho_{i,j}}{\\mathrm{d}t} $$\n问题指定了在时间步长 $\\Delta t = t^{n+1} - t^{n}$ 上使用后向欧拉格式进行时间积分。该格式使用时间步的开始和结束时刻的值来近似时间导数：\n$$ \\frac{\\mathrm{d}\\rho_{i,j}}{\\mathrm{d}t} \\approx \\frac{\\rho^{n+1}_{i,j} - \\rho^{n}_{i,j}}{\\Delta t} $$\n将此代入存储项的表达式，得到其完全离散形式：\n$$ \\Delta x \\Delta y \\frac{\\rho^{n+1}_{i,j} - \\rho^{n}_{i,j}}{\\Delta t} $$\n后向欧拉法是一种隐式格式，因此不属于时间导数部分的通量项在新的时间层 $n+1$ 上进行计算。\n\n**2. 通量项的离散化**\n\n第二项 $\\oint_{\\partial V}\\rho\\,\\boldsymbol{u}\\cdot \\boldsymbol{n}\\,\\mathrm{d}A$ 表示穿过控制体边界 $\\partial V$ 的净质量流出量。单元 $V_{i,j}$ 的边界由四个面组成：东（e）、西（w）、北（n）和南（s）。因此，面积分是穿过这四个面的通量之和：\n$$ \\oint_{\\partial V_{i,j}}\\rho\\,\\boldsymbol{u}\\cdot \\boldsymbol{n}\\,\\mathrm{d}A = \\int_{A_e} (\\rho\\boldsymbol{u}\\cdot\\boldsymbol{n}_e)\\mathrm{d}A + \\int_{A_w} (\\rho\\boldsymbol{u}\\cdot\\boldsymbol{n}_w)\\mathrm{d}A + \\int_{A_n} (\\rho\\boldsymbol{u}\\cdot\\boldsymbol{n}_n)\\mathrm{d}A + \\int_{A_s} (\\rho\\boldsymbol{u}\\cdot\\boldsymbol{n}_s)\\mathrm{d}A $$\n我们计算每个面上的积分：\n*   **东面（e）**：此面位于 $x_{i+\\frac{1}{2}}$。向外的单位法向量为 $\\boldsymbol{n}_e = (1, 0)$。面的面积为 $A_e = \\Delta y$。点积为 $\\rho\\boldsymbol{u}\\cdot\\boldsymbol{n}_e = \\rho u$。通量近似为 $(\\rho u)_{i+\\frac{1}{2},j} A_e = (\\rho u)_{i+\\frac{1}{2},j} \\Delta y$。问题提供了离散质量通量 $m^{x}_{i+\\frac{1}{2},j}=\\rho_{i+\\frac{1}{2},j}\\,u_{i+\\frac{1}{2},j}\\,\\Delta y$，其定义为沿 $+x$ 方向（向外）的流动为正。因此，质量流出率恰好是 $m^{x}_{i+\\frac{1}{2},j}$。\n*   **西面（w）**：此面位于 $x_{i-\\frac{1}{2}}$。向外的单位法向量为 $\\boldsymbol{n}_w = (-1, 0)$。面的面积为 $A_w = \\Delta y$。点积为 $\\rho\\boldsymbol{u}\\cdot\\boldsymbol{n}_w = -\\rho u$。向外的通量近似为 $(-\\rho u)_{i-\\frac{1}{2},j} A_w = -(\\rho u)_{i-\\frac{1}{2},j} \\Delta y$。问题提供了离散质量通量 $m^{x}_{i-\\frac{1}{2},j}=\\rho_{i-\\frac{1}{2},j}\\,u_{i-\\frac{1}{2},j}\\,\\Delta y$，定义为沿 $+x$ 方向的流动为正。一个正的 $m^{x}_{i-\\frac{1}{2},j}$ 表示流入单元 $V_{i,j}$。因此，通过西面的质量流出率为 $-m^{x}_{i-\\frac{1}{2},j}$。\n*   **北面（n）**：此面位于 $y_{j+\\frac{1}{2}}$。向外的单位法向量为 $\\boldsymbol{n}_n = (0, 1)$。面的面积为 $A_n = \\Delta x$。点积为 $\\rho\\boldsymbol{u}\\cdot\\boldsymbol{n}_n = \\rho v$。向外的通量近似为 $(\\rho v)_{i,j+\\frac{1}{2}} A_n = (\\rho v)_{i,j+\\frac{1}{2}} \\Delta x$。给定的质量通量 $m^{y}_{i,j+\\frac{1}{2}}=\\rho_{i,j+\\frac{1}{2}}\\,v_{i,j+\\frac{1}{2}}\\,\\Delta x$ 在沿 $+y$ 方向（向外）的流动时为正。因此，质量流出率为 $m^{y}_{i,j+\\frac{1}{2}}$。\n*   **南面（s）**：此面位于 $y_{j-\\frac{1}{2}}$。向外的单位法向量为 $\\boldsymbol{n}_s = (0, -1)$。面的面积为 $A_s = \\Delta x$。点积为 $\\rho\\boldsymbol{u}\\cdot\\boldsymbol{n}_s = -\\rho v$。向外的通量近似为 $(-\\rho v)_{i,j-\\frac{1}{2}} A_s = -(\\rho v)_{i,j-\\frac{1}{2}} \\Delta x$。给定的质量通量 $m^{y}_{i,j-\\frac{1}{2}}=\\rho_{i,j-\\frac{1}{2}}\\,v_{i,j-\\frac{1}{2}}\\,\\Delta x$ 在沿 $+y$ 方向的流动时为正，这是一个流入。因此，通过南面的质量流出率为 $-m^{y}_{i,j-\\frac{1}{2}}$。\n\n将所有四个面的贡献相加，得到净质量流出率：\n$$ \\oint_{\\partial V_{i,j}}\\rho\\,\\boldsymbol{u}\\cdot \\boldsymbol{n}\\,\\mathrm{d}A \\approx m^{x}_{i+\\frac{1}{2},j} - m^{x}_{i-\\frac{1}{2},j} + m^{y}_{i,j+\\frac{1}{2}} - m^{y}_{i,j-\\frac{1}{2}} $$\n\n**3. 组装最终方程**\n\n结合离散化的存储项和通量项，得到完全离散的质量守恒方程：\n$$ \\Delta x \\Delta y \\frac{\\rho^{n+1}_{i,j} - \\rho^{n}_{i,j}}{\\Delta t} + \\left( m^{x}_{i+\\frac{1}{2},j} - m^{x}_{i-\\frac{1}{2},j} \\right) + \\left( m^{y}_{i,j+\\frac{1}{2}} - m^{y}_{i,j-\\frac{1}{2}} \\right) = 0 $$\n问题要求的是残差的表达式，也就是该方程的左侧。该表达式代表了“每个压力单元的守恒连续性平衡”，数值求解器必须将其驱动为零。",
            "answer": "$$ \\boxed{\\Delta x \\Delta y \\frac{\\rho^{n+1}_{i,j} - \\rho^{n}_{i,j}}{\\Delta t} + m^{x}_{i+\\frac{1}{2},j} - m^{x}_{i-\\frac{1}{2},j} + m^{y}_{i,j+\\frac{1}{2}} - m^{y}_{i,j-\\frac{1}{2}}} $$"
        },
        {
            "introduction": "在处理完质量守恒之后，求解Navier-Stokes方程的关键下一步是离散化动量方程。拉普拉斯算子是该方程的主要组成部分，它模拟了由粘性引起的动量扩散。本实践  聚焦于为存储在交错网格上的速度分量推导拉普拉斯算子的离散形式。掌握这项技能对于精确模拟粘性效应至关重要，并且推导过程还能揭示交错笛卡尔网格简化离散过程的一个关键特性。",
            "id": "3346623",
            "problem": "考虑一个在标记-单元（MAC）交错网格上离散化的二维不可压缩流。压力 $p$ 存储在单元中心 $(i,j)$，其坐标为 $(x_i,y_j)$，水平速度分量 $u$ 存储在垂直于 $x$ 方向的单元面上，位于 $(i+\\tfrac{1}{2},j)$，其坐标为 $(x_{i+\\frac{1}{2}},y_j)$，而垂直速度分量 $v$ 存储在垂直于 $y$ 方向的单元面上，位于 $(i,j+\\tfrac{1}{2})$，其坐标为 $(x_i,y_{j+\\frac{1}{2}})$。该笛卡尔网格是均匀的，间距为 $\\Delta x$ 和 $\\Delta y$，因此 $x_{i+1}-x_i=\\Delta x$ 且 $y_{j+1}-y_j=\\Delta y$。\n\n从笛卡尔坐标系中拉普拉斯算子的定义出发，$\\nabla^{2} u \\equiv \\frac{\\partial^{2} u}{\\partial x^{2}} + \\frac{\\partial^{2} u}{\\partial y^{2}}$，推导在交错网格位置 $(i+\\tfrac{1}{2},j)$ 处 $\\nabla^{2} u$ 的二阶中心差分近似，该近似与 $u$ 在 $x$ 方向单元面上的存储方式一致。使用关于 $(x_{i+\\frac{1}{2}},y_j)$ 的泰勒级数展开来证明其精度阶数，并明确展示为什么对于您构建的中心差分格式，在均匀笛卡尔网格上任何交叉导数项（涉及 $\\frac{\\partial^{2} u}{\\partial x \\partial y}$ 的混合导数）都会消失。\n\n将您在 $(i+\\tfrac{1}{2},j)$ 处得到的 $\\nabla^{2} u$ 的最终离散算子，仅用相邻的面心值 $u_{i+\\frac{3}{2},\\,j}$、$u_{i+\\frac{1}{2},\\,j}$、$u_{i-\\frac{1}{2},\\,j}$、$u_{i+\\frac{1}{2},\\,j+1}$ 和 $u_{i+\\frac{1}{2},\\,j-1}$ 表示，写成一个单一的封闭形式解析表达式。不需要进行数值计算。",
            "solution": "出发点是笛卡尔坐标系中拉普拉斯算子的定义，\n$$\n\\nabla^{2} u(x,y) \\equiv \\frac{\\partial^{2} u}{\\partial x^{2}}(x,y) + \\frac{\\partial^{2} u}{\\partial y^{2}}(x,y).\n$$\n在标记-单元（MAC）交错网格上，水平速度分量 $u$ 定义在位置 $(x_{i+\\frac{1}{2}},y_j)$ 处，这些位置位于垂直于 $x$ 方向的面的中心。目标是使用相邻的面心 $u$ 值，构建在 $(x_{i+\\frac{1}{2}},y_j)$ 处计算的 $\\frac{\\partial^{2} u}{\\partial x^{2}}$ 和 $\\frac{\\partial^{2} u}{\\partial y^{2}}$ 的二阶中心差分近似。\n\n对于在 $(x_{i+\\frac{1}{2}},y_j)$ 处沿 $x$ 方向的二阶导数，我们使用点 $(x_{i+\\frac{3}{2}},y_j)$ 和 $(x_{i-\\frac{1}{2}},y_j)$。均匀网格意味着 $x_{i+\\frac{3}{2}} - x_{i+\\frac{1}{2}} = \\Delta x$ 且 $x_{i+\\frac{1}{2}} - x_{i-\\frac{1}{2}} = \\Delta x$。对 $u$ 在 $(x_{i+\\frac{1}{2}},y_j)$ 点进行泰勒级数展开：\n$$\nu(x_{i+\\frac{3}{2}},y_j) = u(x_{i+\\frac{1}{2}},y_j) + \\Delta x\\, u_{x}(x_{i+\\frac{1}{2}},y_j) + \\frac{(\\Delta x)^{2}}{2}\\, u_{xx}(x_{i+\\frac{1}{2}},y_j) + \\frac{(\\Delta x)^{3}}{6}\\, u_{xxx}(x_{i+\\frac{1}{2}},y_j) + \\frac{(\\Delta x)^{4}}{24}\\, u_{xxxx}(x_{i+\\frac{1}{2}},y_j) + \\mathcal{O}((\\Delta x)^{5}),\n$$\n$$\nu(x_{i-\\frac{1}{2}},y_j) = u(x_{i+\\frac{1}{2}},y_j) - \\Delta x\\, u_{x}(x_{i+\\frac{1}{2}},y_j) + \\frac{(\\Delta x)^{2}}{2}\\, u_{xx}(x_{i+\\frac{1}{2}},y_j) - \\frac{(\\Delta x)^{3}}{6}\\, u_{xxx}(x_{i+\\frac{1}{2}},y_j) + \\frac{(\\Delta x)^{4}}{24}\\, u_{xxxx}(x_{i+\\frac{1}{2}},y_j) + \\mathcal{O}((\\Delta x)^{5}),\n$$\n其中下标表示在 $(x_{i+\\frac{1}{2}},y_j)$ 处计算的偏导数。将这两个表达式相加，并减去两倍的 $u(x_{i+\\frac{1}{2}},y_j)$，得到\n$$\nu(x_{i+\\frac{3}{2}},y_j) - 2\\,u(x_{i+\\frac{1}{2}},y_j) + u(x_{i-\\frac{1}{2}},y_j) = (\\Delta x)^{2}\\, u_{xx}(x_{i+\\frac{1}{2}},y_j) + \\frac{(\\Delta x)^{4}}{12}\\, u_{xxxx}(x_{i+\\frac{1}{2}},y_j) + \\mathcal{O}((\\Delta x)^{6}).\n$$\n除以 $(\\Delta x)^{2}$ 得到二阶中心差分近似\n$$\n\\frac{u_{i+\\frac{3}{2},\\,j} - 2\\,u_{i+\\frac{1}{2},\\,j} + u_{i-\\frac{1}{2},\\,j}}{(\\Delta x)^{2}} = u_{xx}(x_{i+\\frac{1}{2}},y_j) + \\frac{(\\Delta x)^{2}}{12}\\, u_{xxxx}(x_{i+\\frac{1}{2}},y_j) + \\mathcal{O}((\\Delta x)^{4}),\n$$\n其在 $\\Delta x$ 上具有二阶精度。\n\n对于在 $(x_{i+\\frac{1}{2}},y_j)$ 处沿 $y$ 方向的二阶导数，使用点 $(x_{i+\\frac{1}{2}},y_{j+1})$ 和 $(x_{i+\\frac{1}{2}},y_{j-1})$，其中 $y_{j+1} - y_j = \\Delta y$ 且 $y_j - y_{j-1} = \\Delta y$。关于 $(x_{i+\\frac{1}{2}},y_j)$ 的泰勒展开式为\n$$\nu(x_{i+\\frac{1}{2}},y_{j+1}) = u(x_{i+\\frac{1}{2}},y_j) + \\Delta y\\, u_{y}(x_{i+\\frac{1}{2}},y_j) + \\frac{(\\Delta y)^{2}}{2}\\, u_{yy}(x_{i+\\frac{1}{2}},y_j) + \\frac{(\\Delta y)^{3}}{6}\\, u_{yyy}(x_{i+\\frac{1}{2}},y_j) + \\frac{(\\Delta y)^{4}}{24}\\, u_{yyyy}(x_{i+\\frac{1}{2}},y_j) + \\mathcal{O}((\\Delta y)^{5}),\n$$\n$$\nu(x_{i+\\frac{1}{2}},y_{j-1}) = u(x_{i+\\frac{1}{2}},y_j) - \\Delta y\\, u_{y}(x_{i+\\frac{1}{2}},y_j) + \\frac{(\\Delta y)^{2}}{2}\\, u_{yy}(x_{i+\\frac{1}{2}},y_j) - \\frac{(\\Delta y)^{3}}{6}\\, u_{yyy}(x_{i+\\frac{1}{2}},y_j) + \\frac{(\\Delta y)^{4}}{24}\\, u_{yyyy}(x_{i+\\frac{1}{2}},y_j) + \\mathcal{O}((\\Delta y)^{5}).\n$$\n求和并减去两倍的 $u(x_{i+\\frac{1}{2}},y_j)$，得到\n$$\nu(x_{i+\\frac{1}{2}},y_{j+1}) - 2\\,u(x_{i+\\frac{1}{2}},y_j) + u(x_{i+\\frac{1}{2}},y_{j-1}) = (\\Delta y)^{2}\\, u_{yy}(x_{i+\\frac{1}{2}},y_j) + \\frac{(\\Delta y)^{4}}{12}\\, u_{yyyy}(x_{i+\\frac{1}{2}},y_j) + \\mathcal{O}((\\Delta y)^{6}),\n$$\n因此二阶中心差分近似为\n$$\n\\frac{u_{i+\\frac{1}{2},\\,j+1} - 2\\,u_{i+\\frac{1}{2},\\,j} + u_{i+\\frac{1}{2},\\,j-1}}{(\\Delta y)^{2}} = u_{yy}(x_{i+\\frac{1}{2}},y_j) + \\frac{(\\Delta y)^{2}}{12}\\, u_{yyyy}(x_{i+\\frac{1}{2}},y_j) + \\mathcal{O}((\\Delta y)^{4}),\n$$\n其在 $\\Delta y$ 上具有二阶精度。\n\n将这两个近似相加，得到在 $(x_{i+\\frac{1}{2}},y_j)$ 处的离散拉普拉斯算子：\n$$\n\\frac{u_{i+\\frac{3}{2},\\,j} - 2\\,u_{i+\\frac{1}{2},\\,j} + u_{i-\\frac{1}{2},\\,j}}{(\\Delta x)^{2}} + \\frac{u_{i+\\frac{1}{2},\\,j+1} - 2\\,u_{i+\\frac{1}{2},\\,j} + u_{i+\\frac{1}{2},\\,j-1}}{(\\Delta y)^{2}} = \\nabla^{2} u(x_{i+\\frac{1}{2}},y_j) + \\mathcal{O}((\\Delta x)^{2}) + \\mathcal{O}((\\Delta y)^{2}).\n$$\n\n剩下的问题是解释为什么交叉导数项 $u_{xy}(x_{i+\\frac{1}{2}},y_j)$ 没有出现在所构建的离散算子中。考虑 $u$ 在 $(x_{0},y_{0})$ 点关于 $(x_{0}+h,y_{0}+k)$ 的二维泰勒展开：\n$$\nu(x_{0}+h,y_{0}+k) = u(x_{0},y_{0}) + h\\, u_{x} + k\\, u_{y} + \\frac{h^{2}}{2}\\, u_{xx} + h k\\, u_{xy} + \\frac{k^{2}}{2}\\, u_{yy} + \\cdots,\n$$\n其中所有导数均在 $(x_{0},y_{0})$ 处计算。混合导数 $u_{xy}$ 乘以乘积 $h k$。在上面用于近似 $u_{xx}$ 和 $u_{yy}$ 的格式中，偏移量完全沿着一个坐标轴：对于 $u_{xx}$，点具有 $(h,k)=(\\pm \\Delta x,0)$，对于 $u_{yy}$，点具有 $(h,k)=(0,\\pm \\Delta y)$。在这两种情况下，$h k = 0$，因此在所选格式点的展开式中，混合导数项恒为零。此外，根据定义，笛卡尔坐标系中的拉普拉斯算子不包含交叉导数，$\\nabla^{2} u = u_{xx} + u_{yy}$，这反映了坐标方向的正交性和度量系数的均匀性。因此，当将离散拉普拉斯算子构造为两个解耦的二阶导数之和时，不会引入交叉导数项，并且所构建的算子是一个以 $(i+\\tfrac{1}{2},j)$ 为中心的五点格式，仅涉及沿坐标轴排列的邻点。\n\n因此，在均匀笛卡尔 MAC 交错网格上，于 $(i+\\tfrac{1}{2},j)$ 处的 $\\nabla^{2} u$ 的二阶中心差分近似为\n$$\n\\frac{u_{i+\\frac{3}{2},\\,j} - 2\\,u_{i+\\frac{1}{2},\\,j} + u_{i-\\frac{1}{2},\\,j}}{(\\Delta x)^{2}} + \\frac{u_{i+\\frac{1}{2},\\,j+1} - 2\\,u_{i+\\frac{1}{2},\\,j} + u_{i+\\frac{1}{2},\\,j-1}}{(\\Delta y)^{2}},\n$$\n其截断误差为 $\\mathcal{O}((\\Delta x)^{2}) + \\mathcal{O}((\\Delta y)^{2})$，并且由于网格的正交性和格式点的轴向排列，所有交叉导数项都消失了。",
            "answer": "$$\\boxed{\\frac{u_{i+\\frac{3}{2},\\,j} - 2\\,u_{i+\\frac{1}{2},\\,j} + u_{i-\\frac{1}{2},\\,j}}{(\\Delta x)^{2}} + \\frac{u_{i+\\frac{1}{2},\\,j+1} - 2\\,u_{i+\\frac{1}{2},\\,j} + u_{i+\\frac{1}{2},\\,j-1}}{(\\Delta y)^{2}}}$$"
        },
        {
            "introduction": "理想网格上的理论推导是基础，但真实世界的CFD应用几乎总是涉及与计算网格不符的复杂几何形状。在这些弯曲或不规则表面上施加边界条件的方式，会显著影响模拟的准确性和稳定性。这个动手编程问题  旨在弥合理论与实现之间的差距，它要求你构建一个数值实验，以量化不同边界条件方案所产生的误差，即所谓的“数值滑移”。通过测量局部质量守恒的违背程度，你将对稳健CFD代码开发的一个关键方面获得实践性的洞察。",
            "id": "3346576",
            "problem": "要求您在二维 Marker-And-Cell (MAC) 交错网格上，使用一种鬼点（ghost-cell）方法处理动量分量，为曲面固体边界上的数值滑移实现一个量化测试。其目的是测量将壁面法向速度插值到面中心如何改变近壁流体单元中的离散散度，从而评估在曲面壁面处强制执行边界条件所引入的质量守恒误差。\n\n基本原理和设置：\n- 从不可压缩流的质量守恒定律开始，即连续性方程 $\\nabla \\cdot \\boldsymbol{u} = 0$，其中 $\\boldsymbol{u} = (u,v)$ 是速度。\n- 在单位正方形域 $[0,1] \\times [0,1]$ 上使用一个具有 $N \\times N$ 控制体的二维 MAC 网格。网格间距为 $\\Delta x = \\Delta y = 1/N$。\n- 交错速度分量：水平分量 $u$ 存储在垂直面中心 $(x_{i+\\frac{1}{2}}, y_j)$，垂直分量 $v$ 存储在水平面中心 $(x_i, y_{j+\\frac{1}{2}})$，其中单元中心的坐标为 $x_i = (i+\\tfrac{1}{2}) \\Delta x$，面的坐标为 $x_{i+\\frac{1}{2}} = i \\Delta x$，$y$ 的定义与此类似。\n- 使用单元中心上的指示函数嵌入一个圆形固体障碍物。该固体是一个以 $(c_x,c_y) = (0.5,0.5)$ 为中心、半径为 $R$ 的圆盘。如果位于中心 $(x_i,y_j)$ 的单元满足 $(x_i - c_x)^2 + (y_j - c_y)^2 < R^2$，则该单元为固体，否则为流体。\n- 采用一个光滑、无散度的制造速度场作为基准：围绕 $(c_x,c_y)$ 的刚体旋转，角速度为 $\\omega = 1$，即 $u(x,y) = -\\omega (y - c_y)$ 和 $v(x,y) = \\omega (x - c_x)$，该速度场恒满足 $\\partial u/\\partial x + \\partial v/\\partial y = 0$。\n\n离散散度：\n- 对于任意流体单元 $(i,j)$，定义离散散度算子\n$$\n(\\nabla_h \\cdot \\boldsymbol{u})_{i,j} \\equiv \\frac{u_{i+\\frac{1}{2},j} - u_{i-\\frac{1}{2},j}}{\\Delta x} + \\frac{v_{i,j+\\frac{1}{2}} - v_{i,j-\\frac{1}{2}}}{\\Delta y}.\n$$\n- “近壁”单元是指其四个相邻（共享一个面）单元中至少有一个被标记为固体的流体单元。\n\n交错网格上的曲面边界处理：\n- 对于位于流体单元和固体单元之间的任何面（“边界面”），您必须用一个与边界一致的值替换基准的面法向速度。考虑两种方案：\n  1. 朴素置零法（记为“zero”）：将边界面上的面法向速度设置为 $0$。\n  2. 到壁面的线性插值法（记为“linear”）：将壁面视为沿面法向方向距离面中心为 $d$ 的位置。设 $U_1$ 是沿相同法向方向、距离壁面一个网格间距的下一个内部面上的面法向速度。通过将边界面速度 $U_0$ 设置为以下值来线性地强制执行壁面值 $U(0)=0$：\n  $$\n  U_0 \\equiv U_1 \\frac{d}{d+\\Delta},\n  $$\n  其中 $\\Delta$ 是面法向的网格间距（即，$u$-面为 $\\Delta x$，$v$-面为 $\\Delta y$）。距离 $d$ 是根据从面中心沿相应坐标线到圆交点的几何关系计算得出：\n  - 对于一个位于 $(x_f, y_f)$ 的 $u$-面，若其右侧是固体单元，则使用 $x_w = c_x + \\sqrt{R^2 - (y_f - c_y)^2}$ 和 $d = x_w - x_f$。若固体在其左侧，则使用 $x_w = c_x - \\sqrt{R^2 - (y_f - c_y)^2}$ 和 $d = x_f - x_w$。\n  - 对于一个位于 $(x_f, y_f)$ 的 $v$-面，若其上方是固体单元，则使用 $y_w = c_y + \\sqrt{R^2 - (x_f - c_x)^2}$ 和 $d = y_w - y_f$。若固体在其下方，则使用 $y_w = c_y - \\sqrt{R^2 - (x_f - c_x)^2}$ 和 $d = y_f - y_w$。\n  - 对于非边界面（即相邻单元均为流体），使用在面中心采样的基准（制造）速度。\n\n任务：\n- 实现一个程序来：\n  1. 为给定的 $N$ 和 $R$ 构建 MAC 网格。\n  2. 使用圆形障碍物标记流体与固体单元。\n  3. 在所有面上采样无散度的制造场，以获得基准面速度。\n  4. 根据指定的方案（“zero” 或 “linear”）替换边界面上的面法向速度。\n  5. 计算所有近壁单元中的离散散度，并报告近壁单元上的平均绝对散度。\n\n数值单位和输出：\n- 所有量均为无量纲。以浮点数形式报告平均绝对散度。\n- 对于每个测试用例，输出一个等于近壁单元上离散散度绝对值平均值的浮点数。将报告的每个值四舍五入到 $8$ 位小数。\n\n测试套件：\n- 使用以下六个测试用例，每个由元组 $(N,R,\\text{scheme})$ 指定：\n  - $(32, 0.30, \\text{\"zero\"})$,\n  - $(32, 0.30, \\text{\"linear\"})$,\n  - $(64, 0.30, \\text{\"zero\"})$,\n  - $(64, 0.30, \\text{\"linear\"})$,\n  - $(64, 0.45, \\text{\"zero\"})$,\n  - $(64, 0.45, \\text{\"linear\"})$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表元素必须是与上述测试套件顺序相同的六个四舍五入后的浮点结果。例如，一个可接受的输出格式是\n- $[a_1,a_2,a_3,a_4,a_5,a_6]$,\n其中每个 $a_k$ 是一个四舍五入到 $8$ 位小数的浮点数。",
            "solution": "用户提供了一个计算流体动力学（CFD）领域的计算问题。在进行求解之前，需要对问题陈述进行严格的验证。\n\n### 步骤 1：提取已知条件\n\n-   **控制定律**：不可压缩连续性方程，$\\nabla \\cdot \\boldsymbol{u} = 0$，适用于速度场 $\\boldsymbol{u} = (u,v)$。\n-   **域与网格**：单位正方形 $[0,1] \\times [0,1]$ 被离散化为一个 $N \\times N$ 的二维 Marker-And-Cell (MAC) 交错网格。\n-   **网格间距**：$\\Delta x = \\Delta y = 1/N$。\n-   **网格结构**：\n    -   水平速度 $u$ 存储在垂直面中心 $(x_{i+\\frac{1}{2}}, y_j)$。\n    -   垂直速度 $v$ 存储在水平面中心 $(x_i, y_{j+\\frac{1}{2}})$。\n    -   单元中心坐标：$x_i = (i+\\tfrac{1}{2}) \\Delta x$, $y_j = (j+\\tfrac{1}{2}) \\Delta y$。\n    -   面坐标：$x_{i+\\frac{1}{2}} = i \\Delta x$，$y$ 的定义与此类似。\n-   **固体障碍物**：一个半径为 $R$、中心位于 $(c_x,c_y) = (0.5,0.5)$ 的圆盘。如果单元 $(i,j)$ 的中心 $(x_i,y_j)$ 满足 $(x_i - c_x)^2 + (y_j - c_y)^2  R^2$，则该单元被标记为固体。\n-   **制造速度场**：围绕 $(0.5,0.5)$ 的刚体旋转，角速度 $\\omega = 1$。速度分量为 $u(x,y) = -(y - 0.5)$ 和 $v(x,y) = x - 0.5$。该场解析上是无散度的。\n-   **离散散度**：对于一个流体单元 $(i,j)$，其散度为 $(\\nabla_h \\cdot \\boldsymbol{u})_{i,j} \\equiv \\frac{u_{i+\\frac{1}{2},j} - u_{i-\\frac{1}{2},j}}{\\Delta x} + \\frac{v_{i,j+\\frac{1}{2}} - v_{i,j-\\frac{1}{2}}}{\\Delta y}$。\n-   **近壁单元**：与固体单元共享至少一个面的流体单元。\n-   **边界面速度方案**：对于分隔流体和固体单元的面：\n    1.  **“zero”方案**：面法向速度设为 $0$。\n    2.  **“linear”方案**：边界面速度 $U_0$ 通过线性插值设置：$U_0 \\equiv U_1 \\frac{d}{d+\\Delta}$，其中 $U_1$ 是下一个内部面（距离一个网格间距 $\\Delta$）上的速度，$d$ 是从面中心到圆边界的距离。\n-   **距离 `d` 的计算**：\n    -   对于一个位于 $(x_f, y_f)$ 的 $u$-面：如果右侧是固体，则 $x_w = c_x + \\sqrt{R^2 - (y_f - c_y)^2}$ 且 $d = x_w - x_f$。如果左侧是固体，则 $x_w = c_x - \\sqrt{R^2 - (y_f - c_y)^2}$ 且 $d = x_f - x_w$。\n    -   对于一个位于 $(x_f, y_f)$ 的 $v$-面：如果上方是固体，则 $y_w = c_y + \\sqrt{R^2 - (x_f - c_x)^2}$ 且 $d = y_w - y_f$。如果下方是固体，则 $y_w = c_y - \\sqrt{R^2 - (x_f - c_x)^2}$ 且 $d = y_f - y_w$。\n-   **任务**：对于每个测试用例，计算所有近壁单元上离散散度绝对值的平均值。\n-   **测试用例**：$(32, 0.30, \\text{\"zero\"})$, $(32, 0.30, \\text{\"linear\"})$, $(64, 0.30, \\text{\"zero\"})$, $(64, 0.30, \\text{\"linear\"})$, $(64, 0.45, \\text{\"zero\"})$, $(64, 0.45, \\text{\"linear\"})$。\n-   **输出**：一个包含六个浮点数的列表，四舍五入到 $8$ 位小数。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题是 CFD 中的一个标准练习，旨在研究在交错网格上强制执行边界条件所导致的质量守恒误差（数值滑移）。所提出的方法（“置零”和“线性插值”）是常见但简化的技术。该设置在科学上是合理的。\n-   **适定性**：该问题为计算提供了一个完整的、分步的程序。对于每个测试用例，输入都已定义，操作序列将导出一个唯一的数值结果。\n-   **客观性**：问题以精确、客观的数学和算法语言陈述。\n-   **潜在缺陷检查**：\n    1.  **`d` 公式中的过度简化**：规定的壁面位置 $x_w$ 和 $y_w$ 的公式对右侧/上方的固体单元使用 `+`，对左侧/下方的固体单元使用 `-`。这仅当面分别位于圆形障碍物的左半部分/下半部分时才是物理上正确的。这是一个重大的简化，忽略了圆另一半的几何形状。然而，问题陈述明确指定了使用这个确切的公式。任务是实现和测试*这个特定的方案*，而不是一个物理上修正的方案。由此产生的误差是衡量该方案（不）准确性的一个指标。\n    2.  **平方根的有效性**：距离 $d$ 的计算涉及一个平方根 $\\sqrt{R^2 - \\text{dist}^2}$。一个潜在的问题是根号内的参数可能变为负数。然而，基于单元中心到圆心的距离来标记固体单元的方法确保了任何相邻的边界面其坐标都将位于圆的投影范围内，从而保证了平方根的参数为非负数。因此，该计算在这方面是稳健的。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。尽管存在物理上简化的边界位置模型，但指令在算法上是明确且自洽的。该问题的目的似乎是对这些特定的、简化的方案进行定量评估。因此，我将完全按照规定来实现该程序，以进行求解。\n\n### 算法解决方案\n对于每个测试用例 $(N, R, \\text{scheme})$，通过以下步骤实现解决方案。\n\n1.  **网格与几何定义**：在 $[0,1] \\times [0,1]$ 域上建立一个 $N \\times N$ 的网格，网格间距为 $\\Delta x = \\Delta y = 1/N$。创建一个大小为 $N \\times N$ 的布尔数组 `is_solid`。如果单元 $(i,j)$ 的中心位于以 $(0.5,0.5)$ 为中心、半径为 $R$ 的圆内，则将其标记为固体。\n\n2.  **基准速度场初始化**：用制造速度场 $u(x,y) = -(y-0.5)$ 和 $v(x,y) = x-0.5$ 在相应面中心采样得到的值填充两个数组，大小分别为 $(N+1) \\times N$ 的 `U_base` 和 $N \\times (N+1)$ 的 `V_base`。该基准场的解析散度为零，其在 MAC 网格上的离散散度也恒为零。\n\n3.  **边界条件强制执行**：创建基准速度数组 `U` 和 `V` 的副本。然后在边界面（即分隔流体单元和固体单元的面）上修改这些数组。\n    -   对于每个这样的边界面，根据指定的方案重新计算其法向速度。\n    -   **“zero”方案**：面法向速度设为 $0$。\n    -   **“linear”方案**：面法向速度 $U_0$ 计算为 $U_0 = U_1 \\frac{d}{d+\\Delta}$。这里的 $d$ 是从面中心到壁面的距离，使用问题陈述中明确（尽管简化）的公式计算。$U_1$ 是制造场在下一个内部面上的速度，$\\Delta$ 是网格间距。此过程应用于所有垂直（$u$）和水平（$v$）的边界面。\n\n4.  **散度计算**：识别出“近壁”流体单元列表（即至少有一个固体邻居的流体单元）。对于此列表中的每个单元，使用修改后的速度场 `U` 和 `V` 计算离散散度：\n    $$\n    (\\nabla_h \\cdot \\boldsymbol{u})_{i,j} = \\frac{U_{i+1,j} - U_{i,j}}{\\Delta x} + \\frac{V_{i,j+1} - V_{i,j}}{\\Delta y}\n    $$\n    其中 `U` 和 `V` 上的索引对应于单元 $(i,j)$ 的面。\n\n5.  **结果聚合**：对每个近壁单元计算其散度的绝对值。然后计算这些绝对值的平均值。这个最终值代表了在给定参数下，边界方案引入的平均质量守恒误差。对所有六个测试用例重复此过程。\n\n此过程正确地量化了每个边界条件方案所引入的误差，因为任何非零散度都完全源于在边界面上所做的修改。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 0.30, \"zero\"),\n        (32, 0.30, \"linear\"),\n        (64, 0.30, \"zero\"),\n        (64, 0.30, \"linear\"),\n        (64, 0.45, \"zero\"),\n        (64, 0.45, \"linear\"),\n    ]\n\n    results = []\n    for N, R, scheme in test_cases:\n        result = run_simulation(N, R, scheme)\n        results.append(f\"{result:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef run_simulation(N, R, scheme):\n    \"\"\"\n    Performs the simulation for a single test case.\n\n    Args:\n        N (int): Grid resolution (N x N).\n        R (float): Radius of the circular obstacle.\n        scheme (str): Boundary condition scheme (\"zero\" or \"linear\").\n\n    Returns:\n        float: The mean absolute divergence over near-wall cells.\n    \"\"\"\n    # 1. Grid setup\n    dx = 1.0 / N\n    dy = 1.0 / N\n    cx, cy = 0.5, 0.5\n    omega = 1.0\n\n    # 2. Mark solid vs. fluid cells\n    # Cell centers are at ((i+0.5)*dx, (j+0.5)*dy)\n    cell_centers_x = (np.arange(N) + 0.5) * dx\n    cell_centers_y = (np.arange(N) + 0.5) * dy\n    is_solid = np.zeros((N, N), dtype=bool)\n    for i in range(N):\n        for j in range(N):\n            dist_sq = (cell_centers_x[i] - cx)**2 + (cell_centers_y[j] - cy)**2\n            if dist_sq  R**2:\n                is_solid[i, j] = True\n\n    # 3. Sample baseline manufactured velocity field\n    # U-velocities at vertical faces: (i*dx, (j+0.5)*dy) for i in 0..N, j in 0..N-1\n    U_base = np.zeros((N + 1, N))\n    u_face_y_coords = (np.arange(N) + 0.5) * dy\n    U_base[:, :] = -omega * (u_face_y_coords[np.newaxis, :] - cy)\n    \n    # V-velocities at horizontal faces: ((i+0.5)*dx, j*dy) for i in 0..N-1, j in 0..N\n    V_base = np.zeros((N, N + 1))\n    v_face_x_coords = (np.arange(N) + 0.5) * dx\n    V_base[:, :] = omega * (v_face_x_coords[:, np.newaxis] - cx)\n\n    # 4. Apply boundary conditions\n    U = np.copy(U_base)\n    V = np.copy(V_base)\n\n    # Modify U on vertical boundary faces\n    # Face U[i, j] is between cells (i-1, j) and (i, j)\n    for i in range(1, N): # Internal vertical faces only\n        for j in range(N):\n            is_left_solid = is_solid[i - 1, j]\n            is_right_solid = is_solid[i, j]\n\n            if is_left_solid != is_right_solid:\n                if scheme == 'zero':\n                    U[i, j] = 0.0\n                elif scheme == 'linear':\n                    xf = i * dx\n                    yf = (j + 0.5) * dy\n                    sqrt_arg = R**2 - (yf - cy)**2\n                    if sqrt_arg = 0:\n                        sqrt_val = np.sqrt(sqrt_arg)\n                        if is_right_solid:\n                            # Formula as specified in the problem for solid on right\n                            xw = cx + sqrt_val\n                            d = xw - xf\n                            U1 = U_base[i - 1, j]\n                            U[i, j] = U1 * d / (d + dx) if (d + dx)  1e-12 else 0.0\n                        else: # is_left_solid\n                            # Formula as specified for solid on left\n                            xw = cx - sqrt_val\n                            d = xf - xw\n                            U1 = U_base[i + 1, j]\n                            U[i, j] = U1 * d / (d + dx) if (d + dx)  1e-12 else 0.0\n    \n    # Modify V on horizontal boundary faces\n    # Face V[i, j] is between cells (i, j-1) and (i, j)\n    for j in range(1, N): # Internal horizontal faces only\n        for i in range(N):\n            is_bottom_solid = is_solid[i, j - 1]\n            is_top_solid = is_solid[i, j]\n\n            if is_bottom_solid != is_top_solid:\n                if scheme == 'zero':\n                    V[i, j] = 0.0\n                elif scheme == 'linear':\n                    xf = (i + 0.5) * dx\n                    yf = j * dy\n                    # Using corrected formula (xf-cx) instead of (xf-cy) as per validation\n                    sqrt_arg = R**2 - (xf - cx)**2\n                    if sqrt_arg = 0:\n                        sqrt_val = np.sqrt(sqrt_arg)\n                        if is_top_solid:\n                            yw = cy + sqrt_val\n                            d = yw - yf\n                            U1 = V_base[i, j - 1]\n                            V[i, j] = U1 * d / (d + dy) if (d + dy)  1e-12 else 0.0\n                        else: # is_bottom_solid\n                            yw = cy - sqrt_val\n                            d = yf - yw\n                            U1 = V_base[i, j + 1]\n                            V[i, j] = U1 * d / (d + dy) if (d + dy)  1e-12 else 0.0\n\n    # 5. Compute mean absolute divergence in near-wall cells\n    total_abs_div = 0.0\n    near_wall_cell_count = 0\n\n    for i in range(N):\n        for j in range(N):\n            if not is_solid[i, j]: # Must be a fluid cell\n                is_near_wall = False\n                if i  0 and is_solid[i - 1, j]: is_near_wall = True\n                if not is_near_wall and i  N - 1 and is_solid[i + 1, j]: is_near_wall = True\n                if not is_near_wall and j  0 and is_solid[i, j - 1]: is_near_wall = True\n                if not is_near_wall and j  N - 1 and is_solid[i, j + 1]: is_near_wall = True\n                \n                if is_near_wall:\n                    near_wall_cell_count += 1\n                    u_east = U[i + 1, j]\n                    u_west = U[i, j]\n                    v_north = V[i, j + 1]\n                    v_south = V[i, j]\n                    \n                    div = (u_east - u_west) / dx + (v_north - v_south) / dy\n                    total_abs_div += abs(div)\n\n    if near_wall_cell_count == 0:\n        return 0.0\n    \n    mean_abs_div = total_abs_div / near_wall_cell_count\n    return mean_abs_div\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}