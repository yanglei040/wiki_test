{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握Chorin投影法，我们必须首先理解其离散形式的构成。本练习将指导您在一个简单的一维交错网格上，从零开始构建基本的离散算子——散度、梯度和拉普拉斯算子。通过手动执行一个精确的投影步骤，您将对压力如何在代数层面确保不可压缩性获得一个具体而深刻的理解。",
            "id": "3301246",
            "problem": "考虑在一个长度为 $L$ 的通道中，在 $x=0$ 和 $x=L$ 处为无滑移壁面的情况下，基于Marker-and-Cell (MAC) 网格的一维空间不可压缩Navier–Stokes方程。速度存储在面中心位置，压力存储在单元中心位置。设有 $N$ 个大小均匀的控制体（单元），单元中心的索引为 $i=1,\\dots,N$，面的索引为 $j=0,\\dots,N$。网格间距为 $h=L/N$。与通道方向一致的速度分量用 $u$ 表示，不可压缩性要求在投影后每个单元内的离散散度为零。Chorin方法的投影步通过求解压力的离散泊松方程，然后修正中间速度，来强制满足不可压缩性条件。\n\n从质量守恒的有限体积陈述（每个单元的面法向通量的离散散度）和内部面上压力梯度的中心差分近似（壁面处采用与无滑移和零法向压力梯度一致的齐次Neumann边界条件）出发，针对 $N=4$, $L=1$ 米, $h=L/N$, 密度 $\\rho=1$ kg/m$^{3}$ 及时间步长 $\\Delta t=0.2$ 秒的特定情况，完成以下任务：\n\n1. 定义离散散度算子 $D \\in \\mathbb{R}^{N \\times (N+1)}$，该算子使用二阶有限体积通量差分，将面速度 $\\boldsymbol{u} \\in \\mathbb{R}^{N+1}$ 映射到单元中心的散度。写出其对于排序 $\\boldsymbol{u} = \\big(u_0,u_1,\\dots,u_N\\big)^{\\mathsf{T}}$ 和 $\\boldsymbol{d} = D \\boldsymbol{u}$（其中 $\\boldsymbol{d} \\in \\mathbb{R}^{N}$ 按单元 $i=1,\\dots,N$ 排序）的显式矩阵元素。\n\n2. 定义离散梯度算子 $G \\in \\mathbb{R}^{(N+1) \\times N}$，该算子将单元中心的压力 $\\boldsymbol{p} \\in \\mathbb{R}^{N}$ 映射到面中心的压力梯度，其中在内部面 $j=1,\\dots,N-1$ 上使用中心差分，在边界面 $j=0$ 和 $j=N$ 上使用齐次Neumann条件。写出其显式矩阵元素。\n\n3. 构建离散压力拉普拉斯算子 $L = D G \\in \\mathbb{R}^{N \\times N}$ 并写出其显式矩阵形式。陈述Neumann问题的可解性条件以及您将用来获得唯一解压力的规范约束。\n\n4. 给定中间面速度向量（单位：m/s）\n$$\n\\boldsymbol{u}^{\\ast} \\;=\\; \\big(0,\\;0.8,\\;-0.4,\\;0.6,\\;0\\big)^{\\mathsf{T}},\n$$\n从第一性原理推导投影步中压力的离散泊松方程，并求解唯一的零均值离散压力 $\\boldsymbol{p} \\in \\mathbb{R}^{N}$（单位：Pa）。然后通过在壁面处强制无滑移的投影更新来计算修正后的面速度。\n\n第二个单元中心处的压力值 $p_2$（单位：Pa）是多少？将您的答案四舍五入到四位有效数字，并以帕斯卡（Pa）为单位表示。",
            "solution": "该问题要求计算在用于不可压缩Navier-Stokes方程的Chorin方法的投影步中，第二个单元中心处的压力值 $p_2$。该问题定义明确，并提供了所有必要的数据和边界条件。我们将系统地构建离散算子，并求解得到的压力泊松方程。\n\n该特定情况的给定参数如下：\n- 单元数：$N=4$\n- 通道长度：$L=1$ m\n- 单元宽度：$h = \\frac{L}{N} = \\frac{1}{4} = 0.25$ m\n- 流体密度：$\\rho=1$ kg/m$^3$\n- 时间步长：$\\Delta t = 0.2$ s\n- 中间速度向量：$\\boldsymbol{u}^{\\ast} = \\big(0, 0.8, -0.4, 0.6, 0\\big)^{\\mathsf{T}}$ m/s\n\n**1. 离散散度算子 $D$**\n\n离散散度算子 $D$ 将面中心的速度 $\\boldsymbol{u} = \\big(u_0, u_1, u_2, u_3, u_4\\big)^{\\mathsf{T}}$ 映射到单元中心的散度 $\\boldsymbol{d} = \\big(d_1, d_2, d_3, d_4\\big)^{\\mathsf{T}}$。对于均匀网格，单元 $i$（其面为 $i-1$ 和 $i$）中的散度是单位体积（二维情况下为单位面积，一维情况下为单位长度）的净通量，由下式给出：\n$$\nd_i = (\\nabla \\cdot \\boldsymbol{u})_i = \\frac{u_i - u_{i-1}}{h}\n$$\n对于 $i=1, \\dots, N$。这定义了 $N \\times (N+1)$ 矩阵 $D$ 的行。当 $N=4$ 且 $h=0.25$ 时，$1/h=4$，算子为：\n$$\n\\boldsymbol{d} = D\\boldsymbol{u} = \\frac{1}{h}\n\\begin{pmatrix}\n-1  1  0  0  0 \\\\\n0  -1  1  0  0 \\\\\n0  0  -1  1  0 \\\\\n0  0  0  -1  1\n\\end{pmatrix}\n\\begin{pmatrix} u_0 \\\\ u_1 \\\\ u_2 \\\\ u_3 \\\\ u_4 \\end{pmatrix}\n=\n4\n\\begin{pmatrix}\n-1  1  0  0  0 \\\\\n0  -1  1  0  0 \\\\\n0  0  -1  1  0 \\\\\n0  0  0  -1  1\n\\end{pmatrix}\n\\begin{pmatrix} u_0 \\\\ u_1 \\\\ u_2 \\\\ u_3 \\\\ u_4 \\end{pmatrix}\n$$\n\n**2. 离散梯度算子 $G$**\n\n离散梯度算子 $G$ 将单元中心的压力 $\\boldsymbol{p} = \\big(p_1, p_2, p_3, p_4\\big)^{\\mathsf{T}}$ 映射到面中心的梯度 $(\\nabla p)_j$。\n- 对于内部面 $j=1, \\dots, N-1$，使用中心差分。面 $j$（位于单元 $j$ 和 $j+1$ 之间）处的梯度为：\n  $$ (\\nabla p)_j = \\frac{p_{j+1} - p_j}{h} $$\n- 对于边界面 $j=0$ 和 $j=N=4$，应用齐次Neumann条件 $(\\nabla p)_0 = 0$ 和 $(\\nabla p)_N = 0$。\n\n这定义了 $(N+1) \\times N$ 矩阵 $G$：\n$$\nG \\boldsymbol{p} = \\frac{1}{h}\n\\begin{pmatrix}\n0  0  0  0 \\\\\n-1  1  0  0 \\\\\n0  -1  1  0 \\\\\n0  0  -1  1 \\\\\n0  0  0  0\n\\end{pmatrix}\n\\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\\\ p_4 \\end{pmatrix}\n=\n4\n\\begin{pmatrix}\n0  0  0  0 \\\\\n-1  1  0  0 \\\\\n0  -1  1  0 \\\\\n0  0  -1  1 \\\\\n0  0  0  0\n\\end{pmatrix}\n\\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\\\ p_4 \\end{pmatrix}\n$$\n对于此类离散化，一个常见的性质是，如果我们忽略边界条件，$G$ 是 $D$ 的负转置，即 $D = -G^{\\mathsf{T}}$。$G$ 中的零行代表Neumann边界条件。\n\n**3. 离散压力拉普拉斯算子 $L = DG$**\n\n离散拉普拉斯算子是一个由乘积 $L=DG$ 构成的 $N \\times N$ 矩阵。\n$$\nL = DG = \\frac{1}{h^2}\n\\begin{pmatrix}\n-1  1  0  0  0 \\\\\n0  -1  1  0  0 \\\\\n0  0  -1  1  0 \\\\\n0  0  0  -1  1\n\\end{pmatrix}\n\\begin{pmatrix}\n0  0  0  0 \\\\\n-1  1  0  0 \\\\\n0  -1  1  0 \\\\\n0  0  -1  1 \\\\\n0  0  0  0\n\\end{pmatrix}\n$$\n执行矩阵乘法可得：\n$$\nL = \\frac{1}{h^2}\n\\begin{pmatrix}\n-1  1  0  0 \\\\\n1  -2  1  0 \\\\\n0  1  -2  1 \\\\\n0  0  1  -1\n\\end{pmatrix}\n$$\n代入 $h=0.25$，我们得到 $1/h^2 = 1/(0.0625) = 16$。\n$$\nL = 16\n\\begin{pmatrix}\n-1  1  0  0 \\\\\n1  -2  1  0 \\\\\n0  1  -2  1 \\\\\n0  0  1  -1\n\\end{pmatrix}\n$$\n这是带有Neumann边界条件的二阶导数的标准一维有限差分表示。每行元素之和为零，这意味着矩阵 $L$ 是奇异的。其零空间由常数向量 $\\boldsymbol{c} = (c, c, \\dots, c)^{\\mathsf{T}}$ 组成。Neumann问题 $L\\boldsymbol{p} = \\boldsymbol{f}$ 的可解性条件是右端向量 $\\boldsymbol{f}$ 必须与 $L^{\\mathsf{T}}$ 的零空间正交。由于 $L$ 是对称的（$L=L^{\\mathsf{T}}$），这意味着 $\\boldsymbol{f}$ 必须与常数向量正交，这要求其分量之和为零：$\\sum_{i=1}^N f_i = 0$。为了获得 $\\boldsymbol{p}$ 的唯一解，需要施加一个规范约束，例如固定一个压力值或要求平均压力为零（如题目所要求）：$\\sum_{i=1}^N p_i = 0$。\n\n**4. 求解压力**\n\n投影步涉及求解压力的泊松方程，该方程修正中间速度场 $\\boldsymbol{u}^*$ 使其无散度。更新步为 $\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^* - \\frac{\\Delta t}{\\rho} \\nabla p$。要求 $\\nabla \\cdot \\boldsymbol{u}^{n+1}=0$ 会得到压力泊松方程：\n$$\n\\nabla^2 p = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\boldsymbol{u}^*\n$$\n其离散形式为 $L\\boldsymbol{p} = \\frac{\\rho}{\\Delta t} D\\boldsymbol{u}^*$。\n\n首先，我们计算右端项 $\\boldsymbol{f} = \\frac{\\rho}{\\Delta t} D\\boldsymbol{u}^*$。\n$$\n\\frac{\\rho}{\\Delta t} = \\frac{1 \\text{ kg/m}^3}{0.2 \\text{ s}} = 5 \\text{ kg/(m}^3 \\cdot \\text{s)}\n$$\n$$\nD\\boldsymbol{u}^* = \\frac{1}{h}\n\\begin{pmatrix} u_1^* - u_0^* \\\\ u_2^* - u_1^* \\\\ u_3^* - u_2^* \\\\ u_4^* - u_3^* \\end{pmatrix}\n= 4\n\\begin{pmatrix} 0.8 - 0 \\\\ -0.4 - 0.8 \\\\ 0.6 - (-0.4) \\\\ 0 - 0.6 \\end{pmatrix}\n= 4\n\\begin{pmatrix} 0.8 \\\\ -1.2 \\\\ 1.0 \\\\ -0.6 \\end{pmatrix}\n=\n\\begin{pmatrix} 3.2 \\\\ -4.8 \\\\ 4.0 \\\\ -2.4 \\end{pmatrix} \\text{ s}^{-1}\n$$\n各分量之和为 $3.2 - 4.8 + 4.0 - 2.4 = 0$，满足可解性条件。现在，我们计算 $\\boldsymbol{f}$：\n$$\n\\boldsymbol{f} = 5 \\times D\\boldsymbol{u}^* =\n5 \\begin{pmatrix} 3.2 \\\\ -4.8 \\\\ 4.0 \\\\ -2.4 \\end{pmatrix}\n=\n\\begin{pmatrix} 16 \\\\ -24 \\\\ 20 \\\\ -12 \\end{pmatrix} \\text{ Pa/m}^2\n$$\n待求解的线性系统为 $L\\boldsymbol{p} = \\boldsymbol{f}$：\n$$\n16\n\\begin{pmatrix}\n-1  1  0  0 \\\\\n1  -2  1  0 \\\\\n0  1  -2  1 \\\\\n0  0  1  -1\n\\end{pmatrix}\n\\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\\\ p_4 \\end{pmatrix}\n=\n\\begin{pmatrix} 16 \\\\ -24 \\\\ 20 \\\\ -12 \\end{pmatrix}\n$$\n两边同除以 $16$ 得到方程组：\n1.  $-p_1 + p_2 = 1$\n2.  $p_1 - 2p_2 + p_3 = -1.5$\n3.  $p_2 - 2p_3 + p_4 = 1.25$\n4.  $p_3 - p_4 = -0.75$\n\n我们用零均值规范约束来补充这些方程：\n5.  $p_1 + p_2 + p_3 + p_4 = 0$\n\n由方程(1)可得，$p_1 = p_2 - 1$。\n由方程(4)可得，$p_4 = p_3 + 0.75$。\n将 $p_1$ 代入方程(2)：\n$(p_2 - 1) - 2p_2 + p_3 = -1.5 \\implies -p_2 + p_3 = -0.5 \\implies p_3 = p_2 - 0.5$。\n现在用 $p_2$ 表示 $p_4$：\n$p_4 = p_3 + 0.75 = (p_2 - 0.5) + 0.75 = p_2 + 0.25$。\n\n我们已经将所有压力用 $p_2$ 表示：\n- $p_1 = p_2 - 1$\n- $p_2 = p_2$\n- $p_3 = p_2 - 0.5$\n- $p_4 = p_2 + 0.25$\n\n现在，将这些代入规范约束(5)：\n$$ (p_2 - 1) + p_2 + (p_2 - 0.5) + (p_2 + 0.25) = 0 $$\n$$ 4p_2 - 1.25 = 0 $$\n$$ 4p_2 = 1.25 $$\n$$ p_2 = \\frac{1.25}{4} = \\frac{5/4}{4} = \\frac{5}{16} = 0.3125 $$\n第二个单元中心处的压力值 $p_2$ 为 $0.3125$ Pa。题目要求答案四舍五入到四位有效数字，这恰好是 $0.3125$。\n\n作为最终验证，我们可以计算修正后的速度场 $\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^* - \\frac{\\Delta t}{\\rho} G \\boldsymbol{p}$。\n压力向量为 $\\boldsymbol{p} = (-0.6875, 0.3125, -0.1875, 0.5625)^{\\mathsf{T}}$。\n压力梯度项为：\n$$\n\\frac{\\Delta t}{\\rho} G \\boldsymbol{p} = 0.2 \\times 4 \\times\n\\begin{pmatrix}\n0 \\\\\np_2 - p_1 \\\\\np_3 - p_2 \\\\\np_4 - p_3 \\\\\n0\n\\end{pmatrix}\n= 0.8\n\\begin{pmatrix}\n0 \\\\\n0.3125 - (-0.6875) \\\\\n-0.1875 - 0.3125 \\\\\n0.5625 - (-0.1875) \\\\\n0\n\\end{pmatrix}\n= 0.8\n\\begin{pmatrix}\n0 \\\\\n1 \\\\\n-0.5 \\\\\n0.75 \\\\\n0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n0.8 \\\\\n-0.4 \\\\\n0.6 \\\\\n0\n\\end{pmatrix}\n$$\n修正后的速度为：\n$$\n\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^* - \\frac{\\Delta t}{\\rho} G \\boldsymbol{p} = \\begin{pmatrix} 0 \\\\ 0.8 \\\\ -0.4 \\\\ 0.6 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ 0.8 \\\\ -0.4 \\\\ 0.6 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n最终速度处处为零。它显然是无散度的（$D\\boldsymbol{u}^{n+1} = \\boldsymbol{0}$）并且满足无滑移边界条件（$u_0^{n+1}=0, u_4^{n+1}=0$）。这证实了计算的正确性。\n\n第二个单元中心处的压力值 $p_2$ 是 $0.3125$ Pa。",
            "answer": "$$\\boxed{0.3125}$$"
        },
        {
            "introduction": "在实际应用中，压力泊松方程通常通过迭代法求解，因此解是不精确的。本练习探讨了这种不精确性对质量守恒这一物理原则的直接影响。您将首先推导，然后通过数值模拟来验证线性求解器残差与最终速度场的散度误差之间的关键关系，从而揭示求解器收敛判据如何直接控制最终流场的不可压缩性程度。",
            "id": "3301215",
            "problem": "考虑不可压缩Navier–Stokes方程和一个算子分裂格式，其中速度通过一个投影步来更新以强制施加不可压缩性。在Chorin的投影法中，首先使用不含压力项的动量方程推进到一个中间速度场$u^\\ast$，然后通过求解一个类压力变量$p$的泊松方程并进行投影来施加不可压缩性：\n$$\nu^{n+1} \\leftarrow u^\\ast - \\frac{\\Delta t}{\\rho}\\,\\nabla p,\n$$\n其目的是使修正后的速度满足离散无散约束。假设在一个周期性方形域$[0,1]^2$上有一个均匀笛卡尔网格，每个方向的网格间距为$h = 1/N$，采用交錯的标记-网格（MAC）离散化：水平速度分量位于水平面的中心，垂直速度分量位于垂直面的中心，而压力和散度位于单元中心。记$\\nabla_h \\cdot$为将面心速度映射到单元中心的MAC离散散度，记$\\nabla_h$为将单元中心压力映射到面的MAC离散梯度，记$L_h$为单元中心的标准五点离散拉普拉斯算子。在周期性边界条件下，MAC算子满足相容性恒等式$\\nabla_h \\cdot \\nabla_h p = L_h p$。令$\\|\\cdot\\|_{2}$表示所有网格值的向量的未加权欧几里得范数，令$\\|\\cdot\\|_{L^2_h}$表示定义在域上的离散$L^2$范数，其定义为\n$$\n\\|q\\|_{L^2_h} \\equiv \\left( \\sum_{i,j} |q_{i,j}|^2\\, h^2 \\right)^{1/2}.\n$$\n在压力投影中，通过求解离散泊松方程来计算类压力变量$p_h$\n$$\nL_h p_h = b_h, \\quad \\text{with} \\quad b_h = \\frac{\\rho}{\\Delta t} \\, (\\nabla_h \\cdot u^\\ast),\n$$\n但假设线性求解是不精确的，并在残差$r_h = L_h p_h - b_h$满足某个停止准则时终止。然后使用这个不精确的$p_h$执行投影。两种常见的停止准则是：\n1. 绝对容差：对于给定的$\\varepsilon_{\\mathrm{abs}} > 0$，$\\|r_h\\|_{2} \\le \\varepsilon_{\\mathrm{abs}}$。\n2. 相对容差：对于给定的$\\varepsilon_{\\mathrm{rel}} > 0$，$\\|r_h\\|_{2} \\le \\varepsilon_{\\mathrm{rel}} \\, \\|b_h\\|_{2}$。\n\n仅从MAC离散化的基本性质、投影更新的定义以及上述范数出发，推导修正后速度中的离散质量守恒误差（由离散$L^2$范数$\\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$度量）、求解器容差（$\\varepsilon_{\\mathrm{abs}}$或$\\varepsilon_{\\mathrm{rel}}$）和网格间距$h$之间的定量关系。使用$\\rho = 1$和$\\Delta t = 1$的无量纲单位。\n\n然后实现一个程序，通过在均匀周期性网格上的相应面位置采样连续场\n$$\nu_x(x,y) = \\sin(2\\pi x)\\,\\sin(2\\pi y), \\qquad u_y(x,y) = \\cos(2\\pi x)\\,\\sin(2\\pi y),\n$$\n来构造MAC网格上的光滑面心速度中间场$u^\\ast_h$，计算相应的$b_h = \\nabla_h \\cdot u^\\ast_h$（在单元中心），并根据推导出的关系，在两种停止准则下，评估预测的离散质量守恒误差$\\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$，而无需实际求解线性系统。使用连接$\\nabla_h \\cdot u^{n+1}$与残差$r_h$的恒等式以及离散范数之间的关系来评估给定容差下的误差大小。\n\n构建以下测试套件以探测不同的标度关系：\n- 固定网格分辨率下绝对容差的标度关系：固定$N = 64$，使用$\\varepsilon_{\\mathrm{abs}} \\in \\{10^{-6}, 5\\times 10^{-7}, 2.5\\times 10^{-7}\\}$，计算$\\log \\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$对$\\log \\varepsilon_{\\mathrm{abs}}$的斜率（以e为底的对数回归）。\n- 固定容差下绝对容差与网格间距的标度关系：固定$\\varepsilon_{\\mathrm{abs}} = 10^{-6}$，使用$N \\in \\{32, 64, 128\\}$（因此$h \\in \\{1/32,1/64,1/128\\}$），计算$\\log \\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$对$\\log h$的斜率。\n- 固定网格分辨率下相对容差的标度关系：固定$N = 64$，使用$\\varepsilon_{\\mathrm{rel}} \\in \\{10^{-6}, 5\\times 10^{-7}, 2.5\\times 10^{-7}\\}$，计算$\\log \\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$对$\\log \\varepsilon_{\\mathrm{rel}}$的斜率。\n- 固定容差下相对容差与网格间距的标度关系：固定$\\varepsilon_{\\mathrm{rel}} = 10^{-6}$，使用$N \\in \\{32, 64, 128\\}$，计算$\\log \\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$对$\\log h$的斜率。\n\n对于上述四个要点中的每一个，通过对数据点对$(\\log x,\\log y)$进行线性最小二乘拟合来估计斜率，其中$x$相应地为$\\varepsilon_{\\mathrm{abs}}$、$h$、$\\varepsilon_{\\mathrm{rel}}$或$h$，$y$为对应的$\\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$。您的程序应输出一行，包含这四个斜率，顺序如下：\n- 首先，绝对容差相对于$\\varepsilon_{\\mathrm{abs}}$的斜率，\n- 其次，绝对容差相对于$h$的斜率，\n- 第三，相对容差相对于$\\varepsilon_{\\mathrm{rel}}$的斜率，\n- 第四，相对容差相对于$h$的斜率，\n并四舍五入到三位小数。\n\n最终输出格式：您的程序应生成单行输出，包含四个斜率，形式为逗号分隔的列表并用方括号括起来，例如，“[s1,s2,s3,s4]”。由于输出是无量纲斜率，因此不需要物理单位。",
            "solution": "用户提供了有效的问题陈述。\n\n### 第1步：已知条件提取\n- **控制方程**：不可压缩Navier–Stokes方程。\n- **数值方法**：Chorin投影法。\n- **投影步**：$u^{n+1} \\leftarrow u^\\ast - \\frac{\\Delta t}{\\rho}\\,\\nabla p$。\n- **计算域和网格**：周期性方形域$[0,1]^2$，均匀笛卡尔网格，间距$h = 1/N$。\n- **离散化**：交错的标记-网格（MAC）法。\n- **离散算子**：$\\nabla_h \\cdot$（散度），$\\nabla_h$（梯度），$L_h$（拉普拉斯算子）。\n- **算子恒等式**：在周期性边界条件下，$\\nabla_h \\cdot \\nabla_h p = L_h p$。\n- **范数**：\n    - 欧几里得范数：$\\|\\cdot\\|_{2}$。\n    - 离散$L^2$范数：$\\|q\\|_{L^2_h} \\equiv \\left( \\sum_{i,j} |q_{i,j}|^2\\, h^2 \\right)^{1/2}$。\n- **压力泊松问题**：$L_h p_h = b_h$，其中$b_h = \\frac{\\rho}{\\Delta t} \\, (\\nabla_h \\cdot u^\\ast)$。\n- **不精确求解**：残差为$r_h = L_h p_h - b_h$。\n- **停止准则**：\n    1.  绝对容差：$\\|r_h\\|_{2} \\le \\varepsilon_{\\mathrm{abs}}$。\n    2.  相对容差：$\\|r_h\\|_{2} \\le \\varepsilon_{\\mathrm{rel}} \\, \\|b_h\\|_{2}$。\n- **常数**：无量纲单位，$\\rho = 1$且$\\Delta t = 1$。\n- **目标1（推导）**：推导$\\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$、容差（$\\varepsilon_{\\mathrm{abs}}$或$\\varepsilon_{\\mathrm{rel}}$）和网格间距$h$之间的关系。\n- **目标2（实现）**：实现一个程序，以计算给定中间速度场下的预测质量守恒误差，并测试不同的标度律。\n- **中间速度场**：$u_x(x,y) = \\sin(2\\pi x)\\,\\sin(2\\pi y)$，$u_y(x,y) = \\cos(2\\pi x)\\,\\sin(2\\pi y)$。\n- **测试用例**：\n    - 用例1：$N = 64$，$\\varepsilon_{\\mathrm{abs}} \\in \\{10^{-6}, 5\\times 10^{-7}, 2.5\\times 10^{-7}\\}$。\n    - 用例2：$\\varepsilon_{\\mathrm{abs}} = 10^{-6}$，$N \\in \\{32, 64, 128\\}$。\n    - 用例3：$N = 64$，$\\varepsilon_{\\mathrm{rel}} \\in \\{10^{-6}, 5\\times 10^{-7}, 2.5\\times 10^{-7}\\}$。\n    - 用例4：$\\varepsilon_{\\mathrm{rel}} = 10^{-6}$，$N \\in \\{32, 64, 128\\}$。\n- **输出**：四个来自以e为底的对数回归的斜率，四舍五入到三位小数，格式为`[s1,s2,s3,s4]`。\n\n### 第2步：问题验证\n该问题在计算流体动力学原理，特别是关于不可压缩流的投影方法方面具有科学依据。问题陈述清晰，提供了执行所需推导和数值计算的所有必要定义和数据。语言客观明确。该问题是分析数值格式性质的标准练习，既不琐碎也不病态。满足有效问题的所有标准。\n\n### 第3步：结论与行动\n问题有效。将提供完整解答。\n\n### 基于原理的解答\n\n目标是推导投影速度场的离散质量守恒误差$\\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$与数值方法参数（即求解器容差和网格间距）之间的定量关系。\n\n**1. 将散度误差与泊松求解器残差联系起来**\n\n投影法分两步更新速度。我们关注的是第二步，即投影，它强制施加不可压缩性约束。速度场$u_h$的离散更新法则是：\n$$\nu_h^{n+1} = u_h^\\ast - \\frac{\\Delta t}{\\rho} \\nabla_h p_h\n$$\n其中$u_h^{n+1}$是新速度，$u_h^\\ast$是中间速度，$\\nabla_h p_h$是离散压力梯度，$\\Delta t$是时间步长，$\\rho$是密度。问题陈述要求使用无量纲单位，其中$\\rho = 1$和$\\Delta t = 1$，将方程简化为：\n$$\nu_h^{n+1} = u_h^\\ast - \\nabla_h p_h\n$$\n为了评估新速度场的质量守恒，我们将离散散度算子$\\nabla_h \\cdot$应用于此方程。该算子将面心速度数据映射到单元中心散度数据。\n$$\n\\nabla_h \\cdot u_h^{n+1} = \\nabla_h \\cdot u_h^\\ast - \\nabla_h \\cdot (\\nabla_h p_h)\n$$\n问题提供了周期域上MAC离散化的恒等式：$\\nabla_h \\cdot \\nabla_h p_h = L_h p_h$，其中$L_h$是单元中心数据上的离散拉普拉斯算子。代入此恒等式得到：\n$$\n\\nabla_h \\cdot u_h^{n+1} = \\nabla_h \\cdot u_h^\\ast - L_h p_h\n$$\n类压力变量$p_h$是通过求解离散泊松方程$L_h p_h = b_h$得到的，其中源项为$b_h = \\frac{\\rho}{\\Delta t} \\nabla_h \\cdot u_h^\\ast$。使用我们的单位常数，这变为$b_h = \\nabla_h \\cdot u_h^\\ast$。问题指明此线性系统求解不精确，导致非零残差$r_h$：\n$$\nr_h = L_h p_h - b_h\n$$\n我们可以重新整理这个残差的定义，将$L_h p_h$表示为$L_h p_h = b_h + r_h$。将此式及$b_h$的定义代入$u_h^{n+1}$的散度方程中：\n$$\n\\nabla_h \\cdot u_h^{n+1} = b_h - (b_h + r_h)\n$$\n这可以简化为投影方法的一个基本恒等式：\n$$\n\\nabla_h \\cdot u_h^{n+1} = -r_h\n$$\n这个结果表明，投影速度场的离散散度恰好等于不精确压力泊松求解的残差的负值。\n\n**2. 关联范数**\n\n问题要求我们使用离散$L^2_h$范数量化误差。根据上述恒等式，我们有：\n$$\n\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h} = \\|-r_h\\|_{L^2_h} = \\|r_h\\|_{L^2_h}\n$$\n线性求解器的停止准则是根据未加权的欧几里得范数$\\|\\cdot\\|_2$给出的。我们必须将$\\|\\cdot\\|_{L^2_h}$范数与$\\|\\cdot\\|_2$范数联系起来。对于定义在$N \\times N$单元中心上的任何网格函数$q_h$，定义如下：\n$$\n\\|q_h\\|_{L^2_h}^2 = \\sum_{i,j=0}^{N-1} |q_{h,i,j}|^2 h^2 \\quad \\text{and} \\quad \\|q_h\\|_2^2 = \\sum_{i,j=0}^{N-1} |q_{h,i,j}|^2\n$$\n通过从第一个和式中分解出常数$h^2$，我们找到了直接关系：\n$$\n\\|q_h\\|_{L^2_h}^2 = h^2 \\|q_h\\|_2^2 \\implies \\|q_h\\|_{L^2_h} = h \\|q_h\\|_2\n$$\n将此关系应用于残差$r_h$，我们得到了散度误差的核心表达式：\n$$\n\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h} = h \\|r_h\\|_2\n$$\n\n**3. 停止准则分析**\n\n我们现在通过将两个指定的停止准则代入此表达式来进行分析。我们假设求解器在准则的边界处终止，这代表了最坏情况。\n\n**情况 A：绝对容差**\n停止准则是$\\|r_h\\|_2 \\le \\varepsilon_{\\mathrm{abs}}$。在终止时，我们有$\\|r_h\\|_2 \\approx \\varepsilon_{\\mathrm{abs}}$。因此，散度误差为：\n$$\n\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h} \\approx h \\varepsilon_{\\mathrm{abs}}\n$$\n此关系预测了以下标度律：\n- 在固定网格分辨率（固定的$h$）下，误差$\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h}$与$\\varepsilon_{\\mathrm{abs}}$成正比。$\\log(\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h})$对$\\log(\\varepsilon_{\\mathrm{abs}})$的斜率为1。\n- 在固定容差（固定的$\\varepsilon_{\\mathrm{abs}}$）下，误差与$h$成正比。$\\log(\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h})$对$\\log(h)$的斜率为1。\n\n**情况 B：相对容差**\n停止准则是$\\|r_h\\|_2 \\le \\varepsilon_{\\mathrm{rel}} \\|b_h\\|_2$。在终止时，我们有$\\|r_h\\|_2 \\approx \\varepsilon_{\\mathrm{rel}} \\|b_h\\|_2$。散度误差为：\n$$\n\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h} \\approx h \\varepsilon_{\\mathrm{rel}} \\|b_h\\|_2\n$$\n为了理解关于$h$的标度关系，我们必须确定$\\|b_h\\|_2$如何依赖于$h$。$b_h = \\nabla_h \\cdot u_h^\\ast$项是连续散度$\\nabla \\cdot u$的离散逼近。对于一个光滑速度场，离散算子$\\nabla_h \\cdot$是一致的，意味着当$h \\to 0$时，$(\\nabla_h \\cdot u_h^\\ast)(x,y) \\to (\\nabla \\cdot u)(x,y)$。离散$L^2_h$范数旨在逼近连续$L^2$积分范数：\n$$\n\\|b_h\\|_{L^2_h}^2 = \\sum_{i,j} |b_{h,i,j}|^2 h^2 \\xrightarrow{h \\to 0} \\int_{[0,1]^2} |(\\nabla \\cdot u)(x,y)|^2 dx dy\n$$\n对于给定的连续场$u$，右侧的积分是一个常数。因此，对于小的$h$，$\\|b_h\\|_{L^2_h}$近似为常数。使用范数之间的关系$\\|b_h\\|_2 = h^{-1}\\|b_h\\|_{L^2_h}$，我们推导出标度关系：\n$$\n\\|b_h\\|_2 \\propto h^{-1}\n$$\n将此标度关系代回相对容差情况下的误差表达式：\n$$\n\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h} \\approx h \\varepsilon_{\\mathrm{rel}} (C h^{-1}) = C \\varepsilon_{\\mathrm{rel}}\n$$\n其中$C$是与连续散度的$L^2$范数相关的常数。此关系预测：\n- 在固定网格分辨率（固定的$h$）下，误差$\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h}$与$\\varepsilon_{\\mathrm{rel}}$成正比。$\\log(\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h})$对$\\log(\\varepsilon_{\\mathrm{rel}})$的斜率为1。\n- 在固定容差（固定的$\\varepsilon_{\\mathrm{rel}}$）下，误差近似独立于网格间距$h$。$\\log(\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h})$对$\\log(h)$的斜率为0。\n\n所给问题要求实现一个程序来数值验证这四个预测的斜率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_bh_norm2(N):\n    \"\"\"\n    Computes the Euclidean norm of the discrete divergence of the\n    intermediate velocity field u* on a MAC grid.\n\n    Args:\n        N (int): The number of grid cells in each direction.\n\n    Returns:\n        float: The Euclidean L2 norm of the discrete divergence vector b_h.\n    \"\"\"\n    h = 1.0 / N\n    \n    # Create grid indices for an N x N grid\n    j_idx, i_idx = np.indices((N, N))\n\n    # Define coordinates for the horizontal (u) velocity components\n    # ux is located at (i*h, (j+0.5)*h)\n    x_u = i_idx * h\n    y_u = (j_idx + 0.5) * h\n    \n    # Define coordinates for the vertical (v) velocity components\n    # uy is located at ((i+0.5)*h, j*h)\n    x_v = (i_idx + 0.5) * h\n    y_v = j_idx * h\n\n    # Sample the continuous velocity field to get the discrete intermediate velocity u*\n    # u_x(x,y) = sin(2*pi*x)*sin(2*pi*y)\n    # u_y(x,y) = cos(2*pi*x)*sin(2*pi*y)\n    ux_h = np.sin(2 * np.pi * x_u) * np.sin(2 * np.pi * y_u)\n    uy_h = np.cos(2 * np.pi * x_v) * np.sin(2 * np.pi * y_v)\n\n    # Compute the discrete divergence b_h = nabla_h . u* at cell centers.\n    # The divergence at cell (j,i) is (u_right - u_left)/h + (u_top - u_bottom)/h.\n    # On a periodic MAC grid, u_left of cell (j,i) is ux_h[j,i] and u_right is ux_h[j,(i+1)%N].\n    # Similarly, u_bottom is uy_h[j,i] and u_top is uy_h[(j+1)%N,i].\n    # We use np.roll for efficient periodic boundary handling.\n    # np.roll(ux_h, -1, axis=1) corresponds to ux_h[j, (i+1)%N]\n    # np.roll(uy_h, -1, axis=0) corresponds to uy_h[(j+1)%N, i]\n    b_h = ((np.roll(ux_h, -1, axis=1) - ux_h) + (np.roll(uy_h, -1, axis=0) - uy_h)) / h\n    \n    # The Euclidean norm ||b_h||_2 is equivalent to the Frobenius norm of the matrix\n    b_h_norm2 = np.linalg.norm(b_h)\n    \n    return b_h_norm2\n\ndef get_slope(x_values, y_values):\n    \"\"\"\n    Performs a linear regression on the base-e logarithm of the data.\n\n    Args:\n        x_values (np.ndarray): The independent variable values.\n        y_values (np.ndarray): The dependent variable values.\n\n    Returns:\n        float: The slope of the line fitted to (log(x), log(y)).\n    \"\"\"\n    log_x = np.log(x_values)\n    log_y = np.log(y_values)\n    # np.polyfit with degree 1 returns [slope, intercept]\n    slope, _ = np.polyfit(log_x, log_y, 1)\n    return slope\n\ndef solve():\n    \"\"\"\n    Main function to perform the four scaling tests and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Absolute tolerance scaling with tol, fixed N\n        {'N_vals': np.array([64]), 'eps_vals': np.array([1e-6, 5e-7, 2.5e-7]), 'mode': 'abs_vs_eps'},\n        # 2. Absolute tolerance scaling with h, fixed tol\n        {'N_vals': np.array([32, 64, 128]), 'eps_vals': np.array([1e-6]), 'mode': 'abs_vs_h'},\n        # 3. Relative tolerance scaling with tol, fixed N\n        {'N_vals': np.array([64]), 'eps_vals': np.array([1e-6, 5e-7, 2.5e-7]), 'mode': 'rel_vs_eps'},\n        # 4. Relative tolerance scaling with h, fixed tol\n        {'N_vals': np.array([32, 64, 128]), 'eps_vals': np.array([1e-6]), 'mode': 'rel_vs_h'},\n    ]\n\n    results = []\n\n    # Case 1: Absolute tolerance vs. epsilon_abs\n    case1 = test_cases[0]\n    N1 = case1['N_vals'][0]\n    h1 = 1.0 / N1\n    eps_abs_vals = case1['eps_vals']\n    # Derived relationship: ||div u||_L2h = h * eps_abs\n    errors1 = h1 * eps_abs_vals\n    slope1 = get_slope(eps_abs_vals, errors1)\n    results.append(slope1)\n\n    # Case 2: Absolute tolerance vs. h\n    case2 = test_cases[1]\n    N_vals2 = case2['N_vals']\n    h_vals2 = 1.0 / N_vals2\n    eps_abs2 = case2['eps_vals'][0]\n    # Derived relationship: ||div u||_L2h = h * eps_abs\n    errors2 = h_vals2 * eps_abs2\n    slope2 = get_slope(h_vals2, errors2)\n    results.append(slope2)\n\n    # Case 3: Relative tolerance vs. epsilon_rel\n    case3 = test_cases[2]\n    N3 = case3['N_vals'][0]\n    h3 = 1.0 / N3\n    eps_rel_vals = case3['eps_vals']\n    b_h_norm2_N64 = compute_bh_norm2(N3)\n    # Derived relationship: ||div u||_L2h = h * eps_rel * ||b_h||_2\n    errors3 = h3 * eps_rel_vals * b_h_norm2_N64\n    slope3 = get_slope(eps_rel_vals, errors3)\n    results.append(slope3)\n\n    # Case 4: Relative tolerance vs. h\n    case4 = test_cases[3]\n    N_vals4 = case4['N_vals']\n    h_vals4 = 1.0 / N_vals4\n    eps_rel4 = case4['eps_vals'][0]\n    errors4 = []\n    for N_val in N_vals4:\n        h_val = 1.0 / N_val\n        b_h_norm2 = compute_bh_norm2(N_val)\n        # Derived relationship: ||div u||_L2h = h * eps_rel * ||b_h||_2\n        error = h_val * eps_rel4 * b_h_norm2\n        errors4.append(error)\n    errors4 = np.array(errors4)\n    slope4 = get_slope(h_vals4, errors4)\n    results.append(slope4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{results[0]:.3f},{results[1]:.3f},{results[2]:.3f},{results[3]:.3f}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "除了求解器误差外，Chorin方法本身还存在一种固有的“分裂误差”，它源于在时间步进格式中对压力梯度的解耦处理。这个高级练习将引入“人造解方法”(Method of Manufactured Solutions, MMS)来分离并量化这一基本的误差来源。通过比较存在与不存在压力梯度的两种情况，您将以数值方式确定该方法的时间精度阶数，并理解为何分裂误差是模拟复杂流动时需要考量的一个关键因素。",
            "id": "3301208",
            "problem": "考虑将二维不可压缩纳维-斯托克斯方程作为计算流体动力学（CFD）的基本方程：$$\\partial_t \\mathbf{u} + (\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\nu \\Delta \\mathbf{u} + \\mathbf{f},\\quad \\nabla\\cdot \\mathbf{u} = 0,$$ 其中 $\\mathbf{u}(x,y,t)$ 是速度，$p(x,y,t)$ 是运动压力，$\\nu$ 是运动粘度，$\\mathbf{f}(x,y,t)$ 是体力。Chorin 投影法通过首先计算一个忽略了压力梯度贡献的暂定（预投影）速度 $\\mathbf{u}^\\star$，然后通过压力泊松方程（PPE）将 $\\mathbf{u}^\\star$ 投影到一个无散场上，从而对时间推进进行分裂。分裂误差源于在暂定更新中忽略了 $-\\nabla p$。\n\n使用人造解方法，在周期性域 $[0,2\\pi]\\times[0,2\\pi]$上定义两个光滑的无散精确解：\n\n- 情况 A (Taylor–Green 涡)：$$\\mathbf{u}(x,y,t) = \\begin{bmatrix} -U_0 \\cos(x)\\sin(y)\\, e^{-2\\nu t} \\\\ U_0 \\sin(x)\\cos(y)\\, e^{-2\\nu t} \\end{bmatrix},\\quad p(x,y,t) = \\frac{U_0^2}{4}\\big(\\cos(2x) + \\cos(2y)\\big) e^{-4\\nu t},\\quad \\mathbf{f}=\\mathbf{0}.$$\n\n- 情况 B (扩散剪切，零压力梯度)：$$\\mathbf{u}(x,y,t) = \\begin{bmatrix} \\sin(y)\\, e^{-\\nu t} \\\\ 0 \\end{bmatrix},\\quad p(x,y,t) = \\text{constant},\\quad \\mathbf{f}=\\mathbf{0}.$$\n\n在周期性边界条件下，对于给定的 $p$ 和 $\\mathbf{f}$，这两种情况都满足不可压缩方程。设粘度为 $\\nu = 0.1$，且 $U_0=1$。\n\n通过仅显式推进非压力项，定义在时间 $t^n$ 处、时间步长为 $\\Delta t$ 的 Chorin 暂定更新：$$\\mathbf{u}^\\star = \\mathbf{u}(t^n) + \\Delta t\\left(-(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} + \\nu \\Delta \\mathbf{u} + \\mathbf{f}\\right)\\Big|_{t=t^n}.$$ 使用精确的人造解 $\\mathbf{u}(t^n)$ 来精确（解析地）评估所有空间导数，并且不执行投影步骤。对于每种情况，计算误差 $$E(\\Delta t) = \\left\\|\\mathbf{u}^\\star - \\mathbf{u}(t^n+\\Delta t)\\right\\|_{L^2(\\Omega)},$$ 其中 $\\Omega=[0,2\\pi]\\times[0,2\\pi]$，且 $L^2$ 范数是关于面积测度在域上计算的。该误差隔离了在暂定步骤中忽略 $-\\nabla p$ 的分裂效应（情况 A 预计将由一个一阶 $\\Delta t$ 项主导，因为 $\\nabla p$ 非零，而情况 B 应表现出更高阶衰减，因为 $\\nabla p=\\mathbf{0}$）。\n\n您的程序必须：\n- 使用周期性采样和由人造场所蕴含的 $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$、$\\Delta \\mathbf{u}$ 和 $\\nabla p$ 的精确解析表达式，在 $[0,2\\pi]\\times[0,2\\pi]$ 上的均匀网格上通过数值积分来评估 $L^2$ 误差。\n- 使用时间集 $t^n = 0$。\n- 使用以下测试时间步长集：$\\Delta t \\in \\{0.2, 0.1, 0.05, 0.025, 0.0125\\}$。\n- 对于每种情况，报告五个 $\\Delta t$ 值的 $L^2$ 误差 $E(\\Delta t)$ 列表，然后报告观测到的衰减阶数，该阶数由 $\\log E$ 与 $\\log \\Delta t$ 的最小二乘拟合斜率计算得出（即，在 $E \\approx C\\,\\Delta t^{\\,q}$ 中估计 $q$）。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，各项按以下顺序排列：首先是情况 A (Taylor–Green 涡) 的五个误差，从最大的 $\\Delta t$ 到最小的 $\\Delta t$，然后是给出情况 A 估计阶数的单个浮点数，接着是情况 B (扩散剪切) 的五个误差，从最大的 $\\Delta t$ 到最小的 $\\Delta t$，最后是给出情况 B 估计阶数的单个浮点数。例如，一行输出的模式为 \"[E_A(0.2),E_A(0.1),E_A(0.05),E_A(0.025),E_A(0.0125),q_A,E_B(0.2),E_B(0.1),E_B(0.05),E_B(0.025),E_B(0.0125),q_B]\"。",
            "solution": "用户希望分析 Chorin 投影法对于二维不可压缩纳维-斯托克斯方程的两种不同人造解的分裂误差。\n\n### 步骤 1：提取已知信息\n\n- **控制方程**：\n  - 动量方程：$\\partial_t \\mathbf{u} + (\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\nu \\Delta \\mathbf{u} + \\mathbf{f}$\n  - 不可压缩性：$\\nabla\\cdot \\mathbf{u} = 0$\n- **域**：周期性方框 $\\Omega = [0,2\\pi]\\times[0,2\\pi]$。\n- **物理参数**：运动粘度 $\\nu = 0.1$。\n- **情况 A (Taylor-Green 涡)**：\n  - 速度：$\\mathbf{u}(x,y,t) = \\begin{bmatrix} -U_0 \\cos(x)\\sin(y)\\, e^{-2\\nu t} \\\\ U_0 \\sin(x)\\cos(y)\\, e^{-2\\nu t} \\end{bmatrix}$\n  - 压力：$p(x,y,t) = \\frac{U_0^2}{4}\\big(\\cos(2x) + \\cos(2y)\\big) e^{-4\\nu t}$\n  - 强迫项：$\\mathbf{f}=\\mathbf{0}$\n  - 振幅：$U_0=1$\n- **情况 B (扩散剪切)**：\n  - 速度：$\\mathbf{u}(x,y,t) = \\begin{bmatrix} \\sin(y)\\, e^{-\\nu t} \\\\ 0 \\end{bmatrix}$\n  - 压力：$p(x,y,t) = \\text{constant}$\n  - 强迫项：$\\mathbf{f}=\\mathbf{0}$\n- **数值方法**：Chorin 暂定速度更新（仅第一步）。\n  - 更新公式：$\\mathbf{u}^\\star = \\mathbf{u}(t^n) + \\Delta t\\left(-(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} + \\nu \\Delta \\mathbf{u} + \\mathbf{f}\\right)\\Big|_{t=t^n}$\n- **问题设置**：\n  - 时间：$t^n = 0$。\n  - 更新公式中的所有空间导数都使用人造解进行解析评估。\n- **误差度量**：\n  - 定义：$E(\\Delta t) = \\left\\|\\mathbf{u}^\\star - \\mathbf{u}(t^n+\\Delta t)\\right\\|_{L^2(\\Omega)}$\n- **测试套件**：\n  - 时间步长：$\\Delta t \\in \\{0.2, 0.1, 0.05, 0.025, 0.0125\\}$。\n- **任务**：\n  1. 对于每种情况，使用数值积分计算所有指定 $\\Delta t$ 值的 $L^2$ 误差 $E(\\Delta t)$。\n  2. 对于每种情况，通过对 $\\log E$ 与 $\\log \\Delta t$ 进行最小二乘拟合，计算观测到的衰减阶数 $q$。\n- **输出格式**：单行 `[E_A(0.2), ..., E_A(0.0125), q_A, E_B(0.2), ..., E_B(0.0125), q_B]`。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n- **科学基础**：该问题植根于基本的纳维-斯托克斯方程和一种标准的、广泛使用的数值算法（Chorin 投影法）。人造解方法是科学计算中代码验证的基石技术。所选的人造解（Taylor-Green 涡、扩散剪切）是经典且正确的例子。该问题在科学和数学上是合理的。\n- **适定性**：任务是基于解析指定的函数和参数来计算一个明确定义的误差量。计算误差和收敛阶数的过程有明确描述。存在唯一且有意义的解。\n- **客观性**：问题陈述精确、量化，没有主观或模糊的语言。所有术语都有正式定义。\n\n该问题没有任何无效性缺陷。它是自洽的、一致的且具有科学依据的。\n\n### 步骤 3：结论与行动\n该问题是**有效**的。我将继续生成解决方案。\n\n### 基于原则的解决方案设计\n\n该解决方案需要计算 Chorin 投影法第一步产生的误差。此误差隔离了算子分裂的影响，特别是暂定速度更新中未能考虑压力梯度的影响。\n\n问题的核心在于评估误差项 $\\mathbf{e}(\\Delta t) = \\mathbf{u}^\\star - \\mathbf{u}(t^n + \\Delta t)$。\n暂定速度 $\\mathbf{u}^\\star$ 由下式给出：\n$$ \\mathbf{u}^\\star = \\mathbf{u}(t^n) + \\Delta t \\left( -(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} + \\nu \\Delta \\mathbf{u} + \\mathbf{f} \\right)\\Big|_{t=t^n} $$\n由于人造解精确满足纳维-斯托克斯方程 $\\partial_t \\mathbf{u} + (\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\nu \\Delta \\mathbf{u} + \\mathbf{f}$，我们可以替换非压力项：\n$$ -(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} + \\nu \\Delta \\mathbf{u} + \\mathbf{f} = \\partial_t \\mathbf{u} + \\nabla p $$\n将此代入 $\\mathbf{u}^\\star$ 的表达式，得到一个更直接的形式：\n$$ \\mathbf{u}^\\star = \\mathbf{u}(t^n) + \\Delta t \\left( \\partial_t \\mathbf{u} + \\nabla p \\right) \\Big|_{t=t^n} $$\n误差向量则为：\n$$ \\mathbf{e}(\\Delta t) = \\left[ \\mathbf{u}(t^n) + \\Delta t \\left( \\partial_t \\mathbf{u} + \\nabla p \\right)\\Big|_{t=t^n} \\right] - \\mathbf{u}(t^n + \\Delta t) $$\n在 $t^n$ 处对 $\\mathbf{u}(t^n + \\Delta t)$ 进行泰勒级数展开为 $\\mathbf{u}(t^n) + \\Delta t \\partial_t\\mathbf{u}|_{t^n} + \\frac{(\\Delta t)^2}{2} \\partial_{tt}\\mathbf{u}|_{t^n} + \\mathcal{O}((\\Delta t)^3)$。\n将此代入误差表达式，得到误差向量的主导阶行为：\n$$ \\mathbf{e}(\\Delta t) = \\Delta t \\, \\nabla p|_{t^n} - \\frac{(\\Delta t)^2}{2} \\partial_{tt}\\mathbf{u}|_{t^n} + \\mathcal{O}((\\Delta t)^3) $$\n这表明，如果 $\\nabla p \\neq 0$，误差是 $\\Delta t$ 的一阶；如果 $\\nabla p = 0$，误差是二阶。\n\n现在我们将为每种情况在 $t^n = 0$ 时计算必要的解析项。\n\n**情况 A：Taylor-Green 涡**\n- 参数：$U_0=1$, $\\nu=0.1$。\n- $t=0$ 时的速度：$\\mathbf{u}(0) = \\begin{bmatrix} -\\cos(x)\\sin(y) \\\\ \\sin(x)\\cos(y) \\end{bmatrix}$。\n- $t=\\Delta t$ 时的精确速度：$\\mathbf{u}(\\Delta t) = \\mathbf{u}(0) e^{-2\\nu\\Delta t}$。\n- 为求 $\\mathbf{u}^\\star$，我们需要 $\\partial_t \\mathbf{u}|_{t=0}$ 和 $\\nabla p|_{t=0}$。\n  - $\\partial_t \\mathbf{u} = -2\\nu \\mathbf{u}$，所以 $\\partial_t \\mathbf{u}|_{t=0} = -2\\nu \\mathbf{u}(0)$。\n  - $p(t=0) = \\frac{1}{4}(\\cos(2x) + \\cos(2y))$。\n  - $\\nabla p|_{t=0} = \\begin{bmatrix} -\\frac{1}{2}\\sin(2x) \\\\ -\\frac{1}{2}\\sin(2y) \\end{bmatrix}$。\n- 代入 $\\mathbf{u}^\\star$ 的简化表达式：\n  $$ \\mathbf{u}^\\star = \\mathbf{u}(0) + \\Delta t \\left( -2\\nu \\mathbf{u}(0) + \\nabla p|_{t=0} \\right) = (1-2\\nu\\Delta t)\\mathbf{u}(0) + \\Delta t \\nabla p|_{t=0} $$\n- 误差向量为：\n  $$ \\mathbf{e}_A(\\Delta t) = \\mathbf{u}^\\star - \\mathbf{u}(\\Delta t) = \\left( (1-2\\nu\\Delta t)\\mathbf{u}(0) + \\Delta t \\nabla p|_{t=0} \\right) - \\left( \\mathbf{u}(0) e^{-2\\nu\\Delta t} \\right) $$\n  $$ \\mathbf{e}_A(\\Delta t) = (1-2\\nu\\Delta t - e^{-2\\nu\\Delta t})\\mathbf{u}(0) + \\Delta t \\nabla p|_{t=0} $$\n  乘以 $\\mathbf{u}(0)$ 的项是 $\\mathcal{O}((\\Delta t)^2)$，而涉及 $\\nabla p$ 的项是 $\\mathcal{O}(\\Delta t)$。如预期，误差由压力梯度项主导。\n\n**情况 B：扩散剪切**\n- 参数：$\\nu=0.1$。\n- $t=0$ 时的速度：$\\mathbf{u}(0) = \\begin{bmatrix} \\sin(y) \\\\ 0 \\end{bmatrix}$。\n- $t=\\Delta t$ 时的精确速度：$\\mathbf{u}(\\Delta t) = \\mathbf{u}(0) e^{-\\nu\\Delta t}$。\n- 为求 $\\mathbf{u}^\\star$，我们需要 $\\partial_t \\mathbf{u}|_{t=0}$ 和 $\\nabla p|_{t=0}$。\n  - $\\partial_t \\mathbf{u} = -\\nu \\mathbf{u}$，所以 $\\partial_t \\mathbf{u}|_{t=0} = -\\nu \\mathbf{u}(0)$。\n  - $p = \\text{constant}$，所以 $\\nabla p = \\mathbf{0}$。\n- 代入 $\\mathbf{u}^\\star$ 的简化表达式：\n  $$ \\mathbf{u}^\\star = \\mathbf{u}(0) + \\Delta t ( -\\nu \\mathbf{u}(0) + \\mathbf{0} ) = (1-\\nu\\Delta t)\\mathbf{u}(0) $$\n- 误差向量为：\n  $$ \\mathbf{e}_B(\\Delta t) = \\mathbf{u}^\\star - \\mathbf{u}(\\Delta t) = (1-\\nu\\Delta t)\\mathbf{u}(0) - \\mathbf{u}(0) e^{-\\nu\\Delta t} $$\n  $$ \\mathbf{e}_B(\\Delta t) = (1-\\nu\\Delta t - e^{-\\nu\\Delta t})\\mathbf{u}(0) $$\n  乘以 $\\mathbf{u}(0)$ 的项是 $\\mathcal{O}((\\Delta t)^2)$。如预期，误差是二阶的。\n\n**数值积分和阶数估计**\n$L^2$ 范数 $\\|f\\|_{L^2(\\Omega)} = \\left(\\int_\\Omega |f(x,y)|^2 \\,dx\\,dy\\right)^{1/2}$ 将通过数值方法计算。我们将域 $\\Omega=[0,2\\pi]\\times[0,2\\pi]$ 离散化为一个 $N \\times N$ 的网格，网格间距为 $h = 2\\pi/N$。积分通过对网格点 $(x_i, y_j)$ 的求和来近似：\n$$ E^2(\\Delta t) = \\|\\mathbf{e}\\|^2_{L^2} \\approx \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\|\\mathbf{e}(x_i, y_j, \\Delta t)\\|^2 h^2 $$\n$$ E(\\Delta t) \\approx h \\sqrt{\\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} (e_x^2 + e_y^2)\\big|_{(x_i,y_j)}} $$\n足够大的 $N$ (例如 $N=256$) 可以确保准确性。\n\n收敛阶数 $q$ 通过拟合模型 $E(\\Delta t) = C (\\Delta t)^q$ 来估计。取对数后，我们得到一个线性关系：$\\log(E) = q \\log(\\Delta t) + \\log(C)$。斜率 $q$ 通过对给定时间步长集上的 $\\log(E)$ 关于 $\\log(\\Delta t)$ 进行线性最小二乘回归得到。这将使用 `scipy.stats.linregress` 来完成。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Computes the splitting error for Chorin's projection method for two\n    manufactured solutions and estimates the order of convergence.\n    \"\"\"\n    # Define problem parameters\n    nu = 0.1\n    U0 = 1.0\n    dts = np.array([0.2, 0.1, 0.05, 0.025, 0.0125])\n    \n    # Numerical quadrature parameters\n    N = 256\n    h = 2 * np.pi / N\n    x = np.linspace(0, 2 * np.pi, N, endpoint=False)\n    y = np.linspace(0, 2 * np.pi, N, endpoint=False)\n    X, Y = np.meshgrid(x, y)\n\n    # --- Case A: Taylor-Green Vortex ---\n    errors_A = []\n    \n    # Pre-compute spatial fields at t=0\n    u0_x_A = -U0 * np.cos(X) * np.sin(Y)\n    u0_y_A =  U0 * np.sin(X) * np.cos(Y)\n    grad_p_x_A = - (U0**2 / 2.0) * np.sin(2 * X)\n    grad_p_y_A = - (U0**2 / 2.0) * np.sin(2 * Y)\n\n    for dt in dts:\n        # Calculate terms for the error vector e = u* - u(dt)\n        # The equation for the error vector is:\n        # e = (1 - 2*nu*dt - exp(-2*nu*dt)) * u(0) + dt * grad_p(0)\n        \n        # Coefficient for the u(0) term\n        C1 = 1.0 - 2.0 * nu * dt - np.exp(-2.0 * nu * dt)\n        \n        # Components of the error vector field\n        e_x = C1 * u0_x_A + dt * grad_p_x_A\n        e_y = C1 * u0_y_A + dt * grad_p_y_A\n\n        # Compute L2 norm via numerical quadrature\n        sum_sq_error = np.sum(e_x**2 + e_y**2)\n        l2_error = h * np.sqrt(sum_sq_error)\n        errors_A.append(l2_error)\n        \n    # Estimate order of convergence q_A\n    log_dts = np.log(dts)\n    log_errors_A = np.log(np.array(errors_A))\n    # linregress returns a tuple, the slope is the first element\n    q_A = linregress(log_dts, log_errors_A).slope\n\n    # --- Case B: Diffusing Shear ---\n    errors_B = []\n\n    # Pre-compute spatial fields at t=0\n    u0_x_B = np.sin(Y)\n    # u0_y_B is zero everywhere\n\n    for dt in dts:\n        # Calculate terms for the error vector e = u* - u(dt)\n        # The equation for the error vector is:\n        # e = (1 - nu*dt - exp(-nu*dt)) * u(0)\n        # Note: grad_p(0) is zero for this case.\n\n        # Coefficient for the u(0) term\n        C2 = 1.0 - nu * dt - np.exp(-nu * dt)\n        \n        # Components of the error vector field\n        e_x = C2 * u0_x_B\n        # e_y is zero\n\n        # Compute L2 norm via numerical quadrature\n        sum_sq_error = np.sum(e_x**2) # e_y is zero\n        l2_error = h * np.sqrt(sum_sq_error)\n        errors_B.append(l2_error)\n\n    # Estimate order of convergence q_B\n    log_errors_B = np.log(np.array(errors_B))\n    q_B = linregress(log_dts, log_errors_B).slope\n    \n    # Combine all results into a single list\n    final_results = errors_A + [q_A] + errors_B + [q_B]\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{val:.8f}' for val in final_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}