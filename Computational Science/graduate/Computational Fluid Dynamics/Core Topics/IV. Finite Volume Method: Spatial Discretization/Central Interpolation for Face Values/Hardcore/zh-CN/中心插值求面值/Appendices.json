{
    "hands_on_practices": [
        {
            "introduction": "中心插值格式因其简洁性和二阶精度而具有吸引力，但在应用于对流主导问题时，它会暴露出一个关键的弱点。本练习将引导你推导著名的单元佩克莱数（cell Peclet number）$Pe$ 的约束条件，这是计算流体力学中的一个基石概念，它决定了这种简单格式何时是数值有界的。通过这个练习，你将亲手发现为什么在强对流情况下必须谨慎使用中心插值。",
            "id": "3298459",
            "problem": "考虑一个一维稳态的被动标量 $\\phi(x)$ 在一个均匀的控制体网格上的对流-扩散输运，该网格的间距为 $\\Delta x$，横截面积为单位面积。其控制微分守恒方程为\n$$\\frac{d}{dx}\\left(\\Gamma \\frac{d \\phi}{dx}\\right) - \\rho u \\frac{d \\phi}{dx} = 0,$$\n其中 $\\rho$ 是流体密度，$u$ 是恒定速度，$\\Gamma$ 是 $\\phi$ 的扩散系数。使用有限体积法 (FVM)，在一个由西($w$)面和东($e$)面界定的通用内部控制体 $P$ 上进行积分，并用中心梯度来离散化扩散通量。对于对流通量，采用中心插值法计算界面值（即中心差分格式，CDS），这意味着在均匀网格上，界面值是相邻单元中心值的算术平均值。定义界面质量通量大小为 $F \\equiv \\rho u$（单位面积下），扩散传导系数为 $D \\equiv \\Gamma/\\Delta x$。\n\n如果在线性化代数方程中，乘以相邻未知数的系数为非负，并且中心系数满足必要的对角占优条件以排除离散解中的过冲和下冲，则称该离散格式为有界的。推导 CDS 所蕴含的系数约束条件，并用无量纲的单元佩克莱特数\n$$Pe \\equiv \\frac{\\rho u \\Delta x}{\\Gamma} = \\frac{F}{D}$$\n表示有界性要求。\n\n然后，对于给定的特定参数值\n$$\\rho = 1.2 \\ \\text{kg}\\,\\text{m}^{-3}, \\quad u = 2 \\ \\text{m}\\,\\text{s}^{-1}, \\quad \\Gamma = 1.8 \\times 10^{-5} \\ \\text{kg}\\,\\text{m}^{-1}\\,\\text{s}^{-1}, \\quad \\Delta x = 1.0 \\times 10^{-2} \\ \\text{m},$$\n计算 $Pe$ 的数值，并判断在这些条件下中心插值是否有界。将最终答案以行矩阵 $\\begin{pmatrix} Pe & b \\end{pmatrix}$ 的形式报告，其中如果中心插值是有界的，则 $b=1$，否则 $b=0$。将 $Pe$ 表示为无单位的纯数，$b$ 表示为无量纲指标。无需四舍五入；尽可能提供精确值。",
            "solution": "本任务是推导应用于一维稳态对流-扩散方程的中心差分格式 (CDS) 的有界性判据，然后针对一组特定的物理参数评估该判据。\n\n控制微分方程如下：\n$$\n\\frac{d}{dx}\\left(\\Gamma \\frac{d\\phi}{dx}\\right) - \\rho u \\frac{d\\phi}{dx} = 0\n$$\n其中 $\\phi$ 是被动标量，$\\Gamma$ 是扩散系数，$\\rho$ 是密度，$u$ 是速度。\n\n为了应用有限体积法 (FVM)，我们在一个以节点 $P$ 为中心、由西面 $w$ 和东面 $e$ 界定的通用控制体 (CV) 上对此方程进行积分。控制体的体积为 $\\Delta V = A \\Delta x$，其中横截面积设为单位1 ($A=1$)，网格间距为 $\\Delta x$。\n$$\n\\int_{w}^{e} \\left[ \\frac{d}{dx}\\left(\\Gamma \\frac{d\\phi}{dx}\\right) - \\rho u \\frac{d\\phi}{dx} \\right] A \\, dx = 0\n$$\n由于 $A=1$，我们可以写出：\n$$\n\\int_{w}^{e} \\frac{d}{dx}\\left(\\Gamma \\frac{d\\phi}{dx}\\right) dx - \\int_{w}^{e} \\rho u \\frac{d\\phi}{dx} dx = 0\n$$\n对第一项（扩散通量的散度）应用微积分基本定理，并假设第二项中的 $\\rho$ 和 $u$ 为常数，我们得到控制体上的平衡方程：\n$$\n\\left(A \\Gamma \\frac{d\\phi}{dx}\\right)_e - \\left(A \\Gamma \\frac{d\\phi}{dx}\\right)_w - \\rho u A (\\phi_e - \\phi_w) = 0\n$$\n同样，当 $A=1$ 时：\n$$\n\\left(\\Gamma \\frac{d\\phi}{dx}\\right)_e - \\left(\\Gamma \\frac{d\\phi}{dx}\\right)_w - \\rho u (\\phi_e - \\phi_w) = 0\n$$\n此方程表示穿过控制体界面的扩散通量和对流通量的平衡。标准的 FVM 方法处理界面上的总通量。一个等效且更标准的出发点是散度形式的守恒定律，即 $\\frac{d}{dx}(\\rho u \\phi - \\Gamma \\frac{d\\phi}{dx}) = 0$。积分得到 $(\\rho u \\phi)_e - (\\Gamma \\frac{d\\phi}{dx})_e - [(\\rho u \\phi)_w - (\\Gamma \\frac{d\\phi}{dx})_w] = 0$。问题中指定的离散格式会得到与我们将要推导的相同的代数形式，这证实了问题陈述的一致性。\n\n现在我们对一个均匀网格上的各项进行离散化，其中节点由 $W$（西）、$P$（中）和 $E$（东）表示，节点间距为 $\\Delta x$。\n界面上的扩散通量使用中心差分来近似梯度：\n$$\n\\left(\\Gamma \\frac{d\\phi}{dx}\\right)_e \\approx \\Gamma_e \\frac{\\phi_E - \\phi_P}{\\Delta x} \\quad \\text{和} \\quad \\left(\\Gamma \\frac{d\\phi}{dx}\\right)_w \\approx \\Gamma_w \\frac{\\phi_P - \\phi_W}{\\Delta x}\n$$\n假设扩散系数为常数，$\\Gamma_e = \\Gamma_w = \\Gamma$。\n对于对流项，问题指定使用 CDS，其中界面上标量 $\\phi$ 的值是相邻单元中心值的算术平均值：\n$$\n\\phi_e \\approx \\frac{\\phi_P + \\phi_E}{2} \\quad \\text{和} \\quad \\phi_w \\approx \\frac{\\phi_W + \\phi_P}{2}\n$$\n将这些离散格式代入积分方程中，得到：\n$$\n\\Gamma \\frac{\\phi_E - \\phi_P}{\\Delta x} - \\Gamma \\frac{\\phi_P - \\phi_W}{\\Delta x} - \\rho u \\left( \\frac{\\phi_P + \\phi_E}{2} - \\frac{\\phi_W + \\phi_P}{2} \\right) = 0\n$$\n简化各项：\n$$\n\\frac{\\Gamma}{\\Delta x}(\\phi_E - 2\\phi_P + \\phi_W) - \\frac{\\rho u}{2}(\\phi_E - \\phi_W) = 0\n$$\n我们引入扩散传导系数 $D \\equiv \\Gamma/\\Delta x$ 和界面质量通量 $F \\equiv \\rho u$ 的定义：\n$$\nD(\\phi_E - 2\\phi_P + \\phi_W) - \\frac{F}{2}(\\phi_E - \\phi_W) = 0\n$$\n为了分析该格式的性质，我们将其重排为标准线性代数形式 $a_P \\phi_P = a_W \\phi_W + a_E \\phi_E$：\n$$\n(D\\phi_E - \\frac{F}{2}\\phi_E) + (D\\phi_W + \\frac{F}{2}\\phi_W) - 2D\\phi_P = 0\n$$\n$$\n(2D)\\phi_P = \\left(D + \\frac{F}{2}\\right)\\phi_W + \\left(D - \\frac{F}{2}\\right)\\phi_E\n$$\n由此，我们确定系数为：\n$$\na_W = D + \\frac{F}{2}\n$$\n$$\na_E = D - \\frac{F}{2}\n$$\n$$\na_P = 2D\n$$\n如果一个数值格式不产生非物理的过冲或下冲，则称其为有界的。有界性的一个充分条件是所有相邻节点的系数（$a_W, a_E$）都为非负。这确保了 $\\phi_P$ 是 $\\phi_W$ 和 $\\phi_E$ 的加权平均值。\n$$\na_W \\ge 0 \\implies D + \\frac{F}{2} \\ge 0\n$$\n$$\na_E \\ge 0 \\implies D - \\frac{F}{2} \\ge 0\n$$\n由于 $D = \\Gamma/\\Delta x$ 内在地为正，这两个不等式合并得到 $|F/2| \\le D$，或 $|F| \\le 2D$。\n\n这个条件可以用无量纲单元佩克莱特数来表示，其定义为 $Pe \\equiv \\frac{\\rho u \\Delta x}{\\Gamma}$。我们可以用 $F$ 和 $D$ 的定义重写 $Pe$：\n$$\nPe = \\frac{(\\rho u) \\Delta x}{\\Gamma} = \\frac{F}{(\\Gamma/\\Delta x)} = \\frac{F}{D}\n$$\n有界性判据 $|F| \\le 2D$ 继而可以通过两边同除以 $D$ 来重写：\n$$\n\\frac{|F|}{D} \\le 2 \\implies |Pe| \\le 2\n$$\n这就是 CDS 著名的约束条件：只有当单元佩克莱特数的大小小于或等于 2 时，该格式才是有界的，并保证其解是物理上真实的。\n\n接下来，我们使用给定的数据计算 $Pe$ 的值：\n$\\rho = 1.2 \\ \\text{kg}\\,\\text{m}^{-3}$，$u = 2 \\ \\text{m}\\,\\text{s}^{-1}$，$\\Gamma = 1.8 \\times 10^{-5} \\ \\text{kg}\\,\\text{m}^{-1}\\,\\text{s}^{-1}$，以及 $\\Delta x = 1.0 \\times 10^{-2} \\ \\text{m}$。\n$$\nPe = \\frac{\\rho u \\Delta x}{\\Gamma} = \\frac{(1.2)(2)(1.0 \\times 10^{-2})}{1.8 \\times 10^{-5}} = \\frac{2.4 \\times 10^{-2}}{1.8 \\times 10^{-5}}\n$$\n$$\nPe = \\frac{2.4}{1.8} \\times 10^{-2 - (-5)} = \\frac{4}{3} \\times 10^3 = \\frac{4000}{3}\n$$\n计算出的佩克莱特数为 $Pe = \\frac{4000}{3} \\approx 1333.33$。\n\n最后，我们将此值与有界性判据 $|Pe| \\le 2$ 进行比较。\n$$\n\\left|\\frac{4000}{3}\\right| = \\frac{4000}{3} \\approx 1333.33\n$$\n显然，$\\frac{4000}{3} > 2$。该条件不满足。因此，对于这组参数，中心插值格式是无界的。这意味着数值解容易产生伪振荡，并且可能在物理上是无意义的。我们将有界性指标设为 $b=0$。\n\n最终答案是行矩阵 $\\begin{pmatrix} Pe & b \\end{pmatrix}$。代入我们的结果，得到 $\\begin{pmatrix} \\frac{4000}{3} & 0 \\end{pmatrix}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{4000}{3} & 0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "我们之所以容忍中心插值的稳定性问题，其根本原因在于它的二阶精度（$O(\\Delta x^2)$）。本练习将理论转向计算实践，指导你使用“制造解方法”（Method of Manufactured Solutions, MMS）来数值验证该格式确实以预期的速率收敛。掌握MMS是任何数值代码开发人员的基本技能，它能让你确信你的实现与理论相符。",
            "id": "3298479",
            "problem": "考虑一个一维周期性域 $x \\in [0,1]$，其光滑人造解为 $\\phi(x) = \\sin(k x)$，其中所有角度均以弧度为单位。设一个均匀网格族由单元数 $N \\in \\{10, 20, 40, 80\\}$ 定义，并用 $\\Delta x = 1/N$ 表示网格间距。对于每个网格，定义单元中心位置 $x_i = (i + 1/2)\\Delta x$（其中 $i \\in \\{0, 1, \\dots, N-1\\}$）和面位置 $x_{f}^{(j)} = j \\Delta x$（其中 $j \\in \\{0, 1, \\dots, N-1\\}$），并采用周期性索引，使得面 $j$ 位于左侧单元 $(j-1) \\bmod N$ 和右侧单元 $j$ 之间。\n\n仅使用基于每个面的光滑性和对称性原理，通过对相邻单元中心值进行中心插值，构造面对上函数值 $\\phi(x_f^{(j)})$ 的一个二阶精确近似 $\\phi_f$。对于每个网格，计算面插值误差的离散 $L_2$ 范数\n$$\n\\|e\\|_{L_2} = \\left( \\Delta x \\sum_{j=0}^{N-1} \\left[\\phi_f^{(j)} - \\phi\\!\\left(x_f^{(j)}\\right)\\right]^2 \\right)^{1/2},\n$$\n然后通过最小二乘法对整个网格族的数据 $\\left(\\ln \\Delta x, \\ln \\|e\\|_{L_2}\\right)$ 进行直线拟合，将斜率作为观测精度阶 $p$ 来估计。\n\n使用以下波数 $k$ 的测试集：\n- $k = 2\\pi$（一个波长横跨整个域），作为一般情况，\n- $k = 8\\pi$（四个波长），用于探测更高频率的内容，\n- $k = 32\\pi$（十六个波长），用于挑战分辨率。\n\n所有角度必须以弧度为单位。如果某个测试用例在整个网格族上的所有计算误差在数值上均为零，则定义该用例的观测阶 $p$ 为 $+\\infty$。\n\n您的程序应生成单行输出，其中包含三个观测阶，其顺序与测试集相同，格式为用方括号括起来的逗号分隔列表（例如 $[p_1,p_2,p_3]$）。输出必须是实数（浮点值）；如果某个用例根据上述规则得到无穷观测阶，则应将其打印为由标准浮点数无穷大表示的 $+\\infty$。",
            "solution": "本解答旨在通过人造解方法（Method of Manufactured Solutions, MMS）数值验证中心插值格式的精度阶。首先，我们构建一个适用于均匀周期网格的中心插值格式，即取相邻单元中心值的算术平均作为面心值。其次，通过泰勒级数展开，从理论上证明该格式的截断误差为 $O(\\Delta x^2)$，即二阶精确。最后，我们编写一个计算程序，该程序对一系列逐渐加密的网格执行此插值，计算离散 $L_2$ 误差范数，并通过对数-对数图上的线性回归来确定观测到的收敛阶。\n\n问题的核心是为变量 $\\phi$ 构建一个从单元中心值到面位置的二阶精确中心插值格式，然后数值上验证其精度阶。\n\n首先，我们根据指定的光滑性和对称性原理设计插值格式。考虑一个间距为 $\\Delta x = 1/N$ 的一维均匀网格。单元中心位于 $x_i = (i + 1/2)\\Delta x$（其中 $i \\in \\{0, 1, \\dots, N-1\\}$），面位于 $x_{f}^{(j)} = j \\Delta x$（其中 $j \\in \\{0, 1, \\dots, N-1\\}$）。根据问题陈述，面 $j$ 位于单元 $(j-1) \\pmod N$ 和单元 $j$ 之间。这两个单元中心的位置是 $x_{j-1} = ((j-1) + 1/2)\\Delta x$ 和 $x_j = (j + 1/2)\\Delta x$。面位置 $x_f^{(j)}$ 是这两个单元中心的中点：\n$$\n\\frac{x_{j-1} + x_j}{2} = \\frac{((j - 1/2) + (j + 1/2))\\Delta x}{2} = \\frac{2j\\Delta x}{2} = j\\Delta x = x_f^{(j)}\n$$\n鉴于底层函数 $\\phi(x)$ 是光滑的，并且插值模板关于目标点 $x_f^{(j)}$ 对称，最简单、最自然的中心插值格式是在两个相邻单元中心值 $\\phi_{j-1} = \\phi(x_{j-1})$ 和 $\\phi_j = \\phi(x_j)$ 之间进行线性插值。由于 $x_f^{(j)}$ 是中点，这对应于算术平均值：\n$$\n\\phi_f^{(j)} = \\frac{\\phi_{j-1} + \\phi_j}{2}\n$$\n当 $j=0$ 时，使用周期性索引 $(j-1) \\pmod N$ 来找到“左侧”单元 $\\phi_{j-1}$。\n\n接下来，我们必须验证此格式是否如要求的那样具有二阶精度。我们在面位置 $x_f^{(j)}$ 周围对 $\\phi(x)$ 进行泰勒级数展开。相邻的单元中心距离该面的距离为 $\\pm \\Delta x/2$。\n$$\n\\phi_j = \\phi(x_j) = \\phi\\left(x_f^{(j)} + \\frac{\\Delta x}{2}\\right) = \\phi(x_f^{(j)}) + \\phi'(x_f^{(j)})\\frac{\\Delta x}{2} + \\frac{1}{2}\\phi''(x_f^{(j)})\\left(\\frac{\\Delta x}{2}\\right)^2 + \\frac{1}{6}\\phi'''(x_f^{(j)})\\left(\\frac{\\Delta x}{2}\\right)^3 + \\mathcal{O}(\\Delta x^4)\n$$\n$$\n\\phi_{j-1} = \\phi(x_{j-1}) = \\phi\\left(x_f^{(j)} - \\frac{\\Delta x}{2}\\right) = \\phi(x_f^{(j)}) - \\phi'(x_f^{(j)})\\frac{\\Delta x}{2} + \\frac{1}{2}\\phi''(x_f^{(j)})\\left(\\frac{\\Delta x}{2}\\right)^2 - \\frac{1}{6}\\phi'''(x_f^{(j)})\\left(\\frac{\\Delta x}{2}\\right)^3 + \\mathcal{O}(\\Delta x^4)\n$$\n将这些展开式代入插值公式：\n$$\n\\phi_f^{(j)} = \\frac{1}{2}(\\phi_{j-1} + \\phi_j) = \\frac{1}{2}\\left[2\\phi(x_f^{(j)}) + \\phi''(x_f^{(j)})\\frac{\\Delta x^2}{4} + \\mathcal{O}(\\Delta x^4)\\right] = \\phi(x_f^{(j)}) + \\frac{1}{8}\\phi''(x_f^{(j)})\\Delta x^2 + \\mathcal{O}(\\Delta x^4)\n$$\n面 $j$ 处的插值误差，记为 $e_j$，是插值与精确值之差：\n$$\ne_j = \\phi_f^{(j)} - \\phi(x_f^{(j)}) = \\frac{1}{8}\\phi''(x_f^{(j)})\\Delta x^2 + \\mathcal{O}(\\Delta x^4)\n$$\n由于误差的主导项与 $\\Delta x^2$ 成正比，因此该格式是二阶精确的，满足了问题的要求。\n\n为了确定观测精度阶 $p$，我们为一系列逐渐加密的网格计算误差的 $L_2$ 范数 $\\|e\\|_{L_2}$。误差范数与网格间距之间的理论关系是 $\\|e\\|_{L_2} \\approx C(\\Delta x)^p$，其中 $C$ 是一个常数。对两边取自然对数得到：\n$$\n\\ln(\\|e\\|_{L_2}) \\approx \\ln(C) + p \\ln(\\Delta x)\n$$\n该方程具有直线 $y = m x + b$ 的形式，其中 $y = \\ln(\\|e\\|_{L_2})$，$x = \\ln(\\Delta x)$，斜率是精度阶 $m=p$，y轴截距是 $b = \\ln(C)$。\n\n计算步骤如下：\n1. 对于测试集 $\\{2\\pi, 8\\pi, 32\\pi\\}$ 中的每个波数 $k$：\n2. 对于网格族 $\\{10, 20, 40, 80\\}$ 中的每个网格尺寸 $N$：\n    a. 计算网格间距 $\\Delta x = 1/N$。\n    b. 定义单元中心位置数组 $x_i$ 和面位置数组 $x_f^{(j)}$。\n    c. 在单元中心处计算人造解 $\\phi(x) = \\sin(kx)$ 以获得 $\\{\\phi_i\\}$。\n    d. 在面中心处计算精确解以获得 $\\{\\phi(x_f^{(j)})\\}$。\n    e. 使用 $\\phi_f^{(j)} = (\\phi_{(j-1)\\pmod N} + \\phi_j)/2$ 计算插值面值 $\\{\\phi_f^{(j)}\\}$。\n    f. 计算面插值误差的离散 $L_2$ 范数：$\\|e\\|_{L_2} = \\left( \\Delta x \\sum_{j=0}^{N-1} [\\phi_f^{(j)} - \\phi(x_f^{(j)})]^2 \\right)^{1/2}$。\n    g. 存储数据对 $(\\ln \\Delta x, \\ln \\|e\\|_{L_2})$。\n3. 检查给定 $k$ 的所有计算误差是否在数值上为零。如果是，则设 $p = +\\infty$。\n4. 否则，对点集 $(\\ln \\Delta x, \\ln \\|e\\|_{L_2})$ 进行线性最小二乘回归，以找到斜率，即观测精度阶 $p$。\n\n对三个给定的波数分别执行此过程，以产生最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the observed order of accuracy for a central interpolation scheme.\n\n    The problem involves a 1D periodic domain with a manufactured solution\n    phi(x) = sin(k*x). The value at a cell face is interpolated from the two\n    neighboring cell centers using a second-order accurate central scheme, which\n    is the arithmetic mean of the neighboring values.\n\n    The L2 error of this interpolation is computed for a family of meshes. The\n    observed order of accuracy is then determined by a least-squares fit on\n    the log-log plot of the error vs. mesh size.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    k_values = [2 * np.pi, 8 * np.pi, 32 * np.pi]\n    N_values = [10, 20, 40, 80]\n    \n    # Store the observed order of accuracy for each k.\n    observed_orders = []\n\n    for k in k_values:\n        log_dx_list = []\n        log_error_list = []\n        errors_for_case = []\n        \n        for N in N_values:\n            # 1. Define mesh parameters and grid locations.\n            dx = 1.0 / N\n            # Cell centers: x_i = (i + 1/2) * dx\n            x_cell = (np.arange(N) + 0.5) * dx\n            # Face centers: x_f = j * dx\n            x_face = np.arange(N) * dx\n\n            # 2. Evaluate the manufactured solution.\n            # Cell-centered values of the solution.\n            phi_cell = np.sin(k * x_cell)\n            # Exact solution at face locations.\n            phi_face_exact = np.sin(k * x_face)\n\n            # 3. Perform central interpolation for face values.\n            # The scheme is phi_f[j] = 0.5 * (phi_cell[j-1] + phi_cell[j]).\n            # np.roll(phi_cell, 1) provides periodic shifting, so that\n            # phi_left[j] = phi_cell[j-1] (and phi_left[0] = phi_cell[N-1]).\n            phi_left_neighbor = np.roll(phi_cell, 1)\n            phi_right_neighbor = phi_cell\n            phi_face_interp = 0.5 * (phi_left_neighbor + phi_right_neighbor)\n\n            # 4. Compute the discrete L2 norm of the interpolation error.\n            error_vector = phi_face_interp - phi_face_exact\n            l2_error = np.sqrt(dx * np.sum(error_vector**2))\n            \n            errors_for_case.append(l2_error)\n            \n            # Store log-values for regression, avoiding log(0).\n            # A small tolerance is used to check for numerical zero.\n            if l2_error > 1e-16:\n                log_dx_list.append(np.log(dx))\n                log_error_list.append(np.log(l2_error))\n\n        # 5. Estimate the order of accuracy.\n        # Check for the special case of all errors being numerically zero.\n        if np.all(np.array(errors_for_case)  1e-16):\n            order = np.inf\n        # Ensure at least two points for a meaningful line fit.\n        elif len(log_dx_list) >= 2:\n            # Perform a linear least-squares fit to find the slope.\n            # The model is log(error) = p * log(dx) + C.\n            # np.polyfit returns [slope, intercept].\n            p, _ = np.polyfit(log_dx_list, log_error_list, 1)\n            order = p\n        else:\n            # This case (fewer than 2 non-zero points) is unlikely but\n            # would mean the order cannot be determined from the fit.\n            # We'll assign NaN as a signal of this undefined state.\n            order = np.nan\n            \n        observed_orders.append(order)\n\n    # Final print statement in the exact required format.\n    # The default string representation of np.inf is 'inf', which is the\n    # standard representation for floating-point infinity.\n    print(f\"[{','.join(map(str, observed_orders))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "中心插值的稳定性限制在实践中常常表现为非物理的数值振荡，尤其是在求解具有尖锐梯度的标量（如浓度 $\\phi$）时。本练习介绍了一种先进的修正技术——通量修正输运（Flux-Corrected Transport, FCT），它系统地修正中心插值格式以强制施加非负性等物理约束。通过本练习，你将学习如何通过融合中心插值的精度和更简单格式的稳定性，来构建一个鲁棒的高分辨率格式。",
            "id": "3298519",
            "problem": "考虑一个带有局部源项 $S(x)$ 的非负标量浓度 $\\phi(x,t)$ 的一维守恒输运，其受守恒律控制\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(u\\phi\\right) = S(x),\n$$\n其中 $u$ 是一个恒定速度。在覆盖长度为 $L$ 的周期性域的 $N$ 个控制体的均匀网格上，使用有限体积离散化。令时间 $t^n$ 的网格平均值表示为 $\\phi_i^n$，其中网格索引 $i \\in \\{0,1,\\dots,N-1\\}$，均匀间距为 $\\Delta x = L/N$，时间步长为 $\\Delta t$。将网格 $i$ 和 $i+1$ 之间的右侧面定义为索引 $i+\\tfrac{1}{2}$, 对于 $i=\\{-1,N\\}$ 采用周期性索引。假设采用一阶算子分裂法，其中源项首先被显式施加，然后进行输运：\n$$\n\\tilde{\\phi}_i = \\phi_i^n + \\Delta t S_i,\n$$\n然后\n$$\n\\phi_i^{n+1} = \\tilde{\\phi}_i - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}} - F_{i-\\tfrac{1}{2}}\\right).\n$$\n这里 $F_{i+\\tfrac{1}{2}}$ 是在面 $i+\\tfrac{1}{2}$ 上根据 $\\tilde{\\phi}$ 计算得到的数值平流通量。考虑由下式定义的中心面插值\n$$\n\\phi_{i+\\tfrac{1}{2}}^{\\text{cen}} = \\frac{\\tilde{\\phi}_i + \\tilde{\\phi}_{i+1}}{2},\\quad F_{i+\\tfrac{1}{2}}^{H} = u\\phi_{i+\\tfrac{1}{2}}^{\\text{cen}}.\n$$\n为了比较，定义保持正性的低阶迎风通量\n$$\nF_{i+\\tfrac{1}{2}}^{L} =\n\\begin{cases}\nu\\tilde{\\phi}_i,  u0,\\\\\nu\\tilde{\\phi}_{i+1},  u0.\n\\end{cases}\n$$\n令高阶纯中心格式更新为\n$$\n\\phi_i^{H} = \\tilde{\\phi}_i - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^{H} - F_{i-\\tfrac{1}{2}}^{H}\\right),\n$$\n以及低阶迎风格式更新为\n$$\n\\phi_i^{L} = \\tilde{\\phi}_i - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^{L} - F_{i-\\tfrac{1}{2}}^{L}\\right).\n$$\n您的任务有两部分：\n- 从有限体积守恒形式和上述定义出发，分析当 $\\tilde{\\phi}$ 因 $S(x)$ 而强局部化时，中心面插值如何在一步输运后可能产生负浓度。\n- 设计并实现一个通量修正输运步骤，该步骤最小化地扰动中心通量以强制 $\\phi^{n+1}$ 的非负性。具体来说，构造反扩散通量 $A_{i+\\tfrac{1}{2}} = F_{i+\\tfrac{1}{2}}^{H} - F_{i+\\tfrac{1}{2}}^{L}$，定义每个网格的下界容许量 $P_i^{-} = \\phi_i^{L}$，并选择面限制器 $\\alpha_{i+\\tfrac{1}{2}} \\in [0,1]$，使得受限的反扩散在满足约束的同时保持非负性并最大化 $\\alpha_{i+\\tfrac{1}{2}}$。受限更新必须为\n$$\n\\phi_i^{\\text{FCT}} = \\phi_i^{L} - \\frac{\\Delta t}{\\Delta x}\\left(\\alpha_{i+\\tfrac{1}{2}}A_{i+\\tfrac{1}{2}} - \\alpha_{i-\\tfrac{1}{2}}A_{i-\\tfrac{1}{2}}\\right).\n$$\n使用周期性边界条件。所有浓度都是无量纲的，不需要进行物理单位转换。\n\n限制器的设计要求如下。对于每个网格，考虑来自各个面的反扩散贡献：\n$$\nc_{i,+} = -\\frac{\\Delta t}{\\Delta x}A_{i+\\tfrac{1}{2}},\\quad c_{i,-} = \\frac{\\Delta t}{\\Delta x}A_{i-\\tfrac{1}{2}}.\n$$\n计算其负值部分之和\n$$\n\\Sigma_i^{-} = \\sum_{\\sigma \\in \\{+,-\\}} \\min\\left(0, c_{i,\\sigma}\\right).\n$$\n定义每个网格的缩减因子\n$$\nr_i^{-} =\n\\begin{cases}\n1,  \\Sigma_i^{-} = 0,\\\\\n\\min\\left(1,\\dfrac{P_i^{-}}{-\\Sigma_i^{-}}\\right),  \\Sigma_i^{-}  0,\n\\end{cases}\n$$\n并通过下式设置面限制器\n$$\n\\alpha_{i+\\tfrac{1}{2}} =\n\\begin{cases}\nr_i^{-},  A_{i+\\tfrac{1}{2}} \\ge 0,\\\\\nr_{i+1}^{-},  A_{i+\\tfrac{1}{2}}  0.\n\\end{cases}\n$$\n此选择必须确保 $\\phi^{\\text{FCT}}$ 的非负性，同时仅在必要时扰动中心通量。\n\n为以下测试套件实现该格式。对于每个案例，初始化所有 $i$ 的 $\\phi_i^0 = 0$，在单个网格索引 $i_0$ 处放置一个强度为 $Q > 0$ 的局部源，施加一个源-输运分裂步骤，使得 $\\Delta t S_{i_0} = Q$ 且对于 $i \\ne i_0$ 有 $S_i = 0$。选择 $\\Delta t$ 以满足目标库朗数 $\\mathsf{C} = |u|\\Delta t/\\Delta x$。四个测试案例如下：\n1. $N=50$, $L=1.0$, $u=1.0$, $\\mathsf{C}=0.8$, $Q=1.0$, $i_0=12$.\n2. $N=50$, $L=1.0$, $u=-1.0$, $\\mathsf{C}=0.8$, $Q=1.0$, $i_0=12$.\n3. $N=50$, $L=1.0$, $u=1.0$, $\\mathsf{C}=0.8$, $Q=4.0$, $i_0=0$.\n4. $N=50$, $L=1.0$, $u=1.0$, $\\mathsf{C}=0.95$, $Q=1.0$, $i_0=25$.\n\n对于每个案例，执行一个源项步骤和一个输运步骤，并计算最小值 $\\min_i \\phi_i^{H}$ 和 $\\min_i \\phi_i^{\\text{FCT}}$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，其中每个元素是对应测试案例的一个双元素列表 $[\\min_i \\phi_i^{H},\\min_i \\phi_i^{\\text{FCT}}]$，例如 $[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]]$，其中 $a_k$ 和 $b_k$ 是十进制数。",
            "solution": "用户提供了来自计算流体动力学领域的有效问题陈述，具体涉及一维平流方程的通量修正输运 (FCT) 格式的实现与分析。该问题具有科学依据、是适定的，并且为获得唯一解提供了所有必要的参数和定义。\n\n任务分为两部分：首先，提供理论分析，解释为何简单的平流通量中心差分格式会导致非物理的负值；其次，设计并实现一个特定的 FCT 格式来修正此问题。\n\n### 中心面插值分析\n输运步骤的有限体积更新由下式给出：\n$$ \\phi_i^{n+1} = \\tilde{\\phi}_i - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}} - F_{i-\\tfrac{1}{2}}\\right) $$\n其中 $\\tilde{\\phi}_i$ 是源项步骤后网格 $i$ 中的浓度。高阶更新 $\\phi_i^H$ 使用中心通量 $F^H$：\n$$ F_{i+\\tfrac{1}{2}}^{H} = u\\phi_{i+\\tfrac{1}{2}}^{\\text{cen}} = u\\frac{\\tilde{\\phi}_i + \\tilde{\\phi}_{i+1}}{2} $$\n将此通量代入更新方程，得到高阶更新的显式形式：\n$$ \\phi_i^{H} = \\tilde{\\phi}_i - \\frac{\\Delta t}{\\Delta x}\\left( u\\frac{\\tilde{\\phi}_i + \\tilde{\\phi}_{i+1}}{2} - u\\frac{\\tilde{\\phi}_{i-1} + \\tilde{\\phi}_{i}}{2} \\right) $$\n$$ \\phi_i^{H} = \\tilde{\\phi}_i - \\frac{u\\Delta t}{2\\Delta x}\\left( \\tilde{\\phi}_{i+1} - \\tilde{\\phi}_{i-1} \\right) $$\n令带符号的库朗数为 $\\mathsf{C}_u = u\\Delta t/\\Delta x$。更新变为：\n$$ \\phi_i^{H} = \\tilde{\\phi}_i - \\frac{\\mathsf{C}_u}{2}\\left( \\tilde{\\phi}_{i+1} - \\tilde{\\phi}_{i-1} \\right) $$\n现在，考虑单步问题的初始条件：所有 $i$ 的 $\\phi_i^0=0$，在单个网格 $i_0$ 处有局部源 $\\Delta t S_{i_0} = Q$。源项步骤之后，状态为 $\\tilde{\\phi}_{i_0} = Q$ 且 $\\tilde{\\phi}_{i \\ne i_0} = 0$。我们分析 $i_0$ 处脉冲附近的网格更新。\n\n让我们假设速度为正 $u  0$，因此 $\\mathsf{C}_u = \\mathsf{C} = |u|\\Delta t / \\Delta x  0$。\n- 对于网格 $i_0+1$ (下游)：\n  $$ \\phi_{i_0+1}^H = \\tilde{\\phi}_{i_0+1} - \\frac{\\mathsf{C}}{2}\\left( \\tilde{\\phi}_{i_0+2} - \\tilde{\\phi}_{i_0} \\right) = 0 - \\frac{\\mathsf{C}}{2}(0 - Q) = \\frac{\\mathsf{C}}{2}Q $$\n  这是一个正值，代表脉冲的平流输运。\n- 对于网格 $i_0-1$ (上游)：\n  $$ \\phi_{i_0-1}^H = \\tilde{\\phi}_{i_0-1} - \\frac{\\mathsf{C}}{2}\\left( \\tilde{\\phi}_{i_0} - \\tilde{\\phi}_{i_0-2} \\right) = 0 - \\frac{\\mathsf{C}}{2}(Q - 0) = -\\frac{\\mathsf{C}}{2}Q $$\n这个结果是明确的负值。中心格式在利用网格 $i-2$ 和 $i$ 的值来近似网格 $i-1$ 处的空间导数时，在传播脉冲的上游产生了一个非物理的下冲。这是线性二阶格式的一个典型缺陷，这类格式不保持单调性，并且可能产生新的极小值和极大值（吉布斯现象）。此负浓度的量级与库朗数和脉冲强度均成正比。对于 $u  0$ 的类似分析表明，在网格 $i_0+1$ 处会出现负下冲。\n\n### 通量修正输运 (FCT) 格式\n\nFCT 方法通过将一个低阶、保持正性的格式与一个高阶、更精确的格式相混合来解决这个问题。该过程确保来自高阶格式的修正（反扩散）不会违反非负性约束。\n\n**1. 低阶保持正性解**\n其基础是一阶迎风格式，已知该格式是耗散的，但能保证在库朗数 $\\mathsf{C} \\le 1$ 时解的正性。其更新为：\n$$ \\phi_i^{L} = \\tilde{\\phi}_i - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^{L} - F_{i-\\tfrac{1}{2}}^{L}\\right) $$\n对于 $u0$ 和给定的脉冲初始条件，可以证明 $\\phi_i^L = \\tilde{\\phi}_i - \\mathsf{C}(\\tilde{\\phi}_i - \\tilde{\\phi}_{i-1})$。对于 $i_0$ 处的脉冲，这得出 $\\phi_{i_0}^L = (1-\\mathsf{C})Q$ 和 $\\phi_{i_0+1}^L = \\mathsf{C}Q$，所有其他值均为零。由于 $\\mathsf{C} \\le 1$，所有 $\\phi_i^L \\ge 0$。这个非负场 $\\phi_i^L$ 作为基准，并定义了可用于反扩散修正的“空间”，即 $P_i^{-} = \\phi_i^L$。\n\n**2. 反扩散通量与限制器设计**\n高阶和低阶通量之差即为反扩散通量, $A_{i+\\tfrac{1}{2}} = F_{i+\\tfrac{1}{2}}^{H} - F_{i+\\tfrac{1}{2}}^{L}$，它代表了恢复二阶精度所需的修正量。FCT 更新被表述为低阶解加上一个受限的反扩散修正：\n$$ \\phi_i^{\\text{FCT}} = \\phi_i^{L} - \\frac{\\Delta t}{\\Delta x}\\left(\\alpha_{i+\\tfrac{1}{2}}A_{i+\\tfrac{1}{2}} - \\alpha_{i-\\tfrac{1}{2}}A_{i-\\tfrac{1}{2}}\\right) $$\n该方法的核心在于选择面限制器 $\\alpha_{i+\\tfrac{1}{2}} \\in [0,1]$。具体算法如下：\n\n- **步骤 1：计算每个网格的反扩散贡献**：对每个网格 $i$，计算来自右侧面 ($i+\\frac{1}{2}$) 和左侧面 ($i-\\frac{1}{2}$) 的反扩散引起的潜在变化：\n  $$ c_{i,+} = -\\frac{\\Delta t}{\\Delta x}A_{i+\\tfrac{1}{2}}, \\quad c_{i,-} = \\frac{\\Delta t}{\\Delta x}A_{i-\\tfrac{1}{2}} $$\n- **步骤 2：求和负贡献**：对每个网格 $i$，将所有可能导致 $\\phi_i^L$ 减小的传入反扩散贡献求和：\n  $$ \\Sigma_i^{-} = \\min\\left(0, c_{i,+}\\right) + \\min\\left(0, c_{i,-}\\right) $$\n- **步骤 3：计算每个网格的缩减因子**：该因子 $r_i^-$ 决定了负向通量必须被缩减多少以防止 $\\phi_i$ 变为负值。此操作的“裕量”为 $P_i^{-} = \\phi_i^L$。\n  $$ r_i^{-} = \\begin{cases} 1,  \\text{if } \\Sigma_i^{-} = 0 \\\\ \\min\\left(1, \\frac{P_i^{-}}{-\\Sigma_i^{-}}\\right),  \\text{if } \\Sigma_i^{-}  0 \\end{cases} $$\n  这确保了总的受限负贡献 $r_i^- \\Sigma_i^-$ 的量级不会超过 $\\phi_i^L$。\n\n- **步骤 4：计算面限制器**：每个网格的因子 $r^-$ 用于确定每个面的限制器 $\\alpha$。其选择取决于哪个网格是反扩散通量的“施主”网格。这由 $A_{i+\\tfrac{1}{2}}$ 的符号决定：\n  $$ \\alpha_{i+\\tfrac{1}{2}} = \\begin{cases} r_i^{-},  \\text{if } A_{i+\\tfrac{1}{2}} \\ge 0 \\\\ r_{i+1}^{-},  \\text{if } A_{i+\\tfrac{1}{2}}  0 \\end{cases} $$\n  如果 $A_{i+\\tfrac{1}{2}} \\ge 0$ (对于 $u0$)，它对应于从网格 $i$ 到 $i+1$ 的反扩散通量。因此，限制由网格 $i$ 中的可用量通过 $r_i^-$ 控制。反之，如果 $A_{i+\\tfrac{1}{2}}  0$，反扩散从 $i+1$ 流向 $i$，则使用限制器 $r_{i+1}^-$。这种构造保证了对于任何网格 $i$，所有受限的负向反扩散通量之和不会超过 $\\phi_i^L$，从而确保 $\\phi_i^{\\text{FCT}} \\ge 0$。\n\n- **步骤 5：计算最终解**：在确定限制器 $\\alpha_{i+\\tfrac{1}{2}}$后，使用 FCT 更新公式计算最终的非负解 $\\phi_i^{\\text{FCT}}$。根据设计，此格式最小化地扰动更精确的中心通量，仅在必要时施加修正以保持正性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection problem using high-order central and \n    flux-corrected transport (FCT) schemes for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # (N, L, u, C, Q, i0)\n        (50, 1.0, 1.0, 0.8, 1.0, 12),\n        (50, 1.0, -1.0, 0.8, 1.0, 12),\n        (50, 1.0, 1.0, 0.8, 4.0, 0),\n        (50, 1.0, 1.0, 0.95, 1.0, 25),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, u, C, Q, i0 = case\n        \n        # Grid and time step setup\n        dx = L / N\n        dt = C * dx / abs(u)\n        \n        # Initial condition and source step\n        phi_n = np.zeros(N)\n        tilde_phi = np.copy(phi_n)\n        tilde_phi[i0] += Q # Problem statement: delta_t * S_i0 = Q\n        \n        # Prepare shifted arrays for periodic boundaries\n        tilde_phi_ip1 = np.roll(tilde_phi, -1) # phi_{i+1} at index i\n        \n        # --- Flux calculations ---\n        # High-order central flux (F_H)\n        F_H = u * (tilde_phi + tilde_phi_ip1) / 2.0\n        \n        # Low-order upwind flux (F_L)\n        if u > 0:\n            F_L = u * tilde_phi\n        else:\n            F_L = u * tilde_phi_ip1\n            \n        # Antidiffusive flux (A)\n        A = F_H - F_L\n\n        # --- Compute H and L solutions ---\n        # Get fluxes at i-1/2 face for divergence calculation\n        F_H_im1 = np.roll(F_H, 1)\n        F_L_im1 = np.roll(F_L, 1)\n        \n        # High-order update (phi_H)\n        phi_H = tilde_phi - (dt / dx) * (F_H - F_H_im1)\n        \n        # Low-order update (phi_L), which is also P_minus\n        phi_L = tilde_phi - (dt / dx) * (F_L - F_L_im1)\n        P_minus = phi_L\n\n        # --- FCT Limiter Calculation ---\n        # Antidiffusive contributions per cell\n        c_plus = -(dt / dx) * A\n        c_minus = (dt / dx) * np.roll(A, 1)\n        \n        # Sum of negative parts\n        Sigma_minus = np.minimum(0.0, c_plus) + np.minimum(0.0, c_minus)\n        \n        # Per-cell reduction factor (r_minus)\n        r_minus = np.ones(N)\n        # Use a mask to avoid division by zero and handle the case Sigma_minus = 0\n        neg_sigma_mask = Sigma_minus  0\n        \n        # The denominator -Sigma_minus is positive where the mask is true\n        r_minus[neg_sigma_mask] = np.minimum(1.0, P_minus[neg_sigma_mask] / (-Sigma_minus[neg_sigma_mask]))\n        \n        # Face limiter (alpha) based on donor cell logic from the problem statement\n        r_minus_ip1 = np.roll(r_minus, -1)\n        alpha = np.where(A >= 0, r_minus, r_minus_ip1)\n        \n        # --- Final FCT Update ---\n        A_limited = alpha * A\n        div_A_limited = A_limited - np.roll(A_limited, 1)\n        phi_FCT = phi_L - (dt / dx) * div_A_limited\n        \n        # Record the minimum values\n        min_H = np.min(phi_H)\n        min_FCT = np.min(phi_FCT)\n        results.append([min_H, min_FCT])\n\n    # Format the final output string exactly as required\n    inner_strings = [f\"[{h:.6f},{fct:.6f}]\" for h, fct in results]\n    final_string = f\"[{','.join(inner_strings)}]\"\n    print(final_string)\n\nsolve()\n```"
        }
    ]
}