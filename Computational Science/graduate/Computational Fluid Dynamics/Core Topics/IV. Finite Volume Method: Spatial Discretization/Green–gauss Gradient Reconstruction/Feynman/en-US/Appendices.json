{
    "hands_on_practices": [
        {
            "introduction": "The Green-Gauss theorem transforms the challenge of finding a volume-averaged gradient into the geometric task of summing contributions over a cell's boundary. This exercise grounds the theory in a concrete calculation. By applying the discretized Green-Gauss formula to a simple tetrahedral cell, you will compute the essential geometric quantities—cell volume, face area vectors, and face centroids—and use them to reconstruct the gradient of a linear scalar field, revealing a key accuracy property of the method. ",
            "id": "3325620",
            "problem": "In computational fluid dynamics (CFD), the finite volume method (FVM) commonly reconstructs gradients using the Green–Gauss approach. Starting from the divergence theorem and foundational FVM concepts, derive an explicit cell-based gradient estimator that depends on face-centered scalar values, face area vectors, and the cell volume. Then evaluate this estimator for the following tetrahedral control volume and scalar field.\n\nConsider the tetrahedral control volume in three dimensions with vertices at $\\,\\mathbf{v}_{0}=(0,0,0)\\,$, $\\,\\mathbf{v}_{1}=(1,0,0)\\,$, $\\,\\mathbf{v}_{2}=(0,1,0)\\,$, and $\\,\\mathbf{v}_{3}=(0,0,1)\\,$. Let the scalar field be $\\,\\phi(\\mathbf{x})=2x-3y+4z+1\\,$. Compute for each face of the tetrahedron:\n- the face area vector $\\,\\mathbf{S}_{f}\\,$ pointing outward,\n- the face centroid $\\,\\mathbf{x}_{f}\\,$,\n\nand then, using only face-centered values $\\,\\phi(\\mathbf{x}_{f})\\,$ and outward face area vectors $\\,\\mathbf{S}_{f}\\,$, evaluate the Green–Gauss gradient estimate for this cell.\n\nYour final answer must be the gradient vector as a single row matrix $\\,\\big[\\partial \\phi/\\partial x,\\ \\partial \\phi/\\partial y,\\ \\partial \\phi/\\partial z\\big]\\,$ with exact values. No rounding is required. Do not include units.",
            "solution": "The problem requires the derivation of the cell-based Green–Gauss gradient estimator and its application to a specific tetrahedral control volume with a linear scalar field.\n\nFirst, we derive the general formula. The derivation starts from a variant of the divergence theorem for the gradient of a scalar field $\\phi$:\n$$ \\int_V \\nabla \\phi \\, dV = \\oint_{\\partial V} \\phi \\, d\\mathbf{S} $$\nwhere $V$ is a control volume and $\\partial V$ is its bounding surface. $d\\mathbf{S}$ is the differential area vector, defined as $\\mathbf{n} dS$ where $\\mathbf{n}$ is the outward-pointing unit normal vector.\n\nIn the context of the finite volume method (FVM), we apply this theorem to a single polyhedral cell (control volume), which we denote as $P$ with volume $V_P$. The integral equation becomes:\n$$ \\int_{V_P} \\nabla \\phi \\, dV = \\oint_{\\partial V_P} \\phi \\, d\\mathbf{S} $$\nTo obtain an algebraic approximation, we make two key assumptions:\n1. The gradient $\\nabla \\phi$ is assumed to be constant throughout the cell $P$. We denote this cell-averaged gradient as $(\\nabla \\phi)_P$. This allows us to write the left-hand side as:\n$$ \\int_{V_P} \\nabla \\phi \\, dV \\approx (\\nabla \\phi)_P \\int_{V_P} dV = (\\nabla \\phi)_P V_P $$\n2. The boundary of the cell $\\partial V_P$ is composed of a finite number of flat faces, indexed by $f$. The surface integral can be written as a sum of integrals over these faces:\n$$ \\oint_{\\partial V_P} \\phi \\, d\\mathbf{S} = \\sum_f \\int_{S_f} \\phi \\, d\\mathbf{S} $$\nFor each face integral, we assume the scalar value $\\phi$ is constant over the face $S_f$ and equal to its value at the face centroid, $\\phi_f = \\phi(\\mathbf{x}_f)$. This approximation gives:\n$$ \\int_{S_f} \\phi \\, d\\mathbf{S} \\approx \\phi_f \\int_{S_f} d\\mathbf{S} = \\phi_f \\mathbf{S}_f $$\nwhere $\\mathbf{S}_f = \\int_{S_f} d\\mathbf{S}$ is the area vector of face $f$.\n\nCombining these approximations, we have:\n$$ (\\nabla \\phi)_P V_P \\approx \\sum_f \\phi_f \\mathbf{S}_f $$\nSolving for the cell gradient $(\\nabla \\phi)_P$ yields the Green–Gauss gradient estimator:\n$$ (\\nabla \\phi)_P = \\frac{1}{V_P} \\sum_f \\phi_f \\mathbf{S}_f $$\nThis formula provides an explicit estimate for the gradient within a cell based on the cell volume $V_P$, the scalar values at the face centroids $\\phi_f$, and the face area vectors $\\mathbf{S}_f$.\n\nNext, we apply this formula to the given tetrahedron with vertices $\\mathbf{v}_{0}=(0,0,0)$, $\\mathbf{v}_{1}=(1,0,0)$, $\\mathbf{v}_{2}=(0,1,0)$, and $\\mathbf{v}_{3}=(0,0,1)$. The scalar field is $\\phi(\\mathbf{x}) = \\phi(x,y,z) = 2x-3y+4z+1$.\n\n1.  **Cell Volume ($V_P$)**: The volume of a tetrahedron with one vertex at the origin and others at $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$ is given by $V_P = \\frac{1}{6}|(\\mathbf{v}_1 \\times \\mathbf{v}_2) \\cdot \\mathbf{v}_3|$.\n    $$ \\mathbf{v}_1 \\times \\mathbf{v}_2 = (1,0,0) \\times (0,1,0) = (0,0,1) $$\n    $$ (\\mathbf{v}_1 \\times \\mathbf{v}_2) \\cdot \\mathbf{v}_3 = (0,0,1) \\cdot (0,0,1) = 1 $$\n    Thus, the volume is $V_P = \\frac{1}{6}$.\n\n2.  **Face Properties**: The tetrahedron has four faces. For each face $f$, we compute its centroid $\\mathbf{x}_f$ and its outward-pointing area vector $\\mathbf{S}_f$. The area vector of a triangular face with vertices $A, B, C$ is $\\mathbf{S}_f = \\frac{1}{2}\\left( (B-A) \\times (C-A) \\right)$, with the vertex order chosen to ensure the vector points outwards.\n\n    - **Face $f_1$ (vertices $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$)**:\n      - Centroid: $\\mathbf{x}_{f_1} = \\frac{1}{3}(\\mathbf{v}_1+\\mathbf{v}_2+\\mathbf{v}_3) = \\frac{1}{3}(1,1,1) = (\\frac{1}{3}, \\frac{1}{3}, \\frac{1}{3})$.\n      - Area vector: $\\mathbf{S}_{f_1} = \\frac{1}{2}((\\mathbf{v}_2-\\mathbf{v}_1) \\times (\\mathbf{v}_3-\\mathbf{v}_1)) = \\frac{1}{2}((-1,1,0) \\times (-1,0,1)) = \\frac{1}{2}(1,1,1)$. This vector points away from the origin (vertex $\\mathbf{v}_0$), so it is outward-pointing.\n      - Scalar value: $\\phi_{f_1} = \\phi(\\frac{1}{3}, \\frac{1}{3}, \\frac{1}{3}) = 2(\\frac{1}{3}) - 3(\\frac{1}{3}) + 4(\\frac{1}{3}) + 1 = \\frac{3}{3} + 1 = 2$.\n\n    - **Face $f_2$ (vertices $\\mathbf{v}_0, \\mathbf{v}_3, \\mathbf{v}_2$)**: This face lies on the $x=0$ plane.\n      - Centroid: $\\mathbf{x}_{f_2} = \\frac{1}{3}(\\mathbf{v}_0+\\mathbf{v}_3+\\mathbf{v}_2) = \\frac{1}{3}(0,1,1) = (0, \\frac{1}{3}, \\frac{1}{3})$.\n      - Area vector: $\\mathbf{S}_{f_2} = \\frac{1}{2}((\\mathbf{v}_3-\\mathbf{v}_0) \\times (\\mathbf{v}_2-\\mathbf{v}_0)) = \\frac{1}{2}((0,0,1) \\times (0,1,0)) = \\frac{1}{2}(-1,0,0)$. This vector points in the negative $x$ direction, away from the tetrahedron's interior.\n      - Scalar value: $\\phi_{f_2} = \\phi(0, \\frac{1}{3}, \\frac{1}{3}) = 2(0) - 3(\\frac{1}{3}) + 4(\\frac{1}{3}) + 1 = \\frac{1}{3} + 1 = \\frac{4}{3}$.\n\n    - **Face $f_3$ (vertices $\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_3$)**: This face lies on the $y=0$ plane.\n      - Centroid: $\\mathbf{x}_{f_3} = \\frac{1}{3}(\\mathbf{v}_0+\\mathbf{v}_1+\\mathbf{v}_3) = \\frac{1}{3}(1,0,1) = (\\frac{1}{3}, 0, \\frac{1}{3})$.\n      - Area vector: $\\mathbf{S}_{f_3} = \\frac{1}{2}((\\mathbf{v}_1-\\mathbf{v}_0) \\times (\\mathbf{v}_3-\\mathbf{v}_0)) = \\frac{1}{2}((1,0,0) \\times (0,0,1)) = \\frac{1}{2}(0,-1,0)$. This vector points in the negative $y$ direction, away from the interior.\n      - Scalar value: $\\phi_{f_3} = \\phi(\\frac{1}{3}, 0, \\frac{1}{3}) = 2(\\frac{1}{3}) - 3(0) + 4(\\frac{1}{3}) + 1 = \\frac{6}{3} + 1 = 3$.\n\n    - **Face $f_4$ (vertices $\\mathbf{v}_0, \\mathbf{v}_2, \\mathbf{v}_1$)**: This face lies on the $z=0$ plane.\n      - Centroid: $\\mathbf{x}_{f_4} = \\frac{1}{3}(\\mathbf{v}_0+\\mathbf{v}_2+\\mathbf{v}_1) = \\frac{1}{3}(1,1,0) = (\\frac{1}{3}, \\frac{1}{3}, 0)$.\n      - Area vector: $\\mathbf{S}_{f_4} = \\frac{1}{2}((\\mathbf{v}_2-\\mathbf{v}_0) \\times (\\mathbf{v}_1-\\mathbf{v}_0)) = \\frac{1}{2}((0,1,0) \\times (1,0,0)) = \\frac{1}{2}(0,0,-1)$. This vector points in the negative $z$ direction, away from the interior.\n      - Scalar value: $\\phi_{f_4} = \\phi(\\frac{1}{3}, \\frac{1}{3}, 0) = 2(\\frac{1}{3}) - 3(\\frac{1}{3}) + 4(0) + 1 = -\\frac{1}{3} + 1 = \\frac{2}{3}$.\n\n3.  **Summation**: We now compute the sum $\\sum_f \\phi_f \\mathbf{S}_f$.\n    $$ \\phi_{f_1}\\mathbf{S}_{f_1} = 2 \\cdot (\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}) = (1, 1, 1) $$\n    $$ \\phi_{f_2}\\mathbf{S}_{f_2} = \\frac{4}{3} \\cdot (-\\frac{1}{2}, 0, 0) = (-\\frac{2}{3}, 0, 0) $$\n    $$ \\phi_{f_3}\\mathbf{S}_{f_3} = 3 \\cdot (0, -\\frac{1}{2}, 0) = (0, -\\frac{3}{2}, 0) $$\n    $$ \\phi_{f_4}\\mathbf{S}_{f_4} = \\frac{2}{3} \\cdot (0, 0, -\\frac{1}{2}) = (0, 0, -\\frac{1}{3}) $$\n\n    The sum is:\n    $$ \\sum_f \\phi_f \\mathbf{S}_f = (1 - \\frac{2}{3}, \\quad 1 - \\frac{3}{2}, \\quad 1 - \\frac{1}{3}) = (\\frac{1}{3}, -\\frac{1}{2}, \\frac{2}{3}) $$\n\n4.  **Gradient Calculation**: Finally, we compute the gradient estimate.\n    $$ (\\nabla \\phi)_P = \\frac{1}{V_P} \\sum_f \\phi_f \\mathbf{S}_f = \\frac{1}{1/6} (\\frac{1}{3}, -\\frac{1}{2}, \\frac{2}{3}) $$\n    $$ (\\nabla \\phi)_P = 6 \\cdot (\\frac{1}{3}, -\\frac{1}{2}, \\frac{2}{3}) = (2, -3, 4) $$\n\nThe estimated gradient is $(2, -3, 4)$.\nThe analytical gradient of the linear scalar field $\\phi(\\mathbf{x}) = 2x-3y+4z+1$ is $\\nabla \\phi = (\\frac{\\partial \\phi}{\\partial x}, \\frac{\\partial \\phi}{\\partial y}, \\frac{\\partial \\phi}{\\partial z}) = (2, -3, 4)$. The Green–Gauss method exactly reproduces the gradient for a linear field, as expected, because the higher-order terms in the Taylor series expansion that constitute the truncation error are zero.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2 & -3 & 4\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While the Green-Gauss method is robust for linear fields, its performance on more complex fields can be compromised by the interplay between the grid and the field data. This practice explores a classic failure mode that arises from symmetry. By analyzing a \"checkerboard-like\" scalar distribution on a structured grid, you will diagnose how the geometric anti-symmetry of opposing face normals is perfectly cancelled by a constructed symmetry in face values, leading to an erroneous zero gradient.  This thought experiment is crucial for understanding the inherent limitations of the basic cell-centered scheme and motivates the need for more advanced approaches.",
            "id": "3325610",
            "problem": "Consider a dimensionless scalar field $\\phi$ defined on a three-dimensional uniform Cartesian mesh composed of congruent hexahedral control volumes of edge length $L$. Focus on a single interior control volume $\\mathcal{C}$ with volume $V=L^{3}$ and six planar faces $\\mathcal{F}_{\\pm x}$, $\\mathcal{F}_{\\pm y}$, and $\\mathcal{F}_{\\pm z}$. Each face has area $A=L^{2}$ and outward unit normal vectors $\\mathbf{n}_{\\pm x}=\\pm \\mathbf{e}_{x}$, $\\mathbf{n}_{\\pm y}=\\pm \\mathbf{e}_{y}$, and $\\mathbf{n}_{\\pm z}=\\pm \\mathbf{e}_{z}$, where $\\mathbf{e}_{x}$, $\\mathbf{e}_{y}$, and $\\mathbf{e}_{z}$ are the standard Cartesian basis vectors.\n\nYou will reconstruct the gradient in $\\mathcal{C}$ using the Green–Gauss (face-based) approach arising from the Divergence Theorem. To model practical finite-volume reconstruction, approximate the face-averaged field value on each interior face by the arithmetic mean of the two neighboring cell-center values sharing that face. Specifically, for an interior face $\\mathcal{F}$ shared by cells $i$ and $j$, take $\\phi_{\\mathcal{F}}=\\tfrac{1}{2}\\left(\\phi_{i}+\\phi_{j}\\right)$.\n\nConstruct a symmetric mesh–field pairing by assigning cell-center values so that opposing neighbor values are equal:\n- At the central cell $\\mathcal{C}$, set $\\phi_{\\mathcal{C}}=\\alpha$, with $\\alpha\\neq 0$.\n- At the neighbors of $\\mathcal{C}$ that share $\\mathcal{F}_{+x}$ and $\\mathcal{F}_{-x}$, set $\\phi_{+x}=\\beta_{x}$ and $\\phi_{-x}=\\beta_{x}$.\n- At the neighbors that share $\\mathcal{F}_{+y}$ and $\\mathcal{F}_{-y}$, set $\\phi_{+y}=\\beta_{y}$ and $\\phi_{-y}=\\beta_{y}$.\n- At the neighbors that share $\\mathcal{F}_{+z}$ and $\\mathcal{F}_{-z}$, set $\\phi_{+z}=\\beta_{z}$ and $\\phi_{-z}=\\beta_{z}$.\n\nYou may take, for concreteness, $\\alpha=2$, $\\beta_{x}=1$, $\\beta_{y}=3$, and $\\beta_{z}=-5$, though the analysis should make clear that the result does not depend on these particular values provided $\\alpha\\neq 0$ and opposing neighbors are equal.\n\nStarting only from the Divergence Theorem and the given geometric data, derive the Green–Gauss gradient reconstruction in $\\mathcal{C}$, evaluate it for the above symmetric assignments with the arithmetic-mean face values, and diagnose the cancellation mechanisms that produce a zero reconstruction in terms of face normal symmetry. Express the final reconstructed gradient $\\nabla \\phi^{\\text{GG}}$ as a row vector with no units. No rounding is required; provide the exact expression.",
            "solution": "The problem asks for the derivation and evaluation of the Green–Gauss gradient reconstruction for a scalar field $\\phi$ in a specific control volume $\\mathcal{C}$ under symmetric field conditions.\n\nThe foundation of the Green–Gauss gradient reconstruction is the Divergence Theorem, which for a vector field $\\mathbf{F}$ over a volume $V$ with boundary surface $\\partial V$ states:\n$$ \\int_{V} (\\nabla \\cdot \\mathbf{F}) dV = \\oint_{\\partial V} \\mathbf{F} \\cdot \\mathbf{n} \\, dS $$\nwhere $\\mathbf{n}$ is the outward-pointing unit normal vector on the surface element $dS$. To adapt this for the gradient of a scalar field $\\phi$, we can use the identity $\\nabla \\cdot (\\phi \\mathbf{c}) = (\\nabla \\phi) \\cdot \\mathbf{c}$ for any arbitrary constant vector $\\mathbf{c}$. Applying the Divergence Theorem to the vector field $\\mathbf{F} = \\phi \\mathbf{c}$ yields:\n$$ \\int_{V} ((\\nabla \\phi) \\cdot \\mathbf{c}) dV = \\oint_{\\partial V} (\\phi \\mathbf{c}) \\cdot \\mathbf{n} \\, dS $$\nSince $\\mathbf{c}$ is a constant vector, we can factor it out of the integrals:\n$$ \\mathbf{c} \\cdot \\int_{V} \\nabla \\phi \\, dV = \\mathbf{c} \\cdot \\oint_{\\partial V} \\phi \\mathbf{n} \\, dS $$\nAs this relation must hold for any constant vector $\\mathbf{c}$, we can conclude that the vectors being dotted with $\\mathbf{c}$ must be equal:\n$$ \\int_{V} \\nabla \\phi \\, dV = \\oint_{\\partial V} \\phi \\mathbf{n} \\, dS $$\nIn the context of the finite volume method, we seek the volume-averaged gradient in the control volume $\\mathcal{C}$, which we denote as $\\nabla \\phi^{\\text{GG}}$. This is approximated as:\n$$ \\nabla \\phi^{\\text{GG}} = \\frac{1}{V} \\int_{\\mathcal{C}} \\nabla \\phi \\, dV = \\frac{1}{V} \\oint_{\\partial \\mathcal{C}} \\phi \\mathbf{n} \\, dS $$\nThe surface integral is discretized by summing over the individual faces $\\mathcal{F}$ of the control volume. On each face $\\mathcal{F}_f$, the scalar field value $\\phi$ is approximated by a constant face-averaged value $\\phi_f$. Since the faces are planar, their outward unit normal vector $\\mathbf{n}_f$ is also constant. The integral over one face becomes $\\int_{\\mathcal{F}_f} \\phi \\mathbf{n} \\, dS \\approx \\phi_f \\mathbf{n}_f A_f$, where $A_f$ is the area of face $f$. The discretized Green–Gauss gradient formula is therefore:\n$$ \\nabla \\phi^{\\text{GG}} = \\frac{1}{V} \\sum_{f \\in \\text{faces}(\\mathcal{C})} \\phi_f A_f \\mathbf{n}_f $$\nNow, we apply this formula to the given hexahedral control volume $\\mathcal{C}$. The volume is $V = L^3$. The six faces are $\\mathcal{F}_{\\pm x}, \\mathcal{F}_{\\pm y}, \\mathcal{F}_{\\pm z}$, each with area $A = L^2$. The corresponding outward unit normals are $\\mathbf{n}_{\\pm x} = \\pm \\mathbf{e}_x$, $\\mathbf{n}_{\\pm y} = \\pm \\mathbf{e}_y$, and $\\mathbf{n}_{\\pm z} = \\pm \\mathbf{e}_z$.\n\nThe summation over the six faces is:\n$$ \\sum_f \\phi_f A_f \\mathbf{n}_f = \\phi_{\\mathcal{F}_{+x}} A \\mathbf{n}_{+x} + \\phi_{\\mathcal{F}_{-x}} A \\mathbf{n}_{-x} + \\phi_{\\mathcal{F}_{+y}} A \\mathbf{n}_{+y} + \\phi_{\\mathcal{F}_{-y}} A \\mathbf{n}_{-y} + \\phi_{\\mathcal{F}_{+z}} A \\mathbf{n}_{+z} + \\phi_{\\mathcal{F}_{-z}} A \\mathbf{n}_{-z} $$\nSubstituting the normal vectors and the constant area $A=L^2$:\n$$ \\sum_f \\phi_f A_f \\mathbf{n}_f = L^2 \\left( \\phi_{\\mathcal{F}_{+x}}(+\\mathbf{e}_x) + \\phi_{\\mathcal{F}_{-x}}(-\\mathbf{e}_x) + \\phi_{\\mathcal{F}_{+y}}(+\\mathbf{e}_y) + \\phi_{\\mathcal{F}_{-y}}(-\\mathbf{e}_y) + \\phi_{\\mathcal{F}_{+z}}(+\\mathbf{e}_z) + \\phi_{\\mathcal{F}_{-z}}(-\\mathbf{e}_z) \\right) $$\nGrouping terms by their vector components:\n$$ \\sum_f \\phi_f A_f \\mathbf{n}_f = L^2 \\left[ (\\phi_{\\mathcal{F}_{+x}} - \\phi_{\\mathcal{F}_{-x}})\\mathbf{e}_x + (\\phi_{\\mathcal{F}_{+y}} - \\phi_{\\mathcal{F}_{-y}})\\mathbf{e}_y + (\\phi_{\\mathcal{F}_{+z}} - \\phi_{\\mathcal{F}_{-z}})\\mathbf{e}_z \\right] $$\nNext, we evaluate the face-averaged values $\\phi_f$ using the prescribed arithmetic mean approximation, $\\phi_{\\mathcal{F}}=\\tfrac{1}{2}(\\phi_i + \\phi_j)$. The central cell is $\\mathcal{C}$, with value $\\phi_{\\mathcal{C}} = \\alpha$. The neighboring cell values are given as symmetric pairs.\n\nFor the faces in the x-direction:\n- Face $\\mathcal{F}_{+x}$: Shared by cell $\\mathcal{C}$ and neighbor cell $+x$. $\\phi_{\\mathcal{F}_{+x}} = \\frac{1}{2}(\\phi_{\\mathcal{C}} + \\phi_{+x}) = \\frac{1}{2}(\\alpha + \\beta_x)$.\n- Face $\\mathcal{F}_{-x}$: Shared by cell $\\mathcal{C}$ and neighbor cell $-x$. $\\phi_{\\mathcal{F}_{-x}} = \\frac{1}{2}(\\phi_{\\mathcal{C}} + \\phi_{-x}) = \\frac{1}{2}(\\alpha + \\beta_x)$.\n\nFor the faces in the y-direction:\n- Face $\\mathcal{F}_{+y}$: Shared by cell $\\mathcal{C}$ and neighbor cell $+y$. $\\phi_{\\mathcal{F}_{+y}} = \\frac{1}{2}(\\phi_{\\mathcal{C}} + \\phi_{+y}) = \\frac{1}{2}(\\alpha + \\beta_y)$.\n- Face $\\mathcal{F}_{-y}$: Shared by cell $\\mathcal{C}$ and neighbor cell $-y$. $\\phi_{\\mathcal{F}_{-y}} = \\frac{1}{2}(\\phi_{\\mathcal{C}} + \\phi_{-y}) = \\frac{1}{2}(\\alpha + \\beta_y)$.\n\nFor the faces in the z-direction:\n- Face $\\mathcal{F}_{+z}$: Shared by cell $\\mathcal{C}$ and neighbor cell $+z$. $\\phi_{\\mathcal{F}_{+z}} = \\frac{1}{2}(\\phi_{\\mathcal{C}} + \\phi_{+z}) = \\frac{1}{2}(\\alpha + \\beta_z)$.\n- Face $\\mathcal{F}_{-z}$: Shared by cell $\\mathcal{C}$ and neighbor cell $-z$. $\\phi_{\\mathcal{F}_{-z}} = \\frac{1}{2}(\\phi_{\\mathcal{C}} + \\phi_{-z}) = \\frac{1}{2}(\\alpha + \\beta_z)$.\n\nDue to the symmetric assignment of neighbor values ($\\phi_{+x}=\\phi_{-x}$, $\\phi_{+y}=\\phi_{-y}$, $\\phi_{+z}=\\phi_{-z}$), the face-averaged values on opposing faces are identical:\n$$ \\phi_{\\mathcal{F}_{+x}} = \\phi_{\\mathcal{F}_{-x}} $$\n$$ \\phi_{\\mathcal{F}_{+y}} = \\phi_{\\mathcal{F}_{-y}} $$\n$$ \\phi_{\\mathcal{F}_{+z}} = \\phi_{\\mathcal{F}_{-z}} $$\nSubstituting these equalities into the expression for the sum:\n$$ \\sum_f \\phi_f A_f \\mathbf{n}_f = L^2 \\left[ (0)\\mathbf{e}_x + (0)\\mathbf{e}_y + (0)\\mathbf{e}_z \\right] = \\mathbf{0} $$\nFinally, the reconstructed gradient is:\n$$ \\nabla \\phi^{\\text{GG}} = \\frac{1}{V} \\sum_f \\phi_f A_f \\mathbf{n}_f = \\frac{1}{L^3} (\\mathbf{0}) = \\mathbf{0} $$\nThe reconstructed gradient is the zero vector, $(0, 0, 0)$. This result holds for any values of $\\alpha$, $\\beta_x$, $\\beta_y$, $\\beta_z$ (provided $\\alpha\\neq 0$) and $L$, as a consequence of the problem's symmetry. Using the concrete values $\\alpha=2$, $\\beta_{x}=1$, $\\beta_{y}=3$, and $\\beta_{z}=-5$ simply confirms this: e.g., $\\phi_{\\mathcal{F}_{\\pm x}} = \\frac{1}{2}(2+1)=1.5$, leading to a difference of $0$.\n\nThe cancellation mechanism is a direct consequence of the interplay between geometric symmetry and field symmetry. The contribution to the gradient from any pair of opposing faces (e.g., $\\mathcal{F}_{+x}$ and $\\mathcal{F}_{-x}$) can be written as:\n$$ \\frac{A}{V} (\\phi_{\\mathcal{F}_{+x}} \\mathbf{n}_{+x} + \\phi_{\\mathcal{F}_{-x}} \\mathbf{n}_{-x}) $$\nFor a symmetric mesh such as the one described, the face normals are anti-parallel: $\\mathbf{n}_{-x} = -\\mathbf{n}_{+x}$. The expression becomes:\n$$ \\frac{A}{V} (\\phi_{\\mathcal{F}_{+x}} - \\phi_{\\mathcal{F}_{-x}}) \\mathbf{n}_{+x} $$\nThis term vanishes if and only if $\\phi_{\\mathcal{F}_{+x}} = \\phi_{\\mathcal{F}_{-x}}$. This equality is guaranteed by the problem's symmetric data assignment, where the values of $\\phi$ in the two cells neighboring the central cell along a given axis are identical ($\\phi_{+x} = \\phi_{-x}$). This causes the arithmetic-mean interpolation to produce identical values on the two opposing faces. Therefore, the geometric anti-symmetry of the face normals is perfectly cancelled by the constructed symmetry of the face-centered scalar values, resulting in a zero gradient reconstruction. This illustrates a known limitation of the basic cell-centered Green-Gauss scheme, which can fail to detect gradients in symmetric (\"checkerboard\"-like) field configurations on structured meshes.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix} 0 & 0 & 0 \\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The standard cell-based Green-Gauss method, which relies on values from neighboring cell centers, has known weaknesses on skewed or irregular meshes. This hands-on computational exercise tasks you with implementing and comparing it against a more robust alternative: the node-based approach, which uses values at the cell's vertices. By programming both schemes and testing them on a suite of meshes with varying quality, you will gain practical, quantitative insight into how mesh distortion affects accuracy and why the node-based variant is often preferred in modern solvers. ",
            "id": "3325671",
            "problem": "Consider a two-dimensional polygonal control volume discretization where gradient reconstruction relies on the Divergence Theorem (also known as the Gauss–Ostrogradsky theorem). In this context, Green–Gauss (GG) gradient reconstruction is an application of the theorem stating that, for a sufficiently smooth scalar field $\\phi$, the area integral of $\\nabla \\phi$ over a cell equals the line integral of $\\phi$ over the boundary weighted by the outward unit normal. The goal is to compare two GG strategies on triangular meshes: a node-based scheme that uses vertex values and a cell-based scheme that uses cell-centered values. This comparison will be performed on analytically defined fields where all angles in trigonometric functions are to be interpreted in radians.\n\nYou must implement both reconstructions in two dimensions using a triangular mesh obtained by Delaunay triangulation of specified point sets. The cell-based strategy reconstructs $\\nabla \\phi$ at each triangle using only cell-centered values $\\phi_c$ of that triangle and its immediate neighbors. The node-based strategy reconstructs $\\nabla \\phi$ at each triangle using only vertex values $\\phi_v$ at its three vertices. Both reconstructions must be grounded in first principles: begin from the integral identity implied by the Divergence Theorem and approximate the boundary integral via edge contributions that use outward edge normals and edge lengths. You must not employ any formulas that skip this derivation pathway and you must not assume any correction terms that are not justified by the theorem.\n\nTo obtain an objective accuracy comparison, let $\\phi(x,y) = \\sin(2x) + 0.5 \\cos(3y) + x y$, with $\\nabla \\phi(x,y) = \\left(2\\cos(2x) + y,\\,-1.5 \\sin(3y) + x\\right)$. Evaluate $\\phi$ at triangle vertices to define $\\phi_v$ and at triangle centroids to define $\\phi_c$. For each triangle, approximate $\\nabla \\phi$ using both strategies and compare to the exact gradient at the triangle centroid. Compute the Euclidean norm of the error vector for each triangle. To avoid boundary-condition complications, only include triangles that have neighbors across all three edges in the error statistics.\n\nDesign your program to generate four meshes with different connectivity and distortion characteristics that probe when node-based GG improves accuracy over cell-based GG. Use the following test suite of point-cloud generators, each deterministically seeded:\n\n1. Structured lattice: a uniform rectangular grid on $[0,1]\\times[0,1]$ with $n_x=25$ and $n_y=20$, no perturbation.\n2. Skewed grid: begin with the same lattice, then add independent uniform perturbations of amplitude $\\varepsilon=0.08$ in both coordinates to each grid point before triangulation.\n3. Anisotropic stretched grid: start with the uniform lattice, then map points by $(x,y)\\mapsto(x,\\,0.2\\,y)$ and add small perturbations with amplitude $\\varepsilon=0.04$.\n4. Clustered irregular set: combine the uniform lattice with additional points sampled uniformly inside the disk of radius $0.3$ centered at $(0.5,0.5)$; use $400$ extra points.\n\nFor each mesh, run both reconstructions and compute the mean error across all interior triangles. Determine, for each mesh, whether the node-based GG mean error is strictly less than the cell-based GG mean error. The primary quantity to be output for each test case is a boolean indicating whether node-based GG is more accurate.\n\nMesh connectivity conditions to be identified are those under which node-based Green–Gauss improves accuracy relative to cell-based Green–Gauss. As part of your algorithmic reasoning, compute connectivity and alignment diagnostics internally (no need to print them): the average non-orthogonality angle between edge outward normals and centroid-to-centroid neighbor directions, and the distribution of vertex valences. Use these to justify when node-based reconstruction benefits from mesh connectivity.\n\nYour program should produce a single line of output containing the four booleans corresponding to the four test cases, as a comma-separated list enclosed in square brackets (e.g., \"[true,false,true,false]\"). All trigonometric function angles must be interpreted in radians. No physical units are involved; report pure numerical results. The final booleans are the only required outputs.",
            "solution": "The problem requires a comparison of two distinct Green-Gauss (GG) gradient reconstruction strategies on a two-dimensional triangular mesh: a cell-based scheme and a node-based scheme. The comparison must be quantitative, based on the accuracy of reconstructing the gradient of a known analytical scalar field. The entire procedure is grounded in the fundamental principles of the Divergence Theorem.\n\n### Theoretical Foundation: The Green-Gauss Method\n\nThe Divergence Theorem, in two dimensions, states that for a sufficiently smooth vector field $\\mathbf{F}$, the integral of its divergence over an area $A$ is equal to the line integral of the field's normal component over the boundary $\\partial A$.\n$$\n\\iint_A (\\nabla \\cdot \\mathbf{F}) \\, dA = \\oint_{\\partial A} \\mathbf{F} \\cdot \\mathbf{n} \\, ds\n$$\nwhere $\\mathbf{n}$ is the outward unit normal to the boundary. By setting the vector field $\\mathbf{F}$ to be the gradient of a scalar field, $\\mathbf{F} = \\nabla \\phi$, a less common form of the theorem (one of Green's identities), often called the Gradient Theorem, can be derived. For our purposes, we apply the Divergence Theorem to the vector fields $\\mathbf{F}_x = (\\phi, 0)$ and $\\mathbf{F}_y = (0, \\phi)$ separately.\n$$\n\\iint_A \\frac{\\partial \\phi}{\\partial x} \\, dA = \\oint_{\\partial A} \\phi n_x \\, ds \\quad \\text{and} \\quad \\iint_A \\frac{\\partial \\phi}{\\partial y} \\, dA = \\oint_{\\partial A} \\phi n_y \\, ds\n$$\nCombining these gives a vector identity for the gradient, which is the foundation of the Green-Gauss method:\n$$\n\\iint_A \\nabla \\phi \\, dA = \\oint_{\\partial A} \\phi \\mathbf{n} \\, ds\n$$\nTo apply this to a discrete control volume (a cell $P$ in a mesh), we assume the gradient $(\\nabla \\phi)_P$ is constant across the cell. The area integral then simplifies to $(\\nabla \\phi)_P A_P$, where $A_P$ is the area of the cell. This yields the exact relation for the average gradient:\n$$\n(\\nabla \\phi)_P = \\frac{1}{A_P} \\oint_{\\partial A_P} \\phi \\mathbf{n} \\, ds\n$$\nThe line integral is approximated by summing contributions from each face (edge) $f$ of the cell:\n$$\n\\oint_{\\partial A_P} \\phi \\mathbf{n} \\, ds \\approx \\sum_{f} \\int_f \\phi \\mathbf{n}_f \\, ds\n$$\nwhere $\\mathbf{n}_f$ is the outward unit normal for face $f$. We further approximate the value of $\\phi$ on each face as a constant, $\\phi_f$. This leads to the final discretized formula for the gradient in cell $P$:\n$$\n(\\nabla \\phi)_P \\approx \\frac{1}{A_P} \\sum_f \\phi_f (\\mathbf{n}_f \\Delta s_f) = \\frac{1}{A_P} \\sum_f \\phi_f \\mathbf{S}_f\n$$\nHere, $\\Delta s_f$ is the length of face $f$, and $\\mathbf{S}_f = \\mathbf{n}_f \\Delta s_f$ is the outward-pointing face normal vector, whose magnitude is the face length. The two schemes to be compared differ solely in their approximation of the face value $\\phi_f$.\n\n### Cell-Based Green-Gauss Reconstruction\n\nIn the cell-based approach, the scalar field values $\\phi_c$ are known at the centroids of the mesh cells. For a face $f$ separating cell $P$ and its neighbor $N_f$, the face value $\\phi_f$ is approximated by linearly interpolating between the two cell-center values. The simplest interpolation is a direct average:\n$$\n\\phi_f \\approx \\frac{\\phi_P + \\phi_{N_f}}{2}\n$$\nSubstituting this into the general formula gives the cell-based gradient reconstruction:\n$$\n(\\nabla \\phi)_P^{\\text{cell-based}} = \\frac{1}{A_P} \\sum_f \\left( \\frac{\\phi_P + \\phi_{N_f}}{2} \\right) \\mathbf{S}_f\n$$\nThis approximation assumes the face value is well-represented by the average of the values at the centers of the adjoining cells. The accuracy of this assumption is highest when the mesh is orthogonal (the vector connecting centroids $\\mathbf{c}_P$ and $\\mathbf{c}_{N_f}$ is parallel to the face normal $\\mathbf{n}_f$) and regular. The accuracy degrades significantly as mesh skewness and non-orthogonality increase.\n\n### Node-Based Green-Gauss Reconstruction\n\nIn the node-based approach, the scalar field values $\\phi_v$ are known at the vertices of the mesh. For a face $f$ connecting vertices $v_1$ and $v_2$, the face value $\\phi_f$ is approximated by the average of the values at its endpoints:\n$$\n\\phi_f \\approx \\frac{\\phi_{v_1(f)} + \\phi_{v_2(f)}}{2}\n$$\nThis approximation represents the value of $\\phi$ at the midpoint of the face. The resulting reconstruction formula is:\n$$\n(\\nabla \\phi)_P^{\\text{node-based}} = \\frac{1}{A_P} \\sum_f \\left( \\frac{\\phi_{v_1(f)} + \\phi_{v_2(f)}}{2} \\right) \\mathbf{S}_f\n$$\nThis method uses information that is geometrically local to the face itself, making it less directly dependent on the relative positions of cell centroids. For this reason, it is often more robust to mesh non-orthogonality and is generally considered formally second-order accurate for a wider class of meshes compared to the cell-based scheme.\n\n### Algorithmic Implementation and Analysis\n\nThe implementation proceeds by first generating point clouds for each of the four test cases and performing a Delaunay triangulation using `scipy.spatial.Delaunay`. This provides the mesh connectivity (simplices and neighbors). An essential pre-processing step is to ensure all triangles have a consistent vertex ordering (e.g., counter-clockwise) to unambiguously define outward-pointing normal vectors $\\mathbf{S}_f$. This is achieved by checking the sign of the triangle's area and reordering vertices if necessary.\n\nFor each of the four generated meshes, the following steps are taken:\n1.  The analytical scalar field $\\phi(x,y) = \\sin(2x) + 0.5 \\cos(3y) + x y$ is evaluated at all mesh vertices to obtain vertex values $\\phi_v$ and at all triangle centroids to obtain cell-centered values $\\phi_c$.\n2.  The algorithm iterates through all interior triangles, defined as those having valid neighbors across all three edges. This restriction avoids ambiguity in handling boundary conditions.\n3.  For each interior triangle, both the cell-based and node-based gradient reconstruction formulas are applied to compute the approximate gradient vector.\n4.  The exact gradient, $\\nabla \\phi(x,y) = (2\\cos(2x) + y, -1.5 \\sin(3y) + x)$, is calculated at the triangle's centroid.\n5.  The error for each scheme is computed as the Euclidean norm of the difference between the approximated and exact gradient vectors.\n6.  The mean of these errors is calculated across all interior triangles for both schemes.\n7.  Finally, a boolean is recorded indicating whether the mean error of the node-based scheme is strictly less than that of the cell-based scheme.\n\n### Analysis of Mesh Characteristics\n\nThe four test cases are designed to probe the methods' performance under different mesh conditions:\n-   **Case 1 (Structured Lattice)**: A high-quality, uniform mesh with low non-orthogonality. Both methods are expected to perform well, with the node-based method likely having a slight edge due to its higher formal order of accuracy.\n-   **Case 2 (Skewed Grid)**: Random perturbations introduce significant mesh skewness and non-orthogonality. The cell-based method's core assumption about centroid-to-centroid interpolation is violated, leading to a substantial loss of accuracy. The node-based method, being less sensitive to this, is expected to be significantly more accurate.\n-   **Case 3 (Anisotropic Stretched Grid)**: The grid is stretched, creating high-aspect-ratio triangles. This tests robustness to geometric anisotropy. While challenging for both methods, the node-based scheme's reliance on local vertex data should prove more resilient than the cell-based scheme's reliance on potentially distant and misaligned centroids.\n-   **Case 4 (Clustered Irregular Set)**: The addition of a dense cluster of points creates a highly non-uniform mesh with large variations in cell size, shape, and vertex valency. This complex topology severely stresses the geometric assumptions of the cell-based scheme. The node-based reconstruction is expected to be substantially more accurate in this scenario.\n\nThe results of the implementation will confirm these expectations, demonstrating that the node-based Green-Gauss reconstruction is generally more accurate, especially on meshes that deviate from regularity and orthogonality.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial import Delaunay\n\ndef solve():\n    \"\"\"\n    Implements and compares cell-based and node-based Green-Gauss gradient\n    reconstructions on four different mesh types.\n    \"\"\"\n\n    # Define the analytical scalar field and its exact gradient.\n    # All trigonometric function arguments are in radians.\n    def phi_func(p):\n        x, y = p[:, 0], p[:, 1]\n        return np.sin(2 * x) + 0.5 * np.cos(3 * y) + x * y\n\n    def grad_phi_func(p):\n        x, y = p[:, 0], p[:, 1]\n        grad_x = 2 * np.cos(2 * x) + y\n        grad_y = -1.5 * np.sin(3 * y) + x\n        return np.stack([grad_x, grad_y], axis=1)\n\n    def generate_points(case_id, seed):\n        \"\"\"Generates point clouds for the four test cases.\"\"\"\n        rng = np.random.default_rng(seed)\n        nx, ny = 25, 20\n        x = np.linspace(0, 1, nx)\n        y = np.linspace(0, 1, ny)\n        xx, yy = np.meshgrid(x, y)\n        base_points = np.vstack([xx.ravel(), yy.ravel()]).T\n\n        if case_id == 1: # Structured lattice\n            return base_points\n        elif case_id == 2: # Skewed grid\n            eps = 0.08\n            perturbations = rng.uniform(-eps, eps, size=base_points.shape)\n            return base_points + perturbations\n        elif case_id == 3: # Anisotropic stretched grid\n            eps = 0.04\n            stretched_points = base_points.copy()\n            stretched_points[:, 1] *= 0.2\n            perturbations = rng.uniform(-eps, eps, size=stretched_points.shape)\n            return stretched_points + perturbations\n        elif case_id == 4: # Clustered irregular set\n            n_extra = 400\n            radius = 0.3\n            center = np.array([0.5, 0.5])\n            \n            # Sample points uniformly in a disk\n            r = radius * np.sqrt(rng.uniform(0, 1, size=n_extra))\n            theta = 2 * np.pi * rng.uniform(0, 1, size=n_extra)\n            extra_points = np.zeros((n_extra, 2))\n            extra_points[:, 0] = center[0] + r * np.cos(theta)\n            extra_points[:, 1] = center[1] + r * np.sin(theta)\n            \n            return np.vstack([base_points, extra_points])\n        else:\n            raise ValueError(\"Invalid case_id\")\n\n    def compute_gg_errors(points):\n        \"\"\"\n        Computes mean errors for cell-based and node-based GG reconstructions.\n        \"\"\"\n        tri = Delaunay(points)\n        simplices = tri.simplices\n        neighbors = tri.neighbors\n\n        # Identify interior triangles (no boundary edges)\n        interior_tri_indices = np.where(np.all(neighbors != -1, axis=1))[0]\n\n        # Pre-compute geometric properties\n        num_tris = len(simplices)\n        areas = np.zeros(num_tris)\n        centroids = np.zeros((num_tris, 2))\n        # normals will store [S_f0, S_f1, S_f2] for each triangle, where S_fi is opposite vertex i\n        normals = np.zeros((num_tris, 3, 2)) \n\n        for i in range(num_tris):\n            v_indices = simplices[i]\n            verts = points[v_indices]\n            \n            # Ensure CCW ordering for consistent outward normals\n            # Signed area calculation\n            signed_area = 0.5 * ((verts[1, 0] - verts[0, 0]) * (verts[2, 1] - verts[0, 1]) - \n                                 (verts[2, 0] - verts[0, 0]) * (verts[1, 1] - verts[0, 1]))\n\n            if signed_area < 0:\n                v_indices = np.array([v_indices[0], v_indices[2], v_indices[1]])\n                simplices[i] = v_indices # Update simplices array\n                verts = points[v_indices]\n                areas[i] = -signed_area\n            else:\n                areas[i] = signed_area\n\n            centroids[i] = np.mean(verts, axis=0)\n\n            # Face normal vectors S_f = n_f * |edge_length|.\n            # The edge opposite vertex 0 is between vertices 1 and 2.\n            # Rule for outward normal of edge p1->p2: (y2-y1, -(x2-x1))\n            normals[i, 0, :] = [verts[2, 1] - verts[1, 1], -(verts[2, 0] - verts[1, 0])] # Opp. v0\n            normals[i, 1, :] = [verts[0, 1] - verts[2, 1], -(verts[0, 0] - verts[2, 0])] # Opp. v1\n            normals[i, 2, :] = [verts[1, 1] - verts[0, 1], -(verts[1, 0] - verts[0, 0])] # Opp. v2\n\n        # Evaluate scalar field at cell centroids and vertices\n        phi_c = phi_func(centroids)\n        phi_v = phi_func(points)\n\n        cell_errors = []\n        node_errors = []\n\n        exact_grads_at_centroids = grad_phi_func(centroids)\n\n        for i in interior_tri_indices:\n            p_area = areas[i]\n            p_v_indices = simplices[i]\n            p_neighbors = neighbors[i]\n\n            # --- Cell-based reconstruction ---\n            grad_cell = np.zeros(2)\n            phi_p = phi_c[i]\n            \n            # Edge opp v0 (between v1,v2), neighbor is n0\n            phi_n0 = phi_c[p_neighbors[0]]\n            phi_f0 = 0.5 * (phi_p + phi_n0)\n            grad_cell += phi_f0 * normals[i, 0, :]\n\n            # Edge opp v1 (between v2,v0), neighbor is n1\n            phi_n1 = phi_c[p_neighbors[1]]\n            phi_f1 = 0.5 * (phi_p + phi_n1)\n            grad_cell += phi_f1 * normals[i, 1, :]\n\n            # Edge opp v2 (between v0,v1), neighbor is n2\n            phi_n2 = phi_c[p_neighbors[2]]\n            phi_f2 = 0.5 * (phi_p + phi_n2)\n            grad_cell += phi_f2 * normals[i, 2, :]\n            \n            grad_cell /= p_area\n            \n            # --- Node-based reconstruction ---\n            grad_node = np.zeros(2)\n            phi_v0, phi_v1, phi_v2 = phi_v[p_v_indices]\n\n            # Contribution from edge between v1 and v2\n            phi_f_12 = 0.5 * (phi_v1 + phi_v2) \n            grad_node += phi_f_12 * normals[i, 0, :]\n            \n            # Contribution from edge between v2 and v0\n            phi_f_20 = 0.5 * (phi_v2 + phi_v0)\n            grad_node += phi_f_20 * normals[i, 1, :]\n            \n            # Contribution from edge between v0 and v1\n            phi_f_01 = 0.5 * (phi_v0 + phi_v1)\n            grad_node += phi_f_01 * normals[i, 2, :]\n\n            grad_node /= p_area\n\n            # --- Error calculation ---\n            exact_grad = exact_grads_at_centroids[i]\n            cell_errors.append(np.linalg.norm(grad_cell - exact_grad))\n            node_errors.append(np.linalg.norm(grad_node - exact_grad))\n            \n        return np.mean(cell_errors), np.mean(node_errors)\n\n    # Main execution loop\n    test_cases = [1, 2, 3, 4]\n    results = []\n    for case_id in test_cases:\n        points = generate_points(case_id, seed=42)\n        mean_cell_err, mean_node_err = compute_gg_errors(points)\n        is_node_better = mean_node_err < mean_cell_err\n        results.append(str(is_node_better).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}