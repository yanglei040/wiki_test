{
    "hands_on_practices": [
        {
            "introduction": "理论与实践相结合的第一步是验证数值格式的基本属性。本练习旨在通过经典的网格加密研究，来考察一种基础混合差分策略的收敛阶。您将实现一个根据局部皮克莱数（Peclet number）在中心差分和迎风差分之间切换的格式，并分别在对流主导和扩散主导的情况下，通过计算误差来确定其数值精度，从而亲手验证混合策略在稳定性和精度之间的权衡。",
            "id": "3330986",
            "problem": "考虑在区间 $[0,1]$ 上的稳态一维对流-扩散边界值问题，其带有狄利克雷边界条件：寻找一个足够光滑的函数 $u(x)$，使得\n$$\na\\,\\frac{d u}{d x}(x) - D\\,\\frac{d^2 u}{d x^2}(x) = 0,\\quad x \\in (0,1),\\qquad u(0) = 0,\\quad u(1) = 1,\n$$\n其中 $a$ 和 $D$ 是分别代表平流速度和扩散系数的实常数。所有量都是无量纲的（没有物理单位）。任务是使用一种针对对流项的混合差分策略进行网格加密研究，并提取在扩散主导和对流主导两种情况下的观测精度阶。\n\n使用有限差分法 (FDM) 进行空间离散化，采用均匀的网格间距 $\\Delta x = h = 1/N$，其中 $N$ 是区间的总数，网格节点位于 $x_i = i h$，$i=0,1,\\dots,N$。扩散项 $-D\\,\\frac{d^2 u}{d x^2}$ 总是通过标准的二阶中心差分来近似。对于对流项 $a\\,\\frac{d u}{d x}$，根据局部单元佩克莱数 $P_{\\Delta} = \\frac{|a|\\,\\Delta x}{D}$，采用以下混合差分策略：\n- 如果 $P_{\\Delta} \\le 2$，在内部节点上对 $\\frac{d u}{d x}$ 使用二阶中心差分。\n- 如果 $P_{\\Delta} > 2$，在内部节点上对 $\\frac{d u}{d x}$ 使用与 $a$ 的符号一致的一阶迎风差分（即，对于 $a>0$，使用后向差分；对于 $a0$，使用前向差分）。\n\n您必须：\n- 为内部未知数 $u_i$（节点 $x_i$ 处，其中 $i=1,\\dots,N-1$）组装所得的三对角线性系统，并直接施加 $u_0=0$ 和 $u_N=1$。\n- 求解该线性系统，并计算所有节点上的数值解 $u^{(h)}(x_i)$。\n- 根据控制方程推导出的边界值问题的精确解 $u(x)$，计算离散 $\\ell^2$ 误差范数，\n$$\nE(h) = \\left(\\Delta x \\sum_{i=0}^{N} \\left(u^{(h)}(x_i) - u(x_i)\\right)^2\\right)^{1/2}.\n$$\n- 对于每种测试情况，通过对加密序列上的 $\\log(E(h))$ 与 $\\log(h)$ 进行最小二乘线性回归，计算观测到的精度阶 $p$。也就是说，确定 $p$ 使得 $\\log(E(h)) \\approx \\alpha + p\\,\\log(h)$ 对于某个常数 $\\alpha$ 成立。\n\n测试套件：\n- 所有测试均使用 $D=1$。对于每种情况，提供如下所列的 $N$ 值序列。\n    $1.$ 扩散主导情况：$a=0.1$，$N\\in\\{32,64,128,256,512\\}$。\n    $2.$ 正平流的对流主导情况：$a=400$，$N\\in\\{8,16,32,64\\}$。\n    $3.$ 纯扩散边界值问题：$a=0$，$N\\in\\{32,64,128,256,512\\}$。\n    $4.$ 负平流的对流主导情况：$a=-400$，$N\\in\\{8,16,32,64\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含案例 $1$ 到 $4$ 的四个观测精度阶，以逗号分隔列表的形式包含在方括号中，四舍五入到三位小数，例如 $[p_1,p_2,p_3,p_4]$。\n\n角度单位不适用。百分比不适用。所有量都是无量纲的。用于误差评估的精确解必须从微分方程和边界条件推导得出，而不是凭经验指定。",
            "solution": "用户提供的问题是一个来自计算流体力学的适定边界值问题 (BVP)，需要进行数值求解和误差分析。该问题具有科学依据，内容自洽，并要求应用标准的、可验证的数值方法。因此，该问题是有效的。\n\n求解过程包括以下几个步骤：\n1.  推导BVP的精确解析解，作为精度评估的基准。\n2.  使用指定的混合有限差分格式对控制微分方程进行离散化。\n3.  组装并求解所得的三对角线性方程组。\n4.  为一系列加密网格计算离散 $\\ell^2$ 误差范数。\n5.  通过对误差与网格间距的对数-对数图进行线性回归，计算观测到的精度阶 $p$。\n\n### 1. 解析解\n控制常微分方程 (ODE) 是一个二阶线性齐次常系数方程：\n$$\nD\\,\\frac{d^2 u}{d x^2}(x) - a\\,\\frac{d u}{d x}(x) = 0\n$$\n特征方程为 $D r^2 - a r = r(D r - a) = 0$，其根为 $r_1 = 0$ 和 $r_2 = a/D$。\n\n对于 $a \\neq 0$，通解的形式为 $u(x) = C_1 e^{r_1 x} + C_2 e^{r_2 x}$，即：\n$$\nu(x) = C_1 + C_2 e^{(a/D)x}\n$$\n常数 $C_1$ 和 $C_2$ 由狄利克雷边界条件 $u(0) = 0$ 和 $u(1) = 1$ 确定。\n应用 $u(0) = 0$：\n$$\nC_1 + C_2 e^0 = 0 \\implies C_1 = -C_2\n$$\n应用 $u(1) = 1$：\n$$\nC_1 + C_2 e^{a/D} = 1\n$$\n将 $C_1 = -C_2$ 代入第二个方程得到 $-C_2 + C_2 e^{a/D} = 1$，解得 $C_2 = 1 / (e^{a/D} - 1)$。因此，$C_1 = -1 / (e^{a/D} - 1)$。\n对于 $a \\neq 0$ 的精确解是：\n$$\nu(x) = \\frac{e^{(a/D)x} - 1}{e^{a/D} - 1}\n$$\n\n对于特殊情况 $a = 0$，ODE 简化为 $D u''(x) = 0$，积分得到 $u(x) = C_1 x + C_2$。应用边界条件 $u(0)=0$ 和 $u(1)=1$ 分别得到 $C_2=0$ 和 $C_1=1$。因此，对于 $a=0$，精确解为：\n$$\nu(x) = x\n$$\n此结果也可以通过使用洛必达法则对通解取 $a \\to 0$ 的极限得到。\n\n### 2. 有限差分法离散化\n我们使用一个包含 $N$ 个区间的均匀网格对定义域 $[0,1]$ 进行离散化，使得网格间距为 $h = \\Delta x = 1/N$，网格节点为 $x_i = i h$，其中 $i = 0, 1, \\dots, N$。这些节点上的数值解记为 $u_i \\approx u(x_i)$。根据边界条件，$u_0=0$ 和 $u_N=1$ 的值是已知的。我们需求解内部节点的值 $u_1, \\dots, u_{N-1}$。\n\n内部节点 $x_i$ 处的离散方程为：\n$$\na \\left(\\frac{du}{dx}\\right)_i - D \\left(\\frac{d^2u}{dx^2}\\right)_i = 0\n$$\n扩散项总是通过二阶中心差分来近似：\n$$\n- D \\left(\\frac{d^2u}{dx^2}\\right)_i \\approx -D \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n$$\n对流项根据单元佩克莱数 $P_{\\Delta} = \\frac{|a|h}{D}$ 使用混合格式进行近似。\n\n**情况 A：$P_{\\Delta} \\le 2$ (中心差分格式)**\n对流项由二阶中心差分近似：\n$$\na \\left(\\frac{du}{dx}\\right)_i \\approx a \\frac{u_{i+1} - u_{i-1}}{2h}\n$$\n将这些近似代入控制ODE并重新整理为 $a_P u_i = a_W u_{i-1} + a_E u_{i+1}$ 的形式，得到：\n$$\n\\frac{2D}{h^2} u_i = \\left(\\frac{D}{h^2} + \\frac{a}{2h}\\right) u_{i-1} + \\left(\\frac{D}{h^2} - \\frac{a}{2h}\\right) u_{i+1}\n$$\n系数为：\n$a_W = \\frac{D}{h} + \\frac{a}{2}$，$a_E = \\frac{D}{h} - \\frac{a}{2}$，以及 $a_P = a_W + a_E = \\frac{2D}{h}$。\n\n**情况 B：$P_{\\Delta} > 2$ (迎风差分格式)**\n格式变为一阶迎风。\n如果 $a>0$，使用后向差分：$a \\left(\\frac{du}{dx}\\right)_i \\approx a \\frac{u_i - u_{i-1}}{h}$。\n离散方程为：\n$$\n\\left(\\frac{2D}{h^2} + \\frac{a}{h}\\right) u_i = \\left(\\frac{D}{h^2} + \\frac{a}{h}\\right) u_{i-1} + \\left(\\frac{D}{h^2}\\right) u_{i+1}\n$$\n系数为：\n$a_W = \\frac{D}{h} + a$，$a_E = \\frac{D}{h}$，以及 $a_P = a_W + a_E = \\frac{2D}{h} + a$。\n\n如果 $a0$，使用前向差分：$a \\left(\\frac{du}{dx}\\right)_i \\approx a \\frac{u_{i+1} - u_{i}}{h}$。\n离散方程为：\n$$\n\\left(\\frac{2D}{h^2} - \\frac{a}{h}\\right) u_i = \\left(\\frac{D}{h^2}\\right) u_{i-1} + \\left(\\frac{D}{h^2} - \\frac{a}{h}\\right) u_{i+1}\n$$\n系数为：\n$a_W = \\frac{D}{h}$，$a_E = \\frac{D}{h} - a$，以及 $a_P = a_W + a_E = \\frac{2D}{h} - a$。\n\n### 3. 线性系统组装\n对于每个内部节点 $i=1, \\dots, N-1$，我们有一个形式如下的方程：\n$$\n-a_W u_{i-1} + a_P u_i - a_E u_{i+1} = 0\n$$\n由于对于给定的测试案例，$a_W, a_P, a_E$ 在均匀网格上是常数，这构成了一个关于未知数向量 $\\vec{u} = [u_1, u_2, \\dots, u_{N-1}]^T$ 的三对角线性方程组 $A\\vec{u} = \\vec{b}$。\n\n矩阵 $A$ 是一个 $(N-1) \\times (N-1)$ 的三对角矩阵：\n$$\nA = \\begin{pmatrix}\na_P  -a_E  0  \\dots  0 \\\\\n-a_W  a_P  -a_E  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n0  \\dots  -a_W  a_P  -a_E \\\\\n0  \\dots  0  -a_W  a_P\n\\end{pmatrix}\n$$\n右侧向量 $\\vec{b}$ 包含了边界条件。\n对于 $i=1$：$-a_W u_0 + a_P u_1 - a_E u_2 = 0$。由于 $u_0=0$，方程变为 $a_P u_1 - a_E u_2 = 0$。\n对于 $i=N-1$：$-a_W u_{N-2} + a_P u_{N-1} - a_E u_N = 0$。由于 $u_N=1$，方程变为 $-a_W u_{N-2} + a_P u_{N-1} = a_E$。\n因此，向量 $\\vec{b}$ 是：\n$$\n\\vec{b} = [0, 0, \\dots, 0, a_E]^T\n$$\n这个三对角系统可以使用专门的算法高效求解，例如 `scipy.linalg.solve_banded`。\n\n### 4. 误差分析与精度阶\n在求解得到数值解 $u^{(h)} = [u_0, u_1, \\dots, u_N]^T$ 后，我们计算其与精确解 $u(x_i)$ 之间的离散 $\\ell^2$ 误差范数：\n$$\nE(h) = \\left(h \\sum_{i=0}^{N} \\left(u_i - u(x_i)\\right)^2\\right)^{1/2}\n$$\n理论收敛率是 $E(h) \\approx C h^p$，其中 $p$ 是精度阶。为了找到观测到的阶数，我们取对数：\n$$\n\\log(E(h)) \\approx \\log(C) + p \\log(h)\n$$\n通过为一系列网格间距 $h$ 计算 $E(h)$，我们可以对 $\\log(E(h))$ 与 $\\log(h)$ 进行线性回归。所得直线的斜率即为观测到的精度阶 $p$。\n\n### 5. 测试案例分析\n- **案例 1 ($a=0.1, D=1$):** 当 $N \\ge 32$ 时，$h \\le 1/32$。最大的 $P_{\\Delta} = 0.1 \\times (1/32) / 1 \\approx 0.0031$，远小于 $2$。使用二阶中心差分格式，因此我们预期 $p \\approx 2.0$。\n- **案例 2 ($a=400, D=1$):** 当 $N \\le 64$ 时，$h \\ge 1/64$。最小的 $P_{\\Delta} = 400 \\times (1/64) / 1 = 6.25$，大于 $2$。使用一阶迎风格式，因此我们预期 $p \\approx 1.0$。\n- **案例 3 ($a=0, D=1$):** $P_{\\Delta} = 0$，所以使用中心差分格式。该格式简化为二阶导数的标准模板，且精确解为 $u(x)=x$。在没有浮点误差的情况下，有限差分法可以精确地重现该线性解。在数值上，误差将处于机器精度水平，因此对所有 $h$ 大致恒定。这导致观测到的精度阶 $p \\approx 0.0$。\n- **案例 4 ($a=-400, D=1$):** 与案例 2 类似，最小的 $P_{\\Delta} = |-400| \\times (1/64) / 1 = 6.25 > 2$。使用一阶迎风格式，我们预期 $p \\approx 1.0$。\n\n实现将遵循此逻辑来计算四个 $p$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D steady convection-diffusion equation using a hybrid finite\n    difference scheme and calculates the observed order of accuracy for\n    four different test regimes.\n    \"\"\"\n\n    def get_exact_solution(x, a, D):\n        \"\"\"\n        Computes the exact analytical solution to the BVP.\n        \"\"\"\n        if a == 0.0:\n            return x\n        else:\n            ratio = a / D\n            # Use np.expm1 for numerical stability when ratio is close to zero.\n            return np.expm1(ratio * x) / np.expm1(ratio)\n\n    def solve_one_case(a, D, N_values):\n        \"\"\"\n        Performs grid refinement study for a single (a, D) case.\n        Returns the observed order of accuracy.\n        \"\"\"\n        h_list = []\n        error_list = []\n\n        for N in N_values:\n            # 1. Grid setup\n            h = 1.0 / N\n            x_nodes = np.linspace(0.0, 1.0, N + 1)\n            \n            # 2. Determine scheme based on cell Peclet number\n            P_delta = np.abs(a) * h / D\n\n            if P_delta = 2.0:\n                # Central Difference Scheme for convection\n                a_W = D/h + a/2.0\n                a_E = D/h - a/2.0\n                # Per the control volume formulation, a_P = a_W + a_E for CDS\n                a_P = 2.0*D/h\n            else:\n                # Upwind Scheme for convection\n                if a  0.0:\n                    # Backward difference\n                    a_W = D/h + a\n                    a_E = D/h\n                    a_P = a_W + a_E # = 2*D/h + a\n                else: # a  0.0\n                    # Forward difference\n                    a_W = D/h\n                    a_E = D/h - a\n                    a_P = a_W + a_E # = 2*D/h - a\n            \n            # 3. Assemble the tridiagonal linear system Au = b\n            dim = N - 1\n            ab = np.zeros((3, dim))\n            b = np.zeros(dim)\n            \n            # Fill the banded matrix 'ab' for scipy.linalg.solve_banded\n            # ab[0, 1:] = super-diagonal\n            # ab[1, :]   = main-diagonal\n            # ab[2, :-1]= sub-diagonal\n            ab[1, :] = a_P\n            if dim  0:\n                ab[0, 1:] = -a_E\n                ab[2, :-1] = -a_W\n\n            # 4. Apply boundary conditions\n            # u_0 = 0 is handled implicitly as it doesn't add to the RHS\n            # u_N = 1 affects the last equation (for u_{N-1})\n            if dim  0:\n                # The term -a_E * u_N becomes a_E on the RHS\n                b[-1] = a_E * 1.0\n            \n            # 5. Solve the system\n            if dim  0:\n                u_internal = solve_banded((1, 1), ab, b)\n            else:\n                u_internal = np.array([])\n            \n            # 6. Construct full numerical solution vector\n            u_numerical = np.zeros(N + 1)\n            u_numerical[0] = 0.0\n            u_numerical[-1] = 1.0\n            u_numerical[1:-1] = u_internal\n\n            # 7. Compute the l2-error\n            u_exact = get_exact_solution(x_nodes, a, D)\n            error_sq_sum = np.sum((u_numerical - u_exact)**2)\n            error = np.sqrt(h * error_sq_sum)\n            \n            # Handle cases where error is zero to avoid log(0)\n            if error  np.finfo(np.float64).tiny:\n                error = np.finfo(np.float64).tiny\n\n            h_list.append(h)\n            error_list.append(error)\n        \n        # 8. Calculate order of accuracy using linear regression\n        log_h = np.log(np.array(h_list))\n        log_error = np.log(np.array(error_list))\n        \n        # Fit a line: log(error) = p * log(h) + const\n        p, _ = np.polyfit(log_h, log_error, 1)\n        \n        return p\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'a': 0.1,  'D': 1.0, 'N_values': [32, 64, 128, 256, 512]}, # Diffusion-dominated\n        {'a': 400.0, 'D': 1.0, 'N_values': [8, 16, 32, 64]}, # Convection-dominated, a>0\n        {'a': 0.0,  'D': 1.0, 'N_values': [32, 64, 128, 256, 512]}, # Pure diffusion\n        {'a': -400.0, 'D': 1.0, 'N_values': [8, 16, 32, 64]}, # Convection-dominated, a0\n    ]\n\n    results = []\n    for case in test_cases:\n        order_p = solve_one_case(case['a'], case['D'], case['N_values'])\n        results.append(order_p)\n\n    # Format the final output string\n    formatted_results = [f\"{p:.3f}\" for p in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "高级的混合格式通常采用平滑过渡函数，而非简单的“开/关”切换，以改善解的质量。本练习将深入探讨这种平滑混合对解的光滑性和单调性的影响。我们将通过计算离散算子的格林函数（Green's function），即其对单位点源的响应，来量化不同皮克莱数和混合函数平滑度下解的过冲（overshoot）幅度，这有助于深刻理解数值格式如何引入或抑制非物理振荡。",
            "id": "3331016",
            "problem": "考虑作用于单位区间 $[0,1]$ 上未知函数 $u(x)$ 的一维、稳态、线性对流-扩散算子，其齐次狄利克雷边界条件为 $u(0)=0$ 和 $u(1)=0$。其控制方程的强形式为 $$a \\frac{du}{dx} - \\nu \\frac{d^2 u}{dx^2} = s(x),$$ 其中 $a$ 是恒定的对流速度，$\\nu0$ 是恒定的扩散系数，$s(x)$ 是一个源项。任务是在离散设置下，分析对流项的混合差分策略如何影响算子的离散格林函数，特别是，量化过冲振幅作为网格佩克莱数和控制数值通量混合的光滑度参数的函数。\n\n从以下基础出发：\n\n- 稳态一维输运的守恒声明：净对流通量加上净扩散通量与源项平衡，其强形式如上所示。\n- 使用具有 $N$ 个内部点的均匀网格对 $[0,1]$ 进行离散化，网格间距为 $h = 1/(N+1)$，内部节点索引为 $i \\in \\{1,2,\\dots,N\\}$。\n- 离散算子通过有限差分法构建：扩散项使用二阶中心差分，对流项使用一种混合差分策略，该策略平滑地混合了一阶迎风差分和二阶中心差分。\n\n将网格佩克莱数定义为 $Pe = \\dfrac{a h}{\\nu}$，其中 $h$ 是网格间距，$\\nu$ 是扩散系数。为实现混合差分策略，使用阈值为 $Pe_t=2$ 和光滑度参数 $s0$ 的逻辑转换，定义中心差分和迎风差分之间的光滑混合权重 $w(Pe;s)$：\n$$ w(Pe;s) = \\frac{1}{1+\\exp\\left(\\frac{|Pe|-Pe_t}{s}\\right)}. $$\n对于内部节点 $i$ 的对流项，当 $a \\ge 0$ 时，使用混合导数\n$$ \\left.\\frac{du}{dx}\\right|_i \\approx (1-w) \\frac{u_i - u_{i-1}}{h} + w \\frac{u_{i+1} - u_{i-1}}{2h}, $$\n当 $a  0$ 时，使用\n$$ \\left.\\frac{du}{dx}\\right|_i \\approx (1-w) \\frac{u_{i+1} - u_{i}}{h} + w \\frac{u_{i+1} - u_{i-1}}{2h}. $$\n扩散项通过以下方式离散化：\n$$ -\\nu \\left.\\frac{d^2 u}{dx^2}\\right|_i \\approx -\\nu \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}. $$\n这些为每个内部节点 $i$ 产生一个三点模板，从而得到一个三对角矩阵 $\\mathbf{A}$，该矩阵将内部节点值向量映射到离散源向量。对应于节点 $i_0$ 处单位脉冲的离散格林函数 $\\mathbf{G}$ 定义为以下方程的唯一解：\n$$ \\mathbf{A} \\mathbf{G} = \\mathbf{e}_{i_0}, $$\n其中 $\\mathbf{e}_{i_0}$ 是在索引 $i_0$ 处为 $1$、其他位置为 $0$ 的向量，并强制执行狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。\n\n按如下方式定义过冲振幅。通过其中心峰值 $G_{i_0}$ 对离散格林函数进行归一化：\n$$ g_i = \\frac{G_i}{|G_{i_0}|}. $$\n对于峰值的右侧，定义基准邻近值 $b_R = g_{i_0+1}$ (如果 $i_0+1$ 存在)，右侧过冲振幅候选值定义为 $A_R = \\max\\left(0, \\max_{j \\ge i_0+2} (g_j - b_R)\\right)$。对于左侧，定义 $b_L = g_{i_0-1}$ (如果 $i_0-1$ 存在)，以及 $A_L = \\max\\left(0, \\max_{j \\le i_0-2} (g_j - b_L)\\right)$。总过冲振幅是两侧的最大值：\n$$ A_{\\text{over}} = \\max(A_L, A_R). $$\n此定义捕获了远离中心峰值的、相对于紧邻值的次级振荡最大值，并且对于严格单调衰减的情况返回 $0$。\n\n您的任务是实现一个完整的程序，该程序：\n\n1. 根据上述规则，在具有 $N$ 个内部点的均匀网格上，使用扩散系数 $\\nu=1$、域长度 $L=1$ 以及狄利克雷边界条件 $u(0)=0$ 和 $u(L)=0$，构建离散算子的三对角矩阵 $\\mathbf{A}$。\n2. 在选定的网格上，使用关系式 $a = \\dfrac{Pe \\, \\nu}{h}$ 来实现给定的 $Pe$，其中 $\\nu=1$。\n3. 计算位于中心内部索引 $i_0 = \\lfloor N/2 \\rfloor$ 处单位脉冲的离散格林函数 $\\mathbf{G}$。\n4. 计算如上定义的过冲振幅 $A_{\\text{over}}$。\n\n设计程序以处理以下由数对 $(Pe, s)$ 指定的测试用例集：\n\n- 用例 $1$：$(Pe, s) = (0.0, 0.5)$。\n- 用例 $2$：$(Pe, s) = (2.0, 0.1)$。\n- 用例 $3$：$(Pe, s) = (2.0, 1.0)$。\n- 用例 $4$：$(Pe, s) = (10.0, 0.1)$。\n- 用例 $5$：$(Pe, s) = (10.0, 0.5)$。\n- 用例 $6$：$(Pe, s) = (50.0, 0.1)$。\n- 用例 $7$：$(Pe, s) = (-10.0, 0.5)$。\n- 用例 $8$：$(Pe, s) = (20.0, 2.0)$。\n- 用例 $9$：$(Pe, s) = (0.5, 0.5)$。\n\n所有用例均使用 $N=101$、$\\nu=1$、 $L=1$ 和 $i_0 = \\lfloor N/2 \\rfloor$。所有量均为无量纲，因此不需要物理单位。要求的最终输出是一行，其中包含九个案例的过冲振幅，按顺序排列，形式为用方括号括起来的、四舍五入到六位小数的逗号分隔列表。例如，格式必须与以下完全一样：\n$$ [a_1,a_2,\\dots,a_9], $$\n其中每个 $a_k$ 是用例 $k$ 的过冲振幅。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，“[result1,result2,result3]”）。",
            "solution": "用户提供了一个在计算流体力学领域定义明确的问题，具体涉及一维稳态对流-扩散方程混合差分格式的数值分析。对问题陈述的验证证实了其科学性、自洽性、一致性和客观性。任务是计算离散格林函数的一个特定度量——“过冲振幅”，该度量用于量化数值解的非单调行为。这需要构建一个离散算子，求解一个线性系统，然后应用一个已定义的后处理公式。该问题是有效的，并且可以按所述方式解决。\n\n针对由网格佩克莱数 $Pe$ 和混合光滑度参数 $s$ 指定的每个测试用例，系统地进行求解。\n\n**1. 离散化与矩阵构建**\n\n控制方程为 $a \\frac{du}{dx} - \\nu \\frac{d^2 u}{dx^2} = s(x)$。我们在具有 $N$ 个内部节点和间距 $h = \\frac{L}{N+1}$ 的均匀网格上离散化该方程。对于此问题，$L=1$，$N=101$，因此 $h = \\frac{1}{102}$。使用 $\\nu=1$ 和齐次狄利克雷边界条件 $u_0=0$ 及 $u_{N+1}=0$。内部节点 $i$ 处的离散方程可写为 $C_i u_{i-1} + D_i u_i + E_i u_{i+1} = s_i$，其中 $C_i$、$D_i$ 和 $E_i$ 是三对角矩阵 $\\mathbf{A}$ 的系数。\n\n对流项和扩散项的离散化如下：\n- 对流 ($a \\frac{du}{dx}$): 一阶迎风差分和二阶中心差分的混合，使用权重 $w(Pe;s) = \\frac{1}{1+\\exp\\left(\\frac{|Pe|-Pe_t}{s}\\right)}$ 进行混合，其中 $Pe_t=2$。\n- 扩散 ($-\\nu \\frac{d^2u}{dx^2}$): 标准二阶中心差分，$-\\nu \\frac{u_{i+1}-2u_i+u_{i-1}}{h^2}$。\n\n我们通过组合这些离散化来推导矩阵系数。我们定义 $|a|$ 并使用网格佩克莱数 $Pe = \\frac{ah}{\\nu}$。请注意 $|Pe| = \\frac{|a|h}{\\nu}$。\n\n节点 $i$ 处的离散算子为：\n- 当 $a \\ge 0$ ($Pe \\ge 0$) 时：$a \\left[ (1-w) \\frac{u_i - u_{i-1}}{h} + w \\frac{u_{i+1} - u_{i-1}}{2h} \\right] - \\nu \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$\n- 当 $a  0$ ($Pe  0$) 时：$a \\left[ (1-w) \\frac{u_{i+1} - u_{i}}{h} + w \\frac{u_{i+1} - u_{i-1}}{2h} \\right] - \\nu \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$\n\n合并 $u_{i-1}$、$u_i$ 和 $u_{i+1}$ 的项，得到矩阵系数。\n对于任何 $Pe$，主对角线系数为：\n$$ D_i = \\frac{|a|}{h}(1-w) + \\frac{2\\nu}{h^2} $$\n非对角线系数取决于 $Pe$ 的符号。我们定义两个可能的值：\n$$ V_1 = -\\frac{|a|}{h}(1-w/2) - \\frac{\\nu}{h^2} $$\n$$ V_2 = \\frac{|a|w}{2h} - \\frac{\\nu}{h^2} $$\n然后，对于 $Pe \\ge 0$：\n- 次对角线 ($C_i$): $V_1$\n- 超对角线 ($E_i$): $V_2$\n\n而对于 $Pe  0$：\n- 次对角线 ($C_i$): $V_2$\n- 超对角线 ($E_i$): $V_1$\n\n这样就定义了 $N \\times N$ 的三对角矩阵 $\\mathbf{A}$。\n\n**2. 离散格林函数**\n\n离散格林函数 $\\mathbf{G}$ 是线性系统 $\\mathbf{A} \\mathbf{G} = \\mathbf{e}_{i_0}$ 的解，其中 $\\mathbf{e}_{i_0}$ 是一个在对应于中心节点 $i_0 = \\lfloor N/2 \\rfloor = \\lfloor 101/2 \\rfloor = 50$ 的位置为 $1$、其余位置为零的向量。在一个大小为 $N=101$ 的 0-索引数组中，这对应于索引 $49$。这个稀疏、三对角且对角占优的系统可以使用专门的算法高效求解，例如 `scipy.linalg.solve_banded` 中可用的 Thomas 算法。\n\n**3. 过冲振幅计算**\n\n过冲振幅 $A_{\\text{over}}$ 根据问题中定义的精确步骤从解向量 $\\mathbf{G}$ 计算得出：\n1. 归一化格林函数：$g_i = G_i / |G_{i_0}|$，其中 $G_{i_0}$ 是解在脉冲位置（索引 $i_0=50$，或 0-索引 $49$）的值。\n2. 为脉冲的左右两侧定义基准邻近值：$b_L = g_{i_0-1}$ 和 $b_R = g_{i_0+1}$。\n3. 计算左侧过冲振幅 $A_L$。这是任何点 $g_j$（其中 $j \\le i_0-2$）与基准值 $b_L$ 之间的最大差值，且不小于 $0$。\n   $$ A_L = \\max\\left(0, \\max_{j \\le i_0-2} (g_j - b_L)\\right) $$\n4. 类似地计算右侧过冲振幅 $A_R$。\n   $$ A_R = \\max\\left(0, \\max_{j \\ge i_0+2} (g_j - b_R)\\right) $$\n5. 总过冲是两侧的最大值：$A_{\\text{over}} = \\max(A_L, A_R)$。\n\n该过程被实现并应用于指定的九个测试用例，并将结果收集和格式化。$Pe$ 的选择（特别是与阈值 $Pe_t=2$ 的关系）以及光滑度 $s$ 决定了混合权重 $w$ 的值，这反过来又控制了所用中心差分的程度，从而决定了由 $A_{\\text{over}}$ 测量的数值振荡倾向。\n- 当 $|Pe| \\ll 2$ 时，$w \\approx 1$ (中心差分主导)，但由于格式稳定，预计不会出现振荡。\n- 当 $|Pe| \\gg 2$ 时，较小的 $s$ 会导致 $w \\approx 0$ (迎风差分主导)，从而抑制振荡。较大的 $s$ 会导致非零的 $w$，混合入一些中心差分，可能重新引入振荡。\n- 在 $|Pe| \\approx 2$ 附近，行为对 $s$ 的值最为敏感。\n\n实现将反映这一逻辑，以计算所需的九个 $A_{\\text{over}}$ 值。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    \n    # Define problem constants\n    N = 101\n    nu = 1.0\n    L = 1.0\n    \n    # Define test cases (Pe, s)\n    test_cases = [\n        (0.0, 0.5),\n        (2.0, 0.1),\n        (2.0, 1.0),\n        (10.0, 0.1),\n        (10.0, 0.5),\n        (50.0, 0.1),\n        (-10.0, 0.5),\n        (20.0, 2.0),\n        (0.5, 0.5),\n    ]\n\n    results = []\n    for Pe, s in test_cases:\n        A_over = calculate_overshoot(Pe, s, N, nu, L)\n        results.append(A_over)\n\n    # Format and print the final output\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_overshoot(Pe, s, N, nu, L):\n    \"\"\"\n    Calculates the overshoot amplitude for a given set of parameters.\n    \n    Args:\n        Pe (float): Cell Peclet number.\n        s (float): Smoothness parameter for blending.\n        N (int): Number of interior grid points.\n        nu (float): Diffusion coefficient.\n        L (float): Domain length.\n\n    Returns:\n        float: The calculated overshoot amplitude.\n    \"\"\"\n    # 1. Setup constants and derived parameters\n    h = L / (N + 1)\n    i0_1based = 50 # Per problem: floor(101/2) = 50\n    i0_idx = i0_1based - 1 # Convert to 0-based index for Python arrays\n\n    a = Pe * nu / h\n    abs_Pe = abs(Pe)\n    Pe_t = 2.0\n    \n    # 2. Calculate blending weight `w`\n    arg_exp = (abs_Pe - Pe_t) / s\n    if arg_exp  700:  # Avoid numpy.exp overflow\n        w = 0.0\n    else:\n        w = 1.0 / (1.0 + np.exp(arg_exp))\n\n    # 3. Construct the tridiagonal matrix A\n    abs_a = abs(a)\n    \n    # Coefficients for main, sub, and super diagonals based on derived formulas\n    main_val = abs_a / h * (1.0 - w) + 2.0 * nu / h**2\n    v1 = -abs_a / h * (1.0 - w / 2.0) - nu / h**2\n    v2 = abs_a * w / (2.0 * h) - nu / h**2\n    \n    if Pe = 0:\n        sub_val = v1\n        sup_val = v2\n    else:  # Pe  0\n        sub_val = v2\n        sup_val = v1\n\n    # Create the banded matrix `ab` for scipy's solver\n    # `ab` format: row 0 is super-diagonal, row 1 is main, row 2 is sub\n    ab = np.zeros((3, N))\n    ab[0, 1:] = sup_val\n    ab[1, :] = main_val\n    ab[2, :-1] = sub_val\n\n    # 4. Solve the linear system A*G = e_{i_0}\n    b = np.zeros(N)\n    b[i0_idx] = 1.0\n\n    try:\n        G = linalg.solve_banded((1, 1), ab, b)\n    except np.linalg.LinAlgError:\n        return np.nan # Should not happen for this problem's parameters\n\n    # 5. Compute the overshoot amplitude\n    G_i0 = G[i0_idx]\n    if abs(G_i0)  1e-15:\n        return np.nan # Avoid division by zero\n        \n    g = G / abs(G_i0)\n\n    b_L = g[i0_idx - 1]\n    b_R = g[i0_idx + 1]\n\n    # Left-side overshoot\n    left_indices = slice(0, i0_idx - 1)\n    max_diff_L = np.max(g[left_indices] - b_L, initial=-np.inf)\n    A_L = np.max([0, max_diff_L])\n\n    # Right-side overshoot\n    right_indices = slice(i0_idx + 2, N)\n    max_diff_R = np.max(g[right_indices] - b_R, initial=-np.inf)\n    A_R = np.max([0, max_diff_R])\n    \n    A_over = np.max([A_L, A_R])\n    \n    return A_over\n\nsolve()\n```"
        },
        {
            "introduction": "在实际工程问题中，流场往往是非均匀的，可能包含尖锐的内边界层，这对数值格式提出了更高的要求。本练习将通过“人造解法”（Method of Manufactured Solutions）构建一个包含内边界层的精确可解问题。您的任务是实现一个自适应混合策略，使其能够根据局部流场条件自动调整混合参数 $\\beta_i$，并将其计算结果与固定的中心差分、迎风差分等策略进行误差对比，从而定量地展示自适应混合格式在处理复杂流动问题时的优越性。",
            "id": "3331018",
            "problem": "考虑在域 $[0,1]$ 上的一维稳态对流扩散方程，其空间坐标为 $x$，\n$$u(x)\\,\\frac{d\\phi}{dx} \\;=\\; \\nu\\,\\frac{d^2\\phi}{dx^2} \\;+\\; s(x),$$\n其中 $u(x)$ 是一个给定的空间变化的对流速度，$\\nu0$ 是恒定的扩散系数，$s(x)$ 是为强制执行一个选定的精确解而构造的源项。使用狄利克雷边界条件 $\\phi(0)=\\phi_{\\text{exact}}(0)$ 和 $\\phi(1)=\\phi_{\\text{exact}}(1)$。\n\n为在保持问题可通过构造求解的同时引入一个内部层，采用精确解方法。设精确解为\n$$\\phi_{\\text{exact}}(x) \\;=\\; \\frac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\right),$$\n其中一个小的正参数 $\\delta_\\phi$ 控制了靠近 $x=1/2$ 处的内部层厚度。定义空间变化的对流速度为\n$$u(x) \\;=\\; u_0 \\;+\\; u_{\\mathrm{amp}}\\,\\tanh\\!\\left(\\frac{x - 1/2}{\\delta_u}\\right),$$\n其中参数 $u_00$、$u_{\\mathrm{amp}}\\ge 0$ 和 $\\delta_u0$ 的选择应确保对于所有 $x\\in[0,1]$，$u(x)\\ge 0$。通过将 $\\phi_{\\text{exact}}(x)$ 和 $u(x)$ 代入控制方程，解析地计算出相应的源项 $s(x)$。\n\n将域离散化为一个包含 $N+1$ 个点的均匀网格，间距为 $\\Delta x = 1/N$。扩散项通过标准的二阶中心差分进行近似：\n$$\\frac{d^2\\phi}{dx^2}\\Big|_{x_i} \\approx \\frac{\\phi_{i+1} - 2\\phi_{i} + \\phi_{i-1}}{\\Delta x^2},$$\n对流项则采用一种混合差分策略进行近似，该策略通过一个局部混合权重 $\\beta_i\\in[0,1]$ 来混合中心差分和迎风差分：\n- 节点 $i$ 处的中心差分：$$\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{CD}}_i \\approx \\frac{\\phi_{i+1} - \\phi_{i-1}}{2\\Delta x}。$$\n- 节点 $i$ 处当 $u(x_i)\\ge 0$ 时的迎风差分：$$\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{UD}}_i \\approx \\frac{\\phi_{i} - \\phi_{i-1}}{\\Delta x}。$$\n- 节点 $i$ 处当 $u(x_i)  0$ 时的迎风差分：$$\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{UD}}_i \\approx \\frac{\\phi_{i+1} - \\phi_{i}}{\\Delta x}。$$\n- 混合格式：$$\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{HYB}}_i \\approx (1-\\beta_i)\\,\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{CD}}_i \\;+\\; \\beta_i\\,\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{UD}}_i。$$\n\n实现两种 $\\beta_i$ 策略：\n1. 固定混合，对所有 $i$ 有 $\\beta_i=\\beta_{\\mathrm{fixed}}$，其中 $\\beta_{\\mathrm{fixed}}$ 是从集合 $\\{0.0,\\,0.5,\\,1.0\\}$ 中选择的一个常数。\n2. 自适应混合，其中 $\\beta_i$ 取决于局部网格佩克莱数 $P_e(x_i)$，定义为 $$P_e(x_i) \\;=\\; \\frac{|u(x_i)|\\,\\Delta x}{\\nu}。$$ 使用一个以经典混合格式阈值 $P_e = 2$ 为中心的平滑逻辑斯蒂型过渡：\n$$\\beta_i \\;=\\; \\frac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{P_e(x_i) - 2}{w}\\right)\\right),$$\n其中 $w$ 是一个正的陡峭度参数（使用 $w=0.5$）。\n\n组装得到的针对内部未知数 $\\{\\phi_i\\}_{i=1}^{N-1}$ 的线性系统，并使用在 $x=0$ 和 $x=1$ 处的精确解值施加狄利克雷边界条件。求解该线性系统以获得离散近似解 $\\phi^{\\mathrm{num}}$。\n\n通过在网格上比较 $\\phi^{\\mathrm{num}}$ 与 $\\phi_{\\text{exact}}$ 来计算离散误差，并报告以下误差范数：\n- 离散 $L_2$ 范数：$$\\lVert e \\rVert_{L_2} \\;=\\; \\left(\\sum_{i=0}^{N} \\left(\\phi^{\\mathrm{num}}_i - \\phi_{\\text{exact}}(x_i)\\right)^2 \\,\\Delta x\\right)^{1/2}。$$\n- 离散 $L_\\infty$ 范数：$$\\lVert e \\rVert_{L_\\infty} \\;=\\; \\max_{0\\le i \\le N}\\left|\\phi^{\\mathrm{num}}_i - \\phi_{\\text{exact}}(x_i)\\right|。$$\n\n对于每个测试用例，计算自适应策略相对于每个固定的 $\\beta_{\\mathrm{fixed}}\\in\\{0.0,\\,0.5,\\,1.0\\}$ 的改进因子，定义为固定策略误差与自适应策略误差之比：\n- $I_{2}(\\beta_{\\mathrm{fixed}}) = \\lVert e \\rVert_{L_2}^{\\mathrm{fixed}} \\big/ \\lVert e \\rVert_{L_2}^{\\mathrm{adaptive}}$。\n- $I_{\\infty}(\\beta_{\\mathrm{fixed}}) = \\lVert e \\rVert_{L_\\infty}^{\\mathrm{fixed}} \\big/ \\lVert e \\rVert_{L_\\infty}^{\\mathrm{adaptive}}$。\n\n您的程序必须实现上述内容，并为每个测试用例输出一个包含六个浮点数的列表，排列如下\n$$\\left[ I_{2}(0.0),\\, I_{\\infty}(0.0),\\, I_{2}(0.5),\\, I_{\\infty}(0.5),\\, I_{2}(1.0),\\, I_{\\infty}(1.0) \\right]。$$\n将所有测试用例的结果汇总到一个列表中，并按照下面指定的精确格式打印在一行上。\n\n测试套件：\n使用以下 $4$ 个测试用例，每个用例由元组 $(N,\\,\\nu,\\,u_0,\\,u_{\\mathrm{amp}},\\,\\delta_\\phi,\\,\\delta_u)$ 指定：\n- 用例 1：$(200,\\,0.001,\\,1.0,\\,0.9,\\,0.02,\\,0.02)$。\n- 用例 2：$(200,\\,0.01,\\,1.0,\\,0.5,\\,0.05,\\,0.05)$。\n- 用例 3：$(400,\\,0.0005,\\,0.5,\\,0.49,\\,0.01,\\,0.01)$。\n- 用例 4：$(100,\\,0.001,\\,0.0,\\,0.0,\\,0.02,\\,0.02)$。\n\n最终输出格式：\n您的程序应生成单行输出，包含结果，格式为一个逗号分隔的列表的列表，每个内部列表对应一个测试用例，形式如下\n$$\\texttt{[[r_{1,1},r_{1,2},r_{1,3},r_{1,4},r_{1,5},r_{1,6}],[r_{2,1},\\dots,r_{2,6}],[r_{3,1},\\dots,r_{3,6}],[r_{4,1},\\dots,r_{4,6}]]}$$\n其中每个 $r_{k,j}$ 是一个浮点数。",
            "solution": "该问题是有效的。它提出了一个在计算流体动力学领域中适定且有科学依据的任务，具体涉及一维稳态对流扩散方程的数值解。所有参数、方程和边界条件都已明确定义，构成了一个自洽且可验证的问题。精确解方法的使用是代码验证和数值格式分析的标准技术。所提供的测试用例与问题的约束条件一致，包括作为一项有价值的检验的纯扩散边界情况。\n\n求解过程包括几个步骤：推导解析源项，将控制偏微分方程离散化为线性代数方程组，针对不同的数值格式求解该系统，以及计算指定的误差度量和改进因子。\n\n首先，我们使用精确解方法推导源项 $s(x)$。控制方程为\n$$u(x)\\,\\frac{d\\phi}{dx} \\;=\\; \\nu\\,\\frac{d^2\\phi}{dx^2} \\;+\\; s(x)$$\n因此，源项为 $s(x) = u(x)\\frac{d\\phi}{dx} - \\nu\\frac{d^2\\phi}{dx^2}$。我们需要精确解 $\\phi_{\\text{exact}}(x) = \\frac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\right)$ 的一阶和二阶导数。设 $\\theta_\\phi(x) = \\frac{x - 1/2}{\\delta_\\phi}$。\n\n一阶导数为：\n$$ \\frac{d\\phi_{\\text{exact}}}{dx} = \\frac{d}{dx}\\left[\\frac{1}{2}(1 + \\tanh(\\theta_\\phi(x)))\\right] = \\frac{1}{2} \\text{sech}^2(\\theta_\\phi(x)) \\cdot \\frac{d\\theta_\\phi}{dx} = \\frac{1}{2\\delta_\\phi}\\text{sech}^2\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right) $$\n\n二阶导数为：\n$$ \\frac{d^2\\phi_{\\text{exact}}}{dx^2} = \\frac{d}{dx}\\left[\\frac{1}{2\\delta_\\phi}\\text{sech}^2(\\theta_\\phi(x))\\right] = \\frac{1}{2\\delta_\\phi} \\cdot \\left(-2\\,\\text{sech}^2(\\theta_\\phi(x))\\tanh(\\theta_\\phi(x))\\right) \\cdot \\frac{d\\theta_\\phi}{dx} $$\n$$ \\frac{d^2\\phi_{\\text{exact}}}{dx^2} = -\\frac{1}{\\delta_\\phi^2}\\text{sech}^2\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\tanh\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right) $$\n\n将这些代入 $s(x)$ 的表达式中，我们得到解析源项：\n$$ s(x) = u(x)\\left[\\frac{1}{2\\delta_\\phi}\\text{sech}^2\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\right] - \\nu\\left[-\\frac{1}{\\delta_\\phi^2}\\text{sech}^2\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\tanh\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\right] $$\n$$ s(x) = \\frac{1}{\\delta_\\phi} \\text{sech}^2\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right) \\left[ \\frac{u(x)}{2} + \\frac{\\nu}{\\delta_\\phi}\\tanh\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right) \\right] $$\n其中 $u(x) = u_0 + u_{\\mathrm{amp}}\\,\\tanh\\!\\left(\\frac{x - 1/2}{\\delta_u}\\right)$。\n\n接下来，我们将域 $[0,1]$ 离散化为 $N+1$ 个点 $x_i = i\\Delta x$，$i=0, 1, \\dots, N$，网格间距为 $\\Delta x = 1/N$。在内部节点 $x_i$ 处的控制方程近似为：\n$$ u_i \\left(\\frac{d\\phi}{dx}\\right)_i - \\nu \\left(\\frac{d^2\\phi}{dx^2}\\right)_i = s_i $$\n其中 $u_i = u(x_i)$，$s_i = s(x_i)$，$\\phi_i$ 是对 $\\phi(x_i)$ 的数值近似。\n\n扩散项通过二阶中心差分来近似：\n$$ \\left(\\frac{d^2\\phi}{dx^2}\\right)_i \\approx \\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{\\Delta x^2} $$\n\n对流项使用中心差分和迎风差分的混合格式来近似。鉴于问题参数确保 $u(x_i) \\ge 0$，我们使用非负速度的迎风格式。\n$$ \\left(\\frac{d\\phi}{dx}\\right)_i \\approx (1-\\beta_i)\\left(\\frac{\\phi_{i+1} - \\phi_{i-1}}{2\\Delta x}\\right) + \\beta_i\\left(\\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}\\right) $$\n重新整理，按 $\\phi_j$ 对各项进行分组：\n$$ \\left(\\frac{d\\phi}{dx}\\right)_i \\approx \\frac{1}{2\\Delta x}\\left[ (1-\\beta_i)\\phi_{i+1} + 2\\beta_i\\phi_i - (1+\\beta_i)\\phi_{i-1} \\right] $$\n\n将这些近似代入控制方程并重新整理，得到每个内部节点 $i \\in \\{1, \\dots, N-1\\}$ 的一个线性代数方程：\n$$ \\phi_{i-1}\\left(-\\frac{u_i(1+\\beta_i)}{2\\Delta x} - \\frac{\\nu}{\\Delta x^2}\\right) + \\phi_i\\left(\\frac{u_i \\beta_i}{\\Delta x} + \\frac{2\\nu}{\\Delta x^2}\\right) + \\phi_{i+1}\\left(\\frac{u_i(1-\\beta_i)}{2\\Delta x} - \\frac{\\nu}{\\Delta x^2}\\right) = s_i $$\n这可以写成标准形式 $C_{W,i}\\phi_{i-1} + C_{P,i}\\phi_i + C_{E,i}\\phi_{i+1} = s_i$，其中：\n$$ C_{W,i} = -\\frac{u_i(1+\\beta_i)}{2\\Delta x} - \\frac{\\nu}{\\Delta x^2} \\quad (\\text{西系数}) $$\n$$ C_{P,i} = \\frac{u_i \\beta_i}{\\Delta x} + \\frac{2\\nu}{\\Delta x^2} \\quad (\\text{点系数}) $$\n$$ C_{E,i} = \\frac{u_i(1-\\beta_i)}{2\\Delta x} - \\frac{\\nu}{\\Delta x^2} \\quad (\\text{东系数}) $$\n\n混合因子 $\\beta_i$ 由两种策略之一确定：\n$1$. 固定混合：$\\beta_i = \\beta_{\\mathrm{fixed}}$，其中 $\\beta_{\\mathrm{fixed}}$ 是一个常数（$0.0$，$0.5$ 或 $1.0$）。\n$2$. 自适应混合：$\\beta_i$ 是局部网格佩克莱数 $P_e(x_i) = \\frac{|u(x_i)|\\Delta x}{\\nu}$ 的函数。使用指定的逻辑斯蒂函数，陡峭度参数 $w=0.5$：\n$$ \\beta_i = \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{P_e(x_i) - 2}{0.5}\\right)\\right) $$\n\n这些对于 $i=1, \\dots, N-1$ 的方程构成一个三对角线性系统 $A\\mathbf{\\phi}_{\\text{int}} = \\mathbf{b}$，其中 $\\mathbf{\\phi}_{\\text{int}} = [\\phi_1, \\phi_2, \\dots, \\phi_{N-1}]^T$ 是未知内部节点值的向量。矩阵 $A$ 的维度为 $(N-1) \\times (N-1)$。\n\n狄利克雷边界条件 $\\phi_0 = \\phi_{\\text{exact}}(0)$ 和 $\\phi_N = \\phi_{\\text{exact}}(1)$ 是已知的。它们的贡献被移到 $i=1$ 和 $i=N-1$ 方程的右侧：\n对于 $i=1$：$C_{P,1}\\phi_1 + C_{E,1}\\phi_2 = s_1 - C_{W,1}\\phi_0$\n对于 $i=N-1$：$C_{W,N-1}\\phi_{N-2} + C_{P,N-1}\\phi_{N-1} = s_{N-1} - C_{E,N-1}\\phi_N$\n\n求解这个三对角系统以找到 $\\mathbf{\\phi}_{\\text{int}}$。然后，完整的数值解向量为 $\\phi^{\\mathrm{num}} = [\\phi_0, \\phi_1, \\dots, \\phi_{N-1}, \\phi_N]^T$。\n\n通过在网格点上比较 $\\phi^{\\mathrm{num}}$ 和精确解 $\\phi_{\\text{exact}}$ 来计算误差。按规定计算离散 $L_2$ 和 $L_\\infty$ 误差范数。最后，计算改进因子，该因子量化了自适应格式的相对性能，计算方法为固定-$\\beta$格式的误差范数与自适应格式相应范数之比。\n$$I_{2}(\\beta_{\\mathrm{fixed}}) = \\frac{\\lVert e \\rVert_{L_2}^{\\mathrm{fixed}}}{\\lVert e \\rVert_{L_2}^{\\mathrm{adaptive}}}, \\quad I_{\\infty}(\\beta_{\\mathrm{fixed}}) = \\frac{\\lVert e \\rVert_{L_\\infty}^{\\mathrm{fixed}}}{\\lVert e \\rVert_{L_\\infty}^{\\mathrm{adaptive}}}$$\n对于测试用例4，其中 $u(x)=0$，对流项消失。因此，所有差分格式产生相同的结果，并且所有改进因子预计都恰好为 $1.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (200, 0.001, 1.0, 0.9, 0.02, 0.02),\n        (200, 0.01, 1.0, 0.5, 0.05, 0.05),\n        (400, 0.0005, 0.5, 0.49, 0.01, 0.01),\n        (100, 0.001, 0.0, 0.0, 0.02, 0.02),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, nu, u0, u_amp, delta_phi, delta_u = case\n        \n        # Calculate errors for the four schemes\n        err_fixed_00 = solve_case(N, nu, u0, u_amp, delta_phi, delta_u, 'fixed', beta_fixed=0.0)\n        err_fixed_05 = solve_case(N, nu, u0, u_amp, delta_phi, delta_u, 'fixed', beta_fixed=0.5)\n        err_fixed_10 = solve_case(N, nu, u0, u_amp, delta_phi, delta_u, 'fixed', beta_fixed=1.0)\n        err_adaptive = solve_case(N, nu, u0, u_amp, delta_phi, delta_u, 'adaptive')\n\n        l2_err_adapt, linf_err_adapt = err_adaptive\n\n        # Calculate improvement factors\n        # For stability, if adaptive error is zero, ratio is 1 (as fixed error must also be zero).\n        # This handles the u=0 case where all errors are identical.\n        I2_00 = err_fixed_00[0] / l2_err_adapt if l2_err_adapt > 0 else 1.0\n        Iinf_00 = err_fixed_00[1] / linf_err_adapt if linf_err_adapt > 0 else 1.0\n        \n        I2_05 = err_fixed_05[0] / l2_err_adapt if l2_err_adapt > 0 else 1.0\n        Iinf_05 = err_fixed_05[1] / linf_err_adapt if linf_err_adapt > 0 else 1.0\n        \n        I2_10 = err_fixed_10[0] / l2_err_adapt if l2_err_adapt > 0 else 1.0\n        Iinf_10 = err_fixed_10[1] / linf_err_adapt if linf_err_adapt > 0 else 1.0\n\n        case_results = [I2_00, Iinf_00, I2_05, Iinf_05, I2_10, Iinf_10]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print('[' + ','.join(f\"[{','.join(map(str, r))}]\" for r in all_results) + ']')\n\ndef solve_case(N, nu, u0, u_amp, delta_phi, delta_u, beta_strategy, beta_fixed=None):\n    \"\"\"\n    Solves the 1D convection-diffusion problem for a single strategy.\n    \n    Args:\n        N, nu, u0, u_amp, delta_phi, delta_u: Problem parameters.\n        beta_strategy (str): 'fixed' or 'adaptive'.\n        beta_fixed (float, optional): Value for fixed blending.\n\n    Returns:\n        A tuple (l2_error, linf_error).\n    \"\"\"\n    # 1. Setup grid\n    x = np.linspace(0.0, 1.0, N + 1)\n    dx = 1.0 / N\n\n    # 2. Define analytical functions\n    # Using '1 - tanh^2' for sech^2 is more numerically stable than '1/cosh^2'\n    def phi_exact_func(x_):\n        theta = (x_ - 0.5) / delta_phi\n        return 0.5 * (1.0 + np.tanh(theta))\n\n    def u_func(x_):\n        theta = (x_ - 0.5) / delta_u\n        return u0 + u_amp * np.tanh(theta)\n\n    def s_func(x_):\n        u_val = u_func(x_)\n        \n        theta_phi = (x_ - 0.5) / delta_phi\n        tanh_phi = np.tanh(theta_phi)\n        sech2_phi = 1.0 - tanh_phi**2\n        \n        dphi_dx = 0.5 * sech2_phi / delta_phi\n        d2phi_dx2 = -sech2_phi * tanh_phi / delta_phi**2\n        \n        return u_val * dphi_dx - nu * d2phi_dx2\n\n    # 3. Evaluate exact solution, velocity, and source at grid points\n    phi_exact_grid = phi_exact_func(x)\n    u_grid = u_func(x)\n    s_grid = s_func(x)\n\n    # 4. Determine beta values for interior nodes\n    beta_vals_interior = np.zeros(N - 1)\n    i_int = np.arange(1, N) # Indices of interior points\n    if beta_strategy == 'fixed':\n        beta_vals_interior[:] = beta_fixed\n    else: # adaptive\n        w = 0.5\n        # Since u(x)>=0, abs is not strictly necessary but good practice\n        pe = np.abs(u_grid[i_int]) * dx / nu\n        beta_vals_interior = 0.5 * (1.0 + np.tanh((pe - 2.0) / w))\n\n    # 5. Assemble banded matrix A and vector b for interior nodes\n    num_unknowns = N - 1\n    # ab[0,:]: upper\n    # ab[1,:]: main\n    # ab[2,:]: lower\n    ab = np.zeros((3, num_unknowns))\n    b = np.zeros(num_unknowns)\n    \n    ui = u_grid[i_int]\n    betai = beta_vals_interior\n\n    # Calculate coefficients for all interior nodes at once\n    CW = -ui * (1.0 + betai) / (2.0 * dx) - nu / dx**2\n    CP = ui * betai / dx + 2.0 * nu / dx**2\n    CE = ui * (1.0 - betai) / (2.0 * dx) - nu / dx**2\n\n    # Populate banded matrix\n    ab[0, 1:] = CE[:-1]       # Upper diagonal\n    ab[1, :] = CP             # Main diagonal\n    ab[2, :-1] = CW[1:]       # Lower diagonal\n\n    # Populate RHS vector b\n    b[:] = s_grid[i_int]\n    \n    # Apply boundary conditions\n    b[0] -= CW[0] * phi_exact_grid[0]      # At i=1\n    b[-1] -= CE[-1] * phi_exact_grid[-1]   # At i=N-1\n    \n    # 6. Solve the system\n    phi_interior = solve_banded((1, 1), ab, b)\n\n    # 7. Construct full numerical solution vector\n    phi_num = np.zeros(N + 1)\n    phi_num[0] = phi_exact_grid[0]\n    phi_num[-1] = phi_exact_grid[-1]\n    phi_num[1:N] = phi_interior\n\n    # 8. Calculate error norms\n    error = phi_num - phi_exact_grid\n    l2_error = np.sqrt(np.sum(error**2) * dx)\n    linf_error = np.max(np.abs(error))\n\n    return l2_error, linf_error\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}