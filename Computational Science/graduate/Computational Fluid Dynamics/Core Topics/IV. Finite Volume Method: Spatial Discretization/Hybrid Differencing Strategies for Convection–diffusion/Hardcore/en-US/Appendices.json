{
    "hands_on_practices": [
        {
            "introduction": "A crucial first step in computational science is verifying that a numerical implementation behaves as theoretically predicted. This practice provides a foundational exercise in code verification by performing a grid refinement study on a classic 1D convection-diffusion problem. By implementing a basic hybrid scheme that switches between central and upwind differencing based on the cell Peclet number $P_{\\Delta}$, you will numerically determine the scheme's order of accuracy and observe how it degrades from second-order in diffusion-dominated regimes to first-order in convection-dominated regimes .",
            "id": "3330986",
            "problem": "Consider the steady one-dimensional convection–diffusion boundary value problem on the interval $[0,1]$ with Dirichlet boundary conditions: find a sufficiently smooth function $u(x)$ such that\n$$\na\\,\\frac{d u}{d x}(x) - D\\,\\frac{d^2 u}{d x^2}(x) = 0,\\quad x \\in (0,1),\\qquad u(0) = 0,\\quad u(1) = 1,\n$$\nwhere $a$ and $D$ are real constants representing the advective speed and diffusivity, respectively. All quantities are dimensionless (no physical units). The task is to perform grid refinement studies using a hybrid differencing strategy for the convection term and to extract the observed order of accuracy in diffusion-dominated and convection-dominated regimes.\n\nImplement the Finite Difference Method (FDM) for the spatial discretization with a uniform grid spacing $\\Delta x = h = 1/N$, where $N$ is the total number of intervals and the grid has nodes at $x_i = i h$ for $i=0,1,\\dots,N$. Always approximate the diffusion term $-D\\,\\frac{d^2 u}{d x^2}$ by the standard second-order central difference. For the convection term $a\\,\\frac{d u}{d x}$, adopt the following hybrid differencing strategy based on the local cell Peclet number $P_{\\Delta} = \\frac{|a|\\,\\Delta x}{D}$:\n- If $P_{\\Delta} \\le 2$, use the second-order central difference for $\\frac{d u}{d x}$ at interior nodes.\n- If $P_{\\Delta} > 2$, use the first-order upwind difference for $\\frac{d u}{d x}$ aligned with the sign of $a$ at interior nodes (i.e., for $a>0$, use the backward difference; for $a0$, use the forward difference).\n\nYou must:\n- Assemble the resulting tridiagonal linear system for the interior unknowns $u_i$ at nodes $x_i$ for $i=1,\\dots,N-1$ with $u_0=0$ and $u_N=1$ imposed directly.\n- Solve the linear system and compute the numerical solution $u^{(h)}(x_i)$ at all nodes.\n- Compute the discrete $\\ell^2$ error norm against the exact solution $u(x)$ of the boundary value problem derived from the governing equation,\n$$\nE(h) = \\left(\\Delta x \\sum_{i=0}^{N} \\left(u^{(h)}(x_i) - u(x_i)\\right)^2\\right)^{1/2}.\n$$\n- For each test regime, compute the observed order of accuracy $p$ by performing a least-squares linear regression of $\\log(E(h))$ against $\\log(h)$ over the refinement sequence. That is, determine $p$ such that $\\log(E(h)) \\approx \\alpha + p\\,\\log(h)$ for some constant $\\alpha$.\n\nTest suite:\n- Use $D=1$ for all tests. For each case, provide the sequence of $N$ values as listed.\n    $1.$ Diffusion-dominated regime: $a=0.1$, $N\\in\\{32,64,128,256,512\\}$.\n    $2.$ Convection-dominated regime with positive advection: $a=400$, $N\\in\\{8,16,32,64\\}$.\n    $3.$ Pure diffusion boundary value problem: $a=0$, $N\\in\\{32,64,128,256,512\\}$.\n    $4.$ Convection-dominated regime with negative advection: $a=-400$, $N\\in\\{8,16,32,64\\}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the four observed orders of accuracy for cases $1$ through $4$ as a comma-separated list enclosed in square brackets, rounded to three decimal places, for example, $[p_1,p_2,p_3,p_4]$.\n\nAngle units are not applicable. Percentages are not applicable. All quantities are dimensionless. The exact solution used for error evaluation must be derived from the differential equation and boundary conditions, not empirically specified.",
            "solution": "The user-provided problem is a well-posed boundary value problem (BVP) from computational fluid dynamics, requiring a numerical solution and error analysis. The problem is scientifically grounded, self-contained, and calls for the application of standard, verifiable numerical methods. Therefore, the problem is valid.\n\nThe solution process involves several steps:\n1.  Deriving the exact analytical solution to the BVP to serve as a benchmark for accuracy.\n2.  Discretizing the governing differential equation using the specified hybrid finite difference scheme.\n3.  Assembling and solving the resulting tridiagonal linear system of equations.\n4.  Computing the discrete $\\ell^2$ error norm for a sequence of refined grids.\n5.  Calculating the observed order of accuracy, $p$, by performing a linear regression on the log-log plot of error versus grid spacing.\n\n### 1. Analytical Solution\nThe governing ordinary differential equation (ODE) is a second-order linear homogeneous equation with constant coefficients:\n$$\nD\\,\\frac{d^2 u}{d x^2}(x) - a\\,\\frac{d u}{d x}(x) = 0\n$$\nThe characteristic equation is $D r^2 - a r = r(D r - a) = 0$, which has roots $r_1 = 0$ and $r_2 = a/D$.\n\nFor $a \\neq 0$, the general solution is of the form $u(x) = C_1 e^{r_1 x} + C_2 e^{r_2 x}$, which gives:\n$$\nu(x) = C_1 + C_2 e^{(a/D)x}\n$$\nThe constants $C_1$ and $C_2$ are determined by the Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 1$.\nApplying $u(0) = 0$:\n$$\nC_1 + C_2 e^0 = 0 \\implies C_1 = -C_2\n$$\nApplying $u(1) = 1$:\n$$\nC_1 + C_2 e^{a/D} = 1\n$$\nSubstituting $C_1 = -C_2$ into the second equation gives $-C_2 + C_2 e^{a/D} = 1$, which yields $C_2 = 1 / (e^{a/D} - 1)$. Consequently, $C_1 = -1 / (e^{a/D} - 1)$.\nThe exact solution for $a \\neq 0$ is:\n$$\nu(x) = \\frac{e^{(a/D)x} - 1}{e^{a/D} - 1}\n$$\n\nFor the special case $a = 0$, the ODE simplifies to $D u''(x) = 0$, which integrates to $u(x) = C_1 x + C_2$. Applying the boundary conditions $u(0)=0$ and $u(1)=1$ gives $C_2=0$ and $C_1=1$, respectively. Thus, for $a=0$, the exact solution is:\n$$\nu(x) = x\n$$\nThis result can also be obtained by taking the limit of the general solution as $a \\to 0$ using L'Hôpital's rule.\n\n### 2. Finite Difference Discretization\nWe discretize the domain $[0,1]$ using a uniform grid with $N$ intervals, such that the grid spacing is $h = \\Delta x = 1/N$ and the grid nodes are $x_i = i h$ for $i = 0, 1, \\dots, N$. The numerical solution at these nodes is denoted by $u_i \\approx u(x_i)$. The values $u_0=0$ and $u_N=1$ are known from the boundary conditions. We seek to find the interior values $u_1, \\dots, u_{N-1}$.\n\nThe discretized equation at an interior node $x_i$ is:\n$$\na \\left(\\frac{du}{dx}\\right)_i - D \\left(\\frac{d^2u}{dx^2}\\right)_i = 0\n$$\nThe diffusion term is always approximated by the second-order central difference:\n$$\n- D \\left(\\frac{d^2u}{dx^2}\\right)_i \\approx -D \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n$$\nThe convection term is approximated using a hybrid scheme based on the cell Peclet number $P_{\\Delta} = \\frac{|a|h}{D}$.\n\n**Case A: $P_{\\Delta} \\le 2$ (Central Difference Scheme)**\nThe convection term is approximated by the second-order central difference:\n$$\na \\left(\\frac{du}{dx}\\right)_i \\approx a \\frac{u_{i+1} - u_{i-1}}{2h}\n$$\nSubstituting these approximations into the governing ODE and rearranging terms to the form $a_P u_i = a_W u_{i-1} + a_E u_{i+1}$ yields:\n$$\n\\frac{2D}{h^2} u_i = \\left(\\frac{D}{h^2} + \\frac{a}{2h}\\right) u_{i-1} + \\left(\\frac{D}{h^2} - \\frac{a}{2h}\\right) u_{i+1}\n$$\nThe coefficients are:\n$a_W = \\frac{D}{h} + \\frac{a}{2}$, $a_E = \\frac{D}{h} - \\frac{a}{2}$, and $a_P = a_W + a_E = \\frac{2D}{h}$.\n\n**Case B: $P_{\\Delta} > 2$ (Upwind Difference Scheme)**\nThe scheme becomes first-order upwind.\nIf $a>0$, a backward difference is used: $a \\left(\\frac{du}{dx}\\right)_i \\approx a \\frac{u_i - u_{i-1}}{h}$.\nThe discretized equation is:\n$$\n\\left(\\frac{2D}{h^2} + \\frac{a}{h}\\right) u_i = \\left(\\frac{D}{h^2} + \\frac{a}{h}\\right) u_{i-1} + \\left(\\frac{D}{h^2}\\right) u_{i+1}\n$$\nThe coefficients are:\n$a_W = \\frac{D}{h} + a$, $a_E = \\frac{D}{h}$, and $a_P = a_W + a_E = \\frac{2D}{h} + a$.\n\nIf $a0$, a forward difference is used: $a \\left(\\frac{du}{dx}\\right)_i \\approx a \\frac{u_{i+1} - u_{i}}{h}$.\nThe discretized equation is:\n$$\n\\left(\\frac{2D}{h^2} - \\frac{a}{h}\\right) u_i = \\left(\\frac{D}{h^2}\\right) u_{i-1} + \\left(\\frac{D}{h^2} - \\frac{a}{h}\\right) u_{i+1}\n$$\nThe coefficients are:\n$a_W = \\frac{D}{h}$, $a_E = \\frac{D}{h} - a$, and $a_P = a_W + a_E = \\frac{2D}{h} - a$.\n\n### 3. Linear System Assembly\nFor each interior node $i=1, \\dots, N-1$, we have an equation of the form:\n$$\n-a_W u_{i-1} + a_P u_i - a_E u_{i+1} = 0\n$$\nSince $a_W, a_P, a_E$ are constant across the uniform grid for a given test case, this forms a tridiagonal system of linear equations $A\\vec{u} = \\vec{b}$ for the vector of unknowns $\\vec{u} = [u_1, u_2, \\dots, u_{N-1}]^T$.\n\nThe matrix $A$ is an $(N-1) \\times (N-1)$ tridiagonal matrix:\n$$\nA = \\begin{pmatrix}\na_P  -a_E  0  \\dots  0 \\\\\n-a_W  a_P  -a_E  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n0  \\dots  -a_W  a_P  -a_E \\\\\n0  \\dots  0  -a_W  a_P\n\\end{pmatrix}\n$$\nThe right-hand side vector $\\vec{b}$ incorporates the boundary conditions.\nFor $i=1$: $-a_W u_0 + a_P u_1 - a_E u_2 = 0$. With $u_0=0$, this is $a_P u_1 - a_E u_2 = 0$.\nFor $i=N-1$: $-a_W u_{N-2} + a_P u_{N-1} - a_E u_N = 0$. With $u_N=1$, this becomes $-a_W u_{N-2} + a_P u_{N-1} = a_E$.\nThus, the vector $\\vec{b}$ is:\n$$\n\\vec{b} = [0, 0, \\dots, 0, a_E]^T\n$$\nThis tridiagonal system can be efficiently solved using specialized algorithms, such as `scipy.linalg.solve_banded`.\n\n### 4. Error Analysis and Order of Accuracy\nAfter solving for the numerical solution $u^{(h)} = [u_0, u_1, \\dots, u_N]^T$, we compute the discrete $\\ell^2$ error norm against the exact solution $u(x_i)$:\n$$\nE(h) = \\left(h \\sum_{i=0}^{N} \\left(u_i - u(x_i)\\right)^2\\right)^{1/2}\n$$\nThe theoretical convergence rate is $E(h) \\approx C h^p$, where $p$ is the order of accuracy. To find the observed order, we take the logarithm:\n$$\n\\log(E(h)) \\approx \\log(C) + p \\log(h)\n$$\nBy computing $E(h)$ for a sequence of grid spacings $h$, we can perform a linear regression on $\\log(E(h))$ versus $\\log(h)$. The slope of the resulting line is the observed order of accuracy, $p$.\n\n### 5. Analysis of Test Cases\n- **Case 1 ($a=0.1, D=1$):** With $N \\ge 32$, $h \\le 1/32$. The maximum $P_{\\Delta} = 0.1 \\times (1/32) / 1 \\approx 0.0031$, which is much less than $2$. The second-order central difference scheme is used, so we expect $p \\approx 2.0$.\n- **Case 2 ($a=400, D=1$):** With $N \\le 64$, $h \\ge 1/64$. The minimum $P_{\\Delta} = 400 \\times (1/64) / 1 = 6.25$, which is greater than $2$. The first-order upwind scheme is used, so we expect $p \\approx 1.0$.\n- **Case 3 ($a=0, D=1$):** $P_{\\Delta} = 0$, so the central difference scheme is used. The scheme reduces to the standard stencil for the second derivative, and the exact solution is $u(x)=x$. The finite difference method recovers this linear solution exactly in the absence of floating-point error. Numerically, the error will be at the level of machine precision, and thus roughly constant for all $h$. This leads to an observed order of accuracy $p \\approx 0.0$.\n- **Case 4 ($a=-400, D=1$):** Similar to Case 2, the minimum $P_{\\Delta} = |-400| \\times (1/64) / 1 = 6.25 > 2$. The first-order upwind scheme is used, and we expect $p \\approx 1.0$.\n\nThe implementation will follow this logic to compute the four values of $p$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D steady convection-diffusion equation using a hybrid finite\n    difference scheme and calculates the observed order of accuracy for\n    four different test regimes.\n    \"\"\"\n\n    def get_exact_solution(x, a, D):\n        \"\"\"\n        Computes the exact analytical solution to the BVP.\n        \"\"\"\n        if a == 0.0:\n            return x\n        else:\n            ratio = a / D\n            # Use np.expm1 for numerical stability when ratio is close to zero.\n            return np.expm1(ratio * x) / np.expm1(ratio)\n\n    def solve_one_case(a, D, N_values):\n        \"\"\"\n        Performs grid refinement study for a single (a, D) case.\n        Returns the observed order of accuracy.\n        \"\"\"\n        h_list = []\n        error_list = []\n\n        for N in N_values:\n            # 1. Grid setup\n            h = 1.0 / N\n            x_nodes = np.linspace(0.0, 1.0, N + 1)\n            \n            # 2. Determine scheme based on cell Peclet number\n            P_delta = np.abs(a) * h / D\n\n            if P_delta = 2.0:\n                # Central Difference Scheme for convection\n                a_W = D/h + a/2.0\n                a_E = D/h - a/2.0\n                # Per the control volume formulation, a_P = a_W + a_E for CDS\n                a_P = 2.0*D/h\n            else:\n                # Upwind Scheme for convection\n                if a  0.0:\n                    # Backward difference\n                    a_W = D/h + a\n                    a_E = D/h\n                    a_P = a_W + a_E # = 2*D/h + a\n                else: # a  0.0\n                    # Forward difference\n                    a_W = D/h\n                    a_E = D/h - a\n                    a_P = a_W + a_E # = 2*D/h - a\n            \n            # 3. Assemble the tridiagonal linear system Au = b\n            dim = N - 1\n            ab = np.zeros((3, dim))\n            b = np.zeros(dim)\n            \n            # Fill the banded matrix 'ab' for scipy.linalg.solve_banded\n            # ab[0, 1:] = super-diagonal\n            # ab[1, :]   = main-diagonal\n            # ab[2, :-1]= sub-diagonal\n            ab[1, :] = a_P\n            if dim  0:\n                ab[0, 1:] = -a_E\n                ab[2, :-1] = -a_W\n\n            # 4. Apply boundary conditions\n            # u_0 = 0 is handled implicitly as it doesn't add to the RHS\n            # u_N = 1 affects the last equation (for u_{N-1})\n            if dim  0:\n                # The term -a_E * u_N becomes a_E on the RHS\n                b[-1] = a_E * 1.0\n            \n            # 5. Solve the system\n            if dim  0:\n                u_internal = solve_banded((1, 1), ab, b)\n            else:\n                u_internal = np.array([])\n            \n            # 6. Construct full numerical solution vector\n            u_numerical = np.zeros(N + 1)\n            u_numerical[0] = 0.0\n            u_numerical[-1] = 1.0\n            u_numerical[1:-1] = u_internal\n\n            # 7. Compute the l2-error\n            u_exact = get_exact_solution(x_nodes, a, D)\n            error_sq_sum = np.sum((u_numerical - u_exact)**2)\n            error = np.sqrt(h * error_sq_sum)\n            \n            # Handle cases where error is zero to avoid log(0)\n            if error  np.finfo(np.float64).tiny:\n                error = np.finfo(np.float64).tiny\n\n            h_list.append(h)\n            error_list.append(error)\n        \n        # 8. Calculate order of accuracy using linear regression\n        log_h = np.log(np.array(h_list))\n        log_error = np.log(np.array(error_list))\n        \n        # Fit a line: log(error) = p * log(h) + const\n        p, _ = np.polyfit(log_h, log_error, 1)\n        \n        return p\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'a': 0.1,  'D': 1.0, 'N_values': [32, 64, 128, 256, 512]}, # Diffusion-dominated\n        {'a': 400.0, 'D': 1.0, 'N_values': [8, 16, 32, 64]}, # Convection-dominated, a0\n        {'a': 0.0,  'D': 1.0, 'N_values': [32, 64, 128, 256, 512]}, # Pure diffusion\n        {'a': -400.0, 'D': 1.0, 'N_values': [8, 16, 32, 64]}, # Convection-dominated, a0\n    ]\n\n    results = []\n    for case in test_cases:\n        order_p = solve_one_case(case['a'], case['D'], case['N_values'])\n        results.append(order_p)\n\n    # Format the final output string\n    formatted_results = [f\"{p:.3f}\" for p in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While the overall order of accuracy is a key metric, the qualitative behavior of a numerical solution is equally important, especially the avoidance of non-physical oscillations. This exercise moves beyond error norms to investigate the monotonicity of a hybrid scheme by analyzing its discrete Green's function—the numerical response to a single point source. You will implement a more sophisticated hybrid scheme with a smooth blending function and quantify the resulting numerical \"overshoots\" as a function of the Peclet number $Pe$ and the blending function's smoothness, providing direct insight into the stability and boundedness properties of the discretization .",
            "id": "3331016",
            "problem": "Consider the one-dimensional, steady, linear convection–diffusion operator acting on an unknown function $u(x)$ on the unit interval $[0,1]$ with homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$. The governing equation is the strong form $$a \\frac{du}{dx} - \\nu \\frac{d^2 u}{dx^2} = s(x),$$ where $a$ is a constant convection speed, $\\nu0$ is a constant diffusion coefficient, and $s(x)$ is a source. The task is to analyze, in a discrete setting, how a hybrid differencing strategy for the convection term affects the discrete Green’s function of the operator and, in particular, to quantify the overshoot amplitude as a function of the cell Peclet number and a smoothness parameter controlling the blending of numerical fluxes.\n\nStart from the following foundational base:\n\n- Conservation statement for steady one-dimensional transport: the net convective flux plus the net diffusive flux balances the source, with the strong form given above.\n- A uniform grid with $N$ interior points is used to discretize $[0,1]$ with grid spacing $h = 1/(N+1)$, and interior node indices $i \\in \\{1,2,\\dots,N\\}$.\n- The discrete operator is constructed by finite differences: the diffusion term uses second-order central differencing, and the convection term uses a hybrid differencing strategy that smoothly blends first-order upwind and second-order central differences.\n\nDefine the cell Peclet number as $Pe = \\dfrac{a h}{\\nu}$, where $h$ is the grid spacing and $\\nu$ is the diffusion coefficient. To realize a hybrid differencing strategy, define a smooth blending weight $w(Pe;s)$ between central and upwind differencing using a logistic transition with threshold $Pe_t=2$ and smoothness parameter $s0$:\n$$ w(Pe;s) = \\frac{1}{1+\\exp\\left(\\frac{|Pe|-Pe_t}{s}\\right)}. $$\nFor the convection term at interior node $i$, for $a \\ge 0$ use the blended derivative\n$$ \\left.\\frac{du}{dx}\\right|_i \\approx (1-w) \\frac{u_i - u_{i-1}}{h} + w \\frac{u_{i+1} - u_{i-1}}{2h}, $$\nand for $a  0$ use\n$$ \\left.\\frac{du}{dx}\\right|_i \\approx (1-w) \\frac{u_{i+1} - u_{i}}{h} + w \\frac{u_{i+1} - u_{i-1}}{2h}. $$\nThe diffusion term is discretized by\n$$ -\\nu \\left.\\frac{d^2 u}{dx^2}\\right|_i \\approx -\\nu \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}. $$\nThese yield a three-point stencil for each interior node $i$, resulting in a tridiagonal matrix $\\mathbf{A}$ that maps the vector of interior nodal values to the discrete source vector. The discrete Green’s function $\\mathbf{G}$ corresponding to a unit impulse at node $i_0$ is defined as the unique solution of\n$$ \\mathbf{A} \\mathbf{G} = \\mathbf{e}_{i_0}, $$\nwhere $\\mathbf{e}_{i_0}$ is the vector with $1$ at index $i_0$ and $0$ elsewhere, and Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$ are enforced.\n\nDefine the overshoot amplitude as follows. Normalize the discrete Green’s function by its central peak $G_{i_0}$:\n$$ g_i = \\frac{G_i}{|G_{i_0}|}. $$\nFor the right side of the peak, define the base neighbor value $b_R = g_{i_0+1}$ (if $i_0+1$ exists), and the right-side overshoot amplitude candidate as $A_R = \\max\\left(0, \\max_{j \\ge i_0+2} (g_j - b_R)\\right)$. For the left side, define $b_L = g_{i_0-1}$ (if $i_0-1$ exists), and $A_L = \\max\\left(0, \\max_{j \\le i_0-2} (g_j - b_L)\\right)$. The total overshoot amplitude is the maximum of the two sides:\n$$ A_{\\text{over}} = \\max(A_L, A_R). $$\nThis definition captures secondary oscillatory maxima away from the central peak relative to the immediately adjacent value, and returns $0$ for strictly monotone decay.\n\nYour task is to implement a complete program that:\n\n1. Constructs the tridiagonal matrix $\\mathbf{A}$ for the discrete operator using the rules above, on a uniform grid with $N$ interior points, diffusion coefficient $\\nu=1$, domain length $L=1$, and Dirichlet boundary conditions $u(0)=0$ and $u(L)=0$.\n2. Uses the relation $a = \\dfrac{Pe \\, \\nu}{h}$ to realize a given $Pe$ on the chosen grid, with $\\nu=1$.\n3. Computes the discrete Green’s function $\\mathbf{G}$ for a unit impulse placed at the central interior index $i_0 = \\lfloor N/2 \\rfloor$.\n4. Computes the overshoot amplitude $A_{\\text{over}}$ as defined above.\n\nDesign the program to process the following test suite of cases, each specified by the pair $(Pe, s)$:\n\n- Case $1$: $(Pe, s) = (0.0, 0.5)$.\n- Case $2$: $(Pe, s) = (2.0, 0.1)$.\n- Case $3$: $(Pe, s) = (2.0, 1.0)$.\n- Case $4$: $(Pe, s) = (10.0, 0.1)$.\n- Case $5$: $(Pe, s) = (10.0, 0.5)$.\n- Case $6$: $(Pe, s) = (50.0, 0.1)$.\n- Case $7$: $(Pe, s) = (-10.0, 0.5)$.\n- Case $8$: $(Pe, s) = (20.0, 2.0)$.\n- Case $9$: $(Pe, s) = (0.5, 0.5)$.\n\nUse $N=101$, $\\nu=1$, $L=1$, and $i_0 = \\lfloor N/2 \\rfloor$ for all cases. All quantities are dimensionless, so no physical units are required. The required final output is a single line containing the overshoot amplitudes for the nine cases, in order, as a comma-separated list of decimal numbers rounded to six digits, enclosed in square brackets. For example, the format must be exactly like\n$$ [a_1,a_2,\\dots,a_9], $$\nwhere each $a_k$ is the overshoot amplitude for case $k$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\").",
            "solution": "The user has provided a well-defined problem in the field of computational fluid dynamics, specifically concerning the numerical analysis of a hybrid differencing scheme for the one-dimensional steady convection-diffusion equation. A validation of the problem statement confirms that it is scientifically grounded, self-contained, consistent, and objective. The task is to compute a specific metric, the \"overshoot amplitude,\" for a discrete Green's function, which quantifies the non-monotonic behavior of the numerical solution. This requires constructing a discrete operator, solving a linear system, and then applying a defined post-processing formula. The problem is valid and can be solved as stated.\n\nThe solution proceeds systematically for each test case specified by the cell Peclet number $Pe$ and the blending smoothness parameter $s$.\n\n**1. Discretization and Matrix Construction**\n\nThe governing equation is $a \\frac{du}{dx} - \\nu \\frac{d^2 u}{dx^2} = s(x)$. We discretize this equation on a uniform grid with $N$ interior nodes and spacing $h = \\frac{L}{N+1}$. For this problem, $L=1$, $N=101$, so $h = \\frac{1}{102}$. The values $\\nu=1$ and the homogeneous Dirichlet boundary conditions $u_0=0$ and $u_{N+1}=0$ are used. The discrete equation at an interior node $i$ can be written as $C_i u_{i-1} + D_i u_i + E_i u_{i+1} = s_i$, where $C_i$, $D_i$, and $E_i$ are the coefficients of the tridiagonal matrix $\\mathbf{A}$.\n\nThe convection and diffusion terms are discretized as follows:\n- Convection ($a \\frac{du}{dx}$): A hybrid of first-order upwind and second-order central differencing, blended with a weight $w(Pe;s) = \\frac{1}{1+\\exp\\left(\\frac{|Pe|-Pe_t}{s}\\right)}$, where $Pe_t=2$.\n- Diffusion ($-\\nu \\frac{d^2u}{dx^2}$): Standard second-order central differencing, $-\\nu \\frac{u_{i+1}-2u_i+u_{i-1}}{h^2}$.\n\nWe derive the matrix coefficients by combining the discretizations. Let's define $|a|$ and use the cell Peclet number $Pe = \\frac{ah}{\\nu}$. Note that $|Pe| = \\frac{|a|h}{\\nu}$.\n\nThe discrete operator at node $i$ is:\n- For $a \\ge 0$ ($Pe \\ge 0$): $a \\left[ (1-w) \\frac{u_i - u_{i-1}}{h} + w \\frac{u_{i+1} - u_{i-1}}{2h} \\right] - \\nu \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$\n- For $a  0$ ($Pe  0$): $a \\left[ (1-w) \\frac{u_{i+1} - u_{i}}{h} + w \\frac{u_{i+1} - u_{i-1}}{2h} \\right] - \\nu \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$\n\nCollecting terms for $u_{i-1}$, $u_i$, and $u_{i+1}$ yields the matrix coefficients.\nFor any $Pe$, the main diagonal coefficient is:\n$$ D_i = \\frac{|a|}{h}(1-w) + \\frac{2\\nu}{h^2} $$\nThe off-diagonal coefficients depend on the sign of $Pe$. Let us define two potential values:\n$$ V_1 = -\\frac{|a|}{h}(1-w/2) - \\frac{\\nu}{h^2} $$\n$$ V_2 = \\frac{|a|w}{2h} - \\frac{\\nu}{h^2} $$\nThen, for $Pe \\ge 0$:\n- Sub-diagonal ($C_i$): $V_1$\n- Super-diagonal ($E_i$): $V_2$\n\nAnd for $Pe  0$:\n- Sub-diagonal ($C_i$): $V_2$\n- Super-diagonal ($E_i$): $V_1$\n\nThis defines the $N \\times N$ tridiagonal matrix $\\mathbf{A}$.\n\n**2. Discrete Green's Function**\n\nThe discrete Green's function $\\mathbf{G}$ is the solution to the linear system $\\mathbf{A} \\mathbf{G} = \\mathbf{e}_{i_0}$, where $\\mathbf{e}_{i_0}$ is a vector of zeros with a $1$ at the position corresponding to the central node $i_0 = \\lfloor N/2 \\rfloor = \\lfloor 101/2 \\rfloor = 50$. In a 0-indexed array of size $N=101$, this corresponds to index $49$. This sparse, tridiagonal, and diagonally dominant system is efficiently solved using a specialized algorithm like the Thomas algorithm, available in `scipy.linalg.solve_banded`.\n\n**3. Overshoot Amplitude Calculation**\n\nThe overshoot amplitude $A_{\\text{over}}$ is calculated from the solution vector $\\mathbf{G}$ following the precise steps defined in the problem:\n1. Normalize the Green's function: $g_i = G_i / |G_{i_0}|$, where $G_{i_0}$ is the value of the solution at the impulse location (index $i_0=50$, or 0-indexed $49$).\n2. Define base neighbor values for the left and right sides of the impulse: $b_L = g_{i_0-1}$ and $b_R = g_{i_0+1}$. For $i_0=50$, these are $g_{49}$ and $g_{51}$.\n3. Calculate the left-side overshoot amplitude $A_L$. This is the maximum difference between any point $g_j$ for $j \\le i_0-2$ and the base value $b_L$, floored at $0$.\n   $$ A_L = \\max\\left(0, \\max_{j \\le i_0-2} (g_j - b_L)\\right) $$\n4. Calculate the right-side overshoot amplitude $A_R$ similarly.\n   $$ A_R = \\max\\left(0, \\max_{j \\ge i_0+2} (g_j - b_R)\\right) $$\n5. The total overshoot is the maximum of the two sides: $A_{\\text{over}} = \\max(A_L, A_R)$.\n\nThis procedure is implemented and applied to each of the nine test cases specified, with the results collected and formatted as required. The choice of $Pe$, particularly in relation to the threshold $Pe_t=2$, and the smoothness $s$ determines the value of the blending weight $w$, which in turn controls the degree of central differencing used and thus the propensity for numerical oscillations measured by $A_{\\text{over}}$.\n- For $|Pe| \\ll 2$, $w \\approx 1$ (central-dominant), but oscillations are not expected as the scheme is stable.\n- For $|Pe| \\gg 2$, a small $s$ leads to $w \\approx 0$ (upwind-dominant), suppressing oscillations. A large $s$ results in a non-zero $w$, blending in some central difference and potentially re-introducing oscillations.\n- Around $|Pe| \\approx 2$, the behavior is most sensitive to the value of $s$.\n\nThe implementation will reflect this logic to compute the required nine values of $A_{\\text{over}}$.",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    \n    # Define problem constants\n    N = 101\n    nu = 1.0\n    L = 1.0\n    \n    # Define test cases (Pe, s)\n    test_cases = [\n        (0.0, 0.5),\n        (2.0, 0.1),\n        (2.0, 1.0),\n        (10.0, 0.1),\n        (10.0, 0.5),\n        (50.0, 0.1),\n        (-10.0, 0.5),\n        (20.0, 2.0),\n        (0.5, 0.5),\n    ]\n\n    results = []\n    for Pe, s in test_cases:\n        A_over = calculate_overshoot(Pe, s, N, nu, L)\n        results.append(A_over)\n\n    # Format and print the final output\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_overshoot(Pe, s, N, nu, L):\n    \"\"\"\n    Calculates the overshoot amplitude for a given set of parameters.\n    \n    Args:\n        Pe (float): Cell Peclet number.\n        s (float): Smoothness parameter for blending.\n        N (int): Number of interior grid points.\n        nu (float): Diffusion coefficient.\n        L (float): Domain length.\n\n    Returns:\n        float: The calculated overshoot amplitude.\n    \"\"\"\n    # 1. Setup constants and derived parameters\n    h = L / (N + 1)\n    i0_1based = 50 # Per problem: floor(101/2) = 50\n    i0_idx = i0_1based - 1 # Convert to 0-based index for Python arrays\n\n    a = Pe * nu / h\n    abs_Pe = abs(Pe)\n    Pe_t = 2.0\n    \n    # 2. Calculate blending weight `w`\n    arg_exp = (abs_Pe - Pe_t) / s\n    if arg_exp  700:  # Avoid numpy.exp overflow\n        w = 0.0\n    else:\n        w = 1.0 / (1.0 + np.exp(arg_exp))\n\n    # 3. Construct the tridiagonal matrix A\n    abs_a = abs(a)\n    \n    # Coefficients for main, sub, and super diagonals based on derived formulas\n    main_val = abs_a / h * (1.0 - w) + 2.0 * nu / h**2\n    v1 = -abs_a / h * (1.0 - w / 2.0) - nu / h**2\n    v2 = abs_a * w / (2.0 * h) - nu / h**2\n    \n    if Pe = 0:\n        sub_val = v1\n        sup_val = v2\n    else:  # Pe  0\n        sub_val = v2\n        sup_val = v1\n\n    # Create the banded matrix `ab` for scipy's solver\n    # `ab` format: row 0 is super-diagonal, row 1 is main, row 2 is sub\n    ab = np.zeros((3, N))\n    ab[0, 1:] = sup_val\n    ab[1, :] = main_val\n    ab[2, :-1] = sub_val\n\n    # 4. Solve the linear system A*G = e_{i_0}\n    b = np.zeros(N)\n    b[i0_idx] = 1.0\n\n    try:\n        G = linalg.solve_banded((1, 1), ab, b)\n    except np.linalg.LinAlgError:\n        return np.nan # Should not happen for this problem's parameters\n\n    # 5. Compute the overshoot amplitude\n    G_i0 = G[i0_idx]\n    if abs(G_i0)  1e-15:\n        return np.nan # Avoid division by zero\n        \n    g = G / abs(G_i0)\n\n    b_L = g[i0_idx - 1]\n    b_R = g[i0_idx + 1]\n\n    # Left-side overshoot\n    left_indices = slice(0, i0_idx - 1)\n    max_diff_L = np.max(g[left_indices] - b_L, initial=-np.inf)\n    A_L = np.max([0, max_diff_L])\n\n    # Right-side overshoot\n    right_indices = slice(i0_idx + 2, N)\n    max_diff_R = np.max(g[right_indices] - b_R, initial=-np.inf)\n    A_R = np.max([0, max_diff_R])\n    \n    A_over = np.max([A_L, A_R])\n    \n    return A_over\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world problems often feature complex phenomena, such as sharp internal layers, where flow characteristics vary dramatically across the domain. This practice demonstrates the power of an adaptive numerical strategy using the Method of Manufactured Solutions to create a test case with a known exact solution and a challenging internal layer. By comparing fixed-blending schemes against a scheme that adapts its blending factor based on the local cell Peclet number, you will quantify the significant improvements in accuracy and robustness offered by the adaptive approach, highlighting its necessity for resolving sharp gradients without sacrificing accuracy in smoother regions of the flow .",
            "id": "3331018",
            "problem": "Consider the one-dimensional steady convection–diffusion equation on the domain $[0,1]$ with spatial coordinate $x$,\n$$u(x)\\,\\frac{d\\phi}{dx} \\;=\\; \\nu\\,\\frac{d^2\\phi}{dx^2} \\;+\\; s(x),$$\nwhere $u(x)$ is a prescribed spatially varying convection speed, $\\nu0$ is the constant diffusion coefficient, and $s(x)$ is a source term fabricated to enforce a chosen exact solution. Use Dirichlet boundary conditions $\\phi(0)=\\phi_{\\text{exact}}(0)$ and $\\phi(1)=\\phi_{\\text{exact}}(1)$.\n\nTo introduce an internal layer while keeping the problem solvable by construction, employ the Method of Manufactured Solutions. Let the exact solution be\n$$\\phi_{\\text{exact}}(x) \\;=\\; \\frac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\right),$$\nwith a small positive parameter $\\delta_\\phi$ controlling the internal layer thickness near $x=1/2$. Define the spatially varying convection speed\n$$u(x) \\;=\\; u_0 \\;+\\; u_{\\mathrm{amp}}\\,\\tanh\\!\\left(\\frac{x - 1/2}{\\delta_u}\\right),$$\nwith parameters $u_00$, $u_{\\mathrm{amp}}\\ge 0$, and $\\delta_u0$ chosen so that $u(x)\\ge 0$ for all $x\\in[0,1]$. Compute the corresponding source term $s(x)$ analytically by substituting $\\phi_{\\text{exact}}(x)$ and $u(x)$ into the governing equation.\n\nDiscretize the domain into a uniform grid of $N+1$ points with spacing $\\Delta x = 1/N$. Approximate the diffusion term by the standard second-order central difference\n$$\\frac{d^2\\phi}{dx^2}\\Big|_{x_i} \\approx \\frac{\\phi_{i+1} - 2\\phi_{i} + \\phi_{i-1}}{\\Delta x^2},$$\nand approximate the convection term with a hybrid differencing strategy that blends central differencing and upwind differencing via a local blending weight $\\beta_i\\in[0,1]$:\n- Central difference at node $i$: $$\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{CD}}_i \\approx \\frac{\\phi_{i+1} - \\phi_{i-1}}{2\\Delta x}.$$\n- Upwind difference at node $i$ for $u(x_i)\\ge 0$: $$\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{UD}}_i \\approx \\frac{\\phi_{i} - \\phi_{i-1}}{\\Delta x}.$$\n- Upwind difference at node $i$ for $u(x_i) 0$: $$\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{UD}}_i \\approx \\frac{\\phi_{i+1} - \\phi_{i}}{\\Delta x}.$$\n- Hybrid blend: $$\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{HYB}}_i \\approx (1-\\beta_i)\\,\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{CD}}_i \\;+\\; \\beta_i\\,\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{UD}}_i.$$\n\nImplement two strategies for $\\beta_i$:\n1. Fixed blending with $\\beta_i=\\beta_{\\mathrm{fixed}}$ for all $i$, where $\\beta_{\\mathrm{fixed}}$ is a constant chosen from the set $\\{0.0,\\,0.5,\\,1.0\\}$.\n2. Adaptive blending where $\\beta_i$ depends on the local cell Peclet number $P_e(x_i)$ defined by $$P_e(x_i) \\;=\\; \\frac{|u(x_i)|\\,\\Delta x}{\\nu}.$$ Use a smooth logistic-type transition centered at the classical hybrid threshold $P_e = 2$:\n$$\\beta_i \\;=\\; \\frac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{P_e(x_i) - 2}{w}\\right)\\right),$$\nwith a positive steepness parameter $w$ (use $w=0.5$).\n\nAssemble the resulting linear system for the interior unknowns $\\{\\phi_i\\}_{i=1}^{N-1}$ and enforce the Dirichlet boundary conditions using the exact solution values at $x=0$ and $x=1$. Solve the linear system to obtain the discrete approximation $\\phi^{\\mathrm{num}}$.\n\nCompute the discretization error by comparing $\\phi^{\\mathrm{num}}$ to $\\phi_{\\text{exact}}$ on the grid, and report the following error norms:\n- The discrete $L_2$ norm: $$\\lVert e \\rVert_{L_2} \\;=\\; \\left(\\sum_{i=0}^{N} \\left(\\phi^{\\mathrm{num}}_i - \\phi_{\\text{exact}}(x_i)\\right)^2 \\,\\Delta x\\right)^{1/2}.$$\n- The discrete $L_\\infty$ norm: $$\\lVert e \\rVert_{L_\\infty} \\;=\\; \\max_{0\\le i \\le N}\\left|\\phi^{\\mathrm{num}}_i - \\phi_{\\text{exact}}(x_i)\\right|.$$\n\nFor each test case, compute the improvement factors of the adaptive strategy relative to each fixed $\\beta_{\\mathrm{fixed}}\\in\\{0.0,\\,0.5,\\,1.0\\}$, defined as the ratio of the fixed strategy error to the adaptive strategy error:\n- $I_{2}(\\beta_{\\mathrm{fixed}}) = \\lVert e \\rVert_{L_2}^{\\mathrm{fixed}} \\big/ \\lVert e \\rVert_{L_2}^{\\mathrm{adaptive}}$.\n- $I_{\\infty}(\\beta_{\\mathrm{fixed}}) = \\lVert e \\rVert_{L_\\infty}^{\\mathrm{fixed}} \\big/ \\lVert e \\rVert_{L_\\infty}^{\\mathrm{adaptive}}$.\n\nYour program must implement the above and output, for each test case, a list of six floating-point numbers arranged as\n$$\\left[ I_{2}(0.0),\\, I_{\\infty}(0.0),\\, I_{2}(0.5),\\, I_{\\infty}(0.5),\\, I_{2}(1.0),\\, I_{\\infty}(1.0) \\right].$$\nAggregate the results for all test cases into a single list, printed on one line in the exact format specified below.\n\nTest Suite:\nUse the following $4$ test cases, each specified by the tuple $(N,\\,\\nu,\\,u_0,\\,u_{\\mathrm{amp}},\\,\\delta_\\phi,\\,\\delta_u)$:\n- Case $1$: $(200,\\,0.001,\\,1.0,\\,0.9,\\,0.02,\\,0.02)$.\n- Case $2$: $(200,\\,0.01,\\,1.0,\\,0.5,\\,0.05,\\,0.05)$.\n- Case $3$: $(400,\\,0.0005,\\,0.5,\\,0.49,\\,0.01,\\,0.01)$.\n- Case $4$: $(100,\\,0.001,\\,0.0,\\,0.0,\\,0.02,\\,0.02)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list of lists, each inner list corresponding to one test case, in the form\n$$\\texttt{[[r_{1,1},r_{1,2},r_{1,3},r_{1,4},r_{1,5},r_{1,6}],[r_{2,1},\\dots,r_{2,6}],[r_{3,1},\\dots,r_{3,6}],[r_{4,1},\\dots,r_{4,6}]]}$$\nwhere each $r_{k,j}$ is a floating-point number.",
            "solution": "The problem is valid. It presents a well-posed, scientifically grounded task in the field of computational fluid dynamics, specifically concerning the numerical solution of the one-dimensional steady convection-diffusion equation. All parameters, equations, and boundary conditions are explicitly defined, creating a self-contained and verifiable problem. The use of the Method of Manufactured Solutions is a standard technique for code verification and numerical scheme analysis. The test cases provided are consistent with the problem's constraints, including the edge case of pure diffusion, which serves as a valuable check.\n\nThe solution process involves several steps: derivation of the analytical source term, discretization of the governing partial differential equation into a system of linear algebraic equations, solving the system for different numerical schemes, and calculating the specified error metrics and improvement factors.\n\nFirst, we derive the source term $s(x)$ using the Method of Manufactured Solutions. The governing equation is\n$$u(x)\\,\\frac{d\\phi}{dx} \\;=\\; \\nu\\,\\frac{d^2\\phi}{dx^2} \\;+\\; s(x)$$\nThe source term is therefore $s(x) = u(x)\\frac{d\\phi}{dx} - \\nu\\frac{d^2\\phi}{dx^2}$. We require the first and second derivatives of the manufactured solution $\\phi_{\\text{exact}}(x) = \\frac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\right)$. Let $\\theta_\\phi(x) = \\frac{x - 1/2}{\\delta_\\phi}$.\n\nThe first derivative is:\n$$ \\frac{d\\phi_{\\text{exact}}}{dx} = \\frac{d}{dx}\\left[\\frac{1}{2}(1 + \\tanh(\\theta_\\phi(x)))\\right] = \\frac{1}{2} \\text{sech}^2(\\theta_\\phi(x)) \\cdot \\frac{d\\theta_\\phi}{dx} = \\frac{1}{2\\delta_\\phi}\\text{sech}^2\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right) $$\n\nThe second derivative is:\n$$ \\frac{d^2\\phi_{\\text{exact}}}{dx^2} = \\frac{d}{dx}\\left[\\frac{1}{2\\delta_\\phi}\\text{sech}^2(\\theta_\\phi(x))\\right] = \\frac{1}{2\\delta_\\phi} \\cdot \\left(-2\\,\\text{sech}^2(\\theta_\\phi(x))\\tanh(\\theta_\\phi(x))\\right) \\cdot \\frac{d\\theta_\\phi}{dx} $$\n$$ \\frac{d^2\\phi_{\\text{exact}}}{dx^2} = -\\frac{1}{\\delta_\\phi^2}\\text{sech}^2\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\tanh\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right) $$\n\nSubstituting these into the expression for $s(x)$, we obtain the analytical source term:\n$$ s(x) = u(x)\\left[\\frac{1}{2\\delta_\\phi}\\text{sech}^2\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\right] - \\nu\\left[-\\frac{1}{\\delta_\\phi^2}\\text{sech}^2\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\tanh\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\right] $$\n$$ s(x) = \\frac{1}{\\delta_\\phi} \\text{sech}^2\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right) \\left[ \\frac{u(x)}{2} + \\frac{\\nu}{\\delta_\\phi}\\tanh\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right) \\right] $$\nwhere $u(x) = u_0 + u_{\\mathrm{amp}}\\,\\tanh\\!\\left(\\frac{x - 1/2}{\\delta_u}\\right)$.\n\nNext, we discretize the domain $[0,1]$ into $N+1$ points $x_i = i\\Delta x$ for $i=0, 1, \\dots, N$, with grid spacing $\\Delta x = 1/N$. The governing equation at an interior node $x_i$ is approximated as:\n$$ u_i \\left(\\frac{d\\phi}{dx}\\right)_i - \\nu \\left(\\frac{d^2\\phi}{dx^2}\\right)_i = s_i $$\nwhere $u_i = u(x_i)$, $s_i = s(x_i)$, and $\\phi_i$ is the numerical approximation to $\\phi(x_i)$.\n\nThe diffusion term is approximated by a second-order central difference:\n$$ \\left(\\frac{d^2\\phi}{dx^2}\\right)_i \\approx \\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{\\Delta x^2} $$\n\nThe convection term is approximated using a hybrid blending of central and upwind differences. Given that the problem parameters ensure $u(x_i) \\ge 0$, we use the upwind scheme for non-negative velocity.\n$$ \\left(\\frac{d\\phi}{dx}\\right)_i \\approx (1-\\beta_i)\\left(\\frac{\\phi_{i+1} - \\phi_{i-1}}{2\\Delta x}\\right) + \\beta_i\\left(\\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}\\right) $$\nRearranging this to group terms by $\\phi_j$:\n$$ \\left(\\frac{d\\phi}{dx}\\right)_i \\approx \\frac{1}{2\\Delta x}\\left[ (1-\\beta_i)\\phi_{i+1} + 2\\beta_i\\phi_i - (1+\\beta_i)\\phi_{i-1} \\right] $$\n\nSubstituting these approximations into the governing equation and rearranging yields a linear algebraic equation for each interior node $i \\in \\{1, \\dots, N-1\\}$:\n$$ \\phi_{i-1}\\left(-\\frac{u_i(1+\\beta_i)}{2\\Delta x} - \\frac{\\nu}{\\Delta x^2}\\right) + \\phi_i\\left(\\frac{u_i \\beta_i}{\\Delta x} + \\frac{2\\nu}{\\Delta x^2}\\right) + \\phi_{i+1}\\left(\\frac{u_i(1-\\beta_i)}{2\\Delta x} - \\frac{\\nu}{\\Delta x^2}\\right) = s_i $$\nThis can be written in the standard form $C_{W,i}\\phi_{i-1} + C_{P,i}\\phi_i + C_{E,i}\\phi_{i+1} = s_i$, where:\n$$ C_{W,i} = -\\frac{u_i(1+\\beta_i)}{2\\Delta x} - \\frac{\\nu}{\\Delta x^2} \\quad (\\text{West coefficient}) $$\n$$ C_{P,i} = \\frac{u_i \\beta_i}{\\Delta x} + \\frac{2\\nu}{\\Delta x^2} \\quad (\\text{Point coefficient}) $$\n$$ C_{E,i} = \\frac{u_i(1-\\beta_i)}{2\\Delta x} - \\frac{\\nu}{\\Delta x^2} \\quad (\\text{East coefficient}) $$\n\nThe blending factor $\\beta_i$ is determined by one of two strategies:\n$1$. Fixed blending: $\\beta_i = \\beta_{\\mathrm{fixed}}$, where $\\beta_{\\mathrm{fixed}}$ is a constant ($0.0$, $0.5$, or $1.0$).\n$2$. Adaptive blending: $\\beta_i$ is a function of the local cell Peclet number $P_e(x_i) = \\frac{|u(x_i)|\\Delta x}{\\nu}$. Using the specified logistic function with steepness parameter $w=0.5$:\n$$ \\beta_i = \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{P_e(x_i) - 2}{0.5}\\right)\\right) $$\n\nThese equations for $i=1, \\dots, N-1$ form a tridiagonal linear system $A\\mathbf{\\phi}_{\\text{int}} = \\mathbf{b}$, where $\\mathbf{\\phi}_{\\text{int}} = [\\phi_1, \\phi_2, \\dots, \\phi_{N-1}]^T$ is the vector of unknown interior nodal values. The matrix $A$ has dimensions $(N-1) \\times (N-1)$.\n\nThe Dirichlet boundary conditions $\\phi_0 = \\phi_{\\text{exact}}(0)$ and $\\phi_N = \\phi_{\\text{exact}}(1)$ are known. Their contributions are moved to the right-hand side of the equations for $i=1$ and $i=N-1$:\nFor $i=1$: $C_{P,1}\\phi_1 + C_{E,1}\\phi_2 = s_1 - C_{W,1}\\phi_0$\nFor $i=N-1$: $C_{W,N-1}\\phi_{N-2} + C_{P,N-1}\\phi_{N-1} = s_{N-1} - C_{E,N-1}\\phi_N$\n\nThis tridiagonal system is solved to find $\\mathbf{\\phi}_{\\text{int}}$. The full numerical solution vector is then $\\phi^{\\mathrm{num}} = [\\phi_0, \\phi_1, \\dots, \\phi_{N-1}, \\phi_N]^T$.\n\nThe error is calculated by comparing $\\phi^{\\mathrm{num}}$ to the exact solution $\\phi_{\\text{exact}}$ evaluated at the grid points. The discrete $L_2$ and $L_\\infty$ error norms are computed as specified. Finally, the improvement factors, which quantify the relative performance of the adaptive scheme, are calculated as the ratio of an error norm from a fixed-$\\beta$ scheme to the corresponding norm from the adaptive scheme.\n$$I_{2}(\\beta_{\\mathrm{fixed}}) = \\frac{\\lVert e \\rVert_{L_2}^{\\mathrm{fixed}}}{\\lVert e \\rVert_{L_2}^{\\mathrm{adaptive}}}, \\quad I_{\\infty}(\\beta_{\\mathrm{fixed}}) = \\frac{\\lVert e \\rVert_{L_\\infty}^{\\mathrm{fixed}}}{\\lVert e \\rVert_{L_\\infty}^{\\mathrm{adaptive}}}$$\nFor test case $4$, where $u(x)=0$, the convection term vanishes. Consequently, all differencing schemes produce identical results, and all improvement factors are expected to be exactly $1.0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (200, 0.001, 1.0, 0.9, 0.02, 0.02),\n        (200, 0.01, 1.0, 0.5, 0.05, 0.05),\n        (400, 0.0005, 0.5, 0.49, 0.01, 0.01),\n        (100, 0.001, 0.0, 0.0, 0.02, 0.02),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, nu, u0, u_amp, delta_phi, delta_u = case\n        \n        # Calculate errors for the four schemes\n        err_fixed_00 = solve_case(N, nu, u0, u_amp, delta_phi, delta_u, 'fixed', beta_fixed=0.0)\n        err_fixed_05 = solve_case(N, nu, u0, u_amp, delta_phi, delta_u, 'fixed', beta_fixed=0.5)\n        err_fixed_10 = solve_case(N, nu, u0, u_amp, delta_phi, delta_u, 'fixed', beta_fixed=1.0)\n        err_adaptive = solve_case(N, nu, u0, u_amp, delta_phi, delta_u, 'adaptive')\n\n        l2_err_adapt, linf_err_adapt = err_adaptive\n\n        # Calculate improvement factors\n        # For stability, if adaptive error is zero, ratio is 1 (as fixed error must also be zero).\n        # This handles the u=0 case where all errors are identical.\n        I2_00 = err_fixed_00[0] / l2_err_adapt if l2_err_adapt  0 else 1.0\n        Iinf_00 = err_fixed_00[1] / linf_err_adapt if linf_err_adapt  0 else 1.0\n        \n        I2_05 = err_fixed_05[0] / l2_err_adapt if l2_err_adapt  0 else 1.0\n        Iinf_05 = err_fixed_05[1] / linf_err_adapt if linf_err_adapt  0 else 1.0\n        \n        I2_10 = err_fixed_10[0] / l2_err_adapt if l2_err_adapt  0 else 1.0\n        Iinf_10 = err_fixed_10[1] / linf_err_adapt if linf_err_adapt  0 else 1.0\n\n        case_results = [I2_00, Iinf_00, I2_05, Iinf_05, I2_10, Iinf_10]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"{all_results}\")\n\ndef solve_case(N, nu, u0, u_amp, delta_phi, delta_u, beta_strategy, beta_fixed=None):\n    \"\"\"\n    Solves the 1D convection-diffusion problem for a single strategy.\n    \n    Args:\n        N, nu, u0, u_amp, delta_phi, delta_u: Problem parameters.\n        beta_strategy (str): 'fixed' or 'adaptive'.\n        beta_fixed (float, optional): Value for fixed blending.\n\n    Returns:\n        A tuple (l2_error, linf_error).\n    \"\"\"\n    # 1. Setup grid\n    x = np.linspace(0.0, 1.0, N + 1)\n    dx = 1.0 / N\n\n    # 2. Define analytical functions\n    # Using '1 - tanh^2' for sech^2 is more numerically stable than '1/cosh^2'\n    def phi_exact_func(x_):\n        theta = (x_ - 0.5) / delta_phi\n        return 0.5 * (1.0 + np.tanh(theta))\n\n    def u_func(x_):\n        theta = (x_ - 0.5) / delta_u\n        return u0 + u_amp * np.tanh(theta)\n\n    def s_func(x_):\n        u_val = u_func(x_)\n        \n        theta_phi = (x_ - 0.5) / delta_phi\n        tanh_phi = np.tanh(theta_phi)\n        sech2_phi = 1.0 - tanh_phi**2\n        \n        dphi_dx = 0.5 * sech2_phi / delta_phi\n        d2phi_dx2 = -sech2_phi * tanh_phi / delta_phi**2\n        \n        return u_val * dphi_dx - nu * d2phi_dx2\n\n    # 3. Evaluate exact solution, velocity, and source at grid points\n    phi_exact_grid = phi_exact_func(x)\n    u_grid = u_func(x)\n    s_grid = s_func(x)\n\n    # 4. Determine beta values for interior nodes\n    beta_vals_interior = np.zeros(N - 1)\n    i_int = np.arange(1, N) # Indices of interior points\n    if beta_strategy == 'fixed':\n        beta_vals_interior[:] = beta_fixed\n    else: # adaptive\n        w = 0.5\n        # Since u(x)=0, abs is not strictly necessary but good practice\n        pe = np.abs(u_grid[i_int]) * dx / nu\n        beta_vals_interior = 0.5 * (1.0 + np.tanh((pe - 2.0) / w))\n\n    # 5. Assemble banded matrix A and vector b for interior nodes\n    num_unknowns = N - 1\n    # ab[0,:]: upper\n    # ab[1,:]: main\n    # ab[2,:]: lower\n    ab = np.zeros((3, num_unknowns))\n    b = np.zeros(num_unknowns)\n    \n    ui = u_grid[i_int]\n    betai = beta_vals_interior\n\n    # Calculate coefficients for all interior nodes at once\n    CW = -ui * (1.0 + betai) / (2.0 * dx) - nu / dx**2\n    CP = ui * betai / dx + 2.0 * nu / dx**2\n    CE = ui * (1.0 - betai) / (2.0 * dx) - nu / dx**2\n\n    # Populate banded matrix\n    ab[0, 1:] = CE[:-1]       # Upper diagonal\n    ab[1, :] = CP             # Main diagonal\n    ab[2, :-1] = CW[1:]       # Lower diagonal\n\n    # Populate RHS vector b\n    b[:] = s_grid[i_int]\n    \n    # Apply boundary conditions\n    b[0] -= CW[0] * phi_exact_grid[0]      # At i=1\n    b[-1] -= CE[-1] * phi_exact_grid[-1]   # At i=N-1\n    \n    # 6. Solve the system\n    phi_interior = solve_banded((1, 1), ab, b)\n\n    # 7. Construct full numerical solution vector\n    phi_num = np.zeros(N + 1)\n    phi_num[0] = phi_exact_grid[0]\n    phi_num[-1] = phi_exact_grid[-1]\n    phi_num[1:N] = phi_interior\n\n    # 8. Calculate error norms\n    error = phi_num - phi_exact_grid\n    l2_error = np.sqrt(np.sum(error**2) * dx)\n    linf_error = np.max(np.abs(error))\n\n    return l2_error, linf_error\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}