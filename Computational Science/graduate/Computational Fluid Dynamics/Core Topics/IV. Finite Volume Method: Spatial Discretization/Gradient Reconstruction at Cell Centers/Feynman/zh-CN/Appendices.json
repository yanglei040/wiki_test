{
    "hands_on_practices": [
        {
            "introduction": "在分析梯度重构的误差之前，我们必须首先确保我们使用的方法本身是基本正确的。一项至关重要的测试是验证其在坐标变换下的行为。这项实践将指导你实现一个最小二乘梯度方法，并验证它是否正确遵循仿射变换定律，从而确保其量纲一致性和稳健性。",
            "id": "3324929",
            "problem": "您需要实现并测试一个适用于计算流体动力学 (CFD) 的、在单元中心进行的梯度重构程序。该重构必须在仿射坐标变换下满足量纲一致性。请从以下基本原理出发：\n\n- 标量场的梯度由其一阶泰勒展开的线性部分定义：对于一个标量场 $f(\\mathbf{x})$ 和一个点 $\\mathbf{x}_0$，当 $\\mathbf{r}$ 很小时，有 $f(\\mathbf{x}_0 + \\mathbf{r}) \\approx f(\\mathbf{x}_0) + \\nabla f(\\mathbf{x}_0) \\cdot \\mathbf{r}$。\n- 在仿射坐标变换 $\\mathbf{x}' = A \\mathbf{x} + \\mathbf{b}$（其中 $A \\in \\mathbb{R}^{2 \\times 2}$ 可逆，$\\mathbf{b} \\in \\mathbb{R}^2$）下，代表相同物理场的变换后标量场为 $f'(\\mathbf{x}') = f(A^{-1}(\\mathbf{x}' - \\mathbf{b}))$。根据链式法则，梯度之间的关系为 $\\nabla_{\\mathbf{x}'} f'(\\mathbf{x}') = A^{-\\top} \\nabla_{\\mathbf{x}} f(\\mathbf{x})$，其中 $\\mathbf{x} = A^{-1}(\\mathbf{x}' - \\mathbf{b})$。\n- 最小二乘拟合：给定围绕单元中心 $\\mathbf{x}_0$ 的邻居偏移量 $\\{\\mathbf{r}_i\\}_{i=1}^m$ 和标量值 $f_i = f(\\mathbf{x}_0 + \\mathbf{r}_i)$，通过最小化线性模型 $f(\\mathbf{x}_0 + \\mathbf{r}_i) \\approx f(\\mathbf{x}_0) + \\mathbf{g} \\cdot \\mathbf{r}_i$ 的残差平方和来重构 $\\mathbf{x}_0$ 处的梯度 $\\mathbf{g}$。即，最小化 $\\sum_{i=1}^m \\left(\\mathbf{g} \\cdot \\mathbf{r}_i - (f_i - f_0)\\right)^2$，其中 $f_0 = f(\\mathbf{x}_0)$。\n\n您的任务是：\n\n- 如上所述，在二维空间中实现一个在目标函数中使用相等权重的、以单元为中心的最小二乘梯度重构。\n- 开发一个量纲一致性检查，以验证梯度的仿射变换定律。具体来说，对于每个仿射变换 $(A,\\mathbf{b})$，您必须：\n  1. 定义一个线性标量场 $f(\\mathbf{x}) = c_0 + \\mathbf{c}^\\top \\mathbf{x}$，其系数 $c_0 \\in \\mathbb{R}$ 和 $\\mathbf{c} \\in \\mathbb{R}^2$ 为固定值。\n  2. 构建一个围绕 $\\mathbf{x}_0$ 的邻居偏移量模板 $\\{\\mathbf{r}_i\\}_{i=1}^m$。\n  3. 从原始数据 $\\{\\mathbf{r}_i, f(\\mathbf{x}_0 + \\mathbf{r}_i)\\}$ 计算重构梯度 $\\mathbf{g}$。\n  4. 通过 $\\mathbf{x}' = A \\mathbf{x} + \\mathbf{b}$ 进行坐标变换，生成变换后的数据 $\\{\\mathbf{r}_i' = A \\mathbf{r}_i, f'(\\mathbf{x}_0' + \\mathbf{r}_i')\\}$（其中 $f'(\\mathbf{x}') = f(A^{-1}(\\mathbf{x}' - \\mathbf{b}))$ 且 $\\mathbf{x}_0' = A \\mathbf{x}_0 + \\mathbf{b}$），从变换后的数据重构梯度 $\\mathbf{g}'$，并验证关系 $\\mathbf{g}' \\approx A^{-\\top} \\mathbf{g}$。\n  5. 通过相对误差 $e = \\|\\mathbf{g}' - A^{-\\top} \\mathbf{g}\\|_2 / (\\|A^{-\\top} \\mathbf{g}\\|_2 + \\varepsilon)$ 来量化检查结果，其中 $\\varepsilon = 10^{-15}$。\n\n使用以下固定参数和测试套件。所有角度必须以弧度表示。\n\n- 维度和模板：\n  - 空间维度为 $2$。\n  - 单元中心为 $\\mathbf{x}_0 = (0, 0)$。\n  - 邻居偏移量为 8 个向量 $\\{(1,0), (-1,0), (0,1), (0,-1), (1,1), (1,-1), (-1,1), (-1,-1)\\}$。\n- 线性场系数：\n  - 使用 $c_0 = 0.2$ 和 $\\mathbf{c} = (1.3, -0.4)$。\n- 待测试的仿射变换 $(A,\\mathbf{b})$：\n  1. 旋转角度 $\\theta = 0.7$：$$A = \\begin{bmatrix} \\cos(\\theta) & -\\sin(\\theta) \\\\ \\sin(\\theta) & \\cos(\\theta) \\end{bmatrix}$$, $\\mathbf{b} = (0.3, -0.2)$。\n  2. 对角缩放：$$A = \\mathrm{diag}(2.5, 0.5)$$, $\\mathbf{b} = (-1.0, 2.0)$。\n  3. 剪切：$$A = \\begin{bmatrix} 1 & 0.8 \\\\ 0 & 1 \\end{bmatrix}$$, $\\mathbf{b} = (0.1, 0.1)$。\n  4. 极端各向异性：$$A = \\begin{bmatrix} 0.01 & 0 \\\\ 0 & 50 \\end{bmatrix}$$, $\\mathbf{b} = (-2.0, 3.0)$。\n  5. 随机线性变换：按如下方式生成另外 $3$ 个可逆矩阵 $A$ 和平移向量 $\\mathbf{b}$。使用种子为 $2025$ 的伪随机数生成器。对于每个矩阵，从 $[-1,1]$ 上的均匀分布中独立抽样 $A$ 的元素，直到获得一个行列式绝对值至少为 $0.1$ 的矩阵。对于每个 $\\mathbf{b}$，从 $[-1,1]$ 上的均匀分布中独立抽样其元素。使用抽样得到的 $(A,\\mathbf{b})$ 对构成三个额外的测试。\n\n对于每个测试，计算上文定义的相对误差 $e$。您的程序应生成单行输出，其中包含按上述测试顺序列出的 $7$ 个相对误差，格式为方括号内以逗号分隔的列表（例如，“[e1,e2,e3,e4,e5,e6,e7]”）。角度必须是弧度，本问题不涉及其他物理单位。最终答案必须以浮点数形式打印，不带百分号，也不带任何附加文本。\n\n解决方案必须是自包含的，且不得需要任何外部输入或文件。程序必须是完整且可运行的。",
            "solution": "已确认所提供问题陈述的有效性。这是一个适定且科学严谨的计算流体动力学数值方法练习。我们现在将提供一个完整的解决方案。\n\n该问题要求实现并验证一种二维的、以单元为中心的最小二乘梯度重构方法。核心任务是证明该方法具有量纲一致性，即它能正确遵循梯度向量场在仿射坐标变换下的变换属性。\n\n首先，我们将梯度重构过程形式化。标量场 $f(\\mathbf{x})$ 在点 $\\mathbf{x}_0$ 处的梯度 $\\nabla f$ 通过一阶泰勒展开定义，$f(\\mathbf{x}_0 + \\mathbf{r}) \\approx f(\\mathbf{x}_0) + \\nabla f(\\mathbf{x}_0) \\cdot \\mathbf{r}$。给定一组包含 $m$ 个邻近点的位置向量 $\\mathbf{x}_i = \\mathbf{x}_0 + \\mathbf{r}_i$ 及相应的标量值 $f_i = f(\\mathbf{x}_i)$，我们旨在找到一个向量 $\\mathbf{g}$ 来最佳逼近 $\\nabla f(\\mathbf{x}_0)$。最小二乘法通过最小化残差平方和来实现这一目标：\n$$\nS(\\mathbf{g}) = \\sum_{i=1}^m \\left( f(\\mathbf{x}_i) - (f(\\mathbf{x}_0) + \\mathbf{g} \\cdot \\mathbf{r}_i) \\right)^2 = \\sum_{i=1}^m (\\Delta f_i - \\mathbf{g} \\cdot \\mathbf{r}_i)^2\n$$\n其中 $\\Delta f_i = f_i - f_0$ 表示邻居 $i$ 与中心点 $\\mathbf{x}_0$ 之间的标量值之差。为最小化 $S(\\mathbf{g})$，我们将其关于 $\\mathbf{g} = (g_x, g_y)^\\top$ 各分量的偏导数置为零。这会得到一个称为正规方程的线性方程组。该系统可以紧凑地写成矩阵形式：\n$$\n(R^\\top R) \\mathbf{g} = R^\\top \\Delta\\mathbf{f}\n$$\n在这里，$R$ 是一个 $m \\times 2$ 矩阵，其中每一行是邻居偏移向量 $\\mathbf{r}_i^\\top$ 的转置，而 $\\Delta\\mathbf{f}$ 是一个包含标量差 $\\Delta f_i$ 的 $m$ 维列向量。\n\n我们定义几何矩阵 $M = R^\\top R$ 和右侧向量 $\\mathbf{V} = R^\\top \\Delta\\mathbf{f}$。然后通过求解 $2 \\times 2$ 线性系统 $M\\mathbf{g} = \\mathbf{V}$ 来找到梯度。$M$ 和 $\\mathbf{V}$ 的分量具体如下：\n$$\nM = \\sum_{i=1}^m \\mathbf{r}_i \\mathbf{r}_i^\\top = \\begin{bmatrix} \\sum_{i=1}^m r_{ix}^2 & \\sum_{i=1}^m r_{ix} r_{iy} \\\\ \\sum_{i=1}^m r_{ix} r_{iy} & \\sum_{i=1}^m r_{iy}^2 \\end{bmatrix}\n$$\n$$\n\\mathbf{V} = \\sum_{i=1}^m \\Delta f_i \\mathbf{r}_i = \\begin{bmatrix} \\sum_{i=1}^m \\Delta f_i r_{ix} \\\\ \\sum_{i=1}^m \\Delta f_i r_{iy} \\end{bmatrix}\n$$\n对于问题中给定的 $m=8$ 个邻居的特定模板 $\\{(1,0), (-1,0), (0,1), (0,-1), (1,1), (1,-1), (-1,1), (-1,-1)\\}$，几何矩阵 $M$ 为：\n$\\sum r_{ix}^2 = 1+1+0+0+1+1+1+1 = 6$\n$\\sum r_{iy}^2 = 0+0+1+1+1+1+1+1 = 6$\n$\\sum r_{ix}r_{iy} = 0+0+0+0+1-1-1+1 = 0$\n所以，$M = \\begin{bmatrix} 6 & 0 \\\\ 0 & 6 \\end{bmatrix} = 6I$，其中 $I$ 是 $2 \\times 2$ 单位矩阵。$M$ 的可逆性保证了 $\\mathbf{g}$ 的唯一解。\n\n问题指定使用线性标量场 $f(\\mathbf{x}) = c_0 + \\mathbf{c}^\\top \\mathbf{x}$ 进行测试。该场的真实梯度在任何地方都是常数：$\\nabla f = \\mathbf{c}$。对于该场，标量差为 $\\Delta f_i = f(\\mathbf{x}_0+\\mathbf{r}_i) - f(\\mathbf{x}_0) = (c_0 + \\mathbf{c}^\\top(\\mathbf{x}_0+\\mathbf{r}_i)) - (c_0 + \\mathbf{c}^\\top\\mathbf{x}_0) = \\mathbf{c}^\\top\\mathbf{r}_i$。右侧向量变为：\n$$\n\\mathbf{V} = \\sum_{i=1}^m (\\mathbf{c}^\\top\\mathbf{r}_i) \\mathbf{r}_i = \\sum_{i=1}^m (\\mathbf{r}_i \\mathbf{r}_i^\\top) \\mathbf{c} = \\left(\\sum_{i=1}^m \\mathbf{r}_i \\mathbf{r}_i^\\top\\right) \\mathbf{c} = M\\mathbf{c}\n$$\n因此，重构梯度为 $\\mathbf{g} = M^{-1}\\mathbf{V} = M^{-1}(M\\mathbf{c}) = \\mathbf{c}$。这证明了对于线性标量场，在假定完美算术运算的情况下，最小二乘法能精确重构梯度。\n\n验证的核心是检验在仿射变换 $\\mathbf{x}' = A\\mathbf{x} + \\mathbf{b}$ 下的行为。两个坐标系中的梯度向量通过 $\\mathbf{g}' = A^{-\\top}\\mathbf{g}$ 相关联。我们的数值格式必须再现这种关系。\n在变换后的坐标中，新的中心是 $\\mathbf{x}_0' = A\\mathbf{x}_0 + \\mathbf{b}$，新的邻居偏移量是 $\\mathbf{r}_i' = (A(\\mathbf{x}_0+\\mathbf{r}_i)+\\mathbf{b}) - (A\\mathbf{x}_0+\\mathbf{b}) = A\\mathbf{r}_i$。\n变换后的标量场是 $f'(\\mathbf{x}') = f(A^{-1}(\\mathbf{x}'-\\mathbf{b}))$。新系统中的标量差 $\\Delta f'_i = f'(\\mathbf{x}_0'+\\mathbf{r}_i') - f'(\\mathbf{x}_0')$ 是不变的：\n$\\Delta f'_i = f(A^{-1}((\\mathbf{x}_0'+\\mathbf{r}_i') - \\mathbf{b})) - f(A^{-1}(\\mathbf{x}_0' - \\mathbf{b})) = f(\\mathbf{x}_0+\\mathbf{r}_i) - f(\\mathbf{x}_0) = \\Delta f_i$。\n\n我们现在在带撇号的坐标系中组装最小二乘系统。新的几何矩阵是：\n$$\nM' = \\sum_{i=1}^m \\mathbf{r}_i' (\\mathbf{r}_i')^\\top = \\sum_{i=1}^m (A\\mathbf{r}_i)(A\\mathbf{r}_i)^\\top = \\sum_{i=1}^m A\\mathbf{r}_i\\mathbf{r}_i^\\top A^\\top = A \\left(\\sum_{i=1}^m \\mathbf{r}_i\\mathbf{r}_i^\\top\\right) A^\\top = AMA^\\top\n$$\n新的右侧向量是：\n$$\n\\mathbf{V}' = \\sum_{i=1}^m \\Delta f'_i \\mathbf{r}_i' = \\sum_{i=1}^m \\Delta f_i (A\\mathbf{r}_i) = A \\left(\\sum_{i=1}^m \\Delta f_i \\mathbf{r}_i\\right) = A\\mathbf{V}\n$$\n变换后系统中的重构梯度 $\\mathbf{g}'$ 是 $M'\\mathbf{g}' = \\mathbf{V}'$ 的解：\n$$\n\\mathbf{g}' = (M')^{-1}\\mathbf{V}' = (AMA^\\top)^{-1}(A\\mathbf{V}) = (A^\\top)^{-1}M^{-1}A^{-1}A\\mathbf{V} = A^{-\\top}M^{-1}\\mathbf{V} = A^{-\\top}\\mathbf{g}\n$$\n该推导正式证明了最小二乘梯度重构方法是量纲一致的；它遵循梯度的仿射变换定律。数值实现应通过为所有指定的变换 $(A, \\mathbf{b})$ 生成一个量级为机器精度的相对误差 $e = \\|\\mathbf{g}' - A^{-\\top} \\mathbf{g}\\|_2 / (\\|A^{-\\top} \\mathbf{g}\\|_2 + \\varepsilon)$ 来证实这一点。所提供的测试用例，包括旋转、缩放、剪切、各向异性和随机变换，用于在各种几何畸变下严格测试此属性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef reconstruct_gradient(r_offsets, df_values):\n    \"\"\"\n    Computes the 2D gradient using least-squares reconstruction.\n\n    Args:\n        r_offsets (np.ndarray): An (m, 2) array of m neighbor offset vectors.\n        df_values (np.ndarray): An (m,) array of scalar differences f_i - f_0.\n\n    Returns:\n        np.ndarray: The reconstructed 2D gradient vector (g_x, g_y).\n    \"\"\"\n    # The normal equations are (R^T R) g = R^T df\n    # where R is the matrix of row vectors r_i^T.\n    # M = R^T R = sum(r_i * r_i^T)\n    # V = R^T df = sum(df_i * r_i)\n    M = r_offsets.T @ r_offsets\n    V = r_offsets.T @ df_values\n    \n    # Solve the 2x2 system M g = V for g\n    g = np.linalg.solve(M, V)\n    return g\n\ndef solve():\n    \"\"\"\n    Main function to run the dimensional consistency check for gradient reconstruction.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    x0 = np.array([0.0, 0.0])\n    r_neighbors = np.array([\n        [1.0, 0.0], [-1.0, 0.0], [0.0, 1.0], [0.0, -1.0],\n        [1.0, 1.0], [1.0, -1.0], [-1.0, 1.0], [-1.0, -1.0]\n    ])\n    c0 = 0.2\n    c = np.array([1.3, -0.4])\n    epsilon = 1e-15\n\n    # Define the linear scalar field f(x) = c0 + c . x\n    # The exact gradient is c for all x.\n    scalar_field = lambda x_vec: c0 + c @ x_vec\n\n    # Define the test cases for affine transforms (A, b)\n    test_cases = []\n\n    # Test Case 1: Rotation\n    theta = 0.7  # radians\n    A1 = np.array([\n        [np.cos(theta), -np.sin(theta)],\n        [np.sin(theta),  np.cos(theta)]\n    ])\n    b1 = np.array([0.3, -0.2])\n    test_cases.append((\"Rotation\", A1, b1))\n\n    # Test Case 2: Diagonal scaling\n    A2 = np.array([[2.5, 0.0], [0.0, 0.5]])\n    b2 = np.array([-1.0, 2.0])\n    test_cases.append((\"Scaling\", A2, b2))\n\n    # Test Case 3: Shear\n    A3 = np.array([[1.0, 0.8], [0.0, 1.0]])\n    b3 = np.array([0.1, 0.1])\n    test_cases.append((\"Shear\", A3, b3))\n\n    # Test Case 4: Extreme anisotropy\n    A4 = np.array([[0.01, 0.0], [0.0, 50.0]])\n    b4 = np.array([-2.0, 3.0])\n    test_cases.append((\"Anisotropy\", A4, b4))\n\n    # Test Cases 5, 6, 7: Random transforms\n    rng = np.random.default_rng(2025)\n    for i in range(3):\n        while True:\n            A_rand = rng.uniform(-1, 1, size=(2, 2))\n            if np.abs(np.linalg.det(A_rand)) >= 0.1:\n                break\n        b_rand = rng.uniform(-1, 1, size=(2,))\n        test_cases.append((f\"Random {i+1}\", A_rand, b_rand))\n\n    errors = []\n\n    # Perform the check for each test case\n    for _, A, b in test_cases:\n        # --- Gradient in original coordinates ---\n        # Evaluate scalar field at center and neighbors\n        f0 = scalar_field(x0)\n        x_neighbors = x0 + r_neighbors\n        f_neighbors = np.array([scalar_field(xi) for xi in x_neighbors])\n        \n        # Compute scalar differences\n        df_values = f_neighbors - f0\n        \n        # Reconstruct gradient g\n        g = reconstruct_gradient(r_neighbors, df_values)\n\n        # Sanity check: for a linear field, g should be exactly c\n        # assert np.allclose(g, c)\n\n        # --- Gradient in transformed coordinates ---\n        # The new offsets are r'_i = A * r_i\n        r_prime_neighbors = (A @ r_neighbors.T).T\n\n        # As derived in the solution, for any field, the scalar differences\n        # are invariant under the transformation: df'_i = df_i.\n        df_prime_values = df_values\n        \n        # Reconstruct gradient g' in the new system\n        g_prime = reconstruct_gradient(r_prime_neighbors, df_prime_values)\n\n        # --- Verification ---\n        # Theoretical transformed gradient: g'_theory = A^{-T} * g\n        A_inv_T = np.linalg.inv(A).T\n        g_theory_prime = A_inv_T @ g\n\n        # Calculate relative error\n        error_numerator = np.linalg.norm(g_prime - g_theory_prime)\n        error_denominator = np.linalg.norm(g_theory_prime) + epsilon\n        relative_error = error_numerator / error_denominator\n        errors.append(relative_error)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, errors))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际应用中，计算网格很少是完全正交的。这项实践将深入探讨网格质量如何影响重构精度的理论基础。通过解析推导，你将揭示网格的倾斜度如何与场的曲率相结合，在最小二乘梯度计算中引入系统性偏差，从而建立几何形状与误差之间的清晰数学联系。",
            "id": "3324944",
            "problem": "考虑一个用于计算流体动力学的二维、以单元为中心的有限体积法，其中，在相邻单元的中心对标量场 $f(\\mathbf{x})$ 进行采样，以进行最小二乘 (LS) 梯度重构。假设 $f(\\mathbf{x})$ 是二次连续可微的，并定义一个综合场\n$$\nf(\\mathbf{x}) \\;=\\; \\boldsymbol{\\beta}\\cdot \\mathbf{x} \\;+\\; \\frac{1}{2}\\,\\mathbf{x}^{\\top}\\mathbf{H}\\,\\mathbf{x},\n$$\n其中 $\\boldsymbol{\\beta}\\in\\mathbb{R}^{2}$ 控制线性部分，$\\mathbf{H}\\in\\mathbb{R}^{2\\times 2}$ 是控制曲率和各向异性的对称Hessian矩阵。设\n$$\n\\mathbf{H} \\;=\\; \\begin{pmatrix}\\alpha & \\gamma \\\\ \\gamma & \\delta\\end{pmatrix},\n$$\n其中 $\\alpha, \\gamma, \\delta \\in \\mathbb{R}$。\n\n将目标单元的中心置于原点 $\\mathbf{0}$，并设四个相邻单元的中心位于\n$$\n\\mathbf{r}_{\\mathrm{W}} = \\begin{pmatrix}-\\Delta \\\\ 0\\end{pmatrix},\\quad\n\\mathbf{r}_{\\mathrm{N}} = \\begin{pmatrix}0 \\\\ \\Delta\\end{pmatrix},\\quad\n\\mathbf{r}_{\\mathrm{S}} = \\begin{pmatrix}0 \\\\ -\\Delta\\end{pmatrix},\\quad\n\\mathbf{r}_{\\mathrm{E}} = \\begin{pmatrix}\\Delta \\\\ 0\\end{pmatrix} + \\boldsymbol{\\sigma},\n$$\n其中 $\\Delta>0$ 是一个特征相邻距离，$\\boldsymbol{\\sigma}\\in\\mathbb{R}^{2}$ 是局部网格的非正交性向量，表示相对于到东侧相邻单元中心连线的切向偏斜。假设非正交性纯粹是 $y$ 方向上的切向非正交性，即\n$$\n\\boldsymbol{\\sigma} \\;=\\; \\begin{pmatrix}0 \\\\ s\\end{pmatrix},\n$$\n其中 $s\\in\\mathbb{R}$ 用来量化偏斜的大小。最小二乘法采用单位权重，即每个相邻单元的权重为 $w_{i}=1$。\n\n在单元中心 $\\mathbf{0}$ 处的最小二乘梯度定义为下式的最小化子\n$$\n\\sum_{i\\in\\{\\mathrm{W},\\mathrm{N},\\mathrm{S},\\mathrm{E}\\}}\\left( f(\\mathbf{r}_{i}) - f(\\mathbf{0}) - \\mathbf{g}\\cdot \\mathbf{r}_{i} \\right)^{2}\n$$\n相对于梯度向量 $\\mathbf{g}\\in\\mathbb{R}^{2}$。定义偏差向量 $\\mathbf{b}$ 为重构梯度与单元中心处真实梯度之间的差值：\n$$\n\\mathbf{b} \\;=\\; \\mathbf{g}_{\\mathrm{LS}} \\;-\\; \\nabla f(\\mathbf{0}).\n$$\n\n从多元泰勒级数和最小二乘重构的定义出发，推导偏差向量 $\\mathbf{b}$ 的一个闭式解析表达式，该表达式是局部网格非正交性向量 $\\boldsymbol{\\sigma}$（通过 $s$）、间距 $\\Delta$ 以及Hessian矩阵参数 $\\alpha$、$\\gamma$、$\\delta$ 的函数。将最终答案表示为 $\\mathbf{b}$ 的两个分量关于 $\\alpha$、$\\gamma$、$\\delta$、$\\Delta$ 和 $s$ 的单个解析表达式。不需要进行数值计算或四舍五入，最终表达式中也无需包含物理单位。",
            "solution": "该问题被评估为有效。这是一个计算流体动力学领域中的适定问题，具体涉及非正交网格上最小二乘梯度重构的误差分析。问题陈述具有科学依据，客观且自洽，提供了推导所要求的梯度偏差表达式所需的所有定义和数据。\n\n求解过程如下。首先，我们确定单元中心处的真实梯度。其次，我们构建最小二乘问题并推导其正规方程。第三，我们求解正规方程得到重构梯度 $\\mathbf{g}_{\\mathrm{LS}}$。最后，我们计算偏差向量 $\\mathbf{b} = \\mathbf{g}_{\\mathrm{LS}} - \\nabla f(\\mathbf{0})$。\n\n标量场由下式给出\n$$\nf(\\mathbf{x}) = \\boldsymbol{\\beta}\\cdot \\mathbf{x} + \\frac{1}{2}\\,\\mathbf{x}^{\\top}\\mathbf{H}\\,\\mathbf{x}\n$$\n其中 $\\mathbf{x} = \\begin{pmatrix} x \\\\ y \\end{pmatrix}$，$\\boldsymbol{\\beta} = \\begin{pmatrix} \\beta_1 \\\\ \\beta_2 \\end{pmatrix}$，以及 $\\mathbf{H} = \\begin{pmatrix}\\alpha & \\gamma \\\\ \\gamma & \\delta\\end{pmatrix}$。\n该场的梯度为 $\\nabla f(\\mathbf{x}) = \\boldsymbol{\\beta} + \\mathbf{H}\\mathbf{x}$。在目标单元中心处，$\\mathbf{x} = \\mathbf{0}$，真实梯度为\n$$\n\\nabla f(\\mathbf{0}) = \\boldsymbol{\\beta}.\n$$\n在原点处场的值为 $f(\\mathbf{0}) = 0$。对于位置为 $\\mathbf{r}_i$ 的相邻单元，场的值为 $f(\\mathbf{r}_i) = \\boldsymbol{\\beta} \\cdot \\mathbf{r}_i + \\frac{1}{2}\\mathbf{r}_i^{\\top}\\mathbf{H}\\mathbf{r}_i$。\n\n最小二乘梯度 $\\mathbf{g}_{\\mathrm{LS}}$ 是使残差平方和最小化的向量 $\\mathbf{g}$：\n$$\nJ(\\mathbf{g}) = \\sum_{i\\in\\{\\mathrm{W},\\mathrm{N},\\mathrm{S},\\mathrm{E}\\}}\\left( f(\\mathbf{r}_{i}) - f(\\mathbf{0}) - \\mathbf{g}\\cdot \\mathbf{r}_{i} \\right)^{2}\n$$\n为求最小值，我们将 $J$ 对 $\\mathbf{g}$ 的梯度置零，即 $\\nabla_{\\mathbf{g}} J(\\mathbf{g}) = \\mathbf{0}$。这导出了正规方程：\n$$\n\\left( \\sum_{i} \\mathbf{r}_i \\mathbf{r}_i^{\\top} \\right) \\mathbf{g}_{\\mathrm{LS}} = \\sum_{i} \\mathbf{r}_i \\left( f(\\mathbf{r}_i) - f(\\mathbf{0}) \\right)\n$$\n我们定义几何矩阵 $\\mathbf{A} = \\sum_{i} \\mathbf{r}_i \\mathbf{r}_i^{\\top}$。方程变为：\n$$\n\\mathbf{A} \\mathbf{g}_{\\mathrm{LS}} = \\sum_{i} \\mathbf{r}_i \\left( \\boldsymbol{\\beta} \\cdot \\mathbf{r}_i + \\frac{1}{2}\\mathbf{r}_i^{\\top}\\mathbf{H}\\mathbf{r}_i \\right)\n$$\n$$\n\\mathbf{A} \\mathbf{g}_{\\mathrm{LS}} = \\sum_{i} \\mathbf{r}_i \\mathbf{r}_i^{\\top} \\boldsymbol{\\beta} + \\frac{1}{2} \\sum_{i} \\mathbf{r}_i (\\mathbf{r}_i^{\\top}\\mathbf{H}\\mathbf{r}_i)\n$$\n使用 $\\mathbf{A}$ 的定义，上式可简化为：\n$$\n\\mathbf{A} \\mathbf{g}_{\\mathrm{LS}} = \\mathbf{A} \\boldsymbol{\\beta} + \\frac{1}{2} \\sum_{i} \\mathbf{r}_i (\\mathbf{r}_i^{\\top}\\mathbf{H}\\mathbf{r}_i)\n$$\n通过乘以 $\\mathbf{A}^{-1}$ 来求解 $\\mathbf{g}_{\\mathrm{LS}}$：\n$$\n\\mathbf{g}_{\\mathrm{LS}} = \\boldsymbol{\\beta} + \\frac{1}{2} \\mathbf{A}^{-1} \\sum_{i} \\mathbf{r}_i (\\mathbf{r}_i^{\\top}\\mathbf{H}\\mathbf{r}_i)\n$$\n偏差向量定义为 $\\mathbf{b} = \\mathbf{g}_{\\mathrm{LS}} - \\nabla f(\\mathbf{0})$。由于 $\\nabla f(\\mathbf{0}) = \\boldsymbol{\\beta}$，偏差为：\n$$\n\\mathbf{b} = \\frac{1}{2} \\mathbf{A}^{-1} \\sum_{i} \\mathbf{r}_i (\\mathbf{r}_i^{\\top}\\mathbf{H}\\mathbf{r}_i)\n$$\n这表明偏差与场的线性部分 $\\boldsymbol{\\beta}$ 无关，仅取决于曲率（Hessian矩阵 $\\mathbf{H}$）和模板的几何形状。\n\n现在我们计算矩阵 $\\mathbf{A}$ 和向量和。相邻单元的位置为：\n$\\mathbf{r}_{\\mathrm{W}} = \\begin{pmatrix}-\\Delta \\\\ 0\\end{pmatrix}$，$\\mathbf{r}_{\\mathrm{N}} = \\begin{pmatrix}0 \\\\ \\Delta\\end{pmatrix}$，$\\mathbf{r}_{\\mathrm{S}} = \\begin{pmatrix}0 \\\\ -\\Delta\\end{pmatrix}$，$\\mathbf{r}_{\\mathrm{E}} = \\begin{pmatrix}\\Delta \\\\ s\\end{pmatrix}$。\n几何矩阵 $\\mathbf{A}$ 是：\n$$\n\\mathbf{A} = \\mathbf{r}_{\\mathrm{W}}\\mathbf{r}_{\\mathrm{W}}^{\\top} + \\mathbf{r}_{\\mathrm{N}}\\mathbf{r}_{\\mathrm{N}}^{\\top} + \\mathbf{r}_{\\mathrm{S}}\\mathbf{r}_{\\mathrm{S}}^{\\top} + \\mathbf{r}_{\\mathrm{E}}\\mathbf{r}_{\\mathrm{E}}^{\\top}\n$$\n$$\n\\mathbf{A} = \\begin{pmatrix} \\Delta^2 & 0 \\\\ 0 & 0 \\end{pmatrix} + \\begin{pmatrix} 0 & 0 \\\\ 0 & \\Delta^2 \\end{pmatrix} + \\begin{pmatrix} 0 & 0 \\\\ 0 & \\Delta^2 \\end{pmatrix} + \\begin{pmatrix} \\Delta^2 & \\Delta s \\\\ \\Delta s & s^2 \\end{pmatrix} = \\begin{pmatrix} 2\\Delta^2 & \\Delta s \\\\ \\Delta s & 2\\Delta^2 + s^2 \\end{pmatrix}\n$$\n$\\mathbf{A}$ 的行列式是 $\\det(\\mathbf{A}) = (2\\Delta^2)(2\\Delta^2 + s^2) - (\\Delta s)^2 = 4\\Delta^4 + 2\\Delta^2 s^2 - \\Delta^2 s^2 = 4\\Delta^4 + \\Delta^2 s^2 = \\Delta^2(4\\Delta^2 + s^2)$。其逆矩阵为：\n$$\n\\mathbf{A}^{-1} = \\frac{1}{\\Delta^2(4\\Delta^2 + s^2)} \\begin{pmatrix} 2\\Delta^2 + s^2 & -\\Delta s \\\\ -\\Delta s & 2\\Delta^2 \\end{pmatrix}\n$$\n接下来，我们计算向量和 $\\mathbf{V} = \\sum_{i} \\mathbf{r}_i (\\mathbf{r}_i^{\\top}\\mathbf{H}\\mathbf{r}_i)$。\n对于每个相邻单元，我们计算 $\\mathbf{r}_i^{\\top}\\mathbf{H}\\mathbf{r}_i$：\n- $\\mathbf{r}_{\\mathrm{W}}^{\\top}\\mathbf{H}\\mathbf{r}_{\\mathrm{W}} = \\begin{pmatrix}-\\Delta & 0\\end{pmatrix} \\begin{pmatrix}\\alpha & \\gamma \\\\ \\gamma & \\delta\\end{pmatrix} \\begin{pmatrix}-\\Delta \\\\ 0\\end{pmatrix} = \\alpha\\Delta^2$\n- $\\mathbf{r}_{\\mathrm{N}}^{\\top}\\mathbf{H}\\mathbf{r}_{\\mathrm{N}} = \\begin{pmatrix}0 & \\Delta\\end{pmatrix} \\begin{pmatrix}\\alpha & \\gamma \\\\ \\gamma & \\delta\\end{pmatrix} \\begin{pmatrix}0 \\\\ \\Delta\\end{pmatrix} = \\delta\\Delta^2$\n- $\\mathbf{r}_{\\mathrm{S}}^{\\top}\\mathbf{H}\\mathbf{r}_{\\mathrm{S}} = \\begin{pmatrix}0 & -\\Delta\\end{pmatrix} \\begin{pmatrix}\\alpha & \\gamma \\\\ \\gamma & \\delta\\end{pmatrix} \\begin{pmatrix}0 \\\\ -\\Delta\\end{pmatrix} = \\delta\\Delta^2$\n- $\\mathbf{r}_{\\mathrm{E}}^{\\top}\\mathbf{H}\\mathbf{r}_{\\mathrm{E}} = \\begin{pmatrix}\\Delta & s\\end{pmatrix} \\begin{pmatrix}\\alpha & \\gamma \\\\ \\gamma & \\delta\\end{pmatrix} \\begin{pmatrix}\\Delta \\\\ s\\end{pmatrix} = \\alpha\\Delta^2 + 2\\gamma\\Delta s + \\delta s^2$\n\n现在我们计算 $\\mathbf{r}_i (\\mathbf{r}_i^{\\top}\\mathbf{H}\\mathbf{r}_i)$ 项并将它们相加：\n- 西侧: $\\begin{pmatrix}-\\Delta \\\\ 0\\end{pmatrix} (\\alpha\\Delta^2) = \\begin{pmatrix}-\\alpha\\Delta^3 \\\\ 0\\end{pmatrix}$\n- 北侧: $\\begin{pmatrix}0 \\\\ \\Delta\\end{pmatrix} (\\delta\\Delta^2) = \\begin{pmatrix}0 \\\\ \\delta\\Delta^3\\end{pmatrix}$\n- 南侧: $\\begin{pmatrix}0 \\\\ -\\Delta\\end{pmatrix} (\\delta\\Delta^2) = \\begin{pmatrix}0 \\\\ -\\delta\\Delta^3\\end{pmatrix}$\n- 东侧: $\\begin{pmatrix}\\Delta \\\\ s\\end{pmatrix} (\\alpha\\Delta^2 + 2\\gamma\\Delta s + \\delta s^2) = \\begin{pmatrix} \\alpha\\Delta^3 + 2\\gamma\\Delta^2 s + \\delta\\Delta s^2 \\\\ \\alpha\\Delta^2 s + 2\\gamma\\Delta s^2 + \\delta s^3 \\end{pmatrix}$\n\n和 $\\mathbf{V}$ 是：\n$$\n\\mathbf{V} = \\begin{pmatrix} -\\alpha\\Delta^3 + (\\alpha\\Delta^3 + 2\\gamma\\Delta^2 s + \\delta\\Delta s^2) \\\\ \\delta\\Delta^3 - \\delta\\Delta^3 + (\\alpha\\Delta^2 s + 2\\gamma\\Delta s^2 + \\delta s^3) \\end{pmatrix} = \\begin{pmatrix} 2\\gamma\\Delta^2 s + \\delta\\Delta s^2 \\\\ \\alpha\\Delta^2 s + 2\\gamma\\Delta s^2 + \\delta s^3 \\end{pmatrix}\n$$\n$$\n\\mathbf{V} = s \\begin{pmatrix} 2\\gamma\\Delta^2 + \\delta\\Delta s \\\\ \\alpha\\Delta^2 + 2\\gamma\\Delta s + \\delta s^2 \\end{pmatrix}\n$$\n最后，我们计算偏差向量 $\\mathbf{b} = \\frac{1}{2}\\mathbf{A}^{-1}\\mathbf{V}$：\n$$\n\\mathbf{b} = \\frac{1}{2} \\frac{1}{\\Delta^2(4\\Delta^2 + s^2)} \\begin{pmatrix} 2\\Delta^2 + s^2 & -\\Delta s \\\\ -\\Delta s & 2\\Delta^2 \\end{pmatrix} \\left( s \\begin{pmatrix} 2\\gamma\\Delta^2 + \\delta\\Delta s \\\\ \\alpha\\Delta^2 + 2\\gamma\\Delta s + \\delta s^2 \\end{pmatrix} \\right)\n$$\n让我们进行矩阵-向量乘法：\n第一个分量，$b_x$：\n$$\nb_x = \\frac{s}{2\\Delta^2(4\\Delta^2 + s^2)} \\left[ (2\\Delta^2 + s^2)(2\\gamma\\Delta^2 + \\delta\\Delta s) - \\Delta s(\\alpha\\Delta^2 + 2\\gamma\\Delta s + \\delta s^2) \\right]\n$$\n$$\nb_x = \\frac{s}{2\\Delta^2(4\\Delta^2 + s^2)} \\left[ (4\\gamma\\Delta^4 + 2\\delta\\Delta^3 s + 2\\gamma\\Delta^2 s^2 + \\delta\\Delta s^3) - (\\alpha\\Delta^3 s + 2\\gamma\\Delta^2 s^2 + \\delta\\Delta s^3) \\right]\n$$\n$$\nb_x = \\frac{s}{2\\Delta^2(4\\Delta^2 + s^2)} [4\\gamma\\Delta^4 + (2\\delta - \\alpha)\\Delta^3 s] = \\frac{s\\Delta^3(4\\gamma\\Delta + (2\\delta - \\alpha)s)}{2\\Delta^2(4\\Delta^2 + s^2)} = \\frac{s\\Delta(4\\gamma\\Delta + (2\\delta - \\alpha)s)}{2(4\\Delta^2 + s^2)}\n$$\n第二个分量，$b_y$：\n$$\nb_y = \\frac{s}{2\\Delta^2(4\\Delta^2 + s^2)} \\left[ -\\Delta s(2\\gamma\\Delta^2 + \\delta\\Delta s) + 2\\Delta^2(\\alpha\\Delta^2 + 2\\gamma\\Delta s + \\delta s^2) \\right]\n$$\n$$\nb_y = \\frac{s}{2\\Delta^2(4\\Delta^2 + s^2)} \\left[ -2\\gamma\\Delta^3 s - \\delta\\Delta^2 s^2 + 2\\alpha\\Delta^4 + 4\\gamma\\Delta^3 s + 2\\delta\\Delta^2 s^2 \\right]\n$$\n$$\nb_y = \\frac{s}{2\\Delta^2(4\\Delta^2 + s^2)} [2\\alpha\\Delta^4 + 2\\gamma\\Delta^3 s + \\delta\\Delta^2 s^2] = \\frac{s\\Delta^2(2\\alpha\\Delta^2 + 2\\gamma\\Delta s + \\delta s^2)}{2\\Delta^2(4\\Delta^2 + s^2)} = \\frac{s(2\\alpha\\Delta^2 + 2\\gamma\\Delta s + \\delta s^2)}{2(4\\Delta^2 + s^2)}\n$$\n所以偏差向量是：\n$$\n\\mathbf{b} = \\begin{pmatrix} \\frac{s\\Delta(4\\gamma\\Delta + (2\\delta - \\alpha)s)}{2(4\\Delta^2 + s^2)} \\\\ \\frac{s(2\\alpha\\Delta^2 + 2\\gamma\\Delta s + \\delta s^2)}{2(4\\Delta^2 + s^2)} \\end{pmatrix}\n$$\n这可以写成：\n$$\n\\mathbf{b} = \\frac{s}{2(4\\Delta^2 + s^2)} \\begin{pmatrix} 4\\gamma\\Delta^2 + (2\\delta - \\alpha)\\Delta s \\\\ 2\\alpha\\Delta^2 + 2\\gamma\\Delta s + \\delta s^2 \\end{pmatrix}\n$$\n这就是偏差向量分量的最终表达式。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{s(4\\gamma\\Delta^2 + (2\\delta - \\alpha)\\Delta s)}{2(4\\Delta^2 + s^2)} \\\\ \\frac{s(2\\alpha\\Delta^2 + 2\\gamma\\Delta s + \\delta s^2)}{2(4\\Delta^2 + s^2)} \\end{pmatrix}}$$"
        },
        {
            "introduction": "梯度重构中的误差不仅仅是学术上的问题，它们对整个数值模拟过程有着直接且实际的影响。本练习将局部重构误差与一个时变扩散问题的全局稳定性联系起来。你将推导并应用一个更严格的稳定性极限，揭示网格的非正交性及其他重构缺陷会如何显著减小显式格式所允许的最大时间步长。",
            "id": "3324934",
            "problem": "考虑二维线性扩散方程 $u_t = \\nu \\nabla^2 u$，该方程定义于一个具有齐次狄利克雷边界条件的矩形域上，并通过单元中心有限体积法在 $L_x$ 米和 $L_y$ 米长度上的结构化 $N_x \\times N_y$ 控制体阵列上进行离散。假设对半离散系统应用时间上的前向欧拉法。用 $L$ 表示在正交网格上精确计算梯度时产生的离散拉普拉斯矩阵，用 $\\tilde{L}$ 表示在高度倾斜的网格上于单元中心重构梯度时使用的实际离散算子。假设在倾斜网格上的梯度重构满足以下建模假设：\n- 每个面上的法线方向与连接相邻单元中心的线之间存在一个角度偏差 $\\theta \\in [0,\\pi/2)$，这被解释为整个网格上非正交性的最坏情况界限。角度以度为单位给出，在进行任何三角函数求值时应转换为弧度。\n- 单元中心重构的梯度受到一个相对振幅为 $\\varepsilon \\ge 0$ 的乘性噪声的影响，即梯度重构的算子范数相对于正交、无噪声的梯度算子最多膨胀 $(1+\\varepsilon)$ 倍。\n\n您可以从以下基本出发点开始：\n- 对于线性自治系统 $u^{n+1} = u^n + \\Delta t \\, \\nu \\, A u^n$，采用前向欧拉时间积分的线法公式在欧几里得范数下是稳定的，当且仅当 $I + \\Delta t \\, \\nu \\, A$ 的谱半径不超过 $1$。对于一个实对称负半定矩阵 $A$，这得出的充分必要条件是 $\\Delta t \\le 2 / (\\nu \\, |\\lambda_{\\min}(A)|)$，其中 $\\lambda_{\\min}(A) \\le 0$ 是 $A$ 的最小（最负）的特征值。\n- 在一个具有 $N_x$ 和 $N_y$ 个内部单元以及均匀间距 $h_x = L_x/(N_x+1)$ 和 $h_y = L_y/(N_y+1)$ 的结构化矩形网格上，具有狄利克雷边界条件的标准五点离散拉普拉斯算子的特征值为\n$$\n\\lambda_{p,q} = -\\frac{4}{h_x^2} \\sin^2\\left(\\frac{p \\pi}{2 (N_x+1)}\\right) - \\frac{4}{h_y^2} \\sin^2\\left(\\frac{q \\pi}{2 (N_y+1)}\\right),\n$$\n其中整数 $p = 1,\\dots,N_x$ 且 $q=1,\\dots,N_y$。最大模（最负）的特征值出现在 $p=N_x$ 和 $q=N_y$ 处。\n\n您的任务是：\n1. 仅使用上述基本出发点以及单元中心有限体积法中离散梯度和散度算子的标准性质，推导出一个由非正交性 $\\theta$ 和乘性梯度噪声 $\\varepsilon$ 引起的离散扩散算子谱半径膨胀的严格上界。将离散算子建模为 $\\tilde{L} = D \\tilde{G}$，其中 $D$ 是离散散度算子，$\\tilde{G}$ 是一个受扰动的梯度重构算子，其算子范数相对于正交、无噪声的梯度 $G$ 满足一个界限。请论证为何在类似于分部积分的离散对称性下，对 $|\\lambda_{\\min}(\\tilde{L})|$ 的最坏情况影响是一个乘法因子，其值为梯度算子范数膨胀因子的平方。\n2. 根据此推导，用基准最大模特征值 $|\\lambda_{\\min}(L)|$、运动学扩散系数 $\\nu$（单位为 $\\mathrm{m}^2/\\mathrm{s}$）、非正交角 $\\theta$（单位为度）以及乘性梯度噪声水平 $\\varepsilon$ 来表示前向欧拉法的显式时间步长稳定性极限 $\\Delta t_{\\max}$（单位为秒）。\n3. 实现一个程序，对于下面的每个测试用例，使用上述结构化网格公式计算基准最大模特征值 $|\\lambda_{\\min}(L)|$，然后使用您推导出的表达式返回收紧的稳定性界限 $\\Delta t_{\\max}$（单位为秒）。以度为单位提供的角度在应用三角函数前必须转换为弧度。最终输出必须是单行，包含一个由方括号括起来的、按测试套件顺序排列的、用逗号分隔的结果列表。\n\n测试套件（每个用例是一个元组 $(N_x,N_y,L_x,L_y,\\nu,\\theta,\\varepsilon)$）：\n- 用例1（理想路径）：$(20,20,1.0,1.0,1.0 \\times 10^{-2},30.0,0.05)$\n- 用例2（基准：正交、无噪声）：$(20,20,1.0,1.0,1.0 \\times 10^{-2},0.0,0.0)$\n- 用例3（高度非正交）：$(20,20,1.0,1.0,1.0 \\times 10^{-2},85.0,0.02)$\n- 用例4（各向异性网格与中度噪声）：$(64,16,2.0,1.0,1.0 \\times 10^{-3},45.0,0.10)$\n- 用例5（细网格、小扩散、强倾斜）：$(100,100,1.0,1.0,1.0 \\times 10^{-4},60.0,0.20)$\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、用逗号分隔的结果列表（例如，\"[result1,result2,result3,result4,result5]\"）。每个结果必须是表示 $\\Delta t_{\\max}$（单位为秒）的浮点数。不允许有其他输出。",
            "solution": "根据指定标准，用户提供的问题被评估为有效。它具有科学依据、问题适定且客观。问题陈述提供了清晰的框架和足够的信息来推导出唯一的解决方案。\n\n按照要求，解决方案分三部分展开：谱半径膨胀因子的推导、相应稳定性极限的推导以及算法实现。\n\n**第1部分：谱半径膨胀的推导**\n\n设扩散方程 $u_t = \\nu \\nabla^2 u$ 的半离散有限体积近似由以下常微分方程组给出：\n$$\n\\frac{d \\mathbf{u}}{dt} = \\nu \\tilde{L} \\mathbf{u}\n$$\n其中 $\\mathbf{u}$ 是单元中心未知数值的向量，$\\nu$ 是运动学扩散系数，$\\tilde{L}$ 是计算网格上的离散拉普拉斯算子。\n\n在单元中心有限体积法中，拉普拉斯算子被构造为离散散度算子 $D$ 和离散梯度算子 $\\tilde{G}$ 的复合。散度是在单元中心通过单元面上的通量计算得出的，而梯度是在单元中心或单元面上重构的。因此，我们可以写作 $\\tilde{L} = D \\tilde{G}$。\n\n首先，考虑结构化正交网格且无梯度重构噪声的理想情况。离散拉普拉斯算子表示为 $L$，相应的梯度算子表示为 $G$。在此类网格上，格林第一恒等式（或分部积分）的离散模拟成立，这意味着关系式 $D = -G^T$。即散度算子是梯度算子的负转置。因此，理想的离散拉普拉斯算子是：\n$$\nL = -G^T G\n$$\n此形式表明 $L$ 是一个对称负半定矩阵。对于任何对称矩阵，谱半径 $\\rho(L)$ 等于算子2-范数 $\\|L\\|_2$。对于负半定矩阵，谱半径是最小（最负）特征值 $\\lambda_{\\min}(L)$ 的模。所以，我们有：\n$$\n|\\lambda_{\\min}(L)| = \\rho(L) = \\|L\\|_2 = \\|-G^T G\\|_2 = \\|G\\|_2^2\n$$\n这在拉普拉斯算子的最大模特征值和梯度算子的算子范数之间建立了一个关键联系。\n\n现在，我们分析在有梯度噪声的倾斜网格上的受扰动算子 $\\tilde{L}$。问题将扰动建模为影响梯度重构算子，从而产生一个受扰动的算子 $\\tilde{G}$。我们假设散度算子 $D$ 保持不变，因为它由网格拓扑决定。\n问题陈述假定我们应在“类似于分部积分的离散对称性”下进行分析。我们将其解释为，对 $\\tilde{L}$ 特征值的最坏情况效应，可以通过与理想情况相同的方式分析 $\\tilde{G}$ 的算子范数来界定。也就是说，我们将 $\\tilde{L}$ 的最坏情况最大模特征值估计为：\n$$\n|\\lambda_{\\min}(\\tilde{L})|_{\\text{worst}} = \\|\\tilde{G}\\|_2^2\n$$\n问题指出了梯度算子扰动的两个来源，我们必须对其在算子范数 $\\|\\tilde{G}\\|_2$ 上的影响进行建模。\n1.  **非正交性 ($\\theta$):** 在倾斜网格上，连接相邻单元中心的向量与共享面的法线不对齐。一个简单的有限体积格式可能会使用单元中心值的差除以投影的中心距来近似通量计算所需的法向梯度分量 $F \\propto (\\nabla u \\cdot \\mathbf{n})$，即 $\\frac{u_j-u_i}{|\\mathbf{d}_{ij}|\\cos\\theta}$。与正交情况下的分母为 $|\\mathbf{d}_{ij}|$ 相比，此公式将梯度大小放大了 $1/\\cos\\theta$ 倍。我们采用此模型来描述由非正交性引起的最坏情况下的范数膨胀。角度 $\\theta \\in [0, \\pi/2)$ 以度为单位给出，在求值时必须转换为弧度。\n2.  **乘性噪声 ($\\varepsilon$):** 问题明确指出，由于重构噪声，算子范数最多膨胀 $(1+\\varepsilon)$ 倍。\n\n由于这些是独立的、最坏情况下的界限，它们相乘。因此，梯度算子范数的总膨胀因子为：\n$$\nC = \\frac{1+\\varepsilon}{\\cos(\\theta)}\n$$\n这给出了受扰动梯度算子与理想梯度算子范数之间的关系：\n$$\n\\|\\tilde{G}\\|_2 \\le C \\|G\\|_2\n$$\n结合我们的发现，我们可以表达拉普拉斯算子最大模特征值的最坏情况膨胀：\n$$\n|\\lambda_{\\min}(\\tilde{L})|_{\\text{worst}} = \\|\\tilde{G}\\|_2^2 = (C \\|G\\|_2)^2 = C^2 \\|G\\|_2^2 = C^2 |\\lambda_{\\min}(L)|\n$$\n因此，$|\\lambda_{\\min}|$ 的膨胀因子是梯度算子范数膨胀因子的平方，即 $C^2$。\n\n**第2部分：时间步长稳定性极限的推导**\n\n问题给出了应用于系统 $\\frac{d\\mathbf{u}}{dt} = \\nu \\tilde{L} \\mathbf{u}$ 的前向欧拉法的稳定性条件：\n$$\n\\Delta t \\le \\frac{2}{\\nu |\\lambda_{\\min}(\\tilde{L})|}\n$$\n为确保在上述建模的最坏情况下的稳定性，我们必须使用 $|\\lambda_{\\min}(\\tilde{L})|$ 的上界。设 $\\Delta t_{\\max}$ 为最大稳定时间步长。\n$$\n\\Delta t_{\\max} = \\frac{2}{\\nu |\\lambda_{\\min}(\\tilde{L})|_{\\text{worst}}}\n$$\n代入第1部分推导的表达式：\n$$\n\\Delta t_{\\max} = \\frac{2}{\\nu \\left( C^2 |\\lambda_{\\min}(L)| \\right)} = \\frac{2}{\\nu |\\lambda_{\\min}(L)|} \\frac{1}{C^2}\n$$\n代入 $C$ 的表达式：\n$$\n\\Delta t_{\\max} = \\frac{2}{\\nu |\\lambda_{\\min}(L)|} \\left( \\frac{\\cos(\\theta)}{1+\\varepsilon} \\right)^2\n$$\n这就是收紧的稳定性界限的最终表达式。\n\n**第3部分：用于计算的最终表达式**\n\n为了实现这一点，我们需要理想结构化网格上 $|\\lambda_{\\min}(L)|$ 的公式，该公式已给出。最小（最负）的特征值出现在模式 $p=N_x$ 和 $q=N_y$ 处。\n$$\n\\lambda_{\\min}(L) = -\\frac{4}{h_x^2} \\sin^2\\left(\\frac{N_x \\pi}{2 (N_x+1)}\\right) - \\frac{4}{h_y^2} \\sin^2\\left(\\frac{N_y \\pi}{2 (N_y+1)}\\right)\n$$\n其中 $h_x = L_x/(N_x+1)$ 且 $h_y = L_y/(N_y+1)$。其模为 $|\\lambda_{\\min}(L)| = - \\lambda_{\\min}(L)$。\n\n用于计算的最终公式是：\n$$\n\\Delta t_{\\max} = \\frac{2 \\cos^2(\\theta_{\\text{rad}})}{\\nu (1+\\varepsilon)^2 \\left[ \\frac{4}{h_x^2} \\sin^2\\left(\\frac{N_x \\pi}{2 (N_x+1)}\\right) + \\frac{4}{h_y^2} \\sin^2\\left(\\frac{N_y \\pi}{2 (N_y+1)}\\right) \\right]}\n$$\n其中 $\\theta_{\\text{rad}}$ 是以弧度为单位的非正交角。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum stable time step for a finite volume discretization\n    of the 2D diffusion equation using forward Euler, considering the effects\n    of mesh non-orthogonality and gradient reconstruction noise.\n    \"\"\"\n    # Test suite: (Nx, Ny, Lx, Ly, nu, theta_degrees, epsilon)\n    test_cases = [\n        (20, 20, 1.0, 1.0, 1.0e-2, 30.0, 0.05),\n        (20, 20, 1.0, 1.0, 1.0e-2, 0.0, 0.0),\n        (20, 20, 1.0, 1.0, 1.0e-2, 85.0, 0.02),\n        (64, 16, 2.0, 1.0, 1.0e-3, 45.0, 0.10),\n        (100, 100, 1.0, 1.0, 1.0e-4, 60.0, 0.20),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for the current test case\n        Nx, Ny, Lx, Ly, nu, theta_deg, epsilon = case\n\n        # Calculate cell spacings\n        hx = Lx / (Nx + 1)\n        hy = Ly / (Ny + 1)\n\n        # Calculate the magnitude of the most negative eigenvalue of the\n        # ideal discrete Laplacian (L) on an orthogonal grid.\n        # This occurs for the highest frequency modes, p=Nx and q=Ny.\n        term_x = (4 / hx**2) * np.sin(Nx * np.pi / (2 * (Nx + 1)))**2\n        term_y = (4 / hy**2) * np.sin(Ny * np.pi / (2 * (Ny + 1)))**2\n        lambda_min_mag_L = term_x + term_y\n\n        # Convert the non-orthogonality angle from degrees to radians\n        theta_rad = np.deg2rad(theta_deg)\n\n        # Calculate the stability constraint inflation factor squared (C^2).\n        # This factor accounts for both non-orthogonality (cos(theta) in the\n        # denominator) and gradient reconstruction noise (1+epsilon).\n        # The effect on the Laplacian eigenvalue is the square of the effect\n        # on the gradient operator norm.\n        # A check for theta=90 degrees is implicitly handled by the problem\n        # domain theta in [0, pi/2).\n        C_squared = ((1 + epsilon) / np.cos(theta_rad))**2\n\n        # The worst-case largest-magnitude eigenvalue for the perturbed\n        # operator is the ideal one multiplied by the inflation factor.\n        lambda_min_mag_L_tilde = lambda_min_mag_L * C_squared\n\n        # Calculate the maximum stable time step (dt_max) for the forward\n        # Euler scheme using the perturbed eigenvalue.\n        dt_max = 2 / (nu * lambda_min_mag_L_tilde)\n        \n        results.append(dt_max)\n\n    # Format the final output as a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}