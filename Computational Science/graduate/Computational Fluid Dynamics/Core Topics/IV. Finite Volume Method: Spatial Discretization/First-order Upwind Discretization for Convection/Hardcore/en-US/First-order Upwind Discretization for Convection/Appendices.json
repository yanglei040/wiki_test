{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of developing reliable numerical solvers is the practice of verification, which ensures the code correctly implements the intended mathematical model. This first exercise guides you through a grid refinement study, a fundamental verification technique in CFD. By applying the first-order upwind scheme to a simple 1D advection problem with a smooth analytical solution, you will empirically measure the scheme's error and confirm its theoretical first-order accuracy .",
            "id": "3318421",
            "problem": "Consider the one-dimensional linear advection of a passive scalar governed by the conservation law $$\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0$$ with flux $$f(u) = a\\,u,$$ where $$u(x,t)$$ is a smooth scalar field and $$a$$ is a constant advection speed. On a uniform grid over a periodic domain of length $$L$$, the objective is to design and implement a grid refinement study to empirically verify first-order convergence of a first-order upwind spatial discretization applied to the transport of a smooth cosine wave. The derivation and implementation must begin from the conservation law and a monotone numerical flux selection consistent with the direction of information propagation, and must not assume any shortcut formulas. The study must use a first-order explicit time integrator with a timestep chosen to maintain a constant Courant–Friedrichs–Lewy (CFL) number across refinements.\n\nUse the following physically and numerically consistent setup:\n- Domain length $$L = 1\\,\\mathrm{m}$$ with periodic boundary conditions.\n- Advection speed $$a \\in \\{1\\,\\mathrm{m/s}, -1\\,\\mathrm{m/s}\\}$$ as specified in the test suite.\n- Initial condition $$u(x,0) = \\cos\\left(2\\pi k\\, \\frac{x}{L}\\right),$$ with wave number $$k = 1$$ (dimensionless).\n- Uniform grid with $$N$$ cells and cell centers $$x_i = \\left(i + \\frac{1}{2}\\right)\\Delta x$$ for $$i \\in \\{0,1,\\dots,N-1\\}$$ and $$\\Delta x = \\frac{L}{N}$$.\n- Final physical time $$T = \\frac{L}{2\\,|a|}$$ in $$\\mathrm{s}$$.\n- Timestep $$\\Delta t$$ chosen to keep the Courant–Friedrichs–Lewy (CFL) number $$\\nu = \\frac{|a|\\,\\Delta t}{\\Delta x}$$ constant for each test case and refinement; adjust $$\\Delta t$$ so that the integer number of steps $$n_{\\text{steps}}$$ satisfies $$n_{\\text{steps}}\\,\\Delta t = T$$ exactly for each grid.\n\nSpatial discretization requirement:\n- Implement a first-order upwind spatial discretization consistent with the sign of $$a$$ on the periodic grid. The discretization must be derived from the conservation law with a monotone numerical flux and must use only nearest-neighbor information in the upwind direction.\n\nTime discretization requirement:\n- Use a first-order explicit time integrator for the semi-discrete system.\n\nError measurement:\n- At final time $$T$$, compare the numerical solution $$u_i^{n_{\\text{final}}}$$ at cell centers $$x_i$$ to the exact solution $$u_{\\text{exact}}(x_i,T) = \\cos\\left(2\\pi k\\,\\frac{x_i - a\\,T}{L}\\right)$$ and compute the following discrete error norms:\n  1. The discrete $$L^1$$ norm $$\\|e\\|_{1} = \\sum_{i=0}^{N-1} |e_i|\\,\\Delta x,$$ where $$e_i = u_i^{n_{\\text{final}}} - u_{\\text{exact}}(x_i,T).$$\n  2. The discrete $$L^2$$ norm $$\\|e\\|_{2} = \\left(\\sum_{i=0}^{N-1} e_i^2\\,\\Delta x\\right)^{1/2}.$$\n  3. The discrete $$L^{\\infty}$$ norm $$\\|e\\|_{\\infty} = \\max_{0 \\le i \\le N-1} |e_i|.$$\n\nObserved order of convergence:\n- For each norm, given a refinement set $$\\{N_j\\}$$ and corresponding $$\\Delta x_j$$ and error values $$E_j$$, estimate the observed order $$p$$ by a linear least-squares fit of $$\\log(E_j)$$ versus $$\\log(\\Delta x_j).$$ Report $$p$$ as a real number.\n\nTest suite specification:\n- Use $$k = 1$$, $$L = 1\\,\\mathrm{m}$$, and the refinement set $$N \\in \\{50, 100, 200, 400\\}$$.\n- Use the following three parameter sets for $$a$$ and CFL:\n  1. Case A (happy path, positive speed, moderate CFL): $$a = 1\\,\\mathrm{m/s}$$ and $$\\nu = 0.5.$$\n  2. Case B (edge case, negative speed to exercise upwind direction switch): $$a = -1\\,\\mathrm{m/s}$$ and $$\\nu = 0.5.$$\n  3. Case C (near-CFL-$$1$$ case to probe stability margin): $$a = 1\\,\\mathrm{m/s}$$ and $$\\nu = 0.9.$$\n\nUnits and outputs:\n- All physical quantities must be handled using $$\\mathrm{m}$$ for length and $$\\mathrm{s}$$ for time.\n- The final program output must be a single line containing a comma-separated list enclosed in square brackets of nine real numbers with no units, representing the observed orders of convergence $$p$$ for the $$L^1$$, $$L^2$$, and $$L^{\\infty}$$ norms for Cases A, B, and C, in that order.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $$[p_{A,1}, p_{A,2}, p_{A,\\infty}, p_{B,1}, p_{B,2}, p_{B,\\infty}, p_{C,1}, p_{C,2}, p_{C,\\infty}]$$ where each $$p$$ is a floating-point number.",
            "solution": "The problem requires a grid refinement study to verify the first-order convergence of the first-order upwind scheme for the one-dimensional linear advection equation. The derivation and implementation must start from first principles.\n\nWe begin with the one-dimensional linear advection equation in conservation form:\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0\n$$\nwhere $u(x,t)$ is a scalar field and the flux is given by $f(u) = a\\,u$, with $a$ being a constant advection speed.\n\nTo derive a numerical scheme, we employ the finite volume method. We divide the spatial domain of length $L$ into $N$ uniform cells, or control volumes, $C_i = [x_{i-1/2}, x_{i+1/2}]$ for $i=0, 1, \\dots, N-1$. The width of each cell is $\\Delta x = L/N$, and the cell center is $x_i = (i + 1/2)\\Delta x$. Integrating the conservation law over a cell $C_i$ yields:\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial u}{\\partial t} dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial f(u)}{\\partial x} dx = 0\n$$\nWe define the cell-averaged value of $u$ in cell $i$ at time $t$ as:\n$$\nu_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx\n$$\nAssuming $\\Delta x$ is constant, the first term becomes $\\Delta x \\frac{d u_i}{dt}$. The second term, by the fundamental theorem of calculus, becomes $f(u(x_{i+1/2}, t)) - f(u(x_{i-1/2}, t))$. The equation is now an ordinary differential equation (ODE) for the cell average $u_i$:\n$$\n\\frac{d u_i}{dt} + \\frac{f(u(x_{i+1/2}, t)) - f(u(x_{i-1/2}, t))}{\\Delta x} = 0\n$$\nThe point values of the flux at the cell interfaces (e.g., $f(u(x_{i+1/2},t))$) are not known. We replace them with a numerical flux function, denoted by $\\hat{f}$, which depends on the states to the left and right of the interface. Let $\\hat{f}_{i+1/2}$ be the numerical flux at the interface $x_{i+1/2}$, which depends on the cell averages $u_i$ and $u_{i+1}$. The semi-discrete form of the conservation law is:\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x} (\\hat{f}_{i+1/2} - \\hat{f}_{i-1/2})\n$$\nThe problem specifies a first-order upwind spatial discretization. The upwind flux is a monotone flux that respects the direction of information propagation, which is determined by the sign of the characteristic speed $f'(u) = a$.\nThe first-order upwind numerical flux between a left state $u_L$ and a right state $u_R$ is:\n$$\n\\hat{f}(u_L, u_R) =\n\\begin{cases}\nf(u_L) = a\\,u_L  \\text{if } a  0 \\\\\nf(u_R) = a\\,u_R  \\text{if } a  0\n\\end{cases}\n$$\nThis can be written compactly using the positive and negative parts of the advection speed, $a^+ = \\max(a, 0)$ and $a^- = \\min(a, 0)$:\n$$\n\\hat{f}(u_L, u_R) = a^+ u_L + a^- u_R\n$$\nFor our grid, the flux at interface $x_{i+1/2}$ is $\\hat{f}_{i+1/2} = \\hat{f}(u_i, u_{i+1}) = a^+ u_i + a^- u_{i+1}$, and at interface $x_{i-1/2}$ it is $\\hat{f}_{i-1/2} = \\hat{f}(u_{i-1}, u_i) = a^+ u_{i-1} + a^- u_i$. Substituting these into the semi-discrete equation gives:\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x} \\left( (a^+ u_i + a^- u_{i+1}) - (a^+ u_{i-1} + a^- u_i) \\right) = -\\frac{1}{\\Delta x} \\left( a^+(u_i - u_{i-1}) + a^-(u_{i+1} - u_i) \\right)\n$$\nNext, we discretize in time using a first-order explicit (Forward Euler) method. Let $u_i^n$ be the numerical solution at cell $i$ and time step $n$. The time derivative is approximated as $\\frac{du_i}{dt} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}$. The fully discrete scheme is:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = -\\frac{1}{\\Delta x} \\left( a^+(u_i^n - u_{i-1}^n) + a^-(u_{i+1}^n - u_i^n) \\right)\n$$\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( a^+(u_i^n - u_{i-1}^n) + a^-(u_{i+1}^n - u_i^n) \\right)\n$$\nLet's analyze the two cases for the sign of $a$:\n1. If $a  0$: $a^+ = a$ and $a^- = 0$. The scheme becomes $u_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n)$.\n2. If $a  0$: $a^+ = 0$ and $a^- = a$. The scheme becomes $u_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x}(u_{i+1}^n - u_i^n)$.\n\nIntroducing the Courant–Friedrichs–Lewy (CFL) number $\\nu = \\frac{|a| \\Delta t}{\\Delta x}$, we can write $\\frac{\\Delta t}{\\Delta x} = \\frac{\\nu}{|a|}$. The update rules become:\n1. If $a  0$: $u_i^{n+1} = u_i^n - \\frac{a}{|a|}\\nu(u_i^n - u_{i-1}^n) = u_i^n - \\nu(u_i^n - u_{i-1}^n) = (1-\\nu)u_i^n + \\nu u_{i-1}^n$.\n2. If $a  0$: $u_i^{n+1} = u_i^n - \\frac{a}{|a|}\\nu(u_{i+1}^n - u_i^n) = u_i^n + \\nu(u_{i+1}^n - u_i^n) = (1-\\nu)u_i^n + \\nu u_{i+1}^n$.\n\nThe problem states that the domain is periodic. This means that for cell $i=0$, the \"upwind\" neighbor $u_{-1}$ is $u_{N-1}$. For cell $i=N-1$, the \"downwind\" neighbor $u_N$ is $u_0$.\n\nThe grid refinement study proceeds as follows. For each test case defined by $a$ and a target CFL number $\\nu_{\\text{target}}$, we solve the problem on a sequence of grids $N \\in \\{50, 100, 200, 400\\}$. For each grid $N$:\n- The grid spacing is $\\Delta x = L/N$.\n- The final time is $T = L/(2|a|)$.\n- The target time step is $\\Delta t_{\\text{target}} = \\nu_{\\text{target}} \\Delta x / |a|$.\n- The number of time steps must be an integer, $n_{\\text{steps}}$, such that the final time $T$ is reached exactly. We first calculate a non-integer number of steps $n_{\\text{float}} = T/\\Delta t_{\\text{target}} = (L/(2|a|)) / (\\nu_{\\text{target}} \\Delta x / |a|) = N/(2\\nu_{\\text{target}})$. We then round this to the nearest integer: $n_{\\text{steps}} = \\text{round}(n_{\\text{float}})$.\n- The actual time step used is $\\Delta t = T/n_{\\text{steps}}$. The actual CFL number is $\\nu_{\\text{actual}} = |a|\\Delta t / \\Delta x$, which will be close to $\\nu_{\\text{target}}$.\n- The initial condition is applied: $u_i^0 = \\cos(2\\pi k x_i/L)$.\n- The solution is advanced for $n_{\\text{steps}}$ time steps to reach $t=T$.\n- At $t=T$, the error $e_i = u_i^{n_{\\text{steps}}} - u_{\\text{exact}}(x_i, T)$ is computed, where $u_{\\text{exact}}(x,t) = \\cos(2\\pi k (x - at)/L)$.\n- The discrete error norms $\\|e\\|_1$, $\\|e\\|_2$, and $\\|e\\|_{\\infty}$ are calculated.\n\nAfter obtaining the error $E_j$ for each grid spacing $\\Delta x_j$ in the refinement sequence, we estimate the order of convergence $p$. Assuming an error relationship $E_j = C (\\Delta x_j)^p$, taking the logarithm gives $\\log(E_j) = p \\log(\\Delta x_j) + \\log(C)$. This is a linear relationship. We perform a linear least-squares fit on the points $(\\log(\\Delta x_j), \\log(E_j))$, and the resulting slope is the observed order of convergence $p$. This procedure is repeated for each norm and each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the grid refinement study for all test cases.\n    \"\"\"\n\n    # Test suite specification\n    test_cases = [\n        # Case A: a = 1.0 m/s, nu = 0.5\n        {'a': 1.0, 'nu_target': 0.5, 'L': 1.0, 'k': 1, 'N_list': [50, 100, 200, 400]},\n        # Case B: a = -1.0 m/s, nu = 0.5\n        {'a': -1.0, 'nu_target': 0.5, 'L': 1.0, 'k': 1, 'N_list': [50, 100, 200, 400]},\n        # Case C: a = 1.0 m/s, nu = 0.9\n        {'a': 1.0, 'nu_target': 0.9, 'L': 1.0, 'k': 1, 'N_list': [50, 100, 200, 400]},\n    ]\n    \n    all_results = []\n    for params in test_cases:\n        p1, p2, p_inf = run_convergence_study(**params)\n        all_results.extend([p1, p2, p_inf])\n\n    # Format and print the final output as specified.\n    print(f\"[{','.join(f'{r:.8f}' for r in all_results)}]\")\n\ndef run_convergence_study(a, nu_target, N_list, L, k):\n    \"\"\"\n    Performs a grid refinement study for a single test case.\n\n    Args:\n        a (float): Advection speed.\n        nu_target (float): Target CFL number.\n        N_list (list): List of grid resolutions.\n        L (float): Domain length.\n        k (int): Wavenumber of the initial condition.\n\n    Returns:\n        tuple: A tuple containing the observed orders of convergence (p1, p2, p_inf).\n    \"\"\"\n    \n    dx_values = []\n    errors_l1 = []\n    errors_l2 = []\n    errors_linf = []\n\n    for N in N_list:\n        # 1. Setup grid and time parameters\n        dx = L / N\n        dx_values.append(dx)\n        \n        # Cell centers\n        x = (np.arange(N) + 0.5) * dx\n        \n        # Time parameters\n        T_final = L / (2.0 * abs(a))\n        \n        # Adjust dt to hit T_final exactly with an integer number of steps\n        dt_target = nu_target * dx / abs(a)\n        n_steps_float = T_final / dt_target\n        n_steps = int(round(n_steps_float))\n        dt = T_final / n_steps\n        \n        # Calculate actual CFL number based on the adjusted dt\n        nu_actual = abs(a) * dt / dx\n\n        # 2. Initial Condition\n        u = np.cos(2.0 * np.pi * k * x / L)\n        \n        # 3. Time Marching Loop\n        for _ in range(n_steps):\n            if a > 0.0:\n                # Upwind is from the left (i-1)\n                # u_new = (1-nu)*u + nu*u_im1\n                u_im1 = np.roll(u, 1)\n                u = (1.0 - nu_actual) * u + nu_actual * u_im1\n            else: # a  0.0\n                # Upwind is from the right (i+1)\n                # u_new = (1-nu)*u + nu*u_ip1\n                u_ip1 = np.roll(u, -1)\n                u = (1.0 - nu_actual) * u + nu_actual * u_ip1\n\n        # 4. Error Calculation\n        # Exact solution at T_final\n        u_exact = np.cos(2.0 * np.pi * k * (x - a * T_final) / L)\n\n        # Error vector\n        error = u - u_exact\n\n        # Calculate and store norms\n        errors_l1.append(np.sum(np.abs(error)) * dx)\n        errors_l2.append(np.sqrt(np.sum(error**2) * dx))\n        errors_linf.append(np.max(np.abs(error)))\n\n    # 5. Calculate Order of Convergence\n    # Use linear regression on log(error) vs log(dx)\n    # log(E) = p * log(dx) + C, so the slope is the order p.\n    \n    log_dx = np.log(dx_values)\n    \n    log_err_l1 = np.log(errors_l1)\n    p1 = linregress(log_dx, log_err_l1).slope\n    \n    log_err_l2 = np.log(errors_l2)\n    p2 = linregress(log_dx, log_err_l2).slope\n    \n    log_err_linf = np.log(errors_linf)\n    p_inf = linregress(log_dx, log_err_linf).slope\n\n    return p1, p2, p_inf\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "Having empirically verified the scheme's convergence rate, we now delve into its theoretical stability properties, which dictate the allowable time step size. This practice employs von Neumann stability analysis, a powerful tool for analyzing linear schemes on periodic domains, to derive the amplification factor for the first-order upwind discretization. Through this analysis, you will determine the precise Courant-Friedrichs-Lewy (CFL) number limit, $\\nu$, required to maintain both stability and monotonicity, preventing the growth of errors and the formation of non-physical oscillations .",
            "id": "3318483",
            "problem": "Consider the one-dimensional constant-coefficient linear advection equation $u_{t} + a\\,u_{x} = 0$ with $a0$, posed on an infinite, uniform grid with spacing $\\Delta x$ and periodicity enabling Fourier analysis. Discretize convection using the donor-cell (first-order upwind) flux to obtain a semidiscrete ordinary differential equation. Advance in time using either the forward explicit Euler method or the Strong Stability Preserving Runge-Kutta of order three (SSPRK(3)). Define the Courant–Friedrichs–Lewy (CFL) number $\\nu = a\\,\\Delta t/\\Delta x$.\n\nUsing von Neumann analysis with a discrete Fourier mode $u_{j}^{n} = \\hat{u}^{n}\\exp(\\mathrm{i}\\,k\\,j\\,\\Delta x)$, derive the amplification factor $G(k)$ for the donor-cell scheme coupled to each time integrator:\n- $G_{\\mathrm{E}}(k)$ for explicit Euler,\n- $G_{\\mathrm{SSPRK3}}(k)$ for SSPRK(3).\n\nImpose the monotonicity requirements:\n- the Fourier amplitude does not grow in one time step for any wavenumber, i.e., $|G(k)| \\leq 1$ for all $k$,\n- the update does not create new extrema in physical space, i.e., it is a convex combination of existing solution values at the current time level or compositions thereof with nonnegative weights.\n\nDetermine, for each time integrator, the tightest upper bound on the CFL number $\\nu$ that simultaneously satisfies both monotonicity requirements for the donor-cell spatial discretization. Express your final answer as the pair $\\left(\\nu_{\\max}^{\\mathrm{Euler}},\\,\\nu_{\\max}^{\\mathrm{SSPRK3}}\\right)$ in a single row matrix using the LaTeX $\\mathrm{pmatrix}$ environment. No rounding is required; the CFL number is dimensionless, so do not report units.",
            "solution": "The problem requires the determination of the tightest upper bounds on the Courant–Friedrichs–Lewy (CFL) number $\\nu$ for the first-order upwind discretization of the linear advection equation, coupled with two different time integrators, under two specified monotonicity requirements.\n\nThe governing partial differential equation is the one-dimensional linear advection equation with a constant, positive wave speed $a$:\n$$\nu_{t} + a\\,u_{x} = 0, \\quad a  0\n$$\n\nFirst, we discretize the spatial derivative $u_x$ on a uniform grid with spacing $\\Delta x$. The problem specifies the donor-cell, or first-order upwind, scheme. Since the wave speed $a$ is positive, information propagates from left to right, so the upwind direction is from the node $j-1$ to $j$. We use a first-order backward difference for $u_x$:\n$$\nu_x \\bigg|_{j} \\approx \\frac{u_j - u_{j-1}}{\\Delta x}\n$$\nSubstituting this into the governing equation yields a system of semi-discrete ordinary differential equations (ODEs), one for each grid point $j$:\n$$\n\\frac{du_j(t)}{dt} = -\\frac{a}{\\Delta x} \\left(u_j(t) - u_{j-1}(t)\\right)\n$$\nThis can be written in the form $\\frac{d\\mathbf{u}}{dt} = L(\\mathbf{u})$, where $L$ is the spatial discretization operator.\n\nThe analysis proceeds by considering each time integrator separately.\n\n### 1. Forward Explicit Euler Time Integration\n\nThe forward Euler method updates the solution from time level $n$ to $n+1$ as $u_j^{n+1} = u_j^n + \\Delta t \\left(\\frac{du_j}{dt}\\right)^n$. Applying this to our semi-discrete equation gives:\n$$\nu_j^{n+1} = u_j^n + \\Delta t \\left( -\\frac{a}{\\Delta x} (u_j^n - u_{j-1}^n) \\right)\n$$\nUsing the definition of the CFL number, $\\nu = \\frac{a\\,\\Delta t}{\\Delta x}$, the fully discrete scheme is:\n$$\nu_j^{n+1} = u_j^n - \\nu (u_j^n - u_{j-1}^n)\n$$\n$$\nu_j^{n+1} = (1-\\nu)u_j^n + \\nu u_{j-1}^n\n$$\n\nWe now analyze this scheme against the two stated requirements.\n\n**Requirement 2: Convex Combination**\nThe second requirement is that the update is a convex combination of existing solution values, which for this linear scheme means the coefficients on the right-hand side must be non-negative and sum to $1$.\nThe coefficients are $c_0 = 1-\\nu$ and $c_{-1} = \\nu$.\nThe sum of the coefficients is $(1-\\nu) + \\nu = 1$.\nFor the coefficients to be non-negative, we require:\n1. $\\nu \\ge 0$: Since $a0$, $\\Delta t0$, and $\\Delta x0$, this condition is naturally satisfied.\n2. $1-\\nu \\ge 0 \\implies \\nu \\le 1$.\nThus, the scheme is monotone (does not create new extrema) if and only if $0 \\le \\nu \\le 1$. The tightest upper bound from this condition is $\\nu \\le 1$.\n\n**Requirement 1: Von Neumann Stability**\nThe first requirement is that $|G(k)| \\le 1$ for all wavenumbers $k$. We derive the amplification factor $G_{\\mathrm{E}}(k)$ by substituting a single Fourier mode, $u_j^n = \\hat{u}^n \\exp(\\mathrm{i} k j \\Delta x)$, into the discrete equation:\n$$\n\\hat{u}^{n+1}\\exp(\\mathrm{i} k j \\Delta x) = (1-\\nu)\\hat{u}^n\\exp(\\mathrm{i} k j \\Delta x) + \\nu\\hat{u}^n\\exp(\\mathrm{i} k (j-1) \\Delta x)\n$$\nDividing by $\\hat{u}^n \\exp(\\mathrm{i} k j \\Delta x)$, we find the amplification factor $G_{\\mathrm{E}}(k) = \\frac{\\hat{u}^{n+1}}{\\hat{u}^n}$:\n$$\nG_{\\mathrm{E}}(k) = (1-\\nu) + \\nu \\exp(-\\mathrm{i} k \\Delta x)\n$$\nLet $\\theta = k \\Delta x$. Then $G_{\\mathrm{E}}(\\theta) = 1 - \\nu + \\nu e^{-\\mathrm{i}\\theta} = (1 - \\nu + \\nu\\cos\\theta) - \\mathrm{i}\\nu\\sin\\theta$.\nThe squared magnitude is:\n$$\n|G_{\\mathrm{E}}(\\theta)|^2 = (1 - \\nu + \\nu\\cos\\theta)^2 + (\\nu\\sin\\theta)^2\n$$\n$$\n|G_{\\mathrm{E}}(\\theta)|^2 = (1-\\nu)^2 + 2\\nu(1-\\nu)\\cos\\theta + \\nu^2\\cos^2\\theta + \\nu^2\\sin^2\\theta\n$$\n$$\n|G_{\\mathrm{E}}(\\theta)|^2 = 1 - 2\\nu + \\nu^2 + 2\\nu(1-\\nu)\\cos\\theta + \\nu^2 = 1 - 2\\nu + 2\\nu^2 + 2\\nu(1-\\nu)\\cos\\theta\n$$\n$$\n|G_{\\mathrm{E}}(\\theta)|^2 = 1 - 2\\nu(1-\\nu) + 2\\nu(1-\\nu)\\cos\\theta = 1 - 2\\nu(1-\\nu)(1-\\cos\\theta)\n$$\nThe stability condition $|G_{\\mathrm{E}}(\\theta)|^2 \\le 1$ requires $ -2\\nu(1-\\nu)(1-\\cos\\theta) \\le 0$. Since $\\nu0$ and $1-\\cos\\theta \\ge 0$ for all $\\theta$, this simplifies to the condition $1-\\nu \\ge 0$, or $\\nu \\le 1$.\n\nBoth requirements lead to the same condition. The tightest upper bound on the CFL number is:\n$$\n\\nu_{\\max}^{\\mathrm{Euler}} = 1\n$$\n\n### 2. Strong Stability Preserving Runge-Kutta of Order Three (SSPRK(3))\n\nThe SSPRK(3) method for $\\frac{d\\mathbf{u}}{dt} = L(\\mathbf{u})$ is given by the three stages:\n$$\n\\begin{aligned}\n\\mathbf{u}^{(1)} = \\mathbf{u}^n + \\Delta t L(\\mathbf{u}^n) \\\\\n\\mathbf{u}^{(2)} = \\frac{3}{4} \\mathbf{u}^n + \\frac{1}{4} \\mathbf{u}^{(1)} + \\frac{1}{4} \\Delta t L(\\mathbf{u}^{(1)}) \\\\\n\\mathbf{u}^{n+1} = \\frac{1}{3} \\mathbf{u}^n + \\frac{2}{3} \\mathbf{u}^{(2)} + \\frac{2}{3} \\Delta t L(\\mathbf{u}^{(2)})\n\\end{aligned}\n$$\nThis method can be interpreted as a convex combination of forward Euler-like steps. Let $P_E(\\mathbf{u}) = \\mathbf{u} + \\Delta t L(\\mathbf{u})$ be the forward Euler operator. The SSPRK(3) scheme can be written as:\n$$\n\\begin{aligned}\n\\mathbf{u}^{(1)} = P_E(\\mathbf{u}^n) \\\\\n\\mathbf{u}^{(2)} = \\frac{3}{4} \\mathbf{u}^n + \\frac{1}{4} P_E(\\mathbf{u}^{(1)}) \\\\\n\\mathbf{u}^{n+1} = \\frac{1}{3} \\mathbf{u}^n + \\frac{2}{3} P_E(\\mathbf{u}^{(2)})\n\\end{aligned}\n$$\n\n**Requirement 2: Convex Combination**\nThe key property of SSP methods is that if the forward Euler method $P_E$ is monotone under a CFL condition $\\nu \\le \\nu_0$, then the SSPRK method is also monotone under a related CFL condition. For the given SSPRK(3) scheme, it is known to be monotone if the forward Euler step is monotone. As established in the previous section, the forward Euler step with the first-order upwind spatial discretization, $u_j^{n+1} = (1-\\nu)u_j^n + \\nu u_{j-1}^n$, is monotone if $0 \\le \\nu \\le 1$.\nThe SSPRK(3) scheme is a composition of operations (addition with positive coefficients, and application of $P_E$) that preserve non-negativity and convexity, provided $P_E$ itself is a monotone operator. This requires $\\nu \\le 1$. Thus, the tightest upper bound for monotonicity is $\\nu \\le 1$.\n\n**Requirement 1: Von Neumann Stability**\nTo derive $G_{\\mathrm{SSPRK3}}(k)$, we analyze the method in Fourier space. The amplification factor of the spatial operator $L$ is $\\hat{L}(k)$.\n$$\nL(e^{\\mathrm{i} k j \\Delta x}) = -\\frac{a}{\\Delta x}(e^{\\mathrm{i} k j \\Delta x} - e^{\\mathrm{i} k (j-1) \\Delta x}) = \\left(-\\frac{a}{\\Delta x}(1 - e^{-\\mathrm{i} k \\Delta x})\\right) e^{\\mathrm{i} k j \\Delta x}\n$$\nLet $z = \\Delta t \\hat{L}(k) = -\\nu(1-e^{-\\mathrm{i} k \\Delta x})$. The amplification factor of the time integration scheme is its stability polynomial $R(z)$. For SSPRK(3), this is:\n$$\nG_{\\mathrm{SSPRK3}}(k) = R(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3\n$$\nThe stability of the scheme requires $|R(z)| \\le 1$ for all values of $z$ traced by $z = -\\nu(1-e^{-\\mathrm{i}\\theta})$ as $\\theta=k\\Delta x$ sweeps through $[-\\pi, \\pi]$. The locus of $z$ in the complex plane is a circle centered at $(-\\nu, 0)$ with radius $\\nu$. The stability region of the classical RK3 method, defined by $|R(z)| \\le 1$, contains the interval $[-2.51, 0]$ on the real axis. For the locus of $z$ to be within this region, its leftmost point, $-2\\nu$, must be within the boundary. This yields $-2\\nu \\gtrsim -2.51$, or $\\nu \\lesssim 1.25$.\n\n**Conclusion for SSPRK(3)**\nThe monotonicity requirement (convex combination) imposes the condition $\\nu \\le 1$. The von Neumann stability requirement ($|G| \\le 1$) imposes the condition $\\nu \\lesssim 1.25$. To satisfy *both* requirements, we must take the more restrictive condition.\nTherefore, the tightest upper bound on the CFL number for the SSPRK(3) scheme is:\n$$\n\\nu_{\\max}^{\\mathrm{SSPRK3}} = 1\n$$\n\n### Final Result\n\nThe tightest upper bounds on the CFL number $\\nu$ that satisfy both monotonicity requirements for the first-order upwind scheme are $\\nu_{\\max}^{\\mathrm{Euler}} = 1$ and $\\nu_{\\max}^{\\mathrm{SSPRK3}} = 1$. The required final answer is the pair $(\\nu_{\\max}^{\\mathrm{Euler}}, \\nu_{\\max}^{\\mathrm{SSPRK3}})$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While the upwind scheme is stable and monotone in one dimension, its behavior in multiple dimensions reveals a critical deficiency. This final practice extends the advection problem to a 2D domain to investigate the phenomenon of numerical diffusion, often called 'false diffusion' when it acts anisotropically. By simulating the transport of a Gaussian profile at an angle to the grid lines, you will quantify how the scheme artificially spreads the solution more in the cross-stream direction than in the stream-wise direction, a key limitation that motivates the development of higher-order methods .",
            "id": "3318407",
            "problem": "Consider the linear, constant-coefficient advection equation in two spatial dimensions,\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\boldsymbol{a} \\cdot \\nabla \\phi = 0,\n$$\nwhere $\\phi(x,y,t)$ is a passive scalar and $\\boldsymbol{a} = (a_x,a_y)$ is a constant advection velocity. The computational domain is the periodic unit square $[0,1]\\times[0,1]$ in non-dimensional units, discretized with a uniform Cartesian grid of $N_x \\times N_y$ cells of sizes $\\Delta x = 1/N_x$ and $\\Delta y = 1/N_y$.\n\nStarting from the conservation form of advection and the definition of upwind numerical fluxes, derive the first-order upwind (donor-cell) semi-discrete spatial discretization on this grid for constant $\\boldsymbol{a}$. Then select a single-step explicit forward Euler time integration with time step $\\Delta t$ satisfying a suitable Courant–Friedrichs–Lewy (CFL) stability requirement. The scheme must use periodic boundary conditions.\n\nYou will create a wind-oblique advection test in two dimensions to measure false diffusion and report directional smoothing relative to the angle between $\\boldsymbol{a}$ and the grid axes. Use the following mathematically specified setup:\n\n- The initial condition at time $t=0$ is a smooth, localized Gaussian bump centered at $(x_0,y_0)$,\n$$\n\\phi(x,y,0) = \\exp\\left( - \\frac{(x-x_0)^2 + (y-y_0)^2}{2\\sigma^2} \\right),\n$$\nwith $x_0=0.25$, $y_0=0.25$, and $\\sigma=0.05$ (all in non-dimensional units).\n\n- The velocity is $\\boldsymbol{a} = (\\cos\\theta,\\sin\\theta)$ for a specified angle $\\theta$ (in radians). The magnitude $\\|\\boldsymbol{a}\\|$ is $1$.\n\n- Take $N_x = N_y = 256$, $\\Delta t = 0.2\\,\\Delta x$, and integrate to a final time $T=0.1$ using explicit forward Euler. The actual integration time $T_{\\text{actual}}$ should be the product of the integer number of steps and $\\Delta t$. Use periodic boundary conditions on all sides.\n\nTo quantify false diffusion and directional smoothing, compute second central moments of $\\phi$ with respect to its mass-weighted centroid and project them onto directions parallel and perpendicular to $\\boldsymbol{a}$:\n\n1. Compute the mass $M = \\int_{0}^{1}\\int_{0}^{1} \\phi(x,y,t)\\,\\mathrm{d}x\\,\\mathrm{d}y$, the centroid $(\\bar{x}(t),\\bar{y}(t))$, and the covariance matrix\n$$\n\\mathbf{C}(t) = \\frac{1}{M}\\int_{0}^{1}\\int_{0}^{1} \n\\begin{bmatrix}\nx-\\bar{x}(t)\\\\\ny-\\bar{y}(t)\n\\end{bmatrix}\n\\begin{bmatrix}\nx-\\bar{x}(t)  y-\\bar{y}(t)\n\\end{bmatrix}\n\\phi(x,y,t)\\,\\mathrm{d}x\\,\\mathrm{d}y.\n$$\n2. Let the unit vectors along and orthogonal to the flow be $\\hat{\\boldsymbol{s}} = \\boldsymbol{a}/\\|\\boldsymbol{a}\\|$ and $\\hat{\\boldsymbol{n}} = (-\\hat{s}_y,\\hat{s}_x)$, respectively. Define the variances along these directions by $v_s(t) = \\hat{\\boldsymbol{s}}^\\top \\mathbf{C}(t)\\,\\hat{\\boldsymbol{s}}$ and $v_n(t) = \\hat{\\boldsymbol{n}}^\\top \\mathbf{C}(t)\\,\\hat{\\boldsymbol{n}}$.\n3. Estimate effective directional numerical diffusion coefficients by\n$$\nD_{\\text{eff},s} = \\frac{v_s(T_{\\text{actual}}) - v_s(0)}{2\\,T_{\\text{actual}}}, \\quad\nD_{\\text{eff},n} = \\frac{v_n(T_{\\text{actual}}) - v_n(0)}{2\\,T_{\\text{actual}}},\n$$\nand report the directional smoothing ratio $R = D_{\\text{eff},n}/D_{\\text{eff},s}$.\n\nAll quantities are non-dimensional and should be reported in non-dimensional units consistent with the unit-length domain and unit velocity magnitude. Angles must be specified in degrees in the output.\n\nTest Suite:\nEvaluate the above for the following angles $\\theta$ (provided here in degrees, to be converted to radians internally): $0$, $5$, $22.5$, $45$, $67.5$, $90$. These cover axis-aligned flows, near-axis oblique flows, and diagonal flows.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list containing four floats:\n$[\\,[\\theta_1,D_{\\text{eff},s,1},D_{\\text{eff},n,1},R_1],\\,[\\theta_2,D_{\\text{eff},s,2},D_{\\text{eff},n,2},R_2],\\,\\dots\\,]\n$$\nwith numerical values in place of the symbols. No additional text should be printed.",
            "solution": "The problem is valid. It presents a standard, well-posed initial-boundary value problem from computational fluid dynamics, providing all necessary parameters and a clear objective for analysis. The underlying physics and mathematics are sound, and the numerical methods are classical.\n\n### Derivation of the First-Order Upwind Semi-Discretization\n\nWe begin with the two-dimensional linear advection equation in conservation form:\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\nabla \\cdot (\\boldsymbol{a}\\phi) = 0\n$$\nwhere $\\boldsymbol{a}=(a_x, a_y)$ is a constant velocity vector. We integrate this equation over a computational cell $\\Omega_{i,j} = [x_{i-1/2}, x_{i+1/2}] \\times [y_{j-1/2}, y_{j+1/2}]$ of area $\\Delta x \\Delta y$. Applying the divergence theorem, we obtain the integral form:\n$$\n\\frac{d}{dt} \\iint_{\\Omega_{i,j}} \\phi \\,dx\\,dy + \\oint_{\\partial\\Omega_{i,j}} (\\phi\\boldsymbol{a}) \\cdot \\hat{\\boldsymbol{n}} \\,ds = 0\n$$\nLet $\\phi_{i,j}(t)$ be the cell-averaged value of the scalar, $\\phi_{i,j}(t) = \\frac{1}{\\Delta x \\Delta y} \\iint_{\\Omega_{i,j}} \\phi \\,dx\\,dy$. The time derivative of the integral is approximated as $\\Delta x \\Delta y \\frac{d\\phi_{i,j}}{dt}$. The boundary integral (flux term) is the sum of fluxes across the four faces of the cell (east, west, north, south):\n$$\n\\oint_{\\partial\\Omega_{i,j}} (\\phi\\boldsymbol{a}) \\cdot \\hat{\\boldsymbol{n}} \\,ds = (F_e - F_w) + (F_n - F_s)\n$$\nwhere the fluxes are defined at the cell faces. For example, the flux through the east face at $x_{i+1/2}$ is $F_e = \\int_{y_{j-1/2}}^{y_{j+1/2}} \\phi(x_{i+1/2}, y) a_x \\,dy$. We approximate this as $F_e \\approx (\\phi_{i+1/2,j} a_x) \\Delta y$, where $\\phi_{i+1/2,j}$ is the value of $\\phi$ at the face. Similar approximations are made for the other faces:\n$F_w \\approx (\\phi_{i-1/2,j} a_x) \\Delta y$, $F_n \\approx (\\phi_{i,j+1/2} a_y) \\Delta x$, and $F_s \\approx (\\phi_{i,j-1/2} a_y) \\Delta x$.\n\nThe first-order upwind, or donor-cell, scheme defines the value at a cell face to be the value from the \"upwind\" or \"donor\" cell, i.e., the cell from which the flow originates.\nFor the face at $x_{i+1/2}$, the value $\\phi_{i+1/2,j}$ is determined by the sign of $a_x$:\n$$\n\\phi_{i+1/2,j} = \\begin{cases} \\phi_{i,j}  \\text{if } a_x  0 \\\\ \\phi_{i+1,j}  \\text{if } a_x  0 \\end{cases}\n$$\nThis logic is applied to all faces. A convenient way to express this is by splitting the velocity components into positive and negative parts: $a_x = a_x^+ + a_x^-$ where $a_x^+ = \\max(a_x, 0)$ and $a_x^- = \\min(a_x, 0)$. The net flux in the x-direction, $F_e - F_w$, becomes:\n$$\nF_e - F_w \\approx \\left[ (a_x^+ \\phi_{i,j} + a_x^- \\phi_{i+1,j}) - (a_x^+ \\phi_{i-1,j} + a_x^- \\phi_{i,j}) \\right] \\Delta y\n$$\nA similar expression holds for the net flux in the y-direction. Substituting these into the discretized conservation law and dividing by the cell area $\\Delta x \\Delta y$, we arrive at the semi-discrete equation for the cell average $\\phi_{i,j}$:\n$$\n\\frac{d\\phi_{i,j}}{dt} = - \\left[ \\frac{a_x^+(\\phi_{i,j} - \\phi_{i-1,j}) + a_x^-(\\phi_{i+1,j} - \\phi_{i,j})}{\\Delta x} + \\frac{a_y^+(\\phi_{i,j} - \\phi_{i,j-1}) + a_y^-(\\phi_{i,j+1} - \\phi_{i,j})}{\\Delta y} \\right]\n$$\n\n### Fully-Discrete Scheme with Forward Euler\n\nTo obtain a fully-discrete scheme, we discretize the time derivative using the first-order explicit forward Euler method: $\\frac{d\\phi_{i,j}}{dt} \\approx \\frac{\\phi_{i,j}^{n+1} - \\phi_{i,j}^n}{\\Delta t}$, where the superscript $n$ denotes the time level $t^n = n\\Delta t$.\nThis yields the update formula:\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^n - \\frac{\\Delta t}{\\Delta x} \\left[ a_x^+(\\phi_{i,j}^n - \\phi_{i-1,j}^n) + a_x^-(\\phi_{i+1,j}^n - \\phi_{i,j}^n) \\right] - \\frac{\\Delta t}{\\Delta y} \\left[ a_y^+(\\phi_{i,j}^n - \\phi_{i,j-1}^n) + a_y^-(\\phi_{i,j+1}^n - \\phi_{i,j}^n) \\right]\n$$\nThis scheme is stable under the Courant–Friedrichs–Lewy (CFL) condition $|a_x|\\frac{\\Delta t}{\\Delta x} + |a_y|\\frac{\\Delta t}{\\Delta y} \\le 1$. The problem specifies $\\Delta x = \\Delta y = 1/256$, $\\Delta t = 0.2 \\Delta x$, and $\\|\\boldsymbol{a}\\|=1$. The sum of Courant numbers is $C_x+C_y = \\frac{\\Delta t}{\\Delta x}(|a_x| + |a_y|) = 0.2(|\\cos\\theta| + |\\sin\\theta|)$. The maximum value of $|\\cos\\theta| + |\\sin\\theta|$ is $\\sqrt{2}$, so the maximum CFL number is $0.2\\sqrt{2} \\approx 0.283  1$, ensuring stability.\n\n### Analysis of Numerical Diffusion\n\nThe analysis quantifies the numerical diffusion inherent in the scheme by measuring the change in the spatial variance of the scalar field. The required quantities are computed numerically from the discrete solution $\\phi_{i,j}$ on the grid. We use cell-centered coordinates $x_i = (i+0.5)\\Delta x$ and $y_j = (j+0.5)\\Delta y$.\n\n1.  **Mass and Centroid**: The integrals are approximated by sums over all cells. The total mass is $M \\approx \\sum_{i,j} \\phi_{i,j} \\Delta x \\Delta y$. The centroid components are $\\bar{x} \\approx \\frac{1}{M} \\sum_{i,j} x_i \\phi_{i,j} \\Delta x \\Delta y$ and $\\bar{y} \\approx \\frac{1}{M} \\sum_{i,j} y_j \\phi_{i,j} \\Delta x \\Delta y$. Since the propagation distance is small relative to the domain size, periodic corrections for the centroid calculation are unnecessary.\n\n2.  **Covariance Matrix**: The components of the covariance matrix $\\mathbf{C}$ are also computed via summation:\n    $$\n    C_{xx} \\approx \\frac{1}{M} \\sum_{i,j} (x_i - \\bar{x})^2 \\phi_{i,j} \\Delta x \\Delta y = \\frac{\\sum_{i,j} (x_i - \\bar{x})^2 \\phi_{i,j}}{\\sum_{i,j} \\phi_{i,j}} \\\\\n    C_{yy} \\approx \\frac{\\sum_{i,j} (y_j - \\bar{y})^2 \\phi_{i,j}}{\\sum_{i,j} \\phi_{i,j}} \\\\\n    C_{xy} \\approx \\frac{\\sum_{i,j} (x_i - \\bar{x})(y_j - \\bar{y}) \\phi_{i,j}}{\\sum_{i,j} \\phi_{i,j}}\n    $$\n\n3.  **Directional Variances**: With $\\mathbf{C}$ computed, the variances parallel ($v_s$) and perpendicular ($v_n$) to the flow direction $\\hat{\\boldsymbol{s}} = \\boldsymbol{a}/\\|\\boldsymbol{a}\\|=(\\cos\\theta, \\sin\\theta)$ are found by projection:\n    $$\n    v_s = \\hat{\\boldsymbol{s}}^\\top \\mathbf{C}\\,\\hat{\\boldsymbol{s}} = C_{xx} \\cos^2\\theta + C_{yy} \\sin^2\\theta + 2 C_{xy} \\sin\\theta \\cos\\theta \\\\\n    v_n = \\hat{\\boldsymbol{n}}^\\top \\mathbf{C}\\,\\hat{\\boldsymbol{n}} = C_{xx} \\sin^2\\theta + C_{yy} \\cos^2\\theta - 2 C_{xy} \\sin\\theta \\cos\\theta\n    $$\n    where $\\hat{\\boldsymbol{n}} = (-\\sin\\theta, \\cos\\theta)$.\n\n4.  **Effective Diffusion**: The effective numerical diffusion coefficients are estimated by observing the growth of these variances over the simulation time $T_{\\text{actual}}$:\n    $$\n    D_{\\text{eff},s} = \\frac{v_s(T_{\\text{actual}}) - v_s(0)}{2\\,T_{\\text{actual}}}, \\quad\n    D_{\\text{eff},n} = \\frac{v_n(T_{\\text{actual}}) - v_n(0)}{2\\,T_{\\text{actual}}}\n    $$\n    These coefficients are calculated for both the initial state ($t=0$) and the final state ($t=T_{\\text{actual}}$). For consistency, the initial variances $v_s(0)$ and $v_n(0)$ are computed from the discretized initial condition, not from the analytical formula for a perfect Gaussian, to isolate the change due to the numerical scheme alone. The ratio $R = D_{\\text{eff},n}/D_{\\text{eff},s}$ quantifies the anisotropy of the numerical error, often termed \"false diffusion\" when it acts perpendicular to the flow.\n\n### Computational Implementation\n\nThe simulation is performed for each specified angle $\\theta$. For each case, the grid and initial Gaussian profile are generated. The core of the solver is a time loop that iteratively applies the fully-discrete upwind formula. Periodic boundary conditions are efficiently handled using array-shifting operations (e.g., `numpy.roll`). After the final time step, the analysis routine is called on the initial and final scalar fields to compute the variances, effective diffusion coefficients, and their ratio. The results are then collated and printed in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D advection equation using a first-order upwind scheme\n    and analyzes the numerical diffusion for various flow angles.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.0,\n        5.0,\n        22.5,\n        45.0,\n        67.5,\n        90.0,\n    ]\n\n    # Simulation parameters\n    Nx = 256\n    Ny = 256\n    x0 = 0.25\n    y0 = 0.25\n    sigma = 0.05\n    domain_size = 1.0\n    T_final = 0.1\n\n    dx = domain_size / Nx\n    dy = domain_size / Ny\n    dt = 0.2 * dx\n    \n    # Create grid\n    x_coords = (np.arange(Nx) + 0.5) * dx\n    y_coords = (np.arange(Ny) + 0.5) * dy\n    X, Y = np.meshgrid(x_coords, y_coords)\n\n    def calculate_analysis(phi, X_grid, Y_grid, s_hat, n_hat):\n        \"\"\"\n        Calculates mass, centroid, covariance matrix, and directional variances.\n        \"\"\"\n        # Mass calculation (dx*dy cancels out in ratios, so can be omitted)\n        mass = np.sum(phi)\n        if mass == 0:\n            return 0, 0, 0 # Should not happen with a Gaussian\n\n        # Centroid calculation\n        # The bump does not wrap around, so simple weighted average is fine.\n        x_bar = np.sum(X_grid * phi) / mass\n        y_bar = np.sum(Y_grid * phi) / mass\n\n        # Distances from centroid\n        dx_bar = X_grid - x_bar\n        dy_bar = Y_grid - y_bar\n        \n        # Covariance matrix components\n        C_xx = np.sum(dx_bar**2 * phi) / mass\n        C_yy = np.sum(dy_bar**2 * phi) / mass\n        C_xy = np.sum(dx_bar * dy_bar * phi) / mass\n\n        # Directional variances\n        s_x, s_y = s_hat\n        n_x, n_y = n_hat\n\n        v_s = C_xx * s_x**2 + C_yy * s_y**2 + 2 * C_xy * s_x * s_y\n        v_n = C_xx * n_x**2 + C_yy * n_y**2 + 2 * C_xy * n_x * n_y\n        \n        return v_s, v_n\n\n    results = []\n    \n    for theta_deg in test_cases:\n        theta_rad = np.radians(theta_deg)\n        \n        # Velocity vector and its positive/negative parts\n        ax = np.cos(theta_rad)\n        ay = np.sin(theta_rad)\n        ax_pos = max(ax, 0)\n        ax_neg = min(ax, 0)\n        ay_pos = max(ay, 0)\n        ay_neg = min(ay, 0)\n\n        # Projection vectors\n        s_hat = np.array([ax, ay])\n        n_hat = np.array([-ay, ax])\n        \n        # Initial condition\n        phi0 = np.exp(-((X - x0)**2 + (Y - y0)**2) / (2 * sigma**2))\n\n        # Analysis of initial condition\n        v_s0, v_n0 = calculate_analysis(phi0, X, Y, s_hat, n_hat)\n\n        # Time stepping\n        phi = phi0.copy()\n        num_steps = int(np.floor(T_final / dt))\n        T_actual = num_steps * dt\n\n        for _ in range(num_steps):\n            # Periodic BCs using numpy.roll\n            phi_im1 = np.roll(phi, 1, axis=1) # phi at i-1\n            phi_ip1 = np.roll(phi, -1, axis=1) # phi at i+1\n            phi_jm1 = np.roll(phi, 1, axis=0) # phi at j-1\n            phi_jp1 = np.roll(phi, -1, axis=0) # phi at j+1\n            \n            # Spatial derivative term (upwind)\n            dphi_dx_term = (ax_pos * (phi - phi_im1) + ax_neg * (phi_ip1 - phi)) / dx\n            dphi_dy_term = (ay_pos * (phi - phi_jm1) + ay_neg * (phi_jp1 - phi)) / dy\n\n            # Forward Euler update\n            phi -= dt * (dphi_dx_term + dphi_dy_term)\n\n        # Analysis of final condition\n        v_sT, v_nT = calculate_analysis(phi, X, Y, s_hat, n_hat)\n        \n        # Effective diffusion coefficients\n        if T_actual > 0:\n            D_eff_s = (v_sT - v_s0) / (2 * T_actual)\n            D_eff_n = (v_nT - v_n0) / (2 * T_actual)\n        else:\n            D_eff_s = 0.0\n            D_eff_n = 0.0\n\n        # Smoothing ratio\n        # Avoid division by zero, although D_eff_s should be positive.\n        if D_eff_s != 0:\n            R = D_eff_n / D_eff_s\n        else:\n            # If stream-wise diffusion is zero, but cross-stream is not, ratio is infinite.\n            # If both are zero, ratio is undefined, we can set it to 0 or 1. \n            # In this problem, D_eff_s > 0 is expected for T>0.\n            R = np.inf if D_eff_n != 0 else 0.0\n            \n        results.append([theta_deg, D_eff_s, D_eff_n, R])\n\n    # Final print statement in the exact required format.\n    case_strings = [f\"[{c[0]},{c[1]},{c[2]},{c[3]}]\" for c in results]\n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```"
        }
    ]
}