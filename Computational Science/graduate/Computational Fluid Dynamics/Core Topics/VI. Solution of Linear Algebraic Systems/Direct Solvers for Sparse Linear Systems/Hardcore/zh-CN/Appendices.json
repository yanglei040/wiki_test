{
    "hands_on_practices": [
        {
            "introduction": "理论分析的第一步是理解基础。本练习将引导你分析一个典型场景：在二维结构化网格上使用自然排序法。通过从头推导，你将把问题的几何结构与矩阵的代数属性（即带宽）联系起来，并量化其对 Cholesky 分解计算成本的影响。这项实践旨在揭示为何看似简单的排序策略可能导致计算成本过高，为后续理解更高级的稀疏直解法奠定坚实的理论基础 。",
            "id": "3309508",
            "problem": "在计算流体力学 (CFD) 中，一个对称正定 (SPD) 线性系统源于压力泊松方程的标准有限差分离散化。考虑在单位正方形上使用 $n \\times n$ 内部点的笛卡尔网格进行均匀离散化，采用五点 ($5$-point) 有限差分格式和狄利克雷边界条件，得到 $N = n^{2}$ 个未知数。使用行主序字典序，即映射 $(i,j) \\mapsto k = i + (j-1)n$，其中 $i,j \\in \\{1,\\dots,n\\}$。\n\n从第一性原理出发：\n- 利用五点格式的结构和该映射，推导出最终得到的对称正定矩阵 $A \\in \\mathbb{R}^{N \\times N}$ 的稀疏模式。\n- 将矩阵的半带宽 $w$ 定义为 $w = \\max\\{|i-j| : A_{ij} \\neq 0\\}$（在给定排序下），并用 $n$ 来表示 $w$。\n- 利用对称正定带状矩阵的 Cholesky 分解的基本循环结构，论证带状结构如何限定内积和秩一更新中的索引范围，并从第一性原理出发，推导出计算和存储 Cholesky 因子 $L$ 所需的渐近主阶浮点运算计数和存储量（用 $N$ 和 $w$ 表示）。\n\n然后，用 $n$ 消去 $N$ 和 $w$，并仅报告主阶浮点运算计数，形式为一个只含 $n$ 的单一闭式渐近表达式（忽略乘法常数）。你的最终答案必须是那个只含 $n$ 的单一表达式，不带单位，也不使用大O表示法。",
            "solution": "该问题陈述在科学上是合理的、内容是自洽的、并且是适定的。它描述了数值线性代数中一个源于椭圆偏微分方程有限差分离散化的典型问题。验证过程证实了其有效性，因此将提供解答。\n\n问题要求计算在 $n \\times n$ 网格上使用五点有限差分格式所产生的矩阵 $A$ 进行 Cholesky 分解的渐近主阶浮点运算 (flop) 计数。求解过程需要推导矩阵的结构及其带宽，然后基于此结构分析分解的计算复杂度。\n\n首先，我们确定矩阵 $A \\in \\mathbb{R}^{N \\times N}$ 的结构，其中 $N=n^2$。未知数采用行主序字典序进行排序，其中网格点 $(i,j)$（$i$ 为列索引，$j$ 为行索引，对于 $i,j \\in \\{1,\\dots,n\\}$）被映射到单个索引 $k = i + (j-1)n$。\n\n网格点 $(i,j)$ 处的五点格式将其与四个紧邻点耦合：$(i-1,j)$、$(i+1,j)$、$(i,j-1)$ 和 $(i,j+1)$。这意味着矩阵 $A$ 中对应于 $(i,j)$ 处未知数的行，将有非零元连接到这些邻点的未知数。让我们确定这些网格点对应的线性索引：\n- 点 $(i,j)$：索引 $k = i + (j-1)n$。这对应于对角元素 $A_{k,k}$。\n- 西侧邻点 $(i-1,j)$：索引 $l_W = (i-1)+(j-1)n = k-1$。这对应于 $A_{k, k-1}$。\n- 东侧邻点 $(i+1,j)$：索引 $l_E = (i+1)+(j-1)n = k+1$。这对应于 $A_{k, k+1}$。\n- 南侧邻点 $(i,j-1)$：索引 $l_S = i+(j-2)n = k-n$。这对应于 $A_{k, k-n}$。\n- 北侧邻点 $(i,j+1)$：索引 $l_N = i+(j)n = k+n$。这对应于 $A_{k, k+n}$。\n\n这些连接对网格的内部点有效。对于靠近区域边界的点，一些邻点会落在 $n \\times n$ 内部点集合之外。由于指定了狄利克雷边界条件，这些连接不会在 $N$ 个未知数之间引入新的依赖关系。\n\n因此，非零元 $A_{k,l}$ 位于 $l \\in \\{k-n, k-1, k, k+1, k+n\\}$ 的位置。由于这种离散化产生的矩阵 $A$ 是对称的，所以 $A_{kl} = A_{lk}$。$A$ 的结构是一个对称块三对角矩阵，其中对角块是三对角的，非对角块是对角的（在差一个标量因子的情况下是单位矩阵）。\n\n半带宽 $w$ 定义为 $w = \\max\\{|k-l| : A_{k,l} \\neq 0\\}$。从索引差集合 $\\{1, n\\}$ 来看，最大值为 $n$。因此，半带宽为 $w=n$。\n\n接下来，我们分析 Cholesky 分解 $A = LL^T$，其中 $L$ 是一个下三角矩阵。对于带状矩阵的分解，一个关键特性是其因子 $L$ 在很大程度上保留了带状结构。对于一个半带宽为 $w$ 的矩阵 $A$，其 Cholesky 因子 $L$ 的下半带宽也为 $w$。也就是说，当 $i-j  w$ 时，$L_{ij} = 0$。$L$ 的非零元都包含在这个带内。\n\n$L$ 的元素计算是逐列进行的，从 $j=1$ 到 $N$。其公式为：\n$$L_{jj} = \\sqrt{A_{jj} - \\sum_{k=1}^{j-1} L_{jk}^2}$$\n$$L_{ij} = \\frac{1}{L_{jj}} \\left( A_{ij} - \\sum_{k=1}^{j-1} L_{ik} L_{jk} \\right) \\quad \\text{for } i  j$$\n\n我们通过分析一个远离边界的通用列 $j$（即 $jw$ 且 $N-jw$）的操作数，从这些公式中推导出渐近浮点运算计数。一个浮点运算可以是一次乘法或一次加法。\n\n1.  **对角元素 $L_{jj}$ 的成本**：求和 $\\sum_{k=1}^{j-1} L_{jk}^2$ 只涉及 $L_{jk} \\neq 0$ 的项。由于 $L$ 的带状结构，这意味着 $j-k \\le w$，所以 $k \\ge j-w$。该求和实际上是从 $k=j-w$ 到 $k=j-1$，包含 $w$ 个项。这构成了一个长度为 $w$ 的向量与其自身的点积，需要 $w$ 次乘法和 $w-1$ 次加法，总计 $2w-1$ 次浮点运算。\n\n2.  **非对角元素 $L_{ij}$ 的成本**：我们只需计算带内的 $L_{ij}$，即 $j  i \\le j+w$。对于每个这样的 $i$，成本主要由点积 $\\sum_{k=1}^{j-1} L_{ik} L_{jk}$ 决定。此和中的项非零，当且仅当 $L_{ik} \\neq 0$ 和 $L_{jk} \\neq 0$ 同时成立。这意味着 $k \\ge i-w$ 和 $k \\ge j-w$。由于 $ij$，更严格的条件是 $k \\ge i-w$。因此，求和的范围是从 $k=i-w$ 到 $k=j-1$。项数为 $(j-1) - (i-w) + 1 = j-i+w$。令 $d=i-j$，其中 $d \\in \\{1, 2, \\dots, w\\}$。项数为 $w-d$。点积需要 $w-d$ 次乘法和 $w-d-1$ 次加法，总计 $2(w-d)-1$ 次浮点运算。\n\n3.  **每列 $j$ 的总成本**：将 $L_{jj}$ 和所有相关 $L_{ij}$ 的成本相加：\n$$ \\text{Flops}_j \\approx (2w-1) + \\sum_{i=j+1}^{j+w} (2(j-i+w)-1) $$\n代入 $d=i-j$，求和变为：\n$$ \\sum_{d=1}^{w} (2(w-d)-1) = 2\\sum_{d=1}^{w}(w-d) - \\sum_{d=1}^{w}1 = 2\\left(\\sum_{k=0}^{w-1}k\\right) - w = 2\\frac{(w-1)w}{2} - w = w^2 - w - w = w^2 - 2w $$\n第 $j$ 列的总浮点运算量约为 $(2w-1) + (w^2-2w) = w^2-1$。每列工作量的主阶项是 $w^2$。\n\n4.  **总浮点运算计数**：为了得到总的渐近运算计数，我们将所有 $N$ 列的成本相加：\n$$ \\text{Total Flops} = \\sum_{j=1}^{N} \\text{Flops}_j \\approx \\sum_{j=1}^{N} w^2 = N w^2 $$\n\n最后，我们用 $n$ 来表示这个计数。我们有 $N = n^2$ 并且推导出 $w=n$。将这些代入浮点运算计数表达式中，得到：\n$$ \\text{Total Flops} \\approx (n^2)(n)^2 = n^4 $$\n\n问题要求忽略乘法常数并提供主阶表达式。推导出的表达式 $n^4$ 即是此结果。\n\n至于存储量，必须计算 Cholesky 因子 $L$ 中的非零元数量。对于每一列 $j$，我们存储元素 $L_{ij}$，其中 $j \\le i \\le \\min(N, j+w)$。对于大多数列，这需要存储 $w+1$ 个元素。因此，总存储量为 $\\sum_{j=1}^{N} (w+1) \\approx Nw$。用 $n$ 代替 $N$ 和 $w$ 得到存储复杂度为 $(n^2)(n) = n^3$。然而，问题只要求提供最终的浮点运算计数表达式。",
            "answer": "$$\\boxed{n^{4}}$$"
        },
        {
            "introduction": "在了解了基础排序策略的局限性后，我们自然会问：能否做得更好？本练习将带你探索一种更先进的“分而治之”策略——嵌套剖分（Nested Dissection）排序法。你将以一个更具挑战性的三维问题为背景，分析这种高级排序如何重塑填充模式，并从理论上推导其计算复杂度的量级。通过这个练习，你将领略到高级排序算法的力量，并深入理解直接求解器在处理高维问题时所面临的“维度灾难” 。",
            "id": "3309443",
            "problem": "考虑一个对称正定稀疏线性系统。该系统源于计算流体力学(CFD)中，通过对单位立方体上大小为 $n \\times n \\times n$ 的规则笛卡尔网格上的三维泊松方程(拉普拉斯算子)进行有限差分或有限体积离散化而得到，产生 $N = n^{3}$ 个未知数。其邻接图为标准的 $7$ 点模板。假设该系统通过多波前直接法求解，采用几何嵌套剖分(ND)排序。该排序以 $z, y, x$ 的重复顺序，使用轴对齐的分隔面递归地划分立方体，直到子域达到常数大小。\n\n对于每个分隔面上的多波前成本，使用以下经过充分检验的建模假设：\n1. 与基数（节点数）为 $s$ 的分隔面相关联的波前矩阵，在其分解时是一个大小为 $s \\times s$ 的稠密矩阵。\n2. 一个稠密的 $s \\times s$ 对称正定矩阵的 Cholesky 分解需要 $\\frac{1}{3}s^{3}$ 次浮点运算(flops)。\n3. 存储一个稠密的 $s \\times s$ 矩阵的(下三角)Cholesky因子所需的存储量为 $\\frac{1}{2}s(s+1)$ 个数值，渐进地为 $\\frac{1}{2}s^{2}$。\n\n从这些基础出发，并结合嵌套剖分在 $n \\times n \\times n$ 网格上所隐含的分隔面几何结构，请从第一性原理推导多波前分解的主阶渐进浮点运算量和内存占用，表示为关于 $n$ 的显式闭式表达式，然后将它们重写为关于 $N = n^{3}$ 的表达式。在您的推导过程中，请指明哪些分隔面层级在总计算量和总存储量中占主导地位，并解释原因。忽略低阶项，如分解之外的组装成本和次主导存储(例如，严格上三角项)，但不要先验地假设任何目标复杂度。\n\n请提供您的最终答案，形式为一对主阶表达式：浮点运算量为 $c_{f}N^{2}$，内存占用为 $c_{m}N^{4/3}$，其中显式常数 $c_{f}$ 和 $c_{m}$ 是在上述假设下得到的。不需要数值舍入，也不涉及物理单位。您最终提交的答案必须仅为这两个表达式。",
            "solution": "该问题是有效的，因为它提出了一个数值线性代数领域中适定的、有科学依据的问题。它提供了一个清晰的分析模型，该模型基于标准概念：泊松方程、嵌套剖分排序和多波前直接求解器。所有关于几何结构和计算成本的必要假设都已明确说明。我们现在将从第一性原理出发推导其复杂度。\n\n分析分三个阶段进行：首先，我们确定对一个一般立方体子域进行单次三步（先 $z$，再 $y$，后 $x$）划分的成本。其次，我们将这些成本在递归剖分的所有层级上求和。最后，我们将得到的总成本表示为总未知数 $N$ 的函数。\n\n让我们考虑递归嵌套剖分中的一个一般步骤，该步骤应用于边长为 $m$ 的网格立方体子域。该过程涉及将这个 $m \\times m \\times m$ 的立方体划分为八个边长为 $m/2$ 的子立方体。这是通过一系列三种类型的分隔面来实现的。\n\n1.  **z-分隔面：** 首先，立方体被一个 $z$ 方向的分隔面平分。这个分隔面是一个大小为 $m \\times m$ 的单一平面网格。\n    分隔面大小（节点数）为 $s_z = m^{2}$。\n    根据问题的假设，与分解此分隔面的波前矩阵相关的成本是：\n    *   浮点运算：$F_z = \\frac{1}{3}s_z^{3} = \\frac{1}{3}(m^{2})^{3} = \\frac{1}{3}m^{6}$。\n    *   内存：$M_z = \\frac{1}{2}s_z^{2} = \\frac{1}{2}(m^{2})^{2} = \\frac{1}{2}m^{4}$。\n\n2.  **y-分隔面：** 最初的 $z$ 切割创建了两个大小为 $m \\times m \\times m/2$ 的子域。然后，每个子域再被一个 $y$ 方向的分隔面平分。\n    共有 $2$ 个这样的分隔面。每个分隔面是一个大小为 $m \\times m/2$ 的平面网格。\n    分隔面大小为 $s_y = m \\cdot (m/2) = \\frac{m^{2}}{2}$。\n    这两个分隔面的总成本是：\n    *   浮点运算：$F_y = 2 \\times \\left(\\frac{1}{3}s_y^{3}\\right) = \\frac{2}{3}\\left(\\frac{m^{2}}{2}\\right)^{3} = \\frac{2}{3}\\frac{m^{6}}{8} = \\frac{1}{12}m^{6}$。\n    *   内存：$M_y = 2 \\times \\left(\\frac{1}{2}s_y^{2}\\right) = \\left(\\frac{m^{2}}{2}\\right)^{2} = \\frac{1}{4}m^{4}$。\n\n3.  **x-分隔面：** 两个 $y$ 切割创建了四个大小为 $m \\times m/2 \\times m/2$ 的子域。然后，每个子域再被一个 $x$ 方向的分隔面平分。\n    共有 $4$ 个这样的分隔面。每个分隔面是一个大小为 $m/2 \\times m/2$ 的平面网格。\n    分隔面大小为 $s_x = (m/2) \\cdot (m/2) = \\frac{m^{2}}{4}$。\n    这四个分隔面的总成本是：\n    *   浮点运算：$F_x = 4 \\times \\left(\\frac{1}{3}s_x^{3}\\right) = \\frac{4}{3}\\left(\\frac{m^{2}}{4}\\right)^{3} = \\frac{4}{3}\\frac{m^{6}}{64} = \\frac{1}{48}m^{6}$。\n    *   内存：$M_x = 4 \\times \\left(\\frac{1}{2}s_x^{2}\\right) = 2\\left(\\frac{m^{2}}{4}\\right)^{2} = 2\\frac{m^{4}}{16} = \\frac{1}{8}m^{4}$。\n\n在 $m \\times m \\times m$ 立方体上进行一轮完整的 $z, y, x$ 划分（此过程产生8个大小为 $m/2 \\times m/2 \\times m/2$ 的子立方体）的总成本是这三个步骤成本的总和。\n在 $m$-立方体上进行一级递归的总浮点运算量 $C_F(m)$：\n$$C_F(m) = F_z + F_y + F_x = \\frac{1}{3}m^{6} + \\frac{1}{12}m^{6} + \\frac{1}{48}m^{6} = m^{6}\\left(\\frac{16+4+1}{48}\\right) = \\frac{21}{48}m^{6} = \\frac{7}{16}m^{6}$$\n在 $m$-立方体上进行一级递归的总内存占用 $C_M(m)$：\n$$C_M(m) = M_z + M_y + M_x = \\frac{1}{2}m^{4} + \\frac{1}{4}m^{4} + \\frac{1}{8}m^{4} = m^{4}\\left(\\frac{4+2+1}{8}\\right) = \\frac{7}{8}m^{4}$$\n\n现在，我们将这些成本在递归的所有层级上求和。递归从完整的 $n \\times n \\times n$ 立方体开始。设递归层级由 $j$ 索引，从 $j=0$ 开始。在第 $j$ 层，我们有 $8^{j}$ 个子问题，每个子问题作用于边长为 $m_j = n/2^{j}$ 的立方体。递归持续进行，直到子域的大小为常数，这在渐进分析中对应于 $\\log_2(n)$ 个层级。\n\n总浮点运算量 $F_{total}(n)$ 是所有层级成本的总和：\n$$F_{total}(n) = \\sum_{j=0}^{\\log_2(n)-1} 8^{j} C_F(m_j) = \\sum_{j=0}^{\\log_2(n)-1} 8^{j} \\frac{7}{16} \\left(\\frac{n}{2^{j}}\\right)^{6} = \\frac{7n^{6}}{16} \\sum_{j=0}^{\\log_2(n)-1} \\frac{8^{j}}{(2^{6})^{j}}$$\n$$F_{total}(n) = \\frac{7n^{6}}{16} \\sum_{j=0}^{\\log_2(n)-1} \\left(\\frac{8}{64}\\right)^{j} = \\frac{7n^{6}}{16} \\sum_{j=0}^{\\log_2(n)-1} \\left(\\frac{1}{8}\\right)^{j}$$\n这是一个公比为 $r = 1/8$ 的几何级数。当 $n \\to \\infty$ 时，其和收敛到 $\\frac{1}{1-r} = \\frac{1}{1-1/8} = \\frac{8}{7}$。\n主阶渐进浮点运算量为：\n$$F_{total}(n) \\approx \\frac{7n^{6}}{16} \\cdot \\frac{8}{7} = \\frac{1}{2}n^{6}$$\n\n总内存占用 $M_{total}(n)$ 是所有层级存储量的总和：\n$$M_{total}(n) = \\sum_{j=0}^{\\log_2(n)-1} 8^{j} C_M(m_j) = \\sum_{j=0}^{\\log_2(n)-1} 8^{j} \\frac{7}{8} \\left(\\frac{n}{2^{j}}\\right)^{4} = \\frac{7n^{4}}{8} \\sum_{j=0}^{\\log_2(n)-1} \\frac{8^{j}}{(2^{4})^{j}}$$\n$$M_{total}(n) = \\frac{7n^{4}}{8} \\sum_{j=0}^{\\log_2(n)-1} \\left(\\frac{8}{16}\\right)^{j} = \\frac{7n^{4}}{8} \\sum_{j=0}^{\\log_2(n)-1} \\left(\\frac{1}{2}\\right)^{j}$$\n这是一个公比为 $r=1/2$ 的几何级数。前 $\\log_2(n)$ 项的和为 $\\frac{1-(1/2)^{\\log_2(n)}}{1-1/2} = \\frac{1-1/n}{1/2} = 2(1-1/n)$。\n主阶渐进内存占用为：\n$$M_{total}(n) \\approx \\frac{7n^{4}}{8} \\cdot 2 = \\frac{7}{4}n^{4}$$\n\n这些结果表明，递归的顶层在总成本中占主导地位。对于浮点运算量和内存占用，成本都是形如 $\\sum_{j} C_j$ 的和，其中 $C_j$ 是第 $j$ 层的成本。连续层级之间的成本比率，对于浮点运算是 $8 \\cdot (1/2)^6 = 1/8$，对于内存是 $8 \\cdot (1/2)^4 = 1/2$。由于这两个比率都小于1，几何级数收敛，并且第一项（$j=0$，对应于原始 $n \\times n \\times n$ 域的分隔面）是最大的。这一项贡献了总浮点运算量的 $7/8$ 和总内存占用的 $1/2$，证实了最大、最顶层的分隔面在总成本中占主导地位。\n\n最后，我们将这些结果用总未知数 $N=n^{3}$ 来表示。\n浮点运算量：\n$$F_{total}(N) = \\frac{1}{2}n^{6} = \\frac{1}{2}(n^{3})^{2} = \\frac{1}{2}N^{2}$$\n内存占用：\n$$M_{total}(N) = \\frac{7}{4}n^{4} = \\frac{7}{4}(n^{3})^{4/3} = \\frac{7}{4}N^{4/3}$$\n因此，常数为 $c_f = 1/2$ 和 $c_m = 7/4$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{1}{2}N^{2}  \\frac{7}{4}N^{4/3} \\end{pmatrix} } $$"
        },
        {
            "introduction": "理论上的运算量（flop counts）只是故事的一部分，实际应用中的数值行为同样至关重要。本编程练习将引导你从理论走向实践，通过代码探索一个核心权衡：通过矩阵重排（ordering）来最小化填充（fill-in）以节省内存和时间，与通过主元选取（pivoting）来维持数值稳定性之间的矛盾。你将亲手构建一个源于各向异性扩散问题的稀疏矩阵，并观察其在不同求解策略下的填充率和主元增长情况，从而获得宝贵的实践经验 。",
            "id": "3309525",
            "problem": "设计并实现一个完整的、可运行的程序，通过量化网格和系数各向异性下的填充（fill-in）和主元选择（pivoting）行为，来评估源于计算流体动力学中二维扩散问题的稀疏线性系统直接求解器的鲁棒性。起点是在矩形域上的扩散算子 $-\\nabla \\cdot (K \\nabla u)$，其扩散张量 $K = \\mathrm{diag}(k_x, k_y)$ 为常数且与坐标轴对齐。该算子使用标准的二阶中心差分在间距为 $h_x$ 和 $h_y$ 的均匀笛卡尔网格上进行离散化。这将产生一个线性系统 $A \\, \\mathbf{u} = \\mathbf{b}$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个稀疏矩阵，对于内部网格维度为 $N_x \\times N_y$ 的情况，$n = N_x N_y$，并采用齐次狄利克雷边界条件（边界值已从系统中消去）。以此为基础，您的程序必须：\n- 将 $A$ 构造为一个具有块结构的稀疏矩阵，其五点模板对应于算子 $-k_x \\, \\partial_{xx} u - k_y \\, \\partial_{yy} u$。每个内部节点的离散系数在主对角线上为 $2 \\, \\alpha_x + 2 \\, \\alpha_y$，在紧邻的水平邻居上为 $-\\alpha_x$，在紧邻的垂直邻居上为 $-\\alpha_y$，其中 $\\alpha_x = k_x / h_x^2$ 且 $\\alpha_y = k_y / h_y^2$。\n- 对于每个问题实例，使用三种列置换策略计算带部分主元选择的 $\\mathrm{LU}$ 分解：自然排序、列近似最小度（Column Approximate Minimum Degree），以及在 $A^\\top + A$ 上的多重最小度（Multiple Minimum Degree）。\n- 对于每次分解，计算：\n    1) 填充率，定义为 $\\rho_{\\mathrm{fill}} = \\dfrac{\\mathrm{nnz}(L) + \\mathrm{nnz}(U)}{\\mathrm{nnz}(A)}$，其中 $\\mathrm{nnz}(\\cdot)$ 表示非零元素的数量，$L$ 和 $U$ 是直接求解器产生的因子。\n    2) 主元增长因子，定义为 $\\gamma = \\dfrac{\\max_{i,j} |U_{ij}|}{\\max_{i,j} |A_{ij}|}$。\n- 对于每个问题实例，报告两个量：三种排序中的最小填充率和三种排序中的最坏情况主元增长因子。对于每个测试用例，应按此顺序输出这两个值。\n\n您的实现必须仅依赖于基本定义和经过充分测试的算法：\n- 如上所述，在矩形网格上使用中心差分对 $-\\nabla \\cdot (K \\nabla u)$ 进行有限差分离散化。\n- 用于直接求解的带部分主元选择的高斯消元法（即 $\\mathrm{LU}$ 分解），以及将填充理解为在 $L$ 和 $U$ 中引入的、超出 $A$ 中原有非零元素的新非零元素的标准解释。\n- 如上定义的主元增长因子，作为直接求解器的一个标准稳定性指标。\n\n测试套件（程序必须为这四组参数精确计算结果）：\n- 案例 $1$（退化的最小网格）：$(N_x, N_y, k_x, k_y, h_x, h_y) = (1, 1, 1.0, 1.0, 1.0, 1.0)$。\n- 案例 $2$（各向同性，中等网格）：$(N_x, N_y, k_x, k_y, h_x, h_y) = (30, 30, 1.0, 1.0, 1.0, 1.0)$。\n- 案例 $3$（高系数各向异性）：$(N_x, N_y, k_x, k_y, h_x, h_y) = (30, 30, 10^{-8}, 1.0, 1.0, 1.0)$。\n- 案例 $4$（网格各向异性）：$(N_x, N_y, k_x, k_y, h_x, h_y) = (80, 5, 1.0, 1.0, 0.01, 1.0)$。\n\n输出要求：\n- 对于每个案例，计算三种置换中的最小填充率和三种置换中的最大主元增长因子。\n- 将每个报告的浮点值四舍五入到六位有效数字。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身是一个形式为 $[\\rho_{\\min}, \\gamma_{\\max}]$ 的双元素列表，且不含空格。例如，输出格式必须类似于 $[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]]$，其中每个 $a_i$ 和 $b_i$ 是案例 $i$ 的四舍五入后的浮点数。\n\n不涉及物理单位，也不使用角度。所有输出均为实值浮点数。输入必须嵌入在程序中；不需要用户输入。",
            "solution": "用户提供了一个来自数值分析领域的有效且适定的问题陈述，特别关注稀疏线性系统直接求解器的性能。该问题在科学上基于二维扩散方程的标准有限差分离散化，这是计算流体动力学和其他计算科学领域的一个基本问题。所有术语、度量标准和程序都定义清晰，并与数值线性代数中已建立的概念相对应。所提供的测试用例经过精心选择，旨在探究算法在不同网格和系数各向异性条件下的行为。因此，该问题经验证有效，并将提供解决方案。\n\n问题的核心是构造一个表示离散扩散算子的稀疏矩阵 $A$，然后分析其在不同列重排策略下的 LU 分解。分析重点关注两个关键指标：填充率 $\\rho_{\\mathrm{fill}}$，它衡量了分解的内存开销；以及主元增长因子 $\\gamma$，它是分解过程数值稳定性的一个指标。\n\n**1. 矩阵构造**\n问题始于各向异性扩散的偏微分方程（PDE）：\n$$\n-\\nabla \\cdot (K \\nabla u) = f\n$$\n在一个具有常数对角扩散张量 $K = \\mathrm{diag}(k_x, k_y)$ 的矩形域上，该方程展开为：\n$$\n-k_x \\frac{\\partial^2 u}{\\partial x^2} - k_y \\frac{\\partial^2 u}{\\partial y^2} = f\n$$\n我们在间距为 $h_x$ 和 $h_y$ 的均匀笛卡尔网格上离散化此方程。该网格包含 $N_x \\times N_y$ 个内部节点。对内部节点 $(i,j)$ 处的二阶导数使用二阶中心差分近似，我们得到：\n$$\n-k_x \\left(\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2}\\right) - k_y \\left(\\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}\\right) = f_{i,j}\n$$\n重新整理各项，得到关于 $u_{i,j}$ 的线性方程：\n$$\n\\left(\\frac{2k_x}{h_x^2} + \\frac{2k_y}{h_y^2}\\right) u_{i,j} - \\frac{k_x}{h_x^2} u_{i-1,j} - \\frac{k_x}{h_x^2} u_{i+1,j} - \\frac{k_y}{h_y^2} u_{i,j-1} - \\frac{k_y}{h_y^2} u_{i,j+1} = f_{i,j}\n$$\n定义 $\\alpha_x = k_x / h_x^2$ 和 $\\alpha_y = k_y / h_y^2$，方程简化为：\n$$\n(2\\alpha_x + 2\\alpha_y) u_{i,j} - \\alpha_x u_{i-1,j} - \\alpha_x u_{i+1,j} - \\alpha_y u_{i,j-1} - \\alpha_y u_{i,j+1} = f_{i,j}\n$$\n这对应于一个 $5$ 点模板。为了构建系统 $A\\mathbf{u}=\\mathbf{b}$ 的矩阵 $A$，我们将二维未知数网格 $u_{i,j}$ 映射到一个大小为 $n = N_x N_y$ 的一维向量 $\\mathbf{u}$。这里使用标准的列主序映射，其中节点 $(i,j)$（$i \\in [0, N_x-1], j \\in [0, N_y-1]$）的索引 $k$ 为 $k = j \\cdot N_x + i$。这种映射将网格同一列的节点在向量中连续放置。在此排序下，模板连接转化为距主对角线特定偏移处的矩阵元素：\n-   主对角线上的元素位于 $(k, k)$，对应于 $(2\\alpha_x + 2\\alpha_y)u_{i,j}$ 项。\n-   紧邻的次对角线元素位于 $(k, k-1)$ 和 $(k, k+1)$，用于水平耦合项 $-\\alpha_x u_{i-1,j}$ 和 $-\\alpha_x u_{i+1,j}$。\n-   较远的次对角线元素位于 $(k, k-N_x)$ 和 $(k, k+N_x)$，用于垂直耦合项 $-\\alpha_y u_{i,j-1}$ 和 $-\\alpha_y u_{i,j+1}$。\n\n最终得到的矩阵 $A$ 是稀疏的、结构对称的、并且是块三对角矩阵。它也是一个 M-矩阵和正定矩阵，这对求解器的稳定性有重要影响。\n\n**2. LU 分解与分析**\n直接求解器通过将 $A$ 分解为下三角矩阵 ($L$) 和上三角矩阵 ($U$) 的乘积来求解 $A\\mathbf{u}=\\mathbf{b}$。为了保证数值稳定性，采用了部分主元法，这涉及到行交换。这导致了分解形式 $P A = L U$，其中 $P$ 是表示行交换的置换矩阵。\n\n填充（fill-in），即在 $L$ 和 $U$ 中 $A$ 的零元素位置上创建新的非零元素，高度依赖于行和列的排序。为了最小化填充，使用了预排序策略。问题指定了分析 $A$ 的三种列置换策略：\n1.  **自然排序**：不执行重排。\n2.  **列近似最小度 (COLAMD)**：一种启发式算法，通过置换列来减少填充，常用于非对称矩阵。\n3.  **在 $A^\\top + A$ 上的多重最小度 (MMD_ATA)**：一种用于对称矩阵的强大启发式算法，它根据矩阵图中节点的度来对节点进行排序。由于我们的 $A$ 是结构对称的，这等同于在 $A$ 上使用 MMD。\n\n对于每一种排序，我们将执行带部分主元选择的 LU 分解。这是通过将列置换 $C$ 应用于 $A$ 得到 $A_c = AC$，然后分解 $P A_c = LU$ 来完成的。SciPy 函数 `scipy.sparse.linalg.splu` 提供了一个到高性能 SuperLU 库的接口，可以精确执行此操作。\n\n**3. 指标计算**\n对于每次分解，计算定义的两个指标：\n-   **填充率**：$\\rho_{\\mathrm{fill}} = \\dfrac{\\mathrm{nnz}(L) + \\mathrm{nnz}(U)}{\\mathrm{nnz}(A)}$。这里，$\\mathrm{nnz}(\\cdot)$ 是非零元素的计数。此指标量化了因子相对于原始矩阵的内存成本。值越低越好。我们将直接从求解器返回的 $L$ 和 $U$ 的稀疏矩阵对象的 `.nnz` 属性中获取 $\\mathrm{nnz}(L)$ 和 $\\mathrm{nnz}(U)$。\n-   **主元增长因子**：$\\gamma = \\dfrac{\\max_{i,j} |U_{ij}|}{\\max_{i,j} |A_{ij}|}$。这衡量了消元过程中元素大小的增长，是数值稳定性的一个关键指标。大的 $\\gamma$ 值表明可能存在精度损失。因为 $A$ 是一个 M-矩阵，$\\max|A_{ij}|$ 就是 $2\\alpha_x + 2\\alpha_y$，而 $\\max|U_{ij}|$ 则通过检查计算出的因子 $U$ 的非零元素来找到。\n\n虽然原始矩阵 $A$ 是对角占优的，这通常意味着主元增长因子 $\\gamma \\le 1$，但是保持稀疏性的列置换可能会破坏置换后矩阵 $A_c$ 的这种结构。这可能需要进行行主元选择，并可能导致主元增长 $\\gamma  1$，这突显了稀疏性与数值稳定性之间的权衡。\n\n**4. 最终报告**\n对于每个测试用例，程序将对所有三种排序执行分解，为每种排序计算两个指标，然后报告在三种排序中观察到的最小填充率和最大主元增长因子。这为给定的问题实例提供了最佳情况下的内存性能和最坏情况下的稳定性摘要。最终结果按要求格式化为六位有效数字。",
            "answer": "```python\nimport numpy as np\nimport scipy.sparse\nimport scipy.sparse.linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Case 1 (degenerate minimal grid)\n        (1, 1, 1.0, 1.0, 1.0, 1.0),\n        # Case 2 (isotropic, moderate grid)\n        (30, 30, 1.0, 1.0, 1.0, 1.0),\n        # Case 3 (high coefficient anisotropy)\n        (30, 30, 1e-8, 1.0, 1.0, 1.0),\n        # Case 4 (mesh anisotropy)\n        (80, 5, 1.0, 1.0, 0.01, 1.0),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        rho_min, gamma_max = analyze_case(*params)\n        # Format results to 6 significant digits and no whitespace within the pair.\n        all_results.append(f\"[{rho_min:.6g},{gamma_max:.6g}]\")\n    \n    # Print the final list of results in the required format.\n    print(f\"[{','.join(all_results)}]\")\n\n\ndef analyze_case(Nx, Ny, kx, ky, hx, hy):\n    \"\"\"\n    Analyzes a single problem instance: constructs the sparse matrix,\n    computes LU factorizations with different orderings, and determines\n    the min fill-in ratio and max pivot growth.\n    \"\"\"\n    n = Nx * Ny\n    if n == 0:\n        return 0.0, 1.0\n\n    alpha_x = kx / hx**2\n    alpha_y = ky / hy**2\n    \n    diag_val = 2 * alpha_x + 2 * alpha_y\n    \n    # Construct the sparse matrix A using COOrdinate format for efficiency\n    row_ind = []\n    col_ind = []\n    data = []\n\n    for j in range(Ny):\n        for i in range(Nx):\n            k = j * Nx + i\n            \n            # Main diagonal\n            row_ind.append(k)\n            col_ind.append(k)\n            data.append(diag_val)\n            \n            # Horizontal neighbors (x-direction)\n            if i  0:\n                row_ind.append(k)\n                col_ind.append(k - 1)\n                data.append(-alpha_x)\n            if i  Nx - 1:\n                row_ind.append(k)\n                col_ind.append(k + 1)\n                data.append(-alpha_x)\n            \n            # Vertical neighbors (y-direction)\n            if j  0:\n                row_ind.append(k)\n                col_ind.append(k - Nx)\n                data.append(-alpha_y)\n            if j  Ny - 1:\n                row_ind.append(k)\n                col_ind.append(k + Nx)\n                data.append(-alpha_y)\n\n    A = scipy.sparse.coo_matrix((data, (row_ind, col_ind)), shape=(n, n))\n    A_csc = A.tocsc() # splu requires CSC or CSR format\n\n    nnz_A = A_csc.nnz\n    # For an M-matrix, the max absolute value is the diagonal element.\n    max_abs_A = diag_val if diag_val  0 else 1.0\n\n    orderings = ['NATURAL', 'COLAMD', 'MMD_AT_PLUS_A']\n    fill_ratios = []\n    pivot_growths = []\n\n    for ordering in orderings:\n        # Perform LU factorization with partial pivoting\n        lu = scipy.sparse.linalg.splu(A_csc, permc_spec=ordering)\n        \n        # 1. Calculate Fill-in Ratio\n        # Per problem spec: (nnz(L) + nnz(U)) / nnz(A)\n        nnz_L_U = lu.L.nnz + lu.U.nnz\n        fill_ratio = nnz_L_U / nnz_A\n        fill_ratios.append(fill_ratio)\n        \n        # 2. Calculate Pivot Growth Factor\n        # max(|U_ij|) / max(|A_ij|)\n        if lu.U.nnz  0:\n            max_abs_U = np.max(np.abs(lu.U.data))\n        else:\n            max_abs_U = 0.0\n        \n        pivot_growth = max_abs_U / max_abs_A\n        pivot_growths.append(pivot_growth)\n\n    min_fill_ratio = min(fill_ratios)\n    max_pivot_growth = max(pivot_growths)\n    \n    return min_fill_ratio, max_pivot_growth\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}