{
    "hands_on_practices": [
        {
            "introduction": "为了在实际的多维模拟中应用通量矢量分裂，必须以一种独立于网格方向的方式扩展一维概念。本练习将引导您推导van Leer分裂通量的旋转不变形式，并实施数值测试以验证这一关键属性 。掌握这一点可确保您的数值格式无论在哪种坐标系下都能提供物理上一致的结果。",
            "id": "3387357",
            "problem": "考虑二维无粘可压缩欧拉方程，它是一个关于状态向量 $U = [\\rho, \\rho u, \\rho v, \\rho E]^\\top$ 的守恒律系统，其中 $\\rho$ 是密度，$(u,v)$ 是速度的笛卡尔分量，$E$ 是比总能。设比热比为 $\\gamma$，热力学压力为 $p$，声速为 $a = \\sqrt{\\gamma p / \\rho}$。比总焓为 $H = E + p / \\rho$。通过外单位法向量为 $\\mathbf{n} = (n_x, n_y)$ 的面的通量是法向通量 $F_n(U)$，它通过将物理通量投影到方向 $\\mathbf{n}$ 上得到。\n\n从欧拉方程和热力学量的定义出发，推导一种 van Leer 意义上的多维通量矢量分裂（FVS），该分裂仅依赖于法向马赫数 $M_n = (\\mathbf{u} \\cdot \\mathbf{n}) / a$ 和热力学标量。具体来说，构造分裂通量 $F_n^+(U)$ 和 $F_n^-(U)$，使得 $F_n(U) = F_n^+(U) + F_n^-(U)$，并且每个分裂通量都通过 $M_n$ 依赖于相对于面法线方向的波传播符号。证明当分裂通量写为 $F_n^\\pm(U) = F^\\pm(U;\\,M_n)$ 时，它是旋转不变的，即如果坐标系通过正交变换旋转，并且 $\\mathbf{n}$ 也相应地旋转，则分裂通量的动量分量会像一个真正的矢量一样变换，而质量和能量分量则保持为不变的标量。\n\n使用以下基础：\n- 欧拉方程的守恒形式及其旋转不变性。\n- 将法向通量分解为对流和压力功的贡献，每个贡献都可以用 $\\rho$、$(u,v)$、$p$、$a$、$H$ 和面法向量 $\\mathbf{n}$ 表示。\n- 通过将速度投影到 $\\mathbf{n}$ 上来定义法向马赫数 $M_n$。\n\n在推导过程中，您不得假设或陈述任何预先推导出的 van Leer 公式。您必须从第一性原理出发进行推导，确保其与守恒形式和沿面法线方向的特征速度相一致。\n\n在推导多维分裂通量并证明其旋转不变性之后，实现一个程序，该程序：\n- 构建一个马赫数为 $M_\\infty = 2$ 的均匀超音速自由来流，其中 $\\gamma = 1.4$，密度 $\\rho_\\infty = 1.225$ 千克/立方米，压力 $p_\\infty = 101325$ 帕斯卡。计算相应的声速 $a_\\infty$ 和自由来流速度大小 $U_\\infty = M_\\infty a_\\infty$。\n- 定义一个笛卡尔网格，其外向面法向量为 $\\mathbf{n}_x = (1,0)$ 和 $\\mathbf{n}_y = (0,1)$，以及一个由角度 $\\theta$（以弧度为单位）旋转的自由来流速度方向。\n- 对于每个面法向量和每个测试角度，使用您的多维 van Leer FVS 计算分裂通量 $F_n^\\pm(U)$，并独立地通过将状态旋转到面法向坐标系中，沿对齐的法向应用一维分裂，然后将分裂通量的动量分量旋转回原始坐标系来计算它们。\n- 对于每个测试角度，报告直接计算的分裂通量与旋转坐标系计算的分裂通量之间的最大绝对差（涵盖两个面和两种符号）。\n\n角度单位说明：所有角度均使用弧度。\n\n您的程序必须实现所述方法，并为以下自由来流角度测试套件生成结果：\n- $\\theta_1 = 0$（与 $x$ 轴对齐），\n- $\\theta_2 = \\pi/3$（对于 $x$ 面，法向马赫数等于 $1$），\n- $\\theta_3 = \\pi/4$，\n- $\\theta_4 = -\\pi/6$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4]”）。每个结果都必须是一个浮点数，等于上述的最大绝对差。由于这些差异是无量纲的，因此输出不需要物理单位。程序必须是自包含的，不得读取任何输入，并且必须使用指定的运行时环境。",
            "solution": "该问题要求为二维欧拉方程推导一个旋转不变的多维 van Leer 通量矢量分裂（FVS），证明其旋转不变性，并进行数值验证。\n\n### 第 1 部分：多维 van Leer 分裂通量的推导\n\n我们从守恒形式的二维无粘可压缩欧拉方程开始：\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial F_x(U)}{\\partial x} + \\frac{\\partial F_y(U)}{\\partial y} = 0\n$$\n其中状态向量 $U$ 和笛卡尔通量向量 $F_x(U)$ 与 $F_y(U)$ 由下式给出：\n$$\nU = \\begin{pmatrix} \\rho \\\\ \\rho u \\\\ \\rho v \\\\ \\rho E \\end{pmatrix}, \\quad\nF_x(U) = \\begin{pmatrix} \\rho u \\\\ \\rho u^2 + p \\\\ \\rho uv \\\\ \\rho u H \\end{pmatrix}, \\quad\nF_y(U) = \\begin{pmatrix} \\rho v \\\\ \\rho uv \\\\ \\rho v^2 + p \\\\ \\rho v H \\end{pmatrix}\n$$\n这里，$\\rho$ 是密度，$\\mathbf{u} = (u,v)$ 是速度矢量，$p$ 是压力，$E = \\frac{p}{(\\gamma-1)\\rho} + \\frac{1}{2}(u^2+v^2)$ 是比总能，$H = E + p/\\rho$ 是比总焓，$\\gamma$ 是比热比。\n\n通过具有外向单位法向量 $\\mathbf{n} = (n_x, n_y)$ 的表面的通量是法向通量 $F_n(U)$，它通过将笛卡尔通量投影到 $\\mathbf{n}$ 上得到：\n$$\nF_n(U) = F_x(U) n_x + F_y(U) n_y = \\begin{pmatrix} \\rho(un_x + vn_y) \\\\ (\\rho u^2+p)n_x + (\\rho uv)n_y \\\\ (\\rho uv)n_x + (\\rho v^2+p)n_y \\\\ (\\rho u H)n_x + (\\rho v H)n_y \\end{pmatrix}\n$$\n令 $u_n = \\mathbf{u} \\cdot \\mathbf{n} = u n_x + v n_y$ 为速度的法向分量。法向通量可以写为：\n$$\nF_n(U) = \\begin{pmatrix} \\rho u_n \\\\ \\rho u u_n + p n_x \\\\ \\rho v u_n + p n_y \\\\ \\rho H u_n \\end{pmatrix}\n$$\n为了使结构在坐标旋转下保持不变，我们使用矢量表示法来表达动量分量：\n$$\nF_n(U) = \\begin{pmatrix} \\rho u_n \\\\ \\rho \\mathbf{u} u_n + p \\mathbf{n} \\\\ \\rho H u_n \\end{pmatrix}\n$$\n通量矢量分裂（FVS）的目标是将 $F_n(U)$ 分解为两部分，$F_n^+(U)$ 和 $F_n^-(U)$，使得 $F_n(U) = F_n^+(U) + F_n^-(U)$。这种分裂基于垂直于面的信息传播方向。欧拉方程在法向方向的特征速度是通量雅可比矩阵 $\\partial F_n / \\partial U$ 的特征值，即 $\\lambda_1 = u_n - a$，$\\lambda_{2,3} = u_n$ 和 $\\lambda_4 = u_n + a$，其中 $a = \\sqrt{\\gamma p / \\rho}$ 是声速。分裂通量 $F_n^+$ 和 $F_n^-$ 的构造使得雅可比矩阵 $\\partial F_n^+ / \\partial U$ 具有非负特征值，而 $\\partial F_n^- / \\partial U$ 具有非正特征值。\n\nvan Leer 分裂格式通过使分裂依赖于法向马赫数 $M_n = u_n / a$ 来实现这一点。\n\n**超音速流 ($|M_n| \\ge 1$)：**\n在超音速流中，所有特征波都沿同一方向传播。\n- 如果 $M_n \\ge 1$，流动是向下游进行的。所有信息随流而动，因此整个通量都与正向相关联。\n  $$ F_n^+(U) = F_n(U), \\quad F_n^-(U) = 0 $$\n- 如果 $M_n \\le -1$，流动是向上游进行的。所有信息都与正法线方向相反移动。\n  $$ F_n^+(U) = 0, \\quad F_n^-(U) = F_n(U) $$\n\n**亚音速流（$|M_n|  1$）：**\n在亚音速流中，声波 $(u_n \\pm a)$ 向相反方向传播。通量必须被分裂为与这些方向相关联的分量。我们遵循将一维 van Leer 分裂扩展为多维、旋转不变形式的原则。关键在于从旋转不变的标量和正确变换的矢量来构造分裂通量矢量。\n\n我们定义分裂质量通量 $f_m^\\pm$ 和分裂压力 $p^\\pm$：\n1.  **分裂质量通量：** 总质量通量为 $f_m = \\rho u_n$。对于 $|M_n|  1$，van Leer 的多项式分裂为：\n    $$ f_m^\\pm(M_n) = \\pm \\frac{1}{4} \\rho a (M_n \\pm 1)^2 $$\n    其和正确地重构了总质量通量：$f_m^+ + f_m^- = \\frac{1}{4}\\rho a[(M_n+1)^2 - (M_n-1)^2] = \\frac{1}{4}\\rho a[4M_n] = \\rho a M_n = \\rho u_n$。\n2.  **分裂压力：** 总压力贡献 $p$ 根据声波的传播进行分裂。对于 $|M_n|  1$，多项式分裂为：\n    $$ p^\\pm(M_n) = p \\cdot \\frac{1}{4} (M_n \\pm 1)^2 (2 \\mp M_n) $$\n    其和正确地重构了总压力：$p^+ + p^- = \\frac{p}{4}[ (M_n^2+2M_n+1)(2-M_n) + (M_n^2-2M_n+1)(2+M_n) ] = \\frac{p}{4}[ (-M_n^3+3M_n+2) + (M_n^3-3M_n+2) ] = p$。\n\n使用这些分裂的标量，我们通过从一维情况推广结构来构造多维分裂通量矢量 $F_n^\\pm$。总通量分量可以解释为质量通量 ($\\rho u_n$)、动量通量 ($\\rho \\mathbf{u} u_n + p \\mathbf{n}$) 和能量通量 ($\\rho H u_n = (\\rho u_n) H$)。我们类似地组装分裂通量：\n$$\nF_n^\\pm(U) = \\begin{pmatrix} f_m^\\pm \\\\ f_m^\\pm \\mathbf{u} + p^\\pm \\mathbf{n} \\\\ f_m^\\pm H \\end{pmatrix}\n$$\n这种形式将标量 $f_m^\\pm$ 和 $p^\\pm$ 与矢量 $\\mathbf{u}$ 和 $\\mathbf{n}$ 结合起来。各项为：\n- 质量分量：$f_m^\\pm$\n- 动量分量：$f_m^\\pm \\mathbf{u} + p^\\pm \\mathbf{n}$\n- 能量分量：$f_m^\\pm H$\n\n对于 $|M_n|  1$，$F_n^+ + F_n^-$ 的和正确地恢复了全通量 $F_n(U)$。分裂函数和超音速截断确保了分裂通量在 $M_n = \\pm 1$ 处的连续性和可微性。\n\n### 第 2 部分：旋转不变性的证明\n\n为了证明分裂是旋转不变的，我们必须表明在任意坐标系正交旋转下，分裂通量的形式保持一致。设 $T$ 是一个正交旋转矩阵 ($T^\\top T = I$)。在旋转后的坐标系中，矢量变换为 $\\mathbf{v}' = T\\mathbf{v}$，而标量保持不变。\n- 带撇号的量表示旋转后的坐标系。\n- 标量热力学性质是不变的：$\\rho' = \\rho$，$p' = p$，$a' = a$，$E' = E$，$H' = H$。\n- 速度和法向量的变换如下：$\\mathbf{u}' = T\\mathbf{u}$ 和 $\\mathbf{n}' = T\\mathbf{n}$。\n\n关键步骤是检查法向马赫数 $M_n$ 的变换性质。旋转坐标系中的法向速度为：\n$$\nu_n' = \\mathbf{u}' \\cdot \\mathbf{n}' = (T\\mathbf{u}) \\cdot (T\\mathbf{n}) = (T\\mathbf{u})^\\top (T\\mathbf{n}) = \\mathbf{u}^\\top T^\\top T \\mathbf{n} = \\mathbf{u}^\\top I \\mathbf{n} = \\mathbf{u} \\cdot \\mathbf{n} = u_n\n$$\n由于 $u_n$ 是一个旋转不变量（一个真标量），$a$ 也是一个标量，因此法向马赫数是不变的：\n$$\nM_n' = u_n' / a' = u_n / a = M_n\n$$\n因为分裂质量通量 $f_m^\\pm$ 和分裂压力 $p^\\pm$ 仅依赖于 $\\rho, p, a$ 和 $M_n$，而这些都是旋转不变量，所以这些量也是不变的：\n$$\nf_m'^\\pm = f_m^\\pm, \\quad p'^\\pm = p^\\pm\n$$\n现在，我们检查分裂通量矢量 $F_n^\\pm(U)$ 的变换。它在旋转坐标系中的分量 $F_{n'}^\\pm(U')$ 是：\n$$\nF_{n'}^\\pm(U') = \\begin{pmatrix} f_m'^\\pm \\\\ f_m'^\\pm \\mathbf{u}' + p'^\\pm \\mathbf{n}' \\\\ f_m'^\\pm H' \\end{pmatrix}\n= \\begin{pmatrix} f_m^\\pm \\\\ f_m^\\pm (T\\mathbf{u}) + p^\\pm (T\\mathbf{n}) \\\\ f_m^\\pm H \\end{pmatrix}\n= \\begin{pmatrix} f_m^\\pm \\\\ T(f_m^\\pm \\mathbf{u} + p^\\pm \\mathbf{n}) \\\\ f_m^\\pm H \\end{pmatrix}\n$$\n这个结果表明：\n1.  质量分量 $f_m^\\pm$ 是一个标量，并且正确地保持不变。\n2.  能量分量 $f_m^\\pm H$ 是一个标量，并且正确地保持不变。\n3.  动量分量 $f_m^\\pm \\mathbf{u} + p^\\pm \\mathbf{n}$ 的变换方式为 $T(f_m^\\pm \\mathbf{u} + p^\\pm \\mathbf{n})$，这是一个矢量的正确变换规则。\n\n分裂公式的结构与坐标系的选择无关。它仅依赖于内在的、与坐标无关的量（标量和矢量）。这便完成了旋转不变性的证明。问题的数值部分将通过比较直接计算和涉及显式旋转的计算来验证此性质。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and verifies the rotational invariance of a multidimensional\n    van Leer Flux Vector Splitting scheme for the 2D Euler equations.\n    \"\"\"\n\n    # 1. Define problem constants and free-stream conditions\n    gamma = 1.4\n    rho_inf = 1.225  # kg/m^3\n    p_inf = 101325.0  # Pa\n    M_inf = 2.0\n\n    a_inf = np.sqrt(gamma * p_inf / rho_inf)\n    U_inf_mag = M_inf * a_inf\n    E_inf = p_inf / ((gamma - 1) * rho_inf) + 0.5 * U_inf_mag**2\n    H_inf = E_inf + p_inf / rho_inf\n\n    # State primitives (constant for the free stream)\n    rho, p, a, E, H = rho_inf, p_inf, a_inf, E_inf, H_inf\n\n    test_cases = [\n        0.0,          # Aligned with x-axis\n        np.pi / 3,    # Mn = 1 for x-face\n        np.pi / 4,    # General supersonic case\n        -np.pi / 6,   # Mn = -1 for y-face\n    ]\n\n    normals = [\n        np.array([1.0, 0.0]),  # x-face\n        np.array([0.0, 1.0]),  # y-face\n    ]\n\n    results = []\n\n    def get_split_flux_direct(u_vec, n_vec):\n        \"\"\"Computes split fluxes F+ and F- directly using the multidimensional formula.\"\"\"\n        u, v = u_vec\n        nx, ny = n_vec\n\n        un = u * nx + v * ny\n        Mn = un / a\n\n        F_plus = np.zeros(4)\n        F_minus = np.zeros(4)\n\n        if Mn = 1.0:\n            F_plus[0] = rho * un\n            F_plus[1] = rho * u * un + p * nx\n            F_plus[2] = rho * v * un + p * ny\n            F_plus[3] = rho * H * un\n        elif Mn = -1.0:\n            F_minus[0] = rho * un\n            F_minus[1] = rho * u * un + p * nx\n            F_minus[2] = rho * v * un + p * ny\n            F_minus[3] = rho * H * un\n        else: # |Mn|  1.0\n            # Split mass flux\n            fm_plus = rho * a * 0.25 * (Mn + 1.0)**2\n            fm_minus = -rho * a * 0.25 * (Mn - 1.0)**2\n            # Split pressure\n            p_plus = p * 0.25 * (Mn + 1.0)**2 * (2.0 - Mn)\n            p_minus = p * 0.25 * (Mn - 1.0)**2 * (2.0 + Mn)\n\n            # Assemble F+\n            F_plus[0] = fm_plus\n            F_plus[1] = fm_plus * u + p_plus * nx\n            F_plus[2] = fm_plus * v + p_plus * ny\n            F_plus[3] = fm_plus * H\n\n            # Assemble F-\n            F_minus[0] = fm_minus\n            F_minus[1] = fm_minus * u + p_minus * nx\n            F_minus[2] = fm_minus * v + p_minus * ny\n            F_minus[3] = fm_minus * H\n            \n        return F_plus, F_minus\n\n    def get_split_flux_rotated(u_vec, n_vec):\n        \"\"\"Computes split fluxes by rotating, applying 1D split, and rotating back.\"\"\"\n        u, v = u_vec\n        nx, ny = n_vec\n\n        # Rotated velocity components\n        un = u * nx + v * ny  # Normal velocity\n        ut = -u * ny + v * nx # Tangential velocity\n        Mn = un / a\n\n        F_plus_rot = np.zeros(4)\n        F_minus_rot = np.zeros(4)\n\n        if Mn = 1.0:\n            F_plus_rot[0] = rho * un\n            F_plus_rot[1] = rho * un * un + p\n            F_plus_rot[2] = rho * un * ut\n            F_plus_rot[3] = rho * H * un\n        elif Mn = -1.0:\n            F_minus_rot[0] = rho * un\n            F_minus_rot[1] = rho * un * un + p\n            F_minus_rot[2] = rho * un * ut\n            F_minus_rot[3] = rho * H * un\n        else: # |Mn|  1.0\n            fm_plus = rho * a * 0.25 * (Mn + 1.0)**2\n            fm_minus = -rho * a * 0.25 * (Mn - 1.0)**2\n            p_plus = p * 0.25 * (Mn + 1.0)**2 * (2.0 - Mn)\n            p_minus = p * 0.25 * (Mn - 1.0)**2 * (2.0 + Mn)\n\n            # Assemble F+ in rotated frame\n            F_plus_rot[0] = fm_plus\n            F_plus_rot[1] = fm_plus * un + p_plus\n            F_plus_rot[2] = fm_plus * ut\n            F_plus_rot[3] = fm_plus * H\n\n            # Assemble F- in rotated frame\n            F_minus_rot[0] = fm_minus\n            F_minus_rot[1] = fm_minus * un + p_minus\n            F_minus_rot[2] = fm_minus * ut\n            F_minus_rot[3] = fm_minus * H\n\n        # Rotate momentum components back to original frame\n        F_plus_final = np.copy(F_plus_rot)\n        F_plus_final[1] = F_plus_rot[1] * nx - F_plus_rot[2] * ny\n        F_plus_final[2] = F_plus_rot[1] * ny + F_plus_rot[2] * nx\n\n        F_minus_final = np.copy(F_minus_rot)\n        F_minus_final[1] = F_minus_rot[1] * nx - F_minus_rot[2] * ny\n        F_minus_final[2] = F_minus_rot[1] * ny + F_minus_rot[2] * nx\n\n        return F_plus_final, F_minus_final\n\n    for theta in test_cases:\n        max_abs_diff_for_angle = 0.0\n        \n        # 2. Get free-stream velocity vector for the current angle\n        u = U_inf_mag * np.cos(theta)\n        v = U_inf_mag * np.sin(theta)\n        u_vec = np.array([u, v])\n\n        for n_vec in normals:\n            # 3. Method 1: Direct multidimensional calculation\n            F_plus_direct, F_minus_direct = get_split_flux_direct(u_vec, n_vec)\n\n            # 4. Method 2: Rotated frame calculation\n            F_plus_rotated, F_minus_rotated = get_split_flux_rotated(u_vec, n_vec)\n\n            # 5. Compare results and update max difference\n            diff_plus = np.max(np.abs(F_plus_direct - F_plus_rotated))\n            diff_minus = np.max(np.abs(F_minus_direct - F_minus_rotated))\n            \n            max_abs_diff_for_angle = max(max_abs_diff_for_angle, diff_plus, diff_minus)\n\n        results.append(max_abs_diff_for_angle)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "数值格式的性能从根本上由其截断误差决定，这些误差会引入非物理的耗散和色散。本练习深入探讨了二阶van Leer格式的修正方程分析，这是一种量化这些误差的强大技术 。通过识别主要的误差项，您将更深入地理解该格式的精度及其在光滑流场中的行为。",
            "id": "3387412",
            "problem": "考虑量热完全气体的一维无粘可压缩欧拉方程，该方程在一个具有恒定密度 $\\rho_{0}$、速度 $u_{0}$ 和压力 $p_{0}$ 的均匀状态附近进行线性化。令声速为 $a_{0} = \\sqrt{\\gamma p_{0}/\\rho_{0}}$，并定义马赫数 $M = u_{0}/a_{0}$。假设存在光滑的等熵扰动，使得特征场解耦，其波速分别为 $u_{0} - a_{0}$、$u_{0}$ 和 $u_{0} + a_{0}$。我们关注速度为 $\\lambda_{+} = u_{0} + a_{0} = a_{0}(M + 1)$ 的右行声学特征。\n\n在一个间距为 $\\Delta x$ 的均匀网格上，考虑一个采用 van Leer 通量矢量分裂（FVS）的半离散有限体积格式，该格式通过线性重构获得二阶空间精度。在特征变量中，对于右行声学场且 $M  -1$ 的情况，van Leer FVS 在界面 $i+\\tfrac{1}{2}$ 处的数值通量简化为与 $\\lambda_{+}$ 相关联的正通量，该通量作用于从单元 $i$ 重构的左状态。对右行声波的特征振幅 $w$ 使用以下分段线性、迎风偏置的重构方法：\n$$\nw^{L}_{i+\\frac{1}{2}} = w_{i} + \\frac{1}{2}\\left(w_{i} - w_{i-1}\\right),\n$$\n且不使用限制器。$w_{i}(t)$ 的半离散有限体积更新方程为\n$$\n\\frac{d w_{i}}{d t} = -\\frac{1}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\n其中数值通量为 $F_{i+\\frac{1}{2}} = \\lambda_{+}\\, w^{L}_{i+\\frac{1}{2}}$ 和 $F_{i-\\frac{1}{2}} = \\lambda_{+}\\, w^{L}_{i-\\frac{1}{2}}$。\n\n使用关于在 $x = x_{i}$ 处求值的光滑解 $w(x,t)$ 的修正方程（泰勒级数）分析，推导此二阶 van Leer FVS 格式的截断误差，在空间离散误差中保留至 $\\mathcal{O}(\\Delta x^{3})$ 阶的项。通过将修正方程写成以下规范形式，来辨识主要的色散和耗散贡献：\n$$\nw_{t} + \\lambda_{+}\\, w_{x} = C_{3}\\, \\Delta x^{2}\\, w_{xxx} - C_{4}\\, \\Delta x^{3}\\, w_{xxxx} + \\mathcal{O}(\\Delta x^{4}),\n$$\n其中，$C_{3}$ 是领头的奇数阶导数（色散）项的系数，$C_{4}$ 是与超粘性意义下领头的偶数阶导数（耗散）项相关的正系数。将 $C_{3}$ 和 $C_{4}$ 符号化地表示为 $M$、$a_{0}$ 和 $\\Delta x$ 的函数。以行向量 $\\left[C_{3}\\ \\ C_{4}\\right]$ 的形式提供最终答案。不需要四舍五入，应将结果保留为精确的符号形式。最终方框内的答案不需要物理单位。",
            "solution": "用户希望针对一个应用于标量线性平流方程的特定二阶有限体积格式，推导出其修正偏微分方程。该平流方程代表了线性化欧拉方程的一个特征场。目标是辨识领头的色散和耗散误差项的系数。\n\n问题从单元 $i$ 中特征振幅 $w_{i}$ 的半离散有限体积方程开始：\n$$\n\\frac{d w_{i}}{d t} = -\\frac{1}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right)\n$$\n其中 $\\Delta x$ 是均匀网格间距。\n\n界面处的数值通量 $F$ 由 van Leer 通量矢量分裂（FVS）格式给出。对于速度为 $\\lambda_{+} = u_{0} + a_{0}  0$ （因为 $M = u_0/a_0  -1$）的右行声波，通量是纯迎风的。这意味着界面 $i+\\frac{1}{2}$ 处的通量由从左侧（即从单元 $i$）重构的状态确定。\n$$\nF_{i+\\frac{1}{2}} = \\lambda_{+}\\, w^{L}_{i+\\frac{1}{2}}\n$$\n问题指定了界面左侧值 $w^{L}_{i+\\frac{1}{2}}$ 的分段线性、迎风偏置重构方法：\n$$\nw^{L}_{i+\\frac{1}{2}} = w_{i} + \\frac{1}{2}\\left(w_{i} - w_{i-1}\\right) = \\frac{3}{2}w_{i} - \\frac{1}{2}w_{i-1}\n$$\n将此代入通量表达式，我们得到：\n$$\nF_{i+\\frac{1}{2}} = \\lambda_{+}\\left(\\frac{3}{2}w_{i} - \\frac{1}{2}w_{i-1}\\right)\n$$\n为了求得前一个界面 $F_{i-\\frac{1}{2}}$ 处的通量，我们将索引减一：\n$$\nF_{i-\\frac{1}{2}} = \\lambda_{+}\\left(\\frac{3}{2}w_{i-1} - \\frac{1}{2}w_{i-2}\\right)\n$$\n现在，我们可以计算半离散更新所需的通量差：\n$$\nF_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}} = \\lambda_{+}\\left[ \\left(\\frac{3}{2}w_{i} - \\frac{1}{2}w_{i-1}\\right) - \\left(\\frac{3}{2}w_{i-1} - \\frac{1}{2}w_{i-2}\\right) \\right]\n$$\n$$\nF_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}} = \\lambda_{+}\\left( \\frac{3}{2}w_{i} - 2w_{i-1} + \\frac{1}{2}w_{i-2} \\right)\n$$\n将此代回半离散方程，得到 $\\frac{d w_{i}}{d t}$ 方程的右侧（RHS）：\n$$\n\\frac{d w_{i}}{d t} = -\\frac{\\lambda_{+}}{\\Delta x}\\left( \\frac{3}{2}w_{i} - 2w_{i-1} + \\frac{1}{2}w_{i-2} \\right)\n$$\n为了进行修正方程分析，我们假设 $w_i = w(x_i, t)$ 是光滑函数 $w(x, t)$ 在网格点 $x_i$ 处的值。我们将 $w_{i-1}$ 和 $w_{i-2}$ 项在 $x_i$ 附近展开为泰勒级数。设对 $x$ 的偏导数用下标表示，例如，$w_x = \\frac{\\partial w}{\\partial x}$，在 $(x_i, t)$ 处求值。\n$$\nw_{i-1} = w(x_i - \\Delta x) = w_i - w_x \\Delta x + \\frac{w_{xx}}{2!} \\Delta x^2 - \\frac{w_{xxx}}{3!} \\Delta x^3 + \\frac{w_{xxxx}}{4!} \\Delta x^4 - \\dots\n$$\n$$\nw_{i-2} = w(x_i - 2\\Delta x) = w_i - w_x (2\\Delta x) + \\frac{w_{xx}}{2!} (2\\Delta x)^2 - \\frac{w_{xxx}}{3!} (2\\Delta x)^3 + \\frac{w_{xxxx}}{4!} (2\\Delta x)^4 - \\dots\n$$\n我们将这些展开式代入括号中的表达式，记为 $S$：\n$$\nS = \\frac{3}{2}w_{i} - 2w_{i-1} + \\frac{1}{2}w_{i-2}\n$$\n$$\nS = \\frac{3}{2}w_i - 2\\left(w_i - w_x \\Delta x + \\frac{w_{xx}}{2}\\Delta x^2 - \\frac{w_{xxx}}{6}\\Delta x^3 + \\frac{w_{xxxx}}{24}\\Delta x^4 + \\dots\\right) + \\frac{1}{2}\\left(w_i - 2w_x\\Delta x + 2w_{xx}\\Delta x^2 - \\frac{4}{3}w_{xxx}\\Delta x^3 + \\frac{2}{3}w_{xxxx}\\Delta x^4 + \\dots\\right)\n$$\n现在我们按空间导数的阶数对各项进行分组：\n- $w_i$ 的系数： $\\frac{3}{2} - 2 + \\frac{1}{2} = 0$。\n- $w_x$ 的系数： $-2(-1)\\Delta x + \\frac{1}{2}(-2)\\Delta x = (2-1)\\Delta x = \\Delta x$。\n- $w_{xx}$ 的系数： $-2\\left(\\frac{1}{2}\\right)\\Delta x^2 + \\frac{1}{2}(2)\\Delta x^2 = (-1+1)\\Delta x^2 = 0$。这证实了该格式至少是二阶精度的。\n- $w_{xxx}$ 的系数： $-2\\left(-\\frac{1}{6}\\right)\\Delta x^3 + \\frac{1}{2}\\left(-\\frac{4}{3}\\right)\\Delta x^3 = \\left(\\frac{1}{3} - \\frac{2}{3}\\right)\\Delta x^3 = -\\frac{1}{3}\\Delta x^3$。\n- $w_{xxxx}$ 的系数： $-2\\left(\\frac{1}{24}\\right)\\Delta x^4 + \\frac{1}{2}\\left(\\frac{2}{3}\\right)\\Delta x^4 = \\left(-\\frac{1}{12} + \\frac{1}{3}\\right)\\Delta x^4 = \\left(-\\frac{1}{12} + \\frac{4}{12}\\right)\\Delta x^4 = \\frac{3}{12}\\Delta x^4 = \\frac{1}{4}\\Delta x^4$。\n\n合并这些项，$S$ 的展开式为：\n$$\nS = (w_x \\Delta x) + 0 - \\frac{1}{3}w_{xxx}\\Delta x^3 + \\frac{1}{4}w_{xxxx}\\Delta x^4 + \\mathcal{O}(\\Delta x^5)\n$$\n半离散方程的右侧，即 $w_t$ 的近似值，变为：\n$$\n\\frac{d w_{i}}{d t} \\approx -\\frac{\\lambda_{+}}{\\Delta x} \\left( w_x \\Delta x - \\frac{1}{3}w_{xxx}\\Delta x^3 + \\frac{1}{4}w_{xxxx}\\Delta x^4 + \\mathcal{O}(\\Delta x^5) \\right)\n$$\n$$\nw_t = -\\lambda_{+} w_x + \\frac{\\lambda_{+}}{3} \\Delta x^2 w_{xxx} - \\frac{\\lambda_{+}}{4} \\Delta x^3 w_{xxxx} + \\mathcal{O}(\\Delta x^4)\n$$\n通过整理此表达式得到修正方程。该格式旨在求解的原始偏微分方程是 $w_t + \\lambda_+ w_x = 0$。修正方程包含了截断误差项：\n$$\nw_t + \\lambda_{+} w_x = \\frac{\\lambda_{+}}{3} \\Delta x^2 w_{xxx} - \\frac{\\lambda_{+}}{4} \\Delta x^3 w_{xxxx} + \\mathcal{O}(\\Delta x^4)\n$$\n问题要求将其写成规范形式：\n$$\nw_{t} + \\lambda_{+}\\, w_{x} = C_{3}\\, \\Delta x^{2}\\, w_{xxx} - C_{4}\\, \\Delta x^{3}\\, w_{xxxx} + \\mathcal{O}(\\Delta x^{4})\n$$\n通过将我们推导的方程与目标形式进行比较，我们可以辨识出系数 $C_3$ 和 $C_4$：\n$$\nC_3 = \\frac{\\lambda_{+}}{3}\n$$\n$$\n-C_4 = -\\frac{\\lambda_{+}}{4} \\implies C_4 = \\frac{\\lambda_{+}}{4}\n$$\n系数 $C_3$ 乘以领头的色散误差项 ($w_{xxx}$)，而 $C_4$ 乘以领头的耗散误差项 ($w_{xxxx}$)。问题陈述 $M  -1$，这确保了 $\\lambda_{+} = u_0 + a_0  0$。因此，$C_4$ 是正的，对应于耗散效应（对高波数振荡的阻尼）。\n\n最后，我们用给定的参数 $a_0$ 和 $M$ 来表示这些系数。已知 $\\lambda_{+} = u_0 + a_0$ 和 $M=u_0/a_0$，这意味着 $u_0 = M a_0$。将此代入 $\\lambda_{+}$ 的表达式中：\n$$\n\\lambda_{+} = M a_0 + a_0 = a_0(M + 1)\n$$\n因此，系数为：\n$$\nC_3 = \\frac{a_0(M+1)}{3}\n$$\n$$\nC_4 = \\frac{a_0(M+1)}{4}\n$$\n最终答案是行向量 $[C_3 \\ \\ C_4]$。\n$$\n\\begin{pmatrix} \\frac{a_0(M+1)}{3}  \\frac{a_0(M+1)}{4} \\end{pmatrix}\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{a_{0}(M+1)}{3}  \\frac{a_{0}(M+1)}{4} \\end{pmatrix}}$$"
        },
        {
            "introduction": "虽然标准分裂函数提供了良好的平衡，但高级应用可能需要针对特定现象进行微调。本练习从分析转向设计，将分裂函数的构建框定为一个约束优化问题 。您将学习如何将物理目标——例如清晰的激波捕捉和精确的接触间断保持——转化为数学成本函数，然后求解最优的多项式系数。",
            "id": "3387417",
            "problem": "您的任务是在计算流体动力学（CFD）学科领域内，为一维可压缩流中的 van Leer 通量矢量分裂（flux vector splitting）形式化并解决一个参数辨识问题。其基本原理是基于一维可压缩欧拉方程给出的双曲守恒律，以及通量矢量分裂的原则，即将通量分解为与波族相关的前向和后向传播分量。马赫数 $M$ 在构建对流-声学分裂中起着核心作用。设计目标是调整基于马赫数的分裂系数 $g^\\pm(M)$，以在激波分辨率、接触间断保持和声学色散控制之间实现均衡折衷。\n\n定义马赫数分裂 $g^\\pm(M)$，使得 $g^+(M) + g^-(M) = M$，并且函数是连续可微的（$g^\\pm \\in C^1$）。对于超音速区域，正分裂采用上风-超音速延拓，\n$$\ng^+(M) = \\frac{1}{2}(M + |M|),\n$$\n其中，对于 $M \\ge 1$，正分支等于 $g^+(M) = M$；对于 $M \\le -1$，正分支等于 $g^+(M) = 0$。这在 van Leer 型格式中是标准做法。在亚音速区间 $|M|  1$ 内，通过一个五次多项式对正分裂进行参数化，\n$$\ng^+(M) = a_0 + a_1 M + a_2 M^2 + a_3 M^3 + a_4 M^4 + a_5 M^5,\n$$\n并通过精确和约束为 $|M|  1$ 定义 $g^-(M)$\n$$\ng^-(M) = M - g^+(M).\n$$\n为在音速边界上强制实现 $C^1$ 连续性，在 $M = 1$ 和 $M = -1$ 处施加 $C^1$ 匹配条件：\n$$\ng^+(1) = 1,\\quad \\frac{d}{dM}g^+(1) = 1,\\quad g^+(-1) = 0,\\quad \\frac{d}{dM}g^+(-1) = 0.\n$$\n这些是关于系数 $a_0,\\dots,a_5$ 的线性等式约束。\n\n使用加权和构建一个优化目标，以平衡三个设计准则：\n- 激波厚度代理 $E_s$：使用亚音速导数与超音速上风导数之间的偏差，在音速点 $M = 1$ 附近加重权重，\n$$\nE_s(a_0,\\dots,a_5) = \\int_{0}^{1} M^2 \\left(1 - \\frac{d}{dM}g^+(M)\\right)^2\\, dM.\n$$\n- 接触保持代理 $E_c$：要求在 $M = 0$ 处具有对称中心性，惩罚正分支在零马赫数时偏离均等分裂的情况，\n$$\nE_c(a_0,\\dots,a_5) = \\left(g^+(0) - \\frac{1}{2}\\right)^2 = \\left(a_0 - \\frac{1}{2}\\right)^2.\n$$\n- 声学色散代理 $E_a$：惩罚 $M = 0$ 附近的曲率，以减少小振幅声波的色散，方法是在对称区间 $[-\\delta,\\delta]$（给定半宽 $\\delta$）上使用二阶导数的平方 $L^2$ 范数，\n$$\nE_a(a_0,\\dots,a_5) = \\int_{-\\delta}^{\\delta} \\left(\\frac{d^2}{dM^2} g^+(M)\\right)^2\\, dM,\n$$\n其中 $\\delta = \\frac{1}{2}$。\n\n设权重为 $w_s$、$w_c$ 和 $w_a$，并定义总目标\n$$\nJ(a_0,\\dots,a_5) = w_s\\,E_s + w_c\\,E_c + w_a\\,E_a.\n$$\n您的任务是：\n- 导出系数向量 $\\mathbf{a} = [a_0,\\dots,a_5]^T$ 的约束二次优化问题，其中包含四个线性等式约束，以强制实现 $M = \\pm 1$ 处的 $C^1$ 连续性。\n- 实现一个求解器，通过求解带有线性等式约束的二次目标的 Karush–Kuhn–Tucker 系统来计算最优系数 $\\mathbf{a}^\\star$。$E_s$ 和 $E_a$ 中的积分必须通过多项式积分进行解析计算，而不是数值计算。\n- 对每个测试用例，评估最小化目标值 $J(\\mathbf{a}^\\star)$。\n\n积分使用以下固定参数：$E_s$ 的权重函数指数为 $p = 2$，使得被积函数包含 $M^2$；$E_a$ 的区间半宽为 $\\delta = \\frac{1}{2}$，如上所述。\n\n测试套件：\n- 情况 1：$(w_s,w_c,w_a) = (1,1,1)$。\n- 情况 2：$(w_s,w_c,w_a) = (100,1,1)$。\n- 情况 3：$(w_s,w_c,w_a) = (1,1,100)$。\n- 情况 4：$(w_s,w_c,w_a) = (1,100,1)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。外层列表中的每个条目对应上述顺序的一个测试用例，并且必须是一个包含7个浮点数的内层列表：六个优化后的系数 $[a_0,a_1,a_2,a_3,a_4,a_5]$，后跟最小化目标值 $J(\\mathbf{a}^\\star)$。每个浮点数必须四舍五入到六位小数。例如：\n$$\n\\left[\\left[a_0,a_1,a_2,a_3,a_4,a_5,J\\right]_{\\text{case }1},\\left[a_0,a_1,a_2,a_3,a_4,a_5,J\\right]_{\\text{case }2},\\left[a_0,a_1,a_2,a_3,a_4,a_5,J\\right]_{\\text{case }3},\\left[a_0,a_1,a_2,a_3,a_4,a_5,J\\right]_{\\text{case }4}\\right].\n$$\n此问题不涉及物理单位；所有量均为无量纲。不出现角度，也不需要百分比表示。",
            "solution": "用户提供的问题是计算流体动力学领域中一个适定的参数辨识任务。它要求通过最小化一个带权重的目标函数来确定通量分裂函数多项式表示的最优系数，并受线性约束限制。这属于带等式约束的凸二次规划问题，其唯一解可通过 Karush-Kuhn-Tucker (KKT) 条件获得。\n\n解决方案主要分三个阶段进行：\n1.  将目标函数和约束形式化为矩阵-向量的二次规划格式。\n2.  构建 KKT 系统，这是一个关于最优系数和拉格朗日乘子的线性方程组。\n3.  对测试套件中提供的每组权重求解 KKT 系统，并计算相应的最小化目标值。\n\n**1. 形式化为约束二次规划**\n\n问题在于找到系数向量 $\\mathbf{a} = [a_0, a_1, a_2, a_3, a_4, a_5]^T$，使其在满足一组线性等式约束的条件下，最小化目标函数 $J(\\mathbf{a})$。\n\n目标函数为\n$$\nJ(\\mathbf{a}) = w_s E_s(\\mathbf{a}) + w_c E_c(\\mathbf{a}) + w_a E_a(\\mathbf{a}).\n$$\n该函数可以表示为一般的二次形式\n$$\nJ(\\mathbf{a}) = \\frac{1}{2}\\mathbf{a}^T \\mathbf{Q} \\mathbf{a} + \\mathbf{c}^T \\mathbf{a} + d,\n$$\n其中 $\\mathbf{Q}$ 是一个对称的 $6 \\times 6$ 半正定矩阵（Hessian 矩阵），$\\mathbf{c}$ 是一个 $6 \\times 1$ 的向量，$d$ 是一个标量常数。总量是每个代理误差项贡献的总和：\n$$\n\\mathbf{Q} = w_s \\mathbf{Q}_s + w_c \\mathbf{Q}_c + w_a \\mathbf{Q}_a, \\quad \\mathbf{c} = w_s \\mathbf{c}_s + w_c \\mathbf{c}_c + w_a \\mathbf{c}_a, \\quad d = w_s d_s + w_c d_c + w_a d_a.\n$$\n我们现在推导每个代理的单独分量。在亚音速区域 $|M|  1$ 中的分裂函数是五次多项式\n$$\ng^+(M) = \\sum_{i=0}^{5} a_i M^i.\n$$\n\n**1.1. 接触保持代理 ($E_c$)**\n代理 $E_c$ 定义为 $E_c = (g^+(0) - 1/2)^2$。由于 $g^+(0) = a_0$，我们有\n$$\nE_c = (a_0 - 1/2)^2 = a_0^2 - a_0 + 1/4.\n$$\n这是一个二次形式 $\\frac{1}{2}\\mathbf{a}^T \\mathbf{Q}_c \\mathbf{a} + \\mathbf{c}_c^T \\mathbf{a} + d_c$，其中：\n$$\n\\mathbf{Q}_c = \\begin{pmatrix} 2  0  \\dots  0 \\\\ 0  0  \\dots  0 \\\\ \\vdots  \\vdots  \\ddots  \\vdots \\\\ 0  0  \\dots  0 \\end{pmatrix}, \\quad\n\\mathbf{c}_c = \\begin{pmatrix} -1 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{pmatrix}, \\quad\nd_c = 1/4.\n$$\n\n**1.2. 激波厚度代理 ($E_s$)**\n代理 $E_s$ 由积分 $E_s = \\int_{0}^{1} M^2 (1 - \\frac{d}{dM}g^+(M))^2 dM$ 给出。\n其导数为 $\\frac{d g^+}{dM} = \\sum_{j=1}^{5} j a_j M^{j-1}$。代入并展开被积函数，我们得到：\n$$\nE_s = \\int_{0}^{1} M^2 \\left( 1 - 2\\sum_{j=1}^{5} j a_j M^{j-1} + \\left(\\sum_{j=1}^{5} j a_j M^{j-1}\\right) \\left(\\sum_{k=1}^{5} k a_k M^{k-1}\\right) \\right) dM.\n$$\n从 $M=0$ 到 $M=1$ 逐项解析积分：\n$$\nE_s = \\frac{1}{3} - 2\\sum_{j=1}^{5} \\frac{j}{j+2} a_j + \\sum_{j=1}^{5}\\sum_{k=1}^{5} \\frac{jk}{j+k+1} a_j a_k.\n$$\n这对应于二次形式 $\\frac{1}{2}\\mathbf{a}^T \\mathbf{Q}_s \\mathbf{a} + \\mathbf{c}_s^T \\mathbf{a} + d_s$，其中：\n$$\n(\\mathbf{Q}_s)_{jk} = \\begin{cases} \\frac{2jk}{j+k+1}  \\text{for } 1 \\le j, k \\le 5 \\\\ 0  \\text{otherwise} \\end{cases}, \\quad\n(\\mathbf{c}_s)_j = \\begin{cases} -\\frac{2j}{j+2}  \\text{for } 1 \\le j \\le 5 \\\\ 0  \\text{for } j=0 \\end{cases}, \\quad\nd_s = 1/3.\n$$\n\n**1.3. 声学色散代理 ($E_a$)**\n代理 $E_a$ 是 $E_a = \\int_{-\\delta}^{\\delta} (\\frac{d^2}{dM^2} g^+(M))^2 dM$，其中 $\\delta = 1/2$。\n其二阶导数为 $\\frac{d^2 g^+}{dM^2} = \\sum_{j=2}^{5} j(j-1) a_j M^{j-2}$。表示该积分为：\n$$\nE_a = \\sum_{j=2}^{5}\\sum_{k=2}^{5} j(j-1)k(k-1) a_j a_k \\int_{-\\delta}^{\\delta} M^{j+k-4} dM.\n$$\n仅当指数 $j+k-4$ 为偶数时，该积分非零。解析计算：\n$$\n\\int_{-\\delta}^{\\delta} M^{n} dM = \\begin{cases} \\frac{2\\delta^{n+1}}{n+1}  \\text{if } n \\text{ is even} \\\\ 0  \\text{if } n \\text{ is odd} \\end{cases}.\n$$\n这产生了一个纯二次形式 $E_a = \\frac{1}{2}\\mathbf{a}^T \\mathbf{Q}_a \\mathbf{a}$，其中 $\\mathbf{c}_a=0$ 且 $d_a=0$。矩阵 $\\mathbf{Q}_a$ 由下式给出：\n$$\n(\\mathbf{Q}_a)_{jk} = \\begin{cases} 2j(j-1)k(k-1) \\frac{2\\delta^{j+k-3}}{j+k-3}  \\text{for } 2 \\le j, k \\le 5 \\text{ and } (j+k) \\text{ even} \\\\ 0  \\text{otherwise} \\end{cases}.\n$$\n\n**2. 线性约束的构建**\n该问题施加了四个线性等式约束，以确保在音速点 $M = 1$ 和 $M = -1$ 处的 $C^1$ 连续性。这些可以写成一个线性系统 $\\mathbf{C} \\mathbf{a} = \\mathbf{b}$。\n\n1.  $g^+(1) = 1 \\implies a_0+a_1+a_2+a_3+a_4+a_5 = 1$\n2.  $\\frac{d g^+}{dM}(1) = 1 \\implies a_1+2a_2+3a_3+4a_4+5a_5 = 1$\n3.  $g^+(-1) = 0 \\implies a_0-a_1+a_2-a_3+a_4-a_5 = 0$\n4.  $\\frac{d g^+}{dM}(-1) = 0 \\implies a_1-2a_2+3a_3-4a_4+5a_5 = 0$\n\n这些方程定义了 $4 \\times 6$ 的约束矩阵 $\\mathbf{C}$ 和 $4 \\times 1$ 的向量 $\\mathbf{b}$：\n$$\n\\mathbf{C} = \\begin{pmatrix}\n1  1  1  1  1  1 \\\\\n0  1  2  3  4  5 \\\\\n1  -1  1  -1  1  -1 \\\\\n0  1  -2  3  -4  5\n\\end{pmatrix}, \\quad\n\\mathbf{b} = \\begin{pmatrix}\n1 \\\\ 1 \\\\ 0 \\\\ 0\n\\end{pmatrix}.\n$$\n\n**3. 通过 KKT 系统求解**\n约束优化问题使用拉格朗日乘子法求解。拉格朗日函数为 $\\mathcal{L}(\\mathbf{a}, \\boldsymbol{\\lambda}) = J(\\mathbf{a}) - \\boldsymbol{\\lambda}^T (\\mathbf{C}\\mathbf{a} - \\mathbf{b})$。KKT 条件 $\\nabla_{\\mathbf{a}}\\mathcal{L} = 0$ 和 $\\nabla_{\\boldsymbol{\\lambda}}\\mathcal{L} = 0$ 产生一个关于最优系数向量 $\\mathbf{a}^\\star$ 和拉格朗日乘子向量 $\\boldsymbol{\\lambda}$ 的线性方程组。\n$$\n\\nabla_{\\mathbf{a}}\\mathcal{L} = \\mathbf{Q}\\mathbf{a} + \\mathbf{c} - \\mathbf{C}^T\\boldsymbol{\\lambda} = \\mathbf{0} \\implies \\mathbf{Q}\\mathbf{a} - \\mathbf{C}^T\\boldsymbol{\\lambda} = -\\mathbf{c}\n$$\n$$\n\\nabla_{\\boldsymbol{\\lambda}}\\mathcal{L} = -(\\mathbf{C}\\mathbf{a} - \\mathbf{b}) = \\mathbf{0} \\implies \\mathbf{C}\\mathbf{a} = \\mathbf{b}\n$$\n这可以写成一个单一的块矩阵系统：\n$$\n\\begin{pmatrix}\n\\mathbf{Q}  -\\mathbf{C}^T \\\\\n\\mathbf{C}  \\mathbf{0}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{a} \\\\\n\\boldsymbol{\\lambda}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-\\mathbf{c} \\\\\n\\mathbf{b}\n\\end{pmatrix}.\n$$\n一些约定使用 $\\mathbf{Q}\\mathbf{a} + \\mathbf{C}^T\\boldsymbol{\\lambda} = -\\mathbf{c}$，这会改变 $\\boldsymbol{\\lambda}$ 的符号，但对 $\\mathbf{a}$ 的解没有影响。我们将求解以下系统：\n$$\n\\begin{pmatrix}\n\\mathbf{Q}  \\mathbf{C}^T \\\\\n\\mathbf{C}  \\mathbf{0}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{a} \\\\\n\\boldsymbol{\\lambda}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-\\mathbf{c} \\\\\n\\mathbf{b}\n\\end{pmatrix}.\n$$\n这个 $10 \\times 10$ 的线性系统是为由权重 $(w_s, w_c, w_a)$ 指定的每个测试用例构建和求解的。解向量提供了最优系数 $\\mathbf{a}^\\star = [a_0, \\dots, a_5]^T$。然后使用导出的二次形式计算最小化目标值 $J(\\mathbf{a}^\\star)$。由于目标函数是凸的且约束是线性的，KKT 系统的解代表全局最小值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the constrained quadratic optimization problem for the coefficients of the\n    van Leer flux vector splitting polynomial.\n    \"\"\"\n\n    test_cases = [\n        (1.0, 1.0, 1.0),\n        (100.0, 1.0, 1.0),\n        (1.0, 1.0, 100.0),\n        (1.0, 100.0, 1.0),\n    ]\n\n    # Fixed parameters\n    delta = 0.5\n    num_coeffs = 6\n\n    # --- 1. Construct Constraint Matrices C and b ---\n    # C a = b\n    C = np.array([\n        [1, 1, 1, 1, 1, 1],\n        [0, 1, 2, 3, 4, 5],\n        [1, -1, 1, -1, 1, -1],\n        [0, 1, -2, 3, -4, 5]\n    ], dtype=float)\n    b = np.array([1, 1, 0, 0], dtype=float)\n\n    # --- 2. Construct Objective Function Components (Q, c, d) ---\n    \n    # E_c components\n    Qc = np.zeros((num_coeffs, num_coeffs), dtype=float)\n    Qc[0, 0] = 2.0\n    cc = np.zeros(num_coeffs, dtype=float)\n    cc[0] = -1.0\n    dc = 0.25\n\n    # E_s components\n    Qs = np.zeros((num_coeffs, num_coeffs), dtype=float)\n    cs = np.zeros(num_coeffs, dtype=float)\n    for j in range(1, num_coeffs):\n        cs[j] = -2.0 * j / (j + 2.0)\n        for k in range(1, num_coeffs):\n            Qs[j, k] = 2.0 * j * k / (j + k + 1.0)\n    ds = 1.0 / 3.0\n\n    # E_a components\n    Qa = np.zeros((num_coeffs, num_coeffs), dtype=float)\n    ca = np.zeros(num_coeffs, dtype=float) # No linear term\n    da = 0.0 # No constant term\n    for j in range(2, num_coeffs):\n        for k in range(2, num_coeffs):\n            if (j + k) % 2 == 0:  # j+k must be even for non-zero integral\n                exponent = j + k - 3\n                # Integral from -delta to delta of M^(j+k-4) is 2 * delta^(j+k-3) / (j+k-3)\n                integral_val = 2.0 * (delta ** exponent) / exponent\n                # Q_a = 2 * H_a, where H_a_jk = j(j-1)k(k-1) * integral\n                Qa[j, k] = 2.0 * (j * (j - 1)) * (k * (k - 1)) * integral_val\n\n    results = []\n    for ws, wc, wa in test_cases:\n        # --- 3. Assemble total Q, c, and d for the current case ---\n        Q = ws * Qs + wc * Qc + wa * Qa\n        c = ws * cs + wc * cc + wa * ca\n        d_total = ws * ds + wc * dc + wa * da\n\n        # --- 4. Assemble and Solve the KKT System ---\n        # | Q  C^T | | a |   | -c |\n        # | C  0   | | l | = |  b |\n        kkt_size = num_coeffs + C.shape[0]\n        KKT_matrix = np.zeros((kkt_size, kkt_size), dtype=float)\n        KKT_matrix[:num_coeffs, :num_coeffs] = Q\n        KKT_matrix[:num_coeffs, num_coeffs:] = C.T\n        KKT_matrix[num_coeffs:, :num_coeffs] = C\n        \n        RHS_vector = np.zeros(kkt_size, dtype=float)\n        RHS_vector[:num_coeffs] = -c\n        RHS_vector[num_coeffs:] = b\n\n        solution = np.linalg.solve(KKT_matrix, RHS_vector)\n        a_star = solution[:num_coeffs]\n\n        # --- 5. Calculate the minimized objective value J(a*) ---\n        # J(a) = 0.5 * a^T Q a + c^T a + d\n        J_val = 0.5 * a_star.T @ Q @ a_star + c.T @ a_star + d_total\n\n        # --- 6. Store and format results ---\n        current_result = [round(x, 6) for x in a_star] + [round(J_val, 6)]\n        results.append(str(current_result))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}