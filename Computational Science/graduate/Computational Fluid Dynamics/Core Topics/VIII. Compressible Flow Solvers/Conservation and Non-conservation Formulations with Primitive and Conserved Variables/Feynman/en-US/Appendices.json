{
    "hands_on_practices": [
        {
            "introduction": "Theory is essential, but there is no substitute for seeing it in action. This first practice provides a stark and memorable demonstration of the critical importance of the conservation form. By implementing a simple, consistent, but non-conservative numerical scheme for the inviscid Burgers' equation, you will observe firsthand how it converges to a physically incorrect solution for a flow with a shock wave, violating the fundamental Rankine–Hugoniot jump condition . This exercise makes the abstract distinction between formulations tangible, providing the core motivation for the rigorous use of conservative schemes in CFD.",
            "id": "3304192",
            "problem": "You are asked to design and analyze a numerical method for a one-dimensional scalar conservation law in a way that distinguishes conservative and nonconservative formulations in computational fluid dynamics (CFD). The core focus is to demonstrate, via a reproducible numerical experiment, that a scheme which is consistent but not conservative can converge to a weak solution that violates the Rankine–Hugoniot jump condition.\n\nConsider the scalar conservation law for the inviscid Burgers equation on a one-dimensional domain,\n$$\nu_t + \\left(\\tfrac{1}{2} u^2\\right)_x = 0,\n$$\nposed on a uniform grid on the interval $[-1,1]$ with Riemann initial data\n$$\nu(x,0) = \\begin{cases}\nu_L, & x < 0,\\\\\nu_R, & x \\ge 0.\n\\end{cases}\n$$\nHere $u$ is dimensionless. You may assume standard mathematical smoothness wherever needed for formal consistency analysis.\n\nYour tasks are:\n\n- Construct a finite difference time-marching scheme that is consistent for smooth solutions but not conservative for discontinuous solutions. Base your construction on the quasi-linear form\n$$\nu_t + a(u)\\,u_x = 0,\\quad a(u) = f'(u) = u,\n$$\nand use upwinding based on the local characteristic speed. Choose a time step that satisfies a Courant–Friedrichs–Lewy (CFL) condition with a specified Courant number and the maximum local characteristic speed magnitude. Do not rewrite the scheme in conservative flux-difference form. Your scheme must evolve cell-centered values on a uniform grid, and you must implement outflow (constant extrapolation) boundary conditions at both ends of the interval.\n\n- Using the Rankine–Hugoniot jump condition for the conservation law,\n$$\ns_{\\mathrm{RH}} = \\frac{f(u_L) - f(u_R)}{u_L - u_R},\n$$\nwith $f(u)=\\tfrac{1}{2}u^2$, define a numerical diagnostic to estimate the shock speed at a final time $T$ from the computed profile for a Riemann problem with $u_L > u_R$. Estimate the instantaneous shock position by locating where the numerical solution crosses the midpoint value $m = \\tfrac{1}{2}(u_L + u_R)$ and dividing its position by $T$ to produce an estimated speed. For rarefaction data $u_L  u_R$, compute the $L^1$ error against the exact self-similar rarefaction solution \n$$\nu(x,T) = \\begin{cases}\nu_L,  x/T \\le u_L,\\\\\nx/T,  u_L  x/T  u_R,\\\\\nu_R,  x/T \\ge u_R.\n\\end{cases}\n$$\nFor constant data $u_L = u_R$, compute the $L^\\infty$ error at the final time $T$.\n\n- All quantities are dimensionless. Report speeds in units of grid-length per unit-time implied by the non-dimensionalization. No other unit conversions are needed.\n\nYour program must implement the nonconservative, consistent upwind scheme described above and produce a single line of output containing the aggregated numerical results for the following test suite:\n\n- Test A (shock): $u_L=2$, $u_R=0$, with final time $T=0.2$, Courant number $\\mathrm{CFL}=0.4$, uniform grids with $N \\in \\{200, 400, 800\\}$ cells over $[-1,1]$. For each $N$, estimate the numerical shock speed $s_{\\mathrm{num}}(N)$ as described. Also compute the Rankine–Hugoniot speed $s_{\\mathrm{RH}}$ for these data and the absolute difference $\\lvert s_{\\mathrm{num}}(800) - s_{\\mathrm{RH}}\\rvert$. Additionally, report a boolean indicating whether $\\lvert s_{\\mathrm{num}}(800) - s_{\\mathrm{RH}}\\rvert > 0.25$.\n\n- Test B (rarefaction): $u_L=0$, $u_R=2$, with final time $T=0.2$, Courant number $\\mathrm{CFL}=0.4$, and $N=800$. Compute the $L^1$ error against the exact rarefaction profile on $[-1,1]$.\n\n- Test C (constant state): $u_L=u_R=1$, with final time $T=0.2$, Courant number $\\mathrm{CFL}=0.4$, and $N=200$. Compute the $L^\\infty$ error at time $T$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order:\n$$\n\\big[s_{\\mathrm{num}}(200),\\, s_{\\mathrm{num}}(400),\\, s_{\\mathrm{num}}(800),\\, s_{\\mathrm{RH}},\\, \\lvert s_{\\mathrm{num}}(800)-s_{\\mathrm{RH}}\\rvert,\\, \\text{violation\\_boolean},\\, L^1\\_B,\\, L^\\infty\\_C\\big].\n$$\nThe values $s_{\\mathrm{num}}(N)$ and $s_{\\mathrm{RH}}$ must be floats, the absolute difference must be a float, the violation flag must be a boolean, $L^1_B$ must be a float, and $L^\\infty_C$ must be a float. The computation must be entirely self-contained, require no user input, and use the given parameter values exactly as specified above. The single line of output must be the only printed output.",
            "solution": "The problem presented is a valid numerical analysis exercise in computational fluid dynamics. It is scientifically grounded, well-posed, and objective. It tasks us with demonstrating a fundamental concept: the failure of a non-conservative numerical scheme to capture the correct weak solution of a conservation law, specifically by converging to a shock wave that propagates at a speed violating the Rankine-Hugoniot condition.\n\nThe problem centers on the one-dimensional inviscid Burgers' equation, a canonical model for hyperbolic conservation laws. Its conservative form is\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x} \\left( \\frac{1}{2} u^2 \\right) = 0.\n$$\nFor smooth solutions, the chain rule allows this to be written in the quasi-linear form,\n$$\n\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = 0,\n$$\nwhere $a(u) = u$ is the characteristic speed. While these two forms are equivalent for smooth solutions, their weak solutions, which admit discontinuities (shocks), are not equivalent. The conservative form is the physically correct one, derived from an integral balance law. A numerical scheme must be in conservation form to guarantee that its solutions converge to a weak solution satisfying the correct jump conditions.\n\nWe will construct a numerical scheme based on the non-conservative quasi-linear form and demonstrate that for a Riemann problem generating a shock ($u_L  u_R$), it converges to a shock with an incorrect propagation speed.\n\n**1. Numerical Discretization**\n\nWe discretize the spatial domain $x \\in [-1, 1]$ into $N$ uniform cells. The grid spacing is $\\Delta x = 2/N$. The solution is represented by cell-centered values $U_j^n$, which approximate the solution $u(x_j, t_n)$ at cell centers $x_j = -1 + (j+0.5)\\Delta x$ for $j=0, 1, \\dots, N-1$ and time $t_n = n\\Delta t$.\n\nThe initial condition is a Riemann problem,\n$$\nu(x,0) = \\begin{cases}\nu_L,  x  0,\\\\\nu_R,  x \\ge 0.\n\\end{cases}\n$$\nThis is discretized by setting $U_j^0 = u_L$ if $x_j  0$ and $U_j^0 = u_R$ if $x_j \\ge 0$.\n\n**2. Non-Conservative Upwind Scheme**\n\nWe are tasked to create a scheme based on the quasi-linear form $u_t + u u_x = 0$. We use a forward Euler method for time integration and a first-order upwind scheme for the spatial derivative $u_x$. The upwind direction is determined by the sign of the local characteristic speed, $a(u_j) = U_j^n$.\n\nThe semi-discrete approximation at cell $j$ is\n$$\n\\frac{dU_j}{dt} = -U_j (u_x)_j.\n$$\nThe upwind discretization for $(u_x)_j$ is:\n$$\n(u_x)_j \\approx \\begin{cases}\n(U_j^n - U_{j-1}^n)/\\Delta x,  \\text{if } U_j^n \\ge 0 \\\\\n(U_{j+1}^n - U_j^n)/\\Delta x,  \\text{if } U_j^n  0\n\\end{cases}\n$$\nCombining these with forward Euler time-stepping, the full update rule is:\n$$\nU_j^{n+1} = U_j^n - \\frac{\\Delta t}{\\Delta x} U_j^n \\times \\begin{cases}\n(U_j^n - U_{j-1}^n),  \\text{if } U_j^n \\ge 0 \\\\\n(U_{j+1}^n - U_j^n),  \\text{if } U_j^n  0\n\\end{cases}\n$$\nThis scheme is not conservative because it cannot be written in the flux-difference form $U_j^{n+1} = U_j^n - \\frac{\\Delta t}{\\Delta x}(F_{j+1/2} - F_{j-1/2})$, where $F$ is a consistent numerical flux. Summing the updates over the grid does not result in a telescoping sum of fluxes, meaning the discrete total mass $\\sum_j U_j \\Delta x$ is not conserved up to boundary fluxes.\n\n**3. Time Step and Boundary Conditions**\n\nTo ensure numerical stability, the time step $\\Delta t$ is chosen to satisfy a Courant-Friedrichs-Lewy (CFL) condition. For an explicit scheme, we must ensure that the numerical domain of dependence contains the physical domain of dependence. This requires\n$$\n\\Delta t \\le \\mathrm{CFL} \\frac{\\Delta x}{\\max_j |a(U_j^n)|} \\implies \\Delta t = \\mathrm{CFL} \\frac{\\Delta x}{\\max_j |U_j^n|}.\n$$\nThe time step is re-calculated at every iteration based on the current maximum wave speed in the domain. To reach the final time $T$ exactly, the last time step is adjusted if necessary.\n\nOutflow boundary conditions are implemented using ghost cells. We add one ghost cell at each end of the domain, $U_{-1}$ and $U_N$. The values are set by constant extrapolation: $U_{-1}^n = U_0^n$ and $U_N^n = U_{N-1}^n$.\n\n**4. Numerical Diagnostics**\n\n- **Test A (Shock):** For the case $u_L  u_R$, a shock wave forms. The theoretically correct shock speed $s_{\\mathrm{RH}}$ is given by the Rankine-Hugoniot jump condition for the conservative equation with flux $f(u) = \\frac{1}{2}u^2$:\n$$\ns_{\\mathrm{RH}} = \\frac{f(u_L) - f(u_R)}{u_L - u_R} = \\frac{\\frac{1}{2}u_L^2 - \\frac{1}{2}u_R^2}{u_L - u_R} = \\frac{1}{2}(u_L + u_R).\n$$\nFor $u_L=2$ and $u_R=0$, we have $s_{\\mathrm{RH}} = \\frac{1}{2}(2+0) = 1$. The numerical shock speed $s_{\\mathrm{num}}$ is estimated from the final solution profile at time $T$. We find the position $x_{\\mathrm{shock}}$ where the solution crosses the midpoint value $m = \\frac{1}{2}(u_L+u_R) = 1$. This position is found by linear interpolation between the two grid cells bracketing the value $m$. The speed is then $s_{\\mathrm{num}} = x_{\\mathrm{shock}} / T$.\n\n- **Test B (Rarefaction):** For $u_L  u_R$, a smooth rarefaction wave develops. The exact solution is self-similar, depending only on $\\xi = x/t$. We compare our numerical solution $U_{\\mathrm{final}}$ at time $T$ to the exact solution $u_{\\mathrm{exact}}(x_j, T)$ and compute the $L^1$ error:\n$$\nL^1 \\text{ error} = \\sum_{j=0}^{N-1} |U_{\\mathrm{final},j} - u_{\\mathrm{exact}}(x_j, T)| \\Delta x.\n$$\n\n- **Test C (Constant State):** For $u_L=u_R=c$, the exact solution is $u(x,t)=c$. The non-conservative upwind scheme is exact for this case, as the spatial difference term is zero. The error should be on the order of machine precision. We compute the $L^\\infty$ error:\n$$\nL^\\infty \\text{ error} = \\max_{j} |U_{\\mathrm{final},j} - c|.\n$$\n\nThe specified computations will be performed for the three test cases, and the results will be aggregated as requested. This will numerically verify that the non-conservative scheme, despite being consistent for smooth flows (as shown by its small errors in Tests B and C), produces a large, persistent error in the shock speed for discontinuous flows (Test A), thus converging to an incorrect weak solution.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(u_l, u_r, N, T_final, CFL):\n    \"\"\"\n    Solves the 1D Burgers' equation using a non-conservative upwind scheme.\n    \"\"\"\n    # Grid setup\n    L_domain = 2.0\n    dx = L_domain / N\n    x = -1.0 + (np.arange(N) + 0.5) * dx\n\n    # Initial condition\n    u = np.full(N, u_r)\n    u[x  0] = u_l\n\n    t = 0.0\n    while t  T_final:\n        # Calculate time step based on CFL condition\n        max_abs_u = np.max(np.abs(u))\n        if max_abs_u == 0:\n            # If u is zero everywhere, dt can be T_final - t\n            # or a large number. Let's make it not infinite.\n            dt = T_final - t\n        else:\n            dt = CFL * dx / max_abs_u\n\n        # Ensure we do not step past the final time\n        if t + dt  T_final:\n            dt = T_final - t\n\n        # Pad the solution array with ghost cells for boundary conditions\n        # Outflow (constant extrapolation)\n        u_padded = np.pad(u, 1, mode='edge')\n        \n        # Vectorized calculation of the spatial derivative term\n        u_conv = np.zeros_like(u)\n\n        # Positive speeds: upwind from left\n        pos_mask = u = 0\n        if np.any(pos_mask):\n            u_j = u_padded[1:-1][pos_mask]\n            u_jm1 = u_padded[:-2][pos_mask]\n            u_conv[pos_mask] = u_j * (u_j - u_jm1)\n\n        # Negative speeds: upwind from right\n        neg_mask = u  0\n        if np.any(neg_mask):\n            u_j = u_padded[1:-1][neg_mask]\n            u_jp1 = u_padded[2:][neg_mask]\n            u_conv[neg_mask] = u_j * (u_jp1 - u_j)\n\n        # Forward Euler update\n        u = u - (dt / dx) * u_conv\n        t += dt\n\n    return x, u\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and produce the final output.\n    \"\"\"\n    # --- Test A: Schock Problem ---\n    u_l_A, u_r_A = 2.0, 0.0\n    T_A = 0.2\n    CFL_A = 0.4\n    N_vals_A = [200, 400, 800]\n    \n    s_num_list = []\n    for N in N_vals_A:\n        x, u_final = run_simulation(u_l_A, u_r_A, N, T_A, CFL_A)\n        dx = x[1] - x[0]\n        \n        # Find shock position by interpolation\n        mid_val = 0.5 * (u_l_A + u_r_A)\n        \n        # Find index j where u[j] = mid_val and u[j+1]  mid_val\n        cross_indices = np.where((u_final[:-1] = mid_val)  (u_final[1:]  mid_val))[0]\n        \n        if len(cross_indices)  0:\n            j = cross_indices[0]\n            x_j = x[j]\n            u_j = u_final[j]\n            u_jp1 = u_final[j+1]\n            \n            # Linear interpolation to find x_shock\n            x_shock = x_j + dx * (u_j - mid_val) / (u_j - u_jp1)\n            s_num = x_shock / T_A\n        else:\n            # Fallback if no crossing is found (should not happen for this problem)\n            s_num = np.nan\n            \n        s_num_list.append(s_num)\n\n    s_rh = 0.5 * (u_l_A**2 - u_r_A**2) / (u_l_A - u_r_A)\n    abs_diff = np.abs(s_num_list[-1] - s_rh)\n    violation_boolean = abs_diff  0.25\n\n    # --- Test B: Rarefaction Problem ---\n    u_l_B, u_r_B = 0.0, 2.0\n    T_B = 0.2\n    CFL_B = 0.4\n    N_B = 800\n    \n    x_B, u_final_B = run_simulation(u_l_B, u_r_B, N_B, T_B, CFL_B)\n    dx_B = x_B[1] - x_B[0]\n    \n    # Exact solution for rarefaction\n    xt = x_B / T_B\n    u_exact_B = np.zeros_like(x_B)\n    mask1 = xt = u_l_B\n    mask2 = xt = u_r_B\n    mask3 = (~mask1)  (~mask2)\n    u_exact_B[mask1] = u_l_B\n    u_exact_B[mask2] = u_r_B\n    u_exact_B[mask3] = xt[mask3]\n    \n    l1_error_B = np.sum(np.abs(u_final_B - u_exact_B)) * dx_B\n\n    # --- Test C: Constant State ---\n    u_l_C, u_r_C = 1.0, 1.0\n    T_C = 0.2\n    CFL_C = 0.4\n    N_C = 200\n\n    x_C, u_final_C = run_simulation(u_l_C, u_r_C, N_C, T_C, CFL_C)\n    \n    l_inf_error_C = np.max(np.abs(u_final_C - u_l_C))\n    \n    # --- Final Output ---\n    results = [\n        s_num_list[0],\n        s_num_list[1],\n        s_num_list[2],\n        s_rh,\n        abs_diff,\n        violation_boolean,\n        l1_error_B,\n        l_inf_error_C\n    ]\n    \n    # Format the output string\n    formatted_results = []\n    for r in results:\n        if isinstance(r, bool):\n            formatted_results.append(str(r).lower())\n        else:\n            formatted_results.append(f\"{r}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having witnessed the failure of a non-conservative scheme, we now delve into the mathematical structure that explains why the conservative formulation is physically correct and mathematically robust. This analytical exercise requires deriving the flux Jacobian matrix for the one-dimensional Euler equations and analyzing its eigenstructure . Understanding the eigenvalues (characteristic wave speeds) and eigenvectors of the system is not merely an academic pursuit; it is the foundation for constructing advanced numerical methods, such as Riemann solvers and characteristic-based schemes, that correctly capture the physics of wave propagation in compressible flows.",
            "id": "3304162",
            "problem": "Consider the one-dimensional Euler equations for a calorically perfect gas in conservation form,\n$$\n\\frac{\\partial \\mathbf{U}}{\\partial t} + \\frac{\\partial \\mathbf{F}(\\mathbf{U})}{\\partial x} = 0,\n$$\nwhere the conserved variable vector is $\\mathbf{U} = \\begin{pmatrix} \\rho \\\\ \\rho u \\\\ \\rho E \\end{pmatrix}$, the flux vector is $\\mathbf{F}(\\mathbf{U}) = \\begin{pmatrix} \\rho u \\\\ \\rho u^{2} + p \\\\ u(\\rho E + p) \\end{pmatrix}$, the pressure is given by the ideal-gas closure $p = (\\gamma - 1)\\left(\\rho E - \\tfrac{1}{2}\\rho u^{2}\\right)$ with $\\gamma > 1$ constant, and the speed of sound is $c^{2} = \\gamma p / \\rho$. Let the primitive variable vector be $\\mathbf{V} = \\begin{pmatrix} \\rho \\\\ u \\\\ p \\end{pmatrix}$.\n\nStarting from these definitions and the conservation laws, do the following:\n- Derive the flux Jacobian in conservative variables, $\\mathbf{A}(\\mathbf{U}) = \\partial \\mathbf{F}/\\partial \\mathbf{U}$, and determine its eigenvalues and a consistent set of right eigenvectors.\n- Compute the transformation matrix $\\mathbf{U}_{\\mathbf{V}} = \\partial \\mathbf{U}/\\partial \\mathbf{V}$ and use it to obtain the quasilinear primitive-variable Jacobian associated with the evolution of $\\mathbf{V}$, $\\mathbf{B}(\\mathbf{V}) = \\mathbf{U}_{\\mathbf{V}}^{-1}\\,\\mathbf{A}(\\mathbf{U})\\,\\mathbf{U}_{\\mathbf{V}}$.\n- Compare the eigenstructures of $\\mathbf{A}(\\mathbf{U})$ and $\\mathbf{B}(\\mathbf{V})$ and explain the distinction between $\\partial \\mathbf{F}/\\partial \\mathbf{V}$ and $\\mathbf{B}(\\mathbf{V})$.\nAs a scalar measure of this comparison, give the determinant of the primitive-variable Jacobian $\\det(\\mathbf{B}(\\mathbf{V}))$ expressed purely in terms of $u$ and $c$. Express your final answer as a single closed-form analytic expression with no units.",
            "solution": "The problem is well-posed, scientifically grounded, objective, and contains all necessary information for a full derivation. It is a standard exercise in the analysis of hyperbolic conservation laws, specifically the Euler equations, and is therefore valid.\n\nThe process involves several steps: deriving the flux Jacobian in conservative variables and its eigenstructure, finding the transformation matrix to primitive variables, computing the corresponding primitive variable Jacobian, comparing the two systems, and finally calculating the determinant of the primitive variable Jacobian.\n\n**Part 1: Flux Jacobian $\\mathbf{A}(\\mathbf{U})$ and its Eigenstructure**\n\nThe vector of conserved variables is $\\mathbf{U} = (U_1, U_2, U_3)^T = (\\rho, \\rho u, \\rho E)^T$. The flux vector is $\\mathbf{F}(\\mathbf{U}) = (\\rho u, \\rho u^2+p, u(\\rho E+p))^T$. To compute the Jacobian $\\mathbf{A}(\\mathbf{U}) = \\partial \\mathbf{F}/\\partial \\mathbf{U}$, we first express the flux components $F_1, F_2, F_3$ in terms of $U_1, U_2, U_3$.\nThe primitive variables are $\\rho = U_1$ and $u = U_2/U_1$.\nThe pressure $p$ is given by the equation of state:\n$$p = (\\gamma - 1)\\left(\\rho E - \\frac{1}{2}\\rho u^2\\right) = (\\gamma - 1)\\left(U_3 - \\frac{1}{2}U_1 \\left(\\frac{U_2}{U_1}\\right)^2\\right) = (\\gamma - 1)\\left(U_3 - \\frac{U_2^2}{2U_1}\\right)$$\nThe flux vector components are:\n$$F_1 = \\rho u = U_2$$\n$$F_2 = \\rho u^2 + p = U_1\\left(\\frac{U_2}{U_1}\\right)^2 + (\\gamma - 1)\\left(U_3 - \\frac{U_2^2}{2U_1}\\right) = \\frac{U_2^2}{U_1} + (\\gamma-1)U_3 - \\frac{\\gamma-1}{2}\\frac{U_2^2}{U_1} = \\frac{3-\\gamma}{2}\\frac{U_2^2}{U_1} + (\\gamma-1)U_3$$\n$$F_3 = u(\\rho E + p) = \\frac{U_2}{U_1}(U_3 + p) = \\frac{U_2}{U_1}\\left[U_3 + (\\gamma-1)\\left(U_3 - \\frac{U_2^2}{2U_1}\\right)\\right] = \\frac{U_2}{U_1}\\left[\\gamma U_3 - \\frac{\\gamma-1}{2}\\frac{U_2^2}{U_1}\\right] = \\frac{\\gamma U_2 U_3}{U_1} - \\frac{\\gamma-1}{2}\\frac{U_2^3}{U_1^2}$$\nThe flux Jacobian $\\mathbf{A}(\\mathbf{U})_{ij} = \\partial F_i/\\partial U_j$ is computed by differentiation. For clarity, it is convenient to express the final matrix in terms of primitive variables $\\rho, u, p$ and related quantities like the total enthalpy $H = E + p/\\rho = \\frac{\\rho E + p}{\\rho}$ and speed of sound $c = \\sqrt{\\gamma p/\\rho}$. Total enthalpy can be written as $H = \\frac{c^2}{\\gamma-1} + \\frac{u^2}{2}$. The resulting Jacobian is:\n$$\n\\mathbf{A}(\\mathbf{U}) = \\begin{pmatrix}\n0  1  0 \\\\\n\\frac{\\gamma-3}{2}u^2  (3-\\gamma)u  \\gamma-1 \\\\\nu\\left(\\frac{\\gamma-1}{2}u^2 - H\\right)  H - (\\gamma-1)u^2  \\gamma u\n\\end{pmatrix}\n$$\nThe eigenvalues of this matrix are the characteristic wave speeds of the system. For the one-dimensional Euler equations, these are known to be:\n$$\n\\lambda_1 = u - c, \\quad \\lambda_2 = u, \\quad \\lambda_3 = u + c\n$$\nA consistent set of right eigenvectors $\\mathbf{r}_k$ satisfying $\\mathbf{A}\\mathbf{r}_k = \\lambda_k\\mathbf{r}_k$ is:\n$$\n\\mathbf{r}_1 = \\begin{pmatrix} 1 \\\\ u-c \\\\ H-uc \\end{pmatrix}, \\quad\n\\mathbf{r}_2 = \\begin{pmatrix} 1 \\\\ u \\\\ \\frac{1}{2}u^2 \\end{pmatrix}, \\quad\n\\mathbf{r}_3 = \\begin{pmatrix} 1 \\\\ u+c \\\\ H+uc \\end{pmatrix}\n$$\nDifferent scalings exist for these eigenvectors; the choice above is a common and simple one.\n\n**Part 2: Transformation Matrix and Primitive Variable Jacobian**\n\nThe transformation from primitive variables $\\mathbf{V} = (\\rho, u, p)^T$ to conserved variables $\\mathbf{U} = (\\rho, \\rho u, \\rho E)^T$ requires expressing $\\mathbf{U}$ in terms of $\\mathbf{V}$. Using the relation $\\rho E = \\frac{p}{\\gamma-1} + \\frac{1}{2}\\rho u^2$, we have:\n$$\n\\mathbf{U}(\\mathbf{V}) = \\begin{pmatrix} \\rho \\\\ \\rho u \\\\ \\frac{p}{\\gamma-1} + \\frac{1}{2}\\rho u^2 \\end{pmatrix}\n$$\nThe transformation matrix $\\mathbf{U}_{\\mathbf{V}}$ is the Jacobian of this transformation, $\\mathbf{U}_{\\mathbf{V}} = \\partial \\mathbf{U}/\\partial \\mathbf{V}$:\n$$\n\\mathbf{U}_{\\mathbf{V}} = \\begin{pmatrix} \\partial U_1/\\partial \\rho  \\partial U_1/\\partial u  \\partial U_1/\\partial p \\\\ \\partial U_2/\\partial \\rho  \\partial U_2/\\partial u  \\partial U_2/\\partial p \\\\ \\partial U_3/\\partial \\rho  \\partial U_3/\\partial u  \\partial U_3/\\partial p \\end{pmatrix} = \\begin{pmatrix}\n1  0  0 \\\\\nu  \\rho  0 \\\\\n\\frac{1}{2}u^2  \\rho u  \\frac{1}{\\gamma-1}\n\\end{pmatrix}\n$$\nThe inverse transformation matrix $\\mathbf{U}_{\\mathbf{V}}^{-1} = \\partial \\mathbf{V}/\\partial \\mathbf{U}$ can be computed either by direct matrix inversion or by differentiating the expressions for $\\mathbf{V}$ in terms of $\\mathbf{U}$: $\\rho = U_1$, $u=U_2/U_1$, $p=(\\gamma-1)(U_3 - U_2^2/(2U_1))$.\n$$\n\\mathbf{U}_{\\mathbf{V}}^{-1} = \\begin{pmatrix}\n1  0  0 \\\\\n-u/\\rho  1/\\rho  0 \\\\\n\\frac{\\gamma-1}{2}u^2  -(\\gamma-1)u  \\gamma-1\n\\end{pmatrix}\n$$\nThe quasilinear primitive-variable Jacobian $\\mathbf{B}(\\mathbf{V})$ is obtained via a similarity transformation of $\\mathbf{A}$: $\\mathbf{B}(\\mathbf{V}) = \\mathbf{U}_{\\mathbf{V}}^{-1}\\,\\mathbf{A}\\,\\mathbf{U}_{\\mathbf{V}}$. A convenient way to compute this is to first find the product $\\mathbf{A}\\mathbf{U}_{\\mathbf{V}}$, which by the chain rule is equal to $\\partial \\mathbf{F}/\\partial \\mathbf{V}$:\n$$ \\mathbf{A}\\mathbf{U}_{\\mathbf{V}} = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{U}}\\frac{\\partial \\mathbf{U}}{\\partial \\mathbf{V}} = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{V}} $$\nWe calculate $\\partial \\mathbf{F}/\\partial \\mathbf{V}$ by first expressing $\\mathbf{F}$ in terms of $\\mathbf{V}$:\n$$ \\mathbf{F}(\\mathbf{V}) = \\begin{pmatrix} \\rho u \\\\ \\rho u^2+p \\\\ u\\left(\\frac{\\gamma p}{\\gamma-1} + \\frac{1}{2}\\rho u^2\\right) \\end{pmatrix} $$\nDifferentiating yields:\n$$ \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{V}} = \\begin{pmatrix}\nu  \\rho  0 \\\\\nu^2  2\\rho u  1 \\\\\n\\frac{1}{2}u^3  \\frac{\\gamma p}{\\gamma-1} + \\frac{3}{2}\\rho u^2  \\frac{\\gamma u}{\\gamma-1}\n\\end{pmatrix}\n$$\nNow we can find $\\mathbf{B}$ as $\\mathbf{B} = \\mathbf{U}_{\\mathbf{V}}^{-1} (\\partial \\mathbf{F}/\\partial \\mathbf{V})$:\n$$\n\\mathbf{B}(\\mathbf{V}) = \\begin{pmatrix}\n1  0  0 \\\\\n-u/\\rho  1/\\rho  0 \\\\\n\\frac{\\gamma-1}{2}u^2  -(\\gamma-1)u  \\gamma-1\n\\end{pmatrix} \\begin{pmatrix}\nu  \\rho  0 \\\\\nu^2  2\\rho u  1 \\\\\n\\frac{1}{2}u^3  \\frac{\\gamma p}{\\gamma-1} + \\frac{3}{2}\\rho u^2  \\frac{\\gamma u}{\\gamma-1}\n\\end{pmatrix} = \\begin{pmatrix}\nu  \\rho  0 \\\\\n0  u  1/\\rho \\\\\n0  \\gamma p  u\n\\end{pmatrix}\n$$\nUsing $c^2=\\gamma p/\\rho$, we can write this as:\n$$\n\\mathbf{B}(\\mathbf{V}) = \\begin{pmatrix}\nu  \\rho  0 \\\\\n0  u  1/\\rho \\\\\n0  \\rho c^2  u\n\\end{pmatrix}\n$$\n\n**Part 3: Comparison of Eigenstructures and Jacobians**\n\nSince $\\mathbf{B}$ is related to $\\mathbf{A}$ by a similarity transformation, they share the same eigenvalues. We can verify this by computing the characteristic polynomial of $\\mathbf{B}$:\n$$ \\det(\\mathbf{B}-\\lambda\\mathbf{I}) = \\begin{vmatrix} u-\\lambda  \\rho  0 \\\\ 0  u-\\lambda  1/\\rho \\\\ 0  \\rho c^2  u-\\lambda \\end{vmatrix} = (u-\\lambda)\\left( (u-\\lambda)^2 - (\\rho c^2)(1/\\rho) \\right) = (u-\\lambda)( (u-\\lambda)^2 - c^2 ) = 0 $$\nThis yields the eigenvalues $\\lambda = u, u \\pm c$, identical to those of $\\mathbf{A}$.\n\nHowever, their eigenvectors are different. The right eigenvectors of $\\mathbf{B}$ are:\n$$\n\\mathbf{r}_{B,1} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad\n\\mathbf{r}_{B,2} = \\begin{pmatrix} \\rho \\\\ -c \\\\ \\rho c^2 \\end{pmatrix}, \\quad\n\\mathbf{r}_{B,3} = \\begin{pmatrix} \\rho \\\\ c \\\\ \\rho c^2 \\end{pmatrix}\n$$\nThese eigenvectors represent perturbations in primitive variable space $(\\delta\\rho, \\delta u, \\delta p)^T$, whereas the eigenvectors of $\\mathbf{A}$ represent perturbations in conserved variable space.\n\nThe distinction between $\\mathbf{B}(\\mathbf{V})$ and $\\partial \\mathbf{F}/\\partial \\mathbf{V}$ is fundamental. The conservation law $\\partial_t \\mathbf{U} + \\partial_x \\mathbf{F}(\\mathbf{U}) = 0$ can be rewritten in terms of primitive variables using the chain rule:\n$$ \\frac{\\partial \\mathbf{U}}{\\partial \\mathbf{V}}\\frac{\\partial \\mathbf{V}}{\\partial t} + \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{V}}\\frac{\\partial \\mathbf{V}}{\\partial x} = 0 \\implies \\mathbf{U}_{\\mathbf{V}} \\frac{\\partial \\mathbf{V}}{\\partial t} + \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{V}} \\frac{\\partial \\mathbf{V}}{\\partial x} = 0 $$\nTo obtain the standard quasilinear form $\\partial_t \\mathbf{V} + \\mathbf{B} \\partial_x \\mathbf{V} = 0$, we must multiply by $\\mathbf{U}_{\\mathbf{V}}^{-1}$:\n$$ \\frac{\\partial \\mathbf{V}}{\\partial t} + \\left(\\mathbf{U}_{\\mathbf{V}}^{-1} \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{V}}\\right) \\frac{\\partial \\mathbf{V}}{\\partial x} = 0 $$\nThus, $\\mathbf{B}(\\mathbf{V}) = \\mathbf{U}_{\\mathbf{V}}^{-1}(\\partial \\mathbf{F}/\\partial \\mathbf{V})$ is the authentic system Jacobian for the primitive variable formulation, and its eigenvalues are the characteristic wave speeds. In contrast, $\\partial \\mathbf{F}/\\partial \\mathbf{V}$ is an intermediate matrix that does not, by itself, represent the system's characteristic structure. The Euler equations in primitive variables are not in conservation form, meaning there is no flux function $\\mathbf{G}(\\mathbf{V})$ such that $\\mathbf{B} = \\partial \\mathbf{G}/\\partial \\mathbf{V}$.\n\n**Part 4: Determinant of the Primitive-Variable Jacobian**\n\nThe determinant of a matrix is the product of its eigenvalues. For $\\mathbf{B}(\\mathbf{V})$, the eigenvalues are $u, u-c, u+c$. Therefore:\n$$ \\det(\\mathbf{B}(\\mathbf{V})) = (u)(u-c)(u+c) = u(u^2-c^2) $$\nThis can be confirmed by direct calculation from the matrix form of $\\mathbf{B}(\\mathbf{V})$:\n$$ \\det(\\mathbf{B}(\\mathbf{V})) = \\begin{vmatrix}\nu  \\rho  0 \\\\\n0  u  1/\\rho \\\\\n0  \\rho c^2  u\n\\end{vmatrix} = u \\begin{vmatrix} u  1/\\rho \\\\ \\rho c^2  u \\end{vmatrix} - 0 = u(u^2 - (\\rho c^2)(1/\\rho)) = u(u^2 - c^2) $$\nThe final expression is in terms of only $u$ and $c$, as requested.",
            "answer": "$$\n\\boxed{u(u^2 - c^2)}\n$$"
        },
        {
            "introduction": "This final practice synthesizes the lessons from the previous exercises by moving from a scalar model equation to the full system of compressible Euler equations. Here, you will directly compare a proper finite-volume scheme, which is discretely conservative, against a non-conservative scheme derived from the primitive-variable equations for a smooth, periodic flow . By quantifying the spurious generation or loss of mass, momentum, and total energy, you will see that the failure to conserve is not limited to shocks but is an inherent flaw of discretizing the non-conservative form, leading to a violation of fundamental physical principles even in the absence of discontinuities.",
            "id": "3304148",
            "problem": "Consider the one-dimensional compressible Euler equations for a calorically perfect ideal gas, posed on a periodic domain of length $L$, with primitive variables $(\\rho, u, p)$, conserved variables $(\\rho, \\rho u, \\rho E)$, and the Equation of State (EOS) $p = (\\gamma - 1)\\rho e$ for a constant ratio of specific heats $\\gamma$ and specific internal energy $e$. The total energy per unit mass $E$ satisfies $E = e + \\tfrac{1}{2}u^2$. The conserved-form system is\n$$\n\\partial_t \\rho + \\partial_x (\\rho u) = 0,\\quad\n\\partial_t (\\rho u) + \\partial_x\\!\\left(\\rho u^2 + p\\right) = 0,\\quad\n\\partial_t (\\rho E) + \\partial_x\\!\\left(u(\\rho E + p)\\right) = 0.\n$$\nFor smooth solutions, the primitive-variable system that is algebraically equivalent (derived via the product rule and the ideal-gas EOS) is\n$$\n\\partial_t \\rho + u\\,\\partial_x \\rho + \\rho\\,\\partial_x u = 0,\\quad\n\\partial_t u + u\\,\\partial_x u + \\frac{1}{\\rho}\\,\\partial_x p = 0,\\quad\n\\partial_t p + u\\,\\partial_x p + \\gamma p\\,\\partial_x u = 0.\n$$\nYou will design a thought experiment and instantiate it numerically to compare two discrete schemes advancing the same smooth initial data over one time step:\n- A finite-volume scheme that updates the conserved variables $(\\rho, \\rho u, \\rho E)$ using face fluxes, ensuring exact discrete conservation under periodic boundary conditions.\n- An algebraically equivalent, but non-conservative, scheme that updates the primitive variables $(\\rho, u, p)$ by discretizing the primitive-variable system with cellwise spatial derivatives.\n\nStarting only from the above fundamental laws and definitions, you must:\n1. Implement a one-dimensional periodic mesh with $N$ uniform cells of width $\\Delta x = L/N$.\n2. Choose a single explicit time step $\\Delta t$ via the Courant–Friedrichs–Lewy (CFL) condition (Courant–Friedrichs–Lewy (CFL)), $\\Delta t = \\mathrm{CFL}\\,\\Delta x / a_{\\max}$, where $a_{\\max} = \\max_i \\left(|u_i| + c_i\\right)$ and $c_i = \\sqrt{\\gamma p_i/\\rho_i}$ is the local sound speed.\n3. Conservative finite-volume update:\n   - Construct cell-centered conserved variables from cell-centered primitive variables via the EOS.\n   - Compute face fluxes $F_{i+\\frac{1}{2}}$ using any consistent monotone numerical flux; for concreteness, use the local Lax–Friedrichs (Rusanov) flux $F^\\ast(U_L,U_R) = \\tfrac{1}{2}\\left(F(U_L)+F(U_R)\\right) - \\tfrac{1}{2} a_{\\max}(U_R-U_L)$ with $a_{\\max} = \\max\\left(|u_L|+c_L, |u_R|+c_R\\right)$, where $F(U) = \\left(\\rho u,\\ \\rho u^2 + p,\\ u(\\rho E + p)\\right)$ and $U_L,U_R$ are left/right states at each face. Update $U_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right)$.\n4. Primitive-variable update:\n   - Discretize the primitive system using centered finite differences for spatial derivatives on the periodic grid: $\\partial_x w \\approx (w_{i+1}-w_{i-1})/(2\\Delta x)$ for $w \\in \\{\\rho,u,p\\}$.\n   - Update $(\\rho, u, p)$ via the explicit Euler method using the primitive-variable equations.\n5. For both schemes, compute the global integrals of mass, momentum, and energy immediately before and after the single time step:\n   - Mass $M = \\sum_i \\rho_i\\,\\Delta x$.\n   - Momentum $P = \\sum_i \\rho_i u_i\\,\\Delta x$.\n   - Energy $E_{\\mathrm{tot}} = \\sum_i \\rho_i E_i\\,\\Delta x = \\sum_i \\left(\\frac{p_i}{\\gamma - 1} + \\frac{1}{2}\\rho_i u_i^2\\right)\\Delta x$.\n6. Quantify the induced non-conservation as absolute changes $\\Delta M$, $\\Delta P$, $\\Delta E$ from initial to updated totals for each scheme.\n\nAll variables are dimensionless. Angle parameters in initial conditions are specified in radians and must be treated as such.\n\nImplement the following smooth test suite of initial conditions on $x \\in [0,L)$ with $L = 2\\pi$, periodic boundary conditions, and $\\gamma = 1.4$. Use the specified $N$ and $\\mathrm{CFL}$ per test. For each test case, define\n$$\n\\rho(x) = \\rho_0 + a_\\rho \\sin(kx + \\phi_\\rho),\\quad\nu(x) = u_0 + a_u \\sin(kx + \\phi_u),\\quad\np(x) = p_0 + a_p \\cos(kx + \\phi_p),\n$$\nwith parameters given below:\n\n- Test $1$: $N=128$, $\\mathrm{CFL}=0.5$, $k=2$, $\\rho_0=1$, $u_0=0$, $p_0=1$, $a_\\rho=0.1$, $a_u=0.1$, $a_p=0.1$, $\\phi_\\rho=0$, $\\phi_u=0$, $\\phi_p=0$.\n- Test $2$: $N=128$, $\\mathrm{CFL}=0.5$, $k=3$, $\\rho_0=1$, $u_0=0$, $p_0=1$, $a_\\rho=10^{-8}$, $a_u=10^{-8}$, $a_p=10^{-8}$, $\\phi_\\rho=0$, $\\phi_u=0$, $\\phi_p=0$.\n- Test $3$: $N=128$, $\\mathrm{CFL}=0.5$, $k=1$, $\\rho_0=1$, $u_0=0$, $p_0=1$, $a_\\rho=0.2$, $a_u=0$, $a_p=0.2$, $\\phi_\\rho=0$, $\\phi_u=0$, $\\phi_p=0$.\n- Test $4$: $N=128$, $\\mathrm{CFL}=0.5$, $k=4$, $\\rho_0=1$, $u_0=0$, $p_0=1$, $a_\\rho=0$, $a_u=0.3$, $a_p=0.3$, $\\phi_\\rho=0$, $\\phi_u=\\pi/3$, $\\phi_p=-\\pi/4$.\n\nYour program must produce a single line of output containing a list of lists, one inner list per test case, where each inner list contains six floats in the order $[\\Delta M_{\\mathrm{cons}}, \\Delta P_{\\mathrm{cons}}, \\Delta E_{\\mathrm{cons}}, \\Delta M_{\\mathrm{prim}}, \\Delta P_{\\mathrm{prim}}, \\Delta E_{\\mathrm{prim}}]$. The numbers must be printed as raw decimal values with default Python formatting, in a single line, enclosed in square brackets, for example: $[[m_1,p_1,e_1,m'_1,p'_1,e'_1],[m_2,p_2,e_2,m'_2,p'_2,e'_2],\\dots]$.",
            "solution": "The problem requires a comparison between two numerical schemes for the one-dimensional compressible Euler equations on a periodic domain: a conservative finite-volume scheme and a non-conservative finite-difference scheme. The analysis centers on quantifying the conservation of total mass, momentum, and energy after a single time step for several smooth initial conditions.\n\nFirst, we establish the mathematical and physical context. The state of the fluid is described by primitive variables: density $\\rho$, velocity $u$, and pressure $p$. Alternatively, it can be described by conserved variables: mass density $\\rho$, momentum density $\\rho u$, and total energy density $\\rho E$. The system is closed by the equation of state (EOS) for a calorically perfect ideal gas, $p = (\\gamma - 1)\\rho e$, where $\\gamma$ is the ratio of specific heats, and $e$ is the specific internal energy. The total energy per unit mass is the sum of internal and kinetic energies, $E = e + \\frac{1}{2}u^2$. From these definitions, the total energy density can be expressed in terms of primitive variables: $\\rho E = \\frac{p}{\\gamma-1} + \\frac{1}{2}\\rho u^2$.\n\nThe governing equations are the Euler equations, which express the conservation of mass, momentum, and energy. In conservative form, they are given by $\\partial_t U + \\partial_x F(U) = 0$, where $U = [\\rho, \\rho u, \\rho E]^T$ is the vector of conserved variables and $F(U) = [\\rho u, \\rho u^2 + p, u(\\rho E + p)]^T$ is the flux vector. Explicitly:\n$$\n\\partial_t \\rho + \\partial_x (\\rho u) = 0\n$$\n$$\n\\partial_t (\\rho u) + \\partial_x (\\rho u^2 + p) = 0\n$$\n$$\n\\partial_t (\\rho E) + \\partial_x (u(\\rho E + p)) = 0\n$$\nFor smooth solutions, applying the product rule for differentiation to the conservative form yields an algebraically equivalent system in non-conservative form, expressed in terms of primitive variables:\n$$\n\\partial_t \\rho + u\\,\\partial_x \\rho + \\rho\\,\\partial_x u = 0\n$$\n$$\n\\partial_t u + u\\,\\partial_x u + \\frac{1}{\\rho}\\,\\partial_x p = 0\n$$\n$$\n\\partial_t p + u\\,\\partial_x p + \\gamma p\\,\\partial_x u = 0\n$$\nWhile mathematically equivalent in the continuous sense, their discrete counterparts exhibit fundamentally different behavior regarding conservation properties.\n\nThe numerical experiment is conducted on a one-dimensional periodic domain $x \\in [0, L)$ with $L=2\\pi$, discretized into $N$ uniform cells of width $\\Delta x = L/N$. The cell centers are $x_i = (i+0.5)\\Delta x$ for $i=0, 1, \\dots, N-1$. A single explicit time step, $\\Delta t$, is determined by the Courant–Friedrichs–Lewy (CFL) condition: $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / a_{\\max}$, where $\\mathrm{CFL}$ is a given number, and $a_{\\max} = \\max_i(|u_i| + c_i)$ is the maximum characteristic wave speed over the grid, with $c_i = \\sqrt{\\gamma p_i / \\rho_i}$ being the local sound speed.\n\nThe initial conditions for each test case are given by smooth sinusoidal functions for $\\rho(x)$, $u(x)$, and $p(x)$. We first evaluate these functions at the cell centers $x_i$ to obtain the initial discrete state $(\\rho^n_i, u^n_i, p^n_i)$.\n\nThe procedure involves the following steps for each test case:\n\n1.  **Initialization**: Set up the grid and compute the initial primitive variables $(\\rho^n, u^n, p^n)$ at cell centers. Calculate the initial conserved variables $U^n$ from the primitive ones. Compute the initial total mass $M^n$, momentum $P^n$, and energy $E_{\\mathrm{tot}}^n$ by summing over the grid: $M^n = \\sum_i \\rho^n_i \\Delta x$, $P^n = \\sum_i (\\rho u)^n_i \\Delta x$, and $E_{\\mathrm{tot}}^n = \\sum_i (\\rho E)^n_i \\Delta x$. Calculate the time step $\\Delta t$ based on the initial state.\n\n2.  **Conservative Finite-Volume Scheme**: This scheme updates the cell-averaged conserved variables $U_i$. The update formula is:\n    $$\n    U_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} (F^*_{i+1/2} - F^*_{i-1/2})\n    $$\n    where $F^*_{i+1/2}$ is the numerical flux at the interface between cell $i$ and cell $i+1$. We use the local Lax–Friedrichs (Rusanov) flux:\n    $$\n    F^*(U_L, U_R) = \\frac{1}{2}(F(U_L) + F(U_R)) - \\frac{1}{2} a_{\\max, \\text{face}} (U_R - U_L)\n    $$\n    Here, $U_L = U_i^n$ and $U_R = U_{i+1}^n$ are the states to the left and right of the face (with periodic indexing for the last face). The wave speed $a_{\\max, \\text{face}}$ is computed locally for each face as $a_{\\max, \\text{face}} = \\max(|u_L|+c_L, |u_R|+c_R)$. After computing $U_i^{n+1}$ for all $i$, the final total conserved quantities $M_{\\mathrm{cons}}^{n+1}$, $P_{\\mathrm{cons}}^{n+1}$, and $E_{\\mathrm{tot}, \\mathrm{cons}}^{n+1}$ are calculated. The crucial property of this scheme on a periodic grid is that the sum of the flux differences telescopes to zero, $\\sum_{i=0}^{N-1} (F^*_{i+1/2} - F^*_{i-1/2}) = 0$, ensuring that $\\sum_i U_i^{n+1} = \\sum_i U_i^n$. Thus, any change in the total conserved quantities will be due solely to floating-point arithmetic errors.\n\n3.  **Non-Conservative Primitive-Variable Scheme**: This scheme directly discretizes the non-conservative form of the Euler equations and updates the primitive variables. Spatial derivatives are approximated using second-order centered finite differences on the periodic grid, for example $\\partial_x w |_i \\approx (w_{i+1} - w_{i-1}) / (2\\Delta x)$. The time derivatives $(\\partial_t \\rho, \\partial_t u, \\partial_t p)$ are computed at each cell center using the discretized non-conservative equations. An explicit Euler time step updates the primitive variables:\n    $$\n    \\rho_i^{n+1} = \\rho_i^n + \\Delta t (\\partial_t \\rho)_i^n\n    $$\n    $$\n    u_i^{n+1} = u_i^n + \\Delta t (\\partial_t u)_i^n\n    $$\n    $$\n    p_i^{n+1} = p_i^n + \\Delta t (\\partial_t p)_i^n\n    $$\n    After obtaining the new primitive variables $(\\rho_{\\mathrm{prim}}^{n+1}, u_{\\mathrm{prim}}^{n+1}, p_{\\mathrm{prim}}^{n+1})$, they are converted back to conserved variables. The final total quantities $M_{\\mathrm{prim}}^{n+1}$, $P_{\\mathrm{prim}}^{n+1}$, and $E_{\\mathrm{tot}, \\mathrm{prim}}^{n+1}$ are then calculated. This scheme lacks the telescoping sum property, and thus is not expected to conserve the total quantities, even for smooth flow. The discretization error introduces artificial sources or sinks for mass, momentum, and energy.\n\n4.  **Analysis**: For both schemes, the change in each conserved quantity is computed as the absolute difference between the final and initial total value. For the conservative scheme, these changes are denoted $\\Delta M_{\\mathrm{cons}}$, $\\Delta P_{\\mathrm{cons}}$, $\\Delta E_{\\mathrm{cons}}$. For the primitive-variable scheme, they are $\\Delta M_{\\mathrm{prim}}$, $\\Delta P_{\\mathrm{prim}}$, $\\Delta E_{\\mathrm{prim}}$. These six values are reported for each test case. As predicted by theory, the changes for the conservative scheme should be on the order of machine precision, while the changes for the non-conservative scheme will be significantly larger, demonstrating the failure to preserve discrete conservation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment comparing conservative and \n    non-conservative schemes for the 1D Euler equations.\n    \"\"\"\n    \n    test_cases = [\n        # Test 1\n        {'N': 128, 'CFL': 0.5, 'k': 2, 'rho0': 1.0, 'u0': 0.0, 'p0': 1.0,\n         'arho': 0.1, 'au': 0.1, 'ap': 0.1, 'phirho': 0.0, 'phiu': 0.0, 'phip': 0.0},\n        # Test 2\n        {'N': 128, 'CFL': 0.5, 'k': 3, 'rho0': 1.0, 'u0': 0.0, 'p0': 1.0,\n         'arho': 1e-8, 'au': 1e-8, 'ap': 1e-8, 'phirho': 0.0, 'phiu': 0.0, 'phip': 0.0},\n        # Test 3\n        {'N': 128, 'CFL': 0.5, 'k': 1, 'rho0': 1.0, 'u0': 0.0, 'p0': 1.0,\n         'arho': 0.2, 'au': 0.0, 'ap': 0.2, 'phirho': 0.0, 'phiu': 0.0, 'phip': 0.0},\n        # Test 4\n        {'N': 128, 'CFL': 0.5, 'k': 4, 'rho0': 1.0, 'u0': 0.0, 'p0': 1.0,\n         'arho': 0.0, 'au': 0.3, 'ap': 0.3, 'phirho': 0.0, 'phiu': np.pi / 3.0, 'phip': -np.pi / 4.0},\n    ]\n\n    L = 2.0 * np.pi\n    gamma = 1.4\n    all_results = []\n\n    def prim_to_cons(rho, u, p, gamma_val):\n        rhoE = p / (gamma_val - 1.0) + 0.5 * rho * u**2\n        return np.stack([rho, rho * u, rhoE], axis=-1)\n\n    def cons_to_prim(U, gamma_val):\n        rho = U[..., 0]\n        u = U[..., 1] / rho\n        rhoE = U[..., 2]\n        p = (gamma_val - 1.0) * (rhoE - 0.5 * rho * u**2)\n        return rho, u, p\n\n    def get_flux(rho, u, p, gamma_val):\n        rhoE = p / (gamma_val - 1.0) + 0.5 * rho * u**2\n        return np.stack([rho * u, rho * u**2 + p, u * (rhoE + p)], axis=-1)\n\n    for params in test_cases:\n        N = params['N']\n        CFL = params['CFL']\n        \n        # 1. Setup grid and initial conditions\n        dx = L / N\n        x = (np.arange(N) + 0.5) * dx\n\n        rho_n = params['rho0'] + params['arho'] * np.sin(params['k'] * x + params['phirho'])\n        u_n = params['u0'] + params['au'] * np.sin(params['k'] * x + params['phiu'])\n        p_n = params['p0'] + params['ap'] * np.cos(params['k'] * x + params['phip'])\n\n        # 2. Time Step Calculation\n        c_n = np.sqrt(gamma * p_n / rho_n)\n        a_max = np.max(np.abs(u_n) + c_n)\n        dt = CFL * dx / a_max\n        \n        # 3. Initial State Analysis\n        U_n = prim_to_cons(rho_n, u_n, p_n, gamma)\n        M_n = np.sum(U_n[:, 0]) * dx\n        P_n = np.sum(U_n[:, 1]) * dx\n        E_n = np.sum(U_n[:, 2]) * dx\n        \n        # --- Scheme 1: Conservative Finite-Volume Update ---\n        U_cons = np.copy(U_n)\n        fluxes = np.zeros_like(U_n)\n\n        # Loop over faces i + 1/2\n        for i in range(N):\n            i_right = (i + 1) % N\n            \n            U_L = U_cons[i, :]\n            U_R = U_cons[i_right, :]\n            \n            rho_L, u_L, p_L = cons_to_prim(U_L, gamma)\n            rho_R, u_R, p_R = cons_to_prim(U_R, gamma)\n            \n            c_L = np.sqrt(gamma * p_L / rho_L)\n            c_R = np.sqrt(gamma * p_R / rho_R)\n            \n            F_L = get_flux(rho_L, u_L, p_L, gamma)\n            F_R = get_flux(rho_R, u_R, p_R, gamma)\n            \n            a_max_face = max(np.abs(u_L) + c_L, np.abs(u_R) + c_R)\n            \n            fluxes[i, :] = 0.5 * (F_L + F_R) - 0.5 * a_max_face * (U_R - U_L)\n        \n        U_cons_np1 = U_cons - (dt / dx) * (fluxes - np.roll(fluxes, 1, axis=0))\n        \n        M_cons_np1 = np.sum(U_cons_np1[:, 0]) * dx\n        P_cons_np1 = np.sum(U_cons_np1[:, 1]) * dx\n        E_cons_np1 = np.sum(U_cons_np1[:, 2]) * dx\n        \n        delta_M_cons = M_cons_np1 - M_n\n        delta_P_cons = P_cons_np1 - P_n\n        delta_E_cons = E_cons_np1 - E_n\n        \n        # --- Scheme 2: Non-Conservative Primitive-Variable Update ---\n        rho_prim, u_prim, p_prim = np.copy(rho_n), np.copy(u_n), np.copy(p_n)\n        \n        # Central differences for spatial derivatives\n        d_rho_dx = (np.roll(rho_prim, -1) - np.roll(rho_prim, 1)) / (2.0 * dx)\n        d_u_dx = (np.roll(u_prim, -1) - np.roll(u_prim, 1)) / (2.0 * dx)\n        d_p_dx = (np.roll(p_prim, -1) - np.roll(p_prim, 1)) / (2.0 * dx)\n        \n        # Time derivatives from primitive equations\n        d_rho_dt = -u_prim * d_rho_dx - rho_prim * d_u_dx\n        d_u_dt = -u_prim * d_u_dx - (1.0 / rho_prim) * d_p_dx\n        d_p_dt = -u_prim * d_p_dx - gamma * p_prim * d_u_dx\n        \n        # Explicit Euler update\n        rho_prim_np1 = rho_prim + dt * d_rho_dt\n        u_prim_np1 = u_prim + dt * d_u_dt\n        p_prim_np1 = p_prim + dt * d_p_dt\n        \n        U_prim_np1 = prim_to_cons(rho_prim_np1, u_prim_np1, p_prim_np1, gamma)\n        \n        M_prim_np1 = np.sum(U_prim_np1[:, 0]) * dx\n        P_prim_np1 = np.sum(U_prim_np1[:, 1]) * dx\n        E_prim_np1 = np.sum(U_prim_np1[:, 2]) * dx\n\n        delta_M_prim = M_prim_np1 - M_n\n        delta_P_prim = P_prim_np1 - P_n\n        delta_E_prim = E_prim_np1 - E_n\n        \n        all_results.append([\n            delta_M_cons, delta_P_cons, delta_E_cons,\n            delta_M_prim, delta_P_prim, delta_E_prim\n        ])\n\n    print(f\"[{','.join([f'[{\",\".join(map(str, r))}]' for r in all_results])}]\")\n\nsolve()\n```"
        }
    ]
}