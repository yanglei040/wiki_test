{
    "hands_on_practices": [
        {
            "introduction": "本练习将指导您构建一个求解稳态流函数-涡量方程的基础求解器。通过使用定点迭代（皮卡迭代）方法，您将学习如何处理速度与涡量之间的非线性耦合。此练习采用了“人造解方法”（Method of Manufactured Solutions），这是一种严谨的代码验证技术，可帮助您确保计算结果的准确性()。",
            "id": "3389266",
            "problem": "考虑在边长为 $L=1$ 的方形域上的二维不可压缩Navier–Stokes方程，两个空间方向均采用周期性边界条件。令 $\\boldsymbol{u} = (u, v)$ 表示速度场，$p$ 表示压力，$\\nu$ 表示运动粘度。无量綱形式的控制方程为\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + \\boldsymbol{u} \\cdot \\nabla \\boldsymbol{u} = -\\nabla p + \\nu \\nabla^2 \\boldsymbol{u} + \\boldsymbol{f}, \\quad \\nabla \\cdot \\boldsymbol{u} = 0.\n$$\n定义标量涡量 $\\omega$ 为 $\\omega = \\partial v/\\partial x - \\partial u/\\partial y$，并引入流函数 $\\psi$ 使得 $\\boldsymbol{u} = \\left(\\frac{\\partial \\psi}{\\partial y}, -\\frac{\\partial \\psi}{\\partial x}\\right)$。对于二维不可压缩流，流函数和涡量通过Poisson方程相关联\n$$\n\\nabla^2 \\psi = -\\omega.\n$$\n从不可压缩Navier–Stokes方程出发，二维涡量输运方程为\n$$\n\\frac{\\partial \\omega}{\\partial t} + \\boldsymbol{u} \\cdot \\nabla \\omega = \\nu \\nabla^2 \\omega + S,\n$$\n其中 $S$ 是一个标量源项，等于体积力 $\\boldsymbol{f}$ 的旋度：\n$$\nS = \\left(\\nabla \\times \\boldsymbol{f}\\right)_z.\n$$\n在流函数-涡量公式中，耦合是非线性的，因为 $\\boldsymbol{u}$ 依赖于 $\\psi$，而 $\\psi$ 又依赖于 $\\omega$，且平流项 $\\boldsymbol{u} \\cdot \\nabla \\omega$ 同时依赖于 $\\boldsymbol{u}$ 和 $\\omega$。\n\n您的任务是实现一个不动点分裂迭代（Picard迭代），通过交替求解流函数的Poisson方程和使用显式伪时间步更新涡量，来近似求解涡量输运方程的稳態解。在伪时间步 $n$ 的迭代过程如下：\n1. 给定当前涡量场 $\\omega^n$，求解流函数 $\\psi^n$ 的Poisson方程：\n   $$\n   \\nabla^2 \\psi^n = -\\omega^n.\n   $$\n2. 计算速度场 $\\boldsymbol{u}^n = \\left(\\frac{\\partial \\psi^n}{\\partial y}, -\\frac{\\partial \\psi^n}{\\partial x}\\right)$。\n3. 使用下式显式更新涡量\n   $$\n   \\omega^{n+1} = \\omega^n + \\Delta t \\left( -\\nabla \\cdot \\left( \\omega^n \\boldsymbol{u}^n \\right) + \\nu \\nabla^2 \\omega^n + S \\right),\n   $$\n   其中平流项以涡量通量散度的守恒形式进行离散化，并且 $\\nu = 1/\\mathrm{Re}$，其中 $\\mathrm{Re}$ 是Reynolds数。迭代旨在收敛到满足以下条件的稳态：\n   $$\n   \\nabla \\cdot \\left( \\omega \\boldsymbol{u} \\right) = \\nu \\nabla^2 \\omega + S \\quad \\text{with} \\quad \\boldsymbol{u} = \\left(\\frac{\\partial \\psi}{\\partial y}, -\\frac{\\partial \\psi}{\\partial x}\\right), \\quad \\nabla^2 \\psi = -\\omega.\n   $$\n\n为了使问题适定且可验证，请使用人造解方法。考虑精确流函数\n$$\n\\psi_{\\text{exact}}(x,y) = \\sin(2\\pi x)\\sin(2\\pi y),\n$$\n以及相应的精确速度\n$$\n\\boldsymbol{u}_{\\text{exact}}(x,y) = \\left( \\frac{\\partial \\psi_{\\text{exact}}}{\\partial y}, -\\frac{\\partial \\psi_{\\text{exact}}}{\\partial x} \\right),\n$$\n和精确涡量\n$$\n\\omega_{\\text{exact}}(x,y) = -\\nabla^2 \\psi_{\\text{exact}}(x,y).\n$$\n定义源项 $S$，使其与您算法中使用的离散守恒平流和谱扩散相一致：\n$$\nS := \\nabla \\cdot \\left( \\omega_{\\text{exact}} \\boldsymbol{u}_{\\text{exact}} \\right) - \\nu \\nabla^2 \\omega_{\\text{exact}}.\n$$\n使用此 $S$ 项，人造场满足所选离散形式的稳态涡量输运方程，使其在理想分辨率和充分收敛的条件下成为迭代的一个不动点。\n\n算法和数值要求：\n- 空间离散化：在 $[0,1)\\times[0,1)$ 上使用具有 $N \\times N$ 个点的均匀网格，并采用周期性边界条件。网格间距为 $h = 1/N$。\n- 谱方法操作：使用适用于周期性域的傅里葉譜方法实现Poisson求解和拉普拉斯算子。具体来说，如果 $\\widehat{f}$ 表示 $f$ 的傅里叶变换，$k_x, k_y$ 是离散波数，那么 $\\nabla^2 f$ 在谱空间中表示为 $-\\left(k_x^2 + k_y^2\\right)\\widehat{f}$，并且Poisson方程 $\\nabla^2 \\psi = -\\omega$ 在傅里叶空间中通过 $\\widehat{\\psi} = \\widehat{\\omega}/\\left(k_x^2 + k_y^2\\right)$ 求解（对于非零波数），并将 $\\widehat{\\psi}$ 的零模设置为零。\n- 速度计算：通过谱微分从 $\\psi$ 计算 $\\boldsymbol{u}$，即 $\\widehat{u} = i k_y \\widehat{\\psi}$ 和 $\\widehat{v} = -i k_x \\widehat{\\psi}$，然后进行傅里叶逆变换。\n- 平流项：在周期性网格上使用二阶中心有限差分将 $-\\boldsymbol{u}\\cdot \\nabla \\omega$ 以守恒形式 $-\\nabla \\cdot \\left(\\omega \\boldsymbol{u}\\right)$ 进行离散化：\n  $$\n  \\nabla \\cdot \\left(\\omega \\boldsymbol{u}\\right) \\approx \\frac{F_x(i,j+1) - F_x(i,j-1)}{2h} + \\frac{F_y(i+1,j) - F_y(i-1,j)}{2h}, \\quad F_x = u \\omega, \\quad F_y = v \\omega,\n  $$\n  其中 $i$ 和 $j$ 分别是网格在 $y$ 和 $x$ 方向的索引，索引会周期性地回绕。\n- 扩散项：如上所述，使用谱方法计算 $\\nabla^2 \\omega$。\n- 迭代：从 $\\omega^0 \\equiv 0$ 开始。对于每个伪时间步，执行不动点分裂：从 $\\omega^n$ 求解 $\\psi^n$，计算 $\\boldsymbol{u}^n$，然后通过显式步更新 $\\omega^{n+1}$。迭代中使用恒定的伪时间步 $\\Delta t$。\n\n测试套件：\n实现您的程序以运行以下三个测试用例，每个用例由元组 $(N, \\mathrm{Re}, \\Delta t, \\text{steps})$ 定义，所有量均为无量纲：\n1. A例（中等平流-扩散）：($N=48$, $\\mathrm{Re}=100$, $\\Delta t=2.0\\times 10^{-4}$, steps=600)。\n2. B例（扩散主导）：($N=48$, $\\mathrm{Re}=5$, $\\Delta t=2.0\\times 10^{-4}$, steps=600)。\n3. C例（平流主导）：($N=64$, $\\mathrm{Re}=1000$, $\\Delta t=1.0\\times 10^{-4}$, steps=800)。\n\n对于每个用例，计算最后一次迭代时数值涡量与人造精确涡量之间的均方根误差，\n$$\nE = \\sqrt{\\frac{1}{N^2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left(\\omega^{\\text{final}}_{i,j} - \\omega_{\\text{exact}, i,j}\\right)^2 }.\n$$\n\n最终输出规范：\n- 程序必须生成单行输出，其中包含A例、B例和C例的三个误差，形式为用方括号括起来的逗号分隔列表。每个误差必须四舍五入到六位小数。例如：\"[0.012345,0.001234,0.123456]\"。\n- 所有量均为无量纲；不涉及物理单位。\n\n您的实现必须是一个完整、可运行的程序，并遵守最终答案块中指定的执行环境限制。",
            "solution": "问题陈述经过了仔细验证，被认为是具有科学依据、适定且内部一致的。它提出了计算流体力学中的一个标准验证练习，利用人造解方法来测试二维不可压缩Navier–Stokes方程的流函数-涡量公式的数值实现。指定的数值方法，包括在周期性域上混合使用谱方法和有限差分技术，是恰当且定义清晰的。测试用例的参数是合理的，应该能得到稳定的数值迭代。因此，我们可以着手提供一个完整的解决方案。\n\n目标是通过不动点迭代方法找到涡量输运方程的稳态解，\n$$\n\\frac{\\partial \\omega}{\\partial t} + \\nabla \\cdot (\\omega \\boldsymbol{u}) = \\nu \\nabla^2 \\omega + S\n$$\n在稳态下（$\\partial \\omega / \\partial t = 0$），方程变为\n$$\n\\nabla \\cdot (\\omega \\boldsymbol{u}) = \\nu \\nabla^2 \\omega + S\n$$\n该方程与关联流函数 $\\psi$ 和涡量 $\\omega$ 的Poisson方程 $\\nabla^2 \\psi = -\\omega$ 以及从流函数导出的速度运动学定义 $\\boldsymbol{u} = (\\partial \\psi/\\partial y, -\\partial \\psi/\\partial x)$ 相耦合。所提出的迭代方案通过滞后处理非线性平流项来解决此系统。给定伪时间步 $n$ 处的涡量 $\\omega^n$，$\\omega^{n+1}$ 的更新通过一个显式向前Euler步计算：\n$$\n\\frac{\\omega^{n+1} - \\omega^n}{\\Delta t} = -\\nabla \\cdot \\left( \\omega^n \\boldsymbol{u}^n \\right) + \\nu \\nabla^2 \\omega^n + S\n$$\n其中 $\\boldsymbol{u}^n$ 从 $\\omega^n$ 导出。\n\n空间域是一个双周期方块 $[0,1) \\times [0,1)$，用 $N \\times N$ 个点的均匀网格离散化。网格间距为 $h=1/N$。这种周期性使得傅里叶谱方法在计算空间导数和求解Poisson方程时非常有效。\n\n我们首先建立计算框架。对于大小为 $N$、间距为 $h$ 的网格，离散波数由 $k = 2\\pi f$ 给出，其中 $f$ 是从 `numpy.fft.fftfreq(N, d=h)` 获得的离散频率。我们构建二维波数数组 $k_x$ 和 $k_y$。拉普拉斯算子 $\\nabla^2$ 作用于场 $g$ 的谱表示是将其傅里叶变换 $\\widehat{g}$ 乘以 $-(k_x^2 + k_y^2)$。令 $K^2 = k_x^2 + k_y^2$。那么，$\\widehat{\\nabla^2 g} = -K^2 \\widehat{g}$。Poisson方程 $\\nabla^2 \\psi = -\\omega$ 在傅里葉空間中求解为：\n$$\n\\widehat{\\psi} = - \\frac{\\widehat{\\omega}}{-K^2} = \\frac{\\widehat{\\omega}}{K^2}\n$$\n对于零波数模式（$k_x=k_y=0$），除以 $K^2$ 是未定义的。对于周期性域，流函数的平均值是任意的。我们通过将平均值设置为零来固定它，这对应于设置 $\\widehat{\\psi}(0,0) = 0$。\n\n速度分量 $(u, v)$ 通过谱微分从流函数 $\\psi$ 计算得出：\n$$\n\\widehat{u} = \\widehat{\\frac{\\partial \\psi}{\\partial y}} = i k_y \\widehat{\\psi}, \\qquad \\widehat{v} = \\widehat{-\\frac{\\partial \\psi}{\\partial x}} = -i k_x \\widehat{\\psi}\n$$\n然后通过快速傅里叶逆变换（FFT）恢复物理速度场 $u$ 和 $v$。\n\n采用人造解方法进行验证。我们定义一个精确的解析解，并推导出一个源项 $S$，该源项迫使此解满足离散化的稳态方程。选定的精确流函数为：\n$$\n\\psi_{\\text{exact}}(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)\n$$\n由此，我们推导出精确的涡量场和速度场：\n$$\n\\omega_{\\text{exact}} = -\\nabla^2 \\psi_{\\text{exact}} = -(-\\left(2\\pi\\right)^2 - \\left(2\\pi\\right)^2)\\psi_{\\text{exact}} = 8\\pi^2 \\sin(2\\pi x)\\sin(2\\pi y)\n$$\n$$\nu_{\\text{exact}} = \\frac{\\partial \\psi_{\\text{exact}}}{\\partial y} = 2\\pi \\sin(2\\pi x)\\cos(2\\pi y)\n$$\n$$\nv_{\\text{exact}} = -\\frac{\\partial \\psi_{\\text{exact}}}{\\partial x} = -2\\pi \\cos(2\\pi x)\\sin(2\\pi y)\n$$\n源项 $S$ 至关重要。为确保人造解是我们数值格式的真正不动点，$S$ 必须使用与迭代求解器中*相同的离散算子*来计算。稳态方程为 $S = \\nabla \\cdot (\\omega \\boldsymbol{u}) - \\nu \\nabla^2 \\omega$。因此，我们将离散源项 $S_{i,j}$ 定义为：\n$$\nS_{i,j} = \\mathcal{D}_{FD}(\\omega_{\\text{exact}}, \\boldsymbol{u}_{\\text{exact}})_{i,j} - \\nu \\mathcal{L}_{SP}(\\omega_{\\text{exact}})_{i,j}\n$$\n其中 $\\mathcal{D}_{FD}$ 是用于散度项 $\\nabla\\cdot(\\omega\\boldsymbol{u})$ 的二阶中心有限差分算子，而 $\\mathcal{L}_{SP}$ 是用于拉普拉斯算子 $\\nabla^2 \\omega$ 的谱算子。作用于通量 $F_x=\\omega u$ 和 $F_y=\\omega v$ 的有限差分算子为：\n$$\n\\mathcal{D}_{FD} \\approx \\frac{F_x(i,j+1) - F_x(i,j-1)}{2h} + \\frac{F_y(i+1,j) - F_y(i-1,j)}{2h}\n$$\n周期性索引使用 `numpy.roll` 处理。\n\n对于每个测试用例 $(N, \\mathrm{Re}, \\Delta t, \\text{steps})$，迭代算法按以下步骤进行：\n1.  **设置**：定义网格参数 ($h$)、谱参数 ($k_x, k_y, K^2$) 和物理常数 ($\\nu=1/\\mathrm{Re}$)。\n2.  **人造解**：在离散网格上计算 $\\psi_{\\text{exact}}$、$\\omega_{\\text{exact}}$ 和 $\\boldsymbol{u}_{\\text{exact}}$。\n3.  **源项**：如上所述，使用混合离散化计算源项 $S$。\n4.  **初始化**：设置初始涡量场 $\\omega^0_{i,j} = 0$。\n5.  **迭代**：从 $n=0$ 到 $\\text{steps}-1$：\n    a. 计算当前涡量的傅里叶变换，$\\widehat{\\omega}^n = \\text{FFT}(\\omega^n)$。\n    b. 在傅里叶空间中求解流函数：$\\widehat{\\psi}^n = \\widehat{\\omega}^n / K^2$（其中 $\\widehat{\\psi}^n(0,0)=0$）。\n    c. 通过谱微分和傅里葉逆變換计算速度场：$\\boldsymbol{u}^n = \\text{IFFT}(i k_y \\widehat{\\psi}^n, -i k_x \\widehat{\\psi}^n)$。\n    d. 计算涡量更新方程的右端项 (RHS)：\n       $$\n       \\text{RHS} = -\\mathcal{D}_{FD}(\\omega^n, \\boldsymbol{u}^n) + \\nu \\mathcal{L}_{SP}(\\omega^n) + S\n       $$\n    e. 使用伪时间的向前Euler步更新涡量场：$\\omega^{n+1} = \\omega^n + \\Delta t \\cdot \\text{RHS}$。\n6.  **误差计算**：在最后一步之后，计算最终数值涡量 $\\omega^{\\text{final}}$ 与精确涡量 $\\omega_{\\text{exact}}$ 之间的均方根 (RMS) 误差：\n    $$\n    E = \\sqrt{\\frac{1}{N^2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left(\\omega^{\\text{final}}_{i,j} - \\omega_{\\text{exact}, i,j}\\right)^2}\n    $$\n对问题陈述中指定的三个测试用例中的每一个都重复此过程。最终输出将是这三个计算出的误差列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, Re, dt, steps):\n    \"\"\"\n    Solves the 2D steady vorticity transport equation using a fixed-point\n    iteration on a periodic domain with a manufactured solution for verification.\n    \"\"\"\n    # 1. Grid and Parameters\n    L = 1.0\n    h = L / N\n    nu = 1.0 / Re\n\n    # Physical grid\n    x = np.linspace(0, L, N, endpoint=False)\n    y = np.linspace(0, L, N, endpoint=False)\n    X, Y = np.meshgrid(x, y)\n\n    # Spectral grid (wavenumbers)\n    kx_vec = 2 * np.pi * np.fft.fftfreq(N, d=h)\n    ky_vec = 2 * np.pi * np.fft.fftfreq(N, d=h)\n    KX, KY = np.meshgrid(kx_vec, ky_vec, indexing='xy')\n\n    # Squared wavenumbers and inverse Laplacian operator\n    K_sq = KX**2 + KY**2\n    inv_K_sq = np.zeros_like(K_sq)\n    # Avoid division by zero at the (0,0) mode\n    non_zero_k = K_sq != 0\n    inv_K_sq[non_zero_k] = 1.0 / K_sq[non_zero_k]\n\n    # 2. Manufactured Solution and Source Term\n    # Exact streamfunction\n    psi_exact = np.sin(2 * np.pi * X) * np.sin(2 * np.pi * Y)\n    \n    # Exact vorticity: omega = -nabla^2(psi)\n    omega_exact = 8 * (np.pi**2) * np.sin(2 * np.pi * X) * np.sin(2 * np.pi * Y)\n    \n    # Exact velocity: u = d(psi)/dy, v = -d(psi)/dx\n    u_exact = 2 * np.pi * np.sin(2 * np.pi * X) * np.cos(2 * np.pi * Y)\n    v_exact = -2 * np.pi * np.cos(2 * np.pi * X) * np.sin(2 * np.pi * Y)\n    \n    # Helper for the centered finite-difference divergence\n    def fd_divergence(Fx, Fy, grid_spacing):\n        # Note: numpy arrays are indexed (row, col) which corresponds to (y, x).\n        # axis=1 is x-direction, axis=0 is y-direction.\n        dFx_dx = (np.roll(Fx, -1, axis=1) - np.roll(Fx, 1, axis=1)) / (2 * grid_spacing)\n        dFy_dy = (np.roll(Fy, -1, axis=0) - np.roll(Fy, 1, axis=0)) / (2 * grid_spacing)\n        return dFx_dx + dFy_dy\n        \n    # Source term S such that the exact solution is a fixed point of the discrete operators\n    # S = div(omega_exact * u_exact) [FD] - nu * laplacian(omega_exact) [Spectral]\n    \n    # Advection term computed with finite differences\n    Fx_exact = u_exact * omega_exact\n    Fy_exact = v_exact * omega_exact\n    advection_exact_term = fd_divergence(Fx_exact, Fy_exact, h)\n\n    # Diffusion term computed spectrally\n    omega_exact_hat = np.fft.fft2(omega_exact)\n    laplacian_omega_exact = np.fft.ifft2(-K_sq * omega_exact_hat).real\n    diffusion_exact_term = nu * laplacian_omega_exact\n    \n    S = advection_exact_term - diffusion_exact_term\n    \n    # 3. Iteration Loop\n    # Initialize vorticity field\n    omega = np.zeros((N, N), dtype=float)\n\n    for _ in range(steps):\n        omega_n = omega\n        \n        # 1. Solve for streamfunction psi^n from omega^n\n        omega_n_hat = np.fft.fft2(omega_n)\n        psi_n_hat = -omega_n_hat * inv_K_sq\n        \n        # 2. Compute velocity u^n\n        u_n_hat = 1j * KY * psi_n_hat\n        v_n_hat = -1j * KX * psi_n_hat\n        u_n = np.fft.ifft2(u_n_hat).real\n        v_n = np.fft.ifft2(v_n_hat).real\n        \n        # 3. Compute RHS of vorticity update equation\n        # RHS = -div(omega*u) [FD] + nu*laplacian(omega) [Spectral] + S\n        \n        # Advection term: -div(omega*u) [FD]\n        Fx_n = u_n * omega_n\n        Fy_n = v_n * omega_n\n        advection_n_term = fd_divergence(Fx_n, Fy_n, h)\n        \n        # Diffusion term: nu*laplacian(omega) [Spectral]\n        laplacian_omega_n = np.fft.ifft2(-K_sq * omega_n_hat).real\n        diffusion_n_term = nu * laplacian_omega_n\n\n        # Assemble RHS\n        rhs = -advection_n_term + diffusion_n_term + S\n        \n        # 4. Update vorticity (Forward Euler in pseudo-time)\n        omega = omega_n + dt * rhs\n\n    # 4. Calculate Error\n    error = np.sqrt(np.mean((omega - omega_exact)**2))\n    return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (N, Re, dt, steps)\n        (48, 100, 2.0e-4, 600),\n        # Case B: (N, Re, dt, steps)\n        (48, 5, 2.0e-4, 600),\n        # Case C: (N, Re, dt, steps)\n        (64, 1000, 1.0e-4, 800),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, Re, dt, steps = case\n        rms_error = run_simulation(N, Re, dt, steps)\n        results.append(rms_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.6f}' for err in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本练习将从稳态问题转向非稳态流动，探索如何使用伪谱方法模拟经典的双剪切层不稳定性。重点是处理非线性模拟中的一个关键数值问题：混淆误差（aliasing error）。您将通过实现并比较不同的去混淆技术，深入理解它们在保持能量和拟涡能等物理不变量方面的作用和效果()。",
            "id": "3389248",
            "problem": "考虑在边长为 $2\\pi$ 的双周期方形区域上，以流函数-涡量公式表示的二维不可压缩欧拉方程。涡量场 $\\omega(x,y,t)$ 根据涡量输运方程 $\\,\\partial_t \\omega + J(\\psi,\\omega) = 0\\,$ 演化，其中流函数 $\\psi(x,y,t)$ 满足泊松方程 $-\\nabla^2 \\psi = \\omega$，雅可比算子 $J(\\psi,\\omega)$ 为 $J(\\psi,\\omega) = \\partial_x \\psi\\,\\partial_y \\omega - \\partial_y \\psi\\,\\partial_x \\omega$。速度分量为 $u = \\partial_y \\psi$ 和 $v = -\\partial_x \\psi$。假设全文使用无量纲变量。您必须推导并实现一个伪谱求解器，使用快速傅里葉變換 (FFT) 计算空间导数，并在物理空间中计算非线性雅可比项。您的推导起点必须是上述给出的不可压缩欧拉方程以及流函数、涡量和雅可比算子的定义。您必须基于这些来设计一个数值一致的算法。\n\n您的任务是通过比较非线性项的三种不同处理方法，来量化雅可比算子 $J(\\psi,\\omega)$ 中的数值混叠：\n- 不进行去混叠处理（直接伪谱计算）。\n- 三分之二波数截断（通常称为 $\\frac{2}{3}$ 去混叠）。\n- 对计算出的雅可比算子进行物理空间高斯滤波。\n\n使用无粘性双剪切层不稳定性作为初始条件。设初始速度为\n$$\nu(x,y,0) = U(y),\\quad v(x,y,0) = \\varepsilon \\sin(x),\n$$\n其中\n$$\nU(y) = \\tanh\\!\\left(\\frac{y - \\frac{\\pi}{2}}{\\delta}\\right) - \\tanh\\!\\left(\\frac{y - \\frac{3\\pi}{2}}{\\delta}\\right),\n$$\n涡量为\n$$\n\\omega(x,y,0) = \\partial_x v(x,y,0) - \\partial_y u(x,y,0) = \\varepsilon \\cos(x) - U'(y),\\quad U'(y) = \\frac{1}{\\delta}\\,\\mathrm{sech}^2\\!\\left(\\frac{y - \\frac{\\pi}{2}}{\\delta}\\right) - \\frac{1}{\\delta}\\,\\mathrm{sech}^2\\!\\left(\\frac{y - \\frac{3\\pi}{2}}{\\delta}\\right).\n$$\n在周期性区域 $[0,2\\pi)\\times[0,2\\pi)$ 上使用大小为 $N\\times N$ 的均匀网格进行计算。在傅里葉空間中，通过乘以与周期为 $2\\pi$ 的函数的傅里叶级数相对应的适当波数 $k_x$ 和 $k_y$ 来计算空间导数。对于所有情况，使用三阶形式精度的三阶段强稳定性保持龙格-库塔 (Runge–Kutta) 格式对 $\\partial_t \\omega = -J(\\psi,\\omega)$进行时间推进。\n\n定义以下诊断量来量化混叠：\n- 动能\n$$\nE(t) = \\frac{1}{2}\\int_{0}^{2\\pi}\\int_{0}^{2\\pi}\\left(u^2+v^2\\right)\\,\\mathrm{d}x\\,\\mathrm{d}y,\n$$\n- 拟涡能\n$$\nZ(t) = \\frac{1}{2}\\int_{0}^{2\\pi}\\int_{0}^{2\\pi}\\omega^2\\,\\mathrm{d}x\\,\\mathrm{d}y,\n$$\n- 末态高波数拟涡能占比 $f_{\\mathrm{high}}(T)$ 定义为傅里叶模态中 $|k_x|>\\kappa_c$ 或 $|k_y|>\\kappa_c$ 的部分所含的拟涡能与总拟涡能之比，其中 $\\kappa_c$ 是截断波数 $\\,\\kappa_c = \\left\\lfloor\\frac{N}{3}\\right\\rfloor\\,$，$N$ 是每个方向上的网格点数。\n\n计算不变量在模拟区间 $[0,T]$ 上的相对漂移：\n$$\n\\Delta E/E_0 = \\frac{E(T)-E(0)}{E(0)},\\qquad \\Delta Z/Z_0 = \\frac{Z(T)-Z(0)}{Z(0)}.\n$$\n\n实现三种非线性雅可比项处理方法：\n- 不去混叠：直接从谱导数在物理空间中计算 $J(\\psi,\\omega)$，不进行任何截断或滤波。\n- 三分之二去混叠：在形成构成 $J(\\psi,\\omega)$ 的物理空间乘积之前，将微分场的傅里叶谱在矩形区域 $|k_x|\\le \\kappa_c$ 和 $|k_y|\\le \\kappa_c$ 之外截断为零，然后在物理空间中计算乘积。\n- 物理空间滤波：直接计算 $J(\\psi,\\omega)$，然后将其与一个整数半径为 $r$、标准差为 $\\sigma$（以网格点为单位）的归一化可分离高斯核进行卷积，在两个方向上都使用周期性环绕。\n\n设计您的程序以运行以下测试套件，每个测试由元组 $(N,\\delta,\\varepsilon,\\Delta t, \\text{steps}, \\text{method}, r, \\sigma)$ 指定，其中 $r$ 和 $\\sigma$ 仅用于物理空间滤波：\n- 测试 1：($N=32$, $\\delta=0.05$, $\\varepsilon=0.05$, $\\Delta t=0.0010$, steps=150, method='none', $r=0$, $\\sigma=0.0$)\n- 测试 2：($N=32$, $\\delta=0.05$, $\\varepsilon=0.05$, $\\Delta t=0.0010$, steps=150, method='two_thirds', $r=0$, $\\sigma=0.0$)\n- 测试 3：($N=32$, $\\delta=0.05$, $\\varepsilon=0.05$, $\\Delta t=0.0010$, steps=150, method='physical', $r=1$, $\\sigma=0.70$)\n- 测试 4：($N=64$, $\\delta=0.05$, $\\varepsilon=0.05$, $\\Delta t=0.0007$, steps=150, method='none', $r=0$, $\\sigma=0.0$)\n- 测试 5：($N=64$, $\\delta=0.05$, $\\varepsilon=0.05$, $\\Delta t=0.0007$, steps=150, method='two_thirds', $r=0$, $\\sigma=0.0$)\n- 边缘测试 6：($N=48$, $\\delta=0.05$, $\\varepsilon=0.05$, $\\Delta t=0.0009$, steps=150, method='physical', $r=2$, $\\sigma=1.00$)\n\n对于每个测试，计算并报告三元组 $[\\Delta E/E_0,\\ \\Delta Z/Z_0,\\ f_{\\mathrm{high}}(T)]$，其值为实数（无单位）。您的程序应生成单行输出，其中包含这些三元组的逗号分隔列表，并用方括号括起来，例如 $[\\,[a,b,c],\\,[d,e,f],\\,\\dots]$。您必须在最终输出格式中将每个报告的浮点数四舍五入到六位小数。不允许使用外部输入或文件；所有常量必须在程序内部定义。数值算法必须在实现相同快速傅里叶变换语义的平台上可复现。",
            "solution": "该问题要求开发一个用于二维不可压缩欧拉方程流函数-涡量公式的伪谱求解器，以研究数值混叠效应。分析将在涉及双剪切层不稳定性的测试案例上进行。\n\n控制方程为涡量输运方程，\n$$\n\\partial_t \\omega + J(\\psi,\\omega) = 0\n$$\n以及关联流函数 $\\psi$ 和涡量 $\\omega$ 的泊松方程，\n$$\n-\\nabla^2 \\psi = \\omega\n$$\n其中 $\\nabla^2 = \\partial_x^2 + \\partial_y^2$。计算区域是双周期方形区域 $[0, 2\\pi) \\times [0, 2\\pi)$。速度分量 $(u, v)$ 由 $u = \\partial_y \\psi$ 和 $v = -\\partial_x \\psi$ 给出。代表速度场对涡量平流的雅可比算子定义为\n$$\nJ(\\psi, \\omega) = (\\partial_x \\psi)(\\partial_y \\omega) - (\\partial_y \\psi)(\\partial_x \\omega)\n$$\n\n我们将使用大小为 $N \\times N$ 的均匀网格离散化该区域，网格点为 $(x_i, y_j) = (i \\frac{2\\pi}{N}, j \\frac{2\\pi}{N})$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。伪谱方法利用快速傅里葉變換 (FFT) 的高效性和准确性，在具有周期性边界条件的问题中计算空间导数。\n\n此网格上的函数 $f(x, y)$ 由其离散傅里叶级数表示：\n$$\nf(x_i, y_j) = \\sum_{k_x=-N/2+1}^{N/2} \\sum_{k_y=-N/2+1}^{N/2} \\hat{f}(k_x, k_y) e^{i(k_x x_i + k_y y_j)}\n$$\n其中 $\\hat{f}(k_x, k_y)$ 是离散傅里叶系数，$k_x, k_y$ 是整数波数。离散傅里葉變換 (DFT) 及其逆变换 (IDFT) 提供了物理空间表示 $f(x_i, y_j)$ 和谱空间表示 $\\hat{f}(k_x, k_y)$ 之间的映射。关键在于，空间导数在谱空间中转化为代数乘法：\n$$\n\\mathcal{F}(\\partial_x f) = i k_x \\hat{f}, \\quad \\mathcal{F}(\\partial_y f) = i k_y \\hat{f}\n$$\n此处，$\\mathcal{F}$ 表示 DFT。在我们的数值实现中，与 DFT 数组对应的波数由 `numpy.fft.fftfreq(N) * N` 提供，它为偶数 $N$ 生成整数序列 $\\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$。\n\n泊松方程 $-\\nabla^2 \\psi = \\omega$ 在谱空间中變得易于求解：\n$$\n-( (i k_x)^2 + (i k_y)^2 ) \\hat{\\psi} = \\hat{\\omega} \\implies (k_x^2 + k_y^2) \\hat{\\psi} = \\hat{\\omega}\n$$\n因此，流函数系数可通过以下方式求得：\n$$\n\\hat{\\psi}(k_x, k_y) = \\frac{\\hat{\\omega}(k_x, k_y)}{k_x^2 + k_y^2}, \\quad \\text{for } k_x^2+k_y^2 \\neq 0\n$$\n对于平均模态 $(k_x, k_y) = (0, 0)$，由于周期性，连续涡量场的均值为零（$\\iint \\omega \\,dx\\,dy = \\oint (\\mathbf{u} \\cdot d\\mathbf{l}) = 0$）。这确保了 $\\hat{\\omega}(0, 0) = 0$。我们设置 $\\hat{\\psi}(0, 0) = 0$，因为流函数的平均值在物理上是无关紧要的。\n\n涡量输运方程是关于傅里叶系数 $\\hat{\\omega}$ 的常微分方程 (ODE)：\n$$\n\\frac{d\\hat{\\omega}}{dt} = -\\mathcal{F}\\{ J(\\psi, \\omega) \\}\n$$\n非线性雅可比项 $J(\\psi, \\omega)$ 在物理空间中计算，以避免全谱方法所需的昂贵卷积。这种“伪谱”方法按以下步骤进行：\n1. 给定 $\\hat{\\omega}(t)$，使用谱泊松求解器求解 $\\hat{\\psi}(t)$。\n2. 计算所需导数的谱系数：$\\widehat{\\partial_x\\psi} = ik_x\\hat{\\psi}$、$\\widehat{\\partial_y\\psi} = ik_y\\hat{\\psi}$、$\\widehat{\\partial_x\\omega} = ik_x\\hat{\\omega}$ 和 $\\widehat{\\partial_y\\omega} = ik_y\\hat{\\omega}$。\n3. 对这四个场中的每一个应用 IDFT，以获得它们的物理空间表示 $\\partial_x\\psi$、$\\partial_y\\psi$、$\\partial_x\\omega$ 和 $\\partial_y\\omega$。\n4. 在物理空间中计算逐点乘积：$J(x_i, y_j) = (\\partial_x\\psi)(\\partial_y\\omega) - (\\partial_y\\psi)(\\partial_x\\omega)$。\n5. 对 $J(x_i, y_j)$ 应用 DFT 以获得 $\\mathcal{F}\\{J(\\psi, \\omega)\\}$，即 $\\hat{\\omega}$ 的 ODE 的右侧项。\n\n步骤 4 中的乘积会引入混叠误差。如果输入场包含高达 $k_{max} \\approx N/2$ 的波数，它们的乘积可能包含高达 $2k_{max} \\approx N$ 的波数。大于 $N/2$ 的波数在 $N$ 点网格上会被错误地表示（混叠）为较低的波数，从而污染解。我们将研究此项的三种处理方法：\n\n1. **不去混叠**：直接遵循上述步骤。这是计算效率最高的方法，但也最容易受到混叠不稳定性的影响。\n\n2. **三分之二波数截断**：在步骤 3 之前，对四个导数场的谱系数进行截断。任何满足 $|k_x| > \\kappa_c$ 或 $|k_y| > \\kappa_c$ 的系数 $\\hat{f}(k_x, k_y)$ 都被设置为零，其中 $\\kappa_c = \\lfloor N/3 \\rfloor$。这确保了乘积中的最高波数约为 $2\\kappa_c \\approx 2N/3$。虽然这仍然大于奈奎斯特波数 $N/2$，但它移除了最高波数的相互作用，这些相互作用是混叠不稳定性的主要来源。\n\n3. **物理空间高斯滤波**：在步骤 4 之后，通过与一个离散、归一化的二维高斯核进行卷积来对计算出的雅可比项 $J(x_i, y_j)$ 进行滤波。卷积在周期性边界条件下执行。该核是可分离的，由一维核 $K_1[i] = \\exp(-((i-r)/\\sigma)^2/2)$ 构建，其中 $i \\in \\{0, \\dots, 2r\\}$，$r$ 是整数半径，$\\sigma$ 是标准差。此滤波器平滑了雅可比项，抑制了由混叠产生的高波数分量。\n\n对于半离散方程 $d\\hat{\\omega}/dt = \\mathcal{L}(\\hat{\\omega})$ 的时间积分，我们使用三阶段、三阶精度的强稳定性保持龙格-库塔 (SSP-RK3) 格式：\n$$\n\\begin{aligned}\n\\hat{\\omega}^{(1)} = \\hat{\\omega}^n + \\Delta t \\mathcal{L}(\\hat{\\omega}^n) \\\\\n\\hat{\\omega}^{(2)} = \\frac{3}{4} \\hat{\\omega}^n + \\frac{1}{4} \\hat{\\omega}^{(1)} + \\frac{1}{4} \\Delta t \\mathcal{L}(\\hat{\\omega}^{(1)}) \\\\\n\\hat{\\omega}^{n+1} = \\frac{1}{3} \\hat{\\omega}^n + \\frac{2}{3} \\hat{\\omega}^{(2)} + \\frac{2}{3} \\Delta t \\mathcal{L}(\\hat{\\omega}^{(2)})\n\\end{aligned}\n$$\n在每个时间步长 $\\Delta t$ 应用此格式，以将解从 $t$ 推进到 $t+\\Delta t$。\n\n初始条件是双剪切层，其涡量为 $\\omega(x,y,0) = \\varepsilon \\cos(x) - U'(y)$，其中 $U'(y) = \\frac{1}{\\delta}\\,\\mathrm{sech}^2(\\frac{y - \\pi/2}{\\delta}) - \\frac{1}{\\delta}\\,\\mathrm{sech}^2(\\frac{y - 3\\pi/2}{\\delta})$。该场在物理网格上初始化，并转换到谱空间以获得 $\\hat{\\omega}(0)$。\n\n计算诊断量以量化每种方法的性能。总动能 $E(t)$ 和总拟涡能 $Z(t)$ 是连续欧拉方程的无粘性不变量。它们的数值漂移表明误差累积。它们通过在物理网格上进行数值积分来计算：\n$$\nE(t) = \\frac{1}{2} \\left(\\frac{2\\pi}{N}\\right)^2 \\sum_{i,j=0}^{N-1} (u_{ij}^2+v_{ij}^2), \\quad Z(t) = \\frac{1}{2} \\left(\\frac{2\\pi}{N}\\right)^2 \\sum_{i,j=0}^{N-1} \\omega_{ij}^2\n$$\n速度分量 $u$ 和 $v$ 是通过将 $\\hat{u} = ik_y\\hat{\\psi}$ 和 $\\hat{v} = -ik_x\\hat{\\psi}$ 变换到物理空间得到的。混叠误差也通过末态拟涡能中驻留在高波数模态中的分数 $f_{\\mathrm{high}}(T)$ 来量化，该分数在谱空间中计算：\n$$\nf_{\\mathrm{high}}(T) = \\frac{\\sum_{|k_x|>\\kappa_c \\text{ or } |k_y|>\\kappa_c} |\\hat{\\omega}(k_x, k_y, T)|^2}{\\sum_{\\text{all } k_x, k_y} |\\hat{\\omega}(k_x, k_y, T)|^2}\n$$\n这些诊断量使得能够对混叠控制方法进行定量比较。",
            "answer": "```python\nimport numpy as np\nimport scipy.signal\n\ndef solve():\n    \"\"\"\n    Solves the 2D Euler equations using a pseudo-spectral method\n    to analyze aliasing effects based on the problem specification.\n    \"\"\"\n\n    test_cases = [\n        # (N, delta, epsilon, dt, steps, method, r, sigma)\n        (32, 0.05, 0.05, 0.0010, 150, 'none', 0, 0.0),\n        (32, 0.05, 0.05, 0.0010, 150, 'two_thirds', 0, 0.0),\n        (32, 0.05, 0.05, 0.0010, 150, 'physical', 1, 0.70),\n        (64, 0.05, 0.05, 0.0007, 150, 'none', 0, 0.0),\n        (64, 0.05, 0.05, 0.0007, 150, 'two_thirds', 0, 0.0),\n        (48, 0.05, 0.05, 0.0009, 150, 'physical', 2, 1.00),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N, delta, epsilon, dt, steps, method, r, sigma = case\n        \n        # Grid and Wavenumbers\n        L = 2 * np.pi\n        dx = L / N\n        x = np.arange(N) * dx\n        xx, yy = np.meshgrid(x, x, indexing='ij')\n\n        kx = np.fft.fftfreq(N, d=1.0/N)\n        ky = np.fft.fftfreq(N, d=1.0/N)\n        kxx, kyy = np.meshgrid(kx, ky, indexing='ij')\n\n        ksq = kxx**2 + kyy**2\n        ksq_inv = np.zeros_like(ksq)\n        ksq_inv[ksq > 0] = 1.0 / ksq[ksq > 0]\n\n        # Dealiasing masks\n        kappa_c = int(N / 3)\n        dealias_mask = (np.abs(kxx) = kappa_c)  (np.abs(kyy) = kappa_c)\n        high_k_mask = (np.abs(kxx) > kappa_c) | (np.abs(kyy) > kappa_c)\n        \n        # Gaussian filter kernel for physical-space filtering\n        gauss_kernel = None\n        if method == 'physical' and r > 0:\n            kernel_indices = np.arange(2 * r + 1)\n            kernel_coords = kernel_indices - r\n            kernel_1d = np.exp(-kernel_coords**2 / (2 * sigma**2))\n            kernel_1d /= np.sum(kernel_1d)\n            gauss_kernel = np.outer(kernel_1d, kernel_1d)\n\n        # Initial Condition\n        def sech(z):\n            return 1.0 / np.cosh(z)\n\n        U_prime = (1.0/delta) * (sech((yy - L/4) / delta)**2 - sech((yy - 3*L/4) / delta)**2)\n        omega0_phys = epsilon * np.cos(xx) - U_prime\n        omega_hat = np.fft.fftn(omega0_phys)\n\n        def get_diagnostics(omega_hat_current):\n            # Enstrophy\n            omega_phys = np.real(np.fft.ifftn(omega_hat_current))\n            enstrophy = 0.5 * dx**2 * np.sum(omega_phys**2)\n            \n            # Kinetic Energy\n            psi_hat = -omega_hat_current * ksq_inv\n            u_hat = 1j * kyy * psi_hat\n            v_hat = -1j * kxx * psi_hat\n            u_phys = np.real(np.fft.ifftn(u_hat))\n            v_phys = np.real(np.fft.ifftn(v_hat))\n            energy = 0.5 * dx**2 * np.sum(u_phys**2 + v_phys**2)\n            \n            return energy, enstrophy\n\n        E0, Z0 = get_diagnostics(omega_hat)\n\n        def calculate_rhs(omega_hat_t):\n            psi_hat = -omega_hat_t * ksq_inv\n            \n            psi_x_hat = 1j * kxx * psi_hat\n            psi_y_hat = 1j * kyy * psi_hat\n            omega_x_hat = 1j * kxx * omega_hat_t\n            omega_y_hat = 1j * kyy * omega_hat_t\n            \n            if method == 'two_thirds':\n                psi_x_hat *= dealias_mask\n                psi_y_hat *= dealias_mask\n                omega_x_hat *= dealias_mask\n                omega_y_hat *= dealias_mask\n            \n            psi_x = np.real(np.fft.ifftn(psi_x_hat))\n            psi_y = np.real(np.fft.ifftn(psi_y_hat))\n            omega_x = np.real(np.fft.ifftn(omega_x_hat))\n            omega_y = np.real(np.fft.ifftn(omega_y_hat))\n            \n            jacobian_phys = psi_x * omega_y - psi_y * omega_x\n            \n            if method == 'physical' and gauss_kernel is not None:\n                jacobian_phys = scipy.signal.convolve2d(\n                    jacobian_phys, gauss_kernel, mode='same', boundary='wrap'\n                )\n\n            return -np.fft.fftn(jacobian_phys)\n\n        # SSP-RK3 Time Stepping\n        for _ in range(steps):\n            # Stage 1\n            rhs1 = calculate_rhs(omega_hat)\n            omega_hat1 = omega_hat + dt * rhs1\n            \n            # Stage 2\n            rhs2 = calculate_rhs(omega_hat1)\n            omega_hat2 = 0.75 * omega_hat + 0.25 * (omega_hat1 + dt * rhs2)\n            \n            # Stage 3\n            rhs3 = calculate_rhs(omega_hat2)\n            omega_hat = (1.0/3.0) * omega_hat + (2.0/3.0) * (omega_hat2 + dt * rhs3)\n        \n        # Final diagnostics\n        EF, ZF = get_diagnostics(omega_hat)\n        \n        delta_E_rel = (EF - E0) / E0 if E0 != 0 else 0.0\n        delta_Z_rel = (ZF - Z0) / Z0 if Z0 != 0 else 0.0\n        \n        total_enstrophy_spec = np.sum(np.abs(omega_hat)**2)\n        high_k_enstrophy_spec = np.sum(np.abs(omega_hat[high_k_mask])**2)\n        f_high = high_k_enstrophy_spec / total_enstrophy_spec if total_enstrophy_spec != 0 else 0.0\n        \n        results.append([delta_E_rel, delta_Z_rel, f_high])\n\n    # Format output\n    formatted_results = []\n    for res_triple in results:\n        formatted_triple = [f\"{x:.6f}\" for x in res_triple]\n        formatted_results.append(f\"[{','.join(formatted_triple)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这个练习旨在解决一个至关重要的挑战：为壁面有界流动施加精确的边界条件。您将研究在无滑移壁面附近，流函数泊松方程的数值离散化如何导致非物理性的“涡量泄漏”。通过比较标准的二阶格式和高阶紧致格式，您将在实际流动构型中获得提高模拟保真度的实践经验()。",
            "id": "3389276",
            "problem": "考虑在纳维-斯托克斯方程的流函数-涡量形式下的二维不可压缩流，其中速度场由流函数 $\\psi(x,y)$ 通过 $u = \\partial \\psi / \\partial y$ 和 $v = -\\partial \\psi / \\partial x$ 表示，标量涡量为 $\\omega = \\partial v / \\partial x - \\partial u / \\partial y = - \\nabla^2 \\psi$。对于一个与坐标轴对齐的静止、不可穿透的无滑移壁面，流函数边界条件为壁面上的 $\\psi = \\text{constant}$（不可穿透）和壁面上的 $\\partial \\psi / \\partial n = 0$（无滑移），其中 $\\partial \\psi / \\partial n$ 是壁面的法向导数。在流函数-涡量形式中，离散化近壁面 $\\nabla^2 \\psi$ 时的数值误差会直接污染计算出的涡量 $\\omega$，这种现象在高雷诺数（Reynolds number (Re)）下通常被称为涡量泄漏，此时近壁面梯度非常陡峭。\n\n您的任务是在一个均匀的笛卡尔网格上，为 $\\nabla^2 \\psi$ 建立并评估一种尊重无滑移边界结构的高阶紧致有限差分离散格式。在一个无量纲的方形域 $[0,1]\\times[0,1]$ 上进行，该域上有一个 $N\\times N$ 个点的均匀网格，网格间距为 $h = 1/(N-1)$。使用以下构造的光滑流函数，它能精确地满足不可穿透和无滑移两个条件：\n$$\n\\psi(x,y) = \\sin^2\\!\\big(k\\pi x\\big)\\,\\sin^2\\!\\big(k\\pi y\\big),\n$$\n其中 $k$ 是一个正整数，用于控制近壁面梯度的陡峭程度（较大的 $k$ 通过创建更薄的有效层来模拟更高的雷诺数状态）。对于此选择，精确涡量为\n$$\n\\omega_{\\text{true}}(x,y) \\equiv -\\nabla^2 \\psi(x,y) = -2\\,(k\\pi)^2\\left[\\cos\\!\\big(2k\\pi x\\big)\\,\\sin^2\\!\\big(k\\pi y\\big) + \\cos\\!\\big(2k\\pi y\\big)\\,\\sin^2\\!\\big(k\\pi x\\big)\\right].\n$$\n\n在内部网格点上，实现并比较以下两种 $\\omega = -\\nabla^2 \\psi$ 的离散近似方法：\n\n- 基准二阶格式（记为 S2）：在内部点 $(i,j)$ 使用标准的拉普拉斯算子五点模板，\n$$\n(\\nabla^2 \\psi)^{\\text{S2}}_{i,j} = \\frac{\\psi_{i+1,j} - 2\\psi_{i,j} + \\psi_{i-1,j}}{h^2} + \\frac{\\psi_{i,j+1} - 2\\psi_{i,j} + \\psi_{i,j-1}}{h^2},\n$$\n在需要闭合模板时使用边界值 $\\psi=0$。然后 $\\omega^{\\text{S2}}_{i,j} = -(\\nabla^2 \\psi)^{\\text{S2}}_{i,j}$。\n\n- 高阶紧致格式（记为 HC4）：通过一个一维的五点模板，使用四阶精度紧致显式中心公式计算每个笛卡尔方向的二阶导数，\n$$\n\\left(\\frac{\\partial^2 \\psi}{\\partial x^2}\\right)_{i,j}^{\\text{HC4}} = \\frac{-\\psi_{i+2,j} + 16\\psi_{i+1,j} - 30\\psi_{i,j} + 16\\psi_{i-1,j} - \\psi_{i-2,j}}{12\\,h^2},\n$$\n$$\n\\left(\\frac{\\partial^2 \\psi}{\\partial y^2}\\right)_{i,j}^{\\text{HC4}} = \\frac{-\\psi_{i,j+2} + 16\\psi_{i,j+1} - 30\\psi_{i,j} + 16\\psi_{i,j-1} - \\psi_{i,j-2}}{12\\,h^2}.\n$$\n在壁面附近，当索引 $i\\pm 2$ 或 $j\\pm 2$ 位于域外时，通过跨壁面的偶反射来强制实现与无滑移兼容的紧致闭合，即对于任何超出范围的索引 $p0$，在相应方向上用 $\\psi_{-p,\\cdot}$ 替换 $\\psi_{p,\\cdot}$；对于任何超出范围的索引 $p>N-1$，用 $\\psi_{2(N-1)-p,\\cdot}$ 替换 $\\psi_{p,\\cdot}$。这实现了关于壁面的局部偶延拓，与该处的 $\\partial \\psi / \\partial n = 0$ 条件一致。然后设置\n$$\n\\omega^{\\text{HC4}}_{i,j} = -\\left[\\left(\\frac{\\partial^2 \\psi}{\\partial x^2}\\right)_{i,j}^{\\text{HC4}} + \\left(\\frac{\\partial^2 \\psi}{\\partial y^2}\\right)_{i,j}^{\\text{HC4}}\\right].\n$$\n\n将近壁面带 $\\mathcal{B}$ 定义为距离任何壁面一个内部单元格范围内的内部索引集合：\n$$\n\\mathcal{B} = \\left\\{(i,j)\\,:\\,1\\le i \\le N-2,\\,1\\le j \\le N-2,\\,\\min\\big(i,\\,j,\\,N-1-i,\\,N-1-j\\big)=1\\right\\}.\n$$\n对于 $\\{\\text{S2},\\text{HC4}\\}$ 中的每种格式 X，在带 $\\mathcal{B}$ 中定义一个泄漏度量，即计算涡量相对于精确涡量的相对均方根误差，并用带中精确涡量的最大绝对值进行归一化，\n$$\n\\mathcal{E}^{\\text{X}} = \\frac{\\left(\\frac{1}{|\\mathcal{B}|}\\sum_{(i,j)\\in\\mathcal{B}}\\left(\\omega^{\\text{X}}_{i,j} - \\omega_{\\text{true}}(x_i,y_j)\\right)^2\\right)^{1/2}}{\\max_{(i,j)\\in\\mathcal{B}}\\left|\\omega_{\\text{true}}(x_i,y_j)\\right|}.\n$$\n\n针对上述构造的流函数以及指定的 S2 和 HC4 离散化方法，实现一个程序，用于评估高阶紧致格式是否比二阶格式减少了近壁面泄漏度量，即是否 $\\mathcal{E}^{\\text{HC4}}  \\mathcal{E}^{\\text{S2}}$。评估使用以下网格分辨率和陡峭度参数的测试套件：\n- 测试用例 1：$N = 65$, $k = 3$。\n- 测试用例 2：$N = 17$, $k = 3$。\n- 测试用例 3：$N = 65$, $k = 6$。\n- 测试用例 4：$N = 17$, $k = 6$。\n\n所有量均为无量纲；无需物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表，其顺序与测试套件一致，例如，“[True,False,True,True]”。",
            "solution": "该问题是有效的。这是一个适定的数值分析练习，其基础是计算流体动力学的基本原理，特别是纳维-斯托克斯方程的流函数-涡量形式。所有提供的定义、方程和边界条件在科学上都是合理的、一致的，并且足以进行求解。\n\n任务是比较两种有限差分格式在无滑移壁面附近，从给定的光滑流函数 $\\psi$ 计算涡量 $\\omega = -\\nabla^2 \\psi$ 的准确性。该比较在二维均匀笛卡尔网格上针对几组参数集进行。解决方案的核心在于仔细实现这些格式和指定的误差度量。\n\n首先，我们建立计算域和网格。域是一个单位正方形 $[0,1]\\times[0,1]$，由一个 $N \\times N$ 的点网格离散化。网格间距是均匀的，由 $h = 1/(N-1)$ 给出。网格坐标 $(x_i, y_j)$ 由 $x_i = i \\cdot h$ 和 $y_j = j \\cdot h$ 给出，其中索引 $i, j$ 的范围是从 $0$ 到 $N-1$。使用这些坐标，我们在所有网格点 $(x_i, y_j)$ 上计算构造的流函数 $\\psi(x,y) = \\sin^2(k\\pi x)\\,\\sin^2(k\\pi y)$ 和精确涡量 $\\omega_{\\text{true}}(x,y) = -2\\,(k\\pi)^2[\\cos(2k\\pi x)\\,\\sin^2(k\\pi y) + \\cos(2k\\pi y)\\,\\sin^2(k\\pi x)]$，并将它们存储在 $N \\times N$ 的数组中。\n\n接下来，我们实现两种数值格式来近似内部网格点上的涡量 $\\omega = -\\nabla^2\\psi$，其中索引 $(i,j)$ 在范围 $[1, N-2] \\times [1, N-2]$ 内。\n\n1.  **二阶格式 (S2)**：涡量 $\\omega^{\\text{S2}}$ 使用标准的拉普拉斯算子五点模板计算，$\\nabla^2$。对于一个内部点 $(i,j)$，公式为：\n    $$\n    \\omega^{\\text{S2}}_{i,j} = - \\left( \\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2} \\right)\n    $$\n    使用 `numpy` 数组切片，可以高效地同时为所有内部点实现此公式。当应用于邻近边界的点时（例如，在 $i=1$ 处，使用 $\\psi_{i-1,j} = \\psi_{0,j}$ 项），该模板自然地包含了 $\\psi$ 的边界值（其中 $\\psi=0$）。\n\n2.  **高阶紧致格式 (HC4)**：该格式通过对二阶偏导数 $\\partial^2\\psi/\\partial x^2$ 和 $\\partial^2\\psi/\\partial y^2$ 的四阶精度近似求和来近似拉普拉斯算子。例如，在 $x$ 方向上，二阶导数的一维五点模板为：\n    $$\n    \\left(\\frac{\\partial^2 \\psi}{\\partial x^2}\\right)_{i,j} = \\frac{-\\psi_{i-2,j} + 16\\psi_{i-1,j} - 30\\psi_{i,j} + 16\\psi_{i+1,j} - \\psi_{i+2,j}}{12\\,h^2}\n    $$\n    此问题的一个关键方面是在边界附近处理此模板，因为它需要域外的“虚拟”点。问题指定了一种与无滑移条件 $\\partial\\psi/\\partial n = 0$ 兼容的闭合方式，这意味着跨边界进行偶反射。例如，在壁面 $x=0$（索引 $i=0$）处，这意味着 $\\psi(-x, y) = \\psi(x, y)$。用网格索引表示，即为 $\\psi_{-p,j} = \\psi_{p,j}$。\n    - 对于 $i=1$ 处的点，模板需要 $\\psi_{-1,j}$。使用偶反射规则，我们代入 $\\psi_{1,j}$，得到一个修改后的 $\\partial^2\\psi/\\partial x^2$ 模板：\n      $$\n      \\left(\\frac{\\partial^2 \\psi}{\\partial x^2}\\right)_{1,j} = \\frac{16\\psi_{0,j} - 31\\psi_{1,j} + 16\\psi_{2,j} - \\psi_{3,j}}{12\\,h^2}\n      $$\n    - 类似地，在 $i=N-2$ 处，模板需要 $\\psi_{N,j}$。跨越壁面 $x=1$（索引 $N-1$）的反射规则是 $\\psi_{N-1+p, j} = \\psi_{N-1-p, j}$，这得出 $\\psi_{N,j} = \\psi_{N-2,j}$。模板变为：\n      $$\n      \\left(\\frac{\\partial^2 \\psi}{\\partial x^2}\\right)_{N-2,j} = \\frac{-\\psi_{N-4,j} + 16\\psi_{N-3,j} - 31\\psi_{N-2,j} + 16\\psi_{N-1,j}}{12\\,h^2}\n      $$\n    在 $j=1$ 和 $j=N-2$ 处，对 $y$ 方向的导数应用类似的模板修改。远离壁面的内部点（索引在 $[2, N-3]\\times[2,N-3]$ 内）使用标准的五点 HC4 模板。然后计算出的涡量为 $\\omega^{\\text{HC4}}_{i,j} = -[(\\partial^2\\psi/\\partial x^2)^{\\text{HC4}}_{i,j} + (\\partial^2\\psi/\\partial y^2)^{\\text{HC4}}_{i,j}]$。这些计算也通过 `numpy` 切片对主体内部和近壁面行/列分别进行矢量化。\n\n最后，我们为每种格式 $\\text{X} \\in \\{\\text{S2}, \\text{HC4}\\}$ 计算泄漏度量 $\\mathcal{E}^{\\text{X}}$。近壁面带 $\\mathcal{B}$ 被识别为内部点 $(i,j)$ 的集合，其中 $i=1$、$j=1$、$i=N-2$ 或 $j=N-2$。创建一个布尔掩码来表示这个带。该度量是此带内计算涡量的均方根（RMS）误差，并用同一带内真实涡量的最大绝对值进行归一化：\n$$\n\\mathcal{E}^{\\text{X}} = \\frac{\\sqrt{\\frac{1}{|\\mathcal{B}|}\\sum_{(i,j)\\in\\mathcal{B}}(\\omega^{\\text{X}}_{i,j} - \\omega_{\\text{true}}(x_i,y_j))^2}}{\\max_{(i,j)\\in\\mathcal{B}}|\\omega_{\\text{true}}(x_i,y_j)|}\n$$\n$|\\mathcal{B}|$ 的值是带中点的总数。对于由一对 $(N, k)$ 定义的每个测试用例，我们计算 $\\mathcal{E}^{\\text{S2}}$ 和 $\\mathcal{E}^{\\text{HC4}}$，并确定高阶格式是否产生更低的误差，即 $\\mathcal{E}^{\\text{HC4}}  \\mathcal{E}^{\\text{S2}}$ 是否成立。收集并打印生成的布尔值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# The scipy library is permitted but not required for this solution.\n\ndef solve_case(N, k):\n    \"\"\"\n    Solves a single test case for a given grid size N and parameter k.\n    \"\"\"\n    # 1. Grid Setup\n    h = 1.0 / (N - 1)\n    grid_pts = np.linspace(0, 1, N)\n    # Use 'ij' indexing so that the first index corresponds to x and the second to y\n    X, Y = np.meshgrid(grid_pts, grid_pts, indexing='ij')\n\n    # 2. Evaluate Exact Fields\n    kp = k * np.pi\n    psi = (np.sin(kp * X)**2) * (np.sin(kp * Y)**2)\n    omega_true = -2 * kp**2 * (\n        np.cos(2 * kp * X) * np.sin(kp * Y)**2 +\n        np.cos(2 * kp * Y) * np.sin(kp * X)**2\n    )\n\n    # Define slices for the interior domain\n    interior_slice = slice(1, N - 1)\n    \n    # 3. Compute S2 vorticity\n    h2 = h**2\n    omega_s2 = np.zeros_like(psi)\n    \n    # Standard 5-point Laplacian stencil for all interior points\n    lap_s2 = (psi[2:N, interior_slice] + psi[0:N-2, interior_slice] +\n              psi[interior_slice, 2:N] + psi[interior_slice, 0:N-2] -\n              4 * psi[interior_slice, interior_slice]) / h2\n    \n    omega_s2[interior_slice, interior_slice] = -lap_s2\n\n    # 4. Compute HC4 vorticity\n    omega_hc4 = np.zeros_like(psi)\n    d2psidx2 = np.zeros_like(psi)\n    d2psidy2 = np.zeros_like(psi)\n    \n    # Check for grid size, HC4 logic requires N > 3.\n    if N > 3:\n        # 4a. d2psi/dx^2 calculation\n        j_slice = slice(1, N - 1)\n        # Bulk interior rows: i in [2, N-3]\n        if N > 4:\n            d2psidx2[2:N-2, j_slice] = (\n                -psi[0:N-4, j_slice] + 16 * psi[1:N-3, j_slice] -\n                 30 * psi[2:N-2, j_slice] + 16 * psi[3:N-1, j_slice] -\n                 psi[4:N, j_slice]\n            )\n        # Row i=1 (near wall x=0)\n        d2psidx2[1, j_slice] = (\n            16 * psi[0, j_slice] - 31 * psi[1, j_slice] + 16 * psi[2, j_slice] - psi[3, j_slice]\n        )\n        # Row i=N-2 (near wall x=1)\n        d2psidx2[N-2, j_slice] = (\n            -psi[N-4, j_slice] + 16 * psi[N-3, j_slice] - \n            31 * psi[N-2, j_slice] + 16 * psi[N-1, j_slice]\n        )\n\n        # 4b. d2psi/dy^2 calculation\n        i_slice = slice(1, N - 1)\n        # Bulk interior columns: j in [2, N-3]\n        if N > 4:\n            d2psidy2[i_slice, 2:N-2] = (\n                -psi[i_slice, 0:N-4] + 16 * psi[i_slice, 1:N-3] -\n                 30 * psi[i_slice, 2:N-2] + 16 * psi[i_slice, 3:N-1] -\n                 psi[i_slice, 4:N]\n            )\n        # Column j=1 (near wall y=0)\n        d2psidy2[i_slice, 1] = (\n            16 * psi[i_slice, 0] - 31 * psi[i_slice, 1] + 16 * psi[i_slice, 2] - psi[i_slice, 3]\n        )\n        # Column j=N-2 (near wall y=1)\n        d2psidy2[i_slice, N-2] = (\n            -psi[i_slice, N-4] + 16 * psi[i_slice, N-3] - \n            31 * psi[i_slice, N-2] + 16 * psi[i_slice, N-1]\n        )\n\n    # Combine derivatives and apply coefficient\n    c = 1.0 / (12 * h2)\n    omega_hc4[interior_slice, interior_slice] = -c * (d2psidx2[interior_slice, interior_slice] + d2psidy2[interior_slice, interior_slice])\n\n    # 5. Define Near-Wall Band and Calculate Error Metrics\n    band_mask = np.zeros_like(psi, dtype=bool)\n    if N > 2:\n        band_mask[1, 1:N-1] = True\n        band_mask[N-2, 1:N-1] = True\n        band_mask[1:N-1, 1] = True\n        band_mask[1:N-1, N-2] = True\n    \n    num_band_points = np.sum(band_mask)\n    if num_band_points == 0:\n        return False # No data to compare\n\n    def calculate_leakage(omega_num):\n        err = omega_num - omega_true\n        err_band = err[band_mask]\n        omega_true_band = omega_true[band_mask]\n        \n        sse = np.sum(err_band**2)\n        rms_err = np.sqrt(sse / num_band_points)\n        \n        max_omega_abs = np.max(np.abs(omega_true_band))\n        if max_omega_abs == 0:\n            return float('inf') if rms_err > 0 else 0.0\n        \n        return rms_err / max_omega_abs\n\n    E_s2 = calculate_leakage(omega_s2)\n    E_hc4 = calculate_leakage(omega_hc4)\n\n    return E_hc4  E_s2\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (65, 3),  # Test case 1: N = 65, k = 3\n        (17, 3),  # Test case 2: N = 17, k = 3\n        (65, 6),  # Test case 3: N = 65, k = 6\n        (17, 6),  # Test case 4: N = 17, k = 6\n    ]\n\n    results = []\n    for N, k in test_cases:\n        result = solve_case(N, k)\n        results.append(result)\n        \n    # Final print statement in the exact required format.\n    # The boolean values are converted to string 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}