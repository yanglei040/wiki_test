{
    "hands_on_practices": [
        {
            "introduction": "The generation of vorticity via the baroclinic mechanism is fundamental to understanding how shocks amplify turbulence and deform material interfaces. This process occurs whenever the gradients of density and pressure are misaligned, a condition epitomized by a shock wave encountering a turbulent eddy or a perturbed interface. This practice isolates the baroclinic term, $\\nabla \\rho \\times \\nabla p / \\rho^2$, in a controlled numerical experiment, allowing you to verify its implementation against exact solutions and build a foundational understanding of vorticity dynamics in compressible flows .",
            "id": "3361565",
            "problem": "You are asked to implement a self-contained numerical verification of the baroclinic vorticity generation term in a shock–turbulence interaction using a simplified two-dimensional periodic domain and controlled initial spectra. The starting point must be the compressible Navier–Stokes equations and their curl (the vorticity transport equation). In two spatial dimensions with vorticity aligned in the out-of-plane direction, denote the vorticity by $\\omega$, the velocity by $\\boldsymbol{u}$, the density by $\\rho$, the pressure by $p$, and the kinematic viscosity by $\\nu$. The materially transported vorticity equation can be written as $D\\boldsymbol{\\omega}/Dt = (\\boldsymbol{\\omega}\\cdot\\nabla)\\boldsymbol{u} - \\boldsymbol{\\omega}(\\nabla\\cdot \\boldsymbol{u}) + \\nabla \\rho \\times \\nabla p / \\rho^2 + \\nu \\nabla^2 \\boldsymbol{\\omega}$. In a kinematic verification setting, impose $\\boldsymbol{u}=\\boldsymbol{0}$ for all time so that $D\\boldsymbol{\\omega}/Dt=\\partial \\boldsymbol{\\omega}/\\partial t$, and the evolution reduces to $\\partial \\omega / \\partial t = S_b + \\nu \\nabla^2 \\omega$, where $S_b = (\\partial_x \\rho \\, \\partial_y p - \\partial_y \\rho \\, \\partial_x p)/\\rho^2$ is the baroclinic source term. The purpose is to isolate and verify the correctness of the baroclinic source computation under controlled spectral content of $\\rho$ and a shock-like pressure field, without solving for $\\boldsymbol{u}$, and to quantitatively compare a direct numerical integration against an exact spectral solution when $S_b$ is time-independent.\n\nDomain and fields: Use a doubly periodic square domain of side length $L_x=L_y=2\\pi$, discretized by $N_x \\times N_y$ grid points with uniform spacing. The density field $\\rho(x,y)$ must be constructed to have controlled spectral content, and the pressure field $p(x,y)$ must represent a stationary, periodic, pair of smoothed shocks with large gradient primarily along the $x$ direction. Let the vorticity initial condition be $\\omega(x,y,0)=0$. All quantities are non-dimensional.\n\nFundamental base to be used: The compressible Navier–Stokes equations, the definition of vorticity $\\boldsymbol{\\omega}=\\nabla\\times\\boldsymbol{u}$, the materially transported form $D/Dt=\\partial/\\partial t+\\boldsymbol{u}\\cdot\\nabla$, and the well-tested vorticity transport equation providing the baroclinic source term $\\nabla \\rho \\times \\nabla p / \\rho^2$. The Fourier spectral differentiation identities on periodic domains must be used to compute spatial gradients and Laplacians via Fast Fourier Transforms, with angular wavenumbers $k_x=2\\pi n_x/L_x$ and $k_y=2\\pi n_y/L_y$, where $n_x$ and $n_y$ are integer mode indices.\n\nYour program must implement the following verification tasks on three carefully chosen test cases, integrating $\\partial \\omega / \\partial t = S_b + \\nu \\nabla^2 \\omega$ in time using a stable explicit scheme and comparing to expected outcomes:\n\n1. Aligned gradients (baroclinic source suppressed): Choose $\\rho(x,y)$ that depends only on $x$ and $p(x,y)$ that depends only on $x$ through the periodic shock pair, so that $\\partial_y \\rho=0$ and $\\partial_y p=0$, implying $S_b=0$. Integrate to a final time $T$ with viscosity $\\nu=0$ and report the $\\ell_2$ norm of $\\omega(x,y,T)$, which should be $0$ in exact arithmetic.\n\n2. Maximally misaligned gradients (pure baroclinic generation without diffusion): Choose $\\rho(x,y)$ that depends only on $y$, and $p(x,y)$ as in the shock pair depending only on $x$. With $\\nu=0$, $S_b$ is time-independent, and the exact solution is $\\omega(x,y,T)=T\\,S_b(x,y)$. Integrate numerically to $T$ and report the relative $\\ell_2$ error between the numerical $\\omega$ and the analytic $T\\,S_b$.\n\n3. Turbulent density with controlled spectrum and diffusive evolution: Construct $\\rho(x,y)$ by spectral synthesis with random phases constrained to an isotropic ring around a target wavenumber $k_0$, scaled so that $\\rho(x,y)0$ everywhere, and $p(x,y)$ as the shock pair. With viscosity $\\nu0$ and time-independent $S_b$, the exact spectral solution for each nonzero mode is $\\hat{\\omega}(\\boldsymbol{k},T)=\\hat{S}_b(\\boldsymbol{k})\\,(1-e^{-\\nu |\\boldsymbol{k}|^2 T})/(\\nu |\\boldsymbol{k}|^2)$, where hats denote Fourier coefficients and $|\\boldsymbol{k}|^2=k_x^2+k_y^2$, and the zero mode obeys $\\hat{\\omega}(\\boldsymbol{0},T)=T\\,\\hat{S}_b(\\boldsymbol{0})$. Integrate numerically to $T$ and report the relative $\\ell_2$ error between the numerical $\\omega$ and the inverse Fourier transform of the exact spectral solution.\n\nNumerical details to be enforced: Use spectral differentiation via the Fast Fourier Transform to compute $\\partial_x$ and $\\partial_y$ and $\\nabla^2$. Use a fourth-order explicit Runge–Kutta method for time integration. Ensure $\\rho(x,y)$ remains strictly positive by using a baseline value plus small-amplitude fluctuations. Use a reproducible random seed for spectral synthesis. All computations are non-dimensional; no physical units are required. Angles are in radians.\n\nTest suite parameter values:\n- Case $1$: $N_x=N_y=64$, $L_x=L_y=2\\pi$, $\\nu=0$, $T=0.20$, shock thickness $\\delta=0.05\\,L_x$, pressure jump amplitude $\\Delta p=1.0$, density amplitude $A_\\rho=0.1$, density wavenumber $k_\\rho=4$ along $x$.\n- Case $2$: $N_x=N_y=64$, $L_x=L_y=2\\pi$, $\\nu=0$, $T=0.15$, $\\delta=0.05\\,L_x$, $\\Delta p=1.0$, $A_\\rho=0.1$, density wavenumber $k_\\rho=5$ along $y$.\n- Case $3$: $N_x=N_y=64$, $L_x=L_y=2\\pi$, $\\nu=0.01$, $T=0.20$, $\\delta=0.05\\,L_x$, $\\Delta p=1.0$, spectral ring center $k_0=8$, ring half-width $\\Delta k=1$, density fluctuation amplitude $A_\\rho=0.1$.\n\nProgram requirements: Your program must construct $\\rho$ and $p$ as specified, compute $S_b$, integrate $\\partial \\omega / \\partial t = S_b + \\nu \\nabla^2 \\omega$ from $t=0$ to $t=T$ using a fixed time step $\\Delta t$ chosen to ensure numerical stability and accuracy, and then compute the requested quantitative metrics for each case: a float for case $1$, a float for case $2$, and a float for case $3$. The final output format must be a single line containing the three results as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3]$, where each $r_i$ is a floating-point number.\n\nYour program must produce exactly this single-line output and nothing else. All computations must be completed without user input.",
            "solution": "The problem presents a numerical verification task for the baroclinic vorticity generation term, a fundamental mechanism in compressible fluid dynamics, particularly relevant to shock-turbulence interactions. The verification is conducted in a simplified kinematic setting where the velocity field $\\boldsymbol{u}$ is set to zero, which isolates the baroclinic and viscous effects on vorticity evolution. The governing equation for the out-of-plane component of vorticity, $\\omega$, in two dimensions $(x,y)$ is given as:\n$$\n\\frac{\\partial \\omega}{\\partial t} = S_b + \\nu \\nabla^2 \\omega\n$$\nwhere $\\nu$ is the kinematic viscosity and $S_b$ is the baroclinic source term, defined by the cross product of the density and pressure gradients:\n$$\nS_b = \\frac{\\nabla \\rho \\times \\nabla p}{\\rho^2} = \\frac{1}{\\rho^2} \\left( \\frac{\\partial \\rho}{\\partial x} \\frac{\\partial p}{\\partial y} - \\frac{\\partial \\rho}{\\partial y} \\frac{\\partial p}{\\partial x} \\right)\n$$\nThe problem requires integrating this equation from an initial condition of zero vorticity, $\\omega(x,y,0)=0$, on a doubly periodic square domain of side length $L=2\\pi$, discretized on a uniform $N_x \\times N_y$ grid. The solution must be compared against analytical results or expected zero outcomes for three distinct test cases.\n\nThe numerical implementation adheres to the following principles:\n\n**1. Spatial Discretization: Fourier Pseudospectral Method**\nOn a periodic domain, the Fourier spectral method provides the most accurate means of computing spatial derivatives. A function $f(x,y)$ is represented by its discrete Fourier series coefficients $\\hat{f}(k_x, k_y)$. The spatial derivatives in physical space correspond to algebraic multiplication by the imaginary unit $i$ and the respective wavenumbers in Fourier space. For a field $f$ with Fourier transform $\\hat{f}$, its derivatives and Laplacian are computed via:\n$$\n\\frac{\\partial f}{\\partial x} = \\mathcal{F}^{-1}\\{i k_x \\hat{f}\\} \\quad , \\quad \\frac{\\partial f}{\\partial y} = \\mathcal{F}^{-1}\\{i k_y \\hat{f}\\}\n$$\n$$\n\\nabla^2 f = \\mathcal{F}^{-1}\\{-(k_x^2 + k_y^2) \\hat{f}\\}\n$$\nwhere $\\mathcal{F}^{-1}$ denotes the inverse Fourier transform, and $k_x$, $k_y$ are the discrete wavenumbers. This method is implemented efficiently using the Fast Fourier Transform (FFT) algorithm.\n\n**2. Temporal Integration: 4th-Order Runge-Kutta (RK4) Method**\nThe time evolution is performed using the classic fourth-order explicit Runge-Kutta scheme, which offers a favorable balance of accuracy (fourth-order) and stability for a given time step $\\Delta t$. For an ordinary differential equation of the form $d\\omega/dt = \\mathcal{R}(\\omega)$, a single time step from $\\omega_n$ to $\\omega_{n+1}$ is computed as:\n$$\n\\begin{aligned}\nk_1 = \\Delta t \\cdot \\mathcal{R}(\\omega_n) \\\\\nk_2 = \\Delta t \\cdot \\mathcal{R}(\\omega_n + k_1/2) \\\\\nk_3 = \\Delta t \\cdot \\mathcal{R}(\\omega_n + k_2/2) \\\\\nk_4 = \\Delta t \\cdot \\mathcal{R}(\\omega_n + k_3) \\\\\n\\omega_{n+1} = \\omega_n + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\nwhere $\\mathcal{R}(\\omega) = S_b + \\nu \\nabla^2 \\omega$. The time step $\\Delta t$ is chosen to be sufficiently small to ensure both numerical stability, particularly limited by the viscous term $\\nu \\nabla^2 \\omega$ at high wavenumbers, and temporal accuracy.\n\n**3. Field Construction**\nThe static pressure and density fields are constructed as follows:\n-   **Pressure Field:** A periodic pair of smoothed shocks with gradients primarily in the $x$-direction is required. A suitable function that is periodic on $[0, 2\\pi]$ and possesses these features is $p(x,y) = \\frac{\\Delta p}{2} \\tanh(\\frac{\\cos(x)}{\\epsilon})$, where $\\epsilon = 2\\delta/L_x$ is a parameter controlling the shock thickness. This creates steep pressure gradients near $x=\\pi/2$ and $x=3\\pi/2$.\n-   **Density Fields:**\n    -   **Case 1 (Aligned Gradients):** A simple sinusoidal field, $\\rho(x,y) = 1 + A_\\rho \\sin(k_\\rho x)$, with gradients only in the $x$-direction. Since $\\nabla p$ is also only in the $x$-direction, their cross product is zero, yielding $S_b=0$.\n    -   **Case 2 (Misaligned Gradients):** A similar sinusoidal field, but oriented along the $y$-direction, $\\rho(x,y) = 1 + A_\\rho \\sin(k_\\rho y)$. Here, $\\nabla\\rho$ is perpendicular to $\\nabla p$, maximizing the baroclinic source term $S_b$.\n    -   **Case 3 (Turbulent Density):** A field with controlled spectral content is constructed via spectral synthesis. A random real field is generated in physical space, transformed to Fourier space using FFT, and then filtered to retain energy only within an isotropic wavenumber ring defined by $k_0 - \\Delta k \\le |\\boldsymbol{k}| \\le k_0 + \\Delta k$. The resulting filtered spectrum is transformed back to physical space to obtain a turbulent-like density fluctuation field. This field is scaled by the specified amplitude $A_\\rho$ and added to a mean value of $1$ to ensure $\\rho > 0$.\n\n**4. Verification and Metrics**\n-   **Case 1:** Since $S_b=0$ and $\\nu=0$, the equation becomes $\\partial \\omega/\\partial t=0$. With $\\omega(0)=0$, the exact solution is $\\omega(T)=0$. The metric is the $\\ell_2$-norm of the final numerical vorticity, $||\\omega(T)||_2$, which should be close to machine precision.\n-   **Case 2:** With time-independent fields and $\\nu=0$, the equation is $\\partial \\omega/\\partial t = S_b(\\text{const.})$. The exact solution is $\\omega(T) = T \\cdot S_b$. The metric is the relative $\\ell_2$-error between the numerical and exact solutions, $||\\omega_{\\text{num}} - \\omega_{\\text{exact}}||_2 / ||\\omega_{\\text{exact}}||_2$.\n-   **Case 3:** For this case with $\\nu0$, the governing equation is a linear PDE with a constant source term. Its exact solution in Fourier space is given. For each wavenumber $\\boldsymbol{k}$:\n    $$\n    \\hat{\\omega}(\\boldsymbol{k}, T) = \\begin{cases} \\hat{S}_b(\\boldsymbol{k}) \\frac{1 - e^{-\\nu |\\boldsymbol{k}|^2 T}}{\\nu |\\boldsymbol{k}|^2}  \\text{if } |\\boldsymbol{k}| \\neq 0 \\\\ T \\cdot \\hat{S}_b(\\boldsymbol{k})  \\text{if } |\\boldsymbol{k}| = 0 \\end{cases}\n    $$\n    The exact solution in physical space, $\\omega_{\\text{exact}}(T)$, is found by taking the inverse Fourier transform of $\\hat{\\omega}(\\boldsymbol{k}, T)$. The metric is again the relative $\\ell_2$-error between the numerical and exact solutions.\n\nThe provided Python program implements these steps, processing each test case to compute and report the specified quantitative metric.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the baroclinic vorticity verification problem for three test cases.\n    \"\"\"\n    test_cases_params = [\n        {'case_id': 1, 'N': 64, 'L': 2 * np.pi, 'nu': 0.0, 'T': 0.20, 'delta_rel': 0.05, 'dp': 1.0, 'a_rho': 0.1, 'k_rho': 4},\n        {'case_id': 2, 'N': 64, 'L': 2 * np.pi, 'nu': 0.0, 'T': 0.15, 'delta_rel': 0.05, 'dp': 1.0, 'a_rho': 0.1, 'k_rho': 5},\n        {'case_id': 3, 'N': 64, 'L': 2 * np.pi, 'nu': 0.01, 'T': 0.20, 'delta_rel': 0.05, 'dp': 1.0, 'a_rho': 0.1, 'k0': 8, 'dk': 1},\n    ]\n\n    results = []\n    n_steps = 1000  # Fixed number of time steps for stability and accuracy\n\n    for params in test_cases_params:\n        # 1. Setup Grid and Wavenumbers\n        N = params['N']\n        L = params['L']\n        dx = L / N\n        x_1d = np.arange(N) * dx\n        x, y = np.meshgrid(x_1d, x_1d, indexing='ij')\n\n        k_1d = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n        kx, ky = np.meshgrid(k_1d, k_1d, indexing='ij')\n        k_sq = kx**2 + ky**2\n\n        # 2. Define Spectral Derivative Utilities\n        def grad(f_field):\n            f_hat = np.fft.fft2(f_field)\n            dfdx = np.fft.ifft2(1j * kx * f_hat).real\n            dfdy = np.fft.ifft2(1j * ky * f_hat).real\n            return dfdx, dfdy\n\n        def laplacian(f_field):\n            f_hat = np.fft.fft2(f_field)\n            return np.fft.ifft2(-k_sq * f_hat).real\n\n        # 3. Construct Initial Density and Pressure Fields\n        dp = params['dp']\n        delta_param = 2 * params['delta_rel']\n        p = (dp / 2.0) * np.tanh(np.cos(x) / delta_param)\n\n        if params['case_id'] == 1:\n            rho = 1.0 + params['a_rho'] * np.sin(params['k_rho'] * x)\n        elif params['case_id'] == 2:\n            rho = 1.0 + params['a_rho'] * np.sin(params['k_rho'] * y)\n        else:  # Case 3\n            k0, dk, a_rho = params['k0'], params['dk'], params['a_rho']\n            np.random.seed(42)  # For reproducibility\n\n            k_mag = np.sqrt(k_sq)\n            filter_mask = (k_mag = k0 - dk)  (k_mag = k0 + dk)\n            \n            # Generate a random real field, FFT, filter, then IFFT\n            rand_field = np.random.randn(N, N)\n            rand_hat = np.fft.fft2(rand_field)\n            \n            rho_hat_filtered = rand_hat * filter_mask\n            delta_rho = np.fft.ifft2(rho_hat_filtered).real\n            delta_rho -= np.mean(delta_rho) # Ensure zero mean fluctuation\n            \n            # Scale to specified peak amplitude\n            max_abs_val = np.max(np.abs(delta_rho))\n            if max_abs_val  1e-9:\n                delta_rho *= a_rho / max_abs_val\n            \n            rho = 1.0 + delta_rho\n\n        # 4. Compute Baroclinic Source Term\n        rho_dx, rho_dy = grad(rho)\n        p_dx, p_dy = grad(p)\n        S_b = (rho_dx * p_dy - rho_dy * p_dx) / rho**2\n\n        # 5. Time Integration (RK4)\n        omega = np.zeros((N, N))\n        T, nu = params['T'], params['nu']\n        dt = T / n_steps\n\n        def rhs(w):\n            return S_b + nu * laplacian(w)\n\n        for _ in range(n_steps):\n            k1 = dt * rhs(omega)\n            k2 = dt * rhs(omega + 0.5 * k1)\n            k3 = dt * rhs(omega + 0.5 * k2)\n            k4 = dt * rhs(omega + k3)\n            omega += (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n            \n        # 6. Calculate and Store Result Metric\n        if params['case_id'] == 1:\n            result = np.linalg.norm(omega)\n        elif params['case_id'] == 2:\n            omega_analytic = T * S_b\n            error_norm = np.linalg.norm(omega - omega_analytic)\n            analytic_norm = np.linalg.norm(omega_analytic)\n            result = error_norm / analytic_norm if analytic_norm  1e-12 else error_norm\n        else: # Case 3\n            S_b_hat = np.fft.fft2(S_b)\n            omega_hat_analytic = np.zeros_like(S_b_hat)\n            \n            # Non-zero k modes\n            non_zero_k_mask = k_sq  1e-12\n            k_sq_nz = k_sq[non_zero_k_mask]\n            \n            term = nu * k_sq_nz\n            factor = (1.0 - np.exp(-term * T)) / term\n            \n            omega_hat_analytic[non_zero_k_mask] = S_b_hat[non_zero_k_mask] * factor\n            \n            # Zero k mode (k=0)\n            omega_hat_analytic[0, 0] = S_b_hat[0, 0] * T\n            \n            omega_analytic = np.fft.ifft2(omega_hat_analytic).real\n            \n            error_norm = np.linalg.norm(omega - omega_analytic)\n            analytic_norm = np.linalg.norm(omega_analytic)\n            result = error_norm / analytic_norm if analytic_norm  1e-12 else error_norm\n\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Classical interfacial instabilities, such as the Rayleigh-Taylor instability, are driven by a competition between destabilizing forces like gravity and stabilizing effects. Surface tension, or capillarity, is a crucial stabilizing mechanism that resists interfacial deformation, particularly at small length scales. This practice employs a linear spectral model to quantify this effect, where you will explore how the growth rate spectrum changes as a function of the Weber number, a dimensionless group comparing inertial forces to surface tension forces. This analysis provides direct insight into how capillarity establishes a cutoff scale, suppressing the growth of small-scale corrugations on an unstable interface .",
            "id": "3361575",
            "problem": "You are to implement a conservative curvature calculation for a surface-tension force in a weakly compressible Rayleigh–Taylor instability, and then use a linear spectral model to quantify the influence of the surface tension coefficient on small-scale stabilization of interfacial displacement. The goal is to compute the curvature using a conservative level-set style formula and then compare the interfacial displacement spectra with and without capillarity for a range of Weber numbers.\n\nBackground and fundamental base:\n- Start from the compressible, inviscid Euler equations for each fluid,\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla\\cdot(\\rho \\boldsymbol{u}) = 0,\\quad\n\\frac{\\partial (\\rho \\boldsymbol{u})}{\\partial t} + \\nabla\\cdot(\\rho \\boldsymbol{u}\\otimes \\boldsymbol{u}) + \\nabla p = \\rho \\boldsymbol{g},\n$$\nand the dynamic boundary condition at the interface that imposes a pressure jump equal to the surface tension times curvature,\n$$\n[p] = \\sigma_s \\kappa,\n$$\nwhere $[\\cdot]$ denotes the jump across the interface, $\\sigma_s$ is the surface tension coefficient, and $\\kappa$ is the curvature. The kinematic boundary condition ties the interface displacement $\\eta(x,t)$ to the fluid velocity at the interface. Under the low Mach number regime (e.g., $M \\ll 1$), the leading-order linearized dispersion relation for the Rayleigh–Taylor instability with capillarity (for a flat base interface at $y=0$ perturbed by $\\eta(x,t)$) reduces to the classical incompressible form,\n$$\ns^2(k) = A g k - \\frac{\\sigma_s}{\\rho_1+\\rho_2} k^3,\n$$\nwhere $s(k)$ is the growth rate, $g$ is gravitational acceleration, $k$ is the wavenumber magnitude, $\\rho_1$ and $\\rho_2$ are the (constant) densities of the light and heavy fluids, and $A$ is the Atwood number $A = \\frac{\\rho_2-\\rho_1}{\\rho_2+\\rho_1}$. This leading-order result is valid for subsonic conditions when acoustic corrections are higher-order in the Mach number.\n\nYou must implement the conservative curvature of the interface using the implicit function $\\phi(x,y) = y - \\eta(x)$, for which the unit normal is\n$$\n\\hat{\\boldsymbol{n}} = \\frac{\\nabla \\phi}{\\lVert\\nabla \\phi\\rVert} = \\frac{(-\\partial_x\\eta,\\,1)}{\\sqrt{1+(\\partial_x \\eta)^2}}.\n$$\nThe conservative curvature is then the divergence of the unit normal,\n$$\n\\kappa = \\nabla\\cdot \\hat{\\boldsymbol{n}} = -\\frac{\\partial_{xx}\\eta}{\\left(1+(\\partial_x \\eta)^2\\right)^{3/2}}.\n$$\nIn the small-slope limit $|\\partial_x\\eta| \\ll 1$, this simplifies to $\\kappa \\approx -\\partial_{xx}\\eta$, and in Fourier space $\\widehat{\\kappa}(k) \\approx -k^2 \\widehat{\\eta}(k)$.\n\nYou will construct a one-dimensional interface $\\eta(x)$ over a periodic domain and compute its curvature using the conservative formula above. Then, using the linear growth model with and without capillarity, compute and compare the spectra of $\\eta$ under a fixed evolution time.\n\nProblem specification:\n- Domain length is $L_x = 1\\,\\mathrm{m}$, and the discretization uses $N_x = 4096$ uniformly spaced points (periodic).\n- Fluid densities are $\\rho_1 = 1\\,\\mathrm{kg/m^3}$ and $\\rho_2 = 3\\,\\mathrm{kg/m^3}$, so $A = \\frac{\\rho_2-\\rho_1}{\\rho_2+\\rho_1}$ and $\\rho_{\\text{tot}} = \\rho_1+\\rho_2$.\n- Gravity is $g = 9.81\\,\\mathrm{m/s^2}$.\n- The characteristic scales for the Weber number are $U = 1\\,\\mathrm{m/s}$ and $L = 0.1\\,\\mathrm{m}$, and the reference density in the Weber number is $\\rho_{\\text{ref}} = \\rho_2$.\n- The Weber number is defined as $We = \\frac{\\rho_{\\text{ref}} U^2 L}{\\sigma_s}$, so $\\sigma_s = \\frac{\\rho_{\\text{ref}} U^2 L}{We}$ for finite $We$. Use the following $We$ test suite values spanning $[1,10^3]$: $We \\in \\{1, 10, 100, 1000\\}$. For the “without capillarity” comparison, set $\\sigma_s = 0$ explicitly.\n- Wavenumbers to be analyzed are the discrete Fourier modes corresponding to integer harmonics $n \\in \\{1,2,3,5,10\\}$, i.e., $k_n = \\frac{2\\pi n}{L_x}$ in $\\mathrm{rad/m}$.\n- The initial interface is a deterministic sum of cosines,\n$$\n\\eta(x,0) = \\sum_{n \\in \\{1,2,3,5,10\\}} \\frac{a_0}{n^2} \\cos\\left(k_n x\\right),\n$$\nwith $a_0 = 10^{-5}\\,\\mathrm{m}$.\n- The conservative curvature is computed from the discrete $\\eta(x)$ using central differences to approximate $\\partial_x \\eta$ and $\\partial_{xx}\\eta$, and then using $\\kappa = -\\partial_{xx}\\eta/\\left(1+(\\partial_x \\eta)^2\\right)^{3/2}$.\n- The spectral energy of displacement is defined as\n$$\nE_\\eta(k_n) = \\left|\\widehat{\\eta}(k_n)\\right|^2,\n$$\nwhere $\\widehat{\\eta}(k_n)$ is the discrete Fourier coefficient normalized by $1/N_x$ to approximate the continuous $L_x^{-1}\\int \\eta(x)e^{-ik_n x}\\,dx$. Report $E_\\eta(k_n)$ in $\\mathrm{m^2}$.\n- The evolution is linear and purely exponential in time over duration $T = 0.5\\,\\mathrm{s}$; for each mode $k_n$, with capillarity,\n$$\ns^2(k_n) = A g k_n - \\frac{\\sigma_s}{\\rho_{\\text{tot}}} k_n^3,\\quad s(k_n) = \\begin{cases}\\sqrt{s^2(k_n)}  \\text{if } s^2(k_n)  0,\\\\ 0  \\text{otherwise,}\\end{cases}\n$$\nand the evolved spectrum is\n$$\nE_\\eta^{(\\text{cap})}(k_n) = E_\\eta^{(0)}(k_n) \\exp\\left(2\\,s(k_n)\\,T\\right).\n$$\nWithout capillarity, set $\\sigma_s = 0$ and use the same formula to compute $E_\\eta^{(\\text{no-cap})}(k_n)$.\n- Angle units are radians. Wavenumber units are $\\mathrm{rad/m}$. Report all energies in $\\mathrm{m^2}$.\n- Test suite:\n  1. $We = 1$ (strong capillarity),\n  2. $We = 10$,\n  3. $We = 100$,\n  4. $We = 1000$ (weak capillarity).\n  Additionally, for each $We$, compute the comparison spectrum without capillarity ($\\sigma_s = 0$).\n- Final output format: Your program should produce a single line of output containing a nested list. The outer list iterates over the $We$ values in the order $\\{1,10,100,1000\\}$. For each $We$, produce an inner pair of lists: the first is $[E_\\eta^{(\\text{cap})}(k_1),E_\\eta^{(\\text{cap})}(k_2),E_\\eta^{(\\text{cap})}(k_3),E_\\eta^{(\\text{cap})}(k_5),E_\\eta^{(\\text{cap})}(k_{10})]$, and the second is $[E_\\eta^{(\\text{no-cap})}(k_1),E_\\eta^{(\\text{no-cap})}(k_2),E_\\eta^{(\\text{no-cap})}(k_3),E_\\eta^{(\\text{no-cap})}(k_5),E_\\eta^{(\\text{no-cap})}(k_{10})]$. The output must be a single line with this nested list in Python list literal syntax, for example, \"[[[e11,e12,...],[f11,f12,...]],[[e21,...],[f21,...]],...]\".",
            "solution": "The problem requires an analysis of the stabilizing effect of surface tension, or capillarity, on the development of the Rayleigh–Taylor instability. The analysis will be performed using a one-dimensional linear spectral model. The core task is to compute the evolution of the spectral energy of an initial interfacial perturbation for a set of wavenumbers under different surface tension strengths, parameterized by the Weber number, and compare these to the case with no capillarity.\n\nThe problem is founded on the linearized theory of interfacial instabilities in inviscid, weakly compressible flows. The governing equations are the Euler equations, supplemented by a dynamic boundary condition at the fluid interface. For two immiscible fluids with densities $\\rho_1$ and $\\rho_2$ (with $\\rho_2 > \\rho_1$) subject to a gravitational acceleration $\\boldsymbol{g} = (0, -g, 0)$, an interface initially at $y=0$ is perturbed by a small displacement $\\eta(x,t)$. The instability growth is governed by the linearized dispersion relation, which connects the temporal growth rate, $s$, to the spatial wavenumber, $k$.\n\nIn the low Mach number regime, the dispersion relation simplifies to the classical incompressible form:\n$$\ns^2(k) = A g k - \\frac{\\sigma_s}{\\rho_1+\\rho_2} k^3\n$$\nHere, $k$ is the magnitude of the wavenumber, $g$ is the gravitational acceleration, $\\sigma_s$ is the surface tension coefficient, and $A$ is the Atwood number, defined as $A = \\frac{\\rho_2-\\rho_1}{\\rho_2+\\rho_1}$. The first term, $A g k$, represents the destabilizing effect of buoyancy, driving the instability. The second term, $-\\frac{\\sigma_s}{\\rho_1+\\rho_2} k^3$, represents the stabilizing effect of surface tension, which acts to restore a flat interface and is most effective at small length scales (large $k$). The growth rate $s(k)$ is the square root of this expression, taken to be zero if $s^2(k)$ is negative, which corresponds to stable or oscillating modes. The condition $s^2(k)=0$ defines a critical cutoff wavenumber, $k_c = \\sqrt{A g (\\rho_1+\\rho_2) / \\sigma_s}$, beyond which all perturbations are stabilized by capillarity.\n\nThe curvature $\\kappa$ of the interface $y=\\eta(x)$ is given by the conservative formula, which is the divergence of the unit normal vector $\\hat{\\boldsymbol{n}}$:\n$$\n\\kappa = \\nabla\\cdot \\hat{\\boldsymbol{n}} = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{\\lVert\\nabla \\phi\\rVert} \\right)\n$$\nwhere $\\phi(x,y)=y-\\eta(x)$ is the level-set function defining the interface. In two dimensions, this evaluates to:\n$$\n\\kappa = -\\frac{\\partial_{xx}\\eta}{\\left(1+(\\partial_x \\eta)^2\\right)^{3/2}}\n$$\nWhile this formula is provided for context, the linear analysis proceeds directly in Fourier space, bypassing a direct numerical calculation of $\\kappa$ on a grid. The effect of curvature is implicitly contained within the $k^3$ term of the dispersion relation, which arises from the Fourier representation of the pressure jump condition $[p] = \\sigma_s \\kappa \\approx -\\sigma_s \\partial_{xx}\\eta$.\n\nThe problem specifies the following parameters:\n- Domain length: $L_x = 1\\,\\mathrm{m}$\n- Fluid densities: $\\rho_1 = 1\\,\\mathrm{kg/m^3}$, $\\rho_2 = 3\\,\\mathrm{kg/m^3}$\n- Gravitational acceleration: $g = 9.81\\,\\mathrm{m/s^2}$\n- Evolution time: $T = 0.5\\,\\mathrm{s}$\n- Initial perturbation amplitude: $a_0 = 10^{-5}\\,\\mathrm{m}$\n\nFrom these, we derive the Atwood number $A = \\frac{3-1}{3+1} = 0.5$ and the total density $\\rho_{\\text{tot}} = \\rho_1+\\rho_2 = 4\\,\\mathrm{kg/m^3}$.\n\nThe surface tension coefficient $\\sigma_s$ is specified via the Weber number, $We = \\frac{\\rho_{\\text{ref}} U^2 L}{\\sigma_s}$, where $\\rho_{\\text{ref}} = \\rho_2 = 3\\,\\mathrm{kg/m^3}$, $U = 1\\,\\mathrm{m/s}$, and $L = 0.1\\,\\mathrm{m}$. Thus, $\\sigma_s = \\frac{3 \\cdot 1^2 \\cdot 0.1}{We} = \\frac{0.3}{We}\\,\\mathrm{N/m}$. The analysis is performed for $We \\in \\{1, 10, 100, 1000\\}$, and for the baseline case where $\\sigma_s = 0$.\n\nThe initial interface is a superposition of cosine modes:\n$$\n\\eta(x,0) = \\sum_{n \\in \\{1,2,3,5,10\\}} \\frac{a_0}{n^2} \\cos\\left(k_n x\\right)\n$$\nwhere $k_n = \\frac{2\\pi n}{L_x} = 2\\pi n\\,\\mathrm{rad/m}$. The Fourier series of $\\cos(k_n x)$ is $\\frac{1}{2}(e^{ik_n x} + e^{-ik_n x})$. The complex Fourier coefficient $\\widehat{\\eta}(k_n, t=0)$ for the wavenumber $k_n$ is therefore $\\frac{1}{2}$ the amplitude of the corresponding cosine term, which is $\\frac{1}{2} \\frac{a_0}{n^2}$. The initial spectral energy for each mode is defined as $E_\\eta^{(0)}(k_n) = |\\widehat{\\eta}(k_n, 0)|^2$:\n$$\nE_\\eta^{(0)}(k_n) = \\left(\\frac{a_0}{2n^2}\\right)^2\n$$\nUnder the linear growth model, the amplitude of each mode evolves exponentially: $\\widehat{\\eta}(k_n, T) = \\widehat{\\eta}(k_n, 0) \\exp(s(k_n)T)$. The spectral energy at time $T$ is therefore:\n$$\nE_\\eta(k_n, T) = |\\widehat{\\eta}(k_n, T)|^2 = |\\widehat{\\eta}(k_n, 0)|^2 \\exp(2 s(k_n) T) = E_\\eta^{(0)}(k_n) \\exp(2 s(k_n) T)\n$$\n\nThe solution algorithm is as follows:\n1.  Define all physical constants and problem parameters.\n2.  Calculate the derived constants $A$ and $\\rho_{\\text{tot}}$.\n3.  Define the set of integer modes $n \\in \\{1,2,3,5,10\\}$ and the corresponding wavenumbers $k_n = 2\\pi n/L_x$.\n4.  Iterate through the specified Weber numbers $We \\in \\{1, 10, 100, 1000\\}$.\n5.  For each $We$, calculate the corresponding $\\sigma_s$.\n6.  For each $n$ in the set of modes:\n    a. Calculate the initial spectral energy $E_\\eta^{(0)}(k_n)$.\n    b. **With capillarity**: Compute $s^2(k_n) = A g k_n - \\frac{\\sigma_s}{\\rho_{\\text{tot}}} k_n^3$. Set $s(k_n) = \\sqrt{\\max(0, s^2(k_n))}$. Calculate the evolved energy $E_\\eta^{(\\text{cap})}(k_n, T) = E_\\eta^{(0)}(k_n) \\exp(2 s(k_n) T)$.\n    c. **Without capillarity**: Compute $s_0^2(k_n) = A g k_n$. Set $s_0(k_n) = \\sqrt{s_0^2(k_n)}$. Calculate the reference evolved energy $E_\\eta^{(\\text{no-cap})}(k_n, T) = E_\\eta^{(0)}(k_n) \\exp(2 s_0(k_n) T)$.\n7.  Store the results for each $We$ as a pair of lists: one for the energies with capillarity and one for the energies without.\n8.  Format the final collection of results into a single nested list as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the spectral energy of Rayleigh-Taylor instability with and without\n    surface tension effects based on a linear growth model.\n    \"\"\"\n    # Problem specification:\n    L_x = 1.0  # m\n    # N_x = 4096 (not needed for spectral calculation)\n    rho1 = 1.0  # kg/m^3\n    rho2 = 3.0  # kg/m^3\n    g = 9.81  # m/s^2\n    \n    # Weber number parameters\n    U_char = 1.0  # m/s\n    L_char = 0.1  # m\n    rho_ref = rho2  # kg/m^3\n    \n    # Initial condition and evolution parameters\n    a0 = 1e-5  # m\n    T = 0.5  # s\n    \n    # Test suite parameters\n    weber_numbers = [1, 10, 100, 1000]\n    modes_n = [1, 2, 3, 5, 10]\n\n    # Derived constants\n    A = (rho2 - rho1) / (rho2 + rho1)\n    rho_tot = rho1 + rho2\n\n    all_results = []\n\n    for we in weber_numbers:\n        # Calculate surface tension coefficient from Weber number\n        if we  0:\n            sigma_s = (rho_ref * U_char**2 * L_char) / we\n        else: # Should not happen with the given test suite\n            sigma_s = 0\n\n        energies_cap = []\n        energies_nocap = []\n\n        for n in modes_n:\n            # Wavenumber\n            k_n = (2 * np.pi * n) / L_x\n\n            # Initial spectral energy from initial condition eta(x,0)\n            # For eta_n(x) = C_n cos(k_n x), the Fourier coefficient is C_n/2.\n            # Here C_n = a0 / n**2.\n            # E_eta(k_n) = |a0 / (2 * n**2)|^2\n            E0_n = (a0 / (2 * n**2))**2\n\n            # --- Case 1: With capillarity ---\n            s2_cap = A * g * k_n - (sigma_s / rho_tot) * k_n**3\n            \n            if s2_cap  0:\n                s_cap = np.sqrt(s2_cap)\n            else:\n                s_cap = 0.0\n            \n            E_final_cap = E0_n * np.exp(2 * s_cap * T)\n            energies_cap.append(E_final_cap)\n\n            # --- Case 2: Without capillarity (sigma_s = 0) ---\n            s2_nocap = A * g * k_n\n            s_nocap = np.sqrt(s2_nocap) # Always positive for k_n  0\n            \n            E_final_nocap = E0_n * np.exp(2 * s_nocap * T)\n            energies_nocap.append(E_final_nocap)\n\n        all_results.append([energies_cap, energies_nocap])\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list of lists is the required format.\n    print(all_results)\n\nsolve()\n```"
        },
        {
            "introduction": "Understanding and modeling the interaction between turbulence and shock waves is a central challenge in compressible computational fluid dynamics. When turbulence passes through a shock, it is not only amplified but also becomes highly anisotropic, effects which must be captured by any high-fidelity simulation. This advanced practice guides you through the construction and calibration of a reduced-order model for the Reynolds stress response across a shock, a task representative of modern turbulence model development for Large-Eddy Simulations (LES). By using results from Rapid Distortion Theory (RDT) as a calibration target, you will gain practical experience in bridging fundamental theory with the algebraic models used in cutting-edge compressible flow simulations .",
            "id": "3361602",
            "problem": "You are to implement a self-contained, reduced-order, compressible large-eddy simulation (LES) response model for homogeneous isotropic turbulence impinging on a planar, stationary, normal shock at upstream Mach number $M_s$. The goal is to compute the amplification of turbulent kinetic energy $k$ and the anisotropy tensor $a_{ij}$ across the shock as functions of $M_s$, using three different shock sensors. The model constants are to be calibrated by matching Reynolds stress jump conditions derived from conservation laws across the shock in the linear (rapid-distortion) limit. All outputs must be dimensionless floats.\n\nStart from the following fundamental base:\n\n- The compressible Navier–Stokes equations with the ideal gas law and the Rankine–Hugoniot jump conditions across a stationary planar normal shock. For an ideal gas with ratio of specific heats $\\gamma$, the exact mean jump for the density ratio is\n$$\n\\eta \\equiv \\frac{\\rho_2}{\\rho_1} = \\frac{(\\gamma+1) M_s^2}{(\\gamma-1) M_s^2 + 2},\n$$\nand the exact mean jump for the static pressure ratio is\n$$\n\\Pi \\equiv \\frac{p_2}{p_1} = 1 + \\frac{2\\gamma}{\\gamma+1}\\left(M_s^2 - 1\\right).\n$$\nAssume $\\gamma = 1.4$.\n\n- Use Favre (density-weighted) averaging for mean quantities and standard Reynolds decomposition for fluctuations. Let the upstream turbulence be homogeneous and isotropic with upstream turbulent kinetic energy $k_1$ and the upstream Reynolds stress\n$$\nR_{ij,1} = \\overline{u_i' u_j'} = \\frac{2}{3} k_1 \\delta_{ij},\n$$\nwhere $u_i'$ are velocity fluctuations and $\\delta_{ij}$ is the Kronecker delta. Set $k_1 = 1$ for normalization, so all outputs are dimensionless.\n\n- Define the downstream Reynolds stress $R_{ij,2}$ via a component-wise jump model with normal and tangential multipliers:\n$$\nR_{11,2} = C_n \\, R_{11,1}, \\quad R_{22,2} = C_t \\, R_{22,1}, \\quad R_{33,2} = C_t \\, R_{33,1}.\n$$\nDefine the downstream turbulent kinetic energy $k_2 = \\frac{1}{2}(R_{11,2} + R_{22,2} + R_{33,2})$, its amplification $A_k \\equiv k_2/k_1$, and the downstream anisotropy tensor\n$$\na_{ij} = \\frac{R_{ij,2}}{2 k_2} - \\frac{1}{3}\\delta_{ij}.\n$$\n\n- Model $C_n$ and $C_t$ using a shock-sensor-weighted algebraic response with two unknown constants $C_1$ and $C_2$:\n$$\ns \\equiv g_s \\, (\\eta - 1), \\quad C_n = 1 + C_1 s + C_2 s^2, \\quad C_t = 1 + \\frac{1}{2} C_1 s + \\frac{1}{4} C_2 s^2,\n$$\nwhere $g_s \\in [0,1]$ is the output of a chosen shock sensor (defined below). The factorization between $C_n$ and $C_t$ encodes axisymmetric distortion about the shock normal.\n\n- Calibrate $(C_1, C_2)$ by enforcing Reynolds stress jump conditions derived from linearized conservation across a planar normal shock in the rapid-distortion limit. Use the following target component ratios as the calibration objectives:\n$$\nC_n^{\\text{target}}(\\eta) = \\eta^{-2}, \\qquad C_t^{\\text{target}}(\\eta) = \\eta,\n$$\nwhich represent, respectively, normal-component reduction by mass-flux continuity and tangential-component amplification by mean compressive rapid distortion integrated through the shock. Determine $(C_1, C_2)$ by minimizing the sum of squared residuals\n$$\nJ(C_1,C_2) = \\sum_{M_s \\in \\mathcal{S}_{\\text{cal}}} \\left[ \\left(C_n(M_s) - C_n^{\\text{target}}(\\eta(M_s))\\right)^2 + \\left(C_t(M_s) - C_t^{\\text{target}}(\\eta(M_s))\\right)^2 \\right],\n$$\nover the calibration set $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ with a fixed calibration filter-to-shock thickness ratio $\\Delta/\\delta = 1$. Because $C_n$ and $C_t$ are linear functions of $C_1$ and $C_2$ when shifted by $1$, this is a linear least-squares problem in $(C_1, C_2)$.\n\n- Implement three shock sensors to compute $g_s$:\n  1. Density-gradient sensor $g_\\rho$: model the shock as a $\\tanh$ profile with thickness $\\delta$, and a grid filter width $\\Delta$. Let\n  $$\n  g_\\rho = \\tanh\\!\\left( \\alpha_\\rho \\, (\\eta - 1)\\, \\frac{\\Delta}{\\delta} \\right),\n  $$\n  with $\\alpha_\\rho = 0.75$.\n  2. Pressure-based sensor $g_p$: use the pressure jump,\n  $$\n  g_p = \\tanh\\!\\left( \\alpha_p \\, (\\Pi - 1)\\, \\frac{\\Delta}{\\delta} \\right),\n  $$\n  with $\\alpha_p = 0.50$.\n  3. Ducros-type sensor $g_D$: use a compressive indicator proportional to $M_s^2$,\n  $$\n  g_D = \\tanh\\!\\left( \\alpha_D \\, M_s^2 \\, \\frac{\\Delta}{\\delta} \\right),\n  $$\n  with $\\alpha_D = 0.35$.\n\nWorkflow to implement:\n\n- For a given $(M_s, \\delta/\\Delta, \\text{sensor})$, compute $\\eta(M_s)$ and $\\Pi(M_s)$ from the Rankine–Hugoniot formulas with $\\gamma = 1.4$. Compute $\\Delta/\\delta = 1/(\\delta/\\Delta)$.\n\n- For each sensor, first calibrate $(C_1, C_2)$ by solving the linear least-squares problem defined above using the calibration set $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ with $\\Delta/\\delta = 1$ (so $\\delta/\\Delta = 1$). Use the sensor-specific $g_s$ in the definitions of $s$ at each calibration $M_s$.\n\n- With the calibrated $(C_1, C_2)$ for the chosen sensor, evaluate $C_n$ and $C_t$ at the requested $(M_s, \\delta/\\Delta, \\text{sensor})$, then compute $A_k$ and $a_{11}$ for $k_1 = 1$ and $R_{ij,1} = \\frac{2}{3} \\delta_{ij}$.\n\nNumerical and implementation details:\n\n- Use $\\gamma = 1.4$ and $k_1 = 1$. All quantities are dimensionless.\n\n- The test suite consists of the following three cases, which you must evaluate in order:\n  - Case $1$: $(M_s, \\delta/\\Delta, \\text{sensor}) = (1.05, 2.0, \\text{density})$ with the density-gradient sensor $g_\\rho$.\n  - Case $2$: $(M_s, \\delta/\\Delta, \\text{sensor}) = (1.5, 1.0, \\text{pressure})$ with the pressure-based sensor $g_p$.\n  - Case $3$: $(M_s, \\delta/\\Delta, \\text{sensor}) = (3.0, 0.25, \\text{ducros})$ with the Ducros-type sensor $g_D$.\n\n- For each case, produce two outputs: the turbulent kinetic energy amplification $A_k$ and the normal-component anisotropy $a_{11}$, both as dimensionless floats rounded to six digits after the decimal point.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$$\n[A_k^{(1)}, a_{11}^{(1)}, A_k^{(2)}, a_{11}^{(2)}, A_k^{(3)}, a_{11}^{(3)}].\n$$\nNo other text should be printed. All outputs must be dimensionless floats rounded to six decimals.",
            "solution": "We construct a principled, reduced-order model that captures the essential physics of shock–turbulence interaction for homogeneous isotropic turbulence in the limit of small-scale rapid distortion. We begin from conservation laws and standard decompositions, then formulate a calibration against Reynolds stress jump relations, and finally define an algorithm that is implementable as a short numerical program.\n\nBase equations and definitions:\n\n- For a stationary planar normal shock in an ideal gas with ratio of specific heats $\\gamma$, the Rankine–Hugoniot jump conditions for the mean fields yield the exact density and pressure ratios:\n$$\n\\eta(M_s) = \\frac{\\rho_2}{\\rho_1} = \\frac{(\\gamma+1) M_s^2}{(\\gamma-1) M_s^2 + 2}, \\quad\n\\Pi(M_s) = \\frac{p_2}{p_1} = 1 + \\frac{2\\gamma}{\\gamma+1}\\left(M_s^2 - 1\\right).\n$$\n\n- The upstream flow is homogeneous and isotropic with upstream turbulent kinetic energy $k_1$, and Reynolds stress\n$$\nR_{ij,1} = \\overline{u_i' u_j'} = \\frac{2}{3} k_1 \\delta_{ij}.\n$$\nWe set $k_1 = 1$ so that $R_{ij,1} = \\frac{2}{3} \\delta_{ij}$. The downstream stress is modeled with component multipliers $C_n$ (normal) and $C_t$ (tangential):\n$$\nR_{11,2} = C_n \\, R_{11,1}, \\quad R_{22,2} = R_{33,2} = C_t \\, R_{22,1}.\n$$\nThen the downstream turbulent kinetic energy is $k_2 = \\frac{1}{2}(R_{11,2} + R_{22,2} + R_{33,2})$, and the amplification is $A_k \\equiv k_2/k_1$. The anisotropy tensor is $a_{ij} = \\frac{R_{ij,2}}{2k_2} - \\frac{1}{3}\\delta_{ij}$, from which we will extract $a_{11}$.\n\nRapid-distortion-based jump targets:\n\n- For a planar shock aligned with the $x$-axis ($x$ is the shock-normal direction), we consider a small control volume straddling the shock and linearize the conservation of mass and momentum for perturbations. Mass-flux continuity suggests that normal velocity perturbations scale inversely with increases in density across the discontinuity, $u_n' \\to u_n'/\\eta$, assuming the shock thickness is negligible compared with the turbulent scales and neglecting density perturbations within the vanishingly thin discontinuity itself. Squaring the amplitude implies the variance of the normal component scales as $1/\\eta^2$. Hence for the normal component we target\n$$\nC_n^{\\text{target}}(\\eta) = \\eta^{-2}.\n$$\n\n- Tangential components are affected by compressive mean rapid distortion. In rapid-distortion theory for planar compression, the tangential components experience amplification proportional to the compression factor integrated through the shock. For an axisymmetric distortion about the normal, the tangential variance grows proportionally to the density increase (reflecting the contraction of material surfaces and concomitant amplification of tangential gradients), yielding\n$$\nC_t^{\\text{target}}(\\eta) = \\eta.\n$$\nThis pair of targets is consistent with conservation of mass (for the normal component) and compressive rapid distortion (for tangential components) in the linear limit and has been widely invoked as a first-order approximation in shock–turbulence interaction models.\n\nAlgebraic response model:\n\n- We introduce a sensor-weighted algebraic model for the component multipliers with two unknown constants $C_1$ and $C_2$:\n$$\ns \\equiv g_s (\\eta - 1), \\quad\nC_n = 1 + C_1 s + C_2 s^2, \\quad\nC_t = 1 + \\frac{1}{2} C_1 s + \\frac{1}{4} C_2 s^2.\n$$\nHere $g_s \\in [0,1]$ is a shock sensor. The specific forms for $C_n$ and $C_t$ enforce axisymmetric distortion about the shock normal and ensure $C_n, C_t \\to 1$ as $s \\to 0$ (no shock or fully under-resolved shock).\n\nShock sensors:\n\n- We require three sensors $g_s$ that monotonically increase with shock strength and resolution ($\\Delta/\\delta$), where $\\Delta$ is the grid filter width and $\\delta$ is the shock thickness. Noting that the maximum gradient of a $\\tanh$ profile scales as $1/\\delta$, we define:\n  1. Density-gradient sensor:\n  $$\n  g_\\rho = \\tanh\\!\\left( \\alpha_\\rho \\, (\\eta - 1) \\frac{\\Delta}{\\delta} \\right), \\quad \\alpha_\\rho = 0.75.\n  $$\n  2. Pressure-based sensor:\n  $$\n  g_p = \\tanh\\!\\left( \\alpha_p \\, (\\Pi - 1) \\frac{\\Delta}{\\delta} \\right), \\quad \\alpha_p = 0.50.\n  $$\n  3. Ducros-type compressive sensor:\n  $$\n  g_D = \\tanh\\!\\left( \\alpha_D \\, M_s^2 \\frac{\\Delta}{\\delta} \\right), \\quad \\alpha_D = 0.35.\n  $$\n\nCalibration procedure:\n\n- We determine $C_1$ and $C_2$ by minimizing the squared residual between the modeled components $(C_n, C_t)$ and the targets $(\\eta^{-2}, \\eta)$ over a calibration set $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ using $\\Delta/\\delta = 1$. Because the dependence on $(C_1, C_2)$ is linear after subtracting $1$, we assemble a linear system in least-squares form. For each $M_s \\in \\mathcal{S}_{\\text{cal}}$, let $s = g_s (\\eta - 1)$, then we enforce\n$$\nC_n - 1 = C_1 s + C_2 s^2 \\approx \\eta^{-2} - 1, \\quad\nC_t - 1 = C_1 \\frac{s}{2} + C_2 \\frac{s^2}{4} \\approx \\eta - 1.\n$$\nStacking these for the two $M_s$ values yields four equations for $(C_1, C_2)$, which we solve in the least-squares sense.\n\nComputation of outputs:\n\n- Given $(M_s, \\delta/\\Delta, \\text{sensor})$, compute $\\eta(M_s)$ and $\\Pi(M_s)$, evaluate $\\Delta/\\delta = 1/(\\delta/\\Delta)$, and compute $g_s$ according to the sensor definition. Compute $s = g_s(\\eta-1)$, then $C_n$ and $C_t$. With $R_{ij,1} = \\frac{2}{3}\\delta_{ij}$, obtain\n$$\nR_{11,2} = \\frac{2}{3} C_n, \\quad R_{22,2} = R_{33,2} = \\frac{2}{3} C_t,\n$$\nso\n$$\nk_2 = \\frac{1}{2}\\left( \\frac{2}{3} C_n + 2 \\cdot \\frac{2}{3} C_t \\right) = \\frac{1}{3} \\left( C_n + 2 C_t \\right)\n$$\nand\n$$\nA_k = \\frac{k_2}{k_1} = \\frac{1}{3} \\left( C_n + 2 C_t \\right).\n$$\nFinally,\n$$\na_{11} = \\frac{R_{11,2}}{2k_2} - \\frac{1}{3} = \\frac{\\frac{2}{3} C_n}{\\frac{2}{3} (C_n + 2 C_t)} - \\frac{1}{3} = \\frac{C_n}{C_n + 2 C_t} - \\frac{1}{3}.\n$$\n\nTest suite and output:\n\n- Calibrate $(C_1, C_2)$ separately for each sensor using $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ and $\\Delta/\\delta = 1$.\n\n- Evaluate the following cases in order:\n  - Case $1$: $(M_s, \\delta/\\Delta, \\text{sensor}) = (1.05, 2.0, \\text{density})$ with $g_\\rho$.\n  - Case $2$: $(M_s, \\delta/\\Delta, \\text{sensor}) = (1.5, 1.0, \\text{pressure})$ with $g_p$.\n  - Case $3$: $(M_s, \\delta/\\Delta, \\text{sensor}) = (3.0, 0.25, \\text{ducros})$ with $g_D$.\n\n- For each case, compute $A_k$ and $a_{11}$ and print\n$$\n[A_k^{(1)}, a_{11}^{(1)}, A_k^{(2)}, a_{11}^{(2)}, A_k^{(3)}, a_{11}^{(3)}]\n$$\non a single line as comma-separated floats rounded to six decimals. All outputs are dimensionless.\n\nAlgorithmic summary:\n\n- Implement functions for $\\eta(M_s)$ and $\\Pi(M_s)$ given $\\gamma$.\n\n- Implement sensor functions $g_\\rho$, $g_p$, $g_D$.\n\n- For each sensor, solve a $4 \\times 2$ linear least-squares problem to determine $(C_1, C_2)$ using the calibration set.\n\n- For each test case, compute $C_n$, $C_t$, then $A_k$ and $a_{11}$ using the formulas above.\n\nThis approach is principle-based: it starts from conservation laws at the shock (Rankine–Hugoniot), uses linear rapid-distortion arguments to define target Reynolds stress jump relations, and constructs a minimal algebraic model tied to shock sensing and calibrated by matching those targets. The algorithm is deterministic and fully specified by the equations above, ensuring reproducibility and a single-line numerical output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nGAMMA = 1.4\n\ndef density_ratio(Ms, gamma=GAMMA):\n    # Rankine–Hugoniot density ratio across a normal shock\n    num = (gamma + 1.0) * Ms**2\n    den = (gamma - 1.0) * Ms**2 + 2.0\n    return num / den\n\ndef pressure_ratio(Ms, gamma=GAMMA):\n    # Rankine–Hugoniot pressure ratio across a normal shock\n    return 1.0 + (2.0 * gamma / (gamma + 1.0)) * (Ms**2 - 1.0)\n\ndef sensor_value(sensor, Ms, delta_over_Delta, gamma=GAMMA):\n    # Compute g_s based on the specified sensor and parameters.\n    # delta_over_Delta = delta/Delta, so inv_ratio = Delta/delta\n    inv_ratio = 1.0 / delta_over_Delta\n    eta = density_ratio(Ms, gamma)\n    Pi = pressure_ratio(Ms, gamma)\n    if sensor == 'density':\n        alpha_rho = 0.75\n        arg = alpha_rho * (eta - 1.0) * inv_ratio\n        return np.tanh(arg)\n    elif sensor == 'pressure':\n        alpha_p = 0.50\n        arg = alpha_p * (Pi - 1.0) * inv_ratio\n        return np.tanh(arg)\n    elif sensor == 'ducros':\n        alpha_d = 0.35\n        arg = alpha_d * (Ms**2) * inv_ratio\n        return np.tanh(arg)\n    else:\n        raise ValueError(\"Unknown sensor type\")\n\ndef calibrate_constants(sensor, gamma=GAMMA):\n    # Calibrate C1, C2 for the given sensor using Ms in {1.5, 3.0} and Delta/delta = 1 (i.e., delta/Delta=1)\n    Ms_list = [1.5, 3.0]\n    delta_over_Delta_cal = 1.0  # so inv_ratio = 1\n    rows = []\n    rhs = []\n    for Ms in Ms_list:\n        eta = density_ratio(Ms, gamma)\n        # Targets from rapid-distortion-based jump conditions\n        Cn_target = eta**(-2.0)\n        Ct_target = eta\n        # Sensor\n        gs = sensor_value(sensor, Ms, delta_over_Delta_cal, gamma)\n        s = gs * (eta - 1.0)\n        # Equations: Cn - 1 = C1*s + C2*s^2  - row [s, s^2], rhs (Cn_target - 1)\n        rows.append([s, s**2])\n        rhs.append(Cn_target - 1.0)\n        # Ct - 1 = C1*(s/2) + C2*(s^2/4)\n        rows.append([0.5 * s, 0.25 * s**2])\n        rhs.append(Ct_target - 1.0)\n    A = np.array(rows, dtype=float)\n    b = np.array(rhs, dtype=float)\n    # Least-squares solution\n    theta, *_ = np.linalg.lstsq(A, b, rcond=None)\n    C1, C2 = theta[0], theta[1]\n    return C1, C2\n\ndef compute_Ak_a11(Ms, delta_over_Delta, sensor, C1, C2, gamma=GAMMA):\n    # Compute Ak and a11 for given case and calibrated constants.\n    eta = density_ratio(Ms, gamma)\n    gs = sensor_value(sensor, Ms, delta_over_Delta, gamma)\n    s = gs * (eta - 1.0)\n    Cn = 1.0 + C1 * s + C2 * s**2\n    Ct = 1.0 + 0.5 * C1 * s + 0.25 * C2 * s**2\n    # Upstream R_ii,1 = 2/3\n    R11_2 = (2.0 / 3.0) * Cn\n    R22_2 = (2.0 / 3.0) * Ct\n    R33_2 = (2.0 / 3.0) * Ct\n    k2 = 0.5 * (R11_2 + R22_2 + R33_2)\n    Ak = k2 / 1.0  # since k1 = 1\n    # a11 = R11/(2 k2) - 1/3\n    a11 = (R11_2 / (2.0 * k2)) - (1.0 / 3.0)\n    return Ak, a11\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (Ms, delta_over_Delta, sensor_key)\n    test_cases = [\n        (1.05, 2.0, 'density'),  # Case 1: density-gradient sensor\n        (1.5,  1.0, 'pressure'), # Case 2: pressure-based sensor\n        (3.0,  0.25, 'ducros'),  # Case 3: Ducros-type sensor\n    ]\n\n    # Calibrate constants for each sensor independently.\n    sensors = ['density', 'pressure', 'ducros']\n    calib = {}\n    for s in sensors:\n        C1, C2 = calibrate_constants(s, GAMMA)\n        calib[s] = (C1, C2)\n\n    results = []\n    for Ms, delta_over_Delta, sensor in test_cases:\n        C1, C2 = calib[sensor]\n        Ak, a11 = compute_Ak_a11(Ms, delta_over_Delta, sensor, C1, C2, GAMMA)\n        # Round to six decimals as specified\n        results.append(f\"{Ak:.6f}\")\n        results.append(f\"{a11:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}