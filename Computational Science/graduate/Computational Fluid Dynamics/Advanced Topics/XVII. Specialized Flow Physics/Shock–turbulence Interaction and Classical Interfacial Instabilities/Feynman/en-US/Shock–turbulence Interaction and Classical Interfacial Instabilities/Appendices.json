{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of shock-driven instabilities is the mechanism of baroclinic vorticity generation, captured by the term $\\frac{\\nabla \\rho \\times \\nabla p}{\\rho^2}$ in the vorticity transport equation. This term describes how vorticity is created when a pressure gradient, such as a shock front, is misaligned with a density gradient. This hands-on practice isolates this fundamental term in a simplified kinematic setting, allowing for a rigorous verification of its numerical implementation against exact analytical solutions, a critical skill for building confidence in any compressible flow solver .",
            "id": "3361565",
            "problem": "You are asked to implement a self-contained numerical verification of the baroclinic vorticity generation term in a shock–turbulence interaction using a simplified two-dimensional periodic domain and controlled initial spectra. The starting point must be the compressible Navier–Stokes equations and their curl (the vorticity transport equation). In two spatial dimensions with vorticity aligned in the out-of-plane direction, denote the vorticity by $\\omega$, the velocity by $\\boldsymbol{u}$, the density by $\\rho$, the pressure by $p$, and the kinematic viscosity by $\\nu$. The materially transported vorticity equation can be written as $D\\boldsymbol{\\omega}/Dt = (\\boldsymbol{\\omega}\\cdot\\nabla)\\boldsymbol{u} - \\boldsymbol{\\omega}(\\nabla\\cdot \\boldsymbol{u}) + \\nabla \\rho \\times \\nabla p / \\rho^2 + \\nu \\nabla^2 \\boldsymbol{\\omega}$. In a kinematic verification setting, impose $\\boldsymbol{u}=\\boldsymbol{0}$ for all time so that $D\\boldsymbol{\\omega}/Dt=\\partial \\boldsymbol{\\omega}/\\partial t$, and the evolution reduces to $\\partial \\omega / \\partial t = S_b + \\nu \\nabla^2 \\omega$, where $S_b = (\\partial_x \\rho \\, \\partial_y p - \\partial_y \\rho \\, \\partial_x p)/\\rho^2$ is the baroclinic source term. The purpose is to isolate and verify the correctness of the baroclinic source computation under controlled spectral content of $\\rho$ and a shock-like pressure field, without solving for $\\boldsymbol{u}$, and to quantitatively compare a direct numerical integration against an exact spectral solution when $S_b$ is time-independent.\n\nDomain and fields: Use a doubly periodic square domain of side length $L_x=L_y=2\\pi$, discretized by $N_x \\times N_y$ grid points with uniform spacing. The density field $\\rho(x,y)$ must be constructed to have controlled spectral content, and the pressure field $p(x,y)$ must represent a stationary, periodic, pair of smoothed shocks with large gradient primarily along the $x$ direction. Let the vorticity initial condition be $\\omega(x,y,0)=0$. All quantities are non-dimensional.\n\nFundamental base to be used: The compressible Navier–Stokes equations, the definition of vorticity $\\boldsymbol{\\omega}=\\nabla\\times\\boldsymbol{u}$, the materially transported form $D/Dt=\\partial/\\partial t+\\boldsymbol{u}\\cdot\\nabla$, and the well-tested vorticity transport equation providing the baroclinic source term $\\nabla \\rho \\times \\nabla p / \\rho^2$. The Fourier spectral differentiation identities on periodic domains must be used to compute spatial gradients and Laplacians via Fast Fourier Transforms, with angular wavenumbers $k_x=2\\pi n_x/L_x$ and $k_y=2\\pi n_y/L_y$, where $n_x$ and $n_y$ are integer mode indices.\n\nYour program must implement the following verification tasks on three carefully chosen test cases, integrating $\\partial \\omega / \\partial t = S_b + \\nu \\nabla^2 \\omega$ in time using a stable explicit scheme and comparing to expected outcomes:\n\n1. Aligned gradients (baroclinic source suppressed): Choose $\\rho(x,y)$ that depends only on $x$ and $p(x,y)$ that depends only on $x$ through the periodic shock pair, so that $\\partial_y \\rho=0$ and $\\partial_y p=0$, implying $S_b=0$. Integrate to a final time $T$ with viscosity $\\nu=0$ and report the $\\ell_2$ norm of $\\omega(x,y,T)$, which should be $0$ in exact arithmetic.\n\n2. Maximally misaligned gradients (pure baroclinic generation without diffusion): Choose $\\rho(x,y)$ that depends only on $y$, and $p(x,y)$ as in the shock pair depending only on $x$. With $\\nu=0$, $S_b$ is time-independent, and the exact solution is $\\omega(x,y,T)=T\\,S_b(x,y)$. Integrate numerically to $T$ and report the relative $\\ell_2$ error between the numerical $\\omega$ and the analytic $T\\,S_b$.\n\n3. Turbulent density with controlled spectrum and diffusive evolution: Construct $\\rho(x,y)$ by spectral synthesis with random phases constrained to an isotropic ring around a target wavenumber $k_0$, scaled so that $\\rho(x,y)>0$ everywhere, and $p(x,y)$ as the shock pair. With viscosity $\\nu>0$ and time-independent $S_b$, the exact spectral solution for each nonzero mode is $\\hat{\\omega}(\\boldsymbol{k},T)=\\hat{S}_b(\\boldsymbol{k})\\,(1-e^{-\\nu |\\boldsymbol{k}|^2 T})/(\\nu |\\boldsymbol{k}|^2)$, where hats denote Fourier coefficients and $|\\boldsymbol{k}|^2=k_x^2+k_y^2$, and the zero mode obeys $\\hat{\\omega}(\\boldsymbol{0},T)=T\\,\\hat{S}_b(\\boldsymbol{0})$. Integrate numerically to $T$ and report the relative $\\ell_2$ error between the numerical $\\omega$ and the inverse Fourier transform of the exact spectral solution.\n\nNumerical details to be enforced: Use spectral differentiation via the Fast Fourier Transform to compute $\\partial_x$ and $\\partial_y$ and $\\nabla^2$. Use a fourth-order explicit Runge–Kutta method for time integration. Ensure $\\rho(x,y)$ remains strictly positive by using a baseline value plus small-amplitude fluctuations. Use a reproducible random seed for spectral synthesis. All computations are non-dimensional; no physical units are required. Angles are in radians.\n\nTest suite parameter values:\n- Case $1$: $N_x=N_y=64$, $L_x=L_y=2\\pi$, $\\nu=0$, $T=0.20$, shock thickness $\\delta=0.05\\,L_x$, pressure jump amplitude $\\Delta p=1.0$, density amplitude $A_\\rho=0.1$, density wavenumber $k_\\rho=4$ along $x$.\n- Case $2$: $N_x=N_y=64$, $L_x=L_y=2\\pi$, $\\nu=0$, $T=0.15$, $\\delta=0.05\\,L_x$, $\\Delta p=1.0$, $A_\\rho=0.1$, density wavenumber $k_\\rho=5$ along $y$.\n- Case $3$: $N_x=N_y=64$, $L_x=L_y=2\\pi$, $\\nu=0.01$, $T=0.20$, $\\delta=0.05\\,L_x$, $\\Delta p=1.0$, spectral ring center $k_0=8$, ring half-width $\\Delta k=1$, density fluctuation amplitude $A_\\rho=0.1$.\n\nProgram requirements: Your program must construct $\\rho$ and $p$ as specified, compute $S_b$, integrate $\\partial \\omega / \\partial t = S_b + \\nu \\nabla^2 \\omega$ from $t=0$ to $t=T$ using a fixed time step $\\Delta t$ chosen to ensure numerical stability and accuracy, and then compute the requested quantitative metrics for each case: a float for case $1$, a float for case $2$, and a float for case $3$. The final output format must be a single line containing the three results as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3]$, where each $r_i$ is a floating-point number.\n\nYour program must produce exactly this single-line output and nothing else. All computations must be completed without user input.",
            "solution": "The problem presents a numerical verification task for the baroclinic vorticity generation term, a fundamental mechanism in compressible fluid dynamics, particularly relevant to shock-turbulence interactions. The verification is conducted in a simplified kinematic setting where the velocity field $\\boldsymbol{u}$ is set to zero, which isolates the baroclinic and viscous effects on vorticity evolution. The governing equation for the out-of-plane component of vorticity, $\\omega$, in two dimensions $(x,y)$ is given as:\n$$\n\\frac{\\partial \\omega}{\\partial t} = S_b + \\nu \\nabla^2 \\omega\n$$\nwhere $\\nu$ is the kinematic viscosity and $S_b$ is the baroclinic source term, defined by the cross product of the density and pressure gradients:\n$$\nS_b = \\frac{\\nabla \\rho \\times \\nabla p}{\\rho^2} = \\frac{1}{\\rho^2} \\left( \\frac{\\partial \\rho}{\\partial x} \\frac{\\partial p}{\\partial y} - \\frac{\\partial \\rho}{\\partial y} \\frac{\\partial p}{\\partial x} \\right)\n$$\nThe problem requires integrating this equation from an initial condition of zero vorticity, $\\omega(x,y,0)=0$, on a doubly periodic square domain of side length $L=2\\pi$, discretized on a uniform $N_x \\times N_y$ grid. The solution must be compared against analytical results or expected zero outcomes for three distinct test cases.\n\nThe numerical implementation adheres to the following principles:\n\n**1. Spatial Discretization: Fourier Pseudospectral Method**\nOn a periodic domain, the Fourier spectral method provides the most accurate means of computing spatial derivatives. A function $f(x,y)$ is represented by its discrete Fourier series coefficients $\\hat{f}(k_x, k_y)$. The spatial derivatives in physical space correspond to algebraic multiplication by the imaginary unit $i$ and the respective wavenumbers in Fourier space. For a field $f$ with Fourier transform $\\hat{f}$, its derivatives and Laplacian are computed via:\n$$\n\\frac{\\partial f}{\\partial x} = \\mathcal{F}^{-1}\\{i k_x \\hat{f}\\} \\quad , \\quad \\frac{\\partial f}{\\partial y} = \\mathcal{F}^{-1}\\{i k_y \\hat{f}\\}\n$$\n$$\n\\nabla^2 f = \\mathcal{F}^{-1}\\{-(k_x^2 + k_y^2) \\hat{f}\\}\n$$\nwhere $\\mathcal{F}^{-1}$ denotes the inverse Fourier transform, and $k_x$, $k_y$ are the discrete wavenumbers. This method is implemented efficiently using the Fast Fourier Transform (FFT) algorithm.\n\n**2. Temporal Integration: 4th-Order Runge-Kutta (RK4) Method**\nThe time evolution is performed using the classic fourth-order explicit Runge-Kutta scheme, which offers a favorable balance of accuracy (fourth-order) and stability for a given time step $\\Delta t$. For an ordinary differential equation of the form $d\\omega/dt = \\mathcal{R}(\\omega)$, a single time step from $\\omega_n$ to $\\omega_{n+1}$ is computed as:\n$$\n\\begin{aligned}\nk_1 &= \\Delta t \\cdot \\mathcal{R}(\\omega_n) \\\\\nk_2 &= \\Delta t \\cdot \\mathcal{R}(\\omega_n + k_1/2) \\\\\nk_3 &= \\Delta t \\cdot \\mathcal{R}(\\omega_n + k_2/2) \\\\\nk_4 &= \\Delta t \\cdot \\mathcal{R}(\\omega_n + k_3) \\\\\n\\omega_{n+1} &= \\omega_n + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\nwhere $\\mathcal{R}(\\omega) = S_b + \\nu \\nabla^2 \\omega$. The time step $\\Delta t$ is chosen to be sufficiently small to ensure both numerical stability, particularly limited by the viscous term $\\nu \\nabla^2 \\omega$ at high wavenumbers, and temporal accuracy.\n\n**3. Field Construction**\nThe static pressure and density fields are constructed as follows:\n-   **Pressure Field:** A periodic pair of smoothed shocks with gradients primarily in the $x$-direction is required. A suitable function that is periodic on $[0, 2\\pi]$ and possesses these features is $p(x,y) = \\frac{\\Delta p}{2} \\tanh(\\frac{\\cos(x)}{\\epsilon})$, where $\\epsilon = 2\\delta/L_x$ is a parameter controlling the shock thickness.\n-   **Density Fields:**\n    -   **Case 1 (Aligned Gradients):** A simple sinusoidal field, $\\rho(x,y) = 1 + A_\\rho \\sin(k_\\rho x)$, with gradients only in the $x$-direction. Since $\\nabla p$ is also only in the $x$-direction, their cross product is zero, yielding $S_b=0$.\n    -   **Case 2 (Misaligned Gradients):** A similar sinusoidal field, but oriented along the $y$-direction, $\\rho(x,y) = 1 + A_\\rho \\sin(k_\\rho y)$. Here, $\\nabla\\rho$ is perpendicular to $\\nabla p$, maximizing the baroclinic source term $S_b$.\n    -   **Case 3 (Turbulent Density):** A field with controlled spectral content is constructed via spectral synthesis. A random real field is generated in physical space, transformed to Fourier space using FFT, and then filtered to retain energy only within an isotropic wavenumber ring defined by $k_0 - \\Delta k \\le |\\boldsymbol{k}| \\le k_0 + \\Delta k$. The resulting filtered spectrum is transformed back to physical space to obtain a turbulent-like density fluctuation field. This field is scaled by the specified amplitude $A_\\rho$ and added to a mean value of $1$ to ensure $\\rho > 0$.\n\n**4. Verification and Metrics**\n-   **Case 1:** Since $S_b=0$ and $\\nu=0$, the equation becomes $\\partial \\omega/\\partial t=0$. With $\\omega(0)=0$, the exact solution is $\\omega(T)=0$. The metric is the $\\ell_2$-norm of the final numerical vorticity, $||\\omega(T)||_2$, which should be close to machine precision.\n-   **Case 2:** With time-independent fields and $\\nu=0$, the equation is $\\partial \\omega/\\partial t = S_b(\\text{const.})$. The exact solution is $\\omega(T) = T \\cdot S_b$. The metric is the relative $\\ell_2$-error between the numerical and exact solutions, $||\\omega_{\\text{num}} - \\omega_{\\text{exact}}||_2 / ||\\omega_{\\text{exact}}||_2$.\n-   **Case 3:** For this case with $\\nu>0$, the governing equation is a linear PDE with a constant source term. Its exact solution in Fourier space is given. For each wavenumber $\\boldsymbol{k}$:\n    $$\n    \\hat{\\omega}(\\boldsymbol{k}, T) = \\begin{cases} \\hat{S}_b(\\boldsymbol{k}) \\frac{1 - e^{-\\nu |\\boldsymbol{k}|^2 T}}{\\nu |\\boldsymbol{k}|^2} & \\text{if } |\\boldsymbol{k}| \\neq 0 \\\\ T \\cdot \\hat{S}_b(\\boldsymbol{k}) & \\text{if } |\\boldsymbol{k}| = 0 \\end{cases}\n    $$\n    The exact solution in physical space, $\\omega_{\\text{exact}}(T)$, is found by taking the inverse Fourier transform of $\\hat{\\omega}(\\boldsymbol{k}, T)$. The metric is again the relative $\\ell_2$-error between the numerical and exact solutions.\n\nThe provided Python program implements these steps, processing each test case to compute and report the specified quantitative metric.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the baroclinic vorticity verification problem for three test cases.\n    \"\"\"\n    test_cases_params = [\n        {'case_id': 1, 'N': 64, 'L': 2 * np.pi, 'nu': 0.0, 'T': 0.20, 'delta_rel': 0.05, 'dp': 1.0, 'a_rho': 0.1, 'k_rho': 4},\n        {'case_id': 2, 'N': 64, 'L': 2 * np.pi, 'nu': 0.0, 'T': 0.15, 'delta_rel': 0.05, 'dp': 1.0, 'a_rho': 0.1, 'k_rho': 5},\n        {'case_id': 3, 'N': 64, 'L': 2 * np.pi, 'nu': 0.01, 'T': 0.20, 'delta_rel': 0.05, 'dp': 1.0, 'a_rho': 0.1, 'k0': 8, 'dk': 1},\n    ]\n\n    results = []\n    n_steps = 1000  # Fixed number of time steps for stability and accuracy\n\n    for params in test_cases_params:\n        # 1. Setup Grid and Wavenumbers\n        N = params['N']\n        L = params['L']\n        dx = L / N\n        x_1d = np.arange(N) * dx\n        x, y = np.meshgrid(x_1d, x_1d, indexing='ij')\n\n        k_1d = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n        kx, ky = np.meshgrid(k_1d, k_1d, indexing='ij')\n        k_sq = kx**2 + ky**2\n\n        # 2. Define Spectral Derivative Utilities\n        def grad(f_field):\n            f_hat = np.fft.fft2(f_field)\n            dfdx = np.fft.ifft2(1j * kx * f_hat).real\n            dfdy = np.fft.ifft2(1j * ky * f_hat).real\n            return dfdx, dfdy\n\n        def laplacian(f_field):\n            f_hat = np.fft.fft2(f_field)\n            return np.fft.ifft2(-k_sq * f_hat).real\n\n        # 3. Construct Initial Density and Pressure Fields\n        dp = params['dp']\n        delta_param = 2 * params['delta_rel']\n        p = (dp / 2.0) * np.tanh(np.cos(x) / delta_param)\n\n        if params['case_id'] == 1:\n            rho = 1.0 + params['a_rho'] * np.sin(params['k_rho'] * x)\n        elif params['case_id'] == 2:\n            rho = 1.0 + params['a_rho'] * np.sin(params['k_rho'] * y)\n        else:  # Case 3\n            k0, dk, a_rho = params['k0'], params['dk'], params['a_rho']\n            np.random.seed(42)  # For reproducibility\n\n            k_mag = np.sqrt(k_sq)\n            filter_mask = (k_mag >= k0 - dk) & (k_mag <= k0 + dk)\n            \n            # Generate a random real field, FFT, filter, then IFFT\n            rand_field = np.random.randn(N, N)\n            rand_hat = np.fft.fft2(rand_field)\n            \n            rho_hat_filtered = rand_hat * filter_mask\n            delta_rho = np.fft.ifft2(rho_hat_filtered).real\n            delta_rho -= np.mean(delta_rho) # Ensure zero mean fluctuation\n            \n            # Scale to specified peak amplitude\n            max_abs_val = np.max(np.abs(delta_rho))\n            if max_abs_val > 1e-9:\n                delta_rho *= a_rho / max_abs_val\n            \n            rho = 1.0 + delta_rho\n\n        # 4. Compute Baroclinic Source Term\n        rho_dx, rho_dy = grad(rho)\n        p_dx, p_dy = grad(p)\n        S_b = (rho_dx * p_dy - rho_dy * p_dx) / rho**2\n\n        # 5. Time Integration (RK4)\n        omega = np.zeros((N, N))\n        T, nu = params['T'], params['nu']\n        dt = T / n_steps\n\n        def rhs(w):\n            return S_b + nu * laplacian(w)\n\n        for _ in range(n_steps):\n            k1 = dt * rhs(omega)\n            k2 = dt * rhs(omega + 0.5 * k1)\n            k3 = dt * rhs(omega + 0.5 * k2)\n            k4 = dt * rhs(omega + k3)\n            omega += (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n            \n        # 6. Calculate and Store Result Metric\n        if params['case_id'] == 1:\n            result = np.linalg.norm(omega)\n        elif params['case_id'] == 2:\n            omega_analytic = T * S_b\n            error_norm = np.linalg.norm(omega - omega_analytic)\n            analytic_norm = np.linalg.norm(omega_analytic)\n            result = error_norm / analytic_norm if analytic_norm > 1e-12 else error_norm\n        else: # Case 3\n            S_b_hat = np.fft.fft2(S_b)\n            omega_hat_analytic = np.zeros_like(S_b_hat)\n            \n            # Non-zero k modes\n            non_zero_k_mask = k_sq > 1e-12\n            k_sq_nz = k_sq[non_zero_k_mask]\n            \n            term = nu * k_sq_nz\n            factor = (1.0 - np.exp(-term * T)) / term\n            \n            omega_hat_analytic[non_zero_k_mask] = S_b_hat[non_zero_k_mask] * factor\n            \n            # Zero k mode (k=0)\n            omega_hat_analytic[0, 0] = S_b_hat[0, 0] * T\n            \n            omega_analytic = np.fft.ifft2(omega_hat_analytic).real\n            \n            error_norm = np.linalg.norm(omega - omega_analytic)\n            analytic_norm = np.linalg.norm(omega_analytic)\n            result = error_norm / analytic_norm if analytic_norm > 1e-12 else error_norm\n\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "The Rayleigh-Taylor instability is a classical problem in fluid dynamics, but simulating its slow, buoyancy-driven growth using compressible solvers at low Mach numbers presents a significant numerical challenge due to the stiffness created by fast acoustic waves. This exercise uses a simplified, reduced-order model to explore how low-Mach number preconditioning addresses this issue by effectively modifying the acoustic timescale. By deriving and comparing the instability growth rates, you will gain a concrete understanding of how this advanced numerical technique enables efficient and accurate simulations of nearly-incompressible phenomena .",
            "id": "3361543",
            "problem": "You are tasked with constructing a mathematically consistent, low-cost model problem that captures the onset growth of the Rayleigh–Taylor interfacial instability at low Mach number and uses it to examine the regime of validity of a preconditioning strategy for compressible solvers. The focus is on a linear, single-mode setting that is universal in the sense that it requires only fundamental laws and clear assumptions, and is implementable in any programming language.\n\nConsider two immiscible, inviscid fluids in a uniform gravitational field with constant gravitational acceleration $g$ in $\\mathrm{m/s^2}$, heavy fluid on top of light fluid. Let the densities be $\\rho_h$ and $\\rho_\\ell$ with $\\rho_h > \\rho_\\ell$, and define the Atwood number $A = (\\rho_h - \\rho_\\ell)/(\\rho_h + \\rho_\\ell)$ (dimensionless). Assume small-amplitude, single-Fourier-mode perturbations of the initially flat interface with wavenumber $k$ in $\\mathrm{m^{-1}}$, and adopt periodicity in the horizontal direction and potential-flow kinematics consistent with the linear stage. The Mach number $M$ (dimensionless) is defined with respect to a reference velocity scale and the sound speed as described below.\n\nStarting point and modeling assumptions:\n- Begin from the compressible Euler equations with gravity (mass and momentum conservation) and the isentropic relation $p' = c^2 \\rho'$ for perturbations, where $c$ is the sound speed. Adopt the low-amplitude, single-mode linearization in which all fields vary as $\\exp(i k x)$ in the horizontal direction and evolve in time.\n- In the incompressible limit with negligible density variation in the inertia (the Boussinesq approximation), the interfacial displacement amplitude $\\eta(t)$ satisfies a second-order ordinary differential equation of the form $\\mathrm{d}^2 \\eta/\\mathrm{d} t^2 = \\mathcal{L}_I \\eta$, where the operator $\\mathcal{L}_I$ is determined by $A$, $g$ and $k$ and leads to exponential growth with some rate $\\sigma_I$ in $\\mathrm{s^{-1}}$.\n- To model finite compressibility in a way consistent with the low-Mach regime and the presence of fast acoustic scales, introduce a minimal linear three-variable system for the interface amplitude $\\eta(t)$, the interfacial vertical velocity amplitude $w(t)$, and a modal pressure-gradient-like amplitude $q(t)$ that relaxes to the buoyancy forcing. In this model, the compressible solver is represented by the linear system\n  1) $\\mathrm{d}\\eta/\\mathrm{d}t = w$,\n  2) $\\mathrm{d}w/\\mathrm{d}t = k\\, q$,\n  3) $\\mathrm{d}q/\\mathrm{d}t = -\\left(q - g A \\eta\\right)/\\tau_a$,\n  where $\\tau_a$ is a relaxation time scale that represents the time needed for acoustic communication across a wavelength $2\\pi/k$. This $\\tau_a$ must be chosen from first principles using a sound speed and a preconditioning factor as described below.\n\nDefinition of reference scales and Mach number:\n- Let the incompressible linear growth rate (to be derived by you from the above incompressible model) be $\\sigma_I = \\sqrt{A g k}$ in $\\mathrm{s^{-1}}$. Define a reference velocity scale by $U_{\\mathrm{ref}} = \\sigma_I / k$ in $\\mathrm{m/s}$, which is the natural interface vertical velocity scale for unit amplitude growth.\n- Given a dimensionless Mach number $M$, define the sound speed by $c = U_{\\mathrm{ref}} / M$ in $\\mathrm{m/s}$. This makes $M$ the ratio $U_{\\mathrm{ref}}/c$.\n- Define a preconditioning factor $\\theta$ that scales the effective acoustic speed as $c_{\\mathrm{eff}} = \\theta\\, c$. Consider two cases:\n  - Unpreconditioned compressible model (physical acoustics): $\\theta = 1$.\n  - Preconditioned compressible model (low-Mach preconditioning intended to accelerate acoustic communication): $\\theta = 1/M$ for $M \\le 1$ and $\\theta = 1$ for $M > 1$. This choice reduces the acoustic relaxation time by a factor of $M$ when $M \\ll 1$.\n- With $c_{\\mathrm{eff}}$ defined as above, set the acoustic relaxation time to $\\tau_a = 1/(k\\, c_{\\mathrm{eff}})$ in $\\mathrm{s}$.\n\nTasks:\n1) From the incompressible model, derive the growth rate $\\sigma_I$ that emerges from the second-order differential equation governing $\\eta(t)$. Express $\\sigma_I$ in terms of $A$, $g$ and $k$, in $\\mathrm{s^{-1}}$.\n2) From the compressible three-variable linear system, derive the dispersion relation for exponential solutions of the form $\\eta(t) \\sim \\exp(\\sigma t)$, and compute the unstable growth rate $\\sigma_C$ in $\\mathrm{s^{-1}}$ as a function of $A$, $g$, $k$, $M$, and the preconditioning factor $\\theta$ through $\\tau_a$. Your solver must robustly select the real root with the largest positive real part when multiple roots exist.\n3) Use the above to implement a program that, for each test case, computes and reports:\n   - The incompressible growth rate $\\sigma_I$ (in $\\mathrm{s^{-1}}$),\n   - The compressible preconditioned growth rate $\\sigma_C$ with $\\theta$ as specified (in $\\mathrm{s^{-1}}$),\n   - The compressible unpreconditioned growth rate $\\sigma_C$ with $\\theta = 1$ (in $\\mathrm{s^{-1}}$).\n   All reported values must be in $\\mathrm{s^{-1}}$ and rounded to six decimal places.\n\nTest suite:\nUse the following four test cases, each specified as a tuple $(A, g, k, M)$ with units as indicated above.\n- Case 1 (happy path, low Mach): $(0.5,\\; 9.81,\\; 10.0,\\; 0.05)$\n- Case 2 (very low Mach): $(0.5,\\; 9.81,\\; 10.0,\\; 0.001)$\n- Case 3 (near-stable small Atwood): $(1.0\\times 10^{-6},\\; 9.81,\\; 10.0,\\; 0.1)$\n- Case 4 (moderate Mach, long wave): $(0.5,\\; 9.81,\\; 1.0,\\; 0.3)$\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the twelve numbers corresponding to the four cases, in this exact order: for each case, output the three numbers $[\\sigma_I,\\; \\sigma_{C,\\mathrm{pre}},\\; \\sigma_{C,\\mathrm{unpre}}]$ in $\\mathrm{s^{-1}}$, each rounded to six decimal places, and then flatten the four triplets into a single list. For example, a valid output has the form\n\"[sigmaI_case1,sigmaCpre_case1,sigmaCun_case1,sigmaI_case2,sigmaCpre_case2,sigmaCun_case2,sigmaI_case3,sigmaCpre_case3,sigmaCun_case3,sigmaI_case4,sigmaCpre_case4,sigmaCun_case4]\".",
            "solution": "The problem is to construct and analyze a simplified model for the Rayleigh–Taylor instability to study the effect of a low-Mach number preconditioning scheme. The analysis involves deriving the instability growth rates for an incompressible reference case and for a compressible model, both with and without preconditioning.\n\n**Part 1: Incompressible Growth Rate ($\\sigma_I$)**\n\nThe problem states that in the incompressible Boussinesq limit, the interface displacement amplitude, $\\eta(t)$, is governed by a second-order ordinary differential equation (ODE) of the form $\\mathrm{d}^2 \\eta/\\mathrm{d} t^2 = \\mathcal{L}_I \\eta$, where $\\mathcal{L}_I$ is a linear operator dependent on the Atwood number $A$, gravitational acceleration $g$, and perturbation wavenumber $k$.\n\nTo determine the operator $\\mathcal{L}_I$, we can examine the provided three-variable compressible model in the limit of infinitely fast acoustic communication. The model is:\n1) $\\mathrm{d}\\eta/\\mathrm{d}t = w$\n2) $\\mathrm{d}w/\\mathrm{d}t = k\\, q$\n3) $\\mathrm{d}q/\\mathrm{d}t = -\\left(q - g A \\eta\\right)/\\tau_a$\n\nThe incompressible limit corresponds to an infinitely fast adjustment of the pressure field, which is modeled by the relaxation time $\\tau_a \\to 0$. In this limit, the third equation implies that the term in the parenthesis must be zero for $\\mathrm{d}q/\\mathrm{d}t$ to remain finite. Thus, we have the equilibrium condition:\n$$ q(t) = g A \\eta(t) $$\nSubstituting this into the second equation yields:\n$$ \\frac{\\mathrm{d}w}{\\mathrm{d}t} = k (g A \\eta) = A g k \\eta $$\nFrom the first equation, we have $w = \\mathrm{d}\\eta/\\mathrm{d}t$. Differentiating this with respect to time gives $\\mathrm{d}w/\\mathrm{d}t = \\mathrm{d}^2\\eta/\\mathrm{d}t^2$. Combining these results, we obtain the second-order ODE for $\\eta(t)$:\n$$ \\frac{\\mathrm{d}^2\\eta}{\\mathrm{d}t^2} = A g k \\eta $$\nComparing this to the generic form $\\mathrm{d}^2 \\eta/\\mathrm{d} t^2 = \\mathcal{L}_I \\eta$, we identify the operator $\\mathcal{L}_I$ as multiplication by the constant $A g k$. To find the growth rate, we assume a solution of the form $\\eta(t) \\propto \\exp(\\sigma_I t)$. Substituting this into the ODE gives the characteristic equation:\n$$ \\sigma_I^2 = A g k $$\nThe Rayleigh–Taylor instability corresponds to the exponentially growing solution, so we take the positive root. This yields the classical incompressible growth rate:\n$$ \\sigma_I = \\sqrt{A g k} $$\nThis completes the derivation for Task 1, confirming the formula provided in the problem statement.\n\n**Part 2: Compressible Growth Rate ($\\sigma_C$)**\n\nFor a finite acoustic relaxation time $\\tau_a$, we must solve the full three-variable linear system. We assume exponential solutions for all three variables:\n$$ \\eta(t) = \\eta_0 e^{\\sigma t}, \\quad w(t) = w_0 e^{\\sigma t}, \\quad q(t) = q_0 e^{\\sigma t} $$\nwhere $\\sigma$ is the complex growth rate to be determined. Substituting these into the system of ODEs gives an algebraic system for the amplitudes $(\\eta_0, w_0, q_0)$:\n1) $\\sigma \\eta_0 = w_0$\n2) $\\sigma w_0 = k q_0$\n3) $\\sigma q_0 = -\\left(q_0 - g A \\eta_0\\right)/\\tau_a$\n\nThis can be written as a homogeneous linear system. A more direct route is to derive a single third-order ODE for $\\eta(t)$. Starting from $\\eta(t)$, we can express $w(t)$ and $q(t)$ and their derivatives in terms of $\\eta(t)$ and its derivatives:\n$$ w = \\frac{\\mathrm{d}\\eta}{\\mathrm{d}t} $$\n$$ q = \\frac{1}{k}\\frac{\\mathrm{d}w}{\\mathrm{d}t} = \\frac{1}{k}\\frac{\\mathrm{d}^2\\eta}{\\mathrm{d}t^2} $$\n$$ \\frac{\\mathrm{d}q}{\\mathrm{d}t} = \\frac{1}{k}\\frac{\\mathrm{d}^3\\eta}{\\mathrm{d}t^3} $$\nSubstitute these expressions into the third ODE:\n$$ \\frac{1}{k}\\frac{\\mathrm{d}^3\\eta}{\\mathrm{d}t^3} = -\\frac{1}{\\tau_a}\\left(\\frac{1}{k}\\frac{\\mathrm{d}^2\\eta}{\\mathrm{d}t^2} - g A \\eta \\right) $$\nMultiplying by $k$ and rearranging terms, we get:\n$$ \\frac{\\mathrm{d}^3\\eta}{\\mathrm{d}t^3} + \\frac{1}{\\tau_a}\\frac{\\mathrm{d}^2\\eta}{\\mathrm{d}t^2} - \\frac{A g k}{\\tau_a} \\eta = 0 $$\nAssuming the solution $\\eta(t) \\propto \\exp(\\sigma t)$, we obtain the characteristic equation (or dispersion relation) for the compressible growth rate $\\sigma$:\n$$ \\sigma^3 + \\frac{1}{\\tau_a}\\sigma^2 - \\frac{A g k}{\\tau_a} = 0 $$\nUsing $\\sigma_I^2 = A g k$, this simplifies to:\n$$ \\sigma^3 + \\frac{1}{\\tau_a}\\sigma^2 - \\frac{\\sigma_I^2}{\\tau_a} = 0 $$\nAnalysis of this cubic polynomial reveals that it has exactly one positive real root, which corresponds to the physical Rayleigh-Taylor instability growth rate, $\\sigma_C$.\n\nThe relaxation time $\\tau_a$ is defined as $\\tau_a = 1/(k c_{\\mathrm{eff}})$, where $c_{\\mathrm{eff}} = \\theta c$, $c = U_{\\mathrm{ref}} / M$, and $U_{\\mathrm{ref}} = \\sigma_I/k$. Substituting these definitions yields:\n$$ \\frac{1}{\\tau_a} = k c_{\\mathrm{eff}} = k (\\theta c) = k \\theta \\frac{U_{\\mathrm{ref}}}{M} = k \\theta \\frac{\\sigma_I/k}{M} = \\frac{\\theta \\sigma_I}{M} $$\nSubstituting this into the characteristic equation gives:\n$$ \\sigma^3 + \\left(\\frac{\\theta \\sigma_I}{M}\\right)\\sigma^2 - \\left(\\frac{\\theta \\sigma_I}{M}\\right)\\sigma_I^2 = 0 $$\nTo simplify, we non-dimensionalize the growth rate by defining $\\hat{\\sigma} = \\sigma / \\sigma_I$. We also define a dimensionless parameter $\\alpha = \\theta/M$. The equation becomes:\n$$ (\\hat{\\sigma}\\sigma_I)^3 + \\alpha \\sigma_I (\\hat{\\sigma}\\sigma_I)^2 - \\alpha \\sigma_I \\sigma_I^2 = 0 $$\nDividing by $\\sigma_I^3$:\n$$ \\hat{\\sigma}^3 + \\alpha \\hat{\\sigma}^2 - \\alpha = 0 $$\nThis is the final non-dimensional equation for the scaled growth rate $\\hat{\\sigma}$. For any given test case, we compute the parameter $\\alpha$ and solve this cubic equation for its unique positive real root, $\\hat{\\sigma}_C$. The physical compressible growth rate is then $\\sigma_C = \\hat{\\sigma}_C \\sigma_I$.\n\n**Part 3: Implementation Strategy**\n\nThe program will implement the following steps for each test case $(A, g, k, M)$:\n1.  Calculate the incompressible growth rate $\\sigma_I = \\sqrt{A g k}$.\n2.  For the **preconditioned** case:\n    a. Determine the preconditioning factor $\\theta_{pre} = 1/M$ (since all test cases have $M \\le 1$).\n    b. Compute the parameter $\\alpha_{pre} = \\theta_{pre}/M = 1/M^2$.\n    c. Solve the cubic equation $\\hat{\\sigma}^3 + \\alpha_{pre} \\hat{\\sigma}^2 - \\alpha_{pre} = 0$ for the positive real root $\\hat{\\sigma}_{C,pre}$.\n    d. Calculate the growth rate $\\sigma_{C,pre} = \\hat{\\sigma}_{C,pre} \\sigma_I$.\n3.  For the **unpreconditioned** case:\n    a. The factor is $\\theta_{unpre} = 1$.\n    b. Compute the parameter $\\alpha_{unpre} = \\theta_{unpre}/M = 1/M$.\n    c. Solve the cubic equation $\\hat{\\sigma}^3 + \\alpha_{unpre} \\hat{\\sigma}^2 - \\alpha_{unpre} = 0$ for the positive real root $\\hat{\\sigma}_{C,unpre}$.\n    d. Calculate the growth rate $\\sigma_{C,unpre} = \\hat{\\sigma}_{C,unpre} \\sigma_I$.\n4.  The three values $(\\sigma_I, \\sigma_{C,pre}, \\sigma_{C,unpre})$ are then formatted and collected.\n\nThe roots of the cubic polynomial are found numerically. A standard numerical library routine can find all three complex roots. The desired root is identified by its properties: being real (within a small numerical tolerance) and positive.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Rayleigh-Taylor instability growth rate problem for the specified test cases.\n    \"\"\"\n    \n    # Test cases: tuples of (A, g, k, M)\n    test_cases = [\n        (0.5, 9.81, 10.0, 0.05),     # Case 1\n        (0.5, 9.81, 10.0, 0.001),    # Case 2\n        (1.0e-6, 9.81, 10.0, 0.1),    # Case 3\n        (0.5, 9.81, 1.0, 0.3)       # Case 4\n    ]\n\n    results = []\n\n    def get_compressible_rate(alpha, sigma_I):\n        \"\"\"\n        Solves the non-dimensional cubic equation for the growth rate.\n        \n        The equation is: hat_sigma^3 + alpha * hat_sigma^2 - alpha = 0.\n        \n        Args:\n            alpha (float): The dimensionless parameter alpha = theta/M.\n            sigma_I (float): The incompressible growth rate.\n        \n        Returns:\n            float: The compressible growth rate sigma_C.\n        \"\"\"\n        # Coefficients of the polynomial p(x) = x^3 + alpha*x^2 + 0*x - alpha\n        coeffs = [1, alpha, 0, -alpha]\n        roots = np.roots(coeffs)\n        \n        # We need the unique positive real root.\n        # It's guaranteed to exist and be unique.\n        # We filter for it by checking for a positive real part and negligible imaginary part.\n        positive_real_root = None\n        for r in roots:\n            if r.real > 0 and np.abs(r.imag) < 1e-9:\n                positive_real_root = r.real\n                break\n        \n        if positive_real_root is None:\n            # This case should not be reached based on the analysis.\n            # Handle as an error if it occurs.\n            raise ValueError(\"Could not find a positive real root.\")\n            \n        hat_sigma_C = positive_real_root\n        sigma_C = hat_sigma_C * sigma_I\n        return sigma_C\n\n    for case in test_cases:\n        A, g, k, M = case\n        \n        # 1. Calculate the incompressible growth rate sigma_I\n        sigma_I = np.sqrt(A * g * k)\n        \n        # --- Preconditioned Case ---\n        # Determine preconditioning factor theta\n        theta_pre = 1.0 / M if M <= 1.0 else 1.0\n        # Calculate alpha parameter\n        alpha_pre = theta_pre / M\n        # Calculate compressible growth rate\n        sigma_C_pre = get_compressible_rate(alpha_pre, sigma_I)\n        \n        # --- Unpreconditioned Case ---\n        # Theta is 1\n        theta_unpre = 1.0\n        # Calculate alpha parameter\n        alpha_unpre = theta_unpre / M\n        # Calculate compressible growth rate\n        sigma_C_unpre = get_compressible_rate(alpha_unpre, sigma_I)\n        \n        # Append results for the current case\n        results.append(sigma_I)\n        results.append(sigma_C_pre)\n        results.append(sigma_C_unpre)\n\n    # Format the results to exactly six decimal places for the final output string.\n    results_str = [\"{:.6f}\".format(r) for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Beyond single-mode instabilities, understanding the full response of a turbulent field to a shock wave is crucial for many engineering and astrophysical applications. This practice delves into the modeling of shock-turbulence interaction within a large-eddy simulation (LES) framework, focusing on the amplification of turbulent kinetic energy and the generation of Reynolds stress anisotropy. You will develop and calibrate a reduced-order algebraic model by using theoretical targets from rapid-distortion theory, providing a direct look at how fundamental physics informs the practical construction of advanced turbulence models .",
            "id": "3361602",
            "problem": "You are to implement a self-contained, reduced-order, compressible large-eddy simulation (LES) response model for homogeneous isotropic turbulence impinging on a planar, stationary, normal shock at upstream Mach number $M_s$. The goal is to compute the amplification of turbulent kinetic energy $k$ and the anisotropy tensor $a_{ij}$ across the shock as functions of $M_s$, using three different shock sensors. The model constants are to be calibrated by matching Reynolds stress jump conditions derived from conservation laws across the shock in the linear (rapid-distortion) limit. All outputs must be dimensionless floats.\n\nStart from the following fundamental base:\n\n- The compressible Navier–Stokes equations with the ideal gas law and the Rankine–Hugoniot jump conditions across a stationary planar normal shock. For an ideal gas with ratio of specific heats $\\gamma$, the exact mean jump for the density ratio is\n$$\n\\eta \\equiv \\frac{\\rho_2}{\\rho_1} = \\frac{(\\gamma+1) M_s^2}{(\\gamma-1) M_s^2 + 2},\n$$\nand the exact mean jump for the static pressure ratio is\n$$\n\\Pi \\equiv \\frac{p_2}{p_1} = 1 + \\frac{2\\gamma}{\\gamma+1}\\left(M_s^2 - 1\\right).\n$$\nAssume $\\gamma = 1.4$.\n\n- Use Favre (density-weighted) averaging for mean quantities and standard Reynolds decomposition for fluctuations. Let the upstream turbulence be homogeneous and isotropic with upstream turbulent kinetic energy $k_1$ and the upstream Reynolds stress\n$$\nR_{ij,1} = \\overline{u_i' u_j'} = \\frac{2}{3} k_1 \\delta_{ij},\n$$\nwhere $u_i'$ are velocity fluctuations and $\\delta_{ij}$ is the Kronecker delta. Set $k_1 = 1$ for normalization, so all outputs are dimensionless.\n\n- Define the downstream Reynolds stress $R_{ij,2}$ via a component-wise jump model with normal and tangential multipliers:\n$$\nR_{11,2} = C_n \\, R_{11,1}, \\quad R_{22,2} = C_t \\, R_{22,1}, \\quad R_{33,2} = C_t \\, R_{33,1}.\n$$\nDefine the downstream turbulent kinetic energy $k_2 = \\frac{1}{2}(R_{11,2} + R_{22,2} + R_{33,2})$, its amplification $A_k \\equiv k_2/k_1$, and the downstream anisotropy tensor\n$$\na_{ij} = \\frac{R_{ij,2}}{2 k_2} - \\frac{1}{3}\\delta_{ij}.\n$$\n\n- Model $C_n$ and $C_t$ using a shock-sensor-weighted algebraic response with two unknown constants $C_1$ and $C_2$:\n$$\ns \\equiv g_s \\, (\\eta - 1), \\quad C_n = 1 + C_1 s + C_2 s^2, \\quad C_t = 1 + \\frac{1}{2} C_1 s + \\frac{1}{4} C_2 s^2,\n$$\nwhere $g_s \\in [0,1]$ is the output of a chosen shock sensor (defined below). The factorization between $C_n$ and $C_t$ encodes axisymmetric distortion about the shock normal.\n\n- Calibrate $(C_1, C_2)$ by enforcing Reynolds stress jump conditions derived from linearized conservation across a planar normal shock in the rapid-distortion limit. Use the following target component ratios as the calibration objectives:\n$$\nC_n^{\\text{target}}(\\eta) = \\eta^{-2}, \\qquad C_t^{\\text{target}}(\\eta) = \\eta,\n$$\nwhich represent, respectively, normal-component reduction by mass-flux continuity and tangential-component amplification by mean compressive rapid distortion integrated through the shock. Determine $(C_1, C_2)$ by minimizing the sum of squared residuals\n$$\nJ(C_1,C_2) = \\sum_{M_s \\in \\mathcal{S}_{\\text{cal}}} \\left[ \\left(C_n(M_s) - C_n^{\\text{target}}(\\eta(M_s))\\right)^2 + \\left(C_t(M_s) - C_t^{\\text{target}}(\\eta(M_s))\\right)^2 \\right],\n$$\nover the calibration set $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ with a fixed calibration filter-to-shock thickness ratio $\\Delta/\\delta = 1$. Because $C_n$ and $C_t$ are linear functions of $C_1$ and $C_2$ when shifted by $1$, this is a linear least-squares problem in $(C_1, C_2)$.\n\n- Implement three shock sensors to compute $g_s$:\n  1. Density-gradient sensor $g_\\rho$: model the shock as a $\\tanh$ profile with thickness $\\delta$, and a grid filter width $\\Delta$. Let\n  $$\n  g_\\rho = \\tanh\\!\\left( \\alpha_\\rho \\, (\\eta - 1)\\, \\frac{\\Delta}{\\delta} \\right),\n  $$\n  with $\\alpha_\\rho = 0.75$.\n  2. Pressure-based sensor $g_p$: use the pressure jump,\n  $$\n  g_p = \\tanh\\!\\left( \\alpha_p \\, (\\Pi - 1)\\, \\frac{\\Delta}{\\delta} \\right),\n  $$\n  with $\\alpha_p = 0.50$.\n  3. Ducros-type sensor $g_D$: use a compressive indicator proportional to $M_s^2$,\n  $$\n  g_D = \\tanh\\!\\left( \\alpha_D \\, M_s^2 \\, \\frac{\\Delta}{\\delta} \\right),\n  $$\n  with $\\alpha_D = 0.35$.\n\nWorkflow to implement:\n\n- For a given ($M_s, \\delta/\\Delta, \\text{sensor}$), compute $\\eta(M_s)$ and $\\Pi(M_s)$ from the Rankine–Hugoniot formulas with $\\gamma = 1.4$. Compute $\\Delta/\\delta = 1/(\\delta/\\Delta)$.\n\n- For each sensor, first calibrate $(C_1, C_2)$ by solving the linear least-squares problem defined above using the calibration set $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ with $\\Delta/\\delta = 1$ (so $\\delta/\\Delta = 1$). Use the sensor-specific $g_s$ in the definitions of $s$ at each calibration $M_s$.\n\n- With the calibrated $(C_1, C_2)$ for the chosen sensor, evaluate $C_n$ and $C_t$ at the requested ($M_s, \\delta/\\Delta, \\text{sensor}$), then compute $A_k$ and $a_{11}$ for $k_1 = 1$ and $R_{ij,1} = \\frac{2}{3} \\delta_{ij}$.\n\nNumerical and implementation details:\n\n- Use $\\gamma = 1.4$ and $k_1 = 1$. All quantities are dimensionless.\n\n- The test suite consists of the following three cases, which you must evaluate in order:\n  - Case $1$: $(M_s, \\delta/\\Delta, \\text{sensor}) = (1.05, 2.0, \\text{density})$ with the density-gradient sensor $g_\\rho$.\n  - Case $2$: $(M_s, \\delta/\\Delta, \\text{sensor}) = (1.5, 1.0, \\text{pressure})$ with the pressure-based sensor $g_p$.\n  - Case $3$: $(M_s, \\delta/\\Delta, \\text{sensor}) = (3.0, 0.25, \\text{ducros})$ with the Ducros-type sensor $g_D$.\n\n- For each case, produce two outputs: the turbulent kinetic energy amplification $A_k$ and the normal-component anisotropy $a_{11}$, both as dimensionless floats rounded to six digits after the decimal point.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$$\n[A_k^{(1)}, a_{11}^{(1)}, A_k^{(2)}, a_{11}^{(2)}, A_k^{(3)}, a_{11}^{(3)}].\n$$\nNo other text should be printed. All outputs must be dimensionless floats rounded to six decimals.",
            "solution": "We construct a principled, reduced-order model that captures the essential physics of shock–turbulence interaction for homogeneous isotropic turbulence in the limit of small-scale rapid distortion. We begin from conservation laws and standard decompositions, then formulate a calibration against Reynolds stress jump relations, and finally define an algorithm that is implementable as a short numerical program.\n\nBase equations and definitions:\n\n- For a stationary planar normal shock in an ideal gas with ratio of specific heats $\\gamma$, the Rankine–Hugoniot jump conditions for the mean fields yield the exact density and pressure ratios:\n$$\n\\eta(M_s) = \\frac{\\rho_2}{\\rho_1} = \\frac{(\\gamma+1) M_s^2}{(\\gamma-1) M_s^2 + 2}, \\quad\n\\Pi(M_s) = \\frac{p_2}{p_1} = 1 + \\frac{2\\gamma}{\\gamma+1}\\left(M_s^2 - 1\\right).\n$$\n\n- The upstream flow is homogeneous and isotropic with upstream turbulent kinetic energy $k_1$, and Reynolds stress\n$$\nR_{ij,1} = \\overline{u_i' u_j'} = \\frac{2}{3} k_1 \\delta_{ij}.\n$$\nWe set $k_1 = 1$ so that $R_{ij,1} = \\frac{2}{3} \\delta_{ij}$. The downstream stress is modeled with component multipliers $C_n$ (normal) and $C_t$ (tangential):\n$$\nR_{11,2} = C_n \\, R_{11,1}, \\quad R_{22,2} = R_{33,2} = C_t \\, R_{22,1}.\n$$\nThen the downstream turbulent kinetic energy is $k_2 = \\frac{1}{2}(R_{11,2} + R_{22,2} + R_{33,2})$, and the amplification is $A_k \\equiv k_2/k_1$. The anisotropy tensor is $a_{ij} = \\frac{R_{ij,2}}{2k_2} - \\frac{1}{3}\\delta_{ij}$, from which we will extract $a_{11}$.\n\nRapid-distortion-based jump targets:\n\n- For a planar shock aligned with the $x$-axis ($x$ is the shock-normal direction), we consider a small control volume straddling the shock and linearize the conservation of mass and momentum for perturbations. Mass-flux continuity suggests that normal velocity perturbations scale inversely with increases in density across the discontinuity, $u_n' \\to u_n'/\\eta$, assuming the shock thickness is negligible compared with the turbulent scales and neglecting density perturbations within the vanishingly thin discontinuity itself. Squaring the amplitude implies the variance of the normal component scales as $1/\\eta^2$. Hence for the normal component we target\n$$\nC_n^{\\text{target}}(\\eta) = \\eta^{-2}.\n$$\n\n- Tangential components are affected by compressive mean rapid distortion. In rapid-distortion theory for planar compression, the tangential components experience amplification proportional to the compression factor integrated through the shock. For an axisymmetric distortion about the normal, the tangential variance grows proportionally to the density increase (reflecting the contraction of material surfaces and concomitant amplification of tangential gradients), yielding\n$$\nC_t^{\\text{target}}(\\eta) = \\eta.\n$$\nThis pair of targets is consistent with conservation of mass (for the normal component) and compressive rapid distortion (for tangential components) in the linear limit and has been widely invoked as a first-order approximation in shock–turbulence interaction models.\n\nAlgebraic response model:\n\n- We introduce a sensor-weighted algebraic model for the component multipliers with two unknown constants $C_1$ and $C_2$:\n$$\ns \\equiv g_s (\\eta - 1), \\quad\nC_n = 1 + C_1 s + C_2 s^2, \\quad\nC_t = 1 + \\frac{1}{2} C_1 s + \\frac{1}{4} C_2 s^2.\n$$\nHere $g_s \\in [0,1]$ is a shock sensor. The specific forms for $C_n$ and $C_t$ enforce axisymmetric distortion about the shock normal and ensure $C_n, C_t \\to 1$ as $s \\to 0$ (no shock or fully under-resolved shock).\n\nShock sensors:\n\n- We require three sensors $g_s$ that monotonically increase with shock strength and resolution ($\\Delta/\\delta$), where $\\Delta$ is the grid filter width and $\\delta$ is the shock thickness. Noting that the maximum gradient of a $\\tanh$ profile scales as $1/\\delta$, we define:\n  1. Density-gradient sensor:\n  $$\n  g_\\rho = \\tanh\\!\\left( \\alpha_\\rho \\, (\\eta - 1) \\frac{\\Delta}{\\delta} \\right), \\quad \\alpha_\\rho = 0.75.\n  $$\n  2. Pressure-based sensor:\n  $$\n  g_p = \\tanh\\!\\left( \\alpha_p \\, (\\Pi - 1) \\frac{\\Delta}{\\delta} \\right), \\quad \\alpha_p = 0.50.\n  $$\n  3. Ducros-type compressive sensor:\n  $$\n  g_D = \\tanh\\!\\left( \\alpha_D \\, M_s^2 \\frac{\\Delta}{\\delta} \\right), \\quad \\alpha_D = 0.35.\n  $$\n\nCalibration procedure:\n\n- We determine $C_1$ and $C_2$ by minimizing the squared residual between the modeled components $(C_n, C_t)$ and the targets $(\\eta^{-2}, \\eta)$ over a calibration set $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ using $\\Delta/\\delta = 1$. Because the dependence on $(C_1, C_2)$ is linear after subtracting $1$, we assemble a linear system in least-squares form. For each $M_s \\in \\mathcal{S}_{\\text{cal}}$, let $s = g_s (\\eta - 1)$, then we enforce\n$$\nC_n - 1 = C_1 s + C_2 s^2 \\approx \\eta^{-2} - 1, \\quad\nC_t - 1 = C_1 \\frac{s}{2} + C_2 \\frac{s^2}{4} \\approx \\eta - 1.\n$$\nStacking these for the two $M_s$ values yields four equations for $(C_1, C_2)$, which we solve in the least-squares sense.\n\nComputation of outputs:\n\n- Given $(M_s, \\delta/\\Delta, \\text{sensor})$, compute $\\eta(M_s)$ and $\\Pi(M_s)$, evaluate $\\Delta/\\delta = 1/(\\delta/\\Delta)$, and compute $g_s$ according to the sensor definition. Compute $s = g_s(\\eta-1)$, then $C_n$ and $C_t$. With $R_{ij,1} = \\frac{2}{3}\\delta_{ij}$, obtain\n$$\nR_{11,2} = \\frac{2}{3} C_n, \\quad R_{22,2} = R_{33,2} = \\frac{2}{3} C_t,\n$$\nso\n$$\nk_2 = \\frac{1}{2}\\left( \\frac{2}{3} C_n + 2 \\cdot \\frac{2}{3} C_t \\right) = \\frac{1}{3} \\left( C_n + 2 C_t \\right)\n$$\nand\n$$\nA_k = \\frac{k_2}{k_1} = \\frac{1}{3} \\left( C_n + 2 C_t \\right).\n$$\nFinally,\n$$\na_{11} = \\frac{R_{11,2}}{2k_2} - \\frac{1}{3} = \\frac{\\frac{2}{3} C_n}{\\frac{2}{3} (C_n + 2 C_t)} - \\frac{1}{3} = \\frac{C_n}{C_n + 2 C_t} - \\frac{1}{3}.\n$$\n\nTest suite and output:\n\n- Calibrate $(C_1, C_2)$ separately for each sensor using $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ and $\\Delta/\\delta = 1$.\n\n- Evaluate the following cases in order:\n  - Case $1$: $(M_s, \\delta/\\Delta, \\text{sensor}) = (1.05, 2.0, \\text{density})$ with $g_\\rho$.\n  - Case $2$: $(M_s, \\delta/\\Delta, \\text{sensor}) = (1.5, 1.0, \\text{pressure})$ with $g_p$.\n  - Case $3$: $(M_s, \\delta/\\Delta, \\text{sensor}) = (3.0, 0.25, \\text{ducros})$ with $g_D$.\n\n- For each case, compute $A_k$ and $a_{11}$ and print\n$$\n[A_k^{(1)}, a_{11}^{(1)}, A_k^{(2)}, a_{11}^{(2)}, A_k^{(3)}, a_{11}^{(3)}]\n$$\non a single line as comma-separated floats rounded to six decimals. All outputs are dimensionless.\n\nAlgorithmic summary:\n\n- Implement functions for $\\eta(M_s)$ and $\\Pi(M_s)$ given $\\gamma$.\n\n- Implement sensor functions $g_\\rho$, $g_p$, $g_D$.\n\n- For each sensor, solve a $4 \\times 2$ linear least-squares problem to determine $(C_1, C_2)$ using the calibration set.\n\n- For each test case, compute $C_n$, $C_t$, then $A_k$ and $a_{11}$ using the formulas above.\n\nThis approach is principle-based: it starts from conservation laws at the shock (Rankine–Hugoniot), uses linear rapid-distortion arguments to define target Reynolds stress jump relations, and constructs a minimal algebraic model tied to shock sensing and calibrated by matching those targets. The algorithm is deterministic and fully specified by the equations above, ensuring reproducibility and a single-line numerical output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nGAMMA = 1.4\n\ndef density_ratio(Ms, gamma=GAMMA):\n    # Rankine–Hugoniot density ratio across a normal shock\n    num = (gamma + 1.0) * Ms**2\n    den = (gamma - 1.0) * Ms**2 + 2.0\n    return num / den\n\ndef pressure_ratio(Ms, gamma=GAMMA):\n    # Rankine–Hugoniot pressure ratio across a normal shock\n    return 1.0 + (2.0 * gamma / (gamma + 1.0)) * (Ms**2 - 1.0)\n\ndef sensor_value(sensor, Ms, delta_over_Delta, gamma=GAMMA):\n    # Compute g_s based on the specified sensor and parameters.\n    # delta_over_Delta = delta/Delta, so inv_ratio = Delta/delta\n    inv_ratio = 1.0 / delta_over_Delta\n    eta = density_ratio(Ms, gamma)\n    Pi = pressure_ratio(Ms, gamma)\n    if sensor == 'density':\n        alpha_rho = 0.75\n        arg = alpha_rho * (eta - 1.0) * inv_ratio\n        return np.tanh(arg)\n    elif sensor == 'pressure':\n        alpha_p = 0.50\n        arg = alpha_p * (Pi - 1.0) * inv_ratio\n        return np.tanh(arg)\n    elif sensor == 'ducros':\n        alpha_d = 0.35\n        arg = alpha_d * (Ms**2) * inv_ratio\n        return np.tanh(arg)\n    else:\n        raise ValueError(\"Unknown sensor type\")\n\ndef calibrate_constants(sensor, gamma=GAMMA):\n    # Calibrate C1, C2 for the given sensor using Ms in {1.5, 3.0} and Delta/delta = 1 (i.e., delta/Delta=1)\n    Ms_list = [1.5, 3.0]\n    delta_over_Delta_cal = 1.0  # so inv_ratio = 1\n    rows = []\n    rhs = []\n    for Ms in Ms_list:\n        eta = density_ratio(Ms, gamma)\n        # Targets from rapid-distortion-based jump conditions\n        Cn_target = eta**(-2.0)\n        Ct_target = eta\n        # Sensor\n        gs = sensor_value(sensor, Ms, delta_over_Delta_cal, gamma)\n        s = gs * (eta - 1.0)\n        # Equations: Cn - 1 = C1*s + C2*s^2  -> row [s, s^2], rhs (Cn_target - 1)\n        rows.append([s, s**2])\n        rhs.append(Cn_target - 1.0)\n        # Ct - 1 = C1*(s/2) + C2*(s^2/4)\n        rows.append([0.5 * s, 0.25 * s**2])\n        rhs.append(Ct_target - 1.0)\n    A = np.array(rows, dtype=float)\n    b = np.array(rhs, dtype=float)\n    # Least-squares solution\n    theta, *_ = np.linalg.lstsq(A, b, rcond=None)\n    C1, C2 = theta[0], theta[1]\n    return C1, C2\n\ndef compute_Ak_a11(Ms, delta_over_Delta, sensor, C1, C2, gamma=GAMMA):\n    # Compute Ak and a11 for given case and calibrated constants.\n    eta = density_ratio(Ms, gamma)\n    gs = sensor_value(sensor, Ms, delta_over_Delta, gamma)\n    s = gs * (eta - 1.0)\n    Cn = 1.0 + C1 * s + C2 * s**2\n    Ct = 1.0 + 0.5 * C1 * s + 0.25 * C2 * s**2\n    # Upstream R_ii,1 = 2/3\n    R11_2 = (2.0 / 3.0) * Cn\n    R22_2 = (2.0 / 3.0) * Ct\n    R33_2 = (2.0 / 3.0) * Ct\n    k2 = 0.5 * (R11_2 + R22_2 + R33_2)\n    Ak = k2 / 1.0  # since k1 = 1\n    # a11 = R11/(2 k2) - 1/3\n    a11 = (R11_2 / (2.0 * k2)) - (1.0 / 3.0)\n    return Ak, a11\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (Ms, delta_over_Delta, sensor_key)\n    test_cases = [\n        (1.05, 2.0, 'density'),  # Case 1: density-gradient sensor\n        (1.5,  1.0, 'pressure'), # Case 2: pressure-based sensor\n        (3.0,  0.25, 'ducros'),  # Case 3: Ducros-type sensor\n    ]\n\n    # Calibrate constants for each sensor independently.\n    sensors = ['density', 'pressure', 'ducros']\n    calib = {}\n    for s in sensors:\n        C1, C2 = calibrate_constants(s, GAMMA)\n        calib[s] = (C1, C2)\n\n    results = []\n    for Ms, delta_over_Delta, sensor in test_cases:\n        C1, C2 = calib[sensor]\n        Ak, a11 = compute_Ak_a11(Ms, delta_over_Delta, sensor, C1, C2, GAMMA)\n        # Round to six decimals as specified\n        results.append(f\"{Ak:.6f}\")\n        results.append(f\"{a11:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}