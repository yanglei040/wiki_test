{
    "hands_on_practices": [
        {
            "introduction": "在模拟多相流时，一个常见的挑战是如何精确地模拟表面张力。这个过程中的数值误差会导致非物理的“寄生流”，即便在静态的流体中也会出现。这项练习将指导您实现一个模型来量化这些寄生流，从而直观地展示数值误差与其物理表现之间的直接联系 ()。",
            "id": "3332836",
            "problem": "考虑一个静态、不互溶的两相流，其光滑界面分隔了两种黏度相等的牛顿流体，该流动由不可压缩的斯托克斯方程控制。其基本原理是不可压缩的斯托克斯动量平衡方程和连续性方程，以及经典的杨-拉普拉斯表面张力压力跳跃条件。具体来说，设流体速度为 $\\mathbf{u}(\\mathbf{x})$，压力为 $p(\\mathbf{x})$，动力黏度为 $\\mu$，表面张力系数为 $\\sigma$。假设雷诺数很低，因此惯性项可以忽略不计。在体相中的控制方程为\n$$\n-\\mu \\nabla^2 \\mathbf{u} + \\nabla p = \\mathbf{0}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n在界面 $\\Gamma$ 上的尖锐界面条件是压力跳跃等于表面张力乘以平均曲率，以及速度连续，\n$$\n[\\![p]\\!] = \\sigma \\kappa, \\quad [\\![\\mathbf{u}]\\!] = \\mathbf{0},\n$$\n其中 $[\\![\\cdot]\\!]$ 表示该量跨界面的差值，$\\kappa$ 是界面的平均曲率。考虑一个三维空间中半径为 $R$ 的球形界面，其精确平均曲率为 $\\kappa_{\\mathrm{true}} = 2/R$。一个以误差 $\\epsilon_\\kappa$ 估算 $\\kappa$ 的数值方法将强制一个跳跃 $[\\![p]\\!]_{\\mathrm{num}} = \\sigma (\\kappa_{\\mathrm{true}} + \\epsilon_\\kappa)$，从而产生一个与 $\\sigma \\epsilon_\\kappa$ 成正比的残余界面力。在分布的意义上，不正确的跳跃在动量方程中产生一个有效的奇异体力，可以近似表示为\n$$\n\\mathbf{f}_{\\mathrm{res}}(\\mathbf{x}) \\approx \\sigma \\epsilon_\\kappa \\, \\mathbf{n}(\\mathbf{x}) \\, \\delta_{\\Gamma}(\\mathbf{x}),\n$$\n其中 $\\mathbf{n}$ 是界面上从内部流体指向外部流体的单位法向量，$\\delta_{\\Gamma}$ 是支撑在 $\\Gamma$ 上的表面狄拉克分布。在数值方法中，$\\delta_{\\Gamma}$ 通过一个宽度与网格间距 $h$ 成正比的光滑化子来近似，而 $\\mathbf{n}$ 可以从到界面的有符号距离函数计算得出。\n\n您的任务是实现一个程序，该程序针对一个边长为 $L$ 的二维周期性域，该域被一个 $N \\times N$ 点的均匀网格离散化，网格间距为 $h = L/N$。该程序需要模拟不可压缩斯托克斯方程中残余界面力的影响，并计算寄生流的振幅。您应将界面视为一个以域中心为圆心、半径为 $R$ 的圆，并使用平滑化的界面δ分布来近似球形界面的残余力。该流动是周期性的，您必须通过将残余力投影到无散度模态上，在傅里叶空间中求解稳态不可压缩斯托克斯方程：\n$$\n-\\mu \\nabla^2 \\mathbf{u} + \\nabla p = \\mathbf{f}_{\\mathrm{res}}, \\quad \\nabla \\cdot \\mathbf{u} = 0, \\quad \\mathbf{u} \\text{ periodic on } [0,L]^2.\n$$\n残余力应构造为 $\\mathbf{f}_{\\mathrm{res}}(\\mathbf{x}) = \\sigma \\epsilon_\\kappa \\, \\delta_\\varepsilon(\\phi(\\mathbf{x})) \\, \\mathbf{n}(\\mathbf{x})$，其中 $\\phi(\\mathbf{x})$ 是到圆的有符号距离函数，$\\mathbf{n}(\\mathbf{x}) = \\nabla \\phi(\\mathbf{x}) / \\|\\nabla \\phi(\\mathbf{x})\\|$，而 $\\delta_\\varepsilon$ 是狄拉克δ函数的一个光滑近似，其支撑宽度 $\\varepsilon$ 与 $h$相当。使用余弦光滑化子\n$$\n\\delta_\\varepsilon(\\phi) = \\begin{cases}\n\\dfrac{1}{2\\varepsilon}\\left(1 + \\cos\\left(\\dfrac{\\pi \\phi}{\\varepsilon}\\right)\\right),  |\\phi| \\le \\varepsilon, \\\\[6pt]\n0,  \\text{其他情况},\n\\end{cases}\n$$\n其中 $\\varepsilon = 1.5 h$。在傅里叶空间中，对于每个波矢 $\\mathbf{k} = (k_x, k_y) \\neq \\mathbf{0}$，解满足\n$$\n\\widehat{\\mathbf{u}}(\\mathbf{k}) = \\frac{1}{\\mu \\|\\mathbf{k}\\|^2} \\left( \\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^\\top}{\\|\\mathbf{k}\\|^2} \\right) \\widehat{\\mathbf{f}}_{\\mathrm{res}}(\\mathbf{k}),\n$$\n且 $\\widehat{\\mathbf{u}}(\\mathbf{0}) = \\mathbf{0}$。\n\n通过傅里叶逆变换计算速度场 $\\mathbf{u}(\\mathbf{x})$，并报告定义为寄生流振幅的值\n$$\nU_{\\max} = \\max_{\\mathbf{x}} \\|\\mathbf{u}(\\mathbf{x})\\|.\n$$\n所有物理量必须使用一致的单位处理：$\\sigma$ 的单位是 $\\mathrm{N/m}$，$\\mu$ 的单位是 $\\mathrm{Pa\\cdot s}$，$L$、$R$、$h$ 和 $\\varepsilon$ 的单位是 $\\mathrm{m}$，$\\epsilon_\\kappa$ 的单位是 $\\mathrm{m}^{-1}$，而 $U_{\\max}$ 的单位是 $\\mathrm{m/s}$。角度（如果有）必须以弧度为单位。您的程序必须为以下参数集测试套件生成 $U_{\\max}$ 的数值：\n\n- 测试用例1（理想路径，零曲率误差）：$\\sigma = 0.072\\,\\mathrm{N/m}$，$\\mu = 1.0\\times 10^{-3}\\,\\mathrm{Pa\\cdot s}$，$L = 0.04\\,\\mathrm{m}$，$R = 0.01\\,\\mathrm{m}$，$N = 128$，$\\epsilon_\\kappa = 0.0\\,\\mathrm{m}^{-1}$。\n- 测试用例2（非零曲率误差）：$\\sigma = 0.072\\,\\mathrm{N/m}$，$\\mu = 1.0\\times 10^{-3}\\,\\mathrm{Pa\\cdot s}$，$L = 0.04\\,\\mathrm{m}$，$R = 0.01\\,\\mathrm{m}$，$N = 128$，$\\epsilon_\\kappa = 0.5\\,\\mathrm{m}^{-1}$。\n- 测试用例3（网格加密边界情况）：$\\sigma = 0.072\\,\\mathrm{N/m}$，$\\mu = 1.0\\times 10^{-3}\\,\\mathrm{Pa\\cdot s}$，$L = 0.04\\,\\mathrm{m}$，$R = 0.01\\,\\mathrm{m}$，$N = 256$，$\\epsilon_\\kappa = 0.5\\,\\mathrm{m}^{-1}$。\n- 测试用例4（黏度变化边界情况）：$\\sigma = 0.072\\,\\mathrm{N/m}$，$\\mu = 1.0\\times 10^{-2}\\,\\mathrm{Pa\\cdot s}$，$L = 0.04\\,\\mathrm{m}$，$R = 0.01\\,\\mathrm{m}$，$N = 128$，$\\epsilon_\\kappa = 0.5\\,\\mathrm{m}^{-1}$。\n\n以 $\\mathrm{m/s}$ 为单位表示最终答案，将四个测试用例的结果聚合到一个用方括号括起来的逗号分隔列表中，并放在单行中。输出格式必须严格为\n$$\n[\\text{result1},\\text{result2},\\text{result3},\\text{result4}],\n$$\n其中每个 $\\text{result}$ 是一个浮点数，代表相应测试用例的 $U_{\\max}$ 值（单位为 $\\mathrm{m/s}$）。",
            "solution": "该问题是有效的。它在科学上基于低雷诺数流体动力学（不可压缩斯托克斯流）的原理，问题提法适定，并为可解的数值任务提供了一套完整的参数和方程。其目标是计算在两相流数值模拟中，由于曲率估计误差所产生的非物理“寄生”流的大小，而曲率估计误差又会导致错误的表面张力。\n\n解决方案将通过实现一个伪谱方法来求解二维周期域内包含指定残余力项的控制性斯托克斯方程。该方法的核心依赖于快速傅里叶变换（FFT）在周期域上求解常系数线性偏微分方程的高效性。\n\n计算流程如下：\n\n**1. 离散化与力场构建**\n\n首先，我们使用一个 $N \\times N$ 点的均匀网格来离散化二维周期域 $[0, L] \\times [0, L]$。网格间距为 $h = L/N$。网格点 $(x_i, y_j)$ 的坐标由 $x_i = i h$ 和 $y_j = j h$ 给出，其中 $i, j \\in \\{0, 1, \\dots, N-1\\}$。\n\n驱动寄生流的残余力被建模为一个连续场：\n$$\n\\mathbf{f}_{\\mathrm{res}}(\\mathbf{x}) = \\sigma \\epsilon_\\kappa \\, \\delta_\\varepsilon(\\phi(\\mathbf{x})) \\, \\mathbf{n}(\\mathbf{x})\n$$\n该力仅在圆形界面周围的一个薄层内非零。我们在离散网格上通过计算每个点 $(x_i, y_j)$ 上的分量来构建这个力场。\n\n此公式的组成部分包括：\n-   **有符号距离函数, $\\phi(\\mathbf{x})$**: 对于一个以 $(L/2, L/2)$ 为圆心、半径为 $R$ 的圆形界面，有符号距离函数由 $\\phi(x,y) = \\sqrt{(x-L/2)^2 + (y-L/2)^2} - R$ 给出。$\\phi$ 的负值表示点在圆内，正值表示点在圆外。\n\n-   **法向量场, $\\mathbf{n}(\\mathbf{x})$**: 从界面向外指向的单位法向量是有符号距离函数的归一化梯度，即 $\\mathbf{n}(\\mathbf{x}) = \\nabla\\phi / \\|\\nabla\\phi\\|$。对于圆形界面，其计算结果为：\n    $$\n    \\mathbf{n}(x,y) = \\frac{(x-L/2, y-L/2)}{\\sqrt{(x-L/2)^2 + (y-L/2)^2}}\n    $$\n    在圆心 $(L/2, L/2)$ 处，法向量在数学上是未定义的。然而，只要界面宽度 $\\varepsilon$ 小于半径 $R$，平滑化的δ函数在该点将为零，因此力也为零。在数值上，我们可以通过确保乘积为零来处理除以零的情况。\n\n-   **平滑狄拉克δ函数, $\\delta_\\varepsilon(\\phi)$**: 表面狄拉克δ函数使用宽度为 $\\varepsilon = 1.5 h$ 的余弦光滑化子进行正则化：\n    $$\n    \\delta_\\varepsilon(\\phi) = \\begin{cases}\n    \\frac{1}{2\\varepsilon}\\left(1 + \\cos\\left(\\frac{\\pi \\phi}{\\varepsilon}\\right)\\right),   |\\phi| \\le \\varepsilon \\\\\n    0,   \\text{其他情况}\n    \\end{cases}\n    $$\n    该函数将力局部化到 $\\phi=0$ 的圆周围一个厚度为 $2\\varepsilon$ 的窄带内。\n\n力场的两个分量 $f_x(\\mathbf{x})$ 和 $f_y(\\mathbf{x})$ 在网格上计算。对于 $\\epsilon_\\kappa = 0$ 的测试用例，力场恒为零，导致速度为零，这符合预期。\n\n**2. 斯托克斯方程的傅里叶空间解**\n\n带有残余力项的稳态、不可压缩斯托克斯控制方程为：\n$$\n-\\mu \\nabla^2 \\mathbf{u} + \\nabla p = \\mathbf{f}_{\\mathrm{res}}\n$$\n$$\n\\nabla \\cdot \\mathbf{u} = 0\n$$\n对这些方程应用傅里叶变换（用帽子符号表示，例如 $\\widehat{\\mathbf{u}}$），将空间导数转换为空域矢 $\\mathbf{k} = (k_x, k_y)$ 的代数乘法：\n$$\n\\mu \\|\\mathbf{k}\\|^2 \\widehat{\\mathbf{u}}(\\mathbf{k}) + i \\mathbf{k} \\widehat{p}(\\mathbf{k}) = \\widehat{\\mathbf{f}}_{\\mathrm{res}}(\\mathbf{k})\n$$\n$$\ni \\mathbf{k} \\cdot \\widehat{\\mathbf{u}}(\\mathbf{k}) = 0\n$$\n第二个方程是傅里叶空间中的不可压缩性约束。为了求解 $\\widehat{\\mathbf{u}}$，我们将动量方程投影到无散度向量场的空间上。这可以通过使用投影算子 $\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^\\top}{\\|\\mathbf{k}\\|^2}$ 来实现，其中 $\\mathbf{I}$ 是单位矩阵。将此算子应用于动量方程可以消去压力项，因为 $\\mathbf{P}(\\mathbf{k}) (i\\mathbf{k}\\widehat{p}) = \\mathbf{0}$。\n\n这就给出了傅里叶空间中每个波矢 $\\mathbf{k} \\neq \\mathbf{0}$ 对应的速度场解：\n$$\n\\widehat{\\mathbf{u}}(\\mathbf{k}) = \\frac{1}{\\mu \\|\\mathbf{k}\\|^2} \\mathbf{P}(\\mathbf{k}) \\widehat{\\mathbf{f}}_{\\mathrm{res}}(\\mathbf{k})\n$$\n对于零波矢 $\\mathbf{k} = \\mathbf{0}$（代表平均流），问题指定 $\\widehat{\\mathbf{u}}(\\mathbf{0}) = \\mathbf{0}$。因此，$\\|\\mathbf{k}\\|^2=0$ 处的奇点得到了处理。\n\n傅里叶空间中速度的分量计算如下：\n$$\n\\widehat{u}_x(\\mathbf{k}) = \\frac{1}{\\mu \\|\\mathbf{k}\\|^4} \\left( k_y^2 \\widehat{f}_x(\\mathbf{k}) - k_x k_y \\widehat{f}_y(\\mathbf{k}) \\right)\n$$\n$$\n\\widehat{u}_y(\\mathbf{k}) = \\frac{1}{\\mu \\|\\mathbf{k}\\|^4} \\left( k_x^2 \\widehat{f}_y(\\mathbf{k}) - k_x k_y \\widehat{f}_x(\\mathbf{k}) \\right)\n$$\n这些计算针对离散网格对应的所有波矢进行。波矢由 $k_x = 2\\pi f_x$ 和 $k_y = 2\\pi f_y$ 给出，其中 $f_x$ 和 $f_y$ 是从 `numpy.fft.fftfreq` 获得的离散频率。\n\n**3. 实空间速度的恢复与最终结果**\n\n通过对傅里叶空间中的速度分量 $\\widehat{u}_x(\\mathbf{k})$ 和 $\\widehat{u}_y(\\mathbf{k})$ 应用二维傅里叶逆变换（2D IFFT），可以恢复实空间中的速度场 $\\mathbf{u}(\\mathbf{x}) = (u_x(\\mathbf{x}), u_y(\\mathbf{x}))$。\n\n最后，寄生流的振幅 $U_{\\max}$ 通过计算所有网格点上速度矢量大小的最大值来确定：\n$$\nU_{\\max} = \\max_{\\mathbf{x}} \\|\\mathbf{u}(\\mathbf{x})\\| = \\max_{i,j} \\sqrt{u_x(x_i, y_j)^2 + u_y(x_i, y_j)^2}\n$$\n对测试套件中提供的每个参数集重复此过程，以获得最终结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1: sigma, mu, L, R, N, eps_kappa\n        (0.072, 1.0e-3, 0.04, 0.01, 128, 0.0),\n        # Test case 2\n        (0.072, 1.0e-3, 0.04, 0.01, 128, 0.5),\n        # Test case 3\n        (0.072, 1.0e-3, 0.04, 0.01, 256, 0.5),\n        # Test case 4\n        (0.072, 1.0e-2, 0.04, 0.01, 128, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        U_max = compute_parasitic_current_amplitude(*case)\n        results.append(U_max)\n\n    # Format output as specified\n    formatted_results = [f\"{r:.12f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef compute_parasitic_current_amplitude(sigma, mu, L, R, N, eps_kappa):\n    \"\"\"\n    Computes the amplitude of parasitic currents for a given set of parameters.\n\n    Args:\n        sigma (float): Surface tension coefficient (N/m).\n        mu (float): Dynamic viscosity (Pa·s).\n        L (float): Domain side length (m).\n        R (float): Circle radius (m).\n        N (int): Number of grid points per dimension.\n        eps_kappa (float): Curvature error (m^-1).\n\n    Returns:\n        float: The maximum velocity amplitude U_max (m/s).\n    \"\"\"\n\n    # If there is no curvature error, the residual force is zero, thus velocity is zero.\n    if eps_kappa == 0.0:\n        return 0.0\n\n    # 1. Grid Generation and Parameters\n    h = L / N\n    epsilon = 1.5 * h\n    # Grid coordinates\n    coords = np.arange(N) * h\n    X, Y = np.meshgrid(coords, coords)\n\n    # 2. Construct the Residual Force Field in Real Space\n    center_x, center_y = L / 2, L / 2\n    dist = np.sqrt((X - center_x)**2 + (Y - center_y)**2)\n    \n    # Signed distance function\n    phi = dist - R\n\n    # Smoothed Dirac delta function (cosine mollifier)\n    delta = np.zeros_like(phi)\n    mask = np.abs(phi) = epsilon\n    phi_masked = phi[mask]\n    delta[mask] = (1 / (2 * epsilon)) * (1 + np.cos(np.pi * phi_masked / epsilon))\n\n    # Normal vector field. Handle division by zero at the center.\n    # The normal is undefined at the center, but delta will be zero there if R > epsilon,\n    # so the force will correctly be zero.\n    dist_inv = np.divide(1.0, dist, out=np.zeros_like(dist), where=dist != 0)\n    nx = (X - center_x) * dist_inv\n    ny = (Y - center_y) * dist_inv\n\n    # Assemble the force components\n    f_coeff = sigma * eps_kappa\n    fx = f_coeff * delta * nx\n    fy = f_coeff * delta * ny\n\n    # 3. Fourier Transform the Force Field\n    hat_fx = np.fft.fft2(fx)\n    hat_fy = np.fft.fft2(fy)\n\n    # 4. Solve for Velocity in Fourier Space\n    # Wavevectors\n    freq = np.fft.fftfreq(N, d=h)\n    k = 2 * np.pi * freq\n    Kx, Ky = np.meshgrid(k, k) # Kx varies along cols (axis 1), Ky along rows (axis 0)\n\n    # Squared magnitude of wavevectors\n    K2 = Kx**2 + Ky**2\n\n    # Stokes solver in Fourier space. The projection operator and 1/(mu*K^2) are combined.\n    # The term 1/K^4 must avoid the K=0 singularity.\n    inv_mu_K4 = np.divide(1.0, mu * K2**2, out=np.zeros_like(K2), where=K2 != 0)\n\n    # Calculate velocity components in Fourier space\n    hat_ux = inv_mu_K4 * (Ky**2 * hat_fx - Kx * Ky * hat_fy)\n    hat_uy = inv_mu_K4 * (Kx**2 * hat_fy - Kx * Ky * hat_fx)\n    \n    # The k=0 mode (mean velocity) is correctly set to zero by the `where` clause in np.divide.\n\n    # 5. Inverse Fourier Transform to get Real-Space Velocity\n    ux = np.fft.ifft2(hat_ux).real\n    uy = np.fft.ifft2(hat_uy).real\n\n    # 6. Compute the Amplitude of Parasitic Currents\n    vel_mag = np.sqrt(ux**2 + uy**2)\n    U_max = np.max(vel_mag)\n\n    return U_max\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "浸入边界法依赖于两个基本算子：一个将力从边界“散布”到流体网格上，另一个将速度从网格“插值”回边界。这项练习探讨了这两个算子之间关键的数学关系，即伴随属性。验证这一属性对于许多高级模拟方案（尤其是在优化问题中）的稳定性和准确性至关重要 ()。",
            "id": "3332853",
            "problem": "给定一个单位正方形上的具有周期性边界的均匀二维笛卡尔网格，以及一组表示浸入曲线的拉格朗日标记点。浸入边界法使用正则化的狄拉克δ函数来定义两个线性算子：一个将拉格朗日力映射到网格上欧拉力的散布算子$S$，以及一个将欧拉网格场映射到拉格朗日标记点的插值算子$J$。您的任务是构建这些算子的离散矩阵表示，形成正确的加权伴随对，在特定求积法则下验证对称关系，并量化这种对称性的偏差如何影响一个简单优化任务中的梯度精度。\n\n从以下基本基础和定义开始：\n\n- 欧拉网格为 $N \\times N$，网格间距为 $h = 1/N$，网格坐标为 $x_i = i h, y_j = j h$，其中整数 $i,j \\in \\{0,\\dots,N-1\\}$，且在 $[0,1)^2$ 上具有周期性边界条件。\n\n- 有 $M$ 个拉格朗日标记点，位于位置 $(X_\\ell, Y_\\ell)$，具有均匀的求积权重 $w_\\ell = \\Delta s$，其中 $\\Delta s$ 近似于曲线的弧长间距。\n\n- 一维四点正则化狄拉克δ函数（Peskin核）$\\varphi(r)$ 的支撑集在 $|r|  2$ 上，定义为\n  $$\n  \\varphi(r) = \n  \\begin{cases}\n  \\dfrac{1}{8}\\left(3 - 2|r| + \\sqrt{1 + 4|r| - 4 r^2}\\right),  0 \\le |r|  1, \\\\\n  \\dfrac{1}{8}\\left(5 - 2|r| - \\sqrt{-7 + 12|r| - 4 r^2}\\right),  1 \\le |r|  2, \\\\\n  0,  |r| \\ge 2,\n  \\end{cases}\n  $$\n  在网格间距 $h$ 下的二维正则化δ函数为\n  $$\n  \\delta_h(x,y) = \\dfrac{1}{h^2} \\, \\varphi\\!\\left(\\dfrac{x}{h}\\right)\\, \\varphi\\!\\left(\\dfrac{y}{h}\\right).\n  $$\n  周期性通过对其参数取最小周期差来强制执行。\n\n- 离散散布算子 $S_{\\mathrm{phys}}$ 将一个拉格朗日向量 $F \\in \\mathbb{R}^{M}$ 映射到一个欧拉向量 $f \\in \\mathbb{R}^{N^2}$，通过\n  $$\n  f_{ij} = \\sum_{\\ell=1}^{M} w_\\ell \\, F_\\ell \\, \\delta_h\\!\\left(x_i - X_\\ell, \\, y_j - Y_\\ell\\right),\n  $$\n  即，以矩阵形式表示为 $f = S_{\\mathrm{phys}} \\, F$，其中 $S_{\\mathrm{phys}} \\in \\mathbb{R}^{N^2 \\times M}$。\n\n- 离散插值算子 $J_{\\mathrm{phys}}$ 将一个欧拉向量 $u \\in \\mathbb{R}^{N^2}$ 映射到一个拉格朗日向量 $U \\in \\mathbb{R}^{M}$，通过\n  $$\n  U_\\ell = \\sum_{i=1}^{N} \\sum_{j=1}^{N} u_{ij}\\, h^2 \\, \\delta_h\\!\\left(x_i - X_\\ell, \\, y_j - Y_\\ell\\right),\n  $$\n  即，以矩阵形式表示为 $U = J_{\\mathrm{phys}} \\, u$，其中 $J_{\\mathrm{phys}} \\in \\mathbb{R}^{M \\times N^2}$。\n\n- 欧拉加权内积为 $\\langle u, f \\rangle_E = \\sum_{i,j} u_{ij} f_{ij} \\, h^2$，拉格朗日加权内积为 $\\langle U, F \\rangle_L = \\sum_{\\ell} U_\\ell F_\\ell \\, w_\\ell$。在这些权重下，离散功率恒等式 $\\langle u, S_{\\mathrm{phys}} F \\rangle_E = \\langle J_{\\mathrm{phys}} u, F \\rangle_L$ 成立，等价于\n  $$\n  J_{\\mathrm{phys}} = W_L^{-1} \\, S_{\\mathrm{phys}}^\\top \\, W_E,\n  $$\n  其中 $W_E = h^2 I_{N^2}$ 且 $W_L = \\mathrm{diag}(w_1,\\dots,w_M)$。\n\n- 定义对称加权算子\n  $$\n  \\widetilde{S} = W_E^{1/2}\\, S_{\\mathrm{phys}}\\, W_L^{-1/2}, \\qquad\n  \\widetilde{J} = W_L^{1/2}\\, J_{\\mathrm{phys}}\\, W_E^{-1/2}.\n  $$\n  使用上述基本恒等式，可以得到对称关系\n  $$\n  \\widetilde{J} = \\widetilde{S}^\\top.\n  $$\n\n您的程序必须：\n\n- 对于给定的 $(N,M)$、位于半径为 $R$、中心为 $(x_c,y_c)$ 的圆上的标记点位置 $(X_\\ell,Y_\\ell)$，以及求积权重 $w_\\ell = 2\\pi R / M$，构建 $S_{\\mathrm{phys}}$ 和 $J_{\\mathrm{phys}}$。\n\n- 构建对称加权对 $(\\widetilde{S}, \\widetilde{J})$，并计算差值 $\\|\\widetilde{J} - \\widetilde{S}^\\top\\|_F$ 的 Frobenius 范数，结果为一个标量浮点数。\n\n- 构建一个有偏差的插值算子 $J_{\\mathrm{wrong}}$，该算子省略了欧拉求积因子 $h^2$（即，设 $U_\\ell = \\sum_{i,j} u_{ij}\\, \\delta_h(\\cdot)$），并使用相同的对称加权公式 $\\widetilde{J}_{\\mathrm{wrong}} = W_L^{1/2} J_{\\mathrm{wrong}} W_E^{-1/2}$ 计算 $\\|\\widetilde{J}_{\\mathrm{wrong}} - \\widetilde{S}^\\top\\|_F$。\n\n- 在拉格朗日力 $F \\in \\mathbb{R}^M$ 上定义二次目标函数，\n  $$\n  \\Phi(F) = \\dfrac{1}{2}\\, \\| A F - b \\|_{W_L}^2, \\quad \\text{其中 } A = J_{\\mathrm{phys}} S_{\\mathrm{phys}},\n  $$\n  其中 $\\|v\\|_{W_L}^2 = v^\\top W_L v$。为了可复现性，使用一个固定的随机向量 $b \\in \\mathbb{R}^M$ 和一个确定性播种的固定随机向量 $F \\in \\mathbb{R}^M$。\n\n- 使用加权内积所蕴含的伴随链计算关于 $F$ 的精确梯度，\n  $$\n  \\nabla \\Phi(F) = S_{\\mathrm{phys}}^\\top\\, J_{\\mathrm{phys}}^\\top\\, \\left(W_L (A F - b)\\right).\n  $$\n  同时，计算一个在伴随链中使用有偏差的插值算子的不正确梯度，\n  $$\n  \\nabla_{\\mathrm{wrong}} \\Phi(F) = S_{\\mathrm{phys}}^\\top\\, J_{\\mathrm{wrong}}^\\top\\, \\left(W_L (A F - b)\\right).\n  $$\n\n- 通过中心有限差分法估计参考梯度，其中扰动步长 $\\varepsilon$ 逐分量应用于 $F$：\n  $$\n  \\left[\\nabla \\Phi(F)\\right]_k \\approx \\dfrac{\\Phi(F + \\varepsilon e_k) - \\Phi(F - \\varepsilon e_k)}{2 \\varepsilon},\n  $$\n  其中 $e_k$ 是第 $k$ 个基向量。\n\n- 报告精确梯度和不正确梯度相对于有限差分结果的相对 $\\ell^2$-误差：\n  $$\n  E_{\\mathrm{true}} = \\dfrac{\\|\\nabla \\Phi(F) - \\nabla_{\\mathrm{FD}} \\Phi(F)\\|_2}{\\|\\nabla_{\\mathrm{FD}} \\Phi(F)\\|_2}, \\qquad\n  E_{\\mathrm{wrong}} = \\dfrac{\\|\\nabla_{\\mathrm{wrong}} \\Phi(F) - \\nabla_{\\mathrm{FD}} \\Phi(F)\\|_2}{\\|\\nabla_{\\mathrm{FD}} \\Phi(F)\\|_2}.\n  $$\n\n测试套件和要求的最终输出：\n\n您的程序必须实现以下三个测试用例，并将其输出汇总到一个列表中：\n\n- 用例 1（对称性验证，匹配的求积）：$N = 16$, $M = 20$，圆心 $(x_c,y_c) = (0.15, 0.85)$，半径 $R = 0.22$。计算 $E_{\\mathrm{sym}}^{\\mathrm{matched}} = \\|\\widetilde{J} - \\widetilde{S}^\\top\\|_F$ 为一个浮点数。\n\n- 用例 2（对称性验证，有偏差的插值求积）：参数与用例 1 相同，但使用省略了因子 $h^2$ 的 $J_{\\mathrm{wrong}}$。计算 $E_{\\mathrm{sym}}^{\\mathrm{wrong}} = \\|\\widetilde{J}_{\\mathrm{wrong}} - \\widetilde{S}^\\top\\|_F$ 为一个浮点数。\n\n- 用例 3（二次设计任务中的梯度精度）：$N = 24$, $M = 28$，圆心 $(x_c,y_c) = (0.07, 0.11)$，半径 $R = 0.19$，随机种子固定为一个整数值，有限差分步长 $\\varepsilon = 10^{-6}$。计算 $E_{\\mathrm{true}}$ 和 $E_{\\mathrm{wrong}}$ 为浮点数。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含按顺序 $[E_{\\mathrm{sym}}^{\\mathrm{matched}}, E_{\\mathrm{sym}}^{\\mathrm{wrong}}, E_{\\mathrm{true}}, E_{\\mathrm{wrong}}]$ 排列的结果，以逗号分隔并用方括号括起来。",
            "solution": "用户想要验证一个问题陈述。\n\n### 步骤 1：提取给定信息\n\n- **欧拉网格**：单位正方形 $[0,1)^2$ 上的均匀 $N \\times N$ 笛卡尔网格，具有周期性边界。网格间距为 $h = 1/N$。网格点坐标为 $(x_i, y_j)$，其中 $x_i = i h$，$y_j = j h$，$i, j \\in \\{0, \\dots, N-1\\}$。\n- **拉格朗日标记点**：$M$ 个标记点，位于位置 $(X_\\ell, Y_\\ell)$。\n- **拉格朗日求积**：均匀求积权重 $w_\\ell = \\Delta s$。对于半径为 $R$ 的圆，$w_\\ell = 2\\pi R / M$。\n- **正则化 Delta 函数**：一维四点 Peskin 核 $\\varphi(r)$，及其二维张量积扩展 $\\delta_h(x,y) = \\frac{1}{h^2} \\varphi(x/h) \\varphi(y/h)$。周期性通过最小周期差强制执行。\n- **散布算子 ($S_{\\mathrm{phys}}$)**：从拉格朗日力 $F \\in \\mathbb{R}^M$ 到欧拉力 $f \\in \\mathbb{R}^{N^2}$ 的线性算子，定义为 $f_{ij} = \\sum_{\\ell=1}^{M} w_\\ell \\, F_\\ell \\, \\delta_h(x_i - X_\\ell, y_j - Y_\\ell)$。矩阵形式为 $f = S_{\\mathrm{phys}} F$。\n- **插值算子 ($J_{\\mathrm{phys}}$)**：从欧拉场 $u \\in \\mathbb{R}^{N^2}$ 到拉格朗日场 $U \\in \\mathbb{R}^M$ 的线性算子，定义为 $U_\\ell = \\sum_{i,j} u_{ij}\\, h^2 \\, \\delta_h(x_i - X_\\ell, y_j - Y_\\ell)$。矩阵形式为 $U = J_{\\mathrm{phys}} u$。\n- **加权内积**：欧拉内积 $\\langle u, f \\rangle_E = \\sum_{i,j} u_{ij} f_{ij} \\, h^2$ 和拉格朗日内积 $\\langle U, F \\rangle_L = \\sum_{\\ell} U_\\ell F_\\ell \\, w_\\ell$。\n- **离散伴随关系**：算子被定义为满足功率恒等式 $\\langle u, S_{\\mathrm{phys}} F \\rangle_E = \\langle J_{\\mathrm{phys}} u, F \\rangle_L$，这蕴含矩阵关系 $J_{\\mathrm{phys}} = W_L^{-1} S_{\\mathrm{phys}}^\\top W_E$，其中 $W_E = h^2 I_{N^2}$，$W_L = \\mathrm{diag}(w_1, \\dots, w_M)$。\n- **对称加权算子**：$\\widetilde{S} = W_E^{1/2} S_{\\mathrm{phys}} W_L^{-1/2}$ 和 $\\widetilde{J} = W_L^{1/2} J_{\\mathrm{phys}} W_E^{-1/2}$，它们应满足 $\\widetilde{J} = \\widetilde{S}^\\top$。\n- **有偏差的插值算子 ($J_{\\mathrm{wrong}}$)**：通过省略 $h^2$ 因子定义：$U_\\ell = \\sum_{i,j} u_{ij} \\delta_h(x_i - X_\\ell, y_j - Y_\\ell)$。\n- **目标函数**：$\\Phi(F) = \\frac{1}{2} \\| A F - b \\|_{W_L}^2$，其中 $A = J_{\\mathrm{phys}} S_{\\mathrm{phys}}$，以及固定的随机向量 $b, F$。\n- **梯度**：“精确”梯度 $\\nabla \\Phi(F) = S_{\\mathrm{phys}}^\\top J_{\\mathrm{phys}}^\\top (W_L(AF-b))$，“不正确”梯度 $\\nabla_{\\mathrm{wrong}} \\Phi(F) = S_{\\mathrm{phys}}^\\top J_{\\mathrm{wrong}}^\\top (W_L(AF-b))$，以及通过有限差分得到的参考梯度 $\\nabla_{\\mathrm{FD}} \\Phi(F)$。\n- **任务**：\n  1.  构建算子并计算 $E_{\\mathrm{sym}}^{\\mathrm{matched}} = \\|\\widetilde{J} - \\widetilde{S}^\\top\\|_F$。\n  2.  构建 $J_{\\mathrm{wrong}}$ 并计算 $E_{\\mathrm{sym}}^{\\mathrm{wrong}} = \\|\\widetilde{J}_{\\mathrm{wrong}} - \\widetilde{S}^\\top\\|_F$。\n  3.  计算解析梯度相对于有限差分近似的相对误差 $E_{\\mathrm{true}}$ 和 $E_{\\mathrm{wrong}}$。\n- **参数**：\n  - 用例 1  2：$N=16, M=20, (x_c,y_c)=(0.15, 0.85), R=0.22$。\n  - 用例 3：$N=24, M=28, (x_c,y_c)=(0.07, 0.11), R=0.19$，固定的整数随机种子，$\\varepsilon = 10^{-6}$。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n根据验证标准对问题进行评估。\n\n- **科学基础**：该问题牢固地植根于计算流体动力学，特别是 Charles Peskin 开创的浸入边界法。包括正则化delta函数、散布/插值算子和加权伴随在内的概念，都是该领域的标准和基础。所有的数学定义和物理解释都是正确的。\n- **适定性**：问题是适定的。它要求实现明确定义的数学对象，并计算特定的、明确定义的量（矩阵范数、向量范数和相对误差）。为每个任务提供了所有必要的参数和定义。计算的确定性保证了结果的存在性和唯一性。\n- **客观性**：语言精确、量化，没有任何主观或模糊的术语。\n- **完整性**：问题是自包含的。为指定的测试用例提供了所有必要的方程、常数和参数。不需要外部信息。\n- **一致性**：定义是相互一致的。例如，矩阵关系 $J_{\\mathrm{phys}} = W_L^{-1} S_{\\mathrm{phys}}^\\top W_E$ 是算子定义和加权内积的直接推论，这构成了练习中的一个关键验证点。\n- **真实性**：对于一个演示规模的问题，这些参数在物理上和数值上都是合理的。在一个开发和验证工程和物理学中数值优化代码的过程中，验证伴随关系及其对梯度计算的影响是一个关键且现实的步骤。\n\n该问题没有任何无效性缺陷。这是一个典型的、具有教学意义且健全的数值方法练习。\n\n### 步骤 3：结论与行动\n\n问题是有效的。将提供一个解决方案。\n\n---\n\n### 解决方案\n\n该问题要求仔细实现浸入边界（IB）方法的核心算子，并研究其伴随性质。解决方案围绕算子离散化、加权伴随及其在基于梯度的优化中的应用等原则构建。\n\n**1. 连续算子的离散化**\n\nIB 方法将浸入结构的拉格朗日表示与周围的欧拉流体网格耦合起来。这种耦合是通过涉及狄拉克δ函数的积分算子实现的。在离散设置中，狄拉克δ函数被正则化核 $\\delta_h$ 替代，积分被求和替代。\n\n- **网格和标记点**：欧拉域是一个由 $N^2$ 个点 $(x_i, y_j)$ 组成的网格，浸入边界是一组 $M$ 个拉格朗日标记点 $(X_\\ell, Y_\\ell)$。周期性边界条件通过计算环面上的距离来处理，即 $d_{\\text{periodic}}(a,b) = (a-b) - \\lfloor(a-b)+0.5\\rfloor$，假设域大小为 1。\n\n- **散布算子 $S_{\\mathrm{phys}}$**：此算子将拉格朗日量（如力 $F$）散布到欧拉网格上。连续定义为 $f(\\mathbf{x}) = \\int_{\\Gamma} F(s) \\delta(\\mathbf{x} - \\mathbf{X}(s)) ds$。其离散化形式为：\n$$ f_{ij} = \\sum_{\\ell=1}^M F_\\ell \\delta_h(x_i - X_\\ell, y_j - Y_\\ell) w_\\ell $$\n这里，$w_\\ell$（近似 $ds$）是拉格朗日求积权重。将向量 $F$ 映射到向量 $f$ 的 $S_{\\mathrm{phys}}$ 的矩阵元素（以网格点为行，标记点为列）是：\n$$ (S_{\\mathrm{phys}})_{ij, \\ell} = w_\\ell \\, \\delta_h(x_i - X_\\ell, y_j - Y_\\ell) = \\frac{w_\\ell}{h^2} \\varphi\\left(\\frac{x_i - X_\\ell}{h}\\right) \\varphi\\left(\\frac{y_j - Y_\\ell}{h}\\right) $$\n\n- **插值算子 $J_{\\mathrm{phys}}$**：此算子将欧拉场（如速度 $u$）插值到拉格朗日标记点上。连续定义为 $U(s) = \\int_{\\Omega} u(\\mathbf{x}) \\delta(\\mathbf{x} - \\mathbf{X}(s)) d\\mathbf{x}$。其离散化形式为：\n$$ U_\\ell = \\sum_{i=1}^N \\sum_{j=1}^N u_{ij} \\delta_h(x_i - X_\\ell, y_j - Y_\\ell) h^2 $$\n这里，$h^2$ 是欧拉求积权重（面积元 $d\\mathbf{x}$）。$J_{\\mathrm{phys}}$ 的矩阵元素（以标记点为行，网格点为列）是：\n$$ (J_{\\mathrm{phys}})_{\\ell, ij} = h^2 \\, \\delta_h(x_i - X_\\ell, y_j - Y_\\ell) = \\varphi\\left(\\frac{x_i - X_\\ell}{h}\\right) \\varphi\\left(\\frac{y_j - Y_\\ell}{h}\\right) $$\n\n**2. 伴随关系与对称性**\n\n算子 $S_{\\mathrm{phys}}$ 和 $J_{\\mathrm{phys}}$ 彼此不是矩阵转置。相反，它们是关于代表离散积分的特定加权内积的伴随算子：网格上的 $\\langle \\cdot, \\cdot \\rangle_E$ 和标记点上的 $\\langle \\cdot, \\cdot \\rangle_L$。必须满足功率守恒恒等式 $\\langle u, S_{\\mathrm{phys}} F \\rangle_E = \\langle J_{\\mathrm{phys}} u, F \\rangle_L$。这等价于矩阵恒等式 $S_{\\mathrm{phys}}^\\top W_E = W_L J_{\\mathrm{phys}}$，或 $J_{\\mathrm{phys}} = W_L^{-1} S_{\\mathrm{phys}}^\\top W_E$，其中 $W_E=h^2 I$ 且 $W_L=\\mathrm{diag}(w_\\ell)$。我们对 $(S_{\\mathrm{phys}})_{ij, \\ell}$ 和 $(J_{\\mathrm{phys}})_{\\ell, ij}$ 的构造满足此条件。\n\n为了恢复熟悉的矩阵转置关系，我们定义对称加权算子：\n$$ \\widetilde{S} = W_E^{1/2} S_{\\mathrm{phys}} W_L^{-1/2} \\quad \\text{和} \\quad \\widetilde{J} = W_L^{1/2} J_{\\mathrm{phys}} W_E^{-1/2} $$\n将 $J_{\\mathrm{phys}}$ 的伴随关系代入 $\\widetilde{J}$ 的定义并化简，可以证实 $\\widetilde{J} = \\widetilde{S}^\\top$。代码将通过计算 $\\|\\widetilde{J} - \\widetilde{S}^\\top\\|_F$ 来数值验证这一点，其值应接近机器精度。\n\n有偏差的算子 $J_{\\mathrm{wrong}}$ 省略了欧拉求积权重 $h^2$，得到 $(J_{\\mathrm{wrong}})_{\\ell, ij} = \\delta_h(\\dots)$。这破坏了功率恒等式，因此也破坏了加权算子的对称性。$\\|\\widetilde{J}_{\\mathrm{wrong}} - \\widetilde{S}^\\top\\|_F$ 将显著不为零。\n\n**3. 梯度计算与验证**\n\n对于目标函数 $\\Phi(F) = \\frac{1}{2} \\| J_{\\mathrm{phys}} S_{\\mathrm{phys}} F - b \\|_{W_L}^2$，梯度通过链式法则求得。$\\|v\\|_{W_L}^2$ 关于 $v$ 的导数是 $2 W_L v$。通过线性算子应用链式法则得到：\n$$ \\nabla \\Phi(F) = (J_{\\mathrm{phys}} S_{\\mathrm{phys}})^\\dagger (J_{\\mathrm{phys}} S_{\\mathrm{phys}} F - b) $$\n其中 $(\\cdot)^\\dagger$ 表示关于输入空间上的标准欧几里得内积和输出空间上的 $W_L$-加权内积的伴随。这可以简化为：\n$$ \\nabla \\Phi(F) = (J_{\\mathrm{phys}} S_{\\mathrm{phys}})^\\top W_L (J_{\\mathrm{phys}} S_{\\mathrm{phys}} F - b) = S_{\\mathrm{phys}}^\\top J_{\\mathrm{phys}}^\\top W_L (A F - b) $$\n这就是“精确”的解析梯度。该公式关键依赖于前向算子的伴随（转置）。如果在梯度公式中错误地使用了非伴随算子，例如用 $J_{\\mathrm{wrong}}^\\top$ 代替 $J_{\\mathrm{phys}}^\\top$，结果将是不正确的。\n\n我们用中心有限差分近似来验证解析梯度，这是梯度检验的黄金标准。正确解析梯度与有限差分之间的相对误差 $E_{\\mathrm{true}}$ 应该很小，受浮点精度和有限差分格式的近似误差限制。相反，对于不正确计算的梯度，其误差 $E_{\\mathrm{wrong}}$ 将会很大，这表明在灵敏度分析和优化中使用正确定推导的伴随算子的至关重要性。",
            "answer": "```python\nimport numpy as np\n\ndef phi(r_in):\n    \"\"\"\n    Computes the 4-point Peskin kernel (regularized Dirac delta function).\n    This function is piecewise and continuous, with support over |r|  2.\n\n    Args:\n        r_in (np.ndarray): Input values.\n\n    Returns:\n        np.ndarray: The kernel values.\n    \"\"\"\n    r = np.abs(r_in)\n    val = np.zeros_like(r, dtype=float)\n    \n    # Case a: 0 = |r|  1\n    mask1 = r  1\n    r1 = r[mask1]\n    val[mask1] = (1/8) * (3 - 2*r1 + np.sqrt(1 + 4*r1 - 4*r1**2))\n    \n    # Case b: 1 = |r|  2\n    mask2 = (r >= 1)  (r  2)\n    r2 = r[mask2]\n    val[mask2] = (1/8) * (5 - 2*r2 - np.sqrt(-7 + 12*r2 - 4*r2**2))\n    \n    # Case c: |r| >= 2 is implicitly zero\n    return val\n\ndef periodic_diff(coords1, coords2, domain_size=1.0):\n    \"\"\"\n    Calculates the shortest periodic difference vector.\n    Handles broadcasting between coordinate arrays.\n\n    Args:\n        coords1 (np.ndarray): First set of coordinates, shape (P, D).\n        coords2 (np.ndarray): Second set of coordinates, shape (Q, D).\n        domain_size (float): The size of the periodic domain.\n\n    Returns:\n        np.ndarray: The difference vectors, shape (P, Q, D).\n    \"\"\"\n    diff = coords1[:, None, :] - coords2[None, :, :]\n    return diff - domain_size * np.round(diff / domain_size)\n\ndef solve_symmetry_cases(N, M, xc, yc, R):\n    \"\"\"\n    Solves for Cases 1 and 2: Symmetry verification of IB operators.\n\n    Args:\n        N (int): Grid dimension.\n        M (int): Number of markers.\n        xc, yc (float): Circle center coordinates.\n        R (float): Circle radius.\n\n    Returns:\n        tuple[float, float]: The Frobenius norms of the differences for\n                             the matched and wrong interpolation operators.\n    \"\"\"\n    h = 1.0 / N\n    \n    # Eulerian grid setup\n    grid_pts = np.arange(N) * h\n    grid_x, grid_y = np.meshgrid(grid_pts, grid_pts, indexing='ij')\n    grid_coords = np.stack((grid_x.ravel(), grid_y.ravel()), axis=-1)\n    \n    # Lagrangian marker setup\n    thetas = 2 * np.pi * np.arange(M) / M\n    marker_coords = np.zeros((M, 2))\n    marker_coords[:, 0] = xc + R * np.cos(thetas)\n    marker_coords[:, 1] = yc + R * np.sin(thetas)\n    \n    # Quadrature weights\n    ds = 2 * np.pi * R / M\n    w_L_vals = np.full(M, ds)\n    \n    # Interaction terms\n    diffs = periodic_diff(grid_coords, marker_coords)\n    phi_x = phi(diffs[..., 0] / h)\n    phi_y = phi(diffs[..., 1] / h)\n    phi_prod = phi_x * phi_y\n    \n    # Operator construction\n    S_phys = (w_L_vals[None, :] / (h**2)) * phi_prod\n    J_phys = phi_prod.T\n    J_wrong = (1 / h**2) * J_phys\n    \n    # Symmetrically weighted operators\n    sqrt_w_L = np.sqrt(w_L_vals)\n    S_tilde = h * S_phys * (1.0 / sqrt_w_L[None, :])\n    J_tilde = (1/h) * sqrt_w_L[:, None] * J_phys\n    J_tilde_wrong = (1/h) * sqrt_w_L[:, None] * J_wrong\n    \n    # Compute Frobenius norms\n    E_sym_matched = np.linalg.norm(J_tilde - S_tilde.T, 'fro')\n    E_sym_wrong = np.linalg.norm(J_tilde_wrong - S_tilde.T, 'fro')\n    \n    return E_sym_matched, E_sym_wrong\n\ndef solve_gradient_case(N, M, xc, yc, R, seed, eps):\n    \"\"\"\n    Solves for Case 3: Gradient accuracy of an objective function.\n\n    Args:\n        N, M, xc, yc, R: Problem parameters.\n        seed (int): Seed for random number generator.\n        eps (float): Step size for finite differences.\n\n    Returns:\n        tuple[float, float]: Relative errors of the 'true' and 'wrong' gradients.\n    \"\"\"\n    h = 1.0 / N\n    \n    # Grid and marker setup\n    grid_pts = np.arange(N) * h\n    grid_x, grid_y = np.meshgrid(grid_pts, grid_pts, indexing='ij')\n    grid_coords = np.stack((grid_x.ravel(), grid_y.ravel()), axis=-1)\n    \n    thetas = 2 * np.pi * np.arange(M) / M\n    marker_coords = np.zeros((M, 2))\n    marker_coords[:, 0] = xc + R * np.cos(thetas)\n    marker_coords[:, 1] = yc + R * np.sin(thetas)\n    \n    # Weights and interaction terms\n    ds = 2 * np.pi * R / M\n    w_L_vals = np.full(M, ds)\n    W_L = np.diag(w_L_vals)\n    \n    diffs = periodic_diff(grid_coords, marker_coords)\n    phi_prod = phi(diffs[..., 0] / h) * phi(diffs[..., 1] / h)\n    \n    # Operator construction\n    S_phys = (w_L_vals[None, :] / (h**2)) * phi_prod\n    J_phys = phi_prod.T\n    J_wrong = (1 / h**2) * J_phys\n    \n    # System operator A\n    A = J_phys @ S_phys\n    \n    # Random vectors for reproducibility\n    rng = np.random.default_rng(seed)\n    b = rng.random(M)\n    F_vec = rng.random(M)\n    \n    def objective_Phi(force_vec):\n        residual = A @ force_vec - b\n        return 0.5 * (residual.T @ W_L @ residual)\n\n    # Analytical gradients\n    residual_at_F = A @ F_vec - b\n    grad_Phi_exact = S_phys.T @ J_phys.T @ (W_L @ residual_at_F)\n    grad_Phi_wrong = S_phys.T @ J_wrong.T @ (W_L @ residual_at_F)\n    \n    # Finite difference gradient\n    grad_Phi_fd = np.zeros(M)\n    for k in range(M):\n        F_plus = F_vec.copy()\n        F_plus[k] += eps\n        F_minus = F_vec.copy()\n        F_minus[k] -= eps\n        \n        phi_plus = objective_Phi(F_plus)\n        phi_minus = objective_Phi(F_minus)\n        \n        grad_Phi_fd[k] = (phi_plus - phi_minus) / (2 * eps)\n        \n    # Relative errors\n    norm_fd = np.linalg.norm(grad_Phi_fd)\n    E_true = np.linalg.norm(grad_Phi_exact - grad_Phi_fd) / norm_fd\n    E_wrong = np.linalg.norm(grad_Phi_wrong - grad_Phi_fd) / norm_fd\n\n    return E_true, E_wrong\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    \n    # Test cases defined in the problem statement.\n    test_cases = {\n        \"case1_2\": {\"N\": 16, \"M\": 20, \"xc\": 0.15, \"yc\": 0.85, \"R\": 0.22},\n        \"case3\": {\"N\": 24, \"M\": 28, \"xc\": 0.07, \"yc\": 0.11, \"R\": 0.19, \"seed\": 42, \"eps\": 1e-6}\n    }\n    \n    # Case 1  2\n    params12 = test_cases[\"case1_2\"]\n    E_sym_matched, E_sym_wrong = solve_symmetry_cases(\n        params12[\"N\"], params12[\"M\"], params12[\"xc\"], params12[\"yc\"], params12[\"R\"]\n    )\n    \n    # Case 3\n    params3 = test_cases[\"case3\"]\n    E_true, E_wrong_grad = solve_gradient_case(\n        params3[\"N\"], params3[\"M\"], params3[\"xc\"], params3[\"yc\"], params3[\"R\"], \n        params3[\"seed\"], params3[\"eps\"]\n    )\n    \n    results = [E_sym_matched, E_sym_wrong, E_true, E_wrong_grad]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "自适应网格加密（AMR）是一种强大的技术，可以将计算资源集中在最需要的地方，例如浸入边界附近。然而，将AMR与浸入边界法相结合时需要特别小心，以确保物理量在不同网格层级间是守恒的。这项练习提供了一个动手实践的测试，用于验证粗细网格界面处的力守恒性，这是构建稳健的AMR-IB求解器的关键一步 ()。",
            "id": "3332792",
            "problem": "要求您设计并实现一种针对沉浸边界 (Immersed Boundary, IB) 的自适应网格加密 (Adaptive Mesh Refinement, AMR) 数值策略，以确保正则化宽度与网格间距的比率在不同层级间保持一致。您的目标是在二维设置中，当沉浸体穿过层级边界时，验证粗细网格界面上的守恒性。使用基于正则化 delta 核函数的扩散界面 IB 方法。\n\n基本原理和场景：\n- 从沉浸边界 (IB) 的耦合原理开始，该原理通过正则化的狄拉克 delta 函数将拉格朗日线力散布到欧拉网格上。在二维中，由线力密度为 $f_\\ell$ 的拉格朗日曲线 $\\Gamma$ 生成的欧拉力密度 $g(x,y)$ 可近似为\n$$\ng(x,y) \\approx \\int_{\\Gamma} f_\\ell \\, \\delta_\\varepsilon(x - X(s)) \\, \\delta_\\varepsilon(y - Y(s)) \\, \\mathrm{d}\\ell,\n$$\n其中 $(X(s),Y(s))$ 用弧长 $s$ 参数化曲线，$\\mathrm{d}\\ell$ 是线元，$\\delta_\\varepsilon$ 是宽度为 $\\varepsilon$ 的正则化一维 delta 核函数。在整个域上积分的欧拉总力应近似于在 $\\Gamma$ 上积分的拉格朗日总力：\n$$\n\\iint g(x,y)\\,\\mathrm{d}x\\,\\mathrm{d}y \\approx \\int_{\\Gamma} f_\\ell \\,\\mathrm{d}\\ell.\n$$\n- 使用升余弦正则化 delta 核函数\n$$\n\\delta_\\varepsilon(\\xi) = \\begin{cases}\n\\dfrac{1}{2\\varepsilon}\\left(1+\\cos\\left(\\dfrac{\\pi \\xi}{\\varepsilon}\\right)\\right),  |\\xi| \\le \\varepsilon, \\\\\n0,  \\text{其他情况},\n\\end{cases}\n$$\n以及二维散布核函数 $\\delta_\\varepsilon(x)\\delta_\\varepsilon(y)$。\n\nAMR 策略：\n- 在方形域 $[0,1] \\times [0,1]$ 上构建一个双层 AMR 层级结构，其中包含一个 $N_0 \\times N_0$ 的均匀粗网格，其单元中心点间距为 $\\Delta x_0=1/N_0$，以及一个单一的精细补丁（fine patch），其加密比为 $r$，因此精细网格间距为 $\\Delta x_1=\\Delta x_0/r$。精细补丁必须与粗网格对齐，由整数粗网格索引边界 $(i_{\\min}, i_{\\max})$ 和 $(j_{\\min}, j_{\\max})$ 定义，精细补丁覆盖这些粗网格单元所跨越的矩形区域。补丁对齐确保了网格的非重叠和嵌套。\n- 通过在每个层级 $\\ell \\in \\{0,1\\}$ 上设置 $\\varepsilon = k \\Delta x_\\ell$（使用相同的常数 $k$），来保持各层级间 $w/\\Delta x$ 的比率一致。\n\n沉浸体：\n- 使用一个圆形的沉浸边界，其中心为 $(x_c,y_c)$，半径为 $R$，线力密度 $f_\\ell$ 为常数。使用 $M$ 个按角度 $\\theta \\in [0,2\\pi)$（以弧度为单位）等距分布的点来离散化 $\\Gamma$。设离散弧长为 $\\Delta \\ell = 2\\pi R / M$。每个位于 $(X(\\theta), Y(\\theta)) = (x_c + R\\cos\\theta, y_c+R\\sin\\theta)$ 的拉格朗日点通过核函数对其附近的欧拉节点产生贡献。角度必须以弧度为单位。\n\n数值构造与守恒性测试：\n- 通过使用 $\\varepsilon_0 = k \\Delta x_0$ 将拉格朗日线力散布到粗网格的任何位置，计算纯粗网格欧拉场 $g_0$。\n- 通过使用 $\\varepsilon_1 = k \\Delta x_1$ 将拉格朗日线力散布到补丁内的精细网格节点，计算精细补丁欧拉场 $g_1$。\n- 将精细补丁外的粗网格贡献与补丁内的精细网格贡献相结合，形成复合 AMR 场。通过在相应区域上使用正确的单元面积（补丁外为 $\\Delta x_0^2$，补丁内为 $\\Delta x_1^2$）求和，来对复合场进行积分。\n- 将跨越粗细网格界面的相对守恒误差定义为\n$$\nE = \\frac{\\left| \\left( \\sum_{\\text{粗网格}\\setminus\\text{补丁}} g_0 \\, \\Delta x_0^2 + \\sum_{\\text{精细补丁}} g_1 \\, \\Delta x_1^2 \\right) - \\left( \\sum_{\\text{所有粗网格}} g_0 \\, \\Delta x_0^2 \\right) \\right|}{\\sum_{\\text{所有粗网格}} g_0 \\, \\Delta x_0^2}.\n$$\n当物体切割层级边界时，一个小的 $E$ 值表示跨越粗细网格界面的守恒性。\n\n单位与角度规定：\n- 没有物理单位；所有量都是无量纲的。所有角度必须以弧度为单位指定。\n\n实现细节：\n- 使用单元中心网格。粗网格单元中心位于 $(x_i,y_j)=((i+\\tfrac{1}{2})\\Delta x_0,(j+\\tfrac{1}{2})\\Delta x_0)$，其中 $i,j \\in \\{0,\\dots,N_0-1\\}$。精细补丁单元中心位于 $(x_{i'}^{(1)},y_{j'}^{(1)})=(x_{\\min}+(i'+\\tfrac{1}{2})\\Delta x_1,\\, y_{\\min}+(j'+\\tfrac{1}{2})\\Delta x_1)$，其中 $i' \\in \\{0,\\dots,(i_{\\max}-i_{\\min})r-1\\}$ 且 $j' \\in \\{0,\\dots,(j_{\\max}-j_{\\min})r-1\\}$，且 $x_{\\min}=i_{\\min}\\Delta x_0$，$y_{\\min}=j_{\\min}\\Delta x_0$。\n- 为提高计算效率，每个拉格朗日点应仅散布到由 $|\\xi|\\le\\varepsilon$（沿每个坐标轴）定义的核函数支撑域内的欧拉节点模板上。\n\n测试套件：\n实现您的程序，以评估以下四个测试用例的相对守恒误差 $E$。在所有情况下，使用 $f_\\ell = 1$ 和 $M=1000$。将最终结果报告为浮点数。\n\n1. 清晰切割补丁边界的理想情况：\n   - $N_0 = 64$, $r = 2$, $k = 2.0$, $(x_c,y_c)=(0.5,0.5)$, $R=0.23$.\n   - 粗网格补丁边界：$i_{\\min}=22$, $i_{\\max}=42$, $j_{\\min}=22$, $j_{\\max}=42$.\n\n2. 不同的 $k$ 值，同时保持 $w/\\Delta x$ 一致，且中心偏移导致非对称切割：\n   - $N_0 = 64$, $r = 2$, $k = 1.5$, $(x_c,y_c)=(0.45,0.5)$, $R=0.23$.\n   - 粗网格补丁边界：$i_{\\min}=22$, $i_{\\max}=42$, $j_{\\min}=22, j_{\\max}=42$.\n\n3. 物体几乎完全容纳在补丁内的边界情况：\n   - $N_0 = 64$, $r = 2$, $k = 2.0$, $(x_c,y_c)=(0.5,0.5)$, $R=0.15$.\n   - 粗网格补丁边界：$i_{\\min}=22$, $i_{\\max}=42$, $j_{\\min}=22, j_{\\max}=42$.\n\n4. 圆形与补丁角点相交的切角情况：\n   - $N_0 = 64$, $r = 2$, $k = 2.0$, $(x_c,y_c)=(0.35,0.35)$, $R=0.20$.\n   - 粗网格补丁边界：$i_{\\min}=22$, $i_{\\max}=42$, $j_{\\min}=22, j_{\\max}=42$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），其中每个结果对应相应测试用例的相对守恒误差 $E$（浮点数）。",
            "solution": "该问题要求设计并实现一个数值测试，用以验证在自适应网格加密 (AMR) 网格中使用扩散界面沉浸边界 (IB) 方法时的力守恒性。验证的核心是量化当沉浸体，更重要的是其数值支撑域，跨越粗网格与加密补丁之间的界面时，在该界面上引入的误差。一个小的误差表明总力是守恒的，这是流固耦合模拟物理真实性的一个关键属性。\n\n解决方案按以下原则构建：\n\n**1. 沉浸边界离散化与力散布**\n\n沉浸边界是一个以 $(x_c, y_c)$ 为中心、半径为 $R$ 的圆，由一组 $M$ 个离散的拉格朗日点表示。这些点按角度 $\\theta \\in [0, 2\\pi)$ 等距分布。第 $k$ 个拉格朗日点的坐标为 $(X_k, Y_k) = (x_c + R\\cos\\theta_k, y_c + R\\sin\\theta_k)$，其中 $\\theta_k = 2\\pi k / M$，$k = 0, \\dots, M-1$。\n\n连续的线力密度 $f_\\ell$被离散化为位于每个拉格朗日点上的点力 $F_k$。每个点代表一个长度为 $\\Delta\\ell = 2\\pi R / M$ 的小弧段。因此，每个点上的力为 $F_k = f_\\ell \\Delta\\ell$。物体上的总拉格朗日力是这些点力的总和，它近似于连续积分：\n$$\nF_{\\text{Lagrange}} = \\sum_{k=0}^{M-1} F_k = \\sum_{k=0}^{M-1} f_\\ell \\Delta\\ell = M f_\\ell \\frac{2\\pi R}{M} = 2\\pi R f_\\ell\n$$\nIB 方法通过将这些点力分布到附近的网格节点，将拉格朗日体与欧拉流体网格耦合起来。这种“散布”操作将离散的拉格朗日力转换为欧拉力密度场 $g(x,y)$。问题指定使用正则化的狄拉克 delta 函数 $\\delta_\\varepsilon$ 来实现此目的。欧拉网格节点 $(x_i, y_j)$ 处的力密度通过对所有拉格朗日点的贡献求和来计算：\n$$\ng_{i,j} = g(x_i, y_j) = \\sum_{k=0}^{M-1} F_k \\, \\delta_\\varepsilon(x_i - X_k) \\, \\delta_\\varepsilon(y_j - Y_k)\n$$\n函数 $\\delta_\\varepsilon(x)\\delta_\\varepsilon(y)$ 是一个二维张量积核函数。\n\n**2. 正则化 Delta 核函数**\n\n所选的核函数是升余弦函数：\n$$\n\\delta_\\varepsilon(\\xi) = \\begin{cases}\n\\dfrac{1}{2\\varepsilon}\\left(1+\\cos\\left(\\dfrac{\\pi \\xi}{\\varepsilon}\\right)\\right),  |\\xi| \\le \\varepsilon, \\\\\n0,  \\text{其他情况}。\n\\end{cases}\n$$\n该核函数具有宽度为 $2\\varepsilon$ 的有限支撑域。其零阶矩为 1 是守恒性的一个关键属性：\n$$\n\\int_{-\\infty}^{\\infty} \\delta_\\varepsilon(\\xi) \\, \\mathrm{d}\\xi = \\int_{-\\varepsilon}^{\\varepsilon} \\frac{1}{2\\varepsilon}\\left(1+\\cos\\left(\\frac{\\pi \\xi}{\\varepsilon}\\right)\\right) \\, \\mathrm{d}\\xi = \\frac{1}{2\\varepsilon} \\left[\\xi + \\frac{\\varepsilon}{\\pi}\\sin\\left(\\frac{\\pi\\xi}{\\varepsilon}\\right) \\right]_{-\\varepsilon}^{\\varepsilon} = 1\n$$\n此属性确保在散布力 $F_k$ 时，分布到欧拉网格上的总力积分回 $F_k$，即 $\\iint F_k \\delta_\\varepsilon(x-X_k)\\delta_\\varepsilon(y-Y_k) \\, \\mathrm{d}x\\mathrm{d}y = F_k$。\n\n**3. 自适应网格加密 (AMR) 网格结构**\n\n使用双层 AMR 网格。\n- 粗网格（层级 $\\ell=0$）覆盖整个域 $[0,1] \\times [0,1]$，包含 $N_0 \\times N_0$ 个单元。网格间距为 $\\Delta x_0 = 1/N_0$。\n- 精细网格（层级 $\\ell=1$）是一个覆盖域中子区域的补丁，由粗网格索引 $[i_{\\min}, i_{\\max})$ 和 $[j_{\\min}, j_{\\max})$ 定义。网格通过加密比 $r$ 进行加密，因此精细网格间距为 $\\Delta x_1 = \\Delta x_0/r$。\n\nAMR 策略要求核函数宽度 $\\varepsilon$ 与网格间距 $\\Delta x$ 的比率在不同层级间保持恒定。这通过为一个固定的常数 $k$ 设置 $\\varepsilon_\\ell = k \\Delta x_\\ell$ 来实现。因此，我们有用于粗网格的 $\\varepsilon_0 = k \\Delta x_0$ 和用于精细网格的 $\\varepsilon_1 = k \\Delta x_1$。这确保了散布操作的数值模板在两个层级上覆盖相同数量的网格单元，尽管其在精细网格上的物理尺寸更小。\n\n**4. 守恒性验证过程**\n\n验证过程涉及将在单个粗网格上计算的总力与在复合 AMR 网格上计算的总力进行比较。\n\n**步骤 A：基准粗网格计算**\n首先，使用核函数宽度 $\\varepsilon_0 = k \\Delta x_0$ 在整个 $N_0 \\times N_0$ 粗网格上计算欧拉力密度场 $g_0$。该网格上的总力通过数值积分（对所有单元求和）计算得出：\n$$\nF_{\\text{total},0} = \\sum_{i=0}^{N_0-1} \\sum_{j=0}^{N_0-1} (g_0)_{i,j} (\\Delta x_0)^2\n$$\n该值作为总力的参考值或“基准真相”。\n\n**步骤 B：复合 AMR 网格计算**\n接下来，在复合网格上计算总力。这涉及两个独立的计算：\n1.  **精细补丁贡献**：使用加密后的核函数宽度 $\\varepsilon_1 = k \\Delta x_1$ 在补丁内的精细网格节点上计算力密度场 $g_1$。此补丁的总力为：\n    $$\n    F_{\\text{fine patch}} = \\sum_{(i', j') \\in \\text{patch}} (g_1)_{i',j'} (\\Delta x_1)^2\n    $$\n2.  **粗网格贡献**：粗网格的贡献取自预先计算的场 $g_0$，但仅限于位于精细补丁区域*之外*的单元。\n    $$\n    F_{\\text{coarse}\\setminus\\text{patch}} = \\sum_{(i,j) \\notin \\text{patch}} (g_0)_{i,j} (\\Delta x_0)^2\n    $$\n复合 AMR 网格上的总力是这两个贡献的总和：\n$$\nF_{\\text{composite}} = F_{\\text{fine patch}} + F_{\\text{coarse}\\setminus\\text{patch}}\n$$\n\n**步骤 C：相对守恒误差**\n复合网格力与基准粗网格力之间的差异由相对误差 $E$ 量化：\n$$\nE = \\frac{\\left| F_{\\text{composite}} - F_{\\text{total},0} \\right|}{F_{\\text{total},0}}\n$$\n一个小的 $E$ 值表明数值方案是守恒的，意味着引入粗细网格界面不会导致总力的人为显著增加或损失。对于任何涉及守恒量的基于 AMR 的模拟，这都是一个关键的验证步骤。误差并非严格为零，这是由于网格之间的离散化误差存在差异，以及标准 IB 核函数不保守高阶矩，这可能在 AMR 界面上表现为不一致性。所提供的测试用例旨在探测在物体的“数值支撑域”跨越网格界面的各种场景下此误差的大小。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the AMR-IB conservation test for all specified cases.\n    \"\"\"\n\n    def delta_kernel(xi, epsilon):\n        \"\"\"\n        Computes the raised-cosine regularized delta kernel.\n        Vectorized to work on NumPy arrays.\n        \"\"\"\n        vals = np.zeros_like(xi, dtype=float)\n        mask = np.abs(xi) = epsilon\n        xi_masked = xi[mask]\n        vals[mask] = (1.0 / (2.0 * epsilon)) * (1.0 + np.cos(np.pi * xi_masked / epsilon))\n        return vals\n\n    def spread_force(lag_pts, lag_forces, x_coords, y_coords, epsilon):\n        \"\"\"\n        Spreads Lagrangian forces to a 2D Eulerian grid.\n        \n        Args:\n            lag_pts (np.ndarray): Array of Lagrangian point coordinates, shape (M, 2).\n            lag_forces (np.ndarray): Array of forces at each Lagrangian point, shape (M,).\n            x_coords (np.ndarray): 1D array of Eulerian grid x-coordinates.\n            y_coords (np.ndarray): 1D array of Eulerian grid y-coordinates.\n            epsilon (float): Kernel width.\n\n        Returns:\n            np.ndarray: 2D array of the Eulerian force density field.\n        \"\"\"\n        g = np.zeros((len(y_coords), len(x_coords)), dtype=float)\n        for i in range(lag_pts.shape[0]):\n            Xm, Ym = lag_pts[i]\n            Fm = lag_forces[i]\n            \n            # Vectorized computation of kernel values along each axis\n            dx_vals = Xm - x_coords\n            dy_vals = Ym - y_coords\n            \n            kernel_x = delta_kernel(dx_vals, epsilon)\n            kernel_y = delta_kernel(dy_vals, epsilon)\n            \n            # Use outer product to get 2D contribution and add to grid\n            # This is efficient as non-zero values are only in the stencil area\n            g += Fm * np.outer(kernel_y, kernel_x)\n            \n        return g\n\n    test_cases = [\n        # Case 1: Happy path\n        {'N0': 64, 'r': 2, 'k': 2.0, 'xc': 0.5, 'yc': 0.5, 'R': 0.23, 'imin': 22, 'imax': 42, 'jmin': 22, 'jmax': 42},\n        # Case 2: Different k, shifted center\n        {'N0': 64, 'r': 2, 'k': 1.5, 'xc': 0.45, 'yc': 0.5, 'R': 0.23, 'imin': 22, 'imax': 42, 'jmin': 22, 'jmax': 42},\n        # Case 3: Body nearly fits inside patch\n        {'N0': 64, 'r': 2, 'k': 2.0, 'xc': 0.5, 'yc': 0.5, 'R': 0.15, 'imin': 22, 'imax': 42, 'jmin': 22, 'jmax': 42},\n        # Case 4: Corner-cutting case\n        {'N0': 64, 'r': 2, 'k': 2.0, 'xc': 0.35, 'yc': 0.35, 'R': 0.20, 'imin': 22, 'imax': 42, 'jmin': 22, 'jmax': 42},\n    ]\n\n    fl = 1.0\n    M = 1000\n    results = []\n\n    for case in test_cases:\n        N0, r, k, xc, yc, R = case['N0'], case['r'], case['k'], case['xc'], case['yc'], case['R']\n        imin, imax, jmin, jmax = case['imin'], case['imax'], case['jmin'], case['jmax']\n\n        # 1. Define Lagrangian body\n        thetas = np.linspace(0, 2 * np.pi, M, endpoint=False)\n        lag_pts = np.array([xc + R * np.cos(thetas), yc + R * np.sin(thetas)]).T\n        delta_l = 2 * np.pi * R / M\n        lag_forces = np.full(M, fl * delta_l)\n\n        # 2. Define Coarse Grid\n        dx0 = 1.0 / N0\n        epsilon0 = k * dx0\n        coarse_coords_1d = (np.arange(N0) + 0.5) * dx0\n\n        # 3. Calculate Coarse-only solution (Baseline)\n        g0 = spread_force(lag_pts, lag_forces, coarse_coords_1d, coarse_coords_1d, epsilon0)\n        total_force_coarse = np.sum(g0) * dx0**2\n\n        # 4. Define Fine Patch Grid\n        dx1 = dx0 / r\n        epsilon1 = k * dx1\n        x_min_patch = imin * dx0\n        y_min_patch = jmin * dx0\n        Nx_fine = (imax - imin) * r\n        Ny_fine = (jmax - jmin) * r\n        \n        fine_x_coords = x_min_patch + (np.arange(Nx_fine) + 0.5) * dx1\n        fine_y_coords = y_min_patch + (np.arange(Ny_fine) + 0.5) * dx1\n        \n        # 5. Calculate fine patch force contribution\n        g1 = spread_force(lag_pts, lag_forces, fine_x_coords, fine_y_coords, epsilon1)\n        force_fine_patch = np.sum(g1) * dx1**2\n        \n        # 6. Calculate coarse grid contribution outside the patch\n        g0_outside_patch = g0.copy()\n        g0_outside_patch[jmin:jmax, imin:imax] = 0.0\n        force_coarse_outside = np.sum(g0_outside_patch) * dx0**2\n        \n        # 7. Calculate composite force and relative error\n        total_force_composite = force_fine_patch + force_coarse_outside\n        \n        if total_force_coarse == 0:\n            error = 0.0 if total_force_composite == 0 else np.inf\n        else:\n            error = np.abs(total_force_composite - total_force_coarse) / total_force_coarse\n\n        results.append(error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}