{
    "hands_on_practices": [
        {
            "introduction": "任何流体求解器的一个基本测试是其维持均匀流场（“自由流”）不变的能力。在任意拉格朗日-欧拉（ALE）框架中，由于网格的运动，这一特性并非自动满足，除非满足一个称为离散几何守恒律（DGCL）的特殊条件。这项练习  将通过第一性原理，引导您发现自由流守恒与 DGCL 之间的直接联系，并展示一个常见的实现错误（不一致的面速度）是如何破坏这一原则并产生伪影的。",
            "id": "3292275",
            "problem": "考虑在任意拉格朗日-欧拉（ALE）框架中，一个被动守恒标量 $q$ 在具有网格速度 $\\mathbf{w}$ 的移动网格上被恒定流体速度 $\\mathbf{u}$ 平流的有限体积法。从积分守恒律和雷诺输运定理出发，推导适用于有限体积离散化的 ALE 形式，并阐述在纯网格平移下保证均匀解不变性的离散条件。具体而言，使用以下基本依据：\n\n- 一个守恒标量在移动控制体 $V(t)$ 上的积分守恒律：$\\dfrac{\\mathrm{d}}{\\mathrm{d}t}\\int_{V(t)} q \\,\\mathrm{d}V + \\int_{\\partial V(t)} q\\, (\\mathbf{u}-\\mathbf{w})\\cdot \\mathbf{n} \\,\\mathrm{d}A = 0$。\n- 对于具有单位外法向量 $\\mathbf{n}$ 和面积元 $\\mathrm{d}A$ 的封闭曲面 $\\partial V$ 的恒等式：$\\int_{\\partial V} \\mathbf{n}\\,\\mathrm{d}A = \\mathbf{0}$。\n- 几何守恒律（GCL），其连续形式表述为 $\\dfrac{\\mathrm{d}}{\\mathrm{d}t}V(t) = \\int_{\\partial V(t)} \\mathbf{w}\\cdot \\mathbf{n} \\,\\mathrm{d}A$。\n\n从第一性原理出发，解释为什么任何一致的 ALE 离散格式都必须在纯网格平移 $\\mathbf{w} = \\mathbf{c}$（其中 $\\mathbf{c}$ 为恒定矢量）下，使均匀态 $q(\\mathbf{x},t) \\equiv q_0$ 保持不变，而这与恒定的流体速度 $\\mathbf{u}$ 无关。然后，设计一个能够检测由不一致的面扫描引起的违规情况的数值测试，并提出一种基于面平均 $\\mathbf{w}$ 的修正方法。\n\n您必须实现一个独立完整的程序，该程序针对一组构成结构化网格的二维矩形控制体，在一个时间步 $\\Delta t$ 后计算：\n- 定义为 $\\max_{K} \\left| q_K^{n+1} - q_0 \\right|$ 的不变性误差，其中 $q_K^{n+1}$ 是单元 $K$ 经过一次 ALE 更新后的单元平均值，$q_0$ 是均匀初始值。\n- 定义为 $\\max_{K} \\left| \\sum_{f\\subset \\partial K} \\mathbf{w}_f\\cdot \\mathbf{n}_f \\, L_f \\right|$ 的离散几何守恒残差，其中求和遍历单元 $K$ 的所有面 $f$，$\\mathbf{n}_f$ 是面 $f$ 的单位外法向量，$L_f$ 是面长度。\n\n您的离散格式必须对面积为 $V_K$ 的单元 $K$ 上的标量使用标准的有限体积 ALE 更新：\n- $V_K^{n+1} q_K^{n+1} = V_K^{n} q_K^{n} - \\Delta t \\sum_{f\\subset \\partial K} q_f \\, (\\mathbf{u} - \\mathbf{w}_f)\\cdot \\mathbf{n}_f \\, L_f$，\n其中对于均匀态和矩形单元，$q_f = q_K^{n}$，并且在纯平移下 $V_K^{n+1} = V_K^{n}$。\n\n为了暴露这种不一致性，请构建两种格式：\n- 一种不一致的面扫描格式，当从相邻单元观察时，它会为同一个几何面分配不同的 $\\mathbf{w}_f$。这是通过在 $\\mathbf{c}$ 上叠加故意引入的、按方向偏置的扰动实现的，从而使得即使在 $\\mathbf{w} = \\mathbf{c}$ 的情况下，$\\sum_{f} \\mathbf{w}_f\\cdot \\mathbf{n}_f \\, L_f \\neq 0$。\n- 一种修正格式，它为每个面分配从节点速度获得的面平均网格速度，在均匀平移下该速度精确等于 $\\mathbf{c}$，从而确保离散几何守恒。\n\n使用以下参数值测试套件，每个测试产生一个由两个浮点数 $[E,R]$ 组成的列表作为单一结果，其中 $E$ 是不变性误差，$R$ 是离散几何守恒残差：\n\n- 测试 1 (单单元，不一致格式): $N_x=1$, $N_y=1$, $h_x=1.0$, $h_y=1.0$, $\\mathbf{u} = \\mathbf{c} = [0.7,-0.3]$, $\\Delta t = 0.2$, $q_0 = 2.5$，使用不一致的面扫描格式。\n- 测试 2 (单单元，修正格式): 与测试 1 相同，但使用修正的面平均 $\\mathbf{w}$ 格式。\n- 测试 3 (多单元，不一致格式): $N_x=4$, $N_y=3$, $h_x=1.0$, $h_y=1.0$, $\\mathbf{u} = \\mathbf{c} = [0.7,-0.3]$, $\\Delta t = 0.2$, $q_0 = 2.5$，使用不一致的面扫描格式。\n- 测试 4 (多单元，修正格式): 与测试 3 相同，但使用修正的面平均 $\\mathbf{w}$ 格式。\n- 测试 5 (多单元，不一致格式, $\\mathbf{u}\\neq \\mathbf{c}$): $N_x=5$, $N_y=2$, $h_x=1.2$, $h_y=0.8$, $\\mathbf{u} = [0.2,0.1]$, $\\mathbf{c} = [0.7,-0.3]$, $\\Delta t = 0.3$, $q_0 = 1.0$，使用不一致的面扫描格式。\n- 测试 6 (多单元，修正格式, $\\mathbf{u}\\neq \\mathbf{c}$): 与测试 5 相同，但使用修正的面平均 $\\mathbf{w}$ 格式。\n\n您的程序应生成单行输出，其中包含以逗号分隔、无空格、并用方括号括起来的结果列表。每个测试用例的结果格式化为 $[E,R]$，所有结果汇总在一个列表中。例如：$[[E_1,R_1],[E_2,R_2],\\dots]$。所有量均为无量纲；无需进行物理单位转换。此公式中不涉及角度。\n\n为保证能够检测到问题，不一致的面扫描格式应按如下方式构造：对于每个具有从零开始的索引 $(i,j)$ 的单元，定义其四个面的外法向量和面长度如下\n- 左侧面: $\\mathbf{n}_L = [-1,0]$, $L_L = h_y$,\n- 右侧面: $\\mathbf{n}_R = [1,0]$, $L_R = h_y$,\n- 底面: $\\mathbf{n}_B = [0,-1]$, $L_B = h_x$,\n- 顶面: $\\mathbf{n}_T = [0,1]$, $L_T = h_x$,\n并将单元 $(i,j)$ 使用的面网格速度设置为\n- $\\mathbf{w}_R = \\mathbf{c} + [\\gamma_x (i+1), -\\gamma_y (j+1)]$,\n- $\\mathbf{w}_L = \\mathbf{c} + [-0.5\\,\\gamma_x (i+1), +0.25\\,\\gamma_y (j+1)]$,\n- $\\mathbf{w}_T = \\mathbf{c} + [0.1\\,\\gamma_x (i+1), +1.5\\,\\gamma_y (j+1)]$,\n- $\\mathbf{w}_B = \\mathbf{c} + [-0.2\\,\\gamma_x (i+1), -0.8\\,\\gamma_y (j+1)]$,\n其中 $\\gamma_x = 10^{-3}$ 且 $\\gamma_y = 2\\times 10^{-3}$。这将在每个单元上产生一个非零的离散几何守恒残差，从而导致一个可测量的的不变性误差。\n\n修正格式应对所有面 $f$ 赋以 $\\mathbf{w}_f = \\mathbf{c}$，这对应于均匀平移下的面平均节点速度。\n\n您的程序必须为所提供的测试精确实现这些计算，并以要求的格式打印汇总结果。",
            "solution": "该问题要求推导守恒被动标量的有限体积任意拉格朗日-欧拉（ALE）更新格式，并分析该格式保持均匀标量场所需的条件。这种保持特性，通常称为自由流保持特性，是任何有效数值格式的基本一致性要求。分析将证明，该特性与满足离散几何守恒律（DGCL）内在地联系在一起。\n\n出发点是标量 $q$ 在一个随时间变化的控制体 $V(t)$ 上的积分形式守恒律，该控制体边界为 $\\partial V(t)$，以速度 $\\mathbf{w}$ 移动。流体速度为 $\\mathbf{u}$。这是雷诺输运定理应用于守恒量的结果，在 ALE 框架下表示为：\n$$\n\\dfrac{\\mathrm{d}}{\\mathrm{d}t}\\int_{V(t)} q \\,\\mathrm{d}V + \\int_{\\partial V(t)} q\\, (\\mathbf{u}-\\mathbf{w})\\cdot \\mathbf{n} \\,\\mathrm{d}A = 0\n$$\n此处，$\\mathbf{n}$ 是指向外部的表面元 $\\mathrm{d}A$ 的单位法向量。\n\n对于有限体积离散化，我们将空间域划分为一组不重叠的控制体（或单元）$K$。对每个单元 $K$，我们在一个时间步内（从 $t^n$ 到 $t^{n+1} = t^n + \\Delta t$）对该方程进行积分。对时间导数使用一阶欧拉显式格式，我们得到：\n$$\n\\frac{1}{\\Delta t} \\left[ \\left(\\int_{V_K} q \\,\\mathrm{d}V\\right)^{n+1} - \\left(\\int_{V_K} q \\,\\mathrm{d}V\\right)^{n} \\right] + \\left(\\int_{\\partial V_K} q\\, (\\mathbf{u}-\\mathbf{w})\\cdot \\mathbf{n} \\,\\mathrm{d}A\\right)^n \\approx 0\n$$\n我们将单元平均标量定义为 $q_K(t) = \\frac{1}{V_K(t)} \\int_{V_K(t)} q(\\mathbf{x}, t) \\,\\mathrm{d}V$，其中 $V_K(t)$ 是单元 $K$ 的体积（在二维中为面积）。方程变为：\n$$\n\\frac{V_K^{n+1} q_K^{n+1} - V_K^n q_K^n}{\\Delta t} + \\sum_{f \\subset \\partial K} \\int_{A_f} q\\, (\\mathbf{u}-\\mathbf{w})\\cdot \\mathbf{n}_f \\,\\mathrm{d}A = 0\n$$\n单元边界 $\\partial V_K$ 上的面积分被替换为对单元各面 $f$ 的求和。通过用面平均值与面面积（在二维中为长度 $L_f$）的乘积来近似面积分，得到全离散更新格式：\n$$\nV_K^{n+1} q_K^{n+1} = V_K^{n} q_K^{n} - \\Delta t \\sum_{f\\subset \\partial K} q_f \\, (\\mathbf{u} - \\mathbf{w}_f)\\cdot \\mathbf{n}_f \\, L_f\n$$\n此处，$q_f$ 和 $\\mathbf{w}_f$ 是面 $f$ 上标量和网格速度的代表值。\n\n我们现在分析此格式保持均匀态 $q(\\mathbf{x}, t) \\equiv q_0$（其中 $q_0$ 为常数）所需的条件。在这种情况下，初始单元平均值完全相同，即对所有 $K$ 都有 $q_K^n = q_0$。一个简单且一致的面值选择是 $q_f = q_K^n = q_0$。将这些代入更新公式：\n$$\nV_K^{n+1} q_K^{n+1} = V_K^{n} q_0 - \\Delta t \\sum_{f\\subset \\partial K} q_0 \\, (\\mathbf{u} - \\mathbf{w}_f)\\cdot \\mathbf{n}_f \\, L_f\n$$\n将常数 $q_0$ 提取出来：\n$$\nV_K^{n+1} q_K^{n+1} = V_K^{n} q_0 - \\Delta t \\, q_0 \\sum_{f\\subset \\partial K} (\\mathbf{u} - \\mathbf{w}_f)\\cdot \\mathbf{n}_f \\, L_f\n$$\n求和项可以拆分为：\n$$\n\\sum_{f\\subset \\partial K} (\\mathbf{u} - \\mathbf{w}_f)\\cdot \\mathbf{n}_f \\, L_f = \\sum_{f\\subset \\partial K} \\mathbf{u}\\cdot \\mathbf{n}_f \\, L_f - \\sum_{f\\subset \\partial K} \\mathbf{w}_f\\cdot \\mathbf{n}_f \\, L_f\n$$\n由于流体速度 $\\mathbf{u}$ 是恒定的，右边的第一项变为 $\\mathbf{u} \\cdot \\left(\\sum_{f\\subset \\partial K} \\mathbf{n}_f L_f\\right)$。对于任何封闭的控制体，其指向外部、按面积（此处为长度）加权的法向量的矢量和为零。这是恒等式 $\\int_{\\partial V} \\mathbf{n}\\,\\mathrm{d}A = \\mathbf{0}$ 的离散等价形式。因此，$\\sum_{f\\subset \\partial K} \\mathbf{n}_f L_f = \\mathbf{0}$，包含 $\\mathbf{u}$ 的项完全消失。这是一个关键步骤：均匀态的不变性必须与流体速度无关。\n\n更新方程简化为：\n$$\nV_K^{n+1} q_K^{n+1} = V_K^{n} q_0 + \\Delta t \\, q_0 \\sum_{f\\subset \\partial K} \\mathbf{w}_f\\cdot \\mathbf{n}_f \\, L_f\n$$\n现在，我们引用几何守恒律（GCL）。其连续形式表明，控制体体积的变化率等于边界速度的通量：$\\frac{\\mathrm{d}V}{\\mathrm{d}t} = \\int_{\\partial V} \\mathbf{w}\\cdot\\mathbf{n}\\,\\mathrm{d}A$。通过与标量输运方程相同的方式对此定律进行离散化，可以得到一个一致的离散模拟形式，即离散几何守恒律（DGCL）：\n$$\n\\frac{V_K^{n+1} - V_K^n}{\\Delta t} = \\sum_{f\\subset \\partial K} \\mathbf{w}_f \\cdot \\mathbf{n}_f \\, L_f\n$$\n将此 DGCL 代入简化的 $q_K^{n+1}$ 更新方程中：\n$$\nV_K^{n+1} q_K^{n+1} = V_K^{n} q_0 + q_0 (V_K^{n+1} - V_K^n)\n$$\n$$\nV_K^{n+1} q_K^{n+1} = q_0 (V_K^n + V_K^{n+1} - V_K^n) = q_0 V_K^{n+1}\n$$\n假设单元体积 $V_K^{n+1}$ 非零，我们可以用它来除，从而得到期望的结果：\n$$\nq_K^{n+1} = q_0\n$$\n此推导表明，当且仅当数值格式满足离散几何守恒律时，均匀态 $q_0$ 才会保持不变。此条件确保了几何演化的数值离散与输运方程的离散相一致，从而防止仅因网格运动而产生标量 $q$ 的人为源或汇。\n\n对于纯网格平移的特定情况，网格速度在任何地方都是一个恒定矢量，即 $\\mathbf{w}(\\mathbf{x},t) = \\mathbf{c}$。从几何上看，任何单元的体积都保持不变，因此 $V_K^{n+1} = V_K^n$。于是 DGCL 要求：\n$$\n\\frac{V_K^{n+1} - V_K^n}{\\Delta t} = 0 = \\sum_{f\\subset \\partial K} \\mathbf{w}_f \\cdot \\mathbf{n}_f \\, L_f\n$$\n在纯网格平移下保证均匀解不变性的离散条件是，对于每个单元 $K$，都有 $\\sum_{f\\subset \\partial K} \\mathbf{w}_f \\cdot \\mathbf{n}_f \\, L_f = 0$。\n\n数值测试旨在暴露对此条件的违反情况。\n“修正”格式为每个几何面唯一定义了面速度 $\\mathbf{w}_f$，例如，定义为其节点速度的平均值。对于纯平移 $\\mathbf{w}=\\mathbf{c}$，所有节点都以速度 $\\mathbf{c}$ 移动，因此所有面速度均为 $\\mathbf{w}_f = \\mathbf{c}$。此时 DGCL 的和为 $\\sum_{f} \\mathbf{c} \\cdot \\mathbf{n}_f L_f = \\mathbf{c} \\cdot (\\sum_{f} \\mathbf{n}_f L_f) = \\mathbf{c} \\cdot \\mathbf{0} = 0$。该格式满足 DGCL 并将保持均匀态，从而产生零不变性误差和零 GCL 残差。\n\n“不一致”格式代表了一种常见的实现错误，其中面速度 $\\mathbf{w}_f$ 是从以单元为中心的视角计算的。所提供的公式故意向 $\\mathbf{c}$ 引入了微小的、依赖于单元索引的扰动。因此，对于两个单元之间的共享面，一个单元计算出的网格速度与其相邻单元计算出的不同。这种不一致性导致了非零和 $\\sum_{f \\subset \\partial K} \\mathbf{w}_f \\cdot \\mathbf{n}_f \\, L_f \\neq 0$。如推导所示，这种对 DGCL 的违反直接导致了更新后标量的误差，即 $|q_K^{n+1}-q_0| = \\frac{\\Delta t |q_0|}{V_K^n} |\\sum_f \\mathbf{w}_f \\cdot \\mathbf{n}_f L_f|$，该误差与 GCL 残差成正比。数值实现将计算此误差 $E$ 和残差 $R$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the ALE invariance test suite.\n    \"\"\"\n\n    test_cases = [\n        # Test 1 (single-cell, inconsistent)\n        {'Nx': 1, 'Ny': 1, 'hx': 1.0, 'hy': 1.0, 'u': np.array([0.7, -0.3]),\n         'c': np.array([0.7, -0.3]), 'dt': 0.2, 'q0': 2.5, 'inconsistent': True},\n        # Test 2 (single-cell, corrected)\n        {'Nx': 1, 'Ny': 1, 'hx': 1.0, 'hy': 1.0, 'u': np.array([0.7, -0.3]),\n         'c': np.array([0.7, -0.3]), 'dt': 0.2, 'q0': 2.5, 'inconsistent': False},\n        # Test 3 (multi-cell, inconsistent)\n        {'Nx': 4, 'Ny': 3, 'hx': 1.0, 'hy': 1.0, 'u': np.array([0.7, -0.3]),\n         'c': np.array([0.7, -0.3]), 'dt': 0.2, 'q0': 2.5, 'inconsistent': True},\n        # Test 4 (multi-cell, corrected)\n        {'Nx': 4, 'Ny': 3, 'hx': 1.0, 'hy': 1.0, 'u': np.array([0.7, -0.3]),\n         'c': np.array([0.7, -0.3]), 'dt': 0.2, 'q0': 2.5, 'inconsistent': False},\n        # Test 5 (multi-cell, inconsistent, u != c)\n        {'Nx': 5, 'Ny': 2, 'hx': 1.2, 'hy': 0.8, 'u': np.array([0.2, 0.1]),\n         'c': np.array([0.7, -0.3]), 'dt': 0.3, 'q0': 1.0, 'inconsistent': True},\n        # Test 6 (multi-cell, corrected, u != c)\n        {'Nx': 5, 'Ny': 2, 'hx': 1.2, 'hy': 0.8, 'u': np.array([0.2, 0.1]),\n         'c': np.array([0.7, -0.3]), 'dt': 0.3, 'q0': 1.0, 'inconsistent': False},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_simulation(**params)\n        all_results.append(result)\n\n    # Format the final output string exactly as specified.\n    result_strings = [f\"[{e},{r}]\" for e, r in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\ndef run_simulation(Nx, Ny, hx, hy, u, c, dt, q0, inconsistent):\n    \"\"\"\n    Computes invariance error and GCL residual for a given grid and scheme.\n    \"\"\"\n    \n    # Constants for the inconsistent scheme\n    gamma_x = 1e-3\n    gamma_y = 2e-3\n    \n    max_invariance_error = 0.0\n    max_gcl_residual = 0.0\n\n    # Cell volume (constant under pure translation)\n    V_K = hx * hy\n\n    # Iterate over all cells in the grid (i = x-index, j = y-index)\n    for j in range(Ny):\n        for i in range(Nx):\n            # Define faces: normal vector, length\n            faces_geom = {\n                'R': {'n': np.array([1.0, 0.0]), 'L': hy},   # Right\n                'L': {'n': np.array([-1.0, 0.0]), 'L': hy},  # Left\n                'T': {'n': np.array([0.0, 1.0]), 'L': hx},   # Top\n                'B': {'n': np.array([0.0, -1.0]), 'L': hx}   # Bottom\n            }\n\n            # Get mesh velocities for each face\n            if inconsistent:\n                # Indices for formula are 1-based\n                ip1 = i + 1\n                jp1 = j + 1\n                w_faces = {\n                    'R': c + np.array([gamma_x * ip1, -gamma_y * jp1]),\n                    'L': c + np.array([-0.5 * gamma_x * ip1, 0.25 * gamma_y * jp1]),\n                    'T': c + np.array([0.1 * gamma_x * ip1, 1.5 * gamma_y * jp1]),\n                    'B': c + np.array([-0.2 * gamma_x * ip1, -0.8 * gamma_y * jp1])\n                }\n            else: # Corrected scheme\n                w_faces = {\n                    'R': c, 'L': c, 'T': c, 'B': c\n                }\n\n            # Calculate sum of fluxes and GCL term for the cell\n            total_flux_term = 0.0\n            gcl_sum = 0.0\n\n            for face_key in faces_geom:\n                n_f = faces_geom[face_key]['n']\n                L_f = faces_geom[face_key]['L']\n                w_f = w_faces[face_key]\n\n                # Flux for q\n                # q_f * (u - w_f) . n_f * L_f\n                # For uniform state, q_f = q0\n                flux = q0 * np.dot(u - w_f, n_f) * L_f\n                total_flux_term += flux\n\n                # Geometric Conservation Law term\n                # w_f . n_f * L_f\n                gcl_term = np.dot(w_f, n_f) * L_f\n                gcl_sum += gcl_term\n\n            # Update q for the cell\n            # V_K * q_K^{n+1} = V_K * q_K^n - dt * sum(fluxes)\n            # Since q_K^n = q0, and V_K is constant\n            q_K_np1 = q0 - (dt / V_K) * total_flux_term\n\n            # Calculate cell-wise errors\n            cell_invariance_error = abs(q_K_np1 - q0)\n            cell_gcl_residual = abs(gcl_sum)\n\n            # Update maximums\n            if cell_invariance_error > max_invariance_error:\n                max_invariance_error = cell_invariance_error\n            \n            if cell_gcl_residual > max_gcl_residual:\n                max_gcl_residual = cell_gcl_residual\n\n    return [max_invariance_error, max_gcl_residual]\n\nsolve()\n```"
        },
        {
            "introduction": "在认识到几何守恒律（GCL）的重要性之后，我们现在将探讨一个更微妙但至关重要的方面：GCL 必须与用于物理守恒律的时间积分方案在时间上保持一致。这项练习  旨在量化当 GCL 未在常用的龙格-库塔（Runge-Kutta）方法等分阶段时间积分器中被正确执行时，像能量这样的物理守恒量会产生的显著误差。通过对比正确和不正确的实现，它突显了在几何更新和物理更新之间保持时间一致性的关键需求。",
            "id": "3292269",
            "problem": "您必须为一个活塞-气缸装置中的可压缩理想气体实现一个一维任意拉格朗日-欧拉（ALE）时间积分器，该装置的右侧活塞是移动的。左壁固定在位置 $x=0$ 处，右活塞的位置由 $x_p(t)=L(t)$ 指定。气体占据一个长度随时间变化的控制体积 $L(t)$，其横截面积等于 $1$，因此物理体积为 $V(t)=L(t)$。假设状态在所有时间上空间均匀，并由控制体积上的可压缩欧拉方程的积分形式控制。\n\n基本原理：\n- 质量守恒：对于不透水壁，控制体积内的质量是守恒的。如果 $\\rho(t)$ 是密度， $J(t)=L(t)$ 是雅可比行列式（体积），则有 $\\rho(t) J(t)=\\rho_0 J_0$，其中 $\\rho_0=\\rho(0)$ 且 $J_0=J(0)$。\n- 动量守恒：在两侧壁面压力相等且无净力的情况下，对于无净冲量的对称壁面，空间平均速度保持为零，即 $u(t)=0$。这与此处使用的均匀状态假设一致。\n- ALE形式的总能量守恒：控制体积 $[0,L(t)]$ 上的积分能量平衡给出\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\big(\\rho E\\,J\\big) \\;=\\; -\\big[u(\\rho E + p) - w\\,\\rho E\\big]\\big\\rvert_{x=L(t)} \\;+\\; \\big[u(\\rho E + p) - w\\,\\rho E\\big]\\big\\rvert_{x=0},\n$$\n其中 $E$ 是比总能，$p$ 是压力，$w$ 是网格（壁面）速度。在处处 $u=0$、固定壁面处 $w(0)=0$ 以及移动壁面处 $u(L)=w(L)=\\dot L(t)$ 的条件下，该方程简化为\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\big(\\rho E\\,J\\big) \\;=\\; -\\,\\dot L(t)\\,p(t).\n$$\n对于比热容比为 $\\gamma$ 的理想气体，$E = e + \\tfrac{1}{2}u^2$ 且 $e = \\dfrac{p}{(\\gamma-1)\\rho}$。在 $u=0$ 的情况下，单位质量的内能 $e$ 满足\n$$\n\\frac{\\mathrm{d}e}{\\mathrm{d}t} \\;=\\; -(\\gamma-1)\\,\\frac{\\dot L(t)}{L(t)}\\,e.\n$$\n这个常微分方程有精确解\n$$\ne(t) \\;=\\; e_0 \\left(\\frac{L(t)}{L_0}\\right)^{-(\\gamma-1)},\n$$\n其中 $e_0 = \\dfrac{p_0}{(\\gamma-1)\\rho_0}$，$L_0=L(0)$，$p_0=p(0)$。\n\n几何守恒律（GCL）与时间积分：\n- 在ALE龙格-库塔（RK）方法中，在RK的中间阶段强制执行几何守恒律（GCL）意味着几何量（如 $J(t)$ 和 $w(t)=\\dot L(t)$）必须在每个阶段时间点上进行一致的评估。对于上述常微分方程，这对应于在每个阶段时间点上计算系数 $-(\\gamma-1)\\,\\dot L(t)/L(t)$。\n- 一个常见的违规做法是在中间阶段不强制执行GCL，方法是在时间步开始时冻结几何形状，即对于从时间 $t_n$ 到 $t_{n+1}=t_n+\\Delta t$ 的一个步长的所有子阶段，都使用 $\\dot L(t_n)/L(t_n)$。这会在压力功的时间积分中产生偏差，从而导致最终内能出现误差。\n\n您的任务：\n1. 使用三阶强稳定保持龙格-库塔（SSP-RK3）方法，对常数时间步长 $\\Delta t$ 在 $t\\in[0,T]$ 区间上，为以下常微分方程实现一个时间积分器：\n$$\n\\frac{\\mathrm{d}e}{\\mathrm{d}t} \\;=\\; -(\\gamma-1)\\,\\frac{\\dot L(t)}{L(t)}\\,e,\n$$\n2. 实现右端项计算的两种变体：\n   - 在阶段上强制执行GCL：在每个龙格-库塔子阶段的时间点 $t_\\ast$ 上，计算 $\\dot L(t_\\ast)$ 和 $L(t_\\ast)$，并使用瞬时比率 $\\dot L(t_\\ast)/L(t_\\ast)$。\n   - 在中间阶段不强制执行GCL：对于从 $t_n$ 到 $t_{n+1}$ 的一个步长内的所有子阶段，无论阶段时间为何，都通过使用 $\\dot L(t_n)/L(t_n)$ 来冻结在 $t_n$ 时的几何形状。\n3. 对于下面测试套件中的每个测试用例，计算最终单位质量内能 $e(T)$（单位为 $\\mathrm{J/kg}$）相对于精确解\n$$\ne_{\\text{exact}}(T) \\;=\\; e_0 \\left(\\frac{L(T)}{L_0}\\right)^{-(\\gamma-1)}.\n$$\n的绝对误差。每个测试用例报告两个误差：首先是在阶段上强制执行GCL时的误差，然后是在中间阶段不强制执行GCL时的误差。\n\n物理参数和单位：\n- 使用 $\\gamma=1.4$，$\\rho_0=1.0\\,\\mathrm{kg/m^3}$，$p_0=100000\\,\\mathrm{Pa}$，因此 $e_0=\\dfrac{p_0}{(\\gamma-1)\\rho_0}$ 的单位是 $\\mathrm{J/kg}$。\n- 所有长度单位为 $\\mathrm{m}$，时间单位为 $\\mathrm{s}$，速度单位为 $\\mathrm{m/s}$。\n- 所需输出是单位质量内能的误差，单位为 $\\mathrm{J/kg}$。\n\n测试套件：\n- 测试 $1$（平滑的单周期正弦运动，返回初始长度）：$L_0=1.0\\,\\mathrm{m}$，$L(t)=L_0 + A\\sin\\big(2\\pi t/T\\big)$，其中 $A=0.1\\,\\mathrm{m}$，$T=1.0\\,\\mathrm{s}$，$\\Delta t = 0.01\\,\\mathrm{s}$。精确的 $L(T)=L_0$ 意味着 $e_{\\text{exact}}(T)=e_0$。\n- 测试 $2$（单调线性压缩）：$L_0=1.0\\,\\mathrm{m}$，$L(t)=L_0 - \\alpha t$ 在 $t\\in[0,T]$ 上，其中 $\\alpha=0.4\\,\\mathrm{m/s}$，$T=0.5\\,\\mathrm{s}$，因此 $L(T)=0.8\\,\\mathrm{m}$，$\\Delta t = 0.005\\,\\mathrm{s}$。\n- 测试 $3$（更快的、多周期的正弦运动，返回初始长度）：$L_0=1.0\\,\\mathrm{m}$，$L(t)=L_0 + A\\sin\\big(4\\pi t\\big)$，其中 $A=0.05\\,\\mathrm{m}$，$T=1.0\\,\\mathrm{s}$，$\\Delta t = 0.01\\,\\mathrm{s}$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的条目是浮点数，单位为 $\\mathrm{J/kg}$，顺序如下：\n$$\n[\\;\\text{err}_{\\text{GCL},1},\\;\\text{err}_{\\text{noGCL},1},\\;\\text{err}_{\\text{GCL},2},\\;\\text{err}_{\\text{noGCL},2},\\;\\text{err}_{\\text{GCL},3},\\;\\text{err}_{\\text{noGCL},3}\\;].\n$$\n每个 $\\text{err}$ 是绝对差值 $|e_{\\text{num}}(T)-e_{\\text{exact}}(T)|$，单位为 $\\mathrm{J/kg}$。",
            "solution": "该问题要求为一个活塞-气缸装置中的可压缩理想气体简化模型实现一个一维任意拉格朗日-欧拉（ALE）时间积分器。该问题在物理上和数学上都有明确的定义，为数值求解提供了清晰的路径。我们将首先概述其理论基础，然后是数值实现策略。\n\n物理系统包含一个控制体积 $V(t)$ 内的气体，其长度为 $L(t)$，横截面积为单位1。气体的状态（密度 $\\rho$、压力 $p$、比内能 $e$）被假设在所有时间上空间均匀。在指定的边界条件下（固定左壁处 $u(0)=0$, $w(0)=0$，移动右活塞处 $u(L)=w(L)=\\dot{L}(t)$），该系统的质量、动量和能量守恒定律得到显著简化。\n\n质量守恒定律 $\\rho(t) L(t) = \\rho_0 L_0$（其中 $\\rho_0 = \\rho(0)$ 和 $L_0 = L(0)$）表明体积内的总质量是恒定的。均匀状态假设和对称边界强迫导致平均流体速度为零，即 $u(t)=0$。\n\n问题的核心在于总能量守恒。ALE控制体积的积分能量平衡可简化为关于比内能 $e(t)$ 的常微分方程（ODE）。起点是ALE能量方程：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\big(\\rho E J\\big) = -[u(\\rho E + p) - w \\rho E]\\big|_{x=L(t)} + [u(\\rho E + p) - w \\rho E]\\big|_{x=0}\n$$\n其中 $E$ 是比总能，$p$ 是压力，$J=L(t)$ 是体积（一维中的雅可比行列式），$w$ 是网格速度。给定 $u(t)=0$，$E=e$，$w(0)=0$ 且 $w(L(t)) = \\dot{L}(t)$，该方程简化为：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\big(\\rho e L\\big) = - p(t) \\dot{L}(t)\n$$\n由于总质量 $M = \\rho L$ 是常数，我们有 $M \\frac{\\mathrm{d}e}{\\mathrm{d}t} = -p(t) \\dot{L}(t)$。使用理想气体状态方程 $p = (\\gamma-1)\\rho e$ 并代入 $\\rho = M/L(t)$，我们得到控制常微分方程：\n$$\nM \\frac{\\mathrm{d}e}{\\mathrm{d}t} = -(\\gamma-1)\\frac{M}{L(t)}e(t) \\dot{L}(t) \\implies \\frac{\\mathrm{d}e}{\\mathrm{d}t} = -(\\gamma-1)\\frac{\\dot{L}(t)}{L(t)}e(t)\n$$\n这是一个一阶线性齐次常微分方程。对于给定的初始条件 $e(0)=e_0$，通过分离变量法可以找到其精确解：\n$$\n\\int_{e_0}^{e(t)} \\frac{\\mathrm{d}e'}{e'} = -(\\gamma-1) \\int_{0}^{t} \\frac{\\dot{L}(\\tau)}{L(\\tau)} \\mathrm{d}\\tau \\implies \\ln\\left(\\frac{e(t)}{e_0}\\right) = -(\\gamma-1)\\ln\\left(\\frac{L(t)}{L_0}\\right)\n$$\n这给出了任意时刻 $t$ 的比内能的精确解：\n$$\ne(t) = e_0 \\left(\\frac{L(t)}{L_0}\\right)^{-(\\gamma-1)}\n$$\n初始比内能 $e_0$ 由初始条件计算得出，$e_0 = \\frac{p_0}{(\\gamma-1)\\rho_0}$。\n\n主要任务是使用三阶强稳定保持龙格-库塔（SSP-RK3）方法数值求解该常微分方程。该常微分方程的形式为 $\\frac{\\mathrm{d}e}{\\mathrm{d}t} = f(t, e)$，其中右端函数是 $f(t, e) = C(t) e(t)$，其含时系数为 $C(t) = -(\\gamma-1)\\frac{\\dot{L}(t)}{L(t)}$。\n从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的一个步长的SSP-RK3格式如下：\n\\begin{align*}\ne^{(1)} = e_n + \\Delta t \\, f(t_n, e_n) \\\\\ne^{(2)} = \\frac{3}{4} e_n + \\frac{1}{4} \\left( e^{(1)} + \\Delta t \\, f(t_n + \\Delta t, e^{(1)}) \\right) \\\\\ne_{n+1} = \\frac{1}{3} e_n + \\frac{2}{3} \\left( e^{(2)} + \\Delta t \\, f(t_n + \\frac{1}{2}\\Delta t, e^{(2)}) \\right)\n\\end{align*}\n我们必须实现两种计算函数 $f(t,e)$ 的变体：\n\n1.  **在阶段上强制执行GCL**：这是一种物理上和数值上都一致的方法。构成系数 $C(t)$ 的几何项 $L(t)$ 和 $\\dot{L}(t)$ 在龙格-库塔方法每个阶段所要求的特定时间点上进行计算。\n    -   对于 $e^{(1)}$，$C(t)$ 在 $t_n$ 处计算。\n    -   对于 $e^{(2)}$，$C(t)$ 在 $t_n + \\Delta t$ 处计算。\n    -   对于 $e_{n+1}$，$C(t)$ 在 $t_n + \\frac{1}{2}\\Delta t$ 处计算。\n\n2.  **在中间阶段不强制执行GCL**：这是一个常见的实现错误，即在时间步开始时将几何形状“冻结”。系数 $C(t_n) = -(\\gamma-1)\\frac{\\dot{L}(t_n)}{L(t_n)}$ 在时间 $t_n$ 计算一次，并用于该步长内的所有三个阶段。这在子阶段层面上违反了几何守恒律（GCL），并预计会在压力功项的时间积分中引入一阶误差，从而导致精度降低。\n\n对于每个测试用例，我们将使用这两种变体进行从 $t=0$ 到 $t=T$ 的时间积分。最终的数值结果 $e_{\\text{num}}(T)$ 将与精确解 $e_{\\text{exact}}(T)$ 进行比较，以计算绝对误差 $|e_{\\text{num}}(T) - e_{\\text{exact}}(T)|$。\n\n实现将包含一个主驱动函数，该函数会遍历指定的测试用例。对于每个用例，它将定义函数 $L(t)$ 和 $\\dot{L}(t)$，计算初始和精确的最终能量，并调用一个专用的求解器函数。该求解器将实现SSP-RK3时间步进循环，并包含在强制执行GCL和不执行GCL的变体之间切换的逻辑。最终输出将是按要求格式化的这些误差的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It computes the errors in internal energy for GCL-enforced and non-GCL\n    SSP-RK3 integration schemes and prints them in the required format.\n    \"\"\"\n\n    # Physical parameters\n    GAMMA = 1.4\n    RHO_0 = 1.0  # kg/m^3\n    P_0 = 100000.0  # Pa\n    # Initial specific internal energy\n    E_0 = P_0 / ((GAMMA - 1) * RHO_0)  # J/kg\n\n    def run_ssp_rk3_integration(L_func, L_dot_func, L0, T, dt, use_gcl):\n        \"\"\"\n        Performs time integration of the internal energy ODE using SSP-RK3.\n        \n        Args:\n            L_func (callable): Function L(t) for piston position.\n            L_dot_func (callable): Function dL/dt(t) for piston velocity.\n            L0 (float): Initial piston position.\n            T (float): Total integration time.\n            dt (float): Time step.\n            use_gcl (bool): If True, enforces GCL at sub-stages. Otherwise, freezes geometry.\n            \n        Returns:\n            float: The final specific internal energy e(T).\n        \"\"\"\n        num_steps = round(T / dt)\n        e = E_0\n        t = 0.0\n\n        for _ in range(num_steps):\n            if use_gcl:\n                # GCL-enforced at stages: evaluate geometry at each stage time.\n                # Stage 1\n                t1 = t\n                C1 = -(GAMMA - 1) * (L_dot_func(t1) / L_func(t1))\n                e_stage1 = e + dt * (C1 * e)\n\n                # Stage 2\n                t2 = t + dt\n                C2 = -(GAMMA - 1) * (L_dot_func(t2) / L_func(t2))\n                e_stage2 = 0.75 * e + 0.25 * (e_stage1 + dt * (C2 * e_stage1))\n\n                # Stage 3\n                t3 = t + 0.5 * dt\n                C3 = -(GAMMA - 1) * (L_dot_func(t3) / L_func(t3))\n                e_next = (1.0 / 3.0) * e + (2.0 / 3.0) * (e_stage2 + dt * (C3 * e_stage2))\n            else:\n                # No GCL at stages: freeze geometry at the start of the time step.\n                C_frozen = -(GAMMA - 1) * (L_dot_func(t) / L_func(t))\n                \n                # Stage 1\n                e_stage1 = e + dt * (C_frozen * e)\n\n                # Stage 2\n                e_stage2 = 0.75 * e + 0.25 * (e_stage1 + dt * (C_frozen * e_stage1))\n\n                # Stage 3\n                e_next = (1.0 / 3.0) * e + (2.0 / 3.0) * (e_stage2 + dt * (C_frozen * e_stage2))\n\n            e = e_next\n            t += dt\n        \n        return e\n\n    # Test suite definition\n    test_cases = [\n        {\n            \"name\": \"Test 1\",\n            \"L0\": 1.0, \"T\": 1.0, \"dt\": 0.01,\n            \"params\": {\"A\": 0.1},\n            \"L_func\": lambda t, L0, A: L0 + A * np.sin(2 * np.pi * t / 1.0),\n            \"L_dot_func\": lambda t, L0, A: A * (2 * np.pi / 1.0) * np.cos(2 * np.pi * t / 1.0),\n        },\n        {\n            \"name\": \"Test 2\",\n            \"L0\": 1.0, \"T\": 0.5, \"dt\": 0.005,\n            \"params\": {\"alpha\": 0.4},\n            \"L_func\": lambda t, L0, alpha: L0 - alpha * t,\n            \"L_dot_func\": lambda t, L0, alpha: -alpha,\n        },\n        {\n            \"name\": \"Test 3\",\n            \"L0\": 1.0, \"T\": 1.0, \"dt\": 0.01,\n            \"params\": {\"A\": 0.05},\n            \"L_func\": lambda t, L0, A: L0 + A * np.sin(4 * np.pi * t),\n            \"L_dot_func\": lambda t, L0, A: A * (4 * np.pi) * np.cos(4 * np.pi * t),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        L0, T, dt, params = case[\"L0\"], case[\"T\"], case[\"dt\"], case[\"params\"]\n        \n        # Create specific L(t) and L_dot(t) functions for this case\n        L = lambda t: case[\"L_func\"](t, L0, **params)\n        L_dot = lambda t: case[\"L_dot_func\"](t, L0, **params)\n        \n        # Calculate the exact solution at the final time T\n        L_final = L(T)\n        e_exact = E_0 * (L_final / L0) ** (-(GAMMA - 1))\n        \n        # Calculate numerical solution and error for the GCL-enforced case\n        e_num_gcl = run_ssp_rk3_integration(L, L_dot, L0, T, dt, use_gcl=True)\n        err_gcl = abs(e_num_gcl - e_exact)\n        results.append(err_gcl)\n\n        # Calculate numerical solution and error for the non-GCL case\n        e_num_nogcl = run_ssp_rk3_integration(L, L_dot, L0, T, dt, use_gcl=False)\n        err_nogcl = abs(e_num_nogcl - e_exact)\n        results.append(err_nogcl)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在处理了 ALE 的几何方面之后，我们现在转向流体动力学求解器本身。这项练习  演示了如何修改一个标准的欧拉黎曼求解器，使其适用于 ALE 框架。关键在于根据流体和运动网格之间的相对速度来重新表述问题。您将通过推导网格坐标系中的波速与物理实验室坐标系中实际激波速度之间的关键关系，获得构建 ALE 代码核心组件的实践经验。",
            "id": "3292307",
            "problem": "考虑以守恒形式写出的一维可压缩欧拉方程，其状态向量为 $U = [\\rho, \\rho u, E]^{\\top}$，其中 $\\rho$ 是质量密度，单位为 $\\mathrm{kg/m^3}$，$u$ 是速度，单位为 $\\mathrm{m/s}$，$E$ 是总能量密度，单位为 $\\mathrm{J/m^3}$。物理通量为 $F(U) = [\\rho u, \\rho u^2 + p, (E + p) u]^{\\top}$，对于比热比为 $\\gamma$ 的量热完全气体，其热力学封闭关系为 $E = \\dfrac{p}{\\gamma - 1} + \\dfrac{1}{2} \\rho u^2$。在任意拉格朗日-欧拉 (ALE) 格式中，界面以速度 $w$（网格速度，单位为 $\\mathrm{m/s}$）移动。在一个移动控制体上的 ALE 平衡法则导出了 ALE 通量 $F^{\\mathrm{ALE}}(U; w) = F(U) - w U$，并且网格坐标系中的波传播取决于相对速度 $(u - w)$。\n\n您的任务是为可压缩欧拉方程构建一个 Harten–Lax–van Leer–Contact (HLLC) 类型的近似 ALE 黎曼求解器，该求解器使用网格坐标系中的相对速度来估计左右波速，并产生与 ALE 格式一致的通量。您还必须分析当 $w$ 非零但无旋（即 $\\nabla \\times \\mathbf{w} = \\mathbf{0}$）时，实验室坐标系中的激波速度如何变化。在一维空间中，$w$ 是一个标量，因此根据其构造是无旋的。分析必须基于第一性原理，从守恒律和 Rankine–Hugoniot 跳跃条件出发，并且必须证明当 $w \\neq 0$ 时，网格坐标系和实验室坐标系中激波速度之间的关系。\n\n具体来说，请执行以下操作：\n\n1. 从守恒律和雷诺输运定理出发，推导一维 ALE 守恒律及相应的 ALE 通量 $F^{\\mathrm{ALE}}(U; w) = F(U) - w U$。解释 $(u - w)$ 在波速估计中的出现，并说明为什么 ALE 中所有的界面通量都取决于相对速度。\n2. 使用跨越以速度 $s$ 移动的间断的 Rankine–Hugoniot (RH) 跳跃条件，证明当 $w$ 在界面处无旋且均匀时，在网格坐标系中测量的激波速度 $s_{\\mathrm{rel}}$ 与实验室坐标系中的激波速度 $s_{\\mathrm{lab}}$ 之间的关系，并用 $s_{\\mathrm{rel}}$ 和 $w$ 表示 $s_{\\mathrm{lab}}$。您的推导必须完全基于 RH 跳跃条件和 ALE 通量定义。\n3. 实现一个 ALE-HLLC 黎曼求解器，该求解器使用网格坐标系中的 Davis 估计来估算左右波速：\n   a. 计算局部声速 $a_L = \\sqrt{\\gamma p_L / \\rho_L}$ 和 $a_R = \\sqrt{\\gamma p_R / \\rho_R}$。\n   b. 定义相对速度 $u_L' = u_L - w$ 和 $u_R' = u_R - w$。\n   c. 使用 $S_L = \\min(u_L' - a_L, u_R' - a_R)$ 和 $S_R = \\max(u_L' + a_L, u_R' + a_R)$。\n   d. 计算接触波速度 $S_M$ 和星区压力 $p_*$，使其与网格坐标系中的 HLLC 一致。您可以使用从动量平衡和星区状态一致性推导出的标准 HLLC 接触速度公式：\n   $$S_M = \\frac{p_R - p_L + \\rho_L u_L' (S_L - u_L') - \\rho_R u_R' (S_R - u_R')}{\\rho_L (S_L - u_L') - \\rho_R (S_R - u_R')}$$\n   以及\n   $$p_* = p_L + \\rho_L (S_L - u_L') (S_M - u_L') = p_R + \\rho_R (S_R - u_R') (S_M - u_R').$$\n   e. 通过比较 $p_*$ 与 $p_L$ 和 $p_R$ 来确定哪个外波是激波：如果 $p_* > p_L$，则左波是激波；如果 $p_* > p_R$，则右波是激波。\n   f. 将实验室坐标系中的激波速度报告为 $s_{\\mathrm{lab}} = s_{\\mathrm{rel}} + w$，其中 $s_{\\mathrm{rel}}$ 是网格坐标系中相应的外部波速（$S_L$ 或 $S_R$）。\n4. 对于下面的每个测试用例，计算实验室坐标系中的激波速度，并以 $\\mathrm{m/s}$ 为单位表示。如果由于两侧都是稀疏波而导致外波上不存在激波，则报告对应于压缩侧的外波速度（使用上述 HLLC 准则），否则返回外激波速度。在所有情况下，始终假设 $\\gamma = 1.4$。\n\n使用以下左右状态 $(\\rho, u, p)$ 和网格速度 $w$ 的测试套件：\n\n- 情况1（基准 Sod 类问题，网格静止）：$U_L = (\\rho_L, u_L, p_L) = (1.0, 0.0, 1.0 \\times 10^5)$，$U_R = (\\rho_R, u_R, p_R) = (0.125, 0.0, 1.0 \\times 10^4)$，$w = 0.0$。\n- 情况2（初始状态相同，网格向右移动）：$U_L = (1.0, 0.0, 1.0 \\times 10^5)$，$U_R = (0.125, 0.0, 1.0 \\times 10^4)$，$w = 50.0$。\n- 情况3（初始状态相同，网格向左移动）：$U_L = (1.0, 0.0, 1.0 \\times 10^5)$，$U_R = (0.125, 0.0, 1.0 \\times 10^4)$，$w = -30.0$。\n- 情况4（反向压力梯度，预计为左激波）：$U_L = (0.125, 0.0, 1.0 \\times 10^4)$，$U_R = (1.0, 0.0, 1.0 \\times 10^5)$，$w = 20.0$。\n- 情况5（非零速度，网格速度与左侧状态匹配）：$U_L = (1.0, 200.0, 1.2 \\times 10^5)$，$U_R = (0.4, 50.0, 5.0 \\times 10^4)$，$w = 200.0$。\n\n您的程序必须实现该求解器，并生成一行输出，其中包含五个案例的实验室坐标系激波速度的逗号分隔列表，单位为 $\\mathrm{m/s}$，并用方括号括起来，顺序与上述案例完全一致。输出格式必须为 $[s_1,s_2,s_3,s_4,s_5]$，其中每个 $s_i$ 是一个以 $\\mathrm{m/s}$ 为单位的浮点数，且无附加文本。此问题不涉及角度；无需指定角度单位。不涉及百分比；无需百分比格式。确保程序是自包含的，并且不需要输入。",
            "solution": "所提出的问题是有效的，因为它在科学上基于计算流体动力学的原理，是适定的和客观的。它为严谨的求解提供了完整且一致的数据和定义。我们将首先推导任意拉格朗日-欧拉 (ALE) 格式的理论基础，然后实现指定的数值求解器。\n\n### 1. ALE 守恒律的推导与解释\n\n任何连续介质力学问题的基础是守恒律。对于一个具有密度 $U$ 和单位面积物理通量 $F(U)$ 的通用守恒量，其在一维随时间移动的控制体 $V(t) = [x_a(t), x_b(t)]$ 上的积分形式为：\n$$\n\\frac{d}{dt} \\int_{x_a(t)}^{x_b(t)} U(x, t) \\,dx = F(U(x_a, t)) - F(U(x_b, t))\n$$\n左侧表示控制体内该物理量的总变化率，右侧是跨越其边界的净通量。边界的速度由 $\\frac{dx_a}{dt} = w_a$ 和 $\\frac{dx_b}{dt} = w_b$ 给出，其中 $w$ 是网格速度。\n\n对左侧应用莱布尼茨积分法则（雷诺输运定理的一种形式）可得：\n$$\n\\frac{d}{dt} \\int_{x_a(t)}^{x_b(t)} U(x, t) \\,dx = \\int_{x_a(t)}^{x_b(t)} \\frac{\\partial U}{\\partial t} \\,dx + U(x_b, t) \\frac{dx_b}{dt} - U(x_a, t) \\frac{dx_a}{dt}\n$$\n代入边界速度，我们有：\n$$\n\\frac{d}{dt} \\int_{x_a(t)}^{x_b(t)} U(x, t) \\,dx = \\int_{x_a(t)}^{x_b(t)} \\frac{\\partial U}{\\partial t} \\,dx + U(x_b, t) w_b - U(x_a, t) w_a\n$$\n将其与守恒律相等同：\n$$\n\\int_{x_a(t)}^{x_b(t)} \\frac{\\partial U}{\\partial t} \\,dx + U_b w_b - U_a w_a = F_a - F_b\n$$\n其中 $U_a = U(x_a, t)$，$F_a=F(U_a)$，依此类推。重新整理各项，按边界位置分组：\n$$\n\\int_{x_a(t)}^{x_b(t)} \\frac{\\partial U}{\\partial t} \\,dx = (F_a - w_a U_a) - (F_b - w_b U_b)\n$$\n我们将任意拉格朗日-欧拉 (ALE) 通量定义为 $F^{\\mathrm{ALE}}(U; w) = F(U) - wU$。方程变为：\n$$\n\\int_{x_a(t)}^{x_b(t)} \\frac{\\partial U}{\\partial t} \\,dx = F^{\\mathrm{ALE}}_a - F^{\\mathrm{ALE}}_b = -\\int_{x_a(t)}^{x_b(t)} \\frac{\\partial F^{\\mathrm{ALE}}}{\\partial x} \\,dx\n$$\n这意味着对于任何任意控制体 $V(t)$，\n$$\n\\int_{x_a(t)}^{x_b(t)} \\left( \\frac{\\partial U}{\\partial t} + \\frac{\\partial F^{\\mathrm{ALE}}}{\\partial x} \\right) \\,dx = 0\n$$\n从而得到 ALE 守恒律的微分形式：\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial}{\\partial x} \\left( F(U) - wU \\right) = 0\n$$\n该系统的特征波速是 ALE 通量雅可比矩阵 $A^{\\mathrm{ALE}} = \\frac{\\partial F^{\\mathrm{ALE}}}{\\partial U} = \\frac{\\partial F}{\\partial U} - wI$ 的特征值。对于欧拉方程，实验室坐标系雅可比矩阵 $\\frac{\\partial F}{\\partial U}$ 的特征值为 $u$、$u+a$ 和 $u-a$，其中 $u$ 是流体速度，$a$ 是声速。因此，$A^{\\mathrm{ALE}}$ 的特征值为 $(u-w)$、$(u-w)+a$ 和 $(u-w)-a$。这些波速是在网格的参考系中测量的。它们从根本上取决于流体相对于网格的相对速度 $u' = u-w$。这就是为什么在 ALE 背景下，所有波传播现象和相关的数值通量都自然地用这个相对速度来表示。\n\n### 2. 通过 Rankine–Hugoniot 条件建立激波速度关系\n\nRankine–Hugoniot (RH) 跳跃条件将间断（如激波）两侧的状态与其传播速度联系起来。对于一个通用守恒律 $\\frac{\\partial U}{\\partial t} + \\frac{\\partial G(U)}{\\partial x} = 0$，跨越以速度 $s$ 移动的间断的 RH 条件是 $s[U] = [G(U)]$，其中 $[q] = q_R - q_L$ 表示量 $q$ 的跳跃。\n\n在实验室（欧拉）坐标系中，守恒律为 $\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0$。对于以速度 $s_{\\mathrm{lab}}$ 移动的激波，RH 条件是：\n$$\ns_{\\mathrm{lab}}[U] = [F(U)]\n$$\n在 ALE 框架中，控制方程为 $\\frac{\\partial U}{\\partial t} + \\frac{\\partial F^{\\mathrm{ALE}}(U; w)}{\\partial x} = 0$。网格界面处的黎曼求解器在网格的参考系中运行。该求解器所见的波速是其相对于网格的速度，我们表示为 $s_{\\mathrm{rel}}$。相应的 RH 条件是：\n$$\ns_{\\mathrm{rel}}[U] = [F^{\\mathrm{ALE}}(U; w)] = [F(U) - wU]\n$$\n问题规定网格速度 $w$ 在界面处是无旋且均匀的，在一维中这意味着 $w$ 在间断处是连续的（$w_L = w_R = w$）。这允许我们写出 $[wU] = w[U]$。ALE 跳跃条件变为：\n$$\ns_{\\mathrm{rel}}[U] = [F(U)] - w[U]\n$$\n我们现在可以从实验室坐标系的 RH 条件中代入 $[F(U)]$ 的表达式：\n$$\ns_{\\mathrm{rel}}[U] = s_{\\mathrm{lab}}[U] - w[U]\n$$\n对于一个非平凡的激波，$[U] \\neq 0$，所以我们可以除以跳跃向量 $[U]$，得到标量关系：\n$$\ns_{\\mathrm{rel}} = s_{\\mathrm{lab}} - w\n$$\n这个方程表明，相对于网格的激波速度是实验室坐标系中的激波速度减去网格速度。重新整理得到实验室坐标系中的激波速度：\n$$\ns_{\\mathrm{lab}} = s_{\\mathrm{rel}} + w\n$$\n这个结果展示了速度的伽利略变换：在实验室中观察到的物理激波速度是其相对于移动网格的速度与网格本身速度之和。\n\n### 3. ALE-HLLC 黎曼求解器与测试用例分析\n\n我们现在在 ALE 框架内实现指定的 Harten–Lax–van Leer–Contact (HLLC) 近似黎曼求解器。该算法依赖于在网格坐标系中估计最快的左行和右行波速（$S_L$, $S_R$），然后重构中间“星区”的通量。\n\n每个测试用例的步骤如下：\na. 给定左右状态 $(\\rho_L, u_L, p_L)$ 和 $(\\rho_R, u_R, p_R)$ 以及网格速度 $w$。比热比为 $\\gamma = 1.4$。\nb. 计算声速：$a_K = \\sqrt{\\gamma p_K / \\rho_K}$，其中 $K \\in \\{L, R\\}$。\nc. 计算相对流体速度：$u'_K = u_K - w$。\nd. 使用 Davis 估计法估算网格坐标系中的波速：\n   $$S_L = \\min(u'_L - a_L, u'_R - a_R)$$\n   $$S_R = \\max(u'_L + a_L, u'_R + a_R)$$\ne. 使用从动量守恒跨接触面推导出的给定公式，计算网格坐标系中的接触波速度 $S_M$：\n   $$S_M = \\frac{p_R - p_L + \\rho_L u_L' (S_L - u_L') - \\rho_R u_R' (S_R - u_R')}{\\rho_L (S_L - u_L') - \\rho_R (S_R - u_R')}$$\nf. 计算星区压力 $p_*$。$S_M$ 的值的构造保证了 $p_*$ 的左右表达式之间的一致性：\n   $$p_* = p_L + \\rho_L (S_L - u_L') (S_M - u_L')$$\ng. 识别压缩波（激波）。如果 $p_* > p_L$，左波为激波，相对速度为 $s_{\\mathrm{rel}} = S_L$。如果 $p_* > p_R$，右波为激波，相对速度为 $s_{\\mathrm{rel}} = S_R$。对于给定的测试用例，一侧将是压缩的，另一侧是稀疏的。\nh. 使用推导的变换计算实验室坐标系中的激波速度：$s_{\\mathrm{lab}} = s_{\\mathrm{rel}} + w$。\n\n此过程将应用于每个测试用例，并计算最终的实验室坐标系激波速度。实现将此逻辑封装在一个可重用的函数中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the ALE-HLLC problem for all test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Format: ((rho_L, u_L, p_L), (rho_R, u_R, p_R), w)\n    test_cases = [\n        # Case 1: Sod-like, mesh at rest\n        ((1.0, 0.0, 1.0e5), (0.125, 0.0, 1.0e4), 0.0),\n        # Case 2: Sod-like, mesh moving right\n        ((1.0, 0.0, 1.0e5), (0.125, 0.0, 1.0e4), 50.0),\n        # Case 3: Sod-like, mesh moving left\n        ((1.0, 0.0, 1.0e5), (0.125, 0.0, 1.0e4), -30.0),\n        # Case 4: Reversed pressure, left shock expected\n        ((0.125, 0.0, 1.0e4), (1.0, 0.0, 1.0e5), 20.0),\n        # Case 5: Non-zero velocities\n        ((1.0, 200.0, 1.2e5), (0.4, 50.0, 5.0e4), 200.0),\n    ]\n\n    gamma = 1.4\n    results = []\n    for case in test_cases:\n        state_L, state_R, w = case\n        rho_L, u_L, p_L = state_L\n        rho_R, u_R, p_R = state_R\n\n        s_lab = calculate_lab_shock_speed(rho_L, u_L, p_L, rho_R, u_R, p_R, w, gamma)\n        results.append(s_lab)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_lab_shock_speed(rho_L, u_L, p_L, rho_R, u_R, p_R, w, gamma):\n    \"\"\"\n    Implements the ALE-HLLC Riemann solver to find the laboratory-frame shock speed.\n\n    Args:\n        rho_L, u_L, p_L: Density, velocity, and pressure of the left state.\n        rho_R, u_R, p_R: Density, velocity, and pressure of the right state.\n        w: Mesh velocity.\n        gamma: Ratio of specific heats.\n\n    Returns:\n        The laboratory-frame shock speed (s_lab) in m/s.\n    \"\"\"\n    # a. Compute local sound speeds\n    a_L = np.sqrt(gamma * p_L / rho_L)\n    a_R = np.sqrt(gamma * p_R / rho_R)\n\n    # b. Define the relative velocities\n    u_L_prime = u_L - w\n    u_R_prime = u_R - w\n\n    # c. Use Davis estimates for wave speeds in the mesh frame\n    S_L = min(u_L_prime - a_L, u_R_prime - a_R)\n    S_R = max(u_L_prime + a_L, u_R_prime + a_R)\n\n    # d. Compute the contact wave speed S_M and star pressure p_star\n    \n    # Numerator for S_M\n    num_S_M = (p_R - p_L + \n               rho_L * u_L_prime * (S_L - u_L_prime) - \n               rho_R * u_R_prime * (S_R - u_R_prime))\n\n    # Denominator for S_M\n    den_S_M = (rho_L * (S_L - u_L_prime) - \n               rho_R * (S_R - u_R_prime))\n    \n    # Avoid division by zero, though unlikely for these physical problems\n    if np.isclose(den_S_M, 0):\n        # Fallback, though not specified, this would indicate an issue.\n        # For the given problems, this case is not encountered.\n        S_M = (u_L_prime + u_R_prime) / 2.0 \n    else:\n        S_M = num_S_M / den_S_M\n\n    # Calculate star pressure p_star (using the left state)\n    p_star = p_L + rho_L * (S_L - u_L_prime) * (S_M - u_L_prime)\n\n    # e. Determine which of the outer waves is a shock\n    s_rel = 0.0\n    # Check for right-traveling shock\n    if p_star > p_R:\n        s_rel = S_R\n    # Check for left-traveling shock\n    elif p_star > p_L:\n        s_rel = S_L\n    else:\n        # This case suggests both waves are rarefactions or a numerical issue.\n        # Problem asks to report the compressive side even if no strong shock.\n        # For given test cases, p_star will be between p_L and p_R, but not\n        # smaller than both. One side will be compressive.\n        # If p_star > p_R, right is compressive. If p_star > p_L, left is.\n        # The logic above correctly handles this.\n        # Setting a default for completeness though it's not strictly needed for these cases.\n        # A more robust criterion might be needed for general cases.\n        pass\n\n    # f. Report the shock speed in the laboratory frame\n    s_lab = s_rel + w\n    \n    return s_lab\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}