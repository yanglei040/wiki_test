{
    "hands_on_practices": [
        {
            "introduction": "The drift-flux model provides a powerful framework for analyzing the macroscopic behavior of multiphase flows without resolving the fine details of the interface. A key application of this model is the prediction of transitions between flow regimes, such as the shift from bubbly to churn flow. This foundational exercise  guides you through an analytical derivation of a widely-used criterion for this transition, connecting a mathematical feature of the model—an inflection point on the holdup curve—to a profound physical change in the flow's structure.",
            "id": "3301455",
            "problem": "Consider upward vertical gas–liquid flow in a circular pipe within the framework of Computational Fluid Dynamics (CFD). Let the pipe inner diameter be $D = 0.05$ m, and the gravitational acceleration be $g = 9.81$ m s$^{-2}$. The mixture superficial velocity is fixed at $J = 1.0$ m s$^{-1}$, and the gas superficial velocity is $J_g$. The cross-sectional gas holdup is denoted by the void fraction $\\alpha$, with $0  \\alpha  1$. In the bubbly regime, take the distribution parameter to be a constant $C_0 = 1.20$. Assume the gas drift velocity follows a hindered rise scaling,\n$$\nV_{gj}(\\alpha) = \\beta \\sqrt{g D}\\,(1 - \\alpha)^{n},\n$$\nwith $\\beta = 0.50$ and $n = 2$. Starting from the standard drift-flux conceptualization and basic definitions of superficial velocities and phase holdup, derive the holdup relation $\\alpha(J_g)$ at fixed $J$. Then, determine the condition under which the curvature of the holdup curve $\\alpha(J_g)$ vanishes, and use it to obtain an explicit expression for the critical gas superficial velocity $J_g^{\\star}$ at the inflection point. Compute the numerical value of $J_g^{\\star}$ for the given parameters. Round your final answer to four significant figures and express it in m s$^{-1}$. Finally, provide a brief physical argument for why the appearance of this inflection coincides with the bubbly–churn transition, referencing the roles of hydrodynamic interaction, coalescence, and changes in phase distribution captured by the drift-flux framework.",
            "solution": "The problem statement is scientifically grounded, well-posed, objective, and provides a complete and consistent set of data and definitions. It is based on the established drift-flux model in multiphase flow, a core topic in computational fluid dynamics. The parameters are physically realistic. Therefore, the problem is deemed valid and a full solution is provided below.\n\nThe starting point is the standard Zuber-Findlay drift-flux model, which relates the gas superficial velocity $J_g$ to the cross-sectional void fraction $\\alpha$. The actual gas velocity $u_g$ is given by $u_g = J_g / \\alpha$. The model expresses $u_g$ in terms of the mixture superficial velocity $J$ and the gas drift velocity $V_{gj}$ as:\n$$\nu_g = C_0 J + V_{gj}\n$$\nwhere $C_0$ is the distribution parameter. Substituting the definition of $u_g$, we get a relation for $J_g$:\n$$\n\\frac{J_g}{\\alpha} = C_0 J + V_{gj}\n$$\nThe problem provides the gas drift velocity $V_{gj}$ as a function of the void fraction $\\alpha$:\n$$\nV_{gj}(\\alpha) = \\beta \\sqrt{g D}\\,(1 - \\alpha)^{n}\n$$\nSubstituting this expression for $V_{gj}$ into the drift-flux equation and solving for $J_g$ gives the holdup relation, which expresses $J_g$ as a function of $\\alpha$ for a fixed mixture velocity $J$:\n$$\nJ_g(\\alpha) = \\alpha (C_0 J + V_{gj}(\\alpha)) = \\alpha \\left( C_0 J + \\beta \\sqrt{g D}\\,(1 - \\alpha)^{n} \\right)\n$$\nThis can be written as:\n$$\nJ_g(\\alpha) = C_0 J \\alpha + \\beta \\sqrt{gD} \\alpha(1 - \\alpha)^{n}\n$$\nThis is the derived holdup relation between $J_g$ and $\\alpha$.\n\nNext, we are asked to find the condition under which the curvature of the holdup curve $\\alpha(J_g)$ vanishes. This occurs at an inflection point, where the second derivative is zero: $\\frac{d^2\\alpha}{dJ_g^2} = 0$.\nIt is mathematically more convenient to analyze the inverse function $J_g(\\alpha)$ and find the point where its second derivative with respect to $\\alpha$ is zero. The relationship between the second derivatives is given by:\n$$\n\\frac{d^2\\alpha}{dJ_g^2} = - \\frac{d^2J_g}{d\\alpha^2} \\left( \\frac{dJ_g}{d\\alpha} \\right)^{-3}\n$$\nFor a physically meaningful flow where $J_g$ is an increasing function of $\\alpha$, the first derivative $\\frac{dJ_g}{d\\alpha}$ is finite and non-zero. Therefore, the condition $\\frac{d^2\\alpha}{dJ_g^2} = 0$ is equivalent to the condition $\\frac{d^2J_g}{d\\alpha^2} = 0$.\n\nWe proceed by computing the first and second derivatives of $J_g(\\alpha)$ with respect to $\\alpha$. The first derivative is:\n$$\n\\frac{dJ_g}{d\\alpha} = \\frac{d}{d\\alpha} \\left[ C_0 J \\alpha + \\beta \\sqrt{gD} \\alpha(1-\\alpha)^n \\right]\n$$\n$$\n\\frac{dJ_g}{d\\alpha} = C_0 J + \\beta \\sqrt{gD} \\left[ 1 \\cdot (1-\\alpha)^n + \\alpha \\cdot n(1-\\alpha)^{n-1}(-1) \\right]\n$$\n$$\n\\frac{dJ_g}{d\\alpha} = C_0 J + \\beta \\sqrt{gD} (1-\\alpha)^{n-1} [ (1-\\alpha) - n\\alpha ]\n$$\n$$\n\\frac{dJ_g}{d\\alpha} = C_0 J + \\beta \\sqrt{gD} (1-\\alpha)^{n-1} [ 1 - (n+1)\\alpha ]\n$$\nNow, we compute the second derivative, $\\frac{d^2J_g}{d\\alpha^2}$:\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\frac{d}{d\\alpha} \\left[ C_0 J + \\beta \\sqrt{gD} (1-\\alpha)^{n-1} (1 - (n+1)\\alpha) \\right]\n$$\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\beta \\sqrt{gD} \\frac{d}{d\\alpha} \\left[ (1-\\alpha)^{n-1} - (n+1)\\alpha(1-\\alpha)^{n-1} \\right]\n$$\nUsing the product rule, we find:\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\beta \\sqrt{gD} \\left[ (n-1)(1-\\alpha)^{n-2}(-1) - (n+1) \\left( 1 \\cdot (1-\\alpha)^{n-1} + \\alpha(n-1)(1-\\alpha)^{n-2}(-1) \\right) \\right]\n$$\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\beta \\sqrt{gD} \\left[ -(n-1)(1-\\alpha)^{n-2} - (n+1)(1-\\alpha)^{n-1} + (n+1)(n-1)\\alpha (1-\\alpha)^{n-2} \\right]\n$$\nFactoring out the term $(1-\\alpha)^{n-2}$:\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\beta \\sqrt{gD} (1-\\alpha)^{n-2} \\left[ -(n-1) - (n+1)(1-\\alpha) + (n^2-1)\\alpha \\right]\n$$\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\beta \\sqrt{gD} (1-\\alpha)^{n-2} \\left[ (-n+1) - (n+1) + (n+1)\\alpha + (n^2-1)\\alpha \\right]\n$$\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\beta \\sqrt{gD} (1-\\alpha)^{n-2} \\left[ -2n + (n+n^2)\\alpha \\right]\n$$\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\beta \\sqrt{gD} n (1-\\alpha)^{n-2} \\left[ (n+1)\\alpha - 2 \\right]\n$$\nThe condition for the inflection point is $\\frac{d^2J_g}{d\\alpha^2} = 0$. Since $\\beta$, $g$, $D$, and $n$ are non-zero constants and we are interested in $\\alpha  1$, this condition simplifies to:\n$$\n(n+1)\\alpha - 2 = 0\n$$\nThis gives the critical void fraction, $\\alpha^{\\star}$, at the inflection point:\n$$\n\\alpha^{\\star} = \\frac{2}{n+1}\n$$\nThe critical gas superficial velocity, $J_g^{\\star}$, is found by evaluating $J_g(\\alpha^{\\star})$:\n$$\nJ_g^{\\star} = C_0 J \\alpha^{\\star} + \\beta \\sqrt{gD} \\alpha^{\\star}(1 - \\alpha^{\\star})^{n}\n$$\nSubstituting the expression for $\\alpha^{\\star}$:\n$$\nJ_g^{\\star} = C_0 J \\left(\\frac{2}{n+1}\\right) + \\beta \\sqrt{gD} \\left(\\frac{2}{n+1}\\right) \\left(1 - \\frac{2}{n+1}\\right)^{n}\n$$\n$$\nJ_g^{\\star} = \\frac{2 C_0 J}{n+1} + \\beta \\sqrt{gD} \\frac{2}{n+1} \\left(\\frac{n+1-2}{n+1}\\right)^{n}\n$$\nThis gives the final explicit expression for $J_g^{\\star}$:\n$$\nJ_g^{\\star} = \\frac{2 C_0 J}{n+1} + \\frac{2 \\beta \\sqrt{gD}}{n+1} \\left(\\frac{n-1}{n+1}\\right)^{n}\n$$\nNow, we compute the numerical value of $J_g^{\\star}$ using the given parameters: $D = 0.05$ m, $g = 9.81$ m s$^{-2}$, $J = 1.0$ m s$^{-1}$, $C_0 = 1.20$, $\\beta = 0.50$, and $n = 2$.\nFirst, we find the critical void fraction:\n$$\n\\alpha^{\\star} = \\frac{2}{2+1} = \\frac{2}{3}\n$$\nNext, we substitute the values into the expression for $J_g^{\\star}$:\n$$\nJ_g^{\\star} = \\frac{2 (1.20) (1.0)}{2+1} + \\frac{2 (0.50) \\sqrt{(9.81)(0.05)}}{2+1} \\left(\\frac{2-1}{2+1}\\right)^{2}\n$$\n$$\nJ_g^{\\star} = \\frac{2.40}{3} + \\frac{1.0 \\sqrt{0.4905}}{3} \\left(\\frac{1}{3}\\right)^{2}\n$$\n$$\nJ_g^{\\star} = 0.8 + \\frac{\\sqrt{0.4905}}{3} \\left(\\frac{1}{9}\\right) = 0.8 + \\frac{\\sqrt{0.4905}}{27}\n$$\nCalculating the numerical value:\n$$\nJ_g^{\\star} \\approx 0.8 + \\frac{0.70035708}{27} \\approx 0.8 + 0.02593915\n$$\n$$\nJ_g^{\\star} \\approx 0.82593915 \\, \\text{m s}^{-1}\n$$\nRounding to four significant figures, we get $J_g^{\\star} = 0.8259$ m s$^{-1}$.\n\nThe physical argument for the inflection point coinciding with the bubbly-churn transition is as follows. The drift-flux model is a macroscopic model that captures the average behavior of the two-phase mixture. The shape of the holdup curve $J_g(\\alpha)$ reflects the underlying physics of phase interaction.\nIn the bubbly flow regime, at low void fractions, the gas phase is dispersed as small, relatively independent bubbles in the continuous liquid phase. As $J_g$ increases, the number of bubbles increases, leading to a monotonic rise in $\\alpha$.\nThe term $V_{gj}(\\alpha) = \\beta \\sqrt{g D}\\,(1 - \\alpha)^{n}$ models the buoyant rise of bubbles, hindered by the presence of other bubbles (the $(1-\\alpha)^n$ term). As $\\alpha$ grows, hydrodynamic interactions become more significant. Bubbles get closer, increasing the probability of collision and coalescence.\nThe inflection point, defined by $\\frac{d^2J_g}{d\\alpha^2}=0$, represents a critical point in the system's stability. Physically, it is interpreted as the point where the rate of bubble coalescence becomes so significant that the dispersed bubbly flow structure is no longer stable. At void fractions beyond $\\alpha^{\\star}$, small bubbles rapidly merge to form large, distorted, cap-shaped bubbles. These larger bubbles have different rise velocities and interact with the flow in a fundamentally different way, leading to a more chaotic and intermittent regime known as churn flow (or slug flow in smaller diameter pipes).\nThe drift-flux model, despite its simplicity, captures this fundamental change in phase topology as a change in the curvature of the holdup relation. The inflection point is therefore a widely used theoretical criterion for predicting the transition from bubbly to churn flow, marking the limit of stability for the dispersed bubbly regime. It signifies the onset of large-scale structures in the gas phase.",
            "answer": "$$ \\boxed{0.8259} $$"
        },
        {
            "introduction": "Before constructing any classification model, we must ensure it adheres to fundamental physical laws. A cornerstone of mechanics is Galilean invariance, which dictates that physical laws are identical in all inertial reference frames, meaning that classification should depend on relative, not absolute, velocities. This computational exercise  challenges you to prove this principle by implementing two classifiers: one that correctly uses relative velocity and a naive one that does not, highlighting why the proper definition of characteristic velocity in dimensionless groups like $Re$, $Fr$, and $We$ is critical for a physically sound result.",
            "id": "3301432",
            "problem": "Consider two-phase Newtonian flows subjected to a uniform translation of the reference frame by an added constant velocity $U_0$ applied equally to both phases. According to Galilean invariance of Newtonian mechanics, classification of multiphase flow regimes should be independent of such uniform translations and depend only on nondimensional groups formed from physically meaningful relative velocities and material properties. Use the following context and tasks to design and implement a program that tests this invariance.\n\nStart from the governing principles: Newton's Second Law and the incompressible Navier–Stokes equations extended with gravity and surface tension for two-phase flows. Under nondimensionalization, three fundamental groups that capture the competition of inertia, gravity, and capillarity are the Reynolds number $Re$, the Froude number $Fr$, and the Weber number $We$, defined using a characteristic length $L$, a characteristic relative speed $U$ (the slip or interfacial relative speed), density $\\rho$, dynamic viscosity $\\mu$, gravitational acceleration $g$, and surface tension $\\sigma$:\n- $Re = \\dfrac{\\rho U L}{\\mu}$,\n- $Fr = \\dfrac{U}{\\sqrt{g L}}$,\n- $We = \\dfrac{\\rho U^2 L}{\\sigma}$.\n\nYour program must:\n1. Implement a regime classifier that depends only on the nondimensional groups $Re$, $Fr$, and $We$, computed from the relative speed $U$ and independent of a uniform added velocity $U_0$. This classifier must return one of the following regime labels: \"stratified\", \"bubbly\", \"slug\", \"annular\", or \"dispersed\", using the following deterministic decision rules:\n   - If $Fr  0.3$ and $We  1$, classify as \"stratified\".\n   - Else if $We \\ge 1$ and $Re  3000$ and $Fr  1$, classify as \"bubbly\".\n   - Else if $Re \\ge 3000$ and $We \\ge 10$, classify as \"annular\".\n   - Else if $Re \\ge 2000$ and $Fr \\ge 0.3$ and $We \\ge 1$, classify as \"slug\".\n   - Else classify as \"dispersed\".\n   When computing the nondimensional groups, use $U$ as the magnitude of the physically relevant relative velocity, i.e., use $|U|$.\n\n2. Implement a naive classifier with the same decision rules, but compute $Re$, $Fr$, and $We$ using the measured absolute speed $U_{\\text{meas}} = |U + U_0|$. This represents a frame-dependent procedure that violates Galilean invariance when $U_0 \\ne 0$.\n\n3. For each test case, evaluate the invariance of each classifier under a set of added uniform velocities $\\{U_0\\}$ by checking whether the classification label remains identical across all provided $U_0$ values. Return a boolean for each classifier indicating whether its classification is invariant across the set $\\{U_0\\}$.\n\nAll physical quantities must be treated with the following units:\n- $U$, $U_0$ in meters per second ($\\mathrm{m/s}$),\n- $L$ in meters ($\\mathrm{m}$),\n- $\\rho$ in kilograms per cubic meter ($\\mathrm{kg/m^3}$),\n- $\\mu$ in Pascal seconds ($\\mathrm{Pa\\cdot s}$),\n- $\\sigma$ in Newtons per meter ($\\mathrm{N/m}$),\n- $g$ in meters per second squared ($\\mathrm{m/s^2}$).\nNo angles are involved. The final outputs are booleans; no unit conversion is required for outputs.\n\nUse the following test suite of parameter sets. Each test case is specified as a tuple $(\\rho,\\mu,\\sigma,g,L,U;\\{U_0\\})$. For each case, compute the invariance boolean of the frame-invariant classifier and the invariance boolean of the naive classifier. The test suite covers a general case, boundary-sensitive cases, and edge cases:\n- Case A (general high-inertia, high-capillarity flow):\n  - $\\rho = 1000$, $\\mu = 0.001$, $\\sigma = 0.072$, $g = 9.81$, $L = 0.05$, $U = 1.2$, $\\{U_0\\} = \\{-2.0, 0.0, 3.0\\}$.\n- Case B (low $Fr$, moderate $We$, low $Re$ due to high viscosity):\n  - $\\rho = 1000$, $\\mu = 0.1$, $\\sigma = 0.072$, $g = 9.81$, $L = 0.2$, $U = 0.3$, $\\{U_0\\} = \\{-0.3, 0.0, 1.5\\}$.\n- Case C (very high $We$ and $Re$ when moving, sensitive to $U_0$):\n  - $\\rho = 1000$, $\\mu = 0.001$, $\\sigma = 0.02$, $g = 9.81$, $L = 0.01$, $U = 5.0$, $\\{U_0\\} = \\{-5.0, 0.0, 10.0\\}$.\n- Case D (edge case with zero relative speed):\n  - $\\rho = 1000$, $\\mu = 0.001$, $\\sigma = 0.072$, $g = 9.81$, $L = 0.05$, $U = 0.0$, $\\{U_0\\} = \\{-1.0, 0.0, 4.0\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and must itself be a two-element list $[b_1,b_2]$ where $b_1$ is the invariance boolean for the frame-invariant classifier, and $b_2$ is the invariance boolean for the naive classifier. For example, a valid output format is $[[\\text{True},\\text{False}],[\\text{True},\\text{True}]]$ for two cases.",
            "solution": "The appropriate fundamental base for this problem is Newton's Second Law and the incompressible Navier–Stokes equations with gravity and surface tension terms for two-phase flows. In a reference frame translated by a constant velocity $U_0$, Galilean invariance of Newtonian mechanics implies that the governing equations retain their form because a uniform addition to the velocity field does not alter spatial gradients nor relative velocities that drive advection, diffusion, or interfacial dynamics. Specifically, for a velocity field $\\mathbf{u}(\\mathbf{x},t)$, the transformation $\\mathbf{u}' = \\mathbf{u} + \\mathbf{U}_0$, with $\\mathbf{U}_0$ constant, leaves the convective derivative invariant in the sense that $\\left(\\partial_t + \\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}$ transforms to $\\left(\\partial_t + \\mathbf{u}'\\cdot\\nabla\\right)\\mathbf{u}'$ with identical physical predictions because $\\nabla\\mathbf{U}_0 = \\mathbf{0}$ and interfacial forces depend on curvature and relative motion.\n\nNondimensionalization of the Navier–Stokes equations with characteristic scales $U$ for relative speed, $L$ for length, and the material properties $\\rho$, $\\mu$, $g$, and $\\sigma$ yields the nondimensional groups $Re$, $Fr$, and $We$:\n$$\nRe = \\frac{\\rho U L}{\\mu},\\quad\nFr = \\frac{U}{\\sqrt{g L}},\\quad\nWe = \\frac{\\rho U^2 L}{\\sigma}.\n$$\nThese groups quantify the ratios of inertia to viscous forces, inertia to gravity, and inertia to surface tension, respectively. Crucially, the velocity scale $U$ must represent the relative or slip velocity relevant to interfacial transport and deformation, not the absolute velocity of the frame. Under a Galilean transformation $U \\mapsto U + U_0$ for a constant $U_0$ applied equally to both phases, the physically relevant $U$ that enters $Re$, $Fr$, and $We$ remains the magnitude of the relative speed $|U|$, so the nondimensional groups are invariant. Any classifier that depends only on these nondimensional groups constructed from $|U|$ will therefore be invariant under such uniform translations.\n\nTo test this principle computationally, we implement two classifiers:\n- A frame-invariant classifier that computes $Re$, $Fr$, and $We$ using $U_{\\text{rel}} = |U|$ and applies deterministic decision boundaries. Because $U_{\\text{rel}}$ does not change when we vary $U_0$, the resulting classification remains identical across all $U_0$ values, yielding an invariance boolean $b_1 = \\text{True}$ when checked across the set $\\{U_0\\}$.\n- A naive classifier that instead uses $U_{\\text{meas}} = |U + U_0|$ to compute the same nondimensional groups. This classifier incorrectly mixes frame-dependent information into the nondimensionalization. As $U_0$ varies, $U_{\\text{meas}}$ can change, altering $Re$, $Fr$, and $We$ and potentially crossing classification thresholds. The invariance boolean $b_2$ will be $\\text{False}$ whenever the label changes across $\\{U_0\\}$.\n\nWe use the decision rules specified in the problem for classification:\n1. If $Fr  0.3$ and $We  1$, return \"stratified\".\n2. Else if $We \\ge 1$ and $Re  3000$ and $Fr  1$, return \"bubbly\".\n3. Else if $Re \\ge 3000$ and $We \\ge 10$, return \"annular\".\n4. Else if $Re \\ge 2000$ and $Fr \\ge 0.3$ and $We \\ge 1$, return \"slug\".\n5. Else return \"dispersed\".\n\nAlgorithmic steps for each test case $(\\rho,\\mu,\\sigma,g,L,U;\\{U_0\\})$ are:\n- Compute $U_{\\text{rel}} = |U|$.\n- For the invariant classifier, compute $(Re,Fr,We)$ from $U_{\\text{rel}}$ and record the regime label for each $U_0 \\in \\{U_0\\}$ (which will be identical since $U_{\\text{rel}}$ is constant). Set $b_1$ to $\\text{True}$ if all labels match across $\\{U_0\\}$.\n- For the naive classifier, for each $U_0 \\in \\{U_0\\}$ compute $U_{\\text{meas}} = |U + U_0|$, then compute $(Re,Fr,We)$ from $U_{\\text{meas}}$ and record the label. Set $b_2$ to $\\text{True}$ only if all labels match across $\\{U_0\\}$; otherwise $\\text{False}$.\n\nWe analyze the test suite qualitatively:\n- Case A has large $Re$ and $We$ even at the smallest $U_{\\text{meas}}$, so both classifiers will likely return \"annular\" for all $U_0$. Thus $b_1 = \\text{True}$ and $b_2 = \\text{True}$.\n- Case B uses high viscosity $\\mu$ leading to low $Re$ at baseline $U$, yielding \"bubbly\". When $U_{\\text{meas}} = 0$ due to $U_0 = -U$, naive classification becomes \"stratified\", and for large $U_{\\text{meas}}$ it becomes \"annular\"; labels differ, so $b_2 = \\text{False}$. The invariant classifier remains \"bubbly\" for all $U_0$, so $b_1 = \\text{True}$.\n- Case C at $U_{\\text{meas}} = 0$ drops all groups to zero, yielding \"stratified\"; at nonzero $U_{\\text{meas}}$ it returns \"annular\"; $b_2 = \\text{False}$. The invariant classifier remains \"annular\" since it uses the fixed $U$ and is independent of $U_0$, hence $b_1 = \\text{True}$.\n- Case D has $U = 0$, so the invariant classifier always returns \"stratified\" regardless of $U_0$, so $b_1 = \\text{True}$. The naive classifier changes labels across $U_0$ (e.g., \"stratified\" at $U_{\\text{meas}} = 0$ and a high-inertia label at larger $U_{\\text{meas}}$), so $b_2 = \\text{False}$.\n\nTherefore, the expected single-line output is a list of two-element lists $[b_1,b_2]$ for each case. The program computes these booleans explicitly from the provided parameters and prints them in the required format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_dimensionless_groups(rho, mu, sigma, g, L, U_mag):\n    \"\"\"\n    Compute Reynolds, Froude, and Weber numbers using magnitude of the velocity.\n    \"\"\"\n    Re = (rho * U_mag * L) / mu\n    Fr = U_mag / np.sqrt(g * L) if g  0 and L  0 else np.inf\n    We = (rho * (U_mag ** 2) * L) / sigma if sigma  0 else np.inf\n    return Re, Fr, We\n\ndef classify_regime(Re, Fr, We):\n    \"\"\"\n    Deterministic regime classification based on provided thresholds.\n    \"\"\"\n    if (Fr  0.3) and (We  1.0):\n        return \"stratified\"\n    elif (We = 1.0) and (Re  3000.0) and (Fr  1.0):\n        return \"bubbly\"\n    elif (Re = 3000.0) and (We = 10.0):\n        return \"annular\"\n    elif (Re = 2000.0) and (Fr = 0.3) and (We = 1.0):\n        return \"slug\"\n    else:\n        return \"dispersed\"\n\ndef invariance_boolean_for_case(rho, mu, sigma, g, L, U_rel, U0_list):\n    \"\"\"\n    Returns (b1, b2):\n    b1: invariance boolean for frame-invariant classifier (uses U_rel magnitude only)\n    b2: invariance boolean for naive classifier (uses |U_rel + U0| for each U0)\n    \"\"\"\n    # Frame-invariant classifier: uses |U_rel| always\n    invariant_labels = []\n    U_rel_mag = abs(U_rel)\n    for _ in U0_list:\n        Re, Fr, We = compute_dimensionless_groups(rho, mu, sigma, g, L, U_rel_mag)\n        invariant_labels.append(classify_regime(Re, Fr, We))\n    b1 = all(label == invariant_labels[0] for label in invariant_labels)\n\n    # Naive classifier: uses |U_rel + U0| for each U0\n    naive_labels = []\n    for U0 in U0_list:\n        U_meas_mag = abs(U_rel + U0)\n        Re, Fr, We = compute_dimensionless_groups(rho, mu, sigma, g, L, U_meas_mag)\n        naive_labels.append(classify_regime(Re, Fr, We))\n    b2 = all(label == naive_labels[0] for label in naive_labels)\n\n    return b1, b2\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is: (rho, mu, sigma, g, L, U_rel, [U0_list])\n    test_cases = [\n        # Case A\n        (1000.0, 0.001, 0.072, 9.81, 0.05, 1.2, [-2.0, 0.0, 3.0]),\n        # Case B\n        (1000.0, 0.1,   0.072, 9.81, 0.2,  0.3, [-0.3, 0.0, 1.5]),\n        # Case C\n        (1000.0, 0.001, 0.02,  9.81, 0.01, 5.0, [-5.0, 0.0, 10.0]),\n        # Case D\n        (1000.0, 0.001, 0.072, 9.81, 0.05, 0.0, [-1.0, 0.0, 4.0]),\n    ]\n\n    results = []\n    for case in test_cases:\n        rho, mu, sigma, g, L, U_rel, U0_list = case\n        b1, b2 = invariance_boolean_for_case(rho, mu, sigma, g, L, U_rel, U0_list)\n        results.append([b1, b2])\n\n    # Final print statement in the exact required format.\n    # Single line: list of [b1,b2] pairs for each test case.\n    def bool_to_str(b): return \"True\" if b else \"False\"\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join([bool_to_str(x) for x in pair]) + \"]\" for pair in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        },
        {
            "introduction": "The convergence of high-fidelity simulation and data science enables the creation of sophisticated, data-driven flow classifiers. The success of such models depends on designing features that capture the essential physics separating different regimes, often involving interface morphology and turbulence statistics. In this advanced practice , you will develop a feature space from physical principles—including interface curvature statistics and the spectral energy of the phase field—and train a support vector classifier to distinguish between bubbly and churn regimes, bridging the gap between classical fluid dynamics and modern machine learning applications in CFD.",
            "id": "3301488",
            "problem": "You are given the task of building and evaluating a binary classifier that distinguishes between bubbly and churn flow regimes using features derived from Volume of Fluid (VOF) multiphase simulations. The classification is to be performed for liquid Reynolds numbers in the range $Re_l \\in [10^4, 10^5]$. Your solution must begin from first principles in fluid mechanics and turbulence, translate them into a reproducible feature construction for the VOF indicator field, and then implement a support vector classifier trained on synthetic, physics-informed features. The final program must produce a single line of output containing the predicted class labels for a specified test suite.\n\nThe fundamental base to use includes: (i) the definition of the Reynolds number $Re_l = \\rho_l U_l L/\\mu_l$, (ii) the definition of the VOF phase indicator field $\\alpha(\\mathbf{x},t) \\in [0,1]$ and its interface curvature $\\kappa(\\mathbf{x},t)$ via the divergence of the unit normal to the interface, (iii) qualitative differences between bubbly and churn regimes observed in experiments and resolved simulations, namely differences in bubble breakup frequency, interface curvature statistics, and $\\alpha$-field spectral content across scales. You must use these fundamentals to justify how to construct dimensionless features that vary with $Re_l$ and gas volume fraction $\\phi \\in (0,1)$ without reference to any raw simulation dataset. You must not assume access to any external data.\n\nConstruct a dimensionless feature vector $\\mathbf{f} \\in \\mathbb{R}^5$ composed of the following components, all computed as dimensionless quantities:\n- $f_1$: mean absolute interface curvature scaled by a characteristic length (so it is dimensionless).\n- $f_2$: skewness of the probability density function (PDF) of the interface curvature field.\n- $f_3$: a dimensionless bubble count rate per unit time, scaled into a Strouhal-like form.\n- $f_4$: the spectral slope $p$ of the azimuthally integrated spectral energy density of the $\\alpha$-field in an intermediate wavenumber band (so that $E_\\alpha(k) \\sim k^{-p}$ over that band).\n- $f_5$: the fraction of spectral energy of the $\\alpha$-field above a high-wavenumber threshold relative to the total.\n\nTo make the exercise numerically concrete and reproducible, assume the following calibrated, dimensionless feature models that are consistent with the above physics. Let $s = \\log_{10}(Re_l/10^4)$ and $\\phi \\in [0.05, 0.30]$. For each regime $r \\in \\{0,1\\}$, where $r=0$ denotes bubbly and $r=1$ denotes churn, define\n$$\n\\begin{aligned}\nf_1(r; Re_l) = \n\\begin{cases}\n0.80 + 0.20\\, s + n_1,  r=0,\\\\\n1.50 + 0.30\\, s + n_1,  r=1,\n\\end{cases}\n\\\\\nf_2(r; Re_l) = \n\\begin{cases}\n0.70 - 0.10\\, s + n_2,  r=0,\\\\\n0.10 - 0.05\\, s + n_2,  r=1,\n\\end{cases}\n\\\\\nf_3(r; Re_l, \\phi) = \n\\begin{cases}\n0.50 + 0.20\\, \\phi + 0.30\\, s + n_3,  r=0,\\\\\n1.20 + 0.50\\, \\phi + 0.50\\, s + n_3,  r=1,\n\\end{cases}\n\\\\\nf_4(r; \\phi) = \n\\begin{cases}\n1.65 + 0.05\\, \\phi + n_4,  r=0,\\\\\n1.30 + 0.10\\, \\phi + n_4,  r=1,\n\\end{cases}\n\\\\\nf_5(r; Re_l) = \n\\begin{cases}\n0.15 + 0.05\\, s + n_5,  r=0,\\\\\n0.35 + 0.10\\, s + n_5,  r=1,\n\\end{cases}\n\\end{aligned}\n$$\nwith independent Gaussian perturbations $n_i \\sim \\mathcal{N}(0,\\sigma_i^2)$, where $(\\sigma_1,\\sigma_2,\\sigma_3,\\sigma_4,\\sigma_5) = (0.03, 0.05, 0.04, 0.02, 0.03)$. All features are dimensionless. These forms encode the trends that, as $Re_l$ increases, churn exhibits higher curvature magnitude, a broader and less skewed curvature PDF, higher bubble count rates, flatter intermediate-band spectral slopes, and larger high-wavenumber energy fractions than bubbly flows.\n\nTrain a linear Support Vector Classifier (SVC) by minimizing the $\\ell_2$-regularized hinge-loss primal objective\n$$\n\\min_{\\mathbf{w}, b}\\; \\frac{\\lambda}{2}\\|\\mathbf{w}\\|_2^2 + \\frac{1}{m} \\sum_{i=1}^{m} \\max\\left(0,\\, 1 - y_i(\\mathbf{w}^\\top \\mathbf{x}_i + b)\\right),\n$$\nwhere $\\mathbf{x}_i \\in \\mathbb{R}^5$ are standardized features, $y_i \\in \\{-1,+1\\}$ are class labels mapped from regimes by $y= -1$ for bubbly and $y=+1$ for churn, $\\lambda  0$ is the regularization parameter, and $m$ is the number of training samples. Use a stochastic subgradient method consistent with the Pegasos algorithm, with step size $\\eta_t = 1/(\\lambda t)$ at iteration $t$ and with the bias $b$ updated only when the margin is violated. Standardize the features to zero mean and unit variance using only the training set statistics.\n\nYour program must:\n- Generate a synthetic training dataset of size $m = 400$ with $m/2$ samples per regime, by drawing $Re_l$ uniformly in $\\log_{10}$ over $[10^4, 10^5]$ and $\\phi$ uniformly over $[0.05, 0.30]$, then sampling $\\mathbf{f}$ using the above model with a fixed pseudo-random seed for reproducibility. Map regimes $r \\in \\{0,1\\}$ to labels $y \\in \\{-1,+1\\}$ as specified.\n- Train a linear SVC using the stochastic subgradient method on standardized features with regularization parameter $\\lambda = 10^{-2}$ and $T = 20000$ iterations, starting from $\\mathbf{w}=\\mathbf{0}$ and $b=0$.\n- Apply the trained classifier to the following test suite, where each case provides $(Re_l, \\phi, r_{\\text{true}})$; use $r_{\\text{true}}$ only to synthesize the features, not in prediction:\n    1. $(Re_l = 10^4,\\; \\phi = 0.05,\\; r_{\\text{true}}=0)$\n    2. $(Re_l = 1.5 \\times 10^4,\\; \\phi = 0.10,\\; r_{\\text{true}}=0)$\n    3. $(Re_l = 5 \\times 10^4,\\; \\phi = 0.20,\\; r_{\\text{true}}=1)$\n    4. $(Re_l = 8 \\times 10^4,\\; \\phi = 0.15,\\; r_{\\text{true}}=1)$\n    5. $(Re_l = 10^5,\\; \\phi = 0.25,\\; r_{\\text{true}}=1)$\n    6. $(Re_l = 2 \\times 10^4,\\; \\phi = 0.30,\\; r_{\\text{true}}=0)$\n    7. $(Re_l = 7 \\times 10^4,\\; \\phi = 0.05,\\; r_{\\text{true}}=1)$\n    8. $(Re_l = 1.2 \\times 10^4,\\; \\phi = 0.20,\\; r_{\\text{true}}=0)$\n- Produce predictions $\\hat{r} \\in \\{0,1\\}$ by thresholding the decision function at zero, mapping $+1 \\mapsto 1$ and $-1 \\mapsto 0$.\n\nFinal output format: Your program should produce a single line of output containing the predicted class labels for the $8$ test cases as a comma-separated list of integers enclosed in square brackets, for example, $[0,1,1,0,1,0,1,0]$. No additional text may be printed. All quantities in this task are dimensionless; no physical units are required in the output.",
            "solution": "The objective is to construct and evaluate a binary classifier to distinguish between bubbly ($r=0$) and churn ($r=1$) multiphase flow regimes. The classifier, a linear Support Vector Classifier (SVC), will be trained on a synthetic dataset whose features are derived from first principles in fluid mechanics. The entire process, from feature justification to algorithmic implementation, is designed to be self-contained and reproducible.\n\n### 1. Physics-Informed Feature Construction\n\nThe problem statement requires the construction of a $5$-dimensional dimensionless feature vector $\\mathbf{f} \\in \\mathbb{R}^5$ based on the physical differences between bubbly and churn flows, as observed in high-fidelity Volume of Fluid (VOF) simulations. The VOF method uses a phase indicator field, $\\alpha(\\mathbf{x}, t)$, which is $1$ in one phase (e.g., liquid) and $0$ in the other (e.g., gas), with intermediate values $0  \\alpha  1$ representing the interface. The features are designed to capture key statistical and morphological differences in this field between the two regimes.\n\n-   **$f_1$: Mean Absolute Interface Curvature  $f_2$: Curvature Skewness**: The interface curvature is given by $\\kappa = \\nabla \\cdot \\mathbf{n}$, where $\\mathbf{n} = \\nabla\\alpha / \\|\\nabla\\alpha\\|$ is the interface normal. In bubbly flow, bubbles are relatively spherical and stable, leading to a narrow distribution of curvatures. Churn flow is characterized by violent, chaotic interface motions, including stretching, coalescence, and breakup. This produces a wider range of interface shapes, from large, distorted structures to small droplets and ligaments, resulting in a higher mean absolute curvature ($f_1$) and a broader, more symmetric (less skewed, $f_2$) probability density function (PDF) of $\\kappa$. The provided models for $f_1$ and $f_2$ correctly reflect that churn flow ($r=1$) has a higher mean curvature and lower skewness than bubbly flow ($r=0$).\n\n-   **$f_3$: Dimensionless Bubble Count Rate**: Churn flow involves frequent breakup and coalescence events. This high rate of topological change can be quantified by a characteristic frequency. When non-dimensionalized, for instance, in the form of a Strouhal number, this rate ($f_3$) is expected to be significantly higher in churn flow than in the more quiescent bubbly flow. The model for $f_3$ shows a larger base value and stronger dependence on gas volume fraction $\\phi$ and Reynolds number $Re_l$ for the churn regime.\n\n-   **$f_4$: Spectral Slope  $f_5$: High-Wavenumber Energy Fraction**: The spatial distribution of the phases, encapsulated by the $\\alpha(\\mathbf{x}, t)$ field, can be analyzed in Fourier space. The spectral energy density, $E_\\alpha(k)$, describes how the variance of the $\\alpha$ field is distributed across different length scales (related to wavenumber $k$). Turbulent flows often exhibit power-law scaling, $E_\\alpha(k) \\sim k^{-p}$. The chaotic breakup process in churn flow continuously creates small-scale interface structures. This \"cascade\" of structure to smaller scales results in more energy at high wavenumbers. Consequently, churn flow is expected to have a flatter spectral slope (a smaller exponent $p$, represented by $f_4$) and a larger fraction of its total spectral energy above a certain high-wavenumber cutoff ($f_5$). The provided models for $f_4$ and $f_5$ are consistent with this physical reasoning.\n\n### 2. Synthetic Data Generation\n\nTo create a reproducible machine learning task, we do not use raw simulation data. Instead, we use the provided calibrated models, which mathematically encode the physical trends discussed above. A training dataset of size $m=400$ is generated, with $200$ samples for each regime. For each sample, the liquid Reynolds number $Re_l$ is drawn such that $\\log_{10}(Re_l)$ is uniform on $[4, 5]$, and the gas volume fraction $\\phi$ is drawn uniformly from $[0.05, 0.30]$. The parameter $s = \\log_{10}(Re_l/10^4)$ is thus uniform on $[0,1]$. These parameters, along with the true regime label $r$, determine the mean values of the features. Independent Gaussian noise $n_i \\sim \\mathcal{N}(0, \\sigma_i^2)$ with specified variances is added to each feature component to simulate the inherent variability in complex flow measurements. The bubbly regime ($r=0$) is mapped to the class label $y=-1$, and the churn regime ($r=1$) to $y=+1$.\n\n### 3. Classifier Model and Training Algorithm\n\nA linear Support Vector Classifier (SVC) is trained to find an optimal separating hyperplane $(\\mathbf{w}, b)$ in the feature space. The parameters $\\mathbf{w} \\in \\mathbb{R}^5$ and $b \\in \\mathbb{R}$ are found by minimizing the $\\ell_2$-regularized hinge-loss objective function:\n$$\n\\min_{\\mathbf{w}, b}\\; \\frac{\\lambda}{2}\\|\\mathbf{w}\\|_2^2 + \\frac{1}{m} \\sum_{i=1}^{m} \\max\\left(0,\\, 1 - y_i(\\mathbf{w}^\\top \\mathbf{x}_i + b)\\right)\n$$\nHere, $\\mathbf{x}_i$ are the standardized feature vectors, $y_i$ are the class labels, and $\\lambda = 10^{-2}$ is the regularization parameter that balances margin maximization and classification error.\n\n**Feature Standardization**: Before training, the raw features $\\mathbf{f}_i$ are standardized to have zero mean and unit variance. The mean $\\boldsymbol{\\mu}$ and standard deviation $\\boldsymbol{\\sigma}$ are computed *only* from the training data: $\\mathbf{x}_i = (\\mathbf{f}_i - \\boldsymbol{\\mu}) / \\boldsymbol{\\sigma}$. This is a critical step to prevent data leakage from the test set and to ensure that all features contribute equally to the decision function, regardless of their original scale.\n\n**Training Algorithm**: We employ a stochastic subgradient method. At each iteration $t=1, \\dots, T$ (with $T=20000$), a single training sample $(\\mathbf{x}_i, y_i)$ is randomly selected. The learning rate is set to $\\eta_t = 1/(\\lambda t)$. The subgradient of the objective function with respect to this single sample is used to update the parameters.\nThe update rules are as follows:\nFirst, a \"decay\" step is applied to the weights, corresponding to the gradient of the regularization term:\n$$\n\\mathbf{w} \\leftarrow \\left(1 - \\eta_t \\lambda\\right) \\mathbf{w}\n$$\nNext, the margin condition $y_i(\\mathbf{w}^\\top \\mathbf{x}_i + b)  1$ is checked. If the sample is misclassified or inside the margin (i.e., the condition is true), an additional update based on the subgradient of the hinge loss is performed:\n$$\n\\begin{aligned}\n\\mathbf{w} \\leftarrow \\mathbf{w} + \\eta_t y_i \\mathbf{x}_i \\\\\nb \\leftarrow b + \\eta_t y_i\n\\end{aligned}\n$$\nIf the margin condition is false, the sample is correctly classified outside the margin, and the subgradient of the hinge loss is zero, so no further update is made to $\\mathbf{w}$ or $b$. This procedure is consistent with the Pegasos algorithm and the problem specification.\n\n### 4. Prediction\n\nAfter $T$ training iterations, the final model $(\\mathbf{w}, b)$ is obtained. To classify a new test sample, its features are first generated using the same physical models (including a random noise component, as per the problem's sampling-based directive) and then standardized using the mean and standard deviation from the *training* set. The decision function $d = \\mathbf{w}^\\top \\mathbf{x}_{\\text{test}} + b$ is computed. The predicted regime $\\hat{r}$ is determined by the sign of $d$:\n$$\n\\hat{r} = \\begin{cases} 1  \\text{if } d \\ge 0 \\quad (\\text{predicted label } +1, \\text{churn}) \\\\ 0  \\text{if } d  0 \\quad (\\text{predicted label } -1, \\text{bubbly}) \\end{cases}\n$$\nThis procedure is applied to each of the $8$ cases in the specified test suite, and the resulting list of predicted regimes constitutes the final output.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the full pipeline for training a linear SVC to classify flow regimes\n    and predicting on a given test suite.\n    \"\"\"\n    # Set seed for reproducibility of all random operations.\n    SEED = 42\n    np.random.seed(SEED)\n\n    # --- Constants and Hyperparameters ---\n    M_TRAIN = 400\n    N_FEATURES = 5\n    LAMBDA_REG = 1e-2\n    T_ITERATIONS = 20000\n    SIGMAS = np.array([0.03, 0.05, 0.04, 0.02, 0.03])\n\n    def generate_features(r, Re_l, phi):\n        \"\"\"\n        Generates a 5-dimensional feature vector for a given regime and parameters.\n        Includes a stochastic noise component.\n\n        Args:\n            r (int): Regime label (0 for bubbly, 1 for churn).\n            Re_l (float): Liquid Reynolds number.\n            phi (float): Gas volume fraction.\n\n        Returns:\n            np.ndarray: The 5-dimensional feature vector.\n        \"\"\"\n        s = np.log10(Re_l / 10000.0)\n        n = np.random.normal(0.0, SIGMAS)\n        f = np.zeros(N_FEATURES)\n        \n        if r == 0:  # Bubbly flow\n            f[0] = 0.80 + 0.20 * s + n[0]\n            f[1] = 0.70 - 0.10 * s + n[1]\n            f[2] = 0.50 + 0.20 * phi + 0.30 * s + n[2]\n            f[3] = 1.65 + 0.05 * phi + n[3]\n            f[4] = 0.15 + 0.05 * s + n[4]\n        else:  # r == 1, Churn flow\n            f[0] = 1.50 + 0.30 * s + n[0]\n            f[1] = 0.10 - 0.05 * s + n[1]\n            f[2] = 1.20 + 0.50 * phi + 0.50 * s + n[2]\n            f[3] = 1.30 + 0.10 * phi + n[3]\n            f[4] = 0.35 + 0.10 * s + n[4]\n            \n        return f\n\n    # --- 1. Generate Synthetic Training Data ---\n    n_per_class = M_TRAIN // 2\n    X_train_raw = np.zeros((M_TRAIN, N_FEATURES))\n    y_train = np.zeros(M_TRAIN)\n\n    # Generate bubbly flow samples (r=0, y=-1)\n    for i in range(n_per_class):\n        log_rel_bubbly = np.random.uniform(4.0, 5.0)\n        phi_bubbly = np.random.uniform(0.05, 0.30)\n        Re_l = 10**log_rel_bubbly\n        X_train_raw[i, :] = generate_features(r=0, Re_l=Re_l, phi=phi_bubbly)\n        y_train[i] = -1.0\n\n    # Generate churn flow samples (r=1, y=1)\n    for i in range(n_per_class):\n        log_rel_churn = np.random.uniform(4.0, 5.0)\n        phi_churn = np.random.uniform(0.05, 0.30)\n        Re_l = 10**log_rel_churn\n        X_train_raw[n_per_class + i, :] = generate_features(r=1, Re_l=Re_l, phi=phi_churn)\n        y_train[n_per_class + i] = 1.0\n\n    # --- 2. Standardize Features ---\n    # Compute mean and std dev from the training set only\n    mu = np.mean(X_train_raw, axis=0)\n    std = np.std(X_train_raw, axis=0)\n    # Prevent division by zero, though unlikely with noise model\n    std[std == 0] = 1.0\n    \n    X_train_std = (X_train_raw - mu) / std\n\n    # --- 3. Train Linear SVC with Stochastic Subgradient Method ---\n    w = np.zeros(N_FEATURES)\n    b = 0.0\n\n    # The order of random sampling during training is part of the reproducible process\n    training_indices = np.random.randint(0, M_TRAIN, T_ITERATIONS)\n\n    for t_idx, item_idx in enumerate(training_indices):\n        t = t_idx + 1  # Iteration count from 1\n        x_i = X_train_std[item_idx]\n        y_i = y_train[item_idx]\n        eta_t = 1.0 / (LAMBDA_REG * t)\n\n        decision_val = y_i * (np.dot(w, x_i) + b)\n        \n        # Regularization update (always applied)\n        w *= (1.0 - eta_t * LAMBDA_REG)\n\n        if decision_val  1.0:\n            # Hinge loss update (applied only when margin is violated)\n            w += eta_t * y_i * x_i\n            b += eta_t * y_i\n\n    # --- 4. Prediction on Test Suite ---\n    test_cases = [\n        # (Re_l, phi, r_true)\n        (1e4, 0.05, 0),\n        (1.5e4, 0.10, 0),\n        (5e4, 0.20, 1),\n        (8e4, 0.15, 1),\n        (1e5, 0.25, 1),\n        (2e4, 0.30, 0),\n        (7e4, 0.05, 1),\n        (1.2e4, 0.20, 0)\n    ]\n\n    # Generate features for the test suite. The random state continues from training.\n    X_test_raw = np.array([generate_features(r=r_true, Re_l=Re_l, phi=phi) \n                           for Re_l, phi, r_true in test_cases])\n\n    # Standardize test features using training set statistics\n    X_test_std = (X_test_raw - mu) / std\n\n    results = []\n    for x_test in X_test_std:\n        decision = np.dot(w, x_test) + b\n        # Map decision function output to regime label: = 0 - +1 (churn/1),  0 - -1 (bubbly/0)\n        r_pred = 1 if decision = 0 else 0\n        results.append(r_pred)\n\n    # --- 5. Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}