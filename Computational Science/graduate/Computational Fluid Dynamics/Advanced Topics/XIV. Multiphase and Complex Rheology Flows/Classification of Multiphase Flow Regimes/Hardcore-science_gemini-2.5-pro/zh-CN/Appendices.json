{
    "hands_on_practices": [
        {
            "introduction": "漂移流模型是分析多相流宏观行为的基石，它能够在不解析每个气泡或液滴细节的情况下，有效预测相含率等关键参数。本练习旨在通过一个经典的解析推导，加深对该模型的理解。我们将从漂移流的基本关系式出发，通过求解持气率曲线的拐点，来确定从泡状流到搅动流的转变条件，这揭示了流体动力学不稳定性在流型转变中的核心作用 。",
            "id": "3301455",
            "problem": "在计算流体力学（CFD）的框架内，考虑圆形管道中的气液垂直向上流动。设管道内径为 $D = 0.05$ m，重力加速度为 $g = 9.81$ m s$^{-2}$。混合物表观速度固定为 $J = 1.0$ m s$^{-1}$，气体表观速度为 $J_g$。横截面气体含率由空隙率 $\\alpha$ 表示，其中 $0  \\alpha  1$。在泡状流区域，取分布参数为常数 $C_0 = 1.20$。假设气体漂移速度遵循受阻上升标度关系，\n$$\nV_{gj}(\\alpha) = \\beta \\sqrt{g D}\\,(1 - \\alpha)^{n},\n$$\n其中 $\\beta = 0.50$ 且 $n = 2$。从标准的漂移流概念以及表观速度和相含率的基本定义出发，推导在固定 $J$ 值下的含率关系 $\\alpha(J_g)$。然后，确定含率曲线 $\\alpha(J_g)$ 的曲率消失的条件，并用它来获得拐点处的临界气体表观速度 $J_g^{\\star}$ 的显式表达式。计算给定参数下 $J_g^{\\star}$ 的数值。将最终答案四舍五入至四位有效数字，并以 m s$^{-1}$ 为单位表示。最后，提供一个简要的物理解释，说明为什么该拐点的出现与泡状流-搅动流转变相吻合，并参考漂移流框架所捕捉到的流体动力学相互作用、聚并以及相分布变化的作用。",
            "solution": "问题陈述具有科学依据，提法恰当，客观，并提供了一套完整且一致的数据和定义。它基于多相流中已建立的漂移流模型，这是计算流体力学的一个核心课题。所给参数在物理上是现实的。因此，该问题被认为是有效的，下面给出完整解答。\n\n出发点是标准的 Zuber-Findlay 漂移流模型，该模型将气体表观速度 $J_g$ 与横截面空隙率 $\\alpha$ 联系起来。实际气体速度 $u_g$ 由 $u_g = J_g / \\alpha$ 给出。该模型用混合物表观速度 $J$ 和气体漂移速度 $V_{gj}$ 表示 $u_g$ 如下：\n$$\nu_g = C_0 J + V_{gj}\n$$\n其中 $C_0$ 是分布参数。代入 $u_g$ 的定义，我们得到 $J_g$ 的关系式：\n$$\n\\frac{J_g}{\\alpha} = C_0 J + V_{gj}\n$$\n问题给出了气体漂移速度 $V_{gj}$ 作为空隙率 $\\alpha$ 的函数：\n$$\nV_{gj}(\\alpha) = \\beta \\sqrt{g D}\\,(1 - \\alpha)^{n}\n$$\n将 $V_{gj}$ 的这个表达式代入漂移流方程并求解 $J_g$，得到含率关系式，该关系式表达了在固定混合物速度 $J$ 下，$J_g$ 作为 $\\alpha$ 的函数：\n$$\nJ_g(\\alpha) = \\alpha (C_0 J + V_{gj}(\\alpha)) = \\alpha \\left( C_0 J + \\beta \\sqrt{g D}\\,(1 - \\alpha)^{n} \\right)\n$$\n这可以写作：\n$$\nJ_g(\\alpha) = C_0 J \\alpha + \\beta \\sqrt{gD} \\alpha(1 - \\alpha)^{n}\n$$\n这就是推导出的 $J_g$ 和 $\\alpha$ 之间的含率关系。\n\n接下来，我们需要找到含率曲线 $\\alpha(J_g)$ 的曲率消失的条件。这发生在拐点处，其二阶导数为零：$\\frac{d^2\\alpha}{dJ_g^2} = 0$。\n从数学上讲，分析反函数 $J_g(\\alpha)$ 并找到其关于 $\\alpha$ 的二阶导数为零的点更为方便。这两个二阶导数之间的关系由下式给出：\n$$\n\\frac{d^2\\alpha}{dJ_g^2} = - \\frac{d^2J_g}{d\\alpha^2} \\left( \\frac{dJ_g}{d\\alpha} \\right)^{-3}\n$$\n对于一个物理上有意义的流，其中 $J_g$ 是 $\\alpha$ 的增函数，一阶导数 $\\frac{dJ_g}{d\\alpha}$ 是有限且非零的。因此，条件 $\\frac{d^2\\alpha}{dJ_g^2} = 0$ 等价于条件 $\\frac{d^2J_g}{d\\alpha^2} = 0$。\n\n我们通过计算 $J_g(\\alpha)$ 关于 $\\alpha$ 的一阶和二阶导数来继续。一阶导数是：\n$$\n\\frac{dJ_g}{d\\alpha} = \\frac{d}{d\\alpha} \\left[ C_0 J \\alpha + \\beta \\sqrt{gD} \\alpha(1-\\alpha)^n \\right]\n$$\n$$\n\\frac{dJ_g}{d\\alpha} = C_0 J + \\beta \\sqrt{gD} \\left[ 1 \\cdot (1-\\alpha)^n + \\alpha \\cdot n(1-\\alpha)^{n-1}(-1) \\right]\n$$\n$$\n\\frac{dJ_g}{d\\alpha} = C_0 J + \\beta \\sqrt{gD} (1-\\alpha)^{n-1} [ (1-\\alpha) - n\\alpha ]\n$$\n$$\n\\frac{dJ_g}{d\\alpha} = C_0 J + \\beta \\sqrt{gD} (1-\\alpha)^{n-1} [ 1 - (n+1)\\alpha ]\n$$\n现在，我们计算二阶导数 $\\frac{d^2J_g}{d\\alpha^2}$：\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\frac{d}{d\\alpha} \\left[ C_0 J + \\beta \\sqrt{gD} (1-\\alpha)^{n-1} (1 - (n+1)\\alpha) \\right]\n$$\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\beta \\sqrt{gD} \\frac{d}{d\\alpha} \\left[ (1-\\alpha)^{n-1} - (n+1)\\alpha(1-\\alpha)^{n-1} \\right]\n$$\n使用乘法法则，我们发现：\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\beta \\sqrt{gD} \\left[ (n-1)(1-\\alpha)^{n-2}(-1) - (n+1) \\left( 1 \\cdot (1-\\alpha)^{n-1} + \\alpha(n-1)(1-\\alpha)^{n-2}(-1) \\right) \\right]\n$$\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\beta \\sqrt{gD} \\left[ -(n-1)(1-\\alpha)^{n-2} - (n+1)(1-\\alpha)^{n-1} + (n+1)(n-1)\\alpha (1-\\alpha)^{n-2} \\right]\n$$\n提出公因式 $(1-\\alpha)^{n-2}$：\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\beta \\sqrt{gD} (1-\\alpha)^{n-2} \\left[ -(n-1) - (n+1)(1-\\alpha) + (n^2-1)\\alpha \\right]\n$$\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\beta \\sqrt{gD} (1-\\alpha)^{n-2} \\left[ -n+1 - (n-n\\alpha+1-\\alpha) + n^2\\alpha - \\alpha \\right]\n$$\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\beta \\sqrt{gD} (1-\\alpha)^{n-2} \\left[ -n+1 - n + n\\alpha - 1 + \\alpha + n^2\\alpha - \\alpha \\right]\n$$\n$$\n\\frac{d^2J_g}{d\\alpha^2} = \\beta \\sqrt{gD} (1-\\alpha)^{n-2} \\left[ -2n + (n+n^2)\\alpha \\right] = \\beta \\sqrt{gD} \\cdot n (1-\\alpha)^{n-2} \\left[ (n+1)\\alpha - 2 \\right]\n$$\n拐点的条件是 $\\frac{d^2J_g}{d\\alpha^2} = 0$。由于 $\\beta$、$g$、$D$ 和 $n$ 都是非零常数，并且我们关心的是 $\\alpha  1$ 的情况，这个条件简化为：\n$$\n(n+1)\\alpha - 2 = 0\n$$\n这给出了拐点处的临界空隙率 $\\alpha^{\\star}$：\n$$\n\\alpha^{\\star} = \\frac{2}{n+1}\n$$\n临界气体表观速度 $J_g^{\\star}$ 是通过计算 $J_g(\\alpha^{\\star})$ 得到的：\n$$\nJ_g^{\\star} = C_0 J \\alpha^{\\star} + \\beta \\sqrt{gD} \\alpha^{\\star}(1 - \\alpha^{\\star})^{n}\n$$\n代入 $\\alpha^{\\star}$ 的表达式：\n$$\nJ_g^{\\star} = C_0 J \\left(\\frac{2}{n+1}\\right) + \\beta \\sqrt{gD} \\left(\\frac{2}{n+1}\\right) \\left(1 - \\frac{2}{n+1}\\right)^{n}\n$$\n$$\nJ_g^{\\star} = \\frac{2 C_0 J}{n+1} + \\beta \\sqrt{gD} \\frac{2}{n+1} \\left(\\frac{n+1-2}{n+1}\\right)^{n}\n$$\n这给出了 $J_g^{\\star}$ 的最终显式表达式：\n$$\nJ_g^{\\star} = \\frac{2 C_0 J}{n+1} + \\frac{2 \\beta \\sqrt{gD}}{n+1} \\left(\\frac{n-1}{n+1}\\right)^{n}\n$$\n现在，我们使用给定的参数计算 $J_g^{\\star}$ 的数值：$D = 0.05$ m, $g = 9.81$ m s$^{-2}$, $J = 1.0$ m s$^{-1}$, $C_0 = 1.20$, $\\beta = 0.50$, 且 $n = 2$。\n首先，我们求出临界空隙率：\n$$\n\\alpha^{\\star} = \\frac{2}{2+1} = \\frac{2}{3}\n$$\n接下来，我们将这些值代入 $J_g^{\\star}$ 的表达式中：\n$$\nJ_g^{\\star} = \\frac{2 (1.20) (1.0)}{2+1} + \\frac{2 (0.50) \\sqrt{(9.81)(0.05)}}{2+1} \\left(\\frac{2-1}{2+1}\\right)^{2}\n$$\n$$\nJ_g^{\\star} = \\frac{2.40}{3} + \\frac{1.0 \\sqrt{0.4905}}{3} \\left(\\frac{1}{3}\\right)^{2}\n$$\n$$\nJ_g^{\\star} = 0.8 + \\frac{\\sqrt{0.4905}}{3} \\left(\\frac{1}{9}\\right) = 0.8 + \\frac{\\sqrt{0.4905}}{27}\n$$\n计算数值：\n$$\nJ_g^{\\star} \\approx 0.8 + \\frac{0.70035708}{27} \\approx 0.8 + 0.02593915\n$$\n$$\nJ_g^{\\star} \\approx 0.82593915 \\, \\text{m s}^{-1}\n$$\n四舍五入到四位有效数字，我们得到 $J_g^{\\star} = 0.8259$ m s$^{-1}$。\n\n关于拐点与泡状流-搅动流转变相吻合的物理解释如下。漂移流模型是一个宏观模型，它捕捉了两相混合物的平均行为。含率曲线 $J_g(\\alpha)$ 的形状反映了相间相互作用的潜在物理机制。\n在泡状流区域，当空隙率较低时，气相以小的、相对独立的气泡形式分散在连续的液相中。随着 $J_g$ 的增加，气泡数量增多，导致 $\\alpha$ 单调上升。\n$V_{gj}(\\alpha) = \\beta \\sqrt{g D}\\,(1 - \\alpha)^{n}$ 这一项模拟了气泡的浮力上升，这种上升受到其他气泡存在的阻碍（即 $(1-\\alpha)^n$ 项）。随着 $\\alpha$ 的增长，流体动力学相互作用变得更加显著。气泡之间距离变近，增加了碰撞和聚并的概率。\n由 $\\frac{d^2J_g}{d\\alpha^2}=0$ 定义的拐点代表了系统稳定性的一个临界点。在物理上，它被解释为气泡聚并速率变得非常显著，以至于分散的泡状流结构不再稳定的点。当空隙率超过 $\\alpha^{\\star}$ 时，小气泡迅速合并形成大的、扭曲的、帽状的气泡。这些较大的气泡具有不同的上升速度，并以一种根本不同的方式与流动相互作用，导致一种更混乱、更间歇的流态，称为搅动流（或在较小直径的管道中称为段塞流）。\n漂移流模型尽管简单，却通过含率关系曲率的变化捕捉到了相拓扑的这种根本性变化。因此，拐点是预测从泡状流到搅动流转变的一个广泛使用的理论判据，它标志着分散泡状流区域稳定性的极限。它意味着气相中大规模结构的开始出现。",
            "answer": "$$ \\boxed{0.8259} $$"
        },
        {
            "introduction": "从解析模型转向高保真数值模拟，直接解析界面动力学是理解复杂多相流的关键。然而，不同的数值方法，如流体体积法(VOF)和相场法(PF)，对界面的处理方式（锐利或弥散）有所不同，这可能会影响对曲率等几何量的计算。本练习通过编程实践，量化这种由有限界面厚度 $\\epsilon$ 带来的数值偏差，从而揭示计算工具的选择如何影响我们对流型分类的物理判断 。",
            "id": "3301499",
            "problem": "您的任务是设计并实现一个程序，量化当使用基于曲率的准则时，有限的弥散界面厚度如何影响多相流流态的分类。您必须比较一个简单的二维周期性界面的尖锐界面表示法（流体体积法，VOF）和弥散界面表示法（基于Cahn–Hilliard方程的相场法，PF）。\n\n从以下基本依据开始：\n\n- 界面上的拉普拉斯压力跃变由 $\\Delta p = \\sigma \\kappa$ 给出，其中 $\\sigma$ 是表面张力（单位为 $\\mathrm{N/m}$），$\\kappa$ 是平均曲率（单位为 $\\mathrm{m}^{-1}$）。在二维情况下，界面表示为图 $y(x)$，其曲率为\n$$\n\\kappa(x) = \\frac{y''(x)}{\\left(1 + \\left(y'(x)\\right)^2\\right)^{3/2}}。\n$$\n\n- 对于特征速度为 $U$、密度为 $\\rho$ 的流动，其惯性压力标度为 $p_{\\text{inertial}} \\sim \\rho U^2$。\n\n- Cahn–Hilliard（相场）模型引入了一个有限界面厚度参数 $\\epsilon$（单位为 $\\mathrm{m}$）。当从弥散界面中提取曲率时，这些曲率实际上是在一个与 $\\epsilon$ 相当的长度尺度上被平滑了。对此平滑在数学上一个易于处理的替代方法是，将曲率场与一个沿流向坐标 $x$、标准差为 $\\epsilon$ 的高斯核进行卷积，\n$$\n\\kappa_{\\epsilon}(x) = \\left(G_{\\epsilon} * \\kappa\\right)(x), \\quad G_{\\epsilon}(x) = \\frac{1}{\\sqrt{2\\pi}\\,\\epsilon} \\exp\\left(-\\frac{x^2}{2\\epsilon^2}\\right)。\n$$\n等效地，在傅里叶空间中，这对应于将每个波数为 $k_n$ 的模式乘以 $\\exp\\left(-\\frac{1}{2}(\\epsilon k_n)^2\\right)$。\n\n使用均方根曲率定义一个无量纲毛细主导数，\n$$\nK_{\\mathrm{rms}} = \\sqrt{\\frac{1}{L}\\int_0^L \\kappa(x)^2\\,dx}, \\qquad C_{\\mathrm{rms}} = \\frac{\\sigma K_{\\mathrm{rms}}}{\\rho U^2},\n$$\n同样地，对于平滑曲率 $K_{\\mathrm{rms},\\epsilon}$，得到 $C_{\\mathrm{rms},\\epsilon}$。此处，$L$ 是界面的空间周期。\n\n为了算法化地对流态进行分类，请使用以下基于 $C_{\\mathrm{rms}}$ 和陡度参数 $S = \\max_x |y'(x)|$ 的规则：\n\n- 如果 $C_{\\mathrm{rms}} \\geq 0.7$：代码 $0$ (分层光滑流)。\n- 如果 $0.3 \\leq C_{\\mathrm{rms}}  0.7$ 且 $S  0.5$：代码 $1$ (波状流)。\n- 如果 $0.3 \\leq C_{\\mathrm{rms}}  0.7$ 且 $S \\geq 0.5$：代码 $2$ (段塞流)。\n- 如果 $C_{\\mathrm{rms}}  0.3$：代码 $3$ (弥散流)。\n\n考虑一个单频界面\n$$\ny(x) = A \\sin(kx),\n$$\n其振幅为 $A$（单位为 $\\mathrm{m}$），基波数为 $k$（单位为 $\\mathrm{m}^{-1}$），这意味着空间周期 $L = \\frac{2\\pi}{k}$。对于此界面，$y'(x) = A k \\cos(kx)$ 且 $y''(x) = -A k^2 \\sin(kx)$；因此 $S = A k$。\n\n您的程序必须：\n\n1. 计算尖锐界面情况（VOF）下的 $K_{\\mathrm{rms}}$ 和 $C_{\\mathrm{rms}}$。\n2. 通过傅里叶方法将曲率与标准差为 $\\epsilon$ 的高斯核沿 $x$ 轴进行卷积，计算相场法情况（PF）下的 $K_{\\mathrm{rms},\\epsilon}$ 和 $C_{\\mathrm{rms},\\epsilon}$。\n3. 使用上述规则确定 VOF 和 PF 两种情况的分类代码。\n4. 通过计算 $\\Delta C = C_{\\mathrm{rms},\\epsilon} - C_{\\mathrm{rms}}$ 来量化由有限 $\\epsilon$ 引起的偏差。将 $\\Delta C$ 报告为一个四舍五入到六位小数的无量纲浮点数。\n\n物理单位：$\\rho$ 的单位为 $\\mathrm{kg/m^3}$，$U$ 的单位为 $\\mathrm{m/s}$，$\\sigma$ 的单位为 $\\mathrm{N/m}$，$A$ 的单位为 $\\mathrm{m}$，$k$ 的单位为 $\\mathrm{m^{-1}}$，$\\epsilon$ 的单位为 $\\mathrm{m}$。所有输出均为无量纲数或整数，如前所述。\n\n待您程序评估的测试套件（五个案例）：\n\n- 案例 1（理想路径波状流，小程度平滑）：\n  - $\\rho = 1000\\,\\mathrm{kg/m^3}$，$U = 0.02\\,\\mathrm{m/s}$，$\\sigma = 0.072\\,\\mathrm{N/m}$，$A = 1.0\\times 10^{-4}\\,\\mathrm{m}$，$k = 200\\,\\mathrm{m^{-1}}$，$\\epsilon = 5.0\\times 10^{-4}\\,\\mathrm{m}$。\n\n- 案例 2（近边界波状流至弥散流，中等程度平滑）：\n  - $\\rho = 1000\\,\\mathrm{kg/m^3}$，$U = 0.0256\\,\\mathrm{m/s}$，$\\sigma = 0.072\\,\\mathrm{N/m}$，$A = 1.0\\times 10^{-4}\\,\\mathrm{m}$，$k = 200\\,\\mathrm{m^{-1}}$，$\\epsilon = 4.0\\times 10^{-3}\\,\\mathrm{m}$。\n\n- 案例 3（因陡度大而导致的段塞流，小程度平滑）：\n  - $\\rho = 1000\\,\\mathrm{kg/m^3}$，$U = 0.12\\,\\mathrm{m/s}$，$\\sigma = 0.072\\,\\mathrm{N/m}$，$A = 3.0\\times 10^{-3}\\,\\mathrm{m}$，$k = 200\\,\\mathrm{m^{-1}}$，$\\epsilon = 5.0\\times 10^{-4}\\,\\mathrm{m}$。\n\n- 案例 4（分层光滑流，对平滑具有鲁棒性）：\n  - $\\rho = 1000\\,\\mathrm{kg/m^3}$，$U = 0.015\\,\\mathrm{m/s}$，$\\sigma = 0.072\\,\\mathrm{N/m}$，$A = 1.0\\times 10^{-4}\\,\\mathrm{m}$，$k = 200\\,\\mathrm{m^{-1}}$，$\\epsilon = 1.0\\times 10^{-3}\\,\\mathrm{m}$。\n\n- 案例 5（边界情况，大 $\\epsilon$ 强烈影响分类）：\n  - $\\rho = 1000\\,\\mathrm{kg/m^3}$，$U = 0.08\\,\\mathrm{m/s}$，$\\sigma = 0.072\\,\\mathrm{N/m}$，$A = 5.0\\times 10^{-4}\\,\\mathrm{m}$，$k = 400\\,\\mathrm{m^{-1}}$，$\\epsilon = 1.0\\times 10^{-2}\\,\\mathrm{m}$。\n\n最终输出格式规范：\n\n- 对于上述顺序中的每个案例 $i$，计算 VOF 的整数分类代码、PF 的整数分类代码以及浮点数 $\\Delta C$（四舍五入到六位小数）。\n- 将五个案例的所有结果聚合成一个扁平列表，顺序为\n$$\n\\left[\\text{code}_{\\mathrm{VOF},1},\\text{code}_{\\mathrm{PF},1},\\Delta C_1,\\text{code}_{\\mathrm{VOF},2},\\text{code}_{\\mathrm{PF},2},\\Delta C_2,\\ldots,\\text{code}_{\\mathrm{VOF},5},\\text{code}_{\\mathrm{PF},5},\\Delta C_5\\right]。\n$$\n- 您的程序应生成一行输出，包含这个用方括号括起来的逗号分隔序列，例如\n$$\n[\\text{result}_1,\\text{result}_2,\\ldots,\\text{result}_{15}]。\n$$\n所有浮点数都应为无量纲，并四舍五入到六位小数。所有整数应符合分类规则的规定。",
            "solution": "该问题要求通过算法比较尖锐界面（流体体积法，VOF）和弥散界面（相场法，PF）表示法在多相流流态分类中的差异。比较基于一个从界面曲率的均方根（RMS）派生出的毛细主导数 $C_{\\mathrm{rms}}$。问题的核心是量化PF模型中的有限界面厚度 $\\epsilon$ 如何系统性地改变计算出的曲率，并因此改变流态分类。\n\n分析是针对一个由函数 $y(x) = A \\sin(kx)$ 定义的二维周期性界面进行的，其中 $A$ 是振幅，$k$ 是波数。解决此问题的方法是，首先为相关物理量构建表达式，然后实现一个数值算法来为给定的测试案例评估这些表达式。\n\n**1. 尖锐界面模型 (VOF)**\n\n在VOF模型中，界面被认为是无限薄的。局部曲率 $\\kappa(x)$ 直接由给定的界面几何形状确定。\n\n界面形状 $y(x) = A \\sin(kx)$ 的一阶和二阶导数是：\n$$\ny'(x) = A k \\cos(kx)\n$$\n$$\ny''(x) = -A k^2 \\sin(kx)\n$$\n将这些代入二维曲率公式 $\\kappa(x) = y''(x) / (1 + (y'(x))^2)^{3/2}$，得到：\n$$\n\\kappa(x) = \\frac{-A k^2 \\sin(kx)}{\\left(1 + (Ak)^2 \\cos^2(kx)\\right)^{3/2}}\n$$\n无量纲陡度参数 $S = \\max_x |y'(x)|$ 只是 $y'(x)$ 的振幅，即 $S = Ak$。\n\nRMS曲率 $K_{\\mathrm{rms}}$ 定义为一个空间周期 $L = 2\\pi/k$ 上曲率平方均值的平方根：\n$$\nK_{\\mathrm{rms}} = \\sqrt{\\frac{1}{L}\\int_0^L \\kappa(x)^2\\,dx}\n$$\n求 $K_{\\mathrm{rms}}$ 解析解所需的积分并不简单，特别是由于分母的存在。一个稳健且实用的方法是采用数值积分，这非常适合该问题的计算性质。我们将空间域 $[0, L]$ 离散为 $N$ 个点 $x_j$，在每个点上评估 $\\kappa(x_j)$，然后近似计算曲率平方的均值：\n$$\nK_{\\mathrm{rms}}^2 \\approx \\frac{1}{N} \\sum_{j=0}^{N-1} \\kappa(x_j)^2\n$$\n由此，可以计算出尖锐界面毛细主导数 $C_{\\mathrm{rms}}$：\n$$\nC_{\\mathrm{rms}} = \\frac{\\sigma K_{\\mathrm{rms}}}{\\rho U^2}\n$$\n其中 $\\sigma$ 是表面张力，$\\rho$ 是密度，$U$ 是特征速度。然后根据 $C_{\\mathrm{rms}}$ 和 $S$ 的值应用给定的分类规则来确定流态。\n\n**2. 弥散界面模型 (PF)**\n\nPF模型引入了一个特征界面厚度 $\\epsilon$。问题指明，这种弥散界面对曲率测量的影响可以通过将尖锐界面曲率 $\\kappa(x)$ 与高斯核 $G_{\\epsilon}(x)$ 进行卷积来建模：\n$$\n\\kappa_{\\epsilon}(x) = (\\kappa * G_{\\epsilon})(x)\n$$\n根据卷积定理，此运算在傅里叶空间中等效于乘法。如果 $\\hat{\\kappa}(k_n)$ 是 $\\kappa(x)$ 在波数 $k_n$ 处的傅里叶变换，那么平滑后曲率的傅里叶变换 $\\hat{\\kappa}_{\\epsilon}(k_n)$ 是：\n$$\n\\hat{\\kappa}_{\\epsilon}(k_n) = \\hat{\\kappa}(k_n) \\cdot \\exp\\left(-\\frac{1}{2}(\\epsilon k_n)^2\\right)\n$$\n这提供了一个高效的数值流程：\n\n1.  在空间网格上计算离散曲率场 $\\kappa(x_j)$，如同VOF情况一样。\n2.  应用快速傅里叶变换（FFT）以获得离散谱 $\\hat{\\kappa}_n$。\n3.  对于与FFT分量对应的每个离散波数 $k_n$，计算高斯滤波器因子 $G_n = \\exp(-\\frac{1}{2}(\\epsilon k_n)^2)$。\n4.  将谱与滤波器相乘：$\\hat{\\kappa}_{\\epsilon,n} = \\hat{\\kappa}_n \\cdot G_n$。\n5.  对滤波后的谱应用逆FFT，以获得平滑后的离散曲率场 $\\kappa_{\\epsilon}(x_j)$。\n\n然后从此新场中计算RMS平滑曲率 $K_{\\mathrm{rms},\\epsilon}$：\n$$\nK_{\\mathrm{rms},\\epsilon}^2 \\approx \\frac{1}{N} \\sum_{j=0}^{N-1} \\left( \\text{Re}\\{\\kappa_{\\epsilon}(x_j)\\} \\right)^2\n$$\n取实部是为了舍弃由数值浮点不精确性产生的微小虚部。随后，计算弥散界面毛细主导数 $C_{\\mathrm{rms},\\epsilon}$：\n$$\nC_{\\mathrm{rms},\\epsilon} = \\frac{\\sigma K_{\\mathrm{rms},\\epsilon}}{\\rho U^2}\n$$\nPF模型的分类使用此 $C_{\\mathrm{rms},\\epsilon}$ 和相同的陡度参数 $S=Ak$，因为 $S$ 关系到在考虑曲率平滑效应之前的底层几何形状。\n\n**3. 偏差量化**\n\n由弥散界面模型引入的系统性偏差通过毛细主导数之差来量化：\n$$\n\\Delta C = C_{\\mathrm{rms},\\epsilon} - C_{\\mathrm{rms}}\n$$\n$\\Delta C$ 的负值表示PF模型的平滑效应导致有效曲率变小，可能使分类偏向于扰动较小的流态（例如，从波状流到分层光滑流，或从弥散流到波状流）。\n\n实现将对所提供的每个测试案例遵循此数值流程，生成VOF和PF的分类代码以及由此产生的偏差 $\\Delta C$。",
            "answer": "```python\nimport numpy as np\n\ndef classify(C_rms, S):\n    \"\"\"\n    Classifies the flow regime based on the capillary-dominance number C_rms\n    and the steepness parameter S.\n    \"\"\"\n    if C_rms >= 0.7:\n        return 0  # stratified-smooth\n    elif 0.3 = C_rms  0.7:\n        if S  0.5:\n            return 1  # wavy\n        else:\n            return 2  # slug\n    else:  # C_rms  0.3\n        return 3  # dispersed\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and compute flow regime classifications.\n    \"\"\"\n    # Test suite provided in the problem statement.\n    test_cases = [\n        # Case 1: happy path wavy, small smoothing\n        {'rho': 1000.0, 'U': 0.02, 'sigma': 0.072, 'A': 1.0e-4, 'k': 200.0, 'epsilon': 5.0e-4},\n        # Case 2: near boundary wavy to dispersed, moderate smoothing\n        {'rho': 1000.0, 'U': 0.0256, 'sigma': 0.072, 'A': 1.0e-4, 'k': 200.0, 'epsilon': 4.0e-3},\n        # Case 3: slug due to steepness, small smoothing\n        {'rho': 1000.0, 'U': 0.12, 'sigma': 0.072, 'A': 3.0e-3, 'k': 200.0, 'epsilon': 5.0e-4},\n        # Case 4: stratified-smooth, robust to smoothing\n        {'rho': 1000.0, 'U': 0.015, 'sigma': 0.072, 'A': 1.0e-4, 'k': 200.0, 'epsilon': 1.0e-3},\n        # Case 5: edge case, large epsilon strongly biases classification\n        {'rho': 1000.0, 'U': 0.08, 'sigma': 0.072, 'A': 5.0e-4, 'k': 400.0, 'epsilon': 1.0e-2},\n    ]\n\n    results = []\n    \n    # Parameters for numerical computation\n    N = 2048  # Number of points for discretization (power of 2 is efficient for FFT)\n\n    for case in test_cases:\n        rho = case['rho']\n        U = case['U']\n        sigma = case['sigma']\n        A = case['A']\n        k = case['k']\n        epsilon = case['epsilon']\n        \n        # 1. Setup spatial grid and interface properties\n        L = 2 * np.pi / k\n        # Use endpoint=False for periodic functions with FFT\n        x = np.linspace(0, L, N, endpoint=False)\n        \n        # 2. VOF (Sharp-Interface) Calculations\n        # Calculate first and second derivatives of the interface\n        y_prime = A * k * np.cos(k * x)\n        y_double_prime = -A * k**2 * np.sin(k * x)\n        \n        # Calculate sharp-interface curvature\n        kappa_vof = y_double_prime / (1 + y_prime**2)**1.5\n        \n        # Calculate RMS curvature for VOF\n        K_rms_vof = np.sqrt(np.mean(kappa_vof**2))\n        \n        # Calculate capillary-dominance number for VOF\n        C_rms_vof = (sigma * K_rms_vof) / (rho * U**2)\n\n        # The steepness S is an intrinsic property of the interface geometry\n        S = A * k\n\n        # Classify the VOF regime\n        code_vof = classify(C_rms_vof, S)\n        \n        # 3. PF (Diffuse-Interface) Calculations\n        # Obtain the spectrum of the sharp curvature via FFT\n        kappa_vof_fft = np.fft.fft(kappa_vof)\n        \n        # Define the wavenumbers corresponding to the FFT components\n        sample_spacing = L / N\n        wavenumbers = 2 * np.pi * np.fft.fftfreq(N, d=sample_spacing)\n        \n        # Construct the Gaussian filter in Fourier space\n        filter_G = np.exp(-0.5 * (epsilon * wavenumbers)**2)\n        \n        # Apply the filter in Fourier space\n        kappa_pf_fft = kappa_vof_fft * filter_G\n        \n        # Transform back to spatial domain via inverse FFT\n        kappa_pf = np.fft.ifft(kappa_pf_fft)\n        # Result should be real; take real part to remove numerical noise\n        kappa_pf_real = np.real(kappa_pf)\n        \n        # Calculate RMS curvature for PF\n        K_rms_pf = np.sqrt(np.mean(kappa_pf_real**2))\n        \n        # Calculate capillary-dominance number for PF\n        C_rms_pf = (sigma * K_rms_pf) / (rho * U**2)\n        \n        # Classify the PF regime using C_rms_pf and the same S\n        code_pf = classify(C_rms_pf, S)\n        \n        # 4. Bias Calculation\n        delta_C = C_rms_pf - C_rms_vof\n        \n        # Append results for the current case\n        results.append(code_vof)\n        results.append(code_pf)\n        results.append(delta_C)\n\n    # Format the final list for printing\n    # Floats are rounded to six decimal places, integers are kept as is.\n    formatted_results = []\n    for r in results:\n        if isinstance(r, float):\n            formatted_results.append(f\"{r:.6f}\")\n        else:\n            formatted_results.append(str(r))\n    \n    # Print the final aggregated list as a single-line string\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "在流型分类的前沿领域，数据驱动方法正展现出强大的潜力，它不再依赖于预设的简单阈值规则。本练习将引导我们进入这一领域，学习如何基于从流场数据中提取的物理特征，构建并训练一个如支持向量机(SVM)这样的高级分类器。我们将通过一个综合性的编程任务，利用基于物理洞察（如曲率统计和能量谱）合成的特征来模拟这一工作流程，从而体验流体力学原理与机器学习技术相结合的强大威力 。",
            "id": "3301488",
            "problem": "您的任务是构建并评估一个二元分类器，该分类器利用从流体体积（VOF）多相模拟中提取的特征来区分泡状流和搅动流两种流态。分类任务需在液体雷诺数范围 $Re_l \\in [10^4, 10^5]$ 内执行。您的解决方案必须从流体力学和湍流的基本原理出发，将其转化为针对VOF指示场的可复现的特征构建方法，然后实现一个在基于物理信息的合成特征上训练的支持向量分类器。最终程序必须产生单行输出，其中包含针对指定测试套件的预测类别标签。\n\n使用的基本原理包括：(i) 雷诺数的定义 $Re_l = \\rho_l U_l L/\\mu_l$，(ii) VOF相指示场 $\\alpha(\\mathbf{x},t) \\in [0,1]$ 及其界面曲率 $\\kappa(\\mathbf{x},t)$（通过界面单位法向量的散度定义）的定义，(iii) 在实验和解析模拟中观察到的泡状流和搅动流之间的定性差异，即气泡破碎频率、界面曲率统计以及$\\alpha$场在不同尺度上的谱含量的差异。您必须利用这些基本原理来论证如何构建随 $Re_l$ 和气体体积分数 $\\phi \\in (0,1)$ 变化的无量纲特征，且不参考任何原始模拟数据集。您不得假设可以访问任何外部数据。\n\n构建一个无量纲特征向量 $\\mathbf{f} \\in \\mathbb{R}^5$，该向量由以下分量组成，所有分量均作为无量纲量计算：\n- $f_1$：由特征长度缩放的平均绝对界面曲率（使其无量纲）。\n- $f_2$：界面曲率场概率密度函数（PDF）的偏度。\n- $f_3$：单位时间的无量纲气泡计数率，缩放为类似斯特劳哈尔数（Strouhal-like）的形式。\n- $f_4$：$\\alpha$场在中间波数带内方位角积分谱能量密度的谱斜率 $p$（使得在该带内 $E_\\alpha(k) \\sim k^{-p}$）。\n- $f_5$：$\\alpha$场在高于某个高波数阈值的谱能量占总能量的比例。\n\n为了使本练习在数值上具体且可复现，假设使用以下与上述物理原理一致的已校准无量纲特征模型。设 $s = \\log_{10}(Re_l/10^4)$ 且 $\\phi \\in [0.05, 0.30]$。对于每种流态 $r \\in \\{0,1\\}$，其中 $r=0$ 表示泡状流，$r=1$ 表示搅动流，定义\n$$\n\\begin{aligned}\nf_1(r; Re_l) = \n\\begin{cases}\n0.80 + 0.20\\, s + n_1,  r=0,\\\\\n1.50 + 0.30\\, s + n_1,  r=1,\n\\end{cases}\n\\\\\nf_2(r; Re_l) = \n\\begin{cases}\n0.70 - 0.10\\, s + n_2,  r=0,\\\\\n0.10 - 0.05\\, s + n_2,  r=1,\n\\end{cases}\n\\\\\nf_3(r; Re_l, \\phi) = \n\\begin{cases}\n0.50 + 0.20\\, \\phi + 0.30\\, s + n_3,  r=0,\\\\\n1.20 + 0.50\\, \\phi + 0.50\\, s + n_3,  r=1,\n\\end{cases}\n\\\\\nf_4(r; \\phi) = \n\\begin{cases}\n1.65 + 0.05\\, \\phi + n_4,  r=0,\\\\\n1.30 + 0.10\\, \\phi + n_4,  r=1,\n\\end{cases}\n\\\\\nf_5(r; Re_l) = \n\\begin{cases}\n0.15 + 0.05\\, s + n_5,  r=0,\\\\\n0.35 + 0.10\\, s + n_5,  r=1,\n\\end{cases}\n\\end{aligned}\n$$\n其中 $n_i \\sim \\mathcal{N}(0,\\sigma_i^2)$ 是独立高斯扰动，且 $(\\sigma_1,\\sigma_2,\\sigma_3,\\sigma_4,\\sigma_5) = (0.03, 0.05, 0.04, 0.02, 0.03)$。所有特征均为无量纲。这些形式编码了如下趋势：随着 $Re_l$ 的增加，与泡状流相比，搅动流表现出更高的曲率幅值、更宽且偏度更小的曲率PDF、更高的气泡计数率、更平坦的中间波数带谱斜率以及更大的高波数能量占比。\n\n通过最小化 $\\ell_2$正则化合页损失（hinge-loss）原始目标函数来训练一个线性支持向量分类器（SVC）：\n$$\n\\min_{\\mathbf{w}, b}\\; \\frac{\\lambda}{2}\\|\\mathbf{w}\\|_2^2 + \\frac{1}{m} \\sum_{i=1}^{m} \\max\\left(0,\\, 1 - y_i(\\mathbf{w}^\\top \\mathbf{x}_i + b)\\right),\n$$\n其中 $\\mathbf{x}_i \\in \\mathbb{R}^5$ 是标准化特征，$y_i \\in \\{-1,+1\\}$ 是从流态映射而来的类别标签（泡状流对应 $y=-1$，搅动流对应 $y=+1$），$\\lambda > 0$ 是正则化参数，$m$ 是训练样本的数量。使用与Pegasos算法一致的随机次梯度法，在第 $t$ 次迭代时步长为 $\\eta_t = 1/(\\lambda t)$，并且仅在间隔被违反时更新偏置项 $b$。仅使用训练集的统计数据将特征标准化为零均值和单位方差。\n\n您的程序必须：\n- 生成一个大小为 $m = 400$ 的合成训练数据集，每种流态包含 $m/2$ 个样本。通过在 $[10^4, 10^5]$ 上对 $\\log_{10}(Re_l)$ 进行均匀采样，在 $[0.05, 0.30]$ 上对 $\\phi$ 进行均匀采样，然后使用上述模型并设置固定的伪随机种子以保证可复现性来采样 $\\mathbf{f}$。按规定将流态 $r \\in \\{0,1\\}$ 映射到标签 $y \\in \\{-1,+1\\}$。\n- 在标准化特征上，使用随机次梯度法训练一个线性SVC，正则化参数 $\\lambda = 10^{-2}$，迭代次数 $T = 20000$ 次，初始权重 $\\mathbf{w}=\\mathbf{0}$，初始偏置 $b=0$。\n- 将训练好的分类器应用于以下测试套件，其中每个案例提供 $(Re_l, \\phi, r_{\\text{true}})$；仅使用 $r_{\\text{true}}$ 来合成特征，不用于预测：\n    1. $(Re_l = 10^4,\\; \\phi = 0.05,\\; r_{\\text{true}}=0)$\n    2. $(Re_l = 1.5 \\times 10^4,\\; \\phi = 0.10,\\; r_{\\text{true}}=0)$\n    3. $(Re_l = 5 \\times 10^4,\\; \\phi = 0.20,\\; r_{\\text{true}}=1)$\n    4. $(Re_l = 8 \\times 10^4,\\; \\phi = 0.15,\\; r_{\\text{true}}=1)$\n    5. $(Re_l = 10^5,\\; \\phi = 0.25,\\; r_{\\text{true}}=1)$\n    6. $(Re_l = 2 \\times 10^4,\\; \\phi = 0.30,\\; r_{\\text{true}}=0)$\n    7. $(Re_l = 7 \\times 10^4,\\; \\phi = 0.05,\\; r_{\\text{true}}=1)$\n    8. $(Re_l = 1.2 \\times 10^4,\\; \\phi = 0.20,\\; r_{\\text{true}}=0)$\n- 通过在零处对决策函数进行阈值处理来产生预测结果 $\\hat{r} \\in \\{0,1\\}$，将 $+1$ 映射到 $1$，将 $-1$ 映射到 $0$。\n\n最终输出格式：您的程序应生成单行输出，其中包含8个测试用例的预测类别标签，形式为方括号括起来的逗号分隔整数列表，例如 $[0,1,1,0,1,0,1,0]$。不得打印任何额外文本。本任务中所有量均为无量纲；输出中不需要物理单位。",
            "solution": "目标是构建并评估一个二元分类器，以区分泡状流（$r=0$）和搅动流（$r=1$）这两种多相流流态。该分类器是一个线性支持向量分类器（SVC），将在一个合成数据集上进行训练，该数据集的特征源自流体力学的基本原理。从特征论证到算法实现的整个过程被设计为自洽且可复现的。\n\n### 1. 基于物理信息的特征构建\n\n问题陈述要求基于在泡状流和搅动流之间观察到的物理差异，构建一个5维无量纲特征向量 $\\mathbf{f} \\in \\mathbb{R}^5$。这些差异是在高保真度的流体体积（VOF）模拟中观察到的。VOF方法使用一个相指示场 $\\alpha(\\mathbf{x}, t)$，它在一个相（例如液体）中为1，在另一个相（例如气体）中为0，中间值 $0  \\alpha  1$ 代表界面。设计的特征旨在捕捉这两个流态在该场中的关键统计和形态学差异。\n\n-   **$f_1$：平均绝对界面曲率  $f_2$：曲率偏度**：界面曲率由 $\\kappa = \\nabla \\cdot \\mathbf{n}$ 给出，其中 $\\mathbf{n} = \\nabla\\alpha / \\|\\nabla\\alpha\\|$ 是界面法线。在泡状流中，气泡相对呈球形且稳定，导致曲率分布较窄。搅动流的特点是剧烈、混沌的界面运动，包括拉伸、聚并和破碎。这会产生更大范围的界面形状，从大的、扭曲的结构到小的液滴和液丝，从而导致更高的平均绝对曲率（$f_1$）和更宽、更对称（即偏度更小，$f_2$）的$\\kappa$概率密度函数（PDF）。所提供的 $f_1$ 和 $f_2$ 模型正确地反映了搅动流（$r=1$）比泡状流（$r=0$）具有更高的平均曲率和更低的偏度。\n\n-   **$f_3$：无量纲气泡计数率**：搅动流涉及频繁的破碎和聚并事件。这种高拓扑变化率可以通过一个特征频率来量化。当无量纲化后（例如，以斯特劳哈尔数的形式），预计这个速率（$f_3$）在搅动流中会显著高于相对静止的泡状流。$f_3$ 的模型显示，对于搅动流态，其基值更大，并且对气体体积分数 $\\phi$ 和雷诺数 $Re_l$ 的依赖性更强。\n\n-   **$f_4$：谱斜率  $f_5$：高波数能量分数**：由 $\\alpha(\\mathbf{x}, t)$ 场封装的相空间分布可以在傅里叶空间中进行分析。谱能量密度 $E_\\alpha(k)$ 描述了 $\\alpha$ 场的方差如何在不同长度尺度（与波数 $k$ 相关）上分布。湍流通常表现出幂律标度，$E_\\alpha(k) \\sim k^{-p}$。搅动流中的混沌破碎过程不断产生小尺度的界面结构。这种结构向更小尺度的“级串”导致高波数处有更多的能量。因此，预计搅动流将具有更平坦的谱斜率（更小的指数 $p$，由 $f_4$ 表示）和在某个高波数截止值以上的总谱能量中占有更大比例（$f_5$）。所提供的 $f_4$ 和 $f_5$ 模型与此物理推理一致。\n\n### 2. 合成数据生成\n\n为了创建一个可复现的机器学习任务，我们不使用原始模拟数据。相反，我们使用所提供的已校准模型，这些模型在数学上编码了上述的物理趋势。生成一个大小为 $m=400$ 的训练数据集，每个流态有 $200$ 个样本。对于每个样本，液体雷诺数 $Re_l$ 的抽样方式使得 $\\log_{10}(Re_l)$ 在 $[4, 5]$ 上均匀分布，气体体积分数 $\\phi$ 在 $[0.05, 0.30]$ 上均匀抽样。因此，参数 $s = \\log_{10}(Re_l/10^4)$ 在 $[0,1]$ 上均匀分布。这些参数与真实的流态标签 $r$ 一起决定了特征的均值。将具有指定方差的独立高斯噪声 $n_i \\sim \\mathcal{N}(0, \\sigma_i^2)$ 添加到每个特征分量中，以模拟复杂流动测量中的内在可变性。泡状流态（$r=0$）被映射到类别标签 $y=-1$，搅动流态（$r=1$）被映射到 $y=+1$。\n\n### 3. 分类器模型与训练算法\n\n训练一个线性支持向量分类器（SVC）以在特征空间中找到一个最优分离超平面 $(\\mathbf{w}, b)$。参数 $\\mathbf{w} \\in \\mathbb{R}^5$ 和 $b \\in \\mathbb{R}$ 通过最小化 $\\ell_2$正则化合页损失目标函数来找到：\n$$\n\\min_{\\mathbf{w}, b}\\; \\frac{\\lambda}{2}\\|\\mathbf{w}\\|_2^2 + \\frac{1}{m} \\sum_{i=1}^{m} \\max\\left(0,\\, 1 - y_i(\\mathbf{w}^\\top \\mathbf{x}_i + b)\\right)\n$$\n此处，$\\mathbf{x}_i$ 是标准化后的特征向量，$y_i$ 是类别标签，$\\lambda = 10^{-2}$ 是正则化参数，用于平衡间隔最大化和分类误差。\n\n**特征标准化**：在训练之前，原始特征 $\\mathbf{f}_i$ 被标准化为零均值和单位方差。均值 $\\boldsymbol{\\mu}$ 和标准差 $\\boldsymbol{\\sigma}$ *仅*根据训练数据计算：$\\mathbf{x}_i = (\\mathbf{f}_i - \\boldsymbol{\\mu}) / \\boldsymbol{\\sigma}$。这是防止测试集数据泄露并确保所有特征无论其原始尺度如何都能对决策函数做出同等贡献的关键步骤。\n\n**训练算法**：我们采用随机次梯度法。在每次迭代 $t=1, \\dots, T$（其中 $T=20000$）时，随机选择一个训练样本 $(\\mathbf{x}_i, y_i)$。学习率设置为 $\\eta_t = 1/(\\lambda t)$。使用目标函数相对于该单个样本的次梯度来更新参数。\n更新规则如下：\n首先，对权重应用一个“衰减”步骤，该步骤对应于正则化项的梯度：\n$$\n\\mathbf{w} \\leftarrow \\left(1 - \\eta_t \\lambda\\right) \\mathbf{w}\n$$\n接下来，检查间隔条件 $y_i(\\mathbf{w}^\\top \\mathbf{x}_i + b)  1$。如果样本被误分类或位于间隔内部（即条件为真），则执行基于合页损失次梯度的额外更新：\n$$\n\\begin{aligned}\n\\mathbf{w} \\leftarrow \\mathbf{w} + \\eta_t y_i \\mathbf{x}_i \\\\\nb \\leftarrow b + \\eta_t y_i\n\\end{aligned}\n$$\n如果间隔条件为假，则样本被正确分类于间隔之外，合页损失的次梯度为零，因此不对 $\\mathbf{w}$ 或 $b$ 进行进一步更新。此过程与Pegasos算法和问题规范一致。\n\n### 4. 预测\n\n经过 $T$ 次训练迭代后，获得最终模型 $(\\mathbf{w}, b)$。为了对新的测试样本进行分类，首先使用相同的物理模型（根据问题的采样指令，包括一个随机噪声分量）生成其特征，然后使用*训练*集的均值和标准差进行标准化。计算决策函数 $d = \\mathbf{w}^\\top \\mathbf{x}_{\\text{test}} + b$。预测的流态 $\\hat{r}$ 由 $d$ 的符号确定：\n$$\n\\hat{r} = \\begin{cases} 1  \\text{若 } d \\ge 0 \\quad (\\text{预测标签为 } +1, \\text{搅动流}) \\\\ 0  \\text{若 } d  0 \\quad (\\text{预测标签为 } -1, \\text{泡状流}) \\end{cases}\n$$\n此过程应用于指定测试套件中的全部8个案例，所得的预测流态列表构成最终输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the full pipeline for training a linear SVC to classify flow regimes\n    and predicting on a given test suite.\n    \"\"\"\n    # Set seed for reproducibility of all random operations.\n    SEED = 42\n    np.random.seed(SEED)\n\n    # --- Constants and Hyperparameters ---\n    M_TRAIN = 400\n    N_FEATURES = 5\n    LAMBDA_REG = 1e-2\n    T_ITERATIONS = 20000\n    SIGMAS = np.array([0.03, 0.05, 0.04, 0.02, 0.03])\n\n    def generate_features(r, Re_l, phi):\n        \"\"\"\n        Generates a 5-dimensional feature vector for a given regime and parameters.\n        Includes a stochastic noise component.\n\n        Args:\n            r (int): Regime label (0 for bubbly, 1 for churn).\n            Re_l (float): Liquid Reynolds number.\n            phi (float): Gas volume fraction.\n\n        Returns:\n            np.ndarray: The 5-dimensional feature vector.\n        \"\"\"\n        s = np.log10(Re_l / 10000.0)\n        n = np.random.normal(0.0, SIGMAS)\n        f = np.zeros(N_FEATURES)\n        \n        if r == 0:  # Bubbly flow\n            f[0] = 0.80 + 0.20 * s + n[0]\n            f[1] = 0.70 - 0.10 * s + n[1]\n            f[2] = 0.50 + 0.20 * phi + 0.30 * s + n[2]\n            f[3] = 1.65 + 0.05 * phi + n[3]\n            f[4] = 0.15 + 0.05 * s + n[4]\n        else:  # r == 1, Churn flow\n            f[0] = 1.50 + 0.30 * s + n[0]\n            f[1] = 0.10 - 0.05 * s + n[1]\n            f[2] = 1.20 + 0.50 * phi + 0.50 * s + n[2]\n            f[3] = 1.30 + 0.10 * phi + n[3]\n            f[4] = 0.35 + 0.10 * s + n[4]\n            \n        return f\n\n    # --- 1. Generate Synthetic Training Data ---\n    n_per_class = M_TRAIN // 2\n    X_train_raw = np.zeros((M_TRAIN, N_FEATURES))\n    y_train = np.zeros(M_TRAIN)\n\n    # Generate bubbly flow samples (r=0, y=-1)\n    for i in range(n_per_class):\n        log_rel_bubbly = np.random.uniform(4.0, 5.0)\n        phi_bubbly = np.random.uniform(0.05, 0.30)\n        Re_l = 10**log_rel_bubbly\n        X_train_raw[i, :] = generate_features(r=0, Re_l=Re_l, phi=phi_bubbly)\n        y_train[i] = -1.0\n\n    # Generate churn flow samples (r=1, y=1)\n    for i in range(n_per_class):\n        log_rel_churn = np.random.uniform(4.0, 5.0)\n        phi_churn = np.random.uniform(0.05, 0.30)\n        Re_l = 10**log_rel_churn\n        X_train_raw[n_per_class + i, :] = generate_features(r=1, Re_l=Re_l, phi=phi_churn)\n        y_train[n_per_class + i] = 1.0\n\n    # --- 2. Standardize Features ---\n    # Compute mean and std dev from the training set only\n    mu = np.mean(X_train_raw, axis=0)\n    std = np.std(X_train_raw, axis=0)\n    # Prevent division by zero, though unlikely with noise model\n    std[std == 0] = 1.0\n    \n    X_train_std = (X_train_raw - mu) / std\n\n    # --- 3. Train Linear SVC with Stochastic Subgradient Method ---\n    w = np.zeros(N_FEATURES)\n    b = 0.0\n\n    # The order of random sampling during training is part of the reproducible process\n    training_indices = np.random.randint(0, M_TRAIN, T_ITERATIONS)\n\n    for t_idx, item_idx in enumerate(training_indices):\n        t = t_idx + 1  # Iteration count from 1\n        x_i = X_train_std[item_idx]\n        y_i = y_train[item_idx]\n        eta_t = 1.0 / (LAMBDA_REG * t)\n\n        decision_val = y_i * (np.dot(w, x_i) + b)\n        \n        # Regularization update (always applied)\n        w *= (1.0 - eta_t * LAMBDA_REG)\n\n        if decision_val  1.0:\n            # Hinge loss update (applied only when margin is violated)\n            w += eta_t * y_i * x_i\n            b += eta_t * y_i\n\n    # --- 4. Prediction on Test Suite ---\n    test_cases = [\n        # (Re_l, phi, r_true)\n        (1e4, 0.05, 0),\n        (1.5e4, 0.10, 0),\n        (5e4, 0.20, 1),\n        (8e4, 0.15, 1),\n        (1e5, 0.25, 1),\n        (2e4, 0.30, 0),\n        (7e4, 0.05, 1),\n        (1.2e4, 0.20, 0)\n    ]\n\n    # Generate features for the test suite. The random state continues from training.\n    X_test_raw = np.array([generate_features(r=r_true, Re_l=Re_l, phi=phi) \n                           for Re_l, phi, r_true in test_cases])\n\n    # Standardize test features using training set statistics\n    X_test_std = (X_test_raw - mu) / std\n\n    results = []\n    for x_test in X_test_std:\n        decision = np.dot(w, x_test) + b\n        # Map decision function output to regime label: >= 0 -> +1 (churn/1),  0 -> -1 (bubbly/0)\n        r_pred = 1 if decision >= 0 else 0\n        results.append(r_pred)\n\n    # --- 5. Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}