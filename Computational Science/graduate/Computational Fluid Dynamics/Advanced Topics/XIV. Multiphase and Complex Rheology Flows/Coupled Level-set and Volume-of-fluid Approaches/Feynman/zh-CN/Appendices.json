{
    "hands_on_practices": [
        {
            "introduction": "在构建复杂的多相流模拟之前，验证其基本组件能否正确工作至关重要。本练习专注于计算界面法向量和曲率，这对于精确模拟表面张力等界面现象是必不可少的。通过一个采用简单已知几何形状（圆形）的“补丁测试”(patch test)，我们将严格地衡量数值方法的准确性，并揭示水平集函数满足符号距离属性（即Eikonal条件，$|\\nabla \\phi| = 1$）的关键作用，以及违反该条件将如何影响几何计算的精度。",
            "id": "3305511",
            "problem": "设计并实现一个用于耦合水平集和流体体积法（CLSVOF）的数值界面法向贴片测试。从第一性原理和核心定义出发，避免使用任何预封装的界面重构快捷方法。您将为已知几何形状规定精确场，然后计算数值界面法线和曲率。您将验证网格细化下的收敛阶，并识别平流后违反 Eikonal 条件时引入的偏差。所有计算均在二维空间中进行，且为无量纲。\n\n基本原理：\n- 水平集（LS）函数是一个标量场 $ \\phi(\\mathbf{x}) $，其零等值线表示界面。对于有符号距离水平集，$ |\\nabla \\phi| = 1 $。\n- 流体体积法（VOF）颜色函数是一个标量场 $ C(\\mathbf{x}) \\in [0,1] $，表示相指示器。我们使用从 $ \\phi $到 $ C $的正则化 Heaviside 映射来获得离散体积分数的光滑代理：对于平滑半宽 $ \\varepsilon > 0 $，\n$$\nH_\\varepsilon(\\phi) =\n\\begin{cases}\n0, & \\phi \\le -\\varepsilon, \\\\\n\\frac{1}{2} + \\frac{\\phi}{2\\varepsilon} + \\frac{1}{2\\pi}\\sin\\!\\left(\\pi \\frac{\\phi}{\\varepsilon}\\right), & |\\phi| < \\varepsilon, \\\\\n1, & \\phi \\ge \\varepsilon.\n\\end{cases}\n$$\n然后定义 $ C = H_\\varepsilon(\\phi) $。\n- 从标量场 $ f $得到的单位法向量为 $ \\mathbf{n}_f = \\nabla f / \\lVert \\nabla f \\rVert $，其中 $ \\lVert \\cdot \\rVert $ 表示欧几里得范数。\n- 曲率定义为 $ \\kappa = \\nabla \\cdot \\left( \\nabla \\phi / \\lVert \\nabla \\phi \\rVert \\right) $。对于半径为 $ R $、法线向外的圆，精确曲率为 $ \\kappa_{\\text{exact}} = 1/R $。\n\n几何形状与精确场：\n- 考虑单位正方形域 $ [0,1] \\times [0,1] $，该域在均匀笛卡尔网格上离散化，具有 $ N \\times N $ 个单元中心，坐标为 $ x_i = (i + \\tfrac{1}{2}) \\Delta x $，$ y_j = (j + \\tfrac{1}{2}) \\Delta x $，其中 $ \\Delta x = 1/N $ 且 $ i,j \\in \\{0,1,\\dots,N-1\\} $。\n- 设精确几何形状为一个以 $ (x_0,y_0) = (0.5,0.5) $ 为中心、半径为 $ R = 0.3 $ 的圆。精确的有符号距离水平集为\n$$\n\\phi_{\\text{sd}}(x,y) = \\sqrt{(x-x_0)^2 + (y-y_0)^2} - R.\n$$\n- 通过保持零等值线不变的光滑重参数化来定义一个平流后的（非 Eikonal）水平集：\n$$\n\\phi_{\\text{adv}}(x,y) = \\phi_{\\text{sd}}(x,y)\\bigl(1 + \\beta x\\bigr) + \\gamma \\, \\phi_{\\text{sd}}(x,y)^2,\n$$\n其中 $ \\beta = 0.5 $ 且 $ \\gamma = 0.25 \\beta $。这在同一个圆上满足 $ \\phi_{\\text{adv}} = 0 $，但通常情况下 $ |\\nabla \\phi_{\\text{adv}}| \\ne 1 $。\n- 定义正则化半宽为 $ \\varepsilon = \\alpha \\Delta x $，其中 $ \\alpha = 1.5 $，并对选定的 $ \\phi $ 设置 $ C = H_\\varepsilon(\\phi) $。\n\n离散化：\n- 使用二阶中心有限差分在均匀网格上近似空间梯度和散度。对于在单元中心采样的任何足够光滑的标量场 $ f $，在每个方向上使用中心差分近似 $ \\nabla f $。类似地，对于向量场 $ \\mathbf{g} $，通过分量上应用中心差分来近似 $ \\nabla \\cdot \\mathbf{g} $。\n- 从 $ \\phi $ 计算基于 LS 的单位法向量 $ \\mathbf{n}_\\phi $，从平滑后的 $ C $ 计算基于 VOF 的单位法向量 $ \\mathbf{n}_C $，两种情况都通过归一化数值计算出的梯度来得到。\n- 计算基于 LS 的曲率 $ \\kappa_\\phi = \\nabla \\cdot \\mathbf{n}_\\phi $。\n\n误差度量与界面带：\n- 定义圆的精确单位法向量为\n$$\n\\mathbf{n}_{\\text{exact}}(x,y) = \\frac{1}{\\sqrt{(x-x_0)^2 + (y-y_0)^2}}\\begin{bmatrix} x-x_0 \\\\ y-y_0 \\end{bmatrix},\n$$\n在网格点上求值，精确曲率为 $ \\kappa_{\\text{exact}} = 1/R $。\n- 使用精确有符号距离场定义一个界面带（窄带）：包含满足 $ |\\phi_{\\text{sd}}(x,y)| \\le 2\\varepsilon $ 的网格点。所有误差范数仅在此带上计算。\n- 对于向量误差 $ \\mathbf{e} = \\mathbf{a} - \\mathbf{b} $，使用逐点大小 $ \\lVert \\mathbf{e} \\rVert $。对于标量误差 $ e = a - b $，使用绝对值 $ |e| $。将带上的离散 $ L^2 $ 误差定义为带上逐点误差平方的算术平均值的平方根。\n\n任务：\n- 对于每个分辨率 $ N \\in \\{32, 64, 128\\} $，对 $ \\phi_{\\text{sd}} $ 和 $ \\phi_{\\text{adv}} $ 计算带上的以下三个 $ L^2 $ 误差：\n  1. LS 法向误差 $ E_{n,\\phi}(N) $，即 $ \\mathbf{n}_\\phi $ 与 $ \\mathbf{n}_{\\text{exact}} $ 之间的误差。\n  2. VOF 法向误差 $ E_{n,C}(N) $，即 $ \\mathbf{n}_C $ 与 $ \\mathbf{n}_{\\text{exact}} $ 之间的误差。\n  3. LS 曲率误差 $ E_{\\kappa,\\phi}(N) $，即 $ \\kappa_\\phi $ 与 $ \\kappa_{\\text{exact}} $ 之间的误差。\n- 对每个量，使用标准定义计算连续细化之间的观测收敛阶\n$$\np = \\frac{\\log\\!\\bigl(E(N_1)/E(N_2)\\bigr)}{\\log\\!\\bigl(\\Delta x_{N_1}/\\Delta x_{N_2}\\bigr)} = \\frac{\\log\\!\\bigl(E(N_1)/E(N_2)\\bigr)}{\\log\\!\\bigl(N_2/N_1\\bigr)}.\n$$\n具体计算对 $ (N_1,N_2) \\in \\{(32,64), (64,128)\\} $ 的收敛阶。\n- 通过在最细网格 $ N = 128 $ 上计算梯度大小与 1 的带平均偏差，来量化带内的 Eikonal 偏差，即\n$$\nB(\\phi) = \\text{mean over band}\\bigl(|\\,\\lVert \\nabla \\phi \\rVert - 1\\,|\\bigr),\n$$\n对 $ \\phi_{\\text{sd}} $ 和 $ \\phi_{\\text{adv}} $ 均进行计算。\n\n测试套件：\n- 几何参数：$ (x_0,y_0) = (0.5,0.5) $，$ R = 0.3 $。\n- 正则化：$ \\alpha = 1.5 $，因此 $ \\varepsilon = \\alpha \\Delta x $。\n- 平流参数：$ \\beta = 0.5 $，$ \\gamma = 0.25 \\beta $。\n- 分辨率：$ N \\in \\{32, 64, 128\\} $。\n\n要求输出：\n- 按下列顺序计算并报告以下 $ 14 $ 个浮点数值：\n  1. 对于 $ \\phi_{\\text{sd}} $：LS 法向误差的两个观测阶 $ \\bigl(p_{n,\\phi}^{32\\to64}, p_{n,\\phi}^{64\\to128}\\bigr) $。\n  2. 对于 $ \\phi_{\\text{sd}} $：VOF 法向误差的两个观测阶 $ \\bigl(p_{n,C}^{32\\to64}, p_{n,C}^{64\\to128}\\bigr) $。\n  3. 对于 $ \\phi_{\\text{sd}} $：LS 曲率误差的两个观测阶 $ \\bigl(p_{\\kappa,\\phi}^{32\\to64}, p_{\\kappa,\\phi}^{64\\to128}\\bigr) $。\n  4. 对于 $ \\phi_{\\text{adv}} $：LS 法向误差的两个观测阶 $ \\bigl(\\tilde{p}_{n,\\phi}^{32\\to64}, \\tilde{p}_{n,\\phi}^{64\\to128}\\bigr) $。\n  5. 对于 $ \\phi_{\\text{adv}} $：VOF 法向误差的两个观测阶 $ \\bigl(\\tilde{p}_{n,C}^{32\\to64}, \\tilde{p}_{n,C}^{64\\to128}\\bigr) $。\n  6. 对于 $ \\phi_{\\text{adv}} $：LS 曲率误差的两个观测阶 $ \\bigl(\\tilde{p}_{\\kappa,\\phi}^{32\\to64}, \\tilde{p}_{\\kappa,\\phi}^{64\\to128}\\bigr) $。\n  7. 在 $ N = 128 $ 时的两个偏差度量：$ B(\\phi_{\\text{sd}}) $ 和 $ B(\\phi_{\\text{adv}}) $。\n- 最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,...]”）。不要包含空格。所有报告的值都是无量纲实数。\n\n约束与现实性：\n- 将所有有限差分操作限制在均匀网格上，并且在计算法线或曲率时仅使用中心差分所隐含的数值微分；不要调用 $ \\phi $ 或 $ C $ 的任何解析导数。\n- 实现必须是自包含的，不需要用户输入，并且只使用指定的计算库。",
            "solution": "用户提供了一个关于计算流体动力学中数值贴片测试的适定问题陈述。该问题具有科学依据、自成体系，并要求进行一系列与耦合水平集和流体体积法（CLSVOF）相关的特定计算和误差分析。所有定义、参数和要求的输出都已明确指定。因此，该问题被认为是有效的，下面提供了完整的解决方案。\n\n该问题要求实现和分析一个数值贴片测试，以评估从水平集（LS）和流体体积法（VOF）标量场派生的界面法线和曲率计算的准确性。分析在一个静态圆形界面上进行，该界面的精确解析解是已知的。这使得能够精确量化数值误差，并研究网格细化下的收敛率。研究的一个关键方面是比较从满足 Eikonal 条件 $|\\nabla \\phi| = 1$ 的有符号距离水平集函数获得的结果，与从非 Eikonal 场获得的结果，后者代表了因数值平流而失真的水平集函数。\n\n解决方案的基本步骤如下：\n1.  对每个网格分辨率，离散化域并在单元中心评估解析的 LS 和 VOF 场。\n2.  使用二阶中心有限差分数值计算 LS 和 VOF 场的梯度。\n3.  通过归一化计算出的梯度来计算界面法向量。\n4.  通过求取基于 LS 的法向量场的散度来计算界面曲率。\n5.  通过在界面周围指定的窄带内将数值法线和曲率与精确解析值进行比较，计算它们的 $L^2$ 误差。\n6.  根据三个连续网格分辨率下的误差，确定每个计算量的观测收敛阶。\n7.  对于有符号距离和失真的 LS 场，量化 Eikonal 偏差，即 LS 梯度大小与 1 的偏差。\n\n让我们将数值过程形式化。域是单位正方形 $[0,1] \\times [0,1]$，被离散化为 $N \\times N$ 的网格。单元中心位于 $(x_i, y_j) = ((i + 0.5)\\Delta x, (j + 0.5)\\Delta x)$，其中 $i,j \\in \\{0, \\dots, N-1\\}$，网格间距为 $\\Delta x = 1/N$。\n\n对于定义在网格上的标量场 $f$，其梯度 $\\nabla f = (\\partial_x f, \\partial_y f)$ 使用二阶中心差分进行近似。如果 $f_{i,j}$ 表示在网格节点 $(i,j)$ 处 $f$ 的值，则梯度的分量近似为：\n$$\n(\\partial_x f)_{i,j} \\approx \\frac{f_{i+1,j} - f_{i-1,j}}{2\\Delta x}, \\quad\n(\\partial_y f)_{i,j} \\approx \\frac{f_{i,j+1} - f_{i,j-1}}{2\\Delta x}\n$$\n对于向量场 $\\mathbf{g} = (g_x, g_y)$，其散度 $\\nabla \\cdot \\mathbf{g}$ 类似地近似为：\n$$\n(\\nabla \\cdot \\mathbf{g})_{i,j} \\approx \\frac{(g_x)_{i+1,j} - (g_x)_{i-1,j}}{2\\Delta x} + \\frac{(g_y)_{i,j+1} - (g_y)_{i,j-1}}{2\\Delta y}\n$$\n这些中心差分格式用于内部网格点，而边界上通常使用一阶格式。\n\n从场 $f$（$\\phi$ 或 $C$）得到的数值单位法向量 $\\mathbf{n}_f$ 是通过首先近似 $\\nabla f$，然后在每个网格点上归一化结果来计算的：\n$$\n\\mathbf{n}_f = \\frac{\\nabla_{\\text{num}} f}{\\lVert \\nabla_{\\text{num}} f \\rVert_2}\n$$\n其中 $\\nabla_{\\text{num}}$ 表示有限差分梯度算子，$\\lVert \\cdot \\rVert_2$ 是欧几里得范数。\n\n基于 LS 的曲率 $\\kappa_\\phi$ 是通过计算数值 LS 单位法向量场 $\\mathbf{n}_\\phi$ 的数值散度得到的：\n$$\n\\kappa_\\phi = \\nabla_{\\text{num}} \\cdot \\mathbf{n}_\\phi\n$$\n\nVOF 场 $C$ 是从给定的水平集场 $\\phi$ 通过正则化的 Heaviside 函数 $H_\\varepsilon(\\phi)$ 导出的，其中平滑宽度 $\\varepsilon = \\alpha \\Delta x = 1.5 \\Delta x$ 与网格间距成正比。这种构造提供了 $C$ 在界面上从 $0$到 $1$ 的平滑过渡，这对于计算有意义的梯度 $\\nabla C$ 是必要的。\n\n分析区分了两种水平集场：\n1.  精确的有符号距离函数 $\\phi_{\\text{sd}}(x,y) = \\sqrt{(x-x_0)^2 + (y-y_0)^2} - R$，它在任何地方都满足 $|\\nabla \\phi_{\\text{sd}}| = 1$。\n2.  “平流后的”非 Eikonal 函数 $\\phi_{\\text{adv}}(x,y) = \\phi_{\\text{sd}}(x,y)(1 + \\beta x) + \\gamma \\phi_{\\text{sd}}(x,y)^2$。该函数与 $\\phi_{\\text{sd}}$ 共享相同的零等值线，但违反了 Eikonal 条件，即通常情况下 $|\\nabla \\phi_{\\text{adv}}| \\neq 1$。这模拟了有符号距离场在流场中平流后未经重新初始化步骤而发生的畸变。\n\n误差在离散 $L^2$ 范数中计算，定义为位于界面带 $\\{ (x,y) \\mid |\\phi_{\\text{sd}}(x,y)| \\le 2\\varepsilon \\}$ 内的网格点上逐点误差平方的均值的平方根。例如，LS 法向误差为：\n$$\nE_{n,\\phi}(N) = \\sqrt{ \\frac{1}{N_{\\text{band}}} \\sum_{(i,j) \\in \\text{band}} \\lVert \\mathbf{n}_\\phi(x_i, y_j) - \\mathbf{n}_{\\text{exact}}(x_i, y_j) \\rVert_2^2 }\n$$\n其中 $N_{\\text{band}}$ 是带内的网格点数。\n\n两个分辨率 $N_1$ 和 $N_2$ 之间的观测收敛阶 $p$ 计算如下：\n$$\np = \\frac{\\log(E(N_1)/E(N_2))}{\\log(N_2/N_1)}\n$$\n对于使用二阶精度格式计算的量，期望值为 $p \\approx 2$。然而，对于像从 $\\phi_{\\text{adv}}$ 计算的曲率这样的量，理论定义 $\\kappa = \\nabla \\cdot (\\nabla \\phi/|\\nabla \\phi|)$ 仅对有符号距离场有效。当 $|\\nabla \\phi| \\neq 1$ 时，此公式引入了一个不随网格细化而减小的建模误差，导致零阶收敛（$p \\approx 0$）。\n\n最后，Eikonal 偏差 $B(\\phi)$ 是数值梯度大小与 1 的带平均偏差。该度量直接量化了未能满足有符号距离属性的情况，这是曲率计算不准确的主要原因。\n\n我们继续进行实现，将系统地为分辨率 $N \\in \\{32, 64, 128\\}$ 计算这些量，并按要求报告收敛阶和偏差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef H_eps(phi, eps):\n    \"\"\"\n    Computes the regularized Heaviside function H_epsilon(phi).\n    \"\"\"\n    C = np.zeros_like(phi)\n    \n    # Case phi = -eps: C is already 0.\n    \n    # Case phi >= eps\n    C[phi >= eps] = 1.0\n    \n    # Case |phi|  eps\n    mid_mask = np.abs(phi)  eps\n    phi_mid = phi[mid_mask]\n    \n    C[mid_mask] = 0.5 + phi_mid / (2 * eps) + (1.0 / (2.0 * np.pi)) * np.sin(np.pi * phi_mid / eps)\n    \n    return C\n\ndef get_order(err1, err2, N1, N2):\n    \"\"\"\n    Computes the convergence order p.\n    Handles potential division by zero if errors are extremely small.\n    \"\"\"\n    if err1 == 0.0 or err2 == 0.0:\n        return 0.0\n    return np.log(err1 / err2) / np.log(N2 / N1)\n\ndef analyze_field(phi, phi_sd_for_band, N, dx, grid_x, grid_y, x0, y0, alpha, kappa_exact):\n    \"\"\"\n    Performs the analysis for a given level-set field: calculates normals,\n    curvature, and errors.\n    \"\"\"\n    eps = alpha * dx\n    band_mask = np.abs(phi_sd_for_band) = 2 * eps\n    \n    # Avoid division by zero if the band is empty, though unlikely.\n    if not np.any(band_mask):\n        return 0.0, 0.0, 0.0, 0.0\n\n    # Exact normals on the grid for error calculation\n    r_dist = np.sqrt((grid_x - x0)**2 + (grid_y - y0)**2)\n    # Avoid division by zero at the circle center\n    safe_r = np.where(r_dist == 0, 1.0, r_dist)\n    n_exact_x = (grid_x - x0) / safe_r\n    n_exact_y = (grid_y - y0) / safe_r\n    \n    safety_factor = 1e-15\n\n    # VOF field from the given LS field\n    C = H_eps(phi, eps)\n    \n    # --- LS-based calculations ---\n    # Gradient of phi. np.gradient returns (dy, dx) for a (y, x) indexed grid.\n    grad_phi_y, grad_phi_x = np.gradient(phi, dx)\n    \n    # Normals from phi\n    norm_grad_phi = np.sqrt(grad_phi_x**2 + grad_phi_y**2)\n    n_phi_x = grad_phi_x / (norm_grad_phi + safety_factor)\n    n_phi_y = grad_phi_y / (norm_grad_phi + safety_factor)\n    \n    # Curvature from phi\n    # div(n) = d(nx)/dx + d(ny)/dy\n    grad_nx_y, grad_nx_x = np.gradient(n_phi_x, dx)\n    grad_ny_y, grad_ny_x = np.gradient(n_phi_y, dx)\n    kappa_phi = grad_nx_x + grad_ny_y\n    \n    # --- VOF-based calculations ---\n    # Gradient and normals from C\n    grad_C_y, grad_C_x = np.gradient(C, dx)\n    norm_grad_C = np.sqrt(grad_C_x**2 + grad_C_y**2)\n    n_C_x = grad_C_x / (norm_grad_C + safety_factor)\n    n_C_y = grad_C_y / (norm_grad_C + safety_factor)\n    \n    # --- Error Calculations ---\n    # L2 error of LS-normal\n    err_n_phi = np.sqrt(np.mean(((n_phi_x - n_exact_x)**2 + (n_phi_y - n_exact_y)**2)[band_mask]))\n    \n    # L2 error of VOF-normal\n    err_n_C = np.sqrt(np.mean(((n_C_x - n_exact_x)**2 + (n_C_y - n_exact_y)**2)[band_mask]))\n    \n    # L2 error of LS-curvature\n    err_k_phi = np.sqrt(np.mean(((kappa_phi - kappa_exact)**2)[band_mask]))\n    \n    # --- Eikonal Bias Calculation ---\n    # Bias is mean(| |grad(phi)| - 1 |) over the band\n    bias = np.mean(np.abs(norm_grad_phi - 1.0)[band_mask])\n    \n    return err_n_phi, err_n_C, err_k_phi, bias\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = {\n        'params': {\n            'x0': 0.5, 'y0': 0.5, 'R': 0.3,\n            'alpha': 1.5, 'beta': 0.5,\n        },\n        'resolutions': [32, 64, 128]\n    }\n    \n    params = test_cases['params']\n    resolutions = test_cases['resolutions']\n    \n    # Derived parameters\n    params['gamma'] = 0.25 * params['beta']\n    params['kappa_exact'] = 1.0 / params['R']\n\n    errors_sd = {'n_phi': [], 'n_C': [], 'k_phi': []}\n    errors_adv = {'n_phi': [], 'n_C': [], 'k_phi': []}\n    \n    bias_sd_128, bias_adv_128 = 0.0, 0.0\n\n    for N in resolutions:\n        dx = 1.0 / N\n        grid_pts = np.linspace(0.5 * dx, 1.0 - 0.5 * dx, N)\n        # grid_x varies along axis 1, grid_y along axis 0\n        grid_x, grid_y = np.meshgrid(grid_pts, grid_pts)\n\n        # Define analytical fields on the grid\n        phi_sd = np.sqrt((grid_x - params['x0'])**2 + (grid_y - params['y0'])**2) - params['R']\n        phi_adv = phi_sd * (1 + params['beta'] * grid_x) + params['gamma'] * phi_sd**2\n\n        # --- Analyze phi_sd ---\n        err_n_phi_sd, err_n_C_sd, err_k_phi_sd, bias_sd = analyze_field(\n            phi_sd, phi_sd, N, dx, grid_x, grid_y, \n            params['x0'], params['y0'], params['alpha'], params['kappa_exact']\n        )\n        errors_sd['n_phi'].append(err_n_phi_sd)\n        errors_sd['n_C'].append(err_n_C_sd)\n        errors_sd['k_phi'].append(err_k_phi_sd)\n\n        # --- Analyze phi_adv ---\n        err_n_phi_adv, err_n_C_adv, err_k_phi_adv, bias_adv = analyze_field(\n            phi_adv, phi_sd, N, dx, grid_x, grid_y, \n            params['x0'], params['y0'], params['alpha'], params['kappa_exact']\n        )\n        errors_adv['n_phi'].append(err_n_phi_adv)\n        errors_adv['n_C'].append(err_n_C_adv)\n        errors_adv['k_phi'].append(err_k_phi_adv)\n\n        # Store bias values for the finest grid\n        if N == 128:\n            bias_sd_128 = bias_sd\n            bias_adv_128 = bias_adv\n\n    # Post-process to calculate convergence orders\n    results = []\n    \n    # 1. phi_sd: LS-normal orders\n    results.append(get_order(errors_sd['n_phi'][0], errors_sd['n_phi'][1], 32, 64))\n    results.append(get_order(errors_sd['n_phi'][1], errors_sd['n_phi'][2], 64, 128))\n\n    # 2. phi_sd: VOF-normal orders\n    results.append(get_order(errors_sd['n_C'][0], errors_sd['n_C'][1], 32, 64))\n    results.append(get_order(errors_sd['n_C'][1], errors_sd['n_C'][2], 64, 128))\n    \n    # 3. phi_sd: LS-curvature orders\n    results.append(get_order(errors_sd['k_phi'][0], errors_sd['k_phi'][1], 32, 64))\n    results.append(get_order(errors_sd['k_phi'][1], errors_sd['k_phi'][2], 64, 128))\n\n    # 4. phi_adv: LS-normal orders\n    results.append(get_order(errors_adv['n_phi'][0], errors_adv['n_phi'][1], 32, 64))\n    results.append(get_order(errors_adv['n_phi'][1], errors_adv['n_phi'][2], 64, 128))\n\n    # 5. phi_adv: VOF-normal orders\n    results.append(get_order(errors_adv['n_C'][0], errors_adv['n_C'][1], 32, 64))\n    results.append(get_order(errors_adv['n_C'][1], errors_adv['n_C'][2], 64, 128))\n\n    # 6. phi_adv: LS-curvature orders\n    results.append(get_order(errors_adv['k_phi'][0], errors_adv['k_phi'][1], 32, 64))\n    results.append(get_order(errors_adv['k_phi'][1], errors_adv['k_phi'][2], 64, 128))\n\n    # 7. Bias metrics at N = 128\n    results.append(bias_sd_128)\n    results.append(bias_adv_128)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "自适应网格加密（AMR）是一项强大的技术，能将计算资源高效地集中在流体界面等最需要关注的区域。然而，在粗、细网格之间传递数据时必须格外小心，以分别维护流体体积（VOF）场和水平集（Level-Set）场的独特物理和数值特性。该练习将指导您设计和实现这些关键的数据传输算子，重点是为体积函数$F$构建保持物理守恒性的传输算子，同时为符号距离函数$\\phi$构建保持几何一致性的插值方法，掌握这两种不同但核心的要求是开发稳健CLSVOF-AMR方法的基石。",
            "id": "3305549",
            "problem": "给定一个在方形域 $[0,1]\\times[0,1]$ 上的二维、均匀、以单元为中心的有限体积网格，该网格包含 $N\\times N$ 个宽度为 $h=1/N$ 的单元。定义了两个相指示器：一个水平集函数 $\\phi(\\mathbf{x})$，表示到界面的有符号距离（因此理想情况下满足程函属性 $\\lvert \\nabla \\phi \\rvert = 1$），以及一个体积分数函数 $F(\\mathbf{x})$，表示其中一个相的单元平均指示函数。考虑一个半径为 $R$、中心位于 $(0.5,0.5)$ 的圆形界面，其精确有符号距离场为 $\\phi(x,y) = \\sqrt{(x-0.5)^2 + (y-0.5)^2} - R$。通过一个平滑半厚度 $\\varepsilon  0$ 定义一个正则化的亥维赛德函数 $H_\\varepsilon(\\zeta)$：\n$$\nH_\\varepsilon(\\zeta) = \n\\begin{cases}\n0,  \\zeta \\le -\\varepsilon,\\\\\n\\frac{1}{2} \\left[ 1 + \\frac{\\zeta}{\\varepsilon} + \\frac{1}{\\pi} \\sin\\left( \\frac{\\pi \\zeta}{\\varepsilon} \\right) \\right],  \\lvert \\zeta \\rvert  \\varepsilon,\\\\\n1,  \\zeta \\ge \\varepsilon.\n\\end{cases}\n$$\n设流体是 $\\phi \\le 0$ 的区域。然后将每个单元中心的粗网格体积分数定义为 $F = H_\\varepsilon(-\\phi)$。\n\n将应用自适应网格加密 (AMR)，使得加密在界面附近以及体积分数跳跃陡峭的地方被触发。具体来说，如果索引为 $(i,j)$ 的粗网格单元满足 $\\lvert \\phi_{i,j} \\rvert \\le \\epsilon_\\phi$ 或 $\\lVert \\nabla F \\rVert_{i,j} \\ge \\tau_F$ 中的任意一个条件，则该单元被标记为需要加密。其中 $\\epsilon_\\phi  0$ 和 $\\tau_F  0$ 是阈值，$\\nabla F$ 在粗网格上使用中心有限差分逼近，并在边界处使用适当的单边差分。加密比 $r \\in \\mathbb{N}$ 将一个被标记的粗网格单元细分为 $r\\times r$ 个子细网格单元。\n\n您必须：\n- 设计并实现一个标记准则，该准则当且仅当 $\\lvert \\phi \\rvert \\le \\epsilon_\\phi$ 或 $\\lVert \\nabla F \\rVert \\ge \\tau_F$ 时，标记每个粗网格单元以进行加密。\n- 为 $F$ 指定并实现守恒的限制算子和延拓算子：\n  - 限制算子必须在有限体积意义上是守恒的：粗网格单元的平均值 $F^{c}$ 必须等于其子细网格单元 $F^{f}$ 的面积加权平均值，从而使得总“流体体积” $\\sum F\\,h^2$ 在层级间传递时保持守恒。\n  - 延拓算子必须是守恒且有界的：在每个粗网格单元内使用斜率限制将 $F$ 重构为分段线性函数以保证单调性，计算临时的细网格单元平均值，然后应用一个重分布步骤，该步骤在确保所有子单元中 $0 \\le F \\le 1$ 的同时，强制父单元平均值的精确守恒。\n- 为 $\\phi$ 在延拓到细网格时指定并实现一个一致的插值方法：使用分段线性重构，其梯度由中心差分估计并进行缩放，以使重构的 $\\phi$ 逼近一个有符号距离，即在加密区域内 $\\lvert \\nabla \\phi \\rvert \\approx 1$。将 $\\phi$ 限制回粗网格时使用算术平均。\n\n从以下基本依据出发：\n- 将水平集函数 $\\phi$ 定义为有符号距离意味着在远离扭结点的几乎所有地方都满足程函属性 $\\lvert \\nabla \\phi \\rvert = 1$。\n- 将体积分数 $F$ 定义为指示函数的单元平均意味着在离散化和层级间传递时必须保持有限体积守恒。\n- 斜率限制，例如 minmod 限制器，是一种经过充分测试的机制，用于确保分段线性重构的单调性并防止产生新的极值。\n\n您的程序必须：\n- 对于给定的圆形界面和具有平滑半厚度 $\\varepsilon = \\eta_{\\mathrm{fac}}\\,h$ 的正则化亥维赛德函数 $H_\\varepsilon$ 构建粗网格场 $\\phi$ 和 $F$，其中 $\\eta_{\\mathrm{fac}}$ 是一个给定的无量纲因子。\n- 使用阈值 $\\epsilon_\\phi = \\epsilon_{\\phi,\\mathrm{fac}}\\,h$ 和 $\\tau_F = \\tau_{F,\\mathrm{fac}}/\\varepsilon$ 标记需要加密的粗网格单元，其中 $\\epsilon_{\\phi,\\mathrm{fac}}$ 和 $\\tau_{F,\\mathrm{fac}}$ 是给定的无量纲因子。\n- 对于每个被标记的单元，使用指定的算子将 $F$ 和 $\\phi$ 延拓到一个 $r\\times r$ 的区块上。然后将 $F$ 限制回粗网格，并计算此加密-限制循环前后的总流体体积，以评估守恒性。\n- 通过在每个加密区块上计算细网格上的离散梯度 $\\nabla \\phi$（使用有限差分），并测量在满足 $\\lvert \\phi \\rvert \\le \\kappa$ 的细网格单元上 $\\lvert \\nabla \\phi \\rvert$ 与 $1$ 的最大偏差，来诊断 $\\phi$ 插值的一致性，其中 $\\kappa = 2\\,\\epsilon_\\phi$。\n\n测试套件：\n使用以下三个测试用例，每个用例以元组 $(N, R, \\eta_{\\mathrm{fac}}, \\epsilon_{\\phi,\\mathrm{fac}}, \\tau_{F,\\mathrm{fac}}, r)$ 的形式给出：\n- Case 1: $(32, 0.3, 2.0, 1.0, 0.6, 2)$。\n- Case 2: $(16, 0.25, 1.0, 0.5, 0.8, 2)$。\n- Case 3: $(24, 0.2, 3.0, 0.2, 0.2, 2)$。\n\n对于每个用例，您的程序必须输出三个量：\n- 加密的粗网格单元的整数数量 $n_{\\mathrm{ref}}$。\n- 在所有加密单元上对 $F$ 进行一次守恒的延拓-限制循环后，相对总流体体积误差 $e_V = \\lvert V_{\\mathrm{after}} - V_{\\mathrm{before}} \\rvert / \\max(V_{\\mathrm{before}}, 10^{-16})$。\n- 在所有加密区块内的子细网格单元中，最大细网格程函偏差 $e_\\phi = \\max_{\\lvert \\phi \\rvert \\le \\kappa} \\lvert \\lVert \\nabla \\phi \\rVert - 1 \\rvert$，其中 $\\kappa = 2\\,\\epsilon_\\phi$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。按顺序连接每个测试用例的三个量，得到一个长度为 9 的扁平列表：\n$[n_{\\mathrm{ref},1}, e_{V,1}, e_{\\phi,1}, n_{\\mathrm{ref},2}, e_{V,2}, e_{\\phi,2}, n_{\\mathrm{ref},3}, e_{V,3}, e_{\\phi,3}]$。\n所有三个 $e_V$ 和 $e_\\phi$ 值必须以浮点数形式打印。本问题不涉及物理单位。",
            "solution": "用户提供的问题是计算流体动力学中一个定义明确的练习，具体涉及在耦合水平集/流体体积法 (level-set/volume-of-fluid) 的背景下，为自适应网格加密 (AMR) 实现和验证数据传递算子。该问题具有科学依据、自成体系且算法上明确。我将着手解决。\n\n解决方案需要设计并实现以下算法：\n1.  初始化粗网格上的水平集函数 $\\phi$ 和体积分数函数 $F$。\n2.  根据指定准则标记需要加密的粗网格单元。\n3.  将 $\\phi$ 和 $F$ 从一个粗网格单元延拓到一个细网格单元区块。\n4.  将 $F$ 从一个细网格区块限制回单个粗网格单元值。\n5.  诊断 $F$ 算子的守恒性和 $\\phi$ 算子的一致性。\n\n我将详细说明每个主要组件的实现。\n\n### 1. 网格和场初始化\n计算域为 $[0,1] \\times [0,1]$。使用一个包含 $N \\times N$ 个单元的均匀、以单元为中心的网格。单元宽度为 $h=1/N$。单元中心 $(x_i, y_j)$ 的坐标由以下公式给出：\n$$ x_i = (i + 1/2)h, \\quad y_j = (j + 1/2)h \\quad \\text{for } i,j = 0, \\dots, N-1 $$\n在每个单元中心计算水平集场 $\\phi$，它表示到以 $(0.5, 0.5)$ 为中心、半径为 $R$ 的圆的有符号距离：\n$$ \\phi_{i,j} = \\sqrt{(x_i - 0.5)^2 + (y_j - 0.5)^2} - R $$\n体积分数场 $F$ 由 $\\phi$ 通过给定的正则化亥维赛德函数 $H_\\varepsilon(\\zeta)$ 导出，其平滑半厚度为 $\\varepsilon = \\eta_{\\mathrm{fac}}h$。关系式为 $F = H_\\varepsilon(-\\phi)$：\n$$\nF_{i,j} = H_\\varepsilon(-\\phi_{i,j}) = \n\\begin{cases}\n0,  -\\phi_{i,j} \\le -\\varepsilon,\\\\\n\\frac{1}{2} \\left[ 1 - \\frac{\\phi_{i,j}}{\\varepsilon} - \\frac{1}{\\pi} \\sin\\left( \\frac{\\pi \\phi_{i,j}}{\\varepsilon} \\right) \\right],  \\lvert \\phi_{i,j} \\rvert  \\varepsilon,\\\\\n1,  -\\phi_{i,j} \\ge \\varepsilon.\n\\end{cases}\n$$\n\n### 2. 用于加密的单元标记\n如果索引为 $(i,j)$ 的粗网格单元满足以下两个条件之一，则将其标记为需要加密：\n1.  **界面邻近性**：单元中心靠近界面，$\\lvert \\phi_{i,j} \\rvert \\le \\epsilon_\\phi$，其中阈值为 $\\epsilon_\\phi = \\epsilon_{\\phi,\\mathrm{fac}}h$。\n2.  **陡峭的体积分数**：体积分数梯度较大，$\\lVert \\nabla F \\rVert_{i,j} \\ge \\tau_F$，其中阈值为 $\\tau_F = \\tau_{F,\\mathrm{fac}}/\\varepsilon$。\n\n体积分数的梯度 $\\nabla F = (\\partial_x F, \\partial_y F)$ 使用二阶中心有限差分对内部单元进行逼近，在域边界使用一阶单边差分。范数 $\\lVert \\nabla F \\rVert_{i,j}$ 是标准的欧几里得范数 $\\sqrt{(\\partial_x F)_{i,j}^2 + (\\partial_y F)_{i,j}^2}$。\n\n### 3. 延拓和限制算子\n\n#### 3.1. 体积分数 $F$\n$F$ 的数据传递算子必须是守恒的，以保持总流体体积。\n\n**延拓 (从粗到细)**：\n目标是从单个粗网格单元值 $F^c$ 生成 $r \\times r$ 个细网格单元值 $F^f_k$，以实现守恒性 ($\\sum_k F^f_k = r^2 F^c$) 和有界性 ($0 \\le F^f_k \\le 1$)。这通过带有斜率限制的分段线性重构，后跟一个重分布步骤来完成。\n\n1.  **斜率限制**：对于每个粗网格单元 $(i,j)$，我们计算限制后的斜率 $(\\partial_x F)_{lim}, (\\partial_y F)_{lim}$。我们使用 minmod 限制器，这是保证单调性的标准选择。对于 x 方向：\n    $$ (\\partial_x F)_{lim} = \\text{minmod}\\left( \\frac{F_{i+1,j} - F_{i,j}}{h}, \\frac{F_{i,j} - F_{i-1,j}}{h} \\right) $$\n    其中 $\\text{minmod}(a,b) = \\frac{1}{2}(\\text{sgn}(a)+\\text{sgn}(b))\\min(\\lvert a \\rvert, \\lvert b \\rvert)$。y 方向有类似的表达式。在边界处，斜率设为零。\n\n2.  **重构**：通过在细网格中心 $(\\mathbf{x}^f_k - \\mathbf{x}^c)$ 处评估线性重构来计算临时的细网格单元值 $\\tilde{F}^f_k$：\n    $$ \\tilde{F}^f_k = F^c + (\\nabla F)_{lim} \\cdot (\\mathbf{x}^f_k - \\mathbf{x}^c) $$\n\n3.  **重分布**：调整临时值 $\\tilde{F}^f_k$ 以满足守恒性和边界条件。采用迭代过程：\n    a. 首先，强制守恒：$\\tilde{F}^f_k \\leftarrow \\tilde{F}^f_k + (F^c - \\text{mean}(\\tilde{F}^f))$。\n    b. 迭代修正越界。在每次迭代中，值被裁剪到 $[0,1]$。计算因裁剪导致的总质量变化，并将其均匀地重分布到非饱和单元（即值严格在 $0$ 和 $1$ 之间的单元）中。此过程重复固定次数或直到收敛。这确保最终的细网格单元值 $F^f_k$ 是有界的，同时它们的均值非常接近 $F^c$。\n\n**限制 (从细到粗)**：\n此操作是简单平均，这与有限体积守恒的定义一致：\n$$ F^c = \\frac{1}{r^2} \\sum_{k=1}^{r^2} F^f_k $$\n\n#### 3.2. 水平集 $\\phi$\n$\\phi$ 的算子必须是一致的，旨在保持有符号距离属性 $|\\nabla\\phi|=1$。\n\n**延拓 (从粗到细)**：\n与 $F$ 类似，我们使用分段线性重构。\n1.  **梯度估计**：使用中心差分计算粗网格梯度 $\\nabla \\phi^c$。\n2.  **归一化**：为强制执行程函属性，对梯度进行归一化：$\\mathbf{g} = \\nabla \\phi^c / \\lvert \\nabla \\phi^c \\rvert$。如果 $\\lvert \\nabla \\phi^c \\rvert = 0$，则将 $\\mathbf{g}$ 设为零。\n3.  **重构**：细网格单元值的计算如下：\n    $$ \\phi^f_k = \\phi^c + \\mathbf{g} \\cdot (\\mathbf{x}^f_k - \\mathbf{x}^c) $$\n$\\phi$ 不需要重分布。\n\n**限制 (从细到粗)**：\n如问题所述，这是简单的算术平均：$\\phi^c = \\frac{1}{r^2} \\sum_k \\phi^f_k$。\n\n### 4. 诊断计算\n\n**体积守恒误差 $e_V$**：\n总流体体积为 $V = \\sum_{i,j} F_{i,j} h^2$。我们使用初始粗网格 $F$ 计算体积 $V_{\\mathrm{before}}$。然后，创建一个新网格 $F_{\\mathrm{after}}$，其中每个被标记单元的值被替换为一次延拓-限制循环的结果：$F_{\\mathrm{after}, i,j} = \\text{restrict}(\\text{prolongate}(F_{i,j}))$。从这个新网格计算体积 $V_{\\mathrm{after}}$。相对误差为：\n$$ e_V = \\frac{\\lvert V_{\\mathrm{after}} - V_{\\mathrm{before}} \\rvert}{\\max(V_{\\mathrm{before}}, 10^{-16})} $$\n由于守恒算子的精心实现，该误差预期接近机器精度。\n\n**程函偏差 $e_\\phi$**：\n对于从被标记单元生成的每个细网格区块，我们使用细网格上的中心差分计算延拓场的梯度 $\\nabla \\phi^f$。然后，我们在所有靠近界面（$\\lvert \\phi^f_k \\rvert \\le \\kappa = 2\\epsilon_\\phi$）的细网格单元中，找出其梯度大小与 $1$ 的最大偏差：\n$$ e_\\phi = \\max_{\\text{all fine patches}} \\left( \\max_{k \\text{ s.t. } \\lvert\\phi^f_k\\rvert \\le \\kappa} \\lvert \\lvert \\nabla \\phi^f_k \\rvert - 1 \\rvert \\right) $$\n\n这些步骤构成了解决问题并为每个测试用例生成所需输出的完整计划。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n\n    def H_eps(zeta, eps):\n        \"\"\"Regularized Heaviside function.\"\"\"\n        val = np.zeros_like(zeta, dtype=float)\n        # To avoid division by zero if eps is zero, though problem constraints prevent this.\n        if eps == 0:\n            val[zeta > 0] = 1.0\n            return val\n            \n        mask_mid = np.abs(zeta)  eps\n        zeta_mid = zeta[mask_mid]\n        val[mask_mid] = 0.5 * (1.0 + zeta_mid / eps + (1.0 / np.pi) * np.sin(np.pi * zeta_mid / eps))\n        val[zeta >= eps] = 1.0\n        return val\n\n    def minmod(a, b):\n        \"\"\"Minmod limiter function.\"\"\"\n        return 0.5 * (np.sign(a) + np.sign(b)) * np.minimum(np.abs(a), np.abs(b))\n\n    def compute_limited_slopes(F, h):\n        \"\"\"Computes minmod-limited slopes for a 2D field F.\"\"\"\n        # X-direction slopes\n        dF_fwd_x = (np.roll(F, -1, axis=1) - F) / h\n        dF_bwd_x = (F - np.roll(F, 1, axis=1)) / h\n        sx = minmod(dF_fwd_x, dF_bwd_x)\n        sx[:, 0] = 0.0\n        sx[:, -1] = 0.0\n\n        # Y-direction slopes\n        dF_fwd_y = (np.roll(F, -1, axis=0) - F) / h\n        dF_bwd_y = (F - np.roll(F, 1, axis=0)) / h\n        sy = minmod(dF_fwd_y, dF_bwd_y)\n        sy[0, :] = 0.0\n        sy[-1, :] = 0.0\n        \n        return sx, sy\n\n    def prolongate_F(F_c, sx, sy, h, r):\n        \"\"\"Prolongates F to a fine patch with conservation and bounds.\"\"\"\n        h_f = h / r\n        rel_coords_1d = np.linspace(-(h - h_f) / 2.0, (h - h_f) / 2.0, r)\n        rel_x, rel_y = np.meshgrid(rel_coords_1d, rel_coords_1d)\n        \n        F_prov = F_c + sx * rel_x + sy * rel_y\n        \n        F_f = F_prov\n        # Enforce conservation initially\n        F_f += F_c - np.mean(F_f)\n        \n        for _ in range(20): # Iterative redistribution\n            if np.all((F_f >= 0)  (F_f = 1)):\n                break\n            \n            F_clipped = np.clip(F_f, 0, 1)\n            error_sum = F_c * (r**2) - np.sum(F_clipped)\n            \n            receivers_mask = (F_clipped > 1e-12)  (F_clipped  1 - 1e-12)\n            num_receivers = np.sum(receivers_mask)\n\n            if num_receivers == 0:\n                F_f = F_clipped\n                break\n            \n            delta = error_sum / num_receivers\n            F_f = F_clipped\n            F_f[receivers_mask] += delta\n        \n        # Final clip to strictly enforce bounds after iterations\n        return np.clip(F_f, 0, 1)\n\n\n    def prolongate_phi(phi_c, gx, gy, h, r):\n        \"\"\"Prolongates phi with normalized gradients.\"\"\"\n        h_f = h / r\n        norm = np.sqrt(gx**2 + gy**2)\n        if norm > 1e-15:\n            gx_norm, gy_norm = gx / norm, gy / norm\n        else:\n            gx_norm, gy_norm = 0.0, 0.0\n            \n        rel_coords_1d = np.linspace(-(h - h_f) / 2.0, (h - h_f) / 2.0, r)\n        rel_x, rel_y = np.meshgrid(rel_coords_1d, rel_coords_1d)\n\n        return phi_c + gx_norm * rel_x + gy_norm * rel_y\n\n    test_cases = [\n        (32, 0.3, 2.0, 1.0, 0.6, 2),\n        (16, 0.25, 1.0, 0.5, 0.8, 2),\n        (24, 0.2, 3.0, 0.2, 0.2, 2)\n    ]\n\n    results = []\n    for case in test_cases:\n        N, R, eta_fac, eps_phi_fac, tau_F_fac, r = case\n\n        # 1. Setup coarse grid and fields\n        h = 1.0 / N\n        eps = eta_fac * h\n        grid_coords = np.linspace(h / 2.0, 1.0 - h / 2.0, N)\n        xx, yy = np.meshgrid(grid_coords, grid_coords)\n        \n        phi_coarse = np.sqrt((xx - 0.5)**2 + (yy - 0.5)**2) - R\n        F_coarse = H_eps(-phi_coarse, eps)\n        \n        # 2. Tag cells for refinement\n        eps_phi = eps_phi_fac * h\n        tau_F = tau_F_fac / eps if eps > 0 else float('inf')\n        \n        grad_F_y, grad_F_x = np.gradient(F_coarse, h)\n        grad_F_norm = np.sqrt(grad_F_x**2 + grad_F_y**2)\n        \n        tags = (np.abs(phi_coarse) = eps_phi) | (grad_F_norm >= tau_F)\n        n_ref = np.sum(tags)\n        \n        # 3. Prepare for prolongation/restriction cycle\n        V_before = np.sum(F_coarse) * h**2\n        F_after = F_coarse.copy()\n        all_eikonal_errors = []\n        \n        # Pre-compute gradients for all cells\n        sx_F, sy_F = compute_limited_slopes(F_coarse, h)\n        grad_phi_y, grad_phi_x = np.gradient(phi_coarse, h)\n        \n        tagged_indices = np.argwhere(tags)\n        for i, j in tagged_indices:\n            # 4. Prolongation-Restriction for F\n            F_cell = F_coarse[i, j]\n            sx, sy = sx_F[i, j], sy_F[i, j]\n            F_fine_patch = prolongate_F(F_cell, sx, sy, h, r)\n            \n            # Conservative restriction is simple averaging\n            F_restricted = np.mean(F_fine_patch)\n            F_after[i, j] = F_restricted\n\n            # 5. Prolongation and Diagnosis for phi\n            phi_cell = phi_coarse[i, j]\n            gx, gy = grad_phi_x[i, j], grad_phi_y[i, j]\n            phi_fine_patch = prolongate_phi(phi_cell, gx, gy, h, r)\n\n            h_fine = h / r\n            grad_phi_fine_y, grad_phi_fine_x = np.gradient(phi_fine_patch, h_fine)\n            grad_norm_fine = np.sqrt(grad_phi_fine_x**2 + grad_phi_fine_y**2)\n            \n            kappa = 2.0 * eps_phi\n            mask = np.abs(phi_fine_patch) = kappa\n            if np.any(mask):\n                errors = np.abs(grad_norm_fine[mask] - 1.0)\n                all_eikonal_errors.append(np.max(errors))\n\n        # 6. Finalize diagnostics\n        V_after = np.sum(F_after) * h**2\n        e_V = np.abs(V_after - V_before) / max(V_before, 1e-16)\n\n        if not all_eikonal_errors:\n            e_phi = 0.0\n        else:\n            e_phi = np.max(all_eikonal_errors)\n\n        results.extend([n_ref, e_V, e_phi])\n    \n    # Format and print the final flat list of results\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "水平集场和VOF场是同一界面的两种不同表示，但在数值求解过程中，累积的误差可能导致它们之间出现不一致。本节的最后一个练习将从代码实现转向更深层次的理论分析，探索如何从数学上强制实现两者的一致性。在此，我们将一致性问题构建为一个最小化问题，通过定义一个惩罚$\\phi$场隐含体积与$F$场真实体积之间差异的泛函，并利用变分法推导其Gâteaux导数。这一过程不仅能加深您对两个场耦合本质的理解，也为设计那些能够主动耦合与校正两个场的高级算法提供了坚实的理论基础。",
            "id": "3305591",
            "problem": "考虑一个在笛卡尔网格上离散化的不可压缩两相流，该网格将计算域划分为一组不重叠的控制体积 $\\{\\Omega_{i}\\}_{i=1}^{N}$，其度量为 $\\Delta V_{i} = \\int_{\\Omega_{i}} 1 \\, \\mathrm{d}\\mathbf{x}$。令 $\\phi(\\mathbf{x})$ 表示一个二阶连续可微的水平集函数，其零等值面 $\\{\\mathbf{x} \\,:\\, \\phi(\\mathbf{x}) = 0\\}$ 代表物质界面。令 $F_{i} \\in [0,1]$ 表示单元 $\\Omega_{i}$ 中的流体体积 (VOF) 分数，定义为某一相所占据的体积与 $\\Delta V_{i}$ 的比值。分段线性界面计算 (PLIC) 方法在每个部分填充的单元 $\\Omega_{i}$ 中重构一个平面界面，其单位法向量为 $\\mathbf{m}_{i}$，平面常数为 $\\alpha_{i}$，选择这些参数使得在 $\\Omega_{i}$ 内该平面一侧的体积与 $F_{i}\\Delta V_{i}$ 相匹配。\n\n为了将水平集和 VOF 描述联系起来，定义 Heaviside 函数的一个光滑近似 $H_{\\varepsilon}(s)$，它由一个小的正则化参数 $\\varepsilon  0$ 参数化，使得 $H_{\\varepsilon}(s)$ 连续可微，并且当 $\\varepsilon \\to 0$ 时，$H_{\\varepsilon}(s)$ 逐点收敛于 $H(s)$，其中 $H$ 是不连续的 Heaviside 函数。那么，在 $\\Omega_{i}$ 中，由水平集隐含的所选相的体积为\n$$\nV_{i}^{\\mathrm{LS}}(\\phi) \\;=\\; \\int_{\\Omega_{i}} H_{\\varepsilon}\\!\\big(-\\phi(\\mathbf{x})\\big)\\,\\mathrm{d}\\mathbf{x}.\n$$\n假设在 $\\Omega_{i}$ 中构造的 PLIC 平面满足\n$$\nV_{i}^{\\mathrm{PLIC}} \\;=\\; F_{i}\\,\\Delta V_{i}.\n$$\n\n你被要求建立一个约束来强制 $\\phi$ 和 $F$ 的一致性。该约束通过最小化一个不匹配泛函来实现，该泛函惩罚每个单元中水平集隐含体积 $V_{i}^{\\mathrm{LS}}(\\phi)$ 与 PLIC 平面体积 $V_{i}^{\\mathrm{PLIC}}$ 之间的差异。具体来说，考虑加权最小二乘不匹配泛函\n$$\nJ(\\phi) \\;=\\; \\sum_{i=1}^{N} w_{i}\\,\\Big(V_{i}^{\\mathrm{LS}}(\\phi) - F_{i}\\,\\Delta V_{i}\\Big)^{2},\n$$\n其中 $w_{i}  0$ 是给定的权重。使用基于 $V_{i}^{\\mathrm{LS}}(\\phi)$ 定义的第一性原理和标准变分法，推导出 Gâteaux 导数 $\\delta J/\\delta \\phi(\\mathbf{x})$ 的闭合解析形式。\n\n你的最终答案必须是 $\\delta J/\\delta \\phi(\\mathbf{x})$ 的单一闭合解析表达式。不需要进行数值计算，也不需要进行四舍五入。每个数学符号都必须用 LaTeX 书写。清楚地说明你引入的任何指示函数，并确保所有量在定义域上都是良定义的。",
            "solution": "问题要求计算泛函 $J(\\phi)$ 关于水平集函数 $\\phi(\\mathbf{x})$ 的 Gâteaux 导数。泛函 $J(\\phi)$ 由下式给出\n$$\nJ(\\phi) \\;=\\; \\sum_{i=1}^{N} w_{i}\\,\\Big(V_{i}^{\\mathrm{LS}}(\\phi) - F_{i}\\,\\Delta V_{i}\\Big)^{2},\n$$\n其中水平集隐含体积 $V_{i}^{\\mathrm{LS}}(\\phi)$ 定义为\n$$\nV_{i}^{\\mathrm{LS}}(\\phi) \\;=\\; \\int_{\\Omega_{i}} H_{\\varepsilon}\\big(-\\phi(\\mathbf{x})\\big)\\,\\mathrm{d}\\mathbf{x}.\n$$\nGâteaux 导数，记作 $\\frac{\\delta J}{\\delta \\phi}$，是通过其对一个任意的、足够光滑的测试函数 $\\psi(\\mathbf{x})$ 的作用来定义的。$J$ 在 $\\phi$ 处沿 $\\psi$ 方向的方向导数由下式给出\n$$\n\\langle \\frac{\\delta J}{\\delta \\phi}, \\psi \\rangle = \\lim_{\\tau \\to 0} \\frac{J(\\phi + \\tau\\psi) - J(\\phi)}{\\tau} = \\frac{d}{d\\tau} J(\\phi + \\tau\\psi) \\bigg|_{\\tau=0}.\n$$\n该方向导数可以通过在整个计算域 $\\Omega = \\bigcup_{i=1}^{N} \\Omega_{i}$ 上的内积与 Gâteaux 导数联系起来：\n$$\n\\frac{d}{d\\tau} J(\\phi + \\tau\\psi) \\bigg|_{\\tau=0} = \\int_{\\Omega} \\frac{\\delta J}{\\delta \\phi}(\\mathbf{x}) \\psi(\\mathbf{x}) \\, \\mathrm{d}\\mathbf{x}.\n$$\n我们的目标是找到 $\\frac{\\delta J}{\\delta \\phi}(\\mathbf{x})$ 的表达式。\n\n首先，我们计算 $J(\\phi + \\tau\\psi)$ 关于参数 $\\tau$ 的导数。根据链式法则，我们有\n$$\n\\frac{d}{d\\tau} J(\\phi + \\tau\\psi) = \\sum_{i=1}^{N} \\frac{d}{d\\tau} \\left[ w_{i}\\,\\Big(V_{i}^{\\mathrm{LS}}(\\phi + \\tau\\psi) - F_{i}\\,\\Delta V_{i}\\Big)^{2} \\right].\n$$\n再次对平方项应用链式法则，得到\n$$\n\\frac{d}{d\\tau} J(\\phi + \\tau\\psi) = \\sum_{i=1}^{N} 2 w_{i}\\,\\Big(V_{i}^{\\mathrm{LS}}(\\phi + \\tau\\psi) - F_{i}\\,\\Delta V_{i}\\Big) \\frac{d}{d\\tau}V_{i}^{\\mathrm{LS}}(\\phi + \\tau\\psi).\n$$\n接下来，我们必须计算水平集体积泛函 $V_{i}^{\\mathrm{LS}}(\\phi + \\tau\\psi)$ 关于 $\\tau$ 的导数：\n$$\nV_{i}^{\\mathrm{LS}}(\\phi + \\tau\\psi) = \\int_{\\Omega_{i}} H_{\\varepsilon}\\big(-(\\phi(\\mathbf{x}) + \\tau\\psi(\\mathbf{x}))\\big)\\,\\mathrm{d}\\mathbf{x}.\n$$\n由于问题中说明 $H_{\\varepsilon}(s)$ 是连续可微的，我们可以在积分号下求导（莱布尼茨积分法则）。令 $H'_{\\varepsilon}(s) = \\frac{d}{ds}H_{\\varepsilon}(s)$ 表示 $H_{\\varepsilon}(s)$ 关于其自变量 $s$ 的导数。对被积函数应用链式法则，得到\n$$\n\\frac{d}{d\\tau} H_{\\varepsilon}\\big(-\\phi(\\mathbf{x}) - \\tau\\psi(\\mathbf{x})\\big) = H'_{\\varepsilon}\\big(-\\phi(\\mathbf{x}) - \\tau\\psi(\\mathbf{x})\\big) \\cdot \\frac{\\partial}{\\partial \\tau}\\big(-\\phi(\\mathbf{x}) - \\tau\\psi(\\mathbf{x})\\big) = -\\psi(\\mathbf{x}) H'_{\\varepsilon}\\big(-\\phi(\\mathbf{x}) - \\tau\\psi(\\mathbf{x})\\big).\n$$\n将此代入 $V_{i}^{\\mathrm{LS}}$ 的导数积分中：\n$$\n\\frac{d}{d\\tau}V_{i}^{\\mathrm{LS}}(\\phi + \\tau\\psi) = \\int_{\\Omega_{i}} -\\psi(\\mathbf{x}) H'_{\\varepsilon}\\big(-\\phi(\\mathbf{x}) - \\tau\\psi(\\mathbf{x})\\big) \\,\\mathrm{d}\\mathbf{x}.\n$$\n现在，我们在 $\\tau = 0$ 处计算所有导数的值：\n$$\n\\frac{d}{d\\tau} J(\\phi + \\tau\\psi) \\bigg|_{\\tau=0} = \\sum_{i=1}^{N} 2 w_{i}\\,\\Big(V_{i}^{\\mathrm{LS}}(\\phi) - F_{i}\\,\\Delta V_{i}\\Big) \\left( \\int_{\\Omega_{i}} -\\psi(\\mathbf{x}) H'_{\\varepsilon}\\big(-\\phi(\\mathbf{x})\\big) \\,\\mathrm{d}\\mathbf{x} \\right).\n$$\n我们可以将常数因子移到积分内部：\n$$\n\\frac{d}{d\\tau} J(\\phi + \\tau\\psi) \\bigg|_{\\tau=0} = \\sum_{i=1}^{N} \\int_{\\Omega_{i}} \\left[ -2 w_{i}\\,\\Big(V_{i}^{\\mathrm{LS}}(\\phi) - F_{i}\\,\\Delta V_{i}\\Big) H'_{\\varepsilon}\\big(-\\phi(\\mathbf{x})\\big) \\right] \\psi(\\mathbf{x}) \\,\\mathrm{d}\\mathbf{x}.\n$$\n为了将其表示为在整个域 $\\Omega$ 上的单个积分，我们为每个单元 $\\Omega_{i}$ 引入指示函数 $\\chi_{\\Omega_{i}}(\\mathbf{x})$，定义为\n$$\n\\chi_{\\Omega_{i}}(\\mathbf{x}) =\n\\begin{cases}\n1  \\text{if } \\mathbf{x} \\in \\Omega_{i} \\\\\n0  \\text{if } \\mathbf{x} \\notin \\Omega_{i}\n\\end{cases}\n$$\n使用这个函数，我们可以将积分之和写成和的积分：\n$$\n\\frac{d}{d\\tau} J(\\phi + \\tau\\psi) \\bigg|_{\\tau=0} = \\int_{\\Omega} \\left( \\sum_{i=1}^{N} \\chi_{\\Omega_{i}}(\\mathbf{x}) \\left[ -2 w_{i}\\,\\Big(V_{i}^{\\mathrm{LS}}(\\phi) - F_{i}\\,\\Delta V_{i}\\Big) H'_{\\varepsilon}\\big(-\\phi(\\mathbf{x})\\big) \\right] \\right) \\psi(\\mathbf{x}) \\,\\mathrm{d}\\mathbf{x}.\n$$\n通过将其与定义 $\\int_{\\Omega} \\frac{\\delta J}{\\delta \\phi}(\\mathbf{x}) \\psi(\\mathbf{x}) \\, \\mathrm{d}\\mathbf{x}$ 进行比较，我们可以将 Gâteaux 导数 $\\frac{\\delta J}{\\delta \\phi}(\\mathbf{x})$ 确定为积分内乘以 $\\psi(\\mathbf{x})$ 的项：\n$$\n\\frac{\\delta J}{\\delta \\phi}(\\mathbf{x}) = \\sum_{i=1}^{N} \\chi_{\\Omega_{i}}(\\mathbf{x}) \\left[ -2 w_{i}\\,\\Big(V_{i}^{\\mathrm{LS}}(\\phi) - F_{i}\\,\\Delta V_{i}\\Big) H'_{\\varepsilon}\\big(-\\phi(\\mathbf{x})\\big) \\right].\n$$\n最后，我们将 $V_{i}^{\\mathrm{LS}}(\\phi)$ 的定义代回此表达式，使其完全用 $\\phi$ 显式表示。为了避免计算导数的点 $\\mathbf{x}$ 与 $V_{i}^{\\mathrm{LS}}$ 定义中的积分变量之间的混淆，我们使用 $\\mathbf{y}$ 作为积分哑元：\n$$\nV_{i}^{\\mathrm{LS}}(\\phi) = \\int_{\\Omega_{i}} H_{\\varepsilon}\\big(-\\phi(\\mathbf{y})\\big)\\,\\mathrm{d}\\mathbf{y}.\n$$\n因此，Gâteaux 导数可以写为\n$$\n\\frac{\\delta J}{\\delta \\phi}(\\mathbf{x}) = -2 H'_{\\varepsilon}\\big(-\\phi(\\mathbf{x})\\big) \\sum_{i=1}^{N} w_{i} \\left( \\int_{\\Omega_{i}} H_{\\varepsilon}\\big(-\\phi(\\mathbf{y})\\big)\\,\\mathrm{d}\\mathbf{y} - F_{i}\\,\\Delta V_{i} \\right) \\chi_{\\Omega_{i}}(\\mathbf{x}).\n$$\n这就是 Gâteaux 导数的闭合解析表达式。求和项是一个分段常数函数；对于任何给定的点 $\\mathbf{x}$，它必须属于单个单元 $\\Omega_k$，该求和式将简化为对应于 $i=k$ 的单个项。该导数在域 $\\Omega$ 上是良定义的。",
            "answer": "$$\n\\boxed{-2 H'_{\\varepsilon}\\big(-\\phi(\\mathbf{x})\\big) \\sum_{i=1}^{N} w_{i} \\left( \\int_{\\Omega_{i}} H_{\\varepsilon}\\big(-\\phi(\\mathbf{y})\\big)\\,\\mathrm{d}\\mathbf{y} - F_{i}\\,\\Delta V_{i} \\right) \\chi_{\\Omega_{i}}(\\mathbf{x})}\n$$"
        }
    ]
}