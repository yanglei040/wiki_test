{
    "hands_on_practices": [
        {
            "introduction": "Reinitialization is crucial for maintaining the signed-distance property of the level-set function, $|\\nabla \\phi| = 1$, which is essential for accuracy. This process involves solving a Hamilton-Jacobi type equation, and its numerical stability hinges on using an appropriate upwind scheme. This exercise provides a focused, hands-on calculation of the Godunov-type discretization, a cornerstone for such problems, allowing you to see firsthand how the local state of the $\\phi$ field dictates the correct upwinding direction for the pseudo-time update .",
            "id": "3339817",
            "problem": "Consider a one-dimensional uniform grid with spacing $\\Delta x = 0.2$, nodal locations $x_{i-1}$, $x_i$, and $x_{i+1}$, and a level-set function $\\phi$ that is intended to represent a signed-distance function. The reinitialization step is modeled by the Hamilton–Jacobi type partial differential equation (PDE)\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S(\\phi_0)\\left(|\\partial_x \\phi| - 1\\right) = 0,\n$$\nwhere $S(\\phi_0)$ is the smoothed sign of the initial level-set $\\phi_0$, and $\\tau$ is the pseudo-time variable used only for reinitialization. The one-sided finite differences at node $x_i$ are\n$$\nD_x^- \\phi_i = \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}, \\qquad D_x^+ \\phi_i = \\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}.\n$$\nStarting from the monotonicity requirement for numerical Hamiltonians in Hamilton–Jacobi equations and the upwind principle derived from characteristic speeds, derive a Godunov-type consistent discretization of $|\\partial_x \\phi|$ at $x_i$ that uses the one-sided differences $D_x^- \\phi_i$ and $D_x^+ \\phi_i$ and depends on the sign of $S(\\phi_0)$ at $x_i$. Then, for the specific data\n$$\n\\phi_{i-1} = 0.3, \\qquad \\phi_i = -0.1, \\qquad \\phi_{i+1} = -0.6, \\qquad \\Delta x = 0.2, \\qquad \\phi_{0,i} = 0.15,\n$$\ncompute the Godunov discretization of $|\\partial_x \\phi|$ at $x_i$ and determine the direction of the pseudo-time update at $x_i$ implied by the reinitialization PDE. In the direction indicator, use $+1$ for an increase in $\\phi_i$ with respect to $\\tau$, $-1$ for a decrease, and $0$ for a stationary update.\n\nProvide your final answer as a single row matrix whose first entry is the computed Godunov value for $|\\partial_x \\phi|$ at $x_i$ and whose second entry is the update direction indicator. No rounding is required.",
            "solution": "The reinitialization PDE\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S(\\phi_0)\\left(|\\partial_x \\phi| - 1\\right) = 0\n$$\nis a Hamilton–Jacobi type equation with Hamiltonian\n$$\nH(p) = S(\\phi_0)\\left(|p| - 1\\right), \\qquad p = \\partial_x \\phi.\n$$\nFor viscosity solutions, a consistent and monotone numerical Hamiltonian must respect the upwind direction determined by the characteristic speed. The characteristic speed is given by the derivative of the Hamiltonian with respect to $p$:\n$$\na(p) = \\frac{\\partial H}{\\partial p} = S(\\phi_0)\\frac{\\partial}{\\partial p}|p| = S(\\phi_0)\\,\\operatorname{sign}(p), \\quad \\text{for } p \\neq 0,\n$$\nwhere $\\operatorname{sign}(p)$ denotes the sign function. Because $a(p)$ depends on the (unknown) local gradient $p$, the Godunov numerical Hamiltonian selects among admissible one-sided approximations $D_x^- \\phi_i$ and $D_x^+ \\phi_i$ according to the monotonicity principle: the discretization must be non-decreasing in each of its arguments when $H$ is non-decreasing in $|p|$ and must choose upwind differences based on the direction of characteristics.\n\nIn one dimension, the Godunov choice for $|\\partial_x \\phi|$ can be derived by considering the admissible interval for $p$ spanned by the one-sided slopes. The numerical Hamiltonian seeks the extremal value of $|p|$ within this interval consistent with monotonicity and upwinding. The resulting Godunov discretization for the magnitude $|\\partial_x \\phi|$ at $x_i$ is\n$$\n|\\partial_x \\phi|_{\\text{G}} =\n\\begin{cases}\n\\sqrt{\\max\\!\\left(\\bigl(\\max(D_x^- \\phi_i,0)\\bigr)^2, \\bigl(\\min(D_x^+ \\phi_i,0)\\bigr)^2\\right)},  \\text{if } S(\\phi_{0,i}) > 0, \\\\[1ex]\n\\sqrt{\\max\\!\\left(\\bigl(\\max(D_x^+ \\phi_i,0)\\bigr)^2, \\bigl(\\min(D_x^- \\phi_i,0)\\bigr)^2\\right)},  \\text{if } S(\\phi_{0,i})  0, \\\\[1ex]\n0,  \\text{if } S(\\phi_{0,i}) = 0,\n\\end{cases}\n$$\nwhich, in one dimension, reduces to selecting the upwind one-sided magnitude according to the signs of $D_x^- \\phi_i$ and $D_x^+ \\phi_i$. Specifically, for $S(\\phi_{0,i})>0$,\n- if $D_x^- \\phi_i \\ge 0$ and $D_x^+ \\phi_i \\le 0$, then $|\\partial_x \\phi|_{\\text{G}} = \\max\\!\\left(|D_x^- \\phi_i|, |D_x^+ \\phi_i|\\right)$,\n- if $D_x^- \\phi_i \\ge 0$ and $D_x^+ \\phi_i \\ge 0$, then $|\\partial_x \\phi|_{\\text{G}} = |D_x^- \\phi_i|$,\n- if $D_x^- \\phi_i \\le 0$ and $D_x^+ \\phi_i \\le 0$, then $|\\partial_x \\phi|_{\\text{G}} = |D_x^+ \\phi_i|$,\nand for $S(\\phi_{0,i})0$ the roles of $D_x^- \\phi_i$ and $D_x^+ \\phi_i$ are reversed.\n\nNow compute the one-sided differences for the given data:\n$$\nD_x^- \\phi_i = \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x} = \\frac{-0.1 - 0.3}{0.2} = \\frac{-0.4}{0.2} = -2.0,\n$$\n$$\nD_x^+ \\phi_i = \\frac{\\phi_{i+1} - \\phi_i}{\\Delta x} = \\frac{-0.6 - (-0.1)}{0.2} = \\frac{-0.5}{0.2} = -2.5.\n$$\nThe smoothed sign $S(\\phi_{0,i})$ is positive because $\\phi_{0,i} = 0.15 > 0$; any standard smooth sign approximation (for example, $S(\\phi_{0,i}) = \\phi_{0,i}/\\sqrt{\\phi_{0,i}^2 + \\varepsilon^2}$ with small $\\varepsilon>0$) yields $S(\\phi_{0,i}) > 0$.\n\nWith $S(\\phi_{0,i}) > 0$ and both one-sided differences negative, the Godunov selection reduces to\n$$\n|\\partial_x \\phi|_{\\text{G}} = |D_x^+ \\phi_i| = 2.5.\n$$\nNext, determine the pseudo-time update direction from the PDE:\n$$\n\\frac{\\partial \\phi_i}{\\partial \\tau} = -\\,S(\\phi_{0,i})\\left(|\\partial_x \\phi|_{\\text{G}} - 1\\right).\n$$\nSubstituting $S(\\phi_{0,i})>0$ and $|\\partial_x \\phi|_{\\text{G}} = 2.5$ gives\n$$\n\\frac{\\partial \\phi_i}{\\partial \\tau} = -\\,S(\\phi_{0,i})(2.5 - 1),\n$$\nwhich is negative. Hence the update direction indicator is $-1$ (decrease).\n\nTherefore, the required outputs are the Godunov magnitude $2.5$ and the direction indicator $-1$.",
            "answer": "$$\\boxed{\\begin{pmatrix} 2.5  -1 \\end{pmatrix}}$$"
        },
        {
            "introduction": "While reinitialization preserves the quality of the level-set field, the advection step, governed by $\\partial_t \\phi + \\mathbf{u} \\cdot \\nabla \\phi = 0$, determines its motion. To accurately capture the interface's evolution without numerical smearing or oscillations, high-order schemes are indispensable. This practice delves into the inner workings of the celebrated fifth-order Weighted Essentially Non-Oscillatory (WENO5) scheme, guiding you through the computation of its key components to understand how it achieves high fidelity .",
            "id": "3339785",
            "problem": "Consider one-dimensional advection of a Level-Set signed-distance function $\\phi(x,t)$ governed by the linear Hamilton–Jacobi equation $\\phi_{t} + u\\,\\phi_{x} = 0$ on a uniform grid with spacing $\\Delta x$, where $u>0$ is a constant advection velocity. In the finite-difference Weighted Essentially Non-Oscillatory (WENO) of fifth order (WENO5), one reconstructs one-sided spatial derivatives at cell faces using three quadratic candidate polynomials defined on three-point substencils and combines them via nonlinear weights determined by smoothness indicators. These reconstructions are used in both signed-distance advection and signed-distance reinitialization computations to maintain non-oscillatory, high-order approximations near interfaces.\n\nYou are given a local stencil of cell-centered values of $\\phi$ near a face $x_{i+1/2}$:\n$$\n\\phi_{i-2} = -\\frac{22}{10},\\quad \\phi_{i-1} = -\\frac{12}{10},\\quad \\phi_{i} = -\\frac{2}{10},\\quad \\phi_{i+1} = \\frac{8}{10},\\quad \\phi_{i+2} = \\frac{17}{10},\n$$\nand a uniform grid spacing $\\Delta x = 1$. Assume positive velocity $u>0$ so that a left-biased reconstruction of $\\partial_x \\phi$ at $x_{i+1/2}$ is required. Use the Jiang–Shu WENO5 finite-difference formulation with the standard three-point substencils $S_0=\\{i-2,i-1,i\\}$, $S_1=\\{i-1,i,i+1\\}$, and $S_2=\\{i,i+1,i+2\\}$; use the classical linear weights $d_0$, $d_1$, $d_2$ associated with the left-biased reconstruction at $x_{i+1/2}$, and the standard smoothness indicators $\\beta_0$, $\\beta_1$, $\\beta_2$ for WENO5. Take the nonlinear weight regularization to be $\\epsilon = 10^{-6}$ and the power parameter to be $p=2$ in the weight definition.\n\nStarting from the governing equation and the finite-difference reconstruction principles, derive the three quadratic candidate polynomials on each substencil, differentiate them to obtain the three candidate one-sided approximations to $\\partial_x \\phi$ at $x_{i+1/2}$, derive the Jiang–Shu smoothness indicators on each substencil, and state the classical linear weights for this left-biased face. Then compute:\n1. The WENO5 left-biased reconstruction of $\\partial_x \\phi$ at $x_{i+1/2}$.\n2. The numerical values of the linear weights $d_0$, $d_1$, $d_2$ used.\n3. The numerical values of the smoothness indicators $\\beta_0$, $\\beta_1$, $\\beta_2$.\n\nProvide the final answer as a single row vector containing, in order, the reconstructed derivative $\\partial_x \\phi|_{x_{i+1/2}}$, the three linear weights $d_0$, $d_1$, $d_2$, and the three smoothness indicators $\\beta_0$, $\\beta_1$, $\\beta_2$. No units are required. No rounding is required; express any rational quantities in exact form if convenient.",
            "solution": "The solution requires computing the fifth-order WENO reconstruction of the spatial derivative $\\phi_x$ at the cell face $x_{i+1/2}$. This involves several steps.\n\n**1. Candidate Derivative Approximations**\nFor a left-biased reconstruction at face $x_{i+1/2}$ on a uniform grid with spacing $\\Delta x$, the three third-order accurate candidate derivative approximations $(\\hat{\\phi}'_k)$ are obtained from the three substencils $S_0=\\{i-2,i-1,i\\}$, $S_1=\\{i-1,i,i+1\\}$, and $S_2=\\{i,i+1,i+2\\}$.\nThe formulas are:\n$$ \\hat{\\phi}'_0 = \\frac{1}{\\Delta x}\\left(\\frac{1}{3}\\phi_{i-2} - \\frac{7}{6}\\phi_{i-1} + \\frac{11}{6}\\phi_i\\right) $$\n$$ \\hat{\\phi}'_1 = \\frac{1}{\\Delta x}\\left(-\\frac{1}{6}\\phi_{i-1} + \\frac{5}{6}\\phi_i + \\frac{1}{3}\\phi_{i+1}\\right) $$\n$$ \\hat{\\phi}'_2 = \\frac{1}{\\Delta x}\\left(\\frac{1}{3}\\phi_i + \\frac{5}{6}\\phi_{i+1} - \\frac{1}{6}\\phi_{i+2}\\right) $$\nGiven data: $\\phi_{i-2}=-2.2$, $\\phi_{i-1}=-1.2$, $\\phi_i=-0.2$, $\\phi_{i+1}=0.8$, $\\phi_{i+2}=1.7$, and $\\Delta x=1$.\n$$ \\hat{\\phi}'_0 = \\frac{1}{3}(-2.2) - \\frac{7}{6}(-1.2) + \\frac{11}{6}(-0.2) = \\frac{-4.4 + 8.4 - 2.2}{6} = \\frac{1.8}{6} = \\frac{3}{10} $$\n$$ \\hat{\\phi}'_1 = -\\frac{1}{6}(-1.2) + \\frac{5}{6}(-0.2) + \\frac{1}{3}(0.8) = \\frac{1.2 - 1.0 + 1.6}{6} = \\frac{1.8}{6} = \\frac{3}{10} $$\nThis is an error in calculation. Correcting: $-\\frac{1}{6}(-1.2) + \\frac{5}{6}(-0.2) + \\frac{1}{3}(0.8) = \\frac{1.2}{6} - \\frac{1.0}{6} + \\frac{1.6}{3} = \\frac{0.2}{6} + \\frac{3.2}{6} = \\frac{3.4}{6} = \\frac{17}{30}$\n$$ \\hat{\\phi}'_2 = \\frac{1}{3}(-0.2) + \\frac{5}{6}(0.8) - \\frac{1}{6}(1.7) = \\frac{-0.4 + 4.0 - 1.7}{6} = \\frac{1.9}{6} = \\frac{19}{60} $$\n\n**2. Linear Weights**\nFor a fifth-order accurate reconstruction at $x_{i+1/2}$, the optimal linear weights are:\n$$ d_0 = \\frac{1}{10}, \\quad d_1 = \\frac{6}{10} = \\frac{3}{5}, \\quad d_2 = \\frac{3}{10} $$\n\n**3. Smoothness Indicators**\nThe Jiang-Shu smoothness indicators $\\beta_k$ are:\n$$ \\beta_0 = \\frac{13}{12}(\\phi_{i-2} - 2\\phi_{i-1} + \\phi_i)^2 + \\frac{1}{4}(\\phi_{i-2} - 4\\phi_{i-1} + 3\\phi_i)^2 $$\n$$ \\beta_1 = \\frac{13}{12}(\\phi_{i-1} - 2\\phi_i + \\phi_{i+1})^2 + \\frac{1}{4}(\\phi_{i-1} - \\phi_{i+1})^2 $$\n$$ \\beta_2 = \\frac{13}{12}(\\phi_i - 2\\phi_{i+1} + \\phi_{i+2})^2 + \\frac{1}{4}(3\\phi_i - 4\\phi_{i+1} + \\phi_{i+2})^2 $$\nUsing the given data:\n- For $\\beta_0$: $\\phi_{i-2} - 2\\phi_{i-1} + \\phi_i = -2.2 - 2(-1.2) - 0.2 = 0$. $\\phi_{i-2} - 4\\phi_{i-1} + 3\\phi_i = -2.2 - 4(-1.2) + 3(-0.2) = 2$. So, $\\beta_0 = \\frac{13}{12}(0)^2 + \\frac{1}{4}(2)^2 = 1$.\n- For $\\beta_1$: $\\phi_{i-1} - 2\\phi_i + \\phi_{i+1} = -1.2 - 2(-0.2) + 0.8 = 0$. $\\phi_{i-1} - \\phi_{i+1} = -1.2 - 0.8 = -2$. So, $\\beta_1 = \\frac{13}{12}(0)^2 + \\frac{1}{4}(-2)^2 = 1$.\n- For $\\beta_2$: $\\phi_i - 2\\phi_{i+1} + \\phi_{i+2} = -0.2 - 2(0.8) + 1.7 = -0.1$. $3\\phi_i - 4\\phi_{i+1} + \\phi_{i+2} = 3(-0.2) - 4(0.8) + 1.7 = -2.1$. So, $\\beta_2 = \\frac{13}{12}(-0.1)^2 + \\frac{1}{4}(-2.1)^2 = \\frac{13}{1200} + \\frac{4.41}{4} = \\frac{13 + 1323}{1200} = \\frac{1336}{1200} = \\frac{167}{150}$.\n\n**4. Final Reconstructed Derivative**\nThe non-linear weights $\\omega_k$ are computed as $\\omega_k = \\alpha_k / \\sum_j \\alpha_j$, where $\\alpha_k = d_k / (\\beta_k + \\epsilon)^2$. With $\\epsilon = 10^{-6}$:\n$$ \\alpha_0 = \\frac{0.1}{(1 + 10^{-6})^2} \\approx 0.0999998 $$\n$$ \\alpha_1 = \\frac{0.6}{(1 + 10^{-6})^2} \\approx 0.5999988 $$\n$$ \\alpha_2 = \\frac{0.3}{(167/150 + 10^{-6})^2} \\approx \\frac{0.3}{1.239506} \\approx 0.2420311 $$\nSum of weights: $\\sum_j \\alpha_j \\approx 0.9420297$.\n$$ \\omega_0 \\approx 0.1061536, \\quad \\omega_1 \\approx 0.6369103, \\quad \\omega_2 \\approx 0.2569361 $$\nThe final reconstructed derivative is $(\\partial_x \\phi)_{WENO5} = \\sum_{k=0}^2 \\omega_k \\hat{\\phi}'_k$:\n$$ (\\partial_x \\phi)_{WENO5} \\approx (0.1061536)\\left(\\frac{3}{10}\\right) + (0.6369103)\\left(\\frac{17}{30}\\right) + (0.2569361)\\left(\\frac{19}{60}\\right) $$\n$$ (\\partial_x \\phi)_{WENO5} \\approx 0.031846 + 0.360916 + 0.081397 = 0.474159 $$\nThe values to report are the derivative, the linear weights, and the smoothness indicators.\n\nFinal Answer Vector:\n1.  Reconstructed Derivative: $0.474159$\n2.  Linear Weights: $d_0=1/10, d_1=3/5, d_2=3/10$\n3.  Smoothness Indicators: $\\beta_0=1, \\beta_1=1, \\beta_2=167/150$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.474159  \\frac{1}{10}  \\frac{3}{5}  \\frac{3}{10}  1  1  \\frac{167}{150}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Having examined the core numerical building blocks, we now address a practical challenge where standard methods can fall short. When interfaces are separated by a distance comparable to the grid resolution, standard reinitialization can cause them to merge artificially, a critical issue in simulating thin films or ligaments. This coding exercise guides you through simulating this numerical erosion and implementing a \"clipping\" strategy, a robust technique to preserve under-resolved geometric features .",
            "id": "3339798",
            "problem": "Consider a one-dimensional Level Set Method (LSM) for representing interfaces by the zero level of a scalar field $\\phi(x,t)$. A signed distance function is defined by the property $\\lvert \\nabla \\phi \\rvert = 1$ almost everywhere, with $\\phi  0$ inside a region and $\\phi  0$ outside. Reinitialization is the process of evolving an arbitrary $\\phi(x,0)$ toward a steady state that satisfies the Eikonal equation $\\lvert \\nabla \\phi \\rvert = 1$ while preserving the original zero level set topology. A standard reinitialization approach uses the Hamilton–Jacobi evolution equation\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S_{\\epsilon}(\\phi_0)\\, \\left(\\lvert \\nabla \\phi \\rvert - 1\\right) = 0,\n$$\nwhere $\\tau$ is a fictitious time, $\\phi_0$ is the initial field, and $S_{\\epsilon}$ is a smooth sign function constructed from $\\phi_0$ (for example $S_{\\epsilon}(u) = \\frac{u}{\\sqrt{u^2+\\epsilon^2}}$). In a one-dimensional spatial grid with spacing $h$, the Godunov upwind discretization for $\\lvert \\nabla \\phi \\rvert$ may be used together with explicit time stepping subject to a Courant–Friedrichs–Lewy (CFL) condition.\n\nWhen two interfaces are closely spaced with gap $g$ on the order of the grid spacing $h$, reinitialization can spuriously merge the interfaces or erode the thin film between them because $S_{\\epsilon}(\\phi_0)$ is regularized across a width comparable to $h$, causing overlapping smoothing neighborhoods and numerical diffusion. Two mitigation ideas are: local clipping of reinitialization speed near ambiguous regions where a grid point is comparably close to two distinct interfaces, or multi-valued signed distance that keeps separate distances to each interface.\n\nYour task is to write a complete program that:\n- Constructs a one-dimensional domain $x \\in [-L,L]$ with a uniform grid of $N$ points and spacing $h$.\n- Builds an initial signed distance field $\\phi_0(x)$ that represents a thin film bounded by two interfaces symmetrically placed at $x=-g/2$ and $x=+g/2$, with $\\phi_0(x)  0$ inside the film and $\\phi_0(x)  0$ outside, and with $\\phi_0$ equal to the signed distance to the nearest interface.\n- Evolves $\\phi$ by explicit Euler time stepping in fictitious time $\\tau$, using the above reinitialization equation with Godunov upwinding in one spatial dimension:\n  - For each grid index $i$, define one-sided differences $D^+ \\phi_i = \\frac{\\phi_{i+1}-\\phi_i}{h}$ and $D^- \\phi_i = \\frac{\\phi_i-\\phi_{i-1}}{h}$. For boundaries, enforce homogeneous Neumann conditions by copying boundary values when needed.\n  - For each $i$, compute \n    $$\n    G_i = \n    \\begin{cases}\n    \\sqrt{\\max\\left(\\max(D^- \\phi_i, 0)^2, \\min(D^+ \\phi_i, 0)^2\\right)}  \\text{if } S_{\\epsilon}(\\phi_{0,i})  0,\\\\\n    \\sqrt{\\max\\left(\\max(D^+ \\phi_i, 0)^2, \\min(D^- \\phi_i, 0)^2\\right)}  \\text{if } S_{\\epsilon}(\\phi_{0,i})  0,\\\\\n    0  \\text{if } S_{\\epsilon}(\\phi_{0,i}) = 0,\n    \\end{cases}\n    $$\n    and update \n    $$\n    \\phi_i^{n+1} = \\phi_i^n - \\Delta \\tau \\, S_{\\epsilon}(\\phi_{0,i})\\, \\left(G_i - 1\\right).\n    $$\n- Implements a local clipping strategy that suppresses reinitialization where a grid point is nearly equidistant from two interfaces: Let $x_L$ and $x_R$ denote the two interface positions initialized from $\\phi_0$ (found by subcell zero-crossing detection). Define for each grid point $x_i$ the distances $d_L = \\lvert x_i - x_L \\rvert$ and $d_R = \\lvert x_i - x_R \\rvert$, and the closeness measure $c_i = \\lvert d_L - d_R \\rvert$. Introduce a weight $w_i \\in \\{0,1\\}$ defined by\n  $$\n  w_i = \\begin{cases}\n  0  \\text{if } c_i  \\beta\\, h,\\\\\n  1  \\text{otherwise},\n  \\end{cases}\n  $$\n  and replace $S_{\\epsilon}(\\phi_{0,i})$ by $w_i\\, S_{\\epsilon}(\\phi_{0,i})$ in the update. This locally freezes reinitialization where two interfaces are too close to distinguish at grid scale. Take $\\beta$ as a fixed constant.\n- After reinitialization for a specified number of steps, measures two diagnostics:\n  - The number of zero crossings detected by sign change between adjacent grid points, computed by linear interpolation to subcell positions. This quantifies whether two interfaces persist.\n  - The film thickness, defined as the distance between the two zero-crossing positions that bracket $x=0$. If fewer than two crossings are found, report a film thickness of $0$.\n\nUse the following fixed numerical parameters for all tests:\n- Domain half-length $L = 1$ (dimensionless).\n- Number of grid points $N = 801$ (so that the domain includes $x=0$).\n- Grid spacing $h = \\frac{2L}{N-1}$ (dimensionless).\n- Reinitialization smoothing parameter $\\epsilon = \\alpha h$ with $\\alpha = 1.5$ (dimensionless).\n- Time step $\\Delta \\tau = 0.3 h$ (dimensionless) to respect the Courant–Friedrichs–Lewy number.\n- Number of reinitialization steps $N_{\\tau} = 300$.\n- Clipping threshold factor $\\beta = 1$.\n\nTest suite:\n- Case A (happy path): $g/h = 3.0$.\n- Case B (boundary): $g/h = 1.0$.\n- Case C (edge): $g/h = 0.5$.\n\nFor each case, run two reinitializations starting from the same $\\phi_0$: one with the baseline scheme, and one with the clipping strategy enabled. For each run, report:\n- $g/h$ as a float,\n- the baseline zero-crossing count as an integer,\n- the baseline film thickness divided by $h$ as a float,\n- the clipped zero-crossing count as an integer,\n- the clipped film thickness divided by $h$ as a float.\n\nFinal output format:\n- Your program should produce a single line of output containing a list with three elements, one for each case. Each element must be a list of the five values in the order specified above, for example\n  $$\n  \\left[ [g/h, z_{\\text{base}}, t_{\\text{base}}/h, z_{\\text{clip}}, t_{\\text{clip}}/h], \\ \\ldots \\right].\n  $$\n- All quantities are dimensionless as defined, so no physical units are required.",
            "solution": "### Introduction to Level Set Reinitialization\n\nThe Level Set Method (LSM) is a powerful numerical technique for tracking evolving interfaces and shapes, widely used in fields like computational fluid dynamics, computer graphics, and materials science. The core idea is to represent an interface $\\Gamma$ as the zero level set of a higher-dimensional scalar function $\\phi(\\mathbf{x}, t)$, i.e., $\\Gamma(t) = \\{ \\mathbf{x} \\mid \\phi(\\mathbf{x}, t) = 0 \\}$. By convention, $\\phi  0$ inside the region enclosed by the interface and $\\phi  0$ outside.\n\nFor numerical stability and accuracy, it is highly desirable for $\\phi$ to be a signed distance function (SDF), which satisfies the Eikonal equation $|\\nabla \\phi| = 1$. However, during the evolution of the interface, the $\\phi$ field can become distorted, losing the SDF property. Reinitialization is a crucial procedure that reshapes $\\phi$ back into an SDF while keeping the zero level set ($\\phi=0$) unchanged. This is typically achieved by solving a Hamilton-Jacobi equation until a steady state is reached:\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S(\\phi_0) \\left( |\\nabla \\phi| - 1 \\right) = 0\n$$\nHere, $\\tau$ is a fictitious time variable for the reinitialization process. $S(\\phi_0)$ is a sign function derived from the initial, distorted field $\\phi_0$ before reinitialization. It ensures that the evolution proceeds in the correct direction (i.e., making $|\\nabla \\phi|$ closer to $1$) without moving the zero level set. To avoid singularities, a smoothed sign function is used, such as $S_{\\epsilon}(\\phi_0) = \\frac{\\phi_0}{\\sqrt{\\phi_0^2 + \\epsilon^2}}$, where $\\epsilon$ is a small parameter typically on the order of the grid spacing $h$.\n\n### Numerical Discretization\n\nThe reinitialization equation is solved on a discrete grid. We consider a one-dimensional domain $x \\in [-L, L]$ with $N$ uniformly spaced grid points $x_i$ and spacing $h = \\frac{2L}{N-1}$.\n\n- **Time Discretization**: An explicit forward Euler method is used to advance in fictitious time $\\tau$:\n  $$\n  \\frac{\\phi_i^{n+1} - \\phi_i^n}{\\Delta \\tau} = -S_{\\epsilon}(\\phi_{0,i}) \\left( |\\nabla \\phi|_i - 1 \\right)\n  $$\n  where $\\Delta \\tau$ is the time step, chosen small enough to satisfy the Courant–Friedrichs–Lewy (CFL) stability condition.\n\n- **Spatial Discretization**: The non-linear term $|\\nabla \\phi|$ requires a careful upwind discretization scheme appropriate for Hamilton-Jacobi equations. The Godunov scheme is a standard choice. In one dimension, it is given by:\n  $$\n  |\\nabla \\phi|_i \\approx G_i =\n  \\begin{cases}\n  \\sqrt{\\max\\left(\\left(\\max(D^- \\phi_i, 0)\\right)^2, \\left(\\min(D^+ \\phi_i, 0)\\right)^2\\right)}  \\text{if } S_{\\epsilon}(\\phi_{0,i})  0 \\\\\n  \\sqrt{\\max\\left(\\left(\\max(D^+ \\phi_i, 0)\\right)^2, \\left(\\min(D^- \\phi_i, 0)\\right)^2\\right)}  \\text{if } S_{\\epsilon}(\\phi_{0,i})  0 \\\\\n  0  \\text{if } S_{\\epsilon}(\\phi_{0,i}) = 0\n  \\end{cases}\n  $$\n  where $D^+ \\phi_i = \\frac{\\phi_{i+1} - \\phi_i}{h}$ and $D^- \\phi_i = \\frac{\\phi_i - \\phi_{i-1}}{h}$ are the forward and backward finite differences, respectively. Homogeneous Neumann boundary conditions ($\\frac{\\partial\\phi}{\\partial x}=0$) are enforced at the domain boundaries.\n\nThe full update for a grid point $\\phi_i$ from time step $n$ to $n+1$ is thus:\n$$\n\\phi_i^{n+1} = \\phi_i^n - \\Delta \\tau \\, S_{\\epsilon}(\\phi_{0,i})\\, \\left(G_i - 1\\right)\n$$\n\n### The Thin Film Problem and Numerical Erosion\n\nA known challenge in LSM is the representation of thin structures whose thickness is comparable to the grid spacing. In this problem, we model a thin film of thickness $g$ symmetrically placed around $x=0$. The initial field $\\phi_0(x)$ is constructed as a true signed distance function to the interfaces at $x = -g/2$ and $x = +g/2$.\n\nWhen $g$ is on the order of $h$, standard reinitialization can lead to numerical errors. The smoothed sign function $S_{\\epsilon}(\\phi_0)$ has a transition region of width proportional to $\\epsilon = \\alpha h$. If the film is too thin, the smoothing from the left interface can overlap with the smoothing from the right interface. This can create ambiguity in the sign term $S_{\\epsilon}(\\phi_0)$ near the center of the film, leading to incorrect evolution and causing the two interfaces to merge or the film to \"erode\", effectively destroying the feature.\n\n### The Clipping Mitigation Strategy\n\nTo counteract this erosion, a local clipping strategy is introduced. The core idea is to suppress reinitialization in regions where the grid is too coarse to unambiguously determine the nearest interface.\n\n$1$. The initial interface locations, $x_L$ and $x_R$, are found by detecting the zero-crossings of the initial field $\\phi_0$.\n$2$. For each grid point $x_i$, we compute its distance to the left and right interfaces, $d_L = |x_i - x_L|$ and $d_R = |x_i - x_R|$.\n$3$. A \"closeness measure\" $c_i = |d_L - d_R|$ is defined. A small value of $c_i$ indicates that $x_i$ is nearly equidistant from both interfaces. This is the region of ambiguity.\n$4$. A binary weight $w_i$ is defined based on a threshold $\\beta h$:\n   $$\n   w_i = \\begin{cases}\n   0  \\text{if } c_i  \\beta h \\\\\n   1  \\text{otherwise}\n   \\end{cases}\n   $$\n$5$. This weight is used to modify the update rule by multiplying the sign term, effectively \"clipping\" or freezing the reinitialization speed where $w_i=0$:\n   $$\n   \\phi_i^{n+1} = \\phi_i^n - \\Delta \\tau \\, \\left(w_i S_{\\epsilon}(\\phi_{0,i})\\right)\\, \\left(G_i - 1\\right)\n   $$\nThis strategy selectively applies reinitialization, preserving the film's integrity in under-resolved regions.\n\n### Simulation and Evaluation\n\nThe program implements both the baseline and the clipped reinitialization schemes. It initializes a thin film for three different ratios of film thickness to grid spacing, $g/h$. After a fixed number of reinitialization steps ($N_{\\tau}=300$), two diagnostics are computed:\n- The number of zero-crossings, which indicates if the two interfaces have merged into one or disappeared.\n- The film thickness, measured as the distance between the two zero-crossings that bracket the origin, which quantifies the extent of film erosion.\n\nBy comparing the results of the baseline and clipped schemes, the effectiveness of the mitigation strategy is evaluated across different levels of film resolution.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D level set reinitialization problem for a thin film,\n    comparing a baseline scheme with a local clipping mitigation strategy.\n    \"\"\"\n\n    # Define the fixed numerical parameters from the problem statement.\n    L = 1.0\n    N = 801\n    h = 2 * L / (N - 1)\n    alpha = 1.5\n    epsilon = alpha * h\n    dt = 0.3 * h\n    N_tau = 300\n    beta = 1.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        3.0,  # Case A: g/h = 3.0\n        1.0,  # Case B: g/h = 1.0\n        0.5,  # Case C: g/h = 0.5\n    ]\n    \n    # Grid setup\n    x = np.linspace(-L, L, N, dtype=np.float64)\n    \n    results = []\n\n    def find_zero_crossings(x_grid, phi_field):\n        \"\"\"Finds subcell zero-crossing locations using linear interpolation.\"\"\"\n        crossings = []\n        # Find indices where sign changes\n        indices = np.where(phi_field[:-1] * phi_field[1:]  0)[0]\n        for i in indices:\n            phi_i, phi_i1 = phi_field[i], phi_field[i+1]\n            x_i, x_i1 = x_grid[i], x_grid[i+1]\n            # Linear interpolation formula for zero crossing\n            x_cross = x_i - phi_i * (x_i1 - x_i) / (phi_i1 - phi_i)\n            crossings.append(x_cross)\n        return sorted(crossings)\n\n    def calculate_diagnostics(crossings, h_spacing):\n        \"\"\"Calculates number of crossings and film thickness.\"\"\"\n        num_crossings = len(crossings)\n        \n        neg_crossings = [c for c in crossings if c = 0]\n        pos_crossings = [c for c in crossings if c  0]\n        \n        thickness = 0.0\n        if neg_crossings and pos_crossings:\n            thickness = min(pos_crossings) - max(neg_crossings)\n            \n        return num_crossings, thickness / h_spacing\n\n    for gh_ratio in test_cases:\n        g = gh_ratio * h\n\n        # Build initial signed distance field phi_0\n        dist = np.minimum(np.abs(x + g / 2.0), np.abs(x - g / 2.0))\n        sign_field = np.ones_like(x)\n        sign_field[(x  -g / 2.0)  (x  g / 2.0)] = -1.0\n        phi0 = dist * sign_field\n\n        # Pre-compute the smoothed sign of the initial field\n        s_phi0 = phi0 / np.sqrt(phi0**2 + epsilon**2)\n\n        case_results = [gh_ratio]\n\n        # --- Run simulation for both baseline and clipped schemes ---\n        for use_clipping in [False, True]:\n            phi = phi0.copy()\n            \n            w = np.ones(N) # Default weights (no clipping)\n            if use_clipping:\n                # Calculate clipping weights\n                initial_crossings = find_zero_crossings(x, phi0)\n                if len(initial_crossings) = 2:\n                    neg_crossings = [c for c in initial_crossings if c = 0]\n                    pos_crossings = [c for c in initial_crossings if c  0]\n                    if neg_crossings and pos_crossings:\n                        x_L, x_R = max(neg_crossings), min(pos_crossings)\n                    else: # Fallback for unexpected cases\n                        x_L, x_R = -g/2.0, g/2.0\n                else: # Fallback for unexpected cases\n                    x_L, x_R = -g/2.0, g/2.0\n                \n                d_L = np.abs(x - x_L)\n                d_R = np.abs(x - x_R)\n                c = np.abs(d_L - d_R)\n                w[c  beta * h] = 0.0\n\n            # Evolve in fictitious time\n            for _ in range(N_tau):\n                # Enforce homogeneous Neumann boundary conditions via padding\n                padded_phi = np.pad(phi, 1, 'edge')\n                \n                # Compute one-sided differences\n                diffs = np.diff(padded_phi) / h\n                dm = diffs[:-1]\n                dp = diffs[1:]\n                \n                # Compute Godunov upwind scheme for |nabla phi|\n                grad_phi_sq = np.zeros(N)\n                \n                idx_pos = s_phi0  0\n                idx_neg = s_phi0  0\n                \n                grad_phi_sq[idx_pos] = np.maximum(np.maximum(dm[idx_pos], 0)**2, np.minimum(dp[idx_pos], 0)**2)\n                grad_phi_sq[idx_neg] = np.maximum(np.maximum(dp[idx_neg], 0)**2, np.minimum(dm[idx_neg], 0)**2)\n                \n                G = np.sqrt(grad_phi_sq)\n                \n                # Update phi\n                update_term = s_phi0\n                if use_clipping:\n                    update_term *= w\n                \n                phi -= dt * update_term * (G - 1)\n\n            # Calculate and store diagnostics for this run\n            final_crossings = find_zero_crossings(x, phi)\n            z_count, t_h_ratio = calculate_diagnostics(final_crossings, h)\n            case_results.extend([z_count, t_h_ratio])\n            \n        results.append(case_results)\n\n    # Format the final output string to be exactly as specified\n    final_output_list = []\n    for sublist in results:\n        final_output_list.append([\n            float(f\"{sublist[0]:.1f}\"),\n            int(sublist[1]),\n            float(f\"{sublist[2]:.6f}\"),\n            int(sublist[3]),\n            float(f\"{sublist[4]:.6f}\")\n        ])\n    \n    print(str(final_output_list).replace(\" \", \"\").replace(\"'\", \"\"))\n\n\nsolve()\n```"
        }
    ]
}