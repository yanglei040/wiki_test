{
    "hands_on_practices": [
        {
            "introduction": "理解单个粒子的运动是离散相模型的基础。本练习旨在通过简化更复杂的Maxey-Riley方程，推导在重粒子假设下（$ \\rho_p \\gg \\rho_f $）的粒子运动控制方程。通过求解这个常微分方程的初值问题，您将获得粒子速度随时间演变的解析解，从而加深对粒子响应时间和终端速度等关键概念的理解。",
            "id": "3309864",
            "problem": "考虑一个直径为 $d$、密度为 $\\rho_{p}$ 的单个刚性球形颗粒，在密度为 $\\rho_{f}$、动力粘度为 $\\mu$ 的不可压缩牛顿流体中运动。未受扰动的载体流是稳态且空间均匀的，其速度为 $\\mathbf{u}=\\mathbf{U}$，其中 $\\mathbf{U}$ 是一个常数向量。重力 $\\mathbf{g}$ 是恒定的，并与 $\\mathbf{U}$ 方向一致，因此该运动可视为沿 $\\mathbf{U}$ 方向的一维运动。假设颗粒雷诺数 $\\mathrm{Re}_{p}$（定义为 $\\mathrm{Re}_{p}=\\rho_{f} d |\\mathbf{U}-\\mathbf{v}|/\\mu$）足够小，使得颗粒上的流体动力阻力处于斯托克斯流态。颗粒在时间 $t=0$ 时被释放，初始速度为 $\\mathbf{v}(0)=\\mathbf{v}_{0}$，方向沿 $\\mathbf{U}$。\n\n从牛顿第二定律和斯托克斯阻力表达式出发，通过系统地忽略在比率 $\\rho_{f}/\\rho_{p}$ 下渐近小的项，将 Maxey–Riley 方程特例化到稳态均匀流中的重颗粒极限 $\\rho_{p} \\gg \\rho_{f}$，并推导出控制沿 $\\mathbf{U}$ 方向颗粒速度 $v(t)$ 的一维初值问题。然后精确求解该初值问题，以获得 $v(t)$ 的解析表达式，该表达式应显示其趋近于终端速度的过程。\n\n提供 $v(t)$ 的封闭形式最终表达式，该表达式用 $U=|\\mathbf{U}|$, $g=|\\mathbf{g}|$, $\\mu$, $d$, $\\rho_{p}$ 和 $v_{0}=|\\mathbf{v}_{0}|$ 表示。将答案表示为单个解析表达式。不要进行任何数值计算或四舍五入。最终表达式中不需要单位。",
            "solution": "用户希望我按照以下步骤解决问题：\n1.  **验证问题：**\n    *   **已知条件：**\n        -   颗粒：刚性、球形、直径 $d$、密度 $\\rho_p$。\n        -   流体：不可压缩、牛顿流体、密度 $\\rho_f$、动力粘度 $\\mu$。\n        -   载体流：稳态、均匀速度 $\\mathbf{u} = \\mathbf{U}$（常数向量）。\n        -   重力：$\\mathbf{g}$（常数向量），与 $\\mathbf{U}$ 方向一致。\n        -   颗粒雷诺数：$\\mathrm{Re}_{p} \\ll 1$（斯托克斯流态）。\n        -   初始条件：$t=0$ 时的颗粒速度为 $\\mathbf{v}(0)=\\mathbf{v}_{0}$，方向沿 $\\mathbf{U}$。\n        -   近似：重颗粒极限，$\\rho_{p} \\gg \\rho_{f}$。\n    *   **验证：**\n        -   **科学依据：**该问题基于经典力学和流体动力学的基本原理，特别是应用于流体中颗粒的牛顿第二定律，并包含了诸如阻力、浮力和附加质量等已确定的力。简化到斯托克斯流态和重颗粒极限是含颗粒流中标准且有效的近似。对 Maxey–Riley 方程的引用将问题置于已建立的理论模型之上。\n        -   **适定性：**该问题为一阶常微分方程提供了明确的初始条件，这保证了颗粒速度作为时间函数的解的存在性和唯一性。所有必要的物理参数都已定义。\n        -   **客观性：**问题陈述使用了精确、客观的科学语言，没有主观或基于意见的陈述。\n        -   **完整性和一致性：**问题是自洽的，所有给定的信息都是一致的。推导和求解过程中没有矛盾或缺失所需的参数。\n\n    *   **结论：** 问题有效。\n\n2.  **解决问题：**\n小刚性球体在非均匀流中的运动由 Maxey–Riley 方程描述。对于给定的均匀流体速度场 $\\mathbf{u}(\\mathbf{x},t) = \\mathbf{U}$（其中 $\\mathbf{U}$ 是一个常数向量）的条件，流体速度的物质导数为零：\n$$\n\\frac{D\\mathbf{u}}{Dt} = \\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u} \\cdot \\nabla)\\mathbf{u} = \\mathbf{0}\n$$\n在此条件下，Maxey–Riley 方程大大简化。作用在颗粒上的力包括其惯性力、重力、浮力、附加质量力和斯托克斯阻力。为简化分析或考虑长时间行为，巴塞特历史力在此类分析中通常被忽略，而重颗粒假设进一步证明了忽略该力的合理性。\n\n颗粒的牛顿第二定律为 $m_p \\frac{d\\mathbf{v}}{dt} = \\sum \\mathbf{F}$，其中 $m_p$ 是颗粒质量，$\\mathbf{v}$ 是其速度。这些力包括：\n1.  **重力：** $\\mathbf{F}_g = m_p \\mathbf{g}$。\n2.  **浮力：** 此力源于抵抗重力以支撑流体所需的压力梯度。它等于被排开流体的重量，$\\mathbf{F}_b = -m_f \\mathbf{g}$，其中 $m_f$ 是被颗粒排开的流体质量。\n3.  **斯托克斯阻力：** 对于小颗粒雷诺数，阻力由 $\\mathbf{F}_D = 3\\pi\\mu d(\\mathbf{u} - \\mathbf{v})$ 给出。由于 $\\mathbf{u}=\\mathbf{U}$，这变为 $\\mathbf{F}_D = 3\\pi\\mu d(\\mathbf{U} - \\mathbf{v})$。\n4.  **附加质量力：** 此力与随颗粒一起加速的流体惯性有关。由于 $\\frac{D\\mathbf{u}}{Dt}=0$，它由 $\\mathbf{F}_{am} = -\\frac{1}{2}m_f \\frac{d\\mathbf{v}}{dt}$ 给出。\n\n综合这些力，运动方程为：\n$$\nm_p \\frac{d\\mathbf{v}}{dt} = m_p\\mathbf{g} - m_f\\mathbf{g} + 3\\pi\\mu d(\\mathbf{U} - \\mathbf{v}) - \\frac{1}{2}m_f \\frac{d\\mathbf{v}}{dt}\n$$\n颗粒质量为 $m_p = \\rho_p V_p$，被排开的流体质量为 $m_f = \\rho_f V_p$，其中 $V_p = \\frac{1}{6}\\pi d^3$ 是球形颗粒的体积。将这些代入方程并重新整理，将加速度项集中到一边，得到：\n$$\n\\left(m_p + \\frac{1}{2}m_f\\right)\\frac{d\\mathbf{v}}{dt} = (m_p - m_f)\\mathbf{g} + 3\\pi\\mu d(\\mathbf{U} - \\mathbf{v})\n$$\n将质量用密度和体积表示的表达式代入：\n$$\n\\left(\\rho_p V_p + \\frac{1}{2}\\rho_f V_p\\right)\\frac{d\\mathbf{v}}{dt} = (\\rho_p - \\rho_f)V_p\\mathbf{g} + 3\\pi\\mu d(\\mathbf{U} - \\mathbf{v})\n$$\n除以颗粒体积 $V_p$：\n$$\n\\left(\\rho_p + \\frac{1}{2}\\rho_f\\right)\\frac{d\\mathbf{v}}{dt} = (\\rho_p - \\rho_f)\\mathbf{g} + \\frac{3\\pi\\mu d}{V_p}(\\mathbf{U} - \\mathbf{v})\n$$\n使用 $V_p = \\frac{1}{6}\\pi d^3$，阻力项的系数变为 $\\frac{3\\pi\\mu d}{\\frac{1}{6}\\pi d^3} = \\frac{18\\mu}{d^2}$。方程为：\n$$\n\\left(\\rho_p + \\frac{1}{2}\\rho_f\\right)\\frac{d\\mathbf{v}}{dt} = (\\rho_p - \\rho_f)\\mathbf{g} + \\frac{18\\mu}{d^2}(\\mathbf{U} - \\mathbf{v})\n$$\n问题要求我们考虑重颗粒极限 $\\rho_p \\gg \\rho_f$。在此极限下，与 $\\rho_f$ 成正比的项与与 $\\rho_p$ 成正比的项相比可以忽略不计。因此，我们进行如下近似：\n$$\n\\rho_p + \\frac{1}{2}\\rho_f \\approx \\rho_p\n$$\n$$\n\\rho_p - \\rho_f \\approx \\rho_p\n$$\n这些近似分别对应于忽略相对于颗粒惯性和重量的附加质量力和浮力。运动方程简化为：\n$$\n\\rho_p \\frac{d\\mathbf{v}}{dt} = \\rho_p\\mathbf{g} + \\frac{18\\mu}{d^2}(\\mathbf{U} - \\mathbf{v})\n$$\n除以 $\\rho_p$：\n$$\n\\frac{d\\mathbf{v}}{dt} = \\mathbf{g} + \\frac{18\\mu}{\\rho_p d^2}(\\mathbf{U} - \\mathbf{v})\n$$\n问题陈述 $\\mathbf{U}$ 和 $\\mathbf{g}$ 方向一致，初始速度 $\\mathbf{v}_0$ 也沿此方向。因此，该运动是一维的。我们可以用沿此共同方向的标量大小来表示矢量：$\\mathbf{v} \\to v(t)$，$\\mathbf{U} \\to U$ 和 $\\mathbf{g} \\to g$。得到的一维初值问题是：\n$$\n\\frac{dv}{dt} = g + \\frac{18\\mu}{\\rho_p d^2}(U - v), \\quad v(0) = v_0\n$$\n这是一个一阶线性常微分方程。我们可以将其重写为：\n$$\n\\frac{dv}{dt} + \\left(\\frac{18\\mu}{\\rho_p d^2}\\right)v = g + \\left(\\frac{18\\mu}{\\rho_p d^2}\\right)U\n$$\n我们定义颗粒响应时间 $\\tau_p = \\frac{\\rho_p d^2}{18\\mu}$。方程变为：\n$$\n\\frac{dv}{dt} + \\frac{1}{\\tau_p}v = g + \\frac{U}{\\tau_p}\n$$\n这个常微分方程可以用积分因子 $I(t) = \\exp\\left(\\int \\frac{1}{\\tau_p} dt\\right) = \\exp(t/\\tau_p)$ 来求解。将方程两边乘以 $I(t)$：\n$$\n\\exp(t/\\tau_p)\\frac{dv}{dt} + \\frac{1}{\\tau_p}\\exp(t/\\tau_p)v = \\left(g + \\frac{U}{\\tau_p}\\right)\\exp(t/\\tau_p)\n$$\n左边是一个乘积的导数：\n$$\n\\frac{d}{dt}\\left(v \\exp(t/\\tau_p)\\right) = \\left(g + \\frac{U}{\\tau_p}\\right)\\exp(t/\\tau_p)\n$$\n对两边关于 $t$ 积分：\n$$\nv(t) \\exp(t/\\tau_p) = \\int \\left(g + \\frac{U}{\\tau_p}\\right)\\exp(t/\\tau_p) dt = \\left(g + \\frac{U}{\\tau_p}\\right)\\tau_p \\exp(t/\\tau_p) + C\n$$\n$$\nv(t) \\exp(t/\\tau_p) = (g\\tau_p + U)\\exp(t/\\tau_p) + C\n$$\n其中 $C$ 是积分常数。通过乘以 $\\exp(-t/\\tau_p)$ 来求解 $v(t)$：\n$$\nv(t) = g\\tau_p + U + C \\exp(-t/\\tau_p)\n$$\n我们使用初始条件 $v(0)=v_0$ 来求解 $C$：\n$$\nv(0) = v_0 = g\\tau_p + U + C \\exp(0) = g\\tau_p + U + C\n$$\n$$\nC = v_0 - (g\\tau_p + U) = v_0 - g\\tau_p - U\n$$\n将常数 $C$ 代回 $v(t)$ 的解中：\n$$\nv(t) = g\\tau_p + U + (v_0 - g\\tau_p - U)\\exp(-t/\\tau_p)\n$$\n项 $v_T = g\\tau_p + U$ 代表颗粒的终端速度，即当 $t \\to \\infty$ 时的速度。该解显示了从初始速度 $v_0$ 指数趋近于此终端速度的过程。\n最后，我们将 $\\tau_p = \\frac{\\rho_p d^2}{18\\mu}$ 的表达式代回解中，以用给定的参数表示 $v(t)$：\n$$\nv(t) = \\left(g \\frac{\\rho_p d^2}{18\\mu} + U\\right) + \\left(v_0 - g \\frac{\\rho_p d^2}{18\\mu} - U\\right) \\exp\\left(-\\frac{18\\mu t}{\\rho_p d^2}\\right)\n$$\n这就是颗粒速度随时间变化的最终解析表达式。",
            "answer": "$$\n\\boxed{\n\\left(U + g \\frac{\\rho_p d^2}{18\\mu}\\right) + \\left(v_0 - U - g \\frac{\\rho_p d^2}{18\\mu}\\right) \\exp\\left(-\\frac{18\\mu t}{\\rho_p d^2}\\right)\n}\n$$"
        },
        {
            "introduction": "在将计算代码用于科学研究之前，必须严格验证其能正确求解其所基于的数学方程。本练习将引导您应用制造解方法（Method of Manufactured Solutions, MMS），这是一种强大的代码验证技术。您将通过构造一个解析粒子轨迹，并反向推导出一个“制造”的源项，来检验您的数值积分器是否能够达到预期的收敛阶数，这是开发可靠计算工具的核心技能。",
            "id": "3309830",
            "problem": "您需要为一个用于离散相模拟和粒子追踪的拉格朗日点粒子模型实现一个制造解验证程序。目标是构建一个合成的粒子轨迹和一个光滑不可压缩的载体速度场，推导出一个制造的强迫项，使得所选轨迹成为粒子运动方程的精确解，然后设计数值测试来验证时间和空间上的精度阶数。\n\n从第一性原理开始。假设一个质量为 $m$ 的粒子在二维域中根据牛顿第二定律演化，受到线性的斯托克斯型曳力作用，其中载体流体速度为 $u(x,t)$，粒子状态为 $(x(t),v(t)) \\in \\mathbb{R}^{2} \\times \\mathbb{R}^{2}$。基本控制方程为：\n$$\n\\frac{dx}{dt} = v, \\qquad m \\frac{dv}{dt} = c_{d}\\,\\bigl(u(x,t) - v\\bigr) + F(x,t).\n$$\n这里，$c_{d}$ 是一个曳力系数，$F(x,t)$ 是一个待设计的外部施加的力密度（制造的强迫项）。您将通过指定一个保持在周期性盒子内的精确粒子轨迹 $x^{\\star}(t)$ 来构造一个制造解，然后使用上述方程确定相应的 $F(x,t)$，使得 $(x^{\\star}(t),v^{\\star}(t))$（其中 $v^{\\star}(t) = \\frac{d x^{\\star}}{dt}$）在所有时间 $t$ 都满足这些方程。\n\n请使用以下科学上一致的设定：\n\n- 选择一个边长为 $L = 1\\,\\mathrm{m}$ 的周期性方形域，并在两个空间方向上施加周期性。三角函数中出现的所有角度都应解释为弧度。\n\n- 选择一个模仿泰勒-格林涡的光滑不可压缩载体场：\n$$\nu_{x}(x,y,t) = U\\,\\sin(k x)\\,\\cos(k y)\\,\\cos(\\sigma t), \\quad\nu_{y}(x,y,t) = -U\\,\\cos(k x)\\,\\sin(k y)\\,\\cos(\\sigma t),\n$$\n其中 $U = 0.5\\,\\mathrm{m/s}$，$k = \\frac{2\\pi}{L}$，以及 $\\sigma = 1.0\\,\\mathrm{s}^{-1}$。三角函数的参数是无量纲的，因为 $k$ 的单位是 $\\mathrm{m}^{-1}$，空间坐标的单位是 $\\mathrm{m}$，而 $\\sigma t$ 的单位是弧度。\n\n- 选择一个形式如下的制造粒子轨迹：\n$$\nx^{\\star}(t) =\n\\begin{bmatrix}\nx_{0} + A \\cos(\\omega t) \\\\\ny_{0} + A \\sin(\\omega t)\n\\end{bmatrix},\n\\qquad\nv^{\\star}(t) = \\frac{d x^{\\star}}{dt} =\n\\begin{bmatrix}\n- A \\omega \\sin(\\omega t) \\\\\nA \\omega \\cos(\\omega t)\n\\end{bmatrix},\n$$\n其中 $x_{0} = 0.4\\,L$，$y_{0} = 0.6\\,L$，$A = 0.1\\,L$，以及 $\\omega = 1.3\\,\\mathrm{s}^{-1}$。令 $a^{\\star}(t) = \\frac{d v^{\\star}}{dt}$ 表示精确加速度。该粒子严格保持在周期性域内。\n\n- 考虑粒子质量 $m = 10^{-3}\\,\\mathrm{kg}$ 和基准曳力系数 $c_{d} = 5\\times 10^{-3}\\,\\mathrm{kg/s}$。\n\n您的任务是：\n\n$1.$ 从基本方程出发，推导制造的强迫项 $F(x,t)$，以保证 $(x^{\\star}(t),v^{\\star}(t))$ 精确满足粒子方程。您的推导必须从给定的牛顿第二定律开始，仅使用核心定义（$\\frac{dx}{dt} = v$，$v^{\\star} = \\frac{dx^{\\star}}{dt}$）和直接代入。除了已指定的线性曳力外，不要引入任何经验性的封闭关系。该强迫项必须是时间和已知量的函数，且所有物理单位与国际单位制一致。\n\n$2.$ 为粒子常微分方程实现一个时间积分器，包含两个变体：一个显式二阶龙格-库塔方法（显式中点法）和一个显式四阶龙格-库塔方法。两者都必须以步长 $\\Delta t$ 进行积分，并相应地更新状态 $(x,v)$。在评估载体场 $u(x,t)$ 时，考虑两种情况：\n- 时间精度情景：在粒子位置 $x$ 和时间 $t$ 处，精确地评估解析的 $u(x,t)$。\n- 空间精度情景：在 $[0,L)\\times[0,L)$ 上的一个均匀 $N \\times N$ 网格上，通过双线性插值来近似 $u(x,t)$，并采用周期性环绕处理。网格值取自当前时刻网格节点上精确解析的 $u$。\n\n$3.$ 设计并运行以下数值测试套件。在所有测试中，使用精确的初始条件 $x(0) = x^{\\star}(0)$ 和 $v(0) = v^{\\star}(0)$ 初始化粒子，积分到 $T=1.0\\,\\mathrm{s}$，并将误差测量为位置差异的欧几里得范数 $\\|x_{\\mathrm{num}}(T) - x^{\\star}(T)\\|_{2}$（单位为 $\\mathrm{m}$）。所有角度仅使用弧度。\n\n- 测试A（时间精度，四阶）：使用解析的 $u(x,t)$ 和任务1中得到的制造强迫项。使用显式四阶龙格-库塔方法，对一系列时间步长 $\\Delta t \\in \\{10^{-2}, 5\\times10^{-3}, 2.5\\times 10^{-3}\\}\\,\\mathrm{s}$ 进行积分。通过连续的成对数据计算观测到的阶数 $p$：\n$$\np = \\frac{\\log(e_{1}/e_{2})}{\\log(\\Delta t_{1}/\\Delta t_{2})},\n$$\n其中 $e_{i}$ 是相应时间步长下的终端位置误差。如果两个连续的观测阶数都至少为 $3.8$，则测试通过。\n\n- 测试B（时间精度，二阶）：重复测试A，但使用显式二阶龙格-库塔方法。如果两个连续的观测阶数都至少为 $1.8$，则测试通过。\n\n- 测试C（通过双线性插值的空间精度）：使用显式四阶龙格-库塔方法和一个非常小的时间步长 $\\Delta t = 2\\times 10^{-4}\\,\\mathrm{s}$，以使时间误差可以忽略不计。将解析的 $u(x,t)$ 替换为其在 $N \\in \\{16,32,64\\}$ 的均匀网格上的双线性插值。从终端位置误差计算观测到的空间阶数 $q$，$q = \\frac{\\log(E_{1}/E_{2})}{\\log(h_{1}/h_{2})}$，其中 $h = L/N$。如果两个连续的观测阶数都至少为 $1.8$，则测试通过。\n\n- 测试D（曳力消失的边缘情况）：设置 $c_{d} = 0$，并使用解析的 $u(x,t)$。根据任务1推导适用于 $c_{d}=0$ 的相应制造强迫项。使用显式四阶龙格-库塔方法和 $\\Delta t = 10^{-3}\\,\\mathrm{s}$ 进行积分。如果终端位置误差小于 $10^{-8}\\,\\mathrm{m}$，则测试通过。\n\n$4.$ 您的程序必须生成单行输出，其中包含测试A-D的结果，形式为一个以逗号分隔的布尔值列表，并用方括号括起来，顺序为 $[\\text{A},\\text{B},\\text{C},\\text{D}]$。例如，一个有效的输出可能看起来像 $[\\text{True},\\text{True},\\text{True},\\text{True}]$。\n\n所有物理量必须以国际单位制（米、秒、千克）处理，所有角度必须以弧度为单位。最终输出是布尔值，它们是无量纲的。\n\n提供一个完整的、可运行的程序，该程序以符号化的方式执行任务1的推导来定义制造的强迫项，实现积分器，使用指定的参数运行四个测试，并以所描述的精确格式打印所需的单行输出。不允许用户输入，程序必须是自包含的。",
            "solution": "该问题要求使用制造解方法（Method of Manufactured Solutions, MMS）为拉格朗日粒子追踪模型实现并执行一个验证套件。该过程涉及推导一个合成的强迫项，使得一个选定的解析轨迹成为控制方程的精确解，然后实现数值方案来求解这些方程，并运行测试以验证预期的精度阶数。\n\n粒子的状态由其位置 $x(t) \\in \\mathbb{R}^2$ 和速度 $v(t) \\in \\mathbb{R}^2$ 描述。在牛顿第二定律和线性斯托克斯曳力作用下的控制方程如下：\n$$\n\\frac{dx}{dt} = v\n$$\n$$\nm \\frac{dv}{dt} = c_{d}\\,\\bigl(u(x,t) - v\\bigr) + F(x,t)\n$$\n其中 $m$ 是粒子质量，$c_{d}$ 是曳力系数，$u(x,t)$ 是载体流体速度，$F(x,t)$ 是待确定的制造强迫项。所有量均采用国际单位制，角度单位为弧度。\n\n**1. 制造强迫项的推导**\n\nMMS的核心原理是假设一个精确的解析解，然后推导出使其满足控制方程所必需的源项或强迫项。我们已知制造的粒子轨迹 $x^{\\star}(t)$ 及其对应的速度 $v^{\\star}(t) = \\frac{dx^{\\star}}{dt}$ 和加速度 $a^{\\star}(t) = \\frac{dv^{\\star}}{dt}$。\n$$\nx^{\\star}(t) =\n\\begin{bmatrix}\nx_{0} + A \\cos(\\omega t) \\\\\ny_{0} + A \\sin(\\omega t)\n\\end{bmatrix}\n$$\n$$\nv^{\\star}(t) =\n\\begin{bmatrix}\n- A \\omega \\sin(\\omega t) \\\\\nA \\omega \\cos(\\omega t)\n\\end{bmatrix}\n$$\n$$\na^{\\star}(t) =\n\\begin{bmatrix}\n- A \\omega^2 \\cos(\\omega t) \\\\\n- A \\omega^2 \\sin(\\omega t)\n\\end{bmatrix}\n$$\n为了使该轨迹成为一个精确解，当粒子在 $x^{\\star}(t)$ 处具有速度 $v^{\\star}(t)$ 时，运动方程必须在所有时间 $t$ 都得到满足。将 $(x^{\\star}(t), v^{\\star}(t), a^{\\star}(t))$ 代入第二个控制方程得到：\n$$\nm a^{\\star}(t) = c_{d}\\,\\bigl(u(x^{\\star}(t),t) - v^{\\star}(t)\\bigr) + F(x^{\\star}(t),t)\n$$\n制造的强迫项 $F(x^{\\star}(t),t)$ 是平衡此方程所需的项。我们可以直接求解它。为了模拟的目的，我们只需要沿着已知的轨迹评估这个力，因此我们将其定义为时间的函数，$F(t) \\equiv F(x^{\\star}(t),t)$：\n$$\nF(t) = m a^{\\star}(t) - c_{d}\\,\\bigl(u(x^{\\star}(t),t) - v^{\\star}(t)\\bigr)\n$$\n这个方程提供了强迫项向量的解析表达式。其分量 $F_x(t)$ 和 $F_y(t)$ 依赖于已知的函数 $x^{\\star}(t)$、$v^{\\star}(t)$、$a^{\\star}(t)$ 和给定的载体速度场 $u(x,y,t)$。对于测试D中 $c_d = 0\\,\\mathrm{kg/s}$ 的特殊情况，强迫项简化为 $F(t) = m a^{\\star}(t)$，正如预期的那样。\n\n**2. 数值实现**\n\n粒子的运动由一个针对状态向量 $Y(t) = [x(t), y(t), v_x(t), v_y(t)]^T$ 的四个一阶常微分方程（ODE）组成的系统控制。该系统写作 $\\frac{dY}{dt} = G(Y, t)$，其中：\n$$\nG(Y, t) = \\begin{pmatrix} v_x \\\\ v_y \\\\ \\frac{1}{m} [c_d(u_x(x,y,t) - v_x) + F_x(t)] \\\\ \\frac{1}{m} [c_d(u_y(x,y,t) - v_y) + F_y(t)] \\end{pmatrix}\n$$\n注意，制造的强迫项 $F(t)$ 仅是时间的函数，并且是使用*解析*解来评估的，而不是数值状态 $Y$。这是MMS的一个关键方面。\n\n我们实现两种显式龙格-库塔方法来将该系统从 $t=0$ 积分到 $t=T$：\n\n*   **显式二阶龙格-库塔（中点法）**：\n    $$\n    k_1 = G(Y_n, t_n)\n    $$\n    $$\n    k_2 = G(Y_n + \\frac{\\Delta t}{2} k_1, t_n + \\frac{\\Delta t}{2})\n    $$\n    $$\n    Y_{n+1} = Y_n + \\Delta t \\, k_2\n    $$\n    该方法在时间上具有理论上的二阶精度，即误差与 $(\\Delta t)^2$ 成正比。\n\n*   **经典四阶龙格-库塔（RK4）**：\n    $$\n    k_1 = G(Y_n, t_n)\n    $$\n    $$\n    k_2 = G(Y_n + \\frac{\\Delta t}{2} k_1, t_n + \\frac{\\Delta t}{2})\n    $$\n    $$\n    k_3 = G(Y_n + \\frac{\\Delta t}{2} k_2, t_n + \\frac{\\Delta t}{2})\n    $$\n    $$\n    k_4 = G(Y_n + \\Delta t \\, k_3, t_n + \\Delta t)\n    $$\n    $$\n    Y_{n+1} = Y_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n    $$\n    该方法在时间上具有理论上的四阶精度，即误差 $\\propto (\\Delta t)^4$。\n\n在函数 $G(Y,t)$ 中，载体速度 $u(x,t)$ 的评估以两种方式处理：\n1.  **解析评估**：对于时间精度测试，函数 $u(x,y,t)$ 在当前数值粒子位置 $(x,y)$ 和时间 $t$ 处，使用其给定的解析公式直接评估。\n2.  **双线性插值**：对于空间精度测试，载体速度首先在当前时间 $t$ 于域 $[0,L) \\times [0,L)$ 上的一个均匀 $N \\times N$ 网格上计算。然后，任意粒子位置 $(x_p, y_p)$ 处的速度通过周围四个网格节点的值进行双线性插值来近似。该域是周期性的，因此位置和网格索引使用模运算处理。网格间距为 $h=L/N$，双线性插值的理论误差与 $h^2$ 成正比。\n\n**3. 验证测试套件**\n\n通过四个测试来验证实现，数值解从精确的初始条件 $x(0) = x^{\\star}(0)$ 和 $v(0) = v^{\\star}(0)$ 开始。误差被测量为最终时间 $T=1.0\\,\\mathrm{s}$ 时数值位置与精确位置之差的欧几里得范数，记为 $e = \\|x_{\\mathrm{num}}(T) - x^{\\star}(T)\\|_{2}$。观测到的收敛阶数 $p$ 由使用分辨率 $r_1$ 和 $r_2$（其中 $r$ 是 $\\Delta t$ 或 $h$）得到的误差 $e_1$ 和 $e_2$ 计算得出，公式为 $p = \\log(e_1/e_2) / \\log(r_1/r_2)$。\n\n*   **测试A（时间精度，RK4）**：验证RK4积分器的四阶时间精度。观测阶数 $p$ 预计接近4。对于两次连续的 $\\Delta t$ 细化，如果 $p \\ge 3.8$，则测试通过。\n*   **测试B（时间精度，RK2）**：验证RK2积分器的二阶时间精度。观测阶数 $p$ 预计接近2。对于两次连续的 $\\Delta t$ 细化，如果 $p \\ge 1.8$，则测试通过。\n*   **测试C（空间精度，双线性插值）**：验证双线性插值方案的二阶空间精度。使用一个小的 $\\Delta t$ 以使时间误差可以忽略不计。观测到的空间阶数 $q$ 预计接近2。对于两次连续的网格细化，如果 $q \\ge 1.8$，则测试通过。\n*   **测试D（边缘情况，曳力消失）**：测试在 $c_d = 0$ 情况下的实现正确性。在此极限下，粒子运动与流体无关。使用小时间步长的RK4积分器应该能够以非常高的精度恢复精确轨迹。如果最终位置误差低于 $10^{-8}\\,\\mathrm{m}$，则测试通过。\n\n通过这些测试为代码正确实现了粒子模型的物理原理和数值方案提供了强有力的证据。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs a verification-by-manufactured-solutions procedure\n    for a Lagrangian point-particle model.\n    \"\"\"\n\n    # --- Problem Constants (SI Units) ---\n    L = 1.0  # Domain side length [m]\n    m = 1.0e-3  # Particle mass [kg]\n    cd_base = 5.0e-3  # Baseline drag coefficient [kg/s]\n    U = 0.5  # Carrier velocity amplitude [m/s]\n    k = 2.0 * np.pi / L  # Wavenumber [rad/m]\n    sigma = 1.0  # Carrier flow frequency [rad/s]\n    x0 = 0.4 * L  # Trajectory center x [m]\n    y0 = 0.6 * L  # Trajectory center y [m]\n    A = 0.1 * L  # Trajectory amplitude [m]\n    omega = 1.3  # Trajectory frequency [rad/s]\n    T_final = 1.0  # Final integration time [s]\n\n    # --- Task 1: Analytical and Manufactured Functions ---\n\n    def x_star(t):\n        \"\"\"Exact manufactured particle position.\"\"\"\n        return np.array([x0 + A * np.cos(omega * t), y0 + A * np.sin(omega * t)])\n\n    def v_star(t):\n        \"\"\"Exact manufactured particle velocity.\"\"\"\n        return np.array([-A * omega * np.sin(omega * t), A * omega * np.cos(omega * t)])\n\n    def a_star(t):\n        \"\"\"Exact manufactured particle acceleration.\"\"\"\n        return np.array([-A * omega**2 * np.cos(omega * t), -A * omega**2 * np.sin(omega * t)])\n\n    def u_analytical(pos, t):\n        \"\"\"Analytical carrier velocity field (Taylor-Green vortex).\"\"\"\n        x_pos, y_pos = pos\n        ux = U * np.sin(k * x_pos) * np.cos(k * y_pos) * np.cos(sigma * t)\n        uy = -U * np.cos(k * x_pos) * np.sin(k * y_pos) * np.cos(sigma * t)\n        return np.array([ux, uy])\n\n    def F_manufactured(t, c_d):\n        \"\"\"Manufactured forcing term, a function of time.\"\"\"\n        pos_s, vel_s, acc_s = x_star(t), v_star(t), a_star(t)\n        u_val_at_star = u_analytical(pos_s, t)\n        force = m * acc_s - c_d * (u_val_at_star - vel_s)\n        return force\n\n    # --- Task 2: Integrators and Interpolation ---\n\n    def ode_rhs(state, t, c_d, u_func, F_func):\n        \"\"\"Right-hand side of the particle's ODE system.\"\"\"\n        pos, vel = state[:2], state[2:]\n        pos_periodic = pos % L\n        \n        u_val = u_func(pos_periodic, t)\n        F_val = F_func(t, c_d)\n        \n        d_pos_dt = vel\n        d_vel_dt = (c_d * (u_val - vel) + F_val) / m\n        return np.concatenate([d_pos_dt, d_vel_dt])\n\n    def rk2_step(state, t, dt, c_d, u_func, F_func):\n        \"\"\"A single step using the explicit second-order RK (midpoint) method.\"\"\"\n        k1 = ode_rhs(state, t, c_d, u_func, F_func)\n        state_mid = state + 0.5 * dt * k1\n        t_mid = t + 0.5 * dt\n        k2 = ode_rhs(state_mid, t_mid, c_d, u_func, F_func)\n        return state + dt * k2\n\n    def rk4_step(state, t, dt, c_d, u_func, F_func):\n        \"\"\"A single step using the classic fourth-order RK method.\"\"\"\n        t_mid, t_end = t + 0.5 * dt, t + dt\n        k1 = ode_rhs(state, t, c_d, u_func, F_func)\n        k2 = ode_rhs(state + 0.5 * dt * k1, t_mid, c_d, u_func, F_func)\n        k3 = ode_rhs(state + 0.5 * dt * k2, t_mid, c_d, u_func, F_func)\n        k4 = ode_rhs(state + dt * k3, t_end, c_d, u_func, F_func)\n        return state + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def u_bilinear_interp_factory(N):\n        \"\"\"Factory for creating a bilinear interpolation function for a given grid size N.\"\"\"\n        h = L / N\n        x_nodes = np.linspace(0, L, N, endpoint=False)\n        y_nodes = np.linspace(0, L, N, endpoint=False)\n        \n        def u_interp(pos, t):\n            px, py = pos[0], pos[1]\n            i, j = int(px / h), int(py / h)\n            \n            xi, eta = (px - i * h) / h, (py - j * h) / h\n            \n            ip1, jp1 = (i + 1) % N, (j + 1) % N\n            \n            u00 = u_analytical(np.array([x_nodes[i], y_nodes[j]]), t)\n            u10 = u_analytical(np.array([x_nodes[ip1], y_nodes[j]]), t)\n            u01 = u_analytical(np.array([x_nodes[i], y_nodes[jp1]]), t)\n            u11 = u_analytical(np.array([x_nodes[ip1], y_nodes[jp1]]), t)\n            \n            return (1-xi)*(1-eta)*u00 + xi*(1-eta)*u10 + (1-xi)*eta*u01 + xi*eta*u11\n        \n        return u_interp\n\n    def run_simulation(dt, integrator_step, c_d, u_func, F_func):\n        \"\"\"Drives a single particle simulation and returns the final position error.\"\"\"\n        t = 0.0\n        state = np.concatenate([x_star(0), v_star(0)])\n        \n        num_steps = int(np.ceil(T_final / dt))\n        actual_dt = T_final / num_steps\n\n        for _ in range(num_steps):\n            state = integrator_step(state, t, actual_dt, c_d, u_func, F_func)\n            t += actual_dt\n            \n        pos_num = state[:2]\n        pos_exact = x_star(T_final)\n        return np.linalg.norm(pos_num - pos_exact)\n\n    def get_orders(errors, ratios):\n        \"\"\"Computes observed orders of convergence.\"\"\"\n        return [np.log(errors[i] / errors[i+1]) / np.log(ratios[i]) for i in range(len(errors) - 1)]\n\n    # --- Task 3: Numerical Tests ---\n\n    def run_test_A():\n        \"\"\"Test A: Temporal accuracy, fourth order (RK4).\"\"\"\n        dts = [1.0e-2, 5.0e-3, 2.5e-3]\n        errors = [run_simulation(dt, rk4_step, cd_base, u_analytical, F_manufactured) for dt in dts]\n        dt_ratios = [dts[0]/dts[1], dts[1]/dts[2]]\n        orders = get_orders(errors, dt_ratios)\n        return all(p >= 3.8 for p in orders)\n\n    def run_test_B():\n        \"\"\"Test B: Temporal accuracy, second order (RK2).\"\"\"\n        dts = [1.0e-2, 5.0e-3, 2.5e-3]\n        errors = [run_simulation(dt, rk2_step, cd_base, u_analytical, F_manufactured) for dt in dts]\n        dt_ratios = [dts[0]/dts[1], dts[1]/dts[2]]\n        orders = get_orders(errors, dt_ratios)\n        return all(p >= 1.8 for p in orders)\n\n    def run_test_C():\n        \"\"\"Test C: Spatial accuracy, bilinear interpolation.\"\"\"\n        dt_small = 2.0e-4\n        Ns = [16, 32, 64]\n        errors = []\n        for N in Ns:\n            u_func = u_bilinear_interp_factory(N)\n            errors.append(run_simulation(dt_small, rk4_step, cd_base, u_func, F_manufactured))\n\n        h_values = [L/N for N in Ns]\n        h_ratios = [h_values[0]/h_values[1], h_values[1]/h_values[2]]\n        orders = get_orders(errors, h_ratios)\n        return all(q >= 1.8 for q in orders)\n\n    def run_test_D():\n        \"\"\"Test D: Edge case with vanishing drag.\"\"\"\n        dt = 1.0e-3\n        cd_zero = 0.0\n        error = run_simulation(dt, rk4_step, cd_zero, u_analytical, F_manufactured)\n        return error  1.0e-8\n\n    # --- Task 4: Final Output ---\n    results = [\n        run_test_A(),\n        run_test_B(),\n        run_test_C(),\n        run_test_D(),\n    ]\n\n    # Convert boolean results to strings \"True\" or \"False\"\n    results_str = [str(res) for res in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "即使经过验证的求解器，如果对离散事件（如壁面碰撞）处理不当，其模拟结果也可能不准确。本练习着重于粒子与壁面碰撞的精确事件检测，对比了线性插值和高阶Hermite插值在估算碰撞时间和状态上的差异。通过与解析解的精确结果进行比较，您将量化不同方法引入的误差，并认识到在处理这类不连续事件时进行子时间步长建模的重要性。",
            "id": "3309806",
            "problem": "一个质量为 $m$ 的二维点状粒子在静止流体中受斯托克斯阻力和重力作用而运动。设粒子位置为 $\\boldsymbol{x}_p(t) = (x_p(t), y_p(t))$，速度为 $\\boldsymbol{v}_p(t) = (v_x(t), v_y(t))$。其动力学控制方程由牛顿第二定律给出，包含线性和恒定的重力加速度，重力作用于 $y$ 轴负方向，具体为\n$$\n\\frac{d \\boldsymbol{v}_p}{dt} = -\\frac{1}{\\tau_p} \\boldsymbol{v}_p + (0, -g), \\quad \\frac{d \\boldsymbol{x}_p}{dt} = \\boldsymbol{v}_p,\n$$\n其中 $\\tau_p$ 是粒子弛豫时间，$g$ 是重力加速度的大小。考虑在 $y=0$ 处有一个完全平坦的水平壁面。粒子从壁面上方开始运动，其初始位置满足 $y_p(0)  0$，并在一个大小为 $\\Delta t$ 的指定时间步内穿过该壁面。\n\n您必须设计并比较两种事件检测方案，用于估算在区间 $[0,\\Delta t]$ 内发生碰撞的时间 $t_\\star$（即 $y_p(t_\\star)=0$ 的时刻），并基于此事件时间估算碰撞速度 $\\boldsymbol{v}_p(t_\\star)$、碰撞角度以及碰撞时的动能。这两种方案是：\n\n1. 线性事件检测方法：该方法假设 $y_p(t)$ 在端点 $(t=0,y_p(0))$ 和 $(t=\\Delta t, y_p(\\Delta t))$ 之间呈线性变化来估算 $t_\\star$，然后通过在 $\\boldsymbol{v}_p(0)$ 和 $\\boldsymbol{v}_p(\\Delta t)$ 之间进行线性插值来估算 $\\boldsymbol{v}_p(t_\\star)$。\n\n2. 高阶事件检测方法：该方法基于对 $\\boldsymbol{x}_p(t)$ 的三次 Hermite 插值，为每个分量在 $[0,\\Delta t]$ 上构造一个与两端点的位置和速度均匹配的三次多项式，并通过求解 $y_p(t)=0$（其中 $t \\in [0, \\Delta t]$）来估算 $t_\\star$。然后，通过在估算的碰撞时间对 Hermite 插值函数求导来估算碰撞速度。\n\n您必须使用的基本原理是：\n- 牛顿第二定律 $m\\, d\\boldsymbol{v}_p/dt = \\text{力的总和}$，其中力包括上述指定的斯托克斯阻力和重力。\n- 速度的定义，即位置对时间的导数 $d\\boldsymbol{x}_p/dt = \\boldsymbol{v}_p$。\n- 在区间 $[0,\\Delta t]$ 上，与两端点的函数值和一阶导数均匹配的三次 Hermite 插值的定义。\n- 动能的定义 $E = \\tfrac{1}{2} m \\|\\boldsymbol{v}_p\\|^2$ 以及相对于壁面的碰撞角度的定义，即速度矢量与壁面切线之间的锐角 $\\alpha \\in [0,\\pi/2]$。对于水平壁面，壁面切线为 $x$ 轴，因此 $\\alpha = \\arctan\\!\\left(\\frac{|v_n|}{|v_t|}\\right)$，其中 $v_n = v_y$，$v_t = v_x$。\n\n在评估时，请勿通过离散化运动方程来生成端点状态。相反，应使用线性常微分方程的精确解析解来计算 $t=\\Delta t$ 时的端点位置和速度，然后根据各方案的要求，仅使用端点数据在时间步内执行事件检测。为获取基准真相值，请将真实碰撞时间 $t_\\mathrm{true}$ 计算为精确解 $y_p(t)$ 在 $[0,\\Delta t]$ 上的唯一根，并从解析解中评估出精确速度 $\\boldsymbol{v}_p(t_\\mathrm{true})$。\n\n对于每种方案 $s \\in \\{\\text{linear}, \\text{Hermite}\\}$，量化其绝对误差\n$$\n\\varepsilon_t^{(s)} = |t_\\star^{(s)} - t_\\mathrm{true}| \\ \\text{单位为秒}, \\quad \\varepsilon_\\alpha^{(s)} = |\\alpha^{(s)} - \\alpha^\\mathrm{true}| \\ \\text{单位为弧度}, \\quad \\varepsilon_E^{(s)} = |E^{(s)} - E^\\mathrm{true}| \\ \\text{单位为焦耳},\n$$\n其中 $E = \\tfrac{1}{2} m (v_x^2+v_y^2)$ 且 $\\alpha = \\arctan\\!\\left(\\frac{|v_y|}{|v_x|}\\right)$。角度以弧度表示，时间以秒表示，能量以焦耳表示。所有情况下均使用 $m=1$（千克）。所有数值输出均四舍五入保留六位小数。\n\n请为以下一系列独立测试用例实现此比较。在每个用例中，输入参数为 $(x_0, y_0, v_{x,0}, v_{y,0}, \\tau_p, g, \\Delta t)$，均采用国际单位制基本单位（米、秒）。每个用例均从 $t=0$ 开始。\n\n- 用例 1: $(0.0, 1.0, 1.5, -1.0, 0.2, 9.81, 0.7)$。\n- 用例 2: $(0.0, 0.05, 0.3, -0.2, 0.2, 9.81, 0.1)$。\n- 用例 3: $(0.0, 0.02, 2.0, -0.01, 0.1, 9.81, 0.2)$。\n- 用例 4: $(0.0, 0.1, 0.0, -0.5, 0.02, 9.81, 1.0)$。\n- 用例 5: $(0.0, 0.5, 0.8, -0.5, 5.0, 9.81, 0.3)$。\n\n您的程序必须：\n1. 使用所述线性系统的精确解析解，根据给定的初始状态 $\\boldsymbol{x}_p(0)$ 和 $\\boldsymbol{v}_p(0)$ 计算 $\\boldsymbol{x}_p(\\Delta t)$ 和 $\\boldsymbol{v}_p(\\Delta t)$。\n2. 使用稳健的求根器，将 $t_\\mathrm{true}$ 计算为精确解 $y_p(t)$ 在 $[0,\\Delta t]$ 内的根。\n3. 通过端点间的线性插值计算线性估计值 $t_\\star^{(\\text{linear})}$ 及其相关的 $\\boldsymbol{v}_p(t_\\star^{(\\text{linear})})$。\n4. 使用从端点位置和导数构建的 $y_p(t)$ 的三次 Hermite 插值计算 Hermite 估计值 $t_\\star^{(\\text{Hermite})}$，并通过在 $t_\\star^{(\\text{Hermite})}$ 处对 $x_p(t)$ 和 $y_p(t)$ 的三次 Hermite 插值函数求导来计算其相关的碰撞速度。\n5. 对于 $s \\in \\{\\text{linear}, \\text{Hermite}\\}$，计算 $\\varepsilon_t^{(s)}$、$\\varepsilon_\\alpha^{(s)}$ 和 $\\varepsilon_E^{(s)}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个结果列表，每个测试用例对应一个结果，每个结果是一个包含六个浮点数 $[\\varepsilon_t^{(\\text{Hermite})}, \\varepsilon_t^{(\\text{linear})}, \\varepsilon_\\alpha^{(\\text{Hermite})}, \\varepsilon_\\alpha^{(\\text{linear})}, \\varepsilon_E^{(\\text{Hermite})}, \\varepsilon_E^{(\\text{linear})}]$ 的列表，四舍五入至六位小数。整个输出必须显示为由这些按用例排列的列表组成的单个逗号分隔列表，并用方括号括起来，例如 $[[a_{1,1},a_{1,2},a_{1,3},a_{1,4},a_{1,5},a_{1,6}],[a_{2,1},\\dots],[\\dots]]$，不含任何附加文本。",
            "solution": "经评估，此问题是**有效的**。其科学基础是经典力学原理，具体为牛顿第二定律应用于受斯托克斯阻力和重力作用的粒子。其控制常微分方程是线性的且适定的，对于任何给定的初始条件都存在唯一的解析解。此问题是自洽的、客观的，并提供了所有必要的数据和定义，用于将两种数值事件检测方案（线性和三次 Hermite 插值）与从精确解导出的基准真相值进行比较。这构成了计算流体动力学和离散相建模领域中的一个标准验证任务，且没有任何指定的导致问题无效的缺陷。\n\n解题步骤如下：\n首先，推导粒子运动方程的解析解。该解为任何时间 $t \\ge 0$ 提供了精确的粒子位置 $\\boldsymbol{x}_p(t)$ 和速度 $\\boldsymbol{v}_p(t)$。\n其次，使用此解析解来建立碰撞事件的基准真相值。这包括找到真实的碰撞时间 $t_\\mathrm{true}$，然后评估出真实的碰撞速度 $\\boldsymbol{v}_p(t_\\mathrm{true})$、角度 $\\alpha^\\mathrm{true}$ 和动能 $E^\\mathrm{true}$。\n第三，实现所指定的线性和 Hermite 两种事件检测方案。对于每种方案，我们仅使用时间步开始 ($t=0$) 和结束 ($t=\\Delta t$) 时的粒子状态 $(\\boldsymbol{x}_p, \\boldsymbol{v}_p)$ 来估算碰撞时间 $t_\\star$ 和相应的碰撞属性。\n最后，计算并按规定报告每种方案相对于基准真相值的误差。\n\n### 1. 解析解\n控制方程为：\n$$\n\\frac{d v_x}{dt} = -\\frac{1}{\\tau_p} v_x\n$$\n$$\n\\frac{d v_y}{dt} = -\\frac{1}{\\tau_p} v_y - g\n$$\n初始条件为 $\\boldsymbol{x}_p(0) = (x_0, y_0)$ 和 $\\boldsymbol{v}_p(0) = (v_{x,0}, v_{y,0})$。\n\n这些是一阶线性常微分方程。速度分量的解为：\n$$\nv_x(t) = v_{x,0} e^{-t/\\tau_p}\n$$\n$$\nv_y(t) = (v_{y,0} + g\\tau_p)e^{-t/\\tau_p} - g\\tau_p\n$$\n\n将速度分量从 $0$到 $t$ 对时间进行积分，得到位置分量：\n$$\nx_p(t) = x_0 + \\int_0^t v_x(s) ds = x_0 + v_{x,0} \\tau_p (1 - e^{-t/\\tau_p})\n$$\n$$\ny_p(t) = y_0 + \\int_0^t v_y(s) ds = y_0 + (v_{y,0} + g\\tau_p)\\tau_p(1 - e^{-t/\\tau_p}) - g\\tau_p t\n$$\n这些表达式定义了粒子的精确轨迹。\n\n### 2. 基准真相值计算\n真实碰撞发生在粒子垂直位置为零的时刻 $t_\\mathrm{true}$，即 $y_p(t_\\mathrm{true}) = 0$。由于位置函数 $y_p(t)$ 是一个超越函数，我们通过数值求解方程 $y_p(t) = 0$（其中 $t \\in [0, \\Delta t]$）来找到 $t_\\mathrm{true}$。鉴于 $y_p(0) = y_0  0$ 且问题陈述中说明了在 $\\Delta t$ 内会发生穿越（意味着 $y_p(\\Delta t)  0$），像 Brent 方法这样的区间求根方法是适用的。\n\n一旦确定了 $t_\\mathrm{true}$，通过将其代入解析解来计算真实的碰撞属性：\n-   碰撞速度: $\\boldsymbol{v}_p^\\mathrm{true} = (v_x(t_\\mathrm{true}), v_y(t_\\mathrm{true}))$。\n-   碰撞角度: $\\alpha^\\mathrm{true} = \\arctan\\left(\\frac{|v_y(t_\\mathrm{true})|}{|v_x(t_\\mathrm{true})|}\\right)$。一个稳健的实现使用 `atan2` 函数。\n-   碰撞动能: $E^\\mathrm{true} = \\frac{1}{2}m(v_x(t_\\mathrm{true})^2 + v_y(t_\\mathrm{true})^2)$，其中 $m=1$。\n\n### 3. 线性事件检测方案\n该方案仅使用 $t=0$ 和 $t=\\Delta t$ 时的状态。设初始状态为 $(\\boldsymbol{x}_0, \\boldsymbol{v}_0)$，最终状态为 $(\\boldsymbol{x}_1, \\boldsymbol{v}_1) = (\\boldsymbol{x}_p(\\Delta t), \\boldsymbol{v}_p(\\Delta t))$。\n垂直位置由一个线性函数近似：\n$$\ny_p^{(\\text{linear})}(t) = y_0 + \\frac{y_1 - y_0}{\\Delta t} t\n$$\n令 $y_p^{(\\text{linear})}(t_\\star^{(\\text{linear})})=0$ 可得出估算的碰撞时间：\n$$\nt_\\star^{(\\text{linear})} = -y_0 \\frac{\\Delta t}{y_1 - y_0} = \\frac{y_0}{y_0 - y_1} \\Delta t\n$$\n通过在端点之间对速度矢量进行线性插值来找到碰撞速度：\n$$\n\\boldsymbol{v}_p(t_\\star^{(\\text{linear})}) = \\boldsymbol{v}_0 + (\\boldsymbol{v}_1 - \\boldsymbol{v}_0) \\frac{t_\\star^{(\\text{linear})}}{\\Delta t}\n$$\n根据这个估算的速度，计算出 $\\alpha^{(\\text{linear})}$ 和 $E^{(\\text{linear})}$。\n\n### 4. 三次 Hermite 事件检测方案\n该方法使用端点处的位置及其导数（速度）为每个位置分量构造一个更精确的三次插值函数。对于一个在 $[0, \\Delta t]$ 上的通用函数 $f(t)$，已知 $f_0, f'_0, f_1, f'_1$，其三次 Hermite 插值函数 $P(\\tau)$ 以归一化时间 $\\tau = t/\\Delta t \\in [0,1]$ 表示为：\n$$\nP(\\tau) = A\\tau^3 + B\\tau^2 + C\\tau + D\n$$\n其中 $y$ 分量的系数通过匹配 $y_0, y_1, v_{y,0}, v_{y,1}$ 来确定：\n-   $D = y_0$\n-   $C = \\Delta t v_{y,0}$\n-   $B = 3(y_1 - y_0) - \\Delta t (2 v_{y,0} + v_{y,1})$\n-   $A = 2(y_0 - y_1) + \\Delta t (v_{y,0} + v_{y,1})$\n\n为了找到碰撞时间 $t_\\star^{(\\text{Hermite})}$，我们必须找到三次方程 $A\\tau^3 + B\\tau^2 + C\\tau + D = 0$ 在 $[0,1]$ 内的根 $\\tau_\\star$。这可以使用标准的多项式求根器完成。由于保证会发生穿越，区间内至少存在一个实根。第一次物理碰撞对应于最小的非负根。然后，$t_\\star^{(\\text{Hermite})} = \\tau_\\star \\Delta t$。\n\n碰撞速度通过在估算的碰撞时间点对 $x_p(t)$ 和 $y_p(t)$ 的 Hermite 插值函数求导来估算。插值函数 $P(\\tau)$ 关于 $t$ 的导数为：\n$$\n\\frac{dP}{dt} = \\frac{d\\tau}{dt}\\frac{dP}{d\\tau} = \\frac{1}{\\Delta t} (3A\\tau^2 + 2B\\tau + C)\n$$\n此公式与 $x$ 和 $y$ 插值函数的系数一起使用，并在 $\\tau=\\tau_\\star$ 处求值，以求得 $v_x^{(\\text{Hermite})}$ 和 $v_y^{(\\text{Hermite})}$。根据这些值，计算出 $\\alpha^{(\\text{Hermite})}$ 和 $E^{(\\text{Hermite})}$。\n\n### 5. 误差计算\n对于每种方案 $s \\in \\{\\text{linear}, \\text{Hermite}\\}$，绝对误差计算如下：\n$$\n\\varepsilon_t^{(s)} = |t_\\star^{(s)} - t_\\mathrm{true}|, \\quad \\varepsilon_\\alpha^{(s)} = |\\alpha^{(s)} - \\alpha^\\mathrm{true}|, \\quad \\varepsilon_E^{(s)} = |E^{(s)} - E^\\mathrm{true}|\n$$\n这些值量化了对于给定的测试用例，每种插值方法的准确性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the particle impact problem for all test cases.\n    \"\"\"\n\n    def compute_errors_for_case(params):\n        \"\"\"\n        Computes the results for a single test case.\n        \"\"\"\n        x0, y0, vx0, vy0, tau_p, g, dt = params\n        m = 1.0\n\n        # --- 1. Analytical Solution ---\n        # Define analytical solution functions for velocity and position.\n        def vx_f(t):\n            return vx0 * np.exp(-t / tau_p)\n\n        def vy_f(t):\n            return (vy0 + g * tau_p) * np.exp(-t / tau_p) - g * tau_p\n\n        def x_f(t):\n            if np.isclose(vx0, 0.0):\n                return x0\n            return x0 + vx0 * tau_p * (1.0 - np.exp(-t / tau_p))\n            \n        def y_f(t):\n            return y0 + (vy0 + g * tau_p) * tau_p * (1.0 - np.exp(-t / tau_p)) - g * tau_p * t\n\n        # Helper functions for impact angle and kinetic energy\n        def impact_angle(vx, vy):\n            return np.arctan2(np.abs(vy), np.abs(vx))\n\n        def kinetic_energy(mass, vx, vy):\n            return 0.5 * mass * (vx**2 + vy**2)\n\n        # Compute endpoint states at t = dt\n        x1 = x_f(dt)\n        y1 = y_f(dt)\n        vx1 = vx_f(dt)\n        vy1 = vy_f(dt)\n\n        # --- 2. Ground Truth ---\n        # Find true impact time t_true by finding the root of y_f(t) = 0.\n        try:\n            t_true = brentq(y_f, 0, dt)\n        except ValueError:\n            # This happens if y(0) and y(dt) have the same sign, meaning no crossing\n            # or a touch-and-go event. The problem statement guarantees a crossing.\n            # This is a fallback for robustness.\n            return [0.0] * 6\n        \n        # True impact properties\n        vx_true = vx_f(t_true)\n        vy_true = vy_f(t_true)\n        alpha_true = impact_angle(vx_true, vy_true)\n        E_true = kinetic_energy(m, vx_true, vy_true)\n\n        # --- 3. Linear Scheme ---\n        # Estimate impact time t_linear by linear interpolation of y(t).\n        t_linear = y0 * dt / (y0 - y1)\n        \n        # Estimate impact velocity by linear interpolation of v(t).\n        vx_linear = vx0 + (vx1 - vx0) * t_linear / dt\n        vy_linear = vy0 + (vy1 - vy0) * t_linear / dt\n        \n        # Linear scheme properties\n        alpha_linear = impact_angle(vx_linear, vy_linear)\n        E_linear = kinetic_energy(m, vx_linear, vy_linear)\n\n        # --- 4. Hermite Scheme ---\n        # Estimate impact time t_hermite using cubic Hermite interpolation for y(t).\n        # y_hermite(t) = A*tau^3 + B*tau^2 + C*tau + D, with tau = t/dt.\n        # Coefficients for y(t) interpolant\n        A_y = 2.0 * (y0 - y1) + dt * (vy0 + vy1)\n        B_y = 3.0 * (y1 - y0) - dt * (2.0 * vy0 + vy1)\n        C_y = dt * vy0\n        D_y = y0\n        \n        # Find roots of the cubic polynomial for tau in [0, 1].\n        poly_coeffs = [A_y, B_y, C_y, D_y]\n        roots = np.roots(poly_coeffs)\n       \n        # Filter for real roots in [0, 1] and take the smallest one.\n        real_roots_in_interval = [r.real for r in roots if np.isclose(r.imag, 0) and 0.0 = r.real = 1.0]\n        tau_star = min(real_roots_in_interval) if real_roots_in_interval else 0.0\n        t_hermite = tau_star * dt\n\n        # Estimate impact velocity by differentiating the Hermite interpolant.\n        # v(t_star) = (1/dt) * (3*A*tau_star^2 + 2*B*tau_star + C)\n        # Coefficients for x(t) interpolant\n        A_x = 2.0 * (x0 - x1) + dt * (vx0 + vx1)\n        B_x = 3.0 * (x1 - x0) - dt * (2.0 * vx0 + vx1)\n        C_x = dt * vx0\n\n        vx_hermite = (1.0 / dt) * (3.0 * A_x * tau_star**2 + 2.0 * B_x * tau_star + C_x)\n        vy_hermite = (1.0 / dt) * (3.0 * A_y * tau_star**2 + 2.0 * B_y * tau_star + C_y)\n        \n        # Hermite scheme properties\n        alpha_hermite = impact_angle(vx_hermite, vy_hermite)\n        E_hermite = kinetic_energy(m, vx_hermite, vy_hermite)\n\n        # --- 5. Error Calculation ---\n        eps_t_hermite = abs(t_hermite - t_true)\n        eps_t_linear  = abs(t_linear - t_true)\n        eps_alpha_hermite = abs(alpha_hermite - alpha_true)\n        eps_alpha_linear  = abs(alpha_linear - alpha_true)\n        eps_E_hermite = abs(E_hermite - E_true)\n        eps_E_linear = abs(E_linear - E_true)\n\n        return [\n            round(eps_t_hermite, 6),\n            round(eps_t_linear, 6),\n            round(eps_alpha_hermite, 6),\n            round(eps_alpha_linear, 6),\n            round(eps_E_hermite, 6),\n            round(eps_E_linear, 6),\n        ]\n\n    test_cases = [\n        # (x0, y0, vx0, vy0, tau_p, g, dt)\n        (0.0, 1.0, 1.5, -1.0, 0.2, 9.81, 0.7),\n        (0.0, 0.05, 0.3, -0.2, 0.2, 9.81, 0.1),\n        (0.0, 0.02, 2.0, -0.01, 0.1, 9.81, 0.2),\n        (0.0, 0.1, 0.0, -0.5, 0.02, 9.81, 1.0),\n        (0.0, 0.5, 0.8, -0.5, 5.0, 9.81, 0.3),\n    ]\n\n    results = [compute_errors_for_case(case) for case in test_cases]\n    \n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}