{
    "hands_on_practices": [
        {
            "introduction": "本实践将聚焦于离散相模型中最关键的概念之一：粒子对流体流动的惯性响应。我们将引入粒子弛豫时间 $\\tau_p$，它量化了粒子适应周围流体速度变化的快慢。通过将此时间尺度与流场的特征时间尺度 $\\tau_f$ 进行比较，我们定义了无量纲的斯托克斯数 $St$。本练习  将引导您推导这些量，并应用它们在一个经典的通道流场景中，区分那些紧密跟随流体的粒子（低惯性）和那些显著偏离流线的粒子（高惯性）。",
            "id": "3309849",
            "problem": "将单分散、刚性、球形颗粒的稀疏悬浮液注入到稳定的、由压力驱动的空气平面通道流中。通道的半高为 $H$，空气以整体速度 $U_b$ 流动。在操作条件下，空气的动力粘度为 $\\mu$，密度为 $\\rho_f$。颗粒的材料密度为 $\\rho_p$，直径为 $d_p$。假设以下模型条件：单向耦合（颗粒不影响载体流）、与曳力相比重力和浮力可忽略不计、布朗运动可忽略不计，以及颗粒雷诺数足够小以至于斯托克斯曳力定律有效。\n\n从牛顿第二定律和粘性流体中小球的斯托克斯曳力定律出发，首先用 $\\rho_p$、$d_p$ 和 $\\mu$ 推导出颗粒速度弛豫时间 $\\tau_p$。然后，使用基于通道的特征流体时间尺度 $\\tau_f$ 的对流估计（由特征长度与特征速度之比得到），用 $\\rho_p$、$d_p$、$\\mu$、$H$ 和 $U_b$ 推导出斯托克斯数 $St(d_p)$。\n\n使用这些结果确定当 $St(d_*) = 1$ 时的颗粒直径 $d_*$，该直径区分了弱惯性响应（$St \\ll 1$）和强惯性响应（$St \\gg 1$）。对以下参数计算 $d_*$ 的值：\n- $H = 2.0 \\times 10^{-4}\\,\\mathrm{m}$，\n- $U_b = 5.0\\,\\mathrm{m/s}$，\n- $\\mu = 1.8 \\times 10^{-5}\\,\\mathrm{Pa\\,s}$，\n- $\\rho_f = 1.2\\,\\mathrm{kg/m^3}$（仅供参考），\n- $\\rho_p = 2.5 \\times 10^{3}\\,\\mathrm{kg/m^3}$。\n\n报告：\n1. 您使用的通道对流时间尺度 $\\tau_f$。\n2. 满足 $St(d_*) = 1$ 的临界直径 $d_*$。\n\n以微米为单位表示最终所求的直径，并将您的答案四舍五入到三位有效数字。最终答案必须是 $d_*$ 以微米为单位的单个数值。不要在最终的方框值中包含单位。",
            "solution": "在进行求解之前，对问题陈述的有效性进行严格评估。\n\n### 步骤1：提取已知条件\n-   流体：空气\n-   流动类型：稳定的、由压力驱动的平面通道流\n-   通道半高：$H$\n-   整体速度：$U_b$\n-   空气动力粘度：$\\mu$\n-   空气密度：$\\rho_f$\n-   颗粒：单分散、刚性、球形颗粒的稀疏悬浮液\n-   颗粒材料密度：$\\rho_p$\n-   颗粒直径：$d_p$\n-   假设：\n    1.  单向耦合（颗粒不影响流体流动）。\n    2.  与曳力相比，重力和浮力可忽略不计。\n    3.  布朗运动可忽略不计。\n    4.  颗粒雷诺数足够小，斯托克斯曳力定律有效。\n-   数值：\n    -   $H = 2.0 \\times 10^{-4}\\,\\mathrm{m}$\n    -   $U_b = 5.0\\,\\mathrm{m/s}$\n    -   $\\mu = 1.8 \\times 10^{-5}\\,\\mathrm{Pa\\,s}$\n    -   $\\rho_f = 1.2\\,\\mathrm{kg/m^3}$（仅供参考）\n    -   $\\rho_p = 2.5 \\times 10^{3}\\,\\mathrm{kg/m^3}$\n\n### 步骤2：使用提取的已知条件进行验证\n-   **科学依据：** 该问题牢固地植根于流体动力学和颗粒力学的基本原理，特别是牛顿第二定律和低雷诺数流动的斯托克斯曳力概念。颗粒弛豫时间和斯托克斯数的定义在气溶胶科学和多相流领域是标准概念。\n-   **适定性：** 问题陈述清晰，提供了推导所求量和计算唯一数值答案所需的所有参数和假设。\n-   **客观性：** 语言技术性强、精确，没有任何主观或模棱两可的术语。\n-   **完整性和一致性：** 问题是自洽的。所提供的数值对于小通道中的空气流动和常见的固体颗粒是物理上现实的。不存在矛盾之处。\n\n### 步骤3：结论与行动\n问题被判定为**有效**。将提供完整解答。\n\n颗粒的运动遵循牛顿第二定律，该定律指出，颗粒动量的变化率等于作用在其上的外力之和。对于质量为 $m_p$、速度为 $\\vec{v}_p$ 的颗粒，这表示为：\n$$\nm_p \\frac{d\\vec{v}_p}{dt} = \\sum \\vec{F}_i\n$$\n问题陈述要求忽略重力和浮力，因此唯一考虑的力是曳力 $\\vec{F}_D$。因此，运动方程简化为：\n$$\nm_p \\frac{d\\vec{v}_p}{dt} = \\vec{F}_D\n$$\n颗粒是一个直径为 $d_p$、密度为 $\\rho_p$ 的球体。其质量 $m_p$ 是其密度与体积 $V_p = \\frac{1}{6}\\pi d_p^3$ 的乘积：\n$$\nm_p = \\rho_p \\left( \\frac{1}{6}\\pi d_p^3 \\right)\n$$\n问题指明颗粒雷诺数很小，因此斯托克斯曳力定律适用。作用在以速度 $\\vec{v}_p$ 在速度为 $\\vec{v}_f$ 的流体中运动的球形颗粒上的曳力 $\\vec{F}_D$ 由下式给出：\n$$\n\\vec{F}_D = 3 \\pi \\mu d_p (\\vec{v}_f - \\vec{v}_p)\n$$\n将 $m_p$ 和 $\\vec{F}_D$ 的表达式代入运动方程：\n$$\n\\rho_p \\left( \\frac{1}{6}\\pi d_p^3 \\right) \\frac{d\\vec{v}_p}{dt} = 3 \\pi \\mu d_p (\\vec{v}_f - \\vec{v}_p)\n$$\n为了求出颗粒速度弛豫时间 $\\tau_p$，我们将此方程重新排列成标准形式 $\\frac{d\\vec{v}_p}{dt} = \\frac{1}{\\tau_p}(\\vec{v}_f - \\vec{v}_p)$。\n$$\n\\frac{d\\vec{v}_p}{dt} = \\frac{3 \\pi \\mu d_p}{\\rho_p (\\frac{1}{6}\\pi d_p^3)} (\\vec{v}_f - \\vec{v}_p)\n$$\n简化右侧的系数：\n$$\n\\frac{d\\vec{v}_p}{dt} = \\frac{18 \\pi \\mu d_p}{\\pi \\rho_p d_p^3} (\\vec{v}_f - \\vec{v}_p) = \\frac{18 \\mu}{\\rho_p d_p^2} (\\vec{v}_f - \\vec{v}_p)\n$$\n通过与标准形式比较，颗粒速度弛豫时间 $\\tau_p$ 被确定为：\n$$\n\\tau_p = \\frac{\\rho_p d_p^2}{18 \\mu}\n$$\n接下来，我们确定特征流体时间尺度 $\\tau_f$。问题要求使用通道的特征长度和速度进行对流估计。特征长度是通道半高 $H$，特征速度是整体速度 $U_b$。因此，流体时间尺度为：\n$$\n\\tau_f = \\frac{H}{U_b}\n$$\n斯托克斯数 $St$ 是颗粒弛豫时间与流体时间尺度之比：\n$$\nSt(d_p) = \\frac{\\tau_p}{\\tau_f} = \\frac{\\frac{\\rho_p d_p^2}{18 \\mu}}{\\frac{H}{U_b}} = \\frac{\\rho_p d_p^2 U_b}{18 \\mu H}\n$$\n我们需要找到当斯托克斯数为1时的临界直径 $d_*$，即 $St(d_*) = 1$。\n$$\n1 = \\frac{\\rho_p d_*^2 U_b}{18 \\mu H}\n$$\n解出 $d_*^2$：\n$$\nd_*^2 = \\frac{18 \\mu H}{\\rho_p U_b}\n$$\n取平方根得到临界直径的表达式：\n$$\nd_* = \\sqrt{\\frac{18 \\mu H}{\\rho_p U_b}}\n$$\n现在，我们代入给定的数值来计算 $d_*$：\n-   $\\mu = 1.8 \\times 10^{-5}\\,\\mathrm{Pa\\,s}$\n-   $H = 2.0 \\times 10^{-4}\\,\\mathrm{m}$\n-   $\\rho_p = 2.5 \\times 10^{3}\\,\\mathrm{kg/m^3}$\n-   $U_b = 5.0\\,\\mathrm{m/s}$\n$$\nd_* = \\sqrt{\\frac{18 (1.8 \\times 10^{-5}) (2.0 \\times 10^{-4})}{(2.5 \\times 10^{3}) (5.0)}}\n$$\n$$\nd_* = \\sqrt{\\frac{6.48 \\times 10^{-8}}{1.25 \\times 10^{4}}} = \\sqrt{5.184 \\times 10^{-12}}\\,\\mathrm{m}\n$$\n$$\nd_* = 2.27684... \\times 10^{-6}\\,\\mathrm{m}\n$$\n第一个要求项是通道对流时间尺度 $\\tau_f$：\n$$\n\\tau_f = \\frac{H}{U_b} = \\frac{2.0 \\times 10^{-4}\\,\\mathrm{m}}{5.0\\,\\mathrm{m/s}} = 4.0 \\times 10^{-5}\\,\\mathrm{s}\n$$\n第二个要求项是以微米为单位的临界直径 $d_*$，四舍五入到三位有效数字。由于 $1\\,\\mu\\mathrm{m} = 10^{-6}\\,\\mathrm{m}$：\n$$\nd_* = 2.27684...\\,\\mu\\mathrm{m} \\approx 2.28\\,\\mu\\mathrm{m}\n$$\n作为一致性检查，我们可以验证颗粒雷诺数的假设。颗粒雷诺数为 $Re_p = \\frac{\\rho_f d_p |\\vec{v}_f - \\vec{v}_p|}{\\mu}$。最大滑移速度 $|\\vec{v}_f - \\vec{v}_p|$ 与整体速度 $U_b$ 在同一数量级。使用 $d_*$ 作为颗粒直径：\n$$\nRe_{p, \\text{max}} \\approx \\frac{\\rho_f d_* U_b}{\\mu} = \\frac{(1.2\\,\\mathrm{kg/m^3}) (2.28 \\times 10^{-6}\\,\\mathrm{m}) (5.0\\,\\mathrm{m/s})}{1.8 \\times 10^{-5}\\,\\mathrm{Pa\\,s}} \\approx 0.76\n$$\n由于 $Re_{p, \\text{max}}  1$，对于此颗粒尺寸，使用斯托克斯曳力定律是合理的。",
            "answer": "$$\\boxed{2.28}$$"
        },
        {
            "introduction": "在粒子惯性概念的基础上，我们现在进入离散相能够影响连续相的场景。这种被称为“双向耦合”的现象，对于精确模拟含有大量颗粒的流动至关重要。本练习  将通过对一个含颗粒的管道流应用宏观动量平衡，挑战您分析这样一个系统，从而量化由于与颗粒的动量交换导致的流体平均速度的降低。掌握这一概念对于理解和预测许多工业多相系统的行为至关重要。",
            "id": "3309855",
            "problem": "考虑在直径为 $D$ 的长直圆形管道中，一种不可压缩牛顿流体进行稳定、充分发展的向上流动。该流动由施加的轴向压力梯度 $\\mathrm{d}p/\\mathrm{d}z$（其中 $z$ 向上测量）驱动。密度为 $\\rho_{p}$ 的单分散球形固体颗粒的稀疏悬浮液被夹带在密度为 $\\rho_{f}$、动力粘度为 $\\mu$ 的载体液体中。颗粒体积分数均匀且等于 $\\alpha_{p}$，颗粒间的相互作用可以忽略不计。流动是层流，并且在双向耦合极限下使用离散相模型 (DPM)，其中颗粒与流体交换动量，但不会改变管道几何形状，也不会产生除浮力和重力之外的额外体积力。流体相和颗粒相均处于稳定状态，轴向平均加速度为零，轴向滑移会自行调整，以使每个颗粒的轴向力平衡得到满足。\n\n从应用于各相的牛顿第二定律和流体的横截面控制体动量平衡出发，并使用层流泊肃叶定律将壁面剪切应力与流体的平均轴向速度 $u$ 联系起来，推导载体相平均轴向速度因与颗粒的双向耦合而减小的表达式，该减小量定义为 $\\Delta u \\equiv u_{0} - u$，其中 $u_{0}$ 是在相同施加压力梯度下的单相平均速度，而 $u$ 是存在颗粒时的平均速度。您的推导必须明确识别并平衡流向动量的源和汇，包括重力、壁面剪切和相间动量交换，并且必须在所述假设下与科学现实相符。\n\n使用以下参数值：$D = 0.05$ 米，$\\mu = 1.0 \\times 10^{-3}$ 帕斯卡·秒，$\\rho_{f} = 1000$ 千克/立方米，$\\rho_{p} = 2500$ 千克/立方米，$\\alpha_{p} = 1.0 \\times 10^{-3}$，重力加速度 $g = 9.81$ 米/秒平方。将最终数值答案四舍五入至四位有效数字。速度减小量以米/秒为单位表示。",
            "solution": "该问题被评估为有效，因为它在科学上基于流体力学和多相流的原理，问题提出得当且信息充分，并以客观、正式的语言表述。我们可以开始求解。\n\n目标是推导在相同施加的轴向压力梯度 $\\mathrm{d}p/\\mathrm{d}z$ 下，载体相平均轴向速度的减小量 $\\Delta u \\equiv u_0 - u$ 的表达式，其中 $u_0$ 是单相流的平均速度，$u$ 是两相（液-固）流的平均速度。推导将基于管道的圆柱形控制体的宏观动量平衡。\n\n我们考虑一个长度为 $L$、直径为 $D$ 的圆柱形控制体，其与向上的管道轴线 $z$ 对齐。流动是稳定且充分发展的，因此控制体内动量没有变化，并且其两端没有净动量通量。因此，作用在控制体上沿轴向的所有外力之和必须为零。\n\n**1. 单相流（基准情况）**\n\n对于密度为 $\\rho_f$、粘度为 $\\mu$ 的液体的单相流，作用在控制体上的力有：\n1.  压力：压力沿长度 $L$ 下降。净力为 $(p_z - p_{z+L})A$，其中 $A = \\pi D^2/4$ 是横截面积。对于充分发展的流动，这简化为 $(-\\mathrm{d}p/\\mathrm{d}z) L A$。\n2.  重力：控制体中流体的重量，向下作用，为 $-m_f g = -\\rho_f (AL) g$。\n3.  壁面剪切力：壁面上的剪切应力 $\\tau_{w,0}$ 对流体施加一个阻力。该力作用于表面积 $\\pi D L$ 上，因此力为 $-\\tau_{w,0} (\\pi D L)$。\n\n轴向动量平衡为：\n$$ \\left(-\\frac{\\mathrm{d}p}{\\mathrm{d}z}\\right) L A - \\rho_f g A L - \\tau_{w,0} \\pi D L = 0 $$\n除以体积 $AL = (\\pi D^2/4)L$：\n$$ -\\frac{\\mathrm{d}p}{\\mathrm{d}z} - \\rho_f g - \\frac{\\tau_{w,0} \\pi D}{\\pi D^2/4} = 0 $$\n$$ -\\left(\\frac{\\mathrm{d}p}{\\mathrm{d}z} + \\rho_f g\\right) - \\frac{4\\tau_{w,0}}{D} = 0 $$\n对于层流泊肃叶流动，壁面剪切应力通过 $\\tau_{w,0} = 8\\mu u_0/D$ 与平均速度 $u_0$ 相关。代入此式可得：\n$$ -\\left(\\frac{\\mathrm{d}p}{\\mathrm{d}z} + \\rho_f g\\right) - \\frac{4}{D}\\left(\\frac{8\\mu u_0}{D}\\right) = 0 $$\n$$ \\frac{32\\mu u_0}{D^2} = -\\left(\\frac{\\mathrm{d}p}{\\mathrm{d}z} + \\rho_f g\\right) $$\n该方程将单相平均速度 $u_0$ 与施加的压力梯度和流体性质联系起来。项 $-(\\mathrm{d}p/\\mathrm{d}z + \\rho_f g)$ 表示克服粘性摩擦的有效驱动压力梯度。\n\n**2. 两相流**\n\n现在，我们考虑具有均匀颗粒体积分数 $\\alpha_p$ 的两相流。我们在相同的控制体内对混合物（流体+颗粒）进行动量平衡。\n作用在混合物上的力有：\n1.  压力：同样外部施加的压力梯度产生净力 $(-\\mathrm{d}p/\\mathrm{d}z) L A$。\n2.  重力：控制体中混合物的总重量是流体相和颗粒相重量的总和。流体的体积是 $(1-\\alpha_p)AL$，颗粒的体积是 $\\alpha_p AL$。总重力为 $-[(1-\\alpha_p)\\rho_f + \\alpha_p\\rho_p] g A L$。\n3.  壁面剪切力：壁面剪切应力 $\\tau_w$ 仅作用于流体相。问题陈述要求使用层流泊肃叶定律，该定律将壁面剪切与流体的平均速度 $u$ 联系起来。因此，我们假设 $\\tau_w = 8\\mu u/D$。产生的力为 $-\\tau_w (\\pi D L)$。\n\n混合物的轴向动量平衡为：\n$$ \\left(-\\frac{\\mathrm{d}p}{\\mathrm{d}z}\\right) L A - [(1-\\alpha_p)\\rho_f + \\alpha_p\\rho_p] g A L - \\tau_w \\pi D L = 0 $$\n混合物密度的项可以重写为 $\\rho_f + \\alpha_p(\\rho_p - \\rho_f)$。将方程除以 $AL$：\n$$ -\\frac{\\mathrm{d}p}{\\mathrm{d}z} - [\\rho_f + \\alpha_p(\\rho_p - \\rho_f)] g - \\frac{\\tau_w \\pi D}{A} = 0 $$\n$$ -\\frac{\\mathrm{d}p}{\\mathrm{d}z} - \\rho_f g - \\alpha_p(\\rho_p - \\rho_f)g - \\frac{4\\tau_w}{D} = 0 $$\n代入壁面剪切应力的关系式 $\\tau_w = 8\\mu u/D$：\n$$ -\\left(\\frac{\\mathrm{d}p}{\\mathrm{d}z} + \\rho_f g\\right) - \\alpha_p(\\rho_p - \\rho_f)g - \\frac{32\\mu u}{D^2} = 0 $$\n根据单相流分析，项 $-(\\mathrm{d}p/\\mathrm{d}z + \\rho_f g)$ 等于 $32\\mu u_0/D^2$。将此代入两相流方程：\n$$ \\frac{32\\mu u_0}{D^2} - \\alpha_p(\\rho_p - \\rho_f)g - \\frac{32\\mu u}{D^2} = 0 $$\n\n**3. 速度减小量 $\\Delta u$ 的推导**\n\n重新整理方程以求解速度减小量 $\\Delta u = u_0 - u$：\n$$ \\frac{32\\mu}{D^2}(u_0 - u) = \\alpha_p(\\rho_p - \\rho_f)g $$\n$$ \\frac{32\\mu}{D^2}\\Delta u = \\alpha_p(\\rho_p - \\rho_f)g $$\n求解 $\\Delta u$：\n$$ \\Delta u = \\frac{D^2 g}{32 \\mu} \\alpha_p (\\rho_p - \\rho_f) $$\n此表达式表示由于悬浮颗粒产生的动量汇导致的平均流体速度的减小。项 $\\alpha_p(\\rho_p - \\rho_f)g$ 是单位体积颗粒相的浮重，它构成了一个流动必须克服的额外体积力。对于固定的压力梯度，这个额外的负载会导致平均流体速度降低。\n\n**4. 数值计算**\n\n我们将给定值代入推导出的 $\\Delta u$ 表达式中：\n- $D = 0.05$ 米\n- $g = 9.81$ 米/秒$^2$\n- $\\mu = 1.0 \\times 10^{-3}$ 帕·秒\n- $\\alpha_p = 1.0 \\times 10^{-3}$\n- $\\rho_p = 2500$ 千克/米$^3$\n- $\\rho_f = 1000$ 千克/米$^3$\n\n首先，我们计算各项：\n- $D^2 = (0.05 \\text{ m})^2 = 0.0025$ 米$^2$\n- $\\rho_p - \\rho_f = 2500 - 1000 = 1500$ 千克/米$^3$\n- $32\\mu = 32 \\times (1.0 \\times 10^{-3} \\text{ 帕·秒}) = 0.032$ 帕·秒\n\n现在，我们计算 $\\Delta u$：\n$$ \\Delta u = \\frac{(0.0025 \\text{ m}^2) (9.81 \\text{ m/s}^2)}{0.032 \\text{ Pa·s}} (1.0 \\times 10^{-3}) (1500 \\text{ kg/m}^3) $$\n$$ \\Delta u = \\frac{0.024525}{0.032} \\times (1.0 \\times 10^{-3}) \\times 1500 \\text{ m/s} $$\n$$ \\Delta u = 0.76640625 \\times 1.5 \\text{ m/s} $$\n$$ \\Delta u = 1.149609375 \\text{ m/s} $$\n按要求四舍五入到四位有效数字：\n$$ \\Delta u \\approx 1.150 \\text{ m/s} $$\n由于颗粒的存在，载体相平均轴向速度的减小量为 $1.150$ m/s。",
            "answer": "$$\\boxed{1.150}$$"
        },
        {
            "introduction": "在探究了粒子运动和耦合的物理原理之后，我们转向计算实现所面临的实际挑战。数值模拟是离散相模型中不可或缺的工具，但我们如何确定代码是正确的呢？本实践将介绍“制造解方法”（Method of Manufactured Solutions, MMS），这是一种用于代码验证的严谨标准流程。在本练习  中，您将从头开始实现一个完整的 MMS 测试案例，推导一个人工源项，并测试数值积分器的收敛阶，以确保您的粒子追踪代码既准确又可靠。",
            "id": "3309830",
            "problem": "我们要求您为一个用于离散相建模和粒子追踪的拉格朗日点粒子模型，实现一个制造解验证（verification-by-manufactured-solutions）程序。目标是构建一个合成的粒子轨迹和一个光滑的不可压缩载体速度场，推导出一个制造强迫项，使得所选轨迹成为粒子运动方程的精确解，然后设计数值测试来验证时间和空间上的精度阶。\n\n从第一性原理出发。设一个质量为 $m$ 的粒子在二维域中演化，其运动遵循牛顿第二定律，并受到线性的斯托克斯（Stokes）型曳力作用，其中载体流体速度为 $u(x,t)$，粒子状态为 $(x(t),v(t)) \\in \\mathbb{R}^{2} \\times \\mathbb{R}^{2}$。基本控制方程为：\n$$\n\\frac{dx}{dt} = v, \\qquad m \\frac{dv}{dt} = c_{d}\\,\\bigl(u(x,t) - v\\bigr) + F(x,t).\n$$\n这里，$c_{d}$ 是曳力系数，$F(x,t)$ 是一个待设计的外部施加力密度（制造强迫项）。您将通过规定一个保持在周期性盒子内的精确粒子轨迹 $x^{\\star}(t)$ 来构造一个制造解，然后使用上述方程确定相应的 $F(x,t)$，使得 $(x^{\\star}(t),v^{\\star}(t))$（其中 $v^{\\star}(t) = \\frac{d x^{\\star}}{dt}$）对所有 $t$ 都满足这些方程。\n\n请使用以下科学上一致的设置：\n\n- 选择一个边长为 $L$ 的周期性正方形域，其中 $L = 1\\,\\mathrm{m}$，并在两个空间方向上施加周期性。三角函数中出现的所有角度都应以弧度解释。\n\n- 选择一个以泰勒-格林（Taylor–Green）涡为模型的光滑不可压缩载体流场：\n$$\nu_{x}(x,y,t) = U\\,\\sin(k x)\\,\\cos(k y)\\,\\cos(\\sigma t), \\quad\nu_{y}(x,y,t) = -U\\,\\cos(k x)\\,\\sin(k y)\\,\\cos(\\sigma t),\n$$\n其中 $U = 0.5\\,\\mathrm{m/s}$，$k = \\frac{2\\pi}{L}$，以及 $\\sigma = 1.0\\,\\mathrm{s}^{-1}$。三角函数的参数是无量纲的，因为 $k$ 的单位是 $\\mathrm{m}^{-1}$，空间坐标的单位是 $\\mathrm{m}$，而 $\\sigma t$ 的单位是弧度。\n\n- 选择一个形式如下的制造粒子轨迹：\n$$\nx^{\\star}(t) =\n\\begin{bmatrix}\nx_{0} + A \\cos(\\omega t) \\\\\ny_{0} + A \\sin(\\omega t)\n\\end{bmatrix},\n\\qquad\nv^{\\star}(t) = \\frac{d x^{\\star}}{dt} =\n\\begin{bmatrix}\n- A \\omega \\sin(\\omega t) \\\\\nA \\omega \\cos(\\omega t)\n\\end{bmatrix},\n$$\n其中 $x_{0} = 0.4\\,L$，$y_{0} = 0.6\\,L$，$A = 0.1\\,L$，以及 $\\omega = 1.3\\,\\mathrm{s}^{-1}$。令 $a^{\\star}(t) = \\frac{d v^{\\star}}{dt}$ 表示精确加速度。粒子始终严格保持在周期域内部。\n\n- 考虑粒子质量 $m = 10^{-3}\\,\\mathrm{kg}$ 和基准曳力系数 $c_{d} = 5\\times 10^{-3}\\,\\mathrm{kg/s}$。\n\n您的任务是：\n\n$1.$ 从基本方程出发，推导制造强迫项 $F(x,t)$，以保证 $(x^{\\star}(t),v^{\\star}(t))$ 精确满足粒子方程。您的推导必须从给定的牛顿第二定律开始，并且只使用核心定义（$\\frac{dx}{dt} = v$，$v^{\\star} = \\frac{dx^{\\star}}{dt}$）和直接代入。除了已指定的线性曳力外，不要引入任何经验性的封闭关系。强迫项必须是时间和已知量的函数，所有物理单位与国际单位制（SI）保持一致。\n\n$2.$ 为粒子常微分方程实现一个时间积分器，包含两种变体：一个显式二阶龙格-库塔（Runge–Kutta）方法（显式中点法）和一个显式四阶龙格-库塔方法。两者都必须以大小为 $\\Delta t$ 的步长进行积分，并相应地更新状态 $(x,v)$。在评估载体场 $u(x,t)$ 时，考虑两种情景：\n- 时间精度情景：在粒子位置 $x$ 和时间 $t$ 处精确计算解析的 $u(x,t)$。\n- 空间精度情景：在 $[0,L)\\times[0,L)$ 上的一个均匀 $N \\times N$ 网格上，通过双线性插值来近似 $u(x,t)$，并采用周期性环绕处理。网格上的值取自当前时刻网格节点上的精确解析 $u$ 值。\n\n$3.$ 设计并运行以下数值测试套件。在所有测试中，使用精确初始条件 $x(0) = x^{\\star}(0)$ 和 $v(0) = v^{\\star}(0)$ 初始化粒子，积分到 $T=1.0\\,\\mathrm{s}$，并以位置差的欧几里得范数 $\\|x_{\\mathrm{num}}(T) - x^{\\star}(T)\\|_{2}$（单位为 $\\mathrm{m}$）来衡量误差。所有角度仅使用弧度。\n\n- 测试 A（时间精度，四阶）：使用解析的 $u(x,t)$ 和任务 1 中得到的制造强迫项。使用显式四阶龙格-库塔方法，对一系列时间步长 $\\Delta t \\in \\{10^{-2}, 5\\times10^{-3}, 2.5\\times 10^{-3}\\}\\,\\mathrm{s}$ 进行积分。通过连续的成对结果计算观察到的阶数 $p$：\n$$\np = \\frac{\\log(e_{1}/e_{2})}{\\log(\\Delta t_{1}/\\Delta t_{2})},\n$$\n其中 $e_{i}$ 是相应时间步长下的终端位置误差。如果两个连续的观察阶数都至少为 $3.8$，则测试通过。\n\n- 测试 B（时间精度，二阶）：重复测试 A，但使用显式二阶龙格-库塔方法。如果两个连续的观察阶数都至少为 $1.8$，则测试通过。\n\n- 测试 C（通过双线性插值的空间精度）：使用显式四阶龙格-库塔方法，并采用一个非常小的时间步长 $\\Delta t = 2\\times 10^{-4}\\,\\mathrm{s}$，以使时间误差可以忽略不计。用其在均匀网格（$N \\in \\{16,32,64\\}$）上的双线性插值替换解析的 $u(x,t)$。根据终端位置误差计算观察到的空间阶数 $q$，$q = \\frac{\\log(E_{1}/E_{2})}{\\log(h_{1}/h_{2})}$，其中 $h = L/N$。如果两个连续的观察阶数都至少为 $1.8$，则测试通过。\n\n- 测试 D（曳力消失的边缘情况）：设置 $c_{d} = 0$，并使用解析的 $u(x,t)$。根据任务 1，推导对应于 $c_{d}=0$ 的制造强迫项。使用显式四阶龙格-库塔方法和 $\\Delta t = 10^{-3}\\,\\mathrm{s}$ 进行积分。如果终端位置误差小于 $10^{-8}\\,\\mathrm{m}$，则测试通过。\n\n$4.$ 您的程序必须生成单行输出，其中包含测试 A-D 的结果，形式为一个用方括号括起来的逗号分隔的布尔值列表，顺序为 $[\\text{A},\\text{B},\\text{C},\\text{D}]$。例如，一个有效的输出可能看起来像 $[\\text{True},\\text{True},\\text{True},\\text{True}]$。\n\n所有物理量必须使用国际单位制（米、秒、千克）处理，所有角度必须是弧度。最终输出是布尔值，它们是无量纲的。\n\n提供一个完整的、可运行的程序，该程序能符号化地执行任务 1 中的推导以定义制造强迫项，实现积分器，使用指定的参数运行四个测试，并以所描述的精确格式打印出所需的单行输出。不允许用户输入，程序必须是自包含的。",
            "solution": "该问题要求使用制造解方法（MMS）为一个拉格朗日粒子追踪模型实现并执行一个验证套件。该过程涉及推导一个合成的强迫项，使选定的解析轨迹成为控制方程的精确解，实现求解这些方程的数值方案，并运行测试以验证预期的精度阶。\n\n粒子的状态由其位置 $x(t) \\in \\mathbb{R}^2$ 和速度 $v(t) \\in \\mathbb{R}^2$ 描述。在牛顿第二定律和线性斯托克斯曳力作用下的控制方程如下：\n$$\n\\frac{dx}{dt} = v\n$$\n$$\nm \\frac{dv}{dt} = c_{d}\\,\\bigl(u(x,t) - v\\bigr) + F(x,t)\n$$\n其中 $m$ 是粒子质量，$c_{d}$ 是曳力系数，$u(x,t)$ 是载体流体速度，而 $F(x,t)$ 是待确定的制造强迫项。所有量均采用国际单位制，角度以弧度为单位。\n\n**1. 制造强迫项的推导**\n\nMMS 的核心原理是先假设一个精确的解析解，然后推导出使其满足控制方程所必需的源项或强迫项。我们给定制造的粒子轨迹 $x^{\\star}(t)$ 及其对应的速度 $v^{\\star}(t) = \\frac{dx^{\\star}}{dt}$ 和加速度 $a^{\\star}(t) = \\frac{dv^{\\star}}{dt}$。\n$$\nx^{\\star}(t) =\n\\begin{bmatrix}\nx_{0} + A \\cos(\\omega t) \\\\\ny_{0} + A \\sin(\\omega t)\n\\end{bmatrix}\n$$\n$$\nv^{\\star}(t) =\n\\begin{bmatrix}\n- A \\omega \\sin(\\omega t) \\\\\nA \\omega \\cos(\\omega t)\n\\end{bmatrix}\n$$\n$$\na^{\\star}(t) =\n\\begin{bmatrix}\n- A \\omega^2 \\cos(\\omega t) \\\\\n- A \\omega^2 \\sin(\\omega t)\n\\end{bmatrix}\n$$\n为使该轨迹成为一个精确解，当粒子处于位置 $x^{\\star}(t)$ 且速度为 $v^{\\star}(t)$ 时，运动方程必须在所有时刻 $t$ 都得到满足。将 $(x^{\\star}(t), v^{\\star}(t), a^{\\star}(t))$ 代入第二个控制方程可得：\n$$\nm a^{\\star}(t) = c_{d}\\,\\bigl(u(x^{\\star}(t),t) - v^{\\star}(t)\\bigr) + F(x^{\\star}(t),t)\n$$\n制造强迫项 $F(x^{\\star}(t),t)$ 是平衡此方程所需的项。我们可以直接求解它。为了模拟的目的，我们只需要沿已知轨迹计算这个力，因此我们将其定义为时间的函数，$F(t) \\equiv F(x^{\\star}(t),t)$：\n$$\nF(t) = m a^{\\star}(t) - c_{d}\\,\\bigl(u(x^{\\star}(t),t) - v^{\\star}(t)\\bigr)\n$$\n此方程提供了强迫向量的解析表达式。其分量 $F_x(t)$ 和 $F_y(t)$ 依赖于已知的函数 $x^{\\star}(t)$、$v^{\\star}(t)$、$a^{\\star}(t)$ 以及给定的载体速度场 $u(x,y,t)$。对于测试 D 中 $c_d = 0\\,\\mathrm{kg/s}$ 的特殊情况，强迫项简化为 $F(t) = m a^{\\star}(t)$，正如预期。\n\n**2. 数值实现**\n\n粒子的运动由一个包含四个一阶常微分方程（ODE）的系统控制，该系统针对状态向量 $Y(t) = [x(t), y(t), v_x(t), v_y(t)]^T$。该系统可写为 $\\frac{dY}{dt} = G(Y, t)$，其中：\n$$\nG(Y, t) = \\begin{pmatrix} v_x \\\\ v_y \\\\ \\frac{1}{m} [c_d(u_x(x,y,t) - v_x) + F_x(t)] \\\\ \\frac{1}{m} [c_d(u_y(x,y,t) - v_y) + F_y(t)] \\end{pmatrix}\n$$\n请注意，制造强迫项 $F(t)$ 仅是时间的函数，并且是使用*解析*解来计算的，而不是数值状态 $Y$。这是 MMS 的一个关键方面。\n\n我们实现了两种显式龙格-库塔（Runge-Kutta）方法来对该系统从 $t=0$ 积分到 $t=T$：\n\n*   **显式二阶龙格-库塔（中点法）**：\n    $$\n    k_1 = G(Y_n, t_n)\n    $$\n    $$\n    k_2 = G(Y_n + \\frac{\\Delta t}{2} k_1, t_n + \\frac{\\Delta t}{2})\n    $$\n    $$\n    Y_{n+1} = Y_n + \\Delta t \\, k_2\n    $$\n    此方法在时间上具有理论上的二阶精度，即误差与 $(\\Delta t)^2$ 成正比。\n\n*   **经典四阶龙格-库塔（RK4）**：\n    $$\n    k_1 = G(Y_n, t_n)\n    $$\n    $$\n    k_2 = G(Y_n + \\frac{\\Delta t}{2} k_1, t_n + \\frac{\\Delta t}{2})\n    $$\n    $$\n    k_3 = G(Y_n + \\frac{\\Delta t}{2} k_2, t_n + \\frac{\\Delta t}{2})\n    $$\n    $$\n    k_4 = G(Y_n + \\Delta t \\, k_3, t_n + \\Delta t)\n    $$\n    $$\n    Y_{n+1} = Y_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n    $$\n    此方法在时间上具有理论上的四阶精度，即误差 $\\propto (\\Delta t)^4$。\n\n在函数 $G(Y,t)$ 中对载体速度 $u(x,t)$ 的求值有两种处理方式：\n1.  **解析求值**：对于时间精度测试，函数 $u(x,y,t)$ 在当前的数值粒子位置 $(x,y)$ 和时间 $t$ 处，使用其给定的解析公式直接计算。\n2.  **双线性插值**：对于空间精度测试，首先在当前时间 $t$ 于域 $[0,L) \\times [0,L)$ 上的一个均匀 $N \\times N$ 网格上计算载体速度。然后，使用周围四个网格节点的值，通过双线性插值来近似任意粒子位置 $(x_p, y_p)$ 处的速度。该域是周期性的，因此位置和网格索引使用模运算处理。网格间距为 $h=L/N$，双线性插值的理论误差与 $h^2$ 成正比。\n\n**3. 验证测试套件**\n\n通过四个测试来验证实现，数值解从精确的初始条件 $x(0) = x^{\\star}(0)$ 和 $v(0) = v^{\\star}(0)$ 开始。误差以最终时间 $T=1.0\\,\\mathrm{s}$ 时数值位置与精确位置之差的欧几里得范数来度量，记为 $e = \\|x_{\\mathrm{num}}(T) - x^{\\star}(T)\\|_{2}$。观察到的收敛阶 $p$ 是根据使用分辨率 $r_1$ 和 $r_2$（其中 $r$ 是 $\\Delta t$ 或 $h$）得到的误差 $e_1$ 和 $e_2$ 计算得出的，公式为 $p = \\log(e_1/e_2) / \\log(r_1/r_2)$。\n\n*   **测试 A（时间精度，RK4）**：验证 RK4 积分器的时间四阶精度。观察到的阶数 $p$ 预期接近 4。如果对于两次连续的 $\\Delta t$ 细化，观察阶数 $p \\ge 3.8$，则测试通过。\n*   **测试 B（时间精度，RK2）**：验证 RK2 积分器的时间二阶精度。观察到的阶数 $p$ 预期接近 2。如果对于两次连续的 $\\Delta t$ 细化，观察阶数 $p \\ge 1.8$，则测试通过。\n*   **测试 C（空间精度，双线性插值）**：验证双线性插值方案的空间二阶精度。使用一个小的 $\\Delta t$ 以使时间误差可以忽略不计。观察到的空间阶数 $q$ 预期接近 2。如果对于两次连续的网格细化，观察阶数 $q \\ge 1.8$，则测试通过。\n*   **测试 D（边缘情况，曳力消失）**：测试当 $c_d = 0$ 时实现的正确性。在此极限下，粒子运动与流体无关。使用小时间步长的 RK4 积分器应该能以非常高的精度恢复精确轨迹。如果最终位置误差低于 $10^{-8}\\,\\mathrm{m}$，则测试通过。\n\n通过这些测试有力地证明了代码正确地实现了粒子模型的物理原理和数值方案。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs a verification-by-manufactured-solutions procedure\n    for a Lagrangian point-particle model.\n    \"\"\"\n\n    # --- Problem Constants (SI Units) ---\n    L = 1.0  # Domain side length [m]\n    m = 1.0e-3  # Particle mass [kg]\n    cd_base = 5.0e-3  # Baseline drag coefficient [kg/s]\n    U = 0.5  # Carrier velocity amplitude [m/s]\n    k = 2.0 * np.pi / L  # Wavenumber [rad/m]\n    sigma = 1.0  # Carrier flow frequency [rad/s]\n    x0 = 0.4 * L  # Trajectory center x [m]\n    y0 = 0.6 * L  # Trajectory center y [m]\n    A = 0.1 * L  # Trajectory amplitude [m]\n    omega = 1.3  # Trajectory frequency [rad/s]\n    T_final = 1.0  # Final integration time [s]\n\n    # --- Task 1: Analytical and Manufactured Functions ---\n\n    def x_star(t):\n        \"\"\"Exact manufactured particle position.\"\"\"\n        return np.array([x0 + A * np.cos(omega * t), y0 + A * np.sin(omega * t)])\n\n    def v_star(t):\n        \"\"\"Exact manufactured particle velocity.\"\"\"\n        return np.array([-A * omega * np.sin(omega * t), A * omega * np.cos(omega * t)])\n\n    def a_star(t):\n        \"\"\"Exact manufactured particle acceleration.\"\"\"\n        return np.array([-A * omega**2 * np.cos(omega * t), -A * omega**2 * np.sin(omega * t)])\n\n    def u_analytical(pos, t):\n        \"\"\"Analytical carrier velocity field (Taylor-Green vortex).\"\"\"\n        x_pos, y_pos = pos\n        ux = U * np.sin(k * x_pos) * np.cos(k * y_pos) * np.cos(sigma * t)\n        uy = -U * np.cos(k * x_pos) * np.sin(k * y_pos) * np.cos(sigma * t)\n        return np.array([ux, uy])\n\n    def F_manufactured(t, c_d):\n        \"\"\"Manufactured forcing term, a function of time.\"\"\"\n        pos_s, vel_s, acc_s = x_star(t), v_star(t), a_star(t)\n        u_val_at_star = u_analytical(pos_s, t)\n        force = m * acc_s - c_d * (u_val_at_star - vel_s)\n        return force\n\n    # --- Task 2: Integrators and Interpolation ---\n\n    def ode_rhs(state, t, c_d, u_func, F_func):\n        \"\"\"Right-hand side of the particle's ODE system.\"\"\"\n        pos, vel = state[:2], state[2:]\n        pos_periodic = pos % L\n        \n        u_val = u_func(pos_periodic, t)\n        F_val = F_func(t, c_d)\n        \n        d_pos_dt = vel\n        d_vel_dt = (c_d * (u_val - vel) + F_val) / m\n        return np.concatenate([d_pos_dt, d_vel_dt])\n\n    def rk2_step(state, t, dt, c_d, u_func, F_func):\n        \"\"\"A single step using the explicit second-order RK (midpoint) method.\"\"\"\n        k1 = ode_rhs(state, t, c_d, u_func, F_func)\n        state_mid = state + 0.5 * dt * k1\n        t_mid = t + 0.5 * dt\n        k2 = ode_rhs(state_mid, t_mid, c_d, u_func, F_func)\n        return state + dt * k2\n\n    def rk4_step(state, t, dt, c_d, u_func, F_func):\n        \"\"\"A single step using the classic fourth-order RK method.\"\"\"\n        t_mid, t_end = t + 0.5 * dt, t + dt\n        k1 = ode_rhs(state, t, c_d, u_func, F_func)\n        k2 = ode_rhs(state + 0.5 * dt * k1, t_mid, c_d, u_func, F_func)\n        k3 = ode_rhs(state + 0.5 * dt * k2, t_mid, c_d, u_func, F_func)\n        k4 = ode_rhs(state + dt * k3, t_end, c_d, u_func, F_func)\n        return state + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def u_bilinear_interp_factory(N):\n        \"\"\"Factory for creating a bilinear interpolation function for a given grid size N.\"\"\"\n        h = L / N\n        x_nodes = np.linspace(0, L, N, endpoint=False)\n        y_nodes = np.linspace(0, L, N, endpoint=False)\n        \n        def u_interp(pos, t):\n            px, py = pos[0], pos[1]\n            i, j = int(px / h), int(py / h)\n            \n            xi, eta = (px - i * h) / h, (py - j * h) / h\n            \n            ip1, jp1 = (i + 1) % N, (j + 1) % N\n            \n            u00 = u_analytical(np.array([x_nodes[i], y_nodes[j]]), t)\n            u10 = u_analytical(np.array([x_nodes[ip1], y_nodes[j]]), t)\n            u01 = u_analytical(np.array([x_nodes[i], y_nodes[jp1]]), t)\n            u11 = u_analytical(np.array([x_nodes[ip1], y_nodes[jp1]]), t)\n            \n            return (1-xi)*(1-eta)*u00 + xi*(1-eta)*u10 + (1-xi)*eta*u01 + xi*eta*u11\n        \n        return u_interp\n\n    def run_simulation(dt, integrator_step, c_d, u_func, F_func):\n        \"\"\"Drives a single particle simulation and returns the final position error.\"\"\"\n        t = 0.0\n        state = np.concatenate([x_star(0), v_star(0)])\n        \n        num_steps = int(np.ceil(T_final / dt))\n        actual_dt = T_final / num_steps\n\n        for _ in range(num_steps):\n            state = integrator_step(state, t, actual_dt, c_d, u_func, F_func)\n            t += actual_dt\n            \n        pos_num = state[:2]\n        pos_exact = x_star(T_final)\n        return np.linalg.norm(pos_num - pos_exact)\n\n    def get_orders(errors, ratios):\n        \"\"\"Computes observed orders of convergence.\"\"\"\n        return [np.log(errors[i] / errors[i+1]) / np.log(ratios[i]) for i in range(len(errors) - 1)]\n\n    # --- Task 3: Numerical Tests ---\n\n    def run_test_A():\n        \"\"\"Test A: Temporal accuracy, fourth order (RK4).\"\"\"\n        dts = [1.0e-2, 5.0e-3, 2.5e-3]\n        errors = [run_simulation(dt, rk4_step, cd_base, u_analytical, F_manufactured) for dt in dts]\n        dt_ratios = [dts[0]/dts[1], dts[1]/dts[2]]\n        orders = get_orders(errors, dt_ratios)\n        return all(p = 3.8 for p in orders)\n\n    def run_test_B():\n        \"\"\"Test B: Temporal accuracy, second order (RK2).\"\"\"\n        dts = [1.0e-2, 5.0e-3, 2.5e-3]\n        errors = [run_simulation(dt, rk2_step, cd_base, u_analytical, F_manufactured) for dt in dts]\n        dt_ratios = [dts[0]/dts[1], dts[1]/dts[2]]\n        orders = get_orders(errors, dt_ratios)\n        return all(p = 1.8 for p in orders)\n\n    def run_test_C():\n        \"\"\"Test C: Spatial accuracy, bilinear interpolation.\"\"\"\n        dt_small = 2.0e-4\n        Ns = [16, 32, 64]\n        errors = []\n        for N in Ns:\n            u_func = u_bilinear_interp_factory(N)\n            errors.append(run_simulation(dt_small, rk4_step, cd_base, u_func, F_manufactured))\n\n        h_values = [L/N for N in Ns]\n        h_ratios = [h_values[0]/h_values[1], h_values[1]/h_values[2]]\n        orders = get_orders(errors, h_ratios)\n        return all(q = 1.8 for q in orders)\n\n    def run_test_D():\n        \"\"\"Test D: Edge case with vanishing drag.\"\"\"\n        dt = 1.0e-3\n        cd_zero = 0.0\n        error = run_simulation(dt, rk4_step, cd_zero, u_analytical, F_manufactured)\n        return error  1.0e-8\n\n    # --- Task 4: Final Output ---\n    results = [\n        run_test_A(),\n        run_test_B(),\n        run_test_C(),\n        run_test_D(),\n    ]\n\n    # Convert boolean results to strings \"True\" or \"False\"\n    results_str = [str(res) for res in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}