{
    "hands_on_practices": [
        {
            "introduction": "Understanding a constitutive model begins with analyzing its predictions in canonical flows. This first exercise involves a fundamental analytical derivation of the stress tensor for an Oldroyd-B fluid in steady simple shear flow, allowing you to directly uncover the model's characteristic predictions for normal stress differences (). This pencil-and-paper task is essential for building physical intuition before tackling more complex computational problems.",
            "id": "3388262",
            "problem": "Consider a homogeneous, incompressible viscoelastic fluid modeled by the Oldroyd–B constitutive framework in a simple shear flow. The velocity field is given by $\\boldsymbol{v} = (\\dot{\\gamma} y,\\, 0,\\, 0)$, where $\\dot{\\gamma}$ is a constant shear rate. The Oldroyd–B fluid consists of a Newtonian solvent of viscosity $\\eta_{s}$ and a polymeric contribution described by Hookean dumbbells with relaxation time $\\lambda$ and polymer viscosity $\\eta_{p}$. The total extra stress is $\\boldsymbol{\\tau} = \\boldsymbol{\\tau}_{s} + \\boldsymbol{\\tau}_{p}$, where the solvent stress is $\\boldsymbol{\\tau}_{s} = 2 \\eta_{s} \\boldsymbol{D}$ with $\\boldsymbol{D} = \\frac{1}{2}\\left( \\nabla \\boldsymbol{v} + (\\nabla \\boldsymbol{v})^{\\top} \\right)$, and the polymer stress is related to the polymer conformation tensor $\\boldsymbol{C}$ via $\\boldsymbol{\\tau}_{p} = \\frac{\\eta_{p}}{\\lambda}(\\boldsymbol{C} - \\boldsymbol{I})$. The evolution of $\\boldsymbol{C}$ is governed by the upper-convected equation\n$$\n\\frac{\\partial \\boldsymbol{C}}{\\partial t} + \\boldsymbol{v} \\cdot \\nabla \\boldsymbol{C} - \\nabla \\boldsymbol{v} \\cdot \\boldsymbol{C} - \\boldsymbol{C} \\cdot (\\nabla \\boldsymbol{v})^{\\top} = -\\frac{1}{\\lambda}(\\boldsymbol{C} - \\boldsymbol{I}),\n$$\nwith $\\boldsymbol{I}$ the identity tensor. In steady, homogeneous simple shear, define the first and second normal stress differences as $N_{1} = \\tau_{xx} - \\tau_{yy}$ and $N_{2} = \\tau_{yy} - \\tau_{zz}$. Starting from the governing equations provided, derive closed-form expressions for $N_{1}$ and $N_{2}$ for the Oldroyd–B fluid in terms of $\\eta_{s}$, $\\eta_{p}$, $\\lambda$, and $\\dot{\\gamma}$, making clear any assumptions you use. Your final answer must be a single analytical expression or a row matrix containing $N_{1}$ and $N_{2}$. No rounding is required, and you should express the answer without units inside the final box. If you provide both $N_{1}$ and $N_{2}$, express them as a row matrix in the order $\\left(N_{1},\\, N_{2}\\right)$.",
            "solution": "The problem requires the derivation of the first and second normal stress differences, $N_{1}$ and $N_{2}$, for an Oldroyd–B fluid in steady, homogeneous simple shear flow. The derivation proceeds from the fundamental equations provided.\n\nFirst, we establish the kinematic tensors for the given simple shear flow. The velocity field is $\\boldsymbol{v} = (\\dot{\\gamma} y,\\, 0,\\, 0)$, where $\\dot{\\gamma}$ is the constant shear rate. The velocity gradient tensor, $\\nabla \\boldsymbol{v}$, is given in Cartesian coordinates by:\n$$\n\\nabla \\boldsymbol{v} = \n\\begin{pmatrix} \n\\frac{\\partial v_x}{\\partial x} & \\frac{\\partial v_x}{\\partial y} & \\frac{\\partial v_x}{\\partial z} \\\\\n\\frac{\\partial v_y}{\\partial x} & \\frac{\\partial v_y}{\\partial y} & \\frac{\\partial v_y}{\\partial z} \\\\\n\\frac{\\partial v_z}{\\partial x} & \\frac{\\partial v_z}{\\partial y} & \\frac{\\partial v_z}{\\partial z}\n\\end{pmatrix}\n= \n\\begin{pmatrix} \n0 & \\dot{\\gamma} & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n$$\nThe rate-of-strain tensor, $\\boldsymbol{D}$, is defined as $\\boldsymbol{D} = \\frac{1}{2}\\left( \\nabla \\boldsymbol{v} + (\\nabla \\boldsymbol{v})^{\\top} \\right)$. Using the velocity gradient tensor and its transpose, we find:\n$$\n\\boldsymbol{D} = \\frac{1}{2} \\left( \n\\begin{pmatrix} \n0 & \\dot{\\gamma} & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n+\n\\begin{pmatrix} \n0 & 0 & 0 \\\\\n\\dot{\\gamma} & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n\\right) = \\frac{1}{2}\n\\begin{pmatrix} \n0 & \\dot{\\gamma} & 0 \\\\\n\\dot{\\gamma} & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n$$\n\nNext, we determine the polymer conformation tensor, $\\boldsymbol{C}$. Its evolution is governed by:\n$$\n\\frac{\\partial \\boldsymbol{C}}{\\partial t} + \\boldsymbol{v} \\cdot \\nabla \\boldsymbol{C} - \\nabla \\boldsymbol{v} \\cdot \\boldsymbol{C} - \\boldsymbol{C} \\cdot (\\nabla \\boldsymbol{v})^{\\top} = -\\frac{1}{\\lambda}(\\boldsymbol{C} - \\boldsymbol{I})\n$$\nThe problem specifies a steady flow, so all time derivatives are zero: $\\frac{\\partial \\boldsymbol{C}}{\\partial t} = \\boldsymbol{0}$. The flow is also homogeneous, which means that physical quantities do not vary with position. Consequently, the spatial gradient of the conformation tensor is zero: $\\nabla \\boldsymbol{C} = \\boldsymbol{0}$. This simplifies the advection term to $\\boldsymbol{v} \\cdot \\nabla \\boldsymbol{C} = \\boldsymbol{0}$.\nThe evolution equation thus reduces to an algebraic equation for $\\boldsymbol{C}$:\n$$\n- \\nabla \\boldsymbol{v} \\cdot \\boldsymbol{C} - \\boldsymbol{C} \\cdot (\\nabla \\boldsymbol{v})^{\\top} = -\\frac{1}{\\lambda}(\\boldsymbol{C} - \\boldsymbol{I})\n$$\nMultiplying by $-\\lambda$ and rearranging gives:\n$$\n\\boldsymbol{C} - \\boldsymbol{I} = \\lambda \\left( \\nabla \\boldsymbol{v} \\cdot \\boldsymbol{C} + \\boldsymbol{C} \\cdot (\\nabla \\boldsymbol{v})^{\\top} \\right)\n$$\nWe now solve for the components of the symmetric tensor $\\boldsymbol{C} = \\begin{pmatrix} C_{xx} & C_{xy} & C_{xz} \\\\ C_{xy} & C_{yy} & C_{yz} \\\\ C_{xz} & C_{yz} & C_{zz} \\end{pmatrix}$. The term on the right-hand side is calculated as:\n$$\n\\nabla \\boldsymbol{v} \\cdot \\boldsymbol{C} + \\boldsymbol{C} \\cdot (\\nabla \\boldsymbol{v})^{\\top} = \n\\begin{pmatrix} \n0 & \\dot{\\gamma} & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n\\begin{pmatrix} \nC_{xx} & C_{xy} & C_{xz} \\\\ \nC_{xy} & C_{yy} & C_{yz} \\\\ \nC_{xz} & C_{yz} & C_{zz} \n\\end{pmatrix}\n+\n\\begin{pmatrix} \nC_{xx} & C_{xy} & C_{xz} \\\\ \nC_{xy} & C_{yy} & C_{yz} \\\\ \nC_{xz} & C_{yz} & C_{zz} \n\\end{pmatrix}\n\\begin{pmatrix} \n0 & 0 & 0 \\\\\n\\dot{\\gamma} & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n$$\n$$\n= \n\\begin{pmatrix} \n\\dot{\\gamma} C_{xy} & \\dot{\\gamma} C_{yy} & \\dot{\\gamma} C_{yz} \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n+\n\\begin{pmatrix} \n\\dot{\\gamma} C_{xy} & 0 & 0 \\\\\n\\dot{\\gamma} C_{yy} & 0 & 0 \\\\\n\\dot{\\gamma} C_{yz} & 0 & 0\n\\end{pmatrix}\n=\n\\begin{pmatrix} \n2\\dot{\\gamma} C_{xy} & \\dot{\\gamma} C_{yy} & \\dot{\\gamma} C_{yz} \\\\\n\\dot{\\gamma} C_{yy} & 0 & 0 \\\\\n\\dot{\\gamma} C_{yz} & 0 & 0\n\\end{pmatrix}\n$$\nSubstituting this back into the algebraic equation for $\\boldsymbol{C}$ gives:\n$$\n\\begin{pmatrix} \nC_{xx}-1 & C_{xy} & C_{xz} \\\\ \nC_{xy} & C_{yy}-1 & C_{yz} \\\\ \nC_{xz} & C_{yz} & C_{zz}-1 \n\\end{pmatrix}\n= \\lambda\n\\begin{pmatrix} \n2\\dot{\\gamma} C_{xy} & \\dot{\\gamma} C_{yy} & \\dot{\\gamma} C_{yz} \\\\\n\\dot{\\gamma} C_{yy} & 0 & 0 \\\\\n\\dot{\\gamma} C_{yz} & 0 & 0\n\\end{pmatrix}\n$$\nEquating the components leads to a system of equations:\nFrom the $(y,z)$ and $(z,z)$ components:\n$C_{yz} = \\lambda (0) \\implies C_{yz} = 0$.\n$C_{zz}-1 = \\lambda (0) \\implies C_{zz} = 1$.\nFrom the $(x,z)$ component:\n$C_{xz} = \\lambda (\\dot{\\gamma} C_{yz})$. With $C_{yz}=0$, we get $C_{xz} = 0$.\nFrom the $(y,y)$ component:\n$C_{yy}-1 = \\lambda (0) \\implies C_{yy} = 1$.\nFrom the $(x,y)$ component:\n$C_{xy} = \\lambda (\\dot{\\gamma} C_{yy})$. With $C_{yy}=1$, we get $C_{xy} = \\lambda \\dot{\\gamma}$.\nFrom the $(x,x)$ component:\n$C_{xx}-1 = \\lambda (2\\dot{\\gamma} C_{xy})$. Substituting $C_{xy} = \\lambda \\dot{\\gamma}$, we get $C_{xx}-1 = 2\\lambda\\dot{\\gamma}(\\lambda\\dot{\\gamma}) = 2\\lambda^2\\dot{\\gamma}^2$.\nThus, $C_{xx} = 1 + 2\\lambda^2\\dot{\\gamma}^2$.\n\nThe conformation tensor is:\n$$\n\\boldsymbol{C} = \n\\begin{pmatrix} \n1 + 2\\lambda^2\\dot{\\gamma}^2 & \\lambda\\dot{\\gamma} & 0 \\\\ \n\\lambda\\dot{\\gamma} & 1 & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n$$\nNow we compute the stress contributions. The polymer stress, $\\boldsymbol{\\tau}_{p}$, is:\n$$\n\\boldsymbol{\\tau}_{p} = \\frac{\\eta_{p}}{\\lambda}(\\boldsymbol{C} - \\boldsymbol{I}) = \\frac{\\eta_{p}}{\\lambda} \n\\begin{pmatrix} \n2\\lambda^2\\dot{\\gamma}^2 & \\lambda\\dot{\\gamma} & 0 \\\\ \n\\lambda\\dot{\\gamma} & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n= \n\\begin{pmatrix} \n2\\eta_{p}\\lambda\\dot{\\gamma}^2 & \\eta_{p}\\dot{\\gamma} & 0 \\\\ \n\\eta_{p}\\dot{\\gamma} & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n$$\nThe solvent stress, $\\boldsymbol{\\tau}_{s}$, is:\n$$\n\\boldsymbol{\\tau}_{s} = 2 \\eta_{s} \\boldsymbol{D} = 2 \\eta_{s} \\left(\\frac{1}{2}\n\\begin{pmatrix} \n0 & \\dot{\\gamma} & 0 \\\\ \n\\dot{\\gamma} & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n\\right) = \n\\begin{pmatrix} \n0 & \\eta_{s}\\dot{\\gamma} & 0 \\\\ \n\\eta_{s}\\dot{\\gamma} & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n$$\nThe total extra stress tensor, $\\boldsymbol{\\tau}$, is the sum $\\boldsymbol{\\tau} = \\boldsymbol{\\tau}_{s} + \\boldsymbol{\\tau}_{p}$:\n$$\n\\boldsymbol{\\tau} = \n\\begin{pmatrix} \n0 & \\eta_{s}\\dot{\\gamma} & 0 \\\\ \n\\eta_{s}\\dot{\\gamma} & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n+\n\\begin{pmatrix} \n2\\eta_{p}\\lambda\\dot{\\gamma}^2 & \\eta_{p}\\dot{\\gamma} & 0 \\\\ \n\\eta_{p}\\dot{\\gamma} & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n=\n\\begin{pmatrix} \n2\\eta_{p}\\lambda\\dot{\\gamma}^2 & (\\eta_{s}+\\eta_{p})\\dot{\\gamma} & 0 \\\\ \n(\\eta_{s}+\\eta_{p})\\dot{\\gamma} & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n$$\nThe components of the total stress are $\\tau_{xx} = 2\\eta_{p}\\lambda\\dot{\\gamma}^2$, $\\tau_{yy} = 0$, and $\\tau_{zz} = 0$.\n\nFinally, we calculate the normal stress differences using their definitions:\nThe first normal stress difference, $N_{1}$:\n$$\nN_{1} = \\tau_{xx} - \\tau_{yy} = 2\\eta_{p}\\lambda\\dot{\\gamma}^2 - 0 = 2\\eta_{p}\\lambda\\dot{\\gamma}^2\n$$\nThe second normal stress difference, $N_{2}$:\n$$\nN_{2} = \\tau_{yy} - \\tau_{zz} = 0 - 0 = 0\n$$\nThe Oldroyd-B model predicts a non-zero first normal stress difference that is quadratic in the shear rate and a zero second normal stress difference, which are its characteristic features in simple shear flow.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2\\eta_{p}\\lambda\\dot{\\gamma}^{2} & 0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "A crucial test for any physical model is its ability to recover well-established behavior in limiting cases. This practice guides you through a numerical verification that the Oldroyd-B model correctly reduces to a simple Newtonian fluid as the elastic effects vanish (). By implementing a solver for the algebraic stress equation, you will gain hands-on experience in translating the model's equations into code and validating its physical consistency.",
            "id": "3388289",
            "problem": "Consider an incompressible viscoelastic fluid described by the Oldroyd–B constitutive model. Let $\\boldsymbol{u}(\\boldsymbol{x})$ denote the velocity field, $\\boldsymbol{D} = \\frac{1}{2}\\left(\\nabla \\boldsymbol{u} + (\\nabla \\boldsymbol{u})^{\\top}\\right)$ be the rate-of-deformation tensor, and let the total extra stress be decomposed into a solvent part and a polymeric part. The Oldroyd–B polymer stress $\\boldsymbol{\\tau}_p$ is governed by the Upper-Convected Maxwell (UCM) relation, which for steady flow reads\n$$\n\\boldsymbol{\\tau}_p + \\lambda \\left( \\boldsymbol{u}\\cdot\\nabla \\boldsymbol{\\tau}_p - (\\nabla \\boldsymbol{u}) \\boldsymbol{\\tau}_p - \\boldsymbol{\\tau}_p (\\nabla \\boldsymbol{u})^{\\top} \\right) = 2 \\eta_p \\boldsymbol{D},\n$$\nwhere $\\lambda$ is the relaxation time and $\\eta_p$ is the polymer viscosity satisfying $\\eta_p = (1-\\beta)\\,\\eta$, with $\\beta \\in (0,1]$ the solvent viscosity fraction and $\\eta = \\eta_s + \\eta_p$ the total viscosity. In the limiting regime $\\beta \\to 1$ and $\\lambda \\to 0$, the polymer stress should vanish and the flow should reduce to Newtonian solvent behavior.\n\nYour task is to implement a numerical verification of the convergence $\\boldsymbol{\\tau}_p \\to \\boldsymbol{0}$ uniformly in the spatial domain $\\Omega$ as $\\beta \\to 1$ and $\\lambda \\to 0$ for steady homogeneous flows with constant velocity gradient. Use the following scientifically sound setup:\n\n- Domain: $\\Omega = [0,1]\\times[0,1]$ in meters, discretized to any uniform grid of at least $16\\times 16$ points to evaluate uniformity. Since the velocity gradients are constant, the solution is spatially homogeneous; nevertheless, compute the polymer stress on the grid and take the supremum norm over all grid points to assess uniform convergence explicitly.\n- Physical parameters: total viscosity $\\eta = 1\\,\\text{Pa}\\cdot\\text{s}$, shear rate $\\dot{\\gamma} = 1\\,\\text{s}^{-1}$ for simple shear, and extension rate $\\epsilon = 0.5\\,\\text{s}^{-1}$ for planar extension.\n- Flows to analyze:\n  1. Simple shear: $\\boldsymbol{u}(x,y) = (\\dot{\\gamma} y, 0)$, so $\\nabla \\boldsymbol{u} = \\begin{pmatrix} 0 & \\dot{\\gamma} \\\\ 0 & 0 \\end{pmatrix}$ and $\\boldsymbol{D} = \\frac{1}{2}\\begin{pmatrix} 0 & \\dot{\\gamma} \\\\ \\dot{\\gamma} & 0 \\end{pmatrix}$.\n  2. Planar extension: $\\boldsymbol{u}(x,y) = (\\epsilon x, -\\epsilon y)$, so $\\nabla \\boldsymbol{u} = \\begin{pmatrix} \\epsilon & 0 \\\\ 0 & -\\epsilon \\end{pmatrix}$ and $\\boldsymbol{D} = \\begin{pmatrix} \\epsilon & 0 \\\\ 0 & -\\epsilon \\end{pmatrix}$.\n\nFor each flow, start from the steady UCM definition above and, under the assumption of constant $\\nabla \\boldsymbol{u}$ and spatially uniform $\\boldsymbol{\\tau}_p$, derive a linear matrix equation for $\\boldsymbol{\\tau}_p$ of the form\n$$\n\\boldsymbol{\\tau}_p - \\lambda \\left( (\\nabla \\boldsymbol{u})\\, \\boldsymbol{\\tau}_p + \\boldsymbol{\\tau}_p\\, (\\nabla \\boldsymbol{u})^{\\top} \\right) = 2 \\eta_p \\boldsymbol{D}.\n$$\nThen implement a solver for this $2\\times 2$ linear matrix equation by transforming it to a $4\\times 4$ linear system using a vectorization approach appropriate for matrices (you must derive this transformation yourself). Evaluate $\\boldsymbol{\\tau}_p$ on the grid for each parameter pair, compute its Frobenius norm at each grid point, and report the supremum over $\\Omega$. Express all reported stress magnitudes in Pascal.\n\nDesign a test suite of parameter values that probes the limit $\\beta \\to 1$ and $\\lambda \\to 0$, as well as boundary cases:\n\n- Use the total viscosity $\\eta = 1\\,\\text{Pa}\\cdot\\text{s}$ fixed for all cases. For each case, set $\\eta_p = (1-\\beta)\\eta$.\n- For simple shear, evaluate the supremum of $\\|\\boldsymbol{\\tau}_p\\|_F$ for the following $(\\beta,\\lambda)$ pairs:\n  1. $(\\beta,\\lambda) = (0.8, 0.2\\,\\text{s})$ (general case).\n  2. $(\\beta,\\lambda) = (0.999, 0.001\\,\\text{s})$ (approach the limit).\n  3. $(\\beta,\\lambda) = (0.9999, 10^{-4}\\,\\text{s})$ (closer to the limit).\n  4. $(\\beta,\\lambda) = (1.0, 0.0\\,\\text{s})$ (exact limiting case).\n  5. $(\\beta,\\lambda) = (0.8, 0.0\\,\\text{s})$ (boundary case showing that $\\lambda \\to 0$ alone does not imply $\\boldsymbol{\\tau}_p \\to \\boldsymbol{0}$ unless $\\beta \\to 1$).\n- For planar extension, evaluate the supremum of $\\|\\boldsymbol{\\tau}_p\\|_F$ for the following $(\\beta,\\lambda)$ pairs:\n  6. $(\\beta,\\lambda) = (0.8, 0.2\\,\\text{s})$ (general case).\n  7. $(\\beta,\\lambda) = (0.999, 0.001\\,\\text{s})$ (approach the limit).\n  8. $(\\beta,\\lambda) = (0.9999, 10^{-4}\\,\\text{s})$ (closer to the limit).\n  9. $(\\beta,\\lambda) = (1.0, 0.0\\,\\text{s})$ (exact limiting case).\n  10. $(\\beta,\\lambda) = (0.8, 0.0\\,\\text{s})$ (boundary case as above).\n\nYour program must compute, for each of the 10 test cases, the supremum norm over $\\Omega$ of the Frobenius norm $\\|\\boldsymbol{\\tau}_p(\\boldsymbol{x})\\|_F$ and report these values in Pascal, rounded to eight decimal places.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...,result10]\"). Results must be in the order of the test cases listed above (first the five simple shear cases, then the five planar extension cases).",
            "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in the principles of continuum mechanics and computational fluid dynamics, specifically concerning the Oldroyd–B constitutive model. The problem is well-posed, objective, and self-contained, providing all necessary physical parameters, equations, and boundary conditions to arrive at a unique, meaningful solution. There are no contradictions, ambiguities, or scientifically unsound premises.\n\nThe solution proceeds as follows: First, the governing equation for the polymer stress tensor is simplified for the specified flow conditions. Second, this tensor equation is converted into a standard $4 \\times 4$ linear system. Third, this system is specialized for the two flow cases: simple shear and planar extension. Finally, a numerical procedure is outlined to solve this system for the given test cases and compute the required stress norm.\n\nThe governing equation for the steady-state polymer stress $\\boldsymbol{\\tau}_p$ is given by the Upper-Convected Maxwell (UCM) model:\n$$\n\\boldsymbol{\\tau}_p + \\lambda \\left( \\boldsymbol{u}\\cdot\\nabla \\boldsymbol{\\tau}_p - (\\nabla \\boldsymbol{u}) \\boldsymbol{\\tau}_p - \\boldsymbol{\\tau}_p (\\nabla \\boldsymbol{u})^{\\top} \\right) = 2 \\eta_p \\boldsymbol{D}\n$$\nThe problem considers homogeneous flows with a constant velocity gradient, $\\nabla\\boldsymbol{u}$. For such flows, the polymer stress $\\boldsymbol{\\tau}_p$ is also spatially uniform, meaning its gradient is zero, $\\nabla\\boldsymbol{\\tau}_p = \\boldsymbol{0}$. Consequently, the convective term $\\boldsymbol{u}\\cdot\\nabla \\boldsymbol{\\tau}_p$ vanishes. The governing equation simplifies to a linear matrix equation:\n$$\n\\boldsymbol{\\tau}_p - \\lambda \\left( (\\nabla \\boldsymbol{u}) \\boldsymbol{\\tau}_p + \\boldsymbol{\\tau}_p (\\nabla \\boldsymbol{u})^{\\top} \\right) = 2 \\eta_p \\boldsymbol{D}\n$$\nThis equation must be solved for the unknown $2 \\times 2$ tensor $\\boldsymbol{\\tau}_p$. To facilitate a numerical solution, we convert this matrix equation into a standard linear system of the form $\\boldsymbol{M}\\vec{\\tau} = \\vec{f}$. Let $\\boldsymbol{L} = \\nabla\\boldsymbol{u}$. The tensor components are denoted as:\n$$\n\\boldsymbol{\\tau}_p = \\begin{pmatrix} \\tau_{11} & \\tau_{12} \\\\ \\tau_{21} & \\tau_{22} \\end{pmatrix}, \\quad \\boldsymbol{L} = \\begin{pmatrix} L_{11} & L_{12} \\\\ L_{21} & L_{22} \\end{pmatrix}, \\quad \\boldsymbol{D} = \\begin{pmatrix} D_{11} & D_{12} \\\\ D_{21} & D_{22} \\end{pmatrix}\n$$\nWe vectorize $\\boldsymbol{\\tau}_p$ as $\\vec{\\tau} = (\\tau_{11}, \\tau_{12}, \\tau_{21}, \\tau_{22})^\\top$. Writing the matrix equation component-wise yields four linear equations:\n\\begin{align*}\n\\tau_{11} - \\lambda(2L_{11}\\tau_{11} + L_{12}\\tau_{21} + L_{12}\\tau_{12}) &= 2\\eta_p D_{11} \\\\\n\\tau_{12} - \\lambda(L_{11}\\tau_{12} + L_{12}\\tau_{22} + L_{21}\\tau_{11} + L_{22}\\tau_{12}) &= 2\\eta_p D_{12} \\\\\n\\tau_{21} - \\lambda(L_{21}\\tau_{11} + L_{22}\\tau_{21} + L_{11}\\tau_{21} + L_{12}\\tau_{22}) &= 2\\eta_p D_{21} \\\\\n\\tau_{22} - \\lambda(L_{21}\\tau_{12} + L_{22}\\tau_{22} + L_{21}\\tau_{21} + L_{22}\\tau_{22}) &= 2\\eta_p D_{22}\n\\end{align*}\nRearranging these into the form $\\boldsymbol{M}\\vec{\\tau} = \\vec{f}$, where $\\vec{f} = 2\\eta_p(D_{11}, D_{12}, D_{21}, D_{22})^\\top$, the $4 \\times 4$ coefficient matrix $\\boldsymbol{M}$ is:\n$$\n\\boldsymbol{M} = \\begin{pmatrix}\n1 - 2\\lambda L_{11} & -\\lambda L_{12} & -\\lambda L_{12} & 0 \\\\\n-\\lambda L_{21} & 1 - \\lambda(L_{11}+L_{22}) & 0 & -\\lambda L_{12} \\\\\n-\\lambda L_{21} & 0 & 1 - \\lambda(L_{11}+L_{22}) & -\\lambda L_{12} \\\\\n0 & -\\lambda L_{21} & -\\lambda L_{21} & 1 - 2\\lambda L_{22}\n\\end{pmatrix}\n$$\nThe problem specifies that the domain $\\Omega = [0,1]\\times[0,1]$ is discretized on a grid. Since $\\nabla\\boldsymbol{u}$ is constant, the resulting stress tensor $\\boldsymbol{\\tau}_p$ is also constant throughout the domain. Therefore, the supremum of its norm over $\\Omega$ is simply the norm evaluated at any point.\n\nThe solution strategy is to construct and solve the linear system $\\boldsymbol{M}\\vec{\\tau} = \\vec{f}$ for each test case.\nThe physical parameters are fixed: total viscosity $\\eta = 1\\,\\text{Pa}\\cdot\\text{s}$, shear rate $\\dot{\\gamma} = 1\\,\\text{s}^{-1}$, and extension rate $\\epsilon = 0.5\\,\\text{s}^{-1}$. The polymer viscosity is $\\eta_p = (1-\\beta)\\eta$.\n\n**1. Simple Shear Flow**\nFor simple shear $\\boldsymbol{u}(x,y) = (\\dot{\\gamma} y, 0)$, the velocity gradient and rate-of-deformation tensors are:\n$$\n\\boldsymbol{L} = \\begin{pmatrix} 0 & \\dot{\\gamma} \\\\ 0 & 0 \\end{pmatrix}, \\quad \\boldsymbol{D} = \\frac{1}{2}\\begin{pmatrix} 0 & \\dot{\\gamma} \\\\ \\dot{\\gamma} & 0 \\end{pmatrix}\n$$\nSubstituting $L_{11}=0, L_{12}=\\dot{\\gamma}, L_{21}=0, L_{22}=0$ into $\\boldsymbol{M}$:\n$$\n\\boldsymbol{M}_{\\text{shear}} = \\begin{pmatrix}\n1 & -\\lambda \\dot{\\gamma} & -\\lambda \\dot{\\gamma} & 0 \\\\\n0 & 1 & 0 & -\\lambda \\dot{\\gamma} \\\\\n0 & 0 & 1 & -\\lambda \\dot{\\gamma} \\\\\n0 & 0 & 0 & 1\n\\end{pmatrix}\n$$\nThe right-hand side vector is $\\vec{f}_{\\text{shear}} = 2\\eta_p (0, \\dot{\\gamma}/2, \\dot{\\gamma}/2, 0)^\\top = \\eta_p (0, \\dot{\\gamma}, \\dot{\\gamma}, 0)^\\top$. Solving $\\boldsymbol{M}_{\\text{shear}}\\vec{\\tau} = \\vec{f}_{\\text{shear}}$ yields the polymer stress components.\n\n**2. Planar Extension Flow**\nFor planar extension $\\boldsymbol{u}(x,y) = (\\epsilon x, -\\epsilon y)$, the tensors are:\n$$\n\\boldsymbol{L} = \\begin{pmatrix} \\epsilon & 0 \\\\ 0 & -\\epsilon \\end{pmatrix}, \\quad \\boldsymbol{D} = \\begin{pmatrix} \\epsilon & 0 \\\\ 0 & -\\epsilon \\end{pmatrix}\n$$\nSubstituting $L_{11}=\\epsilon, L_{12}=0, L_{21}=0, L_{22}=-\\epsilon$ into $\\boldsymbol{M}$:\n$$\n\\boldsymbol{M}_{\\text{ext}} = \\begin{pmatrix}\n1 - 2\\lambda\\epsilon & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1 + 2\\lambda\\epsilon\n\\end{pmatrix}\n$$\nThe right-hand side is $\\vec{f}_{\\text{ext}} = 2\\eta_p (\\epsilon, 0, 0, -\\epsilon)^\\top$. The system $\\boldsymbol{M}_{\\text{ext}}\\vec{\\tau} = \\vec{f}_{\\text{ext}}$ is diagonal and easily solved. Note that a singularity occurs if $1 - 2\\lambda\\epsilon = 0$. For the given parameters $\\epsilon = 0.5\\,\\text{s}^{-1}$, this happens at $\\lambda = 1\\,\\text{s}$, which is not among the test-case values.\n\nFor each test case defined by $(\\beta, \\lambda)$, the corresponding $\\boldsymbol{L}$ and $\\boldsymbol{D}$ are used to construct and solve the linear system for $\\vec{\\tau}$. The resulting vector is reshaped into the $2 \\times 2$ matrix $\\boldsymbol{\\tau}_p$, and its Frobenius norm $\\|\\boldsymbol{\\tau}_p\\|_F = \\sqrt{\\sum_{i,j} |\\tau_{ij}|^2}$ is computed. This value, being constant over the domain, is the required supremum norm. The results for all 10 cases are computed and formatted as requested.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the polymer stress in an Oldroyd-B fluid under simple shear and\n    planar extensional flows for a range of parameters.\n    \"\"\"\n\n    def calculate_stress_norm(beta, lam, flow_type, eta, gamma_dot, epsilon):\n        \"\"\"\n        Calculates the Frobenius norm of the polymer stress tensor.\n\n        Args:\n            beta (float): Solvent viscosity fraction.\n            lam (float): Relaxation time in seconds.\n            flow_type (str): 'shear' or 'extension'.\n            eta (float): Total viscosity in Pa.s.\n            gamma_dot (float): Shear rate in 1/s.\n            epsilon (float): Extension rate in 1/s.\n\n        Returns:\n            float: The Frobenius norm of the polymer stress tensor in Pa.\n        \"\"\"\n        eta_p = (1.0 - beta) * eta\n\n        if eta_p == 0.0:\n            return 0.0\n\n        if flow_type == 'shear':\n            L = np.array([[0., gamma_dot], [0., 0.]])\n            D = 0.5 * np.array([[0., gamma_dot], [gamma_dot, 0.]])\n        elif flow_type == 'extension':\n            L = np.array([[epsilon, 0.], [0., -epsilon]])\n            D = np.array([[epsilon, 0.], [0., -epsilon]])\n        else:\n            raise ValueError(\"Invalid flow type specified.\")\n\n        L11, L12 = L[0, 0], L[0, 1]\n        L21, L22 = L[1, 0], L[1, 1]\n        \n        # Construct the 4x4 coefficient matrix M\n        M = np.zeros((4, 4))\n        \n        # Equation for tau_11\n        M[0, 0] = 1.0 - 2.0 * lam * L11\n        M[0, 1] = -lam * L12\n        M[0, 2] = -lam * L12\n        \n        # Equation for tau_12\n        M[1, 0] = -lam * L21\n        M[1, 1] = 1.0 - lam * (L11 + L22)\n        M[1, 3] = -lam * L12\n\n        # Equation for tau_21\n        M[2, 0] = -lam * L21\n        M[2, 2] = 1.0 - lam * (L11 + L22)\n        M[2, 3] = -lam * L12\n\n        # Equation for tau_22\n        M[3, 1] = -lam * L21\n        M[3, 2] = -lam * L21\n        M[3, 3] = 1.0 - 2.0 * lam * L22\n\n        # Construct the right-hand side vector f\n        f = 2.0 * eta_p * np.array([D[0, 0], D[0, 1], D[1, 0], D[1, 1]])\n\n        # Solve the linear system M * tau_vec = f\n        tau_vec = np.linalg.solve(M, f)\n        \n        # Reshape the solution vector to a 2x2 matrix\n        tau_p = tau_vec.reshape((2, 2))\n\n        # Compute and return the Frobenius norm\n        return np.linalg.norm(tau_p, 'fro')\n\n    # Define physical parameters\n    eta = 1.0        # Pa.s\n    gamma_dot = 1.0  # 1/s\n    epsilon = 0.5    # 1/s\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Simple Shear cases\n        {'beta': 0.8, 'lambda': 0.2, 'flow': 'shear'},\n        {'beta': 0.999, 'lambda': 0.001, 'flow': 'shear'},\n        {'beta': 0.9999, 'lambda': 1e-4, 'flow': 'shear'},\n        {'beta': 1.0, 'lambda': 0.0, 'flow': 'shear'},\n        {'beta': 0.8, 'lambda': 0.0, 'flow': 'shear'},\n        # Planar Extension cases\n        {'beta': 0.8, 'lambda': 0.2, 'flow': 'extension'},\n        {'beta': 0.999, 'lambda': 0.001, 'flow': 'extension'},\n        {'beta': 0.9999, 'lambda': 1e-4, 'flow': 'extension'},\n        {'beta': 1.0, 'lambda': 0.0, 'flow': 'extension'},\n        {'beta': 0.8, 'lambda': 0.0, 'flow': 'extension'},\n    ]\n\n    results = []\n    for case in test_cases:\n        norm = calculate_stress_norm(\n            case['beta'],\n            case['lambda'],\n            case['flow'],\n            eta,\n            gamma_dot,\n            epsilon\n        )\n        results.append(np.round(norm, 8))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Solving the full time-dependent Oldroyd-B model requires robust numerical schemes to handle the interplay of advection, deformation, and relaxation. This advanced practice explores operator splitting, a powerful technique for breaking the complex conformation tensor evolution equation into a sequence of simpler, solvable steps (). You will implement and compare different splitting strategies, quantifying their accuracy and their ability to preserve the symmetric positive definite (SPD) nature of the conformation tensor, which is a critical physical constraint.",
            "id": "3388252",
            "problem": "You are asked to design and implement a complete, runnable program that compares three operator-splitting strategies for the evolution of the conformation tensor in the Oldroyd–B constitutive model. The goal is to quantify the splitting error against an unsplit reference computed along characteristics and to verify the preservation of symmetric positive definiteness (SPD) of the conformation tensor for each scheme.\n\nThe starting point is the Oldroyd–B conformation equation in Eulerian form for an incompressible flow with no polymer stress diffusion:\n$$\n\\partial_t \\mathbf{C} + \\mathbf{u} \\cdot \\nabla \\mathbf{C} - (\\nabla \\mathbf{u}) \\,\\mathbf{C} - \\mathbf{C}\\, (\\nabla \\mathbf{u})^{\\top} = -\\frac{1}{\\lambda}\\left(\\mathbf{C} - \\mathbf{I}\\right),\n$$\nwhere $\\mathbf{C}(x,t) \\in \\mathbb{R}^{2 \\times 2}$ is the symmetric conformation tensor, $\\mathbf{u}(x)$ is the velocity field, $\\nabla \\mathbf{u}$ is the velocity gradient, $\\lambda$ is the relaxation time, and $\\mathbf{I}$ is the identity tensor. We will use nondimensional units throughout this problem.\n\nYou must restrict attention to a one-dimensional periodic domain $x \\in [0,1)$ with a uniform advection velocity and a spatially varying simple-shear velocity gradient:\n- The advection velocity is constant, $\\mathbf{u}(x) = (u, 0)$ with $u = 1$.\n- The velocity gradient is taken as\n$$\n\\nabla \\mathbf{u}(x) = \\begin{bmatrix} 0 & s(x) \\\\ 0 & 0 \\end{bmatrix}, \\quad s(x) = s_0 + s_1 \\sin(2\\pi x).\n$$\n- The initial condition is $\\mathbf{C}(x,0) = \\mathbf{I}$.\n- The evolution is computed up to a final time $T = 1$.\n\nThe governing equation can be written as the composition of three operators:\n- Advection operator $\\mathcal{A}$ from $\\mathbf{u} \\cdot \\nabla \\mathbf{C}$,\n- Coupling (deformation) operator $\\mathcal{B}$ from $(\\nabla \\mathbf{u}) \\,\\mathbf{C} + \\mathbf{C}\\, (\\nabla \\mathbf{u})^{\\top}$,\n- Relaxation operator $\\mathcal{R}$ from $-\\frac{1}{\\lambda}\\left(\\mathbf{C}-\\mathbf{I}\\right)$.\n\nThe implementation must use a uniform grid with $N$ points on $[0,1)$ and periodic boundary conditions. For $\\mathcal{A}$, use a semi-Lagrangian backtracking step with linear interpolation. For $\\mathcal{B}$ at a grid point $x_i$, use the exact congruence update for a constant velocity gradient during a substep $\\Delta t$: with $\\mathbf{A}(x_i) = \\nabla \\mathbf{u}(x_i)$,\n$$\n\\mathbf{C}^{\\mathrm{new}} = \\exp\\!\\big(\\mathbf{A}(x_i)\\,\\Delta t\\big)\\, \\mathbf{C}^{\\mathrm{old}}\\, \\exp\\!\\big(\\mathbf{A}(x_i)^{\\top}\\,\\Delta t\\big).\n$$\nFor the specific $\\mathbf{A}(x_i)$ above, you must use $\\exp\\!\\big(\\mathbf{A}(x_i)\\,\\Delta t\\big) = \\begin{bmatrix} 1 & s(x_i)\\,\\Delta t \\\\ 0 & 1 \\end{bmatrix}$. For $\\mathcal{R}$, use the exact pointwise update\n$$\n\\mathbf{C}^{\\mathrm{new}} = \\mathbf{I} + \\exp\\!\\left(-\\frac{\\Delta t}{\\lambda}\\right)\\, \\big(\\mathbf{C}^{\\mathrm{old}} - \\mathbf{I}\\big).\n$$\n\nImplement and compare the following three splitting strategies per time step $\\Delta t$:\n- Scheme $\\mathsf{ABC}$ (Lie splitting in the order Advection $\\rightarrow$ Coupling $\\rightarrow$ Relaxation): apply $\\mathcal{A}_{\\Delta t}$, then $\\mathcal{B}_{\\Delta t}$, then $\\mathcal{R}_{\\Delta t}$.\n- Scheme $\\mathsf{RBA}$ (Lie splitting in the order Relaxation $\\rightarrow$ Coupling $\\rightarrow$ Advection): apply $\\mathcal{R}_{\\Delta t}$, then $\\mathcal{B}_{\\Delta t}$, then $\\mathcal{A}_{\\Delta t}$.\n- Scheme $\\mathsf{Strang}$ (second-order symmetric splitting): apply $\\mathcal{A}_{\\Delta t/2}$, then $\\mathcal{B}_{\\Delta t/2}$, then $\\mathcal{R}_{\\Delta t}$, then $\\mathcal{B}_{\\Delta t/2}$, then $\\mathcal{A}_{\\Delta t/2}$.\n\nAs a reference \"unsplit\" update over each coarse time step $\\Delta t$, compute the characteristic-based update at each grid point $x_i$ as follows:\n- Compute the departure point $x_d = x_i - u\\,\\Delta t \\bmod 1$.\n- Interpolate $\\mathbf{C}$ at time $t$ from the grid to initialize $\\mathbf{C}(t)$ at $x_d$.\n- Integrate along the characteristic $x(\\tau) = x_d + u\\,(\\tau - t)$, $\\tau \\in [t, t+\\Delta t]$, the matrix ordinary differential equation\n$$\n\\frac{d\\mathbf{C}}{d\\tau} = \\mathbf{A}(x(\\tau))\\,\\mathbf{C} + \\mathbf{C}\\,\\mathbf{A}(x(\\tau))^{\\top} - \\frac{1}{\\lambda}\\left(\\mathbf{C} - \\mathbf{I}\\right),\n$$\nusing a fourth-order Runge–Kutta method with a sufficiently fine internal substep $\\delta \\tau$ so that the unsplit step is of higher accuracy than any of the splits. This reference is used solely for error quantification.\n\nDefine the relative splitting error at final time $T$ for a given scheme as\n$$\n\\varepsilon = \\sqrt{\\frac{\\sum_{i=0}^{N-1} \\left\\lVert \\mathbf{C}_{\\mathrm{scheme}}(x_i,T) - \\mathbf{C}_{\\mathrm{ref}}(x_i,T) \\right\\rVert_F^2}{\\sum_{i=0}^{N-1} \\left\\lVert \\mathbf{C}_{\\mathrm{ref}}(x_i,T) \\right\\rVert_F^2}},\n$$\nwhere $\\lVert \\cdot \\rVert_F$ is the Frobenius norm.\n\nVerify SPD preservation by checking after every substep in time that, at every grid point, the minimum eigenvalue of $\\mathbf{C}$ is strictly greater than a tolerance $\\tau_{\\mathrm{SPD}} = 10^{-12}$; report a boolean that is $\\mathrm{True}$ if SPD is preserved at all substeps and grid points for the entire simulation, and $\\mathrm{False}$ otherwise.\n\nTest Suite:\nYou must run the program for the following four parameter sets, each specified as $(N, \\Delta t, s_0, s_1, \\lambda, T)$:\n- Case $1$ (commuting advection-relaxation only): $(N=\\;64,\\;\\Delta t=\\;0.05,\\; s_0=\\;0,\\; s_1=\\;0,\\; \\lambda=\\;0.5,\\; T=\\;1)$.\n- Case $2$ (happy path): $(N=\\;64,\\;\\Delta t=\\;0.01,\\; s_0=\\;2,\\; s_1=\\;1,\\; \\lambda=\\;0.5,\\; T=\\;1)$.\n- Case $3$ (coarser time step): $(N=\\;64,\\;\\Delta t=\\;0.05,\\; s_0=\\;2,\\; s_1=\\;1,\\; \\lambda=\\;0.5,\\; T=\\;1)$.\n- Case $4$ (higher Weissenberg number): $(N=\\;64,\\;\\Delta t=\\;0.02,\\; s_0=\\;6,\\; s_1=\\;3,\\; \\lambda=\\;1.5,\\; T=\\;1)$.\n\nAll quantities are nondimensional. Angles in the trigonometric function are in radians.\n\nProgram Requirements:\n- Implement the three splitting schemes and the unsplit reference as described.\n- For each case, compute and return a list containing $6$ results: the three relative errors $\\varepsilon$ (in that order for $\\mathsf{ABC}$, $\\mathsf{RBA}$, $\\mathsf{Strang}$) as floating-point numbers, followed by three booleans indicating SPD preservation for $\\mathsf{ABC}$, $\\mathsf{RBA}$, and $\\mathsf{Strang}$ over the entire simulation.\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list of lists, enclosed in square brackets, where each inner list is formatted as described above. For example, an output with two hypothetical cases would look like $[[0.1,0.2,0.05,\\mathrm{True},\\mathrm{False},\\mathrm{True}],[\\dots]]$. The actual numerical values must be computed by your implementation.",
            "solution": "We begin from the Oldroyd–B conformation equation in Eulerian variables for an incompressible flow,\n$$\n\\partial_t \\mathbf{C} + \\mathbf{u} \\cdot \\nabla \\mathbf{C} - (\\nabla \\mathbf{u})\\,\\mathbf{C} - \\mathbf{C}\\,(\\nabla \\mathbf{u})^{\\top} = -\\frac{1}{\\lambda}(\\mathbf{C} - \\mathbf{I}),\n$$\nwhere $\\mathbf{C}(x,t)$ is symmetric positive definite when initialized as such for exact continuous dynamics. We choose a one-dimensional periodic domain $x \\in [0,1)$ with uniform advection velocity $\\mathbf{u} = (u,0)$ and a simple-shear velocity gradient that varies with position,\n$$\n\\nabla \\mathbf{u}(x) = \\begin{bmatrix} 0 & s(x) \\\\ 0 & 0 \\end{bmatrix}, \\quad s(x) = s_0 + s_1 \\sin(2\\pi x).\n$$\nThis yields a tractable yet nontrivial spatial dependence which makes the advection and local source operators noncommuting when $s_1 \\neq 0$.\n\nWe decompose the right-hand side into three operators:\n- Advection operator $\\mathcal{A}$: $\\partial_t \\mathbf{C} + \\mathbf{u}\\cdot \\nabla \\mathbf{C} = 0$,\n- Coupling operator $\\mathcal{B}$: $\\partial_t \\mathbf{C} = (\\nabla \\mathbf{u})\\,\\mathbf{C} + \\mathbf{C}\\,(\\nabla \\mathbf{u})^{\\top}$,\n- Relaxation operator $\\mathcal{R}$: $\\partial_t \\mathbf{C} = -\\dfrac{1}{\\lambda}(\\mathbf{C} - \\mathbf{I})$.\n\nFor numerical implementation:\n- For $\\mathcal{A}$, we use a semi-Lagrangian backtracking step with linear interpolation on a uniform grid with $N$ points and spacing $\\Delta x = 1/N$. Each grid point at $x_i = i \\Delta x$ at time $t+\\Delta t$ traces back to a departure point $x_d = x_i - u \\Delta t \\bmod 1$, which lies between two grid nodes. Linear interpolation with weights in $[0,1]$ computes $\\mathbf{C}(x_d,t)$ by convex combination of neighboring nodal values.\n\n- For $\\mathcal{B}$ at fixed location $x_i$ with constant $\\mathbf{A} = \\nabla \\mathbf{u}(x_i)$ over a substep $\\Delta t$, the exact solution of $\\partial_t \\mathbf{C} = \\mathbf{A}\\mathbf{C} + \\mathbf{C}\\mathbf{A}^{\\top}$ is\n$$\n\\mathbf{C}(t+\\Delta t) = \\exp(\\mathbf{A}\\Delta t)\\, \\mathbf{C}(t)\\,\\exp(\\mathbf{A}^{\\top}\\Delta t).\n$$\nFor the simple-shear $\\mathbf{A} = \\begin{bmatrix} 0 & s \\\\ 0 & 0 \\end{bmatrix}$, the exponential is exactly\n$$\n\\exp(\\mathbf{A}\\Delta t) = \\begin{bmatrix} 1 & s\\Delta t \\\\ 0 & 1 \\end{bmatrix},\n$$\nwhich makes the coupling update a congruence transformation by an upper-triangular matrix.\n\n- For $\\mathcal{R}$, the exact solution of $\\partial_t \\mathbf{C} = -\\dfrac{1}{\\lambda}(\\mathbf{C}-\\mathbf{I})$ is the convex combination\n$$\n\\mathbf{C}(t+\\Delta t) = \\mathbf{I} + \\exp\\!\\left(-\\frac{\\Delta t}{\\lambda}\\right)\\, \\left(\\mathbf{C}(t) - \\mathbf{I}\\right).\n$$\n\nThese exact substeps are favorable for symmetric positive definite preservation:\n- The advection step with linear interpolation yields a convex combination of symmetric positive definite matrices, which remains symmetric positive definite.\n- The coupling step maps $\\mathbf{C}$ to $\\mathbf{E}\\mathbf{C}\\mathbf{E}^{\\top}$ for $\\mathbf{E} = \\exp(\\mathbf{A}\\Delta t)$, a congruence transform, which preserves symmetric positive definiteness.\n- The relaxation step yields a convex combination of $\\mathbf{C}$ and $\\mathbf{I}$, preserving symmetric positive definiteness.\n\nWe consider three compositions per time step $\\Delta t$:\n- Lie $\\mathsf{ABC}$: first $\\mathcal{A}_{\\Delta t}$, then $\\mathcal{B}_{\\Delta t}$, then $\\mathcal{R}_{\\Delta t}$,\n- Lie $\\mathsf{RBA}$: first $\\mathcal{R}_{\\Delta t}$, then $\\mathcal{B}_{\\Delta t}$, then $\\mathcal{A}_{\\Delta t}$,\n- Strang $\\mathsf{Strang}$: $\\mathcal{A}_{\\Delta t/2} \\circ \\mathcal{B}_{\\Delta t/2} \\circ \\mathcal{R}_{\\Delta t} \\circ \\mathcal{B}_{\\Delta t/2} \\circ \\mathcal{A}_{\\Delta t/2}$.\n\nBecause $s(x)$ varies spatially when $s_1 \\neq 0$, $\\mathcal{A}$ and $\\mathcal{B}$ do not commute, and neither do $\\mathcal{A}$ and $\\mathcal{R}$ commute with $\\mathcal{B}$; hence splitting errors are expected. In contrast, when $s(x) \\equiv 0$ the advection and relaxation operators commute, and the splitting error should be negligible up to interpolation and floating-point roundoff.\n\nFor error quantification, we build an unsplit reference at each coarse time step $\\Delta t$ by integrating along characteristics. For each grid point $x_i$ at time $t+\\Delta t$:\n- The departure point is $x_d = x_i - u\\Delta t \\bmod 1$.\n- The initial conformation is $\\mathbf{C}(t)$ interpolated at $x_d$.\n- Along the characteristic $x(\\tau) = x_d + u (\\tau - t)$, we integrate the matrix ordinary differential equation\n$$\n\\frac{d\\mathbf{C}}{d\\tau} = \\mathbf{A}(x(\\tau))\\,\\mathbf{C} + \\mathbf{C}\\,\\mathbf{A}(x(\\tau))^{\\top} - \\frac{1}{\\lambda}\\left(\\mathbf{C} - \\mathbf{I}\\right),\n$$\nusing the classical fourth-order Runge–Kutta method with an internal substep $\\delta \\tau = \\Delta t / M$ and $M$ sufficiently large (for example, $M = 20$) to reduce temporal error below that of the splitting schemes. This procedure effectively computes $\\mathbf{C}(x_i,t+\\Delta t)$ with reduced splitting error because advection and sources are coupled continuously along the trajectory.\n\nDefine the relative error at the final time $T$ as\n$$\n\\varepsilon = \\sqrt{\\frac{\\sum_{i=0}^{N-1} \\left\\lVert \\mathbf{C}_{\\mathrm{scheme}}(x_i,T) - \\mathbf{C}_{\\mathrm{ref}}(x_i,T) \\right\\rVert_F^2}{\\sum_{i=0}^{N-1} \\left\\lVert \\mathbf{C}_{\\mathrm{ref}}(x_i,T) \\right\\rVert_F^2}}.\n$$\nThis choice normalizes by the reference magnitude and aggregates errors over the domain.\n\nTo verify symmetric positive definiteness, we check after every substep (each application of $\\mathcal{A}$, $\\mathcal{B}$, or $\\mathcal{R}$ in a time step) that the minimum eigenvalue at each grid node is strictly greater than a tolerance $\\tau_{\\mathrm{SPD}} = 10^{-12}$. For a symmetric $2\\times 2$ matrix\n$$\n\\mathbf{M} = \\begin{bmatrix} a & b \\\\ b & c \\end{bmatrix},\n$$\nthe eigenvalues are\n$$\n\\lambda_{\\pm} = \\frac{a+c \\pm \\sqrt{(a-c)^2 + 4b^2}}{2},\n$$\nso we may compute the minimum eigenvalue via this closed form to avoid unnecessary overhead. We set the symmetric part at each stage as $\\dfrac{1}{2}(\\mathbf{C} + \\mathbf{C}^{\\top})$ to mitigate floating-point asymmetries without altering the underlying SPD-preserving logic.\n\nWe use the following test suite to exercise different regimes:\n- Case $1$: $(N=\\;64,\\;\\Delta t=\\;0.05,\\; s_0=\\;0,\\; s_1=\\;0,\\; \\lambda=\\;0.5,\\; T=\\;1)$, where advection and relaxation commute and the splitting error should be negligible.\n- Case $2$: $(N=\\;64,\\;\\Delta t=\\;0.01,\\; s_0=\\;2,\\; s_1=\\;1,\\; \\lambda=\\;0.5,\\; T=\\;1)$, a moderate regime with expected small splitting error.\n- Case $3$: $(N=\\;64,\\;\\Delta t=\\;0.05,\\; s_0=\\;2,\\; s_1=\\;1,\\; \\lambda=\\;0.5,\\; T=\\;1)$, a coarser time step that should increase splitting error.\n- Case $4$: $(N=\\;64,\\;\\Delta t=\\;0.02,\\; s_0=\\;6,\\; s_1=\\;3,\\; \\lambda=\\;1.5,\\; T=\\;1)$, a higher Weissenberg-number-like setting with stronger deformation.\n\nAlgorithmic structure per case:\n- Initialize $\\mathbf{C}(x,0) = \\mathbf{I}$ on the grid.\n- Advance the reference solution to $T$ with the unsplit characteristic-based Runge–Kutta method per coarse step $\\Delta t$.\n- For each splitting scheme, advance to $T$ with its composition, tracking SPD at each substep and symmetrizing after each operator.\n- Compute the relative error $\\varepsilon$ at $T$ for each scheme versus the reference.\n- Output per case a list $[\\varepsilon_{\\mathsf{ABC}}, \\varepsilon_{\\mathsf{RBA}}, \\varepsilon_{\\mathsf{Strang}}, \\mathrm{SPD}_{\\mathsf{ABC}}, \\mathrm{SPD}_{\\mathsf{RBA}}, \\mathrm{SPD}_{\\mathsf{Strang}}]$.\n\nFinally, aggregate the results for all four cases into a single list of lists and print it as a single line as specified. Because all quantities are nondimensional and trigonometric arguments are in radians, no additional units are required. The SPD check threshold is $\\tau_{\\mathrm{SPD}} = 10^{-12}$. The output format is a single line with a comma-separated list of per-case lists enclosed in square brackets, for example $[[0.1,0.2,0.05,\\mathrm{True},\\mathrm{False},\\mathrm{True}],[\\dots],[\\dots],[\\dots]]$, but with the actual computed values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Execution environment: Python 3.12, numpy 1.23.5, scipy 1.11.4 (not used).\nimport numpy as np\n\ndef shear_profile(x, s0, s1):\n    # x in [0,1)\n    return s0 + s1 * np.sin(2.0 * np.pi * x)\n\ndef grid_points(N):\n    dx = 1.0 / N\n    x = np.arange(N) * dx\n    return x, dx\n\ndef interpolate_C_linear_periodic(C, xq, dx):\n    \"\"\"\n    Semi-Lagrangian linear interpolation of C at query positions xq in [0,1).\n    C: array (N, 2, 2)\n    xq: array (M,)\n    dx: grid spacing\n    Returns Cq: array (M, 2, 2)\n    \"\"\"\n    N = C.shape[0]\n    xq_mod = np.mod(xq, 1.0)\n    j0 = np.floor(xq_mod / dx).astype(int) % N\n    x0 = j0 * dx\n    alpha = (xq_mod - x0) / dx\n    j1 = (j0 + 1) % N\n    # Broadcast alpha to (M,1,1)\n    alpha_b = alpha[:, None, None]\n    Cq = (1.0 - alpha_b) * C[j0] + alpha_b * C[j1]\n    return Cq\n\ndef advection_step(C, u, dt, dx):\n    \"\"\"\n    Semi-Lagrangian advection for constant velocity u on uniform grid.\n    C: (N,2,2)\n    \"\"\"\n    N = C.shape[0]\n    x, _ = grid_points(N)\n    xd = x - u * dt\n    C_new = interpolate_C_linear_periodic(C, xd, dx)\n    # Symmetrize to mitigate floating point drift\n    C_new = 0.5 * (C_new + np.swapaxes(C_new, -1, -2))\n    return C_new\n\ndef coupling_step(C, s_arr, dt):\n    \"\"\"\n    Exact coupling update: C_new = E C E^T, with E = exp(A dt), A = [[0,s],[0,0]]\n    s_arr: array (N,)\n    \"\"\"\n    N = C.shape[0]\n    # Build E for each grid point\n    E = np.zeros((N, 2, 2))\n    E[:, 0, 0] = 1.0\n    E[:, 1, 1] = 1.0\n    E[:, 0, 1] = s_arr * dt\n    # Compute C_new = E C E^T\n    # First temp = E C\n    temp = np.einsum('nij,njk->nik', E, C)\n    C_new = np.einsum('nij,nkj->nik', temp, E)  # multiply by E^T\n    # Symmetrize to mitigate floating point drift\n    C_new = 0.5 * (C_new + np.swapaxes(C_new, -1, -2))\n    return C_new\n\ndef relaxation_step(C, lam, dt):\n    \"\"\"\n    Exact relaxation update: C_new = I + exp(-dt/lam) * (C - I)\n    \"\"\"\n    factor = np.exp(-dt / lam)\n    I = np.zeros_like(C)\n    I[:, 0, 0] = 1.0\n    I[:, 1, 1] = 1.0\n    C_new = I + factor * (C - I)\n    # Symmetrize to mitigate floating point drift\n    C_new = 0.5 * (C_new + np.swapaxes(C_new, -1, -2))\n    return C_new\n\ndef min_eigenvalue_field(C):\n    \"\"\"\n    Compute the minimal eigenvalue across the grid for symmetric 2x2 matrices.\n    C: (N,2,2)\n    Returns min_lambda (float), and array of min eigenvalues per gridpoint.\n    \"\"\"\n    a = C[:, 0, 0]\n    b = C[:, 0, 1]\n    c = C[:, 1, 1]\n    disc = np.sqrt((a - c) ** 2 + 4.0 * (b ** 2))\n    lam_min = 0.5 * (a + c - disc)\n    return np.min(lam_min), lam_min\n\ndef run_lie_scheme(C0, u, dt, T, s0, s1, lam, order, spd_tol=1e-12):\n    \"\"\"\n    Run Lie splitting with specified order string: 'ABC' or 'RBA'\n    Returns final C and SPD preservation boolean across all substeps.\n    \"\"\"\n    N = C0.shape[0]\n    _, dx = grid_points(N)\n    steps = int(np.round(T / dt))\n    C = C0.copy()\n    spd_ok = True\n    for _ in range(steps):\n        # s(x) evaluated at current grid nodes\n        x, _ = grid_points(N)\n        s_arr = shear_profile(x, s0, s1)\n        # Apply operators in specified order\n        if order == 'ABC':\n            # A -> B -> R\n            C = advection_step(C, u, dt, dx)\n            min_lam, _ = min_eigenvalue_field(C)\n            if min_lam <= spd_tol:\n                spd_ok = False\n            C = coupling_step(C, s_arr, dt)\n            min_lam, _ = min_eigenvalue_field(C)\n            if min_lam <= spd_tol:\n                spd_ok = False\n            C = relaxation_step(C, lam, dt)\n            min_lam, _ = min_eigenvalue_field(C)\n            if min_lam <= spd_tol:\n                spd_ok = False\n        elif order == 'RBA':\n            # R -> B -> A\n            C = relaxation_step(C, lam, dt)\n            min_lam, _ = min_eigenvalue_field(C)\n            if min_lam <= spd_tol:\n                spd_ok = False\n            x, _ = grid_points(N)\n            s_arr = shear_profile(x, s0, s1)\n            C = coupling_step(C, s_arr, dt)\n            min_lam, _ = min_eigenvalue_field(C)\n            if min_lam <= spd_tol:\n                spd_ok = False\n            C = advection_step(C, u, dt, dx)\n            min_lam, _ = min_eigenvalue_field(C)\n            if min_lam <= spd_tol:\n                spd_ok = False\n        else:\n            raise ValueError(\"Unknown Lie order\")\n    return C, spd_ok\n\ndef run_strang_scheme(C0, u, dt, T, s0, s1, lam, spd_tol=1e-12):\n    \"\"\"\n    Run Strang splitting: A(dt/2) -> B(dt/2) -> R(dt) -> B(dt/2) -> A(dt/2)\n    Returns final C and SPD preservation boolean across all substeps.\n    \"\"\"\n    N = C0.shape[0]\n    _, dx = grid_points(N)\n    steps = int(np.round(T / dt))\n    C = C0.copy()\n    spd_ok = True\n    half_dt = 0.5 * dt\n    for _ in range(steps):\n        # A(dt/2)\n        C = advection_step(C, u, half_dt, dx)\n        min_lam, _ = min_eigenvalue_field(C)\n        if min_lam <= spd_tol:\n            spd_ok = False\n        # B(dt/2)\n        x, _ = grid_points(N)\n        s_arr = shear_profile(x, s0, s1)\n        C = coupling_step(C, s_arr, half_dt)\n        min_lam, _ = min_eigenvalue_field(C)\n        if min_lam <= spd_tol:\n            spd_ok = False\n        # R(dt)\n        C = relaxation_step(C, lam, dt)\n        min_lam, _ = min_eigenvalue_field(C)\n        if min_lam <= spd_tol:\n            spd_ok = False\n        # B(dt/2)\n        x, _ = grid_points(N)\n        s_arr = shear_profile(x, s0, s1)\n        C = coupling_step(C, s_arr, half_dt)\n        min_lam, _ = min_eigenvalue_field(C)\n        if min_lam <= spd_tol:\n            spd_ok = False\n        # A(dt/2)\n        C = advection_step(C, u, half_dt, dx)\n        min_lam, _ = min_eigenvalue_field(C)\n        if min_lam <= spd_tol:\n            spd_ok = False\n    return C, spd_ok\n\ndef rk4_step(C, x_d, t, dt, u, s0, s1, lam):\n    \"\"\"\n    One RK4 step integrating dC/dtau = A(x(tau)) C + C A^T(x(tau)) - (1/lam)(C - I)\n    along characteristic x(tau) = x_d + u*(tau - t0),\n    starting from C at tau = t and ending at tau = t + dt.\n    C: (2,2) at tau=t\n    \"\"\"\n    def A_of_x(x):\n        s = shear_profile(np.array([x]), s0, s1)[0]\n        # A = [[0, s], [0, 0]]\n        return np.array([[0.0, s], [0.0, 0.0]])\n\n    I = np.eye(2)\n\n    def F(tau, Cmat):\n        x_tau = np.mod(x_d + u * (tau - t), 1.0)\n        A = A_of_x(x_tau)\n        return A @ Cmat + Cmat @ A.T - (1.0 / lam) * (Cmat - I)\n\n    k1 = F(t, C)\n    k2 = F(t + 0.5 * dt, C + 0.5 * dt * k1)\n    k3 = F(t + 0.5 * dt, C + 0.5 * dt * k2)\n    k4 = F(t + dt, C + dt * k3)\n    C_new = C + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + 2.0 * k4)\n    # Symmetrize\n    C_new = 0.5 * (C_new + C_new.T)\n    return C_new\n\ndef run_reference(C0, u, dt, T, s0, s1, lam, M_sub=20):\n    \"\"\"\n    Unsplit reference: per coarse step, for each grid point, backtrack to departure,\n    interpolate initial C, then integrate along characteristic with RK4 with M_sub substeps.\n    Returns final C field.\n    \"\"\"\n    N = C0.shape[0]\n    x, dx = grid_points(N)\n    steps = int(np.round(T / dt))\n    C_field = C0.copy()\n    for n in range(steps):\n        t0 = n * dt\n        # Build C at departure positions\n        xd = np.mod(x - u * dt, 1.0)\n        C_init = interpolate_C_linear_periodic(C_field, xd, dx)  # (N,2,2)\n        # Integrate for each gridpoint independently\n        C_next = np.zeros_like(C_field)\n        for i in range(N):\n            Cmat = C_init[i]\n            # RK4 with M_sub substeps\n            sub_dt = dt / M_sub\n            tau = t0\n            x_d = xd[i]  # departure point\n            for _ in range(M_sub):\n                Cmat = rk4_step(Cmat, x_d, tau, sub_dt, u, s0, s1, lam)\n                tau += sub_dt\n            C_next[i] = Cmat\n        C_field = C_next\n    return C_field\n\ndef relative_error(C_approx, C_ref):\n    \"\"\"\n    Relative L2 (Frobenius) error over grid: sqrt( sum ||diff||^2 / sum ||ref||^2 )\n    \"\"\"\n    diff = C_approx - C_ref\n    num = np.sum(np.sum(diff * diff, axis=(1,2)))\n    den = np.sum(np.sum(C_ref * C_ref, axis=(1,2)))\n    if den == 0.0:\n        return 0.0\n    return float(np.sqrt(num / den))\n\ndef run_case(N, dt, s0, s1, lam, T):\n    # Initialize C=I\n    C0 = np.zeros((N, 2, 2))\n    C0[:, 0, 0] = 1.0\n    C0[:, 1, 1] = 1.0\n    u = 1.0\n    # Reference\n    C_ref = run_reference(C0, u, dt, T, s0, s1, lam, M_sub=20)\n    # ABC\n    C_abc, spd_abc = run_lie_scheme(C0, u, dt, T, s0, s1, lam, order='ABC', spd_tol=1e-12)\n    err_abc = relative_error(C_abc, C_ref)\n    # RBA\n    C_rba, spd_rba = run_lie_scheme(C0, u, dt, T, s0, s1, lam, order='RBA', spd_tol=1e-12)\n    err_rba = relative_error(C_rba, C_ref)\n    # Strang\n    C_str, spd_str = run_strang_scheme(C0, u, dt, T, s0, s1, lam, spd_tol=1e-12)\n    err_str = relative_error(C_str, C_ref)\n    return [err_abc, err_rba, err_str, spd_abc, spd_rba, spd_str]\n\ndef format_results_no_spaces(results):\n    \"\"\"\n    Format a list of per-case result lists into a single string with no spaces.\n    Each per-case list contains floats and booleans.\n    Floats are formatted with up to 8 significant digits.\n    \"\"\"\n    def fmt_val(v):\n        if isinstance(v, (float, np.floating)):\n            return f\"{v:.8g}\"\n        elif isinstance(v, (bool, np.bool_)):\n            return \"True\" if bool(v) else \"False\"\n        else:\n            # integers or others\n            return str(v)\n    parts = []\n    for sub in results:\n        sub_s = \",\".join(fmt_val(v) for v in sub)\n        parts.append(f\"[{sub_s}]\")\n    return \"[\" + \",\".join(parts) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, dt, s0, s1, lambda, T)\n    test_cases = [\n        (64, 0.05, 0.0, 0.0, 0.5, 1.0),  # Case 1: commuting advection-relaxation only\n        (64, 0.01, 2.0, 1.0, 0.5, 1.0),  # Case 2: happy path\n        (64, 0.05, 2.0, 1.0, 0.5, 1.0),  # Case 3: coarser dt\n        (64, 0.02, 6.0, 3.0, 1.5, 1.0),  # Case 4: higher Wi-like\n    ]\n\n    results = []\n    for case in test_cases:\n        N, dt, s0, s1, lam, T = case\n        res = run_case(N, dt, s0, s1, lam, T)\n        results.append(res)\n\n    # Final print statement in the exact required format: single line, comma-separated lists, no spaces.\n    print(format_results_no_spaces(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}