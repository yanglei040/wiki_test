{
    "hands_on_practices": [
        {
            "introduction": "Before solving the full Poisson system, it is essential to understand how a mapping's analytical form translates into geometric grid properties. This foundational exercise provides a direct link between a mapping's partial derivatives and key metrics such as the Jacobian, orthogonality, and cell aspect ratio . By analyzing a simple transformation with a control parameter, you will build crucial intuition for how these parameters ultimately shape the final grid.",
            "id": "3313603",
            "problem": "In the context of computational fluid dynamics (CFD) elliptic grid generation, consider a smooth mapping from computational space to physical space defined on the unit square $[0,1]\\times[0,1]$ in computational coordinates $(\\xi,\\eta)$ by\n$$\nx(\\xi,\\eta) = \\xi,\\qquad y(\\xi,\\eta) = \\eta + \\alpha \\sin(\\pi \\xi),\n$$\nwhere $\\alpha \\in \\mathbb{R}$ is a real-valued control parameter. In elliptic grid generation using Poisson equations, coordinate functions satisfy\n$$\nx_{\\xi\\xi} + x_{\\eta\\eta} = P(\\xi,\\eta),\\qquad y_{\\xi\\xi} + y_{\\eta\\eta} = Q(\\xi,\\eta),\n$$\nwith prescribed right-hand sides $P$ and $Q$ that steer grid line clustering and smoothness.\n\nStarting from the fundamental definitions of the covariant base vectors in the physical plane,\n$$\n\\mathbf{g}_{\\xi} = \\begin{pmatrix} x_{\\xi} \\\\ y_{\\xi} \\end{pmatrix},\\qquad \\mathbf{g}_{\\eta} = \\begin{pmatrix} x_{\\eta} \\\\ y_{\\eta} \\end{pmatrix},\n$$\nthe Jacobian determinant\n$$\nJ = x_{\\xi} y_{\\eta} - x_{\\eta} y_{\\xi},\n$$\nthe orthogonality error\n$$\n\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta},\n$$\nand the local cell aspect ratio (ratio of edge lengths corresponding to unit steps in $\\xi$ and $\\eta$)\n$$\nA = \\frac{\\|\\mathbf{g}_{\\xi}\\|}{\\|\\mathbf{g}_{\\eta}\\|},\n$$\nderive analytic expressions for $J(\\xi,\\eta;\\alpha)$, $\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta}(\\xi,\\eta;\\alpha)$, and $A(\\xi,\\eta;\\alpha)$. Then, based on these expressions and the Poisson formulation, briefly discuss how the parameter $\\alpha$ affects grid orthogonality and cell stretching in the physical plane.\n\nProvide your final result as the ordered triple $\\big(J,\\ \\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta},\\ A\\big)$ in closed form. No rounding is required and no units are needed.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of differential geometry applied to computational grid generation, is well-posed with sufficient information for a unique solution, and is expressed in objective, formal language. We proceed with the derivation.\n\nThe given transformation from computational coordinates $(\\xi, \\eta)$ to physical coordinates $(x, y)$ is:\n$$\nx(\\xi,\\eta) = \\xi\n$$\n$$\ny(\\xi,\\eta) = \\eta + \\alpha \\sin(\\pi \\xi)\n$$\nwhere $\\alpha$ is a real-valued parameter.\n\nFirst, we compute the first-order partial derivatives of $x$ and $y$ with respect to $\\xi$ and $\\eta$. These derivatives are the components of the covariant base vectors.\n$$\nx_{\\xi} = \\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}(\\xi) = 1\n$$\n$$\nx_{\\eta} = \\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}(\\xi) = 0\n$$\n$$\ny_{\\xi} = \\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}(\\eta + \\alpha \\sin(\\pi \\xi)) = \\alpha \\pi \\cos(\\pi \\xi)\n$$\n$$\ny_{\\eta} = \\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}(\\eta + \\alpha \\sin(\\pi \\xi)) = 1\n$$\n\nUsing these derivatives, we construct the covariant base vectors, $\\mathbf{g}_{\\xi}$ and $\\mathbf{g}_{\\eta}$:\n$$\n\\mathbf{g}_{\\xi} = \\begin{pmatrix} x_{\\xi} \\\\ y_{\\xi} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ \\alpha \\pi \\cos(\\pi \\xi) \\end{pmatrix}\n$$\n$$\n\\mathbf{g}_{\\eta} = \\begin{pmatrix} x_{\\eta} \\\\ y_{\\eta} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\nThese vectors are tangent to the grid lines of constant $\\eta$ and constant $\\xi$, respectively, in the physical $(x,y)$ plane.\n\nNext, we derive the requested quantities using their definitions.\n\n**1. Jacobian Determinant, $J(\\xi,\\eta;\\alpha)$**\nThe Jacobian determinant is defined as $J = x_{\\xi} y_{\\eta} - x_{\\eta} y_{\\xi}$. Substituting the calculated partial derivatives:\n$$\nJ = (1)(1) - (0)(\\alpha \\pi \\cos(\\pi \\xi)) = 1 - 0 = 1\n$$\nThe Jacobian determinant is constant and equal to $1$. This indicates that the transformation is locally area-preserving; a differential area element $d\\xi d\\eta$ in the computational space maps to a differential area element $dx dy$ of the same size in the physical space.\n\n**2. Orthogonality Error, $\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta}(\\xi,\\eta;\\alpha)$**\nThe orthogonality of the grid is measured by the dot product of the covariant base vectors. A value of $0$ indicates local orthogonality.\n$$\n\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta} = x_{\\xi} x_{\\eta} + y_{\\xi} y_{\\eta}\n$$\nSubstituting the derivatives:\n$$\n\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta} = (1)(0) + (\\alpha \\pi \\cos(\\pi \\xi))(1) = \\alpha \\pi \\cos(\\pi \\xi)\n$$\nThis expression quantifies the deviation from orthogonality at any point $(\\xi, \\eta)$.\n\n**3. Local Cell Aspect Ratio, $A(\\xi,\\eta;\\alpha)$**\nThe aspect ratio $A$ is the ratio of the magnitudes of the base vectors, $A = \\frac{\\|\\mathbf{g}_{\\xi}\\|}{\\|\\mathbf{g}_{\\eta}\\|}$. We first compute the magnitudes:\n$$\n\\|\\mathbf{g}_{\\xi}\\| = \\sqrt{x_{\\xi}^{2} + y_{\\xi}^{2}} = \\sqrt{1^{2} + (\\alpha \\pi \\cos(\\pi \\xi))^{2}} = \\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)}\n$$\n$$\n\\|\\mathbf{g}_{\\eta}\\| = \\sqrt{x_{\\eta}^{2} + y_{\\eta}^{2}} = \\sqrt{0^{2} + 1^{2}} = 1\n$$\nTherefore, the aspect ratio is:\n$$\nA = \\frac{\\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)}}{1} = \\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)}\n$$\n\n**Discussion of the role of $\\alpha$:**\n\nThe parameter $\\alpha$ directly controls the geometric properties of the grid in the physical plane.\n- **Grid Orthogonality**: The orthogonality error is $\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta} = \\alpha \\pi \\cos(\\pi \\xi)$. If $\\alpha=0$, the transformation reduces to the identity mapping $(x,y) = (\\xi,\\eta)$, the orthogonality error is $0$ everywhere, and the grid is a simple orthogonal Cartesian grid. For $\\alpha \\neq 0$, the grid is generally non-orthogonal. The deviation from orthogonality is directly proportional to $|\\alpha|$ and varies with $\\xi$. For any non-zero $\\alpha$, perfect orthogonality is achieved only where $\\cos(\\pi \\xi) = 0$, which occurs at $\\xi=1/2$ in the domain $[0,1]$. The maximum non-orthogonality occurs at the boundaries $\\xi=0$ and $\\xi=1$, where $|\\cos(\\pi \\xi)|=1$.\n\n- **Cell Stretching**: The local aspect ratio is $A = \\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)}$. If $\\alpha=0$, $A=1$ everywhere, indicating that cells formed by unit steps in $\\xi$ and $\\eta$ are locally square. For $\\alpha \\neq 0$, $A \\geq 1$, indicating that grid cells are stretched. The length of a cell edge in the $\\xi$-direction, $\\|\\mathbf{g}_{\\xi}\\|$, is stretched relative to the edge length in the $\\eta$-direction, $\\|\\mathbf{g}_{\\eta}\\|$. The stretching is a function of $\\alpha^2$, so its magnitude is independent of the sign of $\\alpha$. The maximum stretching occurs where $|\\cos(\\pi \\xi)|=1$ (at $\\xi=0, 1$), and there is no stretching ($A=1$) where $\\cos(\\pi \\xi)=0$ (at $\\xi=1/2$).\n\n- **Relation to Poisson Equations**: The forcing functions $P$ and $Q$ in the Poisson grid generation equations are determined by the second derivatives of the mapping functions. We can compute them for the given transformation:\n$$\nx_{\\xi\\xi} = 0, \\quad x_{\\eta\\eta} = 0 \\implies P(\\xi,\\eta) = x_{\\xi\\xi} + x_{\\eta\\eta} = 0\n$$\n$$\ny_{\\xi\\xi} = -\\alpha \\pi^{2} \\sin(\\pi \\xi), \\quad y_{\\eta\\eta} = 0 \\implies Q(\\xi,\\eta) = y_{\\xi\\xi} + y_{\\eta\\eta} = -\\alpha \\pi^{2} \\sin(\\pi \\xi)\n$$\nThis demonstrates that the parameter $\\alpha$ is directly proportional to the forcing function $Q$, which controls the curvature of the $y$-coordinate lines. A non-zero $\\alpha$ introduces a non-zero forcing term $Q$, which \"pulls\" the grid lines to create the observed non-orthogonality and stretching. Thus, $\\alpha$ acts as a control parameter for these grid properties through the mechanism of the Poisson equation's source term.\n\nIn summary, the derived expressions are:\n$J = 1$\n$\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta} = \\alpha \\pi \\cos(\\pi \\xi)$\n$A = \\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)}$\nThese form the final ordered triple.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1  \\alpha \\pi \\cos(\\pi \\xi)  \\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Moving from analytical forms to numerical implementation introduces new challenges, particularly regarding the stability of the solution. This hands-on coding exercise demonstrates a critical concept in solving discretized Poisson equations: the discrete maximum principle and its connection to the diagonal dominance of the system matrix . You will see firsthand how a loss of this property can lead to non-physical grid folding, even with smooth source terms, and learn how to implement a stabilization that ensures a valid, unfolded grid.",
            "id": "3313541",
            "problem": "Consider two-dimensional elliptic grid generation via the Poisson system for the physical mapping components $x(\\xi,\\eta)$ and $y(\\xi,\\eta)$ on the computational unit square $(\\xi,\\eta)\\in[0,1]\\times[0,1]$ with Dirichlet boundary conditions. The continuous formulation prescribes that $x$ and $y$ solve the Poisson equations with smooth source terms in the computational space. The fundamental base for this problem consists of: (i) the continuous maximum principle for the Laplace operator stating that the extrema of a harmonic function occur on the boundary; (ii) the definition of the discrete maximum principle for linear systems arising from finite-difference discretizations, which holds when the coefficient matrix is a monotone matrix (for example, an $M$-matrix) characterized by nonpositive off-diagonal entries, positive diagonal entries, and a diagonal dominance condition sufficient to ensure a nonnegative inverse; and (iii) the standard five-point finite-difference discretization of the Laplacian on a uniform grid.\n\nYour task is to demonstrate, using a concrete computable construction, that violating diagonal dominance in the discrete linear system for the Poisson grid generator can break the discrete maximum principle and produce a non-invertible grid (folded cells) even with smooth source terms and smooth boundary data; and to implement a stabilization that restores diagonal dominance and prevents folding.\n\nTo make the task fully specified, use the following setup.\n\n1. Define the exact smooth target mapping with small, smooth interior clustering:\n   - Let $A$ be the smoothness amplitude given by $A=0.158$ (dimensionless).\n   - Define\n     $$x_{\\text{exact}}(\\xi,\\eta) = \\xi + A \\sin(2\\pi \\xi)\\sin(\\pi \\eta),$$\n     $$y_{\\text{exact}}(\\xi,\\eta) = \\eta + A \\sin(2\\pi \\eta)\\sin(\\pi \\xi).$$\n   - Define the source terms by the computational-space Laplacian of the above functions:\n     $$P(\\xi,\\eta) = \\nabla^2 x_{\\text{exact}}(\\xi,\\eta) = -A\\,(5\\pi^2)\\,\\sin(2\\pi \\xi)\\sin(\\pi \\eta),$$\n     $$Q(\\xi,\\eta) = \\nabla^2 y_{\\text{exact}}(\\xi,\\eta) = -A\\,(5\\pi^2)\\,\\sin(2\\pi \\eta)\\sin(\\pi \\xi).$$\n   - Impose Dirichlet boundary conditions taken from the exact mapping $x_{\\text{exact}}$ and $y_{\\text{exact}}$ on the boundary of the unit square.\n\n2. Discretize the interior using a uniform grid with $N$ nodes per coordinate direction, so that the grid spacing is $h = 1/(N-1)$, and the number of interior points is $(N-2)^2$. Use the standard five-point stencil on the interior for the discrete Laplacian, i.e., the operator corresponding to\n   $$4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} = h^2 f_{i,j},$$\n   with boundary contributions added to the right-hand side for neighbors on the boundary.\n\n3. Construct a one-parameter family of linear systems for the interior unknowns that can violate diagonal dominance by scaling the diagonal of the discrete operator:\n   - Let $s \\in \\mathbb{R}$ be a diagonal scaling parameter. Replace the central coefficient $4$ in the standard five-point stencil by $4s$, while keeping all off-diagonals equal to $-1$. In matrix form, this yields a linear system with coefficient matrix\n     $$A_s = L + 4(s-1)I,$$\n     where $L$ is the standard five-point discrete Laplacian matrix multiplied by $h^2$ (in the form $4I -$ off-diagonals) and $I$ is the identity matrix of size $(N-2)^2\\times(N-2)^2$. Note that for $s1$ the diagonal dominance can be violated.\n   - Augment the system with a stabilization parameter $\\sigma \\ge 0$ by adding a positive multiple of the identity (a reaction term) to the operator, producing\n     $$A_{s,\\sigma} = L + 4(s-1+\\sigma)I.$$\n     For $\\sigma \\ge 1-s$, the row-wise diagonal dominance is restored to at least the standard level.\n\n4. Solve the two decoupled Poisson problems for $x$ and $y$ using the same $A_{s,\\sigma}$ and the right-hand sides determined by the source terms and boundary contributions. Reconstruct the full grid including boundaries.\n\n5. Detect grid folding by computing the discrete cell Jacobian on each computational cell using forward differences:\n   $$J_{i,j} = \\det\\begin{pmatrix}\n   x_{i+1,j} - x_{i,j}  x_{i,j+1} - x_{i,j} \\\\\n   y_{i+1,j} - y_{i,j}  y_{i,j+1} - y_{i,j}\n   \\end{pmatrix}.$$\n   A folded cell is detected if any $J_{i,j} \\le 0$.\n\n6. Your program must implement the above and return, for each test case, a boolean indicating whether any cell is folded (i.e., whether there exists $J_{i,j} \\le 0$). The program must not require any user input.\n\nUse the following test suite, which includes a baseline case, an unstable non-diagonally-dominant case, a stabilized case, and a near-dominance edge case:\n- Test case $1$: $N=41$, $s=1.0$, $\\sigma=0.0$.\n- Test case $2$: $N=41$, $s=0.1$, $\\sigma=0.0$.\n- Test case $3$: $N=41$, $s=0.1$, $\\sigma=1.0$.\n- Test case $4$: $N=16$, $s=0.95$, $\\sigma=0.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases, for example, in the form $[r_1,r_2,r_3,r_4]$ where each $r_k$ is the boolean result for test case $k$ indicating whether folding occurs. No physical units are required. Angles used inside trigonometric functions are in radians. The final outputs are booleans and require no rounding.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of computational fluid dynamics and numerical analysis, specifically concerning elliptic grid generation via Poisson's equation. The problem is well-posed, providing a complete and consistent set of definitions, parameters, and boundary conditions for a numerical experiment. The objective is to demonstrate the importance of diagonal dominance in the discretized linear system for maintaining grid quality (i.e., preventing folding). This is a standard and insightful exercise in scientific computing. All terms are formally defined, and the task is computationally verifiable.\n\nThe solution proceeds as follows:\n\nFirst, we establish the computational domain, a unit square in $(\\xi, \\eta)$ coordinates, discretized by a uniform grid of size $N \\times N$. The grid spacing is $h = 1/(N-1)$. The grid points are $(\\xi_i, \\eta_j) = (i h, j h)$ for $i, j = 0, \\dots, N-1$.\n\nThe problem requires solving two decoupled Poisson equations for the physical coordinates $x(\\xi, \\eta)$ and $y(\\xi, \\eta)$:\n$$ \\nabla^2 x = P(\\xi, \\eta) $$\n$$ \\nabla^2 y = Q(\\xi, \\eta) $$\nwhere $\\nabla^2 = \\frac{\\partial^2}{\\partial \\xi^2} + \\frac{\\partial^2}{\\partial \\eta^2}$. The source terms $P$ and $Q$ and the Dirichlet boundary conditions are derived from a known exact mapping:\n$$ x_{\\text{exact}}(\\xi,\\eta) = \\xi + A \\sin(2\\pi \\xi)\\sin(\\pi \\eta) $$\n$$ y_{\\text{exact}}(\\xi,\\eta) = \\eta + A \\sin(2\\pi \\eta)\\sin(\\pi \\xi) $$\nwith amplitude $A = 0.158$. The source terms are $P = \\nabla^2 x_{\\text{exact}}$ and $Q = \\nabla^2 y_{\\text{exact}}$, which are given by:\n$$ P(\\xi,\\eta) = -A(5\\pi^2)\\sin(2\\pi \\xi)\\sin(\\pi \\eta) $$\n$$ Q(\\xi,\\eta) = -A(5\\pi^2)\\sin(2\\pi \\eta)\\sin(\\pi \\xi) $$\n\nThe core of the problem lies in the discretization of the Poisson equation. A modified five-point stencil is used for the interior points $(i, j)$ where $i, j \\in \\{1, \\dots, N-2\\}$:\n$$ 4(s+\\sigma) u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} = h^2 f_{i,j} $$\nHere, $u$ stands for either $x$ or $y$, and $f$ for $P$ or $Q$. The parameters $s$ and $\\sigma$ control the diagonal entries of the resulting linear system's matrix, affecting its diagonal dominance. For an interior node, the diagonal entry is $4(s+\\sigma)$, while the sum of the magnitudes of the off-diagonal entries is $4$. Diagonal dominance is guaranteed if $|4(s+\\sigma)| \\ge 4$, which simplifies to $s+\\sigma \\ge 1$.\n\nWe formulate a linear system $A_{s,\\sigma} \\mathbf{u} = \\mathbf{b}$ for the $(N-2)^2$ unknown values of $x$ and $y$ at the interior grid points. The matrix $A_{s,\\sigma}$ is constructed based on the modified stencil. For each interior point $(i,j)$, the corresponding row in the linear system is built. The diagonal element of the matrix is $4(s+\\sigma)$, and off-diagonal elements are $-1$ for each interior neighbor. If a neighbor $(i', j')$ is on the boundary, its value $u_{i',j'}$ is known from the Dirichlet condition (evaluated from $x_{\\text{exact}}$ or $y_{\\text{exact}}$). This known value is moved to the right-hand side of the equation. Thus, the right-hand side vector $\\mathbf{b}$ for a given interior point $(i,j)$ consists of the scaled source term $h^2 f_{i,j}$ plus the sum of any boundary values from adjacent cells.\n\nThe two resulting sparse linear systems, one for the $x$ coordinates and one for the $y$ coordinates, are solved to find the values at the interior grid points. These solutions are then combined with the known boundary values to form the complete $N \\times N$ grid of physical coordinates $(x_{i,j}, y_{i,j})$.\n\nThe final step is to check for grid folding. A grid is considered folded if any of its cells have a non-positive area or are oriented incorrectly. This is detected by computing the Jacobian of the mapping for each quadrilateral cell. For a cell with its bottom-left corner at $(\\xi_i, \\eta_j)$, the Jacobian $J_{i,j}$ is calculated using forward differences:\n$$ J_{i,j} = \\det\\begin{pmatrix}\nx_{i+1,j} - x_{i,j}  x_{i,j+1} - x_{i,j} \\\\\ny_{i+1,j} - y_{i,j}  y_{i,j+1} - y_{i,j}\n\\end{pmatrix} $$\nThis is computed for all cells, where $i, j = 0, \\dots, N-2$. If any $J_{i,j} \\le 0$, it signifies a locally non-invertible mapping, and the grid is flagged as folded. The boolean result `True` (folded) or `False` (not folded) is determined for each test case.\n\nThe implementation details involve:\n1.  Setting up the computational grid coordinates.\n2.  Evaluating the exact solution on the boundaries and the source terms in the interior.\n3.  Constructing the sparse matrix $A_{s,\\sigma}$ and the right-hand-side vectors $\\mathbf{b}_x$ and $\\mathbf{b}_y$. The an index mapping from 2D grid indices $(i, j)$ to a 1D vector index $k$ is used, e.g., $k = (j-1)(N-2) + (i-1)$ for $i,j \\in \\{1, \\dots, N-2\\}$.\n4.  Solving the sparse linear systems using `scipy.sparse.linalg.spsolve`.\n5.  Reconstructing the full $N \\times N$ solution grids for $x$ and $y$.\n6.  Vectorizing the Jacobian calculation over all $(N-1) \\times (N-1)$ cells for efficiency.\n7.  Returning `True` if any Jacobian is less than or equal to zero, and `False` otherwise.\nThis procedure is applied to each of the specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef run_case(N, s, sigma, A_const):\n    \"\"\"\n    Sets up and solves the Poisson grid generation problem for a single test case.\n\n    Args:\n        N (int): Number of grid points in each direction.\n        s (float): Diagonal scaling parameter.\n        sigma (float): Stabilization parameter.\n        A_const (float): Amplitude for the exact solution.\n\n    Returns:\n        bool: True if the grid is folded, False otherwise.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    n_interior = (N - 2)**2\n\n    # 1. Computational grid and function definitions\n    xi_1d = np.linspace(0.0, 1.0, N)\n    eta_1d = np.linspace(0.0, 1.0, N)\n    # With indexing='xy', array[j, i] corresponds to (xi_i, eta_j)\n    xi_grid, eta_grid = np.meshgrid(xi_1d, eta_1d, indexing='xy')\n\n    def x_exact_func(xi, eta):\n        return xi + A_const * np.sin(2.0 * np.pi * xi) * np.sin(np.pi * eta)\n\n    def y_exact_func(xi, eta):\n        return eta + A_const * np.sin(2.0 * np.pi * eta) * np.sin(np.pi * xi)\n\n    def p_source_func(xi, eta):\n        return -A_const * (5.0 * np.pi**2) * np.sin(2.0 * np.pi * xi) * np.sin(np.pi * eta)\n\n    def q_source_func(xi, eta):\n        return -A_const * (5.0 * np.pi**2) * np.sin(2.0 * np.pi * eta) * np.sin(np.pi * xi)\n\n    # 2. Evaluate boundary conditions and source terms\n    x_exact_grid = x_exact_func(xi_grid, eta_grid)\n    y_exact_grid = y_exact_func(xi_grid, eta_grid)\n\n    P_interior = p_source_func(xi_grid[1:-1, 1:-1], eta_grid[1:-1, 1:-1])\n    Q_interior = q_source_func(xi_grid[1:-1, 1:-1], eta_grid[1:-1, 1:-1])\n\n    # 3. Assemble matrix A and RHS vectors b_x, b_y\n    rows, cols, data = [], [], []\n    b_x = np.zeros(n_interior)\n    b_y = np.zeros(n_interior)\n    \n    # Loop over interior grid points (eta_j, xi_i)\n    for j in range(1, N - 1):  # Index for eta\n        for i in range(1, N - 1):  # Index for xi\n            k = (j - 1) * (N - 2) + (i - 1)  # Row-major 1D index\n\n            rows.append(k)\n            cols.append(k)\n            data.append(4.0 * (s + sigma))\n            \n            b_x[k] = h**2 * P_interior[j-1, i-1]\n            b_y[k] = h**2 * Q_interior[j-1, i-1]\n\n            # Neighbors: west, east, south, north\n            if i == 1: # West boundary\n                b_x[k] += x_exact_grid[j, 0]\n                b_y[k] += y_exact_grid[j, 0]\n            else:\n                rows.append(k); cols.append(k - 1); data.append(-1.0)\n            \n            if i == N - 2: # East boundary\n                b_x[k] += x_exact_grid[j, N - 1]\n                b_y[k] += y_exact_grid[j, N - 1]\n            else:\n                rows.append(k); cols.append(k + 1); data.append(-1.0)\n\n            if j == 1: # South boundary\n                b_x[k] += x_exact_grid[0, i]\n                b_y[k] += y_exact_grid[0, i]\n            else:\n                rows.append(k); cols.append(k - (N - 2)); data.append(-1.0)\n                \n            if j == N - 2: # North boundary\n                b_x[k] += x_exact_grid[N - 1, i]\n                b_y[k] += y_exact_grid[N - 1, i]\n            else:\n                rows.append(k); cols.append(k + (N - 2)); data.append(-1.0)\n\n    A_matrix = coo_matrix((data, (rows, cols)), shape=(n_interior, n_interior)).tocsc()\n    \n    # 4. Solve linear systems\n    try:\n        x_interior_sol = spsolve(A_matrix, b_x)\n        y_interior_sol = spsolve(A_matrix, b_y)\n    except np.linalg.LinAlgError:\n        # A singular matrix implies catastrophic failure of the grid generation.\n        return True\n\n    # 5. Reconstruct full grid solution\n    x_sol = np.copy(x_exact_grid)\n    y_sol = np.copy(y_exact_grid)\n    x_sol[1:-1, 1:-1] = x_interior_sol.reshape((N - 2, N - 2))\n    y_sol[1:-1, 1:-1] = y_interior_sol.reshape((N - 2, N - 2))\n\n    # 6. Check for grid folding by computing cell Jacobians\n    # J_ij = (x_{i+1,j}-x_{ij})(y_{i,j+1}-y_{ij}) - (x_{i,j+1}-x_{ij})(y_{i+1,j}-y_{ij})\n    # x_{i,j} - x_sol[j,i]\n    \n    dx_dxi = x_sol[:, 1:] - x_sol[:, :-1]   # shape (N, N-1)\n    dy_dxi = y_sol[:, 1:] - y_sol[:, :-1]\n    dx_deta = x_sol[1:, :] - x_sol[:-1, :]   # shape (N-1, N)\n    dy_deta = y_sol[1:, :] - y_sol[:-1, :]\n\n    J = dx_dxi[:-1, :] * dy_deta[:, :-1] - dx_deta[:, :-1] * dy_dxi[:-1, :]\n\n    return np.any(J = 0)\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (41, 1.0, 0.0),  # Baseline, diagonally dominant\n        (41, 0.1, 0.0),  # Not diagonally dominant, unstable\n        (41, 0.1, 1.0),  # Stabilized\n        (16, 0.95, 0.0),  # Near-dominance edge case\n    ]\n\n    results = []\n    A_const = 0.158\n    for case in test_cases:\n        N, s, sigma = case\n        is_folded = run_case(N, s, sigma, A_const)\n        results.append(is_folded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The true power of elliptic grid generation with Poisson equations lies in the ability to intelligently control grid structure using the source terms $P$ and $Q$. This advanced practice simulates a common scenario in CFD where one wishes to adapt the grid to anticipated flow features, such as a vortex pair . By designing source terms that mimic a physical flow field, you will explore how grid lines can be guided to wrap around areas of high vorticity, a key strategy for creating high-quality, solution-adaptive meshes.",
            "id": "3313605",
            "problem": "Consider the classical elliptic grid generation framework used in Computational Fluid Dynamics (CFD). Let the computational coordinates be $\\xi \\in [0,1]$ and $\\eta \\in [0,1]$ on a uniform lattice, and let the physical mapping be $(x(\\xi,\\eta), y(\\xi,\\eta))$. The elliptic grid generation by Poisson equations prescribes the coordinate functions through the equations\n$$\nx_{\\xi\\xi} + x_{\\eta\\eta} = P(\\xi,\\eta), \\quad y_{\\xi\\xi} + y_{\\eta\\eta} = Q(\\xi,\\eta),\n$$\nwith Dirichlet boundary conditions fixing the boundary to the identity mapping, namely $x(\\xi,0)=\\xi$, $x(\\xi,1)=\\xi$, $x(0,\\eta)=0$, $x(1,\\eta)=1$ and $y(\\xi,0)=0$, $y(\\xi,1)=1$, $y(0,\\eta)=\\eta$, $y(1,\\eta)=\\eta$.\n\nYou are to design an experiment in which virtual point sources and sinks in the control functions $P$ and $Q$ mimic a vortex pair, and then examine whether coordinate lines wrap similarly to streamlines of the imposed vortex field. The experiment must proceed from first principles, using the following well-tested base: a two-dimensional, inviscid, incompressible point vortex of circulation strength $\\Gamma$ located at $(c_x,c_y)$ produces a velocity field\n$$\nu(\\xi,\\eta) = -\\frac{\\Gamma}{2\\pi} \\frac{\\eta-c_y}{(\\xi-c_x)^2 + (\\eta-c_y)^2}, \\quad\nv(\\xi,\\eta) = \\phantom{-}\\frac{\\Gamma}{2\\pi} \\frac{\\xi-c_x}{(\\xi-c_x)^2 + (\\eta-c_y)^2}.\n$$\nTo ensure numerical stability and physical realism, regularize the singularity by replacing the denominator with $(\\xi-c_x)^2 + (\\eta-c_y)^2 + \\varepsilon^2$, where $\\varepsilon0$ is a core size. Construct a vortex pair by superposing two such vortices of equal and opposite strengths $+\\Gamma$ and $-\\Gamma$ centered at $(c_{1x},c_{1y})$ and $(c_{2x},c_{2y})$, respectively. Define the control functions by a scalar scaling $k$ applied to the velocity components:\n$$\nP(\\xi,\\eta) = k\\,u_{\\text{pair}}(\\xi,\\eta), \\quad Q(\\xi,\\eta) = k\\,v_{\\text{pair}}(\\xi,\\eta),\n$$\nwhere $(u_{\\text{pair}}, v_{\\text{pair}})$ is the sum of the regularized velocities induced by both vortices.\n\nImplement a finite-difference solver for the above Poisson equations on a uniform $\\xi$–$\\eta$ grid with spacing $h=\\frac{1}{N-1}$ for a chosen integer $N\\ge 5$. Use a Gauss–Seidel iteration for the interior nodes to obtain $(x,y)$, starting from the identity mapping as the initial guess. Stop iterating when the maximum absolute change in any interior node for both $x$ and $y$ drops below a tolerance $10^{-6}$, or when $10^4$ iterations are reached, whichever comes first.\n\nAfter computing $(x,y)$, estimate the local tangents to the coordinate lines by centered differences:\n$$\n\\mathbf{t}_\\xi = \\big(x_\\xi, y_\\xi\\big), \\quad \\mathbf{t}_\\eta = \\big(x_\\eta, y_\\eta\\big),\n$$\nand evaluate the regularized vortex-pair velocity $(u_{\\text{pair}}, v_{\\text{pair}})$ on the same lattice. For each interior node where the tangent and the velocity magnitudes exceed a small threshold (e.g., $10^{-12}$), compute the unsigned misalignment angles (in radians) between $\\mathbf{t}_\\xi$ and the local streamline direction, and between $\\mathbf{t}_\\eta$ and the local streamline direction:\n$$\n\\theta_\\xi = \\arccos\\left(\\frac{\\left|\\mathbf{t}_\\xi \\cdot \\mathbf{s}\\right|}{\\|\\mathbf{t}_\\xi\\|\\,\\|\\mathbf{s}\\|}\\right), \\quad\n\\theta_\\eta = \\arccos\\left(\\frac{\\left|\\mathbf{t}_\\eta \\cdot \\mathbf{s}\\right|}{\\|\\mathbf{t}_\\eta\\|\\,\\|\\mathbf{s}\\|}\\right),\n$$\nwhere $\\mathbf{s} = (u_{\\text{pair}}, v_{\\text{pair}})$ is the local velocity vector and $\\|\\cdot\\|$ denotes the Euclidean norm. Aggregate these into a single scalar by averaging over all interior nodes:\n$$\n\\bar{\\theta} = \\frac{1}{2}\\left(\\operatorname{mean}(\\theta_\\xi) + \\operatorname{mean}(\\theta_\\eta)\\right).\n$$\nAdditionally, estimate the local Jacobian determinant of the coordinate transformation,\n$$\nJ = x_\\xi y_\\eta - x_\\eta y_\\xi,\n$$\nand report whether $J0$ holds at all interior nodes (a boolean indicating absence of folding). Use centered differences for interior nodes to compute $x_\\xi$, $x_\\eta$, $y_\\xi$, $y_\\eta$.\n\nDesign a test suite of three cases to explore the behavior:\n- Case $1$ (happy path): $N=51$, $\\Gamma=1.0$, $\\varepsilon=0.02$, $k=0.02$, $(c_{1x},c_{1y})=(0.35,0.50)$, $(c_{2x},c_{2y})=(0.65,0.50)$.\n- Case $2$ (near-Laplace baseline): $N=51$, $\\Gamma=1.0$, $\\varepsilon=0.02$, $k=0.0$, $(c_{1x},c_{1y})=(0.35,0.50)$, $(c_{2x},c_{2y})=(0.65,0.50)$.\n- Case $3$ (stronger control): $N=51$, $\\Gamma=1.0$, $\\varepsilon=0.015$, $k=0.08$, $(c_{1x},c_{1y})=(0.35,0.50)$, $(c_{2x},c_{2y})=(0.65,0.50)$.\n\nYour program must solve the grid for each case, compute $\\bar{\\theta}$ in radians and the boolean $\\text{all\\_positive\\_Jacobian}$ indicating whether $J0$ at all interior nodes, and then produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[\\bar{\\theta}_1,\\text{all\\_positive\\_Jacobian}_1,\\bar{\\theta}_2,\\text{all\\_positive\\_Jacobian}_2,\\bar{\\theta}_3,\\text{all\\_positive\\_Jacobian}_3].\n$$\nAngles must be reported in radians. No external input is permitted, and the program must run self-contained.",
            "solution": "The problem requires the numerical solution of a set of two Poisson equations for elliptic grid generation on a unit square, and a subsequent analysis of the resulting grid geometry. The process is divided into four main stages: problem formulation, discretization, numerical solution, and post-processing analysis.\n\nThe physical coordinates $(x, y)$ are to be determined as functions of the computational coordinates $(\\xi, \\eta)$, where $(\\xi, \\eta)$ form a uniform lattice on the unit square $[0,1] \\times [0,1]$. The governing equations are a pair of Poisson equations:\n$$\n\\nabla^2 x = x_{\\xi\\xi} + x_{\\eta\\eta} = P(\\xi,\\eta)\n$$\n$$\n\\nabla^2 y = y_{\\xi\\xi} + y_{\\eta\\eta} = Q(\\xi,\\eta)\n$$\nThe functions $P(\\xi,\\eta)$ and $Q(\\xi,\\eta)$ are control functions used to influence the grid characteristics. The boundary conditions are of the Dirichlet type, mapping the boundary of the computational square to the boundary of the physical square identically:\n$$\n\\begin{align*}\nx(\\xi,0) = \\xi,  x(\\xi,1) = \\xi,  x(0,\\eta) = 0,  x(1,\\eta) = 1 \\\\\ny(\\xi,0) = 0,  y(\\xi,1) = 1,  y(0,\\eta) = \\eta,  y(1,\\eta) = \\eta\n\\end{align*}\n$$\nThe control functions are constructed from the velocity field of a regularized vortex pair. A single vortex of strength $\\Gamma$ at $(c_x, c_y)$ with a regularization core size $\\varepsilon$ has the velocity field $(u,v)$:\n$$\n u(\\xi,\\eta) = -\\frac{\\Gamma}{2\\pi} \\frac{\\eta-c_y}{(\\xi-c_x)^2 + (\\eta-c_y)^2 + \\varepsilon^2}, \\quad\n v(\\xi,\\eta) = \\phantom{-}\\frac{\\Gamma}{2\\pi} \\frac{\\xi-c_x}{(\\xi-c_x)^2 + (\\eta-c_y)^2 + \\varepsilon^2}\n$$\nThe vortex pair field $(u_{\\text{pair}}, v_{\\text{pair}})$ is the superposition of two such vortices: one with strength $+\\Gamma$ at $(c_{1x},c_{1y})$ and another with strength $-\\Gamma$ at $(c_{2x},c_{2y})$. The control functions are then defined as $P(\\xi,\\eta) = k\\,u_{\\text{pair}}(\\xi,\\eta)$ and $Q(\\xi,\\eta) = k\\,v_{\\text{pair}}(\\xi,\\eta)$, where $k$ is a scaling factor.\n\nTo solve this system numerically, we discretize the computational domain into a uniform grid of $N \\times N$ points. The grid spacing in both directions is $h = 1/(N-1)$. Let $x_{i,j} = x(i h, j h)$ and $y_{i,j} = y(i h, j h)$ for $i,j \\in \\{0, 1, \\dots, N-1\\}$. The Laplacian operator $\\nabla^2$ is approximated at each interior node $(i,j)$ using a second-order central difference scheme:\n$$\n\\nabla^2 x |_{i,j} \\approx \\frac{x_{i+1,j} - 2x_{i,j} + x_{i-1,j}}{h^2} + \\frac{x_{i,j+1} - 2x_{i,j} + x_{i,j-1}}{h^2}\n$$\nApplying this to the Poisson equation for $x$ yields the discrete equation:\n$$\nx_{i+1,j} + x_{i-1,j} + x_{i,j+1} + x_{i,j-1} - 4x_{i,j} = h^2 P_{i,j}\n$$\nA similar equation holds for $y_{i,j}$.\n\nThe resulting system of linear algebraic equations for the interior nodes is solved using the Gauss-Seidel iterative method. Starting with an initial guess, which is the identity mapping ($x_{i,j} = i h$, $y_{i,j} = j h$), the value at each interior node $(i,j)$ is updated using the most recently computed values of its neighbors. The iterative update formula for $x_{i,j}$ at iteration $k+1$ is:\n$$\nx_{i,j}^{(k+1)} = \\frac{1}{4} \\left( x_{i+1,j}^{(k)} + x_{i-1,j}^{(k+1)} + x_{i,j+1}^{(k)} + x_{i,j-1}^{(k+1)} - h^2 P_{i,j} \\right)\n$$\nA similar update is performed for $y_{i,j}$. This process is repeated until the maximum absolute change in any interior node's value for both $x$ and $y$ between successive iterations falls below a tolerance of $10^{-6}$, or a maximum of $10^4$ iterations is reached.\n\nAfter convergence, we analyze the resulting grid. First, we compute the tangents to the coordinate lines, $\\mathbf{t}_\\xi = (x_\\xi, y_\\xi)$ and $\\mathbf{t}_\\eta = (x_\\eta, y_\\eta)$, at each interior node using second-order centered-differences:\n$$\nx_\\xi \\approx \\frac{x_{i+1,j} - x_{i-1,j}}{2h}, \\quad x_\\eta \\approx \\frac{x_{i,j+1} - x_{i,j-1}}{2h}, \\quad \\text{etc. for } y\n$$\nThe unsigned misalignment angles, $\\theta_\\xi$ and $\\theta_\\eta$, between these tangents and the local streamline direction vector $\\mathbf{s} = (u_{\\text{pair}}, v_{\\text{pair}})$ are calculated:\n$$\n\\theta_\\xi = \\arccos\\left(\\frac{\\left|\\mathbf{t}_\\xi \\cdot \\mathbf{s}\\right|}{\\|\\mathbf{t}_\\xi\\|\\,\\|\\mathbf{s}\\|}\\right), \\quad \\theta_\\eta = \\arccos\\left(\\frac{\\left|\\mathbf{t}_\\eta \\cdot \\mathbf{s}\\right|}{\\|\\mathbf{t}_\\eta\\|\\,\\|\\mathbf{s}\\|}\\right)\n$$\nThese are computed only at nodes where vector magnitudes are above a threshold $10^{-12}$. The average misalignment $\\bar{\\theta}$ is then calculated as $\\bar{\\theta} = \\frac{1}{2}(\\text{mean}(\\theta_\\xi) + \\text{mean}(\\theta_\\eta))$.\nFinally, we evaluate the Jacobian determinant of the transformation, $J = x_\\xi y_\\eta - x_\\eta y_\\xi$, at all interior nodes. A positive Jacobian everywhere ($J0$) signifies that the grid has not folded over itself, which is a critical quality metric for a valid grid. A boolean flag is reported based on this check. This entire procedure is executed for three distinct test cases to explore the effect of the control function strength.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (N, Gamma, epsilon, k, c1, c2)\n    test_cases = [\n        # Case 1: happy path\n        (51, 1.0, 0.02, 0.02, (0.35, 0.50), (0.65, 0.50)),\n        # Case 2: near-Laplace baseline\n        (51, 1.0, 0.02, 0.0, (0.35, 0.50), (0.65, 0.50)),\n        # Case 3: stronger control\n        (51, 1.0, 0.015, 0.08, (0.35, 0.50), (0.65, 0.50)),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        bar_theta, all_positive_jacobian = run_case(*case_params)\n        results.append(f\"{bar_theta:.12f}\")\n        results.append(str(all_positive_jacobian).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef run_case(N, Gamma, epsilon, k, c1, c2):\n    \"\"\"\n    Solves the grid generation problem for a single set of parameters.\n    \"\"\"\n    # Unpack vortex centers\n    c1x, c1y = c1\n    c2x, c2y = c2\n\n    # Grid setup\n    h = 1.0 / (N - 1)\n    xi_coords = np.linspace(0.0, 1.0, N)\n    eta_coords = np.linspace(0.0, 1.0, N)\n    XI, ETA = np.meshgrid(xi_coords, eta_coords, indexing='ij')\n\n    # --- Step 1: Compute source terms P and Q ---\n    def vortex_velocity(grid_XI, grid_ETA, G, center, eps):\n        cx_v, cy_v = center\n        den = (grid_XI - cx_v)**2 + (grid_ETA - cy_v)**2 + eps**2\n        u = -(G / (2 * np.pi)) * (grid_ETA - cy_v) / den\n        v =  (G / (2 * np.pi)) * (grid_XI - cx_v) / den\n        return u, v\n\n    u1, v1 = vortex_velocity(XI, ETA, Gamma, c1, epsilon)\n    u2, v2 = vortex_velocity(XI, ETA, -Gamma, c2, epsilon)\n    \n    u_pair = u1 + u2\n    v_pair = v1 + v2\n    \n    P = k * u_pair\n    Q = k * v_pair\n\n    # --- Step 2: Solve the Poisson equations using Gauss-Seidel ---\n    x = XI.copy()\n    y = ETA.copy()\n\n    tol = 1e-6\n    max_iter = 10000\n    h2 = h**2\n    \n    for _ in range(max_iter):\n        x_old = x.copy()\n        y_old = y.copy()\n        \n        # Explicit point-wise Gauss-Seidel iteration over interior nodes\n        for i in range(1, N - 1):\n            for j in range(1, N - 1):\n                x[i, j] = 0.25 * (x[i+1, j] + x[i-1, j] + x[i, j+1] + x[i, j-1] - h2 * P[i, j])\n                y[i, j] = 0.25 * (y[i+1, j] + y[i-1, j] + y[i, j+1] + y[i, j-1] - h2 * Q[i, j])\n\n        # Check for convergence\n        max_change = np.max([np.abs(x - x_old), np.abs(y - y_old)])\n        if max_change  tol:\n            break\n\n    # --- Step 3: Post-processing and analysis ---\n    # Compute derivatives on interior nodes using centered differences\n    x_xi = (x[2:, 1:-1] - x[:-2, 1:-1]) / (2 * h)\n    x_eta = (x[1:-1, 2:] - x[1:-1, :-2]) / (2 * h)\n    y_xi = (y[2:, 1:-1] - y[:-2, 1:-1]) / (2 * h)\n    y_eta = (y[1:-1, 2:] - y[1:-1, :-2]) / (2 * h)\n\n    # Calculate Jacobian determinant and check for folding\n    J = x_xi * y_eta - x_eta * y_xi\n    all_positive_jacobian = np.all(J  0)\n\n    # Calculate misalignment angles\n    s_u = u_pair[1:-1, 1:-1]\n    s_v = v_pair[1:-1, 1:-1]\n    \n    # Calculate magnitudes of tangent and streamline vectors\n    norm_t_xi = np.sqrt(x_xi**2 + y_xi**2)\n    norm_t_eta = np.sqrt(x_eta**2 + y_eta**2)\n    norm_s = np.sqrt(s_u**2 + s_v**2)\n\n    # Filter nodes where magnitudes are too small\n    mag_tol = 1e-12\n    valid_mask = (norm_t_xi  mag_tol)  (norm_t_eta  mag_tol)  (norm_s  mag_tol)\n    \n    # Compute dot products only for valid nodes\n    dot_xi_s = x_xi[valid_mask] * s_u[valid_mask] + y_xi[valid_mask] * s_v[valid_mask]\n    dot_eta_s = x_eta[valid_mask] * s_u[valid_mask] + y_eta[valid_mask] * s_v[valid_mask]\n\n    # Filtered norms\n    norm_t_xi_f = norm_t_xi[valid_mask]\n    norm_t_eta_f = norm_t_eta[valid_mask]\n    norm_s_f = norm_s[valid_mask]\n\n    # Calculate angles, clipping to avoid domain errors with arccos\n    cos_arg_xi = np.clip(np.abs(dot_xi_s) / (norm_t_xi_f * norm_s_f), -1.0, 1.0)\n    cos_arg_eta = np.clip(np.abs(dot_eta_s) / (norm_t_eta_f * norm_s_f), -1.0, 1.0)\n\n    theta_xi = np.arccos(cos_arg_xi)\n    theta_eta = np.arccos(cos_arg_eta)\n    \n    # Compute the final average misalignment angle\n    if theta_xi.size == 0 and theta_eta.size == 0:\n        bar_theta = 0.0\n    else:\n        mean_xi = np.mean(theta_xi) if theta_xi.size  0 else 0.0\n        mean_eta = np.mean(theta_eta) if theta_eta.size  0 else 0.0\n        bar_theta = 0.5 * (mean_xi + mean_eta)\n\n    return bar_theta, all_positive_jacobian\n\nsolve()\n```"
        }
    ]
}