{
    "hands_on_practices": [
        {
            "introduction": "Effective boundary-layer meshing is a balancing act between accuracy and computational cost. This practice guides you through the fundamental optimization problem at the heart of this trade-off . By minimizing the number of mesh layers subject to critical constraints like the wall-unit distance ($y^+$) and total boundary layer thickness, you will derive the optimal parameters for a 1D stack of cells, building a foundational understanding for all subsequent meshing tasks.",
            "id": "3296993",
            "problem": "A boundary-layer mesh is to be generated using a geometric progression of wall-normal layer thicknesses. Let the first layer thickness be $\\Delta y_{1}$ and the $i$-th layer thickness be $\\Delta y_{i} = \\Delta y_{1}\\,r^{i-1}$, with growth factor $r>1$. The total thickness of a column of $N_{\\ell}$ layers is then $$\\sum_{i=1}^{N_{\\ell}} \\Delta y_{i} = \\Delta y_{1}\\,\\frac{r^{N_{\\ell}} - 1}{r - 1}.$$ You are tasked with minimizing the number of degrees of freedom (DOF) associated with the wall-normal layering, which in this column is proportional to the layer count $N_{\\ell}$, subject to two design constraints used in computational fluid dynamics boundary-layer mesh generation:\n\n1. The wall unit constraint on the first cell height, defined by the friction-velocity-based wall unit $y^{+}$, requires $y^{+}_{1} \\leq y^{+}_{\\max}$, where $$y^{+}_{1} = \\frac{\\Delta y_{1}\\,u_{\\tau}}{\\nu},$$ with $u_{\\tau}$ the friction velocity and $\\nu$ the kinematic viscosity.\n\n2. The total wall-normal coverage of the boundary-layer mesh must meet or exceed a target thickness $\\delta$, i.e., $$\\sum_{i=1}^{N_{\\ell}} \\Delta y_{i} \\geq \\delta.$$\n\nAdditionally, for mesh quality, the growth factor is bounded above by a prescribed limit $r_{\\max}>1$ (i.e., $1<r\\leq r_{\\max}$). Assume the flow parameters $u_{\\tau}$, $\\nu$, $y^{+}_{\\max}$, and the target coverage $\\delta$ are known positive constants, and that the DOF cost depends only on $N_{\\ell}$. For the purpose of continuous optimization, relax $N_{\\ell}\\in\\mathbb{N}$ to $N_{\\ell}\\in\\mathbb{R}_{+}$.\n\nFormulate the constrained optimization problem to minimize $N_{\\ell}$ with decision variables $N_{\\ell}$ and $r$, treating $\\Delta y_{1}$ as determined by the $y^{+}$ constraint, and derive the Karush–Kuhn–Tucker (KKT) conditions. Use these conditions, together with first principles and the geometric-series relation, to obtain a closed-form analytic expression for the optimal continuous layer count $N_{\\ell}^{\\ast}$ in terms of $\\delta$, $\\nu$, $u_{\\tau}$, $y^{+}_{\\max}$, and $r_{\\max}$. Express your final answer as a single analytic expression. No numerical evaluation is required. If any rounding were necessary, it would be specified via significant figures, but do not round here. The final answer is dimensionless and requires no units.",
            "solution": "The problem is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n-   The thickness of the $i$-th layer is $\\Delta y_{i} = \\Delta y_{1}\\,r^{i-1}$, where $r>1$ is the growth factor.\n-   The total thickness of $N_{\\ell}$ layers is $\\sum_{i=1}^{N_{\\ell}} \\Delta y_{i} = \\Delta y_{1}\\,\\frac{r^{N_{\\ell}} - 1}{r - 1}$.\n-   The objective is to minimize the number of layers, $N_{\\ell}$.\n-   Constraint 1: Wall unit constraint, $y^{+}_{1} \\leq y^{+}_{\\max}$, where $y^{+}_{1} = \\frac{\\Delta y_{1}\\,u_{\\tau}}{\\nu}$.\n-   Constraint 2: Total thickness constraint, $\\sum_{i=1}^{N_{\\ell}} \\Delta y_{i} \\geq \\delta$.\n-   Constraint 3: Growth factor upper bound, $r \\leq r_{\\max}$, with $r>1$.\n-   Known positive constants: friction velocity $u_{\\tau}$, kinematic viscosity $\\nu$, maximum wall unit $y^{+}_{\\max}$, target thickness $\\delta$, and maximum growth factor $r_{\\max} > 1$.\n-   The layer count $N_{\\ell}$ is relaxed from $\\mathbb{N}$ to $\\mathbb{R}_{+}$.\n-   Decision variables are $N_{\\ell}$ and $r$.\n-   $\\Delta y_{1}$ is to be treated as determined by the $y^{+}$ constraint.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientifically Grounded:** The problem uses standard and correct formulae for a geometric progression of layer thicknesses in boundary-layer meshing, a common practice in Computational Fluid Dynamics (CFD). The $y^{+}$ constraint is a fundamental concept in wall-resolved turbulence modeling. The problem is scientifically sound.\n-   **Well-Posed:** The problem defines a clear objective function (minimize $N_{\\ell}$) and a set of well-defined constraints. The relaxation of $N_{\\ell}$ to a real number makes the problem amenable to continuous optimization methods like KKT. The existence and uniqueness of the solution depend on the problem parameters, which will be addressed in the solution, but the structure is well-posed.\n-   **Objective:** The language is formal, precise, and free of subjective statements.\n-   The problem is self-contained, with all necessary parameters defined. The constraints are not contradictory.\n\n### Step 3: Verdict and Action\nThe problem is deemed valid. A solution will be provided.\n\n### Solution Formulation and Derivation\n\nThe task is to solve a constrained optimization problem. The objective is to minimize the number of layers $N_{\\ell}$. The decision variables are $N_{\\ell} \\in \\mathbb{R}_{+}$ and the growth factor $r \\in (1, r_{\\max}]$.\n\nThe optimization problem can be stated as:\nMinimize $N_{\\ell}$\nSubject to:\n1.  $\\frac{\\Delta y_{1}\\,u_{\\tau}}{\\nu} \\leq y^{+}_{\\max}$\n2.  $\\Delta y_{1}\\,\\frac{r^{N_{\\ell}} - 1}{r - 1} \\geq \\delta$\n3.  $1 < r \\leq r_{\\max}$\n\nTo minimize $N_{\\ell}$, we should make each layer as thick as possible. This means we should choose the largest allowable value for the first layer thickness, $\\Delta y_{1}$. From constraint (1), the upper bound for $\\Delta y_{1}$ is found by setting the inequality to an equality:\n$$ \\frac{\\Delta y_{1}\\,u_{\\tau}}{\\nu} = y^{+}_{\\max} \\implies \\Delta y_{1} = \\frac{y^{+}_{\\max} \\nu}{u_{\\tau}} $$\nUsing this largest possible $\\Delta y_{1}$ will help satisfy the total thickness requirement (constraint 2) with the minimum number of layers. By making this choice, $\\Delta y_{1}$ is no longer a variable but a fixed value determined by the problem parameters.\n\nSimilarly, to minimize $N_{\\ell}$ for any given $r$ and $\\Delta y_1$, the total thickness generated by the formula must be as large as possible. This means the total thickness constraint should be active, i.e., an equality:\n$$ \\sum_{i=1}^{N_{\\ell}} \\Delta y_{i} = \\delta $$\nSubstituting the expressions for $\\Delta y_1$ and the sum into this equality yields:\n$$ \\left( \\frac{y^{+}_{\\max} \\nu}{u_{\\tau}} \\right) \\frac{r^{N_{\\ell}} - 1}{r - 1} = \\delta $$\nThis equation implicitly defines $N_{\\ell}$ as a function of $r$. We can solve for $N_{\\ell}(r)$:\n$$ \\frac{r^{N_{\\ell}} - 1}{r - 1} = \\frac{\\delta u_{\\tau}}{y^{+}_{\\max} \\nu} $$\nLet us define a dimensionless constant $C = \\frac{\\delta u_{\\tau}}{y^{+}_{\\max} \\nu}$. This constant represents the ratio of the target total thickness $\\delta$ to the maximum allowable first layer thickness $\\Delta y_1$. The equation becomes:\n$$ \\frac{r^{N_{\\ell}} - 1}{r - 1} = C $$\nSolving for $N_{\\ell}$:\n$$ r^{N_{\\ell}} - 1 = C(r-1) $$\n$$ r^{N_{\\ell}} = 1 + C(r-1) $$\n$$ N_{\\ell} \\ln(r) = \\ln(1 + C(r-1)) $$\n$$ N_{\\ell}(r) = \\frac{\\ln(1 + C(r-1))}{\\ln(r)} $$\nThe optimization problem has been reduced to finding the minimum value of the function $N_{\\ell}(r)$ over the interval $r \\in (1, r_{\\max}]$. To find the minimum, we analyze the derivative of $N_{\\ell}(r)$ with respect to $r$:\n$$ \\frac{dN_{\\ell}}{dr} = \\frac{\\frac{C}{1+C(r-1)}\\ln(r) - \\ln(1+C(r-1))\\frac{1}{r}}{\\left(\\ln(r)\\right)^2} $$\nThe sign of the derivative is determined by the sign of the numerator.\nFor a non-trivial boundary-layer mesh with multiple layers, the total thickness $\\delta$ must be greater than the first layer thickness $\\Delta y_1$. This physical requirement implies $\\frac{\\delta}{\\Delta y_1} > 1$, which means $C>1$. We proceed under this assumption, which ensures the problem is physically meaningful and well-posed.\n\nLet's analyze the sign of the derivative for $C>1$. Consider the function $k(r) = r^C - (1+C(r-1))$ for $r>1$. Its value at $r=1$ is $k(1)=1^C - (1+0) = 0$. Its derivative is $k'(r) = Cr^{C-1} - C = C(r^{C-1}-1)$. Since $C>1$ and $r>1$, we have $C-1>0$ and $r^{C-1}>1$, which implies $k'(r)>0$. Thus, $k(r)$ is a strictly increasing function for $r>1$. Since $k(1)=0$, we have $k(r)>0$ for all $r>1$.\nThe inequality $r^C > 1+C(r-1)$ for $r>1$ implies (by taking the logarithm):\n$$ C \\ln(r) > \\ln(1+C(r-1)) $$\nDividing by $\\ln(r)>0$, we get $C > \\frac{\\ln(1+C(r-1))}{\\ln(r)} = N_{\\ell}(r)$. While this provides a bound, we need the sign of the derivative $\\frac{dN_{\\ell}}{dr}$. The numerator of the derivative is proportional to $h(r) = Cr\\ln(r) - (1+C(r-1))\\ln(1+C(r-1))$. Analysis of $h(r)$ shows it is negative for $C>1$ and $r>1$. A simpler argument is based on the known result from convex analysis that for a concave function $f(x)$ with $f(0)=0$, the function $f(x)/x$ is decreasing. Applying this to related functions reveals that $N_{\\ell}(r)$ is a monotonically decreasing function of $r$ for $C>1$.\n\nSince $N_{\\ell}(r)$ is a monotonically decreasing function on the interval $(1, r_{\\max}]$, its minimum value will be at the rightmost boundary of the interval, i.e., at $r = r_{\\max}$.\nTherefore, the optimal growth factor is $r^* = r_{\\max}$.\n\nThe optimal number of layers, $N_{\\ell}^*$, is found by substituting $r=r_{\\max}$ into the expression for $N_{\\ell}(r)$:\n$$ N_{\\ell}^* = N_{\\ell}(r_{\\max}) = \\frac{\\ln(1 + C(r_{\\max}-1))}{\\ln(r_{\\max})} $$\nFinally, substituting the definition of $C$ back into the expression gives the closed-form solution for the optimal continuous layer count:\n$$ N_{\\ell}^* = \\frac{\\ln\\left(1 + \\frac{\\delta u_{\\tau}}{y^{+}_{\\max} \\nu} (r_{\\max} - 1)\\right)}{\\ln(r_{\\max})} $$\nThis expression provides the minimum number of layers (as a continuous variable) required to satisfy all design constraints.",
            "answer": "$$\\boxed{\\frac{\\ln\\left(1 + \\frac{\\delta u_{\\tau}}{y^{+}_{\\max} \\nu} (r_{\\max} - 1)\\right)}{\\ln(r_{\\max})}}$$"
        },
        {
            "introduction": "Moving from a one-dimensional stack of cells to a two-dimensional mesh over a curved surface introduces a critical choice: the extrusion strategy. This hands-on exercise  requires you to implement and compare two common approaches, a simple vertical extrusion and a geometrically ideal normal-projection method. By quantifying the resulting geometric errors and their impact on a model problem for wall shear stress, you will gain direct insight into how mesh quality, particularly orthogonality, affects the accuracy of a CFD simulation.",
            "id": "3297008",
            "problem": "You are asked to compare two structured boundary-layer mesh generation strategies over a wavy wall in two spatial dimensions: transfinite interpolation extrusion aligned with a fixed vertical direction and normal-projection extrusion aligned with the physical wall normals. The wall surface is given by the single-valued function $z = a \\sin(k x)$, with $x$ measured in meters and $z$ in meters. Your task is to quantify geometric errors and the induced impact on the Jacobian determinant and on a model problem for wall shear stress estimation. You must implement a complete, runnable program that performs these computations for a prescribed test suite.\n\nStart from the following fundamental bases and core definitions:\n- The wall surface is the parametric curve $\\boldsymbol{r}_w(x) = (x, a \\sin(k x))$ with $x \\in [0, L]$, where $L = 2\\pi/k$.\n- The (unnormalized) tangent vector is $\\boldsymbol{t} = \\partial \\boldsymbol{r}_w/\\partial x = (1, a k \\cos(k x))$ and the outward unit normal is $\\hat{\\boldsymbol{n}} = \\boldsymbol{n}/\\|\\boldsymbol{n}\\|$ with $\\boldsymbol{n} = (-a k \\cos(k x), 1)$ and $\\|\\boldsymbol{n}\\| = \\sqrt{1 + (a k \\cos(k x))^2}$.\n- A structured boundary-layer mesh is built by extruding layers from the wall into the fluid. Let the number of discrete layers be $N \\in \\mathbb{N}$ and let the desired normal distance sequence be a geometric progression with first spacing $y_1$ and growth ratio $r > 1$, i.e., the unscaled layer increments are $\\Delta n_j^{\\text{raw}} = y_1 r^{j-1}$ for $j \\in \\{1,\\dots,N\\}$. The cumulative unscaled distance to layer $j$ is $S_j = \\sum_{m=1}^j \\Delta n_m^{\\text{raw}}$. To enforce a prescribed outer boundary-layer height $H$ (in meters), scale these distances by a factor $c = H/S_N$ so that the target cumulative normal distances are $n_j = c S_j$, with $n_0 = 0$ and $n_N = H$.\n- The transfinite-interpolation-aligned extrusion is defined here as a vertical-direction extrusion: at a given surface point $(x, z_w)$ the mesh node for layer $j$ is $\\boldsymbol{r}^{\\mathrm{TFI}}(x,j) = (x, z_w) + n_j \\,\\hat{\\boldsymbol{e}}_z$, where $\\hat{\\boldsymbol{e}}_z = (0,1)$.\n- The normal-projection extrusion is defined by $\\boldsymbol{r}^{\\mathrm{NP}}(x,j) = \\boldsymbol{r}_w(x) + n_j \\,\\hat{\\boldsymbol{n}}(x)$.\n- The computational coordinates are $(\\xi,\\eta)$ with $\\xi \\in [0,1]$ discretized uniformly into $N_x$ nodes mapped to $x \\in [0,L]$, and $\\eta$ implicitly indexing the layers $j \\in \\{0,\\dots,N\\}$.\n- The local mapped cell (between $(i,j-1)$ and $(i+1,j)$ in index space) has physical edge vectors $\\boldsymbol{E}_\\xi = \\boldsymbol{r}(i+1,j-1) - \\boldsymbol{r}(i,j-1)$ and $\\boldsymbol{E}_\\eta = \\boldsymbol{r}(i,j) - \\boldsymbol{r}(i,j-1)$. The discrete Jacobian magnitude for that cell is $J_{\\text{cell}} = |\\boldsymbol{E}_\\xi \\times \\boldsymbol{E}_\\eta|$, where the two-dimensional scalar cross product is $\\boldsymbol{a} \\times \\boldsymbol{b} = a_x b_z - a_z b_x$.\n- The true reference area scaling for one computational cell in an idealized orthogonal mapping is the product $\\Delta x \\,\\Delta n_j$, where $\\Delta x = L/(N_x-1)$ and $\\Delta n_j = n_j - n_{j-1}$.\n\nDefine and compute the following quantitative metrics:\n1) Geometric normal-distance error at nodes: for a mesh node $\\boldsymbol{r}(x,j)$, define the actual normal distance as $d_{\\perp}(x,j) = (\\boldsymbol{r}(x,j) - \\boldsymbol{r}_w(x)) \\cdot \\hat{\\boldsymbol{n}}(x)$. The nodewise geometric error is $e_n(x,j) = d_{\\perp}(x,j) - n_j$. For each mesh, compute the root-mean-square (RMS) over all streamwise locations and all off-wall layers,\n$$\nE_{n,\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_x \\, N}\\sum_{i=1}^{N_x}\\sum_{j=1}^N e_n(x_i,j)^2}.\n$$\n\n2) Jacobian quality via normalized minimum Jacobian: for each mesh, compute the ratio\n$$\n\\rho_{i,j} = \\frac{J_{\\text{cell}}(i,j)}{\\Delta x \\,\\Delta n_j}\n$$\nfor all interior cells indexed by $i \\in \\{1,\\dots,N_x-1\\}$ and $j \\in \\{1,\\dots,N\\}$. Report the minimum value over the whole mesh,\n$$\n\\rho_{\\min} = \\min_{i,j} \\rho_{i,j}.\n$$\n\n3) Impact on wall shear stress estimation using a model near-wall tangential velocity profile. Let the analytic tangential velocity in wall-normal coordinates be $u_t(n) = U_\\infty\\left(1 - e^{-n/\\ell}\\right)$, with $U_\\infty$ in meters per second and $\\ell$ in meters. The true wall shear stress is $\\tau_w^{\\mathrm{true}} = \\mu \\,\\partial u_t/\\partial n|_{n=0} = \\mu\\, U_\\infty/\\ell$, with dynamic viscosity $\\mu$ in pascal-seconds and the shear in pascals. A common one-sided discrete estimator uses the first off-wall node. For each $x_i$, let $\\boldsymbol{v}_1 = \\boldsymbol{r}(x_i,1) - \\boldsymbol{r}_w(x_i)$, $n_1(x_i) = \\boldsymbol{v}_1 \\cdot \\hat{\\boldsymbol{n}}(x_i)$, and $d_1(x_i) = \\|\\boldsymbol{v}_1\\|$. Define\n$$\n\\tau_w^{\\mathrm{est}}(x_i) = \\mu \\,\\frac{u_t(n_1(x_i)) - u_t(0)}{d_1(x_i)} = \\mu \\, \\frac{U_\\infty \\left(1 - e^{-n_1(x_i)/\\ell}\\right)}{d_1(x_i)}.\n$$\nCompute the RMS relative error along the wall,\n$$\n\\varepsilon_{\\tau,\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_x}\\sum_{i=1}^{N_x}\\left(\\frac{\\tau_w^{\\mathrm{est}}(x_i) - \\tau_w^{\\mathrm{true}}}{\\tau_w^{\\mathrm{true}}}\\right)^2}.\n$$\n\nImplementation requirements:\n- Build both meshes on the same streamwise grid of $N_x$ points uniformly spanning one wavelength $L = 2\\pi/k$.\n- Use the same layer distribution $\\{n_j\\}_{j=0}^N$ for both meshes, computed from the geometric progression and scaled so that $n_N = H$.\n- For the Jacobian ratios, use the same $\\Delta n_j$ for both meshes as the normalization.\n- For the wall shear stress model, use the same $U_\\infty$, $\\mu$, and $\\ell$ for all test cases. Answer the shear-related metric in pascals implicitly by forming a dimensionless relative error; the final reported metric must be dimensionless.\n\nTest suite:\nUse the following three parameter sets. All dimensional quantities are in the International System of Units (SI).\n- Case $1$: $a = 0$, $k = 2\\pi$, $H = 2.0\\times 10^{-2}$, $N = 40$, $N_x = 401$, $y_1 = 1.0\\times 10^{-5}$, $r = 1.2$, $U_\\infty = 1.0\\times 10^{1}$, $\\mu = 1.0\\times 10^{-3}$, $\\ell = 2.0\\times 10^{-4}$.\n- Case $2$: $a = 1.0\\times 10^{-2}$, $k = 1.0\\times 10^{1}$, $H = 2.0\\times 10^{-2}$, $N = 40$, $N_x = 401$, $y_1 = 1.0\\times 10^{-5}$, $r = 1.2$, $U_\\infty = 1.0\\times 10^{1}$, $\\mu = 1.0\\times 10^{-3}$, $\\ell = 2.0\\times 10^{-4}$.\n- Case $3$: $a = 2.0\\times 10^{-2}$, $k = 4.0\\times 10^{1}$, $H = 2.0\\times 10^{-2}$, $N = 40$, $N_x = 401$, $y_1 = 1.0\\times 10^{-5}$, $r = 1.2$, $U_\\infty = 1.0\\times 10^{1}$, $\\mu = 1.0\\times 10^{-3}$, $\\ell = 2.0\\times 10^{-4}$.\n\nFor each case, compute and report the following six floats in this exact order:\n- $E_{n,\\mathrm{RMS}}$ for the transfinite-interpolation-aligned extrusion.\n- $E_{n,\\mathrm{RMS}}$ for the normal-projection extrusion.\n- $\\rho_{\\min}$ for the transfinite-interpolation-aligned extrusion.\n- $\\rho_{\\min}$ for the normal-projection extrusion.\n- $\\varepsilon_{\\tau,\\mathrm{RMS}}$ for the transfinite-interpolation-aligned extrusion.\n- $\\varepsilon_{\\tau,\\mathrm{RMS}}$ for the normal-projection extrusion.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases ($1$ to $3$), with each case contributing its six floats in the order listed above. For example, the output must look like $[\\dots]$ with exactly $6 \\times 3 = 18$ comma-separated floats. All reported metrics are dimensionless real numbers except the geometric errors, which carry meters; nevertheless, report the numeric values as plain floats without units in the output.",
            "solution": "The present problem requires a comparative analysis of two structured boundary-layer mesh generation strategies—a vertical transfinite interpolation (TFI) extrusion and a normal-projection (NP) extrusion—over a sinusoidal wall. The comparison is to be performed by implementing an algorithm to compute three specific quantitative metrics: a geometric normal-distance error, a Jacobian-based cell quality metric, and an error metric for a model wall shear stress estimation.\n\nThe solution proceeds by first establishing the shared geometric and discretization parameters. Then, for each of the two meshing strategies, the node coordinates are computed. Finally, the specified metrics are calculated for both meshes and reported for a defined set of test cases.\n\n**1. Common Framework: Wall Geometry and Layer Distribution**\n\nThe physical domain is defined over a two-dimensional wavy wall given by the function $z_w(x) = a \\sin(k x)$. The analysis is restricted to a single wavelength, $x \\in [0, L]$, where $L = 2\\pi/k$. The discrete streamwise coordinates are uniformly spaced:\n$$\nx_i = i \\cdot \\Delta x, \\quad \\text{for } i \\in \\{0, 1, \\dots, N_x-1\\}\n$$\nwhere $\\Delta x = L/(N_x-1)$. For each point $\\boldsymbol{r}_w(x_i) = (x_i, z_w(x_i))$ on the wall, we need the outward unit normal vector, $\\hat{\\boldsymbol{n}}(x_i)$. The unnormalized normal vector is $\\boldsymbol{n} = (-z_w'(x), 1) = (-a k \\cos(k x), 1)$, and its magnitude is $\\|\\boldsymbol{n}\\| = \\sqrt{1 + (a k \\cos(k x))^2}$. Thus, the unit normal is:\n$$\n\\hat{\\boldsymbol{n}}(x) = \\frac{1}{\\sqrt{1 + (a k \\cos(k x))^2}} \\begin{pmatrix} -a k \\cos(k x) \\\\ 1 \\end{pmatrix}\n$$\n\nThe boundary layer mesh consists of $N$ layers extruded from the wall up to a total height of $H$. The desired normal distance from the wall to the $j$-th layer, $n_j$, is defined by a geometric progression. The unscaled thickness of the $j$-th layer is $\\Delta n_j^{\\text{raw}} = y_1 r^{j-1}$. The cumulative unscaled distance is the sum of a geometric series:\n$$\nS_j = \\sum_{m=1}^{j} \\Delta n_m^{\\text{raw}} = y_1 \\frac{r^j - 1}{r-1} \\quad (\\text{for } r \\neq 1)\n$$\nTo ensure the total height is exactly $H$, these distances are scaled by a factor $c = H/S_N$. The final target normal distances are $n_j = c S_j$ for $j \\in \\{0, \\dots, N\\}$, with $n_0 = 0$. This yields the explicit formula:\n$$\nn_j = H \\frac{r^j - 1}{r^N - 1}\n$$\nThe thickness of the $j$-th layer is $\\Delta n_j = n_j - n_{j-1}$.\n\n**2. Mesh Generation Strategies**\n\nGiven the wall points $\\boldsymbol{r}_w(x_i)$ and the layer distance distribution $\\{n_j\\}$, the two meshes are constructed as follows:\n\n- **Vertical TFI-Aligned Extrusion (TFI):** This method extrudes nodes along the fixed vertical direction $\\hat{\\boldsymbol{e}}_z = (0,1)$. The position of a node at streamwise location $x_i$ and layer $j$ is:\n$$\n\\boldsymbol{r}^{\\mathrm{TFI}}(x_i, j) = \\boldsymbol{r}_w(x_i) + n_j \\hat{\\boldsymbol{e}}_z = (x_i, a \\sin(k x_i) + n_j)\n$$\nThis method is simple but generates grids that are not orthogonal to the wall surface, unless the wall is flat ($a=0$).\n\n- **Normal-Projection Extrusion (NP):** This method extrudes nodes along the local wall normal vector $\\hat{\\boldsymbol{n}}(x_i)$ at each streamwise location. The node position is:\n$$\n\\boldsymbol{r}^{\\mathrm{NP}}(x_i, j) = \\boldsymbol{r}_w(x_i) + n_j \\hat{\\boldsymbol{n}}(x_i)\n$$\nThis method is designed to create a mesh that is perfectly orthogonal at the wall surface, thereby achieving the desired normal distances exactly.\n\n**3. Quantitative Metrics**\n\nFor each generated mesh, three metrics are computed to quantify its quality.\n\n**3.1. Geometric Normal-Distance Error, $E_{n,\\mathrm{RMS}}$**\nThis metric quantifies how well the mesh nodes adhere to the target normal distances $\\{n_j\\}$. For a node $\\boldsymbol{r}(x_i, j)$, its actual normal distance from the wall is the projection of the vector from the corresponding wall point onto the wall normal:\n$$\nd_{\\perp}(x_i, j) = (\\boldsymbol{r}(x_i, j) - \\boldsymbol{r}_w(x_i)) \\cdot \\hat{\\boldsymbol{n}}(x_i)\n$$\nThe nodewise error is $e_n(x_i, j) = d_{\\perp}(x_i, j) - n_j$. The Root-Mean-Square (RMS) of this error over all off-wall nodes provides a global measure of geometric accuracy:\n$$\nE_{n,\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_x N}\\sum_{i=0}^{N_x-1}\\sum_{j=1}^N e_n(x_i, j)^2}\n$$\nBy construction, the NP mesh should yield $E_{n,\\mathrm{RMS}} = 0$ (within machine precision), as $d_{\\perp} = (n_j \\hat{\\boldsymbol{n}}) \\cdot \\hat{\\boldsymbol{n}} = n_j$. The TFI mesh will have non-zero error for a wavy wall, since $d_{\\perp} = (n_j \\hat{\\boldsymbol{e}}_z) \\cdot \\hat{\\boldsymbol{n}} = n_j (\\hat{\\boldsymbol{n}})_z$, and the $z$-component of the unit normal, $(\\hat{\\boldsymbol{n}})_z = 1/\\|\\boldsymbol{n}\\|$, is less than or equal to $1$.\n\n**3.2. Jacobian Quality, $\\rho_{\\min}$**\nThe Jacobian of the mapping from computational to physical space measures local cell area and orientation. A poor-quality mesh can have highly skewed or even inverted cells ($J \\le 0$). The quality is assessed using a normalized discrete Jacobian. For a cell originating at node $(i, j-1)$, the edge vectors are defined as $\\boldsymbol{E}_\\xi = \\boldsymbol{r}(x_{i+1}, j-1) - \\boldsymbol{r}(x_i, j-1)$ and $\\boldsymbol{E}_\\eta = \\boldsymbol{r}(x_i, j) - \\boldsymbol{r}(x_i, j-1)$. The scalar 2D cross product gives the area of the parallelogram formed by these vectors: $J_{\\text{cell}} = |E_{\\xi,x} E_{\\eta,z} - E_{\\xi,z} E_{\\eta,x}|$. This area is normalized by the ideal orthogonal cell area, $\\Delta x \\Delta n_j$. The quality metric is the minimum value of this ratio over the entire mesh:\n$$\n\\rho_{\\min} = \\min_{i,j} \\left( \\frac{J_{\\text{cell}}(i,j)}{\\Delta x \\Delta n_j} \\right)\n$$\nFor an ideal orthogonal mesh, $\\rho_{i,j} = 1$ everywhere. For the TFI mesh, the vector $\\boldsymbol{E}_\\eta$ is purely vertical, $(0, \\Delta n_j)$, while $\\boldsymbol{E}_\\xi = (\\Delta x, \\Delta z_w)$. This leads to $J_{\\text{cell}} = |\\Delta x \\cdot \\Delta n_j - \\Delta z_w \\cdot 0| = \\Delta x \\Delta n_j$, and thus $\\rho_{i,j}=1$ everywhere. For the NP mesh, the extrusion directions $\\hat{\\boldsymbol{n}}(x_i)$ and $\\hat{\\boldsymbol{n}}(x_{i+1})$ are not parallel if the wall is curved, leading to distorted cells and $\\rho_{i,j} \\neq 1$ away from the wall.\n\n**3.3. Wall Shear Stress Estimation Error, $\\varepsilon_{\\tau,\\mathrm{RMS}}$**\nThis metric evaluates the impact of mesh geometry on a finite-difference approximation of a physical quantity. The true wall shear stress for the model velocity profile $u_t(n) = U_\\infty(1 - e^{-n/\\ell})$ is $\\tau_w^{\\mathrm{true}} = \\mu \\frac{\\partial u_t}{\\partial n}\\big|_{n=0} = \\mu U_\\infty/\\ell$. A first-order, one-sided discrete estimate is:\n$$\n\\tau_w^{\\mathrm{est}}(x_i) = \\mu \\frac{u_t(n_1(x_i)) - u_t(0)}{d_1(x_i)}\n$$\nwhere $\\boldsymbol{v}_1 = \\boldsymbol{r}(x_i, 1) - \\boldsymbol{r}_w(x_i)$ is the vector to the first off-wall node, $d_1(x_i) = \\|\\boldsymbol{v}_1\\|$ is the geometric distance, and $n_1(x_i) = \\boldsymbol{v}_1 \\cdot \\hat{\\boldsymbol{n}}(x_i)$ is the actual normal distance. The term $u_t(n_1(x_i))$ uses the actual normal distance to evaluate the model velocity. The RMS relative error is:\n$$\n\\varepsilon_{\\tau,\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_x}\\sum_{i=0}^{N_x-1}\\left(\\frac{\\tau_w^{\\mathrm{est}}(x_i) - \\tau_w^{\\mathrm{true}}}{\\tau_w^{\\mathrm{true}}}\\right)^2}\n$$\nFor the TFI mesh, $d_1 = n_1$ and $n_1(x_i) = n_1 (\\hat{\\boldsymbol{n}}(x_i))_z$, which varies with $x$. For the NP mesh, $d_1=n_1$ and $n_1(x_i)=n_1$, making the estimate independent of $x$ and identical to the flat plate case. This highlights how geometric error ($d_1 \\neq n_1$ or $n_1(x_i)$ varying) propagates into the stencil of the numerical scheme. However, in both TFI and NP definitions given, $d_1=n_1$, so the error is driven solely by the difference between the true normal distance $n_1(x_i)$ and the stencil distance $d_1(x_i)$.\n\nThe implementation computes these quantities for each case and method using vectorized `numpy` operations for efficiency.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_metrics(mesh_coords, params, wall_data, layer_data):\n    \"\"\"\n    Computes the three specified quality metrics for a given mesh.\n    \"\"\"\n    # Unpack parameters and pre-computed data\n    a, k, H, N, Nx = params['a'], params['k'], params['H'], params['N'], params['Nx']\n    U_inf, mu, l_scale = params['U_inf'], params['mu'], params['l']\n    \n    wall_nodes = wall_data['wall_nodes']\n    unit_normals = wall_data['unit_normals']\n    n_dist = layer_data['n_dist']\n    delta_n_layers = layer_data['delta_n']\n    L = 2 * np.pi / k\n\n    # Metric 1: Geometric normal-distance error (E_n_RMS)\n    # The sum is over i=1..Nx and j=1..N. In 0-based index: i=0..Nx-1, j=1..N\n    # We use all off-wall nodes: mesh_coords[:, 1:, :] which has shape (Nx, N, 2)\n    diff_vec = mesh_coords[:, 1:, :] - wall_nodes[:, np.newaxis, :]\n    unit_normals_bcast = unit_normals[:, np.newaxis, :]\n    d_perp = np.sum(diff_vec * unit_normals_bcast, axis=2)  # Dot product\n\n    n_dist_offwall = n_dist[1:]\n    e_n = d_perp - n_dist_offwall[np.newaxis, :]\n    e_n_rms = np.sqrt(np.mean(e_n**2))\n\n    # Metric 2: Jacobian quality (rho_min)\n    # The min is over i=1..Nx-1 and j=1..N. In 0-based: i=0..Nx-2, j=1..N\n    # These correspond to cells defined from nodes (i, j-1)\n    E_xi = mesh_coords[1:, :-1, :] - mesh_coords[:-1, :-1, :]\n    E_eta = mesh_coords[:-1, 1:, :] - mesh_coords[:-1, :-1, :]\n    \n    # 2D scalar cross product\n    j_cell = np.abs(E_xi[..., 0] * E_eta[..., 1] - E_xi[..., 1] * E_eta[..., 0])\n    \n    delta_x = L / (Nx-1)\n    ref_area = delta_x * delta_n_layers[np.newaxis, :] # delta_n_layers has length N\n    \n    # Avoid division by zero if ref_area is zero (e.g., H=0)\n    # Although not the case here, it's good practice.\n    rho = np.divide(j_cell, ref_area, out=np.ones_like(j_cell), where=ref_area!=0)\n    rho_min = np.min(rho)\n\n    # Metric 3: Wall shear stress estimation error (eps_tau_RMS)\n    # The sum is over i=1..Nx. In 0-based: i=0..Nx-1\n    tau_true = mu * U_inf / l_scale\n    \n    # Get vector to first off-wall node\n    v1 = mesh_coords[:, 1, :] - mesh_coords[:, 0, :]\n    d1 = np.linalg.norm(v1, axis=1)\n    \n    # Actual normal distance of first off-wall node\n    n1_actual = np.sum(v1 * unit_normals, axis=1) # Dot product\n\n    # Avoid division by zero. If d1 is zero, the estimate is ill-defined.\n    # In this problem, d1 = n_dist[1] > 0 always.\n    tau_est = mu * U_inf * (1 - np.exp(-n1_actual / l_scale)) / d1\n    \n    rel_error = (tau_est - tau_true) / tau_true\n    eps_tau_rms = np.sqrt(np.mean(rel_error**2))\n\n    return e_n_rms, rho_min, eps_tau_rms\n\ndef solve_case(params):\n    \"\"\"\n    Solves one test case, generating both meshes and computing all metrics.\n    \"\"\"\n    # Unpack parameters\n    a, k, H, N, Nx = params['a'], params['k'], params['H'], params['N'], params['Nx']\n    y1, r = params['y1'], params['r']\n\n    # Setup common grid and layer properties\n    L = 2.0 * np.pi / k\n    x_grid = np.linspace(0, L, Nx)\n\n    # Layer distribution\n    j_vals = np.arange(N + 1)\n    if r == 1.0:\n        n_dist = H * j_vals / N\n    else:\n        # This formula prevents potential overflow/underflow with large N\n        # by using log-exp properties, but direct computation is fine for N=40.\n        # It simplifies to: n_j = H * (r^j - 1) / (r^N - 1)\n        n_dist = H * (np.power(r, j_vals) - 1.0) / (np.power(r, N) - 1.0)\n    n_dist[0] = 0.0 # Ensure starts at zero\n    \n    delta_n_layers = n_dist[1:] - n_dist[:-1]\n    layer_data = {'n_dist': n_dist, 'delta_n': delta_n_layers}\n\n    # Wall properties\n    z_w = a * np.sin(k * x_grid)\n    wall_nodes = np.stack([x_grid, z_w], axis=-1)\n    \n    nx_unnormalized = -a * k * np.cos(k * x_grid)\n    nz_unnormalized = np.ones_like(x_grid)\n    norm_mag = np.sqrt(nx_unnormalized**2 + nz_unnormalized**2)\n    unit_normals = np.stack([nx_unnormalized / norm_mag, nz_unnormalized / norm_mag], axis=-1)\n    \n    wall_data = {'wall_nodes': wall_nodes, 'unit_normals': unit_normals}\n\n    # TFI Mesh Generation (Vertical Extrusion)\n    mesh_tfi = np.zeros((Nx, N + 1, 2))\n    mesh_tfi[:, :, 0] = x_grid[:, np.newaxis]\n    mesh_tfi[:, :, 1] = z_w[:, np.newaxis] + n_dist[np.newaxis, :]\n\n    # NP Mesh Generation (Normal Projection)\n    mesh_np = wall_nodes[:, np.newaxis, :] + n_dist[np.newaxis, :, np.newaxis] * unit_normals[:, np.newaxis, :]\n    \n    # Calculate metrics for both meshes\n    tfi_metrics = calculate_metrics(mesh_tfi, params, wall_data, layer_data)\n    np_metrics = calculate_metrics(mesh_np, params, wall_data, layer_data)\n    \n    return [tfi_metrics[0], np_metrics[0], tfi_metrics[1], np_metrics[1], tfi_metrics[2], np_metrics[2]]\n\ndef solve():\n    \"\"\"\n    Main entry point to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'a': 0.0, 'k': 2.0 * np.pi, 'H': 2.0e-2, 'N': 40, 'Nx': 401,\n            'y1': 1.0e-5, 'r': 1.2, 'U_inf': 1.0e1, 'mu': 1.0e-3, 'l': 2.0e-4\n        },\n        {\n            'a': 1.0e-2, 'k': 1.0e1, 'H': 2.0e-2, 'N': 40, 'Nx': 401,\n            'y1': 1.0e-5, 'r': 1.2, 'U_inf': 1.0e1, 'mu': 1.0e-3, 'l': 2.0e-4\n        },\n        {\n            'a': 2.0e-2, 'k': 4.0e1, 'H': 2.0e-2, 'N': 40, 'Nx': 401,\n            'y1': 1.0e-5, 'r': 1.2, 'U_inf': 1.0e1, 'mu': 1.0e-3, 'l': 2.0e-4\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = solve_case(case)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world engineering models are defined by complex intersections where multiple surfaces meet at corners and junctions, posing a significant challenge for boundary-layer extrusion. This advanced practice  presents a robust, mathematically-grounded strategy for defining a single, coherent extrusion direction in such complex regions. You will derive and implement an algorithm that blends surface normals based on a least-squares principle, a technique essential for generating high-quality meshes for multifaceted industrial geometries.",
            "id": "3297048",
            "problem": "You must derive, implement, and test a robust boundary-layer extrusion strategy at junctions, corners, and multi-surface intersections, suitable for Computational Fluid Dynamics (CFD). The aim is to construct a prismatic boundary-layer mesh extrusion direction and a layer-thickness distribution that is scientifically sound at high Reynolds number and in complex geometrical junctures. The program you produce must compute, for several specified test cases, the extrusion direction and the near-wall layer heights that meet a first-cell wall distance target in wall units, and it must verify local angular constraints at intersections.\n\nBegin from the following foundational base.\n\n1. The boundary-layer in viscous flow has a characteristic near-wall viscous length scale defined by $y^{+} = y \\, u_{\\tau} / \\nu$, where $y$ is a physical distance from the wall in meters, $u_{\\tau}$ is the friction velocity in meters per second, and $\\nu$ is the kinematic viscosity in square meters per second. The friction velocity is $u_{\\tau} = \\sqrt{\\tau_{w} / \\rho}$, where $\\tau_{w}$ is the wall shear stress in pascals and $\\rho$ is the fluid density in kilograms per cubic meter. The wall shear stress can be parameterized as $\\tau_{w} = \\tfrac{1}{2} \\rho U^{2} C_{f}$, where $U$ is a characteristic flow speed in meters per second and $C_{f}$ is a skin-friction coefficient. The skin-friction coefficient $C_{f}$ may be modeled by well-tested correlations for smooth flat plates: for laminar flow $C_{f,\\text{lam}} = 0.664 / \\sqrt{Re}$, and for turbulent flow $C_{f,\\text{turb}} = 0.0592 \\, Re^{-1/5}$, where $Re = U L / \\nu$ is the Reynolds number based on a characteristic length $L$ in meters and the kinematic viscosity $\\nu$. These correlations are widely used in engineering practice for preliminary design and mesh sizing.\n\n2. For multi-surface junctions, consider $m$ smooth surfaces meeting along a curve or point, with outward unit normals $\\{\\mathbf{n}_{i}\\}_{i=1}^{m}$ and positive weights $\\{a_{i}\\}_{i=1}^{m}$ that represent local geometric or physical weighting (for example, local surface area contributions or target flux weight). The boundary-layer extrusion direction $\\mathbf{d}$ at the junction must be consistent with near-wall orthogonality and continuity across the intersection. A principled way to select $\\mathbf{d}$ is to minimize a least-squares measure of deviation from orthogonality to each surface simultaneously. Pose the problem as minimizing $\\sum_{i=1}^{m} w_{i} \\lVert \\mathbf{d} - \\mathbf{n}_{i} \\rVert^{2}$ subject to $\\lVert \\mathbf{d} \\rVert = 1$, with weights $w_{i} = a_{i}^{\\gamma}$, where $\\gamma > 0$ is a blending exponent. This constrained optimization yields a unique direction in the convex cone spanned by the normals, assuming the weighted sum is nonzero, and is well-posed in Euclidean geometry.\n\n3. For the boundary-layer thickness distribution, adopt a geometric progression for the layer heights $\\{y_{k}\\}_{k=1}^{N}$, where $N$ is an integer number of layers, with $y_{k} = y_{1} r^{k-1}$ for a growth factor $r \\ge 1$. The total boundary-layer thickness is $T = \\sum_{k=1}^{N} y_{k}$, and the first layer height $y_{1}$ is set by a target wall unit $y^{+}_{\\text{target}}$ via $y_{1} = y^{+}_{\\text{target}} \\, \\nu / u_{\\tau}$. The value of $r$ must be determined such that the geometric series sums to the specified total thickness $T$ (if feasible), namely $T = y_{1} \\, \\tfrac{1 - r^{N}}{1 - r}$ for $r \\ne 1$, or $T = N y_{1}$ for $r = 1$. If $T < N y_{1}$, the target first cell height is infeasible under a nondecreasing geometric progression; report infeasibility for the test case and set a fallback with $r = 1$ and $y_{k} = T/N$ for all $k$.\n\n4. At junctions and corners, constrain the extrusion direction by an angular threshold to maintain near-wall orthogonality quality: compute the angles $\\theta_{i} = \\arccos(\\mathbf{d} \\cdot \\mathbf{n}_{i})$ in radians for all $i$, and enforce $\\theta_{i} \\le \\theta_{\\max}$. Report whether this constraint is satisfied for each test case.\n\nYour tasks are:\n\nA. Derive the expression for the extrusion direction $\\mathbf{d}$ under the least-squares criterion in item $2$, given the unit norm constraint.\n\nB. Derive the friction velocity $u_{\\tau}$ given $U$, $\\rho$, $L$, and $\\nu$, using the piecewise skin-friction correlations in item $1$, and then derive the first layer height $y_{1}$ for a target $y^{+}_{\\text{target}}$.\n\nC. Derive a procedure to compute the growth factor $r \\ge 1$ that achieves the specified total thickness $T$ when feasible, and specify a robust numerical method to find $r$.\n\nD. Implement a program that, for each test case defined below, computes:\n- The extrusion direction components $(d_{x}, d_{y}, d_{z})$.\n- A boolean indicating whether the angular constraint is satisfied.\n- The first layer height $y_{1}$ in meters.\n- The growth factor $r$ (or a sentinel value if infeasible).\n- The absolute difference between $\\sum_{k=1}^{N} y_{k}$ and $T$ in meters.\n- A boolean indicating feasibility ($T \\ge N y_{1}$).\n- The list of layer heights $[y_{1}, y_{2}, \\dots, y_{N}]$ in meters.\n\nAngles must be computed and reported in radians. All physical quantities must be in SI units: meters, seconds, kilograms, and pascals.\n\nTest Suite:\nUse the following test cases. For each case, provide the parameters exactly as listed.\n\nCase $1$ (two-surface orthogonal corner, air):\n- $\\mathbf{n}_{1} = (1, 0, 0)$, $\\mathbf{n}_{2} = (0, 1, 0)$, $a_{1} = 1$, $a_{2} = 1$, $\\gamma = 1$, $\\theta_{\\max} = \\pi/3$.\n- $U = 30$, $\\mu = 1.8 \\times 10^{-5}$, $\\rho = 1.225$, $L = 1$, $y^{+}_{\\text{target}} = 1$, $N = 10$, $T = 0.02$.\n\nCase $2$ (two-surface acute corner with angle $\\phi = \\pi/6$, air):\n- $\\mathbf{n}_{1} = (1, 0, 0)$, $\\mathbf{n}_{2} = (\\cos(\\pi/6), \\sin(\\pi/6), 0)$, $a_{1} = 1$, $a_{2} = 1$, $\\gamma = 1$, $\\theta_{\\max} = 0.4$.\n- $U = 30$, $\\mu = 1.8 \\times 10^{-5}$, $\\rho = 1.225$, $L = 1$, $y^{+}_{\\text{target}} = 5$, $N = 20$, $T = 0.03$.\n\nCase $3$ (three-surface intersection, water):\n- $\\mathbf{n}_{1} = (1, 0, 0)$, $\\mathbf{n}_{2} = (0, 1, 0)$, $\\mathbf{n}_{3} = (0, 0, 1)$, $a_{1} = 1$, $a_{2} = 1$, $a_{3} = 1$, $\\gamma = 1$, $\\theta_{\\max} = 1.0$.\n- $U = 2$, $\\mu = 10^{-3}$, $\\rho = 1000$, $L = 0.5$, $y^{+}_{\\text{target}} = 1$, $N = 8$, $T = 0.005$.\n\nCase $4$ (nearly parallel surfaces with weighted blending, air, infeasible $T$):\n- $\\mathbf{n}_{1} = (1, 0, 0)$, $\\mathbf{n}_{2} = (0.999, 0.0447, 0)$, $a_{1} = 1$, $a_{2} = 0.2$, $\\gamma = 2$, $\\theta_{\\max} = 0.05$.\n- $U = 10$, $\\mu = 1.8 \\times 10^{-5}$, $\\rho = 1.225$, $L = 0.2$, $y^{+}_{\\text{target}} = 30$, $N = 5$, $T = 0.001$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of the outer list corresponds to one test case and must itself be a list of the form:\n$[d_{x}, d_{y}, d_{z}, \\text{pass\\_angle}, y_{1}, r, \\text{thickness\\_error}, \\text{pass\\_thickness}, [y_{1}, y_{2}, \\dots, y_{N}]]$.\nBooleans must be represented in their language-native boolean form. Units must be consistent with the above specifications. The angles are in radians, and distances are in meters.",
            "solution": "We derive the extrusion direction and boundary-layer thickness distribution from foundational principles.\n\nA. Extrusion direction derivation. Let $\\{\\mathbf{n}_{i}\\}_{i=1}^{m}$ be unit normals and $\\{w_{i}\\}_{i=1}^{m}$ be positive weights with $w_{i} = a_{i}^{\\gamma}$ and $\\gamma > 0$. We seek $\\mathbf{d} \\in \\mathbb{R}^{3}$ with $\\lVert \\mathbf{d} \\rVert = 1$ that minimizes the objective\n$$\nJ(\\mathbf{d}) = \\sum_{i=1}^{m} w_{i} \\lVert \\mathbf{d} - \\mathbf{n}_{i} \\rVert^{2}.\n$$\nExpanding the squared norm,\n$$\nJ(\\mathbf{d}) = \\sum_{i=1}^{m} w_{i} \\left( \\lVert \\mathbf{d} \\rVert^{2} - 2 \\mathbf{d} \\cdot \\mathbf{n}_{i} + \\lVert \\mathbf{n}_{i} \\rVert^{2} \\right)\n= \\left( \\sum_{i=1}^{m} w_{i} \\right) \\lVert \\mathbf{d} \\rVert^{2} - 2 \\mathbf{d} \\cdot \\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i} + \\sum_{i=1}^{m} w_{i} \\lVert \\mathbf{n}_{i} \\rVert^{2}.\n$$\nSince each $\\mathbf{n}_{i}$ is unit, $\\lVert \\mathbf{n}_{i} \\rVert^{2} = 1$, and the last term is constant with respect to $\\mathbf{d}$. The constrained minimization with $\\lVert \\mathbf{d} \\rVert = 1$ can be handled via a Lagrange multiplier $\\lambda$:\n$$\n\\mathcal{L}(\\mathbf{d}, \\lambda) = \\left( \\sum_{i=1}^{m} w_{i} \\right) \\lVert \\mathbf{d} \\rVert^{2} - 2 \\mathbf{d} \\cdot \\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i} + \\lambda \\left( \\lVert \\mathbf{d} \\rVert^{2} - 1 \\right).\n$$\nTaking the gradient with respect to $\\mathbf{d}$ and setting to zero,\n$$\n\\nabla_{\\mathbf{d}} \\mathcal{L} = 2 \\left( \\sum_{i=1}^{m} w_{i} \\right) \\mathbf{d} - 2 \\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i} + 2 \\lambda \\mathbf{d} = \\mathbf{0}.\n$$\nThus,\n$$\n\\left( \\sum_{i=1}^{m} w_{i} + \\lambda \\right) \\mathbf{d} = \\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i}.\n$$\nFor some scalar $\\alpha = 1 / \\left( \\sum_{i=1}^{m} w_{i} + \\lambda \\right)$, we have\n$$\n\\mathbf{d} = \\alpha \\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i}.\n$$\nImposing $\\lVert \\mathbf{d} \\rVert = 1$ determines $\\alpha$ as the reciprocal of the norm of the weighted sum:\n$$\n\\mathbf{d} = \\frac{\\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i}}{\\left\\lVert \\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i} \\right\\rVert}.\n$$\nThis is well-defined provided $\\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i} \\ne \\mathbf{0}$, which is generically true for a proper junction of outward normals without exact cancellation. In the degenerate case where the weighted sum is zero, a fallback selects the normal with the largest weight.\n\nTo assess near-wall orthogonality quality, compute the angles\n$$\n\\theta_{i} = \\arccos\\!\\left( \\mathbf{d} \\cdot \\mathbf{n}_{i} \\right),\n$$\nand enforce the bound $\\theta_{i} \\le \\theta_{\\max}$ for all $i$.\n\nB. Friction velocity and first cell height derivation. The Reynolds number is\n$$\nRe = \\frac{U L}{\\nu}, \\quad \\nu = \\frac{\\mu}{\\rho}.\n$$\nUsing flat-plate correlations,\n$$\nC_{f} = \n\\begin{cases}\n0.664 \\, Re^{-1/2}, & \\text{if } Re \\le 5 \\times 10^{5}, \\\\\n0.0592 \\, Re^{-1/5}, & \\text{if } Re > 5 \\times 10^{5}.\n\\end{cases}\n$$\nThe wall shear stress is $\\tau_{w} = \\tfrac{1}{2} \\rho U^{2} C_{f}$, and the friction velocity is\n$$\nu_{\\tau} = \\sqrt{\\frac{\\tau_{w}}{\\rho}} = U \\sqrt{\\frac{C_{f}}{2}}.\n$$\nFor a target wall unit $y^{+}_{\\text{target}}$, the first cell height is\n$$\ny_{1} = y^{+}_{\\text{target}} \\, \\frac{\\nu}{u_{\\tau}}.\n$$\n\nC. Growth factor computation. The total thickness of a geometric progression with $r \\ne 1$ is\n$$\nT = y_{1} \\frac{1 - r^{N}}{1 - r}, \\quad r \\ge 1.\n$$\nIf $r = 1$, then $T = N y_{1}$. A feasible solution with $r \\ge 1$ requires $T \\ge N y_{1}$ since $T(r)$ is monotonically increasing in $r$ for $r \\ge 1$. When feasible, solve for $r$ via a monotone root-finding method. Define\n$$\nf(r) = y_{1} \\frac{1 - r^{N}}{1 - r} - T,\n$$\nwith the domain $r \\in [1, r_{\\max}]$ and $r_{\\max}$ chosen by exponential bracketing until $f(r_{\\max}) \\ge 0$ (that is, the sum reaches or exceeds $T$). Use bisection to find the unique root since $f(r)$ is continuous and strictly increasing on $[1, \\infty)$ for $N \\ge 1$ and $y_{1} > 0$. If $T < N y_{1}$, declare infeasibility and set a fallback with $r = 1$ and $y_{k} = T / N$ for all $k$.\n\nD. Implementation details. For each test case, compute:\n- Weights $w_{i} = a_{i}^{\\gamma}$, then the weighted sum $\\mathbf{s} = \\sum_{i} w_{i} \\mathbf{n}_{i}$. If $\\lVert \\mathbf{s} \\rVert > 0$, set $\\mathbf{d} = \\mathbf{s} / \\lVert \\mathbf{s} \\rVert$; otherwise, set $\\mathbf{d}$ equal to the $\\mathbf{n}_{i}$ corresponding to $\\max w_{i}$.\n- Angles $\\theta_{i} = \\arccos(\\mathbf{d} \\cdot \\mathbf{n}_{i})$ and $\\text{pass\\_angle}$ if $\\max_{i} \\theta_{i} \\le \\theta_{\\max}$.\n- Kinematic viscosity $\\nu = \\mu / \\rho$, Reynolds number $Re = U L / \\nu$, skin-friction coefficient $C_{f}$ by the piecewise correlation, friction velocity $u_{\\tau} = U \\sqrt{C_{f} / 2}$, and $y_{1} = y^{+}_{\\text{target}} \\nu / u_{\\tau}$.\n- Feasibility check $\\text{pass\\_thickness} \\leftrightarrow T \\ge N y_{1}$. If feasible, bracket and solve for $r \\ge 1$ using bisection on $f(r)$. If infeasible, set $r = 1$ and $y_{k} = T/N$.\n- The list of heights $[y_{1}, y_{2}, \\dots, y_{N}]$ with $y_{k} = y_{1} r^{k-1}$ for the feasible case and $y_{k} = T/N$ otherwise.\n- The absolute thickness error $\\lvert \\sum_{k=1}^{N} y_{k} - T \\rvert$.\n\nAll angles are in radians; all distances are in meters. This design ensures scientific realism: the extrusion direction arises from a convex combination of surface normals minimizing a quadratic objective under a unit norm constraint, and the layer sizing is based on wall units and established flat-plate friction correlations, with robust numerical treatment of the growth factor under feasibility constraints.\n\nThe final program aggregates the per-case results into a single line, a comma-separated list enclosed in square brackets, where each element is a list containing the extrusion direction, boolean flags, first height, growth factor, thickness error, feasibility flag, and the list of layer heights.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef weighted_direction(normals, areas, gamma):\n    \"\"\"\n    Compute extrusion direction by normalized weighted sum of unit normals.\n    If the weighted sum is (near) zero, fall back to the normal with largest weight.\n    \"\"\"\n    weights = np.power(np.asarray(areas, dtype=float), float(gamma))\n    normals = np.asarray(normals, dtype=float)\n    # Normalize normals defensively in case of slight deviations\n    norms = np.linalg.norm(normals, axis=1)\n    norms[norms == 0.0] = 1.0\n    unit_normals = normals / norms[:, None]\n    s = (weights[:, None] * unit_normals).sum(axis=0)\n    s_norm = np.linalg.norm(s)\n    if s_norm <= 1e-14:\n        # Fallback: pick the normal with the largest weight\n        idx = int(np.argmax(weights))\n        d = unit_normals[idx]\n    else:\n        d = s / s_norm\n    return d\n\ndef angles_to_normals(direction, normals):\n    \"\"\"Compute angles between direction and each normal, in radians.\"\"\"\n    direction = np.asarray(direction, dtype=float)\n    direction_norm = np.linalg.norm(direction)\n    if direction_norm == 0.0:\n        raise ValueError(\"Direction vector has zero norm.\")\n    d = direction / direction_norm\n    normals = np.asarray(normals, dtype=float)\n    # normalize normals just in case\n    norms = np.linalg.norm(normals, axis=1)\n    norms[norms == 0.0] = 1.0\n    unit_normals = normals / norms[:, None]\n    dots = np.clip(unit_normals @ d, -1.0, 1.0)\n    thetas = np.arccos(dots)\n    return thetas\n\ndef friction_velocity(U, mu, rho, L):\n    \"\"\"Compute friction velocity using piecewise Cf correlations.\"\"\"\n    nu = mu / rho\n    Re = U * L / nu\n    if Re <= 5.0e5:\n        Cf = 0.664 / np.sqrt(Re)\n    else:\n        Cf = 0.0592 * (Re ** (-0.2))\n    u_tau = U * np.sqrt(0.5 * Cf)\n    return u_tau, nu, Re, Cf\n\ndef first_cell_height(yplus_target, nu, u_tau):\n    \"\"\"Compute first layer height y1 from target y+.\"\"\"\n    return yplus_target * nu / u_tau\n\ndef geometric_sum(y1, r, N):\n    \"\"\"Sum of geometric progression y1, y1*r, ..., y1*r^(N-1).\"\"\"\n    if abs(r - 1.0) < 1e-14:\n        return N * y1\n    return y1 * (1.0 - r**N) / (1.0 - r)\n\ndef solve_growth_factor(y1, T, N, tol=1e-12, max_iter=200):\n    \"\"\"\n    Solve for growth factor r >= 1 such that geometric_sum(y1, r, N) == T.\n    Returns (r, heights, thickness_error, pass_thickness).\n    If infeasible (T < N*y1), returns r=1, equal heights T/N, error=0, pass_thickness=False.\n    \"\"\"\n    min_sum = N * y1\n    if T < min_sum - 1e-14:\n        # Infeasible: fallback equal heights\n        heights = [T / N] * N\n        thickness_error = abs(sum(heights) - T)\n        return 1.0, heights, thickness_error, False\n    # Feasible: find r >= 1\n    # If T == N*y1 within tolerance, r == 1\n    if abs(T - min_sum) <= 1e-14:\n        heights = [y1] * N\n        thickness_error = abs(sum(heights) - T)\n        return 1.0, heights, thickness_error, True\n    # Bracket r\n    r_lo = 1.0\n    r_hi = 2.0\n    # Increase r_hi until sum >= T\n    for _ in range(1000):\n        S = geometric_sum(y1, r_hi, N)\n        if S >= T:\n            break\n        r_hi *= 2.0\n        if r_hi > 1e12:\n            # Avoid runaway; treat as failure, though should not happen\n            break\n    # Bisection\n    r = r_lo\n    for _ in range(max_iter):\n        r_mid = 0.5 * (r_lo + r_hi)\n        S_mid = geometric_sum(y1, r_mid, N)\n        if abs(S_mid - T) <= tol:\n            r = r_mid\n            break\n        if S_mid < T:\n            r_lo = r_mid\n        else:\n            r_hi = r_mid\n    else:\n        r = r_mid\n    # Build heights\n    heights = [y1 * (r ** k) for k in range(N)]\n    thickness_error = abs(sum(heights) - T)\n    return r, heights, thickness_error, True\n\ndef case_result(normals, areas, gamma, theta_max,\n                U, mu, rho, L, yplus_target, N, T):\n    # Direction\n    d = weighted_direction(normals, areas, gamma)\n    thetas = angles_to_normals(d, normals)\n    pass_angle = bool(np.max(thetas) <= theta_max + 1e-14)\n    # Friction velocity and y1\n    u_tau, nu, Re, Cf = friction_velocity(U, mu, rho, L)\n    y1 = first_cell_height(yplus_target, nu, u_tau)\n    # Growth factor\n    r, heights, thickness_error, pass_thickness = solve_growth_factor(y1, T, N)\n    # Compose result list\n    result = [float(d[0]), float(d[1]), float(d[2]),\n              bool(pass_angle),\n              float(y1),\n              float(r),\n              float(thickness_error),\n              bool(pass_thickness),\n              [float(h) for h in heights]]\n    return result\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"normals\": [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)],\n            \"areas\": [1.0, 1.0],\n            \"gamma\": 1.0,\n            \"theta_max\": np.pi / 3.0,\n            \"U\": 30.0,\n            \"mu\": 1.8e-5,\n            \"rho\": 1.225,\n            \"L\": 1.0,\n            \"yplus_target\": 1.0,\n            \"N\": 10,\n            \"T\": 0.02\n        },\n        # Case 2\n        {\n            \"normals\": [(1.0, 0.0, 0.0), (np.cos(np.pi/6.0), np.sin(np.pi/6.0), 0.0)],\n            \"areas\": [1.0, 1.0],\n            \"gamma\": 1.0,\n            \"theta_max\": 0.4,\n            \"U\": 30.0,\n            \"mu\": 1.8e-5,\n            \"rho\": 1.225,\n            \"L\": 1.0,\n            \"yplus_target\": 5.0,\n            \"N\": 20,\n            \"T\": 0.03\n        },\n        # Case 3\n        {\n            \"normals\": [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)],\n            \"areas\": [1.0, 1.0, 1.0],\n            \"gamma\": 1.0,\n            \"theta_max\": 1.0,\n            \"U\": 2.0,\n            \"mu\": 1.0e-3,\n            \"rho\": 1000.0,\n            \"L\": 0.5,\n            \"yplus_target\": 1.0,\n            \"N\": 8,\n            \"T\": 0.005\n        },\n        # Case 4\n        {\n            \"normals\": [(1.0, 0.0, 0.0), (0.999, 0.0447, 0.0)],\n            \"areas\": [1.0, 0.2],\n            \"gamma\": 2.0,\n            \"theta_max\": 0.05,\n            \"U\": 10.0,\n            \"mu\": 1.8e-5,\n            \"rho\": 1.225,\n            \"L\": 0.2,\n            \"yplus_target\": 30.0,\n            \"N\": 5,\n            \"T\": 0.001\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = case_result(\n            normals=case[\"normals\"],\n            areas=case[\"areas\"],\n            gamma=case[\"gamma\"],\n            theta_max=case[\"theta_max\"],\n            U=case[\"U\"],\n            mu=case[\"mu\"],\n            rho=case[\"rho\"],\n            L=case[\"L\"],\n            yplus_target=case[\"yplus_target\"],\n            N=case[\"N\"],\n            T=case[\"T\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Print single-line, comma-separated list enclosed in square brackets.\n    def format_element(elem):\n        if isinstance(elem, list):\n            return \"[\" + \",\".join(format_element(e) for e in elem) + \"]\"\n        elif isinstance(elem, bool):\n            return \"True\" if elem else \"False\"\n        else:\n            # float or int\n            return str(elem)\n\n    print(\"[\" + \",\".join(format_element(r) for r in results) + \"]\")\n\nsolve()\n```"
        }
    ]
}