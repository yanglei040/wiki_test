{
    "hands_on_practices": [
        {
            "introduction": "掌握代数网格生成技术的第一步是理解如何根据已知的边界构建映射。本练习将引导您使用强大的超限插值（Transfinite Interpolation, TFI）技术，从零开始构建一个二维网格。通过将简单的一维线性插值与容斥原理相结合，您将推导出经典的TFI公式，并亲身体验它如何确保生成的网格与指定的边界曲线完美匹配 。",
            "id": "3290639",
            "problem": "在计算流体动力学的代数网格生成中，根据四条解析边界曲线，在单位正方形参数域 $[0,1] \\times [0,1]$ 上构造一个内部映射。这四条曲线中，两条是水平参数 $\\xi$ 的函数，另外两条是垂直参数 $\\eta$ 的函数。考虑物理平面 $\\mathbb{R}^{2}$ 中的以下四条边界曲线：\n- 底边（由 $\\xi$ 参数化）：$\\mathbf{c}_{1}(\\xi) = \\big(\\,\\xi + \\xi^{2}, \\tfrac{1}{2}\\,\\xi\\,\\big)$。\n- 顶边（由 $\\xi$ 参数化）：$\\mathbf{c}_{2}(\\xi) = \\big(\\,1 + \\tfrac{1}{2}\\cos(\\pi \\xi),\\, 1 + \\tfrac{1}{2}\\sin(\\pi \\xi)\\,\\big)$。\n- 左边（由 $\\eta$ 参数化）：$\\mathbf{d}_{1}(\\eta) = \\big(\\,\\tfrac{3}{2}\\,\\eta^{2},\\, \\eta\\,\\big)$。\n- 右边（由 $\\eta$ 参数化）：$\\mathbf{d}_{2}(\\eta) = \\big(\\,2 - \\tfrac{3}{2}\\,\\eta,\\, \\tfrac{1}{2} + \\tfrac{1}{2}\\,\\eta\\,\\big)$。\n\n这些曲线在四个角点处是一致的，即 $\\mathbf{c}_{1}(0) = \\mathbf{d}_{1}(0)$，$\\mathbf{c}_{1}(1) = \\mathbf{d}_{2}(0)$，$\\mathbf{c}_{2}(0) = \\mathbf{d}_{1}(1)$，以及 $\\mathbf{c}_{2}(1) = \\mathbf{d}_{2}(1)$。\n\n仅使用以下基本原理：(i) 沿参数线的一维线性插值，以及 (ii) 用于校正角点贡献重复计算的容斥原理，从第一性原理出发构造一个在 $[0,1] \\times [0,1]$ 上的二维代数映射 $\\mathbf{x}(\\xi,\\eta)$，该映射能够混合这些边界并在边界上精确地再现它们。证明您的构造满足边界再现属性 $\\mathbf{x}(\\xi,0) = \\mathbf{c}_{1}(\\xi)$，$\\mathbf{x}(\\xi,1) = \\mathbf{c}_{2}(\\xi)$，$\\mathbf{x}(0,\\eta) = \\mathbf{d}_{1}(\\eta)$ 和 $\\mathbf{x}(1,\\eta) = \\mathbf{d}_{2}(\\eta)$。\n\n最后，在内点 $(\\xi_{0},\\eta_{0}) = \\big(\\tfrac{1}{3}, \\tfrac{2}{5}\\big)$ 处计算得到的超限插值(TFI)映射的值，并给出 $\\mathbf{x}(\\tfrac{1}{3}, \\tfrac{2}{5})$ 的精确解析表达式。将最终答案表示为一个二分量行向量。无需四舍五入。",
            "solution": "目标是推导出一个二维代数映射，该映射插值四条边界曲线并在边界上再现它们。推导过程基于以下基本思想：\n\n1. 沿参数域中坐标线的一维线性插值。给定与 $\\eta=0$ 和 $\\eta=1$ 相关联的两个向量值函数 $\\mathbf{a}(\\xi)$ 和 $\\mathbf{b}(\\xi)$，沿 $\\eta$ 方向的线性混合为\n$$\n\\mathbf{L}_{\\eta}(\\xi,\\eta) = (1-\\eta)\\,\\mathbf{a}(\\xi) + \\eta\\,\\mathbf{b}(\\xi).\n$$\n类似地，沿 $\\xi$ 方向，对于与 $\\xi=0$ 和 $\\xi=1$ 相关联的两个向量值函数 $\\mathbf{p}(\\eta)$ 和 $\\mathbf{q}(\\eta)$，线性混合为\n$$\n\\mathbf{L}_{\\xi}(\\xi,\\eta) = (1-\\xi)\\,\\mathbf{p}(\\eta) + \\xi\\,\\mathbf{q}(\\eta).\n$$\n\n2. 容斥原理（或布尔和）以校正重复计算。如果我们简单地将两个一维混合 $\\mathbf{L}_{\\eta}$ 和 $\\mathbf{L}_{\\xi}$ 相加，角点将被计算两次。为了消除重复计数，我们减去四个角点的双线性插值，其使用标准的双线性形函数 $N_{00}=(1-\\xi)(1-\\eta)$、$N_{10}=\\xi(1-\\eta)$、$N_{01}=(1-\\xi)\\eta$、$N_{11}=\\xi\\eta$。\n\n我们首先确定角点，这些角点必须是相互一致的：\n$$\n\\mathbf{x}_{00} = \\mathbf{c}_{1}(0) = \\mathbf{d}_{1}(0),\\quad\n\\mathbf{x}_{10} = \\mathbf{c}_{1}(1) = \\mathbf{d}_{2}(0),\\quad\n\\mathbf{x}_{01} = \\mathbf{c}_{2}(0) = \\mathbf{d}_{1}(1),\\quad\n\\mathbf{x}_{11} = \\mathbf{c}_{2}(1) = \\mathbf{d}_{2}(1).\n$$\n根据所给数据，\n$$\n\\mathbf{x}_{00} = (0,0),\\quad\n\\mathbf{x}_{10} = (2,\\tfrac{1}{2}),\\quad\n\\mathbf{x}_{01} = (\\tfrac{3}{2},1),\\quad\n\\mathbf{x}_{11} = (\\tfrac{1}{2},1).\n$$\n\n使用给定的边界构造一维混合：\n- 沿 $\\eta$ 方向，在 $\\mathbf{c}_{1}(\\xi)$ 和 $\\mathbf{c}_{2}(\\xi)$ 之间：\n$$\n\\mathbf{L}_{\\eta}(\\xi,\\eta) = (1-\\eta)\\,\\mathbf{c}_{1}(\\xi) + \\eta\\,\\mathbf{c}_{2}(\\xi).\n$$\n- 沿 $\\xi$ 方向，在 $\\mathbf{d}_{1}(\\eta)$ 和 $\\mathbf{d}_{2}(\\eta)$ 之间：\n$$\n\\mathbf{L}_{\\xi}(\\xi,\\eta) = (1-\\xi)\\,\\mathbf{d}_{1}(\\eta) + \\xi\\,\\mathbf{d}_{2}(\\eta).\n$$\n\n为了校正角点的重复计算，减去角点的双线性插值\n$$\n\\mathbf{B}(\\xi,\\eta) = (1-\\xi)(1-\\eta)\\,\\mathbf{x}_{00} + \\xi(1-\\eta)\\,\\mathbf{x}_{10} + (1-\\xi)\\eta\\,\\mathbf{x}_{01} + \\xi\\eta\\,\\mathbf{x}_{11}.\n$$\n\n因此，从第一性原理构造的超限插值(TFI)映射为\n$$\n\\mathbf{x}(\\xi,\\eta) \\;=\\; \\mathbf{L}_{\\eta}(\\xi,\\eta) \\;+\\; \\mathbf{L}_{\\xi}(\\xi,\\eta) \\;-\\; \\mathbf{B}(\\xi,\\eta).\n$$\n\n我们现在验证边界再现性：\n\n1. 底边 $\\eta=0$：\n代入 $\\eta=0$：\n$$\n\\mathbf{x}(\\xi,0) = (1-0)\\mathbf{c}_{1}(\\xi) + 0\\cdot \\mathbf{c}_{2}(\\xi) + (1-\\xi)\\mathbf{d}_{1}(0) + \\xi \\mathbf{d}_{2}(0) - \\big[(1-\\xi)(1-0)\\mathbf{x}_{00} + \\xi(1-0)\\mathbf{x}_{10} + (1-\\xi)0\\,\\mathbf{x}_{01} + \\xi 0\\,\\mathbf{x}_{11}\\big].\n$$\n由于 $\\mathbf{d}_{1}(0)=\\mathbf{x}_{00}$ 和 $\\mathbf{d}_{2}(0)=\\mathbf{x}_{10}$，后两项与双线性角点项完全抵消，剩下\n$$\n\\mathbf{x}(\\xi,0) = \\mathbf{c}_{1}(\\xi).\n$$\n\n2. 顶边 $\\eta=1$：\n类似地，\n$$\n\\mathbf{x}(\\xi,1) = (1-1)\\mathbf{c}_{1}(\\xi) + 1\\cdot \\mathbf{c}_{2}(\\xi) + (1-\\xi)\\mathbf{d}_{1}(1) + \\xi \\mathbf{d}_{2}(1) - \\big[(1-\\xi)0\\,\\mathbf{x}_{00} + \\xi 0\\,\\mathbf{x}_{10} + (1-\\xi)1\\,\\mathbf{x}_{01} + \\xi 1\\,\\mathbf{x}_{11}\\big].\n$$\n使用 $\\mathbf{d}_{1}(1)=\\mathbf{x}_{01}$ 和 $\\mathbf{d}_{2}(1)=\\mathbf{x}_{11}$，最后两项与被减去的角点项抵消，得到\n$$\n\\mathbf{x}(\\xi,1) = \\mathbf{c}_{2}(\\xi).\n$$\n\n3. 左边 $\\xi=0$：\n$$\n\\mathbf{x}(0,\\eta) = (1-\\eta)\\mathbf{c}_{1}(0) + \\eta \\mathbf{c}_{2}(0) + (1-0)\\mathbf{d}_{1}(\\eta) + 0\\cdot \\mathbf{d}_{2}(\\eta) - \\big[(1-0)(1-\\eta)\\mathbf{x}_{00} + 0(1-\\eta)\\mathbf{x}_{10} + (1-0)\\eta\\,\\mathbf{x}_{01} + 0\\cdot \\eta\\,\\mathbf{x}_{11}\\big].\n$$\n使用 $\\mathbf{c}_{1}(0)=\\mathbf{x}_{00}$ 和 $\\mathbf{c}_{2}(0)=\\mathbf{x}_{01}$，相加的项与被减去的双线性角点项抵消，得到\n$$\n\\mathbf{x}(0,\\eta) = \\mathbf{d}_{1}(\\eta).\n$$\n\n4. 右边 $\\xi=1$：\n$$\n\\mathbf{x}(1,\\eta) = (1-\\eta)\\mathbf{c}_{1}(1) + \\eta \\mathbf{c}_{2}(1) + (1-1)\\mathbf{d}_{1}(\\eta) + 1\\cdot \\mathbf{d}_{2}(\\eta) - \\big[(1-1)(1-\\eta)\\mathbf{x}_{00} + 1(1-\\eta)\\mathbf{x}_{10} + (1-1)\\eta\\,\\mathbf{x}_{01} + 1\\cdot \\eta\\,\\mathbf{x}_{11}\\big].\n$$\n使用 $\\mathbf{c}_{1}(1)=\\mathbf{x}_{10}$ 和 $\\mathbf{c}_{2}(1)=\\mathbf{x}_{11}$，这些项再次抵消，得到\n$$\n\\mathbf{x}(1,\\eta) = \\mathbf{d}_{2}(\\eta).\n$$\n因此，该映射精确地再现了所有四个边界。\n\n现在我们使用明确的数据来计算 $\\mathbf{x}(\\xi,\\eta)$ 在 $(\\xi,\\eta)=\\big(\\tfrac{1}{3},\\tfrac{2}{5}\\big)$ 处的值。\n\n计算在指定参数下的边界值：\n$$\n\\mathbf{c}_{1}\\!\\big(\\tfrac{1}{3}\\big) = \\Big(\\tfrac{1}{3} + \\tfrac{1}{9},\\, \\tfrac{1}{2}\\cdot \\tfrac{1}{3}\\Big) = \\Big(\\tfrac{4}{9},\\, \\tfrac{1}{6}\\Big),\n$$\n$$\n\\mathbf{c}_{2}\\!\\big(\\tfrac{1}{3}\\big) = \\Big(1 + \\tfrac{1}{2}\\cos\\tfrac{\\pi}{3},\\, 1 + \\tfrac{1}{2}\\sin\\tfrac{\\pi}{3}\\Big) = \\Big(1 + \\tfrac{1}{2}\\cdot \\tfrac{1}{2},\\, 1 + \\tfrac{1}{2}\\cdot \\tfrac{\\sqrt{3}}{2}\\Big) = \\Big(\\tfrac{5}{4},\\, 1 + \\tfrac{\\sqrt{3}}{4}\\Big),\n$$\n$$\n\\mathbf{d}_{1}\\!\\big(\\tfrac{2}{5}\\big) = \\Big(\\tfrac{3}{2}\\cdot \\big(\\tfrac{2}{5}\\big)^{2},\\, \\tfrac{2}{5}\\Big) = \\Big(\\tfrac{6}{25},\\, \\tfrac{2}{5}\\Big),\n$$\n$$\n\\mathbf{d}_{2}\\!\\big(\\tfrac{2}{5}\\big) = \\Big(2 - \\tfrac{3}{2}\\cdot \\tfrac{2}{5},\\, \\tfrac{1}{2} + \\tfrac{1}{2}\\cdot \\tfrac{2}{5}\\Big) = \\Big(\\tfrac{7}{5},\\, \\tfrac{7}{10}\\Big).\n$$\n角点为\n$$\n\\mathbf{x}_{00}=(0,0),\\quad \\mathbf{x}_{10}=(2,\\tfrac{1}{2}),\\quad \\mathbf{x}_{01}=(\\tfrac{3}{2},1),\\quad \\mathbf{x}_{11}=(\\tfrac{1}{2},1).\n$$\n\n当 $(\\xi,\\eta)=\\big(\\tfrac{1}{3},\\tfrac{2}{5}\\big)$ 时，该映射的计算结果为\n$$\n\\mathbf{x} = (1-\\eta)\\,\\mathbf{c}_{1}(\\xi) + \\eta\\,\\mathbf{c}_{2}(\\xi) + (1-\\xi)\\,\\mathbf{d}_{1}(\\eta) + \\xi\\,\\mathbf{d}_{2}(\\eta) \\;-\\; \\Big[(1-\\xi)(1-\\eta)\\,\\mathbf{x}_{00} + \\xi(1-\\eta)\\,\\mathbf{x}_{10} + (1-\\xi)\\eta\\,\\mathbf{x}_{01} + \\xi\\eta\\,\\mathbf{x}_{11}\\Big].\n$$\n计算标量权重：\n$$\n1-\\eta = \\tfrac{3}{5},\\quad 1-\\xi = \\tfrac{2}{3},\\quad \\xi = \\tfrac{1}{3},\\quad \\eta = \\tfrac{2}{5}.\n$$\n首先，是四个混合项：\n$$\n(1-\\eta)\\,\\mathbf{c}_{1}(\\xi) = \\tfrac{3}{5}\\,\\Big(\\tfrac{4}{9},\\,\\tfrac{1}{6}\\Big) = \\Big(\\tfrac{4}{15},\\,\\tfrac{1}{10}\\Big),\n$$\n$$\n\\eta\\,\\mathbf{c}_{2}(\\xi) = \\tfrac{2}{5}\\,\\Big(\\tfrac{5}{4},\\,1 + \\tfrac{\\sqrt{3}}{4}\\Big) = \\Big(\\tfrac{1}{2},\\, \\tfrac{2}{5} + \\tfrac{\\sqrt{3}}{10}\\Big),\n$$\n$$\n(1-\\xi)\\,\\mathbf{d}_{1}(\\eta) = \\tfrac{2}{3}\\,\\Big(\\tfrac{6}{25},\\,\\tfrac{2}{5}\\Big) = \\Big(\\tfrac{4}{25},\\,\\tfrac{4}{15}\\Big),\n$$\n$$\n\\xi\\,\\mathbf{d}_{2}(\\eta) = \\tfrac{1}{3}\\,\\Big(\\tfrac{7}{5},\\,\\tfrac{7}{10}\\Big) = \\Big(\\tfrac{7}{15},\\,\\tfrac{7}{30}\\Big).\n$$\n将这四项相加得到\n$$\n\\mathbf{S}_{1} = \\Big(\\tfrac{209}{150},\\, 1 + \\tfrac{\\sqrt{3}}{10}\\Big).\n$$\n\n接下来，是双线性角点减法项：\n$$\n(1-\\xi)(1-\\eta)\\,\\mathbf{x}_{00} = \\tfrac{2}{5}\\,(0,0) = (0,0),\n$$\n$$\n\\xi(1-\\eta)\\,\\mathbf{x}_{10} = \\tfrac{1}{5}\\,(2,\\tfrac{1}{2}) = \\Big(\\tfrac{2}{5},\\,\\tfrac{1}{10}\\Big),\n$$\n$$\n(1-\\xi)\\eta\\,\\mathbf{x}_{01} = \\tfrac{4}{15}\\,(\\tfrac{3}{2},1) = \\Big(\\tfrac{2}{5},\\,\\tfrac{4}{15}\\Big),\n$$\n$$\n\\xi\\eta\\,\\mathbf{x}_{11} = \\tfrac{2}{15}\\,(\\tfrac{1}{2},1) = \\Big(\\tfrac{1}{15},\\,\\tfrac{2}{15}\\Big).\n$$\n将这四项相加得到\n$$\n\\mathbf{S}_{2} = \\Big(\\tfrac{13}{15},\\, \\tfrac{1}{2}\\Big).\n$$\n\n因此，\n$$\n\\mathbf{x}\\!\\Big(\\tfrac{1}{3},\\tfrac{2}{5}\\Big) \\;=\\; \\mathbf{S}_{1} - \\mathbf{S}_{2} \\;=\\; \\Big(\\tfrac{209}{150} - \\tfrac{13}{15},\\, 1 + \\tfrac{\\sqrt{3}}{10} - \\tfrac{1}{2}\\Big) \\;=\\; \\Big(\\tfrac{79}{150},\\, \\tfrac{5+\\sqrt{3}}{10}\\Big).\n$$\n这是由所构造的超限插值映射产生的内点的精确解析表达式，并且其边界再现属性已经通过一维混合和容斥原理从第一性原理得到证明。",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{79}{150}  \\frac{5+\\sqrt{3}}{10}\\end{pmatrix}}$$"
        },
        {
            "introduction": "一个有效的网格必须没有折叠或面积为零的单元，这一特性由映射的雅可比行列式（Jacobian determinant）决定。本练习通过将超限插值应用于一个角点角度 $\\theta$ 可控的简单平行四边形，清晰地阐释了这一原理。您将发现这个几何角度与雅可比行列式之间存在一个直接而优美的关系，从而揭示边界几何如何决定网格的有效性，并深入理解网格退化这一关键问题 。",
            "id": "3290601",
            "problem": "为一个凸四边形构造一个代数网格，使用由四条边界曲线构成的 Gordon–Hall 超限插值（TFI）曲面，这些曲线在一个角点相交，且该角点的内角可控。设物理域为由以下四个顶点给出的平行四边形：$r_{00}=(0,0)$、$r_{10}=(1,0)$、$r_{01}=(\\cos\\theta,\\sin\\theta)$ 和 $r_{11}=(1+\\cos\\theta,\\sin\\theta)$，其中 $\\theta\\in(0,\\pi)$ 是一个以弧度为单位的预设角度。边界曲线是以下直线段：\n- 底边 $C_{\\text{bottom}}(\\xi)=(\\xi,0)$，对于 $\\xi\\in[0,1]$，\n- 顶边 $C_{\\text{top}}(\\xi)=(\\xi+\\cos\\theta,\\sin\\theta)$，对于 $\\xi\\in[0,1]$，\n- 左边 $C_{\\text{left}}(\\eta)=(\\eta\\cos\\theta,\\eta\\sin\\theta)$，对于 $\\eta\\in[0,1]$，\n- 右边 $C_{\\text{right}}(\\eta)=(1+\\eta\\cos\\theta,\\eta\\sin\\theta)$，对于 $\\eta\\in[0,1]$。\n\n此设定保证了所有四个角点的边界切线连续性，且在内角点 $r_{00}$ 处，引入的边界切线之间的夹角为 $\\theta$。\n\n使用基于边界数据代数插值基本概念的超限插值定义：TFI 映射 $r:[0,1]^2\\to\\mathbb{R}^2$ 满足边界插值约束，并通过四条边界曲线的标准双参数混合构造而成。仅依赖于超限插值的核心定义和雅可比行列式作为面积缩放因子的定义 $J(\\xi,\\eta)=\\left\\lvert\\det\\left[\\partial r/\\partial(\\xi,\\eta)\\right]\\right\\rvert=\\lvert r_\\xi\\times r_\\eta\\rvert$（在二维情况下）。除这些普遍教授的基础知识外，不要假定任何专门的快捷公式。\n\n任务：\n1. 从第一性原理推导由给定边界曲线的超限插值生成的显式代数映射 $r(\\xi,\\eta)$，然后推导偏导数 $r_\\xi$ 和 $r_\\eta$ 的表达式。利用这些表达式，以符号形式表示雅可比行列式 $J(\\xi,\\eta)$，并确定 $J$ 是否依赖于 $(\\xi,\\eta)$。\n2. 根据定义，阐明左下角 $r_{00}$ 处角点正交性的充要条件（用该角点的边界切向量表示），并用 $\\theta$ 表达该条件。解释强制角点正交性如何等同于约束边界切线连续性的方向。\n3. 分析极限 $\\theta\\to 0^+$，并确定雅可比行列式 $J(\\xi,\\eta)$ 的行为，特别是它是否退化，以及对于小 $\\theta$ 值，它如何随 $\\theta$ 缩放。\n\n程序要求：\n- 实现一个程序，对于每个指定的测试角度 $\\theta$，根据推导结果构造映射，计算雅可比行列式 $J(\\xi,\\eta)$，并为每个测试用例报告以下内容：\n  - $J$ 在 $[0,1]^2$ 上的最小值，四舍五入到 $12$ 位小数。\n  - 一个布尔值，表示在 $\\varepsilon=10^{-12}$ 的容差范围内，计算坐标线在角点 $r_{00}$ 是否正交，即是否满足 $|r_\\xi(0,0)\\cdot r_\\eta(0,0)|\\le\\varepsilon$。\n  - 一个布尔值，表示在相同容差范围内，映射是否在域内任何地方存在雅可比行列式退化，即是否满足 $\\min_{\\xi,\\eta\\in[0,1]} J(\\xi,\\eta)\\le\\varepsilon$。\n- 角度必须以弧度为单位进行解释。\n- 最终输出必须是单行，包含所有测试用例结果的逗号分隔列表，并用方括号括起来，其中每个条目本身是按上述顺序包含三个量的列表。例如，包含两个测试用例的输出应类似于 $[[j_1,o_1,d_1],[j_2,o_2,d_2]]$，其中 $j_k$ 是一个四舍五入到12位小数的浮点数，$o_k$ 和 $d_k$ 是布尔值。\n\n测试套件：\n- 使用以下 $\\theta$ 值（单位为弧度）：$\\theta_1=\\pi/2$、$\\theta_2=\\pi/6$、$\\theta_3=10^{-3}$、$\\theta_4=10^{-12}$、$\\theta_5=3.0$。\n- 您的程序必须计算并按所要求的确切格式打印一个单行字符串，其中包含按给定顺序排列的五个测试用例的结果列表。",
            "solution": "此问题的核心是使用 Gordon-Hall 超限插值（TFI）从一个计算方形域 $(\\xi, \\eta) \\in [0,1]^2$ 构造到一个物理四边形域的映射 $r(\\xi,\\eta)$。TFI 映射是作为插值边界数据的投影算子的布尔和构造的。设 $P_\\xi$ 和 $P_\\eta$ 分别是沿 $\\xi$ 和 $\\eta$ 方向的线性投影算子。\n$$ P_\\xi[F](\\xi, \\eta) = (1-\\xi)F(0, \\eta) + \\xi F(1, \\eta) $$\n$$ P_\\eta[F](\\xi, \\eta) = (1-\\eta)F(\\xi, 0) + \\eta F(\\xi, 1) $$\nTFI 映射 $r(\\xi,\\eta)$ 由布尔和 $r = P_\\xi \\oplus P_\\eta$ 给出，展开为：\n$$ r(\\xi,\\eta) = P_\\xi[r](\\xi,\\eta) + P_\\eta[r](\\xi,\\eta) - (P_\\xi P_\\eta)[r](\\xi,\\eta) $$\n其中 $(P_\\xi P_\\eta)[r]$ 项是四个角点的双线性插值：\n$$ (P_\\xi P_\\eta)[r](\\xi,\\eta) = (1-\\xi)(1-\\eta)r(0,0) + \\xi(1-\\eta)r(1,0) + (1-\\xi)\\eta r(0,1) + \\xi\\eta r(1,1) $$\n\n### 任务1：映射及其雅可比行列式的推导\n\n我们已知四条边界曲线：\n$C_{\\text{bottom}}(\\xi) = r(\\xi, 0) = (\\xi, 0)$\n$C_{\\text{top}}(\\xi) = r(\\xi, 1) = (\\xi+\\cos\\theta, \\sin\\theta)$\n$C_{\\text{left}}(\\eta) = r(0, \\eta) = (\\eta\\cos\\theta, \\eta\\sin\\theta)$\n$C_{\\text{right}}(\\eta) = r(1, \\eta) = (1+\\eta\\cos\\theta, \\eta\\sin\\theta)$\n\n我们来计算 TFI 公式的各个项。\n首先，投影算子 $P_\\xi[r]$ 插值左右边界：\n$P_\\xi[r](\\xi,\\eta) = (1-\\xi)r(0,\\eta) + \\xi r(1,\\eta)$\n$P_\\xi[r](\\xi,\\eta) = (1-\\xi)(\\eta\\cos\\theta, \\eta\\sin\\theta) + \\xi(1+\\eta\\cos\\theta, \\eta\\sin\\theta)$\nx分量为 $(1-\\xi)\\eta\\cos\\theta + \\xi(1+\\eta\\cos\\theta) = \\eta\\cos\\theta - \\xi\\eta\\cos\\theta + \\xi + \\xi\\eta\\cos\\theta = \\xi + \\eta\\cos\\theta$。\ny分量为 $(1-\\xi)\\eta\\sin\\theta + \\xi\\eta\\sin\\theta = \\eta\\sin\\theta - \\xi\\eta\\sin\\theta + \\xi\\eta\\sin\\theta = \\eta\\sin\\theta$。\n所以，$P_\\xi[r](\\xi,\\eta) = (\\xi + \\eta\\cos\\theta, \\eta\\sin\\theta)$。\n\n其次，投影算子 $P_\\eta[r]$ 插值底部和顶部边界：\n$P_\\eta[r](\\xi,\\eta) = (1-\\eta)r(\\xi,0) + \\eta r(\\xi,1)$\n$P_\\eta[r](\\xi,\\eta) = (1-\\eta)(\\xi,0) + \\eta(\\xi+\\cos\\theta, \\sin\\theta)$\nx分量为 $(1-\\eta)\\xi + \\eta(\\xi+\\cos\\theta) = \\xi - \\xi\\eta + \\xi\\eta + \\eta\\cos\\theta = \\xi + \\eta\\cos\\theta$。\ny分量为 $(1-\\eta)0 + \\eta\\sin\\theta = \\eta\\sin\\theta$。\n所以，$P_\\eta[r](\\xi,\\eta) = (\\xi + \\eta\\cos\\theta, \\eta\\sin\\theta)$。\n\n第三，我们计算张量积投影算子项 $(P_\\xi P_\\eta)[r]$，即四个角点的双线性插值：\n$r(0,0)=(0,0)$，$r(1,0)=(1,0)$，$r(0,1)=(\\cos\\theta,\\sin\\theta)$，$r(1,1)=(1+\\cos\\theta,\\sin\\theta)$。\n$(P_\\xi P_\\eta)[r](\\xi,\\eta) = (1-\\xi)(1-\\eta)(0,0) + \\xi(1-\\eta)(1,0) + (1-\\xi)\\eta(\\cos\\theta,\\sin\\theta) + \\xi\\eta(1+\\cos\\theta,\\sin\\theta)$\nx分量为 $\\xi(1-\\eta) + (1-\\xi)\\eta\\cos\\theta + \\xi\\eta(1+\\cos\\theta) = \\xi - \\xi\\eta + \\eta\\cos\\theta - \\xi\\eta\\cos\\theta + \\xi\\eta + \\xi\\eta\\cos\\theta = \\xi+\\eta\\cos\\theta$。\ny分量为 $(1-\\xi)\\eta\\sin\\theta + \\xi\\eta\\sin\\theta = \\eta\\sin\\theta - \\xi\\eta\\sin\\theta + \\xi\\eta\\sin\\theta = \\eta\\sin\\theta$。\n所以，$(P_\\xi P_\\eta)[r](\\xi,\\eta) = (\\xi+\\eta\\cos\\theta, \\eta\\sin\\theta)$。\n\n现在，我们将这些结果代入 TFI 公式：\n$r(\\xi,\\eta) = P_\\xi[r] + P_\\eta[r] - P_\\xi P_\\eta[r] = (\\xi + \\eta\\cos\\theta, \\eta\\sin\\theta) + (\\xi + \\eta\\cos\\theta, \\eta\\sin\\theta) - (\\xi + \\eta\\cos\\theta, \\eta\\sin\\theta)$\n$$ r(\\xi,\\eta) = (\\xi + \\eta\\cos\\theta, \\eta\\sin\\theta) $$\n这个非常简洁的形式之所以出现，是因为所有四条边界曲线都是直线，使得 TFI 等效于四个角点之间的简单双线性插值。\n\n接下来，我们求映射 $r(\\xi,\\eta)$ 的偏导数。\n沿 $\\eta$ 等值线的切向量是：\n$$ r_\\xi(\\xi,\\eta) = \\frac{\\partial r}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}(\\xi + \\eta\\cos\\theta, \\eta\\sin\\theta) = (1, 0) $$\n沿 $\\xi$ 等值线的切向量是：\n$$ r_\\eta(\\xi,\\eta) = \\frac{\\partial r}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}(\\xi + \\eta\\cos\\theta, \\eta\\sin\\theta) = (\\cos\\theta, \\sin\\theta) $$\n\n雅可比行列式 $J(\\xi,\\eta)$ 是由这些偏导数向量构成的雅可比矩阵的行列式的绝对值：\n$$ J(\\xi,\\eta) = \\left\\lvert\\det\\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}\\right\\rvert = \\left\\lvert\\det\\begin{pmatrix} 1  \\cos\\theta \\\\ 0  \\sin\\theta \\end{pmatrix}\\right\\rvert $$\n$$ J(\\xi,\\eta) = |1 \\cdot \\sin\\theta - 0 \\cdot \\cos\\theta| = |\\sin\\theta| $$\n由于问题规定 $\\theta \\in (0, \\pi)$，$\\sin\\theta$ 始终为正。因此：\n$$ J(\\xi,\\eta) = \\sin\\theta $$\n对于给定的 $\\theta$，雅可比行列式是一个常数值，不依赖于坐标 $(\\xi, \\eta)$。\n\n### 任务2：角点正交性\n\n如果计算坐标线在一点 $(\\xi, \\eta)$ 的切向量 $r_\\xi$ 和 $r_\\eta$ 在该点正交，则这些坐标线在该点是正交的。正交的充要条件是它们的点积为零：\n$$ r_\\xi(\\xi,\\eta) \\cdot r_\\eta(\\xi,\\eta) = 0 $$\n在左下角 $r_{00}$（对应于 $(\\xi,\\eta)=(0,0)$），条件是 $r_\\xi(0,0) \\cdot r_\\eta(0,0) = 0$。使用推导出的常数偏导数：\n$$ r_\\xi(0,0) \\cdot r_\\eta(0,0) = (1, 0) \\cdot (\\cos\\theta, \\sin\\theta) = 1 \\cdot \\cos\\theta + 0 \\cdot \\sin\\theta = \\cos\\theta $$\n因此，在角点 $r_{00}$ 处正交的条件变为：\n$$ \\cos\\theta = 0 $$\n对于 $\\theta \\in (0, \\pi)$，唯一解是 $\\theta = \\pi/2$。\n\nTFI 公式确保了边界切线的连续性。在角点 $r_{00}$，$\\xi$ 坐标线的切线 $r_\\xi(0,0)=(1,0)$ 恰好是底部边界曲线 $C_{\\text{bottom}}(\\xi)$ 在 $\\xi=0$ 处的切线。同样，$\\eta$ 坐标线的切线 $r_\\eta(0,0)=(\\cos\\theta, \\sin\\theta)$ 是左侧边界曲线 $C_{\\text{left}}(\\eta)$ 在 $\\eta=0$ 处的切线。这些边界切线在角点处的夹角由 $\\theta$ 给出。因此，强制角点处计算网格线的正交性（$r_\\xi \\cdot r_\\eta = 0$），等同于约束物理边界切线之间的夹角为 $\\pi/2$。\n\n### 任务3：极限行为与退化\n\n当 $\\theta \\to 0^+$ 时，雅可比行列式 $J = \\sin\\theta$ 的行为是：\n$$ \\lim_{\\theta\\to 0^+} J(\\xi,\\eta) = \\lim_{\\theta\\to 0^+} \\sin\\theta = 0 $$\n如果映射的雅可比行列式为零，则认为该映射是退化的。当 $\\theta$ 趋近于 $0$ 时，雅可比行列式消失，表明映射变得退化。从几何上看，这对应于平行四边形坍缩为 x 轴上的一个一维线段，因为 $r_{01} \\to (1,0)$ 且 $r_{11} \\to (2,0)$。从二维单位正方形到一维直线的映射必然是退化的。\n对于小的 $\\theta$ 值，正弦函数可以用其泰勒级数展开来近似：$\\sin\\theta \\approx \\theta$。这表明对于小 $\\theta$，雅可比行列式 $J$ 与 $\\theta$ 呈线性缩放关系。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the algebraic grid generation problem for a set of test angles.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.pi / 2,     # theta_1\n        np.pi / 6,     # theta_2\n        1e-3,          # theta_3\n        1e-12,         # theta_4\n        3.0            # theta_5\n    ]\n    \n    # Tolerance for numerical comparisons.\n    epsilon = 1e-12\n\n    results = []\n    for theta in test_cases:\n        # Task 1: Jacobian Determinant\n        # From the derivation, J(xi, eta) = sin(theta) for theta in (0, pi).\n        # Since J is constant over the domain, its minimum value is simply J.\n        # For theta in (0, pi), sin(theta) > 0.\n        min_J = np.sin(theta)\n\n        # Task 2: Corner Orthogonality\n        # The condition for orthogonality at r_00 is r_xi . r_eta = 0.\n        # From the derivation, r_xi . r_eta = cos(theta).\n        # We check if |cos(theta)| = epsilon.\n        dot_product = np.cos(theta)\n        is_orthogonal = abs(dot_product) = epsilon\n\n        # Task 3: Jacobian Degeneracy\n        # The mapping is degenerate if min(J) = epsilon.\n        # Since min(J) = sin(theta), we check this condition.\n        is_degenerate = min_J = epsilon\n        \n        # Round min_J to 12 decimal places as required.\n        rounded_min_J = round(min_J, 12)\n\n        results.append([rounded_min_J, is_orthogonal, is_degenerate])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, so we need to format each inner list.\n    formatted_results = [\n        f\"[{res[0]}, {str(res[1]).lower()}, {str(res[2]).lower()}]\"\n        for res in results\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了有效性（$J \\gt 0$）之外，网格的质量，如单元的正交性和光滑性，对CFD模拟的精度和稳定性至关重要。本练习旨在探索在TFI框架内，代数混合函数的选择如何直接影响这些质量属性。通过实现和比较使用简单线性混合函数与更光滑的三次混合函数生成的网格，您将学习如何定量评估和控制网格的偏斜度与光滑度等特性 。",
            "id": "3290621",
            "problem": "您的任务是在平面上构建并比较两个代数结构化网格，这两个网格由相同的四条边界曲线生成，但使用两种不同的超限插值策略。您的程序必须从基本原理出发实现这两种策略，为每个网格计算两个量化的网格质量度量，然后汇总指定测试套件的结果。\n\n设定如下。假设存在一个从计算矩形域到物理域的映射，由向量值函数 $\\mathbf{X}(\\xi,\\eta) \\in \\mathbb{R}^2$ 给出，其中 $(\\xi,\\eta) \\in [0,1]\\times[0,1]$。该映射必须插值四条边界曲线 $\\mathbf{B}_0(\\xi) = \\mathbf{X}(\\xi,0)$、$\\mathbf{B}_1(\\xi) = \\mathbf{X}(\\xi,1)$、$\\mathbf{C}_0(\\eta) = \\mathbf{X}(0,\\eta)$ 和 $\\mathbf{C}_1(\\eta) = \\mathbf{X}(1,\\eta)$，并在角点处保持一致，即 $\\mathbf{B}_0(0) = \\mathbf{C}_0(0)$、$\\mathbf{B}_0(1) = \\mathbf{C}_1(0)$、$\\mathbf{B}_1(0) = \\mathbf{C}_0(1)$ 和 $\\mathbf{B}_1(1) = \\mathbf{C}_1(1)$。\n\n您的网格生成器必须通过对四条边界曲线进行超限插值来构建，使用的混合函数需满足单位分解和端点条件。具体来说，设 $g_0(\\xi)$ 和 $g_1(\\xi)$ 是 $\\xi$ 方向上的混合函数，$h_0(\\eta)$ 和 $h_1(\\eta)$ 是 $\\eta$ 方向上的混合函数，使得 $g_0(\\xi) + g_1(\\xi) = 1$、$h_0(\\eta) + h_1(\\eta) = 1$、$g_0(0) = 1$、$g_0(1) = 0$、$g_1(0) = 0$、$g_1(1) = 1$，同样地，$h_0(0) = 1$、$h_0(1) = 0$、$h_1(0) = 0$、$h_1(1) = 1$。从这些定义和映射插值边界曲线的要求出发，推导出 $\\mathbf{X}(\\xi,\\eta)$ 的超限插值公式，该公式应与容斥原理一致，以避免重复计算角点数据。\n\n您必须在相同的边界曲线上构建并比较两个网格：\n- 网格 A（双线性超限插值）：选择线性混合函数 $g_1(\\xi) = \\xi$、$g_0(\\xi) = 1 - \\xi$、$h_1(\\eta) = \\eta$、$h_0(\\eta) = 1 - \\eta$。\n- 网格 B（带三次参数化拉伸的 Coons 曲面）：选择单调三次斜坡函数 $\\sigma(\\xi) = 3\\xi^2 - 2\\xi^3$ 和 $\\rho(\\eta) = 3\\eta^2 - 2\\eta^3$，并设置 $g_1(\\xi) = \\sigma(\\xi)$、$g_0(\\xi) = 1 - \\sigma(\\xi)$、$h_1(\\eta) = \\rho(\\eta)$、$h_0(\\eta) = 1 - \\rho(\\eta)$。\n\n使用以下由实标量 $a$、$b$、$c$ 和 $d$ 参数化的角点一致的边界曲线族：\n- 底边 $\\mathbf{B}_0(\\xi) = \\big(\\xi + a \\sin(2\\pi \\xi)\\,\\xi(1-\\xi),\\; 0\\big)$，\n- 顶边 $\\mathbf{B}_1(\\xi) = \\big(\\xi + b \\sin(2\\pi \\xi)\\,\\xi(1-\\xi),\\; 1\\big)$，\n- 左边 $\\mathbf{C}_0(\\eta) = \\big(0,\\; \\eta + c \\sin(2\\pi \\eta)\\,\\eta(1-\\eta)\\big)$，\n- 右边 $\\mathbf{C}_1(\\eta) = \\big(1,\\; \\eta + d \\sin(2\\pi \\eta)\\,\\eta(1-\\eta)\\big)$。\n\n对于每个网格，您必须量化：\n1. 基于网格线正交性偏差的偏斜度度量。设网格节点处的协变基向量通过中心有限差分近似为 $\\mathbf{g}_\\xi \\approx \\mathbf{X}(\\xi+\\Delta\\xi,\\eta) - \\mathbf{X}(\\xi-\\Delta\\xi,\\eta)$ 和 $\\mathbf{g}_\\eta \\approx \\mathbf{X}(\\xi,\\eta+\\Delta\\eta) - \\mathbf{X}(\\xi,\\eta-\\Delta\\eta)$。定义局部正交性偏差为 $\\delta(\\xi,\\eta) = \\left| \\frac{\\pi}{2} - \\arccos\\left( \\frac{\\mathbf{g}_\\xi \\cdot \\mathbf{g}_\\eta}{\\|\\mathbf{g}_\\xi\\| \\,\\|\\mathbf{g}_\\eta\\|} \\right) \\right|$。偏斜度度量是 $\\delta(\\xi,\\eta)$ 在所有内部节点上的平均值。所有角度必须以弧度表示。\n\n2. 基于二阶差分的平滑度度量。使用中心二阶差分，定义 $\\Delta^2_\\xi \\mathbf{X} \\approx \\mathbf{X}(\\xi+\\Delta\\xi,\\eta) - 2\\mathbf{X}(\\xi,\\eta) + \\mathbf{X}(\\xi-\\Delta\\xi,\\eta)$ 和 $\\Delta^2_\\eta \\mathbf{X} \\approx \\mathbf{X}(\\xi,\\eta+\\Delta\\eta) - 2\\mathbf{X}(\\xi,\\eta) + \\mathbf{X}(\\xi,\\eta-\\Delta\\eta)$。在每个内部节点，计算 $s(\\xi,\\eta) = \\sqrt{\\|\\Delta^2_\\xi \\mathbf{X}\\|^2 + \\|\\Delta^2_\\eta \\mathbf{X}\\|^2}$。平滑度度量是 $s(\\xi,\\eta)$ 在所有内部节点上的平均值。\n\n您的程序必须：\n- 使用推导出的超限插值结构实现网格 A 和网格 B。\n- 为每个网格计算两个度量。\n- 对于每个测试用例，返回一个包含六个浮点数的列表：$[\\text{skew}_A,\\text{skew}_B,\\text{smooth}_A,\\text{smooth}_B,\\text{skew}_A-\\text{skew}_B,\\text{smooth}_A-\\text{smooth}_B]$。\n\n测试套件：\n- 用例 1（均衡的缓和曲率）：$N_\\xi = 21$，$N_\\eta = 21$，$(a,b,c,d) = (0.2, 0.2, 0.2, 0.2)$。\n- 用例 2（非对称的较强曲率，更高分辨率）：$N_\\xi = 41$，$N_\\eta = 31$，$(a,b,c,d) = (0.3, -0.1, 0.25, 0.0)$。\n- 用例 3（矩形域）：$N_\\xi = 17$，$N_\\eta = 19$，$(a,b,c,d) = (0.0, 0.0, 0.0, 0.0)$。\n\n角度单位：所有角度必须以弧度为单位。没有其他物理单位。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个 Python 风格的列表，该列表有三个元素（每个测试用例一个），每个元素本身是按上述顺序排列的六个浮点数结果的列表，例如 [[...case1...],[...case2...],[...case3...]]。",
            "solution": "### 1. 超限插值公式的推导\n\n目标是找到一个映射 $\\mathbf{X}(\\xi, \\eta) : [0,1]^2 \\to \\mathbb{R}^2$，该映射与四条给定的边界曲线相匹配：$\\mathbf{B}_0(\\xi) = \\mathbf{X}(\\xi,0)$、$\\mathbf{B}_1(\\xi) = \\mathbf{X}(\\xi,1)$、$\\mathbf{C}_0(\\eta) = \\mathbf{X}(0,\\eta)$ 和 $\\mathbf{C}_1(\\eta) = \\mathbf{X}(1,\\eta)$。该构造使用超限插值（TFI），它将标准多项式插值推广到函数，即它对一个连续的点集进行插值。\n\n我们定义两个投影算子 $P_\\xi$ 和 $P_\\eta$，它们从边界插值数据。\n投影算子 $P_\\xi$ 使用混合函数 $g_0(\\xi)$ 和 $g_1(\\xi)$ 在边界 $\\mathbf{C}_0(\\eta)$ 和 $\\mathbf{C}_1(\\eta)$ 之间构造一个直纹面：\n$$P_\\xi[\\mathbf{F}](\\xi,\\eta) = g_0(\\xi) \\mathbf{F}(0,\\eta) + g_1(\\xi) \\mathbf{F}(1,\\eta)$$\n投影算子 $P_\\eta$ 使用混合函数 $h_0(\\eta)$ 和 $h_1(\\eta)$ 在边界 $\\mathbf{B}_0(\\xi)$ 和 $\\mathbf{B}_1(\\xi)$ 之间构造一个直纹面：\n$$P_\\eta[\\mathbf{F}](\\xi,\\eta) = h_0(\\eta) \\mathbf{F}(\\xi,0) + h_1(\\eta) \\mathbf{F}(\\xi,1)$$\n混合函数必须满足端点和单位分解属性：$g_0(0)=1, g_0(1)=0, g_1(0)=0, g_1(1)=1$，以及 $g_0(\\xi)+g_1(\\xi)=1$。这同样适用于 $h_0, h_1$。\n\n这两个投影算子的简单求和 $(P_\\xi + P_\\eta)[\\mathbf{X}]$ 会重复计算角点信息。容斥原理要求我们减去公共部分，即被两个算子同时插值的信息。这引出了投影算子的布尔和：$P_{TFI} = P_\\xi \\oplus P_\\eta = P_\\xi + P_\\eta - P_\\xi P_\\eta$。\n\n将此应用于我们的映射函数 $\\mathbf{X}$，得到插值公式：\n$$\\mathbf{X}(\\xi,\\eta) = (P_\\xi + P_\\eta - P_\\xi P_\\eta)[\\mathbf{X}]$$\n让我们展开这些项：\n1. $P_\\xi[\\mathbf{X}](\\xi,\\eta) = g_0(\\xi) \\mathbf{X}(0,\\eta) + g_1(\\xi) \\mathbf{X}(1,\\eta) = g_0(\\xi) \\mathbf{C}_0(\\eta) + g_1(\\xi) \\mathbf{C}_1(\\eta)$。\n2. $P_\\eta[\\mathbf{X}](\\xi,\\eta) = h_0(\\eta) \\mathbf{X}(\\xi,0) + h_1(\\eta) \\mathbf{X}(\\xi,1) = h_0(\\eta) \\mathbf{B}_0(\\xi) + h_1(\\eta) \\mathbf{B}_1(\\xi)$。\n3. 乘积项 $P_\\xi P_\\eta[\\mathbf{X}]$ 是 $P_\\xi (P_\\eta[\\mathbf{X}])$。我们将 $P_\\xi$ 应用于 $P_\\eta$ 的结果：\n$$P_\\xi P_\\eta[\\mathbf{X}] = g_0(\\xi) [P_\\eta[\\mathbf{X}]]_{\\xi=0} + g_1(\\xi) [P_\\eta[\\mathbf{X}]]_{\\xi=1}$$\n$$= g_0(\\xi) [h_0(\\eta) \\mathbf{B}_0(0) + h_1(\\eta) \\mathbf{B}_1(0)] + g_1(\\xi) [h_0(\\eta) \\mathbf{B}_0(1) + h_1(\\eta) \\mathbf{B}_1(1)]$$\n使用角点一致性条件，例如 $\\mathbf{B}_0(0) = \\mathbf{X}(0,0)$、$\\mathbf{B}_1(0) = \\mathbf{X}(0,1)$ 等，可简化为：\n$$P_\\xi P_\\eta[\\mathbf{X}] = g_0(\\xi)h_0(\\eta)\\mathbf{X}(0,0) + g_0(\\xi)h_1(\\eta)\\mathbf{X}(0,1) + g_1(\\xi)h_0(\\eta)\\mathbf{X}(1,0) + g_1(\\xi)h_1(\\eta)\\mathbf{X}(1,1)$$\n这是对四个角点进行的张量积插值。\n\n结合这些项，得到最终的 TFI 公式，通常称为 Coons 曲面：\n$$\\mathbf{X}(\\xi,\\eta) = \\sum_{i=0}^{1} g_i(\\xi) \\mathbf{C}_i(\\eta) + \\sum_{j=0}^{1} h_j(\\eta) \\mathbf{B}_j(\\xi) - \\sum_{i=0}^{1}\\sum_{j=0}^{1} g_i(\\xi) h_j(\\eta) \\mathbf{X}(i,j)$$\n其中 $\\mathbf{C}_i(\\eta)$、$\\mathbf{B}_j(\\xi)$ 和 $\\mathbf{X}(i,j)$ 代表边界和角点数据。\n\n### 2. 网格生成与混合函数\n\n连续映射 $\\mathbf{X}(\\xi,\\eta)$ 在一个大小为 $N_\\xi \\times N_\\eta$ 的均匀计算网格上进行离散化。计算坐标为 $\\xi_i = i/(N_\\xi-1)$，其中 $i \\in \\{0, \\dots, N_\\xi-1\\}$，以及 $\\eta_j = j/(N_\\eta-1)$，其中 $j \\in \\{0, \\dots, N_\\eta-1\\}$。物理网格节点则计算为 $\\mathbf{X}_{i,j} = \\mathbf{X}(\\xi_i, \\eta_j)$。\n\n根据混合函数的不同选择，生成两种类型的网格：\n- **网格 A（双线性 TFI）：** 使用线性混合函数。\n  $$g_1(\\xi) = \\xi, \\quad g_0(\\xi) = 1-\\xi$$\n  $$h_1(\\eta) = \\eta, \\quad h_0(\\eta) = 1-\\eta$$\n- **网格 B（三次 TFI）：** 使用三次 Hermite 混合函数进行参数化拉伸，这些函数在端点处提供零导数，如果边界曲线与笛卡尔坐标轴对齐，则可产生边界正交的网格线。\n  $$\\sigma(t) = 3t^2 - 2t^3$$\n  $$g_1(\\xi) = \\sigma(\\xi), \\quad g_0(\\xi) = 1 - \\sigma(\\xi)$$\n  $$h_1(\\eta) = \\sigma(\\eta), \\quad h_0(\\eta) = 1 - \\sigma(\\eta)$$\n\n### 3. 网格质量度量\n\n生成的网格质量通过在网格内部节点（即 $i \\in \\{1, \\dots, N_\\xi-2\\}$ 和 $j \\in \\{1, \\dots, N_\\eta-2\\}$）上评估的两个度量来评估。\n\n**偏斜度度量：** 此度量量化与正交性的偏差。切向（协变基）向量 $\\mathbf{g}_\\xi = \\partial\\mathbf{X}/\\partial\\xi$ 和 $\\mathbf{g}_\\eta = \\partial\\mathbf{X}/\\partial\\eta$ 使用二阶中心有限差分进行近似：\n$$\\mathbf{g}_\\xi(\\xi_i, \\eta_j) \\approx \\frac{\\mathbf{X}_{i+1,j} - \\mathbf{X}_{i-1,j}}{2\\Delta\\xi}, \\quad \\mathbf{g}_\\eta(\\xi_i, \\eta_j) \\approx \\frac{\\mathbf{X}_{i,j+1} - \\mathbf{X}_{i,j-1}}{2\\Delta\\eta}$$\n由于比例因子 $2\\Delta\\xi$ 不影响角度，问题将用于角度计算的向量定义为 $\\mathbf{g}_\\xi \\approx \\mathbf{X}_{i+1,j} - \\mathbf{X}_{i-1,j}$ 和 $\\mathbf{g}_\\eta \\approx \\mathbf{X}_{i,j+1} - \\mathbf{X}_{i,j-1}$。它们之间的角度 $\\theta$ 通过点积求得。局部正交性偏差为 $\\delta_{i,j} = |\\frac{\\pi}{2} - \\theta_{i,j}|$。偏斜度度量是 $\\delta_{i,j}$ 在所有内部节点上的平均值。\n\n**平滑度度量：** 此度量量化网格间距的变化。它基于映射函数二阶导数的模，通过中心二阶差分近似：\n$$\\Delta^2_\\xi \\mathbf{X} \\approx \\mathbf{X}_{i+1,j} - 2\\mathbf{X}_{i,j} + \\mathbf{X}_{i-1,j}$$\n$$\\Delta^2_\\eta \\mathbf{X} \\approx \\mathbf{X}_{i,j+1} - 2\\mathbf{X}_{i,j} + \\mathbf{X}_{i,j-1}$$\n局部平滑度值为 $s_{i,j} = \\sqrt{\\|\\Delta^2_\\xi \\mathbf{X}\\|^2 + \\|\\Delta^2_\\eta \\mathbf{X}\\|^2}$。平滑度度量是 $s_{i,j}$ 在所有内部节点上的平均值。\n\n### 4. 算法实现\n\n对于由 $(N_\\xi, N_\\eta, a, b, c, d)$ 指定的每个测试用例：\n1. 为网格 A（线性）和网格 B（三次）定义混合函数 $\\{g_0, g_1, h_0, h_1\\}$。\n2. 创建大小为 $N_\\xi$ 和 $N_\\eta$ 的均匀计算坐标数组 `xi_v` 和 `eta_v`。\n3. 对于每种网格类型（A 和 B）：\n    a. 在离散点 `xi_v` 和 `eta_v` 上评估四条边界曲线 $\\mathbf{B}_0(\\xi), \\mathbf{B}_1(\\xi), \\mathbf{C}_0(\\eta), \\mathbf{C}_1(\\eta)$。\n    b. 应用推导出的 TFI 公式计算所有 $(i,j)$ 的物理网格坐标 $\\mathbf{X}_{i,j}$。这需要谨慎使用数组广播以实现高效计算。\n    c. 通过将有限差分公式应用于网格 $\\mathbf{X}$ 的内部来计算偏斜度和光滑度度量。\n4. 将计算出的四个度量（$\\text{skew}_A, \\text{skew}_B, \\text{smooth}_A, \\text{smooth}_B$）及其差异整合为包含六个值的单个列表。\n5. 收集所有测试用例的结果，并按指定格式化最终输出。\n\n当 $a=b=c=d=0$ 时，该情况可作为验证性检查。此时，边界形成一个单位正方形。TFI 公式应重现恒等映射 $\\mathbf{X}(\\xi,\\eta) = (\\xi,\\eta)$，从而产生一个完美的笛卡尔网格，其偏斜度和光滑度度量均为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and compares two algebraic structured grids using different\n    transfinite interpolation (TFI) strategies and computes grid quality metrics.\n    \"\"\"\n\n    # --- Blending Functions ---\n    # Grid A: Linear blending functions\n    def g1_A(xi): return xi\n    def g0_A(xi): return 1.0 - xi\n    def h1_A(eta): return eta\n    def h0_A(eta): return 1.0 - eta\n\n    # Grid B: Cubic (Hermite) blending functions\n    def sigma(t): return 3.0 * t**2 - 2.0 * t**3\n    def g1_B(xi): return sigma(xi)\n    def g0_B(xi): return 1.0 - sigma(xi)\n    def h1_B(eta): return sigma(eta)\n    def h0_B(eta): return 1.0 - sigma(eta)\n\n    # --- Boundary Curve Definitions ---\n    def B0(xi, a, b, c, d):\n        x = xi + a * np.sin(2.0 * np.pi * xi) * xi * (1.0 - xi)\n        y = np.zeros_like(xi)\n        return np.stack((x, y), axis=-1)\n\n    def B1(xi, a, b, c, d):\n        x = xi + b * np.sin(2.0 * np.pi * xi) * xi * (1.0 - xi)\n        y = np.ones_like(xi)\n        return np.stack((x, y), axis=-1)\n\n    def C0(eta, a, b, c, d):\n        x = np.zeros_like(eta)\n        y = eta + c * np.sin(2.0 * np.pi * eta) * eta * (1.0 - eta)\n        return np.stack((x, y), axis=-1)\n\n    def C1(eta, a, b, c, d):\n        x = np.ones_like(eta)\n        y = eta + d * np.sin(2.0 * np.pi * eta) * eta * (1.0 - eta)\n        return np.stack((x, y), axis=-1)\n\n    def generate_grid(N_xi, N_eta, params, g_funcs, h_funcs):\n        \"\"\"\n        Generates a 2D structured grid using transfinite interpolation.\n        \"\"\"\n        a, b, c, d = params\n        g0, g1 = g_funcs\n        h0, h1 = h_funcs\n        \n        xi_v = np.linspace(0.0, 1.0, N_xi)\n        eta_v = np.linspace(0.0, 1.0, N_eta)\n        \n        # 'ij' indexing ensures shape is (N_xi, N_eta)\n        XI, ETA = np.meshgrid(xi_v, eta_v, indexing='ij')\n\n        # Evaluate boundary curves on the discrete points\n        B0_vals = B0(xi_v, a, b, c, d)  # Shape (N_xi, 2)\n        B1_vals = B1(xi_v, a, b, c, d)  # Shape (N_xi, 2)\n        C0_vals = C0(eta_v, a, b, c, d)  # Shape (N_eta, 2)\n        C1_vals = C1(eta_v, a, b, c, d)  # Shape (N_eta, 2)\n\n        # Evaluate blending functions on the computational grid\n        G0 = g0(XI)\n        G1 = g1(XI)\n        H0 = h0(ETA)\n        H1 = h1(ETA)\n\n        # Apply TFI formula using numpy broadcasting\n        # Term 1: Interpolation from xi-boundaries\n        term1 = G0[..., None] * C0_vals[None, :, :] + G1[..., None] * C1_vals[None, :, :]\n        # Term 2: Interpolation from eta-boundaries\n        term2 = H0[..., None] * B0_vals[:, None, :] + H1[..., None] * B1_vals[:, None, :]\n        \n        # Term 3: Corner correction term\n        X00, X10 = B0_vals[0], B0_vals[-1]\n        X01, X11 = B1_vals[0], B1_vals[-1]\n        \n        term3 = (G0[..., None] * H0[..., None] * X00[None, None, :] +\n                 G1[..., None] * H0[..., None] * X10[None, None, :] +\n                 G0[..., None] * H1[..., None] * X01[None, None, :] +\n                 G1[..., None] * H1[..., None] * X11[None, None, :])\n\n        X = term1 + term2 - term3\n        return X\n\n    def calculate_metrics(X):\n        \"\"\"\n        Computes skewness and smoothness metrics for a given grid.\n        \"\"\"\n        N_xi, N_eta, _ = X.shape\n        if N_xi  3 or N_eta  3:\n            return 0.0, 0.0\n\n        # --- Skewness Metric ---\n        # Approximate tangent vectors using centered differences on interior nodes\n        g_xi = X[2:, 1:-1, :] - X[:-2, 1:-1, :]\n        g_eta = X[1:-1, 2:, :] - X[1:-1, :-2, :]\n\n        # Calculate angle between tangent vectors\n        dot_product = np.sum(g_xi * g_eta, axis=2)\n        norm_g_xi = np.linalg.norm(g_xi, axis=2)\n        norm_g_eta = np.linalg.norm(g_eta, axis=2)\n        \n        denominator = norm_g_xi * norm_g_eta\n        # Avoid division by zero for robustness\n        cos_theta = np.divide(dot_product, denominator, \n                              out=np.zeros_like(dot_product), \n                              where=denominator != 0)\n        \n        cos_theta = np.clip(cos_theta, -1.0, 1.0)\n        theta = np.arccos(cos_theta)\n        \n        # Orthogonality deviation in radians\n        ortho_dev = np.abs(np.pi / 2.0 - theta)\n        skewness = np.mean(ortho_dev)\n        \n        # --- Smoothness Metric ---\n        # Approximate second derivatives using centered differences\n        d2X_dxi2 = X[2:, 1:-1, :] - 2 * X[1:-1, 1:-1, :] + X[:-2, 1:-1, :]\n        d2X_deta2 = X[1:-1, 2:, :] - 2 * X[1:-1, 1:-1, :] + X[1:-1, :-2, :]\n\n        # Compute magnitude of second derivatives\n        norm_sq_d2xi = np.sum(d2X_dxi2**2, axis=2)\n        norm_sq_d2eta = np.sum(d2X_deta2**2, axis=2)\n        \n        s = np.sqrt(norm_sq_d2xi + norm_sq_d2eta)\n        smoothness = np.mean(s)\n        \n        return skewness, smoothness\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"N_xi\": 21, \"N_eta\": 21, \"params\": (0.2, 0.2, 0.2, 0.2)},\n        {\"N_xi\": 41, \"N_eta\": 31, \"params\": (0.3, -0.1, 0.25, 0.0)},\n        {\"N_xi\": 17, \"N_eta\": 19, \"params\": (0.0, 0.0, 0.0, 0.0)},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N_xi, N_eta, params = case[\"N_xi\"], case[\"N_eta\"], case[\"params\"]\n\n        # Generate Grid A and calculate metrics\n        grid_A = generate_grid(N_xi, N_eta, params, (g0_A, g1_A), (h0_A, h1_A))\n        skew_A, smooth_A = calculate_metrics(grid_A)\n\n        # Generate Grid B and calculate metrics\n        grid_B = generate_grid(N_xi, N_eta, params, (g0_B, g1_B), (h0_B, h1_B))\n        skew_B, smooth_B = calculate_metrics(grid_B)\n        \n        skew_diff = skew_A - skew_B\n        smooth_diff = smooth_A - smooth_B\n\n        case_results = [skew_A, skew_B, smooth_A, smooth_B, skew_diff, smooth_diff]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in all_results)}]\")\n\nsolve()\n```"
        }
    ]
}