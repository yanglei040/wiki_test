{
    "hands_on_practices": [
        {
            "introduction": "将理论付诸实践是掌握超限插值（TFI）的关键。这项练习将引导您从基本原理出发，将核心的超限插值公式转化为可执行的代码，从而根据四条给定的边界曲线生成一个二维网格片。通过亲手构建这个曲面，您将具体地理解超限插值是如何融合边界信息，并运用容斥原理来精确修正角点贡献的。",
            "id": "3384022",
            "problem": "考虑使用超限插值（TFI）为网格生成构建一个二维参数化曲面片。给定四条边界折线作为参数化三次样条：沿 $t$ 方向的两条边界，记为 $C_{t0}(s)$ 和 $C_{t1}(s)$，以及沿 $s$ 方向的两条边界，记为 $C_{s0}(t)$ 和 $C_{s1}(t)$。角点定义为：$(s,t)=(0,0)$ 处的 $P_{00}$，$(s,t)=(1,0)$ 处的 $P_{10}$，$(s,t)=(0,1)$ 处的 $P_{01}$，以及 $(s,t)=(1,1)$ 处的 $P_{11}$。目标是根据超限插值原理计算混合边界曲线的内部映射 $P(s,t)$，并验证容斥校正。\n\n基本假设：\n- 参数化三次样条插值生成 $C^2$ 连续曲线，对每条边界曲线的给定数据点进行精确插值。\n- 超限插值通过混合沿 $s$ 和 $t$ 方向的一维插值体从其边界曲线构造曲面，这种方式可强制实现边界一致性，并通过容斥原理消除对角点贡献的双重计算。\n\n定义四个角点如下：\n- $P_{00} = (0.5, 0.1)$，\n- $P_{10} = (2.1, 0.3)$，\n- $P_{01} = (0.0, 1.7)$，\n- $P_{11} = (2.2, 1.9)$。\n\n通过其参数化三次样条控制点定义四条边界折线。对于 $t=0$ 处的边界 $C_{t0}(s)$，使用参数值 $s \\in \\{0, 0.25, 0.5, 0.75, 1\\}$ 及对应点：\n- $s=0$: $(0.5, 0.1)$，\n- $s=0.25$: $(0.9, -0.05)$，\n- $s=0.5$: $(1.4, 0.20)$，\n- $s=0.75$: $(1.8, 0.35)$，\n- $s=1$: $(2.1, 0.3)$。\n\n对于 $t=1$ 处的边界 $C_{t1}(s)$，使用参数值 $s \\in \\{0, 0.35, 0.7, 1\\}$ 及对应点：\n- $s=0$: $(0.0, 1.7)$，\n- $s=0.35$: $(0.8, 2.0)$，\n- $s=0.7$: $(1.5, 1.4)$，\n- $s=1$: $(2.2, 1.9)$。\n\n对于 $s=0$ 处的边界 $C_{s0}(t)$，使用参数值 $t \\in \\{0, 0.4, 0.8, 1\\}$ 及对应点：\n- $t=0$: $(0.5, 0.1)$，\n- $t=0.4$: $(0.2, 0.8)$，\n- $t=0.8$: $(-0.1, 1.3)$，\n- $t=1$: $(0.0, 1.7)$。\n\n对于 $s=1$ 处的边界 $C_{s1}(t)$，使用参数值 $t \\in \\{0, 0.2, 0.6, 1\\}$ 及对应点：\n- $t=0$: $(2.1, 0.3)$，\n- $t=0.2$: $(2.6, 0.5)$，\n- $t=0.6$: $(2.4, 1.2)$，\n- $t=1$: $(2.2, 1.9)$。\n\n令容斥角点校正为双线性混合\n$$\nB(s,t) = (1-s)(1-t)P_{00} + s(1-t)P_{10} + (1-s)t\\,P_{01} + st\\,P_{11}.\n$$\n从超限插值原理出发，推导 $P(s,t)$ 作为沿 $s$ 和 $t$ 方向的边界插值体与 $B(s,t)$ 的组合，以避免对角点的双重计算。为给定的边界三次样条显式实现 $P(s,t)$。\n\n测试集：\n在以下参数对 $(s,t)$ 集合上进行评估：\n- 角点：$(0,0)$、$(1,0)$、$(0,1)$、$(1,1)$。\n- 边中点：$(0.5,0)$、$(0.5,1)$、$(0,0.5)$、$(1,0.5)$。\n- 内部点：$(0.3,0.4)$、$(0.75,0.25)$。\n\n对于每个 $(s,t)$，计算：\n1. 容斥残差，定义为 $R(s,t) = \\left[H(s,t)+V(s,t)\\right] - P(s,t) - B(s,t)$ 的最大绝对分量，其中 $H(s,t)$ 是超限插值中使用的 $t$ 方向混合，$V(s,t)$ 是 $s$ 方向混合。\n2. 边界一致性误差，定义为当 $(s,t)$ 位于边界上时，$P(s,t)$ 与适用边界曲线之差的最大绝对分量：如果 $t=0$，与 $C_{t0}(s)$ 比较；如果 $t=1$，与 $C_{t1}(s)$ 比较；如果 $s=0$，与 $C_{s0}(t)$ 比较；如果 $s=1$，与 $C_{s1}(t)$ 比较。对于角点，与两条适用的边界进行比较并报告两者中的最大值；对于内部点，报告 $0$。\n3. 角点处的校正前双重计算误差，定义为 $\\left[H(s,t)+V(s,t)\\right] - P_{\\mathrm{corner}}$ 的最大绝对分量，其中 $P_{\\mathrm{corner}}$ 是对应的角点 $P_{00}$、$P_{10}$、$P_{01}$ 或 $P_{11}$。对于非角点，报告 $0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，其中每个条目对应测试集中的一个 $(s,t)$ 对，并且其本身是按上述顺序排列的三个浮点数的列表（例如，$[[e_{11},e_{12},e_{13}],[e_{21},e_{22},e_{23}],\\ldots]$）。所有量均为无量纲实数。不要进行任何四舍五入；报告计算产生的原始浮点结果。",
            "solution": "用户在计算网格生成领域提供了一个定义明确的问题，具体涉及超限插值（TFI）的应用。\n\n### 步骤1：提取已知条件\n- **角点**：\n  - $P_{00} = (0.5, 0.1)$\n  - $P_{10} = (2.1, 0.3)$\n  - $P_{01} = (0.0, 1.7)$\n  - $P_{11} = (2.2, 1.9)$\n- **边界 $C_{t0}(s)$ (于 $t=0$)**：通过以下点的参数化三次样条：\n  - $(s, P) \\in \\{(0, (0.5, 0.1)), (0.25, (0.9, -0.05)), (0.5, (1.4, 0.20)), (0.75, (1.8, 0.35)), (1, (2.1, 0.3))\\}$\n- **边界 $C_{t1}(s)$ (于 $t=1$)**：通过以下点的参数化三次样条：\n  - $(s, P) \\in \\{(0, (0.0, 1.7)), (0.35, (0.8, 2.0)), (0.7, (1.5, 1.4)), (1, (2.2, 1.9))\\}$\n- **边界 $C_{s0}(t)$ (于 $s=0$)**：通过以下点的参数化三次样条：\n  - $(t, P) \\in \\{(0, (0.5, 0.1)), (0.4, (0.2, 0.8)), (0.8, (-0.1, 1.3)), (1, (0.0, 1.7))\\}$\n- **边界 $C_{s1}(t)$ (于 $s=1$)**：通过以下点的参数化三次样条：\n  - $(t, P) \\in \\{(0, (2.1, 0.3)), (0.2, (2.6, 0.5)), (0.6, (2.4, 1.2)), (1, (2.2, 1.9))\\}$\n- **双线性混合定义**：\n  $B(s,t) = (1-s)(1-t)P_{00} + s(1-t)P_{10} + (1-s)t\\,P_{01} + st\\,P_{11}$\n- **测试集**：\n  - $(s,t) \\in \\{(0,0), (1,0), (0,1), (1,1), (0.5,0), (0.5,1), (0,0.5), (1,0.5), (0.3,0.4), (0.75,0.25)\\}$\n- **误差度量**：对每个测试点，计算一个包含三个值的列表：\n  1. 容斥残差：$\\max|\\left[H(s,t)+V(s,t)\\right] - P(s,t) - B(s,t)|$\n  2. 边界一致性误差：如果在边界上，则为 $\\max|P(s,t) - C_{\\text{boundary}}|$，否则为 $0$。\n  3. 角点双重计算误差：如果在角点处，则为 $\\max|\\left[H(s,t)+V(s,t)\\right] - P_{\\mathrm{corner}}|$，否则为 $0$。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于成熟的超限插值理论，这是计算机辅助几何设计（CAGD）和计算流体动力学（CFD）中生成结构化网格的标准技术。所有概念和公式都是标准的。\n- **适定性**：该问题提供了所有必要信息：四条边界曲线和四个角点。经检查确认，边界曲线的端点与指定的角点正确重合（例如，$C_{t0}(0) = P_{00}$，$C_{t0}(1) = P_{10}$，$C_{s0}(0) = P_{00}$，$C_{s0}(1)=P_{01}$ 等），确保形成一个闭合有效的边界环。插值方法（TFI）也已明确定义。\n- **客观性**：问题使用精确的数学语言陈述，待计算的量由明确的公式定义。\n\n### 步骤3：结论与行动\n该问题具有科学合理性、适定性、自洽性和客观性。它是**有效的**。我们开始求解。\n\n### 基于原理的解决方案\n\n目标是构建一个参数化曲面 $P(s,t)$，该曲面插值四条给定的边界曲线 $C_{t0}(s)$、$C_{t1}(s)$、$C_{s0}(t)$ 和 $C_{s1}(t)$。这些曲线在参数域 $(s,t) \\in [0,1] \\times [0,1]$ 中构成一个单位正方形的边界。这通过使用超限插值（TFI）来实现。\n\nTFI 的核心思想是混合一维插值。我们首先定义两个曲面，每个曲面插值一对相对的边界曲线。\n\n1. 第一个曲面，我们记为 $H(s,t)$，使用 $t$ 方向的线性混合函数来插值 $t=0$ 和 $t=1$ 处的边界（参数平面中的“水平”边界）：\n$$H(s,t) = (1-t)C_{t0}(s) + t C_{t1}(s)$$\n此构造确保了 $H(s,0) = C_{t0}(s)$ 和 $H(s,1) = C_{t1}(s)$。\n\n2. 第二个曲面 $V(s,t)$，使用 $s$ 方向的线性混合函数来插值 $s=0$ 和 $s=1$ 处的边界（“垂直”边界）：\n$$V(s,t) = (1-s)C_{s0}(t) + s C_{s1}(t)$$\n此构造确保了 $V(0,t) = C_{s0}(t)$ 和 $V(1,t) = C_{s1}(t)$。\n\n一个简单的方法是将这两个曲面相加，$H(s,t) + V(s,t)$。然而，这会导致错误的结果，因为角点的贡献被计算了两次。例如，在角点 $(s,t)=(0,0)$ 处：\n- $H(0,0) = (1-0)C_{t0}(0) + 0 \\cdot C_{t1}(0) = C_{t0}(0) = P_{00}$\n- $V(0,0) = (1-0)C_{s0}(0) + 0 \\cdot C_{s1}(0) = C_{s0}(0) = P_{00}$\n其和为 $H(0,0) + V(0,0) = P_{00} + P_{00} = 2P_{00}$。这种重复计算发生在所有四个角点上。\n\n容斥原理解决了这个问题。我们必须减去 $H(s,t)$ 和 $V(s,t)$ 共有的插值部分。这个公共部分是仅插值四个角点 $P_{00}$、$P_{10}$、$P_{01}$ 和 $P_{11}$ 的曲面。角点的双线性插值可以实现这一点：\n$$B(s,t) = (1-s)(1-t)P_{00} + s(1-t)P_{10} + (1-s)tP_{01} + stP_{11}$$\n这就是问题中指定的双线性混合。请注意，$B(s,t)$ 是将 $s$ 方向插值方案应用于 $t$ 方向插值方案的边界（反之亦然）所得到的结果。\n\n最终的超限插值曲面 $P(s,t)$ 是通过将两个方向的插值体相加，然后减去被双重计算的双线性角点混合来构造的：\n$$P(s,t) = H(s,t) + V(s,t) - B(s,t)$$\n\n此公式正确地满足所有边界条件。例如，我们来验证 $t=0$ 处的边界：\n$P(s,0) = H(s,0) + V(s,0) - B(s,0)$\n- $H(s,0) = (1-0)C_{t0}(s) + 0 \\cdot C_{t1}(s) = C_{t0}(s)$\n- $V(s,0) = (1-s)C_{s0}(0) + sC_{s1}(0) = (1-s)P_{00} + sP_{10}$\n- $B(s,0) = (1-s)(1-0)P_{00} + s(1-0)P_{10} + (1-s)\\cdot 0 \\cdot P_{01} + s \\cdot 0 \\cdot P_{11} = (1-s)P_{00} + sP_{10}$\n将这些代入 $P(s,0)$ 的方程中：\n$P(s,0) = C_{t0}(s) + \\left[(1-s)P_{00} + sP_{10}\\right] - \\left[(1-s)P_{00} + sP_{10}\\right] = C_{t0}(s)$\n曲面正确地再现了边界曲线 $C_{t0}(s)$。类似的推导可以表明 $P(s,t)$ 正确地再现了其他三条边界曲线。\n\n实现将按以下步骤进行：\n1.  使用 `scipy.interpolate.CubicSpline` 根据给定的控制点定义四个参数化三次样条 $C_{t0}(s)$、$C_{t1}(s)$、$C_{s0}(t)$ 和 $C_{s1}(t)$。样条将假定采用`natural`边界条件。\n2.  基于推导出的公式，实现函数 $H(s,t)$、$V(s,t)$、$B(s,t)$ 以及最终曲面 $P(s,t)$。\n3.  遍历 $(s,t)$ 参数对的测试集，并计算三个指定的误差度量。\n\n- **容斥残差**：$R(s,t) = [H(s,t)+V(s,t)] - P(s,t) - B(s,t)$。根据 $P(s,t)$ 的定义，我们有 $P(s,t) + B(s,t) = H(s,t) + V(s,t)$。因此，$R(s,t)$ 必须恒等于零向量，其最大绝对分量将为 $0$（在浮点精度范围内）。此计算可作为对实现的健全性检查。\n- **边界一致性误差**：如上所述，TFI曲面 $P(s,t)$ 保证与边界曲线完全匹配。因此，对于所有边界点，此误差将为 $0$（在浮点精度范围内）。对于内部点，定义为 $0$。\n- **角点双重计算误差**：这个量衡量的是如果简单地将 $H(s,t)$ 和 $V(s,t)$ 相加，在角点处会产生的误差。在角点，比如说 $(s,t)=(0,0)$，误差为 $\\max|H(0,0)+V(0,0)-P_{00}| = \\max|P_{00}+P_{00}-P_{00}| = \\max|P_{00}|$。该值将为非零，并表示通过减去 $B(s,t)$ 来校正的角点重复计算的量。对于所有非角点，此误差定义为 $0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Computes TFI surface points and associated error metrics for a given test suite.\n    \"\"\"\n    # 1. DEFINE GIVEN DATA\n    # Corner points\n    P00 = np.array([0.5, 0.1])\n    P10 = np.array([2.1, 0.3])\n    P01 = np.array([0.0, 1.7])\n    P11 = np.array([2.2, 1.9])\n\n    # Boundary curve spline parameters and points\n    # C_t0(s) at t=0\n    s_t0 = [0, 0.25, 0.5, 0.75, 1]\n    pts_t0 = np.array([[0.5, 0.1], [0.9, -0.05], [1.4, 0.20], [1.8, 0.35], [2.1, 0.3]])\n\n    # C_t1(s) at t=1\n    s_t1 = [0, 0.35, 0.7, 1]\n    pts_t1 = np.array([[0.0, 1.7], [0.8, 2.0], [1.5, 1.4], [2.2, 1.9]])\n\n    # C_s0(t) at s=0\n    t_s0 = [0, 0.4, 0.8, 1]\n    pts_s0 = np.array([[0.5, 0.1], [0.2, 0.8], [-0.1, 1.3], [0.0, 1.7]])\n    \n    # C_s1(t) at s=1\n    t_s1 = [0, 0.2, 0.6, 1]\n    pts_s1 = np.array([[2.1, 0.3], [2.6, 0.5], [2.4, 1.2], [2.2, 1.9]])\n\n    # 2. CREATE PARAMETRIC CUBIC SPLINES FOR BOUNDARIES\n    # Use 'natural' boundary conditions as a standard choice.\n    spline_t0 = CubicSpline(s_t0, pts_t0, bc_type='natural', axis=0)\n    spline_t1 = CubicSpline(s_t1, pts_t1, bc_type='natural', axis=0)\n    spline_s0 = CubicSpline(t_s0, pts_s0, bc_type='natural', axis=0)\n    spline_s1 = CubicSpline(t_s1, pts_s1, bc_type='natural', axis=0)\n\n    # Wrapper functions for clarity\n    def C_t0(s): return spline_t0(s)\n    def C_t1(s): return spline_t1(s)\n    def C_s0(t): return spline_s0(t)\n    def C_s1(t): return spline_s1(t)\n\n    # 3. DEFINE TFI COMPONENT FUNCTIONS\n    def H(s, t):\n        return (1 - t) * C_t0(s) + t * C_t1(s)\n    \n    def V(s, t):\n        return (1 - s) * C_s0(t) + s * C_s1(t)\n    \n    def B(s, t):\n        return (1 - s) * (1 - t) * P00 + s * (1 - t) * P10 + \\\n               (1 - s) * t * P01 + s * t * P11\n    \n    def P(s, t):\n        return H(s, t) + V(s, t) - B(s, t)\n\n    # 4. DEFINE TEST SUITE\n    test_cases = [\n        # Corners\n        (0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (1.0, 1.0),\n        # Edge midpoints\n        (0.5, 0.0), (0.5, 1.0), (0.0, 0.5), (1.0, 0.5),\n        # Interior points\n        (0.3, 0.4), (0.75, 0.25)\n    ]\n    \n    results = []\n    \n    # 5. PROCESS TEST CASES AND CALCULATE ERRORS\n    for s, t in test_cases:\n        # Error 1: Inclusion-Exclusion Residual\n        residual_vec = (H(s, t) + V(s, t)) - P(s, t) - B(s, t)\n        e1 = np.max(np.abs(residual_vec))\n\n        # Error 2: Boundary Consistency Error\n        e2 = 0.0\n        # A small tolerance is good practice, but for these exact inputs, direct comparison is fine.\n        is_on_boundary_t0 = (t == 0.0)\n        is_on_boundary_t1 = (t == 1.0)\n        is_on_boundary_s0 = (s == 0.0)\n        is_on_boundary_s1 = (s == 1.0)\n        \n        is_on_boundary = is_on_boundary_t0 or is_on_boundary_t1 or is_on_boundary_s0 or is_on_boundary_s1\n        \n        if is_on_boundary:\n            err_t0 = np.max(np.abs(P(s, t) - C_t0(s))) if is_on_boundary_t0 else -1.0\n            err_t1 = np.max(np.abs(P(s, t) - C_t1(s))) if is_on_boundary_t1 else -1.0\n            err_s0 = np.max(np.abs(P(s, t) - C_s0(t))) if is_on_boundary_s0 else -1.0\n            err_s1 = np.max(np.abs(P(s, t) - C_s1(t))) if is_on_boundary_s1 else -1.0\n            e2 = max(err for err in [err_t0, err_t1, err_s0, err_s1] if err >= 0.0)\n\n        # Error 3: Corner Double-Counting Error\n        e3 = 0.0\n        if (s, t) == (0.0, 0.0):\n            e3 = np.max(np.abs(H(s, t) + V(s, t) - P00))\n        elif (s, t) == (1.0, 0.0):\n            e3 = np.max(np.abs(H(s, t) + V(s, t) - P10))\n        elif (s, t) == (0.0, 1.0):\n            e3 = np.max(np.abs(H(s, t) + V(s, t) - P01))\n        elif (s, t) == (1.0, 1.0):\n            e3 = np.max(np.abs(H(s, t) + V(s, t) - P11))\n        \n        results.append([e1, e2, e3])\n\n    # 6. FORMAT AND PRINT OUTPUT\n    # The default string representation of a list is '[item1, item2, ...]'\n    # which matches the required inner format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "生成网格仅仅是第一步，评估其质量对于确保可靠的计算流体动力学（CFD）模拟至关重要。本练习引入微分几何的工具来分析网格，特别是通过计算度量张量的分量。您将学习这些系数如何量化网格的局部特性，例如拉伸和偏斜度，从而为网格优化提供必不可少的诊断依据。",
            "id": "3384066",
            "problem": "考虑在计算流体力学中用于生成结构化网格的二维超限插值（Coons 曲面）。该曲面在计算坐标 $(s,t) \\in [0,1] \\times [0,1]$ 的单位正方形上由物理空间 $\\mathbb{R}^2$ 中的四条边界曲线定义：\n- $t=0$ 处的底边界：$C_0(s) = \\big(2s,\\,0\\big)$，\n- $t=1$ 处的顶边界：$C_1(s) = \\big(2s,\\,1 + \\epsilon \\sin(\\pi s)\\big)$，\n- $s=0$ 处的左边界：$D_0(t) = \\big(\\delta \\sin(\\pi t),\\,t\\big)$，\n- $s=1$ 处的右边界：$D_1(t) = \\big(2 + \\delta \\sin(\\pi t),\\,t\\big)$，\n\n并在角点 $(s,t) \\in \\{0,1\\}^2$ 处确保了一致性。Coons 曲面是通过对这些边界曲线进行双线性混合来构建的，\n$$\nP(s,t) = (1-t)\\,C_0(s) + t\\,C_1(s) + (1-s)\\,D_0(t) + s\\,D_1(t) - \\big[(1-s)(1-t)P_{00} + s(1-t)P_{10} + (1-s)tP_{01} + stP_{11}\\big],\n$$\n其中 $P_{00},P_{10},P_{01},P_{11}$ 是由边界曲线所隐含的四个角点。\n\n从这个定义出发，并仅使用曲线坐标微分几何的基本定义（度量张量和内积），执行以下操作：\n1. 显式地推导 $P(s,t)$ 的分量形式。\n2. 计算偏导数 $P_s = \\partial P/\\partial s$ 和 $P_t = \\partial P/\\partial t$。\n3. 推导该曲面的度量系数 $g_{ss} = \\|P_s\\|^2$、$g_{tt} = \\|P_t\\|^2$ 和 $g_{st} = P_s \\cdot P_t$。\n4. 将非正交性（偏斜度）度量定义为\n$$\nM(s,t) \\equiv \\frac{|g_{st}(s,t)|}{\\sqrt{g_{ss}(s,t)\\,g_{tt}(s,t)}},\n$$\n并解释为什么 $M=0$ 对应于网格线的正交性，而更大的 $M$ 值表示更大的偏斜度。\n5. 对于 $\\epsilon = 0.2$ 和 $\\delta = 0.3$，计算在 $s=\\frac{1}{3}$ 和 $t=\\frac{1}{3}$ 处的 $M(s,t)$。\n\n将 $M\\!\\left(\\frac{1}{3},\\frac{1}{3}\\right)$ 的最终数值答案四舍五入到 4 位有效数字。将您的最终答案表示为一个纯数（无量纲）。不要包含单位。如果讨论到角度，应以弧度为单位，但您无需报告任何角度；仅报告 $M$ 的数值。",
            "solution": "首先对问题进行验证，以确保其具有科学依据、是良构的且客观的。\n\n### 步骤 1：提取已知条件\n- 计算域：$(s,t) \\in [0,1] \\times [0,1]$。\n- 边界曲线：\n  - $t=0$ 时：$C_0(s) = \\big(2s,\\,0\\big)$。\n  - $t=1$ 时：$C_1(s) = \\big(2s,\\,1 + \\epsilon \\sin(\\pi s)\\big)$。\n  - $s=0$ 时：$D_0(t) = \\big(\\delta \\sin(\\pi t),\\,t\\big)$。\n  - $s=1$ 时：$D_1(t) = \\big(2 + \\delta \\sin(\\pi t),\\,t\\big)$。\n- Coons 曲面公式：$P(s,t) = (1-t)C_0(s) + tC_1(s) + (1-s)D_0(t) + sD_1(t) - \\big[(1-s)(1-t)P_{00} + s(1-t)P_{10} + (1-s)tP_{01} + stP_{11}\\big]$。\n- 非正交性度量：$M(s,t) = \\frac{|g_{st}(s,t)|}{\\sqrt{g_{ss}(s,t)\\,g_{tt}(s,t)}}$。\n- 求值点：$(s,t) = (\\frac{1}{3}, \\frac{1}{3})$。\n- 参数：$\\epsilon = 0.2$，$\\delta = 0.3$。\n- 最终指令：将 $M(\\frac{1}{3},\\frac{1}{3})$ 的数值四舍五入到 4 位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，属于计算流体力学和微分几何领域。超限插值（Coons 曲面）方法和度量张量分量的定义是标准且正确的。检查边界曲线在角点处的一致性：\n- $P_{00}: C_0(0) = (0,0)$ 且 $D_0(0) = (0,0)$。一致。$P_{00}=(0,0)$。\n- $P_{10}: C_0(1) = (2,0)$ 且 $D_1(0) = (2,0)$。一致。$P_{10}=(2,0)$。\n- $P_{01}: C_1(0) = (0,1)$ 且 $D_0(1) = (\\delta\\sin(\\pi),1)=(0,1)$。一致。$P_{01}=(0,1)$。\n- $P_{11}: C_1(1) = (2,1+\\epsilon\\sin(\\pi))=(2,1)$ 且 $D_1(1) = (2+\\delta\\sin(\\pi),1)=(2,1)$。一致。$P_{11}=(2,1)$。\n问题是良构的、自洽的，并为得到唯一解提供了所有必要信息。语言是客观且明确的。未检测到任何缺陷。\n\n### 步骤 3：结论与行动\n问题有效。下面提供完整解答。\n\n### 任务 1：显式推导 $P(s,t)$\nCoons 曲面由 $P(s,t) = L_s P(s,t) + L_t P(s,t) - L_s L_t P(s,t)$ 定义，其中 $L_s$ 和 $L_t$ 是线性插值算子。给定的公式是其展开式。让我们计算各项。\n底部和顶部曲线的线性插值是：\n$$L_t P(s,t) = (1-t)C_0(s) + tC_1(s) = (1-t)(2s,0) + t(2s, 1+\\epsilon\\sin(\\pi s)) = (2s, t(1+\\epsilon\\sin(\\pi s)))$$\n左侧和右侧曲线的线性插值是：\n$$L_s P(s,t) = (1-s)D_0(t) + sD_1(t) = (1-s)(\\delta\\sin(\\pi t), t) + s(2+\\delta\\sin(\\pi t), t) = (2s+\\delta\\sin(\\pi t), t)$$\n角点的双线性插值是：\n$$L_s L_t P(s,t) = (1-s)(1-t)P_{00} + s(1-t)P_{10} + (1-s)tP_{01} + stP_{11}$$\n$$L_s L_t P(s,t) = (1-s)(1-t)(0,0) + s(1-t)(2,0) + (1-s)t(0,1) + st(2,1) = (2s, t)$$\n结合这些项得到映射 $P(s,t) = (x(s,t), y(s,t))$：\n$$P(s,t) = (2s+\\delta\\sin(\\pi t), t) + (2s, t(1+\\epsilon\\sin(\\pi s))) - (2s, t)$$\n$x$ 分量是 $x(s,t) = (2s+\\delta\\sin(\\pi t)) + 2s - 2s = 2s+\\delta\\sin(\\pi t)$。\n$y$ 分量是 $y(s,t) = t + t(1+\\epsilon\\sin(\\pi s)) - t = t(1+\\epsilon\\sin(\\pi s))$。\n所以，该映射的显式分量形式是：\n$$P(s,t) = \\big(2s + \\delta \\sin(\\pi t),\\, t(1 + \\epsilon \\sin(\\pi s))\\big)$$\n\n### 任务 2：计算偏导数 $P_s$ 和 $P_t$\n偏导数是坐标线的切向量。\n$P_s(s,t) = \\frac{\\partial P}{\\partial s} = \\left(\\frac{\\partial x}{\\partial s}, \\frac{\\partial y}{\\partial s}\\right)$。\n$$\\frac{\\partial x}{\\partial s} = \\frac{\\partial}{\\partial s}\\left(2s + \\delta \\sin(\\pi t)\\right) = 2$$\n$$\\frac{\\partial y}{\\partial s} = \\frac{\\partial}{\\partial s}\\left(t(1 + \\epsilon \\sin(\\pi s))\\right) = t\\epsilon\\pi\\cos(\\pi s)$$\n因此，$P_s(s,t) = \\big(2, t\\epsilon\\pi\\cos(\\pi s)\\big)$。\n\n$P_t(s,t) = \\frac{\\partial P}{\\partial t} = \\left(\\frac{\\partial x}{\\partial t}, \\frac{\\partial y}{\\partial t}\\right)$。\n$$\\frac{\\partial x}{\\partial t} = \\frac{\\partial}{\\partial t}\\left(2s + \\delta \\sin(\\pi t)\\right) = \\delta\\pi\\cos(\\pi t)$$\n$$\\frac{\\partial y}{\\partial t} = \\frac{\\partial}{\\partial t}\\left(t(1 + \\epsilon \\sin(\\pi s))\\right) = 1 + \\epsilon \\sin(\\pi s)$$\n因此，$P_t(s,t) = \\big(\\delta\\pi\\cos(\\pi t), 1 + \\epsilon \\sin(\\pi s)\\big)$。\n\n### 任务 3：推导度量系数\n度量系数 $g_{ij}$ 是切向量的内积。\n$g_{ss}(s,t) = P_s \\cdot P_s = \\|P_s\\|^2 = (2)^2 + (t\\epsilon\\pi\\cos(\\pi s))^2$。\n$$g_{ss}(s,t) = 4 + t^2\\epsilon^2\\pi^2\\cos^2(\\pi s)$$\n$g_{tt}(s,t) = P_t \\cdot P_t = \\|P_t\\|^2 = (\\delta\\pi\\cos(\\pi t))^2 + (1 + \\epsilon \\sin(\\pi s))^2$。\n$$g_{tt}(s,t) = \\delta^2\\pi^2\\cos^2(\\pi t) + (1 + \\epsilon \\sin(\\pi s))^2$$\n$g_{st}(s,t) = P_s \\cdot P_t = (2)(\\delta\\pi\\cos(\\pi t)) + (t\\epsilon\\pi\\cos(\\pi s))(1 + \\epsilon \\sin(\\pi s))$。\n$$g_{st}(s,t) = 2\\delta\\pi\\cos(\\pi t) + t\\epsilon\\pi\\cos(\\pi s)(1 + \\epsilon \\sin(\\pi s))$$\n\n### 任务 4：解释非正交性度量 $M(s,t)$\n向量 $P_s$ 和 $P_t$ 分别是常数 $t$ 网格线和常数 $s$ 网格线的切向量。在点 $P(s,t)$ 处，这些网格线之间的夹角 $\\theta(s,t)$ 是这两个切向量之间的夹角。$P_s$ 和 $P_t$ 的内积（点积）定义为 $P_s \\cdot P_t = \\|P_s\\| \\|P_t\\| \\cos(\\theta)$。\n用度量系数表示，这可以写成 $g_{st} = \\sqrt{g_{ss}} \\sqrt{g_{tt}} \\cos(\\theta)$。\n重新整理这个方程，得到 $\\cos(\\theta)$ 的表达式：\n$$\\cos(\\theta) = \\frac{g_{st}}{\\sqrt{g_{ss}g_{tt}}}$$\n非正交性度量定义为 $M(s,t) = \\frac{|g_{st}(s,t)|}{\\sqrt{g_{ss}(s,t)g_{tt}(s,t)}}$。通过比较，我们看到 $M(s,t) = |\\cos(\\theta)|$。\n- 如果网格线是正交的，$\\theta = \\pi/2$，这使得 $\\cos(\\theta) = 0$。因此，$M=0$ 表示完全正交。\n- 如果网格线高度偏斜，它们几乎平行，所以角度 $\\theta$ 接近 $0$ 或 $\\pi$。在这种情况下，$|\\cos(\\theta)|$ 接近 $1$。$M=1$ 的值对应于网格线共线的退化单元。\n因此，$M$ 是衡量局部偏离正交性程度的指标，值越大表示偏斜度越大，这在数值模拟中通常是不希望出现的，因为它会降低精度。\n\n### 任务 5：计算 $M(1/3, 1/3)$ 的值\n给定 $s=1/3$, $t=1/3$, $\\epsilon = 0.2$ 和 $\\delta = 0.3$。\n首先，计算三角函数的值：\n$$\\pi s = \\frac{\\pi}{3} \\implies \\sin(\\pi s) = \\frac{\\sqrt{3}}{2}, \\quad \\cos(\\pi s) = \\frac{1}{2}$$\n$$\\pi t = \\frac{\\pi}{3} \\implies \\cos(\\pi t) = \\frac{1}{2}$$\n现在，我们计算该点的度量系数。\n$$g_{ss}\\left(\\frac{1}{3},\\frac{1}{3}\\right) = 4 + \\left(\\frac{1}{3}\\right)^2(0.2)^2\\pi^2\\cos^2\\left(\\frac{\\pi}{3}\\right) = 4 + \\frac{1}{9}(0.04)\\pi^2\\left(\\frac{1}{2}\\right)^2 = 4 + \\frac{0.04\\pi^2}{36} = 4 + \\frac{\\pi^2}{900}$$\n数值上，$g_{ss} \\approx 4 + \\frac{(3.14159...)^2}{900} \\approx 4 + 0.0109662 \\approx 4.0109662$。\n\n$$g_{tt}\\left(\\frac{1}{3},\\frac{1}{3}\\right) = (0.3)^2\\pi^2\\cos^2\\left(\\frac{\\pi}{3}\\right) + \\left(1 + 0.2\\sin\\left(\\frac{\\pi}{3}\\right)\\right)^2 = 0.09\\pi^2\\left(\\frac{1}{2}\\right)^2 + \\left(1 + 0.2\\frac{\\sqrt{3}}{2}\\right)^2$$\n$$g_{tt}\\left(\\frac{1}{3},\\frac{1}{3}\\right) = 0.0225\\pi^2 + (1+0.1\\sqrt{3})^2$$\n数值上，$g_{tt} \\approx 0.0225(9.86960) + (1+0.1(1.73205))^2 \\approx 0.222066 + (1.173205)^2 \\approx 0.222066 + 1.376410 \\approx 1.598476$。\n\n$$g_{st}\\left(\\frac{1}{3},\\frac{1}{3}\\right) = 2(0.3)\\pi\\cos\\left(\\frac{\\pi}{3}\\right) + \\frac{1}{3}(0.2)\\pi\\cos\\left(\\frac{\\pi}{3}\\right)\\left(1 + 0.2\\sin\\left(\\frac{\\pi}{3}\\right)\\right)$$\n$$g_{st}\\left(\\frac{1}{3},\\frac{1}{3}\\right) = 0.6\\pi\\left(\\frac{1}{2}\\right) + \\frac{0.2\\pi}{3}\\left(\\frac{1}{2}\\right)\\left(1 + 0.1\\sqrt{3}\\right) = 0.3\\pi + \\frac{0.1\\pi}{3}(1+0.1\\sqrt{3})$$\n由于所有项均为正，所以 $|g_{st}| = g_{st}$。\n数值上，$g_{st} \\approx 0.3(3.14159) + \\frac{0.1(3.14159)}{3}(1.173205) \\approx 0.942478 + 0.104720(1.173205) \\approx 0.942478 + 0.122856 \\approx 1.065334$。\n\n最后，我们计算 $M(1/3, 1/3)$：\n$$M\\left(\\frac{1}{3},\\frac{1}{3}\\right) = \\frac{|g_{st}|}{\\sqrt{g_{ss}g_{tt}}} \\approx \\frac{1.065334}{\\sqrt{(4.0109662)(1.598476)}} = \\frac{1.065334}{\\sqrt{6.411420}} \\approx \\frac{1.065334}{2.532078}$$\n$$M\\left(\\frac{1}{3},\\frac{1}{3}\\right) \\approx 0.4207298$$\n四舍五入到 4 位有效数字，结果是 $0.4207$。",
            "answer": "$$\\boxed{0.4207}$$"
        },
        {
            "introduction": "超限插值虽然功能强大，但并非万无一失，过于扭曲的边界可能导致网格发生自我折叠。这项练习通过检验映射的雅可比行列式（Jacobian determinant）$J$来探究这种致命的失效模式。您将构建一个有意引发网格反转的情景，并学习如何利用雅可比行列式的符号来检测和量化这些无效区域，这是稳健网格生成的一项关键技能。",
            "id": "3384030",
            "problem": "考虑通过在单位正方形参数域上进行超限插值来构建二维结构化网格。设参数域为 $u$ 方向上的区间 $[0,1]$ 和 $v$ 方向上的区间 $[0,1]$ 的笛卡尔积。在物理平面中规定了四条边界曲线，底边（$v=0$）表示为 $\\mathbf{B}(u)$，顶边（$v=1$）表示为 $\\mathbf{T}(u)$，左边（$u=0$）表示为 $\\mathbf{L}(v)$，右边（$u=1$）表示为 $\\mathbf{R}(v)$。通过使用超限插值混合这些边界，定义了 Coons 曲面映射 $\\mathbf{P}(u,v)$。该映射的雅可比行列式，记为 $J(u,v)=\\det\\left(\\frac{\\partial \\mathbf{P}}{\\partial (u,v)}\\right)$，编码了局部方向和面积缩放；$J(u,v)$ 的负值表示单元反转（方向翻转）。\n\n从参数化映射 $\\mathbf{P}(u,v)$ 导出雅可比张量 $\\frac{\\partial \\mathbf{P}}{\\partial (u,v)}$（其行列式 $J(u,v)$ 提供了局部面积和方向的变化）这一基本原理出发。根据四条给定边界曲线的超限插值定义，推导 Coons 曲面 $\\mathbf{P}(u,v)$ 的表达式，然后推导 $\\frac{\\partial \\mathbf{P}}{\\partial u}$ 和 $\\frac{\\partial \\mathbf{P}}{\\partial v}$ 关于边界数据及其导数的表达式。使用这些表达式计算单位正方形上的 $J(u,v)$。\n\n设计一个因不相容的边界数据或极端凹性而表现出单元反转的反例。为了使构造具体且可测试，使用以下由实标量 $\\alpha$ 和 $\\beta$ 以及方向标志 $\\sigma_T \\in \\{+1,-1\\}$ 和 $\\sigma_R \\in \\{+1,-1\\}$ 参数化的一族边界曲线，这些标志分别控制顶边和右边的方向：\n\n- 底边：$\\mathbf{B}(u)=\\begin{bmatrix}u \\\\ 0\\end{bmatrix}$，对于 $u\\in[0,1]$。\n- 左边：$\\mathbf{L}(v)=\\begin{bmatrix}0 \\\\ v\\end{bmatrix}$，对于 $v\\in[0,1]$。\n- 顶边：$\\mathbf{T}(u)=\\begin{bmatrix}x_T(u) \\\\ 1-\\alpha \\sin(\\pi u)\\end{bmatrix}$，对于 $u\\in[0,1]$，其中若 $\\sigma_T=+1$ 则 $x_T(u)=u$，若 $\\sigma_T=-1$ 则 $x_T(u)=1-u$。\n- 右边：$\\mathbf{R}(v)=\\begin{bmatrix}1+\\beta \\sin(\\pi v) \\\\ y_R(v)\\end{bmatrix}$，对于 $v\\in[0,1]$，其中若 $\\sigma_R=+1$ 则 $y_R(v)=v$，若 $\\sigma_R=-1$ 则 $y_R(v)=1-v$。\n\n假设 Coons 曲面的角点数据在需要时从左边和底边获取以解决不相容性，具体为 $P_{00}=\\mathbf{L}(0)$，$P_{01}=\\mathbf{L}(1)$，$P_{10}=\\mathbf{B}(1)$ 和 $P_{11}=\\mathbf{T}(1)$。使用这些边界曲线和角点，通过超限插值构造 $\\mathbf{P}(u,v)$。然后，计算参数域 $[0,1]^2$ 上的雅可比行列式 $J(u,v)$。\n\n通过测量 $J(u,v)  0$ 区域的勒贝格面积（在 $u$-$v$ 参数空间中，这是无量纲的）来量化反转程度，该面积记为 $A_{-}=\\int_{[0,1]^2} \\mathbf{1}_{\\{J(u,v)0\\}} \\, \\mathrm{d}u\\,\\mathrm{d}v$，其中 $\\mathbf{1}$ 是指示函数。将每个计算出的面积表示为小数（无百分号），并四舍五入到 $6$ 位小数。\n\n使用以下测试套件来检验不同的行为：\n\n- 测试案例 1（行为良好的矩形）：$\\alpha=0$, $\\beta=0$, $\\sigma_T=+1$, $\\sigma_R=+1$。\n- 测试案例 2（顶边极端凹陷）：$\\alpha=2.0$, $\\beta=0$, $\\sigma_T=+1$, $\\sigma_R=+1$。\n- 测试案例 3（通过反转顶边方向导致边界数据不相容）：$\\alpha=0$, $\\beta=0$, $\\sigma_T=-1$, $\\sigma_R=+1$。\n- 测试案例 4（通过反转右边方向并带有凹陷导致边界数据不相容）：$\\alpha=0$, $\\beta=0.8$, $\\sigma_T=+1$, $\\sigma_R=-1$。\n\n您的程序应通过在每个参数方向上使用分辨率为 $N$ 的网格上进行均匀采样来为每个测试案例近似计算 $A_{-}$，使用 $J(u,v)0$ 的采样点分数作为估计量（即黎曼和近似）。使用 $N=800$ 以确保足够的覆盖范围，并将每个结果四舍五入到 $6$ 位小数。\n\n最终输出格式：您的程序应生成一行输出，其中包含四个结果，格式为逗号分隔的列表，并用方括号括起来（例如 $[a_1,a_2,a_3,a_4]$），其中每个 $a_i$ 是按上述顺序列出的测试案例 $i$ 的四舍五入后的面积 $A_{-}$。不应打印其他任何文本。",
            "solution": "该问题要求分析通过超限插值生成的二维结构化网格中的单元反转。该网格是一个从单位正方形参数域 $(u,v) \\in [0,1]^2$ 到物理域 $(x,y)$ 的映射。当映射的雅可比行列式变为负值时，就会发生单元反转。我们必须首先推导双线性混合 Coons 曲面的雅可比行列式 $J(u,v)$ 的通用表达式，然后将其应用于一族特定的边界曲线，以计算几个测试案例中反转区域的面积。\n\n设四条边界曲线表示为 $\\mathbf{B}(u) = \\mathbf{P}(u,0)$、$\\mathbf{T}(u) = \\mathbf{P}(u,1)$、$\\mathbf{L}(v) = \\mathbf{P}(0,v)$ 和 $\\mathbf{R}(v) = \\mathbf{P}(1,v)$。Coons 曲面是通过两个线性直纹面的布尔和构造的，并由角的双线性插值进行校正。映射 $\\mathbf{P}(u,v) = [x(u,v), y(u,v)]^T$ 的公式为：\n$$\n\\mathbf{P}(u,v) = (1-v)\\mathbf{B}(u) + v\\mathbf{T}(u) + (1-u)\\mathbf{L}(v) + u\\mathbf{R}(v) - \\mathbf{P}_{corners}(u,v)\n$$\n其中角点校正项 $\\mathbf{P}_{corners}(u,v)$ 由下式给出：\n$$\n\\mathbf{P}_{corners}(u,v) = (1-u)(1-v)P_{00} + u(1-v)P_{10} + (1-u)vP_{01} + uvP_{11}\n$$\n问题指定角点为 $P_{00}=\\mathbf{L}(0)$，$P_{01}=\\mathbf{L}(1)$，$P_{10}=\\mathbf{B}(1)$ 和 $P_{11}=\\mathbf{T}(1)$。\n\n映射的雅可比矩阵由 $\\mathbf{P}(u,v)$ 相对于 $u$ 和 $v$ 的偏导数构成：\n$$\n\\mathbf{J}_{\\mathbf{P}}(u,v) = \\frac{\\partial \\mathbf{P}}{\\partial(u,v)} = \\left[ \\frac{\\partial \\mathbf{P}}{\\partial u} \\quad \\frac{\\partial \\mathbf{P}}{\\partial v} \\right]\n$$\n雅可比行列式为 $J(u,v) = \\det(\\mathbf{J}_{\\mathbf{P}}) = \\frac{\\partial x}{\\partial u}\\frac{\\partial y}{\\partial v} - \\frac{\\partial x}{\\partial v}\\frac{\\partial y}{\\partial u}$。\n\n为了求偏导数，我们对 $\\mathbf{P}(u,v)$ 的表达式进行微分。让撇号表示相对于曲线参数的微分。\n$$\n\\frac{\\partial \\mathbf{P}}{\\partial u} = (1-v)\\mathbf{B}'(u) + v\\mathbf{T}'(u) - \\mathbf{L}(v) + \\mathbf{R}(v) - \\frac{\\partial}{\\partial u}\\mathbf{P}_{corners}(u,v)\n$$\n$$\n\\frac{\\partial \\mathbf{P}}{\\partial v} = -\\mathbf{B}(u) + \\mathbf{T}(u) + (1-u)\\mathbf{L}'(v) + u\\mathbf{R}'(v) - \\frac{\\partial}{\\partial v}\\mathbf{P}_{corners}(u,v)\n$$\n角点项的导数为：\n$$\n\\frac{\\partial}{\\partial u}\\mathbf{P}_{corners}(u,v) = -(1-v)P_{00} + (1-v)P_{10} - vP_{01} + vP_{11}\n$$\n$$\n\\frac{\\partial}{\\partial v}\\mathbf{P}_{corners}(u,v) = -(1-u)P_{00} - uP_{10} + (1-u)P_{01} + uP_{11}\n$$\n将这些代入 $\\mathbf{P}$ 的偏导数表达式中，即可得到雅可比矩阵各列的通用公式。\n\n问题提供了以下一族曲线：\n- $\\mathbf{B}(u)=\\begin{bmatrix}u \\\\ 0\\end{bmatrix} \\implies \\mathbf{B}'(u)=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$\n- $\\mathbf{L}(v)=\\begin{bmatrix}0 \\\\ v\\end{bmatrix} \\implies \\mathbf{L}'(v)=\\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$\n- $\\mathbf{T}(u)=\\begin{bmatrix}x_T(u) \\\\ 1-\\alpha \\sin(\\pi u)\\end{bmatrix}$，其中若 $\\sigma_T=1$ 则 $x_T(u) = u$，若 $\\sigma_T=-1$ 则为 $1-u$。因此，$x_T'(u) = \\sigma_T$。所以，$\\mathbf{T}'(u)=\\begin{bmatrix}\\sigma_T \\\\ -\\alpha \\pi \\cos(\\pi u)\\end{bmatrix}$。\n- $\\mathbf{R}(v)=\\begin{bmatrix}1+\\beta \\sin(\\pi v) \\\\ y_R(v)\\end{bmatrix}$，其中若 $\\sigma_R=1$ 则 $y_R(v) = v$，若 $\\sigma_R=-1$ 则为 $1-v$。因此，$y_R'(v) = \\sigma_R$。所以，$\\mathbf{R}'(v)=\\begin{bmatrix}\\beta \\pi \\cos(\\pi v) \\\\ \\sigma_R\\end{bmatrix}$。\n\n使用这些特定的曲线和指定的角点，可以推导出雅可比向量 $\\mathbf{P}_u = [x_u, y_u]^T$ 和 $\\mathbf{P}_v = [x_v, y_v]^T$ 的分量。推导过程繁琐但系统，得出的表达式依赖于标志 $\\sigma_T$ 和 $\\sigma_R$。\n\n雅可比行列式为 $J(u,v) = x_u y_v - x_v y_u$。\n反转面积 $A_{-}$ 是参数域中 $J(u,v)  0$ 区域的面积。我们用数值方法近似这个面积。我们在 $[0,1]^2$ 域中创建一个 $N \\times N$ 的均匀网格，其中 $N=800$。网格点为 $(u_i, v_j)$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。面积 $A_{-}$ 估计为计算出的雅可比行列式 $J(u_i,v_j)$ 为负的网格点所占的比例。\n$A_{-} \\approx \\frac{\\text{count}\\{ (i,j) | J(u_i,v_j)  0 \\}}{N^2}$。\n\n我们对四个测试案例中的每一个进行评估：\n1.  **案例 1: $\\alpha=0, \\beta=0, \\sigma_T=1, \\sigma_R=1$** (单位正方形)\n    $x_u=1$, $y_u=0$, $x_v=0$, $y_v=1$。\n    $J(u,v) = (1)(1) - (0)(0) = 1$。\n    $J(u,v)0$ 处处成立。$A_{-}=0$。\n\n2.  **案例 2: $\\alpha=2.0, \\beta=0, \\sigma_T=1, \\sigma_R=1$** (凹顶边)\n    $x_u=1$, $y_u=-2\\pi v \\cos(\\pi u)$, $x_v=0$, $y_v=1-2\\sin(\\pi u)$。\n    $J(u,v) = 1 - 2\\sin(\\pi u)$。\n    $J(u,v)0$ 当 $\\sin(\\pi u)  1/2$ 时成立，这发生在 $u \\in (1/6, 5/6)$。解析面积为 $5/6 - 1/6 = 4/6 \\approx 0.666667$。将计算其数值近似值。\n\n3.  **案例 3: $\\alpha=0, \\beta=0, \\sigma_T=-1, \\sigma_R=1$** (反转顶边)\n    $x_u=1-v$, $y_u=0$, $x_v=1-u$, $y_v=1$。\n    $J(u,v) = (1-v)(1) - (1-u)(0) = 1-v$。\n    对于 $(u,v) \\in [0,1]^2$，$J(u,v) \\ge 0$。因此，$A_{-}=0$。\n\n4.  **案例 4: $\\alpha=0, \\beta=0.8, \\sigma_T=1, \\sigma_R=-1$** (反转右边，凸形)\n    $J(u,v) = (1+0.8\\sin(\\pi v))(1-u) - (0.8u\\pi\\cos(\\pi v))(1-v)$。\n    此案例的面积 $A_{-}$ 通过数值计算得出。\n\n实现将计算 $800 \\times 800$ 网格上每个点的雅可比行列式，并确定每个测试案例中雅可比行列式为负的点的比例。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_jacobian_components(u, v, alpha, beta, sigma_T, sigma_R):\n    \"\"\"\n    Calculates the components of the Jacobian matrix for the Coons patch.\n    u and v can be scalars or numpy arrays of the same shape.\n    \n    Args:\n        u (float or np.ndarray): Parameter u.\n        v (float or np.ndarray): Parameter v.\n        alpha (float): Parameter for top edge concavity.\n        beta (float): Parameter for right edge concavity.\n        sigma_T (int): Orientation flag for the top edge (+1 or -1).\n        sigma_R (int): Orientation flag for the right edge (+1 or -1).\n        \n    Returns:\n        tuple[np.ndarray, ...]: Components xu, yu, xv, yv of the Jacobian matrix.\n    \"\"\"\n    pi = np.pi\n    sin_pi_u = np.sin(pi * u)\n    cos_pi_u = np.cos(pi * u)\n    sin_pi_v = np.sin(pi * v)\n    cos_pi_v = np.cos(pi * v)\n\n    # Component x_u\n    if sigma_T == 1:\n        xu = 1 + beta * sin_pi_v\n    else:  # sigma_T == -1\n        xu = 1 - v + beta * sin_pi_v\n\n    # Component y_u\n    if sigma_R == 1:\n        yu = -alpha * v * pi * cos_pi_u\n    else:  # sigma_R == -1\n        yu = 1 - v - alpha * v * pi * cos_pi_u\n\n    # Component x_v\n    if sigma_T == 1:\n        xv = u * beta * pi * cos_pi_v\n    else:  # sigma_T == -1\n        xv = 1 - u + u * beta * pi * cos_pi_v\n\n    # Component y_v\n    if sigma_R == 1:\n        yv = 1 - alpha * sin_pi_u\n    else:  # sigma_R == -1\n        yv = 1 - u - alpha * sin_pi_u\n\n    return xu, yu, xv, yv\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating the inverted area for four test cases.\n    \"\"\"\n    test_cases = [\n        # (alpha, beta, sigma_T, sigma_R)\n        (0.0, 0.0, 1, 1),\n        (2.0, 0.0, 1, 1),\n        (0.0, 0.0, -1, 1),\n        (0.0, 0.8, 1, -1),\n    ]\n\n    results = []\n    N = 800\n\n    u_vals = np.linspace(0, 1, N)\n    v_vals = np.linspace(0, 1, N)\n    u, v = np.meshgrid(u_vals, v_vals)\n    \n    total_points = N * N\n\n    for case in test_cases:\n        alpha, beta, sigma_T, sigma_R = case\n        \n        xu, yu, xv, yv = calculate_jacobian_components(u, v, alpha, beta, sigma_T, sigma_R)\n        \n        jacobian = xu * yv - xv * yu\n        \n        # Count points where the Jacobian is strictly negative\n        inverted_points_count = np.sum(jacobian  0)\n        \n        # The area is the fraction of inverted points over the total number of points\n        area = inverted_points_count / total_points\n        \n        # Format the result to 6 decimal places\n        results.append(f\"{area:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}