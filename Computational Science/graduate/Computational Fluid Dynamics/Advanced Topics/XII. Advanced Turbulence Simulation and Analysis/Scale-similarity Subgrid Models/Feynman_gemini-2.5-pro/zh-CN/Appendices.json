{
    "hands_on_practices": [
        {
            "introduction": "要理解尺度相似性模型，最直接的方法是从第一性原理出发进行实现。本练习将指导您实现基础的 Bardina 模型，该模型利用一个测试滤波器作用于已解析的速度场来估计亚格子应力，其关系式为 $\\tau_{ij}^{\\text{sim}} = \\widetilde{u_i u_j} - \\widetilde{u_i} \\widetilde{u_j}$。通过在一个合成速度场上编写离散卷积程序 ，您将对如何利用已解析尺度信息来模拟未解析尺度的影响建立起具体的认识。",
            "id": "3360696",
            "problem": "考虑不可压缩流的大涡模拟 (LES)，其中解析速度场是一个在均匀周期性网格上定义的二维场 $(u_1(x,y),u_2(x,y))$。目标是使用 Bardina 模型，通过离散模板系数指定的箱式测试滤波器，计算亚格子应力分量 $\\tau_{12}^{\\text{sim}}$ 的尺度相似性估计。从 LES 中滤波和二阶矩的核心定义出发，基于 Bardina 尺度相似性原理，推导 $\\tau_{12}^{\\text{sim}}$ 的离散表达式，并在一个合成场上实现它。\n\n基本原理：\n- 网格滤波层级的亚格子应力张量由滤波后速度的二阶矩定义。\n- 测试滤波器定义为一个线性平均算子，在均匀网格上实现为与一个归一化模板的离散卷积。\n- Bardina 尺度相似性原理通过将测试滤波器层级的相同二阶结构应用于解析场，来模拟网格滤波层级的小尺度应力。\n\n离散测试滤波器规格：\n- 使用一个 $3 \\times 3$ 模板的箱式测试滤波器，其对于偏移量 $a,b \\in \\{-1,0,1\\}$ 的系数 $w_{a,b}$ 均等于 $1/9$。即，\n$$\nw_{a,b} = \\frac{1}{9} \\quad \\text{for} \\quad a,b \\in \\{-1,0,1\\},\n$$\n一个离散标量场 $\\phi_{i,j}$ 的滤波场 $\\widetilde{\\phi}_{i,j}$ 通过周期性卷积定义，\n$$\n\\widetilde{\\phi}_{i,j} = \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} w_{a,b}\\, \\phi_{i+a \\bmod N_x,\\; j+b \\bmod N_y}.\n$$\n所有索引都采用周期性环绕处理，$(N_x,N_y)$ 是网格分辨率。\n\n离散网格和场：\n- 网格是均匀且周期性的，其中 $x_i = i\\,\\Delta x$，$y_j = j\\,\\Delta y$，并且 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$，$i \\in \\{0,\\dots,N_x-1\\}$，$j \\in \\{0,\\dots,N_y-1\\}$。\n- $x$ 和 $y$ 的三角函数使用以弧度为单位的角度。\n\n实现目标：\n- 从上述定义推导 $\\tau_{12}^{\\text{sim}}$ 的 Bardina 尺度相似性表达式，不假设任何快捷公式。\n- 实现带有给定模板和周期性环绕的离散卷积。\n- 对以下每个测试案例，在每个网格点上计算 $\\tau_{12}^{\\text{sim}}$。\n- 对每个测试案例，输出由下式定义的 $\\tau_{12}^{\\text{sim}}$ 的空间均方根 (RMS) 值\n$$\n\\text{RMS}(\\tau_{12}^{\\text{sim}}) = \\sqrt{ \\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left( \\tau_{12,\\,i,j}^{\\text{sim}} \\right)^2 }.\n$$\n- 不需要物理单位；所有量均为无量纲。\n\n测试套件：\n- 案例 A (一般解析结构)：\n    - $N_x = 16$, $N_y = 16$, $L_x = 2\\pi$, $L_y = 2\\pi$,\n    - $u_1(x,y) = \\sin(x) + 0.3\\,\\cos(2y)$,\n    - $u_2(x,y) = \\cos(y) + 0.3\\,\\sin(2x)\\cos(2y)$.\n- 案例 B (均匀流边界情况)：\n    - $N_x = 8$, $N_y = 8$, $L_x = 1$, $L_y = 1$,\n    - $u_1(x,y) = 1$, $u_2(x,y) = 1$.\n- 案例 C (接近网格分辨率的高频内容)：\n    - $N_x = 32$, $N_y = 32$, $L_x = 2\\pi$, $L_y = 2\\pi$,\n    - $u_1(x,y) = \\sin(4x) + 0.2\\,\\sin(8x)\\cos(8y)$,\n    - $u_2(x,y) = \\cos(4y) + 0.2\\,\\sin(8x)\\sin(8y)$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按案例 A、B、C 的顺序排列结果，例如 $\\left[\\text{rms}_A,\\text{rms}_B,\\text{rms}_C\\right]$。",
            "solution": "该问题是有效的，因为它科学地基于计算流体动力学的原理，特别是大涡模拟 (LES)，并且定义和数据完整一致，是一个适定问题。\n\n目标是基于 Bardina 模型，推导尺度相似性亚格子应力分量 $\\tau_{12}^{\\text{sim}}$ 的离散表达式，并针对给定的速度场实现其计算。\n\n**1. 基本概念：亚格子尺度应力和测试滤波**\n\n在 LES 中，速度场 $u_i$ 被分解为一个解析分量 $\\bar{u}_i$ 和一个亚格子尺度分量 $u_i'$。上划线表示在网格尺度 $\\Delta$ 上的滤波操作。当对不可压缩的纳维-斯托克斯方程进行滤波时，会出现一个未封闭项，称为亚格子尺度 (SGS) 应力张量 $\\tau_{ij}$：\n$$ \\tau_{ij} = \\overline{u_i u_j} - \\bar{u}_i \\bar{u}_j $$\n该张量表示未解析的小尺度对已解析的大尺度的影响，必须对其进行建模。本问题提供了在离散网格上定义的解析速度场，我们简单地将其表示为 $u_i$（在此上下文中等同于 $\\bar{u}_i$）。由于我们只能访问这些解析信息，$\\tau_{ij}$ 无法直接计算。\n\n**2. Bardina 尺度相似性原理**\n\nBardina 模型基于尺度相似性原理为 $\\tau_{ij}$ 提供了一个近似。该原理假设，最小的已解析尺度之间的能量相互作用，在结构上与已解析尺度和未解析尺度之间的相互作用相似。为了探测量最小的已解析尺度，引入了第二个显式的 *测试滤波器*，用波浪号 ($\\widetilde{\\cdot}$) 表示。此测试滤波器的特征宽度 $\\widetilde{\\Delta}$ 大于网格滤波器宽度 $\\Delta$。\n\n该模型是通过应用定义 SGS 应力时所用的相同数学形式构建的，但作用于作用在解析场 $u_i$ 上的测试滤波器层级：\n$$ \\tau_{ij}^{\\text{sim}} = \\widetilde{u_i u_j} - \\widetilde{u_i} \\widetilde{u_j} $$\n这个量完全可以从解析场计算得出，作为 SGS 应力的尺度相似性估计。对于分量 $\\tau_{12}$，模型为：\n$$ \\tau_{12}^{\\text{sim}} = \\widetilde{u_1 u_2} - \\widetilde{u_1} \\widetilde{u_2} $$\n此表达式要求我们必须首先计算速度分量 $u_1$ 和 $u_2$ 的逐点乘积，然后将测试滤波器应用于该乘积场。最后，从中减去经过测试滤波的速度分量的乘积。\n\n**3. 离散化和滤波器应用**\n\n问题在尺寸为 $N_x \\times N_y$ 的均匀、周期性二维网格上定义了场和操作。解析的速度分量是离散数组 $u_{1,i,j}$ 和 $u_{2,i,j}$。在网格点 $(i, j)$ 处，模型的离散形式为：\n$$ (\\tau_{12}^{\\text{sim}})_{i,j} = (\\widetilde{u_1 u_2})_{i,j} - (\\widetilde{u_1})_{i,j} (\\widetilde{u_2})_{i,j} $$\n测试滤波器被指定为与一个 $3 \\times 3$ 模板的离散卷积，其中权重 $w_{a,b} = 1/9$（对于 $a,b \\in \\{-1,0,1\\}$）。对于任意离散场 $\\phi_{i,j}$，滤波操作为：\n$$ \\widetilde{\\phi}_{i,j} = \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} w_{a,b}\\, \\phi_{i+a \\bmod N_x,\\; j+b \\bmod N_y} = \\frac{1}{9} \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} \\phi_{i+a \\bmod N_x,\\; j+b \\bmod N_y} $$\n这是一个在 $3 \\times 3$ 单元邻域上的简单算术平均，在边界处采用周期性环绕处理。\n\n将此滤波器定义应用于模型中 $(\\tau_{12}^{\\text{sim}})_{i,j}$ 的各项：\n- 滤波后的乘积场为：$(\\widetilde{u_1 u_2})_{i,j} = \\frac{1}{9} \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} \\left( u_{1, i+a, j+b} \\cdot u_{2, i+a, j+b} \\right)$\n- 滤波后的分量场为：$(\\widetilde{u_1})_{i,j} = \\frac{1}{9} \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} u_{1, i+a, j+b}$ 和 $(\\widetilde{u_2})_{i,j} = \\frac{1}{9} \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} u_{2, i+a, j+b}$\n\n将这些代入离散模型方程，得到网格上每个点的最终显式表达式：\n$$ (\\tau_{12}^{\\text{sim}})_{i,j} = \\left( \\frac{1}{9} \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} u_{1,i+a,j+b} u_{2,i+a,j+b} \\right) - \\left( \\frac{1}{9} \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} u_{1,i+a,j+b} \\right) \\left( \\frac{1}{9} \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} u_{2,i+a,j+b} \\right) $$\n其中所有索引都根据网格维度取模（第一个索引对 $N_x$ 取模，第二个对 $N_y$ 取模）。\n\n**4. 最终度量：均方根 (RMS)**\n\n在计算完整个二维场 $(\\tau_{12}^{\\text{sim}})_{i,j}$ 后，问题要求其空间均方根 (RMS) 值。这是衡量场量级的一个标准度量，定义为：\n$$ \\text{RMS}(\\tau_{12}^{\\text{sim}}) = \\sqrt{ \\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left( (\\tau_{12}^{\\text{sim}})_{i,j} \\right)^2 } $$\n这个从基本原理到最终 RMS 计算的流程，为解决该问题提供了一个完整的算法。实现将针对每个指定的测试案例遵循这些步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import convolve\n\ndef solve():\n    \"\"\"\n    Computes the RMS of the scale-similarity subgrid stress τ_12 for given test cases.\n    \"\"\"\n    # Define test cases as a list of tuples.\n    # Each tuple contains: (Nx, Ny, Lx, Ly, u1_func, u2_func)\n    test_cases = [\n        # Case A: General resolved structure\n        (16, 16, 2 * np.pi, 2 * np.pi,\n         lambda x, y: np.sin(x) + 0.3 * np.cos(2 * y),\n         lambda x, y: np.cos(y) + 0.3 * np.sin(2 * x) * np.cos(2 * y)),\n        \n        # Case B: Uniform flow boundary case\n        (8, 8, 1.0, 1.0,\n         lambda x, y: np.ones_like(x),  # Uniform flow u1=1\n         lambda x, y: np.ones_like(x)),  # Uniform flow u2=1\n        \n        # Case C: High-frequency content near grid resolution\n        (32, 32, 2 * np.pi, 2 * np.pi,\n         lambda x, y: np.sin(4 * x) + 0.2 * np.sin(8 * x) * np.cos(8 * y),\n         lambda x, y: np.cos(4 * y) + 0.2 * np.sin(8 * x) * np.sin(8 * y))\n    ]\n\n    results = []\n    \n    # Define the discrete 3x3 box test filter kernel.\n    # The weights w_ab are 1/9 for all stencil points.\n    kernel = np.full((3, 3), 1/9.0)\n\n    for case in test_cases:\n        # Unpack case parameters\n        Nx, Ny, Lx, Ly, u1_func, u2_func = case\n\n        # 1. Create the uniform, periodic grid\n        dx = Lx / Nx\n        dy = Ly / Ny\n        x_coords = np.arange(Nx) * dx\n        y_coords = np.arange(Ny) * dy\n        X, Y = np.meshgrid(x_coords, y_coords, indexing='ij')\n\n        # 2. Generate the discrete velocity fields u1 and u2\n        u1 = u1_func(X, Y)\n        u2 = u2_func(X, Y)\n\n        # 3. Apply the test filter\n        # The scale-similarity stress is τ_12^sim = ~(u1*u2) - ~u1 * ~u2\n        # where ~ denotes the test-filtering operation.\n\n        # First, filter the individual velocity components\n        u1_tilde = convolve(u1, kernel, mode='wrap')\n        u2_tilde = convolve(u2, kernel, mode='wrap')\n\n        # Second, form the product field and filter it\n        u1u2 = u1 * u2\n        u1u2_tilde = convolve(u1u2, kernel, mode='wrap')\n\n        # 4. Compute the scale-similarity stress field\n        tau12_sim = u1u2_tilde - u1_tilde * u2_tilde\n\n        # 5. Calculate the root-mean-square (RMS) of the stress field\n        # RMS = sqrt( mean( (τ_12)^2 ) )\n        rms_val = np.sqrt(np.mean(np.square(tau12_sim)))\n        results.append(rms_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个正确的模型实现不仅仅是简单地转录公式，它还需要确保基本的物理原理在数值上得到遵守。本练习聚焦于在模拟中应用离散滤波器时动量守恒这一关键问题 。您将研究不正确的边界处理或核函数归一化如何破坏守恒性，然后实现一种“后验”校正方法来恢复全局动量平衡，这是开发稳健的计算流体力学代码的一项至关重要的技能。",
            "id": "3360731",
            "problem": "考虑一个用于大涡模拟 (LES) 的离散一维、不可压缩、恒定密度流场，其中使用尺度相似性亚格子模型，且滤波被用来定义网格滤波器和测试滤波器。设域长度为 $L=1$，计算网格在位置 $x_n = n/N$（$n=0,1,\\dots,N-1$）处有 $N$ 个均匀分布的节点，间距为 $\\Delta x = 1/N$。设密度为 $\\rho=1$。离散总解析动量为\n$$\nM = \\sum_{n=0}^{N-1} u_n \\,\\Delta x.\n$$\n一个具有紧致模板的线性离散滤波器由系数 $g_m$（$m=-r,\\dots,r$）定义，并生成一个滤波后的场\n$$\n\\tilde{u}_n = \\sum_{m=-r}^{r} g_m\\, \\mathcal{B}(u_{n+m}),\n$$\n其中 $\\mathcal{B}$ 表示边界处理算子。考虑两种边界处理选择：\n- 周期性包裹: $\\mathcal{B}(u_{n+m}) = u_{(n+m) \\bmod N}$。\n- 零填充: 如果 $n+m \\notin \\{0,1,\\dots,N-1\\}$，则 $\\mathcal{B}(u_{n+m}) = 0$，否则 $\\mathcal{B}(u_{n+m}) = u_{n+m}$。\n\n滤波器的非保守实现是指任何其中核不满足 $\\sum_{m=-r}^{r} g_m = 1$ 或边界处理破坏了域平均值不变性（例如，没有近边界重整化的零填充）的实现。这会在封闭或周期性设置中伪地改变全局守恒动量 $M$。\n\n任务：从不可压缩流的动量守恒和滤波的线性性质出发，推导离散滤波器在何种条件下保持全局动量。然后，对于下面的每个测试用例，计算由非保守滤波器引入的全局动量绝对误差，\n$$\nE_{\\mathrm{nc}} = \\left| \\sum_{n=0}^{N-1} \\tilde{u}^{(\\mathrm{nc})}_n \\,\\Delta x - \\sum_{n=0}^{N-1} u_n \\,\\Delta x \\right|,\n$$\n并提出和实现一个通过后验校正强制实现精确全局动量守恒的保守修正。具体来说，在计算非保守滤波场 $\\tilde{u}^{(\\mathrm{nc})}_n$ 后，通过\n$$\nc = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left(u_n - \\tilde{u}^{(\\mathrm{nc})}_n\\right),\n$$\n定义一个均匀校正量 $c$，并设置校正后的滤波场为 $\\tilde{u}^{(\\mathrm{fix})}_n = \\tilde{u}^{(\\mathrm{nc})}_n + c$。然后计算修正后的绝对动量误差，\n$$\nE_{\\mathrm{fix}} = \\left| \\sum_{n=0}^{N-1} \\tilde{u}^{(\\mathrm{fix})}_n \\,\\Delta x - \\sum_{n=0}^{N-1} u_n \\,\\Delta x \\right|.\n$$\n你必须为每个测试生成 $E_{\\mathrm{nc}}$ 和 $E_{\\mathrm{fix}}$。\n\n所有量均为无量纲；不需要物理单位。\n\n测试套件：\n- 测试 $1$ (未归一化核，周期性边界)。参数：$N=16$；定义 $u_n = A + B \\sin(2\\pi k x_n)$，其中 $A=0.3$，$B=1.1$，$k=3$；对 $\\mathcal{B}$ 使用核 $g = [1,2,1]$ (即 $r=1$) 和周期性包裹。\n- 测试 $2$ (归一化核，零填充边界)。参数：$N=32$；定义 $u_n = A + B \\sin(2\\pi k x_n)$，其中 $A=0.5$，$B=0.7$，$k=5$；对 $\\mathcal{B}$ 使用核 $g = [1,4,6,4,1]/16$ (即 $r=2$) 和零填充。\n- 测试 $3$ (常数场，和小于一的核，周期性边界)。参数：$N=15$；定义 $u_n = C$，其中 $C=0.7$；对 $\\mathcal{B}$ 使用核 $g=[2,5,2]/10$ (即 $r=1$) 和周期性包裹。\n\n对于每个测试，计算如上定义的 $E_{\\mathrm{nc}}$ 和 $E_{\\mathrm{fix}}$。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：$[E_{\\mathrm{nc}}^{(1)},E_{\\mathrm{fix}}^{(1)},E_{\\mathrm{nc}}^{(2)},E_{\\mathrm{fix}}^{(2)},E_{\\mathrm{nc}}^{(3)},E_{\\mathrm{fix}}^{(3)}]$。列表中的每个条目都必须是一个实数（浮点数）。",
            "solution": "该问题要求对一维离散滤波器的动量守恒进行分析，并实施一个数值测试来量化和校正非守恒误差。\n\n**第一部分：离散动量守恒条件的推导**\n\n对于一个密度恒定为 $\\rho=1$、域长度为 $L=1$、并离散为 $N$ 个节点的流，其离散总动量 $M$ 由下式给出：\n$$\nM = \\sum_{n=0}^{N-1} u_n \\,\\Delta x,\n$$\n其中 $u_n$ 是节点 $x_n = n/N$ 处的速度，$\\Delta x = 1/N$ 是均匀的网格间距。\n\n一个线性滤波器作用于场 $u_n$ 以产生一个滤波后的场 $\\tilde{u}_n$，其公式为：\n$$\n\\tilde{u}_n = \\sum_{m=-r}^{r} g_m\\, \\mathcal{B}(u_{n+m}),\n$$\n其中 $g_m$ 是滤波器核系数，$\\mathcal{B}$ 是边界处理算子。滤波后场的总动量 $\\tilde{M}$ 是：\n$$\n\\tilde{M} = \\sum_{n=0}^{N-1} \\tilde{u}_n \\,\\Delta x.\n$$\n将滤波器的定义代入 $\\tilde{M}$ 的表达式中，得到：\n$$\n\\tilde{M} = \\sum_{n=0}^{N-1} \\left( \\sum_{m=-r}^{r} g_m\\, \\mathcal{B}(u_{n+m}) \\right) \\Delta x.\n$$\n根据求和的线性性质，我们可以交换求和顺序：\n$$\n\\tilde{M} = \\Delta x \\sum_{m=-r}^{r} g_m \\left( \\sum_{n=0}^{N-1} \\mathcal{B}(u_{n+m}) \\right).\n$$\n为了使滤波器是保守的，我们必须有 $\\tilde{M} = M$。让我们针对两种指定的边界条件分析内层和 $\\sum_{n=0}^{N-1} \\mathcal{B}(u_{n+m})$。\n\n**情况1：周期性包裹**\n对于周期性边界，算子定义为 $\\mathcal{B}(u_{n+m}) = u_{(n+m) \\bmod N}$。内层和变为：\n$$\n\\sum_{n=0}^{N-1} u_{(n+m) \\bmod N}.\n$$\n对于任何固定的整数位移 $m$，索引集合 $\\{(n+m) \\bmod N \\mid n=0, 1, \\dots, N-1\\}$ 是集合 $\\{0, 1, \\dots, N-1\\}$ 的一个排列。因此，对排列后的索引求和等于对原始索引求和：\n$$\n\\sum_{n=0}^{N-1} u_{(n+m) \\bmod N} = \\sum_{j=0}^{N-1} u_j.\n$$\n将此结果代回 $\\tilde{M}$ 的表达式中：\n$$\n\\tilde{M} = \\Delta x \\sum_{m=-r}^{r} g_m \\left( \\sum_{j=0}^{N-1} u_j \\right) = \\left( \\sum_{m=-r}^{r} g_m \\right) \\left( \\sum_{j=0}^{N-1} u_j \\Delta x \\right) = \\left( \\sum_{m=-r}^{r} g_m \\right) M.\n$$\n在这种情况下，动量守恒（$\\tilde{M} = M$）当且仅当滤波器核系数之和为1：\n$$\n\\sum_{m=-r}^{r} g_m = 1.\n$$\n\n**情况2：零填充**\n对于零填充，当 $k \\notin \\{0, 1, \\dots, N-1\\}$ 时，$\\mathcal{B}(u_{k}) = 0$。内层和 $\\sum_{n=0}^{N-1} \\mathcal{B}(u_{n+m})$ 不再等于 $\\sum_j u_j$。例如，如果 $m  0$，和 $\\sum_{n=0}^{N-1} \\mathcal{B}(u_{n+m})$ 将会缺少对应于 $u_{N-1}, u_{N-2}, \\dots, u_{N-m}$ 的项，因为对于最后几个 $n$ 值，它们的索引 $n+m$ 会超过 $N-1$。具体来说，只有当 $n$ 满足 $0 \\le n+m \\le N-1$ (即 $0 \\le n \\le N-1-m$) 时，项才非零。该和变为 $\\sum_{n=0}^{N-1-m} u_{n+m}$。这个和显然不等于总和 $\\sum_j u_j$。因此，即使 $\\sum_m g_m = 1$，总滤波动量 $\\tilde{M}$ 也不会等于 $M$。该滤波器是内地非保守的，因为它导致了边界处动量信息的损失。\n\n**第二部分：后验校正分析**\n\n问题定义了一个非保守滤波场 $\\tilde{u}^{(\\mathrm{nc})}_n$，并提出了一个校正以创建一个新场 $\\tilde{u}^{(\\mathrm{fix})}_n = \\tilde{u}^{(\\mathrm{nc})}_n + c$，其中 $c$ 是一个均匀校正项。目标是事后强制动量守恒。该校正定义为：\n$$\nc = \\frac{1}{N}\\sum_{j=0}^{N-1} \\left(u_j - \\tilde{u}^{(\\mathrm{nc})}_j\\right).\n$$\n校正后场的总动量 $M_{\\mathrm{fix}}$ 是：\n$$\nM_{\\mathrm{fix}} = \\sum_{n=0}^{N-1} \\tilde{u}^{(\\mathrm{fix})}_n \\,\\Delta x = \\sum_{n=0}^{N-1} (\\tilde{u}^{(\\mathrm{nc})}_n + c) \\,\\Delta x.\n$$\n分离和中的项：\n$$\nM_{\\mathrm{fix}} = \\left( \\sum_{n=0}^{N-1} \\tilde{u}^{(\\mathrm{nc})}_n \\Delta x \\right) + \\left( \\sum_{n=0}^{N-1} c \\Delta x \\right).\n$$\n第一项是非保守动量 $M_{\\mathrm{nc}}$。第二项简化为：\n$$\n\\sum_{n=0}^{N-1} c \\Delta x = c \\sum_{n=0}^{N-1} \\Delta x = c \\cdot N \\cdot \\Delta x.\n$$\n因为 $\\Delta x = 1/N$，我们有 $N \\Delta x = 1$，所以该项就变成了 $c$。因此，\n$$\nM_{\\mathrm{fix}} = M_{\\mathrm{nc}} + c.\n$$\n现在，让我们用动量项重写 $c$ 的定义。\n$$\nc = \\frac{1}{N}\\sum_j u_j - \\frac{1}{N}\\sum_j \\tilde{u}^{(\\mathrm{nc})}_j = \\left( \\sum_j u_j \\Delta x \\right) - \\left( \\sum_j \\tilde{u}^{(\\mathrm{nc})}_j \\Delta x \\right) = M - M_{\\mathrm{nc}}.\n$$\n将这个 $c$ 的表达式代回 $M_{\\mathrm{fix}}$ 的方程中：\n$$\nM_{\\mathrm{fix}} = M_{\\mathrm{nc}} + (M - M_{\\mathrm{nc}}) = M.\n$$\n这证明了校正后场的总动量在解析上与原始场的总动量完全相同。因此，修正后的绝对动量误差，\n$$\nE_{\\mathrm{fix}} = \\left| \\sum_{n=0}^{N-1} \\tilde{u}^{(\\mathrm{fix})}_n \\,\\Delta x - \\sum_{n=0}^{N-1} u_n \\,\\Delta x \\right| = |M_{\\mathrm{fix}} - M|,\n$$\n在解析上为零。在数值实现中任何非零值都将完全是由于浮点精度限制造成的。\n\n**第三部分：数值实现**\n\n每个测试用例的计算将通过编程方式执行。将实现一个函数来应用离散滤波器。这是一个离散卷积操作。对于所有测试用例中给出的对称核，可以直接使用标准的卷积函数 `scipy.ndimage.convolve1d`。该函数的 `mode` 参数直接映射到所需的边界条件：`'wrap'` 用于周期性包裹，`'constant'` 搭配 `cval=0.0` 用于零填充。\n\n对于每个测试用例，执行以下步骤：\n1.  构建计算网格 $x_n$ 和初始速度场 $u_n$。\n2.  通过应用指定的核和边界条件，计算非保守滤波场 $\\tilde{u}^{(\\mathrm{nc})}_n$。\n3.  通过对相应场求和并乘以 $\\Delta x = 1/N$，计算原始动量 $M$ 和非保守动量 $M_{\\mathrm{nc}}$。\n4.  计算非保守误差 $E_{\\mathrm{nc}} = |M_{\\mathrm{nc}} - M|$。\n5.  根据其定义计算校正项 $c$，可简化为 $c = (M - M_{\\mathrm{nc}})$。\n6.  通过将 $c$ 加到 $\\tilde{u}^{(\\mathrm{nc})}_n$ 上，获得校正场 $\\tilde{u}^{(\\mathrm{fix})}_n$。\n7.  计算校正后的动量 $M_{\\mathrm{fix}}$ 并用其求得修正后误差 $E_{\\mathrm{fix}} = |M_{\\mathrm{fix}} - M|$，预计该值在机器精度范围内为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import convolve1d\n\ndef solve():\n    \"\"\"\n    Computes momentum errors for several filtering test cases and a conservation-restoring fix.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: Unnormalized kernel, periodic boundary\n        {'N': 16, 'u_func': lambda x: 0.3 + 1.1 * np.sin(2 * np.pi * 3 * x), \n         'kernel': np.array([1, 2, 1]), 'boundary_mode': 'periodic'},\n        \n        # Test 2: Normalized kernel, zero padding boundary\n        {'N': 32, 'u_func': lambda x: 0.5 + 0.7 * np.sin(2 * np.pi * 5 * x),\n         'kernel': np.array([1, 4, 6, 4, 1]) / 16.0, 'boundary_mode': 'zeropadding'},\n        \n        # Test 3: Constant field, sub-unity-sum kernel, periodic boundary\n        {'N': 15, 'u_func': lambda x: 0.7 + 0.0 * x, # u_n = C\n         'kernel': np.array([2, 5, 2]) / 10.0, 'boundary_mode': 'periodic'}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        u_func = case['u_func']\n        kernel = case['kernel']\n        boundary_mode = case['boundary_mode']\n        \n        # 1. Construct the grid and initial velocity field\n        dx = 1.0 / N\n        x = np.arange(N) * dx\n        u = u_func(x)\n        \n        # 2. Apply the nonconservative filter\n        if boundary_mode == 'periodic':\n            # scipy.ndimage.convolve1d 'wrap' mode handles periodic boundaries\n            u_tilde_nc = convolve1d(u, kernel, mode='wrap')\n        elif boundary_mode == 'zeropadding':\n            # 'constant' mode with cval=0.0 handles zero padding\n            u_tilde_nc = convolve1d(u, kernel, mode='constant', cval=0.0)\n        \n        # 3. Calculate original and nonconservative momentum\n        M_orig = np.sum(u) * dx\n        M_nc = np.sum(u_tilde_nc) * dx\n        \n        # 4. Compute the nonconservative error\n        E_nc = np.abs(M_nc - M_orig)\n        \n        # 5. Compute the uniform correction term\n        # c = (1/N) * sum(u - u_tilde_nc) = dx * sum(u - u_tilde_nc)\n        c = dx * np.sum(u - u_tilde_nc) \n        \n        # 6. Apply the correction to get the fixed field\n        u_tilde_fix = u_tilde_nc + c\n        \n        # 7. Calculate the post-fix momentum and error\n        M_fix = np.sum(u_tilde_fix) * dx\n        E_fix = np.abs(M_fix - M_orig)\n        \n        results.extend([E_nc, E_fix])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在静态模型的基础上，动态程序提供了一种强大的方法，能够根据流场本身自适应地确定模型系数。本练习应用了这种先进技术，利用 Germano 恒等式来计算一个尺度相似性模型的动态系数 。通过为一个经典的 Taylor-Green 涡流实现该程序，您将探索模型系数在空间和时间上的变化，从而将在理论与现代大涡模拟模型的实际应用之间架起一座桥梁。",
            "id": "3360733",
            "problem": "考虑不可压缩流的大涡模拟 (LES)，其中滤波后的速度场表示为 $\\bar{u}_i(x,t)$，亚格子尺度 (SGS) 应力张量定义为 $\\tau_{ij} = \\overline{u_i u_j} - \\bar{u}_i \\bar{u}_j$。令 Germano 恒等式以宽度为 $\\hat{\\Delta} = \\alpha \\Delta$（其中 $\\alpha  1$）的测试滤波器（用帽子符号表示）写为 $L_{ij} = \\widehat{\\bar{u}_i \\bar{u}_j} - \\hat{\\bar{u}}_i \\hat{\\bar{u}}_j = T_{ij} - \\widehat{\\tau_{ij}}$。考虑一个带有可调系数 $C$ 的尺度相似模型，其中网格尺度上的模型化 SGS 应力为 $\\tau^{m}_{ij} = C B_{ij}(\\bar{\\mathbf{u}})$，而尺度相似张量 $B_{ij}$ 是通过将宽度为 $\\Delta$ 的辅助高斯滤波器（用波浪号表示）应用于已解析场来构造的：\n$$\nB_{ij}(\\bar{\\mathbf{u}}) = \\widetilde{\\bar{u}_i \\bar{u}_j} - \\tilde{\\bar{u}}_i \\tilde{\\bar{u}}_j.\n$$\n在测试滤波器尺度上，相同的模型形式给出 $T^{m}_{ij} = C B_{ij}(\\hat{\\bar{\\mathbf{u}}})$。动态过程使用恒等式\n$$\nL_{ij} \\approx C \\left( B_{ij}(\\hat{\\bar{\\mathbf{u}}}) - \\widehat{B_{ij}(\\bar{\\mathbf{u}})} \\right) \\equiv C H_{ij},\n$$\n通过最小二乘法确定 $C$，其中 $H_{ij} = B_{ij}(\\hat{\\bar{\\mathbf{u}}}) - \\widehat{B_{ij}(\\bar{\\mathbf{u}})}$。为移除动态不可解析的各向同性部分，在 $d$ 维空间中使用偏张量投影，$A_{ij}^{\\prime} = A_{ij} - \\frac{1}{d} A_{kk} \\delta_{ij}$，其中 $d = 2$。该系数可以局部确定为\n$$\nC(\\mathbf{x},t) = \\frac{\\sum_{i,j} L_{ij}^{\\prime} H_{ij}^{\\prime}}{\\sum_{i,j} H_{ij}^{\\prime} H_{ij}^{\\prime}},\n$$\n以及在 Germano-Lilly 全局最小二乘平均的意义上确定为\n$$\nC_{\\text{Lilly}}(t) = \\frac{\\left\\langle \\sum_{i,j} L_{ij}^{\\prime} H_{ij}^{\\prime} \\right\\rangle}{\\left\\langle \\sum_{i,j} H_{ij}^{\\prime} H_{ij}^{\\prime} \\right\\rangle},\n$$\n其中 $\\langle \\cdot \\rangle$ 表示空间平均，索引求和是在对称分量上定义的，二维中的约定为 $\\sum_{i,j} A_{ij} B_{ij} \\equiv A_{11} B_{11} + 2 A_{12} B_{12} + A_{22} B_{22}$。\n\n采用边长为 $L = 2\\pi$ 的周期性方形域，用 $N \\times N$ 个点进行均匀离散。使用 Taylor-Green 涡流定义已解析的速度场为\n$$\n\\bar{u}(x,y,t) = U_0 \\sin(k x) \\cos(k y) \\mathrm{e}^{-2 \\nu k^2 t}, \\qquad\n\\bar{v}(x,y,t) = - U_0 \\cos(k x) \\sin(k y) \\mathrm{e}^{-2 \\nu k^2 t},\n$$\n参数为 $U_0  0$，$k \\in \\mathbb{N}$，以及运动粘度 $\\nu  0$。使用宽度为 $\\Delta$ 的高斯滤波器算子，其傅里叶传递函数为\n$$\n\\widehat{G}_\\Delta(\\mathbf{k}) = \\exp\\left( - \\tfrac{1}{2} \\sigma^2 |\\mathbf{k}|^2 \\right), \\quad \\text{其中 } \\sigma = \\frac{\\Delta}{\\sqrt{12}},\n$$\n使得该滤波器与宽度为 $\\Delta$ 的顶帽滤波器具有相同的二阶矩。设网格间距为 $\\Delta x = \\Delta y = L/N$，辅助相似性滤波器宽度设为 $\\Delta = 2 \\Delta x$。测试滤波器宽度为 $\\hat{\\Delta} = \\alpha \\Delta$。\n\n任务：编写一个完整的程序，对下面测试套件中的每个参数对 $(\\alpha, t)$，计算：\n- 全局动态系数 $C_{\\text{Lilly}}(t)$，\n- 局部系数的空间平均值 $\\langle C(\\mathbf{x},t) \\rangle$，仅限于分母严格为正的点，\n- 在这些点上局部系数的空间标准差。\n\n所有三个报告的量都必须是无量纲实数。在计算 $C(\\mathbf{x},t)$ 时，如果局部分母 $\\sum_{i,j} H_{ij}^{\\prime} H_{ij}^{\\prime}$ 小于一个小阈值 $\\varepsilon$，则在该点将 $C(\\mathbf{x},t)$ 设置为 $0$，以避免除以零。使用 $\\varepsilon = 10^{-12}$。\n\n使用 $N = 64$，$L = 2\\pi$，$U_0 = 1$，$k = 1$ 和 $\\nu = 10^{-2}$。三角函数中的角度必须以弧度为单位。输出无需报告物理单位；所有输出均为纯数。\n\n测试套件：\n- 案例 1：$(\\alpha, t) = (1.1, 0)$，一个近乎单位的测试滤波器，用于探测 Germano 恒等式变得病态的边界。\n- 案例 2：$(\\alpha, t) = (2.0, 0)$，接近初始化时的典型动态测试。\n- 案例 3：$(\\alpha, t) = (2.0, 1.0)$，在稍后时间的相同滤波器比率，用于评估时间行为。\n- 案例 4：$(\\alpha, t) = (3.0, 0.5)$，一个更强的测试滤波器，用于探测尺度分离效应。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试案例贡献一个包含三个浮点数的子列表，顺序为 $[C_{\\text{Lilly}}, \\langle C \\rangle, \\mathrm{std}(C)]$。例如，最终输出格式必须为\n$$\n\\texttt{[[c\\_1, m\\_1, s\\_1],[c\\_2, m\\_2, s\\_2],[c\\_3, m\\_3, s\\_3],[c\\_4, m\\_4, s\\_4]]}\n$$\n其中每个 $c_i$、$m_i$ 和 $s_i$ 都是一个浮点数。",
            "solution": "用户希望解决一个计算流体动力学问题。\n\n### 方法\n\n该问题要求在大涡模拟 (LES) 背景下，对动态尺度相似模型的系数进行数值评估。计算是在一个二维周期性域上，针对给定的解析速度场——Taylor-Green 涡流——进行的。解决方案涉及以下步骤序列：\n1.  **离散化与傅里叶表示**：连续域和速度场在均匀的 $N \\times N$ 网格上进行离散化。由于域是周期性的，所有定义为卷积的滤波操作都可以使用快速傅里叶变换 (FFT) 在傅里叶空间中最高效地执行。\n2.  **滤波器定义**：使用两种高斯滤波器：宽度为 $\\Delta = 2\\Delta x$ 的辅助滤波器（用波浪号表示）和宽度为 $\\hat{\\Delta} = \\alpha\\Delta$ 的测试滤波器（用帽子符号表示）。它们的传递函数分别为 $\\widetilde{G}(\\mathbf{k}) = \\exp(-\\frac{1}{2}\\sigma^2|\\mathbf{k}|^2)$ 和 $\\widehat{G}(\\mathbf{k}) = \\exp(-\\frac{1}{2}\\hat{\\sigma}^2|\\mathbf{k}|^2)$，构建在离散波数网格上。参数为 $\\sigma = \\Delta/\\sqrt{12}$ 和 $\\hat{\\sigma} = \\hat{\\Delta}/\\sqrt{12}$。还将使用一个复合滤波器，它对应于两个滤波器的应用，其传递函数为 $\\widetilde{G}(\\mathbf{k})\\widehat{G}(\\mathbf{k})$。\n3.  **张量场计算**：问题的核心是计算从已解析速度场 $\\bar{u}_i$ 派生出的几个张量场：\n    -   **Leonard 张量 ($L_{ij}$)**：这个张量源于 Germano 恒等式，定义为 $L_{ij} = \\widehat{\\bar{u}_i \\bar{u}_j} - \\hat{\\bar{u}}_i \\hat{\\bar{u}}_j$。它表示与网格滤波器和测试滤波器之间的尺度相关的应力。其计算涉及将测试滤波器 (`hat`) 应用于速度场 $\\bar{u}_i$ 及其分量的乘积 $\\bar{u}_i\\bar{u}_j$。\n    -   **尺度相似张量 ($B_{ij}$)**：该模型基于张量 $B_{ij}(\\bar{\\mathbf{u}}) = \\widetilde{\\bar{u}_i \\bar{u}_j} - \\tilde{\\bar{u}}_i \\tilde{\\bar{u}}_j$。这涉及将辅助滤波器（`tilde`）应用于速度场及其分量乘积。\n    -   **模型张量 ($H_{ij}$)**：动态过程依赖于张量 $H_{ij} = B_{ij}(\\hat{\\bar{\\mathbf{u}}}) - \\widehat{B_{ij}(\\bar{\\mathbf{u}})}$。\n        - 第一项 $B_{ij}(\\hat{\\bar{\\mathbf{u}}})$ 是应用于测试滤波场的尺度相似模型，即 $B_{ij}(\\hat{\\bar{\\mathbf{u}}}) = \\widetilde{\\hat{\\bar{u}}_i \\hat{\\bar{u}}_j} - \\tilde{\\hat{\\bar{u}}}_i \\tilde{\\hat{\\bar{u}}}_j$。\n        - 第二项 $\\widehat{B_{ij}(\\bar{\\mathbf{u}})}$ 是经过测试滤波的尺度相似张量。\n        - 像 $\\tilde{\\hat{\\bar{u}}}_i$ 这样的项的高效计算是通过将复合滤波器直接应用于 $\\bar{u}_i$ 来完成的。\n\n4.  **偏张量投影**：应力张量的各向同性部分无法通过动态过程确定，通常会被移除。我们使用投影 $A_{ij}' = A_{ij} - \\frac{1}{2}A_{kk}\\delta_{ij}$ 在 $d=2$ 维中计算偏张量部分 $L_{ij}'$ 和 $H_{ij}'$。对于对称的二维张量，这简化为 $A_{11}' = \\frac{1}{2}(A_{11} - A_{22})$，$A_{22}' = -A_{11}'$ 和 $A_{12}' = A_{12}$。\n\n5.  **系数计算**：使用偏张量，我们计算系数表达式的分子 $N_C = \\sum_{i,j} L_{ij}' H_{ij}'$ 和分母 $D_C = \\sum_{i,j} H_{ij}' H_{ij}'$。对于对称二维张量，使用求和约定 $\\sum_{i,j} A_{ij} B_{ij} \\equiv A_{11} B_{11} + 2 A_{12} B_{12} + A_{22} B_{22}$。对于偏张量，这简化为 $N_C = 2(L_{11}' H_{11}' + L_{12}' H_{12}')$ 和 $D_C = 2(H_{11}'^2 + (H_{12}')^2)$。因子 2 在比率中被消去。\n    -   **全局系数 ($C_{\\text{Lilly}}$)**：计算为空间平均值的比率，$C_{\\text{Lilly}} = \\langle N_C \\rangle / \\langle D_C \\rangle$。\n    -   **局部系数 ($C(\\mathbf{x}, t)$)**：逐点计算为 $C = N_C / D_C$。应用一个阈值 $\\varepsilon = 10^{-12}$；如果在某点 $D_C  \\varepsilon$，则将 $C$ 设为 0。\n    -   **统计**：$C$ 的平均值和标准差仅在 $D_C > \\varepsilon$ 的网格点上计算。\n\n对测试套件中的每个参数对 $(\\alpha, t)$ 重复此过程。\n\n### 数学公式\n给定的速度场为：\n$$\n\\bar{u}(x,y,t) = U_0 \\sin(k x) \\cos(k y) e^{-2 \\nu k^2 t}, \\qquad \\bar{v}(x,y,t) = - U_0 \\cos(k x) \\sin(k y) e^{-2 \\nu k^2 t}\n$$\n$N = 64$，$L = 2\\pi$，$U_0 = 1$，$k = 1$，$\\nu = 10^{-2}$。\n网格间距：$\\Delta x = L/N$。\n辅助滤波器宽度：$\\Delta = 2\\Delta x$。\n测试滤波器宽度：$\\hat{\\Delta} = \\alpha \\Delta$。\n\n在傅里叶空间中对场 $f(\\mathbf{x})$ 进行滤波是通过 $\\mathcal{F}^{-1}\\{\\widehat{G}(\\mathbf{k}) \\mathcal{F}\\{f(\\mathbf{x})\\}\\}$ 完成的。\n\n计算过程是先构造每个张量，然后进行投影，计算点积，最后按定义评估系数及其统计数据。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    \n    # Define problem parameters\n    N = 64\n    L = 2 * np.pi\n    U0 = 1.0\n    k_wave = 1.0  # Renamed from k to avoid conflict with wavenumber arrays\n    nu = 1e-2\n    epsilon = 1e-12\n\n    # Define test cases from the problem statement\n    test_cases = [\n        (1.1, 0.0),\n        (2.0, 0.0),\n        (2.0, 1.0),\n        (3.0, 0.5),\n    ]\n\n    # Setup grid and wavenumbers\n    dx = L / N\n    x_coords = np.arange(N) * dx\n    x, y = np.meshgrid(x_coords, x_coords, indexing='ij')\n    \n    k_coords = np.fft.fftfreq(N, d=dx) * 2 * np.pi\n    kx, ky = np.meshgrid(k_coords, k_coords, indexing='ij')\n    k_sq = kx**2 + ky**2\n\n    # Helper for filtering\n    def filter_field(field, kernel):\n        \"\"\"Applies a filter in Fourier space.\"\"\"\n        return np.fft.ifft2(np.fft.fft2(field) * kernel).real\n\n    results = []\n    for alpha, t in test_cases:\n        # Define filter kernels for the current case\n        delta_aux = 2 * dx\n        sigma_aux = delta_aux / np.sqrt(12)\n        G_tilde = np.exp(-0.5 * sigma_aux**2 * k_sq)\n        \n        delta_test = alpha * delta_aux\n        sigma_test = delta_test / np.sqrt(12)\n        G_hat = np.exp(-0.5 * sigma_test**2 * k_sq)\n        \n        G_hat_tilde = G_hat * G_tilde\n    \n        # Define velocity field at time t\n        decay = np.exp(-2 * nu * k_wave**2 * t)\n        u_bar = U0 * np.sin(k_wave * x) * np.cos(k_wave * y) * decay\n        v_bar = -U0 * np.cos(k_wave * x) * np.sin(k_wave * y) * decay\n        \n        # --- Calculate Leonard Tensor L_ij ---\n        u_bar_u_bar = u_bar * u_bar\n        u_bar_v_bar = u_bar * v_bar\n        v_bar_v_bar = v_bar * v_bar\n    \n        u_bar_hat = filter_field(u_bar, G_hat)\n        v_bar_hat = filter_field(v_bar, G_hat)\n    \n        L11 = filter_field(u_bar_u_bar, G_hat) - u_bar_hat * u_bar_hat\n        L12 = filter_field(u_bar_v_bar, G_hat) - u_bar_hat * v_bar_hat\n        L22 = filter_field(v_bar_v_bar, G_hat) - v_bar_hat * v_bar_hat\n        \n        # --- Calculate Scale-Similarity Tensor B_ij(u_bar) ---\n        u_bar_tilde = filter_field(u_bar, G_tilde)\n        v_bar_tilde = filter_field(v_bar, G_tilde)\n    \n        B11_ubar = filter_field(u_bar_u_bar, G_tilde) - u_bar_tilde * u_bar_tilde\n        B12_ubar = filter_field(u_bar_v_bar, G_tilde) - u_bar_tilde * v_bar_tilde\n        B22_ubar = filter_field(v_bar_v_bar, G_tilde) - v_bar_tilde * v_bar_tilde\n        \n        # --- Calculate Model Tensor H_ij ---\n        # Term 1: B_ij(u_bar_hat)\n        u_bar_hat_u_bar_hat = u_bar_hat * u_bar_hat\n        u_bar_hat_v_bar_hat = u_bar_hat * v_bar_hat\n        v_bar_hat_v_bar_hat = v_bar_hat * v_bar_hat\n        \n        u_bar_hat_tilde = filter_field(u_bar, G_hat_tilde)\n        v_bar_hat_tilde = filter_field(v_bar, G_hat_tilde)\n        \n        B11_of_ubar_hat = filter_field(u_bar_hat_u_bar_hat, G_tilde) - u_bar_hat_tilde * u_bar_hat_tilde\n        B12_of_ubar_hat = filter_field(u_bar_hat_v_bar_hat, G_tilde) - u_bar_hat_tilde * v_bar_hat_tilde\n        B22_of_ubar_hat = filter_field(v_bar_hat_v_bar_hat, G_tilde) - v_bar_hat_tilde * v_bar_hat_tilde\n        \n        # Term 2: hat(B_ij(u_bar))\n        B11_ubar_filtered = filter_field(B11_ubar, G_hat)\n        B12_ubar_filtered = filter_field(B12_ubar, G_hat)\n        B22_ubar_filtered = filter_field(B22_ubar, G_hat)\n\n        # Combine for H_ij\n        H11 = B11_of_ubar_hat - B11_ubar_filtered\n        H12 = B12_of_ubar_hat - B12_ubar_filtered\n        H22 = B22_of_ubar_hat - B22_ubar_filtered\n        \n        # --- Deviatoric Projections ---\n        L11_p = 0.5 * (L11 - L22)\n        H11_p = 0.5 * (H11 - H22)\n        \n        # --- Calculate Dot Products for Coefficients ---\n        # The sum sum_ij A'_ij B'_ij for traceless symmetric 2D tensors is 2*(A'_11*B'_11 + A_12*B_12).\n        # The factor of 2 cancels in the ratio for C.\n        numerator_term = L11_p * H11_p + L12 * H12\n        denominator_term = H11_p**2 + H12**2\n        \n        # --- Calculate Coefficients ---\n        # Global Lilly coefficient\n        mean_denom = np.mean(denominator_term)\n        c_lilly = np.mean(numerator_term) / mean_denom if mean_denom != 0 else 0.0\n        \n        # Local coefficient\n        c_local = np.zeros_like(numerator_term)\n        mask = denominator_term > epsilon\n        c_local[mask] = numerator_term[mask] / denominator_term[mask]\n        \n        # Statistics on valid local coefficients\n        c_local_valid = c_local[mask]\n        if c_local_valid.size > 0:\n            c_mean = np.mean(c_local_valid)\n            c_std = np.std(c_local_valid)\n        else:\n            c_mean = 0.0\n            c_std = 0.0\n            \n        results.append([c_lilly, c_mean, c_std])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}