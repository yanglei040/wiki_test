{
    "hands_on_practices": [
        {
            "introduction": "掌握尺度相似性模型的第一步是理解其最核心的公式并能够将其转化为可执行的代码。本练习将指导您实现基础的Bardina模型 ()，将重点放在将公式 $\\tau_{ij}^{\\text{sim}} = \\widetilde{u_i u_j} - \\widetilde{u_i} \\widetilde{u_j}$ 应用于一个合成的二维速度场。通过这个实践，您将直接获得离散卷积和周期性边界条件处理的经验，这是在大涡模拟中应用任何滤波模型的基础技能。",
            "id": "3360696",
            "problem": "考虑不可压缩流的大涡模拟 (LES)，其中解析速度场是在均匀周期性网格上定义的二维场 $(u_1(x,y),u_2(x,y))$。目标是使用 Bardina 模型和一个由离散模板系数指定的箱式检验滤波器，计算亚格子应力分量 $\\tau_{12}^{\\text{sim}}$ 的尺度相似性估计。从 LES 中滤波和二阶矩的核心定义出发，基于 Bardina 尺度相似性原理推导 $\\tau_{12}^{\\text{sim}}$ 的离散表达式，并在一个合成场上实现它。\n\n基本基础：\n- 网格滤波尺度的亚格子应力张量由滤波后速度的二阶矩定义。\n- 检验滤波器被定义为一个线性平均算子，在均匀网格上通过与归一化模板进行离散卷积来实现。\n- Bardina 尺度相似性原理通过将检验滤波器尺度上的相同二阶结构应用于解析场，来模拟网格滤波尺度上的小尺度应力。\n\n离散检验滤波器规格：\n- 使用一个 $3 \\times 3$ 模板的箱式检验滤波器，其对于偏移量 $a,b \\in \\{-1,0,1\\}$ 的系数 $w_{a,b}$ 均等于 $1/9$。即，\n$$\nw_{a,b} = \\frac{1}{9} \\quad \\text{for} \\quad a,b \\in \\{-1,0,1\\},\n$$\n一个离散标量场 $\\phi_{i,j}$ 的滤波场 $\\widetilde{\\phi}_{i,j}$ 通过周期性卷积定义为，\n$$\n\\widetilde{\\phi}_{i,j} = \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} w_{a,b}\\, \\phi_{i+a \\bmod N_x,\\; j+b \\bmod N_y}.\n$$\n所有索引都采用周期性环绕处理，$(N_x,N_y)$ 是网格分辨率。\n\n离散网格和场：\n- 网格是均匀且周期性的，其中 $x_i = i\\,\\Delta x$, $y_j = j\\,\\Delta y$，并且 $\\Delta x = L_x/N_x$，$ \\Delta y = L_y/N_y$，$i \\in \\{0,\\dots,N_x-1\\}$, $j \\in \\{0,\\dots,N_y-1\\}$。\n- $x$ 和 $y$ 的三角函数使用以弧度为单位的角度。\n\n实现目标：\n- 从上述定义推导 $\\tau_{12}^{\\text{sim}}$ 的 Bardina 尺度相似性表达式，不假设任何快捷公式。\n- 使用给定的模板和周期性环绕实现离散卷积。\n- 对于下面的每个测试用例，在每个网格点上计算 $\\tau_{12}^{\\text{sim}}$。\n- 对于每个测试用例，输出由下式定义的 $\\tau_{12}^{\\text{sim}}$ 的空间均方根 (RMS) 值\n$$\n\\text{RMS}(\\tau_{12}^{\\text{sim}}) = \\sqrt{ \\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left( \\tau_{12,\\,i,j}^{\\text{sim}} \\right)^2 }.\n$$\n- 不需要物理单位；所有量均为无量纲。\n\n测试套件：\n- 用例 A (一般解析结构):\n    - $N_x = 16$, $N_y = 16$, $L_x = 2\\pi$, $L_y = 2\\pi$,\n    - $u_1(x,y) = \\sin(x) + 0.3\\,\\cos(2y)$,\n    - $u_2(x,y) = \\cos(y) + 0.3\\,\\sin(2x)\\cos(2y)$.\n- 用例 B (均匀流边界情况):\n    - $N_x = 8$, $N_y = 8$, $L_x = 1$, $L_y = 1$,\n    - $u_1(x,y) = 1$, $u_2(x,y) = 1$.\n- 用例 C (接近网格分辨率的高频分量):\n    - $N_x = 32$, $N_y = 32$, $L_x = 2\\pi$, $L_y = 2\\pi$,\n    - $u_1(x,y) = \\sin(4x) + 0.2\\,\\sin(8x)\\cos(8y)$,\n    - $u_2(x,y) = \\cos(4y) + 0.2\\,\\sin(8x)\\sin(8y)$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按用例 A、B、C 顺序排列的结果，格式为方括号内的逗号分隔列表，例如 $\\left[\\text{rms}_A,\\text{rms}_B,\\text{rms}_C\\right]$。",
            "solution": "该问题是有效的，因为它在科学上基于计算流体动力学原理，特别是大涡模拟（LES），并且定义和数据完整、一致，问题提法是适定的。\n\n目标是基于 Bardina 模型推导尺度相似性亚格子应力分量 $\\tau_{12}^{\\text{sim}}$ 的离散表达式，并针对给定的速度场实现其计算。\n\n**1. 基本概念：亚格子尺度应力和检验滤波**\n\n在 LES 中，速度场 $u_i$ 被分解为解析分量 $\\bar{u}_i$ 和亚格子尺度分量 $u_i'$。上划线表示在网格尺度 $\\Delta$ 上的滤波操作。当对不可压缩的纳维-斯托克斯方程进行滤波时，会出现一个非封闭项，称为亚格子尺度 (SGS) 应力张量 $\\tau_{ij}$：\n$$ \\tau_{ij} = \\overline{u_i u_j} - \\bar{u}_i \\bar{u}_j $$\n该张量表示未解析的小尺度对已解析的大尺度的影响，必须对其进行建模。本问题提供了在离散网格上定义的解析速度场，我们简单地将其表示为 $u_i$（在此上下文中等同于 $\\bar{u}_i$）。由于我们只能访问这些已解析的信息，$\\tau_{ij}$ 无法直接计算。\n\n**2. Bardina 尺度相似性原理**\n\nBardina 模型基于尺度相似性原理为 $\\tau_{ij}$ 提供了一个近似。该原理假设，最小解析尺度之间的能量相互作用在结构上与解析尺度和未解析尺度之间的相互作用相似。为了探测最小的解析尺度，引入了第二个显式的*检验滤波器*，用波浪号（$\\widetilde{\\cdot}$）表示。该检验滤波器的特征宽度 $\\widetilde{\\Delta}$ 大于网格滤波器的宽度 $\\Delta$。\n\n该模型通过将定义 SGS 应力的相同数学形式应用于作用在解析场 $u_i$ 上的检验滤波器层面来构建：\n$$ \\tau_{ij}^{\\text{sim}} = \\widetilde{u_i u_j} - \\widetilde{u_i} \\widetilde{u_j} $$\n这个量完全可以从解析场计算得出，作为 SGS 应力的尺度相似性估计。对于分量 $\\tau_{12}$，模型为：\n$$ \\tau_{12}^{\\text{sim}} = \\widetilde{u_1 u_2} - \\widetilde{u_1} \\widetilde{u_2} $$\n该表达式规定，我们必须首先计算速度分量 $u_1$ 和 $u_2$ 的逐点乘积，然后将检验滤波器应用于该乘积场。在此基础上，我们减去经过检验滤波的速度分量的乘积。\n\n**3. 离散化和滤波器应用**\n\n问题在一个大小为 $N_x \\times N_y$ 的均匀、周期性二维网格上定义了场和操作。解析的速度分量是离散数组 $u_{1,i,j}$ 和 $u_{2,i,j}$。模型在网格点 $(i, j)$ 处的离散形式为：\n$$ (\\tau_{12}^{\\text{sim}})_{i,j} = (\\widetilde{u_1 u_2})_{i,j} - (\\widetilde{u_1})_{i,j} (\\widetilde{u_2})_{i,j} $$\n检验滤波器被指定为与一个 $3 \\times 3$ 模板的离散卷积，其中对于 $a,b \\in \\{-1,0,1\\}$，权重 $w_{a,b} = 1/9$。对于任意离散场 $\\phi_{i,j}$，滤波操作为：\n$$ \\widetilde{\\phi}_{i,j} = \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} w_{a,b}\\, \\phi_{i+a \\bmod N_x,\\; j+b \\bmod N_y} = \\frac{1}{9} \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} \\phi_{i+a \\bmod N_x,\\; j+b \\bmod N_y} $$\n这是一个在 $3 \\times 3$ 单元邻域上的简单算术平均，边界处采用周期性环绕处理。\n\n将此滤波器定义应用于模型中 $(\\tau_{12}^{\\text{sim}})_{i,j}$ 的各项：\n- 滤波后的乘积场为：$(\\widetilde{u_1 u_2})_{i,j} = \\frac{1}{9} \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} \\left( u_{1, i+a, j+b} \\cdot u_{2, i+a, j+b} \\right)$\n- 滤波后的分量场为：$(\\widetilde{u_1})_{i,j} = \\frac{1}{9} \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} u_{1, i+a, j+b}$ 和 $(\\widetilde{u_2})_{i,j} = \\frac{1}{9} \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} u_{2, i+a, j+b}$\n\n将这些代入离散模型方程，得到网格上每个点的最终显式表达式：\n$$ (\\tau_{12}^{\\text{sim}})_{i,j} = \\left( \\frac{1}{9} \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} u_{1,i+a,j+b} u_{2,i+a,j+b} \\right) - \\left( \\frac{1}{9} \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} u_{1,i+a,j+b} \\right) \\left( \\frac{1}{9} \\sum_{a=-1}^{1}\\sum_{b=-1}^{1} u_{2,i+a,j+b} \\right) $$\n其中所有索引都根据网格维度取模（第一个索引对 $N_x$ 取模，第二个索引对 $N_y$ 取模）。\n\n**4. 最终度量：均方根 (RMS)**\n\n在计算出整个二维场 $(\\tau_{12}^{\\text{sim}})_{i,j}$ 后，问题要求其空间均方根 (RMS) 值。这是衡量场量级的一个标准度量，定义为：\n$$ \\text{RMS}(\\tau_{12}^{\\text{sim}}) = \\sqrt{ \\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left( (\\tau_{12}^{\\text{sim}})_{i,j} \\right)^2 } $$\n这个过程，从基本原理到最终的 RMS 计算，为解决该问题提供了一个完整的算法。实现将针对每个指定的测试用例遵循这些步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import convolve\n\ndef solve():\n    \"\"\"\n    Computes the RMS of the scale-similarity subgrid stress τ_12 for given test cases.\n    \"\"\"\n    # Define test cases as a list of tuples.\n    # Each tuple contains: (Nx, Ny, Lx, Ly, u1_func, u2_func)\n    test_cases = [\n        # Case A: General resolved structure\n        (16, 16, 2 * np.pi, 2 * np.pi,\n         lambda x, y: np.sin(x) + 0.3 * np.cos(2 * y),\n         lambda x, y: np.cos(y) + 0.3 * np.sin(2 * x) * np.cos(2 * y)),\n        \n        # Case B: Uniform flow boundary case\n        (8, 8, 1.0, 1.0,\n         lambda x, y: np.ones_like(x),  # Uniform flow u1=1\n         lambda x, y: np.ones_like(x)),  # Uniform flow u2=1\n        \n        # Case C: High-frequency content near grid resolution\n        (32, 32, 2 * np.pi, 2 * np.pi,\n         lambda x, y: np.sin(4 * x) + 0.2 * np.sin(8 * x) * np.cos(8 * y),\n         lambda x, y: np.cos(4 * y) + 0.2 * np.sin(8 * x) * np.sin(8 * y))\n    ]\n\n    results = []\n    \n    # Define the discrete 3x3 box test filter kernel.\n    # The weights w_ab are 1/9 for all stencil points.\n    kernel = np.full((3, 3), 1/9.0)\n\n    for case in test_cases:\n        # Unpack case parameters\n        Nx, Ny, Lx, Ly, u1_func, u2_func = case\n\n        # 1. Create the uniform, periodic grid\n        dx = Lx / Nx\n        dy = Ly / Ny\n        x_coords = np.arange(Nx) * dx\n        y_coords = np.arange(Ny) * dy\n        X, Y = np.meshgrid(x_coords, y_coords, indexing='ij')\n\n        # 2. Generate the discrete velocity fields u1 and u2\n        u1 = u1_func(X, Y)\n        u2 = u2_func(X, Y)\n\n        # 3. Apply the test filter\n        # The scale-similarity stress is τ_12^sim = ~(u1*u2) - ~u1 * ~u2\n        # where ~ denotes the test-filtering operation.\n\n        # First, filter the individual velocity components\n        u1_tilde = convolve(u1, kernel, mode='wrap')\n        u2_tilde = convolve(u2, kernel, mode='wrap')\n\n        # Second, form the product field and filter it\n        u1u2 = u1 * u2\n        u1u2_tilde = convolve(u1u2, kernel, mode='wrap')\n\n        # 4. Compute the scale-similarity stress field\n        tau12_sim = u1u2_tilde - u1_tilde * u2_tilde\n\n        # 5. Calculate the root-mean-square (RMS) of the stress field\n        # RMS = sqrt( mean( (τ_12)^2 ) )\n        rms_val = np.sqrt(np.mean(np.square(tau12_sim)))\n        results.append(rms_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在计算流体动力学中，数值方案必须严格遵守物理守恒定律，例如动量守恒。然而，在大涡模拟中引入的滤波操作，如果处理不当（例如，在非周期性边界上或使用未归一化的核），可能会无意中破坏这种守恒性。本练习 () 旨在揭示这一常见的实现陷阱，并让您亲手量化由于不保守的滤波方案导致的动量误差，并实现一种标准的后处理校正方法来精确恢复全局动量守恒。",
            "id": "3360731",
            "problem": "考虑一个用于大涡模拟 (LES) 的离散一维、不可压缩、恒定密度流场，其中采用尺度相似亚格子模型，并使用滤波来定义网格滤波器和测试滤波器。设域长度为 $L=1$，计算网格在位置 $x_n = n/N$（$n=0,1,\\dots,N-1$）处有 $N$ 个均匀间隔的节点，间距为 $\\Delta x = 1/N$。设密度为 $\\rho=1$。离散总解析动量为\n$$\nM = \\sum_{n=0}^{N-1} u_n \\,\\Delta x.\n$$\n一个具有紧致模板的线性离散滤波器由系数 $g_m$（$m=-r,\\dots,r$）定义，并产生一个滤波后的场\n$$\n\\tilde{u}_n = \\sum_{m=-r}^{r} g_m\\, \\mathcal{B}(u_{n+m}),\n$$\n其中 $\\mathcal{B}$ 表示边界处理算子。考虑两种边界处理选择：\n- 周期性环绕：$\\mathcal{B}(u_{n+m}) = u_{(n+m) \\bmod N}$。\n- 零填充：若 $n+m \\notin \\{0,1,\\dots,N-1\\}$，则 $\\mathcal{B}(u_{n+m}) = 0$，否则 $\\mathcal{B}(u_{n+m}) = u_{n+m}$。\n\n滤波器的非守恒实现是指任何满足以下任一条件的实现：其核不满足 $\\sum_{m=-r}^{r} g_m = 1$，或者其边界处理破坏了域平均值的不变性（例如，不进行近边界重整化的零填充）。在封闭或周期性环境中，这可能会虚假地改变全局守恒动量 $M$。\n\n任务：从不可压缩流的动量守恒和滤波的线性性出发，推导离散滤波器在何种条件下保持全局动量。然后，对于下方的每个测试用例，计算由非守恒滤波器引入的绝对全局动量误差，\n$$\nE_{\\mathrm{nc}} = \\left| \\sum_{n=0}^{N-1} \\tilde{u}^{(\\mathrm{nc})}_n \\,\\Delta x - \\sum_{n=0}^{N-1} u_n \\,\\Delta x \\right|,\n$$\n并提出并实现一种守恒修正方法，该方法通过后验校正来强制实现精确的全局动量守恒。具体来说，在计算非守恒滤波场 $\\tilde{u}^{(\\mathrm{nc})}_n$ 后，通过以下方式定义一个均匀校正值 $c$\n$$\nc = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left(u_n - \\tilde{u}^{(\\mathrm{nc})}_n\\right),\n$$\n并设置校正后的滤波场 $\\tilde{u}^{(\\mathrm{fix})}_n = \\tilde{u}^{(\\mathrm{nc})}_n + c$。然后计算校正后的绝对动量误差，\n$$\nE_{\\mathrm{fix}} = \\left| \\sum_{n=0}^{N-1} \\tilde{u}^{(\\mathrm{fix})}_n \\,\\Delta x - \\sum_{n=0}^{N-1} u_n \\,\\Delta x \\right|.\n$$\n您必须为每个测试生成 $E_{\\mathrm{nc}}$ 和 $E_{\\mathrm{fix}}$。\n\n所有量均为无量纲；不需要物理单位。\n\n测试套件：\n- 测试 $1$（未归一化核，周期性边界）。参数：$N=16$；定义 $u_n = A + B \\sin(2\\pi k x_n)$，其中 $A=0.3$, $B=1.1$, $k=3$；使用核 $g = [1,2,1]$（因此 $r=1$），并为 $\\mathcal{B}$ 使用周期性环绕。\n- 测试 $2$（归一化核，零填充边界）。参数：$N=32$；定义 $u_n = A + B \\sin(2\\pi k x_n)$，其中 $A=0.5$, $B=0.7$, $k=5$；使用核 $g = [1,4,6,4,1]/16$（因此 $r=2$），并为 $\\mathcal{B}$ 使用零填充。\n- 测试 $3$（常数场，和小于一的核，周期性边界）。参数：$N=15$；定义 $u_n = C$，其中 $C=0.7$；使用核 $g=[2,5,2]/10$（因此 $r=1$），并为 $\\mathcal{B}$ 使用周期性环绕。\n\n对于每个测试，计算如上定义的 $E_{\\mathrm{nc}}$ 和 $E_{\\mathrm{fix}}$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：$[E_{\\mathrm{nc}}^{(1)},E_{\\mathrm{fix}}^{(1)},E_{\\mathrm{nc}}^{(2)},E_{\\mathrm{fix}}^{(2)},E_{\\mathrm{nc}}^{(3)},E_{\\mathrm{fix}}^{(3)}]$。列表中的每个条目都必须是实数（浮点数）。",
            "solution": "该问题要求分析一维离散滤波器的动量守恒性，并实现一个数值测试来量化和校正非守恒误差。\n\n**第一部分：离散动量守恒条件的推导**\n\n对于一个密度 $\\rho=1$、在长度为 $L=1$ 的域中被离散化为 $N$ 个节点的恒定密度流，其总离散动量 $M$ 由下式给出：\n$$\nM = \\sum_{n=0}^{N-1} u_n \\,\\Delta x,\n$$\n其中 $u_n$ 是节点 $x_n = n/N$ 处的速度，$\\Delta x = 1/N$ 是均匀的网格间距。\n\n一个线性滤波器作用于场 $u_n$ 以产生滤波后的场 $\\tilde{u}_n$，其公式如下：\n$$\n\\tilde{u}_n = \\sum_{m=-r}^{r} g_m\\, \\mathcal{B}(u_{n+m}),\n$$\n其中 $g_m$ 是滤波器核系数，$\\mathcal{B}$ 是边界处理算子。滤波后场的总动量 $\\tilde{M}$ 为：\n$$\n\\tilde{M} = \\sum_{n=0}^{N-1} \\tilde{u}_n \\,\\Delta x.\n$$\n将滤波器定义代入 $\\tilde{M}$ 的表达式中，得到：\n$$\n\\tilde{M} = \\sum_{n=0}^{N-1} \\left( \\sum_{m=-r}^{r} g_m\\, \\mathcal{B}(u_{n+m}) \\right) \\Delta x.\n$$\n根据求和的线性性质，我们可以交换求和的顺序：\n$$\n\\tilde{M} = \\Delta x \\sum_{m=-r}^{r} g_m \\left( \\sum_{n=0}^{N-1} \\mathcal{B}(u_{n+m}) \\right).\n$$\n为了使滤波器是守恒的，我们必须有 $\\tilde{M} = M$。让我们针对两种指定的边界条件分析内部的和 $\\sum_{n=0}^{N-1} \\mathcal{B}(u_{n+m})$。\n\n**情况1：周期性环绕**\n对于周期性边界，算子定义为 $\\mathcal{B}(u_{n+m}) = u_{(n+m) \\bmod N}$。内部的和变为：\n$$\n\\sum_{n=0}^{N-1} u_{(n+m) \\bmod N}.\n$$\n对于任何固定的整数位移 $m$，索引集合 $\\{(n+m) \\bmod N \\mid n=0, 1, \\dots, N-1\\}$ 是集合 $\\{0, 1, \\dots, N-1\\}$ 的一个排列。因此，对排列后的索引求和等于对原始索引求和：\n$$\n\\sum_{n=0}^{N-1} u_{(n+m) \\bmod N} = \\sum_{j=0}^{N-1} u_j.\n$$\n将此结果代回 $\\tilde{M}$ 的表达式中：\n$$\n\\tilde{M} = \\Delta x \\sum_{m=-r}^{r} g_m \\left( \\sum_{j=0}^{N-1} u_j \\right) = \\left( \\sum_{m=-r}^{r} g_m \\right) \\left( \\sum_{j=0}^{N-1} u_j \\Delta x \\right) = \\left( \\sum_{m=-r}^{r} g_m \\right) M.\n$$\n在这种情况下，动量守恒（$\\tilde{M} = M$）的充分必要条件是滤波器核系数之和为1：\n$$\n\\sum_{m=-r}^{r} g_m = 1.\n$$\n\n**情况2：零填充**\n对于零填充，当 $k \\notin \\{0, 1, \\dots, N-1\\}$ 时，$\\mathcal{B}(u_{k}) = 0$。内部的和 $\\sum_{n=0}^{N-1} \\mathcal{B}(u_{n+m})$不再等于 $\\sum_j u_j$。例如，如果 $m > 0$，和 $\\sum_{n=0}^{N-1} \\mathcal{B}(u_{n+m})$ 将会缺少对应于 $u_{N-1}, u_{N-2}, \\dots, u_{N-m}$ 的项，因为对于最后几个 $n$ 值，它们的索引 $n+m$ 会超过 $N-1$。具体来说，仅当 $n$ 满足 $0 \\le n+m \\le N-1$ 时，即 $0 \\le n \\le N-1-m$ 时，项才为非零。和变为 $\\sum_{n=0}^{N-1-m} u_{n+m}$。这个和显然不等于总和 $\\sum_j u_j$。因此，即使 $\\sum_m g_m = 1$，总滤波动量 $\\tilde{M}$ 也不会等于 $M$。该滤波器本质上是非守恒的，因为它会导致边界处动量信息的损失。\n\n**第二部分：后验校正的分析**\n\n问题定义了一个非守恒滤波场 $\\tilde{u}^{(\\mathrm{nc})}_n$，并提出一种校正方法来创建一个新场 $\\tilde{u}^{(\\mathrm{fix})}_n = \\tilde{u}^{(\\mathrm{nc})}_n + c$，其中 $c$ 是一个均匀校正项。目标是事后强制实现动量守恒。校正定义为：\n$$\nc = \\frac{1}{N}\\sum_{j=0}^{N-1} \\left(u_j - \\tilde{u}^{(\\mathrm{nc})}_j\\right).\n$$\n校正后场的总动量 $M_{\\mathrm{fix}}$ 为：\n$$\nM_{\\mathrm{fix}} = \\sum_{n=0}^{N-1} \\tilde{u}^{(\\mathrm{fix})}_n \\,\\Delta x = \\sum_{n=0}^{N-1} (\\tilde{u}^{(\\mathrm{nc})}_n + c) \\,\\Delta x.\n$$\n分离和中的项：\n$$\nM_{\\mathrm{fix}} = \\left( \\sum_{n=0}^{N-1} \\tilde{u}^{(\\mathrm{nc})}_n \\Delta x \\right) + \\left( \\sum_{n=0}^{N-1} c \\Delta x \\right).\n$$\n第一项是非守恒动量 $M_{\\mathrm{nc}}$。第二项简化为：\n$$\n\\sum_{n=0}^{N-1} c \\Delta x = c \\sum_{n=0}^{N-1} \\Delta x = c \\cdot N \\cdot \\Delta x.\n$$\n由于 $\\Delta x = 1/N$，我们有 $N \\Delta x = 1$，所以该项就变成了 $c$。因此，\n$$\nM_{\\mathrm{fix}} = M_{\\mathrm{nc}} + c.\n$$\n现在，让我们使用动量项重写 $c$ 的定义。\n$$\nc = \\frac{1}{N}\\sum_j u_j - \\frac{1}{N}\\sum_j \\tilde{u}^{(\\mathrm{nc})}_j = \\left( \\sum_j u_j \\Delta x \\right) - \\left( \\sum_j \\tilde{u}^{(\\mathrm{nc})}_j \\Delta x \\right) = M - M_{\\mathrm{nc}}.\n$$\n将这个 $c$ 的表达式代回 $M_{\\mathrm{fix}}$ 的方程中：\n$$\nM_{\\mathrm{fix}} = M_{\\mathrm{nc}} + (M - M_{\\mathrm{nc}}) = M.\n$$\n这证明了校正后场的总动量在解析上与原始场的总动量完全相同。因此，校正后的绝对动量误差，\n$$\nE_{\\mathrm{fix}} = \\left| \\sum_{n=0}^{N-1} \\tilde{u}^{(\\mathrm{fix})}_n \\,\\Delta x - \\sum_{n=0}^{N-1} u_n \\,\\Delta x \\right| = |M_{\\mathrm{fix}} - M|,\n$$\n在解析上为零。在数值实现中任何非零值都将完全是由于浮点精度限制造成的。\n\n**第三部分：数值实现**\n\n每个测试用例的计算都将以编程方式执行。将实现一个函数来应用离散滤波器。这是一个离散卷积操作。对于所有测试用例中给出的对称核，可以直接使用标准卷积函数 `scipy.ndimage.convolve1d`。此函数的 `mode` 参数直接对应所需的边界条件：`'wrap'` 用于周期性环绕，`'constant'` 加上 `cval=0.0` 用于零填充。\n\n对于每个测试用例，执行以下步骤：\n1.  构建计算网格 $x_n$ 和初始速度场 $u_n$。\n2.  通过应用指定的核和边界条件，计算非守恒滤波场 $\\tilde{u}^{(\\mathrm{nc})}_n$。\n3.  通过对相应场求和并乘以 $\\Delta x = 1/N$ 来计算原始动量 $M$ 和非守恒动量 $M_{\\mathrm{nc}}$。\n4.  计算非守恒误差 $E_{\\mathrm{nc}} = |M_{\\mathrm{nc}} - M|$。\n5.  校正项 $c$ 根据其定义计算，该定义可简化为 $c = M - M_{\\mathrm{nc}}$。\n6.  将 $c$ 加到 $\\tilde{u}^{(\\mathrm{nc})}_n$ 上，得到校正后的场 $\\tilde{u}^{(\\mathrm{fix})}_n$。\n7.  计算校正后的动量 $M_{\\mathrm{fix}}$，并用它来求得校正后误差 $E_{\\mathrm{fix}} = |M_{\\mathrm{fix}} - M|$。该误差预期在机器精度范围内为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import convolve1d\n\ndef solve():\n    \"\"\"\n    Computes momentum errors for several filtering test cases and a conservation-restoring fix.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: Unnormalized kernel, periodic boundary\n        {'N': 16, 'u_func': lambda x: 0.3 + 1.1 * np.sin(2 * np.pi * 3 * x), \n         'kernel': np.array([1, 2, 1]), 'boundary_mode': 'periodic'},\n        \n        # Test 2: Normalized kernel, zero padding boundary\n        {'N': 32, 'u_func': lambda x: 0.5 + 0.7 * np.sin(2 * np.pi * 5 * x),\n         'kernel': np.array([1, 4, 6, 4, 1]) / 16.0, 'boundary_mode': 'zeropadding'},\n        \n        # Test 3: Constant field, sub-unity-sum kernel, periodic boundary\n        {'N': 15, 'u_func': lambda x: 0.7 + 0.0 * x, # u_n = C\n         'kernel': np.array([2, 5, 2]) / 10.0, 'boundary_mode': 'periodic'}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        u_func = case['u_func']\n        kernel = case['kernel']\n        boundary_mode = case['boundary_mode']\n        \n        # 1. Construct the grid and initial velocity field\n        dx = 1.0 / N\n        x = np.arange(N) * dx\n        u = u_func(x)\n        \n        # 2. Apply the nonconservative filter\n        if boundary_mode == 'periodic':\n            # scipy.ndimage.convolve1d 'wrap' mode handles periodic boundaries\n            # The unnormalized kernel sum is sum(g_m), let's calculate it.\n            # For Test 1, the kernel needs to be normalized before applying a standard convolution\n            # OR we can apply it as is, and it will be non-conservative.\n            # The problem asks to use the non-conservative filter.\n            # In Test 1, sum(g) = 4. Convolve1d does not automatically normalize.\n            u_tilde_nc = convolve1d(u, kernel, mode='wrap')\n        elif boundary_mode == 'zeropadding':\n            # 'constant' mode with cval=0.0 handles zero padding\n            u_tilde_nc = convolve1d(u, kernel, mode='constant', cval=0.0)\n        \n        # 3. Calculate original and nonconservative momentum\n        M_orig = np.sum(u) * dx\n        M_nc = np.sum(u_tilde_nc) * dx\n        \n        # 4. Compute the nonconservative error\n        E_nc = np.abs(M_nc - M_orig)\n        \n        # 5. Compute the uniform correction term\n        # c = (1/N) * sum(u - u_tilde_nc) = dx * sum(u - u_tilde_nc)\n        c = dx * np.sum(u - u_tilde_nc) \n        \n        # 6. Apply the correction to get the fixed field\n        u_tilde_fix = u_tilde_nc + c\n        \n        # 7. Calculate the post-fix momentum and error\n        M_fix = np.sum(u_tilde_fix) * dx\n        E_fix = np.abs(M_fix - M_orig)\n        \n        results.extend([E_nc, E_fix])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "尺度相似性概念的真正威力体现在其作为动态模型框架基石的角色中。本练习 () 是一个综合性的实践，它将引导您实现完整的动态程序，这是现代大涡模拟中的一项关键技术。您将使用Germano恒等式，通过在网格尺度和测试滤波尺度上假设相似的模型形式，来动态地计算模型系数，从而使模型能够自适应于流动的局部物理特性。",
            "id": "3360733",
            "problem": "考虑一个不可压缩流的大涡模拟（LES），其中，滤波后的速度场表示为 $\\bar{u}_i(x,t)$，亚格子尺度（SGS）应力张量定义为 $\\tau_{ij} = \\overline{u_i u_j} - \\bar{u}_i \\bar{u}_j$。令 Germano 恒等式用宽度为 $\\hat{\\Delta} = \\alpha \\Delta$（其中 $\\alpha > 1$）的测试滤波器（用帽子符号表示）写为 $L_{ij} = \\widehat{\\bar{u}_i \\bar{u}_j} - \\hat{\\bar{u}}_i \\hat{\\bar{u}}_j = T_{ij} - \\widehat{\\tau_{ij}}$。考虑一个带有可调系数 $C$ 的尺度相似性模型，其中网格尺度上模拟的 SGS 应力为 $\\tau^{m}_{ij} = C B_{ij}(\\bar{\\mathbf{u}})$，尺度相似性张量 $B_{ij}$ 是通过将宽度为 $\\Delta$ 的辅助高斯滤波器（用波浪号表示）应用于解析场来构造的：\n$$\nB_{ij}(\\bar{\\mathbf{u}}) = \\widetilde{\\bar{u}_i \\bar{u}_j} - \\tilde{\\bar{u}}_i \\tilde{\\bar{u}}_j.\n$$\n在测试滤波器尺度上，相同的模型形式给出 $T^{m}_{ij} = C B_{ij}(\\hat{\\bar{\\mathbf{u}}})$。动态程序使用以下恒等式通过最小二乘法确定 $C$：\n$$\nL_{ij} \\approx C \\left( B_{ij}(\\hat{\\bar{\\mathbf{u}}}) - \\widehat{B_{ij}(\\bar{\\mathbf{u}})} \\right) \\equiv C H_{ij},\n$$\n其中 $H_{ij} = B_{ij}(\\hat{\\bar{\\mathbf{u}}}) - \\widehat{B_{ij}(\\bar{\\mathbf{u}})}$。为了移除动态不可解的各向同性部分，使用 $d$ 维空间中的偏张量投影 $A_{ij}^{\\prime} = A_{ij} - \\frac{1}{d} A_{kk} \\delta_{ij}$，其中 $d = 2$。该系数可以局部地确定为\n$$\nC(\\mathbf{x},t) = \\frac{\\sum_{i,j} L_{ij}^{\\prime} H_{ij}^{\\prime}}{\\sum_{i,j} H_{ij}^{\\prime} H_{ij}^{\\prime}},\n$$\n也可以在 Germano-Lilly 全局最小二乘平均的意义上确定为\n$$\nC_{\\text{Lilly}}(t) = \\frac{\\left\\langle \\sum_{i,j} L_{ij}^{\\prime} H_{ij}^{\\prime} \\right\\rangle}{\\left\\langle \\sum_{i,j} H_{ij}^{\\prime} H_{ij}^{\\prime} \\right\\rangle},\n$$\n其中 $\\langle \\cdot \\rangle$ 表示空间平均，索引求和是针对对称分量定义的，约定为二维情况下 $\\sum_{i,j} A_{ij} B_{ij} \\equiv A_{11} B_{11} + 2 A_{12} B_{12} + A_{22} B_{22}$。\n\n采用边长为 $L = 2\\pi$ 的周期性方形域，用 $N \\times N$ 个点进行均匀离散化。使用 Taylor-Green 涡将解析速度场定义为\n$$\n\\bar{u}(x,y,t) = U_0 \\sin(k x) \\cos(k y) \\mathrm{e}^{-2 \\nu k^2 t}, \\qquad\n\\bar{v}(x,y,t) = - U_0 \\cos(k x) \\sin(k y) \\mathrm{e}^{-2 \\nu k^2 t},\n$$\n参数为 $U_0 > 0$，$k \\in \\mathbb{N}$，运动粘度 $\\nu > 0$。使用宽度为 $\\Delta$ 的高斯滤波算子，其傅里叶传递函数为\n$$\n\\widehat{G}_\\Delta(\\mathbf{k}) = \\exp\\left( - \\tfrac{1}{2} \\sigma^2 |\\mathbf{k}|^2 \\right), \\quad \\text{with } \\sigma = \\frac{\\Delta}{\\sqrt{12}},\n$$\n使得该滤波器与宽度为 $\\Delta$ 的盒式滤波器具有相同的二阶矩。设网格间距为 $\\Delta x = \\Delta y = L/N$，并将辅助相似性滤波器宽度设置为 $\\Delta = 2 \\Delta x$。测试滤波器宽度为 $\\hat{\\Delta} = \\alpha \\Delta$。\n\n任务：编写一个完整的程序，对下面测试套件中的每一对参数 $(\\alpha, t)$，计算：\n- 全局动态系数 $C_{\\text{Lilly}}(t)$，\n- 局部系数的空间平均值 $\\langle C(\\mathbf{x},t) \\rangle$，仅限于分母严格为正的点，\n- 在这些点上局部系数的空间标准差。\n\n所有三个报告的量都必须是无量纲实数。在计算 $C(\\mathbf{x},t)$ 时，如果局部分母 $\\sum_{i,j} H_{ij}^{\\prime} H_{ij}^{\\prime}$ 小于一个小的阈值 $\\varepsilon$，则在该点将 $C(\\mathbf{x},t)$ 设置为 0 以避免除以零。使用 $\\varepsilon = 10^{-12}$。\n\n使用 $N = 64$，$L = 2\\pi$，$U_0 = 1$，$k = 1$ 以及 $\\nu = 10^{-2}$。三角函数中的角度必须以弧度为单位。输出没有需要报告的物理单位；所有输出都是纯数字。\n\n测试套件：\n- 情况 1：$(\\alpha, t) = (1.1, 0)$，一个接近单位算子的测试滤波器，用于探测 Germano 恒等式变得病态的边界。\n- 情况 2：$(\\alpha, t) = (2.0, 0)$，一个在初始化附近的典型动态测试。\n- 情况 3：$(\\alpha, t) = (2.0, 1.0)$，在稍后时刻使用相同的滤波器比率以评估时间行为。\n- 情况 4：$(\\alpha, t) = (3.0, 0.5)$，一个更强的测试滤波器，用于探测尺度分离效应。\n\n你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含三个浮点数的子列表，顺序为 $[C_{\\text{Lilly}}, \\langle C \\rangle, \\mathrm{std}(C)]$。例如，最终的输出格式必须是\n$$\n\\texttt{[[c\\_1, m\\_1, s\\_1],[c\\_2, m\\_2, s\\_2],[c\\_3, m\\_3, s\\_3],[c\\_4, m\\_4, s\\_4]]}\n$$\n其中每个 $c_i$、$m_i$ 和 $s_i$ 都是一个浮点数。",
            "solution": "用户希望解决一个计算流体力学问题。\n\n### 方法\n\n该问题要求在大涡模拟（LES）的背景下，对动态尺度相似性模型的系数进行数值评估。计算是在一个二维周期性域上，针对一个给定的解析速度场——Taylor-Green 涡——进行的。求解过程包括以下一系列步骤：\n1.  **离散化和傅里叶表示**：将连续域和速度场在均匀的 $N \\times N$ 网格上进行离散化。由于域是周期性的，所有定义为卷积的滤波操作都可以使用快速傅里叶变换（FFT）在傅里叶空间中最高效地执行。\n2.  **滤波器定义**：使用两个高斯滤波器：一个宽度为 $\\Delta = 2\\Delta x$ 的辅助滤波器（用波浪号表示）和一个宽度为 $\\hat{\\Delta} = \\alpha\\Delta$ 的测试滤波器（用帽子符号表示）。它们的传递函数 $\\widetilde{G}(\\mathbf{k}) = \\exp(-\\frac{1}{2}\\sigma^2|\\mathbf{k}|^2)$ 和 $\\widehat{G}(\\mathbf{k}) = \\exp(-\\frac{1}{2}\\hat{\\sigma}^2|\\mathbf{k}|^2)$ 是在离散波数网格上构造的。参数为 $\\sigma = \\Delta/\\sqrt{12}$ 和 $\\hat{\\sigma} = \\hat{\\Delta}/\\sqrt{12}$。一个复合滤波器，对应于同时应用两个滤波器，也将被使用，其传递函数为 $\\widetilde{G}(\\mathbf{k})\\widehat{G}(\\mathbf{k})$。\n3.  **张量场计算**：问题的核心是计算从解析速度场 $\\bar{u}_i$ 导出的几个张量场：\n    -   **Leonard 张量 ($L_{ij}$)**：该张量源于 Germano 恒等式，定义为 $L_{ij} = \\widehat{\\bar{u}_i \\bar{u}_j} - \\hat{\\bar{u}}_i \\hat{\\bar{u}}_j$。它代表了与网格滤波器和测试滤波器之间的尺度相关的应力。其计算涉及将测试滤波器（`hat`）应用于速度场 $\\bar{u}_i$ 及其分量的乘积 $\\bar{u}_i\\bar{u}_j$。\n    -   **尺度相似性张量 ($B_{ij}$)**：该模型基于张量 $B_{ij}(\\bar{\\mathbf{u}}) = \\widetilde{\\bar{u}_i \\bar{u}_j} - \\tilde{\\bar{u}}_i \\tilde{\\bar{u}}_j$。这涉及将辅助滤波器（`tilde`）应用于速度场及其分量乘积。\n    -   **模型张量 ($H_{ij}$)**：动态程序依赖于张量 $H_{ij} = B_{ij}(\\hat{\\bar{\\mathbf{u}}}) - \\widehat{B_{ij}(\\bar{\\mathbf{u}})}$。\n        - 第一项 $B_{ij}(\\hat{\\bar{\\mathbf{u}}})$ 是应用于测试滤波场的尺度相似性模型，即 $B_{ij}(\\hat{\\bar{\\mathbf{u}}}) = \\widetilde{\\hat{\\bar{u}}_i \\hat{\\bar{u}}_j} - \\tilde{\\hat{\\bar{u}}}_i \\tilde{\\hat{\\bar{u}}}_j$。\n        - 第二项 $\\widehat{B_{ij}(\\bar{\\mathbf{u}})}$ 是经过测试滤波的尺度相似性张量。\n        - 像 $\\tilde{\\hat{\\bar{u}}}_i$ 这样的项可以通过将复合滤波器直接应用于 $\\bar{u}_i$ 来高效计算。\n\n4.  **偏张量投影**：应力张量的各向同性部分无法通过动态程序确定，通常会被移除。我们使用投影 $A_{ij}' = A_{ij} - \\frac{1}{2}A_{kk}\\delta_{ij}$ 在 $d=2$ 维空间中计算偏张量部分 $L_{ij}'$ 和 $H_{ij}'$。对于一个对称的二维张量，这可以简化为 $A_{11}' = \\frac{1}{2}(A_{11} - A_{22})$，$A_{22}' = -A_{11}'$ 和 $A_{12}' = A_{12}$。\n\n5.  **系数计算**：使用偏张量，我们计算系数表达式的分子 $N_C = \\sum_{i,j} L_{ij}' H_{ij}'$ 和分母 $D_C = \\sum_{i,j} H_{ij}' H_{ij}'$。使用了对称二维张量的求和约定 $\\sum_{i,j} A_{ij} B_{ij} \\equiv A_{11} B_{11} + 2 A_{12} B_{12} + A_{22} B_{22}$。对于偏张量，这简化为 $N_C = 2(L_{11}' H_{11}' + L_{12}' H_{12}')$ 和 $D_C = 2(H_{11}'^2 + (H_{12}')^2)$。因子 $2$ 在比率中被抵消。\n    -   **全局系数 ($C_{\\text{Lilly}}$)**：计算为空间平均值的比率，$C_{\\text{Lilly}} = \\langle N_C \\rangle / \\langle D_C \\rangle$。\n    -   **局部系数 ($C(\\mathbf{x}, t)$)**：逐点计算为 $C = N_C / D_C$。应用一个阈值 $\\varepsilon = 10^{-12}$；如果在某点 $D_C  \\varepsilon$，则将 $C$ 设置为 $0$。\n    -   **统计**：仅在 $D_C > \\varepsilon$ 的网格点上计算 $C$ 的平均值和标准差。\n\n对测试套件中的每一对参数 $(\\alpha, t)$ 重复此过程。\n\n### 数学公式\n给定的速度场为：\n$$\n\\bar{u}(x,y,t) = U_0 \\sin(k x) \\cos(k y) e^{-2 \\nu k^2 t}, \\qquad \\bar{v}(x,y,t) = - U_0 \\cos(k x) \\sin(k y) e^{-2 \\nu k^2 t}\n$$\n$N = 64$，$L = 2\\pi$，$U_0 = 1$，$k = 1$，$\\nu = 10^{-2}$。\n网格间距：$\\Delta x = L/N$。\n辅助滤波器宽度：$\\Delta = 2\\Delta x$。\n测试滤波器宽度：$\\hat{\\Delta} = \\alpha \\Delta$。\n\n在傅里叶空间中对一个场 $f(\\mathbf{x})$ 进行滤波，是通过 $\\mathcal{F}^{-1}\\{\\widehat{G}(\\mathbf{k}) \\mathcal{F}\\{f(\\mathbf{x})\\}\\}$ 完成的。\n\n计算过程通过构造每个张量，对其进行投影，计算点积，最后评估定义的系数及其统计数据来进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    \n    # Define problem parameters\n    N = 64\n    L = 2 * np.pi\n    U0 = 1.0\n    k_wave = 1.0  # Renamed from k to avoid conflict with wavenumber arrays\n    nu = 1e-2\n    epsilon = 1e-12\n\n    # Define test cases from the problem statement\n    test_cases = [\n        (1.1, 0.0),\n        (2.0, 0.0),\n        (2.0, 1.0),\n        (3.0, 0.5),\n    ]\n\n    # Setup grid and wavenumbers\n    dx = L / N\n    x_coords = np.arange(N) * dx\n    x, y = np.meshgrid(x_coords, x_coords, indexing='ij')\n    \n    k_coords = np.fft.fftfreq(N, d=dx) * 2 * np.pi\n    kx, ky = np.meshgrid(k_coords, k_coords, indexing='ij')\n    k_sq = kx**2 + ky**2\n\n    # Helper for filtering\n    def filter_field(field, kernel):\n        \"\"\"Applies a filter in Fourier space.\"\"\"\n        return np.fft.ifft2(np.fft.fft2(field) * kernel).real\n\n    results = []\n    for alpha, t in test_cases:\n        # Define filter kernels for the current case\n        delta_aux = 2 * dx\n        sigma_aux = delta_aux / np.sqrt(12)\n        G_tilde = np.exp(-0.5 * sigma_aux**2 * k_sq)\n        \n        delta_test = alpha * delta_aux\n        sigma_test = delta_test / np.sqrt(12)\n        G_hat = np.exp(-0.5 * sigma_test**2 * k_sq)\n        \n        G_hat_tilde = G_hat * G_tilde\n    \n        # Define velocity field at time t\n        decay = np.exp(-2 * nu * k_wave**2 * t)\n        u_bar = U0 * np.sin(k_wave * x) * np.cos(k_wave * y) * decay\n        v_bar = -U0 * np.cos(k_wave * x) * np.sin(k_wave * y) * decay\n        \n        # --- Calculate Leonard Tensor L_ij ---\n        u_bar_u_bar = u_bar * u_bar\n        u_bar_v_bar = u_bar * v_bar\n        v_bar_v_bar = v_bar * v_bar\n    \n        u_bar_hat = filter_field(u_bar, G_hat)\n        v_bar_hat = filter_field(v_bar, G_hat)\n    \n        L11 = filter_field(u_bar_u_bar, G_hat) - u_bar_hat * u_bar_hat\n        L12 = filter_field(u_bar_v_bar, G_hat) - u_bar_hat * v_bar_hat\n        L22 = filter_field(v_bar_v_bar, G_hat) - v_bar_hat * v_bar_hat\n        \n        # --- Calculate Scale-Similarity Tensor B_ij(u_bar) ---\n        u_bar_tilde = filter_field(u_bar, G_tilde)\n        v_bar_tilde = filter_field(v_bar, G_tilde)\n    \n        B11_ubar = filter_field(u_bar_u_bar, G_tilde) - u_bar_tilde * u_bar_tilde\n        B12_ubar = filter_field(u_bar_v_bar, G_tilde) - u_bar_tilde * v_bar_tilde\n        B22_ubar = filter_field(v_bar_v_bar, G_tilde) - v_bar_tilde * v_bar_tilde\n        \n        # --- Calculate Model Tensor H_ij ---\n        # Term 1: B_ij(u_bar_hat)\n        u_bar_hat_u_bar_hat = u_bar_hat * u_bar_hat\n        u_bar_hat_v_bar_hat = u_bar_hat * v_bar_hat\n        v_bar_hat_v_bar_hat = v_bar_hat * v_bar_hat\n        \n        u_bar_hat_tilde = filter_field(u_bar, G_hat_tilde)\n        v_bar_hat_tilde = filter_field(v_bar, G_hat_tilde)\n        \n        B11_of_ubar_hat = filter_field(u_bar_hat_u_bar_hat, G_tilde) - u_bar_hat_tilde * u_bar_hat_tilde\n        B12_of_ubar_hat = filter_field(u_bar_hat_v_bar_hat, G_tilde) - u_bar_hat_tilde * v_bar_hat_tilde\n        B22_of_ubar_hat = filter_field(v_bar_hat_v_bar_hat, G_tilde) - v_bar_hat_tilde * v_bar_hat_tilde\n        \n        # Term 2: hat(B_ij(u_bar))\n        B11_ubar_filtered = filter_field(B11_ubar, G_hat)\n        B12_ubar_filtered = filter_field(B12_ubar, G_hat)\n        B22_ubar_filtered = filter_field(B22_ubar, G_hat)\n\n        # Combine for H_ij\n        H11 = B11_of_ubar_hat - B11_ubar_filtered\n        H12 = B12_of_ubar_hat - B12_ubar_filtered\n        H22 = B22_of_ubar_hat - B22_ubar_filtered\n        \n        # --- Deviatoric Projections ---\n        L11_p = 0.5 * (L11 - L22)\n        H11_p = 0.5 * (H11 - H22)\n        \n        # --- Calculate Dot Products for Coefficients ---\n        # The sum sum_ij A'_ij B'_ij for traceless symmetric 2D tensors is 2*(A'_11*B'_11 + A_12*B_12).\n        # The factor of 2 cancels in the ratio for C.\n        numerator_term = L11_p * H11_p + L12 * H12\n        denominator_term = H11_p**2 + H12**2\n        \n        # --- Calculate Coefficients ---\n        # Global Lilly coefficient\n        mean_denom = np.mean(denominator_term)\n        c_lilly = np.mean(numerator_term) / mean_denom if mean_denom != 0 else 0.0\n        \n        # Local coefficient\n        c_local = np.zeros_like(numerator_term)\n        mask = denominator_term > epsilon\n        c_local[mask] = numerator_term[mask] / denominator_term[mask]\n        \n        # Statistics on valid local coefficients\n        c_local_valid = c_local[mask]\n        if c_local_valid.size > 0:\n            c_mean = np.mean(c_local_valid)\n            c_std = np.std(c_local_valid)\n        else:\n            c_mean = 0.0\n            c_std = 0.0\n            \n        results.append([c_lilly, c_mean, c_std])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}