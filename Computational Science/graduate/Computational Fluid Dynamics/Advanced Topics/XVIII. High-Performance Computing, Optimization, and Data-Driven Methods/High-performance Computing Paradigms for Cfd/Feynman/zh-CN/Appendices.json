{
    "hands_on_practices": [
        {
            "introduction": "在进行性能优化之前，首先必须能够准确地分析和预测性能瓶颈。本练习将引导你应用经典的屋顶线 (Roofline) 模型，这是一个关键的性能分析工具，用于判断一个计算核心是受内存带宽还是计算吞吐量的限制。通过分析计算流体动力学 (CFD) 求解器中常见的稀疏矩阵向量乘法 (SpMV) 操作，你将掌握量化计算强度并预测性能上界的核心技能。",
            "id": "3329287",
            "problem": "考虑一个计算流体动力学（CFD）求解器中的矩阵向量乘积，该求解器使用压缩稀疏行（CSR）数据结构来应用一个七点模板对三维泊松算子进行有限体积离散化。该稀疏矩阵每行恰好有 $z=7$ 个非零元。CSR表示法使用双精度值和向量（每个存储为 $8$ 字节），以及用于列索引和行指针数组的 $32$ 位整数（每个存储为 $4$ 字节）。该操作是在一个中央处理器（CPU）节点上执行的稀疏矩阵向量乘法（SpMV），$y = A x$。该节点的持续主内存带宽为每秒 $200$ GB，双精度峰值性能为每秒 $1.6 \\times 10^{12}$ 次浮点运算。对于带宽，将 $1$ GB解释为 $10^{9}$ 字节。\n\n假设一个实现，其中对CSR数组进行流式访问，每个非零元对单个输出项的累加贡献一次乘法和一次加法，累加完全在寄存器中进行，并且输出项 $y_{i}$ 每行写入一次。由于问题规模和访问模式的结合，假设输入向量项 $x_{j}$ 在各行之间没有重用，并计算每行界定非零元区间所需的两个行指针项（一个用于行首，一个用于行尾）。\n\n从CSR内存访问模式和Roofline模型的定义出发，确定每行移动的总字节数和浮点运算次数，计算此SpMV的运算强度，然后确定Roofline性能界限。最终性能界限以每秒十亿次浮点运算（GFLOP/s）表示。将您的最终答案四舍五入到三位有效数字。",
            "solution": "首先对问题陈述进行严格的验证过程。\n\n### 步骤1：提取已知条件\n- 运算：稀疏矩阵向量乘法 (SpMV)，$y = A x$。\n- 求解器背景：计算流体动力学 (CFD)。\n- 离散化：有限体积法，三维泊松算子，七点模板。\n- 矩阵结构：稀疏，每行恰好有 $z=7$ 个非零元。\n- 数据结构：压缩稀疏行 (CSR)。\n- 数据类型：\n    - 矩阵值 (`A_vals`) 和向量项 ($x, y$)：双精度，每个元素 $8$ 字节。\n    - 列索引 (`A_cols`) 和行指针 (`A_row_ptr`)：$32$ 位整数，每个元素 $4$ 字节。\n- 硬件规格：\n    - 主内存带宽 ($B$)：每秒 $200$ GB ($200 \\times 10^{9}$ 字节/秒)。\n    - 双精度峰值性能 ($P_{\\text{peak}}$)：每秒 $1.6 \\times 10^{12}$ 次浮点运算 (FLOP/s)。\n- 实现假设：\n    - 每个非零元的浮点运算：$1$ 次乘法和 $1$ 次加法。\n    - 输出项 $y_i$ 的累加完全在寄存器中进行。\n    - 输出项 $y_i$ 每行写入内存一次。\n    - 内存访问是流式的，输入向量项 ($x_j$) 在各行之间没有缓存重用。\n    - 每行读取两个行指针项来界定非零元。\n\n### 步骤2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学依据**：该问题根植于高性能计算、数值线性代数和计算流体动力学的既定原理。CSR格式、SpMV操作和Roofline性能模型是该领域的标准课题。3D泊松方程的七点模板是一个经典的例子。\n- **适定性**：该问题是适定的。它提供了计算运算强度和应用Roofline模型以找到唯一性能界限所需的所有必要参数和一组清晰、明确的假设（例如，数据大小、每个非零元的操作、内存访问模式）。\n- **客观性**：问题陈述使用了精确、客观和技术性的语言，没有歧义或主观论断。\n- **缺陷检查**：\n    1.  **科学或事实不健全**：无。所涉及的概念及其应用都是标准的。提供的硬件性能数值对于现代CPU节点是现实的。\n    2.  **不可形式化或不相关**：无。该问题完全可以形式化，并且与科学计算中数值核心的性能分析直接相关。\n    3.  **不完整或矛盾的设置**：无。问题是自包含的，并提供了所有必要的信息。假设每行非零元数量恒为（$z=7$）是一个简化，但已明确说明，并非矛盾。\n    4.  **不切实际或不可行**：无。这些条件在物理上是合理的，并且在性能建模练习中很常见。\n    5.  **病态或结构不良**：无。问题结构从第一性原理（FLOP和字节计数）逻辑地引导用户到Roofline模型的最终应用。\n    6.  **伪深刻、琐碎或同义反复**：无。该问题要求正确且不平凡地应用Roofline模型，这是性能工程中的一个关键概念。\n    7.  **超出科学可验证性**：无。整个计算都基于可验证的数学定义和模型。\n\n### 步骤3：结论与行动\n问题是**有效的**。将推导解答。\n\n### 解答推导\n解答过程首先计算矩阵向量乘积单行所需的浮点运算次数（FLOPs）以及与主内存之间传输的总字节数。然后使用这些值计算运算强度，这是Roofline模型中的一个关键参数。最后，应用Roofline模型来确定性能界限。\n\n**1. 每行的浮点运算次数**\n问题陈述，矩阵的每个非零元贡献一次乘法和一次加法。由于每行有 $z=7$ 个非零元，因此每行的总FLOPs数为：\n$$\n\\text{FLOPs per row} = 2 \\times z = 2 \\times 7 = 14 \\text{ FLOPs}\n$$\n\n**2. 每行的内存流量**\n总内存流量（移动的字节数）是为计算一行而从主内存读取和写入主内存的所有数据的总和。我们计算CSR数据结构各部分以及输入/输出向量的流量。\n\n- **CSR `values` 数组**：对于 $z=7$ 个非零元中的每一个，读取一个双精度值。一个双精度浮点数是 $8$ 字节。\n$$\n\\text{Bytes}_{\\text{values}} = z \\times (\\text{size of double}) = 7 \\times 8 = 56 \\text{ bytes}\n$$\n- **CSR `col_ind` 数组**：对于 $z=7$ 个非零元中的每一个，读取一个 $32$ 位整数列索引。一个 $32$ 位整数是 $4$ 字节。\n$$\n\\text{Bytes}_{\\text{col\\_ind}} = z \\times (\\text{size of int32}) = 7 \\times 4 = 28 \\text{ bytes}\n$$\n- **CSR `row_ptr` 数组**：为了识别第 $i$ 行的非零元，需要读取 `row_ptr[i]` 和 `row_ptr[i+1]` 这两个条目。这是两个 $32$ 位整数。\n$$\n\\text{Bytes}_{\\text{row\\_ptr}} = 2 \\times (\\text{size of int32}) = 2 \\times 4 = 8 \\text{ bytes}\n$$\n- **输入向量 `x`**：对于 $z=7$ 个非零元 $A_{ij}$ 中的每一个，读取相应的元素 $x_j$。问题陈述假设没有缓存重用，因此这 $z=7$ 次访问中的每一次都会从主内存读取。向量元素是双精度的。\n$$\n\\text{Bytes}_{x} = z \\times (\\text{size of double}) = 7 \\times 8 = 56 \\text{ bytes}\n$$\n- **输出向量 `y`**：每行将单个结果元素 $y_i$ 写入内存一次。这是一个双精度值。\n$$\n\\text{Bytes}_{y} = 1 \\times (\\text{size of double}) = 1 \\times 8 = 8 \\text{ bytes}\n$$\n每行移动的总字节数是这些部分的总和：\n$$\n\\text{Total Bytes per row} = \\text{Bytes}_{\\text{values}} + \\text{Bytes}_{\\text{col\\_ind}} + \\text{Bytes}_{\\text{row\\_ptr}} + \\text{Bytes}_{x} + \\text{Bytes}_{y}\n$$\n$$\n\\text{Total Bytes per row} = 56 + 28 + 8 + 56 + 8 = 156 \\text{ bytes}\n$$\n\n**3. 运算强度**\n运算强度 ($I$) 是浮点运算次数与处理器和主内存之间移动的数据字节数之比。\n$$\nI = \\frac{\\text{FLOPs per row}}{\\text{Total Bytes per row}} = \\frac{14}{156} \\text{ FLOPs/byte}\n$$\n这简化为 $I = \\frac{7}{78}$ FLOPs/byte。\n\n**4. Roofline性能界限**\nRoofline模型给出了性能的上限 $P$，其值为峰值计算性能 $P_{\\text{peak}}$ 和内存带宽所能支持的峰值性能 $P_{mem} = I \\times B$ 中的较小者。\n$$\nP = \\min(P_{\\text{peak}}, I \\times B)\n$$\n给定的值为：\n- $P_{\\text{peak}} = 1.6 \\times 10^{12}$ FLOP/s\n- $B = 200 \\times 10^9$ 字节/秒\n\n首先，我们计算受内存带宽限制的性能：\n$$\nP_{mem} = I \\times B = \\left(\\frac{14}{156}\\right) \\frac{\\text{FLOPs}}{\\text{byte}} \\times (200 \\times 10^9) \\frac{\\text{bytes}}{\\text{s}}\n$$\n$$\nP_{mem} = \\frac{14 \\times 200 \\times 10^9}{156} \\frac{\\text{FLOPs}}{\\text{s}} = \\frac{2800}{156} \\times 10^9 \\text{ FLOP/s}\n$$\n$$\nP_{mem} \\approx 17.9487179... \\times 10^9 \\text{ FLOP/s}\n$$\n这大约是 $17.95$ GFLOP/s。\n\n现在，我们将其与峰值计算性能进行比较：\n$$\nP_{\\text{peak}} = 1.6 \\times 10^{12} \\text{ FLOP/s} = 1600 \\times 10^9 \\text{ FLOP/s} = 1600 \\text{ GFLOP/s}\n$$\nRoofline性能界限是：\n$$\nP = \\min(1600 \\times 10^9 \\text{ FLOP/s}, 17.9487... \\times 10^9 \\text{ FLOP/s})\n$$\n由于 $17.9487... \\times 10^9 \\ll 1600 \\times 10^9$，性能受限于内存带宽。\n$$\nP \\approx 17.9487... \\times 10^9 \\text{ FLOP/s}\n$$\n问题要求结果以GFLOP/s为单位，并四舍五入到三位有效数字。\n$$\nP \\approx 17.9 \\text{ GFLOP/s}\n$$",
            "answer": "$$\n\\boxed{17.9}\n$$"
        },
        {
            "introduction": "在大规模并行计算中，保证结果的按位复现性对于调试和验证至关重要。本练习探讨了由浮点数运算的非结合性引起的非确定性问题，并要求你设计一种保证确定性的并行归约方案。通过对该方案与非确定性基线方案的性能开销进行建模和量化，你将深入理解在分布式内存环境中平衡数值精度、可复现性与通信成本的实际挑战。",
            "id": "3329343",
            "problem": "考虑在一个使用消息传递接口 (MPI) 的分布式内存环境中，为可压缩纳维-斯托克斯求解器的每次非线性迭代计算残差二范数。全局残差向量被均匀地划分到 $P$ 个进程中；进程 $p$ 持有 $n$ 个双精度条目 $\\{r_{i}^{(p)}\\}_{i=1}^{n}$。残差二范数为 $\\|r\\|_{2} = \\sqrt{\\sum_{p=0}^{P-1}\\sum_{i=1}^{n} \\left(r_{i}^{(p)}\\right)^{2}}$。\n\n你需要为平方和提出一种确定性的并行归约方案，该方案能保证在相同硬件和软件配置的多次运行之间结果的按位可复现性，然后量化其相对于非确定性归约的性能开销。\n\n使用以下有科学依据的出发点作为基础：\n1. 由电气和电子工程师协会 (IEEE) $754$ 标准规定的有限精度算术不满足结合律，因此具有不同求值顺序的并行归约在多次运行之间会产生不同的舍入实现。\n2. 一个预先固定的归约顺序（例如，进程内固定的成对求和顺序，以及带有规定父子调度的固定进程间归约树）在相同的执行条件下，能够产生按位可复现的结果。\n3. 用于计算通信时间的 Hockney 延迟–带宽模型，$T(m) = \\alpha + \\beta\\, m$，其中 $\\alpha$ 是每条消息的延迟，$\\beta$ 是每字节的传输时间，这是一个经过充分检验的点对点通信模型；一个二项树归约后跟一个广播会产生 $2\\log_{2} P$ 个阶段，每个阶段携带一个大小为 $m$ 字节的消息。\n4. 处理流式数据的单节点时间可以通过一个 Roofline 风格的计算时间和内存时间的最大值来建模：$T_{\\text{local}} = \\max\\{T_{\\text{mem}}, T_{\\text{comp}}\\}$，其中 $T_{\\text{mem}} = V/B$，$V$ 是内存总量，$B$ 是可持续带宽；$T_{\\text{comp}} = \\text{flops}/F$，$flops$ 是浮点运算次数，$F$ 是可持续浮点速率。\n\n将这两种方案精确定义如下。\nA. 非确定性基线。在每个进程上，使用朴素累加法，按照数组的自然存储顺序计算局部平方和，这会对每个元素执行一次浮点乘法和一次浮点加法。在进程间，使用一个标准的 MPI all-reduce，它实现为到根节点的二项树归约后跟一个广播，除了具有 $2\\log_{2} P$ 个阶段的属性外，对其选择的形状没有其他约束。\nB. 确定性方案。在每个进程上，使用固定顺序的成对求和计算局部平方和，并在每次成对合并中使用 Kahan 补偿求和，因此对每个元素，其平方值通过一次浮点乘法和三次浮点加法/减法进行累加。在进程间，使用一个显式构造的二项树归约，其父子关系由递增的进程号确定，并为 $2\\log_{2} P$ 个阶段制定了固定调度，随后是从进程 0 进行的确定性广播；这施加了一个固定的进程间操作顺序。\n\n假设以下参数在所有进程中都是恒定的：\n- 每个进程的元素数 $n = 5 \\times 10^{7}$。\n- 进程数 $P = 256$。\n- 每个进程的可持续浮点速率 $F = 2.5 \\times 10^{9}$ flops/秒。\n- 每个进程的可持续内存带宽 $B = 2.0 \\times 10^{10}$ 字节/秒。\n- 通信延迟 $\\alpha = 3.0 \\times 10^{-6}$ 秒。\n- 每字节传输时间 $\\beta = 5.0 \\times 10^{-10}$ 秒。\n- 每个归约消息携带 $m = 8$ 字节（一个单一的双精度部分和）。\n- 最终的平方根在根节点上计算，与其他项相比其成本可以忽略不计。\n\n仅使用上述基础和定义，不借助任何其他专门的公式，推导每种方案总时间的表达式，并计算开销比 $\\mathcal{R} = T_{\\text{det}}/T_{\\text{nd}}$。将你的答案四舍五入到四位有效数字。将该比率表示为无单位的无量纲数。",
            "solution": "我们从 IEEE $754$ 的一个观察出发：浮点加法不满足结合律，因此变化的求值顺序会产生不同的舍入。可以通过固定操作顺序来强制实现多次运行间的按位可复现性。在一个进程内部，我们可以对 $n$ 个元素强制使用一个固定的成对求和树，以预定的顺序访问索引，并在每次合并中采用 Kahan 补偿求和来进一步稳定舍入轨迹。在进程间，一个为 $2\\log_{2} P$ 个阶段设计的、具有固定父子调度（例如，按进程号升序）的二项树会产生一个确定性的进程间顺序。因此，局部和全局的顺序都被固定了，和值在多次运行间是可复现的。\n\n为了分析开销，我们将时间建模为局部处理时间和通信时间的总和。两种方案的局部处理时间都受一个 Roofline 风格的计算时间和内存时间的最大值控制，因为其核心（kernel）为形成平方和而一次性地流式处理 $n$ 个元素。\n\n对于非确定性基线：\n- 每个元素，我们执行 $1$ 次乘法和 $1$ 次加法，共 $2$ 次浮点运算。因此，每个进程的总浮点工作量为\n$$\n\\text{flops}_{\\text{nd}} = 2 n.\n$$\n- 每个进程的计算时间为\n$$\nT_{\\text{comp,nd}} = \\frac{\\text{flops}_{\\text{nd}}}{F} = \\frac{2 n}{F}.\n$$\n- 每个进程的内存总量是加载 $n$ 个双精度数所需的量，为\n$$\nV = 8 n \\ \\text{bytes},\n$$\n所以每个进程的内存时间为\n$$\nT_{\\text{mem}} = \\frac{V}{B} = \\frac{8 n}{B}.\n$$\n- 每个进程的局部时间为\n$$\nT_{\\text{local,nd}} = \\max\\!\\left\\{\\frac{8 n}{B}, \\frac{2 n}{F}\\right\\}.\n$$\n- 通信方面，归约加广播形成 $2 \\log_{2} P$ 个阶段，每个阶段发送 $m=8$ 字节。使用 Hockney 模型，总通信时间为\n$$\nT_{\\text{comm}} = \\left(2 \\log_{2} P\\right)\\left(\\alpha + \\beta m\\right).\n$$\n因此，总的非确定性时间为\n$$\nT_{\\text{nd}} = T_{\\text{local,nd}} + T_{\\text{comm}}.\n$$\n\n对于确定性方案：\n- 每个元素，在 Kahan 补偿下，我们执行 $1$ 次乘法和 $3$ 次加法/减法，共 $4$ 次浮点运算。每个进程的总浮点工作量为\n$$\n\\text{flops}_{\\text{det}} = 4 n,\n$$\n并且每个进程的计算时间为\n$$\nT_{\\text{comp,det}} = \\frac{\\text{flops}_{\\text{det}}}{F} = \\frac{4 n}{F}.\n$$\n- 每个进程的内存总量和内存时间与上面相同，$T_{\\text{mem}} = \\dfrac{8 n}{B}$，因为两种方案都只流式处理数组一次。\n- 每个进程的局部时间为\n$$\nT_{\\text{local,det}} = \\max\\!\\left\\{\\frac{8 n}{B}, \\frac{4 n}{F}\\right\\}.\n$$\n- 通信使用相同的二项树深度和消息大小，但有固定的调度；在 Hockney 模型中，其成本保持不变，为\n$$\nT_{\\text{comm}} = \\left(2 \\log_{2} P\\right)\\left(\\alpha + \\beta m\\right).\n$$\n因此，总的确定性时间为\n$$\nT_{\\text{det}} = T_{\\text{local,det}} + T_{\\text{comm}}.\n$$\n\n现在我们用给定的参数计算这些表达式的值。首先计算局部时间。使用 $n = 5 \\times 10^{7}$，$F = 2.5 \\times 10^{9}$ flops/秒，以及 $B = 2.0 \\times 10^{10}$ 字节/秒，我们得到\n$$\nT_{\\text{comp,nd}} = \\frac{2 n}{F} = \\frac{2 \\cdot \\left(5 \\times 10^{7}\\right)}{2.5 \\times 10^{9}} = \\frac{10 \\times 10^{7}}{2.5 \\times 10^{9}} = \\frac{10}{2.5} \\times 10^{-2} = 4.0 \\times 10^{-2} \\ \\text{s},\n$$\n$$\nT_{\\text{comp,det}} = \\frac{4 n}{F} = \\frac{4 \\cdot \\left(5 \\times 10^{7}\\right)}{2.5 \\times 10^{9}} = \\frac{20 \\times 10^{7}}{2.5 \\times 10^{9}} = \\frac{20}{2.5} \\times 10^{-2} = 8.0 \\times 10^{-2} \\ \\text{s},\n$$\n$$\nT_{\\text{mem}} = \\frac{8 n}{B} = \\frac{8 \\cdot \\left(5 \\times 10^{7}\\right)}{2.0 \\times 10^{10}} = \\frac{40 \\times 10^{7}}{2.0 \\times 10^{10}} = \\frac{40}{2.0} \\times 10^{-3} = 2.0 \\times 10^{-2} \\ \\text{s}.\n$$\n因此，\n$$\nT_{\\text{local,nd}} = \\max\\!\\left\\{2.0 \\times 10^{-2}, \\ 4.0 \\times 10^{-2}\\right\\} = 4.0 \\times 10^{-2} \\ \\text{s},\n$$\n$$\nT_{\\text{local,det}} = \\max\\!\\left\\{2.0 \\times 10^{-2}, \\ 8.0 \\times 10^{-2}\\right\\} = 8.0 \\times 10^{-2} \\ \\text{s}.\n$$\n\n接下来，计算通信时间，使用 $P = 256$ 使得 $\\log_{2} P = 8$，$\\alpha = 3.0 \\times 10^{-6}$ 秒，$\\beta = 5.0 \\times 10^{-10}$ 秒/字节，以及 $m = 8$ 字节：\n$$\nT_{\\text{comm}} = \\left(2 \\log_{2} P\\right)\\left(\\alpha + \\beta m\\right) = \\left(2 \\cdot 8\\right)\\left(3.0 \\times 10^{-6} + 5.0 \\times 10^{-10} \\cdot 8\\right).\n$$\n计算每个阶段的项：\n$$\n\\alpha + \\beta m = 3.0 \\times 10^{-6} + 4.0 \\times 10^{-9} = 3.004 \\times 10^{-6} \\ \\text{s}.\n$$\n乘以阶段数：\n$$\nT_{\\text{comm}} = 16 \\cdot \\left(3.004 \\times 10^{-6}\\right) = 48.064 \\times 10^{-6} \\ \\text{s} = 4.8064 \\times 10^{-5} \\ \\text{s}.\n$$\n\n汇总总计：\n$$\nT_{\\text{nd}} = T_{\\text{local,nd}} + T_{\\text{comm}} = \\left(4.0 \\times 10^{-2}\\right) + \\left(4.8064 \\times 10^{-5}\\right) = 4.0048064 \\times 10^{-2} \\ \\text{s},\n$$\n$$\nT_{\\text{det}} = T_{\\text{local,det}} + T_{\\text{comm}} = \\left(8.0 \\times 10^{-2}\\right) + \\left(4.8064 \\times 10^{-5}\\right) = 8.0048064 \\times 10^{-2} \\ \\text{s}.\n$$\n最后，开销比为\n$$\n\\mathcal{R} = \\frac{T_{\\text{det}}}{T_{\\text{nd}}} = \\frac{8.0048064 \\times 10^{-2}}{4.0048064 \\times 10^{-2}} = \\frac{0.080048064}{0.040048064}.\n$$\n计算得，\n$$\n\\mathcal{R} \\approx 1.998799842\\ldots\n$$\n四舍五入到四位有效数字，得出\n$$\n\\mathcal{R} = 1.999.\n$$\n\n这个比率反映出，在给定参数下，两种方案都由计算（而非通信）主导，并且确定性方案使用的 Kahan 补偿求和相对于朴素求和，大约将浮点工作量增加了一倍，而公共的通信项只带来了可忽略的摊销效应。对于标量消息，在 Hockney 模型下，固定顺序的二项树与基线的二项 all-reduce 相比，并不会改变其渐进通信成本。",
            "answer": "$$\\boxed{1.999}$$"
        },
        {
            "introduction": "现代高性能计算严重依赖于如图形处理器 (GPU) 这样的高度并行架构，而要发挥其极致性能，必须将算法精心映射到硬件特性上。本练习将带你深入研究一种针对 GPU 的关键优化技术：共享内存分块 (shared memory tiling)。你将为一个三维 CFD 模板计算，系统地寻找最优的分块维度，以最大化流式多处理器 (SM) 的占用率 (occupancy)，从而将算法设计决策与寄存器、共享内存等底层硬件资源约束直接联系起来。",
            "id": "3329340",
            "problem": "要求您在图形处理单元 (GPU) 上，使用共享内存分块技术，为一个源于计算流体动力学 (CFD) 的三维模板，形式化并实现一种占用率驱动的分块选择策略。目标是在线程、寄存器和共享内存的资源约束下，选择整数分块维度 $(t_x,t_y,t_z)$，以最大化流式多处理器 (SM) 的占用率。您的程序必须搜索不同的分块形状，评估资源使用情况，并根据明确定义的目标和清晰的平局决胜规则选择最优分块。\n\n物理和算法背景如下。考虑一个三维 Navier–Stokes 离散化（有限体积或有限差分），其线程束大小为2的幂。为了计算所有内部模板点，保存在共享内存中的分块必须在每个维度上包含一个宽度为 $h$ 的光环。设每个线程块的内部（线程化）工作量为 $N_{\\mathrm{int}} = t_x t_y t_z$。该线程块为每个内部分单元分配一个线程。每个线程块的共享内存占用为\n$$\nS_{\\mathrm{block}} = (t_x + 2h)(t_y + 2h)(t_z + 2h) \\, F \\, s,\n$$\n其中 $F$ 是每个单元的状态变量数，$s$ 是每个变量的字节数。每个线程使用的寄存器数量为 $r$ 个，因此每个线程块的寄存器数量为 $R_{\\mathrm{block}} = r \\, N_{\\mathrm{int}}$。\n\n您将使用以下基本定义和经过充分验证的事实作为推导和实现的基础：\n- GPU 以线程束为单位执行线程，每个线程束大小为 $W$ 个线程。每个线程块的线程束数量为 $W_b = \\lceil N_{\\mathrm{int}}/W \\rceil$。\n- 流式多处理器 (SM) 有资源限制：每个线程块的最大线程数 $T_{\\mathrm{block}}^{\\max}$、每个SM的最大线程块数 $B_{\\mathrm{SM}}^{\\max}$、每个SM的最大线程数 $T_{\\mathrm{SM}}^{\\max}$、每个SM的寄存器数 $R_{\\mathrm{SM}}$、每个SM的共享内存大小 $M_{\\mathrm{sh}}$，以及每个线程块的最大共享内存 $M_{\\mathrm{sh}}^{\\mathrm{block}}$。每个SM的最大线程束数量为 $W_{\\mathrm{SM}}^{\\max} = T_{\\mathrm{SM}}^{\\max}/W$。\n- SM上的驻留线程块数量受每种资源的限制：\n$$\nb_T = \\left\\lfloor \\frac{T_{\\mathrm{SM}}^{\\max}}{N_{\\mathrm{int}}} \\right\\rfloor, \\quad\nb_R = \\left\\lfloor \\frac{R_{\\mathrm{SM}}}{R_{\\mathrm{block}}} \\right\\rfloor, \\quad\nb_S = \\left\\lfloor \\frac{M_{\\mathrm{sh}}}{S_{\\mathrm{block}}} \\right\\rfloor, \\quad\nb_{\\max} = B_{\\mathrm{SM}}^{\\max}.\n$$\n每个SM的活跃线程块数是 $B = \\min(b_T,b_R,b_S,b_{\\max})$，前提是线程块本身满足 $N_{\\mathrm{int}} \\le T_{\\mathrm{block}}^{\\max}$ 和 $S_{\\mathrm{block}} \\le M_{\\mathrm{sh}}^{\\mathrm{block}}$。\n- SM占用率是活跃线程束数与最大线程束数的比值：\n$$\n\\phi = \\frac{\\min\\left(W_{\\mathrm{SM}}^{\\max}, \\, B \\, W_b \\right)}{W_{\\mathrm{SM}}^{\\max}}.\n$$\n\n您的程序必须通过在可行性约束下最大化 $\\phi$ 来选择 $(t_x,t_y,t_z)$。此外，为了强调共享内存分块对于CFD模板的效用，请施加以下实际约束：\n- $N_{\\mathrm{int}} = t_x t_y t_z$ 必须是 $W$ 的倍数，以避免出现部分填充的线程束。\n- $t_x, t_y, t_z$ 是闭区间 $\\{4,5,6,\\dots,32\\}$ 内的整数。\n- 可行性要求 $N_{\\mathrm{int}} \\le T_{\\mathrm{block}}^{\\max}$ 和 $S_{\\mathrm{block}} \\le M_{\\mathrm{sh}}^{\\mathrm{block}}$。\n- 除非测试套件中另有说明，否则假设 $h \\ge 1$。\n\n对于具有相同最大 $\\phi$ 的多个 $(t_x,t_y,t_z)$，使用以下优先顺序来打破平局：\n1. 最大化共享内存重用率\n$$\n\\rho = \\frac{N_{\\mathrm{int}}}{(t_x + 2h)(t_y + 2h)(t_z + 2h)}.\n$$\n2. 最大化 $N_{\\mathrm{int}}$。\n3. 选择字典序最小的 $(t_x,t_y,t_z)$。\n\n您的程序必须在指定范围内对所有整数 $(t_x,t_y,t_z)$ 实现完整搜索，应用约束条件，为每个可行的块计算 $\\phi$ 和 $\\rho$，并根据上述规则选择最优分块。对于每个测试用例，输出应为所选的 $(t_x,t_y,t_z)$ 和相应的占用率 $\\phi$（一个介于0和1之间的实数）。\n\n此问题中没有物理单位；所有量都是无量纲的或以字节为单位。不涉及角度。不得使用百分比；任何分数量都应表示为小数。\n\n测试套件。使用以下测试用例。每个用例是一个元组，包含 $(W, T_{\\mathrm{block}}^{\\max}, B_{\\mathrm{SM}}^{\\max}, T_{\\mathrm{SM}}^{\\max}, R_{\\mathrm{SM}}, M_{\\mathrm{sh}}, M_{\\mathrm{sh}}^{\\mathrm{block}}, r, h, F, s)$，其中所有数字均为整数：\n- 用例 1: $(32, 1024, 32, 2048, 65536, 102400, 98304, 64, 1, 5, 8)$。\n- 用例 2: $(32, 1024, 32, 2048, 65536, 49152, 49152, 32, 1, 7, 8)$。\n- 用例 3: $(32, 1024, 32, 2048, 65536, 102400, 98304, 128, 1, 3, 8)$。\n- 用例 4: $(32, 512, 16, 1536, 32768, 65536, 49152, 40, 1, 4, 4)$。\n- 用例 5: $(32, 1024, 32, 2048, 65536, 102400, 98304, 64, 2, 9, 8)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个结果列表，每个测试用例一个结果，并按顺序排列。每个结果本身是一个包含四个数字 $[t_x, t_y, t_z, \\phi]$ 的列表。最后一行必须是单个 Python 风格的列表，条目之间用逗号分隔，不含任何额外文本，例如：\n$[ [t_{x,1}, t_{y,1}, t_{z,1}, \\phi_1], [t_{x,2}, t_{y,2}, t_{z,2}, \\phi_2], \\dots ]$。\n\n您的解决方案必须是一个完整的、可运行的程序，该程序实现上述逻辑并完全按照规定打印所需的单行输出。",
            "solution": "该问题是有效的。它提出了一个适定的优化任务，该任务基于高性能计算和GPU架构的既定原则。问题是自包含的，所有必要的常数、公式和约束都已明确定义。目标函数、搜索空间和多级平局决胜规则都得到了明确的规定，确保存在唯一解，并且可以通过确定性算法找到。测试套件中提供的参数对于现代GPU硬件是切合实际的。问题中没有科学上的不准确之处、矛盾或不适定的元素。\n\n目标是为GPU上的三维模板计算确定最优的整数分块维度 $(t_x, t_y, t_z)$。优化目标是在一系列硬件和算法约束下，最大化流式多处理器 (SM) 的占用率 $\\phi$。该问题要求对 $(t_x, t_y, t_z)$ 的指定参数空间进行完整搜索。\n\n解决此问题的方法是为每个测试用例进行系统的搜索和评估过程。\n\n首先，我们定义搜索空间。分块维度 $t_x$、$t_y$ 和 $t_z$ 是闭区间 $\\{4, 5, \\dots, 32\\}$ 内的整数。我们的算法将通过遍历此范围内的所有 $(t_x, t_y, t_z)$ 组合来执行穷举搜索。\n\n对于每个候选分块配置 $(t_x, t_y, t_z)$，我们首先根据一组给定的约束来评估其可行性。一个分块只有在满足以下所有条件时才被认为是可行的：\n1. 线程块中的线程数 $N_{\\mathrm{int}} = t_x t_y t_z$ 必须是线程束大小 $W$ 的倍数。\n2. 每个线程块的线程数不得超过硬件限制：$N_{\\mathrm{int}} \\le T_{\\mathrm{block}}^{\\max}$。\n3. 分块所需的共享内存（包括宽度为 $h$ 的光环）不得超过每个块允许的最大值。共享内存占用由 $S_{\\mathrm{block}} = (t_x + 2h)(t_y + 2h)(t_z + 2h) \\cdot F \\cdot s$ 给出，其中 $F$ 是每个单元的状态变量数，$s$ 是每个变量的字节大小。约束条件为 $S_{\\mathrm{block}} \\le M_{\\mathrm{sh}}^{\\mathrm{block}}$。\n\n如果一个分块配置 $(t_x, t_y, t_z)$ 未能通过这些检查中的任何一项，它将被丢弃，搜索将继续下一个配置。\n\n如果一个分块是可行的，我们继续计算其性能指标。主要指标是 SM 占用率 $\\phi$。其计算取决于可以同时驻留在单个 SM 上的线程块数量。这个数量用 $B$ 表示，受 SM 资源（总线程数、总寄存器数和总共享内存）的限制。\n一个线程块使用的寄存器数量为 $R_{\\mathrm{block}} = r \\cdot N_{\\mathrm{int}}$，其中 $r$ 是每个线程的寄存器数。\n由每种资源限制的最大并发块数计算如下：\n-   按线程数：$b_T = \\lfloor T_{\\mathrm{SM}}^{\\max} / N_{\\mathrm{int}} \\rfloor$。\n-   按寄存器数：$b_R = \\lfloor R_{\\mathrm{SM}} / R_{\\mathrm{block}} \\rfloor$，假设 $R_{\\mathrm{block}} > 0$。\n-   按共享内存：$b_S = \\lfloor M_{\\mathrm{sh}} / S_{\\mathrm{block}} \\rfloor$，假设 $S_{\\mathrm{block}} > 0$。\n\n每个 SM 的实际活跃线程块数是这些值的最小值，并进一步受架构限制 $B_{\\mathrm{SM}}^{\\max}$ 的制约：\n$$B = \\min(b_T, b_R, b_S, B_{\\mathrm{SM}}^{\\max})$$\n一个线程块中的线程束数量为 $W_b = \\lceil N_{\\mathrm{int}} / W \\rceil$。由于 $N_{\\mathrm{int}}$ 被约束为 $W$ 的倍数，这可以简化为 $W_b = N_{\\mathrm{int}} / W$。\n一个 SM 可以支持的最大线程束数量是 $W_{\\mathrm{SM}}^{\\max} = T_{\\mathrm{SM}}^{\\max} / W$。\nSM 上的活跃线程束总数为 $B \\cdot W_b$，上限为 $W_{\\mathrm{SM}}^{\\max}$。占用率 $\\phi$ 是活跃线程束数与最大可能线程束数的比值：\n$$\\phi = \\frac{\\min(W_{\\mathrm{SM}}^{\\max}, B \\cdot W_b)}{W_{\\mathrm{SM}}^{\\max}}$$\n\n计算出 $\\phi$ 后，我们将当前的分块配置与目前找到的最佳配置进行比较。比较遵循严格的字典序平局决胜程序：\n1. 主要目标是最大化占用率 $\\phi$。\n2. 如果两种配置产生相同的 $\\phi$，我们选择具有更高共享内存重用率 $\\rho = \\frac{N_{\\mathrm{int}}}{(t_x + 2h)(t_y + 2h)(t_z + 2h)}$ 的配置。\n3. 如果仍然平局，我们选择具有更大线程数 $N_{\\mathrm{int}}$ 的配置。\n4. 作为最后的平局决胜方法，我们选择字典序最小的配置 $(t_x, t_y, t_z)$。\n\n为了高效地实现这种多级优化，我们可以为每个可行的分块构建一个评分元组：$(\\phi, \\rho, N_{\\mathrm{int}}, -t_x, -t_y, -t_z)$。我们旨在找到使该评分元组最大化的分块，其中 Python 中的标准元组比较将正确实现指定的有序标准。对 $t_x, t_y, t_z$ 取负值，将字典序元组 $(t_x, t_y, t_z)$ 的最小化问题转化为最大化问题，从而巧妙地融入了单目标框架中。\n\n算法首先用低于任何可能结果的占位符值（例如，$(-1.0, -1.0, -1, 0, 0, 0)$）初始化一个 `best_score` 元组。随着搜索遍历所有 $29 \\times 29 \\times 29$ 个分块配置，每当找到更好的配置时，都会更新此 `best_score` 和相应的最优分块维度。搜索完成后，记录该测试用例的最优 $(t_x, t_y, t_z)$ 及其对应的占用率 $\\phi$。对测试套件中的所有用例重复此过程。```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the GPU tile selection problem for a series of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # (W, T_block_max, B_SM_max, T_SM_max, R_SM, M_sh, M_sh_block, r, h, F, s)\n        (32, 1024, 32, 2048, 65536, 102400, 98304, 64, 1, 5, 8),\n        (32, 1024, 32, 2048, 65536, 49152, 49152, 32, 1, 7, 8),\n        (32, 1024, 32, 2048, 65536, 102400, 98304, 128, 1, 3, 8),\n        (32, 512, 16, 1536, 32768, 65536, 49152, 40, 1, 4, 4),\n        (32, 1024, 32, 2048, 65536, 102400, 98304, 64, 2, 9, 8),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        W, T_block_max, B_SM_max, T_SM_max, R_SM, M_sh, M_sh_block, r, h, F, s = case\n        \n        best_tile_dims = None\n        # Score is a tuple: (phi, rho, N_int, -tx, -ty, -tz) for maximization\n        best_score = (-1.0, -1.0, -1, 0, 0, 0)\n\n        tile_dim_range = range(4, 33)\n\n        for tx in tile_dim_range:\n            for ty in tile_dim_range:\n                for tz in tile_dim_range:\n                    N_int = tx * ty * tz\n\n                    # Constraint 1: N_int must be a multiple of W\n                    if N_int % W != 0:\n                        continue\n                    \n                    # Constraint 2: N_int = T_block_max\n                    if N_int > T_block_max:\n                        continue\n\n                    S_block_vol = (tx + 2 * h) * (ty + 2 * h) * (tz + 2 * h)\n                    S_block = S_block_vol * F * s\n\n                    # Constraint 3: S_block = M_sh_block\n                    if S_block > M_sh_block:\n                        continue\n\n                    # Tile is feasible, calculate performance metrics\n                    \n                    # Registers per block\n                    R_block = r * N_int\n                    \n                    # Blocks per SM limitations\n                    # Note: Denominators cannot be zero due to problem constraints\n                    b_T = T_SM_max // N_int if N_int > 0 else B_SM_max\n                    b_R = R_SM // R_block if R_block > 0 else B_SM_max\n                    b_S = M_sh // S_block if S_block > 0 else B_SM_max\n\n                    # Active blocks per SM\n                    B = min(b_T, b_R, b_S, B_SM_max)\n\n                    # Warps per block\n                    W_b = N_int // W\n                    \n                    # Max warps per SM\n                    W_SM_max = T_SM_max // W\n\n                    # Occupancy\n                    active_warps = B * W_b\n                    phi = min(W_SM_max, active_warps) / W_SM_max\n\n                    # Shared memory reuse ratio\n                    rho = N_int / S_block_vol\n\n                    # Compare with best tile found so far\n                    current_score = (phi, rho, N_int, -tx, -ty, -tz)\n\n                    if current_score > best_score:\n                        best_score = current_score\n                        best_tile_dims = (tx, ty, tz)\n\n        # Append result for the current case\n        final_phi = best_score[0]\n        result_list = [*best_tile_dims, final_phi]\n        all_results.append(result_list)\n        \n    # Format the final output string as specified\n    formatted_strings = [f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in all_results]\n    final_output_str = f\"[{','.join(formatted_strings)}]\"\n    print(final_output_str)\n\nsolve()\n```",
            "answer": "[[8,8,8,0.5],[8,8,8,1.0],[4,8,8,0.5],[8,4,4,1.0],[8,8,4,0.25]]"
        }
    ]
}