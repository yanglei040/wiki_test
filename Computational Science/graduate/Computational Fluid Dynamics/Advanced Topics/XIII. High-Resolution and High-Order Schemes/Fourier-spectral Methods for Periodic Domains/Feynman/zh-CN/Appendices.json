{
    "hands_on_practices": [
        {
            "introduction": "在将傅里叶方法应用于求解偏微分方程之前，掌握函数在傅里叶空间中的表示至关重要。本练习旨在通过一个具体的函数，动手计算其傅里叶系数，从而加深对函数与其频谱之间关系的理解。此外，通过验证帕塞瓦尔恒等式（Parseval's identity），我们可以直观地看到物理空间中的能量如何与谱空间中系数的能量相关联，这是理解谱方法中守恒律的基础。",
            "id": "3396156",
            "problem": "考虑在周期性域上使用复傅里叶级数通过傅里叶谱方法求解偏微分方程（PDE）。在区间 $[0,2\\pi)$ 上，一个平方可积函数 $u(x)$ 可以用级数 $u(x)=\\sum_{k\\in\\mathbb{Z}}\\hat{u}_{k}\\exp(\\mathrm{i}kx)$ 表示，其中 $\\{\\exp(\\mathrm{i}kx)\\}_{k\\in\\mathbb{Z}}$ 是 $L^{2}([0,2\\pi))$ 内积空间中的一组正交基，其内积为 $\\langle f,g\\rangle=\\frac{1}{2\\pi}\\int_{0}^{2\\pi}f(x)\\overline{g(x)}\\,\\mathrm{d}x$，范数为 $\\|f\\|_{L^{2}([0,2\\pi))}^{2}=\\frac{1}{2\\pi}\\int_{0}^{2\\pi}|f(x)|^{2}\\,\\mathrm{d}x$。设在 $[0,2\\pi)$ 上 $u(x)=\\sin x+\\frac{1}{2}\\cos(3x)$。\n\n仅利用 $\\exp(\\mathrm{i}kx)$ 的正交性以及 $L^{2}([0,2\\pi))$ 内积的定义，确定此 $u(x)$ 的所有非零复傅里叶系数 $\\hat{u}_{k}$，并通过计算量 $D=\\frac{1}{2\\pi}\\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x-\\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2}$ 来验证能量平衡。\n以行向量的形式给出最终答案，其中包含四个非零系数和 $D$，顺序为 $(\\hat{u}_{-3},\\hat{u}_{-1},\\hat{u}_{1},\\hat{u}_{3},D)$。请使用精确值，不要四舍五入。",
            "solution": "题目要求确定函数 $u(x) = \\sin(x) + \\frac{1}{2}\\cos(3x)$ 在定义域 $[0, 2\\pi)$ 上的非零复傅里叶系数 $\\hat{u}_{k}$，并验证由量 $D$ 描述的能量平衡。\n\n函数 $u(x)$ 由复傅里叶级数 $u(x) = \\sum_{k \\in \\mathbb{Z}} \\hat{u}_{k} \\exp(\\mathrm{i}kx)$ 表示。基函数 $\\{\\exp(\\mathrm{i}kx)\\}_{k \\in \\mathbb{Z}}$ 对于给定的内积 $\\langle f,g\\rangle = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} f(x)\\overline{g(x)}\\,\\mathrm{d}x$ 是标准正交的。标准正交性意味着 $\\langle \\exp(\\mathrm{i}kx), \\exp(\\mathrm{i}mx) \\rangle = \\delta_{km}$，其中 $\\delta_{km}$ 是 Kronecker delta。\n\n指示中要求仅使用正交性来确定系数 $\\hat{u}_{k}$，这意味着我们可以使用投影公式 $\\hat{u}_k = \\langle u(x), \\exp(\\mathrm{i}kx) \\rangle$，或者更直接地，我们可以将 $u(x)$ 表达为复指数基的形式，并根据正交基中表示的唯一性，通过观察来确定系数。我们将采用后一种更有效的方法。\n\n首先，我们使用 Euler 公式将三角函数 $\\sin(x)$ 和 $\\cos(3x)$ 表示为复指数形式：\n$$ \\sin(\\theta) = \\frac{\\exp(\\mathrm{i}\\theta) - \\exp(-\\mathrm{i}\\theta)}{2\\mathrm{i}} $$\n$$ \\cos(\\theta) = \\frac{\\exp(\\mathrm{i}\\theta) + \\exp(-\\mathrm{i}\\theta)}{2} $$\n\n将这些公式应用于给定的函数 $u(x)$：\n$$ u(x) = \\left( \\frac{\\exp(\\mathrm{i}x) - \\exp(-\\mathrm{i}x)}{2\\mathrm{i}} \\right) + \\frac{1}{2} \\left( \\frac{\\exp(\\mathrm{i}3x) + \\exp(-\\mathrm{i}3x)}{2} \\right) $$\n简化各项，并使用恒等式 $\\frac{1}{\\mathrm{i}} = -\\mathrm{i}$：\n$$ u(x) = \\frac{1}{2\\mathrm{i}}\\exp(\\mathrm{i}x) - \\frac{1}{2\\mathrm{i}}\\exp(-\\mathrm{i}x) + \\frac{1}{4}\\exp(\\mathrm{i}3x) + \\frac{1}{4}\\exp(-\\mathrm{i}3x) $$\n$$ u(x) = -\\frac{\\mathrm{i}}{2}\\exp(\\mathrm{i}x) + \\frac{\\mathrm{i}}{2}\\exp(-\\mathrm{i}x) + \\frac{1}{4}\\exp(\\mathrm{i}3x) + \\frac{1}{4}\\exp(-\\mathrm{i}3x) $$\n为了与级数形式 $u(x) = \\sum_{k\\in\\mathbb{Z}}\\hat{u}_{k}\\exp(\\mathrm{i}kx)$ 相匹配，我们按指数 $k$ 对各项进行排序：\n$$ u(x) = \\frac{1}{4}\\exp(\\mathrm{i}(-3)x) + \\frac{\\mathrm{i}}{2}\\exp(\\mathrm{i}(-1)x) - \\frac{\\mathrm{i}}{2}\\exp(\\mathrm{i}(1)x) + \\frac{1}{4}\\exp(\\mathrm{i}(3)x) $$\n通过将此表达式与一般傅里叶级数进行比较，我们确定非零系数 $\\hat{u}_k$：\n- 当 $k=-3$ 时，系数为 $\\hat{u}_{-3} = \\frac{1}{4}$。\n- 当 $k=-1$ 时，系数为 $\\hat{u}_{-1} = \\frac{\\mathrm{i}}{2}$。\n- 当 $k=1$ 时，系数为 $\\hat{u}_{1} = -\\frac{\\mathrm{i}}{2}$。\n- 当 $k=3$ 时，系数为 $\\hat{u}_{3} = \\frac{1}{4}$。\n所有其他系数 $\\hat{u}_k$（对于 $k \\notin \\{-3, -1, 1, 3\\}$）均为零。\n\n接下来，我们计算量 $D = \\frac{1}{2\\pi}\\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x - \\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2}$。这个表达式比较了函数在物理空间中的范数与其系数在频率空间中的范数。对于这个标准正交系统，Parseval 定理指出这两个量是相等的，即 $\\|u\\|_{L^{2}([0,2\\pi))}^{2} = \\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2}$。因此，我们预期 $D=0$。我们必须通过显式计算来验证这一点。\n\n首先，我们计算积分项：\n$$ \\frac{1}{2\\pi}\\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x = \\frac{1}{2\\pi}\\int_{0}^{2\\pi}\\left(\\sin(x) + \\frac{1}{2}\\cos(3x)\\right)^{2}\\,\\mathrm{d}x $$\n展开平方：\n$$ \\left(\\sin(x) + \\frac{1}{2}\\cos(3x)\\right)^{2} = \\sin^{2}(x) + \\sin(x)\\cos(3x) + \\frac{1}{4}\\cos^{2}(3x) $$\n我们在 $[0, 2\\pi]$ 上逐项积分：\n使用恒等式 $\\int_{0}^{2\\pi}\\sin^{2}(nx)\\,\\mathrm{d}x = \\pi$ 和 $\\int_{0}^{2\\pi}\\cos^{2}(nx)\\,\\mathrm{d}x = \\pi$（对于任何非零整数 $n$），以及正交关系 $\\int_{0}^{2\\pi}\\sin(mx)\\cos(nx)\\,\\mathrm{d}x = 0$（对于整数 $m, n$）：\n$$ \\int_{0}^{2\\pi} \\sin^{2}(x)\\,\\mathrm{d}x = \\pi $$\n$$ \\int_{0}^{2\\pi} \\sin(x)\\cos(3x)\\,\\mathrm{d}x = 0 $$\n$$ \\int_{0}^{2\\pi} \\frac{1}{4}\\cos^{2}(3x)\\,\\mathrm{d}x = \\frac{1}{4}\\int_{0}^{2\\pi} \\cos^{2}(3x)\\,\\mathrm{d}x = \\frac{\\pi}{4} $$\n将这些结果相加，我们得到：\n$$ \\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x = \\pi + 0 + \\frac{\\pi}{4} = \\frac{5\\pi}{4} $$\n因此，表达式 $D$ 中的第一项是：\n$$ \\frac{1}{2\\pi}\\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x = \\frac{1}{2\\pi} \\left( \\frac{5\\pi}{4} \\right) = \\frac{5}{8} $$\n\n其次，我们计算系数模的平方和：\n$$ \\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2} = |\\hat{u}_{-3}|^{2} + |\\hat{u}_{-1}|^{2} + |\\hat{u}_{1}|^{2} + |\\hat{u}_{3}|^{2} $$\n模为：\n$$ |\\hat{u}_{-3}| = \\left|\\frac{1}{4}\\right| = \\frac{1}{4} \\implies |\\hat{u}_{-3}|^{2} = \\frac{1}{16} $$\n$$ |\\hat{u}_{-1}| = \\left|\\frac{\\mathrm{i}}{2}\\right| = \\frac{1}{2} \\implies |\\hat{u}_{-1}|^{2} = \\frac{1}{4} $$\n$$ |\\hat{u}_{1}| = \\left|-\\frac{\\mathrm{i}}{2}\\right| = \\frac{1}{2} \\implies |\\hat{u}_{1}|^{2} = \\frac{1}{4} $$\n$$ |\\hat{u}_{3}| = \\left|\\frac{1}{4}\\right| = \\frac{1}{4} \\implies |\\hat{u}_{3}|^{2} = \\frac{1}{16} $$\n将这些值相加：\n$$ \\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2} = \\frac{1}{16} + \\frac{1}{4} + \\frac{1}{4} + \\frac{1}{16} = \\frac{2}{16} + \\frac{2}{4} = \\frac{1}{8} + \\frac{1}{2} = \\frac{1+4}{8} = \\frac{5}{8} $$\n\n最后，我们计算 $D$：\n$$ D = \\frac{1}{2\\pi}\\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x - \\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2} = \\frac{5}{8} - \\frac{5}{8} = 0 $$\n这验证了 Parseval 定理所述的能量平衡。\n\n所要求的最终答案是行向量 $(\\hat{u}_{-3}, \\hat{u}_{-1}, \\hat{u}_{1}, \\hat{u}_{3}, D)$。\n$$ \\left(\\frac{1}{4}, \\frac{\\mathrm{i}}{2}, -\\frac{\\mathrm{i}}{2}, \\frac{1}{4}, 0\\right) $$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{4}  \\frac{\\mathrm{i}}{2}  -\\frac{\\mathrm{i}}{2}  \\frac{1}{4}  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "傅里叶谱方法的核心优势在于它将物理空间中复杂的微分运算转化为谱空间中简单的乘法运算。本实践将指导您使用计算效率极高的快速傅里叶变换（FFT）来实现这一核心操作——谱求导。通过编写代码计算函数导数并分析其误差，您将亲身体验到谱方法无与伦比的精度，并掌握其在计算中的具体实现。",
            "id": "3396179",
            "problem": "给定一个光滑的 $2\\pi$ 周期函数 $f$，在区间 $[0,2\\pi)$ 上的 $N$ 个等距网格点上采样。设网格为 $x_j = \\frac{2\\pi j}{N}$，其中 $j = 0,1,\\dots,N-1$，并将样本表示为 $f_j = f(x_j)$。目标是通过快速傅里叶变换 (FFT) 计算导数 $f'(x)$ 在网格点上的谱近似，然后使用 $L^2$ 误差和逐点（无穷）误差来量化其精度。\n\n从以下基本原理出发：\n- 对于一个光滑的 $2\\pi$ 周期函数 $f$，其复傅里叶级数为 $f(x) = \\sum_{k\\in\\mathbb{Z}} \\hat{f}_k e^{ikx}$，其中 $\\hat{f}_k$ 是傅里叶系数。物理空间中的微分对应于傅里叶空间中乘以 $ik$：$f'(x) = \\sum_{k\\in\\mathbb{Z}} (ik)\\hat{f}_k e^{ikx}$。\n- 离散傅里叶变换 (DFT) 将 $N$ 个等距样本 $\\{f_j\\}_{j=0}^{N-1}$ 映射到一组离散傅里叶模式，这些模式表示与采样网格和周期性一致的整数波数。逆离散傅里叶变换 (IDFT) 从这些模式重构网格点上的函数值。\n- 对于光滑周期函数，等距周期网格上的离散梯形法则以谱精度逼近连续 $L^2$ 范数。\n\n根据这些原理，推导出在网格点上计算谱导数的算法：\n1. 将 DFT 应用于 $\\{f_j\\}$ 以获得与整数波数 $k$ 相关的离散傅里叶模式。\n2. 将每个模式乘以 $ik$ 以表示傅里叶空间中的微分。\n3. 应用逆 DFT (IDFT) 返回物理空间，从而得到 $\\{f'(x_j)\\}$ 的谱近似。\n\n使用快速傅里叶变换 (FFT) 及其逆变换来实现此算法，以确保计算效率。显式构造与区间 $[0,2\\pi)$ 上由 FFT 引起的 DFT 排序一致的整数波数向量 $k$，并确保您的实现能正确处理 $N$ 的偶数值和奇数值。使用弧度作为角度单位。\n\n对于每个测试用例，计算：\n- $L^2$ 误差，定义为 $\\|e\\|_{L^2} \\approx \\left(\\sum_{j=0}^{N-1} |e_j|^2 \\,\\Delta x\\right)^{1/2}$，其中 $e_j = f'_{\\text{spec}}(x_j) - f'_{\\text{exact}}(x_j)$ 是 $x_j$ 处的逐点误差，并且 $\\Delta x = \\frac{2\\pi}{N}$。\n- 逐点（无穷）误差，定义为 $\\|e\\|_{\\infty} = \\max_{0\\le j\\le N-1} |e_j|$。\n\n您的程序必须为下面指定的每个测试用例计算这两个误差度量。在生成最终输出之前，将每个浮点误差四舍五入到 $8$ 位小数。\n\n测试套件（请严格使用这些函数和分辨率）：\n- 案例 1：$f_1(x) = \\sin(3x) + \\cos(5x)$，其中 $N=16$。\n- 案例 2：$f_1(x) = \\sin(3x) + \\cos(5x)$，其中 $N=64$。\n- 案例 3：$f_2(x) = \\exp(\\sin x)$，其中 $N=32$。\n- 案例 4：$f_2(x) = \\exp(\\sin x)$，其中 $N=128$。\n- 案例 5：$f_3(x) = \\sin(20x)$，其中 $N=32$。\n- 案例 6：$f_1(x) = \\sin(3x) + \\cos(5x)$，其中 $N=8$。\n\n对于每个案例，使用其精确导数：\n- $f_1'(x) = 3\\cos(3x) - 5\\sin(5x)$。\n- $f_2'(x) = \\cos(x)\\exp(\\sin x)$。\n- $f_3'(x) = 20\\cos(20x)$。\n\n所有三角函数参数均以弧度为单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且本身是一个包含 $L^2$ 误差和无穷误差（按此顺序）的双元素列表，两个误差值均四舍五入到 $8$ 位小数。例如，输出应类似于：`[[e21,einf1],[e22,einf2],...]`，不含空格。请确保结果的出现顺序与上面列出的案例 1 到 6 的顺序完全一致。",
            "solution": "本问题要求使用傅里叶谱方法计算一个光滑 $2\\pi$ 周期函数的导数，并量化该方法的精度。解决方案源于傅里叶分析的基本原理。\n\n谱方法的核心原理是，物理空间中的运算（如微分）对应于频率（或傅里叶）空间中更简单的代数运算。对于一个具有连续傅里叶级数表示的光滑 $2\\pi$ 周期函数 $f(x)$：\n$$\nf(x) = \\sum_{k \\in \\mathbb{Z}} \\hat{f}_k e^{ikx}\n$$\n其中 $\\hat{f}_k$ 是连续傅里叶系数，$k$ 是整数波数。对 $x$ 求导可得：\n$$\nf'(x) = \\frac{d}{dx} \\sum_{k \\in \\mathbb{Z}} \\hat{f}_k e^{ikx} = \\sum_{k \\in \\mathbb{Z}} (ik) \\hat{f}_k e^{ikx}\n$$\n这表明物理空间中的微分等价于将每个傅里叶系数 $\\hat{f}_k$ 乘以因子 $ik$。\n\n在计算环境中，我们处理的是函数的离散表示。函数 $f(x)$ 在区间 $[0, 2\\pi)$ 内的 $N$ 个点的均匀网格上进行采样：\n$$\nx_j = \\frac{2\\pi j}{N}, \\quad j = 0, 1, \\dots, N-1\n$$\n此网格上的函数值为 $f_j = f(x_j)$。傅里叶级数的离散模拟是离散傅里叶变换（DFT）。序列 $\\{f_j\\}_{j=0}^{N-1}$ 的 DFT 是一组 $N$ 个复系数，我们记为 $\\hat{f}^N$，通过快速傅里叶变换（FFT）算法计算：\n$$\n\\hat{f}^N_k = \\sum_{j=0}^{N-1} f_j e^{-i \\frac{2\\pi kj}{N}}, \\quad k = 0, 1, \\dots, N-1\n$$\n使用逆离散傅里叶变换（IDFT），通常通过逆快速傅里叶变换（IFFT）计算，可以从这些系数中完美重构原始函数值：\n$$\nf_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{f}^N_k e^{i \\frac{2\\pi kj}{N}} = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{f}^N_k e^{ik_{\\text{phys}}(k) x_j}\n$$\nDFT 输出的索引 $k$ 必须映射到其对应的物理整数波数，记为 $k_{\\text{phys}}(k)$。对于长度为 $N$ 的序列，DFT 系数对应的波数会被混叠到网格可分辨的范围内。标准的 FFT 库，如 NumPy 的库，按以下方式排序相应的整数波数：\n- 对于 $k = 0, \\dots, \\lfloor (N-1)/2 \\rfloor$：波数为 $0, 1, \\dots, \\lfloor (N-1)/2 \\rfloor$。\n- 对于 $k = \\lfloor (N-1)/2 \\rfloor + 1, \\dots, N-1$：波数为 $\\lfloor -N/2 \\rfloor, \\dots, -1$。\n标准库提供了生成这个波数向量（我们称之为 $k_{\\text{phys}}$）的稳健方法。\n\n为计算导数，我们将微分-乘法原理应用于离散系数：\n$$\n\\widehat{(f')}^N_k = (i k_{\\text{phys}}(k)) \\hat{f}^N_k\n$$\n对于偶数点数 $N$，存在一个关键的微妙之处。网格可以表示一个对应于奈奎斯特波数 $k = N/2$ 的频率分量。在网格点 $x_j$ 上，函数 $\\cos((N/2)x_j) = \\cos(\\pi j) = (-1)^j$。其解析导数是 $-(N/2)\\sin((N/2)x)$，在所有网格点上的值为 $-(N/2)\\sin(\\pi j) = 0$。为确保实值函数的数值导数也是实值，并与网格上函数的行为保持一致，奈奎斯特模式的导数通常被设置为零。这可以通过将波数向量 $k_{\\text{phys}}$ 中对应于奈奎斯特频率的分量设置为 $0$ 来实现。对于奇数点数 $N$，则不需要这样的特殊处理，因为不存在单一的奈奎斯特频率。\n\n计算谱导数 $\\{f'_{\\text{spec}}(x_j)\\}$ 的算法如下：\n1.  在网格 $\\{x_j\\}$ 上计算离散函数样本 $\\{f_j\\}$。\n2.  对 $\\{f_j\\}$ 应用 FFT 以获得离散傅里叶系数 $\\{\\hat{f}^N_k\\}$。\n3.  构造物理整数波数向量 $\\{k_{\\text{phys}}\\}$。对于偶数 $N$，将对应于奈奎斯特频率的元素设置为 $0$。\n4.  将傅里叶系数乘以 $ik_{\\text{phys}}$ 以获得导数的系数，即 $\\{\\widehat{(f')}^N_k\\} = \\{i k_{\\text{phys}}(k) \\hat{f}^N_k\\}$。\n5.  对 $\\{\\widehat{(f')}^N_k\\}$ 应用 IFFT 以在物理空间中获得谱导数值 $\\{f'_{\\text{spec}}(x_j)\\}$。结果应在机器精度内为实数；取实部可以舍弃由浮点误差引起的任何微小虚部。\n\n最后，为了评估精度，我们计算误差向量 $e_j = f'_{\\text{spec}}(x_j) - f'_{\\text{exact}}(x_j)$。精度通过两种范数进行量化：\n- 离散 $L^2$ 误差，它逼近连续 $L^2$ 范数：\n$$\n\\|e\\|_{L^2} \\approx \\left( \\sum_{j=0}^{N-1} |e_j|^2 \\Delta x \\right)^{1/2}\n$$\n其中网格间距为 $\\Delta x = 2\\pi/N$。\n- 逐点无穷误差，它衡量网格上的最大绝对误差：\n$$\n\\|e\\|_{\\infty} = \\max_{0 \\le j \\le N-1} |e_j|\n$$\n实现将把这个完整的过程应用于所提供的每个测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes spectral derivatives and errors for a suite of test cases.\n    \"\"\"\n\n    # Define the functions and their exact derivatives for the test cases.\n    def f1(x):\n        return np.sin(3 * x) + np.cos(5 * x)\n\n    def f1_prime(x):\n        return 3 * np.cos(3 * x) - 5 * np.sin(5 * x)\n\n    def f2(x):\n        return np.exp(np.sin(x))\n\n    def f2_prime(x):\n        return np.cos(x) * np.exp(np.sin(x))\n\n    def f3(x):\n        return np.sin(20 * x)\n\n    def f3_prime(x):\n        return 20 * np.cos(20 * x)\n\n    # Define the test cases as specified in the problem statement.\n    test_cases = [\n        {'N': 16, 'func': f1, 'deriv': f1_prime},\n        {'N': 64, 'func': f1, 'deriv': f1_prime},\n        {'N': 32, 'func': f2, 'deriv': f2_prime},\n        {'N': 128, 'func': f2, 'deriv': f2_prime},\n        {'N': 32, 'func': f3, 'deriv': f3_prime},\n        {'N': 8, 'func': f1, 'deriv': f1_prime},\n    ]\n\n    results_str = []\n    \n    for case in test_cases:\n        N = case['N']\n        f = case['func']\n        f_prime_exact_func = case['deriv']\n\n        # 1. Create the grid an sample the function.\n        # The domain is [0, 2*pi), so the grid is x_j = 2*pi*j / N.\n        x = np.arange(N) * (2 * np.pi / N)\n        f_values = f(x)\n        \n        # 2. Compute the FFT of the signal.\n        f_hat = np.fft.fft(f_values)\n\n        # 3. Construct the wavenumber vector for differentiation.\n        # numpy.fft.fftfreq(N) returns the unique sampling frequencies.\n        # We multiply by N to get the integer wavenumbers.\n        k = np.fft.fftfreq(N) * N\n        \n        # 4. Handle the Nyquist frequency for even N.\n        # For a real signal, the derivative of the Nyquist mode must be zero\n        # to ensure the derivative is real-valued.\n        if N % 2 == 0:\n            k[N // 2] = 0\n\n        # 5. Differentiate in Fourier space.\n        f_prime_hat = 1j * k * f_hat\n        \n        # 6. Apply inverse FFT to get the derivative in physical space.\n        f_prime_spec = np.fft.ifft(f_prime_hat)\n        \n        # The result must be real for a real input function. Take the real part\n        # to discard any small imaginary noise from floating-point inaccuracies.\n        f_prime_spec = np.real(f_prime_spec)\n        \n        # 7. Compute the exact derivative at the grid points.\n        f_prime_exact = f_prime_exact_func(x)\n        \n        # 8. Calculate the error vector.\n        error_vec = f_prime_spec - f_prime_exact\n        \n        # 9. Compute the L2 and infinity error norms.\n        delta_x = 2 * np.pi / N\n        l2_error = np.sqrt(np.sum(error_vec**2) * delta_x)\n        inf_error = np.max(np.abs(error_vec))\n\n        # 10. Format and store the results.\n        l2_error_str = f\"{l2_error:.8f}\"\n        inf_error_str = f\"{inf_error:.8f}\"\n        results_str.append(f\"[{l2_error_str},{inf_error_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了线性算子后，我们将注意力转向在计算流体力学中更为普遍的非线性问题。本练习以无粘伯格斯方程为模型，演示了伪谱方法在处理非线性项时面临的一个关键挑战：混叠误差（aliasing error）。您将通过实现并对比有混叠和无混叠（使用三分之二法则去混叠）的两种计算格式，深刻理解为何以及如何进行去混叠处理，以保证数值解的物理守恒性。",
            "id": "3396162",
            "problem": "考虑区间 $[0,2\\pi]$ 上的无粘性伯格斯方程的周期性初值问题，\n$$\nu_t(x,t) + u(x,t)\\,u_x(x,t) = 0, \\quad x \\in [0,2\\pi], \\quad t \\ge 0,\n$$\n其具有周期性边界条件和光滑初始条件 $u(x,0) = \\sin(x)$。连续 $L^2$ 能量\n$$\nE(t) = \\frac{1}{2}\\int_{0}^{2\\pi} u(x,t)^2 \\, dx\n$$\n对于激波形成前的足够光滑的解是守恒的。\n\n在傅里叶伪谱离散化中，非线性项 $u\\,u_x$ 的计算方法是：变换到物理空间，进行逐点相乘，然后变换回傅里叶空间。然而，离散卷积被截断为可用模态，这会引入混叠误差，从而破坏离散守恒性。一种常见的补救方法是使用三分之二法则进行去混叠，即在计算二次非线性时，对于具有 $N$ 个点的网格，将波数大小大于 $N/3$ 的所有傅里叶模态置零。\n\n您的任务是编写一个完整的、可运行的程序，该程序：\n- 用 $N$ 个等距点离散化空间域 $[0,2\\pi]$，并通过其离散傅里叶变换来表示 $u$。\n- 使用傅里叶伪谱方法计算空间导数，并为非线性项 $u\\,u_x$ 提供两种变体：\n  1. 混叠变体（不去混叠）：通过在物理空间中进行逐点相乘来计算 $u\\,u_x$，然后未经截断地变换回去。\n  2. 使用三分之二法则的去混叠变体：在形成非线性乘积之前，将场投影到 $|k|\\le N/3$ 的傅里叶模态上，在物理空间中计算乘积，并将得到的傅里叶变换结果投影回 $|k|\\le N/3$ 的模态上。\n- 使用具有固定时间步长 $\\Delta t$ 的显式四阶龙格-库塔方法将解在时间上推进到指定的最终时间 $T$。\n- 使用梯形法则（对于周期函数的等距采样是精确的）计算在时间 $t=0$ 和 $t=T$ 的离散 $L^2$ 能量，即\n$$\nE_{\\text{disc}}(t) = \\frac{1}{2}\\,\\Delta x \\sum_{j=0}^{N-1} u(x_j,t)^2,\n$$\n其中 $\\Delta x = 2\\pi/N$ 且 $x_j = j\\,\\Delta x$。\n- 对于每个测试用例，以无量纲单位的浮点数形式返回能量漂移 $E_{\\text{disc}}(T) - E_{\\text{disc}}(0)$。\n\n请将您的推导和实现建立在以下基本事实上：\n- 无粘性伯格斯方程 $u_t + u u_x = 0$ 在激波形成前具有连续能量守恒定律 $dE/dt = 0$。\n- 傅里叶变换将导数变为乘子：如果 $\\widehat{u}(k)$ 表示波数 $k$ 处的离散傅里叶系数，那么 $u_x$ 对应于在傅里叶空间中乘以 $\\mathrm{i}k$。\n- 两个场的伪谱乘积对应于傅里叶空间中的离散卷积，该卷积被截断到可分辨的模态，如果非线性相互作用产生了不可分辨的模态，则可能导致混叠。\n- 用于二次非线性的三分之二去混叠法则确保了两个截断谱的卷积不会混叠到可分辨频带中：在非线性乘积计算过程中， $|k| > N/3$ 的模态被置零。\n\n为确保科学真实性，请将最终时间严格保持在激波时间之前。对于 $u(x,0) = \\sin(x)$，激波时间为 $t_s = 1$，因为 $\\min_x u_x(x,0) = -1$。\n\n测试套件：\n使用以下参数集，其中每个测试用例是一个元组 $(N,T,\\text{dealias})$，$N$ 是网格点数，$T$ 是最终时间，$\\text{dealias}$ 是一个等于 \"none\" 或 \"2/3\" 的字符串，指示非线性计算的变体。\n- 测试 1 (理想情况，中等分辨率，存在混叠)：$(64,\\,0.5,\\,\\text{\"none\"})$。\n- 测试 2 (理想情况，中等分辨率，应用去混叠)：$(64,\\,0.5,\\,\\text{\"2/3\"})$。\n- 测试 3 (边缘情况，粗糙分辨率，存在混叠)：$(16,\\,0.5,\\,\\text{\"none\"})$。\n- 测试 4 (接近激波时间的边界情况，应用去混叠)：$(64,\\,0.95,\\,\\text{\"2/3\"})$。\n\n所有计算都是无量纲的。角度以弧度为单位。您的程序应生成单行输出，其中包含测试套件的能量漂移，形式为方括号内以逗号分隔的列表，例如，\n$$\n[\\delta E_1,\\delta E_2,\\delta E_3,\\delta E_4],\n$$\n其中每个 $\\delta E_i$ 等于相应测试用例的 $E_{\\text{disc}}(T)-E_{\\text{disc}}(0)$。这些值应以十进制浮点数输出。\n\n程序必须是独立自含的，使用快速傅里叶变换 (FFT)，并遵循为执行环境指定的约束。不允许外部输入，除上述无量纲规定外，不涉及任何物理单位。",
            "solution": "该问题要求在周期域 $x \\in [0, 2\\pi]$ 上，对具有初始条件 $u(x,0) = \\sin(x)$ 的无粘性伯格斯方程 $u_t + u u_x = 0$ 进行数值求解。该解将使用傅里叶伪谱方法获得，时间积分通过四阶龙格-库塔 (RK4) 方案执行。一个关键方面是通过实现非线性项 $u u_x$ 的两种变体来比较混叠误差对离散能量守恒的影响：一种没有混叠控制，另一种采用三分之二去混叠法则。\n\n该方法的核心是对偏微分方程 (PDE) 进行半离散化。我们用解 $u(x,t)$ 在任意时间 $t$ 于 $N$ 个等距点 $x_j = j \\Delta x$（其中 $\\Delta x = 2\\pi/N$，$j=0, 1, \\dots, N-1$）上的值来表示它。对于周期函数，这种空间表示在傅里叶空间中可以高效处理。设 $\\widehat{u}_k(t)$ 为 $u(x,t)$ 对应于波数 $k$ 的离散傅里叶系数。所有系数的集合 $\\{\\widehat{u}_k(t)\\}$ 构成了系统的状态。因此，PDE 被转换为关于这些系数的常微分方程组 (ODEs)：\n$$\n\\frac{d\\widehat{u}_k}{dt} = -\\mathcal{F}(u \\cdot u_x)_k\n$$\n其中 $\\mathcal{F}$ 表示离散傅里叶变换，下标 $k$ 表示括号内项的第 $k$ 个傅里叶系数。\n\n空间导数 $u_x$ 在傅里叶空间中精确计算。傅里叶变换的微分性质表明，实空间中的导数 $\\partial/\\partial x$ 对应于在傅里叶空间中乘以 $ik$，其中 $i = \\sqrt{-1}$，$k$ 是整数波数。在 $[0, 2\\pi]$ 上的 $N$ 点网格的波数由集合 $k \\in \\{0, \\pm 1, \\dots, \\pm(N/2-1), -N/2\\}$ 给出（对于偶数 $N$）。因此，导数的傅里叶系数 $\\widehat{(u_x)}_k$ 计算如下：\n$$\n\\widehat{(u_x)}_k = i k \\widehat{u}_k\n$$\n\n主要挑战在于计算非线性项 $u u_x$。在伪谱（或配置）方法中，这个乘积是在物理空间中逐点计算的。过程如下：\n1. 使用逆快速傅里叶变换 (IFFT) 将 $\\widehat{u}_k$ 和 $\\widehat{(u_x)}_k$ 变换到物理空间，以获得网格点值 $u(x_j)$ 和 $u_x(x_j)$。\n2. 计算逐点乘积 $p(x_j) = u(x_j) u_x(x_j)$。\n3. 使用快速傅里叶变换 (FFT) 将乘积变换回傅里叶空间，得到 $\\widehat{p}_k = \\mathcal{F}(p)_k$。\n\n这个过程会引入混叠误差。两个谱限于波数 $|k| \\le K_{max}$ 的函数的乘积，其结果的谱会扩展到 $|k| \\le 2K_{max}$。离散网格只能表示达到奈奎斯特极限 $|k| \\le N/2$ 的波数。任何超出此极限生成的谱内容都会被“折叠”回可分辨的波数上，从而污染傅里叶系数。这种现象被称为混叠，它破坏了连续卷积的性质，并导致不准确性，包括离散能量守恒的破坏。该算法的混叠变体直接实现此过程，不进行任何校正。\n\n为减轻混叠，应用了三分之二去混叠法则。对于像 $u u_x$ 这样的二次非线性，该法则可确保谱卷积不会导致环绕误差。这是通过在乘法前截断因子的傅里叶级数来实现的。具体来说，所有波数大小 $|k| > K_{cut} = \\lfloor N/3 \\rfloor$ 的模态都被置零。去混叠的过程是：\n1. 给定系数 $\\widehat{u}_k$，通过将所有 $|k| > N/3$ 的系数置零来创建一个滤波后的集合 $\\widehat{u}_{k, \\text{trunc}}$。\n2. 计算滤波后的导数系数：$\\widehat{(u_x)}_{k, \\text{trunc}} = i k \\widehat{u}_{k, \\text{trunc}}$。\n3. 将 $\\widehat{u}_{k, \\text{trunc}}$ 和 $\\widehat{(u_x)}_{k, \\text{trunc}}$ 都变换到物理空间，以获得 $u_{\\text{trunc}}(x_j)$ 和 $(u_x)_{\\text{trunc}}(x_j)$。\n4. 计算乘积 $p_{\\text{trunc}}(x_j) = u_{\\text{trunc}}(x_j) (u_x)_{\\text{trunc}}(x_j)$。\n5. 将此乘积变换回傅里叶空间，以获得 $\\widehat{p}_{\\text{trunc}, k}$。\n6. 作为最终投影，将所有 $|k| > N/3$ 的 $\\widehat{p}_{\\text{trunc}, k}$ 系数置零。结果是非线性项 $-\\mathcal{F}(u u_x)_k$ 的去混叠傅里叶表示。\n\n得到的 ODE 系统 $\\frac{d}{dt}\\widehat{U} = F(\\widehat{U})$（其中 $\\widehat{U}$ 是所有 $\\widehat{u}_k$ 的向量，$F$ 是右端函数，无论是否去混叠），使用经典的四阶龙格-库塔 (RK4) 方法在时间上推进。对于时间步长 $\\Delta t$，时间 $t_{n+1} = t_n + \\Delta t$ 的状态可以从时间 $t_n$ 的状态 $\\widehat{U}_n$ 通过以下方式求得：\n$$\n\\begin{aligned}\n    k_1 = F(\\widehat{U}_n) \\\\\n    k_2 = F(\\widehat{U}_n + \\frac{\\Delta t}{2} k_1) \\\\\n    k_3 = F(\\widehat{U}_n + \\frac{\\Delta t}{2} k_2) \\\\\n    k_4 = F(\\widehat{U}_n + \\Delta t k_3) \\\\\n    \\widehat{U}_{n+1} = \\widehat{U}_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\n选择一个小的固定时间步长 $\\Delta t=0.001$，以确保时间误差与正在研究的空间误差相比可以忽略不计。\n\n最后，在初始时间 $t=0$ 和最终时间 $t=T$ 计算离散 $L^2$ 能量。按照规定，这是通过在物理网格值上使用梯形法则完成的，该法则对于周期函数具有谱精度：\n$$\nE_{\\text{disc}}(t) = \\frac{1}{2}\\,\\Delta x \\sum_{j=0}^{N-1} u(x_j,t)^2\n$$\n能量漂移 $E_{\\text{disc}}(T) - E_{\\text{disc}}(0)$ 作为量化混叠和去混叠方案性能的度量。连续方程是能量守恒的，因此在一个完美的数值方案中，这个漂移应该为零。我们期望去混叠方案表现出显著更小的能量漂移。对于初始条件 $u(x,0)=\\sin(x)$，当 $N>2$ 时，离散初始能量恰好为 $E_{\\text{disc}}(0) = \\pi/2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, T, dealias_mode, dt):\n    \"\"\"\n    Solves the inviscid Burgers' equation using a Fourier pseudo-spectral method.\n\n    Args:\n        N (int): Number of grid points.\n        T (float): Final time.\n        dealias_mode (str): \"none\" for aliased, \"2/3\" for dealiased.\n        dt (float): Time step.\n\n    Returns:\n        float: The energy drift E(T) - E(0).\n    \"\"\"\n    # 1. Setup grid and initial conditions\n    L = 2.0 * np.pi\n    dx = L / N\n    x = np.arange(N) * dx\n    u0 = np.sin(x)\n    u_hat = np.fft.fft(u0)\n\n    # 2. Wavenumbers for spatial differentiation\n    # The factor N scales frequencies from cycles/sample to integer wavenumbers\n    k_vector = np.fft.fftfreq(N) * N\n\n    # 3. Calculate initial energy\n    E0 = 0.5 * dx * np.sum(u0**2)\n\n    # Pre-compute dealiasing mask if needed\n    high_freq_indices = None\n    if dealias_mode == \"2/3\":\n        k_cutoff = int(N / 3)\n        high_freq_indices = np.abs(k_vector) > k_cutoff\n\n    # 4. Define the RHS function for the ODE d(u_hat)/dt = F(u_hat)\n    def rhs(current_u_hat):\n        if dealias_mode == \"2/3\":\n            # Project field onto resolved modes\n            u_hat_trunc = current_u_hat.copy()\n            u_hat_trunc[high_freq_indices] = 0\n            \n            # Differentiate the truncated field\n            u_x_hat_trunc = 1j * k_vector * u_hat_trunc\n            \n            # Transform to physical space\n            u_trunc = np.fft.ifft(u_hat_trunc)\n            u_x_trunc = np.fft.ifft(u_x_hat_trunc)\n            \n            # Pointwise product of truncated fields\n            nonlinear_term = u_trunc * u_x_trunc\n            \n            # Transform product back to Fourier space\n            nonlinear_term_hat = np.fft.fft(nonlinear_term)\n            \n            # Project the result back onto resolved modes\n            nonlinear_term_hat[high_freq_indices] = 0\n            \n            return -nonlinear_term_hat\n        \n        else:  # \"none\" case (aliased)\n            # Differentiate in Fourier space\n            u_x_hat = 1j * k_vector * current_u_hat\n            \n            # Transform to physical space\n            u = np.fft.ifft(current_u_hat)\n            u_x = np.fft.ifft(u_x_hat)\n            \n            # Pointwise product\n            nonlinear_term = u * u_x\n            \n            # Transform product back to Fourier space\n            nonlinear_term_hat = np.fft.fft(nonlinear_term)\n            \n            return -nonlinear_term_hat\n\n    # 5. Time integration loop (RK4)\n    num_steps = int(round(T / dt))\n\n    for _ in range(num_steps):\n        k1 = rhs(u_hat)\n        k2 = rhs(u_hat + 0.5 * dt * k1)\n        k3 = rhs(u_hat + 0.5 * dt * k2)\n        k4 = rhs(u_hat + dt * k3)\n        u_hat += (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n    \n    # 6. Calculate final energy\n    u_final = np.fft.ifft(u_hat)\n    # The physical solution must be real; numerical errors introduce a small imaginary part.\n    E_final = 0.5 * dx * np.sum(np.real(u_final)**2)\n    \n    # 7. Compute and return drift\n    energy_drift = E_final - E0\n    return energy_drift\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, T, dealias_mode)\n        (64, 0.5, \"none\"),\n        (64, 0.5, \"2/3\"),\n        (16, 0.5, \"none\"),\n        (64, 0.95, \"2/3\"),\n    ]\n\n    # Fixed time step for all simulations to ensure stability and\n    # make temporal errors subdominant to spatial ones.\n    dt = 0.001\n\n    results = []\n    for case in test_cases:\n        N, T, dealias_mode = case\n        drift = run_simulation(N, T, dealias_mode, dt)\n        results.append(drift)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}