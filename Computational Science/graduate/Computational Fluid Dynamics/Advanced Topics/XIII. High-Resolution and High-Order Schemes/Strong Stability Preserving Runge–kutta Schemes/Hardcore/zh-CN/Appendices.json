{
    "hands_on_practices": [
        {
            "introduction": "强稳定性保持（SSP）方法的核心，在于它们可以被分解为一系列稳定的向前欧拉步骤的凸组合。本练习将带领您剖析一个高阶的SSP龙格-库塔格式，揭示其内在的构建原理，并从第一性原理出发推导其稳定性条件。通过这个过程，您将不仅仅是使用一个方案，而是真正理解其稳定性的来源。 ",
            "id": "3350094",
            "problem": "考虑在一周期性域上的一维线性平流方程 $u_{t} + a\\,u_{x} = 0$，该方程在间距为 $\\Delta x$ 的均匀网格上使用保守的一阶迎风有限体积法进行离散（对于 $a>0$）。在单元中心的半离散系统为\n$$\n\\frac{d u_{i}}{dt} \\;=\\; \\mathcal{N}(u)_i \\;=\\; -\\frac{a}{\\Delta x}\\left(u_{i} - u_{i-1}\\right).\n$$\n假设数值解使用标准的 Shu-Osher 形式的三阶段三阶强稳定性保持（SSP）Runge-Kutta（RK）方法进行时间推进。假设前向欧拉方法在时间步长限制 $\\Delta t \\le \\Delta t_{\\mathrm{FE}}$ 下是强稳定的（例如，在诸如总变差的凸单调性范数下非增），其中对于此空间离散 $\\Delta t_{\\mathrm{FE}} = \\Delta x/a$。\n\n仅从强稳定性保持（SSP）时间积分器是应用于半离散算子 $\\mathcal{N}(\\cdot)$ 的前向欧拉步长的凸组合这一基本定义出发，完成以下任务：\n\n1. 以 Shu-Osher 形式写出应用于 $\\dot{u}=\\mathcal{N}(u)$ 的三阶段三阶 SSP Runge-Kutta 格式。\n2. 将每个阶段重写为当前状态或使用相同时间步长 $\\Delta t$ 的前向欧拉更新的显式凸组合。\n3. 使用此表示和给定的前向欧拉强稳定性界限 $\\Delta t \\le \\Delta t_{\\mathrm{FE}}$，推导允许的最大 $\\Delta t$，以保证三阶段三阶 SSP Runge-Kutta 方法具有相同的强稳定性属性。\n4. 对于 $a = 1.7\\,\\mathrm{m/s}$ 和 $\\Delta x = 6.2 \\times 10^{-3}\\,\\mathrm{m}$，计算此允许的时间步长。\n\n以秒为单位表示最终允许的时间步长，并将您的答案四舍五入到四位有效数字。",
            "solution": "该问题要求从 SSP 方法的基本定义出发，推导应用于半离散系统的特定三阶段三阶强稳定性保持（SSP）Runge-Kutta 方法的强稳定性时间步长限制。\n\n首先对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **控制方程**：一维线性平流方程，$u_{t} + a\\,u_{x} = 0$，其中 $a > 0$。\n- **域与网格**：周期性域，间距为 $\\Delta x$ 的均匀网格。\n- **空间离散**：保守的一阶迎风有限体积近似。\n- **半离散系统**：$\\frac{d u_{i}}{dt} = \\mathcal{N}(u)_i = -\\frac{a}{\\Delta x}\\left(u_{i} - u_{i-1}\\right)$。\n- **时间积分器**：标准的 Shu-Osher 形式的三阶段三阶 SSP Runge-Kutta (SSP(3,3)) 方法。\n- **前向欧拉稳定性**：前向欧拉方法，$u^{n+1} = u^n + \\Delta t \\mathcal{N}(u^n)$，在其时间步长 $\\Delta t$ 满足 $\\Delta t \\le \\Delta t_{\\mathrm{FE}}$ 的条件下是强稳定的（例如，总变差非增），其中 $\\Delta t_{\\mathrm{FE}} = \\frac{\\Delta x}{a}$。\n- **数值**：$a = 1.7\\,\\mathrm{m/s}$ 和 $\\Delta x = 6.2 \\times 10^{-3}\\,\\mathrm{m}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于数值分析和计算流体力学中的标准、成熟概念，包括线性平流方程、有限体积法、迎风格式和 SSP Runge-Kutta 方法。其表述正确且物理上合理。\n- **适定性**：该问题是适定的。它提供了一套清晰的定义和一个已知的稳定方法（前向欧拉法）作为构建模块。任务是推导由这些模块构建的更复杂方法的稳定性极限，这将导出一个唯一且有意義的解。\n- **客观性**：该问题以精确、客观的数学语言陈述，没有歧义或主观看法。\n\n### 步骤 3：结论与行动\n该问题具有科学依据、适定、客观且自洽。因此，判定其为**有效**。将提供完整解答。\n\n### 解答推导\n\n解答过程遵循问题陈述中概述的四个步骤。\n\n**1. Shu-Osher 形式的 SSP(3,3) Runge-Kutta 格式**\n\n任务是将指定的时间积分器应用于一般的半离散常微分方程（ODE）系统 $\\frac{du}{dt} = \\mathcal{N}(u)$，其中 $u$ 代表单元中心值向量 $\\{u_i\\}$。标准的三阶段三阶 SSP Runge-Kutta 格式，通常表示为 SSP(3,3)，其 Shu-Osher 形式如下：\n$$u^{(0)} = u^n$$\n$$u^{(1)} = u^{(0)} + \\Delta t \\, \\mathcal{N}(u^{(0)})$$\n$$u^{(2)} = \\frac{3}{4} u^{(0)} + \\frac{1}{4} \\left( u^{(1)} + \\Delta t \\, \\mathcal{N}(u^{(1)}) \\right)$$\n$$u^{n+1} = \\frac{1}{3} u^{(0)} + \\frac{2}{3} \\left( u^{(2)} + \\Delta t \\, \\mathcal{N}(u^{(2)}) \\right)$$\n其中 $u^n$ 是在时间 $t_n$ 的解，$u^{n+1}$ 是在下一个时间层 $t_{n+1} = t_n + \\Delta t$ 的解。向量 $u^{(1)}$ 和 $u^{(2)}$ 代表中间阶段的值。\n\n**2. 将各阶段重写为前向欧拉步长的凸组合**\n\nSSP方法的基本原理是它们可以表示为前向欧拉步长的凸组合。一个方法是凸组合，如果它可以写成 $\\sum_{k} \\alpha_k \\mathcal{O}_k$ 的形式，其中算子 $\\mathcal{O}_k$ 本身是强稳定的，且系数满足 $\\alpha_k \\ge 0$ 和 $\\sum_k \\alpha_k = 1$。基础的稳定算子是前向欧拉（FE）步长。\n\n让我们定义时间步长为 $\\delta t$ 的前向欧拉算子为：\n$$E(w; \\delta t) = w + \\delta t \\, \\mathcal{N}(w)$$\n问题指出，该算子在某个凸半范数 $\\|\\cdot\\|$（例如，总变差 $\\|u\\|_{\\text{TV}} = \\sum_i |u_{i+1}-u_i|$）下是强稳定的，即 $\\|E(w; \\delta t)\\| \\le \\|w\\|$，前提是 $\\delta t \\le \\Delta t_{\\mathrm{FE}}$。\n\n我们现在使用这个算子来重写 SSP(3,3) 格式的每个阶段。\n\n*   **阶段 1：**\n    第一个阶段已经是应用于 $u^n = u^{(0)}$、时间步长为 $\\Delta t$ 的前向欧拉步长形式：\n    $$u^{(1)} = u^{(0)} + \\Delta t \\, \\mathcal{N}(u^{(0)}) = E(u^{(0)}; \\Delta t)$$\n    这是一个平凡的凸组合。为了使这一步稳定，我们必须有 $\\Delta t \\le \\Delta t_{\\mathrm{FE}}$。\n\n*   **阶段 2：**\n    第二个阶段是：\n    $$u^{(2)} = \\frac{3}{4} u^{(0)} + \\frac{1}{4} \\left( u^{(1)} + \\Delta t \\, \\mathcal{N}(u^{(1)}) \\right)$$\n    识别括号中的项为作用于 $u^{(1)}$、时间步长为 $\\Delta t$ 的前向欧拉步长，我们可以写出：\n    $$u^{(2)} = \\frac{3}{4} u^{(0)} + \\frac{1}{4} E(u^{(1)}; \\Delta t)$$\n    这个表达式将 $u^{(2)}$ 表示为状态 $u^{(0)}$ 和 $E(u^{(1)}; \\Delta t)$ 的凸组合，因为系数是非负的（$\\frac{3}{4} \\ge 0, \\frac{1}{4} \\ge 0$）且和为一（$\\frac{3}{4} + \\frac{1}{4} = 1$）。为了使整个阶段保持稳定性，算子 $E(u^{(1)}; \\Delta t)$ 必须是稳定的。这要求其时间步长 $\\Delta t$ 满足 $\\Delta t \\le \\Delta t_{\\mathrm{FE}}$。\n\n*   **阶段 3 (最终阶段)：**\n    最终阶段给出新解 $u^{n+1}$：\n    $$u^{n+1} = \\frac{1}{3} u^{(0)} + \\frac{2}{3} \\left( u^{(2)} + \\Delta t \\, \\mathcal{N}(u^{(2)}) \\right)$$\n    类似地，我们将括号中的项识别为作用于 $u^{(2)}$、时间步长为 $\\Delta t$ 的前向欧拉步长：\n    $$u^{n+1} = \\frac{1}{3} u^{(0)} + \\frac{2}{3} E(u^{(2)}; \\Delta t)$$\n    这将 $u^{n+1}$ 表示为 $u^{(0)}$ 和 $E(u^{(2)}; \\Delta t)$ 的凸组合，其系数是非负的（$\\frac{1}{3} \\ge 0, \\frac{2}{3} \\ge 0$）且和为一（$\\frac{1}{3} + \\frac{2}{3} = 1$）。为了使这一步保持稳定性，算子 $E(u^{(2)}; \\Delta t)$ 必须是稳定的，这要求其时间步长 $\\Delta t$ 满足 $\\Delta t \\le \\Delta t_{\\mathrm{FE}}$。\n\n**3. 推导允许的最大时间步长**\n\n整个 SSP(3,3) 方法的稳定性要求其结构内的每一个前向欧拉运算都是稳定的。我们分析了每个阶段，发现前向欧拉算子 $E$ 总是使用 Runge-Kutta 方法的完整时间步长 $\\Delta t$ 来应用。\n\n- 从阶段 1，我们要求 $\\Delta t \\le \\Delta t_{\\mathrm{FE}}$。\n- 从阶段 2，我们要求 $\\Delta t \\le \\Delta t_{\\mathrm{FE}}$。\n- 从阶段 3，我们要求 $\\Delta t \\le \\Delta t_{\\mathrm{FE}}$。\n\n为了同时满足所有这些条件，时间步长 $\\Delta t$ 必须受到这些约束中最严格的一个的限制。由于所有约束都是相同的，SSP(3,3) 方法的总体稳定性条件是：\n$$\\Delta t \\le \\Delta t_{\\mathrm{FE}}$$\n因此，允许的最大时间步长 $\\Delta t_{\\max}$ 等于前向欧拉稳定性极限：\n$$\\Delta t_{\\max} = \\Delta t_{\\mathrm{FE}}$$\n这个结果意味着这个特定的三阶 Runge-Kutta 格式的 SSP 系数是 $C=1$。\n\n**4. 计算允许的时间步长**\n\n问题给出了给定空间离散的前向欧拉稳定性极限的表达式：\n$$\\Delta t_{\\mathrm{FE}} = \\frac{\\Delta x}{a}$$\n因此，SSP(3,3) 方法允许的最大时间步长是：\n$$\\Delta t_{\\max} = \\frac{\\Delta x}{a}$$\n我们已知数值 $a = 1.7\\,\\mathrm{m/s}$ 和 $\\Delta x = 6.2 \\times 10^{-3}\\,\\mathrm{m}$。代入这些值，我们得到：\n$$\\Delta t_{\\max} = \\frac{6.2 \\times 10^{-3}\\,\\mathrm{m}}{1.7\\,\\mathrm{m/s}}$$\n$$\\Delta t_{\\max} \\approx 3.6470588... \\times 10^{-3}\\,\\mathrm{s}$$\n按照要求将结果四舍五入到四位有效数字：\n$$\\Delta t_{\\max} \\approx 3.647 \\times 10^{-3}\\,\\mathrm{s}$$",
            "answer": "$$\\boxed{3.647 \\times 10^{-3}}$$"
        },
        {
            "introduction": "理论上的稳定性保证在实践中意味着什么？本练习通过一个具体的数值实验来回答这个问题，您将实现并对比一个SSP和一个非SSP的二阶龙格-库塔方法。通过观察非SSP方法在较大时间步长下如何产生非物理的振荡并违反最大值原理，而SSP方法则能保持解的物理性，您将直观地体会到SSP属性的实际价值。 ",
            "id": "3287729",
            "problem": "考虑标量守恒律 $u_t + f(u)_x = 0$，定义在周期性一维域 $x \\in [0,1]$ 上。将空间域离散为 $N$ 个均匀单元，单元宽度为 $\\Delta x = 1/N$，并用 $u_j(t)$ 表示在时间 $t$ 时单元索引为 $j$ 的单元平均近似，索引具有周期性。使用带有单调数值通量 $\\hat{f}$ 的有限体积半离散化，使得半离散算子 $L(u)$ 按分量定义为\n$$\n\\left[L(u)\\right]_j = -\\frac{\\hat{f}_{j+1/2} - \\hat{f}_{j-1/2}}{\\Delta x}.\n$$\n令物理通量为 $f(u) = a\\,u$，其中 $a$ 为恒定的平流速度。使用局部Lax-Friedrichs通量，对于此线性通量，该通量简化为一阶迎风通量：\n- 若 $a > 0$，则设 $\\hat{f}_{j+1/2} = a\\,u_j$。\n- 若 $a < 0$，则设 $\\hat{f}_{j+1/2} = a\\,u_{j+1}$。\n这样可以得到一个单调的半离散算子。\n\n使用满足极值原理界的单单元脉冲初始化数据：\n$$\nu_j^0 = \\begin{cases}\n1  \\text{若 } j = j^\\star,\\\\\n0  \\text{其他情况},\n\\end{cases}\n$$\n其中 $j^\\star = \\lfloor N/2 \\rfloor$。\n\n通过 $r = \\frac{|a|\\,\\Delta t}{\\Delta x}$ 定义Courant-Friedrichs-Lewy数，并计算时间步长 $\\Delta t = r\\,\\frac{\\Delta x}{|a|}$。\n\n实现两种显式Runge-Kutta时间积分器，用于单个时间步：\n1. 显式中点法（二阶，非强稳定性保持）：\n   - 阶段1：$u^{(1)} = u^n + \\Delta t\\,L(u^n)$，\n   - 更新：$u^{n+1} = u^n + \\Delta t\\,L(u^{(1)})$。\n2. 强稳定性保持(SSP)二阶Runge-Kutta方法（霍恩法）：\n   - 阶段1：$u^{(1)} = u^n + \\Delta t\\,L(u^n)$，\n   - 阶段2：$\\tilde{u}^{(2)} = u^{(1)} + \\Delta t\\,L(u^{(1)})$，\n   - 更新：$u^{n+1} = \\tfrac{1}{2}\\,u^n + \\tfrac{1}{2}\\,\\tilde{u}^{(2)}$。\n\n对于下方的每个测试用例，从指定的初始数据和空间离散化开始，使用每个积分器精确执行一个时间步。对于每个得到的解 $u^{n+1}$，检验其是否满足初始界 $[0,1]$ 的极值原理：\n- 计算 $\\min_j u_j^{n+1}$ 和 $\\max_j u_j^{n+1}$。\n- 如果 $\\min_j u_j^{n+1} \\ge 0$ 且 $\\max_j u_j^{n+1} \\le 1$（对这些比较使用 $10^{-12}$ 的数值容差），则声明极值原理得以保持。\n\n测试套件：\n- 所有测试均使用 $N = 100$ 和 $j^\\star = \\lfloor N/2 \\rfloor$。\n- 考虑以下 $(a,r)$ 对：\n  1. $(a,r) = (1.0, 0.25)$，\n  2. $(a,r) = (1.0, 0.50)$，\n  3. $(a,r) = (1.0, 0.60)$，\n  4. $(a,r) = (1.0, 0.95)$，\n  5. $(a,r) = (-1.0, 0.60)$，\n  6. $(a,r) = (1.0, 1.05)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为结果。每个测试用例对应两个布尔条目，分别表示显式中点法和强稳定性保持(SSP)二阶Runge-Kutta方法是否保持极值原理。最终输出必须严格按照测试套件和方法配对的顺序，即：\n$$\n\\left[\\text{MP}_{\\text{midpoint},1},\\text{MP}_{\\text{SSP2},1},\\text{MP}_{\\text{midpoint},2},\\text{MP}_{\\text{SSP2},2},\\ldots,\\text{MP}_{\\text{midpoint},6},\\text{MP}_{\\text{SSP2},6}\\right],\n$$\n其中 $\\text{MP}_{\\text{method},k}$ 是第 $k$ 个测试用例和指定方法的布尔结果。不涉及物理单位；所有量均为无量纲。",
            "solution": "该问题要求分析两种不同的二阶显式Runge-Kutta时间积分方案应用于半离散线性平流方程时的极值原理保持特性。此分析将通过实现这些方案并用一套参数对其进行测试来完成。\n\n控制偏微分方程是标量线性平流方程，这是守恒律的一种特定形式：\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0\n$$\n其中物理通量函数为 $f(u) = a\\,u$，$a$ 是恒定的平流速度。空间域为 $x \\in [0,1]$，采用周期性边界条件。\n\n该域被离散为 $N$ 个宽度为 $\\Delta x = 1/N$ 的均匀单元。每个单元 $j$ 内的解由其单元平均值 $u_j(t)$ 表示。使用有限体积法得到的方程的半离散形式为：\n$$\n\\frac{du_j}{dt} = L(u)_j = -\\frac{\\hat{f}_{j+1/2} - \\hat{f}_{j-1/2}}{\\Delta x}\n$$\n其中 $\\hat{f}_{j+1/2}$ 是单元 $j$ 和单元 $j+1$ 之间界面上的数值通量。问题指定了依赖于平流速度 $a$ 符号的一阶迎风通量。\n\n情况1：$a > 0$（向右平流）\n界面 $j+1/2$ 处的通量由上游单元（即单元 $j$）的值确定。\n$$\n\\hat{f}_{j+1/2} = a\\,u_j\n$$\n单元 $j$ 的半离散算子变为：\n$$\nL(u)_j = -\\frac{a\\,u_j - a\\,u_{j-1}}{\\Delta x} = -\\frac{a}{\\Delta x}(u_j - u_{j-1})\n$$\n\n情况2：$a < 0$（向左平流）\n界面 $j+1/2$ 处的通量由上游单元（即单元 $j+1$）的值确定。\n$$\n\\hat{f}_{j+1/2} = a\\,u_{j+1}\n$$\n单元 $j$ 的半离散算子变为：\n$$\nL(u)_j = -\\frac{a\\,u_{j+1} - a\\,u_j}{\\Delta x} = -\\frac{a}{\\Delta x}(u_{j+1} - u_j)\n$$\n\n时间步长 $\\Delta t$ 通过Courant-Friedrichs-Lewy (CFL) 数 $r$ 定义：\n$$\nr = \\frac{|a|\\,\\Delta t}{\\Delta x} \\implies \\Delta t = r \\frac{\\Delta x}{|a|}\n$$\n在时间步进格式中出现了 $\\Delta t \\, L(u)$ 这一项。我们可以简化此项。\n\n对于 $a > 0$，有 $|a|=a$：\n$$\n\\Delta t\\, L(u)_j = \\left(r \\frac{\\Delta x}{a}\\right) \\left(-\\frac{a}{\\Delta x}(u_j - u_{j-1})\\right) = -r(u_j - u_{j-1}) = r(u_{j-1} - u_j)\n$$\n\n对于 $a < 0$，有 $|a|=-a$：\n$$\n\\Delta t\\, L(u)_j = \\left(r \\frac{\\Delta x}{-a}\\right) \\left(-\\frac{a}{\\Delta x}(u_{j+1} - u_j)\\right) = r(u_{j+1} - u_j)\n$$\n这些表达式可以使用带有周期性移位的向量运算高效实现，`numpy.roll` 非常适合此目的。\n\n初始条件是一个离散脉冲：当 $j=j^\\star = \\lfloor N/2 \\rfloor$ 时 $u_j^0 = 1$，否则 $u_j^0=0$。初始数据位于区间 $[0,1]$ 内。如果下一个时间步的解 $u_j^{n+1}$ 对所有 $j$ 也保持在这些界限内，即 $0 \\le u_j^{n+1} \\le 1$，则称极值原理得以保持。此检查使用 $10^{-12}$ 的数值容差。\n\n我们现在实现指定的两种Runge-Kutta格式，用于从 $u^n = u^0$ 到 $u^{n+1}$ 的单个时间步。\n\n1.  **显式中点法**（如问题中所定义）：\n    - 阶段1：$u^{(1)} = u^n + \\Delta t\\,L(u^n)$\n    - 更新：$u^{n+1} = u^n + \\Delta t\\,L(u^{(1)})$\n    该方法具有二阶精度，但通常不是强稳定性保持(SSP)的。对于迎风半离散化，它仅在严格的CFL条件下（理论上为 $r \\le 0.5$）才保持极值原理。\n\n2.  **强稳定性保持(SSP)二阶Runge-Kutta方法（霍恩法）**（如问题中所定义）：\n    - 阶段1：$u^{(1)} = u^n + \\Delta t\\,L(u^n)$\n    - 阶段2：$\\tilde{u}^{(2)} = u^{(1)} + \\Delta t\\,L(u^{(1)})$\n    - 更新：$u^{n+1} = \\tfrac{1}{2}\\,u^n + \\tfrac{1}{2}\\,\\tilde{u}^{(2)}$\n    该方法可以解释为初始状态与应用两个向前欧拉步长后的状态的凸组合。对于此半离散化，如果 $r \\le 1$，则向前欧拉法是保持极值原理的。由于此SSP格式是保持极值原理的操作（在 $r \\le 1$ 条件下）的凸组合，因此整个格式在相同的条件 $r \\le 1$ 下也保持极值原理。\n\n求解过程如下：对于测试套件中的每个 $(a, r)$ 对，我们初始化状态向量 $u^0$。然后，对于两种时间积分器中的每一种，我们计算一个时间步后的状态 $u^{n+1}$。接着我们检查所得向量 $u^{n+1}$ 的最小值和最大值是否在 $[0,1]$ 范围内（带容差）。对于每种方法和每个测试用例，收集布尔结果（True表示保持，False表示违反）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of checking maximum principle preservation for two RK methods.\n    \"\"\"\n    # Define problem parameters\n    N = 100\n    # j_star needs to be an integer for array indexing\n    j_star = int(np.floor(N / 2))\n    # Numerical tolerance for checking the maximum principle\n    tol = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, r) pairs\n        (1.0, 0.25),\n        (1.0, 0.50),\n        (1.0, 0.60),\n        (1.0, 0.95),\n        (-1.0, 0.60),\n        (1.0, 1.05),\n    ]\n\n    results = []\n\n    # Define the operator L_op(u, a, r) which computes delta_t * L(u).\n    # This operator directly uses the CFL number r.\n    def apply_L_times_dt(u, a, r):\n        \"\"\"\n        Applies the semi-discrete operator multiplied by the time step.\n        L(u) = - (f_j+1/2 - f_j-1/2) / dx\n        delta_t * L(u) is computed using the CFL number r.\n        \"\"\"\n        if a > 0:\n            # Upwind flux for positive advection (a > 0)\n            # Stencil uses u_j and u_{j-1}. np.roll(u, 1) gets u_{j-1}.\n            return r * (np.roll(u, 1) - u)\n        else: # a < 0\n            # Upwind flux for negative advection (a  0)\n            # Stencil uses u_j and u_{j+1}. np.roll(u, -1) gets u_{j+1}.\n            return r * (np.roll(u, -1) - u)\n\n    # Define a helper function to check the maximum principle.\n    def check_mp(u, tolerance):\n        \"\"\"\n        Checks if the solution u respects the maximum principle bounds [0, 1].\n        \"\"\"\n        min_u = np.min(u)\n        max_u = np.max(u)\n        # The condition is that all values u_j must be in [0, 1].\n        # We use a tolerance for floating-point comparisons.\n        is_preserved = (min_u = -tolerance) and (max_u = 1.0 + tolerance)\n        return is_preserved\n\n    # Main loop over test cases\n    for a, r in test_cases:\n        # Initialize the data with a single-cell spike\n        u0 = np.zeros(N, dtype=float)\n        u0[j_star] = 1.0\n\n        # 1. Explicit Midpoint Method\n        # Stage 1: u^(1) = u^n + dt*L(u^n)\n        u1_mid = u0 + apply_L_times_dt(u0, a, r)\n        # Update: u^{n+1} = u^n + dt*L(u^(1))\n        u_final_mid = u0 + apply_L_times_dt(u1_mid, a, r)\n        results.append(check_mp(u_final_mid, tol))\n\n        # 2. Strong Stability Preserving (SSP) Runge-Kutta method of order two\n        # Stage 1: u^(1) = u^n + dt*L(u^n)\n        u1_ssp = u0 + apply_L_times_dt(u0, a, r)\n        # Stage 2: u_tilde^(2) = u^(1) + dt*L(u^(1))\n        u2_tilde_ssp = u1_ssp + apply_L_times_dt(u1_ssp, a, r)\n        # Update: u^{n+1} = 0.5*u^n + 0.5*u_tilde^(2)\n        u_final_ssp = 0.5 * u0 + 0.5 * u2_tilde_ssp\n        results.append(check_mp(u_final_ssp, tol))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在真实的计算流体动力学模拟中，稳定性不仅取决于时间积分格式，还与空间离散，特别是边界条件的处理方式密切相关。本练习揭示了一个常见的陷阱：即便是使用了理论上稳定的SSP时间积分器，不恰当的边界处理也可能破坏整体方案的稳定性（如总变差不增性质）。通过对比不同的边界条件实现方式，您将学会如何确保边界处理与SSP格式协同工作，以维持数值解的健壮性。 ",
            "id": "3366853",
            "problem": "考虑一维线性平流方程 $u_t + a u_x = 0$，其中平流速度 $a  0$ 为常数，该方程在一个包含 $N$ 个单元的均匀网格上进行离散化，单元间距为 $\\Delta x = 1/N$，索引从 $i=0$ 到 $i=N-1$，并且对于 $a0$ 有一个入流边界条件 $u(0,t) = u_{\\mathrm{in}}(t)$。对于 $a0$，定义半离散守恒迎风通量 $f_{i+1/2} = a u_i$，以及半离散算子 $L$，其逐分量作用方式为 $L_i(u) = -\\frac{1}{\\Delta x}\\left(f_{i+1/2} - f_{i-1/2}\\right)$（对于 $0 \\le i \\le N-1$），其中入流边界单元面通量为 $f_{-1/2} = a u_{\\mathrm{in}}(t)$，出流边界单元面通量为 $f_{N-1/2} = a u_{N-1}$。设向量 $u \\in \\mathbb{R}^N$ 的全变分通过一个入流扩展向量进行评估：\n$$\nTV_{\\mathrm{ext}}(u;u_{\\mathrm{in}}) = \\sum_{i=-1}^{N-2} \\left|u_{i+1} - u_i\\right|, \\quad \\text{其中 } u_{-1} = u_{\\mathrm{in}} \\text{ 且 } u_i \\text{ 表示单元 } i \\text{ 处的网格函数。}\n$$\n假设采用三阶三步强稳定性保持Runge–Kutta方法 (SSPRK(3,3))，时间步长为 $\\Delta t$，满足每个测试用例中给出的 Courant–Friedrichs–Lewy 数 $\\lambda = a \\Delta t / \\Delta x$。\n\n目标是通过显式计算来证明，即使内部算子是单调的，非守恒的边界处理也可能在强稳定性保持 Runge-Kutta 格式下破坏全变分稳定性。具体来说，您需要在一个 SSPRK(3,3) 时间步内实现并比较以下入流边界离散化方法：\n- 每个阶段使用守恒通量边界：在计算所有阶段的 $L(u)$ 时，始终使用 $f_{-1/2} = a u_{\\mathrm{in}}$。\n- 末阶狄利克雷钳位（非守恒）：在所有阶段计算 $L(u)$ 时使用 $f_{-1/2} = a u_0$（即 $u_0$ 的常微分方程中净边界通量为零），然后在完成三步 SSPRK 更新后，设置 $u_0 \\leftarrow u_{\\mathrm{in}}$。\n- 末阶过冲源（非守恒）：与前一项类似，但在最终 SSPRK 更新后，使用固定的过冲参数 $\\beta = 1.5$ 设置 $u_0 \\leftarrow u_0 + \\beta\\,(u_{\\mathrm{in}} - u_0)$。\n- 为恢复全变分控制而提出的边界阶段更新：在每个阶段使用守恒通量边界（在时间积分器的每个阶段中一致地处理入流边界）。\n\n您必须为以下包含参数值和初始数据的测试套件实现单步 SSPRK(3,3)。在所有情况下，$a$ 都是无量纲的，结果是无量纲浮点数：\n- 测试用例 A（接近稳定性极限的理想路径）：$N=50$，$a=1$，$\\lambda=1.0$，$u_{\\mathrm{in}}=1$，初始条件为对所有 $i$，$u_i^n=0$。\n- 测试用例 B（远离边界的内部间断）：$N=50$，$a=1$，$\\lambda=1.0$，$u_{\\mathrm{in}}=0$，初始条件为当 $i \\ge \\lfloor N/3 \\rfloor$ 时 $u_i^n=1$，否则 $u_i^n=0$。\n- 测试用例 C（更小的时间步长）：$N=50$，$a=1$，$\\lambda=0.5$，$u_{\\mathrm{in}}=1$，初始条件为对所有 $i$，$u_i^n=0$。\n\n对于每个测试用例，计算在单个 SSPRK(3,3) 时间步内入流扩展全变分的变化量，\n$$\n\\Delta TV = TV_{\\mathrm{ext}}(u^{n+1};u_{\\mathrm{in}}) - TV_{\\mathrm{ext}}(u^{n};u_{\\mathrm{in}}),\n$$\n对于上面列出的四种边界离散化方法，顺序如下：守恒法、末阶钳位法、使用 $\\beta=1.5$ 的末阶过冲源法以及建议的修复方法。您的程序应生成单行输出，其中包含所有测试用例的结果，形式为用方括号括起来的逗号分隔列表，即\n$$\n[\\Delta TV_{A,\\mathrm{cons}},\\Delta TV_{A,\\mathrm{clamp}},\\Delta TV_{A,\\mathrm{over}},\\Delta TV_{A,\\mathrm{fix}},\\Delta TV_{B,\\mathrm{cons}},\\Delta TV_{B,\\mathrm{clamp}},\\Delta TV_{B,\\mathrm{over}},\\Delta TV_{B,\\mathrm{fix}},\\Delta TV_{C,\\mathrm{cons}},\\Delta TV_{C,\\mathrm{clamp}},\\Delta TV_{C,\\mathrm{over}},\\Delta TV_{C,\\mathrm{fix}}].\n$$\n所有量均为无量纲浮点数。最后一行必须只包含这个方括号括起来的列表，不得有任何额外文本。",
            "solution": "用户提供的问题被评估为有效。它在偏微分方程数值分析领域具有科学依据，特别关注双曲守恒律数值格式的稳定性。该问题是适定的、客观的，并包含了进行唯一、可验证的计算求解所需的所有必要信息。其目标是展示在使用强稳定性保持（SSP）时间积分器时，非守恒边界条件处理存在的一个已知问题，这是高等计算流体动力学中的一个标准课题。\n\n求解过程如下：\n首先，我们建立数学框架。问题考虑的是一维线性平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\n其中 $u(x, t)$ 是一个标量，而 $a  0$ 是一个恒定的平流速度。这个偏微分方程（PDE）在一个包含 $N$ 个单元且单元间距为 $\\Delta x$ 的均匀网格上进行空间半离散化。这产生了一个常微分方程组（ODEs），形式如下：\n$$\n\\frac{d\\mathbf{u}}{dt} = L(\\mathbf{u})\n$$\n其中 $\\mathbf{u}(t) \\in \\mathbb{R}^N$ 是单元平均值 $u_i(t)$ 的向量，$L$ 是空间离散算子。问题使用守恒有限体积公式和一阶迎风通量来定义 $L$。算子 $L$ 作用于 $\\mathbf{u}$ 的第 $i$ 个分量为：\n$$\nL_i(\\mathbf{u}) = -\\frac{1}{\\Delta x} \\left( f_{i+1/2} - f_{i-1/2} \\right)\n$$\n单元交界面上的数值通量 $f_{i+1/2}$ 由 $a  0$ 时的迎风偏置公式给出：$f_{i+1/2} = a u_i$。出流边界通量为 $f_{N-1/2} = a u_{N-1}$，这与内部迎风通量一致。$i=-1/2$ 面上的入流通量 $f_{-1/2}$ 取决于边界条件的处理方式。这导致了算子 $L$ 的逐分量定义：\n$$\nL_0(\\mathbf{u}) = -\\frac{1}{\\Delta x}(a u_0 - f_{-1/2})\n$$\n$$\nL_i(\\mathbf{u}) = -\\frac{a}{\\Delta x}(u_i - u_{i-1}) \\quad \\text{对于 } 1 \\leq i \\leq N-1\n$$\n该常微分方程组使用三阶三步强稳定性保持 Runge-Kutta 格式（SSPRK(3,3)）进行时间积分。给定时间 $t_n$ 的解 $\\mathbf{u}^n$，时间 $t_{n+1} = t_n + \\Delta t$ 的解通过以下方式计算：\n$$\n\\begin{aligned}\n\\mathbf{u}^{(1)} = \\mathbf{u}^n + \\Delta t L(\\mathbf{u}^n) \\\\\n\\mathbf{u}^{(2)} = \\frac{3}{4} \\mathbf{u}^n + \\frac{1}{4} \\left( \\mathbf{u}^{(1)} + \\Delta t L(\\mathbf{u}^{(1)}) \\right) \\\\\n\\mathbf{u}^{n+1} = \\frac{1}{3} \\mathbf{u}^n + \\frac{2}{3} \\left( \\mathbf{u}^{(2)} + \\Delta t L(\\mathbf{u}^{(2)}) \\right)\n\\end{aligned}\n$$\n解的稳定性由其全变分（TV）来衡量。问题定义了一个入流扩展全变分，它考虑了边界处的跳跃：\n$$\nTV_{\\mathrm{ext}}(\\mathbf{u}; u_{\\mathrm{in}}) = \\sum_{i=-1}^{N-2} |u_{i+1} - u_i| = |u_0 - u_{\\mathrm{in}}| + \\sum_{i=0}^{N-2} |u_{i+1} - u_i|\n$$\n其中 $u_{-1}$ 被取为入流边界值 $u_{\\mathrm{in}}$。如果 $TV(\\mathbf{u}^{n+1}) \\le TV(\\mathbf{u}^n)$，则数值格式是全变分递减（TVD）的。SSP 格式被设计为，在给定的 Courant–Friedrichs–Lewy (CFL) 数约束 $\\lambda = a \\Delta t / \\Delta x \\le 1$ 下，如果前向欧拉步 $\\mathbf{u}' = \\mathbf{u} + \\Delta t L(\\mathbf{u})$ 是 TVD 的，那么该 SSP 格式也是 TVD 的。\n\n问题的核心是比较实现入流边界条件的四种不同方法：\n\n1.  **守恒通量边界**：在所有 RK 阶段，使用给定的边界值一致地设置入流通量：$f_{-1/2} = a u_{\\mathrm{in}}$。这是为 TVD 格式实现边界条件的标准、正确的方法。因此，算子 $L$ 依赖于 $u_{\\mathrm{in}}$。\n\n2.  **末阶狄利克雷钳位**：在 RK 阶段，入流通量的计算如同存在零梯度边界条件一样，$f_{-1/2} = a u_0$。这使得第一个单元的常微分方程变为 $du_0/dt = 0$，从而使其与边界解耦。在完成整个 SSPRK 步骤以找到一个临时解 $\\mathbf{u}^*$ 后，通过直接设置 $u_0^{n+1} = u_{\\mathrm{in}}$ 来“钳位”边界值。这个过程是非守恒的。\n\n3.  **末阶过冲源**：这与钳位法类似。RK 阶段使用 $f_{-1/2} = a u_0$ 进行积分。在获得临时解 $\\mathbf{u}^*$ 后，边界单元通过一个源项进行更新：$u_0^{n+1} = u_0^* + \\beta(u_{\\mathrm{in}} - u_0^*)$，其中 $\\beta=1.5$。这也是非守恒的，并且当 $\\beta1$ 时，会有意地引入一个过冲。\n\n4.  **建议的修复方法**：该方法是对守恒通量边界方法的重述。它作为“正确”的参考，表明对于非守恒边界问题的修复方法是在时间积分器的每个阶段内守恒且一致地应用边界数据。\n\n对于三个测试用例中的每一个，我们将初始化状态向量 $\\mathbf{u}^n$，计算其初始扩展全变分 $TV_{\\mathrm{ext}}(\\mathbf{u}^n; u_{\\mathrm{in}})$，对四种边界方法中的每一种应用单个 SSPRK(3,3) 时间步以获得四个不同的 $\\mathbf{u}^{n+1}$ 向量，计算它们各自的最终扩展全变分 $TV_{\\mathrm{ext}}(\\mathbf{u}^{n+1}; u_{\\mathrm{in}})$，并报告变化量 $\\Delta TV = TV_{\\mathrm{ext}}(\\mathbf{u}^{n+1}) - TV_{\\mathrm{ext}}(\\mathbf{u}^n)$。\n实现将遵循此逻辑，遍历测试用例和边界方法以计算所需的十二个 $\\Delta TV$ 值。结果预期将显示，对于守恒方法，$\\Delta TV \\le 0$，而对于非守恒方法，可能会有 $\\Delta TV  0$，这表明稳定性的丧失和伪振荡的产生。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the change in total variation for different\n    boundary condition treatments for the 1D linear advection equation.\n    \"\"\"\n\n    test_cases = [\n        # Test Case A\n        {'N': 50, 'a': 1.0, 'lambda': 1.0, 'u_in': 1.0, 'u_n': np.zeros(50)},\n        # Test Case B\n        {'N': 50, 'a': 1.0, 'lambda': 1.0, 'u_in': 0.0, 'u_n': np.array([0.0 if i  50 // 3 else 1.0 for i in range(50)])},\n        # Test Case C\n        {'N': 50, 'a': 1.0, 'lambda': 0.5, 'u_in': 1.0, 'u_n': np.zeros(50)}\n    ]\n\n    boundary_methods = [\n        'conservative',\n        'final_stage_clamp',\n        'final_stage_overshoot',\n        'proposed_fix'\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        N = case['N']\n        a = case['a']\n        lambda_cfl = case['lambda']\n        u_in = case['u_in']\n        u_n = case['u_n']\n        \n        delta_x = 1.0 / N\n        delta_t = lambda_cfl * delta_x / a\n\n        def get_L_operator(u, bc_flux_val):\n            \"\"\"Computes the semi-discrete operator L(u).\"\"\"\n            L = np.zeros(N)\n            L[0] = -(a * u[0] - bc_flux_val) / delta_x\n            if N  1:\n                L[1:] = -a * (u[1:] - u[:-1]) / delta_x\n            return L\n\n        def tv_ext(u, u_in_val):\n            \"\"\"Computes the inflow-extended total variation.\"\"\"\n            u_extended = np.concatenate(([u_in_val], u))\n            return np.sum(np.abs(np.diff(u_extended)))\n\n        tv_initial = tv_ext(u_n, u_in)\n\n        for method in boundary_methods:\n            # --- SSPRK(3,3) Integration ---\n            \n            # Stage 1\n            if method in ['conservative', 'proposed_fix']:\n                f_mhalf_n = a * u_in\n            else: # clamp or overshoot\n                f_mhalf_n = a * u_n[0]\n            \n            L_n = get_L_operator(u_n, f_mhalf_n)\n            u_1 = u_n + delta_t * L_n\n\n            # Stage 2\n            if method in ['conservative', 'proposed_fix']:\n                f_mhalf_1 = a * u_in\n            else:\n                f_mhalf_1 = a * u_1[0]\n                \n            L_1 = get_L_operator(u_1, f_mhalf_1)\n            u_2 = 0.75 * u_n + 0.25 * u_1 + 0.25 * delta_t * L_1\n            \n            # Stage 3\n            if method in ['conservative', 'proposed_fix']:\n                f_mhalf_2 = a * u_in\n            else:\n                f_mhalf_2 = a * u_2[0]\n\n            L_2 = get_L_operator(u_2, f_mhalf_2)\n            u_np1_star = (1.0/3.0) * u_n + (2.0/3.0) * (u_2 + delta_t * L_2)\n            \n            u_np1 = u_np1_star.copy()\n\n            # --- Final boundary adjustment for non-conservative methods ---\n            if method == 'final_stage_clamp':\n                u_np1[0] = u_in\n            elif method == 'final_stage_overshoot':\n                beta = 1.5\n                u_np1[0] = u_np1_star[0] + beta * (u_in - u_np1_star[0])\n            \n            # --- Calculate and store Delta TV ---\n            tv_final = tv_ext(u_np1, u_in)\n            delta_tv = tv_final - tv_initial\n            all_results.append(delta_tv)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}