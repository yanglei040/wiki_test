{
    "hands_on_practices": [
        {
            "introduction": "为了掌握MUSCL重构的核心机制，我们首先从一个基础的计算练习开始。这项实践旨在通过一个简单、清晰的线性数据分布，让您亲手计算和比较两种经典的斜率限制器——minmod和van Leer——的结果。通过这个练习，您将直观地理解限制器函数如何处理平滑的数据剖面，并为后续更复杂的实现打下坚实的数学基础。 ",
            "id": "3347626",
            "problem": "考虑一维标量守恒律 $u_t + f(u)_x = 0$，其定义在由网格中心 $x_i$ 和网格界面 $x_{i \\pm 1/2}$ 构成的均匀网格上，网格间距为常数 $\\Delta x  0$。在有限体积法中，网格单元 $i$ 内的分段线性守恒律单调上游中心格式 (MUSCL) 重构为\n$$\nu_i(x) = \\bar u_i + \\sigma_i (x - x_i), \\quad x \\in [x_{i-1/2}, x_{i+1/2}],\n$$\n其中 $\\bar u_i$ 是网格平均值，$\\sigma_i$ 是由单边差商构造的被限制的斜率\n$$\ns_L = \\frac{\\bar u_i - \\bar u_{i-1}}{\\Delta x}, \\qquad s_R = \\frac{\\bar u_{i+1} - \\bar u_i}{\\Delta x}.\n$$\n从网格单元 $i$ 重构的左右界面状态为\n$$\nu_{i-1/2}^R = \\bar u_i - \\frac{1}{2}\\Delta x\\, \\sigma_i, \\qquad u_{i+1/2}^L = \\bar u_i + \\frac{1}{2}\\Delta x\\, \\sigma_i.\n$$\n考虑两种斜率限制器：\n1. minmod 限制器，定义为\n$$\n\\operatorname{minmod}(a,b) = \n\\begin{cases}\n\\phantom{-}\\min(|a|,|b|)\\,\\operatorname{sign}(a),  \\text{若 } a b  0,\\\\\n0,  \\text{其他情况},\n\\end{cases}\n$$\n且 $\\sigma_i^{\\mathrm{mm}} = \\operatorname{minmod}(s_L, s_R)$。\n2. van Leer 调和平均限制器，定义为\n$$\n\\phi_{\\mathrm{VL}}(a,b) = \n\\begin{cases}\n\\dfrac{2 a b}{a + b},  \\text{若 } a b  0,\\\\\n0,  \\text{其他情况},\n\\end{cases}\n$$\n且 $\\sigma_i^{\\mathrm{vl}} = \\phi_{\\mathrm{VL}}(s_L, s_R)$。\n\n给定数据 $\\bar u_{i-1} = 1$，$\\bar u_i = 2$，$\\bar u_{i+1} = 3$，计算被限制的斜率 $\\sigma_i^{\\mathrm{mm}}$ 和 $\\sigma_i^{\\mathrm{vl}}$，以及每种限制器对应的界面值 $u_{i-1/2}^R$ 和 $u_{i+1/2}^L$。比较这些结果，并说明它们是否一致。以行向量 $(\\sigma_i^{\\mathrm{mm}}, \\sigma_i^{\\mathrm{vl}}, u_{i-1/2}^{R,\\mathrm{mm}}, u_{i+1/2}^{L,\\mathrm{mm}}, u_{i-1/2}^{R,\\mathrm{vl}}, u_{i+1/2}^{L,\\mathrm{vl}})$ 的形式（并按此顺序）报告你的最终答案。无需四舍五入。",
            "solution": "首先根据所需标准对问题陈述进行验证。\n\n### 第 1 步：提取已知条件\n- **守恒律**：$u_t + f(u)_x = 0$。\n- **网格**：由网格中心 $x_i$ 和界面 $x_{i \\pm 1/2}$ 构成的均匀网格，网格间距为常数 $\\Delta x  0$。\n- **网格单元 $i$ 内的 MUSCL 重构**：$u_i(x) = \\bar u_i + \\sigma_i (x - x_i)$，其中 $x \\in [x_{i-1/2}, x_{i+1/2}]$。\n- **单边差商**：$s_L = \\frac{\\bar u_i - \\bar u_{i-1}}{\\Delta x}$ 和 $s_R = \\frac{\\bar u_{i+1} - \\bar u_i}{\\Delta x}$。\n- **从网格单元 $i$ 重构的界面状态**：$u_{i-1/2}^R = \\bar u_i - \\frac{1}{2}\\Delta x\\, \\sigma_i$ 和 $u_{i+1/2}^L = \\bar u_i + \\frac{1}{2}\\Delta x\\, \\sigma_i$。\n- **Minmod 限制器**：$\\sigma_i^{\\mathrm{mm}} = \\operatorname{minmod}(s_L, s_R)$，其中 $\\operatorname{minmod}(a,b) = \\begin{cases} \\min(|a|,|b|)\\,\\operatorname{sign}(a),  \\text{若 } a b  0,\\\\ 0,  \\text{其他情况}。 \\end{cases}$\n- **Van Leer 限制器**：$\\sigma_i^{\\mathrm{vl}} = \\phi_{\\mathrm{VL}}(s_L, s_R)$，其中 $\\phi_{\\mathrm{VL}}(a,b) = \\begin{cases} \\dfrac{2 a b}{a + b},  \\text{若 } a b  0,\\\\ 0,  \\text{其他情况}。 \\end{cases}$\n- **数据**：给定的网格平均值为 $\\bar u_{i-1} = 1$，$\\bar u_i = 2$ 和 $\\bar u_{i+1} = 3$。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题是偏微分方程数值方法领域的一个标准练习，特别是在计算流体力学中。\n- **科学性**：该问题描述了守恒律的单调上游中心格式 (MUSCL)，这是一种成熟的二阶精度有限体积法。在此背景下，线性重构、单边差商以及 minmod 和 van Leer 斜率限制器的定义都是标准且正确的。\n- **适定性**：该问题是适定的。它提供了唯一计算所求量所需的所有必要数据和定义。该任务是所提供公式的直接应用。\n- **客观性**：语言精确且数学化，没有任何主观或模棱两可的陈述。\n- **完备性与一致性**：问题是自洽的。所提供的数据对于计算是一致且充分的。没有矛盾之处。\n\n### 第 3 步：结论与行动\n问题有效。将提供完整的解答。\n\n### 解答推导\n目标是根据给定的网格平均值数据 $\\bar u_{i-1} = 1$, $\\bar u_i = 2$ 和 $\\bar u_{i+1} = 3$，计算每种限制器下的被限制斜率 $\\sigma_i^{\\mathrm{mm}}$ 和 $\\sigma_i^{\\mathrm{vl}}$，以及对应的界面值 $u_{i-1/2}^R$ 和 $u_{i+1/2}^L$。\n\n首先，我们计算单边差商 $s_L$ 和 $s_R$。网格间距 $\\Delta x$ 是一个正常数。\n$$\ns_L = \\frac{\\bar u_i - \\bar u_{i-1}}{\\Delta x} = \\frac{2 - 1}{\\Delta x} = \\frac{1}{\\Delta x}\n$$\n$$\ns_R = \\frac{\\bar u_{i+1} - \\bar u_i}{\\Delta x} = \\frac{3 - 2}{\\Delta x} = \\frac{1}{\\Delta x}\n$$\n我们观察到流场数据在这三个网格单元上是线性的，这导致 $s_L = s_R$。\n\n接下来，我们使用 minmod 限制器计算被限制的斜率 $\\sigma_i^{\\mathrm{mm}}$。限制器的输入是 $a = s_L = \\frac{1}{\\Delta x}$ 和 $b = s_R = \\frac{1}{\\Delta x}$。因为 $\\Delta x  0$，我们有 $s_L  0$ 和 $s_R  0$，所以它们的乘积 $s_L s_R = \\frac{1}{(\\Delta x)^2}  0$。\n应用 minmod 限制器的定义：\n$$\n\\sigma_i^{\\mathrm{mm}} = \\operatorname{minmod}(s_L, s_R) = \\min(|s_L|, |s_R|)\\,\\operatorname{sign}(s_L)\n$$\n因为 $s_L = s_R = \\frac{1}{\\Delta x}$，这可以简化为：\n$$\n\\sigma_i^{\\mathrm{mm}} = \\min\\left(\\left|\\frac{1}{\\Delta x}\\right|, \\left|\\frac{1}{\\Delta x}\\right|\\right)\\,\\operatorname{sign}\\left(\\frac{1}{\\Delta x}\\right) = \\frac{1}{\\Delta x} \\cdot 1 = \\frac{1}{\\Delta x}\n$$\n\n现在，我们使用 van Leer 限制器计算被限制的斜率 $\\sigma_i^{\\mathrm{vl}}$。输入 $s_L$ 和 $s_R$ 相同。因为 $s_L s_R  0$，我们使用 van Leer 限制器定义中的相应情况：\n$$\n\\sigma_i^{\\mathrm{vl}} = \\phi_{\\mathrm{VL}}(s_L, s_R) = \\frac{2 s_L s_R}{s_L + s_R}\n$$\n代入 $s_L = s_R = \\frac{1}{\\Delta x}$：\n$$\n\\sigma_i^{\\mathrm{vl}} = \\frac{2 \\left(\\frac{1}{\\Delta x}\\right) \\left(\\frac{1}{\\Delta x}\\right)}{\\frac{1}{\\Delta x} + \\frac{1}{\\Delta x}} = \\frac{\\frac{2}{(\\Delta x)^2}}{\\frac{2}{\\Delta x}} = \\frac{2}{(\\Delta x)^2} \\cdot \\frac{\\Delta x}{2} = \\frac{1}{\\Delta x}\n$$\n对于 $s_L = s_R$ 的线性数据，正如预期的那样，两种限制器返回相同的斜率：$\\sigma_i^{\\mathrm{mm}} = \\sigma_i^{\\mathrm{vl}} = \\frac{1}{\\Delta x}$。这表明对于这个特定的线性数据，重构未受限制，并保持了其二阶精度。\n\n在确定了被限制的斜率后，我们可以计算界面值。\n对于 minmod 限制器，被限制的斜率为 $\\sigma_i^{\\mathrm{mm}} = \\frac{1}{\\Delta x}$。从网格单元 $i$ 重构的界面值为：\n$$\nu_{i-1/2}^{R,\\mathrm{mm}} = \\bar u_i - \\frac{1}{2}\\Delta x\\, \\sigma_i^{\\mathrm{mm}} = 2 - \\frac{1}{2}\\Delta x \\left(\\frac{1}{\\Delta x}\\right) = 2 - \\frac{1}{2} = \\frac{3}{2}\n$$\n$$\nu_{i+1/2}^{L,\\mathrm{mm}} = \\bar u_i + \\frac{1}{2}\\Delta x\\, \\sigma_i^{\\mathrm{mm}} = 2 + \\frac{1}{2}\\Delta x \\left(\\frac{1}{\\Delta x}\\right) = 2 + \\frac{1}{2} = \\frac{5}{2}\n$$\n\n对于 van Leer 限制器，被限制的斜率为 $\\sigma_i^{\\mathrm{vl}} = \\frac{1}{\\Delta x}$。从网格单元 $i$ 重构的界面值为：\n$$\nu_{i-1/2}^{R,\\mathrm{vl}} = \\bar u_i - \\frac{1}{2}\\Delta x\\, \\sigma_i^{\\mathrm{vl}} = 2 - \\frac{1}{2}\\Delta x \\left(\\frac{1}{\\Delta x}\\right) = 2 - \\frac{1}{2} = \\frac{3}{2}\n$$\n$$\nu_{i+1/2}^{L,\\mathrm{vl}} = \\bar u_i + \\frac{1}{2}\\Delta x\\, \\sigma_i^{\\mathrm{vl}} = 2 + \\frac{1}{2}\\Delta x \\left(\\frac{1}{\\Delta x}\\right) = 2 + \\frac{1}{2} = \\frac{5}{2}\n$$\n\n两种限制器的结果一致。这是因为输入数据剖面是完全线性的，而两种限制器都被设计为对此类剖面保持二阶精度（即不施加任何限制）。\n\n最终答案是行向量 $(\\sigma_i^{\\mathrm{mm}}, \\sigma_i^{\\mathrm{vl}}, u_{i-1/2}^{R,\\mathrm{mm}}, u_{i+1/2}^{L,\\mathrm{mm}}, u_{i-1/2}^{R,\\mathrm{vl}}, u_{i+1/2}^{L,\\mathrm{vl}})$。\n代入计算出的值：\n$$\n\\left(\\frac{1}{\\Delta x}, \\frac{1}{\\Delta x}, \\frac{3}{2}, \\frac{5}{2}, \\frac{3}{2}, \\frac{5}{2}\\right)\n$$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{\\Delta x}  \\frac{1}{\\Delta x}  \\frac{3}{2}  \\frac{5}{2}  \\frac{3}{2}  \\frac{5}{2} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在掌握了斜率限制器的基本计算后，下一步是将其整合到一个完整的数值求解器中。这项实践要求您编写代码，实现一个包含MUSCL重构和van Leer限制器的二阶有限体积法，用以求解一个经典的标量守恒律。通过执行网格加密研究并分析$L_2$误差的收敛速度，您将不仅把理论知识转化为可运行的程序，还将学会如何通过数值实验来验证和评估一个数值格式的准确性。",
            "id": "3347636",
            "problem": "考虑周期性区域 $x \\in [0,1]$ 上的标量守恒律 $u_t + f(u)_x = 0$，其通量为 $f(u) = a u$，平流速度 $a$ 为常数，光滑初始条件为 $u(x,0) = \\sin(2\\pi x)$。对于所有 $t \\ge 0$，其精确解为 $u(x,t) = \\sin(2\\pi (x - a t))$。使用有限体积法在具有 $N$ 个网格单元的均匀网格上进行离散，网格宽度为 $\\Delta x = 1/N$，网格平均值为 $U_i(t) \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t)\\,dx$，并采用周期性边界条件。采用带有 van Leer 限制器的守恒律单调上游中心格式 (MUSCL) 进行重构，并使用具有固定库朗-弗里德里希斯-列维 (CFL) 数的两步总变差递减 (TVD) 龙格-库塔方法进行时间推进。\n\n从守恒律的基本有限体积平衡出发，设计并实现一个二阶精确的数值方法，具体如下：\n- 使用一个具有 $N$ 个单元的均匀网格，$\\Delta x = 1/N$，并对跨界面的通量使用周期性索引。\n- 对于每个单元，使用带有 van Leer 斜率限制器 $\\phi(r) = \\frac{r + |r|}{1 + |r|}$ 的 MUSCL 方法重构界面处的左侧状态，其中 $r$ 是连续差分之比。\n- 对于 $a  0$，使用迎风选择来评估数值通量，即 $F_{i+1/2} = a \\, U_{i+1/2}^{-}$，其中 $U_{i+1/2}^{-}$ 是界面 $x_{i+1/2}$ 处的左侧状态。\n- 使用两步 TVD 龙格-库塔方法推进解，时间步长 $\\Delta t$ 由常数 CFL 数 $C$ 决定，即 $\\Delta t = C \\, \\Delta x / a$，并进行调整，使得最终时间 $T$ 恰好能被整数个步长整除。\n\n该格式使用每个单元 $i$ 中 $u(x,0) = \\sin(2\\pi x)$ 的精确网格平均值进行初始化，即\n$$\nU_i(0) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\sin(2\\pi x)\\,dx = \\frac{\\cos(2\\pi x_{i-1/2}) - \\cos(2\\pi x_{i+1/2})}{2\\pi \\Delta x}.\n$$\n对于时间 $T = 1$、$a = 1$ 和 $C = 0.4$ 的误差研究，精确解在周期性区域上返回到初始条件，因此在 $t = T$ 时的精确网格平均值与 $U_i(0)$ 一致。\n\n将时间 $T$ 的离散 $L_2$ 误差定义为\n$$\nE_{L_2}(N) = \\left( \\Delta x \\sum_{i=0}^{N-1} \\left( U_i(T) - U_i(0) \\right)^2 \\right)^{1/2}.\n$$\n两个连续网格加密 $N_1$ 和 $N_2$ 之间的观测收敛率为\n$$\np(N_1,N_2) = \\frac{\\ln\\left( E_{L_2}(N_1) / E_{L_2}(N_2) \\right)}{\\ln\\left( \\Delta x_1 / \\Delta x_2 \\right)} = \\frac{\\ln\\left( E_{L_2}(N_1) / E_{L_2}(N_2) \\right)}{\\ln\\left( N_2 / N_1 \\right)}.\n$$\n\n您的任务是：\n- 从有限体积更新和 MUSCL van Leer 重构出发，实现所述方法以计算数值解。\n- 计算在一组加密网格上 $t=T$ 时的离散 $L_2$ 误差 $E_{L_2}(N)$。\n- 计算连续加密网格之间的观测速率 $p(N_1,N_2)$。\n- 考虑到 $u(x,t)$ 的光滑性以及限制器在光滑剖面上的行为，推导 $E_{L_2}(N)$ 相对于 $\\Delta x$ 的期望渐进行为，并根据方法的结构证明该速率的合理性。\n\n使用以下网格分辨率测试集：\n- $N \\in \\{20,40,80,160\\}$。\n\n设置 $a = 1$，$C = 0.4$，以及 $T = 1$，所有量均为无量纲。输出必须是没有物理单位的数值。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含四个 $L_2$ 误差，后跟三个观测速率\n$[E_{L_2}(20),E_{L_2}(40),E_{L_2}(80),E_{L_2}(160),p(20,40),p(40,80),p(80,160)]$。",
            "solution": "### 1. 有限体积离散\n\n标量守恒律为 $u_t + f(u)_x = 0$，通量为 $f(u)=au$。我们在一个包含 $N$ 个单元的均匀网格上离散此方程，每个单元的宽度为 $\\Delta x = 1/N$。单元中心为 $x_i = (i+1/2)\\Delta x$，其中 $i=0, ..., N-1$。单元 $i$ 中的单元平均值为 $U_i(t)$。单元 $i$ 的半离散有限体积格式为：\n$$\n\\frac{dU_i}{dt} = L(U)_i = -\\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2})\n$$\n其中 $L(U)_i$ 是空间离散算子，$F_{i\\pm 1/2}$ 是单元界面 $x_{i\\pm 1/2}$ 处的数值通量。\n\n### 2. MUSCL 重构和数值通量\n\n为了达到二阶空间精度，我们使用 MUSCL (Monotonic Upstream-centered Schemes for Conservation Laws) 在每个单元内重构解的分段线性表示。单元 $i$ 内一点 $x$ 处的解值近似为：\n$$\nu(x) = U_i + s_i(x - x_i)\n$$\n其中 $s_i$ 是单元 $i$ 中一个受限的斜率，以防止伪振荡并确保总变差递减 (TVD) 属性。\n\n对于具有恒定速度 $a0$ 的线性平流方程，信息从左向右传播。因此，迎风通量是合适的。界面 $x_{i+1/2}$ 处的数值通量由从迎风单元（即单元 $i$）重构的状态决定：\n$$\nF_{i+1/2} = f(U_{i+1/2}^{-}) = a U_{i+1/2}^{-}\n$$\n状态 $U_{i+1/2}^{-}$ 是从单元 $i$ 重构的解在其右边界 $x_{i+1/2} = x_i + \\Delta x/2$ 处的值：\n$$\nU_{i+1/2}^{-} = U_i + s_i \\frac{\\Delta x}{2}\n$$\n受限斜率 $s_i$ 写为 $s_i = \\sigma_i / \\Delta x$，其中 $\\sigma_i$ 是单元 $i$ 的受限差分。状态则为：\n$$\nU_{i+1/2}^{-} = U_i + \\frac{1}{2}\\sigma_i\n$$\n受限差分 $\\sigma_i$ 使用 van Leer 斜率限制器计算。该限制器作用于连续差分之比，以在一阶和二阶格式之间进行混合。我们定义后向差分 $\\Delta_i^- = U_i - U_{i-1}$ 和前向差分 $\\Delta_i^+ = U_{i+1} - U_i$。单元 $i$ 的连续差分之比为 $r_i = \\Delta_i^+ / \\Delta_i^-$。然后，受限差分 $\\sigma_i$ 计算如下：\n$$\n\\sigma_i = \\phi(r_i) \\Delta_i^-\n$$\n其中给定的 van Leer 限制器函数为 $\\phi(r) = \\frac{r + |r|}{1 + |r|}$。此函数可以简化：对于 $r \\le 0$，它为 $0$；对于 $r  0$，它为 $\\frac{2r}{1+r}$。条件 $r \\le 0$ 发生在局部极值点或其附近，限制器在这些点正确地将斜率设置为零以避免产生新的极值，从而局部地退化为一阶迎风格式。对于光滑的单调区域，$r  0$，限制器允许使用更高阶的斜率。\n\n结合这些元素，界面 $i+1/2$ 处数值通量的完整表达式为：\n$$\nF_{i+1/2} = a \\left( U_i + \\frac{1}{2} \\phi\\left(\\frac{U_{i+1}-U_i}{U_i-U_{i-1}}\\right) (U_i-U_{i-1}) \\right)\n$$\n周期性边界条件用于计算在区域边界处的差分。例如，要计算 $\\sigma_0$，我们需要 $U_{-1}$，它被设置为 $U_{N-1}$。\n\n### 3. 时间推进\n\n我们使用两步 TVD 龙格-库塔方法 (TVD-RK2) 将解从时间 $t^n$ 推进到 $t^{n+1} = t^n + \\Delta t$。该方法在时间上是二阶精确的，并保持了空间离散的 TVD 属性。这两个阶段是：\n$$\n\\begin{align*}\nU^{(1)} = U^n + \\Delta t L(U^n) \\\\\nU^{n+1} = \\frac{1}{2} U^n + \\frac{1}{2} \\left( U^{(1)} + \\Delta t L(U^{(1)}) \\right)\n\\end{align*}\n$$\n其中 $U^n$ 是时间 $t^n$ 时所有单元平均值 $U_i$ 的向量。时间步长 $\\Delta t$ 由 CFL 条件确定。计算一个临时时间步长 $\\Delta t_{prov} = C \\Delta x / a$。为确保最终时间 $T$ 在整数步内达到，我们计算步数 $N_{steps} = \\lceil T / \\Delta t_{prov} \\rceil$ 并使用调整后的时间步长 $\\Delta t = T / N_{steps}$。\n\n### 4. 误差分析与期望收敛率\n\n问题要求计算在 $T=1$ 时的离散 $L_2$ 误差。对于 $a=1$，精确解 $u(x,1)=\\sin(2\\pi(x-1))=\\sin(2\\pi x)$ 返回到其初始状态。因此，$T=1$ 时的精确单元平均值与初始值 $U_i(0)$ 相同。误差计算公式为：\n$$\nE_{L_2}(N) = \\left( \\Delta x \\sum_{i=0}^{N-1} \\left( U_i(T) - U_i(0) \\right)^2 \\right)^{1/2}\n$$\n在两个网格 $N_1$ 和 $N_2$ 之间的观测收敛率 $p$ 为：\n$$\np(N_1,N_2) = \\frac{\\ln\\left( E_{L_2}(N_1) / E_{L_2}(N_2) \\right)}{\\ln\\left( N_2 / N_1 \\right)}\n$$\n所构建的格式是形式上二阶精确的。然而，包括 van Leer 限制器在内的 TVD 兼容斜率限制器已知会在光滑极值点处将局部精度降低到一阶（Harten 定理）。由于初始条件 $u(x,0)=\\sin(2\\pi x)$ 有一个最大值和一个最小值，每个周期内有两个单元的局部截断误差 (LTE) 是 $O(\\Delta x)$，而不是在其他地方达到的 $O(\\Delta x^2)$。\n\n$L_p$ 范数下的全局误差 $E_{L_p}$ 可以通过考虑其对 LTE 的依赖性来分析。经过 $N_{steps} = T/\\Delta t \\sim O(1/\\Delta x)$ 步后，误差的标度为：\n$$\nE_{L_p}^p \\approx \\Delta x \\left( \\sum_{\\text{2nd-order cells}} |e_{i}|^p + \\sum_{\\text{1st-order cells}} |e_{i}|^p \\right)\n$$\n假设局部单元误差 $e_i$ 与 LTE 成比例，则在 $N-k$ 个二阶单元中的误差为 $O(\\Delta x^2)$，在 $k=O(1)$ 个一阶单元中的误差为 $O(\\Delta x)$。\n$$\nE_{L_p}^p \\approx \\Delta x \\left( (N-k) \\cdot (O(\\Delta x^2))^p + k \\cdot (O(\\Delta x))^p \\right)\n$$\n代入 $N = 1/\\Delta x$：\n$$\nE_{L_p}^p \\approx \\Delta x \\left( O(\\Delta x^{-1}) \\cdot O(\\Delta x^{2p}) + O(1) \\cdot O(\\Delta x^p) \\right) = O(\\Delta x^{2p}) + O(\\Delta x^{p+1})\n$$\n对于 $p \\geq 1$，我们有 $2p \\ge p+1$，所以 $O(\\Delta x^{p+1})$ 项是主导项（对于 $p=1$ 则相等）。因此，全局误差的标度为：\n$$\nE_{L_p} \\sim \\left( O(\\Delta x^{p+1}) \\right)^{1/p} = O(\\Delta x^{(p+1)/p})\n$$\n对于 $L_2$ 范数，我们有 $p=2$。因此，期望的渐进收敛率是 $(2+1)/2 = 1.5$。数值结果应显示，随着网格的加密，收敛率会趋近于此值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef van_leer_limiter(r: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes the van Leer limiter function phi(r).\n    phi(r) = (r + |r|) / (1 + |r|)\n    Numerically, this is 0 for r = 0 and 2r / (1+r) for r  0.\n    \"\"\"\n    phi = np.zeros_like(r, dtype=float)\n    mask = r  0\n    r_masked = r[mask]\n    phi[mask] = (2 * r_masked) / (1 + r_masked)\n    return phi\n\ndef calculate_rhs(U: np.ndarray, dx: float, a: float) - np.ndarray:\n    \"\"\"\n    Calculates the right-hand side of the finite-volume semi-discretization\n    using MUSCL reconstruction with a van Leer limiter.\n    L(U)_i = - (F_{i+1/2} - F_{i-1/2}) / dx\n    \"\"\"\n    # Periodic boundary conditions are handled by np.roll\n    U_m1 = np.roll(U, 1)  # Stencil for U_{i-1}\n    U_p1 = np.roll(U, -1) # Stencil for U_{i+1}\n\n    # Differences centered on cell i\n    delta_b = U - U_m1      # U_i - U_{i-1}\n    delta_f = U_p1 - U      # U_{i+1} - U_i\n\n    # Ratio of successive differences, r_i = delta_f_i / delta_b_i\n    # Note: problem statement implies r_i = (U_{i+1}-U_i)/(U_i-U_{i-1}) = delta_f / delta_b\n    # Let's adjust based on the derivation that uses phi(r_i)*(U_i-U_{i-1})\n    # The more standard definition is r_i = (U_i-U_{i-1})/(U_{i+1}-U_i) for a slope based on forward diff\n    # But the formula in the problem description is U_i + 1/2*phi(r_i)*(U_i-U_{i-1}). This confirms sigma = phi*delta_b\n    # and r is the ratio of consecutive gradients. Let's use the definition in the problem desc.\n    # r = (U_i-U_{i-1}) / (U_{i+1}-U_i). No, that's not what the solution says.\n    # The solution says r = (U_{i+1}-U_i)/(U_i-U_{i-1}). This is more common. Let's stick to the solution's derivation.\n    r = np.zeros_like(U, dtype=float)\n    denom_is_nonzero = np.abs(delta_b)  1e-12\n    np.divide(delta_f, delta_b, out=r, where=denom_is_nonzero)\n\n    # Calculate limited difference sigma_i for each cell i\n    phi = van_leer_limiter(r)\n    sigma = phi * delta_b\n\n    # Reconstruct the state U at the right-hand interface of each cell i (x_{i+1/2})\n    # U_{i+1/2}^- = U_i + 0.5 * sigma_i\n    U_left_at_interface = U + 0.5 * sigma\n\n    # Numerical flux at interface i+1/2 (upwind for a  0)\n    # F_{i+1/2} = a * U_{i+1/2}^-\n    F = a * U_left_at_interface\n\n    # Flux at interface i-1/2\n    F_m1 = np.roll(F, 1)\n\n    # Compute the RHS of the semi-discrete equation\n    rhs = -(F - F_m1) / dx\n    return rhs\n\ndef solve():\n    \"\"\"\n    Main solver function to run the simulation and compute errors and rates.\n    \"\"\"\n    # Problem parameters\n    a = 1.0\n    C = 0.4\n    T = 1.0\n    N_list = [20, 40, 80, 160]\n\n    errors_l2 = []\n    \n    for N in N_list:\n        # Grid setup\n        dx = 1.0 / N\n        x_interfaces = np.linspace(0.0, 1.0, N + 1)\n        \n        # Initial condition (exact cell averages)\n        U_initial = (np.cos(2 * np.pi * x_interfaces[:-1]) - np.cos(2 * np.pi * x_interfaces[1:])) / (2 * np.pi * dx)\n        U = U_initial.copy()\n\n        # Time step adjustment to hit T exactly\n        dt_provisional = C * dx / a\n        num_steps = int(np.ceil(T / dt_provisional))\n        dt = T / num_steps\n\n        # Time integration using two-stage TVD Runge-Kutta method\n        for _ in range(num_steps):\n            # Stage 1\n            rhs1 = calculate_rhs(U, dx, a)\n            U1 = U + dt * rhs1\n            \n            # Stage 2\n            rhs2 = calculate_rhs(U1, dx, a)\n            U = 0.5 * U + 0.5 * (U1 + dt * rhs2)\n\n        # Compute discrete L2 error at T=1\n        # The exact solution at T=1 is the same as the initial condition\n        error_l2 = np.sqrt(dx * np.sum((U - U_initial)**2))\n        errors_l2.append(error_l2)\n\n    # Compute observed convergence rates\n    rates = []\n    for i in range(len(N_list) - 1):\n        N1 = N_list[i]\n        N2 = N_list[i+1]\n        E1 = errors_l2[i]\n        E2 = errors_l2[i+1]\n        # p = ln(E1/E2) / ln(N2/N1)\n        rate = np.log(E1 / E2) / np.log(N2 / N1)\n        rates.append(rate)\n\n    # Format the final output\n    results = errors_l2 + rates\n    # The print statement must produce only the required output line.\n    print(f\"[{','.join(f'{x:.8e}' for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}