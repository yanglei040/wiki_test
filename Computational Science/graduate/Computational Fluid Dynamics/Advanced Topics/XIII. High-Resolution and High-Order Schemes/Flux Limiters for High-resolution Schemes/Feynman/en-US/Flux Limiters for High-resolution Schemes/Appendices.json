{
    "hands_on_practices": [
        {
            "introduction": "While high-resolution schemes aim for accuracy, they must not violate fundamental physical laws. For fluid dynamics, ensuring that quantities like density $\\rho$ and pressure $p$ remain positive is non-negotiable. This exercise provides a hands-on calculation to design a positivity-preserving scheme for the Euler equations, a cornerstone of robust solver development. You will work through the derivation of a blending coefficient $\\theta$ that formally guarantees physical realizability by mixing a high-order flux with a failsafe, positivity-guaranteeing low-order flux.",
            "id": "3320306",
            "problem": "Consider the one-dimensional compressible Euler equations in conservative variables $U = (\\rho, m, E)^{\\top}$, where $\\rho$ is the density, $m = \\rho u$ is the momentum with velocity $u$, and $E$ is the total energy. The pressure $p$ is given by the ideal gas relation $p = (\\gamma - 1)\\left(E - \\frac{m^{2}}{2 \\rho}\\right)$ for ratio of specific heats $\\gamma > 1$. A uniform finite-volume discretization on a grid with spacing $\\Delta x$ is advanced in time with time step $\\Delta t$ by a flux update of the form\n$$\nU_{i}^{n+1} = U_{i}^{n} - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\nwhere $F_{i\\pm\\frac{1}{2}}$ are numerical fluxes at the cell interfaces. To construct a positivity-preserving high-resolution update for density and pressure, consider a convex flux limiter that blends a high-order flux with a low-order flux as\n$$\nF_{i\\pm\\frac{1}{2}}(\\theta) = \\theta\\,F_{i\\pm\\frac{1}{2}}^{\\mathrm{HO}} + (1-\\theta)\\,F_{i\\pm\\frac{1}{2}}^{\\mathrm{LO}},\n$$\nwith a coefficient $\\theta \\in [0,1]$. Let the net flux differences be denoted by\n$$\n\\Delta F^{\\mathrm{HO}} = F_{i+\\frac{1}{2}}^{\\mathrm{HO}} - F_{i-\\frac{1}{2}}^{\\mathrm{HO}}, \\qquad\n\\Delta F^{\\mathrm{LO}} = F_{i+\\frac{1}{2}}^{\\mathrm{LO}} - F_{i-\\frac{1}{2}}^{\\mathrm{LO}},\n$$\nso that the update in cell $i$ can be written as\n$$\nU_{i}^{n+1}(\\theta) = U_{i}^{n} - \\lambda\\left(\\theta\\,\\Delta F^{\\mathrm{HO}} + (1-\\theta)\\,\\Delta F^{\\mathrm{LO}}\\right),\n\\qquad \\lambda = \\frac{\\Delta t}{\\Delta x}.\n$$\nAssume $\\gamma = 1.4$, $\\lambda = 0.1$, and the initial state\n$$\nU_{i}^{n} = \\begin{pmatrix} \\rho_{i}^{n} \\\\ m_{i}^{n} \\\\ E_{i}^{n} \\end{pmatrix}\n= \\begin{pmatrix} 1.0 \\\\ 2.0 \\\\ 4.5 \\end{pmatrix}.\n$$\nSuppose the high-order net flux difference and the low-order net flux difference are\n$$\n\\Delta F^{\\mathrm{HO}} = \\begin{pmatrix} 0.8 \\\\ -3.0 \\\\ 18.0 \\end{pmatrix},\n\\qquad\n\\Delta F^{\\mathrm{LO}} = \\begin{pmatrix} 0.1 \\\\ 0.0 \\\\ 0.5 \\end{pmatrix},\n$$\nand further suppose that the low-order flux is positivity-guaranteeing in the sense that the update with $\\theta = 0$ yields nonnegative density and pressure. Derive, from the governing update and the definition of pressure, the algebraic conditions on $\\theta$ required to guarantee $\\rho_{i}^{n+1}(\\theta) \\ge 0$ and $p_{i}^{n+1}(\\theta) \\ge 0$. Then, compute the largest admissible $\\theta$ in $[0,1]$ that satisfies both conditions for the given data. Express your final answer as a single real number rounded to four significant figures. The answer is dimensionless, so no units are required.",
            "solution": "The problem requires finding the largest blending coefficient $\\theta \\in [0,1]$ that ensures the updated density $\\rho_{i}^{n+1}$ and pressure $p_{i}^{n+1}$ are non-negative.\n\nThe update for the vector of conservative variables $U_{i}^{n+1} = (\\rho_{i}^{n+1}, m_{i}^{n+1}, E_{i}^{n+1})^{\\top}$ is given by:\n$$\nU_{i}^{n+1}(\\theta) = U_{i}^{n} - \\lambda\\left(\\theta\\,\\Delta F^{\\mathrm{HO}} + (1-\\theta)\\,\\Delta F^{\\mathrm{LO}}\\right)\n$$\nwhere $\\lambda = \\frac{\\Delta t}{\\Delta x}$. We can rewrite this equation by separating the low-order part:\n$$\nU_{i}^{n+1}(\\theta) = U_{i}^{n} - \\lambda\\Delta F^{\\mathrm{LO}} - \\theta\\lambda(\\Delta F^{\\mathrm{HO}} - \\Delta F^{\\mathrm{LO}})\n$$\nLet $U_{i}^{\\mathrm{LO}} = U_{i}^{n} - \\lambda\\Delta F^{\\mathrm{LO}}$ be the state updated using only the low-order flux. The problem states that this update is positivity-preserving, meaning $\\rho_{i}^{\\mathrm{LO}} \\ge 0$ and $p_{i}^{\\mathrm{LO}} \\ge 0$. Let $P = \\lambda(\\Delta F^{\\mathrm{HO}} - \\Delta F^{\\mathrm{LO}})$. The update can then be written compactly as:\n$$\nU_{i}^{n+1}(\\theta) = U_{i}^{\\mathrm{LO}} - \\theta P\n$$\nWriting this in component form:\n$$\n\\rho_{i}^{n+1}(\\theta) = \\rho_{i}^{\\mathrm{LO}} - \\theta P_{\\rho} \\\\\nm_{i}^{n+1}(\\theta) = m_{i}^{\\mathrm{LO}} - \\theta P_{m} \\\\\nE_{i}^{n+1}(\\theta) = E_{i}^{\\mathrm{LO}} - \\theta P_{E}\n$$\nwhere $P = (P_\\rho, P_m, P_E)^\\top$.\n\nFirst, we derive the algebraic condition for the positivity of density, $\\rho_{i}^{n+1}(\\theta) \\ge 0$:\n$$\n\\rho_{i}^{\\mathrm{LO}} - \\theta P_{\\rho} \\ge 0\n$$\nThis is a linear inequality in $\\theta$.\n\nSecond, we derive the condition for the positivity of pressure, $p_{i}^{n+1}(\\theta) \\ge 0$. The pressure is given by $p = (\\gamma - 1)(E - \\frac{m^2}{2\\rho})$. Since $\\gamma > 1$, the condition $p \\ge 0$ is equivalent to its argument being non-negative:\n$$\nE_{i}^{n+1}(\\theta) - \\frac{(m_{i}^{n+1}(\\theta))^2}{2\\rho_{i}^{n+1}(\\theta)} \\ge 0\n$$\nTo avoid division by $\\rho_{i}^{n+1}(\\theta)$ (which could be zero), we multiply by $2\\rho_{i}^{n+1}(\\theta)$. Assuming $\\rho_{i}^{n+1}(\\theta) > 0$, this yields:\n$$\n2E_{i}^{n+1}(\\theta)\\rho_{i}^{n+1}(\\theta) - (m_{i}^{n+1}(\\theta))^2 \\ge 0\n$$\nSubstituting the expressions in terms of $\\theta$:\n$$\n2(E_{i}^{\\mathrm{LO}} - \\theta P_{E})(\\rho_{i}^{\\mathrm{LO}} - \\theta P_{\\rho}) - (m_{i}^{\\mathrm{LO}} - \\theta P_{m})^2 \\ge 0\n$$\nThis is a quadratic inequality in $\\theta$ of the form $A\\theta^2 + B\\theta + C \\ge 0$. Expanding the expression gives the coefficients:\n$$\nA = 2 P_{E}P_{\\rho} - P_{m}^{2}\n$$\n$$\nB = 2 m_{i}^{\\mathrm{LO}}P_{m} - 2(E_{i}^{\\mathrm{LO}}P_{\\rho} + \\rho_{i}^{\\mathrm{LO}}P_{E})\n$$\n$$\nC = 2 E_{i}^{\\mathrm{LO}}\\rho_{i}^{\\mathrm{LO}} - (m_{i}^{\\mathrm{LO}})^2\n$$\nNote that $C \\ge 0$ because the low-order update is positivity-preserving.\n\nNow, we substitute the given numerical values:\n$\\gamma = 1.4$, $\\lambda = 0.1$.\n$U_{i}^{n} = (1.0, 2.0, 4.5)^{\\top}$.\n$\\Delta F^{\\mathrm{HO}} = (0.8, -3.0, 18.0)^{\\top}$.\n$\\Delta F^{\\mathrm{LO}} = (0.1, 0.0, 0.5)^{\\top}$.\n\nFirst, compute the low-order state $U_{i}^{\\mathrm{LO}}$:\n$$\nU_{i}^{\\mathrm{LO}} = U_{i}^{n} - \\lambda \\Delta F^{\\mathrm{LO}} = \\begin{pmatrix} 1.0 \\\\ 2.0 \\\\ 4.5 \\end{pmatrix} - 0.1 \\begin{pmatrix} 0.1 \\\\ 0.0 \\\\ 0.5 \\end{pmatrix} = \\begin{pmatrix} 1.0 \\\\ 2.0 \\\\ 4.5 \\end{pmatrix} - \\begin{pmatrix} 0.01 \\\\ 0.0 \\\\ 0.05 \\end{pmatrix} = \\begin{pmatrix} 0.99 \\\\ 2.0 \\\\ 4.45 \\end{pmatrix}\n$$\nSo, $\\rho_{i}^{\\mathrm{LO}} = 0.99$, $m_{i}^{\\mathrm{LO}} = 2.0$, and $E_{i}^{\\mathrm{LO}} = 4.45$.\n\nNext, compute the vector $P$:\n$$\n\\Delta F^{\\mathrm{HO}} - \\Delta F^{\\mathrm{LO}} = \\begin{pmatrix} 0.8 \\\\ -3.0 \\\\ 18.0 \\end{pmatrix} - \\begin{pmatrix} 0.1 \\\\ 0.0 \\\\ 0.5 \\end{pmatrix} = \\begin{pmatrix} 0.7 \\\\ -3.0 \\\\ 17.5 \\end{pmatrix}\n$$\n$$\nP = \\lambda(\\Delta F^{\\mathrm{HO}} - \\Delta F^{\\mathrm{LO}}) = 0.1 \\begin{pmatrix} 0.7 \\\\ -3.0 \\\\ 17.5 \\end{pmatrix} = \\begin{pmatrix} 0.07 \\\\ -0.3 \\\\ 1.75 \\end{pmatrix}\n$$\nSo, $P_{\\rho} = 0.07$, $P_{m} = -0.3$, and $P_{E} = 1.75$.\n\nEvaluate the density condition:\n$$\n0.99 - \\theta(0.07) \\ge 0 \\implies 0.99 \\ge 0.07\\theta \\implies \\theta \\le \\frac{0.99}{0.07} = \\frac{99}{7} \\approx 14.14\n$$\nThis condition is satisfied for any $\\theta \\in [0,1]$.\n\nEvaluate the pressure condition by computing the coefficients $A$, $B$, and $C$ of the equivalent quadratic $A'\\theta^2 + B'\\theta + C' \\ge 0$ where $A' = A/2, B' = B/2, C' = C/2$:\n$$\nC' = (4.45)(0.99) - \\frac{1}{2}(2.0)^2 = 4.4055 - 2.0 = 2.4055\n$$\n$$\nB' = (2.0)(-0.3) - ((4.45)(0.07) + (0.99)(1.75)) = -0.6 - (0.3115 + 1.7325) = -0.6 - 2.044 = -2.644\n$$\n$$\nA' = (1.75)(0.07) - \\frac{1}{2}(-0.3)^2 = 0.1225 - \\frac{1}{2}(0.09) = 0.1225 - 0.045 = 0.0775\n$$\nThe quadratic inequality for pressure positivity is:\n$$\n0.0775 \\theta^2 - 2.644 \\theta + 2.4055 \\ge 0\n$$\nTo find the regions where this holds, we find the roots of the quadratic equation $0.0775 \\theta^2 - 2.644 \\theta + 2.4055 = 0$ using the quadratic formula $\\theta = \\frac{-B' \\pm \\sqrt{B'^2-4A'C'}}{2A'}$:\n$$\nB'^2 - 4A'C' = (-2.644)^2 - 4(0.0775)(2.4055) = 6.990736 - 0.745705 = 6.245031\n$$\n$$\n\\sqrt{B'^2 - 4A'C'} \\approx 2.499006\n$$\nThe roots are:\n$$\n\\theta_{1,2} = \\frac{2.644 \\pm 2.499006}{2(0.0775)} = \\frac{2.644 \\pm 2.499006}{0.155}\n$$\n$$\n\\theta_1 = \\frac{2.644 - 2.499006}{0.155} = \\frac{0.144994}{0.155} \\approx 0.935445\n$$\n$$\n\\theta_2 = \\frac{2.644 + 2.499006}{0.155} = \\frac{5.143006}{0.155} \\approx 33.18068\n$$\nSince the coefficient $A'=0.0775$ is positive, the parabola opens upwards. The inequality $A'\\theta^2 + B'\\theta + C' \\ge 0$ is satisfied for $\\theta \\le \\theta_1$ or $\\theta \\ge \\theta_2$. Thus, we must have:\n$$\n\\theta \\le 0.935445 \\quad \\text{or} \\quad \\theta \\ge 33.18068\n$$\nWe need to find the largest $\\theta$ that satisfies all conditions simultaneously:\n1. $\\theta \\in [0,1]$ (by definition of the limiter)\n2. $\\theta \\le 14.14$ (from density positivity)\n3. $\\theta \\le 0.935445$ or $\\theta \\ge 33.18068$ (from pressure positivity)\n\nThe intersection of these conditions is $0 \\le \\theta \\le 0.935445$.\nThe largest admissible value for $\\theta$ is the upper bound of this interval, $\\theta_{max} \\approx 0.935445$.\nRounding to four significant figures, the result is $0.9354$.",
            "answer": "$$\\boxed{0.9354}$$"
        },
        {
            "introduction": "Extending one-dimensional concepts to multiple dimensions is a common source of error in numerical methods. A simple coordinate-by-coordinate application of a 1D flux limiter can produce severe non-physical oscillations, especially when the flow is oblique to an anisotropic grid. In this coding practice, you will directly confront this issue by comparing a naive coordinate-wise limiting strategy with a genuinely multi-dimensional limiter that senses the direction of advection. This exercise highlights the critical importance of designing limiters that respect the multi-dimensional nature of the flow physics.",
            "id": "3320354",
            "problem": "Consider the two-dimensional linear advection of a scalar field $q(x,y,t)$ governed by the conservation law\n$$\n\\partial_t q + a\\,\\partial_x q + b\\,\\partial_y q = 0,\n$$\nwhere $(a,b)$ is a constant velocity vector. A second-order accurate finite-volume update on a uniform Cartesian mesh with rectangular cells of sizes $\\,\\Delta x\\,$ and $\\,\\Delta y\\,$ can be written as\n$$\nq_{i,j}^{n+1} = q_{i,j}^{n} - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2},j} - F_{i-\\frac{1}{2},j}\\right) - \\frac{\\Delta t}{\\Delta y}\\left(G_{i,j+\\frac{1}{2}} - G_{i,j-\\frac{1}{2}}\\right),\n$$\nwith periodic boundaries, where $F_{i+\\frac{1}{2},j}$ and $G_{i,j+\\frac{1}{2}}$ are numerical fluxes across cell faces. For linear advection, an upwind Riemann solver uses $F_{i+\\frac{1}{2},j} = a\\,q_{i+\\frac{1}{2},j}^{\\mathrm{up}}$ and $G_{i,j+\\frac{1}{2}} = b\\,q_{i,j+\\frac{1}{2}}^{\\mathrm{up}}$, where $q^{\\mathrm{up}}$ is the reconstructed scalar at the face taken from the upwind side.\n\nThe reconstruction uses a linear profile within each cell based on a limited gradient. In many multi-dimensional implementations, limiting is applied separately to the $\\partial_x q$ and $\\partial_y q$ components by using a one-dimensional Total Variation Diminishing (TVD) limiter along each coordinate. This coordinate-wise limiting can fail to prevent non-physical behavior when the true gradient and characteristics are oblique to the grid axes, especially on grids with aspect ratio $\\Delta x/\\Delta y \\neq 1$. A genuinely multi-dimensional limiter should sense the direction of information propagation and limit the gradient component along that direction, not independently along $x$ and $y$.\n\nTask: Starting from the conservation law and the finite-volume discretization above, implement two reconstruction strategies:\n- Coordinate-wise limiting: compute separate limited slopes for $\\partial_x q$ and $\\partial_y q$ using a one-dimensional TVD limiter applied to forward and backward differences along each axis.\n- Directional multi-dimensional limiting: compute the limited slope along the unit vector in the advection direction $\\boldsymbol{n} = (a,b)/\\sqrt{a^2+b^2}$ using the same TVD limiter, then reconstruct the gradient vector by projecting this limited directional slope back onto $\\boldsymbol{n}$.\n\nUse a single explicit time step of size $\\Delta t$ chosen to satisfy a standard stability constraint. Initialize $q$ as an oblique planar step function on the periodic unit square domain $[0,1]\\times[0,1]$,\n$$\nq(x,y,0) = \\begin{cases}\n1, & \\text{if } x\\cos\\alpha + y\\sin\\alpha > s,\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\nwhere $\\alpha$ is the step normal angle and $s$ is a threshold. The exact solution after one time step is $q_{\\mathrm{exact}}(x,y,\\Delta t) = q(x - a\\Delta t, y - b\\Delta t, 0)$ under periodic wrapping.\n\nYou must:\n- Derive the limited reconstructions from the base discretization and define the limiter you choose to use.\n- Implement both schemes and advance one time step.\n- Quantify failure and improvement using two metrics per test case:\n    1. Overshoot difference: the non-physical boundedness violation magnitude for the coordinate-wise limiter minus that for the directional limiter, defined as\n       $$\n       \\Delta_{\\mathrm{over}} = \\left[\\max\\left(\\max(q_{\\mathrm{axis}} - 1), \\max(0 - q_{\\mathrm{axis}}), 0\\right)\\right] - \\left[\\max\\left(\\max(q_{\\mathrm{dir}} - 1), \\max(0 - q_{\\mathrm{dir}}), 0\\right)\\right].\n       $$\n    2. Error ratio: the ratio of discrete $L^1$ errors,\n       $$\n       R_{L^1} = \\frac{\\frac{1}{N_x N_y}\\sum_{i,j}\\left|q_{i,j}^{\\mathrm{axis}} - q_{i,j}^{\\mathrm{exact}}\\right|}{\\frac{1}{N_x N_y}\\sum_{i,j}\\left|q_{i,j}^{\\mathrm{dir}} - q_{i,j}^{\\mathrm{exact}}\\right|}.\n       $$\n\nAngle quantities must be expressed in radians. There are no physical units beyond the non-dimensional variables above. Use periodic boundary conditions in both directions. Choose $\\Delta t$ according to\n$$\n\\Delta t = \\mathrm{CFL}\\cdot \\min\\left( \\frac{\\Delta x}{|a|}, \\frac{\\Delta y}{|b|} \\right),\n$$\nwith the convention that if $a=0$ or $b=0$, the corresponding fraction is treated as $+\\infty$ in the minimum.\n\nTest Suite:\n- Case $1$ (happy path, near-isotropic mesh): $N_x=128$, $N_y=128$, $\\beta= \\pi/4$, $\\alpha=\\pi/4$, $s=0.5$, $\\mathrm{CFL}=0.4$, with $(a,b)=(\\cos\\beta,\\sin\\beta)$.\n- Case $2$ (extreme aspect ratio, oblique advection): $N_x=200$, $N_y=20$, $\\beta= \\pi/3$, $\\alpha=\\pi/3$, $s=0.5$, $\\mathrm{CFL}=0.95$, with $(a,b)=(\\cos\\beta,\\sin\\beta)$.\n- Case $3$ (extreme aspect ratio in the opposite sense): $N_x=40$, $N_y=400$, $\\beta= \\pi/6$, $\\alpha=\\pi/6$, $s=0.5$, $\\mathrm{CFL}=0.95$, with $(a,b)=(\\cos\\beta,\\sin\\beta)$.\n- Case $4$ (boundary case, purely one-dimensional advection): $N_x=128$, $N_y=32$, $\\beta= 0$, $\\alpha=\\pi/4$, $s=0.5$, $\\mathrm{CFL}=0.8$, with $(a,b)=(\\cos\\beta,\\sin\\beta)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list $[\\Delta_{\\mathrm{over}}, R_{L^1}]$. For example, the output format must be\n$$\n\\text{[}[d_1,r_1],[d_2,r_2],[d_3,r_3],[d_4,r_4]\\text{]},\n$$\nwith each $d_k$ and $r_k$ printed as floating-point numbers.",
            "solution": "The problem requires the implementation and comparison of two finite-volume schemes for the two-dimensional linear advection equation,\n$$\n\\partial_t q + \\mathbf{v} \\cdot \\nabla q = 0,\n$$\nwhere $\\mathbf{v} = (a, b)$ is a constant velocity vector and $q(x,y,t)$ is a scalar field. The comparison focuses on the gradient limiting strategy used in the second-order reconstruction step on a uniform Cartesian mesh.\n\nFirst, we establish the numerical framework. The governing partial differential equation is discretized using a finite-volume method. Integrating over a control volume (cell) $\\Omega_{i,j} = [x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}] \\times [y_{j-\\frac{1}{2}}, y_{j+\\frac{1}{2}}]$ with area $|\\Omega_{i,j}| = \\Delta x \\Delta y$, and applying the divergence theorem, we obtain the semi-discrete conservation law for the cell-averaged quantity $q_{i,j}(t)$:\n$$\n\\frac{d q_{i,j}}{dt} + \\frac{1}{\\Delta x} \\left( F_{i+\\frac{1}{2},j} - F_{i-\\frac{1}{2},j} \\right) + \\frac{1}{\\Delta y} \\left( G_{i,j+\\frac{1}{2}} - G_{i,j-\\frac{1}{2}} \\right) = 0.\n$$\nHere, $F$ and $G$ are the numerical fluxes in the $x$ and $y$ directions, respectively. For linear advection, the physical fluxes are $f(q) = a q$ and $g(q) = b q$. The numerical fluxes approximate the integral of the physical flux over the cell faces. For an upwind scheme, the flux at a cell face is determined by the value of $q$ in the upwind cell. For example, at the face $x = x_{i+\\frac{1}{2}}$ between cells $(i,j)$ and $(i+1,j)$, the flux is:\n$$\nF_{i+\\frac{1}{2},j} = a^+ q_{i+\\frac{1}{2},j}^L + a^- q_{i+\\frac{1}{2},j}^R,\n$$\nwhere $a^+ = \\max(a,0)$, $a^- = \\min(a,0)$, and $q^L$ and $q^R$ are the reconstructed values of $q$ at the face, viewed from the left (cell $i,j$) and right (cell $i+1,j$) respectively.\n\nTo achieve second-order spatial accuracy, we reconstruct $q$ as a linear function within each cell:\n$$\nq(x,y) = q_{i,j} + (\\partial_x q)_{i,j} (x-x_i) + (\\partial_y q)_{i,j} (y-y_j),\n$$\nwhere $(x_i, y_j)$ is the cell center and $(\\partial_x q)_{i,j}, (\\partial_y q)_{i,j}$ are estimates of the gradient in cell $(i,j)$.\nWith this reconstruction, the left and right states at the face $x_{i+\\frac{1}{2}}$ are:\n$$\nq_{i+\\frac{1}{2},j}^L = q_{i,j} + (\\partial_x q)_{i,j} \\frac{\\Delta x}{2}\n$$\n$$\nq_{i+\\frac{1}{2},j}^R = q_{i+1,j} - (\\partial_x q)_{i+1,j} \\frac{\\Delta x}{2}\n$$\nAnalogous expressions hold for the $y$-direction faces.\n\nTo prevent spurious oscillations (Gibbs phenomenon) near discontinuities, the gradient components must be limited. This ensures the reconstruction is Total Variation Diminishing (TVD). We will use the minmod limiter. For two slopes $s_1$ and $s_2$, it is defined as:\n$$\n\\mathrm{minmod}(s_1, s_2) = \\begin{cases} \\min(s_1, s_2) & \\text{if } s_1, s_2 > 0 \\\\ \\max(s_1, s_2) & \\text{if } s_1, s_2  0 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n\nThe two required schemes differ in how they compute the limited gradient vector $\\nabla q_{i,j} = ((\\partial_x q)_{i,j}, (\\partial_y q)_{i,j})$.\n\n**1. Coordinate-wise Limiting (`axis`)**\nThis is the most straightforward extension of one-dimensional limiting to multiple dimensions. The gradient components are limited independently along each coordinate axis.\nWe first compute forward and backward difference quotients in each direction for cell $(i,j)$:\n$$\n\\Delta_x^b q = \\frac{q_{i,j}-q_{i-1,j}}{\\Delta x}, \\quad \\Delta_x^f q = \\frac{q_{i+1,j}-q_{i,j}}{\\Delta x}\n$$\n$$\n\\Delta_y^b q = \\frac{q_{i,j}-q_{i,j-1}}{\\Delta y}, \\quad \\Delta_y^f q = \\frac{q_{i,j+1}-q_{i,j}}{\\Delta y}\n$$\nThe limited gradient components are then computed by applying the minmod limiter to these difference quotients:\n$$\n(\\partial_x q)_{i,j}^{\\mathrm{axis}} = \\mathrm{minmod}(\\Delta_x^b q, \\Delta_x^f q)\n$$\n$$\n(\\partial_y q)_{i,j}^{\\mathrm{axis}} = \\mathrm{minmod}(\\Delta_y^b q, \\Delta_y^f q)\n$$\nThis approach is simple but can be overly diffusive when the flow direction is oblique to the grid, as it fails to correlate the limiting process in the different coordinate directions.\n\n**2. Directional Multi-dimensional Limiting (`dir`)**\nThis strategy aims to limit the gradient along the direction of advection, $\\mathbf{n} = \\mathbf{v} / \\|\\mathbf{v}\\|_2 = (n_x, n_y)$. Following the problem description, we first construct two estimates for the directional derivative using the forward and backward difference quotients computed above:\n$$\nS_b = n_x \\Delta_x^b q + n_y \\Delta_y^b q\n$$\n$$\nS_f = n_x \\Delta_x^f q + n_y \\Delta_y^f q\n$$\nThese represent projections of backward- and forward-biased difference vectors onto the advection direction. We then apply the minmod limiter to these directional slopes:\n$$\n\\sigma_n = \\mathrm{minmod}(S_b, S_f)\n$$\nThis limited directional slope $\\sigma_n$ is then projected back onto the advection direction vector $\\mathbf{n}$ to form the final limited gradient vector:\n$$\n\\nabla q_{i,j}^{\\mathrm{dir}} = \\sigma_n \\mathbf{n} = (\\sigma_n n_x, \\sigma_n n_y)\n$$\nThis ensures the limited gradient is always aligned with the advection velocity, fundamentally differing from the coordinate-wise approach where the limited gradient's direction can be arbitrary.\n\n**Time Discretization and Final Algorithm**\nWe use a single forward Euler step for time integration. The full update formula is:\n$$\nq_{i,j}^{n+1} = q_{i,j}^{n} - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2},j}^n - F_{i-\\frac{1}{2},j}^n\\right) - \\frac{\\Delta t}{\\Delta y}\\left(G_{i,j+\\frac{1}{2}}^n - G_{i,j-\\frac{1}{2}}^n\\right),\n$$\nwhere the fluxes are computed using the reconstructed values from one of the two limiting schemes. The time step $\\Delta t$ is chosen based on the CFL condition to ensure stability. Initial conditions are set by sampling the given step function at cell centers. The exact solution is obtained by advecting the initial condition field and applying periodic wrapping. Periodic boundary conditions are handled by using `numpy.roll` for accessing neighbor data.",
            "answer": "```python\nimport numpy as np\n\ndef minmod(s1, s2):\n    \"\"\"Vectorized minmod limiter function.\"\"\"\n    # This implementation is equivalent to the standard definition.\n    # It correctly handles arrays s1 and s2 element-wise.\n    signs = np.sign(s1) + np.sign(s2)\n    return 0.5 * signs * np.minimum(np.abs(s1), np.abs(s2))\n\ndef solve_step(q, dx, dy, dt, a, b, limiter_type):\n    \"\"\"\n    Advances the scalar field q by one time step dt.\n    \"\"\"\n    Nx, Ny = q.shape\n\n    # --- 1. Compute limited gradients ---\n    # Get neighbor values using periodic boundary conditions\n    q_im1_j = np.roll(q, 1, axis=0)\n    q_ip1_j = np.roll(q, -1, axis=0)\n    q_i_jm1 = np.roll(q, 1, axis=1)\n    q_i_jp1 = np.roll(q, -1, axis=1)\n\n    # Compute forward/backward difference quotients\n    grad_x_bwd = (q - q_im1_j) / dx\n    grad_x_fwd = (q_ip1_j - q) / dx\n    grad_y_bwd = (q - q_i_jm1) / dy\n    grad_y_fwd = (q_i_jp1 - q) / dy\n\n    if limiter_type == 'axis':\n        grad_x = minmod(grad_x_bwd, grad_x_fwd)\n        grad_y = minmod(grad_y_bwd, grad_y_fwd)\n    elif limiter_type == 'dir':\n        v_norm = np.sqrt(a**2 + b**2)\n        if v_norm == 0:\n            grad_x, grad_y = np.zeros_like(q), np.zeros_like(q)\n        else:\n            nx, ny = a / v_norm, b / v_norm\n            s_b = nx * grad_x_bwd + ny * grad_y_bwd\n            s_f = nx * grad_x_fwd + ny * grad_y_fwd\n            sigma_n = minmod(s_b, s_f)\n            grad_x = sigma_n * nx\n            grad_y = sigma_n * ny\n    else:\n        raise ValueError(\"Unknown limiter type\")\n\n    # --- 2. Reconstruct states at cell faces ---\n    # x-faces (i+1/2, j)\n    q_L_x = q + grad_x * dx / 2.0\n    q_R_x = np.roll(q, -1, axis=0) - np.roll(grad_x, -1, axis=0) * dx / 2.0\n    \n    # y-faces (i, j+1/2)\n    q_L_y = q + grad_y * dy / 2.0\n    q_R_y = np.roll(q, -1, axis=1) - np.roll(grad_y, -1, axis=1) * dy / 2.0\n\n    # --- 3. Compute upwind fluxes ---\n    # Fluxes F across x-faces\n    q_upwind_x = np.where(a > 0.0, q_L_x, q_R_x)\n    F = a * q_upwind_x\n    \n    # Fluxes G across y-faces\n    q_upwind_y = np.where(b > 0.0, q_L_y, q_R_y)\n    G = b * q_upwind_y\n\n    # --- 4. Compute flux divergence ---\n    div_F = (F - np.roll(F, 1, axis=0)) / dx\n    div_G = (G - np.roll(G, 1, axis=1)) / dy\n\n    # --- 5. Update cell averages ---\n    q_new = q - dt * (div_F + div_G)\n\n    return q_new\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute metrics.\n    \"\"\"\n    test_cases = [\n        # Case 1: Nx=128, Ny=128, beta=pi/4, alpha=pi/4, s=0.5, CFL=0.4\n        (128, 128, np.pi/4, np.pi/4, 0.5, 0.4),\n        # Case 2: Nx=200, Ny=20, beta=pi/3, alpha=pi/3, s=0.5, CFL=0.95\n        (200, 20, np.pi/3, np.pi/3, 0.5, 0.95),\n        # Case 3: Nx=40, Ny=400, beta=pi/6, alpha=pi/6, s=0.5, CFL=0.95\n        (40, 400, np.pi/6, np.pi/6, 0.5, 0.95),\n        # Case 4: Nx=128, Ny=32, beta=0, alpha=pi/4, s=0.5, CFL=0.8\n        (128, 32, 0.0, np.pi/4, 0.5, 0.8),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        Nx, Ny, beta, alpha, s, CFL = case\n        \n        # Grid setup\n        dx, dy = 1.0 / Nx, 1.0 / Ny\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        y_centers = (np.arange(Ny) + 0.5) * dy\n        xx, yy = np.meshgrid(x_centers, y_centers, indexing='ij')\n\n        # Advection velocity\n        a, b = np.cos(beta), np.sin(beta)\n        \n        # Time step calculation\n        term_x = dx / np.abs(a) if np.abs(a) > 1e-12 else np.inf\n        term_y = dy / np.abs(b) if np.abs(b) > 1e-12 else np.inf\n        dt = CFL * min(term_x, term_y)\n\n        # Initial condition\n        q0 = np.where(xx * np.cos(alpha) + yy * np.sin(alpha) > s, 1.0, 0.0)\n\n        # Run both schemes\n        q_axis = solve_step(q0, dx, dy, dt, a, b, 'axis')\n        q_dir = solve_step(q0, dx, dy, dt, a, b, 'dir')\n\n        # Exact solution at t=dt\n        x_shifted = (xx - a * dt) % 1.0\n        y_shifted = (yy - b * dt) % 1.0\n        q_exact = np.where(x_shifted * np.cos(alpha) + y_shifted * np.sin(alpha) > s, 1.0, 0.0)\n\n        # Calculate metrics\n        # 1. Overshoot difference\n        over_axis = np.max([np.max(q_axis - 1.0), np.max(0.0 - q_axis), 0.0])\n        over_dir = np.max([np.max(q_dir - 1.0), np.max(0.0 - q_dir), 0.0])\n        delta_over = over_axis - over_dir\n\n        # 2. L1 error ratio\n        err_axis = np.sum(np.abs(q_axis - q_exact))\n        err_dir = np.sum(np.abs(q_dir - q_exact))\n        \n        # Handle cases where denominator is zero (e.g., perfect solution)\n        R_L1 = err_axis / err_dir if err_dir > 1e-15 else 1.0\n        \n        all_results.append([delta_over, R_L1])\n\n    # Format output\n    result_str = \",\".join([f\"[{d:.12f},{r:.12f}]\" for d, r in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "An ideal flux limiter should be diffusive near shocks to prevent oscillations but compressive in smooth regions to resolve fine details. This advanced coding exercise guides you in designing such an adaptive limiter, which dynamically adjusts its character based on a local shock sensor. You will also tackle the practical problem of \"limiter chatter\" by implementing a hysteresis mechanism, a technique that adds memory to the switching logic to create a more stable and efficient numerical scheme.",
            "id": "3320332",
            "problem": "Consider the one-dimensional scalar linear advection equation $u_t + a u_x = 0$ on a periodic domain of length $L = 1$ with constant advection speed $a > 0$. Use a conservative finite-volume update with first-order accurate upwind fluxes augmented by a Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) reconstruction of left interface states. The MUSCL reconstruction employs a flux limiter that adapts its compressiveness based on a shock sensor and introduces hysteresis to reduce limiter chatter. All angles in trigonometric functions must be in radians.\n\nBase your derivation on the following fundamentals:\n- The scalar conservation law $u_t + a u_x = 0$ and its conservative finite-volume discretization\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(f_{i+\\frac{1}{2}}^n - f_{i-\\frac{1}{2}}^n\\right),\n$$\nwith numerical flux $f_{i+\\frac{1}{2}}^n = a\\, u_{i+\\frac{1}{2}}^{-\\,n}$ for $a>0$.\n- MUSCL left interface reconstruction for $a>0$ using a limited slope,\n$$\nu_{i+\\frac{1}{2}}^{-\\,n} = u_i^n + \\frac{1}{2}\\,\\phi\\!\\left(r_i^n; c_i^n\\right)\\,\\left(u_i^n - u_{i-1}^n\\right),\n$$\nwhere the gradient ratio $r_i^n$ is\n$$\nr_i^n = \\frac{u_i^n - u_{i-1}^n}{u_{i+1}^n - u_i^n + \\varepsilon},\n$$\nwith a small regularization parameter $\\varepsilon > 0$ to avoid division by zero.\n- The parametric flux limiter family (sometimes called the Slope Limited Centered family),\n$$\n\\phi\\!\\left(r; c\\right) = \\max\\!\\left(0,\\, \\min\\!\\left(\\min\\!\\left(c\\,r,\\,1\\right),\\,\\min\\!\\left(r,\\,c\\right)\\right)\\right),\n$$\nwhere $c \\in [1,2]$ controls compressiveness, $c=1$ recovers the minmod limiter (more diffusive) and $c=2$ recovers the superbee-like behavior (more compressive).\n- The shock sensor\n$$\nS_i^n = \\frac{\\left|u_{i+1}^n - 2\\,u_i^n + u_{i-1}^n\\right|}{\\left|u_{i+1}^n - u_i^n\\right| + \\left|u_i^n - u_{i-1}^n\\right| + \\delta},\n$$\nwith $\\delta > 0$ to avoid a vanishing denominator.\n\nDesign an adaptive compressiveness policy $c_i^n$ based on the shock sensor $S_i^n$ that incorporates hysteresis to mitigate limiter chatter. Specifically, define a binary state $H_i^n \\in \\{0,1\\}$ per cell indicating the compressiveness branch: $H_i^n = 1$ selects $c_{\\mathrm{high}}$ and $H_i^n = 0$ selects $c_{\\mathrm{low}}$, with $1 \\le c_{\\mathrm{low}}  c_{\\mathrm{high}} \\le 2$. Use two thresholds $S_{\\mathrm{low}}  S_{\\mathrm{high}}$ to implement hysteresis transitions:\n- If $H_i^n = 1$ and $S_i^n \\ge S_{\\mathrm{high}}$, then $H_i^{n+} = 0$; otherwise $H_i^{n+} = H_i^n$.\n- If $H_i^n = 0$ and $S_i^n \\le S_{\\mathrm{low}}$, then $H_i^{n+} = 1$; otherwise $H_i^{n+} = H_i^n$.\n\nAs a non-hysteretic baseline, define a single-threshold policy with $S_{\\mathrm{thr}} = \\left(S_{\\mathrm{low}} + S_{\\mathrm{high}}\\right)/2$:\n- At each time step, set $c_i^n = c_{\\mathrm{high}}$ if $S_i^n \\le S_{\\mathrm{thr}}$ and $c_i^n = c_{\\mathrm{low}}$ otherwise.\n\nImplement both the hysteretic and non-hysteretic policies in a MUSCL scheme for $a>0$ with periodic boundary conditions. For each method, define the limiter chatter count as the total number of binary state transitions across all cells and time steps. Assess accuracy by the discrete $L^1$ error at final time $T$ against the exact solution $u(x,T) = u_0(x - aT)$ with periodic wrap-around, where $u_0(x)$ is the initial condition.\n\nYour program must:\n- Initialize the solution $u_i^0$ from a continuous initial condition $u_0(x)$ evaluated at grid points $x_i = i\\,\\Delta x$, with $i=0,\\dots,N-1$, $\\Delta x = L/N$, $L=1$.\n- Use forward Euler time stepping with Courant–Friedrichs–Lewy number $\\lambda = a\\,\\Delta t/\\Delta x \\in (0,1]$.\n- Compute the shock sensor $S_i^n$, gradient ratio $r_i^n$, limiter $\\phi(r_i^n;c_i^n)$, and perform updates for both the hysteretic and non-hysteretic policies.\n- Record the total chatter counts and the final-time $L^1$ errors for both methods.\n\nTest suite:\n- Case A (mixed smooth and discontinuous): $N=256$, $a=1$, $\\lambda=0.5$, $T=0.25$, $c_{\\mathrm{low}}=1.0$, $c_{\\mathrm{high}}=2.0$, $S_{\\mathrm{low}}=0.2$, $S_{\\mathrm{high}}=0.4$, $\\delta=\\varepsilon=10^{-12}$, initial condition\n$$\nu_0(x) = \\begin{cases}\n0.5 + 0.5\\,\\sin(2\\pi x),  0 \\le x  0.7,\\\\\n1,  0.7 \\le x  0.85,\\\\\n0,  0.85 \\le x  1.\n\\end{cases}\n$$\n- Case B (smooth with multi-scale content): $N=256$, $a=1$, $\\lambda=0.5$, $T=0.25$, $c_{\\mathrm{low}}=1.0$, $c_{\\mathrm{high}}=2.0$, $S_{\\mathrm{low}}=0.1$, $S_{\\mathrm{high}}=0.3$, $\\delta=\\varepsilon=10^{-12}$, initial condition\n$$\nu_0(x) = 0.5 + 0.4\\,\\sin(2\\pi x) + 0.05\\,\\sin(16\\pi x).\n$$\n- Case C (constant state edge case): $N=128$, $a=1$, $\\lambda=0.5$, $T=0.25$, $c_{\\mathrm{low}}=1.0$, $c_{\\mathrm{high}}=2.0$, $S_{\\mathrm{low}}=0.2$, $S_{\\mathrm{high}}=0.4$, $\\delta=\\varepsilon=10^{-12}$, initial condition\n$$\nu_0(x) = 0.3.\n$$\n\nFor each case, compute and return the four quantities in the following order:\n1. Total chatter count for the non-hysteretic policy (integer).\n2. Total chatter count for the hysteretic policy (integer).\n3. Final-time discrete $L^1$ error for the non-hysteretic policy (float).\n4. Final-time discrete $L^1$ error for the hysteretic policy (float).\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all three cases as a comma-separated list of lists with no spaces, for example: \n- \"[[cA_no,cA_hyst,eA_no,eA_hyst],[cB_no,cB_hyst,eB_no,eB_hyst],[cC_no,cC_hyst,eC_no,eC_hyst]]\".",
            "solution": "The problem requires the implementation and comparison of two adaptive flux limiter policies within a Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) for the one-dimensional linear advection equation, $u_t + a u_x = 0$. The policies adjust the compressiveness of the limiter based on a local shock sensor, with one policy incorporating hysteresis to mitigate limiter chatter.\n\nThe numerical framework is a conservative finite-volume method. The domain of length $L=1$ is discretized into $N$ cells of uniform width $\\Delta x = L/N$. The solution in cell $i$ at time step $n$, denoted by the cell average $u_i^n$, is updated using the formula:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(f_{i+\\frac{1}{2}}^n - f_{i-\\frac{1}{2}}^n\\right)\n$$\nHere, $\\Delta t$ is the time step, and $f_{i\\pm\\frac{1}{2}}^n$ are the numerical fluxes at the cell interfaces. Given the advection speed $a > 0$, an upwind scheme is used, meaning the flux is determined by the state on the left of the interface. Specifically, the numerical flux is $f_{i+\\frac{1}{2}}^n = a\\, u_{i+\\frac{1}{2}}^{-\\,n}$, where $u_{i+\\frac{1}{2}}^{-\\,n}$ is the reconstructed value of the solution on the left side of the interface between cells $i$ and $i+1$.\n\nThe MUSCL method achieves higher-order accuracy by performing a piecewise linear reconstruction of the solution within each cell. The value at the left of the interface $i+\\frac{1}{2}$ is reconstructed from data in cell $i$ and its neighbors:\n$$\nu_{i+\\frac{1}{2}}^{-\\,n} = u_i^n + \\frac{1}{2}\\,\\phi\\!\\left(r_i^n; c_i^n\\right)\\,\\left(u_i^n - u_{i-1}^n\\right)\n$$\nThis formula adds a limited correction term to the first-order value $u_i^n$. The term $u_i^n - u_{i-1}^n$ represents the backward difference, an approximation of the local gradient. The function $\\phi$ is a flux limiter, which is an essential component for preventing spurious oscillations near steep gradients or discontinuities.\n\nThe limiter function $\\phi(r_i^n; c_i^n)$ depends on the ratio of consecutive gradients, $r_i^n$, defined as:\n$$\nr_i^n = \\frac{u_i^n - u_{i-1}^n}{u_{i+1}^n - u_i^n + \\varepsilon}\n$$\nThe parameter $\\varepsilon$ is a small positive number ($10^{-12}$) to prevent division by zero in regions of constant state. The specific flux limiter to be used is from the parametric family:\n$$\n\\phi\\!\\left(r; c\\right) = \\max\\!\\left(0,\\, \\min\\!\\left(\\min\\!\\left(c\\,r,\\,1\\right),\\,\\min\\!\\left(r,\\,c\\right)\\right)\\right)\n$$\nThe parameter $c \\in [1, 2]$ controls the \"compressiveness\" of the scheme. A value of $c=1$ corresponds to the more diffusive minmod limiter, while $c=2$ yields a more compressive, superbee-like limiter which is better at resolving sharp features but can be more oscillatory.\n\nThe core of the problem is to adapt the parameter $c_i^n$ for each cell $i$ at each time step $n$ based on the local smoothness of the solution. This is achieved using a shock sensor $S_i^n$:\n$$\nS_i^n = \\frac{\\left|u_{i+1}^n - 2\\,u_i^n + u_{i-1}^n\\right|}{\\left|u_{i+1}^n - u_i^n\\right| + \\left|u_i^n - u_{i-1}^n\\right| + \\delta}\n$$\nThis sensor measures the local second derivative relative to the first derivative. A large value of $S_i^n$ (close to $1$) indicates a sharp gradient or shock, while a small value suggests a smooth region. The parameter $\\delta$, like $\\varepsilon$, is a small value ($10^{-12}$) to avoid division by zero.\n\nTwo policies for adapting $c_i^n$ based on $S_i^n$ are evaluated:\n\n1.  **Non-Hysteretic Policy**: This is a simple, single-threshold approach. A threshold $S_{\\mathrm{thr}} = (S_{\\mathrm{low}} + S_{\\mathrm{high}})/2$ is defined. At each time step, the compressiveness parameter for cell $i$ is set as follows:\n    $$\n    c_i^n =\n    \\begin{cases}\n    c_{\\mathrm{high}}  \\text{if } S_i^n \\le S_{\\mathrm{thr}} \\quad \\text{(smooth region)} \\\\\n    c_{\\mathrm{low}}  \\text{if } S_i^n > S_{\\mathrm{thr}} \\quad \\text{(non-smooth region)}\n    \\end{cases}\n    $$\n    This policy aims to use a more compressive limiter in smooth regions to maintain accuracy and a more diffusive limiter near shocks to ensure stability. A potential drawback is \"limiter chatter,\" where $c_i^n$ rapidly switches between $c_{\\mathrm{low}}$ and $c_{\\mathrm{high}}$ if $S_i^n$ hovers around $S_{\\mathrm{thr}}$.\n\n2.  **Hysteretic Policy**: This policy introduces memory to the system to suppress chatter. It uses a binary state variable $H_i^n \\in \\{0, 1\\}$ for each cell. The compressiveness is set by $c_i^n = c_{\\mathrm{high}}$ if $H_i^n=1$ and $c_i^n=c_{\\mathrm{low}}$ if $H_i^n=0$. The state $H_i^n$ is updated using two distinct thresholds, $S_{\\mathrm{low}}$ and $S_{\\mathrm{high}}$, with $S_{\\mathrm{low}}  S_{\\mathrm{high}}$:\n    - If the system is in the high-compressiveness state ($H_i^n = 1$) and the shock sensor exceeds the upper threshold ($S_i^n \\ge S_{\\mathrm{high}}$), it switches to the low-compressiveness state: $H_i^{n+1} = 0$.\n    - If the system is in the low-compressiveness state ($H_i^n = 0$) and the shock sensor drops below the lower threshold ($S_i^n \\le S_{\\mathrm{low}}$), it switches to the high-compressiveness state: $H_i^{n+1} = 1$.\n    - Otherwise, the state remains unchanged: $H_i^{n+1} = H_i^n$.\n    The gap between $S_{\\mathrm{low}}$ and $S_{\\mathrm{high}}$ creates a \"dead zone\" that prevents the state from switching back and forth due to small fluctuations in $S_i^n$, thus reducing chatter.\n\nThe implementation proceeds by discretizing the initial condition $u_0(x)$ on a grid of $N$ points. The system is then evolved in time using forward Euler stepping with a fixed Courant number $\\lambda = a \\Delta t / \\Delta x$. At each time step, for each cell $i$, the algorithm computes the necessary differences, the shock sensor $S_i^n$, chooses $c_i^n$ based on the chosen policy, computes the gradient ratio $r_i^n$ and limiter $\\phi_i^n$, reconstructs all interface values $u_{i+1/2}^{-,n}$, and finally updates the cell averages $u_i^{n+1}$. The update is implemented as $u_i^{n+1} = u_i^n - \\lambda (u_{i+1/2}^{-,n} - u_{i-1/2}^{-,n})$, which is equivalent to the conservative form. Periodic boundary conditions are handled using array-rolling operations.\n\nThe performance of each policy is quantified by two metrics: the total chatter count, which is the sum of all state transitions over all cells and all time steps, and the discrete $L^1$ error at the final time $T$, computed as $\\sum_{i=0}^{N-1} |u_i^{\\text{final}} - u_{\\text{exact}}(x_i, T)| \\Delta x$, where $u_{\\text{exact}}(x, T) = u_0(x-aT \\pmod 1)$. The initial state for the hysteretic policy, $H_i^0$, is determined using the non-hysteretic rule at time $t=0$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that runs simulations for all test cases and prints the results.\n    \"\"\"\n\n    def get_u0_A(x):\n        \"\"\"Initial condition for Case A.\"\"\"\n        return np.piecewise(x,\n                            [(x >= 0)  (x  0.7), (x >= 0.7)  (x  0.85)],\n                            [lambda v: 0.5 + 0.5 * np.sin(2 * np.pi * v), 1.0, 0.0])\n\n    def get_u0_B(x):\n        \"\"\"Initial condition for Case B.\"\"\"\n        return 0.5 + 0.4 * np.sin(2 * np.pi * x) + 0.05 * np.sin(16 * np.pi * x)\n\n    def get_u0_C(x):\n        \"\"\"Initial condition for Case C.\"\"\"\n        return 0.3 * np.ones_like(x)\n\n    def run_simulation(N, a, lam, T, c_low, c_high, S_low, S_high, delta, epsilon, u0_func, policy):\n        \"\"\"\n        Runs a single simulation for a given policy ('hysteretic' or 'non_hysteretic').\n        \"\"\"\n        L = 1.0\n        dx = L / N\n        dt = lam * dx / a\n        num_steps = int(round(T / dt))\n\n        u = u0_func(x)\n        chatter_count = 0\n        \n        S_thr = (S_low + S_high) / 2.0\n\n        # Policy-specific state initialization\n        if policy == 'hysteretic':\n            # Initial H state based on non-hysteretic rule\n            u_im1 = np.roll(u, 1)\n            u_ip1 = np.roll(u, -1)\n            du_left = u - u_im1\n            du_right = u_ip1 - u\n            sensor_num = np.abs(du_right - du_left)\n            sensor_den = np.abs(du_right) + np.abs(du_left) + delta\n            S = sensor_num / sensor_den\n            H = np.where(S = S_thr, 1, 0)\n        elif policy == 'non_hysteretic':\n            # Initial state for chatter counting\n            u_im1 = np.roll(u, 1)\n            u_ip1 = np.roll(u, -1)\n            du_left = u - u_im1\n            du_right = u_ip1 - u\n            sensor_num = np.abs(du_right - du_left)\n            sensor_den = np.abs(du_right) + np.abs(du_left) + delta\n            S = sensor_num / sensor_den\n            C_state = np.where(S = S_thr, 1, 0) # 1 for high, 0 for low\n\n        for _ in range(num_steps):\n            u_im1 = np.roll(u, 1)\n            u_ip1 = np.roll(u, -1)\n\n            du_left = u - u_im1  # u_i - u_{i-1}\n            du_right = u_ip1 - u # u_{i+1} - u_i\n            \n            sensor_num = np.abs(du_right - du_left)\n            sensor_den = np.abs(du_right) + np.abs(du_left) + delta\n            S = sensor_num / sensor_den\n            \n            if policy == 'hysteretic':\n                H_old = H.copy()\n                # Apply transition rules based on H_old\n                H[(H_old == 1)  (S >= S_high)] = 0\n                H[(H_old == 0)  (S = S_low)] = 1\n                chatter_count += np.sum(H != H_old)\n                c = np.where(H == 1, c_high, c_low)\n            elif policy == 'non_hysteretic':\n                C_state_old = C_state.copy()\n                C_state = np.where(S = S_thr, 1, 0)\n                chatter_count += np.sum(C_state != C_state_old)\n                c = np.where(C_state == 1, c_high, c_low)\n            \n            r_num = du_left\n            r_den = du_right + epsilon\n            r = r_num / r_den\n\n            # Limiter function: phi(r,c) = max(0, min(min(c*r, 1), min(r, c)))\n            min1 = np.minimum(c * r, 1.0)\n            min2 = np.minimum(r, c)\n            phi = np.maximum(0.0, np.minimum(min1, min2))\n            \n            # Reconstruct left interface states\n            u_interface_minus = u + 0.5 * phi * du_left\n            \n            # Compute fluxes\n            F = a * u_interface_minus\n            \n            # Update cell averages\n            F_diff = F - np.roll(F, 1)\n            u = u - (lam / a) * F_diff\n        \n        # Calculate L1 error\n        x_shifted = np.mod(x - a * T, L)\n        u_exact = u0_func(x_shifted)\n        l1_error = np.sum(np.abs(u - u_exact)) * dx\n        \n        return int(chatter_count), float(l1_error)\n\n    test_cases = [\n        # Case A\n        {'N': 256, 'a': 1.0, 'lam': 0.5, 'T': 0.25, 'c_low': 1.0, 'c_high': 2.0,\n         'S_low': 0.2, 'S_high': 0.4, 'delta': 1e-12, 'epsilon': 1e-12, 'u0_func': get_u0_A},\n        # Case B\n        {'N': 256, 'a': 1.0, 'lam': 0.5, 'T': 0.25, 'c_low': 1.0, 'c_high': 2.0,\n         'S_low': 0.1, 'S_high': 0.3, 'delta': 1e-12, 'epsilon': 1e-12, 'u0_func': get_u0_B},\n        # Case C\n        {'N': 128, 'a': 1.0, 'lam': 0.5, 'T': 0.25, 'c_low': 1.0, 'c_high': 2.0,\n         'S_low': 0.2, 'S_high': 0.4, 'delta': 1e-12, 'epsilon': 1e-12, 'u0_func': get_u0_C}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_results = []\n        \n        # Non-hysteretic policy\n        chatter_non, error_non = run_simulation(**case, policy='non_hysteretic')\n        \n        # Hysteretic policy\n        chatter_hyst, error_hyst = run_simulation(**case, policy='hysteretic')\n        \n        case_results.extend([chatter_non, chatter_hyst, error_non, error_hyst])\n        all_results.append(case_results)\n\n    # Format output string\n    result_str = f\"[{','.join([f'[{\",\".join(map(str, r))}]' for r in all_results])}]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}