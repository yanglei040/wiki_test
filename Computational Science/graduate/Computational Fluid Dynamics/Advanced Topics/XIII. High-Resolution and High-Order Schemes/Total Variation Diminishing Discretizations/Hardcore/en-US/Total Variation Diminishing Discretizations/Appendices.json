{
    "hands_on_practices": [
        {
            "introduction": "The effectiveness of a Total Variation Diminishing (TVD) scheme hinges on the choice of flux limiter, which navigates the trade-off between numerical diffusion and sharpness at discontinuities. This practice provides a direct comparison of how different popular limiters—minmod, Monotonized Central (MC), and superbee—perform by tracking the evolution of the total variation for a simple advected step. Observing this evolution offers quantitative insight into the \"aggressiveness\" of each limiter in preserving sharp fronts. ",
            "id": "3383804",
            "problem": "Consider the linear advection equation in conservative form for a scalar field $u(x,t)$ with constant advection speed $a$,\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(a\\,u\\right) = 0,\n$$\nposed on a periodic domain of length $L$. Let the initial condition be a unit step with left state $u_L$ and right state $u_R$, positioned at a point $x_s \\in [0,L)$, and let the spatial grid be uniform with $N_x$ control volumes. The goal is to numerically study how the total variation evolves under high-resolution second-order Total Variation Diminishing (TVD) Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL) using three different flux limiters: minmod, Monotonized Central (MC), and superbee.\n\nBase your derivation and implementation on the following foundational principles and facts:\n- Conservation-law finite volume update for cell averages $u_i^n$ with a consistent numerical flux $F_{i+1/2}^n$,\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right).\n$$\n- The Courant number $C$ is given by $C = a\\,\\Delta t / \\Delta x$.\n- The total variation of a grid function $u^n = \\{u_i^n\\}$ on a periodic grid is\n$$\nTV(u^n) = \\sum_{i=0}^{N_x-1} \\left|u_{i+1}^n - u_i^n\\right|,\n$$\nwith periodic indexing so that $u_{N_x}^n \\equiv u_0^n$.\n- For constant $a0$, a high-resolution TVD flux-limiter method consistent with the Sweby framework combines an upwind monotone flux with a limited high-order correction depending on the local smoothness ratio $r_i$ and a limiter function $\\phi(r)$, such that the scheme is second-order accurate in smooth regions and reduces to a monotone upwind method near discontinuities. Assume standard MUSCL-type reconstruction with $r_i$ defined by one-sided discrete gradients and a limiter $\\phi(r)$ belonging to the classical TVD admissible set.\n\nUse the following limiter functions defined on the smoothness ratio $r$ (with the convention that if the denominator in $r$ is zero, then $r=0$ is to be used):\n- Minmod limiter: $\\phi_{\\text{MM}}(r) = \\max\\left(0, \\min\\left(1, r\\right)\\right)$.\n- Monotonized Central limiter: $\\phi_{\\text{MC}}(r) = \\max\\left(0, \\min\\left(\\frac{1+r}{2}, 2, 2r\\right)\\right)$.\n- Superbee limiter: $\\phi_{\\text{SB}}(r) = \\max\\left(0, \\min\\left(2r,1\\right), \\min\\left(r,2\\right)\\right)$.\n\nYour task is to:\n- Derive a conservative second-order MUSCL-type TVD discretization for the linear advection equation with the above limiters, ensuring it respects the Total Variation Diminishing property for Courant numbers $C$ in the admissible range.\n- Implement the derived method and compute the total variation $TV(u^n)$ at selected time steps for a periodic step initial condition, under the same Courant number across all three limiters, to compare limiter aggressiveness via the evolution of total variation.\n\nImplementation details to use for this study:\n- Domain: periodic interval $[0,L)$ with $L = 1$.\n- Advection speed: $a = 1$.\n- Number of grid cells: $N_x = 400$.\n- Initial condition: $u(x,0) = u_L$ for $x  x_s$ and $u(x,0) = u_R$ for $x \\ge x_s$, with $u_L = 1$, $u_R = 0$, and $x_s = 0.3$.\n- Time integration: explicit single-step update as per the conservative finite-volume method with a MUSCL-type TVD numerical flux consistent with the above principles. Periodic boundary conditions must be enforced.\n- Courant numbers and sampling schedule (test suite):\n    - Test A (happy path): $C = 0.8$, evolve for $N_{\\text{steps}} = 80$ time steps and record total variation at time steps $n \\in \\{0,10,20,40,80\\}$.\n    - Test B (diffusive edge): $C = 0.2$, evolve for $N_{\\text{steps}} = 80$ and record $TV(u^n)$ at the same set of steps $n \\in \\{0,10,20,40,80\\}$.\n    - Test C (CFL boundary): $C = 1.0$, evolve for $N_{\\text{steps}} = 80$ and record $TV(u^n)$ at the same set of steps $n \\in \\{0,10,20,40,80\\}$.\n- For each test, compute and report the sequence of total variations for each limiter in the order: minmod, MC, superbee.\n\nYour program must produce a single line of output containing all results aggregated into one flat list of floating-point values, ordered as follows: for each test in the order A, B, C, and within each test for each limiter in the order minmod, MC, superbee, append the total variation values at the steps $n \\in \\{0,10,20,40,80\\}$ in increasing order of $n$. The final output format must be a single Python-style list on one line, for example,\n\"[v_1,v_2, ... , v_M]\",\nwhere each $v_k$ is a floating-point number representing one measured total variation. No physical units are required for the output since $TV(u^n)$ is dimensionless.",
            "solution": "We start from the linear advection equation for a scalar $u(x,t)$ with constant advection speed $a$,\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(a\\,u\\right) = 0,\n$$\non a periodic domain. The conservative finite volume method updates cell averages $u_i^n$ via\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right),\n$$\nwhere $F_{i+1/2}^n$ is a consistent numerical flux approximating $a\\,u$ at the interface between cells $i$ and $i+1$. For a constant $a0$, a monotone upwind flux is $F_{i+1/2}^{\\text{up}} = a\\,u_i^n$. This yields a first-order method that is Total Variation Diminishing (TVD) but diffusive. To restore second-order accuracy in smooth regions while retaining TVD properties near discontinuities, we adopt a high-resolution MUSCL (Monotonic Upstream-centered Schemes for Conservation Laws) flux-limiter approach consistent with the Sweby framework.\n\nThe Courant number is $C = a\\,\\Delta t/\\Delta x$, and for $0 \\le C \\le 1$ the TVD property can be ensured with suitable limiters. The key idea is to correct the upwind flux by a limited high-order term based on local smoothness. Define forward and backward differences $\\Delta^+ u_i = u_{i+1}^n - u_i^n$ and $\\Delta^- u_i = u_i^n - u_{i-1}^n$, and define the smoothness ratio\n$$\nr_i = \\frac{\\Delta^- u_i}{\\Delta^+ u_i},\n$$\nwith the convention $r_i = 0$ whenever $\\Delta^+ u_i = 0$ to avoid division by zero and to remain within the TVD monotone upwind baseline in flat regions. A general second-order TVD flux for $a0$ consistent with the Sweby diagram takes the form\n$$\nF_{i+1/2}^n = a\\,u_i^n + \\frac{1}{2}\\,a\\,\\left(1 - C\\right)\\,\\phi(r_i)\\,\\left(u_{i+1}^n - u_i^n\\right),\n$$\nwhere $\\phi(r)$ is a limiter function constrained to the TVD admissible region so that the resulting scheme is TVD for $0 \\le C \\le 1$. The Total Variation Diminishing property is understood as\n$$\nTV(u^{n+1}) \\le TV(u^n),\n$$\nwhere for periodic data\n$$\nTV(u^n) = \\sum_{i=0}^{N_x-1} \\left|u_{i+1}^n - u_i^n\\right|, \\quad u_{N_x}^n \\equiv u_0^n.\n$$\n\nWe employ three classical limiter functions:\n- Minmod: $\\phi_{\\text{MM}}(r) = \\max\\left(0,\\min\\left(1,r\\right)\\right)$, aggressively limiting to avoid spurious oscillations and thus introducing more numerical diffusion relative to other TVD limiters.\n- Monotonized Central (MC): $\\phi_{\\text{MC}}(r) = \\max\\left(0, \\min\\left(\\frac{1+r}{2}, 2, 2r\\right)\\right)$, a balanced limiter with moderate compressiveness and good accuracy in smooth regions.\n- Superbee: $\\phi_{\\text{SB}}(r) = \\max\\left(0,\\min\\left(2r,1\\right),\\min\\left(r,2\\right)\\right)$, a highly compressive limiter that best preserves sharp discontinuities while remaining TVD for $0 \\le C \\le 1$.\n\nPrinciple-based justification:\n- The discretization is conservative by construction since it updates through flux differences, ensuring that the domain-integrated quantity $\\sum_i u_i^n$ is preserved under periodic boundaries.\n- The TVD property follows from Harten’s theorem for monotone fluxes with limited antidiffusive corrections bounded by the Sweby constraints. The choice $F_{i+1/2}^n = F_{i+1/2}^{\\text{up}} +$ limited correction keeps the modified scheme within the TVD class when $0 \\le C \\le 1$ and $\\phi(r)$ lies in the admissible set.\n- For $C = 1$, the high-order correction term vanishes and the scheme reduces exactly to the upwind method with $u_i^{n+1} = u_{i-1}^n$, i.e., a pure shift by one cell, which preserves total variation exactly. For $0  C  1$, the correction provides second-order accuracy in smooth regions, while limiting enforces non-oscillatory behavior near discontinuities.\n\nAlgorithmic design:\n- Initialize a uniform grid with $N_x = 400$ on $[0,1)$ with cell centers $x_i = \\left(i + \\frac{1}{2}\\right)\\Delta x$, where $\\Delta x = L/N_x$ and $L=1$.\n- Initialize $u_i^0 = u_L$ if $x_i  x_s$ and $u_R$ otherwise, with $u_L = 1$, $u_R = 0$, and $x_s = 0.3$. Under periodicity, this creates two jumps and hence $TV(u^0) \\approx 2$.\n- For each test Courant number $C \\in \\{0.8,0.2,1.0\\}$, set $\\Delta t = C\\,\\Delta x/a$ with $a=1$. Evolve for $N_{\\text{steps}} = 80$ by repeating:\n    - Compute periodic forward differences $\\Delta^+ u_i$ and backward differences $\\Delta^- u_i$.\n    - Form $r_i = \\Delta^- u_i/\\Delta^+ u_i$ where $\\Delta^+ u_i \\ne 0$, otherwise set $r_i=0$.\n    - Evaluate $\\phi(r_i)$ for the chosen limiter.\n    - Assemble fluxes $F_{i+1/2}^n = a\\,u_i^n + \\frac{1}{2}a(1-C)\\phi(r_i)\\,\\Delta^+ u_i$ for all interfaces with periodic indexing.\n    - Update $u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right)$ using periodic shifts to obtain $F_{i-1/2}^n$.\n    - At specified time steps $n \\in \\{0,10,20,40,80\\}$, compute $TV(u^n)$ by summing $|\\Delta^+ u_i|$ over all $i$ with periodic indexing.\n- Repeat the above for each limiter choice: minmod, MC, superbee.\n\nExpected qualitative behavior:\n- For $C = 0.8$ (happy path), minmod will damp total variation more aggressively, MC will retain more variation, and superbee will preserve the most variation and the sharpest front while remaining TVD.\n- For $C = 0.2$ (more diffusive due to smaller Courant number), all limiters will show a more pronounced decay in total variation, with the ordering of aggressiveness unchanged: minmod most diffusive, superbee least.\n- For $C = 1.0$ (Courant–Friedrichs–Lewy boundary), the correction vanishes and the method reduces to pure upwind translation by one cell per time step, preserving $TV$ exactly for this linear problem.\n\nTest suite and output:\n- Test A: $C=0.8$, record $TV$ at $n \\in \\{0,10,20,40,80\\}$ for the three limiters in the order minmod, MC, superbee.\n- Test B: $C=0.2$, same sampling.\n- Test C: $C=1.0$, same sampling.\n- The program must output a single line with a flat Python-style list of floating-point values ordered as follows: Test A minmod sequence, Test A MC sequence, Test A superbee sequence, then Test B in the same order, then Test C in the same order.\n\nSince $TV(u^n)$ is dimensionless, no units are required in the final answer. The numerical scheme and sampling as described are sufficient to compute all requested values, and Total Variation Diminishing behavior should manifest as a non-increasing sequence within each limiter’s sampled times, with the superbee limiter showing the least decay in total variation across the same time horizon compared to MC and minmod.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef phi_minmod(r):\n    # phi_MM(r) = max(0, min(1, r))\n    return np.maximum(0.0, np.minimum(1.0, r))\n\ndef phi_mc(r):\n    # phi_MC(r) = max(0, min((1+r)/2, 2, 2r))\n    a = (1.0 + r) / 2.0\n    b = 2.0 * np.ones_like(r)\n    c = 2.0 * r\n    return np.maximum(0.0, np.minimum(np.minimum(a, b), c))\n\ndef phi_superbee(r):\n    # phi_SB(r) = max(0, min(2r, 1), min(r, 2))\n    return np.maximum(0.0, np.maximum(np.minimum(2.0 * r, 1.0), np.minimum(r, 2.0)))\n\ndef compute_tv(u):\n    \"\"\"Total variation on periodic grid.\"\"\"\n    return np.sum(np.abs(np.roll(u, -1) - u))\n\ndef muscl_tvd_advection_tv_sequence(C, limiter_name, Nx=400, L=1.0, a=1.0, nsteps=80, checkpoints=(0,10,20,40,80)):\n    \"\"\"\n    Compute TV sequence for linear advection using a MUSCL-type TVD flux-limiter scheme.\n    Periodic boundaries. Step initial condition: u_L=1 for xx_s and u_R=0 else.\n    \"\"\"\n    dx = L / Nx\n    dt = C * dx / a\n\n    # Grid cell centers\n    x = (np.arange(Nx) + 0.5) * dx\n    # Step initial condition\n    x_s = 0.3\n    uL, uR = 1.0, 0.0\n    u = np.where(x  x_s, uL, uR).astype(float)\n\n    # Choose limiter function\n    if limiter_name == 'minmod':\n        phi = phi_minmod\n    elif limiter_name == 'mc':\n        phi = phi_mc\n    elif limiter_name == 'superbee':\n        phi = phi_superbee\n    else:\n        raise ValueError(\"Unknown limiter\")\n\n    eps = 1e-14\n    tvs = []\n    checkpoint_set = set(checkpoints)\n    max_step = nsteps\n\n    # Record initial TV if requested\n    if 0 in checkpoint_set:\n        tvs.append(compute_tv(u))\n\n    for n in range(1, max_step + 1):\n        # Periodic differences\n        du_plus = np.roll(u, -1) - u\n        du_minus = u - np.roll(u, 1)\n\n        # Smoothness ratio r = du_minus / du_plus with safe handling of zero denominator\n        denom = du_plus\n        r = np.zeros_like(u)\n        mask = np.abs(denom)  eps\n        r[mask] = du_minus[mask] / denom[mask]\n\n        # Limiter values\n        phi_r = phi(r)\n\n        # Numerical flux at i+1/2 for a  0:\n        # F_{i+1/2} = a*u_i + 0.5*a*(1 - C)*phi(r_i)*(u_{i+1} - u_i)\n        F_iphalf = a * (u + 0.5 * (1.0 - C) * phi_r * du_plus)\n\n        # Update: u^{n+1} = u^n - (dt/dx) * (F_{i+1/2} - F_{i-1/2})\n        u = u - (dt / dx) * (F_iphalf - np.roll(F_iphalf, 1))\n\n        if n in checkpoint_set:\n            tvs.append(compute_tv(u))\n\n    # Ensure ordering of outputs matches the checkpoints tuple order\n    # The tvs currently appended in time order for requested checkpoints.\n    # If 0 was included, it's first; otherwise, tvs starts at first positive checkpoint.\n    # To be safe, rebuild according to exact checkpoints order.\n    # Re-simulating to reorder would be expensive; instead, we regenerate with storage by step.\n    # However, since we appended exactly when encountered and checkpoints are increasing, tvs\n    # is in the same order as checkpoints. We'll assert this assumption:\n    if len(tvs) != len(checkpoints):\n        # In case 0 not in checkpoints, we need to recompute mapping:\n        # But per our use, checkpoints always include 0.\n        pass\n    return tvs\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (Courant number C, total steps, checkpoints)\n    test_cases = [\n        (0.8, 80, (0, 10, 20, 40, 80)),  # Test A: happy path\n        (0.2, 80, (0, 10, 20, 40, 80)),  # Test B: diffusive edge\n        (1.0, 80, (0, 10, 20, 40, 80)),  # Test C: CFL boundary\n    ]\n\n    limiters = ['minmod', 'mc', 'superbee']  # Order: minmod, MC, superbee\n\n    results = []\n    for C, nsteps, checkpoints in test_cases:\n        for lim in limiters:\n            tv_seq = muscl_tvd_advection_tv_sequence(C, lim, Nx=400, L=1.0, a=1.0, nsteps=nsteps, checkpoints=checkpoints)\n            # Append sequence to results\n            results.extend(tv_seq)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "A numerical scheme is only truly Total Variation Diminishing if the combination of its spatial and temporal discretizations preserves this property. This exercise focuses on verifying the TVD nature of a complete high-resolution scheme, coupling second-order Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL) reconstruction with a Strong Stability Preserving (SSP) Runge-Kutta time integrator. By simulating the advection of a square wave, you will numerically confirm that the total variation does not increase, a cornerstone guarantee of non-oscillatory shock-capturing methods. ",
            "id": "3383807",
            "problem": "Consider the one-dimensional scalar linear advection equation, a canonical conservation law in computational fluid dynamics, given by $u_t + a u_x = 0$ for a constant velocity $a$ on a periodic domain $x \\in [0,1]$. The objective is to numerically advect a square wave over one full period using a second-order spatial discretization with Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL) reconstruction and the minmod limiter, coupled with the Harten–Lax–van Leer (HLL) numerical flux and a two-stage Strong Stability Preserving Runge–Kutta method. The evolution must be conducted at Courant–Friedrichs–Lewy (CFL) number $\\nu = a \\Delta t / \\Delta x = 0.8$ (i.e., $\\lambda a = 0.8$ where $\\lambda=\\Delta t/\\Delta x$), and you must verify numerically that the total variation does not increase during the evolution.\n\nFundamental base:\n- Conservation law for advection: $u_t + a u_x = 0$.\n- Definition of total variation for a discrete periodic field $\\{u_i\\}_{i=0}^{N-1}$: $TV(u) = \\sum_{i=0}^{N-1} \\left| u_{i+1} - u_i \\right|$, with periodic indexing $u_N \\equiv u_0$.\n- Total Variation Diminishing (TVD) principle: Under appropriate monotonicity conditions and time-stepping constraints, certain discretizations do not increase total variation.\n\nImplement the following numerical method:\n- Spatial grid: Uniform mesh with $N$ cells, $\\Delta x = 1/N$. Use periodic indexing (i.e., $i+N \\equiv i$).\n- Time step: $\\Delta t = \\nu \\Delta x / |a|$ with $\\nu = 0.8$.\n- Final time: One period $T = 1/|a|$, so the exact solution after time $T$ equals the initial condition advected once around the domain.\n- MUSCL reconstruction: For each cell $i$, compute the minmod-limited slope $\\sigma_i = \\operatorname{minmod}(u_i - u_{i-1}, u_{i+1} - u_i)$, and reconstruct interface states at $x_{i+1/2}$ by $u^{L}_{i+1/2} = u_i + \\frac{1}{2}\\sigma_i$ and $u^{R}_{i+1/2} = u_{i+1} - \\frac{1}{2}\\sigma_{i+1}$.\n- HLL flux for scalar advection: Use the fact that for constant advection speed, the HLL flux reduces to upwind selection. Specifically, for $a  0$, $F_{i+1/2} = a \\, u^{L}_{i+1/2}$; for $a  0$, $F_{i+1/2} = a \\, u^{R}_{i+1/2}$; for $a = 0$, $F_{i+1/2} = 0$.\n- Semi-discrete update operator: $L(u)_i = -\\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x}$.\n- Two-stage Strong Stability Preserving Runge–Kutta (SSP-RK2, also known as Shu–Osher method): Given $u^n$, compute $u^{(1)} = u^n + \\Delta t \\, L(u^n)$, then $u^{n+1} = \\frac{1}{2} u^n + \\frac{1}{2}\\left(u^{(1)} + \\Delta t \\, L\\left(u^{(1)}\\right)\\right)$.\n\nInitial condition: A square wave of amplitude $A$ defined by\n$$\nu(x,0) = \\begin{cases}\nA,  x \\in [x_0, x_0 + w) \\ (\\text{mod } 1), \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\nsampled at cell centers $x_i = \\left(i + \\frac{1}{2}\\right)\\Delta x$ for $i=0,\\dots,N-1$.\n\nTotal variation evaluation and verification: Compute $TV(u^n)$ at every time step $n$ and track the maximum total variation $TV_{\\max}$ throughout the evolution. Numerically verify that $TV_{\\max} \\le TV(u^0)$ within a small numerical tolerance. You must also compute the final total variation $TV(u^N)$ at time $T$ and verify that $TV(u^N) \\le TV(u^0)$ within the same tolerance.\n\nTolerance: Use an absolute tolerance $\\varepsilon = 10^{-10}$ in your comparisons.\n\nAngle units: Not applicable to this problem.\n\nUnits: This problem is purely mathematical; no physical units are required.\n\nTest suite specification:\nProvide results for the following five test cases, each specified by $(N, a, x_0, w, A)$:\n1. General case (happy path): $(N = 200, a = 1, x_0 = 0.15, w = 0.25, A = 1)$.\n2. Constant solution boundary case: $(N = 200, a = 1, x_0 = 0, w = 1, A = 1)$.\n3. Narrow square wave: $(N = 400, a = 1, x_0 = 0.33, w = 0.05, A = 1)$.\n4. Negative advection speed: $(N = 200, a = -1, x_0 = 0.20, w = 0.25, A = 1)$.\n5. Coarse grid resolution: $(N = 40, a = 1, x_0 = 0.10, w = 0.30, A = 1)$.\n\nFor each test case, your program must produce a boolean indicating whether both conditions hold:\n- $TV_{\\max} \\le TV(u^0) + \\varepsilon$,\n- $TV(u^N) \\le TV(u^0) + \\varepsilon$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"), where each result is a boolean corresponding to the test cases in the order presented.",
            "solution": "The problem is valid. It presents a well-posed initial-boundary value problem for the one-dimensional linear advection equation and specifies a complete and scientifically sound numerical method for its solution. All parameters, algorithms, and verification criteria are clearly defined and consistent. The problem is a standard exercise in computational fluid dynamics, specifically in the implementation of high-resolution, total variation diminishing (TVD) schemes for conservation laws. While there is a minor ambiguity in the definition of the Courant number $\\nu$, where it is stated as both $\\nu = a \\Delta t / \\Delta x = 0.8$ and implicitly through $\\Delta t = \\nu \\Delta x / |a|$ with $\\nu=0.8$, the latter formula is the standard and correct definition. This latter formula allows for a consistent interpretation for both positive and negative advection speeds $a$ and will be used in the solution.\n\nThe solution proceeds by first discretizing the domain and the initial condition, then implementing the time-stepping loop which involves computing the spatial operator $L(u)$ at each stage of the Runge-Kutta method. The TVD property is numerically verified by tracking the total variation at each time step.\n\n**1. Discretization and Initial Setup**\n\nThe partial differential equation to be solved is the linear advection equation:\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\non a periodic domain $x \\in [0, 1]$ with a constant advection speed $a$.\n\nThe spatial domain $[0, 1]$ is discretized into $N$ uniform cells, each of width $\\Delta x = 1/N$. The cell centers are located at $x_i = (i + 1/2)\\Delta x$ for $i = 0, 1, \\dots, N-1$. The solution at time $t$ is represented by a set of cell-averaged values $\\{u_i(t)\\}_{i=0}^{N-1}$.\n\nThe initial condition is a square wave of amplitude $A$, width $w$, and starting position $x_0$:\n$$\nu(x,0) = \\begin{cases}\nA,  \\text{if } (x-x_0) \\pmod 1  w \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\nThe discrete initial condition $u^0 = \\{u_i^0\\}_{i=0}^{N-1}$ is obtained by sampling this function at the cell centers $x_i$.\n\nThe simulation runs until a final time $T = 1/|a|$, which corresponds to one full advection period. The time step $\\Delta t$ is determined by the Courant–Friedrichs–Lewy (CFL) number $\\nu = 0.8$, according to the formula:\n$$\n\\Delta t = \\frac{\\nu \\Delta x}{|a|} = \\frac{\\nu}{N|a|}\n$$\nThe total number of time steps required to reach time $T$ is exactly:\n$$\nN_{\\text{steps}} = \\frac{T}{\\Delta t} = \\frac{1/|a|}{\\nu / (N|a|)} = \\frac{N}{\\nu}\n$$\nFor $\\nu = 0.8$, this gives $N_{\\text{steps}} = 1.25 N$, which is an integer for all values of $N$ specified in the test suite.\n\n**2. Finite Volume Method and the Semi-Discrete Form**\n\nThe advection equation is a conservation law, $\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0$, with flux function $f(u) = au$. Integrating over a cell $[x_{i-1/2}, x_{i+1/2}]$ and applying the divergence theorem yields the semi-discrete finite volume formulation:\n$$\n\\frac{du_i}{dt} = -\\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x} \\equiv L(u)_i\n$$\nwhere $F_{i+1/2}$ is the numerical flux at the interface between cell $i$ and cell $i+1$. The operator $L(u)$ represents the spatial discretization.\n\n**3. MUSCL Reconstruction and HLL Flux**\n\nTo achieve second-order spatial accuracy while avoiding spurious oscillations near discontinuities, we use the Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL) approach to reconstruct the solution within each cell.\n\nFirst, for each cell $i$, a limited slope $\\sigma_i$ is computed. The problem specifies the use of the minmod limiter:\n$$\n\\sigma_i = \\operatorname{minmod}(u_i - u_{i-1}, u_{i+1} - u_i)\n$$\nThe minmod function is defined as:\n$$\n\\operatorname{minmod}(a, b) = \\begin{cases}\n\\text{sgn}(a) \\min(|a|, |b|)  \\text{if } ab  0 \\\\\n0  \\text{if } ab \\le 0\n\\end{cases}\n$$\nThis limiter ensures that no new local extrema are created, which is key to the TVD property. Periodic boundary conditions are enforced when computing differences at the domain boundaries (e.g., for $i=0$, $u_{i-1}$ is $u_{N-1}$).\n\nNext, these slopes are used to reconstruct the solution values at the left and right sides of each cell interface $x_{i+1/2}$:\n$$\nu^{L}_{i+1/2} = u_i + \\frac{1}{2}\\sigma_i\n$$\n$$\nu^{R}_{i+1/2} = u_{i+1} - \\frac{1}{2}\\sigma_{i+1}\n$$\nHere, $u^{L}_{i+1/2}$ is the value at the interface derived from the reconstruction in cell $i$, and $u^{R}_{i+1/2}$ is derived from cell $i+1$.\n\nThe Harten–Lax–van Leer (HLL) flux for the scalar advection equation simplifies to the upwind flux. The choice of state (left or right) depends on the direction of information propagation, determined by the sign of the advection speed $a$:\n$$\nF_{i+1/2} = \\begin{cases}\na \\, u^{L}_{i+1/2}  \\text{if } a  0 \\\\\na \\, u^{R}_{i+1/2}  \\text{if } a  0 \\\\\n0  \\text{if } a = 0\n\\end{cases}\n$$\n\n**4. Time Integration: SSP-RK2**\n\nThe semi-discrete system is advanced in time using a two-stage second-order Strong Stability Preserving Runge–Kutta (SSP-RK2) method, also known as the Shu–Osher method. Given the solution $u^n$ at time $t^n$, the solution $u^{n+1}$ at time $t^{n+1} = t^n + \\Delta t$ is computed in two stages:\n$$\nu^{(1)} = u^n + \\Delta t \\, L(u^n)\n$$\n$$\nu^{n+1} = \\frac{1}{2} u^n + \\frac{1}{2}\\left(u^{(1)} + \\Delta t \\, L\\left(u^{(1)}\\right)\\right)\n$$\nThis time integrator is chosen because it preserves the TVD property of the spatial discretization, provided the CFL condition is satisfied. For this scheme, the CFL limit is $\\nu \\le 1$, and the chosen value $\\nu = 0.8$ is safely within this limit.\n\n**5. Total Variation Verification**\n\nThe Total Variation (TV) of the discrete solution $u = \\{u_i\\}_{i=0}^{N-1}$ is defined as:\n$$\nTV(u) = \\sum_{i=0}^{N-1} |u_{i+1} - u_i|\n$$\nwhere periodic indexing $u_N \\equiv u_0$ is used.\nA numerical scheme is TVD if $TV(u^{n+1}) \\le TV(u^n)$ for all $n$. Due to floating-point arithmetic, small increases in TV can occur. We verify the TVD property by checking two conditions against a small tolerance $\\varepsilon = 10^{-10}$:\n1.  The maximum total variation observed throughout the entire simulation, $TV_{\\max} = \\max_n TV(u^n)$, does not exceed the initial total variation: $TV_{\\max} \\le TV(u^0) + \\varepsilon$.\n2.  The final total variation at time $T$, $TV(u^{N_{\\text{steps}}})$, does not exceed the initial total variation: $TV(u^{N_{\\text{steps}}}) \\le TV(u^0) + \\varepsilon$.\n\nA test case passes if and only if both conditions are met. The process is repeated for each of the five specified parameter sets.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using a second-order TVD MUSCL scheme\n    with an SSP-RK2 time integrator and verifies the TVD property.\n    \"\"\"\n\n    test_cases = [\n        # (N, a, x0, w, A)\n        (200, 1.0, 0.15, 0.25, 1.0),\n        (200, 1.0, 0.0, 1.0, 1.0),\n        (400, 1.0, 0.33, 0.05, 1.0),\n        (200, -1.0, 0.20, 0.25, 1.0),\n        (40, 1.0, 0.10, 0.30, 1.0),\n    ]\n\n    results = []\n    \n    # Tolerance for TVD check\n    epsilon = 1e-10\n\n    def minmod(a, b):\n        \"\"\"Element-wise minmod limiter.\"\"\"\n        # Using np.sign to handle arrays efficiently\n        return 0.5 * (np.sign(a) + np.sign(b)) * np.minimum(np.abs(a), np.abs(b))\n\n    def calculate_tv(u):\n        \"\"\"Calculates the total variation of a periodic array.\"\"\"\n        # Append first element to the end to handle periodicity for np.diff\n        u_periodic = np.append(u, u[0])\n        return np.sum(np.abs(np.diff(u_periodic)))\n\n    def spatial_operator_L(u, N, dx, a):\n        \"\"\"Computes the semi-discrete spatial operator L(u).\"\"\"\n        # Periodic shifts to get neighboring cell values\n        u_im1 = np.roll(u, 1)  # u_{i-1}\n        u_ip1 = np.roll(u, -1) # u_{i+1}\n\n        # Step 1: Compute limited slopes (sigma_i)\n        diff_left = u - u_im1\n        diff_right = u_ip1 - u\n        sigma = minmod(diff_left, diff_right)\n\n        # Step 2: Reconstruct interface states\n        # u^L_{i+1/2} = u_i + 0.5 * sigma_i\n        # u^R_{i+1/2} = u_{i+1} - 0.5 * sigma_{i+1}\n        uL_iph = u + 0.5 * sigma\n        sigma_ip1 = np.roll(sigma, -1)\n        uR_iph = u_ip1 - 0.5 * sigma_ip1\n        \n        # Step 3: Compute HLL (upwind) flux at interfaces i+1/2\n        if a  0:\n            flux = a * uL_iph\n        elif a  0:\n            flux = a * uR_iph\n        else: # a == 0\n            flux = np.zeros(N)\n\n        # Step 4: Compute L(u)_i = -(F_{i+1/2} - F_{i-1/2}) / dx\n        flux_imh = np.roll(flux, 1) # F_{i-1/2}\n        L = -(flux - flux_imh) / dx\n        \n        return L\n\n    for case in test_cases:\n        N, a, x0, w, A = case\n        \n        # Setup grid and time parameters\n        dx = 1.0 / N\n        cfl = 0.8\n        \n        # Handle a=0 case for dt calculation to avoid division by zero\n        if abs(a)  1e-15:\n            dt = 1.0 # arbitrary, as it won't be used\n            T = 0.0\n            n_steps = 0\n        else:\n            dt = cfl * dx / abs(a)\n            T = 1.0 / abs(a)\n            n_steps = int(round(T / dt)) # Should be exactly N / cfl\n\n        # Initial condition\n        x = (np.arange(N) + 0.5) * dx\n        # This modular arithmetic handles wrapped-around square waves correctly\n        u0 = np.where((x - x0) % 1.0  w, A, 0.0)\n\n        # TVD analysis setup\n        tv0 = calculate_tv(u0)\n        tv_max = tv0\n        \n        u = u0.copy()\n\n        # Time-stepping loop\n        for _ in range(n_steps):\n            # SSP-RK2 Scheme\n            # Stage 1\n            Lu = spatial_operator_L(u, N, dx, a)\n            u1 = u + dt * Lu\n            \n            # Stage 2\n            Lu1 = spatial_operator_L(u1, N, dx, a)\n            u = 0.5 * u + 0.5 * (u1 + dt * Lu1)\n\n            # Update max total variation\n            tv_current = calculate_tv(u)\n            if tv_current  tv_max:\n                tv_max = tv_current\n\n        tv_final = calculate_tv(u)\n        \n        # Verification checks\n        is_tv_max_ok = tv_max = tv0 + epsilon\n        is_tv_final_ok = tv_final = tv0 + epsilon\n        \n        results.append(is_tv_max_ok and is_tv_final_ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond linear scalar problems, this practice extends TVD concepts to a nonlinear system: the shallow water equations. This introduces critical real-world challenges, such as ensuring the positivity of water height (preventing \"dry\" areas from having negative water) and maintaining equilibrium states like a lake at rest (well-balancedness). You will design a complete TVD-compliant solver that addresses these complexities, demonstrating how to apply these advanced techniques to practical fluid dynamics problems. ",
            "id": "3383825",
            "problem": "Consider the one-dimensional shallow water system (no bathymetry) consisting of the mass and momentum conservation laws\n$$\nh_t + (hu)_x = 0,\\qquad (hu)_t + \\left(hu^2 + \\tfrac{1}{2} g h^2\\right)_x = 0,\n$$\nwhere $h$ is the water height, $u$ is the velocity, $hu$ is the discharge, and $g$ is the gravitational acceleration. The computational task is to design a finite volume discretization that is Total Variation Diminishing (TVD) in $h$, preserves non-negativity of $h$ in the presence of dry beds ($h=0$), and is well-balanced for the lake-at-rest state (constant $h$ and zero velocity $u=0$). You must construct a second-order accurate in space reconstruction for cell interface states using a slope limiter and a single-step method whose stability property implies TVD under a Courant–Friedrichs–Lewy (CFL) constraint. You must select a monotone numerical flux that is consistent with the hyperbolic structure of the system and supports positivity preservation for $h$ under an appropriate time step restriction.\n\nYour derivation must start from the finite volume form of a generic conservation law on a uniform grid of cell centers $x_i$ with spacing $\\Delta x$, cell averages $Q_i^n$ at time $t^n$, and interface fluxes at $x_{i\\pm \\frac{1}{2}}$, together with the definition of total variation\n$$\nTV(h^n) = \\sum_{i} \\left|h_{i+1}^n - h_i^n\\right|.\n$$\nFrom these bases, derive the requirements on the reconstruction, flux, and time discretization that ensure\n$$\nh_i^{n+1} \\ge 0\\quad\\text{for all }i,\\qquad TV(h^{n+1}) \\le TV(h^n),\n$$\nand that the lake-at-rest state $h\\equiv \\text{constant}$, $u\\equiv 0$ is exactly preserved by your scheme. Restrict attention to a one-dimensional periodic domain or transmissive (zero-gradient) boundaries on a finite interval, and assume the gravitational acceleration parameter is $g=9.81$ expressed in $\\mathrm{m/s^2}$; the final answers in this problem are booleans and therefore do not require physical units.\n\nImplement your derived algorithm as a program that performs one Strong Stability Preserving step of the time integration on each test case below (with a single time step chosen from a computed CFL condition). The spatial grid is uniform with $N$ cells, domain length $L$, and spacing $\\Delta x = L/N$. The CFL-based time step must be computed as\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{\\max_i\\left(|u_i| + \\sqrt{g\\,h_i}\\right)},\n$$\nwith a fixed $\\text{CFL}$ chosen by you to meet the TVD and positivity conditions. Use transmissive boundary conditions.\n\nTest suite:\n- Case A (lake at rest, well-balanced and TVD check): $L=1.0$, $N=100$, $g=9.81$, $h(x,0)=1.0$ for all $x$, $u(x,0)=0$ for all $x$.\n- Case B (dam-break with dry bed on the right, positivity and TVD check): $L=1.0$, $N=200$, $g=9.81$, $h(x,0)=1.0$ for $x0.5$ and $h(x,0)=0.0$ for $x\\ge 0.5$, $u(x,0)=0$.\n- Case C (smooth small-amplitude perturbation, TVD check): $L=1.0$, $N=200$, $g=9.81$, $h(x,0)=1.0+0.2\\sin(2\\pi x)$, $u(x,0)=0$.\n- Case D (near-vacuum with dry bed, positivity and TVD check): $L=1.0$, $N=200$, $g=9.81$, $h(x,0)=10^{-3}$ for $x0.5$ and $h(x,0)=0.0$ for $x\\ge 0.5$, $u(x,0)=0$.\n\nFor each case, perform exactly one second-order Strong Stability Preserving step of your scheme and evaluate the following criteria:\n- Non-negativity: $\\min_i h_i^{n+1} \\ge 0$.\n- TVD: $TV(h^{n+1}) \\le TV(h^n)$.\n- For Case A only, well-balanced: $\\max_i |h_i^{n+1}-h_i^n| + \\max_i |(hu)_i^{n+1}-(hu)_i^n|$ is less than a small tolerance.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[true,true,true,true]\"). Each entry is a boolean corresponding to Cases A–D, where \"true\" indicates that all required criteria for that case are satisfied and \"false\" otherwise. No other output is permitted.",
            "solution": "We begin from the finite volume form of a conservation law for a vector of conserved variables $Q=(q_1,q_2)$, here chosen as $Q=(h,hu)$, on a uniform grid with cell centers $x_i$ and spacing $\\Delta x$. The semi-discrete finite volume method for a hyperbolic system $Q_t + F(Q)_x=0$ is\n$$\n\\frac{d Q_i}{d t} = - \\frac{1}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\nwhere $F_{i\\pm\\frac{1}{2}}$ are consistent numerical fluxes approximating $F(Q)$ at interfaces. A forward Euler update with time step $\\Delta t$ reads\n$$\nQ_i^{n+1} = Q_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right).\n$$\nTo achieve second-order spatial accuracy while controlling spurious oscillations near discontinuities, we use a piecewise linear reconstruction with a slope limiter. For a scalar variable $w_i$ (either $h$ or $u$), define limited slopes $\\sigma_i$ by a Total Variation Diminishing limiter, for example the minmod limiter:\n$$\n\\operatorname{minmod}(a,b) = \\begin{cases}\n\\mathrm{sign}(a)\\min(|a|,|b|),  \\text{if } ab0,\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\nand set\n$$\n\\sigma_i = \\operatorname{minmod}(w_i - w_{i-1},\\, w_{i+1} - w_i).\n$$\nThe left and right reconstructed states at interface $x_{i+\\frac{1}{2}}$ are then\n$$\nw_{i+\\frac{1}{2}}^L = w_i + \\tfrac{1}{2}\\sigma_i,\\qquad\nw_{i+\\frac{1}{2}}^R = w_{i+1} - \\tfrac{1}{2}\\sigma_{i+1}.\n$$\nWe perform this reconstruction on the primitive pair $(h,u)$, followed by conversion to conserved variables at interfaces via $(h,hu)=(h,h\\,u)$. To guarantee $h\\ge 0$ in reconstructed states in the presence of dry beds, we clip interface heights by\n$$\nh_{i+\\frac{1}{2}}^{L} \\leftarrow \\max\\{h_{i+\\frac{1}{2}}^{L},\\,0\\},\\quad\nh_{i+\\frac{1}{2}}^{R} \\leftarrow \\max\\{h_{i+\\frac{1}{2}}^{R},\\,0\\},\n$$\nand set the corresponding discharge to $0$ whenever $h=0$, i.e., if $h_{i+\\frac{1}{2}}^{L}=0$ then $(hu)_{i+\\frac{1}{2}}^{L}=0$, and similarly on the right. This reconstruction is TVD for $h$ because the minmod limiter ensures that the discrete total variation cannot increase under a forward Euler step with a monotone flux and a suitable time step restriction, and Strong Stability Preserving time integrators inherit this TVD property under the same restriction scaled by their stability coefficient.\n\nFor the numerical flux, we select a monotone approximate Riemann solver with positivity-preserving properties. A widely used choice with these properties is the two-wave Harten–Lax–van Leer–Einfeldt (HLLE) flux. Given left and right states $Q^L=(h^L,(hu)^L)$ and $Q^R=(h^R,(hu)^R)$ at an interface, define primitive velocities and wave speeds by\n$$\nu^L = \\begin{cases}\\frac{(hu)^L}{h^L},  h^L0,\\\\ 0,  h^L=0,\\end{cases}\\quad\nu^R = \\begin{cases}\\frac{(hu)^R}{h^R},  h^R0,\\\\ 0,  h^R=0,\\end{cases}\n$$\n$$\nc^L = \\sqrt{g h^L},\\qquad c^R = \\sqrt{g h^R},\n$$\nand signal speeds\n$$\ns_L = \\min\\{u^L - c^L,\\, u^R - c^R\\},\\qquad s_R = \\max\\{u^L + c^L,\\, u^R + c^R\\}.\n$$\nLet the physical flux be $F(Q)=(hu,\\, (hu)^2/h + \\tfrac{1}{2} g h^2)$ for $h0$ and $F(Q)=(0,0)$ if $h=0$. The HLLE flux is\n$$\nF_{\\mathrm{HLLE}} =\n\\begin{cases}\nF(Q^L),  s_L \\ge 0,\\\\\nF(Q^R),  s_R \\le 0,\\\\\n\\frac{s_R F(Q^L) - s_L F(Q^R) + s_L s_R (Q^R - Q^L)}{s_R - s_L},  s_L  0  s_R.\n\\end{cases}\n$$\nUnder the Courant–Friedrichs–Lewy condition\n$$\n\\Delta t \\le \\frac{\\Delta x}{\\max_i(|u_i| + \\sqrt{g h_i})},\n$$\nthe HLLE flux combined with forward Euler is monotone and positivity-preserving for $h$. Using a minmod limiter for $h$ makes the forward Euler update TVD in $h$. To achieve second-order temporal accuracy while preserving TVD, we employ a second-order Strong Stability Preserving Runge–Kutta method (also called Shu–Osher scheme):\n$$\nQ^{(1)} = Q^n + \\Delta t\\, L(Q^n),\\qquad\nQ^{n+1} = \\tfrac{1}{2} Q^n + \\tfrac{1}{2}\\left(Q^{(1)} + \\Delta t\\, L(Q^{(1)})\\right),\n$$\nwhere $L(Q)$ denotes the semi-discrete operator $L(Q)_i = -\\tfrac{1}{\\Delta x}(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}})$ with the above reconstruction and flux. The Strong Stability Preserving theory ensures that if forward Euler with time step $\\Delta t$ is TVD in $h$, then this Runge–Kutta method is also TVD provided the same time step restriction is respected.\n\nWell-balancedness for the lake-at-rest state $h\\equiv H$, $u\\equiv 0$ follows because the reconstruction produces constant left and right states $h^L=h^R=H$, $u^L=u^R=0$ at every interface, leading to identical fluxes at adjacent interfaces. Consequently, $F_{i+\\frac{1}{2}}=F_{i-\\frac{1}{2}}$ and $L(Q)=0$, so both stages of the Strong Stability Preserving method leave the state unchanged exactly up to round-off errors.\n\nAlgorithmic steps:\n1. Initialize $h_i$ and $u_i$ from the test case. Form $Q_i=(h_i, h_i u_i)$.\n2. Compute $\\Delta x=L/N$ and a time step $\\Delta t=\\text{CFL}\\,\\Delta x / \\max_i(|u_i|+\\sqrt{g h_i})$ with $\\text{CFL}$ in $(0,1)$ chosen to satisfy the TVD and positivity conditions (we take a conservative choice).\n3. Apply transmissive boundary conditions by copying end cell values into ghost cells.\n4. Reconstruct interface states for $(h,u)$ by minmod-limited piecewise linear reconstruction and clip $h\\ge 0$ at interfaces; set $hu=0$ wherever $h=0$.\n5. Compute HLLE fluxes at interfaces, then the semi-discrete operator $L(Q)$.\n6. Perform one Strong Stability Preserving second-order step to obtain $Q^{n+1}$.\n7. Evaluate the criteria: non-negativity of $h$, TVD for $h$ by comparing $TV(h^{n+1})$ and $TV(h^n)$, and for the lake-at-rest case check that both $h$ and $hu$ remain unchanged within a small tolerance.\n8. Output booleans per case indicating whether all case-specific criteria are satisfied.\n\nThis construction integrates core hyperbolic conservation law discretization principles, slope-limited reconstruction for TVD, monotone flux for positivity, and Strong Stability Preserving time stepping. The HLLE flux is consistent and monotone, and the minmod limiter suppresses new extrema in $h$, satisfying the TVD requirement under the CFL restriction. The lake-at-rest well-balanced property holds because the reconstruction and flux computation do not perturb constant states.",
            "answer": "```python\nimport numpy as np\n\n# Shallow water TVD solver with HLLE flux, minmod-limited MUSCL reconstruction, and SSP RK2.\n# Domain: 1D, transmissive boundaries.\n\ndef minmod(a, b):\n    \"\"\"Minmod limiter for two arrays a, b.\"\"\"\n    sign = np.sign(a)\n    cond = (a * b)  0.0\n    return np.where(cond, sign * np.minimum(np.abs(a), np.abs(b)), 0.0)\n\ndef apply_transmissive_bc(h, m):\n    \"\"\"Apply transmissive (zero-gradient) boundary conditions to ghost cells.\"\"\"\n    # h and m include ghost cells indices [0..N+1], real cells [1..N]\n    h[0] = h[1]\n    h[-1] = h[-2]\n    m[0] = m[1]\n    m[-1] = m[-2]\n\ndef reconstruct_interfaces(h, m, g, eps=1e-14):\n    \"\"\"\n    Reconstruct left/right states (h,u) at interfaces using minmod limiter on (h,u),\n    then convert to conserved (h,hu). Clip h = 0, set hu = 0 where h == 0.\n    Input arrays h, m include ghost cells.\n    Returns arrays hL, mL, hR, mR for interfaces i=0..N (N+1 interfaces).\n    \"\"\"\n    Np2 = h.shape[0]  # includes ghost cells\n    N = Np2 - 2       # number of real cells\n    # Compute primitive velocity u in cells, with safe handling near dryness.\n    u = np.zeros_like(h)\n    mask = h  eps\n    u[mask] = m[mask] / h[mask]\n    u[~mask] = 0.0\n\n    # Limited slopes for h and u in real cells [1..N]\n    dh_left = h[1:N+1] - h[0:N]      # h_i - h_{i-1}\n    dh_right = h[2:N+2] - h[1:N+1]   # h_{i+1} - h_i\n    du_left = u[1:N+1] - u[0:N]\n    du_right = u[2:N+2] - u[1:N+1]\n    sigma_h = minmod(dh_left, dh_right)\n    sigma_u = minmod(du_left, du_right)\n\n    # Prepare arrays for interface states\n    hL = np.zeros(N+1)\n    hR = np.zeros(N+1)\n    uL = np.zeros(N+1)\n    uR = np.zeros(N+1)\n\n    # For interfaces i=0..N, left cell index is i, right cell index is i+1 in full arrays\n    # Left state from cell i:\n    # For i in [1..N-1], use limited slope; for i=0 or i=N, slope = 0 (ghost or boundary)\n    # Build extended slope arrays with boundaries:\n    sigma_h_ext = np.zeros(N+2)\n    sigma_u_ext = np.zeros(N+2)\n    sigma_h_ext[1:N+1] = sigma_h\n    sigma_u_ext[1:N+1] = sigma_u\n\n    # Left states\n    hL[:] = h[0:N+1] + 0.5 * sigma_h_ext[0:N+1]\n    uL[:] = u[0:N+1] + 0.5 * sigma_u_ext[0:N+1]\n    # Right states\n    hR[:] = h[1:N+2] - 0.5 * sigma_h_ext[1:N+2]\n    uR[:] = u[1:N+2] - 0.5 * sigma_u_ext[1:N+2]\n\n    # Positivity clip for reconstructed heights, and set velocity zero where h==0\n    hL = np.maximum(hL, 0.0)\n    hR = np.maximum(hR, 0.0)\n    uL = np.where(hL  eps, uL, 0.0)\n    uR = np.where(hR  eps, uR, 0.0)\n\n    # Convert to conserved discharge\n    mL = hL * uL\n    mR = hR * uR\n\n    return hL, mL, hR, mR\n\ndef hlle_flux(hL, mL, hR, mR, g, eps=1e-14):\n    \"\"\"\n    Compute HLLE flux for shallow water at interfaces.\n    Inputs are arrays at interfaces.\n    Returns flux arrays Fh, Fm at interfaces.\n    \"\"\"\n    # Primitive velocities and wave speeds\n    uL = np.zeros_like(hL)\n    uR = np.zeros_like(hR)\n    maskL = hL  eps\n    maskR = hR  eps\n    uL[maskL] = mL[maskL] / hL[maskL]\n    uR[maskR] = mR[maskR] / hR[maskR]\n\n    cL = np.sqrt(g * hL)\n    cR = np.sqrt(g * hR)\n\n    sL = np.minimum(uL - cL, uR - cR)\n    sR = np.maximum(uL + cL, uR + cR)\n\n    # Physical fluxes\n    FhL = mL\n    FhR = mR\n\n    FmL = np.where(maskL, mL * uL + 0.5 * g * hL * hL, 0.0)\n    FmR = np.where(maskR, mR * uR + 0.5 * g * hR * hR, 0.0)\n\n    Fh = np.zeros_like(hL)\n    Fm = np.zeros_like(hL)\n\n    # Regions: sL = 0, sR = 0, else\n    left_dom = sL = 0.0\n    right_dom = sR = 0.0\n    mid_dom = ~(left_dom | right_dom)\n\n    Fh[left_dom] = FhL[left_dom]\n    Fm[left_dom] = FmL[left_dom]\n\n    Fh[right_dom] = FhR[right_dom]\n    Fm[right_dom] = FmR[right_dom]\n\n    denom = sR[mid_dom] - sL[mid_dom]\n    # Avoid division by zero; where denom is tiny, pick average of left/right flux\n    safe = np.where(np.abs(denom)  1e-14, denom, 1e-14)\n\n    Fh[mid_dom] = (sR[mid_dom] * FhL[mid_dom] - sL[mid_dom] * FhR[mid_dom] +\n                   sL[mid_dom] * sR[mid_dom] * (hR[mid_dom] - hL[mid_dom])) / safe\n    Fm[mid_dom] = (sR[mid_dom] * FmL[mid_dom] - sL[mid_dom] * FmR[mid_dom] +\n                   sL[mid_dom] * sR[mid_dom] * (mR[mid_dom] - mL[mid_dom])) / safe\n\n    return Fh, Fm\n\ndef semi_discrete_L(h, m, g, dx):\n    \"\"\"\n    Compute L(Q) = -(F_{i+1/2} - F_{i-1/2})/dx for arrays with ghost cells.\n    Returns arrays Lh, Lm for real cells [1..N].\n    \"\"\"\n    # Apply BCs\n    apply_transmissive_bc(h, m)\n    # Reconstruct interface states\n    hL, mL, hR, mR = reconstruct_interfaces(h, m, g)\n    # Compute fluxes at interfaces\n    Fh, Fm = hlle_flux(hL, mL, hR, mR, g)\n    # Compute L for real cells: i=1..N using interfaces 0..N\n    Lh = -(Fh[1:] - Fh[:-1]) / dx\n    Lm = -(Fm[1:] - Fm[:-1]) / dx\n    return Lh, Lm\n\ndef ssp_rk2_step(h, m, g, dx, dt):\n    \"\"\"\n    One SSP RK2 step for arrays h, m including ghost cells.\n    Returns new arrays h_new, m_new including ghost cells.\n    \"\"\"\n    # Stage 1\n    Lh1, Lm1 = semi_discrete_L(h.copy(), m.copy(), g, dx)\n    h1 = h.copy()\n    m1 = m.copy()\n    h1[1:-1] = h[1:-1] + dt * Lh1\n    m1[1:-1] = m[1:-1] + dt * Lm1\n\n    # Stage 2\n    Lh2, Lm2 = semi_discrete_L(h1.copy(), m1.copy(), g, dx)\n    h2 = h1.copy()\n    m2 = m1.copy()\n    h2[1:-1] = h1[1:-1] + dt * Lh2\n    m2[1:-1] = m1[1:-1] + dt * Lm2\n\n    # Combine\n    h_new = h.copy()\n    m_new = m.copy()\n    h_new[1:-1] = 0.5 * (h[1:-1] + h2[1:-1])\n    m_new[1:-1] = 0.5 * (m[1:-1] + m2[1:-1])\n\n    # Apply BCs to the result\n    apply_transmissive_bc(h_new, m_new)\n    return h_new, m_new\n\ndef compute_tv(h_real):\n    \"\"\"Compute total variation of h over real cells.\"\"\"\n    return np.sum(np.abs(h_real[1:] - h_real[:-1]))\n\ndef initial_conditions(case, L, N):\n    \"\"\"Generate initial h and u arrays for a given case.\"\"\"\n    x = (np.arange(N) + 0.5) * (L / N)\n    if case == \"lake\":\n        h = np.ones_like(x) * 1.0\n        u = np.zeros_like(x)\n    elif case == \"dam_dry\":\n        h = np.where(x  0.5, 1.0, 0.0)\n        u = np.zeros_like(x)\n    elif case == \"smooth\":\n        h = 1.0 + 0.2 * np.sin(2.0 * np.pi * x)\n        u = np.zeros_like(x)\n    elif case == \"near_vacuum\":\n        h = np.where(x  0.5, 1e-3, 0.0)\n        u = np.zeros_like(x)\n    else:\n        raise ValueError(\"Unknown case\")\n    return h, u\n\ndef cfl_dt(h_real, m_real, g, dx, CFL, eps=1e-14):\n    \"\"\"Compute time step from CFL.\"\"\"\n    u_real = np.zeros_like(h_real)\n    mask = h_real  eps\n    u_real[mask] = m_real[mask] / h_real[mask]\n    speeds = np.abs(u_real) + np.sqrt(g * h_real)\n    amax = np.max(speeds)\n    if amax  eps:\n        # If no wave speed (dry or zero), pick small dt\n        return CFL * dx / (eps + 1.0)\n    return CFL * dx / amax\n\ndef run_case(case_name, L, N, g, CFL, tol=1e-12):\n    \"\"\"Run one SSP RK2 step for the given case and return boolean result.\"\"\"\n    dx = L / N\n    # Allocate with ghost cells\n    h_real, u_real = initial_conditions(case_name, L, N)\n    m_real = h_real * u_real\n\n    # Add ghost cells\n    h = np.zeros(N + 2)\n    m = np.zeros(N + 2)\n    h[1:-1] = h_real\n    m[1:-1] = m_real\n    apply_transmissive_bc(h, m)\n\n    # Compute initial TV\n    tv0 = compute_tv(h[1:-1])\n\n    # Time step from CFL\n    dt = cfl_dt(h[1:-1], m[1:-1], g, dx, CFL)\n\n    # SSP RK2 step\n    h_new, m_new = ssp_rk2_step(h, m, g, dx, dt)\n\n    # Extract real cells\n    h1 = h_new[1:-1]\n    m1 = m_new[1:-1]\n\n    # Checks\n    positive = (np.min(h1) = -tol)\n    tv1 = compute_tv(h1)\n    tvd = (tv1 = tv0 + tol)\n\n    if case_name == \"lake\":\n        # Well-balanced: state unchanged within tolerance\n        wb = (np.max(np.abs(h1 - h[1:-1])) + np.max(np.abs(m1 - m[1:-1])) = tol)\n        return bool(positive and tvd and wb)\n    else:\n        return bool(positive and tvd)\n\ndef solve():\n    g = 9.81  # gravitational acceleration\n    # Choose conservative CFL for TVD and positivity\n    CFL = 0.45\n\n    test_cases = [\n        (\"lake\", 1.0, 100, g, CFL),\n        (\"dam_dry\", 1.0, 200, g, CFL),\n        (\"smooth\", 1.0, 200, g, CFL),\n        (\"near_vacuum\", 1.0, 200, g, CFL),\n    ]\n\n    results = []\n    for name, L, N, gval, cfl in test_cases:\n        res = run_case(name, L, N, gval, cfl)\n        results.append(res)\n\n    # Print in the exact required format: comma-separated booleans in brackets\n    # Use lowercase 'true'/'false' to match example format strictly.\n    def to_str(b):\n        return \"true\" if b else \"false\"\n\n    print(f\"[{','.join(map(to_str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}