{
    "hands_on_practices": [
        {
            "introduction": "为了真正掌握总变差递减（TVD）格式的工作原理，超越数值结果，直接剖析其底层的代数结构是非常有价值的。本练习提供了一次分析推导的实践机会。通过将TVD格式应用于一个极小的周期性网格和简单的初始条件，你将能够推导出单时间步后总变差变化量的精确闭式表达式，从而揭示通量限制器和库朗数如何直接影响解的稳定性。",
            "id": "3383794",
            "problem": "考虑标量线性平流方程 $u_{t} + a\\,u_{x} = 0$，其中波速 $a > 0$ 为常数。该方程在一个间距为 $\\Delta x$ 的均匀一维网格上，通过大小为 $\\Delta t$ 的显式向前欧拉步在时间上推进。令 Courant–Friedrichs–Lewy 数为 $\\lambda = a\\,\\Delta t/\\Delta x \\in [0,1]$。使用守恒型有限体积格式进行更新\n$$\nu_{i}^{n+1} = u_{i}^{n} - \\lambda\\left(F_{i+\\frac{1}{2}}^{n} - F_{i-\\frac{1}{2}}^{n}\\right),\n$$\n由于 $a>0$，通量为迎风通量 $F_{i+\\frac{1}{2}}^{n} = a\\,u_{i+\\frac{1}{2}}^{-}$，并对左状态进行线性重构（保守律的单调上游中心格式，MUSCL）\n$$\nu_{i+\\frac{1}{2}}^{-} = u_{i}^{n} + \\frac{1}{2}\\,(1-\\lambda)\\,\\phi(r_{i})\\,(u_{i}^{n} - u_{i-1}^{n}),\n$$\n其中，比率 $r_{i}$ 定义为\n$$\nr_{i} = \\frac{u_{i+1}^{n} - u_{i}^{n}}{u_{i}^{n} - u_{i-1}^{n}},\n$$\n$\\phi(r)$ 是一个斜率限制器函数。考虑三种总变差不增 (TVD) 限制器：\n- Superbee: $\\phi_{\\mathrm{SB}}(r) = \\max\\!\\left(0,\\,\\min(2r,1),\\,\\min(r,2)\\right)$,\n- van Leer: $\\phi_{\\mathrm{VL}}(r) = \\frac{r + |r|}{1 + |r|}$,\n- Monotonized Central (MC): $\\phi_{\\mathrm{MC}}(r) = \\max\\!\\left(0,\\,\\min\\!\\left(\\frac{1+r}{2},\\,2,\\,2r\\right)\\right)$.\n\n在一个四单元的周期性区域上，给定锯齿状的初始数据（时间层 $n$ 的单元平均值）\n$$\nu_{0}^{n} = 0,\\quad u_{1}^{n} = 1,\\quad u_{2}^{n} = 3,\\quad u_{3}^{n} = 2,\n$$\n并以周期 $4$ 进行周期性延拓。将时间层 $n$ 的总变差定义为\n$$\nTV(u^{n}) = \\sum_{i=0}^{3} \\left|u_{i+1}^{n} - u_{i}^{n}\\right|,\n$$\n其中指标在模 $4$ 的意义下理解。\n\n从以上定义和有限体积更新格式出发，解析地追踪格式的一个时间步，以获得对于每种限制器，总变差比率 $TV(u^{n+1})/TV(u^{n})$ 作为 Courant 数 $\\lambda$ 的函数的闭式表达式。将你的最终答案表示为 $\\left[\\text{superbee},\\,\\text{van Leer},\\,\\text{MC}\\right]$ 顺序的单行矩阵。无需四舍五入。最终答案必须是单一的闭式解析表达式。",
            "solution": "该问题经验证具有科学依据、适定、客观且自洽。要求是针对一个特定的数值格式和初始条件，确定一个时间步长内的总变差比率。\n\n对于标量线性平流方程 $u_t + a u_x = 0$（其中 $a>0$），有限体积更新格式由下式给出：\n$$\nu_{i}^{n+1} = u_{i}^{n} - \\frac{\\Delta t}{\\Delta x}\\left(f_{i+\\frac{1}{2}}^{n} - f_{i-\\frac{1}{2}}^{n}\\right)\n$$\n其中 $f$ 是数值通量。问题陈述的 $F$ 符号与通量 $f$ 的关系似乎不标准，我们将其解释为 $f_{i+\\frac{1}{2}}^{n} = F_{i+\\frac{1}{2}}^{n} = a u_{i+\\frac{1}{2}}^{-}$。代入更新方程并使用 $\\lambda = a \\Delta t/\\Delta x$，得到\n$$\nu_{i}^{n+1} = u_{i}^{n} - \\frac{a \\Delta t}{\\Delta x}\\left(u_{i+\\frac{1}{2}}^{-} - u_{i-\\frac{1}{2}}^{-}\\right) = u_{i}^{n} - \\lambda \\left(u_{i+\\frac{1}{2}}^{-} - u_{i-\\frac{1}{2}}^{-}\\right)\n$$\n这与问题中公式 $u_{i}^{n+1} = u_{i}^{n} - \\lambda\\left(F_{i+\\frac{1}{2}}^{n} - F_{i-\\frac{1}{2}}^{n}\\right)$ 的直接解释不符（后者在量纲上不一致），但我们采纳量纲一致的解释，即问题符号中的 $F$ 代表 $f/a$。\n\n重构的左状态由下式给出：\n$$\nu_{i+\\frac{1}{2}}^{-} = u_{i}^{n} + \\frac{1}{2}(1-\\lambda)\\phi(r_{i})(u_{i}^{n} - u_{i-1}^{n})\n$$\n将此代入更新规则，得到 $u_{i}^{n+1}$ 的表达式：\n$$\nu_{i}^{n+1} = u_{i}^{n} - \\lambda \\left[ \\left(u_{i}^{n} + \\frac{1}{2}(1-\\lambda)\\phi(r_{i})(u_{i}^{n} - u_{i-1}^{n})\\right) - \\left(u_{i-1}^{n} + \\frac{1}{2}(1-\\lambda)\\phi(r_{i-1})(u_{i-1}^{n} - u_{i-2}^{n})\\right) \\right]\n$$\n让我们定义后向差分 $\\Delta_i^n = u_i^n - u_{i-1}^n$。公式变为：\n$$\nu_{i}^{n+1} = u_{i}^{n} - \\lambda \\left[ (u_i^n-u_{i-1}^n) + \\frac{1-\\lambda}{2}\\phi(r_i)\\Delta_i^n - \\frac{1-\\lambda}{2}\\phi(r_{i-1})\\Delta_{i-1}^n \\right]\n$$\n$$\nu_{i}^{n+1} = u_i^n - \\lambda \\Delta_i^n - \\frac{\\lambda(1-\\lambda)}{2} \\left( \\phi(r_i)\\Delta_i^n - \\phi(r_{i-1})\\Delta_{i-1}^n \\right)\n$$\n\n接下来，我们为给定的 $4$ 单元周期性区域上的初始状态计算相关量：$u_{0}^{n} = 0$, $u_{1}^{n} = 1$, $u_{2}^{n} = 3$, $u_{3}^{n} = 2$。\n后向差分 $\\Delta_i^n = u_i^n - u_{i-1}^n$ 为（使用周期性 $u_{-1}^n = u_3^n=2$ 等）：\n$\\Delta_0^n = u_0^n - u_{-1}^n = 0 - 2 = -2$\n$\\Delta_1^n = u_1^n - u_0^n = 1 - 0 = 1$\n$\\Delta_2^n = u_2^n - u_1^n = 3 - 1 = 2$\n$\\Delta_3^n = u_3^n - u_2^n = 2 - 3 = -1$\n\n时间层 $n$ 的总变差为：\n$$\nTV(u^n) = \\sum_{i=0}^{3} |u_{i+1}^n - u_i^n| = |u_1^n-u_0^n| + |u_2^n-u_1^n| + |u_3^n-u_2^n| + |u_0^n-u_3^n|\n$$\n$$\nTV(u^n) = |1| + |2| + |-1| + |-2| = 1+2+1+2=6\n$$\n比率 $r_i = \\frac{u_{i+1}^n - u_i^n}{u_i^n - u_{i-1}^n}$ 为：\n$r_0 = \\frac{u_1^n-u_0^n}{u_0^n-u_{-1}^n} = \\frac{1}{-2} = -\\frac{1}{2}$\n$r_1 = \\frac{u_2^n-u_1^n}{u_1^n-u_0^n} = \\frac{2}{1} = 2$\n$r_2 = \\frac{u_3^n-u_2^n}{u_2^n-u_1^n} = \\frac{-1}{2} = -\\frac{1}{2}$\n$r_3 = \\frac{u_0^n-u_3^n}{u_3^n-u_2^n} = \\frac{-2}{-1} = 2$\n\n现在，我们计算当 $r \\in \\{-\\frac{1}{2}, 2\\}$ 时限制器函数 $\\phi(r)$ 的值。\n当 $r = -\\frac{1}{2}$ 时：\n$\\phi_{\\mathrm{SB}}(-\\frac{1}{2}) = \\max(0, \\min(-1, 1), \\min(-\\frac{1}{2}, 2)) = \\max(0, -1, -\\frac{1}{2}) = 0$\n$\\phi_{\\mathrm{VL}}(-\\frac{1}{2}) = \\frac{-1/2 + |-1/2|}{1+|-1/2|} = 0$\n$\\phi_{\\mathrm{MC}}(-\\frac{1}{2}) = \\max(0, \\min(\\frac{1-1/2}{2}, 2, -1)) = \\max(0, -1) = 0$\n因此，对于所有三种限制器，$\\phi(-\\frac{1}{2})=0$。所以，$\\phi(r_0)=0$ 且 $\\phi(r_2)=0$。\n\n当 $r = 2$ 时：\n$\\phi_{\\mathrm{SB}}(2) = \\max(0, \\min(4, 1), \\min(2, 2)) = \\max(0, 1, 2) = 2$\n$\\phi_{\\mathrm{VL}}(2) = \\frac{2+|2|}{1+|2|} = \\frac{4}{3}$\n$\\phi_{\\mathrm{MC}}(2) = \\max(0, \\min(\\frac{1+2}{2}, 2, 4)) = \\max(0, \\frac{3}{2}) = \\frac{3}{2}$\n因此，对于所有三种限制器，$\\phi(r_1)=\\phi(r_3)=\\phi(2)$，其中 $\\phi(2)$ 是每种限制器的具体值。\n\n现在我们计算时间 $n+1$ 时的差分 $ \\delta_i^{n+1} = u_{i+1}^{n+1} - u_i^{n+1}$。\n$$\n\\delta_i^{n+1} = (u_{i+1}^n - u_i^n) - \\lambda(u_{i+1}^n - 2u_i^n + u_{i-1}^n) - \\frac{\\lambda(1-\\lambda)}{2}[\\phi(r_{i+1})\\Delta_{i+1}^n - 2\\phi(r_i)\\Delta_i^n + \\phi(r_{i-1})\\Delta_{i-1}^n]\n$$\n注意到 $u_{i+1}^n - u_i^n = \\Delta_{i+1}^n$ 且 $u_{i+1}^n - 2u_i^n + u_{i-1}^n = \\Delta_{i+1}^n-\\Delta_i^n$。\n$$\n\\delta_i^{n+1} = \\Delta_{i+1}^n - \\lambda(\\Delta_{i+1}^n - \\Delta_i^n) - \\frac{\\lambda(1-\\lambda)}{2}[\\phi(r_{i+1})\\Delta_{i+1}^n - 2\\phi(r_i)\\Delta_i^n + \\phi(r_{i-1})\\Delta_{i-1}^n]\n$$\n让我们逐一计算。令 $\\phi(2)$ 表示限制器的值。\n对于 $i=0$：$\\Delta_1=1, \\Delta_0=-2, \\Delta_{-1}=\\Delta_3=-1$。$r_1=2, r_0=-1/2, r_{-1}=r_3=2$。$\\phi(r_1)=\\phi(2), \\phi(r_0)=0, \\phi(r_3)=\\phi(2)$。\n$\\delta_0^{n+1} = \\Delta_1 - \\lambda(\\Delta_1 - \\Delta_0) - \\frac{\\lambda(1-\\lambda)}{2}[\\phi(r_1)\\Delta_1 - 2\\phi(r_0)\\Delta_0 + \\phi(r_{-1})\\Delta_{-1}]$\n$\\delta_0^{n+1} = 1 - \\lambda(1 - (-2)) - \\frac{\\lambda(1-\\lambda)}{2}[\\phi(2)(1) - 2(0)(-2) + \\phi(2)(-1)] = 1-3\\lambda - 0 = 1-3\\lambda$。\n\n对于 $i=1$：$\\Delta_2=2, \\Delta_1=1, \\Delta_0=-2$。$r_2=-1/2, r_1=2, r_0=-1/2$。$\\phi(r_2)=0, \\phi(r_1)=\\phi(2), \\phi(r_0)=0$。\n$\\delta_1^{n+1} = \\Delta_2 - \\lambda(\\Delta_2 - \\Delta_1) - \\frac{\\lambda(1-\\lambda)}{2}[\\phi(r_2)\\Delta_2 - 2\\phi(r_1)\\Delta_1 + \\phi(r_0)\\Delta_0]$\n$\\delta_1^{n+1} = 2 - \\lambda(2-1) - \\frac{\\lambda(1-\\lambda)}{2}[0(2) - 2\\phi(2)(1) + 0(-2)] = 2-\\lambda - \\frac{\\lambda(1-\\lambda)}{2}(-2\\phi(2))$\n$\\delta_1^{n+1} = 2-\\lambda + \\lambda(1-\\lambda)\\phi(2)$。\n\n对于 $i=2$：$\\Delta_3=-1, \\Delta_2=2, \\Delta_1=1$。$r_3=2, r_2=-1/2, r_1=2$。$\\phi(r_3)=\\phi(2), \\phi(r_2)=0, \\phi(r_1)=\\phi(2)$。\n$\\delta_2^{n+1} = \\Delta_3 - \\lambda(\\Delta_3 - \\Delta_2) - \\frac{\\lambda(1-\\lambda)}{2}[\\phi(r_3)\\Delta_3 - 2\\phi(r_2)\\Delta_2 + \\phi(r_1)\\Delta_1]$\n$\\delta_2^{n+1} = -1 - \\lambda(-1-2) - \\frac{\\lambda(1-\\lambda)}{2}[\\phi(2)(-1) - 2(0)(2) + \\phi(2)(1)] = -1+3\\lambda - 0 = -1+3\\lambda$。\n\n对于 $i=3$：$\\Delta_0=-2, \\Delta_3=-1, \\Delta_2=2$。$r_0=-1/2, r_3=2, r_2=-1/2$。$\\phi(r_0)=0, \\phi(r_3)=\\phi(2), \\phi(r_2)=0$。\n$\\delta_3^{n+1} = \\Delta_0 - \\lambda(\\Delta_0 - \\Delta_3) - \\frac{\\lambda(1-\\lambda)}{2}[\\phi(r_0)\\Delta_0 - 2\\phi(r_3)\\Delta_3 + \\phi(r_2)\\Delta_2]$\n$\\delta_3^{n+1} = -2 - \\lambda(-2 - (-1)) - \\frac{\\lambda(1-\\lambda)}{2}[0(-2) - 2\\phi(2)(-1) + 0(2)] = -2+\\lambda - \\frac{\\lambda(1-\\lambda)}{2}(2\\phi(2))$\n$\\delta_3^{n+1} = -2+\\lambda - \\lambda(1-\\lambda)\\phi(2)$。\n\n新的总变差为 $TV(u^{n+1}) = \\sum_{i=0}^3|\\delta_i^{n+1}|$。\n注意到 $\\delta_2^{n+1} = -(1-3\\lambda) = -\\delta_0^{n+1}$ 且 $\\delta_3^{n+1} = -(2-\\lambda+\\lambda(1-\\lambda)\\phi(2)) = -\\delta_1^{n+1}$。\n所以，$TV(u^{n+1}) = |\\delta_0^{n+1}| + |\\delta_1^{n+1}| + |-\\delta_0^{n+1}| + |-\\delta_1^{n+1}| = 2|\\delta_0^{n+1}| + 2|\\delta_1^{n+1}|$。\n$TV(u^{n+1}) = 2|1-3\\lambda| + 2|2-\\lambda+\\lambda(1-\\lambda)\\phi(2)|$。\n对于 $\\lambda \\in [0,1]$，项 $2-\\lambda > 0$。项 $\\lambda(1-\\lambda) \\ge 0$。限制器值 $\\phi(2)$ 均为正。因此，$2-\\lambda+\\lambda(1-\\lambda)\\phi(2) > 0$。\n所以，$|2-\\lambda+\\lambda(1-\\lambda)\\phi(2)| = 2-\\lambda+\\lambda(1-\\lambda)\\phi(2)$。\n$TV(u^{n+1}) = 2|1-3\\lambda| + 2(2-\\lambda+\\lambda(1-\\lambda)\\phi(2))$。\n比率 $TV(u^{n+1})/TV(u^n)$ 是：\n$$\n\\frac{TV(u^{n+1})}{TV(u^{n})} = \\frac{2|1-3\\lambda| + 4 - 2\\lambda + 2\\lambda(1-\\lambda)\\phi(2)}{6} = \\frac{|1-3\\lambda| + 2 - \\lambda + \\lambda(1-\\lambda)\\phi(2)}{3}\n$$\n我们现在为每种限制器代入 $\\phi(2)$ 的具体值。\n\n1.  Superbee: $\\phi_{\\mathrm{SB}}(2) = 2$.\n    $\\frac{|1-3\\lambda| + 2 - \\lambda + \\lambda(1-\\lambda)(2)}{3} = \\frac{|1-3\\lambda| + 2 - \\lambda + 2\\lambda - 2\\lambda^2}{3} = \\frac{|1-3\\lambda| + 2 + \\lambda - 2\\lambda^2}{3}$.\n\n2.  van Leer: $\\phi_{\\mathrm{VL}}(2) = \\frac{4}{3}$.\n    $\\frac{|1-3\\lambda| + 2 - \\lambda + \\lambda(1-\\lambda)(\\frac{4}{3})}{3} = \\frac{|1-3\\lambda| + 2 - \\lambda + \\frac{4}{3}\\lambda - \\frac{4}{3}\\lambda^2}{3} = \\frac{|1-3\\lambda| + 2 + \\frac{1}{3}\\lambda - \\frac{4}{3}\\lambda^2}{3}$。为清晰起见，这可以重写为 $\\frac{3|1-3\\lambda| + 6 + \\lambda - 4\\lambda^2}{9}$。\n\n3.  Monotonized Central (MC): $\\phi_{\\mathrm{MC}}(2) = \\frac{3}{2}$.\n    $\\frac{|1-3\\lambda| + 2 - \\lambda + \\lambda(1-\\lambda)(\\frac{3}{2})}{3} = \\frac{|1-3\\lambda| + 2 - \\lambda + \\frac{3}{2}\\lambda - \\frac{3}{2}\\lambda^2}{3} = \\frac{|1-3\\lambda| + 2 + \\frac{1}{2}\\lambda - \\frac{3}{2}\\lambda^2}{3}$。这可以重写为 $\\frac{2|1-3\\lambda| + 4 + \\lambda - 3\\lambda^2}{6}$。\n\n这些就是总变差比率的最终表达式。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{|1-3\\lambda| + 2 + \\lambda - 2\\lambda^2}{3}, & \\frac{3|1-3\\lambda| + 6 + \\lambda - 4\\lambda^2}{9}, & \\frac{2|1-3\\lambda| + 4 + \\lambda - 3\\lambda^2}{6}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在上述解析分析的基础上，本练习将重点转向在完整数值模拟中不同TVD通量限制器的实际性能。你将实现并比较三种经典的限制器——minmod、Monotonized Central (MC) 和 superbee——以观察它们在解析尖锐间断时的独特表现。这项对比研究对于培养在数值耗散和抑制伪振荡之间的权衡直觉至关重要，这是为特定问题选择合适格式的关键技能。",
            "id": "3383804",
            "problem": "考虑一个标量场 $u(x,t)$ 的守恒形式线性平流方程，其平流速度 $a$ 为常数，\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(a\\,u\\right) = 0,\n$$\n方程建立在长度为 $L$ 的周期性定义域上。设初始条件为单位阶跃，左状态为 $u_L$，右状态为 $u_R$，位置在点 $x_s \\in [0,L)$。空间网格是均匀的，有 $N_x$ 个控制体积。目标是使用三种不同的通量限制器（minmod、Monotonized Central (MC) 和 superbee），数值研究在高分辨率二阶总变差递减（TVD）守恒律单调上游中心格式（MUSCL）下，总变差的演化情况。\n\n您的推导和实现应基于以下基本原理和事实：\n- 针对单元平均值 $u_i^n$ 的守恒律有限体积更新，使用相容的数值通量 $F_{i+1/2}^n$，\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right).\n$$\n- 库朗数 $C$ 由 $C = a\\,\\Delta t / \\Delta x$ 给出。\n- 周期网格上，网格函数 $u^n = \\{u_i^n\\}$ 的总变差为\n$$\nTV(u^n) = \\sum_{i=0}^{N_x-1} \\left|u_{i+1}^n - u_i^n\\right|,\n$$\n其中使用周期性索引，使得 $u_{N_x}^n \\equiv u_0^n$。\n- 对于常数 $a>0$，一个与 Sweby 框架相容的高分辨率TVD通量限制器方法，将一个上风单调通量与一个受限的高阶修正项相结合。该修正项取决于局部光滑度比 $r_i$ 和一个限制器函数 $\\phi(r)$，从而使得格式在光滑区域达到二阶精度，而在间断附近退化为单调上风格式。假设采用标准的 MUSCL 型重构，其中 $r_i$ 由连续梯度的比率定义，限制器 $\\phi(r)$ 属于经典的 TVD 容许集。\n\n使用以下定义在光滑度比 $r$ 上的限制器函数（约定当 $r$ 的分母为零时，使用 $r=0$）：\n- Minmod 限制器：$\\phi_{\\text{MM}}(r) = \\max\\left(0, \\min\\left(1, r\\right)\\right)$。\n- Monotonized Central 限制器：$\\phi_{\\text{MC}}(r) = \\max\\left(0, \\min\\left(\\frac{1+r}{2}, 2, 2r\\right)\\right)$。\n- Superbee 限制器：$\\phi_{\\text{SB}}(r) = \\max\\left(0, \\min\\left(2r,1\\right), \\min\\left(r,2\\right)\\right)$。\n- 光滑度比定义为：$r_i = \\frac{u_{i+1}^n-u_i^n}{u_i^n-u_{i-1}^n}$。\n\n您的任务是：\n- 针对线性平流方程，推导一个使用上述限制器的守恒型二阶 MUSCL 类 TVD 离散格式，确保其对于容许范围内的库朗数 $C$ 满足总变差递减（TVD）属性。\n- 实现所推导的方法，并计算在周期性阶跃初始条件下，选定时间步的总变差 $TV(u^n)$。所有三种限制器使用相同的库朗数，以便通过总变差的演化来比较限制器的侵略性。\n\n本研究中使用的实现细节：\n- 定义域：周期区间 $[0,L)$，其中 $L = 1$。\n- 平流速度：$a = 1$。\n- 网格单元数：$N_x = 400$。\n- 初始条件：当 $x < x_s$ 时，$u(x,0) = u_L$；当 $x \\ge x_s$ 时，$u(x,0) = u_R$。其中 $u_L = 1$, $u_R = 0$, $x_s = 0.3$。\n- 时间积分：依据守恒型有限体积法进行显式单步更新，使用与上述原理相容的 MUSCL 型 TVD 数值通量。必须强制执行周期性边界条件。\n- 库朗数和采样计划（测试套件）：\n    - 测试 A（理想情况）：$C = 0.8$，演化 $N_{\\text{steps}} = 80$ 个时间步，并记录时间步 $n \\in \\{0,10,20,40,80\\}$ 的总变差。\n    - 测试 B（扩散情况）：$C = 0.2$，演化 $N_{\\text{steps}} = 80$ 个时间步，并在相同的时间步集合 $n \\in \\{0,10,20,40,80\\}$ 记录 $TV(u^n)$。\n    - 测试 C（CFL 边界情况）：$C = 1.0$，演化 $N_{\\text{steps}} = 80$ 个时间步，并在相同的时间步集合 $n \\in \\{0,10,20,40,80\\}$ 记录 $TV(u^n)$。\n- 对于每项测试，按 minmod, MC, superbee 的顺序，计算并报告每个限制器的总变差序列。\n\n您的程序必须生成单行输出，其中包含一个扁平化的浮点数列表，该列表聚合了所有结果。结果的排序方式如下：按照 A、B、C 的顺序遍历每个测试，在每个测试内部，按照 minmod、MC、superbee 的顺序遍历每个限制器，然后将在时间步 $n \\in \\{0,10,20,40,80\\}$ 测得的总变差值按 $n$ 的升序追加。最终输出格式必须是单行的 Python 风格列表，例如，\n`[v_1,v_2, ... , v_M]`\n其中每个 $v_k$ 是一个代表一次测得总变差的浮点数。由于 $TV(u^n)$ 是无量纲的，输出不需要物理单位。",
            "solution": "我们从定义在周期性定义域上的标量场 $u(x,t)$ 的线性平流方程开始，其平流速度 $a$ 为常数，\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(a\\,u\\right) = 0,\n$$\n守恒型有限体积法通过以下方式更新单元平均值 $u_i^n$：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right),\n$$\n其中 $F_{i+1/2}^n$ 是一个在单元 $i$ 和 $i+1$ 界面上近似 $a\\,u$ 的相容数值通量。对于常数 $a>0$，一阶迎风格式是总变差递减（TVD）的，但具有扩散性。为了在光滑区域恢复二阶精度，同时在间断附近保持 TVD 属性，我们采用 MUSCL (Monotone Upstream-centered Schemes for Conservation Laws) 方法。\n\n库朗数为 $C = a\\,\\Delta t/\\Delta x$，对于 $0 \\le C \\le 1$，可以通过合适的限制器来确保 TVD 属性。对于 $a>0$，数值通量 $F_{i+1/2}$ 基于从左侧重构的状态 $u_{i+1/2}^L$ 计算得出，即 $F_{i+1/2} = a u_{i+1/2}^L$。该状态通过分段线性重构得到：\n$$\nu_{i+1/2}^L = u_i + \\frac{1}{2}\\sigma_i\n$$\n其中 $\\sigma_i$ 是在单元 $i$ 内的受限斜率。斜率通过限制函数 $\\phi(r)$ 对一个参考斜率进行缩放得到。对于迎风格式，使用后向差分作为参考斜率是自然的选择：\n$$\n\\sigma_i = \\phi(r_i)(u_i^n - u_{i-1}^n)\n$$\n其中光滑度比 $r_i$ 定义为连续梯度的比率：\n$$\nr_i = \\frac{u_{i+1}^n - u_i^n}{u_i^n - u_{i-1}^n}\n$$\n当 $u_i^n - u_{i-1}^n = 0$ 时，约定 $r_i=0$。将所有部分组合在一起，数值通量为：\n$$\nF_{i+1/2}^n = a \\left( u_i^n + \\frac{1}{2}\\phi(r_i)(u_i^n - u_{i-1}^n) \\right)\n$$\n这个构造，当与所列出的 minmod、MC 和 superbee 限制器（它们都位于 Sweby 的 TVD 区域内）一起使用时，可以保证对于 $0 \\le C \\le 1$，整个格式是 TVD 的。总变差递减属性被理解为\n$$\nTV(u^{n+1}) \\le TV(u^n),\n$$\n其中对于周期性数据\n$$\nTV(u^n) = \\sum_{i=0}^{N_x-1} \\left|u_{i+1}^n - u_i^n\\right|, \\quad u_{N_x}^n \\equiv u_0^n.\n$$\n\n算法设计：\n- 在 $[0,1)$ 上初始化一个包含 $N_x = 400$ 个单元的均匀网格，单元中心为 $x_i = \\left(i + \\frac{1}{2}\\right)\\Delta x$，其中 $\\Delta x = L/N_x$ 且 $L=1$。\n- 初始化 $u_i^0$，如果 $x_i < x_s$ 则为 $u_L$，否则为 $u_R$，其中 $u_L = 1, u_R = 0, x_s = 0.3$。在周期性条件下，这会产生两个跳跃，因此 $TV(u^0) = 2$。\n- 对于每个测试库朗数 $C \\in \\{0.8,0.2,1.0\\}$，设置 $\\Delta t = C\\,\\Delta x/a$（其中 $a=1$）。通过重复以下步骤演化 $N_{\\text{steps}} = 80$ 次：\n    - 计算周期性的后向差分 $\\Delta^- u_i = u_i^n - u_{i-1}^n$ 和前向差分 $\\Delta^+ u_i = u_{i+1}^n - u_i^n$。\n    - 构建 $r_i = \\Delta^+ u_i / \\Delta^- u_i$，其中 $\\Delta^- u_i \\ne 0$，否则设 $r_i=0$。\n    - 对所选的限制器计算 $\\phi(r_i)$。\n    - 组装界面通量 $F_{i+1/2}^n = a \\left( u_i^n + \\frac{1}{2}\\phi(r_i)\\Delta^- u_i \\right)$，使用周期性索引。\n    - 使用周期性平移来获取 $F_{i-1/2}^n$，并进行更新 $u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right)$。\n    - 在指定的时间步 $n \\in \\{0,10,20,40,80\\}$，通过对所有 $i$（使用周期性索引）求和 $|\\Delta^+ u_i|$ 来计算 $TV(u^n)$。\n- 对每个限制器选项（minmod、MC、superbee）重复上述过程。\n\n预期的定性行为：\n- 对于 $C=0.8$（理想情况），minmod 会更剧烈地耗散总变差，MC 会保留更多的变差，而 superbee 在保持 TVD 的同时，会最大程度地保留变差和最陡峭的前缘。\n- 对于 $C=0.2$（由于库朗数较小而更具扩散性），所有限制器都将显示出更显著的总变差衰减，其侵略性排序不变：minmod 扩散最大，superbee 扩散最小。\n- 对于 $C=1.0$（Courant–Friedrichs–Lewy 边界），该格式精确退化为纯粹平移一个网格单元的迎风格式，即 $u_i^{n+1}=u_{i-1}^n$，这能精确地保持总变差。\n- 程序必须输出单行，其中包含一个扁平化的 Python 风格浮点值列表，排序如下：测试 A 的 minmod 序列，测试 A 的 MC 序列，测试 A 的 superbee 序列，然后是顺序相同的测试 B，再然后是顺序相同的测试 C。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef phi_minmod(r):\n    r = np.asarray(r)\n    return np.maximum(0.0, np.minimum(1.0, r))\n\ndef phi_mc(r):\n    r = np.asarray(r)\n    return np.maximum(0.0, np.minimum(np.minimum((1.0 + r) / 2.0, 2.0), 2.0 * r))\n\ndef phi_superbee(r):\n    r = np.asarray(r)\n    return np.maximum(0.0, np.maximum(np.minimum(2.0 * r, 1.0), np.minimum(r, 2.0)))\n\ndef get_limiter_func(name):\n    if name == 'minmod':\n        return phi_minmod\n    elif name == 'MC':\n        return phi_mc\n    elif name == 'superbee':\n        return phi_superbee\n    else:\n        raise ValueError(\"Unknown limiter\")\n\ndef compute_tv(u):\n    return np.sum(np.abs(np.roll(u, -1) - u))\n\ndef muscl_tvd_advection_tv_sequence(C, limiter_name, Nx=400, L=1.0, a=1.0, nsteps=80, checkpoints=(0, 10, 20, 40, 80)):\n    dx = L / Nx\n    dt = C * dx / a\n    x = (np.arange(Nx) + 0.5) * dx\n    \n    # Initial condition\n    u = np.zeros(Nx, dtype=np.float64)\n    u_L, u_R, x_s = 1.0, 0.0, 0.3\n    u[x  x_s] = u_L\n    \n    limiter_func = get_limiter_func(limiter_name)\n    \n    tv_results = []\n    \n    for n in range(nsteps + 1):\n        if n in checkpoints:\n            tv_results.append(compute_tv(u))\n            \n        if n == nsteps:\n            break\n            \n        u_prev = np.roll(u, 1)\n        u_next = np.roll(u, -1)\n        \n        delta_plus = u_next - u\n        delta_minus = u - u_prev\n        \n        r = np.zeros_like(u)\n        mask = np.abs(delta_minus) > 1e-12\n        r[mask] = delta_plus[mask] / delta_minus[mask]\n        \n        phi_vals = limiter_func(r)\n        \n        # MUSCL reconstruction for u_{i+1/2}^L with upwind-biased slope\n        # sigma_i = phi(r_i) * (u_i - u_{i-1})\n        sigma = phi_vals * delta_minus\n        \n        # Interface fluxes: F_{i+1/2} = a * u_{i+1/2}^L\n        F_interface = a * (u + 0.5 * sigma)\n        F_prev_interface = np.roll(F_interface, 1)\n        \n        u = u - (dt / dx) * (F_interface - F_prev_interface)\n        \n    return tv_results\n    \ndef solve():\n    all_results = []\n    checkpoints = (0, 10, 20, 40, 80)\n    \n    tests = [\n        (0.8, 'minmod'), (0.8, 'MC'), (0.8, 'superbee'),\n        (0.2, 'minmod'), (0.2, 'MC'), (0.2, 'superbee'),\n        (1.0, 'minmod'), (1.0, 'MC'), (1.0, 'superbee'),\n    ]\n    \n    for C_val, limiter in tests:\n        res = muscl_tvd_advection_tv_sequence(C=C_val, limiter_name=limiter, checkpoints=checkpoints)\n        all_results.extend(res)\n        \n    print(str(all_results))\n\nif __name__ == '__main__':\n    # This block is for local execution and will not be part of the final answer tag content.\n    # To generate the required output list, this code would be run.\n    # The output is a list of floats.\n    # For the purpose of filling the XML, we assume the code runs and produces a valid list.\n    # Since I cannot execute code, I will just provide the runnable script.\n    # A placeholder call to solve() is appropriate.\n    solve()\n```"
        },
        {
            "introduction": "TVD离散化的原理远不止适用于线性平流方程。这项综合性练习将挑战你将这些概念应用于非线性的浅水方程组——计算水力学中的一个主力模型。你将面对真实世界的复杂性，例如确保水深 $h$ 的非负性（处理干底问题）和维持静止状态下的“良好平衡”特性，最终为一个物理相关的系统设计出一个稳健的二阶精度格式。",
            "id": "3383825",
            "problem": "考虑一维浅水系统（无水深测绘），其由质量和动量守恒定律组成\n$$\nh_t + (hu)_x = 0,\\qquad (hu)_t + \\left(hu^2 + \\tfrac{1}{2} g h^2\\right)_x = 0,\n$$\n其中 $h$ 是水高，$u$ 是速度，$hu$ 是流量，$g$ 是重力加速度。计算任务是设计一个有限体积离散化方案，该方案对于 $h$ 是总变差递减（TVD）的，在存在干涸河床（$h=0$）时保持 $h$ 的非负性，并且对于静止湖泊状态（$h$ 为常数且速度 $u=0$）是良态平衡的。你必须使用斜率限制器为单元界面状态构建一个空间上二阶精确的重构，并使用一个单步方法，其稳定性属性在 Courant–Friedrichs–Lewy (CFL) 约束下能保证 TVD。你必须选择一个与系统双曲结构一致的单调数值通量，并在适当的时间步长限制下支持 $h$ 的正性保持。\n\n你的推导必须从均匀网格上的通用守恒律的有限体积形式开始，该网格的单元中心为 $x_i$，间距为 $\\Delta x$，在时间 $t^n$ 的单元平均值为 $Q_i^n$，在 $x_{i\\pm \\frac{1}{2}}$ 的界面通量，以及总变差的定义\n$$\nTV(h^n) = \\sum_{i} \\left|h_{i+1}^n - h_i^n\\right|.\n$$\n在这些基础上，推导对重构、通量和时间离散化的要求，以确保\n$$\nh_i^{n+1} \\ge 0\\quad\\text{for all }i,\\qquad TV(h^{n+1}) \\le TV(h^n),\n$$\n并且你的格式能够精确地保持静止湖泊状态 $h\\equiv \\text{constant}$, $u\\equiv 0$。将注意力限制在有限区间上的一维周期性域或透射（零梯度）边界上，并假设重力加速度参数为 $g=9.81$，单位为 $\\mathrm{m/s^2}$；此问题中的最终答案是布尔值，因此不需要物理单位。\n\n将你推导的算法实现为一个程序，对下面的每个测试案例执行一步强稳定性保持（Strong Stability Preserving）时间积分（使用从计算出的 CFL 条件中选择的单个时间步长）。空间网格是均匀的，有 $N$ 个单元，域长度为 $L$，间距为 $\\Delta x = L/N$。基于 CFL 的时间步长必须计算为\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{\\max_i\\left(|u_i| + \\sqrt{g\\,h_i}\\right)},\n$$\n其中固定的 $\\text{CFL}$ 由你选择以满足 TVD 和正性条件。使用透射边界条件。\n\n测试套件：\n- 案例 A（静止湖泊，良态平衡和 TVD 检查）：$L=1.0$, $N=100$, $g=9.81$, 对所有 $x$, $h(x,0)=1.0$，对所有 $x$, $u(x,0)=0$。\n- 案例 B（右侧为干涸河床的溃坝问题，正性和 TVD 检查）：$L=1.0$, $N=200$, $g=9.81$, 对 $x0.5$，$h(x,0)=1.0$，对 $x\\ge 0.5$，$h(x,0)=0.0$，$u(x,0)=0$。\n- 案例 C（平滑小振幅扰动，TVD 检查）：$L=1.0$, $N=200$, $g=9.81$, $h(x,0)=1.0+0.2\\sin(2\\pi x)$, $u(x,0)=0$。\n- 案例 D（接近真空的干涸河床，正性和 TVD 检查）：$L=1.0$, $N=200$, $g=9.81$, 对 $x0.5$，$h(x,0)=10^{-3}$，对 $x\\ge 0.5$，$h(x,0)=0.0$，$u(x,0)=0$。\n\n对于每个案例，精确执行你的格式的一步二阶强稳定性保持步骤，并评估以下标准：\n- 非负性：$\\min_i h_i^{n+1} \\ge 0$。\n- TVD: $TV(h^{n+1}) \\le TV(h^n)$。\n- 仅对于案例 A，良态平衡：$\\max_i |h_i^{n+1}-h_i^n| + \\max_i |(hu)_i^{n+1}-(hu)_i^n|$ 小于一个小的容差。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[true,true,true,true]”）。每个条目是对应于案例 A-D 的布尔值，其中“true”表示该案例的所有要求标准均已满足，否则为“false”。不允许有其他输出。",
            "solution": "我们从守恒变量向量 $Q=(q_1,q_2)$（此处选择为 $Q=(h,hu)$）在均匀网格上的守恒律的有限体积形式开始，该网格的单元中心为 $x_i$，间距为 $\\Delta x$。对于双曲系统 $Q_t + F(Q)_x=0$ 的半离散有限体积方法是\n$$\n\\frac{d Q_i}{d t} = - \\frac{1}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\n其中 $F_{i\\pm\\frac{1}{2}}$ 是在界面上逼近 $F(Q)$ 的相容数值通量。使用时间步长 $\\Delta t$ 的前向欧拉更新为\n$$\nQ_i^{n+1} = Q_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right).\n$$\n为了在控制不连续点附近的伪振荡的同时实现二阶空间精度，我们使用带有斜率限制器的分段线性重构。对于原始变量 $w_i$（例如 $h$ 或 $u$），通过总变差递减限制器（例如 minmod 限制器）定义限制斜率 $\\sigma_i$：\n$$\n\\operatorname{minmod}(a,b) = \\begin{cases}\n\\mathrm{sign}(a)\\min(|a|,|b|),  \\text{如果 } ab0,\\\\\n0,  \\text{否则},\n\\end{cases}\n$$\n并设置\n$$\n\\sigma_i = \\operatorname{minmod}(w_i - w_{i-1},\\, w_{i+1} - w_i).\n$$\n那么，在界面 $x_{i+\\frac{1}{2}}$ 处的左右重构状态为\n$$\nw_{i+\\frac{1}{2}}^L = w_i + \\tfrac{1}{2}\\sigma_i,\\qquad\nw_{i+\\frac{1}{2}}^R = w_{i+1} - \\tfrac{1}{2}\\sigma_{i+1}.\n$$\n我们对原始变量对 $(h,u)$ 执行此重构，然后通过 $(h,hu)=(h,h\\,u)$ 将其转换为界面上的守恒变量。为保证在存在干涸河床时重构状态中 $h\\ge 0$，我们通过以下方式截断界面高度\n$$\nh_{i+\\frac{1}{2}}^{L} \\leftarrow \\max\\{h_{i+\\frac{1}{2}}^{L},\\,0\\},\\quad\nh_{i+\\frac{1}{2}}^{R} \\leftarrow \\max\\{h_{i+\\frac{1}{2}}^{R},\\,0\\},\n$$\n并在 $h=0$ 时将相应的流量设为 $0$。这种重构对于 $h$ 是 TVD 的，因为 minmod 限制器确保在使用单调通量和合适的时间步长限制的前向欧拉步中，离散总变差不会增加，并且强稳定性保持时间积分器在相同的限制下继承了此 TVD 属性。\n\n对于数值通量，我们选择一个具有正性保持性质的单调近似黎曼求解器。一个具有这些性质的广泛使用的选择是双波 Harten–Lax–van Leer–Einfeldt (HLLE) 通量。给定界面处的左右状态 $Q^L=(h^L,(hu)^L)$ 和 $Q^R=(h^R,(hu)^R)$，定义原始速度和波速为\n$$\nu^L = \\begin{cases}\\frac{(hu)^L}{h^L},  h^L0,\\\\ 0,  h^L=0,\\end{cases}\\quad\nu^R = \\begin{cases}\\frac{(hu)^R}{h^R},  h^R0,\\\\ 0,  h^R=0,\\end{cases}\n$$\n$$\nc^L = \\sqrt{g h^L},\\qquad c^R = \\sqrt{g h^R},\n$$\n以及信号速度\n$$\ns_L = \\min\\{u^L - c^L,\\, u^R - c^R\\},\\qquad s_R = \\max\\{u^L + c^L,\\, u^R + c^R\\}.\n$$\n令物理通量为 $F(Q)=(hu,\\, (hu)^2/h + \\tfrac{1}{2} g h^2)$（当 $h0$ 时）和 $F(Q)=(0,0)$（当 $h=0$ 时）。HLLE 通量为\n$$\nF_{\\mathrm{HLLE}} =\n\\begin{cases}\nF(Q^L),  s_L \\ge 0,\\\\\nF(Q^R),  s_R \\le 0,\\\\\n\\frac{s_R F(Q^L) - s_L F(Q^R) + s_L s_R (Q^R - Q^L)}{s_R - s_L},  s_L  0  s_R.\n\\end{cases}\n$$\n在 Courant–Friedrichs–Lewy 条件 $\\Delta t \\le \\text{CFL} \\frac{\\Delta x}{\\max_i(|u_i| + \\sqrt{g h_i})}$ 且 $\\text{CFL}\\le 1/2$ 时，HLLE 通量与前向欧拉法相结合对 $h$ 是单调且保持正性的。为了在保持 TVD 的同时实现二阶时间精度，我们采用二阶强稳定性保持龙格-库塔方法（也称为 Shu–Osher 格式）：\n$$\nQ^{(1)} = Q^n + \\Delta t\\, L(Q^n),\\qquad\nQ^{n+1} = \\tfrac{1}{2} Q^n + \\tfrac{1}{2}\\left(Q^{(1)} + \\Delta t\\, L(Q^{(1)})\\right),\n$$\n其中 $L(Q)$ 表示半离散算子 $L(Q)_i = -\\tfrac{1}{\\Delta x}(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}})$，使用了上述的重构和通量。强稳定性保持理论确保，如果时间步长为 $\\Delta t$ 的前向欧拉法在 $h$ 上是 TVD 的，那么只要遵守相同的时间步长限制，这个龙格-库塔方法也是 TVD 的。\n\n对于静止湖泊状态 $h\\equiv H$, $u\\equiv 0$ 的良态平衡性得以保持，因为重构在每个界面上产生恒定的左右状态 $h^L=h^R=H$, $u^L=u^R=0$，从而导致相邻界面上的通量相同。因此，$F_{i+\\frac{1}{2}}=F_{i-\\frac{1}{2}}$ 且 $L(Q)=0$，所以强稳定性保持方法的两个阶段都使状态保持不变，精确到舍入误差。\n\n算法步骤：\n1. 从测试案例初始化 $h_i$ 和 $u_i$。构成 $Q_i=(h_i, h_i u_i)$。\n2. 计算 $\\Delta x=L/N$ 和时间步长 $\\Delta t=\\text{CFL}\\,\\Delta x / \\max_i(|u_i|+\\sqrt{g h_i})$，其中 $\\text{CFL}$ 在 $(0,1)$ 内选择以满足 TVD 和正性条件。\n3. 通过将末端单元的值复制到虚拟单元来应用透射边界条件。\n4. 通过 minmod 限制的分段线性重构来重构 $(h,u)$ 的界面状态，并在界面处截断 $h\\ge 0$；在 $h=0$ 的地方设置 $hu=0$。\n5. 在界面处计算 HLLE 通量，然后计算半离散算子 $L(Q)$。\n6. 执行一步强稳定性保持二阶步骤以获得 $Q^{n+1}$。\n7. 评估标准：$h$ 的非负性，通过比较 $TV(h^{n+1})$ 和 $TV(h^n)$ 检查 $h$ 的 TVD，对于静止湖泊情况，检查 $h$ 和 $hu$ 是否在一个小容差内保持不变。\n8. 每个案例输出一个布尔值，指示是否满足该案例的所有特定标准。",
            "answer": "```python\nimport numpy as np\n\ndef minmod(a, b):\n    sign = np.sign(a)\n    cond = (a * b) > 0.0\n    return np.where(cond, sign * np.minimum(np.abs(a), np.abs(b)), 0.0)\n\ndef apply_transmissive_bc(h, m):\n    h[0] = h[1]\n    h[-1] = h[-2]\n    m[0] = m[1]\n    m[-1] = m[-2]\n\ndef reconstruct_interfaces(h, m, g, eps=1e-14):\n    Np2 = h.shape[0]\n    N = Np2 - 2\n    u = np.zeros_like(h)\n    mask = h > eps\n    u[mask] = m[mask] / h[mask]\n\n    dh_left = h[1:N+1] - h[0:N]\n    dh_right = h[2:N+2] - h[1:N+1]\n    du_left = u[1:N+1] - u[0:N]\n    du_right = u[2:N+2] - u[1:N+1]\n    sigma_h = minmod(dh_left, dh_right)\n    sigma_u = minmod(du_left, du_right)\n\n    hL = np.zeros(N+1)\n    hR = np.zeros(N+1)\n    uL = np.zeros(N+1)\n    uR = np.zeros(N+1)\n\n    sigma_h_ext = np.zeros(N+2)\n    sigma_u_ext = np.zeros(N+2)\n    sigma_h_ext[1:N+1] = sigma_h\n    sigma_u_ext[1:N+1] = sigma_u\n\n    hL[:] = h[0:N+1] + 0.5 * sigma_h_ext[0:N+1]\n    uL[:] = u[0:N+1] + 0.5 * sigma_u_ext[0:N+1]\n    hR[:] = h[1:N+2] - 0.5 * sigma_h_ext[1:N+2]\n    uR[:] = u[1:N+2] - 0.5 * sigma_u_ext[1:N+2]\n\n    hL = np.maximum(hL, 0.0)\n    hR = np.maximum(hR, 0.0)\n    uL = np.where(hL > eps, uL, 0.0)\n    uR = np.where(hR > eps, uR, 0.0)\n\n    mL = hL * uL\n    mR = hR * uR\n\n    return hL, mL, hR, mR\n\ndef hlle_flux(hL, mL, hR, mR, g, eps=1e-14):\n    uL = np.zeros_like(hL)\n    uR = np.zeros_like(hR)\n    maskL = hL > eps\n    maskR = hR > eps\n    uL[maskL] = mL[maskL] / hL[maskL]\n    uR[maskR] = mR[maskR] / hR[maskR]\n\n    cL = np.sqrt(g * hL)\n    cR = np.sqrt(g * hR)\n\n    sL = np.minimum(uL - cL, uR - cR)\n    sR = np.maximum(uL + cL, uR + cR)\n\n    FhL = mL\n    FhR = mR\n    FmL = np.where(maskL, mL * uL + 0.5 * g * hL * hL, 0.0)\n    FmR = np.where(maskR, mR * uR + 0.5 * g * hR * hR, 0.0)\n\n    Fh = np.zeros_like(hL)\n    Fm = np.zeros_like(hL)\n\n    left_dom = sL >= 0.0\n    right_dom = sR = 0.0\n    mid_dom = ~(left_dom | right_dom)\n\n    Fh[left_dom] = FhL[left_dom]\n    Fm[left_dom] = FmL[left_dom]\n    Fh[right_dom] = FhR[right_dom]\n    Fm[right_dom] = FmR[right_dom]\n\n    denom = sR[mid_dom] - sL[mid_dom]\n    safe = np.where(np.abs(denom) > eps, denom, eps)\n\n    Fh[mid_dom] = (sR[mid_dom] * FhL[mid_dom] - sL[mid_dom] * FhR[mid_dom] +\n                   sL[mid_dom] * sR[mid_dom] * (hR[mid_dom] - hL[mid_dom])) / safe\n    Fm[mid_dom] = (sR[mid_dom] * FmL[mid_dom] - sL[mid_dom] * FmR[mid_dom] +\n                   sL[mid_dom] * sR[mid_dom] * (mR[mid_dom] - mL[mid_dom])) / safe\n\n    return Fh, Fm\n\ndef semi_discrete_L(h, m, g, dx):\n    apply_transmissive_bc(h, m)\n    hL, mL, hR, mR = reconstruct_interfaces(h, m, g)\n    Fh, Fm = hlle_flux(hL, mL, hR, mR, g)\n    Lh = -(Fh[1:] - Fh[:-1]) / dx\n    Lm = -(Fm[1:] - Fm[:-1]) / dx\n    return Lh, Lm\n\ndef ssp_rk2_step(h, m, g, dx, dt):\n    Lh1, Lm1 = semi_discrete_L(h.copy(), m.copy(), g, dx)\n    h1 = h.copy()\n    m1 = m.copy()\n    h1[1:-1] = h[1:-1] + dt * Lh1\n    m1[1:-1] = m[1:-1] + dt * Lm1\n\n    Lh2, Lm2 = semi_discrete_L(h1.copy(), m1.copy(), g, dx)\n    h2 = h1.copy()\n    m2 = m1.copy()\n    h2[1:-1] = h1[1:-1] + dt * Lh2\n    m2[1:-1] = m1[1:-1] + dt * Lm2\n\n    h_new = h.copy()\n    m_new = m.copy()\n    h_new[1:-1] = 0.5 * (h[1:-1] + h2[1:-1])\n    m_new[1:-1] = 0.5 * (m[1:-1] + m2[1:-1])\n    \n    apply_transmissive_bc(h_new, m_new)\n    return h_new, m_new\n\ndef compute_tv(h_real):\n    return np.sum(np.abs(h_real[1:] - h_real[:-1]))\n\ndef initial_conditions(case, L, N):\n    x = (np.arange(N) + 0.5) * (L / N)\n    if case == \"lake\":\n        h = np.ones_like(x)\n        u = np.zeros_like(x)\n    elif case == \"dam_dry\":\n        h = np.where(x  0.5, 1.0, 0.0)\n        u = np.zeros_like(x)\n    elif case == \"smooth\":\n        h = 1.0 + 0.2 * np.sin(2.0 * np.pi * x)\n        u = np.zeros_like(x)\n    elif case == \"near_vacuum\":\n        h = np.where(x  0.5, 1e-3, 0.0)\n        u = np.zeros_like(x)\n    else:\n        raise ValueError(\"Unknown case\")\n    return h, u\n\ndef cfl_dt(h_real, m_real, g, dx, CFL, eps=1e-14):\n    u_real = np.zeros_like(h_real)\n    mask = h_real > eps\n    u_real[mask] = m_real[mask] / h_real[mask]\n    speeds = np.abs(u_real) + np.sqrt(g * h_real)\n    amax = np.max(speeds)\n    if amax  eps:\n        return CFL * dx / (eps + 1.0)\n    return CFL * dx / amax\n\ndef run_case(case_name, L, N, g, CFL, tol=1e-12):\n    dx = L / N\n    h_real, u_real = initial_conditions(case_name, L, N)\n    m_real = h_real * u_real\n\n    h = np.zeros(N + 2)\n    m = np.zeros(N + 2)\n    h[1:-1] = h_real\n    m[1:-1] = m_real\n    apply_transmissive_bc(h, m)\n\n    tv0 = compute_tv(h[1:-1])\n    dt = cfl_dt(h[1:-1], m[1:-1], g, dx, CFL)\n    h_new, m_new = ssp_rk2_step(h, m, g, dx, dt)\n    h1 = h_new[1:-1]\n    m1 = m_new[1:-1]\n\n    positive = (np.min(h1) >= -tol)\n    tv1 = compute_tv(h1)\n    tvd = (tv1 = tv0 + tol)\n\n    if case_name == \"lake\":\n        wb = (np.max(np.abs(h1 - h[1:-1])) + np.max(np.abs(m1 - m[1:-1])) = tol)\n        return bool(positive and tvd and wb)\n    else:\n        return bool(positive and tvd)\n\ndef solve():\n    g = 9.81\n    CFL = 0.45\n\n    test_cases = [\n        (\"lake\", 1.0, 100, g, CFL),\n        (\"dam_dry\", 1.0, 200, g, CFL),\n        (\"smooth\", 1.0, 200, g, CFL),\n        (\"near_vacuum\", 1.0, 200, g, CFL),\n    ]\n\n    results = []\n    for name, L, N, gval, cfl in test_cases:\n        res = run_case(name, L, N, gval, cfl)\n        results.append(res)\n\n    def to_str(b):\n        return \"true\" if b else \"false\"\n\n    print(f\"[{','.join(map(to_str, results))}]\")\n\nsolve()\n```"
        }
    ]
}