{
    "hands_on_practices": [
        {
            "introduction": "在任何磁流体力学（MHD）模拟中，有效控制磁场散度误差 ($\\nabla \\cdot \\mathbf{B}$) 的第一步是能够准确地诊断它。本练习将指导您构建一个实用的计算诊断工具，用于量化数值磁单极子误差。通过在笛卡尔网格上实现有限差分算子并定义一个无量纲化的散度指标 ，您将学习如何设置触发局部清理或网格加密的阈值标准，这是开发稳健的MHD代码的一项基本技能。",
            "id": "3506882",
            "problem": "您的任务是构建和测试一个用于理想磁流体动力学（MHD, Magnetohydrodynamics）中虚假散度引发加速度的计算诊断程序。该诊断程序必须基于第一性原理，并在均匀的笛卡尔网格上实现。目标是定义一个代理加速度，用以量化对磁场高斯定律的数值违背，并设计触发局部散度清理或网格加密的阈值标准。\n\n从磁场高斯定律出发，该定律指出在连续介质中磁场必须满足 $\\nabla \\cdot \\mathbf{B} = 0$，您将在一个均匀的二维网格上推导并实现离散的诊断方法。请仅使用以下基本和经过充分检验的事实作为起点：\n\n- Maxwell方程（磁场高斯定律）：$\\nabla \\cdot \\mathbf{B} = 0$。\n- 间距为 $\\Delta x$ 和 $\\Delta y$ 的均匀笛卡尔网格。\n- 平滑场允许泰勒展开；中心有限差分可以近似内部点的一阶导数，达到二阶精度；单边差分提供一阶精度的边界闭合。\n- 磁场大小为 $|\\mathbf{B}| = \\sqrt{B_x^2 + B_y^2}$。\n- 当 $\\nabla \\cdot \\mathbf{B} \\neq 0$ 时，离散动量方程中会出现一个虚假的类单极子力；由此产生的加速度的一个常用代理与 $-(\\nabla \\cdot \\mathbf{B}) \\mathbf{B}$ 成正比（相差一个常数）。\n\n您的任务是：\n\n- 在均匀网格的内部，使用中心差分格式推导并实现一个对 $\\nabla \\cdot \\mathbf{B}$ 的二阶精度有限差分近似；在边界上，使用一个与之匹配的单边差分近似。\n- 基于这个离散散度，定义并实现一个无量纲的归一化散度指标 $\\varepsilon$，它随分辨率的变化关系为 $\\varepsilon \\sim h |\\nabla \\cdot \\mathbf{B}| / (|\\mathbf{B}| + B_{\\mathrm{floor}})$，其中 $h$ 是一个特征单元尺寸，$B_{\\mathrm{floor}}$ 是一个小的正则化常数，以防止除以零。选择 $h = \\min(\\Delta x, \\Delta y)$，并将 $B_{\\mathrm{floor}}$ 视为给定参数。\n- 定义并计算代理虚假加速度矢量 $\\mathbf{f}_{\\mathrm{div}} \\propto -(\\nabla \\cdot \\mathbf{B}) \\mathbf{B}$。\n- 根据局部诊断设计用于清理和加密的布尔触发器：\n  - 如果 $\\varepsilon > \\theta_{\\mathrm{clean}}$，则清理触发器 $T_{\\mathrm{clean}}$ 设置为真。\n  - 如果 $\\varepsilon > \\theta_{\\mathrm{ref}}$ 或 $|\\nabla \\cdot \\mathbf{B}| > \\phi_{\\mathrm{abs}}$，则加密触发器 $T_{\\mathrm{ref}}$ 设置为真。\n  使用给定的阈值 $\\theta_{\\mathrm{clean}}$、$\\theta_{\\mathrm{ref}}$ 和 $\\phi_{\\mathrm{abs}}$。\n\n您必须实现一个程序，对于下面的每个测试用例，计算：\n- 网格上 $\\varepsilon$ 的最大值，记为 $\\varepsilon_{\\max}$（无单位）。\n- $T_{\\mathrm{clean}}$ 为真的单元总数（整数计数）。\n- $T_{\\mathrm{ref}}$ 为真的单元总数（整数计数）。\n\n报告 $\\varepsilon_{\\max}$，四舍五入到六位小数。本问题中所有量均视为无单位（无量纲）。角度（如涉及）必须以弧度为单位解释。\n\n离散算子和边界条件：\n- 使用一个大小为 $N_x \\times N_y$、间距为 $\\Delta x$ 和 $\\Delta y$ 的均匀二维网格。\n- 在内部单元，使用二阶中心有限差分来近似 $\\partial B_x/\\partial x$ 和 $\\partial B_y/\\partial y$。\n- 在区域边界，使用与之匹配的一阶单边有限差分。\n\n阈值和正则化：\n- 使用 $\\theta_{\\mathrm{clean}} = 0.2$、$\\theta_{\\mathrm{ref}} = 0.6$、$\\phi_{\\mathrm{abs}} = 0.8$ 和 $B_{\\mathrm{floor}} = 10^{-6}$。\n\n测试套件：\n为以下四个测试用例提供结果。在所有情况下，网格是单元中心的，$\\mathbf{B}$ 在单元中心给出。\n\n- 测试用例 A（平滑，通过构造近似无散度）：$N_x = 33$，$N_y = 33$，区域 $x \\in [0, 2\\pi]$，$y \\in [0, 2\\pi]$，因此 $\\Delta x = 2\\pi/(N_x - 1)$ 且 $\\Delta y = 2\\pi/(N_y - 1)$。定义流函数 $\\psi(x,y) = \\sin(k_x x) \\sin(k_y y)$，其中 $k_x = 2$ 和 $k_y = 3$。通过 $B_x = \\partial \\psi/\\partial y$ 和 $B_y = -\\partial \\psi/\\partial x$ 在单元中心解析求值来构造 $\\mathbf{B}$。\n- 测试用例 B（类单极子界面）：$N_x = 9$，$N_y = 9$，$\\Delta x = 1$，$\\Delta y = 1$。对于所有满足 $i \\ge \\lceil N_x/2 \\rceil$ 的索引，定义 $B_x(i,j) = 1$，否则 $B_x(i,j) = 0$；对所有单元设置 $B_y(i,j) = 0$。这里 $i$ 和 $j$ 是代码中从零开始的索引，但您的推导必须与索引约定无关。\n- 测试用例 C（近真空噪声）：$N_x = 7$，$N_y = 7$，$\\Delta x = 1$，$\\Delta y = 1$。将 $B_x$ 和 $B_y$ 定义为独立的、由固定伪随机种子生成的、在 $[-10^{-12}, 10^{-12}]$ 内均匀分布的确定性伪随机值的小振幅场。使用与上面相同的 $B_{\\mathrm{floor}} = 10^{-6}$。\n- 测试用例 D（带有局部扰动的强均匀场）：$N_x = 17$，$N_y = 17$，$\\Delta x = 1$，$\\Delta y = 1$。对所有单元定义 $B_x(i,j) = 5$。初始时对所有单元定义 $B_y(i,j) = 0$，然后在 $y$ 方向添加一个阶跃：对于所有满足 $j \\ge \\lfloor N_y/2 \\rfloor$ 的单元，设置 $B_y(i,j) \\leftarrow B_y(i,j) + 1$，其他单元保持不变。\n\n对于每个测试用例，计算并返回一个包含三项的列表 $[\\varepsilon_{\\max}, n_{\\mathrm{clean}}, n_{\\mathrm{ref}}]$，其中 $n_{\\mathrm{clean}}$ 是 $T_{\\mathrm{clean}}$ 为真的单元数，$n_{\\mathrm{ref}}$ 是 $T_{\\mathrm{ref}}$ 为真的单元数。您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，每个测试用例的结果本身也是一个列表。例如，您应该打印一行形式为\n\"[[eA,ncA,nrA],[eB,ncB,nrB],[eC,ncC,nrC],[eD,ncD,nrD]]\"\n的字符串，不含空格，其中 $eX$ 是四舍五入到六位小数的浮点数，$ncX$、$nrX$ 是整数。",
            "solution": "目标是构建和测试一个用于数值磁流体动力学（MHD）中虚假磁散度的计算诊断程序。这涉及到在均匀笛卡尔网格上推导并实现离散算子，以量化对磁场高斯定律 $\\nabla \\cdot \\mathbf{B} = 0$ 的违背，并为诸如散度清理或网格加密等修正措施建立标准。\n\n### 步骤1：散度算子的离散化\n\n二维磁场 $\\mathbf{B} = (B_x, B_y)$ 的散度由连续介质表达式给出：\n$$ \\nabla \\cdot \\mathbf{B} = \\frac{\\partial B_x}{\\partial x} + \\frac{\\partial B_y}{\\partial y} $$\n我们的任务是在一个由点 $(x_i, y_j) = (i\\Delta x, j\\Delta y)$（整数索引 $i \\in [0, N_x-1]$ 和 $j \\in [0, N_y-1]$）定义的均匀单元中心笛卡尔网格上离散化这个算子。场分量 $B_x(i, j)$ 和 $B_y(i, j)$ 在这些单元中心是已知的。\n\n对于内部网格单元，即 $0  i  N_x-1$ 和 $0  j  N_y-1$，我们采用二阶精度的中心有限差分格式。偏导数近似为：\n$$ \\left(\\frac{\\partial B_x}{\\partial x}\\right)_{i,j} \\approx \\frac{B_x(i+1, j) - B_x(i-1, j)}{2 \\Delta x} $$\n$$ \\left(\\frac{\\partial B_y}{\\partial y}\\right)_{i,j} \\approx \\frac{B_y(i, j+1) - B_y(i, j-1)}{2 \\Delta y} $$\n因此，内部单元 $(i,j)$ 处的离散散度为：\n$$ (\\nabla \\cdot \\mathbf{B})_{i,j} \\approx \\frac{B_x(i+1, j) - B_x(i-1, j)}{2 \\Delta x} + \\frac{B_y(i, j+1) - B_y(i, j-1)}{2 \\Delta y} $$\n\n对于区域边界上的单元，对于垂直于该边界的导数需要使用一阶精度的单边差分，而切向导数仍可使用中心差分格式。例如，对于左边界上（$i=0$）但非角点（$0  j  N_y-1$）的单元，近似变为：\n$$ (\\nabla \\cdot \\mathbf{B})_{0,j} \\approx \\underbrace{\\frac{B_x(1, j) - B_x(0, j)}{\\Delta x}}_{\\text{一阶前向差分}} + \\underbrace{\\frac{B_y(0, j+1) - B_y(0, j-1)}{2 \\Delta y}}_{\\text{二阶中心差分}} $$\n在角点，例如左下角（$i=0, j=0$），两个导数都必须用一阶前向差分来近似：\n$$ (\\nabla \\cdot \\mathbf{B})_{0,0} \\approx \\frac{B_x(1, 0) - B_x(0, 0)}{\\Delta x} + \\frac{B_y(0, 1) - B_y(0, 0)}{\\Delta y} $$\n对于顶部和右侧边界，使用类似的后向差分格式。这种混合精度方案是在有界网格上离散化导数的标准方法。\n\n### 步骤2：诊断指标和触发器\n\n根据计算出的离散散度 $(\\nabla \\cdot \\mathbf{B})_{i,j}$，我们定义几个诊断量。\n\n主要的诊断是无量纲归一化散度指标 $\\varepsilon$，定义为：\n$$ \\varepsilon_{i,j} = \\frac{h |(\\nabla \\cdot \\mathbf{B})_{i,j}|}{|\\mathbf{B}|_{i,j} + B_{\\mathrm{floor}}} $$\n这里，$h = \\min(\\Delta x, \\Delta y)$ 是一个特征单元尺寸，这使得 $\\varepsilon$ 成为相对于网格尺度的散度误差度量。$|\\mathbf{B}|_{i,j} = \\sqrt{B_x(i,j)^2 + B_y(i,j)^2}$ 是局部磁场的大小。通过 $|\\mathbf{B}|$ 进行归一化使 $\\varepsilon$ 成为一个相对误差度量，这通常比绝对散度更有意义。常数 $B_{\\mathrm{floor}}$ 是一个小的正数（在本问题中为 $10^{-6}$），它对表达式进行正则化，防止在磁场极弱（近真空）的区域出现除以零或虚假的巨大 $\\varepsilon$ 值。\n\n基于 $\\varepsilon$ 和 $|\\nabla \\cdot \\mathbf{B}|$ 的值，我们定义两个用于数值控制的布尔触发器：\n\n1.  **清理触发器 ($T_{\\mathrm{clean}}$):** 此触发器指示需要进行局部散度清理操作（例如，使用双曲或椭圆清理方案）。当归一化散度超过一个中等阈值时，它被激活：\n    $$ T_{\\mathrm{clean}} \\text{ 为真，如果 } \\varepsilon > \\theta_{\\mathrm{clean}} $$\n    对于本问题，$\\theta_{\\mathrm{clean}} = 0.2$。\n\n2.  **加密触发器 ($T_{\\mathrm{ref}}$):** 此触发器表示一个更严重的问题，表明局部网格分辨率可能不足以解析场结构，需要自适应网格加密（AMR）。它由一个非常大的归一化散度或一个大的绝对散度激活：\n    $$ T_{\\mathrm{ref}} \\text{ 为真，如果 } (\\varepsilon > \\theta_{\\mathrm{ref}}) \\lor (|\\nabla \\cdot \\mathbf{B}| > \\phi_{\\mathrm{abs}}) $$\n    对于本问题，$\\theta_{\\mathrm{ref}} = 0.6$ 且 $\\phi_{\\mathrm{abs}} = 0.8$。\n\n### 步骤3：计算流程\n\n对每个测试用例，整体算法如下：\n1.  **网格和场设置：** 定义一个具有间距 $\\Delta x$ 和 $\\Delta y$ 的 $N_x \\times N_y$ 网格。根据具体的测试用例定义，在该网格上填充磁场分量 $B_x$ 和 $B_y$。\n2.  **散度计算：** 使用上述混合格式的有限差分方案，为所有单元计算离散散度 $(\\nabla \\cdot \\mathbf{B})_{i,j}$。\n3.  **诊断计算：** 为所有单元计算场强大小 $|\\mathbf{B}|_{i,j}$ 和归一化散度 $\\varepsilon_{i,j}$。\n4.  **触发器评估：** 在每个单元处评估 $T_{\\mathrm{clean}}$ 和 $T_{\\mathrm{ref}}$ 的布尔条件，得到两个布尔数组。\n5.  **结果聚合：** 从全网格的诊断数组中计算最终输出：\n    - 归一化散度的最大值，$\\varepsilon_{\\max} = \\max_{i,j}(\\varepsilon_{i,j})$。\n    - 需要清理的单元总数，$n_{\\mathrm{clean}} = \\sum_{i,j} T_{\\mathrm{clean}}(i,j)$。\n    - 需要加密的单元总数，$n_{\\mathrm{ref}} = \\sum_{i,j} T_{\\mathrm{ref}}(i,j)$。\n\n此流程应用于四个指定的测试用例，这些用例旨在探测诊断程序对不同场构型的响应：一个平滑、解析上无散度的场；一个模拟磁单极子的急剧不连续面；一个带有随机噪声的近真空区域；以及一个叠加在强均匀背景场上的场分量阶跃函数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for MHD divergence diagnostics.\n    \"\"\"\n\n    def compute_diagnostics(Nx, Ny, Bx, By, dx, dy):\n        \"\"\"\n        Computes divergence diagnostics for a given magnetic field on a Cartesian grid.\n\n        Args:\n            Nx (int): Number of grid points in x.\n            Ny (int): Number of grid points in y.\n            Bx (np.ndarray): 2D array of the x-component of the magnetic field.\n            By (np.ndarray): 2D array of the y-component of the magnetic field.\n            dx (float): Grid spacing in x.\n            dy (float): Grid spacing in y.\n\n        Returns:\n            list: A list containing [eps_max, n_clean, n_ref].\n        \"\"\"\n        # Define given thresholds and regularization constant\n        theta_clean = 0.2\n        theta_ref = 0.6\n        phi_abs = 0.8\n        B_floor = 1e-6\n        \n        # Characteristic cell size\n        h = min(dx, dy)\n\n        # Compute partial derivatives using a second-order central difference\n        # for the interior and a first-order one-sided difference at the boundaries.\n        # numpy.gradient implements this exact scheme.\n        # For a 2D array A[i, j], i is row (y), j is col (x) by default plotting convention.\n        # To match the problem's (i,j) as (x,y) indices, we should have our arrays\n        # as shape (Nx, Ny) and specify axis=0 for d/dx and axis=1 for d/dy.\n        d_Bx_dx = np.gradient(Bx, dx, axis=0)\n        d_By_dy = np.gradient(By, dy, axis=1)\n\n        # Compute divergence of B\n        div_B = d_Bx_dx + d_By_dy\n\n        # Compute magnetic field magnitude\n        B_mag = np.sqrt(Bx**2 + By**2)\n\n        # Compute dimensionless normalized divergence indicator epsilon\n        epsilon = h * np.abs(div_B) / (B_mag + B_floor)\n        \n        # Calculate maximum epsilon over the grid\n        eps_max = np.max(epsilon)\n\n        # Evaluate cleaning and refinement triggers\n        T_clean = epsilon > theta_clean\n        T_ref = (epsilon > theta_ref) | (np.abs(div_B) > phi_abs)\n\n        # Count the number of cells where triggers are true\n        n_clean = np.sum(T_clean)\n        n_ref = np.sum(T_ref)\n\n        return [round(eps_max, 6), int(n_clean), int(n_ref)]\n\n    results = []\n\n    # Test Case A: Smooth, nearly divergence-free field\n    Nx_A, Ny_A = 33, 33\n    x_A = np.linspace(0, 2 * np.pi, Nx_A)\n    y_A = np.linspace(0, 2 * np.pi, Ny_A)\n    dx_A, dy_A = x_A[1] - x_A[0], y_A[1] - y_A[0]\n    xx_A, yy_A = np.meshgrid(x_A, y_A, indexing='ij')\n    kx, ky = 2, 3\n    # psi = sin(kx*x)sin(ky*y) => Bx = d(psi)/dy, By = -d(psi)/dx\n    Bx_A = ky * np.sin(kx * xx_A) * np.cos(ky * yy_A)\n    By_A = -kx * np.cos(kx * xx_A) * np.sin(ky * yy_A)\n    results.append(compute_diagnostics(Nx_A, Ny_A, Bx_A, By_A, dx_A, dy_A))\n\n    # Test Case B: Monopole-like interface\n    Nx_B, Ny_B = 9, 9\n    dx_B, dy_B = 1.0, 1.0\n    Bx_B = np.zeros((Nx_B, Ny_B))\n    i_step_B = int(np.ceil(Nx_B / 2.0)) # For Nx=9, ceil(4.5)=5. 0-indexed: 5,6,7,8\n    Bx_B[i_step_B:, :] = 1.0\n    By_B = np.zeros((Nx_B, Ny_B))\n    results.append(compute_diagnostics(Nx_B, Ny_B, Bx_B, By_B, dx_B, dy_B))\n\n    # Test Case C: Near-vacuum noise\n    Nx_C, Ny_C = 7, 7\n    dx_C, dy_C = 1.0, 1.0\n    rng = np.random.default_rng(seed=0)\n    Bx_C = rng.uniform(-1e-12, 1e-12, size=(Nx_C, Ny_C))\n    By_C = rng.uniform(-1e-12, 1e-12, size=(Nx_C, Ny_C))\n    results.append(compute_diagnostics(Nx_C, Ny_C, Bx_C, By_C, dx_C, dy_C))\n\n    # Test Case D: Strong uniform field with localized perturbation\n    Nx_D, Ny_D = 17, 17\n    dx_D, dy_D = 1.0, 1.0\n    Bx_D = np.full((Nx_D, Ny_D), 5.0)\n    By_D = np.zeros((Nx_D, Ny_D))\n    j_step_D = int(np.floor(Ny_D / 2.0)) # For Ny=17, floor(8.5)=8. 0-indexed: 8,...,16\n    By_D[:, j_step_D:] = 1.0 # This modifies the original By_D\n    results.append(compute_diagnostics(Nx_D, Ny_D, Bx_D, By_D, dx_D, dy_D))\n    \n    # Format the final output string\n    # e.g., [[1.0,2,3],[4.0,5,6]]\n    output_str = f\"[{','.join(str(r).replace(' ', '') for r in results)}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在诊断出数值磁散度后，下一步是选择并实施一种清理策略。本练习将对两种主流的散度清理方法进行直接比较：全局性的“投影法”和局部性的“广义拉格朗日乘子（GLM）法”。通过在一个包含激波特征的测试问题上实现这两种方法 ，您将亲身体验它们在精度和计算成本之间的基本权衡，这对于在特定的天体物理模拟中做出明智的方法选择至关重要。",
            "id": "3506842",
            "problem": "您需要实现并比较两种用于磁流体力学（MHD）中磁场散度清理的策略：一种是谱投影方法，另一种是广义拉格朗日乘子（GLM）清理方法。必须根据精度（通过清理后的离散散度范数衡量）和计算成本（通过简单的操作计数建模）进行比较。所有量均为无量纲。\n\n此问题的基本依据是来自麦克斯韦方程组在磁流体力学中的无散度约束，即磁场满足 $\\nabla \\cdot \\mathbf{B} = 0$。在实践中，激波主导流动的数值格式可能会违反此约束，导致非零的离散散度，必须对其进行清理。两种广泛使用的策略是：\n\n- 一种投影方法，通过求解一个势 $\\phi$ 的泊松方程，并通过 $\\mathbf{B} \\leftarrow \\mathbf{B} - \\nabla \\phi$ 来投影 $\\mathbf{B}$，从而强制执行该约束。\n- 一种广义拉格朗日乘子（GLM）方法，它引入一个辅助标量场 $\\psi$，并将其与 $\\nabla \\cdot \\mathbf{B}$ 双曲和抛物地耦合，以衰减和对流散度。\n\n您必须在周期性的二维方形域 $[0,1) \\times [0,1)$ 上实现这两种方法，该域使用 $N_x \\times N_y$ 个单元的均匀网格进行离散化，其中 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$。比较应针对一组指定的测试用例执行。\n\n激波主导的清理前状态场构造：\n- 构造一个合成的清理前磁场 $\\mathbf{B}^*$，通过组合一个光滑的螺线管（无散度）分量和一个受控的非螺线管分量来模拟激波主导的情况：\n  - 令 $\\psi(x,y) = A \\sin(2\\pi x)\\sin(2\\pi y)$，其中 $A = 0.1$。\n  - 令 $\\phi_{\\text{shock}}(x,y) = s \\tanh\\left(\\frac{x - 1/2}{w}\\right)$，其中 $s$ 控制激波严重程度， $w$ 控制激波厚度。\n  - 定义\n    $$\n    B_x^*(x,y) = \\frac{\\partial \\psi}{\\partial y}(x,y) + \\frac{\\partial \\phi_{\\text{shock}}}{\\partial x}(x,y), \\quad\n    B_y^*(x,y) = -\\frac{\\partial \\psi}{\\partial x}(x,y),\n    $$\n    使得 $\\nabla \\cdot \\mathbf{B}^* = \\nabla^2 \\phi_{\\text{shock}}$ 非零且集中在激波处。构造 $\\mathbf{B}^*$ 时出现的导数必须解析计算：\n    $$\n    \\frac{\\partial \\psi}{\\partial y} = A \\sin(2\\pi x)\\, 2\\pi \\cos(2\\pi y), \\quad\n    \\frac{\\partial \\psi}{\\partial x} = A\\, 2\\pi \\cos(2\\pi x)\\, \\sin(2\\pi y),\n    $$\n    $$\n    \\frac{\\partial \\phi_{\\text{shock}}}{\\partial x} = \\frac{s}{w} \\operatorname{sech}^2\\!\\left(\\frac{x - 1/2}{w}\\right), \\quad \\frac{\\partial \\phi_{\\text{shock}}}{\\partial y} = 0.\n    $$\n\n离散诊断：\n- 使用带有周期性环绕的二阶中心差分来定义网格场 $\\mathbf{B}$ 的离散散度：\n  $$\n  (\\nabla \\cdot \\mathbf{B})_{i,j} = \\frac{B_{x,i+1,j} - B_{x,i-1,j}}{2\\Delta x} + \\frac{B_{y,i,j+1} - B_{y,i,j-1}}{2\\Delta y}.\n  $$\n- 将离散 $L^2$ 散度范数定义为\n  $$\n  E(\\mathbf{B}) = \\sqrt{\\frac{1}{N_x N_y} \\sum_{i,j} \\left[(\\nabla \\cdot \\mathbf{B})_{i,j}\\right]^2 }.\n  $$\n\n方法1：谱投影（泊松求解）：\n- 通过求解\n  $$\n  \\nabla^2 \\phi = \\nabla \\cdot \\mathbf{B}^*\n  $$\n  在周期性网格上计算标量势 $\\phi$，并对 $\\phi$ 施加零均值条件（即，波数为零的傅里叶模式设置为零）。使用快速傅里叶变换（FFT）以谱方法实现此求解：在傅里叶空间中，对于波数 $k_x = 2\\pi n_x$ 和 $k_y = 2\\pi n_y$，求解\n  $$\n  \\widehat{\\phi}(\\mathbf{k}) = -\\frac{\\widehat{\\nabla \\cdot \\mathbf{B}^*}(\\mathbf{k})}{k_x^2 + k_y^2} \\quad \\text{for} \\quad \\mathbf{k} \\neq \\mathbf{0}, \\quad \\widehat{\\phi}(\\mathbf{0}) = 0,\n  $$\n  并通过乘以 $\\mathrm{i}\\mathbf{k}$ 和逆FFT以谱方法获得 $\\nabla \\phi$。清理后的场为\n  $$\n  \\mathbf{B}^{\\mathrm{proj}} = \\mathbf{B}^* - \\nabla \\phi.\n  $$\n- 投影方法的成本模型：使用FFT操作计数。假设计算投影需要 $n_{\\mathrm{FFT}} = 4$ 次二维FFT。每次二维FFT的成本建模为\n  $$\n  C_{\\mathrm{FFT}} = \\gamma \\, N_x N_y \\, \\log_2(N_x N_y),\n  $$\n  其中 $\\gamma$ 是一个正常数。因此总成本为\n  $$\n  \\text{Cost}_{\\mathrm{proj}} = n_{\\mathrm{FFT}} \\, C_{\\mathrm{FFT}}.\n  $$\n\n方法2：GLM清理（广义拉格朗日乘子）：\n- 初始化 $\\psi = 0$。对于 $m$ 个子步，执行显式更新\n  $$\n  \\psi^{n+1} = \\psi^n - \\Delta t \\, c_h^2 \\, (\\nabla \\cdot \\mathbf{B}^n) - \\Delta t \\, \\frac{c_h^2}{c_p^2} \\, \\psi^n,\n  $$\n  $$\n  \\mathbf{B}^{n+1} = \\mathbf{B}^n - \\Delta t \\, \\nabla \\psi^{n+1},\n  $$\n  其中 $c_h$ 是双曲清理速度，$c_p$ 是抛物线阻尼参数，$\\nabla$ 通过带有周期性环绕的二阶中心差分进行离散化（与上面的散度算子一致）。将子步数设置为\n  $$\n  m = \\lceil c_h \\rceil,\n  $$\n  并选择子步长\n  $$\n  \\Delta t = \\mathrm{CFL} \\cdot \\frac{\\min(\\Delta x,\\Delta y)}{\\max(c_h, 10^{-8})},\n  $$\n  其中 $\\mathrm{CFL} = 0.8$。$m$ 个子步后清理的场记为 $\\mathbf{B}^{\\mathrm{glm}}$。\n- GLM方法的成本模型：计算局部模板操作。假设每个子步的成本为\n  $$\n  C_{\\mathrm{local}} = \\beta \\, N_x N_y\n  $$\n  次操作，因此总成本为\n  $$\n  \\text{Cost}_{\\mathrm{glm}} = m \\, C_{\\mathrm{local}}.\n  $$\n\n比较指标和决策规则：\n- 定义一个绝对精度容差\n  $$\n  \\tau = 10^{-3}.\n  $$\n- 对于每种方法，使用下面指定的 $\\gamma$ 和 $\\beta$ 的上述模型计算清理后的散度范数 $E(\\mathbf{B}^{\\mathrm{proj}})$ 和 $E(\\mathbf{B}^{\\mathrm{glm}})$，以及成本 $\\text{Cost}_{\\mathrm{proj}}$ 和 $\\text{Cost}_{\\mathrm{glm}}$。\n- 根据以下规则确定哪种方法占优：\n  - 如果恰好有一种方法达到 $E \\le \\tau$，则选择该方法。\n  - 如果两种方法都达到 $E \\le \\tau$，则选择成本较低者。\n  - 如果两种方法都未达到 $E \\le \\tau$，则选择 $E$ 较小者；如果 $E$ 在 $10^{-6}$ 的相对容差内相等，则选择成本较低者。\n- 将每个测试用例的选择编码为一个整数：\n  - 如果选择投影方法，则输出 $1$。\n  - 如果选择GLM方法，则输出 $-1$。\n  - 如果打破平局后没有严格的偏好（仅适用于两种方法在相对容差内 $E$ 相等且在成本模型下成本也相等的情况），则输出 $0$。\n\n成本模型常数：\n- 使用 $\\gamma = 5.0$ 和 $\\beta = 20.0$。\n\n测试套件：\n实现程序以精确执行以下五个测试用例，其中每个元组为 $(N_x, N_y, s, w, c_h, c_p)$：\n- 案例 1：$(128, 128, 1.0, 0.02, 1.0, 1.0)$\n- 案例 2：$(128, 128, 3.0, 0.01, 1.0, 1.0)$\n- 案例 3：$(256, 256, 1.0, 0.02, 1.0, 1.0)$\n- 案例 4：$(128, 128, 1.0, 0.02, 5.0, 1.0)$\n- 案例 5：$(64, 64, 0.5, 0.05, 0.5, 1.0)$\n\n要求的最终输出：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的整数列表，用方括号括起来，顺序与测试用例相同，例如，“[$r_1, r_2, r_3, r_4, r_5$]”。不允许有其他输出。",
            "solution": "该问题要求在二维周期性域上实现并比较两种不同的数值方法，用于在磁流体力学（MHD）中强制执行无散度约束 $\\nabla \\cdot \\mathbf{B} = 0$。待比较的方法是一种谱投影方法和一种广义拉格朗日乘子（GLM）清理方案。比较基于清理后的精度（通过离散散度范数衡量）和计算成本（通过简化的操作模型估算）。\n\n首先，我们建立计算域和初始状态。该域是一个周期性方块 $[0,1) \\times [0,1)$，由一个 $N_x \\times N_y$ 单元的均匀网格离散化，网格间距为 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$。单元中心位于 $(x_i, y_j) = ((i+0.5)\\Delta x, (j+0.5)\\Delta y)$，其中 $i \\in \\{0, \\dots, N_x-1\\}$ 和 $j \\in \\{0, \\dots, N_y-1\\}$。\n\n初始的、清理前的磁场，记作 $\\mathbf{B}^*$，被解析地定义为包含螺线管（无散度）部分和非螺线管部分，以模拟来自激波的数值误差。它由矢量势 $\\psi(x,y) = A \\sin(2\\pi x)\\sin(2\\pi y)$ 和标量势 $\\phi_{\\text{shock}}(x,y) = s \\tanh\\left(\\frac{x - 1/2}{w}\\right)$ 构造而成，其中 $A=0.1$。其分量为：\n$$\nB_x^*(x,y) = \\frac{\\partial \\psi}{\\partial y}(x,y) + \\frac{\\partial \\phi_{\\text{shock}}}{\\partial x}(x,y) = 2\\pi A \\sin(2\\pi x) \\cos(2\\pi y) + \\frac{s}{w} \\operatorname{sech}^2\\!\\left(\\frac{x - 1/2}{w}\\right)\n$$\n$$\nB_y^*(x,y) = -\\frac{\\partial \\psi}{\\partial x}(x,y) = -2\\pi A \\cos(2\\pi x) \\sin(2\\pi y)\n$$\n该场的散度解析地为 $\\nabla \\cdot \\mathbf{B}^* = \\nabla^2\\phi_{\\text{shock}}$，这是非零的。\n\n每种清理方法的精度由清理后场的散度的离散 $L^2$ 范数量化，定义为：\n$$\nE(\\mathbf{B}) = \\sqrt{\\frac{1}{N_x N_y} \\sum_{i,j} \\left[(\\nabla \\cdot \\mathbf{B})_{i,j}\\right]^2 }\n$$\n离散散度算子 $(\\nabla \\cdot \\mathbf{B})_{i,j}$ 使用带周期性边界条件的二阶中心差分来近似：\n$$\n(\\nabla \\cdot \\mathbf{B})_{i,j} = \\frac{B_{x,i+1,j} - B_{x,i-1,j}}{2\\Delta x} + \\frac{B_{y,i,j+1} - B_{y,i,j-1}}{2\\Delta y}\n$$\n\n**方法1：谱投影**\n\n投影方法的原理是将初始场 $\\mathbf{B}^*$ 分解为一个无散度部分和一个标量势的梯度，即 $\\mathbf{B}^* = \\mathbf{B}^{\\mathrm{proj}} + \\nabla \\phi$。为了使清理后的场 $\\mathbf{B}^{\\mathrm{proj}}$ 无散度（即 $\\nabla \\cdot \\mathbf{B}^{\\mathrm{proj}} = 0$），势 $\\phi$ 必须满足泊松方程：\n$$\n\\nabla^2 \\phi = \\nabla \\cdot \\mathbf{B}^*\n$$\n在周期性域上，该方程可以在傅里叶空间中高效求解。进行傅里叶变换得到：\n$$\n-(k_x^2 + k_y^2) \\widehat{\\phi}(\\mathbf{k}) = \\widehat{\\nabla \\cdot \\mathbf{B}^*}(\\mathbf{k})\n$$\n其中 $\\mathbf{k}=(k_x, k_y)$ 是波数矢量，其分量对于整数模数 $n_x, n_y$ 为 $k_x = 2\\pi n_x$ 和 $k_y = 2\\pi n_y$。势的傅里叶系数解为：\n$$\n\\widehat{\\phi}(\\mathbf{k}) = -\\frac{\\widehat{\\nabla \\cdot \\mathbf{B}^*}(\\mathbf{k})}{k_x^2 + k_y^2} \\quad \\text{for} \\quad \\mathbf{k} \\neq \\mathbf{0}\n$$\n对于 $\\mathbf{k} = \\mathbf{0}$，分母为零。通过施加零均值条件 $\\widehat{\\phi}(\\mathbf{0}) = 0$ 来获得 $\\phi$ 的唯一解。\n\n实现对所有导数一致地使用谱方法。首先，计算 $B_x^*$ 和 $B_y^*$ 的傅里叶变换。然后，在傅里叶空间中通过 $\\widehat{\\nabla \\cdot \\mathbf{B}^*} = i k_x \\widehat{B_x^*} + i k_y \\widehat{B_y^*}$ 计算散度。求解出 $\\widehat{\\phi}$ 后，梯度 $\\nabla \\phi$ 也以谱方法找到：$\\widehat{\\nabla\\phi} = i\\mathbf{k}\\widehat{\\phi}$。然后通过傅里叶逆变换恢复 $\\nabla\\phi$ 的分量。清理后的场为 $\\mathbf{B}^{\\mathrm{proj}} = \\mathbf{B}^* - \\nabla\\phi$。整个过程需要对 $\\mathbf{B}^*$ 进行两次前向快速傅里叶变换（FFT），对 $\\nabla\\phi$ 进行两次逆向FFT，这证实了给定的参数 $n_{\\mathrm{FFT}} = 4$。计算成本建模为：\n$$\n\\text{Cost}_{\\mathrm{proj}} = n_{\\mathrm{FFT}} \\, \\gamma \\, N_x N_y \\, \\log_2(N_x N_y)\n$$\n其中 $\\gamma = 5.0$。\n\n**方法2：广义拉格朗日乘子（GLM）**\n\nGLM方法引入了一个辅助标量场 $\\psi$，它与磁场耦合。该方程组被设计为以速度 $c_h$ 将散度误差输运出域外，并同时在与参数 $c_p$ 相关的时间尺度上对其进行阻尼。单次清理扫描的迭代更新方案由下式给出：\n$$\n\\psi^{n+1} = \\psi^n - \\Delta t \\, c_h^2 \\, (\\nabla \\cdot \\mathbf{B}^n) - \\Delta t \\, \\frac{c_h^2}{c_p^2} \\, \\psi^n\n$$\n$$\n\\mathbf{B}^{n+1} = \\mathbf{B}^n - \\Delta t \\, \\nabla \\psi^{n+1}\n$$\n从 $\\psi^0 = 0$ 和 $\\mathbf{B}^0 = \\mathbf{B}^*$ 开始，该方案总共应用 $m = \\lceil c_h \\rceil$ 个子步。时间步长 $\\Delta t$ 由 Courant-Friedrichs-Lewy (CFL) 条件确定：\n$$\n\\Delta t = \\mathrm{CFL} \\cdot \\frac{\\min(\\Delta x,\\Delta y)}{\\max(c_h, 10^{-8})}\n$$\n其中 $\\mathrm{CFL} = 0.8$。离散梯度 $\\nabla$ 和散度 $\\nabla \\cdot$ 算子使用二阶中心差分实现，与诊断计算一致。基于局部模板操作的成本建模为：\n$$\n\\text{Cost}_{\\mathrm{glm}} = m \\, \\beta \\, N_x N_y\n$$\n其中 $\\beta = 20.0$。\n\n**比较与决策**\n\n对于每个测试用例，执行两种方法以获得清理后的场 $\\mathbf{B}^{\\mathrm{proj}}$ 和 $\\mathbf{B}^{\\mathrm{glm}}$、它们各自的散度范数 $E(\\mathbf{B}^{\\mathrm{proj}})$ 和 $E(\\mathbf{B}^{\\mathrm{glm}})$，以及它们的成本 $\\text{Cost}_{\\mathrm{proj}}$ 和 $\\text{Cost}_{\\mathrm{glm}}$。基于一个涉及精度容差 $\\tau = 10^{-3}$ 的预定义规则集做出决策：\n1.  如果一种方法是精确的（$E \\le \\tau$）而另一种不是，则选择精确的那种。\n2.  如果两种方法都是精确的，则选择成本较低的那种。\n3.  如果两种方法都不精确，则选择散度范数 $E$ 较低的那种。如果 $E$ 相等（在 $10^{-6}$ 的相对容差内），则通过选择成本较低的方法来打破平局。\n\n最终选择被编码为：投影方法为 $1$，GLM方法为 $-1$，如果在精度（在容差内）和成本上完全持平，则为 $0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares spectral projection and GLM divergence cleaning methods for MHD.\n    \"\"\"\n\n    # --- Problem Constants ---\n    A = 0.1\n    GAMMA = 5.0\n    BETA = 20.0\n    CFL = 0.8\n    TAU = 1e-3\n    REL_TOL_E = 1e-6\n\n    # --- Test Suite ---\n    test_cases = [\n        # (Nx, Ny, s, w, ch, cp)\n        (128, 128, 1.0, 0.02, 1.0, 1.0),\n        (128, 128, 3.0, 0.01, 1.0, 1.0),\n        (256, 256, 1.0, 0.02, 1.0, 1.0),\n        (128, 128, 1.0, 0.02, 5.0, 1.0),\n        (64, 64, 0.5, 0.05, 0.5, 1.0),\n    ]\n\n    def calculate_divergence(Bx, By, dx, dy):\n        \"\"\"Computes discrete divergence using 2nd-order central differences.\"\"\"\n        # Note: axis=1 for x-derivatives, axis=0 for y-derivatives assuming (Ny, Nx) array shape\n        d_Bx_dx = (np.roll(Bx, -1, axis=1) - np.roll(Bx, 1, axis=1)) / (2 * dx)\n        d_By_dy = (np.roll(By, -1, axis=0) - np.roll(By, 1, axis=0)) / (2 * dy)\n        return d_Bx_dx + d_By_dy\n\n    def calculate_gradient(phi, dx, dy):\n        \"\"\"Computes discrete gradient using 2nd-order central differences.\"\"\"\n        d_phi_dx = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2 * dx)\n        d_phi_dy = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2 * dy)\n        return d_phi_dx, d_phi_dy\n\n    def run_projection_method(B_star_x, B_star_y, Nx, Ny, dx, dy):\n        \"\"\"Implements the spectral projection method.\"\"\"\n        # Wavenumbers\n        kx = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n        ky = 2 * np.pi * np.fft.fftfreq(Ny, d=dy)\n        kx_grid, ky_grid = np.meshgrid(kx, ky)\n        k_squared = kx_grid**2 + ky_grid**2\n\n        # FFT of initial field\n        B_hat_x = np.fft.fft2(B_star_x)\n        B_hat_y = np.fft.fft2(B_star_y)\n\n        # Spectral divergence\n        div_B_hat = 1j * kx_grid * B_hat_x + 1j * ky_grid * B_hat_y\n\n        # Solve for phi in Fourier space\n        phi_hat = np.zeros_like(div_B_hat)\n        non_zero_k = k_squared != 0\n        phi_hat[non_zero_k] = -div_B_hat[non_zero_k] / k_squared[non_zero_k]\n\n        # Spectral gradient of phi\n        grad_phi_x_hat = 1j * kx_grid * phi_hat\n        grad_phi_y_hat = 1j * ky_grid * phi_hat\n\n        # Inverse FFT to get gradient in real space\n        grad_phi_x = np.fft.ifft2(grad_phi_x_hat).real\n        grad_phi_y = np.fft.ifft2(grad_phi_y_hat).real\n\n        # Cleaned field\n        B_proj_x = B_star_x - grad_phi_x\n        B_proj_y = B_star_y - grad_phi_y\n\n        # Diagnostics\n        div_proj = calculate_divergence(B_proj_x, B_proj_y, dx, dy)\n        E_proj = np.sqrt(np.mean(div_proj**2))\n        cost_proj = 4 * GAMMA * Nx * Ny * np.log2(Nx * Ny)\n        \n        return E_proj, cost_proj\n\n    def run_glm_method(B_star_x, B_star_y, Nx, Ny, dx, dy, ch, cp):\n        \"\"\"Implements the GLM cleaning method.\"\"\"\n        # Parameters\n        m = int(np.ceil(ch))\n        dt = CFL * min(dx, dy) / max(ch, 1e-8)\n\n        # Initialization\n        psi = np.zeros((Ny, Nx))\n        Bx = B_star_x.copy()\n        By = B_star_y.copy()\n\n        # Iterative cleaning\n        for _ in range(m):\n            div_B = calculate_divergence(Bx, By, dx, dy)\n            psi_new = psi - dt * ch**2 * div_B - dt * (ch**2 / cp**2) * psi\n            grad_psi_x, grad_psi_y = calculate_gradient(psi_new, dx, dy)\n            Bx_new = Bx - dt * grad_psi_x\n            By_new = By - dt * grad_psi_y\n            \n            psi, Bx, By = psi_new, Bx_new, By_new\n        \n        # Diagnostics\n        B_glm_x, B_glm_y = Bx, By\n        div_glm = calculate_divergence(B_glm_x, B_glm_y, dx, dy)\n        E_glm = np.sqrt(np.mean(div_glm**2))\n        cost_glm = m * BETA * Nx * Ny\n\n        return E_glm, cost_glm\n        \n    results = []\n    for case in test_cases:\n        Nx, Ny, s, w, ch, cp = case\n        \n        # Grid setup\n        dx = 1.0 / Nx\n        dy = 1.0 / Ny\n        x = (np.arange(Nx) + 0.5) * dx\n        y = (np.arange(Ny) + 0.5) * dy\n        xx, yy = np.meshgrid(x, y) # xx shape (Ny,Nx), yy shape (Ny,Nx)\n\n        # Initial field construction\n        B_star_x = (A * 2 * np.pi * np.sin(2 * np.pi * xx) * np.cos(2 * np.pi * yy) + \n                    (s / w) / (np.cosh((xx - 0.5) / w)**2))\n        B_star_y = -A * 2 * np.pi * np.cos(2 * np.pi * xx) * np.sin(2 * np.pi * yy)\n        \n        # Run methods\n        E_proj, cost_proj = run_projection_method(B_star_x, B_star_y, Nx, Ny, dx, dy)\n        E_glm, cost_glm = run_glm_method(B_star_x, B_star_y, Nx, Ny, dx, dy, ch, cp)\n\n        # Comparison logic\n        proj_ok = E_proj = TAU\n        glm_ok = E_glm = TAU\n        \n        result = 0\n        if proj_ok and not glm_ok:\n            result = 1\n        elif not proj_ok and glm_ok:\n            result = -1\n        elif proj_ok and glm_ok:\n            if cost_proj  cost_glm:\n                result = 1\n            elif cost_glm  cost_proj:\n                result = -1\n            else:\n                result = 0\n        else: # Neither is OK\n            if np.isclose(E_proj, E_glm, rtol=REL_TOL_E):\n                if cost_proj  cost_glm:\n                    result = 1\n                elif cost_glm  cost_proj:\n                    result = -1\n                else: \n                    result = 0\n            elif E_proj  E_glm:\n                result = 1\n            else:\n                result = -1\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的天体物理模拟常常使用拉伸的、各向异性的网格来高效地解析特定方向上的结构。本高级练习在前一个练习的基础上，深入探讨了如何优化广义拉格朗日乘子（GLM）方法以适应这种更复杂的计算环境。您将推导散度误差的演化方程，并设计一个“网格感知”的各向异性阻尼项 ，旨在根据局部磁场方向和网格几何形状调整清理效率，从而在挑战性的模拟场景中实现更优越的散度控制。",
            "id": "3506840",
            "problem": "考虑用于磁流体动力学（MHD）的广义拉格朗日乘子（GLM）散度清理，该方法通过引入一个辅助标量场来增强感应方程，以输运和抑制散度误差。假设在二维空间中采用具有恒定系数的双曲-抛物清理形式，由以下线性化方程组给出\n$$\n\\frac{\\partial \\mathbf{B}}{\\partial t} + \\nabla \\times \\mathbf{E} + \\nabla \\psi = \\mathbf{0}, \\quad\n\\frac{\\partial \\psi}{\\partial t} + c_h^2 \\nabla \\cdot \\mathbf{B} = - c_p \\, \\psi,\n$$\n其中 $\\mathbf{B}$ 是磁场，$\\psi$ 是清理场，$c_h$ 是清理波速，$c_p$ 是阻尼率。所有量均为无量綱。角度必须以弧度表示。\n\n仅从上述方程出发，并使用在均匀但各向异性的网格（间距为 $\\Delta x$ 和 $\\Delta y$）上对二阶中心差分的标准离散傅里叶分析，完成以下任务：\n\n1) 推导离散散度 $D = \\nabla \\cdot \\mathbf{B}$ 的傅里叶模式振幅的演化方程，其形式为针对单个模式（波矢为 $\\mathbf{k} = (k_x, k_y)$）的阻尼线性振荡器，其中半离散的离散拉普拉斯算子通过有效波数进入：\n$$\nk_{x,\\mathrm{eff}} = \\frac{2}{\\Delta x} \\sin\\!\\left(\\frac{k_x \\Delta x}{2}\\right), \\quad\nk_{y,\\mathrm{eff}} = \\frac{2}{\\Delta y} \\sin\\!\\left(\\frac{k_y \\Delta y}{2}\\right).\n$$\n证明 $D$ 的模式振幅 $A(t)$ 在常系数下满足以下形式的常微分方程\n$$\nA''(t) + c_p \\, A'(t) + \\omega_0^2 \\, A(t) = 0,\n$$\n其中 $\\omega_0^2 = c_h^2 \\left(k_{x,\\mathrm{eff}}^2 + k_{y,\\mathrm{eff}}^2\\right)$，并采用初始条件 $A(0) = 1$ 和 $A'(0) = 0$。\n\n2) 提出一个依赖于局部磁场方向和网格各向异性的各向异性阻尼模型。令 $\\theta$ 为磁场与 $x$ 轴之间的夹角，令 $r = \\Delta x / \\Delta y$ 为网格各向异性比。将各向异性阻尼率 $c_p(\\theta)$ 定义为\n$$\nc_p(\\theta) = c_{p0} \\, \\frac{\\sqrt{(\\Delta x \\cos\\theta)^2 + (\\Delta y \\sin\\theta)^2}}{\\sqrt{\\Delta x \\, \\Delta y}} = c_{p0} \\sqrt{ r \\cos^2\\theta + \\frac{1}{r} \\sin^2\\theta },\n$$\n其中 $c_{p0}$ 是一个基准各向同性阻尼率。基于拉伸网格引起的方向度量以及沿有效间距较大方向加强阻尼的需求，来证明此选择的合理性。\n\n3) 对于与磁场对齐的单个傅里叶模式（大小为 $k_0$，即 $k_x = k_0 \\cos\\theta$ 和 $k_y = k_0 \\sin\\theta$），使用第1部分中的常微分方程，计算在 $t = T$ 时刻的精确闭式振幅 $A(t)$，分别针对各向同性情况（$c_p = c_{p0}$）和各向异性情况（$c_p = c_p(\\theta)$）。\n\n4) 将散度控制的性能指标定义为比率\n$$\nR = \\frac{A_{\\mathrm{aniso}}(T)}{A_{\\mathrm{iso}}(T)},\n$$\n其中 $A_{\\mathrm{aniso}}(T)$ 和 $A_{\\mathrm{iso}}(T)$ 分别是各向异性和各向同性阻尼选择下在时间 $T$ 时的振幅。$R  1$ 的值表示在所选参数下，各向异性模型改善了控制效果。\n\n你的任务是编写一个完整的程序，对于下面套件中的每个测试用例，使用在初始条件 $A(0) = 1$ 和 $A'(0) = 0$ 下的 $A(t)$ 的精确闭式解来计算 $R$，并适当考虑由 $c_p^2 - 4 \\omega_0^2$ 的符号决定的阻尼振荡器的三种状态（欠阻尼、临界阻尼、过阻尼）。\n\n使用以下测试套件，其中每个测试用例是一个元组 $(\\Delta x, \\Delta y, \\theta, k_0, c_h, c_{p0}, T)$：\n\n- 案例1（理想情况，各向同性网格，因此 $R = 1$）：$(\\Delta x, \\Delta y, \\theta, k_0, c_h, c_{p0}, T) = (1.0, 1.0, 0.7, 1.2, 1.0, 1.0, 1.0)$。\n- 案例2（沿 $x$ 拉伸，场与拉伸方向对齐）：$(4.0, 1.0, 0.0, 1.0, 1.0, 0.5, 2.0)$。\n- 案例3（沿 $x$ 拉伸，场与拉伸方向垂直）：$(4.0, 1.0, \\pi/2, 1.0, 1.0, 0.5, 2.0)$。\n- 案例4（强拉伸，小角度）：$(10.0, 1.0, 0.1, 2.2, 1.0, 0.7, 3.0)$。\n- 案例5（零波数边界情况，平均模式不衰减）：$(2.0, 1.0, 0.3, 0.0, 1.0, 0.9, 1.5)$。\n- 案例6（各向同性选择接近临界阻尼）：$(1.0, 0.5, 0.0, 2.6, 1.0, 3.8, 0.7)$。\n\n你的程序必须：\n\n- 实现初始条件为 $A(0) = 1$ 和 $A'(0) = 0$ 时，在各种状态下 $A(T)$ 的精确闭式解。\n- 使用如上指定的离散有效波数 $k_{x,\\mathrm{eff}}$ 和 $k_{y,\\mathrm{eff}}$。\n- 计算并输出一个单行，其中包含所有测试用例的 $R$ 值列表，按给定顺序排列，四舍五入到六位小数，并用方括号括起来的逗号分隔列表（例如，$[0.123456,0.234567,\\dots]$）。\n\n所有量均为无量纲，角度以弧度为单位。不应读取任何外部输入；测试套件如上所述是固定的，并嵌入到你的程序中。输出必须严格为所描述的单行文本，不得包含任何额外文字。",
            "solution": "该问题是有效的。这是一个计算天体物理学中定义良好的问题，其基础是偏微分方程数值方法，特别是磁流体动力学（MHD）的标准数学框架。所有必要的方程、参数和初始条件都已提供，并且没有内部矛盾、科学不准确性或模糊之处。\n\n在此，我们推导所要求的结果并构建计算算法。\n\n### 第1部分：散度的阻尼振荡器方程推导\n\n给定具有常系数的线性化二维广义拉格朗日乘子（GLM）方程：\n$$ \\frac{\\partial \\mathbf{B}}{\\partial t} + \\nabla \\times \\mathbf{E} + \\nabla \\psi = \\mathbf{0} \\quad (1) $$\n$$ \\frac{\\partial \\psi}{\\partial t} + c_h^2 \\nabla \\cdot \\mathbf{B} = - c_p \\, \\psi \\quad (2) $$\n\n我们的目标是推导磁场散度 $D = \\nabla \\cdot \\mathbf{B}$ 的演化方程。我们首先对（1）式取散度：\n$$ \\nabla \\cdot \\left( \\frac{\\partial \\mathbf{B}}{\\partial t} \\right) + \\nabla \\cdot (\\nabla \\times \\mathbf{E}) + \\nabla \\cdot (\\nabla \\psi) = 0 $$\n假设有足够的光滑性，我们可以交换空间和时间导数，$\\nabla \\cdot (\\frac{\\partial \\mathbf{B}}{\\partial t}) = \\frac{\\partial}{\\partial t}(\\nabla \\cdot \\mathbf{B})$。旋度的散度恒为零，$\\nabla \\cdot (\\nabla \\times \\mathbf{E}) \\equiv 0$。梯度的散度是拉普拉斯算子，$\\nabla \\cdot (\\nabla \\psi) = \\nabla^2 \\psi$。因此方程简化为：\n$$ \\frac{\\partial D}{\\partial t} + \\nabla^2 \\psi = 0 \\quad (3) $$\n该方程表明，清理场 $\\psi$ 的非零散度是磁场散度变化的源头。\n\n为了得到 $D$ 的二阶方程，我们对（3）式关于时间求导：\n$$ \\frac{\\partial^2 D}{\\partial t^2} + \\frac{\\partial}{\\partial t}(\\nabla^2 \\psi) = 0 $$\n再次假设光滑性，我们交换导数顺序：\n$$ \\frac{\\partial^2 D}{\\partial t^2} + \\nabla^2 \\left(\\frac{\\partial \\psi}{\\partial t}\\right) = 0 \\quad (4) $$\n现在，我们将（2）式中 $\\frac{\\partial \\psi}{\\partial t}$ 的表达式代入（4）式：\n$$ \\frac{\\partial^2 D}{\\partial t^2} + \\nabla^2 (-c_h^2 \\nabla \\cdot \\mathbf{B} - c_p \\psi) = 0 $$\n代入 $D = \\nabla \\cdot \\mathbf{B}$ 并分配拉普拉斯算子（因为 $c_h$ 和 $c_p$ 是常数）：\n$$ \\frac{\\partial^2 D}{\\partial t^2} - c_h^2 \\nabla^2 D - c_p \\nabla^2 \\psi = 0 \\quad (5) $$\n最后，我们使用（3）式将 $\\nabla^2 \\psi$ 替换为 $-\\frac{\\partial D}{\\partial t}$。将此代入（5）式得到：\n$$ \\frac{\\partial^2 D}{\\partial t^2} - c_h^2 \\nabla^2 D - c_p \\left(-\\frac{\\partial D}{\\partial t}\\right) = 0 $$\n整理后得到散度 $D$ 的阻尼波方程：\n$$ \\frac{\\partial^2 D}{\\partial t^2} + c_p \\frac{\\partial D}{\\partial t} - c_h^2 \\nabla^2 D = 0 $$\n\n为了找到单个傅里叶模式的方程，我们考虑形式为 $D(\\mathbf{x}, t) = A(t) e^{i \\mathbf{k} \\cdot \\mathbf{x}}$ 的解，其中 $\\mathbf{k} = (k_x, k_y)$ 是波矢，$A(t)$ 是模式的时间相关振幅。对于连续系统，拉普拉斯算子 $\\nabla^2$ 作用于此模式对应于乘以 $-k^2 = -(k_x^2 + k_y^2)$。\n\n对于在间距为 $(\\Delta x, \\Delta y)$ 的网格上使用二阶中心差分的半离散系统，拉普拉斯算子对模式 $e^{i(k_x x + k_y y)}$ 的作用被修正。二阶偏导数 $\\frac{\\partial^2}{\\partial x^2}$ 由中心差分算子 $\\delta_x^2 f(x) = \\frac{f(x+\\Delta x) - 2f(x) + f(x-\\Delta x)}{(\\Delta x)^2}$ 近似。其对 $e^{i k_x x}$ 的作用产生一个乘法因子：\n$$ \\frac{e^{i k_x(x+\\Delta x)} - 2e^{i k_x x} + e^{i k_x(x-\\Delta x)}}{(\\Delta x)^2} = \\frac{e^{i k_x x}(e^{i k_x \\Delta x} - 2 + e^{-i k_x \\Delta x})}{(\\Delta x)^2} = \\frac{e^{i k_x x}(2\\cos(k_x \\Delta x) - 2)}{(\\Delta x)^2} $$\n使用半角恒等式 $1 - \\cos(\\alpha) = 2\\sin^2(\\alpha/2)$，上式变为：\n$$ \\frac{e^{i k_x x}(-4\\sin^2(k_x \\Delta x/2))}{(\\Delta x)^2} = - \\left( \\frac{2}{\\Delta x} \\sin\\left(\\frac{k_x \\Delta x}{2}\\right) \\right)^2 e^{i k_x x} = -k_{x,\\mathrm{eff}}^2 e^{i k_x x} $$\n因此，离散拉普拉斯算子 $\\nabla_d^2 = \\delta_x^2 + \\delta_y^2$ 作用于模式 $A(t) e^{i \\mathbf{k} \\cdot \\mathbf{x}}$ 的效果是将其乘以 $-(k_{x,\\mathrm{eff}}^2 + k_{y,\\mathrm{eff}}^2)$。\n\n将此代入 $D$ 的波动方程，得到振幅 $A(t)$ 的常微分方程：\n$$ A''(t) + c_p A'(t) + c_h^2 (k_{x,\\mathrm{eff}}^2 + k_{y,\\mathrm{eff}}^2) A(t) = 0 $$\n这正是所要求的形式 $A''(t) + c_p A'(t) + \\omega_0^2 A(t) = 0$，其中固有频率的平方由 $\\omega_0^2 = c_h^2 (k_{x,\\mathrm{eff}}^2 + k_{y,\\mathrm{eff}}^2)$ 给出。\n\n### 第2部分：各向异性阻尼模型的合理性证明\n\n提出的各向异性阻尼率为：\n$$ c_p(\\theta) = c_{p0} \\sqrt{ r \\cos^2\\theta + \\frac{1}{r} \\sin^2\\theta } $$\n其中 $r = \\Delta x / \\Delta y$ 是网格各向异性比，$\\theta$ 是磁场相对于 $x$ 轴的角度。\n\n此模型的基本原理是使阻尼强度适应沿磁场方向（以及因此，散度波传播的方向）的局部网格分辨率。平方根下的项 $M(\\theta, r) = r \\cos^2\\theta + \\frac{1}{r} \\sin^2\\theta$ 可以改写为：\n$$ M(\\theta, r) = \\frac{\\Delta x}{\\Delta y} \\cos^2\\theta + \\frac{\\Delta y}{\\Delta x} \\sin^2\\theta = \\frac{(\\Delta x \\cos\\theta)^2 + (\\Delta y \\sin\\theta)^2}{\\Delta x \\Delta y} $$\n分子表示一个指向 $\\theta$ 方向、并经单元格维度缩放的向量的长度平方。此量可作为该方向上有效网格间距的度量。阻尼率 $c_p(\\theta)$ 与此有效间距度量的平方根成正比。\n\n考虑在坐标轴上的行为：\n- 沿 $x$ 轴（$\\theta = 0$）：$c_p(0) = c_{p0} \\sqrt{r} = c_{p0} \\sqrt{\\Delta x / \\Delta y}$。\n- 沿 $y$ 轴（$\\theta = \\pi/2$）：$c_p(\\pi/2) = c_{p0} \\sqrt{1/r} = c_{p0} \\sqrt{\\Delta y / \\Delta x}$。\n如果网格在 $x$ 方向上被拉伸（$\\Delta x > \\Delta y$，因此 $r > 1$），则 $c_p(0) > c_{p0}$ 且 $c_p(\\pi/2)  c_{p0}$。这意味着在分辨率较粗（$\\Delta x$）的方向上阻尼增强，而在分辨率较细（$\\Delta y$）的方向上阻尼减弱。这种启发式方法是合理的：数值误差在单元格尺寸较大的方向上通常更显著或传播方式不同，因此在这些方向上增加阻尼可以提高散度清理方案的稳定性和准确性。\n\n对于各向同性网格（$r=1$），$c_p(\\theta) = c_{p0} \\sqrt{\\cos^2\\theta+\\sin^2\\theta} = c_{p0}$，恢复到所要求的各向同性情况。\n\n### 第3部分：振幅 $A(t)$ 的闭式解\n\n我们必须求解常微分方程 $A''(t) + c_p A'(t) + \\omega_0^2 A(t) = 0$，并满足初始条件 $A(0)=1$ 和 $A'(0)=0$。特征方程为 $\\lambda^2 + c_p\\lambda + \\omega_0^2 = 0$，其根为 $\\lambda_{1,2} = \\frac{-c_p \\pm \\sqrt{c_p^2 - 4\\omega_0^2}}{2}$。解的形式取决于判别式 $\\Delta = c_p^2 - 4\\omega_0^2$ 的符号。\n\n1.  **过阻尼情况（$\\Delta > 0$）：**\n    通解为 $A(t) = e^{-c_p t/2} (C_1 e^{\\Omega_d t} + C_2 e^{-\\Omega_d t})$，其中 $\\Omega_d = \\frac{\\sqrt{\\Delta}}{2}$。应用初始条件 $A(0)=1$ 和 $A'(0)=0$ 得到系数，得出特定解：\n    $$ A(t) = e^{-c_p t/2} \\left[ \\cosh(\\Omega_d t) + \\frac{c_p}{2\\Omega_d} \\sinh(\\Omega_d t) \\right] $$\n\n2.  **临界阻尼情况（$\\Delta = 0$）：**\n    特征方程有一个重根 $\\lambda = -c_p/2$。通解为 $A(t) = (C_1 + C_2 t)e^{-c_p t/2}$。应用初始条件得到：\n    $$ A(t) = \\left(1 + \\frac{c_p}{2} t\\right) e^{-c_p t/2} $$\n\n3.  **欠阻尼情况（$\\Delta  0$）：**\n    根是复共轭的，$\\lambda_{1,2} = -c_p/2 \\pm i\\omega_d$，其中 $\\omega_d = \\frac{\\sqrt{-\\Delta}}{2}$。通解为 $A(t) = e^{-c_p t/2} (C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t))$。应用初始条件得到：\n    $$ A(t) = e^{-c_p t/2} \\left[ \\cos(\\omega_d t) + \\frac{c_p}{2\\omega_d} \\sin(\\omega_d t) \\right] $$\n\n一个重要的边界情况是当 $k_0 = 0$ 时，这意味着 $k_{x,\\mathrm{eff}} = k_{y,\\mathrm{eff}} = 0$，因此 $\\omega_0^2 = 0$。常微分方程变为 $A''(t) + c_p A'(t) = 0$。给定 $A'(0)=0$，解为 $A'(t)=0$ 对于所有 $t$，这意味着 $A(t)$ 是常数。又因 $A(0)=1$，我们有 $A(t)=1$。我们推导的公式能正确处理这种情况：如果 $\\omega_0^2=0$，则 $\\Delta = c_p^2 \\ge 0$。对于 $c_p>0$，这是过阻尼情况，其中 $\\Omega_d = c_p/2$，公式简化为 $A(t)=1$。对于 $c_p=0$，这是临界阻尼情况，也得到 $A(t)=1$。\n\n### 第4部分：算法实现\n\n任务简化为实现这些闭式解并计算每个测试用例的比率 $R = A_{\\mathrm{aniso}}(T) / A_{\\mathrm{iso}}(T)$。\n\n算法如下：\n对于每个测试用例元组 $(\\Delta x, \\Delta y, \\theta, k_0, c_h, c_{p0}, T)$：\n1.  计算辅助参数：网格比 $r = \\Delta x / \\Delta y$，以及波矢分量 $k_x = k_0 \\cos\\theta$ 和 $k_y = k_0 \\sin\\theta$。\n2.  计算有效波数：\n    $$ k_{x,\\mathrm{eff}} = \\frac{2}{\\Delta x} \\sin\\left(\\frac{k_x \\Delta x}{2}\\right), \\quad k_{y,\\mathrm{eff}} = \\frac{2}{\\Delta y} \\sin\\left(\\frac{k_y \\Delta y}{2}\\right) $$\n3.  计算两种情况下共有的固有频率平方：$\\omega_0^2 = c_h^2(k_{x,\\mathrm{eff}}^2 + k_{y,\\mathrm{eff}}^2)$。\n4.  定义一个函数 `compute_amplitude(T, c_p, omega_0_sq)`，它接受时间 $T$、阻尼率 $c_p$ 和频率平方 $\\omega_0^2$，并返回 $A(T)$。此函数将：\n    a. 计算判别式 $\\Delta = c_p^2 - 4\\omega_0^2$。\n    b. 使用一个小的容差来检查 $\\Delta$ 是正、负还是零。\n    c. 应用适当的公式（过阻尼、临界阻尼或欠阻尼）来计算 $A(T)$。\n5.  **各向同性情况**：\n    a. 设置 $c_p = c_{p0}$。\n    b. 调用 `compute_amplitude` 得到 $A_{\\mathrm{iso}}(T)$。\n6.  **各向异性情况**：\n    a. 计算 $c_p(\\theta) = c_{p0} \\sqrt{r \\cos^2\\theta + (1/r) \\sin^2\\theta}$。\n    b. 调用 `compute_amplitude` 得到 $A_{\\mathrm{aniso}}(T)$。\n7.  计算性能比 $R = A_{\\mathrm{aniso}}(T) / A_{\\mathrm{iso}}(T)$。如果 $A_{\\mathrm{iso}}(T)$ 恰好为零，则该比率由标准浮点除法规则处理。\n8.  存储 $R$ 的四舍五入值。\n处理完所有案例后，按指定格式打印结果。\n\n该过程构成了所提供 Python 程序的基础。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the divergence control performance metric R for a set of test cases\n    based on the GLM-MHD divergence cleaning equations.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (dx, dy, theta, k0, ch, cp0, T)\n    test_cases = [\n        (1.0, 1.0, 0.7, 1.2, 1.0, 1.0, 1.0),\n        (4.0, 1.0, 0.0, 1.0, 1.0, 0.5, 2.0),\n        (4.0, 1.0, np.pi/2, 1.0, 1.0, 0.5, 2.0),\n        (10.0, 1.0, 0.1, 2.2, 1.0, 0.7, 3.0),\n        (2.0, 1.0, 0.3, 0.0, 1.0, 0.9, 1.5),\n        (1.0, 0.5, 0.0, 2.6, 1.0, 3.8, 0.7),\n    ]\n\n    results = []\n    \n    # A small tolerance for floating point comparisons to handle the\n    # critically damped case robustly.\n    TOLERANCE = 1e-12\n\n    def calculate_A(T, c_p, omega_0_sq):\n        \"\"\"\n        Calculates the amplitude A(T) of the divergence mode for a given time T,\n        damping coefficient c_p, and natural frequency squared omega_0_sq.\n        \n        The function handles the three regimes of a damped linear oscillator:\n        underdamped, critically damped, and overdamped.\n        \n        Args:\n            T (float): The time at which to evaluate the amplitude.\n            c_p (float): The damping coefficient.\n            omega_0_sq (float): The square of the natural frequency.\n            \n        Returns:\n            float: The amplitude A at time T.\n        \"\"\"\n        # If omega_0_sq is basically zero (k=0 mode), the amplitude does not decay.\n        if abs(omega_0_sq)  TOLERANCE:\n            return 1.0\n            \n        discriminant = c_p**2 - 4 * omega_0_sq\n\n        if discriminant > TOLERANCE:  # Overdamped case\n            Omega_d = 0.5 * np.sqrt(discriminant)\n            term1 = np.cosh(Omega_d * T)\n            term2 = (0.5 * c_p / Omega_d) * np.sinh(Omega_d * T)\n            amplitude = np.exp(-0.5 * c_p * T) * (term1 + term2)\n        elif discriminant  -TOLERANCE:  # Underdamped case\n            omega_d = 0.5 * np.sqrt(-discriminant)\n            term1 = np.cos(omega_d * T)\n            term2 = (0.5 * c_p / omega_d) * np.sin(omega_d * T)\n            amplitude = np.exp(-0.5 * c_p * T) * (term1 + term2)\n        else:  # Critically damped case\n            amplitude = (1 + 0.5 * c_p * T) * np.exp(-0.5 * c_p * T)\n            \n        return amplitude\n\n    for case in test_cases:\n        dx, dy, theta, k0, ch, cp0, T = case\n\n        # Calculate grid ratio and wavevector components\n        r = dx / dy\n        kx = k0 * np.cos(theta)\n        ky = k0 * np.sin(theta)\n\n        # Calculate effective wavenumbers\n        if k0 == 0.0:\n            k_x_eff = 0.0\n            k_y_eff = 0.0\n        else:\n            k_x_eff = (2.0 / dx) * np.sin(kx * dx / 2.0)\n            k_y_eff = (2.0 / dy) * np.sin(ky * dy / 2.0)\n        \n        # Calculate natural frequency squared\n        omega_0_sq = ch**2 * (k_x_eff**2 + k_y_eff**2)\n        \n        # --- Isotropic case ---\n        c_p_iso = cp0\n        A_iso = calculate_A(T, c_p_iso, omega_0_sq)\n\n        # --- Anisotropic case ---\n        c_p_aniso = cp0 * np.sqrt(r * np.cos(theta)**2 + (1.0/r) * np.sin(theta)**2)\n        A_aniso = calculate_A(T, c_p_aniso, omega_0_sq)\n        \n        # --- Performance Metric R ---\n        if abs(A_iso)  TOLERANCE:\n            if abs(A_aniso)  TOLERANCE:\n                R = 1.0\n            else:\n                R = np.inf\n        else:\n            R = A_aniso / A_iso\n        \n        results.append(R)\n\n    # Format output as specified, rounding to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}