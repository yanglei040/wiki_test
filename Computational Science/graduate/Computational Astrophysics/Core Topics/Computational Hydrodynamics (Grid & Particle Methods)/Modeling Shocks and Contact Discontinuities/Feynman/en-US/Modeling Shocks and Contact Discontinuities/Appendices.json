{
    "hands_on_practices": [
        {
            "introduction": "The first step in developing reliable numerical simulations is establishing a rigorous framework for evaluating their accuracy. For solutions with shocks and contact discontinuities, traditional error norms like the $L_1$ norm can be misleading, as they conflate errors in position, amplitude, and width. This practice  introduces specialized, physically-motivated error metrics to separately quantify shock position error and contact discontinuity width, providing a much clearer picture of a scheme's performance. By implementing simple first-order solvers for the Burgers' and linear advection equations and conducting a grid refinement study, you will learn the essential techniques for measuring convergence and diagnosing the behavior of shock-capturing schemes.",
            "id": "3521202",
            "problem": "You are to implement and analyze one-dimensional conservation-law models that contain a propagating shock and a propagating contact discontinuity. The goal is to define interface-aware error norms that are appropriate for discontinuities and to design a grid refinement study that measures convergence of the shock position and the contact width against exact solutions. All mathematical entities must be written in LaTeX, and all physical outputs must be expressed in meters where applicable.\n\nThe fundamental base is the theory of hyperbolic conservation laws, Rankine–Hugoniot jump conditions, and the Courant–Friedrichs–Lewy (CFL) stability condition. Use the following two models:\n\n1. Shock model: the inviscid Burgers conservation law,\n$$\nu_t + \\left(\\frac{1}{2} u^2\\right)_x = 0,\n$$\nwith Riemann initial data at position $x_0$,\n$$\nu(x,0) = \\begin{cases}\nu_L, & x < x_0,\\\\\nu_R, & x > x_0,\n\\end{cases}\n$$\nand $u_L > u_R$. The exact shock speed from Rankine–Hugoniot jump conditions is\n$$\ns = \\frac{f(u_L) - f(u_R)}{u_L - u_R}, \\quad \\text{with} \\quad f(u) = \\frac{1}{2}u^2,\n$$\nwhich simplifies to\n$$\ns = \\frac{u_L + u_R}{2}.\n$$\nThe exact shock position is then\n$$\nx_s(t) = x_0 + s t.\n$$\n\n2. Contact discontinuity model: linear advection of a passive scalar density,\n$$\n\\rho_t + a \\,\\rho_x = 0,\n$$\nwith Riemann initial data at position $x_0$,\n$$\n\\rho(x,0) = \\begin{cases}\n\\rho_L, & x < x_0,\\\\\n\\rho_R, & x > x_0,\n\\end{cases}\n$$\nwhere $a$ is a constant advection speed. The exact contact propagates without diffusion at speed $a$ and the exact contact width remains zero for all times. The exact contact position is\n$$\nx_c(t) = x_0 + a t \\quad \\text{modulo the domain length for periodic boundaries}.\n$$\n\nDefine error norms appropriate for discontinuities. For a discontinuity represented by an interface (shock or contact), we define indicator functions, thresholds, and geometric error metrics as follows:\n\n- Shock indicator function: let $H(x; x_*)$ be the Heaviside function centered at $x_*$,\n$$\nH(x; x_*) = \\begin{cases}\n1, & x < x_*,\\\\\n0, & x > x_*.\n\\end{cases}\n$$\nFor the Burgers shock with $u_L > u_R$, the exact indicator is $\\chi_{\\mathrm{exact}}(x,t) = H(x; x_s(t))$, while the numerical indicator is $\\chi_{\\mathrm{num}}(x,t) = \\mathbf{1}_{\\{u(x,t) > u_m\\}}$ where the mid-value threshold is $u_m = \\frac{u_L + u_R}{2}$. The indicator-function error field is $e_\\chi(x,t) = \\chi_{\\mathrm{num}}(x,t) - \\chi_{\\mathrm{exact}}(x,t)$. The $L_1$, $L_2$, and $L_\\infty$ norms of $e_\\chi$ over the spatial domain $[0,L]$ are\n$$\n\\|e_\\chi\\|_{1} = \\int_0^L |e_\\chi(x,t)| \\, dx, \\quad\n\\|e_\\chi\\|_{2} = \\left(\\int_0^L |e_\\chi(x,t)|^2 \\, dx\\right)^{1/2}, \\quad\n\\|e_\\chi\\|_{\\infty} = \\sup_{x \\in [0,L]} |e_\\chi(x,t)|.\n$$\nFor perfectly sharp steps, $\\|e_\\chi\\|_{1}$ equals the shock misalignment $|x_s^{\\mathrm{num}}(t) - x_s(t)|$ and $\\|e_\\chi\\|_{2} = \\sqrt{|x_s^{\\mathrm{num}}(t) - x_s(t)|}$, while $\\|e_\\chi\\|_{\\infty}$ is either $0$ or $1$. In practice, with numerical smearing, $\\|e_\\chi\\|_{1}$ includes both misalignment and smear contributions. To isolate the geometric shock position error, define the scalar position error\n$$\ne_s(t) = x_s^{\\mathrm{num}}(t) - x_s(t),\n$$\nand use its scalar norms,\n$$\n\\|e_s\\|_{1} = |e_s|, \\quad \\|e_s\\|_{2} = \\sqrt{e_s^2}, \\quad \\|e_s\\|_{\\infty} = |e_s|.\n$$\n\n- Contact width indicator: normalize the density by the jump magnitude,\n$$\n\\eta(x,t) = \\frac{\\rho(x,t) - \\rho_R}{\\rho_L - \\rho_R}.\n$$\nDefine threshold crossings at levels $\\eta_{10} = 0.1$ and $\\eta_{90} = 0.9$. Let $x_{10}(t)$ and $x_{90}(t)$ be the positions at time $t$ where $\\eta$ crosses $0.1$ and $0.9$ respectively, using linear interpolation between grid points. The numerical contact width is\n$$\n\\hat{w}(t) = x_{90}(t) - x_{10}(t).\n$$\nThe exact width is $w(t) = 0$, so the scalar width error is\n$$\ne_w(t) = \\hat{w}(t) - w(t) = \\hat{w}(t).\n$$\nDefine scalar norms for $e_w$ as\n$$\n\\|e_w\\|_{1} = \\hat{w}, \\quad \\|e_w\\|_{2} = \\sqrt{\\hat{w}^2}, \\quad \\|e_w\\|_{\\infty} = \\hat{w}.\n$$\n\nNumerical schemes to be used:\n\n- For the Burgers shock, use a first-order conservative finite-volume method with the Lax–Friedrichs numerical flux, implemented on a uniform grid. The Lax–Friedrichs flux at an interface $i+\\frac{1}{2}$ is\n$$\nF_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(f(u_i) + f(u_{i+1})\\right) - \\frac{1}{2}\\alpha_{i+\\frac{1}{2}}(u_{i+1} - u_i),\n$$\nwith $f(u) = \\frac{1}{2}u^2$ and $\\alpha_{i+\\frac{1}{2}} = \\max\\{|u_i|,|u_{i+1}|\\}$. Update\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\nand enforce outflow (transmissive) boundary conditions via constant extrapolation to ghost cells. Choose the time step by the Courant–Friedrichs–Lewy (CFL) condition,\n$$\n\\Delta t = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max_i |u_i|},\n$$\nwith $\\mathrm{CFL} = 0.45$.\n\n- For the contact, use a first-order upwind finite-difference scheme appropriate to the sign of $a$ on a uniform periodic grid. If $a \\ge 0$,\n$$\n\\rho_i^{n+1} = \\rho_i^n - \\nu\\left(\\rho_i^n - \\rho_{i-1}^n\\right), \\quad \\nu = \\frac{a \\Delta t}{\\Delta x},\n$$\nwith periodic wrap for $i-1$. If $a < 0$,\n$$\n\\rho_i^{n+1} = \\rho_i^n - \\nu\\left(\\rho_{i+1}^n - \\rho_i^n\\right), \\quad \\nu = \\frac{a \\Delta t}{\\Delta x},\n$$\nwith periodic wrap for $i+1$. Choose $\\Delta t$ by the Courant–Friedrichs–Lewy (CFL) condition\n$$\n\\Delta t = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{|a|},\n$$\nwith $\\mathrm{CFL} = 0.9$.\n\nGeometric detection procedures:\n\n- Shock position detection: at final time $t$, define the mid-state $u_m = \\frac{u_L + u_R}{2}$ and locate the unique crossing in $u(x,t)$ of the level $u_m$ by linear interpolation between the two adjacent grid points that straddle $u_m$. If no crossing is found due to numerical anomalies, fall back to locating the interface as the midpoint of the cell face with maximal gradient magnitude $|u_{i+1} - u_i|$.\n\n- Contact width detection: at final time $t$, compute the normalized field $\\eta$. Locate the positions $x_{10}$ and $x_{90}$ at which $\\eta$ crosses the levels $0.1$ and $0.9$ by linear interpolation. Use the pair of crossings closest (in index space) to the maximum gradient location to avoid spurious crossings due to periodicity. The width is then $\\hat{w} = x_{90} - x_{10}$.\n\nGrid refinement study and required outputs:\n\n- Domain length is $L = 1$ meter. Initial discontinuity positions are $x_0 = 0.5$ meters for the shock and $x_0 = 0.25$ meters for the contact. Final times and parameters are:\n\n  - Shock case: $u_L = 2$ meters per second, $u_R = 0$ meters per second, final time $t_{\\mathrm{shock}} = 0.2$ seconds.\n  - Contact case: $\\rho_L = 1$ kilograms per cubic meter, $\\rho_R = 0.1$ kilograms per cubic meter, advection speed $a = 0.5$ meters per second, final time $t_{\\mathrm{contact}} = 0.4$ seconds.\n\n- Use the uniform grids with numbers of cells $N \\in \\{100, 200, 400, 800\\}$. For each $N$, compute the $L_1$ norm of the shock position error $\\|e_s\\|_1$ in meters and the $L_1$ norm of the contact width error $\\|e_w\\|_1$ in meters. Then compute empirical convergence rates for each quantity by pairwise ratios across successive refinements,\n$$\nR = \\frac{1}{M}\\sum_{j=1}^{M} \\frac{\\log\\left(E_{N_j} / E_{N_{j+1}}\\right)}{\\log\\left(\\Delta x_{N_j} / \\Delta x_{N_{j+1}}\\right)} = \\frac{1}{M}\\sum_{j=1}^{M} \\frac{\\log\\left(E_{N_j} / E_{N_{j+1}}\\right)}{\\log(2)},\n$$\nwhere $E_{N}$ is the error at resolution $N$, $\\Delta x_N = L/N$, and $M = 3$ for the sequence $\\{100,200,400,800\\}$.\n\n- Physical units: all positions and widths must be expressed in meters. Report all errors and rates as unitless floats except that all error values represent lengths in meters.\n\n- Test suite: use the two scenarios above and the grid sizes $N \\in \\{100, 200, 400, 800\\}$ for both scenarios.\n\n- Final output format: your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with the exact order\n$$\n[\\|e_s\\|_1(N{=}100), \\|e_s\\|_1(N{=}200), \\|e_s\\|_1(N{=}400), \\|e_s\\|_1(N{=}800), R_{\\mathrm{shock}}, \\|e_w\\|_1(N{=}100), \\|e_w\\|_1(N{=}200), \\|e_w\\|_1(N{=}400), \\|e_w\\|_1(N{=}800), R_{\\mathrm{contact}}],\n$$\nwhere each $\\|e_s\\|_1$ and $\\|e_w\\|_1$ is in meters and each rate $R$ is unitless. The list must be printed exactly as specified, with no additional text.",
            "solution": "The problem requires the implementation and analysis of numerical solutions for two fundamental one-dimensional hyperbolic conservation laws: the inviscid Burgers' equation, which models shock formation, and the linear advection equation, which models the propagation of a contact discontinuity. The analysis involves a grid refinement study to measure the convergence of specific error metrics appropriate for discontinuous solutions.\n\nThe solution is structured as follows: First, we develop the numerical solver for the Burgers' equation using a first-order finite-volume method with the Lax-Friedrichs flux. Second, we develop a solver for the linear advection equation using a first-order upwind scheme. For both cases, we implement the specified procedures for detecting the feature (shock position or contact width) and calculating the error against the exact solution. Finally, we perform a grid refinement study for both models, calculate the errors for grid sizes $N \\in \\{100, 200, 400, 800\\}$, and compute the empirical convergence rates.\n\n### 1. Shock Model: Inviscid Burgers' Equation\n\n**Governing Equation and Exact Solution**\nThe inviscid Burgers' equation is given by\n$$u_t + \\left(\\frac{1}{2} u^2\\right)_x = 0.$$\nFor Riemann initial data with $u(x,0) = u_L$ for $x < x_0$ and $u(x,0) = u_R$ for $x > x_0$, where $u_L > u_R$, a shock wave forms and propagates with a constant speed $s$ determined by the Rankine-Hugoniot condition:\n$$s = \\frac{f(u_L) - f(u_R)}{u_L - u_R} = \\frac{\\frac{1}{2}u_L^2 - \\frac{1}{2}u_R^2}{u_L - u_R} = \\frac{u_L + u_R}{2}.$$\nThe exact shock position at time $t$ is $x_s(t) = x_0 + st$.\n\n**Numerical Implementation**\nWe implement a conservative finite-volume scheme on a uniform grid with cell size $\\Delta x = L/N$. The state variable $u_i^n$ represents the cell-average of the solution in cell $i$ at time $t^n$. The update formula is\n$$u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),$$\nwhere $F_{i+\\frac{1}{2}}$ is the numerical flux at the interface between cell $i$ and cell $i+1$. We use the Lax-Friedrichs flux:\n$$F_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(f(u_i) + f(u_{i+1})\\right) - \\frac{1}{2}\\alpha_{i+\\frac{1}{2}}(u_{i+1} - u_i),$$\nwith the flux function $f(u) = \\frac{1}{2}u^2$ and local dissipative coefficient $\\alpha_{i+\\frac{1}{2}} = \\max\\{|u_i|, |u_{i+1}|\\}$. This scheme is first-order accurate. The time step $\\Delta t$ is controlled by the CFL condition with a constant $\\mathrm{CFL}=0.45$:\n$$\\Delta t = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max_i |u_i^n|}.$$\nOutflow boundary conditions are handled by setting the values in the single ghost cells at each end of the domain to be equal to their adjacent interior cell-centered values (zero-gradient extrapolation).\n\n**Error Analysis: Shock Position**\nThe primary error metric is the shock position error, $e_s(t) = x_s^{\\mathrm{num}}(t) - x_s(t)$. To find the numerical shock position $x_s^{\\mathrm{num}}(t)$, we locate where the numerical solution $u(x,t)$ crosses the mid-state value $u_m = (u_L+u_R)/2$. This is achieved by finding the two adjacent grid cells $(i, i+1)$ that straddle $u_m$ and using linear interpolation to find the sub-grid crossing point. A fallback procedure, based on locating the cell interface with the maximum gradient, is implemented for robustness, though it's not expected to be triggered by the monotone Lax-Friedrichs scheme. The $L_1$ norm of this scalar error is simply its absolute value, $\\|e_s\\|_1 = |e_s(t)|$.\n\n### 2. Contact Discontinuity Model: Linear Advection\n\n**Governing Equation and Exact Solution**\nThe linear advection of a passive scalar density $\\rho$ is governed by\n$$\\rho_t + a \\,\\rho_x = 0,$$\nwhere $a$ is a constant velocity. For Riemann initial data, the discontinuity simply translates at speed $a$ without changing its shape. The exact width of the contact remains zero. The position is $x_c(t) = (x_0 + at) \\pmod{L}$ for a periodic domain of length $L$.\n\n**Numerical Implementation**\nA first-order upwind finite-difference scheme is used on a uniform, periodic grid. For the given parameter $a=0.5 \\text{ m/s} > 0$, the update is\n$$\\rho_i^{n+1} = \\rho_i^n - \\nu\\left(\\rho_i^n - \\rho_{i-1}^n\\right),$$\nwhere $\\nu = a\\Delta t / \\Delta x$ is the Courant number. Periodicity is enforced by using a circular shift for the $\\rho_{i-1}$ term. The time step is determined by the CFL condition with $\\mathrm{CFL}=0.9$:\n$$\\Delta t = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{|a|}.$$\n\n**Error Analysis: Contact Width**\nFirst-order schemes introduce numerical diffusion, which artificially broadens the contact discontinuity. This broadening is the primary error to be measured. The numerical contact width, $\\hat{w}(t)$, is calculated from the profile of the normalized density, $\\eta(x,t) = (\\rho(x,t) - \\rho_R)/(\\rho_L - \\rho_R)$. We identify the positions $x_{10}(t)$ and $x_{90}(t)$ where $\\eta$ crosses the thresholds $0.1$ and $0.9$, respectively. These positions are found using linear interpolation, with the search localized around the point of maximum gradient in $\\eta$ to ensure the correct transition is identified. The numerical width is then computed as $\\hat{w}(t) = |x_{10}(t) - x_{90}(t)|$. Since the exact width $w(t)$ is zero, the width error is $e_w(t) = \\hat{w}(t)$, and its $L_1$ norm is $\\|e_w\\|_1 = \\hat{w}(t)$.\n\n### 3. Grid Refinement Study and Convergence Rate\n\nA convergence study is performed for both models using a sequence of four grid resolutions, $N = 100, 200, 400, 800$. For each resolution, the corresponding error, $\\|e_s\\|_1$ for the shock or $\\|e_w\\|_1$ for the contact, is recorded. The empirical convergence rate $R$ is then calculated as the average of the pairwise rates determined from successive refinements:\n$$R = \\frac{1}{3} \\sum_{j=1}^{3} \\frac{\\log\\left(E_{N_j} / E_{N_{j+1}}\\right)}{\\log(2)},$$\nwhere $E_{N_j}$ is the error for resolution $N_j$ from the sequence $\\{100, 200, 400, 800\\}$. For first-order schemes, the shock position error is expected to converge with $R \\approx 1$, while the contact width, dominated by numerical diffusion proportional to $\\Delta x$, is also expected to converge with $R \\approx 1$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_shock_sim(N):\n    \"\"\"\n    Solves the 1D inviscid Burgers' equation for a shock tube problem\n    using a first-order Lax-Friedrichs finite-volume scheme.\n    \"\"\"\n    # Parameters from problem statement\n    L = 1.0  # meters\n    x0 = 0.5  # meters\n    u_L = 2.0  # m/s\n    u_R = 0.0  # m/s\n    t_final = 0.2  # seconds\n    CFL_val = 0.45\n\n    # Grid setup\n    dx = L / N\n    # Array with one ghost cell on each side\n    u = np.zeros(N + 2)\n    # Cell centers for the physical domain\n    domain_x = np.linspace(0.5 * dx, L - 0.5 * dx, N)\n\n    # Initial condition\n    u[1:-1] = np.where(domain_x < x0, u_L, u_R)\n    \n    t = 0.0\n    while t < t_final:\n        # Boundary conditions: outflow (zero-gradient)\n        u[0] = u[1]\n        u[-1] = u[-2]\n\n        # Time step from CFL condition\n        max_speed = np.max(np.abs(u))\n        if max_speed < 1e-9: # Avoid division by zero\n            dt = t_final - t\n        else:\n            dt = CFL_val * dx / max_speed\n        \n        dt = min(dt, t_final - t)\n\n        # Lax-Friedrichs flux calculation\n        f_u = 0.5 * u**2\n        u_left = u[:-1]\n        u_right = u[1:]\n        \n        alpha = np.maximum(np.abs(u_left), np.abs(u_right))\n        flux = 0.5 * (f_u[:-1] + f_u[1:]) - 0.5 * alpha * (u_right - u_left)\n        \n        # Update solution in the physical domain\n        u[1:-1] -= (dt / dx) * (flux[1:] - flux[:-1])\n        \n        t += dt\n\n    # Post-processing to find error\n    s = (u_L + u_R) / 2.0\n    x_s_exact = x0 + s * t_final\n    \n    u_m = (u_L + u_R) / 2.0\n    u_domain = u[1:-1]\n    \n    x_s_num = None\n    # Find shock position via linear interpolation\n    for i in range(N - 1):\n        if u_domain[i] > u_m and u_domain[i+1] <= u_m:\n            y1, y2 = u_domain[i], u_domain[i+1]\n            x1 = domain_x[i]\n            # (x2-x1) is dx\n            x_s_num = x1 + dx * (u_m - y1) / (y2 - y1)\n            break\n            \n    # Fallback if no crossing is found\n    if x_s_num is None:\n        grad_u = np.abs(u_domain[1:] - u_domain[:-1])\n        max_grad_idx = np.argmax(grad_u)\n        # Midpoint of the cell face with maximal gradient\n        x_s_num = domain_x[max_grad_idx] + 0.5 * dx\n\n    return np.abs(x_s_num - x_s_exact)\n\n\ndef run_contact_sim(N):\n    \"\"\"\n    Solves the 1D linear advection equation for a contact discontinuity\n    using a first-order upwind finite-difference scheme.\n    \"\"\"\n    # Parameters from problem statement\n    L = 1.0  # meters\n    x0 = 0.25  # meters\n    rho_L = 1.0  # kg/m^3\n    rho_R = 0.1  # kg/m^3\n    a = 0.5  # m/s\n    t_final = 0.4  # seconds\n    CFL_val = 0.9\n\n    # Grid setup\n    dx = L / N\n    x = np.linspace(0.5 * dx, L - 0.5 * dx, N)\n    rho = np.where(x < x0, rho_L, rho_R)\n    \n    t = 0.0\n    # Fixed timestep and Courant number for linear advection\n    dt_cfl = CFL_val * dx / np.abs(a)\n    nu_cfl = a * dt_cfl / dx\n\n    while t < t_final:\n        dt = min(dt_cfl, t_final - t)\n        nu = a * dt / dx\n        \n        # Update with first-order upwind scheme (a > 0)\n        # Periodic BCs handled by np.roll\n        rho_prev = np.roll(rho, 1)\n        rho = rho - nu * (rho - rho_prev)\n        \n        t += dt\n\n    # Post-processing to find contact width\n    eta = (rho - rho_R) / (rho_L - rho_R)\n    \n    def find_crossing_pos(vals, x_coords, threshold):\n        for i in range(N):\n            i_p1 = (i + 1) % N\n            y1, y2 = vals[i], vals[i_p1]\n            if (y1 - threshold) * (y2 - threshold) < 0 and y1 > y2:\n                x1 = x_coords[i]\n                return x1 + dx * (threshold - y1) / (y2 - y1)\n        return None\n\n    x_90 = find_crossing_pos(eta, x, 0.9)\n    x_10 = find_crossing_pos(eta, x, 0.1)\n\n    if x_90 is None or x_10 is None:\n        return np.nan # Should not happen in this problem\n\n    # Since profile is decreasing, x_90 < x_10. Width is positive.\n    width = x_10 - x_90\n    if width < 0: # Handle periodic wrap-around case\n        width += L\n    \n    return width\n\n\ndef calculate_rate(errors):\n    \"\"\"Calculates the average convergence rate.\"\"\"\n    rates = []\n    for i in range(len(errors) - 1):\n        # Avoid log(0) or division by zero\n        if errors[i] <= 0 or errors[i+1] <= 0:\n            continue\n        ratio_err = errors[i] / errors[i+1]\n        rate = np.log2(ratio_err) # Equivalent to log(ratio)/log(2)\n        rates.append(rate)\n    return np.mean(rates) if rates else np.nan\n\n\ndef solve():\n    \"\"\"\n    Main driver function to run simulations, calculate errors and rates,\n    and print the final result in the specified format.\n    \"\"\"\n    N_vals = [100, 200, 400, 800]\n    \n    shock_errors = [run_shock_sim(N) for N in N_vals]\n    R_shock = calculate_rate(shock_errors)\n\n    contact_errors = [run_contact_sim(N) for N in N_vals]\n    R_contact = calculate_rate(contact_errors)\n    \n    results = shock_errors + [R_shock] + contact_errors + [R_contact]\n    \n    # Format and print the final output line\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While robust, first-order schemes suffer from significant numerical diffusion, smearing sharp features across many grid cells. To achieve higher accuracy, we turn to methods like the Monotone Upstream-centered Schemes for Conservation Laws (MUSCL), which use a higher-order reconstruction of the solution within each cell. This practice  challenges you to implement a second-order MUSCL scheme and explore the critical role of slope limiters—the mechanism that prevents spurious oscillations near discontinuities—by comparing the performance of several standard limiters on a contact discontinuity problem.",
            "id": "3521267",
            "problem": "Consider the one-dimensional scalar conservation law $\\partial_t q + \\partial_x f(q) = 0$ over a periodic domain of length $L$ with a piecewise constant initial condition that contains a single contact discontinuity. In a contact discontinuity of a compressible flow, a passively advected scalar such as density or a mass fraction is transported without change in shape by the underlying velocity field. Model this transport using the linear advection flux $f(q) = a q$ with constant advection speed $a$, so that the conservation law becomes $\\partial_t q + a \\partial_x q = 0$. Use a finite volume method with uniform cells where $q_i^n$ denotes the cell average in cell index $i$ at time level $n$, uniform grid spacing $\\Delta x = L/N$, and time step $\\Delta t$ set by a specified Courant number $C$ through $\\Delta t = C \\Delta x / |a|$. The update for a single time step is $q_i^{n+1} = q_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right)$, where $F_{i+1/2}^n$ is the numerical flux at the interface between cells $i$ and $i+1$ and periodic boundary conditions are imposed.\n\nConstruct second-order Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL) interface states $q_{i+1/2}^{L}$ and $q_{i+1/2}^{R}$ by piecewise linear reconstruction from $q_i^n$ with a slope-limiter chosen from the following set: minmod, monotonized central (MC), van Leer, or superbee. The slope-limiter must enforce monotonicity consistent with the Total Variation Diminishing (TVD) requirement, reducing to first-order upwind in the presence of local extrema and sharpening contacts where possible without creating spurious oscillations. Use the upwind Godunov flux for linear advection: for $a \\ge 0$, choose $F_{i+1/2}^n = a \\, q_{i+1/2}^{L}$; for $a < 0$, choose $F_{i+1/2}^n = a \\, q_{i+1/2}^{R}$.\n\nAfter advancing the solution by one time step from the initial data using the above scheme, assess oscillation control and contact sharpness using the following metrics:\n- Maximum overshoot magnitude with respect to the initial global bounds: let $q_{\\min}^0 = \\min_i q_i^0$ and $q_{\\max}^0 = \\max_i q_i^0$, and define $\\mathrm{overshoot\\_max} = \\max_i \\max\\left(0, q_i^{1} - q_{\\max}^0, q_{\\min}^0 - q_i^{1}\\right)$ expressed as a float.\n- Total variation increase: let $\\mathrm{TV}(q) = \\sum_i \\left|q_{i+1} - q_i\\right|$ with periodic indexing, and define $\\Delta \\mathrm{TV} = \\mathrm{TV}(q^{1}) - \\mathrm{TV}(q^{0})$ expressed as a float.\n- Contact transition width: given known plateau values $q_L$ (left state) and $q_R$ (right state), define $\\mathrm{width} = \\#\\{i \\, | \\, \\min(q_L,q_R) < q_i^{1} < \\max(q_L,q_R)\\}$ expressed as an integer count of cells whose values lie strictly between the two plateaus after the update.\n\nYour program must implement the reconstruction and update for a single time step and compute these metrics for each test case below. Use a periodic domain. All mathematical operations must be consistent and scientifically sound. No external input is permitted.\n\nTest suite:\n- Case $1$: $N = 100$, $L = 1$, $a = 1$, $C = 0.8$, limiter = minmod, contact location at fraction $x_c = 0.4$ of the domain, plateau values $q_L = 1.0$, $q_R = 0.1$, additive localized noise amplitude $\\epsilon = 0$.\n- Case $2$: $N = 100$, $L = 1$, $a = 1$, $C = 0.95$, limiter = MC, contact location at fraction $x_c = 0.4$, plateau values $q_L = 1.0$, $q_R = 0.1$, additive localized noise amplitude $\\epsilon = 0.01$ applied to exactly the $5$ cells centered at the contact via $q_i \\mapsto q_i + \\epsilon \\sin\\left(2\\pi i / N\\right)$ for those cells.\n- Case $3$: $N = 20$, $L = 1$, $a = 1$, $C = 0.5$, limiter = van Leer, contact location at fraction $x_c = 0.5$, plateau values $q_L = 2.0$, $q_R = 1.5$, $\\epsilon = 0$.\n- Case $4$: $N = 80$, $L = 1$, $a = -1$, $C = 0.9$, limiter = superbee, contact location at fraction $x_c = 0.5$, plateau values $q_L = 1.0$, $q_R = 0.0$, additive localized noise amplitude $\\epsilon = 0.005$ applied to exactly the $3$ cells centered at the contact via $q_i \\mapsto q_i + \\epsilon \\sin\\left(2\\pi i / N\\right)$ for those cells.\n- Case $5$ (boundary condition and degeneracy check): $N = 50$, $L = 1$, $a = 1$, $C = 0.7$, limiter = MC, contact location at fraction $x_c = 0.3$, plateau values $q_L = 0.5$, $q_R = 0.5$, $\\epsilon = 0$.\n\nInitialization: For each case, initialize $q_i^0$ on a uniform grid points $x_i = (i+1/2)\\Delta x$ by setting $q_i^0 = q_L$ for $x_i < x_c L$ and $q_i^0 = q_R$ for $x_i \\ge x_c L$, then add the specified localized noise at the designated number of cells centered on the contact index $i_c = \\lfloor x_c N \\rfloor$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of three values $[\\mathrm{overshoot\\_max}, \\mathrm{width}, \\Delta \\mathrm{TV}]$. Round the floating-point values $\\mathrm{overshoot\\_max}$ and $\\Delta \\mathrm{TV}$ to $6$ decimal places, and output $\\mathrm{width}$ as an integer. For example, an output with two cases would look like $[[0.000123,4,0.001234],[0.0,0,-0.000456]]$.",
            "solution": "The user-provided problem has been validated and is determined to be sound, well-posed, and objective. It represents a standard task in the field of computational methods for fluid dynamics and astrophysics. The following solution provides a detailed explanation of the methodology and its implementation.\n\nThe problem asks for the implementation of a second-order Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL) finite volume method to solve the one-dimensional linear advection equation,\n$$\n\\partial_t q + a \\partial_x q = 0\n$$\non a periodic domain of length $L$. Here, $q(x,t)$ is a scalar quantity and $a$ is a constant advection speed. This equation is a specific case of a conservation law $\\partial_t q + \\partial_x f(q) = 0$ with a linear flux function $f(q) = aq$.\n\nThe numerical solution is computed on a uniform grid of $N$ cells, where cell $i$ spans the interval $[x_{i-1/2}, x_{i+1/2}]$. The cell centers are at $x_i = (i+1/2)\\Delta x$ for $i=0, 1, \\dots, N-1$, with grid spacing $\\Delta x = L/N$. The cell-averaged value of $q$ in cell $i$ at time level $n$ is denoted by $q_i^n$.\n\nThe finite volume method updates the cell averages from one time level $n$ to the next $n+1$ via the conservative formula:\n$$\nq_i^{n+1} = q_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right)\n$$\nwhere $\\Delta t$ is the time step, and $F_{i+1/2}^n$ is the numerical flux at the interface between cells $i$ and $i+1$. The time step is determined by the Courant-Friedrichs-Lewy (CFL) condition, $\\Delta t = C \\Delta x / |a|$, where $C$ is the specified Courant number, which must be less than or equal to $1$ for stability. Periodic boundary conditions are applied, meaning that indices are treated modulo $N$.\n\nThe core of the MUSCL scheme is the second-order accurate spatial reconstruction of the states at the cell interfaces. Within each cell $i$, the data is represented by a piecewise linear function. This leads to two distinct values at each interface: $q_{i+1/2}^L$, the state reconstructed from the left (cell $i$), and $q_{i+1/2}^R$, the state reconstructed from the right (cell $i+1$). These are given by:\n$$\nq_{i+1/2}^L = q_i^n + \\frac{1}{2} \\sigma_i\n$$\n$$\nq_{i+1/2}^R = q_{i+1}^n - \\frac{1}{2} \\sigma_{i+1}\n$$\nHere, $\\sigma_i$ is a slope-limited representation of the change in $q$ across cell $i$. To prevent spurious oscillations and ensure the scheme is Total Variation Diminishing (TVD), the slope $\\sigma_i$ is computed by applying a slope limiter function to the backward and forward differences relative to cell $i$: $\\Delta q_{i-1/2} = q_i^n - q_{i-1}^n$ and $\\Delta q_{i+1/2} = q_{i+1}^n - q_i^n$.\n$$\n\\sigma_i = \\text{limiter}(\\Delta q_{i-1/2}, \\Delta q_{i+1/2})\n$$\nThe limiter functions are defined as follows, for two arguments $u$ and $v$:\n1.  **minmod**:\n    $$\n    \\text{minmod}(u, v) =\n    \\begin{cases}\n    \\text{sgn}(u) \\min(|u|, |v|) & \\text{if } uv > 0 \\\\\n    0 & \\text{if } uv \\le 0\n    \\end{cases}\n    $$\n2.  **Monotonized Central (MC)**:\n    $$\n    \\text{MC}(u, v) =\n    \\begin{cases}\n    \\text{sgn}(u) \\min\\left(2|u|, 2|v|, \\frac{|u+v|}{2}\\right) & \\text{if } uv > 0 \\\\\n    0 & \\text{if } uv \\le 0\n    \\end{cases}\n    $$\n3.  **van Leer**:\n    $$\n    \\text{vanLeer}(u, v) =\n    \\begin{cases}\n    \\frac{2uv}{u+v} & \\text{if } uv > 0 \\\\\n    0 & \\text{if } uv \\le 0\n    \\end{cases}\n    $$\n4.  **superbee**:\n    $$\n    \\text{superbee}(u, v) =\n    \\begin{cases}\n    \\text{sgn}(u) \\max\\left(\\min(2|u|,|v|), \\min(|u|,2|v|)\\right) & \\text{if } uv > 0 \\\\\n    0 & \\text{if } uv \\le 0\n    \\end{cases}\n    $$\n\nThe numerical flux $F_{i+1/2}^n$ is an upwind Godunov flux, which selects the interface state based on the direction of information flow, determined by the sign of the advection speed $a$:\n$$\nF_{i+1/2}^n =\n\\begin{cases}\na \\, q_{i+1/2}^{L} & \\text{if } a \\ge 0 \\\\\na \\, q_{i+1/2}^{R} & \\text{if } a < 0\n\\end{cases}\n$$\n\nAfter computing the updated state $q_i^1$ for all cells $i$, the following metrics are evaluated to assess the scheme's performance:\n-   **Maximum overshoot magnitude**: This measures the largest violation of the initial data's global minimum and maximum values. Let $q_{\\min}^0 = \\min_j q_j^0$ and $q_{\\max}^0 = \\max_j q_j^0$. The overshoot is:\n    $$\n    \\mathrm{overshoot\\_max} = \\max_i \\max\\left(0, q_i^{1} - q_{\\max}^0, q_{\\min}^0 - q_i^{1}\\right)\n    $$\n    A value of $0$ indicates a non-oscillatory result that respects the initial bounds.\n-   **Total variation increase**: The total variation $\\mathrm{TV}(q) = \\sum_i \\left|q_{i+1} - q_i\\right|$ (with periodic indexing) is a measure of the total oscillation in the data. For a TVD scheme, the total variation should not increase over time. The metric is the change in total variation after one step:\n    $$\n    \\Delta \\mathrm{TV} = \\mathrm{TV}(q^{1}) - \\mathrm{TV}(q^{0})\n    $$\n-   **Contact transition width**: This measures the numerical diffusion of the contact discontinuity. It is defined as the number of cells whose values lie strictly between the initial left and right plateau values, $q_L$ and $q_R$:\n    $$\n    \\mathrm{width} = \\#\\{i \\, | \\, \\min(q_L,q_R) < q_i^{1} < \\max(q_L,q_R)\\}\n    $$\n    A smaller width indicates a sharper captured discontinuity.\n\nThe algorithm proceeds by initializing the cell averages $q_i^0$ based on the given piecewise-constant profile and any specified noise, computing the slopes and interface states, calculating the upwind fluxes, advancing the solution by one time step, and finally computing the required metrics. For the case of constant initial data ($q_L = q_R$), the scheme is expected to preserve this state exactly, resulting in zero for all metrics.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a MUSCL finite volume scheme for the 1D linear advection equation\n    and computes performance metrics for several test cases.\n    \"\"\"\n    \n    test_cases = [\n        {'N': 100, 'L': 1.0, 'a': 1.0, 'C': 0.8, 'limiter': 'minmod', 'xc': 0.4, 'qL': 1.0, 'qR': 0.1, 'epsilon': 0.0, 'noise_cells': 0},\n        {'N': 100, 'L': 1.0, 'a': 1.0, 'C': 0.95, 'limiter': 'mc', 'xc': 0.4, 'qL': 1.0, 'qR': 0.1, 'epsilon': 0.01, 'noise_cells': 5},\n        {'N': 20, 'L': 1.0, 'a': 1.0, 'C': 0.5, 'limiter': 'vanleer', 'xc': 0.5, 'qL': 2.0, 'qR': 1.5, 'epsilon': 0.0, 'noise_cells': 0},\n        {'N': 80, 'L': 1.0, 'a': -1.0, 'C': 0.9, 'limiter': 'superbee', 'xc': 0.5, 'qL': 1.0, 'qR': 0.0, 'epsilon': 0.005, 'noise_cells': 3},\n        {'N': 50, 'L': 1.0, 'a': 1.0, 'C': 0.7, 'limiter': 'mc', 'xc': 0.3, 'qL': 0.5, 'qR': 0.5, 'epsilon': 0.0, 'noise_cells': 0},\n    ]\n\n    # --- Slope Limiter Functions ---\n    def minmod(a, b):\n        return np.where(a * b > 0, np.sign(a) * np.minimum(np.abs(a), np.abs(b)), 0)\n\n    def mc(a, b):\n        s = (a + b) / 2.0\n        # Use np.sign(s) instead of np.sign(a) to handle s=0 case if a,b are opposite signs\n        return np.where(a * b > 0, np.sign(s) * np.minimum(np.abs(s), np.minimum(2 * np.abs(a), 2 * np.abs(b))), 0)\n\n    def vanleer(a, b):\n        # Handle division by zero when a+b is close to zero\n        # This happens if a = -b or a=b=0. If a*b > 0, then a+b=0 only if a=b=0.\n        denom = a + b\n        # Epsilon can be larger since we're dealing with differences, not just machine precision\n        return np.where( (a * b > 0) & (np.abs(denom) > 1e-12), 2 * a * b / denom, 0)\n        \n    def superbee(a, b):\n        t1 = np.minimum(2 * np.abs(a), np.abs(b))\n        t2 = np.minimum(np.abs(a), 2 * np.abs(b))\n        return np.where(a * b > 0, np.sign(a) * np.maximum(t1, t2), 0)\n\n    limiters = {\n        'minmod': minmod,\n        'mc': mc,\n        'vanleer': vanleer,\n        'superbee': superbee\n    }\n\n    def total_variation(q):\n        \"\"\"Computes the total variation of a periodic array.\"\"\"\n        return np.sum(np.abs(np.roll(q, -1) - q))\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        L = case['L']\n        a = case['a']\n        C = case['C']\n        qL = case['qL']\n        qR = case['qR']\n        xc = case['xc']\n        epsilon = case['epsilon']\n        noise_cells = case['noise_cells']\n        limiter_func = limiters[case['limiter']]\n\n        # --- Grid and Time Step Setup ---\n        dx = L / N\n        dt = C * dx / abs(a)\n        \n        # --- Initialization ---\n        i = np.arange(N)\n        x = (i + 0.5) * dx\n        q0 = np.where(x < xc * L, qL, qR)\n\n        if epsilon > 0 and noise_cells > 0:\n            ic = int(np.floor(xc * N))\n            m = noise_cells // 2\n            noise_indices = np.arange(ic - m, ic + m + 1)\n            noise_indices = noise_indices % N  # Handle periodic wrap-around\n            q0[noise_indices] += epsilon * np.sin(2 * np.pi * noise_indices / N)\n\n        # --- Initial Metrics ---\n        q0_min = np.min(q0)\n        q0_max = np.max(q0)\n        tv0 = total_variation(q0)\n        \n        # --- MUSCL Finite Volume Step ---\n        # Get neighboring cell values with periodic boundaries\n        q_im1 = np.roll(q0, 1)\n        q_ip1 = np.roll(q0, -1)\n\n        # Compute differences for slope calculation\n        delta_fwd = q_ip1 - q0  # Corresponds to q_{i+1} - q_i\n        delta_bwd = q0 - q_im1  # Corresponds to q_i - q_{i-1}\n\n        # Compute limited slopes for each cell\n        # The limiter function arguments are (q_i - q_{i-1}, q_{i+1} - q_i)\n        sigma = limiter_func(delta_bwd, delta_fwd)\n\n        # Reconstruct interface states\n        q_L = q0 + 0.5 * sigma\n        q_R = q_ip1 - 0.5 * np.roll(sigma, -1)\n\n        # Compute upwind Godunov flux at interfaces i+1/2\n        if a >= 0:\n            F = a * q_L\n        else:\n            F = a * q_R\n        \n        # Get fluxes at interfaces i-1/2 by rolling\n        F_im1_2 = np.roll(F, 1)\n\n        # Update solution by one time step\n        q1 = q0 - (dt / dx) * (F - F_im1_2)\n\n        # --- Final Metrics Calculation ---\n        # 1. Maximum overshoot\n        overshoot = np.maximum(0, q1 - q0_max)\n        undershoot = np.maximum(0, q0_min - q1)\n        overshoot_max = np.max(np.maximum(overshoot, undershoot))\n\n        # 2. Total variation increase\n        tv1 = total_variation(q1)\n        delta_tv = tv1 - tv0\n\n        # 3. Contact transition width\n        plateau_min = min(qL, qR)\n        plateau_max = max(qL, qR)\n        \n        # Prevent counting plateaus if min == max\n        if plateau_min == plateau_max:\n             width = 0\n        else:\n             width = np.sum((q1 > plateau_min) & (q1 < plateau_max))\n\n        results.append([round(overshoot_max, 6), int(width), round(delta_tv, 6)])\n\n    # --- Format final output correctly ---\n    formatted_results = []\n    for r in results:\n        # Use standard float formatting; round() handles cases like 0.0 correctly\n        # f-strings with precision (e.g. .6f) would write 0.0 as 0.000000\n        formatted_results.append(f\"[{r[0]},{r[1]},{r[2]}]\")\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Verifying that a numerical code correctly implements a complex algorithm and achieves its theoretical order of accuracy is a cornerstone of computational science. While testing against known Riemann problems is useful, the Method of Manufactured Solutions (MMS) provides a more powerful and flexible approach for rigorous code verification. In this exercise , you will construct an exact solution that combines smooth features with a sharp, controlled gradient, and use it to precisely measure the convergence rate of your MUSCL scheme. This will allow you to see firsthand how a slope limiter correctly reduces the scheme's accuracy to first-order to maintain monotonicity in sharp regions, while the unlimited scheme maintains second-order convergence at the cost of oscillations.",
            "id": "3521220",
            "problem": "Consider the one-dimensional linear advection conservation law on a periodic domain,\n$$\n\\frac{\\partial u}{\\partial t} + a\\,\\frac{\\partial u}{\\partial x} = 0,\n$$\nfor a scalar field $u(x,t)$, constant advection speed $a>0$, and $x\\in[0,1]$ with periodic boundary conditions. The goal is to construct a manufactured solution with a smoothed discontinuity, implement a shock-capturing finite-volume scheme with and without a slope limiter, and use this manufactured solution to verify the formal order of accuracy while isolating limiter-induced errors.\n\nStart from the integral form of conservation over a cell average and the definition of upwind numerical flux for a linear advection equation. Use a Monotone Upstream-centered Schemes for Conservation Laws (MUSCL) reconstruction for second-order accuracy in space, and use a second-order Strong Stability Preserving Runge-Kutta (SSP-RK2) method in time. Implement two variants of the scheme:\n- a limited variant using the minmod slope limiter,\n- an unlimited variant using the centered slope without limiting.\n\nDefine the manufactured solution by choosing an initial profile $g(x)$ combining a smooth background and a smoothed discontinuity,\n$$\ng(x) = \\sin(2\\pi x) + s\\,\\tanh\\!\\left(\\frac{x-x_0}{\\delta}\\right),\n$$\nwhere $s$ is a fixed amplitude, $x_0$ sets the center of the smoothed discontinuity, and $\\delta>0$ controls the smoothing width. The exact solution at time $t$ under periodic boundary conditions is given by the advected profile\n$$\nu_{\\text{exact}}(x,t) = g\\big((x - a t) \\bmod 1\\big).\n$$\nUse the manufactured solution to compute errors of the numerical solution at a fixed final time $T$ and estimate the observed order of accuracy under successive grid refinements.\n\nImplement a one-dimensional finite-volume method on a uniform grid of $N$ cells of width $\\Delta x = 1/N$ with cell centers at $x_i = (i+1/2)\\Delta x$ for integer $i \\in \\{0,1,\\dots,N-1\\}$. Use periodic boundary conditions for all reconstructions and flux evaluations. The upwind numerical flux for $a>0$ uses the left state at interfaces. For the MUSCL reconstruction, compute left and right interface states using cell-centered values and reconstructed slopes. For the limited variant, use the minmod limiter applied to one-sided differences in each cell; for the unlimited variant, use the centered slope without limiting. Advance the solution in time to $T$ using the SSP-RK2 scheme with a Courant–Friedrichs–Lewy (CFL) number set to $C$ and a time step $\\Delta t$ chosen such that $\\Delta t \\le C\\,\\Delta x/a$. Use periodic indexing for all stencil operations.\n\nCompute the $L^1$ error at time $T$,\n$$\nE_{L^1} = \\sum_{i=0}^{N-1} \\left| u_i(T) - u_{\\text{exact}}(x_i,T) \\right| \\,\\Delta x,\n$$\nwhere $u_i(T)$ is the numerical approximation in cell $i$ at time $T$ and $u_{\\text{exact}}(x_i,T)$ is the exact solution evaluated at the cell center $x_i$. For each refinement pair $(N,2N)$, define the observed order $p$ by\n$$\np = \\frac{\\log\\left( E_{L^1}(N) / E_{L^1}(2N) \\right)}{\\log(2)}.\n$$\n\nYou must implement the program to:\n- construct and evolve the numerical solution to time $T$ for both limited and unlimited MUSCL variants,\n- compute the $L^1$ errors against the exact manufactured solution,\n- estimate the observed order $p$ for each variant using the last refinement pair,\n- quantify limiter-induced errors by reporting the ratio of limited to unlimited $L^1$ error at the finest grid.\n\nUse the following fixed parameters:\n- advection speed $a = 1$,\n- final time $T = 0.5$,\n- limiting amplitude $s = 0.8$,\n- discontinuity center $x_0 = 0.25$,\n- Courant–Friedrichs–Lewy (CFL) number $C = 0.45$,\n- grid resolutions $N \\in \\{50, 100, 200, 400\\}$,\n- smoothing widths $\\delta \\in \\{0.1, 0.02, 0.005\\}$.\n\nFor each chosen $\\delta$, compute:\n- the observed order $p_{\\text{lim}}$ for the limited scheme using the pair $(N,2N) = (200,400)$,\n- the observed order $p_{\\text{unlim}}$ for the unlimited scheme using the same pair,\n- the error ratio $R = E_{L^1,\\text{lim}}(400) / E_{L^1,\\text{unlim}}(400)$.\n\nTest Suite and Answer Specification:\n- The test suite consists of the three values of $\\delta$: $\\delta_1 = 0.1$, $\\delta_2 = 0.02$, and $\\delta_3 = 0.005$, each combined with the four grid sizes $N = 50$, $N = 100$, $N = 200$, and $N = 400$.\n- For each $\\delta$, report the three floats $p_{\\text{lim}}$, $p_{\\text{unlim}}$, and $R$ in that order.\n- Aggregate all results into a single list in the order of $\\delta_1$, then $\\delta_2$, then $\\delta_3$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, namely\n$$\n[ p_{\\text{lim}}(\\delta_1), p_{\\text{unlim}}(\\delta_1), R(\\delta_1), p_{\\text{lim}}(\\delta_2), p_{\\text{unlim}}(\\delta_2), R(\\delta_2), p_{\\text{lim}}(\\delta_3), p_{\\text{unlim}}(\\delta_3), R(\\delta_3) ].\n$$\nAll outputs must be floating-point numbers with no units.",
            "solution": "The problem presented is a valid exercise in computational physics, specifically in the numerical solution of hyperbolic conservation laws. It requires implementing and verifying a finite-volume scheme for the one-dimensional linear advection equation using the method of manufactured solutions. All components of the problem are scientifically sound, well-defined, and consistent with standard practices in the field of numerical methods for partial differential equations.\n\nThe core of the problem lies in solving the linear advection equation,\n$$\n\\frac{\\partial u}{\\partial t} + a\\,\\frac{\\partial u}{\\partial x} = 0\n$$\non a periodic domain $x \\in [0,1]$ with a constant advection speed $a > 0$. We will employ a finite-volume method, which begins with the integral form of the conservation law over a computational cell $C_i = [x_{i-1/2}, x_{i+1/2}]$ of width $\\Delta x = x_{i+1/2} - x_{i-1/2}$. Integrating the equation over $C_i$ yields:\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial u}{\\partial t} dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} a\\,\\frac{\\partial u}{\\partial x} dx = 0\n$$\nDefining the cell average $\\bar{u}_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$ and the flux $F(u) = au$, we obtain the exact evolution equation for the cell averages:\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x} \\left( F(u(x_{i+1/2}, t)) - F(u(x_{i-1/2}, t)) \\right)\n$$\nIn a numerical scheme, the exact point-wise fluxes at the cell interfaces are replaced by a numerical flux function, $F^*$, which depends on the reconstructed states of the solution at the interfaces. This gives the semi-discrete finite-volume scheme:\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x} \\left( F^*_{i+1/2} - F^*_{i-1/2} \\right) \\equiv \\mathcal{L}(\\bar{\\mathbf{u}})_i\n$$\nwhere $\\bar{\\mathbf{u}}$ is the vector of all cell averages. Since the advection speed $a$ is positive, information propagates from left to right. Thus, an upwind scheme uses the state reconstructed from the left of the interface to compute the flux. The numerical flux at interface $x_{i+1/2}$ is $F^*_{i+1/2} = a u^L_{i+1/2}$, where $u^L_{i+1/2}$ is the solution value reconstructed at the left-hand side of the interface $x_{i+1/2}$.\n\nTo achieve second-order accuracy in space, we use the Monotone Upstream-centered Schemes for Conservation Laws (MUSCL) approach. This involves a piecewise linear reconstruction of the solution within each cell $i$:\n$$\nu(x) = \\bar{u}_i + \\sigma_i (x - x_i) \\quad \\text{for } x \\in C_i\n$$\nwhere $x_i$ is the cell center and $\\sigma_i$ is the reconstructed slope in cell $i$. The value on the left side of interface $x_{i+1/2}$ is determined by the reconstruction in cell $i$:\n$$\nu^L_{i+1/2} = \\bar{u}_i + \\sigma_i \\frac{\\Delta x}{2}\n$$\nThe numerical flux at this interface is $F^*_{i+1/2} = a( \\bar{u}_i + \\sigma_i \\frac{\\Delta x}{2} )$. The flux at the preceding interface, $x_{i-1/2}$, depends on the reconstruction in cell $i-1$: $F^*_{i-1/2} = a( \\bar{u}_{i-1} + \\sigma_{i-1} \\frac{\\Delta x}{2} )$. The semi-discrete update for cell $i$ is then:\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{a}{\\Delta x} \\left[ \\left(\\bar{u}_i + \\sigma_i \\frac{\\Delta x}{2}\\right) - \\left(\\bar{u}_{i-1} + \\sigma_{i-1} \\frac{\\Delta x}{2}\\right) \\right]\n$$\nThe scheme is defined by the choice of the slope $\\sigma_i$. We implement two variants:\n1.  **Unlimited Scheme**: For smooth solutions, a second-order accurate centered difference slope is used:\n    $$\n    \\sigma_i^{\\text{unlim}} = \\frac{\\bar{u}_{i+1} - \\bar{u}_{i-1}}{2\\Delta x}\n    $$\n    This scheme is not guaranteed to be monotonic and can produce spurious oscillations near sharp gradients.\n2.  **Limited Scheme**: To prevent oscillations, a slope limiter is applied. The `minmod` limiter is a common choice. It compares the backward and forward difference slopes and selects the one with the smallest magnitude if they have the same sign, or returns zero otherwise.\n    $$\n    \\sigma_i^{\\text{lim}} = \\text{minmod}\\left( \\frac{\\bar{u}_i - \\bar{u}_{i-1}}{\\Delta x}, \\frac{\\bar{u}_{i+1} - \\bar{u}_i}{\\Delta x} \\right)\n    $$\n    where $\\text{minmod}(a, b) = \\frac{1}{2}(\\text{sgn}(a) + \\text{sgn}(b)) \\min(|a|, |b|)$. This ensures the scheme is total variation diminishing (TVD) under certain conditions but reduces the local accuracy to first order at extrema and near sharp gradients.\n\nFor time integration, the second-order Strong Stability-Preserving Runge-Kutta (SSP-RK2) method is employed. Given the semi-discrete operator $\\mathcal{L}(\\bar{\\mathbf{u}})$, the solution is advanced from time $t^n$ to $t^{n+1}=t^n+\\Delta t$ in two stages:\n$$\n\\bar{\\mathbf{u}}^{(1)} = \\bar{\\mathbf{u}}^n + \\Delta t \\mathcal{L}(\\bar{\\mathbf{u}}^n)\n$$\n$$\n\\bar{\\mathbf{u}}^{n+1} = \\frac{1}{2}\\bar{\\mathbf{u}}^n + \\frac{1}{2}\\left(\\bar{\\mathbf{u}}^{(1)} + \\Delta t \\mathcal{L}(\\bar{\\mathbf{u}}^{(1)})\\right)\n$$\nThe time step $\\Delta t$ must satisfy the Courant–Friedrichs–Lewy (CFL) condition, $\\Delta t \\le C \\frac{\\Delta x}{a}$, with the given CFL number $C=0.45$.\n\nThe verification is based on a manufactured solution. The initial profile is $g(x) = \\sin(2\\pi x) + s\\,\\tanh((x-x_0)/\\delta)$. The exact solution to the advection equation with periodic boundary conditions is the translation of this profile: $u_{\\text{exact}}(x,t) = g((x - a t) \\bmod 1)$. We compute the $L^1$ error of the numerical solution $\\bar{u}_i$ at the final time $T$:\n$$\nE_{L^1} = \\sum_{i=0}^{N-1} \\left| \\bar{u}_i(T) - u_{\\text{exact}}(x_i,T) \\right| \\,\\Delta x\n$$\nThe observed order of accuracy, $p$, is estimated from errors on two successively refined grids with $N$ and $2N$ cells: $p = \\log_2(E_{L^1}(N) / E_{L^1}(2N))$.\nBy varying the smoothing parameter $\\delta$, we can study the scheme's behavior on problems ranging from very smooth ($\\delta=0.1$) to those with sharp gradients ($\\delta=0.005$). The analysis involves comparing the convergence orders ($p_{\\text{lim}}$, $p_{\\text{unlim}}$) and the final error ratio $R = E_{L^1,\\text{lim}} / E_{L^1,\\text{unlim}}$ to quantify the impact of the slope limiter. For smooth solutions (large $\\delta$), both schemes should approach second-order convergence ($p \\approx 2$). For sharp features (small $\\delta$), the limiter in the limited scheme will activate, reducing the convergence rate towards first order ($p_{\\text{lim}} \\approx 1$), while the unlimited scheme, despite oscillations, may maintain a higher formal order of accuracy in the $L^1$ norm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the one-dimensional linear advection problem\n    using a finite-volume method with MUSCL reconstruction, comparing limited\n    (minmod) and unlimited (centered slope) schemes.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    A = 1.0  # advection speed\n    T_FINAL = 0.5  # final time\n    S = 0.8  # amplitude of the smoothed discontinuity\n    X0 = 0.25  # center of the smoothed discontinuity\n    CFL = 0.45  # Courant-Friedrichs-Lewy number\n    N_VALS = [50, 100, 200, 400]  # grid resolutions\n    DELTA_VALS = [0.1, 0.02, 0.005]  # smoothing widths for tanh\n\n    def initial_condition(x, s_param, x0_param, delta_param):\n        \"\"\"Defines the initial profile g(x).\"\"\"\n        return np.sin(2 * np.pi * x) + s_param * np.tanh((x - x0_param) / delta_param)\n\n    def exact_solution(x, t, a_param, s_param, x0_param, delta_param):\n        \"\"\"Provides the exact solution by advecting the initial profile.\"\"\"\n        # np.mod handles the periodic boundary condition correctly.\n        return initial_condition(np.mod(x - a_param * t, 1.0), s_param, x0_param, delta_param)\n\n    def rhs(u, dx, a_param, limiter_type):\n        \"\"\"\n        Computes the right-hand side of the semi-discrete finite-volume scheme,\n        which represents the spatial operator L(u).\n        \"\"\"\n        # Get neighboring cell values using periodic boundaries via np.roll\n        u_im1 = np.roll(u, 1)\n        u_ip1 = np.roll(u, -1)\n\n        if limiter_type == 'unlimited':\n            # Unlimited scheme: second-order centered difference slope\n            sigma = (u_ip1 - u_im1) / (2.0 * dx)\n        elif limiter_type == 'limited':\n            # Limited scheme: minmod limiter on one-sided slopes\n            # Epsilon to avoid division by zero in sign evaluation for zero slopes\n            epsilon = 1e-12 \n            sigma_fwd = (u_ip1 - u) / dx\n            sigma_bwd = (u - u_im1) / dx\n            \n            # Vectorized minmod implementation\n            # It returns the argument with smaller magnitude if signs match, else 0.\n            signs_match = (np.sign(sigma_fwd + epsilon) == np.sign(sigma_bwd + epsilon))\n            sigma = np.where(signs_match,\n                             np.sign(sigma_fwd) * np.minimum(np.abs(sigma_fwd), np.abs(sigma_bwd)),\n                             0.0)\n        else:\n            raise ValueError(\"Unknown limiter_type.\")\n\n        # Reconstruct values at the left of the i+1/2 interface\n        # This is for flux F*_{i+1/2} which depends on cell i\n        term = u + sigma * dx / 2.0\n        \n        # Flux at the i-1/2 interface depends on cell i-1\n        term_im1 = np.roll(term, 1)\n        \n        # Semi-discrete form: d(u_i)/dt = -1/dx * (F*_{i+1/2} - F*_{i-1/2})\n        # F*_{i+1/2} = a * (u_i + sigma_i * dx/2)\n        # F*_{i-1/2} = a * (u_{i-1} + sigma_{i-1} * dx/2)\n        dudt = -a_param / dx * (term - term_im1)\n        return dudt\n\n    def run_simulation(N, delta, limiter_type):\n        \"\"\"\n        Runs a single simulation for a given grid size, delta, and limiter type.\n        Returns the L1 error at the final time.\n        \"\"\"\n        # Grid setup\n        dx = 1.0 / N\n        x = (np.arange(N) + 0.5) * dx\n\n        # Time step setup\n        dt_cfl = CFL * dx / A\n        # To land exactly on T_FINAL, adjust dt slightly\n        num_steps = int(np.ceil(T_FINAL / dt_cfl))\n        dt = T_FINAL / num_steps\n\n        # Set initial condition from point values at cell centers\n        u = initial_condition(x, S, X0, delta)\n\n        # Time-marching loop using SSP-RK2\n        for _ in range(num_steps):\n            # Stage 1\n            L_u = rhs(u, dx, A, limiter_type)\n            u1 = u + dt * L_u\n            \n            # Stage 2\n            L_u1 = rhs(u1, dx, A, limiter_type)\n            u = 0.5 * u + 0.5 * (u1 + dt * L_u1)\n\n        # Compute L1 error at the final time\n        u_ex = exact_solution(x, T_FINAL, A, S, X0, delta)\n        l1_error = np.sum(np.abs(u - u_ex)) * dx\n        return l1_error\n\n    # List to store the final results\n    all_results = []\n    \n    # Main loop over the test suite\n    for delta in DELTA_VALS:\n        errors_lim = []\n        errors_unlim = []\n        \n        # Run simulations for all grid resolutions\n        for n in N_VALS:\n            errors_lim.append(run_simulation(n, delta, 'limited'))\n            errors_unlim.append(run_simulation(n, delta, 'unlimited'))\n        \n        # Compute observed order of accuracy p using the last refinement pair (N=200, 2N=400)\n        # N=200 corresponds to index -2, N=400 to index -1\n        p_lim = np.log(errors_lim[-2] / errors_lim[-1]) / np.log(2.0)\n        p_unlim = np.log(errors_unlim[-2] / errors_unlim[-1]) / np.log(2.0)\n        \n        # Compute the error ratio R at the finest grid resolution (N=400)\n        R = errors_lim[-1] / errors_unlim[-1]\n        \n        all_results.extend([p_lim, p_unlim, R])\n        \n    # Print the final aggregated results in the specified format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}