{
    "hands_on_practices": [
        {
            "introduction": "在任何显式时间积分的数值模拟中，确定最大稳定时间步长是至关重要的一步。对于移动网格方法，这一计算必须同时考虑流体速度和网格自身的运动速度，以满足著名的Courant-Friedrichs-Lewy (CFL) 条件。这个练习  将指导你如何在一个具体的移动非结构网格上，基于HLL近似黎曼解算器的波速估计，来计算全局允许的时间步长。",
            "id": "3541461",
            "problem": "考虑在多边形控制体集合上，针对可压缩双曲守恒律的二维非结构化移动网格有限体积离散化。假设采用显式时间积分，并基于在局部面坐标系中计算的单元间数值通量的谱半径，采用 Courant-Friedrichs-Lewy (CFL) 稳定性判据。数值通量是使用 Harten-Lax-van Leer (HLL) 近似黎曼求解器构建的，且面信号速度是相对于面法向网格速度来测量的。给定一个包含三个单元的小网格，所有量均以一致的代码单位表示：长度单位为千米，时间单位为秒，速度单位为千米/秒。\n\n三个单元的面积（在二维中作为体积）为：\n- 单元 $1$：$V_{1} = 3.0$\n- 单元 $2$：$V_{2} = 2.4$\n- 单元 $3$：$V_{3} = 2.1$\n\n每个单元具有恒定的速度矢量和局部声速：\n- 单元 $1$：$\\boldsymbol{u}_{1} = (0.8,\\,0.1)$，$c_{1} = 1.5$\n- 单元 $2$：$\\boldsymbol{u}_{2} = (0.2,\\,-0.2)$，$c_{2} = 1.2$\n- 单元 $3$：$\\boldsymbol{u}_{3} = (-0.3,\\,0.6)$，$c_{3} = 1.0$\n\n内部面（单位法向量 $\\boldsymbol{n}_{f}$ 从左侧单元指向右侧单元）具有以下数据，包括面长度 $A_{f}$ 和面法向网格速度 $w_{n,f}$：\n- 单元 $1$（左）和单元 $2$（右）之间的面 $f_{12}$：$A_{f_{12}} = 1.5$，$\\boldsymbol{n}_{12} = (1,\\,0)$，$w_{n,12} = 0.2$。\n- 单元 $2$（左）和单元 $3$（右）之间的面 $f_{23}$：$A_{f_{23}} = 1.0$，$\\boldsymbol{n}_{23} = (0,\\,1)$，$w_{n,23} = -0.1$。\n- 单元 $3$（左）和单元 $1$（右）之间的面 $f_{31}$：$A_{f_{31}} = 1.2$，$\\boldsymbol{n}_{31} = (-1,\\,0)$，$w_{n,31} = 0.05$。\n\n每个单元还有一个边界-面，其透射条件通过设置一个与边界另一側相邻单元内部状态相等的“幽灵”状态来实现。边界-面数据（具有向外的单位法向量和零网格法向速度）如下：\n- 对于单元 $1$：$A_{b,1} = 1.1$，$\\boldsymbol{n}_{b,1} = (0,\\,-1)$，$w_{n,b,1} = 0$。\n- 对于单元 $2$：$A_{b,2} = 1.0$，$\\boldsymbol{n}_{b,2} = (1,\\,0)$，$w_{n,b,2} = 0$。\n- 对于单元 $3$：$A_{b,3} = 0.9$，$\\boldsymbol{n}_{b,3} = (0,\\,1)$，$w_{n,b,3} = 0$。\n\n设 Courant 因子为 $C_{\\mathrm{CFL}} = 0.4$。使用面坐标系中的 Harten-Lax-van Leer (HLL) 波速估计和非结构化网格的标准显式稳定性限制，计算通过取所有单元中的最小值得到的允许的全局时间步长 $\\Delta t$。以秒为单位表示最终结果，并将您的答案四舍五入到四位有效数字。",
            "solution": "首先验证问题，以确保其在科学上成立、适定且客观。逐字提取给定条件。\n- **问题类型**：针对可压缩双曲守恒律的二维非结构化移动网格有限体积离散化。\n- **时间积分**：显式。\n- **稳定性判据**：Courant-Friedrichs-Lewy (CFL)，Courant 因子 $C_{\\mathrm{CFL}} = 0.4$。\n- **数值通量**：Harten-Lax-van Leer (HLL) 近似黎曼求解器，信号速度相对于面法向网格速度。\n- **单元面积**：$V_{1} = 3.0$，$V_{2} = 2.4$，$V_{3} = 2.1$。\n- **单元状态**：\n  - 单元 $1$：$\\boldsymbol{u}_{1} = (0.8,\\,0.1)$，$c_{1} = 1.5$。\n  - 单元 $2$：$\\boldsymbol{u}_{2} = (0.2,\\,-0.2)$，$c_{2} = 1.2$。\n  - 单元 $3$：$\\boldsymbol{u}_{3} = (-0.3,\\,0.6)$，$c_{3} = 1.0$。\n- **内部面**：\n  - $f_{12}$ (单元 $1$ 左，$2$ 右)：$A_{f_{12}} = 1.5$，$\\boldsymbol{n}_{12} = (1,\\,0)$，$w_{n,12} = 0.2$。\n  - $f_{23}$ (单元 $2$ 左，$3$ 右)：$A_{f_{23}} = 1.0$，$\\boldsymbol{n}_{23} = (0,\\,1)$，$w_{n,23} = -0.1$。\n  - $f_{31}$ (单元 $3$ 左，$1$ 右)：$A_{f_{31}} = 1.2$，$\\boldsymbol{n}_{31} = (-1,\\,0)$，$w_{n,31} = 0.05$。\n- **边界-面**：\n  - 单元 $1$：$A_{b,1} = 1.1$，$\\boldsymbol{n}_{b,1} = (0,\\,-1)$，$w_{n,b,1} = 0$。\n  - 单元 $2$：$A_{b,2} = 1.0$，$\\boldsymbol{n}_{b,2} = (1,\\,0)$，$w_{n,b,2} = 0$。\n  - 单元 $3$：$A_{b,3} = 0.9$，$\\boldsymbol{n}_{b,3} = (0,\\,1)$，$w_{n,b,3} = 0$。\n- **边界条件**：透射性，幽灵状态与内部状态相等。\n\n该问题在科学上是合理的，因为它描述了计算天体物理学和流体动力学中的一种标准数值方法。所有必要的数据都已提供，并且没有矛盾之处。问题是适定且客观的。验证成功。\n\n求解过程是计算全局时间步长 $\\Delta t$。对于非结构化网格上的显式格式，每个单元 $i$ 的 CFL 条件由下式给出：\n$$ \\Delta t_i \\le C_{\\mathrm{CFL}} \\frac{V_i}{\\sum_{f \\in \\partial V_i} S_f A_f} $$\n其中 $V_i$ 是单元体积（二维中为面积），$A_f$ 是面面积（二维中为长度），$S_f$ 是垂直于面 $f$ 的最大信号速度。全局时间步长是所有单元中的最小值：$\\Delta t = \\min_i(\\Delta t_i)$。\n\n信号速度 $S_f$ 源自 HLL 波速估计。问题指定这些是在局部面坐标系中，相对于法向网格速度 $w_{n,f}$ 进行评估的。设 $\\boldsymbol{u}_L$ 和 $\\boldsymbol{u}_R$ 为与面 $f$ 相邻的左右单元中的流体速度，$c_L, c_R$ 为声速。法向流体速度为 $u_{n,L} = \\boldsymbol{u}_L \\cdot \\boldsymbol{n}_f$ 和 $u_{n,R} = \\boldsymbol{u}_R \\cdot \\boldsymbol{n}_f$。相对于移动面的流体速度为 $u'_{n,L} = u_{n,L} - w_{n,f}$ 和 $u'_{n,R} = u_{n,R} - w_{n,f}$。\n\n面坐标系中的 HLL 波速估计 ($S'_L, S'_R$) 为：\n$$ S'_L = \\min(u'_{n,L} - c_L, u'_{n,R} - c_R) $$\n$$ S'_R = \\max(u'_{n,L} + c_L, u'_{n,R} + c_R) $$\n面上用于 CFL 计算的最大信号速度是这些相对于坐标系的波速的最大绝对值：\n$$ S_f = \\max(|S'_L|, |S'_R|) $$\n\n对于具有透射条件的边界-面，幽灵状态与内部状态相同。因此，对于单元 $i$ 的一个边界-面，我们有 $L=R=i$。这简化了波速计算：\n$u'_{n,i} = (\\boldsymbol{u}_i \\cdot \\boldsymbol{n}_{b,i}) - w_{n,b,i}$，导致 $S'_L = u'_{n,i} - c_i$ 和 $S'_R = u'_{n,i} + c_i$。\n信号速度是 $S_f = \\max(|u'_{n,i} - c_i|, |u'_{n,i} + c_i|) = |u'_{n,i}| + c_i$。\n\n我们现在系统地计算每个面 $f$ 的 $S_f$。\n\n**1. 内部面**\n\n- **面 $f_{12}$ (L=1, R=2):** $\\boldsymbol{n}_{12}=(1,\\,0)$，$w_{n,12}=0.2$。\n  - $u_{n,L} = \\boldsymbol{u}_1 \\cdot \\boldsymbol{n}_{12} = 0.8$。$u_{n,R} = \\boldsymbol{u}_2 \\cdot \\boldsymbol{n}_{12} = 0.2$。\n  - $u'_{n,L} = 0.8 - 0.2 = 0.6$。$u'_{n,R} = 0.2 - 0.2 = 0.0$。\n  - $c_L = 1.5$，$c_R = 1.2$。\n  - $S'_L = \\min(0.6 - 1.5, 0.0 - 1.2) = \\min(-0.9, -1.2) = -1.2$。\n  - $S'_R = \\max(0.6 + 1.5, 0.0 + 1.2) = \\max(2.1, 1.2) = 2.1$。\n  - $S_{12} = \\max(|-1.2|, |2.1|) = 2.1$。\n\n- **面 $f_{23}$ (L=2, R=3):** $\\boldsymbol{n}_{23}=(0,\\,1)$，$w_{n,23}=-0.1$。\n  - $u_{n,L} = \\boldsymbol{u}_2 \\cdot \\boldsymbol{n}_{23} = -0.2$。$u_{n,R} = \\boldsymbol{u}_3 \\cdot \\boldsymbol{n}_{23} = 0.6$。\n  - $u'_{n,L} = -0.2 - (-0.1) = -0.1$。$u'_{n,R} = 0.6 - (-0.1) = 0.7$。\n  - $c_L = 1.2$，$c_R = 1.0$。\n  - $S'_L = \\min(-0.1 - 1.2, 0.7 - 1.0) = \\min(-1.3, -0.3) = -1.3$。\n  - $S'_R = \\max(-0.1 + 1.2, 0.7 + 1.0) = \\max(1.1, 1.7) = 1.7$。\n  - $S_{23} = \\max(|-1.3|, |1.7|) = 1.7$。\n\n- **面 $f_{31}$ (L=3, R=1):** $\\boldsymbol{n}_{31}=(-1,\\,0)$，$w_{n,31}=0.05$。\n  - $u_{n,L} = \\boldsymbol{u}_3 \\cdot \\boldsymbol{n}_{31} = 0.3$。$u_{n,R} = \\boldsymbol{u}_1 \\cdot \\boldsymbol{n}_{31} = -0.8$。\n  - $u'_{n,L} = 0.3 - 0.05 = 0.25$。$u'_{n,R} = -0.8 - 0.05 = -0.85$。\n  - $c_L = 1.0$，$c_R = 1.5$。\n  - $S'_L = \\min(0.25 - 1.0, -0.85 - 1.5) = \\min(-0.75, -2.35) = -2.35$。\n  - $S'_R = \\max(0.25 + 1.0, -0.85 + 1.5) = \\max(1.25, 0.65) = 1.25$。\n  - $S_{31} = \\max(|-2.35|, |1.25|) = 2.35$。\n\n**2. 边界-面**\n\n- **单元 1 的边界 ($f_{b,1}$):**\n  - $u'_{n,1} = (\\boldsymbol{u}_1 \\cdot \\boldsymbol{n}_{b,1}) - w_{n,b,1} = ((0.8,\\,0.1) \\cdot (0,\\,-1)) - 0 = -0.1$。\n  - $S_{b,1} = |u'_{n,1}| + c_1 = |-0.1| + 1.5 = 1.6$。\n\n- **单元 2 的边界 ($f_{b,2}$):**\n  - $u'_{n,2} = (\\boldsymbol{u}_2 \\cdot \\boldsymbol{n}_{b,2}) - w_{n,b,2} = ((0.2,\\,-0.2) \\cdot (1,\\,0)) - 0 = 0.2$。\n  - $S_{b,2} = |u'_{n,2}| + c_2 = |0.2| + 1.2 = 1.4$。\n\n- **单元 3 的边界 ($f_{b,3}$):**\n  - $u'_{n,3} = (\\boldsymbol{u}_3 \\cdot \\boldsymbol{n}_{b,3}) - w_{n,b,3} = ((-0.3,\\,0.6) \\cdot (0,\\,1)) - 0 = 0.6$。\n  - $S_{b,3} = |u'_{n,3}| + c_3 = |0.6| + 1.0 = 1.6$。\n\n**3. 每个单元的时间步长计算**\n\n- **单元 1：** 面为 $f_{12}, f_{31}, f_{b,1}$。\n  - $\\sum S_f A_f = S_{12} A_{12} + S_{31} A_{31} + S_{b,1} A_{b,1}$\n  - $\\sum S_f A_f = (2.1)(1.5) + (2.35)(1.2) + (1.6)(1.1) = 3.15 + 2.82 + 1.76 = 7.73$。\n  - $\\Delta t_1 = C_{\\mathrm{CFL}} \\frac{V_1}{\\sum S_f A_f} = 0.4 \\times \\frac{3.0}{7.73} = \\frac{1.2}{7.73} \\approx 0.155239$。\n\n- **单元 2：** 面为 $f_{12}, f_{23}, f_{b,2}$。\n  - $\\sum S_f A_f = S_{12} A_{12} + S_{23} A_{23} + S_{b,2} A_{b,2}$\n  - $\\sum S_f A_f = (2.1)(1.5) + (1.7)(1.0) + (1.4)(1.0) = 3.15 + 1.7 + 1.4 = 6.25$。\n  - $\\Delta t_2 = C_{\\mathrm{CFL}} \\frac{V_2}{\\sum S_f A_f} = 0.4 \\times \\frac{2.4}{6.25} = \\frac{0.96}{6.25} = 0.1536$。\n\n- **单元 3：** 面为 $f_{23}, f_{31}, f_{b,3}$。\n  - $\\sum S_f A_f = S_{23} A_{23} + S_{31} A_{31} + S_{b,3} A_{b,3}$\n  - $\\sum S_f A_f = (1.7)(1.0) + (2.35)(1.2) + (1.6)(0.9) = 1.7 + 2.82 + 1.44 = 5.96$。\n  - $\\Delta t_3 = C_{\\mathrm{CFL}} \\frac{V_3}{\\sum S_f A_f} = 0.4 \\times \\frac{2.1}{5.96} = \\frac{0.84}{5.96} \\approx 0.140939$。\n\n**4. 全局时间步长**\n\n全局时间步长是各个单元时间步长的最小值。\n$$ \\Delta t = \\min(\\Delta t_1, \\Delta t_2, \\Delta t_3) = \\min(0.155239..., 0.1536, 0.140939...) = \\Delta t_3 $$\n最严格的时间步长限制来自单元 $3$。\n$$ \\Delta t = \\frac{0.84}{5.96} \\approx 0.140939597... $$\n将结果四舍五入到四位有效数字，得到 $0.1409$。",
            "answer": "$$\n\\boxed{0.1409}\n$$"
        },
        {
            "introduction": "有限体积法的精度在很大程度上取决于其重构步骤的质量，即如何利用单元平均值来近似单元内的解分布。这个练习  提供了一个通过编写代码来比较不同重构方案（线性MUSCL和二次最小二乘）并凭经验验证其精度阶数的实践机会。掌握这种数值实验的方法是开发和验证高精度计算代码的一项基本技能。",
            "id": "3541478",
            "problem": "你需要编写一个完整、可运行的程序，在一个具有周期性边界条件的一维质心 Voronoi 网格上，对一个光滑标量函数，定量比较线性守恒律单调迎风中心格式 (MUSCL) 重构与二次最小二乘重构，并在网格细化下估计观测到的精度阶。\n\n计算域是周期性区间 $[0,1]$。在周期性边界条件下，一维质心 Voronoi 剖分等效于将区间均匀划分为 $N$ 个单元。设单元交界面位于位置 $x_{i+\\frac{1}{2}} = \\frac{i+1}{N}$，单元质心位于 $x_i = \\frac{i+\\frac{1}{2}}{N}$，其中 $i=0,\\dots,N-1$。定义光滑函数\n$$\n\\phi(x) = \\sin(2\\pi x) + 0.1 \\cos(6\\pi x).\n$$\n对于每个网格，取单元中心采样值 $u_i = \\phi(x_i)$。\n\n需要实现的重构方法：\n1. 线性守恒律单调迎风中心格式 (MUSCL) 重构（无限制器）：\n   - 对于每个单元 $i$，使用中心差分计算斜率\n     $$\n     s_i = \\frac{u_{i+1} - u_{i-1}}{x_{i+1} - x_{i-1}},\n     $$\n     其中指数周期性环绕。在右侧交界面 $x_{i+\\frac{1}{2}}$ 处将左态重构为\n     $$\n     u_{i+\\frac{1}{2}}^{-} = u_i + s_i \\left(x_{i+\\frac{1}{2}} - x_i\\right).\n     $$\n2. 二次最小二乘重构：\n   - 对于每个单元 $i$，拟合一个以 $x_i$ 为中心的二次多项式，即\n     $$\n     p_i(\\xi) = a_0 + a_1 \\xi + a_2 \\xi^2,\\quad \\xi = x - x_i,\n     $$\n     通过在对称模板 $\\{i-2,i-1,i,i+1,i+2\\}$ 上使用点样本 $\\{(x_j - x_i,\\;u_j)\\}$ 最小化残差平方和。根据需要对邻居单元的指数使用周期性环绕。通过以下方式计算右侧交界面的左态：\n     $$\n     u_{i+\\frac{1}{2}}^{-} = p_i\\!\\left(x_{i+\\frac{1}{2}} - x_i\\right).\n     $$\n\n对于每个网格，将一个格式的交界面误差定义为从左侧单元重构的左态与交界面处精确函数值之间的差值，\n$$\ne_{i+\\frac{1}{2}} = u_{i+\\frac{1}{2}}^{-} - \\phi\\!\\left(x_{i+\\frac{1}{2}}\\right).\n$$\n计算所有交界面上的均方根 $L^2$ 误差，\n$$\nE = \\left(\\frac{1}{N}\\sum_{i=0}^{N-1} e_{i+\\frac{1}{2}}^2\\right)^{1/2}.\n$$\n对于一系列细化 $N \\to 2N$，观测到的精度阶计算如下\n$$\np = \\frac{\\log\\left(E(N)/E(2N)\\right)}{\\log(2)}.\n$$\n\n从光滑函数的泰勒展开和上述定义的第一性原理出发，目标是凭经验证明，在线性守恒律单调迎风中心格式 (MUSCL) 重构在质心 Voronoi 网格上是二阶精度的，而二次最小二乘重构是三阶精度的。\n\n你的程序必须：\n- 为每个 $N$ 构建网格。\n- 为所有单元计算 $u_i$。\n- 对每种方法，在所有交界面上重构 $u_{i+\\frac{1}{2}}^{-}$，计算误差 $e_{i+\\frac{1}{2}}$ 和均方根 $L^2$ 误差 $E$。\n- 对于每个连续的细化对 $(N,2N)$，计算定义的观测阶 $p$。\n\n测试套件（请精确使用这些网格尺寸）：\n- $N \\in \\{8, 16, 32, 64\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个顶级列表，该列表内含四个列表：\n  - 第一个列表包含线性守恒律单调迎风中心格式 (MUSCL) 方法在 $N=8,16,32,64$ 时的 $L^2$ 误差。\n  - 第二个列表包含二次最小二乘法在 $N=8,16,32,64$ 时的 $L^2$ 误差。\n  - 第三个列表包含线性守恒律单调迎风中心格式 (MUSCL) 方法在对 $(8,16)$、$(16,32)$、$(32,64)$ 时的观测阶。\n  - 第四个列表包含二次最小二乘法在对 $(8,16)$、$(16,32)$、$(32,64)$ 时的观测阶。\n\n例如，程序必须打印类似下面的一行\n$$\n\\big[\\,[E^\\mathrm{lin}_8,E^\\mathrm{lin}_{16},E^\\mathrm{lin}_{32},E^\\mathrm{lin}_{64}],\\;[E^\\mathrm{quad}_8,E^\\mathrm{quad}_{16},E^\\mathrm{quad}_{32},E^\\mathrm{quad}_{64}],\\;[p^\\mathrm{lin}_{8\\to16},p^\\mathrm{lin}_{16\\to32},p^\\mathrm{lin}_{32\\to64}],\\;[p^\\mathrm{quad}_{8\\to16},p^\\mathrm{quad}_{16\\to32},p^\\mathrm{quad}_{32\\to64}]\\,\\big]\n$$\n用实际数值代替符号。\n\n角度单位为弧度。本问题中没有物理单位。所有返回的数值必须是浮点数。代码必须完全自包含，且不得读取输入。",
            "solution": "用户要求在一个一维周期性网格上，对线性的守恒律单调迎风中心格式 (MUSCL) 重构和二次最小二乘重构进行定量比较。这涉及实现这两种格式，在一系列不断细化的网格上计算它们对一个光滑函数的重构误差，并根据这些误差估计每种方法的观测精度阶。这个问题是数值分析中一个适定的练习，对于发展计算天体物理学等领域中使用的高阶有限体积法至关重要。\n\n### 基于原理的设计\n\n问题的核心在于在离散单元内逼近一个光滑函数 $\\phi(x)$，并在单元交界面上评估此逼近。这种交界面重构的精度决定了基于它构建的数值格式的整体精度。我们将分析并实现两种这样的重构方法。\n\n**1. 准备工作：网格与函数**\n\n计算域是周期性区间 $[0,1]$。具有周期性边界条件的一维质心 Voronoi 剖分等效于一个均匀网格。对于 $N$ 个单元，单元宽度为 $\\Delta x = 1/N$。问题定义了单元交界面在 $x_{i+\\frac{1}{2}} = (i+1)/N$，单元质心在 $x_i = (i+\\frac{1}{2})/N$，其中 $i=0, \\dots, N-1$。根据这些定义，第 $i$ 个单元占据区间 $[i/N, (i+1)/N]$，其宽度确实是 $1/N$，且 $x_i$ 是其中心。从单元中心 $x_i$ 到其右交界面 $x_{i+\\frac{1}{2}}$ 的距离是 $x_{i+\\frac{1}{2}} - x_i = (i+1)/N - (i+0.5)/N = 0.5/N = \\Delta x/2$。\n\n光滑测试函数为 $\\phi(x) = \\sin(2\\pi x) + 0.1 \\cos(6\\pi x)$。重构格式可用的精确数据是单元中心的采样值，$u_i = \\phi(x_i)$。\n\n**2. 线性 MUSCL 重构**\n\n该方法在每个单元中构建函数的分段线性逼近，$p_i(x) = u_i + s_i(x-x_i)$。关键是确定斜率 $s_i$。问题指定了一个中心差分公式：\n$$\ns_i = \\frac{u_{i+1} - u_{i-1}}{x_{i+1} - x_{i-1}}\n$$\n其中指数是周期性处理的。在我们的均匀网格上，$x_{i+1} - x_{i-1} = 2\\Delta x$。对于光滑函数 $\\phi(x)$，泰勒展开表明此公式以二阶精度逼近真实导数 $\\phi'(x_i)$：$s_i = \\phi'(x_i) + O(\\Delta x^2)$。\n\n在右交界面 $x_{i+\\frac{1}{2}}$ 处的重构值是该点处线性多项式的求值：\n$$\nu_{i+\\frac{1}{2}}^{-} = u_i + s_i (x_{i+\\frac{1}{2}} - x_i) = u_i + s_i \\frac{\\Delta x}{2}\n$$\n交界面处的误差为 $e_{i+\\frac{1}{2}} = u_{i+\\frac{1}{2}}^{-} - \\phi(x_{i+\\frac{1}{2}})$。为分析此误差，我们使用泰勒级数。\n重构值为：\n$$\nu_{i+\\frac{1}{2}}^{-} = \\phi(x_i) + \\left(\\phi'(x_i) + O(\\Delta x^2)\\right) \\frac{\\Delta x}{2} = \\phi(x_i) + \\phi'(x_i)\\frac{\\Delta x}{2} + O(\\Delta x^3)\n$$\n精确值为：\n$$\n\\phi(x_{i+\\frac{1}{2}}) = \\phi\\left(x_i + \\frac{\\Delta x}{2}\\right) = \\phi(x_i) + \\phi'(x_i)\\frac{\\Delta x}{2} + \\frac{1}{2}\\phi''(x_i)\\left(\\frac{\\Delta x}{2}\\right)^2 + O(\\Delta x^3)\n$$\n交界面误差是这两个表达式之差：\n$$\ne_{i+\\frac{1}{2}} = -\\frac{1}{8}\\phi''(x_i)\\Delta x^2 + O(\\Delta x^3)\n$$\n局部误差为 $O(\\Delta x^2)$ 阶。因此，对网格上这些局部误差求平均的均方根 (RMS) 误差 $E$ 预计是二阶精度的，即 $E \\propto \\Delta x^2$。这预测观测到的精度阶为 $p \\approx 2$。\n\n**3. 二次最小二乘重构**\n\n该方法在每个单元中构建一个分段二次逼近，$p_i(\\xi) = a_0 + a_1 \\xi + a_2 \\xi^2$，其中 $\\xi = x - x_i$。单元 $i$ 的系数 $(a_0, a_1, a_2)$ 是通过对来自对称5点模板 $\\{i-2, i-1, i, i+1, i+2\\}$ 的数据样本 $u_j$ 进行最小二乘拟合来确定的。\n\n这个最小化问题等价于求解一个超定线性系统。对于每个单元 $i$，我们希望找到系数向量 $\\mathbf{c} = [a_0, a_1, a_2]^T$，以最小化 $\\|\\mathbf{A}\\mathbf{c} - \\mathbf{b}\\|_2^2$，其中：\n- $\\mathbf{b} = [u_{i-2}, u_{i-1}, u_i, u_{i+1}, u_{i+2}]^T$ （采用周期性索引）。\n- $\\mathbf{A}$ 是一个 $5 \\times 3$ 的类范德蒙设计矩阵，其行为 $[1, \\xi_k, \\xi_k^2]$，其中 $\\xi_k = (k\\cdot \\Delta x)$，对于 $k \\in \\{-2, -1, 0, 1, 2\\}$。\n标准解由正规方程给出，$\\mathbf{c} = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T \\mathbf{b}$。由于是均匀网格，矩阵 $\\mathbf{A}$ 仅依赖于 $\\Delta x$，而不依赖于单元索引 $i$。因此，伪逆矩阵 $\\mathbf{A}^+ = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T$ 可以对每个网格分辨率 $N$ 只计算一次。\n\n重构的交界面值是在 $\\xi = \\Delta x/2$ 处对此多项式的求值：\n$$\nu_{i+\\frac{1}{2}}^{-} = p_i(\\Delta x/2) = a_0 + a_1\\frac{\\Delta x}{2} + a_2\\left(\\frac{\\Delta x}{2}\\right)^2\n$$\n对于光滑函数，在对称的5点模板上进行这种更高阶的多项式拟合会产生更精确的重构。理论分析表明，得到的交界面误差 $e_{i+\\frac{1}{2}}$ 为 $O(\\Delta x^3)$ 阶。因此，RMS 误差 $E$ 预计是三阶精度的（$E \\propto \\Delta x^3$），预测观测到的精度阶为 $p \\approx 3$。\n\n**4. 实现与验证**\n\n程序将实现这两种格式。对于每个网格分辨率 $N \\in \\{8, 16, 32, 64\\}$，它会计算两种方法的 RMS 误差 $E(N)$。二次重构将通过预先计算设计矩阵的伪逆，并使用向量化操作同时计算所有单元的系数来高效实现。最后，对于每个细化步骤，计算观测到的精度阶 $p = \\log_2(E(N)/E(2N))$。随着网格的细化，数值结果预计将证实线性 MUSCL 的 $p \\to 2$ 和二次最小二乘的 $p \\to 3$ 的理论预测。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares reconstruction errors and observed orders of accuracy\n    for linear MUSCL and quadratic least-squares schemes.\n    \"\"\"\n\n    # Define the smooth scalar function\n    def phi(x):\n        return np.sin(2 * np.pi * x) + 0.1 * np.cos(6 * np.pi * x)\n\n    # Test suite of mesh sizes\n    N_values = [8, 16, 32, 64]\n\n    # Lists to store the final results\n    E_muscl_list = []\n    E_quad_list = []\n    p_muscl_list = []\n    p_quad_list = []\n\n    # Main loop over the mesh sizes\n    for N in N_values:\n        # Define mesh properties\n        dx = 1.0 / N\n        # Cell centroids x_i = (i + 0.5) / N\n        x_centroids = (np.arange(N) + 0.5) / N\n        # Cell interfaces x_{i+1/2} = (i + 1) / N\n        x_interfaces = (np.arange(N) + 1.0) / N\n        \n        # Compute cell-centered samples of the function\n        u = phi(x_centroids)\n\n        # 1. Linear MUSCL Reconstruction (without limiter)\n        # Get neighbor values using periodic wrapping\n        u_ip1 = np.roll(u, -1)\n        u_im1 = np.roll(u, 1)\n\n        # Compute slope s_i = (u_{i+1} - u_{i-1}) / (x_{i+1} - x_{i-1})\n        # For a uniform periodic grid, x_{i+1} - x_{i-1} is always 2*dx\n        s = (u_ip1 - u_im1) / (2.0 * dx)\n\n        # Reconstruct at right interface: u_i + s_i * (x_{i+1/2} - x_i)\n        # The distance to the interface is 0.5*dx\n        dist_to_interface = 0.5 * dx\n        u_recon_muscl = u + s * dist_to_interface\n\n        # 2. Quadratic Least-Squares Reconstruction\n        # Stencil uses 5 points: {i-2, i-1, i, i+1, i+2}\n        # Relative coordinates xi = (x_j - x_i) = k*dx for k in {-2,...,2}\n        xi_stencil = np.array([-2.0, -1.0, 0.0, 1.0, 2.0]) * dx\n        \n        # Build the design matrix A for p(xi) = a0 + a1*xi + a2*xi^2\n        A = np.vstack([np.ones(5), xi_stencil, xi_stencil**2]).T\n\n        # Gather stencil data for all cells using vectorized operations\n        u_im2 = np.roll(u, 2)\n        # u_im1 is already computed\n        u_ip2 = np.roll(u, -2)\n        # u_ip1 is already computed\n        U_stencils = np.vstack([u_im2, u_im1, u, u_ip1, u_ip2]).T\n\n        # Solve for all coefficient vectors at once: C = pinv(A) @ U.T\n        # We need C.T = pinv(A) @ U.T, so C = (pinv(A) @ U.T).T = U @ pinv(A).T\n        Coeffs = U_stencils @ np.linalg.pinv(A).T\n        \n        # Evaluate all polynomials at the right interface (xi = 0.5*dx)\n        xi_interface = 0.5 * dx\n        xi_vec = np.array([1.0, xi_interface, xi_interface**2])\n        u_recon_quad = Coeffs @ xi_vec\n        \n        # 3. Compute Errors\n        # Get exact function values at the interfaces\n        phi_exact_interfaces = phi(x_interfaces)\n        \n        # Compute L2 RMS error for MUSCL\n        error_muscl = u_recon_muscl - phi_exact_interfaces\n        E_muscl = np.sqrt(np.mean(error_muscl**2))\n        E_muscl_list.append(E_muscl)\n        \n        # Compute L2 RMS error for Quadratic LS\n        error_quad = u_recon_quad - phi_exact_interfaces\n        E_quad = np.sqrt(np.mean(error_quad**2))\n        E_quad_list.append(E_quad)\n        \n    # 4. Compute Observed Order of Accuracy\n    for i in range(len(N_values) - 1):\n        # Order p = log(E(N)/E(2N)) / log(2)\n        p_muscl = np.log(E_muscl_list[i] / E_muscl_list[i+1]) / np.log(2)\n        p_muscl_list.append(p_muscl)\n        \n        p_quad = np.log(E_quad_list[i] / E_quad_list[i+1]) / np.log(2)\n        p_quad_list.append(p_quad)\n\n    # Final print statement in the exact required format.\n    results = [E_muscl_list, E_quad_list, p_muscl_list, p_quad_list]\n    print(results)\n\nsolve()\n```"
        },
        {
            "introduction": "高阶格式在提高光滑流解的精度的同时，也可能在激波等间断附近引入非物理的振荡，这一问题在非结构网格的畸变单元上尤为突出。这个高级练习  旨在挑战你从第一性原理出发，推导并实现一个几何感知的斜率限制器，以增强格式在极端情况下的鲁棒性。这种限制器是现代天体物理模拟程序中确保计算结果可靠性的关键技术之一。",
            "id": "3541412",
            "problem": "您的任务是为计算天体物理学中的非结构化、可能移动的网格上的线性重构，设计、推导并实现一个经过鲁棒性测试的斜率限制器。其科学基础是任意拉格朗日-欧拉 (ALE) 框架下的标量守恒律，以及全变差减小 (TVD) 格式所要求的单调性约束。考虑一个标量 $u(\\mathbf{x},t)$，它在一个可以以网格速度 $\\mathbf{w}(\\mathbf{x},t)$ 移动的控制体 $\\Omega(t)$ 上满足守恒律，其积分形式为\n$$\n\\frac{d}{dt}\\int_{\\Omega(t)} u\\,dA + \\int_{\\partial \\Omega(t)}\\left(\\mathbf{F}(u) - u\\,\\mathbf{w}\\right)\\cdot \\mathbf{n}\\,ds = 0,\n$$\n其中 $\\mathbf{F}(u)$ 是通量函数，$\\mathbf{n}$ 是 $\\partial\\Omega(t)$ 上的单位外法向量。为了在二维空间中构建一个以激波为主导的验证场景，我们沿 $x$ 轴使用一维无粘 Burgers 方程，其通量为 $\\mathbf{F}(u) = (u^2/2,\\,0)$。众所周知，该方程可以从光滑的初始数据发展出激波，并且在以黎曼型跳跃作为初值时表现出强间断性。\n\n在一个非结构化多边形网格上，假设每个单元 $C$ 内部的分段线性重构定义为\n$$\nu(\\mathbf{x}) \\approx u_C + \\phi_C\\,\\mathbf{g}_C\\cdot(\\mathbf{x} - \\mathbf{x}_C),\n$$\n其中 $u_C$ 是单元平均值，$\\mathbf{x}_C$ 是一个选定的代表点（例如，形心或生成点），$\\mathbf{g}_C$ 是通过对邻居信息进行最小二乘拟合得到的无约束梯度，而 $\\phi_C\\in[0,1]$ 是一个强制单调性的标量斜率限制器。标准的 TVD 要求是，在每个面心 $\\mathbf{x}_f$ 处的重构值必须位于该单元及其面相邻邻居单元所形成的闭区间内，即：\n$$\nu(\\mathbf{x}_f) \\in \\big[\\min\\{u_C,u_{N_1},\\dots\\},\\,\\max\\{u_C,u_{N_1},\\dots\\}\\big].\n$$\n然而，在极端宽高比的情况下，仅强制面心处的边界约束仍可能因多边形内部距离的巨大变化而在顶点附近产生内部过冲。为解决此问题，定义单元内切圆半径 $R_i$ 为从 $\\mathbf{x}_C$ 到多边形任意边的最小距离，外接圆半径 $R_c$ 为从 $\\mathbf{x}_C$ 到任意顶点的最大距离。您必须推导出一个限制器 $\\phi_\\chi$，其构造应明确且定量地考虑以下比率\n$$\n\\chi \\equiv \\frac{R_c}{R_i},\n$$\n然后验证其在具有极端 $\\chi$ 值的单元上抵抗激波诱发振荡的鲁棒性。\n\n从 ALE 守恒律和 TVD 要求产生的单调性约束出发，推导一个与几何相关的重构边界，该边界保证在每个多边形单元内的面心和顶点处都不会产生新的极值，并用 $R_i$ 和 $R_c$ 表示。推导必须从第一性原理出发：从守恒律、线性重构的定义、基于邻居的单调性区间以及连接 $\\mathbf{x}_C$ 到面和顶点的距离的几何不等式开始。避免使用任何现成的或简化的公式；通过从这些基本元素出发的逻辑步骤来构建该边界。\n\n程序的实现要求：\n- 构建一个二维矩形网格，作为非结构化多边形网格的一个特例（矩形是多边形）。使用单元形心作为 $\\mathbf{x}_C$。对矩形使用精确的内切圆半径和外接圆半径：$R_i$ 是半宽和半高中较小的一个，而 $R_c$ 是从形心到角落的距离。对于一般多边形，您可以将 $R_i$ 计算为从 $\\mathbf{x}_C$ 到每条边线的最小距离，将 $R_c$ 计算为从 $\\mathbf{x}_C$ 到各顶点的最大欧几里得距离。\n- 通过对每个单元的面相邻邻居单元形心处的值进行最小二乘拟合，计算该单元的无约束梯度 $\\mathbf{g}_C$。\n- 每个测试案例实现两种重构：一种使用传统的基于面心的 TVD 限制器，另一种使用您推导的、包含了 $R_i$ 和 $R_c$ 的几何感知限制器 $\\phi_\\chi$。\n- 将以激波为主导的初始条件定义为黎曼型跳跃：\n$$\nu(\\mathbf{x},0) = \\begin{cases}\n1  &\\text{if } x < 0,\\\\\n0  &\\text{if } x \\ge 0.\n\\end{cases}\n$$\n- 为了进行验证，计算每个单元顶点处的最大重构过冲，该过冲是相对于由该单元及其面相邻邻居形成的局部单调性区间而言的。对于一个单元 $C$，设 $u_{\\min,C}$ 和 $u_{\\max,C}$ 分别是 $\\{u_C,u_{N_1},u_{N_2},u_{N_3},u_{N_4}\\}$（仅包括存在的邻居）中的最小值和最大值。对于 $C$ 的每个顶点 $\\mathbf{v}$，计算 $u_\\text{rec}(\\mathbf{v}) = u_C + \\phi\\,\\mathbf{g}_C\\cdot(\\mathbf{v}-\\mathbf{x}_C)$ 并将局部过冲幅度定义为\n$$\n\\delta(\\mathbf{v}) = \\max\\big(0,\\,u_\\text{rec}(\\mathbf{v}) - u_{\\max,C}\\big) + \\max\\big(0,\\,u_{\\min,C}-u_\\text{rec}(\\mathbf{v})\\big).\n$$\n单元的过冲是其所有顶点的 $\\delta(\\mathbf{v})$ 的最大值，而全网格的过冲是所有单元过冲的最大值。为传统限制器和您的 $\\phi_\\chi$ 限制器计算此过冲，并以浮点数形式报告。\n- 测试套件：\n    - 案例 1：$N_x=40$，$N_y=40$，具有单位宽高比（$s_y=1$）的矩形单元，网格速度为零 $\\mathbf{w}=(0,0)$。\n    - 案例 2：$N_x=40$，$N_y=40$，通过垂直压缩（$s_y=0.1$）产生极端宽高比，$\\mathbf{w}=(0,0)$。\n    - 案例 3：$N_x=40$，$N_y=40$，极端宽高比 $s_y=0.1$，并带有一个在 $x$ 方向上恒定的移动网格速度场 $\\mathbf{w}=(0.2,0)$。尽管过冲度量是纯粹基于几何重构的，但包含 $\\mathbf{w}$ 可确保该场景遵循移动网格的背景，同时限制器的鲁棒性仍然是焦点。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含全网格的重构过冲幅度，形式为一个由方括号括起来的逗号分隔列表。该列表必须恰好包含六个浮点数，顺序如下：\n$$\n[\\Delta_\\text{std}^{(1)},\\Delta_\\chi^{(1)},\\Delta_\\text{std}^{(2)},\\Delta_\\chi^{(2)},\\Delta_\\text{std}^{(3)},\\Delta_\\chi^{(3)}],\n$$\n其中 $\\Delta_\\text{std}^{(i)}$ 是案例 $i$ 使用传统基于面心的 TVD 限制器时的过冲幅度，而 $\\Delta_\\chi^{(i)}$ 是案例 $i$ 使用您的几何感知限制器时的过冲幅度。不涉及任何单位，如果内部出现任何角度，则必须以弧度处理。输出应为纯十进制浮点数，不带任何百分号。",
            "solution": "我们从任意拉格朗日-欧拉 (ALE) 框架下的标量守恒律开始。对于一个控制体 $\\Omega(t)$，其边界 $\\partial\\Omega(t)$ 以速度 $\\mathbf{w}$ 移动，守恒方程为\n$$\n\\frac{d}{dt}\\int_{\\Omega(t)} u\\,dA + \\int_{\\partial \\Omega(t)}\\left(\\mathbf{F}(u) - u\\,\\mathbf{w}\\right)\\cdot \\mathbf{n}\\,ds = 0.\n$$\n这体现了通过移动边界的通量必须相对于网格运动来计算。为了进行以激波为主导的验证，我们在二维空间中嵌入一个沿 $x$ 轴的一维 Burgers 通量：\n$$\n\\mathbf{F}(u) = \\left(\\frac{u^2}{2},\\,0\\right),\n$$\n其黎曼型初始条件为当 $x<0$ 时 $u(\\mathbf{x},0)$ 等于 $1$，当 $x\\ge 0$ 时等于 $0$，这确保了在 $x=0$ 处存在一个强间断（激波）。\n\n在一个多边形单元 $C$ 上，我们使用线性重构：\n$$\nu(\\mathbf{x}) \\approx u_C + \\phi_C\\,\\mathbf{g}_C\\cdot(\\mathbf{x}-\\mathbf{x}_C),\n$$\n其中 $u_C$ 是单元平均值，$\\mathbf{x}_C$ 是一个代表点（我们使用形心），$\\mathbf{g}_C$ 是通过最小二乘法获得的无约束梯度，$\\phi_C\\in[0,1]$ 是一个斜率限制器。最小二乘梯度通过最小化下式推导得出：\n$$\nJ(\\mathbf{g}) = \\sum_{k\\in\\mathcal{N}(C)} w_k\\left(u_k - u_C - \\mathbf{g}\\cdot(\\mathbf{x}_k - \\mathbf{x}_C)\\right)^2,\n$$\n其中 $w_k$ 是权重（我们取 $w_k=1$），得到正规方程组\n$$\n\\left(\\sum_k w_k\\,\\mathbf{d}_k\\mathbf{d}_k^\\top\\right)\\mathbf{g} = \\sum_k w_k\\,\\mathbf{d}_k\\,(u_k - u_C),\n$$\n其中 $\\mathbf{d}_k = \\mathbf{x}_k - \\mathbf{x}_C$。如果该对称矩阵可逆，则解为\n$$\n\\mathbf{g} = \\left(\\sum_k w_k\\,\\mathbf{d}_k\\mathbf{d}_k^\\top\\right)^{-1}\\left(\\sum_k w_k\\,\\mathbf{d}_k\\,(u_k - u_C)\\right).\n$$\n\n全变差减小 (TVD) 的单调性要求重构过程不能产生新的极值。一个常见的充分条件是要求面心处的重构值位于该单元及其面相邻邻居单元所张成的区间内。设\n$$\nu_{\\min,C} = \\min\\{u_C,u_{N_1},u_{N_2},u_{N_3},u_{N_4}\\},\\quad u_{\\max,C} = \\max\\{u_C,u_{N_1},u_{N_2},u_{N_3},u_{N_4}\\},\n$$\n其中集合仅包含存在的邻居。对于每个面心 $\\mathbf{x}_f$（其偏移量为 $\\mathbf{d}_f=\\mathbf{x}_f-\\mathbf{x}_C$），单调性要求\n$$\nu_C + \\phi_C\\,\\mathbf{g}_C\\cdot \\mathbf{d}_f \\in [u_{\\min,C},u_{\\max,C}].\n$$\n这导出了传统的基于面心的限制器边界。定义\n$$\n\\Delta_f = \\mathbf{g}_C\\cdot \\mathbf{d}_f.\n$$\n如果 $\\Delta_f>0$，则上界强制要求\n$$\n\\phi_C \\le \\frac{u_{\\max,C}-u_C}{\\Delta_f},\n$$\n如果 $\\Delta_f<0$，则下界强制要求\n$$\n\\phi_C \\le \\frac{u_{\\min,C}-u_C}{\\Delta_f},\n$$\n如果 $\\Delta_f=0$，则该面没有限制。传统的基于面心的限制器使用\n$$\n\\phi_\\text{std} = \\min\\left(1,\\ \\min_f \\phi_f\\right),\n$$\n其中每个 $\\phi_f$ 根据其符号按上述方法计算，并被截断为非负值。\n\n然而，在极端宽高比下，仅约束面心值可能允许在顶点附近出现内部过冲。要理解其原因，考虑一个多边形单元 $C$ 的几何形状，其代表点为 $\\mathbf{x}_C$。定义内切圆半径 $R_i$ 为从 $\\mathbf{x}_C$ 到任意边线的最小距离，外接圆半径 $R_c$ 为从 $\\mathbf{x}_C$ 到任意顶点的最大欧几里得距离。对于单元内任意一点 $\\mathbf{v}$，其与 $\\mathbf{x}_C$ 的距离为 $r=\\|\\mathbf{v}-\\mathbf{x}_C\\|$，线性重构的变化量为\n$$\n|u(\\mathbf{v})-u_C| = |\\phi_C\\,\\mathbf{g}_C\\cdot(\\mathbf{v}-\\mathbf{x}_C)| \\le \\phi_C\\,\\|\\mathbf{g}_C\\|\\,r.\n$$\n面心约束在偏移量 $r$ 与到面的距离相当的位置上限制了 $|u(\\mathbf{x}_f)-u_C|$；最严格的约束由最小的此类 $r$ 控制，即 $R_i$。与此同时，单元内的最大变化可能发生在最远的顶点附近，其距离为 $r=R_c$。如果我们只确保面心处的边界，可能会出现以下情况\n$$\n|u(\\mathbf{x}_f)-u_C|\\le \\Delta_{\\max}\n$$\n对于所有面都成立，但顶点处的变化可能大至\n$$\n|u(\\mathbf{v})-u_C|\\le \\phi_C\\,\\|\\mathbf{g}_C\\|\\,R_c,\n$$\n如果面约束有效地限制了在接近 $R_i$ 的距离上的变化，这个值可能会超出 $\\Delta_{\\max}$ 约 $R_c/R_i$ 倍。这表明，为了不仅在面上，而且在顶点和内部点都保证单调性，我们应该对 $\\phi_C$ 施加一个与以下比率成正比的几何缩减\n$$\n\\chi = \\frac{R_c}{R_i}.\n$$\n\n一个精确的边界可以如下构造。令严格的基于面心的约束被概括为\n$$\n|\\phi_C\\,\\mathbf{g}_C\\cdot \\mathbf{d}_f| \\le \\Delta_{\\max},\n$$\n对所有面成立（其中 $\\Delta_{\\max}$ 由 $u_{\\min,C}$ 和 $u_{\\max,C}$ 以及 $\\mathbf{d}_f$ 的方向隐式确定）。由于 $|\\mathbf{g}_C\\cdot \\mathbf{d}_f|\\le \\|\\mathbf{g}_C\\|\\,\\|\\mathbf{d}_f\\|$ 并且在最坏情况下，对于面有 $\\|\\mathbf{d}_f\\|\\ge R_i$，基于面的约束限制了\n$$\n\\phi_C\\,\\|\\mathbf{g}_C\\|\\,R_i \\lesssim \\Delta_{\\max}.\n$$\n为了保证在 $C$ 内部的任何点，特别是在距离为 $R_c$ 的远顶点处，都有相同的边界，只需强制\n$$\n\\phi_C\\,\\|\\mathbf{g}_C\\|\\,R_c \\le \\Delta_{\\max}.\n$$\n结合两者可得\n$$\n\\phi_C \\le \\frac{R_i}{R_c}\\,\\frac{\\Delta_{\\max}}{\\|\\mathbf{g}_C\\|\\,R_i} \\le \\frac{R_i}{R_c}\\,\\phi_\\text{std}.\n$$\n由于 $\\phi_\\text{std}$ 已经确保了面的边界，强制内部边界的几何感知限制器继承了一个因子为 $R_i/R_c = 1/\\chi$ 的乘法缩减，得到\n$$\n\\phi_\\chi = \\min\\big(\\phi_\\text{std},\\,\\frac{R_i}{R_c}\\big).\n$$\n这个限制器在高度拉伸的单元上抑制了重构强度，从而提供了抵抗顶点附近内部过冲的鲁棒性，同时在单元紧凑（$R_c/R_i$ 接近 $1$）时恢复为标准限制器。\n\n算法步骤：\n- 对每个单元，使用其面相邻邻居计算最小二乘梯度 $\\mathbf{g}_C$。\n- 从该单元及其邻居计算 $u_{\\min,C}$ 和 $u_{\\max,C}$。\n- 对每个面心，计算 $\\Delta_f=\\mathbf{g}_C\\cdot \\mathbf{d}_f$ 并如上推导 $\\phi_f$；形成 $\\phi_\\text{std}=\\min(1,\\min_f\\phi_f)$。\n- 计算 $R_i$ 为从 $\\mathbf{x}_C$ 到每条边线的最小距离，$R_c$ 为到各顶点的最大距离；如果 $R_c=0$ 或最小二乘矩阵是病态的，则设 $\\phi=0$ 以避免除以零或伪重构。\n- 设置 $\\phi_\\chi = \\min(\\phi_\\text{std}, R_i/R_c)$。\n- 为了验证，在每个单元顶点 $\\mathbf{v}$ 处，为 $\\phi_\\text{std}$ 和 $\\phi_\\chi$ 计算 $u_\\text{rec}(\\mathbf{v})$，评估相对于 $[u_{\\min,C},u_{\\max,C}]$ 的过冲度量 $\\delta(\\mathbf{v})$，取所有顶点的最大值，然后取所有单元的最大值，以获得全网格的过冲幅度 $\\Delta_\\text{std}$ 和 $\\Delta_\\chi$。\n\n测试套件和输出：\n- 案例 1：$N_x=40$，$N_y=40$，$s_y=1$，$\\mathbf{w}=(0,0)$。\n- 案例 2：$N_x=40$，$N_y=40$，$s_y=0.1$，$\\mathbf{w}=(0,0)$。\n- 案例 3：$N_x=40$，$N_y=40$，$s_y=0.1$，$\\mathbf{w}=(0.2,0)$。\n\n对每个案例计算并输出六元素列表\n$$\n[\\Delta_\\text{std}^{(1)},\\Delta_\\chi^{(1)},\\Delta_\\text{std}^{(2)},\\Delta_\\chi^{(2)},\\Delta_\\text{std}^{(3)},\\Delta_\\chi^{(3)}].\n$$\n这在一个以激波为主导的场景中验证了，几何感知限制器在极端宽高比单元上减少或消除了内部过冲，同时在形状良好的单元上与标准限制器表现一致。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_rect_mesh(nx, ny, sy=1.0):\n    \"\"\"\n    Build a rectangular grid mesh on [-1,1]x[-sy,sy] with nx*ny cells.\n    Returns:\n        centers: (N,2) array of cell centroids\n        verts: list of arrays of shape (4,2) for the rectangle corners (CCW)\n        faces: list of faces per cell: each face as (face_center, normal, length)\n        neighbors: list of neighbor indices [left, right, bottom, top] or -1 for boundary\n        ri_rc: array of shape (N,2) with (R_in, R_circ) per cell\n    \"\"\"\n    # Domain extents\n    x0, x1 = -1.0, 1.0\n    y0, y1 = -sy, sy\n    dx = (x1 - x0) / nx\n    dy = (y1 - y0) / ny\n\n    centers = []\n    verts = []\n    faces = []\n    neighbors = []\n    ri_rc = []\n    # We'll map cell indices to (i,j), row-major\n    def idx(i, j):\n        return j * nx + i\n\n    for j in range(ny):\n        yc = y0 + (j + 0.5) * dy\n        for i in range(nx):\n            xc = x0 + (i + 0.5) * dx\n            centers.append([xc, yc])\n            # Rectangle corners CCW: bottom-left, bottom-right, top-right, top-left\n            bl = [xc - dx/2, yc - dy/2]\n            br = [xc + dx/2, yc - dy/2]\n            tr = [xc + dx/2, yc + dy/2]\n            tl = [xc - dx/2, yc + dy/2]\n            v = np.array([bl, br, tr, tl], dtype=float)\n            verts.append(v)\n            # Faces: center, outward normal, length. Order: left, right, bottom, top\n            left_center = [xc - dx/2, yc]\n            right_center = [xc + dx/2, yc]\n            bottom_center = [xc, yc - dy/2]\n            top_center = [xc, yc + dy/2]\n            # Normals outward from cell\n            left_normal = [-1.0, 0.0]\n            right_normal = [1.0, 0.0]\n            bottom_normal = [0.0, -1.0]\n            top_normal = [0.0, 1.0]\n            left_len = dy\n            right_len = dy\n            bottom_len = dx\n            top_len = dx\n            fcs = [\n                (np.array(left_center), np.array(left_normal), left_len),\n                (np.array(right_center), np.array(right_normal), right_len),\n                (np.array(bottom_center), np.array(bottom_normal), bottom_len),\n                (np.array(top_center), np.array(top_normal), top_len),\n            ]\n            faces.append(fcs)\n            # Neighbors: left, right, bottom, top\n            nb_left = idx(i-1, j) if i-1 >= 0 else -1\n            nb_right = idx(i+1, j) if i+1 < nx else -1\n            nb_bottom = idx(i, j-1) if j-1 >= 0 else -1\n            nb_top = idx(i, j+1) if j+1 < ny else -1\n            neighbors.append([nb_left, nb_right, nb_bottom, nb_top])\n            # Radii: for rectangle with centroid at center\n            # Inradius = min(dx/2, dy/2), circumradius = distance to corner\n            Ri = min(dx/2.0, dy/2.0)\n            Rc = np.sqrt((dx/2.0)**2 + (dy/2.0)**2)\n            ri_rc.append([Ri, Rc])\n\n    centers = np.array(centers, dtype=float)\n    ri_rc = np.array(ri_rc, dtype=float)\n    return centers, verts, faces, neighbors, ri_rc\n\ndef least_squares_gradient(cell_idx, centers, values, neighbors):\n    \"\"\"\n    Compute least-squares gradient at cell_idx using neighbor centroids.\n    values: array of cell averages\n    Returns gradient vector (2,), and a flag for success.\n    \"\"\"\n    x_c = centers[cell_idx]\n    nb = neighbors[cell_idx]\n    M = np.zeros((2,2), dtype=float)\n    b = np.zeros(2, dtype=float)\n    count = 0\n    for k in nb:\n        if k == -1:\n            continue\n        d = centers[k] - x_c\n        # accumulate\n        M += np.outer(d, d)\n        b += d * (values[k] - values[cell_idx])\n        count += 1\n    # If fewer than 2 neighbors or singular matrix, return zero gradient\n    if count < 2:\n        return np.zeros(2, dtype=float), False\n    # Regularize slightly if singular\n    det = M[0,0]*M[1,1] - M[0,1]*M[1,0]\n    if abs(det) < 1e-14:\n        return np.zeros(2, dtype=float), False\n    g = np.linalg.solve(M, b)\n    return g, True\n\ndef compute_bounds(cell_idx, values, neighbors):\n    \"\"\"\n    Compute min/max bounds from cell and its neighbors.\n    \"\"\"\n    vlist = [values[cell_idx]]\n    for k in neighbors[cell_idx]:\n        if k != -1:\n            vlist.append(values[k])\n    return min(vlist), max(vlist)\n\ndef face_center_offsets(cell_idx, centers, faces):\n    \"\"\"\n    Return offsets from centroid to each face center for the given cell.\n    \"\"\"\n    x_c = centers[cell_idx]\n    offs = []\n    for fc, _, _ in faces[cell_idx]:\n        offs.append(fc - x_c)\n    return offs\n\ndef std_limiter_phi(cell_idx, centers, values, neighbors, faces, g):\n    \"\"\"\n    Conventional face-centered TVD limiter for a cell.\n    \"\"\"\n    umin, umax = compute_bounds(cell_idx, values, neighbors)\n    uc = values[cell_idx]\n    phis = []\n    for d in face_center_offsets(cell_idx, centers, faces):\n        delta = float(np.dot(g, d))\n        if delta > 0:\n            num = umax - uc\n            if delta <= 1e-14:\n                phis.append(1.0)\n            else:\n                phis.append(max(0.0, min(1.0, num / delta)))\n        elif delta < 0:\n            num = umin - uc\n            if delta >= -1e-14:\n                phis.append(1.0)\n            else:\n                phis.append(max(0.0, min(1.0, num / delta)))\n        else:\n            phis.append(1.0)\n    if len(phis) == 0:\n        return 0.0\n    return min(1.0, min(phis))\n\ndef geometry_aware_phi(phi_std, Ri, Rc):\n    \"\"\"\n    Geometry-aware limiter: reduce phi by min(1, Ri/Rc).\n    \"\"\"\n    if Rc <= 1e-14:\n        return 0.0\n    return min(phi_std, Ri / Rc)\n\ndef reconstruct_at_vertices(cell_idx, centers, values, neighbors, verts, phi, g):\n    \"\"\"\n    Compute maximum overshoot at cell vertices relative to local bounds.\n    \"\"\"\n    umin, umax = compute_bounds(cell_idx, values, neighbors)\n    uc = values[cell_idx]\n    x_c = centers[cell_idx]\n    max_overshoot = 0.0\n    for v in verts[cell_idx]:\n        u_rec = uc + phi * float(np.dot(g, (v - x_c)))\n        # Overshoot amplitude relative to [umin,umax]\n        upper_excess = max(0.0, u_rec - umax)\n        lower_excess = max(0.0, umin - u_rec)\n        delta = max(upper_excess, lower_excess)\n        if delta > max_overshoot:\n            max_overshoot = delta\n    return max_overshoot\n\ndef initial_shock_values(centers):\n    \"\"\"\n    Riemann-type initial condition: u=1 if x<0, else 0.\n    \"\"\"\n    u = np.zeros(centers.shape[0], dtype=float)\n    u[centers[:,0] < 0.0] = 1.0\n    return u\n\ndef run_case(nx, ny, sy, w):\n    \"\"\"\n    Build mesh, compute gradients and overshoot metrics for both limiters.\n    Returns: (overshoot_std, overshoot_geo)\n    \"\"\"\n    centers, verts, faces, neighbors, ri_rc = build_rect_mesh(nx, ny, sy)\n    values = initial_shock_values(centers)\n\n    N = centers.shape[0]\n    overs_std = 0.0\n    overs_geo = 0.0\n\n    for c in range(N):\n        g, ok = least_squares_gradient(c, centers, values, neighbors)\n        if not ok:\n            # No gradient information, no overshoot\n            continue\n        phi_std = std_limiter_phi(c, centers, values, neighbors, faces, g)\n        Ri, Rc = ri_rc[c]\n        phi_geo = geometry_aware_phi(phi_std, Ri, Rc)\n        # Evaluate overshoot at vertices\n        ostd = reconstruct_at_vertices(c, centers, values, neighbors, verts, phi_std, g)\n        ogeo = reconstruct_at_vertices(c, centers, values, neighbors, verts, phi_geo, g)\n        if ostd > overs_std:\n            overs_std = ostd\n        if ogeo > overs_geo:\n            overs_geo = ogeo\n    return overs_std, overs_geo\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (nx, ny, sy, w_x, w_y)\n        (40, 40, 1.0, 0.0, 0.0),      # Case 1: compact cells\n        (40, 40, 0.1, 0.0, 0.0),      # Case 2: extreme aspect ratio\n        (40, 40, 0.1, 0.2, 0.0),      # Case 3: extreme aspect + moving mesh velocity\n    ]\n\n    results = []\n    for nx, ny, sy, wx, wy in test_cases:\n        overs_std, overs_geo = run_case(nx, ny, sy, (wx, wy))\n        results.append(overs_std)\n        results.append(overs_geo)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}