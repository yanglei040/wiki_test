{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of any explicit finite-volume simulation is ensuring numerical stability by respecting the Courant-Friedrichs-Lewy (CFL) condition. On a moving, unstructured mesh, this requires carefully combining information about cell geometry, local fluid properties, and mesh velocity to determine the maximum allowable time step. This practice solidifies your understanding of the CFL condition in a modern hydrodynamics code by guiding you through a concrete calculation of the global time step for a small but representative mesh configuration .",
            "id": "3541461",
            "problem": "Consider a two-dimensional unstructured moving-mesh finite-volume discretization for a compressible hyperbolic conservation law on a set of polygonal control volumes. Assume an explicit time integration and adopt the Courant-Friedrichs-Lewy (CFL) stability criterion based on the spectral radius of the intercell numerical flux evaluated in the local face frame. The numerical flux is constructed using the Harten-Lax-van Leer (HLL) approximate Riemann solver, and the face signal velocities are measured relative to the face normal mesh velocity. You are given a small mesh with three cells, with all quantities expressed in consistent code units: lengths in kilometers, time in seconds, and velocities in kilometers per second.\n\nThe three cell areas (serving as volumes in two dimensions) are:\n- Cell $1$: $V_{1} = 3.0$\n- Cell $2$: $V_{2} = 2.4$\n- Cell $3$: $V_{3} = 2.1$\n\nEach cell has a constant velocity vector and local sound speed:\n- Cell $1$: $\\boldsymbol{u}_{1} = (0.8,\\,0.1)$, $c_{1} = 1.5$\n- Cell $2$: $\\boldsymbol{u}_{2} = (0.2,\\,-0.2)$, $c_{2} = 1.2$\n- Cell $3$: $\\boldsymbol{u}_{3} = (-0.3,\\,0.6)$, $c_{3} = 1.0$\n\nInternal faces (with the unit normal $\\boldsymbol{n}_{f}$ pointing from the left cell to the right cell) have the following data, including face length $A_{f}$ and face-normal mesh velocity $w_{n,f}$:\n- Face $f_{12}$ between cell $1$ (left) and cell $2$ (right): $A_{f_{12}} = 1.5$, $\\boldsymbol{n}_{12} = (1,\\,0)$, $w_{n,12} = 0.2$.\n- Face $f_{23}$ between cell $2$ (left) and cell $3$ (right): $A_{f_{23}} = 1.0$, $\\boldsymbol{n}_{23} = (0,\\,1)$, $w_{n,23} = -0.1$.\n- Face $f_{31}$ between cell $3$ (left) and cell $1$ (right): $A_{f_{31}} = 1.2$, $\\boldsymbol{n}_{31} = (-1,\\,0)$, $w_{n,31} = 0.05$.\n\nEach cell also has one boundary face with a transmissive condition implemented via a ghost state equal to the interior state of the adjoining cell across the boundary. The boundary face data (with outward unit normals and zero mesh normal velocity) are:\n- For cell $1$: $A_{b,1} = 1.1$, $\\boldsymbol{n}_{b,1} = (0,\\,-1)$, $w_{n,b,1} = 0$.\n- For cell $2$: $A_{b,2} = 1.0$, $\\boldsymbol{n}_{b,2} = (1,\\,0)$, $w_{n,b,2} = 0$.\n- For cell $3$: $A_{b,3} = 0.9$, $\\boldsymbol{n}_{b,3} = (0,\\,1)$, $w_{n,b,3} = 0$.\n\nLet the Courant factor be $C_{\\mathrm{CFL}} = 0.4$. Using the Harten-Lax-van Leer (HLL) wave speed estimates in the face frame and a standard explicit stability bound for unstructured meshes, compute the allowable global time step $\\Delta t$ obtained by taking the minimum over all cells. Express the final result in seconds, and round your answer to four significant figures.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective. The givens are extracted verbatim.\n- **Problem Type**: A two-dimensional unstructured moving-mesh finite-volume discretization for a compressible hyperbolic conservation law.\n- **Time Integration**: Explicit.\n- **Stability Criterion**: Courant-Friedrichs-Lewy (CFL) with a Courant factor $C_{\\mathrm{CFL}} = 0.4$.\n- **Numerical Flux**: Harten-Lax-van Leer (HLL) approximate Riemann solver, with signal velocities relative to face normal mesh velocity.\n- **Cell Areas**: $V_{1} = 3.0$, $V_{2} = 2.4$, $V_{3} = 2.1$.\n- **Cell States**:\n  - Cell $1$: $\\boldsymbol{u}_{1} = (0.8,\\,0.1)$, $c_{1} = 1.5$.\n  - Cell $2$: $\\boldsymbol{u}_{2} = (0.2,\\,-0.2)$, $c_{2} = 1.2$.\n  - Cell $3$: $\\boldsymbol{u}_{3} = (-0.3,\\,0.6)$, $c_{3} = 1.0$.\n- **Internal Faces**:\n  - $f_{12}$ (Cell $1$ left, $2$ right): $A_{f_{12}} = 1.5$, $\\boldsymbol{n}_{12} = (1,\\,0)$, $w_{n,12} = 0.2$.\n  - $f_{23}$ (Cell $2$ left, $3$ right): $A_{f_{23}} = 1.0$, $\\boldsymbol{n}_{23} = (0,\\,1)$, $w_{n,23} = -0.1$.\n  - $f_{31}$ (Cell $3$ left, $1$ right): $A_{f_{31}} = 1.2$, $\\boldsymbol{n}_{31} = (-1,\\,0)$, $w_{n,31} = 0.05$.\n- **Boundary Faces**:\n  - Cell $1$: $A_{b,1} = 1.1$, $\\boldsymbol{n}_{b,1} = (0,\\,-1)$, $w_{n,b,1} = 0$.\n  - Cell $2$: $A_{b,2} = 1.0$, $\\boldsymbol{n}_{b,2} = (1,\\,0)$, $w_{n,b,2} = 0$.\n  - Cell $3$: $A_{b,3} = 0.9$, $\\boldsymbol{n}_{b,3} = (0,\\,1)$, $w_{n,b,3} = 0$.\n- **Boundary Condition**: Transmissive, with a ghost state equal to the interior state.\n\nThe problem is scientifically sound, as it describes a standard numerical method in computational astrophysics and fluid dynamics. All necessary data are provided, and there are no contradictions. The problem is well-posed and objective. The validation is successful.\n\nThe solution proceeds by computing the global time step $\\Delta t$. For an explicit scheme on an unstructured mesh, the CFL condition for each cell $i$ is given by:\n$$ \\Delta t_i \\le C_{\\mathrm{CFL}} \\frac{V_i}{\\sum_{f \\in \\partial V_i} S_f A_f} $$\nwhere $V_i$ is the cell volume (area in $2$D), $A_f$ is the face area (length in $2$D), and $S_f$ is the maximum signal speed normal to face $f$. The global time step is the minimum over all cells: $\\Delta t = \\min_i(\\Delta t_i)$.\n\nThe signal speed $S_f$ is derived from the HLL wave speed estimates. The problem specifies that these are evaluated in the local face frame, relative to the normal mesh velocity $w_{n,f}$. Let $\\boldsymbol{u}_L$ and $\\boldsymbol{u}_R$ be the fluid velocities and $c_L, c_R$ the sound speeds in the left and right cells adjacent to a face $f$. The normal fluid velocities are $u_{n,L} = \\boldsymbol{u}_L \\cdot \\boldsymbol{n}_f$ and $u_{n,R} = \\boldsymbol{u}_R \\cdot \\boldsymbol{n}_f$. The fluid velocities relative to the moving face are $u'_{n,L} = u_{n,L} - w_{n,f}$ and $u'_{n,R} = u_{n,R} - w_{n,f}$.\n\nThe HLL wave speed estimates in the face frame ($S'_L, S'_R$) are:\n$$ S'_L = \\min(u'_{n,L} - c_L, u'_{n,R} - c_R) $$\n$$ S'_R = \\max(u'_{n,L} + c_L, u'_{n,R} + c_R) $$\nThe maximum signal speed for the CFL calculation at the face is the maximum magnitude of these frame-relative wave speeds:\n$$ S_f = \\max(|S'_L|, |S'_R|) $$\n\nFor boundary faces with a transmissive condition, the ghost state is identical to the interior state. Thus, for a boundary face of cell $i$, we have $L=R=i$. This simplifies the wave speed calculation:\n$u'_{n,i} = (\\boldsymbol{u}_i \\cdot \\boldsymbol{n}_{b,i}) - w_{n,b,i}$, leading to $S'_L = u'_{n,i} - c_i$ and $S'_R = u'_{n,i} + c_i$.\nThe signal speed is $S_f = \\max(|u'_{n,i} - c_i|, |u'_{n,i} + c_i|) = |u'_{n,i}| + c_i$.\n\nWe now systematically compute $S_f$ for each face.\n\n**1. Internal Faces**\n\n- **Face $f_{12}$ (L=1, R=2):** $\\boldsymbol{n}_{12}=(1,\\,0)$, $w_{n,12}=0.2$.\n  - $u_{n,L} = \\boldsymbol{u}_1 \\cdot \\boldsymbol{n}_{12} = 0.8$. $u_{n,R} = \\boldsymbol{u}_2 \\cdot \\boldsymbol{n}_{12} = 0.2$.\n  - $u'_{n,L} = 0.8 - 0.2 = 0.6$. $u'_{n,R} = 0.2 - 0.2 = 0.0$.\n  - $c_L = 1.5$, $c_R = 1.2$.\n  - $S'_L = \\min(0.6 - 1.5, 0.0 - 1.2) = \\min(-0.9, -1.2) = -1.2$.\n  - $S'_R = \\max(0.6 + 1.5, 0.0 + 1.2) = \\max(2.1, 1.2) = 2.1$.\n  - $S_{12} = \\max(|-1.2|, |2.1|) = 2.1$.\n\n- **Face $f_{23}$ (L=2, R=3):** $\\boldsymbol{n}_{23}=(0,\\,1)$, $w_{n,23}=-0.1$.\n  - $u_{n,L} = \\boldsymbol{u}_2 \\cdot \\boldsymbol{n}_{23} = -0.2$. $u_{n,R} = \\boldsymbol{u}_3 \\cdot \\boldsymbol{n}_{23} = 0.6$.\n  - $u'_{n,L} = -0.2 - (-0.1) = -0.1$. $u'_{n,R} = 0.6 - (-0.1) = 0.7$.\n  - $c_L = 1.2$, $c_R = 1.0$.\n  - $S'_L = \\min(-0.1 - 1.2, 0.7 - 1.0) = \\min(-1.3, -0.3) = -1.3$.\n  - $S'_R = \\max(-0.1 + 1.2, 0.7 + 1.0) = \\max(1.1, 1.7) = 1.7$.\n  - $S_{23} = \\max(|-1.3|, |1.7|) = 1.7$.\n\n- **Face $f_{31}$ (L=3, R=1):** $\\boldsymbol{n}_{31}=(-1,\\,0)$, $w_{n,31}=0.05$.\n  - $u_{n,L} = \\boldsymbol{u}_3 \\cdot \\boldsymbol{n}_{31} = 0.3$. $u_{n,R} = \\boldsymbol{u}_1 \\cdot \\boldsymbol{n}_{31} = -0.8$.\n  - $u'_{n,L} = 0.3 - 0.05 = 0.25$. $u'_{n,R} = -0.8 - 0.05 = -0.85$.\n  - $c_L = 1.0$, $c_R = 1.5$.\n  - $S'_L = \\min(0.25 - 1.0, -0.85 - 1.5) = \\min(-0.75, -2.35) = -2.35$.\n  - $S'_R = \\max(0.25 + 1.0, -0.85 + 1.5) = \\max(1.25, 0.65) = 1.25$.\n  - $S_{31} = \\max(|-2.35|, |1.25|) = 2.35$.\n\n**2. Boundary Faces**\n\n- **Boundary of Cell 1 ($f_{b,1}$):**\n  - $u'_{n,1} = (\\boldsymbol{u}_1 \\cdot \\boldsymbol{n}_{b,1}) - w_{n,b,1} = ((0.8,\\,0.1) \\cdot (0,\\,-1)) - 0 = -0.1$.\n  - $S_{b,1} = |u'_{n,1}| + c_1 = |-0.1| + 1.5 = 1.6$.\n\n- **Boundary of Cell 2 ($f_{b,2}$):**\n  - $u'_{n,2} = (\\boldsymbol{u}_2 \\cdot \\boldsymbol{n}_{b,2}) - w_{n,b,2} = ((0.2,\\,-0.2) \\cdot (1,\\,0)) - 0 = 0.2$.\n  - $S_{b,2} = |u'_{n,2}| + c_2 = |0.2| + 1.2 = 1.4$.\n\n- **Boundary of Cell 3 ($f_{b,3}$):**\n  - $u'_{n,3} = (\\boldsymbol{u}_3 \\cdot \\boldsymbol{n}_{b,3}) - w_{n,b,3} = ((-0.3,\\,0.6) \\cdot (0,\\,1)) - 0 = 0.6$.\n  - $S_{b,3} = |u'_{n,3}| + c_3 = |0.6| + 1.0 = 1.6$.\n\n**3. Time Step Calculation for Each Cell**\n\n- **Cell 1:** Faces are $f_{12}, f_{31}, f_{b,1}$.\n  - $\\sum S_f A_f = S_{12} A_{12} + S_{31} A_{31} + S_{b,1} A_{b,1}$\n  - $\\sum S_f A_f = (2.1)(1.5) + (2.35)(1.2) + (1.6)(1.1) = 3.15 + 2.82 + 1.76 = 7.73$.\n  - $\\Delta t_1 = C_{\\mathrm{CFL}} \\frac{V_1}{\\sum S_f A_f} = 0.4 \\times \\frac{3.0}{7.73} = \\frac{1.2}{7.73} \\approx 0.155239$.\n\n- **Cell 2:** Faces are $f_{12}, f_{23}, f_{b,2}$.\n  - $\\sum S_f A_f = S_{12} A_{12} + S_{23} A_{23} + S_{b,2} A_{b,2}$\n  - $\\sum S_f A_f = (2.1)(1.5) + (1.7)(1.0) + (1.4)(1.0) = 3.15 + 1.7 + 1.4 = 6.25$.\n  - $\\Delta t_2 = C_{\\mathrm{CFL}} \\frac{V_2}{\\sum S_f A_f} = 0.4 \\times \\frac{2.4}{6.25} = \\frac{0.96}{6.25} = 0.1536$.\n\n- **Cell 3:** Faces are $f_{23}, f_{31}, f_{b,3}$.\n  - $\\sum S_f A_f = S_{23} A_{23} + S_{31} A_{31} + S_{b,3} A_{b,3}$\n  - $\\sum S_f A_f = (1.7)(1.0) + (2.35)(1.2) + (1.6)(0.9) = 1.7 + 2.82 + 1.44 = 5.96$.\n  - $\\Delta t_3 = C_{\\mathrm{CFL}} \\frac{V_3}{\\sum S_f A_f} = 0.4 \\times \\frac{2.1}{5.96} = \\frac{0.84}{5.96} \\approx 0.140939$.\n\n**4. Global Time Step**\n\nThe global time step is the minimum of the individual cell time steps.\n$$ \\Delta t = \\min(\\Delta t_1, \\Delta t_2, \\Delta t_3) = \\min(0.155239..., 0.1536, 0.140939...) = \\Delta t_3 $$\nThe most restrictive time step is from Cell $3$.\n$$ \\Delta t = \\frac{0.84}{5.96} \\approx 0.140939597... $$\nRounding the result to four significant figures gives $0.1409$.",
            "answer": "$$\n\\boxed{0.1409}\n$$"
        },
        {
            "introduction": "While stability is essential, the ultimate goal of a simulation is accuracy. To move beyond the diffusive nature of first-order schemes, modern codes employ high-order reconstruction techniques, approximating the solution within each cell as a polynomial. This hands-on coding exercise  allows you to implement and compare two common reconstruction methods, demonstrating through numerical experiment how to verify their theoretical order of accuracy—a fundamental skill in numerical methods development.",
            "id": "3541478",
            "problem": "You are to write a complete, runnable program that, on a one-dimensional centroidal Voronoi mesh with periodic boundary conditions, quantitatively compares a linear Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) reconstruction against a quadratic least-squares reconstruction for a smooth scalar function and estimates the observed order of accuracy under mesh refinement.\n\nThe computational domain is the periodic interval $[0,1]$. A centroidal Voronoi tessellation in one dimension with periodic boundary conditions is equivalent to a uniform partition into $N$ cells. Let the cell interfaces be at positions $x_{i+\\frac{1}{2}} = \\frac{i+1}{N}$ and the cell centroids be $x_i = \\frac{i+\\frac{1}{2}}{N}$ for $i=0,\\dots,N-1$. Define the smooth function\n$$\n\\phi(x) = \\sin(2\\pi x) + 0.1 \\cos(6\\pi x).\n$$\nFor each mesh, take the cell-centered samples $u_i = \\phi(x_i)$.\n\nReconstruction methods to implement:\n1. Linear Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) reconstruction without limiting:\n   - For each cell $i$, compute the slope using a centered difference\n     $$\n     s_i = \\frac{u_{i+1} - u_{i-1}}{x_{i+1} - x_{i-1}},\n     $$\n     where indices wrap periodically. Reconstruct the left-state at the right interface $x_{i+\\frac{1}{2}}$ as\n     $$\n     u_{i+\\frac{1}{2}}^{-} = u_i + s_i \\left(x_{i+\\frac{1}{2}} - x_i\\right).\n     $$\n2. Quadratic least-squares reconstruction:\n   - For each cell $i$, fit a quadratic polynomial centered at $x_i$, namely\n     $$\n     p_i(\\xi) = a_0 + a_1 \\xi + a_2 \\xi^2,\\quad \\xi = x - x_i,\n     $$\n     by minimizing the sum of squared residuals over the symmetric stencil $\\{i-2,i-1,i,i+1,i+2\\}$ using the point samples $\\{(x_j - x_i,\\;u_j)\\}$. Use periodic wrapping of indices for neighbors as needed. Evaluate the left-state at the right interface by\n     $$\n     u_{i+\\frac{1}{2}}^{-} = p_i\\!\\left(x_{i+\\frac{1}{2}} - x_i\\right).\n     $$\n\nFor each mesh, define the interface error for a scheme as the difference between the reconstructed left-state from the left cell and the exact function at the interface,\n$$\ne_{i+\\frac{1}{2}} = u_{i+\\frac{1}{2}}^{-} - \\phi\\!\\left(x_{i+\\frac{1}{2}}\\right).\n$$\nCompute the root-mean-square $L^2$ error over all interfaces,\n$$\nE = \\left(\\frac{1}{N}\\sum_{i=0}^{N-1} e_{i+\\frac{1}{2}}^2\\right)^{1/2}.\n$$\nFor a sequence of refinements $N \\to 2N$, the observed order of accuracy is computed as\n$$\np = \\frac{\\log\\left(E(N)/E(2N)\\right)}{\\log(2)}.\n$$\n\nStarting from first principles of Taylor expansion for smooth functions and the definitions above, the goal is to empirically demonstrate that the linear Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) reconstruction is second-order accurate and that the quadratic least-squares reconstruction is third-order accurate on a centroidal Voronoi mesh.\n\nYour program must:\n- Construct the meshes for each $N$.\n- Compute $u_i$ for all cells.\n- For each method, reconstruct $u_{i+\\frac{1}{2}}^{-}$ at all interfaces, compute the error $e_{i+\\frac{1}{2}}$, and the root-mean-square $L^2$ error $E$.\n- For each consecutive refinement pair $(N,2N)$, compute the observed order $p$ as defined.\n\nTest suite (use exactly these mesh sizes):\n- $N \\in \\{8, 16, 32, 64\\}$.\n\nFinal output format:\n- Your program should produce a single line of output containing four lists inside a top-level list:\n  - The first list holds the $L^2$ errors for the linear Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) method at $N=8,16,32,64$.\n  - The second list holds the $L^2$ errors for the quadratic least-squares method at $N=8,16,32,64$.\n  - The third list holds the observed orders for the linear Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) method for the pairs $(8,16)$, $(16,32)$, $(32,64)$.\n  - The fourth list holds the observed orders for the quadratic least-squares method for the pairs $(8,16)$, $(16,32)$, $(32,64)$.\n\nFor example, the program must print a single line like\n$$\n\\big[\\,[E^\\mathrm{lin}_8,E^\\mathrm{lin}_{16},E^\\mathrm{lin}_{32},E^\\mathrm{lin}_{64}],\\;[E^\\mathrm{quad}_8,E^\\mathrm{quad}_{16},E^\\mathrm{quad}_{32},E^\\mathrm{quad}_{64}],\\;[p^\\mathrm{lin}_{8\\to16},p^\\mathrm{lin}_{16\\to32},p^\\mathrm{lin}_{32\\to64}],\\;[p^\\mathrm{quad}_{8\\to16},p^\\mathrm{quad}_{16\\to32},p^\\mathrm{quad}_{32\\to64}]\\,\\big]\n$$\nwith actual numerical values in place of symbols.\n\nAngle units are in radians. There are no physical units in this problem. All returned numerical values must be floats. The code must be entirely self-contained and must not read input.",
            "solution": "The user requests a quantitative comparison between a linear Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) reconstruction and a quadratic least-squares reconstruction on a one-dimensional periodic mesh. This involves implementing both schemes, computing their reconstruction errors for a smooth function on a series of refining meshes, and from these errors, estimating the observed order of accuracy for each method. The problem is a well-posed exercise in numerical analysis, fundamental to the development of high-order finite volume methods used in fields like computational astrophysics.\n\n### Principle-Based Design\n\nThe core of the problem lies in approximating a smooth function $\\phi(x)$ within discrete cells and evaluating this approximation at cell interfaces. The accuracy of this interface reconstruction dictates the overall accuracy of a numerical scheme built upon it. We will analyze and implement two such reconstruction methods.\n\n**1. Preliminaries: Mesh and Function**\n\nThe computational domain is the periodic interval $[0,1]$. A one-dimensional centroidal Voronoi tessellation with periodic boundary conditions is equivalent to a uniform grid. For $N$ cells, the cell width is $\\Delta x = 1/N$. The problem defines cell interfaces at $x_{i+\\frac{1}{2}} = (i+1)/N$ and cell centroids at $x_i = (i+\\frac{1}{2})/N$ for $i=0, \\dots, N-1$. From these definitions, the $i$-th cell occupies the interval $[i/N, (i+1)/N]$, its width is indeed $1/N$, and $x_i$ is its center. The distance from the cell center $x_i$ to its right interface $x_{i+\\frac{1}{2}}$ is $x_{i+\\frac{1}{2}} - x_i = (i+1)/N - (i+0.5)/N = 0.5/N = \\Delta x/2$.\n\nThe smooth test function is $\\phi(x) = \\sin(2\\pi x) + 0.1 \\cos(6\\pi x)$. The exact data available to the reconstruction schemes are the cell-centered samples, $u_i = \\phi(x_i)$.\n\n**2. Linear MUSCL Reconstruction**\n\nThis method constructs a piecewise linear approximation of the function in each cell, $p_i(x) = u_i + s_i(x-x_i)$. The key is to determine the slope $s_i$. The problem specifies a centered difference formula:\n$$\ns_i = \\frac{u_{i+1} - u_{i-1}}{x_{i+1} - x_{i-1}}\n$$\nwhere indices are handled periodically. On our uniform grid, $x_{i+1} - x_{i-1} = 2\\Delta x$. For a smooth function $\\phi(x)$, a Taylor expansion shows that this formula approximates the true derivative $\\phi'(x_i)$ with second-order accuracy: $s_i = \\phi'(x_i) + O(\\Delta x^2)$.\n\nThe reconstructed value at the right interface $x_{i+\\frac{1}{2}}$ is an evaluation of the linear polynomial at that point:\n$$\nu_{i+\\frac{1}{2}}^{-} = u_i + s_i (x_{i+\\frac{1}{2}} - x_i) = u_i + s_i \\frac{\\Delta x}{2}\n$$\nThe error at the interface is $e_{i+\\frac{1}{2}} = u_{i+\\frac{1}{2}}^{-} - \\phi(x_{i+\\frac{1}{2}})$. To analyze this error, we use Taylor series.\nThe reconstructed value is:\n$$\nu_{i+\\frac{1}{2}}^{-} = \\phi(x_i) + \\left(\\phi'(x_i) + O(\\Delta x^2)\\right) \\frac{\\Delta x}{2} = \\phi(x_i) + \\phi'(x_i)\\frac{\\Delta x}{2} + O(\\Delta x^3)\n$$\nThe exact value is:\n$$\n\\phi(x_{i+\\frac{1}{2}}) = \\phi\\left(x_i + \\frac{\\Delta x}{2}\\right) = \\phi(x_i) + \\phi'(x_i)\\frac{\\Delta x}{2} + \\frac{1}{2}\\phi''(x_i)\\left(\\frac{\\Delta x}{2}\\right)^2 + O(\\Delta x^3)\n$$\nThe interface error is the difference between these two expressions:\n$$\ne_{i+\\frac{1}{2}} = -\\frac{1}{8}\\phi''(x_i)\\Delta x^2 + O(\\Delta x^3)\n$$\nThe local error is of order $O(\\Delta x^2)$. Consequently, the root-mean-square (RMS) error $E$, which averages these local errors over the grid, is expected to be second-order accurate, i.e., $E \\propto \\Delta x^2$. This predicts an observed order of accuracy $p \\approx 2$.\n\n**3. Quadratic Least-Squares Reconstruction**\n\nThis method constructs a piecewise quadratic approximation in each cell, $p_i(\\xi) = a_0 + a_1 \\xi + a_2 \\xi^2$, where $\\xi = x - x_i$. The coefficients $(a_0, a_1, a_2)$ for cell $i$ are determined by a least-squares fit to the data samples $u_j$ from a symmetric 5-point stencil $\\{i-2, i-1, i, i+1, i+2\\}$.\n\nThis minimization problem is equivalent to solving an overdetermined linear system. For each cell $i$, we want to find the coefficient vector $\\mathbf{c} = [a_0, a_1, a_2]^T$ that minimizes $\\|\\mathbf{A}\\mathbf{c} - \\mathbf{b}\\|_2^2$, where:\n- $\\mathbf{b} = [u_{i-2}, u_{i-1}, u_i, u_{i+1}, u_{i+2}]^T$ (with periodic indexing).\n- $\\mathbf{A}$ is a $5 \\times 3$ Vandermonde-like design matrix whose rows are $[1, \\xi_k, \\xi_k^2]$, with $\\xi_k = (k\\cdot \\Delta x)$ for $k \\in \\{-2, -1, 0, 1, 2\\}$.\nThe standard solution is given by the normal equations, $\\mathbf{c} = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T \\mathbf{b}$. The matrix $\\mathbf{A}$ depends only on $\\Delta x$, not on the cell index $i$, due to the uniform grid. Thus, the pseudoinverse $\\mathbf{A}^+ = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T$ can be computed once for each grid resolution $N$.\n\nThe reconstructed interface value is the evaluation of this polynomial at $\\xi = \\Delta x/2$:\n$$\nu_{i+\\frac{1}{2}}^{-} = p_i(\\Delta x/2) = a_0 + a_1\\frac{\\Delta x}{2} + a_2\\left(\\frac{\\Delta x}{2}\\right)^2\n$$\nFor a smooth function, this higher-degree polynomial fit over a symmetric stencil yields a more accurate reconstruction. Theoretical analysis shows that the resulting interface error $e_{i+\\frac{1}{2}}$ is of order $O(\\Delta x^3)$. The RMS error $E$ is therefore expected to be third-order accurate ($E \\propto \\Delta x^3$), predicting an observed order of accuracy $p \\approx 3$.\n\n**4. Implementation and Verification**\n\nThe program will implement these two schemes. For each mesh resolution $N \\in \\{8, 16, 32, 64\\}$, it calculates the RMS error $E(N)$ for both methods. The quadratic reconstruction will be implemented efficiently by pre-calculating the pseudoinverse of the design matrix and using vectorized operations to compute the coefficients for all cells simultaneously. Finally, the observed order of accuracy, $p = \\log_2(E(N)/E(2N))$, is computed for each refinement step. The numerical results are expected to confirm the theoretical predictions of $p \\to 2$ for linear MUSCL and $p \\to 3$ for quadratic least-squares as the mesh is refined.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares reconstruction errors and observed orders of accuracy\n    for linear MUSCL and quadratic least-squares schemes.\n    \"\"\"\n\n    # Define the smooth scalar function\n    def phi(x):\n        return np.sin(2 * np.pi * x) + 0.1 * np.cos(6 * np.pi * x)\n\n    # Test suite of mesh sizes\n    N_values = [8, 16, 32, 64]\n\n    # Lists to store the final results\n    E_muscl_list = []\n    E_quad_list = []\n    p_muscl_list = []\n    p_quad_list = []\n\n    # Main loop over the mesh sizes\n    for N in N_values:\n        # Define mesh properties\n        dx = 1.0 / N\n        # Cell centroids x_i = (i + 0.5) / N\n        x_centroids = (np.arange(N) + 0.5) / N\n        # Cell interfaces x_{i+1/2} = (i + 1) / N\n        x_interfaces = (np.arange(N) + 1.0) / N\n        \n        # Compute cell-centered samples of the function\n        u = phi(x_centroids)\n\n        # 1. Linear MUSCL Reconstruction (without limiter)\n        # Get neighbor values using periodic wrapping\n        u_ip1 = np.roll(u, -1)\n        u_im1 = np.roll(u, 1)\n\n        # Compute slope s_i = (u_{i+1} - u_{i-1}) / (x_{i+1} - x_{i-1})\n        # For a uniform periodic grid, x_{i+1} - x_{i-1} is always 2*dx\n        s = (u_ip1 - u_im1) / (2.0 * dx)\n\n        # Reconstruct at right interface: u_i + s_i * (x_{i+1/2} - x_i)\n        # The distance to the interface is 0.5*dx\n        dist_to_interface = 0.5 * dx\n        u_recon_muscl = u + s * dist_to_interface\n\n        # 2. Quadratic Least-Squares Reconstruction\n        # Stencil uses 5 points: {i-2, i-1, i, i+1, i+2}\n        # Relative coordinates xi = (x_j - x_i) = k*dx for k in {-2,...,2}\n        xi_stencil = np.array([-2.0, -1.0, 0.0, 1.0, 2.0]) * dx\n        \n        # Build the design matrix A for p(xi) = a0 + a1*xi + a2*xi^2\n        A = np.vstack([np.ones(5), xi_stencil, xi_stencil**2]).T\n\n        # Gather stencil data for all cells using vectorized operations\n        u_im2 = np.roll(u, 2)\n        # u_im1 is already computed\n        u_ip2 = np.roll(u, -2)\n        # u_ip1 is already computed\n        U_stencils = np.vstack([u_im2, u_im1, u, u_ip1, u_ip2]).T\n\n        # Solve for all coefficient vectors at once: C = pinv(A) @ U.T\n        # We need C.T = pinv(A) @ U.T, so C = (pinv(A) @ U.T).T = U @ pinv(A).T\n        Coeffs = U_stencils @ np.linalg.pinv(A).T\n        \n        # Evaluate all polynomials at the right interface (xi = 0.5*dx)\n        xi_interface = 0.5 * dx\n        xi_vec = np.array([1.0, xi_interface, xi_interface**2])\n        u_recon_quad = Coeffs @ xi_vec\n        \n        # 3. Compute Errors\n        # Get exact function values at the interfaces\n        phi_exact_interfaces = phi(x_interfaces)\n        \n        # Compute L2 RMS error for MUSCL\n        error_muscl = u_recon_muscl - phi_exact_interfaces\n        E_muscl = np.sqrt(np.mean(error_muscl**2))\n        E_muscl_list.append(E_muscl)\n        \n        # Compute L2 RMS error for Quadratic LS\n        error_quad = u_recon_quad - phi_exact_interfaces\n        E_quad = np.sqrt(np.mean(error_quad**2))\n        E_quad_list.append(E_quad)\n        \n    # 4. Compute Observed Order of Accuracy\n    for i in range(len(N_values) - 1):\n        # Order p = log(E(N)/E(2N)) / log(2)\n        p_muscl = np.log(E_muscl_list[i] / E_muscl_list[i+1]) / np.log(2)\n        p_muscl_list.append(p_muscl)\n        \n        p_quad = np.log(E_quad_list[i] / E_quad_list[i+1]) / np.log(2)\n        p_quad_list.append(p_quad)\n\n    # Final print statement in the exact required format.\n    results = [E_muscl_list, E_quad_list, p_muscl_list, p_quad_list]\n    print(results)\n\nsolve()\n```"
        },
        {
            "introduction": "High-order reconstruction can introduce unphysical oscillations near shocks and other discontinuities, a challenge that is managed by applying slope limiters to enforce solution monotonicity. However, standard limiters can prove insufficient on the highly distorted or high-aspect-ratio cells that are common in astrophysical simulations with complex flows or adaptive meshes. This advanced exercise  challenges you to derive and implement a novel, geometry-aware slope limiter that provides enhanced robustness, tackling a real-world problem at the forefront of computational method design.",
            "id": "3541412",
            "problem": "You are to design, derive, and implement a robustness-tested slope limiter for linear reconstruction on an unstructured, possibly moving mesh in computational astrophysics. The scientific base is the scalar conservation law in an Arbitrary Lagrangian-Eulerian (ALE) formulation and monotonicity constraints required by Total Variation Diminishing (TVD) schemes. Consider a scalar quantity $u(\\mathbf{x},t)$ governed by a conservation law on a control volume $\\Omega(t)$ that can move with a mesh velocity $\\mathbf{w}(\\mathbf{x},t)$, with the integral form\n$$\n\\frac{d}{dt}\\int_{\\Omega(t)} u\\,dA + \\int_{\\partial \\Omega(t)}\\left(\\mathbf{F}(u) - u\\,\\mathbf{w}\\right)\\cdot \\mathbf{n}\\,ds = 0,\n$$\nwhere $\\mathbf{F}(u)$ is a flux function and $\\mathbf{n}$ is the outward unit normal on $\\partial\\Omega(t)$. To create a shock-dominated validation scenario embedded in two dimensions, use the one-dimensional inviscid Burgers equation along the $x$-axis, with flux $\\mathbf{F}(u) = (u^2/2,\\,0)$, which is known to develop shocks from smooth initial data, and to be strongly discontinuous when initialized with a Riemann-type jump.\n\nOn an unstructured polygonal mesh, suppose a piecewise-linear reconstruction within each cell $C$ is defined by\n$$\nu(\\mathbf{x}) \\approx u_C + \\phi_C\\,\\mathbf{g}_C\\cdot(\\mathbf{x} - \\mathbf{x}_C),\n$$\nwhere $u_C$ is the cell-average, $\\mathbf{x}_C$ is a chosen representative point (e.g., centroid or generating point), $\\mathbf{g}_C$ is an unconstrained gradient obtained by a least-squares fit to neighbor information, and $\\phi_C\\in[0,1]$ is a scalar slope limiter enforcing monotonicity. The standard TVD requirement is that reconstructed values at each face center $\\mathbf{x}_f$ lie within the closed interval formed by the cell and its face-adjacent neighbors, i.e.,\n$$\nu(\\mathbf{x}_f) \\in \\big[\\min\\{u_C,u_{N_1},\\dots\\},\\,\\max\\{u_C,u_{N_1},\\dots\\}\\big].\n$$\nHowever, under extreme aspect ratios, enforcing only face-center bounds can still produce interior overshoots near vertices due to large variations in distances within the polygon. To address this, define the cell inradius $R_i$ as the minimum distance from $\\mathbf{x}_C$ to any edge of the polygon, and the circumradius $R_c$ as the maximum distance from $\\mathbf{x}_C$ to any vertex. You must derive a limiter $\\phi_\\chi$ whose construction explicitly and quantitatively accounts for the ratio\n$$\n\\chi \\equiv \\frac{R_c}{R_i},\n$$\nand then validate its robustness against shock-induced oscillations over cells with extreme $\\chi$.\n\nStarting from the ALE conservation law and the monotonicity constraints arising from the TVD requirement, derive a geometry-aware bound on the reconstruction that guarantees no new extrema at both face centers and vertices within each polygonal cell, expressed in terms of $R_i$ and $R_c$. The derivation must be done from first principles: begin from the conservation law, the definition of linear reconstruction, the neighbor-based monotonicity intervals, and geometric inequalities linking distances from $\\mathbf{x}_C$ to faces and vertices. Avoid using any pre-packaged or shortcut formulas; construct the bound by logical steps from these elements.\n\nImplementation requirements for the program:\n- Construct a two-dimensional rectangular grid as a specific instance of an unstructured polygon mesh (rectangles are polygons). Use the cell centroid as $\\mathbf{x}_C$. Use the exact inradius and circumradius for rectangles: $R_i$ is the smaller of half-width and half-height, and $R_c$ is the distance from centroid to a corner. For general polygons, you may compute $R_i$ as the minimum distance from $\\mathbf{x}_C$ to each edge line and $R_c$ as the maximum Euclidean distance from $\\mathbf{x}_C$ to vertices.\n- Compute the unconstrained gradient $\\mathbf{g}_C$ in each cell by a least-squares fit to the values in face-adjacent neighbor cell centroids.\n- Implement two reconstructions per test case: one using a conventional face-centered TVD limiter and one using your derived geometry-aware limiter $\\phi_\\chi$ that incorporates $R_i$ and $R_c$.\n- Define the shock-dominated initial condition as a Riemann-type jump:\n$$\nu(\\mathbf{x},0) = \\begin{cases}\n1 & \\text{if } x < 0,\\\\\n0 & \\text{if } x \\ge 0.\n\\end{cases}\n$$\n- For validation, compute the maximum reconstruction overshoot at the vertices of each cell with respect to the local monotonicity interval formed by the cell and its face-adjacent neighbors. For a cell $C$, let $u_{\\min,C}$ and $u_{\\max,C}$ be the minimum and maximum among $\\{u_C,u_{N_1},u_{N_2},u_{N_3},u_{N_4}\\}$ (available neighbors only). For each vertex $\\mathbf{v}$ of $C$, compute $u_\\text{rec}(\\mathbf{v}) = u_C + \\phi\\,\\mathbf{g}_C\\cdot(\\mathbf{v}-\\mathbf{x}_C)$ and define the local overshoot amplitude as\n$$\n\\delta(\\mathbf{v}) = \\max\\big(0,\\,u_\\text{rec}(\\mathbf{v}) - u_{\\max,C}\\big) + \\max\\big(0,\\,u_{\\min,C}-u_\\text{rec}(\\mathbf{v})\\big).\n$$\nThe cell’s overshoot is the maximum of $\\delta(\\mathbf{v})$ over its vertices, and the mesh-wide overshoot is the maximum cell overshoot. Compute this overshoot for both the conventional limiter and your $\\phi_\\chi$ and report them as floats.\n- Test suite:\n    - Case $1$: $N_x=40$, $N_y=40$, rectangular cells with unit aspect scaling ($s_y=1$), and zero mesh velocity $\\mathbf{w}=(0,0)$.\n    - Case $2$: $N_x=40$, $N_y=40$, extreme aspect ratio via vertical compression ($s_y=0.1$), $\\mathbf{w}=(0,0)$.\n    - Case $3$: $N_x=40$, $N_y=40$, extreme aspect ratio $s_y=0.1$, with a moving mesh velocity field constant in $x$ ($\\mathbf{w}=(0.2,0)$). Even though the overshoot metric is purely geometric-reconstruction based, including $\\mathbf{w}$ ensures the scenario adheres to moving-mesh context while the limiter’s robustness remains the focus.\n\nFinal output format:\n- Your program should produce a single line of output containing the mesh-wide reconstruction overshoot amplitudes as a comma-separated list enclosed in square brackets. The list must contain exactly six floats, ordered as\n$$\n[\\Delta_\\text{std}^{(1)},\\Delta_\\chi^{(1)},\\Delta_\\text{std}^{(2)},\\Delta_\\chi^{(2)},\\Delta_\\text{std}^{(3)},\\Delta_\\chi^{(3)}],\n$$\nwhere $\\Delta_\\text{std}^{(i)}$ is the overshoot amplitude using the conventional face-centered TVD limiter for case $i$, and $\\Delta_\\chi^{(i)}$ is the overshoot amplitude using your geometry-aware limiter for case $i$. No units are involved, and all angles, if any arise internally, must be handled in radians. The output should be in plain decimal floats without any percentage sign.",
            "solution": "We begin with the scalar conservation law in an Arbitrary Lagrangian-Eulerian (ALE) formulation. For a control volume $\\Omega(t)$, with boundary $\\partial\\Omega(t)$ moving with velocity $\\mathbf{w}$, the conservation statement is\n$$\n\\frac{d}{dt}\\int_{\\Omega(t)} u\\,dA + \\int_{\\partial \\Omega(t)}\\left(\\mathbf{F}(u) - u\\,\\mathbf{w}\\right)\\cdot \\mathbf{n}\\,ds = 0.\n$$\nThis captures the fact that flux through a moving boundary must be taken relative to the mesh motion. For shock-dominated validation, we embed a one-dimensional Burgers flux along the $x$-axis inside two dimensions:\n$$\n\\mathbf{F}(u) = \\left(\\frac{u^2}{2},\\,0\\right),\n$$\nwith a Riemann-type initial condition $u(\\mathbf{x},0)$ equal to $1$ for $x<0$ and $0$ for $x\\ge 0$, which ensures the presence of a strong discontinuity (shock) at $x=0$.\n\nOn a polygonal cell $C$ we use linear reconstruction,\n$$\nu(\\mathbf{x}) \\approx u_C + \\phi_C\\,\\mathbf{g}_C\\cdot(\\mathbf{x}-\\mathbf{x}_C),\n$$\nwhere $u_C$ is the cell average, $\\mathbf{x}_C$ a representative point (we use the centroid), $\\mathbf{g}_C$ the unconstrained gradient obtained by least squares, and $\\phi_C\\in[0,1]$ a slope limiter. The least-squares gradient is derived by minimizing\n$$\nJ(\\mathbf{g}) = \\sum_{k\\in\\mathcal{N}(C)} w_k\\left(u_k - u_C - \\mathbf{g}\\cdot(\\mathbf{x}_k - \\mathbf{x}_C)\\right)^2,\n$$\nwith weights $w_k$ (we take $w_k=1$), yielding normal equations\n$$\n\\left(\\sum_k w_k\\,\\mathbf{d}_k\\mathbf{d}_k^\\top\\right)\\mathbf{g} = \\sum_k w_k\\,\\mathbf{d}_k\\,(u_k - u_C),\n$$\nwhere $\\mathbf{d}_k = \\mathbf{x}_k - \\mathbf{x}_C$. Provided the symmetric matrix is invertible, the solution is\n$$\n\\mathbf{g} = \\left(\\sum_k w_k\\,\\mathbf{d}_k\\mathbf{d}_k^\\top\\right)^{-1}\\left(\\sum_k w_k\\,\\mathbf{d}_k\\,(u_k - u_C)\\right).\n$$\n\nTotal Variation Diminishing (TVD) monotonicity requires that no new extrema be created by reconstruction. A common sufficient condition is to require reconstructed values at face centers to lie within the interval spanned by the cell and its face-adjacent neighbors. Let\n$$\nu_{\\min,C} = \\min\\{u_C,u_{N_1},u_{N_2},u_{N_3},u_{N_4}\\},\\quad u_{\\max,C} = \\max\\{u_C,u_{N_1},u_{N_2},u_{N_3},u_{N_4}\\},\n$$\nwhere the set includes only existing neighbors. For each face center $\\mathbf{x}_f$ with offset $\\mathbf{d}_f=\\mathbf{x}_f-\\mathbf{x}_C$, monotonicity demands\n$$\nu_C + \\phi_C\\,\\mathbf{g}_C\\cdot \\mathbf{d}_f \\in [u_{\\min,C},u_{\\max,C}].\n$$\nThis leads to the conventional face-centered limiter bounds. Define\n$$\n\\Delta_f = \\mathbf{g}_C\\cdot \\mathbf{d}_f.\n$$\nIf $\\Delta_f>0$ then the upper bound enforces\n$$\n\\phi_C \\le \\frac{u_{\\max,C}-u_C}{\\Delta_f},\n$$\nand if $\\Delta_f<0$ then the lower bound enforces\n$$\n\\phi_C \\le \\frac{u_{\\min,C}-u_C}{\\Delta_f},\n$$\nand if $\\Delta_f=0$ there is no restriction from that face. The conventional face-centered limiter uses\n$$\n\\phi_\\text{std} = \\min\\left(1,\\ \\min_f \\phi_f\\right),\n$$\nwhere each $\\phi_f$ is computed as above for its sign and clipped to be nonnegative.\n\nUnder extreme aspect ratios, however, constraining only face-center values can allow interior overshoot near vertices. To see why, consider the geometry of a polygonal cell $C$ with representative point $\\mathbf{x}_C$. Define the inradius $R_i$ as the minimum distance from $\\mathbf{x}_C$ to any edge line, and the circumradius $R_c$ as the maximum Euclidean distance from $\\mathbf{x}_C$ to any vertex. For any vector $\\mathbf{v}$ inside the cell at distance $r=\\|\\mathbf{v}-\\mathbf{x}_C\\|$ from $\\mathbf{x}_C$, the linear reconstruction varies by\n$$\n|u(\\mathbf{v})-u_C| = |\\phi_C\\,\\mathbf{g}_C\\cdot(\\mathbf{v}-\\mathbf{x}_C)| \\le \\phi_C\\,\\|\\mathbf{g}_C\\|\\,r.\n$$\nFace-center constraints bound $|u(\\mathbf{x}_f)-u_C|$ at offsets with $r$ comparable to the distance to faces; the harshest bound is controlled by the smallest such $r$, namely $R_i$. Meanwhile, the largest variation inside the cell can occur near the farthest vertex at $r=R_c$. If we only ensure face-center bounds, it is possible that\n$$\n|u(\\mathbf{x}_f)-u_C|\\le \\Delta_{\\max}\n$$\nfor all faces, yet the variation at a vertex could be as large as\n$$\n|u(\\mathbf{v})-u_C|\\le \\phi_C\\,\\|\\mathbf{g}_C\\|\\,R_c,\n$$\nwhich may exceed $\\Delta_{\\max}$ by a factor of approximately $R_c/R_i$ if the face constraints effectively restrict variations at distances near $R_i$. This suggests that to guarantee monotonicity not just at faces but also at vertices and interior points, we should impose a geometric reduction on $\\phi_C$ proportional to the ratio\n$$\n\\chi = \\frac{R_c}{R_i}.\n$$\n\nA precise bound can be constructed as follows. Let the strict face-centered constraint be encapsulated by\n$$\n|\\phi_C\\,\\mathbf{g}_C\\cdot \\mathbf{d}_f| \\le \\Delta_{\\max},\n$$\nfor all faces (with $\\Delta_{\\max}$ implicitly determined by $u_{\\min,C}$ and $u_{\\max,C}$, and directions of $\\mathbf{d}_f$). Since $|\\mathbf{g}_C\\cdot \\mathbf{d}_f|\\le \\|\\mathbf{g}_C\\|\\,\\|\\mathbf{d}_f\\|$ and for faces $\\|\\mathbf{d}_f\\|\\ge R_i$ in the worst case, face-based constraints bound\n$$\n\\phi_C\\,\\|\\mathbf{g}_C\\|\\,R_i \\lesssim \\Delta_{\\max}.\n$$\nTo guarantee the same bound at any point inside $C$, in particular at a far vertex with distance $R_c$, it suffices to enforce\n$$\n\\phi_C\\,\\|\\mathbf{g}_C\\|\\,R_c \\le \\Delta_{\\max}.\n$$\nCombining the two yields\n$$\n\\phi_C \\le \\frac{R_i}{R_c}\\,\\frac{\\Delta_{\\max}}{\\|\\mathbf{g}_C\\|\\,R_i} \\le \\frac{R_i}{R_c}\\,\\phi_\\text{std}.\n$$\nSince $\\phi_\\text{std}$ already ensures face bounds, the geometry-aware limiter that enforces interior bounds inherits a multiplicative reduction by the factor $R_i/R_c = 1/\\chi$, producing\n$$\n\\phi_\\chi = \\min\\big(\\phi_\\text{std},\\,\\frac{R_i}{R_c}\\big).\n$$\nThis limiter suppresses reconstruction strength on highly elongated cells, providing robustness against interior overshoots near vertices, while reverting to the standard limiter when the cell is compact ($R_c/R_i$ close to $1$).\n\nAlgorithmic steps:\n- For each cell, compute the least-squares gradient $\\mathbf{g}_C$ using its face-adjacent neighbors.\n- Compute $u_{\\min,C}$ and $u_{\\max,C}$ from the cell and neighbors.\n- For each face center, compute $\\Delta_f=\\mathbf{g}_C\\cdot \\mathbf{d}_f$ and derive $\\phi_f$ as above; form $\\phi_\\text{std}=\\min(1,\\min_f\\phi_f)$.\n- Compute $R_i$ as the minimum distance from $\\mathbf{x}_C$ to each edge line and $R_c$ as the maximum distance to vertices; if $R_c=0$ or the least-squares matrix is ill-conditioned, set $\\phi=0$ to avoid division by zero or spurious reconstructions.\n- Set $\\phi_\\chi = \\min(\\phi_\\text{std}, R_i/R_c)$.\n- For validation, at each cell vertex $\\mathbf{v}$ compute $u_\\text{rec}(\\mathbf{v})$ for both $\\phi_\\text{std}$ and $\\phi_\\chi$, evaluate the overshoot measure $\\delta(\\mathbf{v})$ relative to $[u_{\\min,C},u_{\\max,C}]$, take the maximum over vertices and then over all cells to obtain mesh-wide overshoot amplitudes $\\Delta_\\text{std}$ and $\\Delta_\\chi$.\n\nTest suite and output:\n- Case $1$: $N_x=40$, $N_y=40$, $s_y=1$, $\\mathbf{w}=(0,0)$.\n- Case $2$: $N_x=40$, $N_y=40$, $s_y=0.1$, $\\mathbf{w}=(0,0)$.\n- Case $3$: $N_x=40$, $N_y=40$, $s_y=0.1$, $\\mathbf{w}=(0.2,0)$.\n\nFor each case compute and output the six-element list\n$$\n[\\Delta_\\text{std}^{(1)},\\Delta_\\chi^{(1)},\\Delta_\\text{std}^{(2)},\\Delta_\\chi^{(2)},\\Delta_\\text{std}^{(3)},\\Delta_\\chi^{(3)}].\n$$\nThis validates, in a shock-dominated scenario, that the geometry-aware limiter reduces or eliminates interior overshoots on extreme-aspect-ratio cells, while matching the standard limiter on well-shaped cells.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_rect_mesh(nx, ny, sy=1.0):\n    \"\"\"\n    Build a rectangular grid mesh on [-1,1]x[-sy,sy] with nx*ny cells.\n    Returns:\n        centers: (N,2) array of cell centroids\n        verts: list of arrays of shape (4,2) for the rectangle corners (CCW)\n        faces: list of faces per cell: each face as (face_center, normal, length)\n        neighbors: list of neighbor indices [left, right, bottom, top] or -1 for boundary\n        ri_rc: array of shape (N,2) with (R_in, R_circ) per cell\n    \"\"\"\n    # Domain extents\n    x0, x1 = -1.0, 1.0\n    y0, y1 = -sy, sy\n    dx = (x1 - x0) / nx\n    dy = (y1 - y0) / ny\n\n    centers = []\n    verts = []\n    faces = []\n    neighbors = []\n    ri_rc = []\n    # We'll map cell indices to (i,j), row-major\n    def idx(i, j):\n        return j * nx + i\n\n    for j in range(ny):\n        yc = y0 + (j + 0.5) * dy\n        for i in range(nx):\n            xc = x0 + (i + 0.5) * dx\n            centers.append([xc, yc])\n            # Rectangle corners CCW: bottom-left, bottom-right, top-right, top-left\n            bl = [xc - dx/2, yc - dy/2]\n            br = [xc + dx/2, yc - dy/2]\n            tr = [xc + dx/2, yc + dy/2]\n            tl = [xc - dx/2, yc + dy/2]\n            v = np.array([bl, br, tr, tl], dtype=float)\n            verts.append(v)\n            # Faces: center, outward normal, length. Order: left, right, bottom, top\n            left_center = [xc - dx/2, yc]\n            right_center = [xc + dx/2, yc]\n            bottom_center = [xc, yc - dy/2]\n            top_center = [xc, yc + dy/2]\n            # Normals outward from cell\n            left_normal = [-1.0, 0.0]\n            right_normal = [1.0, 0.0]\n            bottom_normal = [0.0, -1.0]\n            top_normal = [0.0, 1.0]\n            left_len = dy\n            right_len = dy\n            bottom_len = dx\n            top_len = dx\n            fcs = [\n                (np.array(left_center), np.array(left_normal), left_len),\n                (np.array(right_center), np.array(right_normal), right_len),\n                (np.array(bottom_center), np.array(bottom_normal), bottom_len),\n                (np.array(top_center), np.array(top_normal), top_len),\n            ]\n            faces.append(fcs)\n            # Neighbors: left, right, bottom, top\n            nb_left = idx(i-1, j) if i-1 >= 0 else -1\n            nb_right = idx(i+1, j) if i+1  nx else -1\n            nb_bottom = idx(i, j-1) if j-1 >= 0 else -1\n            nb_top = idx(i, j+1) if j+1  ny else -1\n            neighbors.append([nb_left, nb_right, nb_bottom, nb_top])\n            # Radii: for rectangle with centroid at center\n            # Inradius = min(dx/2, dy/2), circumradius = distance to corner\n            Ri = min(dx/2.0, dy/2.0)\n            Rc = np.sqrt((dx/2.0)**2 + (dy/2.0)**2)\n            ri_rc.append([Ri, Rc])\n\n    centers = np.array(centers, dtype=float)\n    ri_rc = np.array(ri_rc, dtype=float)\n    return centers, verts, faces, neighbors, ri_rc\n\ndef least_squares_gradient(cell_idx, centers, values, neighbors):\n    \"\"\"\n    Compute least-squares gradient at cell_idx using neighbor centroids.\n    values: array of cell averages\n    Returns gradient vector (2,), and a flag for success.\n    \"\"\"\n    x_c = centers[cell_idx]\n    nb = neighbors[cell_idx]\n    M = np.zeros((2,2), dtype=float)\n    b = np.zeros(2, dtype=float)\n    count = 0\n    for k in nb:\n        if k == -1:\n            continue\n        d = centers[k] - x_c\n        # accumulate\n        M += np.outer(d, d)\n        b += d * (values[k] - values[cell_idx])\n        count += 1\n    # If fewer than 2 neighbors or singular matrix, return zero gradient\n    if count  2:\n        return np.zeros(2, dtype=float), False\n    # Regularize slightly if singular\n    det = M[0,0]*M[1,1] - M[0,1]*M[1,0]\n    if abs(det)  1e-14:\n        return np.zeros(2, dtype=float), False\n    g = np.linalg.solve(M, b)\n    return g, True\n\ndef compute_bounds(cell_idx, values, neighbors):\n    \"\"\"\n    Compute min/max bounds from cell and its neighbors.\n    \"\"\"\n    vlist = [values[cell_idx]]\n    for k in neighbors[cell_idx]:\n        if k != -1:\n            vlist.append(values[k])\n    return min(vlist), max(vlist)\n\ndef face_center_offsets(cell_idx, centers, faces):\n    \"\"\"\n    Return offsets from centroid to each face center for the given cell.\n    \"\"\"\n    x_c = centers[cell_idx]\n    offs = []\n    for fc, _, _ in faces[cell_idx]:\n        offs.append(fc - x_c)\n    return offs\n\ndef std_limiter_phi(cell_idx, centers, values, neighbors, faces, g):\n    \"\"\"\n    Conventional face-centered TVD limiter for a cell.\n    \"\"\"\n    umin, umax = compute_bounds(cell_idx, values, neighbors)\n    uc = values[cell_idx]\n    phis = []\n    for d in face_center_offsets(cell_idx, centers, faces):\n        delta = float(np.dot(g, d))\n        if delta > 0:\n            num = umax - uc\n            if delta = 1e-14:\n                phis.append(1.0)\n            else:\n                phis.append(max(0.0, min(1.0, num / delta)))\n        elif delta  0:\n            num = umin - uc\n            if delta >= -1e-14:\n                phis.append(1.0)\n            else:\n                phis.append(max(0.0, min(1.0, num / delta)))\n        else:\n            phis.append(1.0)\n    if len(phis) == 0:\n        return 0.0\n    return min(1.0, min(phis))\n\ndef geometry_aware_phi(phi_std, Ri, Rc):\n    \"\"\"\n    Geometry-aware limiter: reduce phi by min(1, Ri/Rc).\n    \"\"\"\n    if Rc = 1e-14:\n        return 0.0\n    return min(phi_std, Ri / Rc)\n\ndef reconstruct_at_vertices(cell_idx, centers, values, neighbors, verts, phi, g):\n    \"\"\"\n    Compute maximum overshoot at cell vertices relative to local bounds.\n    \"\"\"\n    umin, umax = compute_bounds(cell_idx, values, neighbors)\n    uc = values[cell_idx]\n    x_c = centers[cell_idx]\n    max_overshoot = 0.0\n    for v in verts[cell_idx]:\n        u_rec = uc + phi * float(np.dot(g, (v - x_c)))\n        # Overshoot amplitude relative to [umin,umax]\n        upper_excess = max(0.0, u_rec - umax)\n        lower_excess = max(0.0, umin - u_rec)\n        delta = max(upper_excess, lower_excess)\n        if delta > max_overshoot:\n            max_overshoot = delta\n    return max_overshoot\n\ndef initial_shock_values(centers):\n    \"\"\"\n    Riemann-type initial condition: u=1 if x0, else 0.\n    \"\"\"\n    u = np.zeros(centers.shape[0], dtype=float)\n    u[centers[:,0]  0.0] = 1.0\n    return u\n\ndef run_case(nx, ny, sy, w):\n    \"\"\"\n    Build mesh, compute gradients and overshoot metrics for both limiters.\n    Returns: (overshoot_std, overshoot_geo)\n    \"\"\"\n    centers, verts, faces, neighbors, ri_rc = build_rect_mesh(nx, ny, sy)\n    values = initial_shock_values(centers)\n\n    N = centers.shape[0]\n    overs_std = 0.0\n    overs_geo = 0.0\n\n    for c in range(N):\n        g, ok = least_squares_gradient(c, centers, values, neighbors)\n        if not ok:\n            # No gradient information, no overshoot\n            continue\n        phi_std = std_limiter_phi(c, centers, values, neighbors, faces, g)\n        Ri, Rc = ri_rc[c]\n        phi_geo = geometry_aware_phi(phi_std, Ri, Rc)\n        # Evaluate overshoot at vertices\n        ostd = reconstruct_at_vertices(c, centers, values, neighbors, verts, phi_std, g)\n        ogeo = reconstruct_at_vertices(c, centers, values, neighbors, verts, phi_geo, g)\n        if ostd > overs_std:\n            overs_std = ostd\n        if ogeo > overs_geo:\n            overs_geo = ogeo\n    return overs_std, overs_geo\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (nx, ny, sy, w_x, w_y)\n        (40, 40, 1.0, 0.0, 0.0),      # Case 1: compact cells\n        (40, 40, 0.1, 0.0, 0.0),      # Case 2: extreme aspect ratio\n        (40, 40, 0.1, 0.2, 0.0),      # Case 3: extreme aspect + moving mesh velocity\n    ]\n\n    results = []\n    for nx, ny, sy, wx, wy in test_cases:\n        overs_std, overs_geo = run_case(nx, ny, sy, (wx, wy))\n        results.append(overs_std)\n        results.append(overs_geo)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}