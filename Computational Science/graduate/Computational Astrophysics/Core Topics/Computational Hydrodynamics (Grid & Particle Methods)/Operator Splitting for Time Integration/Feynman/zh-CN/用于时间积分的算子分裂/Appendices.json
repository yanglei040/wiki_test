{
    "hands_on_practices": [
        {
            "introduction": "理论的优美常常在于其简洁性，但只有通过实践，我们才能真正领会其深刻内涵。算符分裂的误差结构由Baker–Campbell–Hausdorff (BCH) 公式给出，其中涉及复杂的嵌套交换子。为了直观地感受这一理论误差，我们可以从一个简单而基础的物理系统——谐振子——入手。本练习将通过比较两种不同的对称分裂格式（$S_{ABA}$ 和 $S_{BAB}$）的计算结果，构建一个数值诊断工具，它能让我们直接“看到”并估计出三阶分裂误差的大小，从而将抽象的数学公式与具体的计算结果联系起来。",
            "id": "3527516",
            "problem": "考虑一个源自牛顿第二定律的一维谐振子，其中质量为 $m$ 的质点遵循 $m\\,\\frac{d^2 x}{dt^2} = -k\\,x$。引入角频率 $\\omega = \\sqrt{k/m}$，使用位置 $x$ 和速度 $v$ 的相空间表述为 $dx/dt = v$ 和 $dv/dt = -\\omega^2 x$。在算符分裂语言中，定义两个作用于相空间状态 $y = (x,v)$ 的时间演化算符 $A$ 和 $B$ 如下：算符 $A$ 编码运动学漂移 $dx/dt = v$, $dv/dt = 0$；算符 $B$ 编码恢复力冲击 $dx/dt = 0$, $dv/dt = -\\omega^2 x$。由 $A$ 在时间增量 $\\Delta t$ 内生成的精确流将 $(x,v)$ 映射到 $(x+\\Delta t\\,v,\\,v)$，由 $B$ 在 $\\Delta t$ 内生成的精确流将 $(x,v)$ 映射到 $(x,\\,v-\\Delta t\\,\\omega^2 x)$。对称二阶 (Strang) 组合由在 $\\Delta t$ 上的两个宏观步定义：$ABA$ 组合 $S_{ABA}(\\Delta t) = \\exp(\\frac{\\Delta t}{2}A)\\exp(\\Delta t\\,B)\\exp(\\frac{\\Delta t}{2}A)$ 和 $BAB$ 组合 $S_{BAB}(\\Delta t) = \\exp(\\frac{\\Delta t}{2}B)\\exp(\\Delta t\\,A)\\exp(\\frac{\\Delta t}{2}B)$。\n\n您的任务是实现一个诊断工具，对于给定的初始条件和参数，从相同的初始状态使用 $S_{ABA}$ 和 $S_{BAB}$ 执行单个宏观步，并利用两个最终状态的差异来估计在算符分裂误差的 Baker–Campbell–Hausdorff 分析中出现的三阶误差项 $\\Delta t^3\\left([A,[A,B]]+[B,[B,A]]\\right)$ 的大小。此处 $[X,Y]$ 表示李括号 $[X,Y] = XY - YX$。该诊断工具必须报告一个具有物理意义并以米为单位表示的标量大小。为避免混合物理量纲，将状态差异 $(\\Delta x, \\Delta v)$ 的相空间度量定义为欧几里得范数，其中速度使用 $\\omega$ 转换为等效长度尺度，即 $\\|\\!(\\Delta x,\\Delta v)\\!\\|_* = \\sqrt{(\\Delta x)^2 + (\\Delta v/\\omega)^2}$，其单位为米。所要求的估计量是通过 $S_{ABA}$ 和 $S_{BAB}$ 在一个宏观步上的结果差异以及上述度量获得的向量 $\\Delta t^3\\left([A,[A,B]]+[B,[B,A]]\\right)y$ 的标量大小。您必须推导并使用正确的比例常数，该常数将此系统中 $S_{ABA}$ 与 $S_{BAB}$ 的差异与 $\\Delta t^3\\left([A,[A,B]]+[B,[B,A]]\\right)$ 联系起来。\n\n实现一个可运行的完整程序，该程序：\n- 编码在任何时间子步上 $A$ 和 $B$ 的精确流。\n- 为大小为 $\\Delta t$ 的单个步骤构建 $S_{ABA}$ 和 $S_{BAB}$ 宏观步。\n- 计算所得状态的差异，并使用度量 $\\|\\cdot\\|_*$ 将其转换为 $\\Delta t^3\\left([A,[A,B]]+[B,[B,A]]\\right)y$ 的大小估计值（以米为单位）。\n\n使用以下测试套件，其中每个案例是一个元组 $(\\omega, \\Delta t, x_0, v_0)$，$\\omega$ 的单位是弧度/秒，$\\Delta t$ 的单位是秒， $x_0$ 的单位是米， $v_0$ 的单位是米/秒：\n1. $(1.0,\\,0.1,\\,1.0,\\,0.0)$\n2. $(2.0,\\,0.05,\\,0.0,\\,1.0)$\n3. $(1.0,\\,1.9,\\,1.0,\\,1.0)$\n4. $(0.5,\\,0.8,\\,-2.0,\\,0.5)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，\"[result1,result2,result3,result4]\"），每个结果是对应于一个测试案例的估计标量大小（以米为单位），根据上述单个宏观步诊断计算得出。不允许外部输入，所有计算必须仅基于指定的流和组合。角度必须以弧度为单位，所有物理量必须采用国际单位制 (SI)。输出值必须是实数（浮点数）。",
            "solution": "该问题经评估有效。它在经典力学和数值分析方面具有科学依据，其定义完整且一致，问题是适定的，并且其表述是客观的。因此，我们可以继续进行求解。\n\n该问题要求为一维简谐振子的算符分裂中的一个特定三阶误差项的大小提供一个估计量。该估计量将通过两种对称二阶 (Strang) 分裂方案 $S_{ABA}$ 和 $S_{BAB}$ 之间的差异来构建。\n\n**第 1 步：系统的矩阵表示**\n\n该系统由相空间方程描述：\n$$\n\\frac{dx}{dt} = v \\\\\n\\frac{dv}{dt} = -\\omega^2 x\n$$\n对于状态向量 $y = (x, v)^T$，这可以写成矩阵形式 $\\frac{dy}{dt} = \\mathbf{L}y$，其中 $\\mathbf{L} = \\begin{pmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{pmatrix}$。\n\n算符分裂将 $\\mathbf{L}$ 分解为 $\\mathbf{A} + \\mathbf{B}$：\n- 算符 $A$ (漂移): $\\frac{dx}{dt} = v, \\frac{dv}{dt} = 0$。这对应于矩阵 $\\mathbf{A} = \\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}$。\n- 算符 $B$ (冲击): $\\frac{dx}{dt} = 0, \\frac{dv}{dt} = -\\omega^2 x$。这对应于矩阵 $\\mathbf{B} = \\begin{pmatrix} 0 & 0 \\\\ -\\omega^2 & 0 \\end{pmatrix}$。\n\n这些子问题在时间步长 $\\tau$ 内的精确流由矩阵指数 $\\exp(\\tau \\mathbf{A})$ 和 $\\exp(\\tau \\mathbf{B})$ 给出。这个特定系统的一个关键性质是 $\\mathbf{A}$ 和 $\\mathbf{B}$ 都是二阶幂零的：\n$$\n\\mathbf{A}^2 = \\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 \\\\ 0 & 0 \\end{pmatrix}\n$$\n$$\n\\mathbf{B}^2 = \\begin{pmatrix} 0 & 0 \\\\ -\\omega^2 & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 0 \\\\ -\\omega^2 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 \\\\ 0 & 0 \\end{pmatrix}\n$$\n这简化了矩阵指数，因为它们的泰勒级数会终止：\n$$\n\\exp(\\tau \\mathbf{A}) = \\mathbf{I} + \\tau \\mathbf{A}\n$$\n$$\n\\exp(\\tau \\mathbf{B}) = \\mathbf{I} + \\tau \\mathbf{B}\n$$\n这些与问题陈述中提供的流完全对应。\n\n**第 2 步：对易子代数**\n\n我们需要计算目标误差项中出现的嵌套李括号，即 $[A,[A,B]]$ 和 $[B,[B,A]]$。使用矩阵表示（其中李括号是矩阵对易子 $[\\mathbf{X},\\mathbf{Y}] = \\mathbf{XY}-\\mathbf{YX}$）：\n$$\n[\\mathbf{A},\\mathbf{B}] = \\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 0 \\\\ -\\omega^2 & 0 \\end{pmatrix} - \\begin{pmatrix} 0 & 0 \\\\ -\\omega^2 & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix} = \\begin{pmatrix} -\\omega^2 & 0 \\\\ 0 & 0 \\end{pmatrix} - \\begin{pmatrix} 0 & 0 \\\\ 0 & -\\omega^2 \\end{pmatrix} = \\begin{pmatrix} -\\omega^2 & 0 \\\\ 0 & \\omega^2 \\end{pmatrix}\n$$\n接下来，我们计算更高阶的对易子：\n$$\n[\\mathbf{A},[\\mathbf{A},\\mathbf{B}]] = \\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}\\begin{pmatrix} -\\omega^2 & 0 \\\\ 0 & \\omega^2 \\end{pmatrix} - \\begin{pmatrix} -\\omega^2 & 0 \\\\ 0 & \\omega^2 \\end{pmatrix}\\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & \\omega^2 \\\\ 0 & 0 \\end{pmatrix} - \\begin{pmatrix} 0 & -\\omega^2 \\\\ 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & 2\\omega^2 \\\\ 0 & 0 \\end{pmatrix} = 2\\omega^2 \\mathbf{A}\n$$\n对于第二项，使用 $[\\mathbf{X},\\mathbf{Y}] = -[\\mathbf{Y},\\mathbf{X}]$：\n$$\n[\\mathbf{B},[\\mathbf{B},\\mathbf{A}]] = -[\\mathbf{B},[\\mathbf{A},\\mathbf{B}]] = -\\left(\\begin{pmatrix} 0 & 0 \\\\ -\\omega^2 & 0 \\end{pmatrix}\\begin{pmatrix} -\\omega^2 & 0 \\\\ 0 & \\omega^2 \\end{pmatrix} - \\begin{pmatrix} -\\omega^2 & 0 \\\\ 0 & \\omega^2 \\end{pmatrix}\\begin{pmatrix} 0 & 0 \\\\ -\\omega^2 & 0 \\end{pmatrix}\\right)\n$$\n$$\n= -\\left(\\begin{pmatrix} 0 & 0 \\\\ \\omega^4 & 0 \\end{pmatrix} - \\begin{pmatrix} 0 & 0 \\\\ -\\omega^4 & 0 \\end{pmatrix}\\right) = -\\begin{pmatrix} 0 & 0 \\\\ 2\\omega^4 & 0 \\end{pmatrix} = 2\\omega^2 \\begin{pmatrix} 0 & 0 \\\\ -\\omega^2 & 0 \\end{pmatrix} = 2\\omega^2 \\mathbf{B}\n$$\n因此，对于这个系统，我们有简单的关系式：$[\\mathbf{A},[\\mathbf{A},\\mathbf{B}]] = 2\\omega^2 \\mathbf{A}$ 和 $[\\mathbf{B},[\\mathbf{B},\\mathbf{A}]] = 2\\omega^2 \\mathbf{B}$。\n\n**第 3 步：比例常数的推导**\n\n目标误差项的向量形式为：\n$$\nE_{vec} = \\Delta t^3 \\left( [\\mathbf{A},[\\mathbf{A},\\mathbf{B}]] + [\\mathbf{B},[\\mathbf{B},\\mathbf{A}]] \\right) y_0 = \\Delta t^3 (2\\omega^2 \\mathbf{A} + 2\\omega^2 \\mathbf{B}) y_0 = 2\\omega^2 \\Delta t^3 (\\mathbf{A}+\\mathbf{B}) y_0\n$$\n为了创建估计量，我们计算由 $S_{ABA}$ 和 $S_{BAB}$ 组合演化出的状态之间的差异。由于 $\\mathbf{A}$ 和 $\\mathbf{B}$ 的幂零性，这些组合可以被精确展开：\n$$\nS_{ABA}(\\Delta t) = \\exp(\\frac{\\Delta t}{2}\\mathbf{A})\\exp(\\Delta t \\mathbf{B})\\exp(\\frac{\\Delta t}{2}\\mathbf{A}) = (\\mathbf{I}+\\frac{\\Delta t}{2}\\mathbf{A})(\\mathbf{I}+\\Delta t \\mathbf{B})(\\mathbf{I}+\\frac{\\Delta t}{2}\\mathbf{A})\n$$\n展开此式并使用 $\\mathbf{A}^2 = 0$：\n$$\nS_{ABA}(\\Delta t) = \\mathbf{I} + \\Delta t (\\mathbf{A}+\\mathbf{B}) + \\frac{\\Delta t^2}{2}(\\mathbf{AB}+\\mathbf{BA}) + \\frac{\\Delta t^3}{4}\\mathbf{ABA}\n$$\n类似地，对于 $S_{BAB}(\\Delta t)$：\n$$\nS_{BAB}(\\Delta t) = \\mathbf{I} + \\Delta t (\\mathbf{A}+\\mathbf{B}) + \\frac{\\Delta t^2}{2}(\\mathbf{BA}+\\mathbf{AB}) + \\frac{\\Delta t^3}{4}\\mathbf{BAB}\n$$\n两个算符之间的差异是：\n$$\nS_{ABA}(\\Delta t) - S_{BAB}(\\Delta t) = \\frac{\\Delta t^3}{4}(\\mathbf{ABA} - \\mathbf{BAB})\n$$\n我们发现 $\\mathbf{ABA} = -\\omega^2 \\mathbf{A}$ 和 $\\mathbf{BAB} = -\\omega^2 \\mathbf{B}$。代入这些：\n$$\nS_{ABA}(\\Delta t) - S_{BAB}(\\Delta t) = \\frac{\\Delta t^3}{4}(-\\omega^2 \\mathbf{A} - (-\\omega^2 \\mathbf{B})) = \\frac{\\omega^2 \\Delta t^3}{4}(\\mathbf{B}-\\mathbf{A})\n$$\n最终状态的差异是 $\\Delta y = y_{ABA} - y_{BAB} = (S_{ABA} - S_{BAB})y_0$：\n$$\n\\Delta y = \\frac{\\omega^2 \\Delta t^3}{4}(\\mathbf{B}-\\mathbf{A})y_0\n$$\n问题要求从 $\\Delta y$ 估计 $E_{vec}$ 的大小，我们将其表示为 $E_s = \\|E_{vec}\\|_*$。我们使用指定的度量 $\\|\\!(\\Delta x,\\Delta v)\\!\\|_* = \\sqrt{(\\Delta x)^2 + (\\Delta v/\\omega)^2}$ 来比较两个向量 $E_{vec}$ 和 $\\Delta y$ 的大小（范数）。\n\n设 $y_0=(x_0, v_0)^T$。向量为：\n$$\n(\\mathbf{A}+\\mathbf{B})y_0 = \\begin{pmatrix} v_0 \\\\ -\\omega^2 x_0 \\end{pmatrix} \\quad \\implies \\quad \\|(\\mathbf{A}+\\mathbf{B})y_0\\|_* = \\sqrt{v_0^2 + (-\\omega^2 x_0/\\omega)^2} = \\sqrt{v_0^2 + \\omega^2 x_0^2}\n$$\n$$\n(\\mathbf{B}-\\mathbf{A})y_0 = \\begin{pmatrix} -v_0 \\\\ -\\omega^2 x_0 \\end{pmatrix} \\quad \\implies \\quad \\|(\\mathbf{B}-\\mathbf{A})y_0\\|_* = \\sqrt{(-v_0)^2 + (-\\omega^2 x_0/\\omega)^2} = \\sqrt{v_0^2 + \\omega^2 x_0^2}\n$$\n向量部分的范数是相同的。现在我们比较 $\\|E_{vec}\\|_*$ 和 $\\|\\Delta y\\|_*$ 的完整表达式：\n$$\n\\|E_{vec}\\|_* = 2\\omega^2 \\Delta t^3 \\|(\\mathbf{A}+\\mathbf{B})y_0\\|_*\n$$\n$$\n\\|\\Delta y\\|_* = \\frac{\\omega^2 \\Delta t^3}{4} \\|(\\mathbf{B}-\\mathbf{A})y_0\\|_*\n$$\n这些大小的比率给出了所需的比例常数：\n$$\n\\frac{\\|E_{vec}\\|_*}{\\|\\Delta y\\|_*} = \\frac{2\\omega^2 \\Delta t^3}{\\frac{\\omega^2 \\Delta t^3}{4}} \\frac{\\|(\\mathbf{A}+\\mathbf{B})y_0\\|_*}{\\|(\\mathbf{B}-\\mathbf{A})y_0\\|_*} = \\frac{2}{1/4} \\times 1 = 8\n$$\n因此，目标误差项大小的估计量是 $8\\|\\Delta y\\|_*$。\n\n**第 4 步：算法流程**\n\n对于每个测试案例 $(\\omega, \\Delta t, x_0, v_0)$:\n1. 初始化状态 $y_0 = (x_0, v_0)$。\n2. 通过应用精确流序列来计算 $y_{ABA}$：首先在 $\\Delta t/2$ 上进行漂移，然后在 $\\Delta t$ 上进行冲击，最后在 $\\Delta t/2$ 上进行漂移。\n3. 通过应用精确流序列来计算 $y_{BAB}$：首先在 $\\Delta t/2$ 上进行冲击，然后在 $\\Delta t$ 上进行漂移，最后在 $\\Delta t/2$ 上进行冲击。\n4. 计算差异向量 $\\Delta y = y_{ABA} - y_{BAB} = (\\Delta x, \\Delta v)$。\n5. 使用给定的度量计算差异的范数：$\\|\\Delta y\\|_* = \\sqrt{(\\Delta x)^2 + (\\Delta v / \\omega)^2}$。\n6. 最终的估计大小为 $8 \\times \\|\\Delta y\\|_*$。\n\n此流程将在最终程序中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the operator-splitting diagnostic problem for a 1D harmonic oscillator.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (omega, dt, x0, v0)\n    test_cases = [\n        (1.0, 0.1, 1.0, 0.0),\n        (2.0, 0.05, 0.0, 1.0),\n        (1.0, 1.9, 1.0, 1.0),\n        (0.5, 0.8, -2.0, 0.5),\n    ]\n\n    results = []\n    \n    # The proportionality constant derived from the system's specific properties.\n    # For a general system, the BCH analysis gives a different leading term,\n    # but for this specific system with nilpotent operators A and B, a direct\n    # expansion is exact and yields a constant of 8.\n    PROPORTIONALITY_CONSTANT = 8.0\n\n    def flow_A(y, dt):\n        \"\"\"Applies the exact kinematic drift flow (operator A) for a time step dt.\"\"\"\n        x, v = y\n        return np.array([x + dt * v, v])\n\n    def flow_B(y, dt, omega):\n        \"\"\"Applies the exact restoring-force kick flow (operator B) for a time step dt.\"\"\"\n        x, v = y\n        omega_sq = omega**2\n        return np.array([x, v - dt * omega_sq * x])\n\n    def S_ABA_step(y0, dt, omega):\n        \"\"\"Performs a single ABA Strang-splitting macro-step of size dt.\"\"\"\n        half_dt = dt / 2.0\n        # 1. A-step (drift) for dt/2\n        y1 = flow_A(y0, half_dt)\n        # 2. B-step (kick) for dt\n        y2 = flow_B(y1, dt, omega)\n        # 3. A-step (drift) for dt/2\n        y_final = flow_A(y2, half_dt)\n        return y_final\n\n    def S_BAB_step(y0, dt, omega):\n        \"\"\"Performs a single BAB Strang-splitting macro-step of size dt.\"\"\"\n        half_dt = dt / 2.0\n        # 1. B-step (kick) for dt/2\n        y1 = flow_B(y0, half_dt, omega)\n        # 2. A-step (drift) for dt\n        y2 = flow_A(y1, dt)\n        # 3. B-step (kick) for dt/2\n        y_final = flow_B(y2, half_dt, omega)\n        return y_final\n\n    for case in test_cases:\n        omega, dt, x0, v0 = case\n        y0 = np.array([x0, v0])\n\n        # Perform one macro-step with each composition\n        y_ABA = S_ABA_step(y0, dt, omega)\n        y_BAB = S_BAB_step(y0, dt, omega)\n\n        # Compute the difference between the final states\n        delta_y = y_ABA - y_BAB\n        delta_x, delta_v = delta_y\n\n        # Compute the magnitude of the difference using the specified phase-space metric\n        norm_delta_y = np.sqrt(delta_x**2 + (delta_v / omega)**2)\n\n        # The estimator is the norm of the difference multiplied by the derived constant\n        estimator_magnitude = PROPORTIONALITY_CONSTANT * norm_delta_y\n        \n        results.append(estimator_magnitude)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了简单常微分方程系统中分裂误差的基本概念后，我们自然地将目光投向更复杂的多物理场偏微分方程（PDE）系统，这是计算天体物理学中的常见情景。本练习将研究一个经典的平流-扩散方程，其中平流算符和扩散算符通常是不可交换的，这正是产生分裂误差的根源。您将运用伪谱法处理空间导数，并直接通过数值计算来量化源于BCH展开式的分裂误差主导项。这个实践不仅能加深您对算符不交换性如何导致误差的理解，也提供了在完整的PDE数值模拟中验证理论误差模型的宝贵经验。",
            "id": "3427806",
            "problem": "考虑一个边长为 $2\\pi$ 的周期性方形域上的二维无源标量平流-扩散方程：\n$$\n\\frac{\\partial s}{\\partial t} = A(s) + B(s),\n$$\n其中平流算子 $A$ 和扩散算子 $B$ 定义为\n$$\nA(s) = -\\boldsymbol{v}\\cdot\\nabla s,\\qquad B(s) = \\nu \\Delta s.\n$$\n速度场 $\\boldsymbol{v}(x,y)$ 是时不变的，并由泰勒-格林涡给出：\n$$\n\\boldsymbol{v}(x,y) = \\left(U\\sin(k_v x)\\cos(k_v y),\\,-U\\cos(k_v x)\\sin(k_v y)\\right),\n$$\n初始标量场为\n$$\ns_0(x,y) = \\cos(k_s x)\\cos(k_s y).\n$$\n假设所有量均为无量纲，且域为 $[0,2\\pi]\\times[0,2\\pi]$，具有周期性边界条件。\n\n你需要：\n- 为上述系统实现一个持续时间为 $\\Delta t$ 的Strang分裂步，即计算\n$$\ns^{\\text{Strang}}(\\Delta t) = e^{A \\Delta t/2}\\, e^{B \\Delta t}\\, e^{A \\Delta t/2}\\, s_0,\n$$\n其中 $e^{A \\tau}$ 表示在冻结时间速度场 $\\boldsymbol{v}$ 下，时间 $\\tau$ 内的精确平流算子，而 $e^{B \\tau}$ 是时间 $\\tau$ 内的精确扩散算子。\n- 使用Baker–Campbell–Hausdorff展开，推导并计算仅由算子分裂（即，不包括空间和时间离散化误差）引起的、在单个时间步后的$L^2$范数下的领头阶期望误差。对于时不变算子 $A$ 和 $B$，Strang分裂的局部误差为 $\\mathcal{O}(\\Delta t^3)$ 阶，其领头项由下式给出\n$$\n\\frac{\\Delta t^3}{12}\\left([A,[A,B]] + [B,[B,A]]\\right) s_0,\n$$\n其中作用于函数 $f$ 上的对易子 $[X,Y]$ 定义为 $[X,Y]f = X(Yf) - Y(Xf)$。因此，期望的 $L^2$ 误差应计算为\n$$\n\\left\\|\\frac{\\Delta t^3}{12}\\left([A,[A,B]] + [B,[B,A]]\\right) s_0\\right\\|_{L^2},\n$$\n其中 $L^2$ 范数定义为\n$$\n\\|f\\|_{L^2} = \\left(\\int_{0}^{2\\pi}\\int_{0}^{2\\pi} |f(x,y)|^2 \\, dx\\,dy\\right)^{1/2}.\n$$\n\n你的实现必须：\n- 在 $[0,2\\pi]\\times[0,2\\pi]$ 上使用大小为 $N\\times N$ 的均匀网格。\n- 通过快速傅里叶变换 (FFT) 计算空间导数，以便为周期函数一致地评估 $\\nabla s$ 和 $\\Delta s$。\n- 通过半拉格朗日平流法执行 $e^{A \\tau}$，其中对冻结速度场使用四阶龙格-库塔特征线积分，并对标量场进行周期性双线性插值；在傅里叶空间中，通过乘以 $e^{-\\nu |\\boldsymbol{k}|^2 \\tau}$（对于傅里叶模态 $\\boldsymbol{k}$）来精确执行 $e^{B \\tau}$。\n- 使用上述对易子表达式计算期望的 $L^2$ 误差，该表达式通过基于FFT的导数来数值地复合算子 $A$ 和 $B$ 实现。\n\n设计一个覆盖不同方面的测试套件：\n- 一个具有非零平流和扩散的通用情况。\n- 平流或扩散之一消失的边界情况，根据定义，其分裂误差应为零。\n- 一个具有更高波数以强调非对易性的情况。\n- 一个平流更强的情况。\n\n使用以下测试用例 $(U,k_v,k_s,\\nu,\\Delta t,N)$：\n1. $(1.0,\\,1,\\,1,\\,0.01,\\,0.05,\\,64)$\n2. $(1.0,\\,1,\\,1,\\,0.00,\\,0.05,\\,64)$\n3. $(0.0,\\,1,\\,1,\\,0.01,\\,0.05,\\,64)$\n4. $(2.0,\\,2,\\,3,\\,0.02,\\,0.05,\\,64)$\n5. $(1.0,\\,4,\\,4,\\,0.01,\\,0.10,\\,64)$\n\n你的程序应生成单行输出，其中包含五个测试用例的期望 $L^2$ 误差值，格式为用方括号括起来的逗号分隔列表（例如 $[e_1,e_2,e_3,e_4,e_5]$）。不应打印任何其他文本。所有值都必须是无量纲实数。三角函数中的角度以弧度为单位。",
            "solution": "该问题要求计算二维平流-扩散方程的Strang分裂格式的领头阶误差。解决方案涉及对区域和算子进行离散化，然后数值评估一个包含这些算子的嵌套对易子的复杂表达式。\n\n控制方程为\n$$\n\\frac{\\partial s}{\\partial t} = A(s) + B(s)\n$$\n在一个周期性域 $[0,2\\pi]\\times[0,2\\pi]$ 上，其中 $A(s) = -\\boldsymbol{v}\\cdot\\nabla s$ 是平流算子， $B(s) = \\nu \\Delta s$ 是扩散算子。速度场是一个时不变的泰勒-格林涡，初始标量场为 $s_0(x,y) = \\cos(k_s x)\\cos(k_s y)$。\n\n主要目标是计算持续时间为 $\\Delta t$ 的单步Strang分裂的领头阶局部误差项的 $L^2$ 范数。对于时不变算子，该误差项由Baker-Campbell-Hausdorff (BCH) 展开给出：\n$$\nE = \\frac{\\Delta t^3}{12}\\left([A,[A,B]] + [B,[B,A]]\\right) s_0\n$$\n其中 $[X,Y]f = X(Yf) - Y(Xf)$ 是算子 $X$ 和 $Y$ 的对易子。我们的任务是计算 $\\|E\\|_{L^2}$。\n\n计算策略如下：\n1.  将连续域 $[0,2\\pi]\\times[0,2\\pi]$ 离散化为一个均匀的 $N\\times N$ 网格。\n2.  使用伪谱法（即通过快速傅里叶变换，FFT）实现微分算子 $A$ 和 $B$ 的数值表示。\n3.  通过将数值算子顺序应用于初始场 $s_0$ 来评估嵌套对易子表达式。\n4.  使用数值积分计算所得误差场的 $L^2$ 范数。\n\n**第1步：离散化与傅里叶表示**\n该域被离散化为一个 $N \\times N$ 的网格，坐标为 $(x_i, y_j)$，其中 $x_i = i \\frac{2\\pi}{N}$ 且 $y_j = j \\frac{2\\pi}{N}$，对于 $i,j \\in \\{0, 1, \\dots, N-1\\}$。标量场 $s(x,y)$ 表示为一个矩阵 $s_{ij} = s(x_i, y_j)$。\n\n对于此网格上的周期函数，在傅里叶空间中计算空间导数最为精确。$s$ 的二维离散傅里叶变换为 $\\hat{s}(\\boldsymbol{k}) = \\mathcal{F}(s)$，其中 $\\boldsymbol{k}=(k_x, k_y)$ 是波矢量。对应于该网格的整数波数为 $k_x, k_y \\in \\{-\\frac{N}{2}, \\dots, \\frac{N}{2}-1\\}$。导数变换如下：\n$$\n\\mathcal{F}\\left(\\frac{\\partial s}{\\partial x}\\right) = i k_x \\hat{s}(\\boldsymbol{k})\n$$\n$$\n\\mathcal{F}\\left(\\frac{\\partial s}{\\partial y}\\right) = i k_y \\hat{s}(\\boldsymbol{k})\n$$\n$$\n\\mathcal{F}(\\Delta s) = \\mathcal{F}\\left(\\frac{\\partial^2 s}{\\partial x^2} + \\frac{\\partial^2 s}{\\partial y^2}\\right) = -(k_x^2 + k_y^2) \\hat{s}(\\boldsymbol{k}) = -|\\boldsymbol{k}|^2 \\hat{s}(\\boldsymbol{k})\n$$\n然后通过应用傅里叶逆变换 $\\mathcal{F}^{-1}$ 来恢复实空间导数。\n\n**第2步：算子 $A$ 和 $B$ 的数值实现**\n这些算子被实现为作用于表示标量场的二维数组的函数。\n\n扩散算子 $B(s) = \\nu \\Delta s$ 完全在傅里叶空间中计算。数值步骤如下：\n1.  计算场 $s$ 的二维FFT：$\\hat{s} = \\text{fft2}(s)$。\n2.  乘以算子的傅里叶符号：$\\widehat{B(s)} = \\nu (-|\\boldsymbol{k}|^2) \\hat{s}$。\n3.  计算结果的二维逆FFT并取实部：$B(s) = \\text{real}(\\text{ifft2}(\\widehat{B(s)}))$。\n\n平流算子 $A(s) = -(v_x \\frac{\\partial s}{\\partial x} + v_y \\frac{\\partial s}{\\partial y})$ 使用伪谱法实现：\n1.  如上所述，在傅里叶空间中计算梯度 $\\frac{\\partial s}{\\partial x}$ 和 $\\frac{\\partial s}{\\partial y}$。\n2.  将梯度变换回实空间。\n3.  在网格上计算速度场分量 $v_x$ 和 $v_y$。\n4.  在实空间中执行点积并乘以 $-1$： $A(s) = -(v_x \\frac{\\partial s}{\\partial x} + v_y \\frac{\\partial s}{\\partial y})$。\n\n**第3步：对易子表达式的评估**\n表达式 $E = \\frac{\\Delta t^3}{12} \\left( [A,[A,B]]s_0 + [B,[B,A]]s_0 \\right)$ 涉及嵌套对易子。为进行数值计算，我们展开对易子：\n$$\n[A,[A,B]]s_0 = A(A(B(s_0))) - 2A(B(A(s_0))) + B(A(A(s_0)))\n$$\n$$\n[B,[B,A]]s_0 = A(B(B(s_0))) - 2B(A(B(s_0))) + B(B(A(s_0)))\n$$\n我们将算子 $X$ 应用于场 $f$ 记为 $Xf$。数值评估需要计算初始场 $s_0$ 上的所有六个唯一的三阶算子序列：\n$AABs_0$、 $ABAs_0$、 $BAAs_0$、 $ABBs_0$、 $BABs_0$、 $BBAs_0$。\n然后，总的未缩放误差场组装为：\n$$\n_E = (AABs_0 - 2 ABAs_0 + BAAs_0) + (ABBs_0 - 2 BABs_0 + BBAs_0)\n$$\n最后，完整的误差场为 $E = \\frac{\\Delta t^3}{12} {}_E$。请注意，如果 $U=0$（因此 $A=0$）或 $\\nu=0$（因此 $B=0$），对易子将消失，产生预期的零误差。\n\n**第4步：$L^2$ 范数的计算**\n域上函数 $f$ 的 $L^2$ 范数为 $\\|f\\|_{L^2} = \\left(\\int_0^{2\\pi}\\int_0^{2\\pi} |f(x,y)|^2 \\, dx\\,dy\\right)^{1/2}$。该积分通过对离散网格点的求和来近似：\n$$\n\\|E\\|_{L^2} \\approx \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} |E(x_i, y_j)|^2 \\Delta x \\Delta y \\right)^{1/2}\n$$\n其中 $E(x_i, y_j)$ 是计算出的误差场在网格上的值，网格间距为 $\\Delta x = \\Delta y = \\frac{2\\pi}{N}$。\n\n整体算法遍历每个测试用例，设置参数和初始场，然后执行第2步到第4步以计算最终的标量误差值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the leading-order Strang splitting error for the 2D\n    advection-diffusion equation on a periodic domain.\n    \"\"\"\n    test_cases = [\n        (1.0, 1, 1, 0.01, 0.05, 64),\n        (1.0, 1, 1, 0.00, 0.05, 64),\n        (0.0, 1, 1, 0.01, 0.05, 64),\n        (2.0, 2, 3, 0.02, 0.05, 64),\n        (1.0, 4, 4, 0.01, 0.10, 64)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        U, k_v, k_s, nu, dt, N = case\n\n        # If U or nu is zero, one operator is zero, so the commutator is zero,\n        # and the splitting error is zero.\n        if U == 0.0 or nu == 0.0:\n            results.append(0.0)\n            continue\n\n        # 1. Setup Grid, Wavenumbers, and Fields\n        L = 2.0 * np.pi\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        X, Y = np.meshgrid(x, x, indexing='ij')\n\n        # Wavenumbers for FFT on a domain of size L=2*pi\n        k_vec = np.fft.fftfreq(N) * N \n        Kx, Ky = np.meshgrid(k_vec, k_vec, indexing='ij')\n        K2 = Kx**2 + Ky**2\n\n        # Initial scalar field\n        s0 = np.cos(k_s * X) * np.cos(k_s * Y)\n        # Velocity field\n        vx = U * np.sin(k_v * X) * np.cos(k_v * Y)\n        vy = -U * np.cos(k_v * X) * np.sin(k_v * Y)\n\n        # 2. Define numerical operators A and B\n        def apply_A(s_field):\n            \"\"\"Applies advection operator A(s) = -v . grad(s)\"\"\"\n            s_hat = np.fft.fft2(s_field)\n            ds_dx_hat = 1j * Kx * s_hat\n            ds_dy_hat = 1j * Ky * s_hat\n            ds_dx = np.fft.ifft2(ds_dx_hat).real\n            ds_dy = np.fft.ifft2(ds_dy_hat).real\n            return -(vx * ds_dx + vy * ds_dy)\n\n        def apply_B(s_field):\n            \"\"\"Applies diffusion operator B(s) = nu * laplacian(s)\"\"\"\n            s_hat = np.fft.fft2(s_field)\n            lap_s_hat = -K2 * s_hat\n            lap_s = np.fft.ifft2(lap_s_hat).real\n            return nu * lap_s\n\n        # 3. Compute all third-order operator applications\n        \n        # 1st order applications\n        As0 = apply_A(s0)\n        Bs0 = apply_B(s0)\n        \n        # 2nd order applications\n        AAs0 = apply_A(As0)\n        ABs0 = apply_A(Bs0)\n        BAs0 = apply_B(As0)\n        BBs0 = apply_B(Bs0)\n\n        # 3rd order applications\n        # For term [A, [A, B]]s0 = AABs0 - 2*ABAs0 + BAAs0\n        AABs0 = apply_A(ABs0)\n        ABAs0 = apply_A(BAs0)\n        BAAs0 = apply_B(AAs0)\n        \n        # For term [B, [B, A]]s0 = ABBs0 - 2*BABs0 + BBAs0\n        ABBs0 = apply_A(BBs0)\n        BABs0 = apply_B(ABs0)\n        BBAs0 = apply_B(BAs0)\n\n        # 4. Assemble the full error field\n        # term1 = A(A(B(s0))) - 2A(B(A(s0))) + B(A(A(s0)))\n        term1_field = AABs0 - 2.0 * ABAs0 + BAAs0\n        # term2 = A(B(B(s0))) - 2B(A(B(s0))) + B(B(A(s0)))\n        term2_field = ABBs0 - 2.0 * BABs0 + BBAs0\n        \n        unscaled_error_field = term1_field + term2_field\n        error_field = (dt**3 / 12.0) * unscaled_error_field\n\n        # 5. Compute the L2 norm of the error field\n        l2_norm_sq = np.sum(np.abs(error_field)**2) * (dx**2)\n        l2_norm = np.sqrt(l2_norm_sq)\n        \n        results.append(l2_norm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.15e}' for val in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "天体物理系统常常包含在迥异的时间尺度上运行的多种物理过程，这导致了数值求解中的“刚性”（stiffness）问题。直接对整个系统采用小时间步长在计算上是不可行的，而算符分裂为此提供了一个优雅的解决方案。本练习介绍了一种处理刚性问题的关键技术——子步循环（subcycling），即在每个“慢”过程的宏观时间步长内，对“快”过程的算符采用多个微观时间步进行演化。您将为一个代表旋转和刚性阻尼的线性系统设计并实现一个子步循环Strang分裂格式，并分析由子步积分器引入的误差如何与固有的分裂误差相互作用，这对于设计高效且准确的多尺度问题求解器至关重要。",
            "id": "3527486",
            "problem": "考虑自治常微分方程 $u'(t) = F(u(t)) + G(u(t))$，其中 $u(t) \\in \\mathbb{R}^n$。该系统被分为两个部分，一个慢分量 $F$ 和一个快分量 $G$。Strang 分裂法使用 $F$ 和 $G$ 的精确流映射的复合来近似宏观时间步长 $\\Delta t$ 内的演化。当 $G$ 非常刚性时，在每个宏观步长内对 $G$ 的更新使用更简单的单步法进行子循环通常是有利的。您的任务是设计这样一种 Strang 分裂法，其中 $G$ 部分在每个宏观步长内使用后向欧拉法进行 $m$ 次子循环更新，并分析子循环误差如何与分裂误差相互作用。\n\n从以下基础出发：\n- 自治向量场 $H$ 的流映射是指将一个状态在 $H$ 的作用下推进时间 $\\tau$ 的映射 $\\Phi_H^{\\tau}$，满足 $u(t+\\tau) = \\Phi_H^{\\tau}(u(t))$。\n- 对于常数矩阵 $A$ 的线性系统 $u'(t) = A u(t)$，精确流映射为 $\\Phi_A^{\\tau} = \\exp(A \\tau)$，其中 $\\exp(\\cdot)$ 表示矩阵指数。\n- Baker–Campbell–Hausdorff (BCH) 展开提供了非对易算子指数复合的局部误差结构，并表明当使用精确流时，Strang 分裂法的局部误差在 $\\Delta t$ 上是三阶的。\n\n设计 $G$ 进行 $m$ 次子循环的 Strang 分裂法如下：\n- 使用复合 $\\Psi_{\\Delta t} = \\widetilde{\\Phi}_G^{\\Delta t/2} \\circ \\Phi_F^{\\Delta t} \\circ \\widetilde{\\Phi}_G^{\\Delta t/2}$，其中 $\\Phi_F^{\\Delta t}$ 是 $F$ 的精确流，$\\widetilde{\\Phi}_G^{\\Delta t/2}$ 是通过 $m$ 个后向欧拉微观步长（微观步长大小为 $h = \\Delta t/(2 m)$）获得的 $G$ 的数值流。\n\n分析误差相互作用：\n- 推导由后向欧拉法对 $G$ 进行子循环所引入的局部截断误差的阶数。\n- 将此与分裂误差相结合，得到每个宏观步长的总体局部误差尺度。\n- 解释当 $F$ 和 $G$ 对易（即 $[F,G] = 0$）时的特殊情况，以及这对分裂误差有何影响。\n\n在与计算天体物理学相关的 $2 \\times 2$ 线性系统上实现并测试该方法，其中由于不同的物理过程，可能出现 $F$ 和 $G$ 之间的非对易性：\n- 令 $F(u) = A u$，其中 $A = \\begin{pmatrix} 0 & -\\omega \\\\ \\omega & 0 \\end{pmatrix}$ 代表角速率为 $\\omega$ 的平面旋转。\n- 令 $G(u) = B u$，其中 $B$ 代表各向异性阻尼，对于非对易测试选择 $B = \\begin{pmatrix} -\\lambda & 0 \\\\ 0 & -2 \\lambda \\end{pmatrix}$，对于对易测试选择 $B = -\\lambda I$。\n\n对于每个测试用例，计算在初始条件 $u_0 = \\begin{pmatrix} 1.0 \\\\ 2.0 \\end{pmatrix}$ 上施加一个宏观时间步长 $\\Delta t$ 的单步误差，通过评估：\n- 精确的宏观步长 $u_{\\text{exact}} = \\exp\\!\\big((A + B) \\Delta t\\big) u_0$。\n- 使用后向欧拉微观步长对 $G$ 进行子循环的 Strang 更新 $u_{\\text{split}} = \\Psi_{\\Delta t}(u_0)$。\n- 误差为欧几里得范数 $\\|u_{\\text{split}} - u_{\\text{exact}}\\|_2$。\n\n不涉及物理单位。如果出现角度，单位为弧度。将所有最终数值答案表示为浮点数。\n\n使用以下参数元组 $(\\omega, \\lambda, \\Delta t, m, B\\text{-type})$ 的测试套件，其中 $B\\text{-type} \\in \\{\\text{diag}, \\text{identity}\\}$ 指示 $B$ 是各向异性对角矩阵 ($\\text{diag}$) 还是标量单位矩阵的倍数 ($\\text{identity}$)：\n- 测试 1：$(\\omega = 1, \\lambda = 50, \\Delta t = 0.05, m = 1, \\text{diag})$ 作为一般的刚性、非对易、最少子循环的情况。\n- 测试 2：$(\\omega = 1, \\lambda = 50, \\Delta t = 0.05, m = 10, \\text{diag})$ 作为中等子循环的理想情况。\n- 测试 3：$(\\omega = 1, \\lambda = 50, \\Delta t = 0.01, m = 100, \\text{diag})$ 用于探测小宏观步长下强子循环的情况。\n- 测试 4：$(\\omega = 1, \\lambda = 50, \\Delta t = 0.05, m = 1, \\text{identity})$ 用于揭示分裂误差消失、仅剩子循环误差的对易情况。\n- 测试 5：$(\\omega = 1, \\lambda = 200, \\Delta t = 0.05, m = 10, \\text{diag})$ 用于检查中等子循环下极端刚性的情况。\n- 测试 6：$(\\omega = 1, \\lambda = 5, \\Delta t = 0.05, m = 10, \\text{diag})$ 用于检查中等子循环下弱刚性的情况。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，$[r_1,r_2,r_3,r_4,r_5,r_6]$），其中每个 $r_i$ 是按上述顺序排列的相应测试用例的浮点误差。",
            "solution": "该问题要求为自治常微分方程 (ODE) $u'(t) = F(u(t)) + G(u(t))$ 设计并分析一种 Strang 分裂法，其中对应于刚性部分 $G$ 的流使用子循环的后向欧拉步进行近似。我们将首先推导该格式的结构和局部误差，然后在一个特定的线性系统上实现它。\n\n在宏观时间步长 $\\Delta t$ 上的总体演化由算子 $\\Psi_{\\Delta t}$ 近似。该算子是一种对称组合，称为 Strang 分裂法，形式如下：\n$$\n\\Psi_{\\Delta t} = \\widetilde{\\Phi}_G^{\\Delta t/2} \\circ \\Phi_F^{\\Delta t} \\circ \\widetilde{\\Phi}_G^{\\Delta t/2}\n$$\n这里，$\\Phi_F^{\\Delta t}$ 是方程 $u' = F(u)$ 在时间 $\\Delta t$ 上的精确流算子。算子 $\\widetilde{\\Phi}_G^{\\Delta t/2}$ 是方程 $u' = G(u)$ 在长度为 $\\Delta t/2$ 的时间区间上精确流 $\\Phi_G^{\\Delta t/2}$ 的数值近似。\n\n数值近似 $\\widetilde{\\Phi}_G^{\\Delta t/2}$ 是通过采取 $m$ 个后向欧拉法的微观步长来构造的。每个微观步长的大小是 $h = \\frac{\\Delta t}{2m}$。对于 $u' = G(u)$，从时间 $t_k$ 到 $t_{k+1} = t_k+h$ 的一个后向欧拉步由以下隐式方程给出：\n$$\nu_{k+1} = u_k + h G(u_{k+1})\n$$\n对于问题中指定的线性系统 $G(u) = Bu$，其中 $B$ 是一个常数矩阵。后向欧拉步变为：\n$$\nu_{k+1} = u_k + h B u_{k+1} \\implies (I - hB)u_{k+1} = u_k \\implies u_{k+1} = (I - hB)^{-1} u_k\n$$\n其中 $I$ 是单位矩阵。将此算子应用 $m$ 次以在时长为 $\\tau = mh = \\Delta t/2$ 的时间内推进解，得到数值流算子：\n$$\n\\widetilde{\\Phi}_G^{\\Delta t/2} = \\left( (I - hB)^{-1} \\right)^m = \\left( \\left(I - \\frac{\\Delta t}{2m}B\\right)^{-1} \\right)^m\n$$\n\n现在，我们分析该格式的局部截断误差。总误差是分裂误差和子循环误差的组合。\n\n1.  **分裂误差**：如果对 $F$ 和 $G$ 都使用精确流，标准的 Strang 分裂算子将是 $\\Phi_G^{\\Delta t/2} \\circ \\Phi_F^{\\Delta t} \\circ \\Phi_G^{\\Delta t/2}$。Baker-Campbell-Hausdorff (BCH) 展开表明，与精确流 $\\Phi_{F+G}^{\\Delta t}$ 相比，这种复合的局部误差在时间步长上是三阶的：\n    $$\n    \\left( \\Phi_G^{\\Delta t/2} \\circ \\Phi_F^{\\Delta t} \\circ \\Phi_G^{\\Delta t/2} \\right)(u) - \\Phi_{F+G}^{\\Delta t}(u) = O((\\Delta t)^3)\n    $$\n    此误差与算子 $F$ 和 $G$ 的嵌套对易子成正比，例如 $[F, [F,G]]$ 和 $[G, [G,F]]$。如果 $F$ 和 $G$ 对易（即 $[F,G]=0$），这些项会消失，分裂误差为零。在线性情况下，这意味着矩阵 $A$ 和 $B$ 对易，即 $[A,B]=0$。\n\n2.  **子循环误差**：此误差源于用数值算子 $\\widetilde{\\Phi}_G^{\\Delta t/2}$ 近似精确流 $\\Phi_G^{\\Delta t/2} = \\exp(B \\Delta t/2)$。后向欧拉法是一阶精度方法。大小为 $h$ 的单步局部误差为 $O(h^2)$。当在时长为 $\\tau=mh$ 的区间上累积 $m$ 步时，结果的全局误差为 $O(h)$ 阶。\n    更精确地说，我们来分析算子误差。一个后向欧拉步的算子可以展开为：\n    $$\n    (I - hB)^{-1} = I + hB + h^2B^2 + O(h^3)\n    $$\n    在时间 $h$ 上的精确流算子为：\n    $$\n    \\exp(hB) = I + hB + \\frac{h^2}{2}B^2 + O(h^3)\n    $$\n    单个微观步长的数值算子误差为 $\\exp(hB) - (I-hB)^{-1} = -\\frac{h^2}{2}B^2 + O(h^3)$。经过 $m$ 步，在 $G$ 的流算子中累积的误差为 $m \\cdot O(h^2) = O(mh^2)$ 阶。由于 $\\tau = \\Delta t/2 = mh$，我们可以将此误差写为 $O(\\tau h)$。代入 $h = \\Delta t/(2m)$ 和 $\\tau = \\Delta t/2$，算子 $\\widetilde{\\Phi}_G^{\\Delta t/2}$ 的误差为：\n    $$\n    E_G = \\widetilde{\\Phi}_G^{\\Delta t/2} - \\Phi_G^{\\Delta t/2} = O(\\tau h) = O\\left(\\frac{\\Delta t}{2} \\cdot \\frac{\\Delta t}{2m}\\right) = O\\left(\\frac{(\\Delta t)^2}{m}\\right)\n    $$\n    这是由 $G$ 部分的数值积分贡献的误差。\n\n3.  **总体局部误差**：每个宏观步长的总局部误差是分裂误差和传播的子循环误差之和。完整的格式是 $\\Psi_{\\Delta t} = (\\Phi_G^{\\Delta t/2} + E_G) \\circ \\Phi_F^{\\Delta t} \\circ (\\Phi_G^{\\Delta t/2} + E_G)$。展开并与精确解比较，得到：\n    $$\n    \\Psi_{\\Delta t} - \\Phi_{F+G}^{\\Delta t} = \\underbrace{\\left(\\Phi_G^{\\Delta t/2} \\Phi_F^{\\Delta t} \\Phi_G^{\\Delta t/2} - \\Phi_{F+G}^{\\Delta t}\\right)}_{\\text{分裂误差}} + \\underbrace{E_G \\Phi_F^{\\Delta t} \\Phi_G^{\\Delta t/2} + \\Phi_G^{\\Delta t/2} \\Phi_F^{\\Delta t} E_G + O(E_G^2)}_{\\text{子循环误差}}\n    $$\n    因此，总的局部误差是两个主阶项之和：\n    $$\n    LTE = O((\\Delta t)^3) + O\\left(\\frac{(\\Delta t)^2}{m}\\right)\n    $$\n    为使该方法有效，子循环误差不应主导分裂误差。这可以通过选择足够大的 $m$ 来实现，使得 $(\\Delta t)^2/m$ 很小，理想情况下与 $(\\Delta t)^3$ 同阶或更小，这意味着 $m$ 至少应与 $1/\\Delta t$ 成正比。\n\n4.  **对易情况**：如果 $[F,G]=0$（或对于线性问题 $[A,B]=0$），如前所示，分裂误差项 $O((\\Delta t)^3)$ 精确地消失。总的局部误差则由子循环误差主导：\n    $$\n    LTE_{\\text{commute}} = O\\left(\\frac{(\\Delta t)^2}{m}\\right)\n    $$\n    在这种特殊情况下，精度完全由子步数值积分的精度决定。\n\n为了实现测试用例，我们为线性系统 $u'=(A+B)u$ 计算以下量：\n- 初始条件：$u_0 = \\begin{pmatrix} 1.0 \\\\ 2.0 \\end{pmatrix}$。\n- 一个宏观步长后的精确解：$u_{\\text{exact}} = \\exp((A+B)\\Delta t) u_0$。矩阵指数通过数值方法计算。\n- 分裂解：$u_{\\text{split}} = \\Psi_{\\Delta t}(u_0) = \\left( (I - hB)^{-1} \\right)^m \\left( \\exp(A \\Delta t) \\left( (I - hB)^{-1} \\right)^m u_0 \\right)$，其中 $h=\\Delta t/(2m)$。\n- 误差：欧几里得范数 $\\|u_{\\text{split}} - u_{\\text{exact}}\\|_2$。\n\n对六个指定的测试用例进行计算，这些用例涉及不同的参数值和矩阵 $B$ 的选择（非对易的对角矩阵与对易的单位矩阵）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the one-step error of a subcycled Strang splitting method\n    for various test cases of a 2x2 linear ODE system.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Format: (omega, lambda, Delta_t, m, B-type)\n    test_cases = [\n        (1.0, 50.0, 0.05, 1, 'diag'),      # Test 1\n        (1.0, 50.0, 0.05, 10, 'diag'),     # Test 2\n        (1.0, 50.0, 0.01, 100, 'diag'),    # Test 3\n        (1.0, 50.0, 0.05, 1, 'identity'),  # Test 4\n        (1.0, 200.0, 0.05, 10, 'diag'),    # Test 5\n        (1.0, 5.0, 0.05, 10, 'diag'),      # Test 6\n    ]\n\n    results = []\n    u0 = np.array([1.0, 2.0])\n    Id = np.identity(2)\n\n    for case in test_cases:\n        omega, lam, dt, m, b_type = case\n\n        # Define system matrices A and B\n        A = np.array([[0.0, -omega], [omega, 0.0]])\n        \n        if b_type == 'diag':\n            B = np.array([[-lam, 0.0], [0.0, -2.0 * lam]])\n        elif b_type == 'identity':\n            B = -lam * Id\n        else:\n            raise ValueError(\"Unknown b_type specified\")\n\n        # 1. Compute the exact solution\n        # u_exact = exp((A + B) * dt) * u0\n        C = A + B\n        u_exact = expm(C * dt) @ u0\n\n        # 2. Compute the solution using Strang splitting with subcycling\n        \n        # Subcycling micro-step size for G-part\n        h = dt / (2.0 * m)\n        \n        # Operator for one G-half-step (m backward Euler steps)\n        # First, find the operator for a single backward Euler micro-step\n        # u_k+1 = (I - hB)^-1 u_k\n        inv_I_m_hB = np.linalg.inv(Id - h * B)\n        # Then, raise it to the power of m for the full half-step\n        G_half_step_op = np.linalg.matrix_power(inv_I_m_hB, m)\n\n        # Operator for the F-step (exact flow)\n        F_step_op = expm(A * dt)\n\n        # Apply the splitting scheme: G(dt/2), F(dt), G(dt/2)\n        u_1 = G_half_step_op @ u0\n        u_2 = F_step_op @ u_1\n        u_split = G_half_step_op @ u_2\n\n        # 3. Compute the error\n        error = np.linalg.norm(u_split - u_exact)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}