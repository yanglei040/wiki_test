{
    "hands_on_practices": [
        {
            "introduction": "The Kick-Drift-Kick (KDK) leapfrog scheme is elegant in its symmetry, but this structure is not a matter of mere aesthetics. This exercise guides you through the foundational derivation that justifies its design. By requiring the numerical solution to match the true dynamics to second order and to be time-reversible, we can uniquely determine how the algorithm must be constructed, starting from its very first step. ",
            "id": "3538304",
            "problem": "Consider a separable Hamiltonian system representative of a collisionless gravitational $N$-body model, with Hamiltonian $H(q,p)=T(p)+V(q)$, where $q \\in \\mathbb{R}^{d}$ are positions, $p \\in \\mathbb{R}^{d}$ are canonical momenta, $T$ is the kinetic energy depending only on $p$, and $V$ is the potential energy depending only on $q$. Let the equations of motion be given by Hamilton’s equations, $\\dot{q}=\\nabla_{p}T(p)$ and $\\dot{p}=-\\nabla_{q}V(q)$, with all functions assumed to be sufficiently smooth for Taylor expansions to be valid.\n\nYou wish to integrate this system with the time-symmetric symplectic leapfrog of the kick-drift-kick (KDK) form over a time step $\\Delta t>0$. The KDK scheme advances from $(q_{0},p_{0})$ at time $t=0$ by first performing a half-step momentum update (kick), then a full-step position update (drift), and finally a half-step momentum update (kick). Because the leapfrog uses staggered momenta, you must initialize a half-step momentum $p_{1/2}$ using only $(q_{0},p_{0})$ and $\\Delta t$ so that:\n- the very first drift step produces $q_{1}$ that matches the exact $q(\\Delta t)$ up to and including terms of order $\\Delta t^{2}$ (local truncation error $\\mathcal{O}(\\Delta t^{3})$), and\n- the overall method is time reversible under $(q,p,\\Delta t)\\mapsto(q,-p,-\\Delta t)$.\n\nAssume $T$ is twice continuously differentiable and strictly convex in $p$ so that $\\nabla_{p}T$ is invertible and its Jacobian with respect to $p$ equals the Hessian $D^{2}_{pp}T(p)$. Let the first drift use the initialized $p_{1/2}$ via $q_{1}=q_{0}+\\Delta t\\,\\nabla_{p}T(p_{1/2})$. Parameterize the initialization as $p_{1/2}=p_{0}-c\\,\\Delta t\\,\\nabla_{q}V(q_{0})+\\mathcal{O}(\\Delta t^{2})$ with an unknown constant $c \\in \\mathbb{R}$.\n\nDerive, from Hamilton’s equations and Taylor expansions about $t=0$, the value of $c$ required to satisfy both conditions above, and hence obtain the unique initialization formula for $p_{1/2}$ in terms of $q_{0}$, $p_{0}$, $\\Delta t$, and $\\nabla_{q}V(q_{0})$ that ensures second-order accuracy from the first step and time reversibility of the KDK method. Express your final answer as a single closed-form analytic expression for $p_{1/2}$. No numerical evaluation is required.",
            "solution": "The problem statement is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- **System**: A separable Hamiltonian system described by $H(q,p)=T(p)+V(q)$.\n- **Variables**: $q \\in \\mathbb{R}^{d}$ (positions), $p \\in \\mathbb{R}^{d}$ (canonical momenta).\n- **Energy Terms**: $T(p)$ is the kinetic energy, $V(q)$ is the potential energy. All functions are assumed to be sufficiently smooth.\n- **Equations of Motion**: Hamilton’s equations are $\\dot{q}=\\nabla_{p}T(p)$ and $\\dot{p}=-\\nabla_{q}V(q)$.\n- **Integration Scheme**: A time-symmetric symplectic leapfrog method of the kick-drift-kick (KDK) form over a time step $\\Delta t > 0$.\n- **Initial Conditions**: The system is at state $(q_{0},p_{0})$ at time $t=0$.\n- **Task**: Determine the initialization formula for a half-step momentum $p_{1/2}$ using only $(q_{0},p_{0})$ and $\\Delta t$.\n- **Condition 1 (Accuracy)**: The first drift step, given by $q_{1}=q_{0}+\\Delta t\\,\\nabla_{p}T(p_{1/2})$, must yield a position $q_{1}$ that matches the exact solution $q(\\Delta t)$ with a local truncation error of $\\mathcal{O}(\\Delta t^{3})$. That is, $q_{1} - q(\\Delta t) = \\mathcal{O}(\\Delta t^{3})$.\n- **Condition 2 (Time Reversibility)**: The overall integration method must be time reversible under the transformation $(q,p,\\Delta t)\\mapsto(q,-p,-\\Delta t)$.\n- **Assumptions on $T(p)$**: The kinetic energy $T$ is twice continuously differentiable and strictly convex in $p$, ensuring its Hessian $D^{2}_{pp}T(p)$ is a well-defined, invertible matrix.\n- **Parameterization**: The initialization for $p_{1/2}$ is parameterized as $p_{1/2}=p_{0}-c\\,\\Delta t\\,\\nabla_{q}V(q_{0})+\\mathcal{O}(\\Delta t^{2})$, where $c \\in \\mathbb{R}$ is a constant to be determined.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is rooted in classical mechanics (Hamiltonian formalism) and numerical analysis (symplectic integration), which are standard and fundamental topics in computational physics and astrophysics.\n- **Well-Posed**: The problem is clearly stated with all necessary information. It asks for a specific constant $c$ and a corresponding formula that satisfy well-defined mathematical conditions (accuracy and time reversibility).\n- **Objective**: The problem is phrased in precise, mathematical language, free from any subjectivity or ambiguity.\n\nThe problem does not violate any of the invalidity criteria. It is a standard, non-trivial derivation in the field of geometric numerical integration.\n\n### Step 3: Verdict and Action\nThe problem is valid. A full, reasoned solution follows.\n\n### Solution Derivation\n\nThe primary task is to find the value of the constant $c$ that satisfies the given accuracy requirement. This value will then define the initialization formula for $p_{1/2}$.\n\nFirst, we determine the Taylor series expansion of the exact position $q(\\Delta t)$ around $t=0$ up to terms of order $(\\Delta t)^2$. The exact solution evolves from the initial state $(q_0, p_0)$ according to Hamilton's equations.\n\nThe Taylor expansion is:\n$$q(\\Delta t) = q(0) + \\Delta t \\, \\dot{q}(0) + \\frac{(\\Delta t)^2}{2} \\ddot{q}(0) + \\mathcal{O}(\\Delta t^3)$$\nAt $t=0$, we have $q(0) = q_0$ and $p(0) = p_0$. The first derivative of position is given by Hamilton's equations:\n$$\\dot{q}(t) = \\nabla_p T(p(t))$$\nEvaluating at $t=0$:\n$$\\dot{q}(0) = \\nabla_p T(p_0)$$\nTo find the second derivative $\\ddot{q}(0)$, we differentiate $\\dot{q}(t)$ with respect to time, using the chain rule:\n$$\\ddot{q}(t) = \\frac{d}{dt} \\left( \\nabla_p T(p(t)) \\right) = D^2_{pp}T(p(t)) \\, \\dot{p}(t)$$\nwhere $D^2_{pp}T(p(t))$ is the Hessian matrix of $T$ with respect to $p$. The derivative of momentum $\\dot{p}(t)$ is also given by Hamilton's equations:\n$$\\dot{p}(t) = -\\nabla_q V(q(t))$$\nEvaluating at $t=0$:\n$$\\dot{p}(0) = -\\nabla_q V(q_0)$$\nSubstituting this into the expression for $\\ddot{q}(0)$:\n$$\\ddot{q}(0) = D^2_{pp}T(p_0) (-\\nabla_q V(q_0)) = -D^2_{pp}T(p_0) \\nabla_q V(q_0)$$\nNow, we substitute the derivatives back into the Taylor expansion for $q(\\Delta t)$:\n$$q(\\Delta t) = q_0 + \\Delta t \\, \\nabla_p T(p_0) - \\frac{(\\Delta t)^2}{2} D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^3)$$\n\nNext, we analyze the position $q_1$ obtained from the first step of the numerical scheme. The scheme uses a drift step based on the initialized momentum $p_{1/2}$:\n$$q_1 = q_0 + \\Delta t \\, \\nabla_p T(p_{1/2})$$\nThe momentum $p_{1/2}$ is given by the parameterization:\n$$p_{1/2} = p_0 - c \\, \\Delta t \\, \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^2)$$\nTo find an expression for $q_1$ comparable to the expansion of $q(\\Delta t)$, we expand $\\nabla_p T(p_{1/2})$ in a Taylor series around $p_0$. Let $\\delta p = p_{1/2} - p_0 = -c \\, \\Delta t \\, \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^2)$. Note that $\\delta p$ is of order $\\mathcal{O}(\\Delta t)$.\n$$\\nabla_p T(p_{1/2}) = \\nabla_p T(p_0 + \\delta p) = \\nabla_p T(p_0) + D^2_{pp}T(p_0) \\, \\delta p + \\mathcal{O}(\\|\\delta p\\|^2)$$\nSubstituting the expression for $\\delta p$:\n$$\\nabla_p T(p_{1/2}) = \\nabla_p T(p_0) + D^2_{pp}T(p_0) \\left( -c \\, \\Delta t \\, \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^2) \\right) + \\mathcal{O}(\\Delta t^2)$$\n$$\\nabla_p T(p_{1/2}) = \\nabla_p T(p_0) - c \\, \\Delta t \\, D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^2)$$\nNow, substitute this expansion back into the expression for $q_1$:\n$$q_1 = q_0 + \\Delta t \\left( \\nabla_p T(p_0) - c \\, \\Delta t \\, D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^2) \\right)$$\n$$q_1 = q_0 + \\Delta t \\, \\nabla_p T(p_0) - c \\, (\\Delta t)^2 \\, D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^3)$$\n\nThe accuracy condition requires that $q_1 = q(\\Delta t) + \\mathcal{O}(\\Delta t^3)$. We compare the two derived expansions:\nExact: $q(\\Delta t) = q_0 + \\Delta t \\, \\nabla_p T(p_0) - \\frac{1}{2} (\\Delta t)^2 D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^3)$\nNumerical: $q_1 = q_0 + \\Delta t \\, \\nabla_p T(p_0) - c \\, (\\Delta t)^2 \\, D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^3)$\nThe terms of order $\\mathcal{O}(1)$ and $\\mathcal{O}(\\Delta t)$ already match. For the expansions to agree up to order $(\\Delta t)^2$, the coefficients of the $(\\Delta t)^2$ terms must be equal:\n$$-c \\, D^2_{pp}T(p_0) \\nabla_q V(q_0) = -\\frac{1}{2} D^2_{pp}T(p_0) \\nabla_q V(q_0)$$\nSince $T(p)$ is strictly convex, its Hessian $D^2_{pp}T(p_0)$ is invertible. Assuming a non-trivial potential where $\\nabla_q V(q_0) \\neq 0$, we can conclude:\n$$c = \\frac{1}{2}$$\n\nThis value of $c$ satisfies the accuracy condition. Now we consider the time-reversibility condition. The standard KDK integrator is a symmetric composition of operators corresponding to flows under $V$ (kick) and $T$ (drift): $\\Phi_{\\Delta t} = \\phi_V^{\\Delta t/2} \\circ \\phi_T^{\\Delta t} \\circ \\phi_V^{\\Delta t/2}$. This symmetric structure ensures that the method is time-reversible, meaning $\\Phi_{\\Delta t}^{-1} = S \\circ \\Phi_{\\Delta t} \\circ S$ for the transformation $S(q,p)=(q,-p)$, provided the kinetic energy $T(p)$ is an even function of $p$. The initialization step $p_{1/2} = p_0 - c \\Delta t \\nabla_q V(q_0)$ corresponds to the action of the first operator, the half-step kick $\\phi_V^{c \\Delta t}$. For the overall scheme to be the symmetric KDK integrator, this first kick must be a half-step kick, $\\phi_V^{\\Delta t/2}$. This implies $c \\Delta t = \\Delta t / 2$, which gives $c = 1/2$. Thus, both the accuracy and time-reversibility conditions independently lead to the same value for $c$.\n\nWith $c=1/2$, the parameterization $p_{1/2}=p_{0}-c\\,\\Delta t\\,\\nabla_{q}V(q_{0})+\\mathcal{O}(\\Delta t^{2})$ becomes the definitive formula for the initial half-step momentum update. The higher-order terms are zero for the standard KDK scheme, so the unique formula is exact within the context of the algorithm's definition.\n\nThe unique initialization formula for $p_{1/2}$ is:\n$$p_{1/2} = p_0 - \\frac{1}{2} \\Delta t \\nabla_q V(q_0)$$",
            "answer": "$$\\boxed{p_{0} - \\frac{1}{2} \\Delta t \\nabla_{q} V(q_{0})}$$"
        },
        {
            "introduction": "In theory, the leapfrog integrator is perfectly symplectic, but in practice, a single misplaced variable in your code can destroy this essential property. How can you be sure your implementation is correct? This hands-on practice guides you in building a powerful numerical diagnostic to test for symplecticity by directly checking the condition $J^{\\top}\\Omega J = \\Omega$, a vital skill for developing reliable simulation software. ",
            "id": "3538342",
            "problem": "You are asked to design and implement a numerical diagnostic that estimates the quantity $J^{\\top}\\Omega J - \\Omega$ for the Leapfrog (Kick-Drift-Kick) map at random phase-space points, and to specify tolerances for detecting loss of symplecticity due to implementation errors. The context is a separable Hamiltonian system with canonical coordinates $(q,p)$ and Hamiltonian $H(q,p) = T(p) + V(q)$, where $T(p)$ depends only on $p$ and $V(q)$ depends only on $q$. The canonical symplectic form is the constant $2\\times 2$ matrix\n$$\n\\Omega \\equiv \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}.\n$$\nThe Leapfrog (Kick-Drift-Kick) scheme advances $(q,p)$ by a time step $h$ using three sequential substeps: a half-step momentum update (\"kick\"), a full-step position update (\"drift\"), and a half-step momentum update (\"kick\"). The diagnostic must:\n- Numerically approximate the Jacobian $J$ of the one-step map $(q,p)\\mapsto (q',p')$ using finite differences at randomly chosen points in phase space.\n- Evaluate the deviation from symplecticity via $S \\equiv J^{\\top}\\Omega J - \\Omega$ and aggregate an error metric (for example, the maximum absolute entry of $S$).\n- Decide whether the map is symplectic within a prescribed tolerance based on the aggregated error metric across a set of random phase-space samples.\n\nDesign constraints and foundational base:\n- Use Hamilton’s equations $dq/dt = \\partial H/\\partial p$ and $dp/dt = -\\partial H/\\partial q$, and the separability of $H$ to justify the Leapfrog (Kick-Drift-Kick) substeps.\n- For a concrete and reproducible test, use the simple harmonic oscillator with nondimensional parameters $m=1$ and $k=1$, i.e., $T(p)=\\tfrac{1}{2}p^2$ and $V(q)=\\tfrac{1}{2}q^2$. All quantities are nondimensional; no physical units are required.\n- Approximate the Jacobian $J$ at a point $(q,p)$ using central finite differences with a user-specified perturbation size $\\delta$ for each coordinate. For the $i$-th coordinate, use the central difference formula $J_{:,i} \\approx \\big(F(x+\\delta e_i)-F(x-\\delta e_i)\\big)/(2\\delta)$, where $F$ is the one-step map and $e_i$ is the $i$-th standard basis vector.\n- Define the symplecticity error at a point as $\\|S\\|_{\\infty}$, where $\\|\\cdot\\|_{\\infty}$ denotes the maximum absolute entry norm.\n- Aggregate over multiple random samples by taking the maximum error across the samples.\n\nTolerance specification:\n- Finite-difference Jacobian estimation introduces two principal error contributions: truncation error $\\mathcal{O}(\\delta^2)$ and floating-point round-off amplification $\\mathcal{O}(\\epsilon_{\\text{mach}}/\\delta)$, where $\\epsilon_{\\text{mach}}$ is machine precision. A practical detection threshold for this diagnostic, robust across typical double-precision scenarios, is\n$$\n\\tau(\\delta) \\equiv 10\\,\\delta^2 + 10^{-8}.\n$$\n- The diagnostic should classify the implementation as symplectic if the aggregated error $\\max\\|S\\|_{\\infty}$ across the sample set is less than or equal to $\\tau(\\delta)$.\n\nRandom sampling:\n- Draw $(q,p)$ independently and uniformly from the interval $[-1,1]$ with a fixed random seed for reproducibility.\n\nImplementation errors to be detected:\n- Include at least one flawed Leapfrog variant that uses the pre-kick momentum $p$ instead of the half-kicked momentum $p_{1/2}$ during the drift substep; this inconsistency breaks symplecticity and should be detected by the diagnostic.\n\nTest suite:\n- Implement four test cases, each specified by a tuple $(\\text{scheme}, h, \\delta, N)$:\n    1. $(\\text{KDK}, 0.1, 10^{-6}, 256)$: Correct Kick-Drift-Kick scheme, moderate time step and finite-difference scale.\n    2. $(\\text{KDK}, 1.0, 10^{-6}, 128)$: Correct Kick-Drift-Kick scheme with a larger time step.\n    3. $(\\text{BUG1}, 0.1, 10^{-6}, 256)$: Flawed scheme where the drift uses $p$ instead of $p_{1/2}$.\n    4. $(\\text{KDK}, 0.1, 10^{-12}, 64)$: Correct scheme but with a very small finite-difference scale to illustrate breakdown due to round-off amplification.\n\nRequired final output format:\n- Your program should produce a single line of output containing the diagnostic decision for each test case as a comma-separated list enclosed in square brackets, with each entry being a boolean that is $\\text{True}$ if the aggregated error is $\\le \\tau(\\delta)$ and $\\text{False}$ otherwise. For example: $[\\text{True},\\text{True},\\text{False},\\text{False}]$.",
            "solution": "The task is to design a numerical diagnostic to verify the symplecticity of a numerical integrator for a separable Hamiltonian system. A map $\\Phi$ which advances the phase-space coordinates $x = (q,p)$ is defined as symplectic if its Jacobian matrix, $J = \\partial \\Phi / \\partial x$, preserves the canonical symplectic form $\\Omega$. This is expressed by the relation $J^{\\top}\\Omega J = \\Omega$. Our diagnostic will numerically estimate the deviation matrix $S \\equiv J^{\\top}\\Omega J - \\Omega$ and check if its magnitude is within a tolerance consistent with numerical precision and approximation errors.\n\nThe physical system under consideration is the simple harmonic oscillator, described by the separable Hamiltonian $H(q,p) = T(p) + V(q)$, where the kinetic energy is $T(p) = \\frac{1}{2}p^2$ and the potential energy is $V(q) = \\frac{1}{2}q^2$. For this problem, we use nondimensional parameters such that mass $m=1$ and spring constant $k=1$. The dynamics are governed by Hamilton's equations:\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p} = p\n$$\n$$\n\\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q} = -q\n$$\n\nThe integrator to be tested is the second-order Leapfrog scheme, in its Kick-Drift-Kick (KDK) formulation. This method is an example of a geometric integrator, designed to preserve the geometric properties of the underlying physical system, including symplecticity. The separability of $H$ allows for operator splitting, where the full evolution over a time step $h$ is approximated by a symmetric sequence of operations involving only $T(p)$ or $V(q)$. The one-step map from $(q_n, p_n)$ to $(q_{n+1}, p_{n+1})$ is given by three substeps:\n\n1.  **Kick (momentum update, half-step $\\Delta t = h/2$):** The system evolves under the potential $V(q)$. The momentum is updated using the force $F(q) = -\\partial V/\\partial q = -q$.\n    $$p_{n+1/2} = p_n + \\frac{h}{2} F(q_n) = p_n - \\frac{h}{2} q_n$$\n2.  **Drift (position update, full-step $\\Delta t = h$):** The system evolves under the kinetic energy $T(p)$. The position is updated using the velocity $v(p) = \\partial T/\\partial p = p$. This step must use the half-step-updated momentum $p_{n+1/2}$.\n    $$q_{n+1} = q_n + h \\cdot v(p_{n+1/2}) = q_n + h \\cdot p_{n+1/2}$$\n3.  **Kick (momentum update, half-step $\\Delta t = h/2$):** A second momentum update is performed, using the force evaluated at the new position $q_{n+1}$.\n    $$p_{n+1} = p_{n+1/2} + \\frac{h}{2} F(q_{n+1}) = p_{n+1/2} - \\frac{h}{2} q_{n+1}$$\n\nThis symmetric construction ensures that the resulting map is exactly symplectic. We also consider a flawed variant (BUG1), where the drift step erroneously uses the initial momentum $p_n$ instead of $p_{n+1/2}$: $q_{n+1} = q_n + h \\cdot p_n$. This seemingly minor error breaks the symmetry of the integrator and leads to a non-symplectic map.\n\nThe core of our diagnostic is the numerical approximation of the Jacobian $J$ of the one-step map, denoted $F(x)$. Since an analytical expression for $J$ is often unavailable for complex systems, we employ a second-order central finite difference formula. For each column $i$ of the Jacobian, corresponding to a perturbation in the $i$-th coordinate of the phase-space vector $x=(q,p)$, we have:\n$$\nJ_{:,i} \\approx \\frac{F(x + \\delta e_i) - F(x - \\delta e_i)}{2\\delta}\n$$\nwhere $e_i$ is the $i$-th standard basis vector and $\\delta$ is a small perturbation. This approximation introduces a truncation error of order $\\mathcal{O}(\\delta^2)$.\n\nWith the numerically estimated Jacobian $\\tilde{J}$, we compute the deviation matrix $\\tilde{S} = \\tilde{J}^{\\top}\\Omega \\tilde{J} - \\Omega$. For the correct KDK scheme, the true map is symplectic, so the only source of error in $\\tilde{S}$ should be the truncation error from the Jacobian approximation, i.e., $\\|\\tilde{S}\\|_{\\infty} = \\mathcal{O}(\\delta^2)$. However, for the flawed BUG1 scheme, the map itself is not symplectic, leading to an intrinsic error in $S$ that does not vanish as $\\delta \\to 0$. We will find this intrinsic error to be of order $\\mathcal{O}(h^2)$. A second source of numerical error is floating-point round-off, which becomes significant for very small $\\delta$. The subtraction of nearly equal numbers in the finite difference numerator, divided by a very small $\\delta$, amplifies round-off error, contributing a term of order $\\mathcal{O}(\\epsilon_{\\text{mach}}/\\delta)$, where $\\epsilon_{\\text{mach}}$ is machine precision (approximately $10^{-16}$ for double precision).\n\nThe diagnostic combines these considerations into a single decision rule. We calculate the maximum absolute entry of the deviation matrix, $\\|S\\|_{\\infty}$, at a set of $N$ random points in phase space and take the maximum value found. The implementation is classified as correctly symplectic if this aggregated error is less than or equal to the specified tolerance $\\tau(\\delta) = 10\\delta^2 + 10^{-8}$. This formula provides a ceiling for the expected truncation error ($10\\delta^2$) and a floor ($10^{-8}$) to accommodate round-off errors, particularly for $\\delta$ values around $10^{-8}$ where the two error sources are comparable.\n\nThe test suite will check four scenarios:\n1.  **Correct KDK, small $h$**: The diagnostic should pass, as the measured error $\\mathcal{O}(\\delta^2) = \\mathcal{O}((10^{-6})^2) = \\mathcal{O}(10^{-12})$ will be far below the tolerance $\\tau \\approx 10^{-8}$.\n2.  **Correct KDK, large $h$**: The result should be identical. The map is exactly symplectic regardless of step size $h$, so the diagnostic error depends only on $\\delta$.\n3.  **Flawed BUG1**: The diagnostic should fail. The intrinsic non-symplecticity introduces an error of magnitude $h^2/2 = (0.1)^2/2 = 0.005$, which is much larger than $\\tau \\approx 10^{-8}$.\n4.  **Correct KDK, very small $\\delta$**: The diagnostic should fail. Round-off amplification, $\\mathcal{O}(\\epsilon_{\\text{mach}}/\\delta) \\approx 10^{-16}/10^{-12} = 10^{-4}$, will dominate and exceed the tolerance $\\tau \\approx 10^{-8}$. This demonstrates a limitation of the numerical diagnostic itself when $\\delta$ is chosen poorly.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the symplecticity diagnostic on a set of test cases.\n    \"\"\"\n    # Define the canonical symplectic form matrix Omega\n    OMEGA = np.array([[0, 1], [-1, 0]], dtype=np.float64)\n\n    # --- Integrator Maps ---\n\n    def kdk_step(x: np.ndarray, h: float) -> np.ndarray:\n        \"\"\"\n        Performs one step of the Kick-Drift-Kick (KDK) Leapfrog integrator\n        for the simple harmonic oscillator H = 0.5*p^2 + 0.5*q^2.\n\n        Args:\n            x: Phase-space vector [q, p].\n            h: Time step.\n\n        Returns:\n            New phase-space vector [q_new, p_new].\n        \"\"\"\n        q, p = x\n        # Force F(q) = -dV/dq = -q\n        \n        # Kick 1 (half step)\n        p_half = p - (h / 2.0) * q\n        \n        # Drift (full step) using updated momentum\n        q_new = q + h * p_half\n        \n        # Kick 2 (half step) using new position\n        p_new = p_half - (h / 2.0) * q_new\n        \n        return np.array([q_new, p_new], dtype=np.float64)\n\n    def buggy_step(x: np.ndarray, h: float) -> np.ndarray:\n        \"\"\"\n        Performs one step of a flawed Leapfrog integrator where the drift\n        step incorrectly uses the initial momentum.\n\n        Args:\n            x: Phase-space vector [q, p].\n            h: Time step.\n\n        Returns:\n            New phase-space vector [q_new, p_new].\n        \"\"\"\n        q, p = x\n        \n        # Kick 1 (half step)\n        p_half = p - (h / 2.0) * q\n        \n        # Drift (full step) - THE BUG: uses initial momentum p instead of p_half\n        q_new = q + h * p\n        \n        # Kick 2 (half step)\n        p_new = p_half - (h / 2.0) * q_new\n        \n        return np.array([q_new, p_new], dtype=np.float64)\n\n    # --- Diagnostic Tools ---\n\n    def compute_jacobian(map_func, x: np.ndarray, h: float, delta: float) -> np.ndarray:\n        \"\"\"\n        Computes the Jacobian of a map function using central finite differences.\n\n        Args:\n            map_func: The one-step map function, e.g., kdk_step.\n            x: The phase-space point [q, p] at which to evaluate the Jacobian.\n            h: The time step for the map function.\n            delta: The perturbation size for the finite difference.\n\n        Returns:\n            The 2x2 Jacobian matrix.\n        \"\"\"\n        dim = len(x)\n        J = np.zeros((dim, dim), dtype=np.float64)\n        \n        for i in range(dim):\n            # Create perturbation vector e_i * delta\n            perturbation = np.zeros(dim, dtype=np.float64)\n            perturbation[i] = delta\n            \n            x_plus = x + perturbation\n            x_minus = x - perturbation\n            \n            f_plus = map_func(x_plus, h)\n            f_minus = map_func(x_minus, h)\n            \n            # Central difference formula for the i-th column of the Jacobian\n            J[:, i] = (f_plus - f_minus) / (2.0 * delta)\n            \n        return J\n\n    def check_symplecticity(scheme_name: str, h: float, delta: float, N: int) -> bool:\n        \"\"\"\n        Runs the full diagnostic for a given scheme and parameters.\n\n        Args:\n            scheme_name: Identifier for the scheme ('KDK' or 'BUG1').\n            h: Time step for the integrator.\n            delta: Perturbation for finite-difference Jacobian.\n            N: Number of random samples to test.\n\n        Returns:\n            True if the scheme is classified as symplectic, False otherwise.\n        \"\"\"\n        if scheme_name == 'KDK':\n            map_func = kdk_step\n        elif scheme_name == 'BUG1':\n            map_func = buggy_step\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme_name}\")\n\n        # Fixed seed for reproducibility\n        rng = np.random.default_rng(42)\n        \n        # Generate N random phase-space points (q, p) in [-1, 1] x [-1, 1]\n        samples = rng.uniform(low=-1.0, high=1.0, size=(N, 2))\n        \n        max_S_norm = 0.0\n        \n        for x_point in samples:\n            # 1. Compute numerical Jacobian J\n            J = compute_jacobian(map_func, x_point, h, delta)\n            \n            # 2. Compute the deviation matrix S = J^T Omega J - Omega\n            S = J.T @ OMEGA @ J - OMEGA\n            \n            # 3. Compute the point-wise error ||S||_inf (max absolute entry)\n            s_norm_inf = np.max(np.abs(S))\n            \n            # 4. Aggregate by taking the maximum error found so far\n            if s_norm_inf > max_S_norm:\n                max_S_norm = s_norm_inf\n        \n        # 5. Calculate the tolerance tau(delta)\n        tolerance = 10.0 * delta**2 + 1e-8\n        \n        # 6. Classify based on the tolerance\n        return max_S_norm <= tolerance\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('KDK', 0.1, 1e-6, 256),\n        ('KDK', 1.0, 1e-6, 128),\n        ('BUG1', 0.1, 1e-6, 256),\n        ('KDK', 0.1, 1e-12, 64)\n    ]\n\n    results = []\n    for case in test_cases:\n        scheme, h, delta, N = case\n        is_symplectic = check_symplecticity(scheme, h, delta, N)\n        results.append(str(is_symplectic))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The symmetric composition of the KDK scheme ensures it is time-reversible, meaning a forward integration followed by a backward integration should return you to the start. While this holds true in the perfect world of exact arithmetic, our computers are not so perfect. This exercise explores the practical consequences of finite precision by quantifying how floating-point round-off errors accumulate to break perfect time reversibility, revealing the subtle interplay between algorithm design and machine architecture. ",
            "id": "3538292",
            "problem": "Implement a program to quantify the loss of time reversibility due to floating-point round-off in a one-dimensional Hamiltonian system integrated by a symplectic leapfrog scheme. The physical system is a simple harmonic oscillator with dimensionless Hamiltonian given by $H(x,v)=\\tfrac{1}{2}v^{2}+\\tfrac{1}{2}x^{2}$, where $x$ is the position and $v$ is the velocity. The equations of motion are $dx/dt=v$ and $dv/dt=a(x)$ with $a(x)=-x$. The integrator to be used is the leapfrog scheme in the kick-drift-kick composition: a half-step update of $v$ by the acceleration at the current $x$, a full-step update of $x$ by the current $v$, and a final half-step update of $v$ by the acceleration at the new $x$. In exact arithmetic this mapping is time-reversible, meaning that $N$ steps forward with step size $\\Delta t$ followed by $N$ steps backward with step size $-\\Delta t$ exactly returns to the initial state. In floating-point arithmetic, rounding errors break perfect reversibility and produce a nonzero round-trip state error.\n\nStarting from the fundamental laws of motion for the Hamiltonian system and the definition of the leapfrog composition, implement the following procedure in double-precision arithmetic. Let the initial state be $x_{0}=1.234567890123456$ and $v_{0}=-0.987654321098765$, and let machine epsilon be $\\epsilon_{\\mathrm{mach}}$, defined as the distance between $1$ and the next larger representable number in the floating-point format (for double precision, this is given by the standard library constant for the machine epsilon of $64$-bit binary floating-point numbers). Define the forward-backward round-trip error after $N$ leapfrog steps with step size $\\Delta t$ as\n$$\nE(N,\\Delta t)=\\sqrt{\\left(x_{\\mathrm{fb}}-x_{0}\\right)^{2}+\\left(v_{\\mathrm{fb}}-v_{0}\\right)^{2}},\n$$\nwhere $\\left(x_{\\mathrm{fb}},v_{\\mathrm{fb}}\\right)$ is obtained by performing $N$ forward kick-drift-kick steps with $\\Delta t$ followed immediately by $N$ backward kick-drift-kick steps with $-\\Delta t$.\n\nYour program must compute the following diagnostics by fitting scaling exponents on logarithmic axes using the natural logarithm:\n\n- For fixed $\\Delta t=\\;10^{-1}$ and a set of step counts $N\\in\\{10,30,100,300,1000,3000,10000\\}$, estimate the exponent $\\alpha_{N}$ in the scaling $E(N,\\Delta t)\\propto N^{\\alpha_{N}}$ by a least-squares line fit of $\\ln E$ versus $\\ln N$. In addition, compute a dimensionless prefactor $C_{N}$ defined as the median, over the same set of $N$, of the normalized quantity $E(N,\\Delta t)/\\left(\\epsilon_{\\mathrm{mach}}\\,N^{\\alpha_{N}}\\right)$.\n\n- For fixed $N=50000$ and a set of step sizes $\\Delta t\\in\\{10^{-4},3\\times 10^{-4},10^{-3},3\\times 10^{-3},10^{-2}\\}$, estimate the exponent $\\beta_{\\Delta t}$ in the scaling $E(N,\\Delta t)\\propto \\Delta t^{\\beta_{\\Delta t}}$ by a least-squares line fit of $\\ln E$ versus $\\ln \\Delta t$.\n\n- As a boundary condition check, verify that $E(0,\\Delta t)=0$ for $\\Delta t=10^{-1}$, and report this as a boolean.\n\n- As a small-step sanity check, verify that for $\\Delta t=10^{-12}$ and $N=1000$, the round-trip error satisfies $E(N,\\Delta t)\\leq 1000\\,\\epsilon_{\\mathrm{mach}}$, and report this as a boolean.\n\nAll computations are to be performed in dimensionless units. Angles are not used. The final output format must be a single line containing a comma-separated Python-style list with the following five entries in order: $[\\alpha_{N},\\beta_{\\Delta t},C_{N},\\text{boundary\\_check},\\text{small\\_step\\_check}]$, where $\\alpha_{N}$, $\\beta_{\\Delta t}$, and $C_{N}$ are real numbers and the two checks are boolean values. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[0.5,0.0,1.2,\\mathrm{True},\\mathrm{True}]$). This single line is the only output and must be produced without reading any input.\n\nTest suite to be used by the program:\n- For the $N$-scaling fit: $\\Delta t=10^{-1}$ and $N\\in\\{10,30,100,300,1000,3000,10000\\}$.\n- For the $\\Delta t$-scaling fit: $N=50000$ and $\\Delta t\\in\\{10^{-4},3\\times 10^{-4},10^{-3},3\\times 10^{-3},10^{-2}\\}$.\n- Boundary condition check: $N=0$ and $\\Delta t=10^{-1}$.\n- Small-step sanity check: $N=1000$ and $\\Delta t=10^{-12}$.\n\nThe expected types of the outputs are a list of three floats followed by two booleans. No other outputs are permitted.",
            "solution": "The problem statement has been rigorously validated and is determined to be sound. It is scientifically grounded in the principles of Hamiltonian mechanics and numerical analysis, well-posed with a clear and complete set of instructions, and computationally feasible. The objective is to implement a numerical experiment to quantify the loss of time-reversibility in a symplectic integrator due to floating-point arithmetic.\n\nThe solution proceeds by first defining the physical system and the numerical integration scheme, then implementing the forward-backward error measurement protocol, and finally performing the specified scaling analyses and checks.\n\n**1. The Physical System: Simple Harmonic Oscillator**\n\nThe system under consideration is a one-dimensional simple harmonic oscillator, a fundamental model in physics. Its state is described by the position $x$ and velocity $v$. The system's total energy is given by the Hamiltonian $H(x, v)$, which is the sum of kinetic and potential energies:\n$$\nH(x,v) = \\frac{1}{2}v^{2} + \\frac{1}{2}x^{2}\n$$\nIn this dimensionless form, the mass and spring constant are both unity ($m=1$, $k=1$). The evolution of the system is governed by Hamilton's equations of motion:\n$$\n\\frac{dx}{dt} = \\frac{\\partial H}{\\partial v} = v\n$$\n$$\n\\frac{dv}{dt} = -\\frac{\\partial H}{\\partial x} = -x\n$$\nThe second equation gives the acceleration, $a(x) = -x$. The initial state of the system is specified as $(x_0, v_0)$, where $x_{0}=1.234567890123456$ and $v_{0}=-0.987654321098765$.\n\n**2. The Numerical Integrator: Kick-Drift-Kick (KDK) Leapfrog**\n\nSymplectic integrators are a class of numerical methods for Hamiltonian systems that are designed to conserve the phase-space volume element, a property that leads to excellent long-term energy conservation. The leapfrog method is a widely used second-order symplectic integrator. The problem specifies the \"Kick-Drift-Kick\" (KDK) variant.\n\nA single integration step advances the state from $(x_n, v_n)$ at time $t_n$ to $(x_{n+1}, v_{n+1})$ at time $t_{n+1} = t_n + \\Delta t$ via three sequential operations:\n\n1.  **Kick (half step)**: The velocity is updated by a half-step, using the acceleration at the current position $x_n$.\n    $$\n    v_{n+1/2} = v_n + a(x_n) \\frac{\\Delta t}{2}\n    $$\n2.  **Drift (full step)**: The position is updated by a full-step, using the new half-step velocity $v_{n+1/2}$.\n    $$\n    x_{n+1} = x_n + v_{n+1/2} \\Delta t\n    $$\n3.  **Kick (half step)**: The velocity is updated for the remaining half-step, using the acceleration at the new position $x_{n+1}$.\n    $$\n    v_{n+1} = v_{n+1/2} + a(x_{n+1}) \\frac{\\Delta t}{2}\n    $$\nSubstituting $a(x)=-x$, the specific update rules for this problem are:\n$$\nv_{n+1/2} = v_n - x_n \\frac{\\Delta t}{2}\n$$\n$$\nx_{n+1} = x_n + v_{n+1/2} \\Delta t\n$$\n$$\nv_{n+1} = v_{n+1/2} - x_{n+1} \\frac{\\Delta t}{2}\n$$\n\n**3. Quantifying Time-Reversibility Error**\n\nA key property of this integrator is that the mapping from $(x_n, v_n)$ to $(x_{n+1}, v_{n+1})$ is time-reversible in exact arithmetic. This means that advancing for $N$ steps with step size $\\Delta t$ and then reversing for $N$ steps with step size $-\\Delta t$ will perfectly recover the initial state. However, in finite-precision floating-point arithmetic, small round-off errors accumulate at each operation, breaking this perfect symmetry.\n\nThe program quantifies this broken symmetry by computing the round-trip error. Starting from $(x_0, v_0)$:\n1.  Perform $N$ forward steps with step size $\\Delta t$.\n2.  From the resulting state, perform $N$ backward steps by using a step size of $-\\Delta t$.\n3.  The final state is denoted $(x_{\\mathrm{fb}}, v_{\\mathrm{fb}})$.\n\nThe round-trip error, $E(N, \\Delta t)$, is the Euclidean distance in phase space between the initial and final states:\n$$\nE(N,\\Delta t)=\\sqrt{\\left(x_{\\mathrm{fb}}-x_{0}\\right)^{2}+\\left(v_{\\mathrm{fb}}-v_{0}\\right)^{2}}\n$$\nComputations are performed using standard double-precision ($64$-bit) floating-point numbers. The characteristic scale of round-off error is given by machine epsilon, $\\epsilon_{\\mathrm{mach}}$, which is the smallest number such that $1.0 + \\epsilon_{\\mathrm{mach}} \\neq 1.0$.\n\n**4. Analysis of Error Scaling and Checks**\n\nThe program implements the four specific analyses requested:\n\n- **$N$-scaling**: For a fixed step size $\\Delta t = 10^{-1}$ and a range of step counts $N \\in \\{10, 30, 100, 300, 1000, 3000, 10000\\}$, we model the error as $E(N, \\Delta t) \\propto N^{\\alpha_N}$. Taking the natural logarithm gives $\\ln E = \\alpha_N \\ln N + \\text{constant}$. The exponent $\\alpha_N$ is determined by finding the slope of a least-squares linear fit to the $(\\ln N, \\ln E)$ data points. The dimensionless prefactor $C_N$ is then calculated as the median of the values $E(N, \\Delta t) / (\\epsilon_{\\mathrm{mach}} N^{\\alpha_N})$ across the set of $N$. This normalization relates the observed error to the fundamental precision of the arithmetic and the number of steps.\n\n- **$\\Delta t$-scaling**: For a fixed number of steps $N = 50000$ and a range of step sizes $\\Delta t \\in \\{10^{-4}, 3 \\times 10^{-4}, 10^{-3}, 3 \\times 10^{-3}, 10^{-2}\\}$, we model the error as $E(N, \\Delta t) \\propto \\Delta t^{\\beta_{\\Delta t}}$. Similarly, $\\beta_{\\Delta t}$ is found from the slope of a least-squares linear fit to the $(\\ln \\Delta t, \\ln E)$ data. This investigates how the step size itself influences the accumulation of round-off error.\n\n- **Boundary Condition Check**: The case of $N=0$ steps is checked for $\\Delta t = 10^{-1}$. With zero steps, the state should not change, so $(x_{\\mathrm{fb}}, v_{\\mathrm{fb}})$ must be identical to $(x_0, v_0)$ and the error $E(0, \\Delta t)$ must be exactly $0$. A boolean value will report if this condition, $E(0, 10^{-1}) = 0$, holds.\n\n- **Small-Step Sanity Check**: For a very small step size $\\Delta t=10^{-12}$ and $N=1000$ steps, the round-off error is checked against a plausible upper bound. In this regime, truncation error is negligible, and round-off error is expected to dominate. The check verifies if the computed error $E(1000, 10^{-12})$ is less than or equal to $1000 \\, \\epsilon_{\\mathrm{mach}}$.\n\nThe implementation encapsulates this logic, performing the numerical simulations and subsequent data analysis to produce the five required diagnostic values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\ndef solve():\n    \"\"\"\n    Computes diagnostics for the time-reversibility error of a leapfrog integrator\n    applied to a simple harmonic oscillator.\n    \"\"\"\n\n    # --- Problem Setup ---\n    \n    # Initial conditions as specified\n    x0 = 1.234567890123456\n    v0 = -0.987654321098765\n    \n    # Machine epsilon for double precision (64-bit) float\n    eps_mach = sys.float_info.epsilon\n\n    # Acceleration function for H = 0.5*v^2 + 0.5*x^2, so a = -dH/dx = -x\n    def acceleration(x):\n        return -x\n\n    # Kick-Drift-Kick (KDK) leapfrog integrator step\n    def kdk_step(x, v, dt):\n        \"\"\"Advances the state (x, v) by a single KDK step of size dt.\"\"\"\n        v_half = v + acceleration(x) * (dt / 2.0)\n        x_new = x + v_half * dt\n        v_new = v_half + acceleration(x_new) * (dt / 2.0)\n        return x_new, v_new\n\n    # Function to compute the forward-backward round-trip error E(N, dt)\n    def compute_error(N, dt):\n        \"\"\"\n        Calculates the round-trip error after N forward steps and N backward steps.\n        \"\"\"\n        # The boundary case of N=0 means no steps are taken.\n        if N == 0:\n            return 0.0\n\n        # Start from the initial state\n        x, v = x0, v0\n\n        # Forward integration: N steps with dt\n        for _ in range(N):\n            x, v = kdk_step(x, v, dt)\n\n        # Backward integration: N steps with -dt from the final forward state\n        for _ in range(N):\n            x, v = kdk_step(x, v, -dt)\n        \n        # The final state after the round trip is (x_fb, v_fb)\n        x_fb, v_fb = x, v\n        \n        # Calculate the Euclidean error in phase space\n        error = np.sqrt((x_fb - x0)**2 + (v_fb - v0)**2)\n        return error\n\n    # --- Task 1: N-scaling analysis ---\n    dt_for_N_scaling = 1e-1\n    N_values = np.array([10, 30, 100, 300, 1000, 3000, 10000], dtype=float)\n    \n    errors_for_N = np.array([compute_error(int(n), dt_for_N_scaling) for n in N_values])\n    \n    # Perform a linear least-squares fit of log(E) vs log(N) to find the slope alpha_N\n    log_N = np.log(N_values)\n    log_E_N = np.log(errors_for_N)\n    alpha_N, _ = np.polyfit(log_N, log_E_N, 1)\n\n    # Compute the dimensionless prefactor C_N\n    prefactors = errors_for_N / (eps_mach * (N_values ** alpha_N))\n    C_N = np.median(prefactors)\n\n    # --- Task 2: dt-scaling analysis ---\n    N_for_dt_scaling = 50000\n    dt_values = np.array([1e-4, 3e-4, 1e-3, 3e-3, 1e-2], dtype=float)\n\n    errors_for_dt = np.array([compute_error(N_for_dt_scaling, dt) for dt in dt_values])\n\n    # Perform a linear least-squares fit of log(E) vs log(dt) to find the slope beta_dt\n    log_dt = np.log(dt_values)\n    log_E_dt = np.log(errors_for_dt)\n    beta_dt, _ = np.polyfit(log_dt, log_E_dt, 1)\n    \n    # --- Task 3: Boundary condition check ---\n    boundary_check = (compute_error(0, 1e-1) == 0.0)\n\n    # --- Task 4: Small-step sanity check ---\n    error_small_step = compute_error(1000, 1e-12)\n    small_step_check = (error_small_step <= 1000 * eps_mach)\n\n    # --- Final Output Generation ---\n    results = [alpha_N, beta_dt, C_N, boundary_check, small_step_check]\n    \n    # Format the output as a single-line string representation of a list\n    # e.g., \"[0.501,0.012,1.234,True,True]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}