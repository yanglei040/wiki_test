{
    "hands_on_practices": [
        {
            "introduction": "The Coulomb logarithm, $\\ln \\Lambda$, is a cornerstone parameter in the study of two-body relaxation, encapsulating the cumulative effect of numerous weak gravitational encounters. This exercise moves beyond abstract definitions by tasking you with estimating $\\ln \\Lambda$ through a direct Monte Carlo simulation of two-body scattering events (). By comparing your numerical estimate, derived from the exact scattering formula, with the classic logarithmic approximation, you will gain a deeper intuition for the physical origins of this term and the validity of the assumptions that underpin it.",
            "id": "3522134",
            "problem": "You are to design and implement a computational experiment that estimates the Coulomb logarithm, denoted by $\\ln \\Lambda$, from controlled $N$-body gravitational scattering experiments, and validates its expected dependence on the logarithmic range of impact parameters. The target quantity $\\ln \\Lambda$ is dimensionless, and your program must output dimensionless results.\n\nConsider a test particle of speed $v$ moving in a straight line past a field mass $M$ under Newtonian gravity. The gravitational constant is $G$. For a hyperbolic two-body encounter with impact parameter $b$ and asymptotic relative speed $v$, the exact scattering angle $\\theta$ satisfies\n$$\n\\theta(b) = 2 \\arctan\\left(\\frac{G M}{b v^2}\\right),\n$$\nwhere all angles are in radians. The transverse speed change magnitude after one encounter is $|\\Delta v_\\perp| = v \\sin \\theta(b)$. Assume that the distribution of impact parameters is uniform in area within the annulus $b \\in [b_{\\min}, b_{\\max}]$, i.e., with probability density $p(b) \\propto b$. You will perform a Monte Carlo (defined here as a random sampling) experiment that draws $N$ independent encounters with $b$ sampled from this distribution.\n\nYour task is to estimate $\\ln \\Lambda$ using the following principle-based path. Start from Newtonian gravity and the two-body scattering relation above. In the small-angle regime where $\\theta \\ll 1$, one has $\\sin \\theta \\approx \\theta$ and hence $\\Delta v_\\perp \\approx v \\theta$. Show that the mean squared transverse speed change per encounter, averaged over the annulus $[b_{\\min}, b_{\\max}]$ with $p(b) \\propto b$, scales as\n$$\n\\mathbb{E}\\left[\\Delta v_\\perp^2\\right] \\approx \\frac{8 G^2 M^2}{v^2} \\frac{\\ln \\Lambda}{b_{\\max}^2 - b_{\\min}^2},\n$$\nwith $\\ln \\Lambda \\equiv \\ln\\left(\\frac{b_{\\max}}{b_{\\min}}\\right)$ under the assumption that the dominant contribution arises from the logarithmic range of $b$. Invert this relation to form an estimator\n$$\n\\widehat{\\ln \\Lambda} \\equiv \\frac{\\mathbb{E}\\left[\\Delta v_\\perp^2\\right] v^2 (b_{\\max}^2 - b_{\\min}^2)}{8 G^2 M^2}.\n$$\nYour program must implement the following algorithm without any external input:\n\n- Adopt gravitational units with $G = 1$, and express all lengths and masses in consistent arbitrary units. The final answers are dimensionless and require no physical units attached.\n- For each test case, generate $N$ independent impact parameters $b$ by sampling $u \\sim \\text{Uniform}(0,1)$ and setting\n$$\nb = \\sqrt{b_{\\min}^2 + u \\left(b_{\\max}^2 - b_{\\min}^2\\right)}.\n$$\n- For each sampled $b$, compute the exact scattering angle $\\theta(b)$ using the formula above with angles in radians, then compute $\\Delta v_\\perp^2 = \\left(v \\sin \\theta(b)\\right)^2$.\n- Compute the sample mean $\\overline{\\Delta v_\\perp^2}$ and use it in the estimator $\\widehat{\\ln \\Lambda}$ defined above.\n- Also compute the analytic target $\\ln\\left(\\frac{b_{\\max}}{b_{\\min}}\\right)$ and the deviation $\\delta \\equiv \\widehat{\\ln \\Lambda} - \\ln\\left(\\frac{b_{\\max}}{b_{\\min}}\\right)$.\n\nTest suite. Use the following three test cases, each specified as $(M, v, b_{\\min}, b_{\\max}, N, \\text{seed})$:\n\n- Case A (happy path with a broad logarithmic range): $(1, 1000, 10^{-3}, 10^{-1}, 500000, 42)$.\n- Case B (moderate logarithmic range): $(1, 1000, 2 \\times 10^{-3}, 2 \\times 10^{-2}, 500000, 314159)$.\n- Case C (edge case with narrow logarithmic range): $(1, 1000, 10^{-2}, 2 \\times 10^{-2}, 500000, 271828)$.\n\nInstructions and requirements:\n\n- All angles must be in radians.\n- All computations must be carried out in dimensionless gravitational units with $G = 1$.\n- For each test case, compute two floats: $\\widehat{\\ln \\Lambda}$ and $\\delta$.\n- Round each float to $6$ decimal places for reporting.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[\\widehat{\\ln \\Lambda}_A, \\delta_A, \\widehat{\\ln \\Lambda}_B, \\delta_B, \\widehat{\\ln \\Lambda}_C, \\delta_C].\n$$\nNo other output is permitted.",
            "solution": "The problem statement is evaluated to be valid as it is scientifically grounded in Newtonian mechanics, well-posed with a clear objective and sufficient data, and expressed in objective, formal language. It presents a standard problem in computational astrophysics, specifically the numerical investigation of two-body relaxation phenomena. We may therefore proceed with a solution.\n\nThe solution consists of two parts: first, a theoretical derivation of the approximate relationship for the mean squared transverse velocity change, and second, the design of the computational algorithm to estimate the Coulomb logarithm.\n\n**Theoretical Derivation**\n\nThe objective is to derive the approximation\n$$\n\\mathbb{E}\\left[\\Delta v_\\perp^2\\right] \\approx \\frac{8\\, G^2 M^2}{v^2} \\,\\frac{\\ln \\Lambda}{b_{\\max}^2 - b_{\\min}^2}\n$$\nwhere $\\ln \\Lambda \\equiv \\ln(b_{\\max}/b_{\\min})$, under the small-angle scattering approximation.\n\nThe problem states that impact parameters $b$ are drawn from an annulus $[b_{\\min}, b_{\\max}]$ with a probability density $p(b)$ proportional to $b$. The normalization condition for the probability density function is $\\int_{b_{\\min}}^{b_{\\max}} p(b) \\, db = 1$. Let $p(b) = Cb$ for some constant $C$.\n$$\n\\int_{b_{\\min}}^{b_{\\max}} Cb \\, db = C \\left[ \\frac{b^2}{2} \\right]_{b_{\\min}}^{b_{\\max}} = \\frac{C}{2} (b_{\\max}^2 - b_{\\min}^2) = 1\n$$\nSolving for the normalization constant $C$ yields $C = \\frac{2}{b_{\\max}^2 - b_{\\min}^2}$. Therefore, the probability density function is\n$$\np(b) = \\frac{2b}{b_{\\max}^2 - b_{\\min}^2} \\quad \\text{for } b \\in [b_{\\min}, b_{\\max}]\n$$\nThe mean squared transverse speed change, $\\mathbb{E}[\\Delta v_\\perp^2]$, is the expectation value of $(\\Delta v_\\perp(b))^2$ over this distribution:\n$$\n\\mathbb{E}[\\Delta v_\\perp^2] = \\int_{b_{\\min}}^{b_{\\max}} (\\Delta v_\\perp(b))^2 \\, p(b) \\, db\n$$\nWe are given that the magnitude of the transverse speed change is $|\\Delta v_\\perp| = v \\sin \\theta(b)$, where $\\theta(b) = 2 \\arctan\\left(\\frac{GM}{bv^2}\\right)$. The problem asks us to consider the small-angle regime, which corresponds to encounters where the argument of the arctangent function is small, i.e., $\\frac{GM}{bv^2} \\ll 1$. In this limit, $\\arctan(x) \\approx x$, so the scattering angle becomes\n$$\n\\theta(b) \\approx 2 \\left(\\frac{GM}{bv^2}\\right) = \\frac{2GM}{bv^2}\n$$\nSince $\\theta$ is small, we can also use the approximation $\\sin \\theta \\approx \\theta$. The squared transverse speed change is then approximated by\n$$\n(\\Delta v_\\perp(b))^2 = (v \\sin \\theta(b))^2 \\approx (v \\theta(b))^2 \\approx \\left(v \\cdot \\frac{2GM}{bv^2}\\right)^2 = \\left(\\frac{2GM}{bv}\\right)^2 = \\frac{4G^2M^2}{b^2v^2}\n$$\nSubstituting this approximation and the probability density $p(b)$ into the integral for the expectation value, we obtain:\n$$\n\\mathbb{E}[\\Delta v_\\perp^2] \\approx \\int_{b_{\\min}}^{b_{\\max}} \\left(\\frac{4G^2M^2}{b^2v^2}\\right) \\left(\\frac{2b}{b_{\\max}^2 - b_{\\min}^2}\\right) db\n$$\nThe constants can be factored out of the integral:\n$$\n\\mathbb{E}[\\Delta v_\\perp^2] \\approx \\frac{8G^2M^2}{v^2(b_{\\max}^2 - b_{\\min}^2)} \\int_{b_{\\min}}^{b_{\\max}} \\frac{1}{b} \\, db\n$$\nThe remaining integral is elementary:\n$$\n\\int_{b_{\\min}}^{b_{\\max}} \\frac{1}{b} \\, db = [\\ln|b|]_{b_{\\min}}^{b_{\\max}} = \\ln(b_{\\max}) - \\ln(b_{\\min}) = \\ln\\left(\\frac{b_{\\max}}{b_{\\min}}\\right)\n$$\nBy definition, this logarithmic term is the Coulomb logarithm, $\\ln \\Lambda$. Substituting this result back, we arrive at the desired expression:\n$$\n\\mathbb{E}[\\Delta v_\\perp^2] \\approx \\frac{8G^2M^2}{v^2(b_{\\max}^2 - b_{\\min}^2)} \\ln\\left(\\frac{b_{\\max}}{b_{\\min}}\\right) = \\frac{8\\, G^2 M^2}{v^2} \\,\\frac{\\ln \\Lambda}{b_{\\max}^2 - b_{\\min}^2}\n$$\nThis completes the derivation. The problem's estimator for $\\ln \\Lambda$ is obtained by inverting this relation and replacing the true expectation $\\mathbb{E}[\\Delta v_\\perp^2]$ with its sample mean estimator $\\overline{\\Delta v_\\perp^2}$:\n$$\n\\widehat{\\ln \\Lambda} = \\frac{\\overline{\\Delta v_\\perp^2} \\, v^2 \\, (b_{\\max}^2 - b_{\\min}^2)}{8\\, G^2 M^2}\n$$\n\n**Algorithmic Design**\n\nThe computational experiment simulates a large number of two-body encounters to estimate $\\mathbb{E}[\\Delta v_\\perp^2]$ and, from it, the Coulomb logarithm $\\ln \\Lambda$. The simulation proceeds according to the following steps for each test case:\n\n$1$. Set the physical and simulation parameters as specified in the test case: mass $M$, speed $v$, impact parameter range $[b_{\\min}, b_{\\max}]$, number of encounters $N$, and random seed. Set the gravitational constant $G=1$.\n\n$2$. Initialize a pseudo-random number generator with the given seed. This ensures the reproducibility of the results.\n\n$3$. Generate $N$ random impact parameters $b$. The sampling method $b = \\sqrt{b_{\\min}^2 + u(b_{\\max}^2 - b_{\\min}^2)}$ for $u \\sim \\text{Uniform}(0,1)$ correctly generates samples from the distribution with probability density $p(b) \\propto b$, as it corresponds to uniform sampling in the variable $b^2$.\n\n$4$. For each of the $N$ sampled impact parameters $b_i$, calculate the exact squared transverse speed change. This is a multi-step calculation:\n    a. Compute the argument for the scattering angle: $y_i = \\frac{GM}{b_i v^2}$.\n    b. Compute the exact scattering angle in radians: $\\theta_i = 2 \\arctan(y_i)$.\n    c. Compute the squared transverse speed change: $(\\Delta v_{\\perp, i})^2 = (v \\sin \\theta_i)^2$.\n\n$5$. Calculate the sample mean of the $N$ values of $(\\Delta v_{\\perp, i})^2$ to obtain an estimate for the expectation value:\n$$\n\\overline{\\Delta v_\\perp^2} = \\frac{1}{N} \\sum_{i=1}^{N} (\\Delta v_{\\perp, i})^2\n$$\n\n$6$. Use this sample mean in the estimator for the Coulomb logarithm:\n$$\n\\widehat{\\ln \\Lambda} = \\frac{\\overline{\\Delta v_\\perp^2} \\, v^2 \\, (b_{\\max}^2 - b_{\\min}^2)}{8\\, G^2 M^2}\n$$\n\n$7$. Calculate the analytical target value based on the small-angle approximation definition: $\\ln \\Lambda_{\\text{true}} = \\ln(b_{\\max}/b_{\\min})$.\n\n$8$. Compute the deviation $\\delta$ between the estimated and analytical values: $\\delta = \\widehat{\\ln \\Lambda} - \\ln \\Lambda_{\\text{true}}$. The deviation $\\delta$ quantifies the error introduced by the small-angle approximation inherent in the derivation of the estimator, given that the simulation uses the full, exact scattering formula.\n\n$9$. Store the computed floats $\\widehat{\\ln \\Lambda}$ and $\\delta$. After processing all test cases, the collected results are formatted into a single string, with each number rounded to $6$ decimal places as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a computational experiment to estimate the Coulomb logarithm.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (M, v, b_min, b_max, N, seed)\n    test_cases = [\n        # Case A: happy path with a broad logarithmic range\n        (1, 1000, 1e-3, 1e-1, 500000, 42),\n        # Case B: moderate logarithmic range\n        (1, 1000, 2e-3, 2e-2, 500000, 314159),\n        # Case C: edge case with narrow logarithmic range\n        (1, 1000, 1e-2, 2e-2, 500000, 271828),\n    ]\n\n    results = []\n    G = 1.0  # Gravitational constant in dimensionless units\n\n    for case in test_cases:\n        M, v, b_min, b_max, N, seed = case\n\n        # 1. Initialize random number generator with the specified seed\n        rng = np.random.default_rng(seed)\n\n        # 2. Generate N uniform random deviates u in [0, 1)\n        u = rng.uniform(size=N)\n\n        # 3. Generate N impact parameters 'b' from the distribution p(b) ~ b\n        # This is done by sampling b^2 uniformly from [b_min^2, b_max^2]\n        b_min_sq = b_min**2\n        b_max_sq = b_max**2\n        b_sq = b_min_sq + u * (b_max_sq - b_min_sq)\n        b = np.sqrt(b_sq)\n\n        # 4. For each b, compute the exact scattering angle theta\n        # theta = 2 * arctan(G*M / (b * v^2))\n        arg_arctan = (G * M) / (b * v**2)\n        theta = 2.0 * np.arctan(arg_arctan)\n\n        # 5. Compute the squared transverse speed change (delta_v_perp)^2\n        # delta_v_perp = v * sin(theta)\n        delta_v_perp_sq = (v * np.sin(theta))**2\n\n        # 6. Compute the sample mean of (delta_v_perp)^2\n        mean_delta_v_perp_sq = np.mean(delta_v_perp_sq)\n\n        # 7. Use the sample mean in the estimator for ln(Lambda)\n        # estimator_ln_Lambda = (mean * v^2 * (b_max^2 - b_min^2)) / (8 * G^2 * M^2)\n        numerator = mean_delta_v_perp_sq * v**2 * (b_max_sq - b_min_sq)\n        denominator = 8.0 * G**2 * M**2\n        ln_Lambda_hat = numerator / denominator\n\n        # 8. Compute the analytical target ln(b_max / b_min)\n        ln_Lambda_true = np.log(b_max / b_min)\n\n        # 9. Compute the deviation delta\n        delta = ln_Lambda_hat - ln_Lambda_true\n\n        # 10. Append results for this case\n        results.append(ln_Lambda_hat)\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    # Round each float to 6 decimal places for reporting.\n    # The format f'{r:.6f}' ensures proper rounding and trailing zeros.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having explored the statistical nature of the Coulomb logarithm, we now construct the full formalism for dynamical friction. This practice guides you through the first-principles derivation of the Chandrasekhar formula, which describes the drag force on a massive object moving through a sea of lighter particles (). You will then implement this formula numerically to verify its non-monotonic dependence on velocity—a crucial feature where friction peaks at intermediate speeds—and confirm its asymptotic behavior, solidifying your understanding of this fundamental process.",
            "id": "3522189",
            "problem": "A single massive perturber of mass $M$ moves rectilinearly at speed $v$ through an infinite, homogeneous, and isotropic background of field particles. The background has mass density $\\rho$, number density $n$, and a three-dimensional Maxwellian velocity distribution with one-dimensional velocity dispersion $\\sigma$. Gravitational interactions are Newtonian with gravitational constant $G$. Close encounters are regularized by a minimum impact parameter $b_{\\min}$ and a maximum impact parameter $b_{\\max}$, which together define the Coulomb logarithm $\\ln\\Lambda$, where $\\Lambda \\equiv b_{\\max}/b_{\\min}$. The dynamical friction acceleration $a_{\\rm df}$ is the systematic deceleration of the massive body along its direction of motion due to many weak two-body encounters with field particles.\n\nStarting from the fundamental base of Newton's gravitational law, the conservation of momentum for two-body elastic encounters, and the Maxwellian speed distribution of the background, derive an expression for the magnitude of the dynamical friction acceleration $a_{\\rm df}(M,v,\\rho,\\sigma,\\ln\\Lambda)$ as a function of $M$, $v$, $\\rho$, $\\sigma$, and $\\ln\\Lambda$. The derivation must begin from:\n- The gravitational two-body scattering law, including the deflection angle as a function of impact parameter and relative speed.\n- The rate of encounters per unit time with impact parameters in $[b_{\\min}, b_{\\max}]$.\n- The isotropic Maxwellian distribution of background velocities and the projection of the cumulative impulse along the massive body's velocity.\n\nDo not use any shortcut formulas that encode the target concept. Your derivation must show how the functional dependence on $v/\\sigma$ emerges from integrating over the Maxwellian distribution and how the dependence on $\\ln\\Lambda$ arises from integrating the encounter cross section over impact parameters.\n\nOnce you have a closed-form analytic expression for $a_{\\rm df}$, implement a program that computes the magnitude of $a_{\\rm df}$ under the following controlled, dimensionless setup:\n- Adopt units in which $G=1$, $\\rho=1$, and $\\sigma=1$.\n- Use a fixed Coulomb logarithm $\\ln\\Lambda=3$.\n- Treat the output as dimensionless numbers.\n\nVerification objectives:\n- Non-monotonic dependence of $a_{\\rm df}$ on $v$ near $v\\sim\\sigma$.\n- Asymptotic scaling for $v\\ll\\sigma$.\n- Asymptotic scaling for $v\\gg\\sigma$.\n\nDefine and evaluate the following test suite of parameter values, producing results for each test as specified:\n\n- Test 1 (non-monotonic check):\n  - Parameters: $M=1.0$, $v_{\\rm small}=0.05$, $v_{\\rm mid}=1.0$, $v_{\\rm large}=10.0$.\n  - Compute the magnitudes $a_{\\rm df}(M,v_{\\rm small})$, $a_{\\rm df}(M,v_{\\rm mid})$, and $a_{\\rm df}(M,v_{\\rm large})$ in the adopted units.\n  - Also compute a non-monotonic indicator that equals $1$ if $a_{\\rm df}(M,v_{\\rm small})  a_{\\rm df}(M,v_{\\rm mid})$ and $a_{\\rm df}(M,v_{\\rm mid})  a_{\\rm df}(M,v_{\\rm large})$, and equals $0$ otherwise.\n  - Output format for this test: a list of four floats/integers $[a_{\\rm small},a_{\\rm mid},a_{\\rm large},I_{\\rm nonmono}]$.\n\n- Test 2 (low-speed asymptotic check, $v\\ll\\sigma$):\n  - Parameters: $M=2.0$, $v_{\\rm small}=0.02$.\n  - Compute the ratio \n    $$R_{\\rm small} \\equiv \\frac{a_{\\rm df}(M,v_{\\rm small})/v_{\\rm small}}{S_{\\rm small}(M,\\sigma,\\ln\\Lambda)},$$\n    where $S_{\\rm small}(M,\\sigma,\\ln\\Lambda)$ is the exact leading-order small-$v$ slope implied by your derived expression for $a_{\\rm df}$ when $v/\\sigma\\to 0$.\n  - Output format for this test: a single-element list $[R_{\\rm small}]$.\n\n- Test 3 (high-speed asymptotic check, $v\\gg\\sigma$):\n  - Parameters: $M=0.7$, $v_{\\rm large}=50.0$.\n  - Compute the ratio \n    $$R_{\\rm large} \\equiv \\frac{a_{\\rm df}(M,v_{\\rm large})\\,v_{\\rm large}^{2}}{P(M,\\ln\\Lambda,\\rho)},$$\n    where $P(M,\\ln\\Lambda,\\rho)$ is the exact leading-order high-$v$ prefactor implied by your derived expression for $a_{\\rm df}$ when $v/\\sigma\\to\\infty$.\n  - Output format for this test: a single-element list $[R_{\\rm large}]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test’s result provided as a sublist and with no spaces. For the specified test suite, the required final format is:\n  - \"[[$a_{\\rm small}$,$a_{\\rm mid}$,$a_{\\rm large}$,$I_{\\rm nonmono}$],[$R_{\\rm small}$],[$R_{\\rm large}$]]\"\n- In this output, $a_{\\rm small}$, $a_{\\rm mid}$, $a_{\\rm large}$, $R_{\\rm small}$, and $R_{\\rm large}$ are to be printed as plain decimal numbers, and $I_{\\rm nonmono}$ must be printed as an integer $1$ or $0$.\n\nThis problem is universally applicable as a numerical evaluation of a derived analytic expression and does not require angle units. The outputs are dimensionless because of the adopted unit system.",
            "solution": "The user wants a detailed derivation of the dynamical friction acceleration, $a_{\\rm df}$, for a massive object moving through a homogeneous background of field particles, followed by a numerical implementation to verify its properties.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- Massive perturber of mass $M$.\n- Rectilinear motion at speed $v$.\n- Infinite, homogeneous, isotropic background of field particles.\n- Background mass density $\\rho$.\n- Background number density $n$.\n- Background has a three-dimensional Maxwellian velocity distribution with one-dimensional velocity dispersion $\\sigma$.\n- Newtonian gravity with gravitational constant $G$.\n- Close encounters regularized by a minimum impact parameter $b_{\\min}$ and a maximum impact parameter $b_{\\max}$.\n- Coulomb logarithm $\\ln\\Lambda \\equiv \\ln(b_{\\max}/b_{\\min})$.\n- Dynamical friction acceleration is $a_{\\rm df}$.\n- The derivation must start from first principles: two-body scattering, encounter rate, and the Maxwellian distribution.\n- The derivation must not use shortcut formulas.\n- A program must be implemented for a dimensionless setup: $G=1$, $\\rho=1$, $\\sigma=1$.\n- A fixed Coulomb logarithm $\\ln\\Lambda=3$ is used in the program.\n- Test cases are provided to check non-monotonicity and asymptotic scaling.\n- A specific output format is required.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically well-grounded, asking for the derivation of the classic Chandrasekhar dynamical friction formula, a cornerstone of stellar dynamics and computational astrophysics. The premises are standard and form the basis of textbook treatments of the subject. The problem is well-posed, providing all necessary physical parameters and distributions to arrive at a unique analytical expression. The language is precise and objective. The test cases are designed to probe fundamental characteristics of the derived function, ensuring a non-trivial check of the result. The problem is self-contained and logically consistent.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n### Derivation of the Dynamical Friction Formula\n\nThe dynamical friction experienced by a massive object $M$ is the net result of a multitude of individual gravitational two-body encounters with the surrounding field particles. We derive the formula for the acceleration $a_{\\rm df}$ by first considering a single encounter, then integrating over all possible encounters and field particle velocities.\n\n**1. Impulse from a Single Encounter**\n\nConsider an encounter between the massive object of mass $M$ and velocity $\\vec{v}$ and a field particle of mass $m_*$ and velocity $\\vec{v}_*$. We work under the standard assumptions that $M \\gg m_*$ and that the encounters are weak (distant), resulting in small-angle scattering. The second assumption implies that the trajectory of the massive object $M$ is approximately a straight line.\n\nThe force on $M$ due to $m_*$ is given by Newton's law of gravitation. By Newton's third law, the impulse on $M$ is opposite to the impulse on $m_*$. It is simpler to calculate the velocity change of the field particle, $\\Delta\\vec{v}_*$, in the rest frame of $M$. In this frame, $m_*$ approaches with relative velocity $\\vec{w} = \\vec{v}_* - \\vec{v}$. For a weak encounter, the change in velocity of $m_*$ is almost entirely perpendicular to $\\vec{w}$. The magnitude of this perpendicular velocity change is:\n$$ \\Delta v_{*,\\perp} \\approx \\frac{2G(M+m_*)}{w b} $$\nwhere $w = |\\vec{w}|$ and $b$ is the impact parameter. Since we assume $M \\gg m_*$, we approximate $M+m_* \\approx M$, yielding:\n$$ \\Delta v_{*,\\perp} \\approx \\frac{2GM}{w b} $$\nThe change in velocity of the massive object $M$ due to this single encounter is given by conservation of momentum: $M\\Delta\\vec{v} = -m_*\\Delta\\vec{v}_*$. For a single encounter, $\\Delta\\vec{v}$ is directed along $-\\Delta\\vec{v}_*$. However, when we sum over all encounters, we must average over the azimuthal angle of the impact parameter. Due to the symmetry of the setup, the net change in velocity perpendicular to the direction of motion $\\vec{v}$ must be zero. We are interested in the component of acceleration along $\\vec{v}$, which causes the drag.\n\nA more rigorous approach considers the change in the relative velocity vector $\\vec{w}$. In an elastic collision, the magnitude of $\\vec{w}$ is conserved, but its direction is changed by a deflection angle $\\theta$. The change in velocity of $M$ is $\\Delta \\vec{v} = \\frac{m_*}{M+m_*} \\Delta \\vec{w} \\approx \\frac{m_*}{M} \\Delta \\vec{w}$. After averaging over all orientations of the impact parameter plane around the $\\vec{w}$ axis, the only non-zero component of $\\langle\\Delta\\vec{w}\\rangle$ is along $-\\vec{w}$. Its magnitude is $w(1-\\cos\\theta)$.\nThus, the average velocity change of $M$ for a fixed $\\vec{w}$ and $b$ is:\n$$ \\langle\\Delta \\vec{v} \\rangle_{azimuth} \\approx \\frac{m_*}{M} \\left( -w(1-\\cos\\theta) \\hat{w} \\right) $$\nFor weak encounters, the deflection angle $\\theta$ is small, and we can approximate $1-\\cos\\theta \\approx \\theta^2/2$. The scattering angle is related to the impact parameter by $\\theta \\approx \\frac{2G(M+m_*)}{w^2 b} \\approx \\frac{2GM}{w^2b}$.\nSubstituting this gives:\n$$ 1-\\cos\\theta \\approx \\frac{1}{2} \\left( \\frac{2GM}{w^2b} \\right)^2 = \\frac{2G^2M^2}{w^4b^2} $$\nSo, the average velocity change of $M$ is:\n$$ \\langle\\Delta \\vec{v} \\rangle_{azimuth} \\approx -\\frac{m_*}{M} w \\left( \\frac{2G^2M^2}{w^4b^2} \\right) \\hat{w} = - \\frac{2G^2 M m_*}{w^3 b^2} \\hat{w} $$\n\n**2. Summing Over All Encounters**\n\nThe total acceleration on $M$ is found by integrating the contributions from all field particles. The rate of encounters with field stars having velocities in the range $[\\vec{v}_*, \\vec{v}_*+d^3v_*]$ and impact parameters in $[b, b+db]$ is given by $(n_* f(\\vec{v}_*) d^3v_*) (w \\cdot 2\\pi b db)$, where $n_*$ is the number density and $f(\\vec{v}_*)$ is the normalized velocity distribution function.\n\nThe total vector acceleration is:\n$$ \\vec{a}_{\\rm df} = \\int n_* f(\\vec{v}_*) d^3v_* \\int_{b_{\\min}}^{b_{\\max}} w \\langle\\Delta \\vec{v} \\rangle_{azimuth} \\, 2\\pi b \\, db $$\nSubstituting the expression for $\\langle\\Delta\\vec{v}\\rangle_{azimuth}$:\n$$ \\vec{a}_{\\rm df} = \\int n_* f(\\vec{v}_*) d^3v_* \\int_{b_{\\min}}^{b_{\\max}} w \\left( - \\frac{2G^2 M m_*}{w^3 b^2} \\hat{w} \\right) 2\\pi b \\, db $$\nFirst, we perform the integral over the impact parameter $b$:\n$$ \\int_{b_{\\min}}^{b_{\\max}} \\frac{2\\pi b}{b^2} db = 2\\pi [\\ln b]_{b_{\\min}}^{b_{\\max}} = 2\\pi \\ln\\left(\\frac{b_{\\max}}{b_{\\min}}\\right) = 2\\pi \\ln\\Lambda $$\nThis gives:\n$$ \\vec{a}_{\\rm df} = -4\\pi G^2 M (n_*m_*) \\ln\\Lambda \\int f(\\vec{v}_*) \\frac{\\hat{w}}{w^2} d^3v_* $$\nUsing $\\rho = n_*m_*$ for the background mass density and $\\hat{w}/w^2 = \\vec{w}/w^3 = (\\vec{v}-\\vec{v}_*)/|\\vec{v}-\\vec{v}_*|^3$:\n$$ \\vec{a}_{\\rm df} = -4\\pi G^2 M \\rho \\ln\\Lambda \\int f(\\vec{v}_*) \\frac{\\vec{v}-\\vec{v}_*}{|\\vec{v}-\\vec{v}_*|^3} d^3v_* $$\nThis is the general expression for the dynamical friction acceleration.\n\n**3. Integration over the Maxwellian Velocity Distribution**\n\nThe integral $\\vec{I} = \\int f(\\vec{v}_*) \\frac{\\vec{v}-\\vec{v}_*}{|\\vec{v}-\\vec{v}_*|^3} d^3v_*$ is analogous to the gravitational field at position $\\vec{v}$ produced by a mass distribution (in velocity space) with density $f(\\vec{v}_*)$. For an isotropic distribution $f(\\vec{v}_*) = f(v_*)$, Newton's shell theorem applies. The integral simplifies to the contribution from particles slower than $v$:\n$$ \\vec{I} = \\frac{\\vec{v}}{v^3} \\int_{v_*  v} f(\\vec{v}_*) d^3v_* $$\nThe vector $\\vec{I}$ points in the same direction as $\\vec{v}$. Therefore, $\\vec{a}_{\\rm df}$ points in the direction of $-\\vec{v}$, signifying a drag force. The magnitude of the acceleration is:\n$$ a_{\\rm df} = |\\vec{a}_{\\rm df}| = 4\\pi G^2 M \\rho \\ln\\Lambda \\frac{1}{v^2} \\int_{v_*  v} f(\\vec{v}_*) d^3v_* $$\nThe integral represents the fraction of field particles with speeds $v_*$ less than $v$. For the given Maxwellian distribution, $f(\\vec{v}_*) = \\frac{1}{(2\\pi\\sigma^2)^{3/2}} e^{-v_*^2/(2\\sigma^2)}$, this fraction is:\n$$ \\text{Frac}(v) = \\int_0^v 4\\pi v_*^2 \\frac{1}{(2\\pi\\sigma^2)^{3/2}} e^{-v_*^2/(2\\sigma^2)} dv_* $$\nLet's introduce the dimensionless variable $X = v/(\\sqrt{2}\\sigma)$. The integral evaluates to:\n$$ \\text{Frac}(v) = \\text{erf}(X) - \\frac{2X}{\\sqrt{\\pi}}e^{-X^2} $$\nwhere $\\text{erf}(X)$ is the error function.\n\n**4. Final Expression**\n\nCombining all the pieces, we arrive at the final closed-form expression for the magnitude of the dynamical friction acceleration, known as the Chandrasekhar formula:\n$$ a_{\\rm df}(M, v, \\rho, \\sigma, \\ln\\Lambda) = \\frac{4\\pi G^2 M \\rho \\ln\\Lambda}{v^2} \\left[ \\text{erf}\\left(\\frac{v}{\\sqrt{2}\\sigma}\\right) - \\sqrt{\\frac{2}{\\pi}} \\frac{v}{\\sigma} e^{-\\frac{v^2}{2\\sigma^2}} \\right] $$\n\nThis expression demonstrates the dependence on $v/\\sigma$ emerging from the integration over the Maxwellian distribution and the dependence on $\\ln\\Lambda$ from the integration over impact parameters.\n\n### Asymptotic Behavior\n\n- **Low-speed limit ($v \\ll \\sigma$, or $X \\ll 1$):**\nUsing the Taylor series for $\\text{erf}(X) \\approx \\frac{2}{\\sqrt{\\pi}}(X - \\frac{X^3}{3})$ and $e^{-X^2} \\approx 1-X^2$, the term in brackets becomes $\\frac{4X^3}{3\\sqrt{\\pi}}$.\nSubstituting this and $X = v/(\\sqrt{2}\\sigma)$ gives:\n$$ a_{\\rm df} \\approx \\frac{4\\pi G^2 M \\rho \\ln\\Lambda}{v^2} \\frac{4}{3\\sqrt{\\pi}} \\left(\\frac{v}{\\sqrt{2}\\sigma}\\right)^3 = \\left( \\frac{4\\sqrt{2\\pi}}{3} \\frac{G^2 M \\rho \\ln\\Lambda}{\\sigma^3} \\right) v $$\nSo, $a_{\\rm df} \\propto v$. The leading-order slope is $S_{\\rm small} = a_{\\rm df}/v = \\frac{4\\sqrt{2\\pi}}{3} \\frac{G^2 M \\rho \\ln\\Lambda}{\\sigma^3}$.\n\n- **High-speed limit ($v \\gg \\sigma$, or $X \\gg 1$):**\nUsing the asymptotic form $\\text{erf}(X) \\approx 1$, the term in brackets approaches $1$.\n$$ a_{\\rm df} \\approx \\frac{4\\pi G^2 M \\rho \\ln\\Lambda}{v^2} $$\nSo, $a_{\\rm df} \\propto v^{-2}$. The leading-order prefactor is $P = a_{\\rm df} v^2 = 4\\pi G^2 M \\rho \\ln\\Lambda$.\n\nThe non-monotonic behavior arises because the friction is weak at low speeds (few slower particles to interact with), increases to a maximum around $v \\sim \\sigma$, and then decreases at high speeds (less time for gravitational focusing to act effectively).\n\n### Numerical Implementation\n\nThe program below implements the derived formula for $a_{\\rm df}$ under the specified dimensionless unit system ($G=1$, $\\rho=1$, $\\sigma=1$) with $\\ln\\Lambda=3$. It then computes the quantities for the three test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Derives and evaluates the Chandrasekhar dynamical friction formula.\n    \"\"\"\n\n    def get_dynamical_friction(M, v, G=1.0, rho=1.0, sigma=1.0, ln_Lambda=3.0):\n        \"\"\"\n        Computes the magnitude of the dynamical friction acceleration.\n\n        Args:\n            M (float): Mass of the perturber.\n            v (float): Speed of the perturber.\n            G (float): Gravitational constant.\n            rho (float): Mass density of the background.\n            sigma (float): 1D velocity dispersion of the background.\n            ln_Lambda (float): Coulomb logarithm.\n        \n        Returns:\n            float: The magnitude of the dynamical friction acceleration, a_df.\n        \"\"\"\n        if v == 0.0:\n            return 0.0\n\n        X = v / (np.sqrt(2.0) * sigma)\n        \n        # The term in brackets from the velocity integral\n        vel_integral_term = erf(X) - (2.0 * X / np.sqrt(np.pi)) * np.exp(-X**2)\n        \n        # Prefactor\n        prefactor = 4.0 * np.pi * G**2 * M * rho * ln_Lambda\n        \n        a_df = (prefactor / v**2) * vel_integral_term\n        \n        return a_df\n\n    # Common parameters for all tests\n    G_val = 1.0\n    rho_val = 1.0\n    sigma_val = 1.0\n    ln_Lambda_val = 3.0\n\n    # Test 1: Non-monotonic check\n    M1 = 1.0\n    v_small1 = 0.05\n    v_mid1 = 1.0\n    v_large1 = 10.0\n    a_small = get_dynamical_friction(M1, v_small1, ln_Lambda=ln_Lambda_val)\n    a_mid = get_dynamical_friction(M1, v_mid1, ln_Lambda=ln_Lambda_val)\n    a_large = get_dynamical_friction(M1, v_large1, ln_Lambda=ln_Lambda_val)\n    I_nonmono = 1 if (a_small  a_mid and a_mid  a_large) else 0\n    test1_result = [a_small, a_mid, a_large, I_nonmono]\n\n    # Test 2: Low-speed asymptotic check\n    M2 = 2.0\n    v_small2 = 0.02\n    \n    # Exact leading-order small-v slope derived from the formula\n    S_small_analytic = (4.0 * np.sqrt(2.0 * np.pi) / 3.0) * \\\n                       (G_val**2 * M2 * rho_val * ln_Lambda_val) / (sigma_val**3)\n                       \n    # Numerically computed a_df for small v\n    a_df_small_v = get_dynamical_friction(M2, v_small2, ln_Lambda=ln_Lambda_val)\n    \n    # Ratio to check convergence to the asymptotic limit\n    R_small = (a_df_small_v / v_small2) / S_small_analytic\n    test2_result = [R_small]\n\n    # Test 3: High-speed asymptotic check\n    M3 = 0.7\n    v_large3 = 50.0\n\n    # Exact leading-order high-v prefactor derived from the formula\n    P_large_analytic = 4.0 * np.pi * G_val**2 * M3 * rho_val * ln_Lambda_val\n    \n    # Numerically computed a_df for large v\n    a_df_large_v = get_dynamical_friction(M3, v_large3, ln_Lambda=ln_Lambda_val)\n    \n    # Ratio to check convergence to the asymptotic limit\n    R_large = (a_df_large_v * v_large3**2) / P_large_analytic\n    test3_result = [R_large]\n\n    # Format output as specified\n    final_result = [test1_result, test2_result, test3_result]\n    \n    # Function to format lists without spaces\n    def format_list(data):\n        if isinstance(data, list):\n            return f\"[{','.join(map(format_list, data))}]\"\n        elif isinstance(data, (int, float)):\n            if data == int(data):\n                 return str(int(data))\n            return f\"{data:.10f}\".rstrip('0').rstrip('.')\n        return str(data)\n\n    output_str = format_list(final_result)\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "In this final practice, we apply the Chandrasekhar formula to a significant problem in galaxy formation: the orbital decay of satellite galaxies or massive clusters within a dark matter halo. This exercise requires you to model the decay rate as a function of the halo's density profile and investigate the critical phenomenon of \"dynamical friction stalling\" in cored halos (). This connects the theoretical framework of dynamical friction to observable astrophysical consequences and demonstrates how the structure of a host system governs the fate of its massive perturbers.",
            "id": "3522175",
            "problem": "You are to develop a complete and runnable program that models the orbital decay of a massive perturber due to dynamical friction (DF) in a spherically symmetric dark matter halo and evaluates the conditions under which the dynamical friction decay time diverges in a constant-density core. Your derivation and implementation must begin from fundamental principles and well-tested formulas without using any formula that directly encodes the target result.\n\nStart from the following foundation:\n\n- Newton’s law of gravitation and definitions for circular orbits in spherical symmetry:\n  - The circular speed at radius $r$ satisfies $v_{\\mathrm{c}}^2(r) = G M(r)/r$, where $M(r)$ is the enclosed mass.\n  - The gravitational potential gradient satisfies $d\\Phi/dr = v_{\\mathrm{c}}^2(r)/r$.\n  - The specific orbital energy for a circular orbit is $E(r) = \\Phi(r) + v_{\\mathrm{c}}^2(r)/2$.\n- For a power-law density profile $\\rho(r) = \\rho_0 \\left( r/r_0 \\right)^{\\alpha}$ with $\\alpha > -3$, the enclosed mass is $M(r) = 4\\pi \\int_0^r \\rho(s) s^2 ds$.\n- The classical Chandrasekhar dynamical friction for an object of mass $M_{\\mathrm{p}}$ moving at speed $v$ through an isotropic Maxwellian background of density $\\rho$ and one-dimensional velocity dispersion $\\sigma$ gives a deceleration\n  $$\\frac{d\\mathbf{v}}{dt} = - 4\\pi G^2 M_{\\mathrm{p}} \\rho \\ln\\Lambda \\, \\frac{\\mathcal{G}(X)}{v^3}\\, \\mathbf{v}, \\quad \\text{with} \\quad \\mathcal{G}(X) = \\operatorname{erf}(X) - \\frac{2X}{\\sqrt{\\pi}} e^{-X^2}, \\quad X \\equiv \\frac{v}{\\sqrt{2}\\,\\sigma},$$\n  where $\\ln\\Lambda$ is the Coulomb logarithm and $\\operatorname{erf}$ is the error function.\n- The orbital energy loss rate is $dE/dt = \\mathbf{F}_{\\mathrm{df}} \\cdot \\mathbf{v}$ with $\\mathbf{F}_{\\mathrm{df}} = M_{\\mathrm{p}}\\, d\\mathbf{v}/dt$. For a circular orbit, $dE/dt$ determines the radial decay via the chain rule $dE/dr \\cdot dr/dt = dE/dt$.\n\nYou must implement the following algorithmic tasks:\n\n1. Implement the spherical mass model as a pure power-law density $\\rho(r) = \\rho_0 \\left( r/r_0 \\right)^{\\alpha}$ for $-2 \\le \\alpha \\le 0$, with enclosed mass $M(r)$ obtained by direct integration. Using this, compute $v_{\\mathrm{c}}(r)$, $d\\Phi/dr$, $d(v_{\\mathrm{c}}^2)/dr$, and $dE/dr$ for a circular orbit.\n2. Using the Chandrasekhar dynamical friction deceleration given above for an isotropic Maxwellian, compute $dE/dt$ and then $dr/dt$ for a circular orbit through $dr/dt = (dE/dt)/(dE/dr)$.\n3. Characterize the asymptotic small-radius scaling of the radial decay as $dr/dt \\sim - C\\, r^p$ as $r \\to 0^+$. Estimate the exponent $p$ numerically using a two-point logarithmic derivative at two radii $r_1$ and $r_2$ with $r_2 = 10\\, r_1$ and $r_1 \\ll r_0$ (use $r_1 = 10^{-6}\\, r_0$ and $r_2 = 10^{-5}\\, r_0$).\n4. Based on the derived exponent $p$, determine whether the total time to reach $r=0$ diverges. Use the criterion that the time $t = \\int_{0}^{r_{\\mathrm{i}}} dr/|dr/dt|$ diverges if and only if $p \\ge 1$. Report a boolean flag that is true if $p \\ge 1$ and false otherwise.\n5. Derive analytically from first principles the condition on the density slope exponent $\\alpha$ that yields a divergent decay time and verify it numerically via your measured $p$.\n\nPhysical and numerical details:\n\n- Use the gravitational constant $G = 4.30091 \\times 10^{-6}$ in units of $(\\mathrm{kpc})\\, (\\mathrm{km}/\\mathrm{s})^2\\, M_{\\odot}^{-1}$.\n- Adopt constant background one-dimensional velocity dispersion $\\sigma$ for the Maxwellian, and a fixed Coulomb logarithm $\\ln\\Lambda$.\n- Do not output any quantity with physical units. All final outputs must be dimensionless floats or booleans. Internally you may use the above units consistently, but the final output must be unitless.\n\nTest suite:\n\nProvide results for the following three parameter sets. Each case specifies $(\\alpha, \\rho_0, r_0, M_{\\mathrm{p}}, \\sigma, \\ln\\Lambda)$, where $\\rho_0$ is in $M_{\\odot}\\,\\mathrm{kpc}^{-3}$, $r_0$ in $\\mathrm{kpc}$, $M_{\\mathrm{p}}$ in $M_{\\odot}$, and $\\sigma$ in $\\mathrm{km}\\,\\mathrm{s}^{-1}$.\n\n- Case A (constant-density core): $\\alpha = 0$, $\\rho_0 = 10^8$, $r_0 = 1$, $M_{\\mathrm{p}} = 10^7$, $\\sigma = 20$, $\\ln\\Lambda = 3$.\n- Case B (shallow cusp): $\\alpha = -0.5$, $\\rho_0 = 10^8$, $r_0 = 1$, $M_{\\mathrm{p}} = 10^7$, $\\sigma = 20$, $\\ln\\Lambda = 3$.\n- Case C (singular isothermal cusp): $\\alpha = -2$, choose $\\rho_0$ so that $v_{\\mathrm{c}}(r)$ is constant with $v_{\\mathrm{c}} = 30$ at $r_0 = 1$. For $\\alpha=-2$, this requires $\\rho_0 = v_{\\mathrm{c}}^2/(4\\pi G r_0^2)$. Use $M_{\\mathrm{p}} = 10^7$, $\\sigma = 20$, $\\ln\\Lambda = 3$.\n\nProgram outputs:\n\n- For each case, compute:\n  1. The predicted asymptotic exponent $p_{\\mathrm{theory}}$ derived from your analysis.\n  2. The numerically estimated exponent $p_{\\mathrm{num}}$ from the two radii $r_1 = 10^{-6}\\, r_0$ and $r_2 = 10^{-5}\\, r_0$.\n  3. The boolean flag $\\mathrm{diverges}$ indicating whether the total decay time to $r=0$ diverges according to the criterion $p \\ge 1$.\n\n- Your program should produce a single line of output containing the results for the three cases, aggregated in order as a comma-separated list enclosed in square brackets: $[p_{\\mathrm{theory}}^{(A)}, p_{\\mathrm{num}}^{(A)}, \\mathrm{diverges}^{(A)}, p_{\\mathrm{theory}}^{(B)}, p_{\\mathrm{num}}^{(B)}, \\mathrm{diverges}^{(B)}, p_{\\mathrm{theory}}^{(C)}, p_{\\mathrm{num}}^{(C)}, \\mathrm{diverges}^{(C)}]$.\n\nAll mathematical symbols, variables, functions, operators, and numbers in this problem statement must be written in LaTeX between dollar signs. No angles are involved. No outputs with physical units are required; all outputs are dimensionless. Ensure scientific realism by using the provided constants and parameter ranges exactly as stated.",
            "solution": "We are to determine the conditions for which the dynamical friction (DF) decay time to $r=0$ diverges in a spherical halo with a power-law density profile. The framework uses Newtonian gravity and Chandrasekhar’s DF formula in an isotropic Maxwellian background.\n\nStep 1: Circular orbital dynamics in a spherical power-law density.\n\nLet $\\rho(r) = \\rho_0 \\left( r / r_0 \\right)^{\\alpha}$ with $\\alpha > -3$. The enclosed mass is\n$$\nM(r) = 4\\pi \\int_0^r \\rho(s) s^2 ds\n= 4\\pi \\rho_0 r_0^{-\\alpha} \\frac{r^{\\alpha+3}}{\\alpha + 3}.\n$$\nThe circular speed is\n$$\nv_{\\mathrm{c}}^2(r) = \\frac{G M(r)}{r}\n= \\frac{4\\pi G \\rho_0}{\\alpha+3} r_0^{-\\alpha} r^{\\alpha+2}.\n$$\nThe gravitational potential gradient satisfies $d\\Phi/dr = v_{\\mathrm{c}}^2/r \\propto r^{\\alpha+1}$. For the specific energy of a circular orbit $E(r) = \\Phi(r) + v_{\\mathrm{c}}^2(r)/2$, we have\n$$\n\\frac{dE}{dr} = \\frac{d\\Phi}{dr} + \\frac{1}{2}\\frac{d\\, v_{\\mathrm{c}}^2}{dr}.\n$$\nWe can evaluate $d\\, v_{\\mathrm{c}}^2/dr$ directly from $v_{\\mathrm{c}}^2 = G M(r)/r$:\n$$\n\\frac{d\\, v_{\\mathrm{c}}^2}{dr} = G \\frac{M' r - M}{r^2}, \\quad \\text{where} \\quad M' = \\frac{dM}{dr} = 4\\pi r^2 \\rho(r).\n$$\nFor the power law, $M' \\propto r^{\\alpha+2}$ and $M \\propto r^{\\alpha+3}$, so $M' r - M \\propto (\\alpha+2)r^{\\alpha+3}$.\nThus, in all these cases, $dE/dr \\propto r^{\\alpha+1}$. For the special case $\\alpha = -2$ (singular isothermal), $v_{\\mathrm{c}}$ is constant, $d(v_{\\mathrm{c}}^2)/dr = 0$, and $d\\Phi/dr = v_{\\mathrm{c}}^2/r \\propto r^{-1}$, which still matches $r^{\\alpha+1}$ with $\\alpha + 1 = -1$.\n\nThus, in all these cases,\n$$\n\\frac{dE}{dr} \\propto r^{\\alpha+1}.\n$$\n\nStep 2: Chandrasekhar dynamical friction and $dE/dt$.\n\nChandrasekhar’s DF deceleration for a massive perturber of mass $M_{\\mathrm{p}}$ moving at speed $v$ through an isotropic Maxwellian background with density $\\rho$ and one-dimensional dispersion $\\sigma$ is\n$$\n\\frac{d\\mathbf{v}}{dt} = - 4\\pi G^2 M_{\\mathrm{p}} \\rho \\ln\\Lambda \\, \\frac{\\mathcal{G}(X)}{v^3}\\, \\mathbf{v}, \\quad\n\\mathcal{G}(X) = \\operatorname{erf}(X) - \\frac{2X}{\\sqrt{\\pi}} e^{-X^2}, \\quad X = \\frac{v}{\\sqrt{2}\\,\\sigma}.\n$$\nThe DF force is $\\mathbf{F}_{\\mathrm{df}} = M_{\\mathrm{p}}\\, d\\mathbf{v}/dt$, so the energy loss rate is\n$$\n\\frac{dE}{dt} = \\mathbf{F}_{\\mathrm{df}} \\cdot \\mathbf{v}\n= - 4\\pi G^2 M_{\\mathrm{p}}^2 \\rho \\ln\\Lambda \\, \\frac{\\mathcal{G}(X)}{v}.\n$$\nOn a circular orbit, $v = v_{\\mathrm{c}}(r)$.\n\nWe must consider the small-radius limit. For $\\alpha > -2$, the circular speed $v_{\\mathrm{c}} \\propto r^{(\\alpha+2)/2}$ tends to zero as $r \\to 0$. In that limit, $X \\to 0$ and the function $\\mathcal{G}(X)$ has the expansion\n$$\n\\mathcal{G}(X) = \\frac{4}{3\\sqrt{\\pi}} X^3 + \\mathcal{O}(X^5).\n$$\nTherefore, for $\\alpha > -2$, the energy loss rate scales as\n$$\n\\frac{dE}{dt} \\propto \\rho \\frac{X^3}{v} \\propto \\rho \\frac{v^3}{\\sigma^3} \\frac{1}{v} \\propto \\rho \\, v^2.\n$$\nUsing $v^2 \\propto r^{\\alpha+2}$ and $\\rho \\propto r^{\\alpha}$, we get\n$$\n\\frac{dE}{dt} \\propto r^{\\alpha} r^{\\alpha+2} = r^{2\\alpha + 2}.\n$$\nFor the special isothermal case $\\alpha = -2$, $v$ is constant and $X$ is constant, so $\\mathcal{G}(X)$ is a constant and\n$$\n\\frac{dE}{dt} \\propto \\frac{\\rho}{v} \\propto r^{\\alpha} = r^{-2}.\n$$\n\nStep 3: Asymptotic scaling for $dr/dt$.\n\nCombining $dE/dr \\propto r^{\\alpha+1}$ with the above $dE/dt$ scalings, the radial decay rate is\n$$\n\\frac{dr}{dt} = \\frac{dE/dt}{dE/dr} \\propto\n\\begin{cases}\nr^{2\\alpha+2} / r^{\\alpha+1} = r^{\\alpha+1},  \\alpha > -2, \\\\\nr^{\\alpha} / r^{\\alpha+1} = r^{\\alpha- \\alpha -1} = r^{-1},  \\alpha = -2.\n\\end{cases}\n$$\nBoth cases can be written compactly as\n$$\n\\frac{dr}{dt} \\sim - C\\, r^{p}, \\quad \\text{with} \\quad p = \\alpha + 1,\n$$\nwhere $C > 0$ is a constant determined by $G$, $M_{\\mathrm{p}}$, $\\rho_0$, $\\sigma$, $\\ln\\Lambda$, and $r_0$. The negative sign indicates inward decay.\n\nStep 4: Divergence of the decay time.\n\nThe time to decay from radius $r_{\\mathrm{i}}$ to $r=0$ is, near the center,\n$$\nt \\sim \\int_{0}^{r_{\\mathrm{i}}} \\frac{dr}{C\\, r^{p}} =\n\\begin{cases}\n\\frac{r_{\\mathrm{i}}^{1-p}}{C(1-p)},  p  1 \\quad (\\text{finite}), \\\\\n\\infty,  p \\ge 1.\n\\end{cases}\n$$\nThus, the total decay time to reach exactly $r=0$ diverges if and only if $p \\ge 1$, i.e.,\n$$\n\\alpha + 1 \\ge 1 \\quad \\Longleftrightarrow \\quad \\alpha \\ge 0.\n$$\nIn particular, for a constant-density core with $\\alpha = 0$, we have $p=1$, so $dr/dt \\propto - r$ and $r(t)$ decays exponentially, $r(t) \\propto e^{-t/\\tau}$ with a finite e-folding time $\\tau$, yet the time to reach $r=0$ strictly diverges, $t_{\\mathrm{df}} \\to \\infty$.\n\nStep 5: Numerical estimation and verification.\n\nTo verify numerically, we compute $dr/dt$ at two small radii $r_1 = 10^{-6} r_0$ and $r_2 = 10^{-5} r_0$ using the exact expressions for $dE/dt$ and $dE/dr$, and estimate\n$$\np_{\\mathrm{num}} = \\frac{\\ln\\left( |dr/dt|(r_2) \\right) - \\ln\\left( |dr/dt|(r_1) \\right)}{\\ln(r_2) - \\ln(r_1)}.\n$$\nWe also compute the theoretical prediction $p_{\\mathrm{theory}} = \\alpha + 1$ and set $\\mathrm{diverges} = \\text{true}$ if $p_{\\mathrm{theory}} \\ge 1$ and false otherwise.\n\nTest cases:\n\n- Case A: $\\alpha=0$ (constant-density core) yields $p_{\\mathrm{theory}} = 1$ and hence divergent total decay time $t_{\\mathrm{df}} \\to \\infty$. Numerically, $p_{\\mathrm{num}}$ should be very close to $1$.\n- Case B: $\\alpha=-0.5$ (shallow cusp) yields $p_{\\mathrm{theory}} = 0.5$ and finite total decay time. Numerically, $p_{\\mathrm{num}}$ should be near $0.5$.\n- Case C: $\\alpha=-2$ (singular isothermal) yields $p_{\\mathrm{theory}} = -1$ and finite total decay time. Numerically, $p_{\\mathrm{num}}$ should be near $-1$.\n\nOutput specification:\n\nYour program must compute $[p_{\\mathrm{theory}}^{(A)}, p_{\\mathrm{num}}^{(A)}, \\mathrm{diverges}^{(A)}, p_{\\mathrm{theory}}^{(B)}, p_{\\mathrm{num}}^{(B)}, \\mathrm{diverges}^{(B)}, p_{\\mathrm{theory}}^{(C)}, p_{\\mathrm{num}}^{(C)}, \\mathrm{diverges}^{(C)}]$ and print a single line in this exact list format. All outputs are dimensionless and unitless. No other text should be printed.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\n# Physical constant in kpc (km/s)^2 / Msun\nG = 4.30091e-6\n\ndef g_maxwellian(X: float) - float:\n    \"\"\"Chandrasekhar Maxwellian velocity factor G(X) = erf(X) - 2X e^{-X^2}/sqrt(pi).\"\"\"\n    # Use math.erf for numerical stability at small X.\n    return math.erf(X) - (2.0 * X / math.sqrt(math.pi)) * math.exp(-X * X)\n\ndef enclosed_mass_powerlaw(r: float, rho0: float, r0: float, alpha: float) - float:\n    \"\"\"Enclosed mass for rho = rho0 (r/r0)^alpha for alpha  -3.\"\"\"\n    # M(r) = 4 pi rho0 r0^{-alpha} r^{alpha+3} / (alpha+3)\n    return 4.0 * math.pi * rho0 * (r ** (alpha + 3)) * (r0 ** (-alpha)) / (alpha + 3.0)\n\ndef density_powerlaw(r: float, rho0: float, r0: float, alpha: float) - float:\n    \"\"\"Density rho = rho0 (r/r0)^alpha.\"\"\"\n    return rho0 * (r / r0) ** alpha\n\ndef circular_speed_sq(r: float, rho0: float, r0: float, alpha: float) - float:\n    \"\"\"v_c^2(r) for power-law density.\"\"\"\n    Menc = enclosed_mass_powerlaw(r, rho0, r0, alpha)\n    return G * Menc / max(r, 1e-300)\n\ndef dE_dr_circular(r: float, rho0: float, r0: float, alpha: float) - float:\n    \"\"\"dE/dr for a circular orbit in spherical power-law density.\"\"\"\n    # dPhi/dr = v_c^2 / r\n    vc2 = circular_speed_sq(r, rho0, r0, alpha)\n    dPhi_dr = vc2 / max(r, 1e-300)\n    # dv_c^2/dr = G [M' r - M] / r^2, with M' = 4 pi r^2 rho\n    Menc = enclosed_mass_powerlaw(r, rho0, r0, alpha)\n    rho = density_powerlaw(r, rho0, r0, alpha)\n    Mprime = 4.0 * math.pi * r * r * rho\n    dv2_dr = G * (Mprime * r - Menc) / max(r * r, 1e-300)\n    return dPhi_dr + 0.5 * dv2_dr\n\ndef dE_dt_df(r: float, rho0: float, r0: float, alpha: float, Mp: float, sigma: float, lnLambda: float) - float:\n    \"\"\"Energy loss rate dE/dt = F_df · v for a circular orbit under Chandrasekhar DF.\"\"\"\n    rho = density_powerlaw(r, rho0, r0, alpha)\n    vc2 = circular_speed_sq(r, rho0, r0, alpha)\n    v = math.sqrt(max(vc2, 0.0))\n    # Avoid divide-by-zero: if v ~ 0, use the limiting behavior automatically via g(X) ~ X^3.\n    X = v / (math.sqrt(2.0) * sigma)\n    GX = g_maxwellian(X)\n    # dE/dt = - 4 pi G^2 Mp^2 rho lnLambda * G(X) / v\n    denom = max(v, 1e-300)\n    return - 4.0 * math.pi * (G ** 2) * (Mp ** 2) * rho * lnLambda * GX / denom\n\ndef dr_dt(r: float, rho0: float, r0: float, alpha: float, Mp: float, sigma: float, lnLambda: float) - float:\n    \"\"\"Radial decay rate dr/dt = (dE/dt)/(dE/dr) for a circular orbit.\"\"\"\n    dEdr = dE_dr_circular(r, rho0, r0, alpha)\n    dEdt = dE_dt_df(r, rho0, r0, alpha, Mp, sigma, lnLambda)\n    # Inward decay = typically negative dr/dt\n    denom = dEdr if abs(dEdr)  1e-300 else (1e-300 if dEdr = 0 else -1e-300)\n    return dEdt / denom\n\ndef estimate_p_numeric(r1: float, r2: float, params: dict) - float:\n    \"\"\"Estimate p from |dr/dt| ~ r^p using two nearby radii r1 and r2.\"\"\"\n    drdt1 = dr_dt(r1, **params)\n    drdt2 = dr_dt(r2, **params)\n    y1 = math.log(abs(drdt1) + 1e-300)\n    y2 = math.log(abs(drdt2) + 1e-300)\n    x1 = math.log(r1)\n    x2 = math.log(r2)\n    # slope of log|dr/dt| vs log r\n    return (y2 - y1) / (x2 - x1)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a dict of parameters for the model:\n    # alpha, rho0, r0, Mp, sigma, lnLambda\n    # Case A: core\n    case_A = {\n        \"alpha\": 0.0,\n        \"rho0\": 1e8,        # Msun/kpc^3\n        \"r0\": 1.0,          # kpc\n        \"Mp\": 1e7,          # Msun\n        \"sigma\": 20.0,      # km/s\n        \"lnLambda\": 3.0\n    }\n    # Case B: shallow cusp\n    case_B = {\n        \"alpha\": -0.5,\n        \"rho0\": 1e8,        # Msun/kpc^3 at r0\n        \"r0\": 1.0,\n        \"Mp\": 1e7,\n        \"sigma\": 20.0,\n        \"lnLambda\": 3.0\n    }\n    # Case C: isothermal cusp alpha=-2 with rho0 chosen for vc=30 km/s at r0=1 kpc\n    # For alpha=-2, vc^2 = 4 pi G rho0 r0^2 = rho0 = vc^2 / (4 pi G r0^2)\n    vc_iso = 30.0\n    rho0_iso = (vc_iso ** 2) / (4.0 * math.pi * G * (1.0 ** 2))\n    case_C = {\n        \"alpha\": -2.0,\n        \"rho0\": rho0_iso,\n        \"r0\": 1.0,\n        \"Mp\": 1e7,\n        \"sigma\": 20.0,\n        \"lnLambda\": 3.0\n    }\n\n    test_cases = [case_A, case_B, case_C]\n\n    # Radii for numerical slope estimation (small radii)\n    r1_factor = 1e-6\n    r2_factor = 1e-5\n\n    results = []\n    for case in test_cases:\n        alpha = case[\"alpha\"]\n        r0 = case[\"r0\"]\n        r1 = r1_factor * r0\n        r2 = r2_factor * r0\n        # Compute theoretical p\n        p_theory = alpha + 1.0\n        # Compute numerical p\n        params = {\n            \"rho0\": case[\"rho0\"],\n            \"r0\": case[\"r0\"],\n            \"alpha\": case[\"alpha\"],\n            \"Mp\": case[\"Mp\"],\n            \"sigma\": case[\"sigma\"],\n            \"lnLambda\": case[\"lnLambda\"]\n        }\n        p_num = estimate_p_numeric(r1, r2, params)\n        # Divergence criterion\n        diverges = (p_theory = 1.0)\n        # Append results in the specified order: p_theory, p_num, diverges per case\n        results.extend([p_theory, p_num, diverges])\n\n    # Final print statement in the exact required format.\n    # Ensure booleans are printed as lowercase \"true\" or \"false\".\n    def format_results(res_list):\n        out = []\n        for item in res_list:\n            if isinstance(item, bool):\n                out.append(str(item).lower())\n            else:\n                out.append(str(item))\n        return out\n    \n    print(f\"[{','.join(format_results(results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}