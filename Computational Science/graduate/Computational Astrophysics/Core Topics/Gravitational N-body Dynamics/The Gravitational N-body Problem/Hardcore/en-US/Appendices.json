{
    "hands_on_practices": [
        {
            "introduction": "The gravitational $N$-body problem begins with the foundational case of $N=2$. This exercise reinforces the analytical solution for the two-body problem, which serves as both a crucial test case for any $N$-body code and the basis for our intuition about orbital dynamics. By reducing the complex dance of two bodies to an equivalent one-body problem, you will derive Kepler's third law from first principles and understand why the total mass $M$ governs the orbital period .",
            "id": "3540212",
            "problem": "In a Newtonian gravitational setting, consider an isolated subsystem of two point masses with masses $m_{1}$ and $m_{2}$ interacting only through their mutual gravitational force. Let the system be bound, with the relative orbit forming an ellipse of semi-major axis $a$. Starting solely from Newton’s second law, the inverse-square law of gravitation, and the definitions of the center of mass and angular momentum, reduce the two-body problem to an equivalent one-body problem in the center-of-mass frame and derive the orbital period $T$ of the bound relative motion as a function of $a$, the gravitational constant $G$, and the total mass $M = m_{1} + m_{2}$. Your derivation must justify why the dependence on mass enters only through $M$ and not through $m_{1}$ and $m_{2}$ separately. Do not quote or assume any pre-existing period–semi-major axis relations; instead, reason from first principles, including conservation laws and the geometry of conic sections as needed.\n\nProvide your final answer as a single analytic expression in terms of $a$, $G$, $M$, and $\\pi$. No numerical evaluation is required and no units should be included in the final expression.",
            "solution": "The problem is validated as scientifically grounded, well-posed, objective, and self-contained. The derivation proceeds from first principles as stipulated.\n\nLet the position vectors of the two point masses $m_{1}$ and $m_{2}$ be $\\vec{r}_{1}$ and $\\vec{r}_{2}$, respectively. The system is isolated, so the only forces acting are their mutual gravitational attraction. According to Newton's second law and the law of universal gravitation, the equations of motion for the two masses are:\n$$m_{1}\\ddot{\\vec{r}}_{1} = \\vec{F}_{12} = G\\frac{m_{1}m_{2}}{|\\vec{r}_{2} - \\vec{r}_{1}|^{3}}(\\vec{r}_{2} - \\vec{r}_{1})$$\n$$m_{2}\\ddot{\\vec{r}}_{2} = \\vec{F}_{21} = G\\frac{m_{1}m_{2}}{|\\vec{r}_{1} - \\vec{r}_{2}|^{3}}(\\vec{r}_{1} - \\vec{r}_{2})$$\nNote that $\\vec{F}_{12} = -\\vec{F}_{21}$, consistent with Newton's third law.\n\nTo reduce this two-body problem, we introduce two new coordinates: the position vector of the center of mass, $\\vec{R}_{CM}$, and the relative position vector, $\\vec{r}$.\nThe center of mass is defined as:\n$$\\vec{R}_{CM} = \\frac{m_{1}\\vec{r}_{1} + m_{2}\\vec{r}_{2}}{m_{1} + m_{2}}$$\nThe total mass of the system is $M = m_{1} + m_{2}$. Differentiating $\\vec{R}_{CM}$ twice with respect to time gives its acceleration:\n$$\\ddot{\\vec{R}}_{CM} = \\frac{m_{1}\\ddot{\\vec{r}}_{1} + m_{2}\\ddot{\\vec{r}}_{2}}{M} = \\frac{\\vec{F}_{12} + \\vec{F}_{21}}{M} = \\frac{\\vec{0}}{M} = \\vec{0}$$\nThis shows that the center of mass moves at a constant velocity, meaning the center-of-mass frame is an inertial frame.\n\nThe relative position vector is defined as $\\vec{r} = \\vec{r}_{1} - \\vec{r}_{2}$. Its second time derivative is:\n$$\\ddot{\\vec{r}} = \\ddot{\\vec{r}}_{1} - \\ddot{\\vec{r}}_{2} = \\frac{\\vec{F}_{12}}{m_{1}} - \\frac{\\vec{F}_{21}}{m_{2}}$$\nSubstituting the expressions for the forces, and noting that $\\vec{F}_{21} = -\\vec{F}_{12}$ and $\\vec{r}_{2} - \\vec{r}_{1} = -\\vec{r}$:\n$$\\ddot{\\vec{r}} = \\frac{1}{m_{1}}\\left(-G\\frac{m_{1}m_{2}}{r^{3}}\\vec{r}\\right) - \\frac{1}{m_{2}}\\left(G\\frac{m_{1}m_{2}}{r^{3}}\\vec{r}\\right)$$\n$$\\ddot{\\vec{r}} = -G\\frac{m_{2}}{r^{3}}\\vec{r} - G\\frac{m_{1}}{r^{3}}\\vec{r} = -G\\frac{(m_{1} + m_{2})}{r^{3}}\\vec{r}$$\nSubstituting $M = m_{1} + m_{2}$, we obtain the equation of motion for the relative coordinate:\n$$\\ddot{\\vec{r}} = -\\frac{GM}{r^{3}}\\vec{r}$$\nThis equation describes the motion of a hypothetical particle whose position is given by the relative vector $\\vec{r}$ under the influence of a central force originating from a fixed point, where the effective mass governing the acceleration is the total mass $M = m_{1} + m_{2}$. This step provides the explicit justification for why the dynamics depend on the sum of the masses, $M$, and not on $m_{1}$ or $m_{2}$ individually. The two-body problem is thus reduced to an equivalent one-body problem.\n\nThe force is purely central (directed along $\\vec{r}$), which implies that the specific angular momentum, $\\vec{h} = \\vec{r} \\times \\dot{\\vec{r}}$, is a conserved quantity.\n$$\\dot{\\vec{h}} = \\frac{d}{dt}(\\vec{r} \\times \\dot{\\vec{r}}) = \\dot{\\vec{r}} \\times \\dot{\\vec{r}} + \\vec{r} \\times \\ddot{\\vec{r}} = \\vec{0} + \\vec{r} \\times \\left(-\\frac{GM}{r^{3}}\\vec{r}\\right) = \\vec{0}$$\nThe conservation of $\\vec{h}$ means the motion is confined to a plane perpendicular to the constant vector $\\vec{h}$. The magnitude of the specific angular momentum is $h = |\\vec{h}|$. In this plane, the rate at which the relative position vector sweeps out area is given by the areal velocity:\n$$\\frac{dA}{dt} = \\frac{1}{2}|\\vec{r} \\times \\dot{\\vec{r}}| = \\frac{h}{2}$$\nSince $h$ is constant, the areal velocity is constant (Kepler's second law). The orbital period $T$ is the total time required to sweep the entire area $A$ of the ellipse. Therefore,\n$$T = \\frac{A}{dA/dt} = \\frac{A}{h/2}$$\nThe area of an ellipse with semi-major axis $a$ and semi-minor axis $b$ is $A = \\pi a b$. Thus, the period is:\n$$T = \\frac{2\\pi a b}{h}$$\n\nTo find the period, we must relate $h$ and $b$ to the given parameters $a$ and $M$. This requires solving the equation of motion for the orbit. The general solution for the path $\\vec{r}(t)$ under an inverse-square force is a conic section. For a bound orbit, it is an ellipse with the origin (the center of mass of the effective one-body system) at one focus. The equation of this ellipse in polar coordinates $(r, \\theta)$ is:\n$$r = \\frac{p}{1 + e\\cos\\theta}$$\nwhere $e$ is the eccentricity ($0 \\le e  1$ for an ellipse) and $p$ is the semi-latus rectum. A standard result from solving the differential equation of motion $\\ddot{\\vec{r}} = -GM\\vec{r}/r^{3}$ is the relation between the specific angular momentum and the semi-latus rectum:\n$$h^{2} = GMp$$\nFor an ellipse, the semi-latus rectum $p$ and semi-minor axis $b$ are related to the semi-major axis $a$ and eccentricity $e$ by:\n$$p = a(1 - e^{2})$$\n$$b = a\\sqrt{1 - e^{2}}$$\nSubstituting the expression for $p$ into the equation for $h^2$:\n$$h^{2} = GMa(1 - e^{2})$$\nNow we can express the period $T$ in terms of $a$, $G$, and $M$. We start with our expression for the period and square it:\n$$T^{2} = \\left(\\frac{2\\pi a b}{h}\\right)^{2} = \\frac{4\\pi^{2}a^{2}b^{2}}{h^{2}}$$\nSubstitute $b^{2} = a^{2}(1-e^{2})$ and $h^{2} = GMa(1-e^{2})$:\n$$T^{2} = \\frac{4\\pi^{2}a^{2}\\left(a^{2}(1-e^{2})\\right)}{GMa(1-e^{2})}$$\nThe term $(1-e^{2})$ cancels from the numerator and denominator, indicating the period depends on the semi-major axis but not the eccentricity.\n$$T^{2} = \\frac{4\\pi^{2}a^{4}}{GMa} = \\frac{4\\pi^{2}a^{3}}{GM}$$\nTaking the square root of both sides gives the final expression for the orbital period:\n$$T = 2\\pi\\sqrt{\\frac{a^{3}}{GM}}$$\nThis is the generalized form of Kepler's third law, derived entirely from first principles as required.",
            "answer": "$$ \\boxed{2\\pi\\sqrt{\\frac{a^{3}}{GM}}} $$"
        },
        {
            "introduction": "Before writing a single line of integration code, a computational astrophysicist must bridge the gap between physical reality and the dimensionless world of the computer. This practice guides you through the essential process of choosing a system of \"code units\" where quantities like the gravitational constant are set to unity ($G=1$) . Properly scaling a physical system, such as a globular cluster, into a numerically stable domain is a critical step for minimizing floating-point errors and ensuring a robust simulation.",
            "id": "3540198",
            "problem": "You are preparing a direct gravitational N-body simulation of a realistic globular cluster in code units with $G=1$, $M=1$, and $L=1$, where $G$ is the gravitational constant, $M$ is the mass unit, and $L$ is the length unit. The physical target system has total mass $M_{\\mathrm{phys}} \\approx 10^{5}\\,\\mathrm{M}_{\\odot}$, half-mass radius $R_{\\mathrm{h}} \\approx 3\\,\\mathrm{pc}$, and a one-dimensional velocity dispersion at $R_{\\mathrm{h}}$ of order $10$–$15\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$. You will run the simulation in double-precision floating-point (DPFP) arithmetic with machine epsilon $\\epsilon_{\\mathrm{mach}} \\approx 2.22\\times 10^{-16}$, and you want to minimize round-off and overflow or underflow risks throughout the integration and diagnostics (positions, velocities, accelerations, energies, and time steps). Assume no external tides and equal-mass particles.\n\nStarting from Newton’s law of gravitation and dimensional analysis, determine which of the following choices of physical unit scaling $(M_{\\mathrm{unit}},L_{\\mathrm{unit}})$ for the code’s $(G=1, M=1, L=1)$ best maps the globular cluster to code-space so that typical dimensionless positions near $R_{\\mathrm{h}}$, velocity dispersion, and crossing time are all of order unity. Use the widely accepted astrophysical value $G_{\\mathrm{phys}} \\approx 4.302\\times 10^{-3}\\,\\mathrm{pc}\\,\\mathrm{M}_{\\odot}^{-1}\\,(\\mathrm{km}/\\mathrm{s})^{2}$ and the conversion $1\\,\\mathrm{pc}/(\\mathrm{km}/\\mathrm{s}) \\approx 0.9778\\,\\mathrm{Myr}$ if needed. Your choice must be justified by first-principles reasoning that links the scaling to the characteristic dynamical scales and explains why it minimizes numerical risk in DPFP.\n\nWhich option is most appropriate?\n\n- A. $M_{\\mathrm{unit}} = 10^{6}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 1\\,\\mathrm{pc}$.\n\n- B. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 3\\,\\mathrm{pc}$.\n\n- C. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 0.1\\,\\mathrm{pc}$.\n\n- D. $M_{\\mathrm{unit}} = 5\\times 10^{4}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 10\\,\\mathrm{pc}$.\n\nAnswer by selecting the single best option and justify it from first principles, explaining what the code-unit velocity and time scales are in physical units for each choice, and why your selection reduces round-off and overflow or underflow risks in DPFP arithmetic for the intended globular cluster model.",
            "solution": "The user wants me to identify the most appropriate choice of physical units for an N-body simulation of a globular cluster. The goal is to scale the problem such that the characteristic physical quantities map to dimensionless code-unit values of order unity, thereby minimizing numerical errors.\n\n### Step 1: Extract Givens\n- **Code Unit System:** Gravitational constant $G_{\\mathrm{code}}=1$, mass unit $M_{\\mathrm{code}}=1$, length unit $L_{\\mathrm{code}}=1$.\n- **Physical System (Globular Cluster):**\n    - Total mass, $M_{\\mathrm{phys}} \\approx 10^{5}\\,\\mathrm{M}_{\\odot}$.\n    - Half-mass radius, $R_{\\mathrm{h}} \\approx 3\\,\\mathrm{pc}$.\n    - One-dimensional velocity dispersion at $R_{\\mathrm{h}}$, $\\sigma_{\\mathrm{phys}} \\approx 10$–$15\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$.\n- **Numerical Details:** Double-precision floating-point arithmetic (DPFP) with machine epsilon $\\epsilon_{\\mathrm{mach}} \\approx 2.22\\times 10^{-16}$.\n- **Astrophysical Constants:**\n    - Gravitational constant, $G_{\\mathrm{phys}} \\approx 4.302\\times 10^{-3}\\,\\mathrm{pc}\\,\\mathrm{M}_{\\odot}^{-1}\\,(\\mathrm{km}/\\mathrm{s})^{2}$.\n    - Time conversion, $1\\,\\mathrm{pc}/(\\mathrm{km}/\\mathrm{s}) \\approx 0.9778\\,\\mathrm{Myr}$.\n- **Objective:** Choose the physical unit scaling $(M_{\\mathrm{unit}},L_{\\mathrm{unit}})$ that maps the cluster's characteristic position, velocity, and time scales to be of order unity in code space to minimize numerical risks.\n\n### Step 2: Validate Using Extracted Givens\nThe problem describes a standard procedure in computational astrophysics: setting up unit scaling for an N-body simulation. The physical parameters provided for the globular cluster ($M_{\\mathrm{phys}}$, $R_{\\mathrm{h}}$, $\\sigma_{\\mathrm{phys}}$) are the basis for this scaling. While there is a slight physical inconsistency (the given velocity dispersion is somewhat high for a virialized system with the given mass and radius), this does not invalidate the problem. The task is not to verify the physical model's realism but to correctly perform the unit scaling procedure given a set of characteristic parameters. The problem is scientifically grounded in Newtonian gravity and dimensional analysis, it is well-posed with a clear objective, and all necessary data are provided. Therefore, the problem statement is valid.\n\n### Principle-Based Derivation\n\nIn N-body simulations, it is standard practice to use a system of units in which the gravitational constant $G$ is equal to $1$. Let the physical units of mass, length, and time be denoted by $M_{\\mathrm{unit}}$, $L_{\\mathrm{unit}}$, and $T_{\\mathrm{unit}}$, respectively. A physical quantity $Q_{\\mathrm{phys}}$ is converted to its dimensionless code-unit counterpart $Q_{\\mathrm{code}}$ via division by the appropriate combination of these unit scales.\n\nThe relationship between the physical gravitational constant $G_{\\mathrm{phys}}$ and the code-unit gravitational constant $G_{\\mathrm{code}}$ is given by dimensional analysis:\n$$ G_{\\mathrm{code}} = G_{\\mathrm{phys}} \\frac{M_{\\mathrm{unit}} T_{\\mathrm{unit}}^2}{L_{\\mathrm{unit}}^3} $$\nSetting $G_{\\mathrm{code}}=1$ imposes a constraint on the unit scales:\n$$ 1 = G_{\\mathrm{phys}} \\frac{M_{\\mathrm{unit}} T_{\\mathrm{unit}}^2}{L_{\\mathrm{unit}}^3} \\implies T_{\\mathrm{unit}}^2 = \\frac{L_{\\mathrm{unit}}^3}{G_{\\mathrm{phys}} M_{\\mathrm{unit}}} $$\nFrom this, we derive the time unit:\n$$ T_{\\mathrm{unit}} = \\sqrt{\\frac{L_{\\mathrm{unit}}^3}{G_{\\mathrm{phys}} M_{\\mathrm{unit}}}} $$\nThe corresponding velocity unit, $V_{\\mathrm{unit}}$, is then:\n$$ V_{\\mathrm{unit}} = \\frac{L_{\\mathrm{unit}}}{T_{\\mathrm{unit}}} = \\frac{L_{\\mathrm{unit}}}{\\sqrt{L_{\\mathrm{unit}}^3 / (G_{\\mathrm{phys}} M_{\\mathrm{unit}})}} = \\sqrt{\\frac{G_{\\mathrm{phys}} M_{\\mathrm{unit}}}{L_{\\mathrm{unit}}}} $$\nThe objective is to select $M_{\\mathrm{unit}}$ and $L_{\\mathrm{unit}}$ such that the characteristic quantities of the system are of order unity ($O(1)$) in code units. This minimizes numerical errors in DPFP by keeping typical values away from the overflow/underflow limits and reducing loss of significance during arithmetic operations. The characteristic scales of the globular cluster are its total mass $M_{\\mathrm{phys}}$ and its half-mass radius $R_{\\mathrm{h}}$. Therefore, the most natural choice for the unit scaling is to set $M_{\\mathrm{unit}}$ equal to the system's total mass and $L_{\\mathrm{unit}}$ equal to its characteristic radius.\n\nLet's adopt this \"natural\" scaling:\n1.  Set the mass unit to the total mass of the system: $M_{\\mathrm{unit}} = M_{\\mathrm{phys}} = 10^5 \\, \\mathrm{M}_{\\odot}$. This ensures the total mass in code units is $M_{\\mathrm{code}} = M_{\\mathrm{phys}}/M_{\\mathrm{unit}} = 1$.\n2.  Set the length unit to the characteristic radius of the system: $L_{\\mathrm{unit}} = R_{\\mathrm{h}} = 3 \\, \\mathrm{pc}$. This ensures that particles near the half-mass radius have a code-unit radius of $r_{\\mathrm{code}} = R_{\\mathrm{h}}/L_{\\mathrm{unit}} = 1$.\n\nWith this choice, we can now check if the resulting velocity scale is also appropriate. The physical velocity dispersion $\\sigma_{\\mathrm{phys}}$ should map to a code-unit velocity $\\sigma_{\\mathrm{code}}$ of order unity. We first calculate the derived velocity unit $V_{\\mathrm{unit}}$:\n$$ V_{\\mathrm{unit}} = \\sqrt{\\frac{G_{\\mathrm{phys}} M_{\\mathrm{unit}}}{L_{\\mathrm{unit}}}} = \\sqrt{\\frac{(4.302\\times 10^{-3}\\,\\mathrm{pc}\\,\\mathrm{M}_{\\odot}^{-1}\\,(\\mathrm{km}/\\mathrm{s})^{2})(10^5\\,\\mathrm{M}_{\\odot})}{3\\,\\mathrm{pc}}} $$\n$$ V_{\\mathrm{unit}} = \\sqrt{\\frac{430.2}{3} \\, (\\mathrm{km/s})^2} = \\sqrt{143.4} \\, \\mathrm{km/s} \\approx 11.975 \\, \\mathrm{km/s} $$\nThe physical velocity dispersion is given as $\\sigma_{\\mathrm{phys}} \\approx 10$–$15\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$. The corresponding code-unit velocity dispersion is:\n$$ \\sigma_{\\mathrm{code}} = \\frac{\\sigma_{\\mathrm{phys}}}{V_{\\mathrm{unit}}} \\approx \\frac{10\\,\\mathrm{km}\\,\\mathrm{s}^{-1}}{11.975\\,\\mathrm{km}\\,\\mathrm{s}^{-1}} \\text{ to } \\frac{15\\,\\mathrm{km}\\,\\mathrm{s}^{-1}}{11.975\\,\\mathrm{km}\\,\\mathrm{s}^{-1}} $$\n$$ \\sigma_{\\mathrm{code}} \\approx 0.835 \\text{ to } 1.253 $$\nThis range is optimally centered around $1$. Finally, the characteristic dynamical time, or crossing time, is $T_{\\mathrm{cross}} \\sim R_{\\mathrm{h}}/\\sigma_{\\mathrm{phys}}$. In code units, this becomes $t_{\\mathrm{cross, code}} \\sim r_{\\mathrm{h, code}}/\\sigma_{\\mathrm{code}} \\approx 1/1 = 1$.\nThus, a choice of $M_{\\mathrm{unit}} = 10^5\\,\\mathrm{M}_{\\odot}$ and $L_{\\mathrm{unit}} = 3\\,\\mathrm{pc}$ makes the code-unit values for characteristic mass, length, velocity, and time all of order unity. This is the ideal scenario for maintaining numerical accuracy.\n\n### Option-by-Option Analysis\n\nNow we evaluate each option against this ideal scaling.\n\n**A. $M_{\\mathrm{unit}} = 10^{6}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 1\\,\\mathrm{pc}$.**\n- Total mass in code units: $M_{\\mathrm{code}} = \\frac{10^5\\,\\mathrm{M}_{\\odot}}{10^6\\,\\mathrm{M}_{\\odot}} = 0.1$. This is not of order $1$.\n- Half-mass radius in code units: $r_{\\mathrm{h, code}} = \\frac{3\\,\\mathrm{pc}}{1\\,\\mathrm{pc}} = 3$. This is arguably of order $1$, but on the high side.\n- Velocity unit: $V_{\\mathrm{unit}} = \\sqrt{\\frac{(4.302\\times 10^{-3})(10^6)}{1}} \\approx 65.6\\,\\mathrm{km/s}$.\n- Velocity dispersion in code units: $\\sigma_{\\mathrm{code}} = \\frac{10-15}{65.6} \\approx 0.15-0.23$. This is not of order $1$.\nThis choice results in characteristic mass and velocity values that are significantly smaller than $1$, which is suboptimal.\n**Verdict: Incorrect.**\n\n**B. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 3\\,\\mathrm{pc}$.**\n- Total mass in code units: $M_{\\mathrm{code}} = \\frac{10^5\\,\\mathrm{M}_{\\odot}}{10^5\\,\\mathrm{M}_{\\odot}} = 1$. Ideal.\n- Half-mass radius in code units: $r_{\\mathrm{h, code}} = \\frac{3\\,\\mathrm{pc}}{3\\,\\mathrm{pc}} = 1$. Ideal.\n- Velocity unit: $V_{\\mathrm{unit}} = \\sqrt{\\frac{(4.302\\times 10^{-3})(10^5)}{3}} \\approx 11.975\\,\\mathrm{km/s}$.\n- Velocity dispersion in code units: $\\sigma_{\\mathrm{code}} = \\frac{10-15}{11.975} \\approx 0.835-1.253$. Ideal.\nThis choice perfectly maps the characteristic physical scales of the system to code-unit values of $1$, providing the best conditions for minimizing numerical error. The time unit is $T_{\\mathrm{unit}} = L_{\\mathrm{unit}}/V_{\\mathrm{unit}} = 3\\,\\mathrm{pc} / (11.975\\,\\mathrm{km/s}) \\approx 0.2505\\,\\mathrm{pc}/(\\mathrm{km/s}) \\approx 0.245\\,\\mathrm{Myr}$. The crossing time in code units is $\\sim 1$.\n**Verdict: Correct.**\n\n**C. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 0.1\\,\\mathrm{pc}$.**\n- Total mass in code units: $M_{\\mathrm{code}} = \\frac{10^5\\,\\mathrm{M}_{\\odot}}{10^5\\,\\mathrm{M}_{\\odot}} = 1$. Ideal.\n- Half-mass radius in code units: $r_{\\mathrm{h, code}} = \\frac{3\\,\\mathrm{pc}}{0.1\\,\\mathrm{pc}} = 30$. This is not of order $1$. Typical particle positions would be large, increasing round-off risks.\n- Velocity unit: $V_{\\mathrm{unit}} = \\sqrt{\\frac{(4.302\\times 10^{-3})(10^5)}{0.1}} \\approx 65.6\\,\\mathrm{km/s}$.\n- Velocity dispersion in code units: $\\sigma_{\\mathrm{code}} = \\frac{10-15}{65.6} \\approx 0.15-0.23$. This is not of order $1$.\nThis choice is poor as it leads to large position values and small velocity values in code units.\n**Verdict: Incorrect.**\n\n**D. $M_{\\mathrm{unit}} = 5\\times 10^{4}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 10\\,\\mathrm{pc}$.**\n- Total mass in code units: $M_{\\mathrm{code}} = \\frac{10^5\\,\\mathrm{M}_{\\odot}}{5\\times 10^4\\,\\mathrm{M}_{\\odot}} = 2$. This is of order $1$.\n- Half-mass radius in code units: $r_{\\mathrm{h, code}} = \\frac{3\\,\\mathrm{pc}}{10\\,\\mathrm{pc}} = 0.3$. This is borderline, on the small side.\n- Velocity unit: $V_{\\mathrm{unit}} = \\sqrt{\\frac{(4.302\\times 10^{-3})(5\\times 10^4)}{10}} = \\sqrt{21.51} \\approx 4.64\\,\\mathrm{km/s}$.\n- Velocity dispersion in code units: $\\sigma_{\\mathrm{code}} = \\frac{10-15}{4.64} \\approx 2.16-3.23$. These values are becoming large.\nWhile the values are closer to $1$ than in options A and C, they are consistently off by factors of $2$ to $3$. Option B achieves a much better mapping with all primary characteristic quantities mapping to values very close to $1$.\n**Verdict: Incorrect.**\n\nIn conclusion, Option B is unequivocally the most appropriate choice as it perfectly aligns the code units with the intrinsic mass, length, and velocity scales of the physical system, thereby providing the most numerically stable setup for the simulation.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "While the underlying laws of gravity are perfectly time-reversible, the numerical algorithms we use to approximate them can break this fundamental symmetry. This hands-on coding exercise challenges you to implement and compare a symplectic integrator (Velocity Verlet) with a non-symplectic one (RK4) . By performing a time-reversal experiment, you will viscerally explore the concepts of numerical error, long-term stability, and the existence of a \"shadow Hamiltonian\" that approximately governs the simulated trajectory.",
            "id": "3540226",
            "problem": "You are tasked to design and implement a numerical experiment to assess time-irreversibility in the gravitational $N$-body problem, examine how the mismatch after time reversal depends on the integrator class and its parameters, and interpret the observed behavior in terms of the concept of a shadow Hamiltonian. Work in dimensionless $N$-body units with gravitational constant $G=1$, equal-mass particles as specified, positions in the same length units, velocities in the same length-per-time units, and time in the same time units. All outputs must be in these dimensionless units.\n\nStarting from Newton's second law applied to $N$ point masses with softened pairwise Newtonian gravity, the accelerations are determined by the negative gradient of the softened potential. The system follows a Hamiltonian flow for the total energy, with the kinetic energy and softened potential energy providing the Hamiltonian. Time reversibility can be probed by the following procedure: integrate forward to a final time $T$, negate all velocities, then integrate forward again for the same duration and parameters, and quantify the mismatch in positions relative to the initial state.\n\nYour task is to:\n\n- Implement two integrators:\n  1. A symplectic, time-reversible method, specifically the velocity Verlet (also known as leapfrog) scheme.\n  2. A non-symplectic method, specifically the classical fourth-order Runge-Kutta (RK4) method.\n\n- Use a softened gravitational force between bodies. The softened potential between bodies $i$ and $j$ at separation vector $\\mathbf{r}_{ij}$ is given by $$\\Phi_{ij} = -\\frac{G m_i m_j}{\\sqrt{\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2}},$$ and its corresponding force on body $i$ due to $j$ is $$\\mathbf{F}_{ij} = - \\nabla \\Phi_{ij} = - G m_i m_j \\frac{\\mathbf{r}_{ij}}{\\left(\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2\\right)^{3/2}}.$$\n\n- For each test case, perform the following experiment:\n  1. Integrate the system forward from time $t=0$ to $t=T$ with a timestep $dt$ using the selected integrator.\n  2. At $t=T$, reverse every velocity vector, i.e., $\\mathbf{v}_i \\leftarrow -\\mathbf{v}_i$.\n  3. Integrate forward again for the same number of steps (duration $T$ and timestep $dt$) using the same integrator.\n  4. Compute the root-mean-square (RMS) position mismatch $$\\delta x = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\left\\lVert \\mathbf{x}_i^{\\text{back}} - \\mathbf{x}_i^{\\text{init}} \\right\\rVert^2}.$$ Report $\\delta x$ in the same length units as the positions.\n\n- The softened gravitational constant is set to $G=1$. The softening length is fixed to $\\epsilon=10^{-2}$ across all tests. The number of bodies $N$, their masses $m_i$, their initial positions $\\mathbf{x}_i(0)$, and initial velocities $\\mathbf{v}_i(0)$ are specified below for each test.\n\n- Implement total energy computation at the start of the forward integration as $$E(0) = K(0) + U(0), \\quad K = \\sum_{i=1}^N \\frac{1}{2} m_i \\lVert \\mathbf{v}_i \\rVert^2, \\quad U = \\sum_{1 \\le i  j \\le N} - \\frac{G m_i m_j}{\\sqrt{\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2}},$$ although you do not need to output energy; it is for internal consistency checks only.\n\n- Design the program to compute the above $\\delta x$ values for the following test suite. Each test case is given as a tuple of parameters specifying the integrator, $N$, masses, positions, velocities, $dt$, and $T$:\n\n  1. Case A (happy path, near-integrable two-body, symplectic, small timestep):\n     - Integrator: velocity Verlet\n     - $N=2$, $m_1=m_2=1/2$\n     - $\\mathbf{x}_1(0)=(-1/2,0,0)$, $\\mathbf{x}_2(0)=(1/2,0,0)$\n     - Choose a circular orbit speed for equal masses separated by $r_0=1$; for each body at radius $a=r_0/2$, the speed is $v=\\sqrt{G m_{\\text{other}}/(2 r_0)}$ with $G=1$ and $m_{\\text{other}}=1/2$, so $v=1/(2\\sqrt{1})=1/2$. Set $\\mathbf{v}_1(0)=(0,v,0)$ and $\\mathbf{v}_2(0)=(0,-v,0)$.\n     - $dt=10^{-3}$, $T=2$.\n\n  2. Case B (near-integrable two-body, non-symplectic, larger timestep):\n     - Integrator: classical fourth-order Runge-Kutta (RK4)\n     - Same $N$, masses, positions as Case A\n     - Same circular orbit velocities as Case A\n     - $dt=10^{-2}$, $T=2$.\n\n  3. Case C (three-body chaotic-like configuration, symplectic, small timestep):\n     - Integrator: velocity Verlet\n     - $N=3$, $m_i=1/3$ for $i=1,2,3$\n     - $\\mathbf{x}_1(0)=(-1,0,0)$, $\\mathbf{x}_2(0)=(1,0.2,0)$, $\\mathbf{x}_3(0)=(0,-0.8,0)$\n     - $\\mathbf{v}_1(0)=(0.3,0.2,0)$, $\\mathbf{v}_2(0)=(-0.2,0.5,0)$, $\\mathbf{v}_3(0)=(-0.1,-0.3,0)$\n     - $dt=2\\times 10^{-3}$, $T=5$.\n\n  4. Case D (three-body chaotic-like configuration, non-symplectic, moderate timestep):\n     - Integrator: classical fourth-order Runge-Kutta (RK4)\n     - Same $N$, masses, positions, velocities as Case C\n     - $dt=5\\times 10^{-3}$, $T=5$.\n\n  5. Case E (three-body chaotic-like configuration, symplectic, boundary with large timestep):\n     - Integrator: velocity Verlet\n     - Same $N$, masses, positions, velocities as Case C\n     - $dt=5\\times 10^{-2}$, $T=5$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$), where each $result_k$ is the $\\delta x$ for Case $k$ in the order A, B, C, D, E. Each $\\delta x$ must be a floating-point number in the same length units as the positions. The program must be self-contained and must not read any input.",
            "solution": "The problem as stated is valid. It presents a well-defined numerical experiment grounded in the principles of classical mechanics and computational dynamics. All necessary parameters, initial conditions, and physical laws are provided, forming a self-contained and scientifically sound task.\n\nThe objective is to investigate the time-reversibility of numerical solutions to the gravitational $N$-body problem. The true dynamics, governed by Newton's laws of motion, are time-reversible. If, at any instant, the velocities of all particles are reversed, the system will retrace its path in phase space, returning to its initial state. This experiment tests how well two different numerical integration schemes—Velocity Verlet and classical fourth-order Runge-Kutta (RK4)—preserve this fundamental symmetry. The deviation from perfect reversal is quantified by the root-mean-square (RMS) position mismatch, $\\delta x$, after a forward-and-backward integration sequence.\n\nThe system's dynamics are dictated by the softened gravitational potential, given for a pair of particles $i$ and $j$ as $\\Phi_{ij} = -G m_i m_j / \\sqrt{\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2}$, where $\\mathbf{r}_{ij} = \\mathbf{x}_i - \\mathbf{x}_j$ is the separation vector, $m_i$ are masses, $G$ is the gravitational constant, and $\\epsilon$ is the softening length. The force on particle $i$ due to particle $j$ is the negative gradient of this potential, $\\mathbf{F}_{ij} = - \\nabla_i \\Phi_{ij} = -G m_i m_j \\mathbf{r}_{ij} / (\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2)^{3/2}$. The total acceleration on particle $i$ is $\\mathbf{a}_i = (1/m_i) \\sum_{j \\neq i} \\mathbf{F}_{ij}$. This setup defines a Hamiltonian system, whose trajectories in phase space $(\\mathbf{x}, \\mathbf{v})$ are what we aim to approximate numerically.\n\nThe core of the analysis lies in the contrasting properties of the two integrators.\n\nThe Velocity Verlet integrator is a member of the family of geometric integrators, specifically, it is symplectic and time-reversible. Its algorithm proceeds in a \"kick-drift-kick\" sequence:\n$1$. Update velocities by a half-step: $\\mathbf{v}(t + dt/2) = \\mathbf{v}(t) + \\mathbf{a}(t) \\cdot dt/2$.\n$2$. Update positions by a full step using the half-step velocities: $\\mathbf{x}(t + dt) = \\mathbf{x}(t) + \\mathbf{v}(t + dt/2) \\cdot dt$.\n$3$. Compute new accelerations $\\mathbf{a}(t+dt)$ at the new positions.\n$4$. Complete the velocity update: $\\mathbf{v}(t + dt) = \\mathbf{v}(t + dt/2) + \\mathbf{a}(t+dt) \\cdot dt/2$.\nThis scheme is explicitly time-reversible. If one performs a step of size $dt$, negates the final velocities, and performs another step of size $dt$, the system returns exactly to its initial state, barring floating-point round-off errors. Furthermore, being symplectic means that over many steps, the integrator does not exactly conserve the true Hamiltonian $H$, but rather a nearby \"shadow Hamiltonian\" $H' = H + O(dt^2)$, which it conserves to a very high degree. This property leads to excellent long-term energy conservation (no secular drift) and stability. Consequently, for the time-reversal test, the mismatch $\\delta x$ for Verlet should be dominated by the accumulation of machine-precision round-off errors.\n\nThe classical fourth-order Runge-Kutta (RK4) method, conversely, is a general-purpose, high-accuracy ordinary differential equation solver. For a system $\\dot{\\mathbf{y}} = f(\\mathbf{y}, t)$, a single step is given by:\n$\\mathbf{k}_1 = f(\\mathbf{y}_n, t_n)$\n$\\mathbf{k}_2 = f(\\mathbf{y}_n + \\frac{dt}{2}\\mathbf{k}_1, t_n + \\frac{dt}{2})$\n$\\mathbf{k}_3 = f(\\mathbf{y}_n + \\frac{dt}{2}\\mathbf{k}_2, t_n + \\frac{dt}{2})$\n$\\mathbf{k}_4 = f(\\mathbf{y}_n + dt\\mathbf{k}_3, t_n + dt)$\n$\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{dt}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)$\nWhile RK4 has a small local truncation error of order $O(dt^5)$, it is not symplectic. It does not preserve the geometric structure of Hamiltonian dynamics and does not conserve a shadow Hamiltonian. Its errors, while small, are dissipative and break the time-reversal symmetry of the underlying physics. As a result, the forward-backward integration test will yield a mismatch $\\delta x$ that is much larger than machine precision and is primarily due to the method's accumulated truncation error.\n\nThe numerical implementation will consist of a primary routine orchestrating the experiment for each test case. This routine will call an acceleration function that calculates gravitational accelerations for all particles based on their current positions. Vectorized `NumPy` operations are used for efficiency. Two separate stepper functions, `verlet_step` and `rk4_step`, will implement the logic for the respective integrators.\n\nThe expected results will highlight these theoretical differences.\nFor the stable two-body system (Cases A, B), Verlet (A) should exhibit a $\\delta x$ near machine precision, demonstrating its inherent reversibility. RK4 (B) will show a significantly larger $\\delta x$, reflecting its non-symplectic nature.\nFor the chaotic three-body system (Cases C, D, E), the situation is more complex due to the exponential amplification of small errors (Lyapunov instability). Even for Verlet (C), the round-off errors will be amplified, leading to a larger $\\delta x$ than in the stable case. However, RK4 (D) will fare worse, as both its larger, systematic truncation errors and round-off errors are amplified. Case E, which uses Verlet with a large timestep, will demonstrate that symplecticity is not a guarantee of accuracy; a large $dt$ means the shadow Hamiltonian is far from the true one, and the resulting large single-step errors are severely amplified by the chaotic dynamics, leading to a poor reversibility score.",
            "answer": "```python\nimport numpy as np\n\ndef get_accelerations(pos, mass, G, epsilon):\n    \"\"\"\n    Calculate the acceleration of each body due to gravitational interaction.\n    The force on particle i from j is F_ij = -G m_i m_j * (r_i - r_j) / (|r_i - r_j|^2 + e^2)^(3/2).\n    Acceleration a_i = F_i / m_i = sum_j(F_ij) / m_i.\n    \n    Args:\n        pos (np.ndarray): Positions of N bodies, shape (N, 3).\n        mass (np.ndarray): Masses of N bodies, shape (N, 1).\n        G (float): Gravitational constant.\n        epsilon (float): Softening length.\n\n    Returns:\n        np.ndarray: Accelerations of N bodies, shape (N, 3).\n    \"\"\"\n    N = pos.shape[0]\n    # rij is a (N, N, 3) array where rij[i, j, :] = pos[i, :] - pos[j, :]\n    rij = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n\n    # dist_sq is a (N, N) array of squared separations\n    dist_sq = np.sum(rij**2, axis=-1)\n\n    # Add epsilon^2 to the denominator and compute inv_r3 = (dist^2 + e^2)^(-3/2)\n    # The diagonal (i=j) will have dist_sq=0, but epsilon avoids division by zero.\n    inv_r3 = (dist_sq + epsilon**2)**(-1.5)\n    \n    # Calculate forces. F_ij's magnitude is G * m_i * m_j / (dist^2+eps^2).\n    # Force vector is this magnitude * -(r_i-r_j)/dist. We rewrite this.\n    # F_i = sum_j!=i -G m_i m_j (r_i - r_j) * inv_r3_ij\n    # a_i = sum_j!=i -G m_j (r_i - r_j) * inv_r3_ij\n    \n    # We can write `a_i = G * sum_j m_j * (r_j - r_i) * inv_r3_ij`.\n    # Let's use the vectorized force calculation for clarity.\n    \n    # Mass matrix M[i, j] = m_i * m_j\n    mass_matrix = mass @ mass.T\n    \n    # Force magnitude component, excluding the vector part and signs.\n    # Note: F_ij = -G m_i m_j * rij / denom^(3/2)\n    # The term G * m_i * m_j * inv_r3 corresponds to the scalar part of the force.\n    scalar_force = G * mass_matrix * inv_r3\n\n    # Multiply by the displacement vectors. Diagonal rij[i,i] is zero, so F_ii is zero.\n    # F_vectors[i,j,:] is the force on i from j.\n    F_vectors = -rij * scalar_force[..., np.newaxis]\n\n    # Sum forces on each particle\n    F_total = np.sum(F_vectors, axis=1)\n\n    # a = F/m\n    accel = F_total / mass\n    \n    return accel\n\ndef verlet_step(pos, vel, acc, mass, G, epsilon, dt):\n    \"\"\"A single step of the Velocity Verlet integrator.\"\"\"\n    vel_half = vel + acc * 0.5 * dt\n    pos_new = pos + vel_half * dt\n    acc_new = get_accelerations(pos_new, mass, G, epsilon)\n    vel_new = vel_half + acc_new * 0.5 * dt\n    return pos_new, vel_new, acc_new\n\ndef rk4_step(pos, vel, mass, G, epsilon, dt):\n    \"\"\"A single step of the classic 4th-order Runge-Kutta integrator.\"\"\"\n    # k1\n    k1_x = vel\n    k1_v = get_accelerations(pos, mass, G, epsilon)\n    \n    # k2\n    k2_x = vel + k1_v * dt * 0.5\n    k2_v = get_accelerations(pos + k1_x * dt * 0.5, mass, G, epsilon)\n\n    # k3\n    k3_x = vel + k2_v * dt * 0.5\n    k3_v = get_accelerations(pos + k2_x * dt * 0.5, mass, G, epsilon)\n\n    # k4\n    k4_x = vel + k3_v * dt\n    k4_v = get_accelerations(pos + k3_x * dt, mass, G, epsilon)\n\n    # Update\n    pos_new = pos + (dt / 6.0) * (k1_x + 2*k2_x + 2*k3_x + k4_x)\n    vel_new = vel + (dt / 6.0) * (k1_v + 2*k2_v + 2*k3_v + k4_v)\n    \n    return pos_new, vel_new\n\ndef run_experiment(integrator_name, N, masses, pos_init, vel_init, dt, T, G, epsilon):\n    \"\"\"Performs the forward-backward integration and returns the mismatch.\"\"\"\n    pos = pos_init.copy()\n    vel = vel_init.copy()\n    \n    num_steps = int(round(T / dt))\n\n    # Forward integration\n    if integrator_name == 'verlet':\n        acc = get_accelerations(pos, masses, G, epsilon)\n        for _ in range(num_steps):\n            pos, vel, acc = verlet_step(pos, vel, acc, masses, G, epsilon, dt)\n    elif integrator_name == 'rk4':\n        for _ in range(num_steps):\n            pos, vel = rk4_step(pos, vel, masses, G, epsilon, dt)\n    \n    # Reverse velocities\n    vel = -vel\n\n    # Backward integration\n    if integrator_name == 'verlet':\n        # acc at time T is needed to start Verlet again\n        acc = get_accelerations(pos, masses, G, epsilon)\n        for _ in range(num_steps):\n            pos, vel, acc = verlet_step(pos, vel, acc, masses, G, epsilon, dt)\n    elif integrator_name == 'rk4':\n        for _ in range(num_steps):\n            pos, vel = rk4_step(pos, vel, masses, G, epsilon, dt)\n            \n    # Compute RMS position mismatch\n    diffs = pos - pos_init\n    rms_mismatch = np.sqrt(np.sum(diffs**2) / N)\n    \n    return rms_mismatch\n\ndef solve():\n    G_const = 1.0\n    epsilon_const = 1e-2\n\n    test_cases = [\n        {\n            \"id\": \"A\", \"integrator\": \"verlet\", \"N\": 2,\n            \"masses\": np.array([[0.5], [0.5]]),\n            \"pos\": np.array([[-0.5, 0.0, 0.0], [0.5, 0.0, 0.0]]),\n            \"vel\": np.array([[0.0, 0.5, 0.0], [0.0, -0.5, 0.0]]),\n            \"dt\": 1e-3, \"T\": 2.0\n        },\n        {\n            \"id\": \"B\", \"integrator\": \"rk4\", \"N\": 2,\n            \"masses\": np.array([[0.5], [0.5]]),\n            \"pos\": np.array([[-0.5, 0.0, 0.0], [0.5, 0.0, 0.0]]),\n            \"vel\": np.array([[0.0, 0.5, 0.0], [0.0, -0.5, 0.0]]),\n            \"dt\": 1e-2, \"T\": 2.0\n        },\n        {\n            \"id\": \"C\", \"integrator\": \"verlet\", \"N\": 3,\n            \"masses\": np.array([[1./3.], [1./3.], [1./3.]]),\n            \"pos\": np.array([[-1.0, 0.0, 0.0], [1.0, 0.2, 0.0], [0.0, -0.8, 0.0]]),\n            \"vel\": np.array([[0.3, 0.2, 0.0], [-0.2, 0.5, 0.0], [-0.1, -0.3, 0.0]]),\n            \"dt\": 2e-3, \"T\": 5.0\n        },\n        {\n            \"id\": \"D\", \"integrator\": \"rk4\", \"N\": 3,\n            \"masses\": np.array([[1./3.], [1./3.], [1./3.]]),\n            \"pos\": np.array([[-1.0, 0.0, 0.0], [1.0, 0.2, 0.0], [0.0, -0.8, 0.0]]),\n            \"vel\": np.array([[0.3, 0.2, 0.0], [-0.2, 0.5, 0.0], [-0.1, -0.3, 0.0]]),\n            \"dt\": 5e-3, \"T\": 5.0\n        },\n        {\n            \"id\": \"E\", \"integrator\": \"verlet\", \"N\": 3,\n            \"masses\": np.array([[1./3.], [1./3.], [1./3.]]),\n            \"pos\": np.array([[-1.0, 0.0, 0.0], [1.0, 0.2, 0.0], [0.0, -0.8, 0.0]]),\n            \"vel\": np.array([[0.3, 0.2, 0.0], [-0.2, 0.5, 0.0], [-0.1, -0.3, 0.0]]),\n            \"dt\": 5e-2, \"T\": 5.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_x = run_experiment(\n            integrator_name=case[\"integrator\"],\n            N=case[\"N\"],\n            masses=case[\"masses\"],\n            pos_init=case[\"pos\"],\n            vel_init=case[\"vel\"],\n            dt=case[\"dt\"],\n            T=case[\"T\"],\n            G=G_const,\n            epsilon=epsilon_const\n        )\n        results.append(delta_x)\n\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}