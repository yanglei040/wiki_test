{
    "hands_on_practices": [
        {
            "introduction": "万有引力N体问题的核心是理解两个天体间的相互作用。本练习将带您回归第一性原理，通过将二体问题简化为等效的单体问题，从牛顿运动定律和万有引力定律出发，推导出行星运动的周期。这项基础实践不仅能巩固您对约化质量和质心坐标系等核心概念的理解，也为构建和验证更复杂的N体模拟提供了不可或缺的解析基础 。",
            "id": "3540212",
            "problem": "在牛顿引力背景下，考虑一个由两个质点组成的孤立子系统，其质量分别为 $m_{1}$ 和 $m_{2}$，它们仅通过相互之间的引力发生作用。设该系统为束缚系统，其相对轨道形成一个半长轴为 $a$ 的椭圆。请仅从牛顿第二定律、引力平方反比定律以及质心和角动量的定义出发，将二体问题简化为质心参考系中的等效单体问题，并推导出束缚相对运动的轨道周期 $T$，将其表示为半长轴 $a$、引力常数 $G$ 和总质量 $M = m_{1} + m_{2}$ 的函数。你的推导必须证明为何质量的依赖关系仅通过总质量 $M$ 体现，而不是分别通过 $m_{1}$ 和 $m_{2}$。不要引用或假设任何已有的周期-半长轴关系；相反，应从第一性原理出发进行推导，并根据需要运用守恒定律和圆锥曲线的几何性质。\n\n请以 $a$、$G$、$M$ 和 $\\pi$ 表示的单个解析表达式的形式给出最终答案。不需要进行数值计算，最终表达式中不应包含单位。",
            "solution": "该问题经验证具有科学依据、良定、客观且自洽。推导过程按规定从第一性原理出发。\n\n设两个质点 $m_{1}$ 和 $m_{2}$ 的位置矢量分别为 $\\vec{r}_{1}$ 和 $\\vec{r}_{2}$。该系统是孤立的，因此唯一作用的力是它们之间的相互引力。根据牛顿第二定律和万有引力定律，这两个质量的运动方程为：\n$$m_{1}\\ddot{\\vec{r}}_{1} = \\vec{F}_{12} = G\\frac{m_{1}m_{2}}{|\\vec{r}_{2} - \\vec{r}_{1}|^{3}}(\\vec{r}_{2} - \\vec{r}_{1})$$\n$$m_{2}\\ddot{\\vec{r}}_{2} = \\vec{F}_{21} = G\\frac{m_{1}m_{2}}{|\\vec{r}_{1} - \\vec{r}_{2}|^{3}}(\\vec{r}_{1} - \\vec{r}_{2})$$\n注意，$\\vec{F}_{12} = -\\vec{F}_{21}$，这与牛顿第三定律一致。\n\n为了简化这个二体问题，我们引入两个新的坐标：质心的位置矢量 $\\vec{R}_{CM}$ 和相对位置矢量 $\\vec{r}$。\n质心的定义为：\n$$\\vec{R}_{CM} = \\frac{m_{1}\\vec{r}_{1} + m_{2}\\vec{r}_{2}}{m_{1} + m_{2}}$$\n系统的总质量为 $M = m_{1} + m_{2}$。对 $\\vec{R}_{CM}$ 关于时间求二阶导数，得到其加速度：\n$$\\ddot{\\vec{R}}_{CM} = \\frac{m_{1}\\ddot{\\vec{r}}_{1} + m_{2}\\ddot{\\vec{r}}_{2}}{M} = \\frac{\\vec{F}_{12} + \\vec{F}_{21}}{M} = \\frac{\\vec{0}}{M} = \\vec{0}$$\n这表明质心以恒定速度运动，意味着质心参考系是一个惯性参考系。\n\n相对位置矢量定义为 $\\vec{r} = \\vec{r}_{1} - \\vec{r}_{2}$。其二阶时间导数为：\n$$\\ddot{\\vec{r}} = \\ddot{\\vec{r}}_{1} - \\ddot{\\vec{r}}_{2} = \\frac{\\vec{F}_{12}}{m_{1}} - \\frac{\\vec{F}_{21}}{m_{2}}$$\n代入力的表达式，并注意到 $\\vec{F}_{21} = -\\vec{F}_{12}$ 和 $\\vec{r}_{2} - \\vec{r}_{1} = -\\vec{r}$：\n$$\\ddot{\\vec{r}} = \\frac{1}{m_{1}}\\left(-G\\frac{m_{1}m_{2}}{r^{3}}\\vec{r}\\right) - \\frac{1}{m_{2}}\\left(G\\frac{m_{1}m_{2}}{r^{3}}\\vec{r}\\right)$$\n$$\\ddot{\\vec{r}} = -G\\frac{m_{2}}{r^{3}}\\vec{r} - G\\frac{m_{1}}{r^{3}}\\vec{r} = -G\\frac{(m_{1} + m_{2})}{r^{3}}\\vec{r}$$\n代入 $M = m_{1} + m_{2}$，我们得到相对坐标的运动方程：\n$$\\ddot{\\vec{r}} = -\\frac{GM}{r^{3}}\\vec{r}$$\n这个方程描述了一个假设粒子的运动，其位置由相对矢量 $\\vec{r}$ 给出，该粒子在一个源于固定点的中心力作用下运动，其中决定加速度的有效质量是总质量 $M = m_{1} + m_{2}$。这一步明确地证明了为什么动力学行为取决于质量之和 $M$，而不是单个的 $m_{1}$ 或 $m_{2}$。因此，二体问题被简化为了一个等效的单体问题。\n\n该力是纯粹的中心力（方向沿 $\\vec{r}$），这意味着比角动量 $\\vec{h} = \\vec{r} \\times \\dot{\\vec{r}}$ 是一个守恒量。\n$$\\dot{\\vec{h}} = \\frac{d}{dt}(\\vec{r} \\times \\dot{\\vec{r}}) = \\dot{\\vec{r}} \\times \\dot{\\vec{r}} + \\vec{r} \\times \\ddot{\\vec{r}} = \\vec{0} + \\vec{r} \\times \\left(-\\frac{GM}{r^{3}}\\vec{r}\\right) = \\vec{0}$$\n$\\vec{h}$ 的守恒意味着运动被限制在一个垂直于恒定矢量 $\\vec{h}$ 的平面内。比角动量的大小为 $h = |\\vec{h}|$。在这个平面内，相对位置矢量扫过面积的速率由掠面速度给出：\n$$\\frac{dA}{dt} = \\frac{1}{2}|\\vec{r} \\times \\dot{\\vec{r}}| = \\frac{h}{2}$$\n由于 $h$ 是常数，掠面速度是恒定的（开普勒第二定律）。轨道周期 $T$ 是扫过整个椭圆面积 $A$ 所需的总时间。因此，\n$$T = \\frac{A}{dA/dt} = \\frac{A}{h/2}$$\n半长轴为 $a$、半短轴为 $b$ 的椭圆面积是 $A = \\pi a b$。因此，周期为：\n$$T = \\frac{2\\pi a b}{h}$$\n\n为了求出周期，我们必须将 $h$ 和 $b$ 与给定的参数 $a$ 和 $M$ 联系起来。这需要求解轨道的运动方程。在平方反比力作用下，路径 $\\vec{r}(t)$ 的通解是一个圆锥曲线。对于束缚轨道，它是一个椭圆，其原点（等效单体系统的质心）位于一个焦点上。该椭圆在极坐标 $(r, \\theta)$ 中的方程为：\n$$r = \\frac{p}{1 + e\\cos\\theta}$$\n其中 $e$ 是离心率（对于椭圆，$0 \\le e  1$），$p$ 是半通径。求解运动微分方程 $\\ddot{\\vec{r}} = -GM\\vec{r}/r^{3}$ 的一个标准结果是比角动量与半通径之间的关系：\n$$h^{2} = GMp$$\n对于椭圆，半通径 $p$ 和半短轴 $b$ 通过以下关系式与半长轴 $a$ 和离心率 $e$ 相关联：\n$$p = a(1 - e^{2})$$\n$$b = a\\sqrt{1 - e^{2}}$$\n将 $p$ 的表达式代入 $h^2$ 的方程中：\n$$h^{2} = GMa(1 - e^{2})$$\n现在我们可以用 $a$、$G$ 和 $M$ 来表示周期 $T$。我们从周期的表达式开始，并将其平方：\n$$T^{2} = \\left(\\frac{2\\pi a b}{h}\\right)^{2} = \\frac{4\\pi^{2}a^{2}b^{2}}{h^{2}}$$\n代入 $b^{2} = a^{2}(1-e^{2})$ 和 $h^{2} = GMa(1-e^{2})$：\n$$T^{2} = \\frac{4\\pi^{2}a^{2}\\left(a^{2}(1-e^{2})\\right)}{GMa(1-e^{2})}$$\n分子和分母中的项 $(1-e^{2})$ 被消去，这表明周期取决于半长轴，而与离心率无关。\n$$T^{2} = \\frac{4\\pi^{2}a^{4}}{GMa} = \\frac{4\\pi^{2}a^{3}}{GM}$$\n对两边取平方根，得到轨道周期的最终表达式：\n$$T = 2\\pi\\sqrt{\\frac{a^{3}}{GM}}$$\n这是开普勒第三定律的推广形式，完全按照要求从第一性原理推导得出。",
            "answer": "$$ \\boxed{2\\pi\\sqrt{\\frac{a^{3}}{GM}}} $$"
        },
        {
            "introduction": "成功的数值模拟不仅需要正确的物理模型，还需要精巧的数值设定。本练习将引导您解决一个关键的实践问题：如何将一个真实天体物理系统（如球状星团）的物理单位（秒差距、太阳质量等）合理地转换为无量纲的程序单位。掌握这种单位标定技术，对于最小化数值误差、确保大规模N体模拟的稳定性和准确性至关重要 。",
            "id": "3540198",
            "problem": "您正在准备一个真实球状星团的直接引力N体模拟，该模拟在代码单位下进行，其中引力常数$G=1$，质量单位$M=1$，长度单位$L=1$。目标物理系统的总质量为 $M_{\\mathrm{phys}} \\approx 10^{5}\\,\\mathrm{M}_{\\odot}$，半质量半径为 $R_{\\mathrm{h}} \\approx 3\\,\\mathrm{pc}$，在 $R_{\\mathrm{h}}$ 处的一维速度弥散约为 $10$–$15\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$。您将使用双精度浮点（DPFP）算法运行此模拟，其机器精度为 $\\epsilon_{\\mathrm{mach}} \\approx 2.22\\times 10^{-16}$。您希望在整个积分和诊断过程（包括位置、速度、加速度、能量和时间步长）中，最大限度地减少舍入误差以及上溢或下溢的风险。假设没有外部潮汐，且所有粒子质量相等。\n\n从牛顿引力定律和量纲分析出发，确定对于代码单位 $(G=1, M=1, L=1)$，以下哪种物理单位标度 $(M_{\\mathrm{unit}},L_{\\mathrm{unit}})$ 的选择能最好地将该球状星团映射到代码空间，从而使得靠近 $R_{\\mathrm{h}}$ 的典型无量纲位置、速度弥散和穿越时间都约为1的量级。如果需要，请使用广为接受的天体物理学数值 $G_{\\mathrm{phys}} \\approx 4.302\\times 10^{-3}\\,\\mathrm{pc}\\,\\mathrm{M}_{\\odot}^{-1}\\,(\\mathrm{km}/\\mathrm{s})^{2}$ 以及转换关系 $1\\,\\mathrm{pc}/(\\mathrm{km}/\\mathrm{s}) \\approx 0.9778\\,\\mathrm{Myr}$。您的选择必须通过第一性原理推导来证明，阐明该标度与特征动力学尺度之间的联系，并解释为什么它能在双精度浮点运算中最大限度地降低数值风险。\n\n哪个选项最合适？\n\n- A. $M_{\\mathrm{unit}} = 10^{6}\\,\\mathrm{M}_{\\odot}$，$L_{\\mathrm{unit}} = 1\\,\\mathrm{pc}$。\n\n- B. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$，$L_{\\mathrm{unit}} = 3\\,\\mathrm{pc}$。\n\n- C. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$，$L_{\\mathrm{unit}} = 0.1\\,\\mathrm{pc}$。\n\n- D. $M_{\\mathrm{unit}} = 5\\times 10^{4}\\,\\mathrm{M}_{\\odot}$，$L_{\\mathrm{unit}} = 10\\,\\mathrm{pc}$。\n\n请选择唯一最佳选项并从第一性原理出发进行论证，解释对于每个选项，代码单位的速度和时间尺度在物理单位下分别是多少，并说明为何您的选择能为目标球状星团模型在双精度浮点运算中降低舍入和上/下溢风险。",
            "solution": "用户希望我为球状星团的N体模拟确定最合适的物理单位选择。目标是对问题进行标度，使得特征物理量映射为量级为1的无量纲代码单位值，从而最大限度地减少数值误差。\n\n### 步骤1：提取已知条件\n- **代码单位系统：** 引力常数 $G_{\\mathrm{code}}=1$，质量单位 $M_{\\mathrm{code}}=1$，长度单位 $L_{\\mathrm{code}}=1$。\n- **物理系统（球状星团）：**\n    - 总质量 $M_{\\mathrm{phys}} \\approx 10^{5}\\,\\mathrm{M}_{\\odot}$。\n    - 半质量半径 $R_{\\mathrm{h}} \\approx 3\\,\\mathrm{pc}$。\n    - 在 $R_{\\mathrm{h}}$ 处的一维速度弥散 $\\sigma_{\\mathrm{phys}} \\approx 10$–$15\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$。\n- **数值细节：** 双精度浮点（DPFP）算法，机器精度 $\\epsilon_{\\mathrm{mach}} \\approx 2.22\\times 10^{-16}$。\n- **天体物理常数：**\n    - 引力常数 $G_{\\mathrm{phys}} \\approx 4.302\\times 10^{-3}\\,\\mathrm{pc}\\,\\mathrm{M}_{\\odot}^{-1}\\,(\\mathrm{km}/\\mathrm{s})^{2}$。\n    - 时间转换 $1\\,\\mathrm{pc}/(\\mathrm{km}/\\mathrm{s}) \\approx 0.9778\\,\\mathrm{Myr}$。\n- **目标：** 选择物理单位标度 $(M_{\\mathrm{unit}},L_{\\mathrm{unit}})$，将星团的特征位置、速度和时间尺度映射到代码空间中量级为1的数值，以最大限度地降低数值风险。\n\n### 步骤2：使用提取的已知条件进行验证\n问题描述了计算天体物理学中的一个标准流程：为N体模拟设置单位标度。所提供的球状星团物理参数（$M_{\\mathrm{phys}}$，$R_{\\mathrm{h}}$，$\\sigma_{\\mathrm{phys}}$）是此标度的基础。尽管存在轻微的物理不一致（对于给定质量和半径的维里化系统，给定的速度弥散略高），但这并不影响问题的有效性。任务不是验证物理模型的真实性，而是在给定一组特征参数的情况下正确执行单位标度程序。该问题在科学上基于牛顿引力和量纲分析，问题陈述清晰，目标明确，并提供了所有必要数据。因此，问题陈述是有效的。\n\n### 基于第一性原理的推导\n\n在N体模拟中，标准做法是使用一个引力常数 $G$ 等于1的单位系统。设质量、长度和时间的物理单位分别为 $M_{\\mathrm{unit}}$、$L_{\\mathrm{unit}}$ 和 $T_{\\mathrm{unit}}$。一个物理量 $Q_{\\mathrm{phys}}$ 通过除以这些单位尺度的适当组合，转换为其无量纲的代码单位对应量 $Q_{\\mathrm{code}}$。\n\n物理引力常数 $G_{\\mathrm{phys}}$ 与代码单位引力常数 $G_{\\mathrm{code}}$ 之间的关系由量纲分析给出：\n$$ G_{\\mathrm{code}} = G_{\\mathrm{phys}} \\frac{M_{\\mathrm{unit}} T_{\\mathrm{unit}}^2}{L_{\\mathrm{unit}}^3} $$\n设 $G_{\\mathrm{code}}=1$ 会对单位尺度施加一个约束：\n$$ 1 = G_{\\mathrm{phys}} \\frac{M_{\\mathrm{unit}} T_{\\mathrm{unit}}^2}{L_{\\mathrm{unit}}^3} \\implies T_{\\mathrm{unit}}^2 = \\frac{L_{\\mathrm{unit}}^3}{G_{\\mathrm{phys}} M_{\\mathrm{unit}}} $$\n由此，我们推导出时间单位：\n$$ T_{\\mathrm{unit}} = \\sqrt{\\frac{L_{\\mathrm{unit}}^3}{G_{\\mathrm{phys}} M_{\\mathrm{unit}}}} $$\n相应的速度单位 $V_{\\mathrm{unit}}$ 则为：\n$$ V_{\\mathrm{unit}} = \\frac{L_{\\mathrm{unit}}}{T_{\\mathrm{unit}}} = \\frac{L_{\\mathrm{unit}}}{\\sqrt{L_{\\mathrm{unit}}^3 / (G_{\\mathrm{phys}} M_{\\mathrm{unit}})}} = \\sqrt{\\frac{G_{\\mathrm{phys}} M_{\\mathrm{unit}}}{L_{\\mathrm{unit}}}} $$\n目标是选择 $M_{\\mathrm{unit}}$ 和 $L_{\\mathrm{unit}}$，使得系统的特征量在代码单位中为1的量级（$O(1)$）。这能通过使典型值远离上溢/下溢极限并减少算术运算中的有效位数损失，从而最大限度地减少双精度浮点运算中的数值误差。球状星团的特征尺度是其总质量 $M_{\\mathrm{phys}}$ 和其半质量半径 $R_{\\mathrm{h}}$。因此，最自然的单位标度选择是将 $M_{\\mathrm{unit}}$ 设为系统的总质量，并将 $L_{\\mathrm{unit}}$ 设为其特征半径。\n\n让我们采用这种“自然”标度：\n1.  将质量单位设为系统的总质量：$M_{\\mathrm{unit}} = M_{\\mathrm{phys}} = 10^5 \\, \\mathrm{M}_{\\odot}$。这确保了代码单位中的总质量为 $M_{\\mathrm{code}} = M_{\\mathrm{phys}}/M_{\\mathrm{unit}} = 1$。\n2.  将长度单位设为系统的特征半径：$L_{\\mathrm{unit}} = R_{\\mathrm{h}} = 3 \\, \\mathrm{pc}$。这确保了靠近半质量半径的粒子在代码单位中的半径为 $r_{\\mathrm{code}} = R_{\\mathrm{h}}/L_{\\mathrm{unit}} = 1$。\n\n作出这个选择后，我们现在可以检查由此产生的速度尺度是否也合适。物理速度弥散 $\\sigma_{\\mathrm{phys}}$ 应映射到量级为1的代码单位速度 $\\sigma_{\\mathrm{code}}$。我们首先计算导出的速度单位 $V_{\\mathrm{unit}}$：\n$$ V_{\\mathrm{unit}} = \\sqrt{\\frac{G_{\\mathrm{phys}} M_{\\mathrm{unit}}}{L_{\\mathrm{unit}}}} = \\sqrt{\\frac{(4.302\\times 10^{-3}\\,\\mathrm{pc}\\,\\mathrm{M}_{\\odot}^{-1}\\,(\\mathrm{km}/\\mathrm{s})^{2})(10^5\\,\\mathrm{M}_{\\odot})}{3\\,\\mathrm{pc}}} $$\n$$ V_{\\mathrm{unit}} = \\sqrt{\\frac{430.2}{3} \\, (\\mathrm{km/s})^2} = \\sqrt{143.4} \\, \\mathrm{km/s} \\approx 11.975 \\, \\mathrm{km/s} $$\n给定的物理速度弥散为 $\\sigma_{\\mathrm{phys}} \\approx 10$–$15\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$。相应的代码单位速度弥散为：\n$$ \\sigma_{\\mathrm{code}} = \\frac{\\sigma_{\\mathrm{phys}}}{V_{\\mathrm{unit}}} \\approx \\frac{10\\,\\mathrm{km}\\,\\mathrm{s}^{-1}}{11.975\\,\\mathrm{km}\\,\\mathrm{s}^{-1}} \\text{ to } \\frac{15\\,\\mathrm{km}\\,\\mathrm{s}^{-1}}{11.975\\,\\mathrm{km}\\,\\mathrm{s}^{-1}} $$\n$$ \\sigma_{\\mathrm{code}} \\approx 0.835 \\text{ to } 1.253 $$\n这个范围理想地以 $1$ 为中心。最后，特征动力学时间（或穿越时间）为 $T_{\\mathrm{cross}} \\sim R_{\\mathrm{h}}/\\sigma_{\\mathrm{phys}}$。在代码单位中，这变为 $t_{\\mathrm{cross, code}} \\sim r_{\\mathrm{h, code}}/\\sigma_{\\mathrm{code}} \\approx 1/1 = 1$。\n因此，选择 $M_{\\mathrm{unit}} = 10^5\\,\\mathrm{M}_{\\odot}$ 和 $L_{\\mathrm{unit}} = 3\\,\\mathrm{pc}$ 可以使特征质量、长度、速度和时间的代码单位值都约为1的量级。这是保持数值精度的理想情况。\n\n### 逐项分析\n\n现在我们根据这个理想标度来评估每个选项。\n\n**A. $M_{\\mathrm{unit}} = 10^{6}\\,\\mathrm{M}_{\\odot}$，$L_{\\mathrm{unit}} = 1\\,\\mathrm{pc}$。**\n- 代码单位中的总质量：$M_{\\mathrm{code}} = \\frac{10^5\\,\\mathrm{M}_{\\odot}}{10^6\\,\\mathrm{M}_{\\odot}} = 0.1$。这不等于1的量级。\n- 代码单位中的半质量半径：$r_{\\mathrm{h, code}} = \\frac{3\\,\\mathrm{pc}}{1\\,\\mathrm{pc}} = 3$。这可以说是在1的量级，但偏高。\n- 速度单位：$V_{\\mathrm{unit}} = \\sqrt{\\frac{(4.302\\times 10^{-3})(10^6)}{1}} \\approx 65.6\\,\\mathrm{km/s}$。\n- 代码单位中的速度弥散：$\\sigma_{\\mathrm{code}} = \\frac{10-15}{65.6} \\approx 0.15-0.23$。这不等于1的量级。\n这个选择导致特征质量和速度值显著小于 $1$，因此不是最优的。\n**结论：不正确。**\n\n**B. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$，$L_{\\mathrm{unit}} = 3\\,\\mathrm{pc}$。**\n- 代码单位中的总质量：$M_{\\mathrm{code}} = \\frac{10^5\\,\\mathrm{M}_{\\odot}}{10^5\\,\\mathrm{M}_{\\odot}} = 1$。理想。\n- 代码单位中的半质量半径：$r_{\\mathrm{h, code}} = \\frac{3\\,\\mathrm{pc}}{3\\,\\mathrm{pc}} = 1$。理想。\n- 速度单位：$V_{\\mathrm{unit}} = \\sqrt{\\frac{(4.302\\times 10^{-3})(10^5)}{3}} \\approx 11.975\\,\\mathrm{km/s}$。\n- 代码单位中的速度弥散：$\\sigma_{\\mathrm{code}} = \\frac{10-15}{11.975} \\approx 0.835-1.253$。理想。\n这个选择完美地将系统的特征物理尺度映射到代码单位值 $1$，为最小化数值误差提供了最佳条件。时间单位是 $T_{\\mathrm{unit}} = L_{\\mathrm{unit}}/V_{\\mathrm{unit}} = 3\\,\\mathrm{pc} / (11.975\\,\\mathrm{km/s}) \\approx 0.2505\\,\\mathrm{pc}/(\\mathrm{km/s}) \\approx 0.245\\,\\mathrm{Myr}$。代码单位中的穿越时间约为 $1$。\n**结论：正确。**\n\n**C. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$，$L_{\\mathrm{unit}} = 0.1\\,\\mathrm{pc}$。**\n- 代码单位中的总质量：$M_{\\mathrm{code}} = \\frac{10^5\\,\\mathrm{M}_{\\odot}}{10^5\\,\\mathrm{M}_{\\odot}} = 1$。理想。\n- 代码单位中的半质量半径：$r_{\\mathrm{h, code}} = \\frac{3\\,\\mathrm{pc}}{0.1\\,\\mathrm{pc}} = 30$。这不等于1的量级。典型粒子位置会很大，增加了舍入误差的风险。\n- 速度单位：$V_{\\mathrm{unit}} = \\sqrt{\\frac{(4.302\\times 10^{-3})(10^5)}{0.1}} \\approx 65.6\\,\\mathrm{km/s}$。\n- 代码单位中的速度弥散：$\\sigma_{\\mathrm{code}} = \\frac{10-15}{65.6} \\approx 0.15-0.23$。这不等于1的量级。\n这个选择很差，因为它导致代码单位中的位置值过大而速度值过小。\n**结论：不正确。**\n\n**D. $M_{\\mathrm{unit}} = 5\\times 10^{4}\\,\\mathrm{M}_{\\odot}$，$L_{\\mathrm{unit}} = 10\\,\\mathrm{pc}$。**\n- 代码单位中的总质量：$M_{\\mathrm{code}} = \\frac{10^5\\,\\mathrm{M}_{\\odot}}{5\\times 10^4\\,\\mathrm{M}_{\\odot}} = 2$。这在1的量级。\n- 代码单位中的半质量半径：$r_{\\mathrm{h, code}} = \\frac{3\\,\\mathrm{pc}}{10\\,\\mathrm{pc}} = 0.3$。这处于临界状态，偏小。\n- 速度单位：$V_{\\mathrm{unit}} = \\sqrt{\\frac{(4.302\\times 10^{-3})(5\\times 10^4)}{10}} = \\sqrt{21.51} \\approx 4.64\\,\\mathrm{km/s}$。\n- 代码单位中的速度弥散：$\\sigma_{\\mathrm{code}} = \\frac{10-15}{4.64} \\approx 2.16-3.23$。这些值变得偏大。\n尽管这些值比选项A和C中的值更接近 $1$，但它们始终偏离了2到3倍。选项B实现了更好的映射，所有主要特征量都映射到非常接近 $1$ 的值。\n**结论：不正确。**\n\n总之，选项B无疑是最合适的选择，因为它完美地将代码单位与物理系统的内在质量、长度和速度尺度对齐，从而为模拟提供了数值上最稳定的设置。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "数值积分器的选择是N体模拟中最关键的决策之一，对结果的长期保真度有着深远影响。这个动手编程练习让您通过一个时间反演实验，直接比较辛积分器（速度Verlet算法）与非辛积分器（四阶龙格-库塔法）的性能差异。通过观察它们在稳定和混沌系统中的不同表现，您将对辛结构、阴影哈密顿量及其在维持模拟物理真实性方面的重要性获得深刻的实践理解 。",
            "id": "3540226",
            "problem": "您的任务是设计并实现一个数值实验，以评估引力 $N$体问题中的时间不可逆性，检验时间反演后的失配如何依赖于积分器类型及其参数，并根据影子哈密顿量的概念解释观察到的行为。使用无量纲 $N$体单位进行工作，其中引力常数 $G=1$，粒子质量相等（按指定），位置使用相同的长度单位，速度使用相同的长度/时间单位，时间使用相同的时间单位。所有输出都必须使用这些无量纲单位。\n\n从应用于 $N$ 个点质量的牛顿第二定律（使用软化的成对牛顿引力）出发，加速度由软化势的负梯度确定。该系统遵循总能量的哈密顿流，其中动能和软化势能构成了哈密顿量。时间可逆性可以通过以下程序进行探测：向前积分到最终时间 $T$，将所有速度取反，然后使用相同的持续时间和参数再次向前积分，并量化相对于初始状态的位置失配。\n\n您的任务是：\n\n- 实现两种积分器：\n  1. 一种辛、时间可逆的方法，具体为速度 Verlet（也称蛙跳法）格式。\n  2. 一种非辛方法，具体为经典四阶 Runge-Kutta (RK4) 方法。\n\n- 使用物体间的软化引力。位于分离矢量 $\\mathbf{r}_{ij}$ 的物体 $i$ 和 $j$ 之间的软化势由下式给出：$$\\Phi_{ij} = -\\frac{G m_i m_j}{\\sqrt{\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2}},$$ 其对应的由物体 $j$ 施加于物体 $i$ 的力为：$$\\mathbf{F}_{ij} = - \\nabla \\Phi_{ij} = - G m_i m_j \\frac{\\mathbf{r}_{ij}}{\\left(\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2\\right)^{3/2}}.$$\n\n- 对每个测试用例执行以下实验：\n  1. 使用选定的积分器，以时间步长 $dt$ 将系统从时间 $t=0$ 向前积分到 $t=T$。\n  2. 在 $t=T$ 时，将每个速度矢量取反，即 $\\mathbf{v}_i \\leftarrow -\\mathbf{v}_i$。\n  3. 使用相同的积分器，再次向前积分相同的步数（持续时间 $T$ 和时间步长 $dt$）。\n  4. 计算均方根 (Root Mean Square, RMS) 位置失配：$$\\delta x = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\left\\lVert \\mathbf{x}_i^{\\text{back}} - \\mathbf{x}_i^{\\text{init}} \\right\\rVert^2}.$$ 以与位置相同的长度单位报告 $\\delta x$。\n\n- 软化引力常数设为 $G=1$。在所有测试中，软化长度固定为 $\\epsilon=10^{-2}$。物体数量 $N$、它们的质量 $m_i$、初始位置 $\\mathbf{x}_i(0)$ 和初始速度 $\\mathbf{v}_i(0)$ 将在下面为每个测试指定。\n\n- 在前向积分开始时实现总能量计算：$$E(0) = K(0) + U(0), \\quad K = \\sum_{i=1}^N \\frac{1}{2} m_i \\lVert \\mathbf{v}_i \\rVert^2, \\quad U = \\sum_{1 \\le i  j \\le N} - \\frac{G m_i m_j}{\\sqrt{\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2}},$$ 尽管您不需要输出能量；这仅用于内部一致性检查。\n\n- 设计程序以计算以下测试套件的上述 $\\delta x$ 值。每个测试用例以一个参数元组的形式给出，指定了积分器、$N$、质量、位置、速度、$dt$ 和 $T$：\n\n  1. 用例 A（理想路径，近可积双体，辛方法，小时间步长）：\n     - 积分器：速度 Verlet\n     - $N=2$, $m_1=m_2=1/2$\n     - $\\mathbf{x}_1(0)=(-1/2,0,0)$, $\\mathbf{x}_2(0)=(1/2,0,0)$\n     - 为相距 $r_0=1$ 的等质量粒子选择圆形轨道速度；对于每个半径为 $a=r_0/2$ 的物体，速度为 $v=\\sqrt{G m_{\\text{other}}/(2 r_0)}$，其中 $G=1$ 且 $m_{\\text{other}}=1/2$，因此 $v=1/(2\\sqrt{1})=1/2$。设置 $\\mathbf{v}_1(0)=(0,v,0)$ 和 $\\mathbf{v}_2(0)=(0,-v,0)$。\n     - $dt=10^{-3}$, $T=2$。\n\n  2. 用例 B（近可积双体，非辛方法，较大时间步长）：\n     - 积分器：经典四阶 Runge-Kutta (RK4)\n     - 与用例 A 相同的 $N$、质量、位置\n     - 与用例 A 相同的圆形轨道速度\n     - $dt=10^{-2}$, $T=2$。\n\n  3. 用例 C（三体类混沌构型，辛方法，小时间步长）：\n     - 积分器：速度 Verlet\n     - $N=3$, $m_i=1/3$ for $i=1,2,3$\n     - $\\mathbf{x}_1(0)=(-1,0,0)$, $\\mathbf{x}_2(0)=(1,0.2,0)$, $\\mathbf{x}_3(0)=(0,-0.8,0)$\n     - $\\mathbf{v}_1(0)=(0.3,0.2,0)$, $\\mathbf{v}_2(0)=(-0.2,0.5,0)$, $\\mathbf{v}_3(0)=(-0.1,-0.3,0)$\n     - $dt=2\\times 10^{-3}$, $T=5$。\n\n  4. 用例 D（三体类混沌构型，非辛方法，中等时间步长）：\n     - 积分器：经典四阶 Runge-Kutta (RK4)\n     - 与用例 C 相同的 $N$、质量、位置、速度\n     - $dt=5\\times 10^{-3}$, $T=5$。\n\n  5. 用例 E（三体类混沌构型，辛方法，大时间步长边界情况）：\n     - 积分器：速度 Verlet\n     - 与用例 C 相同的 $N$、质量、位置、速度\n     - $dt=5\\times 10^{-2}$, $T=5$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,\\dots]$），其中每个 $result_k$ 是按 A、B、C、D、E 顺序排列的用例 $k$ 的 $\\delta x$。每个 $\\delta x$ 必须是与位置单位相同的浮点数。程序必须是自包含的，且不得读取任何输入。",
            "solution": "所述问题是有效的。它提出了一个定义明确的数值实验，该实验基于经典力学和计算动力学的原理。所有必要的参数、初始条件和物理定律都已提供，构成了一个自包含且科学上合理的任务。\n\n目标是研究引力 $N$体问题数值解的时间可逆性。由牛顿运动定律支配的真实动力学是时间可逆的。如果在任何时刻，所有粒子的速度都被反向，系统将在相空间中追溯其路径，返回到其初始状态。本实验测试了两种不同的数值积分方案——速度 Verlet 和经典四阶 Runge-Kutta (RK4)——在多大程度上保持了这一基本对称性。与完美反演的偏差通过前向-后向积分序列后的均方根 (RMS) 位置失配 $\\delta x$ 来量化。\n\n系统的动力学由软化引力势决定，对于一对粒子 $i$ 和 $j$，其表达式为 $\\Phi_{ij} = -G m_i m_j / \\sqrt{\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2}$，其中 $\\mathbf{r}_{ij} = \\mathbf{x}_i - \\mathbf{x}_j$ 是分离矢量，$m_i$ 是质量，$G$ 是引力常数，$\\epsilon$ 是软化长度。粒子 $i$ 因粒子 $j$ 而受到的力是该势的负梯度，$\\mathbf{F}_{ij} = - \\nabla_i \\Phi_{ij} = -G m_i m_j \\mathbf{r}_{ij} / (\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2)^{3/2}$。粒子 $i$ 上的总加速度是 $\\mathbf{a}_i = (1/m_i) \\sum_{j \\neq i} \\mathbf{F}_{ij}$。这个设置定义了一个哈密顿系统，我们的目标是数值近似其在相空间 $(\\mathbf{x}, \\mathbf{v})$ 中的轨迹。\n\n分析的核心在于两种积分器的对比特性。\n\n速度 Verlet 积分器是几何积分器家族的一员，具体来说，它是辛且时间可逆的。其算法按“踢-漂移-踢”（kick-drift-kick）序列进行：\n1. 将速度更新半步：$\\mathbf{v}(t + dt/2) = \\mathbf{v}(t) + \\mathbf{a}(t) \\cdot dt/2$。\n2. 使用半步速度将位置更新一个完整步长：$\\mathbf{x}(t + dt) = \\mathbf{x}(t) + \\mathbf{v}(t + dt/2) \\cdot dt$。\n3. 在新位置计算新的加速度 $\\mathbf{a}(t+dt)$。\n4. 完成速度更新：$\\mathbf{v}(t + dt) = \\mathbf{v}(t + dt/2) + \\mathbf{a}(t+dt) \\cdot dt/2$。\n该方案是显式时间可逆的。如果执行一个大小为 $dt$ 的步长，将最终速度取反，再执行另一个大小为 $dt$ 的步长，系统将精确返回其初始状态，除非存在浮点舍入误差。此外，作为辛积分器意味着在许多步长之后，它不会精确守恒真实的哈密顿量 $H$，而是守恒一个附近的“影子哈密顿量” $H' = H + O(dt^2)$，并且对后者的守恒程度非常高。这一特性带来了优异的长期能量守恒（无长期漂移）和稳定性。因此，对于时间反演测试，Verlet 方法的失配 $\\delta x$ 应主要由机器精度舍入误差的累积所主导。\n\n相反，经典四阶 Runge-Kutta (RK4) 方法是一种通用的高精度常微分方程求解器。对于系统 $\\dot{\\mathbf{y}} = f(\\mathbf{y}, t)$，单步计算如下：\n$\\mathbf{k}_1 = f(\\mathbf{y}_n, t_n)$\n$\\mathbf{k}_2 = f(\\mathbf{y}_n + \\frac{dt}{2}\\mathbf{k}_1, t_n + \\frac{dt}{2})$\n$\\mathbf{k}_3 = f(\\mathbf{y}_n + \\frac{dt}{2}\\mathbf{k}_2, t_n + \\frac{dt}{2})$\n$\\mathbf{k}_4 = f(\\mathbf{y}_n + dt\\mathbf{k}_3, t_n + dt)$\n$\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{dt}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)$\n虽然 RK4 的局部截断误差很小，为 $O(dt^5)$ 阶，但它不是辛方法。它不保持哈密顿动力学的几何结构，也不守恒一个影子哈密顿量。它的误差虽然小，却是耗散的，并破坏了底层物理学的时间反演对称性。因此，前向-后向积分测试将产生一个远大于机器精度的失配 $\\delta x$，这主要是由该方法的累积截断误差引起的。\n\n数值实现将包括一个主程序，用于为每个测试用例组织实验。该程序将调用一个加速度函数，该函数根据所有粒子当前的位置计算引力加速度。为了提高效率，使用了向量化的 `NumPy` 操作。两个独立的步进函数 `verlet_step` 和 `rk4_step` 将分别实现对应积分器的逻辑。\n\n预期结果将突显这些理论差异。对于稳定的双体系统（用例 A, B），Verlet 方法 (A) 应表现出接近机器精度的 $\\delta x$，展示其内在的可逆性。RK4 方法 (B) 将显示出明显更大的 $\\delta x$，反映其非辛性质。对于混沌的三体系统（用例 C, D, E），由于小误差的指数级放大（李雅普诺夫不稳定性），情况更为复杂。即使对于 Verlet 方法 (C)，舍入误差也会被放大，导致 $\\delta x$ 比稳定情况下更大。然而，RK4 方法 (D) 的表现会更差，因为其更大的系统性截断误差和舍入误差都会被放大。用例 E 使用大时间步长的 Verlet 方法，将证明辛性并非准确性的保证；一个大的 $dt$ 意味着影子哈密顿量与真实哈密顿量相差甚远，由此产生的大的单步误差被混沌动力学严重放大，导致可逆性得分很差。",
            "answer": "```python\nimport numpy as np\n\ndef get_accelerations(pos, mass, G, epsilon):\n    \"\"\"\n    Calculate the acceleration of each body due to gravitational interaction.\n    The force on particle i from j is F_ij = -G m_i m_j * (r_i - r_j) / (|r_i - r_j|^2 + e^2)^(3/2).\n    Acceleration a_i = F_i / m_i = sum_j(F_ij) / m_i.\n    \n    Args:\n        pos (np.ndarray): Positions of N bodies, shape (N, 3).\n        mass (np.ndarray): Masses of N bodies, shape (N, 1).\n        G (float): Gravitational constant.\n        epsilon (float): Softening length.\n\n    Returns:\n        np.ndarray: Accelerations of N bodies, shape (N, 3).\n    \"\"\"\n    N = pos.shape[0]\n    # rij is a (N, N, 3) array where rij[i, j, :] = pos[i, :] - pos[j, :]\n    rij = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n\n    # dist_sq is a (N, N) array of squared separations\n    dist_sq = np.sum(rij**2, axis=-1)\n\n    # Add epsilon^2 to the denominator and compute inv_r3 = (dist^2 + e^2)^(-1.5)\n    # The diagonal (i=j) will have dist_sq=0, but epsilon avoids division by zero.\n    inv_r3 = (dist_sq + epsilon**2)**(-1.5)\n    \n    # Calculate forces. F_ij's magnitude is G * m_i * m_j / (dist^2+eps^2).\n    # Force vector is this magnitude * -(r_i-r_j)/dist. We rewrite this.\n    # F_i = sum_j!=i -G m_i m_j (r_i - r_j) * inv_r3_ij\n    # a_i = sum_j!=i -G m_j (r_i - r_j) * inv_r3_ij\n    \n    # We can write `a_i = G * sum_j m_j * (r_j - r_i) * inv_r3_ij`.\n    # Let's use the vectorized force calculation for clarity.\n    \n    # Mass matrix M[i, j] = m_i * m_j\n    mass_matrix = mass @ mass.T\n    \n    # Force magnitude component, excluding the vector part and signs.\n    # Note: F_ij = -G m_i m_j * rij / denom^(3/2)\n    # The term G * m_i * m_j * inv_r3 corresponds to the scalar part of the force.\n    scalar_force = G * mass_matrix * inv_r3\n\n    # Multiply by the displacement vectors. Diagonal rij[i,i] is zero, so F_ii is zero.\n    # F_vectors[i,j,:] is the force on i from j.\n    F_vectors = -rij * scalar_force[..., np.newaxis]\n\n    # Sum forces on each particle\n    F_total = np.sum(F_vectors, axis=1)\n\n    # a = F/m\n    accel = F_total / mass\n    \n    return accel\n\ndef verlet_step(pos, vel, acc, mass, G, epsilon, dt):\n    \"\"\"A single step of the Velocity Verlet integrator.\"\"\"\n    vel_half = vel + acc * 0.5 * dt\n    pos_new = pos + vel_half * dt\n    acc_new = get_accelerations(pos_new, mass, G, epsilon)\n    vel_new = vel_half + acc_new * 0.5 * dt\n    return pos_new, vel_new, acc_new\n\ndef rk4_step(pos, vel, mass, G, epsilon, dt):\n    \"\"\"A single step of the classic 4th-order Runge-Kutta integrator.\"\"\"\n    # k1\n    k1_x = vel\n    k1_v = get_accelerations(pos, mass, G, epsilon)\n    \n    # k2\n    k2_x = vel + k1_v * dt * 0.5\n    k2_v = get_accelerations(pos + k1_x * dt * 0.5, mass, G, epsilon)\n\n    # k3\n    k3_x = vel + k2_v * dt * 0.5\n    k3_v = get_accelerations(pos + k2_x * dt * 0.5, mass, G, epsilon)\n\n    # k4\n    k4_x = vel + k3_v * dt\n    k4_v = get_accelerations(pos + k3_x * dt, mass, G, epsilon)\n\n    # Update\n    pos_new = pos + (dt / 6.0) * (k1_x + 2*k2_x + 2*k3_x + k4_x)\n    vel_new = vel + (dt / 6.0) * (k1_v + 2*k2_v + 2*k3_v + k4_v)\n    \n    return pos_new, vel_new\n\ndef run_experiment(integrator_name, N, masses, pos_init, vel_init, dt, T, G, epsilon):\n    \"\"\"Performs the forward-backward integration and returns the mismatch.\"\"\"\n    pos = pos_init.copy()\n    vel = vel_init.copy()\n    \n    num_steps = int(round(T / dt))\n\n    # Forward integration\n    if integrator_name == 'verlet':\n        acc = get_accelerations(pos, masses, G, epsilon)\n        for _ in range(num_steps):\n            pos, vel, acc = verlet_step(pos, vel, acc, masses, G, epsilon, dt)\n    elif integrator_name == 'rk4':\n        for _ in range(num_steps):\n            pos, vel = rk4_step(pos, vel, masses, G, epsilon, dt)\n    \n    # Reverse velocities\n    vel = -vel\n\n    # Backward integration\n    if integrator_name == 'verlet':\n        # acc at time T is needed to start Verlet again\n        acc = get_accelerations(pos, masses, G, epsilon)\n        for _ in range(num_steps):\n            pos, vel, acc = verlet_step(pos, vel, acc, masses, G, epsilon, dt)\n    elif integrator_name == 'rk4':\n        for _ in range(num_steps):\n            pos, vel = rk4_step(pos, vel, masses, G, epsilon, dt)\n            \n    # Compute RMS position mismatch\n    diffs = pos - pos_init\n    rms_mismatch = np.sqrt(np.sum(diffs**2) / N)\n    \n    return rms_mismatch\n\ndef solve():\n    G_const = 1.0\n    epsilon_const = 1e-2\n\n    test_cases = [\n        {\n            \"id\": \"A\", \"integrator\": \"verlet\", \"N\": 2,\n            \"masses\": np.array([[0.5], [0.5]]),\n            \"pos\": np.array([[-0.5, 0.0, 0.0], [0.5, 0.0, 0.0]]),\n            \"vel\": np.array([[0.0, 0.5, 0.0], [0.0, -0.5, 0.0]]),\n            \"dt\": 1e-3, \"T\": 2.0\n        },\n        {\n            \"id\": \"B\", \"integrator\": \"rk4\", \"N\": 2,\n            \"masses\": np.array([[0.5], [0.5]]),\n            \"pos\": np.array([[-0.5, 0.0, 0.0], [0.5, 0.0, 0.0]]),\n            \"vel\": np.array([[0.0, 0.5, 0.0], [0.0, -0.5, 0.0]]),\n            \"dt\": 1e-2, \"T\": 2.0\n        },\n        {\n            \"id\": \"C\", \"integrator\": \"verlet\", \"N\": 3,\n            \"masses\": np.array([[1./3.], [1./3.], [1./3.]]),\n            \"pos\": np.array([[-1.0, 0.0, 0.0], [1.0, 0.2, 0.0], [0.0, -0.8, 0.0]]),\n            \"vel\": np.array([[0.3, 0.2, 0.0], [-0.2, 0.5, 0.0], [-0.1, -0.3, 0.0]]),\n            \"dt\": 2e-3, \"T\": 5.0\n        },\n        {\n            \"id\": \"D\", \"integrator\": \"rk4\", \"N\": 3,\n            \"masses\": np.array([[1./3.], [1./3.], [1./3.]]),\n            \"pos\": np.array([[-1.0, 0.0, 0.0], [1.0, 0.2, 0.0], [0.0, -0.8, 0.0]]),\n            \"vel\": np.array([[0.3, 0.2, 0.0], [-0.2, 0.5, 0.0], [-0.1, -0.3, 0.0]]),\n            \"dt\": 5e-3, \"T\": 5.0\n        },\n        {\n            \"id\": \"E\", \"integrator\": \"verlet\", \"N\": 3,\n            \"masses\": np.array([[1./3.], [1./3.], [1./3.]]),\n            \"pos\": np.array([[-1.0, 0.0, 0.0], [1.0, 0.2, 0.0], [0.0, -0.8, 0.0]]),\n            \"vel\": np.array([[0.3, 0.2, 0.0], [-0.2, 0.5, 0.0], [-0.1, -0.3, 0.0]]),\n            \"dt\": 5e-2, \"T\": 5.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_x = run_experiment(\n            integrator_name=case[\"integrator\"],\n            N=case[\"N\"],\n            masses=case[\"masses\"],\n            pos_init=case[\"pos\"],\n            vel_init=case[\"vel\"],\n            dt=case[\"dt\"],\n            T=case[\"T\"],\n            G=G_const,\n            epsilon=epsilon_const\n        )\n        results.append(delta_x)\n\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}