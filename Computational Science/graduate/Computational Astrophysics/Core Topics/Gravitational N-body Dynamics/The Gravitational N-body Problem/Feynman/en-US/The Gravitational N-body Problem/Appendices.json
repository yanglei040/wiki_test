{
    "hands_on_practices": [
        {
            "introduction": "Before writing a single line of integration code, a computational astrophysicist must make a crucial decision: how to represent the physical world inside the computer. This exercise  addresses the foundational practice of setting up code units for an N-body simulation. A naive choice can lead to numerical catastrophe, but by scaling the problem such that the system's characteristic mass, length, and velocity are of order unity ($O(1)$), we can significantly improve numerical stability and minimize round-off errors. This practice will guide you through the dimensional analysis needed to map a physical globular cluster into a well-behaved computational domain.",
            "id": "3540198",
            "problem": "You are preparing a direct gravitational N-body simulation of a realistic globular cluster in code units with $G=1$, $M=1$, and $L=1$, where $G$ is the gravitational constant, $M$ is the mass unit, and $L$ is the length unit. The physical target system has total mass $M_{\\mathrm{phys}} \\approx 10^{5}\\,\\mathrm{M}_{\\odot}$, half-mass radius $R_{\\mathrm{h}} \\approx 3\\,\\mathrm{pc}$, and a one-dimensional velocity dispersion at $R_{\\mathrm{h}}$ of order $10$–$15\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$. You will run the simulation in double-precision floating-point (DPFP) arithmetic with machine epsilon $\\epsilon_{\\mathrm{mach}} \\approx 2.22\\times 10^{-16}$, and you want to minimize round-off and overflow or underflow risks throughout the integration and diagnostics (positions, velocities, accelerations, energies, and time steps). Assume no external tides and equal-mass particles.\n\nStarting from Newton’s law of gravitation and dimensional analysis, determine which of the following choices of physical unit scaling $(M_{\\mathrm{unit}},L_{\\mathrm{unit}})$ for the code’s $(G=1, M=1, L=1)$ best maps the globular cluster to code-space so that typical dimensionless positions near $R_{\\mathrm{h}}$, velocity dispersion, and crossing time are all of order unity. Use the widely accepted astrophysical value $G_{\\mathrm{phys}} \\approx 4.302\\times 10^{-3}\\,\\mathrm{pc}\\,\\mathrm{M}_{\\odot}^{-1}\\,(\\mathrm{km}/\\mathrm{s})^{2}$ and the conversion $1\\,\\mathrm{pc}/(\\mathrm{km}/\\mathrm{s}) \\approx 0.9778\\,\\mathrm{Myr}$ if needed. Your choice must be justified by first-principles reasoning that links the scaling to the characteristic dynamical scales and explains why it minimizes numerical risk in DPFP.\n\nWhich option is most appropriate?\n\n- A. $M_{\\mathrm{unit}} = 10^{6}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 1\\,\\mathrm{pc}$.\n- B. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 3\\,\\mathrm{pc}$.\n- C. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 0.1\\,\\mathrm{pc}$.\n- D. $M_{\\mathrm{unit}} = 5\\times 10^{4}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 10\\,\\mathrm{pc}$.\n\nAnswer by selecting the single best option and justify it from first principles, explaining what the code-unit velocity and time scales are in physical units for each choice, and why your selection reduces round-off and overflow or underflow risks in DPFP arithmetic for the intended globular cluster model.",
            "solution": "The goal is to select a system of physical units $(M_{\\mathrm{unit}}, L_{\\mathrm{unit}})$ that maps the characteristic physical properties of a globular cluster to dimensionless code-unit values of order one. This practice is crucial for minimizing numerical round-off and overflow/underflow errors in a simulation.\n\nIn N-body simulations, it's conventional to work in a unit system where the gravitational constant $G_{\\mathrm{code}} = 1$. The relationship between the physical gravitational constant ($G_{\\mathrm{phys}}$) and the code unit is given by dimensional analysis:\n$$ G_{\\mathrm{code}} = G_{\\mathrm{phys}} \\frac{M_{\\mathrm{unit}} T_{\\mathrm{unit}}^2}{L_{\\mathrm{unit}}^3} $$\nSetting $G_{\\mathrm{code}}=1$ allows us to derive the simulation's time unit ($T_{\\mathrm{unit}}$) and velocity unit ($V_{\\mathrm{unit}}$) from our chosen mass and length units:\n$$ T_{\\mathrm{unit}} = \\sqrt{\\frac{L_{\\mathrm{unit}}^3}{G_{\\mathrm{phys}} M_{\\mathrm{unit}}}} \\quad \\text{and} \\quad V_{\\mathrm{unit}} = \\frac{L_{\\mathrm{unit}}}{T_{\\mathrm{unit}}} = \\sqrt{\\frac{G_{\\mathrm{phys}} M_{\\mathrm{unit}}}{L_{\\mathrm{unit}}}} $$\nTo ensure numerical stability, we should choose $M_{\\mathrm{unit}}$ and $L_{\\mathrm{unit}}$ to match the characteristic mass and length scales of the physical system. For the given globular cluster, these are its total mass, $M_{\\mathrm{phys}} \\approx 10^{5}\\,\\mathrm{M}_{\\odot}$, and its half-mass radius, $R_{\\mathrm{h}} \\approx 3\\,\\mathrm{pc}$. This choice ensures that the total mass in code units is approximately 1, and typical particle positions are also of order 1.\n\nLet's analyze the options based on this principle:\n\n**A. $M_{\\mathrm{unit}} = 10^{6}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 1\\,\\mathrm{pc}$.**\n- Code mass: $M_{\\mathrm{code}} = 10^5/10^6 = 0.1$.\n- Code radius: $r_{\\mathrm{h, code}} = 3/1 = 3$.\n- Velocity unit: $V_{\\mathrm{unit}} \\approx 65.6\\,\\mathrm{km/s}$. Code velocity: $\\sigma_{\\mathrm{code}} \\approx (10-15)/65.6 \\approx 0.15-0.23$.\n- None of the characteristic values are close to 1. This is a poor choice.\n\n**B. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 3\\,\\mathrm{pc}$.**\n- Code mass: $M_{\\mathrm{code}} = 10^5/10^5 = 1$. This is ideal.\n- Code radius: $r_{\\mathrm{h, code}} = 3/3 = 1$. This is ideal.\n- Velocity unit: $V_{\\mathrm{unit}} = \\sqrt{\\frac{(4.302\\times 10^{-3})(10^5)}{3}} \\approx 11.975\\,\\mathrm{km/s}$.\n- Code velocity: $\\sigma_{\\mathrm{code}} \\approx (10-15)/11.975 \\approx 0.835-1.253$. This is also ideal, as it is centered around 1.\n- This choice perfectly maps the system's characteristic mass, length, and velocity scales to values of order unity. This minimizes the risk of numerical errors and is the best option.\n\n**C. $M_{\\mathrm{unit}} = 10^{5}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 0.1\\,\\mathrm{pc}$.**\n- Code mass: $M_{\\mathrm{code}} = 10^5/10^5 = 1$.\n- Code radius: $r_{\\mathrm{h, code}} = 3/0.1 = 30$. This is too large.\n- Velocity unit: $V_{\\mathrm{unit}} \\approx 65.6\\,\\mathrm{km/s}$. Code velocity: $\\sigma_{\\mathrm{code}} \\approx 0.15-0.23$. This is too small.\n- This choice leads to large position values and small velocity values, which is numerically suboptimal.\n\n**D. $M_{\\mathrm{unit}} = 5\\times 10^{4}\\,\\mathrm{M}_{\\odot}$, $L_{\\mathrm{unit}} = 10\\,\\mathrm{pc}$.**\n- Code mass: $M_{\\mathrm{code}} = 10^5/(5\\times 10^4) = 2$.\n- Code radius: $r_{\\mathrm{h, code}} = 3/10 = 0.3$.\n- Velocity unit: $V_{\\mathrm{unit}} \\approx 4.64\\,\\mathrm{km/s}$. Code velocity: $\\sigma_{\\mathrm{code}} \\approx (10-15)/4.64 \\approx 2.16-3.23$.\n- While better than A and C, the characteristic values are consistently off from 1 by factors of 2-3. Option B is superior.\n\nIn conclusion, Option B is the most appropriate choice because it aligns the code's unit system with the intrinsic physical scales of the globular cluster, ensuring that the dominant quantities in the simulation are all of order unity. This provides the most numerically stable environment for the integration.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "The true laws of gravity, as described by Hamiltonian mechanics, are perfectly time-reversible. If we could reverse the velocities of all particles in the universe, they would retrace their cosmic dance back to their initial state. This practice  is a numerical experiment designed to see how well this fundamental symmetry holds up in a simulation. By running a system forward and then backward in time with both a symplectic (Velocity Verlet) and a non-symplectic (RK4) integrator, you will gain a powerful, intuitive understanding of why geometric integrators are essential for the long-term study of gravitational systems and how their behavior relates to the concept of a conserved \"shadow Hamiltonian\".",
            "id": "3540226",
            "problem": "You are tasked to design and implement a numerical experiment to assess time-irreversibility in the gravitational $N$-body problem, examine how the mismatch after time reversal depends on the integrator class and its parameters, and interpret the observed behavior in terms of the concept of a shadow Hamiltonian. Work in dimensionless $N$-body units with gravitational constant $G=1$, equal-mass particles as specified, positions in the same length units, velocities in the same length-per-time units, and time in the same time units. All outputs must be in these dimensionless units.\n\nStarting from Newton's second law applied to $N$ point masses with softened pairwise Newtonian gravity, the accelerations are determined by the negative gradient of the softened potential. The system follows a Hamiltonian flow for the total energy, with the kinetic energy and softened potential energy providing the Hamiltonian. Time reversibility can be probed by the following procedure: integrate forward to a final time $T$, negate all velocities, then integrate forward again for the same duration and parameters, and quantify the mismatch in positions relative to the initial state.\n\nYour task is to:\n\n- Implement two integrators:\n  1. A symplectic, time-reversible method, specifically the velocity Verlet (also known as leapfrog) scheme.\n  2. A non-symplectic method, specifically the classical fourth-order Runge-Kutta (RK4) method.\n\n- Use a softened gravitational force between bodies. The softened potential between bodies $i$ and $j$ at separation vector $\\mathbf{r}_{ij}$ is given by $$\\Phi_{ij} = -\\frac{G m_i m_j}{\\sqrt{\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2}},$$ and its corresponding force on body $i$ due to $j$ is $$\\mathbf{F}_{ij} = - \\nabla \\Phi_{ij} = - G m_i m_j \\frac{\\mathbf{r}_{ij}}{\\left(\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2\\right)^{3/2}}.$$\n\n- For each test case, perform the following experiment:\n  1. Integrate the system forward from time $t=0$ to $t=T$ with a timestep $dt$ using the selected integrator.\n  2. At $t=T$, reverse every velocity vector, i.e., $\\mathbf{v}_i \\leftarrow -\\mathbf{v}_i$.\n  3. Integrate forward again for the same number of steps (duration $T$ and timestep $dt$) using the same integrator.\n  4. Compute the root-mean-square (RMS) position mismatch $$\\delta x = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\left\\lVert \\mathbf{x}_i^{\\text{back}} - \\mathbf{x}_i^{\\text{init}} \\right\\rVert^2}.$$ Report $\\delta x$ in the same length units as the positions.\n\n- The softened gravitational constant is set to $G=1$. The softening length is fixed to $\\epsilon=10^{-2}$ across all tests. The number of bodies $N$, their masses $m_i$, their initial positions $\\mathbf{x}_i(0)$, and initial velocities $\\mathbf{v}_i(0)$ are specified below for each test.\n\n- Implement total energy computation at the start of the forward integration as $$E(0) = K(0) + U(0), \\quad K = \\sum_{i=1}^N \\frac{1}{2} m_i \\lVert \\mathbf{v}_i \\rVert^2, \\quad U = \\sum_{1 \\le i < j \\le N} - \\frac{G m_i m_j}{\\sqrt{\\lVert \\mathbf{r}_{ij} \\rVert^2 + \\epsilon^2}},$$ although you do not need to output energy; it is for internal consistency checks only.\n\n- Design the program to compute the above $\\delta x$ values for the following test suite. Each test case is given as a tuple of parameters specifying the integrator, $N$, masses, positions, velocities, $dt$, and $T$:\n\n  1. Case A (happy path, near-integrable two-body, symplectic, small timestep):\n     - Integrator: velocity Verlet\n     - $N=2$, $m_1=m_2=1/2$\n     - $\\mathbf{x}_1(0)=(-1/2,0,0)$, $\\mathbf{x}_2(0)=(1/2,0,0)$\n     - Choose a circular orbit speed for equal masses separated by $r_0=1$; for each body at radius $a=r_0/2$, the speed is $v=\\sqrt{G m_{\\text{other}}/(2 r_0)}$ with $G=1$ and $m_{\\text{other}}=1/2$, so $v=1/(2\\sqrt{1})=1/2$. Set $\\mathbf{v}_1(0)=(0,v,0)$ and $\\mathbf{v}_2(0)=(0,-v,0)$.\n     - $dt=10^{-3}$, $T=2$.\n\n  2. Case B (near-integrable two-body, non-symplectic, larger timestep):\n     - Integrator: classical fourth-order Runge-Kutta (RK4)\n     - Same $N$, masses, positions as Case A\n     - Same circular orbit velocities as Case A\n     - $dt=10^{-2}$, $T=2$.\n\n  3. Case C (three-body chaotic-like configuration, symplectic, small timestep):\n     - Integrator: velocity Verlet\n     - $N=3$, $m_i=1/3$ for $i=1,2,3$\n     - $\\mathbf{x}_1(0)=(-1,0,0)$, $\\mathbf{x}_2(0)=(1,0.2,0)$, $\\mathbf{x}_3(0)=(0,-0.8,0)$\n     - $\\mathbf{v}_1(0)=(0.3,0.2,0)$, $\\mathbf{v}_2(0)=(-0.2,0.5,0)$, $\\mathbf{v}_3(0)=(-0.1,-0.3,0)$\n     - $dt=2\\times 10^{-3}$, $T=5$.\n\n  4. Case D (three-body chaotic-like configuration, non-symplectic, moderate timestep):\n     - Integrator: classical fourth-order Runge-Kutta (RK4)\n     - Same $N$, masses, positions, velocities as Case C\n     - $dt=5\\times 10^{-3}$, $T=5$.\n\n  5. Case E (three-body chaotic-like configuration, symplectic, boundary with large timestep):\n     - Integrator: velocity Verlet\n     - Same $N$, masses, positions, velocities as Case C\n     - $dt=5\\times 10^{-2}$, $T=5$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$), where each $result_k$ is the $\\delta x$ for Case $k$ in the order A, B, C, D, E. Each $\\delta x$ must be a floating-point number in the same length units as the positions. The program must be self-contained and must not read any input.",
            "solution": "This problem investigates the time-reversibility of numerical solutions to the gravitational N-body problem. The underlying physical laws are time-reversible, meaning that if all particle velocities are reversed at any time, the system should retrace its path back to its initial state. This experiment tests how well two common numerical integration schemes—Velocity Verlet (a symplectic method) and classical fourth-order Runge-Kutta (RK4, a non-symplectic method)—preserve this fundamental symmetry. The deviation is measured by the root-mean-square position mismatch ($\\delta x$) after integrating forward in time, reversing velocities, and integrating backward to the start.\n\nThe key to understanding the results lies in the different geometric properties of the integrators:\n\n1.  **Velocity Verlet (Leapfrog)**: This is a symplectic integrator, meaning it is designed to preserve the geometric structure of Hamiltonian systems. It is explicitly time-reversible by construction. A single step forward followed by a velocity-negated step forward exactly returns the system to its starting point, aside from finite-precision floating-point errors. Over long integrations, it does not conserve the true energy perfectly but instead conserves a \"shadow Hamiltonian\" that is very close to the true one. This prevents systematic energy drift. In the time-reversal test, the mismatch $\\delta x$ for Verlet is expected to be extremely small, on the order of machine precision, reflecting the accumulation of round-off errors.\n\n2.  **Classical Fourth-Order Runge-Kutta (RK4)**: This is a high-accuracy, general-purpose solver. However, it is not symplectic. The method introduces small truncation errors at each step that, while small, are dissipative and break the time-reversal symmetry inherent in the physics. Over time, these errors accumulate. In the time-reversal test, the final state will not match the initial state. The resulting mismatch $\\delta x$ will be significantly larger than machine precision and will be dominated by the method's accumulated truncation error.\n\nThe provided Python code implements this experiment. The `get_accelerations` function computes the gravitational force on all particles using the softened potential specified. The `verlet_step` and `rk4_step` functions implement the respective integration algorithms. The main experimental routine `run_experiment` orchestrates the forward and backward integration sequence for each test case and calculates the final $\\delta x$.\n\nThe test cases are designed to highlight these differences under various conditions:\n- **Cases A and B** compare Verlet and RK4 on a stable, predictable two-body orbit. Verlet (A) should show near-perfect reversibility ($\\delta x \\approx 10^{-14}$), while RK4 (B) will have a much larger error.\n- **Cases C, D, and E** use a chaotic three-body system. In chaotic systems, small errors are amplified exponentially. Even the tiny round-off errors in the Verlet method (C) will be amplified, leading to a larger $\\delta x$ than in the stable case, but the result will still be superior to RK4 (D), where larger truncation errors are also amplified. Case E demonstrates that even a symplectic integrator performs poorly if the timestep is too large, as the shadow Hamiltonian diverges significantly from the true one.",
            "answer": "```python\nimport numpy as np\n\ndef get_accelerations(pos, mass, G, epsilon):\n    \"\"\"\n    Calculate the acceleration of each body due to gravitational interaction.\n    The force on particle i from j is F_ij = -G m_i m_j * (r_i - r_j) / (|r_i - r_j|^2 + e^2)^(3/2).\n    Acceleration a_i = F_i / m_i = sum_j(F_ij) / m_i.\n    \n    Args:\n        pos (np.ndarray): Positions of N bodies, shape (N, 3).\n        mass (np.ndarray): Masses of N bodies, shape (N, 1).\n        G (float): Gravitational constant.\n        epsilon (float): Softening length.\n\n    Returns:\n        np.ndarray: Accelerations of N bodies, shape (N, 3).\n    \"\"\"\n    N = pos.shape[0]\n    # rij is a (N, N, 3) array where rij[i, j, :] = pos[i, :] - pos[j, :]\n    rij = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n\n    # dist_sq is a (N, N) array of squared separations\n    dist_sq = np.sum(rij**2, axis=-1)\n\n    # Add epsilon^2 to the denominator and compute inv_r3 = (dist^2 + e^2)^(-3/2)\n    # The diagonal (i=j) will have dist_sq=0, but epsilon avoids division by zero.\n    inv_r3 = (dist_sq + epsilon**2)**(-1.5)\n    \n    # Calculate forces. F_ij's magnitude is G * m_i * m_j / (dist^2+eps^2).\n    # Force vector is this magnitude * -(r_i-r_j)/dist. We rewrite this.\n    # F_i = sum_j!=i -G m_i m_j (r_i - r_j) * inv_r3_ij\n    # a_i = sum_j!=i -G m_j (r_i - r_j) * inv_r3_ij\n    \n    # We can write `a_i = G * sum_j m_j * (r_j - r_i) * inv_r3_ij`.\n    # Let's use the vectorized force calculation for clarity.\n    \n    # Mass matrix M[i, j] = m_i * m_j\n    mass_matrix = mass @ mass.T\n    \n    # Force magnitude component, excluding the vector part and signs.\n    # Note: F_ij = -G m_i m_j * rij / denom^(3/2)\n    # The term G * m_i * m_j * inv_r3 corresponds to the scalar part of the force.\n    scalar_force = G * mass_matrix * inv_r3\n\n    # Multiply by the displacement vectors. Diagonal rij[i,i] is zero, so F_ii is zero.\n    # F_vectors[i,j,:] is the force on i from j.\n    F_vectors = -rij * scalar_force[..., np.newaxis]\n\n    # Sum forces on each particle\n    F_total = np.sum(F_vectors, axis=1)\n\n    # a = F/m\n    accel = F_total / mass\n    \n    return accel\n\ndef verlet_step(pos, vel, acc, mass, G, epsilon, dt):\n    \"\"\"A single step of the Velocity Verlet integrator.\"\"\"\n    vel_half = vel + acc * 0.5 * dt\n    pos_new = pos + vel_half * dt\n    acc_new = get_accelerations(pos_new, mass, G, epsilon)\n    vel_new = vel_half + acc_new * 0.5 * dt\n    return pos_new, vel_new, acc_new\n\ndef rk4_step(pos, vel, mass, G, epsilon, dt):\n    \"\"\"A single step of the classic 4th-order Runge-Kutta integrator.\"\"\"\n    # k1\n    k1_x = vel\n    k1_v = get_accelerations(pos, mass, G, epsilon)\n    \n    # k2\n    k2_x = vel + k1_v * dt * 0.5\n    k2_v = get_accelerations(pos + k1_x * dt * 0.5, mass, G, epsilon)\n\n    # k3\n    k3_x = vel + k2_v * dt * 0.5\n    k3_v = get_accelerations(pos + k2_x * dt * 0.5, mass, G, epsilon)\n\n    # k4\n    k4_x = vel + k3_v * dt\n    k4_v = get_accelerations(pos + k3_x * dt, mass, G, epsilon)\n\n    # Update\n    pos_new = pos + (dt / 6.0) * (k1_x + 2*k2_x + 2*k3_x + k4_x)\n    vel_new = vel + (dt / 6.0) * (k1_v + 2*k2_v + 2*k3_v + k4_v)\n    \n    return pos_new, vel_new\n\ndef run_experiment(integrator_name, N, masses, pos_init, vel_init, dt, T, G, epsilon):\n    \"\"\"Performs the forward-backward integration and returns the mismatch.\"\"\"\n    pos = pos_init.copy()\n    vel = vel_init.copy()\n    \n    num_steps = int(round(T / dt))\n\n    # Forward integration\n    if integrator_name == 'verlet':\n        acc = get_accelerations(pos, masses, G, epsilon)\n        for _ in range(num_steps):\n            pos, vel, acc = verlet_step(pos, vel, acc, masses, G, epsilon, dt)\n    elif integrator_name == 'rk4':\n        for _ in range(num_steps):\n            pos, vel = rk4_step(pos, vel, masses, G, epsilon, dt)\n    \n    # Reverse velocities\n    vel = -vel\n\n    # Backward integration\n    if integrator_name == 'verlet':\n        # acc at time T is needed to start Verlet again\n        acc = get_accelerations(pos, masses, G, epsilon)\n        for _ in range(num_steps):\n            pos, vel, acc = verlet_step(pos, vel, acc, masses, G, epsilon, dt)\n    elif integrator_name == 'rk4':\n        for _ in range(num_steps):\n            pos, vel = rk4_step(pos, vel, masses, G, epsilon, dt)\n            \n    # Compute RMS position mismatch\n    diffs = pos - pos_init\n    rms_mismatch = np.sqrt(np.sum(diffs**2) / N)\n    \n    return rms_mismatch\n\ndef solve():\n    G_const = 1.0\n    epsilon_const = 1e-2\n\n    test_cases = [\n        {\n            \"id\": \"A\", \"integrator\": \"verlet\", \"N\": 2,\n            \"masses\": np.array([[0.5], [0.5]]),\n            \"pos\": np.array([[-0.5, 0.0, 0.0], [0.5, 0.0, 0.0]]),\n            \"vel\": np.array([[0.0, 0.5, 0.0], [0.0, -0.5, 0.0]]),\n            \"dt\": 1e-3, \"T\": 2.0\n        },\n        {\n            \"id\": \"B\", \"integrator\": \"rk4\", \"N\": 2,\n            \"masses\": np.array([[0.5], [0.5]]),\n            \"pos\": np.array([[-0.5, 0.0, 0.0], [0.5, 0.0, 0.0]]),\n            \"vel\": np.array([[0.0, 0.5, 0.0], [0.0, -0.5, 0.0]]),\n            \"dt\": 1e-2, \"T\": 2.0\n        },\n        {\n            \"id\": \"C\", \"integrator\": \"verlet\", \"N\": 3,\n            \"masses\": np.array([[1./3.], [1./3.], [1./3.]]),\n            \"pos\": np.array([[-1.0, 0.0, 0.0], [1.0, 0.2, 0.0], [0.0, -0.8, 0.0]]),\n            \"vel\": np.array([[0.3, 0.2, 0.0], [-0.2, 0.5, 0.0], [-0.1, -0.3, 0.0]]),\n            \"dt\": 2e-3, \"T\": 5.0\n        },\n        {\n            \"id\": \"D\", \"integrator\": \"rk4\", \"N\": 3,\n            \"masses\": np.array([[1./3.], [1./3.], [1./3.]]),\n            \"pos\": np.array([[-1.0, 0.0, 0.0], [1.0, 0.2, 0.0], [0.0, -0.8, 0.0]]),\n            \"vel\": np.array([[0.3, 0.2, 0.0], [-0.2, 0.5, 0.0], [-0.1, -0.3, 0.0]]),\n            \"dt\": 5e-3, \"T\": 5.0\n        },\n        {\n            \"id\": \"E\", \"integrator\": \"verlet\", \"N\": 3,\n            \"masses\": np.array([[1./3.], [1./3.], [1./3.]]),\n            \"pos\": np.array([[-1.0, 0.0, 0.0], [1.0, 0.2, 0.0], [0.0, -0.8, 0.0]]),\n            \"vel\": np.array([[0.3, 0.2, 0.0], [-0.2, 0.5, 0.0], [-0.1, -0.3, 0.0]]),\n            \"dt\": 5e-2, \"T\": 5.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_x = run_experiment(\n            integrator_name=case[\"integrator\"],\n            N=case[\"N\"],\n            masses=case[\"masses\"],\n            pos_init=case[\"pos\"],\n            vel_init=case[\"vel\"],\n            dt=case[\"dt\"],\n            T=case[\"T\"],\n            G=G_const,\n            epsilon=epsilon_const\n        )\n        results.append(delta_x)\n\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While the previous exercise demonstrated the practical consequences of symplecticity through a time-reversal experiment, this practice delves into its rigorous mathematical foundation. A numerical map is symplectic if its Jacobian, known as the monodromy matrix $J$, preserves the canonical symplectic form $M$ such that $J^\\top M J = M$. In this advanced exercise , you will move beyond observing effects and perform a direct verification. By implementing the variational equations to evolve the monodromy matrix alongside the system's trajectory, you will numerically confirm whether an integrator adheres to this defining geometric property, providing a definitive test of its character.",
            "id": "3540177",
            "problem": "Consider a gravitational $N$-body system in canonical Hamiltonian form with positions $q_i \\in \\mathbb{R}^3$ and momenta $p_i \\in \\mathbb{R}^3$ for $i \\in \\{1,\\dots,N\\}$, masses $m_i > 0$, and gravitational constant chosen as $G = 1$ to enforce dimensionless units. The Hamiltonian is\n$$\nH(q,p) = \\sum_{i=1}^{N} \\frac{\\|p_i\\|^2}{2 m_i} - \\sum_{1 \\le i < j \\le N} \\frac{m_i m_j}{\\|q_i - q_j\\|},\n$$\nwith Hamilton's equations\n$$\n\\dot{q}_i = \\frac{p_i}{m_i}, \\qquad \\dot{p}_i = -\\frac{\\partial U}{\\partial q_i}(q) = F_i(q),\n$$\nwhere $U(q) = \\sum_{1 \\le i<j \\le N} \\frac{m_i m_j}{\\|q_i - q_j\\|}$ and $F_i(q)$ is the gravitational force on body $i$ due to all bodies $j \\ne i$.\n\nDefine the state vector $z \\in \\mathbb{R}^{6N}$ by concatenating $q$ and $p$ as $z = (q,p)$. Denote by $M \\in \\mathbb{R}^{6N \\times 6N}$ the canonical symplectic form matrix\n$$\nM = \\begin{pmatrix}\n0_{3N} & I_{3N} \\\\\n- I_{3N} & 0_{3N}\n\\end{pmatrix}.\n$$\nFor a one-step update map $\\Psi_{\\Delta t}: \\mathbb{R}^{6N} \\to \\mathbb{R}^{6N}$ (with time-step $\\Delta t > 0$), its Jacobian $J \\in \\mathbb{R}^{6N \\times 6N}$ at a state $z$ is the monodromy matrix of the discrete map at that step. A method is symplectic if its map satisfies the symplecticity condition $J^\\top M J = M$. Over multiple steps, the monodromy accumulates by composition of per-step Jacobians, and exact symplecticity implies $J(t)^\\top M J(t) = M$ for all discrete times.\n\nTask: Implement a program that, for the gravitational $N$-body problem, evaluates symplecticity numerically by computing the monodromy matrix $J(t)$ over time for two integrators:\n- the canonical leapfrog (velocity Verlet) scheme applied in $(q,p)$,\n- the classical fourth-order Runge-Kutta (RK4) scheme applied to the ordinary differential equation (ODE) $\\dot{z} = f(z)$ in $(q,p)$.\n\nYou must:\n1. Derive, implement, and use the exact linearization (variational equations) necessary to compute the per-step Jacobian for each integrator. For leapfrog, treat it as a composition of exact submaps (half-kick, drift, half-kick) in canonical variables. For RK4, use the chain rule to differentiate the discrete stage construction $k_1, k_2, k_3, k_4$ to obtain the per-step Jacobian.\n2. Accumulate the monodromy over time by multiplying per-step Jacobians in chronological order.\n3. At each step $n$, compute the Frobenius-norm violation of symplecticity\n$$\n\\varepsilon_n = \\left\\| J_n^\\top M J_n - M \\right\\|_F,\n$$\nwhere $J_n$ is the cumulative monodromy after $n$ steps and $\\|\\cdot\\|_F$ denotes the Frobenius norm. Report, for each integrator, the maximum violation over the entire simulated interval:\n$$\n\\varepsilon_{\\max} = \\max_{0 \\le n \\le N_{\\text{steps}}} \\varepsilon_n.\n$$\n\nUse dimensionless units with $G = 1$, and express all outputs as dimensionless real numbers. Angles are not required. The gravitational force and its Jacobian with respect to positions must be computed exactly from first principles. In particular, for $i \\ne j$, let $r_{ij} = q_j - q_i$, $s_{ij} = \\|r_{ij}\\|$, and the pairwise force contribution on $i$ from $j$ be\n$$\nF_{i \\leftarrow j}(q) = m_i m_j \\frac{r_{ij}}{s_{ij}^3}.\n$$\nIts position Jacobian contribution is\n$$\n\\frac{\\partial F_{i \\leftarrow j}}{\\partial q_j} = m_i m_j \\left( \\frac{I_3}{s_{ij}^3} - \\frac{3\\, r_{ij} r_{ij}^\\top}{s_{ij}^5} \\right), \\quad\n\\frac{\\partial F_{i \\leftarrow j}}{\\partial q_i} = - m_i m_j \\left( \\frac{I_3}{s_{ij}^3} - \\frac{3\\, r_{ij} r_{ij}^\\top}{s_{ij}^5} \\right).\n$$\nAll other partial derivatives with respect to positions $q_k$ for $k \\notin \\{i,j\\}$ are zero. Assemble the full $3N \\times 3N$ Jacobian $\\partial F / \\partial q$ by summing block contributions over all pairs.\n\nConstruct the mass-inverse operator as a $3N \\times 3N$ block diagonal matrix with blocks $(1/m_i) I_3$. The ODE Jacobian for $(q,p)$ has the canonical block structure\n$$\nDf(z) = \\begin{pmatrix}\n0_{3N} & M^{-1}_{\\text{mass}} \\\\\n\\frac{\\partial F}{\\partial q}(q) & 0_{3N}\n\\end{pmatrix}.\n$$\n\nTest Suite:\nImplement the following three parameter sets. For each, evolve for the specified number of steps and compute $\\varepsilon_{\\max}$ for leapfrog and for RK4.\n\n- Case 1 (two-body circular orbit, moderate step):\n  - $N = 2$, $m = [1, 1]$,\n  - $q_1(0) = (-0.5, 0, 0)$, $q_2(0) = (0.5, 0, 0)$,\n  - Let $r = 1$ and $\\omega = \\sqrt{(m_1 + m_2)/r^3}$; set $p_1(0) = (0, m_1 \\omega r/2, 0)$, $p_2(0) = (0, -m_2 \\omega r/2, 0)$,\n  - $\\Delta t = 10^{-2}$, $N_{\\text{steps}} = 1000$.\n\n- Case 2 (two-body circular orbit, small step boundary):\n  - Same $N$, $m$, and initial $(q(0),p(0))$ as Case 1,\n  - $\\Delta t = 10^{-4}$, $N_{\\text{steps}} = 1000$.\n\n- Case 3 (three-body equilateral Lagrange solution):\n  - $N = 3$, $m = [1,1,1]$,\n  - Equilateral triangle of side length $L = 1$ in the $xy$-plane centered at the origin:\n    $q_1(0) = (-0.5, -\\sqrt{3}/6, 0)$, $q_2(0) = (0.5, -\\sqrt{3}/6, 0)$, $q_3(0) = (0, \\sqrt{3}/3, 0)$,\n  - Let $R = L/\\sqrt{3}$, $\\omega = \\sqrt{3}$, and assign momenta tangential to the circle of radius $R$ with speed $v = \\omega R = 1$ for rigid rotation:\n    $p_i(0)$ is orthogonal to $q_i(0)$ in the $xy$-plane, with magnitude $1$ and chosen to induce counterclockwise rotation,\n  - $\\Delta t = 2 \\times 10^{-2}$, $N_{\\text{steps}} = 500$.\n\nOutput Specification:\nFor each case, output the pair $[\\varepsilon_{\\max}^{\\text{LF}}, \\varepsilon_{\\max}^{\\text{RK4}}]$ as real numbers. Aggregate the three case results into a single line of output containing a comma-separated list enclosed in square brackets, with no spaces, and with each case represented by its own bracketed pair. For example, the output must look like\n$$\n[[e_{1,\\text{LF}},e_{1,\\text{RK4}}],[e_{2,\\text{LF}},e_{2,\\text{RK4}}],[e_{3,\\text{LF}},e_{3,\\text{RK4}}]].\n$$\nAll results are dimensionless real numbers. No external input or files are permitted; the program must run as-is and produce the single required output line.",
            "solution": "This problem requires a direct numerical verification of the symplecticity of the leapfrog and RK4 integrators. An integrator's one-step map is symplectic if its Jacobian, $J$, preserves the canonical symplectic form matrix, $M$, such that $J^\\top M J = M$. The program will compute the cumulative Jacobian (the monodromy matrix) over many steps and measure the Frobenius norm of the deviation from this condition, $\\| J_n^\\top M J_n - M \\|_F$.\n\nThe core of the implementation is computing the exact per-step Jacobian for each integrator.\n\n1.  **Leapfrog Integrator**: The leapfrog method is a composition of three simpler maps: a half-step 'kick' due to potential energy, a full-step 'drift' due to kinetic energy, and another half-step kick. Since it is constructed from exact Hamiltonian flows, it is exactly symplectic. Its per-step Jacobian is the matrix product of the Jacobians of these three sub-steps:\n    $$ J_{\\text{step}} = J_{\\text{kick}}(q_{n+1}) \\cdot J_{\\text{drift}} \\cdot J_{\\text{kick}}(q_{n}) $$\n    where each sub-Jacobian is a block matrix constructed from identity matrices, the inverse mass matrix, and the Jacobian of the gravitational force field, $\\frac{\\partial F}{\\partial q}$, evaluated at the appropriate positions. Because the method is symplectic, the computed violation of the condition should only be due to floating-point round-off error and remain close to machine precision.\n\n2.  **RK4 Integrator**: The classical fourth-order Runge-Kutta method is not symplectic. Its per-step Jacobian is found by applying the chain rule to the complex, multi-stage formula that defines an RK4 step. This involves differentiating through each of the four stages ($k_1, k_2, k_3, k_4$), requiring the Jacobian of the underlying ODE system, $Df(z)$, to be evaluated at four different intermediate points in phase space for each time step. The resulting expression for $J_{\\text{step}}$ is significantly more complex than for leapfrog. Because the method is not symplectic, the violation metric is expected to grow over time, accumulating with each step.\n\nThe provided code implements this procedure. A `NBodySystem` class handles the calculation of the gravitational force and its Jacobian. The `run_simulation` function iteratively updates the system's state ($q, p$) and its cumulative monodromy matrix ($J$). In each step, it calculates the per-step Jacobian for the selected integrator, updates the cumulative monodromy, and computes the symplecticity violation. The maximum violation observed during the simulation is reported. The results will demonstrate that the violation for leapfrog remains small and bounded (near machine precision), while for RK4 it grows steadily, confirming their respective geometric properties.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares the symplecticity violation of Leapfrog and RK4\n    integrators for the N-body problem by tracking the monodromy matrix.\n    \"\"\"\n\n    class NBodySystem:\n        \"\"\"\n        Represents the physical N-body system and its core mathematical properties.\n        \"\"\"\n        def __init__(self, masses):\n            self.masses = np.array(masses, dtype=float)\n            self.N = len(self.masses)\n            self.dim = 3 * self.N\n            \n            inv_masses = 1.0 / self.masses\n            self.Minv_mass = np.kron(np.diag(inv_masses), np.identity(3))\n\n        def get_force_and_jacobian(self, q_flat):\n            \"\"\"\n            Computes the total gravitational force on each particle and the\n            Jacobian of the force field dF/dq.\n            \"\"\"\n            q = q_flat.reshape(self.N, 3)\n            F_flat = np.zeros(self.dim)\n            dFdq = np.zeros((self.dim, self.dim))\n\n            for i in range(self.N):\n                for j in range(i + 1, self.N):\n                    r_ij = q[j] - q[i]\n                    s_ij_sq = np.dot(r_ij, r_ij)\n                    \n                    if s_ij_sq == 0:\n                        raise ValueError(\"Collision detected, force is undefined.\")\n                    s_ij = np.sqrt(s_ij_sq)\n\n                    force_vec = (self.masses[i] * self.masses[j] / (s_ij**3)) * r_ij\n                    F_flat[3*i : 3*i+3] += force_vec\n                    F_flat[3*j : 3*j+3] -= force_vec\n\n                    s_ij_3 = s_ij**3\n                    s_ij_5 = s_ij_3 * s_ij_sq\n                    outer_r_ij = np.outer(r_ij, r_ij)\n                    \n                    jac_block = self.masses[i] * self.masses[j] * (np.identity(3) / s_ij_3 - 3 * outer_r_ij / s_ij_5)\n                    \n                    idx_i_start, idx_i_end = 3*i, 3*i+3\n                    idx_j_start, idx_j_end = 3*j, 3*j+3\n                    \n                    dFdq[idx_i_start:idx_i_end, idx_j_start:idx_j_end] = jac_block\n                    dFdq[idx_j_start:idx_j_end, idx_i_start:idx_i_end] = jac_block\n                    dFdq[idx_i_start:idx_i_end, idx_i_start:idx_i_end] -= jac_block\n                    dFdq[idx_j_start:idx_j_end, idx_j_start:idx_j_end] -= jac_block\n            \n            return F_flat, dFdq\n\n        def get_ode_f(self, z):\n            \"\"\"Computes the vector field f(z) = (q_dot, p_dot).\"\"\"\n            q = z[:self.dim]\n            p = z[self.dim:]\n            q_dot = self.Minv_mass @ p\n            p_dot, _ = self.get_force_and_jacobian(q)\n            return np.concatenate((q_dot, p_dot))\n\n        def get_ode_jacobian(self, z):\n            \"\"\"Computes the Jacobian Df(z) of the vector field.\"\"\"\n            q = z[:self.dim]\n            Df = np.zeros((2 * self.dim, 2 * self.dim))\n            _, dFdq = self.get_force_and_jacobian(q)\n            Df[:self.dim, self.dim:] = self.Minv_mass\n            Df[self.dim:, :self.dim] = dFdq\n            return Df\n\n    def run_simulation(system, integrator_type, q0, p0, dt, n_steps):\n        \"\"\"\n        Runs the simulation for a given integrator and computes max symplecticity violation.\n        \"\"\"\n        dim = system.dim\n        z = np.concatenate((q0.flatten(), p0.flatten()))\n\n        J_cumulative = np.identity(2 * dim)\n        M_symplectic = np.block([\n            [np.zeros((dim, dim)), np.identity(dim)],\n            [-np.identity(dim), np.zeros((dim, dim))]\n        ])\n        \n        eps_max = 0.0\n\n        for _ in range(n_steps):\n            I_dim = np.identity(dim)\n            I_2dim = np.identity(2 * dim)\n            \n            if integrator_type == 'leapfrog':\n                q_old = z[:dim]\n                p_old = z[dim:]\n                \n                F_old, dFdq_old = system.get_force_and_jacobian(q_old)\n                \n                p_half = p_old + (dt / 2.0) * F_old\n                q_new = q_old + dt * (system.Minv_mass @ p_half)\n                \n                F_new, dFdq_new = system.get_force_and_jacobian(q_new)\n                \n                p_new = p_half + (dt / 2.0) * F_new\n                z = np.concatenate((q_new, p_new))\n\n                J_kick_n = np.block([[I_dim, np.zeros((dim,dim))], [(dt/2.0)*dFdq_old, I_dim]])\n                J_drift = np.block([[I_dim, dt*system.Minv_mass], [np.zeros((dim,dim)), I_dim]])\n                J_kick_n1 = np.block([[I_dim, np.zeros((dim,dim))], [(dt/2.0)*dFdq_new, I_dim]])\n                \n                J_step = J_kick_n1 @ J_drift @ J_kick_n\n\n            elif integrator_type == 'rk4':\n                k1 = dt * system.get_ode_f(z)\n                k2 = dt * system.get_ode_f(z + k1 / 2.0)\n                k3 = dt * system.get_ode_f(z + k2 / 2.0)\n                k4 = dt * system.get_ode_f(z + k3)\n                z_new = z + (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n                \n                A1 = system.get_ode_jacobian(z)\n                J1 = dt * A1\n                A2 = system.get_ode_jacobian(z + k1 / 2.0)\n                J2 = dt * A2 @ (I_2dim + 0.5 * J1)\n                A3 = system.get_ode_jacobian(z + k2 / 2.0)\n                J3 = dt * A3 @ (I_2dim + 0.5 * J2)\n                A4 = system.get_ode_jacobian(z + k3)\n                J4 = dt * A4 @ (I_2dim + J3)\n                \n                J_step = I_2dim + (J1 + 2 * J2 + 2 * J3 + J4) / 6.0\n                z = z_new\n\n            else:\n                raise ValueError(\"Unknown integrator type\")\n\n            J_cumulative = J_step @ J_cumulative\n            violation_matrix = J_cumulative.T @ M_symplectic @ J_cumulative - M_symplectic\n            eps_n = np.linalg.norm(violation_matrix, 'fro')\n            if eps_n > eps_max:\n                eps_max = eps_n\n\n        return eps_max\n\n    # --- Test Cases ---\n    \n    # Cases 1  2\n    m1_val, m2_val = 1.0, 1.0\n    r_val = 1.0\n    omega_val = np.sqrt((m1_val + m2_val) / r_val**3) # G=1\n    \n    q0_case1 = np.array([[-0.5, 0, 0], [0.5, 0, 0]])\n    p0_case1 = np.array([\n        [0, m1_val * omega_val * r_val / 2.0, 0],\n        [0, -m2_val * omega_val * r_val / 2.0, 0]\n    ])\n    \n    # Case 3\n    q0_case3 = np.array([\n        [-0.5, -np.sqrt(3.0)/6.0, 0],\n        [0.5, -np.sqrt(3.0)/6.0, 0],\n        [0, np.sqrt(3.0)/3.0, 0]\n    ])\n    p0_case3 = np.zeros_like(q0_case3)\n    omega_c3 = np.sqrt(3.0)\n    for i in range(3):\n        r_vec = q0_case3[i]\n        v_vec = np.cross(np.array([0,0,omega_c3]), r_vec)\n        p0_case3[i,:] = 1.0 * v_vec # masses are 1.0\n\n    test_cases = [\n        {'m': [m1_val, m2_val], 'q0': q0_case1, 'p0': p0_case1, 'dt': 1e-2, 'n_steps': 1000},\n        {'m': [m1_val, m2_val], 'q0': q0_case1, 'p0': p0_case1, 'dt': 1e-4, 'n_steps': 1000},\n        {'m': [1.0, 1.0, 1.0], 'q0': q0_case3, 'p0': p0_case3, 'dt': 2e-2, 'n_steps': 500}\n    ]\n\n    results = []\n    for params in test_cases:\n        system = NBodySystem(params['m'])\n        \n        eps_lf = run_simulation(system, 'leapfrog', params['q0'], params['p0'], params['dt'], params['n_steps'])\n        eps_rk4 = run_simulation(system, 'rk4', params['q0'], params['p0'], params['dt'], params['n_steps'])\n        \n        results.append((eps_lf, eps_rk4))\n\n    case_strings = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```"
        }
    ]
}