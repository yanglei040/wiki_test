{
    "hands_on_practices": [
        {
            "introduction": "The choice of a flux limiter function is a critical modeling decision in Flux-Limited Diffusion (FLD) that extends beyond satisfying the diffusive and free-streaming asymptotic limits. This practice guides you to investigate the practical consequences of this choice by comparing the classic Levermore-Pomraning limiter with a modified form. By measuring the numerical broadening of a sharp front, you will gain hands-on experience in quantifying limiter-induced numerical diffusion and understanding common artifacts like staircasing. ",
            "id": "3511263",
            "problem": "Consider one-dimensional grey radiation transport in the diffusion approximation closed by a flux-limited diffusion (FLD) relation in a static, homogeneous medium. Let $x \\in [0,1]$ be the dimensionless spatial coordinate and $t \\ge 0$ the dimensionless time. The unknown is the dimensionless radiation energy density $E(x,t) \\ge 0$. The fundamental base consists of: (i) conservation of radiation energy in the diffusion approximation, which yields a parabolic conservation law, and (ii) a constitutive relation for the radiation flux with a flux limiter. Specifically, assume the following:\n\n- The conservation law is\n$$\n\\frac{\\partial E}{\\partial t} = \\frac{\\partial}{\\partial x}\\left( D(E,\\partial_x E)\\, \\frac{\\partial E}{\\partial x} \\right),\n$$\nwith a diffusion coefficient $D$ that depends on $E$ and its gradient through a flux limiter.\n\n- The constitutive relation defining the flux-limited diffusion coefficient is\n$$\nD(E,\\partial_x E) = \\lambda(R),\n\\quad\nR = \\frac{|\\partial_x E|}{\\max(E,\\epsilon)},\n$$\nwhere $\\epsilon > 0$ is a small regularization constant to prevent division by zero. The flux limiter $\\lambda(R)$ must satisfy the diffusion-limit constraint $\\lambda(R) \\to 1/3$ as $R \\to 0$ and the free-streaming constraint $\\lambda(R) \\to 1/R$ as $R \\to \\infty$.\n\n- Two choices of limiter will be compared:\n  1. The Levermore–Pomraning limiter\n  $$\n  \\lambda_{\\mathrm{LP}}(R) = \\frac{1}{R}\\left(\\coth R - \\frac{1}{R}\\right),\n  $$\n  where $\\coth R = \\frac{\\cosh R}{\\sinh R}$ and, for numerical robustness, the small-$R$ limit expansion may be used,\n  $$\n  \\lambda_{\\mathrm{LP}}(R) \\approx \\frac{1}{3} - \\frac{R^2}{45} \\quad \\text{as } R \\to 0.\n  $$\n  2. A proposed modified limiter designed to reduce staircasing while preserving asymptotic limits,\n  $$\n  \\lambda^\\ast(R) = \\frac{1}{\\sqrt{9 + R^2}},\n  $$\n  which satisfies $\\lambda^\\ast(0)=1/3$ and $\\lambda^\\ast(R) \\sim 1/R$ as $R \\to \\infty$.\n\nThe task is to examine numerical diffusion introduced by limiter-induced nonlinearity by measuring front thickness versus grid resolution $N$ for both $\\lambda_{\\mathrm{LP}}(R)$ and $\\lambda^\\ast(R)$. Implement a conservative, explicit finite-volume scheme on a uniform grid of $N$ cells with zero-flux boundary conditions. Let the cell-centered unknown be $E_i(t)$ for $i=0,\\dots,N-1$ and grid spacing $\\Delta x = 1/N$. Approximate the face-centered fluxes using a two-point gradient and a face-centered diffusion coefficient defined from the limiter evaluated at the face. For stability, choose a time step $\\Delta t$ that satisfies a standard diffusion restriction based on the maximum possible diffusion coefficient. Use a constant final time $t_{\\mathrm{final}}$ and integrate from the initial condition specified below.\n\nInitial condition and parameters:\n- Initial data is a Riemann-type front:\n$$\nE(x,0) = \\begin{cases}\nE_{\\mathrm{L}}, & x < 1/2, \\\\\nE_{\\mathrm{R}}, & x \\ge 1/2,\n\\end{cases}\n$$\nwith $E_{\\mathrm{L}} = 1$ and $E_{\\mathrm{R}} = 10^{-3}$.\n- Boundary conditions are zero-flux (homogeneous Neumann) at $x=0$ and $x=1$.\n- Use $t_{\\mathrm{final}} = 2 \\times 10^{-2}$ and $\\epsilon = 10^{-12}$.\n\nDefine the front thickness $w$ at a given time as the spatial distance between the two points where $E$ attains the threshold values\n$$\nE_{0.1} = E_{\\mathrm{R}} + 0.1\\,(E_{\\mathrm{L}} - E_{\\mathrm{R}}), \\quad\nE_{0.9} = E_{\\mathrm{R}} + 0.9\\,(E_{\\mathrm{L}} - E_{\\mathrm{R}}),\n$$\nusing linear interpolation between adjacent cell centers to locate the positions $x_{0.1}$ and $x_{0.9}$ where $E(x_{0.1},t_{\\mathrm{final}}) = E_{0.1}$ and $E(x_{0.9},t_{\\mathrm{final}}) = E_{0.9}$. Then $w = |x_{0.9} - x_{0.1}|$.\n\nYour program must:\n- Implement the explicit finite-volume update\n$$\nE_i^{n+1} = E_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right),\n$$\nwith numerical fluxes\n$$\nF_{i+\\frac{1}{2}}^n = - D_{i+\\frac{1}{2}}^n \\left(\\frac{E_{i+1}^n - E_i^n}{\\Delta x}\\right),\n\\quad\nD_{i+\\frac{1}{2}}^n = \\lambda\\!\\left(R_{i+\\frac{1}{2}}^n\\right),\n\\quad\nR_{i+\\frac{1}{2}}^n = \\frac{\\left|E_{i+1}^n - E_i^n\\right|/\\Delta x}{\\max\\!\\big(\\tfrac{1}{2}(E_{i+1}^n + E_i^n),\\,\\epsilon\\big)}.\n$$\nEnforce zero-flux boundaries by setting $F_{-1/2}^n = 0$ and $F_{N-1/2}^n = 0$.\n\n- Use a time step satisfying\n$$\n\\Delta t \\le \\frac{\\Delta x^2}{2\\,D_{\\max}},\n$$\nwith $D_{\\max} = 1/3$, and apply a safety factor of $0.9$.\n\n- For each limiter choice $\\lambda \\in \\{\\lambda_{\\mathrm{LP}}, \\lambda^\\ast\\}$ and grid resolutions $N \\in \\{32, 64, 128, 256\\}$, compute the front thickness $w(N,\\lambda)$ at $t_{\\mathrm{final}}$.\n\n- For each limiter, estimate the scaling exponent $s(\\lambda)$ by fitting a line to the data $\\{\\log \\Delta x, \\log w\\}$ across the four $N$ values, where $\\Delta x = 1/N$. That is, find $s(\\lambda)$ such that\n$$\n\\log w \\approx s(\\lambda)\\, \\log \\Delta x + b(\\lambda).\n$$\n\n- For numerical robustness near $R=0$, evaluate $\\lambda_{\\mathrm{LP}}(R)$ using its small-$R$ expansion when $R < 10^{-6}$.\n\nTest suite and required output:\n- The test suite consists of the eight front-thickness computations at the specified $N$ values for both limiters and the two fitted scaling exponents.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order:\n$$\n\\big[ w(32,\\lambda_{\\mathrm{LP}}),\\, w(64,\\lambda_{\\mathrm{LP}}),\\, w(128,\\lambda_{\\mathrm{LP}}),\\, w(256,\\lambda_{\\mathrm{LP}}),\\, w(32,\\lambda^\\ast),\\, w(64,\\lambda^\\ast),\\, w(128,\\lambda^\\ast),\\, w(256,\\lambda^\\ast),\\, s(\\lambda_{\\mathrm{LP}}),\\, s(\\lambda^\\ast) \\big].\n$$\nAll quantities are dimensionless real numbers. The program must run to completion without any user input and print exactly this single line as specified.",
            "solution": "The user has provided a valid problem statement. The task is to simulate one-dimensional flux-limited radiation diffusion using an explicit finite-volume method, compare two different flux limiters, and analyze the resulting numerical diffusion.\n\n### Principles and Method\n\nThe governing equation is a nonlinear parabolic partial differential equation for the radiation energy density $E(x,t)$:\n$$\n\\frac{\\partial E}{\\partial t} = \\frac{\\partial}{\\partial x}\\left( D(E,\\partial_x E)\\, \\frac{\\partial E}{\\partial x} \\right) = \\frac{\\partial F}{\\partial x}\n$$\nwhere $F = -D \\frac{\\partial E}{\\partial x}$ is the radiation flux. The diffusion coefficient $D$ is made nonlinear through its dependence on a flux limiter, $\\lambda(R)$. This approach is a standard technique in computational astrophysics to model radiative transfer in both optically thick (diffusive) and optically thin (free-streaming) regimes.\n\nThe key parameter $R$ is the dimensionless gradient of the radiation energy density:\n$$\nR = \\frac{|\\partial_x E|}{\\max(E,\\epsilon)}\n$$\n$R$ is large in regions with sharp gradients (optically thin or front regions) and small in smooth regions (optically thick). The flux limiter $\\lambda(R)$ must satisfy two physical limits:\n1.  **Diffusion Limit ($R \\to 0$):** In optically thick media, the transport is diffusive. For grey transport, this corresponds to $\\lambda(R) \\to 1/3$.\n2.  **Free-Streaming Limit ($R \\to \\infty$):** In optically thin media, radiation streams at the speed of light (which is $c=1$ in our dimensionless units). The flux magnitude $|F|$ should not exceed $cE = E$. Since $|F| = \\lambda(R) |\\partial_x E| = \\lambda(R) R E$, this requires $\\lambda(R)R \\le 1$, which optimally becomes $\\lambda(R) \\to 1/R$ as $R \\to \\infty$.\n\nThe problem compares the classic Levermore–Pomraning limiter, $\\lambda_{\\mathrm{LP}}(R)$, with a modified form, $\\lambda^\\ast(R)$, both of which satisfy these asymptotic constraints.\n\n### Numerical Implementation\n\nA conservative finite-volume method is prescribed. The computational domain $[0, 1]$ is discretized into $N$ cells of uniform width $\\Delta x = 1/N$. The cell-centered energy density in cell $i$ is denoted by $E_i$. The time evolution is governed by an explicit forward Euler scheme:\n$$\n\\frac{E_i^{n+1} - E_i^n}{\\Delta t} = \\frac{F_{i+1/2}^n - F_{i-1/2}^n}{\\Delta x}\n$$\nwhere $F_{i+1/2}$ is the numerical flux at the interface between cell $i$ and cell $i+1$.\n\nThe numerical flux is defined as:\n$$\nF_{i+1/2}^n = - D_{i+1/2}^n \\left(\\frac{E_{i+1}^n - E_i^n}{\\Delta x}\\right)\n$$\nThe interface diffusion coefficient $D_{i+1/2}^n$ is computed by evaluating the limiter $\\lambda$ using face-centered quantities:\n$$\nD_{i+1/2}^n = \\lambda\\left(R_{i+1/2}^n\\right)\n$$\nwhere\n$$\nR_{i+1/2}^n = \\frac{|E_{i+1}^n - E_i^n|/\\Delta x}{\\max\\left(\\frac{1}{2}(E_{i+1}^n + E_i^n), \\epsilon\\right)}\n$$\nThis scheme is fully defined by the problem statement, including zero-flux boundary conditions ($F_{-1/2} = F_{N-1/2} = 0$) and a stable time-step $\\Delta t$ based on the maximum possible diffusion coefficient, $D_{\\max} = 1/3$.\n\n### Analysis of Front Thickness and Scaling\n\nThe simulation is initialized with a step function (a Riemann problem) which resolves into a propagating front. A known artifact of some flux limiters, particularly $\\lambda_{\\mathrm{LP}}$, is \"staircasing,\" where sharp fronts are rendered as a series of steps. This is a form of numerical diffusion where the front width becomes tied to the grid resolution.\n\nTo quantify this, the front thickness $w$ is measured at a fixed time $t_{\\mathrm{final}}$. The thickness is defined as the distance $|x_{0.9} - x_{0.1}|$, where $x_{0.1}$ and $x_{0.9}$ are the positions where the energy density $E$ equals $E_{\\mathrm{R}} + 0.1(E_{\\mathrm{L}} - E_{\\mathrm{R}})$ and $E_{\\mathrm{R}} + 0.9(E_{\\mathrm{L}} - E_{\\mathrm{R}})$, respectively. These positions are found by linear interpolation on the final discrete solution.\n\nBy running the simulation for a sequence of grid resolutions $N$, we obtain $w$ as a function of grid spacing $\\Delta x = 1/N$. The relationship is modeled as a power law, $w \\propto (\\Delta x)^s$. The scaling exponent $s$ is determined by a linear least-squares fit to the data in logarithmic space:\n$$\n\\log w = s \\log \\Delta x + b\n$$\nThe value of $s$ indicates the degree to which the front width is grid-dependent. An ideal limiter would produce a physical front width independent of $\\Delta x$, corresponding to $s=0$. A larger $s$ implies greater numerical diffusion. The goal is to compute $s$ for both $\\lambda_{\\mathrm{LP}}$ and $\\lambda^\\ast$ and compare them.\n\nThe implementation will proceed as follows:\n1.  A main loop iterates through the specified grid resolutions $N \\in \\{32, 64, 128, 256\\}$ and the two limiter functions.\n2.  For each case, a simulation function `run_simulation` is called. It initializes the grid and state, then iterates in time until $t_{\\mathrm{final}}$, calculating fluxes and updating the state vector at each step.\n3.  After the simulation, `run_simulation` calculates the front width $w$ using an interpolation helper function.\n4.  Once all $w$ values are collected, the scaling exponents $s$ are calculated using `numpy.polyfit` on the log-transformed data.\n5.  Finally, the collected results are formatted into the required output string.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the simulation, analysis, and output.\n    It encapsulates all helper functions and constants as specified by the problem.\n    \"\"\"\n    \n    # Define constants from the problem statement\n    E_L = 1.0\n    E_R = 1e-3\n    T_FINAL = 2e-2\n    EPSILON = 1e-12\n    D_MAX = 1.0 / 3.0\n    CFL_FACTOR = 0.9\n    R_LP_THRESHOLD = 1e-6\n\n    # --- Helper Functions ---\n\n    def limiter_lp(R):\n        \"\"\"\n        Computes the Levermore-Pomraning flux limiter.\n        This is a vectorized implementation with a small-R Taylor expansion for robustness.\n        \"\"\"\n        R = np.asanyarray(R)\n        result = np.zeros_like(R, dtype=float)\n        \n        small_r_mask = R < R_LP_THRESHOLD\n        large_r_mask = ~small_r_mask\n\n        # Small R expansion: lambda(R) ~ 1/3 - R^2/45\n        r_small = R[small_r_mask]\n        result[small_r_mask] = (1.0/3.0) - (r_small**2 / 45.0)\n\n        # Full expression for larger R: lambda(R) = (1/R) * (coth(R) - 1/R)\n        r_large = R[large_r_mask]\n        with np.errstate(divide='ignore'):\n            coth_r = 1.0 / np.tanh(r_large)\n        \n        val = (1.0 / r_large) * (coth_r - 1.0 / r_large)\n        result[large_r_mask] = val\n        \n        # Explicitly handle R=0 if it appears\n        result[R == 0] = 1.0 / 3.0\n        \n        return result\n\n    def limiter_star(R):\n        \"\"\"\n        Computes the modified flux limiter lambda*.\n        This function is naturally vectorized using numpy operations.\n        \"\"\"\n        R = np.asanyarray(R)\n        return 1.0 / np.sqrt(9.0 + R**2)\n\n    def find_x_interpolated(E, x_centers, dx, E_threshold):\n        \"\"\"\n        Finds the spatial coordinate x where the energy density E equals E_threshold,\n        using linear interpolation between cell centers. E is assumed to be monotonic.\n        \"\"\"\n        # Find indices 'i' where the profile crosses the threshold E_threshold.\n        indices = np.where((E[:-1] >= E_threshold) & (E[1:] < E_threshold))[0]\n\n        if not indices.size:\n            return np.nan # Should not happen in this problem\n\n        i = indices[0]\n        \n        x_i = x_centers[i]\n        E_i = E[i]\n        E_i_plus_1 = E[i+1]\n        \n        # Linear interpolation formula: x = x_i + dx * (E_target - E_i) / (E_{i+1} - E_i)\n        x_interp = x_i + (E_threshold - E_i) * dx / (E_i_plus_1 - E_i)\n        \n        return x_interp\n\n    def run_simulation(N, limiter_func):\n        \"\"\"\n        Runs the 1D FLD simulation for a given grid size N and limiter function.\n        Returns the computed front thickness w.\n        \"\"\"\n        # 1. Grid, Initial Conditions, and Parameters\n        dx = 1.0 / N\n        x_centers = np.linspace(dx / 2.0, 1.0 - dx / 2.0, N)\n        \n        E = np.full(N, E_R)\n        mid_point_idx = int(N / 2)\n        E[:mid_point_idx] = E_L\n        \n        dt = CFL_FACTOR * (dx**2) / (2.0 * D_MAX)\n        t = 0.0\n        \n        # 2. Time Integration Loop\n        while t < T_FINAL:\n            current_dt = min(dt, T_FINAL - t)\n            \n            # 3. Compute fluxes at internal cell faces\n            dE = E[1:] - E[:-1]\n            grad_E = dE / dx\n            E_face = 0.5 * (E[1:] + E[:-1])\n            R_face = np.abs(grad_E) / np.maximum(E_face, EPSILON)\n            D_face = limiter_func(R_face)\n            F_internal = -D_face * grad_E\n            \n            # 4. Update energy density using conservative finite-volume formula\n            F_all = np.zeros(N + 1)\n            F_all[1:-1] = F_internal\n            \n            E -= (current_dt / dx) * (F_all[1:] - F_all[:-1])\n            \n            t += current_dt\n\n        # 5. Compute front thickness at t_final\n        E_01 = E_R + 0.1 * (E_L - E_R)\n        E_09 = E_R + 0.9 * (E_L - E_R)\n\n        x_01 = find_x_interpolated(E, x_centers, dx, E_01)\n        x_09 = find_x_interpolated(E, x_centers, dx, E_09)\n        \n        w = np.abs(x_09 - x_01)\n        \n        return w\n\n    # --- Main Execution Logic ---\n    \n    # Define test suite parameters\n    N_values = np.array([32, 64, 128, 256])\n    limiters = {'lp': limiter_lp, 'star': limiter_star}\n    \n    w_results = {}\n    \n    # Run simulations for each limiter and grid resolution\n    for name, func in limiters.items():\n        w_values = []\n        for N in N_values:\n            w = run_simulation(N, func)\n            w_values.append(w)\n        w_results[name] = w_values\n        \n    # Calculate scaling exponents from a log-log linear fit\n    dx_values = 1.0 / N_values\n    log_dx = np.log(dx_values)\n    \n    log_w_lp = np.log(w_results['lp'])\n    s_lp = np.polyfit(log_dx, log_w_lp, 1)[0]\n    \n    log_w_star = np.log(w_results['star'])\n    s_star = np.polyfit(log_dx, log_w_star, 1)[0]\n    \n    # Format the final output list as specified\n    final_results = w_results['lp'] + w_results['star'] + [s_lp, s_star]\n    \n    print(f\"[{','.join(f'{x:.10f}' for x in final_results)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "A robust numerical solver must preserve fundamental physical constraints, such as the non-negativity of energy and temperature. This exercise addresses this critical issue by tasking you with the derivation and implementation of a positivity-preserving flux limiter. You will develop a flux-capping method based on local energy content and characteristic wave speeds, a powerful technique for ensuring your simulation remains stable and physical, even when using aggressive time steps that violate standard Courant–Friedrichs–Lewy (CFL) conditions. ",
            "id": "3511282",
            "problem": "You are to derive and implement a one-dimensional explicit Flux-Limited Diffusion (FLD) solver for the gray radiation energy density $E$ that is guaranteed to preserve non-negativity by capping the face fluxes using local wave speeds and local cell content bounds. All quantities are nondimensional.\n\nStarting point and definitions:\n- The gray radiation energy equation under the diffusion approximation is\n$$\n\\frac{\\partial E}{\\partial t} + \\nabla \\cdot \\mathbf{F} = 0,\n$$\nwith diffusive flux\n$$\n\\mathbf{F} = - D \\nabla E,\n$$\nwhere $D$ is the diffusion coefficient. In the flux-limited diffusion closure,\n$$\nD = \\frac{c \\, \\lambda(R)}{\\chi},\n$$\nwhere $c$ is the (nondimensional) speed of light, $\\chi$ is the total transport opacity, and $\\lambda(R)$ is a flux limiter. The Rayleigh number-like ratio $R$ is\n$$\nR = \\frac{\\lvert \\nabla E \\rvert}{\\chi \\, E}.\n$$\n- Use the Levermore-Pomraning flux limiter\n$$\n\\lambda(R) = \\frac{1}{R}\\left(\\coth R - \\frac{1}{R}\\right),\n$$\nwith the limiting cases $\\lambda \\to 1/3$ as $R \\to 0$ and $\\lambda \\to 1/R$ as $R \\to \\infty$.\n- The total opacity is given by\n$$\n\\chi = \\rho \\, \\kappa_R(\\rho, T),\n$$\nwith a Rosseland mean opacity model\n$$\n\\kappa_R(\\rho, T) = \\kappa_0 \\, \\rho^{a} \\, T^{b},\n$$\nwhere $\\rho$ is the mass density and $T$ is the temperature defined by the radiation energy through gray equilibrium\n$$\nT = \\left(\\frac{E}{a_r}\\right)^{1/4},\n$$\nwith radiation constant $a_r$. You must adopt $a_r = 1$ and $c = 1$ to remain in nondimensional units.\n- Use a uniform grid with $N$ finite-volume cells, cell width $\\Delta x = L/N$, and zero-flux (Neumann) boundary conditions.\n\nSemi-discrete finite-volume update:\n- For cell index $i$, the explicit update reads\n$$\nE_i^{n+1} = E_i^{n} - \\frac{\\Delta t}{\\Delta x} \\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\nwhere $F_{i+\\frac{1}{2}}$ is the numerical flux at face $i+\\tfrac{1}{2}$ consistent with $F = -D \\nabla E$.\n\nPositivity-preserving limiter objective:\n- Design, from first principles, a face-based limiter that guarantees $E_i^{n+1} \\ge 0$ for all $i$ and $n$ without requiring $\\Delta t$ to satisfy the strict parabolic stability bound. Your limiter must:\n  1. Enforce a discrete energy-content bound that prevents a single face from removing an amount of radiation energy from its adjacent cell that would drive that cell negative within one time step.\n  2. Enforce a physically motivated speed bound using a characteristic local wave speed constructed from the diffusion coefficient and the grid scale, and capped by the free-streaming limit.\n- Your limiter must be constructed so that at each face $i+\\tfrac{1}{2}$, the magnitude of the limited flux does not exceed both:\n  - an energy-content bound proportional to the adjacent cell energies and $\\Delta x/\\Delta t$, and\n  - a speed bound proportional to a characteristic speed and an adjacent-cell energy scale.\n- Clearly state the characteristic speed that you use and how it is derived from the fundamental diffusion model and its free-streaming limit.\n\nAlgorithmic requirements:\n- Implement a $1$-dimensional explicit update with:\n  - Cell-centered $E_i$.\n  - Face-centered $D_{i+\\frac{1}{2}}$ computed from the flux-limiter $\\lambda(R)$ and the face-interpolated opacity $\\chi_{i+\\frac{1}{2}}$.\n  - Face-centered gradients computed by central differences.\n  - $R$ computed using face-centered gradients and a face-centered energy scale.\n  - Zero-flux boundaries, i.e., $F_{-\\frac{1}{2}} = 0$ and $F_{N-\\frac{1}{2}} = 0$.\n- Implement two solvers in the same program:\n  - A baseline FLD explicit solver without the positivity-preserving limiter (but with the flux-limiter $\\lambda$).\n  - The positivity-preserving limited solver that you derive.\n- Temperature must be computed from $T = (E/a_r)^{1/4}$ with $a_r = 1$. To numerically detect non-physical temperatures in the baseline solver, if any cell has $E < 0$, report the minimum temperature as the signed quartic root $T_{\\min} = -(\\lvert E_{\\min}\\rvert)^{1/4}$ so that negative values indicate a violation. All other uses of $T$ inside the numerical flux computation should regularize the calculation by replacing $E$ with $\\max(E, \\varepsilon)$ using a tiny $\\varepsilon$ to avoid division by zero, without masking the reported sign of the minimum temperature.\n\nTest suite:\n- Use three prescribed tests. In all tests, use $L = 1$, $a_r = 1$, $c = 1$, $N = 256$. Let $\\Delta x = L/N$. The time step $\\Delta t$ must be chosen as\n$$\n\\Delta t = \\beta \\, \\frac{\\Delta x^2}{2 \\, \\max D^{(0)}},\n$$\nwhere $\\max D^{(0)}$ is the maximum initial face-centered diffusion coefficient computed from the initial fields, and $\\beta$ is a prescribed factor for each test to deliberately violate the standard parabolic stability limit. For each test, integrate for a fixed number of steps $N_{\\text{steps}}$.\n\n- Test $1$ (moderately inhomogeneous opacity):\n  - $\\kappa_0 = 1$, $a = 1$, $b = -3.5$.\n  - $\\rho(x) = 1 + 0.5 \\sin(4 \\pi x)$.\n  - $E(x,0) = 1 + \\exp\\left(-\\frac{(x-0.5)^2}{0.05^2}\\right)$.\n  - $\\beta = 2$, $N_{\\text{steps}} = 50$.\n\n- Test $2$ (highly inhomogeneous opacity with sharp peaks):\n  - $\\kappa_0 = 5$, $a = 1$, $b = -3.5$.\n  - $\\rho(x) = 0.1 + 10 \\exp\\left(-\\frac{(x-0.25)^2}{0.02^2}\\right) + 30 \\exp\\left(-\\frac{(x-0.75)^2}{0.01^2}\\right)$.\n  - $E(x,0) = 0.5 + 2 \\exp\\left(-\\frac{(x-0.5)^2}{0.03^2}\\right)$.\n  - $\\beta = 5$, $N_{\\text{steps}} = 30$.\n\n- Test $3$ (near-vacuum region to probe free-streaming limit):\n  - $\\kappa_0 = 1$, $a = 1$, $b = -3.5$.\n  - $\\rho(x) = 1 + 0 \\times x$ for all $x$ except a central dip $\\rho(x) = 10^{-4}$ for $\\lvert x - 0.5 \\rvert < 0.05$.\n  - $E(x,0) = 1 + 0.8 \\tanh\\left(\\frac{0.5 - x}{0.02}\\right)$.\n  - $\\beta = 10$, $N_{\\text{steps}} = 20$.\n\nOutput requirements:\n- For each test, after completing all time steps, compute four scalars:\n  - $m_E^{\\text{lim}}$: the minimum of $E$ over all cells for the positivity-preserving limited solver.\n  - $m_E^{\\text{base}}$: the minimum of $E$ over all cells for the baseline solver.\n  - $m_T^{\\text{lim}}$: the minimum of $T$ over all cells for the limited solver.\n  - $m_T^{\\text{base}}$: the minimum of $T$ over all cells for the baseline solver, computed as described above with the signed quartic root when $E<0$ in any cell.\n- Your program should produce a single line of output containing the $12$ results for the three tests as a comma-separated list enclosed in square brackets in the order\n$$\n\\big[m_E^{\\text{lim}}(1),\\, m_E^{\\text{base}}(1),\\, m_T^{\\text{lim}}(1),\\, m_T^{\\text{base}}(1),\\, m_E^{\\text{lim}}(2),\\, m_E^{\\text{base}}(2),\\, m_T^{\\text{lim}}(2),\\, m_T^{\\text{base}}(2),\\, m_E^{\\textlim}(3),\\, m_E^{\\text{base}}(3),\\, m_T^{\\text{lim}}(3),\\, m_T^{\\text{base}}(3)\\big].\n$$\nAll outputs are dimensionless real numbers.\n\nYour tasks are:\n- Derive from the fundamental FLD model a positivity-preserving flux cap constructed from a discrete energy-content bound and a local wave-speed bound that recovers the parabolic and free-streaming characteristic speeds, and explain why it guarantees $E \\ge 0$ in the explicit update.\n- Implement both the baseline FLD solver and your positivity-preserving limited solver exactly as described and apply them to the tests above.\n- Ensure zero-flux boundary conditions and the specified nondimensional constants.",
            "solution": "The problem requires the derivation and implementation of a positivity-preserving explicit numerical scheme for the one-dimensional gray flux-limited diffusion (FLD) equation. The scheme's positivity must be guaranteed by capping face fluxes based on local energy content and a characteristic wave speed, even when the time step violates the standard parabolic stability condition.\n\nThe governing equation for the radiation energy density $E$ is given by the conservation law:\n$$\n\\frac{\\partial E}{\\partial t} + \\nabla \\cdot \\mathbf{F} = 0\n$$\nIn the flux-limited diffusion approximation, the flux $\\mathbf{F}$ is modeled as:\n$$\n\\mathbf{F} = -D \\nabla E\n$$\nwhere the diffusion coefficient $D$ is given by:\n$$\nD = \\frac{c \\, \\lambda(R)}{\\chi}\n$$\nHere, $c$ is the speed of light, $\\chi$ is the opacity, and $\\lambda(R)$ is the Levermore-Pomraning flux limiter, which depends on the dimensionless ratio $R = |\\nabla E| / (\\chi E)$.\n\nA semi-discrete finite-volume scheme on a uniform grid with cell width $\\Delta x$ gives the explicit update for the cell-averaged energy $E_i$ in cell $i$:\n$$\nE_i^{n+1} = E_i^{n} - \\frac{\\Delta t}{\\Delta x} \\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right)\n$$\nwhere $F_{i+\\frac{1}{2}}^n$ is the numerical flux at the interface between cells $i$ and $i+1$ at time step $n$. To ensure that the updated energy $E_i^{n+1}$ remains non-negative for any initial state $E_i^n \\ge 0$, we must constrain the fluxes.\n\nThe positivity condition is $E_i^{n+1} \\ge 0$, which implies:\n$$\nE_i^n \\ge \\frac{\\Delta t}{\\Delta x} \\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right)\n$$\nThe term $F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n$ represents the net outflow from cell $i$. If $E_i$ is a local maximum ($E_{i-1} < E_i > E_{i+1}$), then $F_{i+\\frac{1}{2}} > 0$ and $F_{i-\\frac{1}{2}} < 0$, leading to outflow at both faces. The total outflow from cell $i$ is $\\max(0, F_{i+\\frac{1}{2}}) - \\min(0, F_{i-\\frac{1}{2}})$. To guarantee positivity, the total energy removed from cell $i$ over $\\Delta t$ must not exceed the initial energy $E_i^n$.\nA robust, local, face-based method to ensure this is to budget half of the cell's energy content to each of its two faces. That is, the outflow from cell $i$ through face $i+\\frac{1}{2}$ should not drain more than $E_i^n/2$, and similarly for face $i-\\frac{1}{2}$.\n\nThis logic leads to the derivation of the **Energy-Content Bound** on the flux magnitude at a face. Consider the flux $F_{i+\\frac{1}{2}}$ between cells $i$ and $i+1$. The direction of flow is from higher $E$ to lower $E$. Let the \"upwind\" cell be the one with higher energy, from which the flux originates. To prevent the outflow from face $i+\\frac{1}{2}$ from causing either cell $i$ or $i+1$ to become negative, we cap its magnitude. If we budget half the content of the upwind cell to this face, the maximum allowed flux magnitude is:\n$$\n|F_{i+\\frac{1}{2}}| \\le \\frac{E_{\\text{upwind}}^n}{2} \\frac{\\Delta x}{\\Delta t}\n$$\nwhere $E_{\\text{upwind}}^n = E_i^n$ if $E_i^n > E_{i+1}^n$, and $E_{\\text{upwind}}^n = E_{i+1}^n$ if $E_{i+1}^n > E_i^n$. Let's verify this. In the worst-case scenario for cell $i$ (outflow at both faces), the total outflow is limited by:\n$$\n\\frac{\\Delta t}{\\Delta x} \\left( |F_{i+\\frac{1}{2}}| + |F_{i-\\frac{1}{2}}| \\right) \\le \\frac{\\Delta t}{\\Delta x} \\left( \\frac{E_i^n \\Delta x}{2 \\Delta t} + \\frac{E_i^n \\Delta x}{2 \\Delta t} \\right) = E_i^n\n$$\nThus, $E_i^{n+1} = E_i^n - (\\text{outflows}) + (\\text{inflows}) \\ge E_i^n - E_i^n + 0 = 0$. This guarantees positivity.\n\nNext, we derive the **Speed Bound**. The FLD model must be consistent with the physical speed limit of radiation, $c$. The flux magnitude $|F|$ cannot exceed $c E$. In the free-streaming limit ($R \\to \\infty$), the Levermore-Pomraning limiter ensures $|F| \\to cE$. Furthermore, in a numerical diffusion scheme, information propagates at a characteristic speed related to the diffusion coefficient $D$ and grid scale $\\Delta x$, which is $v_{\\text{diff}} \\sim D/\\Delta x$. An effective flux speed cannot exceed either of these. We define a characteristic local wave speed at the face:\n$$\nv_{\\text{char}, i+\\frac{1}{2}} = \\min\\left(\\frac{D_{i+\\frac{1}{2}}}{\\Delta x}, c\\right)\n$$\nThe flux magnitude is then bounded by this speed multiplied by the energy density of the upwind cell:\n$$\n|F_{i+\\frac{1}{2}}| \\le v_{\\text{char}, i+\\frac{1}{2}} E_{\\text{upwind}}^n\n$$\n\nThe final positivity-preserving limiter combines these two bounds as specified. The magnitude of the limited flux, $|F^{\\text{lim}}_{i+\\frac{1}{2}}|$, must not exceed the original unlimited flux magnitude, $|F^{\\text{unlim}}_{i+\\frac{1}{2}}|$, nor the two caps.\nLet the unlimited flux be $F^{\\text{unlim}}_{i+\\frac{1}{2}} = -D_{i+\\frac{1}{2}} \\frac{E_{i+1}^n - E_i^n}{\\Delta x}$.\nThe cap on the flux magnitude is:\n$$\nF_{\\text{cap}, i+\\frac{1}{2}} = \\min \\left( \\frac{E_{\\text{upwind}}^n \\Delta x}{2 \\Delta t}, v_{\\text{char}, i+\\frac{1}{2}} E_{\\text{upwind}}^n \\right)\n$$\nwhere $E_{\\text{upwind}}^n = \\max(E_i^n, E_{i+1}^n)$.\nThe final limited flux is constructed by capping the magnitude of the unlimited flux:\n$$\nF^{\\text{lim}}_{i+\\frac{1}{2}} = \\text{sign}\\left(F^{\\text{unlim}}_{i+\\frac{1}{2}}\\right) \\min\\left( \\left|F^{\\text{unlim}}_{i+\\frac{1}{2}}\\right|, F_{\\text{cap}, i+\\frac{1}{2}} \\right)\n$$\nThis formulation ensures that the flux is conservative and respects the physical constraints, guaranteeing $E^{n+1} \\ge 0$.\n\nThe implementation will proceed as follows. For each test case, we run two simulations: a baseline solver using the unlimited flux $F^{\\text{unlim}}$, and the limited solver using $F^{\\text{lim}}$.\nAll face-centered quantities are computed using arithmetic means of the adjacent cell-centered values. Specifically for opacity $\\chi = \\rho \\kappa_R = \\kappa_0 \\rho^{a+1} T^b$, we compute $T_i = (\\max(E_i, \\varepsilon))^{1/4}$, then average $\\rho$ and $T$ to the faces to compute $\\chi_{i+\\frac{1}{2}}$. The Rayleigh number $R$ uses a face-centered gradient and a face-centered energy scale, $E_{i+\\frac{1}{2}} = (E_i + E_{i+1})/2$. Special care is taken for the numerical evaluation of the flux limiter $\\lambda(R)$ near $R=0$, where the asymptotic limit $\\lambda(R) \\approx 1/3$ is used to avoid numerical cancellation errors. The time step $\\Delta t$ is determined from the initial state's maximum diffusion coefficient and a given factor $\\beta$, deliberately chosen to violate the CFL condition for the simple explicit parabolic scheme, thus highlighting the necessity and efficacy of the flux limiter.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a 1D explicit positivity-preserving\n    Flux-Limited Diffusion (FLD) solver.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"id\": 1,\n            \"kappa0\": 1.0, \"a\": 1.0, \"b\": -3.5,\n            \"rho_func\": lambda x: 1.0 + 0.5 * np.sin(4 * np.pi * x),\n            \"E_func\": lambda x: 1.0 + np.exp(-((x - 0.5)**2) / 0.05**2),\n            \"beta\": 2.0, \"N_steps\": 50\n        },\n        {\n            \"id\": 2,\n            \"kappa0\": 5.0, \"a\": 1.0, \"b\": -3.5,\n            \"rho_func\": lambda x: 0.1 + 10 * np.exp(-((x - 0.25)**2) / 0.02**2) + 30 * np.exp(-((x - 0.75)**2) / 0.01**2),\n            \"E_func\": lambda x: 0.5 + 2 * np.exp(-((x - 0.5)**2) / 0.03**2),\n            \"beta\": 5.0, \"N_steps\": 30\n        },\n        {\n            \"id\": 3,\n            \"kappa0\": 1.0, \"a\": 1.0, \"b\": -3.5,\n            \"rho_func\": lambda x: np.where(np.abs(x - 0.5) < 0.05, 1e-4, 1.0),\n            \"E_func\": lambda x: 1.0 + 0.8 * np.tanh((0.5 - x) / 0.02),\n            \"beta\": 10.0, \"N_steps\": 20\n        }\n    ]\n\n    all_results = []\n    \n    # Global parameters\n    L = 1.0\n    N = 256\n    ar = 1.0\n    c_light = 1.0\n    dx = L / N\n    x = (np.arange(N) + 0.5) * dx\n    EPSILON = 1e-100\n\n    def compute_lambda(R):\n        \"\"\"Computes the Levermore-Pomraning flux limiter.\"\"\"\n        R_small_tol = 1e-6\n        lambda_val = np.zeros_like(R)\n        \n        mask_small = R < R_small_tol\n        mask_large = ~mask_small\n\n        R_large = R[mask_large]\n        lambda_val[mask_large] = (1.0 / R_large) * (1.0 / np.tanh(R_large) - 1.0 / R_large)\n        \n        # Taylor expansion for small R: 1/3 - R^2/45 + ...\n        # For simplicity and as per problem, we can use the limit directly.\n        lambda_val[mask_small] = 1.0 / 3.0\n        \n        return lambda_val\n\n    def get_face_properties(E, rho, k0, a, b):\n        \"\"\"Computes all necessary face-centered quantities.\"\"\"\n        # Cell-centered temperatures, regularized for flux computation\n        T_cell = np.power(np.maximum(E, EPSILON), 0.25)\n        \n        # Arithmetic mean for face-centered quantities\n        E_face = (E[:-1] + E[1:]) / 2.0\n        rho_face = (rho[:-1] + rho[1:]) / 2.0\n        T_face = (T_cell[:-1] + T_cell[1:]) / 2.0\n\n        # Face-centered opacity and gradient\n        chi_face = k0 * np.power(rho_face, a + 1.0) * np.power(T_face, b)\n        grad_E_face = (E[1:] - E[:-1]) / dx\n\n        # Rayleigh number R\n        R_face = np.abs(grad_E_face) / (chi_face * E_face + EPSILON)\n\n        # Flux-limiter lambda and diffusion coefficient D\n        lambda_face = compute_lambda(R_face)\n        D_face = c_light * lambda_face / (chi_face + EPSILON)\n        \n        return D_face, grad_E_face\n\n    def run_simulation(E_init, rho, params, limited):\n        \"\"\"Runs a single simulation (baseline or limited).\"\"\"\n        k0, a, b = params[\"kappa0\"], params[\"a\"], params[\"b\"]\n        N_steps, beta = params[\"N_steps\"], params[\"beta\"]\n\n        # Calculate timestep dt based on initial conditions\n        D0_face, _ = get_face_properties(E_init, rho, k0, a, b)\n        max_D0 = np.max(D0_face) if D0_face.size > 0 else 1.0\n        dt = beta * dx**2 / (2.0 * max_D0)\n\n        E = E_init.copy()\n\n        for _ in range(N_steps):\n            D_face, grad_E_face = get_face_properties(E, rho, k0, a, b)\n            \n            # 1. Compute unlimited physical flux\n            F_unlimited = -D_face * grad_E_face\n            \n            F_final = F_unlimited\n            if limited:\n                # 2. Compute positivity-preserving flux caps\n                E_upwind = np.where(E[:-1] > E[1:], E[:-1], E[1:])\n                \n                # Energy content bound\n                F_cap_content = E_upwind * dx / (2.0 * dt)\n                \n                # Characteristic speed and speed bound\n                v_char = np.minimum(D_face / dx, c_light)\n                F_cap_speed = v_char * E_upwind\n                \n                # Combined cap\n                F_cap = np.minimum(F_cap_content, F_cap_speed)\n                \n                # 3. Apply the limiter\n                F_limited = np.sign(F_unlimited) * np.minimum(np.abs(F_unlimited), F_cap)\n                F_final = F_limited\n\n            # 4. Update energy using final fluxes\n            # Flux array with boundary conditions F=0 on both ends\n            F_bnd = np.zeros(N + 1)\n            F_bnd[1:-1] = F_final\n            \n            E -= (dt / dx) * (F_bnd[1:] - F_bnd[:-1])\n\n        # Post-process to find minimums\n        min_E = np.min(E)\n        if not limited and min_E < 0:\n            min_T = -np.power(np.abs(min_E), 0.25)\n        else:\n            # For the limited solver, min_E should be >= 0\n            # For the baseline, if min_E happens to be positive\n            min_T = np.power(max(min_E, 0), 0.25)\n            \n        return min_E, min_T\n\n    for case in test_cases:\n        rho_init = case[\"rho_func\"](x)\n        E_init = case[\"E_func\"](x)\n        \n        # Run baseline solver\n        m_E_base, m_T_base = run_simulation(E_init, rho_init, case, limited=False)\n        \n        # Run limited solver\n        m_E_lim, m_T_lim = run_simulation(E_init, rho_init, case, limited=True)\n        \n        all_results.extend([m_E_lim, m_E_base, m_T_lim, m_T_base])\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Applying radiative transfer methods to cosmology requires correctly accounting for the expansion of the universe. This hands-on problem challenges you to extend the FLD formalism to an expanding medium described by a Hubble-like flow. You will derive the FLD equation in comoving coordinates, implement the crucial adiabatic cooling term, and verify that your code correctly reproduces the expected $E \\propto a^{-4}$ redshifting behavior in the appropriate limit, a cornerstone of cosmological simulations. ",
            "id": "3511262",
            "problem": "Consider Flux-Limited Diffusion (FLD) for radiation in an expanding, homogeneous, isotropic medium undergoing a Hubble-like flow with physical velocity field given by $v_{\\mathrm{phys}}(\\mathbf{r},t)=H(t)\\,\\mathbf{r}$, where $H(t)$ is the Hubble parameter and $\\mathbf{r}$ is the physical position vector. Let $a(t)$ be the cosmological scale factor satisfying $\\dot{a}(t)=H(t)\\,a(t)$ with initial condition $a(0)=a_{0}$. Work in one spatial dimension with a periodic domain in the comoving coordinate $x$ such that the physical coordinate is $r(t)=a(t)\\,x$. The radiation energy density per unit physical volume is denoted by $E(x,t)$ and the radiation pressure is $P_{\\mathrm{rad}}(x,t)=E(x,t)/3$. The FLD flux is defined by $F_{\\mathrm{phys}}(x,t)=-D(x,t)\\,\\nabla_{\\mathrm{phys}}E(x,t)$, where $\\nabla_{\\mathrm{phys}}$ is the physical spatial gradient and the diffusion coefficient is $D(x,t)=\\dfrac{c\\,\\lambda(R)}{\\kappa_{R}}$, with $c$ the speed of light, $\\kappa_{R}$ the Rosseland mean opacity, and $\\lambda(R)$ a flux limiter depending on the dimensionless quantity $R=\\dfrac{\\lvert\\nabla_{\\mathrm{phys}}E\\rvert}{\\kappa_{R}\\,E}$. Use the Levermore–Pomraning flux limiter $\\lambda(R)=\\dfrac{1}{R}\\left(\\coth R-\\dfrac{1}{R}\\right)$, with the limiting behavior $\\lambda(0)=\\dfrac{1}{3}$.\n\nStarting from the radiation energy equation in the mixed frame, and using the transformation between physical and comoving derivatives, derive the form of the comoving-frame FLD equation that includes the effect of expansion. In particular, derive the modification to the diffusion operator when expressed in comoving coordinates and the adiabatic term driven by expansion. Then design a stable, explicit finite-difference algorithm that integrates the derived equation on a one-dimensional periodic comoving grid. The algorithm must ensure that the adiabatic redshifting law for radiation, $E\\propto a^{-4}$, is preserved when diffusion is absent, and it must correctly incorporate the comoving scaling of the diffusion operator.\n\nYour program must implement the following model assumptions and numerical details:\n- The comoving gradient satisfies $\\nabla_{\\mathrm{phys}}=\\dfrac{1}{a(t)}\\,\\nabla_{\\mathrm{com}}$, and the comoving divergence of the diffusion operator scales accordingly.\n- The radiation energy evolution equation in the comoving frame includes an adiabatic work term proportional to $H(t)$ and a comoving diffusion operator with appropriate scaling in $a(t)$.\n- The numerical flux at cell faces should be computed using a variable diffusion coefficient based on the local flux limiter evaluated from comoving gradients.\n- Use periodic boundary conditions in the comoving coordinate.\n- Use an operator-splitting time integrator that separately advances the adiabatic term and the diffusion term.\n- Use a Forward-Time, Centered-Space discretization for the diffusion part, with a stability-conscious time step selection.\n\nWork in centimeter–gram–second (cgs) units where applicable. However, the required outputs are dimensionless floats as specified below.\n\nTest Suite:\nImplement the following three test cases on a one-dimensional periodic comoving domain of length $L=\\;10^{5}\\,$cm discretized into $N=\\;128$ cells. Use $a_{0}=\\;1$ and $c=\\;3.0\\times 10^{10}\\,$cm/s. For all cases, initialize the comoving coordinate grid uniformly and use constant $H(t)=H_{0}$.\n\n1. Case A (Uniform field, diffusion present but no gradient): \n   - Parameters: $\\kappa_{R}=\\;10.0\\,$cm$^{-1}$, $H_{0}=\\;0.01\\,$s$^{-1}$, final time $t_{\\mathrm{end}}=\\;0.1\\,$s.\n   - Initial condition: $E(x,0)=E_{0}$ with $E_{0}=\\;1.0\\,$erg/cm$^{3}$ uniform.\n   - Required result: a single float equal to the relative error between the numerical spatial average $\\langle E(x,t_{\\mathrm{end}})\\rangle$ and the exact adiabatic value $E_{0}\\,\\exp(-4\\,H_{0}\\,t_{\\mathrm{end}})$, computed as $\\left\\lvert \\dfrac{\\langle E\\rangle_{\\mathrm{num}}-E_{0}\\,e^{-4H_{0}t_{\\mathrm{end}}}}{E_{0}\\,e^{-4H_{0}t_{\\mathrm{end}}}}\\right\\rvert$.\n\n2. Case B (Sinusoidal field, optically thick so diffusion is negligible): \n   - Parameters: $\\kappa_{R}=\\;100.0\\,$cm$^{-1}$, $H_{0}=\\;0.02\\,$s$^{-1}$, final time $t_{\\mathrm{end}}=\\;0.1\\,$s.\n   - Initial condition: $E(x,0)=E_{0}\\left[1+0.1\\,\\sin\\left(\\dfrac{2\\pi x}{L}\\right)\\right]$ with $E_{0}=\\;1.0\\,$erg/cm$^{3}$.\n   - Required result: a single float equal to the mean absolute relative error over the grid between the numerical $E(x,t_{\\mathrm{end}})$ and the exact adiabatic-only solution $E(x,0)\\,\\exp(-4\\,H_{0}\\,t_{\\mathrm{end}})$, computed as the average over all grid points of $\\left\\lvert \\dfrac{E_{\\mathrm{num}}(x_{i},t_{\\mathrm{end}})-E(x_{i},0)\\,e^{-4H_{0}t_{\\mathrm{end}}}}{E(x_{i},0)\\,e^{-4H_{0}t_{\\mathrm{end}}}}\\right\\rvert$.\n\n3. Case C (Sinusoidal field, finite diffusion and expansion; conservation of comoving invariant): \n   - Parameters: $\\kappa_{R}=\\;1.0\\,$cm$^{-1}$, $H_{0}=\\;0.01\\,$s$^{-1}$, final time $t_{\\mathrm{end}}=\\;0.2\\,$s.\n   - Initial condition: $E(x,0)=E_{0}\\left[1+0.2\\,\\sin\\left(\\dfrac{4\\pi x}{L}\\right)\\right]$ with $E_{0}=\\;1.0\\,$erg/cm$^{3}$.\n   - Required result: a single float equal to the relative deviation of the spatial average of the comoving invariant $a(t)^{4}E(x,t)$ between initial and final times, computed as $\\left\\lvert \\dfrac{\\langle a(t_{\\mathrm{end}})^{4}E(x,t_{\\mathrm{end}})\\rangle-\\langle a(0)^{4}E(x,0)\\rangle}{\\langle a(0)^{4}E(x,0)\\rangle}\\right\\rvert$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for the three cases as a comma-separated list enclosed in square brackets (e.g., $\\left[\\mathrm{resultA},\\mathrm{resultB},\\mathrm{resultC}\\right]$). Each entry must be a floating-point number as defined above, with no units.",
            "solution": "The problem is well-posed, scientifically grounded, and provides sufficient information for a unique solution. It is a standard problem in computational astrophysics, and I will proceed with the derivation and implementation.\n\n### Part 1: Derivation of the Comoving Frame Flux-Limited Diffusion Equation\n\nWe begin with the radiation energy conservation equation in the mixed frame, where fluid variables are measured in the comoving frame of the fluid, but derivatives are taken in the laboratory (Eulerian) frame. For a fluid moving with physical velocity $\\mathbf{v}_{\\mathrm{phys}}$, this equation is:\n$$\n\\frac{\\partial E}{\\partial t} + \\nabla_{\\mathrm{phys}} \\cdot (E \\mathbf{v}_{\\mathrm{phys}}) + \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}} = -P_{\\mathrm{rad}} : \\nabla_{\\mathrm{phys}} \\mathbf{v}_{\\mathrm{phys}}\n$$\nwhere $E$ is the radiation energy density, $\\mathbf{F}_{\\mathrm{phys}}$ is the radiation flux, and $P_{\\mathrm{rad}}$ is the radiation pressure tensor. For an isotropic radiation field, the pressure is a scalar $P_{\\mathrm{rad}} = E/3$, and the pressure tensor is $P_{ij} = P_{\\mathrm{rad}} \\delta_{ij}$. The work term on the right-hand side simplifies to $-P_{\\mathrm{rad}} (\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}})$.\n\nExpanding the advection term $\\nabla_{\\mathrm{phys}} \\cdot (E \\mathbf{v}_{\\mathrm{phys}}) = \\mathbf{v}_{\\mathrm{phys}} \\cdot \\nabla_{\\mathrm{phys}} E + E (\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}})$, the equation becomes:\n$$\n\\frac{\\partial E}{\\partial t} + \\mathbf{v}_{\\mathrm{phys}} \\cdot \\nabla_{\\mathrm{phys}} E + E (\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}}) + \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}} = -P_{\\mathrm{rad}} (\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}})\n$$\nRecognizing the Lagrangian time derivative $\\frac{DE}{Dt} = \\frac{\\partial E}{\\partial t} + \\mathbf{v}_{\\mathrm{phys}} \\cdot \\nabla_{\\mathrm{phys}} E$, we can rearrange the equation to:\n$$\n\\frac{DE}{Dt} = -(E + P_{\\mathrm{rad}})(\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}}) - \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}}\n$$\nThe problem specifies a homogeneous, isotropic Hubble-like flow, $\\mathbf{v}_{\\mathrm{phys}} = H(t) \\mathbf{r}$, where $\\mathbf{r}$ is the physical position vector. The divergence of this velocity field is $\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}} = 3H(t)$, representing the volumetric expansion rate of the background 3D space. Using the relativistic equation of state $P_{\\mathrm{rad}} = E/3$, we have $E + P_{\\mathrm{rad}} = 4E/3$. The equation becomes:\n$$\n\\frac{DE}{Dt} = -\\frac{4}{3}E (3H(t)) - \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}} = -4H(t)E - \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}}\n$$\nThis equation describes the change in energy density for a fluid element moving with the cosmic expansion.\n\nNext, we transform to comoving coordinates. The physical coordinate $\\mathbf{r}$ is related to the comoving coordinate $\\mathbf{x}$ by the scale factor $a(t)$: $\\mathbf{r} = a(t) \\mathbf{x}$. The velocity of a point with fixed comoving coordinate is $\\dot{\\mathbf{r}} = \\dot{a}(t) \\mathbf{x} = \\frac{\\dot{a}}{a} (a \\mathbf{x}) = H(t) \\mathbf{r} = \\mathbf{v}_{\\mathrm{phys}}$. This means the Lagrangian derivative following the fluid is identical to the partial time derivative at a fixed comoving coordinate: $\\frac{D}{Dt} = \\left. \\frac{\\partial}{\\partial t} \\right|_{\\mathbf{x}}$.\n\nThe equation in terms of the comoving-frame time derivative is:\n$$\n\\left. \\frac{\\partial E}{\\partial t} \\right|_{\\mathbf{x}} = -4H(t)E - \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}}\n$$\nThe first term on the right, $-4H(t)E$, is the **adiabatic cooling term** (or redshifting term) resulting from the work done by radiation pressure as the universe expands. This term correctly leads to the $E \\propto a^{-4}$ scaling in the absence of sources or sinks, as $\\frac{dE}{E} = -4H dt = -4 \\frac{da}{a}$, which integrates to $E a^4 = \\mathrm{constant}$.\n\nNow, we transform the diffusion term. The physical flux is given by the FLD approximation: $\\mathbf{F}_{\\mathrm{phys}} = -D \\nabla_{\\mathrm{phys}} E$. The physical gradient $\\nabla_{\\mathrm{phys}}$ relates to the comoving gradient $\\nabla_{\\mathrm{com}}$ as $\\nabla_{\\mathrm{phys}} = \\frac{1}{a(t)}\\nabla_{\\mathrm{com}}$. The divergence of the flux becomes:\n$$\n\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}} = \\nabla_{\\mathrm{phys}} \\cdot \\left(-D \\nabla_{\\mathrm{phys}} E\\right) = \\frac{1}{a(t)} \\nabla_{\\mathrm{com}} \\cdot \\left(-D \\frac{1}{a(t)} \\nabla_{\\mathrm{com}} E\\right) = -\\frac{1}{a(t)^2} \\nabla_{\\mathrm{com}} \\cdot \\left(D \\nabla_{\\mathrm{com}} E\\right)\n$$\nSubstituting this into the energy equation, we obtain the final one-dimensional FLD equation in comoving coordinates:\n$$\n\\frac{\\partial E}{\\partial t} = -4H(t)E + \\frac{1}{a(t)^2} \\frac{\\partial}{\\partial x} \\left( D \\frac{\\partial E}{\\partial x} \\right)\n$$\nThis is the desired equation. The diffusion coefficient $D = \\frac{c \\lambda(R)}{\\kappa_R}$ depends on the dimensionless quantity $R = \\frac{|\\nabla_{\\mathrm{phys}} E|}{\\kappa_R E} = \\frac{1}{a(t) \\kappa_R E} \\left|\\frac{\\partial E}{\\partial x}\\right|$.\n\n### Part 2: Numerical Algorithm Design\n\nWe will implement a stable, explicit finite-difference scheme using operator splitting to solve the derived PDE.\n\n**1. Operator Splitting**\nThe evolution equation $\\frac{\\partial E}{\\partial t} = \\mathcal{L}_{\\mathrm{ad}}E + \\mathcal{L}_{\\mathrm{diff}}E$ is split into two sub-steps for each time increment $\\Delta t$.\n1.  **Adiabatic Step:** Solve $\\frac{\\partial E}{\\partial t} = -4H(t)E$. For a constant Hubble parameter $H(t)=H_0$, this has the exact solution:\n    $$ E^* = E^n e^{-4H_0 \\Delta t} $$\n    where $E^n$ is the energy density at the beginning of the time step.\n\n2.  **Diffusion Step:** Solve $\\frac{\\partial E}{\\partial t} = \\frac{1}{a(t)^2} \\frac{\\partial}{\\partial x} \\left( D \\frac{\\partial E}{\\partial x} \\right)$ using a Forward-Time, Centered-Space (FTCS) scheme, with $E^*$ as the initial condition.\n    $$ \\frac{E_i^{n+1} - E_i^*}{\\Delta t} = \\frac{1}{a(t^n)^2} \\left[ \\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x} \\right] $$\n    where $\\Delta x$ is the comoving grid spacing, and $F_{i+1/2}$ is the numerical flux at the interface between cells $i$ and $i+1$.\n\n**2. Spatial Discretization and Flux Calculation**\nThe grid consists of $N$ cells of size $\\Delta x = L/N$. The numerical flux at the cell face $x_{i+1/2}$ is:\n$$\nF_{i+1/2} = -D_{i+1/2} \\left( \\frac{E_{i+1}^* - E_i^*}{\\Delta x} \\right)\n$$\nThe diffusion coefficient $D_{i+1/2}$ is evaluated at the cell face. This requires evaluating the limiter $\\lambda(R)$ at the face, which in turn depends on the face-centered gradient and energy density.\n$$\nE_{i+1/2}^* = \\frac{E_{i+1}^* + E_i^*}{2}\n$$\n$$\nR_{i+1/2} = \\frac{1}{a(t^n) \\kappa_R E_{i+1/2}^*} \\left| \\frac{E_{i+1}^* - E_i^*}{\\Delta x} \\right|\n$$\nThe Levermore–Pomraning flux limiter is $\\lambda(R) = \\frac{1}{R}(\\coth R - \\frac{1}{R})$. To avoid numerical cancellation for small $R$, we use its Taylor expansion $\\lambda(R) \\approx 1/3 - R^2/45$ for $R < 10^{-4}$.\nFinally, the face-centered diffusion coefficient is $D_{i+1/2} = \\frac{c \\lambda(R_{i+1/2})}{\\kappa_R}$.\nThe diffusion update for cell $i$ is:\n$$\nE_i^{n+1} = E_i^* + \\frac{\\Delta t}{a(t^n)^2 (\\Delta x)^2} \\left[ D_{i+1/2}(E_{i+1}^* - E_i^*) - D_{i-1/2}(E_i^* - E_{i-1}^*) \\right]\n$$\nPeriodic boundary conditions are handled by ensuring that indices wrap around, e.g., $E_N = E_0$ and $E_{-1} = E_{N-1}$.\n\n**3. Time Step Stability**\nThe explicit FTCS scheme for a diffusion equation is stable provided the time step $\\Delta t$ satisfies the CFL condition. The effective diffusivity in our equation is $D_{\\text{eff}} = D/a^2$. The stability condition is:\n$$\n\\Delta t \\le \\frac{(\\Delta x)^2}{2 \\max(D_{\\text{eff}})} = \\frac{a(t)^2 (\\Delta x)^2}{2 \\max(D)}\n$$\nThe maximum value of the diffusion coefficient occurs when $R \\to 0$, where $\\lambda(0) = 1/3$, so $D_{\\max} = \\frac{c}{3\\kappa_R}$. The stable time step is:\n$$\n\\Delta t_{\\mathrm{diff}} = \\eta \\frac{3 \\kappa_R a(t)^2 (\\Delta x)^2}{2c}\n$$\nwhere $\\eta \\le 1$ is a safety factor (we use $\\eta=0.5$). The overall time step is also constrained to be a small fraction of the expansion timescale $1/H_0$ and not to overshoot the final time $t_{\\mathrm{end}}$.\n\n**4. Conservation**\nThe spatially integrated quantity $\\int_0^L a(t)^4 E(x,t) \\, dx$ is conserved. Differentiating with respect to time yields $\\int_0^L a^2 \\frac{\\partial}{\\partial x} (D \\frac{\\partial E}{\\partial x}) \\, dx$. Due to periodic boundary conditions, this integral is zero, confirming conservation. Our finite-difference scheme, being a direct discretization of the divergence of a flux, will numerically conserve this quantity up to machine precision. This is tested in Case C.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the flux-limited diffusion problem in an expanding medium\n    for three test cases and prints the results.\n    \"\"\"\n\n    def lambda_lp(R, R_thresh=1e-4):\n        \"\"\"\n        Computes sweatshirts Levermore-Pomraning flux limiter.\n        Uses a Taylor expansion for small R to avoid numerical instability.\n        \"\"\"\n        # Ensure R is a numpy array\n        R = np.asanyarray(R)\n        \n        # Initialize result array\n        lambda_val = np.zeros_like(R, dtype=float)\n        \n        # Condition for small R\n        small_R_mask = R < R_thresh\n        \n        # Taylor expansion for small R\n        R_small = R[small_R_mask]\n        lambda_val[small_R_mask] = 1.0 / 3.0 - R_small**2 / 45.0\n        \n        # Full expression for large R\n        R_large = R[~small_R_mask]\n        # Use 1/tanh(R) to avoid overflow issues of coth at R=0\n        # which is already guarded by the mask.\n        lambda_val[~small_R_mask] = (1.0 / np.tanh(R_large) - 1.0 / R_large) / R_large\n        \n        return lambda_val\n\n    def run_simulation(params):\n        \"\"\"\n        Runs a single 1D FLD simulation.\n        \n        Args:\n            params (dict): A dictionary containing all model and simulation parameters.\n            \n        Returns:\n            tuple: Final energy density array E, initial energy E0, scale factor a(t_end).\n        \"\"\"\n        # Unpack parameters\n        L = params['L']\n        N = params['N']\n        k_R = params['k_R']\n        H0 = params['H0']\n        t_end = params['t_end']\n        E_initial_func = params['E_initial_func']\n        a0 = params['a0']\n        c = params['c']\n        \n        # Grid setup\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        \n        # Initial conditions\n        E = E_initial_func(x, L) \n        E_initial = E.copy()\n        \n        t = 0.0\n        a = a0\n        \n        # CFL safety factor\n        cfl_safety_factor = 0.5\n        \n        while t < t_end:\n            # Update scale factor for the start of the step\n            a = a0 * np.exp(H0 * t)\n            \n            # Time step calculation\n            # Diffusion timestep constraint\n            dt_diff = cfl_safety_factor * (3.0 * k_R * a**2 * dx**2) / (2.0 * c)\n            # Expansion timestep constraint\n            dt_exp = 0.01 / H0 if H0 > 0 else t_end\n            \n            dt = min(dt_diff, dt_exp)\n            if t + dt > t_end:\n                dt = t_end - t\n            \n            # --- Operator Splitting ---\n\n            # 1. Adiabatic step (analytically solved)\n            if H0 > 0:\n                E_star = E * np.exp(-4.0 * H0 * dt)\n            else:\n                E_star = E.copy()\n\n            # 2. Diffusion step (FTCS)\n            # Calculate face-centered diffusion coefficients\n            E_plus = np.roll(E_star, -1)\n            E_minus = np.roll(E_star, 1)\n\n            # Face-centered energy and gradient\n            E_face = 0.5 * (E_star + E_plus)\n            # Add a small number to prevent division by zero for uniform fields\n            E_face[E_face == 0] = 1e-99\n            \n            grad_com_E_face = (E_plus - E_star) / dx\n\n            # Dimensionless parameter R at faces\n            R_face = np.abs(grad_com_E_face) / (a * k_R * E_face)\n            \n            # Limiter and diffusion coefficient at forward faces (i+1/2)\n            lambda_face_fwd = lambda_lp(R_face)\n            D_face_fwd = c * lambda_face_fwd / k_R\n            \n            # Diffusion coefficient at backward faces (i-1/2) by rolling\n            D_face_bwd = np.roll(D_face_fwd, 1)\n\n            # Update energy density using flux divergence\n            # We use the direct finite difference form for clarity\n            # d/dx (D dE/dx) -> (D_fwd * (E_plus - E_star) - D_bwd * (E_star - E_minus)) / dx^2\n            diffusion_term = (D_face_fwd * (E_plus - E_star) - D_face_bwd * (E_star - E_minus)) / dx**2\n            \n            E = E_star + (dt / a**2) * diffusion_term\n            \n            # Advance time\n            t += dt\n\n        a_final = a0 * np.exp(H0 * t_end)\n        return E, E_initial, a_final\n\n    # --- Global and Test Case Parameters ---\n    L_domain = 1.0e5   # cm\n    N_cells = 128\n    a0_val = 1.0\n    c_light = 3.0e10   # cm/s\n    E0_val = 1.0       # erg/cm^3\n\n    test_cases = [\n        { # Case A\n            'k_R': 10.0, 'H0': 0.01, 't_end': 0.1,\n            'E_initial_func': lambda x, L: np.full_like(x, E0_val)\n        },\n        { # Case B\n            'k_R': 100.0, 'H0': 0.02, 't_end': 0.1,\n            'E_initial_func': lambda x, L: E0_val * (1.0 + 0.1 * np.sin(2.0 * np.pi * x / L))\n        },\n        { # Case C\n            'k_R': 1.0, 'H0': 0.01, 't_end': 0.2,\n            'E_initial_func': lambda x, L: E0_val * (1.0 + 0.2 * np.sin(4.0 * np.pi * x / L))\n        }\n    ]\n    \n    results = []\n    \n    # --- Run simulations and compute results ---\n    \n    # Case A\n    params_A = {**test_cases[0], 'L': L_domain, 'N': N_cells, 'a0': a0_val, 'c': c_light}\n    E_final_A, _, _ = run_simulation(params_A)\n    E_avg_num = np.mean(E_final_A)\n    E_exact_A = E0_val * np.exp(-4.0 * params_A['H0'] * params_A['t_end'])\n    rel_error_A = np.abs((E_avg_num - E_exact_A) / E_exact_A)\n    results.append(rel_error_A)\n    \n    # Case B\n    params_B = {**test_cases[1], 'L': L_domain, 'N': N_cells, 'a0': a0_val, 'c': c_light}\n    E_final_B, E_initial_B, _ = run_simulation(params_B)\n    E_exact_B = E_initial_B * np.exp(-4.0 * params_B['H0'] * params_B['t_end'])\n    mean_abs_rel_error_B = np.mean(np.abs((E_final_B - E_exact_B) / E_exact_B))\n    results.append(mean_abs_rel_error_B)\n    \n    # Case C\n    params_C = {**test_cases[2], 'L': L_domain, 'N': N_cells, 'a0': a0_val, 'c': c_light}\n    E_final_C, E_initial_C, a_final_C = run_simulation(params_C)\n    invariant_initial = np.mean(a0_val**4 * E_initial_C)\n    invariant_final = np.mean(a_final_C**4 * E_final_C)\n    rel_dev_C = np.abs((invariant_final - invariant_initial) / invariant_initial)\n    results.append(rel_dev_C)\n    \n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}