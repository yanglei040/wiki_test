{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of modern cosmology is translating observational data, such as the Hubble expansion rate $H(z)$, into a geometric understanding of the universe. This first practice focuses on that crucial step by tasking you with computing the line-of-sight comoving distance, $\\chi(z)$, from tabulated data . You will implement and compare different numerical interpolation and quadrature schemes, providing a practical lesson in how the choice of algorithm impacts the accuracy of fundamental cosmological calculations.",
            "id": "3506157",
            "problem": "You are given a tabulated Hubble expansion rate as a function of redshift, denoted by $H(z)$, and are asked to compute the line-of-sight comoving coordinate distance $\\chi(z)$ for specified target redshifts. You must design and implement a high-accuracy numerical quadrature for $\\chi(z)$ and estimate errors introduced by the choices of interpolation and integration scheme. Your derivation must begin from first principles applicable to the Friedmann–Lemaître–Robertson–Walker (FLRW) metric, and your computation must produce comoving distances expressed in megaparsecs with units $\\mathrm{Mpc}$. All quantities must be treated in a scientifically realistic and self-consistent manner.\n\nStarting from the Friedmann–Lemaître–Robertson–Walker (FLRW) line element and the null geodesic condition for photons, derive the integral expression for the line-of-sight comoving coordinate distance $\\chi(z)$ in a spatially flat background, expressed in terms of the Hubble expansion rate $H(z)$ and the speed of light $c$. Clearly state the unit conventions that make the computed $\\chi(z)$ be in $\\mathrm{Mpc}$ when $H(z)$ is provided in $\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$ and $c$ in $\\mathrm{km\\,s^{-1}}$.\n\nYou must then implement the following algorithmic components:\n- Construct two interpolation operators for the tabulated $H(z)$: piecewise linear interpolation and cubic spline interpolation with natural boundary conditions.\n- Implement two numerical quadrature schemes for integrating over redshift: a composite Simpson rule and an adaptive Gauss–Kronrod rule. The adaptive Gauss–Kronrod rule must be configured for high accuracy with absolute and relative tolerances set to $10^{-12}$.\n- For each target redshift $z$, compute $\\chi(z)$ using both interpolation schemes and both integration schemes.\n- For each test case, compute three error metrics:\n  1. Interpolation-choice error estimate $E_{\\mathrm{interp}}$: the maximum over target $z$ of the absolute difference between $\\chi(z)$ computed with cubic spline interpolation and piecewise linear interpolation, using the same composite Simpson quadrature.\n  2. Integration-choice error estimate $E_{\\mathrm{int}}$: the maximum over target $z$ of the absolute difference between $\\chi(z)$ computed with cubic spline interpolation using composite Simpson quadrature and cubic spline interpolation using adaptive Gauss–Kronrod quadrature.\n  3. Total error against an analytic high-resolution reference $E_{\\mathrm{total}}$: the maximum over target $z$ of the absolute difference between $\\chi(z)$ computed with cubic spline interpolation using adaptive Gauss–Kronrod quadrature and a reference $\\chi_{\\mathrm{ref}}(z)$ computed by integrating the exact analytic $H(z)$ with adaptive Gauss–Kronrod quadrature using the same tolerances. The reference should be computed from a well-tested formula for $H(z)$ derived from the Friedmann equation in a spatially flat universe with matter, radiation, and a cosmological constant.\n\nBase your derivation and implementation on the following fundamental context:\n- The Friedmann–Lemaître–Robertson–Walker (FLRW) metric for a spatially flat universe and the null condition for photon geodesics.\n- The definition of redshift $z$ and its relationship to the scale factor $a(t)$ and the Hubble expansion rate $H(z)$.\n- The speed of light $c=299792.458\\,\\mathrm{km\\,s^{-1}}$.\n- The Hubble expansion rate for a spatially flat $\\Lambda\\mathrm{CDM}$ model with matter, radiation, and cosmological constant components, given by the well-tested formula\n$$\nH(z)=H_0\\sqrt{\\Omega_{\\mathrm{r}}(1+z)^4+\\Omega_{\\mathrm{m}}(1+z)^3+\\Omega_{\\Lambda}},\n$$\nwhere $H_0$ is the Hubble constant, $\\Omega_{\\mathrm{r}}$ is the radiation density parameter, $\\Omega_{\\mathrm{m}}$ is the matter density parameter, and $\\Omega_{\\Lambda}$ is the cosmological constant density parameter, with $\\Omega_{\\mathrm{r}}+\\Omega_{\\mathrm{m}}+\\Omega_{\\Lambda}=1$.\n\nPhysical units requirement:\n- Express all comoving distances in $\\mathrm{Mpc}$.\n- Use $H(z)$ in $\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$ and $c$ in $\\mathrm{km\\,s^{-1}}$.\n\nTest suite:\n- Test Case $1$ (happy path, coarse tabulation, moderate redshift range): $H_0=70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$, $\\Omega_{\\mathrm{m}}=0.3$, $\\Omega_{\\Lambda}=0.7$, $\\Omega_{\\mathrm{r}}=0$, redshift grid $z\\in[0,2]$ with $11$ evenly spaced points, and target redshifts $z\\in\\{0.0,0.5,1.0,2.0\\}$.\n- Test Case $2$ (happy path, fine tabulation, same cosmology): $H_0=70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$, $\\Omega_{\\mathrm{m}}=0.3$, $\\Omega_{\\Lambda}=0.7$, $\\Omega_{\\mathrm{r}}=0$, redshift grid $z\\in[0,2]$ with $101$ evenly spaced points, and target redshifts $z\\in\\{0.2,0.9,1.7\\}$.\n- Test Case $3$ (edge case, high redshift with radiation): $H_0=67.74\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$, $\\Omega_{\\mathrm{m}}=0.3$, $\\Omega_{\\mathrm{r}}=9.2\\times 10^{-5}$, $\\Omega_{\\Lambda}=1-\\Omega_{\\mathrm{m}}-\\Omega_{\\mathrm{r}}$, redshift grid $z\\in[0,10]$ with $21$ evenly spaced points, and target redshifts $z\\in\\{0.0,2.0,6.0,10.0\\}$.\n\nYour program must:\n- Construct the tabulated $H(z)$ values for each test case by evaluating the analytic $H(z)$ model on the specified redshift grids.\n- For each test case, compute the three error metrics $E_{\\mathrm{interp}}$, $E_{\\mathrm{int}}$, and $E_{\\mathrm{total}}$ as defined above, all in $\\mathrm{Mpc}$.\n- Produce a single line of output containing the error metrics for all test cases, concatenated in order as a comma-separated list enclosed in square brackets. Specifically, the output must be $[E_{\\mathrm{interp,1}},E_{\\mathrm{int,1}},E_{\\mathrm{total,1}},E_{\\mathrm{interp,2}},E_{\\mathrm{int,2}},E_{\\mathrm{total,2}},E_{\\mathrm{interp,3}},E_{\\mathrm{int,3}},E_{\\mathrm{total,3}}]$ where the subscript denotes the test case index. All values must be floats in $\\mathrm{Mpc}$.",
            "solution": "The problem requires the derivation and numerical computation of the line-of-sight comoving distance in a cosmological context, followed by an error analysis of the numerical methods employed. The problem is rigorously defined, scientifically sound, and internally consistent.\n\n### 1. Derivation of the Comoving Distance $\\chi(z)$\n\nThe geometry of a homogeneous and isotropic universe is described by the Friedmann–Lemaître–Robertson–Walker (FLRW) metric. For a spatially flat universe ($k=0$), the line element $ds$ in spherical comoving coordinates $(\\chi, \\theta, \\phi)$ is given by:\n$$\nds^2 = c^2 dt^2 - a(t)^2 [d\\chi^2 + \\chi^2(d\\theta^2 + \\sin^2\\theta d\\phi^2)]\n$$\nwhere $c$ is the speed of light, $t$ is the cosmic time, $a(t)$ is the dimensionless scale factor (normalized to $a(t_0)=1$ at the present time $t_0$), and $\\chi$ is the radial comoving coordinate distance.\n\nWe consider a photon traveling from a distant source to an observer at the origin ($\\chi=0$). The photon follows a null geodesic, for which $ds^2=0$. Assuming the photon travels along a radial path ($d\\theta=0$, $d\\phi=0$), the condition becomes:\n$$\nc^2 dt^2 = a(t)^2 d\\chi^2\n$$\nTaking the square root and rearranging gives the increment in comoving distance traveled over a time interval $dt$:\n$$\nd\\chi = \\pm \\frac{c \\, dt}{a(t)}\n$$\nSince $\\chi$ is a distance, we take the positive root. The photon is traveling towards the origin, so its coordinate $\\chi$ decreases as time $t$ increases. Let the photon be emitted at time $t_e$ from a comoving distance $\\chi(z)$ and received at the present time $t_0$ at the origin ($\\chi=0$). Integrating the expression gives:\n$$\n\\int_{\\chi(z)}^0 d\\chi' = \\int_{t_e}^{t_0} -\\frac{c \\, dt'}{a(t')}\n$$\n$$\n-\\chi(z) = -c \\int_{t_e}^{t_0} \\frac{dt'}{a(t')} \\implies \\chi(z) = c \\int_{t_e}^{t_0} \\frac{dt'}{a(t')}\n$$\nTo express this integral in terms of redshift $z$, we use the definition of redshift, $1+z = a(t_0)/a(t) = 1/a(t)$, and the definition of the Hubble parameter, $H(t) = \\dot{a}/a = (1/a)(da/dt)$. We can write $dt = da/(aH)$.\nThe differential $dz$ is related to $da$ by differentiating $a=(1+z)^{-1}$:\n$$\nda = -(1+z)^{-2} dz\n$$\nSubstituting this into the expression for $dt$:\n$$\ndt = \\frac{-(1+z)^{-2} dz}{(1+z)^{-1} H(z)} = -\\frac{dz}{(1+z)H(z)}\n$$\nNow, we change the variable of integration from $t'$ to $z'$. The integration limits become $t_e \\to z$ and $t_0 \\to 0$.\n$$\n\\chi(z) = c \\int_{z}^{0} \\frac{1}{a(t(z'))} \\left( -\\frac{dz'}{(1+z')H(z')} \\right)\n$$\nUsing $a(t(z')) = (1+z')^{-1}$, we get:\n$$\n\\chi(z) = c \\int_{z}^{0} (1+z') \\left( -\\frac{dz'}{(1+z')H(z')} \\right) = -c \\int_{z}^{0} \\frac{dz'}{H(z')}\n$$\nFlipping the integration limits to absorb the negative sign yields the final expression for the line-of-sight comoving distance:\n$$\n\\chi(z) = c \\int_0^z \\frac{dz'}{H(z')}\n$$\n\n### 2. Unit Consistency\n\nThe problem specifies units for the input quantities: $c$ is in $\\mathrm{km\\,s^{-1}}$ and $H(z)$ is in $\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$. The integration variable $z'$ is dimensionless. The units of the integrand $\\frac{c}{H(z')}$ are:\n$$\n\\text{Units}\\left[\\frac{c}{H(z')}\\right] = \\frac{\\mathrm{km\\,s^{-1}}}{\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}} = \\mathrm{Mpc}\n$$\nTherefore, the result of the integration, $\\chi(z)$, will naturally be in units of megaparsecs ($\\mathrm{Mpc}$), as required.\n\n### 3. Numerical Implementation Strategy\n\nThe core of the problem is to compute the integral for $\\chi(z)$ using numerically tabulated data for $H(z)$, and to quantify the errors arising from this process.\n\n**A. Interpolation of $H(z)$**\nThe tabulated data $(z_i, H(z_i))$ must be converted into a continuous function $H_{\\text{interp}}(z)$ to be used in the integral. We are required to use two methods:\n1.  **Piecewise Linear Interpolation**: This method connects adjacent data points with straight lines. It is simple and robust but has low accuracy, as its derivative is discontinuous at the data points.\n2.  **Cubic Spline Interpolation**: This method fits a piecewise cubic polynomial between data points, ensuring that the resulting function and its first two derivatives are continuous. We will use natural boundary conditions, which set the second derivative of the spline to zero at the endpoints. This is a higher-order method that generally provides a much smoother and more accurate representation of the underlying function.\n\n**B. Numerical Quadrature**\nWe need to compute the integral $\\int_0^z (c/H_{\\text{interp}}(z')) dz'$ for various target redshifts $z$. Two methods are required:\n1.  **Composite Simpson's Rule**: This is a classic Newton-Cotes formula that approximates the integrand with a quadratic function over subintervals. To achieve high accuracy and ensure the integration error is subdominant to the interpolation error, we will use a fine grid with $10001$ points for the integration.\n2.  **Adaptive Gauss-Kronrod Quadrature**: This is a more sophisticated method that automatically adjusts the subinterval density to meet prescribed accuracy goals. It uses a pair of nested Gaussian quadrature rules (the Gauss rule and the higher-order Kronrod rule) to estimate the integral and its error. We will use it with strict absolute and relative tolerances of $10^{-12}$.\n\n**C. Error Estimation**\nThe problem defines three error metrics to evaluate the numerical scheme:\n1.  $E_{\\mathrm{interp}} = \\max_z |\\chi_{\\text{spline, Simp}}(z) - \\chi_{\\text{lin, Simp}}(z)|$: This isolates the error due to the choice of interpolation scheme (linear vs. spline) by holding the integration method (Simpson's rule) constant.\n2.  $E_{\\mathrm{int}} = \\max_z |\\chi_{\\text{spline, Simp}}(z) - \\chi_{\\text{spline, adapt}}(z)|$: This isolates the error due to the choice of integration scheme (Simpson vs. adaptive) by holding the interpolation method (cubic spline) constant.\n3.  $E_{\\mathrm{total}} = \\max_z |\\chi_{\\text{spline, adapt}}(z) - \\chi_{\\mathrm{ref}}(z)|$: This measures the total error of our best numerical scheme (spline interpolation with adaptive quadrature) against a high-fidelity reference value, $\\chi_{\\text{ref}}$. The reference is computed by integrating the exact analytic formula for $H(z)$ using the same high-accuracy adaptive quadrature, thereby representing the \"ground truth\" for the given cosmology.\n\nThe computational procedure for each test case will be:\n1.  Generate the discrete table of $(z_i, H(z_i))$ values from the analytic $\\Lambda$CDM formula.\n2.  Construct the piecewise linear and cubic spline interpolating functions for $H(z)$.\n3.  For each target redshift $z_j$:\n    - Compute $\\chi(z_j)$ using the four combinations of interpolation and integration schemes.\n    - Compute the reference value $\\chi_{\\mathrm{ref}}(z_j)$.\n4.  Calculate the maximum absolute differences over all $z_j$ to find $E_{\\mathrm{interp}}$, $E_{\\mathrm{int}}$, and $E_{\\mathrm{total}}$.\n5.  Collect the results for all test cases and format them as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import interp1d, CubicSpline\nfrom scipy.integrate import simpson, quad\n\ndef solve():\n    \"\"\"\n    Computes comoving distances and evaluates numerical errors based on\n    tabulated Hubble expansion rate data.\n    \"\"\"\n    # Speed of light in km/s\n    c = 299792.458\n\n    # Test cases: (H0, Om_m, Om_r, (z_min, z_max, n_points), target_z_list)\n    test_cases = [\n        (70.0, 0.3, 0.0, (0.0, 2.0, 11), [0.0, 0.5, 1.0, 2.0]),\n        (70.0, 0.3, 0.0, (0.0, 2.0, 101), [0.2, 0.9, 1.7]),\n        (67.74, 0.3, 9.2e-5, (0.0, 10.0, 21), [0.0, 2.0, 6.0, 10.0])\n    ]\n\n    # Parameters for numerical methods\n    SIMPSON_N_POINTS = 10001\n    ADAPTIVE_TOL = 1e-12\n\n    results = []\n    for case_params in test_cases:\n        H0, Om_m, Om_r, z_grid_params, target_z = case_params\n        Om_L = 1.0 - Om_m - Om_r\n\n        # --- 1. Define H(z) functions ---\n\n        def H_analytic(z, H0_loc=H0, Om_m_loc=Om_m, Om_r_loc=Om_r, Om_L_loc=Om_L):\n            \"\"\"Analytic Hubble expansion rate for flat LambdaCDM+radiation.\"\"\"\n            return H0_loc * np.sqrt(Om_r_loc * (1 + z)**4 + Om_m_loc * (1 + z)**3 + Om_L_loc)\n\n        # --- 2. Generate tabulated data and interpolators ---\n        \n        z_tab = np.linspace(z_grid_params[0], z_grid_params[1], z_grid_params[2])\n        H_tab = H_analytic(z_tab)\n\n        # Piecewise linear interpolation\n        H_linear_interp = interp1d(z_tab, H_tab, kind='linear', bounds_error=False, fill_value=\"extrapolate\")\n        \n        # Cubic spline interpolation with natural boundary conditions\n        H_spline_interp = CubicSpline(z_tab, H_tab, bc_type='natural')\n\n        # --- 3. Define integrands for comoving distance ---\n        \n        integrand_linear = lambda z: c / H_linear_interp(z)\n        integrand_spline = lambda z: c / H_spline_interp(z)\n        integrand_analytic = lambda z: c / H_analytic(z)\n\n        # --- 4. Compute chi(z) for all methods and target redshifts ---\n        \n        chi_lin_simp_vals = []\n        chi_spline_simp_vals = []\n        chi_spline_adapt_vals = []\n        chi_ref_vals = []\n\n        for z_t in target_z:\n            if z_t == 0.0:\n                chi_lin_simp_vals.append(0.0)\n                chi_spline_simp_vals.append(0.0)\n                chi_spline_adapt_vals.append(0.0)\n                chi_ref_vals.append(0.0)\n                continue\n\n            # a) Composite Simpson's rule integration\n            z_fine_grid = np.linspace(0, z_t, SIMPSON_N_POINTS)\n            \n            y_linear = integrand_linear(z_fine_grid)\n            chi_lin_simp = simpson(y_linear, z_fine_grid)\n            chi_lin_simp_vals.append(chi_lin_simp)\n\n            y_spline = integrand_spline(z_fine_grid)\n            chi_spline_simp = simpson(y_spline, z_fine_grid)\n            chi_spline_simp_vals.append(chi_spline_simp)\n            \n            # b) Adaptive Gauss-Kronrod integration\n            chi_spline_adapt, _ = quad(integrand_spline, 0, z_t, epsabs=ADAPTIVE_TOL, epsrel=ADAPTIVE_TOL)\n            chi_spline_adapt_vals.append(chi_spline_adapt)\n\n            # c) Reference high-accuracy calculation\n            chi_ref, _ = quad(integrand_analytic, 0, z_t, epsabs=ADAPTIVE_TOL, epsrel=ADAPTIVE_TOL)\n            chi_ref_vals.append(chi_ref)\n        \n        chi_lin_simp_arr = np.array(chi_lin_simp_vals)\n        chi_spline_simp_arr = np.array(chi_spline_simp_vals)\n        chi_spline_adapt_arr = np.array(chi_spline_adapt_vals)\n        chi_ref_arr = np.array(chi_ref_vals)\n\n        # --- 5. Compute error metrics ---\n\n        # E_interp: Error from interpolation choice (linear vs. spline)\n        E_interp = np.max(np.abs(chi_spline_simp_arr - chi_lin_simp_arr))\n\n        # E_int: Error from integration choice (Simpson vs. adaptive)\n        E_int = np.max(np.abs(chi_spline_simp_arr - chi_spline_adapt_arr))\n\n        # E_total: Total error of best scheme vs. analytic reference\n        E_total = np.max(np.abs(chi_spline_adapt_arr - chi_ref_arr))\n\n        results.extend([E_interp, E_int, E_total])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having established the background cosmology, we now turn to the dynamics of particles within it. This exercise explores the fundamental effect of cosmic expansion on a free-streaming particle's peculiar momentum, a phenomenon often called \"Hubble drag\" . By implementing several standard numerical integrators and benchmarking them against the known analytical solution, you will gain direct insight into their accuracy and convergence properties for a key cosmological process.",
            "id": "3506150",
            "problem": "Implement a complete, runnable program that integrates free-streaming peculiar momentum in comoving coordinates for a particle evolving in conformal time. Begin from the following fundamental base: in an expanding, spatially flat Friedmann–Robertson–Walker background, free-streaming peculiar momentum satisfies the first-order Ordinary Differential Equation (ODE) $u'(\\tau) + \\mathcal{H}(\\tau)\\,u(\\tau) = 0$, where $\\tau$ is conformal time, $u(\\tau)$ is the comoving peculiar momentum, and $\\mathcal{H}(\\tau) = a'(\\tau)/a(\\tau)$ is the conformal Hubble parameter with $a(\\tau)$ the scale factor. You must derive an exact discrete-time integrator implied by the analytical solution to this ODE and benchmark it against explicit numerical schemes that directly time-step the ODE $u'(\\tau) + \\mathcal{H}(\\tau)\\,u(\\tau) = 0$.\n\nYour program must:\n- Use dimensionless quantities throughout; no physical units are required or permitted.\n- Implement the following cosmological backgrounds as functions of conformal time $\\tau$:\n  - Radiation-dominated: $a(\\tau) = \\tau$, yielding $\\mathcal{H}(\\tau) = 1/\\tau$ for $\\tau > 0$.\n  - Matter-dominated: $a(\\tau) = \\tau^2$, yielding $\\mathcal{H}(\\tau) = 2/\\tau$ for $\\tau > 0$.\n  - Cosmological-constant-dominated (de Sitter in conformal time): $a(\\tau) = -1/\\tau$, yielding $\\mathcal{H}(\\tau) = -1/\\tau$ for $\\tau  0$.\n- Implement four integration schemes that advance $u(\\tau)$ from an initial time $\\tau_0$ to a final time $\\tau_1$ using $N$ uniform steps of size $\\Delta \\tau = (\\tau_1 - \\tau_0)/N$:\n  - An exact discrete integrator implied by the analytical solution to the ODE, applied stepwise over each interval.\n  - Forward (explicit) Euler applied to the ODE $u'(\\tau) + \\mathcal{H}(\\tau)\\,u(\\tau) = 0$.\n  - Implicit Euler applied to the same ODE.\n  - Classical fourth-order Runge–Kutta (RK4) applied to the same ODE.\n- For benchmarking, compute the relative error at $\\tau_1$ for each scheme with respect to the exact analytical solution of the ODE, defined as $\\varepsilon = \\lvert u_{\\text{num}}(\\tau_1) - u_{\\text{exact}}(\\tau_1) \\rvert / \\max(\\lvert u_{\\text{exact}}(\\tau_1) \\rvert, 10^{-15})$.\n\nDesign a test suite that exercises distinct regimes and edge cases:\n- Test case $1$ (happy path, radiation-dominated): $\\tau_0 = 1$, $\\tau_1 = 4$, $u_0 = 1.23$, $N = 20$, with $a(\\tau) = \\tau$.\n- Test case $2$ (happy path, matter-dominated): $\\tau_0 = 1$, $\\tau_1 = 2$, $u_0 = -2.5$, $N = 50$, with $a(\\tau) = \\tau^2$.\n- Test case $3$ (boundary: zero momentum, de Sitter): $\\tau_0 = -1$, $\\tau_1 = -0.5$, $u_0 = 0$, $N = 30$, with $a(\\tau) = -1/\\tau$.\n- Test case $4$ (edge: extremely coarse stepping, radiation-dominated): $\\tau_0 = 1$, $\\tau_1 = 4$, $u_0 = 3$, $N = 1$, with $a(\\tau) = \\tau$.\n\nFor each test case, your program must output a single list of four floats, in the fixed order: $[\\varepsilon_{\\text{exact-step}}, \\varepsilon_{\\text{forward-Euler}}, \\varepsilon_{\\text{implicit-Euler}}, \\varepsilon_{\\text{RK4}}]$. Aggregate the results from all test cases into a single line containing an outer list of these four-element lists. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[[e_{1,1}, e_{1,2}, e_{1,3}, e_{1,4}], [e_{2,1}, e_{2,2}, e_{2,3}, e_{2,4}], [e_{3,1}, e_{3,2}, e_{3,3}, e_{3,4}], [e_{4,1}, e_{4,2}, e_{4,3}, e_{4,4}]]$.\n\nNo user input is allowed; all parameters must be coded into the program exactly as specified above. The final printed output must be the single line in the specified format. Ensure scientific realism by keeping $\\tau$ values within domains where $a(\\tau)$ and $\\mathcal{H}(\\tau)$ are finite and well-defined (do not cross $\\tau = 0$ in the de Sitter case). The program must be structured and documented clearly so that a developer can verify correctness and reproduce the benchmark.",
            "solution": "The problem requires the implementation and benchmarking of several numerical integration schemes for the evolution of a particle's comoving peculiar momentum, $u$, in an expanding universe. The evolution is described by a first-order ordinary differential equation (ODE) in terms of conformal time, $\\tau$.\n\nThe fundamental governing equation provided is:\n$$\n\\frac{du}{d\\tau} + \\mathcal{H}(\\tau)u(\\tau) = 0\n$$\nwhere $u'(\\tau) = du/d\\tau$, and $\\mathcal{H}(\\tau) = a'(\\tau)/a(\\tau)$ is the conformal Hubble parameter, with $a(\\tau)$ being the cosmological scale factor. This equation describes the \"Hubble drag\" on the peculiar momentum, which decreases as the universe expands.\n\nFirst, we solve this ODE analytically to establish a ground truth for benchmarking. The equation is a first-order linear homogeneous ODE, which can be solved by separation of variables:\n$$\n\\frac{du}{u} = -\\mathcal{H}(\\tau)d\\tau\n$$\nIntegrating from an initial time $\\tau_0$ to a later time $\\tau$ gives:\n$$\n\\int_{u(\\tau_0)}^{u(\\tau)} \\frac{d\\tilde{u}}{\\tilde{u}} = -\\int_{\\tau_0}^{\\tau} \\mathcal{H}(\\tilde{\\tau})d\\tilde{\\tau}\n$$\n$$\n\\ln\\left(\\frac{u(\\tau)}{u(\\tau_0)}\\right) = -\\int_{\\tau_0}^{\\tau} \\frac{a'(\\tilde{\\tau})}{a(\\tilde{\\tau})}d\\tilde{\\tau} = -\\left[\\ln(a(\\tilde{\\tau}))\\right]_{\\tau_0}^{\\tau} = -(\\ln(a(\\tau)) - \\ln(a(\\tau_0))) = \\ln\\left(\\frac{a(\\tau_0)}{a(\\tau)}\\right)\n$$\nExponentiating both sides yields the exact analytical solution:\n$$\nu(\\tau) = u(\\tau_0) \\frac{a(\\tau_0)}{a(\\tau)}\n$$\nThis result shows that the comoving peculiar momentum redshifts, its magnitude decreasing in inverse proportion to the scale factor, $u \\propto 1/a$.\n\nThe program will implement and compare four integration schemes to solve the ODE from an initial time $\\tau_0$ to a final time $\\tau_1$ over $N$ uniform steps of size $\\Delta\\tau = (\\tau_1 - \\tau_0)/N$. Let $u_i = u(\\tau_i)$ where $\\tau_i = \\tau_0 + i\\Delta\\tau$.\n\n$1$. **Exact Stepwise Integrator**: This scheme applies the exact analytical solution over each discrete time step from $\\tau_i$ to $\\tau_{i+1}$. The update rule is directly derived from the analytical solution:\n$$\nu_{i+1} = u_i \\frac{a(\\tau_i)}{a(\\tau_{i+1})}\n$$\nBy construction, this method will yield the exact result at $\\tau_1$ up to floating-point precision, so its relative error should be near zero.\n\n$2$. **Forward (Explicit) Euler Method**: This is the simplest numerical scheme. It approximates the derivative at the beginning of the interval, $\\tau_i$. The ODE is written as $u' = -\\mathcal{H}(\\tau)u(\\tau)$. The update rule is:\n$$\nu_{i+1} = u_i + \\Delta\\tau \\cdot u'(\\tau_i) = u_i - \\Delta\\tau \\mathcal{H}(\\tau_i) u_i = u_i (1 - \\Delta\\tau \\mathcal{H}(\\tau_i))\n$$\n\n$3$. **Implicit Euler Method**: This scheme evaluates the derivative at the end of the interval, $\\tau_{i+1}$, making it more stable for stiff problems. The update rule is:\n$$\nu_{i+1} = u_i + \\Delta\\tau \\cdot u'(\\tau_{i+1}) = u_i - \\Delta\\tau \\mathcal{H}(\\tau_{i+1}) u_{i+1}\n$$\nSolving for $u_{i+1}$ yields the explicit update rule:\n$$\nu_{i+1}(1 + \\Delta\\tau \\mathcal{H}(\\tau_{i+1})) = u_i \\implies u_{i+1} = \\frac{u_i}{1 + \\Delta\\tau \\mathcal{H}(\\tau_{i+1})}\n$$\n\n$4$. **Classical Fourth-Order Runge-Kutta (RK4) Method**: This is a higher-order method that provides greater accuracy by evaluating the derivative at multiple points within the step. For an ODE $u' = f(\\tau, u)$, the update rule is:\n$$\nu_{i+1} = u_i + \\frac{\\Delta\\tau}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\nwhere, for our specific problem $f(\\tau, u) = -\\mathcal{H}(\\tau)u(\\tau)$:\n- $k_1 = f(\\tau_i, u_i) = -\\mathcal{H}(\\tau_i)u_i$\n- $k_2 = f(\\tau_i + \\frac{\\Delta\\tau}{2}, u_i + \\frac{\\Delta\\tau}{2}k_1) = -\\mathcal{H}(\\tau_i + \\frac{\\Delta\\tau}{2})(u_i + \\frac{\\Delta\\tau}{2}k_1)$\n- $k_3 = f(\\tau_i + \\frac{\\Delta\\tau}{2}, u_i + \\frac{\\Delta\\tau}{2}k_2) = -\\mathcal{H}(\\tau_i + \\frac{\\Delta\\tau}{2})(u_i + \\frac{\\Delta\\tau}{2}k_2)$\n- $k_4 = f(\\tau_i + \\Delta\\tau, u_i + \\Delta\\tau k_3) = -\\mathcal{H}(\\tau_i + \\Delta\\tau)(u_i + \\Delta\\tau k_3)$\n\nThe specified cosmological models are:\n- Radiation-dominated: $a(\\tau) = \\tau$, $\\mathcal{H}(\\tau) = 1/\\tau$, for $\\tau > 0$.\n- Matter-dominated: $a(\\tau) = \\tau^2$, $\\mathcal{H}(\\tau) = 2/\\tau$, for $\\tau > 0$.\n- de Sitter: $a(\\tau) = -1/\\tau$, $\\mathcal{H}(\\tau) = -1/\\tau$, for $\\tau  0$.\nFor all these models, the ODE has the form $u' = -c \\cdot u/\\tau$ for some constant $c$. It is a known property that the RK4 method provides the exact solution for ODEs of this form. Consequently, we expect the RK4 error to be near zero for all test cases.\n\nThe benchmarking process is as follows:\n- For each test case, the parameters $(\\tau_0, \\tau_1, u_0, N)$ and the cosmological model are defined.\n- The exact final momentum $u_{\\text{exact}}(\\tau_1) = u_0 a(\\tau_0)/a(\\tau_1)$ is computed.\n- For each of the four numerical schemes, the final momentum $u_{\\text{num}}(\\tau_1)$ is computed by iterating $N$ times from $\\tau_0$.\n- The relative error, $\\varepsilon$, is calculated for each scheme using the provided formula:\n$$\n\\varepsilon = \\frac{\\lvert u_{\\text{num}}(\\tau_1) - u_{\\text{exact}}(\\tau_1) \\rvert}{\\max(\\lvert u_{\\text{exact}}(\\tau_1) \\rvert, 10^{-15})}\n$$\nThe program collates these errors for each test case and presents them in the specified list-of-lists format.",
            "answer": "```python\n#\n# Meticulous and Exacting STEM Professor\n# Solution for Comoving Momentum Integration\n#\n\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main entry point for the program. Defines test cases, runs benchmarks,\n    and prints the final results in the specified format.\n    \"\"\"\n\n    # Dictionary mapping cosmology names to their scale factor and Hubble parameter functions.\n    cosmology_models = {\n        'radiation': {\n            'a': lambda tau: tau,\n            'H': lambda tau: 1.0 / tau\n        },\n        'matter': {\n            'a': lambda tau: tau**2,\n            'H': lambda tau: 2.0 / tau\n        },\n        'de_sitter': {\n            'a': lambda tau: -1.0 / tau,\n            'H': lambda tau: -1.0 / tau\n        }\n    }\n\n    # Define the test suite as specified in the problem statement.\n    test_cases = [\n        {'cosmology': 'radiation', 'tau0': 1.0, 'tau1': 4.0, 'u0': 1.23, 'N': 20},\n        {'cosmology': 'matter',    'tau0': 1.0, 'tau1': 2.0, 'u0': -2.5, 'N': 50},\n        {'cosmology': 'de_sitter', 'tau0': -1.0, 'tau1': -0.5, 'u0': 0.0, 'N': 30},\n        {'cosmology': 'radiation', 'tau0': 1.0, 'tau1': 4.0, 'u0': 3.0, 'N': 1},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        errors = run_benchmark(case, cosmology_models)\n        all_results.append(errors)\n\n    # Format the final output string as a list of lists.\n    # The default string representation of floats is used as no specific format was required.\n    inner_lists_str = []\n    for res_list in all_results:\n        inner_lists_str.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    final_output = f\"[{','.join(inner_lists_str)}]\"\n    print(final_output)\n\n\ndef run_benchmark(case, cosmology_models):\n    \"\"\"\n    Runs all integration schemes for a single test case and returns their relative errors.\n\n    Args:\n        case (dict): A dictionary containing parameters for the test case\n                     (cosmology, tau0, tau1, u0, N).\n        cosmology_models (dict): A dictionary of cosmological model functions.\n\n    Returns:\n        list: A list of four floats representing the relative errors for each scheme.\n    \"\"\"\n    cosmology = case['cosmology']\n    tau0, tau1, u0, N = case['tau0'], case['tau1'], case['u0'], case['N']\n\n    a_func = cosmology_models[cosmology]['a']\n    H_func = cosmology_models[cosmology]['H']\n\n    # Generate time steps. np.linspace correctly handles N=1 (2 points).\n    tau_steps = np.linspace(tau0, tau1, N + 1)\n    delta_tau = (tau1 - tau0) / N\n\n    # Calculate the exact analytical solution at the final time for reference.\n    u_exact_final = u0 * a_func(tau0) / a_func(tau1)\n\n    # Run each of the four integration schemes.\n    u_exact_step_final = integrate_exact_step(u0, tau_steps, a_func)\n    u_forward_euler_final = integrate_forward_euler(u0, tau_steps, delta_tau, H_func)\n    u_implicit_euler_final = integrate_implicit_euler(u0, tau_steps, delta_tau, H_func)\n    u_rk4_final = integrate_rk4(u0, tau_steps, delta_tau, H_func)\n\n    # Collect the numerical results.\n    numerical_solutions = [\n        u_exact_step_final,\n        u_forward_euler_final,\n        u_implicit_euler_final,\n        u_rk4_final\n    ]\n    \n    # Calculate the relative error for each scheme.\n    errors = [calculate_relative_error(u_num, u_exact_final) for u_num in numerical_solutions]\n    \n    return errors\n\n\ndef calculate_relative_error(u_num, u_exact):\n    \"\"\"\n    Calculates the relative error according to the specified formula.\n    \"\"\"\n    numerator = np.abs(u_num - u_exact)\n    denominator = np.maximum(np.abs(u_exact), 1e-15)\n    return numerator / denominator\n\n\ndef integrate_exact_step(u0, tau_steps, a_func):\n    \"\"\"Integrator based on the exact solution applied stepwise.\"\"\"\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        u = u * a_func(tau_steps[i]) / a_func(tau_steps[i+1])\n    return u\n\n\ndef integrate_forward_euler(u0, tau_steps, delta_tau, H_func):\n    \"\"\"Forward (explicit) Euler integrator.\"\"\"\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        tau_i = tau_steps[i]\n        u = u * (1.0 - delta_tau * H_func(tau_i))\n    return u\n\n\ndef integrate_implicit_euler(u0, tau_steps, delta_tau, H_func):\n    \"\"\"Implicit Euler integrator.\"\"\"\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        tau_i_plus_1 = tau_steps[i+1]\n        u = u / (1.0 + delta_tau * H_func(tau_i_plus_1))\n    return u\n\n\ndef integrate_rk4(u0, tau_steps, delta_tau, H_func):\n    \"\"\"Classical fourth-order Runge-Kutta (RK4) integrator.\"\"\"\n    # Define the function f(tau, u) = u' for the ODE u' = -H(tau) * u\n    f = lambda tau, u: -H_func(tau) * u\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        tau_i = tau_steps[i]\n        \n        k1 = f(tau_i, u)\n        k2 = f(tau_i + 0.5 * delta_tau, u + 0.5 * delta_tau * k1)\n        k3 = f(tau_i + 0.5 * delta_tau, u + 0.5 * delta_tau * k2)\n        k4 = f(tau_i + delta_tau, u + delta_tau * k3)\n        \n        u = u + (delta_tau / 6.0) * (k1 + 2.0*k2 + 2.0*k3 + k4)\n    return u\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "Building on simple dynamics, this final practice addresses a more advanced topic in numerical cosmology: the design of the integrator itself. When simulating particles interacting within a comoving potential, the choice of the independent integration variable—be it cosmic time $t$, conformal time $\\eta$, or the scale factor $a$—has profound implications for numerical accuracy . By quantifying how well each strategy conserves a known energy invariant, you will discover why certain time coordinates are preferred for achieving stable and physically faithful cosmological simulations.",
            "id": "3506154",
            "problem": "You are asked to implement and compare three constant step-size control strategies for numerically integrating the comoving equations of motion of a single particle in a spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) universe. The strategies are based on the independent variables cosmic time $t$, conformal time $\\eta$, and scale factor $a$. Your comparison must quantify the impact of each strategy on the conservation of a comoving energy invariant.\n\nFundamental base and definitions:\n- Let the physical position be $r(t)=a(t)\\,x(t)$, where $a(t)$ is the scale factor and $x(t)$ is the comoving coordinate. Consider one spatial dimension, so that $x$ and $r$ are scalars. Define the Hubble parameter $H(a)$ via $H(a)=\\dot{a}/a$, where the dot denotes derivative with respect to $t$.\n- Let the dimensionless Hubble function be $h(a)=H(a)/H_0$, where $H_0$ is a constant reference value. Assume a flat Lambda Cold Dark Matter model such that $h(a)=\\sqrt{\\Omega_{\\mathrm{m}} a^{-3}+\\Omega_{\\Lambda}}$ with constants $\\Omega_{\\mathrm{m}}$ and $\\Omega_{\\Lambda}$ satisfying $\\Omega_{\\mathrm{m}}+\\Omega_{\\Lambda}=1$.\n- Define conformal time $\\eta$ by $d\\eta=dt/a$. The scale factor $a$ is related to $\\eta$ and $t$ by\n$$\n\\frac{d\\eta}{da}=\\frac{1}{a^2 h(a)},\\qquad \\frac{dt}{da}=\\frac{1}{a h(a)}.\n$$\n- Consider a comoving harmonic potential $\\phi(x)=\\tfrac{1}{2}\\,\\omega_c^2\\,x^2$ that is independent of $\\eta$, with constant $\\omega_c>0$.\n\nEquations of motion:\n- In conformal time, the comoving equations of motion are\n$$\n\\frac{dx}{d\\eta}=u,\\qquad \\frac{du}{d\\eta}=-\\omega_c^2\\,x,\n$$\nwhere $u$ is the comoving canonical momentum conjugate to $x$ (equal to $dx/d\\eta$ for unit mass). The comoving energy\n$$\nE_c(\\eta)=\\tfrac{1}{2}\\,u^2+\\tfrac{1}{2}\\,\\omega_c^2\\,x^2\n$$\nis an invariant for this time-independent comoving potential, and therefore must be conserved by the exact dynamics.\n\n- Rewriting the same dynamics using cosmic time $t$, and using only the definitions above without introducing any additional cosmological formulas, yields\n$$\n\\frac{dx}{dt}=\\frac{u}{a},\\qquad \\frac{du}{dt}=-\\frac{\\omega_c^2}{a}\\,x,\\qquad \\frac{da}{dt}=a\\,h(a).\n$$\n\n- Rewriting with scale factor $a$ as the independent variable yields\n$$\n\\frac{dx}{da}=\\frac{u}{a^2 h(a)},\\qquad \\frac{du}{da}=-\\frac{\\omega_c^2}{a^2 h(a)}\\,x.\n$$\n\nNumerical method requirement:\n- Implement a single-step explicit second-order Runge–Kutta (midpoint) method for a general first-order system $\\dfrac{d\\mathbf{y}}{ds}=\\mathbf{F}(s,\\mathbf{y})$, where $s$ is the chosen independent variable ($t$, $\\eta$, or $a$). The step from $s_n$ to $s_{n+1}=s_n+\\Delta s$ is\n$$\n\\mathbf{k}_1=\\mathbf{F}(s_n,\\mathbf{y}_n),\\quad \\mathbf{k}_2=\\mathbf{F}\\left(s_n+\\tfrac{1}{2}\\Delta s,\\ \\mathbf{y}_n+\\tfrac{1}{2}\\Delta s\\,\\mathbf{k}_1\\right),\\quad \\mathbf{y}_{n+1}=\\mathbf{y}_n+\\Delta s\\,\\mathbf{k}_2.\n$$\n\nPerformance metric:\n- For each strategy, compute the maximum relative drift of the comoving energy\n$$\n\\delta_{\\max}=\\max_{n}\\left|\\frac{E_c(n)-E_c(0)}{E_c(0)}\\right|,\n$$\nwhere $E_c(n)$ is the comoving energy at step index $n$, and $E_c(0)$ is the initial comoving energy. All quantities are dimensionless.\n\nImplementation details:\n- Use the dimensionless Hubble function $h(a)=\\sqrt{\\Omega_{\\mathrm{m}} a^{-3}+\\Omega_{\\Lambda}}$ to evaluate $d\\eta/da$ and $dt/da$, and to evolve $a(t)$ when integrating with $t$ as the independent variable.\n- When integrating with $\\eta$ as the independent variable, obtain the total $\\Delta \\eta$ over the interval $[a_{\\mathrm{i}},a_{\\mathrm{f}}]$ by integrating $d\\eta/da$ over $a$; likewise, when integrating with $t$ as the independent variable, obtain the total $\\Delta t$ over $[a_{\\mathrm{i}},a_{\\mathrm{f}}]$ by integrating $dt/da$ over $a$. Use constant step sizes $\\Delta s$ determined by dividing these totals by the number of steps $N$.\n- Initial conditions are specified at $a=a_{\\mathrm{i}}$ as $x(0)=x_0$ and $u(0)=u_0$.\n\nTest suite:\n- Case $1$ (general Lambda Cold Dark Matter): $\\Omega_{\\mathrm{m}}=0.3$, $\\Omega_{\\Lambda}=0.7$, $a_{\\mathrm{i}}=0.1$, $a_{\\mathrm{f}}=1.0$, $\\omega_c=0.5$, $x_0=1.0$, $u_0=0.0$, $N=1000$.\n- Case $2$ (Einstein–de Sitter matter-only, early times): $\\Omega_{\\mathrm{m}}=1.0$, $\\Omega_{\\Lambda}=0.0$, $a_{\\mathrm{i}}=0.01$, $a_{\\mathrm{f}}=0.1$, $\\omega_c=2.0$, $x_0=0.2$, $u_0=0.0$, $N=1500$.\n- Case $3$ (cosmological constant dominated, late times): $\\Omega_{\\mathrm{m}}=0.0$, $\\Omega_{\\Lambda}=1.0$, $a_{\\mathrm{i}}=0.5$, $a_{\\mathrm{f}}=2.0$, $\\omega_c=0.1$, $x_0=1.0$, $u_0=0.0$, $N=800$.\n\nRequired final output format:\n- Your program should produce a single line of output containing a list of length $3$, where each element is itself a list of length $3$ with the maximum relative energy drifts for the three strategies in the order $[t,\\eta,a]$, corresponding to the three test cases in the order $[1,2,3]$. For example, the output must look like\n$$\n[[\\delta_{t,1},\\delta_{\\eta,1},\\delta_{a,1}],\\ [\\delta_{t,2},\\delta_{\\eta,2},\\delta_{a,2}],\\ [\\delta_{t,3},\\delta_{\\eta,3},\\delta_{a,3}]],\n$$\nprinted as a single line with square brackets and commas, with dimensionless floating-point numbers.",
            "solution": "The user has requested the implementation and comparison of three numerical integration strategies for the equations of motion of a particle in a comoving harmonic potential. The validation and solution are presented below.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n-   **Model**: Spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) universe.\n-   **Coordinates  Relations**: Physical position $r(t) = a(t)x(t)$, where $x$ is the comoving coordinate. Hubble parameter $H(a) = \\dot{a}/a$. Dimensionless Hubble function $h(a) = H(a)/H_0 = \\sqrt{\\Omega_{\\mathrm{m}} a^{-3} + \\Omega_{\\Lambda}}$ with $\\Omega_{\\mathrm{m}} + \\Omega_{\\Lambda} = 1$. Conformal time defined by $d\\eta = dt/a$.\n-   **Key Differential Relations**: $\\frac{d\\eta}{da} = \\frac{1}{a^2 h(a)}$, $\\frac{dt}{da} = \\frac{1}{a h(a)}$.\n-   **Potential and Invariant**: Comoving harmonic potential $\\phi(x) = \\frac{1}{2}\\omega_c^2 x^2$. The associated comoving energy $E_c = \\frac{1}{2}u^2 + \\frac{1}{2}\\omega_c^2 x^2$ is an invariant, where $u$ is the comoving canonical momentum.\n-   **Equations of Motion (EOMs)**:\n    1.  Independent variable $\\eta$: $\\frac{dx}{d\\eta}=u$, $\\frac{du}{d\\eta}=-\\omega_c^2 x$.\n    2.  Independent variable $t$: $\\frac{dx}{dt}=\\frac{u}{a}$, $\\frac{du}{dt}=-\\frac{\\omega_c^2}{a}x$, $\\frac{da}{dt}=a h(a)$.\n    3.  Independent variable $a$: $\\frac{dx}{da}=\\frac{u}{a^2 h(a)}$, $\\frac{du}{da}=-\\frac{\\omega_c^2}{a^2 h(a)}x$.\n-   **Numerical Method**: Explicit second-order Runge–Kutta (midpoint) method for $\\frac{d\\mathbf{y}}{ds}=\\mathbf{F}(s,\\mathbf{y})$:\n    $$\n    \\mathbf{k}_1=\\mathbf{F}(s_n,\\mathbf{y}_n),\\quad \\mathbf{k}_2=\\mathbf{F}\\left(s_n+\\tfrac{1}{2}\\Delta s,\\ \\mathbf{y}_n+\\tfrac{1}{2}\\Delta s\\,\\mathbf{k}_1\\right),\\quad \\mathbf{y}_{n+1}=\\mathbf{y}_n+\\Delta s\\,\\mathbf{k}_2.\n    $$\n-   **Performance Metric**: Maximum relative energy drift $\\delta_{\\max}=\\max_{n}\\left|\\frac{E_c(n)-E_c(0)}{E_c(0)}\\right|$.\n-   **Integration Procedure**: For a given integration range $[a_{\\mathrm{i}}, a_{\\mathrm{f}}]$ and $N$ steps:\n    -   Total integration times $\\Delta t_{\\text{total}} = \\int_{a_{\\mathrm{i}}}^{a_{\\mathrm{f}}} \\frac{da}{a h(a)}$ and $\\Delta \\eta_{\\text{total}} = \\int_{a_{\\mathrm{i}}}^{a_{\\mathrm{f}}} \\frac{da}{a^2 h(a)}$.\n    -   Constant step sizes are $\\Delta t = \\Delta t_{\\text{total}}/N$, $\\Delta \\eta = \\Delta \\eta_{\\text{total}}/N$, and $\\Delta a = (a_{\\mathrm{f}}-a_{\\mathrm{i}})/N$.\n-   **Initial Conditions**: $x(0)=x_0, u(0)=u_0$ at scale factor $a=a_{\\mathrm{i}}$.\n-   **Test Cases**:\n    -   Case 1: $\\Omega_{\\mathrm{m}}=0.3, \\Omega_{\\Lambda}=0.7, a_{\\mathrm{i}}=0.1, a_{\\mathrm{f}}=1.0, \\omega_c=0.5, x_0=1.0, u_0=0.0, N=1000$.\n    -   Case 2: $\\Omega_{\\mathrm{m}}=1.0, \\Omega_{\\Lambda}=0.0, a_{\\mathrm{i}}=0.01, a_{\\mathrm{f}}=0.1, \\omega_c=2.0, x_0=0.2, u_0=0.0, N=1500$.\n    -   Case 3: $\\Omega_{\\mathrm{m}}=0.0, \\Omega_{\\Lambda}=1.0, a_{\\mathrm{i}}=0.5, a_{\\mathrm{f}}=2.0, \\omega_c=0.1, x_0=1.0, u_0=0.0, N=800$.\n-   **Output Format**: Print a single-line list of lists: $[[\\delta_{t,1},\\delta_{\\eta,1},\\delta_{a,1}], [\\delta_{t,2},\\delta_{\\eta,2},\\delta_{a,2}], [\\delta_{t,3},\\delta_{\\eta,3},\\delta_{a,3}]]$.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The problem is based on the standard $\\Lambda$CDM cosmological model and classical mechanics, which are established scientific principles. The equations of motion are textbook derivations for a particle in an expanding universe. The setup is scientifically sound.\n-   **Well-Posedness**: All necessary parameters, initial conditions, and governing equations are explicitly provided for each test case. The numerical method is clearly defined. The task is to execute a well-defined numerical experiment. The problem is well-posed.\n-   **Objectivity**: The problem statement is written in precise, objective mathematical language, free from ambiguity or subjective claims.\n-   **Consistency Check**: The various forms of the equations of motion are consistent with each other via the chain rule and the definitions provided (e.g., $\\frac{dx}{dt} = \\frac{dx}{d\\eta}\\frac{d\\eta}{dt} = u \\cdot \\frac{1}{a}$). The use of the dimensionless Hubble function $h(a)$ in the EOMs like $\\frac{da}{dt}=a h(a)$ implicitly sets the Hubble constant $H_0=1$ in the chosen system of units, a standard practice in theoretical cosmology. Since all equations are given explicitly, this forms a self-contained and consistent system.\n-   **Feasibility**: The parameters chosen are physically representative of different cosmic epochs. The numerical integrations are standard and can be performed with the specified libraries. The problem is feasible.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n### **Principle-Based Design**\n\nThe core of the problem is to compare the numerical stability of three different formulations of the same physical dynamics. The system is a comoving harmonic oscillator, for which comoving energy is a conserved quantity. The accuracy of a numerical integrator can be measured by how well it preserves this invariant. The three formulations use cosmic time $t$, conformal time $\\eta$, and the scale factor $a$ as the independent integration variables.\n\n**1. General Numerical Method: Second-Order Runge-Kutta (Midpoint)**\nA generic function will be implemented for the RK2 midpoint step as defined in the problem. This function will take the right-hand-side (RHS) function $\\mathbf{F}$, the current independent variable value $s$, the state vector $\\mathbf{y}$, and the step size $\\Delta s$, and return the updated state vector.\n\n**2. Integration Strategies**\n\n-   **Strategy I: Integration with respect to Cosmic Time $t$**\n    -   The state vector is $\\mathbf{y} = [x, u, a]$. We must integrate the evolution of the scale factor $a$ alongside the particle's coordinates, as the EOMs for $x$ and $u$ explicitly depend on $a$.\n    -   The system of ODEs is $\\frac{d\\mathbf{y}}{dt} = \\mathbf{F}_t(\\mathbf{y}) = [u/a, -\\omega_c^2 x/a, a h(a)]$. This system is autonomous (the RHS does not explicitly depend on $t$).\n    -   The total integration time $\\Delta t_{\\text{total}}$ is computed by numerically integrating $\\frac{dt}{da} = \\frac{1}{a h(a)}$ from $a_{\\mathrm{i}}$ to $a_{\\mathrm{f}}$. The step size is $\\Delta t = \\Delta t_{\\text{total}} / N$.\n\n-   **Strategy II: Integration with respect to Conformal Time $\\eta$**\n    -   The EOMs in conformal time, $\\frac{dx}{d\\eta}=u$ and $\\frac{du}{d\\eta}=-\\omega_c^2 x$, describe a simple harmonic oscillator. The coefficients are constant.\n    -   The state vector is $\\mathbf{y} = [x, u]$. The ODE system is $\\frac{d\\mathbf{y}}{d\\eta} = \\mathbf{F}_\\eta(\\mathbf{y}) = [u, -\\omega_c^2 x]$. This system is linear, autonomous, and its exact solution lies on an ellipse in phase space, making it an ideal test for an integrator.\n    -   The total integration time $\\Delta \\eta_{\\text{total}}$ is computed by numerically integrating $\\frac{d\\eta}{da} = \\frac{1}{a^2 h(a)}$ from $a_{\\mathrm{i}}$ to $a_{\\mathrm{f}}$. The step size is $\\Delta \\eta = \\Delta \\eta_{\\text{total}} / N$. This choice of variable is expected to yield the highest accuracy due to the simple, time-independent form of the EOMs.\n\n-   **Strategy III: Integration with respect to Scale Factor $a$**\n    -   The state vector is $\\mathbf{y} = [x, u]$.\n    -   The EOMs are $\\frac{d\\mathbf{y}}{da} = \\mathbf{F}_a(a, \\mathbf{y}) = [\\frac{u}{a^2 h(a)}, -\\frac{\\omega_c^2 x}{a^2 h(a)}]$. This system is non-autonomous, as the RHS explicitly depends on the integration variable $a$. This variability in the coefficients can challenge a fixed-step-size integrator.\n    -   The step size is simply $\\Delta a = (a_{\\mathrm{f}} - a_{\\mathrm{i}}) / N$. The integration proceeds in uniform steps of the scale factor.\n\n**3. Implementation Structure**\nA main function will iterate through the three test cases provided. For each case, it will call three separate solver functions, one for each integration strategy. Each solver will:\n1.  Define the specific dimensionless Hubble function $h(a)$ based on the case parameters.\n2.  If necessary, compute the total integration interval (for $t$ and $\\eta$) using `scipy.integrate.quad`.\n3.  Determine the constant step size.\n4.  Initialize the state vector, and calculate the initial comoving energy $E_c(0)$.\n5.  Loop $N$ times, applying the RK2 step at each iteration. Inside the loop, the current comoving energy $E_c(n)$ is computed and the maximum relative drift $\\delta_{\\max}$ is updated.\n6.  Return the final $\\delta_{\\max}$.\n\nThe results from the three strategies for each case will be collected and formatted into the required nested list for the final output.",
            "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the comoving equations of motion using three different integration strategies\n    and computes the maximum relative energy drift for each.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (LCDM)\n        {'Omega_m': 0.3, 'Omega_L': 0.7, 'a_i': 0.1, 'a_f': 1.0, \n         'omega_c': 0.5, 'x0': 1.0, 'u0': 0.0, 'N': 1000},\n        # Case 2 (EdS)\n        {'Omega_m': 1.0, 'Omega_L': 0.0, 'a_i': 0.01, 'a_f': 0.1, \n         'omega_c': 2.0, 'x0': 0.2, 'u0': 0.0, 'N': 1500},\n        # Case 3 (de Sitter)\n        {'Omega_m': 0.0, 'Omega_L': 1.0, 'a_i': 0.5, 'a_f': 2.0, \n         'omega_c': 0.1, 'x0': 1.0, 'u0': 0.0, 'N': 800}\n    ]\n\n    all_results = []\n\n    def rk2_midpoint_step(F, s, y, ds, params):\n        \"\"\"A single RK2 midpoint step.\"\"\"\n        k1 = F(s, y, params)\n        y_mid = y + 0.5 * ds * k1\n        s_mid = s + 0.5 * ds\n        k2 = F(s_mid, y_mid, params)\n        y_next = y + ds * k2\n        return y_next\n\n    # --- RHS functions for the ODEs ---\n    def F_t(t, y, params):\n        x, u, a = y\n        h_func = params['h_func']\n        omega_c = params['omega_c']\n        # Avoid division by zero if a becomes very small, although not expected here.\n        if a == 0:\n            return np.zeros(3)\n        return np.array([u / a, -omega_c**2 * x / a, a * h_func(a)])\n\n    def F_eta(eta, y, params):\n        x, u = y\n        omega_c = params['omega_c']\n        return np.array([u, -omega_c**2 * x])\n\n    def F_a(a, y, params):\n        x, u = y\n        h_func = params['h_func']\n        omega_c = params['omega_c']\n        # Avoid division by zero at a=0.\n        if a == 0:\n            return np.zeros(2)\n        common_factor = 1.0 / (a**2 * h_func(a))\n        return np.array([u * common_factor, -omega_c**2 * x * common_factor])\n\n    # --- Solver for each strategy ---\n    def solve_with_t(params):\n        N, a_i, a_f, x0, u0 = params['N'], params['a_i'], params['a_f'], params['x0'], params['u0']\n        h_func = params['h_func']\n        \n        total_t, _ = integrate.quad(lambda a: 1.0 / (a * h_func(a)), a_i, a_f)\n        dt = total_t / N\n        \n        y = np.array([x0, u0, a_i])\n        \n        E_c_0 = 0.5 * u0**2 + 0.5 * params['omega_c']**2 * x0**2\n        if E_c_0 == 0: return 0.0\n        \n        max_drift = 0.0\n        \n        s = 0.0\n        for _ in range(N):\n            y = rk2_midpoint_step(F_t, s, y, dt, params)\n            s += dt\n            x_n, u_n, _ = y\n            E_c_n = 0.5 * u_n**2 + 0.5 * params['omega_c']**2 * x_n**2\n            drift = abs((E_c_n - E_c_0) / E_c_0)\n            if drift > max_drift:\n                max_drift = drift\n        return max_drift\n\n    def solve_with_eta(params):\n        N, a_i, a_f, x0, u0 = params['N'], params['a_i'], params['a_f'], params['x0'], params['u0']\n        h_func = params['h_func']\n        \n        total_eta, _ = integrate.quad(lambda a: 1.0 / (a**2 * h_func(a)), a_i, a_f)\n        deta = total_eta / N\n        \n        y = np.array([x0, u0])\n        \n        E_c_0 = 0.5 * u0**2 + 0.5 * params['omega_c']**2 * x0**2\n        if E_c_0 == 0: return 0.0\n        \n        max_drift = 0.0\n        \n        s = 0.0\n        for _ in range(N):\n            y = rk2_midpoint_step(F_eta, s, y, deta, params)\n            s += deta\n            x_n, u_n = y\n            E_c_n = 0.5 * u_n**2 + 0.5 * params['omega_c']**2 * x_n**2\n            drift = abs((E_c_n - E_c_0) / E_c_0)\n            if drift > max_drift:\n                max_drift = drift\n        return max_drift\n\n    def solve_with_a(params):\n        N, a_i, a_f, x0, u0 = params['N'], params['a_i'], params['a_f'], params['x0'], params['u0']\n        \n        da = (a_f - a_i) / N\n        \n        y = np.array([x0, u0])\n        \n        E_c_0 = 0.5 * u0**2 + 0.5 * params['omega_c']**2 * x0**2\n        if E_c_0 == 0: return 0.0\n\n        max_drift = 0.0\n        \n        s = a_i\n        for _ in range(N):\n            y = rk2_midpoint_step(F_a, s, y, da, params)\n            s += da\n            x_n, u_n = y\n            E_c_n = 0.5 * u_n**2 + 0.5 * params['omega_c']**2 * x_n**2\n            drift = abs((E_c_n - E_c_0) / E_c_0)\n            if drift > max_drift:\n                max_drift = drift\n        return max_drift\n\n    for case_params in test_cases:\n        Omega_m = case_params['Omega_m']\n        Omega_L = case_params['Omega_L']\n        \n        # Define the dimensionless Hubble function for the current case\n        def h_func(a):\n            return np.sqrt(Omega_m * a**-3 + Omega_L)\n        \n        current_params = case_params.copy()\n        current_params['h_func'] = h_func\n\n        # Calculate drift for each strategy\n        drift_t = solve_with_t(current_params)\n        drift_eta = solve_with_eta(current_params)\n        drift_a = solve_with_a(current_params)\n        \n        all_results.append([drift_t, drift_eta, drift_a])\n    \n    # Format the output string as required\n    result_str = str(all_results).replace(\" \", \"\")\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}