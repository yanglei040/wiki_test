{
    "hands_on_practices": [
        {
            "introduction": "A robust numerical scheme must first and foremost respect the fundamental laws of physics. This practice begins at that foundation, focusing on the principle of detailed balance in thermodynamic equilibrium. You will design and implement a \"uniform bath\" test to verify that numerical models for neutrino-matter interactions—the source terms in the transport equation—correctly preserve an equilibrium neutrino distribution and model relaxation towards it, a critical sanity check for any transport code. ",
            "id": "3524589",
            "problem": "You are asked to design and implement a discrete consistency test for neutrino radiation in a homogeneous, stationary medium that is in thermodynamic equilibrium at temperature $T$ and neutrino chemical potential $\\mu_{\\nu}$. The goal is to verify, in a fully discrete setting, that two commonly used reduced neutrino transport models in computational astrophysics — a leakage energy update and a two-moment scheme with the first-order moment closure (M1) — numerically enforce detailed balance in a uniform bath. You must derive the test design from first principles, implement it, and report quantitative metrics.\n\nYou must base your reasoning on the following foundational principles and well-tested facts:\n- The Boltzmann transport equation reduces, in a spatially uniform and isotropic medium without fluid motion, to an energy-space source-balance relation where emission and absorption compete to change the neutrino energy density.\n- In local thermodynamic equilibrium, detailed balance (Kirchhoff’s law) holds: the emissivity per unit energy group $j$ and the absorption opacity $\\kappa_{a}$ satisfy $j = c\\,\\kappa_{a}\\,B$, where $c$ is the speed of light and $B$ is the equilibrium neutrino energy density per energy group.\n- The first two angular moments of the transport equation (energy density $E$ and flux $F$) form a closed system under an algebraic closure. In a spatially uniform and isotropic state, the divergence terms vanish and scattering acts as a sink for the flux, while absorption couples to both energy density and flux.\n- The Fermi-Dirac (FD) neutrino occupation at energy $\\varepsilon$ with temperature $T$ and chemical potential $\\mu_{\\nu}$ is $f(\\varepsilon;T,\\mu_{\\nu}) = \\left[\\exp\\!\\left((\\varepsilon-\\mu_{\\nu})/T\\right)+1\\right]^{-1}$. Up to a fixed physical constant factor that cancels in the ratios in this problem, the spectral energy density scales as $\\varepsilon^{3} f(\\varepsilon;T,\\mu_{\\nu})$.\n\nYou must consider a discrete energy-group formulation. Let $N_{g}$ be the number of energy groups, linearly spaced in energy from $E_{\\min}$ to $E_{\\max}$, with group centers $\\varepsilon_{g}$ and widths $\\Delta \\varepsilon_{g}$. Define the discrete equilibrium energy density per group by\n$$\nB_{g} \\propto \\varepsilon_{g}^{3}\\, \\left[\\exp\\!\\left((\\varepsilon_{g}-\\mu_{\\nu})/T\\right)+1\\right]^{-1} \\, \\Delta \\varepsilon_{g},\n$$\nwhere the proportionality constant is irrelevant because all requested outputs are dimensionless ratios. You must use energy units of mega-electron volts (MeV) for $\\varepsilon$, $T$, and $\\mu_{\\nu}$ in constructing $B_{g}$; however, your final reported metrics must be dimensionless floats as specified below.\n\nAdopt an opacity model with absorption opacity\n$$\n\\kappa_{a,g} = \\kappa_{0}\\,\\left(\\frac{\\varepsilon_{g}}{10\\,\\mathrm{MeV}}\\right)^{2},\n$$\nand (isotropic) scattering opacity\n$$\n\\kappa_{s,g} = \\sigma_{0}\\,\\left(\\frac{\\varepsilon_{g}}{10\\,\\mathrm{MeV}}\\right)^{2},\n$$\nwith $c$ the speed of light. Take $c = 2.99792458\\times 10^{10}\\,\\mathrm{cm}\\,\\mathrm{s}^{-1}$, $\\kappa_{0}$ and $\\sigma_{0}$ in $\\mathrm{cm}^{-1}$, and time step $\\Delta t$ in $\\mathrm{s}$. The final answers you must report are dimensionless and require no unit conversion.\n\nDefine two time-discrete uniform-bath update models:\n- Leakage energy update per group $g$:\n$$\nE_{g}^{n+1} = E_{g}^{n} + \\Delta t \\left(j_{g} - c\\,\\kappa_{a,g}\\,E_{g}^{n}\\right),\n$$\nwith $j_{g}$ prescribed so that discrete Kirchhoff’s law holds at equilibrium, i.e., $j_{g} = c\\,\\kappa_{a,g}\\,B_{g}$.\n- Two-moment (M1) update per group $g$ for energy density $E_{g}$ and flux $F_{g}$:\n$$\nE_{g}^{n+1} = E_{g}^{n} + \\Delta t \\left(j_{g} - c\\,\\kappa_{a,g}\\,E_{g}^{n}\\right),\n\\qquad\nF_{g}^{n+1} = F_{g}^{n} - \\Delta t\\, c \\left(\\kappa_{a,g} + \\kappa_{s,g}\\right) F_{g}^{n},\n$$\ncorresponding to a spatially uniform, isotropic state with no flux divergence. The algebraic closure reduces to isotropic pressure and is not needed explicitly in this spatially uniform setting, but you must still justify why the above system follows from the closed moment equations.\n\nYou must implement a numerical test suite that exercises and validates the following discrete detailed-balance properties:\n- Equilibrium invariance under leakage: with initial $E_{g}^{0}=B_{g}$ for all $g$, the leakage update should leave $E_{g}$ unchanged to within floating-point roundoff.\n- Equilibrium invariance under M1: with initial $E_{g}^{0}=B_{g}$ and $F_{g}^{0}=0$ for all $g$, the M1 update should leave $E_{g}$ unchanged and damp $F_{g}$ to remain near zero to within floating-point roundoff.\n- Relaxation of a small energy perturbation under leakage: with initial $E_{g}^{0}=(1+\\epsilon)\\,B_{g}$ for a small $\\epsilon$, the exact ordinary differential equation (ODE) solution predicts $E_{g}(t)-B_{g} = (E_{g}(0)-B_{g}) \\exp\\!\\left(-c\\,\\kappa_{a,g}\\,t\\right)$. Your explicit time stepping must approximate this exponential relaxation. Report the maximum relative error across groups.\n- Relaxation of a small flux perturbation under M1: with initial $E_{g}^{0}=B_{g}$ and $F_{g}^{0}=\\phi\\,c\\,B_{g}$ for a small $\\phi$, the exact ODE solution predicts $F_{g}(t) = F_{g}(0)\\,\\exp\\!\\left(-c\\,(\\kappa_{a,g}+\\kappa_{s,g})\\,t\\right)$. Your explicit time stepping must approximate this exponential relaxation. Report the maximum relative error across groups.\n\nUse the following parameter values as the test suite. All energies are in MeV, $\\kappa_{0}$ and $\\sigma_{0}$ are in $\\mathrm{cm}^{-1}$, $c$ is in $\\mathrm{cm}\\,\\mathrm{s}^{-1}$, and time in $\\mathrm{s}$. The reported outputs must be dimensionless floats:\n- Test parameters common to all cases:\n  - Number of groups $N_{g} = 8$.\n  - Energy range $E_{\\min} = 0.5$, $E_{\\max} = 60$.\n  - Absorption scale $\\kappa_{0} = 1.0\\times 10^{-8}$.\n  - Scattering scale $\\sigma_{0} = 5.0\\times 10^{-8}$.\n  - Time step $\\Delta t = 1.0\\times 10^{-7}$.\n  - Number of steps $N_{\\mathrm{steps}} = 30000$ so total evolution time is $t_{\\mathrm{final}} = N_{\\mathrm{steps}}\\Delta t$.\n- Case $1$ (equilibrium invariance, leakage): $T=4.0$, $\\mu_{\\nu}=3.0$. Initialize $E_{g}^{0}=B_{g}$.\n- Case $2$ (equilibrium invariance, M1): $T=4.0$, $\\mu_{\\nu}=3.0$. Initialize $E_{g}^{0}=B_{g}$ and $F_{g}^{0}=0$.\n- Case $3$ (perturbation decay, leakage): $T=4.0$, $\\mu_{\\nu}=3.0$. Initialize $E_{g}^{0}=(1+\\epsilon)\\,B_{g}$ with $\\epsilon=0.1$.\n- Case $4$ (perturbation decay, M1): $T=4.0$, $\\mu_{\\nu}=3.0$. Initialize $E_{g}^{0}=B_{g}$ and $F_{g}^{0}=\\phi\\,c\\,B_{g}$ with $\\phi=0.1$.\n\nYour program must compute and report the following four dimensionless floats, in this order:\n- For Case $1$: the maximum relative drift after $N_{\\mathrm{steps}}$ steps under the leakage update, defined as $\\max_{g}\\left|E_{g}^{N_{\\mathrm{steps}}}-B_{g}\\right|/B_{g}$.\n- For Case $2$: the maximum relative drift after $N_{\\mathrm{steps}}$ steps under the M1 update, defined as $\\max_{g}\\left|E_{g}^{N_{\\mathrm{steps}}}-B_{g}\\right|/B_{g}$.\n- For Case $3$: the maximum relative error in the leakage perturbation decay relative to the exact exponential, defined as\n$$\n\\max_{g}\\left|\\frac{\\left(E_{g}^{N_{\\mathrm{steps}}}-B_{g}\\right)}{\\left(E_{g}^{0}-B_{g}\\right)} - \\exp\\!\\left(-c\\,\\kappa_{a,g}\\,t_{\\mathrm{final}}\\right)\\right|\\Big/\\exp\\!\\left(-c\\,\\kappa_{a,g}\\,t_{\\mathrm{final}}\\right).\n$$\n- For Case $4$: the maximum relative error in the M1 flux decay relative to the exact exponential, defined as\n$$\n\\max_{g}\\left|\\frac{F_{g}^{N_{\\mathrm{steps}}}}{F_{g}^{0}} - \\exp\\!\\left(-c\\,(\\kappa_{a,g}+\\kappa_{s,g})\\,t_{\\mathrm{final}}\\right)\\right|\\Big/\\exp\\!\\left(-c\\,(\\kappa_{a,g}+\\kappa_{s,g})\\,t_{\\mathrm{final}}\\right).\n$$\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). Each result must be a floating-point number.\n\nNo user input is permitted. All calculations must be self-contained and reproducible. The use of any external data is forbidden. All quantities in the reported outputs must be dimensionless floats as defined above.",
            "solution": "The problem requires the design and implementation of a numerical test to verify that two simplified neutrino transport schemes—a leakage model and a two-moment (M1) model—correctly enforce the principle of detailed balance in a discrete setting. The context is a homogeneous, stationary medium in thermodynamic equilibrium at a given temperature $T$ and neutrino chemical potential $\\mu_{\\nu}$.\n\nThe fundamental principle governing the evolution of the neutrino radiation field is the Boltzmann transport equation. For a spatially uniform and isotropic medium with no fluid motion, the equation simplifies significantly. The change in the neutrino energy distribution is driven by the balance between emission and absorption processes. This can be expressed for each energy group $g$ as an ordinary differential equation (ODE) for the radiation energy density $E_{g}$:\n$$\n\\frac{dE_{g}}{dt} = \\mathcal{S}_{g}(E_{g})\n$$\nwhere $\\mathcal{S}_{g}$ represents the net source term due to interactions. In this problem, the source term is composed of emission $j_{g}$ and absorption, leading to:\n$$\n\\frac{dE_{g}}{dt} = j_{g} - c\\,\\kappa_{a,g}\\,E_{g}\n$$\nHere, $c$ is the speed of light and $\\kappa_{a,g}$ is the absorption opacity for group $g$.\n\nIn local thermodynamic equilibrium (LTE), the principle of detailed balance, also known as Kirchhoff's law, dictates that the rate of emission must equal the rate of absorption. The system is characterized by an equilibrium radiation energy density, $B_{g}$, for each group. At equilibrium ($E_{g} = B_{g}$), the net source term must vanish, $\\frac{dE_{g}}{dt} = 0$. This implies a specific relationship between emissivity and absorptivity:\n$$\nj_{g} - c\\,\\kappa_{a,g}\\,B_{g} = 0 \\implies j_{g} = c\\,\\kappa_{a,g}\\,B_{g}\n$$\nThis relation is central to the test design.\n\nThe equilibrium energy density $B_{g}$ is determined by the properties of the medium, specifically its temperature $T$ and neutrino chemical potential $\\mu_{\\nu}$. It is derived from the Fermi-Dirac distribution, which describes the statistical occupation of fermion states. For a discrete energy group $g$ with center $\\varepsilon_{g}$ and width $\\Delta\\varepsilon_{g}$, the equilibrium energy density is given by:\n$$\nB_{g} \\propto \\varepsilon_{g}^{3}\\, f(\\varepsilon_{g}; T, \\mu_{\\nu}) \\, \\Delta\\varepsilon_{g} = \\varepsilon_{g}^{3}\\, \\left[\\exp\\!\\left(\\frac{\\varepsilon_{g}-\\mu_{\\nu}}{T}\\right)+1\\right]^{-1} \\, \\Delta\\varepsilon_{g}\n$$\nThe proportionality constant is irrelevant for the dimensionless ratios required as output. The opacities for absorption and scattering are modeled with a quadratic dependence on energy:\n$$\n\\kappa_{a,g} = \\kappa_{0}\\,\\left(\\frac{\\varepsilon_{g}}{10\\,\\mathrm{MeV}}\\right)^{2}, \\qquad \\kappa_{s,g} = \\sigma_{0}\\,\\left(\\frac{\\varepsilon_{g}}{10\\,\\mathrm{MeV}}\\right)^{2}\n$$\n\nWe will now describe the two numerical schemes and the test cases.\n\n**1. Leakage Energy Update Scheme**\n\nThis is a simplified model focusing only on the evolution of energy density due to emission and absorption. A forward Euler time discretization of the energy balance ODE yields the update rule:\n$$\nE_{g}^{n+1} = E_{g}^{n} + \\Delta t \\left(j_{g} - c\\,\\kappa_{a,g}\\,E_{g}^{n}\\right)\n$$\nSubstituting the detailed balance condition for emissivity, $j_{g} = c\\,\\kappa_{a,g}\\,B_{g}$, we get:\n$$\nE_{g}^{n+1} = E_{g}^{n} + \\Delta t \\, c\\,\\kappa_{a,g}\\left(B_{g} - E_{g}^{n}\\right)\n$$\nThis scheme is first-order accurate in time.\n\n**2. Two-Moment (M1) Scheme**\n\nThe M1 scheme evolves the first two angular moments of the radiation field: the energy density $E_{g}$ (zeroth moment) and the radiation flux $F_{g}$ (first moment). In a spatially uniform medium, the divergence terms $\\nabla \\cdot \\mathbf{F}_g$ and $\\nabla \\cdot \\mathbf{P}_g$ (where $\\mathbf{P}_g$ is the pressure tensor) in the moment equations vanish. The resulting system of ODEs is:\n$$\n\\frac{dE_{g}}{dt} = j_{g} - c\\,\\kappa_{a,g}\\,E_{g}\n$$\n$$\n\\frac{dF_{g}}{dt} = -c \\left(\\kappa_{a,g} + \\kappa_{s,g}\\right) F_{g}\n$$\nThe energy equation is identical to that of the leakage model. Isotropic scattering does not change the energy density $E_g$ but acts as a sink for the flux $F_g$, driving the radiation field towards isotropy. Applying a forward Euler discretization to this system gives the M1 update rules for a uniform medium:\n$$\nE_{g}^{n+1} = E_{g}^{n} + \\Delta t \\left(j_{g} - c\\,\\kappa_{a,g}\\,E_{g}^{n}\\right) = E_{g}^{n} + \\Delta t \\, c\\,\\kappa_{a,g}\\left(B_{g} - E_{g}^{n}\\right)\n$$\n$$\nF_{g}^{n+1} = F_{g}^{n} - \\Delta t\\, c \\left(\\kappa_{a,g} + \\kappa_{s,g}\\right) F_{g}^{n}\n$$\n\n**Numerical Test Suite Design and Implementation**\n\nThe implementation follows a systematic procedure. First, we define the physical constants and numerical parameters. An energy grid with $N_{g}=8$ groups is constructed with centers $\\varepsilon_g$ linearly spaced between $E_{\\min}=0.5\\,\\mathrm{MeV}$ and $E_{\\max}=60\\,\\mathrm{MeV}$. We then compute the opacity arrays $\\kappa_{a,g}$ and $\\kappa_{s,g}$ and the equilibrium energy density array $B_{g}$ for the given $T=4.0\\,\\mathrm{MeV}$ and $\\mu_{\\nu}=3.0\\,\\mathrm{MeV}$.\n\n**Case 1: Equilibrium Invariance (Leakage)**\nWe initialize the system at equilibrium, $E_{g}^{0}=B_{g}$. The discrete update equation becomes $E_{g}^{n+1} = B_{g} + \\Delta t \\, c\\,\\kappa_{a,g}(B_g - B_g) = B_g$. Analytically, the state should remain unchanged. The numerical test evolves the system for $N_{\\mathrm{steps}}=30000$ steps and measures the maximum relative deviation from the initial equilibrium state, $\\max_{g}\\left|E_{g}^{N_{\\mathrm{steps}}}-B_{g}\\right|/B_{g}$. This deviation should be on the order of machine floating-point precision.\n\n**Case 2: Equilibrium Invariance (M1)**\nWe initialize the system at equilibrium, $E_g^0 = B_g$ and $F_g^0=0$. As in Case 1, the energy density should remain unchanged. The flux update is $F_{g}^{n+1} = 0 - \\Delta t\\, c (\\kappa_{a,g} + \\kappa_{s,g}) \\cdot 0 = 0$. The M1 scheme should preserve the equilibrium state $(E_g, F_g) = (B_g, 0)$. The test measures the maximum relative drift in energy density, $\\max_{g}\\left|E_{g}^{N_{\\mathrm{steps}}}-B_{g}\\right|/B_{g}$.\n\n**Case 3: Perturbation Decay (Leakage)**\nTo test the dynamics of relaxation towards equilibrium, we introduce a small perturbation. We initialize $E_{g}^{0}=(1+\\epsilon)\\,B_{g}$ with $\\epsilon=0.1$. The governing ODE for the perturbation $\\delta E_g(t) = E_g(t) - B_g$ is $\\frac{d(\\delta E_g)}{dt} = -c\\,\\kappa_{a,g}\\,\\delta E_g$. The exact solution is $\\delta E_g(t) = \\delta E_g(0) \\exp(-c\\,\\kappa_{a,g}\\,t)$. This gives a decay factor of $\\frac{E_{g}(t)-B_{g}}{E_{g}(0)-B_{g}} = \\exp(-c\\,\\kappa_{a,g}\\,t)$. The test compares the numerical decay factor after $N_{\\mathrm{steps}}$ steps with this analytical solution. The metric is the maximum relative error across all groups:\n$$\n\\max_{g}\\left|\\frac{\\left(E_{g}^{N_{\\mathrm{steps}}}-B_{g}\\right)}{\\left(E_{g}^{0}-B_{g}\\right)} - \\exp\\!\\left(-c\\,\\kappa_{a,g}\\,t_{\\mathrm{final}}\\right)\\right|\\Big/\\exp\\!\\left(-c\\,\\kappa_{a,g}\\,t_{\\mathrm{final}}\\right)\n$$\nwhere $t_{\\mathrm{final}} = N_{\\mathrm{steps}}\\Delta t$. This metric quantifies the discretization error of the forward Euler scheme.\n\n**Case 4: Perturbation Decay (M1)**\nHere we test the damping of a non-equilibrium flux. We initialize $E_{g}^{0}=B_{g}$ and introduce a small flux $F_{g}^{0}=\\phi\\,c\\,B_{g}$ with $\\phi=0.1$. The energy remains in equilibrium (in the continuous limit), while the flux decays according to $\\frac{dF_g}{dt} = -c (\\kappa_{a,g} + \\kappa_{s,g}) F_g$. The exact solution is $F_g(t) = F_g(0) \\exp(-c(\\kappa_{a,g}+\\kappa_{s,g})t)$. The test compares the numerical flux decay factor $F_{g}^{N_{\\mathrm{steps}}}/F_{g}^{0}$ to the analytical factor $\\exp(-c(\\kappa_{a,g}+\\kappa_{s,g})t_{\\mathrm{final}})$. The metric is the maximum relative error:\n$$\n\\max_{g}\\left|\\frac{F_{g}^{N_{\\mathrm{steps}}}}{F_{g}^{0}} - \\exp\\!\\left(-c\\,(\\kappa_{a,g}+\\kappa_{s,g})\\,t_{\\mathrm{final}}\\right)\\right|\\Big/\\exp\\!\\left(-c\\,(\\kappa_{a,g}+\\kappa_{s,g})\\,t_{\\mathrm{final}}\\right)\n$$\nThis tests the M1 scheme's ability to correctly model flux damping in an optically thick, static medium. The combined results from these four tests provide a quantitative validation of the discrete schemes' consistency with fundamental physical principles.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and implements a discrete consistency test for neutrino radiation\n    in a homogeneous, stationary medium in thermodynamic equilibrium.\n    \"\"\"\n    \n    # Common test parameters\n    c_light = 2.99792458e10  # cm/s\n    Ng = 8                   # Number of energy groups\n    E_min = 0.5              # MeV\n    E_max = 60.0             # MeV\n    kappa0 = 1.0e-8          # cm^-1\n    sigma0 = 5.0e-8          # cm^-1\n    dt = 1.0e-7              # s\n    N_steps = 30000          # Number of time steps\n    t_final = N_steps * dt\n\n    # Case-specific parameters\n    T = 4.0   # MeV\n    mu_nu = 3.0 # MeV\n    epsilon = 0.1\n    phi = 0.1\n    \n    # --- Setup: Energy Grid, Opacities, Equilibrium State ---\n    \n    # 1. Energy grid\n    d_eps = (E_max - E_min) / Ng\n    eps_g = E_min + (np.arange(Ng) + 0.5) * d_eps\n\n    # 2. Opacities\n    eps_ratio_sq = (eps_g / 10.0)**2\n    kappa_a_g = kappa0 * eps_ratio_sq\n    kappa_s_g = sigma0 * eps_ratio_sq\n\n    # 3. Equilibrium energy density (proportionality constant = 1)\n    # The exponential term can be large, but numpy handles it.\n    fd_factor = 1.0 / (np.exp((eps_g - mu_nu) / T) + 1.0)\n    B_g = eps_g**3 * fd_factor * d_eps\n\n    results = []\n\n    # --- Case 1: Equilibrium Invariance, Leakage ---\n    E_g = np.copy(B_g)\n    # The analytical solution is E_g(t) = B_g for all t.\n    # Due to floating point arithmetic, small deviations may occur.\n    # The source term becomes c*kappa_a_g*(B_g - E_g).\n    # If E_g = B_g exactly, the update is zero.\n    # We run the loop to accumulate potential round-off errors.\n    for _ in range(N_steps):\n        source = c_light * kappa_a_g * (B_g - E_g)\n        E_g += dt * source\n    \n    # Handle the unlikely case of B_g being zero\n    # This won't happen for the given parameters, but it is good practice\n    # All B_g  0 here.\n    rel_drift_leakage = np.max(np.abs(E_g - B_g) / B_g)\n    results.append(rel_drift_leakage)\n\n    # --- Case 2: Equilibrium Invariance, M1 ---\n    E_g = np.copy(B_g)\n    F_g = np.zeros(Ng, dtype=np.float64) # F_g^0 = 0\n    \n    for _ in range(N_steps):\n        # Energy update\n        source_E = c_light * kappa_a_g * (B_g - E_g)\n        E_g += dt * source_E\n        # Flux update\n        source_F = -c_light * (kappa_a_g + kappa_s_g) * F_g\n        F_g += dt * source_F\n        \n    rel_drift_m1_E = np.max(np.abs(E_g - B_g) / B_g)\n    results.append(rel_drift_m1_E)\n\n    # --- Case 3: Perturbation Decay, Leakage ---\n    E_g_0 = (1.0 + epsilon) * B_g\n    E_g = np.copy(E_g_0)\n\n    for _ in range(N_steps):\n        source = c_light * kappa_a_g * (B_g - E_g)\n        E_g += dt * source\n    \n    numerical_decay_factor = (E_g - B_g) / (E_g_0 - B_g)\n    analytical_decay_factor = np.exp(-c_light * kappa_a_g * t_final)\n    \n    # Relative error, guard against division by zero if analytical factor is tiny\n    # For given parameters, exp() does not underflow to exactly 0.\n    rel_err_leakage_decay = np.max(np.abs(numerical_decay_factor - analytical_decay_factor) / analytical_decay_factor)\n    results.append(rel_err_leakage_decay)\n\n    # --- Case 4: Perturbation Decay, M1 Flux ---\n    E_g = np.copy(B_g) # Not part of the test metric, but for completeness\n    F_g_0 = phi * c_light * B_g\n    F_g = np.copy(F_g_0)\n\n    for _ in range(N_steps):\n        # Flux update\n        source_F = -c_light * (kappa_a_g + kappa_s_g) * F_g\n        F_g += dt * source_F\n        # Energy update (would stay at B_g)\n        # source_E = c_light * kappa_a_g * (B_g - E_g)\n        # E_g += dt * source_E\n\n    numerical_decay_factor_flux = F_g / F_g_0\n    analytical_decay_factor_flux = np.exp(-c_light * (kappa_a_g + kappa_s_g) * t_final)\n\n    rel_err_m1_flux_decay = np.max(np.abs(numerical_decay_factor_flux - analytical_decay_factor_flux) / analytical_decay_factor_flux)\n    results.append(rel_err_m1_flux_decay)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having examined the interaction terms, we now turn to the heart of the M1 moment method: the algebraic closure relation. This practice explores how to express the pressure tensor (the second angular moment) in terms of the energy density and flux (the zeroth and first moments). You will implement the physically-motivated Levermore-Pomraning closure and test its adherence to \"realizability\" constraints, which ensure the moments can always be mapped to a non-negative underlying neutrino distribution function. ",
            "id": "3524590",
            "problem": "Consider neutrino radiation transport approximated by the first two angular moments of the transport equation (M1). Let the neutrino specific intensity be a nonnegative function over direction, and define the lab-frame angular moments as follows: the energy density $E$, the flux vector $\\mathbf{F}$, and the radiation pressure tensor $\\mathbf{P}$. The reduced flux or flux factor is defined by $f(\\mathbf{x}) = \\lVert \\mathbf{F}(\\mathbf{x}) \\rVert / (c\\, E(\\mathbf{x}))$, where $c$ is the speed of light. In M1 closures that are rotationally symmetric about the flux direction, the radiation pressure tensor obeys $\\mathbf{P} = \\mathbf{D} E$, where the Eddington tensor $\\mathbf{D}$ depends on a scalar Eddington factor $\\chi(\\mathbf{x})$ and the unit vector $\\hat{\\mathbf{n}}(\\mathbf{x}) = \\mathbf{F}(\\mathbf{x})/\\lVert\\mathbf{F}(\\mathbf{x})\\rVert$. Specifically, one writes $\\mathbf{D} = \\frac{1-\\chi}{2}\\mathbf{I} + \\frac{3\\chi - 1}{2}\\,\\hat{\\mathbf{n}}\\otimes\\hat{\\mathbf{n}}$, where $\\mathbf{I}$ is the identity tensor.\n\nStarting from the fundamental definitions of angular moments and using only well-tested inequalities for integrals of nonnegative functions, it is known that for any realizable moment set the reduced flux must satisfy $0 \\le f \\le 1$ and the parallel Eddington factor must satisfy $f^2 \\le \\chi \\le 1$. A physically motivated closure must recover the isotropic limit (optically thick) with $\\chi \\to 1/3$ as $f \\to 0$ and the free-streaming limit with $\\chi \\to 1$ as $f \\to 1$, and maintain monotonicity of $\\chi$ in $f$.\n\nTask: Given a discrete grid of values of the reduced flux $f(\\mathbf{x})$ (dimensionless), implement a physically motivated M1 closure to compute the corresponding $\\chi(\\mathbf{x})$ field, and evaluate whether the resulting closure satisfies the realizability constraints $0 \\le f \\le 1$ and $f^2 \\le \\chi \\le 1$ everywhere on the grid. If any grid point violates the constraints, the test case is deemed non-realizable; otherwise it is realizable. Use the speed of light $c$ only as a scaling factor for the definition of $f$, but since $f$ is provided directly and is dimensionless, $c$ need not appear numerically in the computation.\n\nClosure to use: Implement the Levermore-Pomraning variable Eddington factor closure derived from relativistic kinetic theory and maximum entropy considerations, which satisfies the isotropic and free-streaming limits and preserves realizability. The necessary functional dependence $\\chi(f)$ is derived in the solution.\n\nNumerical tolerance: To account for floating-point round-off, treat comparisons to bounds with a tolerance $\\varepsilon = 10^{-12}$. That is, accept $f \\ge -\\varepsilon$, $f \\le 1+\\varepsilon$, and for computed $\\chi$, accept $f^2 - \\varepsilon \\le \\chi \\le 1+\\varepsilon$.\n\nInput specification: There is no input. Your program must internally define the following test suite of flux-factor grids:\n\n- Test case 1 (happy path, mixed values well within bounds): a $4\\times 4$ grid\n$$\n\\begin{bmatrix}\n0.05  0.25  0.50  0.75 \\\\\n0.10  0.30  0.60  0.90 \\\\\n0.20  0.40  0.70  0.95 \\\\\n0.00  0.15  0.85  1.00\n\\end{bmatrix}\n$$\n\n- Test case 2 (violations: negative and greater than unity entries): a $3\\times 3$ grid\n$$\n\\begin{bmatrix}\n-10^{-10}  0.0  0.2 \\\\\n0.9999999999  1.0  1.0000000001 \\\\\n0.5  0.8  1.2\n\\end{bmatrix}\n$$\n\n- Test case 3 (random but reproducible values strictly within $[0,1]$): a $5\\times 5$ grid formed by sampling a pseudorandom number generator with seed $42$ and taking independent uniform samples on $[0,1]$.\n\n- Test case 4 (near-free-streaming edge): a $3\\times 3$ grid with all entries equal to $0.999999999999$.\n\n- Test case 5 (near-isotropic edge with tiny numerical noise): a $3\\times 3$ grid\n$$\n\\begin{bmatrix}\n-10^{-16}  10^{-16}  0.0 \\\\\n10^{-14}  10^{-12}  10^{-10} \\\\\n0.0  10^{-9}  10^{-8}\n\\end{bmatrix}\n$$\n\nOutput specification: For each test case, produce a boolean indicating whether the closure is realizable everywhere on the grid according to the constraints above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). No other output is permitted. All quantities are dimensionless, so no unit conversion is required.",
            "solution": "The task is to implement the Levermore-Pomraning moment closure for neutrino transport and verify its realizability on several grids of the reduced flux factor, $f$.\n\n#### The Levermore-Pomraning M1 Closure\nThe M1 closure problem aims to express the Eddington factor $\\chi$ as a function of the reduced flux $f$, i.e., $\\chi = \\chi(f)$. This closes the system of moment equations. The Levermore-Pomraning closure is derived by maximizing the entropy of the radiation field, which is a principle borrowed from statistical mechanics. This procedure yields a specific functional form for the underlying neutrino distribution function, from which the moments $E$, $\\mathbf{F}$, and $\\mathbf{P}$ can be calculated. Eliminating the parameters of the distribution in favor of the moments leads to the desired closure relation. For a relativistic gas, this relation is:\n$$\n\\chi(f) = \\frac{3 + 4f^2}{5 + 2\\sqrt{4 - 3f^2}}\n$$\nThis function is defined for $4 - 3f^2 \\ge 0$, which implies $f^2 \\le 4/3$, or $|f| \\le 2/\\sqrt{3} \\approx 1.1547$. This domain comfortably includes the physical range of interest, $f \\in [0, 1]$.\n\n#### Verification of Physical Properties\nA physically sound closure must satisfy several key properties, which we verify for the Levermore-Pomraning formula.\n\n1.  **Isotropic Limit**: As the medium becomes optically thick, scattering isotropizes the radiation field, the flux vanishes, so $f \\to 0$. The pressure should become isotropic, $P_{ij} = (E/3)\\delta_{ij}$, which implies $\\chi \\to 1/3$.\n$$\n\\lim_{f \\to 0} \\chi(f) = \\frac{3 + 4(0)^2}{5 + 2\\sqrt{4 - 3(0)^2}} = \\frac{3}{5 + 2\\sqrt{4}} = \\frac{3}{5+4} = \\frac{3}{9} = \\frac{1}{3}\n$$\nThe limit is correctly recovered.\n\n2.  **Free-Streaming Limit**: In a vacuum or optically thin medium, neutrinos stream in a single direction. The flux magnitude approaches its maximum possible value, $cE$, so $f \\to 1$. In this limit, the pressure tensor becomes $P_{ij} = E \\hat{n}_i \\hat{n}_j$, which implies $\\chi \\to 1$.\n$$\n\\lim_{f \\to 1} \\chi(f) = \\frac{3 + 4(1)^2}{5 + 2\\sqrt{4 - 3(1)^2}} = \\frac{3+4}{5 + 2\\sqrt{1}} = \\frac{7}{7} = 1\n$$\nThis limit is also correctly recovered.\n\n3.  **Realizability**: The closure must respect the fundamental constraints $f^2 \\le \\chi(f) \\le 1$ for all $f \\in [0, 1]$.\n    *   **Upper Bound ($\\chi \\le 1$)**: We have shown $\\chi(1)=1$. We can show that $\\chi(f)$ is monotonically increasing for $f \\in [0,1]$. Its derivative is $\\chi'(f) = \\frac{f \\left( 48 + 8\\sqrt{4-3f^2} + \\frac{18+24f^2}{\\sqrt{4-3f^2}} \\right)}{(5+2\\sqrt{4-3f^2})^2}$. For $f \\in [0,1)$, all terms are positive, so $\\chi'(f) \\ge 0$. Since the function increases from $\\chi(0)=1/3$ to $\\chi(1)=1$, the upper bound $\\chi(f) \\le 1$ is satisfied for $f \\in [0,1]$.\n    *   **Lower Bound ($\\chi \\ge f^2$)**: We need to prove $\\frac{3 + 4f^2}{5 + 2\\sqrt{4 - 3f^2}} \\ge f^2$. Since both sides are positive for $f \\in (0,1]$, we can manipulate the inequality:\n$$\n3 + 4f^2 \\ge 5f^2 + 2f^2\\sqrt{4 - 3f^2}\n$$\n$$\n3 - f^2 \\ge 2f^2\\sqrt{4 - 3f^2}\n$$\nFor $f \\in [0,1]$, the left side $3-f^2$ is positive. We can square both sides:\n$$\n(3-f^2)^2 \\ge 4f^4(4-3f^2)\n$$\n$$\n9 - 6f^2 + f^4 \\ge 16f^4 - 12f^6\n$$\n$$\n12f^6 - 15f^4 - 6f^2 + 9 \\ge 0\n$$\nLet $y=f^2$, where $y \\in [0,1]$. The inequality becomes $12y^3 - 15y^2 - 6y + 9 \\ge 0$. We can factor this polynomial. Notice that $y=1$ is a root: $12-15-6+9=0$. Dividing by $(y-1)$ yields $12y^2-3y-9$. Factoring again, $y=1$ is a root of this quadratic: $12-3-9=0$. Dividing $12y^2-3y-9$ by $(y-1)$ gives $12y+9$. So, the polynomial is $ (y-1)^2(12y+9) = 3(y-1)^2(4y+3) $.\nThe inequality is $3(f^2-1)^2(4f^2+3) \\ge 0$. The terms $(f^2-1)^2$ and $(4f^2+3)$ are both non-negative for any real $f$. Thus, the inequality holds, and the lower bound $\\chi(f) \\ge f^2$ is satisfied.\n\n#### Algorithmic Implementation and Test Case Analysis\nThe verification process for each grid of $f$ values involves a point-wise check. Let $\\varepsilon = 10^{-12}$ be the specified tolerance. For each value $f_{ij}$ in a given grid:\n\n1.  **Input Validation**: Check if $f_{ij}$ is within the allowed numerical range. The condition is $f_{ij} \\ge -\\varepsilon$ and $f_{ij} \\le 1+\\varepsilon$. If any $f_{ij}$ on the grid violates this, the entire test case is deemed non-realizable.\n\n2.  **Closure Calculation**: If $f_{ij}$ is valid, compute $\\chi_{ij}$ using the Levermore-Pomraning formula. The argument of the square root, $4 - 3f_{ij}^2$, is guaranteed to be non-negative for all valid inputs, since the maximum allowed $f_{ij}$ is $1+\\varepsilon$, and $4 - 3(1+\\varepsilon)^2 \\approx 4 - 3(1+2\\varepsilon) = 1-6\\varepsilon > 0$.\n\n3.  **Output Validation**: Check if the computed $\\chi_{ij}$ satisfies the realizability conditions with tolerance. The conditions are $\\chi_{ij} \\ge f_{ij}^2 - \\varepsilon$ and $\\chi_{ij} \\le 1+\\varepsilon$.\n\nOur analysis proved that for any $f \\in [0,1]$, the closure automatically produces a realizable $\\chi$. It can be further shown that this holds even for the small perturbations allowed by the tolerance, i.e., for $f \\in [-\\varepsilon, 1+\\varepsilon]$. Therefore, a test case will be realizable if and only if all its input $f$ values satisfy the condition from Step 1.\n\n- **Test Case 1**: All values lie in $[0.00, 1.00]$. These are all valid. Result: **Realizable**.\n- **Test Case 2**: Contains several invalid values.\n    - $f = -10^{-10}$. We check $-10^{-10} \\ge -\\varepsilon \\implies -10^{-10} \\ge -10^{-12}$. This is false, since $10^{-10} > 10^{-12}$. Thus, this input is invalid.\n    - $f = 1.0000000001 = 1 + 10^{-10}$. We check $1+10^{-10} \\le 1+\\varepsilon \\implies 1+10^{-10} \\le 1+10^{-12}$. This is also false.\n    The presence of these invalid inputs makes the grid non-realizable. Result: **Non-realizable**.\n- **Test Case 3**: Random values are sampled from $[0,1]$, so all are valid. Result: **Realizable**.\n- **Test Case 4**: The value $f = 0.999999999999 = 1 - 10^{-12}$ is clearly within the valid range. Result: **Realizable**.\n- **Test Case 5**: Contains small values near zero.\n    - $f = -10^{-16}$. We check $-10^{-16} \\ge -\\varepsilon \\implies -10^{-16} \\ge -10^{-12}$. This is true, since $10^{-16}  10^{-12}$. This value is valid.\n    All other values in the grid, such as $10^{-16}$, $10^{-14}$, etc., are also within $[-\\varepsilon, 1+\\varepsilon]$. Since all inputs are valid, the test case is realizable. Result: **Realizable**.\n\nThe expected boolean outcomes for the five test cases are: `[True, False, True, True, True]`.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Levermore-Pomraning M1 closure and validates realizability\n    for a suite of test cases according to the problem description.\n    \"\"\"\n\n    # Define the numerical tolerance.\n    epsilon = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_case_1 = np.array([\n        [0.05, 0.25, 0.50, 0.75],\n        [0.10, 0.30, 0.60, 0.90],\n        [0.20, 0.40, 0.70, 0.95],\n        [0.00, 0.15, 0.85, 1.00]\n    ])\n\n    test_case_2 = np.array([\n        [-1e-10, 0.0, 0.2],\n        [0.9999999999, 1.0, 1.0000000001],\n        [0.5, 0.8, 1.2]\n    ])\n\n    # Generate test case 3 using the specified seed.\n    np.random.seed(42)\n    test_case_3 = np.random.rand(5, 5)\n\n    test_case_4 = np.full((3, 3), 0.999999999999)\n\n    test_case_5 = np.array([\n        [-1e-16, 1e-16, 0.0],\n        [1e-14, 1e-12, 1e-10],\n        [0.0, 1e-9, 1e-8]\n    ])\n    \n    test_cases = [\n        test_case_1,\n        test_case_2,\n        test_case_3,\n        test_case_4,\n        test_case_5,\n    ]\n\n    def check_realizability(f_grid, tol):\n        \"\"\"\n        Checks a grid of flux factors for realizability.\n\n        Args:\n            f_grid: A numpy array of reduced flux values.\n            tol: The numerical tolerance for comparisons.\n\n        Returns:\n            A boolean, True if the grid is realizable, False otherwise.\n        \"\"\"\n        for f in f_grid.flatten():\n            # 1. Validate the input flux factor f.\n            # Must satisfy f = -tol and f = 1 + tol.\n            if f  -tol or f  1.0 + tol:\n                return False\n\n            # 2. Compute the Eddington factor chi using the Levermore-Pomraning closure.\n            # The argument to the square root is guaranteed to be non-negative\n            # because the check on f ensures |f| = 1 + tol  2/sqrt(3).\n            # To be robust against any floating point issues, clip to 0.\n            sqrt_arg = max(0.0, 4.0 - 3.0 * f**2)\n            chi = (3.0 + 4.0 * f**2) / (5.0 + 2.0 * np.sqrt(sqrt_arg))\n\n            # 3. Validate the computed chi.\n            # Must satisfy f^2 - tol = chi = 1 + tol.\n            lower_bound = f**2 - tol\n            upper_bound = 1.0 + tol\n            if chi  lower_bound or chi  upper_bound:\n                return False\n        \n        # If all points in the grid pass the checks, the case is realizable.\n        return True\n\n    results = []\n    for case in test_cases:\n        is_realizable = check_realizability(case, epsilon)\n        results.append(is_realizable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice synthesizes our understanding into a concrete numerical implementation within a finite-volume framework, tackling a key practical challenge. Explicit transport schemes can produce non-physical, faster-than-light energy propagation if not handled carefully. You will construct a \"flux-capping\" algorithm to enforce the causality constraint, $|F| \\le cE$, at cell interfaces, thereby ensuring the numerical solution remains physically valid and robust, all while maintaining exact conservation of total energy. ",
            "id": "3524567",
            "problem": "Consider a one-dimensional, periodic finite-volume discretization of the neutrino radiation moment equations, where the evolved quantities are the neutrino energy density $E_i$ in $\\mathrm{erg}/\\mathrm{cm}^3$ for cell index $i$, and a face-centered neutrino energy flux $F_{i+1/2}$ in $\\mathrm{erg}/(\\mathrm{cm}^2\\,\\mathrm{s})$ at the interface between cells $i$ and $i+1$. The speed of light is $c$ in $\\mathrm{cm}/\\mathrm{s}$. In any moment formulation derived from a positive distribution function with propagation limited by the speed of light, the causality constraint requires the flux magnitude not to exceed the streaming limit set by the energy density, namely $|F| \\le c\\,E$. In a discrete, face-based formulation that couples adjacent cells, a conservative face-wise enforcement of this constraint uses the bound $|F_{i+1/2}| \\le c \\,\\min(E_i,E_{i+1})$.\n\nYou are asked to design and implement a diagnostic and correction (flux-capping) algorithm that guarantees the discrete causality constraint while preserving total energy exactly under the finite-volume update, for arbitrary time stepping. Use the following fundamental base: the conservative finite-volume update for the energy density,\n$$\nE_i^{n+1} \\;=\\; E_i^{n} \\;-\\; \\frac{\\Delta t}{\\Delta x}\\,\\left( F_{i+1/2}^{\\mathrm{cap}} \\;-\\; F_{i-1/2}^{\\mathrm{cap}} \\right),\n$$\nwhere $\\Delta x$ is the cell width in $\\mathrm{cm}$, $\\Delta t$ is the time step in $\\mathrm{s}$, and $F^{\\mathrm{cap}}$ denotes the possibly capped face flux used in the update. Periodic boundaries imply face indices wrap around modulo the number of cells.\n\nYour program must do the following for each test case:\n- Perform a diagnostic that checks the causality constraint at every face after capping, namely $|F_{i+1/2}^{\\mathrm{cap}}| \\le c\\,\\min(E_i,E_{i+1})$.\n- Apply a flux-capping algorithm that rescales any violating face flux to satisfy causality without altering the associated energy densities prior to the update.\n- Update all $E_i$ by the conservative finite-volume formula above using the capped face fluxes, under periodic boundary conditions, and then compute the total energy before and after the update. Verify that the total energy is preserved to machine precision by checking that the absolute difference between the total energy before and after the update is less than or equal to $10\\,\\varepsilon_{\\mathrm{mach}} \\sum_i |E_i^{n}|$, where $\\varepsilon_{\\mathrm{mach}}$ is the machine epsilon for double precision.\n\nFlux-capping requirement. For each face $(i+1/2)$, define $b_{i+1/2} = c\\,\\min(E_i,E_{i+1})$ and $f_{i+1/2} = |F_{i+1/2}|$. If $f_{i+1/2} \\le b_{i+1/2}$, leave $F_{i+1/2}$ unchanged. Otherwise, set\n$$\n\\alpha_{i+1/2} \\;=\\; \\frac{b_{i+1/2}}{f_{i+1/2} + \\eta}, \\qquad F_{i+1/2}^{\\mathrm{cap}} \\;=\\; \\alpha_{i+1/2}\\,F_{i+1/2},\n$$\nwhere $\\eta$ is a small positive regularization parameter in $\\mathrm{erg}/(\\mathrm{cm}^2\\,\\mathrm{s})$ chosen to avoid division by zero and to maintain numerical robustness when $f_{i+1/2}$ is extremely small. The energy densities $E_i$ are not altered during capping; conservation is achieved by using the same capped face flux for both neighboring cells in the update. Angles do not appear in this one-dimensional formulation.\n\nNumerical units. Use $\\mathrm{erg}/\\mathrm{cm}^3$ for $E$, $\\mathrm{erg}/(\\mathrm{cm}^2\\,\\mathrm{s})$ for $F$, $\\mathrm{cm}/\\mathrm{s}$ for $c$, $\\mathrm{cm}$ for $\\Delta x$, and $\\mathrm{s}$ for $\\Delta t$.\n\nTest suite. Use the speed of light $c = 2.99792458 \\times 10^{10}\\,\\mathrm{cm}/\\mathrm{s}$. For each case, the domain is periodic, with faces indexed modulo the number of cells. The program must evaluate the following five test cases:\n1. Happy path with sub-causal fluxes: $N = 4$, $\\Delta x = 1.0 \\times 10^{5}\\,\\mathrm{cm}$, $\\Delta t = 1.0 \\times 10^{-6}\\,\\mathrm{s}$, $E = [1.0 \\times 10^{25},\\,1.0 \\times 10^{25},\\,1.0 \\times 10^{25},\\,1.0 \\times 10^{25}]$ in $\\mathrm{erg}/\\mathrm{cm}^3$, and $F$ at faces equals $[+0.2\\,c\\,E_{\\min,0},\\,-0.1\\,c\\,E_{\\min,1},\\,+0.05\\,c\\,E_{\\min,2},\\,-0.15\\,c\\,E_{\\min,3}]$ in $\\mathrm{erg}/(\\mathrm{cm}^2\\,\\mathrm{s})$, where $E_{\\min,i} = \\min(E_i,E_{i+1})$ with periodic indexing.\n2. Overshoot requiring capping: $N = 4$, $\\Delta x = 1.0 \\times 10^{5}\\,\\mathrm{cm}$, $\\Delta t = 3.0 \\times 10^{-6}\\,\\mathrm{s}$, $E = [1.0 \\times 10^{25},\\,1.0 \\times 10^{25},\\,1.0 \\times 10^{25},\\,1.0 \\times 10^{25}]$, and $F = [+1.5\\,c\\,E_{\\min,0},\\,+1.2\\,c\\,E_{\\min,1},\\,-0.9\\,c\\,E_{\\min,2},\\,+2.0\\,c\\,E_{\\min,3}]$.\n3. Zero-energy cell edge case: $N = 4$, $\\Delta x = 1.0 \\times 10^{5}\\,\\mathrm{cm}$, $\\Delta t = 2.0 \\times 10^{-6}\\,\\mathrm{s}$, $E = [0.0,\\,1.0 \\times 10^{25},\\,1.0 \\times 10^{25},\\,1.0 \\times 10^{25}]$, and $F = [+0.5\\,c\\,E_{\\min,0},\\,+0.5\\,c\\,E_{\\min,1},\\,+0.5\\,c\\,E_{\\min,2},\\,+0.5\\,c\\,E_{\\min,3}]$.\n4. Arbitrarily large time step: $N = 4$, $\\Delta x = 1.0 \\times 10^{5}\\,\\mathrm{cm}$, $\\Delta t = 1.0 \\times 10^{-1}\\,\\mathrm{s}$, $E = [1.0 \\times 10^{20},\\,1.0 \\times 10^{20},\\,1.0 \\times 10^{20},\\,1.0 \\times 10^{20}]$, and $F = [+3.0\\,c\\,E_{\\min,0},\\,-3.0\\,c\\,E_{\\min,1},\\,+3.0\\,c\\,E_{\\min,2},\\,-3.0\\,c\\,E_{\\min,3}]$.\n5. Mixed amplitudes and signs: $N = 4$, $\\Delta x = 1.0 \\times 10^{5}\\,\\mathrm{cm}$, $\\Delta t = 5.0 \\times 10^{-6}\\,\\mathrms$, $E = [8.0 \\times 10^{24},\\,2.0 \\times 10^{25},\\,5.0 \\times 10^{24},\\,9.0 \\times 10^{25}]$, and $F = [+4.0\\,c\\,E_{\\min,0},\\,-0.3\\,c\\,E_{\\min,1},\\,+1.1\\,c\\,E_{\\min,2},\\,-2.3\\,c\\,E_{\\min,3}]$.\n\nRequired output format. For each test case, return a boolean that is $\\,\\texttt{True}\\,$ if and only if both conditions hold: (a) all faces satisfy $|F_{i+1/2}^{\\mathrm{cap}}| \\le c\\,\\min(E_i,E_{i+1})$ after capping, and (b) the total energy difference is less than or equal to $10\\,\\varepsilon_{\\mathrm{mach}} \\sum_i |E_i^{n}|$ after the finite-volume update with periodic boundaries. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[\\texttt{True},\\texttt{False},\\texttt{True},\\texttt{True},\\texttt{True}]$.",
            "solution": "The task is to design and test a numerical algorithm for a one-dimensional finite-volume discretization of neutrino radiation transport. The algorithm must enforce a physical causality constraint on the neutrino energy flux while exactly conserving total neutrino energy. We will first elaborate on the underlying principles and then detail the implementation of the specified algorithm and checks.\n\n**1. Finite-Volume Formulation and Conservation**\n\nThe evolution of the neutrino energy density $E_i$ in a computational cell $i$ is governed by the conservative finite-volume update equation:\n$$\nE_i^{n+1} \\;=\\; E_i^{n} \\;-\\; \\frac{\\Delta t}{\\Delta x}\\,\\left( F_{i+1/2}^{\\mathrm{cap}} \\;-\\; F_{i-1/2}^{\\mathrm{cap}} \\right)\n$$\nHere, $E_i^n$ and $E_i^{n+1}$ are the energy densities at time levels $n$ and $n+1$, respectively. The quantities $\\Delta x$ and $\\Delta t$ represent the constant cell width and the time step. The terms $F_{i+1/2}^{\\mathrm{cap}}$ and $F_{i-1/2}^{\\mathrm{cap}}$ are the numerical fluxes at the right and left faces of cell $i$. This \"flux-difference\" form is the hallmark of a conservative scheme.\n\nTo verify energy conservation, we sum the change in energy over all cells in the domain. The total energy at time $n$ is $E_{\\text{tot}}^n = \\sum_{i=0}^{N-1} E_i^n$. The change in total energy after one time step is:\n$$\n\\Delta E_{\\text{tot}} = E_{\\text{tot}}^{n+1} - E_{\\text{tot}}^{n} = \\sum_{i=0}^{N-1} (E_i^{n+1} - E_i^n) = \\sum_{i=0}^{N-1} \\left[-\\frac{\\Delta t}{\\Delta x}\\left( F_{i+1/2}^{\\mathrm{cap}} - F_{i-1/2}^{\\mathrm{cap}} \\right)\\right]\n$$\nFor a periodic domain with $N$ cells, the indices of the fluxes are interpreted modulo $N$. For example, the left face of cell $0$ is the face with index $-1/2$, which is equivalent to face $N-1+1/2$. The sum of flux differences becomes a telescoping sum:\n$$\n\\sum_{i=0}^{N-1} \\left( F_{i+1/2}^{\\mathrm{cap}} - F_{i-1/2}^{\\mathrm{cap}} \\right) = \\left(F_{1/2}^{\\mathrm{cap}} - F_{N-1+1/2}^{\\mathrm{cap}}\\right) + \\left(F_{1+1/2}^{\\mathrm{cap}} - F_{1/2}^{\\mathrm{cap}}\\right) + \\dots + \\left(F_{N-1+1/2}^{\\mathrm{cap}} - F_{N-2+1/2}^{\\mathrm{cap}}\\right)\n$$\nDue to the periodic boundary conditions, every flux term $F_{i+1/2}^{\\mathrm{cap}}$ appears twice with opposite signs. For instance, $F_{1/2}^{\\mathrm{cap}}$ appears as a positive term for $i=0$ and a negative term for $i=1$. Consequently, the sum is identically zero in exact arithmetic.\n$$\n\\sum_{i=0}^{N-1} \\left( F_{i+1/2}^{\\mathrm{cap}} - F_{i-1/2}^{\\mathrm{cap}} \\right) = 0\n$$\nThis implies $\\Delta E_{\\text{tot}} = 0$, meaning total energy is conserved. In floating-point arithmetic, we expect this conservation to hold up to machine precision. The problem specifies a validation tolerance for this: $|\\sum E_i^{n+1} - \\sum E_i^n| \\le 10\\,\\varepsilon_{\\mathrm{mach}} \\sum_i |E_i^{n}|$.\n\n**2. Causality Constraint and Flux Capping**\n\nA fundamental principle of relativistic physics is that information and energy cannot propagate faster than the speed of light, $c$. For radiation transport, this implies that the magnitude of the energy flux, $|F|$, cannot exceed the energy density, $E$, multiplied by $c$: $|F| \\le cE$. This is the causality or \"streaming\" limit.\n\nIn a discrete finite-volume scheme, this principle is enforced at the cell faces. The flux $F_{i+1/2}$ passes between cells $i$ and $i+1$. A conservative choice for the local energy density bound is the minimum of the two adjacent cells, leading to the discrete causality constraint:\n$$\n|F_{i+1/2}| \\le c \\, \\min(E_i, E_{i+1})\n$$\nIf an un-capped numerical flux $F_{i+1/2}$ violates this constraint, it must be corrected or \"capped\". The prescribed flux-capping algorithm is:\n1. Define the causality bound for face $i+1/2$: $b_{i+1/2} = c\\,\\min(E_i, E_{i+1})$.\n2. Define the magnitude of the uncapped flux: $f_{i+1/2} = |F_{i+1/2}|$.\n3. If $f_{i+1/2} > b_{i+1/2}$, the flux is super-causal and must be rescaled.\n4. The rescaled (capped) flux is computed as $F_{i+1/2}^{\\mathrm{cap}} = \\alpha_{i+1/2}\\,F_{i+1/2}$, with the scaling factor $\\alpha_{i+1/2} = \\frac{b_{i+1/2}}{f_{i+1/2} + \\eta}$.\n5. If $f_{i+1/2} \\le b_{i+1/2}$, the flux is already sub-causal, so $F_{i+1/2}^{\\mathrm{cap}} = F_{i+1/2}$.\n\nThe problem introduces a small positive regularization parameter $\\eta$ to prevent division by zero. However, the capping logic is only triggered when $f_{i+1/2} > b_{i+1/2}$. Since energy densities are non-negative, $b_{i+1/2} \\ge 0$, which implies $f_{i+1/2}$ must be strictly positive for capping to occur. Thus, division by a zero flux magnitude is not an issue. The most natural and minimal correction is to scale the flux magnitude exactly to the bound, i.e., $|F_{i+1/2}^{\\mathrm{cap}}| = b_{i+1/2}$. This is achieved by setting $\\eta = 0$, which yields $\\alpha_{i+1/2} = b_{i+1/2} / f_{i+1/2}$. We will adopt this choice, $\\eta=0$, for the implementation.\n\n**3. Algorithmic Procedure for Each Test Case**\n\nFor each provided test case, the following sequence of operations is performed:\n1.  **Initialization**: Set the physical constants $c$, grid parameters $N, \\Delta x, \\Delta t$, and initial energy density array $E^n$.\n2.  **Flux Calculation**: Based on the expressions given in each test case (e.g., $+1.5\\,c\\,E_{\\min,0}$), compute the initial numerical flux array, $F$. This involves first calculating $E_{\\min,i} = \\min(E_i, E_{i+1 \\pmod N})$ for each face.\n3.  **Store Initial State**: Calculate and store the initial total energy, $E_{\\text{tot}}^n = \\sum_i E_i^n$.\n4.  **Flux Capping**:\n    a. Initialize the capped flux array, $F^{\\mathrm{cap}}$, as a copy of $F$.\n    b. For each face $i+1/2$ (from $i=0$ to $N-1$):\n       i. Compute the bound $b_{i+1/2} = c\\,\\min(E_i, E_{(i+1) \\pmod N})$.\n       ii. Compute the flux magnitude $f_{i+1/2} = |F_{i+1/2}|$.\n       iii. If $f_{i+1/2} > b_{i+1/2}$, update the capped flux for that face: $F_{i}^{\\mathrm{cap}} \\leftarrow (b_{i+1/2} / f_{i+1/2}) \\times F_{i}$. Note that array index $i$ corresponds to face $i+1/2$.\n5.  **Causality Verification**:\n    a. A boolean flag `causality_ok` is initialized to `True`.\n    b. For each face $i+1/2$:\n       i. Re-compute the bound $b_{i+1/2} = c\\,\\min(E_i, E_{(i+1) \\pmod N})$.\n       ii. Check if $|F_{i}^{\\mathrm{cap}}| \\le b_{i+1/2} \\times (1 + 10\\varepsilon_{\\mathrm{mach}})$. A small floating-point tolerance is used for this comparison to account for potential round-off errors. If the condition fails, set `causality_ok` to `False`.\n6.  **Energy Update**:\n    a. Create a new array, $E^{n+1}$, to store the updated energy densities.\n    b. For each cell $i$ (from $0$ to $N-1$):\n       i. Identify the right-face flux $F_{\\text{right}} = F_{(i)}^{\\mathrm{cap}}$ and the left-face flux $F_{\\text{left}} = F_{(i-1) \\pmod N}^{\\mathrm{cap}}$.\n       ii. Apply the finite-volume formula: $E_i^{n+1} = E_i^n - (\\Delta t / \\Delta x) \\times (F_{\\text{right}} - F_{\\text{left}})$.\n7.  **Conservation Verification**:\n    a. Calculate the final total energy $E_{\\text{tot}}^{n+1} = \\sum_i E_i^{n+1}$.\n    b. Calculate the initial total energy norm $\\sum_i |E_i^n|$.\n    c. A boolean flag `conservation_ok` is determined by the condition $|\\,E_{\\text{tot}}^{n+1} - E_{\\text{tot}}^n\\,| \\le 10 \\times \\varepsilon_{\\mathrm{mach}} \\times \\sum_i |E_i^n|$. If the sum of initial energies is zero, an absolute tolerance check must be used instead.\n8.  **Final Result**: The outcome for the test case is the logical AND of the two verification flags: `result = causality_ok and conservation_ok`.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the neutrino transport problem by applying and verifying a flux-capping algorithm.\n    \"\"\"\n    C_LIGHT = 2.99792458e10  # cm/s\n    MACHINE_EPSILON = np.finfo(np.double).eps\n\n    test_cases = [\n        {\n            \"N\": 4, \"dx\": 1.0e5, \"dt\": 1.0e-6,\n            \"E0\": np.array([1.0e25, 1.0e25, 1.0e25, 1.0e25]),\n            \"F_factors\": np.array([+0.2, -0.1, +0.05, -0.15])\n        },\n        {\n            \"N\": 4, \"dx\": 1.0e5, \"dt\": 3.0e-6,\n            \"E0\": np.array([1.0e25, 1.0e25, 1.0e25, 1.0e25]),\n            \"F_factors\": np.array([+1.5, +1.2, -0.9, +2.0])\n        },\n        {\n            \"N\": 4, \"dx\": 1.0e5, \"dt\": 2.0e-6,\n            \"E0\": np.array([0.0, 1.0e25, 1.0e25, 1.0e25]),\n            \"F_factors\": np.array([+0.5, +0.5, +0.5, +0.5])\n        },\n        {\n            \"N\": 4, \"dx\": 1.0e5, \"dt\": 1.0e-1,\n            \"E0\": np.array([1.0e20, 1.0e20, 1.0e20, 1.0e20]),\n            \"F_factors\": np.array([+3.0, -3.0, +3.0, -3.0])\n        },\n        {\n            \"N\": 4, \"dx\": 1.0e5, \"dt\": 5.0e-6,\n            \"E0\": np.array([8.0e24, 2.0e25, 5.0e24, 9.0e25]),\n            \"F_factors\": np.array([+4.0, -0.3, +1.1, -2.3])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case, C_LIGHT, MACHINE_EPSILON)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(case_data, c, eps):\n    \"\"\"\n    Processes a single test case.\n    \"\"\"\n    N = case_data[\"N\"]\n    dx = case_data[\"dx\"]\n    dt = case_data[\"dt\"]\n    E_n = case_data[\"E0\"].astype(np.double)\n    F_factors = case_data[\"F_factors\"].astype(np.double)\n\n    # 1. Calculate initial uncapped fluxes F\n    # F[i] is at face i+1/2, between cells i and (i+1)%N\n    E_min_face = np.zeros(N, dtype=np.double)\n    for i in range(N):\n        E_min_face[i] = min(E_n[i], E_n[(i + 1) % N])\n    \n    F_uncapped = F_factors * c * E_min_face\n\n    # 2. Store initial total energy\n    total_energy_n = np.sum(E_n)\n\n    # 3. Apply flux capping\n    F_capped = np.copy(F_uncapped)\n    bounds = c * E_min_face\n    \n    for i in range(N):\n        f_mag = np.abs(F_capped[i])\n        b_i = bounds[i]\n        \n        # Capping is applied if |F|  b. Using a small tolerance for the comparison.\n        if f_mag  b_i + eps:\n            # We choose eta=0, which corresponds to scaling to the bound.\n            # alpha = b_i / (f_mag + eta). For eta=0, alpha = b_i / f_mag.\n            # F_capped[i] = alpha * F_capped[i]\n            # This is equivalent to F_capped[i] = (b_i / f_mag) * F_capped[i]\n            # To preserve the sign:\n            F_capped[i] = np.sign(F_capped[i]) * b_i\n\n    # 4. Diagnostic 1: Check causality post-capping\n    # |F_capped[i]| = c * min(E_n[i], E_n[(i+1)%N])\n    causality_ok = True\n    f_capped_mags = np.abs(F_capped)\n    # Use a small tolerance for floating point comparison\n    # Check if f_capped_mags[i] = bounds[i] for all i\n    if not np.all(f_capped_mags = bounds + 10 * eps * (np.abs(bounds) + 1.0)):\n        causality_ok = False\n\n    # 5. Update energy densities\n    E_np1 = np.zeros(N, dtype=np.double)\n    dt_dx = dt / dx\n    for i in range(N):\n        F_right = F_capped[i]\n        F_left = F_capped[(i - 1 + N) % N]\n        E_np1[i] = E_n[i] - dt_dx * (F_right - F_left)\n\n    # 6. Diagnostic 2: Check energy conservation\n    total_energy_np1 = np.sum(E_np1)\n    energy_diff = np.abs(total_energy_np1 - total_energy_n)\n    \n    sum_abs_E_n = np.sum(np.abs(E_n))\n    # Handle case where initial total energy is zero\n    if sum_abs_E_n  0:\n        conservation_tolerance = 10 * eps * sum_abs_E_n\n    else:\n        conservation_tolerance = 10 * eps\n\n    conservation_ok = energy_diff = conservation_tolerance\n    \n    # 7. Final result for the case\n    return causality_ok and conservation_ok\n\nsolve()\n\n```"
        }
    ]
}