{
    "hands_on_practices": [
        {
            "introduction": "恒星演化模型的准确性在很大程度上依赖于精确的物理输入，例如不透明度。这个动手实践将引导你解决恒星演化计算中的一个核心数值挑战：如何在离散的不透明度表中进行精确插值，尤其是在不透明度随温度和密度剧烈变化的电离区附近。通过实现并比较双线性和保单调性插值方案，你将亲身体会到数值方法的选择对物理结果保真度的重要影响。",
            "id": "3534104",
            "problem": "考虑辐射不透明度表，例如由利弗莫尔的不透明度项目 (Opacity Project at Livermore, OPAL) 提供的那些表，这些表将质量吸收系数 $\\kappa$（单位为 $\\mathrm{cm^2\\,g^{-1}}$）制成表格，作为 $\\log_{10} T$（温度，单位为开尔文）和 $\\log_{10} R$ 的函数，其中 $R$ 是一个密度-温度复合变量。在数值恒星演化中，不透明度是通过对这些表在任意点 $(\\log_{10} T, \\log_{10} R)$ 进行插值来评估的。在 $\\kappa$ 快速变化的电离边附近，避免因插值引入虚假的极值至关重要。设计并实现双线性插值和保持单调性的类双三次插值，后者基于以张量积方式构建的一维单调三次 Hermite 插值。\n\n为了使问题自洽并量化插值误差，使用以下物理上合理的合成“太阳成分”不透明度模型作为基准真相。对于氢质量分数 $X=0.70$，氦质量分数 $Y=0.28$ 和金属质量分数 $Z=0.02$，定义 $x = \\log_{10} T$ 和 $y = \\log_{10} R$ 的真实 $\\log_{10} \\kappa$ 为\n$$\n\\log_{10}\\kappa(x,y) = \\log_{10}\\left(A (1+X)\\right) + y - 3.5 x + \\sum_{i=1}^{4} a_i \\exp\\!\\left(-\\left(\\frac{x - x_i}{w_i}\\right)^2\\right)\\left(1 + \\beta_i\\,\\tanh\\!\\left(\\gamma_i\\, y\\right)\\right),\n$$\n其中 $A = 10^{24}$，带有四个模拟电离边的高斯状增强，中心位于\n$$\nx_1 = 3.90 \\quad (\\text{氢}), \\quad x_2 = 4.20 \\quad (\\text{氦 I}), \\quad x_3 = 4.60 \\quad (\\text{氦 II}), \\quad x_4 = 4.90 \\quad (\\text{金属}),\n$$\n振幅和宽度由下式给出\n$$\na_1 = 0.30,\\; w_1 = 0.035,\\;\\beta_1 = 0.2,\\;\\gamma_1=0.8;\\quad\na_2 = 0.25,\\; w_2 = 0.040,\\;\\beta_2 = 0.15,\\;\\gamma_2=0.8;\n$$\n$$\na_3 = 0.20,\\; w_3 = 0.045,\\;\\beta_3 = 0.10,\\;\\gamma_3=0.8;\\quad\na_4 = 0.15 \\frac{Z}{0.02},\\; w_4 = 0.060,\\;\\beta_4 = 0.25,\\;\\gamma_4=0.8.\n$$\n该模型将一个类克莱默定律基线（自由-自由不透明度标度关系 $\\propto R\\,T^{-3.5}$）与平滑、狭窄的增强相结合，以模拟电离边。所有对数均以 10 为底。\n\n在以下粗网格上构建一个矩形不透明度表\n$$\nx \\in [3.75, 5.00],\\quad y \\in [-7.0, -2.0],\n$$\n其中 $x$ 方向有 $N_x = 16$ 个等距点，$y$ 方向有 $N_y = 11$ 个等距点。通过在每个网格节点上评估上述合成基准真相来计算表值 $\\log_{10} \\kappa(x_i,y_j)$。\n\n从此表中实现两个插值器：\n- 一个双线性插值器，源于沿每个轴的线性插值，通过周围四个单元格角点值的凸组合，在测试查询点 $(x_q,y_q)$ 产生一个估计值 $\\tilde{f}_{\\mathrm{bilin}}(x_q,y_q)$。\n- 一个保持单调性的类双三次插值器 $\\tilde{f}_{\\mathrm{mono}}(x_q,y_q)$，构建如下：对于固定的 $y$，使用保持列表值沿 $x$ 轴单调性的单调三次 Hermite 插值，在 $x_q$ 处对 $x \\mapsto \\log_{10}\\kappa(x,y)$ 进行插值；然后，使用由 $y$ 索引的中间值集，使用相同的单调三次 Hermite 方法沿 $y$ 轴在 $y_q$ 处进行插值。与列表数据相比，该方法不得在任一轴上引入新的极值。使用标准的分段单调三次 Hermite 插值器来实现此方法。\n\n使用这两个插值器，通过计算以下值来评估和比较电离边附近的绝对插值误差：\n$$\ne_{\\mathrm{bilin}} = \\left|\\tilde{f}_{\\mathrm{bilin}}(x_q,y_q) - \\log_{10}\\kappa(x_q,y_q)\\right|,\\quad\ne_{\\mathrm{mono}} = \\left|\\tilde{f}_{\\mathrm{mono}}(x_q,y_q) - \\log_{10}\\kappa(x_q,y_q)\\right|,\n$$\n对于以下八个测试查询点 $(x_q,y_q)$：\n1. $x_q = 3.90$, $y_q = -5.00$ (氢电离峰的中心),\n2. $x_q = 3.92$, $y_q = -6.00$ (氢峰附近的陡峭梯度区域),\n3. $x_q = 4.20$, $y_q = -4.00$ (氦 I 峰的中心),\n4. $x_q = 4.60$, $y_q = -6.50$ (氦 II 峰的中心),\n5. $x_q = 4.80$, $y_q = -3.00$ (平滑基线区域),\n6. $x_q = 3.76$, $y_q = -2.10$ (靠近低 $x$ 和高 $y$ 边界),\n7. $x_q = 4.99$, $y_q = -6.90$ (靠近高 $x$ 和低 $y$ 边界),\n8. $x_q = 4.23$, $y_q = -5.50$ (靠近氦 I 峰的偏离中心位置)。\n\n所有误差必须以十进制对数单位 (dex) 表示，它是无量纲的。本问题不涉及角度。你的程序必须产生单行输出，包含用方括号括起来的逗号分隔列表形式的结果，顺序如下：\n$$\n\\left[e_{\\mathrm{bilin}}^{(1)}, e_{\\mathrm{mono}}^{(1)}, e_{\\mathrm{bilin}}^{(2)}, e_{\\mathrm{mono}}^{(2)}, \\ldots, e_{\\mathrm{bilin}}^{(8)}, e_{\\mathrm{mono}}^{(8)}\\right].\n$$\n\n设计必须从数值插值的第一性原理和有物理动机的不透明度行为出发，并且必须确保科学真实性。不允许用户输入或使用外部文件；所有计算都必须在程序内部完成。",
            "solution": "首先根据指定标准对问题进行验证。\n- **科学依据**：该问题在科学上是合理的。它使用了一个有物理动机的合成不透明度函数，该函数模拟了克莱默定律和电离边，这些是恒星天体物理学中的既定概念。该任务涉及应用标准的数值插值技术，这是计算科学中的核心实践。\n- **适定性**：问题是适定的。所有参数、函数和评估点都已明确定义，从而得到一组唯一的数值结果。\n- **客观性**：问题以精确、客观和定量的术语陈述。\n- **完整性和一致性**：问题是自洽的，提供了所有必要的数据和定义。没有明显的矛盾。\n- **真实性**：该场景代表了一个在计算恒星演化中遇到的简化但现实的挑战，其中列表化的物理数据必须被准确而稳健地插值。\n\n问题被认为是有效的。现在将提供一个解决方案。\n\n目标是实现并比较两种不同的二维插值方案：双线性和保持单调性的类双三次方法，用于插值恒星不透明度数据。这些方法的准确性将通过将其结果与已知的解析“基准真相”模型进行比较来量化，特别是在对应于电离边的快速变化区域。所有对数均以 10 为底。\n\n首先，我们为罗斯兰平均不透明度 $\\kappa$ 定义合成的“基准真相”模型。该模型将 $\\log_{10} \\kappa$ 作为 $x = \\log_{10} T$（其中 $T$ 是温度，单位为开尔文）和 $y = \\log_{10} R$（其中 $R$ 是一个密度-温度变量，定义为 $\\rho / T_6^3$，$\\rho$ 的单位是 $\\mathrm{g\\,cm^{-3}}$，$T_6$ 的单位是 $10^6 \\mathrm{K}$）的函数提供。成分是固定的，氢质量分数 $X=0.70$，氦质量分数 $Y=0.28$，金属质量分数 $Z=0.02$。\n\n$\\log_{10}\\kappa$ 的函数由下式给出：\n$$\n\\log_{10}\\kappa(x,y) = \\log_{10}\\left(A (1+X)\\right) + y - 3.5 x + \\sum_{i=1}^{4} a_i \\exp\\!\\left(-\\left(\\frac{x - x_i}{w_i}\\right)^2\\right)\\left(1 + \\beta_i\\,\\tanh\\!\\left(\\gamma_i\\, y\\right)\\right)\n$$\n该模型由一个基线项 $\\log_{10}(A(1+X)) + y - 3.5x$ 组成，该项代表了自由-自由不透明度的克莱默定律标度关系 $\\kappa \\propto R T^{-3.5}$。叠加在此之上的是四个高斯状峰，模拟了由氢、氦 I、氦 II 和一种代表性金属物质的电离引起的不透明度的显著增加。参数如下：\n- 常数：$A = 10^{24}$\n- 峰中心（以 $\\log_{10} T$ 为单位）：$x_1 = 3.90$ (氢)，$x_2 = 4.20$ (氦 I)，$x_3 = 4.60$ (氦 II)，$x_4 = 4.90$ (金属)。\n- 峰参数（振幅 $a_i$、宽度 $w_i$ 和密度依赖性修饰符 $\\beta_i, \\gamma_i$）：\n  - $a_1 = 0.30$, $w_1 = 0.035$, $\\beta_1 = 0.2$, $\\gamma_1=0.8$\n  - $a_2 = 0.25$, $w_2 = 0.040$, $\\beta_2 = 0.15$, $\\gamma_2=0.8$\n  - $a_3 = 0.20$, $w_3 = 0.045$, $\\beta_3 = 0.10$, $\\gamma_3=0.8$\n  - $a_4 = 0.15 \\frac{Z}{0.02} = 0.15$, $w_4 = 0.060$, $\\beta_4 = 0.25$, $\\gamma_4=0.8$\n\n在由以下定义的粗矩形网格上，构建一个离散不透明度表 $f_{ij} = \\log_{10}\\kappa(x_i, y_j)$：\n- $x \\in [3.75, 5.00]$，有 $N_x = 16$ 个等距点 ($x_i$)。\n- $y \\in [-7.0, -2.0]$，有 $N_y = 11$ 个等距点 ($y_j$)。\n\n我们将实现两种方法在此表内进行插值。设查询点为 $(x_q, y_q)$，该点位于由角点 $(x_i, y_j)$、$(x_{i+1}, y_j)$、$(x_i, y_{j+1})$ 和 $(x_{i+1}, y_{j+1})$ 定义的网格单元内。设这些角点对应的函数值为 $f_{i,j}$、$f_{i+1,j}$、$f_{i,j+1}$ 和 $f_{i+1,j+1}$。\n\n1.  **双线性插值**\n此方法将网格单元内的函数近似为一个在每个方向上都是线性的曲面。它等效于执行三次线性插值。首先，我们在单元格的下 $y$ 边界和上 $y$ 边界上沿 $x$ 方向进行插值：\n$$\nf(x_q, y_j) \\approx \\frac{x_{i+1} - x_q}{x_{i+1} - x_i} f_{i,j} + \\frac{x_q - x_i}{x_{i+1} - x_i} f_{i+1,j}\n$$\n$$\nf(x_q, y_{j+1}) \\approx \\frac{x_{i+1} - x_q}{x_{i+1} - x_i} f_{i,j+1} + \\frac{x_q - x_i}{x_{i+1} - x_i} f_{i+1,j+1}\n$$\n然后，我们在这两个中间值之间沿 $y$ 方向进行线性插值，以找到在 $(x_q, y_q)$ 处的最终值：\n$$\n\\tilde{f}_{\\mathrm{bilin}}(x_q, y_q) \\approx \\frac{y_{j+1} - y_q}{y_{j+1} - y_j} f(x_q, y_j) + \\frac{y_q - y_j}{y_{j+1} - y_j} f(x_q, y_{j+1})\n$$\n这个方案是连续的 ($C^0$)，但其导数在单元格边界处不连续。这可能导致插值函数中出现不符合物理规律的扭结以及相对较低的准确性。\n\n2.  **保持单调性的类双三次插值**\n在尖锐的电离边附近，简单的双线性插值可能不准确，而标准的双三次样条插值可能会引入虚假的振荡（过冲/下冲），这在物理上是无意义的。一种更稳健的方法是分段三次 Hermite 插值多项式 (PCHIP)，它可以保持原始数据的单调性。通过一维 PCHIP 插值器的张量积来构建二维插值器。过程如下：\n- **第1步：沿 $x$ 轴插值。**对于每个对应于恒定 $y_j$ 的网格线（$j=0, \\dots, N_y-1$），我们为数据点 $(x_i, f_{i,j})$ 构建一个一维 PCHIP 插值器。这会产生 $N_y$ 个独立的一维插值函数。我们在 $x_q$ 处对每个函数求值，以获得一组中间值，$\\{ v_j = \\tilde{f}(x_q, y_j) \\}_{j=0}^{N_y-1}$。\n- **第2步：沿 $y$ 轴插值。**我们现在有了一个由点 $(y_j, v_j)$ 组成的新的一维数据集。我们为此数据集构建一个最终的一维 PCHIP 插值器，并在 $y_q$ 处求值以获得最终的插值 $\\tilde{f}_{\\mathrm{mono}}(x_q, y_q)$。\n\n该方法确保了如果表数据在某个段内沿一轴是单调的，那么沿该轴的插值也将是单调的。它提供了 $C^1$ 连续性，并且通常比双线性插值更准确，没有标准三次样条相关的非物理振荡风险。\n\n最后，我们将在八个指定的查询点 $(x_q^{(k)}, y_q^{(k)})$ 处评估两种方法的绝对插值误差：\n$$\ne_{\\mathrm{bilin}}^{(k)} = \\left|\\tilde{f}_{\\mathrm{bilin}}(x_q^{(k)},y_q^{(k)}) - \\log_{10}\\kappa(x_q^{(k)},y_q^{(k)})\\right|\n$$\n$$\ne_{\\mathrm{mono}}^{(k)} = \\left|\\tilde{f}_{\\mathrm{mono}}(x_q^{(k)},y_q^{(k)}) - \\log_{10}\\kappa(x_q^{(k)},y_q^{(k)})\\right|\n$$\n这些误差以无量纲的对数单位 (dex) 表示，将被计算和报告。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Implements and compares bilinear and monotonicity-preserving bicubic-like interpolation\n    for a synthetic stellar opacity model.\n    \"\"\"\n    \n    # --------------------------------------------------------------------------\n    # 1. Define the synthetic opacity model (ground truth)\n    # --------------------------------------------------------------------------\n    X, Y, Z = 0.70, 0.28, 0.02\n    A = 1e24\n    \n    # Gaussian-like enhancement parameters for ionization edges\n    params = [\n        # H ionization\n        {'x_i': 3.90, 'a_i': 0.30, 'w_i': 0.035, 'beta_i': 0.2, 'gamma_i': 0.8},\n        # He I ionization\n        {'x_i': 4.20, 'a_i': 0.25, 'w_i': 0.040, 'beta_i': 0.15, 'gamma_i': 0.8},\n        # He II ionization\n        {'x_i': 4.60, 'a_i': 0.20, 'w_i': 0.045, 'beta_i': 0.10, 'gamma_i': 0.8},\n        # Metals ionization\n        {'x_i': 4.90, 'a_i': 0.15 * (Z / 0.02), 'w_i': 0.060, 'beta_i': 0.25, 'gamma_i': 0.8},\n    ]\n    \n    def log_kappa_true(x, y):\n        \"\"\"\n        Calculates the true log10(kappa) from the synthetic model.\n        x = log10(T), y = log10(R)\n        \"\"\"\n        baseline = np.log10(A * (1.0 + X)) + y - 3.5 * x\n        enhancements = 0.0\n        for p in params:\n            gauss_term = np.exp(-((x - p['x_i']) / p['w_i'])**2)\n            tanh_term = 1.0 + p['beta_i'] * np.tanh(p['gamma_i'] * y)\n            enhancements += p['a_i'] * gauss_term * tanh_term\n        return baseline + enhancements\n\n    # --------------------------------------------------------------------------\n    # 2. Construct the coarse opacity table\n    # --------------------------------------------------------------------------\n    Nx, Ny = 16, 11\n    x_grid = np.linspace(3.75, 5.00, Nx)\n    y_grid = np.linspace(-7.0, -2.0, Ny)\n    \n    # Note: np.meshgrid with default indexing='xy' creates X of shape (Ny, Nx)\n    # This means Z_table[j, i] corresponds to (x_grid[i], y_grid[j])\n    X_mesh, Y_mesh = np.meshgrid(x_grid, y_grid)\n    Z_table = log_kappa_true(X_mesh, Y_mesh)\n\n    # --------------------------------------------------------------------------\n    # 3. Implement the interpolators\n    # --------------------------------------------------------------------------\n    \n    def bilinear_interp(xq, yq, x_grid, y_grid, Z_table):\n        \"\"\"Performs bilinear interpolation on the grid.\"\"\"\n        # Find cell indices\n        ix = np.searchsorted(x_grid, xq) - 1\n        iy = np.searchsorted(y_grid, yq) - 1\n        \n        # Clamp indices to be within the grid bounds for interpolation\n        ix = np.clip(ix, 0, len(x_grid) - 2)\n        iy = np.clip(iy, 0, len(y_grid) - 2)\n        \n        # Grid points for the cell\n        x1, x2 = x_grid[ix], x_grid[ix+1]\n        y1, y2 = y_grid[iy], y_grid[iy+1]\n        \n        # Values at the four corners of the cell\n        # Z_table is indexed (y, x)\n        z11 = Z_table[iy, ix]\n        z12 = Z_table[iy+1, ix]\n        z21 = Z_table[iy, ix+1]\n        z22 = Z_table[iy+1, ix+1]\n        \n        # Normalized coordinates\n        tx = (xq - x1) / (x2 - x1)\n        ty = (yq - y1) / (y2 - y1)\n        \n        # Interpolate\n        interp_val = (z11 * (1 - tx) * (1 - ty) +\n                      z21 * tx * (1 - ty) +\n                      z12 * (1 - tx) * ty +\n                      z22 * tx * ty)\n                      \n        return interp_val\n\n    def monotonic_interp(xq, yq, x_grid, y_grid, Z_table):\n        \"\"\"Performs monotonicity-preserving bicubic-like interpolation.\"\"\"\n        # Step 1: Interpolate along x for each y_j\n        y_interp_values = np.zeros(len(y_grid))\n        for j in range(len(y_grid)):\n            # Z_table[j, :] is the slice at y_grid[j]\n            pchip_x = PchipInterpolator(x_grid, Z_table[j, :])\n            y_interp_values[j] = pchip_x(xq)\n            \n        # Step 2: Interpolate along y using the intermediate values\n        pchip_y = PchipInterpolator(y_grid, y_interp_values)\n        final_value = pchip_y(yq)\n        \n        return final_value\n\n    # --------------------------------------------------------------------------\n    # 4. Evaluate errors at test query points\n    # --------------------------------------------------------------------------\n    test_cases = [\n        (3.90, -5.00),  # 1. center of hydrogen ionization bump\n        (3.92, -6.00),  # 2. steep gradient region near hydrogen bump\n        (4.20, -4.00),  # 3. center of helium I bump\n        (4.60, -6.50),  # 4. center of helium II bump\n        (4.80, -3.00),  # 5. smooth baseline region\n        (3.76, -2.10),  # 6. near low-x and high-y boundary\n        (4.99, -6.90),  # 7. near high-x and low-y boundary\n        (4.23, -5.50),  # 8. off-center near helium I bump\n    ]\n\n    results = []\n    for xq, yq in test_cases:\n        true_val = log_kappa_true(xq, yq)\n        \n        bilin_val = bilinear_interp(xq, yq, x_grid, y_grid, Z_table)\n        mono_val = monotonic_interp(xq, yq, x_grid, y_grid, Z_table)\n        \n        e_bilin = np.abs(bilin_val - true_val)\n        e_mono = np.abs(mono_val - true_val)\n        \n        results.extend([e_bilin, e_mono])\n\n    # --------------------------------------------------------------------------\n    # 5. Format and print the final output\n    # --------------------------------------------------------------------------\n    output_str = f\"[{','.join(f'{r:.8f}' for r in results)}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "恒星演化代码的核心是求解一组描述恒星结构和化学成分变化的耦合偏微分方程。本练习将带你探讨求解这些方程的两种基本数值策略：整体（monolithic）隐式方法和算子分裂（operator-splitting）方法。通过在一个简化的反应-扩散系统上实现这两种方法，你将直接量化分裂误差与时间步长的关系，并比较它们在精度和计算成本之间的权衡，这对于设计高效且可靠的模拟代码至关重要。",
            "id": "3534097",
            "problem": "构建一个完整的、可运行的程序，对一个代表简化恒星内部成分输运的线性反应扩散系统进行受控数值实验，以量化算子分裂误差与时间步长的关系，并将其精度和一种操作计数成本代理与整体隐式求解进行比较。该程序必须实现并比较 Strang 分裂法和整体后向欧拉法，用于解决周期性域上的线性双组分反应扩散问题，并且必须根据通过数值计算矩阵指数获得的精确离散参考解来计算它们的误差。在整个过程中使用无量纲单位。\n\n从以下基本原理和定义开始。考虑两个标量场 $u(x,t)$ 和 $v(x,t)$，它们在一个长度为 $L$ 的周期性区间上通过菲克扩散和线性质量作用动力学演化。设 $D_u$ 和 $D_v$ 为正扩散系数，并设可逆线性反应 $u \\rightleftharpoons v$ 的正向和反向速率常数分别为 $k_{1}$ 和 $k_{2}$。连续控制方程为反应扩散系统\n$$\n\\frac{\\partial u}{\\partial t} = D_u \\frac{\\partial^2 u}{\\partial x^2} - k_1 u + k_2 v,\n\\qquad\n\\frac{\\partial v}{\\partial t} = D_v \\frac{\\partial^2 v}{\\partial x^2} + k_1 u - k_2 v,\n$$\n在 $x$ 方向具有周期性边界条件。\n\n使用一个在区间 $[0,L)$ 上有 $N$ 个点的均匀网格对空间进行离散化，网格间距为 $\\Delta x = L/N$，并使用带周期性环绕的标准二阶中心有限差分拉普拉斯算子，因此对于网格函数 $w_i \\approx w(x_i)$，离散拉普拉斯算子 $\\mathcal{L}$ 的作用为\n$$\n(\\mathcal{L} w)_i = \\frac{w_{i+1} - 2 w_i + w_{i-1}}{\\Delta x^2},\n$$\n其中索引取模 $N$。将各组分按顺序 $U = [u_0, u_1, \\ldots, u_{N-1}, v_0, v_1, \\ldots, v_{N-1}]^{\\mathsf{T}}$ 堆叠成一个单一的状态向量 $U \\in \\mathbb{R}^{2N}$。那么，半离散系统是一个形为\n$$\n\\frac{\\mathrm{d}U}{\\mathrm{d}t} = A U,\n$$\n的线性常微分方程 (ODE)，其中系统矩阵 $A \\in \\mathbb{R}^{2N \\times 2N}$ 为\n$$\nA = \\begin{bmatrix}\nD_u \\mathcal{L} - k_1 I_N  k_2 I_N \\\\\nk_1 I_N  D_v \\mathcal{L} - k_2 I_N\n\\end{bmatrix},\n$$\n其中 $I_N$ 是 $N \\times N$ 单位矩阵，$\\mathcal{L}$ 是具有周期性边界条件的 $N \\times N$ 离散拉普拉斯矩阵。\n\n在最终时间 $T$ 上，使用时间步长 $\\Delta t$（其中 $T/\\Delta t$ 为整数）实现以下时间积分器：\n\n- 用于完整耦合系统的整体后向欧拉法（隐式），\n$$\n\\left(I_{2N} - \\Delta t \\, A\\right) U^{n+1} = U^n,\n$$\n应用于 $n = 0,1,\\ldots, T/\\Delta t - 1$。\n\n- 反应与扩散之间的 Strang 分裂。将在单个网格点上的纯反应算子 $R \\in \\mathbb{R}^{2 \\times 2}$ 定义为\n$$\nR = \\begin{bmatrix}\n- k_1  k_2 \\\\\nk_1  -k_2\n\\end{bmatrix}.\n$$\n一个大小为 $\\Delta t$ 的 Strang 分裂步通过以下步骤将 $U^n$ 推进到 $U^{n+1}$：\n  1. 半步反应：在每个网格点 $i$ 处，更新局部二元向量 $[u_i, v_i]^{\\mathsf{T}} \\leftarrow \\exp\\!\\left(\\tfrac{\\Delta t}{2} R\\right) [u_i, v_i]^{\\mathsf{T}}$。\n  2. 对每个组分分别使用后向欧拉法进行全步隐式扩散：\n  $$\n  \\left(I_N - \\Delta t \\, D_u \\mathcal{L}\\right) u \\leftarrow u, \\qquad \\left(I_N - \\Delta t \\, D_v \\mathcal{L}\\right) v \\leftarrow v,\n  $$\n  其中每一行表示为更新后的组分解一个线性系统。\n  3. 再次进行与步骤 1 相同的半步反应。\n\n使用矩阵指数解 $U(T) = \\exp(T A) U(0)$ 作为精确离散参考解，该解通过可靠的矩阵指数例程进行数值计算。\n\n使用以下固定参数和初始条件，均为无量纲单位：$L = 1$，$N = 32$，$D_u = 10^{-3}$，$D_v = 5 \\times 10^{-4}$，$k_1 = 40$，$k_2 = 10$，$T = 5 \\times 10^{-2}$。初始化\n$$\nu(x,0) = 1 + 10^{-1} \\sin\\!\\left(2 \\pi x / L\\right), \\qquad v(x,0) = 0,\n$$\n在网格点 $x_i = i \\Delta x$（其中 $i = 0,1,\\ldots,N-1$）上进行采样。\n\n对于每种方法，通过对两个组分和所有网格点的离散 $\\ell^2$-范数来量化在 $t = T$ 时的误差，\n$$\nE = \\left(\\Delta x \\sum_{i=0}^{N-1} \\left[ \\left(u_i^{\\mathrm{num}} - u_i^{\\mathrm{ref}}\\right)^2 + \\left(v_i^{\\mathrm{num}} - v_i^{\\mathrm{ref}}\\right)^2 \\right]\\right)^{1/2},\n$$\n其中参考解 $(u^{\\mathrm{ref}}, v^{\\mathrm{ref}})$ 由 $U(T) = \\exp(T A) U(0)$ 获得。\n\n通过代理操作计数来量化计算成本，该计数计算每步具有立方复杂度的稠密线性求解次数（以所求解系统的维度为准），并忽略与 $N$ 呈严格线性关系的成本。具体来说，将整体隐式方法的每步成本定义为 $(2N)^3$，将 Strang 分裂法的每步成本定义为 $2 N^3$（每个组分进行一次大小为 $N$ 的后向欧拉求解）。总成本是每步成本乘以步数 $T/\\Delta t$。\n\n设计一个包含三个时间步长的测试套件，以评估分裂误差与时间步长的关系，并比较不同尺度下的精度和成本：\n- 情况 A: $\\Delta t = 5 \\times 10^{-4}$，\n- 情况 B: $\\Delta t = 5 \\times 10^{-3}$，\n- 情况 C: $\\Delta t = 5 \\times 10^{-2}$。\n\n对于每种情况，按顺序计算并报告一个包含四个浮点数的列表 $[E_{\\text{split}}, E_{\\text{mono}}, C_{\\text{split}}, C_{\\text{mono}}]$，其中 $E_{\\text{split}}$ 是 Strang 分裂误差，$E_{\\text{mono}}$ 是整体后向欧拉误差，$C_{\\text{split}}$ 是 Strang 分裂方法的总成本代理，$C_{\\text{mono}}$ 是整体方法的总成本代理，所有值均在 $t = T$ 时计算。\n\n你的程序应生成单行输出，其中包含三个案例的结果，格式为一个由三个案例列表组成的逗号分隔列表，并用方括号括起来（例如，一个形如 $[[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]]$ 的列表的列表）。由于问题是无量纲的，不需要进行物理单位转换，所有报告的值都必须是纯浮点数。",
            "solution": "用户提供的问题是一个精心设计的数值实验，旨在比较两种不同时间积分方案求解线性反应扩散系统的精度和计算成本。该问题具有科学依据、数学上精确，并包含了获得唯一解所需的所有必要信息。因此，该问题被认为是有效的。我们继续进行完整求解。\n\n问题的核心是使用三种不同的方法求解半离散线性常微分方程（ODE）系统 $\\frac{\\mathrm{d}U}{\\mathrm{d}t} = AU$：整体隐式求解器、算子分裂隐式求解器和参考矩阵指数求解器。\n\n### 1. 系统离散化与矩阵表示\n\n首先，我们在均匀的周期性网格上离散化连续控制方程。系统的状态由一个向量 $U \\in \\mathbb{R}^{2N}$ 描述，该向量连接了两个组分 $u$ 和 $v$ 在 $N$ 个网格点上的浓度值：$U = [u_0, u_1, \\ldots, u_{N-1}, v_0, v_1, \\ldots, v_{N-1}]^{\\mathsf{T}}$。空间导数使用二阶中心有限差分格式近似。这产生了一个离散拉普拉斯算子，表示为一个 $N \\times N$ 矩阵 $\\mathcal{L}$。鉴于周期性边界条件，$\\mathcal{L}$ 是一个循环矩阵。具体来说，对于网格间距 $\\Delta x = L/N$，$\\mathcal{L}$ 的元素为 $(\\mathcal{L})_{i,i} = -2/\\Delta x^2$，$(\\mathcal{L})_{i,i\\pm 1} = 1/\\Delta x^2$（索引取模 $N$）。\n\n完整的半离散系统可以写为 $\\frac{\\mathrm{d}U}{\\mathrm{d}t} = AU$。系统矩阵 $A \\in \\mathbb{R}^{2N \\times 2N}$ 是一个由扩散和反应算子组成的分块矩阵：\n$$\nA = \\begin{bmatrix}\nD_u \\mathcal{L} - k_1 I_N  k_2 I_N \\\\\nk_1 I_N  D_v \\mathcal{L} - k_2 I_N\n\\end{bmatrix}\n$$\n其中 $I_N$ 是 $N \\times N$ 单位矩阵。该矩阵将在程序中显式构造。\n\n### 2. 数值积分方法\n\n**a. 精确离散参考解**\n对于线性系统 $\\dot{U} = AU$，从初始状态 $U(0)$ 开始，在时间间隔 $T$ 内的精确解由矩阵指数的作用给出：$U(T) = \\exp(TA)U(0)$。我们使用 `scipy.linalg.expm` 函数高精度地计算此参考解，该函数实现了一种稳健的矩阵指数算法。这为评估其他方法提供了基准。\n\n**b. 整体后向欧拉法**\n后向欧拉法是一种一阶、A-稳定的隐式积分器。对于整个系统，从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个时间步长由下式给出：\n$$\n\\frac{U^{n+1} - U^n}{\\Delta t} = A U^{n+1} \\implies \\left(I_{2N} - \\Delta t A\\right) U^{n+1} = U^n\n$$\n为了推进求解，我们必须在每个时间步求解这个 $2N \\times 2N$ 的线性系统以获得 $U^{n+1}$。对于固定的 $\\Delta t$，矩阵 $(I_{2N} - \\Delta t A)$ 是常数，因此可以在时间步进循环开始前构造一次。然后使用 `scipy.linalg.solve` 求解该线性系统。\n\n**c. Strang 分裂法**\n算子分裂法将一个复杂的算子分解为更简单的部分。这里，我们将系统矩阵 $A$ 分裂为扩散部分 $A_D$ 和反应部分 $A_R$，使得 $A = A_D + A_R$。\n$$\nA_D = \\begin{bmatrix} D_u \\mathcal{L}  0 \\\\ 0  D_v \\mathcal{L} \\end{bmatrix}, \\quad A_R = \\begin{bmatrix} -k_1 I_N  k_2 I_N \\\\ k_1 I_N  -k_2 I_N \\end{bmatrix}\n$$\nStrang 分裂是一种二阶精确的方案，它通过对称地应用子问题传播子来近似解：\n$$\nU^{n+1} \\approx \\exp\\left(\\frac{\\Delta t}{2} A_R\\right) \\exp\\left(\\Delta t A_D\\right) \\exp\\left(\\frac{\\Delta t}{2} A_R\\right) U^n\n$$\n实现遵循以下三个步骤：\n1.  **半步反应：** 反应部分 $A_R$ 仅在同一网格点上耦合不同组分。我们可以将反应传播子 $\\exp(\\frac{\\Delta t}{2} R)$ 应用于每个 $[u_i, v_i]^{\\mathsf{T}}$ 对，其中 $R = \\begin{bmatrix}-k_1  k_2 \\\\ k_1  -k_2 \\end{bmatrix}$。这是通过一次性计算 $2 \\times 2$ 矩阵指数并以向量化方式将其应用于所有网格点来完成的。\n2.  **全步扩散：** 扩散算子 $A_D$ 是块对角矩阵，这意味着组分 $u$ 和 $v$ 的扩散是相互解耦的。我们使用后向欧拉法隐式求解此步骤：\n    $$\n    u \\leftarrow (I_N - \\Delta t D_u \\mathcal{L})^{-1} u, \\quad v \\leftarrow (I_N - \\Delta t D_v \\mathcal{L})^{-1} v\n    $$\n    这需要求解两个独立的 $N \\times N$ 线性系统，其计算成本低于求解一个 $2N \\times 2N$ 系统。\n3.  **半步反应：** 应用第二个对称的反应步。\n\n### 3. 误差与成本评估\n\n在将每个模拟运行到最终时间 $T$ 后，我们量化其性能。\n-   **误差：** 精度通过数值解（$U^{\\mathrm{num}}$）与参考解（$U^{\\mathrm{ref}}$）之差的离散 $\\ell^2$-范数来衡量：\n    $$\n    E = \\left(\\Delta x \\sum_{i=0}^{N-1} \\left[ \\left(u_i^{\\mathrm{num}} - u_i^{\\mathrm{ref}}\\right)^2 + \\left(v_i^{\\mathrm{num}} - v_i^{\\mathrm{ref}}\\right)^2 \\right]\\right)^{1/2} = \\sqrt{\\Delta x} \\, \\| U^{\\mathrm{num}} - U^{\\mathrm{ref}} \\|_2\n    $$\n-   **成本：** 计算成本使用一个代理来估计。对于大小为 $M$ 的线性系统，假定稠密求解的成本为 $M^3$ 次操作。总成本是此每步成本乘以步数 $T/\\Delta t$。\n    -   整体法成本：$C_{\\text{mono}} = (2N)^3 \\times (T/\\Delta t)$\n    -   分裂法成本：$C_{\\text{split}} = (N^3 + N^3) \\times (T/\\Delta t) = 2N^3 \\times (T/\\Delta t)$\n\n程序遍历指定的 $\\Delta t$ 值，为每个值计算这四个度量，并以要求的格式报告结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm, solve, circulant\n\ndef solve_problem():\n    \"\"\"\n    Implements and compares monolithic and Strang-split time integration methods\n    for a linear reaction-diffusion system, evaluating them against a matrix\n    exponential reference solution.\n    \"\"\"\n    \n    # 1. Define fixed parameters and initial conditions in dimensionless units\n    L = 1.0\n    N = 32\n    Du = 1e-3\n    Dv = 5e-4\n    k1 = 40.0\n    k2 = 10.0\n    T = 5e-2\n\n    # Define the test cases for the timestep dt\n    test_cases_dt = [\n        5e-4,  # Case A\n        5e-3,  # Case B\n        5e-2   # Case C\n    ]\n    \n    # 2. Set up the spatial grid and initial state vector U0\n    dx = L / N\n    x = np.arange(N) * dx\n    u0 = 1.0 + 0.1 * np.sin(2 * np.pi * x / L)\n    v0 = np.zeros(N)\n    U0 = np.concatenate([u0, v0])\n\n    # 3. Construct the discrete operators and the full system matrix A\n    # Construct the N x N periodic discrete Laplacian matrix L\n    laplacian_col = np.zeros(N)\n    laplacian_col[0] = -2.0\n    laplacian_col[1] = 1.0\n    laplacian_col[-1] = 1.0  # Periodicity\n    L_matrix = circulant(laplacian_col) / (dx**2)\n    \n    # Construct the 2N x 2N system matrix A\n    I_N = np.identity(N)\n    A_uu = Du * L_matrix - k1 * I_N\n    A_uv = k2 * I_N\n    A_vu = k1 * I_N\n    A_vv = Dv * L_matrix - k2 * I_N\n    A = np.block([[A_uu, A_uv], [A_vu, A_vv]])\n\n    # 4. Compute the exact discrete reference solution at time T\n    # U(T) = exp(T * A) * U(0)\n    U_ref = expm(T * A) @ U0\n\n    # List to store the results for each test case\n    results = []\n\n    # 5. Loop over the test cases defined by different timesteps\n    for dt in test_cases_dt:\n        num_steps = int(round(T / dt))\n\n        # --- Solve with Monolithic Backward Euler ---\n        U_mono = U0.copy()\n        # Pre-compute the matrix for the linear system\n        M_mono = np.identity(2 * N) - dt * A\n        for _ in range(num_steps):\n            U_mono = solve(M_mono, U_mono, assume_a='gen')\n\n        # --- Solve with Strang Splitting ---\n        U_split = U0.copy()\n        \n        # Pre-compute the reaction propagator matrix for a half time-step\n        R = np.array([[-k1, k2], [k1, -k2]], dtype=float)\n        Prop_R_half = expm(0.5 * dt * R)\n\n        # Pre-compute matrices for the implicit diffusion solves\n        M_diff_u = np.identity(N) - dt * Du * L_matrix\n        M_diff_v = np.identity(N) - dt * Dv * L_matrix\n\n        for _ in range(num_steps):\n            u_current = U_split[:N]\n            v_current = U_split[N:]\n            \n            # Form a 2xN array for vectorized reaction calculation\n            uv_current = np.stack([u_current, v_current])\n            \n            # Step 1: Half reaction step\n            uv_reacted1 = Prop_R_half @ uv_current\n            \n            # Step 2: Full diffusion step (implicit)\n            u_diffused = solve(M_diff_u, uv_reacted1[0, :], assume_a='gen')\n            v_diffused = solve(M_diff_v, uv_reacted1[1, :], assume_a='gen')\n            \n            # Form a 2xN array for the second reaction step\n            uv_diffused_stack = np.stack([u_diffused, v_diffused])\n            \n            # Step 3: Second half reaction step\n            uv_reacted2 = Prop_R_half @ uv_diffused_stack\n            \n            # Reconstruct the flat state vector\n            U_split = np.concatenate([uv_reacted2[0, :], uv_reacted2[1, :]])\n        \n        # 6. Quantify error and computational cost\n        # Error calculation using the specified discrete l2-norm\n        err_split = np.sqrt(dx) * np.linalg.norm(U_split - U_ref)\n        err_mono = np.sqrt(dx) * np.linalg.norm(U_mono - U_ref)\n        \n        # Cost proxy calculation\n        cost_split = float(2 * (N**3) * num_steps)\n        cost_mono = float((2 * N)**3 * num_steps)\n        \n        # Append results for the current test case\n        results.append([err_split, err_mono, cost_split, cost_mono])\n\n    # 7. Format and print the final output\n    case_strings = [f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    print(final_output_string)\n\n\n# Execute the main function\nsolve_problem()\n```"
        },
        {
            "introduction": "对于需要模拟数十亿年演化史的恒星模型而言，计算效率是决定性的。这个高级实践将自适应时间步长选择问题提升到了一个新高度，将其构建为一个最优控制问题，目标是在满足局部截断误差约束的前提下最小化总计算成本。通过使用动态规划解决这个模型问题，你将学习到一种前沿的、旨在实现全局最优效率的步长控制策略，而不仅仅是局限于传统的局部误差控制。",
            "id": "3534082",
            "problem": "设计并实现一个程序，将积分热脉冲恒星包层模型的自适应时间步长选择问题，构建为一个离散最优控制问题。其目标是最小化总计算成本，同时对每个被接受的步长强制施加一个局部截断误差的界限。模型、容许控制、约束和目标函数应从第一性原理推导，并通过动态规划求解。\n\n考虑一个标量常微分方程，该方程模拟了由冷却和外部脉冲驱动的、围绕一个基础温度的温度波动，\n$$\n\\frac{dT}{dt} = -\\lambda\\,(T - T_{\\mathrm{base}}) + S_T(t),\n$$\n其中 $T$ 是温度（单位为开尔文），$t$ 是时间（单位为年），$\\lambda = 1/\\tau_{\\mathrm{cool}}$，$\\tau_{\\mathrm{cool}}$ 是冷却时间尺度（单位为年），$T_{\\mathrm{base}}$ 是基础温度，$S_T(t)$ 是模拟热脉冲的外部热源。为了改善数值条件，使用一个固定的标度 $T_{\\mathrm{scale}}$ 对温度进行无量纲化，并定义 $x = (T - T_{\\mathrm{base}})/T_{\\mathrm{scale}}$。用 $x$ 表示，该系统变为\n$$\n\\frac{dx}{dt} = f(t,x) = -\\lambda\\,x + S_x(t),\n$$\n其中 $S_x(t) = S_T(t)/T_{\\mathrm{scale}}$。\n\n你将使用显式梯形法则（也称为 Heun 方法）来将解从 $t$ 推进到 $t + \\Delta t$，\n$$\nx_{\\mathrm{Heun}}(t+\\Delta t) = x(t) + \\frac{\\Delta t}{2}\\Big(f(t,x(t)) + f(t+\\Delta t, x(t) + \\Delta t\\,f(t,x(t)))\\Big).\n$$\n作为局部截断误差的估计器，将其与前向欧拉法进行比较，\n$$\nx_{\\mathrm{Euler}}(t+\\Delta t) = x(t) + \\Delta t\\,f(t,x(t)),\n$$\n并使用两者差值的绝对值，\n$$\ne(t,\\Delta t; x) = \\left|x_{\\mathrm{Heun}}(t+\\Delta t) - x_{\\mathrm{Euler}}(t+\\Delta t)\\right|,\n$$\n作为局部截断误差的代理。从三角不等式和 $f$ 关于 $x$ 的线性性质推导出该估计器可以被如下方式上界约束\n$$\ne(t,\\Delta t; x) \\leq \\frac{\\Delta t}{2}\\left(\\left|f(t,x)\\right| + \\left|f\\Big(t+\\Delta t, x + \\Delta t\\,f(t,x)\\Big)\\right|\\right).\n$$\n假设对 $x$ 在物理上合理的范围有一个保守的统一界限，即对于所有 $t \\in [0, t_{\\mathrm{end}}]$，都有 $\\left|x(t)\\right| \\leq M$，其中 $M$ 为给定值。使用这个条件推导一个可计算的、与状态无关的上界\n$$\n\\hat{e}(t,\\Delta t) = \\frac{\\Delta t}{2}\\left(\\lambda M + \\left|S_x(t)\\right| + \\lambda\\Big(M + \\Delta t\\big(\\lambda M + \\left|S_x(t)\\right|\\big)\\Big) + \\left|S_x(t+\\Delta t)\\right|\\right),\n$$\n该上界保证了当 $\\left|x\\right| \\le M$ 时，必有 $e(t,\\Delta t; x) \\le \\hat{e}(t,\\Delta t)$。\n\n在一个均匀的候选决策时间网格 $\\{t_i\\}_{i=0}^N$（其中 $t_0=0$, $t_N=t_{\\mathrm{end}}$, 且 $t_{i+1}-t_i=\\delta t_{\\min}$）上，将步长选择构建为一个离散最优控制问题。在每个决策时间，控制动作是选择一个步长 $\\Delta t \\in \\mathcal{U}$，其中\n$$\n\\mathcal{U} = \\left\\{k\\,\\delta t_{\\min}\\ \\middle|\\ k \\in \\mathbb{Z},\\ 1 \\le k \\le K_{\\max},\\ k\\,\\delta t_{\\min} \\le \\Delta t_{\\max}\\right\\}.\n$$\n从 $t_i$ 到 $t_j=t_i+\\Delta t$ 的一步是容许的，当且仅当对于给定的容差 $\\varepsilon$，有 $\\hat{e}(t_i,\\Delta t) \\le \\varepsilon$；否则该步被禁止。计算成本是所有被接受的 Heun 步所使用的右端项 $f$ 的求值总次数，即每个被接受的步长两次求值。目标是在所有步长都满足局部截断误差约束的条件下，最小化总计算成本。使用动态规划（反向归纳）求解离散时间域上的最小成本策略，然后，使用得到的步长序列，以 Heun 方法从 $x(0)=0$ 开始积分系统，得到 $x(t_{\\mathrm{end}})$，并将其转换回温度 $T(t_{\\mathrm{end}})$（单位为开尔文）。\n\n热脉冲强迫项由一系列高斯脉冲之和给出，\n$$\nS_x(t) = A \\sum_{k=1}^{n_p} \\exp\\!\\left(-\\frac{(t - t_k)^2}{2\\sigma^2}\\right),\n$$\n其中 $A$ 是无量纲振幅，满足 $A = S_{T,\\mathrm{amp}}/T_{\\mathrm{scale}}$，$\\{t_k\\}$ 是脉冲时间，$\\sigma$ 是脉冲宽度（单位为年）。\n\n使用以下参数值，这些值对于简化的恒星包层模型是科学上合理的，并为数值稳定性进行了缩放：\n- $T_{\\mathrm{base}} = 1.0\\times 10^7$ K。\n- $T_{\\mathrm{scale}} = 1.0\\times 10^6$ K。\n- $\\tau_{\\mathrm{cool}} = 50$ 年，因此 $\\lambda = 1/\\tau_{\\mathrm{cool}}$。\n- 脉冲时间 $\\{t_k\\} = \\{2.0, 5.0, 8.0\\}$ 年，宽度 $\\sigma = 0.05$ 年，有量纲的振幅 $S_{T,\\mathrm{amp}} = 2.0\\times 10^5$ K，所以 $A = 0.2$。\n- 决策网格步长 $\\delta t_{\\min} = 0.0025$ 年，最大步长 $\\Delta t_{\\max} = 0.25$ 年。\n- 积分区间结束时间 $t_{\\mathrm{end}} = 10.0$ 年。\n- 保守界限 $M = 0.4$。\n\n你的程序必须：\n1. 从最优性原理出发，推导出动态规划的递推关系式，并使用容许性约束 $\\hat{e}(t_i,\\Delta t) \\le \\varepsilon$ 来定义时间网格上的允许转移。\n2. 计算一个使总成本最小化的最优步长序列 $\\{\\Delta t_m\\}$。\n3. 沿着所选的步长，用 Heun 方法积分该系统，计算出 $T(t_{\\mathrm{end}})$（单位为开尔文）。\n4. 对每个测试，报告一个三元组 $\\big[n_{\\mathrm{steps}}, n_{\\mathrm{evals}}, T(t_{\\mathrm{end}})\\big]$，其中 $n_{\\mathrm{steps}}$ 是被接受的步数（整数），$n_{\\mathrm{evals}}$ 是 Heun 方法使用的右端项求值总次数（每个被接受的步长两次，为整数），$T(t_{\\mathrm{end}})$ 是最终温度（单位为开尔文，四舍五入到最近的整数）。\n\n时间单位为年，温度单位为开尔文。所有角度（如果有的话）在这里都是无关的。\n\n测试套件和要求的输出格式：\n- 使用容差 $\\varepsilon \\in \\{10^{-2}, 5\\times 10^{-3}, 10^{-3}\\}$（在 $x$ 单位下是无量纲的）。\n- 对于每个 $\\varepsilon$，你的程序应解决动态规划问题并计算最终温度。\n- 你的程序应产生单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果，每个元素本身是形如 $[n_{\\mathrm{steps}}, n_{\\mathrm{evals}}, T_{\\mathrm{final}}]$ 的列表。例如： \"[[n1,c1,T1],[n2,c2,T2],[n3,c3,T3]]\"。",
            "solution": "该问题要求设计一种自适应步长方案，用于积分一个模拟恒星包层中温度波动的标量常微分方程（ODE）。该方案必须被构建为一个离散最优控制问题，并使用动态规划来求解，以在满足局部误差容差的同时最小化计算成本。\n\n该系统由以下无量纲化的 ODE 描述：\n$$\n\\frac{dx}{dt} = f(t,x) = -\\lambda\\,x + S_x(t)\n$$\n其中 $x$ 是无量纲温度，$t$ 是时间，$\\lambda$ 是冷却时间尺度的倒数，$S_x(t)$ 是一个热脉冲源。初始条件给定为 $x(0)=0$。\n\n问题的核心是找到一个最优的时间步长序列 $\\{\\Delta t_m\\}$，将系统从 $t=0$ 积分到 $t=t_{\\mathrm{end}}$，该序列能在每一步都满足误差约束的前提下，最小化函数求值的总次数。\n\n### 1. 最优控制公式化\n我们将时间域 $[0, t_{\\mathrm{end}}]$ 离散化为一个包含 $N+1$ 个决策点的均匀网格 $\\{t_i\\}_{i=0}^N$，其中 $t_i = i \\cdot \\delta t_{\\min}$ 且 $t_N = t_{\\mathrm{end}}$。\n- **状态（States）：** 控制问题的状态是离散的时间索引 $i \\in \\{0, 1, \\dots, N\\}$。\n- **控制（Controls）：** 在任何时间 $t_i$，控制动作是从一个离散集合 $\\mathcal{U} = \\{k \\cdot \\delta t_{\\min} \\mid k \\in \\mathbb{Z}, 1 \\le k \\le K_{\\max}\\}$ 中选择一个步长 $\\Delta t$，其中 $K_{\\max} \\cdot \\delta t_{\\min} \\le \\Delta t_{\\max}$。一个大小为 $\\Delta t = k \\cdot \\delta t_{\\min}$ 的步长将系统从状态 $i$ 带到状态 $i+k$。\n- **约束（Constraint）：** 从 $t_i$ 到 $t_{i+k}$ 的一步是容许的，当且仅当局部截断误差的与状态无关的上界 $\\hat{e}(t_i, \\Delta t)$ 不大于预设的容差 $\\varepsilon$。即 $\\hat{e}(t_i, k \\cdot \\delta t_{\\min}) \\le \\varepsilon$。\n误差界限由下式给出：\n$$\n\\hat{e}(t,\\Delta t) = \\frac{\\Delta t}{2}\\left(\\lambda M + \\left|S_x(t)\\right| + \\lambda\\Big(M + \\Delta t\\big(\\lambda M + \\left|S_x(t)\\right|\\big)\\Big) + \\left|S_x(t+\\Delta t)\\right|\\right)\n$$\n- **目标函数（Objective Function）：** 使用 Heun 方法走一步的成本是 $2$ 次函数求值。目标是最小化总成本，即为到达 $t_{\\mathrm{end}}$ 所采取的所有步长的成本之和。\n\n### 2. 动态规划解法\n这个问题结构适合用动态规划（DP）来解决。我们定义一个价值函数 $J(i)$，表示从时间索引 $i$ 到最终时间索引 $N$ 的最小未来成本（cost-to-go）。\n\n- **最优性原理（Principle of Optimality）：** 从状态 $i$ 出发的最优成本，是在所有容许的控制中，取“单步即时成本”与“从后续状态出发的最优成本”之和的最小值。\n- **贝尔曼方程（Bellman Equation）：** 价值函数 $J(i)$ 遵循以下被称为贝尔曼方程的反向递推关系：\n$$\nJ(i) = \\min_{k \\in \\{1, \\dots, K_{\\max}\\} \\text{ s.t. } i+k \\le N} \\Big\\{ \\text{Cost}(i, k) + J(i+k) \\Big\\}\n$$\n步长成本 $\\text{Cost}(i,k)$ 基于容许性约束定义：\n$$\n\\text{Cost}(i,k) = \\begin{cases} 2  \\text{if } \\hat{e}(t_i, k \\cdot \\delta t_{\\min}) \\le \\varepsilon \\\\ \\infty  \\text{otherwise} \\end{cases}\n$$\n- **边界条件（Boundary Condition）：** 在最终时间 $t_N$ 时，不再需要任何步长，因此成本为零：$J(N) = 0$。\n- **反向归纳（Backward Induction）：** 我们通过从 $i=N$ 开始并向后迭代到 $i=0$ 来求解 $J(i)$。对于每个状态 $i$，我们测试所有可能的前向步长 $k$，检查其容许性，并用找到的最小成本更新 $J(i)$。同时，我们将最优控制（即实现最小值的 $k$）存储在一个策略数组 $\\pi(i) = k^*$ 中。\n\n### 3. 最优积分路径\n反向归纳完成后，策略数组 $\\pi(i)$ 包含了在每个时间点 $t_i$ 的最优步长选择（作为 $\\delta t_{\\min}$ 的整数倍）。然后，我们可以构建最优的时间步长序列并对 ODE 进行积分。\n\n1.  从 $t_c=0$, $x_c=0$ 和时间索引 $i_c=0$ 开始。\n2.  第一个时间步长是 $\\Delta t_0 = \\pi(0) \\cdot \\delta t_{\\min}$。\n3.  使用 Heun 方法将解从 $(t_c, x_c)$ 推进到 $(t_c+\\Delta t_0, x_{\\text{new}})$：\n    - $k_1 = f(t_c, x_c)$\n    - $k_2 = f(t_c + \\Delta t_0, x_c + \\Delta t_0 \\cdot k_1)$\n    - $x_{\\text{new}} = x_c + \\frac{\\Delta t_0}{2}(k_1 + k_2)$\n4.  更新当前状态：$t_c \\leftarrow t_c + \\Delta t_0$, $x_c \\leftarrow x_{\\text{new}}$，以及 $i_c \\leftarrow i_c + \\pi(i_c)$。\n5.  从第 2 步开始，使用新索引 $i_c$ 处的策略重复此过程，直到 $t_c$ 到达 $t_{\\mathrm{end}}$。\n\n### 4. 最终计算\n积分得到最终的无量纲温度 $x(t_{\\mathrm{end}})$。使用变换 $T = T_{\\mathrm{scale}} \\cdot x + T_{\\mathrm{base}}$ 将其转换回物理温度（单位为开尔文）。然后按要求将结果四舍五入到最近的整数。总步数和函数求值次数（步数的 2 倍）也被记录下来。对每个指定的误差容差 $\\varepsilon$ 重复整个过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the adaptive timestepping problem using dynamic programming for multiple error tolerances.\n    \"\"\"\n    #\n    # Problem Parameters\n    #\n    T_base = 1.0e7  # K\n    T_scale = 1.0e6  # K\n    tau_cool = 50.0  # years\n    lambda_val = 1.0 / tau_cool  # 1/years\n    pulse_times = np.array([2.0, 5.0, 8.0])  # years\n    sigma = 0.05  # years\n    S_T_amp = 2.0e5  # K\n    A = S_T_amp / T_scale  # dimensionless\n    dt_min = 0.0025  # years\n    dt_max = 0.25  # years\n    t_end = 10.0  # years\n    M = 0.4  # dimensionless bound on |x|\n    test_epsilons = [1e-2, 5e-3, 1e-3] # dimensionless\n\n    #\n    # Physical and Numerical Model Functions\n    #\n    def S_x(t_in):\n        \"\"\"\n        Calculates the non-dimensional thermal pulse forcing term S_x(t).\n        Vectorized to handle scalar or array inputs for time t.\n        \"\"\"\n        t = np.asarray(t_in).reshape(-1, 1)\n        pulse_times_row = pulse_times.reshape(1, -1)\n        exponents = -((t - pulse_times_row)**2) / (2 * sigma**2)\n        sum_gaussians = np.sum(np.exp(exponents), axis=1)\n        # Squeeze to return scalar for scalar input, 1D array for 1D array input\n        return (A * sum_gaussians).squeeze()\n\n    def f(t, x):\n        \"\"\"\n        The right-hand side of the non-dimensionalized ODE: dx/dt = f(t,x).\n        \"\"\"\n        return -lambda_val * x + S_x(t)\n\n    # Main loop over different tolerance values\n    results = []\n    for epsilon in test_epsilons:\n        #\n        # 1. Dynamic Programming (Backward Induction) to find the optimal policy\n        #\n        N = int(round(t_end / dt_min))\n        K_max = int(round(dt_max / dt_min))\n        \n        t_grid = np.linspace(0.0, t_end, N + 1)\n        Sx_grid = S_x(t_grid)\n        \n        cost = np.full(N + 1, np.inf)\n        policy = np.zeros(N + 1, dtype=int)\n        \n        cost[N] = 0.0 # Cost-to-go from the end is 0\n        \n        # Iterate backward from the penultimate time-step\n        for i in range(N - 1, -1, -1):\n            Sx_i = Sx_grid[i]\n            \n            # Iterate through all possible step sizes k\n            for k in range(1, min(K_max, N - i) + 1):\n                dt = k * dt_min\n                Sx_ik = Sx_grid[i + k]\n                \n                # Calculate the state-independent error bound e_hat\n                term1 = lambda_val * M + np.abs(Sx_i)\n                term2 = lambda_val * (M + dt * term1) + np.abs(Sx_ik)\n                e_hat = (dt / 2.0) * (term1 + term2)\n                \n                # Check admissibility constraint\n                if e_hat = epsilon:\n                    current_total_cost = 2.0 + cost[i + k]\n                    \n                    if current_total_cost  cost[i]:\n                        cost[i] = current_total_cost\n                        policy[i] = k\n        \n        #\n        # 2. Forward Integration using the Optimal Policy\n        #\n        n_steps = 0\n        current_idx = 0\n        current_x = 0.0\n        \n        while current_idx  N:\n            k = policy[current_idx]\n            \n            if k == 0:\n                # No admissible path was found from this state. This indicates\n                # an issue if cost[0] is not inf. For a well-posed problem\n                # as given, a solution should exist.\n                # If cost[0] is inf, no solution exists. We'll assume one does.\n                # This could happen if even the smallest step violates the error bound.\n                raise ValueError(f\"No admissible policy found at time index {current_idx}\")\n            \n            dt = k * dt_min\n            current_t = current_idx * dt_min\n            \n            # Heun's method step\n            f1 = f(current_t, current_x)\n            x_pred = current_x + dt * f1\n            f2 = f(current_t + dt, x_pred)\n            current_x = current_x + 0.5 * dt * (f1 + f2)\n\n            current_idx += k\n            n_steps += 1\n            \n        n_evals = 2 * n_steps\n        T_final = current_x * T_scale + T_base\n        \n        results.append([n_steps, n_evals, int(round(T_final))])\n\n    # Final print statement must match the required format exactly.\n    # str(results) produces '[[...], [...]]' with spaces.\n    # The requirement seems to be no spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        }
    ]
}