{
    "hands_on_practices": [
        {
            "introduction": "Before any time evolution can begin, a numerical relativity simulation requires a physically valid initial snapshot of the spacetime. This means the initial data must satisfy the Hamiltonian and momentum constraint equations of General Relativity. This practice  introduces the \"Method of Manufactured Solutions,\" a cornerstone verification technique where an analytical solution is prescribed to test the accuracy of a numerical scheme. You will discretize the constraint equations and confirm that the numerical error converges to zero at the theoretically expected rate, a critical skill for building confidence in any simulation code.",
            "id": "3533369",
            "problem": "You are tasked with constructing and analyzing discrete evaluations of the general relativity constraints on a single spatial slice suitable for compact-object merger simulations. Work within the standard $3+1$ decomposition and use geometrized units with $G=c=1$ so that all quantities are dimensionless. Begin from the Arnowitt–Deser–Misner (ADM) constraints, which are considered part of the foundational laws for numerical relativity initial data:\n- The Hamiltonian constraint is $\\mathcal{H} \\equiv R + K^2 - K_{ij} K^{ij} - 16\\pi \\rho$, where $R$ is the scalar curvature of the spatial metric, $K_{ij}$ is the extrinsic curvature, $K \\equiv \\gamma^{ij} K_{ij}$ is its trace, and $\\rho$ is the energy density measured by the Eulerian observer.\n- The momentum constraint is $\\mathcal{M}_i \\equiv D_j\\!\\left(K^j{}_i - \\delta^j{}_i K\\right) - 8\\pi S_i$, where $D_j$ is the metric-compatible covariant derivative associated with $\\gamma_{ij}$, and $S_i$ is the momentum density.\n\nTo ensure a scientifically realistic and controlled setting, consider a conformally flat spatial metric on a cubic domain $[-L,L]^3$ with $L=1$, namely $\\gamma_{ij} = \\psi^4 \\delta_{ij}$, and an isotropic extrinsic curvature proportional to the metric, $K_{ij} = \\kappa(\\mathbf{x})\\,\\gamma_{ij}$. Choose smooth, compactly supported fields that typify black hole–neutron star merger initial data generation:\n- Conformal factor $\\psi(\\mathbf{x}) = 1 + A\\,\\exp\\!\\left(-\\frac{x^2 + y^2 + z^2}{\\sigma^2}\\right)$,\n- Curvature amplitude $\\kappa(\\mathbf{x}) = B\\,\\sin(\\pi x)\\,\\sin(\\pi y)\\,\\sin(\\pi z)$.\n\nDerive from the ADM constraints the expressions for the matter fields $\\rho$ and $S_i$ that make the continuum constraints identically satisfied for the above ansatz. Explicitly:\n- Express $R$ in terms of $\\psi$ and its derivatives under conformal flatness.\n- Express $K$ and $K_{ij}K^{ij}$ in terms of $\\kappa$ and the metric.\n- Express $D_j\\!\\left(K^j{}_i - \\delta^j{}_i K\\right)$ in terms of $\\kappa$, $\\psi$, and their derivatives.\n\nImplement second-order central finite differences on a uniform grid of $N^3$ points with $N \\in \\{33,49,65\\}$. Let $h = 2L/(N-1)$ be the grid spacing. Use only interior points (excluding boundaries) when computing derivatives and norms. At each resolution:\n- Approximate derivatives with second-order central differences.\n- Compute the discrete Hamiltonian residual $\\mathcal{H}_{\\text{num}}$ and momentum residual vector $\\mathcal{M}_{i,\\text{num}}$ over the interior.\n- Compute the $L_2$ norm of the Hamiltonian residual, defined as the square root of the mean of $\\mathcal{H}_{\\text{num}}^2$ over interior points.\n- Compute the $L_2$ norm of the momentum residual by first forming the pointwise squared norm $\\mathcal{M}_{x,\\text{num}}^2 + \\mathcal{M}_{y,\\text{num}}^2 + \\mathcal{M}_{z,\\text{num}}^2$ and then taking the square root of its mean over interior points.\n\nAnalyze the observed convergence order with respect to $h$ for both constraints under second-order differencing. For each test case, estimate the order $p$ by comparing $L_2$ residuals at successive resolutions via $p \\equiv \\log\\!\\left(e(h_1)/e(h_2)\\right)/\\log\\!\\left(h_1/h_2\\right)$, where $e(h)$ denotes the $L_2$ residual at spacing $h$. Compute this between $(N=33,N=49)$ and $(N=49,N=65)$ and report the average value for the Hamiltonian and for the momentum constraints separately.\n\nUse the following test suite of parameter values to probe different regimes:\n1. Case 1 (happy path): $A=0.2$, $\\sigma=0.6$, $B=0.05$.\n2. Case 2 (broad conformal bump): $A=0.1$, $\\sigma=0.9$, $B=0.04$.\n3. Case 3 (narrow, stronger curvature): $A=0.5$, $\\sigma=0.4$, $B=0.08$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a two-element list of floats $[p_{\\mathcal{H}},p_{\\mathcal{M}}]$. For example, the output should look like \"[[pH_case1,pM_case1],[pH_case2,pM_case2],[pH_case3,pM_case3]]\". All outputs are dimensionless, expressed as floats with no units or percent signs.",
            "solution": "We start from the Arnowitt–Deser–Misner (ADM) constraints, which are foundational in numerical relativity for constructing initial data:\n$$\n\\mathcal{H} \\equiv R + K^2 - K_{ij}K^{ij} - 16\\pi \\rho,\n$$\n$$\n\\mathcal{M}_i \\equiv D_j\\!\\left(K^j{}_i - \\delta^j{}_i K\\right) - 8\\pi S_i.\n$$\nWe prescribe a conformally flat spatial metric $\\gamma_{ij} = \\psi^4 \\delta_{ij}$ and an isotropic extrinsic curvature $K_{ij} = \\kappa(\\mathbf{x})\\,\\gamma_{ij}$. This choice is common and scientifically realistic in compact object merger initial data. The unknown matter fields $\\rho$ and $S_i$ are to be chosen such that the continuum constraints are satisfied exactly.\n\nStep 1: Geometric identities under conformal flatness. For $\\gamma_{ij} = \\psi^4 \\delta_{ij}$, the scalar curvature is\n$$\nR = -8\\,\\psi^{-5}\\,\\nabla^2 \\psi,\n$$\nwhere $\\nabla^2$ is the flat-space Laplacian with respect to $\\delta_{ij}$. The Christoffel symbols of the spatial metric are\n$$\n\\Gamma^i{}_{jk} = 2\\left(\\delta^i{}_j\\,\\partial_k \\ln\\psi + \\delta^i{}_k\\,\\partial_j \\ln\\psi - \\delta_{jk}\\,\\delta^{im}\\,\\partial_m \\ln\\psi\\right),\n$$\nwhose trace over the first two indices is\n$$\n\\Gamma^j{}_{jk} = 6\\,\\partial_k \\ln\\psi.\n$$\n\nStep 2: Extrinsic curvature contractions. With $K_{ij} = \\kappa\\,\\gamma_{ij}$, we obtain\n$$\nK \\equiv \\gamma^{ij} K_{ij} = \\gamma^{ij}\\,\\kappa\\,\\gamma_{ij} = \\kappa\\,\\delta^i{}_i = 3\\,\\kappa,\n$$\nand\n$$\nK_{ij}K^{ij} = \\kappa\\,\\gamma_{ij}\\;\\kappa\\,\\gamma^{ij} = 3\\,\\kappa^2.\n$$\nTherefore\n$$\nK^2 - K_{ij}K^{ij} = 9\\kappa^2 - 3\\kappa^2 = 6\\kappa^2.\n$$\n\nStep 3: Momentum constraint divergence. Define $T^j{}_i \\equiv K^j{}_i - \\delta^j{}_i K$. With one index raised, $K^j{}_i = \\gamma^{jk}K_{ki} = \\gamma^{jk}\\,\\kappa\\,\\gamma_{ki} = \\kappa\\,\\delta^j{}_i$. Thus\n$$\nT^j{}_i = \\kappa\\,\\delta^j{}_i - \\delta^j{}_i K = -2\\,\\kappa\\,\\delta^j{}_i.\n$$\nThe divergence is\n$$\nD_j T^j{}_i = \\partial_j T^j{}_i + \\Gamma^j{}_{jk}T^k{}_i - \\Gamma^k{}_{ji}T^j{}_k.\n$$\nGiven $T^j{}_i = -2\\,\\kappa\\,\\delta^j{}_i$, the first term becomes $\\partial_j T^j{}_i = -2\\,\\partial_i \\kappa$. For the Christoffel terms we use $\\Gamma^j{}_{jk} = 6\\,\\partial_k \\ln\\psi$ and observe $T^k{}_i = -2\\kappa\\,\\delta^k{}_i$ and $T^j{}_k = -2\\kappa\\,\\delta^j{}_k$. Hence\n$$\n\\Gamma^j{}_{jk}T^k{}_i = -12\\,\\kappa\\,\\partial_i \\ln\\psi,\\quad\n\\Gamma^k{}_{ji}T^j{}_k = -12\\,\\kappa\\,\\partial_i \\ln\\psi,\n$$\nand they cancel:\n$$\nD_j T^j{}_i = -2\\,\\partial_i\\kappa.\n$$\nTherefore, to enforce the continuum momentum constraint $\\mathcal{M}_i=0$, we must choose\n$$\nS_i = \\frac{1}{8\\pi} D_j T^j{}_i = -\\frac{1}{4\\pi}\\,\\partial_i\\kappa.\n$$\n\nStep 4: Hamiltonian constraint matter field. Using $R = -8\\,\\psi^{-5}\\,\\nabla^2\\psi$ and $K^2 - K_{ij}K^{ij} = 6\\kappa^2$, the Hamiltonian constraint $\\mathcal{H} = 0$ implies\n$$\n\\rho = \\frac{1}{16\\pi}\\left(R + K^2 - K_{ij}K^{ij}\\right)\n= \\frac{1}{16\\pi}\\left(-8\\,\\psi^{-5}\\,\\nabla^2\\psi + 6\\,\\kappa^2\\right).\n$$\n\nStep 5: Analytic derivatives of the chosen fields. We choose\n$$\n\\psi(\\mathbf{x}) = 1 + A\\,\\exp\\!\\left(-\\frac{r^2}{\\sigma^2}\\right),\\quad r^2 \\equiv x^2+y^2+z^2,\n$$\nwhose Laplacian is\n$$\n\\nabla^2 \\psi = A\\,\\exp\\!\\left(-\\frac{r^2}{\\sigma^2}\\right)\\left(\\frac{4r^2}{\\sigma^4} - \\frac{6}{\\sigma^2}\\right),\n$$\nand\n$$\n\\kappa(\\mathbf{x}) = B\\,\\sin(\\pi x)\\,\\sin(\\pi y)\\,\\sin(\\pi z),\n$$\nwhose gradient components are\n$$\n\\partial_x \\kappa = B\\,\\pi\\,\\cos(\\pi x)\\,\\sin(\\pi y)\\,\\sin(\\pi z),\\quad\n\\partial_y \\kappa = B\\,\\pi\\,\\sin(\\pi x)\\,\\cos(\\pi y)\\,\\sin(\\pi z),\\quad\n\\partial_z \\kappa = B\\,\\pi\\,\\sin(\\pi x)\\,\\sin(\\pi y)\\,\\cos(\\pi z).\n$$\nWith these, the continuum $\\rho$ and $S_i$ are completely specified.\n\nStep 6: Discrete operators and expected scaling. Implement second-order central differences on a uniform grid with $N^3$ points and spacing $h = 2L/(N-1)$, using only interior points to compute derivatives:\n- For a scalar $f$, the discrete first derivative in $x$ at interior is $(f_{i+1,j,k}-f_{i-1,j,k})/(2h)$ and the second derivative is $(f_{i+1,j,k} - 2f_{i,j,k} + f_{i-1,j,k})/h^2$, with analogous formulas in $y$ and $z$.\n- The discrete Laplacian is the sum of second derivatives over $x$, $y$, and $z$.\n\nWe evaluate the numerical constraints as follows:\n- Hamiltonian residual:\n$$\n\\mathcal{H}_{\\text{num}} = R_{\\text{num}} + K^2 - K_{ij}K^{ij} - 16\\pi\\rho,\n\\quad R_{\\text{num}} = -8\\,\\psi^{-5}\\,\\nabla^2_{\\text{num}}\\psi,\n$$\ncomputed with the discrete Laplacian of $\\psi$ at interior points. Note $K=3\\kappa$ and $K_{ij}K^{ij}=3\\kappa^2$ are pointwise algebraic.\n- Momentum residual components at interior:\n$$\n\\mathcal{M}_{i,\\text{num}} = D_j^{\\text{num}} T^j{}_i - 8\\pi S_i,\n$$\nwhere $T^j{}_i = -2\\,\\kappa\\,\\delta^j{}_i$, and\n$$\nD_j^{\\text{num}} T^j{}_i = \\partial_j^{\\text{num}} T^j{}_i + \\Gamma^j{}_{jk,\\text{num}}\\,T^k{}_i - \\Gamma^k{}_{ji,\\text{num}}\\,T^j{}_k,\n$$\nwith $\\Gamma^j{}_{jk,\\text{num}} = 6\\,\\partial_k^{\\text{num}}\\ln\\psi$, and $\\Gamma^k{}_{ji,\\text{num}}$ contracted over $j$ becomes $6\\,\\partial_i^{\\text{num}}\\ln\\psi$. Numerically, the cancellation is not exact due to truncation error, and the residual scales with the differencing error.\n\nUnder smoothness assumptions, second-order central differencing has truncation error of order $\\mathcal{O}(h^2)$. Since the continuum constraints are satisfied exactly by construction, the residuals arise purely from finite-difference errors and therefore their $L_2$ norms should scale as $e(h) = C\\,h^2 + \\mathcal{O}(h^3)$, which implies an observed convergence order $p \\approx 2$ when comparing successive resolutions.\n\nStep 7: Test suite and outputs. For each of the three cases specified by $(A,\\sigma,B)$ and for resolutions $N\\in\\{33,49,65\\}$, compute the $L_2$ residuals for the Hamiltonian and momentum constraints, estimate $p$ between successive $N$ pairs, and report the average of the two $p$ values for each constraint. The program’s final output must be a single line in the exact format\n$$\n\\text{[[}p_{\\mathcal{H},1}\\text{,}p_{\\mathcal{M},1}\\text{],[}p_{\\mathcal{H},2}\\text{,}p_{\\mathcal{M},2}\\text{],[}p_{\\mathcal{H},3}\\text{,}p_{\\mathcal{M},3}\\text{]]},\n$$\nwhere each $p$ is a float. All quantities are dimensionless in geometrized units.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_grid(L, N):\n    x = np.linspace(-L, L, N)\n    y = np.linspace(-L, L, N)\n    z = np.linspace(-L, L, N)\n    X, Y, Z = np.meshgrid(x, y, z, indexing='ij')\n    h = (2 * L) / (N - 1)\n    return X, Y, Z, h\n\ndef analytic_fields(A, sigma, B, X, Y, Z):\n    r2 = X**2 + Y**2 + Z**2\n    psi = 1.0 + A * np.exp(-r2 / (sigma**2))\n    # Laplacian of psi from analytic derivative\n    lap_psi = A * np.exp(-r2 / (sigma**2)) * (4.0 * r2 / (sigma**4) - 6.0 / (sigma**2))\n    # kappa and its analytic gradients\n    pi = np.pi\n    sinx = np.sin(pi * X)\n    siny = np.sin(pi * Y)\n    sinz = np.sin(pi * Z)\n    cosx = np.cos(pi * X)\n    cosy = np.cos(pi * Y)\n    cosz = np.cos(pi * Z)\n    kappa = B * sinx * siny * sinz\n    dkappa_dx_true = B * pi * cosx * siny * sinz\n    dkappa_dy_true = B * pi * sinx * cosy * sinz\n    dkappa_dz_true = B * pi * sinx * siny * cosz\n    # Scalar curvature R (continuum)\n    R_true = -8.0 * (psi**-5) * lap_psi\n    # K and K_ij K^ij\n    K = 3.0 * kappa\n    KK = 3.0 * (kappa**2)\n    # Matter density rho from Hamiltonian constraint\n    rho_true = (R_true + K**2 - KK) / (16.0 * np.pi)\n    # Momentum density S_i from momentum constraint\n    Sx_true = -(1.0 / (4.0 * np.pi)) * dkappa_dx_true\n    Sy_true = -(1.0 / (4.0 * np.pi)) * dkappa_dy_true\n    Sz_true = -(1.0 / (4.0 * np.pi)) * dkappa_dz_true\n    return psi, kappa, R_true, K, KK, rho_true, (Sx_true, Sy_true, Sz_true)\n\ndef central_diff_first(f, h, axis):\n    \"\"\"\n    Compute first derivative with second-order central differences along given axis.\n    Returns derivative at interior points only.\n    \"\"\"\n    if axis == 0:\n        return (f[2:, 1:-1, 1:-1] - f[:-2, 1:-1, 1:-1]) / (2.0 * h)\n    elif axis == 1:\n        return (f[1:-1, 2:, 1:-1] - f[1:-1, :-2, 1:-1]) / (2.0 * h)\n    elif axis == 2:\n        return (f[1:-1, 1:-1, 2:] - f[1:-1, 1:-1, :-2]) / (2.0 * h)\n    else:\n        raise ValueError(\"Invalid axis\")\n\ndef central_diff_second(f, h, axis):\n    \"\"\"\n    Compute second derivative with second-order central differences along given axis.\n    Returns derivative at interior points only.\n    \"\"\"\n    if axis == 0:\n        return (f[2:, 1:-1, 1:-1] - 2.0 * f[1:-1, 1:-1, 1:-1] + f[:-2, 1:-1, 1:-1]) / (h * h)\n    elif axis == 1:\n        return (f[1:-1, 2:, 1:-1] - 2.0 * f[1:-1, 1:-1, 1:-1] + f[1:-1, :-2, 1:-1]) / (h * h)\n    elif axis == 2:\n        return (f[1:-1, 1:-1, 2:] - 2.0 * f[1:-1, 1:-1, 1:-1] + f[1:-1, 1:-1, :-2]) / (h * h)\n    else:\n        raise ValueError(\"Invalid axis\")\n\ndef compute_residuals(A, sigma, B, L, N):\n    # Build grid and fields\n    X, Y, Z, h = generate_grid(L, N)\n    psi, kappa, R_true, K, KK, rho_true, S_true = analytic_fields(A, sigma, B, X, Y, Z)\n    Sx_true, Sy_true, Sz_true = S_true\n\n    # Interior slices\n    psi_i = psi[1:-1, 1:-1, 1:-1]\n    kappa_i = kappa[1:-1, 1:-1, 1:-1]\n    K_i = K[1:-1, 1:-1, 1:-1]\n    KK_i = KK[1:-1, 1:-1, 1:-1]\n    rho_i = rho_true[1:-1, 1:-1, 1:-1]\n    Sx_i = Sx_true[1:-1, 1:-1, 1:-1]\n    Sy_i = Sy_true[1:-1, 1:-1, 1:-1]\n    Sz_i = Sz_true[1:-1, 1:-1, 1:-1]\n\n    # Discrete Laplacian of psi\n    d2x_psi = central_diff_second(psi, h, axis=0)\n    d2y_psi = central_diff_second(psi, h, axis=1)\n    d2z_psi = central_diff_second(psi, h, axis=2)\n    lap_psi_num = d2x_psi + d2y_psi + d2z_psi\n\n    # Numerical R\n    R_num = -8.0 * (psi_i**-5) * lap_psi_num\n\n    # Hamiltonian residual\n    H_num = R_num + K_i**2 - KK_i - 16.0 * np.pi * rho_i\n\n    # Momentum residual: compute covariant divergence numerically\n    # T^j_i = -2 kappa delta^j_i -> components: T^x_x = T^y_y = T^z_z = -2 kappa, others 0\n    # Partial derivatives\n    dkappa_dx_num = central_diff_first(kappa, h, axis=0)\n    dkappa_dy_num = central_diff_first(kappa, h, axis=1)\n    dkappa_dz_num = central_diff_first(kappa, h, axis=2)\n    # Christoffel traces from ln(psi)\n    lnpsi = np.log(psi)\n    dlnpsi_dx_num = central_diff_first(lnpsi, h, axis=0)\n    dlnpsi_dy_num = central_diff_first(lnpsi, h, axis=1)\n    dlnpsi_dz_num = central_diff_first(lnpsi, h, axis=2)\n    Gamma_tr_x = 6.0 * dlnpsi_dx_num\n    Gamma_tr_y = 6.0 * dlnpsi_dy_num\n    Gamma_tr_z = 6.0 * dlnpsi_dz_num\n\n    # Assemble D_j T^j_i for each i\n    # For i = x: ∂_x T^x_x + Γ^j_{jk} T^k_x - Γ^k_{jx} T^j_k\n    # T^k_x nonzero only for k=x and equals -2 kappa_i\n    # T^j_k nonzero only when j=k; thus sum gives -2 kappa_i\n    Tx_div = -2.0 * dkappa_dx_num + Gamma_tr_x * (-2.0 * kappa_i) - (6.0 * dlnpsi_dx_num) * (-2.0 * kappa_i)\n    Ty_div = -2.0 * dkappa_dy_num + Gamma_tr_y * (-2.0 * kappa_i) - (6.0 * dlnpsi_dy_num) * (-2.0 * kappa_i)\n    Tz_div = -2.0 * dkappa_dz_num + Gamma_tr_z * (-2.0 * kappa_i) - (6.0 * dlnpsi_dz_num) * (-2.0 * kappa_i)\n\n    Mx_num = Tx_div - 8.0 * np.pi * Sx_i\n    My_num = Ty_div - 8.0 * np.pi * Sy_i\n    Mz_num = Tz_div - 8.0 * np.pi * Sz_i\n\n    # L2 norms over interior\n    H_l2 = float(np.sqrt(np.mean(H_num**2)))\n    M_l2 = float(np.sqrt(np.mean(Mx_num**2 + My_num**2 + Mz_num**2)))\n\n    return H_l2, M_l2, h\n\ndef observed_order(errors, hs):\n    # errors: list [e1, e2, e3], hs: list [h1, h2, h3]\n    p1 = np.log(errors[0] / errors[1]) / np.log(hs[0] / hs[1])\n    p2 = np.log(errors[1] / errors[2]) / np.log(hs[1] / hs[2])\n    return float((p1 + p2) / 2.0)\n\ndef run_case(A, sigma, B):\n    L = 1.0\n    Ns = [33, 49, 65]\n    H_errors = []\n    M_errors = []\n    hs = []\n    for N in Ns:\n        H_l2, M_l2, h = compute_residuals(A, sigma, B, L, N)\n        H_errors.append(H_l2)\n        M_errors.append(M_l2)\n        hs.append(h)\n    pH = observed_order(H_errors, hs)\n    pM = observed_order(M_errors, hs)\n    return pH, pM\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.2, 0.6, 0.05),  # Case 1\n        (0.1, 0.9, 0.04),  # Case 2\n        (0.5, 0.4, 0.08),  # Case 3\n    ]\n\n    results = []\n    for (A, sigma, B) in test_cases:\n        pH, pM = run_case(A, sigma, B)\n        # format to a reasonable number of decimals\n        results.append([round(pH, 6), round(pM, 6)])\n\n    # Final print statement in the exact required format.\n    # Produce a single line like [[pH1,pM1],[pH2,pM2],[pH3,pM3]]\n    inner = \",\".join(\"[\" + \",\".join(map(str, pair)) + \"]\" for pair in results)\n    print(f\"[{inner}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Simulating a compact object merger involves evolving a coupled system of gravity, hydrodynamics, and potentially radiation transport, each operating on vastly different timescales. This property, known as \"stiffness,\" can render purely explicit time-stepping schemes unstable or prohibitively expensive. This exercise  explores a powerful solution through a simplified multi-physics model: an Implicit-Explicit (IMEX) time-stepping scheme. By implementing and analyzing this method, you will gain hands-on experience in designing stable and accurate algorithms for stiff problems, a crucial challenge in modern computational astrophysics.",
            "id": "3533440",
            "problem": "You are tasked with designing, analyzing, and implementing a single-step Implicit-Explicit (IMEX) scheme for a reduced multi-physics model of a compact object merger that couples a simplified metric, hydrodynamics, and radiation system. Implicit-Explicit (IMEX) denotes a scheme that treats non-stiff terms explicitly and stiff source terms implicitly to ensure stability while controlling splitting errors. The goal is to derive a principled time-stepping method starting from a linearized set of ordinary differential equations and to quantify stability and operator-splitting error against the exact matrix-exponential solution. All variables and parameters in this problem are dimensionless and are expressed without physical units.\n\nModel setup. Consider the dimensionless state vector $y(t) = [g(t), u(t), r(t)]^{\\top}$, where $g(t)$ is a scalar metric perturbation amplitude, $u(t)$ is a single-component hydrodynamic velocity proxy, and $r(t)$ is a grey radiation energy density. The coupled dynamics are linearized into an additive splitting $y'(t) = F(y(t)) + S(y(t))$, where $F$ represents non-stiff explicit couplings and $S$ represents a stiff radiation relaxation source. Define the explicit linear operator $F(y) = A y$ with constant matrix\n$$\nA = \\begin{bmatrix}\n-\\omega_g & k_{gu} & 0 \\\\\nk_{ug} & -\\omega_u & 0 \\\\\ns_r \\eta_g & s_r \\eta_u & a_r\n\\end{bmatrix},\n$$\nand define the stiff source $S(y) = S_{\\mathrm{op}} y$ with\n$$\nS_{\\mathrm{op}} = \\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 0 & 0 \\\\\n\\kappa \\eta_g & \\kappa \\eta_u & -\\kappa\n\\end{bmatrix},\n$$\nwhich corresponds to a radiation relaxation term $S_r = -\\kappa (r - r_{\\mathrm{eq}})$ to the local equilibrium $r_{\\mathrm{eq}} = \\eta_g g + \\eta_u u$. The combined exact linear operator for the full system is $L = A + S_{\\mathrm{op}}$.\n\nTime stepping requirements. Implement a first-order IMEX Euler step that treats $F$ explicitly and the stiff radiation source implicitly. For a time step of size $\\Delta t$, the update is defined componentwise by\n- Explicit metric-hydro updates:\n$$\ng^{n+1} = g^n + \\Delta t \\left(-\\omega_g g^n + k_{gu} u^n \\right), \\quad\nu^{n+1} = u^n + \\Delta t \\left(k_{ug} g^n - \\omega_u u^n \\right).\n$$\n- Implicit radiation update where the equilibrium $r_{\\mathrm{eq}}^n = \\eta_g g^n + \\eta_u u^n$ is evaluated explicitly:\n$$\nr^{n+1} = \\frac{r^n + \\Delta t \\left( a_r r^n + s_r r_{\\mathrm{eq}}^n \\right) + \\Delta t \\, \\kappa \\, r_{\\mathrm{eq}}^n}{1 + \\Delta t \\, \\kappa}.\n$$\n\nFundamental base and stability analysis. The forward Euler method is conditionally stable for linear systems $y' = A y$ with real negative eigenvalues $\\lambda_i$ when $|1 + \\Delta t \\lambda_i| \\le 1$. For the explicit subsystem defined by the $g$-$u$ block\n$$\nA_{gu} = \\begin{bmatrix}\n-\\omega_g & k_{gu} \\\\\nk_{ug} & -\\omega_u\n\\end{bmatrix},\n$$\nyour program must test explicit stability by verifying $|1 + \\Delta t \\lambda_i(A_{gu})| \\le 1$ for both eigenvalues. For the stiff radiation mode $r'(t) = -\\kappa r(t)$, the implicit Euler update gives an amplification factor $G_{\\mathrm{imp}} = \\frac{1}{1 + \\Delta t \\kappa}$, which satisfies $|G_{\\mathrm{imp}}| \\le 1$ for any $\\Delta t \\ge 0$ and $\\kappa \\ge 0$. Your program must quantify the implicit stiff-mode stability as a boolean by checking $|G_{\\mathrm{imp}}| \\le 1$.\n\nSplitting error quantification. For constant-coefficient linear operators, the exact solution over a time interval $T$ is $y(T) = \\exp(T L) y(0)$, where $\\exp$ is the matrix exponential. The global operator-splitting error of your IMEX solution at time $T$ must be quantified by the Euclidean norm\n$$\nE(T, \\Delta t, \\kappa) = \\left\\| y_{\\mathrm{IMEX}}(T) - \\exp(T L) \\, y(0) \\right\\|_2.\n$$\nUnder first-order splitting, the local error scales as $\\mathcal{O}(\\Delta t^2)$ and the global error scales as $\\mathcal{O}(\\Delta t)$; your test suite must include a case that demonstrates this scaling when $\\Delta t$ is halved.\n\nImplementation details. Use the parameter values\n$$\n\\omega_g = 10, \\quad \\omega_u = 8, \\quad k_{gu} = 3, \\quad k_{ug} = 2, \\quad a_r = -1, \\quad s_r = 5, \\quad \\eta_g = 0.5, \\quad \\eta_u = 0.3,\n$$\nand the initial condition\n$$\ny(0) = \\begin{bmatrix} g(0) \\\\ u(0) \\\\ r(0) \\end{bmatrix} = \\begin{bmatrix} 0.01 \\\\ -0.02 \\\\ 0.03 \\end{bmatrix}.\n$$\nAll quantities are dimensionless.\n\nTest suite. Implement your solver and error/stability analysis for the following $4$ test cases, each specified by $(\\Delta t, T, \\kappa)$:\n1. $(\\Delta t, T, \\kappa) = (0.05, 1.0, 1000)$, a stiff “happy path” case.\n2. $(\\Delta t, T, \\kappa) = (0.17, 0.34, 500)$, a case with $\\Delta t$ near the explicit forward Euler stability boundary for the $g$-$u$ subsystem.\n3. $(\\Delta t, T, \\kappa) = (0.05, 0.5, 10^6)$, extreme stiffness for the radiation relaxation.\n4. $(\\Delta t, T, \\kappa) = (0.025, 1.0, 1000)$, to demonstrate first-order global error scaling when halving $\\Delta t$ relative to case $1$.\n\nProgram outputs. For each test case, compute:\n- The splitting error $E(T, \\Delta t, \\kappa)$ as a floating-point value.\n- The explicit stability boolean for the $g$-$u$ block, defined by checking $|1 + \\Delta t \\lambda_i(A_{gu})| \\le 1$ for both eigenvalues.\n- The implicit stiff-mode stability boolean, defined by checking $|G_{\\mathrm{imp}}| \\le 1$ for $G_{\\mathrm{imp}} = (1 + \\Delta t \\kappa)^{-1}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of the form $[E, \\text{stable\\_explicit}, \\text{stable\\_implicit}]$. For example, the output must be structured as\n$$\n[\\,[E_1,\\text{stable\\_explicit}_1,\\text{stable\\_implicit}_1],\\,[E_2,\\text{stable\\_explicit}_2,\\text{stable\\_implicit}_2],\\,[E_3,\\text{stable\\_explicit}_3,\\text{stable\\_implicit}_3],\\,[E_4,\\text{stable\\_explicit}_4,\\text{stable\\_implicit}_4]\\,].\n$$",
            "solution": "The problem presented is a well-posed and self-contained exercise in numerical analysis, specifically concerning the development and verification of an Implicit-Explicit (IMEX) time-stepping scheme for a system of linear ordinary differential equations. This system is a simplified model for physical processes in compact object mergers. All parameters, initial conditions, and analysis tasks are clearly defined, rendering the problem valid and solvable without ambiguity.\n\nThe core of the problem is to solve the linear system of ordinary differential equations $y'(t) = L y(t)$, where the state vector is $y(t) = [g(t), u(t), r(t)]^{\\top}$ and the operator $L$ is split into a non-stiff part $A$ and a stiff part $S_{\\mathrm{op}}$.\n\nThe system dynamics are given by $y'(t) = (A + S_{\\mathrm{op}})y(t)$, with the matrices:\n$$\nA = \\begin{bmatrix}\n-\\omega_g & k_{gu} & 0 \\\\\nk_{ug} & -\\omega_u & 0 \\\\\ns_r \\eta_g & s_r \\eta_u & a_r\n\\end{bmatrix}\n= \\begin{bmatrix}\n-10 & 3 & 0 \\\\\n2 & -8 & 0 \\\\\n5 \\cdot 0.5 & 5 \\cdot 0.3 & -1\n\\end{bmatrix}\n= \\begin{bmatrix}\n-10 & 3 & 0 \\\\\n2 & -8 & 0 \\\\\n2.5 & 1.5 & -1\n\\end{bmatrix}\n$$\nand\n$$\nS_{\\mathrm{op}} = \\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 0 & 0 \\\\\n\\kappa \\eta_g & \\kappa \\eta_u & -\\kappa\n\\end{bmatrix}\n= \\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 0 & 0 \\\\\n0.5\\kappa & 0.3\\kappa & -\\kappa\n\\end{bmatrix}.\n$$\nThe full system operator is $L = A + S_{\\mathrm{op}}$.\n\nThe specified IMEX scheme treats the dynamics due to $A$ with a first-order explicit (Forward Euler) method and the dynamics due to $S_{\\mathrm{op}}$ with a first-order implicit (Backward Euler) method. A time step from $t^n$ to $t^{n+1} = t^n + \\Delta t$ is formulated as:\n$$\n\\frac{y^{n+1} - y^n}{\\Delta t} = A y^n + S_{\\mathrm{op}} y_{\\mathrm{impl}}.\n$$\nThe problem specifies a particular variant where the implicit solve for the radiation component $r(t)$ uses an explicitly evaluated equilibrium state $r_{\\mathrm{eq}}^n = \\eta_g g^n + \\eta_u u^n$. This decouples the updates. The stiff source term $S_r = -\\kappa(r - r_{\\mathrm{eq}})$ is thus approximated at step $n+1$ as $-\\kappa(r^{n+1} - r_{\\mathrm{eq}}^n)$.\n\nLet's verify the update rules.\nFor the metric $g(t)$ and velocity $u(t)$ components, the first two rows of $S_{\\mathrm{op}}$ are zero, so their updates are purely explicit (Forward Euler) based on the $A$ matrix:\n$$\ng^{n+1} = g^n + \\Delta t (A y^n)_1 = g^n + \\Delta t(-\\omega_g g^n + k_{gu} u^n),\n$$\n$$\nu^{n+1} = u^n + \\Delta t (A y^n)_2 = u^n + \\Delta t(k_{ug} g^n - \\omega_u u^n).\n$$\nThese precisely match the problem statement.\n\nFor the radiation component $r(t)$, the update rule combines the explicit treatment of the third row of $A y^n$ with an implicit treatment of the stiff source term using $r_{\\mathrm{eq}}^n$:\n$$\n\\frac{r^{n+1} - r^n}{\\Delta t} = (s_r \\eta_g g^n + s_r \\eta_u u^n + a_r r^n) - \\kappa (r^{n+1} - (\\eta_g g^n + \\eta_u u^n)).\n$$\nRearranging to solve for $r^{n+1}$:\n$$\nr^{n+1} - r^n = \\Delta t (s_r r_{\\mathrm{eq}}^n + a_r r^n) - \\Delta t \\kappa r^{n+1} + \\Delta t \\kappa r_{\\mathrm{eq}}^n,\n$$\n$$\nr^{n+1}(1 + \\Delta t \\kappa) = r^n + \\Delta t(a_r r^n + s_r r_{\\mathrm{eq}}^n) + \\Delta t \\kappa r_{\\mathrm{eq}}^n,\n$$\n$$\nr^{n+1} = \\frac{r^n + \\Delta t\\left( a_r r^n + s_r r_{\\mathrm{eq}}^n \\right) + \\Delta t \\kappa r_{\\mathrm{eq}}^n}{1 + \\Delta t \\kappa}.\n$$\nThis derivation confirms the correctness of the update formula provided in the problem.\n\nNext, we analyze the stability of the scheme.\nThe stability of the explicit part is governed by the eigenvalues of the metric-hydrodynamics sub-block:\n$$\nA_{gu} = \\begin{bmatrix} -\\omega_g & k_{gu} \\\\ k_{ug} & -\\omega_u \\end{bmatrix} = \\begin{bmatrix} -10 & 3 \\\\ 2 & -8 \\end{bmatrix}.\n$$\nThe eigenvalues $\\lambda$ are the roots of the characteristic equation $\\det(A_{gu} - \\lambda I) = 0$:\n$$\n(-10 - \\lambda)(-8 - \\lambda) - (3)(2) = \\lambda^2 + 18\\lambda + 74 = 0.\n$$\nThe roots are $\\lambda = \\frac{-18 \\pm \\sqrt{18^2 - 4(74)}}{2} = -9 \\pm \\sqrt{7}$.\nSo, $\\lambda_1 = -9 - \\sqrt{7} \\approx -11.6458$ and $\\lambda_2 = -9 + \\sqrt{7} \\approx -6.3542$.\nFor the Forward Euler method to be stable, the condition $|1 + \\Delta t \\lambda_i| \\le 1$ must hold for both eigenvalues. Since both are real and negative, this is equivalent to $-2 \\le \\Delta t \\lambda_i \\le 0$, which implies $\\Delta t \\le -2/\\lambda_i$. The stricter constraint comes from $\\lambda_1$:\n$$\n\\Delta t \\le \\frac{-2}{\\lambda_1} = \\frac{2}{9 + \\sqrt{7}} \\approx 0.1717.\n$$\nThe explicit part of the scheme is stable if $\\Delta t \\lesssim 0.1717$.\n\nThe stability of the implicit part is determined by the amplification factor for the stiffest mode, which is modeled as $z' = -\\kappa z$. The implicit Euler update is $z^{n+1} = z^n - \\Delta t \\kappa z^{n+1}$, which gives $z^{n+1} = \\frac{1}{1 + \\Delta t \\kappa} z^n$. The amplification factor is $G_{\\mathrm{imp}} = (1 + \\Delta t \\kappa)^{-1}$. For any $\\Delta t > 0$ and $\\kappa > 0$, we have $0 < G_{\\mathrm{imp}} < 1$, so $|G_{\\mathrm{imp}}| \\le 1$ is always satisfied. The implicit treatment is unconditionally stable for this stiff relaxation term.\n\nTo quantify the operator-splitting error, the numerical solution $y_{\\mathrm{IMEX}}(T)$ after integrating to time $T$ must be compared to the exact solution. For this linear, constant-coefficient system, the exact solution is given by the matrix exponential:\n$$\ny_{\\mathrm{exact}}(T) = \\exp(T L) y(0),\n$$\nwhere $y(0) = [0.01, -0.02, 0.03]^{\\top}$ is the initial condition. The error is the Euclidean norm of the difference:\n$$\nE(T, \\Delta t, \\kappa) = \\| y_{\\mathrm{IMEX}}(T) - y_{\\mathrm{exact}}(T) \\|_2.\n$$\nSince the IMEX scheme is a first-order splitting, the global error is expected to scale linearly with the time step, $E \\propto \\mathcal{O}(\\Delta t)$. This will be verified by comparing test cases $1$ and $4$, where $\\Delta t$ is halved.\n\nThe implementation will proceed by iterating through the four test cases. For each case, we will:\n1.  Construct the matrices $A$, $S_{\\mathrm{op}}$, and $L$ with the given parameters and $\\kappa$.\n2.  Perform the stability checks on the explicit and implicit parts using the derived conditions.\n3.  Execute the IMEX time-stepping loop for $N = T/\\Delta t$ steps to find $y_{\\mathrm{IMEX}}(T)$.\n4.  Calculate the exact solution $y_{\\mathrm{exact}}(T)$ using `scipy.linalg.expm`.\n5.  Compute the final error norm $E$.\nThe results for all four cases will be collected and formatted into the required output string.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the problem of designing, analyzing, and implementing a single-step\n    IMEX scheme for a reduced multi-physics model of a compact object merger.\n    \"\"\"\n\n    # Define the fixed model parameters\n    wg = 10.0\n    wu = 8.0\n    kgu = 3.0\n    kug = 2.0\n    ar = -1.0\n    sr = 5.0\n    eta_g = 0.5\n    eta_u = 0.3\n\n    # Define the initial condition\n    y0 = np.array([0.01, -0.02, 0.03])\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (delta_t, T, kappa)\n        (0.05, 1.0, 1000.0),\n        (0.17, 0.34, 500.0),\n        (0.05, 0.5, 1e6),\n        (0.025, 1.0, 1000.0),\n    ]\n\n    # Matrix for the explicit g-u subsystem (constant)\n    A_gu = np.array([\n        [-wg, kgu],\n        [kug, -wu]\n    ])\n    \n    # Constant part of the full explicit matrix A\n    A = np.array([\n        [-wg, kgu, 0.0],\n        [kug, -wu, 0.0],\n        [sr * eta_g, sr * eta_u, ar]\n    ])\n\n    results = []\n    for dt, T, kappa in test_cases:\n        # --- Stability Analysis ---\n\n        # 1. Explicit stability for the g-u block\n        eigvals_gu = np.linalg.eigvals(A_gu)\n        # Check if |1 + dt * lambda_i| <= 1 for all eigenvalues\n        stable_explicit = np.all(np.abs(1.0 + dt * eigvals_gu) <= 1.0)\n\n        # 2. Implicit stiff-mode stability\n        G_imp = 1.0 / (1.0 + dt * kappa)\n        stable_implicit = np.abs(G_imp) <= 1.0\n\n        # --- IMEX Time Integration ---\n        y = y0.copy()\n        # The number of steps is an integer for all test cases\n        num_steps = int(round(T / dt))\n\n        for _ in range(num_steps):\n            g_n, u_n, r_n = y[0], y[1], y[2]\n            \n            # Explicit updates for metric (g) and hydro (u)\n            g_np1 = g_n + dt * (-wg * g_n + kgu * u_n)\n            u_np1 = u_n + dt * (kug * g_n - wu * u_n)\n            \n            # Semi-implicit update for radiation (r)\n            # Equilibrium term is evaluated explicitly at step n\n            r_eq_n = eta_g * g_n + eta_u * u_n\n            \n            # The radiation update formula from the problem statement\n            r_np1_numerator = r_n + dt * (ar * r_n + sr * r_eq_n) + dt * kappa * r_eq_n\n            r_np1_denominator = 1.0 + dt * kappa\n            r_np1 = r_np1_numerator / r_np1_denominator\n            \n            y = np.array([g_np1, u_np1, r_np1])\n        \n        y_imex = y\n        \n        # --- Exact Solution using Matrix Exponential ---\n        \n        # Stiff source operator matrix (depends on kappa)\n        S_op = np.array([\n            [0.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0],\n            [kappa * eta_g, kappa * eta_u, -kappa]\n        ])\n        \n        # Full system linear operator\n        L = A + S_op\n        \n        # The exact solution is y(T) = exp(T * L) * y(0)\n        y_exact = expm(T * L) @ y0\n        \n        # --- Splitting Error Quantification ---\n        # Calculate the Euclidean (L2) norm of the error vector\n        splitting_error = np.linalg.norm(y_imex - y_exact)\n        \n        # Append the results for this case to the list\n        results.append(\n            f\"[{splitting_error:.6e},{str(stable_explicit).lower()},{str(stable_implicit).lower()}]\"\n        )\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A simulation's results are only as reliable as their demonstrated accuracy. The fundamental tool for code verification in computational science is the convergence test, which provides quantitative evidence that the numerical solution is approaching the true continuum solution as the grid resolution increases. In this final practice , you will step into the role of an analyst, using synthetic data from a suite of simulations to compute the observed convergence order for key diagnostics like constraint violations and the gravitational-wave phase. Mastering this analysis is essential for validating numerical results and establishing their scientific credibility.",
            "id": "3533416",
            "problem": "You are given synthetic but scientifically plausible multi-resolution diagnostics from three neutron star–neutron star (NS-NS) merger simulations. The goal is to estimate the observed convergence order for three quantities: the Hamiltonian constraint violation (as a domain-integrated $L^2$ norm), the gravitational-wave (GW) phase at a fixed retarded time, and the fractional baryonic mass non-conservation. Your program must implement convergence estimation from first principles starting from the leading-order truncation error model and must report the estimated orders for all three quantities in each simulation case.\n\nStart from the following fundamental base:\n- The discretization error of a sufficiently smooth quantity $Q$ measured on a uniform grid with spacing $h$ typically exhibits an asymptotic scaling $Q(h)=Q_{\\infty}+C\\,h^{p}+O\\!\\left(h^{p+1}\\right)$, where $Q_{\\infty}$ is the continuum-limit value, $C$ is a constant independent of $h$, and $p$ is the method’s formal order of accuracy in the asymptotic regime.\n- For quantities that are themselves errors, such as norms of constraints or fractional conservation defects, the leading-order scaling simplifies to $E(h)=A\\,h^{p}+O\\!\\left(h^{p+1}\\right)$ with $A$ constant.\n- For a phase-like diagnostic such as a GW phase measured at the same physical event across resolutions, successive-resolution differences eliminate the unknown $Q_{\\infty}$ in the leading order under a constant refinement factor.\n\nYour program must implement the following estimation strategies without using any pre-provided target formulas:\n- For constraint and mass-conservation errors: determine the observed order $p$ by identifying and exploiting the implied linear relationship between the logarithm of the error and the logarithm of the grid spacing. Use all available resolution levels within each case.\n- For the GW phase: determine the observed order $p$ by eliminating the unknown continuum phase $Q_{\\infty}$ using at least three consecutive resolution levels that share a common refinement ratio. Use all available triples within each case and aggregate the estimates consistently.\n\nUnits and definitions:\n- Grid spacing $h$ is in meters. The computational domain length is $L=1.0\\times 10^{5}\\,\\mathrm{m}$ in all cases, and the number of grid points is $N$, so $h=L/N$.\n- The Hamiltonian constraint $L^2$ norms are dimensionless.\n- The GW phase is in radians.\n- The fractional baryonic mass non-conservation is dimensionless (a unitless fraction).\n- When computing phase differences and ratios, treat the phase as a continuous real angle in radians.\n\nReturn format and rounding:\n- For each case, compute three floats: the observed orders for the Hamiltonian constraint, the GW phase, and the mass conservation, in that order.\n- Round each observed order to three decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case contributes a sublist in the same order. For example: \"[$[p_{H}^{(1)},p_{\\phi}^{(1)},p_{M}^{(1)}]$,$[p_{H}^{(2)},p_{\\phi}^{(2)},p_{M}^{(2)}]$,$[p_{H}^{(3)},p_{\\phi}^{(3)},p_{M}^{(3)}]$]\".\n\nTest suite (three cases):\n- Case A (happy path, three levels, constant refinement factor $r=2$): $L=1.0\\times 10^{5}\\,\\mathrm{m}$, $N \\in \\{64,128,256\\}$, so $h=L/N$. Hamiltonian constraint $L^2$ errors at merger time: $[2.80\\times 10^{-3},\\,6.70\\times 10^{-4},\\,1.60\\times 10^{-4}]$. GW phase at a fixed retarded time in radians: $[12.345+0.038147,\\,12.345+0.004768,\\,12.345+0.000596]$. Fractional baryonic mass non-conservation: $[3.08708\\times 10^{-4},\\,1.09265\\times 10^{-4},\\,3.86810\\times 10^{-5}]$.\n- Case B (four levels, constant refinement factor $r=2$, moderate noise tolerance): $L=1.0\\times 10^{5}\\,\\mathrm{m}$, $N \\in \\{48,96,192,384\\}$. Hamiltonian constraint $L^2$ errors: $[1.2000\\times 10^{-2},\\,3.2145\\times 10^{-3},\\,8.6130\\times 10^{-4},\\,2.3080\\times 10^{-4}]$. GW phase in radians: $[9.876+0.05173,\\,9.876+0.00796,\\,9.876+0.001225,\\,9.876+0.0001885]$. Fractional baryonic mass non-conservation: $[2.0000\\times 10^{-4},\\,5.0000\\times 10^{-5},\\,1.2500\\times 10^{-5},\\,3.1250\\times 10^{-6}]$.\n- Case C (three levels, constant refinement factor $r=2$): $L=1.0\\times 10^{5}\\,\\mathrm{m}$, $N \\in \\{72,144,288\\}$. Hamiltonian constraint $L^2$ errors: $[4.2000\\times 10^{-3},\\,1.4860\\times 10^{-3},\\,5.2570\\times 10^{-4}]$. GW phase in radians: $[15.555+0.03000,\\,15.555+0.005303,\\,15.555+0.0009375]$. Fractional baryonic mass non-conservation: $[1.8000\\times 10^{-4},\\,9.0000\\times 10^{-5},\\,4.5000\\times 10^{-5}]$.\n\nAngle unit is radians. There is no user input. The program must hard-code the test suite above, compute the observed orders, and print the final single-line output with nested lists exactly as specified, with each number rounded to three decimal places.",
            "solution": "The problem requires the estimation of the convergence order $p$ for three different physical quantities obtained from numerical simulations of neutron star mergers. The estimation must be derived from the provided leading-order error models. We will address the problem by first establishing the mathematical basis for the estimation procedures and then applying these procedures to the supplied data for each of the three cases.\n\nThe problem specifies two types of diagnostics, each with a distinct error model.\n\n**1. Estimation for Error-like Quantities**\n\nFor diagnostics that are inherently measures of error, such as the Hamiltonian constraint violation $E_H$ (an $L^2$ norm) and the fractional baryonic mass non-conservation $E_M$, the leading-order behavior as a function of grid spacing $h$ is given by:\n$$E(h) = A h^p + \\mathcal{O}(h^{p+1})$$\nwhere $A$ is a constant independent of $h$, and $p$ is the convergence order.\n\nTo determine $p$ from a set of data points $(h_i, E_i)$ corresponding to different resolutions, we can neglect the higher-order terms for sufficiently small $h$:\n$$E(h) \\approx A h^p$$\nTaking the natural logarithm of both sides transforms this power-law relationship into a linear one:\n$$\\ln(E) \\approx \\ln(A h^p) = \\ln(A) + p \\ln(h)$$\nThis equation has the form of a line, $y = c + mx$, where $y = \\ln(E)$, $x = \\ln(h)$, the y-intercept is $c = \\ln(A)$, and the slope is the convergence order, $m = p$.\n\nThe problem requires using all available resolution levels to estimate $p$. This is best accomplished by performing a linear regression on the set of transformed data points $\\{(\\ln(h_i), \\ln(E_i))\\}$. The slope of the best-fit line provides a robust estimate of the convergence order $p$. We will use the method of least squares to find this slope for both $E_H$ and $E_M$ for each case. The grid spacing $h$ is calculated from the given computational domain length $L = 1.0 \\times 10^5 \\, \\mathrm{m}$ and the number of grid points $N$ as $h = L/N$.\n\n**2. Estimation for Phase-like Quantities**\n\nFor a phase-like quantity, such as the gravitational-wave (GW) phase $\\phi$, which converges to a non-zero continuum value $\\phi_\\infty$, the error model is:\n$$\\phi(h) = \\phi_\\infty + C h^p + \\mathcal{O}(h^{p+1})$$\nHere, both $\\phi_\\infty$ and the constant $C$ are unknown. To estimate $p$, we must first eliminate $\\phi_\\infty$. This can be done using three data points from resolutions with a constant refinement ratio, $r$. Let the grid spacings for three consecutive resolutions be $h_c$ (coarse), $h_m$ (medium), and $h_f$ (fine), such that $h_c = r h_m$ and $h_m = r h_f$. The corresponding phase measurements are $\\phi_c$, $\\phi_m$, and $\\phi_f$.\n\nNeglecting higher-order terms, we write the model for each resolution:\n$$ \\phi_c \\approx \\phi_\\infty + C h_c^p $$\n$$ \\phi_m \\approx \\phi_\\infty + C h_m^p $$\n$$ \\phi_f \\approx \\phi_\\infty + C h_f^p $$\n\nWe take successive differences to eliminate $\\phi_\\infty$:\n$$ \\phi_c - \\phi_m \\approx C(h_c^p - h_m^p) $$\n$$ \\phi_m - \\phi_f \\approx C(h_m^p - h_f^p) $$\n\nTaking the ratio of these two differences eliminates the constant $C$:\n$$ \\frac{\\phi_c - \\phi_m}{\\phi_m - \\phi_f} \\approx \\frac{h_c^p - h_m^p}{h_m^p - h_f^p} $$\nSubstituting $h_c = r h_m$ and $h_f = h_m/r$:\n$$ \\frac{\\phi_c - \\phi_m}{\\phi_m - \\phi_f} \\approx \\frac{(r h_m)^p - h_m^p}{h_m^p - (h_m/r)^p} = \\frac{h_m^p(r^p - 1)}{h_m^p(1 - r^{-p})} = \\frac{r^p - 1}{1 - r^{-p}} = \\frac{r^p(r^p - 1)}{r^p - 1} = r^p $$\nThis yields a direct equation for the convergence order $p$:\n$$ p \\approx \\frac{\\ln\\left(\\frac{\\phi_c - \\phi_m}{\\phi_m - \\phi_f}\\right)}{\\ln(r)} $$\n\nThe problem requires using all available triples of resolutions. For a simulation with $k > 3$ levels, we will compute an estimate of $p$ for each consecutive triple and then compute the arithmetic mean of these estimates to obtain a final, aggregated value for $p_\\phi$.\n\n**3. Implementation Summary**\n\nFor each of the three test cases, we will:\n1.  Calculate the grid spacing $h_i = L/N_i$ for each resolution level $N_i$.\n2.  For the Hamiltonian constraint violation $p_H$ and mass non-conservation $p_M$, compute the natural logarithms of the errors and grid spacings. Then, use linear regression (specifically, `numpy.polyfit` with degree $1$) to find the slope of $\\ln(E)$ versus $\\ln(h)$, which gives $p$.\n3.  For the GW phase $p_\\phi$, identify all consecutive triples of resolutions. For each triple, calculate $p$ using the derived ratio formula. The final $p_\\phi$ will be the average of these individual estimates. In the given test cases, the refinement ratio $r$ is always $2$.\n4.  Round the final computed orders $p_H$, $p_\\phi$, and $p_M$ to three decimal places.\n\nThe final output will be a list containing one sublist for each case, with each sublist holding the three estimated orders in the specified sequence.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the convergence analysis on the provided test suite.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"L\": 1.0e5,\n            \"N\": np.array([64, 128, 256]),\n            \"r\": 2.0,\n            \"EH\": np.array([2.80e-3, 6.70e-4, 1.60e-4]),\n            \"phi\": np.array([12.345 + 0.038147, 12.345 + 0.004768, 12.345 + 0.000596]),\n            \"EM\": np.array([3.08708e-4, 1.09265e-4, 3.86810e-5]),\n        },\n        {\n            \"name\": \"Case B\",\n            \"L\": 1.0e5,\n            \"N\": np.array([48, 96, 192, 384]),\n            \"r\": 2.0,\n            \"EH\": np.array([1.2000e-2, 3.2145e-3, 8.6130e-4, 2.3080e-4]),\n            \"phi\": np.array([9.876 + 0.05173, 9.876 + 0.00796, 9.876 + 0.001225, 9.876 + 0.0001885]),\n            \"EM\": np.array([2.0000e-4, 5.0000e-5, 1.2500e-5, 3.1250e-6]),\n        },\n        {\n            \"name\": \"Case C\",\n            \"L\": 1.0e5,\n            \"N\": np.array([72, 144, 288]),\n            \"r\": 2.0,\n            \"EH\": np.array([4.2000e-3, 1.4860e-3, 5.2570e-4]),\n            \"phi\": np.array([15.555 + 0.03000, 15.555 + 0.005303, 15.555 + 0.0009375]),\n            \"EM\": np.array([1.8000e-4, 9.0000e-5, 4.5000e-5]),\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        h = case[\"L\"] / case[\"N\"]\n        \n        # --- Estimate order for error-like quantities (EH, EM) ---\n        # The model is E = A*h^p, so log(E) = log(A) + p*log(h).\n        # We find p as the slope of the linear fit of log(E) vs log(h).\n        log_h = np.log(h)\n        \n        log_EH = np.log(case[\"EH\"])\n        p_H = np.polyfit(log_h, log_EH, 1)[0]\n        \n        log_EM = np.log(case[\"EM\"])\n        p_M = np.polyfit(log_h, log_EM, 1)[0]\n        \n        # --- Estimate order for phase-like quantities (phi) ---\n        # The model is phi = phi_inf + C*h^p.\n        # The ratio of differences (phi_c-phi_m)/(phi_m-phi_f) = r^p.\n        # So, p = log(ratio) / log(r).\n        phis = case[\"phi\"]\n        r = case[\"r\"]\n        num_levels = len(case[\"N\"])\n        p_phi_estimates = []\n        \n        for i in range(num_levels - 2):\n            phi_c, phi_m, phi_f = phis[i], phis[i+1], phis[i+2]\n            \n            # Numerator and denominator of the ratio\n            num = phi_c - phi_m\n            den = phi_m - phi_f\n            \n            # Avoid division by zero or log of non-positive if data is noisy\n            if den != 0 and (num / den) > 0:\n                ratio = num / den\n                p_est = np.log(ratio) / np.log(r)\n                p_phi_estimates.append(p_est)\n                \n        # Aggregate estimates by averaging\n        p_phi = np.mean(p_phi_estimates) if p_phi_estimates else np.nan\n\n        # Round results to three decimal places\n        case_results = [round(p_H, 3), round(p_phi, 3), round(p_M, 3)]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as specified\n    def format_sublist(res_list):\n        return f\"[{','.join(f'{x:.3f}' for x in res_list)}]\"\n\n    output_str = f\"[{','.join([format_sublist(r) for r in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}