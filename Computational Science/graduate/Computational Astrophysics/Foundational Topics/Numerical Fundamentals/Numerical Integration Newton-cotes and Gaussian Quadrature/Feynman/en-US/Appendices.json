{
    "hands_on_practices": [
        {
            "introduction": "To build a solid understanding of numerical integration, it's essential to start from first principles. This first practice grounds our study by deriving the weights of the simplest closed Newton-Cotes formula—the trapezoidal rule. By explicitly integrating the underlying Lagrange basis polynomials, you will see exactly how the geometry of linear interpolation translates into a quadrature rule, a fundamental concept that underpins the entire family of Newton-Cotes methods. ",
            "id": "3526428",
            "problem": "In radiative transfer for a plane-parallel stellar atmosphere, the emergent flux can be written as an angular integral of the specific intensity over the direction cosine. More generally, many line-of-sight integrals in computational astrophysics reduce to one-dimensional definite integrals of the form $\\int_{a}^{b} f(x) \\, dx$ that must be evaluated numerically with strict control of discretization error.\n\nConsider a closed Newton-Cotes quadrature rule on the interval $\\left[a,b\\right]$ with $n+1$ equally spaced nodes including the endpoints. Let the nodes be $x_{i} = a + i h$ for $i = 0,1,\\dots,n$, where $h = \\left(b-a\\right)/n$. The closed Newton-Cotes rule approximates the integral by a weighted sum of function values at the nodes, with weights chosen so that the rule reproduces integrals of all polynomials up to degree $n$ exactly.\n\nDefine the quadrature weights in this setting starting from the fundamental polynomial interpolation idea: represent a function by its Lagrange interpolant built on the nodes and integrate the interpolant. Then, specializing to the case $n=1$ (two nodes at the endpoints $x_{0}=a$ and $x_{1}=b$), derive the trapezoidal rule weights by explicitly integrating the first-degree Lagrange basis functions associated with these two nodes.\n\nState your final answer as a row vector containing the two trapezoidal weights $\\left[w_{0}\\;\\;w_{1}\\right]$ as a function of $a$ and $b$. Your final answer must be a single analytic expression. Do not include units. Do not round.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, objective, and internally consistent. It presents a standard derivation in numerical analysis.\n\nThe objective is to derive the weights for the $n=1$ closed Newton-Cotes quadrature rule, commonly known as the trapezoidal rule, for approximating the definite integral $\\int_{a}^{b} f(x) \\, dx$. The derivation proceeds by integrating the Lagrange interpolating polynomial that approximates the function $f(x)$ over the interval $[a, b]$.\n\nA general closed Newton-Cotes formula with $n+1$ nodes approximates the integral as a weighted sum of function values at these nodes:\n$$\n\\int_{a}^{b} f(x) \\, dx \\approx \\sum_{i=0}^{n} w_i f(x_i)\n$$\nThe nodes $x_i$ are equally spaced within the interval $[a, b]$, given by $x_i = a + ih$ for $i = 0, 1, \\dots, n$, where the step size is $h = \\frac{b-a}{n}$. The weights $w_i$ are determined by approximating $f(x)$ with its unique Lagrange interpolating polynomial $P_n(x)$ of degree at most $n$ that passes through the $n+1$ points $(x_i, f(x_i))$. The polynomial is given by:\n$$\nP_n(x) = \\sum_{i=0}^{n} f(x_i) L_{n,i}(x)\n$$\nwhere $L_{n,i}(x)$ are the Lagrange basis polynomials, defined as:\n$$\nL_{n,i}(x) = \\prod_{\\substack{j=0 \\\\ j \\neq i}}^{n} \\frac{x-x_j}{x_i-x_j}\n$$\nIntegrating this polynomial approximation of $f(x)$ gives the approximation for the integral:\n$$\n\\int_{a}^{b} f(x) \\, dx \\approx \\int_{a}^{b} P_n(x) \\, dx = \\int_{a}^{b} \\sum_{i=0}^{n} f(x_i) L_{n,i}(x) \\, dx\n$$\nSince the function values $f(x_i)$ are constants with respect to the integration variable $x$, we can write:\n$$\n\\int_{a}^{b} P_n(x) \\, dx = \\sum_{i=0}^{n} f(x_i) \\left( \\int_{a}^{b} L_{n,i}(x) \\, dx \\right)\n$$\nBy comparing this with the quadrature formula $\\sum_{i=0}^{n} w_i f(x_i)$, we identify the weights $w_i$ as the integrals of the corresponding Lagrange basis polynomials:\n$$\nw_i = \\int_{a}^{b} L_{n,i}(x) \\, dx\n$$\nWe now specialize to the case $n=1$, which corresponds to the trapezoidal rule. For $n=1$, we have $n+1=2$ nodes. The nodes are the endpoints of the interval:\n$x_0 = a + 0 \\cdot \\frac{b-a}{1} = a$\n$x_1 = a + 1 \\cdot \\frac{b-a}{1} = b$\n\nThe two corresponding first-degree Lagrange basis polynomials are:\n$L_{1,0}(x) = \\frac{x-x_1}{x_0-x_1} = \\frac{x-b}{a-b}$\n$L_{1,1}(x) = \\frac{x-x_0}{x_1-x_0} = \\frac{x-a}{b-a}$\n\nNow, we compute the weights $w_0$ and $w_1$ by integrating these basis polynomials over the interval $[a, b]$.\n\nFor the weight $w_0$:\n$$\nw_0 = \\int_{a}^{b} L_{1,0}(x) \\, dx = \\int_{a}^{b} \\frac{x-b}{a-b} \\, dx\n$$\nThe term $\\frac{1}{a-b}$ is a constant and can be factored out:\n$$\nw_0 = \\frac{1}{a-b} \\int_{a}^{b} (x-b) \\, dx = \\frac{1}{a-b} \\left[ \\frac{x^2}{2} - bx \\right]_{a}^{b}\n$$\nEvaluating the antiderivative at the limits of integration:\n$$\nw_0 = \\frac{1}{a-b} \\left( \\left(\\frac{b^2}{2} - b \\cdot b\\right) - \\left(\\frac{a^2}{2} - b \\cdot a\\right) \\right)\n$$\n$$\nw_0 = \\frac{1}{a-b} \\left( \\frac{b^2}{2} - b^2 - \\frac{a^2}{2} + ab \\right) = \\frac{1}{a-b} \\left( -\\frac{b^2}{2} - \\frac{a^2}{2} + ab \\right)\n$$\nFactoring out $-\\frac{1}{2}$:\n$$\nw_0 = \\frac{1}{a-b} \\left( -\\frac{1}{2} (b^2 + a^2 - 2ab) \\right) = \\frac{1}{-(b-a)} \\left( -\\frac{1}{2} (b-a)^2 \\right)\n$$\n$$\nw_0 = \\frac{b-a}{2}\n$$\n\nFor the weight $w_1$:\n$$\nw_1 = \\int_{a}^{b} L_{1,1}(x) \\, dx = \\int_{a}^{b} \\frac{x-a}{b-a} \\, dx\n$$\nThe term $\\frac{1}{b-a}$ is a constant:\n$$\nw_1 = \\frac{1}{b-a} \\int_{a}^{b} (x-a) \\, dx = \\frac{1}{b-a} \\left[ \\frac{x^2}{2} - ax \\right]_{a}^{b}\n$$\nEvaluating at the limits:\n$$\nw_1 = \\frac{1}{b-a} \\left( \\left(\\frac{b^2}{2} - a \\cdot b\\right) - \\left(\\frac{a^2}{2} - a \\cdot a\\right) \\right)\n$$\n$$\nw_1 = \\frac{1}{b-a} \\left( \\frac{b^2}{2} - ab - \\frac{a^2}{2} + a^2 \\right) = \\frac{1}{b-a} \\left( \\frac{b^2}{2} - ab + \\frac{a^2}{2} \\right)\n$$\nFactoring out $\\frac{1}{2}$:\n$$\nw_1 = \\frac{1}{b-a} \\left( \\frac{1}{2} (b^2 - 2ab + a^2) \\right) = \\frac{1}{b-a} \\left( \\frac{1}{2} (b-a)^2 \\right)\n$$\n$$\nw_1 = \\frac{b-a}{2}\n$$\nThus, the weights for the trapezoidal rule ($n=1$ closed Newton-Cotes) are $w_0 = \\frac{b-a}{2}$ and $w_1 = \\frac{b-a}{2}$. The quadrature rule is:\n$$\n\\int_{a}^{b} f(x) \\, dx \\approx w_0 f(x_0) + w_1 f(x_1) = \\frac{b-a}{2} f(a) + \\frac{b-a}{2} f(b) = \\frac{b-a}{2} (f(a) + f(b))\n$$\nThe final answer is the row vector of these two weights.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{b-a}{2} & \\frac{b-a}{2}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "A key theoretical advantage of Gaussian quadrature is its high degree of polynomial exactness compared to Newton-Cotes rules with the same number of nodes. This computational exercise asks you to move from theory to verification by writing a program that empirically tests this claim. By systematically evaluating the performance of both methods on polynomials of increasing degree, you will gain a practical and quantitative appreciation for the power and efficiency of Gauss-Legendre integration for smooth functions. ",
            "id": "3526467",
            "problem": "Consider a dimensionless scaled radial coordinate $r \\in [0,R]$ with $R>0$ representing a normalized stellar radius. Let the integrand be the polynomial $f(r)=\\sum_{m=0}^{p} a_m r^m$, where $p$ is a nonnegative integer and $\\{a_m\\}_{m=0}^{p}$ are real coefficients. The integral of interest is $I=\\int_0^R f(r)\\,dr$. You will study the exactness properties of two numerical quadrature families for approximating $I$: closed Newton-Cotes rules and Gauss-Legendre rules.\n\nStart from the following foundational base:\n\n- A quadrature rule on an interval $[a,b]$ consists of nodes $\\{x_i\\}_{i=1}^{N}$ and weights $\\{w_i\\}_{i=1}^{N}$ used to approximate $\\int_a^b g(x)\\,dx$ by $Q[g]=\\sum_{i=1}^{N} w_i g(x_i)$. A rule is said to be exact for a class of functions if $Q[g]=\\int_a^b g(x)\\,dx$ for all $g$ in that class.\n- Closed Newton-Cotes rules place nodes at $N$ equally spaced points including the endpoints of the interval. The weights are determined so that the quadrature is exact for all polynomials up to some degree by matching polynomial moments.\n- Gauss-Legendre rules of order $n$ place nodes at the $n$ roots of the Legendre polynomial on $[-1,1]$ and choose weights to maximize the degree of polynomial exactness. A linear change of variables maps $[0,R]$ to $[-1,1]$.\n\nYour tasks:\n\n1. Derive, from the condition of moment matching, the system of equations that determines the weights for a closed Newton-Cotes rule with $N$ equally spaced nodes on $[0,R]$. Formulate this in terms of matching the moments $\\int_0^R r^k\\,dr$ for $k=0,1,\\dots,K$ with $K$ chosen appropriately for the construction.\n2. Explain how the Gauss-Legendre rule of order $n$ on $[-1,1]$ is applied to $[0,R]$ via an affine transformation $r=\\alpha t+\\beta$, and write the corresponding quadrature for $\\int_0^R f(r)\\,dr$.\n3. Implement a program that:\n   - Constructs the polynomial coefficients deterministically as $a_m = (-1)^m/(m+1)^2$ for $m=0,1,\\dots,p$.\n   - Computes the analytic value $I_{\\mathrm{exact}}=\\sum_{m=0}^{p} a_m \\frac{R^{m+1}}{m+1}$.\n   - Builds the closed Newton-Cotes rule with $N$ equally spaced nodes on $[0,R]$ by solving the linear system implied by moment matching for the weights, and evaluates the quadrature to obtain $I_{\\mathrm{NC}}$.\n   - Builds the Gauss-Legendre rule of order $n$ on $[0,R]$ by mapping nodes and weights from $[-1,1]$, and evaluates the quadrature to obtain $I_{\\mathrm{GL}}$.\n   - For each method independently, determines the largest polynomial degree $p$ (starting from $p=0$ and increasing by $1$) such that the absolute error relative to $I_{\\mathrm{exact}}$ is below a machine-zero threshold. Define machine-zero error as $|I_{\\mathrm{num}} - I_{\\mathrm{exact}}| \\le \\varepsilon$, where $\\varepsilon=10^{-13}$. Continue increasing $p$ until the inequality fails for the first time, and report the largest $p$ that satisfies the inequality for each method.\n4. Use the following test suite of parameter values to validate and compare the degree of exactness detected by the two methods:\n   - Case A: $R=1.0$, closed Newton-Cotes with $N=5$ nodes, Gauss-Legendre of order $n=3$.\n   - Case B: $R=2.5$, closed Newton-Cotes with $N=4$ nodes, Gauss-Legendre of order $n=2$.\n   - Case C: $R=0.3$, closed Newton-Cotes with $N=2$ nodes, Gauss-Legendre of order $n=1$.\n   - Case D: $R=1.7$, closed Newton-Cotes with $N=7$ nodes, Gauss-Legendre of order $n=4$.\n\nFor each case, search degrees $p$ from $0$ up to and including $12$. For each case, output the pair consisting of the largest exact degrees found for the closed Newton-Cotes rule and for the Gauss-Legendre rule. The final output format must be a single line containing a list of these pairs for all four cases, in the exact format:\n`[[p_{\\mathrm{NC},A},p_{\\mathrm{GL},A}],[p_{\\mathrm{NC},B},p_{\\mathrm{GL},B}],[p_{\\mathrm{NC},C},p_{\\mathrm{GL},C}],[p_{\\mathrm{NC},D},p_{\\mathrm{GL},D}]]`.\nAll numbers are integers, and no units or angle measures are involved since the variable is dimensionless.",
            "solution": "The problem requires a comparative analysis of the degree of exactness for closed Newton-Cotes and Gauss-Legendre quadrature rules. The analysis involves both theoretical derivation and numerical verification.\n\n### Task 1: Closed Newton-Cotes Rule Weight Derivation\n\nA closed Newton-Cotes rule with $N$ nodes on the interval $[0,R]$ approximates the integral $I=\\int_0^R f(r)\\,dr$ by a weighted sum $Q_{NC}[f]=\\sum_{i=1}^{N} w_i f(r_i)$. The nodes $\\{r_i\\}_{i=1}^{N}$ are chosen to be equally spaced, including the endpoints. The positions are given by\n$$ r_i = (i-1)h, \\quad \\text{for } i=1, 2, \\dots, N $$\nwhere the step size is $h = R/(N-1)$ for $N>1$. For $N=1$, the single node is at $r_1=0$.\n\nThe weights $\\{w_i\\}_{i=1}^{N}$ are determined by requiring the quadrature rule to be exact for a basis of polynomials. Since we have $N$ unknown weights, we can impose $N$ constraints. We choose to enforce exactness for the monomials $r^k$ for $k=0, 1, \\dots, N-1$. This guarantees exactness for any polynomial of degree up to $N-1$, as any such polynomial is a linear combination of these basis monomials.\n\nThe condition for exactness for the monomial $r^k$ is:\n$$ \\sum_{i=1}^{N} w_i r_i^k = \\int_0^R r^k\\,dr $$\nThe integral on the right-hand side, the $k$-th moment of the interval $[0,R]$, is evaluated as:\n$$ M_k = \\int_0^R r^k\\,dr = \\left[ \\frac{r^{k+1}}{k+1} \\right]_0^R = \\frac{R^{k+1}}{k+1} $$\nBy applying this condition for each $k \\in \\{0, 1, \\dots, N-1\\}$, we obtain a system of $N$ linear equations for the $N$ unknown weights $w_1, w_2, \\dots, w_N$:\n$$\n\\begin{cases}\n    w_1 r_1^0 + w_2 r_2^0 + \\dots + w_N r_N^0 &= \\frac{R^1}{1} \\\\\n    w_1 r_1^1 + w_2 r_2^1 + \\dots + w_N r_N^1 &= \\frac{R^2}{2} \\\\\n    \\vdots \\\\\n    w_1 r_1^{N-1} + w_2 r_2^{N-1} + \\dots + w_N r_N^{N-1} &= \\frac{R^N}{N}\n\\end{cases}\n$$\nThis system can be written in matrix form as $\\mathbf{V}\\mathbf{w} = \\mathbf{m}$, where:\n- $\\mathbf{w} = [w_1, w_2, \\dots, w_N]^T$ is the vector of unknown weights.\n- $\\mathbf{m} = [M_0, M_1, \\dots, M_{N-1}]^T$ is the vector of moments, with $M_k = \\frac{R^{k+1}}{k+1}$.\n- $\\mathbf{V}$ is an $N \\times N$ matrix whose elements are $V_{ki} = r_i^k$ for $k \\in \\{0, \\dots, N-1\\}$ and $i \\in \\{1, \\dots, N\\}$. This is a Vandermonde matrix.\n$$\n\\mathbf{V} =\n\\begin{pmatrix}\nr_1^0 & r_2^0 & \\dots & r_N^0 \\\\\nr_1^1 & r_2^1 & \\dots & r_N^1 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nr_1^{N-1} & r_2^{N-1} & \\dots & r_N^{N-1}\n\\end{pmatrix}\n$$\nSince the nodes $\\{r_i\\}$ are distinct for $N>1$, the Vandermonde matrix $\\mathbf{V}$ is non-singular, and a unique solution for the weight vector $\\mathbf{w}$ exists, which can be found by solving the linear system. By construction, this rule is exact for all polynomials of degree up to $N-1$. Due to symmetry properties of the nodes and weights, for odd $N$, the degree of exactness is in fact $N$.\n\n### Task 2: Gauss–Legendre Rule on $[0,R]$\n\nThe standard $n$-point Gauss-Legendre quadrature rule is defined on the interval $[-1, 1]$. It approximates an integral as:\n$$ \\int_{-1}^1 g(t)\\,dt \\approx \\sum_{j=1}^{n} w_j^* g(t_j^*) $$\nThe nodes $\\{t_j^*\\}_{j=1}^n$ are the roots of the $n$-th degree Legendre polynomial $P_n(t)$, and the weights $\\{w_j^*\\}_{j=1}^n$ are chosen such that the rule is exact for all polynomials $g(t)$ of degree up to $2n-1$.\n\nTo apply this rule to an integral on $[0,R]$, we perform an affine change of variables $r = \\alpha t + \\beta$ that maps the domain of integration $[-1,1]$ to $[0,R]$. The mapping must satisfy the boundary conditions:\n- $t=-1 \\implies r=0$: $-\\alpha + \\beta = 0$\n- $t=1 \\implies r=R$: $\\alpha + \\beta = R$\nSolving this system yields $\\alpha = R/2$ and $\\beta = R/2$. Thus, the transformation is:\n$$ r(t) = \\frac{R}{2}t + \\frac{R}{2} = \\frac{R}{2}(1+t) $$\nThe differential element transforms as $dr = (R/2)dt$. Substituting this into the integral of interest:\n$$ I = \\int_0^R f(r)\\,dr = \\int_{-1}^1 f\\left(\\frac{R}{2}(1+t)\\right) \\frac{R}{2}\\,dt $$\nWe can now apply the standard Gauss-Legendre rule to the integral on the right:\n$$ I \\approx \\sum_{j=1}^{n} w_j^* f\\left(\\frac{R}{2}(1+t_j^*)\\right) \\frac{R}{2} $$\nThis expression can be viewed as a quadrature rule on the original interval $[0,R]$, $I_{GL} = \\sum_{j=1}^{n} w_j f(r_j)$, with mapped nodes $r_j$ and mapped weights $w_j$:\n- Mapped nodes: $r_j = \\frac{R}{2}(1+t_j^*)$\n- Mapped weights: $w_j = w_j^* \\frac{R}{2}$\n\nThis quadrature rule is exact for any function $f(r)$ such that the transformed function $g(t) = f(r(t)) = f(\\frac{R}{2}(1+t))$ is a polynomial in $t$ of degree at most $2n-1$. Since the mapping $r(t)$ is linear, if $f(r)$ is a polynomial in $r$ of degree $p$, then $g(t)$ is a polynomial in $t$ of the same degree $p$. Therefore, the $n$-point Gauss-Legendre rule on $[0,R]$ is exact for all polynomials $f(r)$ of degree up to $2n-1$.\n\n### Tasks 3 and 4: Implementation and Numerical Verification\n\nThe program will determine the maximum degree of polynomial $p$ for which each quadrature rule is exact, defined as the absolute error being smaller than a numerical threshold $\\varepsilon = 10^{-13}$. For each case, the polynomial $f(r) = \\sum_{m=0}^{p} a_m r^m$ has coefficients $a_m = (-1)^m/(m+1)^2$. The exact integral is $I_{\\mathrm{exact}} = \\sum_{m=0}^{p} a_m R^{m+1}/(m+1)$. The degree $p$ is incremented from $0$ to $12$, and for each quadrature method, the largest value of $p$ satisfying $|I_{\\mathrm{num}} - I_{\\mathrm{exact}}| \\le \\varepsilon$ is recorded. The search for a given method terminates once the error condition is violated.\n\n- **For Newton-Cotes:** The weights are found by numerically solving the linear system $\\mathbf{Vw} = \\mathbf{m}$ derived in Task 1.\n- **For Gauss-Legendre:** The standard nodes and weights on $[-1,1]$ are obtained, then transformed to the interval $[0,R]$ as shown in Task 2.\n\nThe numerical results are expected to align with the theoretical degrees of exactness:\n- **Closed Newton-Cotes ($N$ nodes):** Degree of exactness is $N$ if $N$ is odd, and $N-1$ if $N$ is even.\n- **Gauss-Legendre ($n$ nodes):** Degree of exactness is $2n-1$.\n\nThe test cases are:\n- Case A: $R=1.0$, $N=5$, $n=3$. Expected $p_{NC}=5$, $p_{GL}=2(3)-1=5$.\n- Case B: $R=2.5$, $N=4$, $n=2$. Expected $p_{NC}=4-1=3$, $p_{GL}=2(2)-1=3$.\n- Case C: $R=0.3$, $N=2$, $n=1$. Expected $p_{NC}=2-1=1$, $p_{GL}=2(1)-1=1$.\n- Case D: $R=1.7$, $N=7$, $n=4$. Expected $p_{NC}=7$, $p_{GL}=2(4)-1=7$.\n\nThe implementation will confirm these theoretical predictions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Validates and compares the degree of exactness for closed Newton-Cotes\n    and Gauss-Legendre quadrature rules based on the problem statement.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (R, N for Newton-Cotes, n for Gauss-Legendre)\n        (1.0, 5, 3),\n        # Case B\n        (2.5, 4, 2),\n        # Case C\n        (0.3, 2, 1),\n        # Case D\n        (1.7, 7, 4),\n    ]\n\n    epsilon = 1e-13\n    max_p_search = 12\n    all_results = []\n\n    for R, N, n in test_cases:\n        # Determine the maximum exact degree for the Newton-Cotes rule\n        p_max_nc = -1\n        for p in range(max_p_search + 1):\n            # 1. Define polynomial and exact integral for degree p\n            coeffs = np.array([(-1)**m / (m + 1)**2 for m in range(p + 1)])\n            poly_func = np.polynomial.Polynomial(coeffs)\n            \n            I_exact = 0.0\n            for m in range(p + 1):\n                I_exact += coeffs[m] * (R**(m + 1)) / (m + 1)\n\n            # 2. Construct and evaluate the Newton-Cotes rule\n            if N == 1:\n                nc_nodes = np.array([0.0])\n            else:\n                nc_nodes = np.linspace(0, R, N, dtype=np.float64)\n\n            # Build the Vandermonde matrix V and moment vector M to solve Vw = M\n            # V_ki = nodes_i^k\n            V = nc_nodes**np.arange(N, dtype=np.float64)[:, np.newaxis]\n            M = np.array([R**(k + 1) / (k + 1) for k in range(N)], dtype=np.float64)\n            \n            try:\n                nc_weights = np.linalg.solve(V, M)\n            except np.linalg.LinAlgError:\n                # This should not happen for distinct nodes\n                p_max_nc = -2 # Indicate error\n                break\n\n            I_nc = np.sum(nc_weights * poly_func(nc_nodes))\n\n            # 3. Check for exactness\n            if abs(I_nc - I_exact) = epsilon:\n                p_max_nc = p\n            else:\n                break\n        \n        # Determine the maximum exact degree for the Gauss-Legendre rule\n        p_max_gl = -1\n        for p in range(max_p_search + 1):\n            # 1. Define polynomial and exact integral for degree p\n            coeffs = np.array([(-1)**m / (m + 1)**2 for m in range(p + 1)])\n            poly_func = np.polynomial.Polynomial(coeffs)\n            \n            I_exact = 0.0\n            for m in range(p + 1):\n                I_exact += coeffs[m] * (R**(m + 1)) / (m + 1)\n\n            # 2. Construct and evaluate the Gauss-Legendre rule\n            # Get standard nodes/weights for [-1, 1]\n            gl_nodes_std, gl_weights_std = roots_legendre(n)\n            \n            # Map nodes and weights to [0, R]\n            gl_nodes = 0.5 * R * (gl_nodes_std + 1)\n            gl_weights = 0.5 * R * gl_weights_std\n            \n            I_gl = np.sum(gl_weights * poly_func(gl_nodes))\n\n            # 3. Check for exactness\n            if abs(I_gl - I_exact) = epsilon:\n                p_max_gl = p\n            else:\n                break\n        \n        all_results.append([p_max_nc, p_max_gl])\n\n    # Final print statement in the exact required format.\n    # Format: [[p_NC,A,p_GL,A],[p_NC,B,p_GL,B],[p_NC,C,p_GL,C],[p_NC,D,p_GL,D]]\n    result_str = \",\".join([f\"[{res[0]},{res[1]}]\" for res in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The superior polynomial exactness of high-degree Newton-Cotes rules can be deceptive, as they are notoriously susceptible to Runge's phenomenon when applied to functions with sharp features. This final practice stress-tests different quadrature strategies against a synthetic integrand that mimics a localized cooling function in astrophysics. By comparing a high-degree Newton-Cotes rule, a low-order composite rule, and a Gauss-Legendre rule under a fixed budget of function evaluations, you will discover why robustness is often more critical than theoretical polynomial exactness in real-world applications. ",
            "id": "3526442",
            "problem": "Consider the synthetic integral that models a sharply localized contribution near the high-end of a normalized thermodynamic variable in computational astrophysics cooling models. Let the integral be $$Q=\\int_{0}^{1} f(x)\\,dx, \\quad \\text{where} \\quad f(x;\\varepsilon,p)=\\frac{1}{1+\\left(\\frac{1-x}{\\varepsilon}\\right)^{p}}$$ with parameters $\\varepsilon0$ controlling the width of a boundary layer near $x=1$ and integer $p\\ge 1$ controlling the steepness of the transition. This family is smooth on $[0,1]$, bounded by $0\\le f\\le 1$, and for small $\\varepsilon$ has large derivatives near $x=1$, which stresses interpolatory quadrature schemes built on equispaced nodes.\n\nYour task is to implement and compare three quadrature strategies under a fixed function-evaluation budget on $[0,1]$:\n\n- A single-panel closed Newton-Cotes rule of degree $n_{\\mathrm{NC}}$ (i.e., using $n_{\\mathrm{NC}}+1$ equispaced nodes on $[0,1]$).\n- A composite low-order Newton-Cotes scheme built from Simpson’s rule on $m$ panels, using $2m+1$ equispaced nodes on $[0,1]$.\n- An $n_{\\mathrm{G}}$-point Gauss-Legendre quadrature on $[0,1]$.\n\nAll methods must use the same number of function evaluations $N_{\\mathrm{eval}}$, with $n_{\\mathrm{NC}}+1=2m+1=n_{\\mathrm{G}}=N_{\\mathrm{eval}}$. You must choose $N_{\\mathrm{eval}}=11$, hence $n_{\\mathrm{NC}}=10$, $m=5$, and $n_{\\mathrm{G}}=11$.\n\nFor verification, use exact analytic expressions for $Q$ in the special cases $p=1$ and $p=2$, which follow from the substitution $u=(1-x)/\\varepsilon$ and are given by\n$$Q(\\varepsilon,1)=\\varepsilon\\,\\ln\\!\\left(1+\\frac{1}{\\varepsilon}\\right),\\qquad Q(\\varepsilon,2)=\\varepsilon\\,\\arctan\\!\\left(\\frac{1}{\\varepsilon}\\right).$$\n\nImplement the three quadrature methods from first principles of polynomial interpolation and orthogonal polynomials, without using any adaptive refinement. You may use standard numerical libraries to obtain weights and nodes for the high-degree closed Newton-Cotes rule and the Gauss-Legendre rule.\n\nTest Suite. Evaluate the absolute quadrature errors $\\left|Q_{\\mathrm{approx}}-Q_{\\mathrm{exact}}\\right|$ for the following parameter sets:\n- Case A: $(\\varepsilon,p)=(0.2,1)$.\n- Case B: $(\\varepsilon,p)=(0.01,1)$.\n- Case C: $(\\varepsilon,p)=(0.05,2)$.\n- Case D: $(\\varepsilon,p)=(1.0,2)$.\n- Case E: $(\\varepsilon,p)=(0.001,1)$.\n\nFor each case, report a list with three floating-point numbers corresponding to the absolute errors produced by, in order: single-panel degree-$10$ closed Newton-Cotes, composite Simpson with $m=5$ panels, and $11$-point Gauss-Legendre.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list of three floats for a test case, in the order [Case A, Case B, Case C, Case D, Case E]. For example, a valid output format is\n`[[eA1,eA2,eA3],[eB1,eB2,eB3],[eC1,eC2,eC3],[eD1,eD2,eD3],[eE1,eE2,eE3]]`\nwhere each `e..` is a floating-point number.",
            "solution": "The problem requires the implementation and comparison of three numerical quadrature methods for approximating the integral $Q=\\int_{0}^{1} f(x)\\,dx$, where the integrand is given by $f(x;\\varepsilon,p)=\\frac{1}{1+\\left(\\frac{1-x}{\\varepsilon}\\right)^{p}}$. This function models a sharp transition, or boundary layer, of width controlled by $\\varepsilon0$ near $x=1$. The steepness of this transition is governed by the integer parameter $p\\ge 1$. For small values of $\\varepsilon$, the integrand's derivatives become large near $x=1$, posing a challenge for numerical integration schemes, particularly those based on equispaced nodes.\n\nThe comparison will be performed under a fixed budget of $N_{\\mathrm{eval}}=11$ function evaluations for each method. The three methods are:\n1.  A single-panel closed Newton-Cotes rule of degree $n_{\\mathrm{NC}}=10$.\n2.  A composite Simpson’s rule over $m=5$ panels.\n3.  An $n_{\\mathrm{G}}=11$-point Gauss-Legendre quadrature.\n\nNote that the number of nodes for each method is consistent with the budget: $n_{\\mathrm{NC}}+1 = 10+1=11$, $2m+1 = 2(5)+1=11$, and $n_{\\mathrm{G}}=11$.\n\nThe accuracy of each method is assessed by computing the absolute error $|Q_{\\mathrm{approx}}-Q_{\\mathrm{exact}}|$ for several test cases. The exact value of the integral is provided for the special cases $p=1$ and $p=2$, which correspond to all test cases.\nFor $p=1$: $Q(\\varepsilon,1)=\\varepsilon\\,\\ln\\!\\left(1+\\frac{1}{\\varepsilon}\\right)$.\nFor $p=2$: $Q(\\varepsilon,2)=\\varepsilon\\,\\arctan\\!\\left(\\frac{1}{\\varepsilon}\\right)$.\n\nFor small $\\varepsilon$, the integrand $f(x)$ develops a sharp boundary layer near $x=1$. Quadrature schemes using equispaced nodes, such as the single-panel Newton-Cotes and composite Simpson's rules, are expected to perform poorly as they may not place enough sample points within this narrow region of rapid change. In contrast, Gauss-Legendre quadrature, which clusters nodes near the endpoints of the integration interval, is expected to provide a more accurate approximation by better resolving the feature at $x=1$.\n\nThe implementation of each method from first principles is detailed below.\n\n### Method 1: Single-Panel Degree-10 Closed Newton-Cotes Rule\n\nThis method approximates the integral by integrating a single interpolating polynomial of degree $n_{\\mathrm{NC}}=10$ that passes through $N_{\\mathrm{eval}}=11$ equally spaced points on the interval $[0,1]$.\nThe nodes are given by $x_i = a + i \\cdot h$ for $i=0, 1, \\dots, n_{\\mathrm{NC}}$, where the interval is $[a,b]=[0,1]$ and the step size is $h=(b-a)/n_{\\mathrm{NC}} = (1-0)/10 = 0.1$. Thus, $x_i = i/10$.\nThe quadrature formula is:\n$$ Q_{\\mathrm{NC}} = \\int_0^1 f(x) dx \\approx h \\sum_{i=0}^{n_{\\mathrm{NC}}} C_i^{(n_{\\mathrm{NC}})} f(x_i) $$\nThe Newton-Cotes coefficients, $C_i^{(n_{\\mathrm{NC}})}$, are derived from the integral of Lagrange basis polynomials. As permitted, these coefficients are obtained using a standard numerical library function, specifically `scipy.integrate.newton_cotes`. For $n_{\\mathrm{NC}}=10$ and the interval $[0,1]$, the integral approximation is calculated with $h=0.1$.\n\n### Method 2: Composite Simpson’s Rule\n\nThis method divides the integration interval $[0,1]$ into $m=5$ panels of equal width. On each panel, the function is approximated by a quadratic polynomial (Simpson's rule).\nThe total number of nodes is $N_{\\mathrm{eval}}=2m+1=11$, which are the same equispaced nodes as in the Newton-Cotes method: $x_i = i/10$ for $i=0, \\dots, 10$. The step size between adjacent nodes is $h=1/10$.\nThe composite Simpson's rule formula is:\n$$ Q_{\\mathrm{CS}} = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{j=1}^{m} f(x_{2j-1}) + 2\\sum_{j=1}^{m-1} f(x_{2j}) + f(x_{2m}) \\right] $$\nSubstituting $m=5$ and the node indices, the formula becomes:\n$$ Q_{\\mathrm{CS}} = \\frac{h}{3} \\left[ f(x_0) + 4(f(x_1)+f(x_3)+\\dots+f(x_9)) + 2(f(x_2)+f(x_4)+\\dots+f(x_8)) + f(x_{10}) \\right] $$\nThis formula is implemented directly.\n\n### Method 3: 11-Point Gauss-Legendre Quadrature\n\nGauss-Legendre quadrature provides the highest possible degree of precision for a given number of nodes by optimally placing them as the roots of Legendre polynomials. For an $n_{\\mathrm{G}}$-point rule, it exactly integrates polynomials up to degree $2n_{\\mathrm{G}}-1$.\nThe standard Gauss-Legendre rule is defined on the interval $[-1,1]$:\n$$ \\int_{-1}^1 g(\\xi) d\\xi \\approx \\sum_{i=1}^{n_{\\mathrm{G}}} w_i^{\\mathrm{std}} g(\\xi_i^{\\mathrm{std}}) $$\nwhere $\\xi_i^{\\mathrm{std}}$ are the nodes (roots of the $n_{\\mathrm{G}}$-th Legendre polynomial) and $w_i^{\\mathrm{std}}$ are the corresponding weights.\nTo apply this to the interval $[a,b]=[0,1]$, we use the linear transformation $x = \\frac{b-a}{2}\\xi + \\frac{a+b}{2}$, which for $[0,1]$ becomes $x = \\frac{1}{2}(\\xi+1)$. The differential element transforms as $dx = \\frac{1}{2}d\\xi$.\nThe integral becomes:\n$$ Q_{\\mathrm{GL}} = \\int_0^1 f(x) dx = \\int_{-1}^1 f\\left(\\frac{\\xi+1}{2}\\right) \\frac{1}{2} d\\xi \\approx \\sum_{i=1}^{n_{\\mathrm{G}}} \\left(\\frac{1}{2}w_i^{\\mathrm{std}}\\right) f\\left(\\frac{\\xi_i^{\\mathrm{std}}+1}{2}\\right) $$\nThe transformed nodes on $[0,1]$ are $x_i = (\\xi_i^{\\mathrm{std}}+1)/2$ and the transformed weights are $w_i = w_i^{\\mathrm{std}}/2$. For this problem, $n_{\\mathrm{G}}=11$. The standard nodes and weights are obtained from `numpy.polynomial.legendre.leggauss`.\n\n### Computational Strategy\n\nA Python script will be structured to perform the required calculations. For each of the five test cases defined by $(\\varepsilon,p)$:\n1. The specific integrand $f(x)$ is defined.\n2. The exact integral $Q_{\\mathrm{exact}}$ is calculated using the provided analytical formulas.\n3. The three quadrature approximations ($Q_{\\mathrm{NC}}$, $Q_{\\mathrm{CS}}$, $Q_{\\mathrm{GL}}$) are computed using $N_{\\mathrm{eval}}=11$.\n4. The absolute errors for the three methods are calculated and stored in a list.\n5. The final output is formatted as a list of these error lists, one for each test case, printed to a single line.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import newton_cotes\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Implements and compares three quadrature strategies on a test integral\n    from computational astrophysics, reporting the absolute errors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (epsilon, p), label\n        (0.2, 1, 'A'),\n        (0.01, 1, 'B'),\n        (0.05, 2, 'C'),\n        (1.0, 2, 'D'),\n        (0.001, 1, 'E'),\n    ]\n\n    # Shared parameters for all methods\n    N_eval = 11\n    a, b = 0.0, 1.0\n\n    all_results = []\n\n    for epsilon, p, _ in test_cases:\n        # 1. Define the integrand and exact solution\n        \n        # The integrand f(x; epsilon, p)\n        f = lambda x: 1.0 / (1.0 + ((1.0 - x) / epsilon)**p)\n\n        # The exact analytic solution Q(epsilon, p)\n        if p == 1:\n            Q_exact = epsilon * np.log(1.0 + 1.0 / epsilon)\n        elif p == 2:\n            Q_exact = epsilon * np.arctan(1.0 / epsilon)\n        else:\n            # This case will not be reached with the given test suite\n            raise ValueError(\"No exact solution provided for p != 1 or 2\")\n\n        # 2. Implement and apply the three quadrature methods\n\n        # Method 1: Single-panel closed Newton-Cotes of degree 10\n        n_nc = 10\n        nodes_nc = np.linspace(a, b, N_eval)\n        evals_nc = f(nodes_nc)\n        weights_nc_coeffs, _ = newton_cotes(n_nc)\n        h_nc = (b - a) / n_nc\n        Q_nc = h_nc * np.sum(weights_nc_coeffs * evals_nc)\n\n        # Method 2: Composite Simpson's rule with m=5 panels\n        m = 5\n        # Nodes are the same as for Newton-Cotes\n        nodes_cs = np.linspace(a, b, N_eval)\n        evals_cs = f(nodes_cs)\n        h_cs = (b - a) / (N_eval - 1)\n        Q_cs = (h_cs / 3.0) * (\n            evals_cs[0] + \n            4.0 * np.sum(evals_cs[1:-1:2]) + \n            2.0 * np.sum(evals_cs[2:-1:2]) + \n            evals_cs[-1]\n        )\n        # Note: evals[1:-1:2] is slightly different from problem description's sum limits\n        # but is correct for Python slicing. It selects all odd indices between 0 and N-1.\n\n        # Method 3: 11-point Gauss-Legendre quadrature\n        n_g = 11\n        nodes_gl_std, weights_gl_std = leggauss(n_g)\n        # Transform nodes and weights from [-1, 1] to [a, b] = [0, 1]\n        nodes_gl = 0.5 * (b - a) * nodes_gl_std + 0.5 * (a + b)\n        weights_gl = 0.5 * (b - a) * weights_gl_std\n        evals_gl = f(nodes_gl)\n        Q_gl = np.sum(weights_gl * evals_gl)\n\n        # 3. Calculate absolute errors\n        error_nc = abs(Q_nc - Q_exact)\n        error_cs = abs(Q_cs - Q_exact)\n        error_gl = abs(Q_gl - Q_exact)\n        \n        case_results = [error_nc, error_cs, error_gl]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists.\n    # Ex: \"[[eA1,eA2,eA3],[eB1,eB2,eB3],...]\"\n    formatted_results = [f\"[{res[0]},{res[1]},{res[2]}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}