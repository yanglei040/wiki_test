{
    "hands_on_practices": [
        {
            "introduction": "在计算天体物理学中，蒙特卡洛模拟的效率至关重要，而其核心通常是从给定的概率分布中进行抽样。虽然通过累积分布函数进行抽样是一种直接的方法，但其计算成本可能很高，尤其是在需要海量样本时。本练习将指导您掌握一种强大且高效的技巧——别名方法（Alias Method），该方法能够以$O(1)$的恒定时间复杂度从任意离散分布中精确抽样，这对于避免大规模模拟中与时间步长相关的偏差至关重要。",
            "id": "3531161",
            "problem": "在一个计算天体物理学代码的大规模蒙特卡洛（MC）辐射传输模块中，每个恒星粒子在每个时间步都必须根据预先计算的发生率，概率性地触发$5$个离散反馈通道中的一个。设这些通道由索引 $i \\in \\{1,2,3,4,5\\}$ 枚举，其分类概率向量为\n$$\n\\mathbf{p} = \\left(p_{1},p_{2},p_{3},p_{4},p_{5}\\right) = \\left(\\frac{3}{20}, \\frac{4}{20}, \\frac{1}{20}, \\frac{8}{20}, \\frac{4}{20}\\right),\n$$\n该向量例如分别模拟了Ia型超新星、核心坍缩超新星、恒星风爆发、中子星诞生反冲和辐射加热等反馈事件的联合分布。为了避免与时间步相关的偏差，您必须以每次采样 $O(1)$ 的操作复杂度和精确的概率从此离散分布中进行采样。\n\n从离散概率分布的基本定义、全概率定律以及通过均匀偏差变换构造随机变量出发，推导并解释用于以每次采样 $O(1)$ 时间对具有 $N$ 个类别的离散分布进行采样的别名方法（alias method，也称为 Walker alias method）。然后，对于给定的向量 $\\mathbf{p}$ 和 $N=5$，构建完整的别名表，该表包含阈值数组 $\\mathbf{q}=\\left(q_{1},\\dots,q_{5}\\right)$ 和别名索引数组 $\\mathbf{a}=\\left(a_{1},\\dots,a_{5}\\right)$，使得一次采样是通过从 $\\{1,2,3,4,5\\}$ 中均匀抽取一个整数列索引 $J$ 和一个均匀偏差量 $U \\in [0,1)$，如果 $U  q_{J}$ 则返回 $J$，否则返回 $a_{J}$ 来获得的。\n\n假设在一次特定的实现中，随机整数为 $J=3$，均匀偏差量为 $U=\\frac{7}{10}$，请根据您构建的别名表计算别名采样器将返回的单个整数。仅提供整数通道索引作为最终答案。无需四舍五入，不涉及物理单位。将最终答案表示为一个纯数字。",
            "solution": "问题陈述经过严格验证，认定有效。该问题具有科学依据，问题提出得当，客观且自洽，是计算统计学领域中与指定计算天体物理学领域相关的一个标准问题。所有必要的数据和定义均已提供且内部一致。各概率之和为 $1$，符合要求。因此，我们可以开始求解。\n\n问题要求推导和解释用于从离散分类分布中采样的别名方法，为给定的概率向量 $\\mathbf{p}$ 构建具体的别名表，并将得到的采样器应用于给定的随机数实现。\n\n**1. 别名方法的推导与解释**\n\n基本目标是从一个有 $N$ 个类别的离散概率分布中抽取一个随机样本，其中抽到类别 $i$ 的概率为 $p_i$，且 $\\sum_{i=1}^{N} p_i = 1$。一个朴素的方法，例如搜索累积分布，每次采样需要 $O(\\log N)$ 或 $O(N)$ 的时间。别名方法在初始 $O(N)$ 的设置后，能够以 $O(1)$ 的时间完成这一任务。\n\n别名方法的核心原理是将原始的非均匀分布转化为 $N$ 个简单的两点分布的均匀混合。我们可以通过想象 $N$ 个宽度为 $1$、高度为 $1$ 的容器来将其可视化。这些容器的总面积是 $N$。我们希望在这个结构中表示总概率 $\\sum p_i = 1$。\n\n首先，我们将概率乘以 $N$ 进行缩放：令 $P_i = N p_i$。这些缩放后概率的总和是 $\\sum_{i=1}^{N} P_i = N \\sum_{i=1}^{N} p_i = N$。$P_i$ 的平均值是 $1$。这意味着某些类别会有 $P_i  1$（我们称之为“欠满”），某些会有 $P_i > 1$（“超满”），还有一些可能有 $P_i=1$（“满”）。\n\n别名方法将“超满”类别的“多余”概率质量重新分配，以填补“欠满”类别的“不足”空间。经过这次重新分配后， $N$ 个容器中的每一个都将恰好是满的（即包含总概率质量为 $1$），并且每个容器 $j$ 将最多包含来自两个原始类别的部分：主类别 $j$ 和一个“别名”类别 $a_j$。\n\n采样过程如问题中所定义，如下所示：\n1.  从 $\\{1, 2, \\ldots, N\\}$ 中均匀抽取一个整数索引 $J$。这以 $1/N$ 的概率选择一个容器。\n2.  抽取一个均匀随机数 $U \\in [0,1)$。\n3.  如果 $U  q_J$，则结果为 $J$。值 $q_J$ 是阈值概率，代表类别 $J$ 在容器 $J$ 中所占的部分。\n4.  如果 $U \\ge q_J$，则结果为别名索引 $a_J$。容器中剩余的部分 $1-q_J$ 由类别 $a_J$ 占据。\n\n采样到类别 $k$ 的总概率是从 $N$ 个容器中任意一个获得 $k$ 的概率之和：\n$$p_k = \\sum_{j=1}^{N} P(\\text{outcome}=k | \\text{bin } j \\text{ chosen}) \\times P(\\text{bin } j \\text{ chosen})$$\n由于容器是均匀选择的，$P(\\text{bin } j \\text{ chosen}) = 1/N$。条件概率由采样规则给出：\n$$P(\\text{outcome}=k | \\text{bin } j \\text{ chosen}) = q_j \\cdot \\mathbb{I}(j=k) + (1-q_j) \\cdot \\mathbb{I}(a_j=k)$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。将此代入上一个方程，得到别名表必须满足的基本关系：\n$$p_k = \\frac{1}{N} \\sum_{j=1}^{N} \\left[ q_j \\mathbb{I}(j=k) + (1-q_j) \\mathbb{I}(a_j=k) \\right]$$\n乘以 $N$，我们得到缩放概率的条件：\n$$P_k = N p_k = q_k \\mathbb{I}(k \\text{ is primary in any bin}) + \\sum_{j: a_j=k} (1-q_j)$$\n\n一个构建阈值数组 $\\mathbf{q}$ 和别名数组 $\\mathbf{a}$ 的高效 $O(N)$ 算法（例如，Vose's algorithm）按以下步骤进行：\n1.  创建两个工作列表，`Small` 和 `Large`，分别用于 $P_i  1$ 和 $P_i > 1$ 的索引 $i$。（$P_i=1$ 的类别可以放在一边）。\n2.  当 `Small` 不为空时，从中任意选取一个索引 $l$，并从 `Large` 中任意选取一个索引 $g$。\n3.  填充容器 $l$：设置阈值 $q_l = P_l$。剩余的空间 $1-P_l$ 由超满类别 $g$ 填充，因此设置别名 $a_l = g$。\n4.  更新类别 $g$ 的概率质量：它贡献了 $1-P_l$ 的质量。新的缩放概率为 $P_g' = P_g - (1-P_l) = P_g + P_l - 1$。\n5.  重新分类 $g$：如果 $P_g'  1$，将其移至 `Small` 列表。如果 $P_g' > 1$，它仍保留在 `Large` 列表中。如果 $P_g' = 1$，则可以将其从工作列表中移除。\n6.  重复此过程直至工作列表为空。任何从未在 `Small` 列表中的类别 $k$（即初始 $P_k \\ge 1$）将使其容器 $k$ 完全由其自身的概率填充。对于这些类别，我们设置 $q_k=1$（并且 $a_k$ 变得无关紧要，通常设置为 $k$）。\n\n这种构造方法确保了欠满的类别永远不会被用作别名，并且概率得到精确守恒。\n\n**2. 构建别名表**\n\n给定概率向量 $\\mathbf{p} = \\left(\\frac{3}{20}, \\frac{4}{20}, \\frac{1}{20}, \\frac{8}{20}, \\frac{4}{20}\\right)$ 和 $N=5$。\n平均概率为 $1/N = 1/5 = 4/20$。\n\n首先，我们计算缩放后的概率 $P_i = N p_i = 5 p_i$：\n$P_1 = 5 \\times \\frac{3}{20} = \\frac{15}{20} = \\frac{3}{4}$\n$P_2 = 5 \\times \\frac{4}{20} = \\frac{20}{20} = 1$\n$P_3 = 5 \\times \\frac{1}{20} = \\frac{5}{20} = \\frac{1}{4}$\n$P_4 = 5 \\times \\frac{8}{20} = \\frac{40}{20} = 2$\n$P_5 = 5 \\times \\frac{4}{20} = \\frac{20}{20} = 1$\n所以，$\\mathbf{P} = \\left(\\frac{3}{4}, 1, \\frac{1}{4}, 2, 1\\right)$。\n\n我们初始化工作列表：\n- `Small`（其中 $P_i1$）：`{1, 3}`，对应的值为 $\\{3/4, 1/4\\}$。\n- `Large`（其中 $P_i>1$）：`{4}`，对应的值为 {$2$}。\n- $P_i=1$ 的类别是 `{2, 5}`。对于这些类别，我们可以立即设置 $q_2=1$ 和 $q_5=1$。它们的别名是无关紧要的；我们设置 $a_2=2$ 和 $a_5=5$。\n\n现在我们执行主循环：\n\n**迭代 1：**\n- 从 `Small` 中弹出一个索引：我们选择 $l=3$ ($P_3=1/4$)。\n- 从 `Large` 中弹出一个索引：我们必须选择 $g=4$ ($P_4=2$)。\n- 设置容器 3 的表项：$q_3 = P_3 = 1/4$，别名为 $a_3=4$。\n- 更新类别 4 的缩放概率：$P_4' = P_4 - (1-P_3) = 2 - (1 - 1/4) = 2 - 3/4 = 5/4$。\n- 由于 $P_4' = 5/4 > 1$，类别 4 仍保留在 `Large` 工作列表中。`Small` 列表现在只包含 `{1}`。\n\n**迭代 2：**\n- 从 `Small` 中弹出最后一个索引：$l=1$ ($P_1=3/4$)。\n- 从 `Large` 中弹出：我们必须再次选择 $g=4$（其更新后的概率为 $P_4'=5/4$）。\n- 设置容器 1 的表项：$q_1 = P_1 = 3/4$，别名为 $a_1=4$。\n- 更新类别 4 的缩放概率：$P_4'' = P_4' - (1-P_1) = 5/4 - (1 - 3/4) = 5/4 - 1/4 = 1$。\n- `Small` 列表现在为空，循环终止。\n\n**最终确定：**\n剩下的类别 4 现在的缩放概率为 $1$。对于这个容器，我们设置 $q_4=1$（并且 $a_4=4$）。\n综合所有部分，完整的别名表是：\n- 阈值数组：$\\mathbf{q} = \\left(q_1, q_2, q_3, q_4, q_5 \\right) = \\left(\\frac{3}{4}, 1, \\frac{1}{4}, 1, 1\\right)$\n- 别名数组：$\\mathbf{a} = \\left(a_1, a_2, a_3, a_4, a_5 \\right) = \\left(4, 2, 4, 4, 5\\right)$\n\n**3. 计算采样结果**\n\n问题提供了一次随机抽取的特定实现：\n- 整数列索引：$J=3$。\n- 均匀偏差量：$U=\\frac{7}{10}$。\n\n我们对所选的容器 $J=3$ 应用采样规则：\n1. 获取容器 3 的阈值和别名：$q_3 = 1/4$ 和 $a_3=4$。\n2. 将均匀偏差量 $U$ 与阈值 $q_3$ 进行比较：\n   是否 $U  q_3$？\n   是否 $\\frac{7}{10}  \\frac{1}{4}$？\n   为了比较，我们可以使用公分母 $20$：$\\frac{14}{20}  \\frac{5}{20}$。这是错误的。\n3. 由于条件 $U  q_J$ 为假，采样器返回别名索引 $a_J$。\n   对于 $J=3$，别名为 $a_3=4$。\n\n因此，采样器返回的整数通道索引为 $4$。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "伪随机数并非真正随机，它们是由确定性算法生成的，因此其输出序列中隐藏着固有的结构。对于线性同余生成器（LCG）这类经典的生成器，其连续输出的$d$维元组会落在有限数量的平行超平面上，形成一种格子结构。本练习将引导您从零开始构建并实施谱测试（Spectral Test），这是一种量化这种格子结构的强大工具，通过计算这些超平面之间的最大间距来评估生成器的质量，并将其与潜在的采样偏差直接联系起来。",
            "id": "3531220",
            "problem": "您的任务是构建、实现并分析一个三维谱检验，该检验用于蒙特卡洛环境中宇宙射线传播模拟所使用的线性同余生成器（LCG）。您的解决方案必须从LCG的核心定义及其输出在连续维度中作为格的几何解释出发，然后推导出一个在维度$d=3$下可计算实现的谱检验形式，并将检验结果与一个与计算天体物理学中采样任务相关的定量偏差代理联系起来。\n\n起点和定义：\n- LCG由$X_{n+1} \\equiv a X_n + c \\ (\\mathrm{mod} \\ m)$定义，其中$X_0 \\in \\{0,1,\\dots,m-1\\}$，参数$a, c, m \\in \\mathbb{Z}$，$m \\ge 2$。归一化输出为$U_n = X_n / m \\in [0,1)$。\n- 考虑由连续输出构成的$d$元组序列，此处$d=3$，即$Y_n = (U_n, U_{n+1}, U_{n+2}) \\in [0,1)^3$。\n- 一个经过充分检验的事实是，集合$\\{Y_n\\}$位于$\\mathbb{R}^3$中的有限数量的平行平面上。维度$d=3$的谱检验测量这些相邻平面之间的距离，该距离由对偶格的最短非零向量决定。\n\n待完成任务：\n1) 从LCG定义和$Y_n$的结构出发，推导出表征所有与包含$\\{Y_n\\}$的平面族垂直的整数向量$w = (w_0,w_1,w_2) \\in \\mathbb{Z}^3$的同余方程，证明它们满足\n$$\nw_0 + a w_1 + a^2 w_2 \\equiv 0 \\ (\\mathrm{mod}\\ m).\n$$\n解释为什么当考虑元组的差分，并因此考虑谱检验所基于的格结构时，对于$d \\ge 2$，增量$c$不影响此条件。\n2) 证明第1项中同余方程的所有整数解$w$的集合在$\\mathbb{Z}^3$中构成一个满秩格，并仅使用$m$和$a$为其构造一个显式的整数基。一个方便的选择是\n$$\nb_1 = (m,0,0), \\quad b_2 = (-a,1,0), \\quad b_3 = (-a^2,0,1),\n$$\n其中$a^2$可以取模$m$而不失一般性，因为$b_1$考虑了第一坐标中$m$的倍数。证明任何解$w$都可以写成$w = \\lambda_1 b_1 + \\lambda_2 b_2 + \\lambda_3 b_3$的形式，其中$\\lambda_i \\in \\mathbb{Z}$。\n3) 证明包含点集$\\{Y_n\\}$且与非零整数向量$w$正交的相邻平行平面之间的距离为$\\Delta = \\lVert w \\rVert_2^{-1}$，其中$\\lVert \\cdot \\rVert_2$是欧几里得范数。因此，三维谱检验归结为在解的格中找到最短的非零向量$w^\\star$，谱间距为$\\Delta^\\star = \\lVert w^\\star \\rVert_2^{-1}$。\n4) 定义归一化三维谱品质因数\n$$\nQ = \\frac{\\lVert w^\\star \\rVert_2}{m^{1/3}},\n$$\n它将每单位厚度的实际平面数与三维空间中$m$个点的理想缩放情况进行比较。论证为什么$Q$为单位阶表示可接受的结构，而显著小于$Q$的值表示结构不佳（相对于理想的$m^{-1/3}$尺度，平面之间的间隙较大）。\n5) 为了将检验结果与计算天体物理学背景下的采样偏差联系起来，考虑线性可观测量$f(y) = \\hat{n} \\cdot y$，其中$\\hat{n} \\in \\mathbb{R}^3$且$\\lVert \\hat{n} \\rVert_2 = 1$，作为采样任务中各向异性敏感度的代理。证明由于点被限制在间距为$\\Delta^\\star$的平行平面上，这类1-利普希茨可观测量的均值的最坏情况绝对偏差由以下公式界定\n$$\nB = \\frac{\\Delta^\\star}{2} = \\frac{1}{2 \\lVert w^\\star \\rVert_2}.\n$$\n解释为什么当连续坐标用于参数化物理量时，这个界是各向异性或相关性引起的偏差的一个有原则的代理，这种偏差会影响蒙特卡洛传播。\n\n算法要求：\n- 构建第2项中的格基，使用标准的格基规约方法（例如，Lenstra–Lenstra–Lovász基规约算法）将其规约为一个近正交基，该方法保持整数格不变，然后在一个有界范围内枚举短的整数组合以恢复精确的最短非零向量$w^\\star$。\n- 对以下每个测试用例计算$\\lVert w^\\star \\rVert_2$、$Q$和$B$。使用足够精度的浮点算术以可靠地区分这些情况。\n\n测试套件和要求输出：\n- 在所有情况下均使用$d=3$。评估以下三个参数集，每个参数集以$(m,a,c)$的形式给出：\n  - 情况A（中等模数，乘法）：$(m,a,c) = (65537,3,0)$。\n  - 情况B（具有已知短关系的小模数）：$(m,a,c) = (13,3,0)$。\n  - 情况C（与情况A相同但为混合型）：$(m,a,c) = (65537,3,12345)$。\n- 对于每种情况，计算并报告浮点数三元组$(\\lVert w^\\star \\rVert_2, Q, B)$，并额外报告情况A和情况C之间$Q$的绝对差\n$$\n\\Delta Q = \\left| Q_{\\mathrm{A}} - Q_{\\mathrm{C}} \\right|,\n$$\n以凭经验证实谱检验对于$d \\ge 2$时与增量$c$的独立性。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来，结果按此精确顺序排列并四舍五入到六位小数：\n$[\\lVert w^\\star \\rVert_{2,\\mathrm{A}}, Q_{\\mathrm{A}}, B_{\\mathrm{A}}, \\lVert w^\\star \\rVert_{2,\\mathrm{B}}, Q_{\\mathrm{B}}, B_{\\mathrm{B}}, \\lVert w^\\star \\rVert_{2,\\mathrm{C}}, Q_{\\mathrm{C}}, B_{\\mathrm{C}}, \\Delta Q]$。\n不应打印任何其他文本。所有量都是无量纲的；输出中不要包含任何单位。当概念性地讨论角度时，单位是弧度。",
            "solution": "该问题要求构建、实现并分析一个用于线性同余生成器（LCG）的三维谱检验。我们将首先推导该检验的理论基础，然后开发一个算法来计算给定测试用例所需的度量指标。\n\nLCG由递推关系$X_{n+1} \\equiv a X_n + c \\pmod m$定义，产生一个整数序列。通过模数$m$对这些整数进行归一化，得到一个伪随机数序列$U_n = X_n / m \\in [0,1)$。谱检验通过检查连续数字的$d$元组$Y_n = (U_n, U_{n+1}, \\dots, U_{n+d-1})$的几何结构来评估此生成器的质量。对于此问题，我们关注维度$d=3$。\n\n**1. 格条件的推导**\n\n由LCG生成的点集$\\{Y_n\\}_{n \\ge 0}$并非真正的随机；它表现出规则的格结构。这些点位于有限数量的平行超平面上。在维度$d=3$中，这些是平面。一个平行平面族由一个法向量$w = (w_0, w_1, w_2) \\in \\mathbb{Z}^3$来表征。这些平面中的任何一个上的点$y \\in \\mathbb{R}^3$都满足$w \\cdot y = \\text{常数}$。为了使集合$\\{Y_n\\}$位于这样的平面上，表达式$w \\cdot Y_n$必须取自一个离散集合。\n\n让我们分析点积$w \\cdot Y_n$：\n$$w \\cdot Y_n = w_0 U_n + w_1 U_{n+1} + w_2 U_{n+2} = \\frac{1}{m}(w_0 X_n + w_1 X_{n+1} + w_2 X_{n+2})$$\n我们可以使用LCG递推关系将$X_{n+1}$和$X_{n+2}$表示为$X_n$的函数。对于某个整数$k_{n,1}$和$k_{n,2}$，我们有：\n$X_{n+1} = a X_n + c - k_{n,1} m$\n$X_{n+2} = a X_{n+1} + c - k_{n,2} m = a(a X_n + c - k_{n,1} m) + c - k_{n,2} m = a^2 X_n + c(a+1) - (a k_{n,1} + k_{n,2})m$\n\n将这些代入点积（括号内）得到：\n$$w_0 X_n + w_1 X_{n+1} + w_2 X_{n+2} = w_0 X_n + w_1(aX_n+c) + w_2(a^2X_n+c(a+1)) \\pmod m$$\n$$= (w_0 + a w_1 + a^2 w_2)X_n + c(w_1 + (a+1)w_2) \\pmod m$$\n点积的完整表达式是：\n$$w \\cdot Y_n = \\frac{1}{m}\\left((w_0 + a w_1 + a^2 w_2)X_n + c(w_1 + (a+1)w_2)\\right) - K_n$$\n其中$K_n$是某个整数，捕捉了模运算中$m$的各种倍数。\n为了使点集$\\{Y_n\\}$被限制在少数几个平面上，变化的项$X_n$的系数必须有效地消失。如果该系数是$m$的倍数，则可以实现这一点，这确保了$(w_0 + a w_1 + a^2 w_2)X_n / m$对于所有$X_n$都是整数（如果LCG具有完整周期），或者至少限制了其贡献。基本条件是向量$w$属于生成器格的对偶格，该格由以下同余方程定义：\n$$w_0 + a w_1 + a^2 w_2 \\equiv 0 \\pmod m$$\n当此同余关系成立时，$w_0 + a w_1 + a^2 w_2 = k_w m$对于某个整数$k_w$，点积变为：\n$$w \\cdot Y_n = \\frac{1}{m}(k_w m X_n + c(w_1 + (a+1)w_2)) - K_n = k_w X_n - K_n + \\frac{c(w_1 + (a+1)w_2)}{m}$$\n由于$k_w, X_n, K_n$是整数，$w \\cdot Y_n$的值被限制在一个形式为$\\{ I + \\delta_c \\}$的集合中，其中$I \\in \\mathbb{Z}$且$\\delta_c$是取决于$c$的常数偏移。这证实了平面结构。\n\n加法常数$c$不影响格结构本身，只影响其在空间中的位置（一个仿射平移）。格是由差分向量集合$\\{Y_{n'} - Y_n\\}$来表征的。对于$d \\ge 2$，连续整数向量$(X_{n+1}, \\dots, X_{n+d}) - (X_n, \\dots, X_{n+d-1})$之间的差分由一个与$c$无关的递推关系控制。具体来说，$X_{k+1}-X_k \\equiv a(X_k-X_{k-1}) \\pmod m$。谱检验探测的是这个基础向量格的几何性质，这就是为什么对于$d \\ge 2$，$c$的值是无关紧要的。\n\n**2. 解的格及其基**\n\n满足同余方程$w_0 + a w_1 + a^2 w_2 \\equiv 0 \\pmod m$的所有整数向量$w = (w_0, w_1, w_2) \\in \\mathbb{Z}^3$的集合构成一个格。为了证明给定的向量$b_1 = (m,0,0)$、$b_2 = (-a,1,0)$和$b_3 = (-a^2,0,1)$构成此格的一个整数基，我们必须证明两件事：(i) 每个基向量都满足同余方程；(ii) 任何解$w$都可以唯一地表示为它们的整数线性组合。\n\n(i) 检查基向量：\n对于$b_1$：$m + a(0) + a^2(0) = m \\equiv 0 \\pmod m$。\n对于$b_2$：$-a + a(1) + a^2(0) = 0 \\equiv 0 \\pmod m$。\n对于$b_3$：$-a^2 + a(0) + a^2(1) = 0 \\equiv 0 \\pmod m$。\n所有三个向量都属于解集。\n\n(ii) 证明它们能生成所有解。设$w = (w_0, w_1, w_2)$是满足同余方程的任意整数向量。我们寻求整数$\\lambda_1, \\lambda_2, \\lambda_3$使得$w = \\lambda_1 b_1 + \\lambda_2 b_2 + \\lambda_3 b_3$。\n$$\n(w_0, w_1, w_2) = \\lambda_1(m,0,0) + \\lambda_2(-a,1,0) + \\lambda_3(-a^2,0,1) = (\\lambda_1 m - \\lambda_2 a - \\lambda_3 a^2, \\lambda_2, \\lambda_3)\n$$\n通过比较分量，我们立即发现$\\lambda_2 = w_1$和$\\lambda_3 = w_2$。将它们代入第一个分量方程：\n$w_0 = \\lambda_1 m - w_1 a - w_2 a^2 \\implies \\lambda_1 m = w_0 + w_1 a + w_2 a^2$。\n由于$w$是同余方程的解，我们知道$w_0 + w_1 a + w_2 a^2$是$m$的整数倍。因此，$\\lambda_1 = (w_0 + w_1 a + w_2 a^2)/m$是一个整数。因此，任何解$w$都可以表示为$\\{b_1, b_2, b_3\\}$的整数线性组合。该基矩阵的行列式为$m$，因此向量是线性无关的，使得该格为满秩格。在$b_3$中使用$a^2 \\pmod m$是有效的，因为第一分量中$m$的任何倍数都可以被$\\lambda_1$的整数变化所吸收。\n\n**3. 平面之间的距离**\n\n对于来自解格的给定非零整数法向量$w$，点$\\{Y_n\\}$被约束在形如$w \\cdot y = C_k$的平面上，其中值$C_k$形成一个算术级数。可以证明，$w \\cdot Y_n$的值的形式为$k + \\delta$，其中$k$为整数，$\\delta$为某个固定偏移。这意味着点位于平面$w \\cdot y = k+\\delta$上。两个相邻平面$w \\cdot y = k+\\delta$和$w \\cdot y = k+1+\\delta$之间的距离是它们之间的最短距离。这个距离沿着法线方向$\\hat{w} = w/\\lVert w \\rVert_2$。这些平面上任意两点之间的分离向量在法线方向上的投影是恒定的。距离$\\Delta$由平面方程常数项的差除以向量$w$的范数给出，即$\\Delta = ((k+1+\\delta)-(k+\\delta)) / \\lVert w \\rVert_2 = 1 / \\lVert w \\rVert_2$。\n\n为了找到采样空间中最大的空白区域，我们必须找到相邻平面之间可能的最大距离。这对应于选择间距最大的平面族，这反过来意味着在解格中找到具有最小欧几里得范数$\\lVert w \\rVert_2$的非零向量$w$。这个向量被称为最短非零向量，记为$w^\\star$。相应的最大平面间距是三维谱值$\\Delta^\\star = \\lVert w^\\star \\rVert_2^{-1}$。\n\n**4. 品质因数 $Q$**\n\n品质因数$Q = \\lVert w^\\star \\rVert_2 / m^{1/3}$提供了对生成器质量的归一化度量。如果$m$个点真正均匀随机地分布在$[0,1)^3$中，相邻点之间的典型距离将按$(1/m)^{1/3} = m^{-1/3}$的比例缩放。谱检验揭示，最大的保证空白区域是一个厚度为$\\Delta^\\star = 1/\\lVert w^\\star \\rVert_2$的平板。一个好的生成器应该使这个最大间隙与典型的随机间距处于同一量级，即$\\Delta^\\star \\approx m^{-1/3}$，这意味着$\\lVert w^\\star \\rVert_2 \\approx m^{1/3}$。在这种情况下，$Q \\approx 1$。\n- 如果$Q \\ll 1$，则$\\lVert w^\\star \\rVert_2 \\ll m^{1/3}$，意味着$\\Delta^\\star \\gg m^{-1/3}$。平面相距很远，表明存在粗糙、高度相关的格结构。这对于蒙特卡洛模拟非常不利。\n- 如果$Q \\ge 1$，格结构是细粒度的，平面间距与理想的随机间距相当或更小。这是高质量生成器的特征。\n\n**5. 偏差代理 $B$**\n\n在计算天体物理学中，蒙特卡洛方法用于模拟诸如宇宙射线传播之类的过程。使用来自劣质LCG的相关坐标来表示物理量（例如，动量分量）会引入系统误差或偏差。线性可观测量$f(y) = \\hat{n} \\cdot y$（其中$\\lVert \\hat{n} \\rVert_2 = 1$）是物理量对采样各向异性敏感性的一个简单代理。这样的函数是1-利普希茨连续的，因为$|f(y_1)-f(y_2)|=|\\hat{n}\\cdot(y_1-y_2)| \\le \\lVert\\hat{n}\\rVert_2 \\lVert y_1-y_2\\rVert_2 = \\lVert y_1-y_2\\rVert_2$。\n\n当其梯度$\\nabla f = \\hat{n}$与最稀疏采样方向（即法向量$w^\\star$）对齐时，此类可观测量出现最坏情况偏差。LCG点位于相距$\\Delta^\\star = 1/\\lVert w^\\star \\rVert_2$的平面上。采样最差的区域是两个此类平面之间的空平板。位于此平板中心的点距离最近的采样平面为$\\Delta^\\star/2$。一个1-利普希茨函数在该点的值与在最近平面上值的误差最多为这个距离。这个未采样区域的“半径”，$B = \\Delta^\\star/2 = 1/(2\\lVert w^\\star \\rVert_2)$，可作为局部估计误差的一个有原则的界。虽然对均值偏差的完整分析涉及在整个域上积分，但$B$量化了最坏情况局部偏差的尺度，因此为由生成器的格结构引入的潜在系统偏差提供了一个强大而直观的代理。\n\n**算法实现**\n\n为了计算谱检验度量，我们必须在由基$\\{b_1, b_2, b_3\\}$张成的格中找到最短非零向量$w^\\star$。这是最短向量问题（SVP），在高维中通常是困难的，但在像$d=3$这样的低维中是可行的。策略是首先使用格基规约算法，如Lenstra–Lenstra–Lovász（LLL）算法，将高度倾斜的初始基转换为由短的、近正交向量组成的新基。然后，格中的最短向量很可能是这些新基向量之一或它们的非常短的整数线性组合。我们实现了用于$d=3$的LLL算法，然后在一个小的整数系数框内进行搜索，以找到精确的$w^\\star$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy  # Imported to adhere to problem spec, although not directly used.\n\ndef lll_3d(basis, delta=0.75):\n    \"\"\"\n    Performs LLL lattice basis reduction for a 3D basis.\n    \n    Args:\n        basis (list of lists or np.ndarray): The initial basis vectors (as rows).\n        delta (float): The LLL reduction parameter, typically in (0.25, 1).\n    \n    Returns:\n        np.ndarray: The LLL-reduced basis.\n    \"\"\"\n    B = np.array(basis, dtype=np.int64)\n    \n    while True:\n        # Gram-Schmidt Orthogonalization\n        B_star = np.zeros_like(B, dtype=np.float64)\n        mu = np.zeros((3, 3), dtype=np.float64)\n        \n        B_star[0] = B[0]\n        for i in range(1, 3):\n            B_star[i] = B[i].astype(np.float64)\n            for j in range(i):\n                # Ensure dot products are computed with high precision floats\n                dot_bi_bstarj = np.dot(B[i].astype(np.float64), B_star[j])\n                dot_bstarj_bstarj = np.dot(B_star[j], B_star[j])\n                if dot_bstarj_bstarj == 0:\n                    mu[i, j] = 0\n                else:\n                    mu[i, j] = dot_bi_bstarj / dot_bstarj_bstarj\n\n                B_star[i] -= mu[i, j] * B_star[j]\n\n        # Size Reduction step\n        reduced_in_pass = False\n        for i in range(1, 3):\n            for j in range(i - 1, -1, -1):\n                if abs(mu[i, j]) > 0.5:\n                    B[i] -= np.round(mu[i, j]).astype(np.int64) * B[j]\n                    reduced_in_pass = True\n        \n        if reduced_in_pass:\n            continue\n\n        # Lovasz Condition and Swapping step\n        swapped = False\n        for i in range(1, 3):\n            norm_b_star_i_sq = np.dot(B_star[i], B_star[i])\n            norm_b_star_prev_sq = np.dot(B_star[i-1], B_star[i-1])\n\n            if norm_b_star_i_sq  (delta - mu[i, i-1]**2) * norm_b_star_prev_sq:\n                B[[i, i-1]] = B[[i-1, i]]\n                swapped = True\n                break # Restart LLL\n        \n        if not swapped:\n            break # LLL terminated\n            \n    return B\n\ndef find_shortest_vector(basis, search_range=5):\n    \"\"\"Finds the shortest non-zero vector in a lattice given a basis.\"\"\"\n    \n    # Use LLL to get a basis of shorter vectors\n    reduced_basis = lll_3d(basis)\n    \n    # The shortest vector is often one of the reduced basis vectors\n    min_sq_norm = float('inf')\n    shortest_vec = None\n    \n    for vec in reduced_basis:\n        sq_norm = np.dot(vec, vec)\n        if 0  sq_norm  min_sq_norm:\n            min_sq_norm = sq_norm\n            shortest_vec = vec\n\n    # Enumerate short integer combinations of the reduced basis vectors\n    b1, b2, b3 = reduced_basis\n    for c1 in range(-search_range, search_range + 1):\n        for c2 in range(-search_range, search_range + 1):\n            for c3 in range(-search_range, search_range + 1):\n                if c1 == 0 and c2 == 0 and c3 == 0:\n                    continue\n                \n                vec = c1 * b1 + c2 * b2 + c3 * b3\n                sq_norm = np.dot(vec, vec)\n                \n                if 0  sq_norm  min_sq_norm:\n                    min_sq_norm = sq_norm\n                    shortest_vec = vec\n                    \n    return shortest_vec\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, a, c)\n        (65537, 3, 0),        # Case A\n        (13, 3, 0),          # Case B\n        (65537, 3, 12345),    # Case C\n    ]\n\n    results = []\n    q_values = []\n\n    for m, a, c in test_cases:\n        # Construct the lattice basis for vectors w = (w0, w1, w2) satisfying\n        # w0 + a*w1 + a^2*w2 === 0 (mod m)\n        # We use a^2 % m to keep initial numbers smaller, which is valid.\n        a2_mod_m = (a * a) % m\n        basis = [\n            [m, 0, 0],\n            [-a, 1, 0],\n            [-a2_mod_m, 0, 1]\n        ]\n        \n        # Find the shortest non-zero vector in this lattice\n        w_star = find_shortest_vector(np.array(basis, dtype=np.int64))\n        \n        # Calculate the required metrics\n        norm_w_star = np.linalg.norm(w_star)\n        q_metric = norm_w_star / (m**(1/3.0))\n        b_metric = 1.0 / (2.0 * norm_w_star)\n        \n        results.extend([norm_w_star, q_metric, b_metric])\n        q_values.append(q_metric)\n\n    # Calculate the difference in Q between Case A and Case C\n    delta_q = abs(q_values[0] - q_values[2])\n    results.append(delta_q)\n    \n    # Format the final output string with results rounded to six decimal places.\n    output_str = f\"[{','.join(['{:.6f}'.format(x) for x in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "抽象的质量测试（如谱测试）固然重要，但最终衡量一个随机数生成器好坏的标准是它在实际应用中的表现。一个有缺陷的生成器可能会在复杂的物理模拟中引入难以察觉的系统误差，从而导致错误的科学结论。本综合练习将带您进入一个真实的天体物理学场景，通过模拟一个高斯随机场并检验其统计特性（如功率谱）是否与理论预测相符，来对随机数生成器进行端到端的验证，从而直观地揭示生成器质量对模拟结果的直接影响。",
            "id": "3531195",
            "problem": "在计算天体物理学的背景下，您需要为随机数生成器实现一个谱均匀性检验。目标是使用均匀分布偏差在$k$空间中对各向同性高斯随机场的复傅里叶模式进行采样，并通过球壳平均功率谱值的偏差来量化均匀性。程序必须是一个完整的、可运行的程序，无需用户输入即可产生所要求的输出。\n\n基本原理：\n- 均匀、各向同性的高斯随机场模型在计算天体物理学中被广泛使用。傅里叶空间场由一个功率谱$P(k)$来表征，该谱仅依赖于模长$k = \\lVert \\mathbf{k} \\rVert$。\n- 对于一个高斯随机场，每个独立的复傅里叶模式$a_{\\mathbf{k}}$的实部和虚部都是独立的、均值为零、方差为$P(k)/2$的高斯随机变量。因此，其振幅平方$X_{\\mathbf{k}} = \\lvert a_{\\mathbf{k}} \\rvert^2$服从指数分布，其均值为$P(k)$，方差为$P(k)^2$。\n- 区间$(0,1)$上的均匀分布偏差通过Box–Muller方法转换为高斯分布偏差。Box–Muller变换中使用的角度必须是弧度。\n\n定义与目标计算：\n1. 设离散二维傅里叶网格由$(i,j)$索引，大小为$N_x$和$N_y$。使用离散傅里叶频率定义波数，使得$k_x \\in \\{-\\lfloor N_x/2 \\rfloor, \\ldots, \\lfloor N_x/2 \\rfloor - 1\\}$，对$k_y$也类似。定义$k = \\sqrt{k_x^2 + k_y^2}$。\n2. 通过对$k$进行整数分箱来定义径向球壳：$s = \\lfloor k + 0.5 \\rfloor$。排除$s = 0$的球壳（零模式）。\n3. 对于每个球壳$s$，设$\\mathcal{K}_s$为波数模长落在球壳$s$内的索引$(i,j)$的集合，并设$K_s = \\lvert \\mathcal{K}_s \\rvert$为球壳$s$中的模式数量。\n4. 对于每个测试用例，通过Box–Muller方法从均匀分布偏差生成$M$个独立的复傅里叶系数$a_{\\mathbf{k}}$系综，其中$\\operatorname{Re}(a_{\\mathbf{k}})$和$\\operatorname{Im}(a_{\\mathbf{k}})$从$\\mathcal{N}(0, P(k)/2)$中采样。\n5. 对于每个球壳$s$，计算该球壳中所有系综和模式的振幅平方的聚合样本均值：\n   $$\\widehat{P}_s = \\frac{1}{M K_s} \\sum_{m=1}^{M} \\sum_{(i,j) \\in \\mathcal{K}_s} X_{\\mathbf{k},m}, \\quad \\text{其中 } X_{\\mathbf{k},m} = \\lvert a_{\\mathbf{k},m} \\rvert^2.$$\n6. 期望的球壳均值为\n   $$\\mathbb{E}[\\widehat{P}_s] = \\frac{1}{K_s} \\sum_{(i,j) \\in \\mathcal{K}_s} P(k_{i,j}).$$\n   因为$X_{\\mathbf{k}}$是指数分布，方差为$P(k)^2$，且样本是独立的，所以$\\widehat{P}_s$的方差为\n   $$\\operatorname{Var}(\\widehat{P}_s) = \\frac{\\sum_{(i,j) \\in \\mathcal{K}_s} P(k_{i,j})^2}{M K_s^2},$$\n   对应的标准差为\n   $$\\sigma_s = \\sqrt{\\frac{\\sum_{(i,j) \\in \\mathcal{K}_s} P(k_{i,j})^2}{M K_s^2}}.$$\n7. 定义逐壳归一化偏差（一个$z$-分数）：\n   $$z_s = \\frac{\\lvert \\widehat{P}_s - \\mathbb{E}[\\widehat{P}_s] \\rvert}{\\sigma_s}.$$\n8. 定义一个测试阈值$T$，如果最大球壳偏差满足$\\max_s z_s \\leq T$，则声明该测试用例通过，否则为失败。\n\n实现要求：\n- 仅使用均匀分布偏差通过Box–Muller变换生成高斯分布偏差。使用弧度制角度。\n- 实现多种均匀随机数生成器：\n  - 一个基于64位排列同余生成器（PCG64）的高质量生成器。\n  - 一个特意设计的病态生成器，它在$(0,1)$内的两个值之间交替，从而违反了均匀性。\n- 以无量纲形式实现功率谱$P(k)$。您必须至少处理以下情况：\n  - 白谱：对于$k > 0$，$P(k) = P_0$。\n  - 幂律谱：对于$k > 0$，$P(k) = P_0 \\left( \\frac{k}{k_0} \\right)^{n}$，具有指定的指数$n$和尺度$k_0$。\n\n单位：\n- 所有量均为无量纲。任何三角运算中的角度都必须是弧度。\n\n测试套件：\n您必须实现以下测试用例。每个用例指定$(\\text{rng\\_type}, N_x, N_y, M, P_0, n, k_0, T)$，其中$\\text{rng\\_type} \\in \\{\\text{\"pcg\"}, \\text{\"alt\"}\\}$选择随机数生成器。\n\n- 用例1（正常路径）：$(\\text{\"pcg\"}, 64, 64, 60, 1.0, 0, 1.0, 3.5)$，白谱。\n- 用例2（幂律谱覆盖）：$(\\text{\"pcg\"}, 32, 32, 20, 1.0, -2.0, 6.0, 3.5)$，幂律谱$P(k) = P_0 (k/k_0)^n$（$k > 0$）。\n- 用例3（病态RNG）：$(\\text{\"alt\"}, 64, 64, 60, 1.0, 0, 1.0, 3.5)$，白谱。\n- 用例4（边界：小样本量）：$(\\text{\"pcg\"}, 16, 16, 8, 1.0, 0, 1.0, 4.0)$，白谱。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），每个结果是一个布尔值，指示相应测试用例是通过（True）还是失败（False）。",
            "solution": "问题陈述经评估有效。它在科学上基于统计场论和计算天体物理学的原理，特别是关于高斯随机场的性质及其傅里叶空间表示。该问题定义明确，所有必要的定义、常数和计算步骤都得到了充分的说明。它是客观、完整且计算上可行的。\n\n解决方案涉及实现一个统计测试，以验证随机数生成器（RNG）的质量。该测试利用了模拟的二维均匀各向同性高斯随机场的统计特性。其核心原理是，如果来自RNG的底层均匀分布偏差是真正均匀的，那么从模拟中导出的物理量将在一定的统计容差内与其理论期望相匹配。RNG中均匀性的偏差将传播为模拟场中的系统性偏差，而该测试旨在检测这些偏差。\n\n对于提供的每个测试用例，解决方案按以下步骤进行：\n\n1.  **参数初始化**：对于每个测试用例，我们定义网格维度（$N_x$, $N_y$）、系综数量（$M$）、功率谱参数（$P_0$, $n$, $k_0$）、测试阈值（$T$）以及随机数生成器的类型（`rng_type`）。\n\n2.  **波数网格生成**：构建一个二维离散傅里叶网格。波数分量$k_x$和$k_y$根据离散傅里叶变换的约定定义，以零为中心。具体来说，对于大小为$N$的网格，波数是范围为 $\\{-\\lfloor N/2 \\rfloor, \\ldots, \\lfloor N/2 \\rfloor - 1\\}$ 的整数。根据这些分量，计算网格上每个点的波矢模长$k = \\sqrt{k_x^2 + k_y^2}$。\n\n3.  **功率谱模型**：实现一个函数来计算理论功率谱$P(k)$。该函数支持白谱（对于$k > 0$，$P(k) = P_0$）和幂律谱（对于$k > 0$，$P(k) = P_0 (k/k_0)^n$）。对于$k=0$模式，功率定义为$P(0) = 0$，这与标准的宇宙学假设以及问题对$k > 0$的明确关注相一致。\n\n4.  **球壳分箱与理论统计**：k空间根据波数模长的整数值$s = \\lfloor k + 0.5 \\rfloor$被划分为径向球壳。对应于直流分量（DC component）的$s=0$球壳被排除在分析之外。对于每个剩余的球壳$s$：\n    *   计算离散傅里叶模式的数量$K_s$。\n    *   计算期望的球壳平均功率$\\mathbb{E}[\\widehat{P}_s]$，即为该球壳内所有模式的$P(k)$的平均值：\n        $$ \\mathbb{E}[\\widehat{P}_s] = \\frac{1}{K_s} \\sum_{(i,j) \\in \\mathcal{K}_s} P(k_{i,j}) $$\n    *   计算估计量的理论标准差$\\sigma_s$。这依赖于一个事实，即模式的振幅平方$X_{\\mathbf{k}} = |a_{\\mathbf{k}}|^2$是一个指数分布的随机变量，其方差为$P(k)^2$。因此，球壳平均功率估计量$\\widehat{P}_s$的方差为：\n        $$ \\operatorname{Var}(\\widehat{P}_s) = \\frac{\\sum_{(i,j) \\in \\mathcal{K}_s} P(k_{i,j})^2}{M K_s^2} $$\n        标准差则为$\\sigma_s = \\sqrt{\\operatorname{Var}(\\widehat{P}_s)}$。没有模式的球壳（$K_s=0$）被排除在后续计算之外。\n\n5.  **随机场模拟**：\n    *   根据`rng_type`参数初始化一个合适的RNG。对于`\"pcg\"`，使用一个带种子的`numpy.random.PCG64`生成器以保证可复现性。对于`\"alt\"`，实现一个自定义生成器，以产生一个病态的交替值序列（例如，$0.25$和$0.75$）。\n    *   对于$M$个系综中的每一个，生成一个复傅里叶空间场$a_{\\mathbf{k}}$。这是通过首先在区间$(0,1)$内生成均匀分布偏差$u_1$和$u_2$的网格来完成的。为避免$\\log(0)$的数值问题，任何生成的$u_1$值若恰好为$0$，则替换为一个小的正数。\n    *   将Box-Muller变换应用于$(u_1, u_2)$，以产生两个独立的标准正态偏差网格，$g_1$和$g_2$。\n        $$ g_1 = \\sqrt{-2 \\ln u_1} \\cos(2 \\pi u_2) $$\n        $$ g_2 = \\sqrt{-2 \\ln u_1} \\sin(2 \\pi u_2) $$\n    *   然后通过缩放这些标准正态偏差，使其具有所需的方差$P(k)/2$，来构建复傅里叶振幅$a_{\\mathbf{k}}$的实部和虚部：\n        $$ \\operatorname{Re}(a_{\\mathbf{k}}) = g_1 \\sqrt{P(k)/2} $$\n        $$ \\operatorname{Im}(a_{\\mathbf{k}}) = g_2 \\sqrt{P(k)/2} $$\n    *   对于当前的系综$m$，计算每个模式的振幅平方$X_{\\mathbf{k},m} = |a_{\\mathbf{k},m}|^2 = (\\operatorname{Re}(a_{\\mathbf{k},m}))^2 + (\\operatorname{Im}(a_{\\mathbf{k},m}))^2$。\n\n6.  **统计分析与判定**：\n    *   将模拟的振幅平方$X_{\\mathbf{k},m}$进行聚合。具体来说，将它们在所有$M$个系综上求和，并分箱到与理论值相同的径向球壳$s$中。\n    *   计算模拟的球壳平均功率$\\widehat{P}_s$：\n        $$ \\widehat{P}_s = \\frac{1}{M K_s} \\sum_{m=1}^{M} \\sum_{(i,j) \\in \\mathcal{K}_s} X_{\\mathbf{k},m} $$\n    *   对于每个球壳，计算归一化偏差（z-分数）：\n        $$ z_s = \\frac{|\\widehat{P}_s - \\mathbb{E}[\\widehat{P}_s]|}{\\sigma_s} $$\n    *   找到所有球壳中的最大偏差$\\max_s z_s$。\n    *   如果此最大偏差小于或等于指定的阈值$T$（即，如果$\\max_s z_s \\leq T$），则声明该测试用例通过。否则，它失败。\n\n对问题陈述中指定的四个测试用例中的每一个都执行这整个过程。为了提高效率，实现是使用`numpy`完全向量化的，尽可能避免了对网格点或系综的显式循环。最终输出是一个布尔值列表，指示每个用例的通过/失败结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are permitted as per the instructions.\n\ndef solve():\n    \"\"\"\n    Main function to run the spectral uniformity tests and print the results.\n    \"\"\"\n\n    class AlternatingRNG:\n        \"\"\"\n        A pathological RNG that alternates between two fixed values.\n        This class mimics the interface of a numpy.random.Generator.\n        \"\"\"\n        def __init__(self, val1=0.25, val2=0.75):\n            self._vals = np.array([val1, val2])\n            self._state = 0\n\n        def random(self, size=None):\n            if size is None:\n                val = self._vals[self._state]\n                self._state = (self._state + 1) % 2\n                return val\n\n            n_elements = int(np.prod(size))\n            start_index = self._state\n            indices = (np.arange(n_elements) + start_index) % 2\n            output = self._vals[indices]\n            self._state = (start_index + n_elements) % 2\n            return output.reshape(size)\n\n    def power_spectrum(k, P0, n, k0):\n        \"\"\"\n        Calculates the power spectrum P(k).\n        \"\"\"\n        pk = np.zeros_like(k, dtype=float)\n        # The k=0 mode has P(0)=0. The problem states the formula is for k>0.\n        non_zero_k_mask = k > 0\n        k_pos = k[non_zero_k_mask]\n        \n        # White spectrum is a special case of power-law with n=0\n        if n == 0.0:\n            pk[non_zero_k_mask] = P0\n        else: # Power-law spectrum\n            pk[non_zero_k_mask] = P0 * (k_pos / k0)**n\n            \n        return pk\n\n    def run_test_case(rng_type, Nx, Ny, M, P0, n, k0, T):\n        \"\"\"\n        Executes a single test case for the spectral uniformity test.\n        \"\"\"\n        # 1. RNG Setup\n        if rng_type == \"pcg\":\n            # Use a fixed seed for reproducibility.\n            rng = np.random.Generator(np.random.PCG64(seed=12345))\n        elif rng_type == \"alt\":\n            rng = AlternatingRNG(val1=0.25, val2=0.75)\n        else:\n            raise ValueError(\"Unknown rng_type\")\n\n        # 2. Grid and k-space Setup\n        kx_int = np.fft.fftshift(np.fft.fftfreq(Nx) * Nx)\n        ky_int = np.fft.fftshift(np.fft.fftfreq(Ny) * Ny)\n        kx_grid, ky_grid = np.meshgrid(kx_int, ky_int)\n        \n        # In meshgrid with 'ij' indexing, first index is row (y), second is col (x)\n        # So we swap them to match physical (x, y) coordinates\n        k_grid = np.sqrt(ky_grid**2 + kx_grid**2)\n\n        # 3. Power Spectrum Model\n        pk_grid = power_spectrum(k_grid, P0, n, k0)\n\n        # 4. Shell Binning and Theoretical Statistics\n        s_grid = np.floor(k_grid + 0.5).astype(int)\n        max_s_val = np.max(s_grid)\n        \n        # Use bincount for efficient aggregation into shells\n        # We need counts up to max_s_val, so length must be max_s_val + 1\n        s_ravel = s_grid.ravel()\n        Ks_all = np.bincount(s_ravel, minlength=max_s_val + 1)\n        \n        sum_pk_s = np.bincount(s_ravel, weights=pk_grid.ravel(), minlength=max_s_val + 1)\n        sum_pk_sq_s = np.bincount(s_ravel, weights=(pk_grid**2).ravel(), minlength=max_s_val + 1)\n        \n        # Exclude shell s=0 and any shells with no modes\n        valid_shells_mask = (np.arange(max_s_val + 1) > 0)  (Ks_all > 0)\n        \n        Ks = Ks_all[valid_shells_mask]\n        \n        # Theoretical expectations\n        E_Phat_s = sum_pk_s[valid_shells_mask] / Ks\n        Var_Phat_s = sum_pk_sq_s[valid_shells_mask] / (M * Ks**2)\n        sigma_s = np.sqrt(Var_Phat_s)\n\n        # 5. Random Field Simulation (fully vectorized over ensembles)\n        sim_size = (M, Ny, Nx)\n        \n        # Generate uniform deviates for Box-Muller\n        u1 = rng.random(size=sim_size)\n        \n        # Handle u1=0 to avoid log(0) = -inf\n        u1[u1 == 0.0] = np.finfo(float).eps\n        \n        u2 = rng.random(size=sim_size)\n        \n        # Box-Muller transform\n        mag = np.sqrt(-2.0 * np.log(u1))\n        g1 = mag * np.cos(2.0 * np.pi * u2)\n        g2 = mag * np.sin(2.0 * np.pi * u2)\n        \n        # Scale to get Re(a_k) and Im(a_k)\n        # pk_grid must be broadcast to the simulation shape\n        sqrt_pk_half = np.sqrt(pk_grid / 2.0)\n        \n        re_ak = g1 * sqrt_pk_half\n        im_ak = g2 * sqrt_pk_half\n        \n        # Calculate squared amplitude X_k = |a_k|^2\n        Xk_m = re_ak**2 + im_ak**2\n        \n        # 6. Statistical Analysis and Verdict\n        # Sum over ensembles\n        Xk_total_ensembles = np.sum(Xk_m, axis=0) # Shape (Ny, Nx)\n        \n        # Bin into shells\n        total_Xk_s = np.bincount(s_ravel, weights=Xk_total_ensembles.ravel(), minlength=max_s_val + 1)\n        \n        # Calculate simulated shell-averaged power\n        Phat_s = total_Xk_s[valid_shells_mask] / (M * Ks)\n        \n        # Calculate z-scores\n        z_s = np.abs(Phat_s - E_Phat_s) / sigma_s\n        \n        # Some shells might have sigma_s = 0 if P(k)=0 for all k in that shell.\n        # This can happen if P(k)=0 for k>k_max for example.\n        # In that case, P_hat_s should also be 0, resulting in 0/0.\n        # We define 0/0 as 0 for the z-score.\n        z_s[sigma_s == 0.0] = 0.0\n        \n        max_z = np.max(z_s)\n        \n        return max_z = T\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (rng_type, Nx, Ny, M, P0, n, k0, T)\n        (\"pcg\", 64, 64, 60, 1.0, 0.0, 1.0, 3.5),\n        (\"pcg\", 32, 32, 20, 1.0, -2.0, 6.0, 3.5),\n        (\"alt\", 64, 64, 60, 1.0, 0.0, 1.0, 3.5),\n        (\"pcg\", 16, 16, 8, 1.0, 0.0, 1.0, 4.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}