{
    "hands_on_practices": [
        {
            "introduction": "Before tackling complex astrophysical systems, it is essential to build intuition with fundamental model problems. This exercise provides a hands-on derivation of the exact eigenpairs for the discrete 1D Laplacian operator, a cornerstone of numerical methods for diffusion and wave phenomena. By solving this problem analytically, you will gain a deeper understanding of how spatial discretization determines the spectral properties of a matrix and provides a basis for verifying more complex numerical codes .",
            "id": "3526049",
            "problem": "A plane-parallel, optically thick astrophysical slab of thickness $L$ supports thermal diffusion along the Cartesian coordinate $x \\in [0,L]$ with fixed temperatures at the boundaries due to highly efficient radiative coupling to the ambient medium. To analyze numerical stability and mode content in explicit time-integration schemes, consider the spatial operator underlying the one-dimensional second derivative $d^{2}/dx^{2}$ with homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(L)=0$.\n\nDiscretize the interval with $N$ interior grid points at positions $x_{j} = j h$ for $j \\in \\{1,2,\\dots,N\\}$ and $h = L/(N+1)$. Use the standard second-order central finite-difference approximation for the second derivative built from the definition of the derivative as a limit of difference quotients. Define the dimensionless discrete Laplacian matrix $\\tilde{\\mathcal{L}} \\in \\mathbb{R}^{N \\times N}$ by multiplying the usual finite-difference matrix by $h^{2}$, so that the matrix entries are\n$$\n\\tilde{\\mathcal{L}}_{j,j} = -2, \\quad \\tilde{\\mathcal{L}}_{j,j+1} = 1, \\quad \\tilde{\\mathcal{L}}_{j,j-1} = 1,\n$$\nwith all other entries equal to $0$, and with the implicit Dirichlet conditions $u_{0}=0$ and $u_{N+1}=0$.\n\nStarting from these definitions and boundary conditions, derive the eigenpairs $\\big(\\lambda_{k}, v^{(k)}\\big)$ of $\\tilde{\\mathcal{L}}$, and show that the components of each eigenvector $v^{(k)}$ are sinusoidal in the grid index, consistent with the Dirichlet boundaries. Your derivation should begin from the finite-difference recurrence implied by the eigenvalue equation and should justify the admissible discrete wavenumbers that satisfy the boundary conditions.\n\nFinally, provide the analytic expression for the $k$-th eigenvalue $\\lambda_{k}$ of $\\tilde{\\mathcal{L}}$ as a function of the integers $N \\ge 2$ and $k \\in \\{1,2,\\dots,N\\}$. Express your final answer as a single closed-form symbolic expression. No rounding is required, and no physical units are needed for the dimensionless matrix $\\tilde{\\mathcal{L}}$.",
            "solution": "The problem statement has been validated and is deemed a valid, well-posed problem in numerical analysis, specifically concerning the eigenvalue problem for the one-dimensional discrete Laplacian operator with homogeneous Dirichlet boundary conditions. The problem is self-contained, scientifically grounded, and objective. It is a standard exercise in computational mathematics.\n\nThe task is to find the eigenvalues and eigenvectors of the dimensionless discrete Laplacian matrix $\\tilde{\\mathcal{L}} \\in \\mathbb{R}^{N \\times N}$, whose entries are defined as $\\tilde{\\mathcal{L}}_{j,j} = -2$, $\\tilde{\\mathcal{L}}_{j,j+1} = 1$, and $\\tilde{\\mathcal{L}}_{j,j-1} = 1$. The eigenvalue equation is\n$$\n\\tilde{\\mathcal{L}} v = \\lambda v\n$$\nwhere $\\lambda$ is an eigenvalue and $v$ is the corresponding eigenvector with components $v_j$ for $j \\in \\{1, 2, \\dots, N\\}$.\n\nWriting this matrix equation for the $j$-th component, we obtain a linear recurrence relation:\n$$\n\\tilde{\\mathcal{L}}_{j,j-1} v_{j-1} + \\tilde{\\mathcal{L}}_{j,j} v_j + \\tilde{\\mathcal{L}}_{j,j+1} v_{j+1} = \\lambda v_j\n$$\nSubstituting the matrix elements gives:\n$$\nv_{j-1} - 2v_j + v_{j+1} = \\lambda v_j\n$$\nThis relation holds for $j = 1, 2, \\dots, N$. The problem specifies homogeneous Dirichlet boundary conditions, which in this discrete setting become $v_0 = 0$ and $v_{N+1} = 0$.\n\nWe can rearrange the recurrence relation as:\n$$\nv_{j+1} + v_{j-1} = (2 + \\lambda) v_j\n$$\nThis is a second-order homogeneous linear difference equation with constant coefficients. We seek a solution of the form $v_j = z^j$ for some complex number $z$. Substituting this ansatz into the recurrence yields the characteristic equation:\n$$\nz^{j+1} + z^{j-1} = (2 + \\lambda) z^j\n$$\nDividing by $z^{j-1}$ (for $z \\neq 0$, which must be true for a non-trivial solution), we get:\n$$\nz^2 + 1 = (2 + \\lambda) z\n$$\n$$\nz^2 - (2 + \\lambda)z + 1 = 0\n$$\nThe matrix $\\tilde{\\mathcal{L}}$ is real and symmetric, so its eigenvalues $\\lambda$ are real. Furthermore, as a discrete representation of the second derivative with Dirichlet conditions, its eigenvalues are negative. Specifically, it can be shown that $-4  \\lambda  0$. For this range of $\\lambda$, the term $2+\\lambda$ is in the interval $(-2, 2)$, and the discriminant of the quadratic equation, $\\Delta = (2+\\lambda)^2 - 4$, is negative. The roots for $z$ are therefore a pair of complex conjugates.\n\nLet us define an angle $\\theta$ such that $2 + \\lambda = 2 \\cos(\\theta)$. The characteristic equation becomes:\n$$\nz^2 - 2\\cos(\\theta) z + 1 = 0\n$$\nThe roots are given by the quadratic formula:\n$$\nz = \\frac{2\\cos(\\theta) \\pm \\sqrt{4\\cos^2(\\theta) - 4}}{2} = \\frac{2\\cos(\\theta) \\pm 2i\\sin(\\theta)}{2} = \\cos(\\theta) \\pm i\\sin(\\theta) = e^{\\pm i\\theta}\n$$\nThe general solution for $v_j$ is a linear combination of the two independent solutions corresponding to these roots:\n$$\nv_j = A e^{ij\\theta} + B e^{-ij\\theta}\n$$\nUsing Euler's formula, this can be expressed in terms of sinusoidal functions:\n$$\nv_j = C \\sin(j\\theta) + D \\cos(j\\theta)\n$$\nfor some constants $C$ and $D$.\n\nNow we apply the boundary conditions. The first condition is $v_0 = 0$:\n$$\nv_0 = C \\sin(0 \\cdot \\theta) + D \\cos(0 \\cdot \\theta) = C \\cdot 0 + D \\cdot 1 = D = 0\n$$\nThis forces the coefficient $D$ to be zero, so the solution must be of the form $v_j = C \\sin(j\\theta)$. This demonstrates that the eigenvector components are sinusoidal in the grid index $j$, as requested.\n\nThe second boundary condition is $v_{N+1} = 0$:\n$$\nv_{N+1} = C \\sin((N+1)\\theta) = 0\n$$\nFor a non-trivial eigenvector, we must have $C \\neq 0$. Therefore, the argument of the sine function must be an integer multiple of $\\pi$:\n$$\n(N+1)\\theta = k\\pi, \\quad k \\in \\mathbb{Z}\n$$\nThis quantizes the admissible values of $\\theta$:\n$$\n\\theta_k = \\frac{k\\pi}{N+1}\n$$\nThe components of the $k$-th eigenvector are thus given by:\n$$\nv_j^{(k)} = C \\sin\\left(\\frac{jk\\pi}{N+1}\\right)\n$$\nWe must determine the range of the integer mode index $k$ that produces a complete set of linearly independent eigenvectors.\n- If $k=0$, then $\\theta_0=0$ and $v_j^{(0)} = C\\sin(0) = 0$ for all $j$. This is the trivial vector, not an eigenvector.\n- The indices $j$ run from $1$ to $N$. If $k = N+1$, then $v_j^{(N+1)} = C\\sin(j\\pi) = 0$ for all integer $j$. This is also the trivial vector.\n- For $k \\in \\{1, 2, \\dots, N\\}$, we obtain $N$ non-trivial, linearly independent vectors.\n- For other integer values of $k$, the resulting vectors are not new. For example, for $k' = -k$, $v_j^{(-k)} = C \\sin(-jk\\pi/(N+1)) = -v_j^{(k)}$, which is just a scaling of the $k$-th eigenvector. Similarly, $k' = k+2(N+1)$ yields the same eigenvector since $\\sin(x+2\\pi) = \\sin(x)$.\n\nTherefore, a complete and unique set of $N$ eigenvectors is obtained by taking $k \\in \\{1, 2, \\dots, N\\}$.\n\nFinally, we derive the expression for the eigenvalues $\\lambda_k$. We established the relationship $2 + \\lambda = 2 \\cos(\\theta)$. Substituting the quantized values $\\theta_k$ gives:\n$$\n2 + \\lambda_k = 2\\cos\\left(\\frac{k\\pi}{N+1}\\right)\n$$\n$$\n\\lambda_k = 2\\cos\\left(\\frac{k\\pi}{N+1}\\right) - 2\n$$\nUsing the trigonometric identity $\\cos(2\\alpha) = 1 - 2\\sin^2(\\alpha)$, or equivalently $\\cos(x)-1 = -2\\sin^2(x/2)$, we can rewrite the expression for $\\lambda_k$:\n$$\n\\lambda_k = -2 \\left(1 - \\cos\\left(\\frac{k\\pi}{N+1}\\right)\\right) = -2 \\left(2\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)\\right)\n$$\nThis gives the final closed-form expression for the eigenvalues:\n$$\n\\lambda_k = -4\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)\n$$\nThis is the required analytic expression for the $k$-th eigenvalue of $\\tilde{\\mathcal{L}}$ as a function of $N$ and $k$, for $k \\in \\{1, 2, \\dots, N\\}$.",
            "answer": "$$\\boxed{-4\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)}$$"
        },
        {
            "introduction": "We now move from an idealized model to a more realistic astrophysical application: the oscillation modes of a star. This practice guides you through using the Finite Element Method (FEM) to discretize a Sturm–Liouville problem, which is a common mathematical structure for describing oscillations. You will assemble the stiffness and mass matrices to form a generalized eigenvalue problem, $Kx = \\lambda Bx$, and verify the crucial property of $B$-orthogonality for the computed modes .",
            "id": "3526022",
            "problem": "Consider the generalized self-adjoint Sturm–Liouville eigenvalue problem that models spherically symmetric oscillation modes of a star in one spatial dimension, posed on the interval $\\left[0,R\\right]$,\n$$\n-\\frac{d}{dr}\\left(p(r)\\frac{d\\xi}{dr}\\right) + q(r)\\,\\xi(r) \\;=\\; \\lambda\\, w(r)\\,\\xi(r),\n$$\nwhere $r$ is the radial coordinate, $\\xi(r)$ is the displacement eigenfunction, $\\lambda$ is the eigenvalue, $p(r)$ is a positive stiffness profile, $q(r)$ is a nonnegative restoring profile, and $w(r)$ is a positive weight proportional to the density profile. Impose homogeneous Dirichlet boundary conditions $\\xi(0)=0$ and $\\xi(R)=0$. Assume the following astrophysically plausible profiles:\n$$\np(r) = r^2,\\quad q(r) = \\alpha\\, r^2,\\quad w(r) = r^2\\,\\rho(r),\\quad \\rho(r) = \\rho_c\\left(1 - \\left(\\frac{r}{R}\\right)^2\\right),\n$$\nwith $\\alpha  0$ and $\\rho_c  0$. The weak form on $H_0^1(0,R)$ is: find $\\lambda \\in \\mathbb{R}$ and $\\xi \\neq 0$ such that, for all test functions $\\eta$,\n$$\n\\int_0^R p(r)\\,\\frac{d\\xi}{dr}\\,\\frac{d\\eta}{dr}\\,dr \\;+\\; \\int_0^R q(r)\\,\\xi(r)\\,\\eta(r)\\,dr \\;=\\; \\lambda \\int_0^R w(r)\\,\\xi(r)\\,\\eta(r)\\,dr.\n$$\nDiscretize this weak form using the Finite Element (FE) method with continuous piecewise-linear basis functions on a uniform mesh of $N$ elements over $\\left[0,R\\right]$, enforcing the Dirichlet boundary conditions by eliminating the boundary degrees of freedom at $r=0$ and $r=R$. Assemble the symmetric stiffness matrix $K \\in \\mathbb{R}^{n \\times n}$ and symmetric positive definite mass matrix $B \\in \\mathbb{R}^{n \\times n}$, where $n = N-1$ is the number of interior nodes. Use $3$-point Gauss–Legendre quadrature on each element to evaluate all required integrals. Solve the generalized symmetric eigenvalue problem\n$$\nK\\,x = \\lambda\\,B\\,x,\n$$\nand collect the first $m$ eigenmodes into the mode matrix $X \\in \\mathbb{R}^{n \\times m}$ whose columns are the eigenvectors corresponding to the $m$ smallest eigenvalues.\n\nNormalize the computed eigenmodes with respect to $B$ so that each column $x$ of $X$ satisfies $x^\\top B\\,x = 1$. Then numerically verify $B$-orthogonality by computing\n$$\nM \\;=\\; X^\\top B\\,X,\n$$\nand quantifying the deviation from exact orthonormality in two ways:\n- The maximum absolute off-diagonal magnitude, $s = \\max_{i \\neq j} \\left|M_{ij}\\right|$.\n- The maximum absolute diagonal deviation from unity, $t = \\max_{i} \\left|M_{ii} - 1\\right|$.\n\nYour program must implement this procedure and produce results for the following test suite, each specified by $(N, R, \\rho_c, \\alpha, m)$:\n- Case $A$: $(N, R, \\rho_c, \\alpha, m) = (32, 1, 1, 0.05, 6)$.\n- Case $B$: $(N, R, \\rho_c, \\alpha, m) = (64, 1, 1, 0.0001, 6)$.\n- Case $C$: $(N, R, \\rho_c, \\alpha, m) = (16, 1, 1000, 0.2, 4)$.\n\nFor each case, output the pair $[s, t]$ as real numbers. Your program should produce a single line of output containing the results as a comma-separated list of these pairs, enclosed in square brackets. For example, the required final output format is\n$$\n\\left[ [s_A, t_A], [s_B, t_B], [s_C, t_C] \\right],\n$$\nwhere $[s_A, t_A]$ corresponds to Case $A$, $[s_B, t_B]$ to Case $B$, and $[s_C, t_C]$ to Case $C$. No physical units are required in this problem because all quantities have been nondimensionalized.",
            "solution": "The problem of computing the spherically symmetric oscillation modes of a star is presented as a generalized self-adjoint Sturm–Liouville eigenvalue problem on the interval $\\left[0,R\\right]$. The solution requires discretizing this problem using the Finite Element (FE) method and then numerically solving the resulting matrix eigenvalue problem. The steps are as follows.\n\nFirst, we begin with the weak (or variational) formulation of the problem, which is provided. Find an eigenvalue $\\lambda \\in \\mathbb{R}$ and a non-trivial eigenfunction $\\xi \\in H_0^1(0,R)$ such that for all test functions $\\eta \\in H_0^1(0,R)$:\n$$\na(\\xi, \\eta) = \\lambda\\, b(\\xi, \\eta)\n$$\nwhere the bilinear forms $a(\\cdot, \\cdot)$ and $b(\\cdot, \\cdot)$ are defined as:\n$$\na(\\xi, \\eta) = \\int_0^R p(r)\\,\\frac{d\\xi}{dr}\\,\\frac{d\\eta}{dr}\\,dr \\;+\\; \\int_0^R q(r)\\,\\xi(r)\\,\\eta(r)\\,dr\n$$\n$$\nb(\\xi, \\eta) = \\int_0^R w(r)\\,\\xi(r)\\,\\eta(r)\\,dr\n$$\nThe space $H_0^1(0,R)$ is the Sobolev space of functions with square-integrable first derivatives that vanish at the boundaries $r=0$ and $r=R$. The coefficients are given as $p(r) = r^2$, $q(r) = \\alpha r^2$, and $w(r) = r^2\\rho_c(1-(r/R)^2)$. Since $p(r)0$ for $r \\in (0,R]$, $\\alpha0$, and $\\rho_c0$, the bilinear form $a(\\cdot,\\cdot)$ is symmetric and positive definite, defining an inner product on $H_0^1(0,R)$. Similarly, since $w(r)0$ for $r \\in (0,R)$, $b(\\cdot,\\cdot)$ is also symmetric and positive definite, defining an inner product on $L^2(0,R)$.\n\nSecond, we apply the Finite Element Method. The domain $[0,R]$ is discretized into a uniform mesh of $N$ elements of size $h = R/N$. This creates $N+1$ nodes located at $r_i = i h$ for $i=0, 1, \\dots, N$. The solution $\\xi(r)$ is approximated by a function $\\xi_h(r)$ which is a linear combination of continuous, piecewise-linear basis functions (hat functions) $\\phi_j(r)$:\n$$\n\\xi(r) \\approx \\xi_h(r) = \\sum_{j=1}^{N-1} x_j \\phi_j(r)\n$$\nThe sum runs over the $n = N-1$ interior nodes ($j=1, \\dots, N-1$) because the homogeneous Dirichlet boundary conditions $\\xi(0)=0$ and $\\xi(R)=0$ are enforced by excluding the basis functions $\\phi_0(r)$ and $\\phi_N(r)$ associated with the boundary nodes. The coefficients $x_j$ are the unknown values of the approximate solution at the interior nodes, $\\xi_h(r_j)$.\n\nThird, we employ the Galerkin method, where the test functions $\\eta$ are chosen from the same finite-dimensional space as the trial functions $\\xi_h$. We set $\\eta = \\phi_i(r)$ for each interior basis function $i = 1, \\dots, N-1$. Substituting the approximation $\\xi_h$ and test functions $\\phi_i$ into the weak form yields a system of $n$ linear equations:\n$$\n\\sum_{j=1}^{N-1} a(\\phi_j, \\phi_i) x_j = \\lambda \\sum_{j=1}^{N-1} b(\\phi_j, \\phi_i) x_j \\quad \\text{for } i=1, \\dots, N-1\n$$\nThis is a generalized matrix eigenvalue problem $Kx = \\lambda Bx$, where $x = [x_1, \\dots, x_{N-1}]^\\top$ is the vector of unknown coefficients, and $K$ and $B$ are the global stiffness and mass matrices, respectively. Their entries are given by:\n$$\nK_{ij} = a(\\phi_j, \\phi_i) = \\int_0^R \\left( p(r) \\frac{d\\phi_j}{dr} \\frac{d\\phi_i}{dr} + q(r) \\phi_j(r) \\phi_i(r) \\right) dr\n$$\n$$\nB_{ij} = b(\\phi_j, \\phi_i) = \\int_0^R w(r) \\phi_j(r) \\phi_i(r) dr\n$$\nThese matrices are symmetric, and due to the properties of the bilinear forms, $K$ is positive definite and $B$ is positive definite.\n\nFourth, the integrals for the matrix entries are computed numerically using $3$-point Gauss-Legendre quadrature on each element. The basis functions $\\phi_i$ are non-zero only over at most two adjacent elements, making the matrices $K$ and $B$ sparse (specifically, tridiagonal). For each element $[r_e, r_{e+1}]$, we compute the contributions to the global matrices by evaluating $2 \\times 2$ local matrices. An integral over an element is transformed to the reference interval $[-1,1]$ and approximated as:\n$$\n\\int_{r_e}^{r_{e+1}} f(r) dr \\approx \\frac{h}{2} \\sum_{k=1}^{3} w_k^{\\text{Gauss}} f(r(z_k))\n$$\nwhere $z_k$ and $w_k^{\\text{Gauss}}$ are the quadrature points and weights, and $r(z_k)$ is the corresponding point in the physical element.\n\nFifth, after assembling the $n \\times n$ matrices $K$ and $B$, the generalized symmetric eigenvalue problem $Kx=\\lambda Bx$ is solved for the $m$ smallest eigenvalues and corresponding eigenvectors. This is accomplished using a specialized numerical solver, such as `scipy.linalg.eigh`, which is designed for such problems and returns eigenvalues in ascending order and eigenvectors that are orthonormal with respect to the matrix $B$.\n\nFinally, the computed eigenvectors, which form the columns of the mode matrix $X \\in \\mathbb{R}^{n \\times m}$, are already normalized such that $x^\\top B x = 1$. To verify the numerical accuracy of the $B$-orthogonality, we compute the matrix $M = X^\\top B X$. For exact arithmetic and perfect eigenvectors, $M$ would be the identity matrix. The deviation from this ideal is quantified by two metrics: the maximum absolute off-diagonal magnitude, $s = \\max_{i \\neq j} |M_{ij}|$, and the maximum absolute deviation of the diagonal elements from unity, $t = \\max_i |M_{ii} - 1|$. These values provide a measure of the quality of the computed eigenmodes.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef analyze_modes(N, R, rho_c, alpha, m):\n    \"\"\"\n    Solves the Sturm-Liouville problem using FEM and verifies mode orthogonality.\n\n    Args:\n        N (int): Number of elements.\n        R (float): Radius of the star (domain endpoint).\n        rho_c (float): Central density parameter.\n        alpha (float): Parameter for the q(r) profile.\n        m (int): Number of smallest eigenmodes to compute.\n\n    Returns:\n        tuple[float, float]: A pair [s, t] where s is the max absolute off-diagonal\n                             magnitude and t is the max absolute diagonal deviation.\n    \"\"\"\n    # Number of interior nodes\n    n = N - 1\n    # Element size\n    h = R / N\n\n    # 3-point Gauss-Legendre quadrature points and weights on [-1, 1]\n    z_gauss = np.array([-np.sqrt(3/5), 0, np.sqrt(3/5)])\n    w_gauss = np.array([5/9, 8/9, 5/9])\n\n    # Initialize global stiffness (K) and mass (B) matrices\n    K = np.zeros((n, n))\n    B = np.zeros((n, n))\n\n    # Define coefficient functions based on the problem statement\n    def p(r): return r**2\n    def q(r): return alpha * r**2\n    def w(r): return r**2 * rho_c * (1 - (r/R)**2) if R  0 else 0\n\n    # Assemble matrices element by element\n    for e in range(N):\n        r_e = e * h\n        \n        # Local 2x2 matrices for the current element\n        K_loc = np.zeros((2, 2))\n        B_loc = np.zeros((2, 2))\n        \n        # Integrate over the element using Gauss quadrature\n        for k in range(len(z_gauss)):\n            s_k = z_gauss[k]\n            weight_k = w_gauss[k]\n\n            # Map from reference element [-1, 1] to physical element [r_e, r_{e+1}]\n            r_k = r_e + (1 + s_k) * h / 2\n            jac = h / 2\n            \n            p_val = p(r_k)\n            q_val = q(r_k)\n            w_val = w(r_k)\n            \n            # Hat basis functions and their derivatives on the reference element\n            psi = np.array([(1 - s_k) / 2, (1 + s_k) / 2])\n            dpsi_dr = np.array([-1 / h, 1 / h])\n\n            for i in range(2):\n                for j in range(2):\n                    # Integral for stiffness matrix K\n                    integ_K = p_val * dpsi_dr[i] * dpsi_dr[j] + q_val * psi[i] * psi[j]\n                    K_loc[i, j] += weight_k * integ_K * jac\n                    \n                    # Integral for mass matrix B\n                    integ_B = w_val * psi[i] * psi[j]\n                    B_loc[i, j] += weight_k * integ_B * jac\n    \n        # Assemble local matrices into global matrices, considering only interior nodes\n        # Global matrix indices go from 0 to n-1, corresponding to nodes 1 to N-1\n        \n        # Left node of element 'e' is node 'e'. It is interior if e  0.\n        if e  0:\n            g_idx = e - 1\n            K[g_idx, g_idx] += K_loc[0, 0]\n            B[g_idx, g_idx] += B_loc[0, 0]\n\n        # Right node of element 'e' is node 'e+1'. It is interior if e+1  N.\n        if e  N - 1:\n            g_idx = e  # Corresponds to node e+1, so matrix index is (e+1)-1\n            K[g_idx, g_idx] += K_loc[1, 1]\n            B[g_idx, g_idx] += B_loc[1, 1]\n\n        # Off-diagonal terms if both nodes of the element are interior\n        if e  0 and e  N - 1:\n            g_idx_i = e - 1\n            g_idx_j = e\n            K[g_idx_i, g_idx_j] += K_loc[0, 1]\n            K[g_idx_j, g_idx_i] += K_loc[1, 0]\n            B[g_idx_i, g_idx_j] += B_loc[0, 1]\n            B[g_idx_j, g_idx_i] += B_loc[1, 0]\n\n    # Solve the generalized symmetric eigenvalue problem K*x = lambda*B*x\n    # eigh returns eigenvalues in ascending order and B-orthonormalized eigenvectors\n    eigvals, eigvecs = eigh(K, B)\n    \n    # Collect the first m eigenmodes (eigenvectors)\n    X = eigvecs[:, :m]\n    \n    # Numerically verify B-orthogonality by computing M = X^T * B * X\n    M = X.T @ B @ X\n    \n    # Quantify the deviation from orthonormality\n    # s: maximum absolute off-diagonal magnitude\n    M_off_diag = M.copy()\n    np.fill_diagonal(M_off_diag, 0)\n    s = np.max(np.abs(M_off_diag))\n    \n    # t: maximum absolute diagonal deviation from unity\n    t = np.max(np.abs(np.diag(M) - 1))\n    \n    return s, t\n\ndef solve():\n    # Define the test cases from the problem statement\n    test_cases = [\n        # (N, R, rho_c, alpha, m)\n        (32, 1, 1, 0.05, 6),      # Case A\n        (64, 1, 1, 0.0001, 6),    # Case B\n        (16, 1, 1000, 0.2, 4),    # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        s, t = analyze_modes(*case)\n        results.append([s, t])\n\n    # Format the final output string as specified\n    formatted_results = [f\"[{s},{t}]\" for s, t in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Standard eigenvalue analysis predicts the long-term asymptotic behavior of a system, but it can be misleading for transient dynamics, especially in fluid and plasma physics. This exercise delves into the concept of non-normal operators, where short-term energy growth can occur even if all eigenvalues point to stability. By using the Singular Value Decomposition (SVD) of the system's evolution operator, you will learn to correctly identify the potential for transient amplification and contrast the roles of eigenvectors and singular vectors in stability analysis .",
            "id": "3525933",
            "problem": "Consider the linearized evolution of a two-component perturbation state vector $x(t) \\in \\mathbb{R}^2$ in a locally shearing, diffusive astrophysical flow (a minimal non-normal model of the lift-up effect relevant to differentially rotating disks). The evolution is governed by the linear ordinary differential equation $dx/dt = A x$, where the operator $A \\in \\mathbb{R}^{2 \\times 2}$ is given by\n$$\nA = \\begin{bmatrix}\n-d  S \\\\\n0  -d\n\\end{bmatrix},\n$$\nwith shear rate $S \\ge 0$ and diffusion rate $d \\ge 0$. The evolution operator at time $t \\ge 0$ is $E(t) = \\exp(t A)$. The energy norm is the Euclidean norm $\\|x\\|_2$. For any initial condition $x_0$, the energy amplification at time $t$ is defined as $G(x_0,t) = \\|E(t) x_0\\|_2^2 / \\|x_0\\|_2^2$. Singular Value Decomposition (SVD) analysis of $E(t)$ provides the optimal transient amplification and the associated optimal initial condition and response through the leading singular value and singular vectors.\n\nYour task is to write a complete, runnable program that, for several specified parameter sets $(S,d,t)$, performs the following computations and contrasts non-normal transient amplification with eigenmode predictions:\n\n- Compute the largest singular value $\\sigma_{\\max}(t)$ of $E(t)$ and the associated right and left singular vectors $v_1$ and $u_1$.\n- Compute the optimal energy amplification $G_{\\max}(t) = \\sigma_{\\max}(t)^2$.\n- Compute the spectral abscissa $\\alpha = \\max \\{\\Re(\\lambda) : \\lambda \\in \\sigma(A)\\}$, where $\\sigma(A)$ denotes the spectrum of $A$, and the eigenmode-only energy factor $E_{\\mathrm{eig}}(t) = \\exp(2 \\alpha t)$, which would be the energy factor if all modes evolved independently at the asymptotic rate $\\alpha$.\n- Define the contrast ratio $R(t) = G_{\\max}(t) / E_{\\mathrm{eig}}(t)$.\n- For the eigenvector of $A$ associated with its eigenvalue of algebraic multiplicity $2$ (which for the above $A$ can be taken as $e = [1, 0]^\\top$), compute the angles between $v_1$ and $e$, and between $u_1$ and $e$. Report both angles in radians. Angles must be computed as $\\arccos(|\\langle a,b \\rangle|)$ after normalizing $a$ and $b$, yielding values in $[0,\\pi/2]$.\n\nYou must base your algorithmic design on the following fundamental principles:\n- Linear time-invariant dynamics $dx/dt = A x$ with solution $x(t) = E(t) x_0$, where $E(t) = \\exp(t A)$.\n- Energy in the Euclidean norm evolves as $\\|x(t)\\|_2^2 = \\langle x(t), x(t) \\rangle$.\n- The optimal amplification over initial conditions in the Euclidean norm at fixed $t$ is the largest eigenvalue of $E(t)^\\top E(t)$, equivalently the square of the largest singular value of $E(t)$; the corresponding optimizers are given by the leading singular vectors.\n\nNo shortcut expressions for the matrix exponential or singular values may be used in the problem statement; your program must carry out the computations numerically using robust linear algebra routines.\n\nAll quantities are dimensionless. Any angles reported must be expressed in radians. No other physical units are required.\n\nTest Suite:\nYour program must evaluate the following parameter sets $(S,d,t)$:\n- Case $1$: $S = 10.0$, $d = 1.0$, $t = 0.5$.\n- Case $2$: $S = 10.0$, $d = 1.0$, $t = 1.0$.\n- Case $3$: $S = 0.0$, $d = 1.0$, $t = 1.0$.\n- Case $4$: $S = 5.0$, $d = 0.01$, $t = 1.0$.\n- Case $5$: $S = 10.0$, $d = 1.0$, $t = 0.0$.\n\nFor each case, your program must output a list with the following six entries, in order:\n$[\\sigma_{\\max}(t), G_{\\max}(t), E_{\\mathrm{eig}}(t), R(t), \\theta_{\\mathrm{right}}, \\theta_{\\mathrm{left}}]$, where $\\theta_{\\mathrm{right}}$ is the angle between $v_1$ and $e$, and $\\theta_{\\mathrm{left}}$ is the angle between $u_1$ and $e$, both in radians.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for the cases, as a comma-separated list enclosed in square brackets, where each element is itself the case-specific six-entry list in the order specified above. For example, the output should look like $[[\\dots],[\\dots],\\dots]$ with no additional text. All floating-point values should be reported as standard decimal numbers.",
            "solution": "We begin from the linear time-invariant system $dx/dt = A x$, where $A \\in \\mathbb{R}^{2 \\times 2}$ captures the essential coupling between perturbation components induced by shear and the isotropic decay induced by diffusion. The fundamental solution is $x(t) = E(t) x_0$ with $E(t) = \\exp(t A)$, by the standard definition of the matrix exponential for linear systems. The Euclidean norm energy at time $t$ is $\\|x(t)\\|_2^2 = \\langle x(t), x(t) \\rangle = \\|E(t) x_0\\|_2^2$. The energy amplification factor for an initial condition $x_0 \\ne 0$ is $G(x_0,t) = \\|E(t) x_0\\|_2^2 / \\|x_0\\|_2^2$.\n\nTo determine the maximal possible amplification at a fixed time $t$, we consider\n$$\nG_{\\max}(t) = \\max_{x_0 \\ne 0} \\frac{\\|E(t) x_0\\|_2^2}{\\|x_0\\|_2^2} = \\max_{y \\ne 0} \\frac{y^\\top \\left(E(t)^\\top E(t)\\right) y}{y^\\top y},\n$$\nwhich is the Rayleigh quotient of the symmetric positive semidefinite matrix $E(t)^\\top E(t)$. By the spectral theorem, the maximum equals the largest eigenvalue of $E(t)^\\top E(t)$, which is also the square of the largest singular value of $E(t)$. Therefore, if $E(t) = U \\Sigma V^\\top$ is the Singular Value Decomposition (SVD) with singular values $\\sigma_1 \\ge \\sigma_2 \\ge 0$, then $\\sigma_{\\max}(t) = \\sigma_1$ and $G_{\\max}(t) = \\sigma_1^2$. The maximizing initial condition is the first right singular vector $v_1$ (the first column of $V$), and the corresponding response direction at time $t$ is the first left singular vector $u_1$ (the first column of $U$), up to irrelevant signs. This connects the operator’s non-normality to transient growth: even when all eigenvalues of $A$ have nonpositive real parts, $\\sigma_{\\max}(t)$ can exceed $1$ for intermediate $t$ if $A$ is non-normal.\n\nTo contrast with eigenmode predictions, we compute the spectral abscissa $\\alpha = \\max \\{\\Re(\\lambda) : \\lambda \\in \\sigma(A)\\}$. If one were to model the energy via independent modal decay or growth rates, a naive energy factor would be $E_{\\mathrm{eig}}(t) = \\exp(2 \\alpha t)$, corresponding to the fastest asymptotic exponential rate. For normal operators, $G_{\\max}(t)$ matches $E_{\\mathrm{eig}}(t)$ when $E(t)$ commutes with its adjoint and the singular vectors align with eigenvectors. For non-normal operators, $G_{\\max}(t)$ can greatly exceed $E_{\\mathrm{eig}}(t)$ at finite times, which we quantify with the contrast ratio $R(t) = G_{\\max}(t)/E_{\\mathrm{eig}}(t)$.\n\nFor the specific family\n$$\nA = \\begin{bmatrix}\n-d  S \\\\\n0  -d\n\\end{bmatrix},\n$$\nwith $S \\ge 0$ and $d \\ge 0$, the eigenvalues are both $-d$, of algebraic multiplicity $2$. For $S  0$, $A$ is defective and non-normal (it has one eigenvector), while for $S = 0$, it is a scalar multiple of the identity and thus normal. An eigenvector associated with the eigenvalue $-d$ is $e = [1,0]^\\top$. Although we could write the analytic matrix exponential for this Jordan form, the problem requires numerical computation to maintain generality and robustness.\n\nAlgorithmic steps justified by the above principles:\n- Given $(S,d,t)$, form $A$ and compute $E(t) = \\exp(t A)$ using a reliable matrix exponential routine.\n- Compute the Singular Value Decomposition $E(t) = U \\Sigma V^\\top$; extract $\\sigma_{\\max}(t) = \\Sigma_{11}$, the first right singular vector $v_1$ (first column of $V$), and the first left singular vector $u_1$ (first column of $U$).\n- Compute $G_{\\max}(t) = \\sigma_{\\max}(t)^2$.\n- Compute eigenvalues $\\{\\lambda_i\\}$ of $A$, then $\\alpha = \\max_i \\Re(\\lambda_i)$ and $E_{\\mathrm{eig}}(t) = \\exp(2 \\alpha t)$.\n- Compute $R(t) = G_{\\max}(t) / E_{\\mathrm{eig}}(t)$.\n- Let $e = [1,0]^\\top$. Compute angles $\\theta_{\\mathrm{right}} = \\arccos(|\\langle v_1, e \\rangle|)$ and $\\theta_{\\mathrm{left}} = \\arccos(|\\langle u_1, e \\rangle|)$, with all vectors normalized and the absolute value ensuring angles in $[0,\\pi/2]$. Angles are reported in radians.\n\nEdge and boundary considerations:\n- For $t = 0$, $E(0) = I$, so $\\sigma_{\\max}(0) = 1$, $G_{\\max}(0) = 1$, $E_{\\mathrm{eig}}(0) = 1$, $R(0) = 1$, and singular vectors coincide with the canonical basis; the angles with $e$ are $0$.\n- For $S = 0$, $A = -d I$ is normal, $E(t) = \\exp(-d t) I$ is a scalar multiple of the identity, and any orthonormal basis is a set of singular vectors. Numerically, standard routines return canonical basis vectors; thus the angles with $e$ evaluate to $0$.\n\nImplementation details:\n- Use a robust matrix exponential and Singular Value Decomposition from scientific libraries to avoid numerical instability.\n- Normalize vectors before computing angles; clamp the inner product magnitude to $[0,1]$ before applying $\\arccos$ to avoid floating-point domain errors.\n- Process the specified test suite:\n  - Case $1$: $(S,d,t) = (10.0, 1.0, 0.5)$.\n  - Case $2$: $(S,d,t) = (10.0, 1.0, 1.0)$.\n  - Case $3$: $(S,d,t) = (0.0, 1.0, 1.0)$.\n  - Case $4$: $(S,d,t) = (5.0, 0.01, 1.0)$.\n  - Case $5$: $(S,d,t) = (10.0, 1.0, 0.0)$.\n\nThe program aggregates the six requested quantities for each case in the order $[\\sigma_{\\max}(t), G_{\\max}(t), E_{\\mathrm{eig}}(t), R(t), \\theta_{\\mathrm{right}}, \\theta_{\\mathrm{left}}]$ and prints a single line with the list of per-case lists: $[[\\dots],[\\dots],\\dots]$, containing only this line and no additional text.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm, svd, eigvals\n\ndef spectral_abscissa(A):\n    ev = eigvals(A)\n    return float(np.max(np.real(ev)))\n\ndef principal_singular_triplet(E):\n    # SVD: E = U * S * Vt, with singular values sorted descending by default\n    U, s, Vt = svd(E, full_matrices=True)\n    sigma_max = float(s[0])\n    u1 = U[:, 0]\n    v1 = Vt.T[:, 0]\n    # Normalize to ensure unit vectors (guard against numerical drift)\n    u1 = u1 / np.linalg.norm(u1)\n    v1 = v1 / np.linalg.norm(v1)\n    return sigma_max, u1, v1\n\ndef angle_between(u, v):\n    # Normalize\n    nu = np.linalg.norm(u)\n    nv = np.linalg.norm(v)\n    if nu == 0 or nv == 0:\n        return float(\"nan\")\n    uu = u / nu\n    vv = v / nv\n    # Use absolute value to map to [0, pi/2]\n    c = abs(float(np.dot(uu, vv)))\n    # Clamp due to floating point\n    c = max(0.0, min(1.0, c))\n    return float(np.arccos(c))\n\ndef analyze_case(S, d, t):\n    # Build the non-normal astrophysical operator A\n    A = np.array([[-d, S],\n                  [ 0.0, -d]], dtype=float)\n    # Evolution operator at time t\n    E = expm(t * A)\n    # Leading singular value and vectors\n    sigma_max, u1, v1 = principal_singular_triplet(E)\n    # Optimal energy amplification\n    Gmax = sigma_max ** 2\n    # Spectral abscissa and eigenmode-only energy factor\n    alpha = spectral_abscissa(A)\n    E_eig = float(np.exp(2.0 * alpha * t))\n    # Contrast ratio\n    R = Gmax / E_eig if E_eig != 0.0 else float(\"inf\")\n    # Reference eigenvector for eigenvalue -d (valid for all S, including S=0)\n    e_vec = np.array([1.0, 0.0], dtype=float)\n    # Angles in radians\n    theta_right = angle_between(v1, e_vec)\n    theta_left = angle_between(u1, e_vec)\n    return [sigma_max, Gmax, E_eig, R, theta_right, theta_left]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (S, d, t)\n    test_cases = [\n        (10.0, 1.0, 0.5),  # Case 1\n        (10.0, 1.0, 1.0),  # Case 2\n        (0.0, 1.0, 1.0),   # Case 3 (normal operator)\n        (5.0, 0.01, 1.0),  # Case 4 (weak diffusion)\n        (10.0, 1.0, 0.0),  # Case 5 (boundary t=0)\n    ]\n\n    results = []\n    for S, d, t in test_cases:\n        result = analyze_case(S, d, t)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Print as a single list of per-case lists.\n    # Ensure only the list is printed with no additional text.\n    # Convert to string in a controlled way to avoid scientific notation constraints beyond default.\n    # Default str(list) is acceptable.\n    print(str(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}