{
    "hands_on_practices": [
        {
            "introduction": "Stiff ordinary differential equations, where physical processes operate on vastly different timescales, are ubiquitous in astrophysics. This practice bridges the abstract theory of numerical stability with concrete simulation constraints by analyzing the Backward Differentiation Formula (BDF2), a workhorse for stiff problems. By deriving its absolute stability boundary and applying it to a model of thermal relaxation, you will learn how to ensure a chosen method and step size remain stable and efficient for a given physical problem .",
            "id": "3528288",
            "problem": "A fully implicit Backward Differentiation Formula (BDF) method is used in stiff initial value problems to advance the solution of the Dahlquist test equation $y'(t) = \\lambda y(t)$, where $\\lambda \\in \\mathbb{C}$ represents the spectrum of the linearized operator in a computational astrophysics model. Consider the second-order Backward Differentiation Formula (BDF2), defined by approximating the derivative at the new time level $t_{n+1}$ with a second-order backward difference and equating it to the right-hand side evaluated at $t_{n+1}$:\n$$\\frac{3 y_{n+1} - 4 y_n + y_{n-1}}{2 h} = f(t_{n+1}, y_{n+1}),$$\nwhere $h$ is the constant step size and $f(t, y) = \\lambda y$ for the test equation. The absolute stability region for a linear multistep method is the set of complex numbers $z = h \\lambda$ such that, for the recurrence induced by the test equation, all characteristic roots have modulus strictly less than $1$, with a simple root at $1$ at $z = 0$ permitted by zero-stability.\n\nTask 1: Derive the exact parametric expression of the absolute-stability boundary of BDF2 by assuming a characteristic root of unit modulus and expressing the boundary as $z(\\varphi)$, where $\\varphi \\in [0, 2\\pi)$ is in radians.\n\nTask 2: In degenerate core flash simulations, the diffusion-dominated thermal response can be locally linearized to $y'(t) = -\\Lambda y(t)$ with $\\Lambda > 0$, reflecting strong damping of temperature perturbations on the timescale $\\Lambda^{-1}$. For operational robustness, require the per-step magnitude of the numerical amplification factor of this stiff mode to be at most $r = 0.2$. Using the BDF2 recurrence on the test equation, obtain the minimum step size $h_{\\min}$ that guarantees this per-step damping requirement for real negative $z = - h \\Lambda$. Evaluate $h_{\\min}$ for $\\Lambda = 2.0 \\times 10^{3}\\ \\text{s}^{-1}$ and round your numerical answer to four significant figures. Express $h_{\\min}$ in seconds.\n\nYour final answer must include:\n- The exact analytic expression $z(\\varphi)$ for the stability boundary in terms of $\\varphi$ in radians.\n- The rounded numerical value of $h_{\\min}$ in seconds, to four significant figures.",
            "solution": "The problem has been validated and is determined to be a well-posed, scientifically grounded problem in numerical analysis as applied to computational astrophysics.\n\nThe problem is divided into two tasks. The first is to derive the absolute stability boundary for the second-order Backward Differentiation Formula (BDF2). The second is to apply a specific damping requirement to determine a minimum step size for a given stiff ordinary differential equation (ODE).\n\n**Task 1: Derivation of the Absolute-Stability Boundary**\n\nThe BDF2 method is given by the recurrence relation:\n$$ \\frac{3 y_{n+1} - 4 y_n + y_{n-1}}{2 h} = f(t_{n+1}, y_{n+1}) $$\nWe analyze this method using the Dahlquist test equation, $y'(t) = \\lambda y(t)$, where $\\lambda \\in \\mathbb{C}$. For this equation, the right-hand side is $f(t_{n+1}, y_{n+1}) = \\lambda y_{n+1}$. Substituting this into the BDF2 formula gives:\n$$ \\frac{3 y_{n+1} - 4 y_n + y_{n-1}}{2 h} = \\lambda y_{n+1} $$\nMultiplying by $2h$ and rearranging the terms to group by time steps yields:\n$$ 3 y_{n+1} - 4 y_n + y_{n-1} = 2h\\lambda y_{n+1} $$\n$$ (3 - 2h\\lambda) y_{n+1} - 4 y_n + y_{n-1} = 0 $$\nLet $z = h\\lambda$. The recurrence relation can be written as:\n$$ (3 - 2z) y_{n+1} - 4 y_n + y_{n-1} = 0 $$\nTo find the characteristic roots of this linear constant-coefficient difference equation, we substitute the ansatz $y_k = \\xi^k$:\n$$ (3 - 2z) \\xi^{n+1} - 4 \\xi^n + \\xi^{n-1} = 0 $$\nDividing by $\\xi^{n-1}$ (assuming $\\xi \\neq 0$), we obtain the characteristic polynomial for the amplification factor $\\xi$:\n$$ (3 - 2z) \\xi^2 - 4 \\xi + 1 = 0 $$\nThe absolute stability boundary is the set of $z \\in \\mathbb{C}$ for which at least one characteristic root $\\xi$ has a modulus of one. We therefore set $\\xi = \\exp(i\\varphi)$, where $\\varphi \\in [0, 2\\pi)$ is a real-valued parameter. Substituting this into the characteristic equation:\n$$ (3 - 2z) (\\exp(i\\varphi))^2 - 4 \\exp(i\\varphi) + 1 = 0 $$\n$$ (3 - 2z) \\exp(i2\\varphi) - 4 \\exp(i\\varphi) + 1 = 0 $$\nWe now solve for $z$ as a function of $\\varphi$:\n$$ 3 \\exp(i2\\varphi) - 2z \\exp(i2\\varphi) - 4 \\exp(i\\varphi) + 1 = 0 $$\n$$ 2z \\exp(i2\\varphi) = 3 \\exp(i2\\varphi) - 4 \\exp(i\\varphi) + 1 $$\n$$ z(\\varphi) = \\frac{3 \\exp(i2\\varphi) - 4 \\exp(i\\varphi) + 1}{2 \\exp(i2\\varphi)} $$\nSimplifying this expression gives the parametric form of the stability boundary:\n$$ z(\\varphi) = \\frac{3}{2} - \\frac{4 \\exp(i\\varphi)}{2 \\exp(i2\\varphi)} + \\frac{1}{2 \\exp(i2\\varphi)} $$\n$$ z(\\varphi) = \\frac{3}{2} - 2 \\exp(-i\\varphi) + \\frac{1}{2} \\exp(-i2\\varphi) $$\nThis is the required analytic expression for the absolute-stability boundary of the BDF2 method.\n\n**Task 2: Minimum Step Size for Damping Requirement**\n\nIn the second task, we consider the specific ODE $y'(t) = -\\Lambda y(t)$ with $\\Lambda > 0$. This corresponds to the Dahlquist test equation with $\\lambda = -\\Lambda$. The parameter $z$ is therefore real and negative: $z = h\\lambda = -h\\Lambda$.\n\nThe characteristic equation remains $(3 - 2z) \\xi^2 - 4 \\xi + 1 = 0$. Substituting $z = -h\\Lambda$:\n$$ (3 + 2h\\Lambda) \\xi^2 - 4 \\xi + 1 = 0 $$\nThe roots $\\xi$ of this quadratic equation are the per-step amplification factors:\n$$ \\xi = \\frac{-(-4) \\pm \\sqrt{(-4)^2 - 4(3+2h\\Lambda)(1)}}{2(3+2h\\Lambda)} = \\frac{4 \\pm \\sqrt{16 - 12 - 8h\\Lambda}}{2(3+2h\\Lambda)} = \\frac{4 \\pm \\sqrt{4 - 8h\\Lambda}}{2(3+2h\\Lambda)} $$\n$$ \\xi = \\frac{2 \\pm \\sqrt{1 - 2h\\Lambda}}{3+2h\\Lambda} $$\nThe nature of the roots depends on the sign of the discriminant, $1 - 2h\\Lambda$. Let $x = h\\Lambda$. Since $h>0$ and $\\Lambda>0$, we have $x>0$.\n\nCase 1: $1 - 2x \\ge 0$, which implies $0 < x \\le \\frac{1}{2}$.\nIn this case, the roots are real. The two roots are $\\xi_1 = \\frac{2 + \\sqrt{1 - 2x}}{3+2x}$ and $\\xi_2 = \\frac{2 - \\sqrt{1 - 2x}}{3+2x}$. The dominant root (largest in magnitude) is $\\xi_1$. Let $G(z)$ be the amplification factor, so $|G(z)| = |\\xi_1|$.\nThe requirement is that the magnitude of the amplification factor be at most $r=0.2$.\nLet's analyze the function $g(x) = \\frac{2 + \\sqrt{1 - 2x}}{3+2x}$ for $x \\in (0, \\frac{1}{2}]$.\nAt $x \\to 0$, $g(x) \\to \\frac{2+\\sqrt{1}}{3} = 1$.\nAt $x = \\frac{1}{2}$, $g(\\frac{1}{2}) = \\frac{2+0}{3+1} = \\frac{1}{2} = 0.5$.\nThe function $g(x)$ is monotonically decreasing on this interval. Since its minimum value is $0.5$, which is greater than the required maximum of $0.2$, there is no solution for $h$ in the range $0 < h\\Lambda \\le \\frac{1}{2}$ that satisfies the damping requirement.\n\nCase 2: $1 - 2x < 0$, which implies $x > \\frac{1}{2}$.\nIn this case, the roots are a complex conjugate pair:\n$$ \\xi = \\frac{2 \\pm i\\sqrt{2x - 1}}{3+2x} $$\nThe magnitude of both roots is identical:\n$$ |G(z)| = |\\xi| = \\sqrt{\\left(\\frac{2}{3+2x}\\right)^2 + \\left(\\frac{\\sqrt{2x-1}}{3+2x}\\right)^2} = \\sqrt{\\frac{4 + (2x-1)}{(3+2x)^2}} = \\sqrt{\\frac{3+2x}{(3+2x)^2}} = \\frac{1}{\\sqrt{3+2x}} $$\nThe damping requirement is $|G(z)| \\le r = 0.2$. Substituting back $x = h\\Lambda$:\n$$ \\frac{1}{\\sqrt{3+2h\\Lambda}} \\le 0.2 $$\nTo solve for $h$, we can square both sides (as both are positive):\n$$ \\frac{1}{3+2h\\Lambda} \\le (0.2)^2 = 0.04 $$\n$$ 1 \\le 0.04(3+2h\\Lambda) $$\n$$ \\frac{1}{0.04} \\le 3+2h\\Lambda $$\n$$ 25 \\le 3+2h\\Lambda $$\n$$ 22 \\le 2h\\Lambda $$\n$$ h\\Lambda \\ge 11 $$\nThis implies that the step size $h$ must satisfy $h \\ge \\frac{11}{\\Lambda}$. This condition, $h\\Lambda \\ge 11$, is consistent with the assumption for this case, $h\\Lambda > \\frac{1}{2}$.\nThe minimum step size $h_{\\min}$ that guarantees the required damping is:\n$$ h_{\\min} = \\frac{11}{\\Lambda} $$\nWe are given $\\Lambda = 2.0 \\times 10^3\\ \\text{s}^{-1}$. Substituting this value:\n$$ h_{\\min} = \\frac{11}{2.0 \\times 10^3\\ \\text{s}^{-1}} = 5.5 \\times 10^{-3}\\ \\text{s} $$\nThe problem requires the answer to be rounded to four significant figures.\n$$ h_{\\min} = 5.500 \\times 10^{-3}\\ \\text{s} $$\n\nThe final answer consists of the expression for $z(\\varphi)$ and the numerical value for $h_{\\min}$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{3}{2} - 2\\exp(-i\\varphi) + \\frac{1}{2}\\exp(-i2\\varphi) & 5.500 \\times 10^{-3}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Many problems involving long-term evolution in astrophysics, such as orbital dynamics, are fundamentally Hamiltonian systems with special conservation properties. This exercise demonstrates why the choice of integrator is critical for such problems, as generic methods can introduce unphysical long-term drifts. By comparing a standard Runge-Kutta integrator with a symplectic one (Verlet) in tracking a slowly changing system's adiabatic invariant, you will gain a deep appreciation for how geometric integrators preserve the physical fidelity of a simulation .",
            "id": "3528240",
            "problem": "Consider a one-degree-of-freedom Hamiltonian system with slowly time-varying frequency, relevant to secular dynamics in computational astrophysics where slowly varying parameters arise from gradual mass loss or tidal forcing. Let the Hamiltonian be $H(q,p,t) = \\dfrac{p^2}{2m} + \\dfrac{1}{2} m \\omega(\\epsilon t)^2 q^2$ with mass $m$, coordinate $q$, momentum $p$, and frequency $\\omega(\\epsilon t)$ that varies on the slow timescale set by $0 &lt; \\epsilon \\ll 1$. The Initial Value Problem (IVP) is defined by Hamilton's equations $ \\dot{q} = \\dfrac{\\partial H}{\\partial p}$ and $\\dot{p} = -\\dfrac{\\partial H}{\\partial q}$ with the slow time dependence entering via $H(\\epsilon t)$, and with initial conditions $q(0) = A$ and $p(0) = 0$ for a chosen amplitude $A$. The action variable is defined by $J = \\dfrac{1}{2\\pi} \\oint p \\, dq$, and, by the adiabatic theorem for slowly varying Hamiltonian systems, the theoretical secular drift in $J$ over many oscillations is predicted to vanish to leading order in $\\epsilon$.\n\nStarting from fundamental Hamiltonian mechanics and the definition of the action integral, devise a programmatic method to integrate the IVP, compute the instantaneous action $J(t)$ along the trajectory, and quantify the numerical drift $\\Delta J / J(0)$ by comparing $J(T)$ to $J(0)$ over an interval of duration $T$. The integration must be performed using two distinct numerical schemes to highlight algorithmic effects: the explicit fourth-order Runge–Kutta method and the velocity Verlet scheme. The slow frequency modulation is given by $\\omega(\\epsilon t) = \\omega_0 \\left(1 + a \\sin(\\epsilon t)\\right)$ with $0 \\le a &lt; 1$. Use units where $m$ is in $\\mathrm{kg}$, $q$ is in $\\mathrm{m}$, time $t$ is in $\\mathrm{s}$, and $\\omega$ is in $\\mathrm{rad}\\,\\mathrm{s}^{-1}$. Express the final numerical drift as a dimensionless fractional change $\\Delta J / J(0)$ rounded to $6$ decimal places. Angles for the sinusoidal modulation should be interpreted in radians.\n\nYour program must:\n- Implement the IVP $ \\dot{q} = \\dfrac{p}{m}$ and $\\dot{p} = - m \\omega(\\epsilon t)^2 q$ with the specified $\\omega(\\epsilon t)$.\n- Compute the instantaneous action $J(t)$ along the trajectory from fundamental definitions.\n- Quantify the numerical drift as $\\Delta J / J(0) = \\dfrac{\\left|J(T) - J(0)\\right|}{J(0)}$, and also report the leading-order theoretical secular drift predicted by adiabatic invariance, which is $0$.\n- Integrate over $T = 100\\,\\mathrm{s}$ using a uniform time step $\\Delta t = 0.002\\,\\mathrm{s}$. Use $m = 1\\,\\mathrm{kg}$, $\\omega_0 = 1\\,\\mathrm{rad}\\,\\mathrm{s}^{-1}$, and $A = 1\\,\\mathrm{m}$.\n\nDesign a test suite that probes adiabatic invariance and numerical effects under different slow time scales and modulation amplitudes. Use the following test suite, where each test case is a triplet $(\\epsilon, a, \\text{method})$:\n- $(0.01, 0.2, \\text{\"RK4\"})$ as a general small-$\\epsilon$ case with explicit fourth-order Runge–Kutta (happy path).\n- $(0.01, 0.2, \\text{\"Verlet\"})$ as a general small-$\\epsilon$ case with velocity Verlet (happy path).\n- $(0.20, 0.2, \\text{\"RK4\"})$ as a larger $\\epsilon$ case to expose breakdown of adiabatic invariance and non-symplectic behavior (edge case).\n- $(0.005, 0.2, \\text{\"Verlet\"})$ as a very small $\\epsilon$ case to probe near-ideal adiabatic invariance (boundary case).\n- $(0.01, 0.0, \\text{\"Verlet\"})$ as a constant-frequency boundary where theoretical adiabatic invariant reduces to exact time-independence to leading order.\n\nFor each test case, your program must output a list containing two floats: $[\\Delta J / J(0), 0.0]$, where the second entry is the theoretical secular drift at leading order. Aggregate the results of all test cases into a single line of output as a comma-separated list enclosed in square brackets with no spaces. For example, the final output must look like $[[x_1,y_1],[x_2,y_2],\\dots]$, and each $x_i$ and $y_i$ must be rounded to $6$ decimal places.\n\nNo external input is allowed; all parameters and test cases must be hard-coded exactly as specified above. The solution must be derived from the principles of Hamiltonian dynamics and the definition of the action integral, and must not rely on any pre-provided shortcut formulas or hints in the problem statement itself.",
            "solution": "The appropriate fundamental base is Hamiltonian mechanics for one-degree-of-freedom systems and the definition of the action variable in terms of phase-space integrals. For a Hamiltonian $H(q,p,t) = \\dfrac{p^2}{2m} + V(q,t)$, Hamilton's equations follow from the variational principle and are $ \\dot{q} = \\dfrac{\\partial H}{\\partial p}$ and $\\dot{p} = -\\dfrac{\\partial H}{\\partial q}$. With $V(q,t) = \\dfrac{1}{2} m \\omega(\\epsilon t)^2 q^2$, these become\n$$\n\\dot{q} = \\frac{p}{m}, \\qquad \\dot{p} = - m \\,\\omega(\\epsilon t)^2\\, q.\n$$\nThe slow time dependence is encoded by $\\omega(\\epsilon t) = \\omega_0 \\left(1 + a \\sin(\\epsilon t)\\right)$, with $\\epsilon$ being a dimensionless parameter controlling the separation of timescales. For $0 < \\epsilon \\ll 1$, the parameter varies on timescale $1/\\epsilon$ that is much larger than the natural oscillation period $2\\pi/\\omega_0$.\n\nThe action variable is defined for periodic motion by\n$$\nJ = \\frac{1}{2\\pi} \\oint p \\, dq,\n$$\nwhere the closed integral is over one cycle of the motion in the phase plane $(q,p)$. For an integrable system with one degree of freedom, the transformation to action-angle variables $(J,\\theta)$ is canonical, and the angle variable $\\theta$ advances at the instantaneous frequency. When the Hamiltonian depends slowly on time, standard averaging theory and the classical adiabatic theorem assert that the action $J$ is an adiabatic invariant: its secular change over timescales large compared to the oscillation period but small compared to $1/\\epsilon$ vanishes to leading order in $\\epsilon$, while $J$ may exhibit small oscillations. Formally, upon transforming to action-angle variables and performing a near-identity canonical averaging over $\\theta$, one finds\n$$\n\\frac{dJ}{dt} = \\mathcal{O}(\\epsilon^2)\n$$\nfor the secular part, with the leading $\\mathcal{O}(\\epsilon)$ terms having zero average over the fast phase $\\theta$. Thus the theoretical secular drift to leading order is $0$.\n\nFor the specific time-dependent harmonic oscillator, we can compute $J$ directly from the definition in terms of the geometry of the phase-space ellipse. For fixed $\\omega$, the trajectory is an ellipse:\n$$\nq(t) = A \\cos(\\omega t + \\phi), \\qquad p(t) = - m \\omega A \\sin(\\omega t + \\phi),\n$$\nwith amplitude $A$ and phase $\\phi$. The ellipse in $(q,p)$ has semi-axes $A$ and $m\\omega A$, so the area is $\\pi A \\cdot m \\omega A = \\pi m \\omega A^2$, and therefore\n$$\nJ = \\frac{1}{2\\pi} \\oint p\\,dq = \\frac{1}{2} m \\omega A^2.\n$$\nThe instantaneous energy is\n$$\nE = \\frac{p^2}{2m} + \\frac{1}{2} m \\omega^2 q^2 = \\frac{1}{2} m \\omega^2 A^2,\n$$\nso for the harmonic oscillator one has the identity\n$$\nJ = \\frac{E}{\\omega}.\n$$\nThis identity follows from fundamental definitions and does not assume time-independence; it uses the instantaneous ellipse geometry and the quadratic form of the Hamiltonian. When $\\omega$ varies slowly, $E$ changes such that $E/\\omega$ is approximately constant, consistent with adiabatic invariance.\n\nAlgorithmic design for the IVP:\n1. Define $\\omega(\\epsilon t) = \\omega_0 \\left(1 + a \\sin(\\epsilon t)\\right)$ and the force $F(q,t) = -\\dfrac{\\partial V}{\\partial q} = - m \\omega(\\epsilon t)^2 q$.\n2. Implement two integrators:\n   - Explicit fourth-order Runge–Kutta (RK4), which is non-symplectic but high-order accurate per step for smooth right-hand sides.\n   - Velocity Verlet, which is a symplectic scheme for separable $H(q,p,t)$ and remains a robust second-order method even with explicit time dependence when forces are evaluated consistently at $t$ and $t+\\Delta t$.\n3. Integrate from $t=0$ to $t=T$ with fixed time step $\\Delta t$. Use $m=1$, $\\omega_0=1$, $A=1$, $T=100$, and $\\Delta t=0.002$ in units $\\mathrm{kg}$, $\\mathrm{rad}\\,\\mathrm{s}^{-1}$, $\\mathrm{m}$, and $\\mathrm{s}$.\n4. At $t=0$, compute $J(0) = E(0)/\\omega(0)$ with $E(0) = \\dfrac{p(0)^2}{2m} + \\dfrac{1}{2} m \\omega(0)^2 q(0)^2$. During integration, at the final time $T$, compute $J(T) = E(T)/\\omega(T)$ with $E(T)$ defined analogously using the instantaneous $\\omega(T)$.\n5. Quantify the numerical drift as the dimensionless fractional change\n$$\n\\frac{\\Delta J}{J(0)} = \\frac{\\left|J(T) - J(0)\\right|}{J(0)}.\n$$\nThe theoretical secular drift at leading order is $0$ by the adiabatic theorem, so we output $[\\Delta J/J(0), 0.0]$ for each test.\n6. Repeat for the specified test suite: $(\\epsilon, a, \\text{method})$ cases with $\\epsilon$ and $a$ given and method either $\\text{\"RK4\"}$ or $\\text{\"Verlet\"}$.\n\nNumerical considerations:\n- The RK4 method will generally display secular energy and action drift over long times because it is not symplectic; the velocity Verlet method better preserves invariants in Hamiltonian systems, especially for time-independent cases ($a=0$), and exhibits smaller bounded oscillations in $J$ for small $\\epsilon$.\n- The step size $\\Delta t$ must resolve the fast oscillations, so choosing $\\Delta t \\ll 2\\pi/\\omega_0$ is essential. With $\\omega_0 = 1$, we have period $2\\pi \\approx 6.283$, and $\\Delta t = 0.002$ provides over $3000$ steps per period, ensuring high resolution.\n\nTest suite coverage:\n- $(\\epsilon,a) = (0.01,0.2)$, $\\text{\"RK4\"}$: happy path with small $\\epsilon$ and non-symplectic method.\n- $(0.01,0.2)$, $\\text{\"Verlet\"}$: happy path with symplectic-like method, expected smaller drift.\n- $(0.20,0.2)$, $\\text{\"RK4\"}$: larger $\\epsilon$, highlighting breakdown of the adiabatic approximation and more pronounced numerical drift.\n- $(0.005,0.2)$, $\\text{\"Verlet\"}$: very small $\\epsilon$, testing near-ideal adiabatic behavior.\n- $(0.01,0.0)$, $\\text{\"Verlet\"}$: constant frequency boundary; adiabatic invariant is exactly constant in the time-independent Hamiltonian, so numerical drift should be minimal.\n\nFinal output format:\nFor each test case, the program returns the two-element list $[\\Delta J/J(0), 0.0]$ rounded to $6$ decimal places. All such lists are printed in a single line as a comma-separated list enclosed in square brackets, e.g., $[[x_1,y_1],[x_2,y_2],\\dots]$, with no spaces. This representation is purely numerical and dimensionless, consistent with the problem's unit specifications.",
            "answer": "```python\nimport numpy as np\n\n# Computational setup for a slowly time-varying harmonic Hamiltonian IVP.\n# We compute the action J(t) along trajectories and quantify numerical vs theoretical drift.\n\ndef omega(t, eps, a, omega0=1.0):\n    # Frequency modulation: omega(eps * t) = omega0 * (1 + a * sin(eps * t))\n    return omega0 * (1.0 + a * np.sin(eps * t))\n\ndef dV_dq(q, t, eps, a, m=1.0, omega0=1.0):\n    # dV/dq = m * omega(t)^2 * q\n    om = omega(t, eps, a, omega0)\n    return m * (om**2) * q\n\ndef dynamics(q, p, t, eps, a, m=1.0, omega0=1.0):\n    # qdot = p/m, pdot = -dV/dq\n    qdot = p / m\n    pdot = -dV_dq(q, t, eps, a, m=m, omega0=omega0)\n    return qdot, pdot\n\ndef rk4_step(q, p, t, dt, eps, a, m=1.0, omega0=1.0):\n    # Classic explicit RK4 for Hamiltonian system with time-dependent frequency\n    k1_q, k1_p = dynamics(q, p, t, eps, a, m=m, omega0=omega0)\n    k2_q, k2_p = dynamics(q + 0.5*dt*k1_q, p + 0.5*dt*k1_p, t + 0.5*dt, eps, a, m=m, omega0=omega0)\n    k3_q, k3_p = dynamics(q + 0.5*dt*k2_q, p + 0.5*dt*k2_p, t + 0.5*dt, eps, a, m=m, omega0=omega0)\n    k4_q, k4_p = dynamics(q + dt*k3_q, p + dt*k3_p, t + dt, eps, a, m=m, omega0=omega0)\n    q_new = q + (dt/6.0) * (k1_q + 2.0*k2_q + 2.0*k3_q + k4_q)\n    p_new = p + (dt/6.0) * (k1_p + 2.0*k2_p + 2.0*k3_p + k4_p)\n    return q_new, p_new\n\ndef verlet_step(q, p, t, dt, eps, a, m=1.0, omega0=1.0):\n    # Velocity Verlet adapted to time-dependent potential:\n    # p_{n+1/2} = p_n - (dt/2) * dV/dq(q_n, t_n)\n    # q_{n+1}   = q_n + dt * p_{n+1/2} / m\n    # p_{n+1}   = p_{n+1/2} - (dt/2) * dV/dq(q_{n+1}, t_{n+1})\n    p_half = p - 0.5*dt * dV_dq(q, t, eps, a, m=m, omega0=omega0)\n    q_new = q + dt * (p_half / m)\n    p_new = p_half - 0.5*dt * dV_dq(q_new, t + dt, eps, a, m=m, omega0=omega0)\n    return q_new, p_new\n\ndef energy(q, p, t, eps, a, m=1.0, omega0=1.0):\n    om = omega(t, eps, a, omega0)\n    return 0.5*(p**2)/m + 0.5*m*(om**2)*(q**2)\n\ndef action_instantaneous(q, p, t, eps, a, m=1.0, omega0=1.0):\n    # For harmonic oscillator: J = E / omega\n    om = omega(t, eps, a, omega0)\n    E = energy(q, p, t, eps, a, m=m, omega0=omega0)\n    return E / om\n\ndef integrate_case(eps, a, method, T=100.0, dt=0.002, m=1.0, omega0=1.0, A=1.0):\n    # Initial conditions: q(0) = A (m), p(0) = 0 (kg*m/s)\n    q = A\n    p = 0.0\n    t = 0.0\n\n    J0 = action_instantaneous(q, p, t, eps, a, m=m, omega0=omega0)\n    steps = int(np.round(T / dt))\n\n    # Integrate\n    if method == \"RK4\":\n        stepper = rk4_step\n    elif method == \"Verlet\":\n        stepper = verlet_step\n    else:\n        raise ValueError(\"Unknown method: {}\".format(method))\n\n    for _ in range(steps):\n        q, p = stepper(q, p, t, dt, eps, a, m=m, omega0=omega0)\n        t += dt\n\n    Jf = action_instantaneous(q, p, t, eps, a, m=m, omega0=omega0)\n    drift_fraction = abs(Jf - J0) / J0\n    # Theoretical leading-order secular drift is 0\n    theoretical_drift = 0.0\n    return drift_fraction, theoretical_drift\n\ndef format_results(results):\n    # Format as [[x1,y1],[x2,y2],...] with each float rounded to 6 decimals and no spaces\n    def fmt(x):\n        return f\"{x:.6f}\"\n    inner = \",\".join(f\"[{fmt(r[0])},{fmt(r[1])}]\" for r in results)\n    return f\"[{inner}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.01, 0.2, \"RK4\"),\n        (0.01, 0.2, \"Verlet\"),\n        (0.20, 0.2, \"RK4\"),\n        (0.005, 0.2, \"Verlet\"),\n        (0.01, 0.0, \"Verlet\"),\n    ]\n\n    results = []\n    for eps, a, method in test_cases:\n        drift_fraction, theoretical_drift = integrate_case(eps, a, method)\n        results.append((drift_fraction, theoretical_drift))\n\n    print(format_results(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Realistic astrophysical models, like those for nuclear reaction networks, are often numerically challenging due to stiffness and variables that span many orders of magnitude. This practice introduces the essential technique of non-dimensionalization and variable scaling to improve the conditioning of the underlying mathematical problem. By implementing this scaling for a stiff network and quantifying the resulting improvements in solver performance and Jacobian conditioning, you will develop an advanced, practical skill for making complex computational problems tractable and robust .",
            "id": "3528222",
            "problem": "You are to study a minimal but stiff nuclear reaction network and quantify the numerical impact of a dimensionless scaling of variables on an initial value problem for ordinary differential equations, within the context of computational astrophysics. The goal is to derive the governing equations from first principles, implement both the original and a dimensionless-scaled formulation, integrate both with a stiff solver, and compute quantitative performance and conditioning metrics that can be automatically tested. All times must be expressed in seconds, and all requested outputs are dimensionless real numbers.\n\nStart from the fundamental base that the time evolution of species abundances in a well-mixed network is governed by the law of mass action and stoichiometric conservation. Consider a three-isotope alpha chain with the following effective reactions at constant thermodynamic state:\n- Effective triple-alpha production of carbon: $3\\, {}^{4}\\mathrm{He} \\rightarrow {}^{12}\\mathrm{C}$.\n- Alpha capture on carbon producing oxygen: ${}^{12}\\mathrm{C} + {}^{4}\\mathrm{He} \\rightarrow {}^{16}\\mathrm{O}$.\n\nLet the dynamical variables be the dimensionless abundances per baryon $Y_{\\mathrm{He}}(t)$, $Y_{\\mathrm{C}}(t)$, and $Y_{\\mathrm{O}}(t)$, which are nonnegative and satisfy nucleon conservation under the specified network. Let $k_{3\\alpha}$ denote an effective rate coefficient for the triple-alpha reaction and $k_{\\alpha C}$ denote an effective rate coefficient for the alpha capture on carbon. Treat $k_{3\\alpha}$ and $k_{\\alpha C}$ as constant parameters with dimensions chosen such that the following standard mass-action forms are valid for the production terms in units of inverse seconds: the effective triple-alpha rate term is proportional to $Y_{\\mathrm{He}}^{3}$ with proportionality constant $k_{3\\alpha}$, and the alpha-capture rate term is proportional to $Y_{\\mathrm{He}} Y_{\\mathrm{C}}$ with proportionality constant $k_{\\alpha C}$. Using only these definitions and stoichiometric conservation, derive the closed system of ordinary differential equations for the vector $\\mathbf{y}(t) = \\left[Y_{\\mathrm{He}}(t), Y_{\\mathrm{C}}(t), Y_{\\mathrm{O}}(t)\\right]^{\\top}$.\n\nDefine the unscaled initial value problem over a finite time interval $\\left[t_{0}, t_{f}\\right]$ by the derived system with initial condition $\\mathbf{y}(t_{0}) = \\mathbf{y}_{0}$. For the stiff integration, you must:\n- Use the Backward Differentiation Formula (BDF) method with an analytic Jacobian $\\mathbf{J}_{\\mathbf{y}}(t, \\mathbf{y}) = \\partial \\mathbf{f} / \\partial \\mathbf{y}$.\n- Enable dense output to evaluate the solution at arbitrary intermediate times.\n- Use a relative tolerance of $10^{-9}$ and an absolute tolerance vector of $\\left[10^{-18}, 10^{-18}, 10^{-18}\\right]$ for $\\left[Y_{\\mathrm{He}}, Y_{\\mathrm{C}}, Y_{\\mathrm{O}}\\right]$ respectively.\n\nNow construct a dimensionless scaled formulation designed to reduce dynamic range. Choose a fixed diagonal scaling matrix $\\mathbf{S} = \\mathrm{diag}\\left(s_{\\mathrm{He}}, s_{\\mathrm{C}}, s_{\\mathrm{O}}\\right)$ with $s_{\\mathrm{He}} = 1$, $s_{\\mathrm{C}} = 10^{-6}$, and $s_{\\mathrm{O}} = 10^{-12}$. Define scaled variables $\\mathbf{x}(\\tau) = \\mathbf{S}^{-1} \\mathbf{y}(t)$ and a scaled time $\\tau = t / t_{\\mathrm{ref}}$ with the time scale $t_{\\mathrm{ref}} = 1 / k_{\\alpha C}$. Use only the chain rule and the mass-action forms to derive the transformed initial value problem in the form $\\mathrm{d} \\mathbf{x} / \\mathrm{d} \\tau = \\mathbf{g}(\\mathbf{x})$ with an analytic Jacobian $\\mathbf{J}_{\\mathbf{x}}(\\mathbf{x}) = \\partial \\mathbf{g} / \\partial \\mathbf{x}$. Integrate the scaled system with the same solver settings, but in scaled time $\\tau$, and use the analytic Jacobian appropriate to the scaled system. Map any time-based diagnostics for the scaled run back to physical seconds using $t = \\tau \\, t_{\\mathrm{ref}}$ as needed.\n\nFor each run (unscaled and scaled), compute the following diagnostics:\n- Accepted step sizes: if the solver returns accepted time points $\\{t_{i}\\}_{i=0}^{N}$, compute the sequence of accepted step sizes $\\Delta t_{i} = t_{i+1} - t_{i}$ for $i = 0, \\dots, N-1$; compute the mean $\\overline{\\Delta t}$ and the median $\\widetilde{\\Delta t}$. For the scaled run, convert accepted steps in $\\tau$ to physical seconds via multiplication by $t_{\\mathrm{ref}}$. All times are in seconds.\n- Jacobian conditioning of the implicit linearization: for three physical times $t_{0}$ (initial), $t_{\\mathrm{mid}} = (t_{0} + t_{f})/2$ (midpoint), and $t_{f}$ (final), evaluate the solver’s implicit linear system matrix $\\mathbf{M} = \\mathbf{I} - h \\mathbf{J}$ using $h$ equal to the median accepted step size from that run and the appropriate Jacobian for that formulation. For the unscaled run, use $\\mathbf{J} = \\mathbf{J}_{\\mathbf{y}}$ evaluated at the state $\\mathbf{y}(t)$; for the scaled run, use $\\mathbf{J} = \\mathbf{J}_{\\mathbf{x}}$ evaluated at $\\mathbf{x}(\\tau)$ with $\\tau = t / t_{\\mathrm{ref}}$. Compute the $2$-norm condition number $\\kappa_{2}(\\mathbf{M})$ at each of the three times and then take the arithmetic mean of these three values to obtain a single conditioning metric for that run.\n\nQuantify the impact of scaling using the following three dimensionless metrics for each test case:\n- The ratio of mean conditioning metrics $\\mathcal{R}_{\\kappa} = \\left(\\text{mean } \\kappa_{2} \\text{ for unscaled}\\right) / \\left(\\text{mean } \\kappa_{2} \\text{ for scaled}\\right)$.\n- The ratio of mean accepted physical step sizes $\\mathcal{R}_{\\Delta t} = \\left(\\overline{\\Delta t}\\ \\text{for scaled}\\right) / \\left(\\overline{\\Delta t}\\ \\text{for unscaled}\\right)$.\n- The ratio of function evaluations $\\mathcal{R}_{\\mathrm{nfev}} = \\left(\\mathrm{nfev}\\ \\text{for unscaled}\\right) / \\left(\\mathrm{nfev}\\ \\text{for scaled}\\right)$ reported by the solver.\n\nTest Suite and parameter specifications:\n- Initial condition for all cases: $\\mathbf{y}_{0} = \\left[0.98,\\ 10^{-12},\\ 10^{-20}\\right]^{\\top}$ at $t_{0} = 0$ seconds.\n- Case A (stiff, fast alpha capture): $k_{3\\alpha} = 10^{-4}\\ \\mathrm{s}^{-1}$, $k_{\\alpha C} = 10^{3}\\ \\mathrm{s}^{-1}$, $t_{f} = 10^{-2}$ seconds.\n- Case B (very stiff, extremely fast alpha capture): $k_{3\\alpha} = 10^{-6}\\ \\mathrm{s}^{-1}$, $k_{\\alpha C} = 10^{5}\\ \\mathrm{s}^{-1}$, $t_{f} = 10^{-5}$ seconds.\n- Case C (mild stiffness, slower kinetics): $k_{3\\alpha} = 10^{-2}\\ \\mathrm{s}^{-1}$, $k_{\\alpha C} = 10^{2}\\ \\mathrm{s}^{-1}$, $t_{f} = 10^{-1}$ seconds.\n\nImplementation requirements:\n- Use the Backward Differentiation Formula (BDF) method with analytic Jacobians and dense output enabled.\n- Use relative tolerance $10^{-9}$ and absolute tolerance vector $\\left[10^{-18}, 10^{-18}, 10^{-18}\\right]$.\n- For each case, compute $\\mathcal{R}_{\\kappa}$, $\\mathcal{R}_{\\Delta t}$, and $\\mathcal{R}_{\\mathrm{nfev}}$ as defined above.\n\nFinal output format:\n- Your program should produce a single line of output containing a list of three lists, one per test case, in the same order as the cases above. Each inner list must contain the three floats $\\left[\\mathcal{R}_{\\kappa}, \\mathcal{R}_{\\Delta t}, \\mathcal{R}_{\\mathrm{nfev}}\\right]$ in that order, without any units. The exact format is a Python-style list literal, for example: \"[[1.23,0.45,3.67],[...],[...]]\".",
            "solution": "The user-provided problem is a well-posed and scientifically grounded exercise in computational astrophysics and numerical analysis. It requires the derivation and numerical solution of a system of ordinary differential equations (ODEs) for a simplified nuclear reaction network. The core task is to compare an unscaled formulation against a dimensionless, scaled formulation and quantify the impact on numerical performance. The problem is self-contained, with all necessary parameters, initial conditions, and metric definitions provided. It adheres to established principles of chemical kinetics (law of mass action) and numerical methods for stiff ODEs.\n\n### 1. Derivation of the Unscaled ODE System\n\nThe problem describes a three-isotope alpha chain with two effective reactions:\n1.  Triple-alpha: $3\\, {}^{4}\\mathrm{He} \\rightarrow {}^{12}\\mathrm{C}$\n2.  Alpha capture on Carbon: ${}^{12}\\mathrm{C} + {}^{4}\\mathrm{He} \\rightarrow {}^{16}\\mathrm{O}$\n\nThe state vector is $\\mathbf{y}(t) = \\left[Y_{\\mathrm{He}}(t), Y_{\\mathrm{C}}(t), Y_{\\mathrm{O}}(t)\\right]^{\\top}$, representing the dimensionless abundances. The time evolution of these abundances is governed by the law of mass action.\n\nLet $R_1$ be the rate of the triple-alpha reaction and $R_2$ be the rate of the alpha-capture reaction. The problem states that the production term for ${}^{12}\\mathrm{C}$ from the triple-alpha reaction is $k_{3\\alpha} Y_{\\mathrm{He}}^{3}$ and the production term for ${}^{16}\\mathrm{O}$ from alpha capture is $k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}$. This implies that the rates of change due to production are $\\left.dY_{\\mathrm{C}}/dt\\right|_{\\text{prod},1} = k_{3\\alpha} Y_{\\mathrm{He}}^{3}$ and $\\left.dY_{\\mathrm{O}}/dt\\right|_{\\text{prod},2} = k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}$.\n\nBased on the stoichiometry of the reactions, we can write the full system of ODEs, $\\mathrm{d}\\mathbf{y}/\\mathrm{d}t = \\mathbf{f}(\\mathbf{y})$:\n\nFor the triple-alpha reaction ($3\\mathrm{He} \\to \\mathrm{C}$), for every one ${}^{12}\\mathrm{C}$ nucleus created, three ${}^{4}\\mathrm{He}$ nuclei are destroyed. Thus:\n$\\frac{\\mathrm{d}Y_{\\mathrm{He}}}{\\mathrm{d}t} \\bigg|_{1} = -3 \\left( \\frac{\\mathrm{d}Y_{\\mathrm{C}}}{\\mathrm{d}t} \\bigg|_{\\text{prod},1} \\right) = -3 k_{3\\alpha} Y_{\\mathrm{He}}^{3}$\n$\\frac{\\mathrm{d}Y_{\\mathrm{C}}}{\\mathrm{d}t} \\bigg|_{1} = +k_{3\\alpha} Y_{\\mathrm{He}}^{3}$\n\nFor the alpha capture reaction ($\\mathrm{C} + \\mathrm{He} \\to \\mathrm{O}$), for every one ${}^{16}\\mathrm{O}$ nucleus created, one ${}^{12}\\mathrm{C}$ and one ${}^{4}\\mathrm{He}$ nucleus are destroyed. Thus:\n$\\frac{\\mathrm{d}Y_{\\mathrm{He}}}{\\mathrm{d}t} \\bigg|_{2} = - \\left( \\frac{\\mathrm{d}Y_{\\mathrm{O}}}{\\mathrm{d}t} \\bigg|_{\\text{prod},2} \\right) = -k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}$\n$\\frac{\\mathrm{d}Y_{\\mathrm{C}}}{\\mathrm{d}t} \\bigg|_{2} = - \\left( \\frac{\\mathrm{d}Y_{\\mathrm{O}}}{\\mathrm{d}t} \\bigg|_{\\text{prod},2} \\right) = -k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}$\n$\\frac{\\mathrm{d}Y_{\\mathrm{O}}}{\\mathrm{d}t} \\bigg|_{2} = +k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}$\n\nCombining these terms gives the final system:\n$$\n\\frac{\\mathrm{d}Y_{\\mathrm{He}}}{\\mathrm{d}t} = f_1(\\mathbf{y}) = -3 k_{3\\alpha} Y_{\\mathrm{He}}^{3} - k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}\n$$\n$$\n\\frac{\\mathrm{d}Y_{\\mathrm{C}}}{\\mathrm{d}t} = f_2(\\mathbf{y}) = k_{3\\alpha} Y_{\\mathrm{He}}^{3} - k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}\n$$\n$$\n\\frac{\\mathrm{d}Y_{\\mathrm{O}}}{\\mathrm{d}t} = f_3(\\mathbf{y}) = k_{\\alpha C} Y_{\\mathrm{He}} Y_{\\mathrm{C}}\n$$\n\nThe Jacobian matrix $\\mathbf{J}_{\\mathbf{y}} = \\partial \\mathbf{f} / \\partial \\mathbf{y}$ is:\n$$\n\\mathbf{J}_{\\mathbf{y}} = \n\\begin{pmatrix}\n\\frac{\\partial f_1}{\\partial Y_{\\mathrm{He}}} & \\frac{\\partial f_1}{\\partial Y_{\\mathrm{C}}} & \\frac{\\partial f_1}{\\partial Y_{\\mathrm{O}}} \\\\\n\\frac{\\partial f_2}{\\partial Y_{\\mathrm{He}}} & \\frac{\\partial f_2}{\\partial Y_{\\mathrm{C}}} & \\frac{\\partial f_2}{\\partial Y_{\\mathrm{O}}} \\\\\n\\frac{\\partial f_3}{\\partial Y_{\\mathrm{He}}} & \\frac{\\partial f_3}{\\partial Y_{\\mathrm{C}}} & \\frac{\\partial f_3}{\\partial Y_{\\mathrm{O}}}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-9 k_{3\\alpha} Y_{\\mathrm{He}}^{2} - k_{\\alpha C} Y_{\\mathrm{C}} & -k_{\\alpha C} Y_{\\mathrm{He}} & 0 \\\\\n3 k_{3\\alpha} Y_{\\mathrm{He}}^{2} - k_{\\alpha C} Y_{\\mathrm{C}} & -k_{\\alpha C} Y_{\\mathrm{He}} & 0 \\\\\nk_{\\alpha C} Y_{\\mathrm{C}} & k_{\\alpha C} Y_{\\mathrm{He}} & 0\n\\end{pmatrix}\n$$\n\n### 2. Derivation of the Scaled ODE System\n\nWe introduce scaled variables $\\mathbf{x}(\\tau) = \\mathbf{S}^{-1} \\mathbf{y}(t)$ and scaled time $\\tau = t / t_{\\mathrm{ref}}$, where $\\mathbf{S} = \\mathrm{diag}(s_{\\mathrm{He}}, s_{\\mathrm{C}}, s_{\\mathrm{O}})$ and $t_{\\mathrm{ref}} = 1 / k_{\\alpha C}$. The unscaled variables are $\\mathbf{y}(t) = \\mathbf{S} \\mathbf{x}(\\tau)$.\n\nUsing the chain rule, we transform the derivative:\n$$\n\\frac{\\mathrm{d}\\mathbf{y}}{\\mathrm{d}t} = \\frac{\\mathrm{d}(\\mathbf{S}\\mathbf{x})}{\\mathrm{d}t} = \\mathbf{S} \\frac{\\mathrm{d}\\mathbf{x}}{\\mathrm{d}\\tau} \\frac{\\mathrm{d}\\tau}{\\mathrm{d}t} = \\mathbf{S} \\frac{\\mathrm{d}\\mathbf{x}}{\\mathrm{d}\\tau} \\frac{1}{t_{\\mathrm{ref}}}\n$$\nSubstituting this into the unscaled ODE system $\\mathrm{d}\\mathbf{y}/\\mathrm{d}t = \\mathbf{f}(\\mathbf{y})$:\n$$\n\\frac{\\mathbf{S}}{t_{\\mathrm{ref}}} \\frac{\\mathrm{d}\\mathbf{x}}{\\mathrm{d}\\tau} = \\mathbf{f}(\\mathbf{S}\\mathbf{x}) \\implies \\frac{\\mathrm{d}\\mathbf{x}}{\\mathrm{d}\\tau} = t_{\\mathrm{ref}} \\mathbf{S}^{-1} \\mathbf{f}(\\mathbf{S}\\mathbf{x})\n$$\nThe right-hand side is the new function $\\mathbf{g}(\\mathbf{x})$. Let's write out its components, substituting $Y_{\\mathrm{He}} = s_{\\mathrm{He}}x_{\\mathrm{He}}$, $Y_{\\mathrm{C}} = s_{\\mathrm{C}}x_{\\mathrm{C}}$, $t_{\\mathrm{ref}} = 1/k_{\\alpha C}$, and defining the dimensionless ratio $\\gamma = k_{3\\alpha}/k_{\\alpha C}$:\n$$\ng_1(\\mathbf{x}) = \\frac{t_{\\mathrm{ref}}}{s_{\\mathrm{He}}} f_1(\\mathbf{S x}) = \\frac{1}{k_{\\alpha C}s_{\\mathrm{He}}} \\left( -3 k_{3\\alpha} (s_{\\mathrm{He}}x_{\\mathrm{He}})^3 - k_{\\alpha C} (s_{\\mathrm{He}}x_{\\mathrm{He}})(s_{\\mathrm{C}}x_{\\mathrm{C}}) \\right) = -3\\gamma \\frac{s_{\\mathrm{He}}^3}{s_{\\mathrm{He}}} x_{\\mathrm{He}}^3 - \\frac{s_{\\mathrm{He}}s_{\\mathrm{C}}}{s_{\\mathrm{He}}} x_{\\mathrm{He}}x_{\\mathrm{C}}\n$$\n$$\ng_2(\\mathbf{x}) = \\frac{t_{\\mathrm{ref}}}{s_{\\mathrm{C}}} f_2(\\mathbf{S x}) = \\frac{1}{k_{\\alpha C}s_{\\mathrm{C}}} \\left( k_{3\\alpha} (s_{\\mathrm{He}}x_{\\mathrm{He}})^3 - k_{\\alpha C} (s_{\\mathrm{He}}x_{\\mathrm{He}})(s_{\\mathrm{C}}x_{\\mathrm{C}}) \\right) = \\gamma \\frac{s_{\\mathrm{He}}^3}{s_{\\mathrm{C}}} x_{\\mathrm{He}}^3 - \\frac{s_{\\mathrm{He}}s_{\\mathrm{C}}}{s_{\\mathrm{C}}} x_{\\mathrm{He}}x_{\\mathrm{C}}\n$$\n$$\ng_3(\\mathbf{x}) = \\frac{t_{\\mathrm{ref}}}{s_{\\mathrm{O}}} f_3(\\mathbf{S x}) = \\frac{1}{k_{\\alpha C}s_{\\mathrm{O}}} \\left( k_{\\alpha C} (s_{\\mathrm{He}}x_{\\mathrm{He}})(s_{\\mathrm{C}}x_{\\mathrm{C}}) \\right) = \\frac{s_{\\mathrm{He}}s_{\\mathrm{C}}}{s_{\\mathrm{O}}} x_{\\mathrm{He}}x_{\\mathrm{C}}\n$$\nUsing the specified scaling constants $s_{\\mathrm{He}}=1$, $s_{\\mathrm{C}}=10^{-6}$, and $s_{\\mathrm{O}}=10^{-12}$:\n$$\ng_1(\\mathbf{x}) = -3 \\gamma x_{\\mathrm{He}}^{3} - s_{\\mathrm{C}} x_{\\mathrm{He}} x_{\\mathrm{C}}\n$$\n$$\ng_2(\\mathbf{x}) = \\frac{\\gamma}{s_{\\mathrm{C}}} x_{\\mathrm{He}}^{3} - x_{\\mathrm{He}} x_{\\mathrm{C}}\n$$\n$$\ng_3(\\mathbf{x}) = \\frac{s_{\\mathrm{C}}}{s_{\\mathrm{O}}} x_{\\mathrm{He}} x_{\\mathrm{C}}\n$$\n\nThe Jacobian of the scaled system, $\\mathbf{J}_{\\mathbf{x}} = \\partial \\mathbf{g} / \\partial \\mathbf{x}$, is:\n$$\n\\mathbf{J}_{\\mathbf{x}} = \n\\begin{pmatrix}\n-9 \\gamma x_{\\mathrm{He}}^{2} - s_{\\mathrm{C}} x_{\\mathrm{C}} & -s_{\\mathrm{C}} x_{\\mathrm{He}} & 0 \\\\\n\\frac{3\\gamma}{s_{\\mathrm{C}}} x_{\\mathrm{He}}^{2} - x_{\\mathrm{C}} & -x_{\\mathrm{He}} & 0 \\\\\n\\frac{s_{\\mathrm{C}}}{s_{\\mathrm{O}}} x_{\\mathrm{C}} & \\frac{s_{\\mathrm{C}}}{s_{\\mathrm{O}}} x_{\\mathrm{He}} & 0\n\\end{pmatrix}\n$$\n\n### 3. Numerical Integration and Diagnostics\n\nFor each test case, we solve both the unscaled and scaled systems using the BDF method from $t_0=0$ to $t_f$. The scaled system is solved from $\\tau_0=0$ to $\\tau_f = t_f/t_{\\mathrm{ref}}$.\nThe following diagnostics are computed for each run:\n- **Mean and Median Step Sizes**: The sequence of accepted step sizes, $\\Delta t_i$ for the unscaled run and $\\Delta \\tau_i$ for the scaled run, are collected. For comparison, the scaled steps are converted to physical time: $\\Delta t_i^{\\text{scaled}} = \\Delta \\tau_i \\cdot t_{\\mathrm{ref}}$. The means $\\overline{\\Delta t}$ and medians $\\widetilde{\\Delta t}$ are then computed.\n- **Jacobian Conditioning**: The matrix $\\mathbf{M} = \\mathbf{I} - h \\mathbf{J}$ is constructed. For the unscaled run, $\\mathbf{J}=\\mathbf{J}_{\\mathbf{y}}$ and $h=\\widetilde{\\Delta t}^{\\text{unscaled}}$. For the scaled run, $\\mathbf{J}=\\mathbf{J}_{\\mathbf{x}}$ and $h=\\widetilde{\\Delta \\tau}^{\\text{scaled}}$. The matrix is evaluated at three physical times ($t_0$, $(t_0+t_f)/2$, $t_f$) and their corresponding scaled times. The $2$-norm condition number $\\kappa_2(\\mathbf{M})$ is computed at each time, and the three values are averaged.\n- **Function Evaluations**: The total number of function evaluations, `nfev`, is obtained from the solver.\n\nFinally, three dimensionless ratios are computed to quantify the impact of scaling:\n- $\\mathcal{R}_{\\kappa} = \\left(\\text{mean } \\kappa_{2} \\text{ for unscaled}\\right) / \\left(\\text{mean } \\kappa_{2} \\text{ for scaled}\\right)$\n- $\\mathcal{R}_{\\Delta t} = \\left(\\overline{\\Delta t}\\ \\text{for scaled}\\right) / \\left(\\overline{\\Delta t}\\ \\text{for unscaled}\\right)$\n- $\\mathcal{R}_{\\mathrm{nfev}} = \\left(\\mathrm{nfev}\\ \\text{for unscaled}\\right) / \\left(\\mathrm{nfev}\\ \\text{for scaled}\\right)$\n\nThe implementation will follow these derivations and procedures.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# --- Problem Definition: Unscaled System ---\n\ndef f_unscaled(t, y, k_3a, k_ac):\n    \"\"\"RHS of the unscaled ODE system dy/dt = f(t, y).\"\"\"\n    y_he, y_c, y_o = y[0], y[1], y[2]\n    \n    # Reaction rates based on problem definition\n    term_3a = k_3a * y_he**3\n    term_ac = k_ac * y_he * y_c\n    \n    dy_he_dt = -3.0 * term_3a - term_ac\n    dy_c_dt = term_3a - term_ac\n    dy_o_dt = term_ac\n    \n    return np.array([dy_he_dt, dy_c_dt, dy_o_dt])\n\ndef jac_unscaled(t, y, k_3a, k_ac):\n    \"\"\"Jacobian of the unscaled ODE system.\"\"\"\n    y_he, y_c = y[0], y[1]\n    \n    J = np.zeros((3, 3), dtype=np.float64)\n    \n    # df1/dy\n    J[0, 0] = -9.0 * k_3a * y_he**2 - k_ac * y_c\n    J[0, 1] = -k_ac * y_he\n    \n    # df2/dy\n    J[1, 0] = 3.0 * k_3a * y_he**2 - k_ac * y_c\n    J[1, 1] = -k_ac * y_he\n    \n    # df3/dy\n    J[2, 0] = k_ac * y_c\n    J[2, 1] = k_ac * y_he\n    \n    return J\n\n# --- Problem Definition: Scaled System ---\n\n# Scaling constants are fixed for all test cases\nS_DIAG = np.array([1.0, 1e-6, 1e-12])\nS_HE, S_C, S_O = S_DIAG[0], S_DIAG[1], S_DIAG[2]\n\ndef g_scaled(tau, x, gamma):\n    \"\"\"RHS of the scaled ODE system dx/dtau = g(tau, x).\"\"\"\n    x_he, x_c = x[0], x[1]\n    \n    g1 = -3.0 * gamma * x_he**3 - S_C * x_he * x_c\n    g2 = (gamma / S_C) * x_he**3 - x_he * x_c\n    g3 = (S_C / S_O) * x_he * x_c\n    \n    return np.array([g1, g2, g3])\n\ndef jac_scaled(tau, x, gamma):\n    \"\"\"Jacobian of the scaled ODE system.\"\"\"\n    x_he, x_c = x[0], x[1]\n    \n    J = np.zeros((3, 3), dtype=np.float64)\n    \n    # dg1/dx\n    J[0, 0] = -9.0 * gamma * x_he**2 - S_C * x_c\n    J[0, 1] = -S_C * x_he\n    \n    # dg2/dx\n    J[1, 0] = (3.0 * gamma / S_C) * x_he**2 - x_c\n    J[1, 1] = -x_he\n    \n    # dg3/dx\n    J[2, 0] = (S_C / S_O) * x_c\n    J[2, 1] = (S_C / S_O) * x_he\n    \n    return J\n\ndef run_and_analyze(case_params):\n    \"\"\"\n    Runs both unscaled and scaled simulations for a given case and computes metrics.\n    \"\"\"\n    k_3a, k_ac, tf = case_params\n    y0 = np.array([0.98, 1e-12, 1e-20])\n    t0 = 0.0\n    rtol = 1e-9\n    atol = np.array([1e-18, 1e-18, 1e-18])\n    t_span = [t0, tf]\n    t_eval_points = np.array([t0, (t0 + tf) / 2.0, tf])\n\n    # --- Unscaled Run ---\n    unscaled_sol = solve_ivp(\n        fun=f_unscaled,\n        t_span=t_span,\n        y0=y0,\n        method='BDF',\n        jac=jac_unscaled,\n        dense_output=True,\n        rtol=rtol,\n        atol=atol,\n        args=(k_3a, k_ac)\n    )\n\n    unscaled_steps_t = np.diff(unscaled_sol.t)\n    mean_dt_unscaled = np.mean(unscaled_steps_t)\n    median_dt_unscaled = np.median(unscaled_steps_t)\n    nfev_unscaled = unscaled_sol.nfev\n\n    y_at_evals = unscaled_sol.sol(t_eval_points)\n    kappas_unscaled = []\n    for i in range(len(t_eval_points)):\n        y_i = y_at_evals[:, i]\n        J = jac_unscaled(t_eval_points[i], y_i, k_3a, k_ac)\n        M = np.identity(3, dtype=np.float64) - median_dt_unscaled * J\n        kappas_unscaled.append(np.linalg.cond(M, 2))\n    mean_kappa_unscaled = np.mean(kappas_unscaled)\n\n    # --- Scaled Run ---\n    t_ref = 1.0 / k_ac\n    gamma = k_3a / k_ac\n    x0 = y0 / S_DIAG\n    tau_span = [t / t_ref for t in t_span]\n    \n    scaled_sol = solve_ivp(\n        fun=g_scaled,\n        t_span=tau_span,\n        y0=x0,\n        method='BDF',\n        jac=jac_scaled,\n        dense_output=True,\n        rtol=rtol,\n        atol=atol, # Using same atol as per problem statement\n        args=(gamma,)\n    )\n\n    scaled_steps_tau = np.diff(scaled_sol.t)\n    mean_dt_scaled = np.mean(scaled_steps_tau * t_ref)\n    median_dtau_scaled = np.median(scaled_steps_tau) # Step size h is in integration variable units (tau)\n    nfev_scaled = scaled_sol.nfev\n\n    tau_eval_points = t_eval_points / t_ref\n    x_at_evals = scaled_sol.sol(tau_eval_points)\n    kappas_scaled = []\n    for i in range(len(tau_eval_points)):\n        x_i = x_at_evals[:, i]\n        J = jac_scaled(tau_eval_points[i], x_i, gamma)\n        M = np.identity(3, dtype=np.float64) - median_dtau_scaled * J\n        kappas_scaled.append(np.linalg.cond(M, 2))\n    mean_kappa_scaled = np.mean(kappas_scaled)\n\n    # --- Compute Ratios ---\n    # Handle potential division by zero if a metric is zero, though unlikely.\n    R_kappa = mean_kappa_unscaled / mean_kappa_scaled if mean_kappa_scaled != 0 else np.inf\n    R_dt = mean_dt_scaled / mean_dt_unscaled if mean_dt_unscaled != 0 else np.inf\n    R_nfev = float(nfev_unscaled) / float(nfev_scaled) if nfev_scaled != 0 else np.inf\n    \n    return [R_kappa, R_dt, R_nfev]\n\ndef solve():\n    \"\"\"Main solver function to run all test cases and print results.\"\"\"\n    # Test cases: [k_3alpha (s^-1), k_alphaC (s^-1), t_f (s)]\n    test_cases = [\n        # Case A\n        (1e-4, 1e3, 1e-2),\n        # Case B\n        (1e-6, 1e5, 1e-5),\n        # Case C\n        (1e-2, 1e2, 1e-1)\n    ]\n    \n    # Use a high precision for numpy printing to match string formatting\n    np.set_printoptions(precision=16)\n\n    all_results = []\n    for case in test_cases:\n        result_metrics = run_and_analyze(case)\n        all_results.append(result_metrics)\n    \n    # Format according to spec: \"[[1.23,0.45,3.67],[...],[...]]\"\n    # str(list) provides the required formatting.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}