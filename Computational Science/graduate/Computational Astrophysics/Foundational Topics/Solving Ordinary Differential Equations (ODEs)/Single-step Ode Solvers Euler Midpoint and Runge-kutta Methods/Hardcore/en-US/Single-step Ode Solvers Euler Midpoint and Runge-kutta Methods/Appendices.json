{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of computational science is code verification. This practice guides you through the fundamental process of empirically testing the convergence order of your ordinary differential equation solvers. By applying the forward Euler, midpoint, and RK4 methods to a simple harmonic oscillator—a system with a known analytic solution—you will use the step-doubling technique to measure the observed convergence rate $p_{\\text{obs}}$ and confirm that your implementations behave as theoretically expected . This exercise is the essential first step in building confidence in a numerical code before tackling problems where the true solution is unknown.",
            "id": "3534397",
            "problem": "You will design and implement a computational experiment to empirically verify the convergence order of single-step Ordinary Differential Equation (ODE) solvers via step-doubling, for a known analytic solution that arises in computational astrophysics. The physical model is the epicyclic approximation of small radial oscillations in a galactic disk, which reduces to a one-dimensional simple harmonic oscillator governed by Newton’s Second Law. The equation of motion is\n$$\nm \\,\\frac{d^2 y}{dt^2} \\;=\\; -\\,k\\,y,\n$$\nwhere $m$ is the mass and $k$ is the effective spring constant. Defining the epicyclic angular frequency $\\omega$ by $k = m\\,\\omega^2$, the system can be written in first-order form with state vector $u(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$ as\n$$\n\\frac{d}{dt}\\begin{bmatrix} y \\\\ v \\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix} v \\\\ -\\,\\omega^2\\,y \\end{bmatrix}.\n$$\nThe exact solution for initial conditions $y(0)=y_0$ and $v(0)=v_0$ is\n$$\ny(t) \\;=\\; y_0 \\cos(\\omega t) \\;+\\; \\frac{v_0}{\\omega}\\,\\sin(\\omega t),\\quad\nv(t) \\;=\\; -\\,y_0\\,\\omega\\,\\sin(\\omega t) \\;+\\; v_0 \\cos(\\omega t).\n$$\n\nYour task is to:\n- Implement three explicit single-step ODE solvers: the forward Euler method, the explicit midpoint method, and the classical fourth-order Runge–Kutta method, applied to the system above.\n- For each method, design a step-doubling experiment to estimate the observed global convergence rate $p_{\\mathrm{obs}}$. Let $T$ be the final time, $N$ be the number of steps with step size $h = T/N$, and $2N$ be the number of steps with step size $h/2$. If $E_h$ denotes the global error at time $T$ computed with step size $h$, and $E_{h/2}$ denotes the error with step size $h/2$, then estimate\n$$\np_{\\mathrm{obs}} \\;=\\; \\log_2\\!\\left(\\frac{E_h}{E_{h/2}}\\right).\n$$\n- To avoid unit inconsistency between position and velocity, define the error at time $t$ as the scaled Euclidean norm in state space,\n$$\n\\|e(t)\\| \\;=\\; \\sqrt{\\;\\big(y_{\\mathrm{num}}(t) - y_{\\mathrm{exact}}(t)\\big)^2 \\;+\\; \\left(\\frac{v_{\\mathrm{num}}(t) - v_{\\mathrm{exact}}(t)}{\\omega}\\right)^2\\;}.\n$$\nUse this $\\|e(T)\\|$ for $E_h$ and $E_{h/2}$.\n\nAngle units must be in radians, time in seconds, position in meters, and velocity in meters per second. The observed convergence rate $p_{\\mathrm{obs}}$ is dimensionless and should be reported as a floating-point number.\n\nImplement your program to run the following test suite and output the observed convergence rates, one for each case, in the specified final format.\n\nTest suite (each item is a tuple specifying the method, angular frequency in radians per second, final time in seconds, initial position in meters, initial velocity in meters per second, and the coarse number of steps $N$):\n- Case $1$: $\\big(\\text{Euler},\\, \\omega=1.0,\\, T=2\\pi,\\, y_0=1.0,\\, v_0=0.0,\\, N=200\\big)$.\n- Case $2$: $\\big(\\text{Midpoint},\\, \\omega=2.0,\\, T=\\pi,\\, y_0=1.0,\\, v_0=0.3,\\, N=240\\big)$.\n- Case $3$: $\\big(\\text{RK4},\\, \\omega=1.5,\\, T=\\tfrac{4\\pi}{1.5},\\, y_0=1.0,\\, v_0=0.0,\\, N=120\\big)$.\n- Case $4$ (edge case with coarse resolution for pre-asymptotic behavior): $\\big(\\text{Euler},\\, \\omega=1.0,\\, T=2\\pi,\\, y_0=1.0,\\, v_0=0.0,\\, N=20\\big)$.\n\nYour program should:\n- For each case, compute $E_h$ using $N$ steps and $E_{h/2}$ using $2N$ steps, then compute $p_{\\mathrm{obs}}$ as above.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, [`p_1`, `p_2`, `p_3`, `p_4`].\n\nYour output must be the list of four floating-point values [`p_1`, `p_2`, `p_3`, `p_4`], in the order of the cases above, printed on a single line. No additional text should be printed.",
            "solution": "The problem requires an empirical verification of the convergence order for three explicit single-step Ordinary Differential Equation (ODE) solvers: the forward Euler method, the explicit midpoint method, and the classical fourth-order Runge-Kutta (RK4) method. The test model is a one-dimensional simple harmonic oscillator, representing small radial oscillations in a galactic disk under the epicyclic approximation.\n\nThe physical system is described by the second-order ODE $m \\frac{d^2 y}{dt^2} = -k y$. By defining the angular frequency $\\omega = \\sqrt{k/m}$, this equation is rewritten as $\\frac{d^2 y}{dt^2} = -\\omega^2 y$. To solve this numerically, we convert it into a system of two first-order ODEs. Let the state vector be $u(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$, where $v(t) = \\frac{dy}{dt}$ is the velocity. The system is then given by:\n$$\n\\frac{du}{dt} = \\frac{d}{dt}\\begin{bmatrix} y \\\\ v \\end{bmatrix} = \\begin{bmatrix} v \\\\ -\\omega^2 y \\end{bmatrix} = f(u)\n$$\nThis is an autonomous system of the form $\\frac{du}{dt} = f(u)$, as the right-hand side does not explicitly depend on time $t$. We will solve this system with the initial condition $u(0) = u_0 = \\begin{bmatrix} y_0 \\\\ v_0 \\end{bmatrix}$.\n\nFor each numerical method, we generate a sequence of states $u_0, u_1, \\dots, u_N$ that approximate the true solution at discrete times $t_n = n h$, where $h = T/N$ is the step size, $N$ is the total number of steps, and $T$ is the final integration time.\n\nThe three solvers are implemented as follows for a single step from $u_n$ to $u_{n+1}$:\n\n1.  **Forward Euler Method:** This is a first-order method ($p=1$). The update rule is derived from the first-order Taylor expansion of $u(t_{n+1})$ around $t_n$:\n    $$\n    u_{n+1} = u_n + h f(u_n)\n    $$\n    For our specific system, this becomes:\n    $$\n    \\begin{bmatrix} y_{n+1} \\\\ v_{n+1} \\end{bmatrix} = \\begin{bmatrix} y_n \\\\ v_n \\end{bmatrix} + h \\begin{bmatrix} v_n \\\\ -\\omega^2 y_n \\end{bmatrix} = \\begin{bmatrix} y_n + h v_n \\\\ v_n - h \\omega^2 y_n \\end{bmatrix}\n    $$\n\n2.  **Explicit Midpoint Method:** This is a second-order method ($p=2$), a two-stage Runge-Kutta method. It first estimates the state at the midpoint of the interval, $t_n + h/2$, using a forward Euler step of size $h/2$, and then uses the slope at this midpoint to take the full step from $t_n$ to $t_{n+1}$:\n    $$\n    k_1 = f(u_n)\n    $$\n    $$\n    k_2 = f(u_n + \\frac{h}{2} k_1)\n    $$\n    $$\n    u_{n+1} = u_n + h k_2\n    $$\n\n3.  **Classical Fourth-Order Runge-Kutta (RK4) Method:** This is a fourth-order method ($p=4$) and a widely used four-stage explicit Runge-Kutta method. It uses a weighted average of four slope estimates within the interval $[t_n, t_{n+1}]$:\n    $$\n    k_1 = f(u_n)\n    $$\n    $$\n    k_2 = f(u_n + \\frac{h}{2} k_1)\n    $$\n    $$\n    k_3 = f(u_n + \\frac{h}{2} k_2)\n    $$\n    $$\n    k_4 = f(u_n + h k_3)\n    $$\n    $$\n    u_{n+1} = u_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n    $$\n\nTo empirically determine the order of convergence $p$, we use the method of step-doubling. The global error $E$ at a fixed final time $T$ for a method of order $p$ is expected to be proportional to the step size raised to the power of $p$, i.e., $E \\approx C h^p$ for sufficiently small $h$. We compute the numerical solution and its error twice: once with a coarse step size $h = T/N$ to get error $E_h$, and once with a fine step size $h/2 = T/(2N)$ to get error $E_{h/2}$. The ratio of these errors is:\n$$\n\\frac{E_h}{E_{h/2}} \\approx \\frac{C h^p}{C (h/2)^p} = 2^p\n$$\nSolving for $p$, we obtain the observed order of convergence:\n$$\np_{\\mathrm{obs}} = \\log_2\\left(\\frac{E_h}{E_{h/2}}\\right)\n$$\nThe error at the final time $T$ is computed by comparing the numerical solution $u_{\\mathrm{num}}(T) = \\begin{bmatrix} y_{\\mathrm{num}}(T), v_{\\mathrm{num}}(T) \\end{bmatrix}^T$ to the exact analytical solution:\n$$\ny_{\\mathrm{exact}}(t) = y_0 \\cos(\\omega t) + \\frac{v_0}{\\omega}\\sin(\\omega t)\n$$\n$$\nv_{\\mathrm{exact}}(t) = -y_0\\,\\omega\\,\\sin(\\omega t) + v_0 \\cos(\\omega t)\n$$\nThe problem specifies a scaled Euclidean norm for the error vector $e(T) = u_{\\mathrm{num}}(T) - u_{\\mathrm{exact}}(T)$:\n$$\nE = \\|e(T)\\| = \\sqrt{\\big(y_{\\mathrm{num}}(T) - y_{\\mathrm{exact}}(T)\\big)^2 + \\left(\\frac{v_{\\mathrm{num}}(T) - v_{\\mathrm{exact}}(T)}{\\omega}\\right)^2}\n$$\nThis scaling makes the two components of the error (position and velocity) dimensionally consistent, as both terms inside the square root have units of length.\n\nThe overall algorithm for each test case is:\n1.  Set the parameters: method, $\\omega$, $T$, $u_0$, and the coarse number of steps $N$.\n2.  Integrate from $t=0$ to $t=T$ using the specified method with $N$ steps to obtain $u_{\\mathrm{num}, h}(T)$.\n3.  Integrate from $t=0$ to $t=T$ using the same method with $2N$ steps to obtain $u_{\\mathrm{num}, h/2}(T)$.\n4.  Calculate the exact solution $u_{\\mathrm{exact}}(T)$.\n5.  Compute the errors $E_h$ and $E_{h/2}$ using the provided error norm.\n6.  Calculate the observed convergence rate $p_{\\mathrm{obs}} = \\log_2(E_h/E_{h/2})$.\n\nThis procedure is repeated for all four test cases provided in the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the observed convergence order for Euler, Midpoint, and RK4 methods\n    applied to the simple harmonic oscillator equation.\n    \"\"\"\n\n    # --- Define ODE system and its exact solution ---\n\n    def f_sho(t, u, omega_sq):\n        \"\"\"RHS of the simple harmonic oscillator ODE system: u' = f(t, u).\"\"\"\n        y, v = u\n        return np.array([v, -omega_sq * y])\n\n    def exact_solution(t, u0, omega):\n        \"\"\"Exact solution of the simple harmonic oscillator.\"\"\"\n        y0, v0 = u0\n        y_t = y0 * np.cos(omega * t) + (v0 / omega) * np.sin(omega * t)\n        v_t = -y0 * omega * np.sin(omega * t) + v0 * np.cos(omega * t)\n        return np.array([y_t, v_t])\n\n    # --- Define single-step ODE solvers ---\n\n    def euler_step(f, t, u, h, omega_sq):\n        \"\"\"Performs a single forward Euler step.\"\"\"\n        return u + h * f(t, u, omega_sq)\n\n    def midpoint_step(f, t, u, h, omega_sq):\n        \"\"\"Performs a single explicit midpoint method step.\"\"\"\n        k1 = f(t, u, omega_sq)\n        k2 = f(t + h / 2.0, u + (h / 2.0) * k1, omega_sq)\n        return u + h * k2\n\n    def rk4_step(f, t, u, h, omega_sq):\n        \"\"\"Performs a single classical 4th-order Runge-Kutta step.\"\"\"\n        k1 = f(t, u, omega_sq)\n        k2 = f(t + h / 2.0, u + (h / 2.0) * k1, omega_sq)\n        k3 = f(t + h / 2.0, u + (h / 2.0) * k2, omega_sq)\n        k4 = f(t + h, u + h * k3, omega_sq)\n        return u + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    # --- Define the integration driver ---\n\n    def integrate(step_func, u0, omega, T, N):\n        \"\"\"Integrates the ODE from t=0 to T using N steps.\"\"\"\n        h = T / N\n        u = u0.copy()\n        omega_sq = omega**2\n        for i in range(N):\n            t = i * h\n            u = step_func(f_sho, t, u, h, omega_sq)\n        return u\n\n    # --- Define the error calculation function ---\n\n    def calculate_error(u_num, u_exact, omega):\n        \"\"\"Calculates the error using the specified scaled norm.\"\"\"\n        err_y = u_num[0] - u_exact[0]\n        err_v = u_num[1] - u_exact[1]\n        norm_sq = err_y**2 + (err_v / omega)**2\n        return np.sqrt(norm_sq)\n\n    # --- Test suite definition ---\n\n    test_cases = [\n        # (Method Name, omega, T, y0, v0, N_coarse)\n        ('Euler', 1.0, 2.0 * np.pi, 1.0, 0.0, 200),\n        ('Midpoint', 2.0, np.pi, 1.0, 0.3, 240),\n        ('RK4', 1.5, 4.0 * np.pi / 1.5, 1.0, 0.0, 120),\n        ('Euler', 1.0, 2.0 * np.pi, 1.0, 0.0, 20),\n    ]\n\n    solver_map = {\n        'Euler': euler_step,\n        'Midpoint': midpoint_step,\n        'RK4': rk4_step,\n    }\n\n    results = []\n    for case in test_cases:\n        method_name, omega, T, y0, v0, N_coarse = case\n\n        u0 = np.array([y0, v0])\n        step_func = solver_map[method_name]\n\n        # Integrate with coarse step size h = T / N_coarse\n        u_num_h = integrate(step_func, u0, omega, T, N_coarse)\n\n        # Integrate with fine step size h/2 = T / (2*N_coarse)\n        u_num_h2 = integrate(step_func, u0, omega, T, 2 * N_coarse)\n\n        # Calculate exact solution at T\n        u_exact_T = exact_solution(T, u0, omega)\n\n        # Calculate errors for both resolutions\n        E_h = calculate_error(u_num_h, u_exact_T, omega)\n        E_h2 = calculate_error(u_num_h2, u_exact_T, omega)\n\n        # Estimate the observed convergence order\n        # Handle the case where E_h2 is zero to avoid division by zero\n        if E_h2 == 0.0:\n            p_obs = np.inf if E_h > 0.0 else 0.0\n        else:\n            p_obs = np.log2(E_h / E_h2)\n        \n        results.append(p_obs)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having verified the convergence orders of our solvers, we now apply them to a more realistic astrophysical scenario: the nonlinear Kepler problem. In orbital mechanics, the long-term conservation of physical quantities like angular momentum is often a more critical metric of a solver's quality than its point-wise accuracy over short times. This exercise directly compares the performance of Euler, midpoint, and classical RK4 methods by measuring their respective drifts in angular momentum over many orbits . It provides a clear, practical demonstration of why higher-order methods are indispensable for simulations that require long-term fidelity.",
            "id": "3534434",
            "problem": "Consider the planar two-body (Kepler) problem for a unit point mass orbiting a fixed central mass under Newtonian gravity. Use nondimensional units in which the gravitational constant times the central mass is $G M = 1$. The state is the pair $\\left(\\mathbf{r}(t), \\mathbf{v}(t)\\right) \\in \\mathbb{R}^2 \\times \\mathbb{R}^2$ satisfying the first-order ordinary differential equation (ODE) system\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\qquad \\frac{d\\mathbf{v}}{dt} = - \\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3}.\n$$\nThe specific angular momentum (per unit mass) about the out-of-plane axis is\n$$\n\\ell(t) = \\left(\\mathbf{r}(t) \\times \\mathbf{v}(t)\\right)_z = x(t)\\,v_y(t) - y(t)\\,v_x(t).\n$$\nBy Newton's second law and the central nature of the gravitational force, the torque is zero and therefore $\\ell(t)$ is conserved exactly in the continuous dynamics. In finite-precision computation and with discrete-time single-step ODE integrators, $\\ell(t)$ can drift.\n\nYour task is to construct a numerical experiment that compares the drift in $\\ell(t)$ when integrating a Keplerian ellipse using three single-step methods at the same fixed step size $h$ for each test: the explicit Euler method, the explicit midpoint method (the second-order Runge-Kutta method), and the classical fourth-order Runge-Kutta method (abbreviated as Runge-Kutta of order $4$, or RK4). The experiment must be implemented as a complete, runnable program.\n\nUse the following setup for the initial conditions. Fix the semi-major axis to $a = 1$ and place the particle at pericenter on the $x$-axis,\n$$\n\\mathbf{r}(0) = \\big(a(1-e),\\, 0\\big),\n$$\nwith initial velocity tangent to the orbit in the positive $y$-direction,\n$$\n\\mathbf{v}(0) = \\left(0,\\, \\sqrt{\\frac{1+e}{a(1-e)}}\\right).\n$$\nIn the chosen nondimensional units with $G M = 1$ and $a = 1$, the orbital period is $T = 2\\pi$. For a given number of orbits $K \\in \\mathbb{N}$ and a fixed step size $h > 0$, integrate for $N = \\left\\lfloor \\frac{K T}{h} \\right\\rfloor$ steps (do not take a partial step to exactly hit $K T$; use exactly $N$ steps of size $h$). For each integrator, record the maximum relative angular momentum drift over the integration,\n$$\n\\varepsilon_{\\max} \\equiv \\max_{0 \\leq n \\leq N} \\frac{\\left|\\ell_n - \\ell_0\\right|}{\\left|\\ell_0\\right|},\n$$\nwhere $\\ell_n$ is the discrete angular momentum computed from the numerical state after $n$ steps, and $\\ell_0$ is computed from the initial state.\n\nImplement the three integrators as single-step methods for the first-order system $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ with $\\mathbf{y} = \\left(x, y, v_x, v_y\\right)$ and $\\mathbf{f}(\\mathbf{y}) = \\left(v_x, v_y, -x/r^3, -y/r^3\\right)$ where $r = \\sqrt{x^2 + y^2}$. Use the same fixed step size $h$ for all three integrators within each test case.\n\nAll quantities are nondimensional; no physical units are required. All angles, where applicable, are in radians.\n\nTest suite. Run the experiment for the following four test cases, each specified by the eccentricity $e$, the step size $h$, and the number of orbits $K$:\n\n- Case $1$: $e = 0$, $h = 0.01$, $K = 1$.\n- Case $2$: $e = 0.6$, $h = 0.01$, $K = 1$.\n- Case $3$: $e = 0.6$, $h = 0.03$, $K = 5$.\n- Case $4$: $e = 0.9$, $h = 0.005$, $K = 1$.\n\nFor each case, compute and return a list of three floating-point numbers $[\\varepsilon_{\\max}^{\\text{Euler}}, \\varepsilon_{\\max}^{\\text{Midpoint}}, \\varepsilon_{\\max}^{\\text{RK4}}]$.\n\nFinal output format. Your program should produce a single line of output containing the results for all four cases as a comma-separated list of the four per-case lists, enclosed in square brackets, in the same order as the cases above. That is, the printed string must have the form\n`[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]]`\nwith each `a_j`, `b_j`, `c_j` a floating-point number. No additional text or lines should be printed.",
            "solution": "The user-provided problem has been validated and is determined to be a well-posed, scientifically grounded, and complete task. The objective is to study the numerical conservation of specific angular momentum when integrating the Kepler problem with three distinct single-step ordinary differential equation (ODE) solvers.\n\nThe problem is defined by the equations of motion for a point mass in a central gravitational field in two dimensions. In nondimensional units where the gravitational parameter $G M = 1$, the state of the system is given by the position vector $\\mathbf{r}(t) = (x(t), y(t))$ and the velocity vector $\\mathbf{v}(t) = (v_x(t), v_y(t))$. The dynamics are governed by the first-order ODE system:\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\qquad \\frac{d\\mathbf{v}}{dt} = - \\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3}\n$$\nTo facilitate numerical integration, we represent the state as a single vector in $\\mathbb{R}^4$, $\\mathbf{y}(t) = (x(t), y(t), v_x(t), v_y(t))^T$. The system of ODEs can then be written in the compact form $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$, where the function $\\mathbf{f}: \\mathbb{R}^4 \\to \\mathbb{R}^4$ is defined as:\n$$\n\\mathbf{f}(\\mathbf{y}) = \\begin{pmatrix} v_x \\\\ v_y \\\\ -x / (\\sqrt{x^2+y^2})^3 \\\\ -y / (\\sqrt{x^2+y^2})^3 \\end{pmatrix}\n$$\nThe specific angular momentum, $\\ell(t)$, is a scalar quantity defined by the out-of-plane component of the cross product of position and velocity:\n$$\n\\ell(t) = (\\mathbf{r}(t) \\times \\mathbf{v}(t))_z = x(t)\\,v_y(t) - y(t)\\,v_x(t)\n$$\nIn the exact analytical solution, the central nature of the gravitational force guarantees that torque is zero, and thus $\\ell(t)$ is a conserved quantity. However, numerical integration methods introduce discretization errors, which can lead to a drift in this value over time.\n\nThe numerical experiment is set up for an elliptical orbit with semi-major axis $a=1$. The initial position is at pericenter on the positive $x$-axis, $\\mathbf{r}(0) = (1-e, 0)$, where $e$ is the eccentricity. The initial velocity is perpendicular to the position vector, $\\mathbf{v}(0) = \\left(0, \\sqrt{\\frac{1+e}{1-e}}\\right)$. The initial specific angular momentum, $\\ell_0$, is therefore:\n$$\n\\ell_0 = x(0) v_y(0) - y(0) v_x(0) = (1-e) \\sqrt{\\frac{1+e}{1-e}} - 0 = \\sqrt{(1-e)(1+e)} = \\sqrt{1-e^2}\n$$\nSince the provided test cases use $e  1$, $\\ell_0$ is non-zero. The orbital period for $a=1$ and $GM=1$ is $T=2\\pi$. The integration is performed over $K$ orbits for a total number of steps $N = \\lfloor 2\\pi K / h \\rfloor$, using a fixed step size $h$.\n\nWe will compare three explicit single-step methods. Let $\\mathbf{y}_n$ be the numerical approximation to $\\mathbf{y}(t_n)$ at time $t_n = n h$. The next state $\\mathbf{y}_{n+1}$ is computed as follows:\n\n1.  **Explicit Euler Method (First-Order)**: This method approximates the solution by taking a single step along the tangent at the beginning of the interval.\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\mathbf{f}(\\mathbf{y}_n)\n    $$\n\n2.  **Explicit Midpoint Method (Second-Order Runge-Kutta, RK2)**: This method improves accuracy by using a slope evaluated at the midpoint of the interval.\n    $$\n    \\begin{aligned}\n    \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) \\\\\n    \\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1\\right) \\\\\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\mathbf{k}_2\n    \\end{aligned}\n    $$\n\n3.  **Classical Runge-Kutta Method (Fourth-Order, RK4)**: This is a widely used method that achieves higher accuracy by using a weighted average of four slope estimates within the interval.\n    $$\n    \\begin{aligned}\n    \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) \\\\\n    \\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1\\right) \\\\\n    \\mathbf{k}_3 = \\mathbf{f}\\left(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_2\\right) \\\\\n    \\mathbf{k}_4 = \\mathbf{f}\\left(\\mathbf{y}_n + h \\mathbf{k}_3\\right) \\\\\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n    \\end{aligned}\n    $$\n\nFor each integrator and each test case, the integration is carried out for $N$ steps. At each step $n$, the numerical angular momentum $\\ell_n$ is computed from the state $\\mathbf{y}_n$. The performance metric is the maximum relative drift in angular momentum over the entire integration:\n$$\n\\varepsilon_{\\max} = \\max_{0 \\leq n \\leq N} \\frac{\\left|\\ell_n - \\ell_0\\right|}{\\left|\\ell_0\\right|}\n$$\nThe final output will consist of the computed values of $\\varepsilon_{\\max}$ for each of the three integrators across the four specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Kepler problem for specified test cases, comparing the numerical drift\n    in angular momentum for Euler, Midpoint (RK2), and classical RK4 methods.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (eccentricity, step_size, num_orbits)\n    test_cases = [\n        (0.0, 0.01, 1),\n        (0.6, 0.01, 1),\n        (0.6, 0.03, 5),\n        (0.9, 0.005, 1),\n    ]\n\n    # Nondimensional gravitational parameter and semi-major axis.\n    GM = 1.0\n    a = 1.0\n\n    def f_ode(y):\n        \"\"\"\n        The derivative function dy/dt = f(y) for the Kepler problem.\n        y is the state vector [x, y_pos, v_x, v_y].\n        \"\"\"\n        x, y_pos, v_x, v_y = y\n        # The position vector magnitude r = ||r||.\n        r_norm = np.sqrt(x**2 + y_pos**2)\n        # Avoid division by zero, though not expected for these elliptical orbits.\n        if r_norm == 0:\n            return np.zeros(4)\n        \n        r_norm_cubed = r_norm**3\n        \n        # Acceleration components a = -GM * r / ||r||^3. With GM=1.\n        a_x = -x / r_norm_cubed\n        a_y = -y_pos / r_norm_cubed\n        \n        return np.array([v_x, v_y, a_x, a_y])\n\n    def euler_step(f, y, h):\n        \"\"\"Performs a single step using the explicit Euler method.\"\"\"\n        return y + h * f(y)\n\n    def midpoint_step(f, y, h):\n        \"\"\"Performs a single step using the explicit Midpoint (RK2) method.\"\"\"\n        k1 = f(y)\n        k2 = f(y + 0.5 * h * k1)\n        return y + h * k2\n\n    def rk4_step(f, y, h):\n        \"\"\"Performs a single step using the classical RK4 method.\"\"\"\n        k1 = f(y)\n        k2 = f(y + 0.5 * h * k1)\n        k3 = f(y + 0.5 * h * k2)\n        k4 = f(y + h * k3)\n        return y + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    def get_angular_momentum(y):\n        \"\"\"Computes the specific angular momentum from the state vector.\"\"\"\n        x, y_pos, v_x, v_y = y\n        return x * v_y - y_pos * v_x\n\n    all_results = []\n\n    for e, h, K in test_cases:\n        # Orbital period for a=1, GM=1 is T = 2*pi.\n        T = 2.0 * np.pi\n        total_time = K * T\n        num_steps = int(np.floor(total_time / h))\n\n        # Initial conditions at pericenter.\n        r0 = np.array([a * (1.0 - e), 0.0])\n        v0 = np.array([0.0, np.sqrt(GM * (1.0 + e) / (a * (1.0 - e)))]) # Corrected to include GM\n        y0 = np.array([r0[0], r0[1], v0[0], v0[1]])\n\n        l0 = get_angular_momentum(y0)\n        \n        # Need to handle the case l0=0, though not expected here as e  1.\n        l0_abs = np.abs(l0)\n        if l0_abs == 0.0:\n            # For a radial trajectory, drift is ill-defined. This won't happen for test cases.\n            # We would skip or return NaN, but for this problem it's safe.\n            l0_abs = 1.0 # Placeholder to prevent division by zero in an edge case.\n\n        integrators = [\n            (\"Euler\", euler_step),\n            (\"Midpoint\", midpoint_step),\n            (\"RK4\", rk4_step),\n        ]\n        \n        case_results = []\n        for name, step_func in integrators:\n            y = np.copy(y0)\n            max_rel_drift = 0.0\n\n            for _ in range(num_steps):\n                y = step_func(f_ode, y, h)\n                l_n = get_angular_momentum(y)\n                rel_drift = np.abs(l_n - l0) / l0_abs\n                if rel_drift > max_rel_drift:\n                    max_rel_drift = rel_drift\n            \n            case_results.append(max_rel_drift)\n        \n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # [[a1,b1,c1],[a2,b2,c2],[a_3,b_3,c_3],[a_4,b_4,c_4]]\n    # This construction ensures there are no spaces within the sub-lists.\n    sublist_strs = [f\"[{','.join(map(str, sub))}]\" for sub in all_results]\n    print(f\"[{','.join(sublist_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "For very long-term integrations, even high-order explicit methods can exhibit systematic drift in conserved quantities like energy. This advanced practice introduces a more profound concept: the role of an integrator's geometric properties, such as time-symmetry, in preserving the qualitative features of a dynamical system. You will construct a second-order time-symmetric method by composing forward and backward Euler steps and compare its long-term energy conservation against non-symmetric explicit methods . This exercise reveals that a method's structure can be as important as its order of accuracy, providing a gateway to the powerful world of geometric and symplectic integrators used in state-of-the-art astrophysical simulations.",
            "id": "3534425",
            "problem": "You will study the long-time behavior of numerical orbital energy when integrating a planar two-body problem under a Kepler gravitational potential using three single-step ordinary differential equation solvers: a time-symmetrized composition of Euler forward and Euler backward with half-steps, the explicit midpoint method, and the classical fourth-order Runge–Kutta method. Start from first principles: Newton’s second law and Newtonian gravitation. Specifically, consider a point mass orbiting a fixed central mass with gravitational parameter $\\mu$, with dynamics governed by\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = -\\mu \\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3},\n$$\nwhere $\\mathbf{r} = (x,y)$ and $\\mathbf{v} = (v_x,v_y)$. Use nondimensionalized units with $\\mu = 1$ so that all quantities are dimensionless. The total specific orbital energy is\n$$\nE = \\frac{1}{2} \\left( v_x^2 + v_y^2 \\right) - \\frac{\\mu}{\\lVert \\mathbf{r} \\rVert}.\n$$\n\nYour tasks:\n- Derive a time-symmetrized second-order method by composing Euler forward and Euler backward with half-steps in a symmetric fashion, based only on core definitions. Implement it as a one-step map that takes a state at time $t_n$ to time $t_{n+1} = t_n + h$. Euler forward is the explicit update based on evaluating the right-hand side at the current state, and Euler backward is the implicit update based on evaluating the right-hand side at the new state. The composed method should use a half-step of Euler forward followed by a half-step of Euler backward or vice versa, to achieve time-symmetry. Any implicit substep must be solved to a consistent numerical tolerance.\n- Implement the explicit midpoint method as a single-step second-order Runge–Kutta method.\n- Implement the classical fourth-order Runge–Kutta method as a reference high-order explicit method.\n\nStarting from Newton’s laws and the definition of energy, derive the form of the ordinary differential equation (ODE) system and the expressions needed to apply each single-step method. For any implicit solve, use a Newton iteration with the analytically derived Jacobian of the ODE right-hand side with respect to the state. The Jacobian should be derived from the gravitational acceleration’s dependence on position; all partial derivatives must be expressed in terms of $\\mathbf{r}$, $\\lVert \\mathbf{r} \\rVert$, and $\\mu$. The Newton iteration should terminate when the update’s infinity norm is less than a specified tolerance or a maximum number of iterations is reached. Use a tolerance of $10^{-12}$ and a maximum of $20$ iterations. Use double-precision arithmetic.\n\nThe initial conditions correspond to bound Keplerian orbits with given semi-major axis $a$ and eccentricity $e$, initialized at periapsis. Use the vis-viva relation at periapsis to set the speed:\n$$\nr_p = a (1 - e), \\quad v_p = \\sqrt{\\mu \\left(\\frac{2}{r_p} - \\frac{1}{a}\\right)} = \\sqrt{\\mu \\frac{1+e}{a(1-e)} }.\n$$\nSet the initial state as $\\mathbf{r}(0) = (r_p, 0)$ and $\\mathbf{v}(0) = (0, v_p)$. For $\\mu=1$, the orbital period is\n$$\nT = 2 \\pi a^{3/2}.\n$$\n\nFor each test case below, integrate for a specified number of orbital periods using a fixed step size $\\Delta t = T/N_{\\text{per}}$, where $N_{\\text{per}}$ is the number of time steps per orbital period. For each method, record the maximum relative energy error over the entire integration interval:\n$$\n\\max_{0 \\le n \\le N} \\frac{\\left| E_n - E_0 \\right|}{\\left|E_0\\right|},\n$$\nwhere $N$ is the total number of time steps and $E_n$ is the energy computed at step $n$. Because the units are nondimensional with $\\mu=1$, no physical units need to be reported.\n\nTest suite:\n- Case $1$ (moderate eccentricity, moderate resolution, long duration): $a=1$, $e=0.1$, integrate for $200$ orbital periods with $N_{\\text{per}} = 100$ steps per period.\n- Case $2$ (high eccentricity, higher resolution, moderate duration): $a=1$, $e=0.6$, integrate for $100$ orbital periods with $N_{\\text{per}} = 200$ steps per period.\n- Case $3$ (circular orbit, coarse resolution, short duration): $a=1$, $e=0.0$, integrate for $50$ orbital periods with $N_{\\text{per}} = 20$ steps per period.\n\nFor each case, compute three floats corresponding to the maximum relative energy error for:\n$1$) the time-symmetrized Euler composition method, $2$) the explicit midpoint method, and $3$) the classical Runge–Kutta $4$ method. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the fixed order\n[`case1_symEuler`, `case1_midpoint`, `case1_RK4`, `case2_symEuler`, `case2_midpoint`, `case2_RK4`, `case3_symEuler`, `case3_midpoint`, `case3_RK4`],\nwhere each entry is a float. No additional text should be printed. The answer requires angle-free dynamics and nondimensional units, so no angle unit is needed, and no physical units need to be attached to the outputs. The numerical results must be computed by your code directly; do not hard-code any expected values.",
            "solution": "The user wants to analyze the numerical integration of a planar two-body problem. The problem is scientifically and mathematically sound, well-posed, and all necessary parameters and conditions for a numerical experiment are provided. We may therefore proceed with the solution.\n\n### 1. System Formulation\nThe problem describes the motion of a point mass in a plane orbiting a fixed central mass under Newtonian gravity. The dynamics are governed by a system of second-order ordinary differential equations (ODEs). To apply single-step ODE solvers, we first convert this system into a first-order form.\n\nLet the state of the system be described by a four-dimensional vector $\\mathbf{y}(t)$ comprising the position $\\mathbf{r}=(x,y)$ and velocity $\\mathbf{v}=(v_x,v_y)$:\n$$\n\\mathbf{y}(t) = \\begin{bmatrix} x(t) \\\\ y(t) \\\\ v_x(t) \\\\ v_y(t) \\end{bmatrix}\n$$\nThe governing equations given are:\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = -\\mu \\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3}\n$$\nwhere $\\mu$ is the gravitational parameter, set to $\\mu=1$. This system can be written as a single first-order ODE, $\\frac{d\\mathbf{y}}{dt} = f(\\mathbf{y})$, where the function $f: \\mathbb{R}^4 \\to \\mathbb{R}^4$ is defined as:\n$$\nf(\\mathbf{y}) = f(x, y, v_x, v_y) = \\begin{bmatrix} v_x \\\\ v_y \\\\ -\\mu x / (x^2+y^2)^{3/2} \\\\ -\\mu y / (x^2+y^2)^{3/2} \\end{bmatrix}\n$$\nThe problem is to numerically integrate this system from an initial state $\\mathbf{y}_0$ over a specified duration, using a fixed time step $h = \\Delta t$. A numerical integrator is a map $\\mathbf{y}_{n+1} = \\Phi_h(\\mathbf{y}_n)$ that approximates the true solution at time $t_{n+1} = t_n + h$.\n\nThe specific orbital energy, a conserved quantity of the exact system, is given by:\n$$\nE(\\mathbf{y}) = \\frac{1}{2} (v_x^2 + v_y^2) - \\frac{\\mu}{\\sqrt{x^2+y^2}}\n$$\nWe will monitor the error in this quantity to assess the quality of the numerical integrators.\n\n### 2. Derivation of Numerical Integrators\n\nWe will implement three distinct single-step methods.\n\n#### 2.1. Time-Symmetrized Euler Composition\nThis method is specified as a symmetric composition of the Euler forward (EF) and Euler backward (EB) methods, each with a half-step $h/2$.\nAn EF step from $\\mathbf{y}_A$ to $\\mathbf{y}_B$ with step size $\\Delta t$ is $\\mathbf{y}_B = \\mathbf{y}_A + \\Delta t f(\\mathbf{y}_A)$.\nAn EB step from $\\mathbf{y}_A$ to $\\mathbf{y}_B$ with step size $\\Delta t$ is $\\mathbf{y}_B = \\mathbf{y}_A + \\Delta t f(\\mathbf{y}_B)$.\n\nA symmetric composition involves applying one operator, then another. Let's consider applying a half-step of EF, followed by a half-step of EB.\nLet $\\mathbf{y}_n$ be the state at time $t_n$.\nFirst, an intermediate state $\\mathbf{y}^*$ is computed using EF with a step of $h/2$:\n$$\n\\mathbf{y}^* = \\mathbf{y}_n + \\frac{h}{2} f(\\mathbf{y}_n)\n$$\nThen, the final state $\\mathbf{y}_{n+1}$ is computed from $\\mathbf{y}^*$ using EB with a step of $h/2$:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}^* + \\frac{h}{2} f(\\mathbf{y}_{n+1})\n$$\nSubstituting the expression for $\\mathbf{y}^*$ into the second equation gives the one-step map for $\\mathbf{y}_{n+1}$:\n$$\n\\mathbf{y}_{n+1} = \\left(\\mathbf{y}_n + \\frac{h}{2} f(\\mathbf{y}_n)\\right) + \\frac{h}{2} f(\\mathbf{y}_{n+1})\n$$\nThis can be rearranged to $\\mathbf{y}_{n+1} - \\frac{h}{2} f(\\mathbf{y}_{n+1}) = \\mathbf{y}_n + \\frac{h}{2} f(\\mathbf{y}_n)$. This method is recognized as the implicit trapezoidal rule (or Crank-Nicolson method for PDEs). It is a second-order, A-stable, and time-symmetric (self-adjoint) method. This method is implicit, as $\\mathbf{y}_{n+1}$ appears on both sides. To implement it, we must solve a system of nonlinear equations at each time step.\n\n#### 2.2. Explicit Midpoint Method\nThis is a second-order, explicit Runge-Kutta method. It involves two stages:\n1. Compute a preliminary state at the midpoint of the interval using an Euler step of size $h/2$:\n   $$\n   \\mathbf{k}_1 = f(\\mathbf{y}_n) \\quad (\\text{slope at start})\n   $$\n   $$\n   \\mathbf{y}_{\\text{mid}} = \\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1\n   $$\n2. Use the slope at this midpoint state to take a full step from $\\mathbf{y}_n$:\n   $$\n   \\mathbf{k}_2 = f(\\mathbf{y}_{\\text{mid}}) \\quad (\\text{slope at midpoint})\n   $$\n   $$\n   \\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\mathbf{k}_2\n   $$\nThe method is explicit because each stage can be computed directly from the result of the previous one.\n\n#### 2.3. Classical Fourth-Order Runge-Kutta (RK4) Method\nThe classical RK4 method is a widely used fourth-order explicit method. It achieves higher accuracy by using a weighted average of four slope evaluations within the time step:\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(\\mathbf{y}_n) \\\\\n\\mathbf{k}_2 = f\\left(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1\\right) \\\\\n\\mathbf{k}_3 = f\\left(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_2\\right) \\\\\n\\mathbf{k}_4 = f\\left(\\mathbf{y}_n + h \\mathbf{k}_3\\right) \\\\\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{aligned}\n$$\nBeing explicit, it requires no equation solving. Its superior local accuracy often translates to better performance for moderate integration times.\n\n### 3. Newton's Method for the Implicit Solver\nTo implement the time-symmetrized Euler method, we must solve the implicit equation for $\\mathbf{y}_{n+1}$. Let $X = \\mathbf{y}_{n+1}$. The equation to solve is a root-finding problem:\n$$\nG(X) = X - \\mathbf{y}_n - \\frac{h}{2} f(\\mathbf{y}_n) - \\frac{h}{2} f(X) = 0\n$$\nWe use Newton's method, which generates a sequence of approximations $X_k$ that converge to the root. Starting with an initial guess $X_0$, the iteration is:\n$$\nX_{k+1} = X_k - [G'(X_k)]^{-1} G(X_k)\n$$\nwhere $G'(X_k)$ is the Jacobian matrix of $G$ with respect to $X$, evaluated at $X_k$.\nThe Jacobian of $G(X)$ is:\n$$\nG'(X) = \\frac{\\partial}{\\partial X} \\left( X - \\mathbf{y}_n - \\frac{h}{2} f(\\mathbf{y}_n) - \\frac{h}{2} f(X) \\right) = I - \\frac{h}{2} J_f(X)\n$$\nwhere $I$ is the $4 \\times 4$ identity matrix and $J_f(X) = f'(X)$ is the Jacobian of the ODE's right-hand-side function $f$.\n\nThe Newton update step involves solving the linear system:\n$$\n\\left(I - \\frac{h}{2} J_f(X_k)\\right) \\Delta X_k = -G(X_k)\n$$\nfor the correction $\\Delta X_k = X_{k+1} - X_k$. The iteration proceeds until $\\|\\Delta X_k\\|_\\infty  10^{-12}$ or a maximum of $20$ iterations is reached. A good initial guess $X_0$ is the result of an explicit Euler step: $X_0 = \\mathbf{y}_n + hf(\\mathbf{y}_n)$.\n\n#### Jacobian of the ODE function $f(\\mathbf{y})$\nThe state vector is $\\mathbf{y} = [x, y, v_x, v_y]^T$. The function is $f(\\mathbf{y}) = [v_x, v_y, a_x(\\mathbf{r}), a_y(\\mathbf{r})]^T$, where $\\mathbf{a} = -\\mu \\mathbf{r} / r^3$ and $r = \\sqrt{x^2+y^2}$.\nThe Jacobian $J_f = \\frac{\\partial f}{\\partial \\mathbf{y}}$ has a block structure:\n$$\nJ_f = \\begin{pmatrix} \\mathbf{0}_{2\\times2}  I_{2\\times2} \\\\ J_{\\mathbf{a},\\mathbf{r}}  \\mathbf{0}_{2\\times2} \\end{pmatrix}\n$$\nHere, $\\mathbf{0}_{2\\times2}$ and $I_{2\\times2}$ are the $2 \\times 2$ zero and identity matrices, respectively. The non-trivial block is $J_{\\mathbf{a},\\mathbf{r}} = \\frac{\\partial \\mathbf{a}}{\\partial \\mathbf{r}}$. Its components are derived using the chain and product rules:\nThe general formula for the partial derivatives is $\\frac{\\partial a_i}{\\partial r_j} = \\frac{\\mu}{r^5} (3 r_i r_j - \\delta_{ij} r^2)$, where $i,j \\in \\{x,y\\}$.\nThis gives rise to the block:\n$$\nJ_{\\mathbf{a},\\mathbf{r}} = \\frac{\\partial(a_x, a_y)}{\\partial(x, y)} = \\frac{\\mu}{r^5} \\begin{pmatrix} 3x^2 - r^2  3xy \\\\ 3xy  3y^2 - r^2 \\end{pmatrix} = \\frac{\\mu}{r^5} \\begin{pmatrix} 2x^2 - y^2  3xy \\\\ 3xy  2y^2 - x^2 \\end{pmatrix}\n$$\nThis $4 \\times 4$ Jacobian $J_f$ is used to form the linear system in each Newton iteration.\n\n### 4. Numerical Experiment Setup\nFor each test case, the simulation is set up as follows:\n1.  **Initial Conditions**: The orbit is initialized at periapsis. Given semi-major axis $a$ and eccentricity $e$, the periapsis distance is $r_p = a(1-e)$ and the velocity is $v_p = \\sqrt{\\mu(2/r_p - 1/a)}$. The initial state vector is $\\mathbf{y}_0 = [r_p, 0, 0, v_p]^T$. With $\\mu=1$, the orbital period is $T = 2\\pi a^{3/2}$.\n2.  **Integration Parameters**: The integration runs for a specified number of orbital periods. The fixed time step is $\\Delta t = h = T/N_{\\text{per}}$, where $N_{\\text{per}}$ is the number of steps per period.\n3.  **Error Metric**: The initial energy $E_0 = E(\\mathbf{y}_0)$ is computed. For every step $n$, the energy $E_n = E(\\mathbf{y}_n)$ is calculated, and the relative error is found. The performance metric is the maximum relative energy error over the entire integration:\n    $$\n    \\text{Error} = \\max_{n} \\frac{|E_n - E_0|}{|E_0|}\n    $$\nThis procedure is repeated for each of the three integrators and for each of the three test cases specified in the problem statement. The results are then collected and formatted as required.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-body problem using three different numerical integrators\n    and computes the maximum relative energy error for each.\n    \"\"\"\n    \n    # --- Problem Constants and Numerical Parameters ---\n    MU = 1.0\n    NEWTON_TOL = 1e-12\n    NEWTON_MAX_ITER = 20\n\n    # --- Core Physics and ODE Functions ---\n    \n    def compute_energy(y):\n        \"\"\"Computes the specific orbital energy.\"\"\"\n        x, y, vx, vy = y\n        r_norm = np.sqrt(x**2 + y**2)\n        v_norm_sq = vx**2 + vy**2\n        return 0.5 * v_norm_sq - MU / r_norm\n\n    def f_ode(y):\n        \"\"\"Computes the right-hand side of the ODE dy/dt = f(y).\"\"\"\n        x, y, vx, vy = y\n        r_norm_cubed = (x**2 + y**2)**1.5\n        ax = -MU * x / r_norm_cubed\n        ay = -MU * y / r_norm_cubed\n        return np.array([vx, vy, ax, ay], dtype=np.float64)\n\n    def compute_jacobian(y):\n        \"\"\"Computes the Jacobian of f_ode(y).\"\"\"\n        x, y, _, _ = y\n        r_sq = x**2 + y**2\n        r_norm5 = r_sq**2.5\n        \n        # J_ar block: partial derivatives of acceleration w.r.t. position\n        dax_dx = MU * (2 * x**2 - y**2) / r_norm5\n        dax_dy = MU * (3 * x * y) / r_norm5\n        day_dx = dax_dy\n        day_dy = MU * (2 * y**2 - x**2) / r_norm5\n        \n        J = np.array([\n            [0.0, 0.0, 1.0, 0.0],\n            [0.0, 0.0, 0.0, 1.0],\n            [dax_dx, dax_dy, 0.0, 0.0],\n            [day_dx, day_dy, 0.0, 0.0]\n        ], dtype=np.float64)\n        return J\n\n    # --- Numerical Integrators ---\n\n    def sym_euler_step(y_n, h):\n        \"\"\"Performs one step of the time-symmetrized Euler method.\"\"\"\n        \n        # Implicit equation: G(y_next) = y_next - y_n - 0.5*h*f(y_n) - 0.5*h*f(y_next) = 0\n        f_n = f_ode(y_n)\n        \n        # Initial guess using explicit Euler\n        y_next = y_n + h * f_n\n        \n        for _ in range(NEWTON_MAX_ITER):\n            # Evaluate G(y_next)\n            G = y_next - y_n - 0.5 * h * f_n - 0.5 * h * f_ode(y_next)\n            \n            # Evaluate Jacobian of G: I - 0.5*h*J_f(y_next)\n            J_g = np.identity(4) - 0.5 * h * compute_jacobian(y_next)\n            \n            # Solve linear system for the update: J_g * delta_y = -G\n            delta_y = np.linalg.solve(J_g, -G)\n            \n            # Update solution\n            y_next += delta_y\n            \n            # Check for convergence\n            if np.linalg.norm(delta_y, ord=np.inf)  NEWTON_TOL:\n                break\n        \n        return y_next\n\n    def midpoint_step(y_n, h):\n        \"\"\"Performs one step of the explicit midpoint method.\"\"\"\n        k1 = f_ode(y_n)\n        y_mid = y_n + 0.5 * h * k1\n        k2 = f_ode(y_mid)\n        return y_n + h * k2\n\n    def rk4_step(y_n, h):\n        \"\"\"Performs one step of the classical RK4 method.\"\"\"\n        k1 = f_ode(y_n)\n        k2 = f_ode(y_n + 0.5 * h * k1)\n        k3 = f_ode(y_n + 0.5 * h * k2)\n        k4 = f_ode(y_n + h * k3)\n        return y_n + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    # --- Test Case Execution ---\n\n    test_cases = [\n        # a, e, num_periods, N_per\n        (1.0, 0.1, 200, 100),\n        (1.0, 0.6, 100, 200),\n        (1.0, 0.0, 50, 20),\n    ]\n\n    integrators = {\n        'symEuler': sym_euler_step,\n        'midpoint': midpoint_step,\n        'RK4': rk4_step,\n    }\n    method_order = ['symEuler', 'midpoint', 'RK4']\n    \n    all_results = []\n\n    for a, e, num_periods, N_per in test_cases:\n        # Calculate initial conditions\n        if e == 1.0: # Parabolic case, r_p=a(1-e) is tricky\n            # Not in test suite, but good practice\n            r_p = a\n            v_p = np.sqrt(2*MU/r_p)\n        else:\n            r_p = a * (1 - e)\n            v_p = np.sqrt(MU * (2 / r_p - 1 / a))\n        \n        y0 = np.array([r_p, 0.0, 0.0, v_p], dtype=np.float64)\n        \n        # Calculate integration parameters\n        T = 2 * np.pi * a**1.5\n        dt = T / N_per\n        total_steps = num_periods * N_per\n\n        # Calculate initial energy\n        E0 = compute_energy(y0)\n\n        for method_name in method_order:\n            integrator = integrators[method_name]\n            y = y0.copy()\n            max_rel_error = 0.0\n            \n            for _ in range(total_steps):\n                y = integrator(y, dt)\n                En = compute_energy(y)\n                rel_error = np.abs(En - E0) / np.abs(E0)\n                if rel_error > max_rel_error:\n                    max_rel_error = rel_error\n            \n            all_results.append(max_rel_error)\n\n    # --- Format and Print Final Output ---\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}