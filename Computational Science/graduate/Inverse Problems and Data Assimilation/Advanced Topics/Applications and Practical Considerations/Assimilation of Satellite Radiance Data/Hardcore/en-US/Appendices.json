{
    "hands_on_practices": [
        {
            "introduction": "The relationship between atmospheric properties and satellite-measured radiances is governed by the complex physics of radiative transfer, making the observation operator inherently non-linear. Since many advanced data assimilation techniques rely on a linear representation, this first practice guides you through the fundamental process of testing the validity of the tangent-linear approximation . By deriving the Jacobian for a physically-based radiance model and quantifying the approximation error, you will develop a crucial understanding of the limits of linearization, a cornerstone of variational data assimilation.",
            "id": "3365135",
            "problem": "Consider the assimilation of satellite nadir-view thermal infrared radiances from a single spectral channel over a horizontally homogeneous, clear-sky, isothermal humid layer above a surface. Let the observation operator map the atmospheric state to the Top Of Atmosphere (TOA) monochromatic radiance using the following physically based ingredients:\n\n1. Beer–Lambert law for absorption along the line of sight. For nadir geometry (cosine of zenith angle equal to $1$), the layer transmittance is\n$$\n\\tau(q) = \\exp\\left(- \\kappa_\\nu \\, q \\, M_{\\text{air}}\\right),\n$$\nwhere $q$ is the specific humidity in $\\mathrm{kg}\\,\\mathrm{kg}^{-1}$, $\\kappa_\\nu$ is the mass absorption coefficient for water vapor at the channel wavenumber in $\\mathrm{m}^2\\,\\mathrm{kg}^{-1}$, and $M_{\\text{air}}$ is the layer air mass per unit area in $\\mathrm{kg}\\,\\mathrm{m}^{-2}$.\n\n2. Planck’s law for spectral radiance as a function of absolute temperature, written in the wavenumber domain (spectral radiance per unit wavenumber):\n$$\nB_{\\tilde{\\nu}}(T) = \\frac{2 h c^2 \\tilde{\\nu}^3}{\\exp\\!\\left(\\frac{h c \\tilde{\\nu}}{k_B T}\\right) - 1},\n$$\nwhere $h$ is Planck’s constant in $\\mathrm{J}\\,\\mathrm{s}$, $c$ is the speed of light in $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $k_B$ is Boltzmann’s constant in $\\mathrm{J}\\,\\mathrm{K}^{-1}$, $\\tilde{\\nu}$ is the wavenumber in $\\mathrm{m}^{-1}$, and $T$ is temperature in $\\mathrm{K}$. The units of $B_{\\tilde{\\nu}}$ are $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,(\\mathrm{m}^{-1})^{-1}$.\n\n3. Surface is a Lambertian emitter with emissivity $\\varepsilon_s$ (dimensionless), surface temperature $T_s$, and the layer is isothermal at temperature $T_\\ell$. For nadir view and clear sky, the TOA monochromatic radiance is\n$$\nH(q) = \\varepsilon_s \\, B_{\\tilde{\\nu}}(T_s)\\, \\tau(q) + \\left(1 - \\tau(q)\\right) B_{\\tilde{\\nu}}(T_\\ell).\n$$\n\nYou are asked to test the validity of the Tangent-Linear (TL) approximation of the observation operator in finite-perturbation experiments. Let the background specific humidity be $q_b$. For a perturbation $\\delta q$, define the TL linearization of $H$ around $q_b$ by\n$$\nH(q_b + \\delta q) \\approx H(q_b) + K\\, \\delta q,\n$$\nwhere $K$ is the TL operator (the derivative of $H$ with respect to $q$ evaluated at $q_b$). Your tasks are:\n\n- Starting strictly from the definitions above and standard differentiation rules, derive an analytical expression for $K$ at $q_b$ in terms of the given physical parameters. Do not introduce any unphysical approximations beyond the assumptions stated.\n\n- For each perturbation $\\delta q$, compute the nonlinearity indicator (relative TL error)\n$$\n\\mathcal{E}_{\\text{rel}}(\\delta q) = \\frac{\\left|H(q_b+\\delta q) - H(q_b) - K\\,\\delta q\\right|}{\\left|H(q_b+\\delta q) - H(q_b)\\right|},\n$$\nwith the convention that if the denominator equals zero, then $\\mathcal{E}_{\\text{rel}}(\\delta q)$ is defined to be $0$.\n\n- For each test case below, return a single scalar equal to the maximum of $\\mathcal{E}_{\\text{rel}}(\\delta q)$ over the provided list of perturbations in that test case.\n\nPhysical constants and units:\n- Use $h = 6.62607015\\times 10^{-34}\\ \\mathrm{J}\\,\\mathrm{s}$, $c = 2.99792458\\times 10^{8}\\ \\mathrm{m}\\,\\mathrm{s}^{-1}$, and $k_B = 1.380649\\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$.\n- Use a single channel with wavenumber $\\tilde{\\nu} = 1000\\ \\mathrm{cm}^{-1} = 100000\\ \\mathrm{m}^{-1}$.\n- All temperatures must be expressed in $\\mathrm{K}$, specific humidity $q$ and its perturbations $\\delta q$ in $\\mathrm{kg}\\,\\mathrm{kg}^{-1}$, mass absorption coefficient $\\kappa_\\nu$ in $\\mathrm{m}^2\\,\\mathrm{kg}^{-1}$, layer mass $M_{\\text{air}}$ in $\\mathrm{kg}\\,\\mathrm{m}^{-2}$, and radiances in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,(\\mathrm{m}^{-1})^{-1}$.\n\nTest suite:\n- Case $1$: $q_b = 0.005$, $T_\\ell = 280$, $T_s = 290$, $\\kappa_\\nu = 0.04$, $M_{\\text{air}} = 4000$, $\\varepsilon_s = 0.98$, $\\delta q \\in \\{10^{-6},\\,10^{-5},\\,10^{-4},\\,5\\times 10^{-4}\\}$.\n- Case $2$: $q_b = 0.015$, $T_\\ell = 270$, $T_s = 300$, $\\kappa_\\nu = 0.05$, $M_{\\text{air}} = 4000$, $\\varepsilon_s = 0.98$, $\\delta q \\in \\{10^{-5},\\,10^{-4},\\,10^{-3},\\,2\\times 10^{-3}\\}$.\n- Case $3$: $q_b = 0.020$, $T_\\ell = 295$, $T_s = 305$, $\\kappa_\\nu = 0.06$, $M_{\\text{air}} = 5000$, $\\varepsilon_s = 0.98$, $\\delta q \\in \\{-10^{-4},\\,-5\\times 10^{-4},\\,5\\times 10^{-4},\\,2\\times 10^{-3}\\}$.\n- Case $4$: $q_b = 0.025$, $T_\\ell = 260$, $T_s = 270$, $\\kappa_\\nu = 0.07$, $M_{\\text{air}} = 6000$, $\\varepsilon_s = 0.98$, $\\delta q \\in \\{10^{-3},\\,3\\times 10^{-3},\\,5\\times 10^{-3}\\}$.\n\nNumerical and output requirements:\n- For each test case, compute the maximum relative TL error across its $\\delta q$ values and round it to $6$ decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the four cases, for example $[r_1,r_2,r_3,r_4]$, where each $r_i$ is a float rounded to $6$ decimal places.",
            "solution": "The problem is valid as it is scientifically grounded in established principles of atmospheric radiative transfer, is mathematically well-posed, and all necessary parameters and constants are provided for a unique solution. We proceed to solve the problem.\n\nThe solution involves two main parts: first, the analytical derivation of the Tangent-Linear (TL) operator, $K$, and second, the numerical implementation to compute the relative TL error for the given test cases.\n\n**1. Analytical Derivation of the Tangent-Linear Operator**\n\nThe Tangent-Linear operator $K$ is defined as the first derivative of the observation operator $H(q)$ with respect to the state variable $q$, evaluated at the background state $q_b$.\n$$K = \\frac{dH}{dq}\\bigg|_{q=q_b}$$\nThe observation operator for the Top Of Atmosphere (TOA) monochromatic radiance, $H(q)$, is given by:\n$$H(q) = \\varepsilon_s \\, B_{\\tilde{\\nu}}(T_s)\\, \\tau(q) + \\left(1 - \\tau(q)\\right) B_{\\tilde{\\nu}}(T_\\ell)$$\nwhere $\\varepsilon_s$ is the surface emissivity, $T_s$ is the surface temperature, $T_\\ell$ is the layer temperature, and $B_{\\tilde{\\nu}}(T)$ is the Planck function for radiance at wavenumber $\\tilde{\\nu}$ and temperature $T$. The dependence on the specific humidity $q$ is entirely through the layer transmittance, $\\tau(q)$.\n\nFor clarity in differentiation, we can rearrange the expression for $H(q)$:\n$$H(q) = \\tau(q) \\left[ \\varepsilon_s B_{\\tilde{\\nu}}(T_s) - B_{\\tilde{\\nu}}(T_\\ell) \\right] + B_{\\tilde{\\nu}}(T_\\ell)$$\nThe Planck function values, $B_{\\tilde{\\nu}}(T_s)$ and $B_{\\tilde{\\nu}}(T_\\ell)$, are constant with respect to $q$. We apply the chain rule to differentiate $H(q)$ with respect to $q$:\n$$\\frac{dH}{dq} = \\frac{d}{dq} \\left( \\tau(q) \\left[ \\varepsilon_s B_{\\tilde{\\nu}}(T_s) - B_{\\tilde{\\nu}}(T_\\ell) \\right] + B_{\\tilde{\\nu}}(T_\\ell) \\right)$$\n$$\\frac{dH}{dq} = \\left[ \\varepsilon_s B_{\\tilde{\\nu}}(T_s) - B_{\\tilde{\\nu}}(T_\\ell) \\right] \\frac{d\\tau}{dq}$$\nNext, we find the derivative of the transmittance $\\tau(q)$, which is defined by the Beer-Lambert law:\n$$\\tau(q) = \\exp\\left(- \\kappa_\\nu \\, q \\, M_{\\text{air}}\\right)$$\nwhere $\\kappa_\\nu$ is the mass absorption coefficient and $M_{\\text{air}}$ is the layer air mass per unit area. Differentiating $\\tau(q)$ with respect to $q$:\n$$\\frac{d\\tau}{dq} = \\frac{d}{dq} \\exp\\left(- \\kappa_\\nu \\, q \\, M_{\\text{air}}\\right)$$\nUsing the chain rule for the exponential function, where the argument of the exponent is a linear function of $q$:\n$$\\frac{d\\tau}{dq} = \\exp\\left(- \\kappa_\\nu \\, q \\, M_{\\text{air}}\\right) \\cdot \\frac{d}{dq}\\left(- \\kappa_\\nu \\, q \\, M_{\\text{air}}\\right)$$\n$$\\frac{d\\tau}{dq} = \\tau(q) \\cdot (-\\kappa_\\nu M_{\\text{air}})$$\nSubstituting this result back into the expression for $\\frac{dH}{dq}$:\n$$\\frac{dH}{dq} = \\left[ \\varepsilon_s B_{\\tilde{\\nu}}(T_s) - B_{\\tilde{\\nu}}(T_\\ell) \\right] \\cdot \\left[ -\\kappa_\\nu M_{\\text{air}} \\tau(q) \\right]$$\nThis expression can be rearranged as:\n$$\\frac{dH}{dq} = \\kappa_\\nu M_{\\text{air}} \\, \\tau(q) \\, \\left[ B_{\\tilde{\\nu}}(T_\\ell) - \\varepsilon_s B_{\\tilde{\\nu}}(T_s) \\right]$$\nThe Tangent-Linear operator $K$ is this derivative evaluated at the background specific humidity $q_b$:\n$$K = \\frac{dH}{dq}\\bigg|_{q=q_b} = \\kappa_\\nu M_{\\text{air}} \\, \\tau(q_b) \\, \\left[ B_{\\tilde{\\nu}}(T_\\ell) - \\varepsilon_s B_{\\tilde{\\nu}}(T_s) \\right]$$\nwhere $\\tau(q_b) = \\exp\\left(- \\kappa_\\nu \\, q_b \\, M_{\\text{air}}\\right)$. This is the final analytical expression for $K$.\n\n**2. Algorithmic Procedure for Numerical Calculation**\n\nFor each test case, we compute the maximum relative Tangent-Linear error, $\\mathcal{E}_{\\text{rel}}(\\delta q)$, over a list of perturbations $\\{\\delta q_i\\}$. The relative error is defined as:\n$$\\mathcal{E}_{\\text{rel}}(\\delta q) = \\frac{\\left|H(q_b+\\delta q) - H(q_b) - K\\,\\delta q\\right|}{\\left|H(q_b+\\delta q) - H(q_b)\\right|}$$\nThe algorithm proceeds as follows:\n1.  Set the physical constants: $h = 6.62607015\\times 10^{-34}\\ \\mathrm{J}\\,\\mathrm{s}$, $c = 2.99792458\\times 10^{8}\\ \\mathrm{m}\\,\\mathrm{s}^{-1}$, $k_B = 1.380649\\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$, and the wavenumber $\\tilde{\\nu} = 100000\\ \\mathrm{m}^{-1}$.\n2.  For each test case with its specific set of parameters ($q_b, T_\\ell, T_s, \\kappa_\\nu, M_{\\text{air}}, \\varepsilon_s$) and list of perturbations $\\{\\delta q_i\\}$:\n    a.  Calculate the Planck radiances for the layer, $B_\\ell = B_{\\tilde{\\nu}}(T_\\ell)$, and the surface, $B_s = B_{\\tilde{\\nu}}(T_s)$, using the Planck function formula:\n        $$B_{\\tilde{\\nu}}(T) = \\frac{2 h c^2 \\tilde{\\nu}^3}{\\exp\\!\\left(\\frac{h c \\tilde{\\nu}}{k_B T}\\right) - 1}$$\n    b.  Compute the background radiance $H_b = H(q_b)$ using the observation operator formula.\n    c.  Compute the Tangent-Linear operator $K$ using the derived analytical formula evaluated at $q_b$.\n    d.  Initialize an empty list to store the errors for the current case.\n    e.  For each perturbation $\\delta q$ in the list $\\{\\delta q_i\\}$:\n        i.  Calculate the perturbed state $q_p = q_b + \\delta q$.\n        ii. Calculate the true perturbed radiance $H_p = H(q_p)$.\n        iii. Calculate the numerator of the error term: $N = |H_p - H_b - K \\cdot \\delta q|$.\n        iv. Calculate the denominator of the error term: $D = |H_p - H_b|$.\n        v. If $D$ is zero, the relative error $\\mathcal{E}_{\\text{rel}}(\\delta q)$ is $0$. Otherwise, compute the error as $\\mathcal{E}_{\\text{rel}}(\\delta q) = N / D$.\n        vi. Append the calculated error to the list.\n    f.  Determine the maximum value from the list of calculated errors.\n    g.  Round this maximum error to $6$ decimal places and record it as the result for the test case.\n3.  Combine the results from all test cases into a single list and format the output as requested.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem by calculating the maximum relative \n    Tangent-Linear error for a set of test cases in satellite radiance assimilation.\n    \"\"\"\n\n    # Physical constants\n    H = 6.62607015e-34    # Planck's constant in J.s\n    C = 2.99792458e8      # Speed of light in m/s\n    KB = 1.380649e-23     # Boltzmann's constant in J/K\n    NU_TILDE = 100000.    # Wavenumber in m^-1 (from 1000 cm^-1)\n\n    # Pre-calculate constant parts of the Planck function for efficiency\n    C1 = 2 * H * C**2 * NU_TILDE**3\n    C2 = H * C * NU_TILDE / KB\n\n    def planck(T):\n        \"\"\"\n        Calculates the spectral radiance using Planck's law.\n        :param T: Temperature in Kelvin.\n        :return: Spectral radiance in W m^-2 sr^-1 (m^-1)^-1.\n        \"\"\"\n        # The argument to exp can be large, but temperatures are reasonable.\n        return C1 / (np.exp(C2 / T) - 1)\n\n    def transmittance(q, kappa_nu, M_air):\n        \"\"\"\n        Calculates the layer transmittance using the Beer-Lambert law.\n        :param q: Specific humidity in kg/kg.\n        :param kappa_nu: Mass absorption coefficient in m^2/kg.\n        :param M_air: Layer air mass per unit area in kg/m^2.\n        :return: Transmittance (dimensionless).\n        \"\"\"\n        optical_depth = kappa_nu * q * M_air\n        return np.exp(-optical_depth)\n\n    def H_operator(q, B_ell, B_s, kappa_nu, M_air, eps_s):\n        \"\"\"\n        The observation operator H(q).\n        :param q: Specific humidity in kg/kg.\n        :param B_ell: Pre-calculated layer Planck radiance.\n        :param B_s: Pre-calculated surface Planck radiance.\n        :param kappa_nu, M_air, eps_s: Other physical parameters.\n        :return: Top Of Atmosphere (TOA) radiance.\n        \"\"\"\n        tau = transmittance(q, kappa_nu, M_air)\n        return eps_s * B_s * tau + (1 - tau) * B_ell\n\n    def K_operator(q_b, B_ell, B_s, kappa_nu, M_air, eps_s):\n        \"\"\"\n        The Tangent-Linear operator K = dH/dq at q_b.\n        :param q_b: Background specific humidity.\n        :param B_ell, B_s: Pre-calculated Planck radiances.\n        :param kappa_nu, M_air, eps_s: Other physical parameters.\n        :return: Value of the Tangent-Linear operator K.\n        \"\"\"\n        tau_b = transmittance(q_b, kappa_nu, M_air)\n        # B_diff = eps_s * B_s - B_ell\n        # dtau_dq = -kappa_nu * M_air * tau_b\n        # return B_diff * dtau_dq\n        # Alternative form from derivation:\n        return kappa_nu * M_air * tau_b * (B_ell - eps_s * B_s)\n\n    def calculate_max_error(params):\n        \"\"\"\n        Calculates the maximum relative TL error for a single test case.\n        :param params: A tuple containing all parameters for the case.\n        :return: The maximum relative error, rounded to 6 decimal places.\n        \"\"\"\n        q_b, T_ell, T_s, kappa_nu, M_air, eps_s, delta_q_list = params\n        \n        # Pre-calculate Planck radiances for the case\n        B_ell = planck(T_ell)\n        B_s = planck(T_s)\n        \n        # Calculate H for background state and the K operator\n        H_b = H_operator(q_b, B_ell, B_s, kappa_nu, M_air, eps_s)\n        K = K_operator(q_b, B_ell, B_s, kappa_nu, M_air, eps_s)\n        \n        errors = []\n        for delta_q in delta_q_list:\n            q_p = q_b + delta_q  # Perturbed state\n            \n            # Full non-linear model for perturbed state\n            H_p = H_operator(q_p, B_ell, B_s, kappa_nu, M_air, eps_s)\n            \n            # Numerator of the relative error formula: |H_p - (H_b + K*dq)|\n            numerator = abs(H_p - H_b - K * delta_q)\n            \n            # Denominator of the relative error formula: |H_p - H_b|\n            denominator = abs(H_p - H_b)\n            \n            if denominator == 0.0:\n                # Per problem spec, if denominator is 0, error is 0.\n                rel_error = 0.0\n            else:\n                rel_error = numerator / denominator\n            \n            errors.append(rel_error)\n            \n        max_error = max(errors) if errors else 0.0\n        return round(max_error, 6)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (q_b, T_ell, T_s, kappa_nu, M_air, eps_s, [delta_q values])\n        (0.005, 280, 290, 0.04, 4000, 0.98, [1e-6, 1e-5, 1e-4, 5e-4]),\n        (0.015, 270, 300, 0.05, 4000, 0.98, [1e-5, 1e-4, 1e-3, 2e-3]),\n        (0.020, 295, 305, 0.06, 5000, 0.98, [-1e-4, -5e-4, 5e-4, 2e-3]),\n        (0.025, 260, 270, 0.07, 6000, 0.98, [1e-3, 3e-3, 5e-3]),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_max_error(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "An analysis in data assimilation is not a perfect reconstruction of reality but a smoothed estimate constrained by both observations and our prior knowledge. The averaging kernel matrix, $A$, is a powerful diagnostic tool that precisely describes how the analysis at one point is a weighted average of the true state across all other points. This exercise focuses on deriving and interpreting the averaging kernel to quantify the effective vertical resolution of an analysis, providing direct insight into how assumptions about background error correlations, encoded in the matrix $B$, shape the final result.",
            "id": "3365149",
            "problem": "Consider a one-dimensional vertical column state vector $x \\in \\mathbb{R}^n$ representing atmospheric temperature perturbations in kelvin (K) at discrete altitudes. Infrared satellite radiance observations are linearized around a background state with the relationship $y = K x + \\varepsilon$, where $y \\in \\mathbb{R}^m$ are channel brightness temperature perturbations in kelvin (K), $K \\in \\mathbb{R}^{m \\times n}$ is the Jacobian of the observation operator (also referred to as the weighting functions), and $\\varepsilon \\sim \\mathcal{N}(0, R)$ is the observation error with covariance $R \\in \\mathbb{R}^{m \\times m}$ in $\\text{K}^2$. The background error $e_b = x - x_b$ satisfies $e_b \\sim \\mathcal{N}(0, B)$ with covariance $B \\in \\mathbb{R}^{n \\times n}$ in $\\text{K}^2$.\n\nStarting from the fundamental linear-Gaussian data assimilation principles and the minimum-variance linear estimator under Gaussian assumptions, derive the expression of the averaging kernel matrix $A \\in \\mathbb{R}^{n \\times n}$ that maps the true state $x$ to the analysis $x_a$ and encodes the vertical resolution of the analysis. Your derivation must begin from the conditions on Gaussian priors and linear observation models, and proceed logically to the analysis operator and its sensitivity to the true state. Do not assume any shortcut identities without justification.\n\nThen, implement a numerical experiment that compares how different vertical background covariance structures $B$ affect the vertical resolution of the analysis inferred from $A$. Use a scientifically consistent discretization and channel configuration with the following specifications.\n\n- Vertical grid:\n    - Let $z_i$ be altitudes in kilometers (km) for $i = 0, 1, \\dots, n-1$, with $n = 31$ points uniformly spaced from $z_0 = 0\\,\\text{km}$ to $z_{30} = 15\\,\\text{km}$.\n    - Define $\\Delta z = 0.5\\,\\text{km}$.\n\n- Infrared observation weighting functions (rows of $K$):\n    - Use $m = 6$ channels with centers $z_{c,j} \\in \\{1, 3, 5, 7, 9, 12\\}\\,\\text{km}$ for $j = 1, \\dots, 6$.\n    - For each channel $j$, define a Gaussian weighting function $w_j(z) = \\exp\\left(-\\frac{(z - z_{c,j})^2}{2 \\sigma_w^2}\\right)$ with $\\sigma_w = 0.8\\,\\text{km}$.\n    - Discretize $K$ by $K_{j,i} = \\frac{w_j(z_i)\\,\\Delta z}{\\sum_{p=0}^{n-1} w_j(z_p)\\,\\Delta z}$ so that each channel integrates to unity over the column. $K$ is dimensionless under this normalization.\n\n- Background covariance $B$ choices:\n    - Exponential kernel (also known as Matérn with smoothness $\\nu = \\tfrac{1}{2}$): for correlation length $L_z$ in kilometers and variance $\\sigma_b^2$ in $\\text{K}^2$, define $B_{ij} = \\sigma_b^2 \\exp\\left(-\\frac{|z_i - z_j|}{L_z}\\right)$.\n    - Matérn kernel with smoothness $\\nu  0$, correlation length $L_z$ in kilometers, and variance $\\sigma_b^2$ in $\\text{K}^2$: for $i \\neq j$,\n      $$B_{ij} = \\sigma_b^2 \\frac{2^{1-\\nu}}{\\Gamma(\\nu)} \\left(\\frac{\\sqrt{2\\nu}\\,|z_i - z_j|}{L_z}\\right)^\\nu K_\\nu\\left(\\frac{\\sqrt{2\\nu}\\,|z_i - z_j|}{L_z}\\right),$$\n      where $\\Gamma(\\cdot)$ is the Gamma function and $K_\\nu(\\cdot)$ is the modified Bessel function of the second kind. Set $B_{ii} = \\sigma_b^2$ for all $i$.\n\n- Observation error covariance $R$:\n    - Use diagonal $R = \\operatorname{diag}(\\sigma_{y}^2, \\dots, \\sigma_{y}^2)$ in $\\text{K}^2$.\n\nFrom the derived $A$, define a quantitative vertical resolution metric at each level $z_i$ as follows. Let $a_i$ be the $i$-th row of $A$. Compute weights $u_i$ by normalizing the absolute values of $a_i$,\n$$u_{i,p} = \\frac{|a_{i,p}|}{\\sum_{q=0}^{n-1} |a_{i,q}|}, \\quad p = 0, \\dots, n-1.$$\nDefine the center of mass $\\bar{z}_i = \\sum_{p=0}^{n-1} u_{i,p} z_p$ and the second central moment $M_i = \\sum_{p=0}^{n-1} u_{i,p} (z_p - \\bar{z}_i)^2$. The effective vertical resolution width at level $z_i$ is $W_i = 2 \\sqrt{M_i}$ in kilometers. For numerical stability, exclude levels with $\\sum_{p=0}^{n-1} |a_{i,p}| \\le 10^{-12}$ from the summary statistics; if all levels are excluded in a test case, return the total grid span $z_{30} - z_0$ as the resolution metric for that case. Aggregate a single resolution metric for each experiment by taking the median of $\\{W_i\\}$ across all included levels, expressed in kilometers.\n\nConstruct the following test suite of parameter sets to probe different aspects of the problem:\n- Case 1 (baseline exponential): exponential $B$ with $L_z = 1.5\\,\\text{km}$, $\\sigma_b^2 = 1.0\\,\\text{K}^2$, and $R$ diagonal with $\\sigma_y^2 = 0.25\\,\\text{K}^2$.\n- Case 2 (short-range exponential): exponential $B$ with $L_z = 0.5\\,\\text{km}$, $\\sigma_b^2 = 1.0\\,\\text{K}^2$, and $R$ diagonal with $\\sigma_y^2 = 0.25\\,\\text{K}^2$.\n- Case 3 (Matérn moderate smoothness): Matérn $B$ with $\\nu = 1.5$, $L_z = 1.5\\,\\text{km}$, $\\sigma_b^2 = 1.0\\,\\text{K}^2$, and $R$ diagonal with $\\sigma_y^2 = 0.25\\,\\text{K}^2$.\n- Case 4 (Matérn higher smoothness and longer correlation): Matérn $B$ with $\\nu = 3.0$, $L_z = 2.0\\,\\text{km}$, $\\sigma_b^2 = 1.0\\,\\text{K}^2$, and $R$ diagonal with $\\sigma_y^2 = 0.25\\,\\text{K}^2$.\n- Case 5 (Matérn with large observation error): Matérn $B$ with $\\nu = 1.5$, $L_z = 1.5\\,\\text{km}$, $\\sigma_b^2 = 1.0\\,\\text{K}^2$, and $R$ diagonal with $\\sigma_y^2 = 4.0\\,\\text{K}^2$.\n\nYour program must:\n- Implement the derivation-derived formula for $A$ using $B$, $K$, and $R$.\n- Compute the median effective vertical resolution width in kilometers for each of the five cases, as defined above.\n- Express the final numerical answers in kilometers, rounded to three decimal places.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[w_1,w_2,w_3,w_4,w_5]$), where each $w_k$ is the median width for case $k$ in kilometers.\n\nNo user input or external files are allowed; all constants and parameters are as specified. Angles do not appear and therefore no angle unit is required. Percentages do not appear and therefore no percentage formatting is required. The problem focuses on purely mathematical and algorithmic derivations consistent with inverse problems and data assimilation for satellite infrared radiance data.",
            "solution": "The starting point is the linear-Gaussian data assimilation framework, where the state $x \\in \\mathbb{R}^n$ and observations $y \\in \\mathbb{R}^m$ satisfy $y = K x + \\varepsilon$, with $\\varepsilon \\sim \\mathcal{N}(0, R)$. The background state $x_b$ is a prior estimate with error $e_b = x - x_b \\sim \\mathcal{N}(0, B)$. Under these assumptions, the analysis $x_a$ that minimizes the expected squared estimation error is the linear minimum-variance estimator, obtained by completing the square in the joint Gaussian posterior or, equivalently, by standard Kalman filter analysis with linear observation operator.\n\nThe analysis increment is given by\n$$x_a - x_b = G \\left(y - K x_b\\right),$$\nwhere the gain $G \\in \\mathbb{R}^{n \\times m}$ is\n$$G = B K^\\top \\left(K B K^\\top + R\\right)^{-1}.$$\nThis expression arises from minimizing the quadratic form $(x - x_b)^\\top B^{-1} (x - x_b) + (y - K x)^\\top R^{-1} (y - K x)$ with respect to $x$, leading to the normal equations $(B^{-1} + K^\\top R^{-1} K) x = B^{-1} x_b + K^\\top R^{-1} y$, and to the solution $x_a = x_b + G (y - K x_b)$ after algebraic manipulation and application of the matrix inversion lemma.\n\nThe sensitivity of the analysis $x_a$ to the true state $x$ is captured by the averaging kernel matrix $A \\in \\mathbb{R}^{n \\times n}$, defined as the Jacobian $\\frac{\\partial x_a}{\\partial x}$. Differentiating $x_a$ with respect to $x$ in the linear setting $y = K x + \\varepsilon$ yields\n$$\\frac{\\partial x_a}{\\partial x} = G K.$$\nCombined with the expression for $G$, the averaging kernel is\n$$A = B K^\\top \\left(K B K^\\top + R\\right)^{-1} K.$$\nThis matrix is dimensionless under the chosen normalization for $K$, and encodes the vertical smoothing inherent to the analysis: the $i$-th row of $A$ gives the weights by which the true profile components contribute to the analysis at level $z_i$.\n\nTo quantify vertical resolution, we require a scalar width metric per level that reflects how concentrated each averaging kernel row is around its center. Because averaging kernel rows can have oscillatory or sign-changing structures, we form nonnegative weights from the absolute values of the row to avoid cancellations:\n- For the $i$-th row $a_i \\in \\mathbb{R}^n$, define $u_{i,p} = \\frac{|a_{i,p}|}{\\sum_{q=0}^{n-1} |a_{i,q}|}$.\n- The center of mass is $\\bar{z}_i = \\sum_{p=0}^{n-1} u_{i,p} z_p$.\n- The second central moment is $M_i = \\sum_{p=0}^{n-1} u_{i,p} (z_p - \\bar{z}_i)^2$.\n- The effective width is $W_i = 2 \\sqrt{M_i}$ in kilometers. The factor of $2$ corresponds to a two-standard-deviation width, which is a robust measure that does not assume Gaussianity yet scales with the spread.\n\nWe exclude levels with $\\sum_p |a_{i,p}| \\le 10^{-12}$ (numerically negligible sensitivity) from summary statistics. If no levels remain, the metric defaults to the full grid span $z_{n-1} - z_0$.\n\nNumerical construction details:\n- Vertical grid $z_i$ is uniform from $0\\,\\text{km}$ to $15\\,\\text{km}$ with $n = 31$ and $\\Delta z = 0.5\\,\\text{km}$.\n- Weighting functions $w_j(z)$ are Gaussian with centers $z_{c,j} \\in \\{1, 3, 5, 7, 9, 12\\}\\,\\text{km}$ and spread $\\sigma_w = 0.8\\,\\text{km}$. Each row $K_{j,\\cdot}$ is normalized to integrate to unity via $K_{j,i} = \\frac{w_j(z_i)\\,\\Delta z}{\\sum_p w_j(z_p)\\,\\Delta z}$.\n- The background covariance $B$ is built using either the exponential kernel $B_{ij} = \\sigma_b^2 \\exp\\left(-\\frac{|z_i - z_j|}{L_z}\\right)$ (stationary, positive definite) or the Matérn kernel\n$$B_{ij} = \\begin{cases}\n\\sigma_b^2,  i = j, \\\\\n\\sigma_b^2 \\dfrac{2^{1-\\nu}}{\\Gamma(\\nu)} \\left(\\dfrac{\\sqrt{2\\nu}\\,|z_i - z_j|}{L_z}\\right)^\\nu K_\\nu\\left(\\dfrac{\\sqrt{2\\nu}\\,|z_i - z_j|}{L_z}\\right),  i \\ne j,\n\\end{cases}$$\nwhich is also stationary and positive definite for $\\nu  0$. The diagonal $B_{ii}=\\sigma_b^2$ matches the correct variance at zero separation (the Matérn limit).\n- Observation error covariance is $R = \\operatorname{diag}(\\sigma_y^2, \\dots, \\sigma_y^2)$.\n\nAlgorithmic steps for each test case:\n1. Construct $K$ on the specified grid.\n2. Construct $B$ using the chosen kernel type and parameters $(\\sigma_b^2, L_z, \\nu)$.\n3. Construct $R$ using $\\sigma_y^2$.\n4. Compute $S = K B K^\\top + R$, then solve $S X = K$ for $X$.\n5. Compute $A = B K^\\top X$.\n6. For each level $i$, compute $W_i$ using the absolute-normalized row weights and the second central moment; exclude negligible-sensitivity levels.\n7. Report the median of $\\{W_i\\}$ in kilometers, rounded to three decimal places.\n\nQualitative expectations:\n- Larger correlation length $L_z$ in $B$ broadens background correlations, typically increasing the width of averaging kernels and thus reducing vertical resolution (larger $W_i$).\n- Higher smoothness $\\nu$ in the Matérn kernel yields smoother correlations, often broadening averaging kernels compared to exponential for the same $L_z$.\n- Larger observation error variance $\\sigma_y^2$ increases reliance on the background, which tends to broaden $A$ and increase the width metric, again indicating reduced resolution.\n\nThe program implements these computations precisely and outputs a single line containing five comma-separated floats in kilometers, one per test case, enclosed in square brackets.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import kv as besselk, gamma\n\ndef build_vertical_grid(n=31, zmin=0.0, zmax=15.0):\n    z = np.linspace(zmin, zmax, n)\n    dz = z[1] - z[0]\n    return z, dz\n\ndef build_K(z, centers, sigma_w, dz):\n    m = len(centers)\n    n = len(z)\n    K = np.zeros((m, n))\n    for j, zc in enumerate(centers):\n        w = np.exp(-0.5 * ((z - zc) / sigma_w) ** 2)\n        w_int = w * dz\n        s = np.sum(w_int)\n        if s = 0.0:\n            # Avoid division by zero; unlikely with positive Gaussian\n            K[j, :] = 0.0\n        else:\n            K[j, :] = w_int / s\n    return K\n\ndef build_B_exponential(z, sigma_b2, Lz):\n    # Exponential kernel: B_ij = sigma_b2 * exp(-|z_i - z_j| / Lz)\n    D = np.abs(z[:, None] - z[None, :])\n    B = sigma_b2 * np.exp(-D / Lz)\n    return B\n\ndef build_B_matern(z, sigma_b2, Lz, nu):\n    # Matérn kernel:\n    # For i != j:\n    # B_ij = sigma_b2 * (2^(1-nu) / Gamma(nu)) * (sqrt(2nu) h / Lz)^nu * K_nu(sqrt(2nu) h / Lz)\n    # For i == j: B_ii = sigma_b2\n    D = np.abs(z[:, None] - z[None, :])\n    B = np.zeros_like(D)\n    # Diagonal\n    np.fill_diagonal(B, sigma_b2)\n    # Off-diagonal\n    mask = D  0\n    h = D[mask]\n    arg = np.sqrt(2.0 * nu) * h / Lz\n    const = sigma_b2 * (2.0 ** (1.0 - nu)) / gamma(nu)\n    # besselk(nu, arg) is modified Bessel function of the second kind\n    B[mask] = const * (arg ** nu) * besselk(nu, arg)\n    return B\n\ndef build_R(m, sigma_y2):\n    return np.eye(m) * sigma_y2\n\ndef averaging_kernel(B, K, R):\n    # Compute A = B K^T (K B K^T + R)^{-1} K\n    S = K @ B @ K.T + R\n    # Solve S X = K for X\n    X = np.linalg.solve(S, K)\n    A = B @ K.T @ X\n    return A\n\ndef effective_resolution(A, z, eps=1e-12):\n    widths = []\n    for i in range(A.shape[0]):\n        row = A[i, :]\n        w = np.abs(row)\n        s = np.sum(w)\n        if s = eps:\n            continue\n        wn = w / s\n        zbar = np.sum(wn * z)\n        var = np.sum(wn * (z - zbar) ** 2)\n        width = 2.0 * np.sqrt(var)\n        widths.append(width)\n    if len(widths) == 0:\n        return float(z[-1] - z[0])\n    return float(np.median(np.array(widths)))\n\ndef run_case(case_type, params, z, dz, K):\n    sigma_b2 = params[\"sigma_b2\"]\n    sigma_y2 = params[\"sigma_y2\"]\n    if case_type == \"exp\":\n        Lz = params[\"Lz\"]\n        B = build_B_exponential(z, sigma_b2, Lz)\n    elif case_type == \"matern\":\n        Lz = params[\"Lz\"]\n        nu = params[\"nu\"]\n        B = build_B_matern(z, sigma_b2, Lz, nu)\n    else:\n        raise ValueError(\"Unknown case type\")\n    R = build_R(K.shape[0], sigma_y2)\n    A = averaging_kernel(B, K, R)\n    width = effective_resolution(A, z)\n    return width\n\ndef solve():\n    # Grid and weighting functions setup\n    z, dz = build_vertical_grid(n=31, zmin=0.0, zmax=15.0)\n    centers = [1.0, 3.0, 5.0, 7.0, 9.0, 12.0]\n    sigma_w = 0.8\n    K = build_K(z, centers, sigma_w, dz)\n\n    # Define test cases\n    test_cases = [\n        (\"exp\", {\"Lz\": 1.5, \"sigma_b2\": 1.0, \"sigma_y2\": 0.25}),          # Case 1\n        (\"exp\", {\"Lz\": 0.5, \"sigma_b2\": 1.0, \"sigma_y2\": 0.25}),          # Case 2\n        (\"matern\", {\"Lz\": 1.5, \"nu\": 1.5, \"sigma_b2\": 1.0, \"sigma_y2\": 0.25}),  # Case 3\n        (\"matern\", {\"Lz\": 2.0, \"nu\": 3.0, \"sigma_b2\": 1.0, \"sigma_y2\": 0.25}),  # Case 4\n        (\"matern\", {\"Lz\": 1.5, \"nu\": 1.5, \"sigma_b2\": 1.0, \"sigma_y2\": 4.0}),   # Case 5\n    ]\n\n    results = []\n    for case_type, params in test_cases:\n        width = run_case(case_type, params, z, dz, K)\n        results.append(f\"{width:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Real-world satellite instruments are subject to systematic biases, which, if ignored, can severely corrupt the atmospheric analysis. This advanced practice introduces Variational Bias Correction (VarBC), a powerful technique used in operational systems to estimate and remove bias as part of the assimilation process itself . You will augment the standard control vector with bias parameters and, critically, learn to diagnose the system's observability by analyzing the null space of the augmented Jacobian for degeneracies between the atmospheric state and the bias correction.",
            "id": "3365090",
            "problem": "Consider a linearized assimilation of satellite radiance data under the framework of inverse problems and data assimilation. The radiance observation for each scan indexed by $i$ is modeled by the linearized observation operator applied to a state increment and an additive, channel-dependent variational bias correction. Specifically, let the state increment be $x \\in \\mathbb{R}^n$, and let there be $C$ radiance channels. For observation $i$ belonging to channel $c_i \\in \\{0,1,\\dots,C-1\\}$ with scan angle $\\theta_i$ (in radians), the channel-dependent bias is modeled as $\\beta_{c}(\\theta_i) = \\gamma_{0,c} + \\gamma_{1,c} \\theta_i$, where $\\gamma_{0,c}, \\gamma_{1,c}$ are bias parameters to be estimated for channel $c$. Collect the augmented control vector as $z = [x^\\top, \\gamma_{0,0}, \\dots, \\gamma_{0,C-1}, \\gamma_{1,0}, \\dots, \\gamma_{1,C-1}]^\\top \\in \\mathbb{R}^{n+2C}$.\n\nDefine the linearized observation operator matrix $A \\in \\mathbb{R}^{m \\times n}$ such that the linearized radiance prediction is $A x$ for $m$ observations. Define the channel selector matrix $M_0 \\in \\mathbb{R}^{m \\times C}$ by $(M_0)_{i,c} = 1$ if $c_i = c$ and $0$ otherwise, and the scan-angle predictor matrix $M_1 \\in \\mathbb{R}^{m \\times C}$ by $(M_1)_{i,c} = \\theta_i$ if $c_i = c$ and $0$ otherwise. The augmented Jacobian is the block matrix $K_{\\mathrm{aug}} = [A \\;|\\; M_0 \\;|\\; M_1] \\in \\mathbb{R}^{m \\times (n+2C)}$.\n\nStarting from the definitions above and the principle of Three-Dimensional Variational assimilation (3D-Var), in which the analysis increment minimizes a quadratic form composed of background and observation misfit terms, your program must:\n- Assemble $K_{\\mathrm{aug}}$ for each test case from the provided $A$, $\\theta_i$, and channel assignments $c_i$.\n- Compute the numerical null space of $K_{\\mathrm{aug}}$ using Singular Value Decomposition (SVD) and determine its dimension by counting singular values less than or equal to a fixed tolerance. Use a tolerance of $\\varepsilon = 10^{-12}$ applied to the singular values. Report the null space dimension as an integer.\n- Analyze degeneracy between $\\gamma$ and state increments by inspecting the null space. Compute two boolean degeneracy indicators:\n  1. A pure-bias degeneracy indicator, defined as true if there exists a null-space vector $v$ partitioned as $v = [v_x^\\top, v_\\gamma^\\top]^\\top$ with $\\|v_x\\|_2 \\leq \\eta \\|v_\\gamma\\|_2$ and $\\|v_\\gamma\\|_2  0$, where $\\eta = 10^{-6}$.\n  2. A mixed degeneracy indicator, defined as true if there exists a null-space vector $v = [v_x^\\top, v_\\gamma^\\top]^\\top$ with $\\|v_x\\|_2  0$ and $\\|v_\\gamma\\|_2  0$.\n- Implement variational bias correction by computing the analysis increments $z^\\ast$ that minimize the 3D-Var quadratic objective, under diagonal background covariance and diagonal observation error covariance, and report the estimated bias parameters $(\\gamma_{0,c})_{c=0}^{C-1}$ and $(\\gamma_{1,c})_{c=0}^{C-1}$ for each test case. Angles must be treated in radians. Use the specified units and numerical values below.\n\nYou must adopt the following scientifically sound, fixed test suite, which includes a general case, a boundary case with uninformative scan angles, and a case that induces degeneracy between state and bias slopes:\n- Test Case $1$ (\"happy path\"):\n  - Dimensions: $n = 2$, $C = 2$, $m = 6$.\n  - Channel assignment: $c = [0, 0, 0, 1, 1, 1]$.\n  - Scan angles (in radians): $\\theta = [0.0, 0.5, 1.0, 0.0, 0.5, 1.0]$.\n  - Linearized operator columns $A = [a_1 \\; a_2]$ with\n    $a_1 = [2, -1, 0, 1, -2, 3]^\\top$, $a_2 = [1, 1, -1, -1, 2, 0]^\\top$.\n  - True state and bias used to synthesize observations: $x^\\star = [0.5, -0.7]^\\top$, $\\gamma_0^\\star = [0.1, -0.2]^\\top$, $\\gamma_1^\\star = [0.05, 0.07]^\\top$.\n  - Background covariances: $\\sigma_x^2 = 1.0$ for each state component, $\\sigma_{\\gamma_0}^2 = 0.5$ for each channel, $\\sigma_{\\gamma_1}^2 = 0.5$ for each channel.\n  - Observation error covariance: $\\sigma_{\\mathrm{obs}}^2 = 0.01$ for each observation.\n  - Background is zero: $x_b = [0, 0]^\\top$, $\\gamma_{0,b} = [0, 0]^\\top$, $\\gamma_{1,b} = [0, 0]^\\top$.\n  - Observations: $y = A x^\\star + M_0 \\gamma_0^\\star + M_1 \\gamma_1^\\star$.\n- Test Case $2$ (\"angle-degenerate boundary\"):\n  - Same $n$, $C$, $m$ and channel assignment $c$ as Test Case $1$.\n  - Scan angles (in radians): $\\theta = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]$.\n  - Linearized operator $A$ identical to Test Case $1$.\n  - True state and bias used to synthesize observations: $x^\\star = [0.5, -0.7]^\\top$, $\\gamma_0^\\star = [0.1, -0.2]^\\top$, $\\gamma_1^\\star = [0.05, 0.07]^\\top$.\n  - Background covariances: $\\sigma_x^2 = 1.0$, $\\sigma_{\\gamma_0}^2 = 0.5$, $\\sigma_{\\gamma_1}^2 = 0.5$.\n  - Observation error covariance: $\\sigma_{\\mathrm{obs}}^2 = 0.01$.\n  - Background is zero: $x_b = [0, 0]^\\top$, $\\gamma_{0,b} = [0, 0]^\\top$, $\\gamma_{1,b} = [0, 0]^\\top$.\n  - Observations: $y = A x^\\star + M_0 \\gamma_0^\\star + M_1 \\gamma_1^\\star$ (note that $M_1$ becomes the zero matrix in this boundary case).\n- Test Case $3$ (\"state-bias-slope collinearity\"):\n  - Same $n$, $C$, $m$ and channel assignment $c$ as Test Case $1$.\n  - Scan angles (in radians): $\\theta = [0.0, 0.5, 1.0, 0.0, 0.5, 1.0]$.\n  - Set the linearized operator equal to the scan-angle predictor to induce collinearity: $A := M_1$ built from the given $\\theta$ and $c$.\n  - True state and bias used to synthesize observations: $x^\\star = [0.3, -0.4]^\\top$, $\\gamma_0^\\star = [-0.1, 0.2]^\\top$, $\\gamma_1^\\star = [0.05, 0.04]^\\top$.\n  - Background covariances: $\\sigma_x^2 = 1.0$, $\\sigma_{\\gamma_0}^2 = 0.5$, $\\sigma_{\\gamma_1}^2 = 0.5$.\n  - Observation error covariance: $\\sigma_{\\mathrm{obs}}^2 = 0.01$.\n  - Background is zero: $x_b = [0, 0]^\\top$, $\\gamma_{0,b} = [0, 0]^\\top$, $\\gamma_{1,b} = [0, 0]^\\top$.\n  - Observations: $y = A x^\\star + M_0 \\gamma_0^\\star + M_1 \\gamma_1^\\star$.\n\nYour program must carry out the computations precisely as described and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sub-list of the form $[\\text{null\\_dim}, \\text{pure\\_deg\\_flag}, \\text{mixed\\_deg\\_flag}, \\gamma_{0,0}^{\\ast}, \\gamma_{1,0}^{\\ast}, \\gamma_{0,1}^{\\ast}, \\gamma_{1,1}^{\\ast}]$. The booleans must be represented as $True$ or $False$, and the floating-point values must be raw numbers. No spaces are permitted in the printed list. Angles must be treated in radians throughout.",
            "solution": "The user has provided a well-defined problem in the domain of geophysical data assimilation, specifically focusing on Three-Dimensional Variational (3D-Var) assimilation of satellite radiances with an integrated variational bias correction (VarBC) scheme. The problem requires both an analysis of the system's observability and the computation of an optimal state estimate.\n\n**1. Assimilation Model and Augmented Jacobian**\n\nThe problem defines an augmented state vector $z \\in \\mathbb{R}^{n+2C}$ that includes the atmospheric state increment $x \\in \\mathbb{R}^n$ and bias correction parameters for $C$ channels. The bias for channel $c$ is modeled as a linear function of the scan angle $\\theta$, $\\beta_c(\\theta) = \\gamma_{0,c} + \\gamma_{1,c} \\theta$. The full control vector is given by:\n$$ z = [x^\\top, \\gamma_0^\\top, \\gamma_1^\\top]^\\top = [x_0, \\dots, x_{n-1}, \\gamma_{0,0}, \\dots, \\gamma_{0,C-1}, \\gamma_{1,0}, \\dots, \\gamma_{1,C-1}]^\\top $$\nThe forward model that predicts the observation increments from the state increments is linearized. For $m$ observations, the model is expressed as:\n$$ y_{\\text{model}} = K_{\\mathrm{aug}} z $$\nwhere $K_{\\mathrm{aug}} \\in \\mathbb{R}^{m \\times (n+2C)}$ is the augmented Jacobian matrix. This matrix is constructed by concatenating the Jacobians with respect to each component of $z$.\nThe Jacobian with respect to the state $x$ is the linearized observation operator $A \\in \\mathbb{R}^{m \\times n}$. The Jacobian with respect to the bias offset parameters $\\gamma_0$ is the channel selector matrix $M_0 \\in \\mathbb{R}^{m \\times C}$. Its elements are $(M_0)_{i,c} = 1$ if observation $i$ is from channel $c$ ($c_i=c$), and $0$ otherwise. The Jacobian with respect to the scan-angle-dependent bias parameters $\\gamma_1$ is the scan-angle predictor matrix $M_1 \\in \\mathbb{R}^{m \\times C}$. Its elements are $(M_1)_{i,c} = \\theta_i$ if observation $i$ is from channel $c$, and $0$ otherwise.\nThe augmented Jacobian is the block matrix:\n$$ K_{\\mathrm{aug}} = [A \\;|\\; M_0 \\;|\\; M_1] $$\n\n**2. Observability Analysis via Null Space**\n\nThe null space of $K_{\\mathrm{aug}}$, denoted $\\mathcal{N}(K_{\\mathrm{aug}})$, contains all non-zero state increments $z$ that produce a zero observation increment, i.e., $K_{\\mathrm{aug}} z = 0$. The existence of a non-trivial null space indicates that the observing system cannot distinguish certain combinations of state and bias parameter increments, leading to an ill-posed inverse problem. The dimension of the null space is determined by counting the number of singular values of $K_{\\mathrm{aug}}$ that are zero (or, numerically, less than a small tolerance $\\varepsilon = 10^{-12}$). The singular value decomposition (SVD) of $K_{\\mathrm{aug}} = U S V^\\top$ provides an orthonormal basis for the null space, given by the columns of $V$ (or rows of $V^\\top$) corresponding to zero singular values.\n\nWe analyze the structure of the null space vectors $v \\in \\mathcal{N}(K_{\\mathrm{aug}})$ by partitioning them into state and bias components, $v = [v_x^\\top, v_\\gamma^\\top]^\\top$.\n- **Pure-bias degeneracy**: This occurs if there exists a null space vector that predominantly affects bias parameters, meaning the observations are insensitive to a particular combination of bias parameters alone. The condition is defined as the existence of a vector $v \\in \\mathcal{N}(K_{\\mathrm{aug}})$ such that $\\|v_x\\|_2 \\le \\eta \\|v_\\gamma\\|_2$ and $\\|v_\\gamma\\|_2  0$ for a small tolerance $\\eta = 10^{-6}$.\n- **Mixed degeneracy**: This occurs if there is ambiguity between the state and bias parameters, meaning a change in the state vector can be compensated by a change in bias parameters, yielding no net change in the observations. The condition is defined as the existence of a vector $v \\in \\mathcal{N}(K_{\\mathrm{aug}})$ with both non-zero state and bias components, i.e., $\\|v_x\\|_2  0$ and $\\|v_\\gamma\\|_2  0$.\n\nFor each basis vector of the numerically computed null space, we check these two conditions. The respective flags are set to true if at least one basis vector satisfies the condition.\n\n**3. 3D-Var Solution**\n\nThe 3D-Var analysis increment $z^*$ is found by minimizing a quadratic cost function $J(z)$. This function balances the misfit to a background estimate $z_b$ against the misfit to the observations $y$, weighted by their respective error covariances, $B$ and $R$.\n$$ J(z) = \\frac{1}{2} (z - z_b)^\\top B^{-1} (z - z_b) + \\frac{1}{2} (K_{\\mathrm{aug}} z - (y - K_{\\mathrm{aug}}z_b))^\\top R^{-1} (K_{\\mathrm{aug}} z - (y - K_{\\mathrm{aug}}z_b)) $$\nGiven that the background state is zero ($z_b=0$), the expression simplifies to:\n$$ J(z) = \\frac{1}{2} z^\\top B^{-1} z + \\frac{1}{2} (K_{\\mathrm{aug}} z - y)^\\top R^{-1} (K_{\\mathrm{aug}} z - y) $$\nwhere $y$ is the observation vector. The minimum of this convex function is found where the gradient with respect to $z$ is zero:\n$$ \\nabla_z J(z) = B^{-1} z + K_{\\mathrm{aug}}^\\top R^{-1} (K_{\\mathrm{aug}} z - y) = 0 $$\nRearranging gives a linear system for the analysis increment $z^*$:\n$$ (B^{-1} + K_{\\mathrm{aug}}^\\top R^{-1} K_{\\mathrm{aug}}) z^* = K_{\\mathrm{aug}}^\\top R^{-1} y $$\nThis is a standard linear system of the form $H z^* = g$, where $H = B^{-1} + K_{\\mathrm{aug}}^\\top R^{-1} K_{\\mathrm{aug}}$ is the Hessian of the cost function, and $g = K_{\\mathrm{aug}}^\\top R^{-1} y$ is the gradient term. The background covariance $B$ and observation error covariance $R$ are given as diagonal. $B$ is composed of variances for state variables ($\\sigma_x^2$), bias offsets ($\\sigma_{\\gamma_0}^2$), and bias slopes ($\\sigma_{\\gamma_1}^2$). $R$ is composed of observation error variances ($\\sigma_{\\text{obs}}^2$). The background term $B^{-1}$ acts as a regularization, ensuring that the Hessian $H$ is positive definite and the system has a unique solution, even if $K_{\\mathrm{aug}}$ is rank-deficient.\n\n**4. Computational Steps for Each Test Case**\nFor each test case provided:\n1.  The parameters $n, C, m$, channel assignments $c$, and scan angles $\\theta$ are used to construct the matrices $M_0$ and $M_1$. The matrix $A$ is either given directly or constructed as specified (e.g., $A := M_1$ in Case 3). These are combined to form $K_{\\mathrm{aug}}$.\n2.  The SVD of $K_{\\mathrm{aug}}$ is computed. The dimension of the null space (`null_dim`) is the number of singular values less than or equal to $\\varepsilon = 10^{-12}$. The corresponding rows from $V^\\top$ form the basis for the null space.\n3.  The null space basis vectors are analyzed to determine the boolean flags `pure_deg_flag` and `mixed_deg_flag` according to their definitions.\n4.  The diagonal covariance matrices $B^{-1}$ and $R^{-1}$ are constructed from the given variances.\n5.  The synthetic observation vector $y$ is computed using the provided \"true\" state and bias parameters: $y = A x^\\star + M_0 \\gamma_0^\\star + M_1 \\gamma_1^\\star$.\n6.  The Hessian $H$ and gradient vector $g$ are assembled, and the linear system $H z^* = g$ is solved to find the analysis increment $z^*$.\n7.  The estimated bias parameters $(\\gamma_{0,c}^*)_{c=0}^{C-1}$ and $(\\gamma_{1,c}^*)_{c=0}^{C-1}$ are extracted from the solution vector $z^*$ and reported in the specified order: $\\gamma_{0,0}^*, \\gamma_{1,0}^*, \\gamma_{0,1}^*, \\gamma_{1,1}^*$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the data assimilation test cases and print the results.\n    \"\"\"\n\n    def solve_case(params):\n        \"\"\"\n        Processes a single test case for satellite radiance assimilation.\n\n        Args:\n            params (tuple): A tuple containing all parameters for the test case.\n\n        Returns:\n            list: A list containing the results for the test case:\n                  [null_dim, pure_deg_flag, mixed_deg_flag, g00*, g10*, g01*, g11*]\n        \"\"\"\n        n, C, m, c_assign, theta, A_def, xt, g0t, g1t, sigmas = params\n\n        # 1. Assemble the augmented Jacobian K_aug\n        M0 = np.zeros((m, C))\n        for i in range(m):\n            M0[i, c_assign[i]] = 1.0\n        \n        M1 = np.zeros((m, C))\n        for i in range(m):\n            M1[i, c_assign[i]] = theta[i]\n\n        if isinstance(A_def, str) and A_def == \"M1\":\n            A = M1\n        else:\n            A = np.array(A_def, dtype=float)\n\n        K_aug = np.hstack([A, M0, M1])\n\n        # 2. Null space analysis using Singular Value Decomposition (SVD)\n        _U, s, Vt = np.linalg.svd(K_aug)\n        svd_tol = 1e-12\n        null_space_rows = Vt[s = svd_tol, :]\n        null_dim = null_space_rows.shape[0]\n\n        pure_deg_flag = False\n        mixed_deg_flag = False\n        eta = 1e-6\n        norm_tol = 1e-9  # Tolerance for checking if a norm is effectively  0\n\n        if null_dim  0:\n            for v_row in null_space_rows:\n                v_x = v_row[:n]\n                v_gamma = v_row[n:]\n                norm_vx = np.linalg.norm(v_x)\n                norm_vgamma = np.linalg.norm(v_gamma)\n\n                # Check for pure-bias degeneracy\n                if norm_vgamma  norm_tol:\n                    if norm_vx = eta * norm_vgamma:\n                        pure_deg_flag = True\n                \n                # Check for mixed degeneracy\n                if norm_vx  norm_tol and norm_vgamma  norm_tol:\n                    mixed_deg_flag = True\n        \n        # 3. 3D-Var solution\n        sigma_x2, sigma_g0_2, sigma_g1_2, sigma_obs_2 = sigmas\n        B_inv_diag = np.concatenate([\n            np.full(n, 1.0 / sigma_x2),\n            np.full(C, 1.0 / sigma_g0_2),\n            np.full(C, 1.0 / sigma_g1_2)\n        ])\n        B_inv = np.diag(B_inv_diag)\n        R_inv_val = 1.0 / sigma_obs_2\n\n        # Synthesize observations y from true state\n        xt_vec = np.array(xt)\n        g0t_vec = np.array(g0t)\n        g1t_vec = np.array(g1t)\n        y = A @ xt_vec + M0 @ g0t_vec + M1 @ g1t_vec\n\n        # Form and solve the linear system for the analysis increment z*\n        Hessian = B_inv + (K_aug.T @ K_aug) * R_inv_val\n        g = (K_aug.T @ y) * R_inv_val\n        \n        z_star = np.linalg.solve(Hessian, g)\n\n        # 4. Extract and order results for output\n        # Control vector z ordering: [x_0, ..., x_{n-1}, g0_0, ..., g0_{C-1}, g1_0, ..., g1_{C-1}]\n        # For n=2, C=2: z = [x0, x1, g00, g01, g10, g11] - indices 0, 1, 2, 3, 4, 5\n        # Required output order: g0_0*, g1_0*, g0_1*, g1_1*\n        # Corresponds to z_star indices: 2, 4, 3, 5\n        gamma_results = [z_star[n], z_star[n + C], z_star[n + 1], z_star[n + C + 1]]\n        \n        return [null_dim, pure_deg_flag, mixed_deg_flag] + gamma_results\n\n    # Define the test suite\n    A_matrix = [[2, 1], [-1, 1], [0, -1], [1, -1], [-2, 2], [3, 0]]\n    common_params = {\n        'n': 2, 'C': 2, 'm': 6,\n        'c_assign': [0, 0, 0, 1, 1, 1],\n        'sigmas': (1.0, 0.5, 0.5, 0.01) # (sigma_x^2, sigma_g0^2, sigma_g1^2, sigma_obs^2)\n    }\n\n    test_cases = [\n        # Test Case 1: \"happy path\"\n        (\n            common_params['n'], common_params['C'], common_params['m'],\n            common_params['c_assign'],\n            [0.0, 0.5, 1.0, 0.0, 0.5, 1.0],  # theta\n            A_matrix,\n            [0.5, -0.7],  # x_true\n            [0.1, -0.2],  # gamma0_true\n            [0.05, 0.07], # gamma1_true\n            common_params['sigmas']\n        ),\n        # Test Case 2: \"angle-degenerate boundary\"\n        (\n            common_params['n'], common_params['C'], common_params['m'],\n            common_params['c_assign'],\n            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # theta\n            A_matrix,\n            [0.5, -0.7],  # x_true\n            [0.1, -0.2],  # gamma0_true\n            [0.05, 0.07], # gamma1_true\n            common_params['sigmas']\n        ),\n        # Test Case 3: \"state-bias-slope collinearity\"\n        (\n            common_params['n'], common_params['C'], common_params['m'],\n            common_params['c_assign'],\n            [0.0, 0.5, 1.0, 0.0, 0.5, 1.0],  # theta\n            \"M1\",      # A is dynamically set to M1\n            [0.3, -0.4],  # x_true\n            [-0.1, 0.2],  # gamma0_true\n            [0.05, 0.04], # gamma1_true\n            common_params['sigmas']\n        ),\n    ]\n\n    # Run all test cases\n    all_results = []\n    for case in test_cases:\n        all_results.append(solve_case(case))\n        \n    # Format the final output string exactly as required, removing all spaces\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}