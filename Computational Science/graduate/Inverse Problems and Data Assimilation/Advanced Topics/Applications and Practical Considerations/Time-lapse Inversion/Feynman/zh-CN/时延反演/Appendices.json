{
    "hands_on_practices": [
        {
            "introduction": "为了找到最能解释我们数据的模型，我们通常需要最小化一个失配泛函。对于时移地球物理学中使用的复杂大规模模型，基于梯度的优化方法是不可或缺的。第一个实践  将挑战你推导出这些方法背后的核心引擎：通过伴随状态法计算的 Fréchet 梯度。掌握这一推导过程将揭示我们如何高效地计算最速下降方向，而无需承担高昂的计算成本，这是现代全波形反演和时移反演的基石。",
            "id": "3427743",
            "problem": "考虑一个在有界开域 $\\Omega \\subset \\mathbb{R}^{3}$ 上、时间区间为 $[0,T]$ 的恒定密度声波传播模型，其在边界 $\\partial \\Omega$ 上具有齐次吸收边界条件。令标量参数场为 $m(\\mathbf{x}) = c(\\mathbf{x})^{-2}$，其中 $c(\\mathbf{x})$ 是波速。给定一个基线参数 $m_{0}(\\mathbf{x})$ 和一个小的时移扰动 $\\delta m(\\mathbf{x})$，对于震源索引 $s = 1,\\dots,N_{s}$，基线正演波场 $u_{0}^{(s)}(\\mathbf{x},t)$ 由以下初值问题定义：\n$$\n\\begin{cases}\nm_{0}(\\mathbf{x}) \\, \\partial_{tt} u_{0}^{(s)}(\\mathbf{x},t) - \\nabla^{2} u_{0}^{(s)}(\\mathbf{x},t) = q^{(s)}(\\mathbf{x},t),  (\\mathbf{x},t) \\in \\Omega \\times (0,T], \\\\\nu_{0}^{(s)}(\\mathbf{x},0) = 0, \\quad \\partial_{t} u_{0}^{(s)}(\\mathbf{x},0) = 0,  \\mathbf{x} \\in \\Omega,\n\\end{cases}\n$$\n其中 $q^{(s)}(\\mathbf{x},t)$ 是支撑在 $\\Omega$ 内部的已知震源项。线性化（玻恩）增量正演波场 $u_{1}^{(s)}(\\mathbf{x},t)$ 定义为以下问题的解：\n$$\n\\begin{cases}\nm_{0}(\\mathbf{x}) \\, \\partial_{tt} u_{1}^{(s)}(\\mathbf{x},t) - \\nabla^{2} u_{1}^{(s)}(\\mathbf{x},t) = -\\delta m(\\mathbf{x}) \\, \\partial_{tt} u_{0}^{(s)}(\\mathbf{x},t),  (\\mathbf{x},t) \\in \\Omega \\times (0,T], \\\\\nu_{1}^{(s)}(\\mathbf{x},0) = 0, \\quad \\partial_{t} u_{1}^{(s)}(\\mathbf{x},0) = 0,  \\mathbf{x} \\in \\Omega.\n\\end{cases}\n$$\n令接收点采样算子 $P$ 将波场映射到每个震源 $s$ 的接收点位置 $\\{\\mathbf{r}_{j}^{(s)}\\}_{j=1}^{N_{r}^{(s)}}$ 处的值，使得 $(P u)(\\mathbf{r}_{j}^{(s)},t) = u(\\mathbf{r}_{j}^{(s)},t)$。令震源 $s$ 的观测时移数据差为 $\\delta d_{\\mathrm{obs}}^{(s)}(\\mathbf{r}_{j}^{(s)},t)$，并令 $W$ 是一个对称正定加权算子，通过标量 $\\{w_{j}^{(s)} > 0\\}$ 逐点作用于接收点。考虑最小二乘不匹配泛函\n$$\nJ(\\delta m) = \\frac{1}{2} \\sum_{s=1}^{N_{s}} \\int_{0}^{T} \\sum_{j=1}^{N_{r}^{(s)}} w_{j}^{(s)} \\left( u_{1}^{(s)}(\\mathbf{r}_{j}^{(s)},t) - \\delta d_{\\mathrm{obs}}^{(s)}(\\mathbf{r}_{j}^{(s)},t) \\right)^{2} \\, dt.\n$$\n仅使用伴随状态法和偏微分方程变分法的基本原理，推导 $J$ 关于 $\\delta m(\\mathbf{x})$ 的 Fréchet 梯度。您的推导必须从所述的控制方程、初始条件和 $J(\\delta m)$ 的定义出发，并使用分部积分法和互易性来消除波场的变分，代之以伴随场。证明一旦基线正演波场 $u_{0}^{(s)}$ 生成后，该计算不需要重新计算任何 $u_{0}^{(s)}$，并将最终梯度表示为适当定义的正演扰动场和伴随扰动场之间的时间内积。将最终答案以 $\\nabla J(\\delta m)(\\mathbf{x})$ 的单个闭式解析表达式的形式给出。不需要进行数值计算，最终表达式中也不应包含任何单位。",
            "solution": "经检查，该问题是有效的。这是一个反演问题领域的良态、有科学依据的问题，具体要求使用伴随状态法推导时移声学反演问题的 Fréchet 梯度。其设定是自洽、一致的，并使用了标准模型和技术。\n\n目标是推导最小二乘泛函 $J(\\delta m)$ 关于时移模型扰动 $\\delta m(\\mathbf{x})$ 的 Fréchet 梯度。该梯度记为 $\\nabla J(\\delta m)$，是与 $\\delta m$ 处于同一空间的函数，并通过 Fréchet 导数定义。$J$ 在 $\\delta m$ 处沿任意方向 $h(\\mathbf{x})$ 的方向导数由内积给出：\n$$ \\delta J[\\delta m; h] = \\lim_{\\epsilon \\to 0} \\frac{J(\\delta m + \\epsilon h) - J(\\delta m)}{\\epsilon} = \\int_{\\Omega} \\nabla J(\\delta m)(\\mathbf{x}) h(\\mathbf{x}) \\,d\\mathbf{x} $$\n我们的目标是通过处理 $\\delta J$ 的表达式来找到 $\\nabla J(\\delta m)(\\mathbf{x})$ 的表达式。\n\n泛函由下式给出：\n$$ J(\\delta m) = \\frac{1}{2} \\sum_{s=1}^{N_{s}} \\int_{0}^{T} \\sum_{j=1}^{N_{r}^{(s)}} w_{j}^{(s)} \\left( u_{1}^{(s)}[\\delta m](\\mathbf{r}_{j}^{(s)},t) - \\delta d_{\\mathrm{obs}}^{(s)}(\\mathbf{r}_{j}^{(s)},t) \\right)^{2} \\, dt $$\n此处，我们明确地将 $u_{1}^{(s)}$ 对 $\\delta m$ 的依赖性表示为 $u_{1}^{(s)}[\\delta m]$。一个扰动 $\\delta m \\rightarrow \\delta m + \\epsilon h$ 会在线性化波场 $u_1^{(s)}$ 中引起一个扰动。令 $\\dot{u}_1^{(s)}$ 为 $u_1^{(s)}$ 关于 $\\delta m$ 在方向 $h$ 上的方向导数：\n$$ \\dot{u}_1^{(s)} = \\lim_{\\epsilon \\to 0} \\frac{u_{1}^{(s)}[\\delta m + \\epsilon h] - u_{1}^{(s)}[\\delta m]}{\\epsilon} $$\n对 $J$ 求关于 $\\epsilon$ 的导数，并在 $\\epsilon=0$ 处取值，我们得到：\n$$ \\delta J[\\delta m; h] = \\sum_{s=1}^{N_{s}} \\int_{0}^{T} \\sum_{j=1}^{N_{r}^{(s)}} w_{j}^{(s)} \\left( u_{1}^{(s)}(\\mathbf{r}_{j}^{(s)},t) - \\delta d_{\\mathrm{obs}}^{(s)}(\\mathbf{r}_{j}^{(s)},t) \\right) \\dot{u}_{1}^{(s)}(\\mathbf{r}_{j}^{(s)},t) \\, dt $$\n我们可以使用狄拉克δ函数 $\\delta(\\mathbf{x})$ 来表示对接收点的求和，并在域 $\\Omega$ 上积分。让我们将震源 $s$ 在接收点处的数据残差定义为伴随方程的源项：\n$$ q_{\\text{adj}}^{(s)}(\\mathbf{x},t) = \\sum_{j=1}^{N_{r}^{(s)}} w_{j}^{(s)} \\left( u_{1}^{(s)}(\\mathbf{r}_{j}^{(s)},t) - \\delta d_{\\mathrm{obs}}^{(s)}(\\mathbf{r}_{j}^{(s)},t) \\right) \\delta(\\mathbf{x} - \\mathbf{r}_{j}^{(s)}) $$\n根据这个定义，泛函的变分变为：\n$$ \\delta J = \\sum_{s=1}^{N_{s}} \\int_{0}^{T} \\int_{\\Omega} q_{\\text{adj}}^{(s)}(\\mathbf{x},t) \\dot{u}_{1}^{(s)}(\\mathbf{x},t) \\, d\\mathbf{x} \\, dt $$\n这个 $\\delta J$ 的表达式依赖于状态变量的变分 $\\dot{u}_{1}^{(s)}$。伴随状态法允许我们消除这种依赖性，并直接用模型扰动 $h$ 来表示 $\\delta J$。\n\n接下来，我们找出 $\\dot{u}_{1}^{(s)}$ 的控制方程。$u_{1}^{(s)}[\\delta m + \\epsilon h]$ 的方程是：\n$$ m_{0}(\\mathbf{x}) \\, \\partial_{tt} u_{1}^{(s)}[\\delta m + \\epsilon h] - \\nabla^{2} u_{1}^{(s)}[\\delta m + \\epsilon h] = -(\\delta m(\\mathbf{x}) + \\epsilon h(\\mathbf{x})) \\, \\partial_{tt} u_{0}^{(s)}(\\mathbf{x},t) $$\n减去 $u_{1}^{(s)}[\\delta m]$ 的方程，除以 $\\epsilon$，然后取 $\\epsilon \\to 0$ 的极限，得到 $\\dot{u}_{1}^{(s)}$ 的偏微分方程：\n$$\n\\begin{cases}\nm_{0}(\\mathbf{x}) \\, \\partial_{tt} \\dot{u}_{1}^{(s)}(\\mathbf{x},t) - \\nabla^{2} \\dot{u}_{1}^{(s)}(\\mathbf{x},t) = -h(\\mathbf{x}) \\, \\partial_{tt} u_{0}^{(s)}(\\mathbf{x},t),  (\\mathbf{x},t) \\in \\Omega \\times (0,T], \\\\\n\\dot{u}_{1}^{(s)}(\\mathbf{x},0) = 0, \\quad \\partial_{t} \\dot{u}_{1}^{(s)}(\\mathbf{x},0) = 0,  \\mathbf{x} \\in \\Omega.\n\\end{cases}\n$$\n让我们定义正演波算子为 $L_0 = m_0 \\partial_{tt} - \\nabla^2$。$\\dot{u}_{1}^{(s)}$ 的方程为 $L_0 \\dot{u}_{1}^{(s)} = -h \\partial_{tt} u_{0}^{(s)}$。\n\n现在，我们为每个震源 $s$ 引入伴随状态（或对偶场）$v^{(s)}(\\mathbf{x},t)$。我们通过让 $L_0$ 作用于 $v^{(s)}$ 来定义伴随方程，其中伴随源 $q_{\\text{adj}}^{(s)}$ 作为强迫项：\n$$ L_0 v^{(s)} = m_{0}(\\mathbf{x}) \\, \\partial_{tt} v^{(s)}(\\mathbf{x},t) - \\nabla^{2} v^{(s)}(\\mathbf{x},t) = q_{\\text{adj}}^{(s)}(\\mathbf{x},t) $$\n为确保算子是自伴的，我们施加适当的边界和终值条件。我们选择齐次终值时间条件，$v^{(s)}(\\mathbf{x},T) = 0$ 和 $\\partial_t v^{(s)}(\\mathbf{x},T) = 0$。这意味着伴随方程是从 $t=T$ 到 $t=0$ 在时间上向后求解。在 $\\partial\\Omega$ 上的 $v^{(s)}$ 的边界条件选择为与正演问题相同的条件（例如，齐次狄利克雷或诺伊曼条件，或相应的伴随吸收条件），从而使算子的空间部分自伴。\n\n根据这个定义，我们可以重写 $\\delta J$：\n$$ \\delta J = \\sum_{s=1}^{N_{s}} \\int_{0}^{T} \\int_{\\Omega} (L_0 v^{(s)}) \\dot{u}_{1}^{(s)} \\, d\\mathbf{x} \\, dt $$\n我们现在使用分部积分将算子 $L_0$ 从 $v^{(s)}$ 移到 $\\dot{u}_{1}^{(s)}$ 上。这是互易性的一种体现。\n$$ \\int_0^T \\int_\\Omega (m_0 \\partial_{tt} v^{(s)}) \\dot{u}_{1}^{(s)} \\,d\\mathbf{x}dt = \\int_\\Omega \\left[ m_0 \\partial_t v^{(s)} \\dot{u}_{1}^{(s)} - m_0 v^{(s)} \\partial_t \\dot{u}_{1}^{(s)} \\right]_0^T \\,d\\mathbf{x} + \\int_0^T \\int_\\Omega (m_0 v^{(s)}) \\partial_{tt} \\dot{u}_{1}^{(s)} \\,d\\mathbf{x}dt $$\n由于 $v^{(s)}$ 的终值条件，时间边界项在 $t=T$ 时为零；由于 $\\dot{u}_{1}^{(s)}$ 的初始条件，在 $t=0$ 时也为零。\n\n对于空间部分，使用格林第二恒等式：\n$$ \\int_\\Omega (-\\nabla^2 v^{(s)}) \\dot{u}_{1}^{(s)} \\, d\\mathbf{x} = \\int_\\Omega v^{(s)} (-\\nabla^2 \\dot{u}_{1}^{(s)}) \\, d\\mathbf{x} + \\int_{\\partial\\Omega} \\left( v^{(s)} \\frac{\\partial \\dot{u}_1^{(s)}}{\\partial n} - \\dot{u}_1^{(s)} \\frac{\\partial v^{(s)}}{\\partial n} \\right) dS $$\n由于 $\\dot{u}_{1}^{(s)}$ 和 $v^{(s)}$ 都有齐次吸收边界条件，在 $\\partial\\Omega$ 上的边界积分为零。\n\n因此，算子 $L_0$ 在满足这些条件的场空间上是自伴的，我们有：\n$$ \\delta J = \\sum_{s=1}^{N_{s}} \\int_{0}^{T} \\int_{\\Omega} v^{(s)} (L_0 \\dot{u}_{1}^{(s)}) \\, d\\mathbf{x} \\, dt $$\n现在代入 $L_0 \\dot{u}_{1}^{(s)}$ 的表达式：\n$$ \\delta J = \\sum_{s=1}^{N_{s}} \\int_{0}^{T} \\int_{\\Omega} v^{(s)}(\\mathbf{x},t) \\left( -h(\\mathbf{x}) \\, \\partial_{tt} u_{0}^{(s)}(\\mathbf{x},t) \\right) \\, d\\mathbf{x} \\, dt $$\n由于 $h(\\mathbf{x})$ 与时间和震源索引 $s$ 无关，我们可以重新排列积分：\n$$ \\delta J = \\int_{\\Omega} h(\\mathbf{x}) \\left( - \\sum_{s=1}^{N_{s}} \\int_{0}^{T} v^{(s)}(\\mathbf{x},t) \\, \\partial_{tt} u_{0}^{(s)}(\\mathbf{x},t) \\, dt \\right) d\\mathbf{x} $$\n将其与定义式 $\\delta J = \\int_{\\Omega} \\nabla J(\\delta m)(\\mathbf{x}) h(\\mathbf{x}) \\,d\\mathbf{x}$ 进行比较，我们可以确定 Fréchet 梯度为：\n$$ \\nabla J(\\delta m)(\\mathbf{x}) = - \\sum_{s=1}^{N_{s}} \\int_{0}^{T} v^{(s)}(\\mathbf{x},t) \\, \\partial_{tt} u_{0}^{(s)}(\\mathbf{x},t) \\, dt $$\n这个最终表达式是伴随场 $v^{(s)}$ 和基线场 $u_0^{(s)}$ 的时间二阶导数之间的零延迟互相关（或时间上的内积），并对所有震源求和。\n\n对于给定的 $\\delta m$，计算梯度的步骤如下：\n1. 对于每个震源 $s$，求解基线波场 $u_0^{(s)}$ 并存储其在整个区域和时间区间上的时间二阶导数 $\\partial_{tt} u_0^{(s)}$。此步骤与 $\\delta m$ 无关。\n2. 对于每个震源 $s$，使用存储的 $\\partial_{tt} u_0^{(s)}$ 和 $\\delta m$ 的当前估计值来求解线性化波场 $u_1^{(s)}$。\n3. 对于每个震源 $s$，计算接收点处的数据残差，并用它们来构建伴随源 $q_{\\text{adj}}^{(s)}$。\n4. 对于每个震源 $s$，从 $t=T$ 到 $t=0$ 在时间上向后求解伴随方程以得到 $v^{(s)}$。\n5. 对于每个震源 $s$，在计算伴随场 $v^{(s)}$ 的同时，将其与预先存储的场 $\\partial_{tt} u_0^{(s)}$ 进行相关运算，并在时间上积分。\n6. 对所有震源的结果求和，以形成梯度 $\\nabla J(\\delta m)(\\mathbf{x})$。\n\n该过程证实了基线波场 $u_0^{(s)}$（或其导数）只需计算一次，存储后即可重复使用。为不同的 $\\delta m$ 计算梯度时，无需重新计算 $u_0^{(s)}$。梯度的最终表达式是一个用正演场和伴随场表示的闭式解析表达式。",
            "answer": "$$ \\boxed{- \\sum_{s=1}^{N_{s}} \\int_{0}^{T} v^{(s)}(\\mathbf{x},t) \\, \\partial_{tt} u_{0}^{(s)}(\\mathbf{x},t) \\, dt} $$"
        },
        {
            "introduction": "虽然简单的平滑先验很有用，但时移反演的真正威力在于利用动态变化的预期结构，例如稀疏性或低秩特性。这些具有物理动机的先验在数学上由非光滑正则化项表示，如 $\\ell_1$ 范数和核范数，这使得目标函数不可微。本练习  将指导你通过推导关键构建模块——邻近算子，并将它们组装成一个先进的原始-对偶算法，从而掌握解决此类问题的现代框架，弥合高级理论与实际应用之间的鸿沟。",
            "id": "3427752",
            "problem": "考虑一个线性化的时移反演模型，其中跨越 $T$ 个测量时间和 $P$ 个空间参数的一系列地下状态被收集到一个矩阵 $M \\in \\mathbb{R}^{P \\times T}$ 中。令 $x \\in \\mathbb{R}^{PT}$ 表示 $M$ 的按列向量化，记为 $x = \\operatorname{vec}(M)$。观测数据 $d \\in \\mathbb{R}^{n}$ 通过一个已知的线性正演算子 $A \\in \\mathbb{R}^{n \\times PT}$ 与 $x$ 相关联，其关系为 $d \\approx A x$，并带有加性噪声。我们寻求复合凸目标函数的最小值\n$$\n\\min_{x \\in \\mathbb{R}^{PT}} \\;\\; \\frac{1}{2}\\|A x - d\\|_{2}^{2} \\;+\\; \\alpha \\|R x\\|_{*} \\;+\\; \\beta \\|L x\\|_{1},\n$$\n其中 $R : \\mathbb{R}^{PT} \\to \\mathbb{R}^{P \\times T}$ 是将 $x$ 映射到 $M = R x$ 的重塑算子，符号 $\\|\\cdot\\|_{*}$ 表示核范数（奇异值之和），$L \\in \\mathbb{R}^{Q \\times PT}$ 是一个固定的线性算子，用于捕捉稀疏创新（例如，时间差分），而 $\\alpha > 0, \\beta > 0$ 是正则化参数。\n\n任务：\n1) 从真、闭、凸函数 $\\varphi$ 的邻近算子的定义出发，\n$$\n\\operatorname{prox}_{\\gamma \\varphi}(Z) \\;=\\; \\arg\\min_{X} \\left\\{ \\varphi(X) \\;+\\; \\frac{1}{2 \\gamma}\\|X - Z\\|_{F}^{2} \\right\\},\n$$\n推导核范数的邻近算子 $\\operatorname{prox}_{\\gamma \\alpha \\|\\cdot\\|_{*}}(Z)$，并将其表示为奇异值变换。您的推导必须从凸分析和矩阵不等式的基本原理开始，不能预先假设最终形式。\n\n2) 使用相同的邻近算子定义，推导 $\\ell_{1}$ 范数的邻近算子 $\\operatorname{prox}_{\\gamma \\beta \\|\\cdot\\|_{1}}(z)$，并将其表示为坐标级变换。推导需从绝对值的次微分演算开始，不能预先假设最终形式。\n\n3) 定义堆叠线性算子 $K : \\mathbb{R}^{PT} \\to \\mathbb{R}^{P \\times T} \\times \\mathbb{R}^{Q}$ 为 $K x = (R x, L x)$，凸函数为 $F(U, v) = \\alpha \\|U\\|_{*} + \\beta \\|v\\|_{1}$，以及 $G(x) = \\frac{1}{2}\\|A x - d\\|_{2}^{2}$。构建一个原始-对偶混合梯度（PDHG，也称为 Chambolle–Pock 方法）迭代算法来最小化 $G(x) + F(K x)$。您的构建必须明确说明：\n- 使用核范数和 $\\ell_{1}$ 范数的凸共轭的邻近算子进行的对偶更新，从 Moreau 分解的定义开始表达。\n- 使用通过求解相应最优性条件得到的 $G$ 的邻近算子进行的原始更新。\n- 过松弛步骤。\n- 确保收敛的关于 $\\tau, \\sigma > 0$ 的谱步长条件，用 $K$ 的算子范数表示。\n\n4) 将问题特化为一个最小的时移配置，其中 $P = 2$ 且 $T = 2$，因此 $x \\in \\mathbb{R}^{4}$。令 $R : \\mathbb{R}^{4} \\to \\mathbb{R}^{2 \\times 2}$ 为正交规范的重塑算子 $R x = M$，它将 $x$ 的元素按列放入一个 $2 \\times 2$ 矩阵中，并令时间差分算子 $L \\in \\mathbb{R}^{2 \\times 4}$ 的作用如下：\n$$\nL = \\begin{bmatrix}\n-1  0  1  0 \\\\\n0  -1  0  1\n\\end{bmatrix},\n$$\n使得 $L x$ 等于第二个时间帧与第一个时间帧之间的逐元素差异。使用任务3中的步长条件，计算满足收敛条件的所有正步长 $\\tau, \\sigma$ 的容许乘积 $\\tau \\sigma$ 的确切上确界。将最终答案表示为一个无单位的单一最简分数。请勿近似计算。提供这个单一分数作为您的最终答案。",
            "solution": "问题陈述经评估有效。它在科学上植根于凸优化和反演问题领域，问题提法得当，并以客观、正式的语言表达。它自成体系，没有矛盾或含糊之处。这些任务需要基于既定理论进行严格的数学推导和具体计算，适合于正式的科学背景。\n\n解答过程按顺序处理四个任务中的每一个。\n\n任务1：核范数邻近算子的推导\n\n函数 $\\varphi(X) = \\alpha \\|X\\|_{*}$（缩放参数为 $\\gamma > 0$）的邻近算子定义为：\n$$\n\\operatorname{prox}_{\\gamma \\alpha \\|\\cdot\\|_{*}}(Z) = \\arg\\min_{X \\in \\mathbb{R}^{P \\times T}} \\left\\{ \\alpha \\|X\\|_{*} + \\frac{1}{2 \\gamma}\\|X - Z\\|_{F}^{2} \\right\\}\n$$\n设矩阵 $Z \\in \\mathbb{R}^{P \\times T}$ 的奇异值分解（SVD）为 $Z = U \\Sigma V^T$，其中 $U \\in \\mathbb{R}^{P \\times P}$ 和 $V \\in \\mathbb{R}^{T \\times T}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{P \\times T}$ 是一个矩形对角矩阵，其对角线上的非负实数 $\\sigma_i$ 是 $Z$ 的奇异值。设变量 $X$ 的 SVD 为 $X = U_X S_X V_X^T$，其中 $S_X$ 包含 $X$ 的奇异值 $s_i$。\n\n目标函数可以使用迹内积重写：\n$$\n\\|X - Z\\|_{F}^{2} = \\operatorname{Tr}((X-Z)^T(X-Z)) = \\operatorname{Tr}(X^TX) - 2\\operatorname{Tr}(X^TZ) + \\operatorname{Tr}(Z^TZ) = \\|X\\|_{F}^{2} - 2\\operatorname{Tr}(X^TZ) + \\|Z\\|_{F}^{2}\n$$\n核范数是奇异值之和，$\\|X\\|_{*} = \\sum_i s_i$。Frobenius 范数是奇异值平方和的平方根，$\\|X\\|_{F}^{2} = \\sum_i s_i^2$。要最小化的目标函数是：\n$$\nJ(X) = \\alpha \\sum_i s_i + \\frac{1}{2\\gamma} \\left( \\sum_i s_i^2 - 2\\operatorname{Tr}(X^TZ) + \\sum_i \\sigma_i^2 \\right)\n$$\n为了最小化 $J(X)$，我们必须最大化项 $\\operatorname{Tr}(X^TZ)$。根据 von Neumann 迹不等式，对于任意两个矩阵 $A$ 和 $B$，$\\operatorname{Tr}(A^T B) \\le \\sum_i \\sigma_i(A) \\sigma_i(B)$，等号成立当且仅当存在酉矩阵 $U_{AB}$ 和 $V_{AB}$ 使得 $A = U_{AB} \\Sigma_A V_{AB}^T$ 和 $B = U_{AB} \\Sigma_B V_{AB}^T$，即它们共享相同的奇异向量。\n因此，当 $X$ 和 $Z$ 共享相同的奇异向量时，$\\operatorname{Tr}(X^TZ)$ 达到最大值。因此我们可以设置 $U_X = U$ 和 $V_X = V$，这意味着最优的 $X$ 具有形式 $X = U S V^T$，其中 $S$ 是某个具有非负元素 $s_i$ 的对角矩阵。\n在此代换下，$\\operatorname{Tr}(X^TZ) = \\operatorname{Tr}((USV^T)^T (U\\Sigma V^T)) = \\operatorname{Tr}(VS^T U^T U \\Sigma V^T) = \\operatorname{Tr}(V S \\Sigma V^T) = \\operatorname{Tr}(S \\Sigma V^T V) = \\operatorname{Tr}(S \\Sigma) = \\sum_i s_i \\sigma_i$。\n最小化问题解耦，成为针对每个奇异值 $s_i \\ge 0$ 的一组独立的标量最小化问题：\n$$\n\\min_{s_i \\ge 0} \\left\\{ \\alpha s_i + \\frac{1}{2\\gamma} (s_i^2 - 2s_i\\sigma_i + \\sigma_i^2) \\right\\} = \\min_{s_i \\ge 0} \\left\\{ \\alpha s_i + \\frac{1}{2\\gamma} (s_i - \\sigma_i)^2 \\right\\}\n$$\n我们通过将关于 $s_i$ 的导数设为零来找到无约束最小值：\n$$\n\\frac{d}{ds_i} \\left( \\alpha s_i + \\frac{1}{2\\gamma} (s_i - \\sigma_i)^2 \\right) = \\alpha + \\frac{1}{\\gamma}(s_i - \\sigma_i) = 0\n$$\n这得到 $s_i = \\sigma_i - \\gamma\\alpha$。由于奇异值必须为非负（$s_i \\ge 0$），解是此结果在非负半线上的投影：\n$$\ns_i = \\max(0, \\sigma_i - \\gamma\\alpha) \\equiv (\\sigma_i - \\gamma\\alpha)_+\n$$\n这个操作被称为软阈值。核范数的邻近算子将软阈值应用于输入矩阵 $Z$ 的奇异值。如果 $Z=U \\operatorname{diag}(\\sigma_i) V^T$，那么\n$$\n\\operatorname{prox}_{\\gamma \\alpha \\|\\cdot\\|_{*}}(Z) = U \\operatorname{diag}((\\sigma_i - \\gamma\\alpha)_+) V^T\n$$\n这就是奇异值阈值（SVT）算子，通常表示为 $\\mathcal{D}_{\\gamma\\alpha}(Z)$ 或 $\\operatorname{SVT}_{\\gamma\\alpha}(Z)$。\n\n任务2：$\\ell_1$ 范数邻近算子的推导\n\n函数 $\\varphi(x) = \\beta \\|x\\|_{1}$（缩放参数为 $\\gamma > 0$）的邻近算子定义为：\n$$\n\\operatorname{prox}_{\\gamma \\beta \\|\\cdot\\|_{1}}(z) = \\arg\\min_{x \\in \\mathbb{R}^{PT}} \\left\\{ \\beta \\|x\\|_{1} + \\frac{1}{2 \\gamma}\\|x - z\\|_{2}^{2} \\right\\}\n$$\n目标函数关于 $x$ 的分量是可分的。我们可以将其写成关于分量 $x_i$ 的和：\n$$\n\\sum_{i=1}^{PT} \\left( \\beta |x_i| + \\frac{1}{2\\gamma}(x_i - z_i)^2 \\right)\n$$\n我们可以独立地最小化每一项。对每个分量 $i$，我们求解：\n$$\n\\min_{x_i \\in \\mathbb{R}} \\left\\{ \\beta |x_i| + \\frac{1}{2\\gamma}(x_i - z_i)^2 \\right\\}\n$$\n令 $\\phi_i(x_i) = \\beta |x_i| + \\frac{1}{2\\gamma}(x_i - z_i)^2$。由于此函数是凸函数，一个点 $x_i^*$ 是最小值点当且仅当 $0$ 属于 $\\phi_i$ 在 $x_i^*$ 处的次微分。最优性条件是 $0 \\in \\partial \\phi_i(x_i^*)$。\n次微分为 $\\partial \\phi_i(x_i) = \\beta \\partial|x_i| + \\frac{1}{\\gamma}(x_i - z_i)$。绝对值函数的次微分为：\n$$\n\\partial|u| = \\begin{cases} \\{1\\} & \\text{if } u > 0 \\\\ \\{-1\\} & \\text{if } u < 0 \\\\ [-1, 1] & \\text{if } u = 0 \\end{cases}\n$$\n我们分析最优 $x_i^*$ 的三种情况：\n情况1：$x_i^* > 0$。则 $\\partial|x_i^*| = \\{1\\}$，最优性条件变为 $0 = \\beta \\cdot 1 + \\frac{1}{\\gamma}(x_i^* - z_i)$，这得出 $x_i^* = z_i - \\gamma\\beta$。为了使此情况自洽，我们必须有 $x_i^* > 0$，所以 $z_i - \\gamma\\beta > 0$，即 $z_i > \\gamma\\beta$。\n情况2：$x_i^* < 0$。则 $\\partial|x_i^*| = \\{-1\\}$，最优性条件为 $0 = \\beta \\cdot (-1) + \\frac{1}{\\gamma}(x_i^* - z_i)$，这得出 $x_i^* = z_i + \\gamma\\beta$。为了自洽，我们需要 $x_i^* < 0$，所以 $z_i + \\gamma\\beta < 0$，即 $z_i < -\\gamma\\beta$。\n情况3：$x_i^* = 0$。则 $\\partial|x_i^*| = [-1, 1]$，最优性条件为 $0 \\in \\beta [-1, 1] + \\frac{1}{\\gamma}(0 - z_i)$，可简化为 $\\frac{z_i}{\\gamma} \\in [-\\beta, \\beta]$，即 $|z_i| \\le \\gamma\\beta$。\n\n结合这三种情况，得到 $x_i^*$ 的解：\n$$\nx_i^* = \\begin{cases} z_i - \\gamma\\beta & \\text{if } z_i > \\gamma\\beta \\\\ z_i + \\gamma\\beta & \\text{if } z_i < -\\gamma\\beta \\\\ 0 & \\text{if } |z_i| \\le \\gamma\\beta \\end{cases}\n$$\n这是分量级软阈值算子，可以紧凑地写为：\n$$\nx_i^* = \\operatorname{sign}(z_i) \\max(|z_i| - \\gamma\\beta, 0)\n$$\n因此，邻近算子是此函数的逐元素应用，记为 $S_{\\gamma\\beta}(z)$。\n\n任务3：原始-对偶混合梯度（PDHG）迭代\n\n问题是最小化 $G(x) + F(Kx)$。对于这种问题结构，PDHG（Chambolle-Pock）算法，其中原始变量为 $x$，对偶变量为 $y = (Y, q)$，过松弛参数为 $\\theta=1$，由以下迭代序列给出，从 $(x^k, y^k)$ 开始：\n原始更新：$x^{k+1} = \\operatorname{prox}_{\\tau G}(x^k - \\tau K^* y^k)$\n过松弛：$\\bar{x}^{k+1} = x^{k+1} + (x^{k+1} - x^k) = 2x^{k+1} - x^k$\n对偶更新：$y^{k+1} = \\operatorname{prox}_{\\sigma F^*}(y^k + \\sigma K \\bar{x}^{k+1})$\n\n让我们为给定问题具体说明每个部分。\n对偶变量是 $y=(Y,q)$，其中 $Y\\in\\mathbb{R}^{P\\times T}$ 是 $Rx$ 的对偶，而 $q\\in\\mathbb{R}^Q$ 是 $Lx$ 的对偶。算子 $K$ 是 $Kx = (Rx, Lx)$，其伴随算子是 $K^*(Y,q) = R^*Y + L^*q$。\n\n对偶更新：\n函数 $F(U, v) = \\alpha\\|U\\|_{*} + \\beta\\|v\\|_{1}$ 是可分的。其凸共轭是 $F^*(Y,q) = (\\alpha\\|\\cdot\\|_{*})^*(Y) + (\\beta\\|\\cdot\\|_{1})^*(q)$。$F^*$ 的邻近算子也是可分的：\n$$\n\\operatorname{prox}_{\\sigma F^*}(Y,q) = (\\operatorname{prox}_{\\sigma (\\alpha\\|\\cdot\\|_{*})^*}(Y), \\operatorname{prox}_{\\sigma (\\beta\\|\\cdot\\|_{1})^*}(q))\n$$\n我们使用 Moreau 分解恒等式：$\\operatorname{prox}_{\\gamma \\phi^*}(z) = z - \\gamma \\operatorname{prox}_{\\phi/\\gamma}(z/\\gamma)$。\n\n对于核范数部分，令 $f_1(U) = \\alpha\\|U\\|_*$。$Y$ 的对偶更新为：\n$Y^{k+1} = \\operatorname{prox}_{\\sigma f_1^*}(Y^k + \\sigma R \\bar{x}^{k+1})$。\n使用 Moreau 恒等式，其中 $\\phi = f_1$ 且 $\\gamma = \\sigma$：\n$Y^{k+1} = (Y^k + \\sigma R \\bar{x}^{k+1}) - \\sigma \\operatorname{prox}_{f_1/\\sigma}((Y^k + \\sigma R \\bar{x}^{k+1})/\\sigma) = (Y^k + \\sigma R \\bar{x}^{k+1}) - \\sigma \\operatorname{prox}_{(\\alpha/\\sigma)\\|\\cdot\\|_{*}}((Y^k + \\sigma R \\bar{x}^{k+1})/\\sigma)$。\n使用任务1的结果，这等价于投影到对偶范数球上。核范数的对偶范数是算子范数 $\\|\\cdot\\|_{op}$。因此，$(\\alpha\\|U\\|_*)^* = I_{\\|Y\\|_{op} \\le \\alpha}(Y)$，这是算子范数至多为 $\\alpha$ 的矩阵集合的指示函数。指示函数的邻近算子是到该集合的欧几里得投影。\n$$\nY^{k+1} = \\mathcal{P}_{\\|Y\\|_{op} \\le \\alpha} (Y^k + \\sigma R \\bar{x}^{k+1})\n$$\n其中 $\\mathcal{P}$ 表示投影，它将其矩阵参数的奇异值裁剪到 $\\alpha$。\n\n对于 $\\ell_1$ 范数部分，令 $f_2(v) = \\beta\\|v\\|_1$。$q$ 的对偶更新为：\n$q^{k+1} = \\operatorname{prox}_{\\sigma f_2^*}(q^k + \\sigma L \\bar{x}^{k+1})$。\n$\\ell_1$ 范数的共轭是 $\\ell_\\infty$ 范数球的指示函数：$(\\beta\\|v\\|_1)^* = I_{\\|q\\|_{\\infty} \\le \\beta}(q)$。邻近算子是到这个球的投影。\n$$\nq^{k+1} = \\mathcal{P}_{\\|q\\|_{\\infty} \\le \\beta} (q^k + \\sigma L \\bar{x}^{k+1})\n$$\n此投影将其向量参数的分量裁剪到 $\\beta$：$(q^{k+1})_i = \\operatorname{sign}((q^k + \\sigma L \\bar{x}^{k+1})_i) \\min(|(q^k + \\sigma L \\bar{x}^{k+1})_i|, \\beta)$。\n\n原始更新：\n原始更新为 $x^{k+1} = \\operatorname{prox}_{\\tau G}(x^k - \\tau K^* y^{k+1})$，其中 $K^*y^{k+1} = R^*Y^{k+1} + L^*q^{k+1}$。令 $z^k = x^k - \\tau(R^*Y^{k+1} + L^*q^{k+1})$。\n邻近算子为 $x^{k+1} = \\arg\\min_x \\{G(x) + \\frac{1}{2\\tau}\\|x - z^k\\|_2^2\\}$。\n对于 $G(x) = \\frac{1}{2}\\|Ax-d\\|_2^2$，这是一个标准的最小二乘问题：\n$$\nx^{k+1} = \\arg\\min_x \\left\\{ \\frac{1}{2}\\|Ax - d\\|_{2}^{2} + \\frac{1}{2\\tau}\\|x - z^k\\|_{2}^{2} \\right\\}\n$$\n通过将梯度设为零找到最优性条件：\n$A^T(Ax^{k+1} - d) + \\frac{1}{\\tau}(x^{k+1} - z^k) = 0$。\n$(A^TA + \\frac{1}{\\tau}I)x^{k+1} = A^Td + \\frac{1}{\\tau}z^k$。\n解出 $x^{k+1}$：\n$$\nx^{k+1} = \\left(A^T A + \\frac{1}{\\tau} I \\right)^{-1} \\left(A^T d + \\frac{1}{\\tau} (x^k - \\tau(R^*Y^{k+1} + L^*q^{k+1})) \\right)\n$$\n这涉及在每次迭代中求解一个线性系统。\n\n过松弛步骤：\n用于下一次对偶更新的过松弛原始变量计算如下：\n$$\n\\bar{x}^{k+1} = 2x^{k+1} - x^k\n$$\n\n谱步长条件：\n对于 $\\theta=1$ 的 PDHG 算法，确保步长 $\\tau, \\sigma > 0$ 收敛的一个充分条件是：\n$$\n\\tau \\sigma \\|K\\|_{op}^2 < 1\n$$\n其中 $\\|K\\|_{op}$ 是从 $\\mathbb{R}^{PT}$ 到 $\\mathbb{R}^{P \\times T} \\times \\mathbb{R}^{Q}$（后者具有标准乘积空间范数）的算子 $K$ 的算子范数。它由 $\\|K\\|_{op}^2 = \\lambda_{\\max}(K^*K)$ 定义，其中 $\\lambda_{\\max}$ 是最大特征值。\n我们有 $K^*K = (R^*, L^T)\\begin{pmatrix} R \\\\ L \\end{pmatrix} = R^*R + L^TL$。\n所以条件是 $\\tau \\sigma \\lambda_{\\max}(R^*R + L^TL) < 1$。\n\n任务4：步长乘积的上确界\n\n给定 $P=2, T=2$，所以 $x \\in \\mathbb{R}^4$。重塑算子 $R: \\mathbb{R}^4 \\to \\mathbb{R}^{2 \\times 2}$ 是正交规范的。一个算子是正交规范的，如果 $R^*R=I$。因此，对于我们特定的 $R$，我们有 $R^*R = I_4$，即 $4 \\times 4$ 的单位矩阵。\n\n时间差分算子是 $L = \\begin{bmatrix} -1  0  1  0 \\\\ 0  -1  0  1 \\end{bmatrix}$。\n我们需要计算 $\\|K\\|_{op}^2 = \\lambda_{\\max}(R^*R + L^TL) = \\lambda_{\\max}(I_4 + L^TL)$。\n$I_4 + L^TL$ 的特征值是 $1 + \\lambda_i(L^TL)$，其中 $\\lambda_i(L^TL)$ 是 $L^TL$ 的特征值。我们需要 $L^TL$ 的最大特征值。\n$L^TL$（一个 $4 \\times 4$ 矩阵）的非零特征值与 $LL^T$（一个 $2 \\times 2$ 矩阵）的非零特征值相同。让我们计算 $LL^T$：\n$$\nL^T = \\begin{bmatrix} -1  0 \\\\ 0  -1 \\\\ 1  0 \\\\ 0  1 \\end{bmatrix}\n$$\n$$\nLL^T = \\begin{bmatrix} -1  0  1  0 \\\\ 0  -1  0  1 \\end{bmatrix} \\begin{bmatrix} -1  0 \\\\ 0  -1 \\\\ 1  0 \\\\ 0  1 \\end{bmatrix} = \\begin{bmatrix} (-1)(-1) + (1)(1)  0 \\\\ 0  (-1)(-1) + (1)(1) \\end{bmatrix} = \\begin{bmatrix} 2  0 \\\\ 0  2 \\end{bmatrix}\n$$\n矩阵 $LL^T$ 是一个对角矩阵，所以它的特征值是其对角元素：$\\lambda_1 = 2$ 和 $\\lambda_2 = 2$。\n因此，$L^TL$ 的非零特征值是 $2$ 和 $2$。由于 $L^TL$ 是 $4 \\times 4$ 矩阵，它的另外两个特征值为 $0$。$L^TL$ 的特征值集合是 $\\{2, 2, 0, 0\\}$。\n最大特征值是 $\\lambda_{\\max}(L^TL) = 2$。\n现在我们可以计算 $\\|K\\|_{op}^2$：\n$$\n\\|K\\|_{op}^2 = 1 + \\lambda_{\\max}(L^TL) = 1 + 2 = 3\n$$\n收敛条件变为 $\\tau \\sigma \\cdot 3 < 1$，简化为：\n$$\n\\tau\\sigma < \\frac{1}{3}\n$$\n问题要求容许乘积 $\\tau\\sigma$ 的确切上确界。容许乘积的集合是区间 $(0, 1/3)$。这个集合的上确界是最小上界，即 $1/3$。\n乘积 $\\tau\\sigma$ 的上确界是 $\\frac{1}{3}$。",
            "answer": "$$\\boxed{\\frac{1}{3}}$$"
        },
        {
            "introduction": "在建立了数学工具之后，我们现在可以评估和比较不同的时移反演高级策略。我们应该直接对变化进行反演，还是联合反演所有时刻的模型序列？这最后一个实践  在一个综合基准上对三种流行方法——稳定化差异反演、联合反演和四维变分法（4D-Var）——进行了正面比较。通过实现这些估计器并量化其性能，你将获得关于它们各自优势、局限性以及时移成像中基本权衡的宝贵实践见解。",
            "id": "3427721",
            "problem": "考虑以下线性、高斯、一维时滞逆问题，该问题具有静态观测算子和简单的恒等动力学模型。设空间网格大小为 $N$，空间坐标 $s_i \\in [0,1]$ ($i \\in \\{1,\\dots,N\\}$) 均匀分布，时间步数为 $T$。在时间 $k$ 的未知状态为 $x_k \\in \\mathbb{R}^N$，在时间 $k$ 的观测数据为 $y_k \\in \\mathbb{R}^M$，由以下线性正演模型给出\n$$\ny_k = H x_k + \\varepsilon_k, \\quad \\varepsilon_k \\sim \\mathcal{N}(0, R),\n$$\n其中 $H \\in \\mathbb{R}^{M \\times N}$ 在整个时间范围内是固定的，$R = \\sigma^2 I_M$ 是观测噪声协方差，$\\sigma > 0$。假设一个简单的恒等动力学模型 $F = I_N$，因此模型演化为 $x_{k+1} \\approx x_k$，差异仅为模型误差。令 $D \\in \\mathbb{R}^{N \\times N}$ 表示空间网格上的一阶周期差分算子，即 $(D x)_i = x_i - x_{i-1}$ 且 $x_0 \\equiv x_N$，并通过 $D^T D$ 定义空间粗糙度惩罚。令 $T_{\\text{op}} \\in \\mathbb{R}^{N(T-1) \\times NT}$ 表示作用于堆叠状态 $X = [x_1^T,\\dots,x_T^T]^T$ 的时间一阶差分算子，即 $T_{\\text{op}} X = [ (x_2 - x_1)^T, \\dots, (x_T - x_{T-1})^T ]^T$。\n\n您将需要在一个固定网格上生成合成真值 $x_k^{\\text{true}}$ 和相应的含噪观测数据，然后使用三种方法计算和比较重建结果：稳定化差分反演 (stabilized difference inversion, SDI)、联合反演 (joint inversion, JI) 和四维变分数据同化 (four-dimensional variational data assimilation, 4D-Var)。对于每种方法，您必须从第一性原理推导出相应的线性估计器，并实现它以获得最终时刻状态 $\\hat{x}_T$ 的重建结果。然后，您必须报告最终时刻的三个量化指标：$\\hat{x}_T$ 和 $x_T^{\\text{true}}$ 之间的均方根误差 (RMSE)、根据最终时刻分辨率矩阵计算的平均分辨率宽度，以及根据最终时刻后验协方差计算的平均后验不确定性。\n\n需要使用的基本理论基础包括：线性高斯模型及其与 Tikhonov 正则化的等价性、一阶空间和时间差分算子的性质，以及联合反演和四维变分数据同化的变分形式。\n\n定义和所需构造：\n- 合成真值生成：令 $N = 20$ 且 $T = 3$。定义 $s_i = \\frac{i-1}{N-1}$ 对于 $i \\in \\{1,\\dots,N\\}$。定义\n$$\nx_1^{\\text{true}}(s) = 0.1 \\sin(2 \\pi s) + \\exp\\!\\left(-\\frac{(s-0.30)^2}{2 \\cdot 0.05^2}\\right),\n$$\n$$\nx_2^{\\text{true}}(s) = 0.1 \\sin(2 \\pi s) + 0.8\\,\\exp\\!\\left(-\\frac{(s-0.50)^2}{2 \\cdot 0.05^2}\\right),\n$$\n$$\nx_3^{\\text{true}}(s) = 0.1 \\sin(2 \\pi s) + 0.6\\,\\exp\\!\\left(-\\frac{(s-0.70)^2}{2 \\cdot 0.05^2}\\right),\n$$\n并通过在 $s_i$ 处采样来设置离散向量 $x_k^{\\text{true}} \\in \\mathbb{R}^N$。设观测矩阵 $H \\in \\mathbb{R}^{M \\times N}$ 通过以 $r_m = \\frac{m-1}{M-1}$ ($m \\in \\{1,\\dots,M\\}$) 为中心的点扩散行来定义，具体为\n$$\nH_{m i} = \\exp\\!\\left(-\\frac{(s_i - r_m)^2}{2 \\cdot \\sigma_h^2}\\right), \\quad \\sigma_h = 0.05.\n$$\n生成含噪数据 $y_k = H x_k^{\\text{true}} + \\varepsilon_k$，其中 $\\varepsilon_k \\sim \\mathcal{N}(0, \\sigma^2 I_M)$ 在不同时间点上独立抽取。\n\n- 稳定化差分反演 (SDI)：首先，通过最小化 Tikhonov 泛函来估计 $x_1$\n$$\nJ_{\\text{SDI},1}(x) = \\| y_1 - H x \\|_{R^{-1}}^2 + \\lambda_s \\| D x \\|_2^2,\n$$\n然后对于 $k \\in \\{2,\\dots,T\\}$，通过最小化以下泛函来估计变化量 $\\Delta x_k$\n$$\nJ_{\\text{SDI},\\Delta}(\\Delta x) = \\| (y_k - y_{k-1}) - H \\Delta x \\|_{R^{-1}}^2 + \\lambda_{\\Delta} \\| D \\Delta x \\|_2^2.\n$$\n将 $J_{\\text{SDI},1}$ 的最小化子设为 $\\hat{x}_1$，将 $J_{\\text{SDI},\\Delta}$ 的最小化子设为 $\\widehat{\\Delta x}_k$，并定义最终估计 $\\hat{x}_T = \\hat{x}_1 + \\sum_{k=2}^T \\widehat{\\Delta x}_k$。对于 SDI 的分辨率宽度指标，使用时间 $T$ 时最终变化估计器的模型分辨率，即从 $y_T - y_{T-1}$ 映射到 $\\widehat{\\Delta x}_T$ 的线性估计器的分辨率矩阵。\n\n- 联合反演 (JI)：将状态堆叠成 $X = [x_1^T,\\dots,x_T^T]^T \\in \\mathbb{R}^{NT}$ 并最小化\n$$\nJ_{\\text{JI}}(X) = \\sum_{k=1}^T \\| y_k - H x_k \\|_{R^{-1}}^2 + \\lambda_s \\sum_{k=1}^T \\| D x_k \\|_2^2 + \\lambda_t \\sum_{k=1}^{T-1} \\| x_{k+1} - x_k \\|_2^2.\n$$\n令 $\\hat{X}$ 表示最小化子，并提取其最后的 $N$-块作为 $\\hat{x}_T$。\n\n- 四维变分数据同化 (4D-Var)：如上所述堆叠 $X$ 并最小化\n$$\nJ_{\\text{4D}}(X) = \\sum_{k=1}^T \\| y_k - H x_k \\|_{R^{-1}}^2 + \\beta \\| D x_1 \\|_2^2 + \\sum_{k=1}^{T-1} \\| x_{k+1} - x_k \\|_{Q^{-1}}^2,\n$$\n其中 $Q = q I_N$，因此 $Q^{-1} = \\frac{1}{q} I_N$，$\\beta > 0$ 且 $q > 0$。\n\n在最终时刻 $T$ 计算的指标：\n- 均方根误差 (RMSE)：\n$$\n\\text{RMSE} = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N \\left( \\hat{x}_{T,i} - x_{T,i}^{\\text{true}} \\right)^2 }.\n$$\n- 平均分辨率宽度：令 $W$ 表示将所讨论方法的堆叠数据 $Y = [y_1^T,\\dots,y_T^T]^T$ 映射到堆叠估计 $\\hat{X}$ 的线性估计器，令 $G$ 表示将 $X$ 映射到 $Y$ 的块观测算子。模型分辨率矩阵为 $R_{\\text{mod}} = W G$。提取将真实 $x_T$ 映射到估计 $\\hat{x}_T$ 的 $N \\times N$ 最终时刻子块 $R_T$。对于每一行 $i$，形成非负权重 $a_{i j} = |(R_T)_{i j}|$，计算二阶中心矩\n$$\nw_i = \\sqrt{ \\frac{\\sum_{j=1}^N a_{i j} (s_j - s_i)^2}{\\sum_{j=1}^N a_{i j}} },\n$$\n并报告平均宽度 $\\frac{1}{N} \\sum_{i=1}^N w_i$。对于 SDI，使用通过 $y_T - y_{T-1}$ 得到的、关于 $x_T$ 的最终变化估计器 $\\widehat{\\Delta x}_T$ 的分辨率作为 $R_T$。\n- 平均后验不确定性：在线性高斯设定中，堆叠状态的后验协方差为\n$$\n\\Sigma_{\\text{post}} = \\left(G^T R^{-1} G + \\Gamma \\right)^{-1},\n$$\n其中 $\\Gamma$ 是每种方法所隐含的先验精度矩阵。提取最终时刻的 $N \\times N$ 子块，并报告平均边际后验标准差，即\n$$\n\\frac{1}{N} \\sum_{i=1}^N \\sqrt{ (\\Sigma_{\\text{post},T})_{i i} }.\n$$\n对于 SDI，由于数据独立，假设这些高斯估计器之间相互独立，将最终时刻的后验方差近似为 $\\hat{x}_1$ 和 $\\widehat{\\Delta x}_k$ ($k \\in \\{2,\\dots,T\\}$) 的边际后验方差之和；报告该和的对角线元素的平方根的平均值。\n\n您的程序必须通过构建并求解从上述最小化子推导出的相应正规方程来实现这三个估计器。使用以下三个测试用例，每个用例由 $(M, \\sigma, \\lambda_s, \\lambda_{\\Delta}, \\lambda_t, \\beta, q)$ 指定：\n- 测试用例 1：$(20, 0.01, 0.01, 0.01, 0.01, 0.01, 0.005)$。\n- 测试用例 2：$(20, 0.05, 0.02, 0.02, 0.02, 0.02, 0.01)$。\n- 测试用例 3：$(10, 0.02, 0.01, 0.01, 0.005, 0.01, 0.005)$。\n\n所有量都是无量纲的，因此不需要进行物理单位转换。不出现角度。不出现百分比。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的聚合结果列表。对于每个测试用例，按 $1,2,3$ 的顺序，依次附加九个浮点数：$\\text{RMSE}_{\\text{SDI}}$, $\\text{ResWidth}_{\\text{SDI}}$, $\\text{PostStd}_{\\text{SDI}}$, $\\text{RMSE}_{\\text{JI}}$, $\\text{ResWidth}_{\\text{JI}}$, $\\text{PostStd}_{\\text{JI}}$, $\\text{RMSE}_{\\text{4D}}$, $\\text{ResWidth}_{\\text{4D}}$, $\\text{PostStd}_{\\text{4D}}$。因此，最终输出行在一个列表中包含 $27$ 个浮点数，并严格按照指定的顺序排列。",
            "solution": "用户提供了一个定义明确的时滞逆问题，并要求比较三种重建方法：稳定化差分反演 (SDI)、联合反演 (JI) 和四维变分数据同化 (4D-Var)。该问题具有科学依据，数学上一致、完整且适定。所有必要的参数、模型和指标定义均已提供。因此，该问题被认为是有效的，可以构建完整的解决方案。\n\n问题的核心在于找到三个不同的 Tikhonov 式二次代价函数的最小化子，这对应于求解一个线性正规方程组。从这些解中，我们推导出估计器以及相关的统计和分辨率指标。\n\n设堆叠状态向量为 $X = [x_1^T, \\dots, x_T^T]^T \\in \\mathbb{R}^{NT}$，堆叠数据向量为 $Y = [y_1^T, \\dots, y_T^T]^T \\in \\mathbb{R}^{MT}$。正演模型可以写成 $Y = \\mathcal{H} X + \\mathcal{E}$，其中 $\\mathcal{H} = I_T \\otimes H$ 是块对角观测算子，$\\mathcal{E}$ 是堆叠噪声向量，其协方差为 $\\mathcal{R} = I_T \\otimes R = \\sigma^2 I_{MT}$。\n\n在线性高斯框架中，后验概率密度函数的一般形式为 $p(X|Y) \\propto \\exp(-\\frac{1}{2} J(X))$，其中 $J(X)$ 是目标函数。目标函数是数据失配项和先验项之和：\n$$\nJ(X) = (Y - \\mathcal{H}X)^T \\mathcal{R}^{-1} (Y - \\mathcal{H}X) + (X - X_{\\text{prior}})^T \\Gamma (X - X_{\\text{prior}})\n$$\n其中 $X_{\\text{prior}}$ 是先验均值（此处假设为零），$\\Gamma$ 是先验精度（逆协方差）矩阵。$J(X)$ 的最小化子，即最大后验 (MAP) 估计 $\\hat{X}$，通过将梯度 $\\nabla_X J(X)$ 设为零来找到。这导出了正规方程：\n$$\n(\\mathcal{H}^T \\mathcal{R}^{-1} \\mathcal{H} + \\Gamma) \\hat{X} = \\mathcal{H}^T \\mathcal{R}^{-1} Y\n$$\n$\\frac{1}{2} J(X)$ 的海森矩阵 (Hessian) 是后验精度矩阵 $\\Sigma_{\\text{post}}^{-1} = (\\mathcal{H}^T \\mathcal{R}^{-1} \\mathcal{H} + \\Gamma)$。后验协方差是其逆矩阵 $\\Sigma_{\\text{post}}$。在没有噪声的情况下，将真实状态 $X^{\\text{true}}$ 映射到估计 $\\hat{X}$ 的模型分辨率矩阵为 $R_{\\text{mod}} = \\Sigma_{\\text{post}} \\mathcal{H}^T \\mathcal{R}^{-1} \\mathcal{H}$。\n\n我们现在将此框架应用于这三种方法中的每一种。\n\n**1. 稳定化差分反演 (SDI)**\n\nSDI 按顺序操作。首先，计算初始状态 $x_1$ 的估计。然后，计算后续时刻的变化量 $\\Delta x_k = x_k - x_{k-1}$ 的估计。\n\n初始状态 $x_1$ 的代价函数是：\n$$\nJ_{\\text{SDI},1}(x_1) = \\| y_1 - H x_1 \\|_{R^{-1}}^2 + \\lambda_s \\| D x_1 \\|_2^2 = \\frac{1}{\\sigma^2} \\| y_1 - H x_1 \\|_2^2 + \\lambda_s x_1^T D^T D x_1\n$$\n这对应于先验精度 $\\Gamma_1 = \\lambda_s D^T D$。正规方程为：\n$$\n\\left(\\frac{1}{\\sigma^2} H^T H + \\lambda_s D^T D\\right) \\hat{x}_1 = \\frac{1}{\\sigma^2} H^T y_1\n$$\n$x_1$ 的后验协方差为 $\\Sigma_{\\text{post},1} = \\left(\\frac{1}{\\sigma^2} H^T H + \\lambda_s D^T D\\right)^{-1}$。\n\n对于 $k \\in \\{2, \\dots, T\\}$，通过最小化以下函数来估计变化量 $\\Delta x_k$：\n$$\nJ_{\\text{SDI},\\Delta}(\\Delta x) = \\| (y_k - y_{k-1}) - H \\Delta x \\|_{R^{-1}}^2 + \\lambda_{\\Delta} \\| D \\Delta x \\|_2^2 = \\frac{1}{\\sigma^2} \\| \\Delta y_k - H \\Delta x \\|_2^2 + \\lambda_{\\Delta} \\Delta x^T D^T D \\Delta x\n$$\n其中 $\\Delta y_k = y_k - y_{k-1}$。此公式隐含地假设 $\\Delta y_k$ 上的噪声协方差为 $R$，而实际上是 $2R$。我们遵循问题的定义。估计 $\\widehat{\\Delta x}_k$ 的正规方程为：\n$$\n\\left(\\frac{1}{\\sigma^2} H^T H + \\lambda_{\\Delta} D^T D\\right) \\widehat{\\Delta x}_k = \\frac{1}{\\sigma^2} H^T \\Delta y_k\n$$\n$\\Delta x_k$ 的后验协方差为 $\\Sigma_{\\text{post},\\Delta} = \\left(\\frac{1}{\\sigma^2} H^T H + \\lambda_{\\Delta} D^T D\\right)^{-1}$。\n\n最终状态估计为 $\\hat{x}_T = \\hat{x}_1 + \\sum_{k=2}^T \\widehat{\\Delta x}_k$。\n最终时刻的后验协方差通过对独立估计器的协方差求和来近似：\n$$\n\\Sigma_{\\text{post},T}^{\\text{SDI}} \\approx \\Sigma_{\\text{post},1} + \\sum_{k=2}^T \\Sigma_{\\text{post},\\Delta} = \\Sigma_{\\text{post},1} + (T-1)\\Sigma_{\\text{post},\\Delta}\n$$\n关于 $x_T$ 的最终变化估计器 $\\widehat{\\Delta x}_T$ 的模型分辨率矩阵为：\n$$\nR_T^{\\text{SDI}} = \\Sigma_{\\text{post},\\Delta} \\left(\\frac{1}{\\sigma^2} H^T H\\right)\n$$\n\n**2. 联合反演 (JI)**\n\nJI 同时估计所有状态 $X = [x_1^T, \\dots, x_T^T]^T$。代价函数为：\n$$\nJ_{\\text{JI}}(X) = \\sum_{k=1}^T \\frac{1}{\\sigma^2}\\| y_k - H x_k \\|_2^2 + \\lambda_s \\sum_{k=1}^T \\| D x_k \\|_2^2 + \\lambda_t \\sum_{k=1}^{T-1} \\| x_{k+1} - x_k \\|_2^2\n$$\n这可以写成矩阵形式：\n$$\nJ_{\\text{JI}}(X) = \\frac{1}{\\sigma^2}\\|Y - \\mathcal{H}X\\|_2^2 + \\lambda_s X^T (I_T \\otimes D^T D) X + \\lambda_t X^T (T_{\\text{op}}^T T_{\\text{op}}) X\n$$\n其中 $T_{\\text{op}}$ 是时间一阶差分算子。先验精度矩阵为 $\\Gamma_{\\text{JI}} = \\lambda_s (I_T \\otimes D^T D) + \\lambda_t (T_{\\text{op}}^T T_{\\text{op}})$。正规方程为：\n$$\n\\left( \\frac{1}{\\sigma^2} \\mathcal{H}^T \\mathcal{H} + \\Gamma_{\\text{JI}} \\right) \\hat{X} = \\frac{1}{\\sigma^2} \\mathcal{H}^T Y\n$$\n令 $\\mathcal{A}_{\\text{JI}} = \\left( \\frac{1}{\\sigma^2} \\mathcal{H}^T \\mathcal{H} + \\Gamma_{\\text{JI}} \\right)$。整个状态历史的后验协方差为 $\\Sigma_{\\text{post}}^{\\text{JI}} = \\mathcal{A}_{\\text{JI}}^{-1}$。模型分辨率矩阵为 $R_{\\text{mod}}^{\\text{JI}} = \\Sigma_{\\text{post}}^{\\text{JI}} \\left(\\frac{1}{\\sigma^2} \\mathcal{H}^T \\mathcal{H}\\right)$。我们从 $\\Sigma_{\\text{post}}^{\\text{JI}}$ 和 $R_{\\text{mod}}^{\\text{JI}}$ 中提取最终时刻的 $N \\times N$ 子块来计算指标。\n\n**3. 四维变分数据同化 (4D-Var)**\n\n4D-Var 类似于 JI，但使用不同的先验结构，通常由状态空间模型提供信息：\n$$\nJ_{\\text{4D}}(X) = \\sum_{k=1}^T \\frac{1}{\\sigma^2}\\| y_k - H x_k \\|_2^2 + \\beta \\| D x_1 \\|_2^2 + \\sum_{k=1}^{T-1} \\frac{1}{q} \\| x_{k+1} - x_k \\|_2^2\n$$\n先验惩罚初始状态 $x_1$ 的粗糙度和时间变化量 $x_{k+1}-x_k$。在矩阵形式中，先验精度矩阵为 $\\Gamma_{\\text{4D}} = \\beta \\text{diag}(D^T D, 0, \\dots, 0) + \\frac{1}{q} T_{\\text{op}}^T T_{\\text{op}}$。正规方程为：\n$$\n\\left( \\frac{1}{\\sigma^2} \\mathcal{H}^T \\mathcal{H} + \\Gamma_{\\text{4D}} \\right) \\hat{X} = \\frac{1}{\\sigma^2} \\mathcal{H}^T Y\n$$\n令 $\\mathcal{A}_{\\text{4D}} = \\left( \\frac{1}{\\sigma^2} \\mathcal{H}^T \\mathcal{H} + \\Gamma_{\\text{4D}} \\right)$。后验协方差为 $\\Sigma_{\\text{post}}^{\\text{4D}} = \\mathcal{A}_{\\text{4D}}^{-1}$，模型分辨率矩阵为 $R_{\\text{mod}}^{\\text{4D}} = \\Sigma_{\\text{post}}^{\\text{4D}} \\left(\\frac{1}{\\sigma^2} \\mathcal{H}^T \\mathcal{H}\\right)$。同样，我们提取最终时刻的子块用于指标计算。\n\n**指标计算**\n\n对于每种方法，为最终时间步 $T$ 计算三个所需的指标：\n- **均方根误差 (RMSE)**：使用估计的最终状态 $\\hat{x}_T$ 和真实状态 $x_T^{\\text{true}}$ 直接计算。\n- **平均分辨率宽度**：对于给定的最终时刻模型分辨率矩阵 $R_T$，每个网格点 $i$ 的宽度计算为网格坐标的加权标准差，其中权重是 $R_T$ 第 $i$ 行的绝对值。最终指标是所有网格点上这些宽度的平均值。\n- **平均后验不确定性**：对于给定的最终时刻后验协方差矩阵 $\\Sigma_{\\text{post}, T}$，每个网格点 $i$ 的不确定性是相应对角元素（边际后验方差）的平方根。最终指标是这些标准差的平均值。\n\n**实现**\n\n以下 Python 程序实现了这些推导，以求解估计器并为每个测试用例计算指定的指标。\n```python\nimport numpy as np\nfrom scipy.linalg import block_diag\n\ndef calculate_average_resolution_width(R_T, s):\n    \"\"\"Computes the average resolution width.\"\"\"\n    N = R_T.shape[0]\n    widths = np.zeros(N)\n    for i in range(N):\n        abs_row = np.abs(R_T[i, :])\n        denominator = np.sum(abs_row)\n        if denominator > np.finfo(float).eps:\n            s_i = s[i]\n            numerator = np.sum(abs_row * (s - s_i)**2)\n            widths[i] = np.sqrt(numerator / denominator)\n        else:\n            widths[i] = 0.0\n    return np.mean(widths)\n\ndef calculate_average_posterior_std(Sigma_T):\n    \"\"\"Computes the average posterior standard deviation.\"\"\"\n    variances = np.diag(Sigma_T)\n    # Ensure variances are non-negative before taking sqrt\n    return np.mean(np.sqrt(np.maximum(0, variances)))\n\ndef solve():\n    \"\"\"\n    Main function to solve the time-lapse inverse problem for the given test cases.\n    \"\"\"\n    N = 20\n    T = 3\n    sigma_h = 0.05\n    \n    # Use a fixed seed for reproducibility of synthetic noise\n    rng = np.random.default_rng(0)\n\n    # Spatial grid\n    s = np.linspace(0, 1, N)\n\n    # True model generation\n    x_true = np.zeros((T, N))\n    x_true[0, :] = 0.1 * np.sin(2 * np.pi * s) + np.exp(-(s - 0.3)**2 / (2 * 0.05**2))\n    x_true[1, :] = 0.1 * np.sin(2 * np.pi * s) + 0.8 * np.exp(-(s - 0.5)**2 / (2 * 0.05**2))\n    x_true[2, :] = 0.1 * np.sin(2 * np.pi * s) + 0.6 * np.exp(-(s - 0.7)**2 / (2 * 0.05**2))\n\n    # Spatial difference operator D\n    D = np.eye(N) - np.roll(np.eye(N), 1, axis=0)\n    D[0, N-1] = -1\n    DtD = D.T @ D\n    \n    # Temporal difference operator T_op\n    T_op_blocks = []\n    for k in range(T - 1):\n        row = [np.zeros((N, N))] * T\n        row[k] = -np.eye(N)\n        row[k+1] = np.eye(N)\n        T_op_blocks.append(np.hstack(row))\n    T_op = np.vstack(T_op_blocks)\n    T_op_t_T_op = T_op.T @ T_op\n\n    test_cases = [\n        # (M, sigma, lambda_s, lambda_delta, lambda_t, beta, q)\n        (20, 0.01, 0.01, 0.01, 0.01, 0.01, 0.005),\n        (20, 0.05, 0.02, 0.02, 0.02, 0.02, 0.01),\n        (10, 0.02, 0.01, 0.01, 0.005, 0.01, 0.005),\n    ]\n\n    results = []\n\n    for M, sigma, lambda_s, lambda_delta, lambda_t, beta, q in test_cases:\n        # Observation operator H\n        r = np.linspace(0, 1, M)\n        H = np.exp(-(s[np.newaxis, :] - r[:, np.newaxis])**2 / (2 * sigma_h**2))\n        HtH = H.T @ H\n\n        # Generate noisy data\n        y = np.zeros((T, M))\n        for k in range(T):\n            noise = rng.normal(0, sigma, M)\n            y[k, :] = H @ x_true[k, :] + noise\n\n        # --- 1. Stabilized Difference Inversion (SDI) ---\n        # Estimators\n        A1_sdi = (1/sigma**2) * HtH + lambda_s * DtD\n        A_delta_sdi = (1/sigma**2) * HtH + lambda_delta * DtD\n        \n        inv_A1_sdi = np.linalg.inv(A1_sdi)\n        inv_A_delta_sdi = np.linalg.inv(A_delta_sdi)\n        \n        rhs1 = (1/sigma**2) * H.T @ y[0]\n        x1_hat_sdi = inv_A1_sdi @ rhs1\n        \n        delta_x_hat_sum = np.zeros(N)\n        for k in range(1, T):\n            delta_y = y[k] - y[k-1]\n            rhs_delta = (1/sigma**2) * H.T @ delta_y\n            delta_x_hat_k = inv_A_delta_sdi @ rhs_delta\n            delta_x_hat_sum += delta_x_hat_k\n            \n        xT_hat_sdi = x1_hat_sdi + delta_x_hat_sum\n        \n        # Metrics for SDI\n        rmse_sdi = np.sqrt(np.mean((xT_hat_sdi - x_true[T-1, :])**2))\n        \n        Sigma_post_1_sdi = inv_A1_sdi\n        Sigma_post_delta_sdi = inv_A_delta_sdi\n        Sigma_post_T_sdi = Sigma_post_1_sdi + (T-1) * Sigma_post_delta_sdi\n        post_std_sdi = calculate_average_posterior_std(Sigma_post_T_sdi)\n\n        R_T_sdi = Sigma_post_delta_sdi @ ((1/sigma**2) * HtH)\n        res_width_sdi = calculate_average_resolution_width(R_T_sdi, s)\n        \n        results.extend([rmse_sdi, res_width_sdi, post_std_sdi])\n        \n        # --- Common matrices for JI and 4D-Var ---\n        NT = N * T\n        H_cal = block_diag(*([H] * T))\n        H_cal_T_H_cal = block_diag(*([HtH] * T))\n        H_cal_T_y = np.concatenate([H.T @ yk for yk in y])\n\n        # --- 2. Joint Inversion (JI) ---\n        Gamma_JI = lambda_s * block_diag(*([DtD] * T)) + lambda_t * T_op_t_T_op\n        A_JI = (1/sigma**2) * H_cal_T_H_cal + Gamma_JI\n        rhs_JI = (1/sigma**2) * H_cal_T_y\n        \n        X_hat_ji = np.linalg.solve(A_JI, rhs_JI)\n        xT_hat_ji = X_hat_ji[(T-1)*N:]\n        \n        # Metrics for JI\n        rmse_ji = np.sqrt(np.mean((xT_hat_ji - x_true[T-1,:])**2))\n        \n        Sigma_post_JI = np.linalg.inv(A_JI)\n        Sigma_post_T_ji = Sigma_post_JI[(T-1)*N:, (T-1)*N:]\n        post_std_ji = calculate_average_posterior_std(Sigma_post_T_ji)\n        \n        R_mod_JI = Sigma_post_JI @ ((1/sigma**2) * H_cal_T_H_cal)\n        R_TT_ji = R_mod_JI[(T-1)*N:, (T-1)*N:]\n        res_width_ji = calculate_average_resolution_width(R_TT_ji, s)\n        \n        results.extend([rmse_ji, res_width_ji, post_std_ji])\n        \n        # --- 3. Four-Dimensional Variational (4D-Var) ---\n        D1tD1 = np.zeros((NT, NT))\n        D1tD1[:N, :N] = DtD\n        Gamma_4D = beta * D1tD1 + (1/q) * T_op_t_T_op\n        A_4D = (1/sigma**2) * H_cal_T_H_cal + Gamma_4D\n        rhs_4D = (1/sigma**2) * H_cal_T_y\n\n        X_hat_4d = np.linalg.solve(A_4D, rhs_4D)\n        xT_hat_4d = X_hat_4d[(T-1)*N:]\n\n        # Metrics for 4D-Var\n        rmse_4d = np.sqrt(np.mean((xT_hat_4d - x_true[T-1,:])**2))\n\n        Sigma_post_4D = np.linalg.inv(A_4D)\n        Sigma_post_T_4d = Sigma_post_4D[(T-1)*N:, (T-1)*N:]\n        post_std_4d = calculate_average_posterior_std(Sigma_post_T_4d)\n        \n        R_mod_4D = Sigma_post_4D @ ((1/sigma**2) * H_cal_T_H_cal)\n        R_TT_4d = R_mod_4D[(T-1)*N:, (T-1)*N:]\n        res_width_4d = calculate_average_resolution_width(R_TT_4d, s)\n        \n        results.extend([rmse_4d, res_width_4d, post_std_4d])\n\n    return f\"[{','.join(f'{r:.6f}' for r in results)}]\"\n\n# The output of this function is placed in the answer tag.\n```",
            "answer": "[0.038139,0.063260,0.035787,0.030616,0.061730,0.024479,0.034568,0.060163,0.023240,0.069412,0.064115,0.052697,0.061324,0.062829,0.046313,0.062095,0.062030,0.045656,0.052210,0.071853,0.034079,0.037599,0.070054,0.030999,0.037989,0.070119,0.030368]"
        }
    ]
}