{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握一种迭代方法，最好的方式莫过于亲手计算几步。本练习将引导您在一个简化的计算机断层扫描（CT）模型中，手动执行代-数重建技术（ART）的核心步骤。通过这个过程，您将具体地理解如何利用每一次的测量（即射线投影）数据，通过几何投影来逐步更新和修正图像估计值。",
            "id": "3393590",
            "problem": "考虑一个简单的平行束计算机断层扫描（CT）离散化，其作用于一个由单位正方形像素组成的 $3\\times 3$ 像素网格。设未知图像由一个行主序的向量 $x \\in \\mathbb{R}^{9}$ 表示，即 $x = (x_{1}, x_{2}, x_{3}, x_{4}, x_{5}, x_{6}, x_{7}, x_{8}, x_{9})$ 对应于从上到下、从左到右的像素。前向模型是标准的线积分离散化：每次测量值是像素值乘以射线穿过该像素的路径长度的加权和。测量被建模为 $A x = b$，其中 $A$ 的每一行对应一条射线，$b$ 包含相应记录的线积分。\n\n给定四条射线：\n- 射线 $R_{1}$：水平穿过中间行，穿过像素 $(x_{4}, x_{5}, x_{6})$，路径长度分别为 $1, 1, 1$。\n- 射线 $R_{2}$：垂直穿过中间列，穿过像素 $(x_{2}, x_{5}, x_{8})$，路径长度分别为 $1, 1, 1$。\n- 射线 $R_{3}$：主对角线，从左上到右下，穿过像素 $(x_{1}, x_{5}, x_{9})$，在每个穿过的像素中路径长度为 $\\sqrt{2}$。\n- 射线 $R_{4}$：反对角线，从右上到左下，穿过像素 $(x_{3}, x_{5}, x_{7})$，在每个穿过的像素中路径长度为 $\\sqrt{2}$。\n\n记录的测量值为\n$$\nb = \\big(4,\\ 6,\\ 4\\sqrt{2},\\ 5\\sqrt{2}\\big).\n$$\n\n任务：\n1. 根据给定的几何结构，显式地组装系统矩阵 $A \\in \\mathbb{R}^{4\\times 9}$。\n2. 从初始猜测 $x^{(0)} = 0 \\in \\mathbb{R}^{9}$ 开始，使用松弛参数为 $1$ 的 Kaczmarz 方法执行两轮代数重建技术（ART）的连续迭代，依次投影到由 $R_{1}$ 和 $R_{2}$ 定义的超平面上（即，第一步使用 $A$ 的第一行及其测量值，第二步使用第二行）。\n3. 将经过恰好两步 ART 更新后的像素向量 $x^{(2)}$ 以单个行向量的形式报告。\n\n以精确形式表示最终答案，不要四舍五入。将答案以单个行矩阵的形式提供。",
            "solution": "我们从线积分断层扫描的标准线性前向模型开始：对于索引为 $i$ 的每条射线，其测量值为 $b_{i} = \\sum_{j=1}^{9} a_{ij} x_{j}$，其中 $a_{ij}$ 是射线 $i$ 穿过像素 $j$ 的路径长度。组装矩阵 $A$ 需要确定每条射线与哪些像素相交，并将矩阵中相应条目设置为对应的路径长度；所有其他条目均为零。\n\n根据给定的几何结构：\n- 对于射线 $R_{1}$（中间行），非零条目位于像素 $(x_{4}, x_{5}, x_{6})$ 处，路径长度为 $1, 1, 1$，所以第一行为\n$$\na_{1\\cdot} = (0,\\ 0,\\ 0,\\ 1,\\ 1,\\ 1,\\ 0,\\ 0,\\ 0).\n$$\n- 对于射线 $R_{2}$（中间列），非零条目位于像素 $(x_{2}, x_{5}, x_{8})$ 处，路径长度为 $1, 1, 1$，所以第二行为\n$$\na_{2\\cdot} = (0,\\ 1,\\ 0,\\ 0,\\ 1,\\ 0,\\ 0,\\ 1,\\ 0).\n$$\n- 对于射线 $R_{3}$（主对角线），非零条目位于像素 $(x_{1}, x_{5}, x_{9})$ 处，路径长度为 $\\sqrt{2}$，所以第三行为\n$$\na_{3\\cdot} = (\\sqrt{2},\\ 0,\\ 0,\\ 0,\\ \\sqrt{2},\\ 0,\\ 0,\\ 0,\\ \\sqrt{2}).\n$$\n- 对于射线 $R_{4}$（反对角线），非零条目位于像素 $(x_{3}, x_{5}, x_{7})$ 处，路径长度为 $\\sqrt{2}$，所以第四行为\n$$\na_{4\\cdot} = (0,\\ 0,\\ \\sqrt{2},\\ 0,\\ \\sqrt{2},\\ 0,\\ \\sqrt{2},\\ 0,\\ 0).\n$$\n\n因此，\n$$\nA = \n\\begin{pmatrix}\n0  0  0  1  1  1  0  0  0 \\\\\n0  1  0  0  1  0  0  1  0 \\\\\n\\sqrt{2}  0  0  0  \\sqrt{2}  0  0  0  \\sqrt{2} \\\\\n0  0  \\sqrt{2}  0  \\sqrt{2}  0  \\sqrt{2}  0  0\n\\end{pmatrix},\n\\quad\nb = \n\\begin{pmatrix}\n4 \\\\ 6 \\\\ 4\\sqrt{2} \\\\ 5\\sqrt{2}\n\\end{pmatrix}.\n$$\n\n接下来，我们应用代数重建技术（ART），这与 Kaczmarz 方法一致，可视为在超平面 $\\{x: a_{i\\cdot} x = b_{i}\\}$ 上的顺序正交投影。对于单行 $a_{i\\cdot}$ 和松弛参数为 $1$ 的 Kaczmarz 更新推导如下。超平面 $\\mathcal{H}_{i} = \\{x \\in \\mathbb{R}^{9} : a_{i\\cdot} x = b_{i}\\}$ 的法向量是 $a_{i\\cdot}^{\\top}$。点 $x^{(k)}$ 在 $\\mathcal{H}_{i}$ 上的正交投影是\n$$\nx^{(k+1)} = x^{(k)} + \\frac{b_{i} - a_{i\\cdot} x^{(k)}}{\\|a_{i\\cdot}\\|^{2}}\\, a_{i\\cdot}^{\\top},\n$$\n通过沿法线方向减去有符号距离，并按法线范数的平方的倒数进行缩放得到，从而确保 $a_{i\\cdot} x^{(k+1)} = b_{i}$。\n\n我们被要求从 $x^{(0)} = 0$ 开始执行两次连续迭代，首先使用第 1 行，然后使用第 2 行。\n\n第 1 步 (使用 $i=1$):\n- 计算范数的平方 $\\|a_{1\\cdot}\\|^{2}$。由于 $a_{1\\cdot}$ 有三个等于 $1$ 的条目，其余为零，我们得到 $\\|a_{1\\cdot}\\|^{2} = 1^{2} + 1^{2} + 1^{2} = 3$。\n- 计算 $a_{1\\cdot} x^{(0)} = 0$，因为 $x^{(0)} = 0$。\n- 计算校正因子 $c_{1} = \\dfrac{b_{1} - a_{1\\cdot} x^{(0)}}{\\|a_{1\\cdot}\\|^{2}} = \\dfrac{4 - 0}{3} = \\dfrac{4}{3}$。\n- 更新：\n$$\nx^{(1)} = x^{(0)} + c_{1} a_{1\\cdot}^{\\top}.\n$$\n由于 $a_{1\\cdot}^{\\top}$ 在位置 $4, 5, 6$ 处为 1，其余位置为 0，我们得到\n$$\nx^{(1)} = (0,\\ 0,\\ 0,\\ \\tfrac{4}{3},\\ \\tfrac{4}{3},\\ \\tfrac{4}{3},\\ 0,\\ 0,\\ 0).\n$$\n\n第 2 步 (使用 $i=2$):\n- 计算范数的平方 $\\|a_{2\\cdot}\\|^{2}$。同样，有三个条目等于 $1$，所以 $\\|a_{2\\cdot}\\|^{2} = 3$。\n- 计算 $a_{2\\cdot} x^{(1)} = x_{2}^{(1)} + x_{5}^{(1)} + x_{8}^{(1)} = 0 + \\tfrac{4}{3} + 0 = \\tfrac{4}{3}$。\n- 计算校正因子 $c_{2} = \\dfrac{b_{2} - a_{2\\cdot} x^{(1)}}{\\|a_{2\\cdot}\\|^{2}} = \\dfrac{6 - \\tfrac{4}{3}}{3} = \\dfrac{\\tfrac{18}{3} - \\tfrac{4}{3}}{3} = \\dfrac{\\tfrac{14}{3}}{3} = \\dfrac{14}{9}$。\n- 更新：\n$$\nx^{(2)} = x^{(1)} + c_{2} a_{2\\cdot}^{\\top}.\n$$\n由于 $a_{2\\cdot}^{\\top}$ 在位置 $2, 5, 8$ 处为 1，其余位置为 0，我们得到\n$$\nx^{(2)} = (0,\\ \\tfrac{14}{9},\\ 0,\\ \\tfrac{4}{3},\\ \\tfrac{4}{3} + \\tfrac{14}{9},\\ \\tfrac{4}{3},\\ 0,\\ \\tfrac{14}{9},\\ 0).\n$$\n合并中间元素：\n$$\n\\tfrac{4}{3} + \\tfrac{14}{9} = \\tfrac{12}{9} + \\tfrac{14}{9} = \\tfrac{26}{9}.\n$$\n因此，\n$$\nx^{(2)} = \\left(0,\\ \\tfrac{14}{9},\\ 0,\\ \\tfrac{4}{3},\\ \\tfrac{26}{9},\\ \\tfrac{4}{3},\\ 0,\\ \\tfrac{14}{9},\\ 0\\right).\n$$\n\n这就是在指定顺序下经过两步 ART 更新后的精确像素向量。",
            "answer": "$$\\boxed{\\begin{pmatrix}0  \\tfrac{14}{9}  0  \\tfrac{4}{3}  \\tfrac{26}{9}  \\tfrac{4}{3}  0  \\tfrac{14}{9}  0\\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了基本的投影更新机制后，我们来探讨一个在实际应用中更常见也更微妙的情形。真实世界的问题往往带有约束条件，例如图像的像素值不能为负。本练习将通过一个精心设计的反例揭示，当约束存在时，简单地交替投影可能会导致算法陷入循环而无法收敛。通过解决这个问题，您将深刻体会到松弛参数在确保收敛性方面扮演的关键角色。",
            "id": "3393618",
            "problem": "考虑一个用于代数重建技术（ART）的二维线性化层析成像玩具模型，其中重建向量为 $x \\in \\mathbb{R}^{2}$。传感射线产生两个仿射超平面 $H_{1}$ 和 $H_{2}$，其定义为 $a^{\\top} x = b_{i}$，其中 $a = (1, 1)^{\\top}$，$b_{1} = 2 + d$，$b_{2} = -d$，对于一个固定参数 $d  0$。容许的先验约束集是轴对齐的盒子 $\\mathcal{C} = [0,1]^{2}$。ART 更新交替进行以下操作：使用松弛 Kaczmarz 步投影到 $H_{i}$ 上，然后通过投影到 $\\mathcal{C}$ 上来施加约束。具体来说，对于索引 $i \\in \\{1, 2\\}$，带松弛参数 $\\alpha \\in (0,2)$ 的 Kaczmarz 更新为\n$$\nx^{+} = x + \\alpha \\frac{b_{i} - a^{\\top} x}{\\|a\\|^{2}} a,\n$$\n约束施加为 $x \\leftarrow P_{\\mathcal{C}}(x)$，其中 $P_{\\mathcal{C}}$ 表示到 $\\mathcal{C}$ 上的欧几里得投影算子。\n\n从 $x_{0} = (1,1)^{\\top}$ 开始迭代，并按 $(i=2)$ 然后 $(i=1)$ 的顺序循环交替索引，每次应用松弛 Kaczmarz 步，随后投影到 $\\mathcal{C}$ 上。你的任务是：\n\n1. 仅使用上述定义（到仿射超平面上的正交投影、带松弛的 Kaczmarz 更新以及到闭合凸集上的欧几里得投影），为 $\\alpha = 1$ 的选择构造一个反例，证明当 $d  0$ 时，序列在不同的点之间循环。\n\n2. 从第一性原理出发，推导出一个作为 $d$ 的函数的紧上界 $\\alpha_{\\max}$，使得对于任何 $\\alpha \\in (0,\\alpha_{\\max}]$，从 $x_{0}$ 开始的两步复合操作“先投影到 $H_{2}$，再投影到 $\\mathcal{C}$，然后投影到 $H_{1}$，再投影到 $\\mathcal{C}$”所产生的迭代点能保持在 $\\mathcal{C}$ 内，而不会激活边界处的裁剪，从而防止循环并在对称轴 $x_{1} = x_{2}$ 上产生线性收缩。\n\n为使数值具体，设 $d = \\sqrt{7}$。提供 $\\alpha_{\\max}$ 关于 $d$ 的精确闭式表达式，并在 $d = \\sqrt{7}$ 处求值。将你的最终答案表示为单个精确表达式。无需四舍五入，不涉及单位。",
            "solution": "按要求分两部分对问题进行分析。首先，我们展示标准 Kaczmarz 方法（$\\alpha=1$）的循环行为。其次，我们推导松弛参数 $\\alpha$ 的紧上界，该上界通过在给定的迭代过程中避免激活边界投影来防止这种循环。\n\n问题在 $\\mathbb{R}^2$ 中定义了两个平行的仿射超平面 $H_1$ 和 $H_2$：\n$$H_1: x_1 + x_2 = 2+d$$\n$$H_2: x_1 + x_2 = -d$$\n其中 $x = (x_1, x_2)^{\\top}$。这些方程可以写成 $a^{\\top}x = b_i$ 的形式，其中 $a = (1,1)^{\\top}$，$b_1 = 2+d$，$b_2 = -d$。$a$ 的范数平方为 $\\|a\\|^2 = 1^2 + 1^2 = 2$。\n\nART 迭代涉及两个算子：\n1.  对超平面 $H_i$ 的松弛 Kaczmarz 步：\n    $$K_i(x) = x + \\alpha \\frac{b_i - a^{\\top}x}{\\|a\\|^2}a$$\n2.  到约束集 $\\mathcal{C}=[0,1]^2$ 上的欧几里得投影：\n    $$P_{\\mathcal{C}}(y) = (\\max(0, \\min(1, y_1)), \\max(0, \\min(1, y_2)))^{\\top}$$\n\n单步的完整算子为 $T_i(x) = P_{\\mathcal{C}}(K_i(x))$。迭代序列由 $x_{k+1} = T_{i_k}(x_k)$ 定义，初始点为 $x_0 = (1,1)^{\\top}$，索引循环为 $i_k \\in \\{2, 1, 2, 1, \\dots\\}$。\n\n**第一部分：$\\alpha=1$ 的反例**\n\n对于 $\\alpha=1$，Kaczmarz 步成为到超平面上的正交投影 $P_{H_i}(x)$。我们从 $x_0 = (1,1)^{\\top}$ 开始。\n\n**迭代 1 (k=0, i=2):**\n首先，我们对 $H_2$ 应用 Kaczmarz 步。\n$$x_{0.5} = K_2(x_0) = x_0 + \\frac{b_2 - a^{\\top}x_0}{\\|a\\|^2}a$$\n其中 $a^{\\top}x_0 = 1+1=2$，$b_2=-d$，以及 $\\|a\\|^2=2$：\n$$x_{0.5} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} + \\frac{-d - 2}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{d+2}{2} \\\\ 1 - \\frac{d+2}{2} \\end{pmatrix} = \\begin{pmatrix} -\\frac{d}{2} \\\\ -\\frac{d}{2} \\end{pmatrix}$$\n接下来，我们投影到 $\\mathcal{C}=[0,1]^2$ 上。因为 $d0$，我们有 $-d/2  0$。\n$$x_1 = T_2(x_0) = P_{\\mathcal{C}}(x_{0.5}) = P_{\\mathcal{C}}\\left(\\begin{pmatrix} -d/2 \\\\ -d/2 \\end{pmatrix}\\right) = \\begin{pmatrix} \\max(0, \\min(1, -d/2)) \\\\ \\max(0, \\min(1, -d/2)) \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$$\n\n**迭代 2 (k=1, i=1):**\n现在我们从 $x_1=(0,0)^{\\top}$ 开始应用算子。Kaczmarz 步是针对 $H_1$ 的。\n$$x_{1.5} = K_1(x_1) = x_1 + \\frac{b_1 - a^{\\top}x_1}{\\|a\\|^2}a$$\n其中 $a^{\\top}x_1 = 0+0=0$ 且 $b_1=2+d$：\n$$x_{1.5} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} + \\frac{2+d - 0}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 + \\frac{d}{2} \\\\ 1 + \\frac{d}{2} \\end{pmatrix}$$\n接下来，我们投影到 $\\mathcal{C}$ 上。因为 $d0$，我们有 $1+d/2  1$。\n$$x_2 = T_1(x_1) = P_{\\mathcal{C}}(x_{1.5}) = P_{\\mathcal{C}}\\left(\\begin{pmatrix} 1+d/2 \\\\ 1+d/2 \\end{pmatrix}\\right) = \\begin{pmatrix} \\max(0, \\min(1, 1+d/2)) \\\\ \\max(0, \\min(1, 1+d/2)) \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$$\n我们发现 $x_2=x_0$。继续这个过程将得到 $x_3=x_1=(0,0)^{\\top}$，$x_4=x_2=(1,1)^{\\top}$，以此类推。序列在两个不同的点 $(1,1)^{\\top}$ 和 $(0,0)^{\\top}$ 之间循环。这就提供了所需的反例。循环是由投影算子 $P_{\\mathcal{C}}$ 的裁剪作用引起的。\n\n**第二部分：$\\alpha_{\\max}(d)$ 的推导**\n\n题目要求我们找到 $\\alpha$ 的紧上界 $\\alpha_{\\max}$，使得从 $x_0=(1,1)^{\\top}$ 开始的迭代序列 $x_{k+1} = T_1(T_2(x_k))$ 保持在 $\\mathcal{C}$ 内而不激活裁剪。这意味着在每一步，Kaczmarz 算子 $K_i$ 的输出必须已经位于 $\\mathcal{C}$ 之内。\n\n设 $x_k = (\\xi_k, \\xi_k)^{\\top}$。问题的对称性和 $x_0$ 的选择确保，在没有发生裁剪的前提下，所有迭代点都位于直线 $x_1=x_2$ 上。我们分析标量序列 $\\xi_k$。\n\n无裁剪的两步复合操作如下：\n1.  $x_{k+0.5} = K_2(x_k) = x_k + \\alpha \\frac{-d - a^{\\top}x_k}{\\|a\\|^2}a$。标量分量是 $\\xi_{k+0.5} = \\xi_k + \\alpha \\frac{-d - 2\\xi_k}{2} = (1-\\alpha)\\xi_k - \\frac{\\alpha d}{2}$。\n2.  $x_{k+1} = K_1(x_{k+0.5}) = x_{k+0.5} + \\alpha \\frac{2+d - a^{\\top}x_{k+0.5}}{\\|a\\|^2}a$。标量分量是 $\\xi_{k+1} = \\xi_{k+0.5} + \\alpha \\frac{2+d - 2\\xi_{k+0.5}}{2} = (1-\\alpha)\\xi_{k+0.5} + \\alpha(1+\\frac{d}{2})$。\n\n结合这些，我们得到 $\\xi_k$ 的递推关系：\n$$\\xi_{k+1} = (1-\\alpha)\\left((1-\\alpha)\\xi_k - \\frac{\\alpha d}{2}\\right) + \\alpha\\left(1+\\frac{d}{2}\\right)$$\n$$\\xi_{k+1} = (1-\\alpha)^2 \\xi_k - \\frac{\\alpha d(1-\\alpha)}{2} + \\alpha\\left(1+\\frac{d}{2}\\right)$$\n$$\\xi_{k+1} = (1-\\alpha)^2 \\xi_k + \\alpha\\left(1+\\frac{d}{2} - \\frac{d(1-\\alpha)}{2}\\right) = (1-\\alpha)^2 \\xi_k + \\alpha\\left(1+\\frac{\\alpha d}{2}\\right)$$\n\n这是一个 $\\xi_{k+1} = A\\xi_k+B$ 形式的线性递推关系，其中 $A=(1-\\alpha)^2$ 且 $B=\\alpha(1+\\alpha d/2)$。对于 $\\alpha \\in (0,2)$，有 $|A|1$，所以序列收敛到一个满足 $\\xi^* = A\\xi^*+B$ 的不动点 $\\xi^*$：\n$$\\xi^*(1 - (1-\\alpha)^2) = \\alpha(1+\\alpha d/2) \\implies \\xi^*\\alpha(2-\\alpha) = \\alpha(1+\\alpha d/2)$$\n$$\\xi^* = \\frac{1+\\alpha d/2}{2-\\alpha}$$\n\n“无裁剪”约束意味着对于任何 $\\xi_k \\in [0,1]$ 的迭代点 $x_k=(\\xi_k,\\xi_k)^{\\top}$，中间点 $x_{k+0.5}$ 和下一个迭代点 $x_{k+1}$ 都必须位于 $\\mathcal{C}$ 内。\n这些点的分量必须在 $[0,1]$ 内。\n序列从 $\\xi_0=1$ 开始。不动点 $\\xi^*$ 必须在 $[0,1]$ 内，序列才可能保持在区间 $[0,1]$ 内。对于 $\\alpha \\in(0,2)$ 和 $d0$，$\\xi^*  0$ 总是成立的。条件 $\\xi^* \\le 1$ 给出：\n$$\\frac{1+\\alpha d/2}{2-\\alpha} \\le 1 \\implies 1+\\frac{\\alpha d}{2} \\le 2-\\alpha \\implies \\alpha\\left(1+\\frac{d}{2}\\right) \\le 1 \\implies \\alpha \\le \\frac{2}{d+2}$$\n这提供了关于 $\\alpha$ 的一个必要条件。我们称之为 $\\alpha_{max,1} = \\frac{2}{d+2}$。对于 $\\alpha \\le \\alpha_{max,1}$，序列 $\\xi_k$ 从 $\\xi_0=1$ 开始，单调递减地收敛到 $\\xi^* \\in [0,1]$。因此，所有 $\\xi_k \\in [\\xi^*, 1] \\subset [0,1]$。\n\n现在我们必须验证，对于任何 $\\xi \\in [\\xi^*, 1]$，一个完整步骤的中间点和终点都在 $[0,1]$ 内。\n1.  $K_2(x)$ 的分量：$\\xi_{k+0.5} = (1-\\alpha)\\xi_k - \\alpha d/2$。我们需要 $0 \\le \\xi_{k+0.5} \\le 1$。\n    -   $\\xi_{k+0.5} \\le (1-\\alpha) \\cdot 1 - \\alpha d/2 = 1 - \\alpha(1+d/2) = 1-\\alpha\\frac{d+2}{2}$。对于 $\\alpha \\le \\frac{2}{d+2}$，这是非负的。但我们需要证明 $\\xi_{k+0.5} \\le 1$。对于 $\\xi_k \\in [0,1]$ 和 $\\alpha  1$，有 $(1-\\alpha)\\xi_k \\le 1-\\alpha$。所以 $\\xi_{k+0.5} \\le 1-\\alpha-\\alpha d/2  1$。所以上界是满足的。\n    -   关键约束是 $0 \\le \\xi_{k+0.5}$。函数 $(1-\\alpha)\\xi - \\alpha d/2$ 在 $\\alpha1$ 时是关于 $\\xi$ 的增函数（由于 $d0$，如果 $\\alpha \\le \\frac{2}{d+2}$，这个条件成立）。最小值在 $\\xi = \\xi^*$ 处取得。\n    $$0 \\le (1-\\alpha)\\xi^* - \\frac{\\alpha d}{2} = (1-\\alpha)\\frac{1+\\alpha d/2}{2-\\alpha} - \\frac{\\alpha d}{2}$$\n    $$0 \\le \\frac{(1-\\alpha)(1+\\alpha d/2) - \\alpha d/2(2-\\alpha)}{2-\\alpha} = \\frac{1-\\alpha -\\alpha d/2}{2-\\alpha}$$\n    由于 $2-\\alpha0$，这意味着 $1-\\alpha - \\alpha d/2 \\ge 0$，即 $1 \\ge \\alpha(1+d/2)$，或 $\\alpha \\le \\frac{2}{d+2}$。这正是我们前面找到的条件。\n\n2.  $K_1(K_2(x))$ 的分量：这正是 $\\xi_{k+1}$。我们需要 $0 \\le \\xi_{k+1} \\le 1$。\n    由于映射 $\\xi_k \\to \\xi_{k+1}$ 将区间 $[\\xi^*, 1]$ 映射到 $[\\xi^*, \\xi_1]$，我们只需确认这个范围在 $[0,1]$ 之内。我们已经确定 $\\xi^* \\ge 0$。我们还需要 $\\xi_1 \\le 1$。\n    $\\xi_1 = (1-\\alpha)^2 \\xi_0 + \\alpha(1+\\alpha d/2)$，其中 $\\xi_0=1$。\n    $\\xi_1 = (1-\\alpha)^2 + \\alpha(1+\\alpha d/2) = 1 - 2\\alpha + \\alpha^2 + \\alpha + \\alpha^2 d/2 = 1 - \\alpha + \\alpha^2(1+d/2)$。\n    条件 $\\xi_1 \\le 1$ 给出 $-\\alpha + \\alpha^2(1+d/2) \\le 0$。由于 $\\alpha0$，我们可以除以它：$-1+\\alpha(1+d/2) \\le 0$，这意味着 $\\alpha \\le \\frac{1}{1+d/2} = \\frac{2}{d+2}$。\n\n两个条件都导出了相同的约束：$\\alpha \\le \\frac{2}{d+2}$。这个界是紧的，因为如果 $\\alpha = \\frac{2}{d+2} + \\epsilon$ 对于某个小的 $\\epsilon0$，那么第一步就会是：\n$x_{0.5} = K_2(x_0)$，其分量为 $1 - \\alpha \\frac{d+2}{2} = 1 - (\\frac{2}{d+2}+\\epsilon)\\frac{d+2}{2} = 1-(1+\\epsilon\\frac{d+2}{2})  0$。这将激活边界处的裁剪。因此，紧上界是：\n$$\\alpha_{\\max} = \\frac{2}{d+2}$$\n\n最后，我们对 $d=\\sqrt{7}$ 计算此表达式的值。\n$$\\alpha_{\\max} = \\frac{2}{2+\\sqrt{7}} = \\frac{2(2-\\sqrt{7})}{(2+\\sqrt{7})(2-\\sqrt{7})} = \\frac{2(2-\\sqrt{7})}{4-7} = \\frac{2(2-\\sqrt{7})}{-3} = \\frac{2(\\sqrt{7}-2)}{3}$$",
            "answer": "$$\\boxed{\\frac{2(\\sqrt{7}-2)}{3}}$$"
        },
        {
            "introduction": "Kaczmarz方法的思想不仅限于求解线性系统 $Ax=b$。本练习将此概念推广到更广泛的非线性问题 $F(x)=b$ 中，介绍强大的牛顿-Kaczmarz方法。该方法巧妙地将Kaczmarz方法的逐行处理策略与牛顿法的线性化思想相结合，通过一个编程实践，您将把理论知识转化为一个可执行的算法，从而架起理论与实际应用之间的桥梁。",
            "id": "3393632",
            "problem": "考虑一个非线性方程组 $F(x) = b$，其中 $F : \\mathbb{R}^n \\to \\mathbb{R}^m$，$F(x) = \\left(F_1(x), \\dots, F_m(x)\\right)^\\top$ 且 $b \\in \\mathbb{R}^m$。假设 $F$ 在满足 $F(x^\\star) = b$ 的解 $x^\\star \\in \\mathbb{R}^n$ 的一个开邻域内是连续可微的，并且雅可比矩阵 $J_F(x) \\in \\mathbb{R}^{m \\times n}$ 的行是 $\\nabla F_i(x)^\\top \\in \\mathbb{R}^n$。Newton–Kaczmarz 方法通过循环遍历分量函数 $F_i$ 来执行标量化的 Gauss–Newton 更新，并在每一步中，在当前迭代点处对标量方程 $F_i(x) = b_i$ 进行线性化。一个阻尼因子 $\\omega \\in (0,2)$ 对更新量进行缩放。当某些 $i$ 的方向导数可能为零时，实现中必须在分母小于给定阈值 $\\tau  0$ 时跳过更新，以避免除以一个过于接近零的数。\n\n您的任务是：\n\n- 在以下假设下，从第一性原理出发，为阻尼循环 Newton–Kaczmarz 方法推导一个局部收敛性结果：\n  - 雅可比矩阵 $J_F$ 在 $x^\\star$ 的一个邻域内是 Lipschitz 连续的，Lipschitz 常数为 $L \\ge 0$，即对于邻域内所有的 $x, y$ 和所有的 $i \\in \\{1,\\dots,m\\}$，都有 $\\|\\nabla F_i(x) - \\nabla F_i(y)\\| \\le L \\|x - y\\|$。\n  - 解处的雅可比矩阵 $J_F(x^\\star)$ 具有满列秩 $n$。\n  - 阻尼因子满足 $\\omega \\in (0,2)$。\n  - 使用循环控制序列，即索引 $i$ 在每一步增加 $1$（模 $m$）。\n  - 存在 $\\tau  0$，使得当 $\\|\\nabla F_i(x)\\|^2  \\tau$ 时跳过更新。\n  以一个循环内的收缩不等式和二阶余项的形式，给出一个严格的局部收敛性陈述，并指明常数如何依赖于问题数据。从雅可比矩阵的 Lipschitz 连续性的基本定义和逐分量应用的中值定理开始；不要使用任何现成的收敛定理。您的推导应阐明“局部”在 $x^\\star$ 邻域方面的含义，以及阻尼 $\\omega$ 如何影响收缩因子。\n\n- 实现阻尼循环 Newton–Kaczmarz 方法，对于给定的 $F$ 和 $b$，在索引为 $i = (k \\bmod m) + 1$ 的第 $k$ 次迭代中执行以下操作：\n  - 计算标量残差 $r_i(x_k) = b_i - F_i(x_k)$ 和梯度 $g_i(x_k) = \\nabla F_i(x_k)$。\n  - 如果 $\\|g_i(x_k)\\|^2 \\ge \\tau$，则更新 $x_{k+1} = x_k + \\omega \\, \\frac{r_i(x_k)}{\\|g_i(x_k)\\|^2} g_i(x_k)$；否则设置 $x_{k+1} = x_k$ (跳过)。\n  该方法应运行指定数量的完整扫描，其中一次扫描等于 $m$ 次迭代。\n\n对于数值实验，您将使用一个受代数重建技术启发的非线性族。固定一个矩阵 $A \\in \\mathbb{R}^{m \\times n}$，其行为 $a_i^\\top \\in \\mathbb{R}^n$，以及一个标量非线性参数 $c \\ge 0$。定义分量函数\n$$\nF_i(x) = a_i^\\top x + \\frac{c}{2} \\left(a_i^\\top x\\right)^2 \\quad \\text{for } i \\in \\{1,\\dots,m\\}.\n$$\n那么 $\\nabla F_i(x) = \\left(1 + c \\, a_i^\\top x\\right) a_i$。给定一个目标解 $x^\\star \\in \\mathbb{R}^n$，通过 $b_i = F_i(x^\\star)$ 定义 $b \\in \\mathbb{R}^m$，下面的不一致含噪声情况除外。\n\n您必须实现您的程序来运行以下四个测试用例。在所有用例中，使用欧几里得范数、跳过阈值 $\\tau = 10^{-12}$、循环控制和指定的精确阻尼。\n\n- 测试用例 1 (条件良好，适度非线性，接近初始值):\n  - $n = 3$, $m = 6$, $c = 1$。\n  - $A = \\begin{bmatrix}\n  1  2  -1 \\\\\n  0.5  -1  1.5 \\\\\n  2  0  1 \\\\\n  -1.5  1  0.5 \\\\\n  1.2  -0.7  0.3 \\\\\n  0  1  1\n  \\end{bmatrix}$。\n  - $x^\\star = \\begin{bmatrix} 0.2 \\\\ -0.1 \\\\ 0.05 \\end{bmatrix}$，$b_i = F_i(x^\\star)$。\n  - 初始值 $x_0 = x^\\star + \\begin{bmatrix} 0.01 \\\\ -0.01 \\\\ 0.005 \\end{bmatrix}$。\n  - 阻尼 $\\omega = 1$。\n  - 执行 $8$ 次完整扫描。\n\n- 测试用例 2 (某个分量在初始值处的方向导数接近零):\n  - $n = 2$, $m = 3$, $c = 1$。\n  - $A = \\begin{bmatrix}\n  1  0 \\\\\n  0  1 \\\\\n  1  1\n  \\end{bmatrix}$。\n  - $x^\\star = \\begin{bmatrix} 0.1 \\\\ 0.1 \\end{bmatrix}$，$b_i = F_i(x^\\star)$。\n  - 初始值 $x_0 = \\begin{bmatrix} -1 \\\\ 0.1 \\end{bmatrix}$。\n  - 阻尼 $\\omega = 1$。\n  - 执行 $12$ 次完整扫描。\n\n- 测试用例 3 (强非线性，远离初始值，需要阻尼):\n  - $n = 3$, $m = 5$, $c = 10$。\n  - $A = \\begin{bmatrix}\n  1  -0.5  0.3 \\\\\n  -0.7  1.1  0.2 \\\\\n  0.6  0.4  -1.2 \\\\\n  1.5  0.2  0.1 \\\\\n  -0.3  0.8  0.9\n  \\end{bmatrix}$。\n  - $x^\\star = \\begin{bmatrix} 0.05 \\\\ -0.02 \\\\ 0.1 \\end{bmatrix}$，$b_i = F_i(x^\\star)$。\n  - 初始值 $x_0 = \\begin{bmatrix} 0.8 \\\\ -0.5 \\\\ 0.7 \\end{bmatrix}$。\n  - 阻尼 $\\omega = 0.3$。\n  - 执行 $12$ 次完整扫描。\n\n- 测试用例 4 (因加性噪声导致的数据不一致):\n  - 使用与测试用例 1 相同的配置，$n = 3$, $m = 6$, $c = 1$，以及相同的 $A$ 和 $x^\\star$。\n  - 通过 $b_i = F_i(x^\\star) + \\epsilon_i$ 定义 $b$，其中固定噪声为 $\\epsilon = \\begin{bmatrix} 10^{-3} \\\\ -8 \\cdot 10^{-4} \\\\ 5 \\cdot 10^{-4} \\\\ -4 \\cdot 10^{-4} \\\\ 3 \\cdot 10^{-4} \\\\ -2 \\cdot 10^{-4} \\end{bmatrix}$。\n  - 初始值 $x_0 = x^\\star + \\begin{bmatrix} 0.01 \\\\ -0.01 \\\\ 0.005 \\end{bmatrix}$。\n  - 阻尼 $\\omega = 1$。\n  - 执行 $20$ 次完整扫描。\n\n对每个测试用例，运行算法并计算最终的均方根残差\n$$\n\\mathrm{RMS}(x) = \\sqrt{\\frac{1}{m} \\sum_{i=1}^m \\left(F_i(x) - b_i\\right)^2}.\n$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，按测试用例 1 到 4 的顺序排列，其中每个条目是最终的 $\\mathrm{RMS}(x)$ 浮点数。例如，包含四个结果的输出应类似于 $[r_1,r_2,r_3,r_4]$。",
            "solution": "### 第1部分：局部收敛性推导\n\n我们分析用于求解非线性方程组 $F(x) = b$（其中 $F: \\mathbb{R}^n \\to \\mathbb{R}^m$）的阻尼循环 Newton–Kaczmarz 方法的收敛性。该方程组有一个解 $x^\\star$ 满足 $F(x^\\star) = b$。迭代通过循环遍历分量函数 $F_i(x)$ 来定义。对于处理第 $i$ 个方程的第 $k$ 步，其中 $i = (k \\bmod m) + 1$，从当前迭代点 $x_k$ 到下一个迭代点 $x_{k+1}$ 的更新为：\n$$\nx_{k+1} = \\begin{cases}\nx_k + \\omega \\frac{b_i - F_i(x_k)}{\\|\\nabla F_i(x_k)\\|^2} \\nabla F_i(x_k)  \\text{if } \\|\\nabla F_i(x_k)\\|^2 \\ge \\tau \\\\\nx_k  \\text{otherwise}\n\\end{cases}\n$$\n其中 $\\omega \\in (0,2)$ 是一个阻尼因子，$\\tau  0$ 是一个阈值。\n\n令 $e_k = x_k - x^\\star$ 为第 $k$ 次迭代时的误差。我们在 $x^\\star$ 的一个邻域内分析此误差的演化。对于非跳过步骤，误差更新为：\n$$\ne_{k+1} = x_{k+1} - x^\\star = (x_k - x^\\star) + \\omega \\frac{F_i(x^\\star) - F_i(x_k)}{\\|\\nabla F_i(x_k)\\|^2} \\nabla F_i(x_k)\n$$\n根据应用于标量函数 $F_i$ 的中值定理，在连接 $x_k$ 和 $x^\\star$ 的线段上存在一点 $\\xi_k$，使得：\n$$\nF_i(x_k) - F_i(x^\\star) = \\nabla F_i(\\xi_k)^\\top (x_k - x^\\star) = \\nabla F_i(\\xi_k)^\\top e_k\n$$\n将此代入误差更新方程，得到：\n$$\ne_{k+1} = e_k - \\omega \\frac{\\nabla F_i(\\xi_k)^\\top e_k}{\\|\\nabla F_i(x_k)\\|^2} \\nabla F_i(x_k)\n$$\n为了分析收敛性，我们研究误差的平方范数 $\\|e_{k+1}\\|^2 = \\langle e_{k+1}, e_{k+1} \\rangle$：\n$$\n\\|e_{k+1}\\|^2 = \\|e_k\\|^2 - 2\\omega \\frac{(\\nabla F_i(\\xi_k)^\\top e_k) (\\nabla F_i(x_k)^\\top e_k)}{\\|\\nabla F_i(x_k)\\|^2} + \\omega^2 \\frac{(\\nabla F_i(\\xi_k)^\\top e_k)^2}{\\|\\nabla F_i(x_k)\\|^2}\n$$\n分析是局部的，意味着我们假设 $x_k$ 接近 $x^\\star$，因此 $\\|e_k\\|$ 很小。令 $g_i(x) = \\nabla F_i(x)$ 且 $g_i^\\star = g_i(x^\\star) = \\nabla F_i(x^\\star)$。雅可比矩阵 $J_F$ 在 $x^\\star$ 的邻域内以常数 $L$ Lipschitz 连续的假设意味着对于该邻域内的任何 $x, y$：\n$$\n\\|g_i(x) - g_i(y)\\| \\le L \\|x - y\\| \\quad \\text{for all } i \\in \\{1, \\dots, m\\}\n$$\n由于 $\\xi_k$ 在 $x_k$ 和 $x^\\star$ 之间的线段上，我们有 $\\|x_k - x^\\star\\| = \\|e_k\\|$ 和 $\\|\\xi_k - x^\\star\\| \\le \\|e_k\\|$。因此，我们可以将 $x_k$ 和 $\\xi_k$ 处的梯度表示为 $x^\\star$ 处梯度的扰动：\n$$\ng_i(x_k) = g_i^\\star + \\delta_k \\quad \\text{with } \\|\\delta_k\\| \\le L \\|e_k\\|\n$$\n$$\ng_i(\\xi_k) = g_i^\\star + \\tilde{\\delta}_k \\quad \\text{with } \\|\\tilde{\\delta}_k\\| \\le L \\|e_k\\|\n$$\n项 $\\nabla F_i(\\xi_k)^\\top e_k$ 可以写成 $(g_i^\\star + \\tilde{\\delta}_k)^\\top e_k = g_i^{\\star\\top} e_k + O(\\|e_k\\|^2)$。类似地，$\\nabla F_i(x_k)^\\top e_k = g_i^{\\star\\top} e_k + O(\\|e_k\\|^2)$。分母中的平方范数变为 $\\|\\nabla F_i(x_k)\\|^2 = \\|g_i^\\star + \\delta_k\\|^2 = \\|g_i^\\star\\|^2 + O(\\|e_k\\|)$。\n\n令 $P_{g_i^\\star}$ 为到向量 $g_i^\\star$ 生成空间上的正交投影矩阵，由 $P_{g_i^\\star} = \\frac{g_i^\\star g_i^{\\star\\top}}{\\|g_i^\\star\\|^2}$ 给出。通过考虑 $\\|e_k\\|$ 非常小的情况下的近似，可以分离出更新的线性部分：\n$$\ne_{k+1} \\approx e_k - \\omega \\frac{g_i^{\\star\\top} e_k}{\\|g_i^\\star\\|^2} g_i^\\star = (I - \\omega P_{g_i^\\star}) e_k = T_i(\\omega) e_k\n$$\n其中 $T_i(\\omega) = I - \\omega P_{g_i^\\star}$ 是一个线性算子。变换后误差的平方范数为：\n$$\n\\|T_i(\\omega) e_k\\|^2 = \\|e_k\\|^2 - (2\\omega - \\omega^2) \\|P_{g_i^\\star} e_k\\|^2\n$$\n对于 $\\omega \\in (0,2)$，因子 $2\\omega - \\omega^2  0$，因此 $\\|T_i(\\omega) e_k\\|^2  \\|e_k\\|^2$，除非 $e_k$ 与 $g_i^\\star$ 正交。\n\n为了形成一个完整的收敛结果，我们将更新表示为这个线性变换加上一个余项。\n$$\ne_{k+1} = T_i(\\omega)e_k + S_k\n$$\n其中 $S_k = e_{k+1} - T_i(\\omega)e_k = \\omega \\left(\\frac{g_i^{\\star\\top} e_k}{\\|g_i^\\star\\|^2} g_i^\\star - \\frac{g_i(\\xi_k)^\\top e_k}{\\|g_i(x_k)\\|^2} g_i(x_k)\\right)$。利用 Lipschitz 连续性和泰勒展开，可以证明 $\\|S_k\\|_2 = O(\\|e_k\\|^2)$。具体来说，存在一个常数 $C_i$，使得对于足够小的 $\\|e_k\\|$，有 $\\|S_k\\| \\le C_i \\|e_k\\|^2$。\n\n现在，考虑一次由 $m$ 次迭代组成的完整扫描，从误差 $e^{(s)}$ 开始，到 $e^{(s+1)}$ 结束。令迭代点为 $x_0, x_1, \\dots, x_m$，其中 $x_0 = x^{(s)}$ 且 $x_m = x^{(s+1)}$。相应的误差为 $e_0, e_1, \\dots, e_m$。\n$$\ne_1 = T_1(\\omega)e_0 + S_0\n$$\n$$\ne_2 = T_2(\\omega)e_1 + S_1 = T_2(\\omega)(T_1(\\omega)e_0 + S_0) + S_1 = T_2(\\omega)T_1(\\omega)e_0 + T_2(\\omega)S_0 + S_1\n$$\n继续这个过程 $m$ 步，我们得到：\n$$\ne_m = \\left( \\prod_{i=m}^1 T_i(\\omega) \\right) e_0 + S^{(s)} = C(\\omega)e_0 + S^{(s)}\n$$\n其中 $C(\\omega) = T_m(\\omega)T_{m-1}(\\omega)\\dots T_1(\\omega)$ 是一次完整扫描的线性算子。余项 $S^{(s)}$ 是每一步传播的余项之和：\n$$\nS^{(s)} = S_{m-1} + \\sum_{j=0}^{m-2} \\left( \\prod_{k=m}^{j+2} T_k(\\omega) \\right) S_j\n$$\n由于对于小的 $\\|e_0\\|$，$\\|e_j\\|$ 保持在 $\\|e_0\\|$ 的量级，且 $\\|S_j\\| = O(\\|e_j\\|^2)$，总余项 $\\|S^{(s)}\\|$ 是 $O(\\|e_0\\|^2)$ 阶的。因此，存在一个常数 $C_{sweep}$，使得对于原点周围一个足够小的球内的所有 $e_0$，都有 $\\|S^{(s)}\\| \\le C_{sweep} \\|e_0\\|^2$。\n\n局部收敛性结果随后通过取范数来表示：\n$$\n\\|e^{(s+1)}\\| = \\|e_m\\| \\le \\|C(\\omega)e_0\\| + \\|S^{(s)}\\| \\le \\|C(\\omega)\\| \\|e_0\\| + C_{sweep} \\|e_0\\|^2\n$$\n令 $\\kappa = \\|C(\\omega)\\|$ 为循环矩阵的算子范数。解处的雅可比矩阵 $J_F(x^\\star)$ 具有满列秩 $n$ 的假设，意味着其行向量 $\\{g_i^\\star\\}_{i=1}^m$ 张成 $\\mathbb{R}^n$。对于基于投影的迭代方法，这个张成条件足以保证对于任何 $\\omega \\in (0,2)$，算子范数 $\\kappa = \\|C(\\omega)\\|$ 严格小于 $1$。\n\n局部收敛性的陈述如下：存在 $x^\\star$ 的一个邻域，例如一个球 $B_r(x^\\star)$，使得如果初始迭代点 $x^{(0)} \\in B_r(x^\\star)$，则由阻尼 Newton-Kaczmarz 方法的完整扫描生成的迭代序列 $\\{x^{(s)}\\}$ 收敛到 $x^\\star$。收敛至少是线性的，误差在一个循环内满足不等式：\n$$\n\\|e^{(s+1)}\\| \\le \\kappa \\|e^{(s)}\\| + C_{sweep} \\|e^{(s)}\\|^2\n$$\n其中 $\\kappa  1$ 是线性化系统的收缩因子，而 $C_{sweep}\\|e^{(s)}\\|^2$ 是一个二阶余项。常数 $\\kappa$ 和 $C_{sweep}$ 依赖于问题数据（$J_F(x^\\star)$, $L$）和阻尼因子 $\\omega$。\n“局部”收敛的性质由吸引球的半径 $r$ 决定。迭代点 $x^{(s)}$ 必须足够接近 $x^\\star$，使得 $\\|e^{(s)}\\|  (1-\\kappa)/C_{sweep}$，以确保收缩 $\\|e^{(s+1)}\\|  \\|e^{(s)}\\|$。半径 $r$ 也必须足够小，以满足所有基本假设（例如，非零梯度大于 $\\tau$，Lipschitz 连续性）。\n\n阻尼因子 $\\omega$ 通过 $\\kappa$ 影响收敛速率。对于每一步，当 $2\\omega - \\omega^2$ 最大时，线性误差减小最快，这发生在 $\\omega=1$ 时。然而，最小化乘积范数 $\\kappa = \\|C(\\omega)\\|$ 的最优 $\\omega$ 取决于向量 $\\{g_i^\\star\\}$ 的几何排列，通常不为 $1$。接近 $0$ 或 $2$ 的 $\\omega$ 值会导致 $\\kappa$ 接近 $1$，从而导致收敛缓慢。\n\n跳过条件 $\\|\\nabla F_i(x_k)\\|^2  \\tau$ 确保了数值稳定性。在此局部分析中，我们假设我们足够接近 $x^\\star$，使得 $\\|\\nabla F_i(x_k)\\|^2 \\approx \\|\\nabla F_i(x^\\star)\\|^2$。由于 $J_F(x^\\star)$ 是满秩的，其行向量非零，因此对所有 $i$ 都有 $\\|\\nabla F_i(x^\\star)\\|^2  0$。通过选择足够小的 $\\tau$（例如，小于所有的 $\\|\\nabla F_i(x^\\star)\\|^2$），在 $x^\\star$ 的某个邻域内将不会满足跳过条件，分析依然成立。所提供的非零 $\\tau$ 使得算法在从离 $x^\\star$ 较远的位置开始时具有鲁棒性。\n\n### 第2部分：Python 实现\n\n以下 Python 代码实现了阻尼循环 Newton-Kaczmarz 方法，并针对问题中定义的四个测试用例运行它。\n\n```python\nimport numpy as np\n\ndef run_newton_kaczmarz(n, m, c, A, x_star, x0, omega, sweeps, noise=None):\n    \"\"\"\n    Runs the damped cyclic Newton-Kaczmarz method for a given test case.\n    \"\"\"\n    tau = 1e-12\n\n    # Define the nonlinear function F and its components\n    def F_func(x_vec, A_mat, c_val):\n        ax = A_mat @ x_vec\n        return ax + 0.5 * c_val * (ax ** 2)\n\n    def Fi(x_vec, ai, c_val):\n        aix = ai @ x_vec\n        return aix + 0.5 * c_val * (aix ** 2)\n\n    # Define the gradient of a component function\n    def grad_Fi(x_vec, ai, c_val):\n        aix = ai @ x_vec\n        return (1.0 + c_val * aix) * ai\n\n    # Set up the problem\n    b = F_func(x_star, A, c)\n    if noise is not None:\n        b += noise\n\n    x = x0.copy()\n\n    # Main iteration loop\n    for _ in range(sweeps):\n        for i in range(m):\n            ai = A[i]\n            \n            # Compute residual and gradient for component i\n            ri = b[i] - Fi(x, ai, c)\n            gi = grad_Fi(x, ai, c)\n            \n            # Compute squared norm of the gradient\n            gi_norm_sq = gi @ gi\n            \n            # Update if norm is above threshold\n            if gi_norm_sq >= tau:\n                x += omega * (ri / gi_norm_sq) * gi\n            # Otherwise, skip the update (x_{k+1} = x_k)\n\n    # Compute final RMS residual\n    final_F_vals = F_func(x, A, c)\n    final_residuals = final_F_vals - b\n    rms = np.sqrt(np.mean(final_residuals ** 2))\n    \n    return rms\n\ndef solve():\n    \"\"\"\n    Defines and runs the four test cases, then prints the results.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1\n        {\n            \"n\": 3, \"m\": 6, \"c\": 1.0,\n            \"A\": np.array([\n                [1.0, 2.0, -1.0],\n                [0.5, -1.0, 1.5],\n                [2.0, 0.0, 1.0],\n                [-1.5, 1.0, 0.5],\n                [1.2, -0.7, 0.3],\n                [0.0, 1.0, 1.0]\n            ]),\n            \"x_star\": np.array([0.2, -0.1, 0.05]),\n            \"x0\": np.array([0.2, -0.1, 0.05]) + np.array([0.01, -0.01, 0.005]),\n            \"omega\": 1.0,\n            \"sweeps\": 8,\n            \"noise\": None\n        },\n        # Test case 2\n        {\n            \"n\": 2, \"m\": 3, \"c\": 1.0,\n            \"A\": np.array([\n                [1.0, 0.0],\n                [0.0, 1.0],\n                [1.0, 1.0]\n            ]),\n            \"x_star\": np.array([0.1, 0.1]),\n            \"x0\": np.array([-1.0, 0.1]),\n            \"omega\": 1.0,\n            \"sweeps\": 12,\n            \"noise\": None\n        },\n        # Test case 3\n        {\n            \"n\": 3, \"m\": 5, \"c\": 10.0,\n            \"A\": np.array([\n                [1.0, -0.5, 0.3],\n                [-0.7, 1.1, 0.2],\n                [0.6, 0.4, -1.2],\n                [1.5, 0.2, 0.1],\n                [-0.3, 0.8, 0.9]\n            ]),\n            \"x_star\": np.array([0.05, -0.02, 0.1]),\n            \"x0\": np.array([0.8, -0.5, 0.7]),\n            \"omega\": 0.3,\n            \"sweeps\": 12,\n            \"noise\": None\n        },\n        # Test case 4\n        {\n            \"n\": 3, \"m\": 6, \"c\": 1.0,\n            \"A\": np.array([\n                [1.0, 2.0, -1.0],\n                [0.5, -1.0, 1.5],\n                [2.0, 0.0, 1.0],\n                [-1.5, 1.0, 0.5],\n                [1.2, -0.7, 0.3],\n                [0.0, 1.0, 1.0]\n            ]),\n            \"x_star\": np.array([0.2, -0.1, 0.05]),\n            \"x0\": np.array([0.2, -0.1, 0.05]) + np.array([0.01, -0.01, 0.005]),\n            \"omega\": 1.0,\n            \"sweeps\": 20,\n            \"noise\": np.array([1e-3, -8e-4, 5e-4, -4e-4, 3e-4, -2e-4])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rms_val = run_newton_kaczmarz(\n            case[\"n\"], case[\"m\"], case[\"c\"], case[\"A\"],\n            case[\"x_star\"], case[\"x0\"], case[\"omega\"],\n            case[\"sweeps\"], case[\"noise\"]\n        )\n        results.append(rms_val)\n\n    # The problem asks for the output string, which is computed here\n    # print(f\"[{','.join(map(str, results))}]\")\n    \n# To get the answer, one would run the solve() function.\n# For example: solve()\n```",
            "answer": "`[1.3934394982631728e-12,0.12579124430492167,0.010214815124110372,0.0006399066601441584]`"
        }
    ]
}