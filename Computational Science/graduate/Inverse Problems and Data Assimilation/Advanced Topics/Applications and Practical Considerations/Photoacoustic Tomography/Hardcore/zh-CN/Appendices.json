{
    "hands_on_practices": [
        {
            "introduction": "在进行任何光声成像实验或模拟之前，理解数据采集的基本约束至关重要。这个练习探讨了成像目标的空间分辨率与所需时间采样率之间的根本联系。通过运用声波的色散关系和奈奎斯特-香农采样定理，您将推导出一个关键的设计参数，这对于确保信号的无失真捕获和后续高质量的图像重建至关重要。",
            "id": "3410220",
            "problem": "考虑光声层析成像（PAT），其中初始压力分布 $p_{0}(\\mathbf{x})$ 由一个光脉冲诱导，随后在声速恒为 $c$ 的均匀、各向同性、无损耗介质中作为声场 $p(\\mathbf{x}, t)$ 传播。声传播由标量波动方程控制，初始条件为 $p(\\mathbf{x}, 0) = p_{0}(\\mathbf{x})$ 和 $\\partial_{t} p(\\mathbf{x}, 0) = 0$。位于测量表面上 $\\mathbf{y}$ 位置的探测器记录时间序列 $p(\\mathbf{y}, t)$，您打算以采样间隔 $\\Delta t$ 对其进行均匀时间采样。\n\n从基本原理出发，推断 $p(\\mathbf{y}, t)$ 的频率成分与 $p_{0}(\\mathbf{x})$ 的空间带宽之间的关系。具体而言：\n\n- 使用声波的色散关系，将 $p(\\mathbf{y}, t)$ 的时间频率成分与 $p_{0}(\\mathbf{x})$ 的空间波数成分联系起来。\n- 将 $p(\\mathbf{y}, t)$ 中的最大有效时间频率 $f_{\\max}$ 与 $p_{0}(\\mathbf{x})$ 中的最小特征尺寸 $\\ell$ 关联起来。\n- 使用奈奎斯特-香农采样定理，确定避免在 $p(\\mathbf{y}, t)$ 中产生混叠的最小均匀时间采样间隔 $\\Delta t_{\\min}$。\n\n将您关于 $\\Delta t_{\\min}$ 的最终答案表示为一个用 $c$ 和 $\\ell$ 表示的闭式解析表达式。用秒表示 $\\Delta t_{\\min}$。不需要进行数值近似或四舍五入。",
            "solution": "问题要求求出对光声信号 $p(\\mathbf{y}, t)$ 进行无混叠采样所需的最小均匀时间采样间隔 $\\Delta t_{\\min}$，并用声速 $c$ 和初始压力分布 $p_{0}(\\mathbf{x})$ 的最小特征尺寸 $\\ell$ 来表示。\n\n该问题将根据提示分三步解决：\n1.  利用声波方程的色散关系，建立时间频率和空间频率之间的关系。\n2.  将测量信号中的最大时间频率 $f_{\\max}$ 与初始源中的最小特征尺寸 $\\ell$ 关联起来。\n3.  应用奈奎斯特-香农采样定理来确定所需的采样间隔。\n\n首先，声压场 $p(\\mathbf{x}, t)$ 在均匀、各向同性、无损耗介质中的传播由标量波动方程控制：\n$$ \\nabla^2 p(\\mathbf{x}, t) - \\frac{1}{c^2} \\frac{\\partial^2 p(\\mathbf{x}, t)}{\\partial t^2} = 0 $$\n其中 $c$ 是恒定的声速。为了分析频率成分，我们考虑一个形式为 $p(\\mathbf{x}, t) = A \\exp(i(\\mathbf{k} \\cdot \\mathbf{x} - \\omega t))$ 的平面波解，其中 $\\mathbf{k}$ 是空间波数矢量，$\\omega$ 是时间角频率。将其代入波动方程得到：\n$$ \\nabla^2 (A e^{i(\\mathbf{k} \\cdot \\mathbf{x} - \\omega t)}) = (i\\mathbf{k}) \\cdot (i\\mathbf{k}) (A e^{i(\\mathbf{k} \\cdot \\mathbf{x} - \\omega t)}) = -|\\mathbf{k}|^2 p(\\mathbf{x}, t) $$\n$$ \\frac{\\partial^2}{\\partial t^2} (A e^{i(\\mathbf{k} \\cdot \\mathbf{x} - \\omega t)}) = (-i\\omega)^2 (A e^{i(\\mathbf{k} \\cdot \\mathbf{x} - \\omega t)}) = -\\omega^2 p(\\mathbf{x}, t) $$\n因此波动方程变为：\n$$ -|\\mathbf{k}|^2 p(\\mathbf{x}, t) - \\frac{1}{c^2} (-\\omega^2 p(\\mathbf{x}, t)) = 0 $$\n对于非平凡解 ($p(\\mathbf{x}, t) \\neq 0$)，系数必须为零：\n$$ -|\\mathbf{k}|^2 + \\frac{\\omega^2}{c^2} = 0 $$\n这就得到了在此介质中声波的色散关系：\n$$ \\omega^2 = c^2 |\\mathbf{k}|^2 $$\n由于物理频率是非负的，我们取正根：\n$$ \\omega = c |\\mathbf{k}| $$\n这个基本关系直接将波分量的时间角频率 $\\omega$ 与其空间波数的模 $|\\mathbf{k}|$ 联系起来。这意味着传播波场 $p(\\mathbf{x}, t)$ 的时间频率成分完全由初始压力分布 $p_{0}(\\mathbf{x})$ 的空间频率（波数）成分决定。\n\n其次，我们将测量信号 $p(\\mathbf{y}, t)$ 中的最大有效时间频率 $f_{\\max}$ 与初始压力分布 $p_{0}(\\mathbf{x})$ 中的最小特征尺寸 $\\ell$ 关联起来。最小特征尺寸 $\\ell$ 决定了表示它所需的最高空间频率。在信号处理和成像中，空间分辨率 $\\ell$ 与所需的最大空间波数 $k_{\\max} = |\\mathbf{k}|_{\\max}$ 相关。一个源于空间采样定理的标准惯例将分辨率极限定义为最高频率分量波长的一半。空间波长 $\\lambda_{\\text{sp}}$ 与波数 $k$ 的关系为 $\\lambda_{\\text{sp}} = 2\\pi/k$。因此，最小波长 $\\lambda_{\\text{sp, min}}$ 对应于最大波数 $k_{\\max}$。该关系为：\n$$ \\ell = \\frac{\\lambda_{\\text{sp, min}}}{2} = \\frac{1}{2} \\frac{2\\pi}{k_{\\max}} = \\frac{\\pi}{k_{\\max}} $$\n由此，我们可以将初始压力分布 $p_{0}(\\mathbf{x})$ 中的最大有效空间波数表示为：\n$$ k_{\\max} = \\frac{\\pi}{\\ell} $$\n使用色散关系 $\\omega = c |\\mathbf{k}|$，传播波中的最大时间角频率 $\\omega_{\\max}$ 由 $k_{\\max}$ 决定：\n$$ \\omega_{\\max} = c k_{\\max} = c \\frac{\\pi}{\\ell} $$\n最大时间频率 $f_{\\max}$ 与角频率的关系为 $\\omega_{\\max} = 2\\pi f_{\\max}$。因此：\n$$ 2\\pi f_{\\max} = c \\frac{\\pi}{\\ell} $$\n$$ f_{\\max} = \\frac{c}{2\\ell} $$\n\n第三，我们应用奈奎斯特-香农采样定理来找到所需的采样间隔。该定理指出，为避免混叠，信号必须以至少是其最大频率分量 $f_{\\max}$ 两倍的频率 $f_s$ 进行采样。\n$$ f_s \\ge 2 f_{\\max} $$\n采样间隔 $\\Delta t$ 是采样频率的倒数，即 $\\Delta t = 1/f_s$。将此代入不等式，得到关于采样间隔的条件：\n$$ \\frac{1}{\\Delta t} \\ge 2 f_{\\max} \\implies \\Delta t \\le \\frac{1}{2 f_{\\max}} $$\n问题要求“最小”采样间隔 $\\Delta t_{\\min}$。在奈奎斯特准则的背景下，这被解释为对应于避免混叠的最小采样率（即奈奎斯特率 $f_s = 2f_{\\max}$）的采样间隔。这对应于允许的最大采样间隔。任何小于此值的间隔也能避免混叠，但会构成过采样。充分采样的临界情况是：\n$$ \\Delta t_{\\min} = \\frac{1}{2 f_{\\max}} $$\n代入我们关于 $f_{\\max}$ 的表达式：\n$$ \\Delta t_{\\min} = \\frac{1}{2 \\left( \\frac{c}{2\\ell} \\right)} = \\frac{1}{\\frac{c}{\\ell}} $$\n这简化为最小采样间隔的最终表达式：\n$$ \\Delta t_{\\min} = \\frac{\\ell}{c} $$\n这个表达式的单位是 (长度) / (长度/时间) = 时间，这对于采样间隔是正确的。从物理上讲，这个结果表明，采样间隔不能大于声音传播等于物体中最小特征尺寸的距离所需的时间。这是分辨该特征的一个直观且基本的要求。",
            "answer": "$$\\boxed{\\frac{\\ell}{c}}$$"
        },
        {
            "introduction": "在理解了数据采集的理论要求后，下一步是模拟信号传播的物理过程，即正向模型。精确的正向模型对于开发和测试重建算法至关重要。本练习将指导您使用“人造解法”（Method of Manufactured Solutions）——一种在科学计算中用于代码验证的黄金标准方法——来构建和验证一个一维声波方程的数值求解器。通过这个实践，您将掌握确保数值工具准确可靠的核心技能。",
            "id": "3410161",
            "problem": "考虑在小信号、无损、均匀介质假设下的光声断层成像（PAT）标准正向模型。声压场满足线性波动方程\n$$\n\\partial_{tt} p(x,t) - c^2 \\partial_{xx} p(x,t) = 0 \\quad \\text{for } x \\in [0,L], \\ t \\ge 0,\n$$\n在空间区间上具有周期性边界条件，初始位移为 $p(x,0) = p_0(x)$，初始速度为 $\\partial_t p(x,0) = v_0(x)$。此处 $c$ 是（恒定）声速。在光声断层成像中，由于短脉冲光照后热弹性膨胀的性质，初始压力 $p_0(x)$ 与吸收的光能密度成正比，且 $v_0(x)=0$。\n\n你将使用制造解方法验证一个数值正向求解器。所有量均为无量纲（单位为1）。该求解器在空间和时间上必须达到二阶精度。你必须从基本守恒定律和本构关系（质量守恒、动量守恒和线性状态方程）出发进行推导，而不是从已有的离散化公式开始。\n\n制造解：\n\n1) 齐次波动方程：选择一个光滑的周期解\n$$\np(x,t) = \\sin(k x)\\cos(c k t),\n$$\n其中 $k = 2\\pi m$，$m$ 是一个正整数。该解满足齐次波动方程，其初始数据为 $p(x,0) = \\sin(k x)$ 和 $\\partial_t p(x,0)=0$。\n\n2) 受迫波动方程：为了独立于空间离散误差来分离时间收敛性，使用一个空间均匀的制造解\n$$\np(x,t) = \\cos(\\omega t),\n$$\n该解满足\n$$\n\\partial_{tt} p(x,t) - c^2 \\partial_{xx} p(x,t) = S(x,t),\n$$\n其中制造源项为\n$$\nS(x,t) = -\\omega^2 \\cos(\\omega t).\n$$\n使用初始数据 $p(x,0)=\\cos(0)=1$ 和 $\\partial_t p(x,0)=0$。\n\n你的任务：\n\n- 从基本声学方程推导出，对于 PAT，压力场满足所述的波动方程和给定的初始数据。\n\n- 构建一个在一维空间上具有周期性边界条件的、相容的二阶精度数值方法。该方法必须是时间显式的，并且在应用于光滑数据时，在空间和时间上都具有二阶精度。使用一个包含 $N$ 个点的固定空间网格和一个均匀的时间步长 $\\Delta t$。最终时间 $T$ 必须能精确表示为 $\\Delta t$ 的整数倍。\n\n- 实现求解器，使其既能处理齐次方程，也能处理带有通用源项 $S(x,t)$ 的受迫方程，并且支持上述初始条件。程序必须计算在时间 $T$ 的解，并将其与精确的制造解进行比较，以得出误差。\n\n- 使用由下式定义的离散 $L^2$ 误差\n$$\nE = \\left( \\sum_{i=0}^{N-1} \\left[p_i^{\\mathrm{num}}(T) - p^{\\mathrm{exact}}(x_i,T)\\right]^2 \\Delta x \\right)^{1/2},\n$$\n其中 $\\Delta x = L/N$，$x_i = i \\Delta x$。\n\n- 经验收敛阶：给定两个误差 $E_1$ 和 $E_2$，它们对应于将相关步长（例如，将 $\\Delta x$ 或 $\\Delta t$ 减半，因此 $r=2$）加密一个因子 $r$ 的情况，计算观测阶\n$$\nq = \\frac{\\log(E_1/E_2)}{\\log(r)}.\n$$\n\n测试套件和要求的输出：\n\n实现以下测试套件，每个测试产生一个浮点数误差，以及在适用情况下的经验阶。所有量均为无量纲。\n\n- 测试 A（空间收敛主导）：齐次情况，$c=1, L=1, m=3, k=2\\pi m$，最终时间 $T=0.01$。使用三个网格，其中 $N \\in \\{50, 100, 200\\}$。对于时间步进，选择 $\\Delta t = \\alpha (\\Delta x)^2$，其中 $\\alpha=0.2$。这确保在这些分辨率下，时间截断误差相对于空间截断误差可以忽略不计。计算每个 $N$ 对应的离散 $L^2$ 误差 $E_N$，然后使用 $q_{\\text{space}} = \\frac{1}{2}\\left( \\frac{\\log(E_{50}/E_{100})}{\\log 2} + \\frac{\\log(E_{100}/E_{200})}{\\log 2} \\right)$ 计算观测阶。\n\n- 测试 B（仅通过制造源项进行时间收敛）：受迫情况，$c=1, L=1$，空间均匀的制造解 $p(x,t)=\\cos(\\omega t)$，$\\omega=7$。使用固定的空间网格 $N=64$（这样常数场的空间拉普拉斯算子在周期性网格上精确为零，从而消除空间误差）。最终时间 $T=0.2$。使用三个时间步长 $\\Delta t \\in \\{0.02, 0.01, 0.005\\}$，每个步长的选择都使得 $T$ 是 $\\Delta t$ 的整数倍。计算离散 $L^2$ 误差 $E_{\\Delta t}$ 和观测时间阶\n$$\nq_{\\text{time}} = \\frac{1}{2}\\left( \\frac{\\log(E_{0.02}/E_{0.01})}{\\log 2} + \\frac{\\log(E_{0.01}/E_{0.005})}{\\log 2} \\right).\n$$\n\n- 测试 C（边界情况一致性）：齐次情况，参数与测试 A 相同，但 $T=0$。数值解必须等于初始条件，因此离散 $L^2$ 误差必须在数值上为零。报告误差是否小于容差 $\\varepsilon=10^{-12}$，结果为布尔值。\n\n你的程序应产生单行输出，其中包含一个逗号分隔的列表，用方括号括起来，结果按以下顺序排列：\n- 来自测试 A 的观测空间收敛阶 $q_{\\text{space}}$，为浮点数。\n- 来自测试 B 的观测时间收敛阶 $q_{\\text{time}}$，为浮点数。\n- 一个布尔值，表示 $q_{\\text{space}} \\ge 1.8$ 是否成立。\n- 一个布尔值，表示 $q_{\\text{time}} \\ge 1.8$ 是否成立。\n- 来自测试 C 的一个布尔值，表示 $T=0$ 时的误差是否小于 $\\varepsilon$。\n\n例如，输出格式必须与 \"[2.01,1.99,True,True,True]\" 完全一样。\n\n所有计算量均为无量纲。三角函数中出现的角度单位为弧度。观测阶的最终答案必须以普通十进制浮点数（而非百分比）打印，布尔值必须是 Python 风格的 True 或 False。",
            "solution": "该问题是有效的。它提出了一个在计算物理学领域中定义明确且具有科学依据的任务：推导、实现并验证一个用于光声断层成像（PAT）正向模型的一维声波方程数值求解器。使用制造解方法进行验证是科学计算中一种标准且严谨的途径。所有参数和测试用例都定义清晰，并且在物理和数值上都是一致的。\n\n### 1. 控制方程的推导\n\n流体中声波的行为由质量守恒和动量守恒的基本原理以及一个联系压力和密度的状态方程来描述。对于小信号假设下的无损均匀介质，这些原理可表示为线性化声学方程。在一维空间 $x$ 中，它们是：\n\n1.  **质量守恒（连续性方程）：** 该原理指出，一个体积内质量的变化率等于流入该体积的净质量通量。对于小扰动，该方程线性化为：\n    $$ \\frac{\\partial \\rho'}{\\partial t} + \\rho_a \\frac{\\partial v}{\\partial x} = 0 $$\n    此处，$\\rho'(x,t)$ 是声学密度扰动，$v(x,t)$ 是流体质点速度，$\\rho_a$ 是环境流体密度。\n\n2.  **动量守恒（欧拉方程）：** 这是牛顿第二定律在流体微元上的应用。由压力梯度产生的净力使流体加速。其线性化形式为：\n    $$ \\rho_a \\frac{\\partial v}{\\partial t} = -\\frac{\\partial p}{\\partial x} $$\n    此处，$p(x,t)$ 是声压。\n\n3.  **状态方程：** 对于快速的声学过程（近似为绝热过程），压力和密度是相关的。对于小扰动，这种关系是线性的：\n    $$ p = c^2 \\rho' $$\n    比例常数 $c^2$ 由介质的属性定义，其中 $c$ 是声速，由 $c = \\sqrt{(\\partial P / \\partial \\rho)_S}$ 在环境条件下计算得出。\n\n为了推导关于压力 $p$ 的波动方程，我们将这三个方程结合起来。首先，我们对动量方程关于 $x$求导，并对连续性方程关于 $t$ 求导：\n$$ \\rho_a \\frac{\\partial^2 v}{\\partial t \\partial x} = -\\frac{\\partial^2 p}{\\partial x^2} $$\n$$ \\frac{\\partial^2 \\rho'}{\\partial t^2} + \\rho_a \\frac{\\partial^2 v}{\\partial x \\partial t} = 0 $$\n假设函数足够光滑，求导顺序无关紧要（$\\partial_{tx}v = \\partial_{xt}v$）。我们可以将第一个方程中 $\\rho_a \\partial_{tx}v$ 的表达式代入第二个方程：\n$$ \\frac{\\partial^2 \\rho'}{\\partial t^2} + \\left( -\\frac{\\partial^2 p}{\\partial x^2} \\right) = 0 \\implies \\frac{\\partial^2 \\rho'}{\\partial t^2} = \\frac{\\partial^2 p}{\\partial x^2} $$\n现在，利用状态方程，我们将 $\\rho'$ 替换为 $p/c^2$。由于 $c$ 是常数，我们可以写出 $\\partial_{tt}\\rho' = (1/c^2) \\partial_{tt}p$。代入此式得到：\n$$ \\frac{1}{c^2} \\frac{\\partial^2 p}{\\partial t^2} = \\frac{\\partial^2 p}{\\partial x^2} $$\n整理后得到标准的齐次线性波动方程：\n$$ \\frac{\\partial^2 p}{\\partial t^2} - c^2 \\frac{\\partial^2 p}{\\partial x^2} = 0 $$\n在光声断层成像中，组织被短激光脉冲照射。吸收的能量引起快速、局部的加热和热弹性膨胀，从而产生一个初始压力分布 $p(x,0) = p_0(x)$。因为假定此过程发生在任何显著的物质运动之前，所以初始流体速度为零，即 $v(x,0)=0$。从连续性方程和状态方程，我们有 $\\partial_t p = c^2 \\partial_t \\rho' = -c^2 \\rho_a \\partial_x v$。在 $t=0$ 时进行计算，我们得到 $\\partial_t p(x,0) = -c^2 \\rho_a \\partial_x v(x,0)$。由于对所有 $x$ 都有 $v(x,0)=0$，其空间导数也为零，这导致了初始条件 $\\partial_t p(x,0) = 0$。\n\n### 2. 数值离散化\n\n我们的任务是为波动方程构建一个二阶精度的显式有限差分格式，该方程可能包含一个源项 $S(x,t)$：\n$$ \\partial_{tt} p - c^2 \\partial_{xx} p = S(x,t) $$\n我们定义一个离散网格，其上的点为 $(x_i, t_n)$，其中 $x_i = i \\Delta x$（$i=0, \\dots, N-1$），$t_n = n \\Delta t$。在这些点上的数值解记为 $p_i^n \\approx p(x_i, t_n)$。\n\n使用中心差分可以得到空间和时间导数的二阶精度近似：\n$$ \\partial_{xx} p \\bigg|_{(x_i, t_n)} \\approx \\frac{p_{i+1}^n - 2p_i^n + p_{i-1}^n}{(\\Delta x)^2} + \\mathcal{O}((\\Delta x)^2) $$\n$$ \\partial_{tt} p \\bigg|_{(x_i, t_n)} \\approx \\frac{p_i^{n+1} - 2p_i^n + p_i^{n-1}}{(\\Delta t)^2} + \\mathcal{O}((\\Delta t)^2) $$\n将这些近似代入波动方程，得到离散化形式：\n$$ \\frac{p_i^{n+1} - 2p_i^n + p_i^{n-1}}{(\\Delta t)^2} - c^2 \\frac{p_{i+1}^n - 2p_i^n + p_{i-1}^n}{(\\Delta x)^2} = S_i^n $$\n求解下一时间步的压力 $p_i^{n+1}$，得到显式时间推进公式：\n$$ p_i^{n+1} = 2p_i^n - p_i^{n-1} + \\left(\\frac{c\\Delta t}{\\Delta x}\\right)^2 (p_{i+1}^n - 2p_i^n + p_{i-1}^n) + (\\Delta t)^2 S_i^n $$\n这是一个三层格式，需要前两个时间层 $t_n$ 和 $t_{n-1}$ 的数据。为保证数值稳定性，必须满足 Courant-Friedrichs-Lewy (CFL) 条件：$\\sigma = c\\Delta t/\\Delta x \\le 1$。\n\n为了开始模拟，我们需要 $p^0$ 和 $p^1$。初始条件 $p(x,0)=p_0(x)$ 给出 $p_i^0 = p_0(x_i)$。为了在保持二阶精度的同时找到 $p_i^1$，我们使用初始条件 $\\partial_t p(x,0) = 0$。该导数在 $t=0$ 时的二阶中心差分为 $(\\frac{p_i^1 - p_i^{-1}}{2\\Delta t}) = 0$，这意味着 $p_i^1 = p_i^{-1}$。将此关系代入 $n=0$ 时的一般格式中：\n$$ p_i^1 = 2p_i^0 - p_i^{-1} + \\sigma^2 (p_{i+1}^0 - 2p_i^0 + p_{i-1}^0) + (\\Delta t)^2 S_i^0 $$\n$$ p_i^1 = 2p_i^0 - p_i^1 + \\sigma^2 (p_{i+1}^0 - 2p_i^0 + p_{i-1}^0) + (\\Delta t)^2 S_i^0 $$\n求解 $p_i^1$ 得到二阶精度的启动公式：\n$$ p_i^1 = p_i^0 + \\frac{1}{2} \\sigma^2 (p_{i+1}^0 - 2p_i^0 + p_{i-1}^0) + \\frac{1}{2}(\\Delta t)^2 S_i^0 $$\n在 $[0,L]$ 上的周期性边界条件意味着 $p(x,t) = p(x+L,t)$，在离散网格上即为 $p_N^n = p_0^n$ 和 $p_{-1}^n = p_{N-1}^n$。这些可以通过对索引使用模运算来处理。\n\n### 3. 验证策略\n\n数值求解器通过制造解方法和一个测试套件进行验证。\n- **测试 A（空间收敛）：** 使用一个具有光滑正弦初始条件的齐次情况。时间步长选择为 $\\Delta t = \\alpha (\\Delta x)^2$，其中 $\\alpha=0.2$ 是一个小数。这使得量级为 $(\\Delta t)^2$ 的时间截断误差远小于量级为 $(\\Delta x)^2$ 的空间误差。该测试有效地分离并测量了空间精度阶。对于我们的格式，我们期望误差 $E$ 的量级为 $(\\Delta x)^2$，因此观测阶 $q_{\\text{space}}$ 应接近 2。\n- **测试 B（时间收敛）：** 使用一个具有空间均匀制造解 $p(x,t) = \\cos(\\omega t)$ 的受迫情况。由于解和源项在空间上是常数，离散空间拉普拉斯项 $(p_{i+1}^n - 2p_i^n + p_{i-1}^n)$ 在所有时间步都恒等于零。这完全消除了空间离散误差，从而分离出时间误差。它也规避了 CFL 稳定性约束，因为格式中导致不稳定的部分被置零了。我们期望误差 $E$ 的量级为 $(\\Delta t)^2$，因此观测阶 $q_{\\text{time}}$ 应接近 2。\n- **测试 C（一致性检查）：** 此测试检验求解器在 $T=0$ 时的行为。数值解必须就是初始条件，误差应为零（或在机器精度范围内）。这是一个基本的实现健全性检查。\n\n离散 $L^2$ 误差范数 $E = \\left( \\sum_{i=0}^{N-1} \\left[p_i^{\\mathrm{num}}(T) - p^{\\mathrm{exact}}(x_i,T)\\right]^2 \\Delta x \\right)^{1/2}$ 用于量化数值解与精确解之间的差异，并由此计算经验收敛阶 $q = \\log(E_1/E_2)/\\log(r)$，其中 $r$ 是加密因子。",
            "answer": "```python\nimport numpy as np\n\ndef wave_solver(L, N, c, T, dt, p0_func, S_func=None):\n    \"\"\"\n    Solves the 1D wave equation partial_tt p - c^2 partial_xx p = S(x,t)\n    using a second-order finite difference scheme with periodic boundary conditions.\n    \"\"\"\n    dx = L / N\n    x = np.arange(N) * dx\n\n    num_steps = int(round(T / dt))\n\n    if num_steps == 0:\n        return p0_func(x), x\n\n    # Initialize pressure fields at t=0 and t=-dt (by convention)\n    # p_curr is p^n, p_prev is p^(n-1)\n    p_curr = p0_func(x)  # p^0\n\n    # Courant number squared\n    sigma_sq = (c * dt / dx)**2\n\n    # First time step (n=0) to calculate p^1 using second-order starter.\n    # p^1 = p^0 + dt*v_0 + 0.5*dt^2*(c^2*laplacian(p^0) + S^0). Here v_0=0.\n    lap_p0 = np.roll(p_curr, -1) - 2 * p_curr + np.roll(p_curr, 1)\n    \n    S_at_0 = np.zeros(N)\n    if S_func:\n        S_at_0 = S_func(x, 0.0)\n    \n    p_next = p_curr + 0.5 * sigma_sq * lap_p0 + 0.5 * dt**2 * S_at_0\n\n    p_prev = p_curr\n    p_curr = p_next\n\n    # Main time-stepping loop (n=1 to num_steps-1)\n    for n in range(1, num_steps):\n        t = n * dt\n        \n        lap_p_curr = np.roll(p_curr, -1) - 2 * p_curr + np.roll(p_curr, 1)\n\n        S_at_t = np.zeros(N)\n        if S_func:\n            S_at_t = S_func(x, t)\n\n        p_next = 2 * p_curr - p_prev + sigma_sq * lap_p_curr + dt**2 * S_at_t\n\n        p_prev = p_curr\n        p_curr = p_next\n\n    return p_curr, x\n\ndef calculate_l2_error(p_num, p_exact, dx):\n    \"\"\"Calculates the discrete L2 error.\"\"\"\n    return np.sqrt(np.sum((p_num - p_exact)**2) * dx)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    results = []\n\n    # --- Test A: Spatial Convergence ---\n    c_A = 1.0\n    L_A = 1.0\n    m_A = 3\n    k_A = 2 * np.pi * m_A\n    T_A = 0.01\n    alpha_A = 0.2\n    Ns_A = [50, 100, 200]\n    errors_A = []\n\n    def p0_A(x):\n        return np.sin(k_A * x)\n\n    for N_val in Ns_A:\n        dx_val = L_A / N_val\n        dt_val = alpha_A * (dx_val)**2\n        \n        p_num, x_grid = wave_solver(L_A, N_val, c_A, T_A, dt_val, p0_A)\n        p_exact = np.sin(k_A * x_grid) * np.cos(c_A * k_A * T_A)\n        \n        error = calculate_l2_error(p_num, p_exact, dx_val)\n        errors_A.append(error)\n\n    # Calculate observed order of convergence\n    q_50_100 = np.log(errors_A[0] / errors_A[1]) / np.log(2)\n    q_100_200 = np.log(errors_A[1] / errors_A[2]) / np.log(2)\n    q_space = 0.5 * (q_50_100 + q_100_200)\n    \n    results.append(q_space)\n\n    # --- Test B: Temporal Convergence ---\n    c_B = 1.0\n    L_B = 1.0\n    N_B = 64\n    omega_B = 7.0\n    T_B = 0.2\n    dts_B = [0.02, 0.01, 0.005]\n    errors_B = []\n\n    def p0_B(x):\n        return np.ones_like(x)\n\n    def S_B(x, t):\n        # x is unused since source is spatially uniform\n        return -omega_B**2 * np.cos(omega_B * t) * np.ones_like(x)\n\n    for dt_val in dts_B:\n        p_num, x_grid = wave_solver(L_B, N_B, c_B, T_B, dt_val, p0_B, S_func=S_B)\n        p_exact = np.cos(omega_B * T_B) * np.ones_like(x_grid)\n        dx_val = L_B / N_B\n        \n        error = calculate_l2_error(p_num, p_exact, dx_val)\n        errors_B.append(error)\n\n    # Calculate observed order of convergence\n    q_1 = np.log(errors_B[0] / errors_B[1]) / np.log(2)\n    q_2 = np.log(errors_B[1] / errors_B[2]) / np.log(2)\n    q_time = 0.5 * (q_1 + q_2)\n\n    results.append(q_time)\n\n    # --- Append boolean checks for Test A and B ---\n    results.append(q_space >= 1.8)\n    results.append(q_time >= 1.8)\n\n    # --- Test C: Edge Case Consistency (T=0) ---\n    N_C = 50 \n    dx_C = L_A / N_C\n    dt_C = alpha_A * dx_C**2\n    \n    p_num_C, x_grid_C = wave_solver(L_A, N_C, c_A, 0.0, dt_C, p0_A)\n    p_exact_C = p0_A(x_grid_C)\n\n    error_C = calculate_l2_error(p_num_C, p_exact_C, dx_C)\n    \n    results.append(error_C  1e-12)\n\n    # --- Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "掌握了正向模型后，我们转向光声断层成像的核心目标：反问题，即从测量数据中重建图像。这个综合性练习将带您进入更高级的定量光声断层成像（QPAT）领域。您将结合光传输的扩散近似模型和声信号生成模型，在一个贝叶斯框架下求解光学吸收系数，并使用拉普拉斯近似来量化解的不确定性。这项实践综合了物理建模、优化和不确定性量化，是科学解释成像结果所必需的关键步骤。",
            "id": "3410206",
            "problem": "给定一个简化的定量光声断层成像 (QPAT) 一维模型，该模型使用稳态扩散近似来描述光传输。目标是通过计算负对数后验的 Hessian 矩阵，并将其逆矩阵与近似的后验协方差关联，从而在最大后验 (MAP) 估计处使用 Laplace 近似来近似推断出的光吸收场的不确定性。\n\n考虑一个一维空间域，该域被离散为 $n$ 个内部节点，网格间距为 $h = 1/(n+1)$，并采用齐次 Dirichlet 边界条件。光通量 $\\Phi \\in \\mathbb{R}^n$ 满足离散扩散方程\n$$\n\\mathbf{A}(\\boldsymbol{\\theta}) \\Phi = q,\n$$\n其中 $q \\in \\mathbb{R}^n$ 是一个已知源向量，$\\boldsymbol{\\theta} \\in \\mathbb{R}^n$ 是对数吸收参数，吸收系数 $\\boldsymbol{\\mu}_a \\in \\mathbb{R}^n$ 由 $\\boldsymbol{\\mu}_a = \\exp(\\boldsymbol{\\theta})$ 逐元素给出。刚度矩阵 $\\mathbf{A}(\\boldsymbol{\\theta})$ 为\n$$\n\\mathbf{A}(\\boldsymbol{\\theta}) = \\frac{D}{h^2}\\mathbf{K} + \\operatorname{diag}(\\boldsymbol{\\mu}_a),\n$$\n其中 $D \\in \\mathbb{R}_+$ 是扩散系数，$\\mathbf{K} \\in \\mathbb{R}^{n\\times n}$ 是标准的有限差分三对角矩阵，其主对角线元素为 $2$，次对角线元素为 $-1$。\n\n初始声压 $p_0 \\in \\mathbb{R}^n$ 由下式给出\n$$\np_0 = \\Gamma \\boldsymbol{\\mu}_a \\odot \\Phi,\n$$\n其中 $\\Gamma \\in \\mathbb{R}_+$ 是 Grüneisen 参数（假设已知），$\\odot$ 表示逐元素 (Hadamard) 乘积。测量算子选择一个索引子集 $\\mathcal{S} \\subset \\{1,\\dots,n\\}$，测量数据为\n$$\n\\mathbf{g}(\\boldsymbol{\\theta}) = \\mathbf{S} p_0,\n$$\n其中 $\\mathbf{S} \\in \\{0,1\\}^{m\\times n}$ 选择 $m$ 个传感器位置。观测数据 $\\mathbf{y} \\in \\mathbb{R}^m$ 是在真值参数 $\\boldsymbol{\\theta}_\\text{true}$ 下由正向模型生成的，不含额外噪声，并被视为协方差为 $\\sigma^2\\mathbf{I}_m$ 的高斯似然的一个实现。\n\n假设 $\\boldsymbol{\\theta}$ 的先验为独立高斯分布，其均值为 $\\boldsymbol{\\theta}_\\text{prior}$，协方差为 $\\tau^2\\mathbf{I}_n$。负对数后验（忽略一个加性常数）为\n$$\n\\mathcal{L}(\\boldsymbol{\\theta}) = \\frac{1}{2\\sigma^2}\\|\\mathbf{g}(\\boldsymbol{\\theta}) - \\mathbf{y}\\|_2^2 + \\frac{1}{2\\tau^2}\\|\\boldsymbol{\\theta} - \\boldsymbol{\\theta}_\\text{prior}\\|_2^2.\n$$\n\n在 MAP 估计 $\\boldsymbol{\\theta}_\\text{MAP}$ 附近的后验分布的 Laplace 近似使用一个高斯分布，其协方差等于 $\\mathcal{L}$ 在 $\\boldsymbol{\\theta}_\\text{MAP}$ 处的 Hessian 矩阵的逆。在实践中，对于带高斯噪声的非线性最小二乘问题，通常使用 Hessian 矩阵的 Gauss–Newton 近似\n$$\n\\mathbf{H}(\\boldsymbol{\\theta}_\\text{MAP}) \\approx \\mathbf{J}(\\boldsymbol{\\theta}_\\text{MAP})^\\top \\left(\\frac{1}{\\sigma^2}\\mathbf{I}_m\\right) \\mathbf{J}(\\boldsymbol{\\theta}_\\text{MAP}) + \\frac{1}{\\tau^2}\\mathbf{I}_n\n$$\n其中 $\\mathbf{J}(\\boldsymbol{\\theta}) \\in \\mathbb{R}^{m\\times n}$ 是 $\\mathbf{g}(\\boldsymbol{\\theta})$ 的 Jacobian 矩阵。\n\n任务：\n1. 从 $\\boldsymbol{\\theta}_\\text{prior}$ 开始，使用阻尼 Gauss–Newton (Levenberg–Marquardt) 方法通过最小化 $\\mathcal{L}(\\boldsymbol{\\theta})$ 来计算 $\\boldsymbol{\\theta}_\\text{MAP}$。\n2. 在 $\\boldsymbol{\\theta}_\\text{MAP}$ 处，计算如上所述的 Gauss–Newton Hessian 近似 $\\mathbf{H}(\\boldsymbol{\\theta}_\\text{MAP})$。\n3. 计算近似后验协方差 $\\mathbf{C} \\approx \\mathbf{H}(\\boldsymbol{\\theta}_\\text{MAP})^{-1}$。\n4. 报告在索引 $i \\in \\{1,\\lfloor n/2 \\rfloor, n\\}$ 处的三个选定的边际方差 $\\{\\mathbf{C}_{i,i}\\}$（使用 1-based 索引；在代码中，使用 $0$, $\\lfloor n/2 \\rfloor$ 和 $n-1$）。\n由于无量纲化，所有量都是无量纲的；将三个报告的输出表示为浮点数。\n\nJacobian 矩阵 $\\mathbf{J}(\\boldsymbol{\\theta})$ 必须通过对由 $\\mathbf{A}(\\boldsymbol{\\theta})\\Phi = q$ 给出的 $\\Phi$ 的隐式定义进行微分来计算：\n- 逐元素使用 $\\boldsymbol{\\mu}_a = \\exp(\\boldsymbol{\\theta})$，\n- 通过求解线性系统计算 $\\Phi$，\n- 对于每个分量 $\\theta_i$，通过求解\n$$\n\\mathbf{A}(\\boldsymbol{\\theta})\\frac{\\partial \\Phi}{\\partial \\theta_i} = - \\frac{\\partial \\mathbf{A}}{\\partial \\theta_i} \\Phi,\n$$\n来计算 $\\partial \\Phi/\\partial \\theta_i$，并与 $\\partial p_0/\\partial \\theta_i$ 结合形成 Jacobian 矩阵的列，然后通过 $\\mathbf{S}$ 选择传感器的行。\n\n测试套件：\n使用以下三个测试用例来检验推断问题的不同情况。在每种情况下，观测数据 $\\mathbf{y}$ 都是在真值参数下未添加噪声的正向预测。真值吸收分布定义为\n$$\n\\mu_a^\\text{true}(x_j) = \\mu_0 + \\delta \\exp\\left(-\\frac{(x_j - 0.5)^2}{2w^2}\\right),\n$$\n其中对于内部节点 $j=1,\\dots,n$，$x_j = j h$，且 $\\boldsymbol{\\theta}_\\text{true} = \\log(\\mu_a^\\text{true}(x_j))$ 是逐元素计算的，而先验均值是均匀背景 $\\boldsymbol{\\theta}_\\text{prior} = \\log(\\mu_0)\\mathbf{1}$。\n\n- 情况 A（一般情况，完全观测）：\n  - $n = 20$, $D = 10^{-2}$, $\\Gamma = 1$, $q = \\mathbf{1}$,\n  - $\\mu_0 = 0.1$, $\\delta = 0.2$, $w = 0.1$,\n  - 传感器：所有节点（$\\mathbf{S} = \\mathbf{I}_{n}$），$\\sigma^2 = (10^{-2})^2$, $\\tau^2 = (0.5)^2$。\n\n- 情况 B（低噪声，强数据）：\n  - 与情况 A 相同，除了 $\\sigma^2 = (10^{-4})^2$。\n\n- 情况 C（部分观测，较弱先验）：\n  - 与情况 A 相同，除了传感器位于从索引 3 开始的每第三个节点（即，在 1-based 索引中为索引 $\\{3,6,9,\\dots\\}$），$\\sigma^2 = (10^{-2})^2$, $\\tau^2 = (1.0)^2$。\n\n您的程序必须：\n- 按规定实现正向模型和 Jacobian 矩阵计算，\n- 使用阻尼 Gauss–Newton 方法计算 $\\boldsymbol{\\theta}_\\text{MAP}$，\n- 构建 $\\mathbf{H}(\\boldsymbol{\\theta}_\\text{MAP})$ 和 $\\mathbf{C} \\approx \\mathbf{H}^{-1}$，\n- 对于每个测试用例，输出在索引 $i \\in \\{1,\\lfloor n/2 \\rfloor, n\\}$ 处的三个边际方差 $\\mathbf{C}_{i,i}$（在代码中使用零-based 索引），\n- 生成单行输出，其中包含一个列表的列表，每个测试用例对应一个内部列表，每个内部列表按顺序 $[i=0, i=\\lfloor n/2 \\rfloor, i=n-1]$ 包含三个浮点数，整个输出格式化为用方括号括起来的逗号分隔列表，例如 `[[v_{A1},v_{A2},v_{A3}],[v_{B1},v_{B2},v_{B3}],[v_{C1},v_{C2},v_{C3}]]`。\n\n所有量均为无量纲；不需要物理单位。不涉及角度。不涉及百分比；将所有值表示为普通浮点数。",
            "solution": "**问题验证**\n\n问题陈述已经过严格评估，被认为是有效的。\n\n1.  **已知条件提取**：所有必需的参数、方程和条件都已明确提供。这包括光扩散模型 ($\\mathbf{A}(\\boldsymbol{\\theta})\\Phi = q$)、声压生成模型 ($p_0 = \\Gamma \\boldsymbol{\\mu}_a \\odot \\Phi$)、贝叶斯统计框架（高斯似然和先验）、负对数后验 $\\mathcal{L}(\\boldsymbol{\\theta})$、Hessian 矩阵的 Gauss-Newton 近似 $\\mathbf{H}$，以及通过隐式微分计算 Jacobian 矩阵 $\\mathbf{J}$ 的方法。定义了三个不同的测试用例（A、B、C），并提供了所有必要的常数 ($n, D, \\Gamma, q, \\mu_0, \\delta, w, \\sigma^2, \\tau^2$)。\n\n2.  **有效性检查**：\n    - **科学依据**：该模型基于辐射传输方程的扩散近似和光声信号生成的标准原理。使用 Gauss-Newton 优化和用于不确定性分析的 Laplace 近似的贝叶斯推断方法是计算逆问题中的标准且成熟的方法。该模型在科学上是合理的。\n    - **适定性**：正向问题是适定的（矩阵 $\\mathbf{A}(\\boldsymbol{\\theta})$ 是可逆的）。逆问题通过先验进行正则化，从而为 MAP 估计提供了一个适定的优化问题。Gauss-Newton Hessian 矩阵是一个半正定矩阵与一个正定矩阵之和，因此是可逆的，确保了近似后验协方差有唯一解。\n    - **客观性**：问题以精确的数学和算法术语陈述，没有主观性语言。\n    - **完整性**：实现解决方案和复现结果所需的所有信息都已提供。关于报告结果的索引，在基于 1 的数学描述 ($\\{1, \\lfloor n/2 \\rfloor, n\\}$) 和代码实现的明确指令 ($\\{0, \\lfloor n/2 \\rfloor, n-1\\}$) 之间存在一个微小歧义。将遵循后者更直接的指令。\n\n该问题是计算逆问题领域一个定义明确的标准练习，要求实现正向模型、优化算法和不确定性量化方法。\n\n**解决方法**\n\n目标是计算对数吸收参数场 $\\boldsymbol{\\theta}$ 在选定空间位置的边际后验方差。为实现这一目标，首先找到最大后验 (MAP) 估计 $\\boldsymbol{\\theta}_{\\text{MAP}}$，然后计算后验协方差的 Laplace 近似，该近似由在 MAP 估计处求值的负对数后验的 Hessian 矩阵的逆给出。Hessian 矩阵使用 Gauss-Newton 近似。解决方案按以下步骤进行。\n\n**1. 正向模型与观测**\n\n物理过程由一系列模型描述。\n\n- **光传输**：对于给定的对数吸收场 $\\boldsymbol{\\theta} \\in \\mathbb{R}^n$，稳态光通量 $\\Phi \\in \\mathbb{R}^n$ 由离散扩散方程控制：\n$$\n\\mathbf{A}(\\boldsymbol{\\theta}) \\Phi = q\n$$\n其中 $\\boldsymbol{\\mu}_a = \\exp(\\boldsymbol{\\theta})$ (逐元素)，$\\mathbf{A}(\\boldsymbol{\\theta}) = \\frac{D}{h^2}\\mathbf{K} + \\operatorname{diag}(\\boldsymbol{\\mu}_a)$，$q$ 是源，$D$ 是扩散系数，$h=\\frac{1}{n+1}$ 是网格间距，$\\mathbf{K}$ 是 $n \\times n$ 的二阶有限差分矩阵（三对角矩阵，主对角线元素为 $2$，第一对角线外元素为 $-1$）。由于 $\\mathbf{K}$ 是半正定的，而 $\\operatorname{diag}(\\boldsymbol{\\mu}_a)$ 是一个正定对角矩阵（因为 $\\mu_{a,i} = e^{\\theta_i} > 0$），矩阵 $\\mathbf{A}(\\boldsymbol{\\theta})$ 是对称正定的，因此是可逆的。我们可以通过求解这个线性系统来计算 $\\Phi$：\n$$\n\\Phi(\\boldsymbol{\\theta}) = \\mathbf{A}(\\boldsymbol{\\theta})^{-1} q\n$$\n- **声学生成**：初始声压 $p_0 \\in \\mathbb{R}^n$ 与吸收的光能密度成正比：\n$$\np_0(\\boldsymbol{\\theta}) = \\Gamma (\\boldsymbol{\\mu}_a \\odot \\Phi(\\boldsymbol{\\theta}))\n$$\n其中 $\\Gamma$ 是 Grüneisen 参数，$\\odot$ 是逐元素乘积。\n- **测量**：观测模型 $\\mathbf{g}(\\boldsymbol{\\theta})$ 通过一个线性选择算子 $\\mathbf{S} \\in \\{0,1\\}^{m \\times n}$ 将参数空间映射到测量空间：\n$$\n\\mathbf{g}(\\boldsymbol{\\theta}) = \\mathbf{S} \\, p_0(\\boldsymbol{\\theta})\n$$\n观测数据 $\\mathbf{y} \\in \\mathbb{R}^m$ 是从一个已知的真值 $\\boldsymbol{\\theta}_{\\text{true}}$ 无噪声地合成的：$\\mathbf{y} = \\mathbf{g}(\\boldsymbol{\\theta}_{\\text{true}})$。\n\n**2. 贝叶斯推断与 MAP 估计**\n\n我们采用贝叶斯框架。给定数据 $\\mathbf{y}$，$\\boldsymbol{\\theta}$ 的后验概率分布与似然和先验的乘积成正比。假设似然和先验均为高斯分布，负对数后验 $\\mathcal{L}(\\boldsymbol{\\theta})$（即我们要最小化的目标函数）为：\n$$\n\\mathcal{L}(\\boldsymbol{\\theta}) = \\frac{1}{2\\sigma^2} \\|\\mathbf{g}(\\boldsymbol{\\theta}) - \\mathbf{y}\\|_2^2 + \\frac{1}{2\\tau^2} \\|\\boldsymbol{\\theta} - \\boldsymbol{\\theta}_{\\text{prior}}\\|_2^2\n$$\nMAP 估计是该泛函的最小化子：$\\boldsymbol{\\theta}_{\\text{MAP}} = \\arg\\min_{\\boldsymbol{\\theta}} \\mathcal{L}(\\boldsymbol{\\theta})$。这是一个非线性最小二乘问题。我们使用阻尼 Gauss-Newton (Levenberg-Marquardt) 迭代方法来求解，以先验均值 $\\boldsymbol{\\theta}_{\\text{prior}}$ 作为初始猜测。\n\nGauss-Newton 更新步长 $\\delta\\boldsymbol{\\theta}$ 通过求解以下线性系统得到：\n$$\n(\\mathbf{H}(\\boldsymbol{\\theta}_k) + \\lambda \\mathbf{I}) \\delta\\boldsymbol{\\theta} = -\\nabla\\mathcal{L}(\\boldsymbol{\\theta}_k)\n$$\n其中 $\\boldsymbol{\\theta}_k$ 是第 k 次迭代的估计值，$\\lambda$ 是阻尼参数，$\\nabla\\mathcal{L}$ 是目标函数的梯度，$\\mathbf{H}$ 是 Hessian 矩阵的 Gauss-Newton 近似。\n梯度为：\n$$\n\\nabla\\mathcal{L}(\\boldsymbol{\\theta}) = \\mathbf{J}(\\boldsymbol{\\theta})^\\top \\frac{1}{\\sigma^2} (\\mathbf{g}(\\boldsymbol{\\theta}) - \\mathbf{y}) + \\frac{1}{\\tau^2} (\\boldsymbol{\\theta} - \\boldsymbol{\\theta}_{\\text{prior}})\n$$\nGauss-Newton Hessian 矩阵为：\n$$\n\\mathbf{H}(\\boldsymbol{\\theta}) = \\mathbf{J}(\\boldsymbol{\\theta})^\\top \\frac{1}{\\sigma^2} \\mathbf{I}_m \\mathbf{J}(\\boldsymbol{\\theta}) + \\frac{1}{\\tau^2} \\mathbf{I}_n\n$$\n其中 $\\mathbf{J}(\\boldsymbol{\\theta}) \\in \\mathbb{R}^{m\\times n}$ 是正向模型 $\\mathbf{g}(\\boldsymbol{\\theta})$ 的 Jacobian 矩阵。迭代过程持续进行，直到梯度的范数降至容差以下。\n\n**3. 通过隐式微分计算 Jacobian 矩阵**\n\n优化的核心是 Jacobian 矩阵 $\\mathbf{J}(\\boldsymbol{\\theta})$ 的计算。其元素为 $J_{ij} = \\frac{\\partial g_i}{\\partial \\theta_j}$。我们有 $\\mathbf{g} = \\mathbf{S} p_0$，所以 $\\mathbf{J} = \\mathbf{S} \\frac{\\partial p_0}{\\partial \\boldsymbol{\\theta}}$，其中 $\\frac{\\partial p_0}{\\partial \\boldsymbol{\\theta}}$ 是 $p_0$ 的完整 $n \\times n$ Jacobian 矩阵。我们计算该矩阵的第 j 列，即 $\\frac{\\partial p_0}{\\partial \\theta_j}$。\n对 $p_0 = \\Gamma (\\boldsymbol{\\mu}_a \\odot \\Phi)$ 使用乘法法则：\n$$\n\\frac{\\partial p_0}{\\partial \\theta_j} = \\Gamma \\left( \\frac{\\partial \\boldsymbol{\\mu}_a}{\\partial \\theta_j} \\odot \\Phi + \\boldsymbol{\\mu}_a \\odot \\frac{\\partial \\Phi}{\\partial \\theta_j} \\right)\n$$\n$\\boldsymbol{\\mu}_a$ 的导数很直接：$\\frac{\\partial \\boldsymbol{\\mu}_a}{\\partial \\theta_j} = \\mu_{a,j} \\mathbf{e}_j$，其中 $\\mathbf{e}_j$ 是第 j 个标准基向量。\n$\\Phi$ 的导数需要对正向方程 $\\mathbf{A} \\Phi = q$ 进行隐式微分：\n$$\n\\frac{\\partial \\mathbf{A}}{\\partial \\theta_j} \\Phi + \\mathbf{A} \\frac{\\partial \\Phi}{\\partial \\theta_j} = 0 \\implies \\mathbf{A} \\frac{\\partial \\Phi}{\\partial \\theta_j} = - \\frac{\\partial \\mathbf{A}}{\\partial \\theta_j} \\Phi\n$$\n刚度矩阵的导数为 $\\frac{\\partial \\mathbf{A}}{\\partial \\theta_j} = \\operatorname{diag}(\\frac{\\partial \\boldsymbol{\\mu}_a}{\\partial \\theta_j}) = \\mu_{a,j} \\mathbf{E}_{jj}$，其中 $\\mathbf{E}_{jj}$ 是一个在 $(j, j)$ 位置为 1，其他位置为 0 的矩阵。因此，右侧项为 $-\\mu_{a,j} \\Phi_j \\mathbf{e}_j$。\n通量的灵敏度则为：\n$$\n\\frac{\\partial \\Phi}{\\partial \\theta_j} = -\\mathbf{A}(\\boldsymbol{\\theta})^{-1} (\\mu_{a,j} \\Phi_j \\mathbf{e}_j)\n$$\n将此代回， $p_0$ 的完整 Jacobian 矩阵的第 j 列为：\n$$\n\\frac{\\partial p_0}{\\partial \\theta_j} = \\Gamma \\mu_{a,j} \\Phi_j \\left( \\mathbf{e}_j - \\boldsymbol{\\mu}_a \\odot (\\mathbf{A}^{-1} \\mathbf{e}_j) \\right)\n$$\n为高效计算，对于每个 $j=1,\\dots,n$，我们求解一个线性系统 $\\mathbf{A}\\mathbf{z}_j = \\mathbf{e}_j$ 来找到 $\\mathbf{z}_j=\\mathbf{A}^{-1}\\mathbf{e}_j$（即 $\\mathbf{A}^{-1}$ 的第 j 列），然后构建 Jacobian 列。最终的 Jacobian 矩阵为 $\\mathbf{J} = \\mathbf{S} \\left[ \\frac{\\partial p_0}{\\partial \\theta_1} | \\dots | \\frac{\\partial p_0}{\\partial \\theta_n} \\right]$。\n\n**4. 通过 Laplace 近似进行不确定性量化**\n\n在 MAP 估计附近，后验分布 $p(\\boldsymbol{\\theta}|\\mathbf{y})$ 被近似为一个多元高斯分布：\n$$\np(\\boldsymbol{\\theta}|\\mathbf{y}) \\approx \\mathcal{N}(\\boldsymbol{\\theta}_{\\text{MAP}}, \\mathbf{C})\n$$\n协方差矩阵 $\\mathbf{C}$ 是在 MAP 处求值的负对数后验的 Hessian 矩阵的逆：$\\mathbf{C} \\approx \\mathbf{H}(\\boldsymbol{\\theta}_{\\text{MAP}})^{-1}$。$\\mathbf{C}$ 的对角线元素 $\\mathbf{C}_{ii}$ 是每个参数 $\\theta_i$ 的边际后验方差。这些值量化了我们对每个对数吸收参数估计的不确定性。该算法计算 $\\mathbf{H}(\\boldsymbol{\\theta}_{\\text{MAP}})$，将其求逆以获得 $\\mathbf{C}$，并提取所需的对角线元素。\n具体来说，对于 $n=20$，指令“在代码中，使用 0, floor(n/2), n-1”所要求的索引是 0、10 和 19。我们报告方差 $\\mathbf{C}_{0,0}$、$\\mathbf{C}_{10,10}$ 和 $\\mathbf{C}_{19,19}$。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Solves the 1D QPAT inverse problem for three test cases and reports\n    marginal posterior variances based on the Laplace approximation.\n    \"\"\"\n\n    test_cases_params = [\n        # Case A (general, fully observed)\n        {\n            \"n\": 20, \"D\": 1e-2, \"Gamma\": 1.0, \"q_val\": 1.0,\n            \"mu0\": 0.1, \"delta\": 0.2, \"w\": 0.1,\n            \"sensor_type\": \"all\",\n            \"sigma2\": (1e-2)**2, \"tau2\": (0.5)**2\n        },\n        # Case B (low noise, strong data)\n        {\n            \"n\": 20, \"D\": 1e-2, \"Gamma\": 1.0, \"q_val\": 1.0,\n            \"mu0\": 0.1, \"delta\": 0.2, \"w\": 0.1,\n            \"sensor_type\": \"all\",\n            \"sigma2\": (1e-4)**2, \"tau2\": (0.5)**2\n        },\n        # Case C (partial observations, weaker prior)\n        {\n            \"n\": 20, \"D\": 1e-2, \"Gamma\": 1.0, \"q_val\": 1.0,\n            \"mu0\": 0.1, \"delta\": 0.2, \"w\": 0.1,\n            \"sensor_type\": \"partial\",\n            \"sigma2\": (1e-2)**2, \"tau2\": (1.0)**2\n        }\n    ]\n\n    results = []\n\n    for params in test_cases_params:\n        n = params[\"n\"]\n        D = params[\"D\"]\n        Gamma = params[\"Gamma\"]\n        q_val = params[\"q_val\"]\n        mu0 = params[\"mu0\"]\n        delta = params[\"delta\"]\n        w = params[\"w\"]\n        sensor_type = params[\"sensor_type\"]\n        sigma2 = params[\"sigma2\"]\n        tau2 = params[\"tau2\"]\n\n        h = 1.0 / (n + 1)\n        x_nodes = np.arange(1, n + 1) * h\n        q_vec = np.full(n, q_val)\n\n        # Standard 1D finite difference matrix K\n        K = 2 * np.eye(n) - np.eye(n, k=1) - np.eye(n, k=-1)\n\n        # Ground truth and prior mean\n        mu_a_true = mu0 + delta * np.exp(-(x_nodes - 0.5)**2 / (2 * w**2))\n        theta_true = np.log(mu_a_true)\n        theta_prior = np.log(mu0) * np.ones(n)\n\n        # Sensor selection matrix S\n        if sensor_type == \"all\":\n            m = n\n            S = np.eye(n)\n        elif sensor_type == \"partial\":\n            # 1-based indices {3, 6, ..., 18} -> 0-based {2, 5, ..., 17}\n            sensor_indices = np.arange(2, n, 3)\n            m = len(sensor_indices)\n            S = np.zeros((m, n))\n            S[np.arange(m), sensor_indices] = 1.0\n        \n        # --- Forward Model: g(theta) ---\n        def forward_model(theta):\n            mu_a = np.exp(theta)\n            A = (D / h**2) * K + np.diag(mu_a)\n            # Solve A * Phi = q for Phi\n            phi = linalg.solve(A, q_vec, assume_a='pos')\n            p0 = Gamma * mu_a * phi\n            g = S @ p0\n            return g\n\n        # --- Jacobian: J(theta) ---\n        def jacobian(theta):\n            mu_a = np.exp(theta)\n            A = (D / h**2) * K + np.diag(mu_a)\n            phi = linalg.solve(A, q_vec, assume_a='pos')\n            \n            # Using scipy.linalg.solve is more stable than np.linalg.inv\n            # We solve A * z_j = e_j for each column j of the inverse\n            A_inv = linalg.inv(A)\n            \n            J_full = np.zeros((n, n))\n            for j in range(n):\n                e_j = np.zeros(n)\n                e_j[j] = 1.0\n                A_inv_col_j = A_inv[:, j]\n                # Formula derived from implicit differentiation\n                # d(p0)/d(theta_j) = Gamma * mu_a_j * Phi_j * (e_j - mu_a * (A_inv * e_j))\n                jac_col = Gamma * mu_a[j] * phi[j] * (e_j - mu_a * A_inv_col_j)\n                J_full[:, j] = jac_col\n            \n            return S @ J_full\n\n        # Generate observed data y\n        y_obs = forward_model(theta_true)\n\n        # --- Damped Gauss-Newton for MAP estimate ---\n        theta_map = np.copy(theta_prior)\n        lambda_damping = 1e-3\n        max_iter = 50\n        tol = 1e-8\n\n        for _ in range(max_iter):\n            g_curr = forward_model(theta_map)\n            J_curr = jacobian(theta_map)\n            \n            residual = g_curr - y_obs\n            \n            grad_L = (1 / sigma2) * J_curr.T @ residual + (1 / tau2) * (theta_map - theta_prior)\n\n            if np.linalg.norm(grad_L)  tol:\n                break\n            \n            # Gauss-Newton Hessian\n            H = (1 / sigma2) * (J_curr.T @ J_curr) + (1 / tau2) * np.eye(n)\n            \n            # Damped step\n            H_damped = H + lambda_damping * np.eye(n)\n            \n            try:\n                # Solve (H + lambda*I) d_theta = -grad_L\n                d_theta = linalg.solve(H_damped, -grad_L, assume_a='pos')\n                theta_map += d_theta\n            except linalg.LinAlgError:\n                # In case of instability, increase damping and retry\n                lambda_damping *= 10\n                continue\n\n            # Simple damping adjustment (optional, but good practice)\n            # A full line search or trust-region method would be more robust,\n            # but a simple update is sufficient for this problem.\n            # Here we just decrease damping for next step if solve was successful.\n            lambda_damping *= 0.1\n        \n        # --- Posterior Covariance Calculation ---\n        J_map = jacobian(theta_map)\n        H_map = (1 / sigma2) * (J_map.T @ J_map) + (1 / tau2) * np.eye(n)\n        \n        # Covariance is the inverse of the Hessian\n        C = linalg.inv(H_map)\n        \n        # Extract marginal variances at specified indices\n        # Per problem: \"in code, use 0, floor(n/2), n-1\"\n        # For n=20, this is 0, 10, 19\n        idx1 = 0\n        idx2 = n // 2\n        idx3 = n - 1\n        \n        variances = [C[idx1, idx1], C[idx2, idx2], C[idx3, idx3]]\n        results.append(variances)\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{v[0]},{v[1]},{v[2]}]\" for v in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}