{
    "hands_on_practices": [
        {
            "introduction": "第一个练习旨在通过一个经典的一维反卷积问题，帮助你建立对点扩散函数（PSF）的基本理解。你将在傅里叶域中推导并实现吉洪诺夫正则化反演的分辨率算子。此练习的目标是让你直接观察和量化正则化参数 $\\lambda$ 如何调控噪声抑制与解分辨率之间的基本权衡，其中分辨率通过点扩散函数的半高全宽（FWHM）来衡量。",
            "id": "3417719",
            "problem": "考虑一个一维线性反问题，其离散模型向量为 $m \\in \\mathbb{R}^{N}$，数据向量为 $d \\in \\mathbb{R}^{N}$，由正演模型 $d = A m + n$ 给出。其中，$A$ 是一个具有已知核的离散卷积算子，$n$ 是加性噪声，为零均值高斯噪声，协方差为 $C_{n} = \\sigma^{2} I$。假设采用周期性边界条件，因此 $A$ 是一个循环矩阵。考虑采用零阶惩罚项的 Tikhonov 正则化，即估计量 $\\hat{m}$ 定义为严格凸泛函\n$$\nJ(m) = \\| A m - d \\|_{C_{n}^{-1}}^{2} + \\lambda^{2} \\| m \\|_{2}^{2}\n$$\n的唯一最小化子。其中 $\\| x \\|_{C_{n}^{-1}}^{2} = x^{\\top} C_{n}^{-1} x$，$\\lambda > 0$ 是正则化参数。定义分辨率矩阵（也称为点扩散算子）$R$，其通过精确线性关系 $\\mathbb{E}[\\hat{m}] = R m$ 给出，其中期望是针对数据噪声计算的。网格位置 $j$ 处的点扩散函数 (PSF) 定义为估计量对 $j$ 处单位脉冲的响应，即 $R$ 的第 $j$ 列。换言之，如果真实模型是 $m = e_{j}$（在索引 $j$ 处为 $1$、其他位置为零的标准基向量），那么 $\\mathbb{E}[\\hat{m}]$ 等于以 $j$ 为中心的 PSF。PSF 的半高全宽 (FWHM) 在此定义为 PSF 达到其最大振幅一半的两个点之间的距离，该距离通过网格样本之间的线性插值计算。所有宽度必须以网格单位表示。\n\n您的任务是：\n- 从上述定义和假设 $C_{n} = \\sigma^{2} I$ 及周期性边界条件出发，推导出分辨率矩阵 $R$ 关于 $A$、$\\lambda$ 和 $\\sigma$ 的显式公式，并将在离散网格上的 PSF 刻画为一个函数。\n- 将结果特化到 $A$ 是与已知核进行卷积的情况，并使用离散傅里叶变换 (DFT) 获得一个可实现的 PSF 表达式。\n- 实现一个程序，为下述每个测试案例构建 PSF 并计算其在两个不同正则化参数 $\\lambda$ 下的 FWHM。使用等于 $1$ 的网格间距，以便 FWHM 以网格单位表示。使用相邻样本间的线性插值来确定半最大值交叉位置。在计算 FWHM 之前，将每个 PSF 归一化至单位峰值。将每个 FWHM 四舍五入到六位小数。\n\n需使用的精确定义和约定：\n- 点扩散函数 (PSF)：$R$ 的第 $j$ 列；由于周期性边界条件下的移位不变性，其形状不依赖于 $j$。您必须计算并报告以中间网格索引 $j = \\lfloor N/2 \\rfloor$ 为中心的 PSF。\n- 离散傅里叶变换 (DFT)：一致地使用标准的酉或非酉 DFT；任何一致的归一化方法都是可接受的，因为 PSF 是通过对传递函数进行逆 DFT 后恢复，然后重新归一化至单位峰值。\n- $A$ 的卷积核：下文指定了三种情况。对于高斯核，构建一个周期性离散高斯核 $k[n] \\propto \\exp\\!\\left(-\\tfrac{1}{2} (\\mathrm{dist}(n,0)/\\sigma_{k})^{2}\\right)$，其中 $\\mathrm{dist}(n,0) = \\min\\{ |n|, N - |n| \\}$ 是网格上的循环距离，并进行归一化以使 $\\sum_{n=0}^{N-1} k[n] = 1$。对于 delta 核，使用 $k[0]=1$ 和 $k[n]=0$（对于 $n \\neq 0$）。\n- 半高全宽 (FWHM)：给定一个对称、单峰、非负且已归一化至最大值为 $1$ 的 PSF 剖面 $p[n]$，定义半最大值水平 $h = 1/2$。令 $c = \\lfloor N/2 \\rfloor$ 为中心索引。FWHM 计算为通过在 $c$ 两侧首次跨越 $h$ 的相邻样本对之间进行线性插值，所获得的右侧和左侧半最大值交叉位置之差。假设网格间距为 $1$，结果以网格单位表示。\n\n测试套件：\n- 案例 1 (理想情况)：$N = 257$，噪声标准差 $\\sigma = 0.1$，高斯模糊核标准差 $\\sigma_{k} = 2.0$ 网格单位，两个正则化参数 $\\lambda_{1} = 0.2$ 和 $\\lambda_{2} = 2.0$。\n- 案例 2 (窄核)：$N = 257$，噪声标准差 $\\sigma = 0.1$，高斯模糊核标准差 $\\sigma_{k} = 0.8$ 网格单位，两个正则化参数 $\\lambda_{1} = 0.2$ 和 $\\lambda_{2} = 2.0$。\n- 案例 3 (边界核情况)：$N = 257$，噪声标准差 $\\sigma = 0.1$，delta 核（单位正演算子），两个正则化参数 $\\lambda_{1} = 0.2$ 和 $\\lambda_{2} = 2.0$。\n\n数值与输出要求：\n- 对每个案例，使用推导的方法构建 PSF，并计算两个 $\\lambda$ 值下的 FWHM。必须在周期性边界条件下，使用由循环结构所蕴含的基于 DFT 的方法计算 PSF。\n- 最终程序输出必须是单行，包含一个 Python 风格的列表，内有六个四舍五入到六位小数的浮点数，顺序如下：\n  $[\\text{案例 1 的 } \\mathrm{FWHM}(\\lambda_{1}),\\ \\text{案例 1 的 } \\mathrm{FWHM}(\\lambda_{2}),\\ \\text{案例 2 的 } \\mathrm{FWHM}(\\lambda_{1}),\\ \\text{案例 2 的 } \\mathrm{FWHM}(\\lambda_{2}),\\ \\text{案例 3 的 } \\mathrm{FWHM}(\\lambda_{1}),\\ \\text{案例 3 的 } \\mathrm{FWHM}(\\lambda_{2})]$。\n- 所有宽度必须以网格单位表示，为四舍五入到六位小数的实数。\n- 您的程序必须是完全自包含的，不得读取输入，也不得访问外部资源。它必须仅按所描述的精确格式生成唯一的必需输出行。",
            "solution": "该问题要求推导并实现一种方法，用以计算 Tikhonov 正则化线性反问题的点扩散函数 (PSF) 的半高全宽 (FWHM)。\n\n### 第 1 部分：理论推导\n\n分析始于待最小化的 Tikhonov 泛函：\n$$\nJ(m) = \\| A m - d \\|_{C_{n}^{-1}}^{2} + \\lambda^{2} \\| m \\|_{2}^{2}\n$$\n给定噪声协方差 $C_{n} = \\sigma^{2} I$，其逆为 $C_{n}^{-1} = (\\sigma^{2})^{-1} I$。泛函简化为：\n$$\nJ(m) = \\frac{1}{\\sigma^{2}} \\| A m - d \\|_{2}^{2} + \\lambda^{2} \\| m \\|_{2}^{2} = \\frac{1}{\\sigma^{2}} (A m - d)^{\\top}(A m - d) + \\lambda^{2} m^{\\top}m\n$$\n为求唯一最小化子 $\\hat{m}$，我们将 $J(m)$ 对 $m$ 的梯度置零。\n$$\n\\nabla_{m} J(m) = \\frac{\\partial}{\\partial m} \\left( \\frac{1}{\\sigma^{2}} (m^{\\top}A^{\\top}Am - 2d^{\\top}Am + d^{\\top}d) + \\lambda^{2} m^{\\top}m \\right)\n$$\n使用标准矩阵求导恒等式 $\\nabla_x(x^{\\top}Bx) = (B+B^{\\top})x$（对于对称矩阵 $B$ 简化为 $2Bx$）和 $\\nabla_x(b^{\\top}x) = b$，我们得到梯度：\n$$\n\\nabla_{m} J(m) = \\frac{1}{\\sigma^{2}} (2 A^{\\top} A m - 2 A^{\\top} d) + 2 \\lambda^{2} m\n$$\n对最优估计 $\\hat{m}$ 将梯度置零：\n$$\n\\frac{1}{\\sigma^{2}} (2 A^{\\top} A \\hat{m} - 2 A^{\\top} d) + 2 \\lambda^{2} \\hat{m} = 0\n$$\n两边乘以 $\\sigma^2/2$ 并重新整理，得到此正则化问题的正规方程：\n$$\n(A^{\\top} A + \\sigma^{2} \\lambda^{2} I) \\hat{m} = A^{\\top} d\n$$\n求解 $\\hat{m}$ 可得正则化解的表达式：\n$$\n\\hat{m} = (A^{\\top} A + \\sigma^{2} \\lambda^{2} I)^{-1} A^{\\top} d\n$$\n分辨率矩阵 $R$ 由估计值的期望 $\\mathbb{E}[\\hat{m}]$ 和真实模型 $m_{\\text{true}}$ 之间的关系定义，即 $\\mathbb{E}[\\hat{m}] = R m_{\\text{true}}$。期望是针对噪声分布计算的。将正演模型 $d = A m_{\\text{true}} + n$ 代入 $\\hat{m}$ 的表达式中：\n$$\n\\mathbb{E}[\\hat{m}] = \\mathbb{E}[ (A^{\\top} A + \\sigma^{2} \\lambda^{2} I)^{-1} A^{\\top} (A m_{\\text{true}} + n) ]\n$$\n利用期望的线性性质以及噪声是零均值的（$\\mathbb{E}[n]=0$）：\n$$\n\\mathbb{E}[\\hat{m}] = (A^{\\top} A + \\sigma^{2} \\lambda^{2} I)^{-1} A^{\\top} A m_{\\text{true}} + (A^{\\top} A + \\sigma^{2} \\lambda^{2} I)^{-1} A^{\\top} \\mathbb{E}[n]\n$$\n$$\n\\mathbb{E}[\\hat{m}] = (A^{\\top} A + \\sigma^{2} \\lambda^{2} I)^{-1} A^{\\top} A m_{\\text{true}}\n$$\n将此结果与分辨率矩阵的定义相比较，我们得到其显式形式：\n$$\nR = (A^{\\top} A + \\sigma^{2} \\lambda^{2} I)^{-1} A^{\\top} A\n$$\n问题指定了周期性边界条件，这意味着卷积算子 $A$ 是一个循环矩阵。循环矩阵的一个基本性质是它们可以被离散傅里叶变换 (DFT) 对角化。设 $F$ 为 DFT 矩阵。我们可以写出 $A = F^{-1} \\Lambda_A F$，其中 $\\Lambda_A$ 是一个对角矩阵，其对角线元素是 $A$ 的特征值。这些特征值是 $A$ 第一列（即卷积核 $k$）的 DFT。令 $\\tilde{k} = \\mathcal{F}(k)$ 为这些特征值构成的向量。\n\n转置矩阵 $A^{\\top}$ 也是循环矩阵，其特征值是 $A$ 的特征值的复共轭。因此，$A^{\\top} = F^{-1} \\Lambda_A^* F$，其中 $\\Lambda_A^*$ 的对角线包含 $\\overline{\\tilde{k}}$。乘积 $A^{\\top}A$ 变为：\n$$\nA^{\\top} A = (F^{-1} \\Lambda_A^* F)(F^{-1} \\Lambda_A F) = F^{-1} (\\Lambda_A^* \\Lambda_A) F = F^{-1} |\\Lambda_A|^2 F\n$$\n其中 $|\\Lambda_A|^2$ 是对角线元素为 $|\\tilde{k}_i|^2$ 的对角矩阵。将此代入 $R$ 的表达式中：\n$$\nR = (F^{-1} |\\Lambda_A|^2 F + \\sigma^{2} \\lambda^{2} I)^{-1} (F^{-1} |\\Lambda_A|^2 F)\n$$\n利用 $I = F^{-1}IF$ 和矩阵逆的性质：\n$$\nR = [F^{-1} (|\\Lambda_A|^2 + \\sigma^{2} \\lambda^{2}I) F]^{-1} (F^{-1} |\\Lambda_A|^2 F) = [F^{-1} (|\\Lambda_A|^2 + \\sigma^{2} \\lambda^{2}I)^{-1} F] (F^{-1} |\\Lambda_A|^2 F)\n$$\n$$\nR = F^{-1} [ (|\\Lambda_A|^2 + \\sigma^{2} \\lambda^{2}I)^{-1} |\\Lambda_A|^2 ] F\n$$\n这表明 $R$ 也是一个循环矩阵。它的特征值（我们用向量 $\\tilde{r}$ 表示）由分辨率传递函数给出：\n$$\n\\tilde{r}_i = \\frac{|\\tilde{k}_{i}|^2}{|\\tilde{k}_{i}|^2 + \\sigma^2 \\lambda^2}\n$$\nPSF 是 $R$ 的一列。由于 $R$ 是循环矩阵，其各列是第一列的移位版本。$R$ 的第一列通过对其特征值 $\\tilde{r}$ 应用逆 DFT 获得：\n$$\n\\text{psf}_{\\text{uncentered}} = \\mathcal{F}^{-1}(\\tilde{r})\n$$\n指定的核是实数且对称的，因此它们的 DFT $\\tilde{k}$ 是实数。这使得 $\\tilde{r}$ 是实数且对称的，从而确保得到的 PSF 是实数且关于索引 $0$ 对称。然后将 PSF 进行循环移位，使其中心位于索引 $j = \\lfloor N/2 \\rfloor$ 处。\n\n### 第 2 部分：实现策略\n\nFWHM 的计算遵循以下步骤：\n1.  **核的构建**：对于给定的测试案例，构建大小为 $N$ 的离散卷积核 $k$。对于高斯核，使用周期性距离 $\\mathrm{dist}(n,0) = \\min\\{ |n|, N-|n| \\}$ 定义核，然后归一化使其和为 $1$。对于 delta 核，使用在索引 $0$ 处的单位脉冲。\n2.  **傅里叶变换**：使用 `scipy.fft.fft` 计算核的 DFT，即 $\\tilde{k} = \\mathcal{F}(k)$。\n3.  **传递函数**：使用推导的公式为每个频率分量计算分辨率传递函数 $\\tilde{r}$。\n4.  **PSF 计算**：通过逆 DFT 计算未居中的 PSF，$p = \\mathcal{F}^{-1}(\\tilde{r})$，使用 `scipy.fft.ifft`。取实部以丢弃由数值精度误差引起的可以忽略不计的虚部。\n5.  **居中与归一化**：将 PSF 循环移位 $\\lfloor N/2 \\rfloor$ 个位置，以使其峰值居中。然后通过除以其最大值进行归一化，使得峰值振幅为 $1$。\n6.  **FWHM 计算**：对于归一化的对称 PSF，通过识别其值跨越 $0.5$ 的两个相邻网格点并应用线性插值，找到右侧的半最大值交叉点 $x_{\\text{right}}$。FWHM 随之等于 $2 \\times (x_{\\text{right}} - \\lfloor N/2 \\rfloor)$。对所有测试案例和参数重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating the FWHM for each test case.\n    The final output is a single line containing a list of FWHM values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 257, 'sigma_noise': 0.1, 'kernel_type': 'gaussian', 'sigma_k': 2.0, 'lambdas': [0.2, 2.0]},\n        {'N': 257, 'sigma_noise': 0.1, 'kernel_type': 'gaussian', 'sigma_k': 0.8, 'lambdas': [0.2, 2.0]},\n        {'N': 257, 'sigma_noise': 0.1, 'kernel_type': 'delta', 'sigma_k': None, 'lambdas': [0.2, 2.0]},\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        for lambda_reg in case['lambdas']:\n            fwhm = calculate_psf_and_fwhm(\n                N=case['N'],\n                sigma_noise=case['sigma_noise'],\n                kernel_type=case['kernel_type'],\n                sigma_k=case['sigma_k'],\n                lambda_reg=lambda_reg\n            )\n            results.append(f\"{fwhm:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_psf_and_fwhm(N, sigma_noise, kernel_type, sigma_k, lambda_reg):\n    \"\"\"\n    Constructs the PSF and computes its FWHM for a given set of parameters.\n    \n    Args:\n        N (int): Grid size.\n        sigma_noise (float): Standard deviation of the additive noise.\n        kernel_type (str): Type of convolution kernel ('gaussian' or 'delta').\n        sigma_k (float or None): Standard deviation of the Gaussian kernel.\n        lambda_reg (float): Tikhonov regularization parameter.\n        \n    Returns:\n        float: The computed FWHM in grid units.\n    \"\"\"\n    # Step 1: Construct the convolution kernel k\n    if kernel_type == 'gaussian':\n        n = np.arange(N)\n        # Circular distance from origin for periodic boundary conditions\n        dist = np.minimum(n, N - n)\n        kernel = np.exp(-0.5 * (dist / sigma_k)**2)\n        # Normalize so that the kernel sums to 1\n        kernel /= np.sum(kernel)\n    elif kernel_type == 'delta':\n        kernel = np.zeros(N)\n        kernel[0] = 1.0\n    else:\n        raise ValueError(\"Unknown kernel type specified.\")\n\n    # Step 2: Compute the DFT of the kernel\n    k_tilde = fft.fft(kernel)\n\n    # Step 3: Compute the resolution transfer function r_tilde\n    k_tilde_mag_sq = np.abs(k_tilde)**2\n    sigma_lambda_sq = (sigma_noise * lambda_reg)**2\n    r_tilde = k_tilde_mag_sq / (k_tilde_mag_sq + sigma_lambda_sq)\n\n    # Step 4: Compute the PSF via inverse DFT\n    # For a real and symmetric r_tilde, the ifft is real. We take np.real to handle\n    # potential floating point inaccuracies.\n    psf_uncentered = np.real(fft.ifft(r_tilde))\n\n    # Step 5: Center the PSF at index N // 2\n    center_index = N // 2\n    psf_centered = np.roll(psf_uncentered, center_index)\n\n    # Step 6: Normalize the PSF to have a peak value of 1\n    psf_max = np.max(psf_centered)\n    if psf_max > 0:\n        psf_normalized = psf_centered / psf_max\n    else:\n        # Handle the case of a zero PSF, though unlikely\n        psf_normalized = psf_centered\n\n    # Step 7: Compute the FWHM\n    fwhm = compute_fwhm_from_psf(psf_normalized)\n    \n    return fwhm\n\ndef compute_fwhm_from_psf(psf):\n    \"\"\"\n    Computes the Full Width at Half Maximum for a normalized, centered PSF.\n    \n    Args:\n        psf (np.ndarray): A 1D array representing the centered, normalized PSF.\n        \n    Returns:\n        float: The FWHM value.\n    \"\"\"\n    N = len(psf)\n    center_index = N // 2\n    half_max = 0.5\n    \n    # Check if PSF is a delta function (only one non-zero point at the center)\n    if psf[center_index] == 1.0 and np.sum(psf) == 1.0:\n        # By our linear interpolation definition between grid points [c] and [c+1]\n        # with values 1.0 and 0.0, the half-max is crossed at c+0.5.\n        # FWHM = 2 * ((c+0.5) - c) = 1.0\n        return 1.0\n\n    # Search for the crossing on the right side of the center\n    # Find the index of the first point that drops below half_max\n    try:\n        # `[0]` accesses the array from the tuple, `[0]` gets the first index\n        first_idx_below_rel = np.where(psf[center_index:]  half_max)[0][0]\n    except IndexError:\n        # This occurs if the PSF never drops below 0.5, e.g., if it's broad and flat.\n        #  In this case, the FWHM is arguably the width of the domain.\n        return float(N)\n\n    # The point just before this one is above or at half_max\n    idx_above_rel = first_idx_below_rel - 1\n    \n    # Get absolute indices in the full PSF array\n    idx_above_abs = center_index + idx_above_rel\n    idx_below_abs = center_index + first_idx_below_rel\n\n    # Get values and coordinates for linear interpolation\n    y1 = psf[idx_above_abs]  # Value >= 0.5\n    y2 = psf[idx_below_abs]  # Value  0.5\n    \n    x1 = float(idx_above_abs)\n    x2 = float(idx_below_abs)\n\n    # Linear interpolation to find x_right where y = half_max\n    # x = x1 + (y - y1) * (x2 - x1) / (y2 - y1)\n    if (y2 - y1) == 0:\n         # Avoid division by zero, though unlikely if y1 > 0.5 and y2  0.5\n         x_right = (x1 + x2) / 2.0\n    else:\n         x_right = x1 + (half_max - y1) * (x2 - x1) / (y2 - y1)\n         \n    # Due to symmetry, FWHM is twice the distance from the center to the right crossing\n    fwhm = 2.0 * (x_right - float(center_index))\n    \n    return fwhm\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "从理想化的反卷积问题转向更具应用性的数据同化场景，本练习将探讨观测系统的设计如何影响分辨率。你将为不同的传感器网络配置构建平均核（averaging kernel），它在数据同化中等同于分辨率矩阵。这个练习将帮助你把信号自由度（DFS）和点扩散函数半高全宽（FWHM）等抽象指标，与评估特定观测网络在多大程度上能解析真实状态这一实际问题联系起来。",
            "id": "3417773",
            "problem": "给定一个一维线性高斯数据同化设置，其空间状态位于一条线段上，并有两个由不同观测算子表示的独立传感器网络。对于每种场景，两个网络的背景误差协方差和观测误差协方差是相同的。您的任务是，为每个场景中的每个传感器网络计算信号自由度（DFS）和代表性点扩散函数（PSF）的半峰全宽（FWHM），然后按规定汇总结果。\n\n基本原理和定义：\n- 数据同化更新是线性高斯的，且误差是加性的。空间状态表示为 $x \\in \\mathbb{R}^N$，观测向量为 $y \\in \\mathbb{R}^M$，观测算子为 $H \\in \\mathbb{R}^{M \\times N}$，背景误差协方差为 $B \\in \\mathbb{R}^{N \\times N}$，观测误差协方差为 $R \\in \\mathbb{R}^{M \\times M}$。\n- 卡尔曼增益 $K \\in \\mathbb{R}^{N \\times M}$ 由经过充分检验的公式 $K = B H^\\top (H B H^\\top + R)^{-1}$ 定义。\n- 平均核（也称为分辨率矩阵）$A \\in \\mathbb{R}^{N \\times N}$ 定义为 $A = K H$，它量化了分析场如何对真实状态扰动做出线性响应。\n- 信号自由度（DFS）定义为 $\\mathrm{DFS} = \\mathrm{trace}(A)$。\n- 位于位置 $j$ 的点扩散函数（PSF）是矩阵 $A$ 的第 $j$ 列，它表示分析场对真实状态中索引 $j$ 处单位脉冲的响应的空间分布。代表性 PSF 取自中心网格索引 $j_0 = \\lfloor N/2 \\rfloor$。\n- 半峰全宽（FWHM）是在 PSF 最大振幅一半处测得的宽度，以物理单位表示。它必须以公里为单位计算。\n\n空间域和离散化：\n- 空间域是一维区间 $[0,L]$，其中 $L$ 的单位是公里。状态在 $N$ 个均匀间隔的网格点上离散化，$x_i$ 位于位置 $p_i = i \\,\\Delta x$，其中 $i = 0,1,\\dots,N-1$，$\\Delta x = L/(N-1)$ 的单位是公里。\n\n协方差：\n- 背景误差协方差 $B$ 使用高斯相关模型构建，其方差为 $\\sigma_b^2$，相关长度为 $L_b$（公里）：$B_{ij} = \\sigma_b^2 \\exp\\!\\left(-\\frac{(p_i - p_j)^2}{2 L_b^2}\\right)$。\n- 观测误差协方差 $R$ 是对角矩阵，其对角线元素为 $\\sigma_r^2$（同方差），即 $R = \\sigma_r^2 I_M$。\n\n观测算子：\n- 每个传感器网络由一组沿 $[0,L]$ 分布的传感器位置 $\\{s_m\\}_{m=1}^M$ 定义，每个传感器测量状态的高斯加权局部平均值，其足迹宽度参数（标准差）为 $L_h$（公里）。观测算子 $H$ 的行 $H_{m,:}$ 定义为\n$$\nH_{m,i} = \\frac{\\exp\\!\\left(-\\frac{(p_i - s_m)^2}{2 L_h^2}\\right)}{\\sum_{k=0}^{N-1} \\exp\\!\\left(-\\frac{(p_k - s_m)^2}{2 L_h^2}\\right)},\n$$\n因此每行之和为 $1$。\n\n每个场景的计算任务：\n1. 使用指定的 $L$、$N$、$\\sigma_b^2$、$L_b$ 和 $\\sigma_r^2$ 构建 $B$ 和 $R$。\n2. 使用各自的传感器位置和足迹宽度构建两个不同的观测算子 $H^{(1)}$ 和 $H^{(2)}$。\n3. 对于每个 $H$，使用公式 $K = B H^\\top (H B H^\\top + R)^{-1}$ 计算卡尔曼增益 $K$。\n4. 为每个网络计算平均核 $A = K H$。\n5. 为每个网络计算 $\\mathrm{DFS} = \\mathrm{trace}(A)$。\n6. 提取代表性 PSF 作为 $A$ 的第 $j_0 = \\lfloor N/2 \\rfloor$ 列，并计算其 FWHM（以公里为单位）。FWHM 必须通过对在网格位置 $p_i$ 处采样的 PSF 进行线性插值来计算，以确定左、右半峰值交叉点。如果 PSF 的最大值为非正数，或者在域内无法同时找到两个半峰值交叉点，则将 FWHM 作为非数值（not-a-number）返回。\n\n测试套件：\n对于每个场景，提供了两个传感器网络，它们仅在观测算子 $H$ 上有所不同，而共享相同的 $B$ 和 $R$。\n\n- 场景 1：\n  - $L = 100$，$N = 50$，$\\sigma_b^2 = 1.0$，$L_b = 10$，$\\sigma_r^2 = 0.04$。\n  - 网络 1：$M_1 = 25$ 个传感器，其位置在 $[0,L]$ 上均匀分布（包括端点），足迹宽度 $L_{h,1} = 4$。\n  - 网络 2：$M_2 = 8$ 个传感器，其位置在 $[0,L]$ 上均匀分布（包括端点），足迹宽度 $L_{h,2} = 6$。\n\n- 场景 2：\n  - $L = 100$，$N = 50$，$\\sigma_b^2 = 1.0$，$L_b = 5$，$\\sigma_r^2 = 0.01$。\n  - 网络 1：$M_1 = 50$ 个传感器，其位置在 $[0,L]$ 上均匀分布（包括端点），足迹宽度 $L_{h,1} = 2$。\n  - 网络 2：$M_2 = 4$ 个传感器，其位置在 $[0,L]$ 上均匀分布（包括端点），足迹宽度 $L_{h,2} = 8$。\n\n- 场景 3：\n  - $L = 100$，$N = 50$，$\\sigma_b^2 = 1.0$，$L_b = 15$，$\\sigma_r^2 = 1.0$。\n  - 网络 1：$M_1 = 20$ 个传感器，其位置在 $[0,L]$ 上均匀分布（包括端点），足迹宽度 $L_{h,1} = 4$。\n  - 网络 2：$M_2 = 20$ 个传感器，其位置在 $[0,L]$ 上均匀分布，但偏移了标称传感器间距的一半（裁剪以保持在 $[0,L]$ 内），足迹宽度 $L_{h,2} = 4$。\n\n所需输出和单位：\n- 对于每个场景中的每个传感器网络，计算：\n  - DFS，作为一个浮点数（无单位）。\n  - 代表性 PSF 的 FWHM，以公里为单位，作为一个浮点数。\n- 最终程序输出必须是单行，包含一个逗号分隔的列表，用方括号括起来，按以下顺序汇总结果：\n  $[\\mathrm{DFS}_{1,1},\\mathrm{FWHM}_{1,1},\\mathrm{DFS}_{1,2},\\mathrm{FWHM}_{1,2},\\mathrm{DFS}_{2,1},\\mathrm{FWHM}_{2,1},\\mathrm{DFS}_{2,2},\\mathrm{FWHM}_{2,2},\\mathrm{DFS}_{3,1},\\mathrm{FWHM}_{3,1},\\mathrm{DFS}_{3,2},\\mathrm{FWHM}_{3,2}]$，其中第一个索引表示场景编号，第二个索引表示场景内的网络编号。FWHM 值必须以公里表示。如果 FWHM 无法按规定确定，则将其值输出为非数值浮点数。\n\n您的程序必须按照指定格式精确地生成一行输出，不含任何额外文本。不需要输入；所有参数值均已在上面提供。",
            "solution": "该问题被评估为有效。它在科学上基于线性高斯数据同化的原理，问题陈述清晰，提供了所有必要的参数和定义，并且表述客观。计算任务明确具体，并且是可行的。\n\n解决方案通过为三个场景中的每一个（每个场景包含两个传感器网络）实施定义的计算步骤来展开。\n\n问题的核心在于计算平均核矩阵 $A \\in \\mathbb{R}^{N \\times N}$，该矩阵描述了估计状态（分析场）如何成为真实状态的空间加权平均。分析场 $x_a$ 与背景场 $x_b$ 和观测向量 $y$ 通过方程 $x_a = x_b + K(y - Hx_b)$ 相关联，其中 $K$ 是卡尔曼增益。当考虑分析场与真实状态 $x_t$ 之间的关系时，假设 $y = Hx_t + \\epsilon_r$ 和 $x_b = x_t + \\epsilon_b$（其中 $\\epsilon_r$ 和 $\\epsilon_b$ 分别是观测误差和背景误差），则期望的分析场为 $\\mathbb{E}[x_a] = (I - KH)x_b + KHy$。假设背景场是无偏的 $\\mathbb{E}[x_b] = x_t$ 且观测是无偏的 $\\mathbb{E}[y] = Hx_t$，则分析场也是无偏的：$\\mathbb{E}[x_a] = x_t$。矩阵 $A = KH$ 是平均核，它将分析场扰动与真实状态扰动关联起来。\n\n每个网络的处理流程如下：\n\n1.  **离散化空间域**：将长度为 $L$ 的一维域离散化为 $N$ 个网格点。这些点的位置由 $p_i = i \\cdot \\Delta x$ 给出，其中 $i \\in \\{0, 1, \\dots, N-1\\}$，网格间距为 $\\Delta x = L/(N-1)$。\n\n2.  **构建协方差矩阵**：\n    *   背景误差协方差矩阵 $B \\in \\mathbb{R}^{N \\times N}$ 使用高斯相关函数构建。元素 $B_{ij}$ 表示网格点 $i$ 和 $j$ 处背景误差之间的协方差。\n        $$\n        B_{ij} = \\sigma_b^2 \\exp\\!\\left(-\\frac{(p_i - p_j)^2}{2 L_b^2}\\right)\n        $$\n        其中 $\\sigma_b^2$ 是背景误差方差，$L_b$ 是相关长度。\n    *   观测误差协方差矩阵 $R \\in \\mathbb{R}^{M \\times M}$ 假设为对角矩阵，表示观测误差不相关。对于同方差误差，该矩阵是一个缩放的单位矩阵：\n        $$\n        R = \\sigma_r^2 I_M\n        $$\n        其中 $\\sigma_r^2$ 是观测误差方差，$I_M$ 是 $M \\times M$ 的单位矩阵。\n\n3.  **构建观测算子**：观测算子 $H \\in \\mathbb{R}^{M \\times N}$ 将状态空间映射到观测空间。$H$ 的每一行 $m$ 对应一个传感器，并定义为状态变量的归一化高斯加权平均。\n    $$\n    H_{m,i} = \\frac{\\exp\\!\\left(-\\frac{(p_i - s_m)^2}{2 L_h^2}\\right)}{\\sum_{k=0}^{N-1} \\exp\\!\\left(-\\frac{(p_k - s_m)^2}{2 L_h^2}\\right)}\n    $$\n    这里，$s_m$ 是第 $m$ 个传感器的位置，$L_h$ 是足迹宽度参数。分母确保 $H$ 的每一行之和为 1，使每次观测成为一个真正的加权平均。传感器位置根据每个网络指定的配置确定。\n\n4.  **计算平均核**：\n    *   首先，计算卡尔曼增益矩阵 $K \\in \\mathbb{R}^{N \\times M}$。它提供了背景信息和新观测之间的最优权重。\n        $$\n        K = B H^\\top (H B H^\\top + R)^{-1}\n        $$\n    *   接下来，计算平均核矩阵 $A \\in \\mathbb{R}^{N \\times N}$。\n        $$\n        A = K H\n        $$\n\n5.  **计算分辨率指标**：\n    *   **信号自由度 (DFS)**：这个标量值衡量了状态中可被观测约束的独立信号的数量。它是平均核的迹。\n        $$\n        \\mathrm{DFS} = \\mathrm{trace}(A)\n        $$\n    *   **半峰全宽 (FWHM)**：此指标量化了分析场的空间分辨率。点扩散函数 (PSF) 是平均核的一列，$A_{:,j}$，表示分析场对真实状态在网格点 $j$ 处的狄拉克δ函数扰动的响应。我们使用中心网格索引 $j_0 = \\lfloor N/2 \\rfloor$ 处的代表性 PSF。FWHM 是此 PSF 剖面在其最大振幅一半处的宽度。其计算涉及：\n        1.  提取列向量 $A_{:,j_0}$。\n        2.  找到其最大值 $A_{\\max}$。\n        3.  确定半峰值 $A_{\\max}/2$。\n        4.  在 PSF 剖面（在位置 $p_i$ 处采样）上使用线性插值，找到两个空间位置 $x_{\\text{left}}$ 和 $x_{\\text{right}}$，在这两个位置 PSF 的值等于 $A_{\\max}/2$。\n        5.  FWHM 随后计算为 $x_{\\text{right}} - x_{\\text{left}}$（以公里为单位）。如果最大值为非正数，或者无法在域内找到两个半峰值交叉点，则认为 FWHM 未定义，并表示为非数值 (NaN)。\n\n这些步骤被系统地应用于六个指定的网络配置中的每一个（三个场景，每个场景两个网络）。所得的十二个值（每个配置的 $\\mathrm{DFS}$ 和 $\\mathrm{FWHM}$）按要求汇总到一个列表中。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_fwhm(psf: np.ndarray, p: np.ndarray) -> float:\n    \"\"\"\n    Computes the Full Width at Half Maximum (FWHM) of a point-spread function.\n\n    Args:\n        psf: The point-spread function values at grid points.\n        p: The spatial positions of the grid points (in km).\n\n    Returns:\n        The FWHM in kilometers, or np.nan if it cannot be determined.\n    \"\"\"\n    if psf.size != p.size:\n        raise ValueError(\"psf and p must have the same size.\")\n    \n    n = psf.shape[0]\n    max_val = np.max(psf)\n\n    if max_val = 0:\n        return np.nan\n\n    half_max_val = max_val / 2.0\n    max_idx = np.argmax(psf)\n\n    # Find left crossing\n    # Find indices on the left of the peak where psf is below half_max\n    left_indices = np.where(psf[:max_idx] = half_max_val)[0]\n    if left_indices.size == 0:\n        return np.nan  # No crossing on the left side\n    \n    i_left = left_indices[-1]\n    p1, p2 = p[i_left], p[i_left + 1]\n    v1, v2 = psf[i_left], psf[i_left + 1]\n    left_pos = p1 + (p2 - p1) * (half_max_val - v1) / (v2 - v1)\n\n    # Find right crossing\n    # Find indices on the right of the peak where psf is below half_max\n    # We search in psf[max_idx+1:] and then adjust the index\n    right_indices = np.where(psf[max_idx+1:] = half_max_val)[0]\n    if right_indices.size == 0:\n        return np.nan  # No crossing on the right side\n    \n    i_right = right_indices[0] + max_idx + 1\n    p1, p2 = p[i_right - 1], p[i_right]\n    v1, v2 = psf[i_right - 1], psf[i_right]\n    right_pos = p1 + (p2 - p1) * (half_max_val - v1) / (v2 - v1)\n\n    return right_pos - left_pos\n\ndef compute_metrics(L, N, sigma_b2, L_b, sigma_r2, M, sensor_config, L_h):\n    \"\"\"\n    Computes DFS and FWHM for a given data assimilation setup.\n    \"\"\"\n    # 1. Setup Domain\n    p = np.linspace(0, L, N)\n    delta_x = L / (N - 1)\n\n    # 2. Construct Covariance Matrices\n    # B matrix: Background Error Covariance\n    dist_sq = (p[:, None] - p[None, :])**2\n    B = sigma_b2 * np.exp(-dist_sq / (2 * L_b**2))\n    \n    # R matrix: Observation Error Covariance\n    R = sigma_r2 * np.eye(M)\n\n    # 3. Construct Observation Operator H\n    # Sensor positions\n    if sensor_config[0] == 'uniform':\n        s = np.linspace(0, L, M)\n    elif sensor_config[0] == 'shifted':\n        if M > 1:\n            nominal_spacing = L / (M - 1)\n            shift = nominal_spacing / 2.0\n            s_nominal = np.linspace(0, L, M)\n            s_shifted = s_nominal + shift\n            s = np.clip(s_shifted, 0, L)\n        else: # Handle M=1 case\n             s = np.array([L/2.0])\n    else:\n        raise ValueError(f\"Unknown sensor_config: {sensor_config}\")\n\n    H = np.zeros((M, N))\n    for m in range(M):\n        weights = np.exp(-(p - s[m])**2 / (2 * L_h**2))\n        H[m, :] = weights / np.sum(weights)\n\n    # 4. Data Assimilation Calculations\n    HBHt = H @ B @ H.T\n    S_inv = np.linalg.inv(HBHt + R)\n    K = B @ H.T @ S_inv\n    A = K @ H\n\n    # 5. Calculate Metrics\n    dfs = np.trace(A)\n    \n    j0 = N // 2\n    psf = A[:, j0]\n    fwhm = calculate_fwhm(psf, p)\n    \n    return dfs, fwhm\n\ndef solve():\n    \"\"\"\n    Main function to run all test scenarios and print results.\n    \"\"\"\n    test_cases = [\n        # Scenario 1, Net 1\n        {'L': 100, 'N': 50, 'sigma_b2': 1.0, 'L_b': 10, 'sigma_r2': 0.04, 'M': 25, 'sensor_config': ('uniform',), 'L_h': 4},\n        # Scenario 1, Net 2\n        {'L': 100, 'N': 50, 'sigma_b2': 1.0, 'L_b': 10, 'sigma_r2': 0.04, 'M': 8, 'sensor_config': ('uniform',), 'L_h': 6},\n        # Scenario 2, Net 1\n        {'L': 100, 'N': 50, 'sigma_b2': 1.0, 'L_b': 5, 'sigma_r2': 0.01, 'M': 50, 'sensor_config': ('uniform',), 'L_h': 2},\n        # Scenario 2, Net 2\n        {'L': 100, 'N': 50, 'sigma_b2': 1.0, 'L_b': 5, 'sigma_r2': 0.01, 'M': 4, 'sensor_config': ('uniform',), 'L_h': 8},\n        # Scenario 3, Net 1\n        {'L': 100, 'N': 50, 'sigma_b2': 1.0, 'L_b': 15, 'sigma_r2': 1.0, 'M': 20, 'sensor_config': ('uniform',), 'L_h': 4},\n        # Scenario 3, Net 2\n        {'L': 100, 'N': 50, 'sigma_b2': 1.0, 'L_b': 15, 'sigma_r2': 1.0, 'M': 20, 'sensor_config': ('shifted',), 'L_h': 4},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        dfs, fwhm = compute_metrics(**params)\n        all_results.append(dfs)\n        all_results.append(fwhm)\n    \n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后一个练习处理一个关键的高级主题：模型误差对反演结果的影响。我们将探究当反演中使用的正向模型与真实物理过程不完全匹配时会发生什么，这在实践中是常见情况。通过推导一个模型错配的反卷积问题中的分辨率算子，你将学会识别并量化诸如过度锐化和负旁瓣等常见的人为干扰（artifacts），从而培养出批判性评估反问题解的关键技能。",
            "id": "3417750",
            "problem": "考虑一个长度为 $N$、单位网格间距的一维周期性网格。设正向算子 $H$ 是通过点扩散函数 (PSF) $P$ 的循环卷积，因此对于真实模型 $m_{\\text{true}}$ 和数据 $d$，\n$$\nd = H\\,m_{\\text{true}} + n,\n$$\n其中 $n$ 代表加性噪声，该噪声是白噪声且已被预白化至单位方差。假设一位分析师使用假定的 PSF $\\tilde{P}$ 和一个单位正则化算子来构建二次惩罚（吉洪诺夫）估计器，以寻求一个最小化以下表达式的估计值 $\\hat{m}$：\n$$\n\\| \\tilde{H}\\,m - d \\|_2^2 + \\alpha^2 \\| m \\|_2^2,\n$$\n其中 $\\tilde{H}$ 是通过 $\\tilde{P}$ 的循环卷积，$\\alpha0$ 是正则化参数。该线性估计器可以写成 $\\hat{m} = W\\,d$ 的形式，其中算子 $W$ 由 $(\\tilde{H},\\alpha)$ 确定。相对于真实正向映射 $H$ 的分辨率算子（也称为平均核）定义为：\n$$\nA = W\\,H,\n$$\n因此，均值估计（在无噪声的情况下）满足 $\\hat{m} = A\\,m_{\\text{true}}$。\n\n您将在周期性边界条件下，在离散傅里叶域中进行操作，仅使用以下基本事实：循环卷积可通过离散傅里叶变换对角化，以及通过最小化严格凸二次泛函得到的二次惩罚估计器是线性的。您将：\n- 从二次最小化问题的正规方程和循环卷积通过离散傅里叶变换的对角化出发，推导在正确指定情况 $\\tilde{P}=P$ 和错误指定情况 $\\tilde{P}\\neq P$ 下 $A$ 的频率响应表达式。\n- 对离散 PSF $P$ 和 $\\tilde{P}$ 进行数值实现，这些 PSF 是标准差为 $\\sigma$ 和 $\\tilde{\\sigma}$（以网格单位度量）、归一化使其总和为 1 的循环包裹的离散高斯函数。具体来说，将索引 $n\\in\\{0,1,\\dots,N-1\\}$ 上的离散 PSF 定义为：\n$$\nP[n] \\propto \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{\\min(n,\\,N-n)}{\\sigma}\\right)^2\\right),\n$$\n并进行归一化以强制 $\\sum_{n=0}^{N-1} P[n] = 1$，对带有 $\\tilde{\\sigma}$ 的 $\\tilde{P}$ 也进行类似操作。\n- 通过对其频率响应进行逆变换，计算在正确指定和错误指定情况下空间域中的离散分辨率核（在周期性边界条件下 $A$ 的第一行）。\n\n按如下方式量化分辨率和伪影：\n- 令 $a_{\\text{cor}}[n]$ 表示正确情况下的分辨率核，$a_{\\text{mis}}[n]$ 表示错误指定情况下的分辨率核。对于任何在索引 0 处具有全局最大值的偶核 $a[n]$，将半峰全宽 (FWHM) 定义为 $2x_{1/2}$ 网格单位，其中 $x_{1/2}\\ge 0$ 是最小的非负实数，使得当从 $n=0$ 向正索引移动时，在网格点之间进行线性插值的核首次穿过其峰值的一半。在包含半峰值穿越点的第一对连续索引之间使用线性插值。\n- 将过锐化比定义为：\n$$\nr = \\frac{\\text{FWHM}(a_{\\text{mis}})}{\\text{FWHM}(a_{\\text{cor}})}.\n$$\n当 $r1$ 时，表示相对于正确指定的情况存在过锐化。\n- 将核 $a[n]$ 在主瓣外的伪影比定义为：\n$$\n\\eta(a) = \\frac{\\sum_{n=0}^{N-1} |a[n]| - \\sum_{|n|\\le \\lfloor x_{1/2}\\rfloor} |a[n]|}{\\sum_{n=0}^{N-1} |a[n]|},\n$$\n其中索引区间 $|n|\\le \\lfloor x_{1/2}\\rfloor$ 表示集合 $\\{0,1,\\dots,\\lfloor x_{1/2}\\rfloor\\}$ 及其关于模 $N$ 的对称部分。使用周期对称性和偶性来考虑两侧。将错误指定下的伪影增加量定义为：\n$$\n\\Delta \\eta = \\eta(a_{\\text{mis}}) - \\eta(a_{\\text{cor}}).\n$$\n- 将核 $a[n]$ 的最负旁瓣振幅定义为 $\\min_n a[n]$。\n\n您的程序必须使用离散傅里叶变换实现上述步骤，以获取给定测试套件的正确情况和错误指定情况下的分辨率核。对于每个测试用例，计算并返回三元组 $[r, \\Delta\\eta, \\min_n a_{\\text{mis}}[n]]$，其值为浮点数。\n\n测试套件（每个用例为 $(N,\\sigma,\\tilde{\\sigma},\\alpha)$）：\n- 用例 1：$(512, 3.0, 3.0, 0.1)$。\n- 用例 2：$(512, 3.0, 2.0, 0.1)$。\n- 用例 3：$(512, 3.0, 4.5, 0.1)$。\n- 用例 4：$(512, 3.0, 2.0, 0.5)$。\n- 用例 5：$(512, 3.0, 2.0, 0.01)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其中每个项目本身是对应测试用例的三个逗号分隔浮点数的列表，顺序为 $[r, \\Delta\\eta, \\min a_{\\text{mis}}]$，例如：\n[[r1,DeltaEta1,minMis1],[r2,DeltaEta2,minMis2],...]。\n不允许外部输入，所有计算都必须假定周期性边界条件和上述定义。所有角度（如果出现）都必须以弧度为单位，但此处没有角度。不涉及物理单位；所有网格单位都是无量纲的。",
            "solution": "问题陈述已经过仔细审查，并被确定为有效。它在科学上基于反演问题理论的原理，特别是吉洪诺夫正则化和分辨率分析。该问题是适定的、客观的，并为唯一的、可验证的解提供了一套完整且一致的定义和数据。\n\n问题的核心是推导和计算线性反演问题的分辨率算子，包括当系统的点扩散函数（PSF）模型正确时和被错误指定时两种情况。我们将在离散傅里叶域中进行操作，在该域中循环卷积变为简单的乘法。\n\n### 分辨率算子频率响应的推导\n\n给定要最小化的吉洪诺夫正则化代价泛函：\n$$\nJ(m) = \\| \\tilde{H}m - d \\|_2^2 + \\alpha^2 \\| m \\|_2^2\n$$\n这里，$m$ 是我们寻求的模型向量，$d$ 是数据向量，$\\tilde{H}$ 是基于假定 PSF $\\tilde{P}$ 的正向算子，$\\alpha  0$ 是正则化参数。范数 $\\| \\cdot \\|_2$ 是欧几里得范数。算子 $\\tilde{H}$ 表示与 $\\tilde{P}$ 的循环卷积。\n\n为了找到最小化 $J(m)$ 的模型估计 $\\hat{m}$，我们计算 $J(m)$ 相对于 $m$ 的梯度并将其设为零。对于实值模型和算子，这给出：\n$$\n\\nabla_m J(m) = 2 \\tilde{H}^T (\\tilde{H}m - d) + 2 \\alpha^2 m = 0\n$$\n其中 $\\tilde{H}^T$ 是 $\\tilde{H}$ 的转置。在更一般的复数情况下，转置被共轭转置 $\\tilde{H}^*$ 所取代。重新排列各项以求解 $m$，得到正规方程：\n$$\n(\\tilde{H}^T \\tilde{H} + \\alpha^2 I) m = \\tilde{H}^T d\n$$\n其中 $I$ 是单位算子。因此，解 $\\hat{m}$ 由下式给出：\n$$\n\\hat{m} = (\\tilde{H}^T \\tilde{H} + \\alpha^2 I)^{-1} \\tilde{H}^T d\n$$\n这将估计值 $\\hat{m}$ 表示为数据 $d$ 的线性变换。我们已知 $\\hat{m} = Wd$，所以估计算子 $W$ 是：\n$$\nW = (\\tilde{H}^T \\tilde{H} + \\alpha^2 I)^{-1} \\tilde{H}^T\n$$\n分辨率算子（或平均核）$A$ 通过 $\\hat{m} = A m_{\\text{true}}$（在无噪声的情况下，其中 $d = H m_{\\text{true}}$）将均值估计与真实模型 $m_{\\text{true}}$ 联系起来。其定义为 $A = WH$。代入 $W$ 和 $d$ 的表达式：\n$$\n\\hat{m} = Wd = W(H m_{\\text{true}}) = (WH) m_{\\text{true}}\n$$\n因此，分辨率算子为：\n$$\nA = W H = (\\tilde{H}^T \\tilde{H} + \\alpha^2 I)^{-1} \\tilde{H}^T H\n$$\n该问题设置在周期性网格上，因此循环卷积算子可通过离散傅里叶变换 (DFT) 对角化。令 $\\mathcal{F}$ 表示 DFT 算子。任何带有核 $c$ 的循环卷积算子 $C$ 都可被对角化为 $C = \\mathcal{F}^{-1} D_c \\mathcal{F}$，其中 $D_c$ 是一个对角矩阵，其对角线元素是核 $c$ 的 DFT，记为 $\\hat{c}$。算子的频率响应就是这组对角线元素。\n\n算子 $H$ 和 $\\tilde{H}$ 在傅里叶域中对应于对角矩阵，其对角线元素分别为 $\\hat{P}[k]$ 和 $\\hat{P}_{\\text{tilde}}[k]$，即真实 PSF $P$ 和假定 PSF $\\tilde{P}$ 的 DFT。共轭转置 $\\tilde{H}^*$（对于实核，即为 $\\tilde{H}^T$）对应于一个对角矩阵，其元素为 $\\hat{P}_{\\text{tilde}}[k]^*$。\n\n将 $A$ 的表达式转换到傅里叶域，每个算子都被其对应的频率响应对角矩阵所取代。A 的频率响应的第 $k$ 个分量，记为 $\\hat{A}[k]$，是：\n$$\n\\hat{A}[k] = \\frac{1}{|\\hat{P}_{\\text{tilde}}[k]|^2 + \\alpha^2} \\cdot \\hat{P}_{\\text{tilde}}[k]^* \\cdot \\hat{P}[k]\n$$\n给定的 PSF 是实数且对称的（对于 $n \\neq 0$ 有 $P[n] = P[N-n]$），因此它们的 DFT $\\hat{P}[k]$ 和 $\\hat{P}_{\\text{tilde}}[k]$ 是实数值。表达式简化为：\n$$\n\\hat{A}[k] = \\frac{\\hat{P}_{\\text{tilde}}[k] \\hat{P}[k]}{\\hat{P}_{\\text{tilde}}[k]^2 + \\alpha^2}\n$$\n这是分辨率算子的一般频率响应。我们现在考虑两种指定情况。\n\n1.  **正确指定情况 ($\\tilde{P} = P$):**\n    如果假定的 PSF 是正确的，即 $\\tilde{P} = P$，这意味着 $\\hat{P}_{\\text{tilde}}[k] = \\hat{P}[k]$。分辨率算子 $\\hat{A}_{\\text{cor}}$ 的频率响应变为：\n    $$\n    \\hat{A}_{\\text{cor}}[k] = \\frac{\\hat{P}[k]^2}{\\hat{P}[k]^2 + \\alpha^2}\n    $$\n\n2.  **错误指定情况 ($\\tilde{P} \\neq P$):**\n    如果假定的 PSF 不正确，则一般公式直接适用于频率响应 $\\hat{A}_{\\text{mis}}$：\n    $$\n    \\hat{A}_{\\text{mis}}[k] = \\frac{\\hat{P}_{\\text{tilde}}[k] \\hat{P}[k]}{\\hat{P}_{\\text{tilde}}[k]^2 + \\alpha^2}\n    $$\n\n### 数值实现\n\n实现过程如下：\n1.  **PSF 生成：**对于给定的参数 $(N, \\sigma)$，使用公式 $P[n] \\propto \\exp(-\\frac{1}{2}(\\frac{\\min(n, N-n)}{\\sigma})^2)$（其中 $n \\in \\{0, 1, ..., N-1\\}$）生成一个离散的、循环包裹的高斯 PSF。将生成的向量归一化，使其总和为 1。对 $(\\sigma)$ 和 $(\\tilde{\\sigma})$ 都执行此操作，以分别获得 $P$ 和 $\\tilde{P}$。\n2.  **傅里叶变换：**使用 `numpy.fft.fft` 计算 $P$ 和 $\\tilde{P}$ 的 DFT。如前所述，得到的频域表示 $\\hat{P}$ 和 $\\hat{P}_{\\text{tilde}}$ 是实数值的。\n3.  **分辨率核：**使用推导出的公式计算频率响应 $\\hat{A}_{\\text{cor}}[k]$ 和 $\\hat{A}_{\\text{mis}}[k]$。然后，通过应用逆 DFT (`numpy.fft.ifft`) 获得空间域分辨率核 $a_{\\text{cor}}[n]$ 和 $a_{\\text{mis}}[n]$。得到的核是实数且对称的，中心位于索引 $n=0$ 处。\n4.  **度量计算：**从空间核计算所需的度量：\n    - **FWHM：**为每个核计算半峰全宽。由于核以 $n=0$ 为中心，我们找到最小的非负值 $x_{1/2}$，在该处线性插值的核值等于其峰值的一半，即 $a[0]/2$。FWHM 为 $2x_{1/2}$。这涉及找到第一个网格区间 $[i, i+1]$，其中 $a[i] \\ge a[0]/2$ 且 $a[i+1]  a[0]/2$，然后进行线性插值。\n    - **过锐化比 ($r$)：**计算比率 $\\text{FWHM}(a_{\\text{mis}}) / \\text{FWHM}(a_{\\text{cor}})$。\n    - **伪影比 ($\\eta$)：**对于每个核，计算伪影比 $\\eta(a)$，即位于中心主瓣之外的总绝对质量的分数。主瓣由整数索引 $|n| \\le \\lfloor x_{1/2} \\rfloor$ 定义。\n    - **伪影增加量 ($\\Delta\\eta$)：**计算差值 $\\eta(a_{\\text{mis}}) - \\eta(a_{\\text{cor}})$。\n    - **最负旁瓣：**找到 $a_{\\text{mis}}$ 核的最小值。\n\n此过程应用于每个测试用例，以生成所需的输出三元组 $[r, \\Delta\\eta, \\min_n a_{\\text{mis}}[n]]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef create_psf(N, sigma):\n    \"\"\"\n    Creates a normalized, circularly wrapped 1D discrete Gaussian PSF.\n    \"\"\"\n    if sigma == 0:\n        psf = np.zeros(N)\n        psf[0] = 1.0\n        return psf\n    n_indices = np.arange(N)\n    distances = np.minimum(n_indices, N - n_indices)\n    psf = np.exp(-0.5 * (distances / sigma)**2)\n    psf /= np.sum(psf)\n    return psf\n\ndef calculate_x_half(kernel):\n    \"\"\"\n    Calculates the half-width at half-maximum (x_1/2) for a centered kernel.\n    Uses linear interpolation to find the crossing point.\n    \"\"\"\n    N = len(kernel)\n    peak_value = kernel[0]\n    \n    if peak_value = 0:\n        return float('inf') # FWHM is not well-defined\n\n    half_peak = peak_value / 2.0\n\n    # Search for the first crossing of the half-peak value on the positive index side\n    for i in range(N // 2):\n        if kernel[i] >= half_peak and kernel[i+1]  half_peak:\n            y1, y2 = kernel[i], kernel[i+1]\n            x1 = i\n            # Avoid division by zero if kernel is flat\n            if (y1 - y2) == 0:\n                return float(i)\n            # Linear interpolation to find x_half\n            x_half = x1 + (y1 - half_peak) / (y1 - y2)\n            return x_half\n            \n    # If no crossing is found, kernel is wider than half the domain\n    return float(N // 2)\n\ndef calculate_eta(kernel, x_half):\n    \"\"\"\n    Calculates the artifact ratio eta for a given kernel and its x_1/2.\n    \"\"\"\n    N = len(kernel)\n    total_abs_sum = np.sum(np.abs(kernel))\n    if total_abs_sum == 0:\n        return 0.0\n\n    main_lobe_limit = int(np.floor(x_half))\n    \n    # Sum absolute values over the main lobe, defined by |n| = floor(x_1/2)\n    main_lobe_abs_sum = np.abs(kernel[0])\n    if main_lobe_limit > 0:\n        # Sum for positive indices: 1, ..., limit\n        main_lobe_abs_sum += np.sum(np.abs(kernel[1:main_lobe_limit + 1]))\n        # Sum for negative indices (periodic): N-limit, ..., N-1\n        main_lobe_abs_sum += np.sum(np.abs(kernel[N - main_lobe_limit:]))\n\n    eta = (total_abs_sum - main_lobe_abs_sum) / total_abs_sum\n    return eta\n\ndef analyze_resolution(N, sigma, sigma_tilde, alpha):\n    \"\"\"\n    Performs the full resolution analysis for a single test case.\n    \"\"\"\n    # 1. Generate true and assumed PSFs\n    P = create_psf(N, sigma)\n    P_tilde = create_psf(N, sigma_tilde)\n\n    # 2. Compute their DFTs.\n    # Since PSFs are real and symmetric, their FFTs will be real.\n    hat_p = np.fft.fft(P).real\n    hat_p_tilde = np.fft.fft(P_tilde).real\n\n    # 3. Compute frequency responses of resolution operators\n    # Correctly specified case\n    hat_A_cor = (hat_p**2) / (hat_p**2 + alpha**2)\n    # Mis-specified case\n    hat_A_mis = (hat_p_tilde * hat_p) / (hat_p_tilde**2 + alpha**2)\n\n    # 4. Compute spatial resolution kernels via inverse DFT\n    # Resulting kernels are real and symmetric (centered at index 0)\n    a_cor = np.fft.ifft(hat_A_cor).real\n    a_mis = np.fft.ifft(hat_A_mis).real\n\n    # 5. Calculate metrics for both kernels\n    # Correct case\n    x_half_cor = calculate_x_half(a_cor)\n    fwhm_cor = 2.0 * x_half_cor\n    eta_cor = calculate_eta(a_cor, x_half_cor)\n\n    # Mis-specified case\n    x_half_mis = calculate_x_half(a_mis)\n    fwhm_mis = 2.0 * x_half_mis\n    eta_mis = calculate_eta(a_mis, x_half_mis)\n    min_a_mis = np.min(a_mis)\n\n    # 6. Compute final quantities\n    if fwhm_cor == 0:  # Avoid division by zero\n        r = float('inf') if fwhm_mis > 0 else 1.0\n    else:\n        r = fwhm_mis / fwhm_cor\n\n    delta_eta = eta_mis - eta_cor\n\n    return [r, delta_eta, min_a_mis]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (512, 3.0, 3.0, 0.1),\n        (512, 3.0, 2.0, 0.1),\n        (512, 3.0, 4.5, 0.1),\n        (512, 3.0, 2.0, 0.5),\n        (512, 3.0, 2.0, 0.01),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, sigma, sigma_tilde, alpha = case\n        result = analyze_resolution(N, sigma, sigma_tilde, alpha)\n        results.append(result)\n\n    # Prepare the output string in the exact required format\n    # Example: [[r1,d1,m1],[r2,d2,m2]]\n    result_strings = []\n    for res in results:\n        # Format each triplet [r, delta_eta, min_a_mis]\n        # to ensure no spaces and standard float representation\n        triplet_str = f\"[{res[0]},{res[1]},{res[2]}]\"\n        result_strings.append(triplet_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}