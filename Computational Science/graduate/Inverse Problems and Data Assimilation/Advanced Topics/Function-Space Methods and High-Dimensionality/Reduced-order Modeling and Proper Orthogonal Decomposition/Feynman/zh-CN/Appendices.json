{
    "hands_on_practices": [
        {
            "introduction": "在应用恰当正交分解（POD）时，一个核心任务是选择最少数目的模态来捕捉数据中期望的“能量”或方差。在许多物理应用中，尤其是在使用有限元方法（FEM）时，这种能量必须使用与离散化（例如，质量矩阵）相关的加权内积来衡量。本练习  提供了一个直接的、动手计算的经验，您将使用快照相关矩阵的特征值，在一个加权范数下，确定模态选择和相应的截断误差。",
            "id": "2593061",
            "problem": "考虑一族通过有限元法（FEM）离散化的线性、矫顽、参数化偏微分方程。假设解流形在三个参数值 $\\mu_{1}$、$\\mu_{2}$ 和 $\\mu_{3}$ 处进行采样，得到三个在 $\\mathbb{R}^{3}$ 中的快照向量，这些向量作为快照矩阵 $S \\in \\mathbb{R}^{3 \\times 3}$ 的列向量。设有限元质量矩阵为对称正定矩阵 $M \\in \\mathbb{R}^{3 \\times 3}$。您将对这些快照计算关于 $M$-内积的本征正交分解（POD）。\n\n使用以下数据：\n- 质量矩阵为\n$$\nM \\;=\\; \\begin{pmatrix}\n2  0  0 \\\\\n0  1  0 \\\\\n0  0  \\tfrac{1}{2}\n\\end{pmatrix}.\n$$\n- 快照矩阵为\n$$\nS \\;=\\; \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix}.\n$$\n\n采用 $M$-内积 $\\langle u, v \\rangle_{M} \\equiv u^{\\top} M v$ 和相应的 $M$-范数 $\\|u\\|_{M} \\equiv \\sqrt{u^{\\top} M u}$。根据基本POD定义，定义快照相关矩阵\n$$\nC \\;=\\; S^{\\top} M S \\;\\in\\; \\mathbb{R}^{3 \\times 3}.\n$$\n设 $C$ 的特征值记为并按非递增顺序排列为 $\\lambda_{1} \\ge \\lambda_{2} \\ge \\lambda_{3} \\ge 0$。由前 $r$ 个模态捕获的POD能量定义为\n$$\n\\mathcal{E}(r) \\;=\\; \\frac{\\sum_{i=1}^{r} \\lambda_{i}}{\\sum_{i=1}^{3} \\lambda_{i}}.\n$$\n\n您的任务是：\n1. 给定目标能量阈值 $\\eta = 0.85$，确定满足 $\\mathcal{E}(r) \\ge \\eta$ 的最小整数 $r$。\n2. 使用快照的基本POD误差恒等式，估计当使用 $r$ 个模态时，在 $M$-范数下的总快照重构截断误差，定义为\n$$\nE_{\\text{trunc}} \\;=\\; \\sum_{i=r+1}^{3} \\lambda_{i}.\n$$\n\n将您的最终答案以一个二元行矩阵 $\\begin{pmatrix} r  E_{\\text{trunc}} \\end{pmatrix}$ 的形式报告。无需四舍五入，要求精确值。无需物理单位。",
            "solution": "问题陈述已经过评估，并被认为是有效的。它在科学上基于成熟的降阶模型理论，特别是本征正交分解（POD）。这是一个适定问题，所有必需的数据和定义都已提供，以确保解的唯一性、稳定性和有意义性。问题的结构是客观且逻辑一致的。我们开始求解。\n\n该问题要求计算与给定快照集的本征正交分解相关的两个量。第一个量是捕获指定比例总能量所需的最小模态数 $r$。第二个量是相应的截断误差。计算需要在由质量矩阵 $M$ 导出的内积下进行。\n\n如前所述，POD方法的核心是快照相关矩阵 $C$ 的特征值问题。我们首先计算该矩阵。提供的定义是\n$$\nC \\;=\\; S^{\\top} M S\n$$\n快照矩阵 $S$ 给定为 $3 \\times 3$ 单位矩阵，$S = I = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}$。单位矩阵的转置是其自身，$S^{\\top} = I^{\\top} = I$。将这些代入 $C$ 的定义中得到：\n$$\nC \\;=\\; I^{\\top} M I \\;=\\; I M I \\;=\\; M\n$$\n因此，相关矩阵 $C$ 与质量矩阵 $M$ 相同：\n$$\nC \\;=\\; M \\;=\\; \\begin{pmatrix}\n2  0  0 \\\\\n0  1  0 \\\\\n0  0  \\tfrac{1}{2}\n\\end{pmatrix}\n$$\n下一步是确定 $C$ 的特征值。由于 $C$ 是一个对角矩阵，其特征值就是其对角线上的元素。问题要求这些特征值按非递增顺序排列：$\\lambda_{1} \\ge \\lambda_{2} \\ge \\lambda_{3}$。从 $C$ 的对角线，我们确定特征值为 $2$、$1$ 和 $\\frac{1}{2}$。将它们排序得到：\n$$\n\\lambda_{1} = 2\n$$\n$$\n\\lambda_{2} = 1\n$$\n$$\n\\lambda_{3} = \\frac{1}{2}\n$$\n这些特征值表示由 $M$-内积缩放的快照矩阵的奇异值的平方，它们的和表示快照中包含的总能量或方差。总能量是相关矩阵的迹，$\\mathrm{Tr}(C)$：\n$$\n\\sum_{i=1}^{3} \\lambda_{i} = \\lambda_{1} + \\lambda_{2} + \\lambda_{3} = 2 + 1 + \\frac{1}{2} = 3.5 = \\frac{7}{2}\n$$\n现在，我们来解决第一个任务：找到最小整数 $r$，使得捕獲的能量 $\\mathcal{E}(r)$ 达到或超过阈值 $\\eta = 0.85$。捕獲的能量定义为：\n$$\n\\mathcal{E}(r) \\;=\\; \\frac{\\sum_{i=1}^{r} \\lambda_{i}}{\\sum_{i=1}^{3} \\lambda_{i}}\n$$\n我们对 $r = 1, 2, \\dots$ 计算 $\\mathcal{E}(r)$，直到满足条件 $\\mathcal{E}(r) \\ge 0.85$。阈值为 $\\eta = 0.85 = \\frac{85}{100} = \\frac{17}{20}$。\n\n对于 $r=1$：\n$$\n\\mathcal{E}(1) = \\frac{\\lambda_{1}}{\\sum_{i=1}^{3} \\lambda_{i}} = \\frac{2}{\\frac{7}{2}} = \\frac{4}{7}\n$$\n我们将其与阈值进行比较。$\\frac{4}{7} \\ge \\frac{17}{20}$ 是否成立？通过交叉相乘，我们比较 $4 \\times 20 = 80$ 和 $7 \\times 17 = 119$。因为 $80  119$，所以我们有 $\\frac{4}{7}  \\frac{17}{20}$。因此，$\\mathcal{E}(1)  0.85$。一个模态是不够的。\n\n对于 $r=2$：\n$$\n\\mathcal{E}(2) = \\frac{\\lambda_{1} + \\lambda_{2}}{\\sum_{i=1}^{3} \\lambda_{i}} = \\frac{2 + 1}{\\frac{7}{2}} = \\frac{3}{\\frac{7}{2}} = \\frac{6}{7}\n$$\n我们将其与阈值进行比较。$\\frac{6}{7} \\ge \\frac{17}{20}$ 是否成立？通过交叉相乘，我们比较 $6 \\times 20 = 120$ 和 $7 \\times 17 = 119$。因为 $120 > 119$，所以我们有 $\\frac{6}{7} > \\frac{17}{20}$。因此，$\\mathcal{E}(2) > 0.85$。两个模态是足够的。\n\n因为 $r=1$ 不够而 $r=2$ 足够，所以最小整数是 $r=2$。\n\n第二个任务是计算当使用 $r=2$ 个模态时的总快照重构截断误差 $E_{\\text{trunc}}$。提供的定义是：\n$$\nE_{\\text{trunc}} \\;=\\; \\sum_{i=r+1}^{3} \\lambda_{i}\n$$\n对于 $r=2$，这个和变为：\n$$\nE_{\\text{trunc}} \\;=\\; \\sum_{i=2+1}^{3} \\lambda_{i} \\;=\\; \\sum_{i=3}^{3} \\lambda_{i} \\;=\\; \\lambda_{3}\n$$\n代入 $\\lambda_{3}$ 的值：\n$$\nE_{\\text{trunc}} = \\frac{1}{2}\n$$\n这个值表示被截斷模态的能量含量，这恰好是未被前 $r$ 个模态捕获的总能量部分。\n\n两个要求的值是 $r=2$ 和 $E_{\\text{trunc}} = \\frac{1}{2}$。最终答案必须以一个二元行矩阵的形式报告。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 2  \\frac{1}{2} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在之前练习的基础上，我们现在来探讨选择正确内积的重要性。虽然标准的POD使用欧几里得内积，但在处理非均匀网格上的数据时，这可能会导致次优的甚至是物理上无意义的基函数。本练习  将指导您通过一个数值实验，将欧几里得内积导出的基在正确的物理范数下的投影误差，与真正最优的加权范数基的误差进行比较，从而量化前者的次优性。",
            "id": "3417044",
            "problem": "考虑一组状态快照，由一个实矩阵 $X \\in \\mathbb{R}^{n \\times m}$ 表示，该矩阵是在具有 $n$ 个空间节点的一维、可能非均匀的网格上采样的。令 $M \\in \\mathbb{R}^{n \\times n}$ 是一个对称正定对角矩阵，它通过 $\\langle a,b\\rangle_{M} = a^{\\top} M b$ 在 $\\mathbb{R}^{n}$ 上定义了 $M$-加权内积，以及诱导范数 $\\|a\\|_{M}^{2} = a^{\\top} M a$。本征正交分解（POD）旨在寻找一个 $r$ 维子空间，以在选定的内积中最小化快照的均方投影误差。在非均匀网格设置中，具有物理意义的度量通常是与离散求积权重相关的 $M$-加权内积。\n\n您将量化，对于一个固定的秩 $r$，当 $r$ 维子空间通过以下方式获得时，$M$-范数投影误差的差异：\n- 欧几里得 POD，它使用标准内积 $\\langle a,b\\rangle_{2} = a^{\\top} b$，以及\n- $M$-加权 POD，它使用 $\\langle a,b\\rangle_{M} = a^{\\top} M b$。\n\n使用以下基本定义：\n- 对于张成一个子空间的任意列标准正交基 $U \\in \\mathbb{R}^{n \\times r}$，到 $\\operatorname{span}(U)$ 上的 $M$-正交投影算子是\n$$\nP_{M}(U) = U\\left(U^{\\top} M U\\right)^{-1}U^{\\top} M.\n$$\n- $X$ 到 $\\operatorname{span}(U)$ 上的 $M$-范数投影误差是\n$$\nE(U;M,X) = \\left\\| X - P_{M}(U) X \\right\\|_{M}^{2} = \\operatorname{trace}\\!\\left(\\left(X - P_{M}(U)X\\right)^{\\top} M \\left(X - P_{M}(U)X\\right)\\right).\n$$\n- 欧几里得 POD 基 $U_{r}^{E} \\in \\mathbb{R}^{n \\times r}$ 是通过 $X$ 的前 $r$ 个左奇异向量（使用标准内积）获得的。\n- $M$-加权 POD 基 $U_{r}^{M} \\in \\mathbb{R}^{n \\times r}$ 是通过构造 $Y = M^{1/2} X$，计算 $Y$ 的前 $r$ 个左奇异向量 $Q_{r}$，并设置 $U_{r}^{M} = M^{-1/2} Q_{r}$ 来获得的，它满足 $(U_{r}^{M})^{\\top} M U_{r}^{M} = I_{r}$。\n\n您的任务是为每个测试案例计算标量差\n$$\n\\Delta(r;M,X) = E\\!\\left(U_{r}^{E}; M, X\\right) - E\\!\\left(U_{r}^{M}; M, X\\right),\n$$\n并使用这些结果来经验性地评估何时 $M$-加权是必不可少的。\n\n按如下方式确定性地构造快照。设 $n \\in \\mathbb{N}$ 是空间节点的数量， $m \\in \\mathbb{N}$ 是快照的数量。给定 $[0,1]$ 上的网格 $x = (x_{1},\\dots,x_{n})^{\\top}$，通过\n$$\nX(:,j) = \\sin\\!\\left( 2\\pi j \\, x \\right) + 0.1\\, j \\, \\cos\\!\\left( 2\\pi (j-1) \\, x \\right), \\quad \\text{for } j = 1,2,\\dots,m,\n$$\n定义 $m$ 个快照列，其中正弦和余弦函数逐项作用于向量 $x$。\n\n按如下方式定义对角质量矩阵 $M = \\operatorname{diag}(w)$。对于网格 $x_{i}$，设置梯形求积权重：\n- $w_{1} = \\tfrac{1}{2}\\left(x_{2}-x_{1}\\right)$,\n- $w_{i} = \\tfrac{1}{2}\\left(x_{i+1}-x_{i-1}\\right)$ for $i=2,\\dots,n-1$,\n- $w_{n} = \\tfrac{1}{2}\\left(x_{n}-x_{n-1}\\right)$.\n对于均匀度量情况，使用 $M=I_{n}$。\n\n实现以下测试套件。固定 $n = 80$ 和 $m = 6$。考虑四个秩为 $r$ 的指定案例：\n- 案例 $\\mathbf{A}$（理想路径，均匀度量）：均匀网格 $x_{i} = \\tfrac{i-1}{n-1}$ 且 $M = I_{n}$，其中 $r=2$。\n- 案例 $\\mathbf{B}$（轻度非均匀性）：非均匀网格 $x_{i} = \\left(\\tfrac{i-1}{n-1}\\right)^{1.5}$，使用上述梯形权重，其中 $r=2$。\n- 案例 $\\mathbf{C}$（强度非均匀性）：非均匀网格 $x_{i} = \\left(\\tfrac{i-1}{n-1}\\right)^{3.0}$，使用上述梯形权重，其中 $r=2$。\n- 案例 $\\mathbf{D}$（边界秩情况）：与案例 $\\mathbf{C}$ 相同的网格，其中 $r=m=6$。\n\n对于每个案例，将 $\\Delta(r;M,X)$ 计算为浮点数。您的程序应生成单行输出，其中包含按 $\\mathbf{A}, \\mathbf{B}, \\mathbf{C}, \\mathbf{D}$ 顺序排列的结果，形式为用方括号括起来的逗号分隔列表（例如 $[d_{A},d_{B},d_{C},d_{D}]$）。不涉及物理单位。角度以弧度为单位。所有数值输出均表示为十进制浮点数。\n\n您的解答必须从内积的定义、加权内积中的正交投影以及 POD 基的构造开始，并且必须证明为每个案例计算 $\\Delta(r;M,X)$ 所用算法的合理性。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。所有提供的定义、参数和约束在科学上是合理的、数学上是一致的，并构成一个适定问题。该问题植根于已建立的降阶建模理论，特别是加权内积空间中的本征正交分解（POD），这是数值分析和科学计算中的一个标准课题。指定的测试案例，包括边界情况，旨在有意义地测试核心概念，而不是将其简单化。因此，我们可以继续提供完整的解决方案。\n\n核心任务是量化在构造降阶基时，使用标准欧几里得内积与具有物理动机的加权内积所产生的投影误差差异。这个差异 $\\Delta(r; M, X)$ 凸显了为模型降阶选择适当度量的重要性，尤其是在处理非均匀网格上的数据时。\n\n让我们首先将所涉及的概念形式化。\n\n在具有 $n$ 个节点的空间域上定义的一组 $m$ 个系统状态快照由矩阵 $X \\in \\mathbb{R}^{n \\times m}$ 的列给出。POD 的目标是找到一个 $r$ 维线性子空间（其中 $r \\ll n$），它能为 $X$ 的列提供最佳可能近似。“最佳”的概念是通过最小化均方投影误差来定义的，该误差取决于状态空间 $\\mathbb{R}^{n}$ 上内积的选择。\n\n给定一个对称正定矩阵 $M \\in \\mathbb{R}^{n \\times n}$，$M$-加权内积为 $\\langle a,b\\rangle_{M} = a^{\\top} M b$，其诱导范数为 $\\|a\\|_{M}^{2} = a^{\\top} M a$。在此范数下，快照的总“能量”是 $X$ 的 $M$-加权弗罗贝尼乌斯范数的平方，由 $\\|X\\|_{M,F}^2 = \\operatorname{trace}(X^{\\top} M X)$ 给出。\n\n在此加权内积空间中，到基 $U \\in \\mathbb{R}^{n \\times r}$（其中 $U$ 的列线性无关）的生成空间上的正交投影算子由以下给定公式给出：\n$$\nP_{M}(U) = U\\left(U^{\\top} M U\\right)^{-1}U^{\\top} M\n$$\n快照矩阵 $X$ 到 $\\operatorname{span}(U)$ 上的投影误差是：\n$$\nE(U; M, X) = \\left\\| X - P_{M}(U) X \\right\\|_{M,F}^{2} = \\operatorname{trace}\\!\\left(\\left(X - P_{M}(U)X\\right)^{\\top} M \\left(X - P_{M}(U)X\\right)\\right)\n$$\nPOD 问题旨在寻找最小化此误差的秩为 $r$ 的基 $U$。\n\n这个最小化问题的解是通过变量替换和奇异值分解（SVD）得到的。设 $M^{1/2}$ 是 $M$ 唯一的对称正定平方根。我们定义一个变换后的状态向量 $z = M^{1/2}a$。那么，$M$-加权内积在变换后的空间中变为标准欧几里得内积：\n$$\n\\langle a,b\\rangle_{M} = a^{\\top} M b = \\left(M^{1/2}a\\right)^{\\top}\\left(M^{1/2}b\\right) = z_a^{\\top} z_b = \\langle z_a, z_b \\rangle_2\n$$\n寻找 $X$ 的最优 $M$-加权基的问题等价于为变换后的快照矩阵 $Y = M^{1/2}X$ 寻找最优欧几里得基。\n\n标准欧几里得 POD 问题的解由 Eckart-Young-Mirsky 定理给出。最小化 $\\|Y - Q_r Q_r^{\\top} Y\\|_F^2$ 的最优秩-$r$ 基由 $Y$ 的前 $r$ 个左奇异向量张成。设 $Y$ 的 SVD 为 $Y=Q \\Sigma V^{\\top}$。$Y$ 的最优基是 $Q_r$，即 $Q$ 的前 $r$ 列。\n原始问题的对应最优基 $U_{r}^{M}$ 通过逆变换得到：$U_{r}^{M} = M^{-1/2}Q_r$。根据构造，这个基是 $M$-标准正交的：$(U_{r}^{M})^{\\top}M U_{r}^{M} = (M^{-1/2}Q_r)^{\\top} M (M^{-1/2}Q_r) = Q_r^{\\top}M^{-1/2} M M^{-1/2}Q_r = Q_r^{\\top}Q_r = I_r$。\n\n最小投影误差 $E(U_r^M; M, X)$ 可以被高效地计算。它等于 $Y$ 的最小欧几里得投影误差，即 $Y$ 被忽略的奇异值的平方和。设 $\\sigma_1, \\sigma_2, \\dots, \\sigma_k$ 是 $Y=M^{1/2}X$ 的奇异值，其中 $k=\\min(n, m)$。那么：\n$$\nE(U_{r}^{M}; M, X) = \\sum_{j=r+1}^{k} \\sigma_j^2\n$$\n\n欧几里得 POD 基 $U_{r}^{E}$ 是 $M=I_n$ 的一个特殊情况。它由 $X$ 本身的前 $r$ 个左奇异向量构成。当用于在 $M$-加权内积空间中进行投影时（对于 $M \\neq I_n$），这个基通常是次优的。投影误差 $E(U_{r}^{E}; M, X)$ 必须使用通用公式计算，因为 $U_{r}^{E}$ 不一定是 $M$-标准正交的：\n$$\nE(U_{r}^{E}; M, X) = \\left\\| X - P_{M}(U_r^E) X \\right\\|_{M,F}^{2}\n$$\n其中 $P_{M}(U_r^E) = U_r^E \\left((U_r^E)^{\\top} M U_r^E\\right)^{-1}(U_r^E)^{\\top} M$。\n\n我们感兴趣的量是 $\\Delta(r; M, X) = E(U_{r}^{E}; M, X) - E(U_{r}^{M}; M, X)$。根据 $U_{r}^{M}$ 的最优性，我们必然有 $\\Delta \\ge 0$。\n\n特殊情况：\n- **案例 A**：$M=I_n$。$M$-加权内积就是欧几里得内积。因此，$M$-加权 POD 与欧几里得 POD 相同。$U_r^M = U_r^E$，因此 $E(U_r^E; I_n, X) = E(U_r^M; I_n, X)$。我们预期 $\\Delta = 0$。\n- **案例 D**：$r=m=6$。基向量的数量等于快照的数量。$X$ 的列空间 $\\operatorname{span}(X)$ 的维数最多为 $m$。$U_m^E$ 和 $U_m^M$ 都将构成 $\\operatorname{span}(X)$ 的一个基。因此，$X$ 的任何一列都在 $\\operatorname{span}(U_m^E)$ 和 $\\operatorname{span}(U_m^M)$ 中。一个向量到包含其自身的子空间上的投影是该向量本身。因此，$P_M(U_m^E)X = X$ 且 $P_M(U_m^M)X = X$。两个投影误差都为零，我们预期 $\\Delta = 0 - 0 = 0$。\n\n每个测试案例的算法步骤如下：\n1.  设置参数 $n=80$, $m=6$, 以及案例特定的秩 $r$。\n2.  根据案例定义生成空间网格向量 $x \\in \\mathbb{R}^n$。\n3.  构造对角质量矩阵 $M \\in \\mathbb{R}^{n \\times n}$。对于案例 B、C、D，这涉及计算梯形求积权重。对于案例 A，$M=I_n$。\n4.  使用指定公式构造快照矩阵 $X \\in \\mathbb{R}^{n \\times m}$。\n5.  计算欧几里得 POD 基 $U_r^E$：\n    a. 对 $X$ 执行 SVD：$X = U S V^\\top$。\n    b. 提取 $U$ 的前 $r$ 列以构成 $U_r^E$。\n6.  计算误差 $E(U_{r}^{E}; M, X)$：\n    a. 计算 $X$ 的投影：$X_{proj} = U_r^E \\left((U_r^E)^{\\top} M U_r^E\\right)^{-1}(U_r^E)^{\\top} M X$。\n    b. 计算误差矩阵：$E_{mat} = X - X_{proj}$。\n    c. 计算误差：$E(U_{r}^{E}; M, X) = \\operatorname{trace}(E_{mat}^{\\top} M E_{mat})$。\n7.  计算最优误差 $E(U_{r}^{M}; M, X)$：\n    a. 由于 $M$ 是对角矩阵，计算 $M^{1/2} = \\operatorname{diag}(\\sqrt{w_i})$。\n    b. 构造加权矩阵 $Y = M^{1/2} X$。\n    c. 对 $Y$ 执行 SVD 以获得其奇异值 $\\{\\sigma_j\\}$。\n    d. 计算误差：$E(U_{r}^{M}; M, X) = \\sum_{j=r+1}^{m} \\sigma_j^2$。\n8.  计算差异 $\\Delta(r; M, X) = E(U_{r}^{E}; M, X) - E(U_{r}^{M}; M, X)$。\n\n对四个指定案例中的每一个实施此程序，以获得最终结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import svd, inv\n\ndef solve():\n    \"\"\"\n    Computes the difference in M-norm projection errors between Euclidean POD\n    and M-weighted POD for four specified test cases.\n    \"\"\"\n    \n    n = 80\n    m = 6\n\n    def construct_snapshots(x_nodes: np.ndarray) - np.ndarray:\n        \"\"\"Constructs the snapshot matrix X based on the spatial mesh.\"\"\"\n        X = np.zeros((n, m))\n        j_vals = np.arange(1, m + 1)\n        for j_idx, j in enumerate(j_vals):\n            X[:, j_idx] = np.sin(2 * np.pi * j * x_nodes) + \\\n                          0.1 * j * np.cos(2 * np.pi * (j - 1) * x_nodes)\n        return X\n\n    def construct_mass_matrix(x_nodes: np.ndarray) - np.ndarray:\n        \"\"\"Constructs the trapezoidal quadrature weight matrix M.\"\"\"\n        if np.array_equal(x_nodes, np.linspace(0, 1, n)): # Heuristic for uniform case\n             # Check if it could be the uniform case. We know from the problem\n             # statement that only Case A has M=I. This logic is safe.\n             is_uniform_case = True\n             for i, val in enumerate(x_nodes):\n                 if not np.isclose(val, (i)/(n-1)):\n                     is_uniform_case = False\n                     break\n             if is_uniform_case:\n                return np.identity(n)\n\n        w = np.zeros(n)\n        w[0] = 0.5 * (x_nodes[1] - x_nodes[0])\n        w[n - 1] = 0.5 * (x_nodes[n - 1] - x_nodes[n - 2])\n        for i in range(1, n - 1):\n            w[i] = 0.5 * (x_nodes[i + 1] - x_nodes[i - 1])\n        return np.diag(w)\n\n    def compute_delta(r: int, x_nodes: np.ndarray, use_identity_m: bool) - float:\n        \"\"\"\n        Computes Delta(r; M, X) for a given configuration.\n        \"\"\"\n        X = construct_snapshots(x_nodes)\n        \n        if use_identity_m:\n            M = np.identity(n)\n        else:\n            M = construct_mass_matrix(x_nodes)\n\n        # 1. Compute M-weighted POD error (optimal error)\n        M_sqrt = np.sqrt(M) # Works for diagonal M\n        Y = M_sqrt @ X\n        _, s_y, _ = svd(Y, full_matrices=False)\n        \n        # Error is the sum of squares of neglected singular values\n        error_M_pod = np.sum(s_y[r:]**2)\n\n        # 2. Compute Euclidean POD error (suboptimal error in M-norm)\n        U, _, _ = svd(X, full_matrices=False)\n        UrE = U[:, :r]\n\n        # Projector: P_M(U) = U * (U^T * M * U)^-1 * U^T * M\n        U_T_M_U = UrE.T @ M @ UrE\n        inv_U_T_M_U = inv(U_T_M_U)\n        P_M_UrE = UrE @ inv_U_T_M_U @ UrE.T @ M\n        \n        # Error: ||X - P_M(U)X||_M^2 = trace((X-PX)^T * M * (X-PX))\n        error_matrix = X - P_M_UrE @ X\n        error_E_pod = np.trace(error_matrix.T @ M @ error_matrix)\n\n        # 3. Compute the difference\n        delta = error_E_pod - error_M_pod\n        return delta\n\n    # Define test cases\n    p = np.linspace(0, 1, n)\n    test_cases_params = [\n        # Case A: Uniform mesh, M=I, r=2\n        {'r': 2, 'x_nodes': p, 'use_identity_m': True},\n        # Case B: Mild nonuniformity, Trapezoidal M, r=2\n        {'r': 2, 'x_nodes': p**1.5, 'use_identity_m': False},\n        # Case C: Strong nonuniformity, Trapezoidal M, r=2\n        {'r': 2, 'x_nodes': p**3.0, 'use_identity_m': False},\n        # Case D: Boundary rank, same mesh as C, r=6\n        {'r': 6, 'x_nodes': p**3.0, 'use_identity_m': False},\n    ]\n\n    results = []\n    for params in test_cases_params:\n        result = compute_delta(params['r'], params['x_nodes'], params['use_identity_m'])\n        # Handle potential small negative numbers from floating point arithmetic for expected zero results\n        if np.isclose(result, 0):\n            result = 0.0\n        results.append(result)\n\n    # Format the final output string\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "本练习是前面实践的顶点，它将POD应用于为参数依赖的偏微分方程构建一个功能性的降阶模型（ROM）。我们的目标不仅是构建ROM，更重要的是测试当系统参数变化时模型的预测能力——这在不确定性量化或设计优化中是常见情景。这个综合性练习  涵盖了从离散化、快照生成到基函数构建和误差分析的整个工作流程，让您能实际体验基于投影的ROM的优势与局限。",
            "id": "3265932",
            "problem": "考虑空间区间 $x \\in (0,1)$ 上具有齐次狄利克雷边界条件的一维线性平流扩散初边值问题，该问题由以下偏微分方程控制\n$$\n\\frac{\\partial u}{\\partial t}(x,t;\\mu) \\;=\\; \\mu \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t;\\mu) \\;-\\; a \\,\\frac{\\partial u}{\\partial x}(x,t;\\mu), \\quad u(0,t;\\mu) = 0,\\quad u(1,t;\\mu) = 0,\\quad u(x,0;\\mu) = u_0(x),\n$$\n其中 $\\mu  0$ 是扩散参数，$a \\ge 0$ 是平流速度。降阶模型 (Reduced-Order Model, ROM) 将通过伽辽金投影 (Galerkin projection) 构建。该投影作用于一个基底，此基底通过对在训练参数 $\\mu_{\\text{train}}$ 下生成的快照进行本征正交分解 (Proper Orthogonal Decomposition, POD) 获得。然后，该模型将应用于同一偏微分方程的测试参数 $\\mu_{\\text{test}}$。\n\n从基本定义开始：\n- 使用线方法 (method-of-lines) 在 $N$ 个内部网格点上对空间导数进行半离散化，网格间距均匀为 $h$，其中 $h = \\frac{1}{N+1}$，内部节点为 $x_i = i h$，其中 $i = 1,2,\\dots,N$。使用标准的二阶中心有限差分近似 $\\frac{\\partial^2 u}{\\partial x^2}$，并使用与 $a \\ge 0$ 一致的一阶迎风有限差分近似 $\\frac{\\partial u}{\\partial x}$。这将得到一个半离散的常微分方程\n$$\n\\frac{d \\mathbf{u}}{dt}(t;\\mu) \\;=\\; A(\\mu)\\,\\mathbf{u}(t;\\mu),\n$$\n其中 $\\mathbf{u}(t;\\mu) \\in \\mathbb{R}^N$，$A(\\mu) \\in \\mathbb{R}^{N \\times N}$ 是由离散化构成的依赖于参数的空间算子。\n- 使用隐式欧拉法 (implicit Euler method) 对半离散系统进行时间推进。设时间步长为 $\\Delta t$，$t_k = k\\,\\Delta t$，则更新满足\n$$\n\\left(I - \\Delta t\\,A(\\mu)\\right)\\,\\mathbf{u}^{k+1} \\;=\\; \\mathbf{u}^{k},\n$$\n其中 $\\mathbf{u}^k \\approx \\mathbf{u}(t_k;\\mu)$。\n- 在训练参数 $\\mu_{\\text{train}}$ 下，通过串联 $k = 0,1,\\dots,K$（最终时间 $T = K\\,\\Delta t$）的状态向量 $\\mathbf{u}^k$，生成一个快照矩阵 $X \\in \\mathbb{R}^{N \\times (K+1)}$。使用奇异值分解 (Singular Value Decomposition, SVD) $X = U\\,\\Sigma\\,V^\\top$ 计算秩为 $r$ 的本征正交分解 (POD) 基底，并取 $U$ 的前 $r$ 列作为标准正交基 $V \\in \\mathbb{R}^{N \\times r}$。这里的本征正交分解 (POD) 定义为通过奇异值分解 (SVD) 从快照集合中计算一个标准正交基，该基底能最大化捕获的能量（在欧几里得内积下）。\n- 对于测试参数 $\\mu_{\\text{test}}$，通过将全算子投影到 POD 基底上，形成伽辽金投影的降阶模型 (ROM)，得到\n$$\nA_r(\\mu_{\\text{test}}) \\;=\\; V^\\top A(\\mu_{\\text{test}}) V \\in \\mathbb{R}^{r \\times r},\n$$\n并用隐式欧拉法演化该降阶系统：\n$$\n\\left(I_r - \\Delta t\\,A_r(\\mu_{\\text{test}})\\right)\\,\\mathbf{y}^{k+1} \\;=\\; \\mathbf{y}^{k}, \\quad \\text{其中} \\quad \\mathbf{y}^0 \\;=\\; V^\\top \\mathbf{u}^0, \\quad \\mathbf{u}_{\\text{ROM}}^{k} \\;=\\; V\\,\\mathbf{y}^{k}。\n$$\n\n您的程序必须使用以下科学上一致且自洽的测试套件和参数来实现上述过程：\n- 空间离散化：\n  - $N = 64$ 个内部点。\n  - 域长度 $L = 1$，网格间距 $h = \\frac{L}{N+1}$，内部节点 $x_i = i\\,h$ 其中 $i=1,\\dots,N$。\n  - 齐次狄利克雷边界通过内部未知数的模板构建来施加。\n- 时间离散化：\n  - 隐式欧拉法，$\\Delta t = 10^{-3}$。\n  - 最终时间 $T = 0.2$，因此时间步数为 $K = \\frac{T}{\\Delta t} = 200$。\n- 偏微分方程参数：\n  - 平流速度 $a = 1.0$。\n  - 训练扩散参数 $\\mu_{\\text{train}} = 0.01$。\n- 初始条件：\n  - $u_0(x) = \\sin(\\pi x) + \\tfrac{1}{2}\\,\\sin(2\\pi x)$，在内部节点上离散化以形成 $\\mathbf{u}^0 \\in \\mathbb{R}^N$。\n- POD 基底：\n  - 如上所述，使用快照矩阵的奇异值分解 (SVD) 从 $\\mu_{\\text{train}}$ 处的快照构建秩 $r=6$ 的基底。\n\n在以下四个测试参数下评估 ROM，以分析从不同参数区域生成基底的影响：\n- 情况 1：$\\mu_{\\text{test}} = \\mu_{\\text{train}}$。\n- 情况 2：$\\mu_{\\text{test}} = 1.2\\,\\mu_{\\text{train}}$。\n- 情况 3：$\\mu_{\\text{test}} = 5\\,\\mu_{\\text{train}}$。\n- 情况 4：$\\mu_{\\text{test}} = 10^{-4}$。\n\n对于每种情况，计算全阶模型 (full-order model, FOM) 和 ROM 解在最终时刻的相对误差，\n$$\ne_{\\text{final}} \\;=\\; \\frac{\\left\\|\\mathbf{u}^{K} - \\mathbf{u}_{\\text{ROM}}^{K}\\right\\|_2}{\\left\\|\\mathbf{u}^{K}\\right\\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 是欧几里得范数。\n\n您的程序应生成单行输出，其中包含按四种情况 $[\\text{情况 1}, \\text{情况 2}, \\text{情况 3}, \\text{情况 4}]$ 顺序排列的结果，形式为方括号括起来的逗号分隔列表，每个值都以小数点后八位的小数形式打印（例如，$[0.00123456,0.00234567,0.01234567,0.12345678]$）。不涉及物理单位，所有角度（如果有）均默认为弧度，尽管此处未使用。答案是十进制形式的纯实数。",
            "solution": "用户提供的问题是偏微分方程数值方法中一个定义明确且科学上合理的问题，特别关注使用本征正交分解 (POD) 的降阶建模。该问题的有效性验证如下：\n\n- **科学基础**：该问题基于一维线性平流扩散方程，这是流体动力学和输运现象中的一个经典模型。所指定的数值方法——线方法、有限差分（扩散项用中心差分，平流项用迎风差分）、隐式欧拉时间积分以及通过奇异值分解 (SVD) 的本征正交分解 (POD)——都是科学计算中标准且经过严格验证的技术。该问题没有任何科学或事实上的不妥之处。\n- **适定性与完整性**：问题陈述提供了构建和解决问题所需的所有必要信息。这包括偏微分方程、域、边界和初始条件、所有数值参数（$N, L, a, \\Delta t, T, r$）、离散化模板的精确定义、时间积分方案、POD 基底生成过程以及具体的测试案例。隐式欧拉法确保了数值稳定性。迎风格式适用于平流项。整个问题是适定的且自洽的。\n- **客观性与清晰度**：问题以精确、无歧义的数学语言陈述。没有主观或基于观点的内容。存在一个微小的符号歧义，即 POD 基底被称为 $V$，但却是根据 SVD 分解 $X=U\\Sigma V^\\top$ 中的 $U$ 的列来定义的。然而，通过明确的指令“取 $U$ 的前 $r$ 列作为标准正交基”对此进行了澄清，这与状态轨迹 POD 的标准惯例一致。这并不妨碍唯一且正确的实现。\n\n鉴于该问题是有效的，我们制定了分步解决方案。\n\n### 1. 全阶模型 (FOM) 离散化\n\n偏微分方程为：\n$$\n\\frac{\\partial u}{\\partial t} \\;=\\; \\mu \\,\\frac{\\partial^2 u}{\\partial x^2} \\;-\\; a \\,\\frac{\\partial u}{\\partial x}\n$$\n我们将空间域 $x \\in (0,1)$ 离散化为 $N=64$ 个内部点 $x_i = i h$，$i=1,\\dots,N$，网格间距为 $h = 1/(N+1)$。系统的状态由向量 $\\mathbf{u}(t) \\in \\mathbb{R}^N$ 表示，其中 $(\\mathbf{u})_i = u(x_i, t)$。\n\n空间导数按规定使用有限差分进行近似：\n- **扩散项（二阶中心差分）**：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_i} \\approx \\frac{u(x_{i+1},t) - 2u(x_i,t) + u(x_{i-1},t)}{h^2} = \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n$$\n- **平流项（$a \\ge 0$ 的一阶迎风差分）**：\n$$\n\\frac{\\partial u}{\\partial x}\\bigg|_{x_i} \\approx \\frac{u(x_i,t) - u(x_{i-1},t)}{h} = \\frac{u_i - u_{i-1}}{h}\n$$\n\n将这些近似代入每个内部节点 $x_i$ 的偏微分方程，得到一个常微分方程组 (ODEs)，$\\frac{d\\mathbf{u}}{dt} = A(\\mu)\\mathbf{u}$。第 $i$ 个方程是：\n$$\n\\frac{du_i}{dt} = \\mu \\left( \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} \\right) - a \\left( \\frac{u_i - u_{i-1}}{h} \\right)\n$$\n齐次狄利克雷边界条件 $u(0,t)=u_0=0$ 和 $u(1,t)=u_{N+1}=0$ 被整合到边界（$i=1$ 和 $i=N$）的模板中。重新排列 $u_{i-1}$、$u_i$ 和 $u_{i+1}$ 的项，揭示了系统矩阵 $A(\\mu)$ 的结构：\n$$\n\\frac{du_i}{dt} = \\left(\\frac{\\mu}{h^2} + \\frac{a}{h}\\right) u_{i-1} + \\left(-\\frac{2\\mu}{h^2} - \\frac{a}{h}\\right) u_i + \\left(\\frac{\\mu}{h^2}\\right) u_{i+1}\n$$\n这定义了一个三对角矩阵 $A(\\mu) \\in \\mathbb{R}^{N \\times N}$，其对角线如下：\n- **主对角线**：$-\\frac{2\\mu}{h^2} - \\frac{a}{h}$\n- **次对角线（下）**：$\\frac{\\mu}{h^2} + \\frac{a}{h}$\n- **超对角线（上）**：$\\frac{\\mu}{h^2}$\n\n### 2. 时间积分与快照生成\n\n半离散系统使用隐式欧拉法进行时间推进，时间步长为 $\\Delta t = 10^{-3}$：\n$$\n\\frac{\\mathbf{u}^{k+1} - \\mathbf{u}^{k}}{\\Delta t} = A(\\mu) \\mathbf{u}^{k+1} \\implies \\left(I - \\Delta t\\,A(\\mu)\\right)\\,\\mathbf{u}^{k+1} = \\mathbf{u}^{k}\n$$\n为了获得第 $k+1$ 步的解，我们在每个时间步求解一个线性系统。\n\n通过求解训练参数 $\\mu_{\\text{train}} = 0.01$ 下的 FOM 来生成快照。初始条件是 $\\mathbf{u}^0$，通过在网格点 $x_i$ 上计算 $u_0(x) = \\sin(\\pi x) + \\frac{1}{2}\\sin(2\\pi x)$ 得到。模拟运行到时间 $T=0.2$，对应 $K = T/\\Delta t = 200$ 个时间步。通过收集状态向量形成快照矩阵 $X \\in \\mathbb{R}^{N \\times (K+1)}$：\n$$\nX = \\begin{bmatrix} |  |   | \\\\ \\mathbf{u}^0  \\mathbf{u}^1  \\dots  \\mathbf{u}^K \\\\ |  |   | \\end{bmatrix}\n$$\n\n### 3. POD 基底构建\n\nPOD 基底由快照矩阵 $X$ 的奇异值分解 (SVD) 计算得出：\n$$\nX = U \\Sigma V^\\top\n$$\n矩阵 $U \\in \\mathbb{R}^{N \\times (K+1)}$ 的列是左奇异向量，它们是标准正交的，并表示系统动力学的空间模态。在捕获最多能量的意义上，最优的秩-$r$ 基底由 $U$ 的前 $r$ 列构成。我们使用 $r=6$ 构建基矩阵 $V_{\\text{basis}} \\in \\mathbb{R}^{N \\times r}$：\n$$\nV_{\\text{basis}} = U[:, 0:r]\n$$\n\n### 4. 降阶模型 (ROM) 的构建与仿真\n\nROM 是通过将控制 FOM 方程投影到由 $V_{\\text{basis}}$ 张成的低维子空间上构建的。寻求形式为 $\\mathbf{u}_{\\text{ROM}}(t) = V_{\\text{basis}}\\mathbf{y}(t)$ 的近似解，其中 $\\mathbf{y}(t) \\in \\mathbb{R}^r$ 是降阶坐标。\n将其代入半离散系统并应用伽辽金投影（左乘 $V_{\\text{basis}}^\\top$），得到给定测试参数 $\\mu_{\\text{test}}$ 的 ROM：\n$$\nV_{\\text{basis}}^\\top V_{\\text{basis}} \\frac{d\\mathbf{y}}{dt} = V_{\\text{basis}}^\\top A(\\mu_{\\text{test}}) V_{\\text{basis}} \\mathbf{y}\n$$\n由于 $V_{\\text{basis}}$ 是标准正交的（$V_{\\text{basis}}^\\top V_{\\text{basis}} = I_r$），这可简化为：\n$$\n\\frac{d\\mathbf{y}}{dt} = A_r(\\mu_{\\text{test}}) \\mathbf{y}, \\quad \\text{其中} \\quad A_r(\\mu_{\\text{test}}) = V_{\\text{basis}}^\\top A(\\mu_{\\text{test}}) V_{\\text{basis}}\n$$\n降阶算子 $A_r \\in \\mathbb{R}^{r \\times r}$。ROM 的初始条件是全阶初始条件的投影：$\\mathbf{y}^0 = V_{\\text{basis}}^\\top \\mathbf{u}^0$。\nROM 与 FOM 类似，也使用隐式欧拉法进行时间步进：\n$$\n\\left(I_r - \\Delta t\\,A_r(\\mu_{\\text{test}})\\right)\\,\\mathbf{y}^{k+1} = \\mathbf{y}^{k}\n$$\n模拟到最终时间 $T$ 找到 $\\mathbf{y}^K$ 后，将解重构回全状态空间：$\\mathbf{u}_{\\text{ROM}}^K = V_{\\text{basis}}\\mathbf{y}^K$。\n\n### 5. 误差评估\n\n对于每个测试案例 $\\mu_{\\text{test}}$，我们在最终时间 $T=0.2$ 计算 FOM 解 $\\mathbf{u}^K$ 和 ROM 解 $\\mathbf{u}_{\\text{ROM}}^K$。相对误差计算如下：\n$$\ne_{\\text{final}} = \\frac{\\|\\mathbf{u}^K - \\mathbf{u}_{\\text{ROM}}^K\\|_2}{\\|\\mathbf{u}^K\\|_2}\n$$\n对所有四个指定的 $\\mu_{\\text{test}}$ 值重复此过程，并报告所得误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a POD-Galerkin Reduced-Order Model for a 1D advection-diffusion\n    equation and evaluates its accuracy for several test parameters.\n    \"\"\"\n    # --------------------------------------------------------------------------\n    # 1. Define problem parameters and grid\n    # --------------------------------------------------------------------------\n    N = 64                  # Number of interior spatial points\n    L = 1.0                 # Domain length\n    a = 1.0                 # Advection speed\n    dt = 1.0e-3             # Time step\n    T = 0.2                 # Final time\n    r = 6                   # Rank of POD basis\n    mu_train = 0.01         # Training diffusion parameter\n\n    test_cases_mu = [\n        mu_train,\n        1.2 * mu_train,\n        5.0 * mu_train,\n        1.0e-4\n    ]\n\n    h = L / (N + 1)         # Grid spacing\n    K = int(T / dt)         # Number of time steps\n    x_grid = np.arange(1, N + 1) * h\n\n    # Initial condition\n    u0 = np.sin(np.pi * x_grid) + 0.5 * np.sin(2 * np.pi * x_grid)\n\n    # Memoization caches for efficiency\n    memo_A = {}\n    memo_fom_final_state = {}\n\n    # --------------------------------------------------------------------------\n    # 2. Helper functions for FOM and ROM\n    # --------------------------------------------------------------------------\n    def build_A(mu):\n        \"\"\"Constructs the FOM spatial discretization matrix A(mu).\"\"\"\n        if mu in memo_A:\n            return memo_A[mu]\n\n        h2 = h * h\n        diag_main = -2.0 * mu / h2 - a / h\n        diag_upper = mu / h2\n        diag_lower = mu / h2 + a / h\n        \n        A = np.zeros((N, N))\n        np.fill_diagonal(A, diag_main)\n        np.fill_diagonal(A[1:, :-1], diag_lower)\n        np.fill_diagonal(A[:-1, 1:], diag_upper)\n        \n        memo_A[mu] = A\n        return A\n\n    def run_fom(mu, collect_snapshots=False):\n        \"\"\"Simulates the Full-Order Model (FOM).\"\"\"\n        if not collect_snapshots and mu in memo_fom_final_state:\n            return memo_fom_final_state[mu], None\n\n        A = build_A(mu)\n        # Implicit Euler matrix: M * u^{k+1} = u^k\n        M = np.eye(N) - dt * A\n        u = u0.copy()\n\n        if collect_snapshots:\n            snapshots = np.zeros((N, K + 1))\n            snapshots[:, 0] = u\n            for k in range(K):\n                u = np.linalg.solve(M, u)\n                snapshots[:, k + 1] = u\n            return u, snapshots\n        else:\n            for k in range(K):\n                u = np.linalg.solve(M, u)\n            memo_fom_final_state[mu] = u\n            return u, None\n    \n    # --------------------------------------------------------------------------\n    # 3. Generate POD basis from training data\n    # --------------------------------------------------------------------------\n    _, X_train = run_fom(mu_train, collect_snapshots=True)\n    \n    # Compute SVD: X = U * S * Vh. The POD basis are the left singular vectors (columns of U).\n    # The problem description calls the basis 'V', but it's constructed from 'U'.\n    U, _, _ = np.linalg.svd(X_train, full_matrices=False)\n    V_basis = U[:, :r]\n\n    # --------------------------------------------------------------------------\n    # 4. Evaluate ROM for each test case\n    # --------------------------------------------------------------------------\n    results = []\n    \n    # Project initial condition onto the POD basis\n    y0 = V_basis.T @ u0\n    \n    for mu_test in test_cases_mu:\n        # Get the true FOM solution at the final time for comparison\n        u_fom_final, _ = run_fom(mu_test, collect_snapshots=False)\n\n        # Build and run the ROM\n        A_test = build_A(mu_test)\n        \n        # Project the FOM operator to get the ROM operator\n        A_r = V_basis.T @ A_test @ V_basis\n        \n        # Implicit Euler matrix for the ROM\n        M_r = np.eye(r) - dt * A_r\n        \n        y = y0.copy()\n        for _ in range(K):\n            y = np.linalg.solve(M_r, y)\n        \n        # Reconstruct the full-order solution from the ROM state\n        u_rom_final = V_basis @ y\n        \n        # Calculate final-time relative error\n        error_norm = np.linalg.norm(u_fom_final - u_rom_final)\n        fom_norm = np.linalg.norm(u_fom_final)\n        \n        if fom_norm == 0:\n            # Avoid division by zero, though unlikely for this problem\n            relative_error = error_norm\n        else:\n            relative_error = error_norm / fom_norm\n            \n        results.append(relative_error)\n        \n    # --------------------------------------------------------------------------\n    # 5. Format and print the final output\n    # --------------------------------------------------------------------------\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}