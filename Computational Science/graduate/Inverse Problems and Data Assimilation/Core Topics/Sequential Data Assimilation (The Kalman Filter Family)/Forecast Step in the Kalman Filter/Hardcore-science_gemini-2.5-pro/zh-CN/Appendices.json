{
    "hands_on_practices": [
        {
            "introduction": "卡尔曼滤波的第一步是预测。这个练习将带你从基本原理出发，推导并计算预测状态均值。通过这个过程，你将清晰地理解系统动力学模型和外部控制输入如何共同决定我们对系统未来状态的最佳估计。",
            "id": "3381797",
            "problem": "考虑一个用于部分观测过程数据同化的卡尔曼滤波器中的一维、离散时间、线性动力学系统。时刻 $k$ 的状态演化遵循\n$$\nx_{k} = A x_{k-1} + B u_{k-1} + w_{k-1},\n$$\n其中 $A$ 和 $B$ 是已知常数，$u_{k-1}$ 是时刻 $k-1$ 的已知确定性控制输入，$w_{k-1}$ 是过程噪声。假设 $w_{k-1}$ 是一个零均值高斯随机变量，$w_{k-1} \\sim \\mathcal{N}(0,Q_{k-1})$，与 $x_{k-1}$ 和 $u_{k-1}$ 均独立，且与截至时刻 $k-1$ 的观测历史独立。令 $\\mathcal{I}_{k-1}$ 表示由截至时刻 $k-1$ 的所有观测生成的 $\\sigma$-代数，并令时刻 $k-1$ 的后验（分析）均值由 $x_{k-1\\mid k-1} = \\mathbb{E}[x_{k-1} \\mid \\mathcal{I}_{k-1}]$ 给出。时刻 $k$ 的预报（预测）均值定义为 $x_{k\\mid k-1} = \\mathbb{E}[x_{k} \\mid \\mathcal{I}_{k-1}]$。\n\n仅使用条件期望、期望的线性性和独立性的定义与性质，从第一性原理推导 $x_{k\\mid k-1}$ 的表达式。然后，对于特定值 $A = \\frac{3}{2}$、$B = -\\frac{2}{3}$、$u_{k-1} = \\frac{9}{4}$ 和 $x_{k-1\\mid k-1} = -\\frac{5}{6}$，计算 $x_{k\\mid k-1}$ 的值。最后，解释 $A x_{k-1}$、$B u_{k-1}$ 和 $w_{k-1}$ 各项对预测均值的贡献。$x_{k\\mid k-1}$ 的最终数值必须作为一个精确的单一数字报告；无需四舍五入。",
            "solution": "该问题是适定的，有科学依据，并提供了在卡尔曼滤波器背景下推导和计算预报均值所需的所有必要信息。\n\n第一步是推导时刻 $k$ 的预报（预测）均值表达式，记作 $x_{k\\mid k-1}$。根据定义，这是状态 $x_k$ 在给定截至时刻 $k-1$ 的所有可用信息（这些信息包含在 $\\sigma$-代数 $\\mathcal{I}_{k-1}$ 中）下的条件期望。\n$$\nx_{k\\mid k-1} = \\mathbb{E}[x_k \\mid \\mathcal{I}_{k-1}]\n$$\n状态演化由线性动力学模型给出：\n$$\nx_k = A x_{k-1} + B u_{k-1} + w_{k-1}\n$$\n将 $x_k$ 的这个表达式代入预报均值的定义，我们得到：\n$$\nx_{k\\mid k-1} = \\mathbb{E}[A x_{k-1} + B u_{k-1} + w_{k-1} \\mid \\mathcal{I}_{k-1}]\n$$\n根据期望算子的线性性，我们可以将其分解为三个条件期望之和：\n$$\nx_{k\\mid k-1} = \\mathbb{E}[A x_{k-1} \\mid \\mathcal{I}_{k-1}] + \\mathbb{E}[B u_{k-1} \\mid \\mathcal{I}_{k-1}] + \\mathbb{E}[w_{k-1} \\mid \\mathcal{I}_{k-1}]\n$$\n现在我们根据问题陈述中给出的性质逐一分析每一项。\n\n对于第一项 $\\mathbb{E}[A x_{k-1} \\mid \\mathcal{I}_{k-1}]$，量 $A$ 是一个已知常数。常数可以从期望中提出来。随机变量是 $x_{k-1}$。\n$$\n\\mathbb{E}[A x_{k-1} \\mid \\mathcal{I}_{k-1}] = A \\cdot \\mathbb{E}[x_{k-1} \\mid \\mathcal{I}_{k-1}]\n$$\n问题将时刻 $k-1$ 的后验（分析）均值定义为 $x_{k-1\\mid k-1} = \\mathbb{E}[x_{k-1} \\mid \\mathcal{I}_{k-1}]$。因此，第一项简化为 $A x_{k-1\\mid k-1}$。\n\n对于第二项 $\\mathbb{E}[B u_{k-1} \\mid \\mathcal{I}_{k-1}]$，量 $B$ 是一个已知常数，可以被提出来。输入 $u_{k-1}$ 是时刻 $k-1$ 的一个已知的、确定性的控制输入。这意味着在给定截至时刻 $k-1$ 的信息下，其值是已知的，因此它是 $\\mathcal{I}_{k-1}$-可测的。一个 $\\mathcal{I}_{k-1}$-可测的量的条件期望就是该量本身。\n$$\n\\mathbb{E}[B u_{k-1} \\mid \\mathcal{I}_{k-1}] = B \\cdot \\mathbb{E}[u_{k-1} \\mid \\mathcal{I}_{k-1}] = B u_{k-1}\n$$\n\n对于第三项 $\\mathbb{E}[w_{k-1} \\mid \\mathcal{I}_{k-1}]$，过程噪声 $w_{k-1}$ 被陈述为与截至时刻 $k-1$ 的观测历史独立。这意味着 $w_{k-1}$ 与 $\\sigma$-代数 $\\mathcal{I}_{k-1}$ 独立。对于一个独立的随机变量，其条件期望等于其无条件期望。\n$$\n\\mathbb{E}[w_{k-1} \\mid \\mathcal{I}_{k-1}] = \\mathbb{E}[w_{k-1}]\n$$\n问题指明 $w_{k-1}$ 是一个零均值高斯随机变量，所以 $\\mathbb{E}[w_{k-1}] = 0$。\n\n综合这些结果，预报均值的表达式为：\n$$\nx_{k\\mid k-1} = A x_{k-1\\mid k-1} + B u_{k-1} + 0 = A x_{k-1\\mid k-1} + B u_{k-1}\n$$\n这是从第一性原理推导出的线性离散时间系统中预报均值的一般表达式。\n\n接下来，我们使用给定的数值计算这个表达式的值：$A = \\frac{3}{2}$、$B = -\\frac{2}{3}$、$u_{k-1} = \\frac{9}{4}$ 和 $x_{k-1\\mid k-1} = -\\frac{5}{6}$。\n$$\nx_{k\\mid k-1} = \\left(\\frac{3}{2}\\right) \\left(-\\frac{5}{6}\\right) + \\left(-\\frac{2}{3}\\right) \\left(\\frac{9}{4}\\right)\n$$\n计算第一个乘积：\n$$\n\\left(\\frac{3}{2}\\right) \\left(-\\frac{5}{6}\\right) = -\\frac{3 \\times 5}{2 \\times 6} = -\\frac{15}{12} = -\\frac{5}{4}\n$$\n计算第二个乘积：\n$$\n\\left(-\\frac{2}{3}\\right) \\left(\\frac{9}{4}\\right) = -\\frac{2 \\times 9}{3 \\times 4} = -\\frac{18}{12} = -\\frac{3}{2}\n$$\n将两个结果相加：\n$$\nx_{k\\mid k-1} = -\\frac{5}{4} - \\frac{3}{2} = -\\frac{5}{4} - \\frac{6}{4} = -\\frac{11}{4}\n$$\n最后，我们解释原始状态方程 $x_{k} = A x_{k-1} + B u_{k-1} + w_{k-1}$ 中各项对预测均值 $x_{k\\mid k-1}$ 的贡献。\n\\begin{itemize}\n    \\item 项 $A x_{k-1}$ 对预测均值的贡献是 $A x_{k-1\\mid k-1}$。这代表了将时刻 $k-1$ 的状态最佳估计（即分析均值 $x_{k-1\\mid k-1}$）通过由矩阵 $A$ 代表的系统内部动力学向前传播到未来。这是我们对状态自然演化的最佳预测。\n    \\item 项 $B u_{k-1}$ 对预测均值的贡献是 $B u_{k-1}$。这代表了已知的外部控制输入 $u_{k-1}$ 对时刻 $k$ 的状态的影响。由于此输入是确定性的且已知的，其对均值的贡献不是一个估计值，而是一个已知量。\n    \\item 项 $w_{k-1}$ 代表过程噪声。它对预测均值的贡献是 $\\mathbb{E}[w_{k-1} \\mid \\mathcal{I}_{k-1}] = 0$。这是因为噪声是一个期望值为零的随机扰动，并且假设它无法根据过去的信息进行预测。虽然噪声向系统注入了不确定性（这在预报误差协方差矩阵中有所考虑），但它对状态本身的期望贡献为零。对于一个零均值的随机扰动，我们的最佳猜测就是其均值。\n\\end{itemize}\n总而言之，预报均值（或预测）是通过将当前状态的最佳估计根据系统的已知动力学进行演化，并加上控制输入的已知效应而形成的，同时假设随机噪声将等于其平均值零。",
            "answer": "$$\n\\boxed{-\\frac{11}{4}}\n$$"
        },
        {
            "introduction": "在预测了状态的均值之后，我们必须量化预测的不确定性。本练习将重点关注预测协方差矩阵的演化，它结合了现有不确定性通过系统动力学的传播和新的过程噪声的注入。完成这个练习将帮助你深入理解不确定性是如何在预测步骤中增长和变化的。",
            "id": "3381758",
            "problem": "考虑一个用于反问题和数据同化中卡尔曼滤波器（KF）预测步骤的线性高斯状态转移模型。状态演化遵循 $x_{k} = A x_{k-1} + w_{k-1}$，其中 $x_{k} \\in \\mathbb{R}^{n}$ 是时刻 $k$ 的状态，$A \\in \\mathbb{R}^{n \\times n}$ 是线性传播算子，$w_{k-1}$ 是独立于 $x_{k-1}$ 的零均值过程噪声。设前一时刻的后验协方差为 $P_{k-1|k-1} = \\operatorname{Cov}(x_{k-1} \\mid y_{1:k-1})$。\n\n从协方差的定义出发，仅使用期望、独立性和随机向量线性变换的性质，推导预测协方差 $P_{k|k-1} = \\operatorname{Cov}(x_k \\mid y_{1:k-1})$ 的表达式，并针对以下 $n=2$ 的数值案例进行计算：\n$$\nA = \\begin{pmatrix}\n1.5  0.4 \\\\\n0.2  0.7\n\\end{pmatrix}, \\quad\nP_{k-1|k-1} = \\begin{pmatrix}\n2.0  0.5 \\\\\n0.5  1.0\n\\end{pmatrix}, \\quad\nQ = \\begin{pmatrix}\n0.3  0.0 \\\\\n0.0  0.2\n\\end{pmatrix}.\n$$\n然后，基于协方差在线性映射下如何变换的第一性原理，论证算子 $A$ 是放大还是抑制了沿其主方向的预测不确定性，并解释原因。\n\n精确提供您的数值矩阵 $P_{k|k-1}$；无需四舍五入。您的最终答案必须是矩阵 $P_{k|k-1}$。",
            "solution": "在尝试解答之前，对问题陈述进行严格验证。\n\n### 第1步：提取已知条件\n-   状态演化模型：$x_{k} = A x_{k-1} + w_{k-1}$，其中 $x_{k} \\in \\mathbb{R}^{n}$。\n-   $A \\in \\mathbb{R}^{n \\times n}$ 是线性传播算子。\n-   $w_{k-1}$ 是独立于 $x_{k-1}$ 的零均值过程噪声。\n-   前一时刻的后验协方差为 $P_{k-1|k-1} = \\operatorname{Cov}(x_{k-1} \\mid y_{1:k-1})$。\n-   预测协方差为 $P_{k|k-1} = \\operatorname{Cov}(x_k \\mid y_{1:k-1})$。\n-   过程噪声协方差为 $Q = \\operatorname{Cov}(w_{k-1})$。根据问题背景，这就是给定的矩阵 $Q$。\n-   $n=2$ 的数值案例：\n    -   传播算子矩阵：$A = \\begin{pmatrix} 1.5  0.4 \\\\ 0.2  0.7 \\end{pmatrix}$\n    -   前一时刻的后验协方差：$P_{k-1|k-1} = \\begin{pmatrix} 2.0  0.5 \\\\ 0.5  1.0 \\end{pmatrix}$\n    -   过程噪声协方差：$Q = \\begin{pmatrix} 0.3  0.0 \\\\ 0.0  0.2 \\end{pmatrix}$\n\n### 第2步：使用提取的已知条件进行验证\n-   **科学依据：** 该问题描述了卡尔曼滤波器的预测步骤，这是估计理论和数据同化中的一个基本算法。其状态空间模型、定义和目标都是标准的且科学正确的。\n-   **适定性：** 该问题要求进行标准推导，然后是数值计算和定性分析。所有必要信息均已提供，且存在唯一、有意义的解。\n-   **客观性：** 问题使用精确的数学语言陈述，没有主观性。\n-   **完整性和一致性：** 所有需要的矩阵（$A$、$P_{k-1|k-1}$、$Q$）都已提供，并且对于 $n=2$ 维度一致。协方差矩阵 $P_{k-1|k-1}$ 和 $Q$ 按要求是对称的。过程噪声 $w_{k-1}$ 的性质已明确定义。该问题是自洽的。\n\n### 第3步：结论与行动\n问题有效。它在科学上是合理的，是适定的，并且提供了所有必要的信息。我们继续进行解答。\n\n卡尔曼滤波器的预测步骤在融合时刻 $k$ 的量测之前，将状态估计及其协方差从时刻 $k-1$ 向前传播到时刻 $k$。根据要求，解答分为三个部分：预测协方差方程的推导，针对给定案例的数值计算，以及对算子 $A$ 的分析。\n\n**第1部分：预测协方差 $P_{k|k-1}$ 的推导**\n\n预测协方差 $P_{k|k-1}$ 定义为状态 $x_k$ 在给定截至时刻 $k-1$ 的所有观测值 $y_{1:k-1}$ 条件下的协方差。\n$$P_{k|k-1} = \\operatorname{Cov}(x_k \\mid y_{1:k-1}) = E[(x_k - E[x_k \\mid y_{1:k-1}])(x_k - E[x_k \\mid y_{1:k-1}])^T \\mid y_{1:k-1}]$$\n我们将预测状态估计定义为 $\\hat{x}_{k|k-1} = E[x_k \\mid y_{1:k-1}]$，将前一时刻的后验状态估计定义为 $\\hat{x}_{k-1|k-1} = E[x_{k-1} \\mid y_{1:k-1}]$。\n\n首先，我们通过对状态演化方程取条件期望来求取预测状态估计 $\\hat{x}_{k|k-1}$ 的表达式：\n$$\\hat{x}_{k|k-1} = E[A x_{k-1} + w_{k-1} \\mid y_{1:k-1}]$$\n根据期望的线性性质：\n$$\\hat{x}_{k|k-1} = E[A x_{k-1} \\mid y_{1:k-1}] + E[w_{k-1} \\mid y_{1:k-1}]$$\n由于 $A$ 是一个常数矩阵：\n$$\\hat{x}_{k|k-1} = A E[x_{k-1} \\mid y_{1:k-1}] + E[w_{k-1} \\mid y_{1:k-1}]$$\n第一项是 $A \\hat{x}_{k-1|k-1}$。对于第二项，过程噪声 $w_{k-1}$ 独立于过去的状态，因此也独立于过去的观测值 $y_{1:k-1}$。题目还给定了其均值为零。因此，$E[w_{k-1} \\mid y_{1:k-1}] = E[w_{k-1}] = 0$。\n因此，状态预测为：\n$$\\hat{x}_{k|k-1} = A \\hat{x}_{k-1|k-1}$$\n\n现在，我们将其代回协方差的定义中。预测误差为 $x_k - \\hat{x}_{k|k-1}$。\n$$x_k - \\hat{x}_{k|k-1} = (A x_{k-1} + w_{k-1}) - (A \\hat{x}_{k-1|k-1}) = A(x_{k-1} - \\hat{x}_{k-1|k-1}) + w_{k-1}$$\n设 $e_{k-1|k-1} = x_{k-1} - \\hat{x}_{k-1|k-1}$ 为时刻 $k-1$ 的后验误差。那么预测误差为 $A e_{k-1|k-1} + w_{k-1}$。\n预测协方差是该误差的外积的期望：\n$$P_{k|k-1} = E[(A e_{k-1|k-1} + w_{k-1})(A e_{k-1|k-1} + w_{k-1})^T \\mid y_{1:k-1}]$$\n展开期望内的项：\n$$P_{k|k-1} = E[A e_{k-1|k-1} e_{k-1|k-1}^T A^T + A e_{k-1|k-1} w_{k-1}^T + w_{k-1} e_{k-1|k-1}^T A^T + w_{k-1} w_{k-1}^T \\mid y_{1:k-1}]$$\n再次使用期望的线性性质：\n$$P_{k|k-1} = E[A e_{k-1|k-1} e_{k-1|k-1}^T A^T] + E[A e_{k-1|k-1} w_{k-1}^T] + E[w_{k-1} e_{k-1|k-1}^T A^T] + E[w_{k-1} w_{k-1}^T]$$\n（其中条件 $y_{1:k-1}$ 隐含在期望 $E[\\cdot]$ 中）。\n我们分析每一项：\n1.  $E[A e_{k-1|k-1} e_{k-1|k-1}^T A^T] = A E[e_{k-1|k-1} e_{k-1|k-1}^T] A^T = A P_{k-1|k-1} A^T$。这是因为 $P_{k-1|k-1} = \\operatorname{Cov}(x_{k-1} \\mid y_{1:k-1}) = E[e_{k-1|k-1}e_{k-1|k-1}^T \\mid y_{1:k-1}]$，因为误差 $e_{k-1|k-1}$ 的均值为零。\n2.  交叉项为零。例如，$E[A e_{k-1|k-1} w_{k-1}^T] = A E[e_{k-1|k-1} w_{k-1}^T]$。误差 $e_{k-1|k-1}$ 是截至时刻 $k-1$ 的历史信息的函数。过程噪声 $w_{k-1}$ 独立于此历史信息。由于 $w_{k-1}$ 也是零均值，乘积的期望等于期望的乘积：$A E[e_{k-1|k-1}]E[w_{k-1}^T] = A \\cdot 0 \\cdot 0^T = 0$。同理，$E[w_{k-1} e_{k-1|k-1}^T A^T] = 0$。\n3.  $E[w_{k-1} w_{k-1}^T]$。由于 $w_{k-1}$ 独立于过去的历史信息且均值为零，这便是过程噪声的协方差，$Q = \\operatorname{Cov}(w_{k-1})$。\n\n综合这些结果，我们得到预测协方差更新方程：\n$$P_{k|k-1} = A P_{k-1|k-1} A^T + Q$$\n\n**第2部分：数值计算**\n\n已知：\n$A = \\begin{pmatrix} 1.5  0.4 \\\\ 0.2  0.7 \\end{pmatrix}$， $P_{k-1|k-1} = \\begin{pmatrix} 2.0  0.5 \\\\ 0.5  1.0 \\end{pmatrix}$， $Q = \\begin{pmatrix} 0.3  0.0 \\\\ 0.0  0.2 \\end{pmatrix}$。\n首先，我们计算项 $A P_{k-1|k-1} A^T$。\n$A^T = \\begin{pmatrix} 1.5  0.2 \\\\ 0.4  0.7 \\end{pmatrix}$。\n接下来，我们计算乘积 $A P_{k-1|k-1}$：\n$$A P_{k-1|k-1} = \\begin{pmatrix} 1.5  0.4 \\\\ 0.2  0.7 \\end{pmatrix} \\begin{pmatrix} 2.0  0.5 \\\\ 0.5  1.0 \\end{pmatrix} = \\begin{pmatrix} (1.5)(2.0)+(0.4)(0.5)  (1.5)(0.5)+(0.4)(1.0) \\\\ (0.2)(2.0)+(0.7)(0.5)  (0.2)(0.5)+(0.7)(1.0) \\end{pmatrix}$$\n$$A P_{k-1|k-1} = \\begin{pmatrix} 3.0+0.2  0.75+0.4 \\\\ 0.4+0.35  0.1+0.7 \\end{pmatrix} = \\begin{pmatrix} 3.2  1.15 \\\\ 0.75  0.8 \\end{pmatrix}$$\n现在，我们乘以 $A^T$：\n$$A P_{k-1|k-1} A^T = \\begin{pmatrix} 3.2  1.15 \\\\ 0.75  0.8 \\end{pmatrix} \\begin{pmatrix} 1.5  0.2 \\\\ 0.4  0.7 \\end{pmatrix} = \\begin{pmatrix} (3.2)(1.5)+(1.15)(0.4)  (3.2)(0.2)+(1.15)(0.7) \\\\ (0.75)(1.5)+(0.8)(0.4)  (0.75)(0.2)+(0.8)(0.7) \\end{pmatrix}$$\n$$A P_{k-1|k-1} A^T = \\begin{pmatrix} 4.8+0.46  0.64+0.805 \\\\ 1.125+0.32  0.15+0.56 \\end{pmatrix} = \\begin{pmatrix} 5.26  1.445 \\\\ 1.445  0.71 \\end{pmatrix}$$\n最后，我们加上过程噪声协方差 $Q$：\n$$P_{k|k-1} = A P_{k-1|k-1} A^T + Q = \\begin{pmatrix} 5.26  1.445 \\\\ 1.445  0.71 \\end{pmatrix} + \\begin{pmatrix} 0.3  0.0 \\\\ 0.0  0.2 \\end{pmatrix}$$\n$$P_{k|k-1} = \\begin{pmatrix} 5.26+0.3  1.445+0.0 \\\\ 1.445+0.0  0.71+0.2 \\end{pmatrix} = \\begin{pmatrix} 5.56  1.445 \\\\ 1.445  0.91 \\end{pmatrix}$$\n\n**第3部分：算子 $A$ 对不确定性传播的分析**\n\n预测协方差更新有两个部分：$A P_{k-1|k-1} A^T$ 代表现有不确定性通过系统动力学的传播，$Q$ 代表来自过程噪声的新增不确定性。要分析算子 $A$ 本身的影响，我们必须考察它如何变换不确定性。\n\n从第一性原理出发，线性映射 $x \\mapsto Ax$ 变换一个误差分量。如果误差位于 $A$ 的一个特征向量 $v$ 的方向上（即 $Av = \\lambda v$），那么变换后的误差为 $A(\\epsilon v) = \\epsilon(Av) = (\\epsilon \\lambda)v$。此方向上误差分量的大小被特征值的模 $|\\lambda|$ 缩放。算子 $A$ 的主方向是其特征方向。\n-   如果 $|\\lambda| > 1$，算子 $A$ 会放大沿相应特征向量 $v$ 的任何不确定性分量。\n-   如果 $|\\lambda|  1$，算子 $A$ 会抑制（减小）沿相应特征向量 $v$ 的任何不确定性分量。\n-   如果 $|\\lambda| = 1$，不确定性分量的大小保持不变。\n\n我们从特征方程 $\\det(A-\\lambda I) = 0$ 计算 $A$ 的特征值：\n$$\\det\\begin{pmatrix} 1.5 - \\lambda  0.4 \\\\ 0.2  0.7 - \\lambda \\end{pmatrix} = 0$$\n$$(1.5 - \\lambda)(0.7 - \\lambda) - (0.4)(0.2) = 0$$\n$$\\lambda^2 - 2.2\\lambda + 1.05 - 0.08 = 0$$\n$$\\lambda^2 - 2.2\\lambda + 0.97 = 0$$\n使用二次方程求根公式 $\\lambda = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$：\n$$\\lambda = \\frac{2.2 \\pm \\sqrt{(-2.2)^2 - 4(1)(0.97)}}{2} = \\frac{2.2 \\pm \\sqrt{4.84 - 3.88}}{2} = \\frac{2.2 \\pm \\sqrt{0.96}}{2}$$\n两个特征值为 $\\lambda_1 = 1.1 + \\sqrt{0.24}$ 和 $\\lambda_2 = 1.1 - \\sqrt{0.24}$。\n由于 $A$ 的元素是实数，其对应于实特征值的特征向量是实向量，定义了 $\\mathbb{R}^2$ 中的实方向。\n我们来分析它们的大小：\n-   对于 $\\lambda_1 = 1.1 + \\sqrt{0.24}$：由于 $\\sqrt{0.24} > 0$，显然 $\\lambda_1 > 1.1$，因此 $|\\lambda_1| > 1$。\n-   对于 $\\lambda_2 = 1.1 - \\sqrt{0.24}$：我们需要判断这个值是大于1还是小于1。这等价于比较 $0.1$ 和 $\\sqrt{0.24}$。将两个正数平方，我们比较 $0.1^2=0.01$ 和 $(\\sqrt{0.24})^2=0.24$。因为 $0.01  0.24$，所以 $0.1  \\sqrt{0.24}$，这意味着 $1.1 - \\sqrt{0.24}  1.0$。另外，由于 $\\sqrt{0.24}  \\sqrt{1.21} = 1.1$，所以 $\\lambda_2 > 0$。因此，$0  \\lambda_2  1$，从而 $|\\lambda_2|  1$。\n\n结论：算子 $A$ 有两个不同的主方向（其特征向量）。沿一个方向（对应于特征值 $\\lambda_1 \\approx 1.59$），不确定性被放大。沿另一个方向（对应于特征值 $\\lambda_2 \\approx 0.61$），不确定性被抑制。因此，算子 $A$ 的作用是混合的：它在一个方向上是不稳定的或扩张的，而在另一个方向上是稳定的或收缩的。",
            "answer": "$$\\boxed{\\begin{pmatrix} 5.56  1.445 \\\\ 1.445  0.91 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在处理高维系统（如天气预报模型）时，直接计算和存储协方差矩阵在计算上是昂贵的，且数值上不稳定。本练习介绍了一种先进且稳健的方法——平方根滤波器，它通过操作协方差矩阵的“平方根”来避免这些问题。这个实践将让你掌握一种在现实世界大规模数据同化应用中至关重要的算法。",
            "id": "3381740",
            "problem": "给定一个线性的、离散时间的动力系统，其形式为卡尔曼滤波器预测步骤的标准形式。设状态为一个 $n$ 维向量，且预测模型为线性的：\n$$\n\\mathbf{x}_{k+1} = \\mathbf{F}\\,\\mathbf{x}_k + \\mathbf{w}_k,\n$$\n其中 $\\mathbf{F} \\in \\mathbb{R}^{n \\times n}$ 是模型算子，$\\mathbf{w}_k$ 是过程噪声，其协方差 $\\mathbf{Q} \\in \\mathbb{R}^{n \\times n}$ 是对称半正定的。在基于集合的数据同化中，我们用一个平方根因子 $\\mathbf{S} \\in \\mathbb{R}^{n \\times r}$ 来表示状态协方差，使得\n$$\n\\mathbf{P} = \\mathbf{S}\\,\\mathbf{S}^\\top,\n$$\n其中 $r$ 是因子秩。预测协方差应满足\n$$\n\\mathbf{P}^{f} = \\mathbf{F}\\,\\mathbf{P}\\,\\mathbf{F}^\\top + \\mathbf{Q}.\n$$\n\n你的任务是推导并实现一个平方根集合预报算法，该算法计算一个预测平方根因子 $\\mathbf{S}^{f}$，满足\n$$\n\\mathbf{S}^{f} \\left(\\mathbf{S}^{f}\\right)^\\top = \\mathbf{F}\\,\\mathbf{S}\\,\\mathbf{S}^\\top\\,\\mathbf{F}^\\top + \\mathbf{Q},\n$$\n同时明确避免生成任何协方差矩阵。你的实现必须使用对一个适当构造的矩阵进行单次薄（经济）QR分解，该矩阵仅依赖于 $\\mathbf{F}$、$\\mathbf{S}$ 和 $\\mathbf{Q}$ 的一个平方根因子，并且必须不直接生成 $\\mathbf{P}$ 或 $\\mathbf{P}^{f}$ 来计算 $\\mathbf{S}^{f}$。\n\n从第一性原理出发——即卡尔曼滤波器预测步骤的核心定义、平方根分解的性质以及关于格拉姆矩阵QR分解的成熟结论——你必须：\n- 推导为什么对一个结合了传播后的先验平方根因子和过程噪声平方根因子的增广矩阵进行单次QR分解，可以得到一个有效的预测平方根因子。\n- 在不生成任何协方差矩阵的情况下，解释这种方法如何避免在高维情况下与协方差生成相关的数值问题。\n- 实现所推导的算法，并数值验证所得的预测平方根因子能够再现由模型算子和过程噪声所隐含的预测协方差。\n\n设计一个由三个测试用例组成的确定性测试套件。对于每个测试用例，使用指定的随机种子和程序构造矩阵，以使场景在科学上是合理的：\n\n- 测试用例1（正常路径）：\n  - 维度 $n = 5$。\n  - 随机种子 $s = 42$。\n  - 构造 $\\mathbf{P} = \\mathbf{S}\\,\\mathbf{S}^\\top$，其中 $\\mathbf{S}$ 是一个对称正定矩阵 $\\mathbf{R}\\,\\mathbf{R}^\\top + \\varepsilon\\,\\mathbf{I}$ 的Cholesky因子，其中 $\\varepsilon = 10^{-3}$，$\\mathbf{R}$ 的元素为独立同分布的标准正态分布。\n  - 构造一个稳定的 $\\mathbf{F}$，方法是生成一个随机矩阵 $\\mathbf{G}$（其元素为独立同分布的标准正态分布），然后将 $\\mathbf{G}$ 按因子 $\\alpha = 0.8 / \\rho(\\mathbf{G})$ 进行缩放，其中 $\\rho(\\mathbf{G})$ 是 $\\mathbf{G}$ 的谱半径，使得 $\\rho(\\mathbf{F}) \\approx 0.8$。\n  - 构造 $\\mathbf{Q}$ 为 $\\mathbf{B}\\,\\mathbf{B}^\\top + \\varepsilon\\,\\mathbf{I}$，其中 $\\mathbf{B}$ 的元素为独立同分布的标准正态分布，$\\varepsilon$ 值相同；取其Cholesky因子作为 $\\mathbf{Q}$ 的平方根因子。\n\n- 测试用例2（高维情形）：\n  - 维度 $n = 100$。\n  - 随机种子 $s = 1234$。\n  - 类似于测试用例1，使用相同的 $\\varepsilon = 10^{-3}$ 和稳定缩放因子 $\\alpha = 0.8 / \\rho(\\mathbf{G})$ 来构造 $\\mathbf{S}$、$\\mathbf{F}$ 和 $\\mathbf{Q}$。\n\n- 测试用例3（过程噪声秩亏的边界情况）：\n  - 维度 $n = 40$。\n  - 随机种子 $s = 7$。\n  - 如测试用例1一样构造 $\\mathbf{S}$。\n  - 构造一个秩亏的过程噪声平方根因子，方法是首先生成一个元素为独立同分布的标准正态分布的矩阵 $\\mathbf{B}$，然后将 $\\mathbf{B}$ 的最后 $\\lfloor n/4 \\rfloor$ 列设为零以降低秩，并定义 $\\mathbf{Q} = \\mathbf{B}\\,\\mathbf{B}^\\top$，其中 $\\mathbf{B}$ 作为其平方根因子。\n  - 如测试用例1一样构造一个稳定的 $\\mathbf{F}$。\n\n对于每个测试用例，仅使用你推导的基于QR的算法计算预测平方根因子 $\\mathbf{S}^{f}$，然后，仅为了验证目的，显式计算预测协方差 $\\mathbf{P}^{f} = \\mathbf{F}\\,\\mathbf{S}\\,\\mathbf{S}^\\top\\,\\mathbf{F}^\\top + \\mathbf{Q}$。报告每个测试用例中，由基于QR的平方根重构的协方差与显式预测协方差之间的相对Frobenius范数误差：\n$$\ne = \\frac{\\left\\| \\mathbf{S}^{f}\\left(\\mathbf{S}^{f}\\right)^\\top - \\mathbf{P}^{f} \\right\\|_F}{\\left\\| \\mathbf{P}^{f} \\right\\|_F}.\n$$\n\n你的程序应该产生单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$）。每个 $\\text{result}_i$ 必须是对应测试用例的相对误差 $e$ 的浮点数。此问题不涉及任何物理单位或角度单位；所有输出均为无量纲实数。",
            "solution": "该问题要求推导并实现一个用于线性离散时间动力系统的平方根预测算法。该算法必须计算预测状态协方差的平方根因子 $\\mathbf{S}^f$，而无需显式地生成完整的协方差矩阵。\n\n系统的状态根据以下线性模型演化：\n$$\n\\mathbf{x}_{k+1} = \\mathbf{F}\\,\\mathbf{x}_k + \\mathbf{w}_k\n$$\n其中 $\\mathbf{x}_k \\in \\mathbb{R}^n$ 是在时间 $k$ 的状态向量，$\\mathbf{F} \\in \\mathbb{R}^{n \\times n}$ 是模型算子，而 $\\mathbf{w}_k$ 是一个零均值过程噪声，其协方差矩阵 $\\mathbf{Q} \\in \\mathbb{R}^{n \\times n}$ 是对称半正定的。\n\n先验状态误差协方差矩阵 $\\mathbf{P}$ 由一个平方根因子 $\\mathbf{S} \\in \\mathbb{R}^{n \\times r}$ 表示，使得 $\\mathbf{P} = \\mathbf{S}\\mathbf{S}^\\top$。预测误差协方差 $\\mathbf{P}^f$ 由以下传播方程给出：\n$$\n\\mathbf{P}^{f} = \\mathbf{F}\\,\\mathbf{P}\\,\\mathbf{F}^\\top + \\mathbf{Q}\n$$\n我们的目标是找到一个预测平方根因子 $\\mathbf{S}^f$，它满足 $\\mathbf{S}^{f} \\left(\\mathbf{S}^{f}\\right)^\\top = \\mathbf{P}^{f}$。\n\n### 从第一性原理推导\n\n推导从预测协方差和矩阵分解的基本定义出发。\n\n1.  **替换平方根因子**：我们已知先验协方差的平方根因子 $\\mathbf{P} = \\mathbf{S}\\mathbf{S}^\\top$，对于过程噪声协方差，我们可以定义一个因子 $\\mathbf{S}_Q \\in \\mathbb{R}^{n \\times q}$，使得 $\\mathbf{Q} = \\mathbf{S}_Q \\mathbf{S}_Q^\\top$。将这些代入预测协方差方程，得到：\n    $$\n    \\mathbf{P}^{f} = \\mathbf{F}\\,(\\mathbf{S}\\mathbf{S}^\\top)\\,\\mathbf{F}^\\top + \\mathbf{S}_Q \\mathbf{S}_Q^\\top\n    $$\n\n2.  **重排为类格拉姆结构**：利用矩阵转置性质 $(AB)^\\top = B^\\top A^\\top$，第一项可以重写为：\n    $$\n    \\mathbf{F}\\mathbf{S}\\mathbf{S}^\\top\\mathbf{F}^\\top = (\\mathbf{F}\\mathbf{S})(\\mathbf{S}^\\top\\mathbf{F}^\\top) = (\\mathbf{F}\\mathbf{S})(\\mathbf{F}\\mathbf{S})^\\top\n    $$\n    现在，预测协方差是两个外积之和：\n    $$\n    \\mathbf{P}^{f} = (\\mathbf{F}\\mathbf{S})(\\mathbf{F}\\mathbf{S})^\\top + \\mathbf{S}_Q \\mathbf{S}_Q^\\top\n    $$\n\n3.  **构造增广矩阵**：这个和可以通过构造一个增广矩阵，表示为单个矩阵的外积。我们定义一个新矩阵 $\\mathbf{M}$，通过水平拼接传播后的先验因子 $\\mathbf{F}\\mathbf{S}$ 和过程噪声因子 $\\mathbf{S}_Q$ 得到：\n    $$\n    \\mathbf{M} = \\begin{bmatrix} \\mathbf{F}\\mathbf{S}  \\mathbf{S}_Q \\end{bmatrix}\n    $$\n    $\\mathbf{M}$ 的维度是 $n \\times (r+q)$，其中 $r$ 和 $q$ 分别是 $\\mathbf{S}$ 和 $\\mathbf{S}_Q$ 的列数。$\\mathbf{M}$ 与其自身的外积是：\n    $$\n    \\mathbf{M}\\mathbf{M}^\\top = \\begin{bmatrix} \\mathbf{F}\\mathbf{S}  \\mathbf{S}_Q \\end{bmatrix} \\begin{bmatrix} (\\mathbf{F}\\mathbf{S})^\\top \\\\ \\mathbf{S}_Q^\\top \\end{bmatrix} = (\\mathbf{F}\\mathbf{S})(\\mathbf{F}\\mathbf{S})^\\top + \\mathbf{S}_Q \\mathbf{S}_Q^\\top\n    $$\n    这证明了关键等式：$\\mathbf{P}^f = \\mathbf{M}\\mathbf{M}^\\top$。\n\n4.  **应用QR分解**：我们现在寻求一个矩阵 $\\mathbf{S}^f$ 使得 $\\mathbf{S}^f(\\mathbf{S}^f)^\\top = \\mathbf{M}\\mathbf{M}^\\top$。我们必须避免直接计算乘积 $\\mathbf{M}\\mathbf{M}^\\top$，因此我们可以使用QR分解。让我们对增广矩阵的转置 $\\mathbf{M}^\\top$ 进行薄（经济）QR分解：\n    $$\n    \\mathbf{M}^\\top = \\mathbf{Q}_{qr} \\mathbf{R}_{qr}\n    $$\n    这里，$\\mathbf{Q}_{qr}$ 是一个具有标准正交列的矩阵（即 $\\mathbf{Q}_{qr}^\\top \\mathbf{Q}_{qr} = \\mathbf{I}$），而 $\\mathbf{R}_{qr}$ 是一个上三角（或上梯形）矩阵。将此方程转置回来，得到 $\\mathbf{M} = (\\mathbf{Q}_{qr} \\mathbf{R}_{qr})^\\top = \\mathbf{R}_{qr}^\\top \\mathbf{Q}_{qr}^\\top$。\n\n5.  **确定预测平方根因子**：现在，我们将 $\\mathbf{M}$ 的这种形式代回到 $\\mathbf{P}^f$ 的表达式中：\n    $$\n    \\mathbf{P}^f = \\mathbf{M}\\mathbf{M}^\\top = (\\mathbf{R}_{qr}^\\top \\mathbf{Q}_{qr}^\\top)(\\mathbf{Q}_{qr} \\mathbf{R}_{qr}) = \\mathbf{R}_{qr}^\\top (\\mathbf{Q}_{qr}^\\top \\mathbf{Q}_{qr}) \\mathbf{R}_{qr}\n    $$\n    由于 $\\mathbf{Q}_{qr}$ 具有标准正交列，所以 $\\mathbf{Q}_{qr}^\\top \\mathbf{Q}_{qr} = \\mathbf{I}$。这使表达式简化为：\n    $$\n    \\mathbf{P}^f = \\mathbf{R}_{qr}^\\top \\mathbf{I} \\mathbf{R}_{qr} = \\mathbf{R}_{qr}^\\top \\mathbf{R}_{qr}\n    $$\n    我们正在寻找一个满足 $\\mathbf{S}^f(\\mathbf{S}^f)^\\top = \\mathbf{P}^f$ 的矩阵 $\\mathbf{S}^f$。如果我们将预测平方根因子定义为 $\\mathbf{S}^f = \\mathbf{R}_{qr}^\\top$，我们可以验证这个条件：\n    $$\n    \\mathbf{S}^f(\\mathbf{S}^f)^\\top = (\\mathbf{R}_{qr}^\\top)(\\mathbf{R}_{qr}^\\top)^\\top = \\mathbf{R}_{qr}^\\top \\mathbf{R}_{qr} = \\mathbf{P}^f\n    $$\n    这证实了 $\\mathbf{S}^f = \\mathbf{R}_{qr}^\\top$ 是一个有效的预测平方根因子。该算法仅使用矩阵-矩阵乘法和一次QR分解来计算此因子，而从未生成 $\\mathbf{P}$、$\\mathbf{Q}$ 或 $\\mathbf{P}^f$。\n\n### 避免数值不稳定性\n\n在高维系统中，协方差矩阵通常是病态的，意味着它们的奇异值跨越多个数量级。从其平方根因子生成协方差矩阵的过程 $\\mathbf{P} = \\mathbf{S}\\mathbf{S}^\\top$ 涉及一个平方操作。这种平方效应会使奇异值对数的范围加倍，并使矩阵的条件数平方，即 $\\kappa(\\mathbf{P}) \\approx \\kappa(\\mathbf{S})^2$。\n\n例如，如果 $\\mathbf{S}$ 的条件数为 $10^9$，那么 $\\mathbf{P}$ 的条件数将为 $10^{18}$。在标准双精度浮点运算中（其精度约为16位十进制数），$\\mathbf{P}$ 的最小奇异值在数值上将与零无法区分，导致秩和信息的有效损失。任何后续涉及 $\\mathbf{P}$ 的操作，如求逆或加法，都可能遭受巨大的数值误差或灾难性抵消。\n\n所推导的平方根算法通过直接对因子 $\\mathbf{S}$ 和 $\\mathbf{S}_Q$ 进行操作来规避此问题。核心操作是矩阵乘法和QR分解。QR分解是一种正交变换，已知是向后稳定的，并且能保持矩阵的条件数。通过将这些因子拼接成 $\\mathbf{M}$，然后应用这种稳定的变换，我们有效地结合了由 $\\mathbf{S}$ 和 $\\mathbf{S}_Q$ 代表的不确定性，而没有使其条件数平方。这确保了数值精度的维持，使算法即使对于地球科学、工程和其他领域中常见的大规模和病态问题也保持稳健。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Solves the three test cases specified in the problem and prints the results.\n    \"\"\"\n    \n    test_cases = [\n        # (n, seed, case_type)\n        (5, 42, 'happy_path'),\n        (100, 1234, 'high_dim'),\n        (40, 7, 'rank_deficient'),\n    ]\n\n    results = []\n    for n, seed, case_type in test_cases:\n        error = run_test_case(n, seed, case_type)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_test_case(n, seed, case_type):\n    \"\"\"\n    Generates matrices for a single test case, runs the QR-based square-root\n    forecast algorithm, and computes the verification error.\n    \n    Args:\n        n (int): The dimension of the state space.\n        seed (int): The random seed for reproducibility.\n        case_type (str): The type of test case to run.\n\n    Returns:\n        float: The relative Frobenius-norm error.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    epsilon = 1e-3\n\n    # 1. Construct the prior square-root factor S\n    # P = S S^T. We use Cholesky L, so L L^T. Thus S = L.\n    R_prior = rng.standard_normal((n, n))\n    P_tmp = R_prior @ R_prior.T + epsilon * np.identity(n)\n    S = linalg.cholesky(P_tmp, lower=True)\n\n    # 2. Construct a stable model operator F\n    G = rng.standard_normal((n, n))\n    eigvals = linalg.eigvals(G)\n    rho_G = np.max(np.abs(eigvals))\n    F = (0.8 / rho_G) * G\n\n    # 3. Construct the process noise covariance Q and its square-root factor S_Q\n    if case_type in ['happy_path', 'high_dim']:\n        B = rng.standard_normal((n, n))\n        Q = B @ B.T + epsilon * np.identity(n)\n        S_Q = linalg.cholesky(Q, lower=True)\n    elif case_type == 'rank_deficient':\n        B = rng.standard_normal((n, n))\n        num_zero_cols = n // 4\n        B[:, -num_zero_cols:] = 0.0\n        S_Q = B\n        # For verification, we need the explicit Q\n        Q = S_Q @ S_Q.T\n    else:\n        raise ValueError(\"Invalid case type specified.\")\n\n    # --- QR-Based Square-Root Forecast Algorithm ---\n    # Propagate the prior square-root factor\n    FS = F @ S\n    \n    # Form the augmented matrix M = [FS, S_Q]\n    M = np.hstack([FS, S_Q])\n    \n    # Perform thin QR factorization of M^T = Q_qr R_qr\n    # Using scipy.linalg.qr as specified\n    Q_qr, R_qr = linalg.qr(M.T, mode='economic')\n    \n    # The new forecast square-root factor is S_f = R_qr^T\n    S_f = R_qr.T\n    \n    # --- Verification ---\n    # Reconstruct the forecast covariance from the computed square-root factor\n    P_f_sqrt = S_f @ S_f.T\n\n    # Compute the explicit forecast covariance for direct comparison\n    P = S @ S.T\n    P_f_explicit = F @ P @ F.T + Q\n\n    # Compute the relative Frobenius-norm error\n    # e = || S_f S_f^T - P_f ||_F / || P_f ||_F\n    numerator = linalg.norm(P_f_sqrt - P_f_explicit, 'fro')\n    denominator = linalg.norm(P_f_explicit, 'fro')\n    \n    if denominator == 0:\n        return 0.0 if numerator == 0 else np.inf\n        \n    relative_error = numerator / denominator\n    return relative_error\n\nsolve()\n```"
        }
    ]
}