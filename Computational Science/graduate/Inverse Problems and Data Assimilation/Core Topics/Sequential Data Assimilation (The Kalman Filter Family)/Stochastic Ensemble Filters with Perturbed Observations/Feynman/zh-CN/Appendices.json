{
    "hands_on_practices": [
        {
            "introduction": "随机集合滤波器的一个核心环节是预测步骤，它将分析集合成员向前推进到下一个时间点。这个实践旨在通过一个具体的编程任务，巩固您对随机预测步骤的理解。您将通过Cholesky分解对模型噪声进行采样，并验证生成的预测集合的经验协方差是否在统计采样误差范围内与理论协方差一致 。",
            "id": "3422911",
            "problem": "考虑一个离散时间的状态维度为 $d$ 的线性高斯状态演化模型，由 $x_{k} = \\Phi x_{k-1} + w_{k}$ 给出，其中 $\\Phi \\in \\mathbb{R}^{d \\times d}$ 是一个已知的预报算子， $w_{k} \\sim \\mathcal{N}(0, Q)$ 是高斯过程噪声，其协方差 $Q \\in \\mathbb{R}^{d \\times d}$ 是对称正定的。在随机集合滤波（例如，集合卡尔曼滤波器 (EnKF)）中，第 $k$ 步的预报集合是通过将每个分析集合成员通过 $\\Phi$ 进行映射，并添加一个从 $\\mathcal{N}(0, Q)$ 中抽取的独立扰动 $w_{k}^{(i)}$ 来获得的。一种对 $w_{k}^{(i)}$ 进行采样的数值稳定方法是计算 Cholesky 分解 $Q = L L^{\\top}$（其中 $L$ 是下三角矩阵），并设置 $w_{k}^{(i)} = L \\xi^{(i)}$，其中 $\\xi^{(i)} \\sim \\mathcal{N}(0, I_{d})$ 在集合成员之间是独立的。\n\n从以下基本事实出发：\n- 如果 $x_{a}^{(i)} \\sim \\mathcal{N}(m^{a}, P^{a})$ 是独立的分析集合成员，且 $w^{(i)} \\sim \\mathcal{N}(0, Q)$ 独立于 $x_{a}^{(i)}$，那么 $x_{f}^{(i)} = \\Phi x_{a}^{(i)} + w^{(i)}$ 是从 $\\mathcal{N}(\\Phi m^{a}, \\Phi P^{a} \\Phi^{\\top} + Q)$ 中进行的独立抽样。\n- 对于真实协方差为 $\\Sigma \\in \\mathbb{R}^{d \\times d}$ 的独立同分布高斯样本，从 $N$ 个样本计算出的无偏样本协方差 $S$ 满足 $(N-1) S \\sim \\mathcal{W}_{d}(\\Sigma, N-1)$ (Wishart 分布)，且 $\\mathbb{E}[S] = \\Sigma$。对于如上的 $S$，$S$ 的分量方差遵循 $\\operatorname{Var}(S_{ij}) = \\frac{1}{N-1}\\left(\\Sigma_{ij}^{2} + \\Sigma_{ii}\\Sigma_{jj}\\right)$，这意味着\n$$\n\\mathbb{E}\\left[\\lVert S - \\Sigma \\rVert_{F}^{2}\\right] = \\frac{1}{N-1}\\left(\\lVert \\Sigma \\rVert_{F}^{2} + (\\operatorname{tr}\\Sigma)^{2}\\right).\n$$\n\n你的任务是使用基于 Cholesky 的采样来实现随机预报步骤，并验证从预报集合计算出的经验预报协方差 $\\hat{P}^{f}$ 与理论预报协方差 $\\Sigma_{f} = \\Phi P^{a} \\Phi^{\\top} + Q$ 在抽样误差（由上述公式量化）范围内是一致的。具体来说，对于每个测试用例：\n1. 生成一个分析集合 $\\{x_{a}^{(i)}\\}_{i=1}^{N}$，其中 $x_{a}^{(i)} \\sim \\mathcal{N}(m^{a}, P^{a})$，而 $m^{a} = 0$ 是相应维度的零向量。\n2. 通过 $w^{(i)} = L \\xi^{(i)}$ 采样独立的过程噪声 $w^{(i)}$，其中 $Q = L L^{\\top}$ 是 Cholesky 分解，且 $\\xi^{(i)} \\sim \\mathcal{N}(0, I_{d})$。\n3. 构建预报集合成员 $x_{f}^{(i)} = \\Phi x_{a}^{(i)} + w^{(i)}$。\n4. 计算预报集合的无偏样本协方差，\n$$\n\\hat{P}^{f} = \\frac{1}{N-1}\\sum_{i=1}^{N}\\left(x_{f}^{(i)} - \\bar{x}_{f}\\right)\\left(x_{f}^{(i)} - \\bar{x}_{f}\\right)^{\\top}, \\quad \\bar{x}_{f} = \\frac{1}{N}\\sum_{i=1}^{N} x_{f}^{(i)}.\n$$\n5. 计算理论预报协方差 $\\Sigma_{f} = \\Phi P^{a} \\Phi^{\\top} + Q$。\n6. 计算 Frobenius 范数差异 $\\Delta = \\lVert \\hat{P}^{f} - \\Sigma_{f} \\rVert_{F}$ 和由 Wishart 理论预测的均方根 (RMS) 抽样误差，\n$$\n\\varepsilon_{\\mathrm{RMS}} = \\sqrt{\\frac{\\lVert \\Sigma_{f} \\rVert_{F}^{2} + (\\operatorname{tr}\\Sigma_{f})^{2}}{N-1}}.\n$$\n如果 $\\Delta \\leq c \\, \\varepsilon_{\\mathrm{RMS}}$ 且 $c = 3$，则声明测试用例通过。\n\n所有量都是无量纲的；不需要物理单位。\n\n实现你的程序来评估以下测试套件。对于每个用例，$d$ 是状态维度，$N$ 是集合大小，矩阵已明确给出。在每个用例中，取 $m^{a} = 0$：\n- 用例 1 (正常路径，中等维度和集合大小):\n  - $d = 3$, $N = 400$,\n  - $\\Phi = \\begin{bmatrix} 0.9  0.1  0.0 \\\\ 0.0  0.7  0.2 \\\\ 0.0  0.0  0.8 \\end{bmatrix}$,\n  - $P^{a} = \\begin{bmatrix} 0.5  0.1  0.0 \\\\ 0.1  0.4  0.05 \\\\ 0.0  0.05  0.3 \\end{bmatrix}$,\n  - $Q = \\begin{bmatrix} 0.2  0.05  0.0 \\\\ 0.05  0.1  0.02 \\\\ 0.0  0.02  0.15 \\end{bmatrix}$。\n- 用例 2 (边界，标量系统):\n  - $d = 1$, $N = 200$,\n  - $\\Phi = [1.2]$,\n  - $P^{a} = [0.25]$,\n  - $Q = [0.5]$。\n- 用例 3 (更高维度，大集合大小):\n  - $d = 5$, $N = 2000$,\n  - $\\Phi = \\begin{bmatrix} 0.6  0.2  0.0  0.0  0.0 \\\\ 0.0  0.7  0.1  0.0  0.0 \\\\ 0.0  0.0  0.5  0.2  0.0 \\\\ 0.0  0.0  0.0  0.65  0.1 \\\\ 0.0  0.0  0.0  0.0  0.55 \\end{bmatrix}$,\n  - $P^{a} = \\begin{bmatrix} 1.0  0.1  0.0  0.0  0.0 \\\\ 0.1  0.8  0.0  0.0  0.0 \\\\ 0.0  0.0  0.6  0.05  0.0 \\\\ 0.0  0.0  0.05  0.7  0.0 \\\\ 0.0  0.0  0.0  0.0  0.9 \\end{bmatrix}$,\n  - $Q = \\begin{bmatrix} 0.3  0.04  0.0  0.0  0.0 \\\\ 0.04  0.25  0.03  0.0  0.0 \\\\ 0.0  0.03  0.2  0.02  0.0 \\\\ 0.0  0.0  0.02  0.15  0.01 \\\\ 0.0  0.0  0.0  0.01  0.35 \\end{bmatrix}$。\n- 用例 4 (边缘，小集合大小):\n  - $d = 4$, $N = 30$,\n  - $\\Phi = \\begin{bmatrix} 0.85  0.1  0.0  0.0 \\\\ 0.0  0.75  0.15  0.0 \\\\ 0.0  0.0  0.65  0.1 \\\\ 0.0  0.0  0.0  0.7 \\end{bmatrix}$,\n  - $P^{a} = \\begin{bmatrix} 0.6  0.05  0.0  0.0 \\\\ 0.05  0.5  0.04  0.0 \\\\ 0.0  0.04  0.4  0.03 \\\\ 0.0  0.0  0.03  0.45 \\end{bmatrix}$,\n  - $Q = \\begin{bmatrix} 0.25  0.03  0.0  0.0 \\\\ 0.03  0.2  0.02  0.0 \\\\ 0.0  0.02  0.18  0.01 \\\\ 0.0  0.0  0.01  0.22 \\end{bmatrix}$。\n\n为保证可复现性，随机数生成必须是确定性的；为每个用例使用固定的种子。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个条目都是一个布尔值，指示测试用例是否通过（例如，“[True,False,True,True]”）。",
            "solution": "该问题要求在基于集合的数据同化框架中实现和验证随机预报步骤。这涉及到根据一个线性随机动力学模型，推进一个代表系统状态概率分布的状态向量集合。任务的核心是确认生成的预报集合的样本协方差与模型预测的理论预报误差协方差在统计上是一致的。\n\n系统的状态演化由离散时间线性高斯模型描述：\n$$\nx_{k} = \\Phi x_{k-1} + w_{k}\n$$\n这里，$x_{k} \\in \\mathbb{R}^{d}$ 是时间步 $k$ 的状态向量，$\\Phi \\in \\mathbb{R}^{d \\times d}$ 是确定性预报算子（或转移矩阵），$w_{k} \\in \\mathbb{R}^{d}$ 是一个随机过程噪声向量。假设噪声从零均值多元高斯分布中抽取，$w_{k} \\sim \\mathcal{N}(0, Q)$，其协方差矩阵 $Q \\in \\mathbb{R}^{d \\times d}$ 是已知的对称正定矩阵。\n\n在集合滤波器中，状态的概率分布由一个有限的样本集——集合——来表示。设第 $k-1$ 步的分析集合为 $\\{x_{a}^{(i)}\\}_{i=1}^{N}$，其中 $N$ 是集合大小。假设每个成员 $x_{a}^{(i)}$ 都是从分析分布中独立抽取的样本，该分布是高斯的：$x_{a}^{(i)} \\sim \\mathcal{N}(m^{a}, P^{a})$。对于此问题，分析均值被指定为零向量，$m^{a} = 0$。\n\n预报步骤将每个分析集合成员传播到下一个时间步 $k$。每个成员都通过算子 $\\Phi$ 进行变换，并受到过程噪声的独立实现扰动：\n$$\nx_{f}^{(i)} = \\Phi x_{a}^{(i)} + w^{(i)}\n$$\n其中每个 $w^{(i)} \\sim \\mathcal{N}(0, Q)$ 都是独立抽取的。得到的集合 $\\{x_{f}^{(i)}\\}_{i=1}^{N}$ 就是预报集合。\n\n预报状态的理论分布可以从高斯随机向量的仿射变换性质推导出来。预报分布的均值是：\n$$\n\\mathbb{E}[x_{f}] = \\mathbb{E}[\\Phi x_{a} + w] = \\Phi \\mathbb{E}[x_{a}] + \\mathbb{E}[w] = \\Phi m^{a} + 0 = \\Phi m^{a}\n$$\n由于 $m^{a} = 0$，预报均值也为 $0$。预报分布的协方差（我们用 $\\Sigma_{f}$ 表示）是：\n$$\n\\Sigma_{f} = \\operatorname{Cov}(\\Phi x_{a} + w)\n$$\n因为分析状态 $x_{a}$ 和过程噪声 $w$ 是独立的，所以它们和的协方差是它们协方差的和：\n$$\n\\Sigma_{f} = \\operatorname{Cov}(\\Phi x_{a}) + \\operatorname{Cov}(w) = \\Phi \\operatorname{Cov}(x_{a}) \\Phi^{\\top} + Q = \\Phi P^{a} \\Phi^{\\top} + Q\n$$\n这个矩阵 $\\Sigma_{f}$ 是精确的或理论的预报误差协方差。因此，预报集合成员 $x_{f}^{(i)}$ 是来自分布 $\\mathcal{N}(0, \\Sigma_{f})$ 的独立样本。\n\n要实现的算法遵循一系列明确定义的步骤，以通过数值模拟来验证这一理论结果。\n\n1.  **生成分析集合 $\\{x_{a}^{(i)}\\}_{i=1}^{N}$**：为了从 $\\mathcal{N}(0, P^{a})$ 中抽取样本，我们首先找到一个矩阵 $L_{a}$ 使得 $P^{a} = L_{a} L_{a}^{\\top}$。Cholesky 分解提供了这样一个下三角矩阵 $L_{a}$，前提是 $P^{a}$ 是对称且正定的。然后我们从标准多元正态分布中生成 $N$ 个独立样本 $\\zeta^{(i)}$，$\\zeta^{(i)} \\sim \\mathcal{N}(0, I_{d})$，其中 $I_{d}$ 是 $d \\times d$ 的单位矩阵。每个分析集合成员则通过变换 $x_{a}^{(i)} = L_{a} \\zeta^{(i)}$ 形成。\n\n2.  **采样过程噪声 $\\{w^{(i)}\\}_{i=1}^{N}$**：这一步与第一步类似。我们计算过程噪声协方差矩阵的 Cholesky 分解，$Q = L_{q} L_{q}^{\\top}$。然后我们生成另一组 $N$ 个独立的标准正态向量 $\\xi^{(i)} \\sim \\mathcal{N}(0, I_{d})$ 并计算噪声样本为 $w^{(i)} = L_{q} \\xi^{(i)}$。\n\n3.  **构建预报集合 $\\{x_{f}^{(i)}\\}_{i=1}^{N}$**：通过将模型动力学应用于相应的分析成员来计算每个预报成员：$x_{f}^{(i)} = \\Phi x_{a}^{(i)} + w^{(i)}$。\n\n4.  **计算经验预报协方差 $\\hat{P}^{f}$**：从生成的预报集合中，我们估计协方差。无偏样本协方差矩阵由下式给出：\n    $$\n    \\hat{P}^{f} = \\frac{1}{N-1}\\sum_{i=1}^{N}\\left(x_{f}^{(i)} - \\bar{x}_{f}\\right)\\left(x_{f}^{(i)} - \\bar{x}_{f}\\right)^{\\top}\n    $$\n    其中 $\\bar{x}_{f} = \\frac{1}{N}\\sum_{i=1}^{N} x_{f}^{(i)}$ 是预报集合的样本均值。\n\n5.  **计算理论预报协方差 $\\Sigma_{f}$**：这是使用推导出的公式直接从给定的矩阵计算出来的：$\\Sigma_{f} = \\Phi P^{a} \\Phi^{\\top} + Q$。\n\n6.  **比较经验结果和理论结果**：样本协方差 $\\hat{P}^{f}$ 和真实协方差 $\\Sigma_{f}$ 之间的差异是抽样误差的结果。这个误差通过两种方式量化。首先，直接差异由差异的 Frobenius 范数来衡量：$\\Delta = \\lVert \\hat{P}^{f} - \\Sigma_{f} \\rVert_{F}$。其次，基于 Wishart 分布（样本协方差的抽样分布）的性质，计算均方根 (RMS) 抽样误差的理论估计。期望平方误差由 $\\mathbb{E}\\left[\\lVert \\hat{P}^{f} - \\Sigma_{f} \\rVert_{F}^{2}\\right] = \\frac{1}{N-1}\\left(\\lVert \\Sigma_{f} \\rVert_{F}^{2} + (\\operatorname{tr}\\Sigma_{f})^{2}\\right)$ 给出。RMS 误差是该量的平方根：\n    $$\n    \\varepsilon_{\\mathrm{RMS}} = \\sqrt{\\frac{\\lVert \\Sigma_{f} \\rVert_{F}^{2} + (\\operatorname{tr}\\Sigma_{f})^{2}}{N-1}}\n    $$\n    如果观测到的差异 $\\Delta$ 在这个预期统计误差的合理倍数之内，则认为测试用例通过。问题将此标准指定为 $\\Delta \\leq c \\, \\varepsilon_{\\mathrm{RMS}}$，容差因子 $c = 3$，这类似于一个 \"3-sigma\" 置信区间。此检查确认了模拟的行为与统计理论预测的一致。为保证可复现性，伪随机数生成器为每个测试用例设置了固定的种子值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the stochastic forecast step verification.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"d\": 3, \"N\": 400, \"seed\": 0,\n            \"Phi\": np.array([\n                [0.9, 0.1, 0.0],\n                [0.0, 0.7, 0.2],\n                [0.0, 0.0, 0.8]\n            ]),\n            \"Pa\": np.array([\n                [0.5, 0.1, 0.0],\n                [0.1, 0.4, 0.05],\n                [0.0, 0.05, 0.3]\n            ]),\n            \"Q\": np.array([\n                [0.2, 0.05, 0.0],\n                [0.05, 0.1, 0.02],\n                [0.0, 0.02, 0.15]\n            ])\n        },\n        {\n            \"d\": 1, \"N\": 200, \"seed\": 1,\n            \"Phi\": np.array([[1.2]]),\n            \"Pa\": np.array([[0.25]]),\n            \"Q\": np.array([[0.5]])\n        },\n        {\n            \"d\": 5, \"N\": 2000, \"seed\": 2,\n            \"Phi\": np.array([\n                [0.6, 0.2, 0.0, 0.0, 0.0],\n                [0.0, 0.7, 0.1, 0.0, 0.0],\n                [0.0, 0.0, 0.5, 0.2, 0.0],\n                [0.0, 0.0, 0.0, 0.65, 0.1],\n                [0.0, 0.0, 0.0, 0.0, 0.55]\n            ]),\n            \"Pa\": np.array([\n                [1.0, 0.1, 0.0, 0.0, 0.0],\n                [0.1, 0.8, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.6, 0.05, 0.0],\n                [0.0, 0.0, 0.05, 0.7, 0.0],\n                [0.0, 0.0, 0.0, 0.0, 0.9]\n            ]),\n            \"Q\": np.array([\n                [0.3, 0.04, 0.0, 0.0, 0.0],\n                [0.04, 0.25, 0.03, 0.0, 0.0],\n                [0.0, 0.03, 0.2, 0.02, 0.0],\n                [0.0, 0.0, 0.02, 0.15, 0.01],\n                [0.0, 0.0, 0.0, 0.01, 0.35]\n            ])\n        },\n        {\n            \"d\": 4, \"N\": 30, \"seed\": 3,\n            \"Phi\": np.array([\n                [0.85, 0.1, 0.0, 0.0],\n                [0.0, 0.75, 0.15, 0.0],\n                [0.0, 0.0, 0.65, 0.1],\n                [0.0, 0.0, 0.0, 0.7]\n            ]),\n            \"Pa\": np.array([\n                [0.6, 0.05, 0.0, 0.0],\n                [0.05, 0.5, 0.04, 0.0],\n                [0.0, 0.04, 0.4, 0.03],\n                [0.0, 0.0, 0.03, 0.45]\n            ]),\n            \"Q\": np.array([\n                [0.25, 0.03, 0.0, 0.0],\n                [0.03, 0.2, 0.02, 0.0],\n                [0.0, 0.02, 0.18, 0.01],\n                [0.0, 0.0, 0.01, 0.22]\n            ])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        d, N, seed = case[\"d\"], case[\"N\"], case[\"seed\"]\n        Phi, Pa, Q = case[\"Phi\"], case[\"Pa\"], case[\"Q\"]\n        ma = np.zeros(d)\n        \n        # Initialize the random number generator with a fixed seed for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # 1. Generate an analysis ensemble {x_a^(i)} from N(0, Pa)\n        La = np.linalg.cholesky(Pa)\n        zeta = rng.standard_normal(size=(d, N))\n        xa_ensemble = La @ zeta # Each column is a sample x_a^(i)\n\n        # 2. Sample independent process noises {w^(i)} from N(0, Q)\n        Lq = np.linalg.cholesky(Q)\n        xi = rng.standard_normal(size=(d, N))\n        w_ensemble = Lq @ xi # Each column is a sample w^(i)\n\n        # 3. Form forecast ensemble members\n        xf_ensemble = Phi @ xa_ensemble + w_ensemble\n\n        # 4. Compute the unbiased sample covariance of the forecast ensemble\n        # np.cov computes the unbiased covariance by default (ddof=1)\n        P_f_hat = np.cov(xf_ensemble)\n\n        # 5. Compute the theoretical forecast covariance\n        Sigma_f = Phi @ Pa @ Phi.T + Q\n\n        # 6. Compute discrepancy and RMS sampling error\n        # Frobenius-norm discrepancy\n        Delta = np.linalg.norm(P_f_hat - Sigma_f, 'fro')\n\n        # RMS sampling error predicted by Wishart theory\n        norm_Sigma_f_sq = np.linalg.norm(Sigma_f, 'fro')**2\n        tr_Sigma_f_sq = np.trace(Sigma_f)**2\n        eps_rms = np.sqrt((norm_Sigma_f_sq + tr_Sigma_f_sq) / (N - 1))\n\n        # Declare pass if Delta is within 3 * eps_rms\n        c = 3\n        passes = Delta = c * eps_rms\n        results.append(passes)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在分析步骤中，正确生成观测扰动是随机集合卡尔曼滤波器的成败关键。此练习通过一个精心设计的思想实验，揭示了忽略观测误差相关性所带来的后果。您将分析在一个假设情景下，使用不正确的对角协方差生成扰动，会如何导致集合新息协方差的估计出现偏差 。这个练习强调了准确再现观测误差完整协方差结构（包括非对角线项）的重要性。",
            "id": "3422876",
            "problem": "考虑一个带有扰动观测的随机集合卡尔曼滤波 (EnKF) 的二维线性高斯数据同化设置。设观测算子为单位矩阵，$H = I_{2}$，并假设预报集合的离差为零，即对于所有集合成员 $i$，都有 $x_{f}^{(i)} = \\bar{x}_{f}$，因此预报集合的异常值恒为零。设观测误差为高斯分布，其均值为零，协方差为非对角矩阵\n$$\nR = \\begin{pmatrix} 2  1.2 \\\\ 1.2  1 \\end{pmatrix}.\n$$\n在带有扰动观测的随机 EnKF 中，每个集合成员的新息是通过使用一个合成的观测扰动 $\\eta^{(i)}$ 构成的。无偏情况要求通过一个矩阵 $L$（例如 Cholesky 因子），将标准正态噪声 $\\xi^{(i)} \\sim \\mathcal{N}(0, I_{2})$ 进行线性变换来抽取 $\\eta^{(i)}$，使得 $L L^{\\top} = R$。一个常见的错误做法是忽略 $R$ 的非对角线元素，并使用 $D = \\mathrm{diag}(\\sqrt{2}, 1)$ 来抽取 $\\eta^{(i)} = D \\xi^{(i)}$，这样 $\\mathrm{cov}(\\eta^{(i)}) = \\mathrm{diag}(2, 1)$。\n\n仅使用协方差的基本定义、高斯随机向量线性变换的性质，以及使用因子 $1/(N-1)$ 的无偏样本协方差是总体协方差的无偏估计量这一事实，推导在上述错误做法下集合新息协方差的期望 $(1,2)$ 元素，并计算其相对于由 $R$ 所隐含的正确 $(1,2)$ 元素的偏差。\n\n将您的最终答案表述为 $(1,2)$ 元素的期望偏差（错误值减去正确值），形式为一个实数，四舍五入到四位有效数字。将此量视为无量纲。",
            "solution": "本题要求计算在随机集合卡尔曼滤波 (EnKF) 中，因生成观测扰动的不正确过程而产生的集合新息协方差矩阵 $(1,2)$ 元素的偏差。偏差定义为不正确元素的期望值减去正确值。\n\n首先，我们对涉及的量进行形式化。数据同化在二维空间中进行。观测算子是单位矩阵，$H = I_{2}$。真实的观测误差协方差由以下矩阵给出\n$$\nR = \\begin{pmatrix} 2  1.2 \\\\ 1.2  1 \\end{pmatrix}.\n$$\n一个关键条件是预报集合的离差为零，即所有集合成员都与集合均值相同：对于所有成员 $i = 1, \\dots, N$，都有 $x_{f}^{(i)} = \\bar{x}_{f}$。这意味着预报集合的异常值 $x_{f}^{(i)} - \\bar{x}_{f}$ 都是零向量，因此，预报集合协方差矩阵 $P_{f}^{e}$ 是零矩阵，$P_{f}^{e} = 0$。\n\n在带有扰动观测的随机 EnKF 中，每个集合成员都使用一个合成观测 $y^{(i)}$ 进行更新，该合成观测是通过将随机扰动 $\\eta^{(i)}$ 加到实际观测 $y$ 上创建的。因此，$y^{(i)} = y + \\eta^{(i)}$。第 $i$ 个集合成员的新息 $d^{(i)}$ 定义为其合成观测与其投影预报之间的差：\n$$\nd^{(i)} = y^{(i)} - H x_{f}^{(i)}.\n$$\n给定 $H = I_{2}$ 和 $x_{f}^{(i)} = \\bar{x}_{f}$，这变为：\n$$\nd^{(i)} = (y + \\eta^{(i)}) - I_{2} \\bar{x}_{f} = y - \\bar{x}_{f} + \\eta^{(i)}.\n$$\n集合新息协方差，我们记作 $S^e$，是这些新息向量的样本协方差。其计算公式为：\n$$\nS^e = \\frac{1}{N-1} \\sum_{i=1}^{N} (d^{(i)} - \\bar{d})(d^{(i)} - \\bar{d})^T,\n$$\n其中 $\\bar{d}$ 是新息集合的均值。平均新息为：\n$$\n\\bar{d} = \\frac{1}{N} \\sum_{i=1}^{N} d^{(i)} = \\frac{1}{N} \\sum_{i=1}^{N} (y - \\bar{x}_{f} + \\eta^{(i)}) = y - \\bar{x}_{f} + \\frac{1}{N} \\sum_{i=1}^{N} \\eta^{(i)} = y - \\bar{x}_{f} + \\bar{\\eta},\n$$\n其中 $\\bar{\\eta}$ 是扰动的样本均值。\n\n现在，我们可以求出成员 $i$ 的新息异常值：\n$$\nd^{(i)} - \\bar{d} = (y - \\bar{x}_{f} + \\eta^{(i)}) - (y - \\bar{x}_{f} + \\bar{\\eta}) = \\eta^{(i)} - \\bar{\\eta}.\n$$\n将此代回 $S^e$ 的公式，我们发现由于预报离差为零，集合新息协方差恰好是观测扰动的样本协方差：\n$$\nS^e = \\frac{1}{N-1} \\sum_{i=1}^{N} (\\eta^{(i)} - \\bar{\\eta})(\\eta^{(i)} - \\bar{\\eta})^T.\n$$\n问题要求计算该矩阵 $(1,2)$ 元素的期望值 $E[(S^e)_{1,2}]$。由于期望是线性算子，这等于 $(E[S^e])_{1,2}$。题目陈述中给出了一个事实，即使用因子 $1/(N-1)$ 计算的样本协方差是总体协方差的无偏估计量。因此，样本协方差矩阵 $S^e$ 的期望值是随机向量 $\\eta^{(i)}$ 的总体协方差：\n$$\nE[S^e] = \\mathrm{cov}(\\eta^{(i)}).\n$$\n所描述的“不正确做法”包括从一个忽略 $R$ 非对角线元素的分布中抽取扰动 $\\eta^{(i)}$。具体来说，$\\eta^{(i)} = D \\xi^{(i)}$，其中 $\\xi^{(i)} \\sim \\mathcal{N}(0, I_{2})$ 且 $D = \\mathrm{diag}(\\sqrt{2}, 1)$。这些不正确扰动的协方差为：\n$$\n\\mathrm{cov}(\\eta^{(i)}) = E[\\eta^{(i)}(\\eta^{(i)})^T] = E[D \\xi^{(i)} (\\xi^{(i)})^T D^T] = D E[\\xi^{(i)}(\\xi^{(i)})^T] D^T = D I_{2} D^T = D^2.\n$$\n计算 $D^2$：\n$$\nD^2 = \\begin{pmatrix} \\sqrt{2}  0 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} \\sqrt{2}  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 2  0 \\\\ 0  1 \\end{pmatrix}.\n$$\n因此，在不正确的做法下，期望的集合新息协方差为：\n$$\nE[S^{e}_{\\text{incorrect}}] = \\begin{pmatrix} 2  0 \\\\ 0  1 \\end{pmatrix}.\n$$\n因此，期望的 $(1,2)$ 元素为 $(E[S^{e}_{\\text{incorrect}}])_{1,2} = 0$。\n\n接下来，我们确定“由 $R$ 隐含的正确 $(1,2)$ 元素”。在 EnKF 中，集合新息协方差 $S^e$ 作为理论新息协方差 $S_{\\text{theory}} = H P_f H^T + R$ 的估计，其中 $P_f$ 是真实的预报误差协方差。鉴于预报集合的离差为零 ($P_f^e = 0$)，预报误差协方差 $P_f$ 实际上为零。因此，$S_{\\text{theory}} = R$。正确的实现会从 $\\mathcal{N}(0,R)$ 生成扰动，并且由此产生的 $S^e$ 的期望值将是 $R$。因此，期望新息协方差的 $(1,2)$ 元素的正确值是 $R$ 的 $(1,2)$ 元素。\n根据 $R$ 的定义，正确的值是 $R_{1,2} = 1.2$。\n\n最后，我们计算偏差，定义为不正确的值减去正确的值：\n$$\n\\text{Bias} = (E[S^{e}_{\\text{incorrect}}])_{1,2} - R_{1,2} = 0 - 1.2 = -1.2.\n$$\n题目要求答案四舍五入到四位有效数字。数值 $-1.2$ 用四位有效数字表示为 $-1.200$。",
            "answer": "$$\\boxed{-1.200}$$"
        },
        {
            "introduction": "由于集合规模有限，集合滤波器会不可避免地产生采样误差，尤其是在高维系统中，这可能导致虚假的远距离相关。协方差局地化是解决此问题的标准技术。在此练习中，您将动手构建被广泛使用的Gaspari-Cohn局地化函数，并计算不同局地化半径下的函数值 。通过这种方式，您将直观地理解局地化半径这一关键参数是如何调节观测信息在空间上的影响范围的。",
            "id": "3422897",
            "problem": "考虑一个定义在间距为 $\\Delta x$ 的均匀网格上的一维离散化状态变量。在随机集合卡尔曼滤波器 (EnKF) 中（也称为带扰动观测的集合卡尔曼滤波器），预报（背景）协方差中的采样误差通过协方差局地化来减小。协方差局地化通过将预报协方差矩阵的元素与一个仅依赖于两点之间空间距离 $d$ 的紧支集相关函数 $C(d)$ 进行逐元素相乘来实现。Gaspari–Cohn 局地化函数被广泛用于此目的，它被构造成紧支集、二次连续可微，并且在零距离处等于 $1$。\n\n从基于集合的数据同化中协方差局地化的目标出发，为一维网格构造 Gaspari–Cohn 函数 $C(d;r)$，它应是归一化距离 $z=d/r$ 的函数，其中 $r$ 是用户选择的局地化半径。然后，对于网格距离 $d \\in \\{0,\\Delta x,2\\Delta x,3\\Delta x,4\\Delta x\\}$，计算在两种局地化半径选择下 $C(d;r)$ 的值：$r_{1}=2\\Delta x$ 和 $r_{2}=\\Delta x$。使用这些值，构造比值\n$$\nS = \\frac{\\sum_{d \\in \\{0,\\Delta x,2\\Delta x,3\\Delta x,4\\Delta x\\}} C(d;r_{1})}{\\sum_{d \\in \\{0,\\Delta x,2\\Delta x,3\\Delta x,4\\Delta x\\}} C(d;r_{2})}.\n$$\n使用带扰动观测的 EnKF 更新过程，简要解释 $r$ 的选择如何通过局地化增益影响分析增量。将 $S$ 的最终数值结果表示为一个无单位的最简分数。",
            "solution": "第一步是构造 Gaspari–Cohn 局地化函数。该函数是一个分段多项式，被设计为紧支集且二次连续可微 ($C^2$)。它是根据归一化距离 $z = d/r$ 定义的，其中 $d$ 是两点之间的物理距离，而 $r$ 是用户定义的局地化半径。该函数在 $d \\in [-2r, 2r]$ 上具有紧支集，对应于 $z \\in [-2, 2]$。由于相关函数依赖于距离 $d$，我们只需考虑 $z = |d|/r \\in [0, 2]$。标准的五阶 Gaspari–Cohn 函数 $C(z)$ 由下式给出：\n\n$$\nC(z) = \\begin{cases}\n-\\frac{1}{4}z^5 + \\frac{1}{2}z^4 + \\frac{5}{8}z^3 - \\frac{5}{3}z^2 + 1  \\text{for } 0 \\le z \\le 1 \\\\\n\\frac{1}{12}z^5 - \\frac{1}{2}z^4 + \\frac{5}{8}z^3 + \\frac{5}{3}z^2 - 5z + 4 - \\frac{2}{3}z^{-1}  \\text{for } 1  z \\le 2 \\\\\n0  \\text{for } z > 2\n\\end{cases}\n$$\n\n该函数满足 $C(0) = 1$，并且 $C(z)$ 及其前两个导数在 $z=2$ 处为零。该函数及其前两个导数在 $z=1$ 处也连续。\n\n接下来，我们计算在指定的距离和局地化半径下 $C(d;r)$ 的值。距离集合为 $d \\in \\{0, \\Delta x, 2\\Delta x, 3\\Delta x, 4\\Delta x\\}$。\n\n情况1：局地化半径 $r_1 = 2\\Delta x$。\n归一化距离为 $z_1 = d/r_1 = d/(2\\Delta x)$。函数的支集为 $d \\le 2r_1 = 4\\Delta x$，这意味着当 $d > 4\\Delta x$ 时，$C(d;r_1)=0$。\n\n对于 $d=0$：$z_1 = 0$。$C(0; r_1) = C(0) = 1$。\n对于 $d=\\Delta x$：$z_1 = \\frac{\\Delta x}{2\\Delta x} = \\frac{1}{2}$。这落在 $0 \\le z \\le 1$ 的范围内。\n$C(\\Delta x; r_1) = C(\\frac{1}{2}) = -\\frac{1}{4}(\\frac{1}{2})^5 + \\frac{1}{2}(\\frac{1}{2})^4 + \\frac{5}{8}(\\frac{1}{2})^3 - \\frac{5}{3}(\\frac{1}{2})^2 + 1$\n$= -\\frac{1}{4}(\\frac{1}{32}) + \\frac{1}{2}(\\frac{1}{16}) + \\frac{5}{8}(\\frac{1}{8}) - \\frac{5}{3}(\\frac{1}{4}) + 1$\n$= -\\frac{1}{128} + \\frac{1}{32} + \\frac{5}{64} - \\frac{5}{12} + 1 = \\frac{-1+4+10}{128} - \\frac{5}{12} + 1 = \\frac{13}{128} - \\frac{5}{12} + 1$\n使用公分母 $384$：$\\frac{39 - 160 + 384}{384} = \\frac{263}{384}$。\n\n对于 $d=2\\Delta x$：$z_1 = \\frac{2\\Delta x}{2\\Delta x} = 1$。这位于两个多项式分段的边界处。使用第一段公式：\n$C(2\\Delta x; r_1) = C(1) = -\\frac{1}{4}(1)^5 + \\frac{1}{2}(1)^4 + \\frac{5}{8}(1)^3 - \\frac{5}{3}(1)^2 + 1$\n$= -\\frac{1}{4} + \\frac{1}{2} + \\frac{5}{8} - \\frac{5}{3} + 1 = \\frac{-6+12+15-40+24}{24} = \\frac{5}{24}$。\n\n对于 $d=3\\Delta x$：$z_1 = \\frac{3\\Delta x}{2\\Delta x} = \\frac{3}{2}$。这落在 $1  z \\le 2$ 的范围内。\n$C(3\\Delta x; r_1) = C(\\frac{3}{2}) = \\frac{1}{12}(\\frac{3}{2})^5 - \\frac{1}{2}(\\frac{3}{2})^4 + \\frac{5}{8}(\\frac{3}{2})^3 + \\frac{5}{3}(\\frac{3}{2})^2 - 5(\\frac{3}{2}) + 4 - \\frac{2}{3}(\\frac{3}{2})^{-1}$\n$= \\frac{1}{12}\\frac{243}{32} - \\frac{1}{2}\\frac{81}{16} + \\frac{5}{8}\\frac{27}{8} + \\frac{5}{3}\\frac{9}{4} - \\frac{15}{2} + 4 - \\frac{4}{9}$\n$= \\frac{81}{128} - \\frac{81}{32} + \\frac{135}{64} + \\frac{15}{4} - \\frac{15}{2} + 4 - \\frac{4}{9}$\n$= \\frac{81 - 324 + 270}{128} + \\frac{15}{4} - \\frac{30}{4} + \\frac{16}{4} - \\frac{4}{9} = \\frac{27}{128} + \\frac{1}{4} - \\frac{4}{9}$\n使用公分母 $1152$：$\\frac{243 + 288 - 512}{1152} = \\frac{19}{1152}$。\n\n对于 $d=4\\Delta x$：$z_1 = \\frac{4\\Delta x}{2\\Delta x} = 2$。$C(4\\Delta x; r_1) = C(2) = 0$。\n\n$r_1$ 的和为：\n$\\sum C(d;r_1) = 1 + \\frac{263}{384} + \\frac{5}{24} + \\frac{19}{1152} + 0$\n使用公分母 $1152$：\n$\\sum C(d;r_1) = \\frac{1152}{1152} + \\frac{3 \\times 263}{1152} + \\frac{48 \\times 5}{1152} + \\frac{19}{1152} = \\frac{1152 + 789 + 240 + 19}{1152} = \\frac{2200}{1152} = \\frac{275}{144}$。\n\n情况2：局地化半径 $r_2 = \\Delta x$。\n归一化距离为 $z_2 = d/r_2 = d/\\Delta x$。支集为 $d \\le 2r_2 = 2\\Delta x$。\n\n对于 $d=0$：$z_2 = 0$。$C(0; r_2) = C(0) = 1$。\n对于 $d=\\Delta x$：$z_2 = \\frac{\\Delta x}{\\Delta x} = 1$。$C(\\Delta x; r_2) = C(1) = \\frac{5}{24}$。\n对于 $d=2\\Delta x$：$z_2 = \\frac{2\\Delta x}{\\Delta x} = 2$。$C(2\\Delta x; r_2) = C(2) = 0$。\n对于 $d=3\\Delta x$：$z_2 = 3 > 2$。$C(3\\Delta x; r_2) = 0$。\n对于 $d=4\\Delta x$：$z_2 = 4 > 2$。$C(4\\Delta x; r_2) = 0$。\n\n$r_2$ 的和为：\n$\\sum C(d;r_2) = 1 + \\frac{5}{24} + 0 + 0 + 0 = \\frac{29}{24}$。\n\n最后，我们计算比值 $S$：\n$$\nS = \\frac{\\sum_{d} C(d;r_1)}{\\sum_{d} C(d;r_2)} = \\frac{275/144}{29/24} = \\frac{275}{144} \\times \\frac{24}{29}\n$$\n由于 $144 = 6 \\times 24$，我们有：\n$$\nS = \\frac{275}{6 \\times 29} = \\frac{275}{174}\n$$\n这个分数是不可约的。\n\n局地化半径 $r$ 的选择决定了观测的空间影响范围。在 EnKF 更新中，分析状态 $\\mathbf{x}^a$ 是通过分析增量从预报状态 $\\mathbf{x}^f$ 计算得出的：$\\mathbf{x}^a = \\mathbf{x}^f + \\mathbf{K}_{loc}(\\mathbf{y} - \\mathbf{H}\\mathbf{x}^f)$，其中 $\\mathbf{y}$ 是观测向量，$\\mathbf{H}$ 是观测算子。局地化卡尔曼增益 $\\mathbf{K}_{loc}$ 是使用一个预报误差协方差矩阵 $\\mathbf{P}^f_{loc}$ 计算的，该矩阵的元素通过局地化函数进行调节（锥削）：$(\\mathbf{P}^f_{loc})_{ij} = C(d_{ij}; r) \\times (\\mathbf{P}^f_e)_{ij}$，其中 $\\mathbf{P}^f_e$ 是来自集合的样本协方差。\n\n因此，网格点 $i$ 处的分析增量（由网格点 $j$ 处的观测引起）与这两点之间的局地化协方差成正比，而局地化协方差本身又与 $C(d_{ij}; r)$ 成正比。较小的半径 $r$（如 $r_2=\\Delta x$）会导致一个峰值尖锐且迅速衰减到零的局地化函数。这意味着一次观测仅对其紧邻区域的网格点提供显著的更新。较大的半径 $r$（如 $r_1=2\\Delta x$）会导致一个更宽的局地化函数，允许一次观测的影响扩展到更宽的空间区域，从而更新更远的网格点。$r$ 的值必须仔细选择，以便在滤除虚假的长程相关性的同时，保留具有物理意义的短程相关性。",
            "answer": "$$\\boxed{\\frac{275}{174}}$$"
        }
    ]
}