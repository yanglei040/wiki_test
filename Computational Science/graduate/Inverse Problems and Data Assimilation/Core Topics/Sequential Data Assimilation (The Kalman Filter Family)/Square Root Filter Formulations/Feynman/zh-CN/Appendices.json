{
    "hands_on_practices": [
        {
            "introduction": "该练习聚焦于集合变换卡尔曼滤波（ETKF）的核心机制。通过一个具体的小规模算例，您将亲手构建集合空间中平方根更新的各个基本要素，包括计算变换矩阵 $T$ 和更新预报异常。这项基础实践是理解平方根滤波器如何在保持集合一致性的同时减少不确定性的关键。",
            "id": "3420585",
            "problem": "考虑一个线性的、高斯的数据同化设置，其状态向量维度为 $n = 3$，观测维度为 $p = 3$，以及一个包含 $m = 4$ 个成员的集合。观测算子为单位矩阵 $H = I_{3}$，观测误差协方差为 $R = I_{3}$。给定预报异常矩阵 $A^{f} \\in \\mathbb{R}^{3 \\times 4}$（其列为集合成员相对于预报均值的异常）如下：\n$$\nA^{f} = \\sqrt{3}\n\\begin{bmatrix}\n1  0  0  -1 \\\\\n0  1  0  -1 \\\\\n0  0  1  -1\n\\end{bmatrix}.\n$$\n假设使用集合变换卡尔曼滤波（ETKF）的平方根滤波公式，在集合空间中进行归一化异常和观测白化处理。\n\n利用卡尔曼滤波的基本性质和集合空间平方根的构造，执行以下步骤：\n- 构建归一化预报异常 $X^{f} = A^{f} / \\sqrt{m - 1}$ 和白化投影异常 $\\tilde{S} = R^{-1/2} H X^{f}$。\n- 使用白化空间中卡尔曼更新所隐含的集合空间后验协方差 $\\tilde{P}^{a}$，构造对称平方根变换 $T = (\\tilde{P}^{a})^{1/2}$。\n- 通过 ETKF 变换更新预报异常，以获得分析异常 $A^{a} = A^{f} T$。\n\n最后，计算分析异常矩阵 $A^{a}$ 的弗罗贝尼乌斯范数的平方，其定义为 $||A^{a}||_{F}^{2} = \\operatorname{tr}\\big((A^{a})^{\\top} A^{a}\\big)$，并给出其精确值。无需四舍五入，也无需物理单位。您的最终答案必须是一个实数。",
            "solution": "通过遵循指定程序，对用户提供的问题进行了严格验证。\n\n### 步骤1：提取已知条件\n- 状态向量维度：$n = 3$\n- 观测维度：$p = 3$\n- 集合大小：$m = 4$\n- 观测算子：$H = I_{3}$（$3 \\times 3$ 的单位矩阵）\n- 观测误差协方差：$R = I_{3}$（$3 \\times 3$ 的单位矩阵）\n- 预报异常矩阵：$A^{f} = \\sqrt{3} \\begin{bmatrix} 1  0  0  -1 \\\\ 0  1  0  -1 \\\\ 0  0  1  -1 \\end{bmatrix}$，维度为 $n \\times m$（$3 \\times 4$）。\n- 滤波公式：在集合空间中使用归一化异常和观测白化的集合变换卡尔曼滤波（ETKF）。\n- 要求计算：分析异常矩阵 $A^{a}$ 的弗罗贝尼乌斯范数的平方，定义为 $||A^{a}||_{F}^{2} = \\operatorname{tr}\\big((A^{a})^{\\top} A^{a}\\big)$。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据：** 该问题建立在数据同化的既定数学框架内，特别是使用集合卡尔曼滤波，这是地球物理科学、工程和其他领域的标准方法。该公式与有关平方根滤波的公认文献（例如，由 Bishop 等人于 2001 年提出的 ETKF）一致。所有组成部分在数学上都是合理的。\n- **适定性：** 问题定义清晰，提供了所有必要的矩阵和参数。目标明确：计算一个特定的标量值。该结构保证了唯一解。\n- **客观性：** 问题使用精确的数学术语和符号陈述，没有任何主观或模棱两可的语言。\n\n### 步骤3：结论与行动\n该问题具有科学依据、适定、客观且自洽。这是应用集合数据同化原理的一个有效练习。因此，将提供一个解答。\n\n### 解答推导\n目标是计算分析异常矩阵的弗罗贝尼乌斯范数的平方，$||A^{a}||_{F}^{2}$。分析异常 $A^a$ 是通过使用变换矩阵 $T$ 变换预报异常 $A^f$ 得到的。\n\n首先，我们按照规定的步骤来定义 ETKF 更新的各个组成部分。集合成员的数量为 $m=4$。归一化预报异常矩阵 $X^{f}$ 定义为：\n$$\nX^{f} = \\frac{A^{f}}{\\sqrt{m-1}} = \\frac{1}{\\sqrt{3}} \\left( \\sqrt{3} \\begin{bmatrix} 1  0  0  -1 \\\\ 0  1  0  -1 \\\\ 0  0  1  -1 \\end{bmatrix} \\right) = \\begin{bmatrix} 1  0  0  -1 \\\\ 0  1  0  -1 \\\\ 0  0  1  -1 \\end{bmatrix}\n$$\n接下来，我们构造白化投影异常 $\\tilde{S}$。给定观测算子 $H = I_{3}$ 和观测误差协方差 $R = I_{3}$，我们有 $R^{-1/2} = (I_{3})^{-1/2} = I_{3}$。\n$$\n\\tilde{S} = R^{-1/2} H X^{f} = I_{3} \\cdot I_{3} \\cdot X^{f} = X^{f} = \\begin{bmatrix} 1  0  0  -1 \\\\ 0  1  0  -1 \\\\ 0  0  1  -1 \\end{bmatrix}\n$$\nETKF 使用变换矩阵 $T$ 更新预报异常，使得 $A^{a} = A^{f} T$。矩阵 $T$ 是白化集合空间中后验协方差 $\\tilde{P}^{a}$ 的对称平方根。\n$$\nT = (\\tilde{P}^{a})^{1/2}\n$$\n其中\n$$\n\\tilde{P}^{a} = (I_{m} + \\tilde{S}^{\\top} \\tilde{S})^{-1}\n$$\n此处，$I_m$ 是大小为 $m \\times m$（即 $4 \\times 4$）的单位矩阵。弗罗贝尼乌斯范数的平方由 $(A^{a})^{\\top} A^{a}$ 的迹给出。\n$$\n||A^{a}||_{F}^{2} = \\operatorname{tr}\\big((A^{a})^{\\top} A^{a}\\big) = \\operatorname{tr}\\big((A^{f} T)^{\\top} (A^{f} T)\\big) = \\operatorname{tr}\\big(T^{\\top} (A^{f})^{\\top} A^{f} T\\big)\n$$\n由于 $T$ 是对称的（$T^{\\top} = T$），并利用迹算子的循环性质（$\\operatorname{tr}(ABC) = \\operatorname{tr}(BCA)$），我们可以写出：\n$$\n||A^{a}||_{F}^{2} = \\operatorname{tr}\\big((A^{f})^{\\top} A^{f} T^{2}\\big)\n$$\n根据定义，$T^{2} = ((\\tilde{P}^{a})^{1/2})^{2} = \\tilde{P}^{a} = (I_{m} + \\tilde{S}^{\\top} \\tilde{S})^{-1}$。将此代入范数的方程中：\n$$\n||A^{a}||_{F}^{2} = \\operatorname{tr}\\big((A^{f})^{\\top} A^{f} (I_{m} + \\tilde{S}^{\\top} \\tilde{S})^{-1}\\big)\n$$\n我们可以将 $(A^{f})^{\\top} A^{f}$ 与 $\\tilde{S}^{\\top} \\tilde{S}$ 联系起来。根据定义 $A^{f} = \\sqrt{m-1} X^{f}$，且对于本问题 $\\tilde{S} = X^{f}$，我们有 $A^{f} = \\sqrt{m-1} \\tilde{S}$。\n$$\n(A^{f})^{\\top} A^{f} = (\\sqrt{m-1} \\tilde{S})^{\\top} (\\sqrt{m-1} \\tilde{S}) = (m-1) \\tilde{S}^{\\top} \\tilde{S}\n$$\n代入此式可得到一个更简洁的范数表达式：\n$$\n||A^{a}||_{F}^{2} = \\operatorname{tr}\\big((m-1) \\tilde{S}^{\\top} \\tilde{S} (I_{m} + \\tilde{S}^{\\top} \\tilde{S})^{-1}\\big) = (m-1) \\operatorname{tr}\\big(\\tilde{S}^{\\top} \\tilde{S} (I_{m} + \\tilde{S}^{\\top} \\tilde{S})^{-1}\\big)\n$$\n令 $K = \\tilde{S}^{\\top} \\tilde{S}$。我们使用矩阵恒等式 $K(I+K)^{-1} = (I+K-I)(I+K)^{-1} = I - (I+K)^{-1}$。\n$$\n||A^{a}||_{F}^{2} = (m-1) \\operatorname{tr}\\big(I_{m} - (I_{m} + \\tilde{S}^{\\top} \\tilde{S})^{-1}\\big) = (m-1) \\Big(\\operatorname{tr}(I_{m}) - \\operatorname{tr}\\big((I_{m} + \\tilde{S}^{\\top} \\tilde{S})^{-1}\\big)\\Big)\n$$\n现在，我们计算必要的矩阵。首先是 $\\tilde{S}^{\\top} \\tilde{S}$：\n$$\n\\tilde{S}^{\\top} \\tilde{S} = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\\\ -1  -1  -1 \\end{bmatrix} \\begin{bmatrix} 1  0  0  -1 \\\\ 0  1  0  -1 \\\\ 0  0  1  -1 \\end{bmatrix} = \\begin{bmatrix} 1  0  0  -1 \\\\ 0  1  0  -1 \\\\ 0  0  1  -1 \\\\ -1  -1  -1  3 \\end{bmatrix}\n$$\n接下来，我们计算 $I_{4} + \\tilde{S}^{\\top} \\tilde{S}$：\n$$\nI_{4} + \\tilde{S}^{\\top} \\tilde{S} = \\begin{bmatrix} 1  0  0  0 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  1 \\end{bmatrix} + \\begin{bmatrix} 1  0  0  -1 \\\\ 0  1  0  -1 \\\\ 0  0  1  -1 \\\\ -1  -1  -1  3 \\end{bmatrix} = \\begin{bmatrix} 2  0  0  -1 \\\\ 0  2  0  -1 \\\\ 0  0  2  -1 \\\\ -1  -1  -1  4 \\end{bmatrix}\n$$\n设该矩阵为 $M$。我们需要计算其逆矩阵，$M^{-1} = (I_{4} + \\tilde{S}^{\\top} \\tilde{S})^{-1}$。我们可以使用分块矩阵求逆。设 $M = \\begin{pmatrix} A  B \\\\ C  D \\end{pmatrix}$，其中 $A = 2I_{3}$，$B = \\begin{pmatrix} -1 \\\\ -1 \\\\ -1 \\end{pmatrix}$，$C = \\begin{pmatrix} -1  -1  -1 \\end{pmatrix}$，以及 $D = 4$。逆矩阵由标准公式给出，结果是：\n$$\nM^{-1} = (I_{4} + \\tilde{S}^{\\top} \\tilde{S})^{-1} = \\frac{1}{10} \\begin{bmatrix} 6  1  1  2 \\\\ 1  6  1  2 \\\\ 1  1  6  2 \\\\ 2  2  2  4 \\end{bmatrix}\n$$\n该矩阵的迹为：\n$$\n\\operatorname{tr}\\big((I_{4} + \\tilde{S}^{\\top} \\tilde{S})^{-1}\\big) = \\frac{1}{10} (6+6+6+4) = \\frac{22}{10} = \\frac{11}{5}\n$$\n此外，$\\operatorname{tr}(I_{4}) = 4$。将这些值代入我们的弗罗贝尼乌斯范数平方的表达式中：\n$$\n||A^{a}||_{F}^{2} = (m-1) \\Big(\\operatorname{tr}(I_{m}) - \\operatorname{tr}\\big((I_{m} + \\tilde{S}^{\\top} \\tilde{S})^{-1}\\big)\\Big) = (4-1) \\left(4 - \\frac{11}{5}\\right)\n$$\n$$\n||A^{a}||_{F}^{2} = 3 \\left(\\frac{20}{5} - \\frac{11}{5}\\right) = 3 \\left(\\frac{9}{5}\\right) = \\frac{27}{5}\n$$\n分析异常矩阵的弗罗贝尼乌斯范数平方的精确值为 $\\frac{27}{5}$。",
            "answer": "$$\\boxed{\\frac{27}{5}}$$"
        },
        {
            "introduction": "在实际的数据同化中，观测数据可以一次性全部处理（批处理），也可以逐个序贯处理（串行处理）。本练习旨在探究这两种方法之间的基本关系。通过在一个简单的线性系统中分别计算两种方法得到的后验协方差，您将亲自验证一个重要的理论原理：对于观测误差不相关的系统，无论采用何种处理策略，最终结果都是相同的。 这一认识对于设计高效灵活的数据同化系统至关重要。",
            "id": "3420557",
            "problem": "考虑一个线性的、时不变的数据同化设定，其状态为二维，集合成员为三个。设先验集合成员为 $x_{1}^{f} = \\begin{pmatrix}0 \\\\ 0\\end{pmatrix}$，$x_{2}^{f} = \\begin{pmatrix}2 \\\\ 0\\end{pmatrix}$ 和 $x_{3}^{f} = \\begin{pmatrix}0 \\\\ 2\\end{pmatrix}$。集合平均为 $\\bar{x}^{f} \\in \\mathbb{R}^{2}$，集合扰动矩阵 $A^{f} \\in \\mathbb{R}^{2 \\times 3}$ 由按列排列的扰动定义，并由 $\\sqrt{N-1}$（其中 $N=3$）归一化，因此样本先验协方差满足 $P^{f} = A^{f} (A^{f})^{\\top}$。收集了两个独立的标量观测，其线性观测算子为 $H_{1} = \\begin{pmatrix}1  0\\end{pmatrix}$ 和 $H_{2} = \\begin{pmatrix}0  1\\end{pmatrix}$，观测误差协方差为 $R = I_{2}$。实际观测值是任意但固定的；噪声为零均值高斯噪声。假设在批量和串行形式中都使用确定性平方根更新。\n\n仅使用基础的线性高斯贝叶斯更新和集合平方根滤波的定义，完成以下操作：\n\n1. 对于使用集合变换卡尔曼滤波（ETKF）的批量更新，计算由集合平方根公式所隐含的后验协方差 $P^{a}_{\\mathrm{batch}}$，而无需在集合空间中显式构造变换。从线性高斯协方差更新开始，并展示其如何与集合平方根协方差表达式匹配。\n\n2. 对于串行平方根更新（按 $H_{1}$ 然后 $H_{2}$ 的顺序，一次同化一个标量观测），计算最终的后验协方差 $P^{a}_{\\mathrm{serial}}$。\n\n3. 通过计算两者之差的弗罗贝尼乌斯范数来比较这两个后验协方差，即计算 $\\|P^{a}_{\\mathrm{batch}} - P^{a}_{\\mathrm{serial}}\\|_{F}$。\n\n给出弗罗贝尼乌斯范数的精确值作为最终答案（不要四舍五入）。无需单位。",
            "solution": "该问题要求计算和比较来自批量和串行平方根滤波更新的后验协方差矩阵。\n\n首先，我们计算先验集合统计量。\n给定的先验集合成员是 $x_{1}^{f} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$，$x_{2}^{f} = \\begin{pmatrix} 2 \\\\ 0 \\end{pmatrix}$ 和 $x_{3}^{f} = \\begin{pmatrix} 0 \\\\ 2 \\end{pmatrix}$。\n集合成员的数量为 $N=3$。\n先验集合平均 $\\bar{x}^{f}$ 为：\n$$ \\bar{x}^{f} = \\frac{1}{N} \\sum_{i=1}^{N} x_{i}^{f} = \\frac{1}{3} \\left( \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} + \\begin{pmatrix} 2 \\\\ 0 \\end{pmatrix} + \\begin{pmatrix} 0 \\\\ 2 \\end{pmatrix} \\right) = \\frac{1}{3} \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix} $$\n先验集合扰动为 $x'_{i}{}^{f} = x_{i}^{f} - \\bar{x}^{f}$：\n$$ x'_{1}{}^{f} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} - \\frac{1}{3} \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix} = -\\frac{1}{3} \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix} $$\n$$ x'_{2}{}^{f} = \\begin{pmatrix} 2 \\\\ 0 \\end{pmatrix} - \\frac{1}{3} \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix} = \\frac{1}{3} \\begin{pmatrix} 4 \\\\ -2 \\end{pmatrix} $$\n$$ x'_{3}{}^{f} = \\begin{pmatrix} 0 \\\\ 2 \\end{pmatrix} - \\frac{1}{3} \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix} = \\frac{1}{3} \\begin{pmatrix} -2 \\\\ 4 \\end{pmatrix} $$\n集合扰动矩阵 $A^{f}$ 的列由扰动定义，并由 $\\sqrt{N-1} = \\sqrt{2}$ 归一化：\n$$ A^{f} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} -\\frac{2}{3}  \\frac{4}{3}  -\\frac{2}{3} \\\\ -\\frac{2}{3}  -\\frac{2}{3}  \\frac{4}{3} \\end{pmatrix} = \\frac{\\sqrt{2}}{3} \\begin{pmatrix} -1  2  -1 \\\\ -1  -1  2 \\end{pmatrix} $$\n先验误差协方差矩阵 $P^{f}$ 由 $P^{f} = A^{f} (A^{f})^{\\top}$ 给出：\n$$ P^{f} = \\left(\\frac{\\sqrt{2}}{3}\\right)^2 \\begin{pmatrix} -1  2  -1 \\\\ -1  -1  2 \\end{pmatrix} \\begin{pmatrix} -1  -1 \\\\ 2  -1 \\\\ -1  2 \\end{pmatrix} = \\frac{2}{9} \\begin{pmatrix} (1+4+1)  (1-2-2) \\\\ (1-2-2)  (1+1+4) \\end{pmatrix} $$\n$$ P^{f} = \\frac{2}{9} \\begin{pmatrix} 6  -3 \\\\ -3  6 \\end{pmatrix} = \\frac{2}{3} \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix} $$\n\n为了后续使用，我们计算 $P^{f}$ 的逆矩阵：\n$$ \\det(P^{f}) = \\left(\\frac{2}{3}\\right)^2 (4-1) = \\frac{4}{9} \\times 3 = \\frac{4}{3} $$\n$$ (P^{f})^{-1} = \\frac{1}{4/3} \\frac{2}{3} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} = \\frac{3}{4} \\frac{2}{3} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} = \\begin{pmatrix} 1  1/2 \\\\ 1/2  1 \\end{pmatrix} $$\n\n1. 对于批量更新，我们同时考虑两个观测。完整的观测算子为 $H = \\begin{pmatrix} H_1 \\\\ H_2 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} = I_2$，观测误差协方差为 $R=I_2$。\n该问题要求从线性高斯贝叶斯更新开始，并展示其如何与集合平方根协方差表达式匹配。\n标准的贝叶斯后验协方差更新为：\n$$ P^{a} = \\left( (P^{f})^{-1} + H^{\\top} R^{-1} H \\right)^{-1} $$\n集合变换卡尔曼滤波（ETKF）的后验协方差表示为 $P^{a} = A^{a}(A^{a})^{\\top}$，其中更新后的扰动矩阵为 $A^{a} = A^{f} T$。选择变换矩阵 $T$ 使得 $T T^{\\top} = (I + (H A^{f})^{\\top} R^{-1} H A^{f})^{-1}$。这得到：\n$$ P^{a}_{\\mathrm{ETKF}} = A^{f} (I + (H A^{f})^{\\top} R^{-1} H A^{f})^{-1} (A^{f})^{\\top} $$\n为了证明它们的等价性，我们从更新的卡尔曼增益形式开始，$P^{a} = (I - KH)P^{f}$，其中 $K = P^{f}H^{\\top}(HP^{f}H^{\\top} + R)^{-1}$。\n代入 $P^{f}=A^{f}(A^{f})^{\\top}$：\n$$ P^{a} = A^{f}(A^{f})^{\\top} - A^{f}(A^{f})^{\\top}H^{\\top} (H A^{f}(A^{f})^{\\top}H^{\\top} + R)^{-1} H A^{f}(A^{f})^{\\top} $$\n$$ P^{a} = A^{f} \\left[ I - (A^{f})^{\\top}H^{\\top} (H A^{f}(A^{f})^{\\top}H^{\\top} + R)^{-1} H A^{f} \\right] (A^{f})^{\\top} $$\n设 $Y = H A^{f}$。方括号中的表达式变为 $I - Y^{\\top}(YY^{\\top} + R)^{-1}Y$。使用 Woodbury 矩阵恒等式，即 $(A+UCV)^{-1} = A^{-1} - A^{-1}U(C^{-1}+VA^{-1}U)^{-1}VA^{-1}$，可以证明恒等式 $I - Y^{\\top}(YY^{\\top} + R)^{-1}Y = (I+Y^{\\top}R^{-1}Y)^{-1}$。因此：\n$$ P^{a} = A^{f} (I+Y^{\\top}R^{-1}Y)^{-1} (A^{f})^{\\top} = A^{f} (I+(HA^{f})^{\\top}R^{-1}HA^{f})^{-1} (A^{f})^{\\top} $$\n推导到此完成。现在我们使用更简单的贝叶斯更新形式计算 $P^{a}_{\\mathrm{batch}}$：\n$$ P^{a}_{\\mathrm{batch}} = \\left( (P^{f})^{-1} + H^{\\top} R^{-1} H \\right)^{-1} = \\left( \\begin{pmatrix} 1  1/2 \\\\ 1/2  1 \\end{pmatrix} + I_{2}^{\\top} I_{2}^{-1} I_{2} \\right)^{-1} $$\n$$ P^{a}_{\\mathrm{batch}} = \\left( \\begin{pmatrix} 1  1/2 \\\\ 1/2  1 \\end{pmatrix} + \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} \\right)^{-1} = \\left( \\begin{pmatrix} 2  1/2 \\\\ 1/2  2 \\end{pmatrix} \\right)^{-1} $$\n该矩阵的行列式为 $(2)(2) - (1/2)(1/2) = 4 - 1/4 = 15/4$。\n$$ P^{a}_{\\mathrm{batch}} = \\frac{1}{15/4} \\begin{pmatrix} 2  -1/2 \\\\ -1/2  2 \\end{pmatrix} = \\frac{4}{15} \\begin{pmatrix} 2  -1/2 \\\\ -1/2  2 \\end{pmatrix} = \\begin{pmatrix} 8/15  -2/15 \\\\ -2/15  8/15 \\end{pmatrix} $$\n\n2. 对于串行更新，我们逐个同化观测。观测误差协方差 $R=I_2$ 意味着两个标量观测的误差方差分别为 $r_1=1$ 和 $r_2=1$ 且不相关。\n首先，使用算子 $H_1 = \\begin{pmatrix} 1  0 \\end{pmatrix}$ 和误差方差 $r_1=1$ 同化观测 $y_1$。先验为 $P^{f}$。设中间后验协方差为 $P^{a,1}$。\n$$ P^{a,1} = \\left( (P^{f})^{-1} + H_1^{\\top} r_1^{-1} H_1 \\right)^{-1} $$\n$$ H_1^{\\top} r_1^{-1} H_1 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} (1) \\begin{pmatrix} 1  0 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix} $$\n$$ P^{a,1} = \\left( \\begin{pmatrix} 1  1/2 \\\\ 1/2  1 \\end{pmatrix} + \\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix} \\right)^{-1} = \\left( \\begin{pmatrix} 2  1/2 \\\\ 1/2  1 \\end{pmatrix} \\right)^{-1} $$\n行列式为 $(2)(1) - (1/2)(1/2) = 2 - 1/4 = 7/4$。\n$$ P^{a,1} = \\frac{1}{7/4} \\begin{pmatrix} 1  -1/2 \\\\ -1/2  2 \\end{pmatrix} = \\frac{4}{7} \\begin{pmatrix} 1  -1/2 \\\\ -1/2  2 \\end{pmatrix} = \\begin{pmatrix} 4/7  -2/7 \\\\ -2/7  8/7 \\end{pmatrix} $$\n接下来，使用算子 $H_2 = \\begin{pmatrix} 0  1 \\end{pmatrix}$ 和误差方差 $r_2=1$ 同化观测 $y_2$。此步骤的先验为 $P^{a,1}$。最终的后验协方差为 $P^{a}_{\\mathrm{serial}}$。\n$$ P^{a}_{\\mathrm{serial}} = \\left( (P^{a,1})^{-1} + H_2^{\\top} r_2^{-1} H_2 \\right)^{-1} $$\n根据之前的计算，$(P^{a,1})^{-1} = \\begin{pmatrix} 2  1/2 \\\\ 1/2  1 \\end{pmatrix}$。\n$$ H_2^{\\top} r_2^{-1} H_2 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} (1) \\begin{pmatrix} 0  1 \\end{pmatrix} = \\begin{pmatrix} 0  0 \\\\ 0  1 \\end{pmatrix} $$\n$$ P^{a}_{\\mathrm{serial}} = \\left( \\begin{pmatrix} 2  1/2 \\\\ 1/2  1 \\end{pmatrix} + \\begin{pmatrix} 0  0 \\\\ 0  1 \\end{pmatrix} \\right)^{-1} = \\left( \\begin{pmatrix} 2  1/2 \\\\ 1/2  2 \\end{pmatrix} \\right)^{-1} $$\n这与我们为批量更新求逆的矩阵相同。\n$$ P^{a}_{\\mathrm{serial}} = \\frac{4}{15} \\begin{pmatrix} 2  -1/2 \\\\ -1/2  2 \\end{pmatrix} = \\begin{pmatrix} 8/15  -2/15 \\\\ -2/15  8/15 \\end{pmatrix} $$\n\n3. 比较两个后验协方差并计算它们之差的弗罗贝尼乌斯范数。\n$$ P^{a}_{\\mathrm{batch}} = \\begin{pmatrix} 8/15  -2/15 \\\\ -2/15  8/15 \\end{pmatrix} $$\n$$ P^{a}_{\\mathrm{serial}} = \\begin{pmatrix} 8/15  -2/15 \\\\ -2/15  8/15 \\end{pmatrix} $$\n这两个矩阵是相同的，这对于具有不相关观测误差的线性问题是预料之中的。\n差值为零矩阵：\n$$ P^{a}_{\\mathrm{batch}} - P^{a}_{\\mathrm{serial}} = \\begin{pmatrix} 0  0 \\\\ 0  0 \\end{pmatrix} $$\n矩阵 $M$ 的弗罗贝尼乌斯范数为 $\\|M\\|_{F} = \\sqrt{\\sum_{i,j} |m_{ij}|^2}$。\n$$ \\|P^{a}_{\\mathrm{batch}} - P^{a}_{\\mathrm{serial}}\\|_{F} = \\sqrt{0^2 + 0^2 + 0^2 + 0^2} = 0 $$",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "从理论走向实践，本练习将指导您实现一个完整的局部集合变换卡尔曼滤波（LETKF）。LETKF 是一种先进的算法，广泛应用于天气预报等大规模场景。您需要将平方根更新的核心机制、协方差膨胀以及观测空间局地化等关键概念整合到一个可运行的程序中。 这项综合性的编程任务将帮助您跨越从简化示例到真实世界数据同化系统复杂性的鸿沟。",
            "id": "3420543",
            "problem": "考虑一个包含$n$个格点的一维链，其观测算子为单位算子。假设我们的目标是使用平方根滤波公式执行局地集合变换卡尔曼滤波（LETKF）更新。其基本原理包括线性高斯逆问题和卡尔曼滤波：给定一个线性观测算子$H$和观测误差协方差$R$，后验均值和协方差由高斯条件化法则定义。在基于集合的数据同化中，预报协方差由集合异常的样本协方差近似。\n\n要求您实现一个完整的程序，该程序针对每个指定的测试用例，构建先验集合，应用乘性协方差膨胀，使用一个明确给定的局地化矩阵$C$在每个格点上独立执行局地化集合变换卡尔曼滤波（ETKF）分析，并返回分析均值向量。局地化是在每个格点$i$的观测空间中进行的，通过根据$C$的相应行来缩放观测误差协方差。\n\n定义和设置：\n- 状态维度为$n$，集合大小为$N_e$。\n- 观测算子是$n \\times n$的单位矩阵$H = I_n$，观测误差协方差为$R = \\sigma^2 I_n$，其中$\\sigma^2$为标量。\n- 先验集合矩阵记为$X^f \\in \\mathbb{R}^{n \\times N_e}$，其预报均值为$\\bar{x}^f \\in \\mathbb{R}^n$，预报异常为$A^f = X^f - \\bar{x}^f \\mathbf{1}^\\top \\in \\mathbb{R}^{n \\times N_e}$，其中$\\mathbf{1} \\in \\mathbb{R}^{N_e}$是全1向量。定义归一化异常为$A = \\frac{1}{\\sqrt{N_e - 1}} A^f$。\n- 使用因子为$\\lambda \\geq 1$的乘性协方差膨胀，意味着在分析步骤之前，异常被缩放为$A^f \\leftarrow \\lambda A^f$。\n- 观测值通过$y = x^{\\text{true}} + \\varepsilon$生成，其中$\\varepsilon \\sim \\mathcal{N}(0, \\sigma^2 I_n)$，以及一个指定的确定性$x^{\\text{true}}$。\n- 局地化矩阵$C \\in \\mathbb{R}^{n \\times n}$由一个在一维链上的紧支集Wendland函数指定，其支撑半径参数为$L > 0$。对于索引$i, j \\in \\{0, 1, \\dots, n-1\\}$，定义距离$d_{ij} = |i - j|$和归一化距离$r_{ij} = \\frac{d_{ij}}{L}$。$C$的元素为\n$$\nC_{ij} = \\phi(r_{ij}), \\quad \\text{with} \\quad\n\\phi(r) =\n\\begin{cases}\n(1 - r)^4 (1 + 4 r),  0 \\le r \\le 1, \\\\\n0,  r > 1.\n\\end{cases}\n$$\n\n每个格点的局地ETKF更新：\n- 对于每个格点$i \\in \\{0, 1, \\dots, n-1\\}$，通过包含满足$C_{ij} > \\varepsilon_{\\text{loc}}$的索引$j$来形成一个局地化观测选择，其中$\\varepsilon_{\\text{loc}}$是一个用于避免数值奇异性的微小正阈值。在$i$点定义一个局地化逆观测协方差，它是一个对角矩阵：\n$$\nR_i^{-1} = \\operatorname{diag}\\left( \\frac{C_{ij}^2}{\\sigma^2} \\right)_{j \\in \\mathcal{J}_i},\n$$\n其中$\\mathcal{J}_i = \\{ j \\mid C_{ij} > \\varepsilon_{\\text{loc}} \\}$。\n- 令$Y_i \\in \\mathbb{R}^{|\\mathcal{J}_i| \\times N_e}$是由$Y_i = H_{\\mathcal{J}_i} A$定义的局地化归一化集合观测异常，其中$H_{\\mathcal{J}_i}$选择$A$中对应于$\\mathcal{J}_i$中索引的行；由于$H = I_n$，这只是简单地从$A$中挑选出$j \\in \\mathcal{J}_i$的行。\n- 令$d_{\\mathcal{J}_i} = y_{\\mathcal{J}_i} - \\bar{x}^f_{\\mathcal{J}_i}$为局地化新息向量。\n- 在平方根ETKF中，格点$i$的分析均值增量通过一个集合空间权重向量$w_i \\in \\mathbb{R}^{N_e}$获得，该向量计算如下\n$$\nw_i = \\left( I_{N_e} + Y_i^\\top R_i^{-1} Y_i \\right)^{-1} Y_i^\\top R_i^{-1} d_{\\mathcal{J}_i}.\n$$\n那么在$i$点的分析均值为\n$$\nx^a_i = \\bar{x}^f_i + A_{i,:} w_i,\n$$\n其中$A_{i,:}$表示归一化异常矩阵$A$的第$i$行。\n- 在格点$i$的异常的局地平方根变换定义为\n$$\nT_i = \\left( I_{N_e} + Y_i^\\top R_i^{-1} Y_i \\right)^{-1/2},\n$$\n这是对称逆平方根。第$i$行的局地分析异常通过$A^a_{i,:} = A_{i,:} T_i$更新。尽管最终要求的输出仅为分析均值，但您必须实现$T_i$的计算，以遵循平方根滤波公式。\n\n数值要求：\n- 使用一个小的阈值$\\varepsilon_{\\text{loc}}$来排除局地化权重接近零的观测值；这避免了在$R_i^{-1}$中出现除以零的情况。如果$\\mathcal{J}_i$为空，则设置$x^a_i = \\bar{x}^f_i$和$T_i = I_{N_e}$。\n- 所有的线性代数运算都必须是数值稳定的。使用对称正定矩阵$I_{N_e} + Y_i^\\top R_i^{-1} Y_i$的谱分解来计算逆平方根。\n\n测试套件：\n为以下三个测试用例实现上述过程。对于每个用例，将随机数生成器设置为指定的种子，并确定性地定义$x^{\\text{true}}$为\n$$\nx^{\\text{true}}_k = \\sin\\left( \\frac{2\\pi k}{n} \\right) + \\frac{1}{2} \\cos\\left( \\frac{4\\pi k}{n} \\right), \\quad k = 0, 1, \\dots, n-1.\n$$\n生成先验集合$X^f = x^{\\text{true}} \\mathbf{1}^\\top + \\eta$，其中对于所有的$k$和$\\ell$，$\\eta_{k,\\ell} \\sim \\mathcal{N}(0, 0.5^2)$是独立的。生成观测值$y = x^{\\text{true}} + \\varepsilon$，其中$\\varepsilon_k \\sim \\mathcal{N}(0, \\sigma^2)$是独立的。每个用例的参数是：\n1. 用例A（理想路径）：$n = 8$, $N_e = 10$, $\\lambda = 1.05$, $\\sigma^2 = 0.01$, $L = 2.0$, 种子 $= 1$。\n2. 用例B（边界局地化）：$n = 8$, $N_e = 10$, $\\lambda = 1.00$, $\\sigma^2 = 0.01$, $L = 0.5$, 种子 $= 2$。\n3. 用例C（小编队和更强膨胀）：$n = 12$, $N_e = 6$, $\\lambda = 1.20$, $\\sigma^2 = 0.0625$, $L = 3.0$, 种子 $= 3$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个结果是相应测试用例的分析均值向量，以Python风格的列表形式打印，数值四舍五入到六位小数。例如，输出应如下所示\n$[ [a_1,\\dots,a_n], [b_1,\\dots,b_n], [c_1,\\dots,c_n] ]$",
            "solution": "该问题基于线性高斯逆问题和卡尔曼滤波。对于具有高斯误差的线性观测模型，后验分布是高斯的，其均值和协方差由卡尔曼滤波确定。在基于集合的滤波中，我们通过集合异常的样本协方差来近似预报协方差。\n\n从预报集合$X^f \\in \\mathbb{R}^{n \\times N_e}$开始。其集合均值为$\\bar{x}^f = \\frac{1}{N_e} X^f \\mathbf{1}$，异常为$A^f = X^f - \\bar{x}^f \\mathbf{1}^\\top$。乘性协方差膨胀将异常乘以一个因子$\\lambda \\geq 1$，即$A^f \\leftarrow \\lambda A^f$，这可以抵消由于抽样误差或模型缺陷导致的预报离散度低估。通过$A = \\frac{1}{\\sqrt{N_e - 1}} A^f$对异常进行归一化，使得$A A^\\top$可以估计先验协方差。\n\n在单位算子$H$和对角矩阵$R$的条件下，卡尔曼滤波分析增量可以使用集合变换卡尔曼滤波（ETKF）在集合空间中表示。其关键思想是将后验均值增量表示为异常列的线性组合。定义观测空间异常矩阵$Y = H A$。由于$H = I_n$，我们有$Y = A$。后验均值增量为$\\Delta x = A w$，其中集合空间权重$w \\in \\mathbb{R}^{N_e}$是通过将新息投影到集合子空间来确定的。对于非局地化的ETKF，当$R = \\sigma^2 I_n$为对角阵时，权重$w$的解为：\n$$\nw = \\left( I_{N_e} + Y^\\top R^{-1} Y \\right)^{-1} Y^\\top R^{-1} d, \\quad d = y - \\bar{x}^f.\n$$\n这可由Kalman更新的恒等式$\\Delta x = K d$、集合近似$P^f \\approx A A^\\top$以及使用Sherman–Morrison–Woodbury公式到集合空间的代数简化推导得出。分析异常通过对称平方根变换进行更新，以确保后验协方差在集合子空间内与Kalman分析协方差相匹配：\n$$\nA^a = A T, \\quad T = \\left( I_{N_e} + Y^\\top R^{-1} Y \\right)^{-1/2}.\n$$\n逆平方根通过谱分解计算：如果$B = I_{N_e} + Y^\\top R^{-1} Y$的特征分解为$B = Q \\Lambda Q^\\top$，其中$Q$是正交的，$\\Lambda$是正对角矩阵，则$B^{-1/2} = Q \\Lambda^{-1/2} Q^\\top$。\n\n引入局地化是为了减少由有限集合大小导致的虚假远程相关。在局地集合变换卡尔曼滤波（LETKF）中，分析是在每个状态位置$i$上独立执行的，仅使用由局地化矩阵确定的邻近观测。我们在每个格点$i$采用观测空间局地化，通过根据局地化权重缩放观测误差，这等同于当$R$为对角阵时在观测空间中执行Schur积锥削。具体来说，对于每个$i$，定义局地化逆观测协方差：\n$$\nR_i^{-1} = \\operatorname{diag}\\left( \\frac{C_{ij}^2}{\\sigma^2} \\right)_{j \\in \\mathcal{J}_i},\n$$\n其中$\\mathcal{J}_i = \\{ j \\mid C_{ij} > \\varepsilon_{\\text{loc}} \\}$排除了接近零的权重以避免数值问题。局地化观测异常为$Y_i = H_{\\mathcal{J}_i} A$，它选择$A$中索引在$\\mathcal{J}_i$中的行，局地化新息为$d_{\\mathcal{J}_i} = y_{\\mathcal{J}_i} - \\bar{x}^f_{\\mathcal{J}_i}$。位置$i$的集合空间权重则为：\n$$\nw_i = \\left( I_{N_e} + Y_i^\\top R_i^{-1} Y_i \\right)^{-1} Y_i^\\top R_i^{-1} d_{\\mathcal{J}_i},\n$$\n局地分析均值为\n$$\nx^a_i = \\bar{x}^f_i + A_{i,:} w_i.\n$$\n异常的局地平方根变换是\n$$\nT_i = \\left( I_{N_e} + Y_i^\\top R_i^{-1} Y_i \\right)^{-1/2},\n$$\n应用于第$i$行的异常上，即$A^a_{i,:} = A_{i,:} T_i$，确保了在每个位置上与平方根公式的一致性。\n\n在一维链上构建局地化矩阵$C$使用的是一种紧支集Wendland锥削，它既是正定的又是光滑的，从而在实践中确保了数值稳定性。对于索引$i, j$，定义$d_{ij} = |i - j|$和$r_{ij} = \\frac{d_{ij}}{L}$，以及\n$$\nC_{ij} = \\phi(r_{ij}) =\n\\begin{cases}\n(1 - r_{ij})^4 (1 + 4 r_{ij}),  0 \\le r_{ij} \\le 1, \\\\\n0,  r_{ij} > 1.\n\\end{cases}\n$$\n\n每个测试用例的算法步骤：\n1. 设置随机种子并构建确定性真值$x^{\\text{true}}_k = \\sin\\left( \\frac{2\\pi k}{n} \\right) + \\frac{1}{2} \\cos\\left( \\frac{4\\pi k}{n} \\right)$。\n2. 生成先验集合$X^f = x^{\\text{true}} \\mathbf{1}^\\top + \\eta$，其中$\\eta_{k,\\ell} \\sim \\mathcal{N}(0, 0.25)$为独立高斯噪声。\n3. 生成观测值$y = x^{\\text{true}} + \\varepsilon$，其中$\\varepsilon_k \\sim \\mathcal{N}(0, \\sigma^2)$是独立的。\n4. 计算$\\bar{x}^f$和$A^f$，应用膨胀$A^f \\leftarrow \\lambda A^f$，并形成$A = \\frac{1}{\\sqrt{N_e - 1}} A^f$。\n5. 使用半径为$L$的Wendland函数构建局地化矩阵$C$。\n6. 对于每个格点$i$，形成局地化索引集$\\mathcal{J}_i = \\{ j : C_{ij} > \\varepsilon_{\\text{loc}} \\}$，计算$R_i^{-1}$、$Y_i$和$d_{\\mathcal{J}_i}$，然后通过谱分解计算权重$w_i$和局地变换$T_i$。设置$x^a_i = \\bar{x}^f_i + A_{i,:} w_i$。如果$\\mathcal{J}_i$为空，则设置$x^a_i = \\bar{x}^f_i$和$T_i = I_{N_e}$。\n7. 返回分析均值向量$x^a$。\n\n该程序为三个指定的测试用例实现了此过程。它打印一行包含三个分析均值向量，每个向量都是一个Python风格的、数值四舍五入到六位小数的列表，顺序为A、B、C。这种设计确保了覆盖一般情况、边界局地化情况以及小编队和更强膨胀的边缘情况，从而测试了局地化平方根ETKF实现的不同方面。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef wendland_phi(r: float) -> float:\n    \"\"\"\n    Compactly supported Wendland C^2 function in 1D:\n    phi(r) = (1 - r)^4 (1 + 4 r) for r in [0,1], and 0 otherwise.\n    \"\"\"\n    if r == 0.0:\n        return 1.0\n    if r >= 1.0:\n        return 0.0\n    t = 1.0 - r\n    return (t**4) * (1.0 + 4.0 * r)\n\ndef build_localization_matrix(n: int, L: float) -> np.ndarray:\n    \"\"\"\n    Build the localization matrix C for a 1D chain of length n\n    using the Wendland function with radius L.\n    \"\"\"\n    C = np.zeros((n, n), dtype=float)\n    for i in range(n):\n        for j in range(n):\n            d = abs(i - j)\n            r = d / L if L > 0 else np.inf\n            C[i, j] = wendland_phi(r)\n    return C\n\ndef etkf_local_analysis_mean(Xf: np.ndarray, y: np.ndarray, sigma2: float, C: np.ndarray,\n                             inflation: float, eps_loc: float = 1e-8) -> np.ndarray:\n    \"\"\"\n    Perform LETKF local analysis at each grid point for mean using square-root ETKF formulas.\n    - Xf: forecast ensemble (n x Ne)\n    - y: observations (n,)\n    - sigma2: observation error variance\n    - C: localization matrix (n x n)\n    - inflation: multiplicative inflation factor lambda\n    - eps_loc: threshold for localization weight inclusion\n    Returns the analysis mean vector (n,).\n    \"\"\"\n    n, Ne = Xf.shape\n    # Forecast mean and anomalies\n    xbar = np.mean(Xf, axis=1)  # (n,)\n    Af = Xf - xbar[:, None]     # (n, Ne)\n    # Apply multiplicative covariance inflation\n    Af *= inflation\n    # Normalized anomalies\n    A = Af / np.sqrt(max(Ne - 1, 1))\n    # Innovations\n    d = y - xbar  # (n,)\n    xa = np.copy(xbar)\n\n    # Precompute identity in ensemble space\n    I_ens = np.eye(Ne)\n\n    for i in range(n):\n        # Localized observation indices\n        loc_weights = C[i, :]\n        J = np.where(loc_weights > eps_loc)[0]\n        if J.size == 0:\n            # No local observations; analysis equals forecast mean\n            xa[i] = xbar[i]\n            continue\n\n        # Local inverse R: diag(C[i,j]^2 / sigma2)\n        r_inv = (loc_weights[J] ** 2) / sigma2  # (m_i,)\n        # Local Y = H_J * A; since H = I, pick rows J\n        Y = A[J, :]  # (m_i, Ne)\n        # Compute M = Y^T R_inv Y, using r_inv diagonal efficiently\n        # Scale rows of Y by r_inv, then Y^T @ scaled_Y\n        Y_scaled = Y * r_inv[:, None]  # (m_i, Ne)\n        M = Y.T @ Y_scaled             # (Ne, Ne)\n        # Compute v = Y^T R_inv d_J\n        d_loc = d[J]                   # (m_i,)\n        v = Y.T @ (r_inv * d_loc)      # (Ne,)\n\n        # Solve for w: (I + M) w = v\n        B = I_ens + M                  # (Ne, Ne)\n        # Use symmetric solver via eigendecomposition for stability\n        # w = B^{-1} v\n        evals, evecs = np.linalg.eigh(B)\n        # Inverse via spectral decomposition\n        inv_evals = 1.0 / evals\n        # Compute w = Q (Lambda^{-1} (Q^T v))\n        tmp = evecs.T @ v\n        w = evecs @ (inv_evals * tmp)\n\n        # Update local mean component\n        xa[i] = xbar[i] + A[i, :] @ w\n\n        # Optional: compute local transform T_i = B^{-1/2}, not used further for mean\n        # We implement to adhere to square-root formulation.\n        inv_sqrt_evals = 1.0 / np.sqrt(evals)\n        # T_i = Q diag(inv_sqrt_evals) Q^T\n        # If needed for anomalies, one would use A[i,:] @ T_i\n\n    return xa\n\ndef generate_case(n: int, Ne: int, sigma2: float, L: float, seed: int):\n    \"\"\"\n    Generate truth, prior ensemble, observations, and localization matrix for a case.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    k = np.arange(n, dtype=float)\n    x_true = np.sin(2.0 * np.pi * k / n) + 0.5 * np.cos(4.0 * np.pi * k / n)\n    # Prior ensemble: truth plus Gaussian noise N(0, 0.5^2)\n    Xf = x_true[:, None] + rng.normal(loc=0.0, scale=0.5, size=(n, Ne))\n    # Observations: truth plus noise N(0, sigma2)\n    y = x_true + rng.normal(loc=0.0, scale=np.sqrt(sigma2), size=n)\n    # Localization matrix\n    C = build_localization_matrix(n, L)\n    return Xf, y, C, x_true\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: n=8, Ne=10, lambda=1.05, sigma2=0.01, L=2.0, seed=1\n        (8, 10, 0.01, 2.0, 1, 1.05),\n        # Case B: n=8, Ne=10, lambda=1.00, sigma2=0.01, L=0.5, seed=2\n        (8, 10, 0.01, 0.5, 2, 1.00),\n        # Case C: n=12, Ne=6, lambda=1.20, sigma2=0.0625, L=3.0, seed=3\n        (12, 6, 0.0625, 3.0, 3, 1.20),\n    ]\n\n    results_str = []\n    for n, Ne, sigma2, L, seed, lam in test_cases:\n        # Generate case data\n        Xf, y, C, _ = generate_case(n, Ne, sigma2, L, seed)\n        # Perform local ETKF analysis mean computation\n        xa = etkf_local_analysis_mean(Xf, y, sigma2, C, inflation=lam, eps_loc=1e-8)\n        # Format result with six decimal places\n        formatted = \"[\" + \",\".join(f\"{val:.6f}\" for val in xa.tolist()) + \"]\"\n        results_str.append(formatted)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}