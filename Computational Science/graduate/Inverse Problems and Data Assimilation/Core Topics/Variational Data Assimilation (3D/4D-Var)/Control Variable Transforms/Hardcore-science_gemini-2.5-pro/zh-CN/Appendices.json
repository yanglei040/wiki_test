{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。本节的第一个练习将引导您完成一个基础但极具启发性的控制变量变换（Control Variable Transform, CVT）应用。我们将研究一个简单的一维扩散逆问题，其中CVT被用作一种“先验白化”工具，将具有特定均值和方差的先验分布的物理参数，转换为服从标准正态分布的无约束控制变量。通过在控制变量空间中推导并计算高斯-牛顿（Gauss-Newton）更新，您将亲身体验CVT如何简化正则化项并为优化过程奠定基础。",
            "id": "3372052",
            "problem": "考虑在空间区间 $x \\in [0,1]$ 上的一个一维、稳态、无量纲的扩散问题，其扩散系数 $D > 0$ 为空间常数，源项 $s_0 > 0$ 均匀，并具有齐次狄利克雷边界条件。浓度场 $c(x;D)$ 满足\n$$\n0 = D \\,\\frac{d^2 c}{dx^2} + s_0,\\quad c(0;D) = 0,\\quad c(1;D) = 0.\n$$\n给定在位置 $x_1 = 0.2$、$x_2 = 0.5$ 和 $x_3 = 0.8$ 的三个浓度观测值，其数据向量为\n$$\n\\mathbf{d} = \\begin{pmatrix} 0.205 \\\\ 0.315 \\\\ 0.195 \\end{pmatrix},\n$$\n数据误差协方差为\n$$\n\\mathbf{C}_d = \\operatorname{diag}(0.01,\\,0.01,\\,0.01).\n$$\n假设 $D$ 服从均值为 $D_b = 0.5$、方差为 $\\sigma_D^2 = (0.2)^2$ 的高斯先验，并应用控制变量变换 (CVT)，通过由下式定义的标量控制变量 $z \\in \\mathbb{R}$ 来白化先验：\n$$\nD = D_b + \\sigma_D\\, z.\n$$\n构建关于控制变量 $z$ 的最小二乘目标函数，其中观测算子 $\\mathbf{H}$ 在位置 $\\{x_i\\}_{i=1}^3$ 处对模型浓度进行采样。使用高斯-牛顿法（从目标函数的线性化和二次近似的第一性原理推导），计算在背景值 $z=0$ 处的高斯-牛顿更新量 $\\delta z$。\n\n取 $s_0 = 1$。将最终更新量 $\\delta z$ 表示为一个无量纲标量。将答案四舍五入至四位有效数字。",
            "solution": "用户希望在一个扩散反问题中，求解控制变量的第一个高斯-牛顿更新量。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n\n-   **控制方程**：$0 = D \\,\\frac{d^2 c}{dx^2} + s_0$，对于 $x \\in [0,1]$。\n-   **边界条件**：$c(0;D) = 0$, $c(1;D) = 0$。\n-   **参数**：扩散系数 $D > 0$，均匀源 $s_0 > 0$。对于最终计算，取 $s_0=1$。\n-   **数据**：在 $x_1 = 0.2$、$x_2 = 0.5$、$x_3 = 0.8$ 处的观测值。\n-   **数据向量**：$\\mathbf{d} = \\begin{pmatrix} 0.205 \\\\ 0.315 \\\\ 0.195 \\end{pmatrix}$。\n-   **数据误差协方差**：$\\mathbf{C}_d = \\operatorname{diag}(0.01,\\,0.01,\\,0.01)$。\n-   **先验信息**：$D$ 的高斯先验，均值为 $D_b = 0.5$，方差为 $\\sigma_D^2 = (0.2)^2$。\n-   **控制变量变换（CVT）**：$D = D_b + \\sigma_D\\, z$，其中 $z \\in \\mathbb{R}$。\n-   **方法**：高斯-牛顿法，计算在背景状态 $z=0$ 处的更新量 $\\delta z$。\n\n**1.2. 使用提取的已知条件进行验证**\n\n-   **科学依据**：该问题描述了一个稳态扩散-反应过程，这是物理学和工程学中的一个基本概念。其数学模型是一个标准的二阶常微分方程。这在科学上是合理的。\n-   **适定性**：该问题是适定的。对于任何给定的 $D0$，带有狄利克雷边界条件的常微分方程都有唯一解。反问题在一个标准的贝叶斯/正则化最小二乘框架中构建，该框架旨在产生稳定的解。所有必要的数据、先验信息和误差统计数据都已提供。\n-   **客观性**：该问题使用精确的数学语言陈述，并提供了客观的数值数据。没有主观或模糊的术语。\n-   **完整性**：该问题是自洽的，并提供了执行所要求的计算所需的所有信息。\n-   **形式化**：该问题已经处于一个形式化的数学结构中，并且与反问题中的控制变量变换和高斯-牛顿法主题直接相关。\n\n**1.3. 结论与行动**\n\n该问题是有效的，因为它是科学合理的、适定的、客观的和完整的。我将继续解决它。\n\n### 步骤 2：推导与求解\n\n**2.1. 正演模型解**\n首先，我们求解正演问题以找到浓度 $c(x;D)$。控制方程是一个二阶常微分方程：\n$$ D \\frac{d^2 c}{dx^2} = -s_0 $$\n对 $x$ 积分两次得到：\n$$ D \\frac{dc}{dx} = -s_0 x + A $$\n$$ D c(x) = -\\frac{s_0}{2} x^2 + A x + B $$\n其中 $A$ 和 $B$ 是积分常数。我们应用齐次狄利克雷边界条件：\n-   $c(0) = 0 \\implies D c(0) = 0 = B$。\n-   $c(1) = 0 \\implies D c(1) = 0 = -\\frac{s_0}{2} + A$。这给出 $A = \\frac{s_0}{2}$。\n\n将常数代回，浓度场的解为：\n$$ D c(x; D) = -\\frac{s_0}{2}x^2 + \\frac{s_0}{2}x = \\frac{s_0}{2}(x - x^2) $$\n$$ c(x; D) = \\frac{s_0}{2D} (x - x^2) $$\n\n**2.2. 关于控制变量的目标函数**\n贝叶斯最小二乘目标函数 $J$ 是数据失配项和背景惩罚项之和：\n$$ J(D) = \\frac{1}{2} (\\mathbf{H}(D) - \\mathbf{d})^T \\mathbf{C}_d^{-1} (\\mathbf{H}(D) - \\mathbf{d}) + \\frac{1}{2} (D - D_b)^2 \\sigma_D^{-2} $$\n其中 $\\mathbf{H}(D)$ 是在观测位置 $\\{x_i\\}$ 处对 $c(x;D)$ 进行求值的观测算子。\n\n控制变量变换为 $D(z) = D_b + \\sigma_D z$。$D$ 的先验项变为：\n$$ \\frac{1}{2} \\frac{((D_b + \\sigma_D z) - D_b)^2}{\\sigma_D^2} = \\frac{1}{2} \\frac{(\\sigma_D z)^2}{\\sigma_D^2} = \\frac{1}{2}z^2 $$\n这将 $D$ 上的先验转换为 $z$ 上的标准正态先验。用控制变量 $z$ 表示的目标函数为：\n$$ J(z) = \\frac{1}{2} (\\mathbf{H}(z) - \\mathbf{d})^T \\mathbf{C}_d^{-1} (\\mathbf{H}(z) - \\mathbf{d}) + \\frac{1}{2}z^2 $$\n其中 $\\mathbf{H}(z) \\equiv \\mathbf{H}(D(z))$。\n\n**2.3. 高斯-牛顿法**\n高斯-牛顿法在当前估计值 $z_k$ 周围将目标函数近似为一个二次函数，并找到使该近似最小化的更新量 $\\delta z$。我们从背景状态开始，所以 $z_k=0$。\n首先通过在 $z_k$ 周围线性化观测算子 $\\mathbf{H}(z)$ 来近似 $z_k+\\delta z$ 处的目标函数：\n$$ \\mathbf{H}(z_k + \\delta z) \\approx \\mathbf{H}(z_k) + \\mathbf{H}'(z_k) \\delta z $$\n其中 $\\mathbf{H}'(z_k) = \\frac{d\\mathbf{H}}{dz}\\big|_{z_k}$ 是雅可比矩阵（在此标量情况下为列向量）。\n\n将此代入 $J(z_k+\\delta z)$：\n$$ J(z_k + \\delta z) \\approx \\frac{1}{2} (\\mathbf{H}(z_k) + \\mathbf{H}'(z_k) \\delta z - \\mathbf{d})^T \\mathbf{C}_d^{-1} (\\mathbf{H}(z_k) + \\mathbf{H}'(z_k) \\delta z - \\mathbf{d}) + \\frac{1}{2}(z_k + \\delta z)^2 $$\n为求最小值，我们对 $\\delta z$ 求导并将结果设为零：\n$$ \\frac{\\partial J}{\\partial(\\delta z)} = (\\mathbf{H}'(z_k))^T \\mathbf{C}_d^{-1} (\\mathbf{H}(z_k) - \\mathbf{d} + \\mathbf{H}'(z_k) \\delta z) + (z_k + \\delta z) = 0 $$\n整理各项以求解 $\\delta z$：\n$$ \\delta z \\left[ (\\mathbf{H}'(z_k))^T \\mathbf{C}_d^{-1} \\mathbf{H}'(z_k) + 1 \\right] = - \\left[ (\\mathbf{H}'(z_k))^T \\mathbf{C}_d^{-1} (\\mathbf{H}(z_k) - \\mathbf{d}) + z_k \\right] $$\n我们被要求计算在背景状态下的更新量，因此我们设 $z_k=0$：\n$$ \\delta z \\left[ (\\mathbf{H}'(0))^T \\mathbf{C}_d^{-1} \\mathbf{H}'(0) + 1 \\right] = -(\\mathbf{H}'(0))^T \\mathbf{C}_d^{-1} (\\mathbf{H}(0) - \\mathbf{d}) $$\n该方程定义了高斯-牛顿更新量 $\\delta z$。\n\n**2.4. 数值计算**\n现在我们使用给定值计算更新方程中的各项：\n$s_0 = 1$，$D_b = 0.5$，$\\sigma_D = 0.2$。位置为 $x_1 = 0.2$，$x_2 = 0.5$，$x_3 = 0.8$。\n数据为 $\\mathbf{d} = \\begin{pmatrix} 0.205 \\\\ 0.315 \\\\ 0.195 \\end{pmatrix}$ 且 $\\mathbf{C}_d^{-1} = \\frac{1}{0.01}\\mathbf{I} = 100\\,\\mathbf{I}$。\n\n-   **计算 $\\mathbf{H}(0)$**：在 $z=0$ 时，我们有 $D = D_b = 0.5$。模型为 $c(x; 0.5) = \\frac{1}{2(0.5)}(x-x^2) = x-x^2$。\n    $$ \\mathbf{H}(0) = \\begin{pmatrix} 0.2 - 0.2^2 \\\\ 0.5 - 0.5^2 \\\\ 0.8 - 0.8^2 \\end{pmatrix} = \\begin{pmatrix} 0.16 \\\\ 0.25 \\\\ 0.16 \\end{pmatrix} $$\n-   **计算失配 $\\mathbf{r}_0 = \\mathbf{H}(0) - \\mathbf{d}$**：\n    $$ \\mathbf{r}_0 = \\begin{pmatrix} 0.16 - 0.205 \\\\ 0.25 - 0.315 \\\\ 0.16 - 0.195 \\end{pmatrix} = \\begin{pmatrix} -0.045 \\\\ -0.065 \\\\ -0.035 \\end{pmatrix} $$\n-   **计算雅可比 $\\mathbf{H}'(0)$**：我们需要在每个 $x_i$ 处计算 $\\frac{d\\mathbf{H}}{dz} = \\frac{\\partial c}{\\partial z}$。根据链式法则：\n    $$ \\frac{\\partial c}{\\partial z} = \\frac{\\partial c}{\\partial D} \\frac{dD}{dz} $$\n    我们有 $\\frac{dD}{dz} = \\sigma_D$。并且 $\\frac{\\partial c}{\\partial D} = \\frac{\\partial}{\\partial D} \\left( \\frac{s_0}{2D}(x-x^2) \\right) = -\\frac{s_0}{2D^2}(x-x^2)$。\n    所以，$\\frac{\\partial c}{\\partial z} = -\\frac{s_0 \\sigma_D}{2D^2}(x-x^2)$。\n    在 $z=0$ 时，$D=D_b=0.5$：\n    $$ \\frac{\\partial c}{\\partial z}\\bigg|_{z=0} = -\\frac{1 \\cdot 0.2}{2(0.5)^2}(x-x^2) = -\\frac{0.2}{0.5}(x-x^2) = -0.4(x-x^2) $$\n    现在对每个 $x_i$ 进行计算：\n    $$ \\mathbf{H}'(0) = \\begin{pmatrix} -0.4(0.2 - 0.2^2) \\\\ -0.4(0.5 - 0.5^2) \\\\ -0.4(0.8 - 0.8^2) \\end{pmatrix} = \\begin{pmatrix} -0.4(0.16) \\\\ -0.4(0.25) \\\\ -0.4(0.16) \\end{pmatrix} = \\begin{pmatrix} -0.064 \\\\ -0.100 \\\\ -0.064 \\end{pmatrix} $$\n-   **计算更新方程的各项**：\n    近似海森矩阵的项为 $G = (\\mathbf{H}'(0))^T \\mathbf{C}_d^{-1} \\mathbf{H}'(0) + 1$：\n    $$ (\\mathbf{H}'(0))^T \\mathbf{C}_d^{-1} \\mathbf{H}'(0) = 100 \\begin{pmatrix} -0.064  -0.100  -0.064 \\end{pmatrix} \\begin{pmatrix} -0.064 \\\\ -0.100 \\\\ -0.064 \\end{pmatrix} $$\n    $$ = 100 ((-0.064)^2 + (-0.100)^2 + (-0.064)^2) = 100 (0.004096 + 0.01 + 0.004096) = 100(0.018192) = 1.8192 $$\n    所以，$G = 1.8192 + 1 = 2.8192$。\n\n    梯度的项为 $g = (\\mathbf{H}'(0))^T \\mathbf{C}_d^{-1} \\mathbf{r}_0$：\n    $$ g = 100 \\begin{pmatrix} -0.064  -0.100  -0.064 \\end{pmatrix} \\begin{pmatrix} -0.045 \\\\ -0.065 \\\\ -0.035 \\end{pmatrix} $$\n    $$ = 100 ((-0.064)(-0.045) + (-0.100)(-0.065) + (-0.064)(-0.035)) $$\n    $$ = 100 (0.00288 + 0.0065 + 0.00224) = 100(0.01162) = 1.162 $$\n-   **求解 $\\delta z$**：\n    更新方程为 $\\delta z \\cdot G = -g$。\n    $$ \\delta z (2.8192) = -1.162 $$\n    $$ \\delta z = -\\frac{1.162}{2.8192} \\approx -0.41217047... $$\n四舍五入到四位有效数字，高斯-牛顿更新量为 $\\delta z = -0.4122$。",
            "answer": "$$\n\\boxed{-0.4122}\n$$"
        },
        {
            "introduction": "在掌握了单参数CVT的基础后，我们将转向更贴近实际大规模数据同化应用场景的挑战。本练习的核心在于展示CVT作为一种强大的预条件（preconditioning）工具的威力，特别是在处理高维状态向量时。您将通过一个数值实验，探索经典的 $L=B^{1/2}$ 变换如何显著改善代价函数Hessian矩阵的条件数，其中 $B$ 是背景误差协方差矩阵。通过对比变换前后Hessian矩阵的条件数随观测误差的变化，您将深刻理解为何这种变换对于加速梯度下降等优化算法的收敛至关重要。",
            "id": "3372107",
            "problem": "考虑一个带线性观测算子的一维变分资料同化问题。代价函数由变分资料同化中的标准二次型给出：\n$$\nJ(x) = \\frac{1}{2} \\left\\| x - x_b \\right\\|_{B^{-1}}^2 + \\frac{1}{2} \\left\\| y - H x \\right\\|_{R^{-1}}^2,\n$$\n其中 $x \\in \\mathbb{R}^n$ 是状态向量，$x_b \\in \\mathbb{R}^n$ 是背景场状态，$y \\in \\mathbb{R}^n$ 是观测值，$B \\in \\mathbb{R}^{n \\times n}$ 是背景误差协方差矩阵，$H \\in \\mathbb{R}^{n \\times n}$ 是线性观测算子，$R \\in \\mathbb{R}^{n \\times n}$ 是观测误差协方差矩阵。假设 $H = I$ 且 $R = \\sigma_o^2 I$，其中 $I$ 是单位矩阵，$\\sigma_o^2  0$ 是观测误差方差。\n\n$J(x)$ 的Hessian矩阵在任意点的高斯-牛顿近似为\n$$\nK = B^{-1} + H^\\top R^{-1} H.\n$$\n当 $H = I$ 且 $R = \\sigma_o^2 I$ 时，上式简化为\n$$\nK = B^{-1} + \\frac{1}{\\sigma_o^2} I.\n$$\n\n引入由 $x = x_b + L v$ 定义的控制变量变换，其中 $L \\in \\mathbb{R}^{n \\times n}$ 的选择使得 $L L^\\top = B$（因此 $L$ 是 $B$ 的矩阵平方根），$v \\in \\mathbb{R}^n$ 是控制变量。在 $v$-空间中，高斯-牛顿Hessian矩阵变为\n$$\nK_v = I + L^\\top H^\\top R^{-1} H L.\n$$\n对于 $H = I$ 和 $R = \\sigma_o^2 I$，此式为\n$$\nK_v = I + \\frac{1}{\\sigma_o^2} L^\\top L = I + \\frac{1}{\\sigma_o^2} B.\n$$\n\n设背景误差协方差 $B$ 由单位区间 $[0,1]$ 上 $n$ 个点的均匀一维网格上的指数相关性定义。网格点为 $x_i = \\frac{i}{n-1}$，其中 $i = 0, 1, \\dots, n-1$。$B$ 的元素定义为\n$$\nB_{ij} = \\sigma_b^2 \\exp\\left(-\\frac{|x_i - x_j|}{\\ell}\\right),\n$$\n其中 $\\sigma_b^2  0$ 是背景方差，$\\ell  0$ 是相关长度尺度，两者均无量纲。\n\n你的任务是：\n- 为 $n = 64$、$\\sigma_b^2 = 1$ 和 $\\ell = 0.2$ 构建 $B$。\n- 使用 $B$ 的特征值分解计算 $L = B^{1/2}$。\n- 对于每个指定的 $\\sigma_o^2$ 值，计算未变换的Hessian矩阵 $K$ 和变换后的Hessian矩阵 $K_v$ 的2-范数条件数（谱范数（2-范数）条件数）。对称正定矩阵 $A$ 的2-范数条件数定义为\n$$\n\\kappa_2(A) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)},\n$$\n其中 $\\lambda_{\\max}(A)$ 和 $\\lambda_{\\min}(A)$ 分别是 $A$ 的最大和最小特征值。\n\n为以下观测误差方差的测试套件提供数值结果：\n- $\\sigma_o^2 = 10^{-8}$（边缘情况：观测极度精确），\n- $\\sigma_o^2 = 10^{-4}$,\n- $\\sigma_o^2 = 10^{-2}$,\n- $\\sigma_o^2 = 10^{0}$（一般情况），\n- $\\sigma_o^2 = 10^{2}$（边缘情况：观测噪声极大）。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表的结果。列表中的每个元素本身都应是一个双元素列表，包含对应 $\\sigma_o^2$ 的配对 $[\\kappa_2(K), \\kappa_2(K_v)]$。例如，输出格式必须是\n$$\n[\\,[\\kappa_2(K\\_1),\\kappa_2(K\\_{v,1})],\\,[\\kappa_2(K\\_2),\\kappa_2(K\\_{v,2})],\\,\\dots\\,],\n$$\n以标准Python列表语法打印为单行。不涉及物理单位；所有量均为无量纲。",
            "solution": "问题陈述是一个应用于变分资料同化的、适定且有科学依据的数值线性代数练习。它要求计算标准资料同化代价函数中Hessian矩阵两种不同形式的条件数。所有参数和定义都已提供，问题是自洽的，没有矛盾或歧义。这是一个有效的问题。\n\n核心任务是计算两个矩阵的谱条件数 $\\kappa_2(A) = \\lambda_{\\max}(A)/\\lambda_{\\min}(A)$：未变换的Hessian矩阵 $K$ 和变换后的Hessian矩阵 $K_v$。\n提供的定义是：\n1.  未变换的Hessian矩阵：$K = B^{-1} + \\frac{1}{\\sigma_o^2} I$\n2.  变换后的Hessian矩阵：$K_v = I + \\frac{1}{\\sigma_o^2} B$\n\n这里，$B$ 是背景误差协方差矩阵，$I$ 是单位矩阵，$\\sigma_o^2$ 是观测误差方差。为了计算条件数，我们必须找到 $K$ 和 $K_v$ 的最小和最大特征值。这些可以直接与 $B$ 的特征值相关联。\n\n设 $\\{\\lambda_i(B)\\}$ 是矩阵 $B$ 的特征值集合。由于 $B$ 被构造为对称正定矩阵，其特征值为实数且为正。设 $\\lambda_{\\min}(B)$ 和 $\\lambda_{\\max}(B)$ 分别表示 $B$ 的最小和最大特征值。\n\n**$K$ 的特征值**\n\n逆矩阵 $B^{-1}$ 的特征值是 $B$ 的特征值的倒数，即 $\\{1/\\lambda_i(B)\\}$。顺序被反转，因此 $B^{-1}$ 的最大特征值是 $1/\\lambda_{\\min}(B)$，最小特征值是 $1/\\lambda_{\\max}(B)$。\n给任意矩阵加上一个缩放的单位矩阵 $\\alpha I$ 会使其特征值偏移 $\\alpha$。在我们的例子中，$\\alpha = 1/\\sigma_o^2$。\n因此，$K = B^{-1} + \\frac{1}{\\sigma_o^2} I$ 的极值特征值为：\n$$\n\\lambda_{\\max}(K) = \\lambda_{\\max}(B^{-1}) + \\frac{1}{\\sigma_o^2} = \\frac{1}{\\lambda_{\\min}(B)} + \\frac{1}{\\sigma_o^2}\n$$\n$$\n\\lambda_{\\min}(K) = \\lambda_{\\min}(B^{-1}) + \\frac{1}{\\sigma_o^2} = \\frac{1}{\\lambda_{\\max}(B)} + \\frac{1}{\\sigma_o^2}\n$$\n$K$ 的条件数则为：\n$$\n\\kappa_2(K) = \\frac{\\lambda_{\\max}(K)}{\\lambda_{\\min}(K)} = \\frac{\\frac{1}{\\lambda_{\\min}(B)} + \\frac{1}{\\sigma_o^2}}{\\frac{1}{\\lambda_{\\max}(B)} + \\frac{1}{\\sigma_o^2}}\n$$\n\n**$K_v$ 的特征值**\n\n矩阵 $\\frac{1}{\\sigma_o^2}B$ 的特征值是 $\\{\\frac{\\lambda_i(B)}{\\sigma_o^2}\\}$。加上单位矩阵 $I$ 会使这些特征值偏移 $1$。\n因此，$K_v = I + \\frac{1}{\\sigma_o^2} B$ 的极值特征值为：\n$$\n\\lambda_{\\max}(K_v) = 1 + \\frac{\\lambda_{\\max}(B)}{\\sigma_o^2}\n$$\n$$\n\\lambda_{\\min}(K_v) = 1 + \\frac{\\lambda_{\\min}(B)}{\\sigma_o^2}\n$$\n$K_v$ 的条件数则为：\n$$\n\\kappa_2(K_v) = \\frac{\\lambda_{\\max}(K_v)}{\\lambda_{\\min}(K_v)} = \\frac{1 + \\frac{\\lambda_{\\max}(B)}{\\sigma_o^2}}{1 + \\frac{\\lambda_{\\min}(B)}{\\sigma_o^2}}\n$$\n\n这种分析方法表明，我们只需要计算矩阵 $B$ 的极值特征值。计算条件数并不需要显式地构造 $B^{-1}$ 或矩阵平方根 $L=B^{1/2}$。\n\n数值实现计划如下：\n1.  定义问题参数：网格大小 $n = 64$，背景方差 $\\sigma_b^2 = 1$，以及相关长度 $\\ell = 0.2$。\n2.  在区间 $[0, 1]$ 上创建包含 $n$ 个点的一维网格。\n3.  根据其定义 $B_{ij} = \\sigma_b^2 \\exp\\left(-\\frac{|x_i - x_j|}{\\ell}\\right)$ 构建 $n \\times n$ 的背景误差协方差矩阵 $B$。\n4.  计算实对称矩阵 $B$ 的特征值。适用于对称矩阵的专门算法，如 `numpy.linalg.eigvalsh`，是合适的，因为它高效且数值稳定。该函数返回排序后的特征值。\n5.  提取最小和最大特征值 $\\lambda_{\\min}(B)$ 和 $\\lambda_{\\max}(B)$。\n6.  遍历给定的观测误差方差列表 $\\sigma_o^2 = \\{10^{-8}, 10^{-4}, 10^{-2}, 10^{0}, 10^{2}\\}$。\n7.  在每次迭代中，使用推导出的公式计算 $\\kappa_2(K)$ 和 $\\kappa_2(K_v)$。\n8.  存储每对 $[\\kappa_2(K), \\kappa_2(K_v)]$，并将最终的配对列表格式化为所需的单行字符串输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the condition numbers of the untransformed (K) and transformed (Kv)\n    Hessians for a 1D variational data assimilation problem.\n    \"\"\"\n    # 1. Define problem parameters\n    n = 64\n    sigma_b_sq = 1.0\n    l_corr = 0.2\n    \n    test_cases_sigma_o_sq = [1e-8, 1e-4, 1e-2, 1.0, 1e2]\n\n    # 2. Create the grid\n    x_grid = np.linspace(0.0, 1.0, n)\n\n    # 3. Construct the background error covariance matrix B\n    # Use broadcasting for an efficient construction of the distance matrix\n    dist_matrix = np.abs(x_grid[:, np.newaxis] - x_grid)\n    B = sigma_b_sq * np.exp(-dist_matrix / l_corr)\n    \n    # 4. Compute eigenvalues of B\n    # B is a real symmetric matrix. numpy.linalg.eigvalsh is efficient and\n    # returns sorted eigenvalues in ascending order.\n    eigvals_B = np.linalg.eigvalsh(B)\n    \n    # 5. Extract minimum and maximum eigenvalues\n    lambda_min_B = eigvals_B[0]\n    lambda_max_B = eigvals_B[-1]\n    \n    results = []\n    \n    # 6. Loop through test cases for sigma_o^2\n    for s2o in test_cases_sigma_o_sq:\n        # 7. Calculate condition number for K = B^-1 + (1/s2o) * I\n        lambda_max_K = 1.0 / lambda_min_B + 1.0 / s2o\n        lambda_min_K = 1.0 / lambda_max_B + 1.0 / s2o\n        cond_K = lambda_max_K / lambda_min_K\n        \n        # Calculate condition number for Kv = I + (1/s2o) * B\n        lambda_max_Kv = 1.0 + (1.0 / s2o) * lambda_max_B\n        lambda_min_Kv = 1.0 + (1.0 / s2o) * lambda_min_B\n        cond_Kv = lambda_max_Kv / lambda_min_Kv\n        \n        results.append([cond_K, cond_Kv])\n\n    # 8. Format the final output string as specified\n    string_parts = []\n    for res_pair in results:\n        string_parts.append(f\"[{res_pair[0]},{res_pair[1]}]\")\n    final_string = f\"[{','.join(string_parts)}]\"\n    \n    print(final_string)\n\nsolve()\n```"
        },
        {
            "introduction": "除了预条件处理，CVT的另一个关键作用是强制执行物理约束，例如确保状态变量（如浓度或温度）为正值。本练习将深入探讨这一应用，通过对比两种不同的非线性变换——经典的指数变换 $x = \\exp(z)$ 和更为现代的softplus变换 $x = \\log(1 + \\exp(z))$ ——来实施正定性约束。您需要推导并计算在这些变换下代价函数的一阶和二阶导数，并通过分析梯度饱和和曲率等指标，洞察不同变换选择对优化地形（optimization landscape）的深远影响，从而学习如何在实践中做出更优的设计决策。",
            "id": "3372041",
            "problem": "考虑一个非线性变分数据同化（DA）问题中待估计的标量正状态变量 $x \\in (0,\\infty)$。令 $z \\in \\mathbb{R}$ 为一个无约束的控制变量，它通过一个控制变量变换 $x = \\tau(z)$ 与 $x$ 相关联。变分目标函数由一个背景项和一个具有高斯误差的单非线性观测项定义：\n$$\nJ(z) = \\frac{1}{2}\\frac{\\left(x(z) - x_b\\right)^2}{\\sigma_b^2} + \\frac{1}{2}\\frac{\\left(h\\big(x(z)\\big) - y\\right)^2}{\\sigma_o^2},\n$$\n其中 $x_b \\in (0,\\infty)$ 是背景（先验）均值，$\\sigma_b^2  0$ 是背景方差， $y \\in \\mathbb{R}$ 是观测值，$\\sigma_o^2  0$ 是观测误差方差， $h:(0,\\infty)\\to\\mathbb{R}$ 是一个二次可微的观测算子。在本问题中，使用特定的非线性观测算子 $h(x) = \\sqrt{x}$。\n\n将比较两种不同的强制正定性控制变量变换：\n- Softplus 变换：$x(z) = \\log\\!\\left(1 + e^{z}\\right)$。\n- 指数对数变换：$x(z) = e^{z}$。\n\n任务：\n1. 从 $J(z)$、$h(x)$ 和上述两种变换的定义出发，仅使用标准的微分法则（包括链式法则），为每种变换推导出一阶导数 $\\frac{dJ}{dz}$ 和二阶导数 $\\frac{d^2J}{dz^2}$ 的显式表达式，两者均在任意 $z \\in \\mathbb{R}$ 处求值。\n2. 在一个程序中实现这些表达式，并对下面的测试套件中的每种变换进行求值。对于每个测试用例，计算以下两个标量诊断量：\n   - 梯度饱和比 $r_g = \\frac{\\left|\\frac{dJ}{dz}\\right|_{\\text{softplus}}}{\\left|\\frac{dJ}{dz}\\right|_{\\exp}}$。\n   - 曲率比 $r_H = \\frac{\\left.\\frac{d^2J}{dz^2}\\right|_{\\text{softplus}}}{\\left.\\frac{d^2J}{dz^2}\\right|_{\\exp}}$。\n3. 按指定顺序将所有结果报告为单个扁平列表。\n\n测试套件（每个用例是一个元组 $(z, x_b, \\sigma_b^2, y, \\sigma_o^2)$）：\n- 用例 1 (一般情况): $(0.0, 1.0, 0.25, 1.2, 0.04)$。\n- 用例 2 (强负控制，小状态): $(-20.0, 1.0, 0.25, 0.8, 0.04)$。\n- 用例 3 (强正控制，指数变换下的大状态): $(10.0, 2.0, 0.25, 100.0, 0.04)$。\n- 用例 4 (中度负控制，小状态附近的曲率): $(-5.0, 0.5, 0.25, 0.1, 0.04)$。\n\n您的程序必须输出一行，其中包含一个扁平列表，按顺序包含八个浮点数\n$$\n\\left[r_g^{(1)}, r_H^{(1)}, r_g^{(2)}, r_H^{(2)}, r_g^{(3)}, r_H^{(3)}, r_g^{(4)}, r_H^{(4)}\\right],\n$$\n其中上标指测试用例的索引。将每个数值输出四舍五入到六位小数。输出必须是单行，表示为标准的方括号形式，值之间用逗号分隔（例如，$[0.123456,0.654321,\\dots]$）。不涉及物理单位；所有量都是无量纲的实数。问题中任何地方都没有出现角度，因此不需要角度单位。",
            "solution": "该问题是有效的。它在科学上基于变分数据同化和微分学的原理，是适定的，并且提供了所有必要的信息。\n\n目标是针对两种不同的控制变量变换 $x(z)$，推导变分代价函数 $J(z)$ 关于控制变量 $z$ 的一阶和二阶导数，然后对一组测试用例评估这些导数及其比率。\n\n代价函数由以下公式给出：\n$$\nJ(z) = \\frac{1}{2}\\frac{\\left(x(z) - x_b\\right)^2}{\\sigma_b^2} + \\frac{1}{2}\\frac{\\left(h\\big(x(z)\\big) - y\\right)^2}{\\sigma_o^2}\n$$\n其中 $x$ 是状态变量，$z$ 是控制变量，$x_b$ 是背景状态，$y$ 是观测值，$\\sigma_b^2$ 和 $\\sigma_o^2$ 是方差，$h(x)$ 是观测算子。对于本问题，$h(x) = \\sqrt{x}$。\n\n$J$ 相对于 $z$ 的导数可以使用链式法则求得：\n$$\n\\frac{dJ}{dz} = \\frac{dJ}{dx} \\frac{dx}{dz}\n$$\n$$\n\\frac{d^2J}{dz^2} = \\frac{d}{dz}\\left(\\frac{dJ}{dx} \\frac{dx}{dz}\\right) = \\frac{d}{dx}\\left(\\frac{dJ}{dx}\\right) \\left(\\frac{dx}{dz}\\right) \\frac{dx}{dz} + \\frac{dJ}{dx} \\frac{d^2x}{dz^2} = \\frac{d^2J}{dx^2}\\left(\\frac{dx}{dz}\\right)^2 + \\frac{dJ}{dx}\\frac{d^2x}{dz^2}\n$$\n\n首先，我们计算 $J$ 相对于 $x$ 的导数。这些项对于两种变换都是共同的。\n$h(x) = x^{1/2}$ 的一阶导数是 $h'(x) = \\frac{d h}{d x} = \\frac{1}{2}x^{-1/2} = \\frac{1}{2\\sqrt{x}}$。\n二阶导数是 $h''(x) = \\frac{d^2 h}{d x^2} = -\\frac{1}{4}x^{-3/2} = -\\frac{1}{4x\\sqrt{x}}$。\n\n$J$ 相对于 $x$ 的一阶导数是：\n$$\n\\frac{dJ}{dx} = \\frac{x - x_b}{\\sigma_b^2} + \\frac{h(x) - y}{\\sigma_o^2} h'(x) = \\frac{x - x_b}{\\sigma_b^2} + \\frac{\\sqrt{x} - y}{\\sigma_o^2} \\frac{1}{2\\sqrt{x}} = \\frac{x - x_b}{\\sigma_b^2} + \\frac{1}{2\\sigma_o^2}\\left(1 - \\frac{y}{\\sqrt{x}}\\right)\n$$\n$J$ 相对于 $x$ 的二阶导数是：\n$$\n\\frac{d^2J}{dx^2} = \\frac{d}{dx}\\left(\\frac{dJ}{dx}\\right) = \\frac{1}{\\sigma_b^2} + \\frac{d}{dx}\\left(\\frac{1}{2\\sigma_o^2}\\left(1 - yx^{-1/2}\\right)\\right) = \\frac{1}{\\sigma_b^2} + \\frac{y}{2\\sigma_o^2} \\left(-\\frac{1}{2}x^{-3/2}\\right) = \\frac{1}{\\sigma_b^2} + \\frac{y}{4\\sigma_o^2 x^{3/2}} = \\frac{1}{\\sigma_b^2} + \\frac{y}{4x\\sqrt{x}\\sigma_o^2}\n$$\n\n现在我们为每种特定的变换推导表达式。\n\n**1. 指数对数变换：$x(z) = e^z$**\n\n该变换相对于 $z$ 的导数是：\n$$\n\\frac{dx}{dz} = e^z = x\n$$\n$$\n\\frac{d^2x}{dz^2} = e^z = x\n$$\n将这些代入链式法则公式中：\n\n一阶导数 $\\frac{dJ}{dz}$ 是：\n$$\n\\left.\\frac{dJ}{dz}\\right|_{\\exp} = \\left( \\frac{x - x_b}{\\sigma_b^2} + \\frac{1}{2\\sigma_o^2}\\left(1 - \\frac{y}{\\sqrt{x}}\\right) \\right) x\n$$\n其中 $x = e^z$。\n\n二阶导数 $\\frac{d^2J}{dz^2}$ 是：\n$$\n\\left.\\frac{d^2J}{dz^2}\\right|_{\\exp} = \\left( \\frac{1}{\\sigma_b^2} + \\frac{y}{4x\\sqrt{x}\\sigma_o^2} \\right) \\left(x\\right)^2 + \\left( \\frac{x - x_b}{\\sigma_b^2} + \\frac{1}{2\\sigma_o^2}\\left(1 - \\frac{y}{\\sqrt{x}}\\right) \\right) x\n$$\n其中 $x = e^z$。注意，第二项等于 $\\left.\\frac{dJ}{dz}\\right|_{\\exp}$。\n\n**2. Softplus 变换：$x(z) = \\log(1+e^z)$**\n\n该变换相对于 $z$ 的导数是：\n$$\n\\frac{dx}{dz} = \\frac{e^z}{1+e^z}\n$$\n这是逻辑 S 型函数，通常表示为 $\\sigma(z)$。它也可以写成 $(1+e^{-z})^{-1}$。\n\n$$\n\\frac{d^2x}{dz^2} = \\frac{d}{dz}\\left(\\frac{e^z}{1+e^z}\\right) = \\frac{e^z(1+e^z) - e^z(e^z)}{(1+e^z)^2} = \\frac{e^z}{(1+e^z)^2}\n$$\n这可以紧凑地写为 $\\frac{dx}{dz}\\left(1 - \\frac{dx}{dz}\\right)$。\n\n将这些代入链式法则公式中：\n\n一阶导数 $\\frac{dJ}{dz}$ 是：\n$$\n\\left.\\frac{dJ}{dz}\\right|_{\\text{softplus}} = \\left( \\frac{x - x_b}{\\sigma_b^2} + \\frac{1}{2\\sigma_o^2}\\left(1 - \\frac{y}{\\sqrt{x}}\\right) \\right) \\left(\\frac{e^z}{1+e^z}\\right)\n$$\n其中 $x = \\log(1+e^z)$。\n\n二阶导数 $\\frac{d^2J}{dz^2}$ 是：\n$$\n\\left.\\frac{d^2J}{dz^2}\\right|_{\\text{softplus}} = \\left( \\frac{1}{\\sigma_b^2} + \\frac{y}{4x\\sqrt{x}\\sigma_o^2} \\right) \\left(\\frac{e^z}{1+e^z}\\right)^2 + \\left( \\frac{x - x_b}{\\sigma_b^2} + \\frac{1}{2\\sigma_o^2}\\left(1 - \\frac{y}{\\sqrt{x}}\\right) \\right) \\left(\\frac{e^z}{(1+e^z)^2}\\right)\n$$\n其中 $x = \\log(1+e^z)$。\n\n这些显式表达式在提供的 Python 代码中实现，用于计算给定测试用例的梯度饱和比 $r_g$ 和曲率比 $r_H$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by deriving and evaluating derivatives for two control\n    variable transforms and computing their ratios.\n    \"\"\"\n    test_cases = [\n        # (z, x_b, sigma_b^2, y, sigma_o^2)\n        (0.0, 1.0, 0.25, 1.2, 0.04),\n        (-20.0, 1.0, 0.25, 0.8, 0.04),\n        (10.0, 2.0, 0.25, 100.0, 0.04),\n        (-5.0, 0.5, 0.25, 0.1, 0.04),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        z, xb, s2b, y, s2o = case\n\n        # --- Calculations for Exponential Transform ---\n        # x(z) and its derivatives\n        x_exp = np.exp(z)\n        dxdz_exp = x_exp\n        d2xdz2_exp = x_exp\n\n        # Derivatives of J w.r.t x, evaluated at x_exp\n        sqrt_x_exp = np.sqrt(x_exp)\n        dJdx_exp = (x_exp - xb) / s2b + (1.0 - y / sqrt_x_exp) / (2.0 * s2o)\n        d2Jdx2_exp = 1.0 / s2b + y / (4.0 * s2o * x_exp * sqrt_x_exp)\n\n        # Derivatives of J w.r.t z using the chain rule\n        dJdz_exp = dJdx_exp * dxdz_exp\n        d2Jdz2_exp = d2Jdx2_exp * (dxdz_exp**2) + dJdx_exp * d2xdz2_exp\n\n        # --- Calculations for Softplus Transform ---\n        # x(z) and its derivatives (using numerically stable forms)\n        if z  0:\n            x_soft = z + np.log(1.0 + np.exp(-z))\n        else:\n            x_soft = np.log(1.0 + np.exp(z))\n        \n        dxdz_soft = 1.0 / (1.0 + np.exp(-z))  # Stable sigmoid\n        d2xdz2_soft = dxdz_soft * (1.0 - dxdz_soft)\n        \n        # Derivatives of J w.r.t x, evaluated at x_soft\n        sqrt_x_soft = np.sqrt(x_soft)\n        dJdx_soft = (x_soft - xb) / s2b + (1.0 - y / sqrt_x_soft) / (2.0 * s2o)\n        d2Jdx2_soft = 1.0 / s2b + y / (4.0 * s2o * x_soft * sqrt_x_soft)\n\n        # Derivatives of J w.r.t z using the chain rule\n        dJdz_soft = dJdx_soft * dxdz_soft\n        d2Jdz2_soft = d2Jdx2_soft * (dxdz_soft**2) + dJdx_soft * d2xdz2_soft\n\n        # --- Compute Ratios ---\n        # Gradient saturation ratio\n        rg = np.abs(dJdz_soft) / np.abs(dJdz_exp)\n        \n        # Curvature ratio\n        rH = d2Jdz2_soft / d2Jdz2_exp\n\n        results.extend([rg, rH])\n\n    # Format the final output string\n    formatted_results = \",\".join([f\"{val:.6f}\" for val in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        }
    ]
}