{
    "hands_on_practices": [
        {
            "introduction": "We begin with a foundational building block of many electromagnetic simulations: the scalar Helmholtz Green's function, represented by a Sommerfeld-type integral. Evaluating this integral representation requires tackling an infinite domain, a potential integrable singularity, and oscillatory behavior. This first practice challenges you to develop a robust adaptive quadrature algorithm from first principles, demanding a deep dive into the analytical properties of the integrand to ensure a numerically sound solution .",
            "id": "3348842",
            "problem": "Consider a homogeneous, isotropic medium characterized by a complex wavenumber $k \\in \\mathbb{C}$, and the scalar Helmholtz Green's function for a source at the origin. By separation of variables in cylindrical coordinates and the spectral representation compatible with Maxwell's equations, one arrives at the Sommerfeld-type integral representation for the scalar Green's function with axial separation $z  0$ and transverse separation $\\rho \\ge 0$:\n$$\nG(\\rho,z;k) = \\frac{i}{4\\pi} \\int_{0}^{\\infty} \\frac{k_\\rho}{k_z(k_\\rho)} J_0(k_\\rho \\rho) e^{i k_z(k_\\rho) z} \\, \\mathrm{d}k_\\rho,\n$$\nwhere $J_0(\\cdot)$ is the Bessel function of the first kind of order zero, and $k_z(k_\\rho)$ is the longitudinal spectral wavenumber defined by the principal branch of\n$$\nk_z(k_\\rho) = \\sqrt{k^2 - k_\\rho^2},\n$$\nwith the branch chosen so that $\\operatorname{Im}\\{k_z(k_\\rho)\\} \\ge 0$. The integrand changes character at the branch point $k_\\rho = |k|$ when $k$ is real and positive: for $k_\\rho  |k|$ one has $\\operatorname{Im}\\{k_z\\} = 0$ (oscillatory propagating spectrum), while for $k_\\rho  |k|$ one has $\\operatorname{Im}\\{k_z\\}  0$ (evanescent spectrum leading to decay in $z$). For complex $k$ with $\\operatorname{Im}\\{k\\}  0$, the integrand acquires additional decay.\n\nYour task is to design and implement an adaptive numerical algorithm with parameter tuning to evaluate the real part of $G(\\rho,z;k)$ for a set of test cases. The algorithm must be derived from first principles and incorporate all of the following features:\n\n- An adaptive splitting strategy that accounts for the change of integrand character across the branch point. You must ensure numerical stability near $k_\\rho \\approx |k|$ where the factor $k_\\rho/k_z(k_\\rho)$ yields an integrable square-root singularity.\n- A tail truncation parameter for the upper limit of integration on $k_\\rho \\in [0,\\infty)$ derived from a rigorous bound on the evanescent contribution beyond a cutoff $L$. You must choose $L$ so that a mathematically justified upper bound on the tail remainder is less than a specified tolerance.\n- Parameter tuning of local tolerances and integration subintervals depending on $(\\rho,z,k)$, so that the algorithm remains efficient across highly oscillatory ($\\rho$ large, real $k$) and strongly decaying (evanescent or complex $k$) regimes.\n- A verified branch selection for $k_z(k_\\rho)$ that enforces $\\operatorname{Im}\\{k_z(k_\\rho)\\} \\ge 0$.\n\nStart from the scalar Helmholtz equation and the definition of the spectral Green's function. Justify the branch choice for $k_z(k_\\rho)$ and derive a practical, computable upper bound for the truncation error of the evanescent tail. Based on these principles, specify your adaptive algorithm and its parameter tuning rules.\n\nImplement the algorithm as a complete, runnable program that computes the real part of $G(\\rho,z;k)$ for the following test suite. All quantities are dimensionless (no physical units are used), and angles are not involved.\n\nTest Suite:\n1. $(\\rho, z, k) = (0.5, 0.4, 2.0)$\n2. $(\\rho, z, k) = (5.0, 0.4, 2.0)$\n3. $(\\rho, z, k) = (1.0, 0.2, 2.0 + 0.3 i)$\n4. $(\\rho, z, k) = (0.05, 0.8, 8.0)$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a floating-point number equal to the real part of $G(\\rho,z;k)$ for the corresponding test case, computed to within an absolute tolerance of $10^{-6}$. For example:\n\"[result1,result2,result3,result4]\"\n\nThe algorithmic choices and bounds you use must be scientifically sound and consistent with the integral definition above. No hard-coded shortcuts or closed-form identities for $G(\\rho,z;k)$ are permitted.",
            "solution": "The problem requires the design and implementation of an adaptive numerical algorithm to compute the real part of the scalar Helmholtz Green's function, given by the Sommerfeld-type integral:\n$$\nG(\\rho,z;k) = \\frac{i}{4\\pi} \\int_{0}^{\\infty} \\frac{k_\\rho}{k_z(k_\\rho)} J_0(k_\\rho \\rho) e^{i k_z(k_\\rho) z} \\, \\mathrm{d}k_\\rho\n$$\nThis integral representation arises from solving the scalar Helmholtz equation, $(\\nabla^2 + k^2)G(\\mathbf{r}; k) = -\\delta(\\mathbf{r})$, in cylindrical coordinates $(\\rho, \\phi, z)$ by applying a Fourier-Bessel transform (also known as the Hankel transform). The transform converts the partial differential equation in $(\\rho, z)$ into an ordinary differential equation in $z$ for each spectral component $k_\\rho$. The solution to this ODE, under the Sommerfeld radiation condition, yields the exponential term $e^{i k_z z}$, and applying the inverse transform leads to the integral expression above.\n\nThe numerical evaluation of this integral is non-trivial due to three main challenges, which our algorithm must address from first principles:\n1. The infinite domain of integration, $[0, \\infty)$.\n2. The integrand's slowly decaying and oscillatory nature, primarily due to the Bessel function $J_0(k_\\rho \\rho)$.\n3. The presence of a branch point in the definition of $k_z(k_\\rho) = \\sqrt{k^2 - k_\\rho^2}$, which can lead to an integrable singularity on the integration path.\n\nOur approach is to develop a robust adaptive quadrature scheme based on a precise analysis of the integrand's properties.\n\n**1. Branch Selection for the Longitudinal Wavenumber $k_z(k_\\rho)$**\n\nThe longitudinal wavenumber $k_z$ is defined by $k_z(k_\\rho) = \\sqrt{k^2 - k_\\rho^2}$. The square root function is multi-valued. The physically correct branch is constrained by the condition that the field must decay for $z \\to \\infty$. This implies that the waves corresponding to the spectral components must either propagate away from the source plane or be evanescent (decaying). Mathematically, this translates to the requirement $\\operatorname{Im}\\{k_z(k_\\rho)\\} \\ge 0$ for all real $k_\\rho \\ge 0$.\n\nLet $Z(k_\\rho) = k^2 - k_\\rho^2$. The standard principal branch of the square root, as implemented in most numerical libraries (e.g., `numpy.sqrt`), returns a value $w = \\sqrt{Z}$ such that $\\operatorname{Re}\\{w\\} \\ge 0$. This does not guarantee $\\operatorname{Im}\\{w\\} \\ge 0$. For any non-zero complex number $Z$, there are two square roots, $w$ and $-w$. If $w = u+iv$, then $-w = -u-iv$. Since the imaginary parts have opposite signs (unless $v=0$), one of them must be non-negative.\nTherefore, our procedure to enforce the correct branch is as follows:\n1. Compute the principal square root, $w = \\sqrt{k^2 - k_\\rho^2}$.\n2. If $\\operatorname{Im}\\{w\\}  0$, select the other root, $k_z = -w$.\n3. Otherwise, select $k_z = w$.\nThis procedure guarantees that $\\operatorname{Im}\\{k_z\\} \\ge 0$ for all $k_\\rho$, ensuring the convergence of the integral for $z  0$ as the term $e^{i k_z z} = e^{i (\\operatorname{Re}\\{k_z\\}) z} e^{-(\\operatorname{Im}\\{k_z\\}) z}$ will decay.\n\n**2. Integrand Behavior and Adaptive Splitting**\n\nThe integrand's character changes significantly around $k_\\rho = |k|$.\nLet $k$ be a real positive number for clarity.\n- For $0 \\le k_\\rho  k$, $k^2 - k_\\rho^2  0$, so $k_z = \\sqrt{k^2 - k_\\rho^2}$ is real and positive. The term $e^{i k_z z}$ is purely oscillatory, representing propagating waves.\n- For $k_\\rho  k$, $k^2 - k_\\rho^2  0$, so $k_z = \\sqrt{-(k_\\rho^2 - k^2)} = i\\sqrt{k_\\rho^2 - k^2}$ is purely imaginary and positive (by our branch choice). The term $e^{i k_z z} = e^{-\\sqrt{k_\\rho^2 - k^2}z}$ is purely decaying, representing evanescent waves.\n- At $k_\\rho = k$, $k_z = 0$. The factor $1/k_z$ in the integrand creates a square-root singularity, as $1/k_z \\sim 1/\\sqrt{k-k_\\rho}$ as $k_\\rho \\to k^-$. This singularity is integrable.\n\nIf $k$ is complex ($k = k_r + i k_i$ with $k_i  0$), $k_z$ is always complex with a positive imaginary part, so the singularity does not lie on the real-$k_\\rho$ integration axis. However, the point $k_\\rho = |k|$ still marks a transition in the asymptotic behavior of the integrand.\n\nTo handle these behaviors robustly, a numerical quadrature routine should be made aware of this critical point. We will use `scipy.integrate.quad`, which is an adaptive routine based on QUADPACK. By providing the point $k_\\rho = |k|$ via the `points` argument, we instruct the routine to split the integration interval at this location and apply appropriate quadrature rules to handle the singularity (if present) and the change in the integrand's nature. This constitutes our adaptive splitting strategy.\n\n**3. Tail Truncation and Error Bound**\n\nThe integral is over $[0, \\infty)$. We must truncate this to a finite interval $[0, L]$ for numerical computation. The truncation limit $L$ must be chosen such that the error from omitting the tail integral is less than a specified tolerance $\\epsilon_{\\text{tail}}$.\nThe tail integral is $T = \\frac{i}{4\\pi} \\int_{L}^{\\infty} \\frac{k_\\rho}{k_z} J_0(k_\\rho \\rho) e^{i k_z z} \\, \\mathrm{d}k_\\rho$.\nWe seek an upper bound for $|T|$. For large $k_\\rho \\gg |k|$, we have the following approximations:\n- $k_z(k_\\rho) = \\sqrt{k^2 - k_\\rho^2} = i k_\\rho \\sqrt{1 - k^2/k_\\rho^2} \\approx i k_\\rho$. Our branch condition is satisfied since $k_\\rho  0$.\n- $|\\frac{k_\\rho}{k_z(k_\\rho)}| \\approx |\\frac{k_\\rho}{i k_\\rho}| = 1$.\n- $|J_0(k_\\rho \\rho)| \\le 1$. This is a simple, effective bound.\n- $|e^{i k_z z}| = e^{-\\operatorname{Im}\\{k_z\\}z}$. With $\\operatorname{Im}\\{k_z\\} \\approx k_\\rho$, this becomes $|e^{i k_z z}| \\approx e^{-k_\\rho z}$.\n\nCombining these bounds, the magnitude of the tail integral is bounded by:\n$$\n|T| \\le \\frac{1}{4\\pi} \\int_{L}^{\\infty} \\left| \\frac{k_\\rho}{k_z} \\right| |J_0(k_\\rho \\rho)| |e^{i k_z z}| \\, \\mathrm{d}k_\\rho \\approx \\frac{1}{4\\pi} \\int_{L}^{\\infty} (1) \\cdot (1) \\cdot e^{-k_\\rho z} \\, \\mathrm{d}k_\\rho\n$$\nEvaluating the approximate bounding integral:\n$$\n\\frac{1}{4\\pi} \\int_{L}^{\\infty} e^{-k_\\rho z} \\, \\mathrm{d}k_\\rho = \\frac{1}{4\\pi} \\left[ -\\frac{1}{z} e^{-k_\\rho z} \\right]_{L}^{\\infty} = \\frac{e^{-Lz}}{4\\pi z}\n$$\nWe require this bound to be less than our tail tolerance $\\epsilon_{\\text{tail}}$:\n$$\n\\frac{e^{-Lz}}{4\\pi z} \\le \\epsilon_{\\text{tail}} \\implies e^{-Lz} \\le 4\\pi z \\epsilon_{\\text{tail}} \\implies -Lz \\le \\ln(4\\pi z \\epsilon_{\\text{tail}})\n$$\nSolving for $L$ gives the required truncation limit:\n$$\nL \\ge \\frac{1}{z} \\ln\\left(\\frac{1}{4\\pi z \\epsilon_{\\text{tail}}}\\right)\n$$\nThis formula provides a rigorous basis for choosing $L$ adaptively based on the observation height $z$ and the desired accuracy.\n\n**4. Algorithmic Summary and Parameter Tuning**\n\nThe complete algorithm to compute $\\operatorname{Re}\\{G(\\rho,z;k)\\}$ to an absolute tolerance $\\epsilon$ is as follows:\n\n1.  **Set Tolerances**: Choose a total absolute tolerance $\\epsilon$ (e.g., $10^{-6}$). Set the tail truncation tolerance to a fraction of this, e.g., $\\epsilon_{\\text{tail}} = \\epsilon/10$. The tolerance for the quadrature routine, `epsabs`, which is an error estimate on the computed integral value, will be set to $\\epsilon \\cdot 4\\pi$.\n2.  **Determine Integration Limit $L$**: Calculate $L$ using the derived formula: $L = \\frac{1}{z} \\ln\\left(\\frac{1}{4\\pi z \\epsilon_{\\text{tail}}}\\right)$. To ensure the validity of the asymptotic approximations used in the derivation, we enforce a minimum value for $L$, such as $L = \\max(L, 2|k| + 20)$.\n3.  **Define Integrand**: The quantity to be computed is $\\operatorname{Re}\\{G\\} = \\operatorname{Re}\\{\\frac{i}{4\\pi} \\mathcal{I}\\} = -\\frac{1}{4\\pi} \\operatorname{Im}\\{\\mathcal{I}\\}$, where $\\mathcal{I}$ is the integral. We define a function for `scipy.integrate.quad` that computes $\\operatorname{Im}\\{\\frac{k_\\rho}{k_z} J_0(k_\\rho \\rho) e^{i k_z z}\\}$, with $k_z$ determined using the verified branch selection logic.\n4.  **Tune Quadrature Parameters**:\n    -   **Singularity Handling**: The point $k_\\rho = |k|$ is passed to the `points` argument of `quad` if it falls within the integration interval $[0, L]$.\n    -   **Oscillations**: For cases with large $\\rho$, the Bessel function $J_0(k_\\rho \\rho)$ is highly oscillatory. The number of oscillations over $[0,L]$ is proportional to $L\\rho$. If $L\\rho$ exceeds a threshold (e.g., $100$), we increase the maximum number of subintervals for `quad` (the `limit` parameter) to ensure convergence.\n5.  **Compute and Finalize**: Call `scipy.integrate.quad` with the defined integrand, limits $[0, L]$, and tuned parameters. The final result is the returned integral value multiplied by $-1/(4\\pi)$.\n\nThis principle-based design yields an algorithm that is adaptive, stable, and efficient across different physical regimes.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import j0\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (rho, z, k)\n    test_cases = [\n        (0.5, 0.4, 2.0 + 0.0j),\n        (5.0, 0.4, 2.0 + 0.0j),\n        (1.0, 0.2, 2.0 + 0.3j),\n        (0.05, 0.8, 8.0 + 0.0j),\n    ]\n\n    results = []\n    # Absolute tolerance for the final result, as specified in the problem.\n    absolute_tolerance = 1e-6\n    \n    for rho, z, k in test_cases:\n        # Calculate the real part of the Green's function for the current case.\n        val = calculate_G_real(rho, z, k, absolute_tolerance)\n        results.append(f\"{val:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_G_real(rho, z, k, tol):\n    \"\"\"\n    Calculates the real part of the Sommerfeld integral G(rho, z, k)\n    using an adaptive numerical quadrature algorithm.\n\n    Args:\n        rho (float): Transverse separation.\n        z (float): Axial separation.\n        k (complex): Complex wavenumber of the medium.\n        tol (float): Desired absolute tolerance for the final result.\n\n    Returns:\n        float: The computed real part of G(rho, z, k).\n    \"\"\"\n\n    # --- Step 1: Define the complex integrand F(k_rho) ---\n    # G = (i / 4pi) * Integral(F(k_rho) d(k_rho))\n    def complex_integrand(k_rho, rho, z, k):\n        \"\"\"\n        The complex function inside the Sommerfeld integral.\n        \"\"\"\n        # The numerator contains k_rho, so if k_rho is 0, the integrand is 0.\n        if k_rho == 0.0:\n            return 0.0j\n\n        # --- Branch Selection for k_z ---\n        # Calculate k_z^2 = k^2 - k_rho^2\n        k_z_sq = k**2 - k_rho**2\n        \n        # Compute principal square root\n        k_z = np.sqrt(k_z_sq)\n        \n        # Enforce the branch condition Im{k_z} = 0\n        if k_z.imag  0:\n            k_z = -k_z\n        \n        # If k_z is numerically zero (at a singularity), quad will handle it,\n        # so we avoid explicit division by zero checks which can be problematic.\n        \n        # Assemble the integrand components\n        factor = k_rho / k_z\n        bessel_term = j0(k_rho * rho)\n        exp_term = np.exp(1j * k_z * z)\n        \n        return factor * bessel_term * exp_term\n\n    # We need to compute Re{G}.\n    # G = (i / 4pi) * Integral(F_re + i*F_im)\n    # Re{G} = Re{(i*Integral(F_re) - Integral(F_im)) / 4pi} = -Integral(F_im) / 4pi\n    # So, we need to integrate the imaginary part of complex_integrand.\n    def integrand_for_quad(k_rho, rho, z, k):\n        return complex_integrand(k_rho, rho, z, k).imag\n\n    # --- Step 2: Tail Truncation ---\n    # Set tail tolerance as a fraction of the total tolerance.\n    tail_tol = tol / 10.0\n    \n    # Calculate truncation limit L based on the derived bound.\n    # L = (1/z) * ln(1 / (4*pi*z*tail_tol))\n    # log_arg must be  1 for log to be positive.\n    log_arg = 1.0 / (4.0 * np.pi * z * tail_tol)\n    if log_arg = 1.0:\n        # This case can occur if z is very large, making the tail decay extremely fast.\n        # A sensible default range is sufficient.\n        L = 2.0 * np.abs(k) + 20.0\n    else:\n        L = (1.0 / z) * np.log(log_arg)\n    \n    # Add a safety margin to L to ensure the asymptotic regime is reached.\n    L = max(L, 2.0 * np.abs(k) + 20.0)\n\n    # --- Step 3: Parameter Tuning for Quadrature ---\n    # The point k_rho = |k| marks a change in integrand character (and a singularity for real k)\n    split_point = np.abs(k)\n    integration_points = []\n    if 0  split_point  L:\n        integration_points.append(split_point)\n\n    # Tune the number of subdivisions based on oscillatory behavior (large L*rho).\n    # The number of oscillations of J0 is proportional to L*rho.\n    limit = 50\n    if L * rho  100:  # Heuristic for highly oscillatory cases\n        limit = 200\n        \n    # The tolerance for quad is on the integral value, not the final result.\n    # We scale the desired final tolerance by the constant factor.\n    quad_abs_tol = tol * 4.0 * np.pi\n\n    # --- Step 4: Perform Integration ---\n    integral_val, _ = quad(\n        integrand_for_quad,\n        0, L,\n        args=(rho, z, k),\n        points=integration_points,\n        epsabs=quad_abs_tol,\n        epsrel=1e-9,  # Use a tight relative tolerance for accuracy.\n        limit=limit\n    )\n\n    # --- Step 5: Compute Final Result ---\n    # Re{G} = -Integral(Im{F}) / (4*pi)\n    final_result = -integral_val / (4.0 * np.pi)\n\n    return final_result\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Building on the fundamentals of numerical quadrature, we now advance to the more complex scenario of wave propagation in a layered medium. The integrand now contains Fresnel reflection coefficients, which can introduce significant numerical stability challenges, especially for high-contrast materials. This practice introduces the powerful technique of deforming the integration path into the complex plane to tame the integrand's behavior, guiding you to find an optimal path that minimizes a numerical condition number and ensures a stable computation .",
            "id": "3348833",
            "problem": "Consider a two-dimensional spectral integral representation of the electromagnetic field in a homogeneous half-space layered medium. The fundamental base is Maxwell’s equations in the frequency domain in a source-free region, which imply the vector Helmholtz equation for each homogeneous layer. Let the upper half-space be medium $1$ with complex permittivity $\\epsilon_1$ and the lower half-space be medium $2$ with complex permittivity $\\epsilon_2$. Assume isotropic, non-magnetic media with permeability $\\mu_1 = \\mu_0$ and $\\mu_2 = \\mu_0$, where $\\mu_0$ is the vacuum permeability. Let the angular frequency be $\\omega$, with $\\omega = 2\\pi f$ and $f$ the frequency in hertz. The vacuum permittivity is $\\epsilon_0$.\n\nThe spectral (Sommerfeld) integrals for planar layered media involve the transverse spectral variable $k_\\rho$ and vertical wavenumbers $k_{zj}$ defined by the dispersion relation. For each medium $j \\in \\{1,2\\}$, the complex permittivity is modeled by the loss-tangent form\n$$\n\\epsilon_j = \\epsilon_0 \\, \\epsilon_{rj} \\left(1 - i \\tan\\delta_j\\right),\n$$\nand the medium wavenumber is\n$$\nk_j = \\omega \\sqrt{\\mu_0 \\epsilon_j}.\n$$\nFor a complex-plane contour tilt, parametrize the transverse spectral variable by\n$$\nk_\\rho(t,\\alpha) = t\\, e^{i\\alpha}, \\quad t \\in [0, t_{\\max}],\n$$\nwith a real tilt angle $\\alpha$ (in radians) and a finite truncation $t_{\\max}$. The vertical wavenumbers satisfy\n$$\nk_{zj}(t,\\alpha) = \\sqrt{k_j^2 - k_\\rho^2(t,\\alpha)},\n$$\nwith the radiation condition enforced by choosing the branch such that $\\Im\\{k_{zj}(t,\\alpha)\\} \\ge 0$.\n\nIn layered media, the integrand of Sommerfeld-type representations contains multiplicative factors including the Fresnel reflection coefficients for Transverse Magnetic (TM) and Transverse Electric (TE) polarizations, defined by boundary conditions on the tangential field components. With $\\mu_1 = \\mu_2 = \\mu_0$, these are\n$$\nR_{\\mathrm{TM}}(t,\\alpha) = \\frac{\\epsilon_2\\, k_{z1}(t,\\alpha) - \\epsilon_1\\, k_{z2}(t,\\alpha)}{\\epsilon_2\\, k_{z1}(t,\\alpha) + \\epsilon_1\\, k_{z2}(t,\\alpha)},\n\\qquad\nR_{\\mathrm{TE}}(t,\\alpha) = \\frac{k_{z1}(t,\\alpha) - k_{z2}(t,\\alpha)}{k_{z1}(t,\\alpha) + k_{z2}(t,\\alpha)}.\n$$\nFor observation height $z  0$ in medium $1$, a typical exponential factor from the vertical phase is $\\exp\\!\\left(i k_{z1}(t,\\alpha)\\, z\\right)$, whose magnitude is $\\exp\\!\\left(-\\Im\\{k_{z1}(t,\\alpha)\\} z\\right)$.\n\nDefine the multiplicative factor magnitudes\n$$\nF_{\\mathrm{TM}}(t,\\alpha) = \\left|R_{\\mathrm{TM}}(t,\\alpha)\\right| \\, \\exp\\!\\left(-\\Im\\{k_{z1}(t,\\alpha)\\}\\, z\\right),\n\\qquad\nF_{\\mathrm{TE}}(t,\\alpha) = \\left|R_{\\mathrm{TE}}(t,\\alpha)\\right| \\, \\exp\\!\\left(-\\Im\\{k_{z1}(t,\\alpha)\\}\\, z\\right).\n$$\nTo quantify stability, define condition numbers over the sampled interval $t \\in [0,t_{\\max}]$ as\n$$\n\\kappa_{\\mathrm{TM}}(\\alpha) = \\frac{\\max_{t \\in [0,t_{\\max}]} F_{\\mathrm{TM}}(t,\\alpha)}{\\min_{t \\in [0,t_{\\max}]} F_{\\mathrm{TM}}(t,\\alpha)},\n\\qquad\n\\kappa_{\\mathrm{TE}}(\\alpha) = \\frac{\\max_{t \\in [0,t_{\\max}]} F_{\\mathrm{TE}}(t,\\alpha)}{\\min_{t \\in [0,t_{\\max}]} F_{\\mathrm{TE}}(t,\\alpha)}.\n$$\nUse the worst-polarization condition number\n$$\n\\kappa(\\alpha) = \\max\\!\\left\\{\\kappa_{\\mathrm{TM}}(\\alpha),\\, \\kappa_{\\mathrm{TE}}(\\alpha)\\right\\}.\n$$\nThe task is to design and implement a numerical stability analysis, for layered media with high contrast $\\left|\\epsilon_2/\\epsilon_1\\right| \\gg 1$, that identifies the optimal contour tilt $\\alpha$ in a bounded interval $\\alpha \\in [0,\\alpha_{\\max}]$ minimizing $\\kappa(\\alpha)$.\n\nYour program must:\n- Implement the above definitions exactly, enforce the radiation condition $\\Im\\{k_{zj}\\} \\ge 0$, and evaluate $\\kappa(\\alpha)$ by sampling $t$ uniformly on $[0,t_{\\max}]$.\n- Perform a grid search over $\\alpha \\in [0,\\alpha_{\\max}]$ with step $\\Delta\\alpha$, and return the minimizing tilt $\\alpha^\\star$ and the minimum worst-polarization condition number $\\kappa(\\alpha^\\star)$ for each test case.\n\nPhysical units:\n- Frequency $f$ is in hertz.\n- Height $z$ is in meters.\n- Angles $\\alpha$, $\\alpha_{\\max}$, and $\\Delta\\alpha$ are in radians.\n\nDefine $t_{\\max}$ for each test case by $t_{\\max} = \\gamma \\left|k_1\\right|$, where $\\gamma  0$ is a given scalar and $k_1$ is the wavenumber in medium $1$.\n\nTest Suite:\n- Case $1$ (dielectric contrast, water-like lower medium):\n  - $\\epsilon_{r1} = 1.0$, $\\tan\\delta_1 = 1.0\\times 10^{-4}$,\n  - $\\epsilon_{r2} = 80.0$, $\\tan\\delta_2 = 1.0\\times 10^{-2}$,\n  - $f = 1.0\\times 10^{8}\\,\\mathrm{Hz}$,\n  - $z = 0.5\\,\\mathrm{m}$,\n  - $\\gamma = 6.0$,\n  - $\\alpha_{\\max} = 0.6\\,\\mathrm{rad}$,\n  - $N_t = 512$ samples of $t$,\n  - $\\Delta\\alpha = 0.01\\,\\mathrm{rad}$.\n- Case $2$ (metal-like lower medium with negative permittivity):\n  - $\\epsilon_{r1} = 1.0$, $\\tan\\delta_1 = 1.0\\times 10^{-4}$,\n  - $\\epsilon_{r2} = -10.0$, $\\tan\\delta_2 = 1.0\\times 10^{-1}$,\n  - $f = 3.0\\times 10^{8}\\,\\mathrm{Hz}$,\n  - $z = 0.02\\,\\mathrm{m}$,\n  - $\\gamma = 8.0$,\n  - $\\alpha_{\\max} = 0.7\\,\\mathrm{rad}$,\n  - $N_t = 700$,\n  - $\\Delta\\alpha = 0.01\\,\\mathrm{rad}$.\n- Case $3$ (extreme high-permittivity lower medium at lower frequency):\n  - $\\epsilon_{r1} = 1.0$, $\\tan\\delta_1 = 1.0\\times 10^{-4}$,\n  - $\\epsilon_{r2} = 2000.0$, $\\tan\\delta_2 = 1.0\\times 10^{-3}$,\n  - $f = 1.0\\times 10^{6}\\,\\mathrm{Hz}$,\n  - $z = 0.1\\,\\mathrm{m}$,\n  - $\\gamma = 4.0$,\n  - $\\alpha_{\\max} = 0.6\\,\\mathrm{rad}$,\n  - $N_t = 600$,\n  - $\\Delta\\alpha = 0.01\\,\\mathrm{rad}$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list $[\\alpha^\\star, \\kappa(\\alpha^\\star)]$. For example: $[[\\alpha^\\star_1,\\kappa_1],[\\alpha^\\star_2,\\kappa_2],[\\alpha^\\star_3,\\kappa_3]]$.",
            "solution": "The user-provided problem has been validated and is deemed **valid**. It is scientifically grounded in classical electromagnetism, specifically the theory of wave propagation in layered media. The problem is well-posed, providing all necessary definitions and parameters to execute a numerical optimization procedure. The objective—to find an optimal integration path tilt angle to minimize a numerical condition number—is a standard and practical problem in computational electromagnetics for the evaluation of Sommerfeld integrals.\n\nThe solution proceeds as follows:\n\n**1. Foundational Physical and Mathematical Model**\nThe problem is situated in the frequency domain, governed by Maxwell's equations. The core task is related to the numerical evaluation of spectral integrals (Sommerfeld integrals) that arise when representing fields from sources in layered media. The integrand of these integrals contains various factors, two of which are analyzed here: the Fresnel reflection coefficients and an exponential phase factor.\n\nFirst, we establish the physical constants and medium parameters. The vacuum permeability $\\mu_0$ and permittivity $\\epsilon_0$ are fundamental constants. The angular frequency $\\omega$ is calculated from the given frequency $f$ as $\\omega = 2\\pi f$.\n\nFor each medium $j \\in \\{1,2\\}$, the complex permittivity $\\epsilon_j$ is defined by its relative permittivity $\\epsilon_{rj}$ and loss tangent $\\tan\\delta_j$:\n$$\n\\epsilon_j = \\epsilon_0 \\, \\epsilon_{rj} (1 - i \\tan\\delta_j)\n$$\nwhere $i$ is the imaginary unit. This model accounts for dielectric losses in the media. The corresponding complex wavenumber for each medium is:\n$$\nk_j = \\omega \\sqrt{\\mu_0 \\epsilon_j}\n$$\nThe complex square root implies that $k_j$ will generally have both a real and an imaginary part, with $\\Im\\{k_j\\}  0$ for lossy media.\n\n**2. Spectral Variable Parametrization and the Radiation Condition**\nThe electromagnetic fields are represented as an integral over a spectrum of plane waves, indexed by the transverse spectral variable $k_\\rho$. For numerical stability and convergence, the integration path in the complex $k_\\rho$-plane is often deformed away from the real axis. The problem specifies a simple linear tilt:\n$$\nk_\\rho(t,\\alpha) = t\\, e^{i\\alpha}\n$$\nwhere $t$ is a real parameter representing the distance along the tilted contour, and $\\alpha$ is the real tilt angle. The integration range for $t$ is truncated at $t_{\\max} = \\gamma |k_1|$, where $\\gamma$ is a given scaling factor.\n\nFor each value of $k_\\rho$, the vertical component of the wavevector in medium $j$, denoted $k_{zj}$, is determined by the dispersion relation:\n$$\nk_{zj}^2 + k_\\rho^2 = k_j^2 \\implies k_{zj} = \\sqrt{k_j^2 - k_\\rho^2}\n$$\nThe square root introduces a branch-cut ambiguity. This is resolved by enforcing the radiation condition, which dictates that fields must remain bounded far from their source. For the vertical direction, this translates to the mathematical requirement that the imaginary part of the vertical wavenumber must be non-negative:\n$$\n\\Im\\{k_{zj}\\} \\ge 0\n$$\nIn implementation, after calculating a principal value for the square root, its sign is adjusted if its imaginary part is negative to satisfy this condition.\n\n**3. Numerical Stability Metric: The Condition Number**\nThe stability of the numerical integration is related to the dynamic range of the integrand's magnitude. The problem defines a multiplicative factor $F$ which captures the dominant sources of this variation: the Fresnel reflection coefficients ($R_{\\mathrm{TM}}$, $R_{\\mathrm{TE}}$) and the exponential decay associated with the observation height $z$.\n\nThe Fresnel reflection coefficients for Transverse Magnetic (TM) and Transverse Electric (TE) polarizations at the interface between medium 1 and 2 are:\n$$\nR_{\\mathrm{TM}}(t,\\alpha) = \\frac{\\epsilon_2\\, k_{z1}(t,\\alpha) - \\epsilon_1\\, k_{z2}(t,\\alpha)}{\\epsilon_2\\, k_{z1}(t,\\alpha) + \\epsilon_1\\, k_{z2}(t,\\alpha)}, \\qquad R_{\\mathrm{TE}}(t,\\alpha) = \\frac{k_{z1}(t,\\alpha) - k_{z2}(t,\\alpha)}{k_{z1}(t,\\alpha) + k_{z2}(t,\\alpha)}\n$$\nThe exponential factor for an observation point at height $z  0$ in medium 1 arises from the vertical propagation term $\\exp(i k_{z1} z)$. Its magnitude contributes to the integrand's behavior:\n$$\n\\left| \\exp(i k_{z1} z) \\right| = \\left| \\exp(i (\\Re\\{k_{z1}\\} + i\\Im\\{k_{z1}\\}) z) \\right| = \\left| \\exp(i \\Re\\{k_{z1}\\} z) \\exp(-\\Im\\{k_{z1}\\} z) \\right| = \\exp(-\\Im\\{k_{z1}\\} z)\n$$\nThe multiplicative factor magnitudes are thus defined as:\n$$\nF_{\\mathrm{TM}}(t,\\alpha) = |R_{\\mathrm{TM}}(t,\\alpha)| \\, \\exp(-\\Im\\{k_{z1}(t,\\alpha)\\}\\, z)\n$$\n$$\nF_{\\mathrm{TE}}(t,\\alpha) = |R_{\\mathrm{TE}}(t,\\alpha)| \\, \\exp(-\\Im\\{k_{z1}(t,\\alpha)\\}\\, z)\n$$\nA condition number $\\kappa$ is defined as the ratio of the maximum to the minimum value of this factor magnitude along the integration path for a given tilt $\\alpha$. A smaller condition number implies a more benign integrand for numerical quadrature.\n$$\n\\kappa_{\\mathrm{TM}}(\\alpha) = \\frac{\\max_{t \\in [0,t_{\\max}]} F_{\\mathrm{TM}}(t,\\alpha)}{\\min_{t \\in [0,t_{\\max}]} F_{\\mathrm{TM}}(t,\\alpha)}, \\qquad \\kappa_{\\mathrm{TE}}(\\alpha) = \\frac{\\max_{t \\in [0,t_{\\max}]} F_{\\mathrm{TE}}(t,\\alpha)}{\\min_{t \\in [0,t_{\\max}]} F_{\\mathrm{TE}}(t,\\alpha)}\n$$\nThe final metric is the worst-case condition number across both polarizations:\n$$\n\\kappa(\\alpha) = \\max\\{\\kappa_{\\mathrm{TM}}(\\alpha),\\, \\kappa_{\\mathrm{TE}}(\\alpha)\\}\n$$\n\n**4. Optimization Algorithm: Grid Search**\nThe objective is to find the optimal tilt angle $\\alpha^\\star$ that minimizes $\\kappa(\\alpha)$. The problem specifies a direct numerical approach: a grid search.\nThe algorithm is as follows for each test case:\n1.  Define a grid of candidate angles $\\alpha$ from $0$ to $\\alpha_{\\max}$ with a step of $\\Delta\\alpha$.\n2.  For each angle $\\alpha$ in the grid:\n    a.  Define a uniform sampling of $N_t$ points for the parameter $t$ on the interval $[0, t_{\\max}]$, where $t_{\\max} = \\gamma |k_1|$.\n    b.  For this set of $t$ values, compute the vectors of $k_\\rho$, $k_{z1}$, and $k_{z2}$, ensuring the radiation condition $\\Im\\{k_{zj}\\} \\ge 0$ is enforced for all elements of the $k_{z1}$ and $k_{z2}$ vectors.\n    c.  Calculate the vectors of values for $F_{\\mathrm{TM}}(t, \\alpha)$ and $F_{\\mathrm{TE}}(t, \\alpha)$.\n    d.  Find the maximum and minimum of each vector to compute $\\kappa_{\\mathrm{TM}}(\\alpha)$ and $\\kappa_{\\mathrm{TE}}(\\alpha)$.\n    e.  Determine $\\kappa(\\alpha) = \\max\\{\\kappa_{\\mathrm{TM}}(\\alpha), \\kappa_{\\mathrm{TE}}(\\alpha)\\}$.\n3.  After iterating through all angles, identify the angle $\\alpha^\\star$ that yielded the smallest value of $\\kappa(\\alpha)$.\n4.  The final result for the test case is the pair $[\\alpha^\\star, \\kappa(\\alpha^\\star)]$.\n\nThis procedure is implemented for each provided test case, leveraging vectorized computations with NumPy for efficiency.",
            "answer": "```python\nimport numpy as np\nfrom scipy.constants import mu_0, epsilon_0\n\ndef solve():\n    \"\"\"\n    Main function to run the stability analysis for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            # Case 1: dielectric contrast, water-like lower medium\n            \"eps_r1\": 1.0, \"tan_d1\": 1.0e-4,\n            \"eps_r2\": 80.0, \"tan_d2\": 1.0e-2,\n            \"f\": 1.0e8, \"z\": 0.5, \"gamma\": 6.0,\n            \"alpha_max\": 0.6, \"N_t\": 512, \"delta_alpha\": 0.01\n        },\n        {\n            # Case 2: metal-like lower medium with negative permittivity\n            \"eps_r1\": 1.0, \"tan_d1\": 1.0e-4,\n            \"eps_r2\": -10.0, \"tan_d2\": 1.0e-1,\n            \"f\": 3.0e8, \"z\": 0.02, \"gamma\": 8.0,\n            \"alpha_max\": 0.7, \"N_t\": 700, \"delta_alpha\": 0.01\n        },\n        {\n            # Case 3: extreme high-permittivity lower medium at lower frequency\n            \"eps_r1\": 1.0, \"tan_d1\": 1.0e-4,\n            \"eps_r2\": 2000.0, \"tan_d2\": 1.0e-3,\n            \"f\": 1.0e6, \"z\": 0.1, \"gamma\": 4.0,\n            \"alpha_max\": 0.6, \"N_t\": 600, \"delta_alpha\": 0.01\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_optimal_tilt(case)\n        results.append(result)\n\n    # Format the final output as a string representing a list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_optimal_tilt(params):\n    \"\"\"\n    Performs a grid search to find the optimal contour tilt angle alpha\n    that minimizes the worst-polarization condition number.\n\n    Args:\n        params (dict): A dictionary containing all parameters for a single test case.\n\n    Returns:\n        list: A list containing the optimal alpha and the minimum condition number, [alpha_star, kappa_min].\n    \"\"\"\n    # Unpack parameters\n    f = params[\"f\"]\n    z = params[\"z\"]\n    gamma = params[\"gamma\"]\n    alpha_max = params[\"alpha_max\"]\n    N_t = params[\"N_t\"]\n    delta_alpha = params[\"delta_alpha\"]\n\n    # Calculate physical parameters\n    omega = 2 * np.pi * f\n    eps1 = epsilon_0 * params[\"eps_r1\"] * (1 - 1j * params[\"tan_d1\"])\n    eps2 = epsilon_0 * params[\"eps_r2\"] * (1 - 1j * params[\"tan_d2\"])\n    k1 = omega * np.sqrt(mu_0 * eps1)\n    k2 = omega * np.sqrt(mu_0 * eps2)\n\n    # Define spectral parameter grids\n    t_max = gamma * np.abs(k1)\n    t_vals = np.linspace(0, t_max, N_t)\n    \n    # Create a robust alpha grid that includes alpha_max\n    num_alpha_steps = int(round(alpha_max / delta_alpha)) + 1\n    alpha_vals = np.linspace(0, alpha_max, num_alpha_steps)\n\n    min_kappa = np.inf\n    optimal_alpha = -1.0\n\n    # Grid search over alpha\n    for alpha in alpha_vals:\n        # Vectorized computation for the current alpha over all t values\n        k_rho = t_vals * np.exp(1j * alpha)\n\n        # Calculate vertical wavenumbers k_z1 and k_z2\n        k_z1 = np.sqrt(k1**2 - k_rho**2)\n        # Enforce radiation condition: Im{k_z} = 0\n        k_z1[np.imag(k_z1)  0] *= -1\n\n        k_z2 = np.sqrt(k2**2 - k_rho**2)\n        k_z2[np.imag(k_z2)  0] *= -1\n\n        # Calculate Fresnel reflection coefficients\n        # Add a small epsilon to denominators to prevent division by zero,\n        # although it is physically unlikely to occur off the real axis for lossy media.\n        epsilon_div = 1e-30\n        \n        R_tm = (eps2 * k_z1 - eps1 * k_z2) / (eps2 * k_z1 + eps1 * k_z2 + epsilon_div)\n        R_te = (k_z1 - k_z2) / (k_z1 + k_z2 + epsilon_div)\n\n        # Calculate multiplicative factor magnitudes\n        exp_factor = np.exp(-np.imag(k_z1) * z)\n        F_tm = np.abs(R_tm) * exp_factor\n        F_te = np.abs(R_te) * exp_factor\n\n        # Calculate condition numbers\n        min_F_tm = np.min(F_tm)\n        min_F_te = np.min(F_te)\n        \n        # If min is zero, condition number is infinite (worst case)\n        kappa_tm = np.max(F_tm) / min_F_tm if min_F_tm  0 else np.inf\n        kappa_te = np.max(F_te) / min_F_te if min_F_te  0 else np.inf\n\n        # Worst-polarization condition number for the current alpha\n        kappa_alpha = max(kappa_tm, kappa_te)\n\n        # Update minimum\n        if kappa_alpha  min_kappa:\n            min_kappa = kappa_alpha\n            optimal_alpha = alpha\n            \n    return [optimal_alpha, min_kappa]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}