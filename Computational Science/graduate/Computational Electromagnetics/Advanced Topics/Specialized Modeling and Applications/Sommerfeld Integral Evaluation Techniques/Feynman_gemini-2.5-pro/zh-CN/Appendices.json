{
    "hands_on_practices": [
        {
            "introduction": "在计算电磁学中，直接对索末菲积分在实轴上进行数值计算通常效率低下，因为被积函数可能存在振荡和缓慢衰减。一种核心的改进技术是将积分路径从实轴变形到复平面内，以加速积分的收敛。此练习  聚焦于一个关键的实际问题：如何为具有高介电常数对比度的分层介质问题，系统地寻找一个最优的积分路径倾斜角，从而最小化积分的条件数并确保计算的稳定性。",
            "id": "3348833",
            "problem": "考虑均匀半空间分层介质中电磁场的二维谱积分表示。其基本依据是无源区中频域下的麦克斯韦方程组，它导出每个均匀层中的矢量亥姆霍兹方程。设上半空间为介质$1$，其复介电常数为$\\epsilon_1$；下半空间为介质$2$，其复介电常数为$\\epsilon_2$。假设介质为各向同性、非磁性，其磁导率$\\mu_1 = \\mu_0$且$\\mu_2 = \\mu_0$，其中$\\mu_0$为真空磁导率。设角频率为$\\omega$，其中$\\omega = 2\\pi f$，$f$是以赫兹为单位的频率。真空介电常数为$\\epsilon_0$。\n\n平面分层介质的谱积分（Sommerfeld积分）涉及由色散关系定义的横向谱变量$k_\\rho$和垂直波数$k_{zj}$。对于每种介质$j \\in \\{1,2\\}$，复介电常数由损耗角正切形式建模\n$$\n\\epsilon_j = \\epsilon_0 \\, \\epsilon_{rj} \\left(1 - i \\tan\\delta_j\\right),\n$$\n介质波数为\n$$\nk_j = \\omega \\sqrt{\\mu_0 \\epsilon_j}.\n$$\n对于复平面上的积分路径倾斜，将横向谱变量参数化为\n$$\nk_\\rho(t,\\alpha) = t\\, e^{i\\alpha}, \\quad t \\in [0, t_{\\max}],\n$$\n其中$\\alpha$为实数倾斜角（以弧度为单位），$t_{\\max}$为有限截断值。垂直波数满足\n$$\nk_{zj}(t,\\alpha) = \\sqrt{k_j^2 - k_\\rho^2(t,\\alpha)},\n$$\n并通过选择使得$\\Im\\{k_{zj}(t,\\alpha)\\} \\ge 0$的分支来强制满足辐射条件。\n\n在分层介质中，Sommerfeld型表示的被积函数包含乘法因子，其中包括由切向场分量的边界条件定义的横磁（TM）和横电（TE）极化的菲涅尔反射系数。当$\\mu_1 = \\mu_2 = \\mu_0$时，它们是\n$$\nR_{\\mathrm{TM}}(t,\\alpha) = \\frac{\\epsilon_2\\, k_{z1}(t,\\alpha) - \\epsilon_1\\, k_{z2}(t,\\alpha)}{\\epsilon_2\\, k_{z1}(t,\\alpha) + \\epsilon_1\\, k_{z2}(t,\\alpha)},\n\\qquad\nR_{\\mathrm{TE}}(t,\\alpha) = \\frac{k_{z1}(t,\\alpha) - k_{z2}(t,\\alpha)}{k_{z1}(t,\\alpha) + k_{z2}(t,\\alpha)}.\n$$\n对于介质$1$中观测高度$z  0$的情况，一个典型的来自垂直相位的指数因子是$\\exp\\!\\left(i k_{z1}(t,\\alpha)\\, z\\right)$，其幅值为$\\exp\\!\\left(-\\Im\\{k_{z1}(t,\\alpha)\\} z\\right)$。\n\n定义乘法因子幅值\n$$\nF_{\\mathrm{TM}}(t,\\alpha) = \\left|R_{\\mathrm{TM}}(t,\\alpha)\\right| \\, \\exp\\!\\left(-\\Im\\{k_{z1}(t,\\alpha)\\}\\, z\\right),\n\\qquad\nF_{\\mathrm{TE}}(t,\\alpha) = \\left|R_{\\mathrm{TE}}(t,\\alpha)\\right| \\, \\exp\\!\\left(-\\Im\\{k_{z1}(t,\\alpha)\\}\\, z\\right).\n$$\n为了量化稳定性，将采样区间$t \\in [0,t_{\\max}]$上的条件数定义为\n$$\n\\kappa_{\\mathrm{TM}}(\\alpha) = \\frac{\\max_{t \\in [0,t_{\\max}]} F_{\\mathrm{TM}}(t,\\alpha)}{\\min_{t \\in [0,t_{\\max}]} F_{\\mathrm{TM}}(t,\\alpha)},\n\\qquad\n\\kappa_{\\mathrm{TE}}(\\alpha) = \\frac{\\max_{t \\in [0,t_{\\max}]} F_{\\mathrm{TE}}(t,\\alpha)}{\\min_{t \\in [0,t_{\\max}]} F_{\\mathrm{TE}}(t,\\alpha)}.\n$$\n使用最差极化条件数\n$$\n\\kappa(\\alpha) = \\max\\!\\left\\{\\kappa_{\\mathrm{TM}}(\\alpha),\\, \\kappa_{\\mathrm{TE}}(\\alpha)\\right\\}.\n$$\n任务是为高对比度$\\left|\\epsilon_2/\\epsilon_1\\right| \\gg 1$的分层介质设计并实现一种数值稳定性分析，以确定在有界区间$\\alpha \\in [0,\\alpha_{\\max}]$内使$\\kappa(\\alpha)$最小化的最优积分路径倾斜角$\\alpha$。\n\n你的程序必须：\n- 精确实现上述定义，强制执行辐射条件$\\Im\\{k_{zj}\\} \\ge 0$，并通过在$[0,t_{\\max}]$上均匀采样$t$来评估$\\kappa(\\alpha)$。\n- 在$\\alpha \\in [0,\\alpha_{\\max}]$上以步长$\\Delta\\alpha$执行网格搜索，并为每个测试用例返回最小化倾斜角$\\alpha^\\star$和最小最差极化条件数$\\kappa(\\alpha^\\star)$。\n\n物理单位：\n- 频率$f$的单位是赫兹。\n- 高度$z$的单位是米。\n- 角度$\\alpha$、$\\alpha_{\\max}$和$\\Delta\\alpha$的单位是弧度。\n\n对于每个测试用例，通过$t_{\\max} = \\gamma \\left|k_1\\right|$定义$t_{\\max}$，其中$\\gamma  0$是给定的标量，$k_1$是介质$1$中的波数。\n\n测试套件：\n- 用例1（介电常数对比，类水下半介质）：\n  - $\\epsilon_{r1} = 1.0$, $\\tan\\delta_1 = 1.0\\times 10^{-4}$,\n  - $\\epsilon_{r2} = 80.0$, $\\tan\\delta_2 = 1.0\\times 10^{-2}$,\n  - $f = 1.0\\times 10^{8}\\,\\mathrm{Hz}$,\n  - $z = 0.5\\,\\mathrm{m}$,\n  - $\\gamma = 6.0$,\n  - $\\alpha_{\\max} = 0.6\\,\\mathrm{rad}$,\n  - $N_t = 512$ 个$t$的采样点,\n  - $\\Delta\\alpha = 0.01\\,\\mathrm{rad}$.\n- 用例2（具有负介电常数的类金属下半介质）：\n  - $\\epsilon_{r1} = 1.0$, $\\tan\\delta_1 = 1.0\\times 10^{-4}$,\n  - $\\epsilon_{r2} = -10.0$, $\\tan\\delta_2 = 1.0\\times 10^{-1}$,\n  - $f = 3.0\\times 10^{8}\\,\\mathrm{Hz}$,\n  - $z = 0.02\\,\\mathrm{m}$,\n  - $\\gamma = 8.0$,\n  - $\\alpha_{\\max} = 0.7\\,\\mathrm{rad}$,\n  - $N_t = 700$,\n  - $\\Delta\\alpha = 0.01\\,\\mathrm{rad}$.\n- 用例3（低频下具有极高介电常数的下半介质）：\n  - $\\epsilon_{r1} = 1.0$, $\\tan\\delta_1 = 1.0\\times 10^{-4}$,\n  - $\\epsilon_{r2} = 2000.0$, $\\tan\\delta_2 = 1.0\\times 10^{-3}$,\n  - $f = 1.0\\times 10^{6}\\,\\mathrm{Hz}$,\n  - $z = 0.1\\,\\mathrm{m}$,\n  - $\\gamma = 4.0$,\n  - $\\alpha_{\\max} = 0.6\\,\\mathrm{rad}$,\n  - $N_t = 600$,\n  - $\\Delta\\alpha = 0.01\\,\\mathrm{rad}$.\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个双元素列表$[\\alpha^\\star, \\kappa(\\alpha^\\star)]$。例如：$[[\\alpha^\\star_1,\\kappa_1],[\\alpha^\\star_2,\\kappa_2],[\\alpha^\\star_3,\\kappa_3]]$。",
            "solution": "用户提供的问题已经过验证，被认为是**有效的**。它在科学上植根于经典电磁学，特别是分层介质中的波传播理论。该问题是适定的，提供了执行数值优化程序所需的所有必要定义和参数。其目标——寻找最优积分路径倾斜角以最小化数值条件数——是计算电磁学中评估Sommerfeld积分的一个标准且实际的问题。\n\n解决方案按以下步骤进行：\n\n**1. 基础物理和数学模型**\n该问题设定在频域中，由麦克斯韦方程组控制。核心任务与数值评估谱积分（Sommerfeld积分）有关，这些积分在表示分层介质中源的场时出现。这些积分的被积函数包含多种因子，此处分析其中两种：菲涅尔反射系数和指数相位因子。\n\n首先，我们确定物理常数和介质参数。真空磁导率$\\mu_0$和介电常数$\\epsilon_0$是基本常数。角频率$\\omega$由给定的频率$f$计算得出，即$\\omega = 2\\pi f$。\n\n对于每种介质$j \\in \\{1,2\\}$，复介电常数$\\epsilon_j$由其相对介电常数$\\epsilon_{rj}$和损耗角正切$\\tan\\delta_j$定义：\n$$\n\\epsilon_j = \\epsilon_0 \\, \\epsilon_{rj} (1 - i \\tan\\delta_j)\n$$\n其中$i$是虚数单位。该模型考虑了介质中的介电损耗。每种介质对应的复波数为：\n$$\nk_j = \\omega \\sqrt{\\mu_0 \\epsilon_j}\n$$\n复数平方根意味着$k_j$通常既有实部也有虚部，对于有损介质，$\\Im\\{k_j\\}  0$。\n\n**2. 谱变量参数化与辐射条件**\n电磁场表示为对平面波谱的积分，该谱由横向谱变量$k_\\rho$索引。为了数值稳定性和收敛性，复$k_\\rho$平面中的积分路径通常会偏离实轴。该问题指定了一个简单的线性倾斜：\n$$\nk_\\rho(t,\\alpha) = t\\, e^{i\\alpha}\n$$\n其中$t$是一个实数参数，表示沿倾斜路径的距离，$\\alpha$是实数倾斜角。$t$的积分范围在$t_{\\max} = \\gamma |k_1|$处被截断，其中$\\gamma$是给定的缩放因子。\n\n对于每个$k_\\rho$值，介质$j$中波矢量的垂直分量（记为$k_{zj}$）由色散关系确定：\n$$\nk_{zj}^2 + k_\\rho^2 = k_j^2 \\implies k_{zj} = \\sqrt{k_j^2 - k_\\rho^2}\n$$\n平方根引入了分支切割的模糊性。这通过强制执行辐射条件来解决，该条件规定场在远离其源点处必须保持有界。对于垂直方向，这转化为垂直波数的虚部必须为非负的数学要求：\n$$\n\\Im\\{k_{zj}\\} \\ge 0\n$$\n在实现中，计算出平方根的主值后，如果其虚部为负，则调整其符号以满足此条件。\n\n**3. 数值稳定性度量：条件数**\n数值积分的稳定性与被积函数幅值的动态范围有关。该问题定义了一个乘法因子$F$，它捕捉了这种变化的主要来源：菲涅尔反射系数（$R_{\\mathrm{TM}}$、$R_{\\mathrm{TE}}$）和与观测高度$z$相关的指数衰减。\n\n介质1和介质2之间界面的横磁（TM）和横电（TE）极化的菲涅尔反射系数为：\n$$\nR_{\\mathrm{TM}}(t,\\alpha) = \\frac{\\epsilon_2\\, k_{z1}(t,\\alpha) - \\epsilon_1\\, k_{z2}(t,\\alpha)}{\\epsilon_2\\, k_{z1}(t,\\alpha) + \\epsilon_1\\, k_{z2}(t,\\alpha)}, \\qquad R_{\\mathrm{TE}}(t,\\alpha) = \\frac{k_{z1}(t,\\alpha) - k_{z2}(t,\\alpha)}{k_{z1}(t,\\alpha) + k_{z2}(t,\\alpha)}\n$$\n对于介质1中高度$z  0$的观测点，指数因子源于垂直传播项$\\exp(i k_{z1} z)$。其幅值对被积函数的行为有贡献：\n$$\n\\left| \\exp(i k_{z1} z) \\right| = \\left| \\exp(i (\\Re\\{k_{z1}\\} + i\\Im\\{k_{z1}\\}) z) \\right| = \\left| \\exp(i \\Re\\{k_{z1}\\} z) \\exp(-\\Im\\{k_{z1}\\} z) \\right| = \\exp(-\\Im\\{k_{z1}\\} z)\n$$\n因此，乘法因子幅值定义为：\n$$\nF_{\\mathrm{TM}}(t,\\alpha) = |R_{\\mathrm{TM}}(t,\\alpha)| \\, \\exp(-\\Im\\{k_{z1}(t,\\alpha)\\}\\, z)\n$$\n$$\nF_{\\mathrm{TE}}(t,\\alpha) = |R_{\\mathrm{TE}}(t,\\alpha)| \\, \\exp(-\\Im\\{k_{z1}(t,\\alpha)\\}\\, z)\n$$\n条件数$\\kappa$定义为对于给定的倾斜角$\\alpha$，该因子幅值沿积分路径的最大值与最小值之比。较小的条件数意味着被积函数对于数值求积更为良性。\n$$\n\\kappa_{\\mathrm{TM}}(\\alpha) = \\frac{\\max_{t \\in [0,t_{\\max}]} F_{\\mathrm{TM}}(t,\\alpha)}{\\min_{t \\in [0,t_{\\max}]} F_{\\mathrm{TM}}(t,\\alpha)}, \\qquad \\kappa_{\\mathrm{TE}}(\\alpha) = \\frac{\\max_{t \\in [0,t_{\\max}]} F_{\\mathrm{TE}}(t,\\alpha)}{\\min_{t \\in [0,t_{\\max}]} F_{\\mathrm{TE}}(t,\\alpha)}\n$$\n最终的度量是两种极化中的最差情况条件数：\n$$\n\\kappa(\\alpha) = \\max\\{\\kappa_{\\mathrm{TM}}(\\alpha),\\, \\kappa_{\\mathrm{TE}}(\\alpha)\\}\n$$\n\n**4. 优化算法：网格搜索**\n目标是找到使$\\kappa(\\alpha)$最小化的最优倾斜角$\\alpha^\\star$。问题指定了一种直接的数值方法：网格搜索。\n每个测试用例的算法如下：\n1.  定义一个候选角度$\\alpha$的网格，范围从$0$到$\\alpha_{\\max}$，步长为$\\Delta\\alpha$。\n2.  对于网格中的每个角度$\\alpha$：\n    a.  在区间$[0, t_{\\max}]$上为参数$t$定义$N_t$个点的均匀采样，其中$t_{\\max} = \\gamma |k_1|$。\n    b.  对于这组$t$值，计算$k_\\rho$、$k_{z1}$和$k_{z2}$的向量，确保对$k_{z1}$和$k_{z2}$向量的所有元素都强制执行辐射条件$\\Im\\{k_{zj}\\} \\ge 0$。\n    c.  计算$F_{\\mathrm{TM}}(t, \\alpha)$和$F_{\\mathrm{TE}}(t, \\alpha)$的值向量。\n    d.  找到每个向量的最大值和最小值，以计算$\\kappa_{\\mathrm{TM}}(\\alpha)$和$\\kappa_{\\mathrm{TE}}(\\alpha)$。\n    e.  确定$\\kappa(\\alpha) = \\max\\{\\kappa_{\\mathrm{TM}}(\\alpha), \\kappa_{\\mathrm{TE}}(\\alpha)\\}$。\n3.  遍历所有角度后，找出产生最小$\\kappa(\\alpha)$值的角度$\\alpha^\\star$。\n4.  该测试用例的最终结果是数对$[\\alpha^\\star, \\kappa(\\alpha^\\star)]$。\n\n该过程为每个提供的测试用例实现，利用NumPy的矢量化计算来提高效率。",
            "answer": "```python\nimport numpy as np\nfrom scipy.constants import mu_0, epsilon_0\n\ndef solve():\n    \"\"\"\n    Main function to run the stability analysis for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            # Case 1: dielectric contrast, water-like lower medium\n            \"eps_r1\": 1.0, \"tan_d1\": 1.0e-4,\n            \"eps_r2\": 80.0, \"tan_d2\": 1.0e-2,\n            \"f\": 1.0e8, \"z\": 0.5, \"gamma\": 6.0,\n            \"alpha_max\": 0.6, \"N_t\": 512, \"delta_alpha\": 0.01\n        },\n        {\n            # Case 2: metal-like lower medium with negative permittivity\n            \"eps_r1\": 1.0, \"tan_d1\": 1.0e-4,\n            \"eps_r2\": -10.0, \"tan_d2\": 1.0e-1,\n            \"f\": 3.0e8, \"z\": 0.02, \"gamma\": 8.0,\n            \"alpha_max\": 0.7, \"N_t\": 700, \"delta_alpha\": 0.01\n        },\n        {\n            # Case 3: extreme high-permittivity lower medium at lower frequency\n            \"eps_r1\": 1.0, \"tan_d1\": 1.0e-4,\n            \"eps_r2\": 2000.0, \"tan_d2\": 1.0e-3,\n            \"f\": 1.0e6, \"z\": 0.1, \"gamma\": 4.0,\n            \"alpha_max\": 0.6, \"N_t\": 600, \"delta_alpha\": 0.01\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_optimal_tilt(case)\n        results.append(result)\n\n    # Format the final output as a string representing a list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_optimal_tilt(params):\n    \"\"\"\n    Performs a grid search to find the optimal contour tilt angle alpha\n    that minimizes the worst-polarization condition number.\n\n    Args:\n        params (dict): A dictionary containing all parameters for a single test case.\n\n    Returns:\n        list: A list containing the optimal alpha and the minimum condition number, [alpha_star, kappa_min].\n    \"\"\"\n    # Unpack parameters\n    f = params[\"f\"]\n    z = params[\"z\"]\n    gamma = params[\"gamma\"]\n    alpha_max = params[\"alpha_max\"]\n    N_t = params[\"N_t\"]\n    delta_alpha = params[\"delta_alpha\"]\n\n    # Calculate physical parameters\n    omega = 2 * np.pi * f\n    eps1 = epsilon_0 * params[\"eps_r1\"] * (1 - 1j * params[\"tan_d1\"])\n    eps2 = epsilon_0 * params[\"eps_r2\"] * (1 - 1j * params[\"tan_d2\"])\n    k1 = omega * np.sqrt(mu_0 * eps1)\n    k2 = omega * np.sqrt(mu_0 * eps2)\n\n    # Define spectral parameter grids\n    t_max = gamma * np.abs(k1)\n    t_vals = np.linspace(0, t_max, N_t)\n    \n    # Create a robust alpha grid that includes alpha_max\n    num_alpha_steps = int(round(alpha_max / delta_alpha)) + 1\n    alpha_vals = np.linspace(0, alpha_max, num_alpha_steps)\n\n    min_kappa = np.inf\n    optimal_alpha = -1.0\n\n    # Grid search over alpha\n    for alpha in alpha_vals:\n        # Vectorized computation for the current alpha over all t values\n        k_rho = t_vals * np.exp(1j * alpha)\n\n        # Calculate vertical wavenumbers k_z1 and k_z2\n        k_z1 = np.sqrt(k1**2 - k_rho**2)\n        # Enforce radiation condition: Im{k_z} >= 0\n        k_z1[np.imag(k_z1)  0] *= -1\n\n        k_z2 = np.sqrt(k2**2 - k_rho**2)\n        k_z2[np.imag(k_z2)  0] *= -1\n\n        # Calculate Fresnel reflection coefficients\n        # Add a small epsilon to denominators to prevent division by zero,\n        # although it is physically unlikely to occur off the real axis for lossy media.\n        epsilon_div = 1e-30\n        \n        R_tm = (eps2 * k_z1 - eps1 * k_z2) / (eps2 * k_z1 + eps1 * k_z2 + epsilon_div)\n        R_te = (k_z1 - k_z2) / (k_z1 + k_z2 + epsilon_div)\n\n        # Calculate multiplicative factor magnitudes\n        exp_factor = np.exp(-np.imag(k_z1) * z)\n        F_tm = np.abs(R_tm) * exp_factor\n        F_te = np.abs(R_te) * exp_factor\n\n        # Calculate condition numbers\n        min_F_tm = np.min(F_tm)\n        min_F_te = np.min(F_te)\n        \n        # If min is zero, condition number is infinite (worst case)\n        kappa_tm = np.max(F_tm) / min_F_tm if min_F_tm > 0 else np.inf\n        kappa_te = np.max(F_te) / min_F_te if min_F_te > 0 else np.inf\n\n        # Worst-polarization condition number for the current alpha\n        kappa_alpha = max(kappa_tm, kappa_te)\n\n        # Update minimum\n        if kappa_alpha  min_kappa:\n            min_kappa = kappa_alpha\n            optimal_alpha = alpha\n            \n    return [optimal_alpha, min_kappa]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "即使选择了合适的积分路径，索末菲积分的数值计算本身也充满挑战，其被积函数往往包含无穷积分区间、奇点以及贝塞尔函数带来的振荡。一个稳健的数值算法必须能够智能地处理这些复杂特性。本练习  将引导您从基本原理出发，构建一个自适应积分算法，它不仅能根据严格的误差分析来确定积分区间的截断点，还能在关键的支点奇点附近自动调整策略，从而实现精确高效的计算。",
            "id": "3348842",
            "problem": "考虑一个由复波数 $k \\in \\mathbb{C}$ 表征的均匀各向同性介质，以及位于原点的源的标量亥姆霍兹格林函数。通过在柱坐标中进行变量分离，并采用与 Maxwell 方程组兼容的谱表示，可以得到轴向距离 $z  0$ 和横向距离 $\\rho \\ge 0$ 的标量格林函数的 Sommerfeld 型积分表示：\n$$\nG(\\rho,z;k) = \\frac{i}{4\\pi} \\int_{0}^{\\infty} \\frac{k_\\rho}{k_z(k_\\rho)} J_0(k_\\rho \\rho) e^{i k_z(k_\\rho) z} \\, \\mathrm{d}k_\\rho,\n$$\n其中 $J_0(\\cdot)$ 是零阶第一类贝塞尔函数，$k_z(k_\\rho)$ 是由下式主支定义的纵向谱波数：\n$$\nk_z(k_\\rho) = \\sqrt{k^2 - k_\\rho^2},\n$$\n其支路选择需满足 $\\operatorname{Im}\\{k_z(k_\\rho)\\} \\ge 0$。当 $k$ 为实数且为正时，被积函数在支点 $k_\\rho = |k|$ 处性质发生改变：对于 $k_\\rho  |k|$，有 $\\operatorname{Im}\\{k_z\\} = 0$（振荡传播谱）；而对于 $k_\\rho  |k|$，有 $\\operatorname{Im}\\{k_z\\}  0$（导致沿 $z$ 方向衰减的倏逝谱）。对于 $\\operatorname{Im}\\{k\\}  0$ 的复数 $k$，被积函数会获得额外的衰减。\n\n您的任务是设计并实现一个带参数调优的自适应数值算法，以评估一组测试用例中 $G(\\rho,z;k)$ 的实部。该算法必须从第一性原理推导，并包含以下所有特性：\n\n- 一种自适应分裂策略，用于处理被积函数在支点两侧的性质变化。您必须确保在 $k_\\rho \\approx |k|$ 附近，当因子 $k_\\rho/k_z(k_\\rho)$ 产生可积的平方根奇点时，算法仍保持数值稳定性。\n- 一个用于积分上限 $k_\\rho \\in [0,\\infty)$ 的尾部截断参数，该参数通过对超出截断值 $L$ 的倏逝波贡献的严格界推导得出。您必须选择 $L$，使得一个有数学依据的尾部余项上界小于指定的容差。\n- 根据 $(\\rho,z,k)$ 对局部容差和积分子区间进行参数调优，以使算法在高度振荡（$\\rho$ 大，实数 $k$）和强衰减（倏逝或复数 $k$）的情形下均保持高效。\n- 一种经过验证的 $k_z(k_\\rho)$ 支路选择方法，该方法能强制满足 $\\operatorname{Im}\\{k_z(k_\\rho)\\} \\ge 0$。\n\n请从标量亥姆霍兹方程和谱格林函数的定义出发。证明 $k_z(k_\\rho)$ 支路选择的合理性，并为倏逝尾部的截断误差推导一个实用的、可计算的上界。基于这些原理，详细说明您的自适应算法及其参数调优规则。\n\n将该算法实现为一个完整的、可运行的程序，为以下测试套件计算 $G(\\rho,z;k)$ 的实部。所有量均为无量纲（不使用物理单位），且不涉及角度。\n\n测试套件：\n1. $(\\rho, z, k) = (0.5, 0.4, 2.0)$\n2. $(\\rho, z, k) = (5.0, 0.4, 2.0)$\n3. $(\\rho, z, k) = (1.0, 0.2, 2.0 + 0.3 i)$\n4. $(\\rho, z, k) = (0.05, 0.8, 8.0)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素都是一个浮点数，等于对应测试用例的 $G(\\rho,z;k)$ 的实部，计算的绝对容差在 $10^{-6}$ 以内。例如：\n\"[result1,result2,result3,result4]\"\n\n您所使用的算法选择和界限必须在科学上合理，并与上述积分定义一致。不允许使用硬编码的捷径或 $G(\\rho,z;k)$ 的闭式恒等式。",
            "solution": "该问题要求设计并实现一种自适应数值算法，用于计算由 Sommerfeld 型积分给出的标量亥姆霍兹格林函数的实部：\n$$\nG(\\rho,z;k) = \\frac{i}{4\\pi} \\int_{0}^{\\infty} \\frac{k_\\rho}{k_z(k_\\rho)} J_0(k_\\rho \\rho) e^{i k_z(k_\\rho) z} \\, \\mathrm{d}k_\\rho\n$$\n此积分表示是通过在柱坐标 $(\\rho, \\phi, z)$ 中求解标量亥姆霍兹方程 $(\\nabla^2 + k^2)G(\\mathbf{r}; k) = -\\delta(\\mathbf{r})$，并应用傅里叶-贝塞尔变换（也称汉克尔变换）得到的。该变换将 $(\\rho, z)$ 上的偏微分方程转换为对每个谱分量 $k_\\rho$ 的关于 $z$ 的常微分方程。在 Sommerfeld 辐射条件下，该常微分方程的解产生指数项 $e^{i k_z z}$，再应用逆变换即可得到上述积分表达式。\n\n此积分的数值计算并非易事，主要面临三个挑战，我们的算法必须从第一性原理出发来解决这些挑战：\n1. 无穷积分域 $[0, \\infty)$。\n2. 被积函数缓慢衰减和振荡的性质，这主要源于贝塞尔函数 $J_0(k_\\rho \\rho)$。\n3. 在 $k_z(k_\\rho) = \\sqrt{k^2 - k_\\rho^2}$ 的定义中存在一个支点，这可能导致在积分路径上出现可积奇点。\n\n我们的方法是基于对被积函数性质的精确分析，开发一个鲁棒的自适应求积方案。\n\n**1. 纵向波数 $k_z(k_\\rho)$ 的支路选择**\n\n纵向波数 $k_z$ 由 $k_z(k_\\rho) = \\sqrt{k^2 - k_\\rho^2}$ 定义。平方根函数是多值的。物理上正确的支路受限于场在 $z \\to \\infty$ 时必须衰减的条件。这意味着与谱分量对应的波必须要么从源平面传播出去，要么是倏逝的（衰减的）。在数学上，这转化为对所有实数 $k_\\rho \\ge 0$ 均有 $\\operatorname{Im}\\{k_z(k_\\rho)\\} \\ge 0$ 的要求。\n\n令 $Z(k_\\rho) = k^2 - k_\\rho^2$。平方根的标准主支，正如在大多数数值库（如 `numpy.sqrt`）中所实现的，返回一个值 $w = \\sqrt{Z}$，使得 $\\operatorname{Re}\\{w\\} \\ge 0$。这并不能保证 $\\operatorname{Im}\\{w\\} \\ge 0$。对于任何非零复数 $Z$，存在两个平方根，$w$ 和 $-w$。如果 $w = u+iv$，那么 $-w = -u-iv$。由于它们的虚部符号相反（除非 $v=0$），其中一个必然是非负的。\n因此，我们强制选择正确支路的过程如下：\n1. 计算主平方根，$w = \\sqrt{k^2 - k_\\rho^2}$。\n2. 如果 $\\operatorname{Im}\\{w\\}  0$，选择另一个根，$k_z = -w$。\n3. 否则，选择 $k_z = w$。\n这个过程保证了对所有 $k_\\rho$ 都有 $\\operatorname{Im}\\{k_z\\} \\ge 0$，从而确保积分对于 $z > 0$ 是收敛的，因为项 $e^{i k_z z} = e^{i (\\operatorname{Re}\\{k_z\\}) z} e^{-(\\operatorname{Im}\\{k_z\\}) z}$ 将会衰减。\n\n**2. 被积函数行为和自适应分裂**\n\n被积函数的性质在 $k_\\rho = |k|$ 附近发生显著变化。\n为清晰起见，设 $k$ 为一个实正数。\n- 对于 $0 \\le k_\\rho  k$，$k^2 - k_\\rho^2 > 0$，因此 $k_z = \\sqrt{k^2 - k_\\rho^2}$ 是实数且为正。项 $e^{i k_z z}$ 是纯振荡的，代表传播波。\n- 对于 $k_\\rho > k$，$k^2 - k_\\rho^2  0$，因此 $k_z = \\sqrt{-(k_\\rho^2 - k^2)} = i\\sqrt{k_\\rho^2 - k^2}$ 是纯虚数且为正（根据我们的支路选择）。项 $e^{i k_z z} = e^{-\\sqrt{k_\\rho^2 - k^2}z}$ 是纯衰减的，代表倏逝波。\n- 在 $k_\\rho = k$ 处，$k_z = 0$。被积函数中的因子 $1/k_z$ 产生一个平方根奇点，因为当 $k_\\rho \\to k^-$ 时，$1/k_z \\sim 1/\\sqrt{k-k_\\rho}$。这个奇点是可积的。\n\n如果 $k$ 是复数（$k = k_r + i k_i$ 且 $k_i > 0$），$k_z$ 总是具有正虚部的复数，因此奇点不位于实数 $k_\\rho$ 积分轴上。然而，$k_\\rho = |k|$ 这个点仍然标志着被积函数渐近行为的转变。\n\n为了稳健地处理这些行为，数值求积程序应该被告知这个临界点。我们将使用 `scipy.integrate.quad`，这是一个基于 QUADPACK 的自适应程序。通过 `points` 参数提供点 $k_\\rho = |k|$，我们指示程序在此位置分裂积分区间，并应用适当的求积规则来处理奇点（如果存在）和被积函数性质的变化。这就构成了我们的自适应分裂策略。\n\n**3. 尾部截断和误差界**\n\n积分为 $[0, \\infty)$。我们必须将其截断为有限区间 $[0, L]$ 以进行数值计算。截断极限 $L$ 的选择必须使得省略尾部积分所产生的误差小于指定的容差 $\\epsilon_{\\text{tail}}$。\n尾部积分为 $T = \\frac{i}{4\\pi} \\int_{L}^{\\infty} \\frac{k_\\rho}{k_z} J_0(k_\\rho \\rho) e^{i k_z z} \\, \\mathrm{d}k_\\rho$。\n我们寻求 $|T|$ 的一个上界。对于大的 $k_\\rho \\gg |k|$，我们有以下近似：\n- $k_z(k_\\rho) = \\sqrt{k^2 - k_\\rho^2} = i k_\\rho \\sqrt{1 - k^2/k_\\rho^2} \\approx i k_\\rho$。由于 $k_\\rho > 0$，我们的支路条件得到满足。\n- $|\\frac{k_\\rho}{k_z(k_\\rho)}| \\approx |\\frac{k_\\rho}{i k_\\rho}| = 1$。\n- $|J_0(k_\\rho \\rho)| \\le 1$。这是一个简单而有效的界。\n- $|e^{i k_z z}| = e^{-\\operatorname{Im}\\{k_z\\}z}$。当 $\\operatorname{Im}\\{k_z\\} \\approx k_\\rho$ 时，这变为 $|e^{i k_z z}| \\approx e^{-k_\\rho z}$。\n\n结合这些界，尾部积分的模有如下界定：\n$$\n|T| \\le \\frac{1}{4\\pi} \\int_{L}^{\\infty} \\left| \\frac{k_\\rho}{k_z} \\right| |J_0(k_\\rho \\rho)| |e^{i k_z z}| \\, \\mathrm{d}k_\\rho \\approx \\frac{1}{4\\pi} \\int_{L}^{\\infty} (1) \\cdot (1) \\cdot e^{-k_\\rho z} \\, \\mathrm{d}k_\\rho\n$$\n计算该近似界定积分：\n$$\n\\frac{1}{4\\pi} \\int_{L}^{\\infty} e^{-k_\\rho z} \\, \\mathrm{d}k_\\rho = \\frac{1}{4\\pi} \\left[ -\\frac{1}{z} e^{-k_\\rho z} \\right]_{L}^{\\infty} = \\frac{e^{-Lz}}{4\\pi z}\n$$\n我们要求这个界小于我们的尾部容差 $\\epsilon_{\\text{tail}}$：\n$$\n\\frac{e^{-Lz}}{4\\pi z} \\le \\epsilon_{\\text{tail}} \\implies e^{-Lz} \\le 4\\pi z \\epsilon_{\\text{tail}} \\implies -Lz \\le \\ln(4\\pi z \\epsilon_{\\text{tail}})\n$$\n解出 $L$ 得到所需的截断极限：\n$$\nL \\ge \\frac{1}{z} \\ln\\left(\\frac{1}{4\\pi z \\epsilon_{\\text{tail}}}\\right)\n$$\n该公式为基于观测高度 $z$ 和期望的精度自适应地选择 $L$ 提供了严格的依据。\n\n**4. 算法总结与参数调优**\n\n计算 $\\operatorname{Re}\\{G(\\rho,z;k)\\}$ 至绝对容差 $\\epsilon$ 的完整算法如下：\n\n1.  **设置容差**：选择一个总绝对容差 $\\epsilon$（例如 $10^{-6}$）。将尾部截断容差设置为该值的一小部分，例如 $\\epsilon_{\\text{tail}} = \\epsilon/10$。求积程序 `epsabs` 的容差，即计算积分值的误差估计，将被设置为 $\\epsilon \\cdot 4\\pi$。\n2.  **确定积分上限 $L$**：使用推导出的公式计算 $L$：$L = \\frac{1}{z} \\ln\\left(\\frac{1}{4\\pi z \\epsilon_{\\text{tail}}}\\right)$。为确保推导中使用的渐近近似的有效性，我们强制 $L$ 的一个最小值，例如 $L = \\max(L, 2|k| + 20)$。\n3.  **定义被积函数**：需要计算的量是 $\\operatorname{Re}\\{G\\} = \\operatorname{Re}\\{\\frac{i}{4\\pi} \\mathcal{I}\\} = -\\frac{1}{4\\pi} \\operatorname{Im}\\{\\mathcal{I}\\}$，其中 $\\mathcal{I}$ 是该积分。我们为 `scipy.integrate.quad` 定义一个函数，该函数计算 $\\operatorname{Im}\\{\\frac{k_\\rho}{k_z} J_0(k_\\rho \\rho) e^{i k_z z}\\}$，其中 $k_z$ 使用经过验证的支路选择逻辑确定。\n4.  **调优求积参数**：\n    -   **奇点处理**：如果点 $k_\\rho = |k|$ 位于积分区间 $[0, L]$ 内，则将其传递给 `quad` 的 `points` 参数。\n    -   **振荡**：对于大 $\\rho$ 的情况，贝塞尔函数 $J_0(k_\\rho \\rho)$ 是高度振荡的。在 $[0,L]$ 上的振荡次数与 $L\\rho$ 成正比。如果 $L\\rho$ 超过一个阈值（例如 $100$），我们增加 `quad` 的最大子区间数（`limit` 参数）以确保收敛。\n5.  **计算并最终确定**：使用定义的被积函数、积分限 $[0, L]$ 和调优后的参数调用 `scipy.integrate.quad`。最终结果是返回的积分值乘以 $-1/(4\\pi)$。\n\n这种基于原理的设计产生了一个在不同物理情景下都具有自适应性、稳定性和高效性的算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import j0\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (rho, z, k)\n    test_cases = [\n        (0.5, 0.4, 2.0 + 0.0j),\n        (5.0, 0.4, 2.0 + 0.0j),\n        (1.0, 0.2, 2.0 + 0.3j),\n        (0.05, 0.8, 8.0 + 0.0j),\n    ]\n\n    results = []\n    # Absolute tolerance for the final result, as specified in the problem.\n    absolute_tolerance = 1e-6\n    \n    for rho, z, k in test_cases:\n        # Calculate the real part of the Green's function for the current case.\n        val = calculate_G_real(rho, z, k, absolute_tolerance)\n        results.append(f\"{val:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_G_real(rho, z, k, tol):\n    \"\"\"\n    Calculates the real part of the Sommerfeld integral G(rho, z, k)\n    using an adaptive numerical quadrature algorithm.\n\n    Args:\n        rho (float): Transverse separation.\n        z (float): Axial separation.\n        k (complex): Complex wavenumber of the medium.\n        tol (float): Desired absolute tolerance for the final result.\n\n    Returns:\n        float: The computed real part of G(rho, z, k).\n    \"\"\"\n\n    # --- Step 1: Define the complex integrand F(k_rho) ---\n    # G = (i / 4pi) * Integral(F(k_rho) d(k_rho))\n    def complex_integrand(k_rho, rho, z, k):\n        \"\"\"\n        The complex function inside the Sommerfeld integral.\n        \"\"\"\n        # The numerator contains k_rho, so if k_rho is 0, the integrand is 0.\n        if k_rho == 0.0:\n            return 0.0j\n\n        # --- Branch Selection for k_z ---\n        # Calculate k_z^2 = k^2 - k_rho^2\n        k_z_sq = k**2 - k_rho**2\n        \n        # Compute principal square root\n        k_z = np.sqrt(k_z_sq)\n        \n        # Enforce the branch condition Im{k_z} >= 0\n        if k_z.imag  0:\n            k_z = -k_z\n        \n        # If k_z is numerically zero (at a singularity), quad will handle it,\n        # so we avoid explicit division by zero checks which can be problematic.\n        \n        # Assemble the integrand components\n        factor = k_rho / k_z\n        bessel_term = j0(k_rho * rho)\n        exp_term = np.exp(1j * k_z * z)\n        \n        return factor * bessel_term * exp_term\n\n    # We need to compute Re{G}.\n    # G = (i / 4pi) * Integral(F_re + i*F_im)\n    # Re{G} = Re{(i*Integral(F_re) - Integral(F_im)) / 4pi} = -Integral(F_im) / 4pi\n    # So, we need to integrate the imaginary part of complex_integrand.\n    def integrand_for_quad(k_rho, rho, z, k):\n        return complex_integrand(k_rho, rho, z, k).imag\n\n    # --- Step 2: Tail Truncation ---\n    # Set tail tolerance as a fraction of the total tolerance.\n    tail_tol = tol / 10.0\n    \n    # Calculate truncation limit L based on the derived bound.\n    # L >= (1/z) * ln(1 / (4*pi*z*tail_tol))\n    # log_arg must be > 1 for log to be positive.\n    log_arg = 1.0 / (4.0 * np.pi * z * tail_tol)\n    if log_arg = 1.0:\n        # This case can occur if z is very large, making the tail decay extremely fast.\n        # A sensible default range is sufficient.\n        L = 2.0 * np.abs(k) + 20.0\n    else:\n        L = (1.0 / z) * np.log(log_arg)\n    \n    # Add a safety margin to L to ensure the asymptotic regime is reached.\n    L = max(L, 2.0 * np.abs(k) + 20.0)\n\n    # --- Step 3: Parameter Tuning for Quadrature ---\n    # The point k_rho = |k| marks a change in integrand character (and a singularity for real k)\n    split_point = np.abs(k)\n    integration_points = []\n    if 0  split_point  L:\n        integration_points.append(split_point)\n\n    # Tune the number of subdivisions based on oscillatory behavior (large L*rho).\n    # The number of oscillations of J0 is proportional to L*rho.\n    limit = 50\n    if L * rho > 100:  # Heuristic for highly oscillatory cases\n        limit = 200\n        \n    # The tolerance for quad is on the integral value, not the final result.\n    # We scale the desired final tolerance by the constant factor.\n    quad_abs_tol = tol * 4.0 * np.pi\n\n    # --- Step 4: Perform Integration ---\n    integral_val, _ = quad(\n        integrand_for_quad,\n        0, L,\n        args=(rho, z, k),\n        points=integration_points,\n        epsabs=quad_abs_tol,\n        epsrel=1e-9,  # Use a tight relative tolerance for accuracy.\n        limit=limit\n    )\n\n    # --- Step 5: Compute Final Result ---\n    # Re{G} = -Integral(Im{F}) / (4*pi)\n    final_result = -integral_val / (4.0 * np.pi)\n\n    return final_result\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}