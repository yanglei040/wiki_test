{
    "hands_on_practices": [
        {
            "introduction": "在 FDTD 方法中建模亚元胞薄导线的第一步，是将其物理几何和材料特性转化为 FDTD 网格上的等效参数。本练习将指导您从第一性原理出发，通过对导线电流贡献进行体积平均，推导出任意走向的导线段在 FDTD 单元中引入的等效电导率。掌握这项基本技能对于在计算模型中准确地表示倾斜或弯曲的薄结构至关重要 。",
            "id": "3354986",
            "problem": "考虑一个三维时域有限差分 (FDTD) Yee 网格，其空间步长为 $\\Delta x$、$\\Delta y$ 和 $\\Delta z$。一根半径为 $a$、体电导率为 $\\sigma_{\\mathrm{w}}$ 的细金属线穿过与每个电场边分量相关的局部更新体积。该金属线在几何上是亚元胞尺寸的 ($a \\ll \\min\\{\\Delta x,\\Delta y,\\Delta z\\}$)，并由一个可微空间曲线 $\\mathbf{r}(u)$ 表示，其参数为 $u$，弧长坐标为 $s$，单位切向量为 $\\hat{\\mathbf{t}}(s)$。与第 $i$ 个电场分量 ($i \\in \\{x,y,z\\}$) 相关的局部更新体积被建模为具有纵向维度 $\\Delta i$ 和横向截面积 $A_{\\perp,i}$，其中 $A_{\\perp,x} = \\Delta y \\Delta z$，$A_{\\perp,y} = \\Delta x \\Delta z$，$A_{\\perp,z} = \\Delta x \\Delta y$。\n\n严格从麦克斯韦-安培定律和导线内部的线性传导本构关系出发，根据局部电场分量 $E_i$、导线的单位切向量 $\\hat{\\mathbf{t}}(s)$ 以及导线与该更新体积的几何重叠，定义由导线在第 $i$ 个边更新体积内感应的体平均电流密度分量 $J_i$。使用适合于在第 $i$ 个边更新体积上进行平均的积分形式，并通过将 $\\hat{\\mathbf{t}}(s)$ 投影到坐标轴上来形式化倾斜或弯曲导线的各向异性效应。\n\n在此基础上，推导并实现一个可计算的表达式，用于计算沿第 $i$ 个电场边的有效并联电导率 $\\sigma_{\\mathrm{eff},i}$。该电导率定义为，对于位于第 $i$ 个边更新体积内的那部分导线，关联体平均 $J_i$ 与 $E_i$ 的比例常数。您的表达式必须通过沿位于更新体积内的导线曲线部分进行积分得到，并且必须正确地包含方向投影 $\\hat{\\mathbf{t}}(s)$ 和导线的微分弧长 $\\mathrm{d}s$。\n\n您的程序必须对以下每种情况数值计算 $\\sigma_{\\mathrm{eff},x}$、$\\sigma_{\\mathrm{eff},y}$ 和 $\\sigma_{\\mathrm{eff},z}$，并对每种情况返回标量和 $\\sigma_{\\mathrm{eff},x}+\\sigma_{\\mathrm{eff},y}+\\sigma_{\\mathrm{eff},z}$，结果以 $\\mathrm{S/m}$ 为单位，表示为浮点数。角度变量必须以弧度为单位进行解释。输入规范中的所有物理量均以国际单位制（SI）给出，最终输出必须以 $\\mathrm{S/m}$ 为单位。\n\n所有情况共用的网格和导线参数：\n- $\\Delta x = \\Delta y = \\Delta z = 1\\times 10^{-3}\\,\\mathrm{m}$，\n- $a = 25\\times 10^{-6}\\,\\mathrm{m}$，\n- $\\sigma_{\\mathrm{w}} = 5.8\\times 10^{7}\\,\\mathrm{S/m}$。\n\n测试套件（三种不同的导线几何形状，均局限于单个 $i$ 边更新体积内；在每种情况下，导线段完全位于更新体积内，因此重叠长度等于导线段长度）：\n\n1. $x$–$y$ 平面内的倾斜直线段：\n   - 按弧长 $s$ 参数化：$\\mathbf{r}(s) = \\mathbf{r}_0 + \\hat{\\mathbf{t}}\\, s$，其中 $s \\in [0,\\ell]$，\n   - 单位切向量 $\\hat{\\mathbf{t}} = \\left(\\dfrac{1}{\\sqrt{5}}, \\dfrac{2}{\\sqrt{5}}, 0\\right)$，\n   - 长度 $\\ell = 0.8\\times 10^{-3}\\,\\mathrm{m}$。\n\n2. $x$–$y$ 平面内的四分之一圆弧：\n   - 按角度 $\\theta$ 参数化：$\\mathbf{r}(\\theta) = \\left(R\\cos\\theta, R\\sin\\theta, 0\\right)$，其中 $\\theta \\in [0,\\pi/2]$，\n   - 半径 $R = 0.5\\times 10^{-3}\\,\\mathrm{m}$，\n   - 使用 $\\dfrac{\\mathrm{d}s}{\\mathrm{d}\\theta} = R$ 和 $\\hat{\\mathbf{t}}(\\theta) = \\dfrac{\\mathrm{d}\\mathbf{r}/\\mathrm{d}\\theta}{\\|\\mathrm{d}\\mathbf{r}/\\mathrm{d}\\theta\\|}$。\n\n3. 近乎沿 $x$ 轴、略微向 $z$ 轴倾斜的短直线段：\n   - 按弧长 $s$ 参数化：$\\mathbf{r}(s) = \\mathbf{r}_0 + \\hat{\\mathbf{t}}\\, s$，其中 $s \\in [0,\\ell]$，\n   - 原始方向向量 $\\mathbf{v} = (1, 0, 0.01)$ 且 $\\hat{\\mathbf{t}} = \\dfrac{\\mathbf{v}}{\\|\\mathbf{v}\\|}$，\n   - 长度 $\\ell = 1\\times 10^{-5}\\,\\mathrm{m}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$），其中每个条目是对应测试用例的 $\\sigma_{\\mathrm{eff},x}+\\sigma_{\\mathrm{eff},y}+\\sigma_{\\mathrm{eff},z}$ 之和。输出必须是数值浮点值，单位为 $\\mathrm{S/m}$。",
            "solution": "该问题是有效的，因为它在计算电磁学中有科学依据，问题提出得很好，并且为获得唯一解提供了所有必要的参数。\n\n目标是推导一个表达式，用于计算亚元胞细导线对时域有限差分 (FDTD) 网格元胞中第 $i$ 个电场分量的有效电导率 $\\sigma_{\\mathrm{eff},i}$ 的贡献。这是通过在与电场分量 $E_i$ 相关的 FDTD 元胞体积上对导线的电流贡献进行体平均来实现的。\n\n基本原理是导体的欧姆定律 $\\mathbf{J} = \\sigma \\mathbf{E}$ 和体平均量的定义。问题将有效电导率 $\\sigma_{\\mathrm{eff},i}$ 定义为关联体平均电流密度分量 $J_i$ 与相应的局部电场分量 $E_i$ 的比例常数，即 $J_i = \\sigma_{\\mathrm{eff},i} E_i$。\n\n设与第 $i$ 个电场分量 ($i \\in \\{x,y,z\\}$) 相关的 FDTD 网格元胞体积为 $V_i = \\Delta x \\Delta y \\Delta z$。体平均电流密度分量 $J_i$ 定义为导线电流密度 $\\mathbf{J}_{\\mathrm{w}}$ 的第 $i$ 个分量在元胞体积上的积分，再除以元胞体积本身：\n$$\nJ_i = \\frac{1}{V_i} \\int_{V_i} \\mathbf{J}_{\\mathrm{w}}(\\mathbf{r}) \\cdot \\hat{\\mathbf{i}} \\, \\mathrm{d}V\n$$\n其中 $\\hat{\\mathbf{i}}$ 是沿第 $i$ 个坐标轴的单位向量（例如，当 $i=x$ 时为 $\\hat{\\mathbf{x}}$）。\n\n电流密度 $\\mathbf{J}_{\\mathrm{w}}$ 仅存在于导线体积内。在导线内部，它由本构关系 $\\mathbf{J}_{\\mathrm{w}} = \\sigma_{\\mathrm{w}} \\mathbf{E}_{\\mathrm{w}}$ 给出，其中 $\\sigma_{\\mathrm{w}}$ 是导线的体电导率，$\\mathbf{E}_{\\mathrm{w}}$ 是导线内部的电场。对于细导线，该电场主要平行于导线轴线，轴线由单位切向量 $\\hat{\\mathbf{t}}(s)$ 定义。导线内部电场的大小是环境网格电场 $\\mathbf{E}_{\\mathrm{grid}}$ 在切向量上的投影：$\\mathbf{E}_{\\mathrm{w}} \\approx (\\mathbf{E}_{\\mathrm{grid}} \\cdot \\hat{\\mathbf{t}}(s))\\hat{\\mathbf{t}}(s)$。\n\n由于问题寻求 $J_i$ 和 $E_i$ 之间的直接关系，我们做出标准建模近似，即在第 $i$ 个更新体积内驱动电流的环境场主要由分量 $E_i$ 主导。因此，我们近似 $\\mathbf{E}_{\\mathrm{grid}} \\approx E_i \\hat{\\mathbf{i}}$。将此代入 $\\mathbf{E}_{\\mathrm{w}}$ 的表达式中，得到：\n$$\n\\mathbf{E}_{\\mathrm{w}} \\approx ((E_i \\hat{\\mathbf{i}}) \\cdot \\hat{\\mathbf{t}}(s))\\hat{\\mathbf{t}}(s) = E_i (\\hat{\\mathbf{t}}(s) \\cdot \\hat{\\mathbf{i}}) \\hat{\\mathbf{t}}(s)\n$$\n令 $t_i(s) = \\hat{\\mathbf{t}}(s) \\cdot \\hat{\\mathbf{i}}$ 为单位切向量沿 $i$ 轴的分量。那么导线内部的电流密度向量为：\n$$\n\\mathbf{J}_{\\mathrm{w}}(s) = \\sigma_{\\mathrm{w}} E_i t_i(s) \\hat{\\mathbf{t}}(s)\n$$\n该电流密度沿 $i$ 轴的分量为：\n$$\n\\mathbf{J}_{\\mathrm{w}}(s) \\cdot \\hat{\\mathbf{i}} = \\sigma_{\\mathrm{w}} E_i t_i(s) (\\hat{\\mathbf{t}}(s) \\cdot \\hat{\\mathbf{i}}) = \\sigma_{\\mathrm{w}} E_i t_i^2(s)\n$$\n现在我们可以计算 $J_i$ 的体积积分。由于 $\\mathbf{J}_{\\mathrm{w}}$ 在导线外部为零，积分仅限于元胞内导线的体积 $V_{\\mathrm{w}, \\text{cell}}$。该体积可以通过将导线的横截面积 $A_{\\mathrm{w}} = \\pi a^2$ 沿其弧长 $s$ 积分来描述：\n$$\n\\int_{V_i} \\mathbf{J}_{\\mathrm{w}} \\cdot \\hat{\\mathbf{i}} \\, \\mathrm{d}V = \\int_{V_{\\mathrm{w}, \\text{cell}}} \\sigma_{\\mathrm{w}} E_i t_i^2(s) \\, \\mathrm{d}V = \\int_{\\text{segment}} \\left( \\int_{A_{\\mathrm{w}}} \\sigma_{\\mathrm{w}} E_i t_i^2(s) \\, \\mathrm{d}A \\right) \\mathrm{d}s\n$$\n由于 $\\sigma_{\\mathrm{w}}$、$E_i$ 和 $t_i(s)$ 在导线的亚元胞横截面上被假定为常数，内层积分简单地得出一个横截面积因子 $A_{\\mathrm{w}} = \\pi a^2$。假设 $E_i$ 在其整个更新体积内是恒定的（这是 FDTD 方法的基石），我们也可以将其从外层积分中提取出来：\n$$\n\\int_{V_i} \\mathbf{J}_{\\mathrm{w}} \\cdot \\hat{\\mathbf{i}} \\, \\mathrm{d}V = \\sigma_{\\mathrm{w}} E_i (\\pi a^2) \\int_{\\text{segment}} t_i^2(s) \\, \\mathrm{d}s\n$$\n其中积分是针对元胞内导线段的弧长进行的。将此代回 $J_i$ 的表达式中：\n$$\nJ_i = \\frac{\\pi a^2 \\sigma_{\\mathrm{w}}}{V_i} \\left( \\int_{\\text{segment}} t_i^2(s) \\, \\mathrm{d}s \\right) E_i\n$$\n通过将其与定义 $J_i = \\sigma_{\\mathrm{eff},i} E_i$ 进行比较，我们确定了第 $i$ 个分量的有效电导率：\n$$\n\\sigma_{\\mathrm{eff},i} = \\frac{\\pi a^2 \\sigma_{\\mathrm{w}}}{\\Delta x \\Delta y \\Delta z} \\int_{\\text{segment}} t_i^2(s) \\, \\mathrm{d}s\n$$\n问题要求计算和 $\\sigma_{\\mathrm{eff},x} + \\sigma_{\\mathrm{eff},y} + \\sigma_{\\mathrm{eff},z}$。这个和有一个显著的简化：\n$$\n\\sum_{i=x,y,z} \\sigma_{\\mathrm{eff},i} = \\frac{\\pi a^2 \\sigma_{\\mathrm{w}}}{V_{\\mathrm{cell}}} \\sum_{i=x,y,z} \\int_{\\text{segment}} t_i^2(s) \\, \\mathrm{d}s = \\frac{\\pi a^2 \\sigma_{\\mathrm{w}}}{V_{\\mathrm{cell}}} \\int_{\\text{segment}} (t_x^2 + t_y^2 + t_z^2) \\, \\mathrm{d}s\n$$\n由于 $\\hat{\\mathbf{t}}(s)$ 是一个单位向量，其分量的平方和为 $t_x^2(s) + t_y^2(s) + t_z^2(s) = \\|\\hat{\\mathbf{t}}(s)\\|^2 = 1$。表达式简化为：\n$$\n\\sum_{i=x,y,z} \\sigma_{\\mathrm{eff},i} = \\frac{\\pi a^2 \\sigma_{\\mathrm{w}}}{V_{\\mathrm{cell}}} \\int_{\\text{segment}} 1 \\, \\mathrm{d}s = \\frac{\\pi a^2 \\sigma_{\\mathrm{w}}}{V_{\\mathrm{cell}}} L\n$$\n其中 $L$ 是元胞内导线段的总弧长。\n\n公共参数为：\n$\\Delta x = \\Delta y = \\Delta z = 1 \\times 10^{-3}\\,\\mathrm{m} \\implies V_{\\mathrm{cell}} = 10^{-9}\\,\\mathrm{m}^3$\n$a = 25 \\times 10^{-6}\\,\\mathrm{m}$\n$\\sigma_{\\mathrm{w}} = 5.8 \\times 10^7\\,\\mathrm{S/m}$\n预因子为 $C_{\\Sigma} = \\frac{\\pi a^2 \\sigma_{\\mathrm{w}}}{V_{\\mathrm{cell}}} = \\frac{\\pi (25 \\times 10^{-6})^2 (5.8 \\times 10^7)}{10^{-9}} \\approx 113882733.9\\,\\mathrm{S/m^2}$。\n\n情况 1：倾斜直线段\n导线是直的，所以其长度为 $L = \\ell = 0.8 \\times 10^{-3}\\,\\mathrm{m}$。\n和 = $C_{\\Sigma} \\cdot L = 113882733.9 \\times (0.8 \\times 10^{-3}) \\approx 91106.187\\,\\mathrm{S/m}$。\n\n情况 2：四分之一圆弧\n弧长为 $L = R \\theta$，其中 $\\theta \\in [0, \\pi/2]$。\n$L = R (\\pi/2 - 0) = (0.5 \\times 10^{-3}) \\cdot (\\pi/2) = \\frac{\\pi}{4} \\times 10^{-3}\\,\\mathrm{m} \\approx 0.7854 \\times 10^{-3}\\,\\mathrm{m}$。\n和 = $C_{\\Sigma} \\cdot L = 113882733.9 \\times (\\frac{\\pi}{4} \\times 10^{-3}) \\approx 89445.542\\,\\mathrm{S/m}$。\n\n情况 3：近乎沿 x 轴的短直线段\n导线是直的，所以其长度为 $L = \\ell = 1 \\times 10^{-5}\\,\\mathrm{m}$。\n单位切向量为 $\\hat{\\mathbf{t}} = \\frac{(1, 0, 0.01)}{\\sqrt{1^2+0.01^2}}$，但无论其方向如何，$\\|\\hat{\\mathbf{t}}\\|^2=1$。\n和 = $C_{\\Sigma} \\cdot L = 113882733.9 \\times (1 \\times 10^{-5}) \\approx 1138.827\\,\\mathrm{S/m}$。\n\n以下程序实现了 $\\sigma_{\\mathrm{eff},i}$ 的分量计算，并按要求对结果求和。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and calculates the effective conductivity of a subcell thin wire\n    in an FDTD grid for three different wire geometries.\n    \"\"\"\n    # Define common grid and wire parameters from the problem statement\n    dx = 1e-3  # Grid spacing in x (m)\n    dy = 1e-3  # Grid spacing in y (m)\n    dz = 1e-3  # Grid spacing in z (m)\n    a = 25e-6  # Wire radius (m)\n    sigma_w = 5.8e7  # Wire bulk conductivity (S/m)\n\n    # Calculate common constants for the effective conductivity formula\n    V_cell = dx * dy * dz\n    A_w = np.pi * a**2  # Wire cross-sectional area\n    \n    # C_factor = (sigma_w * A_w) / V_cell\n    # sigma_eff_i = C_factor * integral(t_i^2 ds)\n    C_factor = (sigma_w * A_w) / V_cell\n\n    test_cases = [\n        # Case 1: Oblique straight segment in the x-y plane\n        {\n            \"type\": \"straight\",\n            \"t_hat\": np.array([1/np.sqrt(5), 2/np.sqrt(5), 0]),\n            \"length\": 0.8e-3\n        },\n        # Case 2: Quarter-circle arc in the x-y plane\n        {\n            \"type\": \"arc\",\n            \"R\": 0.5e-3,\n            \"theta_range\": (0, np.pi/2)\n        },\n        # Case 3: Nearly x-aligned short straight segment\n        {\n            \"type\": \"straight_from_v\",\n            \"v\": np.array([1.0, 0.0, 0.01]),\n            \"length\": 1e-5\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma_eff_components = np.zeros(3)  # To store [sigma_eff_x, sigma_eff_y, sigma_eff_z]\n\n        if case[\"type\"] in (\"straight\", \"straight_from_v\"):\n            length = case[\"length\"]\n            if case[\"type\"] == \"straight\":\n                t_hat = case[\"t_hat\"]\n            else: # straight_from_v\n                v = case[\"v\"]\n                t_hat = v / np.linalg.norm(v)\n\n            # For a straight wire, the tangent vector is constant.\n            # The integral of t_i^2 ds becomes t_i^2 * length.\n            integrals = (t_hat**2) * length\n            sigma_eff_components = C_factor * integrals\n\n        elif case[\"type\"] == \"arc\":\n            R = case[\"R\"]\n            theta_min, theta_max = case[\"theta_range\"]\n            \n            # For this specific arc, the tangent vector is t(theta) = [-sin(theta), cos(theta), 0].\n            # The differential arc length ds = R * d(theta).\n            # We need to compute integral_{theta_min}^{theta_max} t_i(theta)^2 * R d(theta).\n            \n            # Integral of t_x^2 ds = R * integral(sin(theta)^2 d(theta))\n            # Antiderivative of sin(theta)^2 is theta/2 - sin(2*theta)/4\n            def int_sin_sq(th): return th / 2.0 - np.sin(2.0 * th) / 4.0\n            integral_tx2_ds = R * (int_sin_sq(theta_max) - int_sin_sq(theta_min))\n            \n            # Integral of t_y^2 ds = R * integral(cos(theta)^2 d(theta))\n            # Antiderivative of cos(theta)^2 is theta/2 + sin(2*theta)/4\n            def int_cos_sq(th): return th / 2.0 + np.sin(2.0 * th) / 4.0\n            integral_ty2_ds = R * (int_cos_sq(theta_max) - int_cos_sq(theta_min))\n\n            # Integral of t_z^2 ds is 0 since t_z = 0.\n            integral_tz2_ds = 0.0\n            \n            sigma_eff_components[0] = C_factor * integral_tx2_ds\n            sigma_eff_components[1] = C_factor * integral_ty2_ds\n            sigma_eff_components[2] = C_factor * integral_tz2_ds\n\n        # The result for the case is the sum of the components\n        total_sigma_eff = np.sum(sigma_eff_components)\n        results.append(total_sigma_eff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将导线表示为等效媒质后，我们需要一种稳健的方法来施加其周围的电磁场定律。本练习探讨了一种基于麦克斯韦方程组积分形式的常用亚元胞技术。您将通过一个精心设计的思想实验，比较方形和圆形两种不同积分路径在恢复导线电流时的准确性和数值各向异性，从而深入理解亚元胞算法设计中的实际权衡 。",
            "id": "3354943",
            "problem": "考虑使用时域有限差分 (FDTD) 方法，对一根置于自由空间中、沿 $\\hat{z}$ 轴排列的长的、直的、细的电阻丝进行建模。在细线亚元胞建模中，一种常见的施加方法是基于切向电场沿包围丝线的一个小轮廓的环流。常用的轮廓选择有两种：与 Yee 网格相称的轴对齐正方形，以及几何上各向同性的圆形。您将比较这两种选择在恢复丝线电流能力和数值各向同性方面的表现。\n\n从以下基本原理出发：\n\n- 积分形式的麦克斯韦-法拉第定律：$\\oint_{\\Gamma} \\mathbf{E}\\cdot d\\boldsymbol{\\ell} = -\\dfrac{d}{dt}\\int_{S} \\mathbf{B}\\cdot \\hat{\\mathbf{n}}\\, dS$。\n- 积分形式的麦克斯韦-安培定律：$\\oint_{\\partial S} \\mathbf{H}\\cdot d\\boldsymbol{\\ell} = \\int_{S} \\mathbf{J}\\cdot \\hat{\\mathbf{n}}\\, dS + \\dfrac{d}{dt}\\int_{S} \\mathbf{D}\\cdot \\hat{\\mathbf{n}}\\, dS$。\n- Leontovich 阻抗边界条件 (LIBC)：在良导体但非理想导体的表面，切向电场和磁场通过 $\\mathbf{E}_{t} = Z_{s} \\left( \\hat{\\mathbf{n}} \\times \\mathbf{H}_{t} \\right)$ 相关联，其中 $Z_{s}$ 是表面阻抗，$\\hat{\\mathbf{n}}$ 是向外的法向量。\n\n假设在时谐场条件下，电流沿丝线缓变，使得横截面内的横向场是准静态的。对于半径为 $a$ 的圆形丝线，当纵向电流为 $I$ 时，其角向磁场为 $\\mathbf{H}_{\\phi}(r) = \\dfrac{I}{2\\pi r}\\,\\hat{\\boldsymbol{\\phi}}$（对于 $r \\ge a$）。在 Leontovich 阻抗边界条件下，这意味着丝线表面存在非零的切向电场。从这些基本原理出发，推导围绕任何环绕丝线的简单闭合轮廓 $\\Gamma$ 的环流 $\\oint_{\\Gamma}\\mathbf{E}\\cdot d\\boldsymbol{\\ell}$ 与丝线电流 $I$ 之间的关系。然后，设计两个离散数值算子来近似该轮廓积分：\n1. 一个方形轮廓算子，该算子沿一个边长为 $s$、可能旋转了角度 $\\alpha$（以弧度为单位）的轴对齐正方形对场进行采样，并通过在每条边上使用中点法则来近似积分。\n2. 一个圆形轮廓算子，该算子沿半径为 $r_{c}$ 的圆对场进行采样，并通过使用中点法则的均匀角度采样来近似积分。\n\n为了使比较独立于全场 FDTD 的细节，同时又基于基本原理，请在横截面内使用以下合成的、各向同性的角向电场模型：\n$$\n\\mathbf{E}(x,y) = \\frac{Z_{s}\\,I}{2\\pi}\\,\\frac{1}{(x-x_{0})^{2}+(y-y_{0})^{2}}\n\\begin{bmatrix}\n-(y-y_{0}) \\\\[4pt]\n\\phantom{-}(x-x_{0})\n\\end{bmatrix},\n$$\n其中 $(x_{0},y_{0})$ 是丝线在横截面中的中心。该场具有一个特性，即它围绕任何包含 $(x_{0},y_{0})$ 的光滑轮廓的精确线积分的计算结果为 $Z_{s} I$ 的一个常数倍，从而在不需要完整电磁仿真的情况下，模拟了 Leontovich 阻抗边界条件所预期的施加关系。您的数值算子将对这个连续场进行采样以近似该积分。\n\n实现这两个算子，并计算恢复的电流\n$$\nI_{\\mathrm{rec}} = \\frac{1}{Z_{s}} \\oint_{\\Gamma} \\mathbf{E}\\cdot d\\boldsymbol{\\ell},\n$$\n以安培为单位表示。量化两个性能指标：\n- 对于标称方向 $\\alpha=0$ 时电流恢复的相对误差，\n$$\n\\varepsilon = \\frac{I_{\\mathrm{rec}}-I}{I},\n$$\n以小数形式报告。\n- 针对方形算子和圆形算子，在一组旋转角度 $\\{\\alpha_{k}\\}$（以弧度为单位）上的数值各向同性度量，\n$$\n\\eta = \\frac{\\sigma\\left( I_{\\mathrm{rec}}(\\alpha_{k}) \\right)}{\\mu\\left( I_{\\mathrm{rec}}(\\alpha_{k}) \\right)},\n$$\n其中 $\\sigma(\\cdot)$ 表示在该旋转角度集合上的标准差，$\\mu(\\cdot)$ 表示平均值。\n\n沿每个分段/样本使用中点求积法。对于正方形，将总样本数 $N$ 尽可能均匀地分布在四条边上；对于圆形，按角度均匀分布样本。角度必须以弧度表示。恢复的电流必须以安培表示。相对误差和各向同性度量必须以小数表示。\n\n测试套件：\n对于下面的每种情况，按以下顺序计算四个浮点数：方形算子在 $\\alpha=0$ 时的相对误差，圆形算子在 $\\alpha=0$ 时的相对误差，方形算子在角度集上的各向同性度量，以及圆形算子在角度集上的各向同性度量。角度集为 $\\{\\alpha_{k}\\} = \\{0, \\pi/8, \\pi/4, 3\\pi/8\\}$。\n\n- 情况1（理想路径）：电流 $I=1.0$ A，表面阻抗 $Z_{s}=0.05$ $\\Omega$，丝线中心 $(x_{0},y_{0})=(0.0,0.0)$ m，方形边长 $s=1.0\\times 10^{-3}$ m，圆形半径 $r_{c}=5.0\\times 10^{-4}$ m，方形采样点数 $N=4$，圆形采样点数 $N=32$。\n- 情况2（偏置丝线，粗糙正方形）：电流 $I=1.0$ A，表面阻抗 $Z_{s}=0.05$ $\\Omega$，丝线中心 $(x_{0},y_{0})=(0.4s,-0.3s)$ m（s 为本情况中的值），方形边长 $s=5.0\\times 10^{-3}$ m，圆形半径 $r_{c}=2.5\\times 10^{-3}$ m，方形采样点数 $N=4$，圆形采样点数 $N=32$。\n- 情况3（不同参数，更精细采样）：电流 $I=2.5$ A，表面阻抗 $Z_{s}=0.2$ $\\Omega$，丝线中心 $(x_{0},y_{0})=(0.2s,0.2s)$ m（s 为本情况中的值），方形边长 $s=1.5\\times 10^{-3}$ m，圆形半径 $r_{c}=7.5\\times 10^{-4}$ m，方形采样点数 $N=16$，圆形采样点数 $N=64$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含 12 个浮点数结果（每个情况四个，按上述为情况1、情况2、情况3指定的顺序排列），形式为用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4,r5,...,r12]”）。所有角度必须以弧度为单位，恢复的电流以安培为单位，误差和各向同性度量以小数形式表示。",
            "solution": "该问题要求在模拟的细线建模情境中，比较两种数值求积方案（一种基于方形轮廓，另一种基于圆形轮廓）的准确性和数值各向同性。核心任务是近似一个给定的合成矢量场的线积分，该矢量场在载流丝线附近可作为电场的代理。\n\n首先，我们验证合成电场的属性及其与丝线电流的关系。问题给出了横截面 $(x,y)$ 平面内的合成电场如下：\n$$\n\\mathbf{E}(x,y) = \\frac{Z_{s}\\,I}{2\\pi}\\,\\frac{1}{(x-x_{0})^{2}+(y-y_{0})^{2}}\n\\begin{bmatrix}\n-(y-y_{0}) \\\\\n(x-x_{0})\n\\end{bmatrix}\n$$\n其中 $(x_0, y_0)$ 是丝线的位置，$I$ 是电流，$Z_s$ 是给定的阻抗。为了分析这个场，我们可以使用以 $(x_0, y_0)$ 为中心的极坐标系 $(\\rho, \\phi)$，其中 $x-x_0 = \\rho\\cos\\phi$ 且 $y-y_0 = \\rho\\sin\\phi$。场的矢量分量变为 $(-\\rho\\sin\\phi, \\rho\\cos\\phi)$，这对应于角向方向矢量 $\\hat{\\boldsymbol{\\phi}}$ 乘以 $\\rho$。分母是 $\\rho^2$。因此，该场简化为：\n$$\n\\mathbf{E}(\\rho, \\phi) = \\frac{Z_s I}{2\\pi\\rho} \\hat{\\boldsymbol{\\phi}}\n$$\n这是一个角向场，其大小从丝线中心开始以 $1/\\rho$ 的规律衰减，这与长直丝线周围预期的场相一致。\n\n问题假定了该场的环流与电流 $I$ 之间存在一个关系。我们可以通过直接积分来验证这个关系。设 $\\Gamma$ 是 $(x,y)$ 平面内包围位于 $(x_0, y_0)$ 的丝线的任意简单闭合轮廓。线积分为 $\\oint_{\\Gamma} \\mathbf{E}\\cdot d\\boldsymbol{\\ell}$。根据无旋场（当 $\\rho \\neq 0$ 时，该场是无旋场）的路径无关性，积分的值仅取决于所包围的奇点。我们可以选择一个以 $(x_0, y_0)$ 为中心、半径为 $R$ 的简单圆形路径。沿此路径，路径元为 $d\\boldsymbol{\\ell} = R\\,d\\phi\\,\\hat{\\boldsymbol{\\phi}}$。点积为：\n$$\n\\mathbf{E}\\cdot d\\boldsymbol{\\ell} = \\left(\\frac{Z_s I}{2\\pi R} \\hat{\\boldsymbol{\\phi}}\\right) \\cdot (R\\,d\\phi\\,\\hat{\\boldsymbol{\\phi}}) = \\frac{Z_s I}{2\\pi} d\\phi\n$$\n那么环流为：\n$$\n\\oint_{\\Gamma} \\mathbf{E}\\cdot d\\boldsymbol{\\ell} = \\int_{0}^{2\\pi} \\frac{Z_s I}{2\\pi} d\\phi = Z_s I\n$$\n这证实了合成场围绕任何包围丝线的轮廓的精确线积分结果为 $Z_s I$。因此，定义为 $I_{\\mathrm{rec}} = \\frac{1}{Z_s}\\oint_{\\Gamma} \\mathbf{E}\\cdot d\\boldsymbol{\\ell}$ 的精确恢复电流恰好等于真实电流 $I$。因此，计算出的 $I_{\\mathrm{rec}}$ 中的任何偏差都可归因于数值积分方案的误差。\n\n现在我们将设计两个指定的数值算子。两个算子都将在以坐标原点 $(0,0)$ 为中心的轮廓上进行评估。\n\n**1. 方形轮廓算子**\n该算子近似计算在一个以原点为中心、边长为 $s$ 的正方形上的线积分。该正方形可以旋转一个角度 $\\alpha$。未旋转正方形的顶点是 $P_1(-s/2, -s/2)$, $P_2(s/2, -s/2)$, $P_3(s/2, s/2)$ 和 $P_4(-s/2, s/2)$。旋转 $\\alpha$ 将顶点 $P_i=(x_i, y_i)$ 变换为 $P'_i=(x_i\\cos\\alpha - y_i\\sin\\alpha, x_i\\sin\\alpha + y_i\\cos\\alpha)$。该积分计算为沿四条边 $P'_1 \\to P'_2$、$P'_2 \\to P'_3$、$P'_3 \\to P'_4$ 和 $P'_4 \\to P'_1$ 的积分之和。\n\n总样本数 $N$ 被均匀分布，每条边有 $N_{\\text{edge}} = N/4$ 个样本。对于从顶点 $A$ 到顶点 $B$ 的一条边，应用中点法则。该边被划分为 $N_{\\text{edge}}$ 个段。表示第 $j$ 个段（$j=0, \\dots, N_{\\text{edge}}-1$）的矢量是 $\\Delta\\boldsymbol{\\ell} = (B - A) / N_{\\text{edge}}$。该段的中点是 $M_j = A + (j+0.5)\\Delta\\boldsymbol{\\ell}$。该段对积分的贡献是 $\\mathbf{E}(M_j) \\cdot \\Delta\\boldsymbol{\\ell}$。总积分是所有四条边的所有段的这些贡献之和。\n\n**2. 圆形轮廓算子**\n该算子近似计算一个以原点为中心、半径为 $r_c$ 的圆上的线积分。该圆被离散化为 $N$ 个均匀的角度段。每个段的角宽度是 $\\Delta\\theta = 2\\pi/N$。旋转 $\\alpha$ 会平移采样角度。第 $j$ 个角度段的中点位于角度 $\\theta_j = (j+0.5)\\Delta\\theta + \\alpha$。圆上的对应点是 $p_j = (r_c\\cos\\theta_j, r_c\\sin\\theta_j)$。该弧段的路径元矢量被近似为中点处的一条切线，其长度等于弧长 $r_c\\Delta\\theta$。在 $\\theta_j$ 处的切向矢量是 $\\hat{\\mathbf{t}}_j=(-\\sin\\theta_j, \\cos\\theta_j)$。因此，路径元矢量是 $\\Delta\\boldsymbol{\\ell}_j = (r_c\\Delta\\theta)\\hat{\\mathbf{t}}_j$。对积分的贡献是 $\\mathbf{E}(p_j)\\cdot\\Delta\\boldsymbol{\\ell}_j$。总积分是这些贡献在 $j=0, \\dots, N-1$ 上的总和。\n\n**性能度量**\n定义了算子之后，我们为每个测试用例计算以下两个度量：\n- **相对误差**：对于未旋转的情况（$\\alpha=0$），恢复电流的相对误差为 $\\varepsilon = (I_{\\mathrm{rec}}-I)/I$，其中 $I_{\\mathrm{rec}} = (\\oint \\mathbf{E}\\cdot d\\boldsymbol{\\ell}) / Z_s$。\n- **各向同性度量**：该度量量化了恢复电流在旋转下的稳定性。对于一组角度 $\\{\\alpha_k\\}$，它被计算为变异系数：$\\eta = \\sigma(I_{\\mathrm{rec}}(\\alpha_k)) / \\mu(I_{\\mathrm{rec}}(\\alpha_k))$，其中 $\\sigma$ 和 $\\mu$ 分别是恢复电流在该角度集上的标准差和平均值。$\\eta$ 值越低，表示数值各向同性越好。\n\n实现过程将首先为每个算子构建函数，然后将它们应用于所提供的三个测试用例的参数。",
            "answer": "```python\nimport numpy as np\n\ndef electric_field(x, y, x0, y0, Zs, I):\n    \"\"\"\n    Computes the synthetic electric field at a point (x, y).\n    \n    Args:\n        x, y (float): Coordinates of the evaluation point.\n        x0, y0 (float): Coordinates of the filament center.\n        Zs (float): Surface impedance.\n        I (float): Filament current.\n        \n    Returns:\n        np.ndarray: A 2-element array for the E-field vector [Ex, Ey].\n    \"\"\"\n    C = Zs * I / (2 * np.pi)\n    dx, dy = x - x0, y - y0\n    den = dx**2 + dy**2\n    if den == 0:\n        # This should not happen if sample points are not at the singularity\n        return np.array([0.0, 0.0])\n    \n    Ex = C * -dy / den\n    Ey = C * dx / den\n    return np.array([Ex, Ey])\n\ndef integrate_square(s, N, alpha, x0, y0, Zs, I):\n    \"\"\"\n    Computes the line integral of E around a rotated square contour.\n    \n    Args:\n        s (float): Side length of the square.\n        N (int): Total number of samples for quadrature.\n        alpha (float): Rotation angle in radians.\n        x0, y0, Zs, I: Parameters for the electric_field function.\n        \n    Returns:\n        float: The numerically calculated line integral.\n    \"\"\"\n    cos_a, sin_a = np.cos(alpha), np.sin(alpha)\n    R = np.array([[cos_a, -sin_a], [sin_a, cos_a]])\n    \n    h = s / 2.0\n    vertices_unrotated = [\n        np.array([-h, -h]),\n        np.array([h, -h]),\n        np.array([h, h]),\n        np.array([-h, h])\n    ]\n    \n    vertices_rotated = [v @ R.T for v in vertices_unrotated]\n    \n    total_integral = 0.0\n    N_edge = N // 4\n    \n    for i in range(4):\n        p_start = vertices_rotated[i]\n        p_end = vertices_rotated[(i + 1) % 4]\n        delta_l_vec = (p_end - p_start) / N_edge\n        \n        for j in range(N_edge):\n            midpoint = p_start + (j + 0.5) * delta_l_vec\n            E_vec = electric_field(midpoint[0], midpoint[1], x0, y0, Zs, I)\n            total_integral += np.dot(E_vec, delta_l_vec)\n            \n    return total_integral\n\ndef integrate_circle(rc, N, alpha, x0, y0, Zs, I):\n    \"\"\"\n    Computes the line integral of E around a circular contour.\n    \n    Args:\n        rc (float): Radius of the circle.\n        N (int): Total number of samples for quadrature.\n        alpha (float): Rotation angle (phase offset) in radians.\n        x0, y0, Zs, I: Parameters for the electric_field function.\n        \n    Returns:\n        float: The numerically calculated line integral.\n    \"\"\"\n    total_integral = 0.0\n    delta_theta = 2 * np.pi / N\n    \n    for j in range(N):\n        theta_mid = (j + 0.5) * delta_theta + alpha\n        \n        # Midpoint position\n        x_mid = rc * np.cos(theta_mid)\n        y_mid = rc * np.sin(theta_mid)\n        \n        # Path element vector dl = (rc * dtheta) * tangent_vector\n        # tangent_vector = (-sin(theta), cos(theta))\n        dl_vec = np.array([-np.sin(theta_mid), np.cos(theta_mid)]) * rc * delta_theta\n        \n        E_vec = electric_field(x_mid, y_mid, x0, y0, Zs, I)\n        total_integral += np.dot(E_vec, dl_vec)\n        \n    return total_integral\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {'I': 1.0, 'Zs': 0.05, 's': 1.0e-3, 'rc': 5.0e-4, 'N_sq': 4, 'N_circ': 32, 'x0_factor': 0.0, 'y0_factor': 0.0},\n        {'I': 1.0, 'Zs': 0.05, 's': 5.0e-3, 'rc': 2.5e-3, 'N_sq': 4, 'N_circ': 32, 'x0_factor': 0.4, 'y0_factor': -0.3},\n        {'I': 2.5, 'Zs': 0.2, 's': 1.5e-3, 'rc': 7.5e-4, 'N_sq': 16, 'N_circ': 64, 'x0_factor': 0.2, 'y0_factor': 0.2},\n    ]\n\n    angles = [0.0, np.pi/8, np.pi/4, 3*np.pi/8]\n    all_results = []\n\n    for case in test_cases:\n        I, Zs = case['I'], case['Zs']\n        s, rc = case['s'], case['rc']\n        N_sq, N_circ = case['N_sq'], case['N_circ']\n        x0 = case['x0_factor'] * s\n        y0 = case['y0_factor'] * s\n        \n        # 1. Square-operator relative error at alpha=0\n        integral_sq_0 = integrate_square(s, N_sq, 0.0, x0, y0, Zs, I)\n        I_rec_sq_0 = integral_sq_0 / Zs\n        err_sq = (I_rec_sq_0 - I) / I\n        all_results.append(err_sq)\n        \n        # 2. Circular-operator relative error at alpha=0\n        integral_circ_0 = integrate_circle(rc, N_circ, 0.0, x0, y0, Zs, I)\n        I_rec_circ_0 = integral_circ_0 / Zs\n        err_circ = (I_rec_circ_0 - I) / I\n        all_results.append(err_circ)\n        \n        # 3. Square-operator isotropy metric\n        I_rec_sq_vals = []\n        for alpha in angles:\n            integral = integrate_square(s, N_sq, alpha, x0, y0, Zs, I)\n            I_rec_sq_vals.append(integral / Zs)\n        \n        mean_sq = np.mean(I_rec_sq_vals)\n        std_sq = np.std(I_rec_sq_vals)\n        eta_sq = std_sq / mean_sq if mean_sq != 0 else 0\n        all_results.append(eta_sq)\n\n        # 4. Circular-operator isotropy metric\n        I_rec_circ_vals = []\n        for alpha in angles:\n            integral = integrate_circle(rc, N_circ, alpha, x0, y0, Zs, I)\n            I_rec_circ_vals.append(integral / Zs)\n\n        mean_circ = np.mean(I_rec_circ_vals)\n        std_circ = np.std(I_rec_circ_vals)\n        eta_circ = std_circ / mean_circ if mean_circ != 0 else 0\n        all_results.append(eta_circ)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.12g}' for r in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个完整的仿真不仅需要精确的物理模型，还需要模型与吸收边界条件之间的正确交互。本项高级练习研究了薄导线穿过完美匹配层（PML）这一具有挑战性的场景。它将引导您使用强大的传输线类比方法，来分析当导线模型与 PML 相互作用时产生的寄生反射，这对于确保包含复杂几何的 FDTD 仿真的整体准确性至关重要 。",
            "id": "3354927",
            "problem": "考虑一个二维 $z$ 方向横向磁波 (TM$_z$) 的时域有限差分 (FDTD) 配置，其中自由空间占据半空间 $x < 0$，一个半无限、均匀的完美匹配层 (PML) 占据半空间 $x > 0$。自由空间区域的特性由真空介电常数 $\\varepsilon_0$ 和真空磁导率 $\\mu_0$ 决定。PML 通过复坐标拉伸进行建模，其电场拉伸参数 $s_e$ 和磁场拉伸参数 $s_m$ 在 PML 板内不随位置和频率变化。一根沿 $z$ 方向的细导线穿过 $x = 0$ 处的平面界面，其子单元模型通过在局部 $E_z$ 自由度上附加一个集总并联导纳 $Y_w$（单位为西门子），来修正界面 FDTD 单元中的局部安培环路定理更新。\n\n从麦克斯韦方程组的微分形式、真空本构关系以及 PML 的复坐标拉伸表示出发，推导半无限 PML 的复平面波输入阻抗 $Z_{\\text{pml}}$ 的表达式，该表达式应以 $\\mu_0$、$\\varepsilon_0$、$s_e$ 和 $s_m$ 表示。然后，将界面单元处细导线子单元导纳 $Y_w$ 的相互作用建模为一个并联导纳，该导纳与正入射的 TM$_z$ 平面波所看到的 PML 输入导纳并联。仅使用这些原理，推导在 $x=0$ 处，一个源于自由空间并入射到被细导线子单元修正的 PML 界面上的平面波的复正入射反射系数，该系数需完全用基本常数 $\\mu_0$、$\\varepsilon_0$ 以及参数 $s_e$、$s_m$ 和 $Y_w$ 来表示。您必须明确说明用于将场公式与阻抗概念联系起来所使用的任何连续性条件和等效关系。\n\n您的程序必须实现所推导的公式，以计算以下每个测试用例的复反射系数的幅值。在每个用例中，根据给定的实值拉伸设计参数 $\\kappa_e$、$\\sigma_e$（单位为西门子/米）、$\\kappa_m$ 和 $\\sigma_m$（单位为西门子/米），在指定的频率 $f$（单位为赫兹）下，使用以下公式计算 $s_e$ 和 $s_m$\n$$\ns_e = \\kappa_e + \\frac{\\sigma_e}{j\\,\\omega\\,\\varepsilon_0},\\qquad\ns_m = \\kappa_m + \\frac{\\sigma_m}{j\\,\\omega\\,\\mu_0},\n$$\n其中 $\\omega = 2\\pi f$。所有量必须在国际单位制（SI）中处理。以无量纲小数形式报告最终的反射系数幅值。自由空间平面波阻抗为 $Z_0 = \\sqrt{\\mu_0/\\varepsilon_0}$。\n\n测试套件（每个元组为 $(f,\\ \\kappa_e,\\ \\sigma_e,\\ \\kappa_m,\\ \\sigma_m,\\ Y_w)$，所有值均采用国际单位制）：\n- 情况 A（匹配，无导线）： ($1.0 \\times 10^9$, 1, 0, 1, 0, 0)。\n- 情况 B（匹配，中等损耗，弱导线）： ($1.0 \\times 10^9$, 1, $5.0 \\times 10^4$, 1, $5.0 \\times 10^4 \\cdot \\mu_0 / \\varepsilon_0$, $1.0 \\times 10^{-3}$)。\n- 情况 C（拉伸失配，较强导线）： ($1.0 \\times 10^9$, 1, $5.0 \\times 10^4$, 1, 0, $1.0 \\times 10^{-2}$)。\n- 情况 D（匹配，更高频率，极弱导线）： ($2.0 \\times 10^9$, 1, $2.0 \\times 10^4$, 1, $2.0 \\times 10^4 \\cdot \\mu_0 / \\varepsilon_0$, $1.0 \\times 10^{-6}$)。\n- 情况 E（匹配，极强导线）： ($1.0 \\times 10^9$, 1, $5.0 \\times 10^4$, 1, $5.0 \\times 10^4 \\cdot \\mu_0 / \\varepsilon_0$, $1.0 \\times 10^6$)。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$），列表中的每个条目是与上述情况相对应的反射幅值，顺序相同。不允许有其他输出。将反射幅值表示为小数（无单位）。",
            "solution": "该问题要求推导在自由空间和半无限完美匹配层 (PML) 之间的界面处的正入射反射系数，该界面被一个细导线子单元模型所修正。推导将从麦克斯韦方程组开始，并采用 PML 的复坐标拉伸表示法。\n\n**第 1 步：PML 波阻抗推导**\n\n我们从频域中的麦克斯韦旋度方程开始（相量形式，假设时间依赖性为 $e^{j\\omega t}$）：\n$$\n\\nabla \\times \\mathbf{E} = -j\\omega \\mathbf{B}\n$$\n$$\n\\nabla \\times \\mathbf{H} = j\\omega \\mathbf{D}\n$$\n设计用于吸收沿 $x$ 方向传播的波的 PML 可以被建模为单轴各向异性介质。在 $x>0$ 区域，具有电场拉伸参数 $s_e$ 和磁场拉伸参数 $s_m$（两者均为均匀且为复数值）的复坐标拉伸等效于在 PML 区域使用以下本构关系：\n$$\n\\mathbf{D} = \\bar{\\bar{\\varepsilon}} \\cdot \\mathbf{E} \\quad \\text{其中} \\quad \\bar{\\bar{\\varepsilon}} = \\varepsilon_0 \\begin{pmatrix} 1/s_e  0  0 \\\\ 0  s_e  0 \\\\ 0  0  s_e \\end{pmatrix}\n$$\n$$\n\\mathbf{B} = \\bar{\\bar{\\mu}} \\cdot \\mathbf{H} \\quad \\text{其中} \\quad \\bar{\\bar{\\mu}} = \\mu_0 \\begin{pmatrix} 1/s_m  0  0 \\\\ 0  s_m  0 \\\\ 0  0  s_m \\end{pmatrix}\n$$\n我们考虑一个沿 $x$ 轴正入射进入 PML 的 $z$ 方向横向磁波 (TM$_z$) 平面波。其场分量为 $\\mathbf{E} = E_z(x)\\hat{z}$ 和 $\\mathbf{H} = H_y(x)\\hat{y}$。\n\n将这些场代入麦克斯韦旋度方程：\n由 $\\nabla \\times \\mathbf{E} = -j\\omega\\mathbf{B}$ 可得：\n$$\n\\begin{vmatrix} \\hat{x}  \\hat{y}  \\hat{z} \\\\ \\frac{\\partial}{\\partial x}  \\frac{\\partial}{\\partial y}  \\frac{\\partial}{\\partial z} \\\\ 0  0  E_z(x) \\end{vmatrix} = \\frac{\\partial E_z}{\\partial x} \\hat{y} = -j\\omega (\\bar{\\bar{\\mu}} \\cdot \\mathbf{H})\n$$\n$\\bar{\\bar{\\mu}} \\cdot \\mathbf{H}$ 的 $y$ 分量是 $\\mu_{yy} H_y = \\mu_0 s_m H_y$。因此，\n$$\n\\frac{dE_z}{dx} = -j\\omega\\mu_0 s_m H_y \\quad (1)\n$$\n由 $\\nabla \\times \\mathbf{H} = j\\omega\\mathbf{D}$ 可得：\n$$\n\\begin{vmatrix} \\hat{x}  \\hat{y}  \\hat{z} \\\\ \\frac{\\partial}{\\partial x}  \\frac{\\partial}{\\partial y}  \\frac{\\partial}{\\partial z} \\\\ 0  H_y(x)  0 \\end{vmatrix} = -\\frac{\\partial H_y}{\\partial x} \\hat{z} = j\\omega (\\bar{\\bar{\\varepsilon}} \\cdot \\mathbf{E})\n$$\n$\\bar{\\bar{\\varepsilon}} \\cdot \\mathbf{E}$ 的 $z$ 分量是 $\\varepsilon_{zz} E_z = \\varepsilon_0 s_e E_z$。因此，\n$$\n-\\frac{dH_y}{dx} = j\\omega\\varepsilon_0 s_e E_z \\quad \\implies \\quad \\frac{dH_y}{dx} = -j\\omega\\varepsilon_0 s_e E_z \\quad (2)\n$$\n为了求得波阻抗，我们假设解的形式为 $E_z(x) = E_0 e^{-\\gamma_x x}$ 和 $H_y(x) = H_0 e^{-\\gamma_x x}$，其中 $\\gamma_x$ 是 PML 中的传播常数。代入方程 $(1)$ 和 $(2)$：\n$$\n-\\gamma_x E_z = -j\\omega\\mu_0 s_m H_y \\quad (3)\n$$\n$$\n-\\gamma_x H_y = -j\\omega\\varepsilon_0 s_e E_z \\quad (4)\n$$\nPML 介质的横向波阻抗 $Z_{\\text{pml}}$ 定义为横向电场与磁场之比，即 $Z_{\\text{pml}} = E_z / H_y$。根据方程 $(3)$：\n$$\nZ_{\\text{pml}} = \\frac{E_z}{H_y} = \\frac{j\\omega\\mu_0 s_m}{\\gamma_x}\n$$\n为了求得 $\\gamma_x$，我们将方程 $(3)$ 与 $(4)$ 相乘：\n$$\n(-\\gamma_x E_z)(-\\gamma_x H_y) = (-j\\omega\\mu_0 s_m H_y)(-j\\omega\\varepsilon_0 s_e E_z)\n$$\n$$\n\\gamma_x^2 (E_z H_y) = (j\\omega)^2 \\mu_0 \\varepsilon_0 s_e s_m (E_z H_y)\n$$\n$$\n\\gamma_x^2 = -\\omega^2 \\mu_0 \\varepsilon_0 s_e s_m \\quad \\implies \\quad \\gamma_x = j\\omega\\sqrt{\\mu_0 \\varepsilon_0 s_e s_m}\n$$\n我们选择 $\\gamma_x$ 的根使其具有正实部，以确保在 $+x$ 方向上的衰减。将 $\\gamma_x$ 代入 $Z_{\\text{pml}}$ 的表达式：\n$$\nZ_{\\text{pml}} = \\frac{j\\omega\\mu_0 s_m}{j\\omega\\sqrt{\\mu_0 \\varepsilon_0 s_e s_m}} = \\frac{\\mu_0 s_m}{\\sqrt{\\mu_0\\varepsilon_0 s_e s_m}} = \\sqrt{\\frac{\\mu_0^2 s_m^2}{\\mu_0\\varepsilon_0 s_e s_m}} = \\sqrt{\\frac{\\mu_0 s_m}{\\varepsilon_0 s_e}}\n$$\n考虑到自由空间阻抗 $Z_0 = \\sqrt{\\mu_0/\\varepsilon_0}$，PML 波阻抗为：\n$$\nZ_{\\text{pml}} = Z_0 \\sqrt{\\frac{s_m}{s_e}}\n$$\n由于 PML 是半无限的，其输入阻抗等于其特性波阻抗。\n\n**第 2 步：反射系数计算**\n\n界面上的平面波反射问题可以使用等效传输线电路进行建模。这种等效性由切向场（$E_z$ 和 $H_y$）在界面 $x=0$ 处的连续性所保证。自由空间区域（$x0$）是一条特性阻抗为 $Z_0$ 的传输线。区域 $x0$ 代表负载。\n\n$x=0$ 处的负载由两个并联的组件构成：\n1. 半无限 PML 的输入阻抗 $Z_{\\text{pml}}$。\n2. 细导线子单元的阻抗，其以并联导纳 $Y_w$ 的形式给出。\n\n对于并联组件，使用导纳进行计算最为方便。\n自由空间的特性导纳为 $Y_0 = 1/Z_0 = \\sqrt{\\varepsilon_0/\\mu_0}$。\nPML 的输入导纳为 $Y_{\\text{pml}} = 1/Z_{\\text{pml}} = \\frac{1}{Z_0\\sqrt{s_m/s_e}} = Y_0 \\sqrt{\\frac{s_e}{s_m}}$。\n总负载导纳 $Y_L$ 是并联导纳之和：\n$$\nY_L = Y_{\\text{pml}} + Y_w = Y_0 \\sqrt{\\frac{s_e}{s_m}} + Y_w\n$$\n负载处的电压反射系数 $\\Gamma$ 由标准的传输线公式给出，用导纳表示为：\n$$\n\\Gamma = \\frac{Y_0 - Y_L}{Y_0 + Y_L}\n$$\n代入 $Y_L$ 的表达式：\n$$\n\\Gamma = \\frac{Y_0 - \\left(Y_0 \\sqrt{\\frac{s_e}{s_m}} + Y_w\\right)}{Y_0 + \\left(Y_0 \\sqrt{\\frac{s_e}{s_m}} + Y_w\\right)}\n$$\n提取公因数 $Y_0$ 并重新整理，得到复反射系数的最终表达式：\n$$\n\\Gamma = \\frac{Y_0 \\left(1 - \\sqrt{\\frac{s_e}{s_m}}\\right) - Y_w}{Y_0 \\left(1 + \\sqrt{\\frac{s_e}{s_m}}\\right) + Y_w}\n$$\n根据要求，该表达式仅通过 $Y_0 = \\sqrt{\\varepsilon_0/\\mu_0}$ 依赖于基本常数，以及指定的参数 $s_e$、$s_m$ 和 $Y_w$。为了实现计算，复数参数 $s_e$ 和 $s_m$ 是根据给定的实值设计参数使用以下公式计算的：\n$$\ns_e = \\kappa_e + \\frac{\\sigma_e}{j\\,\\omega\\,\\varepsilon_0}\n$$\n$$\ns_m = \\kappa_m + \\frac{\\sigma_m}{j\\,\\omega\\,\\mu_0}\n$$\n其中 $\\omega = 2\\pi f$。程序将为每个测试用例计算 $|\\Gamma|$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries outside the Python standard library are permitted.\n# scipy.constants is not used to adhere strictly to the rules.\n\ndef solve():\n    \"\"\"\n    Computes the magnitude of the complex reflection coefficient for a plane wave\n    impinging on a PML-wire interface from free space.\n    \"\"\"\n\n    # Define fundamental physical constants in SI units.\n    # From CODATA 2018. c is exact by definition of the meter. mu_0 is exact by\n    # definition of the Ampere. epsilon_0 is derived.\n    c0 = 299792458.0  # Speed of light in vacuum (m/s)\n    mu_0 = 4.0 * np.pi * 1.0e-7  # Vacuum permeability (H/m)\n    epsilon_0 = 1.0 / (mu_0 * c0**2)  # Vacuum permittivity (F/m)\n\n    # Characteristic admittance of free space\n    Y_0 = np.sqrt(epsilon_0 / mu_0)\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (f, kappa_e, sigma_e, kappa_m, sigma_m, Y_w)\n    # with all values in SI units.\n    test_cases = [\n        # Case A (matched, no wire)\n        (1.0e9, 1.0, 0.0, 1.0, 0.0, 0.0),\n        # Case B (matched, moderate loss, weak wire)\n        (1.0e9, 1.0, 5.0e4, 1.0, 5.0e4 * mu_0 / epsilon_0, 1.0e-3),\n        # Case C (mismatched stretch, stronger wire)\n        (1.0e9, 1.0, 5.0e4, 1.0, 0.0, 1.0e-2),\n        # Case D (matched, higher frequency, very weak wire)\n        (2.0e9, 1.0, 2.0e4, 1.0, 2.0e4 * mu_0 / epsilon_0, 1.0e-6),\n        # Case E (matched, extremely strong wire)\n        (1.0e9, 1.0, 5.0e4, 1.0, 5.0e4 * mu_0 / epsilon_0, 1.0e6),\n    ]\n\n    results = []\n    for case in test_cases:\n        f, kappa_e, sigma_e, kappa_m, sigma_m, Y_w = case\n\n        # Angular frequency\n        omega = 2.0 * np.pi * f\n\n        # Complex value j\n        j = 1j\n\n        # Calculate complex stretching parameters s_e and s_m\n        s_e = kappa_e + sigma_e / (j * omega * epsilon_0)\n        s_m = kappa_m + sigma_m / (j * omega * mu_0)\n        \n        # Derived formula for the reflection coefficient Gamma\n        # Gamma = (Y_0 * (1 - sqrt(s_e/s_m)) - Y_w) / (Y_0 * (1 + sqrt(s_e/s_m)) + Y_w)\n        \n        # Handle the case where s_m is zero to avoid division by zero, though\n        # not expected with the given test cases.\n        if s_m == 0:\n            # If s_m is 0, the ratio is infinite, so sqrt(s_e/s_m) is infinite.\n            # Gamma would approach -1.\n            gamma = -1.0\n        else:\n            sqrt_ratio = np.sqrt(s_e / s_m)\n            numerator = Y_0 * (1.0 - sqrt_ratio) - Y_w\n            denominator = Y_0 * (1.0 + sqrt_ratio) + Y_w\n            \n            # Handle the case where the denominator might be zero.\n            if denominator == 0:\n                # This would imply infinite reflection, which is unphysical.\n                # Per problem, we expect a stable solution so this should not occur.\n                # However, for robustness, one might handle it.\n                # For now, we assume it does not happen with valid inputs.\n                gamma = np.inf\n            else:\n                gamma = numerator / denominator\n\n        # The problem asks for the magnitude of the reflection coefficient.\n        reflection_magnitude = np.abs(gamma)\n        results.append(reflection_magnitude)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}