{
    "hands_on_practices": [
        {
            "introduction": "我们从最基础的模型降阶技术——本征正交分解（Proper Orthogonal Decomposition, POD）——开始。POD 从一组给定的数据（例如仿真快照）中提取出一个在能量上最优的基。本练习将快照矩阵的奇异值分解（SVD）与系统的物理能量直接联系起来，通过从时域仿真数据中生成降阶基并验证其关键理论特性（例如投影误差与奇异值之间的关系），您将获得宝贵的实践经验 。",
            "id": "3345280",
            "problem": "考虑一个长度为 $L$ 的一维、无损、均匀真空域，其具有周期性边界条件。电磁场在具有 $N$ 个单元和空间步长 $\\Delta x = L/N$ 的均匀 Yee 网格上进行离散化。记横截面积为 $A=1$ 平方米，因此单元体积为 $\\Delta V = A \\Delta x = \\Delta x$。设电场分量为 $E(x,t)$，磁场分量为 $H(x,t)$，其中光速为 $c_0 = 1/\\sqrt{\\mu_0 \\varepsilon_0}$，真空介电常数为 $\\varepsilon_0$，真空磁导率为 $\\mu_0$。时间步长 $\\Delta t$ 满足一维传播的 Courant 稳定性条件，即 $c_0 \\Delta t \\le \\Delta x$。时域有限差分 (FDTD) 离散化使用交错格式对 $E$ 和 $H$ 进行时间更新：\n$$\nH^{n+\\frac{1}{2}}_i = H^{n-\\frac{1}{2}}_i + \\frac{\\Delta t}{\\mu_0 \\Delta x}\\left(E^n_{i+1} - E^n_i\\right),\n$$\n$$\nE^{n+1}_i = E^n_i + \\frac{\\Delta t}{\\varepsilon_0 \\Delta x}\\left(H^{n+\\frac{1}{2}}_i - H^{n+\\frac{1}{2}}_{i-1}\\right),\n$$\n其中下标是周期性的，即 $E^n_{i+N} = E^n_i$ 和 $H^{n+\\frac{1}{2}}_{i+N} = H^{n+\\frac{1}{2}}_i$。在时间步 $n$ 的离散总电磁能量为\n$$\n\\mathcal{W}^n = \\frac{1}{2}\\sum_{i=0}^{N-1}\\varepsilon_0 \\left(E^n_i\\right)^2 \\Delta x + \\frac{1}{2}\\sum_{i=0}^{N-1}\\mu_0 \\left(H^{n+\\frac{1}{2}}_i\\right)^2 \\Delta x,\n$$\n以焦耳 (Joules) 为单位。对于此周期性无源系统，离散 Poynting 定理意味着 $\\mathcal{W}^n$ 在 $n$ 上是恒定的。\n\n在离散时间 $t_k = k \\Delta t$（其中 $k \\in \\{0,1,\\ldots,m-1\\}$）收集 $m$ 个电场快照，形成快照矩阵 $X \\in \\mathbb{R}^{N \\times m}$，其列为 $x_k \\in \\mathbb{R}^N$，其中 $x_k$ 是 $E^k_i$ 的向量。定义电场向量能量内积的对称正定权重矩阵为 $W_E = \\varepsilon_0 \\Delta x \\, I_N$，其中 $I_N$ 是大小为 $N$ 的单位矩阵。秩为 $r$ 的本征正交分解 (POD) 基是相对于 $W_E$-内积构造的，通过对缩放后的快照矩阵 $Y = W_E^{1/2} X / \\sqrt{m}$ 进行奇异值分解 (SVD) 实现，其中 $W_E^{1/2}$ 是 $W_E$ 的对称平方根。设 $Y = U \\Sigma V^\\top$ 是其 SVD 分解，其中奇异值 $\\sigma_i$ 位于 $\\Sigma$ 的对角线上，左奇异向量位于 $U$ 中。$W_E$-正交归一的 POD 基是矩阵 $\\Phi_r = W_E^{-1/2} U_r$，其中 $U_r$ 包含 $U$ 的前 $r$ 列。快照 $x_k$ 到 $\\mathrm{span}(\\Phi_r)$ 上的 $W_E$-正交投影为 $P_r x_k = \\Phi_r \\Phi_r^\\top W_E x_k$。\n\n定义均方能量范数投影误差\n$$\nJ_r = \\frac{1}{m} \\sum_{k=0}^{m-1} \\left\\| x_k - P_r x_k \\right\\|_{W_E}^2,\n$$\n其中 $\\|z\\|_{W_E}^2 = z^\\top W_E z$。使用离散 Poynting 定理，任意时刻的电场能量满足\n$$\n\\|x_k\\|_{W_E}^2 \\le 2 \\mathcal{W}^0,\n$$\n其中 $\\mathcal{W}^0$ 是初始总电磁能量。这给出了一个先验界\n$$\nJ_r \\le \\sum_{i=r+1}^{p} \\sigma_i^2 \\le \\frac{1}{m}\\sum_{k=0}^{m-1} \\|x_k\\|_{W_E}^2 \\le 2 \\mathcal{W}^0,\n$$\n其中 $p = \\mathrm{rank}(Y)$。\n\n你的任务是：\n1. 按照描述实现一维 FDTD 格式，使用常数 $\\varepsilon_0 = 8.854187817 \\times 10^{-12}$ (法拉每米)，$\\mu_0 = 4\\pi \\times 10^{-7}$ (亨利每米)，以及 $c_0 = 1/\\sqrt{\\mu_0 \\varepsilon_0}$。用两个高斯脉冲的叠加给出的 $E(x,0)$ 来初始化 $t=0$ 时的场，\n$$\nE(x,0) = E_0 \\left(\\exp\\left(-\\frac{(x - 0.25L)^2}{w^2}\\right) - \\exp\\left(-\\frac{(x - 0.75L)^2}{w^2}\\right)\\right),\n$$\n以及 $H(x,0) = 0$。使用 $E_0 = 1$ (伏特每米) 和 $w = 0.05 L$ (米)。从模拟的 $E$ 场中收集 $m$ 个快照 $x_k$。\n2. 使用上面指定的加权 SVD 构建 POD 基，并计算 $m$ 个快照上的均方能量范数投影误差 $J_r$、POD 尾部和 $\\sum_{i=r+1}^{p} \\sigma_i^2$、基于 Poynting 定理的先验界 $2 \\mathcal{W}^0$ (焦耳)，以及在所有时间步 $n \\in \\{0,\\ldots,m-1\\}$ 上 $\\mathcal{W}^n$ 相对于 $\\mathcal{W}^0$ 的最大绝对偏差 (焦耳)。\n3. 所有能量单位均以焦耳表示。不使用角度。不涉及百分比；所有量均为实数。\n\n测试套件：\n- 情况 A (一般情况)：$L = 1$ 米, $N = 128$, $m = 120$, $r = 10$, $\\Delta t = 0.99 \\, \\Delta x / c_0$ 秒。\n- 情况 B (投影误差接近零的边界情况)：$L = 1$ 米, $N = 80$, $m = 60$, $r = 60$, $\\Delta t = 0.99 \\, \\Delta x / c_0$ 秒。\n- 情况 C (零维降维空间的边缘情况)：$L = 1$ 米, $N = 100$, $m = 50$, $r = 0$, $\\Delta t = 0.99 \\, \\Delta x / c_0$ 秒。\n\n要求的最终输出格式：\n你的程序应生成单行输出，其中包含一个逗号分隔的列表，列表被方括号括起来，每个测试用例的结果本身就是一个形如 $[J_r, \\sum_{i=r+1}^{p} \\sigma_i^2, 2\\mathcal{W}^0, \\max_n |\\mathcal{W}^n - \\mathcal{W}^0|]$ 的列表。例如，输出必须如下所示：\n$$\n[[J_{r,A}, \\mathrm{tail}_A, \\mathrm{bound}_A, \\mathrm{dev}_A],[J_{r,B}, \\mathrm{tail}_B, \\mathrm{bound}_B, \\mathrm{dev}_B],[J_{r,C}, \\mathrm{tail}_C, \\mathrm{bound}_C, \\mathrm{dev}_C]].\n$$\n所有数字都以焦耳为单位，并且必须打印为不带单位的原始十进制浮点数。",
            "solution": "用户提供了一个计算电磁学问题，要求实现一维时域有限差分 (FDTD) 模拟，然后对得到的场快照进行本征正交分解 (POD)。任务是计算与系统能量和基于 POD 的投影误差相关的几个量。\n\n### 基于原理的设计与方法\n\n解决该问题的方法是首先实现物理模拟，然后进行数学分析（模型降阶）。\n\n**1. FDTD 模拟**\n\n该模拟对一维、周期性、无损真空域中的电磁波传播进行建模。控制方程是麦克斯韦方程组，对于横电磁 (TEM) 波，在一维情况下简化为一个耦合的一阶偏微分方程组：\n$$\n\\frac{\\partial H}{\\partial t} = \\pm \\frac{1}{\\mu_0} \\frac{\\partial E}{\\partial x}\n$$\n$$\n\\frac{\\partial E}{\\partial t} = \\pm \\frac{1}{\\varepsilon_0} \\frac{\\partial H}{\\partial x}\n$$\n问题提供了一组特定的离散更新方程，它们对应一个有效、能量守恒的波传播系统，尽管其符号约定不传统（二者皆为正），这可以解释为对其中一个场分量的重新定义。我们将完全按照所述实现这些方程。\n\nFDTD 方法将空间和时间离散化。问题指定了 Yee 网格，这是一种交错网格排列。电场 $E$ 分量位于整数格点 $i\\Delta x$ 处，而磁场 $H$ 分量位于半整数格点 $(i+\\frac{1}{2})\\Delta x$ 处。时间步进也是交错的（一种“蛙跳”格式）：$E$ 在整数时间步 $n\\Delta t$ 计算，而 $H$ 在半整数时间步 $(n+\\frac{1}{2})\\Delta t$ 计算。\n\n给出的更新方程是：\n$$\nH^{n+\\frac{1}{2}}_i = H^{n-\\frac{1}{2}}_i + \\frac{\\Delta t}{\\mu_0 \\Delta x}\\left(E^n_{i+1} - E^n_i\\right)\n$$\n$$\nE^{n+1}_i = E^n_i + \\frac{\\Delta t}{\\varepsilon_0 \\Delta x}\\left(H^{n+\\frac{1}{2}}_i - H^{n+\\frac{1}{2}}_{i-1}\\right)\n$$\n这些使用数组操作实现。周期性边界条件通过循环移位（`numpy.roll`）处理。模拟从给定的初始电场 $E(x,0)$ 和零初始磁场开始。在蛙跳格式中，这被解释为 $H^{-1/2} = 0$。模拟运行 $m$ 个时间步，在每一步 $k$，电场向量 $E^k$ 作为一列存储在快照矩阵 $X$ 中。\n\n**2. 能量计算**\n\n在模拟过程中，每一步 $n$ 都会计算总电磁能量 $\\mathcal{W}^n$。问题提供了离散、交错能量的公式：\n$$\n\\mathcal{W}^n = \\frac{1}{2}\\sum_{i=0}^{N-1}\\varepsilon_0 \\left(E^n_i\\right)^2 \\Delta x + \\frac{1}{2}\\sum_{i=0}^{N-1}\\mu_0 \\left(H^{n+\\frac{1}{2}}_i\\right)^2 \\Delta x\n$$\n这个量预计是近似守恒的。我们计算初始能量 $\\mathcal{W}^0$ 和在整个模拟过程中的最大偏差 $|\\mathcal{W}^n - \\mathcal{W}^0|$。问题指定横截面积为 $A=1 \\, \\mathrm{m}^2$，这使得计算出的量（量纲上是能量每单位面积，$J/m^2$）可以在数值上解释为总能量（单位焦耳）。分析的先验界取为 $2 \\mathcal{W}^0$。\n\n**3. 本征正交分解 (POD)**\n\nPOD 是一种为给定数据集（快照）寻找最优低秩基的技术。“最优”在这里意味着在选定的范数下最小化平均投影误差。问题指定了能量范数，由内积 $\\langle u, v \\rangle_{W_E} = u^\\top W_E v$ 定义，其中权重矩阵为 $W_E = \\varepsilon_0 \\Delta x I_N$。\n\nPOD 基是通过对一个特殊缩放的快照矩阵进行奇异值分解 (SVD) 来构建的。步骤如下：\n- 构建缩放后的快照矩阵 $Y = W_E^{1/2} X / \\sqrt{m}$。\n- 计算其 SVD：$Y = U \\Sigma V^\\top$。$U$ 的列是左奇异向量，$\\Sigma$ 的对角线元素是奇异值 $\\sigma_i$。\n- 秩为 $r$ 的 $W_E$-正交归一 POD 基由 $\\Phi_r = W_E^{-1/2} U_r$ 给出，其中 $U_r$ 包含 $U$ 的前 $r$ 列。\n\n**4. 所需量的计算**\n\n利用 SVD 结果，我们计算所需的量：\n- **POD 尾部和**：这是被忽略的奇异值平方和，$\\sum_{i=r+1}^{p} \\sigma_i^2$，其中 $p$ 是 $Y$ 的秩。在我们从0开始索引的数值实现中，这对应于 `sum(s[r:]**2)`。\n- **均方投影误差 ($J_r$)**：这定义为 $J_r = \\frac{1}{m} \\sum_{k=0}^{m-1} \\| x_k - P_r x_k \\|_{W_E}^2$，其中 $P_r x_k = \\Phi_r \\Phi_r^\\top W_E x_k$ 是快照 $x_k$ 在 POD 基上的投影。POD 的一个关键定理指出，$J_r$ 精确等于 POD 尾部和。我们通过对每个快照显式执行投影并求和误差来计算 $J_r$，以验证我们的实现。投影公式简化为 $P_r x_k = W_E^{-1/2} U_r U_r^\\top W_E^{1/2} x_k$。\n- **先验界**：这由 $2 \\mathcal{W}^0$ 给出。\n- **能量偏差**：这是 $\\max_n |\\mathcal{W}^n - \\mathcal{W}^0|$。\n\n整个过程被封装在一个函数中，该函数接收给定测试用例的参数并返回四个所需的数值。主脚本遍历测试套件并按规定格式化输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define physical constants\n    EPSILON_0 = 8.854187817e-12\n    MU_0 = 4 * np.pi * 1e-7\n    C_0 = 1 / np.sqrt(EPSILON_0 * MU_0)\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # (L, N, m, r, dt_factor)\n        (1.0, 128, 120, 10, 0.99), # Case A\n        (1.0, 80, 60, 60, 0.99),   # Case B\n        (1.0, 100, 50, 0, 0.99),    # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, m, r, dt_factor = case\n        result = _solve_case(L, N, m, r, dt_factor, EPSILON_0, MU_0, C_0)\n        results.append(result)\n\n    # Final print statement in the exact required format\n    # The format [...,[...],...] is achieved by creating strings for sub-lists\n    # and joining them.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _solve_case(L, N, m, r, dt_factor, epsilon0, mu0, c0):\n    \"\"\"\n    Solves a single test case of the FDTD-POD problem.\n    \"\"\"\n    # 1. Grid and Simulation Parameters\n    dx = L / N\n    dt = dt_factor * dx / c0\n    x_grid = np.linspace(0, L, N, endpoint=False)\n\n    # 2. Initial Conditions\n    e_field_amp = 1.0\n    w = 0.05 * L\n    # E-field at time n=0\n    E = e_field_amp * (np.exp(-((x_grid - 0.25 * L) ** 2) / w**2) -\n                     np.exp(-((x_grid - 0.75 * L) ** 2) / w**2))\n    # H-field at time n=-1/2 is initialized to zero\n    H = np.zeros(N)\n\n    # Snapshot matrix and FDTD update coefficients\n    X = np.zeros((N, m))\n    ch = dt / (mu0 * dx)\n    ce = dt / (epsilon0 * dx)\n    \n    # Energy history\n    energy_history = np.zeros(m)\n    W0 = 0.0\n\n    # 3. FDTD Simulation\n    for n in range(m):\n        # Store snapshot E^n\n        X[:, n] = E\n        \n        # Update H to H^{n+1/2} from H^{n-1/2} and E^n\n        H = H + ch * (np.roll(E, -1) - E)\n        \n        # Calculate discrete energy W^n using E^n and H^{n+1/2}\n        electric_energy = 0.5 * epsilon0 * dx * np.sum(E**2)\n        magnetic_energy = 0.5 * mu0 * dx * np.sum(H**2)\n        current_energy = electric_energy + magnetic_energy\n        energy_history[n] = current_energy\n        \n        if n == 0:\n            W0 = current_energy\n            \n        # Update E to E^{n+1} from E^n and H^{n+1/2}\n        E = E + ce * (H - np.roll(H, 1))\n\n    # 4. Post-processing and POD Analysis\n    \n    # Maximum energy deviation and Poynting-based bound\n    max_energy_deviation = np.max(np.abs(energy_history - W0))\n    poynting_bound = 2.0 * W0\n    \n    # Perform POD\n    # The weight matrix is W_E = epsilon0 * dx * I_N\n    # Its square root is W_E^{1/2} = sqrt(epsilon0 * dx) * I_N\n    gamma = np.sqrt(epsilon0 * dx)\n    \n    # Scale snapshot matrix: Y = W_E^{1/2} * X / sqrt(m)\n    Y = (gamma / np.sqrt(m)) * X\n    \n    # SVD of Y: Y = U * Sigma * V^T\n    U, s, _ = np.linalg.svd(Y, full_matrices=False)\n    \n    # POD tail sum: sum_{i=r+1 to p} sigma_i^2\n    # This corresponds to sum(s[r:]**2) in 0-based numpy indexing\n    pod_tail_sum = np.sum(s[r:]**2)\n    \n    # Mean squared energy-norm projection error J_r\n    # This is calculated explicitly by projecting each snapshot.\n    # By POD theory, J_r should equal pod_tail_sum.\n    Jr = 0.0\n    if r >= min(N, m):\n        # If r is >= rank, projection is perfect, error is 0\n        Jr = 0.0\n    elif r == 0:\n        # Projection is onto zero space, error is the norm of the vector\n        # J_0 = (1/m) * sum ||x_k||^2_WE = sum(s**2)\n        Jr = np.sum(s**2)\n    else:\n        projection_errors_sq_sum = 0.0\n        U_r = U[:, :r]\n        for k in range(m):\n            x_k = X[:, k]\n            \n            # Project x_k onto the POD basis: P_r(x_k) = W_E^{-1/2} U_r U_r^T W_E^{1/2} x_k\n            y_k = gamma * x_k # y_k = W_E^{1/2} x_k\n            y_k_proj = U_r @ (U_r.T @ y_k) # Projection in the weighted space\n            P_r_x_k = (1.0 / gamma) * y_k_proj # Transform back to original space\n            \n            error_vec = x_k - P_r_x_k\n            # Squared energy norm of the error: ||error_vec||^2_WE = gamma^2 * sum(error_vec**2)\n            projection_errors_sq_sum += (gamma**2) * np.sum(error_vec**2)\n        \n        Jr = projection_errors_sq_sum / m\n\n    return [Jr, pod_tail_sum, poynting_bound, max_energy_deviation]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "尽管全局基功能强大，但对于具有时变特性的瞬态现象可能效率不高，本练习将探讨一种更先进的策略：时间局部化基。通过为不同的时间窗口构建独立的 POD 基，我们可以为动态特性随时间演变的系统创建更紧凑的表示。这个练习  将教您如何实现时间窗格化方案，并分析基的时间跨度与其所需复杂度（即阶数）之间的权衡关系，这在降阶模型的实际应用中至关重要。",
            "id": "3345245",
            "problem": "考虑一个长度为 $L$ 的一维、无损、均匀介电线段，其被离散化为 $N$ 个均匀空间节点，间距为 $dx = L/(N-1)$。令 $\\mathbf{E}(t) \\in \\mathbb{R}^{N}$ 表示在时间 $t$ 的空间离散化电场，单位为伏特/米。瞬时电场能量密度为 $u_{E}(x,t) = \\frac{\\varepsilon}{2}\\lVert \\mathbf{E}(x,t)\\rVert^{2}$，其中 $\\varepsilon$ 是介质的介电常数。在离散空间设置中，时间 $t$ 的电场的 $L^{2}$ 范数平方定义为\n$$\n\\lVert \\mathbf{E}(t) \\rVert_{L^{2}}^{2} \\approx \\sum_{i=1}^{N} \\mathbf{E}_{i}(t)^{2}\\,dx,\n$$\n这与总储存电能成正比，比例常数为 $\\varepsilon/2$。\n\n一个合成的瞬态数据集由两个移动高斯脉冲的叠加来指定，以表示空间离散化下的 $\\mathbf{E}(x,t)$：\n$$\n\\mathbf{E}_{i}(t) = \\sum_{m=1}^{2} A_{m}\\,\\exp\\!\\left(-\\frac{\\left(x_{i} - \\left(x_{m0} + v_{m}(t - t_{m0})\\right)\\right)^{2}}{2\\sigma_{x,m}^{2}}\\right)\\,\\exp\\!\\left(-\\frac{(t - t_{m0})^{2}}{2\\sigma_{t,m}^{2}}\\right),\n$$\n对于 $i=1,\\dots,N$，其中 $x_{i}$ 是空间节点位置，$A_{m}$ 是振幅（单位：伏特/米），$x_{m0}$ 是初始空间中心（单位：米），$v_{m}$ 是速度（单位：米/秒），$t_{m0}$ 是中心时间（单位：秒），$\\sigma_{x,m}$ 和 $\\sigma_{t,m}$ 分别是空间和时间标准差（单位：米和秒）。\n\n数值网格和参数如下：\n- $L = 1\\,\\text{m}$，$N = 64$，$[0,L]$ 上的均匀节点，以及 $dx = L/(N-1)$。\n- 总模拟时间 $T = 0.02\\,\\text{s}$，均匀时间步长 $dt = 1\\times 10^{-4}\\,\\text{s}$，以及时间点 $t_{n} = n\\,dt$，其中 $n=0,1,\\dots,\\lfloor T/dt \\rfloor$。\n- 脉冲参数：\n  - 脉冲 $m=1$：$A_{1} = 1.0\\,\\text{V/m}$，$x_{10} = 0.30\\,\\text{m}$，$v_{1} = 0.10\\,\\text{m/s}$，$t_{10} = 0.006\\,\\text{s}$，$\\sigma_{x,1} = 0.08\\,\\text{m}$，$\\sigma_{t,1} = 0.002\\,\\text{s}$。\n  - 脉冲 $m=2$：$A_{2} = 0.60\\,\\text{V/m}$，$x_{20} = 0.70\\,\\text{m}$，$v_{2} = -0.15\\,\\text{m/s}$，$t_{20} = 0.012\\,\\text{s}$，$\\sigma_{x,2} = 0.12\\,\\text{m}$，$\\sigma_{t,2} = 0.003\\,\\text{s}$。\n\n定义一个时间局部化的加窗方案，窗长为 $\\Delta t_{w}$，重叠分数为 $\\alpha \\in [0,1)$，其中连续窗口的起始时间相隔 $\\Delta t_{w}(1-\\alpha)$ 秒。对于每个窗口 $w$，收集时间索引位于该窗口内的 $\\mathbf{E}(t)$ 快照，形成一个加权快照矩阵\n$$\nX_{w} = \\left[ \\sqrt{dx}\\,\\mathbf{E}(t_{n_{1}}), \\sqrt{dx}\\,\\mathbf{E}(t_{n_{2}}), \\dots, \\sqrt{dx}\\,\\mathbf{E}(t_{n_{M_{w}}}) \\right] \\in \\mathbb{R}^{N \\times M_{w}},\n$$\n该矩阵通过均匀求积诱导了空间 $L^{2}$ 内积。对于每个 $X_{w}$，考虑在最小化投影残差平方和意义下的快照列的最佳秩-$r$ 线性子空间近似。令 $\\tau \\in (0,1)$ 为所需捕获能量的分数。窗口 $w$ 的最小维度 $r_{w}$ 定义为：所选降维基能捕获该窗口内至少分数 $\\tau$ 的总快照能量的最小整数 $r$。对于由 $\\Delta t_{w}$ 和 $\\alpha$ 诱导的所有窗口集合，将案例结果定义为\n$$\nr_{\\max} = \\max_{w} r_{w},\n$$\n即在所有窗口中保证至少捕获分数 $\\tau$ 能量所需的最坏情况最小维度。\n\n您的任务是实现一个完整的程序来：\n1. 根据上述规范生成 $\\mathbf{E}_{i}(t)$，单位为伏特/米，时间单位为秒。\n2. 对于给定的 $\\Delta t_{w}$ 和 $\\alpha$，将时间区间划分为窗口。如有必要，通过调整最后的起始索引来确保最后一个窗口包含最终时间点。每个窗口使用整数个样本，通过将 $\\Delta t_{w}/dt$ 四舍五入到最近的整数计算得出，并强制至少有一个样本。\n3. 对于每个窗口 $w$，构建 $X_{w}$，使用最优秩-$r$ 子空间计算捕获该窗口内至少分数 $\\tau$ 的总快照能量所需的最小整数 $r_{w}$，然后计算该案例的 $r_{\\max}$。\n\n设计您的实现以产生以下测试套件结果，每个案例一个：\n- 案例 A：$\\Delta t_{w} = 0.004\\,\\text{s}$，$\\alpha = 0.5$（小数），$\\tau = 0.99$（小数）。\n- 案例 B：$\\Delta t_{w} = 0.012\\,\\text{s}$，$\\alpha = 0.5$（小数），$\\tau = 0.99$（小数）。\n- 案例 C：$\\Delta t_{w} = 0.004\\,\\text{s}$，$\\alpha = 0.0$（小数），$\\tau = 0.95$（小数）。\n- 案例 D：$\\Delta t_{w} = 0.008\\,\\text{s}$，$\\alpha = 0.75$（小数），$\\tau = 0.999$（小数）。\n- 案例 E：$\\Delta t_{w} = 0.020\\,\\text{s}$，$\\alpha = 0.5$（小数），$\\tau = 0.90$（小数）。\n\n每个案例的答案必须是单个整数 $r_{\\max}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_{A},r_{B},r_{C},r_{D},r_{E}]$）。所有时间必须以秒为单位处理，所有电场值必须以伏特/米为单位。不涉及角度。像 $\\alpha$ 和 $\\tau$ 这样的分数必须作为小数提供和处理，而不是百分比。",
            "solution": "该问题要求计算一个瞬态电场在时间局部化窗口集上的降阶模型的最大所需秩 $r_{\\max}$。该过程涉及生成一个合成数据集，对其进行分区，并对每个数据段应用奇异值分解 (SVD)，以确定在给定能量捕获标准下的必要模型复杂度。\n\n首先，我们建立离散域。空间域是长度为 $L=1\\,\\text{m}$ 的线段，离散为 $N=64$ 个节点，因此空间坐标为 $x_i$，其中 $i=0, \\dots, N-1$，空间步长为 $dx=L/(N-1)$。时间域从 $t=0$ 到 $T=0.02\\,\\text{s}$，时间步长为 $dt=1\\times 10^{-4}\\,\\text{s}$，产生 $N_t = \\lfloor T/dt \\rfloor + 1 = 201$ 个时间点 $t_n=n \\cdot dt$。\n\n在空间节点 $x_i$ 和时间 $t$ 的电场 $\\mathbf{E}_{i}(t)$ 由两个移动高斯脉冲的叠加给出：\n$$\n\\mathbf{E}_{i}(t) = \\sum_{m=1}^{2} A_{m}\\,\\exp\\!\\left(-\\frac{\\left(x_{i} - c_m(t)\\right)^{2}}{2\\sigma_{x,m}^{2}}\\right)\\,\\exp\\!\\left(-\\frac{(t - t_{m0})^{2}}{2\\sigma_{t,m}^{2}}\\right)\n$$\n其中 $c_m(t) = x_{m0} + v_{m}(t - t_{m0})$ 是第 $m$ 个脉冲随时间变化的中心。使用为两个脉冲提供的参数，我们生成一个完整的数据矩阵 $\\mathbf{E} \\in \\mathbb{R}^{N \\times N_t}$，其中每一列都是在特定时间 $t_n$ 的整个空间场 $\\mathbf{E}(t_n)$ 的一个“快照”。\n\n接下来，我们根据每个案例的参数 $\\Delta t_w$ 和 $\\alpha$，将 $N_t$ 个快照序列划分为窗口。以时间样本数表示的窗长为 $N_w = \\text{max}(1, \\text{round}(\\Delta t_w/dt))$。连续窗口起始点之间的步长为 $N_{\\text{step}} = \\text{max}(1, \\text{round}(N_w(1-\\alpha)))$。我们生成一系列完整长度的窗口。为确保索引为 $N_t-1$ 的最终时间样本被包括在内，我们如下定义窗口起始索引：我们为所有能容纳在 $N_t$ 样本内的完整长度窗口生成一个初始的起始索引列表。如果这些窗口中的最后一个不覆盖最终样本，我们将追加一个新的窗口起始索引 $N_t - N_w$，以保证覆盖。这确保所有窗口都有固定的 $N_w$ 个样本长度。\n\n对于每个窗口 $w$，我们构建一个快照矩阵 $\\mathbf{X}_w \\in \\mathbb{R}^{N \\times N_w}$。$\\mathbf{X}_w$ 的列是该窗口内的电场快照，并按 $\\sqrt{dx}$ 进行缩放：\n$$\n\\mathbf{X}_w = \\left[ \\sqrt{dx}\\,\\mathbf{E}(t_{n_{1}}), \\sqrt{dx}\\,\\mathbf{E}(t_{n_{2}}), \\dots, \\sqrt{dx}\\,\\mathbf{E}(t_{n_{N_w}}) \\right]\n$$\n这种缩放确保了列的平方范数对应于该时刻电场能量的离散 $L^2$ 范数近似（相差一个常数 $\\varepsilon/2$）。\n\n每个窗口分析的核心是找到最佳秩-$r$ 近似。这是通过奇异值分解 (SVD) 实现的，它是本征正交分解 (POD) 的数学基础。我们计算快照矩阵的 SVD：$\\mathbf{X}_w = \\mathbf{U}_w \\mathbf{\\Sigma}_w \\mathbf{V}_w^T$。奇异值 $\\sigma_{w,j}$（$\\mathbf{\\Sigma}_w$ 的对角线元素）至关重要。窗口中快照的总“能量”由 $\\mathbf{X}_w$ 的弗罗贝尼乌斯范数的平方给出，即所有奇异值的平方和：\n$$\nE_{\\text{total}, w} = \\lVert \\mathbf{X}_w \\rVert_F^2 = \\sum_{j=1}^{\\min(N, N_w)} \\sigma_{w,j}^2\n$$\n使用 $\\mathbf{U}_w$ 的前 $r$ 个左奇异向量作为基的最优秩-$r$ 近似所捕获的能量是前 $r$ 个奇异值的平方和：\n$$\nE_r = \\sum_{j=1}^{r} \\sigma_{w,j}^2\n$$\n对于每个窗口 $w$，我们必须找到能捕获至少分数 $\\tau$ 总能量的最小整数秩 $r_w$。这是满足以下条件的最小整数 $r$：\n$$\n\\frac{\\sum_{j=1}^{r} \\sigma_{w,j}^2}{\\sum_{j=1}^{\\min(N, N_w)} \\sigma_{w,j}^2} \\ge \\tau\n$$\n我们通过计算平方奇异值的累积和，并找到累积能量分数达到或超过 $\\tau$ 的第一个索引 $r$ 来计算这个值。如果窗口中的总能量实际上为零，我们定义 $r_w=0$。\n\n最后，对于每个测试案例（A-E），我们找出其所有窗口中的最大所需秩，$r_{\\max} = \\max_w r_w$。这个值代表了在给定的加窗方案下，满足整个时间演化过程中的能量捕获标准 $\\tau$ 所需的最坏情况维度。程序为五个案例中的每一个计算这个 $r_{\\max}$，并以列表形式输出结果。",
            "answer": "```python\nimport numpy as np\n\n# Define global constants based on the problem statement\nL = 1.0\nN = 64\nT = 0.02\nDT = 1e-4\n\nPULSE1_PARAMS = {\n    'A': 1.0, 'x0': 0.30, 'v': 0.10, 't0': 0.006,\n    'sigma_x': 0.08, 'sigma_t': 0.002\n}\nPULSE2_PARAMS = {\n    'A': 0.60, 'x0': 0.70, 'v': -0.15, 't0': 0.012,\n    'sigma_x': 0.12, 'sigma_t': 0.003\n}\n\ndef generate_e_field():\n    \"\"\"\n    Generates the full spatio-temporal electric field data matrix E.\n\n    Returns:\n        tuple: A tuple containing:\n            - E (np.ndarray): The (N, num_t) field data matrix.\n            - dx (float): The spatial step size.\n            - num_t (int): The total number of time points.\n    \"\"\"\n    dx = L / (N - 1)\n    x_nodes = np.linspace(0, L, N).reshape(-1, 1)\n    \n    num_t = int(T / DT) + 1\n    t_points = np.arange(num_t) * DT\n\n    # Generate field from pulse 1\n    p1 = PULSE1_PARAMS\n    center_x1 = p1['x0'] + p1['v'] * (t_points - p1['t0'])\n    spatial_term1 = np.exp(-((x_nodes - center_x1)**2) / (2 * p1['sigma_x']**2))\n    temporal_term1 = np.exp(-((t_points - p1['t0'])**2) / (2 * p1['sigma_t']**2))\n    E1 = p1['A'] * spatial_term1 * temporal_term1\n\n    # Generate field from pulse 2\n    p2 = PULSE2_PARAMS\n    center_x2 = p2['x0'] + p2['v'] * (t_points - p2['t0'])\n    spatial_term2 = np.exp(-((x_nodes - center_x2)**2) / (2 * p2['sigma_x']**2))\n    temporal_term2 = np.exp(-((t_points - p2['t0'])**2) / (2 * p2['sigma_t']**2))\n    E2 = p2['A'] * spatial_term2 * temporal_term2\n    \n    # Superposition of the two pulses\n    E = E1 + E2\n    return E, dx, num_t\n\ndef calculate_rmax(E_field, dx, num_t, delta_t_w, alpha, tau):\n    \"\"\"\n    Calculates r_max for a given set of windowing and energy capture parameters.\n\n    Args:\n        E_field (np.ndarray): The full (N, num_t) field data matrix.\n        dx (float): The spatial step size.\n        num_t (int): The total number of time points.\n        delta_t_w (float): The window length in seconds.\n        alpha (float): The overlap fraction.\n        tau (float): The energy capture threshold.\n\n    Returns:\n        int: The calculated r_max value for the case.\n    \"\"\"\n    win_len = max(1, int(round(delta_t_w / DT)))\n    step = max(1, int(round(win_len * (1 - alpha))))\n    \n    if win_len == 0:\n        return 0\n\n    # Generate start indices for all full-length windows that fit in the data\n    stop_idx = num_t - win_len + 1\n    if stop_idx = 0:\n        start_indices = [0]\n    else:\n        start_indices = list(range(0, stop_idx, step))\n    \n    # Ensure the last window includes the final time sample by adding a\n    # final window if necessary.\n    if start_indices:\n        last_reg_window_end = start_indices[-1] + win_len\n        if last_reg_window_end  num_t:\n            final_start_idx = num_t - win_len\n            # Append only if it's a new, later-starting window\n            if final_start_idx > start_indices[-1]:\n                 start_indices.append(final_start_idx)\n    elif num_t > 0:\n         start_indices = [0]\n\n    r_max = 0\n    for start_idx in start_indices:\n        end_idx = start_idx + win_len\n        \n        E_window = E_field[:, start_idx:end_idx]\n        \n        if E_window.shape[1] == 0:\n            continue\n            \n        X_w = np.sqrt(dx) * E_window\n        \n        s = np.linalg.svd(X_w, compute_uv=False)\n        \n        s_squared = s**2\n        total_energy = np.sum(s_squared)\n        \n        if total_energy  1e-20:\n            r_w = 0\n        else:\n            cumulative_energy_fraction = np.cumsum(s_squared) / total_energy\n            # Find the smallest rank r that captures at least fraction tau\n            r_w = np.searchsorted(cumulative_energy_fraction, tau, side='left') + 1\n\n        r_max = max(r_max, r_w)\n        \n    return r_max\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution process for all test cases.\n    \"\"\"\n    test_cases = [\n        {'delta_t_w': 0.004, 'alpha': 0.5, 'tau': 0.99},   # Case A\n        {'delta_t_w': 0.012, 'alpha': 0.5, 'tau': 0.99},   # Case B\n        {'delta_t_w': 0.004, 'alpha': 0.0, 'tau': 0.95},   # Case C\n        {'delta_t_w': 0.008, 'alpha': 0.75, 'tau': 0.999}, # Case D\n        {'delta_t_w': 0.020, 'alpha': 0.5, 'tau': 0.90},   # Case E\n    ]\n\n    E_field, dx, num_t = generate_e_field()\n    \n    results = []\n    for case in test_cases:\n        r_max = calculate_rmax(E_field, dx, num_t, **case)\n        results.append(r_max)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "降阶模型不仅可用于数据压缩和仿真，更是加速工程设计的强大工具。最后的这个练习将降阶模型应用于一个真实的拓扑优化问题。本练习使用克雷洛夫子空间（Krylov subspace）方法构建基，并通过伽辽金投影（Galerkin projection）同时处理状态方程和伴随方程，从而实现设计梯度的快速计算。通过完成这个练习 ，您将理解如何将降阶模型集成到基于梯度的优化循环中，并学会量化一个关键指标：降阶梯度相对于全阶模型的准确性。",
            "id": "3345202",
            "problem": "考虑一个由源驱动的、非磁性的二维域中的时谐电磁场，该场由麦克斯韦方程组和狄利克雷边界条件所约束。在横电（TE）假设和标准的频域有限差分（FDFD）离散化下，内部网格节点上的标量电场振幅 $E$ 满足一个线性系统\n$$\nA(\\boldsymbol{\\rho})\\,\\mathbf{E} = \\mathbf{b},\n$$\n其中 $\\mathbf{E} \\in \\mathbb{R}^N$ 是 $N$ 个内部节点上的场向量，$\\mathbf{b} \\in \\mathbb{R}^N$ 是一个固定的源向量，表示一个局部化的外加电流密度，而 $A(\\boldsymbol{\\rho}) \\in \\mathbb{R}^{N \\times N}$ 是对称正定系统矩阵，定义为\n$$\nA(\\boldsymbol{\\rho}) = K + k_0^2 \\,\\mathrm{diag}\\!\\left(\\boldsymbol{\\varepsilon}(\\boldsymbol{\\rho})\\right),\n$$\n其中 $K$ 是狄利克雷边界条件下的离散负拉普拉斯算子（按网格间距缩放），$k_0$ 是自由空间波数，$\\boldsymbol{\\varepsilon}(\\boldsymbol{\\rho})$ 是相对介电常数分布，通过一个设计向量 $\\boldsymbol{\\rho} \\in [0,1]^N$ 参数化，具体为\n$$\n\\varepsilon_i(\\rho_i) = \\varepsilon_{\\min} + (\\varepsilon_{\\max} - \\varepsilon_{\\min})\\,\\rho_i, \\quad i = 1,\\dots,N.\n$$\n定义目标泛函\n$$\nJ(\\mathbf{E}) = \\tfrac{1}{2}\\,\\mathbf{E}^\\top W\\,\\mathbf{E},\n$$\n其中 $W \\in \\mathbb{R}^{N \\times N}$ 是一个对角权重矩阵，用于选择网格的一个目标“探测器”子区域（目标节点上的条目为1，其他为0）。通过伴随法可以推导出 $J$ 关于设计向量 $\\boldsymbol{\\rho}$ 的梯度，从拉格朗日量开始\n$$\n\\mathcal{L}(\\mathbf{E},\\boldsymbol{\\lambda},\\boldsymbol{\\rho}) = J(\\mathbf{E}) + \\boldsymbol{\\lambda}^\\top\\left(A(\\boldsymbol{\\rho})\\,\\mathbf{E} - \\mathbf{b}\\right),\n$$\n其中 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^N$ 是伴随变量。全阶模型（FOM）的伴随条件是\n$$\nA(\\boldsymbol{\\rho})\\,\\boldsymbol{\\lambda} = \\frac{\\partial J}{\\partial \\mathbf{E}} = W\\,\\mathbf{E},\n$$\n而关于 $\\rho_i$ 的FOM梯度分量是\n$$\n\\frac{\\partial J}{\\partial \\rho_i} = -\\boldsymbol{\\lambda}^\\top \\frac{\\partial A(\\boldsymbol{\\rho})}{\\partial \\rho_i} \\mathbf{E} = -k_0^2\\,(\\varepsilon_{\\max}-\\varepsilon_{\\min})\\,\\lambda_i\\,E_i.\n$$\n为了在拓扑优化过程中加速重复求解，考虑一个通过伽辽金投影构建的降阶模型（ROM），该投影是投射到由 $V \\in \\mathbb{R}^{N \\times r}$（其中 $r \\ll N$）的列向量所张成的子空间上。给定一个选定的基 $V$，通过求解以下方程获得ROM的状态和伴随\n$$\nA_r\\,\\mathbf{E}_r = \\mathbf{b}_r, \\quad \\text{和} \\quad A_r\\,\\boldsymbol{\\lambda}_r = \\frac{\\partial J}{\\partial \\mathbf{E}}\\bigg|_{\\mathbf{E} = V\\mathbf{E}_r}^{\\!\\!\\!\\!\\!\\!\\!\\!\\!\\text{projected}} = V^\\top W\\,V\\,\\mathbf{E}_r,\n$$\n其中 $A_r = V^\\top A(\\boldsymbol{\\rho}) V$ 且 $\\mathbf{b}_r = V^\\top \\mathbf{b}$，然后提升得到 $\\mathbf{E}_{\\mathrm{ROM}} = V\\,\\mathbf{E}_r$ 和 $\\boldsymbol{\\lambda}_{\\mathrm{ROM}} = V\\,\\boldsymbol{\\lambda}_r$。ROM梯度分量的计算方式与此类似\n$$\n\\left(\\frac{\\partial J}{\\partial \\rho_i}\\right)_{\\mathrm{ROM}} = -k_0^2\\,(\\varepsilon_{\\max}-\\varepsilon_{\\min})\\,\\lambda_{\\mathrm{ROM},i}\\,E_{\\mathrm{ROM},i}.\n$$\n通过相对误差度量来量化由ROM引起的梯度失配\n$$\n\\eta = \\frac{\\left\\| \\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{ROM}} - \\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{FOM}} \\right\\|_2}{\\left\\| \\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{FOM}} \\right\\|_2}.\n$$\n您的任务是实现一个完整的程序，该程序能够：\n- 在尺寸为 $N_x \\times N_y$ 的矩形内部网格上，使用标准的五点差分格式构建 $K$，其中狄利克雷边界条件和网格间距在 $x$ 和 $y$ 方向均为 $h = 1/(N_x+1)$（为简单起见，假设为单位正方形域；两个方向使用相同的间距）。\n- 根据一个在内部节点上由 $ \\rho(x,y) = \\left[0.5 + 0.5 \\sin(2\\pi x)\\cos(2\\pi y)\\right] $（裁剪到 $[0,1]$ 范围）定义的确定性的、非均匀的设计场构建 $\\boldsymbol{\\varepsilon}(\\boldsymbol{\\rho})$，其中 $x$ 和 $y$ 是内部网格上的节点坐标。\n- 选择 $\\varepsilon_{\\min} = 1.0$ 和 $\\varepsilon_{\\max} = 12.0$。\n- 将 $\\mathbf{b}$ 设置为最接近 $(x,y) = (0.25, 0.5)$ 的内部节点处的单位点源。\n- 将 $W$ 定义为一个对角选择器，选择 $x \\ge 0.8$ 的节点。\n- 通过以指定的基矩阵 $A_{\\text{basis}}$ 为中心的逆克雷洛夫过程构建一个降阶模型基 $V$：\n  1. 从 $\\mathbf{v}_0 = \\mathbf{b} / \\|\\mathbf{b}\\|_2$ 开始。\n  2. 对于 $j = 1, \\dots, r-1$，计算 $\\mathbf{w} = A_{\\text{basis}}^{-1}\\,\\mathbf{v}_{j-1}$，使用格拉姆-施密特法将 $\\mathbf{w}$ 与之前的 $\\{\\mathbf{v}_i\\}_{i=0}^{j-1}$ 进行正交化，然后归一化得到 $\\mathbf{v}_j$。\n  3. 构成 $V = [\\mathbf{v}_0, \\dots, \\mathbf{v}_{r-1}]$。如果 $r \\ge N$，则设置 $V = I_N$ 来表示全阶子空间。\n- 为每个测试用例计算FOM和ROM梯度以及相对失配 $\\eta$。\n\n使用以下测试套件，它改变了降阶基的大小以及 $A_{\\text{basis}}$ 和评估矩阵 $A(\\boldsymbol{\\rho})$ 之间的一致性：\n1. $(N_x,N_y,k_0,r,\\text{basis }k_0) = (12,12,8.0,10,8.0)$：一个具有相当丰富的基的典型案例。\n2. $(N_x,N_y,k_0,r,\\text{basis }k_0) = (12,12,8.0,N,8.0)$ 其中 $N = N_x N_y$：一个ROM等于FOM的边界案例。\n3. $(N_x,N_y,k_0,r,\\text{basis }k_0) = (12,12,8.0,3,8.0)$：一个基非常小的边缘案例。\n4. $(N_x,N_y,k_0,r,\\text{basis }k_0) = (12,12,5.0,10,8.0)$：一个在与评估时不同的波数下构建ROM基的案例，用于探究参数不一致性。\n\n您的程序应生成单行输出，其中包含四个测试用例的相对失配值 $\\eta$，格式为逗号分隔的列表，并用方括号括起来，每个值四舍五入到六位小数（例如，\"[0.012345,0.000001,0.123456,0.056789]\"）。不需要物理单位，也不涉及角度。所有计算都是无量纲的。\n\n您的实现必须是一个完整的、可在指定环境中运行的程序，并且不得需要用户输入或外部文件。",
            "solution": "该问题要求在一个电磁拓扑优化框架内，实现并评估一个降阶模型（ROM）的准确性。评估通过比较由高保真全阶模型（FOM）和ROM计算出的设计灵敏度梯度来完成。\n\n解决方案的实现遵循以下计算流程：\n\n1.  **离散化与系统构建**：首先，将单位正方形域离散化为 $N_x \\times N_y$ 的内部网格。使用标准的五点有限差分格式构建稀疏的离散负拉普拉斯算子 $K$。根据给定的空间依赖设计场 $\\boldsymbol{\\rho}$ 和材料参数，构建对角介电常数矩阵。最后，组合这些矩阵，为给定的波数 $k_0$ 构建出完整的系统矩阵 $A(\\boldsymbol{\\rho})$。同时，根据问题描述定义源向量 $\\mathbf{b}$ 和目标权重矩阵 $W$。\n\n2.  **全阶模型（FOM）分析**：通过求解大规模稀疏线性系统 $A(\\boldsymbol{\\rho})\\,\\mathbf{E}_{\\mathrm{FOM}} = \\mathbf{b}$，计算出全阶电场 $\\mathbf{E}_{\\mathrm{FOM}}$。随后，利用此场计算伴随系统的右端项，并求解 $A(\\boldsymbol{\\rho})\\,\\boldsymbol{\\lambda}_{\\mathrm{FOM}} = W\\,\\mathbf{E}_{\\mathrm{FOM}}$ 以获得伴随场 $\\boldsymbol{\\lambda}_{\\mathrm{FOM}}$。最后，利用这两个场，根据提供的公式计算出精确的FOM梯度向量 $\\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{FOM}}$。\n\n3.  **降阶模型（ROM）构建与分析**：\n    *   **基生成**：ROM的核心是降阶基 $V$。该基是通过基于参考矩阵 $A_{\\text{basis}}$ 的逆克雷洛夫子空间方法生成的。从归一化的源向量开始，通过迭代求解线性系统并使用格拉姆-施密特过程进行正交化，来构建一组正交基向量。\n    *   **投影与求解**：使用伽辽金投影，将FOM的系统矩阵和向量投影到由 $V$ 张成的低维子空间上，得到小规模的降阶系统 $(A_r, \\mathbf{b}_r)$。求解这个 $r \\times r$ 的密集线性系统，得到降阶状态 $\\mathbf{E}_r$ 和降阶伴随 $\\boldsymbol{\\lambda}_r$。\n    *   **重构与梯度计算**：将降阶解通过基 $V$ 提升回原始的全阶空间，得到近似场 $\\mathbf{E}_{\\mathrm{ROM}}$ 和 $\\boldsymbol{\\lambda}_{\\mathrm{ROM}}$。使用这些近似场计算ROM梯度向量 $\\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{ROM}}$。\n\n4.  **误差量化**：最后，计算FOM梯度和ROM梯度之间的相对误差 $\\eta$，即两个梯度向量之差的欧几里得范数与FOM梯度范数的比值。此单一标量值量化了ROM在预测设计灵敏度方面的保真度。对测试套件中的每个案例都重复此过程。",
            "answer": "```python\nimport numpy as np\nimport scipy.sparse as sp\nimport scipy.sparse.linalg as spla\n\ndef solve():\n    \"\"\"\n    Solves the reduced-order modeling problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, k0, r, basis_k0)\n        (12, 12, 8.0, 10, 8.0),\n        (12, 12, 8.0, 144, 8.0), # Note: r = N = 12*12 = 144\n        (12, 12, 8.0, 3, 8.0),\n        (12, 12, 5.0, 10, 8.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        Nx, Ny, k0, r, basis_k0 = case\n        N = Nx * Ny\n        h = 1.0 / (Nx + 1)\n        \n        # 1. Grid and Coordinates\n        x_coords = np.linspace(h, 1.0 - h, Nx)\n        y_coords = np.linspace(h, 1.0 - h, Ny)\n        xv, yv = np.meshgrid(x_coords, y_coords, indexing='xy')\n        # Use C-style (row-major) flattening\n        x_flat = xv.flatten()\n        y_flat = yv.flatten()\n        \n        # 2. Construct K matrix (discrete negative Laplacian)\n        # Standard 5-point stencil for -h^2 * nabla^2 results in a matrix with \n        # 2 on the main diagonal and -1 on the two adjacent diagonals for 1D.\n        # We scale the final K matrix by 1/h^2.\n        K1D_x = sp.diags([-1, 2, -1], [-1, 0, 1], shape=(Nx, Nx), format='csc')\n        K1D_y = sp.diags([-1, 2, -1], [-1, 0, 1], shape=(Ny, Ny), format='csc')\n        I_Nx = sp.eye(Nx, format='csc')\n        I_Ny = sp.eye(Ny, format='csc')\n        # Assemble 2D Laplacian using Kronecker products for C-style ordering\n        K = (sp.kron(I_Ny, K1D_x) + sp.kron(K1D_y, I_Nx)) / (h**2)\n        K = K.tocsc()\n        \n        # 3. Construct material and source properties\n        eps_min, eps_max = 1.0, 12.0\n        rho = 0.5 + 0.5 * np.sin(2 * np.pi * x_flat) * np.cos(2 * np.pi * y_flat)\n        rho = np.clip(rho, 0, 1)\n        eps_vec = eps_min + (eps_max - eps_min) * rho\n        eps_diag = sp.diags(eps_vec, format='csc')\n        \n        # Source vector b\n        ix_src = np.argmin(np.abs(x_coords - 0.25))\n        iy_src = np.argmin(np.abs(y_coords - 0.5))\n        src_idx = iy_src * Nx + ix_src # C-style indexing\n        b = np.zeros(N)\n        b[src_idx] = 1.0\n        \n        # Weighting matrix W\n        w_vec = (x_flat >= 0.8).astype(float)\n        W = sp.diags(w_vec, format='csc')\n        \n        # 4. Construct Basis V\n        if r >= N:\n            # Special case: ROM is the FOM, so V is the identity matrix\n            V = np.eye(N)\n        else:\n            # Inverse-Krylov process\n            A_basis = K + basis_k0**2 * eps_diag\n            A_basis = A_basis.tocsc()\n            \n            V_cols = []\n            v0 = b / np.linalg.norm(b)\n            V_cols.append(v0)\n            \n            for j in range(1, r):\n                v_prev = V_cols[-1]\n                w = spla.spsolve(A_basis, v_prev)\n                \n                # Modified Gram-Schmidt orthogonalization\n                for i in range(j):\n                    v_i = V_cols[i]\n                    w = w - (v_i.T @ w) * v_i\n                \n                w_norm = np.linalg.norm(w)\n                if w_norm  1e-12: # Avoid division by zero\n                    break\n                \n                v_next = w / w_norm\n                V_cols.append(v_next)\n                \n            V = np.array(V_cols).T\n\n        # 5. Full-Order Model (FOM) Calculation\n        A = K + k0**2 * eps_diag\n        A_csc = A.tocsc()\n        \n        E_fom = spla.spsolve(A_csc, b)\n        adj_rhs_fom = W @ E_fom\n        lambda_fom = spla.spsolve(A_csc, adj_rhs_fom)\n        grad_fom = -k0**2 * (eps_max - eps_min) * lambda_fom * E_fom\n        \n        # 6. Reduced-Order Model (ROM) Calculation\n        # Project system using the basis V\n        A_r = V.T @ A @ V\n        b_r = V.T @ b\n        \n        E_r = np.linalg.solve(A_r, b_r)\n        \n        # Project objective weighting and compute reduced adjoint\n        W_r = V.T @ W @ V\n        adj_rhs_rom = W_r @ E_r\n        lambda_r = np.linalg.solve(A_r, adj_rhs_rom)\n        \n        # Lift solutions back to full space\n        E_rom = V @ E_r\n        lambda_rom = V @ lambda_r\n        grad_rom = -k0**2 * (eps_max - eps_min) * lambda_rom * E_rom\n        \n        # 7. Compute Relative Error Metric\n        grad_fom_norm = np.linalg.norm(grad_fom)\n        if grad_fom_norm == 0:\n            eta = 0.0 if np.linalg.norm(grad_rom - grad_fom) == 0 else np.inf\n        else:\n            eta = np.linalg.norm(grad_rom - grad_fom) / grad_fom_norm\n            \n        results.append(eta)\n\n    # Print results in the required format\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}