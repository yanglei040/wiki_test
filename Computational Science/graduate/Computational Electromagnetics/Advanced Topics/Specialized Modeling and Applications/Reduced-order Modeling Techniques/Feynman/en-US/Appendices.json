{
    "hands_on_practices": [
        {
            "introduction": "The first step in applying reduced-order modeling is to generate a representative dataset from a full-order simulation and extract its most dominant features. This foundational exercise guides you through simulating wave propagation using the Finite-Difference Time-Domain (FDTD) method, collecting snapshots of the electric field, and then applying Proper Orthogonal Decomposition (POD) to construct an optimal reduced basis. You will gain hands-on experience connecting the mathematical approximation error of POD, quantified by singular values, to an a priori bound derived from the physical principle of energy conservation .",
            "id": "3345280",
            "problem": "Consider a one-dimensional, lossless, homogeneous vacuum domain of length $L$ with periodic boundary conditions. The electromagnetic field is discretized on a uniform Yee grid with $N$ cells and spatial step $\\Delta x = L/N$. Denote by $A=1$ the cross-sectional area in square meters so that the cell volume is $\\Delta V = A \\Delta x = \\Delta x$. Let the electric field component be $E(x,t)$ and the magnetic field component be $H(x,t)$, where the speed of light is $c_0 = 1/\\sqrt{\\mu_0 \\varepsilon_0}$, the vacuum permittivity is $\\varepsilon_0$, and the vacuum permeability is $\\mu_0$. The time step $\\Delta t$ satisfies the Courant stability condition for one-dimensional propagation, namely $c_0 \\Delta t \\le \\Delta x$. The Finite-Difference Time-Domain (FDTD) discretization updates $E$ and $H$ in time using a staggered scheme:\n$$\nH^{n+\\frac{1}{2}}_i = H^{n-\\frac{1}{2}}_i + \\frac{\\Delta t}{\\mu_0 \\Delta x}\\left(E^n_{i+1} - E^n_i\\right),\n$$\n$$\nE^{n+1}_i = E^n_i + \\frac{\\Delta t}{\\varepsilon_0 \\Delta x}\\left(H^{n+\\frac{1}{2}}_i - H^{n+\\frac{1}{2}}_{i-1}\\right),\n$$\nwhere indices are periodic, namely $E^n_{i+N} = E^n_i$ and $H^{n+\\frac{1}{2}}_{i+N} = H^{n+\\frac{1}{2}}_i$. The discrete total electromagnetic energy at time step $n$ is\n$$\n\\mathcal{W}^n = \\frac{1}{2}\\sum_{i=0}^{N-1}\\varepsilon_0 \\left(E^n_i\\right)^2 \\Delta x + \\frac{1}{2}\\sum_{i=0}^{N-1}\\mu_0 \\left(H^{n+\\frac{1}{2}}_i\\right)^2 \\Delta x,\n$$\nexpressed in Joules. The discrete Poynting theorem for this periodic, source-free system implies that $\\mathcal{W}^n$ is constant in $n$.\n\nLet $m$ snapshots of the electric field be collected at discrete times $t_k = k \\Delta t$ for $k \\in \\{0,1,\\ldots,m-1\\}$, forming the snapshot matrix $X \\in \\mathbb{R}^{N \\times m}$ with columns $x_k \\in \\mathbb{R}^N$ where $x_k$ is the vector of $E^k_i$. Define the symmetric positive-definite weight matrix for the energy inner product on electric field vectors by $W_E = \\varepsilon_0 \\Delta x \\, I_N$, where $I_N$ is the identity matrix of size $N$. The Proper Orthogonal Decomposition (POD) basis of rank $r$ is constructed with respect to the $W_E$-inner product by performing the Singular Value Decomposition (SVD) of the scaled snapshot matrix $Y = W_E^{1/2} X / \\sqrt{m}$, where $W_E^{1/2}$ is the symmetric square root of $W_E$. Let $Y = U \\Sigma V^\\top$ be the SVD with singular values $\\sigma_i$ on the diagonal of $\\Sigma$ and left singular vectors in $U$. The $W_E$-orthonormal POD basis is the matrix $\\Phi_r = W_E^{-1/2} U_r$, where $U_r$ contains the first $r$ columns of $U$. The $W_E$-orthogonal projection of a snapshot $x_k$ onto $\\mathrm{span}(\\Phi_r)$ is $P_r x_k = \\Phi_r \\Phi_r^\\top W_E x_k$.\n\nDefine the mean squared energy-norm projection error\n$$\nJ_r = \\frac{1}{m} \\sum_{k=0}^{m-1} \\left\\| x_k - P_r x_k \\right\\|_{W_E}^2,\n$$\nwhere $\\|z\\|_{W_E}^2 = z^\\top W_E z$. Using the discrete Poynting theorem, the electric energy at any time satisfies\n$$\n\\|x_k\\|_{W_E}^2 \\le 2 \\mathcal{W}^0,\n$$\nwhere $\\mathcal{W}^0$ is the initial total electromagnetic energy. This yields an a priori bound\n$$\nJ_r \\le \\sum_{i=r+1}^{p} \\sigma_i^2 \\le \\frac{1}{m}\\sum_{k=0}^{m-1} \\|x_k\\|_{W_E}^2 \\le 2 \\mathcal{W}^0,\n$$\nwhere $p = \\mathrm{rank}(Y)$.\n\nYour tasks are:\n1. Implement the one-dimensional FDTD scheme as described, using the constants $\\varepsilon_0 = 8.854187817 \\times 10^{-12}$ in farads per meter, $\\mu_0 = 4\\pi \\times 10^{-7}$ in henries per meter, and $c_0 = 1/\\sqrt{\\mu_0 \\varepsilon_0}$. Initialize the fields at $t=0$ with $E(x,0)$ given by the superposition of two Gaussian pulses,\n$$\nE(x,0) = E_0 \\left(\\exp\\left(-\\frac{(x - 0.25L)^2}{w^2}\\right) - \\exp\\left(-\\frac{(x - 0.75L)^2}{w^2}\\right)\\right),\n$$\nand $H(x,0) = 0$. Use $E_0 = 1$ in volts per meter and $w = 0.05 L$ in meters. Collect $m$ snapshots $x_k$ from the simulated $E$ field.\n2. Construct the POD basis using the weighted SVD specified above, and compute the mean squared energy-norm projection error $J_r$ over the $m$ snapshots, the POD tail sum $\\sum_{i=r+1}^{p} \\sigma_i^2$, the a priori Poynting-based bound $2 \\mathcal{W}^0$ in Joules, and the maximum absolute deviation of $\\mathcal{W}^n$ from $\\mathcal{W}^0$ over all time steps $n \\in \\{0,\\ldots,m-1\\}$ in Joules.\n3. Express all energy quantities in Joules. Angles are not used. No percentages are involved; all quantities are real numbers.\n\nTest Suite:\n- Case A (general case): $L = 1$ meter, $N = 128$, $m = 120$, $r = 10$, and $\\Delta t = 0.99 \\, \\Delta x / c_0$ in seconds.\n- Case B (boundary case with near-zero projection error): $L = 1$ meter, $N = 80$, $m = 60$, $r = 60$, and $\\Delta t = 0.99 \\, \\Delta x / c_0$ in seconds.\n- Case C (edge case with zero-dimensional reduced space): $L = 1$ meter, $N = 100$, $m = 50$, $r = 0$, and $\\Delta t = 0.99 \\, \\Delta x / c_0$ in seconds.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list in the form $[J_r, \\sum_{i=r+1}^{p} \\sigma_i^2, 2\\mathcal{W}^0, \\max_n |\\mathcal{W}^n - \\mathcal{W}^0|]$. For example, the output must look like\n$$\n[[J_{r,A}, \\mathrm{tail}_A, \\mathrm{bound}_A, \\mathrm{dev}_A],[J_{r,B}, \\mathrm{tail}_B, \\mathrm{bound}_B, \\mathrm{dev}_B],[J_{r,C}, \\mathrm{tail}_C, \\mathrm{bound}_C, \\mathrm{dev}_C]].\n$$\nAll numbers are in Joules and must be printed as raw decimal floats without units.",
            "solution": "The user has provided a problem in computational electromagnetics that requires the implementation of a one-dimensional Finite-Difference Time-Domain (FDTD) simulation, followed by a Proper Orthogonal Decomposition (POD) of the resulting field snapshots. The task is to compute several quantities related to the energy of the system and the error of the POD-based projection.\n\n### Principle-Based Design and Method\n\nThe problem is approached by first implementing the physical simulation, and then performing the mathematical analysis (model reduction).\n\n**1. FDTD Simulation**\n\nThe simulation models the propagation of electromagnetic waves in a one-dimensional, periodic, and lossless vacuum domain. The governing equations are Maxwell's equations, which in one dimension for a transverse electromagnetic (TEM) wave reduce to a coupled system of first-order partial differential equations:\n$$\n\\frac{\\partial H}{\\partial t} = \\pm \\frac{1}{\\mu_0} \\frac{\\partial E}{\\partial x}\n$$\n$$\n\\frac{\\partial E}{\\partial t} = \\pm \\frac{1}{\\varepsilon_0} \\frac{\\partial H}{\\partial x}\n$$\nThe problem provides a specific set of discretized update equations which correspond to a valid, energy-conserving wave propagation system, albeit with an unconventional sign convention (both positive) which can be interpreted as a redefinition of one of the field components. We will implement these equations exactly as stated.\n\nThe FDTD method discretizes space and time. The problem specifies a Yee grid, which is a staggered grid arrangement. The electric field $E$ components are located at integer grid points $i\\Delta x$, while the magnetic field $H$ components are at half-integer points $(i+\\frac{1}{2})\\Delta x$. The time stepping is also staggered (a \"leapfrog\" scheme): $E$ is evaluated at integer time steps $n\\Delta t$ and $H$ at half-integer steps $(n+\\frac{1}{2})\\Delta t$.\n\nThe update equations given are:\n$$\nH^{n+\\frac{1}{2}}_i = H^{n-\\frac{1}{2}}_i + \\frac{\\Delta t}{\\mu_0 \\Delta x}\\left(E^n_{i+1} - E^n_i\\right)\n$$\n$$\nE^{n+1}_i = E^n_i + \\frac{\\Delta t}{\\varepsilon_0 \\Delta x}\\left(H^{n+\\frac{1}{2}}_i - H^{n+\\frac{1}{2}}_{i-1}\\right)\n$$\nThese are implemented using array operations. Periodic boundary conditions are handled using circular shifts (`numpy.roll`). The simulation starts from a given initial electric field $E(x,0)$ and zero initial magnetic field. In a leapfrog scheme, this is interpreted as $H^{-1/2} = 0$. The simulation is run for $m$ time steps, and at each step $k$, the electric field vector $E^k$ is stored as a column in a snapshot matrix $X$.\n\n**2. Energy Calculation**\n\nDuring the simulation, the total electromagnetic energy $\\mathcal{W}^n$ is computed at each step $n$. The problem provides the formula for a discrete, staggered energy:\n$$\n\\mathcal{W}^n = \\frac{1}{2}\\sum_{i=0}^{N-1}\\varepsilon_0 \\left(E^n_i\\right)^2 \\Delta x + \\frac{1}{2}\\sum_{i=0}^{N-1}\\mu_0 \\left(H^{n+\\frac{1}{2}}_i\\right)^2 \\Delta x\n$$\nThis quantity is expected to be nearly conserved. We calculate the initial energy $\\mathcal{W}^0$ and the maximum deviation $|\\mathcal{W}^n - \\mathcal{W}^0|$ over the simulation. The problem specifies that the cross-sectional area is $A=1 \\, \\mathrm{m}^2$, which allows the calculated quantity, dimensionally an energy per area ($J/m^2$), to be numerically interpreted as total energy in Joules. The a priori bound for the analysis is taken as $2 \\mathcal{W}^0$.\n\n**3. Proper Orthogonal Decomposition (POD)**\n\nPOD is a technique to find an optimal low-rank basis for a given set of data (the snapshots). \"Optimal\" here means minimizing the average projection error in a chosen norm. The problem specifies the energy norm, defined by the inner product $\\langle u, v \\rangle_{W_E} = u^\\top W_E v$, where the weight matrix is $W_E = \\varepsilon_0 \\Delta x I_N$.\n\nThe POD basis is constructed via the Singular Value Decomposition (SVD) of a specially scaled snapshot matrix. The procedure is as follows:\n- Construct the scaled snapshot matrix $Y = W_E^{1/2} X / \\sqrt{m}$.\n- Compute its SVD: $Y = U \\Sigma V^\\top$. The columns of $U$ are the left singular vectors, and the diagonal entries of $\\Sigma$ are the singular values $\\sigma_i$.\n- The $W_E$-orthonormal POD basis of rank $r$ is given by $\\Phi_r = W_E^{-1/2} U_r$, where $U_r$ contains the first $r$ columns of $U$.\n\n**4. Calculation of Required Quantities**\n\nWith the SVD results, we compute the required quantities:\n- **POD Tail Sum**: This is the sum of the squares of the neglected singular values, $\\sum_{i=r+1}^{p} \\sigma_i^2$, where $p$ is the rank of $Y$. In our 0-indexed numerical implementation, this corresponds to `sum(s[r:]**2)`.\n- **Mean Squared Projection Error ($J_r$)**: This is defined as $J_r = \\frac{1}{m} \\sum_{k=0}^{m-1} \\| x_k - P_r x_k \\|_{W_E}^2$, where $P_r x_k = \\Phi_r \\Phi_r^\\top W_E x_k$ is the projection of a snapshot $x_k$ onto the POD basis. A key theorem of POD states that $J_r$ is exactly equal to the POD tail sum. We compute $J_r$ by explicitly performing the projection for each snapshot and summing the errors to verify our implementation. The projection formula simplifies to $P_r x_k = W_E^{-1/2} U_r U_r^\\top W_E^{1/2} x_k$.\n- **A Priori Bound**: This is given as $2 \\mathcal{W}^0$.\n- **Energy Deviation**: This is $\\max_n |\\mathcal{W}^n - \\mathcal{W}^0|$.\n\nThe entire process is encapsulated in a function that takes the parameters for a given test case and returns the four required numerical values. The main script iterates through the test suite and formats the output as specified.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define physical constants\n    EPSILON_0 = 8.854187817e-12\n    MU_0 = 4 * np.pi * 1e-7\n    C_0 = 1 / np.sqrt(EPSILON_0 * MU_0)\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # (L, N, m, r, dt_factor)\n        (1.0, 128, 120, 10, 0.99), # Case A\n        (1.0, 80, 60, 60, 0.99),   # Case B\n        (1.0, 100, 50, 0, 0.99),    # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, m, r, dt_factor = case\n        result = _solve_case(L, N, m, r, dt_factor, EPSILON_0, MU_0, C_0)\n        results.append(result)\n\n    # Final print statement in the exact required format\n    # The format [...,[...],...] is achieved by creating strings for sub-lists\n    # and joining them.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _solve_case(L, N, m, r, dt_factor, epsilon0, mu0, c0):\n    \"\"\"\n    Solves a single test case of the FDTD-POD problem.\n    \"\"\"\n    # 1. Grid and Simulation Parameters\n    dx = L / N\n    dt = dt_factor * dx / c0\n    x_grid = np.linspace(0, L, N, endpoint=False)\n\n    # 2. Initial Conditions\n    e_field_amp = 1.0\n    w = 0.05 * L\n    # E-field at time n=0\n    E = e_field_amp * (np.exp(-((x_grid - 0.25 * L) ** 2) / w**2) -\n                     np.exp(-((x_grid - 0.75 * L) ** 2) / w**2))\n    # H-field at time n=-1/2 is initialized to zero\n    H = np.zeros(N)\n\n    # Snapshot matrix and FDTD update coefficients\n    X = np.zeros((N, m))\n    ch = dt / (mu0 * dx)\n    ce = dt / (epsilon0 * dx)\n    \n    # Energy history\n    energy_history = np.zeros(m)\n    W0 = 0.0\n\n    # 3. FDTD Simulation\n    for n in range(m):\n        # Store snapshot E^n\n        X[:, n] = E\n        \n        # Update H to H^{n+1/2} from H^{n-1/2} and E^n\n        H = H + ch * (np.roll(E, -1) - E)\n        \n        # Calculate discrete energy W^n using E^n and H^{n+1/2}\n        electric_energy = 0.5 * epsilon0 * dx * np.sum(E**2)\n        magnetic_energy = 0.5 * mu0 * dx * np.sum(H**2)\n        current_energy = electric_energy + magnetic_energy\n        energy_history[n] = current_energy\n        \n        if n == 0:\n            W0 = current_energy\n            \n        # Update E to E^{n+1} from E^n and H^{n+1/2}\n        E = E + ce * (H - np.roll(H, 1))\n\n    # 4. Post-processing and POD Analysis\n    \n    # Maximum energy deviation and Poynting-based bound\n    max_energy_deviation = np.max(np.abs(energy_history - W0))\n    poynting_bound = 2.0 * W0\n    \n    # Perform POD\n    # The weight matrix is W_E = epsilon0 * dx * I_N\n    # Its square root is W_E^{1/2} = sqrt(epsilon0 * dx) * I_N\n    gamma = np.sqrt(epsilon0 * dx)\n    \n    # Scale snapshot matrix: Y = W_E^{1/2} * X / sqrt(m)\n    Y = (gamma / np.sqrt(m)) * X\n    \n    # SVD of Y: Y = U * Sigma * V^T\n    U, s, _ = np.linalg.svd(Y, full_matrices=False)\n    \n    # POD tail sum: sum_{i=r+1 to p} sigma_i^2\n    # This corresponds to sum(s[r:]**2) in 0-based numpy indexing\n    pod_tail_sum = np.sum(s[r:]**2)\n    \n    # Mean squared energy-norm projection error J_r\n    # This is calculated explicitly by projecting each snapshot.\n    # By POD theory, J_r should equal pod_tail_sum.\n    Jr = 0.0\n    if r >= min(N, m):\n        # If r is >= rank, projection is perfect, error is 0\n        Jr = 0.0\n    elif r == 0:\n        # Projection is onto zero space, error is the norm of the vector\n        # J_0 = (1/m) * sum ||x_k||^2_WE = sum(s**2)\n        Jr = np.sum(s**2)\n    else:\n        projection_errors_sq_sum = 0.0\n        U_r = U[:, :r]\n        for k in range(m):\n            x_k = X[:, k]\n            \n            # Project x_k onto the POD basis: P_r(x_k) = W_E^{-1/2} U_r U_r^T W_E^{1/2} x_k\n            y_k = gamma * x_k # y_k = W_E^{1/2} x_k\n            y_k_proj = U_r @ (U_r.T @ y_k) # Projection in the weighted space\n            P_r_x_k = (1.0 / gamma) * y_k_proj # Transform back to original space\n            \n            error_vec = x_k - P_r_x_k\n            # Squared energy norm of the error: ||error_vec||^2_WE = gamma^2 * sum(error_vec**2)\n            projection_errors_sq_sum += (gamma**2) * np.sum(error_vec**2)\n        \n        Jr = projection_errors_sq_sum / m\n\n    return [Jr, pod_tail_sum, poynting_bound, max_energy_deviation]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "While a single global basis is effective for many problems, transient phenomena with distinct events in time often benefit from more adaptive strategies. This practice explores time-localized model reduction, where separate bases are constructed for different time windows to better capture local dynamics . By analyzing a synthetic signal composed of moving pulses, you will investigate the fundamental trade-off between the temporal support of a basis (the window size) and its required dimension to achieve a desired accuracy.",
            "id": "3345245",
            "problem": "Consider a one-dimensional, lossless, homogeneous dielectric line segment of length $L$ discretized into $N$ uniform spatial nodes with spacing $dx = L/(N-1)$. Let $\\mathbf{E}(t) \\in \\mathbb{R}^{N}$ denote the spatially discretized electric field at time $t$, measured in volts per meter. The instantaneous electric-field energy density is $u_{E}(x,t) = \\frac{\\varepsilon}{2}\\lVert \\mathbf{E}(x,t)\\rVert^{2}$, where $\\varepsilon$ is the permittivity of the medium. In the discrete spatial setting, the squared $L^{2}$ norm of the electric field at time $t$ is defined as\n$$\n\\lVert \\mathbf{E}(t) \\rVert_{L^{2}}^{2} \\approx \\sum_{i=1}^{N} \\mathbf{E}_{i}(t)^{2}\\,dx,\n$$\nwhich is proportional to the total stored electric energy up to the constant $\\varepsilon/2$.\n\nA synthetic transient dataset is specified by a superposition of two moving Gaussian pulses to represent $\\mathbf{E}(x,t)$ under spatial discretization:\n$$\n\\mathbf{E}_{i}(t) = \\sum_{m=1}^{2} A_{m}\\,\\exp\\!\\left(-\\frac{\\left(x_{i} - \\left(x_{m0} + v_{m}(t - t_{m0})\\right)\\right)^{2}}{2\\sigma_{x,m}^{2}}\\right)\\,\\exp\\!\\left(-\\frac{(t - t_{m0})^{2}}{2\\sigma_{t,m}^{2}}\\right),\n$$\nfor $i=1,\\dots,N$, where $x_{i}$ are the spatial node positions, $A_{m}$ are amplitudes in volts per meter, $x_{m0}$ are initial spatial centers in meters, $v_{m}$ are velocities in meters per second, $t_{m0}$ are center times in seconds, and $\\sigma_{x,m}$, $\\sigma_{t,m}$ are spatial and temporal standard deviations in meters and seconds, respectively.\n\nThe numerical grid and parameters are:\n- $L = 1\\,\\text{m}$, $N = 64$, uniform nodes on $[0,L]$ and $dx = L/(N-1)$.\n- Total simulation time $T = 0.02\\,\\text{s}$, uniform time step $dt = 1\\times 10^{-4}\\,\\text{s}$, and times $t_{n} = n\\,dt$ for $n=0,1,\\dots,\\lfloor T/dt \\rfloor$.\n- Pulse parameters:\n  - Pulse $m=1$: $A_{1} = 1.0\\,\\text{V/m}$, $x_{10} = 0.30\\,\\text{m}$, $v_{1} = 0.10\\,\\text{m/s}$, $t_{10} = 0.006\\,\\text{s}$, $\\sigma_{x,1} = 0.08\\,\\text{m}$, $\\sigma_{t,1} = 0.002\\,\\text{s}$.\n  - Pulse $m=2$: $A_{2} = 0.60\\,\\text{V/m}$, $x_{20} = 0.70\\,\\text{m}$, $v_{2} = -0.15\\,\\text{m/s}$, $t_{20} = 0.012\\,\\text{s}$, $\\sigma_{x,2} = 0.12\\,\\text{m}$, $\\sigma_{t,2} = 0.003\\,\\text{s}$.\n\nDefine a time-localized windowing scheme with window length $\\Delta t_{w}$ and overlap fraction $\\alpha \\in [0,1)$, where consecutive windows start $\\Delta t_{w}(1-\\alpha)$ seconds apart. For each window $w$, collect the snapshots of $\\mathbf{E}(t)$ whose time indices lie within the window, forming a matrix of weighted snapshots\n$$\nX_{w} = \\left[ \\sqrt{dx}\\,\\mathbf{E}(t_{n_{1}}), \\sqrt{dx}\\,\\mathbf{E}(t_{n_{2}}), \\dots, \\sqrt{dx}\\,\\mathbf{E}(t_{n_{M_{w}}}) \\right] \\in \\mathbb{R}^{N \\times M_{w}},\n$$\nwhich induces the spatial $L^{2}$ inner product by uniform quadrature. For each $X_{w}$, consider the best rank-$r$ linear subspace approximation to the snapshot columns in the sense of minimizing the sum of squared projection residuals. Let $\\tau \\in (0,1)$ be a required fraction of captured energy. The minimal dimension $r_{w}$ for window $w$ is defined as the smallest integer $r$ for which the chosen reduced basis captures at least a fraction $\\tau$ of the total snapshot energy within that window. For the entire collection of windows induced by $\\Delta t_{w}$ and $\\alpha$, define the case result as\n$$\nr_{\\max} = \\max_{w} r_{w},\n$$\nthe worst-case minimal dimension needed across all windows to guarantee at least fraction $\\tau$ energy capture.\n\nYour task is to implement a complete program to:\n1. Generate $\\mathbf{E}_{i}(t)$ according to the specification above, with units of volts per meter and times in seconds.\n2. Partition the time interval into windows for given $\\Delta t_{w}$ and $\\alpha$. Ensure the last window includes the final time by adjusting the final start index if necessary. Use integer numbers of samples per window, computed by rounding $\\Delta t_{w}/dt$ to the nearest integer and enforcing at least one sample.\n3. For each window $w$, construct $X_{w}$, compute the minimal integer $r_{w}$ needed to capture at least fraction $\\tau$ of the total snapshot energy in that window using an optimal rank-$r$ subspace, and then compute $r_{\\max}$ for the case.\n\nDesign your implementation to produce the following test suite results, one per case:\n- Case A: $\\Delta t_{w} = 0.004\\,\\text{s}$, $\\alpha = 0.5$ (decimal), $\\tau = 0.99$ (decimal).\n- Case B: $\\Delta t_{w} = 0.012\\,\\text{s}$, $\\alpha = 0.5$ (decimal), $\\tau = 0.99$ (decimal).\n- Case C: $\\Delta t_{w} = 0.004\\,\\text{s}$, $\\alpha = 0.0$ (decimal), $\\tau = 0.95$ (decimal).\n- Case D: $\\Delta t_{w} = 0.008\\,\\text{s}$, $\\alpha = 0.75$ (decimal), $\\tau = 0.999$ (decimal).\n- Case E: $\\Delta t_{w} = 0.020\\,\\text{s}$, $\\alpha = 0.5$ (decimal), $\\tau = 0.90$ (decimal).\n\nEach caseâ€™s answer must be a single integer $r_{\\max}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_{A},r_{B},r_{C},r_{D},r_{E}]$). All times must be treated in seconds, and all electric field values must be in volts per meter. No angles are involved. Fractions such as $\\alpha$ and $\\tau$ must be provided and treated as decimals, not percentages.",
            "solution": "The user wants me to solve a computational problem related to reduced-order modeling in electromagnetics.\n\n### Step 1: Extract Givens\n- **Spatial Domain:** Length $L = 1\\,\\text{m}$, $N = 64$ uniform nodes, spacing $dx = L/(N-1)$.\n- **Temporal Domain:** Total time $T = 0.02\\,\\text{s}$, time step $dt = 1 \\times 10^{-4}\\,\\text{s}$. Time points $t_n = n \\cdot dt$ for $n = 0, 1, \\dots, \\lfloor T/dt \\rfloor$.\n- **Electric Field Model:** A spatially discretized field $\\mathbf{E}(t) \\in \\mathbb{R}^{N}$ defined as a superposition of two moving Gaussian pulses:\n$$\n\\mathbf{E}_{i}(t) = \\sum_{m=1}^{2} A_{m}\\,\\exp\\!\\left(-\\frac{\\left(x_{i} - \\left(x_{m0} + v_{m}(t - t_{m0})\\right)\\right)^{2}}{2\\sigma_{x,m}^{2}}\\right)\\,\\exp\\!\\left(-\\frac{(t - t_{m0})^{2}}{2\\sigma_{t,m}^{2}}\\right)\n$$\n- **Pulse 1 Parameters:** $A_{1} = 1.0\\,\\text{V/m}$, $x_{10} = 0.30\\,\\text{m}$, $v_{1} = 0.10\\,\\text{m/s}$, $t_{10} = 0.006\\,\\text{s}$, $\\sigma_{x,1} = 0.08\\,\\text{m}$, $\\sigma_{t,1} = 0.002\\,\\text{s}$.\n- **Pulse 2 Parameters:** $A_{2} = 0.60\\,\\text{V/m}$, $x_{20} = 0.70\\,\\text{m}$, $v_{2} = -0.15\\,\\text{m/s}$, $t_{20} = 0.012\\,\\text{s}$, $\\sigma_{x,2} = 0.12\\,\\text{m}$, $\\sigma_{t,2} = 0.003\\,\\text{s}$.\n- **Windowing:** Window length $\\Delta t_{w}$, overlap fraction $\\alpha \\in [0,1)$. Consecutive windows start $\\Delta t_{w}(1-\\alpha)$ seconds apart. The number of samples per window is rounded from $\\Delta t_{w}/dt$. The last window is adjusted to include the final time sample.\n- **Snapshot Matrix:** For each window $w$, collect snapshots $\\mathbf{E}(t)$ to form $\\mathbf{X}_{w} = \\left[ \\sqrt{dx}\\,\\mathbf{E}(t_{n_{1}}), \\dots, \\sqrt{dx}\\,\\mathbf{E}(t_{n_{M_{w}}}) \\right]$.\n- **Rank Determination:** Find the minimal integer rank $r_w$ for window $w$ such that the best rank-$r_w$ linear subspace captures at least a fraction $\\tau$ of the total energy in $\\mathbf{X}_w$.\n- **Case Result:** $r_{\\max} = \\max_{w} r_{w}$.\n- **Test Cases:**\n  - Case A: $\\Delta t_{w} = 0.004\\,\\text{s}$, $\\alpha = 0.5$, $\\tau = 0.99$.\n  - Case B: $\\Delta t_{w} = 0.012\\,\\text{s}$, $\\alpha = 0.5$, $\\tau = 0.99$.\n  - Case C: $\\Delta t_{w} = 0.004\\,\\text{s}$, $\\alpha = 0.0$, $\\tau = 0.95$.\n  - Case D: $\\Delta t_{w} = 0.008\\,\\text{s}$, $\\alpha = 0.75$, $\\tau = 0.999$.\n  - Case E: $\\Delta t_{w} = 0.020\\,\\text{s}$, $\\alpha = 0.5$, $\\tau = 0.90$.\n- **Output Format:** A list of integers, e.g., $[r_{A},r_{B},r_{C},r_{D},r_{E}]$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded:** The problem uses a synthetic but physically plausible representation of a wave phenomenon. The method for model reduction, Proper Orthogonal Decomposition (POD) via Singular Value Decomposition (SVD), is a standard and powerful technique in computational science and engineering. The connection between singular values and energy is fundamental to this method. The problem is scientifically sound.\n2.  **Well-Posed:** All parameters, equations, and procedures are explicitly defined. The task is to compute a unique numerical value ($r_{\\max}$) for several sets of well-defined inputs. The SVD guarantees a unique set of singular values, leading to a unique determination of $r_w$ and subsequently $r_{\\max}$.\n3.  **Objective:** The problem statement is free of subjective language and relies entirely on mathematical and numerical definitions.\n4.  **Flaw Checklist:**\n    - Scientific or Factual Unsoundness: None.\n    - Non-Formalizable or Irrelevant: The problem is directly relevant to reduced-order modeling in computational electromagnetics and is fully formalizable.\n    - Incomplete or Contradictory Setup: None. All parameters are provided. The rule for handling the final window, while requiring careful interpretation, is not contradictory.\n    - Unrealistic or Infeasible: The parameters are physically reasonable, and the computation is feasible on standard hardware.\n    - Ill-Posed or Poorly Structured: The problem is well-posed, and the solution is unique.\n    - Pseudo-Profound, Trivial, or Tautological: The problem requires a non-trivial implementation involving data generation, windowing, and numerical linear algebra (SVD), representing a valid test of understanding of POD.\n    - Outside Scientific Verifiability: The results are computationally verifiable.\n\n### Step 3: Verdict and Action\nThe problem is valid. A reasoned solution will be provided.\n\nThe problem asks for the computation of the maximum required rank, $r_{\\max}$, for a reduced-order model of a transient electric field over a set of time-localized windows. The procedure involves generating a synthetic dataset, partitioning it, and applying Singular Value Decomposition (SVD) to each data segment to determine the necessary model complexity for a given energy capture criterion.\n\nFirst, we establish the discrete domain. The spatial domain is a line of length $L=1\\,\\text{m}$ discretized into $N=64$ nodes, so the spatial coordinates are $x_i$ for $i=0, \\dots, N-1$, with $dx=L/(N-1)$. The time domain is from $t=0$ to $T=0.02\\,\\text{s}$ with a time step of $dt=1\\times 10^{-4}\\,\\text{s}$, yielding $N_t = \\lfloor T/dt \\rfloor + 1 = 201$ time points $t_n=n \\cdot dt$.\n\nThe electric field $\\mathbf{E}_{i}(t)$ at spatial node $x_i$ and time $t$ is given as a superposition of two moving Gaussian pulses:\n$$\n\\mathbf{E}_{i}(t) = \\sum_{m=1}^{2} A_{m}\\,\\exp\\!\\left(-\\frac{\\left(x_{i} - c_m(t)\\right)^{2}}{2\\sigma_{x,m}^{2}}\\right)\\,\\exp\\!\\left(-\\frac{(t - t_{m0})^{2}}{2\\sigma_{t,m}^{2}}\\right)\n$$\nwhere $c_m(t) = x_{m0} + v_{m}(t - t_{m0})$ is the time-dependent center of the $m$-th pulse. Using the provided parameters for both pulses, we generate a full data matrix $\\mathbf{E} \\in \\mathbb{R}^{N \\times N_t}$, where each column is a \"snapshot\" of the entire spatial field $\\mathbf{E}(t_n)$ at a specific time $t_n$.\n\nNext, we partition the series of $N_t$ snapshots into windows according to the parameters $\\Delta t_w$ and $\\alpha$ for each case. The window length in terms of time samples is $N_w = \\text{max}(1, \\text{round}(\\Delta t_w/dt))$. The step size between the start of consecutive windows is $N_{\\text{step}} = \\text{max}(1, \\text{round}(N_w(1-\\alpha)))$. We generate a series of full-length windows. To ensure the final time sample at index $N_t-1$ is included, we define the window start indices as follows: we generate an initial list of start indices for all full-length windows that fit within the $N_t$ samples. If the last of these windows does not cover the final sample, we append a new window start index, $N_t - N_w$, to guarantee coverage. This ensures all windows have a fixed length of $N_w$ samples.\n\nFor each window $w$, we construct a snapshot matrix $\\mathbf{X}_w \\in \\mathbb{R}^{N \\times N_w}$. The columns of $\\mathbf{X}_w$ are the electric field snapshots within that window, scaled by $\\sqrt{dx}$:\n$$\n\\mathbf{X}_w = \\left[ \\sqrt{dx}\\,\\mathbf{E}(t_{n_{1}}), \\sqrt{dx}\\,\\mathbf{E}(t_{n_{2}}), \\dots, \\sqrt{dx}\\,\\mathbf{E}(t_{n_{N_w}}) \\right]\n$$\nThis scaling ensures that the squared norm of a column corresponds to the discrete $L^2$ norm approximation of the electric field energy at that instant (up to a constant $\\varepsilon/2$).\n\nThe core of the analysis for each window is to find the best rank-$r$ approximation. This is achieved using Singular Value Decomposition (SVD), which is the mathematical foundation of Proper Orthogonal Decomposition (POD). We compute the SVD of the snapshot matrix: $\\mathbf{X}_w = \\mathbf{U}_w \\mathbf{\\Sigma}_w \\mathbf{V}_w^T$. The singular values $\\sigma_{w,j}$ (the diagonal entries of $\\mathbf{\\Sigma}_w$) are crucial. The total \"energy\" of the snapshots in the window is given by the squared Frobenius norm of $\\mathbf{X}_w$, which is the sum of the squares of all singular values:\n$$\nE_{\\text{total}, w} = \\lVert \\mathbf{X}_w \\rVert_F^2 = \\sum_{j=1}^{\\min(N, N_w)} \\sigma_{w,j}^2\n$$\nThe energy captured by an optimal rank-$r$ approximation (using the first $r$ left singular vectors from $\\mathbf{U}_w$ as a basis) is the sum of the squares of the first $r$ singular values:\n$$\nE_r = \\sum_{j=1}^{r} \\sigma_{w,j}^2\n$$\nFor each window $w$, we must find the minimal integer rank $r_w$ that captures at least a fraction $\\tau$ of the total energy. This is the smallest $r$ satisfying:\n$$\n\\frac{\\sum_{j=1}^{r} \\sigma_{w,j}^2}{\\sum_{j=1}^{\\min(N, N_w)} \\sigma_{w,j}^2} \\ge \\tau\n$$\nWe compute this by calculating the cumulative sum of the squared singular values and finding the first index $r$ where the cumulative energy fraction meets or exceeds $\\tau$. If the total energy in a window is effectively zero, we define $r_w=0$.\n\nFinally, for each test case (A-E), we find the maximum required rank over all its windows, $r_{\\max} = \\max_w r_w$. This value represents the worst-case dimensionality needed to satisfy the energy capture criterion $\\tau$ across the entire time evolution, given the specified windowing scheme. The program computes this $r_{\\max}$ for each of the five cases and outputs the results as a list.",
            "answer": "```python\nimport numpy as np\n\n# Define global constants based on the problem statement\nL = 1.0\nN = 64\nT = 0.02\nDT = 1e-4\n\nPULSE1_PARAMS = {\n    'A': 1.0, 'x0': 0.30, 'v': 0.10, 't0': 0.006,\n    'sigma_x': 0.08, 'sigma_t': 0.002\n}\nPULSE2_PARAMS = {\n    'A': 0.60, 'x0': 0.70, 'v': -0.15, 't0': 0.012,\n    'sigma_x': 0.12, 'sigma_t': 0.003\n}\n\ndef generate_e_field():\n    \"\"\"\n    Generates the full spatio-temporal electric field data matrix E.\n\n    Returns:\n        tuple: A tuple containing:\n            - E (np.ndarray): The (N, num_t) field data matrix.\n            - dx (float): The spatial step size.\n            - num_t (int): The total number of time points.\n    \"\"\"\n    dx = L / (N - 1)\n    x_nodes = np.linspace(0, L, N).reshape(-1, 1)\n    \n    num_t = int(T / DT) + 1\n    t_points = np.arange(num_t) * DT\n\n    # Generate field from pulse 1\n    p1 = PULSE1_PARAMS\n    center_x1 = p1['x0'] + p1['v'] * (t_points - p1['t0'])\n    spatial_term1 = np.exp(-((x_nodes - center_x1)**2) / (2 * p1['sigma_x']**2))\n    temporal_term1 = np.exp(-((t_points - p1['t0'])**2) / (2 * p1['sigma_t']**2))\n    E1 = p1['A'] * spatial_term1 * temporal_term1\n\n    # Generate field from pulse 2\n    p2 = PULSE2_PARAMS\n    center_x2 = p2['x0'] + p2['v'] * (t_points - p2['t0'])\n    spatial_term2 = np.exp(-((x_nodes - center_x2)**2) / (2 * p2['sigma_x']**2))\n    temporal_term2 = np.exp(-((t_points - p2['t0'])**2) / (2 * p2['sigma_t']**2))\n    E2 = p2['A'] * spatial_term2 * temporal_term2\n    \n    # Superposition of the two pulses\n    E = E1 + E2\n    return E, dx, num_t\n\ndef calculate_rmax(E_field, dx, num_t, delta_t_w, alpha, tau):\n    \"\"\"\n    Calculates r_max for a given set of windowing and energy capture parameters.\n\n    Args:\n        E_field (np.ndarray): The full (N, num_t) field data matrix.\n        dx (float): The spatial step size.\n        num_t (int): The total number of time points.\n        delta_t_w (float): The window length in seconds.\n        alpha (float): The overlap fraction.\n        tau (float): The energy capture threshold.\n\n    Returns:\n        int: The calculated r_max value for the case.\n    \"\"\"\n    win_len = max(1, int(round(delta_t_w / DT)))\n    step = max(1, int(round(win_len * (1 - alpha))))\n    \n    if win_len == 0:\n        return 0\n\n    # Generate start indices for all full-length windows that fit in the data\n    stop_idx = num_t - win_len + 1\n    if stop_idx <= 0:\n        start_indices = [0]\n    else:\n        start_indices = list(range(0, stop_idx, step))\n    \n    # Ensure the last window includes the final time sample by adding a\n    # final window if necessary.\n    if start_indices:\n        last_reg_window_end = start_indices[-1] + win_len\n        if last_reg_window_end < num_t:\n            final_start_idx = num_t - win_len\n            # Append only if it's a new, later-starting window\n            if final_start_idx > start_indices[-1]:\n                 start_indices.append(final_start_idx)\n    elif num_t > 0:\n         start_indices = [0]\n\n    r_max = 0\n    for start_idx in start_indices:\n        end_idx = start_idx + win_len\n        \n        E_window = E_field[:, start_idx:end_idx]\n        \n        if E_window.shape[1] == 0:\n            continue\n            \n        X_w = np.sqrt(dx) * E_window\n        \n        s = np.linalg.svd(X_w, compute_uv=False)\n        \n        s_squared = s**2\n        total_energy = np.sum(s_squared)\n        \n        if total_energy < 1e-20:\n            r_w = 0\n        else:\n            cumulative_energy_fraction = np.cumsum(s_squared) / total_energy\n            # Find the smallest rank r that captures at least fraction tau\n            r_w = np.searchsorted(cumulative_energy_fraction, tau, side='left') + 1\n\n        r_max = max(r_max, r_w)\n        \n    return r_max\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution process for all test cases.\n    \"\"\"\n    test_cases = [\n        {'delta_t_w': 0.004, 'alpha': 0.5, 'tau': 0.99},   # Case A\n        {'delta_t_w': 0.012, 'alpha': 0.5, 'tau': 0.99},   # Case B\n        {'delta_t_w': 0.004, 'alpha': 0.0, 'tau': 0.95},   # Case C\n        {'delta_t_w': 0.008, 'alpha': 0.75, 'tau': 0.999}, # Case D\n        {'delta_t_w': 0.020, 'alpha': 0.5, 'tau': 0.90},   # Case E\n    ]\n\n    E_field, dx, num_t = generate_e_field()\n    \n    results = []\n    for case in test_cases:\n        r_max = calculate_rmax(E_field, dx, num_t, **case)\n        results.append(r_max)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Reduced-order models truly shine when embedded within larger computational loops, such as optimization. This advanced exercise demonstrates how to accelerate adjoint-based electromagnetic topology optimization using a ROM . You will build a reduced basis for a frequency-domain problem, solve both the reduced state and adjoint equations, and compute the design sensitivity gradient, quantifying the accuracy trade-off against a full-order calculation.",
            "id": "3345202",
            "problem": "Consider time-harmonic electromagnetic fields governed by Maxwell's equations in a source-driven, nonmagnetic, two-dimensional domain with Dirichlet boundary conditions. Under the Transverse Electric (TE) assumption and standard Finite Difference Frequency Domain (FDFD) discretization, the scalar electric field amplitude $E$ on the interior grid nodes satisfies a linear system\n$$\nA(\\boldsymbol{\\rho})\\,\\mathbf{E} = \\mathbf{b},\n$$\nwhere $\\mathbf{E} \\in \\mathbb{R}^N$ is the field vector at $N$ interior nodes, $\\mathbf{b} \\in \\mathbb{R}^N$ is a fixed source vector representing a localized impressed current density, and $A(\\boldsymbol{\\rho}) \\in \\mathbb{R}^{N \\times N}$ is the symmetric positive definite system matrix defined by\n$$\nA(\\boldsymbol{\\rho}) = K + k_0^2 \\,\\mathrm{diag}\\!\\left(\\boldsymbol{\\varepsilon}(\\boldsymbol{\\rho})\\right),\n$$\nwith $K$ the discrete negative Laplacian (scaled by the grid spacing) for Dirichlet boundary conditions, $k_0$ the free-space wavenumber, and $\\boldsymbol{\\varepsilon}(\\boldsymbol{\\rho})$ the relative permittivity distribution parametrized by a design vector $\\boldsymbol{\\rho} \\in [0,1]^N$ via\n$$\n\\varepsilon_i(\\rho_i) = \\varepsilon_{\\min} + (\\varepsilon_{\\max} - \\varepsilon_{\\min})\\,\\rho_i, \\quad i = 1,\\dots,N.\n$$\nDefine the objective functional\n$$\nJ(\\mathbf{E}) = \\tfrac{1}{2}\\,\\mathbf{E}^\\top W\\,\\mathbf{E},\n$$\nwhere $W \\in \\mathbb{R}^{N \\times N}$ is a diagonal weighting matrix selecting a target \"detector\" subregion of the grid (entries equal to one on the target nodes and zero otherwise). The gradient of $J$ with respect to the design vector $\\boldsymbol{\\rho}$ can be derived via the adjoint method, starting from the Lagrangian\n$$\n\\mathcal{L}(\\mathbf{E},\\boldsymbol{\\lambda},\\boldsymbol{\\rho}) = J(\\mathbf{E}) + \\boldsymbol{\\lambda}^\\top\\left(A(\\boldsymbol{\\rho})\\,\\mathbf{E} - \\mathbf{b}\\right),\n$$\nwhere $\\boldsymbol{\\lambda} \\in \\mathbb{R}^N$ is the adjoint variable. The Full-Order Model (FOM) adjoint condition is\n$$\nA(\\boldsymbol{\\rho})\\,\\boldsymbol{\\lambda} = \\frac{\\partial J}{\\partial \\mathbf{E}} = W\\,\\mathbf{E},\n$$\nand the FOM gradient component with respect to $\\rho_i$ is\n$$\n\\frac{\\partial J}{\\partial \\rho_i} = -\\boldsymbol{\\lambda}^\\top \\frac{\\partial A(\\boldsymbol{\\rho})}{\\partial \\rho_i} \\mathbf{E} = -k_0^2\\,(\\varepsilon_{\\max}-\\varepsilon_{\\min})\\,\\lambda_i\\,E_i.\n$$\nTo accelerate repeated solves during topology optimization, consider a Reduced-Order Model (ROM) constructed by Galerkin projection onto a subspace spanned by columns of $V \\in \\mathbb{R}^{N \\times r}$ with $r \\ll N$. Given a chosen basis $V$, the ROM state and adjoint are obtained by solving\n$$\nA_r\\,\\mathbf{E}_r = \\mathbf{b}_r, \\quad \\text{and} \\quad A_r\\,\\boldsymbol{\\lambda}_r = \\frac{\\partial J}{\\partial \\mathbf{E}}\\bigg|_{\\mathbf{E} = V\\mathbf{E}_r}^{\\!\\!\\!\\!\\!\\!\\!\\!\\!\\text{projected}} = V^\\top W\\,V\\,\\mathbf{E}_r,\n$$\nwith $A_r = V^\\top A(\\boldsymbol{\\rho}) V$ and $\\mathbf{b}_r = V^\\top \\mathbf{b}$, and then lifting $\\mathbf{E}_{\\mathrm{ROM}} = V\\,\\mathbf{E}_r$ and $\\boldsymbol{\\lambda}_{\\mathrm{ROM}} = V\\,\\boldsymbol{\\lambda}_r$. The ROM gradient component is computed analogously as\n$$\n\\left(\\frac{\\partial J}{\\partial \\rho_i}\\right)_{\\mathrm{ROM}} = -k_0^2\\,(\\varepsilon_{\\max}-\\varepsilon_{\\min})\\,\\lambda_{\\mathrm{ROM},i}\\,E_{\\mathrm{ROM},i}.\n$$\nQuantify the ROM-induced gradient mismatch by the relative error metric\n$$\n\\eta = \\frac{\\left\\| \\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{ROM}} - \\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{FOM}} \\right\\|_2}{\\left\\| \\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{FOM}} \\right\\|_2}.\n$$\nYour task is to implement a complete program that:\n- Constructs $K$ on a rectangular interior grid of size $N_x \\times N_y$ using the standard five-point stencil with Dirichlet boundary conditions and grid spacing $h = 1/(N_x+1)$ in $x$ and $y$ (assume a unit square domain for simplicity; the same spacing is used in both directions).\n- Builds $\\boldsymbol{\\varepsilon}(\\boldsymbol{\\rho})$ from a deterministic, heterogeneous design field defined at interior nodes by $ \\rho(x,y) = \\left[0.5 + 0.5 \\sin(2\\pi x)\\cos(2\\pi y)\\right] $ clipped to $[0,1]$, with $x$ and $y$ the node coordinates on the interior grid.\n- Chooses $\\varepsilon_{\\min} = 1.0$ and $\\varepsilon_{\\max} = 12.0$.\n- Sets $\\mathbf{b}$ as a unit point source at the interior node closest to $(x,y) = (0.25, 0.5)$.\n- Defines $W$ as a diagonal selector of nodes with $x \\ge 0.8$.\n- Constructs a Reduced-Order Model basis $V$ via an inverse-Krylov process centered at a specified basis matrix $A_{\\text{basis}}$:\n  1. Start with $\\mathbf{v}_0 = \\mathbf{b} / \\|\\mathbf{b}\\|_2$.\n  2. For $j = 1, \\dots, r-1$, compute $\\mathbf{w} = A_{\\text{basis}}^{-1}\\,\\mathbf{v}_{j-1}$, orthonormalize $\\mathbf{w}$ against previous $\\{\\mathbf{v}_i\\}_{i=0}^{j-1}$ using Gram-Schmidt, and normalize to get $\\mathbf{v}_j$.\n  3. Form $V = [\\mathbf{v}_0, \\dots, \\mathbf{v}_{r-1}]$. If $r \\ge N$, set $V = I_N$ to represent the full-order subspace.\n- Computes the FOM and ROM gradients and the relative mismatch $\\eta$ for each test case.\n\nUse the following test suite, which varies the reduced basis size and the consistency between $A_{\\text{basis}}$ and the evaluation matrix $A(\\boldsymbol{\\rho})$:\n1. $(N_x,N_y,k_0,r,\\text{basis }k_0) = (12,12,8.0,10,8.0)$: a typical case with a reasonably rich basis.\n2. $(N_x,N_y,k_0,r,\\text{basis }k_0) = (12,12,8.0,N,8.0)$ where $N = N_x N_y$: a boundary case where the ROM equals the FOM.\n3. $(N_x,N_y,k_0,r,\\text{basis }k_0) = (12,12,8.0,3,8.0)$: an edge case with a very small basis.\n4. $(N_x,N_y,k_0,r,\\text{basis }k_0) = (12,12,5.0,10,8.0)$: a case where the ROM basis is constructed at a different wavenumber than the evaluation, probing parametric inconsistency.\n\nYour program should produce a single line of output containing the relative mismatch values $\\eta$ for the four test cases as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places (e.g., \"[0.012345,0.000001,0.123456,0.056789]\"). No physical units are required, and angles are not involved. All computations are dimensionless.\n\nYour implementation must be a complete, runnable program in the specified environment and must not require user input or external files.",
            "solution": "The user has provided a problem that requires the quantification of the error introduced by a Reduced-Order Model (ROM) in the context of electromagnetic topology optimization. This will be accomplished by comparing the design gradient computed with a high-fidelity Full-Order Model (FOM) to that computed with the ROM. A critical prerequisite is the validation of the problem statement.\n\n### Problem Validation\n\nI will first extract the givens and validate the problem's integrity.\n\n**Step 1: Extract Givens**\n\n-   **Governing Physics**: Time-harmonic 2D TE Maxwell's equations, discretized via Finite Difference Frequency Domain (FDFD).\n-   **FOM System**: $A(\\boldsymbol{\\rho})\\,\\mathbf{E} = \\mathbf{b}$, with $\\mathbf{E}, \\mathbf{b} \\in \\mathbb{R}^N$.\n-   **System Matrix**: $A(\\boldsymbol{\\rho}) = K + k_0^2 \\,\\mathrm{diag}\\!\\left(\\boldsymbol{\\varepsilon}(\\boldsymbol{\\rho})\\right)$, which is symmetric positive definite (SPD). $K$ is the discrete negative Laplacian, and $k_0$ is the free-space wavenumber.\n-   **Permittivity Model**: $\\varepsilon_i(\\rho_i) = \\varepsilon_{\\min} + (\\varepsilon_{\\max} - \\varepsilon_{\\min})\\,\\rho_i$, for a design vector $\\boldsymbol{\\rho} \\in [0,1]^N$.\n-   **Objective Function**: $J(\\mathbf{E}) = \\tfrac{1}{2}\\,\\mathbf{E}^\\top W\\,\\mathbf{E}$, where $W$ is a diagonal selection matrix.\n-   **FOM Adjoint System**: $A(\\boldsymbol{\\rho})\\,\\boldsymbol{\\lambda} = W\\,\\mathbf{E}$.\n-   **FOM Gradient**: $\\frac{\\partial J}{\\partial \\rho_i} = -k_0^2\\,(\\varepsilon_{\\max}-\\varepsilon_{\\min})\\,\\lambda_i\\,E_i$.\n-   **ROM Basis**: $V \\in \\mathbb{R}^{N \\times r}$ with $r \\ll N$.\n-   **ROM Systems**: $A_r\\,\\mathbf{E}_r = \\mathbf{b}_r$ (state) and $A_r\\,\\boldsymbol{\\lambda}_r = V^\\top W\\,V\\,\\mathbf{E}_r$ (adjoint), where $A_r = V^\\top A(\\boldsymbol{\\rho}) V$ and $\\mathbf{b}_r = V^\\top \\mathbf{b}$.\n-   **ROM Reconstruction**: $\\mathbf{E}_{\\mathrm{ROM}} = V\\,\\mathbf{E}_r$ and $\\boldsymbol{\\lambda}_{\\mathrm{ROM}} = V\\,\\boldsymbol{\\lambda}_r$.\n-   **ROM Gradient**: $\\left(\\frac{\\partial J}{\\partial \\rho_i}\\right)_{\\mathrm{ROM}} = -k_0^2\\,(\\varepsilon_{\\max}-\\varepsilon_{\\min})\\,\\lambda_{\\mathrm{ROM},i}\\,E_{\\mathrm{ROM},i}$.\n-   **Error Metric**: $\\eta = \\frac{\\left\\| \\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{ROM}} - \\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{FOM}} \\right\\|_2}{\\left\\| \\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{FOM}} \\right\\|_2}$.\n-   **Implementation Specifics**:\n    -   Grid of size $N_x \\times N_y$ on a unit square, with spacing $h = 1/(N_x+1)$.\n    -   Design field: $ \\rho(x,y) = \\left[0.5 + 0.5 \\sin(2\\pi x)\\cos(2\\pi y)\\right] $.\n    -   Constants: $\\varepsilon_{\\min} = 1.0$, $\\varepsilon_{\\max} = 12.0$.\n    -   Source $\\mathbf{b}$: Unit point source at the node nearest to $(0.25, 0.5)$.\n    -   Weighting $W$: Selector for nodes where $x \\ge 0.8$.\n    -   Basis $V$: Constructed via an inverse-Krylov process using a basis matrix $A_{\\text{basis}}$, starting from $\\mathbf{b}$ and using Gram-Schmidt orthonormalization. For $r \\ge N$, $V=I_N$.\n-   **Test Cases**: Four cases varying $(N_x,N_y,k_0,r,\\text{basis }k_0)$.\n\n**Step 2: Validate Using Extracted Givens**\n\n1.  **Scientific Grounding**: The problem is firmly rooted in established principles of computational electromagnetics and numerical optimization. The FDFD method, adjoint-based sensitivity analysis, and projection-based model reduction (specifically, Galerkin projection onto a Krylov subspace) are standard, well-vetted techniques. The mathematical formulations for the system matrices, gradients, and projections are correct and consistent with the literature. The assertion that $A(\\boldsymbol{\\rho})$ is SPD is correct, as it is the sum of an SPD matrix ($K$) and a positive definite diagonal matrix ($k_0^2 \\mathrm{diag}(\\boldsymbol{\\varepsilon})$).\n\n2.  **Well-Posedness**: The problem is well-posed. The SPD property of the FOM matrix $A(\\boldsymbol{\\rho})$ and the resulting ROM matrix $A_r = V^\\top A(\\boldsymbol{\\rho}) V$ ensures that unique solutions for the state and adjoint variables exist in both the full and reduced models.\n\n3.  **Completeness and Consistency**: The problem statement is exceptionally detailed and self-contained. All necessary parameters, constants, and functional forms are specified, leaving no room for ambiguity. The provided equations for the state, adjoint, and gradient are internally consistent (assuming a Lagrangian formulation of $\\mathcal{L} = J - \\boldsymbol{\\lambda}^\\top(\\dots)$, a standard convention). The special handling for the case $r \\ge N$ is explicitly defined and constitutes a valid boundary condition for the model reduction, where the ROM is expected to exactly reproduce the FOM.\n\n4.  **Feasibility**: All specified parameters are physically realistic, and the computational tasks are feasible. The problem size ($N=144$) is small enough to be handled by standard libraries on a personal computer, including the case where a dense identity matrix is formed for $V$.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is a well-structured, scientifically sound, and complete problem that tests core concepts in reduced-order modeling for computational physics. I will now proceed with the solution.\n\n### Solution\n\nThe solution requires implementing a computational workflow to compare the design sensitivity gradients from a Full-Order Model (FOM) and a Reduced-Order Model (ROM). The core steps are outlined below.\n\n**1. Discretization and System Construction**\n\nThe continuous problem domain, a unit square, is discretized into a grid of $N_x \\times N_y$ interior nodes. The total number of degrees of freedom is $N = N_x N_y$. The grid spacing $h=1/(N_x+1)$ is uniform in both directions. All field quantities are represented as vectors of size $N$.\n\nThe discrete negative Laplacian operator, $K$, is constructed as an $N \\times N$ sparse matrix representing the five-point finite difference stencil on this grid, scaled by $1/h^2$. This corresponds to the matrix form of $-\\nabla^2$.\n\nThe relative permittivity distribution $\\boldsymbol{\\varepsilon}(\\boldsymbol{\\rho})$ is defined at each node using the given spatial function for $\\boldsymbol{\\rho}$ and the linear mapping to $[\\varepsilon_{\\min}, \\varepsilon_{\\max}]$. This forms a diagonal matrix $\\mathrm{diag}(\\boldsymbol{\\varepsilon})$.\n\nWith these components, the full system matrix $A(\\boldsymbol{\\rho}) = K + k_0^2 \\mathrm{diag}(\\boldsymbol{\\varepsilon})$ is assembled for a given wavenumber $k_0$.\n\n**2. Source and Objective Definition**\n\nThe source vector $\\mathbf{b}$ is constructed as a vector of zeros with a single entry of $1$ at the node index corresponding to the coordinates closest to $(x,y)=(0.25, 0.5)$.\n\nThe objective function weighting matrix $W$ is a diagonal matrix. Its diagonal entries are $1$ for nodes located in the region $x \\ge 0.8$ and $0$ otherwise. This effectively defines the objective as the integrated field intensity over the detector region.\n\n**3. Full-Order Model (FOM) Analysis**\n\nThe FOM analysis involves two linear solves:\n-   **State solution**: The electric field $\\mathbf{E}_{\\mathrm{FOM}}$ is found by solving the primary linear system $A(\\boldsymbol{\\rho})\\,\\mathbf{E}_{\\mathrm{FOM}} = \\mathbf{b}$.\n-   **Adjoint solution**: The adjoint variable $\\boldsymbol{\\lambda}_{\\mathrm{FOM}}$ is found by solving the adjoint system $A(\\boldsymbol{\\rho})\\,\\boldsymbol{\\lambda}_{\\mathrm{FOM}} = W\\,\\mathbf{E}_{\\mathrm{FOM}}$.\n\nThe FOM gradient vector $\\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{FOM}}$ is then computed element-wise using the formula $\\frac{\\partial J}{\\partial \\rho_i} = -k_0^2(\\varepsilon_{\\max}-\\varepsilon_{\\min})\\lambda_{\\mathrm{FOM},i}E_{\\mathrm{FOM},i}$.\n\n**4. Reduced-Order Model (ROM) Construction and Analysis**\n\nThe core of the ROM is the basis $V \\in \\mathbb{R}^{N \\times r}$, which projects the problem from the high-dimensional space $\\mathbb{R}^N$ to a low-dimensional subspace $\\mathbb{R}^r$.\n\n-   **Basis Generation**: For $r < N$, the basis $V$ is generated using an inverse-Krylov method. Starting with the normalized source vector $\\mathbf{v}_0 = \\mathbf{b}/\\|\\mathbf{b}\\|_2$, subsequent basis vectors are generated iteratively: $\\mathbf{w}_j = A_{\\text{basis}}^{-1} \\mathbf{v}_{j-1}$. Each new vector $\\mathbf{w}_j$ is made orthogonal to all previous basis vectors $\\{\\mathbf{v}_0, \\ldots, \\mathbf{v}_{j-1}\\}$ via the Modified Gram-Schmidt process, and then normalized to produce $\\mathbf{v}_j$. The matrix $A_{\\text{basis}}$ is constructed using a reference wavenumber, `basis k0`. This process builds a basis that is particularly effective at representing solutions driven by the source $\\mathbf{b}$ for systems \"close\" to $A_{\\text{basis}}$. For the special case $r \\ge N$, the basis is the identity matrix $V=I_N$, meaning no reduction occurs.\n\n-   **ROM Projection**: The FOM system is projected onto the basis $V$ via Galerkin projection:\n    $A_r = V^\\top A(\\boldsymbol{\\rho}) V$\n    $\\mathbf{b}_r = V^\\top \\mathbf{b}$\n\n-   **ROM Solution**: The reduced state and adjoint variables, $\\mathbf{E}_r$ and $\\boldsymbol{\\lambda}_r$, are found by solving the much smaller $r \\times r$ linear systems:\n    $A_r \\mathbf{E}_r = \\mathbf{b}_r$\n    $A_r \\boldsymbol{\\lambda}_r = (V^\\top W V) \\mathbf{E}_r$\n\n-   **Reconstruction**: The full-space approximations are reconstructed by lifting the reduced solutions back: $\\mathbf{E}_{\\mathrm{ROM}} = V\\mathbf{E}_r$ and $\\boldsymbol{\\lambda}_{\\mathrm{ROM}} = V\\boldsymbol{\\lambda}_r$. The ROM gradient $\\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{ROM}}$ is computed using these reconstructed fields.\n\n**5. Error Quantification**\n\nFinally, the mismatch between the FOM and ROM gradients is quantified using the specified relative error metric $\\eta$, which measures the normalized Euclidean distance between the two gradient vectors. This metric provides a concise measure of the ROM's accuracy for design sensitivity analysis. The entire process is repeated for each of the four test cases.",
            "answer": "```python\nimport numpy as np\nimport scipy.sparse as sp\nimport scipy.sparse.linalg as spla\n\ndef solve():\n    \"\"\"\n    Solves the reduced-order modeling problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, k0, r, basis_k0)\n        (12, 12, 8.0, 10, 8.0),\n        (12, 12, 8.0, 144, 8.0), # Note: r = N = 12*12 = 144\n        (12, 12, 8.0, 3, 8.0),\n        (12, 12, 5.0, 10, 8.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        Nx, Ny, k0, r, basis_k0 = case\n        N = Nx * Ny\n        h = 1.0 / (Nx + 1)\n        \n        # 1. Grid and Coordinates\n        x_coords = np.linspace(h, 1.0 - h, Nx)\n        y_coords = np.linspace(h, 1.0 - h, Ny)\n        xv, yv = np.meshgrid(x_coords, y_coords, indexing='xy')\n        # Use C-style (row-major) flattening\n        x_flat = xv.flatten()\n        y_flat = yv.flatten()\n        \n        # 2. Construct K matrix (discrete negative Laplacian)\n        # Standard 5-point stencil for -h^2 * nabla^2 results in a matrix with \n        # 2 on the main diagonal and -1 on the two adjacent diagonals for 1D.\n        # We scale the final K matrix by 1/h^2.\n        K1D_x = sp.diags([-1, 2, -1], [-1, 0, 1], shape=(Nx, Nx), format='csc')\n        K1D_y = sp.diags([-1, 2, -1], [-1, 0, 1], shape=(Ny, Ny), format='csc')\n        I_Nx = sp.eye(Nx, format='csc')\n        I_Ny = sp.eye(Ny, format='csc')\n        # Assemble 2D Laplacian using Kronecker products for C-style ordering\n        K = (sp.kron(I_Ny, K1D_x) + sp.kron(K1D_y, I_Nx)) / (h**2)\n        K = K.tocsc()\n        \n        # 3. Construct material and source properties\n        eps_min, eps_max = 1.0, 12.0\n        rho = 0.5 + 0.5 * np.sin(2 * np.pi * x_flat) * np.cos(2 * np.pi * y_flat)\n        rho = np.clip(rho, 0, 1)\n        eps_vec = eps_min + (eps_max - eps_min) * rho\n        eps_diag = sp.diags(eps_vec, format='csc')\n        \n        # Source vector b\n        ix_src = np.argmin(np.abs(x_coords - 0.25))\n        iy_src = np.argmin(np.abs(y_coords - 0.5))\n        src_idx = iy_src * Nx + ix_src # C-style indexing\n        b = np.zeros(N)\n        b[src_idx] = 1.0\n        \n        # Weighting matrix W\n        w_vec = (x_flat >= 0.8).astype(float)\n        W = sp.diags(w_vec, format='csc')\n        \n        # 4. Construct Basis V\n        if r >= N:\n            # Special case: ROM is the FOM, so V is the identity matrix\n            V = np.eye(N)\n        else:\n            # Inverse-Krylov process\n            A_basis = K + basis_k0**2 * eps_diag\n            A_basis = A_basis.tocsc()\n            \n            V_cols = []\n            v0 = b / np.linalg.norm(b)\n            V_cols.append(v0)\n            \n            for j in range(1, r):\n                v_prev = V_cols[-1]\n                w = spla.spsolve(A_basis, v_prev)\n                \n                # Modified Gram-Schmidt orthogonalization\n                for i in range(j):\n                    v_i = V_cols[i]\n                    w = w - (v_i.T @ w) * v_i\n                \n                w_norm = np.linalg.norm(w)\n                if w_norm < 1e-12: # Avoid division by zero\n                    break\n                \n                v_next = w / w_norm\n                V_cols.append(v_next)\n                \n            V = np.array(V_cols).T\n\n        # 5. Full-Order Model (FOM) Calculation\n        A = K + k0**2 * eps_diag\n        A_csc = A.tocsc()\n        \n        E_fom = spla.spsolve(A_csc, b)\n        adj_rhs_fom = W @ E_fom\n        lambda_fom = spla.spsolve(A_csc, adj_rhs_fom)\n        grad_fom = -k0**2 * (eps_max - eps_min) * lambda_fom * E_fom\n        \n        # 6. Reduced-Order Model (ROM) Calculation\n        # Project system using the basis V\n        A_r = V.T @ A @ V\n        b_r = V.T @ b\n        \n        E_r = np.linalg.solve(A_r, b_r)\n        \n        # Project objective weighting and compute reduced adjoint\n        W_r = V.T @ W @ V\n        adj_rhs_rom = W_r @ E_r\n        lambda_r = np.linalg.solve(A_r, adj_rhs_rom)\n        \n        # Lift solutions back to full space\n        E_rom = V @ E_r\n        lambda_rom = V @ lambda_r\n        grad_rom = -k0**2 * (eps_max - eps_min) * lambda_rom * E_rom\n        \n        # 7. Compute Relative Error Metric\n        grad_fom_norm = np.linalg.norm(grad_fom)\n        if grad_fom_norm == 0:\n            eta = 0.0 if np.linalg.norm(grad_rom - grad_fom) == 0 else np.inf\n        else:\n            eta = np.linalg.norm(grad_rom - grad_fom) / grad_fom_norm\n            \n        results.append(eta)\n\n    # Print results in the required format\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}