{
    "hands_on_practices": [
        {
            "introduction": "Before simulating wave propagation in a periodic structure, one must establish the fundamental geometric framework in both real and reciprocal space. This practice involves the essential task of constructing reciprocal lattice vectors from the direct lattice vectors that define the unit cell, a relationship governed by the biorthogonality condition $\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi\\delta_{ij}$. By implementing this construction for various crystal symmetries and verifying it to machine precision, you will master a critical first step for setting up any periodic simulation and appreciate the importance of numerical fidelity in computational physics .",
            "id": "3308741",
            "problem": "You are given three-dimensional direct lattice primitive vectors and a Bloch wavevector. Your task is to construct the reciprocal lattice vectors for the arbitrary Bravais cell defined by the given primitives and to verify the Floquet periodic boundary constraints to machine precision on a discrete mesh sampling of the unit cell. The program must perform the following steps for each test case and return quantified error measures.\n\nStart from the following fundamental bases:\n- Time-harmonic Maxwell’s equations in a medium with spatially periodic material parameters imply that solutions for the electromagnetic field may be represented as Bloch waves. For a Bloch wave with Bloch wavevector $\\mathbf{k}$, the Floquet periodic boundary condition states that the field obeys $E(\\mathbf{r} + \\mathbf{a}_i) = E(\\mathbf{r}) \\exp\\!\\big(i\\,\\mathbf{k}\\cdot \\mathbf{a}_i\\big)$ for each direct lattice primitive translation $\\mathbf{a}_i$.\n- The reciprocal lattice primitives $\\mathbf{b}_i$ are defined by $\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi\\,\\delta_{ij}$, where $\\delta_{ij}$ is the Kronecker delta. This definition uniquely specifies the reciprocal lattice for a given set of direct lattice primitives that span $\\mathbb{R}^3$.\n\nYour program must, for each test case specified below, do the following:\n1. Given direct lattice primitives $\\mathbf{a}_1$, $\\mathbf{a}_2$, $\\mathbf{a}_3$ (in meters), construct the reciprocal lattice primitives $\\mathbf{b}_1$, $\\mathbf{b}_2$, $\\mathbf{b}_3$ such that $\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi\\,\\delta_{ij}$ holds. Then compute the maximum absolute deviation of the $3\\times 3$ matrix $\\mathbf{A}^\\top \\mathbf{B}$ from $2\\pi\\,\\mathbf{I}_3$, where $\\mathbf{A} = [\\mathbf{a}_1\\,\\mathbf{a}_2\\,\\mathbf{a}_3]$ and $\\mathbf{B} = [\\mathbf{b}_1\\,\\mathbf{b}_2\\,\\mathbf{b}_3]$, and $\\mathbf{I}_3$ is the $3\\times 3$ identity matrix. Report this maximum absolute deviation as a dimensionless float.\n2. Sample the unit cell on a uniform rectilinear mesh in fractional coordinates with $N_x$, $N_y$, $N_z$ points along the $\\mathbf{a}_1$, $\\mathbf{a}_2$, $\\mathbf{a}_3$ directions respectively. The mesh points are at fractional coordinates $(u_1,u_2,u_3)$ with $u_1 \\in \\{0, 1/N_x, \\dots, (N_x - 1)/N_x\\}$, $u_2 \\in \\{0, 1/N_y, \\dots, (N_y - 1)/N_y\\}$, $u_3 \\in \\{0, 1/N_z, \\dots, (N_z - 1)/N_z\\}$, and real-space positions $\\mathbf{r} = u_1 \\mathbf{a}_1 + u_2 \\mathbf{a}_2 + u_3 \\mathbf{a}_3$. Define the scalar plane wave field $E(\\mathbf{r}) = \\exp\\!\\big(i\\,\\mathbf{k}\\cdot \\mathbf{r}\\big)$.\n3. For each $i \\in \\{1,2,3\\}$, compute the maximum absolute mismatch over all mesh points of the identity implied by the Floquet condition,\n$$\n\\exp\\!\\big(i\\,\\mathbf{k}\\cdot(\\mathbf{r} + \\mathbf{a}_i)\\big) \\stackrel{?}{=} \\exp\\!\\big(i\\,\\mathbf{k}\\cdot \\mathbf{r}\\big)\\,\\exp\\!\\big(i\\,\\mathbf{k}\\cdot \\mathbf{a}_i\\big).\n$$\nIn other words, compute\n$$\n\\varepsilon_i = \\max_{\\mathbf{r}\\,\\text{on the mesh}} \\left| \\exp\\!\\big(i\\,\\mathbf{k}\\cdot(\\mathbf{r} + \\mathbf{a}_i)\\big) - \\exp\\!\\big(i\\,\\mathbf{k}\\cdot \\mathbf{r}\\big)\\,\\exp\\!\\big(i\\,\\mathbf{k}\\cdot \\mathbf{a}_i\\big) \\right|,\n$$\nand report each $\\varepsilon_i$ as a dimensionless float. Angles must be treated in radians, and the Bloch wavevector $\\mathbf{k}$ has units of inverse meters. The dot products $\\mathbf{k}\\cdot \\mathbf{a}_i$ are dimensionless radians.\n\nPhysical units: The direct lattice primitives $\\mathbf{a}_i$ must be interpreted in meters, and the Bloch wavevector components in inverse meters. Angles are in radians. All reported errors are dimensionless floats.\n\nTest Suite:\n- Test Case $1$ (orthorhombic cell, happy path):\n  - $\\mathbf{a}_1 = [\\,0.4,\\,0,\\,0\\,]$ $\\mathrm{m}$, $\\mathbf{a}_2 = [\\,0,\\,0.6,\\,0\\,]$ $\\mathrm{m}$, $\\mathbf{a}_3 = [\\,0,\\,0,\\,0.5\\,]$ $\\mathrm{m}$.\n  - $\\mathbf{k} = [\\,5.0,\\,8.0,\\,3.0\\,]$ $\\mathrm{m}^{-1}$.\n  - $N_x = 11$, $N_y = 13$, $N_z = 9$.\n- Test Case $2$ (hexagonal cell, skewed and anisotropic):\n  - $a = 0.35$ $\\mathrm{m}$, $c = 0.9$ $\\mathrm{m}$.\n  - $\\mathbf{a}_1 = [\\,a,\\,0,\\,0\\,]$, $\\mathbf{a}_2 = [\\,a/2,\\,a\\sqrt{3}/2,\\,0\\,]$, $\\mathbf{a}_3 = [\\,0,\\,0,\\,c\\,]$.\n  - $\\mathbf{k} = [\\,4.0,\\,-1.5,\\,2.0\\,]$ $\\mathrm{m}^{-1}$.\n  - $N_x = 17$, $N_y = 19$, $N_z = 7$.\n- Test Case $3$ (triclinic cell, strong skew):\n  - $\\mathbf{a}_1 = [\\,0.3,\\,0.02,\\,0.01\\,]$ $\\mathrm{m}$, $\\mathbf{a}_2 = [\\,0.06,\\,0.25,\\,0.04\\,]$ $\\mathrm{m}$, $\\mathbf{a}_3 = [\\,0.03,\\,0.05,\\,0.4\\,]$ $\\mathrm{m}$.\n  - $\\mathbf{k} = [\\,1.0,\\,2.0,\\,-3.0\\,]$ $\\mathrm{m}^{-1}$.\n  - $N_x = 23$, $N_y = 17$, $N_z = 13$.\n\nFinal Output Format:\n- For each test case, produce a list $[\\,\\varepsilon_1,\\,\\varepsilon_2,\\,\\varepsilon_3,\\,\\varepsilon_{\\mathrm{RL}}\\,]$, where $\\varepsilon_{\\mathrm{RL}}$ is the maximum absolute deviation of $\\mathbf{A}^\\top \\mathbf{B}$ from $2\\pi\\,\\mathbf{I}_3$. Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets with no spaces, for example, $[[x_{11},x_{12},x_{13},x_{14}],[x_{21},x_{22},x_{23},x_{24}],[x_{31},x_{32},x_{33},x_{34}]]$, where each $x_{ij}$ is a float computed as described.",
            "solution": "The problem statement is subjected to validation and is found to be valid. It is scientifically grounded in the principles of solid-state physics and computational electromagnetics, specifically concerning Floquet's theorem for periodic systems. The problem is well-posed, with all necessary data and definitions provided for a unique and meaningful solution. The language is objective and the requirements are formalizable into a computational algorithm. Therefore, a reasoned solution is presented below.\n\nThe solution is partitioned into three main logical steps:\n1.  Construction of the reciprocal lattice and verification of the defining relation.\n2.  Generation of the unit cell mesh and efficient calculation of phase terms.\n3.  Computation of the numerical error in the Floquet periodicity condition on the mesh.\n\n### Part 1: Reciprocal Lattice Construction and Verification\n\nThe direct lattice is defined by a set of three linearly independent primitive vectors $\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$, which are given in units of meters. These vectors form the columns of a $3 \\times 3$ matrix $\\mathbf{A}$:\n$$\n\\mathbf{A} = \\begin{bmatrix} \\mathbf{a}_1 & \\mathbf{a}_2 & \\mathbf{a}_3 \\end{bmatrix}\n$$\nThe reciprocal lattice is defined by a corresponding set of primitive vectors $\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3$, which satisfy the biorthogonality condition:\n$$\n\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi\\,\\delta_{ij}\n$$\nwhere $\\delta_{ij}$ is the Kronecker delta, which is $1$ if $i=j$ and $0$ otherwise. We can assemble the reciprocal lattice vectors as columns of another $3 \\times 3$ matrix $\\mathbf{B}$:\n$$\n\\mathbf{B} = \\begin{bmatrix} \\mathbf{b}_1 & \\mathbf{b}_2 & \\mathbf{b}_3 \\end{bmatrix}\n$$\nThe biorthogonality condition can be expressed in matrix form. The dot product $\\mathbf{a}_i \\cdot \\mathbf{b}_j$ is the $(i, j)$-th element of the matrix product $\\mathbf{A}^\\top \\mathbf{B}$. Thus, the condition becomes:\n$$\n\\mathbf{A}^\\top \\mathbf{B} = 2\\pi\\,\\mathbf{I}_3\n$$\nwhere $\\mathbf{I}_3$ is the $3 \\times 3$ identity matrix.\n\nTo find the reciprocal lattice matrix $\\mathbf{B}$, we can solve for it by pre-multiplying by the inverse of $\\mathbf{A}^\\top$:\n$$\n\\mathbf{B} = (\\mathbf{A}^\\top)^{-1} (2\\pi\\,\\mathbf{I}_3) = 2\\pi\\,(\\mathbf{A}^\\top)^{-1}\n$$\nUsing the property that the inverse of a transpose is the transpose of the inverse, i.e., $(\\mathbf{M}^\\top)^{-1} = (\\mathbf{M}^{-1})^\\top$ for any invertible matrix $\\mathbf{M}$, we obtain the computational formula for $\\mathbf{B}$:\n$$\n\\mathbf{B} = 2\\pi\\,(\\mathbf{A}^{-1})^\\top\n$$\nThe algorithm for this part is:\n1.  Construct the matrix $\\mathbf{A}$ from the given vectors $\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$.\n2.  Compute the inverse matrix $\\mathbf{A}^{-1}$.\n3.  Compute the transpose of the inverse, $(\\mathbf{A}^{-1})^\\top$.\n4.  Multiply by the scalar $2\\pi$ to obtain the matrix $\\mathbf{B}$. The columns of $\\mathbf{B}$ are the desired reciprocal lattice vectors $\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3$.\n\nThe first required output, $\\varepsilon_{\\mathrm{RL}}$, is the maximum absolute deviation of the numerically computed matrix product $\\mathbf{A}^\\top \\mathbf{B}$ from the theoretical ideal $2\\pi\\,\\mathbf{I}_3$. This quantifies the error from floating-point arithmetic in the matrix inversion and multiplication operations.\n$$\n\\varepsilon_{\\mathrm{RL}} = \\max_{i,j} \\left| (\\mathbf{A}^\\top \\mathbf{B})_{ij} - (2\\pi\\,\\mathbf{I}_3)_{ij} \\right|\n$$\n\n### Part 2: Unit Cell Mesh and Phase Calculation\n\nThe problem requires sampling a scalar field within the unit cell defined by the primitives $\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$. Any position vector $\\mathbf{r}$ inside the cell can be written as a linear combination of these primitives using fractional coordinates $(u_1, u_2, u_3)$:\n$$\n\\mathbf{r} = u_1 \\mathbf{a}_1 + u_2 \\mathbf{a}_2 + u_3 \\mathbf{a}_3\n$$\nwhere $u_i \\in [0, 1)$. The problem specifies a discrete mesh over these fractional coordinates:\n$$\nu_1 \\in \\{0, 1/N_x, \\dots, (N_x - 1)/N_x\\} \\\\\nu_2 \\in \\{0, 1/N_y, \\dots, (N_y - 1)/N_y\\} \\\\\nu_3 \\in \\{0, 1/N_z, \\dots, (N_z - 1)/N_z\\}\n$$\nThe field is a plane wave $E(\\mathbf{r}) = \\exp(i\\,\\mathbf{k} \\cdot \\mathbf{r})$, where $\\mathbf{k}$ is the given Bloch wavevector. The phase term $\\mathbf{k} \\cdot \\mathbf{r}$ is required for all mesh points. A direct computation for each of the $N_x N_y N_z$ points would be inefficient. We can exploit the linearity of the dot product:\n$$\n\\mathbf{k} \\cdot \\mathbf{r} = \\mathbf{k} \\cdot (u_1 \\mathbf{a}_1 + u_2 \\mathbf{a}_2 + u_3 \\mathbf{a}_3) = u_1 (\\mathbf{k} \\cdot \\mathbf{a}_1) + u_2 (\\mathbf{k} \\cdot \\mathbf{a}_2) + u_3 (\\mathbf{k} \\cdot \\mathbf{a}_3)\n$$\nLet us pre-compute the constant phase factors $c_i = \\mathbf{k} \\cdot \\mathbf{a}_i$ for $i \\in \\{1, 2, 3\\}$. These are dimensionless quantities (radians). Then, for any point $(u_1, u_2, u_3)$ on the mesh, the phase is simply:\n$$\n\\mathbf{k} \\cdot \\mathbf{r} = u_1 c_1 + u_2 c_2 + u_3 c_3\n$$\nThis formulation is highly efficient for vectorized computation, as it allows constructing the full 3D array of phase values on the mesh from outer products of 1D coordinate arrays and the constants $c_1, c_2, c_3$.\n\n### Part 3: Floquet Condition Error\n\nThe Floquet periodic boundary condition for a Bloch wave $E(\\mathbf{r})$ is $E(\\mathbf{r} + \\mathbf{a}_i) = E(\\mathbf{r}) \\exp(i\\,\\mathbf{k} \\cdot \\mathbf{a}_i)$. For the specific plane wave field $E(\\mathbf{r}) = \\exp(i\\,\\mathbf{k} \\cdot \\mathbf{r})$, this condition becomes an identity involving complex exponentials:\n$$\n\\exp(i\\,\\mathbf{k} \\cdot (\\mathbf{r} + \\mathbf{a}_i)) \\stackrel{?}{=} \\exp(i\\,\\mathbf{k} \\cdot \\mathbf{r}) \\exp(i\\,\\mathbf{k} \\cdot \\mathbf{a}_i)\n$$\nThe left-hand side (LHS) is $\\exp(i(\\mathbf{k} \\cdot \\mathbf{r} + \\mathbf{k} \\cdot \\mathbf{a}_i))$. Due to the fundamental property of the exponential function, $\\exp(z_1+z_2) = \\exp(z_1)\\exp(z_2)$, the LHS and right-hand side (RHS) are mathematically identical. The task is to compute the numerical discrepancy arising from floating-point evaluation of this identity on every point $\\mathbf{r}$ of the discrete mesh.\n\nFor each lattice direction $i \\in \\{1, 2, 3\\}$, we must calculate the maximum absolute error $\\varepsilon_i$:\n$$\n\\varepsilon_i = \\max_{\\mathbf{r}\\,\\text{on the mesh}} \\left| \\exp(i\\,\\mathbf{k}\\cdot(\\mathbf{r} + \\mathbf{a}_i)) - \\exp(i\\,\\mathbf{k}\\cdot \\mathbf{r})\\exp(i\\,\\mathbf{k}\\cdot \\mathbf{a}_i) \\right|\n$$\nUsing the efficient representation from Part 2, where $\\phi(\\mathbf{r}) = \\mathbf{k} \\cdot \\mathbf{r}$ and $c_i = \\mathbf{k} \\cdot \\mathbf{a}_i$:\n$$\n\\varepsilon_i = \\max_{\\phi} \\left| \\exp(i(\\phi + c_i)) - \\exp(i\\phi)\\exp(ic_i) \\right|\n$$\nwhere the maximum is taken over all phase values $\\phi$ corresponding to the mesh points $\\mathbf{r}$. This calculation is performed for each $i \\in \\{1, 2, 3\\}$ to obtain the errors $\\varepsilon_1, \\varepsilon_2, \\varepsilon_3$.\n\nIn summary, for each test case, the algorithm proceeds as follows:\n1.  Form matrix $\\mathbf{A}$ from primitives $\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$.\n2.  Compute matrix $\\mathbf{B} = 2\\pi\\,(\\mathbf{A}^{-1})^\\top$.\n3.  Calculate $\\varepsilon_{\\mathrm{RL}} = \\max|\\mathbf{A}^\\top \\mathbf{B} - 2\\pi\\,\\mathbf{I}_3|$.\n4.  Compute the phase constants $c_i = \\mathbf{k} \\cdot \\mathbf{a}_i$ for $i=1, 2, 3$.\n5.  Generate 1D arrays of fractional coordinates $u_1, u_2, u_3$.\n6.  Construct the 3D array of phase values $\\phi = \\mathbf{k} \\cdot \\mathbf{r}$ over the mesh.\n7.  For each $i \\in \\{1, 2, 3\\}$, compute the 3D array of local errors $|\\exp(i(\\phi + c_i)) - \\exp(i\\phi)\\exp(ic_i)|$ and find its maximum value, $\\varepsilon_i$.\n8.  Collect and report the four computed errors $[\\varepsilon_1, \\varepsilon_2, \\varepsilon_3, \\varepsilon_{\\mathrm{RL}}]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all specified test cases, calculating reciprocal\n    lattice vectors and verifying Floquet periodic boundary constraints.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: orthorhombic cell\n        {\n            \"a_vectors\": np.array([\n                [0.4, 0.0, 0.0],\n                [0.0, 0.6, 0.0],\n                [0.0, 0.0, 0.5]\n            ]),\n            \"k_vector\": np.array([5.0, 8.0, 3.0]),\n            \"N_points\": (11, 13, 9)\n        },\n        # Test Case 2: hexagonal cell\n        {\n            \"params\": {\"a\": 0.35, \"c\": 0.9},\n            \"k_vector\": np.array([4.0, -1.5, 2.0]),\n            \"N_points\": (17, 19, 7)\n        },\n        # Test Case 3: triclinic cell\n        {\n            \"a_vectors\": np.array([\n                [0.3, 0.02, 0.01],\n                [0.06, 0.25, 0.04],\n                [0.03, 0.05, 0.4]\n            ]),\n            \"k_vector\": np.array([1.0, 2.0, -3.0]),\n            \"N_points\": (23, 17, 13)\n        }\n    ]\n    \n    # Process hexagonal cell parameters\n    a_hex = test_cases[1][\"params\"][\"a\"]\n    c_hex = test_cases[1][\"params\"][\"c\"]\n    test_cases[1][\"a_vectors\"] = np.array([\n        [a_hex, 0.0, 0.0],\n        [a_hex / 2.0, a_hex * np.sqrt(3.0) / 2.0, 0.0],\n        [0.0, 0.0, c_hex]\n    ])\n\n    results = []\n    for case in test_cases:\n        a_vectors = case[\"a_vectors\"]\n        k = case[\"k_vector\"]\n        Nx, Ny, Nz = case[\"N_points\"]\n        \n        a1, a2, a3 = a_vectors[0, :], a_vectors[1, :], a_vectors[2, :]\n        \n        # The problem statement implies a_i are columns of A, but standard\n        # crystallography often has them as rows. Here we follow the problem's\n        # matrix relation A^T B = 2pi I, which implies a_i form rows of A^T,\n        # so they must form columns of A.\n        # A = [a1, a2, a3] as columns\n        A = np.array([a1, a2, a3]).T\n        \n        # 1. Construct reciprocal lattice vectors and compute deviation epsilon_RL\n        # From A^T B = 2pi I, we get B = 2pi * (A^T)^-1 = 2pi * (A^-1)^T\n        try:\n            A_inv = np.linalg.inv(A)\n            B = 2.0 * np.pi * A_inv.T\n        except np.linalg.LinAlgError:\n            results.append([\"Error: singular matrix A\"])\n            continue\n\n        # Verify the relation and compute the error\n        identity_check_matrix = A.T @ B\n        error_matrix = identity_check_matrix - 2.0 * np.pi * np.eye(3)\n        epsilon_rl = np.max(np.abs(error_matrix))\n\n        # 2. Sample unit cell and define field\n        # Phase constants c_i = k . a_i\n        c1 = np.dot(k, a1)\n        c2 = np.dot(k, a2)\n        c3 = np.dot(k, a3)\n\n        # Fractional coordinates\n        u1_vals = np.linspace(0.0, (Nx-1)/Nx, Nx)\n        u2_vals = np.linspace(0.0, (Ny-1)/Ny, Ny)\n        u3_vals = np.linspace(0.0, (Nz-1)/Nz, Nz)\n\n        # Meshgrid for vectorized computation of phases\n        # Use 'ij' indexing to match loop order (i for u1, j for u2, k for u3)\n        U1, U2, U3 = np.meshgrid(u1_vals, u2_vals, u3_vals, indexing='ij')\n\n        # Phase on the mesh: k.r = u1*c1 + u2*c2 + u3*c3\n        phi_mesh = c1 * U1 + c2 * U2 + c3 * U3\n        \n        # 3. Compute Floquet condition mismatch errors epsilon_i\n        epsilons = []\n        phase_constants = [c1, c2, c3]\n        for i in range(3):\n            ci = phase_constants[i]\n            \n            # LHS: exp(i*k.(r+a_i)) = exp(i*(phi + c_i))\n            lhs = np.exp(1j * (phi_mesh + ci))\n            \n            # RHS: exp(i*k.r) * exp(i*k.a_i) = exp(i*phi) * exp(i*c_i)\n            rhs = np.exp(1j * phi_mesh) * np.exp(1j * ci)\n            \n            # Mismatch error\n            mismatch = np.max(np.abs(lhs - rhs))\n            epsilons.append(mismatch)\n\n        case_result = epsilons + [epsilon_rl]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    case_results_str = []\n    for res in results:\n        case_results_str.append(f\"[{','.join(f'{x:.17g}' for x in res)}]\")\n    print(f\"[{','.join(case_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A common and powerful method for simulating isolated features, such as defects or cavities, is to place them within a large \"supercell\" and apply periodic boundary conditions. This practice explores the primary limitation of this approach: supercell aliasing, where the artificial periodic replication of the defect introduces spurious interactions and Bragg scattering. By deriving and quantifying this effect for a model Gaussian defect, you will gain a deeper understanding of how the supercell approximation impacts simulation accuracy and learn to critically evaluate the choice of supercell size in your own models .",
            "id": "3308775",
            "problem": "Consider one-dimensional time-harmonic electromagnetic waves governed by the scalar Helmholtz equation in a homogeneous background with a weak, localized defect. The governing equation for the electric field $E(x)$ in dimensionless units is\n$$\n\\frac{d^2 E}{dx^2} + \\omega^2 \\,\\epsilon(x)\\, E = 0,\n$$\nwhere the background permittivity is $\\epsilon_b = 1$, the wave speed is normalized to $c = 1$, and the unperturbed dispersion relation is $\\omega = |k|$ for a plane wave $\\exp(i k x)$. The defect is modeled as a weak perturbation of the permittivity,\n$$\n\\epsilon(x) = 1 + \\eta\\, u(x),\n$$\nwith $0 < \\eta \\ll 1$ and a bounded, localized shape $u(x)$. In a numerical supercell approach with Floquet's theorem and Periodic Boundary Conditions (PBC), the defect is periodically replicated with supercell length $L = N a$, where $a$ is a base cell length and $N$ is the number of base cells in the supercell. The resulting periodic perturbation has a fundamental reciprocal lattice vector $G = \\frac{2\\pi}{L}$ and Fourier coefficients\n$$\nU_m = \\frac{1}{L}\\int_{0}^{L} u(x)\\, e^{-i m G x}\\, dx,\n$$\nwith $\\quad m \\in \\mathbb{Z}$. In the nearly-free-wave approximation, spurious Bragg coupling arises near the first Brillouin-zone boundary at $k \\approx G/2$, causing a frequency band splitting driven by the coupling between $\\exp(i k x)$ and $\\exp(i (k - G) x)$ mediated by the $m=1$ harmonic of the defect’s periodic replication. This effect constitutes supercell aliasing error for defect modes because a truly isolated defect should not induce such periodic Bragg scattering.\n\nAssume a Gaussian defect shape,\n$$\nu(x) = \\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right),\n$$\nwhere $\\sigma$ is the width of the defect and all spatial quantities are expressed in units of $a$, so $a = 1$ is permissible without loss of generality. Work in the limit of weak perturbations appropriate for $0 < \\eta \\ll 1$. Your task is to derive from first principles the leading-order expression for the normalized spurious Bragg-induced frequency splitting at the first Brillouin-zone boundary, defined as the ratio of the gap magnitude to the unperturbed frequency at $k = G/2$. Then, implement a program that evaluates this aliasing error metric for given parameter sets by exploiting the analytical Fourier transform of the Gaussian and the nearly-free-wave two-mode coupling at $k = G/2$.\n\nAll quantities are dimensionless, and the final answers should be dimensionless real numbers. Your program should compute the aliasing error for the following test suite:\n- Case $1$: $a = 1$, $N = 8$, $\\sigma = 0.15$, $\\eta = 0.02$.\n- Case $2$: $a = 1$, $N = 32$, $\\sigma = 0.15$, $\\eta = 0.02$.\n- Case $3$: $a = 1$, $N = 1$, $\\sigma = 0.15$, $\\eta = 0.02$.\n- Case $4$: $a = 1$, $N = 8$, $\\sigma = 0.50$, $\\eta = 0.02$.\n- Case $5$: $a = 1$, $N = 8$, $\\sigma = 0.15$, $\\eta = 0.00$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must be rounded to $8$ decimal places. For example, the output format should be\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5].\n$$",
            "solution": "The problem statement is scientifically sound, self-contained, and well-posed. It describes a canonical problem in computational physics, specifically the analysis of artificial periodicity effects when using a supercell method to model localized defects. The physical principles invoked, such as the Helmholtz equation, Floquet's theorem, Bragg scattering, and the nearly-free-wave approximation, are all cornerstones of wave physics and solid-state theory. The parameters provided are consistent and sufficient for a unique solution. Therefore, the problem is deemed valid, and I shall proceed with a rigorous derivation followed by a numerical implementation.\n\nThe task is to derive the leading-order expression for the normalized frequency splitting at the first Brillouin-zone boundary for a $1$D Helmholtz equation with a periodic perturbation. The governing equation is:\n$$ \\frac{d^2 E}{dx^2} + \\omega^2 \\epsilon(x) E = 0 $$\nIn the supercell model, the permittivity $\\epsilon(x) = 1 + \\eta\\, u_L(x)$ is periodic with period $L=Na$, where $u_L(x)$ is the periodic replication of a single Gaussian defect $u(x) = \\exp(-x^2/(2\\sigma^2))$. The parameter $\\eta$ is a small-valued constant, $0 < \\eta \\ll 1$. We can rewrite the governing equation as:\n$$ \\frac{d^2 E}{dx^2} + \\omega^2 E = -\\omega^2 \\eta\\, u_L(x) E $$\nThe term on the right-hand side acts as a perturbation. In the absence of this perturbation ($\\eta=0$), the solutions are plane waves $E(x) = \\exp(ikx)$ with the dispersion relation $\\omega = |k|$, since the background wave speed is $c=1$.\n\nWe are interested in the behavior near the first Brillouin-zone boundary, where the wave number $k$ is close to $G/2$, with $G = 2\\pi/L$ being the fundamental reciprocal lattice vector. At exactly $k=G/2$, the unperturbed forward-propagating wave $\\exp(i(G/2)x)$ and the first-order Bragg-scattered wave $\\exp(i(k-G)x) = \\exp(i(G/2-G)x) = \\exp(-i(G/2)x)$ are degenerate. Their unperturbed frequency is $\\omega_0 = |k| = G/2$.\n\nThe periodic perturbation $u_L(x)$ can be expanded in a Fourier series:\n$$ u_L(x) = \\sum_{m=-\\infty}^{\\infty} U_m e^{imGx} $$\nwhere the Fourier coefficients $U_m$ are given by $U_m = \\frac{1}{L}\\int_0^L u_L(x) e^{-imGx} dx$.\nThe perturbation couples the degenerate modes. According to the nearly-free-wave approximation, we seek a solution as a superposition of these two dominant modes:\n$$ E(x) = c_0 e^{i(G/2)x} + c_1 e^{-i(G/2)x} $$\nSubstituting this two-mode ansatz into the governing equation:\n$$ -(G/2)^2 (c_0 e^{i(G/2)x} + c_1 e^{-i(G/2)x}) + \\omega^2 (c_0 e^{i(G/2)x} + c_1 e^{-i(G/2)x}) = -\\omega^2 \\eta \\left(\\sum_m U_m e^{imGx}\\right) (c_0 e^{i(G/2)x} + c_1 e^{-i(G/2)x}) $$\nLet $\\omega_0 = G/2$. The equation becomes:\n$$ (\\omega^2 - \\omega_0^2) (c_0 e^{i\\omega_0 x} + c_1 e^{-i\\omega_0 x}) = -\\omega^2 \\eta \\sum_m U_m (c_0 e^{i(m+1)\\omega_0 x} + c_1 e^{i(m-1)\\omega_0 x}) $$\nTo obtain a system of equations for the coefficients $c_0$ and $c_1$, we project the equation onto the basis functions $e^{i\\omega_0 x}$ and $e^{-i\\omega_0 x}$. This is done by multiplying by $e^{-i\\omega_0 x}$ (for the first equation) or $e^{i\\omega_0 x}$ (for the second equation) and integrating over one period $L$. Orthogonality of the complex exponentials, $\\frac{1}{L}\\int_0^L e^{ij\\omega_0 x} e^{-il\\omega_0 x} dx = \\delta_{jl}$, simplifies the sums.\n\nFor the first equation (projection onto $e^{i\\omega_0 x}$):\n$$ (\\omega^2 - \\omega_0^2) c_0 = -\\omega^2 \\eta (U_0 c_0 + U_1 c_1) $$\nFor the second equation (projection onto $e^{-i\\omega_0 x}$):\n$$ (\\omega^2 - \\omega_0^2) c_1 = -\\omega^2 \\eta (U_{-1} c_0 + U_0 c_1) $$\nThis can be written as a $2 \\times 2$ homogeneous linear system for $(c_0, c_1)$:\n$$ \\begin{pmatrix} \\omega^2(1+\\eta U_0) - \\omega_0^2 & \\omega^2 \\eta U_1 \\\\ \\omega^2 \\eta U_{-1} & \\omega^2(1+\\eta U_0) - \\omega_0^2 \\end{pmatrix} \\begin{pmatrix} c_0 \\\\ c_1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} $$\nFor a non-trivial solution, the determinant of the matrix must be zero. The defect shape $u(x)$ is real and even, so its Fourier coefficients are real and even, i.e., $U_m = U_{-m} \\in \\mathbb{R}$.\n$$ (\\omega^2(1+\\eta U_0) - \\omega_0^2)^2 - (\\omega^2 \\eta U_1)^2 = 0 $$\n$$ \\omega^2(1+\\eta U_0) - \\omega_0^2 = \\pm \\omega^2 \\eta U_1 $$\nThis yields two solutions for $\\omega^2$:\n$$ \\omega^2(1 + \\eta U_0 \\mp \\eta U_1) = \\omega_0^2 \\implies \\omega^2_\\pm = \\frac{\\omega_0^2}{1 + \\eta(U_0 \\mp U_1)} $$\nThe frequencies of the upper ($u$) and lower ($l$) band edges are thus $\\omega_u = \\omega_+$ and $\\omega_l = \\omega_-$.\n$$ \\omega_u = \\frac{\\omega_0}{\\sqrt{1 + \\eta(U_0 - U_1)}} \\quad , \\quad \\omega_l = \\frac{\\omega_0}{\\sqrt{1 + \\eta(U_0 + U_1)}} $$\nThe frequency splitting is $\\Delta\\omega = \\omega_u - \\omega_l$. The normalized splitting is $\\Delta\\omega / \\omega_0$:\n$$ \\frac{\\Delta\\omega}{\\omega_0} = \\frac{1}{\\sqrt{1 + \\eta(U_0 - U_1)}} - \\frac{1}{\\sqrt{1 + \\eta(U_0 + U_1)}} $$\nSince we are interested in the leading-order expression for $\\eta \\ll 1$, we use the Taylor expansion $(1+x)^{-1/2} \\approx 1-x/2$.\n$$ \\frac{\\Delta\\omega}{\\omega_0} \\approx \\left(1 - \\frac{\\eta}{2}(U_0 - U_1)\\right) - \\left(1 - \\frac{\\eta}{2}(U_0 + U_1)\\right) = -\\frac{\\eta}{2}U_0 + \\frac{\\eta}{2}U_1 + \\frac{\\eta}{2}U_0 + \\frac{\\eta}{2}U_1 = \\eta U_1 $$\nSince $U_1$ can be negative for a general shape, the splitting magnitude is given by $\\eta|U_1|$. For the specified Gaussian, $U_1 > 0$.\n\nThe final step is to calculate the Fourier coefficient $U_1$. The coefficient for the periodic array of defects, $u_L(x) = \\sum_j u(x-jL)$, is:\n$$ U_m = \\frac{1}{L} \\int_{-L/2}^{L/2} \\left( \\sum_{j=-\\infty}^{\\infty} u(x-jL) \\right) e^{-imGx} dx $$\nThis can be shown to be equivalent to $1/L$ times the Fourier transform of a single defect shape $u(x)$, evaluated at the reciprocal lattice points $k_m=mG$. This approximation is excellent when the defect is well-localized within the supercell ($\\sigma \\ll L$).\n$$ U_m = \\frac{1}{L} \\int_{-\\infty}^{\\infty} u(x) e^{-imGx} dx = \\frac{1}{L} \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) e^{-imGx} dx $$\nThe integral is the standard Fourier transform of a Gaussian function. The transform of $\\exp(-ax^2)$ is $\\sqrt{\\pi/a} \\exp(-k^2/(4a))$. Here, $a = 1/(2\\sigma^2)$ and $k=mG$.\n$$ \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) e^{-imGx} dx = \\sqrt{2\\pi\\sigma^2} \\exp\\left(-\\frac{(mG)^2 \\sigma^2}{2}\\right) $$\nTherefore, the Fourier coefficient is:\n$$ U_m = \\frac{\\sqrt{2\\pi}\\sigma}{L} \\exp\\left(-\\frac{m^2 G^2 \\sigma^2}{2}\\right) $$\nSubstituting $m=1$ and $G=2\\pi/L$:\n$$ U_1 = \\frac{\\sqrt{2\\pi}\\sigma}{L} \\exp\\left(-\\frac{(2\\pi/L)^2 \\sigma^2}{2}\\right) = \\frac{\\sqrt{2\\pi}\\sigma}{L} \\exp\\left(-\\frac{2\\pi^2\\sigma^2}{L^2}\\right) $$\nThe final expression for the normalized aliasing error is:\n$$ \\text{Error} = \\eta U_1 = \\eta \\frac{\\sqrt{2\\pi}\\sigma}{L} \\exp\\left(-\\frac{2\\pi^2\\sigma^2}{L^2}\\right) $$\nThis is the formula to be implemented. We set the base cell length $a=1$, so the supercell length is $L=N$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the normalized spurious Bragg-induced frequency splitting for a\n    1D Helmholtz equation with a periodic Gaussian permittivity defect.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, N, sigma, eta)\n        (1, 8, 0.15, 0.02),\n        (1, 32, 0.15, 0.02),\n        (1, 1, 0.15, 0.02),\n        (1, 8, 0.50, 0.02),\n        (1, 8, 0.15, 0.00),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, N, sigma, eta = case\n\n        # The normalized splitting is given by eta * U_1, where U_1 is the\n        # first Fourier coefficient of the periodic defect potential.\n        # If eta is 0, the perturbation is zero, so the splitting is zero.\n        if eta == 0:\n            results.append(f\"{0.0:.8f}\")\n            continue\n\n        # Supercell length L = N * a\n        L = N * a\n\n        # The Fourier coefficient U_1 is derived from the analytical\n        # Fourier transform of a single Gaussian function.\n        # U_1 = (sqrt(2*pi)*sigma / L) * exp(-2*pi^2*sigma^2 / L^2)\n        \n        prefactor = (np.sqrt(2 * np.pi) * sigma) / L\n        exponent_arg = -2 * np.pi**2 * sigma**2 / L**2\n        exp_term = np.exp(exponent_arg)\n        \n        U1 = prefactor * exp_term\n\n        # The aliasing error metric is the normalized frequency splitting\n        aliasing_error = eta * U1\n        \n        results.append(f\"{aliasing_error:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While eigenmode solvers directly compute the band structure of a periodic system, an alternative and highly flexible approach is to extract this information from the system's response to a frequency-swept external source. This exercise introduces a sophisticated workflow that mirrors advanced computational practices, using harmonic inversion to recover the band structure from synthesized simulation data. By applying a linear prediction method to a time-domain signal generated from the frequency response, you will learn how to identify the system's underlying resonant frequencies, a powerful technique for analyzing complex electromagnetic systems .",
            "id": "3308797",
            "problem": "Consider the frequency-domain response of the cell-averaged electric field in a one-dimensional periodic electromagnetic structure of unit-cell length $a$, subject to Bloch-periodic boundary conditions. For a given Bloch wavevector $\\mathbf{k}$ (in one dimension, $\\mathbf{k}=k\\hat{x}$), the forced frequency-domain solution under a spatially periodic source with Bloch phase satisfies Floquet's theorem: any field can be represented as $E_{k}(x)=u_{k}(x)\\mathrm{e}^{\\mathrm{i}kx}$ where $u_{k}(x)$ is periodic with the unit-cell. In the frequency domain, the cell-averaged field $\\overline{E}(\\omega;k)$ exhibits resonances at the eigenfrequencies $\\,\\omega_{n}(k)\\,$ of the Bloch modes, with each resonance broadened by material loss or radiation represented as a small damping rate.\n\nStarting from Maxwell's equations in the frequency domain, the structure is modeled by the linear operator equation for the field $E$ under a source $J$, $\\nabla\\times\\mu^{-1}\\nabla\\times E-\\omega^{2}\\varepsilon E=J$, and the Floquet condition $E(x+a)=E(x)\\mathrm{e}^{\\mathrm{i}ka}$. By Floquet's theorem, the spectrum of the operator for each $k$ yields a discrete set of complex poles $\\Omega_{n}(k)=\\omega_{n}(k)-\\mathrm{i}\\gamma_{n}$ in the resolvent of the operator, which implies that the scalar cell-averaged frequency response can be represented as a rational function of $\\omega$ with simple poles,\n$$\n\\overline{E}(\\omega;k)=\\sum_{n}\\frac{C_{n}(k)}{\\omega-\\Omega_{n}(k)}.\n$$\nHere $C_{n}(k)$ encodes the overlap of the source with the $n$th Bloch mode and $\\gamma_{n}>0$ is the damping. The time-domain impulse response $h(t;k)$ obtained by inverse Fourier transformation of $\\overline{E}(\\omega;k)$ is then a finite sum of decaying complex exponentials for $t>0$,\n$$\nh(t;k)=\\sum_{n}A_{n}(k)\\,\\mathrm{e}^{\\mathrm{i}\\Omega_{n}(k)t},\n$$\nwhere $A_{n}(k)$ is a constant related to $C_{n}(k)$ by complex residue calculus. Harmonic inversion methods such as Prony's method can recover the complex frequencies $\\Omega_{n}(k)$ from uniformly sampled time-domain data $h(t_{m};k)$, and thus the band structure $\\omega_{n}(k)=\\mathrm{Re}\\,\\Omega_{n}(k)$.\n\nIn this problem, you will recover an approximate band structure from synthetic frequency-domain driven simulations obeying Bloch-periodic forcing. For numerical tractability and clarity, assume a two-band model ($n\\in\\{1,2\\}$) with dispersion relations that emulate a tight-binding-like coupling in a one-dimensional periodic photonic medium:\n$$\n\\omega_{1}(k)=\\sqrt{\\omega_{01}^{2}+4J_{1}\\sin^{2}\\!\\left(\\frac{ka}{2}\\right)},\\qquad\n\\omega_{2}(k)=\\sqrt{\\omega_{02}^{2}+4J_{2}\\sin^{2}\\!\\left(\\frac{ka}{2}\\right)}.\n$$\nAssume small constant damping rates $\\gamma_{1}>0$ and $\\gamma_{2}>0$ with complex pole locations $\\Omega_{1}(k)=\\omega_{1}(k)-\\mathrm{i}\\gamma_{1}$ and $\\Omega_{2}(k)=\\omega_{2}(k)-\\mathrm{i}\\gamma_{2}$. Let the frequency-domain driven response for the cell-averaged field be\n$$\n\\overline{E}(\\omega;k)=\\frac{C_{1}(k)}{\\omega-\\Omega_{1}(k)}+\\frac{C_{2}(k)}{\\omega-\\Omega_{2}(k)},\n$$\nwith $C_{1}(k)=1+0.4\\cos(ka)$ and $C_{2}(k)=0.7+0.3\\sin(ka)$.\n\nYour task is to:\n- Construct the synthetic frequency-domain data by evaluating $\\overline{E}(\\omega;k)$ on a uniform angular-frequency grid $\\omega\\in[-W,W]$ and numerically approximate the time-domain impulse response $h(t;k)$ via the discrete inverse Fourier integral\n$$\nh(t;k)\\approx\\frac{\\Delta\\omega}{2\\pi}\\sum_{m=0}^{M-1}\\overline{E}(\\omega_{m};k)\\,\\mathrm{e}^{\\mathrm{i}\\omega_{m}t}.\n$$\nHere $\\omega_{m}$ are uniformly spaced samples, $\\Delta\\omega$ is the grid spacing, and $M$ is the number of samples. Use $t_{n}=n\\Delta t$ for $n=0,1,\\ldots,N-1$ to form a uniform time sample.\n- Apply harmonic inversion using a linear prediction (Prony) method of order $P=2$ to the time samples $h(t_{n};k)$ to estimate the two complex frequencies $\\Omega_{1}(k)$ and $\\Omega_{2}(k)$, then report $\\omega_{1}(k)=\\mathrm{Re}\\,\\Omega_{1}(k)$ and $\\omega_{2}(k)=\\mathrm{Re}\\,\\Omega_{2}(k)$.\n- Sort the two recovered values for each $k$ in ascending order and round to six decimal places.\n\nUse the following parameter values, all expressed in angular frequency units where applicable:\n- Unit-cell length $a=1$.\n- Band parameters $\\omega_{01}=10$, $\\omega_{02}=14$, $J_{1}=3$, $J_{2}=1.5$.\n- Damping rates $\\gamma_{1}=0.1$, $\\gamma_{2}=0.08$.\n- Frequency grid half-width $W=40$ with $M=4096$ uniformly spaced samples from $-W$ to $W$.\n- Time sampling step $\\Delta t=0.05$ and $N=128$ samples (i.e., $t_{n}=n\\Delta t$).\n- Linear prediction order $P=2$.\n\nTest suite:\n- Case $1$: $k=0$.\n- Case $2$: $k=\\pi/a$.\n- Case $3$: $k=(\\pi/2)/a$.\n\nAnswer specification:\n- For each test case, your program must return a list of the two recovered angular frequencies $\\left[\\omega_{1}(k),\\omega_{2}(k)\\right]$ in $\\mathrm{rad/s}$, sorted in ascending order and rounded to six decimal places.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, with each test case represented by its own bracketed list and no spaces, for example, $\\left[\\left[\\omega_{1}(k_{1}),\\omega_{2}(k_{1})\\right],\\left[\\omega_{1}(k_{2}),\\omega_{2}(k_{2})\\right],\\left[\\omega_{1}(k_{3}),\\omega_{2}(k_{3})\\right]\\right]$.\n\nAll angular frequencies must be reported in $\\mathrm{rad/s}$, rounded to six decimal places. Angles such as $ka$ must be evaluated in radians. Ensure scientific realism by using the provided parameters and carrying out the specified numerical approximations and harmonic inversion. No external data is permitted; the program must be self-contained and must compute the synthetic frequency-domain response before performing the inversion.",
            "solution": "### Problem Validation\n\nThe problem is subjected to a rigorous validation process before a solution is attempted.\n\n#### Step 1: Extract Givens\n\nThe following data and definitions are extracted verbatim from the problem statement:\n- **Physical Model**: One-dimensional periodic electromagnetic structure.\n- **Unit-cell length**: $a$.\n- **Field Representation**: Floquet's theorem applies, $E_{k}(x)=u_{k}(x)\\mathrm{e}^{\\mathrm{i}kx}$, where $u_{k}(x)$ is periodic with period $a$.\n- **Frequency Response Model**: The cell-averaged frequency response $\\overline{E}(\\omega;k)$ is a rational function with simple poles $\\Omega_{n}(k)=\\omega_{n}(k)-\\mathrm{i}\\gamma_{n}$:\n$$\n\\overline{E}(\\omega;k)=\\sum_{n}\\frac{C_{n}(k)}{\\omega-\\Omega_{n}(k)}\n$$\n- **Time Response Model**: The time-domain impulse response $h(t;k)$ for $t>0$ is:\n$$\nh(t;k)=\\sum_{n}A_{n}(k)\\,\\mathrm{e}^{\\mathrm{i}\\Omega_{n}(k)t}\n$$\n- **Specific Two-Band Model ($n\\in\\{1,2\\}$)**:\n    - Dispersion relations:\n        $$\n        \\omega_{1}(k)=\\sqrt{\\omega_{01}^{2}+4J_{1}\\sin^{2}\\!\\left(\\frac{ka}{2}\\right)},\\qquad\n        \\omega_{2}(k)=\\sqrt{\\omega_{02}^{2}+4J_{2}\\sin^{2}\\!\\left(\\frac{ka}{2}\\right)}\n        $$\n    - Complex poles: $\\Omega_{1}(k)=\\omega_{1}(k)-\\mathrm{i}\\gamma_{1}$ and $\\Omega_{2}(k)=\\omega_{2}(k)-\\mathrm{i}\\gamma_{2}$.\n    - Frequency-domain response:\n        $$\n        \\overline{E}(\\omega;k)=\\frac{C_{1}(k)}{\\omega-\\Omega_{1}(k)}+\\frac{C_{2}(k)}{\\omega-\\Omega_{2}(k)}\n        $$\n    - Mode-source overlap coefficients: $C_{1}(k)=1+0.4\\cos(ka)$ and $C_{2}(k)=0.7+0.3\\sin(ka)$.\n- **Numerical Impulse Response Calculation**:\n    $$\n    h(t;k)\\approx\\frac{\\Delta\\omega}{2\\pi}\\sum_{m=0}^{M-1}\\overline{E}(\\omega_{m};k)\\,\\mathrm{e}^{\\mathrm{i}\\omega_{m}t}\n    $$\n- **Numerical Parameters**:\n    - Unit-cell length: $a=1$.\n    - Band parameters: $\\omega_{01}=10$, $\\omega_{02}=14$, $J_{1}=3$, $J_{2}=1.5$.\n    - Damping rates: $\\gamma_{1}=0.1$, $\\gamma_{2}=0.08$.\n    - Frequency grid: half-width $W=40$, $M=4096$ samples from $-W$ to $W$.\n    - Time sampling: step $\\Delta t=0.05$, $N=128$ samples.\n    - Linear prediction order: $P=2$.\n- **Test Cases**:\n    - Case 1: $k=0$.\n    - Case 2: $k=\\pi/a$.\n    - Case 3: $k=(\\pi/2)/a$.\n- **Output Specification**: For each case, a sorted list of two angular frequencies $[\\omega_{1}(k),\\omega_{2}(k)]$ rounded to six decimal places. Final output is a list of these lists.\n\n#### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded**: The problem is well-grounded in the principles of computational electromagnetics and signal processing. Floquet-Bloch theory, frequency-domain analysis of linear systems, and harmonic inversion (Prony's method) are all standard and valid concepts. The physical model is a simplified but representative case study.\n- **Well-Posed**: The problem is well-posed. It provides a complete set of parameters and a clear algorithmic path to a unique solution. The numerical parameters ($M$, $N$, $\\Delta t$, $W$) are chosen appropriately to ensure a stable and accurate numerical result. The separation of the resonant frequencies $\\omega_1(k)$ and $\\omega_2(k)$ for the given test cases is sufficient for the harmonic inversion method to distinguish them.\n- **Objective**: The problem is stated in precise, objective, and mathematical language. There are no subjective or ambiguous terms.\n\n#### Step 3: Verdict and Action\n\nThe problem statement is **valid**. It is scientifically sound, self-contained, and algorithmically specified. The solution process may proceed.\n\n### Principle-Based Solution\n\nThe objective is to recover the band structure, i.e., the resonant angular frequencies $\\omega_1(k)$ and $\\omega_2(k)$, from synthetically generated frequency-domain data. The solution methodology follows a four-step process for each specified wavevector $k$.\n\n#### Step 1: Synthesize Frequency-Domain Data\n\nFirst, we construct the synthetic frequency-domain response $\\overline{E}(\\omega;k)$ based on the provided two-band model. For a given wavevector $k$, we calculate the parameters of the two resonances.\n\nThe resonant frequencies $\\omega_{n}(k)$ are given by:\n$$\n\\omega_{1}(k)=\\sqrt{\\omega_{01}^{2}+4J_{1}\\sin^{2}\\!\\left(\\frac{ka}{2}\\right)} \\quad \\text{and} \\quad \\omega_{2}(k)=\\sqrt{\\omega_{02}^{2}+4J_{2}\\sin^{2}\\!\\left(\\frac{ka}{2}\\right)}\n$$\nThe complex poles in the frequency domain, incorporating damping, are $\\Omega_{n}(k)=\\omega_{n}(k)-\\mathrm{i}\\gamma_{n}$:\n$$\n\\Omega_{1}(k) = \\omega_{1}(k)-\\mathrm{i}\\gamma_{1} \\quad \\text{and} \\quad \\Omega_{2}(k) = \\omega_{2}(k)-\\mathrm{i}\\gamma_{2}\n$$\nThe source coupling coefficients $C_{n}(k)$ are:\n$$\nC_{1}(k)=1+0.4\\cos(ka) \\quad \\text{and} \\quad C_{2}(k)=0.7+0.3\\sin(ka)\n$$\nUsing the specified parameters ($a=1, \\omega_{01}=10, \\omega_{02}=14, J_{1}=3, J_{2}=1.5, \\gamma_{1}=0.1, \\gamma_{2}=0.08$), we evaluate $\\overline{E}(\\omega;k)$ on a uniform angular frequency grid $\\omega_m$ spanning $[ -W, W ] = [ -40, 40 ]$ with $M=4096$ points. The frequency step is $\\Delta\\omega = 2W / (M-1)$.\n\n#### Step 2: Compute Time-Domain Impulse Response\n\nThe time-domain impulse response $h(t;k)$ is the inverse Fourier transform of $\\overline{E}(\\omega;k)$. We numerically approximate this integral using a discrete sum for $N=128$ time points $t_n = n\\Delta t$ where $\\Delta t=0.05$ and $n \\in \\{0, 1, \\dots, N-1\\}$:\n$$\nh(t_n;k) \\approx \\frac{\\Delta\\omega}{2\\pi}\\sum_{m=0}^{M-1}\\overline{E}(\\omega_{m};k)\\,\\mathrm{e}^{\\mathrm{i}\\omega_{m}t_n}\n$$\nThis computation yields a set of $N$ complex-valued time samples, $h_n \\equiv h(t_n; k)$. This operation is effectively a matrix-vector product between an exponential matrix and the frequency-data vector.\n\n#### Step 3: Apply Harmonic Inversion (Linear Prediction)\n\nThe time-domain signal is modeled as a sum of $P=2$ damped complex exponentials:\n$$\nh_n = \\sum_{j=1}^{P} A_j z_j^n\n$$\nwhere $z_j = \\mathrm{e}^{\\mathrm{i}\\Omega_j\\Delta t}$ are the \"poles\" in the z-domain. Such a signal satisfies a linear prediction recurrence relation of order $P$:\n$$\nh_n = -\\sum_{l=1}^{P} c_l h_{n-l} \\quad \\text{for } n \\ge P\n$$\nThe coefficients $c_l$ are found by solving an overdetermined system of linear equations in a least-squares sense. We construct a matrix $\\mathbf{H}$ and a vector $\\mathbf{h}'$ from the time samples $h_n$:\n$$\n\\mathbf{H} = \\begin{pmatrix}\nh_{P-1} & h_{P-2} & \\dots & h_0 \\\\\nh_{P} & h_{P-1} & \\dots & h_1 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nh_{N-2} & h_{N-3} & \\dots & h_{N-1-P}\n\\end{pmatrix}, \\quad\n\\mathbf{h}' = \\begin{pmatrix}\nh_P \\\\\nh_{P+1} \\\\\n\\vdots \\\\\nh_{N-1}\n\\end{pmatrix}\n$$\nWith $P=2$, this becomes:\n$$\n\\begin{pmatrix}\nh_{1} & h_{0} \\\\\nh_{2} & h_{1} \\\\\n\\vdots & \\vdots \\\\\nh_{N-2} & h_{N-3}\n\\end{pmatrix}\n\\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix}\n= -\n\\begin{pmatrix} h_2 \\\\ h_3 \\\\ \\vdots \\\\ h_{N-1} \\end{pmatrix}\n$$\nWe solve the system $\\mathbf{H}\\mathbf{c}=-\\mathbf{h}'$ for the coefficient vector $\\mathbf{c}=[c_1, c_2, \\dots, c_P]^T$ using a standard least-squares solver.\n\n#### Step 4: Recover Frequencies\n\nThe coefficients $c_l$ define a characteristic polynomial whose roots are the z-domain poles $z_j$:\n$$\nz^P + c_1 z^{P-1} + \\dots + c_P = 0\n$$\nWe find the $P=2$ roots of this polynomial, $z_1$ and $z_2$. These roots are related to the complex frequencies $\\Omega_j$ by the definition $z_j = \\mathrm{e}^{\\mathrm{i}\\Omega_j\\Delta t}$. We can invert this relationship to find $\\Omega_j$:\n$$\n\\mathrm{i}\\Omega_j\\Delta t = \\ln(z_j) \\implies \\Omega_j = \\frac{-\\mathrm{i}\\ln(z_j)}{\\Delta t}\n$$\nwhere $\\ln$ is the complex natural logarithm. The real part of $\\Omega_j$ is the desired angular frequency $\\omega_j = \\mathrm{Re}(\\Omega_j)$.\n\nFinally, for each test case $k$, we obtain two frequencies, which are then sorted in ascending order and rounded to six decimal places, as specified. This procedure is repeated for all $k$ values in the test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not used, as numpy is sufficient.\n\ndef solve():\n    \"\"\"\n    Solves the harmonic inversion problem for a 1D photonic crystal.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # k (wavevector)\n        0.0,\n        np.pi,\n        np.pi / 2.0,\n    ]\n\n    # Define parameters from the problem statement\n    a = 1.0\n    omega_01 = 10.0\n    omega_02 = 14.0\n    J1 = 3.0\n    J2 = 1.5\n    gamma1 = 0.1\n    gamma2 = 0.08\n    \n    W = 40.0\n    M = 4096\n    \n    dt = 0.05\n    N = 128\n    P = 2\n    \n    # Create the frequency and time grids\n    omega_grid = np.linspace(-W, W, M, dtype=np.float64)\n    d_omega = (2 * W) / (M - 1)\n    t_grid = np.arange(N, dtype=np.float64) * dt\n\n    results = []\n    for k in test_cases:\n        # Step 1: Calculate model parameters for the given k\n        omega1_k = np.sqrt(omega_01**2 + 4 * J1 * np.sin(k * a / 2)**2)\n        omega2_k = np.sqrt(omega_02**2 + 4 * J2 * np.sin(k * a / 2)**2)\n        \n        Omega1_k = omega1_k - 1j * gamma1\n        Omega2_k = omega2_k - 1j * gamma2\n        \n        C1_k = 1.0 + 0.4 * np.cos(k * a)\n        C2_k = 0.7 + 0.3 * np.sin(k * a)\n        \n        # Step 2: Generate synthetic frequency-domain data\n        E_bar = C1_k / (omega_grid - Omega1_k) + C2_k / (omega_grid - Omega2_k)\n        \n        # Step 3: Compute time-domain impulse response via numerical inverse Fourier Transform\n        # Vectorized calculation for efficiency\n        exp_matrix = np.exp(1j * np.outer(t_grid, omega_grid))\n        h = (d_omega / (2 * np.pi)) * np.dot(exp_matrix, E_bar)\n\n        # Step 4: Apply harmonic inversion (Prony's Method / Linear Prediction)\n        # Set up the linear system Hc = -h' to find prediction coefficients c\n        \n        # Construct the matrix H of shape (N-P, P)\n        # The j-th column is h[P-1-j : N-1-j]\n        H = np.array([h[P - 1 - j : N - 1 - j] for j in range(P)], dtype=np.complex128).T\n\n        # Construct the vector h' to be predicted\n        h_prime = h[P:N]\n        \n        # Solve the least-squares problem Hc = -h'\n        c, _, _, _ = np.linalg.lstsq(H, -h_prime, rcond=None)\n        \n        # Step 5: Find the roots of the characteristic polynomial z^P + c_1*z^{P-1} + ... = 0\n        poly_coeffs = np.concatenate(([1.0], c))\n        z_roots = np.roots(poly_coeffs)\n        \n        # Step 6: Recover the complex frequencies Ω from the roots z\n        # Ω_j = -i * log(z_j) / Δt\n        Omega_recovered = -1j * np.log(z_roots) / dt\n        \n        # Step 7: Extract real parts (angular frequencies), sort, and round\n        omega_recovered = np.real(Omega_recovered)\n        omega_sorted = np.sort(omega_recovered)\n        omega_rounded = [np.round(val, 6) for val in omega_sorted]\n        \n        results.append(omega_rounded)\n\n    # Final print statement in the exact required format.\n    # e.g., [[val1,val2],[val3,val4]]\n    list_of_strings = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(list_of_strings)}]\")\n\nsolve()\n```"
        }
    ]
}