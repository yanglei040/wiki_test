{
    "hands_on_practices": [
        {
            "introduction": "分析多个物体如何散射电磁波是一个复杂的问题，因为它们之间存在相互作用。一种常见的方法是单独对每个物体建模，然后组合它们的影响。本练习利用散射理论中的强大工具——$T$矩阵形式，来表示单个物体的响应，并为单个圆柱体的$T$矩阵学习一个简单的多项式代理模型。您将把这个组件级的代理模型应用到一个更大的多散射系统中，从而展示如何通过组合学习到的模型来高效预测复杂系统的行为 。",
            "id": "3352891",
            "problem": "考虑一个场 $u(\\mathbf{r})$ 的标量二维（2D）时谐亥姆霍兹方程，其波数为 $k$（单位：$\\mathrm{m}^{-1}$）。设有一对相同的理想电导体（PEC）圆柱，半径为 $a$（单位：$\\mathrm{m}$），圆心位于 $x$ 轴上的 $x_{1}=-d/2$ 和 $x_{2}=+d/2$ 位置，其中 $d>2a$（单位：$\\mathrm{m}$）。背景介质是均匀无损的。一个平面波 $u^{\\mathrm{inc}}(\\mathbf{r})=\\exp(i k x)$ 从 $x=-\\infty$ 入射。散射场 $u^{\\mathrm{sca}}$ 满足 Sommerfeld 辐射条件。\n\n基本原理和定义：\n- 在圆柱外部，标量亥姆霍兹方程为 $\\nabla^{2} u + k^{2} u = 0$。\n- 在每个 PEC 圆柱边界上，狄利克雷边界条件成立：在 $r=a$ 处，$u=0$。\n- 在围绕圆柱中心的柱面多极展开中，出射场基函数是第一类汉克尔函数 $H_{m}^{(1)}(k r) e^{i m \\theta}$，而正则（非奇异）基函数是第一类贝塞尔函数 $J_{m}(k r) e^{i m \\theta}$，其中 $m \\in \\mathbb{Z}$，$(r,\\theta)$ 是围绕圆柱中心的局部极坐标。\n\n单散射体 $T$ 矩阵：\n- 对于单个 PEC 圆柱，在 $r=a$ 处的边界条件 $u=0$ 意味着在柱谐波基下单粒子 $T$ 矩阵是对角矩阵。对角元 $T_{m}(k)$ 通过 $b_{m}=T_{m}(k)\\,a_{m}$ 将入射正则系数 $a_{m}$ 映射到出射系数 $b_{m}$。使用分离变量法并施加边界条件，可以得到用在 $k a$ 处求值的 $J_{m}$ 和 $H_{m}^{(1)}$ 表示的 $T_{m}(k)$。\n\n多重散射的组合：\n- 令 $a_{p,m}$ 和 $b_{p,m}$ 分别表示围绕圆柱 $p \\in \\{1,2\\}$ 的 $m$ 阶入射正则和出射柱谐波系数。\n- 多重散射耦合由源自 Graf 加法定理的平移算子描述。对于沿 $x$ 轴相距为 $d$ 的两个圆柱（因此中心间夹角为零），从圆柱 $q$ 的出射模式 $n$ 到圆柱 $p$ 的正则模式 $m$ 的非对角平移由系数 $H_{n-m}^{(1)}(k d)$ 给出。\n- 两个圆柱的耦合系统可以通过将自身 $T$ 矩阵组装在分块对角线上，并将非对角平移块组装起来，写成块矩阵形式。如果 $\\mathbf{b}$ 表示所有 $b_{p,m}$ 的堆叠向量，$\\mathbf{a}^{\\mathrm{ext}}$ 表示每个圆柱处（来自平面波的）入射正则系数的堆叠向量，则组合规则表示为\n$$\n\\left(\\mathbf{I} - \\mathbf{T}\\,\\mathbf{S}\\right)\\,\\mathbf{b} = \\mathbf{T}\\,\\mathbf{a}^{\\mathrm{ext}},\n$$\n其中 $\\mathbf{T}$ 是包含单粒子 $T$ 矩阵的分块对角矩阵，$\\mathbf{S}$ 包含非对角的汉克尔平移块和零对角块。\n\n代理建模目标：\n- 您必须通过将一个关于 $k$ 的多项式模型拟合到由 PEC 圆柱的第一性原理边界条件生成的真实 $T_m(k)$ 的训练样本，来“学习”一个单粒子 $T$ 矩阵代理 $\\widehat{T}_{m}(k)$，作为 $k$ 的函数，适用于截断范围 $m \\in \\{-M,\\ldots,M\\}$ 内的每个柱谐波阶数 $m$。\n- 对每个 $m$ 使用复值岭正则化最小二乘拟合来确定 $P$ 次多项式的系数。训练集由 $N_{\\mathrm{train}}$ 个在 $[k_{\\min},k_{\\max}]$ 区间内均匀间隔的采样点 $k$ 组成。\n\n入射平面波展开：\n- 对于平面波 $u^{\\mathrm{inc}}(\\mathbf{r})=\\exp(i k x)$，其围绕中心在 $x_p$ 的圆柱的局部正则展开系数为 $a_{p,m}^{\\mathrm{ext}} = i^{m}\\,\\exp(i k x_{p})$，适用于每个 $m \\in \\{-M,\\ldots,M\\}$。\n\n数值任务：\n- 使用学习到的代理 $\\widehat{\\mathbf{T}}(k)$ 实现完整的多重散射分块系统，以预测双圆柱配置的 $\\mathbf{b}_{\\mathrm{sur}}(k,d)$，并将其与通过使用从边界条件获得精确单粒子 $T$ 矩阵计算出的“基准真相” $\\mathbf{b}_{\\mathrm{true}}(k,d)$ 进行比较。\n- 使用相对误差度量\n$$\n\\varepsilon(k,d) = \\frac{\\left\\|\\mathbf{b}_{\\mathrm{sur}}(k,d) - \\mathbf{b}_{\\mathrm{true}}(k,d)\\right\\|_{2}}{\\left\\|\\mathbf{b}_{\\mathrm{true}}(k,d)\\right\\|_{2}},\n$$\n其中 $\\|\\cdot\\|_{2}$ 是欧几里得范数。\n\n规格、单位和参数：\n- 使用圆柱半径 $a = 0.15\\,\\mathrm{m}$。\n- 使用在训练范围内足够大以保证精度的截断阶数 $M$；具体选择 $M = \\lceil k_{\\max}\\,a \\rceil + 8$。\n- 使用多项式次数 $P = 5$ 和岭正则化强度 $\\lambda = 10^{-8}$（无量纲）。\n- 训练区间和大小：$k_{\\min} = 2.0\\,\\mathrm{m}^{-1}$，$k_{\\max} = 8.0\\,\\mathrm{m}^{-1}$，以及 $N_{\\mathrm{train}} = 50$。\n- 测试套件：五个 $(k,d)$ 对，其中 $k$ 的单位是 $\\mathrm{m}^{-1}$，$d$ 的单位是 $\\mathrm{m}$：\n    - 情况 $1$：$(k,d)=(6.0,\\,0.32)$，\n    - 情况 $2$：$(k,d)=(6.0,\\,0.80)$，\n    - 情况 $3$：$(k,d)=(6.0,\\,2.00)$，\n    - 情况 $4$：$(k,d)=(3.0,\\,0.50)$，\n    - 情况 $5$：$(k,d)=(8.0,\\,0.50)$。\n  这些满足 $d>2a$。\n- 角度单位是弧度。物理单位：$k$ 的单位是 $\\mathrm{m}^{-1}$，$a$ 和 $d$ 的单位是 $\\mathrm{m}$。\n\n程序要求：\n- 您的程序必须\n    $1$. 对于 $[k_{\\min},k_{\\max}]$ 中的训练样本和每个 $m \\in \\{-M,\\ldots,M\\}$，从 PEC 边界条件生成基准真相单粒子 $T_{m}(k)$。\n    $2$. 对每个 $m$，使用训练数据拟合一个带有岭正则化 $\\lambda$ 的 $P$ 次复值多项式代理 $\\widehat{T}_{m}(k)$。\n    $3$. 对每个测试用例对 $(k,d)$，使用非对角平移系数 $H_{n-m}^{(1)}(k d)$ 组装双粒子分块系统，求解代理预测的 $\\mathbf{b}_{\\mathrm{sur}}(k,d)$ 和基准真相的 $\\mathbf{b}_{\\mathrm{true}}(k,d)$，并计算 $\\varepsilon(k,d)$。\n    $4$. 将每个 $\\varepsilon(k,d)$ 四舍五入到六位小数（以十进制数表示，而非百分比）。\n- 最终输出格式：您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，例如 $[\\varepsilon_{1},\\varepsilon_{2},\\varepsilon_{3},\\varepsilon_{4},\\varepsilon_{5}]$。\n\n假设与提醒：\n- 仅使用 $\\{-M,\\ldots,M\\}$ 中的柱谐波阶数。\n- 确保所有计算在量纲上一致。所有距离单位应为 $\\mathrm{m}$，波数单位应为 $\\mathrm{m}^{-1}$。\n- 平面波沿 $+x$ 方向传播。",
            "solution": "用户提供了一个计算电磁学问题，要求验证用于散射分析的代理模型。该问题在科学上是有效的、适定的，并包含唯一解所需的所有必要信息。该方法将分三个主要阶段进行：首先，基于第一性原理推导和实现基准物真相理模型；其次，使用多项式回归构建数据驱动的代理模型；第三，将代理模型的预测与一组指定测试用例的基准真相进行定量比较。\n\n第一性原理模型：一组物体的二维（2D）时谐电磁散射由标量亥姆霍兹方程 $\\nabla^2 u + k^2 u = 0$ 控制，其中 $u$ 代表一个场分量（例如 $E_z$ 或 $H_z$），$k$ 是背景介质的波数。对于理想电导体（PEC）圆柱，总场 $u$ 必须在其表面上为零，这导致了狄利克雷边界条件 $u=0$。\n\n使用柱谐波基将场分解为多个模式。单个圆柱外部的总场是入射场 $u^{\\mathrm{inc}}$ 和散射场 $u^{\\mathrm{sca}}$ 的和。这些场展开为：\n$$u^{\\mathrm{inc}}(\\mathbf{r}) = \\sum_{m=-\\infty}^{\\infty} a_m J_m(kr) e^{im\\theta}$$\n$$u^{\\mathrm{sca}}(\\mathbf{r}) = \\sum_{m=-\\infty}^{\\infty} b_m H_m^{(1)}(kr) e^{im\\theta}$$\n其中 $(r,\\theta)$ 是局部极坐标，$a_m$ 和 $b_m$ 是模式系数，$J_m$ 是第一类贝塞尔函数（代表正则、非奇异的波），$H_m^{(1)}$ 是第一类汉克尔函数（代表满足 Sommerfeld 辐射条件的出射波）。\n\n在圆柱半径 $r=a$ 处，边界条件 $u=u^{\\mathrm{inc}}+u^{\\mathrm{sca}}=0$ 必须对所有角度 $\\theta$ 成立。根据正交性，这对每个模式 $m$ 意味着：\n$$a_m J_m(ka) + b_m H_m^{(1)}(ka) = 0$$\n这个关系定义了单散射体 $T$ 矩阵 $T_m(k)$，它通过 $b_m = T_m(k) a_m$ 将入射系数 $a_m$ 映射到出射系数 $b_m$。求解 $T_m(k)$ 可得精确公式：\n$$T_m(k) = -\\frac{J_m(ka)}{H_m^{(1)}(ka)}$$\n在实际数值实现中，对模式 $m$ 的无穷求和被截断为有限范围 $m \\in \\{-M, \\ldots, M\\}$。截断阶数 $M$ 被选为 $M = \\lceil k_{\\max} a \\rceil + 8$，即 $M = \\lceil 8.0 \\times 0.15 \\rceil + 8 = 10$。\n\n对于标记为 $p=1$ 和 $p=2$ 的两个圆柱之间的多重散射，一个圆柱的出射场作为另一个圆柱的入射场。这种耦合由 T 矩阵形式体系捕获。激励圆柱 $p$ 的场的总系数，记作 $\\mathbf{a}_p$，是外部入射场 $\\mathbf{a}_p^{\\mathrm{ext}}$ 和从圆柱 $q \\ne p$ 散射的场的总和。这导致了一个耦合方程组：\n$$(\\mathbf{I} - \\mathbf{T}\\mathbf{S})\\mathbf{b} = \\mathbf{T}\\mathbf{a}^{\\mathrm{ext}}$$\n在这里，$\\mathbf{b}$ 是所有未知出射系数 $b_{p,m}$ 的堆叠向量，$\\mathbf{a}^{\\mathrm{ext}}$ 是已知入射场系数的堆叠向量，$\\mathbf{T}$ 是一个分块对角矩阵，包含每个圆柱的单圆柱 T 矩阵，$\\mathbf{S}$ 是一个分块非对角矩阵，包含平移算子。\n对于两个相同的圆柱，分块结构是：\n$$\\begin{pmatrix} \\mathbf{I} & -\\mathbf{T}^{(1)} \\mathbf{S}^{(12)} \\\\ -\\mathbf{T}^{(2)} \\mathbf{S}^{(21)} & \\mathbf{I} \\end{pmatrix} \\begin{pmatrix} \\mathbf{b}_1 \\\\ \\mathbf{b}_2 \\end{pmatrix} = \\begin{pmatrix} \\mathbf{T}^{(1)} \\mathbf{a}_1^{\\mathrm{ext}} \\\\ \\mathbf{T}^{(2)} \\mathbf{a}_2^{\\mathrm{ext}} \\end{pmatrix}$$\n其中 $\\mathbf{T}^{(1)}=\\mathbf{T}^{(2)}$ 是对角元为 $T_m(k)$ 的对角矩阵。入射场是平面波 $u^{\\mathrm{inc}}(x) = \\exp(ikx)$，其在圆柱 $p$（中心在 $x_p$）处的系数为 $a_{p,m}^{\\mathrm{ext}} = i^m \\exp(ikx_p)$。对于此问题，$x_1 = -d/2$ 且 $x_2=d/2$。平移矩阵 $\\mathbf{S}^{(12)}$ 和 $\\mathbf{S}^{(21)}$ 描述了从一个圆柱的出射模式到另一个圆柱的正则模式的转换。根据问题陈述，从一个圆柱的出射模式 $n$ 映射到另一个圆柱的正则模式 $m$ 的平移矩阵元为 $H_{n-m}^{(1)}(kd)$。这定义了 $\\mathbf{S}^{(12)}$ 和 $\\mathbf{S}^{(21)}$ 的元素，它们被视为相同的托普利茨矩阵。\n\n代理模型：目标是用一个简单的多项式代理 $\\widehat{T}_m(k)$ 来替换计算成本高昂的第一性原理 T 矩阵 $T_m(k)$。对每个模式 $m$，寻求一个 $P=5$ 次的多项式：\n$$\\widehat{T}_m(k) = \\sum_{p=0}^{P} c_{m,p} k^p$$\n复系数 $c_{m,p}$ 是通过将该模型拟合到训练数据来确定的。数据是通过在区间 $[k_{\\min}, k_{\\max}] = [2.0, 8.0]\\, \\mathrm{m}^{-1}$ 内以 $N_{\\mathrm{train}}=50$ 个均匀间隔的波数 $k_j$ 对精确的 $T_m(k)$ 进行采样生成的。拟合过程使用复值岭正则化最小二乘法进行，该方法最小化损失函数：\n$$L(\\mathbf{c}_m) = \\sum_{j=1}^{N_{\\mathrm{train}}} \\left| \\sum_{p=0}^{P} c_{m,p} k_j^p - T_m(k_j) \\right|^2 + \\lambda \\sum_{p=0}^{P} |c_{m,p}|^2$$\n正则化强度为 $\\lambda=10^{-8}$。这个最小化问题通过正规方程有一个闭式解：$(\\mathbf{V}^H\\mathbf{V} + \\lambda\\mathbf{I})\\mathbf{c}_m = \\mathbf{V}^H\\mathbf{y}_m$，其中 $\\mathbf{V}$ 是样本波数 $k_j$ 的范德蒙矩阵，$\\mathbf{y}_m$ 是真实 $T_m(k_j)$ 值的向量，$\\mathbf{c}_m$ 是多项式系数的向量。\n\n评估：对每个测试对 $(k,d)$，多重散射系统被组装并求解两次。首先，使用精确的 T 矩阵 $T_m(k)$ 来获得基准真相散射系数 $\\mathbf{b}_{\\mathrm{true}}(k,d)$。其次，使用学习到的代理 $\\widehat{T}_m(k)$ 来获得预测系数 $\\mathbf{b}_{\\mathrm{sur}}(k,d)$。然后，代理模型的准确性通过相对误差来量化：\n$$\\varepsilon(k,d) = \\frac{\\left\\|\\mathbf{b}_{\\mathrm{sur}}(k,d) - \\mathbf{b}_{\\mathrm{true}}(k,d)\\right\\|_{2}}{\\left\\|\\mathbf{b}_{\\mathrm{true}}(k,d)\\right\\|_{2}}$$\n其中 $\\|\\cdot\\|_2$ 是两个圆柱的散射系数全向量的欧几里得范数。下面的程序实现了这整个过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import jv, hankel1\n\ndef solve():\n    \"\"\"\n    Solves the two-cylinder scattering problem using both a ground-truth T-matrix\n    and a trained polynomial surrogate, then computes the relative error.\n    \"\"\"\n    # -- 1. Define constants and parameters --\n    a = 0.15  # Cylinder radius in m\n    P = 5  # Polynomial degree for surrogate model\n    reg_lambda = 1e-8  # Ridge regularization strength\n    k_min, k_max = 2.0, 8.0  # Training wavenumber range in m^-1\n    N_train = 50  # Number of training samples\n\n    # Calculate harmonic truncation order M\n    M = int(np.ceil(k_max * a)) + 8\n    m_vals = np.arange(-M, M + 1)\n    num_modes = len(m_vals)\n\n    # Test cases: (k [m^-1], d [m])\n    test_cases = [\n        (6.0, 0.32),\n        (6.0, 0.80),\n        (6.0, 2.00),\n        (3.0, 0.50),\n        (8.0, 0.50),\n    ]\n\n    # -- 2. Train the T-matrix surrogate model --\n    surrogate_coeffs = {}\n    k_samples = np.linspace(k_min, k_max, N_train)\n    V_train = np.vander(k_samples, P + 1, increasing=True)\n    \n    # Precompute part of the normal equations matrix\n    V_H_V = V_train.T.conj() @ V_train\n    A_reg = V_H_V + reg_lambda * np.identity(P + 1)\n\n    for m in m_vals:\n        # Generate training data y_m = T_m(k)\n        ka_samples = k_samples * a\n        y_m = -jv(m, ka_samples) / hankel1(m, ka_samples)\n\n        # Solve for polynomial coefficients c_m using normal equations\n        # (V^H V + lambda I) c = V^H y\n        b_vec = V_train.T.conj() @ y_m\n        c_m = np.linalg.solve(A_reg, b_vec)\n        \n        # Store coefficients (note: np.polyval expects highest power first)\n        surrogate_coeffs[m] = c_m[::-1]\n\n    # -- 3. Evaluate surrogate for each test case --\n    results = []\n    for k_test, d_test in test_cases:\n        # -- Assemble system components --\n        \n        # Incident field coefficients for cylinders at x = -d/2 and x = +d/2\n        a_ext1 = (1j**m_vals) * np.exp(1j * k_test * (-d_test / 2.0))\n        a_ext2 = (1j**m_vals) * np.exp(1j * k_test * (d_test / 2.0))\n        a_ext_full = np.concatenate([a_ext1, a_ext2])\n\n        # Diagonal T-matrix entries (true and surrogate)\n        t_true_diag = -jv(m_vals, k_test * a) / hankel1(m_vals, k_test * a)\n        t_sur_diag = np.array([np.polyval(surrogate_coeffs[m], k_test) for m in m_vals])\n        \n        T_true_mat = np.diag(t_true_diag)\n        T_sur_mat = np.diag(t_sur_diag)\n\n        # Translation matrix S\n        S_trans = np.zeros((num_modes, num_modes), dtype=np.complex128)\n        for i, m in enumerate(m_vals):\n            for j, n in enumerate(m_vals):\n                # Per problem spec, S_mn = H_{n-m}(kd)\n                S_trans[i, j] = hankel1(n - m, k_test * d_test)\n\n        # -- Assemble and solve the TRUE multiple scattering system --\n        A_block_true = -T_true_mat @ S_trans\n        A_true = np.block([\n            [np.eye(num_modes), A_block_true],\n            [A_block_true,      np.eye(num_modes)]\n        ])\n        c_true = np.concatenate([T_true_mat @ a_ext1, T_true_mat @ a_ext2])\n        b_true = np.linalg.solve(A_true, c_true)\n        \n        # -- Assemble and solve the SURROGATE multiple scattering system --\n        A_block_sur = -T_sur_mat @ S_trans\n        A_sur = np.block([\n            [np.eye(num_modes), A_block_sur],\n            [A_block_sur,      np.eye(num_modes)]\n        ])\n        c_sur = np.concatenate([T_sur_mat @ a_ext1, T_sur_mat @ a_ext2])\n        b_sur = np.linalg.solve(A_sur, c_sur)\n\n        # -- Compute and store the relative error --\n        error_norm = np.linalg.norm(b_sur - b_true)\n        true_norm = np.linalg.norm(b_true)\n        relative_error = error_norm / true_norm if true_norm > 0 else 0.0\n        results.append(round(relative_error, 6))\n\n    # -- 4. Final output --\n    # Format the results as a comma-separated list in brackets.\n    output_str = f\"[{','.join(f'{r:.6f}' for r in results)}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "理解一个结构（例如谐振腔）的谐振频率和场模式（本征模式）如何随其几何结构变化，是器件设计的关键。本练习将从零开始为一个一维谐振腔的本征模式建立代理模型。您将对控制方程进行离散化，在参数变化时追踪模式，并使用本征正交分解（Proper Orthogonal Decomposition, POD）来创建低维表示。这个练习提供了一个从物理偏微分方程到预测性代理模型的完整工作流程，涵盖了模式追踪和降维等核心技术，这些技术对于参数化谐振系统的建模至关重要 。",
            "id": "3352845",
            "problem": "给定一个参数化的一维电磁腔模型，该模型适用于构建具有强制加权正交性的本征频率和模态场的代理模型。该腔体是一个长度为 $L$ 的线段，在 $x=0$ 和 $x=L$ 处具有完美导电壁。考虑在频域中的无源、时谐场，其角频率为 $\\omega$。设介电常数在空间上变化但为分段常数，磁导率为常数。横向标量电场 $E(x)$ 的基本控制方程源于无源介质中的 Maxwell 方程组：对于恒定磁导率 $\\mu$ 和空间变化的介电常数 $\\epsilon(x)$，该场满足\n$$\n-\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}E(x) = \\omega^2 \\epsilon(x) E(x),\n$$\n边界条件为 $E(0) = 0$ 和 $E(L) = 0$。这是一个带有正权重 $\\epsilon(x)$ 的 Sturm–Liouville 本征值问题。\n\n使用 $N$ 个内部点 $\\{x_i\\}_{i=1}^N$、均匀间距 $h = \\frac{L}{N+1}$ 和 Dirichlet 边界条件来离散化区间 $[0,L]$。使用二阶中心有限差分法，构建刚度矩阵 $K \\in \\mathbb{R}^{N \\times N}$ 和质量矩阵 $M(\\mathbf{p}) \\in \\mathbb{R}^{N \\times N}$ 如下：\n- $K$ 是三对角矩阵，其元素为 $K_{ii} = \\frac{2}{h^2}$，$K_{i,i-1} = K_{i,i+1} = -\\frac{1}{h^2}$，其中 $i$ 在适当的范围内。\n- $M(\\mathbf{p})$ 是对角矩阵，其元素为 $M_{ii}(\\mathbf{p}) = \\epsilon(x_i;\\mathbf{p})\\, h$，其中 $\\epsilon(x;\\mathbf{p})$ 是由 $\\mathbf{p}$ 参数化的介电常数分布。\n\n广义对称本征问题为\n$$\nK \\mathbf{u} = \\lambda(\\mathbf{p}) M(\\mathbf{p}) \\mathbf{u}, \\quad \\text{with } \\lambda(\\mathbf{p}) = \\omega^2(\\mathbf{p}),\n$$\n并且本征模可以使用加权内积进行归一化\n$$\n\\langle \\mathbf{u}_m, \\mathbf{u}_n \\rangle_\\epsilon = \\mathbf{u}_m^\\top M(\\mathbf{p}) \\mathbf{u}_n = \\delta_{mn}.\n$$\n\n定义一个单参数介电常数模型，其向量参数为 $\\mathbf{p} = [p]$。设 $L$ 为无量纲且等于 $L=1$，并考虑两个介电常数 $\\epsilon_1$ 和 $\\epsilon_2$。介电常数为分段常数：\n$$\n\\epsilon(x;p) = \\begin{cases}\n\\epsilon_1, & 0 \\le x \\le p L, \\\\\n\\epsilon_2, & p L  x \\le L,\n\\end{cases}\n$$\n其中 $p \\in (0,1)$。设 $\\mu = 1$。所有量均为无量纲。\n\n您的任务：\n1. 从基本控制方程和边界条件出发，解释为什么离散化会产生一个具有正定质量矩阵的广义对称本征问题，以及为什么所得的本征向量可以相对于加权内积 $\\langle \\cdot, \\cdot \\rangle_\\epsilon$ 被规范正交化。\n2. 在参数值训练集 $\\{p_j\\}$ 上实现参数化采样和模态跟踪方法，以确保本征模指数的一致性。具体来说，在每个连续的参数点，通过使用内积 $\\langle \\cdot, \\cdot \\rangle_\\epsilon$ 来最大化与上一步的绝对加权重叠，从而对模态进行重新排序。将此问题表述为一个分配问题，并证明该方法的合理性。\n3. 通过拟合低阶多项式来为最低的 $k$ 个本征频率 $\\omega_n(p)$ 构建代理模型，并通过对训练集中的每个模态执行本征正交分解 (POD)，然后为 POD 系数拟合多项式代理模型，来为相应的模态场 $\\mathbf{E}_n(p)$ 构建代理模型。通过加权 Gram–Schmidt 过程，在一个新参数 $p^\\star$ 处对预测场强制施加正交性约束 $\\langle \\mathbf{E}_m,\\mathbf{E}_n \\rangle_\\epsilon = \\delta_{mn}$。\n4. 通过计算以下指标，在特定的测试参数下评估代理模型的性能和模态跟踪效果：\n   - 预测的本征频率与 $p^\\star$ 处的真实值相比的平均相对误差，定义为\n     $$\n     e_{\\mathrm{freq}}(p^\\star) = \\frac{1}{k} \\sum_{n=1}^k \\frac{|\\omega_n^{\\mathrm{pred}}(p^\\star) - \\omega_n^{\\mathrm{true}}(p^\\star)|}{\\omega_n^{\\mathrm{true}}(p^\\star)}.\n     $$\n   - 预测场的规范正交性的最大绝对偏差，定义为\n     $$\n     e_{\\mathrm{orth}}(p^\\star) = \\max_{m,n} \\left| \\mathbf{E}_m^{\\mathrm{pred}}(p^\\star)^\\top M(p^\\star) \\mathbf{E}_n^{\\mathrm{pred}}(p^\\star) - \\delta_{mn} \\right|.\n     $$\n   - 在 $p^\\star$ 处的一个布尔值模态跟踪正确性指示器，当且仅当每个预测模态 $\\mathbf{E}_n^{\\mathrm{pred}}(p^\\star)$ 与相同索引的真实模态 $\\mathbf{E}_n^{\\mathrm{true}}(p^\\star)$ 具有最大的绝对加权重叠时，该值为真，即\n     $$\n     t(p^\\star) = \\bigwedge_{n=1}^k \\left( \\underset{m \\in \\{1,\\dots,k\\}}{\\arg\\max} \\left| \\mathbf{E}_n^{\\mathrm{true}}(p^\\star)^\\top M(p^\\star) \\mathbf{E}_m^{\\mathrm{pred}}(p^\\star) \\right| = n \\right).\n     $$\n\n数值规格：\n- 使用 $N = 120$，$L = 1$，$k = 3$，$\\epsilon_1 = 1$，$\\epsilon_2 = 4$。\n- 使用一个在 $[0.2, 0.8]$ (含端点) 内均匀分布的 $p$ 值训练集，至少包含 $9$ 个点。频率和 POD 系数的代理多项式阶数应为 $3$，每个模态的 POD 基秩应能捕获至少 $99.9\\%$ 的能量，同时上限为 $5$。\n- 所有量和计算都是无量纲的，不使用角度。\n\n测试套件：\n- 在以下测试参数处评估指标：$p^\\star \\in \\{0.25, 0.50, 0.90\\}$，这些参数涵盖了一般情况、对称分裂情况以及训练区间外的外推情况。\n- 对于每个测试参数，计算并返回三个指标 $e_{\\mathrm{freq}}(p^\\star)$、$e_{\\mathrm{orth}}(p^\\star)$ 和 $t(p^\\star)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表应按测试参数排序并展平，以便它按顺序包含每个测试参数的三个值。具体来说，输出必须是\n$$\n[e_{\\mathrm{freq}}(0.25), e_{\\mathrm{orth}}(0.25), t(0.25), e_{\\mathrm{freq}}(0.50), e_{\\mathrm{orth}}(0.50), t(0.50), e_{\\mathrm{freq}}(0.90), e_{\\mathrm{orth}}(0.90), t(0.90)].\n$$\n每个 $e_{\\mathrm{freq}}$ 和 $e_{\\mathrm{orth}}$ 必须打印为浮点数，每个 $t$ 必须打印为布尔值。",
            "solution": "问题陈述已经过严格验证，被认为是科学可靠、适定、客观和完整的。它描述了计算电磁学和代理模型中的一个标准问题，具有明确、可验证的要求。\n\n### 1. 离散化与本征问题公式化\n\n分析始于无源介质中具有空间变化介电常数 $\\epsilon(x)$ 和恒定磁导率 $\\mu$ 的横向电场 $E(x)$ 的一维亥姆霍兹方程。\n$$\n-\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}E(x) = \\omega^2 \\mu \\epsilon(x) E(x)\n$$\n给定边界条件 $E(0) = 0$ 和 $E(L) = 0$，这构成一个 Sturm–Liouville 本征值问题。我们给定 $\\mu=1$ 并定义本征值为 $\\lambda = \\omega^2$。\n$$\n-\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}E(x) = \\lambda \\epsilon(x) E(x)\n$$\n为了数值求解该问题，将域 $[0,L]$ 离散化为 $N+2$ 个点 $\\{x_i\\}_{i=0}^{N+1}$，其中 $x_i = i h$ 且 $h = L/(N+1)$。点 $x_1, \\dots, x_N$ 为内部点，而 $x_0=0$ 和 $x_{N+1}=L$ 为边界点。场 $E(x)$ 由向量 $\\mathbf{u} \\in \\mathbb{R}^N$ 表示，其中 $u_i = E(x_i)$，$i=1, \\dots, N$。边界条件意味着 $u_0 = E(x_0) = 0$ 且 $u_{N+1} = E(x_{N+1}) = 0$。\n\n在每个内部点 $x_i$ 处，使用二阶中心有限差分格式来近似二阶导数算子：\n$$\n\\left.\\frac{\\mathrm{d}^2 E}{\\mathrm{d}x^2}\\right|_{x_i} \\approx \\frac{E(x_{i+1}) - 2E(x_i) + E(x_{i-1})}{h^2} = \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n$$\n将此代入每个内部节点 $i=1, \\dots, N$ 的控制方程：\n$$\n-\\frac{1}{h^2}(u_{i-1} - 2u_i + u_{i+1}) = \\lambda \\epsilon(x_i) u_i\n$$\n这 $N$ 个方程的完整集合可以组装成一个单一的矩阵方程。左侧形成矩阵-向量积 $K\\mathbf{u}$，其中 $K$ 是刚度矩阵。对于 $i=1$，方程涉及 $u_0$，其值为零，因此 $-u_0/h^2$ 项消失。对于 $i=N$，它涉及 $u_{N+1}$，其值也为零。这得到了指定的对称三对角矩阵 $K \\in \\mathbb{R}^{N \\times N}$：\n$$\nK = \\frac{1}{h^2}\n\\begin{pmatrix}\n2  -1    \\\\\n-1  2  -1   \\\\\n  \\ddots  \\ddots  \\ddots  \\\\\n   -1  2  -1 \\\\\n    -1  2\n\\end{pmatrix}\n$$\n右侧可以写成 $\\lambda M \\mathbf{u}$。$\\epsilon(x) u_i$ 在对应于点 $x_i$ 的体积元（长度为 $h$）上的离散化给出了项 $\\lambda (\\epsilon(x_i) h) u_i$。这产生一个对角质量矩阵 $M \\in \\mathbb{R}^{N \\times N}$，其元素为 $M_{ii} = \\epsilon(x_i)h$。\n这就得到了广义对称本征问题：\n$$\nK \\mathbf{u} = \\lambda M(\\mathbf{p}) \\mathbf{u}\n$$\n矩阵 $K$ 是通过构造对称的。质量矩阵 $M(\\mathbf{p})$ 是对角的，因此也是对称的。\n\n如果一个矩阵的所有本征值都严格为正，则该矩阵是正定的。\n对于刚度矩阵 $K$，其本征值解析上已知为 $\\mu_j = \\frac{2}{h^2}(1 - \\cos(\\frac{j\\pi}{N+1}))$，对于 $j=1,\\dots,N$。由于 $j \\le N$，$\\frac{j\\pi}{N+1} \\in (0, \\pi)$，所以 $\\cos(\\frac{j\\pi}{N+1})  1$，这意味着对所有 $j$ 都有 $\\mu_j  0$。因此，$K$ 是正定的。\n对于质量矩阵 $M(\\mathbf{p})$，其对角元素为 $M_{ii}(\\mathbf{p}) = \\epsilon(x_i; \\mathbf{p})h$。由于物理介电常数 $\\epsilon(x)$ 总是正的，且间距 $h$ 是正的，因此 $M$ 的所有对角元素都是正的。所有对角元素均为正的对角矩阵是正定的。\n\n由于 $K$ 和 $M$ 是对称的，且 $M$ 是正定的，该问题是一个广义对称定本征问题。此类问题的一个关键特性是，对应于不同本征值 $\\lambda_m \\neq \\lambda_n$ 的本征向量 $\\mathbf{u}_m, \\mathbf{u}_n$ 相对于两个矩阵都是正交的，即 $\\mathbf{u}_m^\\top K \\mathbf{u}_n = 0$ 和 $\\mathbf{u}_m^\\top M \\mathbf{u}_n = 0$。对于任何本征向量 $\\mathbf{u}_n$，二次型 $\\mathbf{u}_n^\\top M \\mathbf{u}_n$ 是正的，因为 $M$ 是正定的。这允许进行归一化。我们可以缩放每个本征向量，使其 $M$-范数为1：\n$$\n\\mathbf{u}_n \\leftarrow \\frac{\\mathbf{u}_n}{\\sqrt{\\mathbf{u}_n^\\top M \\mathbf{u}_n}}\n$$\n经过此归一化后，本征向量集合 $\\{\\mathbf{u}_n\\}$ 满足加权规范正交条件 $\\langle \\mathbf{u}_m, \\mathbf{u}_n \\rangle_\\epsilon = \\mathbf{u}_m^\\top M \\mathbf{u}_n = \\delta_{mn}$。\n\n### 2. 参数化采样与模态跟踪\n\n当在不同参数值 $p_j$ 处求解本征问题 $K \\mathbf{u} = \\lambda M(p) \\mathbf{u}$ 时，标准的本征求解器通常按升序返回本征值。然而，随着 $p$ 的变化，一个物理模态在排序列表中的位置可能会改变。这种现象被称为模态交叉。为了构建一个有意义的代理模型，我们必须在整个参数空间中一致地跟踪每个物理模态。\n\n我们的策略依赖于模态连续性原理：对于参数 $p_j \\to p_{j+1}$ 的一个微小变化，本征向量（模态形状）$\\mathbf{u}_n(p)$ 也应该变化很小。我们可以使用向量投影，特别是加权内积，来量化模态形状之间的相似性。\n\n设 $\\{\\mathbf{u}_n(p_j)\\}_{n=1}^k$ 是在参数 $p_j$ 处正确排序和归一化的本征向量集。在下一个参数值 $p_{j+1}$ 处，本征求解器返回一个原始的、排序的本征向量集 $\\{\\tilde{\\mathbf{u}}_m(p_{j+1})\\}_{m=1}^k$。为了找到这个新集合的正确排序，我们计算一个重叠矩阵 $C \\in \\mathbb{R}^{k \\times k}$，其中每个元素 $C_{nm}$ 衡量了上一步的第 $n$ 个跟踪模态与当前步的第 $m$ 个原始模态之间的相似性。内积必须使用与当前参数值对应的质量矩阵 $M(p_{j+1})$：\n$$\nC_{nm} = \\left| \\langle \\mathbf{u}_n(p_j), \\tilde{\\mathbf{u}}_m(p_{j+1}) \\rangle_{M(p_{j+1})} \\right| = \\left| \\mathbf{u}_n(p_j)^\\top M(p_{j+1}) \\tilde{\\mathbf{u}}_m(p_{j+1}) \\right|\n$$\n取绝对值是因为本征向量的符号是任意的。我们寻求找到一个 $\\{1, \\dots, k\\}$ 的排列 $\\pi$，它重新排序新模态，$\\mathbf{u}_n(p_{j+1}) = \\tilde{\\mathbf{u}}_{\\pi(n)}(p_{j+1})$，使得总相似度最大化：$\\max_{\\pi} \\sum_{n=1}^k C_{n, \\pi(n)}$。这是一个经典的线性分配问题。它可以由诸如 Hungarian algorithm 之类的算法高效解决，该算法在 `scipy.optimize.linear_sum_assignment` 中实现。该函数找到最小化总成本的分配，所以我们向它提供我们的相似性矩阵的负数，即 $-C$。\n\n### 3. 代理模型构建\n\n目标是为本征频率 $\\omega_n(p)$ 和本征向量 $\\mathbf{E}_n(p)$ 创建计算成本低的近似，即代理模型。\n\n**频率代理模型：** 对于每个模态 $n \\in \\{1,\\dots,k\\}$，我们有一组从模态跟踪采样过程中获得的训练数据 $(p_j, \\omega_n(p_j))$。我们用一个 3 次多项式拟合这些数据。这产生了一个映射 $p \\mapsto \\omega_n^{\\mathrm{pred}}(p)$。\n\n**场代理模型 (POD)：** 对于每个模态 $n \\in \\{1,\\dots,k\\}$，我们有一个模态跟踪的本征向量集合 $\\{\\mathbf{E}_n(p_j)\\}_{j=1}^{N_s}$，其中 $N_s$ 是训练点的数量。这些向量被称为快照。本征正交分解 (Proper Orthogonal Decomposition, POD) 用于找到一个低维基，该基能最优地捕获这组快照中的方差。\n\n1.  **快照矩阵：** 将模态 $n$ 的快照排列成快照矩阵 $S_n = [\\mathbf{E}_n(p_1), \\dots, \\mathbf{E}_n(p_{N_s})] \\in \\mathbb{R}^{N \\times N_s}$ 的列。\n2.  **POD 基：** 计算 $S_n$ 的 SVD：$S_n = U_n \\Sigma_n V_n^\\top$。$U_n$ 的列，称为 POD 模态或基向量 $\\{\\boldsymbol{\\phi}_{ni}\\}$，为快照所张成的空间构成一个规范正交基。\n3.  **基截断：** $\\Sigma_n$ 中的奇异值表示每个基向量的重要性。第 $i$ 个基向量捕获的“能量”与 $\\sigma_{ni}^2$ 成正比。我们选择前 $r_n$ 个基向量，使得累积能量 $\\sum_{i=1}^{r_n} \\sigma_{ni}^2 / \\sum_{i=1}^{N_s} \\sigma_{ni}^2$ 至少为 $0.999$，并附加约束条件 $r_n \\le 5$。\n4.  **系数代理模型：** 任何快照都可以通过其在截断的 POD 基上的投影来近似：$\\mathbf{E}_n(p_j) \\approx \\sum_{i=1}^{r_n} c_{ni}(p_j) \\boldsymbol{\\phi}_{ni}$。系数为 $c_{ni}(p_j) = \\boldsymbol{\\phi}_{ni}^\\top \\mathbf{E}_n(p_j)$。对于每个模态 $n$ 和每个基索引 $i \\in \\{1, \\dots, r_n\\}$，我们用一个 3 次多项式拟合训练数据 $(p_j, c_{ni}(p_j))$。这给出了一个代理函数 $p \\mapsto c_{ni}^{\\mathrm{pred}}(p)$。\n5.  **场重构：** 在一个新参数 $p^\\star$ 处，使用 POD 基和预测的系数重构预测场：$\\mathbf{E}_n^{\\mathrm{pred}}(p^\\star) = \\sum_{i=1}^{r_n} c_{ni}^{\\mathrm{pred}}(p^\\star) \\boldsymbol{\\phi}_{ni}$。\n\n**正交性强制：** 预测场集合 $\\{\\mathbf{E}_n^{\\mathrm{pred}}(p^\\star)\\}_{n=1}^k$ 不保证相对于质量矩阵 $M(p^\\star)$ 是规范正交的。为强制施加此物理约束，我们应用加权 Gram-Schmidt 过程。给定预测向量 $\\{\\mathbf{v}_n = \\mathbf{E}_n^{\\mathrm{pred}}(p^\\star)\\}_{n=1}^k$，我们如下生成一个规范正交集 $\\{\\mathbf{q}_n\\}_{n=1}^k$：\n$$\n\\mathbf{w}_n = \\mathbf{v}_n - \\sum_{j=1}^{n-1} (\\mathbf{q}_j^\\top M(p^\\star) \\mathbf{v}_n) \\mathbf{q}_j \\quad ; \\quad \\mathbf{q}_n = \\frac{\\mathbf{w}_n}{\\sqrt{\\mathbf{w}_n^\\top M(p^\\star) \\mathbf{w}_n}}\n$$\n最终的预测场是这个规范正交集 $\\{\\mathbf{q}_n\\}$。\n\n### 4. 代理模型评估\n\n代理模型的性能在指定的测试参数 $p^\\star$ 处通过三个指标进行评估，这些指标将代理的预测与在 $p^\\star$ 处通过完全数值求解本征问题获得的“真实”值进行比较。\n\n-   **频率误差 ($e_{\\mathrm{freq}}$):** 在 $k$ 个预测本征频率上的平均相对误差。\n-   **正交性误差 ($e_{\\mathrm{orth}}$):** 在 Gram-Schmidt 强制执行后，预测场的 Gram 矩阵与单位矩阵的最大绝对偏差。这衡量了最终预测场满足规范正交性约束的程度。\n-   **模态跟踪正确性 ($t$):** 一个布尔值，指示每个预测模态是否对应于正确的真实模态。这通过计算在 $p^\\star$ 处的真实模态 $\\{\\mathbf{E}_n^{\\mathrm{true}}\\}$ 和预测模态 $\\{\\mathbf{E}_m^{\\mathrm{pred}}\\}$ 之间的重叠矩阵，并检查每个真实模态的最大重叠是否与相同索引的预测模态发生，来进行验证。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\nfrom scipy.optimize import linear_sum_assignment\n\ndef solve():\n    \"\"\"\n    Main function to construct, train, and evaluate the surrogate model.\n    \"\"\"\n    # Numerical specifications\n    N = 120\n    L = 1.0\n    k = 3\n    eps1 = 1.0\n    eps2 = 4.0\n    poly_deg = 3\n    pod_energy_threshold = 0.999\n    pod_rank_max = 5\n\n    # Training and test parameters\n    train_points = 9\n    p_train = np.linspace(0.2, 0.8, train_points)\n    p_test = [0.25, 0.50, 0.90]\n\n    # Helper function to get system matrices\n    def get_system_matrices(p, N, L, eps1, eps2):\n        h = L / (N + 1)\n        x = np.linspace(h, L - h, N)\n        \n        # Stiffness matrix K\n        main_diag_K = np.full(N, 2.0 / h**2)\n        off_diag_K = np.full(N - 1, -1.0 / h**2)\n        K = np.diag(main_diag_K) + np.diag(off_diag_K, k=1) + np.diag(off_diag_K, k=-1)\n        \n        # Mass matrix M\n        eps_values = np.where(x = p * L, eps1, eps2)\n        M = np.diag(eps_values * h)\n        \n        return K, M\n\n    # Helper function to solve the eigensystem\n    def solve_eigensystem(p, N, L, eps1, eps2, k):\n        K, M = get_system_matrices(p, N, L, eps1, eps2)\n        # Solve the generalized eigenvalue problem K u = lambda M u\n        \n        # scipy.linalg.eigh returns eigenvalues in ascending order\n        eigenvalues, eigenvectors = eigh(K, M, subset_by_index=[0, k - 1])\n        \n        # Normalize eigenvectors such that u.T @ M @ u = 1\n        for i in range(k):\n            norm = np.sqrt(eigenvectors[:, i].T @ M @ eigenvectors[:, i])\n            eigenvectors[:, i] /= norm\n            \n        # omega = sqrt(lambda)\n        omegas = np.sqrt(eigenvalues)\n        return omegas, eigenvectors, M\n\n    # --- Training Phase ---\n    \n    # Store training data (frequencies and eigenvectors)\n    train_data_omegas = np.zeros((train_points, k))\n    train_data_evecs = np.zeros((train_points, N, k))\n\n    # Solve for the first parameter point\n    omegas_prev, evecs_prev, _ = solve_eigensystem(p_train[0], N, L, eps1, eps2, k)\n    train_data_omegas[0, :] = omegas_prev\n    train_data_evecs[0, :, :] = evecs_prev\n\n    # Solve for subsequent training points with mode tracking\n    for j in range(1, train_points):\n        p_j = p_train[j]\n        omegas_raw, evecs_raw, M_j = solve_eigensystem(p_j, N, L, eps1, eps2, k)\n        \n        # Mode tracking using linear assignment problem\n        # Cost matrix: negative absolute overlap\n        overlap_matrix = np.abs(evecs_prev.T @ M_j @ evecs_raw)\n        cost_matrix = -overlap_matrix\n        \n        row_ind, col_ind = linear_sum_assignment(cost_matrix)\n        \n        # Reorder the raw solutions\n        omegas_tracked = omegas_raw[col_ind]\n        evecs_tracked = evecs_raw[:, col_ind]\n        \n        train_data_omegas[j, :] = omegas_tracked\n        train_data_evecs[j, :, :] = evecs_tracked\n        \n        # Update previous for next iteration\n        evecs_prev = evecs_tracked\n\n    # --- Surrogate Construction ---\n    \n    # 1. Frequency surrogates\n    omega_surrogates = [np.poly1d(np.polyfit(p_train, train_data_omegas[:, i], poly_deg)) for i in range(k)]\n\n    # 2. Field surrogates (POD)\n    pod_bases = []\n    pod_coeff_surrogates = []\n\n    for n in range(k):\n        # Snapshot matrix for mode n\n        S_n = train_data_evecs[:, :, n].T\n        \n        # SVD for POD basis\n        U, s, _ = np.linalg.svd(S_n, full_matrices=False)\n        \n        # Truncate basis based on energy\n        energies = s**2\n        cumulative_energy = np.cumsum(energies) / np.sum(energies)\n        r_n = np.searchsorted(cumulative_energy, pod_energy_threshold, side='right') + 1\n        r_n = min(r_n, pod_rank_max, U.shape[1])\n        \n        pod_basis = U[:, :r_n]\n        pod_bases.append(pod_basis)\n        \n        # Project snapshots to get coefficients\n        coeffs = (pod_basis.T @ S_n).T\n        \n        # Fit surrogates for coefficients\n        coeff_surrogates_n = [np.poly1d(np.polyfit(p_train, coeffs[:, i], poly_deg)) for i in range(r_n)]\n        pod_coeff_surrogates.append(coeff_surrogates_n)\n\n    # --- Evaluation Phase ---\n    results = []\n    for p_star in p_test:\n        # 1. Get \"true\" solution at p_star\n        omegas_true, evecs_true, M_star = solve_eigensystem(p_star, N, L, eps1, eps2, k)\n\n        # 2. Get \"predicted\" solution from surrogate\n        # Predict frequencies\n        omegas_pred = np.array([omega_surrogates[n](p_star) for n in range(k)])\n        \n        # Predict fields\n        evecs_pred_raw = np.zeros((N, k))\n        for n in range(k):\n            # Predict POD coefficients\n            coeffs_pred = np.array([coeff_surrogate(p_star) for coeff_surrogate in pod_coeff_surrogates[n]])\n            # Reconstruct field\n            evecs_pred_raw[:, n] = pod_bases[n] @ coeffs_pred\n\n        # Enforce orthogonality via weighted Gram-Schmidt\n        evecs_pred = np.zeros_like(evecs_pred_raw)\n        for n in range(k):\n            v = evecs_pred_raw[:, n]\n            w = v - np.sum([((evecs_pred[:, j].T @ M_star @ v) * evecs_pred[:, j]) for j in range(n)], axis=0)\n            norm = np.sqrt(w.T @ M_star @ w)\n            evecs_pred[:, n] = w / norm\n\n        # 3. Compute metrics\n        # Frequency error\n        e_freq = np.mean(np.abs(omegas_pred - omegas_true) / omegas_true)\n        \n        # Orthogonality error\n        gram_matrix = evecs_pred.T @ M_star @ evecs_pred\n        e_orth = np.max(np.abs(gram_matrix - np.eye(k)))\n        \n        # Mode tracking correctness\n        # Note: the predicted vectors need to be checked against the *true* vectors\n        # The Gram-Schmidt process preserves the order of the input vectors\n        tracking_overlap = np.abs(evecs_true.T @ M_star @ evecs_pred)\n        # For each true mode (row), find the index of the predicted mode (col) with max overlap\n        max_overlap_indices = np.argmax(tracking_overlap, axis=1)\n        t_correct = bool(np.all(max_overlap_indices == np.arange(k)))\n        \n        results.extend([e_freq, e_orth, t_correct])\n        \n    # Format and print the final output\n    output_str = \"[\"\n    for i, item in enumerate(results):\n        if isinstance(item, bool):\n            output_str += str(item).lower()\n        else:\n            output_str += f\"{item}\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "诸如微波网络的$S$参数等测量数据，通常会包含微小误差，这些误差可能违反基本的物理定律，如互易性（reciprocity）和无源性（passivity）。本练习介绍了一种基于凸优化的、物理信息驱动的数据校正方法。您将寻找对测量数据的最小可能扰动，以强制施加这些物理约束。这项实践展示了如何构建一个“修正后的代理模型”，它不仅接近原始数据，而且严格遵守物理原理，这是从实验数据创建稳健可靠模型的关键一步 。",
            "id": "3352830",
            "problem": "考虑一个用散射表示法表征的线性和时不变双端口网络。设入射和反射功率波矢量分别用 $\\mathbf{a} \\in \\mathbb{C}^{2}$ 和 $\\mathbf{b} \\in \\mathbb{C}^{2}$ 表示，散射矩阵 $S(\\omega) \\in \\mathbb{C}^{2 \\times 2}$ 在角频率 $\\omega$ 下满足 $\\mathbf{b} = S(\\omega)\\,\\mathbf{a}$。假设端口参考阻抗为相等的实数。以下基本原理将作为您推理的基础：(i) 对于无源介质，能量守恒和 Poynting 定理意味着总出射功率不能超过入射功率，在功率波归一化下，这意味着对于每个激励 $\\mathbf{a}$ 都有 $\\|\\mathbf{b}\\|_{2} \\le \\|\\mathbf{a}\\|_{2}$；(ii) Lorentz 互易定理意味着在所述条件下，对于互易介质，散射矩阵满足 $S(\\omega) = S(\\omega)^{\\mathsf{T}}$。由此可知，对于无源网络，$S(\\omega)$ 的最大奇异值不超过 1，而对于互易网络，$S(\\omega)$ 是复对称的。假设由于微小的测量噪声，在三个离散频率上采样的 $S(\\omega)$ 值偏离了精确的互易性，在某些情况下，还偏离了无源性。您的任务是：(1) 在每个数据集级别上对互易性和无源性进行数值检验，(2) 在每个采样频率上构造一个校正后的代理矩阵 $\\tilde{S}(\\omega)$，使其在 Frobenius 范数下对测量数据的扰动最小，同时满足 $\\tilde{S}(\\omega) = \\tilde{S}(\\omega)^{\\mathsf{T}}$ 和 $\\|\\tilde{S}(\\omega)\\|_{2} \\le 1$ 这两个约束条件。具体而言，对于每个数据集，在每个采样频率上解决以下凸可行性校正问题：\n$$\n\\min_{\\Delta \\in \\mathbb{C}^{2 \\times 2}} \\ \\|\\Delta\\|_{\\mathrm{F}} \\quad \\text{subject to} \\quad S_{\\mathrm{meas}}(\\omega) + \\Delta = \\tilde{S}(\\omega), \\ \\ \\tilde{S}(\\omega) = \\tilde{S}(\\omega)^{\\mathsf{T}}, \\ \\ \\|\\tilde{S}(\\omega)\\|_{2} \\le 1,\n$$\n并将校正后的代理矩阵取为 $\\tilde{S}(\\omega)$。对于每个数据集，报告四个布尔值，分别表示所有三个测量样本是否满足互易性和无源性，以及所有三个校正后的代理矩阵是否满足互易性和无源性，同时报告总扰动大小，定义为 Frobenius 范数 $\\|S_{\\mathrm{meas}}(\\omega) - \\tilde{S}(\\omega)\\|_{\\mathrm{F}}$ 在三个频率上的总和。散射参数没有物理单位；将所有量视为无量纲的复数。当概念上引用角度时，单位为弧度。所有数值答案都要求为纯布尔值和实数。\n\n实现一个在任何现代编程语言中都普遍适用的算法，以：\n- 计算奇异值和谱范数，\n- 在数值容差范围内通过测试 $S(\\omega) = S(\\omega)^{\\mathsf{T}}$ 来检验互易性，\n- 在每个频率样本上计算一个最小 Frobenius 范数校正，以强制满足互易性和无源性。\n\n设计您的程序来处理以下测试套件（三个数据集，每个数据集包含三个频率样本）。每个 $2 \\times 2$ 复矩阵以 $a + bj$（其中 $j = \\sqrt{-1}$）的直角坐标形式给出：\n\n数据集 A（三个频率）：\n- $\\omega_{1}$: $\\begin{bmatrix} 0.199001 + 0.0199666\\,j  0.099875 - 0.0049979\\,j \\\\ 0.097955 + 0.0029395\\,j  0.299265 + 0.0209828\\,j \\end{bmatrix}$\n- $\\omega_{2}$: $\\begin{bmatrix} 0.179964 - 0.0035998\\,j  0.119904 + 0.0047987\\,j \\\\ 0.120924 + 0.0042359\\,j  0.279986 + 0.0027999\\,j \\end{bmatrix}$\n- $\\omega_{3}$: $\\begin{bmatrix} 0.22 + 0\\,j  0.089982 - 0.0017999\\,j \\\\ 0.0909908 - 0.0013649\\,j  0.309613 + 0.0154935\\,j \\end{bmatrix}$\n\n数据集 B（三个频率）：\n- $\\omega_{1}$: $\\begin{bmatrix} 0.532 + 0.005\\,j  0.456 - 0.004\\,j \\\\ 0.470 + 0.003\\,j  0.532 - 0.006\\,j \\end{bmatrix}$\n- $\\omega_{2}$: $\\begin{bmatrix} 0.540 + 0.002\\,j  0.450 + 0.006\\,j \\\\ 0.455 - 0.005\\,j  0.525 - 0.001\\,j \\end{bmatrix}$\n- $\\omega_{3}$: $\\begin{bmatrix} 0.520 - 0.001\\,j  0.462 + 0\\,j \\\\ 0.458 + 0.010\\,j  0.538 + 0.003\\,j \\end{bmatrix}$\n\n数据集 C（三个频率）：\n- $\\omega_{1}$: $\\begin{bmatrix} 0.25 + 0.01\\,j  0.12 - 0.02\\,j \\\\ 0.17 + 0.01\\,j  0.18 - 0.005\\,j \\end{bmatrix}$\n- $\\omega_{2}$: $\\begin{bmatrix} 0.22 - 0.015\\,j  0.11 + 0\\,j \\\\ 0.16 - 0.02\\,j  0.20 + 0.008\\,j \\end{bmatrix}$\n- $\\omega_{3}$: $\\begin{bmatrix} 0.28 + 0\\,j  0.10 + 0.015\\,j \\\\ 0.14 - 0.005\\,j  0.19 + 0.012\\,j \\end{bmatrix}$\n\n数值规格：\n- 使用互易性容差 $\\varepsilon_{\\mathrm{rec}} = 10^{-9}$，应用于 $\\max_{i,j} |S_{ij} - S_{ji}| \\le \\varepsilon_{\\mathrm{rec}}$。\n- 使用无源性容差 $\\varepsilon_{\\mathrm{pas}} = 10^{-9}$，应用于 $\\sigma_{\\max}(S) \\le 1 + \\varepsilon_{\\mathrm{pas}}$，其中 $\\sigma_{\\max}$ 表示最大奇异值。\n- 对于校正步骤，在每个频率样本上最小化 Frobenius 范数，并服从两个约束条件。一种有原则的方法是计算到复对称矩阵凸集和谱范数单位球凸集交集上的正交投影。您的实现必须确保返回的 $\\tilde{S}(\\omega)$ 在给定容差内满足两个约束。\n- 将每个数据集的总扰动报告为三个 Frobenius 范数 $\\sum_{k=1}^{3} \\|S_{\\mathrm{meas}}(\\omega_k) - \\tilde{S}(\\omega_k)\\|_{\\mathrm{F}}$ 的和，四舍五入到六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个含三个记录的列表，每个数据集一个记录，每个记录是一个含五个元素的列表，顺序为：$[\\text{reciprocal\\_before}, \\text{passive\\_before}, \\text{reciprocal\\_after}, \\text{passive\\_after}, \\text{total\\_perturbation}]$。布尔值必须是字面量 $True$ 或 $False$，总扰动是一个四舍五入到六位小数的实数。整个输出必须是单行，没有额外文本，例如：$[[\\ldots],[\\ldots],[\\ldots]]$。",
            "solution": "该问题定义明确，并以电磁网络理论的原理为科学基础。将通过遵守所提供的约束和定义来解决它。\n\n核心任务是找到一个校正后的散射矩阵 $\\tilde{S}(\\omega)$，它在 Frobenius 范数意义下“最接近”测量的矩阵 $S_{\\mathrm{meas}}(\\omega)$，同时满足互易性和无源性的物理约束。这是一个经典的凸优化问题，称为凸集投影。\n\n这些约束在 $2 \\times 2$ 复矩阵空间 $\\mathbb{C}^{2 \\times 2}$ 中定义了两个凸集：\n1.  互易矩阵集，对于给定条件下的双端口网络，这些是复对称矩阵。这是一个线性子空间，因此是一个凸集，定义为 $C_{\\mathrm{rec}} = \\{ X \\in \\mathbb{C}^{2 \\times 2} \\mid X = X^{\\mathsf{T}} \\}$。\n2.  无源矩阵集，由谱范数（最大奇异值）不超过 1 的条件定义。这是关于谱范数的闭单位球，是一个凸集，定义为 $C_{\\mathrm{pas}} = \\{ X \\in \\mathbb{C}^{2 \\times 2} \\mid \\|X\\|_{2} \\le 1 \\}$。\n\n问题在于找到测量矩阵 $S_{\\mathrm{meas}}$ 到这两个集合交集 $C_{\\mathrm{rec}} \\cap C_{\\mathrm{pas}}$ 上的正交投影。该优化问题正式表述为：\n$$\n\\tilde{S} = \\underset{X}{\\operatorname{argmin}} \\|S_{\\mathrm{meas}} - X\\|_{\\mathrm{F}} \\quad \\text{subject to} \\quad X \\in C_{\\mathrm{rec}} \\cap C_{\\mathrm{pas}}.\n$$\n这里，$\\| \\cdot \\|_{\\mathrm{F}}$ 表示 Frobenius 范数。\n\n虽然对于任意凸集交集的投影没有封闭形式的表达式，但这个特定问题可以通过一种称为 Dykstra 算法的迭代过程来解决。该算法通过在各个集合上交替投影并维持校正项，来找到一个点到两个凸集交集上的投影。\n\n设 $P_{C_{\\mathrm{rec}}}(A)$ 是矩阵 $A$ 在对称矩阵集合上的投影，而 $P_{C_{\\mathrm{pas}}}(A)$ 是其在无源矩阵集合上的投影。\n- 到复对称矩阵子空间上的投影由下式给出：\n  $$\n  P_{C_{\\mathrm{rec}}}(A) = \\frac{A + A^{\\mathsf{T}}}{2}\n  $$\n- 到谱范数单位球上的投影通过奇异值分解（SVD）找到。如果 $A = U \\Sigma V^{\\mathsf{H}}$ 是 $A$ 的 SVD，其中 $\\Sigma = \\operatorname{diag}(\\sigma_1, \\sigma_2, \\dots)$，则投影为：\n  $$\n  P_{C_{\\mathrm{pas}}}(A) = U \\hat{\\Sigma} V^{\\mathsf{H}}, \\quad \\text{where} \\quad \\hat{\\Sigma} = \\operatorname{diag}(\\min(\\sigma_1, 1), \\min(\\sigma_2, 1), \\dots)\n  $$\n  此操作有效地将奇异值“限制”在 1。\n\n应用于此问题的 Dykstra 算法如下：\n初始化 $X_0 = S_{\\mathrm{meas}}$，以及校正矩阵 $Q_0 = \\mathbf{0}$，$R_0 = \\mathbf{0}$。\n对于 $k = 1, 2, \\dots$ 直到收敛：\n1.  投影到 $C_{\\mathrm{rec}}$：$Y_k = P_{C_{\\mathrm{rec}}}(X_{k-1} + Q_{k-1})$\n2.  更新第一个校正项：$Q_k = (X_{k-1} + Q_{k-1}) - Y_k$\n3.  投影到 $C_{\\mathrm{pas}}$：$X_k = P_{C_{\\mathrm{pas}}}(Y_k + R_{k-1})$\n4.  更新第二个校正项：$R_k = (Y_k + R_{k-1}) - X_k$\n\n序列 $X_k$ 收敛到所需的校正矩阵 $\\tilde{S}$。\n\n对于每个数据集，执行以下过程：\n1.  测试三个测量矩阵 $S_{\\mathrm{meas}}(\\omega_k)$ 的属性。\n    -   **互易性：** 如果 $\\max_{i,j} |S_{ij} - S_{ji}| \\le \\varepsilon_{\\mathrm{rec}} = 10^{-9}$，则矩阵 $S$ 被认为是互易的。对于 $2 \\times 2$ 的情况，这简化为 $|S_{12} - S_{21}| \\le 10^{-9}$。\n    -   **无源性：** 如果矩阵的最大奇异值 $\\sigma_{\\max}(S) \\le 1 + \\varepsilon_{\\mathrm{pas}} = 1 + 10^{-9}$，则该矩阵被认为是无源的。\n2.  对于每个 $S_{\\mathrm{meas}}(\\omega_k)$，使用上述 Dykstra 算法计算校正后的矩阵 $\\tilde{S}(\\omega_k)$。\n3.  验证得到的校正矩阵 $\\tilde{S}(\\omega_k)$ 在指定容差内满足互易性和无源性约束。根据构造，该算法保证了这一点。\n4.  每个频率的扰动大小计算为 $\\|S_{\\mathrm{meas}}(\\omega_k) - \\tilde{S}(\\omega_k)\\|_{\\mathrm{F}}$。数据集的总扰动是这三个范数的和。\n5.  汇编每个数据集的最终结果——四个布尔标志和总扰动。\n\n对于所提供的数据集，一个重要的观察结果是，对于每个测量矩阵 $S_{\\mathrm{meas}}$，其在对称子空间上的投影 $P_{C_{\\mathrm{rec}}}(S_{\\mathrm{meas}})$ 已经满足了无源性约束，即 $P_{C_{\\mathrm{rec}}}(S_{\\mathrm{meas}}) \\in C_{\\mathrm{pas}}$。在这种特殊情况下，Dykstra 算法在单次迭代中收敛到 $\\tilde{S} = P_{C_{\\mathrm{rec}}}(S_{\\mathrm{meas}})$。虽然我们的实现为了正确性和鲁棒性使用了通用的迭代算法，但数据的这一特性极大地简化了校正过程。扰动仅仅是测量矩阵斜对称部分的范数，即 $\\|S_{\\mathrm{meas}} - \\tilde{S}\\|_{\\mathrm{F}} = \\|\\frac{1}{2}(S_{\\mathrm{meas}} - S_{\\mathrm{meas}}^{\\mathsf{T}})\\|_{\\mathrm{F}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... # numpy is sufficient for this problem.\n\ndef solve():\n    \"\"\"\n    Validates and corrects scattering matrix data for reciprocity and passivity.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = {\n        \"A\": [\n            np.array([[0.199001 + 0.0199666j, 0.099875 - 0.0049979j],\n                      [0.097955 + 0.0029395j, 0.299265 + 0.0209828j]]),\n            np.array([[0.179964 - 0.0035998j, 0.119904 + 0.0047987j],\n                      [0.120924 + 0.0042359j, 0.279986 + 0.0027999j]]),\n            np.array([[0.22 + 0.j, 0.089982 - 0.0017999j],\n                      [0.0909908 - 0.0013649j, 0.309613 + 0.0154935j]])\n        ],\n        \"B\": [\n            np.array([[0.532 + 0.005j, 0.456 - 0.004j],\n                      [0.470 + 0.003j, 0.532 - 0.006j]]),\n            np.array([[0.540 + 0.002j, 0.450 + 0.006j],\n                      [0.455 - 0.005j, 0.525 - 0.001j]]),\n            np.array([[0.520 - 0.001j, 0.462 + 0.j],\n                      [0.458 + 0.010j, 0.538 + 0.003j]])\n        ],\n        \"C\": [\n            np.array([[0.25 + 0.01j, 0.12 - 0.02j],\n                      [0.17 + 0.01j, 0.18 - 0.005j]]),\n            np.array([[0.22 - 0.015j, 0.11 + 0.j],\n                      [0.16 - 0.02j, 0.20 + 0.008j]]),\n            np.array([[0.28 + 0.j, 0.10 + 0.015j],\n                      [0.14 - 0.005j, 0.19 + 0.012j]])\n        ]\n    }\n\n    # Numerical specifications\n    reciprocity_tol = 1e-9\n    passivity_tol = 1e-9\n\n    def project_symmetric(A):\n        \"\"\"Projects a matrix onto the set of complex symmetric matrices.\"\"\"\n        return (A + A.T) / 2\n\n    def project_passive(A):\n        \"\"\"Projects a matrix onto the spectral norm unit ball.\"\"\"\n        U, s, Vh = np.linalg.svd(A, full_matrices=False)\n        s_capped = np.minimum(s, 1.0)\n        return U @ np.diag(s_capped) @ Vh\n\n    def dykstra_projection(S, max_iter=100):\n        \"\"\"\n        Computes the projection of a matrix S onto the intersection of\n        symmetric matrices and the passive (spectral norm = 1) matrices\n        using Dykstra's algorithm.\n        \"\"\"\n        X = S.copy()\n        Q = np.zeros_like(S, dtype=np.complex128)\n        R = np.zeros_like(S, dtype=np.complex128)\n\n        for _ in range(max_iter):\n            # Project onto C1 (symmetric matrices)\n            Y_temp = X + Q\n            Y = project_symmetric(Y_temp)\n            Q = Y_temp - Y\n            \n            # Project onto C2 (passive matrices)\n            X_temp = Y + R\n            X = project_passive(X_temp)\n            R = X_temp - X\n        \n        return X\n\n    overall_results = []\n    \n    for dataset_key in sorted(test_cases.keys()):\n        dataset = test_cases[dataset_key]\n        \n        reciprocal_before = True\n        passive_before = True\n        reciprocal_after = True\n        passive_after = True\n        total_perturbation = 0.0\n\n        for S_meas in dataset:\n            # Check reciprocity of measured matrix\n            if np.abs(S_meas[0, 1] - S_meas[1, 0]) > reciprocity_tol:\n                reciprocal_before = False\n            \n            # Check passivity of measured matrix\n            s_vals_before = np.linalg.svd(S_meas, compute_uv=False)\n            if np.max(s_vals_before) > 1.0 + passivity_tol:\n                passive_before = False\n                \n            # Compute the corrected surrogate matrix\n            S_tilde = dykstra_projection(S_meas)\n\n            # Check reciprocity of corrected matrix\n            if np.abs(S_tilde[0, 1] - S_tilde[1, 0]) > reciprocity_tol:\n                reciprocal_after = False\n\n            # Check passivity of corrected matrix\n            s_vals_after = np.linalg.svd(S_tilde, compute_uv=False)\n            if np.max(s_vals_after) > 1.0 + passivity_tol:\n                passive_after = False\n            \n            # Calculate and accumulate perturbation\n            perturbation = np.linalg.norm(S_meas - S_tilde, 'fro')\n            total_perturbation += perturbation\n\n        overall_results.append([\n            reciprocal_before,\n            passive_before,\n            reciprocal_after,\n            passive_after,\n            total_perturbation\n        ])\n\n    # Final print statement in the exact required format.\n    results_str_parts = []\n    for res in overall_results:\n        # Format: [bool,bool,bool,bool,float] with float rounded to 6 decimal places.\n        part = (f\"[{str(res[0]).lower()},{str(res[1]).lower()},{str(res[2]).lower()},{str(res[3]).lower()},\"\n                f\"{round(res[4], 6):.6f}]\")\n        results_str_parts.append(part)\n    final_output = f\"[{','.join(results_str_parts)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}