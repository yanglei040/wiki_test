{
    "hands_on_practices": [
        {
            "introduction": "The first step in any Particle-in-Cell (PIC) simulation is mapping the continuous particle positions to a discrete grid-based charge density, a process known as charge deposition. This practice explores the trade-offs between two foundational schemes: the simple Nearest-Grid-Point (NGP) and the smoother Cloud-in-Cell (CIC) method. By implementing both and measuring their error against the analytical result from Gauss's law, you will gain a quantitative understanding of their accuracy and the nature of discretization error in PIC simulations .",
            "id": "3310354",
            "problem": "You are given a uniform three-dimensional Cartesian grid and a single point charge. The objective is to compare two charge deposition schemes used in Particle-In-Cell (PIC) methods—nearest-cell deposition and cloud-in-cell deposition—and to evaluate the resulting discrete Gauss's law error in both the $L^2$ and maximum norms over the grid. The evaluation must be performed by computing approximate electric flux through each cell's closed surface using the continuous Coulomb electric field of the point charge and then comparing that flux-based enclosed charge to the deposited charge per cell for each scheme. Use normalized units with vacuum permittivity set to one, that is, $\\varepsilon_0 = 1$, and a unit charge $q = 1$, so all outputs are dimensionless floats with no physical units.\n\nFundamental base: Maxwell's equations in their electrostatic form require that the divergence of the electric field equals the charge density divided by the vacuum permittivity, that is, the differential Gauss's law $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$. The integral form asserts that the electric flux through any closed surface equals the total enclosed charge divided by the vacuum permittivity, that is, $\\oint_{\\partial V} \\mathbf{E} \\cdot \\mathrm{d}\\mathbf{A} = Q_{\\mathrm{enc}} / \\varepsilon_0$. In free space, the electrostatic field of a point charge is $\\mathbf{E}(\\mathbf{r}) = \\left(1/(4 \\pi \\varepsilon_0) \\right) q \\, (\\mathbf{r} - \\mathbf{r}_0)/\\|\\mathbf{r} - \\mathbf{r}_0\\|^3$.\n\nDiscrete setting and approximations:\n- Grid: Let the domain be the rectangular box $[0, L_x] \\times [0, L_y] \\times [0, L_z]$, partitioned into $N_x \\times N_y \\times N_z$ uniform cells with spacings $h_x = L_x/N_x$, $h_y = L_y/N_y$, $h_z = L_z/N_z$. Cell indices are $(i,j,k)$ with $i \\in \\{0,\\dots,N_x-1\\}$, $j \\in \\{0,\\dots,N_y-1\\}$, and $k \\in \\{0,\\dots,N_z-1\\}$. The center of cell $(i,j,k)$ is at coordinates $(x_i, y_j, z_k) = \\left((i + 0.5) h_x, (j + 0.5) h_y, (k + 0.5) h_z\\right)$.\n- Electric flux approximation: For each cell $(i,j,k)$, approximate the net electric flux through its closed surface using the midpoint rule on faces. The six face centers are\n  - left face center at $\\left(i h_x, (j+0.5) h_y, (k+0.5) h_z\\right)$ with outward normal $\\mathbf{n}_x^- = (-1,0,0)$ and area $A_x = h_y h_z$,\n  - right face center at $\\left((i+1) h_x, (j+0.5) h_y, (k+0.5) h_z\\right)$ with outward normal $\\mathbf{n}_x^+ = (1,0,0)$ and area $A_x = h_y h_z$,\n  - bottom face center at $\\left((i+0.5) h_x, j h_y, (k+0.5) h_z\\right)$ with outward normal $\\mathbf{n}_y^- = (0,-1,0)$ and area $A_y = h_x h_z$,\n  - top face center at $\\left((i+0.5) h_x, (j+1) h_y, (k+0.5) h_z\\right)$ with outward normal $\\mathbf{n}_y^+ = (0,1,0)$ and area $A_y = h_x h_z$,\n  - back face center at $\\left((i+0.5) h_x, (j+0.5) h_y, k h_z\\right)$ with outward normal $\\mathbf{n}_z^- = (0,0,-1)$ and area $A_z = h_x h_y$,\n  - front face center at $\\left((i+0.5) h_x, (j+0.5) h_y, (k+1) h_z\\right)$ with outward normal $\\mathbf{n}_z^+ = (0,0,1)$ and area $A_z = h_x h_y$.\n  Using the continuous Coulomb field of the point charge, denote by $\\mathbf{E}_{\\mathrm{face}}$ the field evaluated at the corresponding face center. The approximate net flux is then\n  $$\\Phi_{i,j,k} \\approx A_x \\left(\\mathbf{E}_{\\mathrm{right}} \\cdot \\mathbf{n}_x^+\\right) + A_x \\left(\\mathbf{E}_{\\mathrm{left}} \\cdot \\mathbf{n}_x^-\\right) + A_y \\left(\\mathbf{E}_{\\mathrm{top}} \\cdot \\mathbf{n}_y^+\\right) + A_y \\left(\\mathbf{E}_{\\mathrm{bottom}} \\cdot \\mathbf{n}_y^-\\right) + A_z \\left(\\mathbf{E}_{\\mathrm{front}} \\cdot \\mathbf{n}_z^+\\right) + A_z \\left(\\mathbf{E}_{\\mathrm{back}} \\cdot \\mathbf{n}_z^-\\right).$$\n- Nearest-cell deposition (NGP): Deposit the entire charge $q$ into the single cell that contains the point charge coordinates $\\mathbf{r}_0 = (x_0,y_0,z_0)$. That is, if $i^\\ast = \\lfloor x_0/h_x \\rfloor$, $j^\\ast = \\lfloor y_0/h_y \\rfloor$, $k^\\ast = \\lfloor z_0/h_z \\rfloor$, then the deposited charge for cell $(i,j,k)$ is\n  $$Q^{\\mathrm{NGP}}_{i,j,k} = \\begin{cases} q,  \\text{if } (i,j,k) = (i^\\ast,j^\\ast,k^\\ast), \\\\ 0,  \\text{otherwise.} \\end{cases}$$\n- Cloud-in-cell deposition (CIC): Deposit the charge $q$ into the $2 \\times 2 \\times 2$ block of cells whose centers immediately surround the point location $\\mathbf{r}_0$ along each axis via trilinear weights. Let $i_0 = \\left\\lfloor x_0/h_x - 0.5 \\right\\rfloor$, $j_0 = \\left\\lfloor y_0/h_y - 0.5 \\right\\rfloor$, $k_0 = \\left\\lfloor z_0/h_z - 0.5 \\right\\rfloor$, clamped so that $i_0 \\in \\{0,\\dots,N_x-2\\}$, $j_0 \\in \\{0,\\dots,N_y-2\\}$, and $k_0 \\in \\{0,\\dots,N_z-2\\}$. Define local fractional coordinates within the bracketing cell-center segment by $s_x = x_0/h_x - (i_0 + 0.5)$, $s_y = y_0/h_y - (j_0 + 0.5)$, $s_z = z_0/h_z - (k_0 + 0.5)$, each in $[0,1)$. The weights for the eight cells $(i_0 + a, j_0 + b, k_0 + c)$ with $a,b,c \\in \\{0,1\\}$ are $w_{a,b,c} = \\left(a s_x + (1-a)(1 - s_x)\\right) \\left(b s_y + (1-b)(1 - s_y)\\right) \\left(c s_z + (1-c)(1 - s_z)\\right)$, normalized so that $\\sum_{a,b,c} w_{a,b,c} = 1$, and the deposited charge is $Q^{\\mathrm{CIC}}_{i_0+a,j_0+b,k_0+c} = q \\, w_{a,b,c}$ for those eight cells and zero elsewhere.\n\nDiscrete Gauss's law error per cell: For each deposition scheme $\\mathcal{D} \\in \\{\\mathrm{NGP}, \\mathrm{CIC}\\}$, define the per-cell error as the difference between the approximated flux-based enclosed charge and the deposited charge,\n$$\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}/\\varepsilon_0.$$\nIn normalized units with $\\varepsilon_0 = 1$ and $q = 1$, this simplifies to $\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}$. Compute the global $L^2$ norm and maximum norm of the error over all cells for each deposition scheme as\n$$\\|\\mathcal{E}^{\\mathcal{D}}\\|_{2} = \\sqrt{\\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\sum_{k=0}^{N_z-1} \\left(\\mathcal{E}^{\\mathcal{D}}_{i,j,k}\\right)^2}, \\quad \\|\\mathcal{E}^{\\mathcal{D}}\\|_{\\infty} = \\max_{i,j,k} \\left| \\mathcal{E}^{\\mathcal{D}}_{i,j,k} \\right|.$$\n\nImplementation details:\n- Use the continuous Coulomb field $\\mathbf{E}(\\mathbf{r}) = \\left(1/(4 \\pi \\varepsilon_0)\\right) q (\\mathbf{r} - \\mathbf{r}_0)/\\|\\mathbf{r} - \\mathbf{r}_0\\|^3$ with $\\varepsilon_0 = 1$ and $q = 1$, hence $\\mathbf{E}(\\mathbf{r}) = \\left(1/(4 \\pi)\\right) (\\mathbf{r} - \\mathbf{r}_0)/\\|\\mathbf{r} - \\mathbf{r}_0\\|^3$.\n- Approximate the flux using the midpoint rule at each face center as described above.\n- Ensure that the point charge location avoids exact coincidence with any face center to prevent singular evaluations. In all given test cases, positions are chosen accordingly.\n\nTest suite:\nCompute the $(L^2, \\text{max})$ error norms for both nearest-cell deposition and cloud-in-cell deposition for each of the following test cases. All positions and lengths are in meters, but remember $\\varepsilon_0 = 1$ and $q = 1$ so the outputs are dimensionless floats.\n1. Case $1$: $N_x = 24$, $N_y = 22$, $N_z = 20$, $L_x = 1.2$, $L_y = 1.2$, $L_z = 1.2$, point charge at $(x_0, y_0, z_0) = (0.53, 0.47, 0.41)$.\n2. Case $2$: $N_x = 12$, $N_y = 10$, $N_z = 8$, $L_x = 1.0$, $L_y = 1.0$, $L_z = 1.0$, point charge at $(x_0, y_0, z_0) = (0.05, 0.92, 0.13)$.\n3. Case $3$: $N_x = 18$, $N_y = 18$, $N_z = 18$, $L_x = 0.9$, $L_y = 0.9$, $L_z = 0.9$, point charge at $(x_0, y_0, z_0) = (0.275, 0.225, 0.275)$.\n4. Case $4$: $N_x = 6$, $N_y = 6$, $N_z = 6$, $L_x = 1.0$, $L_y = 1.0$, $L_z = 1.0$, point charge at $(x_0, y_0, z_0) = (0.37, 0.58, 0.41)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, append four values in the following order: $L^2$ error for nearest-cell deposition, maximum error for nearest-cell deposition, $L^2$ error for cloud-in-cell deposition, maximum error for cloud-in-cell deposition. Concatenate these quadruples for the four cases to form one flat list. For example, the output format must be exactly\n$$[\\text{case1\\_L2\\_NGP},\\text{case1\\_Max\\_NGP},\\text{case1\\_L2\\_CIC},\\text{case1\\_Max\\_CIC},\\text{case2\\_L2\\_NGP},\\dots,\\text{case4\\_Max\\_CIC}].$$",
            "solution": "The problem requires a quantitative comparison of two common charge deposition schemes in computational electromagnetics, namely Nearest-Cell Deposition (also known as Nearest Grid Point, NGP) and Cloud-in-Cell (CIC), by evaluating the error in the discrete representation of Gauss's law.\n\nThe foundation of this analysis is Gauss's law in integral form, which states that the net electric flux $\\Phi$ through a closed surface $\\partial V$ is proportional to the total electric charge $Q_{\\mathrm{enc}}$ enclosed within the volume $V$:\n$$ \\oint_{\\partial V} \\mathbf{E} \\cdot \\mathrm{d}\\mathbf{A} = \\frac{Q_{\\mathrm{enc}}}{\\varepsilon_0} $$\nFor this problem, we are given a single point charge $q$ at position $\\mathbf{r}_0$ in vacuum. The electric field is given by Coulomb's law:\n$$ \\mathbf{E}(\\mathbf{r}) = \\frac{q}{4 \\pi \\varepsilon_0} \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\|\\mathbf{r} - \\mathbf{r}_0\\|^3} $$\nWith the specified normalization of $q=1$ and $\\varepsilon_0=1$, this simplifies to:\n$$ \\mathbf{E}(\\mathbf{r}) = \\frac{1}{4 \\pi} \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\|\\mathbf{r} - \\mathbf{r}_0\\|^3} $$\nThe core idea is to compute, for each cell in a Cartesian grid, two different versions of the enclosed charge:\n1.  A \"flux-based\" charge, $Q_{\\mathrm{flux}}$, derived by numerically approximating the flux integral $\\Phi_{i,j,k}$ over the cell's boundary and using Gauss's law: $Q_{\\mathrm{flux}, i,j,k} = \\varepsilon_0 \\Phi_{i,j,k}$.\n2.  A \"deposited\" charge, $Q^{\\mathcal{D}}_{i,j,k}$, obtained by applying a charge deposition scheme $\\mathcal{D} \\in \\{\\mathrm{NGP}, \\mathrm{CIC}\\}$.\n\nThe discrepancy between these two quantities, $\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}/\\varepsilon_0$, represents the local error in satisfying Gauss's law. With our normalization, this is simply $\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}$. We then quantify the global error using the $L^2$ and maximum norms.\n\nThe algorithm proceeds as follows for each test case:\n\n1.  **Grid and Parameter Initialization**: For a given domain of size $L_x \\times L_y \\times L_z$ and a grid of $N_x \\times N_y \\times N_z$ cells, we compute the cell spacings $h_x = L_x/N_x$, $h_y = L_y/N_y$, and $h_z = L_z/N_z$. The point charge $q=1$ is located at $\\mathbf{r}_0 = (x_0, y_0, z_0)$.\n\n2.  **Charge Deposition**: We compute the charge deposited into each cell $(i,j,k)$ for both schemes.\n    *   **NGP Scheme**: We find the cell indices $(i^\\ast, j^\\ast, k^\\ast)$ that contain $\\mathbf{r}_0$, where $i^\\ast = \\lfloor x_0/h_x \\rfloor$, $j^\\ast = \\lfloor y_0/h_y \\rfloor$, and $k^\\ast = \\lfloor z_0/h_z \\rfloor$. The entire charge $q=1$ is assigned to this single cell. All other cells receive zero charge. This creates a $N_x \\times N_y \\times N_z$ array $Q^{\\mathrm{NGP}}$.\n    *   **CIC Scheme**: This scheme distributes the charge among the $8$ cells whose centers bracket the particle's position. We first find the base index of this $2 \\times 2 \\times 2$ block: $i_0 = \\lfloor x_0/h_x - 0.5 \\rfloor$, $j_0 = \\lfloor y_0/h_y - 0.5 \\rfloor$, $k_0 = \\lfloor z_0/h_z - 0.5 \\rfloor$, ensuring these indices are clamped to remain within the grid bounds for the block. Then, we compute the fractional distances of the particle from the base cell center: $s_x = x_0/h_x - (i_0 + 0.5)$, $s_y = y_0/h_y - (j_0 + 0.5)$, and $s_z = z_0/h_z - (k_0 + 0.5)$. The charge is distributed to the $8$ cells $(i_0+a, j_0+b, k_0+c)$ for $a,b,c \\in \\{0,1\\}$ using trilinear interpolation weights. This creates a charge array $Q^{\\mathrm{CIC}}$.\n\n3.  **Numerical Flux Calculation**: We calculate the electric flux through the boundary of every cell. The problem specifies a midpoint rule approximation. For each cell $(i,j,k)$, the net flux $\\Phi_{i,j,k}$ is the sum of fluxes through its six faces.\n    $$ \\Phi_{i,j,k} \\approx \\sum_{\\text{faces } f} \\mathbf{E}(\\mathbf{r}_f) \\cdot \\mathbf{n}_f A_f $$\n    where $\\mathbf{r}_f$ is the center of a face, $\\mathbf{n}_f$ is its outward-pointing normal vector, and $A_f$ is its area. For example, for the \"right\" face ($x$ constant, maximum value), $\\mathbf{r}_f = ((i+1)h_x, (j+0.5)h_y, (k+0.5)h_z)$, $\\mathbf{n}_f = (1,0,0)$, and $A_f = h_y h_z$.\n    To implement this efficiently, we leverage vectorization. We generate 3D arrays representing the coordinates of all cell indices $(i,j,k)$. From these, we compute the coordinate arrays for the centers of all six face types (e.g., all \"left\" faces, all \"right\" faces, etc.). We then evaluate the electric field vector components on these six grids of face centers. The dot product with the respective normals and multiplication by the face area gives six 3D arrays of partial fluxes. Summing these six arrays yields a final 3D array $\\Phi$, where $\\Phi_{i,j,k}$ is the total approximate flux out of cell $(i,j,k)$.\n\n4.  **Error Calculation and Norms**: With the flux array $\\Phi$ and the charge arrays $Q^{\\mathrm{NGP}}$ and $Q^{\\mathrm{CIC}}$, we compute the error arrays for each scheme:\n    $$ \\mathcal{E}^{\\mathrm{NGP}} = \\Phi - Q^{\\mathrm{NGP}} $$\n    $$ \\mathcal{E}^{\\mathrm{CIC}} = \\Phi - Q^{\\mathrm{CIC}} $$\n    Finally, we compute the $L^2$ norm and maximum ($L^\\infty$) norm for each error array:\n    $$ \\|\\mathcal{E}^{\\mathcal{D}}\\|_{2} = \\sqrt{\\sum_{i,j,k} (\\mathcal{E}^{\\mathcal{D}}_{i,j,k})^2} $$\n    $$ \\|\\mathcal{E}^{\\mathcal{D}}\\|_{\\infty} = \\max_{i,j,k} |\\mathcal{E}^{\\mathcal{D}}_{i,j,k}| $$\n    These four scalar values (two norms for two schemes) are computed for each test case and appended to the final results list. The process is repeated for all cases provided in the problem statement.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # (Nx, Ny, Nz, Lx, Ly, Lz, (x0, y0, z0))\n        (24, 22, 20, 1.2, 1.2, 1.2, (0.53, 0.47, 0.41)),\n        (12, 10, 8, 1.0, 1.0, 1.0, (0.05, 0.92, 0.13)),\n        (18, 18, 18, 0.9, 0.9, 0.9, (0.275, 0.225, 0.275)),\n        (6, 6, 6, 1.0, 1.0, 1.0, (0.37, 0.58, 0.41)),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = calculate_errors_for_case(case)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef calculate_errors_for_case(case_params):\n    \"\"\"\n    Calculates the L2 and max errors for NGP and CIC schemes for a single test case.\n    \"\"\"\n    Nx, Ny, Nz, Lx, Ly, Lz, r0 = case_params\n    r0 = np.array(r0)\n    q = 1.0\n    eps0 = 1.0\n\n    hx, hy, hz = Lx / Nx, Ly / Ny, Lz / Nz\n    h = np.array([hx, hy, hz])\n    Ax, Ay, Az = hy * hz, hx * hz, hx * hy\n\n    # --- Charge Deposition ---\n\n    # NGP (Nearest-Cell Deposition)\n    Q_ngp = np.zeros((Nx, Ny, Nz))\n    i_star = int(np.floor(r0[0] / hx))\n    j_star = int(np.floor(r0[1] / hy))\n    k_star = int(np.floor(r0[2] / hz))\n    if 0 = i_star  Nx and 0 = j_star  Ny and 0 = k_star  Nz:\n        Q_ngp[i_star, j_star, k_star] = q\n\n    # CIC (Cloud-in-Cell)\n    Q_cic = np.zeros((Nx, Ny, Nz))\n    # Base cell index for the 2x2x2 cloud\n    i0 = int(np.floor(r0[0] / hx - 0.5))\n    j0 = int(np.floor(r0[1] / hy - 0.5))\n    k0 = int(np.floor(r0[2] / hz - 0.5))\n\n    # Clamp indices to ensure the 2x2x2 stencil is within the grid\n    i0 = np.clip(i0, 0, Nx - 2)\n    j0 = np.clip(j0, 0, Ny - 2)\n    k0 = np.clip(k0, 0, Nz - 2)\n\n    # Fractional coordinates relative to the base cell center\n    sx = r0[0] / hx - (i0 + 0.5)\n    sy = r0[1] / hy - (j0 + 0.5)\n    sz = r0[2] / hz - (k0 + 0.5)\n\n    # Trilinear weights\n    wx = [1 - sx, sx]\n    wy = [1 - sy, sy]\n    wz = [1 - sz, sz]\n\n    for a in range(2):\n        for b in range(2):\n            for c in range(2):\n                weight = wx[a] * wy[b] * wz[c]\n                Q_cic[i0 + a, j0 + b, k0 + c] = q * weight\n    \n    # --- Electric Field and Flux Calculation ---\n    \n    i_idx, j_idx, k_idx = np.indices((Nx, Ny, Nz))\n\n    def get_E_field(pos_x, pos_y, pos_z):\n        \"\"\"Vectorized E-field calculation.\"\"\"\n        rx = pos_x - r0[0]\n        ry = pos_y - r0[1]\n        rz = pos_z - r0[2]\n        dist_sq = rx**2 + ry**2 + rz**2\n        # Add a small epsilon to avoid division by zero if r coincides with r0.\n        # Problem statement guarantees no coincidence with face centers.\n        dist_cubed = dist_sq * np.sqrt(dist_sq) \n        factor = (q / (4 * np.pi * eps0)) / dist_cubed\n        return factor * rx, factor * ry, factor * rz\n\n    flux_total = np.zeros((Nx, Ny, Nz))\n\n    # Faces at x = constant\n    x_left = i_idx * hx\n    x_right = (i_idx + 1) * hx\n    y_x_face = (j_idx + 0.5) * hy\n    z_x_face = (k_idx + 0.5) * hz\n    Ex_left, _, _ = get_E_field(x_left, y_x_face, z_x_face)\n    Ex_right, _, _ = get_E_field(x_right, y_x_face, z_x_face)\n    flux_total += (Ex_right * 1.0 + Ex_left * -1.0) * Ax\n\n    # Faces at y = constant\n    y_bottom = j_idx * hy\n    y_top = (j_idx + 1) * hy\n    x_y_face = (i_idx + 0.5) * hx\n    z_y_face = (k_idx + 0.5) * hz\n    _, Ey_bottom, _ = get_E_field(x_y_face, y_bottom, z_y_face)\n    _, Ey_top, _ = get_E_field(x_y_face, y_top, z_y_face)\n    flux_total += (Ey_top * 1.0 + Ey_bottom * -1.0) * Ay\n\n    # Faces at z = constant\n    z_back = k_idx * hz\n    z_front = (k_idx + 1) * hz\n    x_z_face = (i_idx + 0.5) * hx\n    y_z_face = (j_idx + 0.5) * hy\n    _, _, Ez_back = get_E_field(x_z_face, y_z_face, z_back)\n    _, _, Ez_front = get_E_field(x_z_face, y_z_face, z_front)\n    flux_total += (Ez_front * 1.0 + Ez_back * -1.0) * Az\n\n    # --- Error Calculation ---\n    \n    # Error = Flux - Q_enclosed (with eps0=1)\n    error_ngp = flux_total - Q_ngp\n    error_cic = flux_total - Q_cic\n\n    # L2 and Max Norms\n    l2_ngp = np.sqrt(np.sum(error_ngp**2))\n    max_ngp = np.max(np.abs(error_ngp))\n    l2_cic = np.sqrt(np.sum(error_cic**2))\n    max_cic = np.max(np.abs(error_cic))\n    \n    return [l2_ngp, max_ngp, l2_cic, max_cic]\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "A robust numerical scheme must not only be accurate but also preserve fundamental physical laws, such as the conservation of momentum. A common pitfall in naive PIC implementations is the emergence of a \"spurious self-force,\" where a particle exerts a net force on itself, violating Newton's third law. This exercise demonstrates how this non-physical artifact arises from the choice of grid structure and discrete operators, allowing you to directly compare a staggered-grid (Yee) arrangement against a collocated-grid scheme and discover why symmetry is crucial for momentum conservation .",
            "id": "3338067",
            "problem": "Consider a one-dimensional, periodic electrostatic Particle-In-Cell (PIC) model on a uniform grid. The goal is to compare staggered-grid storage (Yee arrangement) versus collocated-grid storage of the electric field by quantifying the spurious self-force on a single particle held at rest exactly at a cell center. The comparison must be performed by computing the net self-force $\\mathbf{F}_{\\text{self}}$ (in Newtons) due solely to the particle’s own deposited charge and the numerical field solve and gathering, under scientifically consistent discrete assumptions.\n\nFoundational base and discrete model. Begin from Gauss’s law in differential form, $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$, and the electrostatic potential definition $\\mathbf{E} = -\\nabla \\phi$, with $\\varepsilon_0$ the vacuum permittivity. In one spatial dimension with periodic boundary conditions of domain length $L$, assume the charge density $\\rho(x)$ has zero spatial mean so that the discrete Poisson equation is solvable. Use a uniform grid of $N$ cells, cell size $\\Delta x = L/N$, with cell centers at locations $x_i = (i + \\tfrac{1}{2}) \\Delta x$ for integer $i \\in \\{0,1,\\dots,N-1\\}$. Store the electrostatic potential $\\phi$ at cell centers. Introduce a single particle at rest with charge $q$ located exactly at the center of cell index $i_0$, and neutralize its net charge by a uniform background of density $-q/L$, so that the discrete charge density is\n$$\n\\rho_i = \\frac{q}{\\Delta x} \\delta_{i,i_0} - \\frac{q}{L},\n$$\nwhere $\\delta_{i,i_0}$ is the Kronecker delta. Use cloud-in-cell (CIC) deposition and gathering, which in this special configuration reduces to weight one at $i_0$ and zero elsewhere for operations defined at cell centers, and weight one-half to each adjacent face for operations defined at cell faces.\n\nDefine and compare two field-storage and discrete-operator configurations:\n\n1. Staggered-grid (Yee arrangement): store the electric field component $E_x$ on cell faces at positions $x_{i+\\tfrac{1}{2}} = (i+1)\\Delta x$, while storing $\\rho$ and $\\phi$ at cell centers $x_i$. Compute $\\phi$ at centers by solving the periodic discrete Poisson equation in Fourier space,\n$$\n-\\Delta_d \\phi_i = \\frac{\\rho_i}{\\varepsilon_0},\n$$\nwith the discrete Laplacian eigenvalue $\\lambda_m = \\frac{4}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi m}{N}\\right)$ for mode index $m$. The zero mode is set to zero, $\\phi_{k=0} = 0$, ensuring zero-mean potential. Compute face-centered electric field via the discrete gradient $E_{x,i+\\tfrac{1}{2}} = -(\\phi_{i+1} - \\phi_i)/\\Delta x$, and gather to the particle at the center of cell $i_0$ by symmetric CIC averaging of the adjacent faces:\n$$\nE_{p}^{\\text{Yee}} = \\frac{1}{2}\\left(E_{x,i_0-\\tfrac{1}{2}} + E_{x,i_0+\\tfrac{1}{2}}\\right).\n$$\n\n2. Collocated-grid: store $E_x$ at cell centers together with $\\rho$ and $\\phi$. Compute $\\phi$ at centers by the same discrete Poisson equation as above. Then compute cell-centered $E_x$ using a forward-difference discrete gradient $E_{x,i} = -(\\phi_{i+1} - \\phi_i)/\\Delta x$. Gather to the particle using CIC weights at centers, which reduces to evaluation at the particle cell center:\n$$\nE_{p}^{\\text{Coll}} = E_{x,i_0}.\n$$\n\nIn both configurations, compute the self-force\n$$\n\\mathbf{F}_{\\text{self}} = q\\, E_{p} \\,\\hat{\\mathbf{x}},\n$$\nand report the scalar value $F_{\\text{self}} = q E_p$ in Newtons. The particle is at rest, so there is no magnetic force contribution.\n\nYour task. Implement a complete, runnable program that:\n- Constructs the discrete charge density $\\rho_i$ for the specified parameters.\n- Solves the periodic one-dimensional discrete Poisson equation in Fourier space for $\\phi_i$ using the discrete Laplacian eigenvalues given above, with $\\phi_{k=0}=0$.\n- Computes $E_x$ for both the staggered-grid and collocated-grid configurations as defined, gathers each to the particle position using CIC rules, and computes $F_{\\text{self}}$ for each configuration.\n- Produces numerical results for a specified test suite.\n\nUnits and output. Express all forces in Newtons. Angles are not applicable. The final program output must be a single line containing a comma-separated list of per-test-case results, where each result is the pair $[F_{\\text{self}}^{\\text{Yee}}, F_{\\text{self}}^{\\text{Coll}}]$ for that case. For example: \"[val1,val2,val3]\" where each \"valk\" is itself a list written as \"[F_Yee,F_Coll]\".\n\nTest suite. Use the following test cases, each specified by $(N, L, q, \\varepsilon_0)$:\n- Case A (happy path): $N = 64$, $L = 1.0$ m, $q = 1.0 \\times 10^{-9}$ C, $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ F/m.\n- Case B (coarse resolution boundary): $N = 8$, $L = 1.0$ m, $q = 1.0 \\times 10^{-9}$ C, $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ F/m.\n- Case C (sign edge case): $N = 64$, $L = 1.0$ m, $q = -1.0 \\times 10^{-9}$ C, $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ F/m.\n- Case D (larger domain, finer grid): $N = 256$, $L = 2.0$ m, $q = 5.0 \\times 10^{-10}$ C, $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ F/m.\n\nImplementation constraints. The program must be self-contained, require no input, and strictly use the runtime environment specified in the final answer. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each per-case result itself a two-element list: \"[[F_A_Yee,F_A_Coll],[F_B_Yee,F_B_Coll],[F_C_Yee,F_C_Coll],[F_D_Yee,F_D_Coll]]\".",
            "solution": "The problem statement is critically validated and found to be valid. It is scientifically sound, self-contained, well-posed, and describes a standard numerical experiment in computational plasma physics for analyzing spurious self-forces in Particle-In-Cell (PIC) methods. All required parameters, equations, and discrete operators are unambiguously defined.\n\nThe solution proceeds by implementing the specified numerical algorithm. We will calculate the spurious self-force on a single particle at rest at a grid cell center for two different numerical schemes: a staggered-grid (Yee) scheme and a collocated-grid scheme.\n\n**1. Model Discretization and Setup**\n\nFor each test case, we are given the number of grid cells $N$, the domain length $L$, the particle charge $q$, and the vacuum permittivity $\\varepsilon_0$.\nThe grid cell size is $\\Delta x = L/N$. The domain consists of $N$ cells, with centers at $x_i = (i + \\tfrac{1}{2})\\Delta x$ for $i \\in \\{0, 1, \\dots, N-1\\}$.\n\nA single particle of charge $q$ is placed at the center of cell $i_0$. Due to the periodic nature of the domain, the choice of $i_0$ is arbitrary; we select $i_0 = N/2$ for convenience. The Cloud-In-Cell (CIC) charge deposition scheme for a particle at a cell center simplifies to depositing the entire charge into that cell. To ensure the solvability of the periodic Poisson equation, a neutralizing background charge density $-q/L$ is added. The discrete charge density at each cell center $i$ is thus:\n$$\n\\rho_i = \\frac{q}{\\Delta x} \\delta_{i,i_0} - \\frac{q}{L}\n$$\nwhere $\\delta_{i,i_0}$ is the Kronecker delta. This formulation correctly ensures that the total charge in the domain is zero: $\\sum_{i=0}^{N-1} \\rho_i \\Delta x = 0$.\n\n**2. Solving the Discrete Poisson Equation**\n\nThe electrostatic potential $\\phi$ is stored at the cell centers $x_i$ and is related to the charge density $\\rho_i$ by the discrete Poisson equation:\n$$\n-\\Delta_d \\phi_i = \\frac{\\rho_i}{\\varepsilon_0}\n$$\nwhere $-\\Delta_d$ is the discrete negative Laplacian operator. We solve this equation in Fourier space, as specified. Let $\\tilde{\\phi}_m$ and $\\tilde{\\rho}_m$ be the Discrete Fourier Transforms (DFTs) of $\\phi_i$ and $\\rho_i$, respectively. The equation transforms to:\n$$\n\\lambda_m \\tilde{\\phi}_m = \\frac{\\tilde{\\rho}_m}{\\varepsilon_0}\n$$\nwhere $\\lambda_m$ are the eigenvalues of the $-\\Delta_d$ operator, given by:\n$$\n\\lambda_m = \\frac{4}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi m}{N}\\right) \\quad \\text{for mode index } m \\in \\{0, 1, \\dots, N-1\\}\n$$\nFor the DC mode $m=0$, we have $\\lambda_0 = 0$. The zero-mean charge density ensures $\\tilde{\\rho}_0 = \\sum_i \\rho_i = 0$, making the $m=0$ equation $0 \\cdot \\tilde{\\phi}_0 = 0$. The problem specifies setting the mean potential to zero, which translates to $\\tilde{\\phi}_0 = 0$. For all other modes ($m  0$), we can solve for $\\tilde{\\phi}_m$:\n$$\n\\tilde{\\phi}_m = \\frac{\\tilde{\\rho}_m}{\\varepsilon_0 \\lambda_m}\n$$\nThe algorithm for finding the potential $\\phi_i$ is as follows:\n1. Construct the real-space charge density array $\\rho_i$.\n2. Compute its DFT $\\tilde{\\rho}_m$ using a Fast Fourier Transform (FFT) algorithm.\n3. Compute the eigenvalues $\\lambda_m$.\n4. Construct the Fourier-space potential $\\tilde{\\phi}_m$ using the formula above, setting $\\tilde{\\phi}_0 = 0$.\n5. Compute the inverse DFT of $\\tilde{\\phi}_m$ to obtain $\\phi_i$. Since the initial $\\rho_i$ is real and exhibits symmetry, the resulting $\\phi_i$ will be real (up to numerical precision errors).\n\n**3. Self-Force Calculation: Staggered-Grid (Yee) Scheme**\n\nIn the Yee scheme, the electric field $E_x$ is staggered from the potential $\\phi$, stored on cell faces at locations $x_{i+\\tfrac{1}{2}} = (i+1)\\Delta x$. The discrete gradient is a central difference:\n$$\nE_{x,i+\\tfrac{1}{2}} = -\\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}\n$$\nThe particle is at $x_{i_0}$. The electric field at the particle's position, $E_{p}^{\\text{Yee}}$, is gathered using CIC weights. For a particle at a cell center, this means averaging the fields from the two adjacent faces:\n$$\nE_{p}^{\\text{Yee}} = \\frac{1}{2}\\left(E_{x,i_0-\\tfrac{1}{2}} + E_{x,i_0+\\tfrac{1}{2}}\\right) = \\frac{1}{2}\\left( -\\frac{\\phi_{i_0} - \\phi_{i_0-1}}{\\Delta x} - \\frac{\\phi_{i_0+1} - \\phi_{i_0}}{\\Delta x} \\right) = -\\frac{\\phi_{i_0+1} - \\phi_{i_0-1}}{2\\Delta x}\n$$\nDue to the symmetry of the problem setup (a single point charge in a periodic domain), the resulting potential $\\phi_i$ must be symmetric about the particle's location $i_0$. That is, $\\phi_{i_0+k} = \\phi_{i_0-k}$ for any integer $k$. In particular, $\\phi_{i_0+1} = \\phi_{i_0-1}$. Consequently, the gathered electric field $E_{p}^{\\text{Yee}}$ is analytically zero.\nThe self-force is $F_{\\text{self}}^{\\text{Yee}} = q E_{p}^{\\text{Yee}} = 0$. Any non-zero result will be due to floating-point representation errors and should be negligible.\n\n**4. Self-Force Calculation: Collocated-Grid Scheme**\n\nIn the collocated scheme, the electric field $E_x$ is stored at the same cell-center locations $x_i$ as $\\phi$ and $\\rho$. The potential $\\phi_i$ is computed in the same way as before. The discrete gradient is specified as a forward difference:\n$$\nE_{x,i} = -\\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}\n$$\nThe field is gathered at the particle's location $i_0$. For a particle at a cell center, CIC gathering simplifies to direct evaluation:\n$$\nE_{p}^{\\text{Coll}} = E_{x,i_0} = -\\frac{\\phi_{i_0+1} - \\phi_{i_0}}{\\Delta x}\n$$\nAs established, the potential $\\phi_i$ has a symmetric extremum at $i_0$ (a peak for $q0$, a trough for $q0$). Therefore, $\\phi_{i_0+1} \\neq \\phi_{i_0}$, and the field $E_{p}^{\\text{Coll}}$ will be non-zero. This non-zero field results from the asymmetry of the forward-difference operator. The resulting self-force is:\n$$\nF_{\\text{self}}^{\\text{Coll}} = q E_{p}^{\\text{Coll}} = -q\\frac{\\phi_{i_0+1} - \\phi_{i_0}}{\\Delta x}\n$$\nAn analytical calculation reveals that this force evaluates to $F_{\\text{self}}^{\\text{Coll}} = \\frac{q^2(N-1)}{2N\\varepsilon_0}$. This force is always positive (in the $+\\hat{\\mathbf{x}}$ direction) and approaches a constant value of $q^2/(2\\varepsilon_0)$ as $N \\to \\infty$. This confirms that the collocated scheme with a forward-difference gradient produces a significant and systematic spurious self-force.\n\nThe program below implements these calculations for the provided test suite.",
            "answer": "```python\nimport numpy as np\n\ndef calculate_forces(N, L, q, epsilon_0):\n    \"\"\"\n    Calculates the spurious self-force for staggered and collocated schemes.\n\n    Args:\n        N (int): Number of grid cells.\n        L (float): Length of the 1D periodic domain.\n        q (float): Charge of the particle.\n        epsilon_0 (float): Vacuum permittivity.\n\n    Returns:\n        list: A two-element list containing [F_self_Yee, F_self_Coll].\n    \"\"\"\n    # 1. Setup Grid and Charge Density\n    dx = L / N\n    # Place particle at the center of cell i0 for symmetry\n    i0 = N // 2\n    \n    # Create the discrete charge density array rho_i\n    # rho_i = (q / dx) * delta_{i,i0} - q / L\n    rho = np.full(N, -q / L)\n    rho[i0] += q / dx\n\n    # 2. Solve Poisson's Equation for phi\n    # FFT of the charge density\n    rho_tilde = np.fft.fft(rho)\n\n    # Eigenvalues of the discrete negative Laplacian\n    m = np.arange(N)\n    # The m=0 eigenvalue is 0. Avoid division by zero.\n    with np.errstate(divide='ignore', invalid='ignore'):\n        lambda_m = (4.0 / dx**2) * np.sin(np.pi * m / N)**2\n\n    # Solve for phi_tilde in Fourier space: phi_tilde = rho_tilde / (epsilon_0 * lambda)\n    phi_tilde = np.zeros(N, dtype=complex)\n    # For m  0 (lambda_m != 0)\n    phi_tilde[1:] = rho_tilde[1:] / (epsilon_0 * lambda_m[1:])\n    # For m = 0, phi_tilde[0] is 0 as specified (zero mean potential).\n\n    # Inverse FFT to get phi in real space\n    phi = np.fft.ifft(phi_tilde)\n    phi = np.real(phi) # Potential should be real, discard negligible imag part\n\n    # 3. Calculate Staggered-Grid (Yee) Force\n    # E_p^Yee = - (phi_{i0+1} - phi_{i0-1}) / (2 * dx)\n    # Handle periodic boundary conditions for indices\n    i_prev = (i0 - 1 + N) % N\n    i_next = (i0 + 1) % N\n    \n    phi_prev = phi[i_prev]\n    phi_next = phi[i_next]\n\n    E_p_Yee = - (phi_next - phi_prev) / (2.0 * dx)\n    F_self_Yee = q * E_p_Yee\n\n    # 4. Calculate Collocated-Grid Force\n    # E_p^Coll = - (phi_{i0+1} - phi_{i0}) / (dx)\n    phi_i0 = phi[i0]\n    \n    E_p_Coll = - (phi_next - phi_i0) / dx\n    F_self_Coll = q * E_p_Coll\n\n    return [F_self_Yee, F_self_Coll]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Test suite: (N, L, q, epsilon_0)\n    test_cases = [\n        # Case A: happy path\n        (64, 1.0, 1.0e-9, 8.8541878128e-12),\n        # Case B: coarse resolution boundary\n        (8, 1.0, 1.0e-9, 8.8541878128e-12),\n        # Case C: sign edge case\n        (64, 1.0, -1.0e-9, 8.8541878128e-12),\n        # Case D: larger domain, finer grid\n        (256, 2.0, 5.0e-10, 8.8541878128e-12),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, q, epsilon_0 = case\n        forces = calculate_forces(N, L, q, epsilon_0)\n        results.append(forces)\n\n    # Format the output string exactly as required, removing spaces\n    formatted_results = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While many numerical methods aim to minimize error, certain combinations of algorithms can satisfy physical laws *exactly* in their discrete form, leading to superior long-term stability. This practice guides you through the implementation of a \"Gauss's law-preserving\" scheme, which combines the CIC deposition method with a spectral (FFT-based) Poisson solver for periodic systems. By verifying that the discrete divergence of the computed electric field precisely matches the deposited charge density, you will understand one of the most powerful and elegant properties of modern PIC methods .",
            "id": "3529021",
            "problem": "You are given a two-dimensional, periodic domain and a set of particle trajectories over a single time step. Your task is to implement a charge and current deposition scheme using the Cloud-In-Cell (CIC) method on a uniform Cartesian mesh and to verify that the discrete Gauss’s law residual remains bounded when the electric field is computed from the deposited charge by solving a periodic Poisson equation with a neutralizing background.\n\nStarting from the following fundamental base:\n- Maxwell’s equations (specifically Gauss’s law): $\\nabla \\cdot \\mathbf{E} = \\rho / \\epsilon_0$.\n- The definition of current density from point charges: $\\mathbf{J}(\\mathbf{x},t) = \\sum_p q_p \\mathbf{v}_p(t) \\delta(\\mathbf{x} - \\mathbf{x}_p(t))$, where $q_p$, $\\mathbf{x}_p$, and $\\mathbf{v}_p$ are the charge, position, and velocity of particle $p$, respectively.\n- The continuity equation: $\\partial \\rho / \\partial t + \\nabla \\cdot \\mathbf{J} = 0$.\n- The Cloud-In-Cell (CIC) method interpreted as using a first-order separable triangular particle shape function $S(x) S(y)$ to distribute particle properties to the grid.\n\nImplement the following in normalized units with $\\epsilon_0 = 1$:\n1. A uniform grid with $N_x$ cells in the $x$ direction, $N_y$ cells in the $y$ direction, domain lengths $L_x$ and $L_y$, and periodic boundary conditions in both directions. Let the cell sizes be $d_x = L_x / N_x$ and $d_y = L_y / N_y$. Place scalar fields $\\rho$ and $\\phi$ at cell centers indexed by $(i,j)$ for $i \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$, corresponding to positions $x_i = (i + 1/2) d_x$ and $y_j = (j + 1/2) d_y$.\n2. CIC deposition of charge density $\\rho$ at time $t^{n+1}$ from particle positions $(x_p^{n+1}, y_p^{n+1})$. Each particle $p$ with charge $q_p$ contributes to the four nearest cell centers with weights determined by linear interpolation based on its fractional position within the host cell. Ensure that the deposited quantity is the charge per unit area, i.e., weight the particle charge by the CIC weights and divide by the cell area $d_x d_y$.\n3. CIC deposition of current density $\\mathbf{J} = (J_x, J_y)$ over the interval $\\Delta t = t^{n+1} - t^n$ using the particle velocity $\\mathbf{v}_p^{n+1/2} = \\left((x_p^{n+1} - x_p^n)/\\Delta t, (y_p^{n+1} - y_p^n)/\\Delta t\\right)$ inferred from periodic displacement. Compute the midpoint position $\\left(x_p^{n+1/2}, y_p^{n+1/2}\\right)$ using the periodic displacement and deposit $\\mathbf{J}$ at $t^{n+1/2}$ to the same four nearest cell centers of the midpoint with CIC weights. Each particle contributes $q_p \\mathbf{v}_p^{n+1/2}$ divided by the cell area $d_x d_y$, weighted by the CIC factors. Use the shortest periodic displacement convention so that if $\\Delta x_p = x_p^{n+1} - x_p^n$ then $\\Delta x_p \\leftarrow \\Delta x_p - L_x$ when $\\Delta x_p  L_x/2$, and $\\Delta x_p \\leftarrow \\Delta x_p + L_x$ when $\\Delta x_p  -L_x/2$, and similarly for $\\Delta y_p$.\n4. Compute the electric field $\\mathbf{E} = - \\nabla \\phi$ at time $t^{n+1}$ by solving the periodic Poisson equation for the potential $\\phi$,\n   $$ \\nabla^2 \\phi = - \\frac{\\rho^{n+1} - \\langle \\rho^{n+1} \\rangle}{\\epsilon_0}, $$\n   where $\\langle \\rho^{n+1} \\rangle$ is the spatial mean of $\\rho^{n+1}$ over the domain. Solve this equation in Fourier space using a discrete Fourier transform consistent with the periodic grid, setting the zero mode of $\\phi$ to zero. Then compute $\\mathbf{E}$ in Fourier space by $\\hat{E}_x = - i k_x \\hat{\\phi}$ and $\\hat{E}_y = - i k_y \\hat{\\phi}$, where $k_x = 2 \\pi m / L_x$ and $k_y = 2 \\pi n / L_y$ for integer mode indices.\n5. Compute the discrete Gauss’s law residual at time $t^{n+1}$ as\n   $$ R = \\nabla \\cdot \\mathbf{E}^{n+1} - \\frac{\\rho^{n+1} - \\langle \\rho^{n+1} \\rangle}{\\epsilon_0}, $$\n   using spectral differentiation for the divergence. Evaluate the residual using the uniform grid you constructed and compute the discrete $L_\\infty$ norm of $R$ over all grid cells, i.e., $\\|R\\|_\\infty = \\max_{i,j} |R_{i,j}|$. This norm is dimensionless under the chosen normalization.\n\nTest Suite:\nImplement your program to run the following three test cases. For all cases, use $\\epsilon_0 = 1$ and express all lengths in the same arbitrary length unit and time steps in the same arbitrary time unit. The returned results must be the $L_\\infty$ norms of the Gauss residual for each case, as floating-point numbers.\n\n- Case A (general motion with mixed charges and boundary crossings):\n  - Grid: $N_x = 16$, $N_y = 12$, $L_x = 1.0$, $L_y = 1.2$, $\\Delta t = 0.05$.\n  - Particles: $N_p = 5$ with charges $[+1.0, -1.0, +1.0, +1.0, -1.0]$.\n  - Positions at $t^n$: $\\left[(0.12, 0.21), (0.88, 1.10), (0.33, 0.77), (0.61, 0.44), (0.97, 0.05)\\right]$.\n  - Displacements over $\\Delta t$ (before periodic wrapping): $\\left[(+0.08, -0.03), (+0.20, +0.15), (-0.40, +0.10), (0.00, 0.00), (+0.10, -0.08)\\right]$.\n  - The positions at $t^{n+1}$ are the initial positions plus the displacements, wrapped periodically into $[0, L_x) \\times [0, L_y)$.\n\n- Case B (multiple boundary crossings and uniform positive charge):\n  - Grid: $N_x = 8$, $N_y = 8$, $L_x = 1.0$, $L_y = 1.0$, $\\Delta t = 0.10$.\n  - Particles: $N_p = 4$ with charges $[+1.0, +1.0, +1.0, +1.0]$.\n  - Positions at $t^n$: $\\left[(0.20, 0.20), (0.70, 0.30), (0.40, 0.80), (0.95, 0.95)\\right]$.\n  - Displacements over $\\Delta t$ (before periodic wrapping): $\\left[(+0.50, 0.00), (0.00, +0.50), (-0.60, -0.60), (+0.20, +0.20)\\right]$.\n  - The positions at $t^{n+1}$ are computed as above with periodic wrapping.\n\n- Case C (single particle, strong neutralization test):\n  - Grid: $N_x = 4$, $N_y = 4$, $L_x = 1.0$, $L_y = 1.0$, $\\Delta t = 0.20$.\n  - Particles: $N_p = 1$ with charge $[+2.0]$.\n  - Position at $t^n$: $\\left[(0.49, 0.51)\\right]$.\n  - Displacement over $\\Delta t$ (before periodic wrapping): $\\left[(+0.05, -0.07)\\right]$.\n  - The position at $t^{n+1}$ is computed as above with periodic wrapping.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, i.e., $\\left[\\|R\\|_\\infty^{(A)}, \\|R\\|_\\infty^{(B)}, \\|R\\|_\\infty^{(C)}\\right]$, where each entry is a floating-point number computed for the corresponding case.\n- No additional text should be printed.\n\nAssumptions and notes:\n- Use periodic boundary conditions in both directions.\n- Use normalized units with $\\epsilon_0 = 1$; under these units, the Gauss residual $\\|R\\|_\\infty$ is dimensionless.\n- All angles, if any appear, are not required. No trigonometric angles need to be reported.\n- The CIC deposition must be consistent with the grid interpretation described above and must conserve total deposited charge on the grid up to floating-point roundoff when summing over all cells.",
            "solution": "### Problem Validation\n\nThe problem statement has been critically examined and is determined to be **valid**.\n\n#### Step 1: Extracted Givens\n- **Domain**: A two-dimensional, periodic domain with lengths $L_x$ and $L_y$.\n- **Grid**: A uniform Cartesian mesh with $N_x \\times N_y$ cells. Cell sizes are $d_x = L_x / N_x$ and $d_y = L_y / N_y$.\n- **Field Locations**: Scalar fields $\\rho$ and $\\phi$ are located at cell centers $(x_i, y_j) = ((i + 1/2)d_x, (j + 1/2)d_y)$ for $i \\in \\{0, \\dots, N_x-1\\}$ and $j \\in \\{0, \\dots, N_y-1\\}$.\n- **Fundamental Physics**:\n  - Gauss's Law: $\\nabla \\cdot \\mathbf{E} = \\rho / \\epsilon_0$.\n  - Current Density: $\\mathbf{J}(\\mathbf{x},t) = \\sum_p q_p \\mathbf{v}_p(t) \\delta(\\mathbf{x} - \\mathbf{x}_p(t))$.\n  - Continuity Equation: $\\partial \\rho / \\partial t + \\nabla \\cdot \\mathbf{J} = 0$.\n- **Numerical Methods**:\n  - **Particle Shape**: First-order separable triangular shape function, corresponding to the Cloud-In-Cell (CIC) method.\n  - **Charge Deposition**: CIC deposition of charge $q_p$ from particle positions $(x_p^{n+1}, y_p^{n+1})$ to the four nearest cell centers to form $\\rho^{n+1}$. The deposited quantity is charge per unit area, requiring division by cell area $d_x d_y$.\n  - **Current Deposition**: CIC deposition of current density from particle midpoint positions $(x_p^{n+1/2}, y_p^{n+1/2})$ and velocities $\\mathbf{v}_p^{n+1/2} = (\\mathbf{x}_p^{n+1} - \\mathbf{x}_p^n)/\\Delta t$. The velocity calculation must use the shortest periodic displacement.\n  - **Poisson Solver**: Solve $\\nabla^2 \\phi = - (\\rho^{n+1} - \\langle \\rho^{n+1} \\rangle) / \\epsilon_0$ in Fourier space. The zero-frequency mode $\\hat{\\phi}_{k=0}$ is set to $0$.\n  - **Field Calculation**: Compute $\\mathbf{E}^{n+1}$ from $\\phi^{n+1}$ using spectral differentiation: $\\hat{\\mathbf{E}} = -i\\mathbf{k}\\hat{\\phi}$.\n  - **Residual Calculation**: Compute the residual $R = \\nabla \\cdot \\mathbf{E}^{n+1} - (\\rho^{n+1} - \\langle \\rho^{n+1} \\rangle)/\\epsilon_0$ using spectral differentiation for the divergence. The metric is the discrete $L_\\infty$ norm of $R$.\n- **Constants and Units**: $\\epsilon_0 = 1$. Normalized units are used.\n- **Test Cases**:\n  - **Case A**: $N_x = 16, N_y = 12, L_x = 1.0, L_y = 1.2, \\Delta t = 0.05$. $N_p = 5$ with $q = [+1.0, -1.0, +1.0, +1.0, -1.0]$, initial positions, and displacements are provided.\n  - **Case B**: $N_x = 8, N_y = 8, L_x = 1.0, L_y = 1.0, \\Delta t = 0.10$. $N_p = 4$ with $q = [+1.0, +1.0, +1.0, +1.0]$, initial positions, and displacements are provided.\n  - **Case C**: $N_x = 4, N_y = 4, L_x = 1.0, L_y = 1.0, \\Delta t = 0.20$. $N_p = 1$ with $q = [+2.0]$, initial position, and displacement are provided.\n\n#### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the well-established theory of plasma physics and computational methods (Particle-In-Cell). The required tasks are formalizable and directly relevant to the topic of PIC methods in computational astrophysics. The problem is self-contained, with all necessary parameters and conditions provided for each test case. The setup is internally consistent; while the calculation of the current density $\\mathbf{J}$ is not ultimately required for the computation of the final residual $R^{n+1}$ (as $R^{n+1}$ depends only on $\\rho^{n+1}$ and the field derived from it), its inclusion is a common feature of problems designed to test a comprehensive understanding of PIC cycles. The problem is well-posed, leading to a unique numerical result. The language is objective and precise.\n\n#### Step 3: Verdict and Action\nThe problem is **valid**. A complete solution will be provided.\n\n### Solution\n\nThe solution involves a sequence of steps derived from the Particle-In-Cell (PIC) methodology. We will first compute the particle states at the required time steps, then deposit charge and current densities onto the grid, solve for the electric field via a spectral Poisson solver, and finally compute the Gauss's law residual.\n\n#### 1. Grid Definition\nA two-dimensional Cartesian grid is defined over the domain $[0, L_x) \\times [0, L_y)$ with $N_x \\times N_y$ cells. The cell dimensions are $d_x = L_x / N_x$ and $d_y = L_y / N_y$. Scalar quantities, such as the charge density $\\rho$ and electrostatic potential $\\phi$, are defined at the centers of these cells. The position of the cell center $(i, j)$ is given by $\\mathbf{x}_{i,j} = ((i + 1/2)d_x, (j + 1/2)d_y)$.\n\n#### 2. Particle State Update\nFor each particle $p$, we are given its position $\\mathbf{x}_p^n$ at time $t^n$ and its raw displacement over the time step $\\Delta t = t^{n+1} - t^n$.\n\nThe position at time $t^{n+1}$ is found by adding the displacement and applying periodic boundary conditions:\n$$ \\mathbf{x}_p^{n+1} = (\\mathbf{x}_p^n + \\Delta \\mathbf{x}_{p, \\text{raw}}) \\pmod{\\mathbf{L}} $$\nwhere $\\mathbf{L} = (L_x, L_y)$ and the modulo operation is applied component-wise.\n\nFor the current deposition, we need the particle velocity $\\mathbf{v}_p^{n+1/2}$ and midpoint position $\\mathbf{x}_p^{n+1/2}$. The velocity is inferred from the shortest periodic displacement. For the $x$-component, this displacement $\\Delta x_p$ is:\n$$ \\Delta x_p = \\Delta x_{p, \\text{raw}} - \\text{round}(\\Delta x_{p, \\text{raw}} / L_x) \\cdot L_x $$\nand similarly for the $y$-component. The velocity is then $\\mathbf{v}_p^{n+1/2} = \\Delta \\mathbf{x}_p / \\Delta t$.\nThe midpoint position is $\\mathbf{x}_p^{n+1/2} = (\\mathbf{x}_p^n + \\frac{1}{2}\\Delta\\mathbf{x}_p) \\pmod{\\mathbf{L}}$.\n\n#### 3. Charge and Current Deposition (CIC)\nThe Cloud-In-Cell (CIC) method uses a first-order weighting to distribute particle quantities to the grid. For a particle at a generic position $\\mathbf{x}_p = (x_p, y_p)$, we first find its logical coordinates relative to the grid of cell centers:\n$$ x_{log} = \\frac{x_p}{d_x} - \\frac{1}{2}, \\quad y_{log} = \\frac{y_p}{d_y} - \\frac{1}{2} $$\nThe integer parts of these coordinates, $i = \\lfloor x_{log} \\rfloor$ and $j = \\lfloor y_{log} \\rfloor$, identify the lower-left cell center of the four centers surrounding the particle. The fractional parts, $W_x = x_{log} - i$ and $W_y = y_{log} - j$, serve as interpolation weights.\n\nThe four cell centers involved are $(i,j), (i+1,j), (i,j+1), (i+1,j+1)$, with indices wrapped periodically. A particle quantity $Q_p$ is distributed with the following weights:\n- To cell $(i,j)$: $w_{i,j} = (1 - W_x)(1 - W_y)$\n- To cell $(i+1,j)$: $w_{i+1,j} = W_x(1 - W_y)$\n- To cell $(i,j+1)$: $w_{i,j+1} = (1 - W_x)W_y$\n- To cell $(i+1,j+1)$: $w_{i+1,j+1} = W_x W_y$\n\n**Charge Density $\\rho^{n+1}$**: We use the particle positions $\\mathbf{x}_p^{n+1}$ to compute the weights. The charge density at grid cell $(k,l)$ is the sum of contributions from all particles, divided by the cell area $A = d_x d_y$:\n$$ \\rho_{k,l}^{n+1} = \\frac{1}{A} \\sum_p q_p w_{k,l}(\\mathbf{x}_p^{n+1}) $$\n\n**Current Density $\\mathbf{J}^{n+1/2}$**: We use the midpoint positions $\\mathbf{x}_p^{n+1/2}$ to compute the weights. Each particle contributes $q_p \\mathbf{v}_p^{n+1/2}$ to the grid:\n$$ \\mathbf{J}_{k,l}^{n+1/2} = \\frac{1}{A} \\sum_p q_p \\mathbf{v}_p^{n+1/2} w_{k,l}(\\mathbf{x}_p^{n+1/2}) $$\nThis scheme ensures that the discrete continuity equation is satisfied exactly, a property known as charge conservation. Although $\\mathbf{J}$ is not used in the final residual calculation as specified, its computation is part of a complete PIC step.\n\n#### 4. Electric Field Calculation\nThe electric field $\\mathbf{E}^{n+1}$ is found by solving the periodic Poisson equation for the potential $\\phi^{n+1}$:\n$$ \\nabla^2 \\phi^{n+1} = - \\frac{\\rho^{n+1} - \\langle \\rho^{n+1} \\rangle}{\\epsilon_0} $$\nwhere $\\langle \\rho^{n+1} \\rangle$ is the mean charge density, which acts as a neutralizing background. We solve this efficiently in Fourier space. Applying a discrete Fourier transform (DFT) yields:\n$$ \\widehat{(\\nabla^2 \\phi^{n+1})}_{\\mathbf{k}} = - \\frac{\\hat{\\rho}^{n+1}_{\\mathbf{k}} - \\widehat{\\langle \\rho^{n+1} \\rangle}_{\\mathbf{k}}}{\\epsilon_0} $$\nThe DFT of the Laplacian is $-k^2 = -(k_x^2 + k_y^2)$, where $k_x = 2\\pi m / L_x$ and $k_y = 2\\pi n / L_y$ are the wavenumbers. The DFT of the mean is a delta function at $\\mathbf{k}=0$. Thus, for each mode $\\mathbf{k}$:\n$$ -k^2 \\hat{\\phi}^{n+1}_{\\mathbf{k}} = - \\frac{\\hat{\\rho}^{n+1}_{\\mathbf{k}}}{\\epsilon_0} \\quad (\\text{for } \\mathbf{k} \\neq 0) $$\nWe can solve for $\\hat{\\phi}^{n+1}_{\\mathbf{k}}$:\n$$ \\hat{\\phi}^{n+1}_{\\mathbf{k}} = \\frac{1}{k^2 \\epsilon_0} \\hat{\\rho}^{n+1}_{\\mathbf{k}} $$\nFor the zero-frequency mode ($\\mathbf{k}=0$), the equation is $0=0$. We set $\\hat{\\phi}^{n+1}_{\\mathbf{k}=0} = 0$ to ensure a unique solution.\n\nWith $\\hat{\\phi}^{n+1}$ known, the Fourier representation of the electric field $\\mathbf{E}^{n+1} = -\\nabla\\phi^{n+1}$ is simply:\n$$ \\hat{\\mathbf{E}}^{n+1}_{\\mathbf{k}} = -i\\mathbf{k} \\hat{\\phi}^{n+1}_{\\mathbf{k}} $$\nAn inverse DFT yields $\\mathbf{E}^{n+1}$ on the real-space grid.\n\n#### 5. Gauss's Law Residual\nThe final step is to compute the discrete Gauss's law residual at $t^{n+1}$:\n$$ R = \\nabla \\cdot \\mathbf{E}^{n+1} - \\frac{\\rho^{n+1} - \\langle \\rho^{n+1} \\rangle}{\\epsilon_0} $$\nWe use spectral differentiation for the divergence. In Fourier space:\n$$ \\widehat{(\\nabla \\cdot \\mathbf{E}^{n+1})}_{\\mathbf{k}} = i\\mathbf{k} \\cdot \\hat{\\mathbf{E}}^{n+1}_{\\mathbf{k}} $$\nSubstituting the expression for $\\hat{\\mathbf{E}}^{n+1}_{\\mathbf{k}}$:\n$$ \\widehat{(\\nabla \\cdot \\mathbf{E}^{n+1})}_{\\mathbf{k}} = i\\mathbf{k} \\cdot (-i\\mathbf{k} \\hat{\\phi}^{n+1}_{\\mathbf{k}}) = k^2 \\hat{\\phi}^{n+1}_{\\mathbf{k}} $$\nNow, substituting the solution for $\\hat{\\phi}^{n+1}_{\\mathbf{k}}$ from the Poisson solve:\n$$ \\widehat{(\\nabla \\cdot \\mathbf{E}^{n+1})}_{\\mathbf{k}} = k^2 \\left( \\frac{1}{k^2 \\epsilon_0} \\hat{\\rho}^{n+1}_{\\mathbf{k}} \\right) = \\frac{\\hat{\\rho}^{n+1}_{\\mathbf{k}}}{\\epsilon_0} \\quad (\\text{for } \\mathbf{k} \\neq 0) $$\nFor $\\mathbf{k}=0$, both sides are zero. Therefore, $\\widehat{(\\nabla \\cdot \\mathbf{E}^{n+1})}_{\\mathbf{k}} = (\\hat{\\rho}^{n+1}_{\\mathbf{k}} - \\widehat{\\langle \\rho^{n+1} \\rangle}_{\\mathbf{k}})/\\epsilon_0$ holds for all $\\mathbf{k}$. This means that the real-space residual $R$ is analytically zero. The numerically computed value will be non-zero due to floating-point round-off errors. We quantify this numerical error by taking the $L_\\infty$ norm of the residual grid, $\\|R\\|_\\infty = \\max_{i,j} |R_{i,j}|$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_residual(case_params):\n    \"\"\"\n    Computes the Gauss's law residual for a given set of PIC parameters.\n    \"\"\"\n    Nx, Ny, Lx, Ly, dt, charges, pos_n, displacements_raw = case_params\n    epsilon_0 = 1.0\n\n    # 1. Grid Setup\n    dx, dy = Lx / Nx, Ly / Ny\n    inv_cell_area = 1.0 / (dx * dy)\n    rho_n1 = np.zeros((Nx, Ny), dtype=np.float64)\n    Jx_n_half = np.zeros((Nx, Ny), dtype=np.float64)\n    Jy_n_half = np.zeros((Nx, Ny), dtype=np.float64)\n\n    # 2. Particle Loop for State Update and Deposition\n    for p in range(len(charges)):\n        # --- Particle State Update ---\n        # Position at t^{n+1} with periodic wrapping\n        pos_n1_raw = pos_n[p] + displacements_raw[p]\n        xp_n1 = pos_n1_raw[0] % Lx\n        yp_n1 = pos_n1_raw[1] % Ly\n\n        # Shortest periodic displacement for velocity\n        dx_p_raw = displacements_raw[p][0]\n        dy_p_raw = displacements_raw[p][1]\n        dx_p = dx_p_raw - np.round(dx_p_raw / Lx) * Lx\n        dy_p = dy_p_raw - np.round(dy_p_raw / Ly) * Ly\n\n        # Velocity and midpoint position\n        vpx = dx_p / dt\n        vpy = dy_p / dt\n        xp_n_half = (pos_n[p][0] + 0.5 * dx_p) % Lx\n        yp_n_half = (pos_n[p][1] + 0.5 * dy_p) % Ly\n        \n        qp = charges[p]\n\n        # --- CIC Charge Deposition at t^{n+1} ---\n        x_log_rho = xp_n1 / dx - 0.5\n        y_log_rho = yp_n1 / dy - 0.5\n        i0_rho = int(np.floor(x_log_rho))\n        j0_rho = int(np.floor(y_log_rho))\n        Wx_rho = x_log_rho - i0_rho\n        Wy_rho = y_log_rho - j0_rho\n\n        i0r, i1r = i0_rho % Nx, (i0_rho + 1) % Nx\n        j0r, j1r = j0_rho % Ny, (j0_rho + 1) % Ny\n\n        rho_n1[i0r, j0r] += qp * (1.0 - Wx_rho) * (1.0 - Wy_rho) * inv_cell_area\n        rho_n1[i1r, j0r] += qp * Wx_rho * (1.0 - Wy_rho) * inv_cell_area\n        rho_n1[i0r, j1r] += qp * (1.0 - Wx_rho) * Wy_rho * inv_cell_area\n        rho_n1[i1r, j1r] += qp * Wx_rho * Wy_rho * inv_cell_area\n\n        # --- CIC Current Deposition at t^{n+1/2} ---\n        x_log_J = xp_n_half / dx - 0.5\n        y_log_J = yp_n_half / dy - 0.5\n        i0_J = int(np.floor(x_log_J))\n        j0_J = int(np.floor(y_log_J))\n        Wx_J = x_log_J - i0_J\n        Wy_J = y_log_J - j0_J\n\n        i0J, i1J = i0_J % Nx, (i0_J + 1) % Nx\n        j0J, j1J = j0_J % Ny, (j0_J + 1) % Ny\n\n        J_contrib_x = qp * vpx * inv_cell_area\n        J_contrib_y = qp * vpy * inv_cell_area\n\n        w00 = (1.0 - Wx_J) * (1.0 - Wy_J)\n        w10 = Wx_J * (1.0 - Wy_J)\n        w01 = (1.0 - Wx_J) * Wy_J\n        w11 = Wx_J * Wy_J\n\n        Jx_n_half[i0J, j0J] += J_contrib_x * w00\n        Jx_n_half[i1J, j0J] += J_contrib_x * w10\n        Jx_n_half[i0J, j1J] += J_contrib_x * w01\n        Jx_n_half[i1J, j1J] += J_contrib_x * w11\n        \n        Jy_n_half[i0J, j0J] += J_contrib_y * w00\n        Jy_n_half[i1J, j0J] += J_contrib_y * w10\n        Jy_n_half[i0J, j1J] += J_contrib_y * w01\n        Jy_n_half[i1J, j1J] += J_contrib_y * w11\n\n    # 3. Field Solution\n    rho_mean = np.mean(rho_n1)\n    source = -(rho_n1 - rho_mean) / epsilon_0\n    source_hat = np.fft.fftn(source)\n\n    kx = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n    ky = 2 * np.pi * np.fft.fftfreq(Ny, d=dy)\n    KX, KY = np.meshgrid(kx, ky, indexing='ij')\n\n    k_sq = KX**2 + KY**2\n\n    phi_hat = np.zeros_like(source_hat, dtype=np.complex128)\n    # Avoid division by zero at k=0\n    nonzero_k = k_sq  1e-15\n    phi_hat[nonzero_k] = -source_hat[nonzero_k] / k_sq[nonzero_k]\n\n    # E-field in Fourier space\n    Ex_hat = -1j * KX * phi_hat\n    Ey_hat = -1j * KY * phi_hat\n\n    # 4. Residual Calculation\n    # div(E) in Fourier space\n    divE_hat = 1j * KX * Ex_hat + 1j * KY * Ey_hat\n    \n    # an IFFT will recover div(E) in real space\n    divE = np.fft.ifftn(divE_hat).real\n    \n    # Source term for Gauss's law\n    gauss_source = (rho_n1 - rho_mean) / epsilon_0\n    \n    # Residual\n    R = divE - gauss_source\n    \n    # 5. L_infinity norm of the residual\n    residual_norm = np.max(np.abs(R))\n    \n    return residual_norm\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        (16, 12, 1.0, 1.2, 0.05,\n         np.array([1.0, -1.0, 1.0, 1.0, -1.0]),\n         np.array([(0.12, 0.21), (0.88, 1.10), (0.33, 0.77), (0.61, 0.44), (0.97, 0.05)]),\n         np.array([(0.08, -0.03), (0.20, 0.15), (-0.40, 0.10), (0.00, 0.00), (0.10, -0.08)])),\n        # Case B\n        (8, 8, 1.0, 1.0, 0.10,\n         np.array([1.0, 1.0, 1.0, 1.0]),\n         np.array([(0.20, 0.20), (0.70, 0.30), (0.40, 0.80), (0.95, 0.95)]),\n         np.array([(0.50, 0.00), (0.00, 0.50), (-0.60, -0.60), (0.20, 0.20)])),\n        # Case C\n        (4, 4, 1.0, 1.0, 0.20,\n         np.array([2.0]),\n         np.array([(0.49, 0.51)]),\n         np.array([(0.05, -0.07)]))\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_residual(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}