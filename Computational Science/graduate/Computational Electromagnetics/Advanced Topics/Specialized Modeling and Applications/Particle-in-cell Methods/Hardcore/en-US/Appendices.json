{
    "hands_on_practices": [
        {
            "introduction": "The first step in any Particle-in-Cell simulation is to transfer information from the continuous particle domain to the discrete grid. This practice focuses on the fundamental process of charge deposition, where a particle's charge is assigned to nearby grid nodes. In this exercise , you will compare two of the most common schemes, Nearest-Grid-Point (NGP) and Cloud-in-Cell (CIC), by quantifying how well they preserve the integral form of Gauss's law, a cornerstone of electrostatics. This provides a direct, hands-on understanding of the trade-offs between computational simplicity and the accuracy of representing physical laws on a discrete grid.",
            "id": "3310354",
            "problem": "You are given a uniform three-dimensional Cartesian grid and a single point charge. The objective is to compare two charge deposition schemes used in Particle-In-Cell (PIC) methods—nearest-cell deposition and cloud-in-cell deposition—and to evaluate the resulting discrete Gauss's law error in both the $L^2$ and maximum norms over the grid. The evaluation must be performed by computing approximate electric flux through each cell's closed surface using the continuous Coulomb electric field of the point charge and then comparing that flux-based enclosed charge to the deposited charge per cell for each scheme. Use normalized units with vacuum permittivity set to one, that is, $\\varepsilon_0 = 1$, and a unit charge $q = 1$, so all outputs are dimensionless floats with no physical units.\n\nFundamental base: Maxwell's equations in their electrostatic form require that the divergence of the electric field equals the charge density divided by the vacuum permittivity, that is, the differential Gauss's law $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$. The integral form asserts that the electric flux through any closed surface equals the total enclosed charge divided by the vacuum permittivity, that is, $\\oint_{\\partial V} \\mathbf{E} \\cdot \\mathrm{d}\\mathbf{A} = Q_{\\mathrm{enc}} / \\varepsilon_0$. In free space, the electrostatic field of a point charge is $\\mathbf{E}(\\mathbf{r}) = \\left(1/(4 \\pi \\varepsilon_0) \\right) q \\, (\\mathbf{r} - \\mathbf{r}_0)/\\|\\mathbf{r} - \\mathbf{r}_0\\|^3$.\n\nDiscrete setting and approximations:\n- Grid: Let the domain be the rectangular box $[0, L_x] \\times [0, L_y] \\times [0, L_z]$, partitioned into $N_x \\times N_y \\times N_z$ uniform cells with spacings $h_x = L_x/N_x$, $h_y = L_y/N_y$, $h_z = L_z/N_z$. Cell indices are $(i,j,k)$ with $i \\in \\{0,\\dots,N_x-1\\}$, $j \\in \\{0,\\dots,N_y-1\\}$, and $k \\in \\{0,\\dots,N_z-1\\}$. The center of cell $(i,j,k)$ is at coordinates $(x_i, y_j, z_k) = \\left((i + 0.5) h_x, (j + 0.5) h_y, (k + 0.5) h_z\\right)$.\n- Electric flux approximation: For each cell $(i,j,k)$, approximate the net electric flux through its closed surface using the midpoint rule on faces. The six face centers are\n  - left face center at $\\left(i h_x, (j+0.5) h_y, (k+0.5) h_z\\right)$ with outward normal $\\mathbf{n}_x^- = (-1,0,0)$ and area $A_x = h_y h_z$,\n  - right face center at $\\left((i+1) h_x, (j+0.5) h_y, (k+0.5) h_z\\right)$ with outward normal $\\mathbf{n}_x^+ = (1,0,0)$ and area $A_x = h_y h_z$,\n  - bottom face center at $\\left((i+0.5) h_x, j h_y, (k+0.5) h_z\\right)$ with outward normal $\\mathbf{n}_y^- = (0,-1,0)$ and area $A_y = h_x h_z$,\n  - top face center at $\\left((i+0.5) h_x, (j+1) h_y, (k+0.5) h_z\\right)$ with outward normal $\\mathbf{n}_y^+ = (0,1,0)$ and area $A_y = h_x h_z$,\n  - back face center at $\\left((i+0.5) h_x, (j+0.5) h_y, k h_z\\right)$ with outward normal $\\mathbf{n}_z^- = (0,0,-1)$ and area $A_z = h_x h_y$,\n  - front face center at $\\left((i+0.5) h_x, (j+0.5) h_y, (k+1) h_z\\right)$ with outward normal $\\mathbf{n}_z^+ = (0,0,1)$ and area $A_z = h_x h_y$.\n  Using the continuous Coulomb field of the point charge, denote by $\\mathbf{E}_{\\mathrm{face}}$ the field evaluated at the corresponding face center. The approximate net flux is then\n  $$\\Phi_{i,j,k} \\approx A_x \\left(\\mathbf{E}_{\\mathrm{right}} \\cdot \\mathbf{n}_x^+\\right) + A_x \\left(\\mathbf{E}_{\\mathrm{left}} \\cdot \\mathbf{n}_x^-\\right) + A_y \\left(\\mathbf{E}_{\\mathrm{top}} \\cdot \\mathbf{n}_y^+\\right) + A_y \\left(\\mathbf{E}_{\\mathrm{bottom}} \\cdot \\mathbf{n}_y^-\\right) + A_z \\left(\\mathbf{E}_{\\mathrm{front}} \\cdot \\mathbf{n}_z^+\\right) + A_z \\left(\\mathbf{E}_{\\mathrm{back}} \\cdot \\mathbf{n}_z^-\\right).$$\n- Nearest-cell deposition (NGP): Deposit the entire charge $q$ into the single cell that contains the point charge coordinates $\\mathbf{r}_0 = (x_0,y_0,z_0)$. That is, if $i^\\ast = \\lfloor x_0/h_x \\rfloor$, $j^\\ast = \\lfloor y_0/h_y \\rfloor$, $k^\\ast = \\lfloor z_0/h_z \\rfloor$, then the deposited charge for cell $(i,j,k)$ is\n  $$Q^{\\mathrm{NGP}}_{i,j,k} = \\begin{cases} q,  \\text{if } (i,j,k) = (i^\\ast,j^\\ast,k^\\ast), \\\\ 0,  \\text{otherwise.} \\end{cases}$$\n- Cloud-in-cell deposition (CIC): Deposit the charge $q$ into the $2 \\times 2 \\times 2$ block of cells whose centers immediately surround the point location $\\mathbf{r}_0$ along each axis via trilinear weights. Let $i_0 = \\left\\lfloor x_0/h_x - 0.5 \\right\\rfloor$, $j_0 = \\left\\lfloor y_0/h_y - 0.5 \\right\\rfloor$, $k_0 = \\left\\lfloor z_0/h_z - 0.5 \\right\\rfloor$, clamped so that $i_0 \\in \\{0,\\dots,N_x-2\\}$, $j_0 \\in \\{0,\\dots,N_y-2\\}$, and $k_0 \\in \\{0,\\dots,N_z-2\\}$. Define local fractional coordinates within the bracketing cell-center segment by $s_x = x_0/h_x - (i_0 + 0.5)$, $s_y = y_0/h_y - (j_0 + 0.5)$, $s_z = z_0/h_z - (k_0 + 0.5)$, each in $[0,1)$. The weights for the eight cells $(i_0 + a, j_0 + b, k_0 + c)$ with $a,b,c \\in \\{0,1\\}$ are $w_{a,b,c} = \\left(a s_x + (1-a)(1 - s_x)\\right) \\left(b s_y + (1-b)(1 - s_y)\\right) \\left(c s_z + (1-c)(1 - s_z)\\right)$, normalized so that $\\sum_{a,b,c} w_{a,b,c} = 1$, and the deposited charge is $Q^{\\mathrm{CIC}}_{i_0+a,j_0+b,k_0+c} = q \\, w_{a,b,c}$ for those eight cells and zero elsewhere.\n\nDiscrete Gauss's law error per cell: For each deposition scheme $\\mathcal{D} \\in \\{\\mathrm{NGP}, \\mathrm{CIC}\\}$, define the per-cell error as the difference between the approximated flux-based enclosed charge and the deposited charge,\n$$\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}/\\varepsilon_0.$$\nIn normalized units with $\\varepsilon_0 = 1$ and $q = 1$, this simplifies to $\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}$. Compute the global $L^2$ norm and maximum norm of the error over all cells for each deposition scheme as\n$$\\|\\mathcal{E}^{\\mathcal{D}}\\|_{2} = \\sqrt{\\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\sum_{k=0}^{N_z-1} \\left(\\mathcal{E}^{\\mathcal{D}}_{i,j,k}\\right)^2}, \\quad \\|\\mathcal{E}^{\\mathcal{D}}\\|_{\\infty} = \\max_{i,j,k} \\left| \\mathcal{E}^{\\mathcal{D}}_{i,j,k} \\right|.$$\n\nImplementation details:\n- Use the continuous Coulomb field $\\mathbf{E}(\\mathbf{r}) = \\left(1/(4 \\pi \\varepsilon_0)\\right) q (\\mathbf{r} - \\mathbf{r}_0)/\\|\\mathbf{r} - \\mathbf{r}_0\\|^3$ with $\\varepsilon_0 = 1$ and $q = 1$, hence $\\mathbf{E}(\\mathbf{r}) = \\left(1/(4 \\pi)\\right) (\\mathbf{r} - \\mathbf{r}_0)/\\|\\mathbf{r} - \\mathbf{r}_0\\|^3$.\n- Approximate the flux using the midpoint rule at each face center as described above.\n- Ensure that the point charge location avoids exact coincidence with any face center to prevent singular evaluations. In all given test cases, positions are chosen accordingly.\n\nTest suite:\nCompute the $(L^2, \\text{max})$ error norms for both nearest-cell deposition and cloud-in-cell deposition for each of the following test cases. All positions and lengths are in meters, but remember $\\varepsilon_0 = 1$ and $q = 1$ so the outputs are dimensionless floats.\n1. Case $1$: $N_x = 24$, $N_y = 22$, $N_z = 20$, $L_x = 1.2$, $L_y = 1.2$, $L_z = 1.2$, point charge at $(x_0, y_0, z_0) = (0.53, 0.47, 0.41)$.\n2. Case $2$: $N_x = 12$, $N_y = 10$, $N_z = 8$, $L_x = 1.0$, $L_y = 1.0$, $L_z = 1.0$, point charge at $(x_0, y_0, z_0) = (0.05, 0.92, 0.13)$.\n3. Case $3$: $N_x = 18$, $N_y = 18$, $N_z = 18$, $L_x = 0.9$, $L_y = 0.9$, $L_z = 0.9$, point charge at $(x_0, y_0, z_0) = (0.275, 0.225, 0.275)$.\n4. Case $4$: $N_x = 6$, $N_y = 6$, $N_z = 6$, $L_x = 1.0$, $L_y = 1.0$, $L_z = 1.0$, point charge at $(x_0, y_0, z_0) = (0.37, 0.58, 0.41)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, append four values in the following order: $L^2$ error for nearest-cell deposition, maximum error for nearest-cell deposition, $L^2$ error for cloud-in-cell deposition, maximum error for cloud-in-cell deposition. Concatenate these quadruples for the four cases to form one flat list. For example, the output format must be exactly\n$$[\\text{case1\\_L2\\_NGP},\\text{case1\\_Max\\_NGP},\\text{case1\\_L2\\_CIC},\\text{case1\\_Max\\_CIC},\\text{case2\\_L2\\_NGP},\\dots,\\text{case4\\_Max\\_CIC}].$$",
            "solution": "The problem requires a quantitative comparison of two common charge deposition schemes in computational electromagnetics, namely Nearest-Cell Deposition (also known as Nearest Grid Point, NGP) and Cloud-in-Cell (CIC), by evaluating the error in the discrete representation of Gauss's law.\n\nThe foundation of this analysis is Gauss's law in integral form, which states that the net electric flux $\\Phi$ through a closed surface $\\partial V$ is proportional to the total electric charge $Q_{\\mathrm{enc}}$ enclosed within the volume $V$:\n$$ \\oint_{\\partial V} \\mathbf{E} \\cdot \\mathrm{d}\\mathbf{A} = \\frac{Q_{\\mathrm{enc}}}{\\varepsilon_0} $$\nFor this problem, we are given a single point charge $q$ at position $\\mathbf{r}_0$ in vacuum. The electric field is given by Coulomb's law:\n$$ \\mathbf{E}(\\mathbf{r}) = \\frac{q}{4 \\pi \\varepsilon_0} \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\|\\mathbf{r} - \\mathbf{r}_0\\|^3} $$\nWith the specified normalization of $q=1$ and $\\varepsilon_0=1$, this simplifies to:\n$$ \\mathbf{E}(\\mathbf{r}) = \\frac{1}{4 \\pi} \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\|\\mathbf{r} - \\mathbf{r}_0\\|^3} $$\nThe core idea is to compute, for each cell in a Cartesian grid, two different versions of the enclosed charge:\n1.  A \"flux-based\" charge, $Q_{\\mathrm{flux}}$, derived by numerically approximating the flux integral $\\Phi_{i,j,k}$ over the cell's boundary and using Gauss's law: $Q_{\\mathrm{flux}, i,j,k} = \\varepsilon_0 \\Phi_{i,j,k}$.\n2.  A \"deposited\" charge, $Q^{\\mathcal{D}}_{i,j,k}$, obtained by applying a charge deposition scheme $\\mathcal{D} \\in \\{\\mathrm{NGP}, \\mathrm{CIC}\\}$.\n\nThe discrepancy between these two quantities, $\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}/\\varepsilon_0$, represents the local error in satisfying Gauss's law. With our normalization, this is simply $\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}$. We then quantify the global error using the $L^2$ and maximum norms.\n\nThe algorithm proceeds as follows for each test case:\n\n1.  **Grid and Parameter Initialization**: For a given domain of size $L_x \\times L_y \\times L_z$ and a grid of $N_x \\times N_y \\times N_z$ cells, we compute the cell spacings $h_x = L_x/N_x$, $h_y = L_y/N_y$, and $h_z = L_z/N_z$. The point charge $q=1$ is located at $\\mathbf{r}_0 = (x_0, y_0, z_0)$.\n\n2.  **Charge Deposition**: We compute the charge deposited into each cell $(i,j,k)$ for both schemes.\n    *   **NGP Scheme**: We find the cell indices $(i^\\ast, j^\\ast, k^\\ast)$ that contain $\\mathbf{r}_0$, where $i^\\ast = \\lfloor x_0/h_x \\rfloor$, $j^\\ast = \\lfloor y_0/h_y \\rfloor$, and $k^\\ast = \\lfloor z_0/h_z \\rfloor$. The entire charge $q=1$ is assigned to this single cell. All other cells receive zero charge. This creates a $N_x \\times N_y \\times N_z$ array $Q^{\\mathrm{NGP}}$.\n    *   **CIC Scheme**: This scheme distributes the charge among the $8$ cells whose centers bracket the particle's position. We first find the base index of this $2 \\times 2 \\times 2$ block: $i_0 = \\lfloor x_0/h_x - 0.5 \\rfloor$, $j_0 = \\lfloor y_0/h_y - 0.5 \\rfloor$, $k_0 = \\lfloor z_0/h_z - 0.5 \\rfloor$, ensuring these indices are clamped to remain within the grid bounds for the block. Then, we compute the fractional distances of the particle from the base cell center: $s_x = x_0/h_x - (i_0 + 0.5)$, $s_y = y_0/h_y - (j_0 + 0.5)$, and $s_z = z_0/h_z - (k_0 + 0.5)$. The charge is distributed to the $8$ cells $(i_0+a, j_0+b, k_0+c)$ for $a,b,c \\in \\{0,1\\}$ using trilinear interpolation weights. This creates a charge array $Q^{\\mathrm{CIC}}$.\n\n3.  **Numerical Flux Calculation**: We calculate the electric flux through the boundary of every cell. The problem specifies a midpoint rule approximation. For each cell $(i,j,k)$, the net flux $\\Phi_{i,j,k}$ is the sum of fluxes through its six faces.\n    $$ \\Phi_{i,j,k} \\approx \\sum_{\\text{faces } f} \\mathbf{E}(\\mathbf{r}_f) \\cdot \\mathbf{n}_f A_f $$\n    where $\\mathbf{r}_f$ is the center of a face, $\\mathbf{n}_f$ is its outward-pointing normal vector, and $A_f$ is its area. For example, for the \"right\" face ($x$ constant, maximum value), $\\mathbf{r}_f = ((i+1)h_x, (j+0.5)h_y, (k+0.5)h_z)$, $\\mathbf{n}_f = (1,0,0)$, and $A_f = h_y h_z$.\n    To implement this efficiently, we leverage vectorization. We generate 3D arrays representing the coordinates of all cell indices $(i,j,k)$. From these, we compute the coordinate arrays for the centers of all six face types (e.g., all \"left\" faces, all \"right\" faces, etc.). We then evaluate the electric field vector components on these six grids of face centers. The dot product with the respective normals and multiplication by the face area gives six 3D arrays of partial fluxes. Summing these six arrays yields a final 3D array $\\Phi$, where $\\Phi_{i,j,k}$ is the total approximate flux out of cell $(i,j,k)$.\n\n4.  **Error Calculation and Norms**: With the flux array $\\Phi$ and the charge arrays $Q^{\\mathrm{NGP}}$ and $Q^{\\mathrm{CIC}}$, we compute the error arrays for each scheme:\n    $$ \\mathcal{E}^{\\mathrm{NGP}} = \\Phi - Q^{\\mathrm{NGP}} $$\n    $$ \\mathcal{E}^{\\mathrm{CIC}} = \\Phi - Q^{\\mathrm{CIC}} $$\n    Finally, we compute the $L^2$ norm and maximum ($L^\\infty$) norm for each error array:\n    $$ \\|\\mathcal{E}^{\\mathcal{D}}\\|_{2} = \\sqrt{\\sum_{i,j,k} (\\mathcal{E}^{\\mathcal{D}}_{i,j,k})^2} $$\n    $$ \\|\\mathcal{E}^{\\mathcal{D}}\\|_{\\infty} = \\max_{i,j,k} |\\mathcal{E}^{\\mathcal{D}}_{i,j,k}| $$\n    These four scalar values (two norms for two schemes) are computed for each test case and appended to the final results list. The process is repeated for all cases provided in the problem statement.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # (Nx, Ny, Nz, Lx, Ly, Lz, (x0, y0, z0))\n        (24, 22, 20, 1.2, 1.2, 1.2, (0.53, 0.47, 0.41)),\n        (12, 10, 8, 1.0, 1.0, 1.0, (0.05, 0.92, 0.13)),\n        (18, 18, 18, 0.9, 0.9, 0.9, (0.275, 0.225, 0.275)),\n        (6, 6, 6, 1.0, 1.0, 1.0, (0.37, 0.58, 0.41)),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = calculate_errors_for_case(case)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef calculate_errors_for_case(case_params):\n    \"\"\"\n    Calculates the L2 and max errors for NGP and CIC schemes for a single test case.\n    \"\"\"\n    Nx, Ny, Nz, Lx, Ly, Lz, r0 = case_params\n    r0 = np.array(r0)\n    q = 1.0\n    eps0 = 1.0\n\n    hx, hy, hz = Lx / Nx, Ly / Ny, Lz / Nz\n    h = np.array([hx, hy, hz])\n    Ax, Ay, Az = hy * hz, hx * hz, hx * hy\n\n    # --- Charge Deposition ---\n\n    # NGP (Nearest-Cell Deposition)\n    Q_ngp = np.zeros((Nx, Ny, Nz))\n    i_star = int(np.floor(r0[0] / hx))\n    j_star = int(np.floor(r0[1] / hy))\n    k_star = int(np.floor(r0[2] / hz))\n    if 0 = i_star  Nx and 0 = j_star  Ny and 0 = k_star  Nz:\n        Q_ngp[i_star, j_star, k_star] = q\n\n    # CIC (Cloud-in-Cell)\n    Q_cic = np.zeros((Nx, Ny, Nz))\n    # Base cell index for the 2x2x2 cloud\n    i0 = int(np.floor(r0[0] / hx - 0.5))\n    j0 = int(np.floor(r0[1] / hy - 0.5))\n    k0 = int(np.floor(r0[2] / hz - 0.5))\n\n    # Clamp indices to ensure the 2x2x2 stencil is within the grid\n    i0 = np.clip(i0, 0, Nx - 2)\n    j0 = np.clip(j0, 0, Ny - 2)\n    k0 = np.clip(k0, 0, Nz - 2)\n\n    # Fractional coordinates relative to the base cell center\n    sx = r0[0] / hx - (i0 + 0.5)\n    sy = r0[1] / hy - (j0 + 0.5)\n    sz = r0[2] / hz - (k0 + 0.5)\n\n    # Trilinear weights\n    wx = [1 - sx, sx]\n    wy = [1 - sy, sy]\n    wz = [1 - sz, sz]\n\n    for a in range(2):\n        for b in range(2):\n            for c in range(2):\n                weight = wx[a] * wy[b] * wz[c]\n                Q_cic[i0 + a, j0 + b, k0 + c] = q * weight\n    \n    # --- Electric Field and Flux Calculation ---\n    \n    i_idx, j_idx, k_idx = np.indices((Nx, Ny, Nz))\n\n    def get_E_field(pos_x, pos_y, pos_z):\n        \"\"\"Vectorized E-field calculation.\"\"\"\n        rx = pos_x - r0[0]\n        ry = pos_y - r0[1]\n        rz = pos_z - r0[2]\n        dist_sq = rx**2 + ry**2 + rz**2\n        # Add a small epsilon to avoid division by zero if r coincides with r0.\n        # Problem statement guarantees no coincidence with face centers.\n        dist_cubed = dist_sq * np.sqrt(dist_sq) \n        factor = (q / (4 * np.pi * eps0)) / dist_cubed\n        return factor * rx, factor * ry, factor * rz\n\n    flux_total = np.zeros((Nx, Ny, Nz))\n\n    # Faces at x = constant\n    x_left = i_idx * hx\n    x_right = (i_idx + 1) * hx\n    y_x_face = (j_idx + 0.5) * hy\n    z_x_face = (k_idx + 0.5) * hz\n    Ex_left, _, _ = get_E_field(x_left, y_x_face, z_x_face)\n    Ex_right, _, _ = get_E_field(x_right, y_x_face, z_x_face)\n    flux_total += (Ex_right * 1.0 + Ex_left * -1.0) * Ax\n\n    # Faces at y = constant\n    y_bottom = j_idx * hy\n    y_top = (j_idx + 1) * hy\n    x_y_face = (i_idx + 0.5) * hx\n    z_y_face = (k_idx + 0.5) * hz\n    _, Ey_bottom, _ = get_E_field(x_y_face, y_bottom, z_y_face)\n    _, Ey_top, _ = get_E_field(x_y_face, y_top, z_y_face)\n    flux_total += (Ey_top * 1.0 + Ey_bottom * -1.0) * Ay\n\n    # Faces at z = constant\n    z_back = k_idx * hz\n    z_front = (k_idx + 1) * hz\n    x_z_face = (i_idx + 0.5) * hx\n    y_z_face = (j_idx + 0.5) * hy\n    _, _, Ez_back = get_E_field(x_z_face, y_z_face, z_back)\n    _, _, Ez_front = get_E_field(x_z_face, y_z_face, z_front)\n    flux_total += (Ez_front * 1.0 + Ez_back * -1.0) * Az\n\n    # --- Error Calculation ---\n    \n    # Error = Flux - Q_enclosed (with eps0=1)\n    error_ngp = flux_total - Q_ngp\n    error_cic = flux_total - Q_cic\n\n    # L2 and Max Norms\n    l2_ngp = np.sqrt(np.sum(error_ngp**2))\n    max_ngp = np.max(np.abs(error_ngp))\n    l2_cic = np.sqrt(np.sum(error_cic**2))\n    max_cic = np.max(np.abs(error_cic))\n    \n    return [l2_ngp, max_ngp, l2_cic, max_cic]\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "While accurately representing a static charge distribution is important, a PIC simulation must also handle moving charges without violating fundamental principles. This leads to the crucial concept of charge conservation, which dictates that any change in charge within a grid cell must be exactly balanced by a net current flowing across its boundaries. This practice  delves into the heart of charge-conserving algorithms by having you implement a sophisticated current deposition scheme on a staggered grid that satisfies the discrete continuity equation, $\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot \\mathbf{J} = 0$, to machine precision. Mastering this technique is essential for building stable PIC codes that prevent the non-physical creation or destruction of charge over long simulation times.",
            "id": "3338044",
            "problem": "Consider a two-dimensional Particle-In-Cell (PIC) scheme on a uniform, periodic Cartesian grid with $N_x$ cells in $x$ and $N_y$ cells in $y$. Let the cell centers be indexed by integers $i \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$, and positions be represented in dimensionless grid units so that one cell spacing equals $1$. A single particle of charge $q$ moves with constant velocity given by the electric field $\\mathbf{E}$ and magnetic field $\\mathbf{B}$ through the cross-field drift, namely $\\mathbf{v} = \\mathbf{E} \\times \\mathbf{B} / \\|\\mathbf{B}\\|^2$. Assume $\\mathbf{B} = (0,0,B_z)$ and $\\mathbf{E} = (E_x,E_y,0)$ are uniform and constant in space and time during one time step of duration $\\Delta t$, so that the drift velocity is $\\mathbf{v} = (E_y/B_z, -E_x/B_z, 0)$.\n\nYour task is to implement, for one particle and one time step, the following operations in purely mathematical terms:\n- Deposit the charge density $\\rho$ at time step $n$ and $n+1$ to cell centers using the Cloud-In-Cell bilinear shape function (first-order B-spline), where for a particle position $(x,y)$ the four neighboring cell-center weights are $(1-f_x)(1-f_y)$, $f_x(1-f_y)$, $(1-f_x)f_y$, and $f_x f_y$ with $f_x = x - \\lfloor x \\rfloor$ and $f_y = y - \\lfloor y \\rfloor$, and indices taken modulo $N_x$ and $N_y$ for periodicity.\n- Deposit face-centered currents $\\mathbf{J}^{n+1/2}$ at the half-step using a shape of order zero (nearest-face) along the motion direction and order one (linear) along the transverse direction. Specifically, deposit $J_x$ to faces at $x = i+1$ (i.e., between cells $i$ and $i+1$) and $J_y$ to faces at $y = j+1$ (i.e., between cells $j$ and $j+1$). For $J_x$, choose the unique face index $k_x = i_0 + 1$ if $\\Delta x \\ge 0$ and $k_x = i_0$ if $\\Delta x  0$, where $i_0 = \\lfloor x^n \\rfloor$ and $\\Delta x = x^{n+1} - x^n$; for $J_y$, choose $k_y = j_0 + 1$ if $\\Delta y \\ge 0$ and $k_y = j_0$ if $\\Delta y  0$, where $j_0 = \\lfloor y^n \\rfloor$ and $\\Delta y = y^{n+1} - y^n$. Within the time interval $[t^n,t^{n+1}]$, integrate exactly the linear transverse weights over time segments split at potential crossings of integer boundaries in the transverse coordinate to obtain the time-averaged current at the half-step. Use periodic boundary conditions for indices.\n\nThe discrete continuity equation on the staggered grid is\n$$\n\\frac{\\rho^{n+1}_{i,j} - \\rho^{n}_{i,j}}{\\Delta t} + \\left[ J_x^{n+1/2}(i+1,j) - J_x^{n+1/2}(i,j) \\right] + \\left[ J_y^{n+1/2}(i,j+1) - J_y^{n+1/2}(i,j) \\right] = 0,\n$$\nfor all $i,j$, where $J_x^{n+1/2}(k,j)$ is the $x$-face current at face index $k \\in \\{0,\\dots,N_x-1\\}$ and row $j$, and $J_y^{n+1/2}(i,k)$ is the $y$-face current at column $i$ and face index $k \\in \\{0,\\dots,N_y-1\\}$. The face indices are interpreted modulo $N_x$ and $N_y$ for periodicity. You must compute the maximum absolute residual\n$$\n\\varepsilon = \\max_{i,j} \\left| \\frac{\\rho^{n+1}_{i,j} - \\rho^{n}_{i,j}}{\\Delta t} + \\left[ J_x^{n+1/2}(i+1,j) - J_x^{n+1/2}(i,j) \\right] + \\left[ J_y^{n+1/2}(i,j+1) - J_y^{n+1/2}(i,j) \\right] \\right|,\n$$\nwhich is a dimensionless number in this mathematical formulation.\n\nImplement a program that, for the following test suite, computes the particle position update via $\\mathbf{v} = \\mathbf{E} \\times \\mathbf{B}/\\|\\mathbf{B}\\|^2$, deposits $\\rho^n$, $\\rho^{n+1}$, and the face-centered currents $\\mathbf{J}^{n+1/2}$ via exact time integration of the transverse linear weights split at boundary crossings, computes the discrete continuity residual, and reports the maximum absolute residual $\\varepsilon$ for each case. All quantities are dimensionless, and all indices are periodic. Use $N_x = 8$, $N_y = 8$, $q = 1$, and $\\Delta t = 1$ for all cases.\n\nTest suite parameter sets $(E_x,E_y,B_z,x^n,y^n)$:\n- Case $1$: $(1.0, 0.0, 2.0, 3.2, 4.4)$.\n- Case $2$: $(0.0, 1.0, 2.0, 3.7, 1.1)$.\n- Case $3$: $(1.0, 1.0, 2.0, 2.7, 5.3)$.\n- Case $4$: $(0.0, 0.0, 2.0, 6.5, 3.0)$.\n- Case $5$: $(1.0, 1.0, 10.0, 2.0, 4.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases above, for example, $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4,\\varepsilon_5]$.",
            "solution": "The user has provided a valid, well-posed problem in computational physics, specifically concerning the implementation and verification of a particle-to-grid deposition scheme within a Particle-In-Cell (PIC) framework. The task is to compute the maximum absolute residual of the discrete continuity equation for a specified hybrid current deposition scheme. The problem is scientifically grounded, formally specified, and requires a detailed, non-trivial implementation.\n\nThe solution proceeds by implementing the described algorithm for each of the five test cases. The core steps for each case involve:\n1.  Computing the particle's final position after one time step.\n2.  Depositing the particle's charge onto the grid at the initial and final times.\n3.  Depositing the particle's current onto the grid faces over the time step.\n4.  Calculating the residual of the discrete continuity equation at each grid cell and finding the maximum absolute value.\n\nAll quantities are dimensionless as specified, with grid spacing equal to $1$, particle charge $q=1$, and time step $\\Delta t=1$. The grid is a periodic $8 \\times 8$ domain.\n\n**1. Particle Position Update**\n\nThe particle moves with a constant velocity $\\mathbf{v}$ determined by the $\\mathbf{E} \\times \\mathbf{B}$ drift, where $\\mathbf{E} = (E_x, E_y, 0)$ and $\\mathbf{B} = (0, 0, B_z)$ are uniform and constant. The velocity is given by:\n$$\n\\mathbf{v} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{\\|\\mathbf{B}\\|^2} = \\left( \\frac{E_y B_z}{B_z^2}, \\frac{-E_x B_z}{B_z^2}, 0 \\right) = \\left( \\frac{E_y}{B_z}, -\\frac{E_x}{B_z}, 0 \\right)\n$$\nGiven the initial position $\\mathbf{r}^n = (x^n, y^n)$, the position at the next time step, $\\mathbf{r}^{n+1} = (x^{n+1}, y^{n+1})$, is calculated by a simple forward Euler integration, which is exact for constant velocity:\n$$\n\\mathbf{r}^{n+1} = \\mathbf{r}^n + \\mathbf{v} \\Delta t\n$$\nSince $\\Delta t=1$, this simplifies to $x^{n+1} = x^n + v_x$ and $y^{n+1} = y^n + v_y$.\n\n**2. Charge Deposition**\n\nThe charge density $\\rho$ is deposited onto the cell centers using the Cloud-In-Cell (CIC) or bilinear interpolation scheme. For a particle at position $(x, y)$, the charge $q$ is distributed among the four nearest cell centers. The cell indices are $(i_0, j_0)$, $(i_0+1, j_0)$, $(i_0, j_0+1)$, and $(i_0+1, j_0+1)$, where $i_0 = \\lfloor x \\rfloor$ and $j_0 = \\lfloor y \\rfloor$. The fractional positions are $f_x = x - i_0$ and $f_y = y - j_0$. The weights are:\n-   Cell $(i_0, j_0)$: $W_{i_0,j_0} = (1-f_x)(1-f_y)$\n-   Cell $(i_0+1, j_0)$: $W_{i_0+1,j_0} = f_x(1-f_y)$\n-   Cell $(i_0, j_0+1)$: $W_{i_0,j_0+1} = (1-f_x)f_y$\n-   Cell $(i_0+1, j_0+1)$: $W_{i_0+1,j_0} = f_x f_y$\n\nThe charge deposited to cell $(i, j)$ is $\\rho_{i,j} = q \\cdot W_{i,j}$. This calculation is performed for both $\\rho^n$ (using $\\mathbf{r}^n$) and $\\rho^{n+1}$ (using $\\mathbf{r}^{n+1}$). All grid indices are handled periodically modulo $N_x=8$ and $N_y=8$.\n\n**3. Current Deposition**\n\nThis is the most intricate part of the problem. The current $\\mathbf{J}^{n+1/2}$ is deposited using a hybrid scheme: zero-order (nearest-face) in the direction of motion and first-order (linear) in the transverse direction. The linear weights in the transverse direction are integrated exactly over the time step.\n\nFor the $x$-component of the current, $J_x$:\n-   The motion is projected onto a single face along the $x$-axis. The face index $k_x$ is determined by the initial cell index $i_0 = \\lfloor x^n \\rfloor$ and the sign of the velocity $v_x$. If $v_x \\ge 0$, the particle crosses the face at $i_0+1$, so $k_x = i_0+1$. If $v_x  0$, it crosses the face at $i_0$, so $k_x = i_0$.\n-   The total current in the $x$-direction, $q v_x$, is distributed in the transverse ($y$) direction. The time-averaged current deposited to face $k_x$ at transverse row $j$ is given by:\n    $$\n    J_x(k_x, j) = \\frac{1}{\\Delta t} \\int_{0}^{\\Delta t} q v_x S_j(y(\\tau)) d\\tau\n    $$\n    where $y(\\tau) = y^n + v_y \\tau$ is the particle's $y$-position at time $\\tau \\in [0, \\Delta t]$, and $S_j(y)$ is the linear shape function (a triangular function centered at grid node $j$) for CIC.\n-   The integral $\\int_0^{\\Delta t} S_j(y(\\tau)) d\\tau$ is computed by splitting the integration interval $[0, \\Delta t]$ at each time $\\tau_c$ where the particle's transverse coordinate $y(\\tau_c)$ crosses an integer grid line. Within each sub-interval, $\\lfloor y(\\tau) \\rfloor$ is constant, and the integrand is a linear function of $\\tau$, which can be integrated exactly (e.g., using the trapezoidal rule, which is exact for linear functions).\n\nThe procedure for the $y$-component of the current, $J_y$, is symmetric. The face index $k_y$ is determined by $y^n$ and $v_y$, and the transverse integration is performed over the $x$-coordinate, $x(\\tau)=x^n+v_x \\tau$.\n\n**4. Residual Calculation**\n\nFinally, the residual $\\varepsilon$ is computed. For each cell $(i, j)$, the discrete continuity equation is evaluated:\n$$\nR_{i,j} = \\frac{\\rho^{n+1}_{i,j} - \\rho^{n}_{i,j}}{\\Delta t} + \\left[ J_x^{n+1/2}((i+1)\\%N_x,j) - J_x^{n+1/2}(i,j) \\right] + \\left[ J_y^{n+1/2}(i,(j+1)\\%N_y) - J_y^{n+1/2}(i,j) \\right]\n$$\nWith $\\Delta t=1$, the first term is simply $\\rho^{n+1}_{i,j} - \\rho^{n}_{i,j}$. The maximum absolute residual is then $\\varepsilon = \\max_{i,j} |R_{i,j}|$. This value quantifies the extent to which the implemented deposition scheme fails to conserve charge locally.\n\nThe entire process is implemented in a Python program which iterates through the provided test cases and computes $\\varepsilon$ for each.",
            "answer": "```python\nimport numpy as np\n\ndef _deposit_charge(pos, q, Nx, Ny):\n    \"\"\"\n    Deposits charge using the Cloud-In-Cell (bilinear) scheme.\n    \n    Args:\n        pos (tuple): Particle (x, y) position.\n        q (float): Particle charge.\n        Nx (int): Number of grid cells in x.\n        Ny (int): Number of grid cells in y.\n        \n    Returns:\n        numpy.ndarray: A 2D array representing charge density rho.\n    \"\"\"\n    rho = np.zeros((Nx, Ny))\n    x, y = pos\n    i0 = int(np.floor(x))\n    j0 = int(np.floor(y))\n    fx = x - i0\n    fy = y - j0\n    \n    # Indices with periodic boundary conditions\n    i0m = i0 % Nx\n    i1m = (i0 + 1) % Nx\n    j0m = j0 % Ny\n    j1m = (j0 + 1) % Ny\n    \n    rho[i0m, j0m] = q * (1 - fx) * (1 - fy)\n    rho[i1m, j0m] = q * fx * (1 - fy)\n    rho[i0m, j1m] = q * (1 - fx) * fy\n    rho[i1m, j1m] = q * fx * fy\n    return rho\n\ndef _integrate_shape_weights(p_start, v, dt, N_cells):\n    \"\"\"\n    Exactly integrates the linear CIC shape function weights over time,\n    accounting for grid-line crossings in the path.\n    \n    Args:\n        p_start (float): Initial position in the transverse dimension.\n        v (float): Velocity in the transverse dimension.\n        dt (float): Time step duration.\n        N_cells (int): Number of grid cells in the transverse dimension.\n        \n    Returns:\n        numpy.ndarray: A 1D array of time-integrated weights for each node.\n    \"\"\"\n    integrated_weights = np.zeros(N_cells)\n    \n    # If there is no displacement, the calculation is simple.\n    if abs(v * dt)  1e-14:\n        i0 = int(np.floor(p_start))\n        fp = p_start - i0\n        integrated_weights[i0 % N_cells] += (1 - fp) * dt\n        integrated_weights[(i0 + 1) % N_cells] += fp * dt\n        return integrated_weights\n\n    # Find all times within (0, dt) where the particle crosses an integer grid line.\n    crossing_times = {0.0, dt}\n    p_end = p_start + v * dt\n    p_min = min(p_start, p_end)\n    p_max = max(p_start, p_end)\n\n    k_min = int(np.ceil(p_min))\n    k_max = int(np.floor(p_max))\n    \n    # If the particle path ends on an integer line, that is not an intermediate crossing.\n    if abs(p_max - k_max)  1e-12:\n        k_max -= 1\n        \n    for k in range(k_min, k_max + 1):\n        t_cross = (k - p_start) / v\n        # Add only crossings strictly within the time interval.\n        if 1e-12  t_cross  dt - 1e-12:\n            crossing_times.add(t_cross)\n\n    sorted_times = sorted(list(crossing_times))\n    \n    # Integrate over each segment between crossings.\n    for idx in range(len(sorted_times) - 1):\n        t1, t2 = sorted_times[idx], sorted_times[idx+1]\n        \n        p1 = p_start + v * t1\n        p2 = p_start + v * t2\n        \n        # The integer part of the position is constant within the segment.\n        p_mid = (p1 + p2) / 2.0\n        i0 = int(np.floor(p_mid))\n        \n        # The integral of a linear function f(t) over [t1, t2] is (t2-t1)*(f(t1)+f(t2))/2.\n        # Here we integrate the shape functions S_i0 and S_{i0+1}.\n        # S_{i0+1}(p(t)) = p(t) - i0\n        integral_f = (t2 - t1) * ((p1 - i0) + (p2 - i0)) / 2.0\n        # S_{i0}(p(t)) = 1 - (p(t) - i0)\n        integral_1_minus_f = (t2 - t1) - integral_f\n        \n        integrated_weights[i0 % N_cells] += integral_1_minus_f\n        integrated_weights[(i0 + 1) % N_cells] += integral_f\n        \n    return integrated_weights\n\ndef _solve_case(params):\n    \"\"\"Solves a single test case and returns the max residual.\"\"\"\n    Nx, Ny = 8, 8\n    q, dt = 1.0, 1.0\n    Ex, Ey, Bz, xn, yn = params\n    \n    # 1. Update particle position\n    if abs(Bz)  1e-15:\n        vx, vy = 0.0, 0.0\n    else:\n        vx = Ey / Bz\n        vy = -Ex / Bz\n    \n    x_next = xn + vx * dt\n    y_next = yn + vy * dt\n    \n    # 2. Deposit charge densities rho^n and rho^{n+1}\n    rho_n = _deposit_charge((xn, yn), q, Nx, Ny)\n    rho_next = _deposit_charge((x_next, y_next), q, Nx, Ny)\n    \n    # 3. Deposit face-centered currents J\n    Jx = np.zeros((Nx, Ny))\n    Jy = np.zeros((Nx, Ny))\n    \n    # Jx component\n    if abs(vx * dt)  1e-14:\n        i0 = int(np.floor(xn))\n        kx = ((i0 + 1) if vx = 0 else i0) % Nx\n        integrated_weights_y = _integrate_shape_weights(yn, vy, dt, Ny)\n        current_val = q * vx / dt\n        for j in range(Ny):\n            Jx[kx, j] += current_val * integrated_weights_y[j]\n\n    # Jy component\n    if abs(vy * dt)  1e-14:\n        j0 = int(np.floor(yn))\n        ky = ((j0 + 1) if vy = 0 else j0) % Ny\n        integrated_weights_x = _integrate_shape_weights(xn, vx, dt, Nx)\n        current_val = q * vy / dt\n        for i in range(Nx):\n            Jy[i, ky] += current_val * integrated_weights_x[i]\n\n    # 4. Calculate the residual of the discrete continuity equation\n    residuals = np.zeros((Nx, Ny))\n    for i in range(Nx):\n        for j in range(Ny):\n            delta_rho_over_dt = (rho_next[i, j] - rho_n[i, j]) / dt\n            div_Jx = Jx[(i + 1) % Nx, j] - Jx[i, j]\n            div_Jy = Jy[i, (j + 1) % Ny] - Jy[i, j]\n            residuals[i, j] = delta_rho_over_dt + div_Jx + div_Jy\n            \n    return np.max(np.abs(residuals))\n\ndef solve():\n    \"\"\"Main function to run the test suite and print results.\"\"\"\n    test_cases = [\n        (1.0, 0.0, 2.0, 3.2, 4.4),   # Case 1\n        (0.0, 1.0, 2.0, 3.7, 1.1),   # Case 2\n        (1.0, 1.0, 2.0, 2.7, 5.3),   # Case 3\n        (0.0, 0.0, 2.0, 6.5, 3.0),   # Case 4\n        (1.0, 1.0, 10.0, 2.0, 4.0),  # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_case(case)\n        results.append(result)\n\n    # Format the output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The process of discretizing physical laws onto a grid, while powerful, can introduce non-physical numerical artifacts. One of the most subtle yet important of these is the spurious self-force, where a particle can exert a net force on itself due to asymmetries in the numerical algorithm. This practice  provides a clear and powerful demonstration of this effect by comparing two different grid layouts: a collocated grid and a staggered (Yee) grid. By calculating the self-force in each case, you will discover why the staggered arrangement is a cornerstone of modern PIC design, as it intrinsically cancels this spurious force through symmetry, leading to vastly superior long-term accuracy in particle trajectory calculations.",
            "id": "3338067",
            "problem": "Consider a one-dimensional, periodic electrostatic Particle-In-Cell (PIC) model on a uniform grid. The goal is to compare staggered-grid storage (Yee arrangement) versus collocated-grid storage of the electric field by quantifying the spurious self-force on a single particle held at rest exactly at a cell center. The comparison must be performed by computing the net self-force $\\mathbf{F}_{\\text{self}}$ (in Newtons) due solely to the particle’s own deposited charge and the numerical field solve and gathering, under scientifically consistent discrete assumptions.\n\nFoundational base and discrete model. Begin from Gauss’s law in differential form, $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$, and the electrostatic potential definition $\\mathbf{E} = -\\nabla \\phi$, with $\\varepsilon_0$ the vacuum permittivity. In one spatial dimension with periodic boundary conditions of domain length $L$, assume the charge density $\\rho(x)$ has zero spatial mean so that the discrete Poisson equation is solvable. Use a uniform grid of $N$ cells, cell size $\\Delta x = L/N$, with cell centers at locations $x_i = (i + \\tfrac{1}{2}) \\Delta x$ for integer $i \\in \\{0,1,\\dots,N-1\\}$. Store the electrostatic potential $\\phi$ at cell centers. Introduce a single particle at rest with charge $q$ located exactly at the center of cell index $i_0$, and neutralize its net charge by a uniform background of density $-q/L$, so that the discrete charge density is\n$$\n\\rho_i = \\frac{q}{\\Delta x} \\delta_{i,i_0} - \\frac{q}{L},\n$$\nwhere $\\delta_{i,i_0}$ is the Kronecker delta. Use cloud-in-cell (CIC) deposition and gathering, which in this special configuration reduces to weight one at $i_0$ and zero elsewhere for operations defined at cell centers, and weight one-half to each adjacent face for operations defined at cell faces.\n\nDefine and compare two field-storage and discrete-operator configurations:\n\n1. Staggered-grid (Yee arrangement): store the electric field component $E_x$ on cell faces at positions $x_{i+\\tfrac{1}{2}} = (i+1)\\Delta x$, while storing $\\rho$ and $\\phi$ at cell centers $x_i$. Compute $\\phi$ at centers by solving the periodic discrete Poisson equation in Fourier space,\n$$\n-\\Delta_d \\phi_i = \\frac{\\rho_i}{\\varepsilon_0},\n$$\nwith the discrete Laplacian eigenvalue $\\lambda_m = \\frac{4}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi m}{N}\\right)$ for mode index $m$. The zero mode is set to zero, $\\phi_{k=0} = 0$, ensuring zero-mean potential. Compute face-centered electric field via the discrete gradient $E_{x,i+\\tfrac{1}{2}} = -(\\phi_{i+1} - \\phi_i)/\\Delta x$, and gather to the particle at the center of cell $i_0$ by symmetric CIC averaging of the adjacent faces:\n$$\nE_{p}^{\\text{Yee}} = \\frac{1}{2}\\left(E_{x,i_0-\\tfrac{1}{2}} + E_{x,i_0+\\tfrac{1}{2}}\\right).\n$$\n\n2. Collocated-grid: store $E_x$ at cell centers together with $\\rho$ and $\\phi$. Compute $\\phi$ at centers by the same discrete Poisson equation as above. Then compute cell-centered $E_x$ using a forward-difference discrete gradient $E_{x,i} = -(\\phi_{i+1} - \\phi_i)/\\Delta x$. Gather to the particle using CIC weights at centers, which reduces to evaluation at the particle cell center:\n$$\nE_{p}^{\\text{Coll}} = E_{x,i_0}.\n$$\n\nIn both configurations, compute the self-force\n$$\n\\mathbf{F}_{\\text{self}} = q\\, E_{p} \\,\\hat{\\mathbf{x}},\n$$\nand report the scalar value $F_{\\text{self}} = q E_p$ in Newtons. The particle is at rest, so there is no magnetic force contribution.\n\nYour task. Implement a complete, runnable program that:\n- Constructs the discrete charge density $\\rho_i$ for the specified parameters.\n- Solves the periodic one-dimensional discrete Poisson equation in Fourier space for $\\phi_i$ using the discrete Laplacian eigenvalues given above, with $\\phi_{k=0}=0$.\n- Computes $E_x$ for both the staggered-grid and collocated-grid configurations as defined, gathers each to the particle position using CIC rules, and computes $F_{\\text{self}}$ for each configuration.\n- Produces numerical results for a specified test suite.\n\nUnits and output. Express all forces in Newtons. Angles are not applicable. The final program output must be a single line containing a comma-separated list of per-test-case results, where each result is the pair $[F_{\\text{self}}^{\\text{Yee}}, F_{\\text{self}}^{\\text{Coll}}]$ for that case. For example: \"[val1,val2,val3]\" where each \"valk\" is itself a list written as \"[F_Yee,F_Coll]\".\n\nTest suite. Use the following test cases, each specified by $(N, L, q, \\varepsilon_0)$:\n- Case A (happy path): $N = 64$, $L = 1.0$ m, $q = 1.0 \\times 10^{-9}$ C, $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ F/m.\n- Case B (coarse resolution boundary): $N = 8$, $L = 1.0$ m, $q = 1.0 \\times 10^{-9}$ C, $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ F/m.\n- Case C (sign edge case): $N = 64$, $L = 1.0$ m, $q = -1.0 \\times 10^{-9}$ C, $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ F/m.\n- Case D (larger domain, finer grid): $N = 256$, $L = 2.0$ m, $q = 5.0 \\times 10^{-10}$ C, $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ F/m.\n\nImplementation constraints. The program must be self-contained, require no input, and strictly use the runtime environment specified in the final answer. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each per-case result itself a two-element list: \"[[F_A_Yee,F_A_Coll],[F_B_Yee,F_B_Coll],[F_C_Yee,F_C_Coll],[F_D_Yee,F_D_Coll]]\".",
            "solution": "The problem statement is critically validated and found to be valid. It is scientifically sound, self-contained, well-posed, and describes a standard numerical experiment in computational plasma physics for analyzing spurious self-forces in Particle-In-Cell (PIC) methods. All required parameters, equations, and discrete operators are unambiguously defined.\n\nThe solution proceeds by implementing the specified numerical algorithm. We will calculate the spurious self-force on a single particle at rest at a grid cell center for two different numerical schemes: a staggered-grid (Yee) scheme and a collocated-grid scheme.\n\n**1. Model Discretization and Setup**\n\nFor each test case, we are given the number of grid cells $N$, the domain length $L$, the particle charge $q$, and the vacuum permittivity $\\varepsilon_0$.\nThe grid cell size is $\\Delta x = L/N$. The domain consists of $N$ cells, with centers at $x_i = (i + \\tfrac{1}{2})\\Delta x$ for $i \\in \\{0, 1, \\dots, N-1\\}$.\n\nA single particle of charge $q$ is placed at the center of cell $i_0$. Due to the periodic nature of the domain, the choice of $i_0$ is arbitrary; we select $i_0 = N/2$ for convenience. The Cloud-In-Cell (CIC) charge deposition scheme for a particle at a cell center simplifies to depositing the entire charge into that cell. To ensure the solvability of the periodic Poisson equation, a neutralizing background charge density $-q/L$ is added. The discrete charge density at each cell center $i$ is thus:\n$$\n\\rho_i = \\frac{q}{\\Delta x} \\delta_{i,i_0} - \\frac{q}{L}\n$$\nwhere $\\delta_{i,i_0}$ is the Kronecker delta. This formulation correctly ensures that the total charge in the domain is zero: $\\sum_{i=0}^{N-1} \\rho_i \\Delta x = 0$.\n\n**2. Solving the Discrete Poisson Equation**\n\nThe electrostatic potential $\\phi$ is stored at the cell centers $x_i$ and is related to the charge density $\\rho_i$ by the discrete Poisson equation:\n$$\n-\\Delta_d \\phi_i = \\frac{\\rho_i}{\\varepsilon_0}\n$$\nwhere $-\\Delta_d$ is the discrete negative Laplacian operator. We solve this equation in Fourier space, as specified. Let $\\tilde{\\phi}_m$ and $\\tilde{\\rho}_m$ be the Discrete Fourier Transforms (DFTs) of $\\phi_i$ and $\\rho_i$, respectively. The equation transforms to:\n$$\n\\lambda_m \\tilde{\\phi}_m = \\frac{\\tilde{\\rho}_m}{\\varepsilon_0}\n$$\nwhere $\\lambda_m$ are the eigenvalues of the $-\\Delta_d$ operator, given by:\n$$\n\\lambda_m = \\frac{4}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi m}{N}\\right) \\quad \\text{for mode index } m \\in \\{0, 1, \\dots, N-1\\}\n$$\nFor the DC mode $m=0$, we have $\\lambda_0 = 0$. The zero-mean charge density ensures $\\tilde{\\rho}_0 = \\sum_i \\rho_i = 0$, making the $m=0$ equation $0 \\cdot \\tilde{\\phi}_0 = 0$. The problem specifies setting the mean potential to zero, which translates to $\\tilde{\\phi}_0 = 0$. For all other modes ($m  0$), we can solve for $\\tilde{\\phi}_m$:\n$$\n\\tilde{\\phi}_m = \\frac{\\tilde{\\rho}_m}{\\varepsilon_0 \\lambda_m}\n$$\nThe algorithm for finding the potential $\\phi_i$ is as follows:\n1. Construct the real-space charge density array $\\rho_i$.\n2. Compute its DFT $\\tilde{\\rho}_m$ using a Fast Fourier Transform (FFT) algorithm.\n3. Compute the eigenvalues $\\lambda_m$.\n4. Construct the Fourier-space potential $\\tilde{\\phi}_m$ using the formula above, setting $\\tilde{\\phi}_0 = 0$.\n5. Compute the inverse DFT of $\\tilde{\\phi}_m$ to obtain $\\phi_i$. Since the initial $\\rho_i$ is real and exhibits symmetry, the resulting $\\phi_i$ will be real (up to numerical precision errors).\n\n**3. Self-Force Calculation: Staggered-Grid (Yee) Scheme**\n\nIn the Yee scheme, the electric field $E_x$ is staggered from the potential $\\phi$, stored on cell faces at locations $x_{i+\\tfrac{1}{2}} = (i+1)\\Delta x$. The discrete gradient is a central difference:\n$$\nE_{x,i+\\tfrac{1}{2}} = -\\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}\n$$\nThe particle is at $x_{i_0}$. The electric field at the particle's position, $E_{p}^{\\text{Yee}}$, is gathered using CIC weights. For a particle at a cell center, this means averaging the fields from the two adjacent faces:\n$$\nE_{p}^{\\text{Yee}} = \\frac{1}{2}\\left(E_{x,i_0-\\tfrac{1}{2}} + E_{x,i_0+\\tfrac{1}{2}}\\right) = \\frac{1}{2}\\left( -\\frac{\\phi_{i_0} - \\phi_{i_0-1}}{\\Delta x} - \\frac{\\phi_{i_0+1} - \\phi_{i_0}}{\\Delta x} \\right) = -\\frac{\\phi_{i_0+1} - \\phi_{i_0-1}}{2\\Delta x}\n$$\nDue to the symmetry of the problem setup (a single point charge in a periodic domain), the resulting potential $\\phi_i$ must be symmetric about the particle's location $i_0$. That is, $\\phi_{i_0+k} = \\phi_{i_0-k}$ for any integer $k$. In particular, $\\phi_{i_0+1} = \\phi_{i_0-1}$. Consequently, the gathered electric field $E_{p}^{\\text{Yee}}$ is analytically zero.\nThe self-force is $F_{\\text{self}}^{\\text{Yee}} = q E_{p}^{\\text{Yee}} = 0$. Any non-zero result will be due to floating-point representation errors and should be negligible.\n\n**4. Self-Force Calculation: Collocated-Grid Scheme**\n\nIn the collocated scheme, the electric field $E_x$ is stored at the same cell-center locations $x_i$ as $\\phi$ and $\\rho$. The potential $\\phi_i$ is computed in the same way as before. The discrete gradient is specified as a forward difference:\n$$\nE_{x,i} = -\\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}\n$$\nThe field is gathered at the particle's location $i_0$. For a particle at a cell center, CIC gathering simplifies to direct evaluation:\n$$\nE_{p}^{\\text{Coll}} = E_{x,i_0} = -\\frac{\\phi_{i_0+1} - \\phi_{i_0}}{\\Delta x}\n$$\nAs established, the potential $\\phi_i$ has a symmetric extremum at $i_0$ (a peak for $q0$, a trough for $q0$). Therefore, $\\phi_{i_0+1} \\neq \\phi_{i_0}$, and the field $E_{p}^{\\text{Coll}}$ will be non-zero. This non-zero field results from the asymmetry of the forward-difference operator. The resulting self-force is:\n$$\nF_{\\text{self}}^{\\text{Coll}} = q E_{p}^{\\text{Coll}} = -q\\frac{\\phi_{i_0+1} - \\phi_{i_0}}{\\Delta x}\n$$\nAn analytical calculation reveals that this force evaluates to $F_{\\text{self}}^{\\text{Coll}} = \\frac{q^2(N-1)}{2N\\varepsilon_0}$. This force is always positive (in the $+\\hat{\\mathbf{x}}$ direction) and approaches a constant value of $q^2/(2\\varepsilon_0)$ as $N \\to \\infty$. This confirms that the collocated scheme with a forward-difference gradient produces a significant and systematic spurious self-force.\n\nThe program below implements these calculations for the provided test suite.",
            "answer": "```python\nimport numpy as np\n\ndef calculate_forces(N, L, q, epsilon_0):\n    \"\"\"\n    Calculates the spurious self-force for staggered and collocated schemes.\n\n    Args:\n        N (int): Number of grid cells.\n        L (float): Length of the 1D periodic domain.\n        q (float): Charge of the particle.\n        epsilon_0 (float): Vacuum permittivity.\n\n    Returns:\n        list: A two-element list containing [F_self_Yee, F_self_Coll].\n    \"\"\"\n    # 1. Setup Grid and Charge Density\n    dx = L / N\n    # Place particle at the center of cell i0 for symmetry\n    i0 = N // 2\n    \n    # Create the discrete charge density array rho_i\n    # rho_i = (q / dx) * delta_{i,i0} - q / L\n    rho = np.full(N, -q / L)\n    rho[i0] += q / dx\n\n    # 2. Solve Poisson's Equation for phi\n    # FFT of the charge density\n    rho_tilde = np.fft.fft(rho)\n\n    # Eigenvalues of the discrete negative Laplacian\n    m = np.arange(N)\n    # The m=0 eigenvalue is 0. Avoid division by zero.\n    with np.errstate(divide='ignore', invalid='ignore'):\n        lambda_m = (4.0 / dx**2) * np.sin(np.pi * m / N)**2\n\n    # Solve for phi_tilde in Fourier space: phi_tilde = rho_tilde / (epsilon_0 * lambda)\n    phi_tilde = np.zeros(N, dtype=complex)\n    # For m  0 (lambda_m != 0)\n    phi_tilde[1:] = rho_tilde[1:] / (epsilon_0 * lambda_m[1:])\n    # For m = 0, phi_tilde[0] is 0 as specified (zero mean potential).\n\n    # Inverse FFT to get phi in real space\n    phi = np.fft.ifft(phi_tilde)\n    phi = np.real(phi) # Potential should be real, discard negligible imag part\n\n    # 3. Calculate Staggered-Grid (Yee) Force\n    # E_p^Yee = - (phi_{i0+1} - phi_{i0-1}) / (2 * dx)\n    # Handle periodic boundary conditions for indices\n    i_prev = (i0 - 1 + N) % N\n    i_next = (i0 + 1) % N\n    \n    phi_prev = phi[i_prev]\n    phi_next = phi[i_next]\n\n    E_p_Yee = - (phi_next - phi_prev) / (2.0 * dx)\n    F_self_Yee = q * E_p_Yee\n\n    # 4. Calculate Collocated-Grid Force\n    # E_p^Coll = - (phi_{i0+1} - phi_{i0}) / (dx)\n    phi_i0 = phi[i0]\n    \n    E_p_Coll = - (phi_next - phi_i0) / dx\n    F_self_Coll = q * E_p_Coll\n\n    return [F_self_Yee, F_self_Coll]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Test suite: (N, L, q, epsilon_0)\n    test_cases = [\n        # Case A: happy path\n        (64, 1.0, 1.0e-9, 8.8541878128e-12),\n        # Case B: coarse resolution boundary\n        (8, 1.0, 1.0e-9, 8.8541878128e-12),\n        # Case C: sign edge case\n        (64, 1.0, -1.0e-9, 8.8541878128e-12),\n        # Case D: larger domain, finer grid\n        (256, 2.0, 5.0e-10, 8.8541878128e-12),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, q, epsilon_0 = case\n        forces = calculate_forces(N, L, q, epsilon_0)\n        results.append(forces)\n\n    # Format the output string exactly as required, removing spaces\n    formatted_results = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}