{
    "hands_on_practices": [
        {
            "introduction": "在电磁-结构耦合的计算模型中，洛伦兹力（$ \\mathbf{J} \\times \\mathbf{B} $）是传递相互作用的关键物理机制。此练习将指导您完成一个基础而核心的任务：如何通过有限元方法（FEM），将连续分布的洛伦兹体力密度转化为作用在单元节点上的等效节点力。掌握这一推导和实现过程，是从零开始构建磁-固耦合分析求解器的关键第一步。",
            "id": "3304507",
            "problem": "一个二维磁弹性体占据平面中的一个多边形域，厚度为单位长度。在小变形、准静态磁场、线性和各向同性磁性材料以及忽略磁致伸缩的假设下，电磁场和结构通过洛伦兹体力密度弱耦合。从准静态磁场的麦克斯韦方程组和连续介质力学中的虚功原理出发，推导将电磁自由度映射到单个线性三角形单元的机械节点力矢量的单元级耦合。然后实现推导出的表达式，以计算下方测试套件指定的单元级耦合矩阵或一致性机械节点力矢量。所有计算必须假设单元厚度为单位长度且电流密度在整个单元内恒定。当请求计算机械力时，最终答案以牛顿为单位表示，并四舍五入到六位小数。\n\n基本出发点和建模假设：\n- 使用磁矢量势的准静态磁场，其中磁通密度满足 $\\nabla \\times \\mathbf{A} = \\mathbf{B}$，旋度方程为 $\\nabla \\times \\mathbf{H} = \\mathbf{J}$，并且 $\\mathbf{B} = \\mu \\mathbf{H}$，其中 $\\mu$ 为恒定标量。\n- 二维中的面外磁矢量势表示：$\\mathbf{A} = A_z(x,y)\\,\\hat{\\mathbf{k}}$，因此 $\\mathbf{B} = \\nabla \\times \\left(A_z \\hat{\\mathbf{k}}\\right)$。\n- 电流密度为面外方向且在每个单元内恒定：$\\mathbf{J} = J_z \\hat{\\mathbf{k}}$，其中 $J_z$ 是一个单元常数。\n- 由电磁体力密度引起的机械虚功由 $\\delta W = \\int_{\\Omega} \\delta \\mathbf{u} \\cdot \\left(\\mathbf{J} \\times \\mathbf{B}\\right)\\, \\mathrm{d}\\Omega$ 给出，忽略单元边界上的麦克斯韦表面力。\n- 采用有限元法 (FEM)，在节点索引为 $i \\in \\{1,2,3\\}$、坐标为 $(x_i,y_i)$ 的单个三角形上使用线性形函数。磁矢量势近似为 $A_z(x,y) \\approx \\sum_{i=1}^3 N_i(x,y)\\, a_i$，其中 $a_i$ 是节点值，$N_i$ 是标量形函数。机械位移插值使用相同的形函数 $N_i$，每个节点有两个位移分量。\n\n推导目标：\n- 从以上基础出发，推导线性三角形单元的磁通密度分量 $\\left(B_x, B_y\\right)$ 关于形函数梯度和节点磁势值 $\\{a_i\\}_{i=1}^3$ 的显式表达式。\n- 使用洛伦兹力密度 $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$ 和 $\\mathbf{J} = J_z \\hat{\\mathbf{k}}$，用节点磁势值 $\\{a_i\\}_{i=1}^3$ 表示 $\\mathbf{f}$。\n- 通过对机械形函数进行虚功积分，推导单元的一致性节点机械力矢量 $\\mathbf{F}_e \\in \\mathbb{R}^{6}$，并得到将磁节点矢量 $\\mathbf{a}_e = [a_1, a_2, a_3]^T$ 映射到 $\\mathbf{F}_e$ 的 $6 \\times 3$ 耦合矩阵 $C_e$，即 $\\mathbf{F}_e = C_e \\mathbf{a}_e$。假设单元厚度为单位长度且 $J_z$ 在单元上是恒定的。不要对三角形的任何特殊朝向做假设。\n\n计算任务：\n- 为节点坐标为 $\\left(x_i, y_i\\right)$（$i \\in \\{1,2,3\\}$）且 $J_z$ 在单元上恒定的单个线性三角形单元实现推导出的表达式。\n- 如果测试用例请求耦合矩阵，则按行主序输出展开的矩阵元素：行对应于排序为 $\\left[u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y}\\right]$ 的机械自由度，列对应于 $\\left[a_1, a_2, a_3\\right]$。\n- 如果测试用例请求机械节点力矢量，则计算 $\\mathbf{F}_e = C_e \\mathbf{a}_e$ 并将其作为长度为6的列表输出，排序为 $\\left[F_{1x}, F_{1y}, F_{2x}, F_{2y}, F_{3x}, F_{3y}\\right]$。\n- 单位和四舍五入：\n  - 坐标 $\\left(x_i,y_i\\right)$ 以米为单位。\n  - 电流密度 $J_z$ 以安培/平方米 $\\left(\\mathrm{A}/\\mathrm{m}^2\\right)$ 为单位。\n  - 磁矢量势节点值 $a_i$ 以韦伯/米 $\\left(\\mathrm{Wb}/\\mathrm{m}\\right)$ 为单位。\n  - 单元厚度为单位米，因此得到的节点力以牛顿 $\\left(\\mathrm{N}\\right)$ 为单位。\n  - 所有数值输出必须四舍五入到 $6$ 位小数。\n- 本问题不使用角度单位。\n- 程序必须生成单行输出，其中包含所有测试用例的结果，格式为方括号括起来的逗号分隔列表，每个结果本身也是一个方括号括起来的逗号分隔列表。对于耦合矩阵，按行主序输出展开的元素；对于力矢量，按顺序输出六个分量。例如，输出格式类似于 $\\left[\\,[\\ldots],\\,[\\ldots],\\,\\ldots\\,\\right]$，不含空格，所有数字四舍五入到 $6$ 位小数。\n\n测试套件：\n- 测试用例 1 (耦合矩阵): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=2.0$。\n- 测试用例 2 (力矢量): $\\mathrm{mode}=\\text{\"force\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=1.0$, $\\left[a_1,a_2,a_3\\right]=[0.0,1.0,0.0]$。\n- 测试用例 3 (零耦合): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=0.0$。\n- 测试用例 4 (缩放几何，耦合矩阵): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(2,1)$, $\\left(x_2,y_2\\right)=(5,1)$, $\\left(x_3,y_3\\right)=(2,4)$, $J_z=3.0$。\n- 测试用例 5 (负电流，耦合矩阵): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=-1.5$。\n- 测试用例 6 (非正交三角形上的力矢量): $\\mathrm{mode}=\\text{\"force\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(2,0)$, $\\left(x_3,y_3\\right)=(1,1.7320508075688772)$, $J_z=0.5$, $\\left[a_1,a_2,a_3\\right]=[0.0,2.0,-0.7320508075688772]$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也用方括号括起来，并且所有浮点数都四舍五入到 $6$ 位小数，例如：$\\left[\\,[r_{1,1},\\ldots,r_{1,n_1}],\\,[r_{2,1},\\ldots,r_{2,n_2}],\\ldots\\,\\right]$，其中每个 $r_{k,j}$ 是一个四舍五入到 $6$ 位小数的浮点数。",
            "solution": "本任务是推导并实现将电磁自由度（节点磁矢量势）映射到线性三角形单元的机械节点力的单元级耦合。该耦合源于二维准静态磁-结构模型中的洛伦兹体力。\n\n### 耦合矩阵的推导\n\n推导过程分三步进行：\n1.  用节点磁矢量势值 $\\mathbf{a}_e$ 表示磁通密度 $\\mathbf{B}$。\n2.  使用先前得到的 $\\mathbf{B}$ 的表达式，推导洛伦兹体力密度 $\\mathbf{f}$。\n3.  使用虚功原理求出一致性节点力矢量 $\\mathbf{F}_e$，并提取耦合矩阵 $C_e$。\n\n**1. 磁通密度 $\\mathbf{B}$**\n\n问题假设在一个二维模型中，磁矢量势 $\\mathbf{A}$ 只有一个面外分量 $\\mathbf{A} = A_z(x,y)\\,\\hat{\\mathbf{k}}$。磁通密度 $\\mathbf{B}$ 由 $\\mathbf{A}$ 的旋度给出：\n$$\n\\mathbf{B} = \\nabla \\times \\mathbf{A} = \\nabla \\times (A_z\\,\\hat{\\mathbf{k}}) = \\begin{vmatrix} \\hat{\\mathbf{i}} & \\hat{\\mathbf{j}} & \\hat{\\mathbf{k}} \\\\ \\frac{\\partial}{\\partial x} & \\frac{\\partial}{\\partial y} & \\frac{\\partial}{\\partial z} \\\\ 0 & 0 & A_z \\end{vmatrix} = \\frac{\\partial A_z}{\\partial y} \\hat{\\mathbf{i}} - \\frac{\\partial A_z}{\\partial x} \\hat{\\mathbf{j}}\n$$\n因此，磁通密度的面内分量为 $B_x = \\frac{\\partial A_z}{\\partial y}$ 和 $B_y = -\\frac{\\partial A_z}{\\partial x}$。\n\n在一个线性三角形有限元内，场 $A_z(x,y)$ 由其节点值 $\\{a_1, a_2, a_3\\}$ 使用线性形函数 $N_i(x,y)$ 插值得到：\n$$\nA_z(x,y) \\approx \\sum_{i=1}^{3} N_i(x,y) a_i\n$$\n于是，$A_z$ 的梯度为：\n$$\n\\nabla A_z = \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = \\sum_{i=1}^{3} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} a_i\n$$\n对于节点为 $(x_1, y_1)$、$(x_2, y_2)$ 和 $(x_3, y_3)$ 的线性三角形单元，形函数的梯度在整个单元上是恒定的。它们由以下公式给出：\n$$\n\\frac{\\partial N_i}{\\partial x} = \\frac{b_i}{2 A_e}, \\quad \\frac{\\partial N_i}{\\partial y} = \\frac{d_i}{2 A_e}\n$$\n其中 $A_e$ 是单元的面积，系数 $b_i$ 和 $d_i$ 是节点坐标的函数：\n$$\n\\begin{array}{ll}\nb_1 = y_2 - y_3, & \\quad d_1 = x_3 - x_2 \\\\\nb_2 = y_3 - y_1, & \\quad d_2 = x_1 - x_3 \\\\\nb_3 = y_1 - y_2, & \\quad d_3 = x_2 - x_1\n\\end{array}\n$$\n梯度 $\\nabla A_z$ 可以写成矩阵形式：\n$$\n\\nabla A_z = \\frac{1}{2 A_e} \\begin{bmatrix} b_1 & b_2 & b_3 \\\\ d_1 & d_2 & d_3 \\end{bmatrix} \\begin{pmatrix} a_1 \\\\ a_2 \\\\ a_3 \\end{pmatrix} = \\mathbf{B}_{mat} \\mathbf{a}_e\n$$\n由于 $\\mathbf{B}_{mat}$ 和 $\\mathbf{a}_e$ 在单元内相对于 $(x,y)$ 是常数，所以 $\\nabla A_z$ 也是常数。因此，磁通密度 $\\mathbf{B}$ 在整个单元上也是恒定的：\n$$\n\\begin{pmatrix} B_x \\\\ B_y \\end{pmatrix} = \\begin{pmatrix} \\frac{\\partial A_z}{\\partial y} \\\\ -\\frac{\\partial A_z}{\\partial x} \\end{pmatrix} = \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix} \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix} \\mathbf{B}_{mat} \\mathbf{a}_e = \\frac{1}{2 A_e} \\begin{bmatrix} d_1 & d_2 & d_3 \\\\ -b_1 & -b_2 & -b_3 \\end{bmatrix} \\mathbf{a}_e\n$$\n\n**2. 洛伦兹力密度 $\\mathbf{f}$**\n\n洛伦兹体力密度由 $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$ 给出。电流密度 $\\mathbf{J}$ 假定为恒定且为面外方向，即 $\\mathbf{J} = J_z \\hat{\\mathbf{k}}$。\n$$\n\\mathbf{f} = (J_z \\hat{\\mathbf{k}}) \\times (B_x \\hat{\\mathbf{i}} + B_y \\hat{\\mathbf{j}}) = J_z B_x (\\hat{\\mathbf{k}} \\times \\hat{\\mathbf{i}}) + J_z B_y (\\hat{\\mathbf{k}} \\times \\hat{\\mathbf{j}}) = J_z B_x \\hat{\\mathbf{j}} - J_z B_y \\hat{\\mathbf{i}}\n$$\n力密度的分量为 $f_x = -J_z B_y$ 和 $f_y = J_z B_x$。以矢量形式表示：\n$$\n\\begin{pmatrix} f_x \\\\ f_y \\end{pmatrix} = J_z \\begin{pmatrix} -B_y \\\\ B_x \\end{pmatrix} = J_z \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix} \\begin{pmatrix} B_x \\\\ B_y \\end{pmatrix}\n$$\n代入用 $\\nabla A_z$ 表示的 $\\mathbf{B}$ 的表达式：\n$$\n\\begin{pmatrix} f_x \\\\ f_y \\end{pmatrix} = J_z \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix} \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = J_z \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = J_z \\nabla A_z\n$$\n所以，力密度与磁矢量势的梯度成正比，$\\mathbf{f} = J_z \\mathbf{B}_{mat} \\mathbf{a}_e$。由于 $\\nabla A_z$ 在单元上是常数，所以 $\\mathbf{f}$ 也是常数。\n\n**3. 节点力矢量 $\\mathbf{F}_e$ 和耦合矩阵 $C_e$**\n\n等效节点力由虚功原理推导得出。体力所做的虚功为：\n$$\n\\delta W = \\int_{V_e} \\delta \\mathbf{u} \\cdot \\mathbf{f} \\, dV\n$$\n其中 $\\delta\\mathbf{u}$ 是虚位移场。在有限元法框架中，位移场 $\\mathbf{u}$ 使用与 $A_z$ 相同的形函数进行插值：\n$$\n\\mathbf{u}(x,y) = \\begin{bmatrix} N_1 & 0 & N_2 & 0 & N_3 & 0 \\\\ 0 & N_1 & 0 & N_2 & 0 & N_3 \\end{bmatrix} \\mathbf{u}_e = \\mathbf{N}(x,y) \\mathbf{u}_e\n$$\n其中 $\\mathbf{u}_e \\in \\mathbb{R}^6$ 是节点位移矢量。虚功变为：\n$$\n\\delta W = \\int_{V_e} (\\mathbf{N} \\delta\\mathbf{u}_e)^T \\mathbf{f} \\, dV = \\delta\\mathbf{u}_e^T \\left( \\int_{V_e} \\mathbf{N}^T \\mathbf{f} \\, dV \\right)\n$$\n根据定义，$\\delta W = \\delta\\mathbf{u}_e^T \\mathbf{F}_e$，所以一致性节点力矢量为：\n$$\n\\mathbf{F}_e = \\int_{V_e} \\mathbf{N}^T \\mathbf{f} \\, dV\n$$\n对于厚度为单位长度 $t=1$ 的二维问题，体积分变为面积分，$dV = t \\, dA = dA$。由于力密度 $\\mathbf{f}$ 在整个单元上是恒定的，我们可以将其从积分中提出：\n$$\n\\mathbf{F}_e = \\left( \\int_{A_e} \\mathbf{N}^T \\, dA \\right) \\mathbf{f}\n$$\n形函数矩阵 $\\mathbf{N}^T$ 的积分为：\n$$\n\\int_{A_e} \\mathbf{N}^T dA = \\int_{A_e} \\begin{bmatrix} N_1 & 0 \\\\ 0 & N_1 \\\\ N_2 & 0 \\\\ 0 & N_2 \\\\ N_3 & 0 \\\\ 0 & N_3 \\end{bmatrix} dA = \\begin{bmatrix} \\int N_1 dA & 0 \\\\ 0 & \\int N_1 dA \\\\ \\vdots & \\vdots \\\\ \\int N_3 dA & 0 \\\\ 0 & \\int N_3 dA \\end{bmatrix}\n$$\n一个线性形函数在其三角形单元上的积分为 $\\int_{A_e} N_i \\, dA = A_e/3$。因此：\n$$\n\\int_{A_e} \\mathbf{N}^T dA = \\frac{A_e}{3} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ 1 & 0 \\\\ 0 & 1 \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix}\n$$\n将此式和 $\\mathbf{f}$ 的表达式代入 $\\mathbf{F}_e$ 的方程：\n$$\n\\mathbf{F}_e = \\frac{A_e}{3} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ \\vdots & \\vdots \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\left( J_z \\mathbf{B}_{mat} \\mathbf{a}_e \\right) = \\frac{A_e J_z}{3} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ \\vdots & \\vdots \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\left( \\frac{1}{2 A_e} \\begin{bmatrix} b_1 & b_2 & b_3 \\\\ d_1 & d_2 & d_3 \\end{bmatrix} \\right) \\mathbf{a}_e\n$$\n问题指定了单位厚度 $t=1\\,\\text{m}$。量纲分析要求包含这个厚度。力的完整表达式为 $\\mathbf{F}_e = t \\frac{A_e}{3} ...$。\n$$\n\\mathbf{F}_e = t \\frac{A_e J_z}{3} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ \\vdots & \\vdots \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\left( \\frac{1}{2 A_e} \\begin{bmatrix} b_1 & b_2 & b_3 \\\\ d_1 & d_2 & d_3 \\end{bmatrix} \\right) \\mathbf{a}_e = \\frac{t J_z}{6} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ \\vdots & \\vdots \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\begin{bmatrix} b_1 & b_2 & b_3 \\\\ d_1 & d_2 & d_3 \\end{bmatrix} \\mathbf{a}_e\n$$\n$\\mathbf{F}_e = C_e \\mathbf{a}_e$ 这一项使我们能够确定 $6 \\times 3$ 的耦合矩阵 $C_e$：\n$$\nC_e = \\frac{t J_z}{6} \\begin{bmatrix}\nb_1 & b_2 & b_3 \\\\\nd_1 & d_2 & d_3 \\\\\nb_1 & b_2 & b_3 \\\\\nd_1 & d_2 & d_3 \\\\\nb_1 & b_2 & b_3 \\\\\nd_1 & d_2 & d_3\n\\end{bmatrix}\n$$\n当 $t=1$ 时，需要实现的耦合矩阵的最终表达式为：\n$$\nC_e = \\frac{J_z}{6} \\begin{bmatrix}\ny_2 - y_3 & y_3 - y_1 & y_1 - y_2 \\\\\nx_3 - x_2 & x_1 - x_3 & x_2 - x_1 \\\\\ny_2 - y_3 & y_3 - y_1 & y_1 - y_2 \\\\\nx_3 - x_2 & x_1 - x_3 & x_2 - x_1 \\\\\ny_2 - y_3 & y_3 - y_1 & y_1 - y_2 \\\\\nx_3 - x_2 & x_1 - x_3 & x_2 - x_1\n\\end{bmatrix}\n$$\n力矢量 $\\mathbf{F}_e$ 是通过将该矩阵乘以节点矢量势值 $\\mathbf{a}_e = [a_1, a_2, a_3]^T$ 计算得出的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the magneto-structural coupling problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\"mode\": \"matrix\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": 2.0},\n        {\"mode\": \"force\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": 1.0, \"a\": [0.0, 1.0, 0.0]},\n        {\"mode\": \"matrix\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": 0.0},\n        {\"mode\": \"matrix\", \"coords\": ((2, 1), (5, 1), (2, 4)), \"Jz\": 3.0},\n        {\"mode\": \"matrix\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": -1.5},\n        {\"mode\": \"force\", \"coords\": ((0, 0), (2, 0), (1, 1.7320508075688772)), \"Jz\": 0.5, \"a\": [0.0, 2.0, -0.7320508075688772]},\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = compute_coupling(case)\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    results_str = []\n    for res_list in results:\n        res_list_str = [f\"{x:.6f}\" for x in res_list]\n        results_str.append(f\"[{','.join(res_list_str)}]\")\n    \n    print(f\"[{','.join(results_str)}]\")\n\ndef compute_coupling(case_data):\n    \"\"\"\n    Computes the coupling matrix or nodal force vector for a single linear triangular element.\n\n    Args:\n        case_data (dict): A dictionary containing the parameters for the test case.\n                          It must include 'mode', 'coords', and 'Jz'. If 'mode' is 'force',\n                          it must also include 'a'.\n\n    Returns:\n        list: A list of floats representing either the flattened coupling matrix\n              or the nodal force vector, rounded to 6 decimal places.\n    \"\"\"\n    mode = case_data[\"mode\"]\n    (x1, y1), (x2, y2), (x3, y3) = case_data[\"coords\"]\n    Jz = case_data[\"Jz\"]\n    \n    # As per the problem statement, element thickness t is 1 meter.\n    # The derived coupling matrix includes a factor t, so we set t=1.0.\n    t = 1.0\n    \n    # Calculate geometric coefficients b_i and d_i\n    b1 = y2 - y3\n    b2 = y3 - y1\n    b3 = y1 - y2\n    \n    d1 = x3 - x2\n    d2 = x1 - x3\n    d3 = x2 - x1\n    \n    # The core 2x3 matrix relating force density to nodal potentials (scaled by Jz)\n    # This corresponds to [ [b1, b2, b3], [d1, d2, d3] ]\n    core_matrix = np.array([[b1, b2, b3], [d1, d2, d3]])\n    \n    # Construct the 6x3 coupling matrix Ce by tiling the core matrix and scaling\n    # Ce = (t * Jz / 6) * [ core_matrix_tiled_vertically ]\n    C_e = (t * Jz / 6.0) * np.tile(core_matrix, (3, 1))\n\n    if mode == \"matrix\":\n        # Flatten the matrix in row-major order (numpy's default)\n        return C_e.flatten().tolist()\n    elif mode == \"force\":\n        a_e = np.array(case_data[\"a\"]).reshape(3, 1)\n        # Compute the nodal force vector F_e = C_e * a_e\n        F_e = C_e @ a_e\n        return F_e.flatten().tolist()\n\n# Run the solver\nsolve()\n```"
        },
        {
            "introduction": "在求解瞬态耦合问题时，时间积分算法的选择至关重要，一个看似直观的耦合策略可能在数值上引入非物理的能量，导致仿真结果失真甚至发散。本练习通过一个简化的线圈-梁系统，对比了“功率共轭”的能量守恒格式与一种“非共轭”的耦合格式在能量演化上的差异。通过亲手实现和分析，您将深刻理解为何在离散层面保持物理守恒律是保证多物理场仿真长期稳定性和准确性的核心。",
            "id": "3304517",
            "problem": "您需要分析和模拟一个集总电磁-结构系统中的数值能量交换，该系统由一个单匝线圈耦合到一个单自由度线性梁组成。电气部分被视为一个位置相关的电感器，无电阻、无电源，通过一个与时域有限差分(FDTD)方法一致的不变量进行更新；结构部分则通过 Newmark 系列格式进行更新。您的目标是实现两种时间积分耦合方法，量化离散能量行为，并找出避免人为能量增长的条件。\n\n连续模型如下。设梁的位移为 $x(t)$（单位：米），速度为 $v(t)$（单位：米/秒），质量为 $m$（单位：千克），刚度为 $k$（单位：牛顿/米）。线圈被建模为一个电感取决于梁位移的电感器，$L(x)$（单位：亨利）。设线圈电流为 $I(t)$（单位：安培），磁链为 $\\psi(t)$（单位：韦伯-匝）。假设电阻和电压源为零，因此电气回路方程为磁链守恒，\n$$\n\\frac{d\\psi}{dt} = 0,\\quad \\text{with}\\quad \\psi(t) = L(x(t))\\,I(t).\n$$\n磁共能为\n$$\nW_{\\mathrm{m}}(x,I) = \\frac{1}{2} L(x)\\, I^2,\n$$\n作用在梁上的电磁力是磁共能相对于 $x$ 的负梯度，对于标量状态，这简化为\n$$\nF_{\\mathrm{em}}(x,I) = \\frac{1}{2} I^2 \\frac{dL}{dx}(x).\n$$\n梁的运动方程为\n$$\nm\\,\\ddot{x}(t) + k\\,x(t) = F_{\\mathrm{em}}(x(t), I(t)).\n$$\n总连续能量为\n$$\nE(t) = \\frac{1}{2} m\\, v(t)^2 + \\frac{1}{2} k\\, x(t)^2 + \\frac{1}{2} L(x(t))\\, I(t)^2,\n$$\n在 $d\\psi/dt=0$ 和零阻尼的条件下，该能量是精确守恒的。\n\n您将在固定的时间范围 $T$（单位：秒）内比较两种离散耦合格式：\n- 格式 A（功率一致的 FDTD–Newmark 格式）：通过保持磁链恒定 $\\psi^{n+1} = \\psi^{n}$ 来强制执行与 FDTD 一致的不变量，并对梁使用参数为 $\\beta = 1/4$ 和 $\\gamma = 1/2$ 的 Newmark 梯形法则。在 $\\psi$ 保持恒定的情况下，电流为 $I(x) = \\psi / L(x)$。将加速度定义为位移的函数，\n$$\na(x) = \\frac{1}{m}\\left(\\frac{1}{2}\\,\\frac{\\psi^2}{L(x)^2}\\,\\frac{dL}{dx}(x) - k\\,x\\right).\n$$\n通过求解 Newmark 梯形法则的隐式更新方程来推进 $x^n \\mapsto x^{n+1}$\n$$\nx^{n+1} - \\frac{\\Delta t^2}{4}\\,a(x^{n+1}) = x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\,a(x^{n}),\n$$\n然后设置\n$$\nv^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a(x^{n}) + a(x^{n+1})\\right),\\quad I^{n+1} = \\frac{\\psi}{L(x^{n+1})}.\n$$\n在每一步中使用牛顿迭代法求解 $x^{n+1}$ 直至数值收敛。该格式被设计为在离散层面上是功率共轭的。\n\n- 格式 B（非一致的冻结电流耦合）：通过设置 $I^{n+1} = I^{n}$ 在每个步长内冻结电流，并使用步长开始时的位移和电流来评估电磁力，\n$$\nF_{\\mathrm{em}}^n = \\frac{1}{2} (I^n)^2 \\frac{dL}{dx}(x^n).\n$$\n使用相同的 Newmark 参数 $\\beta = 1/4$ 和 $\\gamma = 1/2$ 来推进梁的运动，但将 $F_{\\mathrm{em}}^n$ 视为在该步长内恒定，因此隐式方程简化为对 $x^{n+1}$ 的线性求解，\n$$\nx^{n+1} = \\frac{x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\left(\\frac{1}{m}\\left(F_{\\mathrm{em}}^{n} - k\\, x^{n}\\right)\\right) + \\frac{\\Delta t^2}{4m} F_{\\mathrm{em}}^{n}}{1 + \\frac{\\Delta t^2}{4}\\frac{k}{m}},\n$$\n然后\n$$\na^{n} = \\frac{1}{m}\\left(F_{\\mathrm{em}}^{n} - k\\, x^{n}\\right),\\quad a^{n+1} = \\frac{1}{m}\\left(F_{\\mathrm{em}}^{n} - k\\, x^{n+1}\\right),\\quad v^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a^{n} + a^{n+1}\\right).\n$$\n该格式有意设计为非功率共轭的，因为它冻结了电流，并在与电感共能不同的时间点评估力。\n\n对于这两种格式，计算每一步 $n$ 的离散总能量，\n$$\nE^{n} = \\frac{1}{2} m\\, (v^{n})^2 + \\frac{1}{2} k\\, (x^{n})^2 + \\frac{1}{2} L(x^{n})\\, (I^{n})^2.\n$$\n\n您的任务是编写一个程序，对于下面的参数集，使用均匀时间步长 $\\Delta t$ 和初始条件，模拟系统从 $t=0$ 到 $t=T$ 的行为，并为每个测试用例返回离散总能量相对于初始能量的最大相对增量，\n$$\n\\max_{0 \\le n \\le N} \\left(\\frac{E^{n} - E^{0}}{E^{0}}\\right),\n$$\n结果报告为无单位的十进制数（无单位），其中 $N = T/\\Delta t$ 是时间步数。接近 $0$ 的值表示没有人为能量增长；正值表示有人为能量增长。\n\n使用以下物理上一致的建模选择：\n- 电感：$L(x) = L_{0} + \\alpha\\, x$，其中 $L_{0} > 0$ 且 $\\alpha \\ge 0$，因此 $\\frac{dL}{dx} = \\alpha$。\n- 无电阻和无外部激励，因此对于格式 A，有 $d\\psi/dt = 0$。\n- 无结构阻尼。\n\n使用以下数值和物理参数，所有量均采用国际单位制 (SI)。质量 $m$ 单位为千克，刚度 $k$ 单位为牛顿/米，电感 $L$ 单位为亨利，电流 $I$ 单位为安培，时间单位为秒，位移 $x$ 单位为米：\n- 通用物理参数：$m = 0.05$，$k = 200$，$L_{0} = 0.001$，$\\alpha = 0.02$。\n- 初始条件：$x(0) = 0$，$v(0) = 0$，$I(0) = 20$。对于格式 A，设置 $\\psi(0) = L(x(0))\\,I(0)$ 并强制 $\\psi^{n+1} = \\psi^{n}$。\n- 时间范围：$T = 0.01$。\n\n实现四个测试用例：\n- 用例 1：使用 $\\Delta t = 0.0001$ 的格式 A。\n- 用例 2：使用 $\\Delta t = 0.0005$ 的格式 A。\n- 用例 3：使用 $\\Delta t = 0.0001$ 的格式 B。\n- 用例 4：使用 $\\Delta t = 0.0005$ 的格式 B。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，按上述四个用例的顺序排列。每个结果是表示最大相对能量增量的浮点数。例如，一个有效的输出格式是“[0.0,0.00123,0.045,0.12]”。本任务中不使用角度。输出是无单位的十进制数。\n\n约束和期望：\n- 从提供的磁链基本守恒定律和 Newmark 方法定义推导您的离散更新；不要使用任何其他快捷公式。\n- 确保格式 A 的牛顿迭代收敛到严格的容差，以便能量行为能代表该方法的特性，而不是数值误差。\n- 对于给定的参数，模拟必须是自包含且确定性的。",
            "solution": "该问题要求在两种不同的时间积分格式下，对一个集总参数电磁-结构系统进行模拟。主要目标是量化每种格式的数值能量守恒特性。分析从作为基准的连续模型开始，然后进行离散实现和比较。\n\n系统的状态由机械位移 $x(t)$ 和速度 $v(t)$，以及电流 $I(t)$ 描述。核心物理原理是磁链守恒和牛顿第二定律。\n\n对于电气子系统，在零电阻和无电压源的情况下，其控制方程是磁链 $\\psi(t)$ 守恒：\n$$\n\\frac{d\\psi}{dt} = 0 \\implies \\psi(t) = L(x(t))\\,I(t) = \\text{constant}\n$$\n磁共能（对于线性磁路，等于储存的磁能）为 $W_{\\mathrm{m}}(x,I) = \\frac{1}{2} L(x)\\, I^2$。施加在机械部分上的电磁力由该共能导出：\n$$\nF_{\\mathrm{em}}(x,I) = \\frac{\\partial W_{\\mathrm{m}}}{\\partial x} = \\frac{1}{2} I^2 \\frac{dL}{dx}(x)\n$$\n对于机械子系统，一个单自由度线性振子，其运动方程为：\n$$\nm\\,\\ddot{x}(t) + k\\,x(t) = F_{\\mathrm{em}}(x(t), I(t))\n$$\n连续系统的总能量是机械动能、机械势能（弹性）和磁能之和：\n$$\nE(t) = \\frac{1}{2} m\\, v(t)^2 + \\frac{1}{2} k\\, x(t)^2 + \\frac{1}{2} L(x(t))\\, I(t)^2\n$$\n在连续域中，此总能量是精确守恒的。总能量的变化率为 $\\frac{dE}{dt} = m\\,v\\,\\dot{v} + k\\,x\\,\\dot{x} + \\frac{1}{2}\\frac{dL}{dx}\\dot{x}\\,I^2 + L\\,I\\,\\frac{dI}{dt}$。由于 $\\dot{x}=v$、$\\ddot{x}=\\dot{v}$，且 $\\psi = L\\,I$ 为常数，我们有 $\\frac{dI}{dt} = -\\frac{I}{L}\\frac{dL}{dt} = -\\frac{I}{L}\\frac{dL}{dx}\\dot{x}$。将这些代入能量导数，得到 $\\frac{dE}{dt} = v(m\\ddot{x} + kx) + \\frac{1}{2}v\\frac{dL}{dx}I^2 + L\\,I(-\\frac{I}{L}\\frac{dL}{dx}v) = v(F_{\\text{em}}) + v F_{\\text{em}} - v\\frac{dL}{dx}I^2 \\neq 0$。上述推导存在错误。正确的能量守恒推导如下：\n$\\frac{dE}{dt} = v(m\\ddot{x} + kx) + \\frac{1}{2} v \\frac{dL}{dx} I^2 + LI\\frac{dI}{dt}$.\n代入运动方程 $m\\ddot{x} + kx = F_{em} = \\frac{1}{2} I^2 \\frac{dL}{dx}$，我们得到\n$\\frac{dE}{dt} = v(\\frac{1}{2}I^2 \\frac{dL}{dx}) + \\frac{1}{2} v \\frac{dL}{dx} I^2 + LI\\frac{dI}{dt} = v I^2 \\frac{dL}{dx} + LI\\frac{dI}{dt}$.\n从 $\\psi = L(x)I(t)$ = const, 我们对时间求导： $\\frac{d\\psi}{dt} = \\frac{dL}{dx}\\frac{dx}{dt} I + L \\frac{dI}{dt} = v I \\frac{dL}{dx} + L\\frac{dI}{dt} = 0$.\n所以 $L\\frac{dI}{dt} = -vI\\frac{dL}{dx}$.\n代入能量导数方程：$\\frac{dE}{dt} = v I^2 \\frac{dL}{dx} + I(-vI\\frac{dL}{dx}) = v I^2 \\frac{dL}{dx} - v I^2 \\frac{dL}{dx} = 0$. 能量守恒得到证实。\n\n任务是使用两种格式将该系统离散化，并比较它们的能量行为。两种格式都对机械部分使用 Newmark 积分器家族，参数为 $\\beta = 1/4$ 和 $\\gamma = 1/2$，这对应于梯形法则，该法则在线性系统中以其良好的能量守恒特性而闻名。区别在于电磁部分和机械部分是如何耦合的。\n\n**格式 A：功率一致的 FDTD–Newmark 耦合**\n此格式旨在在离散层面上遵循两个物理域之间的功率共轭关系，这是离散能量守恒的先决条件。磁链保持恒定，$\\psi^{n+1} = \\psi^n = \\psi$，这反映了连续不变量。这意味着 $I(x) = \\psi / L(x)$。加速度成为仅与位移相关的非线性函数：\n$$\na(x) = \\frac{1}{m}\\left( F_{\\mathrm{em}}(x, I(x)) - k\\,x \\right) = \\frac{1}{m}\\left(\\frac{1}{2} \\left(\\frac{\\psi}{L(x)}\\right)^2 \\frac{dL}{dx}(x) - k\\,x\\right)\n$$\n对于给定的电感 $L(x) = L_0 + \\alpha x$ 及其导数 $\\frac{dL}{dx} = \\alpha$，此表达式为：\n$$\na(x) = \\frac{1}{m}\\left(\\frac{\\alpha \\psi^2}{2(L_0 + \\alpha x)^2} - k\\,x\\right)\n$$\n用于位移 $x^{n+1}$ 的 Newmark 梯形法则更新是隐式且非线性的：\n$$\nx^{n+1} = x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\left(a(x^{n}) + a(x^{n+1})\\right)\n$$\n这可以写成一个求根问题 $g(x^{n+1}) = 0$，其中：\n$$\ng(z) = z - \\frac{\\Delta t^2}{4}\\,a(z) - \\left(x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\,a(x^{n})\\right) = 0\n$$\n在每个时间步中，使用牛顿法求解这个非线性代数方程。根 $z$ 的迭代更新为 $z_{k+1} = z_k - g(z_k)/g'(z_k)$，其中 $g'(z) = 1 - \\frac{\\Delta t^2}{4}a'(z)$ 且 $a'(z) = \\frac{1}{m}(-\\frac{\\alpha^2\\psi^2}{(L_0+\\alpha z)^3} - k)$。使用严格的收敛容差来确保数值解能准确反映格式本身的特性。\n一旦求得 $x^{n+1}$，就更新速度和电流：\n$$\nv^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a(x^{n}) + a(x^{n+1})\\right)\n$$\n$$\nI^{n+1} = \\frac{\\psi}{L(x^{n+1})}\n$$\n这种整体式方法，即隐式求解整个耦合系统，预计将产生出色的能量守恒效果。\n\n**格式 B：非一致的冻结电流耦合**\n该格式代表了一种常见但有缺陷的简化方法。它不是强制执行磁链不变量，而是在时间步内“冻结”电流，即 $I^{n+1} = I^n$。电磁力在步长开始时计算，$F_{\\mathrm{em}}^n = \\frac{1}{2} (I^n)^2 \\frac{dL}{dx}(x^n)$，并被视为在区间 $[t^n, t^{n+1}]$ 内的恒定外力。\n运动方程在步长内变为线性：$m a^{n+1} + k x^{n+1} = F_{\\mathrm{em}}^n$。位移的 Newmark 更新为：\n$$\nx^{n+1} = x^{n} + \\Delta t v^{n} + \\frac{\\Delta t^2}{4}(a^n + a^{n+1})\n$$\n代入 $a^n = (F_{\\mathrm{em}}^n - kx^n)/m$ 和 $a^{n+1} = (F_{\\mathrm{em}}^n - kx^{n+1})/m$ 并求解 $x^{n+1}$，可得到问题中提供的显式更新法则：\n$$\nx^{n+1} = \\frac{x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4m}(2F_{\\mathrm{em}}^{n} - k\\, x^{n})}{1 + \\frac{k \\Delta t^2}{4m}}\n$$\n然后使用梯形法则更新速度：\n$$\nv^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a^{n} + a^{n+1}\\right)\n$$\n这种交错或显式耦合破坏了离散功率平衡。力 $F_{\\mathrm{em}}^n$ 对机械系统所做的功不能正确地从储存的磁能变化中获得，导致总系统能量的人为增加或损失，这通常表现为数值不稳定性或非物理的能量增长。\n\n该实现将在每一步为两种格式计算离散总能量 $E^{n} = \\frac{1}{2} m\\, (v^{n})^2 + \\frac{1}{2} k\\, (x^{n})^2 + \\frac{1}{2} L(x^{n})\\, (I^{n})^2$。比较的度量标准是在模拟时间范围内的最大相对能量增量 $\\max_{n} ((E^n - E^0)/E^0)$，其中 $E^0$ 是初始能量。这个度量标准量化了数值格式引入的人为能量增长程度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the electromagnetic-structural coupling problem for four test cases\n    and prints the maximum fractional energy increase for each.\n    \"\"\"\n    # Common physical parameters (SI units)\n    M = 0.05  # mass (kg)\n    K = 200.0  # stiffness (N/m)\n    L0 = 0.001  # base inductance (H)\n    ALPHA = 0.02  # inductance gradient (H/m)\n    \n    # Initial conditions\n    X0 = 0.0  # initial displacement (m)\n    V0 = 0.0  # initial velocity (m/s)\n    I0 = 20.0  # initial current (A)\n    \n    # Time horizon\n    T_HORIZON = 0.01  # s\n\n    # Define inductance and its derivative\n    def L_func(x):\n        return L0 + ALPHA * x\n    \n    def dLdx_func(x):\n        return ALPHA\n\n    def calculate_energy(x, v, i):\n        return 0.5 * M * v**2 + 0.5 * K * x**2 + 0.5 * L_func(x) * i**2\n\n    def run_simulation(scheme, dt):\n        \"\"\"\n        Runs the time-domain simulation for a given scheme and time step.\n\n        Args:\n            scheme (str): 'A' or 'B' specifying the coupling scheme.\n            dt (float): The time step size.\n\n        Returns:\n            float: The maximum fractional energy increase.\n        \"\"\"\n        x_n, v_n, i_n = X0, V0, I0\n        \n        e0 = calculate_energy(x_n, v_n, i_n)\n        if e0 == 0:  # Avoid division by zero, though not expected here\n            return 0.0\n            \n        max_energy_frac_inc = 0.0\n        n_steps = int(round(T_HORIZON / dt))\n\n        if scheme == 'A':\n            psi = L_func(x_n) * i_n\n            newton_tol = 1e-14\n            max_newton_iter = 20\n            \n            def accel(x):\n                L_val = L_func(x)\n                if L_val == 0: return np.inf # To prevent division by zero in extreme cases\n                fem = 0.5 * (psi**2 / L_val**2) * dLdx_func(x)\n                return (fem - K * x) / M\n\n            def accel_deriv(x):\n                L_val = L_func(x)\n                if L_val == 0: return np.inf\n                fem_deriv = -1.0 * (psi**2 * ALPHA**2) / (L_val**3)\n                return (fem_deriv - K) / M\n\n            for _ in range(n_steps):\n                a_n = accel(x_n)\n                \n                # Newton-Raphson solver for x_{n+1}\n                c_const = x_n + dt * v_n + (dt**2 / 4.0) * a_n\n                x_np1_guess = x_n\n                \n                for _ in range(max_newton_iter):\n                    g = x_np1_guess - (dt**2 / 4.0) * accel(x_np1_guess) - c_const\n                    g_prime = 1.0 - (dt**2 / 4.0) * accel_deriv(x_np1_guess)\n                    if abs(g_prime)  1e-15: # Avoid division by zero\n                        break\n                    delta_x = -g / g_prime\n                    x_np1_guess += delta_x\n                    if abs(delta_x)  newton_tol:\n                        break\n                \n                x_np1 = x_np1_guess\n                a_np1 = accel(x_np1)\n                \n                v_np1 = v_n + (dt / 2.0) * (a_n + a_np1)\n                i_np1 = psi / L_func(x_np1)\n                \n                e_np1 = calculate_energy(x_np1, v_np1, i_np1)\n                frac_inc = (e_np1 - e0) / e0\n                max_energy_frac_inc = max(max_energy_frac_inc, frac_inc)\n                \n                x_n, v_n = x_np1, v_np1\n        \n        elif scheme == 'B':\n            for _ in range(n_steps):\n                fem_n = 0.5 * i_n**2 * dLdx_func(x_n)\n                \n                # Explicit update for x_{n+1}\n                numerator = x_n + dt * v_n + (dt**2 / (4.0 * M)) * (2 * fem_n - K * x_n)\n                denominator = 1.0 + (K * dt**2) / (4.0 * M)\n                x_np1 = numerator / denominator\n                \n                a_n = (fem_n - K * x_n) / M\n                a_np1 = (fem_n - K * x_np1) / M\n                \n                v_np1 = v_n + (dt / 2.0) * (a_n + a_np1)\n                i_np1 = i_n\n                \n                e_np1 = calculate_energy(x_np1, v_np1, i_np1)\n                frac_inc = (e_np1 - e0) / e0\n                max_energy_frac_inc = max(max_energy_frac_inc, frac_inc)\n\n                x_n, v_n, i_n = x_np1, v_np1, i_np1\n                \n        return max_energy_frac_inc\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('A', 0.0001),  # Case 1\n        ('A', 0.0005),  # Case 2\n        ('B', 0.0001),  # Case 3\n        ('B', 0.0005),  # Case 4\n    ]\n\n    results = []\n    for scheme, dt in test_cases:\n        result = run_simulation(scheme, dt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于涉及非线性材料的高保真仿真，电磁与结构之间的耦合关系通常是复杂且非线性的。求解这类非线性方程组需要采用牛顿法等迭代策略，其二次收敛性的关键在于精确提供系统的“一致切线算子”，即能量泛函的Hessian矩阵。本练习将引导您从一个非线性磁弹耦合材料的亥姆霍兹自由能出发，推导完整的切线算子矩阵，并通过有限差分法验证其正确性——这是计算力学中验证本构模型实现正确性的黄金准则。",
            "id": "3304447",
            "problem": "考虑一个在小应变和静磁学假设下的准静态磁弹性体。采用一种基于势的公式，其中单位参考体积的总热力学势由能量密度函数 $\\psi(\\boldsymbol{e},\\boldsymbol{B})$ 给出，其中 $\\boldsymbol{e}$ 是小应变张量，$\\boldsymbol{B}$ 是磁感应矢量。假设一个各向同性、可压缩的线性弹性固体，具有非线性磁响应和双线性磁弹性耦合，其能量密度函数为\n$$\n\\psi(\\boldsymbol{e},\\boldsymbol{B}) \\;=\\; \\mu \\, \\boldsymbol{e}:\\boldsymbol{e} \\;+\\; \\dfrac{\\lambda}{2} \\left(\\operatorname{tr}\\boldsymbol{e}\\right)^2 \\;+\\; \\dfrac{1}{2\\mu_0}\\, \\boldsymbol{B}\\cdot \\boldsymbol{B} \\;+\\; m_s B_0 \\ln\\!\\left(\\cosh\\!\\left(\\dfrac{\\|\\boldsymbol{B}\\|}{B_0}\\right)\\right) \\;-\\; \\gamma \\, \\boldsymbol{B}^{\\mathsf{T}} \\,\\boldsymbol{e}\\, \\boldsymbol{B},\n$$\n其中 $\\mu$ 和 $\\lambda$ 是拉梅参数，$\\mu_0$ 是真空磁导率，$m_s$ 和 $B_0$ 在磁本构律中设定了平滑的饱和响应，$\\gamma$ 是一个磁弹性耦合系数。这里，$\\|\\boldsymbol{B}\\| = \\sqrt{\\boldsymbol{B}\\cdot\\boldsymbol{B}}$，$\\boldsymbol{e}:\\boldsymbol{e} = \\sum_{i,j} e_{ij} e_{ij}$，并且 $\\operatorname{tr}\\boldsymbol{e} = \\sum_i e_{ii}$。所有输入均应理解为国际单位制（SI）：应变为无量纲，磁感应单位为特斯拉，应力和能量密度单位分别为帕斯卡和焦耳每立方米。您将编写的程序只会输出无量纲的布尔值，因此输出中不需要进行显式的单位转换。\n\n从最小势能原理和本构定义\n$$\n\\boldsymbol{\\sigma} \\;=\\; \\dfrac{\\partial \\psi}{\\partial \\boldsymbol{e}}, \\quad \\boldsymbol{H} \\;=\\; \\dfrac{\\partial \\psi}{\\partial \\boldsymbol{B}},\n$$\n出发，推导所需的一致性切线算子（$\\psi$ 的黑塞矩阵），以确保耦合问题的牛顿求解器具有二次收敛性。特别地，推导四个二阶导数块\n$$\n\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{e}\\,\\partial \\boldsymbol{e}}, \\quad\n\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{e}\\,\\partial \\boldsymbol{B}}, \\quad\n\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{B}\\,\\partial \\boldsymbol{e}}, \\quad\n\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{B}\\,\\partial \\boldsymbol{B}},\n$$\n注意当索引被适当地排列时，混合块必须满足麦克斯韦对称性 $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}} = \\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}^{\\mathsf{T}}$。\n\n您的任务是：\n\n$1.$ 从给定的 $\\psi(\\boldsymbol{e},\\boldsymbol{B})$，推导 $\\boldsymbol{\\sigma}(\\boldsymbol{e},\\boldsymbol{B})$ 和 $\\boldsymbol{H}(\\boldsymbol{e},\\boldsymbol{B})$ 的闭合形式表达式。\n\n$2.$ 仅使用上述基本定义，推导算法切线块 $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}}$、$\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}}$、$\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}$ 和 $\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}}$ 的闭合形式表达式。将您的最终公式表示为适合直接在代码中实现的索引分量形式。\n\n$3.$ 实现一个程序，该程序：\n- 在给定的状态 $(\\boldsymbol{e},\\boldsymbol{B})$ 和材料参数 $(\\mu,\\lambda,\\mu_0,m_s,B_0,\\gamma)$ 下，计算四个切线块的解析形式。\n- 通过比较分量 $\\left(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}}\\right)_{ij k}$ 和 $\\left(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}\\right)_{k ij}$（对于所有索引 $i,j,k$）来验证混合块的对称性 $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}} = \\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}^{\\mathsf{T}}$。\n- 通过将解析导数与一阶导数 $\\boldsymbol{\\sigma}(\\boldsymbol{e},\\boldsymbol{B})$ 和 $\\boldsymbol{H}(\\boldsymbol{e},\\boldsymbol{B})$ 的中心有限差分近似进行比较，来验证这四个块中的每一个。对非对角应变分量使用对称扰动，以保持 $\\boldsymbol{e}=\\boldsymbol{e}^{\\mathsf{T}}$。磁分量使用扰动幅度 $h_{\\boldsymbol{B}} = 10^{-6}$ 特斯拉，应变分量使用扰动幅度 $h_{\\boldsymbol{e}} = 10^{-8}$（无量纲）。对弗罗贝尼乌斯范数的相对误差使用相对容差 $\\tau = 10^{-6}$。\n\n$4.$ 将您的程序应用于以下测试套件。对于每个测试，使用相同的材料参数\n$$\n\\mu = 60\\times 10^{9},\\quad \\lambda = 90\\times 10^{9},\\quad \\mu_0 = 4\\pi \\times 10^{-7},\\quad m_s = 10^{5},\\quad B_0 = 1.2,\\quad \\gamma = 10^{6}.\n$$\n为每个测试提供状态 $(\\boldsymbol{e},\\boldsymbol{B})$：\n- 测试 $1$（一般耦合状态）：\n$$\n\\boldsymbol{e} =\n\\begin{bmatrix}\n10^{-3}  2\\times 10^{-4}  -10^{-4}\\\\\n2\\times 10^{-4}  -5\\times 10^{-4}  3\\times 10^{-4}\\\\\n-10^{-4}  3\\times 10^{-4}  2\\times 10^{-4}\n\\end{bmatrix},\\quad\n\\boldsymbol{B} =\n\\begin{bmatrix}\n0.3\\\\ -0.1\\\\ 0.2\n\\end{bmatrix}.\n$$\n- 测试 $2$（近零磁场和小应变）：\n$$\n\\boldsymbol{e} =\n\\begin{bmatrix}\n10^{-6}  0  0\\\\\n0  -2\\times 10^{-6}  0\\\\\n0  0  1.5\\times 10^{-6}\n\\end{bmatrix},\\quad\n\\boldsymbol{B} =\n\\begin{bmatrix}\n10^{-12}\\\\ -2\\times 10^{-12}\\\\ 3\\times 10^{-12}\n\\end{bmatrix}.\n$$\n- 测试 $3$（接近饱和的高磁场）：\n$$\n\\boldsymbol{e} =\n\\begin{bmatrix}\n5\\times 10^{-4}  -1\\times 10^{-4}  2\\times 10^{-4}\\\\\n-1\\times 10^{-4}  4\\times 10^{-4}  -2\\times 10^{-4}\\\\\n2\\times 10^{-4}  -2\\times 10^{-4}  -3\\times 10^{-4}\n\\end{bmatrix},\\quad\n\\boldsymbol{B} =\n\\begin{bmatrix}\n1.5\\\\ 0.5\\\\ -1.0\n\\end{bmatrix}.\n$$\n- 测试 $4$（纯剪切与正交磁感应）：\n$$\n\\boldsymbol{e} =\n\\begin{bmatrix}\n0  5\\times 10^{-4}  0\\\\\n5\\times 10^{-4}  0  0\\\\\n0  0  0\n\\end{bmatrix},\\quad\n\\boldsymbol{B} =\n\\begin{bmatrix}\n0\\\\ 0\\\\ 0.8\n\\end{bmatrix}.\n$$\n\n对于每个测试，您的程序应返回一个布尔值，指示所有检查是否通过：混合块对称性检查和在指定容差 $\\tau$ 下对四个块中每一个的有限差分验证。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，`[True,False,True,True]`）。",
            "solution": "该问题要求从一个给定的热力学势出发，推导磁弹性材料的本构关系（应力 $\\boldsymbol{\\sigma}$ 和磁场 $\\boldsymbol{H}$）以及一致性切线算子（Hessian矩阵）。随后，需要通过数值方法（对称性检查和有限差分法）来验证这些推导的正确性。\n\n### **任务 1：本构关系的推导**\n\n给定的亥姆霍兹自由能密度为：\n$$\n\\psi(\\boldsymbol{e},\\boldsymbol{B}) = \\mu e_{ij}e_{ij} + \\frac{\\lambda}{2} (e_{kk})^2 + \\frac{1}{2\\mu_0} B_k B_k + m_s B_0 \\ln\\left(\\cosh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right)\\right) - \\gamma B_i e_{ij} B_j\n$$\n其中，为了方便推导，我们使用了爱因斯坦求和约定。\n\n**柯西应力张量 $\\boldsymbol{\\sigma}$**:\n应力张量是自由能对应变张量 $\\boldsymbol{e}$ 的偏导数，$\\sigma_{ij} = \\frac{\\partial \\psi}{\\partial e_{ij}}$。考虑到应变张量的对称性，我们对 $\\psi$ 的各项求导：\n- 弹性项：$\\frac{\\partial}{\\partial e_{ij}} \\left( \\mu e_{kl}e_{kl} + \\frac{\\lambda}{2} (e_{kk})^2 \\right) = 2\\mu e_{ij} + \\lambda e_{kk} \\delta_{ij}$\n- 磁项：与 $\\boldsymbol{e}$ 无关，导数为零。\n- 耦合项：$\\frac{\\partial}{\\partial e_{ij}} (-\\gamma B_k e_{kl} B_l) = -\\gamma B_i B_j$\n\n组合得到应力张量：\n$$\n\\sigma_{ij} = 2\\mu e_{ij} + \\lambda e_{kk} \\delta_{ij} - \\gamma B_i B_j \\quad \\text{或} \\quad \\boldsymbol{\\sigma}(\\boldsymbol{e},\\boldsymbol{B}) = 2\\mu\\boldsymbol{e} + \\lambda(\\operatorname{tr}\\boldsymbol{e})\\boldsymbol{I} - \\gamma \\boldsymbol{B}\\otimes\\boldsymbol{B}\n$$\n\n**磁场强度 $\\boldsymbol{H}$**:\n磁场强度是自由能对磁感应强度 $\\boldsymbol{B}$ 的偏导数，$H_i = \\frac{\\partial \\psi}{\\partial B_i}$：\n- 磁能项：$\\frac{\\partial}{\\partial B_i} \\left( \\frac{1}{2\\mu_0} B_k B_k \\right) = \\frac{1}{\\mu_0} B_i$\n- 饱和项：$\\frac{\\partial}{\\partial B_i} \\left( m_s B_0 \\ln\\cosh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) \\right) = m_s \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) \\frac{B_i}{\\|\\boldsymbol{B}\\|}$\n- 耦合项：$\\frac{\\partial}{\\partial B_i} (-\\gamma B_k e_{kl} B_l) = -\\gamma(e_{il}B_l + B_k e_{ki}) = -2\\gamma e_{ik}B_k$ (利用了 $e_{ik}=e_{ki}$)\n\n组合得到磁场强度：\n$$\nH_i = \\frac{1}{\\mu_0} B_i + m_s \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) \\frac{B_i}{\\|\\boldsymbol{B}\\|} - 2\\gamma e_{ik}B_k \\quad \\text{或} \\quad \\boldsymbol{H}(\\boldsymbol{e},\\boldsymbol{B}) = \\frac{1}{\\mu_0} \\boldsymbol{B} + m_s \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) \\frac{\\boldsymbol{B}}{\\|\\boldsymbol{B}\\|} - 2\\gamma \\boldsymbol{e}\\boldsymbol{B}\n$$\n为避免 $\\|\\boldsymbol{B}\\| \\to 0$ 时的数值问题，使用 $\\tanh(x) \\approx x$ 近似，饱和项变为 $(m_s/B_0)\\boldsymbol{B}$。\n\n### **任务 2：切线算子的推导**\n\n切线算子是自由能的二阶导数（Hessian矩阵）。\n\n**弹性张量 $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}}$**:\n$(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}})_{ijkl} = \\frac{\\partial \\sigma_{ij}}{\\partial e_{kl}} = \\frac{\\partial^2 \\psi}{\\partial e_{ij} \\partial e_{kl}}$\n对 $\\sigma_{ij}$ 表达式求导，只有弹性部分有贡献：\n$$\n(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}})_{ijkl} = \\mu(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}) + \\lambda\\delta_{ij}\\delta_{kl}\n$$\n这是各向同性线弹性材料的标准四阶刚度张量。\n\n**压磁型耦合张量 $\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}$ 和 $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}}$**:\n$(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}})_{kij} = \\frac{\\partial H_k}{\\partial e_{ij}}$。对 $H_k$ 表达式求导，只有耦合项有贡献：\n$$\n(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}})_{kij} = \\frac{\\partial}{\\partial e_{ij}} (-2\\gamma e_{km}B_m) = -2\\gamma \\frac{1}{2}(\\delta_{ik}\\delta_{mj} + \\delta_{kj}\\delta_{mi})B_m = -\\gamma(\\delta_{ki}B_j + \\delta_{kj}B_i)\n$$\n$(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}})_{ijk} = \\frac{\\partial \\sigma_{ij}}{\\partial B_k}$。对 $\\sigma_{ij}$ 表达式求导，只有耦合项有贡献：\n$$\n(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}})_{ijk} = \\frac{\\partial}{\\partial B_k}(-\\gamma B_i B_j) = -\\gamma(\\delta_{ik}B_j + B_i \\delta_{jk})\n$$\n可以验证，$(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}})_{kij} = (\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}})_{ijk}$，满足麦克斯韦对称性。\n\n**逆磁导率张量 $\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}}$**:\n$(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}})_{ij} = \\frac{\\partial H_i}{\\partial B_j}$。对 $H_i$ 的三项分别求导：\n1. $\\frac{\\partial}{\\partial B_j} \\left(\\frac{1}{\\mu_0} B_i\\right) = \\frac{1}{\\mu_0}\\delta_{ij}$\n2. $\\frac{\\partial}{\\partial B_j} (-2\\gamma e_{ik}B_k) = -2\\gamma e_{ij}$\n3. $\\frac{\\partial}{\\partial B_j} \\left(m_s \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) \\frac{B_i}{\\|\\boldsymbol{B}\\|}\\right)$\n   - 使用乘法法则和链式法则，该导数可以分为两部分：\n   - 与 $\\delta_{ij}$ 成比例的项：$\\frac{m_s \\tanh\\left(\\|\\boldsymbol{B}\\|/B_0\\right)}{\\|\\boldsymbol{B}\\|} \\delta_{ij}$\n   - 与 $B_i B_j$ 成比例的项：$m_s \\left[ \\frac{\\text{sech}^2\\left(\\|\\boldsymbol{B}\\|/B_0\\right)}{B_0 \\|\\boldsymbol{B}\\|^2} - \\frac{\\tanh\\left(\\|\\boldsymbol{B}\\|/B_0\\right)}{\\|\\boldsymbol{B}\\|^3} \\right] B_i B_j$\n\n组合得到：\n$$\n(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}})_{ij} = \\left(\\frac{1}{\\mu_0} + \\frac{m_s \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right)}{\\|\\boldsymbol{B}\\|}\\right) \\delta_{ij} - 2\\gamma e_{ij} + m_s \\left[ \\frac{\\text{sech}^2\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right)}{B_0 \\|\\boldsymbol{B}\\|^2} - \\frac{\\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|/B_0\\right)}{\\|\\boldsymbol{B}\\|^3} \\right] B_i B_j\n$$\n在 $\\|\\boldsymbol{B}\\| \\to 0$ 的极限下，该表达式简化为 $(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}})_{ij} \\to \\left(\\frac{1}{\\mu_0} + \\frac{m_s}{B_0}\\right)\\delta_{ij} - 2\\gamma e_{ij}$。\n\n### **任务 3 和 4：实现与验证**\n\n程序将实现上述解析表达式，并执行两个核心验证步骤：\n1.  **对称性验证**：直接比较计算出的 $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}}$ 和 $\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}$（经过适当的索引转置后）是否在数值上相等。\n2.  **有限差分验证**：对每个切线块，将其解析计算结果与通过中心差分法数值逼近的结果进行比较。例如，为验证 $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}}$，将计算 $\\frac{\\boldsymbol{\\sigma}(\\boldsymbol{e}, \\boldsymbol{B}+h\\boldsymbol{d}_k) - \\boldsymbol{\\sigma}(\\boldsymbol{e}, \\boldsymbol{B}-h\\boldsymbol{d}_k)}{2h}$，其中 $\\boldsymbol{d}_k$ 是第 $k$ 个笛卡尔基向量，并将结果与解析矩阵 $(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}})_{ij k}$ 的第 $k$ 列进行比较。对所有块和所有分量重复此过程，并检查相对误差是否在给定容差 $\\tau$ 之内。对涉及对称应变张量 $\\boldsymbol{e}$ 的导数进行有限差分时，需要特别注意扰动的定义，以确保结果的一致性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies the tangent operators for a magnetoelastic constitutive model.\n    \"\"\"\n    # --- Material Parameters ---\n    params = {\n        \"mu\": 60e9,\n        \"lambda_\": 90e9,\n        \"mu0\": 4 * np.pi * 1e-7,\n        \"ms\": 1e5,\n        \"B0\": 1.2,\n        \"gamma\": 1e6,\n    }\n\n    # --- Numerical Parameters for Verification ---\n    h_e = 1e-8\n    h_B = 1e-6\n    tolerance = 1e-6\n\n    # --- Test Cases ---\n    test_cases = [\n        {\"e\": np.array([[1e-3, 2e-4, -1e-4], [2e-4, -5e-4, 3e-4], [-1e-4, 3e-4, 2e-4]]), \"B\": np.array([0.3, -0.1, 0.2])},\n        {\"e\": np.array([[1e-6, 0, 0], [0, -2e-6, 0], [0, 0, 1.5e-6]]), \"B\": np.array([1e-12, -2e-12, 3e-12])},\n        {\"e\": np.array([[5e-4, -1e-4, 2e-4], [-1e-4, 4e-4, -2e-4], [2e-4, -2e-4, -3e-4]]), \"B\": np.array([1.5, 0.5, -1.0])},\n        {\"e\": np.array([[0, 5e-4, 0], [5e-4, 0, 0], [0, 0, 0]]), \"B\": np.array([0, 0, 0.8])},\n    ]\n\n    # --- Constitutive Model Implementation ---\n    def get_sigma(e, B, p):\n        tr_e = np.trace(e)\n        return 2 * p[\"mu\"] * e + p[\"lambda_\"] * tr_e * np.identity(3) - p[\"gamma\"] * np.outer(B, B)\n\n    def get_H(e, B, p):\n        norm_B = np.linalg.norm(B)\n        term1 = (1 / p[\"mu0\"]) * B\n        if norm_B  1e-15:\n            term2 = (p[\"ms\"] / p[\"B0\"]) * B\n        else:\n            term2 = p[\"ms\"] * np.tanh(norm_B / p[\"B0\"]) * (B / norm_B)\n        term3 = -2 * p[\"gamma\"] * e @ B\n        return term1 + term2 + term3\n\n    def get_tangents(e, B, p):\n        I = np.identity(3)\n        C_ee = np.einsum('ik,jl->ijkl', p[\"mu\"]*I, I) + np.einsum('il,jk->ijkl', p[\"mu\"]*I, I) + np.einsum('ij,kl->ijkl', p[\"lambda_\"]*I, I)\n        C_eB = -p[\"gamma\"] * (np.einsum('ik,j->ijk', I, B) + np.einsum('jk,i->ijk', I, B))\n        C_Be = -p[\"gamma\"] * (np.einsum('ki,j->kij', I, B) + np.einsum('kj,i->kij', I, B))\n        norm_B = np.linalg.norm(B)\n        if norm_B  1e-15:\n            term_mag_diag = (1 / p[\"mu0\"] + p[\"ms\"] / p[\"B0\"]) * I\n            term_mag_off_diag = np.zeros((3, 3))\n        else:\n            u = norm_B / p[\"B0\"]\n            tanh_u_over_norm_B = np.tanh(u) / norm_B\n            term_mag_diag = (1 / p[\"mu0\"] + p[\"ms\"] * tanh_u_over_norm_B) * I\n            sech_u_sq = 1 - np.tanh(u)**2\n            coeff_off_diag = p[\"ms\"] * (sech_u_sq / (p[\"B0\"] * norm_B**2) - tanh_u_over_norm_B / norm_B)\n            term_mag_off_diag = coeff_off_diag * np.outer(B, B)\n        C_BB = term_mag_diag + term_mag_off_diag - 2 * p[\"gamma\"] * e\n        return C_ee, C_eB, C_Be, C_BB\n\n    def verify(e, B, p):\n        e = 0.5 * (e + e.T)  # Ensure strain is symmetric\n        C_ee, C_eB, C_Be, C_BB = get_tangents(e, B, p)\n        \n        # 1. Symmetry Check\n        symm_check = np.allclose(C_eB, np.transpose(C_Be, (1, 2, 0)), rtol=tolerance, atol=1e-9)\n\n        # 2. FD Check for C_ee\n        C_ee_fd = np.zeros_like(C_ee)\n        for k in range(3):\n            for l in range(3):\n                dE = np.zeros((3, 3))\n                dE[k, l] += h_e\n                if k != l: dE[l, k] += h_e\n                num = get_sigma(e + dE, B, p) - get_sigma(e - dE, B, p)\n                den = 2 * h_e * (1 + (k != l))\n                C_ee_fd[:, :, k, l] = num / den\n        norm_C_ee = np.linalg.norm(C_ee)\n        C_ee_check = (np.linalg.norm(C_ee_fd - C_ee) / norm_C_ee if norm_C_ee > 0 else 0)  tolerance\n\n        # 3. FD Check for C_eB\n        C_eB_fd = np.zeros_like(C_eB)\n        for k in range(3):\n            dB = np.zeros(3); dB[k] = h_B\n            C_eB_fd[:, :, k] = (get_sigma(e, B + dB, p) - get_sigma(e, B - dB, p)) / (2 * h_B)\n        norm_C_eB = np.linalg.norm(C_eB)\n        C_eB_check = (np.linalg.norm(C_eB_fd - C_eB) / norm_C_eB if norm_C_eB > 0 else 0)  tolerance\n\n        # 4. FD Check for C_Be\n        C_Be_fd = np.zeros_like(C_Be)\n        for i in range(3):\n            for j in range(3):\n                dE = np.zeros((3, 3))\n                dE[i, j] += h_e\n                if i != j: dE[j, i] += h_e\n                num = get_H(e + dE, B, p) - get_H(e - dE, B, p)\n                den = 2 * h_e * (1 + (i != j))\n                C_Be_fd[:, i, j] = num / den\n        norm_C_Be = np.linalg.norm(C_Be)\n        C_Be_check = (np.linalg.norm(C_Be_fd - C_Be) / norm_C_Be if norm_C_Be > 0 else 0)  tolerance\n\n        # 5. FD Check for C_BB\n        C_BB_fd = np.zeros_like(C_BB)\n        for j in range(3):\n            dB = np.zeros(3); dB[j] = h_B\n            C_BB_fd[:, j] = (get_H(e, B + dB, p) - get_H(e, B - dB, p)) / (2 * h_B)\n        norm_C_BB = np.linalg.norm(C_BB)\n        C_BB_check = (np.linalg.norm(C_BB_fd - C_BB) / norm_C_BB if norm_C_BB > 0 else 0)  tolerance\n        \n        return all([symm_check, C_ee_check, C_eB_check, C_Be_check, C_BB_check])\n\n    final_results = [verify(case[\"e\"], case[\"B\"], params) for case in test_cases]\n    print(f\"[{','.join(str(r) for r in final_results)}]\")\n\nsolve()\n```"
        }
    ]
}