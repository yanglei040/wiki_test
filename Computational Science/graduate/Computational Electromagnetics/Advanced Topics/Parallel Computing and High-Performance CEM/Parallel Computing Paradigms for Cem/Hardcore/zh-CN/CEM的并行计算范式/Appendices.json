{
    "hands_on_practices": [
        {
            "introduction": "要高效地并行化大规模计算电磁学 (CEM) 仿真，我们必须理解并控制通信开销。本练习将引导您通过一项分析性任务，为一种常见的区域分解策略建立通信成本模型。通过从第一性原理推导这些成本，您将深入了解并行性能如何扩展。",
            "id": "3336971",
            "problem": "用于计算电磁学 (CEM) 的三维时域有限差分 (FDTD) 求解器，使用显式模板在每个时间步更新尺寸为 $n_{x} \\times n_{y} \\times n_{z}$ 的结构化网格上的电场和磁场分量。该网格使用沿 $z$ 轴对齐的铅笔分解 (pencil decomposition) 分布在 $P$ 个进程上：进程排列成一个大小为 $P_{x} \\times P_{y}$ 的二维网格，其中 $P = P_{x} P_{y}$，使得每个进程拥有一个大小为 $\\frac{n_{x}}{P_{x}} \\times \\frac{n_{y}}{P_{y}} \\times n_{z}$ 的子域。模板在 $x$ 和 $y$ 方向上所需的晕环（鬼影区）厚度为 $\\delta \\geq 1$ 个网格单元。沿 $z$ 方向，由于每个进程都跨越了完整的 $z$ 范围，因此不需要进程间通信。\n\n假设代码在每个时间步显式交换以下数据：\n- 与 $x$ 和 $y$ 方向上的四个面相邻进程（$x$ 方向两个，$y$ 方向两个）进行面晕环交换。\n- 与 $x$-$y$ 平面内的四个对角相邻进程（$\\pm x$, $\\pm y$ 的组合）进行边（平面内对角线）晕环交换。这些边区域具有沿 $z$ 轴拉伸的 $\\delta \\times \\delta$ 横截面。\n- 由于沿 $z$ 方向没有进程间邻居，因此在这种铅笔分解下不存在对应于 $\\pm x$, $\\pm y$, $\\pm z$ 三重邻居的角晕环。\n\n每个网格单元携带 $c$ 个需要通信的场自由度（例如，在 Yee 网格方案中，$c=6$，计及三个电场和三个磁场分量），每个自由度以 $b$ 字节进行通信。将每个时间步的总通信量定义为所有进程为面、边和角交换所发送的字节数之和。\n\n从域分解几何和晕环交换的第一性原理出发，用 $n_{x}$、$n_{y}$、$n_{z}$、$P_{x}$、$P_{y}$、$\\delta$、$c$ 和 $b$ 推导由面、边和角贡献的每个时间步总字节数的表达式。然后，为了进行渐近比较，将其特化到平衡情况 $P_{x} = P_{y} = \\sqrt{P}$ 和近立方体网格 $n_{x} \\approx n_{y} \\approx n_{z}$，可记为 $n_{x} = n_{y} = n_{z} = n$。在这种平衡立方体情况下，确定当 $P$ 变大时，三种贡献（面、边、角）中的哪一种占主导地位，并提供每个时间步总通信量的主导项表达式，形式为单一的闭式解析表达式。\n\n以字节为单位表示最终的主导项通信量。不需要进行数值计算。",
            "solution": "首先根据所需标准对问题陈述进行验证。\n\n### 第1步：提取已知条件\n- **全局网格尺寸**：$n_{x} \\times n_{y} \\times n_{z}$ 单元。\n- **进程总数**：$P$。\n- **进程网格**：$P_{x} \\times P_{y}$，其中 $P = P_{x} P_{y}$。\n- **分解方式**：沿 $z$ 轴的铅笔分解。\n- **每个进程的子域尺寸**：$\\frac{n_{x}}{P_{x}} \\times \\frac{n_{y}}{P_{y}} \\times n_{z}$。\n- **晕环厚度**：在 $x$ 和 $y$ 方向上为 $\\delta$ 个网格单元。\n- **通信模式**：\n    - 与 $x-y$ 平面内的四个邻居进行面晕环交换。\n    - 与 $x-y$ 平面内的四个对角邻居进行边晕环交换。\n    - 不涉及 $z$ 方向的角晕环交换。\n- **每个网格单元的数据**：$c$ 个自由度。\n- **数据大小**：每个自由度 $b$ 字节。\n- **总通信量的定义**：每个时间步内，所有进程为面、边和角交换发送的字节数之和。\n- **用于分析的特殊情况**：平衡分解 $P_{x} = P_{y} = \\sqrt{P}$ 和立方体网格 $n_{x} = n_{y} = n_{z} = n$。\n- **目标**：推导面、边和角通信量的表达式；然后在特殊情况下，识别当 $P$ 很大时的主导贡献，并提供总通信量的主导项表达式。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据**：该问题基于高性能计算和计算电磁学中的既定概念。铅笔域分解和晕环交换是在结构化网格上并行化偏微分方程（如麦克斯韦方程组）求解器的标准基础技术。该设置在科学上和算法上都是合理的。\n- **定义明确**：该问题已用所有必要的参数（$n_x, n_y, n_z, P_x, P_y, \\delta, c, b$）和一个精确的几何设置清晰地定义。目标是推导一个解析表达式，这是一个明确定义的数学任务。\n- **客观性**：问题陈述使用了精确、无歧义的技术语言，不含主观内容。\n\n该问题不存在科学上不合理、不完整、矛盾或含糊不清等任何缺陷。这是一个并行计算中的标准分析问题。\n\n### 第3步：结论和行动\n问题是有效的。将提供完整解答。\n\n### 解答推导\n\n每个时间步的总通信量 $V_{\\text{total}}$ 是面、边和角交换的通信量之和。问题将其定义为所有进程*发送*的所有字节之和。我们可以通过识别所有进程间数据交换，计算每个交换的数据量，然后将它们相加来计算这个值。一个等效的方法是计算不同通信接口的数量，确定通过每个接口（双向）发送的数据，然后将这些贡献相加。\n\n**1. 面通信量 ($V_{\\text{face}}$)**\n\n面通信发生在 $x$ 和 $y$ 方向上相邻子域的边界上。\n\n- **沿 $x$ 面的通信**：进程网格有 $P_x$ 列和 $P_y$ 行。进程列之间有 $(P_x - 1)$ 个垂直边界。这些边界中的每一个都在 $y$ 方向上跨越 $P_y$ 个进程。因此，在 $x$ 方向上有 $(P_x - 1) P_y$ 个不同的接口。在每个接口上，数据双向发送。发送的数据是一个大小为 $\\delta \\times \\frac{n_y}{P_y} \\times n_z$ 的网格单元板。\n一个进程跨一个 $x$ 面发送的数据量为：\n$$V_{\\text{send}, x} = \\left(\\delta \\times \\frac{n_y}{P_y} \\times n_z\\right) \\times c \\times b$$\n跨所有 $x$ 面发送的总数据量是接口数量的两倍乘以该数据量（每个传输方向一次）：\n$$V_{\\text{face}, x} = 2 \\times (P_x - 1) P_y \\times \\left(\\delta \\cdot \\frac{n_y}{P_y} \\cdot n_z \\cdot c \\cdot b\\right) = 2 (P_x - 1) \\delta n_y n_z c b$$\n\n- **沿 $y$ 面的通信**：类似地，进程行之间有 $(P_y - 1)$ 个水平边界，每个边界跨越 $P_x$ 个进程。这产生了 $(P_y - 1) P_x$ 个接口。发送的数据是一个大小为 $\\frac{n_x}{P_x} \\times \\delta \\times n_z$ 的板。\n跨所有 $y$ 面发送的总数据量为：\n$$V_{\\text{face}, y} = 2 \\times (P_y - 1) P_x \\times \\left(\\frac{n_x}{P_x} \\cdot \\delta \\cdot n_z \\cdot c \\cdot b\\right) = 2 (P_y - 1) \\delta n_x n_z c b$$\n\n总的面通信量是两者之和：\n$$V_{\\text{face}} = V_{\\text{face}, x} + V_{\\text{face}, y} = 2 \\delta n_z c b \\left[ (P_x - 1) n_y + (P_y - 1) n_x \\right]$$\n\n**2. 边通信量 ($V_{\\text{edge}}$)**\n\n边通信发生在与 $x-y$ 平面内的对角邻居之间。这些交换发生在四个进程子域相交的“角”上。在 $P_x \\times P_y$ 进程网格中，这样的内部角的数量是 $(P_x - 1)(P_y - 1)$。\n在每个这样的角上，有四个进程相遇。我们用它们的网格索引来标记它们：$(i, j)$, $(i+1, j)$, $(i, j+1)$ 和 $(i+1, j+1)$。对角交换发生在 $(i, j)$ 和 $(i+1, j+1)$ 之间，以及 $(i+1, j)$ 和 $(i, j+1)$ 之间。对于每一对，通信都是双向的。例如，进程 $(i,j)$ 向 $(i+1,j+1)$ 发送数据，而 $(i+1,j+1)$ 向 $(i,j)$ 发送数据。这导致每个进程网格的内部角总共发送 4 条消息。\n为边交换发送的数据是一束横截面为 $\\delta \\times \\delta$ 且具有完整 $z$ 范围 $n_z$ 的“铅笔”状单元。一条此类消息的数据量为：\n$$V_{\\text{send}, \\text{edge}} = (\\delta \\times \\delta \\times n_z) \\times c \\times b = \\delta^2 n_z c b$$\n总的边通信量是内部进程角的数量乘以每个角 4 次发送，再乘以每次发送的数据量：\n$$V_{\\text{edge}} = (P_x - 1)(P_y - 1) \\times 4 \\times (\\delta^2 n_z c b) = 4 (P_x - 1)(P_y - 1) \\delta^2 n_z c b$$\n\n**3. 角通信量 ($V_{\\text{corner}}$)**\n\n问题陈述明确指出，由于铅笔分解（沿 $z$ 轴没有分解），不存在对应于所有三个维度（$\\pm x, \\pm y, \\pm z$）的角的进程间邻居。因此，该通信量为零。\n$$V_{\\text{corner}} = 0$$\n\n**4. 特化与渐近分析**\n\n我们现在将这些表达式特化为平衡、立方体的情况：$n_x = n_y = n_z = n$ 且 $P_x = P_y = \\sqrt{P}$。\n\n- 特化后的面通信量：\n$$V_{\\text{face}} = 2 \\delta n c b \\left[ (\\sqrt{P} - 1) n + (\\sqrt{P} - 1) n \\right] = 2 \\delta n c b \\left[ 2 n (\\sqrt{P} - 1) \\right]$$\n$$V_{\\text{face}} = 4 \\delta n^2 c b (\\sqrt{P} - 1)$$\n\n- 特化后的边通信量：\n$$V_{\\text{edge}} = 4 (\\sqrt{P} - 1)(\\sqrt{P} - 1) \\delta^2 n c b = 4 \\delta^2 n c b (\\sqrt{P} - 1)^2$$\n$$V_{\\text{edge}} = 4 \\delta^2 n c b (P - 2\\sqrt{P} + 1)$$\n\n为了确定当 $P$ 变大时的主导贡献，我们比较 $V_{\\text{face}}$ 和 $V_{\\text{edge}}$ 关于 $P$ 的领先阶项。\n- 对于 $V_{\\text{face}}$，领先项与 $\\sqrt{P}$ 成正比：\n$$V_{\\text{face}} \\approx 4 \\delta n^2 c b \\sqrt{P} \\quad (\\text{对于大的 } P)$$\n缩放级别为 $O(\\sqrt{P})$。\n\n- 对于 $V_{\\text{edge}}$，领先项与 $P$ 成正比：\n$$V_{\\text{edge}} \\approx 4 \\delta^2 n c b P \\quad (\\text{对于大的 } P)$$\n缩放级别为 $O(P)$。\n\n由于 $P$ 的增长速度快于 $\\sqrt{P}$，因此对于大的 $P$ 值，边通信量（$V_{\\text{edge}}$）是主导贡献。\n\n总通信量为 $V_{\\text{total}} = V_{\\text{face}} + V_{\\text{edge}} + V_{\\text{corner}}$。\n$$V_{\\text{total}} = 4 \\delta n^2 c b (\\sqrt{P} - 1) + 4 \\delta^2 n c b (P - 2\\sqrt{P} + 1) + 0$$\n$$V_{\\text{total}} = (4 \\delta^2 n c b) P + (4 \\delta n^2 c b - 8 \\delta^2 n c b) \\sqrt{P} + (4 \\delta^2 n c b - 4 \\delta n^2 c b)$$\n问题要求的是总通信量的主导项表达式。这是 $P$ 的最高次幂项。主导项是与 $P$ 成正比的项，源自边通信。\n\n主导项表达式：$4 \\delta^2 n c b P$。这表示在大量进程的极限情况下，由于主导通信模式（边交换）而每个时间步发送的总字节数。",
            "answer": "$$\n\\boxed{4 \\delta^{2} n c b P}\n$$"
        },
        {
            "introduction": "除了节点间的通信，现代多核处理器上的性能还受到内存架构的严重影响，特别是非均匀内存访问 (NUMA) 架构。本练习将从抽象的通信分析转向具体的硬件优化，要求您为一个关键的计算核心设计一种数据布局策略，以最小化昂贵的远程内存访问。这项技能对于在当今的高性能计算节点上实现高效率至关重要。",
            "id": "3336938",
            "problem": "考虑计算电磁学中由麦克斯韦方程组空间离散化产生的稀疏旋度-旋度算子。从旋度方程出发，可以得到矢量波公式，在应用基于边的有限元方法后，离散系统涉及作用于未知向量的旋度-旋度矩阵，该操作实现为稀疏矩阵向量乘积。在一个双插槽非均匀内存访问（NUMA）系统中，访问内存的成本取决于数据是由本地插槽的内存提供还是由远程插槽的内存提供。您必须分析并最小化在两个分区上组装的旋度-旋度矩阵进行稀疏矩阵向量乘积时的远程内存访问比例，并量化通过优化的数据布局策略相较于朴素的交错式布局可实现的加速比。\n\n基本原理。从麦克斯韦方程组中的旋度方程和导致旋度-旋度算子的标准有限元离散化开始。离散更新涉及计算 $y = A x$，其中 $A$ 是一个稀疏矩阵，$x$ 是一个向量，$A$ 是按行分区组装在两个插槽上的。假设 $A$ 以压缩稀疏行（CSR）格式存储，因此对于每个非零元，都会在本地读取一个A值和一个A的列索引。乘积 $y = A x$ 需要读取由 $A$ 的非零元模式索引的 $x$ 条目。在一个双插槽系统上，每个插槽并发处理其行分区，并读取其行所引用的 $x$ 条目的子集。假设 $A$ 的行和 $y$ 的条目都局部分配给它们所属的插槽。\n\n定义。令 $C_0[i]$ 表示在一个稀疏矩阵向量乘积过程中，插槽0读取 $x$ 的第i个条目的次数，令 $C_1[i]$ 表示插槽1读取 $x$ 的第i个条目的次数。在插槽 $s$ 上处理的非零元总数为 $\\sum_i C_s[i]$。定义本地带宽 $B_{\\text{local}}$（单位：字节/秒）、远程带宽 $B_{\\text{remote}}$（单位：字节/秒）、每次访问 $x$ 读取的字节数 $b_x$（单位：字节），以及对于本地数据，每个 $A$ 的非零元读取的字节数 $b_A$（单位：字节），这包括了 $A$ 的值和 $A$ 的索引。令远程访问比率为 $\\rho_s$，即源自插槽 $s$ 的 $x$ 读取中属于远程访问的比例。\n\n朴素布局。通过在插槽间对 $x$ 的页面进行朴素的交错式布局，每个插槽 $s$ 的 $x$ 读取中大约有 $\\rho_s = 0.5$ 的远程比例，即所有 $x$ 访问的一半是远程访问。\n\n优化数据布局策略。您必须提出一种数据布局策略，通过决定将 $x$ 的哪些条目在两个插槽上复制，以及将哪些条目单独分配给一个插槽，来最小化总体远程访问比率。该决定必须遵守一个复制预算 $K$，即可以在两个插槽上复制的 $x$ 条目的最大数量。对于未复制的 $x$ 条目，您可以将每个这样的条目分配给访问它更频繁的插槽，以最小化远程读取。当访问次数相等时，您必须在该 $x$ 条目的页面之间进行交错布局，以便每个插槽对该条目的访问有 $0.5$ 的远程比例。\n\n性能模型。对于每个插槽 $s \\in \\{0,1\\}$，处理其分区的时间由内存限制模型给出\n$$\nT_s = \\frac{\\sum_i C_s[i]\\; b_A}{B_{\\text{local}}} + \\frac{L_s\\; b_x}{B_{\\text{local}}} + \\frac{R_s\\; b_x}{B_{\\text{remote}}},\n$$\n其中 $L_s$ 是插槽 $s$ 上的本地 $x$ 读取次数，$R_s$ 是插槽 $s$ 上的远程 $x$ 读取次数。稀疏矩阵向量乘积的总时间为\n$$\nT = \\max\\{T_0, T_1\\}.\n$$\n优化策略相对于朴素策略的加速比为\n$$\nS = \\frac{T_{\\text{naive}}}{T_{\\text{optimized}}}.\n$$\n\n您的程序必须纯粹以逻辑和数学术语实现以下步骤：\n- 给定 $C_0[i]$ 和 $C_1[i]$，对两个插槽使用 $\\rho_s = 0.5$ 计算 $T_{\\text{naive}}$。\n- 给定复制预算 $K$，选择最多 $K$ 个索引 $i$ 进行复制，以最小化远程 $x$ 读取的总次数。对于未复制的索引，将索引 $i$ 分配给 $C_s[i]$ 较大的插槽；对于 $C_0[i] = C_1[i]$ 的平局情况，进行交错布局，以便每个插槽对该索引的读取中有 $0.5$ 是远程的， $0.5$ 是本地的。然后相应地计算 $T_{\\text{optimized}}$。\n- 计算加速比 $S$。\n\n单位和输出。带宽 $B_{\\text{local}}$ 和 $B_{\\text{remote}}$ 必须以字节/秒为单位处理。量 $b_x$ 和 $b_A$ 必须以字节为单位处理。将加速比 $S$ 报告为无单位的浮点数。\n\n测试套件。您的程序必须运行以下一组测试案例，这些案例涵盖了一般情况、高重叠、不共享分区、均等访问且完全复制以及均等访问且无复制：\n- Case $1$: $C_0 = [120,80,10,60,70,90,5,110]$, $C_1 = [110,90,40,70,80,50,100,60]$, $K = 3$, $B_{\\text{local}} = 80 \\times 10^9$, $B_{\\text{remote}} = 30 \\times 10^9$, $b_x = 8$, $b_A = 12$.\n- Case $2$: $C_0 = [500,450,0,0,300,250,0,0]$, $C_1 = [450,500,0,0,250,300,0,0]$, $K = 2$, $B_{\\text{local}} = 90 \\times 10^9$, $B_{\\text{remote}} = 35 \\times 10^9$, $b_x = 8$, $b_A = 12$.\n- Case $3$: $C_0 = [300,0,0,0,100,0,0,0]$, $C_1 = [0,300,0,0,0,100,0,0]$, $K = 0$, $B_{\\text{local}} = 70 \\times 10^9$, $B_{\\text{remote}} = 25 \\times 10^9$, $b_x = 8$, $b_A = 12$.\n- Case $4$: $C_0 = [100,100,100,100,100,100,100,100]$, $C_1 = [100,100,100,100,100,100,100,100]$, $K = 8$, $B_{\\text{local}} = 60 \\times 10^9$, $B_{\\text{remote}} = 20 \\times 10^9$, $b_x = 8$, $b_A = 12$.\n- Case $5$: $C_0 = [50,50,50,50,50,50,50,50]$, $C_1 = [50,50,50,50,50,50,50,50]$, $K = 0$, $B_{\\text{local}} = 60 \\times 10^9$, $B_{\\text{remote}} = 20 \\times 10^9$, $b_x = 8$, $b_A = 12$.\n\n最终输出格式。您的程序应生成单行输出，其中包含五个案例的加速比结果，格式为方括号内逗号分隔的列表，例如 $[s_1,s_2,s_3,s_4,s_5]$，其中每个 $s_i$ 是一个浮点值。",
            "solution": "该问题要求在双插槽非均匀内存访问（NUMA）系统上对并行稀疏矩阵向量乘积（$SpMV$）的内存访问模式进行分析和性能优化。具体操作是 $y = Ax$，其中 $A$ 是一个稀疏矩阵，代表计算电磁学中有限元离散化产生的旋度-旋度算子。向量 $x$ 在两个NUMA插槽之间进行分区或复制，以最小化远程内存访问。我们必须计算优化数据布局策略相对于朴素策略的加速比。\n\n该分析基于一个内存限制的性能模型。对于每个插槽 $s \\in \\{0, 1\\}$，计算其部分SpMV所需的时间由以下公式给出：\n$$\nT_s = T_{s,A} + T_{s,x} = \\frac{(\\sum_i C_s[i]) b_A}{B_{\\text{local}}} + \\frac{L_s b_x}{B_{\\text{local}}} + \\frac{R_s b_x}{B_{\\text{remote}}}\n$$\n此处，$C_s[i]$ 是插槽 $s$ 访问向量 $x$ 第i个元素的次数。项 $T_{s,A}$ 代表读取矩阵数据（值和索引）的时间，假设这些数据存储在本地。插槽 $s$ 上的非零元总数为 $\\sum_i C_s[i]$，$b_A$ 是每个非零元的字节数。项 $T_{s,x}$ 是读取向量 $x$ 元素的时间。$L_s$ 和 $R_s$ 分别是 $x$ 元素的本地和远程读取次数，满足 $L_s + R_s = \\sum_i C_s[i]$。$b_x$ 是 $x$ 一个元素的大小。$B_{\\text{local}}$ 和 $B_{\\text{remote}}$ 是本地和远程内存带宽。SpMV的总时间由较慢的插槽决定：$T = \\max\\{T_0, T_1\\}$。\n\n**朴素数据布局策略**\n在朴素策略下，向量 $x$ 的页面在两个插槽之间交错布局。这意味着从一个插槽对 $x$ 的任一元素进行的任何给定访问都有 $50\\%$ 的概率是本地的， $50\\%$ 的概率是远程的。因此，每个插槽 $s$ 的远程访问比率 $\\rho_s$ 为 $0.5$。插槽 $s$ 的本地和远程读取次数可以建模为：\n$$\nL_{s, \\text{naive}} = 0.5 \\sum_i C_s[i]\n$$\n$$\nR_{s, \\text{naive}} = 0.5 \\sum_i C_s[i]\n$$\n使用这些值，我们可以计算 $T_{0, \\text{naive}}$ 和 $T_{1, \\text{naive}}$，总时间为 $T_{\\text{naive}} = \\max\\{T_{0, \\text{naive}}, T_{1, \\text{naive}}\\}$。\n\n**优化数据布局策略**\n优化策略旨在最小化远程内存访问的总数，给定一个预算 $K$ 用于可在两个插槽上复制的 $x$ 条目数。对每个条目 $x[i]$ 的决策过程如下：\n1.  **复制**：如果一个条目 $x[i]$ 被复制，那么来自两个插槽的所有对它的访问（即 $C_0[i]$ 和 $C_1[i]$）都变为本地访问。\n2.  **独占布局**：如果 $x[i]$ 未被复制，它将被放置在单个插槽的本地内存中。为了最小化远程访问，它应被放置在访问它最频繁的插槽上。例如，如果 $C_0[i]  C_1[i]$，将 $x[i]$ 放置在插槽0上会导致 $C_0[i]$ 次本地访问（来自插槽0）和 $C_1[i]$ 次远程访问（来自插槽1）。此条目的远程访问总数为 $\\min(C_0[i], C_1[i])$。\n3.  **交错（平局情况）**：如果 $C_0[i] = C_1[i]$ 并且该条目未被复制，则进行交错布局。对于此条目，来自插槽0的访问是 $50\\%$ 本地和 $50\\%$ 远程，对于插槽1也类似。\n\n通过复制条目 $x[i]$ 节省的远程读取总数为 $\\min(C_0[i], C_1[i])$。为了在 $K$ 次复制的预算内实现远程读取的最大减少，贪心方法是最优的：识别出具有最大 $\\min(C_0[i], C_1[i])$ 值的 $K$ 个 $x$ 条目并复制它们。\n\n优化策略的算法如下：\n1.  对于每个条目 $i$，计算如果复制可带来的远程访问减少量：$\\text{benefit}_i = \\min(C_0[i], C_1[i])$。\n2.  选择具有最高收益的前 $K$ 个条目进行复制。\n3.  初始化每个插槽的本地和远程访问计数：$L_{0, \\text{opt}} = R_{0, \\text{opt}} = L_{1, \\text{opt}} = R_{1, \\text{opt}} = 0$。\n4.  遍历每个条目 $x[i]$：\n    - 如果 $x[i]$ 被标记为复制：\n        - $L_{0, \\text{opt}} \\leftarrow L_{0, \\text{opt}} + C_0[i]$\n        - $L_{1, \\text{opt}} \\leftarrow L_{1, \\text{opt}} + C_1[i]$\n    - 如果 $x[i]$ 未被复制：\n        - 如果 $C_0[i]  C_1[i]$ (放置在插槽0):\n            - $L_{0, \\text{opt}} \\leftarrow L_{0, \\text{opt}} + C_0[i]$\n            - $R_{1, \\text{opt}} \\leftarrow R_{1, \\text{opt}} + C_1[i]$\n        - 如果 $C_1[i]  C_0[i]$ (放置在插槽1):\n            - $R_{0, \\text{opt}} \\leftarrow R_{0, \\text{opt}} + C_0[i]$\n            - $L_{1, \\text{opt}} \\leftarrow L_{1, \\text{opt}} + C_1[i]$\n        - 如果 $C_0[i] = C_1[i]$ (交错布局):\n            - $L_{0, \\text{opt}} \\leftarrow L_{0, \\text{opt}} + 0.5 \\cdot C_0[i]$\n            - $R_{0, \\text{opt}} \\leftarrow R_{0, \\text{opt}} + 0.5 \\cdot C_0[i]$\n            - $L_{1, \\text{opt}} \\leftarrow L_{1, \\text{opt}} + 0.5 \\cdot C_1[i]$\n            - $R_{1, \\text{opt}} \\leftarrow R_{1, \\text{opt}} + 0.5 \\cdot C_1[i]$\n5.  使用最终的计数 $L_{s, \\text{opt}}$ 和 $R_{s, \\text{opt}}$，根据性能模型计算每个插槽的 $T_{s, \\text{opt}}$。\n6.  总的优化时间为 $T_{\\text{optimized}} = \\max\\{T_{0, \\text{opt}}, T_{1, \\text{opt}}\\}$。\n\n**加速比**\n最终的性能增益通过加速比来量化，即朴素执行时间与优化执行时间的比率：\n$$\nS = \\frac{T_{\\text{naive}}}{T_{\\text{optimized}}}\n$$\n将为每个提供的测试用例计算此值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_speedups(test_cases):\n    \"\"\"\n    Calculates the speedup for a series of test cases based on the provided NUMA performance model.\n    \"\"\"\n    speedup_results = []\n    \n    for case in test_cases:\n        C0, C1, K, B_local, B_remote, b_x, b_A = case\n        C0 = np.array(C0, dtype=float)\n        C1 = np.array(C1, dtype=float)\n        \n        num_entries = len(C0)\n        \n        # --- Calculate Naive Time ---\n        \n        total_reads_0 = np.sum(C0)\n        total_reads_1 = np.sum(C1)\n        \n        # Naive placement: 50% of x-reads are remote for each socket\n        L0_naive = 0.5 * total_reads_0\n        R0_naive = 0.5 * total_reads_0\n        L1_naive = 0.5 * total_reads_1\n        R1_naive = 0.5 * total_reads_1\n        \n        # Time for socket 0\n        T_A_0 = (total_reads_0 * b_A) / B_local\n        T_x_0_naive = (L0_naive * b_x) / B_local + (R0_naive * b_x) / B_remote\n        T0_naive = T_A_0 + T_x_0_naive\n        \n        # Time for socket 1\n        T_A_1 = (total_reads_1 * b_A) / B_local\n        T_x_1_naive = (L1_naive * b_x) / B_local + (R1_naive * b_x) / B_remote\n        T1_naive = T_A_1 + T_x_1_naive\n        \n        T_naive = max(T0_naive, T1_naive)\n        \n        # --- Calculate Optimized Time ---\n\n        # 1. Determine which entries to replicate\n        # The benefit of replicating is avoiding min(C0[i], C1[i]) remote reads.\n        benefits = []\n        for i in range(num_entries):\n            benefit = min(C0[i], C1[i])\n            benefits.append((benefit, i))\n        \n        # Sort by benefit in descending order\n        benefits.sort(key=lambda x: x[0], reverse=True)\n        \n        replicated_indices = set()\n        if K > 0:\n            replicated_indices = {idx for benefit, idx in benefits[:K]}\n        \n        # 2. Calculate L_opt and R_opt based on the placement strategy\n        L0_opt, R0_opt = 0.0, 0.0\n        L1_opt, R1_opt = 0.0, 0.0\n        \n        for i in range(num_entries):\n            if i in replicated_indices:\n                # Replicated: all accesses are local for both sockets\n                L0_opt += C0[i]\n                L1_opt += C1[i]\n            else:\n                # Not replicated: place according to access frequency\n                if C0[i] > C1[i]:\n                    # Place on socket 0\n                    L0_opt += C0[i]  # Local accesses for socket 0\n                    R1_opt += C1[i]  # Remote accesses for socket 1\n                elif C1[i] > C0[i]:\n                    # Place on socket 1\n                    R0_opt += C0[i]  # Remote accesses for socket 0\n                    L1_opt += C1[i]  # Local accesses for socket 1\n                else: # C0[i] == C1[i]\n                    # Interleave: 50% local, 50% remote for both\n                    L0_opt += 0.5 * C0[i]\n                    R0_opt += 0.5 * C0[i]\n                    L1_opt += 0.5 * C1[i]\n                    R1_opt += 0.5 * C1[i]\n                    \n        # Time for socket 0\n        T_x_0_opt = (L0_opt * b_x) / B_local + (R0_opt * b_x) / B_remote\n        T0_opt = T_A_0 + T_x_0_opt # T_A_0 is the same as in the naive case\n        \n        # Time for socket 1\n        T_x_1_opt = (L1_opt * b_x) / B_local + (R1_opt * b_x) / B_remote\n        T1_opt = T_A_1 + T_x_1_opt # T_A_1 is the same as in the naive case\n        \n        T_optimized = max(T0_opt, T1_opt)\n        \n        # --- Calculate Speedup ---\n        speedup = T_naive / T_optimized if T_optimized > 0 else float('inf')\n        speedup_results.append(speedup)\n        \n    return speedup_results\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General case\n        (\n            [120, 80, 10, 60, 70, 90, 5, 110], \n            [110, 90, 40, 70, 80, 50, 100, 60], \n            3, 80e9, 30e9, 8, 12\n        ),\n        # Case 2: High overlap\n        (\n            [500, 450, 0, 0, 300, 250, 0, 0], \n            [450, 500, 0, 0, 250, 300, 0, 0], \n            2, 90e9, 35e9, 8, 12\n        ),\n        # Case 3: Unshared partitions\n        (\n            [300, 0, 0, 0, 100, 0, 0, 0], \n            [0, 300, 0, 0, 0, 100, 0, 0], \n            0, 70e9, 25e9, 8, 12\n        ),\n        # Case 4: Equal access, full replication\n        (\n            [100, 100, 100, 100, 100, 100, 100, 100], \n            [100, 100, 100, 100, 100, 100, 100, 100], \n            8, 60e9, 20e9, 8, 12\n        ),\n        # Case 5: Equal access, no replication\n        (\n            [50, 50, 50, 50, 50, 50, 50, 50], \n            [50, 50, 50, 50, 50, 50, 50, 50], \n            0, 60e9, 20e9, 8, 12\n        ),\n    ]\n\n    results = calculate_speedups(test_cases)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "实现加速只是并行计算的目标之一；确保结果的正确性和可复现性同等重要。本练习探讨了一个微妙但关键的问题：由并行操作中浮点运算的非结合性引起的数值不可复现性。通过分析并行归约这一常见任务，您将了解到为何结果会发生变化，以及如何在需要时强制实现确定性的结果。",
            "id": "3336896",
            "problem": "一个三维计算电磁学仿真求解由麦克斯韦方程组离散化产生的线性系统 $A \\mathbf{x} = \\mathbf{b}$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 和 $\\mathbf{b} \\in \\mathbb{R}^{n}$ 是实数值的。一种迭代Krylov方法在第 $k$ 次迭代时计算残差 $\\mathbf{r}^{(k)} = \\mathbf{b} - A \\mathbf{x}^{(k)}$，并使用欧几里得范数 $\\|\\mathbf{r}^{(k)}\\|_{2} = \\sqrt{\\sum_{i=1}^{n} \\left(r^{(k)}_{i}\\right)^{2}}$ 来进行收敛和预处理决策。在一个使用 Open Multi-Processing (OpenMP) 的共享内存并行实现中，内层求和 $\\sum_{i=1}^{n} \\left(r^{(k)}_{i}\\right)^{2}$ 是通过 OpenMP 归约来计算的。硬件算术遵循电气和电子工程师协会 (IEEE) 的浮点算术标准 (IEEE 754)，采用向偶数舍入（rounding to nearest ties-to-even）的舍入模式，双精度单位舍入误差为 $u$。\n\n从第一性原理出发，考虑浮点舍入模型 $\\operatorname{fl}(a \\oplus b) = (a \\oplus b)(1 + \\delta)$，其中 $\\oplus$ 表示精确的算术运算，$\\operatorname{fl}(\\cdot)$ 表示浮点运算结果，且 $|\\delta| \\le u$。特别地，对于加法，$\\operatorname{fl}(a + b) = (a + b)(1 + \\delta)$ 且 $|\\delta| \\le u$。OpenMP 中的并行归约可能会根据线程数、调度和归约树的形状，以由实现定义的顺序来组合部分和。\n\n关于使用 OpenMP 归约计算 $\\|\\mathbf{r}^{(k)}\\|_{2}$ 以及所得范数在不同运行次数和线程数下的数值可复现性，下列哪些陈述是正确的？\n\nA. 在双精度浮点数上使用带 $+$ 运算符的 OpenMP 归约，能确保对于相同输入，在不同线程数下得到逐位相同的结果，因为 $+$ 运算是满足结合律的。\n\nB. 求和 $\\sum_{i=1}^{n} \\left(r^{(k)}_{i}\\right)^{2}$ 的不同加括号方式（求和顺序）会产生不同的浮点结果；但是，在平衡二叉树中进行成对求和能将最坏情况下的相对误差从 $\\mathcal{O}(n u)$ 降低到 $\\mathcal{O}(\\log n \\, u)$，并且如果归约树是确定性地构建的（独立于线程调度），那么在使用相同树的多次运行中，计算出的和是逐位可复现的。\n\nC. 在每个线程内执行 Kahan 补偿求和，然后使用带 $+$ 运算符的 OpenMP 归约来合并各线程局部的补偿和，可以保证在任何线程数下结果都是逐位可复现的。\n\nD. 将归约操作替换为将 $\\left(r^{(k)}_{i}\\right)^{2}$ 原子地加到一个单一的全局累加器中，可以保证准确性和可复现性，因为原子操作序列化了加法运算。\n\nE. 使用基于浮点展开或超级累加器（例如，将各个加数确定性地收集到固定“箱子”中的分箱求和）的精确累加器，可以得到一个与求和顺序无关的和；通过固定的分箱和最后一次性的向偶数舍入，结果在不同运行次数和线程数下是逐位可复现的。\n\n选择所有适用项。",
            "solution": "对该问题的分析需要对电气和电子工程师协会 (IEEE) $754$ 标准所定义的浮点算术及其对并行计算的影响有扎实的理解。核心问题在于浮点加法不满足结合律，这对并行归约中的可复现性具有深远的影响。\n\n首先根据所需流程对问题陈述进行验证。\n\n### 第1步：提取已知条件\n- 正在求解一个线性系统 $A \\mathbf{x} = \\mathbf{b}$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 且 $\\mathbf{b} \\in \\mathbb{R}^{n}$。\n- 背景是一个三维计算电磁学仿真。\n- 求解方法是一种迭代Krylov方法。\n- 在每次迭代 $k$ 时，计算残差：$\\mathbf{r}^{(k)} = \\mathbf{b} - A \\mathbf{x}^{(k)}$。\n- 使用残差的欧几里得范数 $\\|\\mathbf{r}^{(k)}\\|_{2} = \\sqrt{\\sum_{i=1}^{n} \\left(r^{(k)}_{i}\\right)^{2}}$。\n- 内层求和 $S = \\sum_{i=1}^{n} \\left(r^{(k)}_{i}\\right)^{2}$ 使用 OpenMP 归约并行计算。\n- 硬件算术遵循 IEEE $754$ 浮点算术标准，采用向偶数舍入。\n- 精度为双精度，单位舍入误差为 $u$。\n- 精确运算 $\\oplus$ 的浮点舍入模型是 $\\operatorname{fl}(a \\oplus b) = (a \\oplus b)(1 + \\delta)$，其中 $|\\delta| \\le u$。特别地，对于加法，$\\operatorname{fl}(a + b) = (a + b)(1 + \\delta)$。\n- OpenMP 归约可能以由实现定义的顺序组合部分和。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据充分：** 该问题描述了高性能科学计算中的一个标准且关键的问题。将Krylov方法用于计算电磁学(CEM)问题、残差和范数的计算，以及浮点算术下并行归约的挑战，都是数值分析和计算科学中已被充分确立的基础课题。所用的浮点模型是误差分析中的标准模型。该陈述在科学上是合理的。\n- **问题适定：** 该问题提供了一个清晰的计算场景，并要求评估关于数值可复现性的具体陈述。问题定义明确，并允许基于计算机算术原理进行唯一的分析。\n- **客观性：** 语言规范、精确，没有任何主观性或歧义。\n\n### 第3步：结论与行动\n问题陈述有效。它在科学上合理、问题适定且客观，为对选项进行严谨分析提供了充分的基础。可以继续进行求解过程。\n\n### 基于原理的推导与逐项分析\n\n中心原理是浮点加法不满足结合律。虽然对于任意实数 $a, b, c$，$(a+b)+c = a+(b+c)$ 成立，但这对于它们的浮点表示通常不成立。令 $\\operatorname{fl}(\\cdot)$ 表示浮点运算的结果。通常情况下，$\\operatorname{fl}(\\operatorname{fl}(a+b)+c) \\neq \\operatorname{fl}(a+\\operatorname{fl}(b+c))$。这是因为每一步都会引入舍入误差，且误差的大小取决于操作数的大小。\n\n一个 OpenMP 归约，例如 `#pragma omp parallel for reduction(+:sum)`，会将循环迭代分配给一组线程。每个线程计算一个部分和。然后这些部分和被组合（归约）以形成最终的总和。OpenMP 标准没有强制规定组合这些部分和的特定顺序。该顺序可能取决于线程数、运行时调度器以及编译器选择的归约具体实现（例如，对部分和进行简单的顺序归约，或基于树的归约）。由于运算顺序（求和的“加括号方式”）可能在每次运行时发生变化，并且浮点加法不满足结合律，因此最终计算出的和不保证在多次运行之间是逐位相同的。\n\n让我们基于这一原理来评估每个选项。\n\n**A. 在双精度浮点数上使用带 $+$ 运算符的 OpenMP 归约，能确保对于相同输入，在不同线程数下得到逐位相同的结果，因为 $+$ 运算是满足结合律的。**\n\n- **分析：** 这个陈述的前提中有一个致命的缺陷。虽然数学上的加法运算符“$+$”对实数是满足结合律的，但其有限精度的浮点对应运算**不**满足结合律。例如，考虑双精度下的 $a = 1.0$、$b = 10^{20}$ 和 $c = -10^{20}$。那么 $\\operatorname{fl}(\\operatorname{fl}(a+b)+c) = \\operatorname{fl}(1.0+10^{20}-10^{20}) = \\operatorname{fl}(10^{20}-10^{20})=0.0$。但是 $\\operatorname{fl}(a+\\operatorname{fl}(b+c)) = \\operatorname{fl}(1.0 + \\operatorname{fl}(10^{20}-10^{20})) = \\operatorname{fl}(1.0+0.0) = 1.0$。这证明了非结合性。由于当线程数改变时，OpenMP 归约可能会改变运算顺序（加括号方式），因此它不会产生逐位相同的结果。\n- **结论：错误**。\n\n**B. 求和 $\\sum_{i=1}^{n} \\left(r^{(k)}_{i}\\right)^{2}$ 的不同加括号方式（求和顺序）会产生不同的浮点结果；但是，在平衡二叉树中进行成对求和能将最坏情况下的相对误差从 $\\mathcal{O}(n u)$ 降低到 $\\mathcal{O}(\\log n \\, u)$，并且如果归约树是确定性地构建的（独立于线程调度），那么在使用相同树的多次运行中，计算出的和是逐位可复现的。**\n\n- **分析：** 这个陈述包含三个正确的主张。\n  1. “不同的加括号方式……会产生不同的浮点结果”：这是正确的，可以用浮点加法的非结合律来解释。\n  2. “成对求和……降低了最坏情况下的相对误差……”：这是数值分析中的一个经典结果。一个简单的顺序求和，其最坏情况误差界与项数成正比，为 $\\mathcal{O}(n u)$。在平衡二叉树中求和（一种成对求和的形式）可以使中间和的量级更接近，从而减少误差累积。该方法的误差界确实是 $\\mathcal{O}(\\log_2 n \\cdot u)$。\n  3. “如果归约树是确定性地构建的……计算出的和是逐位可复现的”：如果加法的确切顺序是固定的，并且底层的浮点运算是确定性的（根据 IEEE $754$），那么对于相同的输入向量 $\\mathbf{r}^{(k)}$，结果必须是逐位相同的。一个确定性的归约树会固定这个顺序。\n- **结论：正确**。\n\n**C. 在每个线程内执行 Kahan 补偿求和，然后使用带 $+$ 运算符的 OpenMP 归约来合并各线程局部的补偿和，可以保证在任何线程数下结果都是逐位可复现的。**\n\n- **分析：** Kahan 求和是一种通过在一个补偿变量中跟踪舍入误差来提高求和准确性的技术。虽然这显著提高了每个线程内计算的部分和的准确性，但组合这些部分和的问题依然存在。所描述的最后一步是“使用带 $+$ 运算符的 OpenMP 归约来合并各线程局部的补偿和”。这个最终的归约步骤仍然受到非结合律的影响。如果线程数改变，需要组合的部分和的数量也会改变，非确定性的归约顺序很可能会导致不同的最终结果。该陈述声称保证在*任何*线程数下都具有可复现性是错误的。\n- **结论：错误**。\n\n**D. 将归约操作替换为将 $\\left(r^{(k)}_{i}\\right)^{2}$ 原子地加到一个单一的全局累加器中，可以保证准确性和可复现性，因为原子操作序列化了加法运算。**\n\n- **分析：** 原子操作（如 `omp atomic update`）确保对共享内存位置的更新不会受到其他线程的干扰，从而防止数据竞争。它们确实序列化了加法运算。然而，它们并**不**对这些串行加法强制一个特定的*顺序*。线程访问原子变量的顺序是非确定性的，取决于线程调度器。由于求和顺序不固定，且浮点加法不满足结合律，最终结果在多次运行之间将不具有可复现性。此外，这种方法将一个可并行的求和变成了一个带有高度争用开销的、实际上串行的过程，从而破坏了性能。与简单的顺序求和相比，它也不能提高准确性。\n- **结论：错误**。\n\n**E. 使用基于浮点展开或超级累加器（例如，将各个加数确定性地收集到固定“箱子”中的分箱求和）的精确累加器，可以得到一个与求和顺序无关的和；通过固定的分箱和最后一次性的向偶数舍入，结果在不同运行次数和线程数下是逐位可复现的。**\n\n- **分析：** 这个陈述描述了一种实现可复现求和的健壮方法。超级累加器或浮点展开以足够的精度存储和，以避免任何中间舍入误差。所有输入都被加到这个精确表示上。由于实数加法满足结合律和交换律，最终的精确和与各项相加的顺序无关。最后一步是将这个唯一的精确和舍入到目标浮点格式（例如双精度）。由于精确和是唯一的，并且舍入规则（向偶数舍入）是确定性的，因此无论线程数、调度或求和顺序如何，最终的浮点结果总是相同的。分箱求和是一种实用的算法，它通过按指数对加数进行分组以最小化舍入误差来近似这一理想情况，如果确定性地执行，它也能产生可复现的结果。这个陈述正确地描述了一种实现逐位可复现性的有效技术。\n- **结论：正确**。",
            "answer": "$$\\boxed{BE}$$"
        }
    ]
}