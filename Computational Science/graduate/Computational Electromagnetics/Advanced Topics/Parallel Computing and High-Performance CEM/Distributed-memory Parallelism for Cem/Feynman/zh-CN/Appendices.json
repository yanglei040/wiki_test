{
    "hands_on_practices": [
        {
            "introduction": "为了有效地扩展计算电磁学仿真，我们必须首先理解其中涉及的开销。作为分布式内存并行计算核心的区域分解策略，会因“光环交换”（halo exchanges）而引入通信开销，即处理器共享其子域边界上的数据。第一个实践练习  提供了一个具体的案例，要求您使用基础的延迟-带宽（$\\alpha-\\beta$）模型，为一个典型的时域有限差分（FDTD）仿真场景建立通信开销模型，从而量化通信瓶颈。",
            "id": "3301712",
            "problem": "考虑在 Yee 交错网格上对麦克斯韦方程组进行三维时域有限差分（FDTD）离散化，其中电场分量 $E_x$、$E_y$、$E_z$ 和磁场分量 $H_x$、$H_y$、$H_z$ 通过局部旋度运算进行更新。计算域的总尺寸为 $N_x \\times N_y \\times N_z$ 个单元，并使用带有周期性边界条件的笛卡尔分区，分布在 $P_x \\times P_y \\times P_z$ 个进程的进程网格上，因此每个进程都与其 $6$ 个面相邻的邻居通信。假设采用双精度存储（每个场值占用 $8$ 字节）。通信使用厚度为 $1$ 个单元的晕环交换，交换 Yee 更新模板所需的最小邻居场分量集。\n\n延迟-带宽（$\\alpha$–$\\beta$）模型将点对点通信时间描述为 $T_{\\text{msg}} = \\alpha + \\beta m$，其中 $\\alpha$ 是每条消息的延迟，$\\beta$ 是以 $\\mathrm{s}$/字节表示的逆带宽，$m$ 是以字节为单位的消息大小。假设晕环交换在每个时间步中分两轮进行：一轮用于电场，一轮用于磁场；在每一轮中，向 $6$ 个邻居中的每一个发送一条消息，聚合该场族每个面所需的晕环数据。\n\n给定：\n- $N_x = 1024$， $N_y = 512$， $N_z = 256$。\n- $P_x = 8$， $P_y = 4$， $P_z = 2$。\n- 每条消息的延迟 $\\alpha = 2 \\times 10^{-6}\\ \\mathrm{s}$。\n- 逆带宽 $\\beta = 1 \\times 10^{-10}\\ \\mathrm{s}$/字节。\n\n使用 Yee 更新结构来确定电场交换和磁场交换所需的每个进程的最小 $1$ 单元晕环负载（即，在每个面上按分量计，仅包括那些其更新模板需要垂直于该面方向上的邻居数据的分量）。然后，在所述的聚合策略（每轮每个邻居一条消息）下，使用 $\\alpha$–$\\beta$ 模型估算每个时间步每个进程的总通信时间。\n\n将最终的通信时间四舍五入到四位有效数字，并以秒为单位表示您的答案。",
            "solution": "该问题要求估算三维时域有限差分（FDTD）模拟中每个时间步每个进程的总通信时间。估算将基于为计算域、进程网格和延迟-带宽通信模型提供的参数。\n\n首先，我们确定分配给 $P = P_x \\times P_y \\times P_z$ 个处理进程中每一个的计算子域的维度。总域包含 $N_x \\times N_y \\times N_z$ 个单元，以笛卡尔方式划分。每个进程上的局部子域维度，记为 $n_x, n_y, n_z$，为：\n$$n_x = \\frac{N_x}{P_x} = \\frac{1024}{8} = 128 \\text{ 单元}$$\n$$n_y = \\frac{N_y}{P_y} = \\frac{512}{4} = 128 \\text{ 单元}$$\n$$n_z = \\frac{N_z}{P_z} = \\frac{256}{2} = 128 \\text{ 单元}$$\n每个进程管理一个 $128 \\times 128 \\times 128$ 单元的立方体子域。\n\n接下来，我们必须确定晕环交换的数据负载。问题指定了 $1$ 个单元厚度的晕环，并要求我们使用由 Yee FDTD 更新模板决定的“最小集”场分量。在 Yee 格式中，电场（$E$）分量使用磁场（$H$）的旋度进行更新，反之亦然。例如，$E_y$ 分量的更新涉及 $H_z$ 在 $x$ 方向上的有限差分：\n$$\\frac{\\partial E_y}{\\partial t} \\propto \\frac{\\partial H_x}{\\partial z} - \\frac{\\partial H_z}{\\partial x}$$\n为了计算子域边界上（例如，在一个恒定 $x$ 的平面上）的 $E_y$， $x$ 方向的有限差分需要来自相邻子域中相邻单元的 $H_z$ 值。类似的分析表明，在恒定 $x$ 的边界上更新 $E_z$ 需要来自邻居的 $H_y$。$E_x$ 的更新不需要来自 $x$ 方向邻居的任何数据。因此，为了更新垂直于 $x$ 轴的面上的 $E$ 场分量，一个进程必须从其 $x$ 方向的邻居接收一个 $1$ 单元厚的 $H_y$ 和 $H_z$ 分量层。这些分量 $H_y$ 和 $H_z$ 与该面相切。\n\n根据对称性，跨越三个笛卡尔方向中每一个进行交换所需的分量是与相应面相切的两个场分量。\n\\begin{itemize}\n    \\item 跨越垂直于 $x$ 轴的面：为进行 $H$ 场更新交换 $E_y, E_z$，为进行 $E$ 场更新交换 $H_y, H_z$。\n    \\item 跨越垂直于 $y$ 轴的面：为进行 $H$ 场更新交换 $E_x, E_z$，为进行 $E$ 场更新交换 $H_x, H_z$。\n    \\item 跨越垂直于 $z$ 轴的面：为进行 $H$ 场更新交换 $E_x, E_y$，为进行 $E$ 场更新交换 $H_x, H_y$。\n\\end{itemize}\n在所有情况下，都必须跨每个面交换 $2$ 个场分量。问题指出数据以双精度存储，即每个值 $8$ 字节。\n\n一个时间步的通信包括两轮：一轮用于电场，一轮用于磁场。在每一轮中，一个进程向其 $6$ 个邻居中的每一个发送一条聚合消息。让我们计算这些消息的大小。\n\n对于电场交换轮（交换 $E$ 场）：\n- 发送给 $\\pm x$ 方向邻居的消息大小 ($m_{E,x}$): 面面积为 $n_y \\times n_z$。交换两个分量 ($E_y, E_z$) 。\n$$m_{E,x} = n_y \\times n_z \\times 2 \\text{ 分量} \\times 8 \\frac{\\text{字节}}{\\text{分量}} = 128 \\times 128 \\times 2 \\times 8 = 262144 \\text{ 字节}$$\n- 发送给 $\\pm y$ 方向邻居的消息大小 ($m_{E,y}$): 面面积为 $n_x \\times n_z$。交换两个分量 ($E_x, E_z$) 。\n$$m_{E,y} = n_x \\times n_z \\times 2 \\times 8 = 128 \\times 128 \\times 2 \\times 8 = 262144 \\text{ 字节}$$\n- 发送给 $\\pm z$ 方向邻居的消息大小 ($m_{E,z}$): 面面积为 $n_x \\times n_y$。交换两个分量 ($E_x, E_y$) 。\n$$m_{E,z} = n_x \\times n_y \\times 2 \\times 8 = 128 \\times 128 \\times 2 \\times 8 = 262144 \\text{ 字节}$$\n磁场交换轮的消息大小 ($m_{H,x}, m_{H,y}, m_{H,z}$) 是相同的，因为分量的数量和面的维度是相同的。我们用 $m = 262144$ 字节表示这个公共的消息大小。\n\n每个时间步每个进程的总通信时间 $T_{\\text{total}}$ 是两轮时间之和。单条消息的时间由 $\\alpha$-$\\beta$ 模型给出：$T_{\\text{msg}} = \\alpha + \\beta m$。\n\n$E$ 场交换轮的时间 ($T_E$): 这一轮涉及发送 $6$ 条消息（每个邻居一条）。\n$$T_E = 2 \\times (\\alpha + \\beta m_{E,x}) + 2 \\times (\\alpha + \\beta m_{E,y}) + 2 \\times (\\alpha + \\beta m_{E,z})$$\n由于 $m_{E,x} = m_{E,y} = m_{E,z} = m$：\n$$T_E = 2(\\alpha + \\beta m) + 2(\\alpha + \\beta m) + 2(\\alpha + \\beta m) = 6(\\alpha + \\beta m)$$\n\n$H$ 场交换轮的时间 ($T_H$): 类似地，\n$$T_H = 6(\\alpha + \\beta m)$$\n\n总时间是两轮时间之和：\n$$T_{\\text{total}} = T_E + T_H = 6(\\alpha + \\beta m) + 6(\\alpha + \\beta m) = 12(\\alpha + \\beta m)$$\n\n现在，我们代入给定值：\n$\\alpha = 2 \\times 10^{-6}\\ \\mathrm{s}$\n$\\beta = 1 \\times 10^{-10}\\ \\mathrm{s}/\\text{字节}$\n$m = 262144\\ \\text{字节}$\n\n$$T_{\\text{total}} = 12 \\left( (2 \\times 10^{-6}) + (1 \\times 10^{-10}) \\times 262144 \\right)$$\n$$T_{\\text{total}} = 12 \\left( 2 \\times 10^{-6} + 2.62144 \\times 10^{-5} \\right)$$\n$$T_{\\text{total}} = 12 \\left( 0.2 \\times 10^{-5} + 2.62144 \\times 10^{-5} \\right)$$\n$$T_{\\text{total}} = 12 \\left( 2.82144 \\times 10^{-5} \\right)$$\n$$T_{\\text{total}} = 33.85728 \\times 10^{-5} \\ \\mathrm{s}$$\n$$T_{\\text{total}} = 0.0003385728 \\ \\mathrm{s}$$\n\n问题要求将最终答案四舍五入到四位有效数字。\n$$T_{\\text{total}} \\approx 0.0003386 \\ \\mathrm{s}$$\n\n这可以表示为科学记数法 $3.386 \\times 10^{-4}\\ \\mathrm{s}$。",
            "answer": "$$\\boxed{3.386 \\times 10^{-4}}$$"
        },
        {
            "introduction": "在为通信成本建模之后，下一个实际步骤是高效地实现数据交换。在结构化网格中，特别是在使用复杂模板或“结构数组”（AoS）内存布局时，光环数据在内存中通常是非连续的，这使得直接传输效率低下。本练习  将演示如何使用消息传递接口（MPI）的派生数据类型来为这些非连续数据创建“视图”，使其能够像单个数据块一样被打包和通信，这是编写高性能代码的一项关键技术。",
            "id": "3301714",
            "problem": "给定一个用于计算电磁学 (CEM) 的三维Yee网格离散化和一个分布式内存子域，该子域的光环交换必须在相邻进程之间移动不连续的边或面数据。考虑两种常见的场分量内存布局：结构数组 (AoS) 和数组结构 (SoA)。设基本标量类型为 IEEE-754 双精度，大小为 $s_T = 8$ 字节。在 AoS 布局中，每个网格单元以 $\\{E_x, E_y, E_z, H_x, H_y, H_z\\}$ 的固定顺序存储 $C$ 个分量，因此 $C = 6$，并使用行主序存储，其线性化元素索引为\n$$\n\\mathrm{idx}_{\\mathrm{AoS}}(i,j,k,c) \\;=\\; \\bigl( ((i \\cdot n_y) + j) \\cdot n_z + k \\bigr)\\cdot C + c,\n$$\n其中 $0 \\le i  n_x$，$0 \\le j  n_y$，$0 \\le k  n_z$ 且 $0 \\le c  C$。在 SoA 布局中，对于单个分量数组（例如，$E_x$），线性索引为\n$$\n\\mathrm{idx}_{\\mathrm{SoA}}(i,j,k) \\;=\\; i\\cdot (n_y n_z) + j \\cdot n_z + k.\n$$\n平面 $i=i_0$ 上的一个面光环需要打包一个 $y\\!-\\!z$ 平板，而沿坐标轴的边光环需要在固定的横向索引处打包一维单元线。用于非连续数据的一种典型的消息传递接口 (MPI) 派生数据类型是向量类型，由三元组 $(R,b,s)$ 表征，其中 $R$ 是重复计数，$b$ 是连续块长度（以基本类型 $T$ 为单位），而 $s$ 是连续块起始点之间的步长（以 $T$ 为单位）。块 $r$ 起始点的字节位移是 $d_r = (d_0 + r\\cdot s)\\cdot s_T$，而跨度（extent）（指类型中最低地址字节到最高地址字节加一的距离）是\n$$\n\\mathrm{extent} \\;=\\; \\bigl((R-1)\\cdot s + b\\bigr)\\cdot s_T.\n$$\n\n您的任务是，对于特定的光环选择，构建一个等效的 MPI 向量派生数据类型 $(R,b,s)$，该类型可以打包所需的不连续条目，并证明其相对于底层内存布局的跨度和字节对齐的正确性。您的程序必须为每个测试用例验证：\n\n- 从 $(R,b,s)$ 计算出的跨度与直接从所选元素的底层线性索引计算出的跨度相匹配。\n- 每个块的起始位移都是 $s_T$ 字节的倍数（对齐）。\n- 使用 $(R,b,s)$ 规范进行的线性打包所生成的有序值序列，与使用上述索引定义从底层数组直接按元素收集的序列完全相同。\n\n您必须从第一性原理出发：使用上面给出的行主序地址映射、在固定 $i=i_0$ 处的Yee网格面 $y\\!-\\!z$ 平板有 $n_y n_z$ 个单元的事实，以及在 AoS 布局中当按行主序扫描 $(j,k)$ 时从每个单元中选择分量索引的子集 $S$ 会产生每个单元长度为 $|S|$ 的连续小块且连续单元之间的步长为 $C$ 的事实。不要使用任何专门的 MPI 库；而是应显式计算索引和 $(R,b,s)$ 参数，并以算法方式验证它们。\n\n测试套件和要求的输出：\n\n- 测试用例 A (AoS, 面, 切向电场分量):\n  - 参数: $n_x=4$, $n_y=3$, $n_z=2$, $C=6$, $i_0 = n_x - 1$, 垂直于x轴的面的切向电场分量是 $E_y$ 和 $E_z$, 即 $S = \\{1,2\\}$。\n  - 要求的向量参数: $R = n_y n_z$, $b = |S|$, $s = C$。\n  - 程序必须检查打包后的序列是否与按行主序遍历 $(j,k)$ 且 $c \\in S$ 按升序排列的 $\\mathrm{idx}_{\\mathrm{AoS}}(i_0,j,k,c)$ 的直接收集结果相匹配。\n\n- 测试用例 B (SoA, 面, 连续分量平板):\n  - 参数: $n_x=4$, $n_y=3$, $n_z=2$, 仅 $E_x$ 分量, 面 $i_0 = 1$。\n  - 要求的向量参数: $R = 1$, $b = n_y n_z$, $s$ 为任意值 (当 $R=1$ 时无关紧要)。\n  - 程序必须检查打包结果是否等于按行主序遍历所有 $(j,k)$ 的 $\\mathrm{idx}_{\\mathrm{SoA}}(i_0,j,k)$ 的直接收集结果。\n\n- 测试用例 C (AoS, 沿x轴的边, 单个磁场分量):\n  - 参数: $n_x=5$, $n_y=1$, $n_z=4$, $C=6$, 位于 $(j_0,k_0)=(0,3)$ 沿x轴的边, 磁场分量 $H_y$ 的分量索引为 $c_0=4$。\n  - 要求的向量参数: $R = n_x$, $b = 1$, $s = n_y n_z C$。\n  - 程序必须检查打包结果是否等于按升序遍历 $i$ 的 $\\mathrm{idx}_{\\mathrm{AoS}}(i,j_0,k_0,c_0)$ 的直接收集结果。\n\n对于每个测试用例，程序必须返回一个布尔值，当且仅当所有三个验证（跨度相等、每个块起始点对齐以及精确的逐元素打包等效性）都通过时，该值为真。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[resultA,resultB,resultC]”）。\n\n所有答案都是纯布尔值；不需要物理单位。不涉及角度。\n\n您的最终程序必须是一个完整的、自包含的脚本，该脚本构建索引集和向量参数，为指定的测试套件执行上述验证，并按规定打印单行结果列表。",
            "solution": "该问题要求在使用三维Yee网格的分布式内存计算电磁学仿真中，验证用于打包非连续光环数据的消息传递接口 (MPI) 派生向量数据类型。必须针对三个特定的测试用例，以算法方式执行验证，涵盖结构数组 (AoS) 和数组结构 (SoA) 两种内存布局。任务的核心是确认所提供的向量数据类型参数 $(R, b, s)$ 能正确描述所需光环元素的内存布局。\n\n首先，我们确立内存索引和数据打包的基本原则。数据元素在内存中的位置由一个线性化索引确定，该索引将多维网格坐标映射到一维数组索引。对于维度为 $n_x \\times n_y \\times n_z$ 的网格，内存布局定义如下：\n\n在结构数组 (AoS) 布局中，单个网格单元的所有 $C$ 个场分量都连续存储。位于网格点 $(i,j,k)$ 的分量 $c$ 的线性内存索引由行主序公式给出：\n$$\n\\mathrm{idx}_{\\mathrm{AoS}}(i,j,k,c) \\;=\\; \\bigl( (i \\cdot n_y + j) \\cdot n_z + k \\bigr) \\cdot C + c\n$$\n其中项 $(i \\cdot n_y + j) \\cdot n_z + k$ 是单元的线性索引，$c$ 是该单元结构内特定分量的偏移量。索引范围为 $0 \\le i  n_x$，$0 \\le j  n_y$，$0 \\le k  n_z$ 且 $0 \\le c  C$。\n\n在数组结构 (SoA) 布局中，每个场分量都存储在一个单独的连续数组中。对于单个分量数组，网格点 $(i,j,k)$ 处元素的索引为：\n$$\n\\mathrm{idx}_{\\mathrm{SoA}}(i,j,k) \\;=\\; i \\cdot (n_y n_z) + j \\cdot n_z + k\n$$\n\nMPI 向量数据类型是描述由等间距块组成的非连续数据模式的强大工具。它由三元组 $(R,b,s)$ 定义：\n- $R$：重复计数，即块的数量。\n- $b$：块长度，即每个块中连续基本元素的数量。\n- $s$：步长，即从一个块的开始到下一个块的开始的距离，以基本元素大小为单位。\n\n相对于起始索引 $\\mathrm{idx}_{\\mathrm{start}}$，由这样一个向量描述的元素索引集可以通过以下公式生成：\n$$\n\\mathrm{idx}(r, \\beta) = \\mathrm{idx}_{\\mathrm{start}} + r \\cdot s + \\beta\n$$\n其中 $r \\in [0, R-1]$ 且 $\\beta \\in [0, b-1]$。\n\n验证过程包括对每个测试用例进行三项检查：\n1.  **打包等效性**：我们通过按规定顺序直接迭代指定的光环元素来生成一个索引列表（“直接收集”）。然后，我们使用给定的 $(R, b, s)$ 参数，从直接收集的第一个元素的索引开始，使用 MPI 风格的向量公式生成第二个索引列表。当且仅当这两个列表完全相同时，测试通过。\n2.  **跨度匹配**：数据类型的跨度是指从其最低地址字节到其最高地址字节加一的总内存范围。对于 MPI 向量，这由 $\\mathrm{extent}_{\\mathrm{MPI}} = \\bigl((R-1) \\cdot s + b\\bigr) \\cdot s_T$ 给出，其中 $s_T$ 是基本数据类型的大小（以字节为单位）。对于直接收集，跨度是从收集到的集合中找到的最小和最大索引计算得出的：$\\mathrm{extent}_{\\mathrm{direct}} = (\\mathrm{idx}_{\\mathrm{max}} - \\mathrm{idx}_{\\mathrm{min}} + 1) \\cdot s_T$。如果 $\\mathrm{extent}_{\\mathrm{MPI}} = \\mathrm{extent}_{\\mathrm{direct}}$，则测试通过。\n3.  **对齐**：此检查验证 $R$ 个块中每个块的起始地址是否为基本类型大小 $s_T$ 的倍数。块 $r$ 起始点的字节地址是 $(\\mathrm{idx}_{\\mathrm{start}} + r \\cdot s) \\cdot s_T$。由于所有项都是整数，因此该字节地址天然是 $s_T$ 的倍数。因此，此检查通过构造可正式满足。\n\n现在我们将此方法应用于每个测试用例。\n\n**测试用例 A (AoS, 面光环)**\n- 参数: $n_x=4$, $n_y=3$, $n_z=2$, $C=6$, $s_T=8$。位于 $i_0 = 3$ 的光环，包含分量 $S=\\{1,2\\}$。\n- 向量规格: $R = n_y n_z = 6$, $b = |S| = 2$, $s = C = 6$。\n光环由一个 $y-z$ 单元平板组成。按行主序，迭代 $(j,k)$ 会遍历内存中连续的单元。对于每个单元，切向分量 $E_y$ (索引 $c=1$) 和 $E_z$ (索引 $c=2$) 是连续的。这形成了一个长度为 $b=2$ 的块。一个单元数据的开始与下一个单元数据（例如，位于 $(i_0, j, k)$ 和 $(i_0, j, k+1)$ 的数据）开始之间的距离恰好是 $C$ 个元素。因此，步长 $s=C$ 是正确的。平板中的单元数量为 $n_y n_z$，所以重复计数为 $R=n_y n_z$。所提供的参数与内存布局一致。我们的算法验证将证实这一点。\n\n**测试用例 B (SoA, 面光环)**\n- 参数: $n_x=4$, $n_y=3$, $n_z=2$, $s_T=8$。位于 $i_0 = 1$ 的光环，用于单个分量数组。\n- 向量规格: $R = 1$, $b = n_y n_z = 6$。步长 $s$ 无关紧要。\n在 SoA 布局中，固定 $i_0$ 处的 $y-z$ 平板是一个连续的内存块。当 $(j,k)$ 按行主序变化时，索引 $\\mathrm{idx}_{\\mathrm{SoA}}(i_0, j, k) = i_0(n_y n_z) + j n_z + k$ 是连续的。因此，整个光环可以被描述为长度为 $b=n_y n_z$ 的单个块 ($R=1$)。参数是正确的。\n\n**测试用例 C (AoS, 边光环)**\n- 参数: $n_x=5$, $n_y=1$, $n_z=4$, $C=6$, $s_T=8$。位于 $(j_0,k_0)=(0,3)$ 的边，包含分量 $c_0=4$。\n- 向量规格: $R = n_x = 5$, $b = 1$, $s = n_y n_z C = 24$。\n光环由沿 x 方向一条线上的每个单元中的单个分量组成。我们每个单元打包一个元素，所以块长度为 $b=1$。重复是沿着 x 维度进行的，所以 $R=n_x$。步长是沿 x 轴的相邻单元中相同分量之间的距离，即 $(i, j_0, k_0)$ 和 $(i+1, j_0, k_0)$ 之间的距离。它们的线性单元索引之差为 $((i+1)n_y + j_0)n_z+k_0 - ((i \\cdot n_y + j_0)n_z+k_0) = n_y n_z$。由于每个单元结构的大小为 $C$，所以步长（以元素为单位）是 $s = n_y n_z C$。参数是一致的。\n\n提供的 Python 代码实现了 `verify_case` 函数，该函数为通用情况执行三项验证检查，然后将其应用于测试用例 A、B 和 C 的特定参数，并为每个用例报告一个布尔值。",
            "answer": "```python\nimport numpy as np\n\ndef verify_case(layout, params, halo_selection, vector_spec):\n    \"\"\"\n    Verifies the correctness of an MPI vector datatype for a given halo selection.\n    \n    Args:\n        layout (str): Memory layout, 'AoS' or 'SoA'.\n        params (dict): Grid and data type parameters (nx, ny, nz, C, sT).\n        halo_selection (dict): Description of the halo elements to pack.\n        vector_spec (dict): The MPI vector parameters (R, b, s) to validate.\n\n    Returns:\n        bool: True if all three validations (pack equivalence, extent, alignment) pass.\n    \"\"\"\n    # Unpack parameters\n    nx, ny, nz = params.get('nx'), params.get('ny'), params.get('nz')\n    sT = params.get('sT')\n    R, b, s = vector_spec['R'], vector_spec['b'], vector_spec['s']\n\n    # --- Step 1: Generate direct gather indices in the specified order ---\n    direct_indices = []\n    if layout == 'AoS':\n        C = params['C']\n        def idx_aos(i, j, k, c):\n            return (((i * ny) + j) * nz + k) * C + c\n        \n        selection_type = halo_selection['type']\n        if selection_type == 'face':\n            i0 = halo_selection['i0']\n            S = halo_selection['S']\n            for j in range(ny):\n                for k in range(nz):\n                    for c in sorted(S):\n                        direct_indices.append(idx_aos(i0, j, k, c))\n        elif selection_type == 'edge':\n            j0, k0 = halo_selection['j0'], halo_selection['k0']\n            c0 = halo_selection['c0']\n            for i in range(nx):\n                direct_indices.append(idx_aos(i, j0, k0, c0))\n    elif layout == 'SoA':\n        def idx_soa(i, j, k):\n            return i * (ny * nz) + j * nz + k\n\n        selection_type = halo_selection['type']\n        if selection_type == 'face':\n            i0 = halo_selection['i0']\n            for j in range(ny):\n                for k in range(nz):\n                    direct_indices.append(idx_soa(i0, j, k))\n    \n    if not direct_indices:\n        return False\n\n    # --- Step 2: Generate MPI-style pack indices ---\n    start_index = direct_indices[0]\n    pack_indices = []\n    for r in range(R):\n        block_start_index = start_index + r * s\n        for i in range(b):\n            pack_indices.append(block_start_index + i)\n            \n    # --- Step 3: Perform Verifications ---\n    \n    # Verification 1: Pack Equivalence\n    # Checks if the sequence of elements gathered matches the sequence from the vector type.\n    pack_equivalence_ok = (direct_indices == pack_indices)\n\n    # Verification 2: Extent Equality\n    # The MPI extent formula defines the span of the datatype in memory.\n    extent_mpi = ((R - 1) * s + b) * sT\n    \n    # The direct extent is the span from the first byte of the first selected element\n    # to the last byte of the last selected element.\n    idx_min = direct_indices[0]\n    idx_max = direct_indices[-1]\n    extent_direct = (idx_max - idx_min + 1) * sT\n    \n    extent_equality_ok = (extent_mpi == extent_direct)\n\n    # Verification 3: Alignment\n    # Checks if the start of each block is aligned to the primitive type size.\n    # This is formally true by construction but is checked explicitly.\n    alignment_ok = True\n    for r in range(R):\n        block_start_index = start_index + r * s\n        block_start_displacement_bytes = block_start_index * sT\n        if block_start_displacement_bytes % sT != 0:\n            alignment_ok = False\n            break\n\n    return pack_equivalence_ok and extent_equality_ok and alignment_ok\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define common parameters\n    sT = 8 # bytes for double precision\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            'name': 'A',\n            'layout': 'AoS',\n            'params': {'nx': 4, 'ny': 3, 'nz': 2, 'C': 6, 'sT': sT},\n            'halo_selection': {'type': 'face', 'i0': 4 - 1, 'S': {1, 2}},\n            'vector_spec': {'R': 3 * 2, 'b': 2, 's': 6}\n        },\n        {\n            'name': 'B',\n            'layout': 'SoA',\n            'params': {'nx': 4, 'ny': 3, 'nz': 2, 'sT': sT},\n            'halo_selection': {'type': 'face', 'i0': 1},\n            'vector_spec': {'R': 1, 'b': 3 * 2, 's': 3 * 2} # s is arbitrary when R=1\n        },\n        {\n            'name': 'C',\n            'layout': 'AoS',\n            'params': {'nx': 5, 'ny': 1, 'nz': 4, 'C': 6, 'sT': sT},\n            'halo_selection': {'type': 'edge', 'j0': 0, 'k0': 3, 'c0': 4},\n            'vector_spec': {'R': 5, 'b': 1, 's': 1 * 4 * 6}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = verify_case(\n            case['layout'],\n            case['params'],\n            case['halo_selection'],\n            case['vector_spec']\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "除了局部的光环交换，并行仿真通常还需要全局操作，例如对所有处理器上的能量或残差进行求和。本实践  探讨了在此过程中一个微妙但深刻的挑战：浮点加法不满足结合律，这可能导致结果因并行执行环境的不同而变化。通过分析一个精心挑选的例子，您将理解为何会失去按位可复现性，并学习如何使用稳健的求和技术来恢复它，这对于调试和验证大规模科学计算代码至关重要。",
            "id": "3301755",
            "problem": "在计算电磁学中，一个三维时域有限差分 (FDTD) 模拟在一个使用消息传递接口 (MPI) 的分布式内存集群上执行。在单个时间步，通过对一个有符号守恒残差（已归一化且无量纲）进行域求和来形成一个全局诊断量，该残差累加了各个局部进程的贡献。由于数值抵消和求和顺序的差异，全局和在不同的 MPI 归约树上可能会有所不同，因为浮点数加法不满足结合律。\n\n考虑三个 MPI 秩，其局部贡献以 IEEE 754 binary64（双精度）浮点格式存储如下：\n$$\nr_0 = 2^{54}, \\quad r_1 = 3, \\quad r_2 = -2^{54}.\n$$\n两种不同的 MPI 归约树被用来计算 $\\{r_0, r_1, r_2\\}$ 的全局和，两者都执行成对的浮点加法，并采用“舍入到最近，偶数优先”的规则：\n\n1. 树 A（左深）：计算 $$((r_0 + r_1) + r_2).$$\n2. 树 B（平衡）：计算 $$((r_0 + r_2) + r_1).$$\n\n从标准浮点模型以及单位舍入误差和给定数量级下可表示数间距的定义出发，推导出树 A 和树 B 产生的两个全局和，以及它们之间的绝对差。然后，设计一种归约方案，通过强制执行一个与进程数量和顺序无关的、数学上明确定义的求和结果，来保证全局诊断量在任意 MPI 归约树上的按位复现性。使用该方案，确定对于给定数据集 $\\{r_0, r_1, r_2\\}$ 的按位可复现的全局诊断量。\n\n将最终的诊断值表示为一个无量纲数。将您的最终答案四舍五入到四位有效数字。",
            "solution": "该问题分析了三个数 $r_0 = 2^{54}$, $r_1 = 3$, 和 $r_2 = -2^{54}$ 的求和，采用的是 IEEE 754 `binary64`（双精度）算术和“舍入到最近，偶数优先”的舍入模式。\n\n在 `binary64` 格式中，一个数用 $p = 53$ 位的有效数精度表示（一个隐含的前导位和 52 个显式的小数位）。单位舍入误差，或称机器ε，为 $\\varepsilon_{\\text{mach}} = 2^{1-p} = 2^{-52}$。可表示浮点数之间的间距，被称为末位单位 (ULP)，取决于数的大小。对于一个值接近 $2^E$ 的数 $x$，其 ULP 由 $\\text{ulp}(x) = 2^{E - (p-1)} = \\varepsilon_{\\text{mach}} \\cdot 2^E$ 给出。\n\n对于给定值 $r_0 = 2^{54}$，其指数为 $E=54$。在此范围内的 ULP 为：\n$$\n\\text{ulp}(2^{54}) = 2^{54 - (53-1)} = 2^{54-52} = 2^2 = 4\n$$\n这意味着在区间 $[2^{54}, 2^{54}+4)$ 内的任何实数只能表示为 $2^{54}$ 或 $2^{54}+4$。\n\n**树 A：左深归约 `((r_0 + r_1) + r_2)`**\n\n首先，我们计算中间和 $S_{A1} = fl(r_0 + r_1)$，其中 $fl(\\cdot)$ 表示浮点求值。\n$$\nS_{A1} = fl(2^{54} + 3)\n$$\n精确结果是 $2^{54} + 3$。这个值在 `binary64` 格式中无法精确表示，因为在 $2^{54}$ 附近的可表示数是 $\\text{ulp}(2^{54}) = 4$ 的整数倍。包围精确和的两个机器可表示数是 $N_1 = 2^{54}$ 和 $N_2 = 2^{54} + 4$。\n\n为了应用“舍入到最近”规则，我们计算到这两个数的距离：\n- 到 $N_1$ 的距离：$|(2^{54} + 3) - 2^{54}| = 3$\n- 到 $N_2$ 的距离：$|(2^{54} + 3) - (2^{54} + 4)| = |-1| = 1$\n\n由于精确结果更接近 $N_2$，和被向上舍入。这种一个小数与一个大数相加时被“淹没”的现象，被称为大数吞噬（swamping）。\n$$\nS_{A1} = 2^{54} + 4\n$$\n接下来，我们计算树 A 的最终和 $S_A = fl(S_{A1} + r_2)$：\n$$\nS_A = fl((2^{54} + 4) + (-2^{54}))\n$$\n$fl(\\cdot)$ 的参数恰好是 $4$。由于 $4$ ($=1.0 \\times 2^2$) 在 `binary64` 格式中可以精确表示，因此不需要进行舍入。\n$$\nS_A = 4\n$$\n\n**树 B：平衡归约 `((r_0 + r_2) + r_1)`**\n\n首先，我们计算中间和 $S_{B1} = fl(r_0 + r_2)$：\n$$\nS_{B1} = fl(2^{54} + (-2^{54})) = fl(0)\n$$\n$2^{54}$ 和 $-2^{54}$ 都能精确表示，它们的和恰好是 $0$，而 $0$ 也能精确表示。这个操作导致了灾难性抵消，但在这一特定情况下，结果是精确的。\n$$\nS_{B1} = 0\n$$\n接下来，我们计算树 B 的最终和 $S_B = fl(S_{B1} + r_1)$：\n$$\nS_B = fl(0 + 3)\n$$\n数字 $3$ 在 `binary64` 格式中也能精确表示 ($3 = 1.5 \\times 2^1$)。因此，和是精确的。\n$$\nS_B = 3\n$$\n\n**树 A 和树 B 之间的差异**\n\n两个计算出的全局和之间的绝对差是：\n$$\n|S_A - S_B| = |4 - 3| = 1\n$$\n这种差异是浮点数加法不满足结合律的直接后果。\n\n**可复现归约方案的设计**\n\n为了保证按位复现性，归约方案必须产生一个与求和顺序和进程数量无关的结果。这需要强制执行一个数学上明确定义的结果。理想的结果是所有贡献值的精确数学和。\n\n所设计的方案是一种 **精确求和算法**。此类算法通过使用“超级累加器”来避免中间舍入误差，该累加器是一种能够精确表示浮点数之和的数据结构。这一概念的一个常见实现方式是将和表示为一系列未求值的、不重叠的浮点数（一种浮点数展开）。当添加一个新数时，它被并入这个展开式中，没有任何精度损失。最终的浮点结果是在最后对存储在超级累加器中的精确和仅进行一次舍入而获得的。\n\n这种方法确保了底层算术在效果上满足结合律和交换律，从而使最终的和与归约树结构（即操作顺序）无关。由 D. E. Knuth、M. J. D. Powell、T. J. Dekker 以及近代的 Jonathan Shewchuk 开发的算法提供了这一原理的实际实现。Python 的 `math.fsum` 函数是此类算法的一个著名例子。\n\n**可复现方案的应用**\n\n将此方案应用于给定的数据集 $\\{r_0, r_1, r_2\\}$，就是要计算其真实的数学和。精确求和算法就其本质而言，将会得出这个结果。\n$$\nS_{\\text{reproducible}} = r_0 + r_1 + r_2 = 2^{54} + 3 + (-2^{54}) = 3\n$$\n这个结果与 $r_0$、$r_1$ 和 $r_2$ 的累加顺序无关。因此，按位可复현的全局诊断量是 $3$。\n\n问题要求将此最终诊断值四舍五入到四位有效数字。数字 $3$ 写成四位有效数字是 $3.000$。",
            "answer": "$$\n\\boxed{3.000}\n$$"
        }
    ]
}