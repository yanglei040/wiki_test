{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的优化算法之前，我们首先需要建立一个坚实的理论基础，即理解目标泛函如何随形状的变化而变化。哈达玛（Hadamard）边界积分公式为我们提供了这样一个强大的数学工具，它将泛函的变化与形状边界的法向速度场直接联系起来。通过这个练习，你将从第一性原理出发，为一个简化的物理模型（玻恩近似）推导出形状导数，并通过数值方法验证你的理论结果，从而在理论和实践之间建立起一座桥梁。",
            "id": "3323745",
            "problem": "您的任务是推导并实现一个用于计算电磁学的数据失配泛函的形状导数的阿达马边界积分表示，该表示通过水平集公式表达。\n\n考虑一个二维时谐电磁学背景，在第一次玻恩近似下，一个紧致包含域 $D \\subset \\mathbb{R}^2$ 的远场模式由以下公式建模：\n$$\nF_D(\\hat{\\mathbf{x}}) \\;=\\; k^2 \\chi \\int_{D} e^{i k (\\mathbf{d}-\\hat{\\mathbf{x}})\\cdot \\mathbf{y}} \\, d\\mathbf{y},\n$$\n其中 $k$ 是波数，$\\chi$ 是一个恒定的对比度参数，$\\mathbf{d}$ 是单位入射方向，$\\hat{\\mathbf{x}} \\in \\mathbb{S}^1$ 是观测方向。设方向 $\\{\\hat{\\mathbf{x}}_m\\}_{m=1}^M$ 上的测量数据为 $\\{d_m\\}_{m=1}^M$，并定义最小二乘失配为\n$$\nJ(D) \\;=\\; \\tfrac{1}{2} \\sum_{m=1}^{M} \\alpha_m \\,\\big| F_D(\\hat{\\mathbf{x}}_m) - d_m \\big|^2,\n$$\n其中 $\\{\\alpha_m\\}$ 为正权重。\n\n边界演化由边界 $\\partial D$ 上的法向速度场 $\\mathbf{V}(\\mathbf{y}) = V_n(\\mathbf{y}) \\,\\mathbf{n}(\\mathbf{y})$ 驱动，该速度场由满足 Hamilton–Jacobi 方程的水平集函数 $\\phi$ 编码：\n$$\n\\partial_t \\phi + V_n \\, |\\nabla \\phi| = 0.\n$$\n\n您的任务是：\n\n$1.$ 从域积分的雷诺输运定理和复数据实值泛函的链式法则出发，推导形状导数的阿达马边界积分表示：\n$$\ndJ(D)[\\mathbf{V}] \\;=\\; \\int_{\\partial D} V_n(\\mathbf{y}) \\, G(\\mathbf{y}) \\, ds(\\mathbf{y}),\n$$\n并根据残差 $z_m = F_D(\\hat{\\mathbf{x}}_m) - d_m$ 和函数 $f_m(\\mathbf{y}) = k^2 \\chi \\, e^{i k (\\mathbf{d}-\\hat{\\mathbf{x}}_m)\\cdot \\mathbf{y}}$，给出边界被积函数 $G(\\mathbf{y})$ 的显式公式。\n\n$2.$ 实现推导出的 $G(\\mathbf{y})$ 的边界积分，并通过将 $dJ(D)[\\mathbf{V}]$ 与针对精心选择的速度场 $V_n$ 和域 $D$ 的微扰的方向导数的有限差分近似进行比较，来对其进行数值验证。使用以下具体设置：\n\n- 使用 $k = 8$ (无量纲)，$\\chi = 1$，入射方向 $\\mathbf{d} = (1,0)$。\n- 使用 $M = 16$ 个观测方向 $\\hat{\\mathbf{x}}_m = (\\cos \\theta_m, \\sin \\theta_m)$，其中 $\\theta_m = 2\\pi m/M$，单位为弧度。\n- 将真实域 $D^\\star$ 定义为一个中心在 $\\mathbf{c}^\\star = (0.1, -0.05)$、半轴为 $a^\\star=0.6$ 和 $b^\\star=0.3$ 的椭圆。测量数据由 $d_m = F_{D^\\star}(\\hat{\\mathbf{x}}_m)$ 使用相同的玻恩模型生成。\n- 将用于计算 $J$ 及其形状导数的当前（测试）域 $D$ 定义为一个中心在 $\\mathbf{c}=(0,0)$、半径为 $R=0.4$ 的圆盘。\n- 使用解析公式计算积分 $\\int_D e^{i k \\mathbf{q}\\cdot \\mathbf{y}}\\, d\\mathbf{y}$ 来计算 $F_D(\\hat{\\mathbf{x}}_m)$：\n  - 对于中心在 $\\mathbf{c}$、半径为 $R$ 的圆盘，其中 $\\mathbf{q}=\\mathbf{d}-\\hat{\\mathbf{x}}$，使用\n    $$\n    \\int_{|\\mathbf{y}-\\mathbf{c}|\\le R} e^{i k \\mathbf{q}\\cdot \\mathbf{y}} \\, d\\mathbf{y}\n    \\;=\\;\n    e^{i k \\mathbf{q}\\cdot \\mathbf{c}} \\, \\frac{2\\pi R}{k\\|\\mathbf{q}\\|} J_1\\!\\big(k \\|\\mathbf{q}\\| R\\big),\n    $$\n    当 $\\|\\mathbf{q}\\|=0$ 时，极限值为 $\\pi R^2$。\n  - 对于中心在 $\\mathbf{c}$、半轴 $a,b$与坐标轴对齐的椭圆，记 $\\mathbf{S}=\\mathrm{diag}(a,b)$ 并使用\n    $$\n    \\int_{\\mathbf{y}:\\;(\\tfrac{y_x-c_x}{a})^2 + (\\tfrac{y_y-c_y}{b})^2 \\le 1} e^{i k \\mathbf{q}\\cdot \\mathbf{y}} \\, d\\mathbf{y}\n    \\;=\\;\n    e^{i k \\mathbf{q}\\cdot \\mathbf{c}} \\, \\frac{2\\pi a b}{k \\|\\mathbf{S}^T \\mathbf{q}\\|} J_1\\!\\big(k \\|\\mathbf{S}^T \\mathbf{q}\\|\\big),\n    $$\n    当 $\\|\\mathbf{S}^T \\mathbf{q}\\|=0$ 时，极限值为 $\\pi a b$。这里 $J_1$ 是第一类1阶贝塞尔函数。\n\n- 使用推导出的边界被积函数 $G(\\mathbf{y})$ 并通过以下三个测试验证阿达马公式。所有角度均以弧度为单位，所有最终报告的量均为无量纲浮点数：\n\n  - 测试A（圆盘的均匀法向扩展）：在 $\\partial D$ 上选择 $V_n(\\mathbf{y}) \\equiv 1$。通过边界积分计算预测的形状导数 $dJ(D)[\\mathbf{V}]$。将其与使用半径为 $R+\\varepsilon$ 的圆盘的精确已知微扰成本 $J$ 的方向导数的有限差分近似进行比较，其中 $\\varepsilon = 10^{-6}$。报告相对误差 $\\big|dJ_{\\text{pred}} - dJ_{\\text{fd}}\\big| / \\max\\{ |dJ_{\\text{fd}}|, 10^{-12} \\}$。\n\n  - 测试B（圆盘的刚性平移）：选择平移向量 $\\mathbf{t}=(0.02,-0.01)$ 并取 $V_n(\\mathbf{y}) = \\mathbf{t}\\cdot \\mathbf{n}(\\mathbf{y})$ on $\\partial D$。通过边界积分计算 $dJ(D)[\\mathbf{V}]$。将其与使用平移到中心 $\\mathbf{c}+\\varepsilon \\mathbf{t}$ 的圆盘的精确已知微扰成本 $J$ 的有限差分近似进行比较，其中 $\\varepsilon = 10^{-6}$。同样报告如测试A中定义的相对误差。\n\n  - 测试C（零残差边缘情况）：将当前域 $D$ 设置为等于真实椭圆域 $D^\\star$，并计算 $\\partial D$ 上的边界被积函数 $G(\\mathbf{y})$。使用椭圆边界的均匀角度参数化，报告 $\\max_{\\mathbf{y}\\in \\partial D} |G(\\mathbf{y})|$。该值应接近于零。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表的结果（例如，$[r_A,r_B,r_C]$），其中 $r_A$ 是测试A的浮点数，$r_B$ 是测试B的浮点数，$r_C$ 是测试C的浮点数。角度必须以弧度为单位进行解释。输出中不需要物理单位。所有积分和运算都必须以数学上一致且数值上稳定的方式计算。",
            "solution": "目标是推导最小二乘数据失配泛函 $J(D)$ 的形状导数的边界被积函数 $G(\\mathbf{y})$ 的显式形式，并对结果进行数值验证。此过程分为两个主要部分：解析推导和数值实现。\n\n### 第1部分：边界被积函数 $G(\\mathbf{y})$ 的推导\n\n分析始于数据失配泛函 $J(D)$，其定义为：\n$$\nJ(D) \\;=\\; \\tfrac{1}{2} \\sum_{m=1}^{M} \\alpha_m \\,\\big| F_D(\\hat{\\mathbf{x}}_m) - d_m \\big|^2\n$$\n其中 $\\{d_m\\}_{m=1}^M$ 是测量的远场数据，$\\{\\alpha_m\\}$ 是正权重，$F_D(\\hat{\\mathbf{x}}_m)$ 是域 $D$ 的建模远场模式。建模数据由一个域积分给出：\n$$\nF_D(\\hat{\\mathbf{x}}_m) \\;=\\; \\int_{D} f_m(\\mathbf{y}) \\, d\\mathbf{y}, \\quad \\text{with} \\quad f_m(\\mathbf{y}) = k^2 \\chi \\, e^{i k (\\mathbf{d}-\\hat{\\mathbf{x}}_m)\\cdot \\mathbf{y}}\n$$\n令 $z_m(D) = F_D(\\hat{\\mathbf{x}}_m) - d_m$ 为第 $m$ 次观测的复值残差。该泛函可以写为 $J(D) = \\frac{1}{2} \\sum_{m=1}^{M} \\alpha_m |z_m(D)|^2 = \\frac{1}{2} \\sum_{m=1}^{M} \\alpha_m z_m(D) \\overline{z_m(D)}$。\n\n$J(D)$ 在边界 $\\partial D$ 上的法向速度场 $\\mathbf{V}(\\mathbf{y}) = V_n(\\mathbf{y})\\mathbf{n}(\\mathbf{y})$ 方向上的形状导数由 $dJ(D)[\\mathbf{V}]$ 给出。我们应用复变量实值泛函的微分链式法则：\n$$\ndJ(D)[\\mathbf{V}] = \\frac{d}{d\\tau} \\left. J(D_\\tau) \\right|_{\\tau=0}\n$$\n其中 $D_\\tau$ 是沿速度场 $\\mathbf{V}$ 微扰后的域 $D$。使用乘法法则，和式中每一项的导数为：\n$$\n\\frac{d}{d\\tau} \\left( z_m(D_\\tau) \\overline{z_m(D_\\tau)} \\right) = \\frac{dz_m}{d\\tau} \\overline{z_m} + z_m \\frac{d\\overline{z_m}}{d\\tau} = 2 \\, \\text{Re} \\left( \\frac{dz_m}{d\\tau} \\overline{z_m} \\right)\n$$\n导数在 $\\tau=0$ 处求值。残差的导数为 $dz_m/d\\tau = dF_D(\\hat{\\mathbf{x}}_m)[\\mathbf{V}]$，因为测量数据 $d_m$ 相对于域的形状是恒定的。对所有 $m$ 求和，我们得到：\n$$\ndJ(D)[\\mathbf{V}] \\;=\\; \\sum_{m=1}^{M} \\alpha_m \\, \\text{Re} \\left( dF_D(\\hat{\\mathbf{x}}_m)[\\mathbf{V}] \\cdot \\overline{z_m(D)} \\right)\n$$\n接下来，我们求远场模式 $F_D(\\hat{\\mathbf{x}}_m)$ 的形状导数。根据雷诺输运定理（或者更具体地说，域积分的阿达马结构定理），对于一个具有光滑被积函数 $f_m$ 的域 $D$ 上的积分，其导数为：\n$$\ndF_D(\\hat{\\mathbf{x}}_m)[\\mathbf{V}] = \\frac{d}{d\\tau} \\left. \\int_{D_\\tau} f_m(\\mathbf{y}) \\, d\\mathbf{y} \\right|_{\\tau=0} = \\int_{\\partial D} f_m(\\mathbf{y}) (\\mathbf{V}(\\mathbf{y}) \\cdot \\mathbf{n}(\\mathbf{y})) \\, ds(\\mathbf{y})\n$$\n鉴于 $\\mathbf{V}(\\mathbf{y}) = V_n(\\mathbf{y})\\mathbf{n}(\\mathbf{y})$，点积简化为 $\\mathbf{V}\\cdot\\mathbf{n} = V_n$。因此：\n$$\ndF_D(\\hat{\\mathbf{x}}_m)[\\mathbf{V}] = \\int_{\\partial D} V_n(\\mathbf{y}) f_m(\\mathbf{y}) \\, ds(\\mathbf{y})\n$$\n将此积分表示代回到 $dJ(D)[\\mathbf{V}]$ 的表达式中：\n$$\ndJ(D)[\\mathbf{V}] \\;=\\; \\sum_{m=1}^{M} \\alpha_m \\, \\text{Re} \\left( \\left( \\int_{\\partial D} V_n(\\mathbf{y}) f_m(\\mathbf{y}) \\, ds(\\mathbf{y}) \\right) \\overline{z_m(D)} \\right)\n$$\n由于 $\\overline{z_m(D)}$ 相对于积分变量 $\\mathbf{y}$ 是常数，且 $V_n(\\mathbf{y})$ 是实数，我们可以将求和及实部算子移入积分内部：\n$$\ndJ(D)[\\mathbf{V}] \\;=\\; \\int_{\\partial D} V_n(\\mathbf{y}) \\left( \\sum_{m=1}^{M} \\alpha_m \\, \\text{Re} \\left( f_m(\\mathbf{y}) \\overline{z_m(D)} \\right) \\right) ds(\\mathbf{y})\n$$\n该表达式具有所期望的阿达马边界积分形式 $dJ(D)[\\mathbf{V}] = \\int_{\\partial D} V_n(\\mathbf{y}) G(\\mathbf{y}) \\, ds(\\mathbf{y})$。通过直接比较，我们确定边界被积函数 $G(\\mathbf{y})$ 为：\n$$\nG(\\mathbf{y}) \\;=\\; \\sum_{m=1}^{M} \\alpha_m \\, \\text{Re} \\left( f_m(\\mathbf{y}) \\overline{z_m(D)} \\right)\n$$\n代入 $f_m$ 和 $z_m$ 的定义，边界被积函数的显式公式为：\n$$\nG(\\mathbf{y}) \\;=\\; \\text{Re} \\left( \\sum_{m=1}^{M} \\alpha_m \\left( k^2 \\chi \\, e^{i k (\\mathbf{d}-\\hat{\\mathbf{x}}_m)\\cdot \\mathbf{y}} \\right) \\overline{\\left( F_D(\\hat{\\mathbf{x}}_m) - d_m \\right)} \\right)\n$$\n此公式提供了成本泛函 $J(D)$ 对其边界 $\\partial D$ 上每一点 $\\mathbf{y} \\in \\partial D$ 的法向微扰的敏感度。\n\n### 第2部分：数值验证计划\n\n对推导出的 $G(\\mathbf{y})$ 公式进行实现，并通过与三个特定测试案例的有限差分近似进行比较来验证。对于数值测试，所有 $m$ 的权重均设置为 $\\alpha_m=1$。\n\n**测试A（均匀扩展）：** 速度为 $V_n(\\mathbf{y})=1$。预测导数 $dJ_{\\text{pred}} = \\int_{\\partial D} G(\\mathbf{y}) \\, ds(\\mathbf{y})$ 通过数值积分计算。将其与有限差分近似 $dJ_{\\text{fd}} = (J(D_{R+\\varepsilon}) - J(D_R))/\\varepsilon$ 进行比较，其中 $D_R$ 是半径为 $R$ 的初始圆盘，$D_{R+\\varepsilon}$ 是半径为 $R+\\varepsilon$ 的圆盘。\n\n**测试B（刚性平移）：** 速度对应于向量 $\\mathbf{t}$ 的刚性平移，因此 $V_n(\\mathbf{y}) = \\mathbf{t} \\cdot \\mathbf{n}(\\mathbf{y})$。计算预测导数 $dJ_{\\text{pred}} = \\int_{\\partial D} (\\mathbf{t} \\cdot \\mathbf{n}(\\mathbf{y})) G(\\mathbf{y}) \\, ds(\\mathbf{y})$ 并将其与 $dJ_{\\text{fd}} = (J(D_{\\mathbf{c}+\\varepsilon\\mathbf{t}}) - J(D_\\mathbf{c}))/\\varepsilon$ 进行比较，其中圆盘的中心从 $\\mathbf{c}$ 平移到 $\\mathbf{c}+\\varepsilon\\mathbf{t}$。\n\n**测试C（零残差情况）：** 测试域 $D$ 设置为真实域 $D^\\star$。在这种理想情况下，残差 $z_m = F_{D^\\star}(\\hat{\\mathbf{x}}_m) - d_m$ 为零。因此，边界被积函数 $G(\\mathbf{y})$ 在 $\\partial D^\\star$ 上也应处处为零。数值测试计算 $\\max_{\\mathbf{y}\\in \\partial D^\\star} |G(\\mathbf{y})|$ 以验证其接近机器精度零。\n\n数值实现使用了所提供的关于圆盘和椭圆域上远场积分的解析公式，其中涉及贝塞尔函数 $J_1(x)$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import j1\n\ndef solve():\n    \"\"\"\n    Derives and implements the Hadamard boundary integral for a shape derivative\n    in computational electromagnetics and verifies it numerically.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    k = 8.0\n    chi = 1.0\n    d_inc = np.array([1.0, 0.0])\n    M = 16\n    a_m = 1.0  # Weights alpha_m\n    epsilon = 1e-6\n\n    # --- Observation Directions ---\n    m_indices = np.arange(1, M + 1)\n    thetas_obs = 2 * np.pi * m_indices / M\n    obs_dirs = np.stack((np.cos(thetas_obs), np.sin(thetas_obs)), axis=-1)\n\n    # --- Domain Definitions ---\n    # True domain D_star (ellipse)\n    c_star = np.array([0.1, -0.05])\n    a_star, b_star = 0.6, 0.3\n    \n    # Current domain D (disk) for Tests A and B\n    c_disk = np.array([0.0, 0.0])\n    R_disk = 0.4\n\n    # --- Helper Functions ---\n\n    def domain_integral(q_unscaled, center, shape, params):\n        \"\"\"\n        Computes the integral of exp(i * k * q_unscaled . y) over a domain.\n        q_unscaled is (d - x_hat).\n        \"\"\"\n        if shape == 'disk':\n            R = params['R']\n            q_norm = np.linalg.norm(q_unscaled)\n            if q_norm  1e-12:\n                return np.pi * R**2\n            \n            exp_term = np.exp(1j * k * np.dot(q_unscaled, center))\n            bessel_arg = k * q_norm * R\n            val = exp_term * (2 * np.pi * R / (k * q_norm)) * j1(bessel_arg)\n            return val\n\n        elif shape == 'ellipse':\n            a, b = params['a'], params['b']\n            S = np.diag([a, b])\n            St_q = S.T @ q_unscaled\n            St_q_norm = np.linalg.norm(St_q)\n            if St_q_norm  1e-12:\n                return np.pi * a * b\n            \n            exp_term = np.exp(1j * k * np.dot(q_unscaled, center))\n            bessel_arg = k * St_q_norm\n            val = exp_term * (2 * np.pi * a * b / bessel_arg) * j1(bessel_arg)\n            return val\n        else:\n            raise ValueError(\"Unknown shape\")\n\n    def compute_far_field(obs_dirs_list, center, shape, params):\n        \"\"\"Computes the far-field pattern F_D for a list of observation directions.\"\"\"\n        F_D_vals = np.zeros(len(obs_dirs_list), dtype=np.complex128)\n        for i, x_hat in enumerate(obs_dirs_list):\n            q_unscaled = d_inc - x_hat\n            integral_val = domain_integral(q_unscaled, center, shape, params)\n            F_D_vals[i] = (k**2 * chi) * integral_val\n        return F_D_vals\n\n    def cost_functional_J(F_D, d_measured):\n        \"\"\"Computes the least-squares cost functional J.\"\"\"\n        residuals = F_D - d_measured\n        return 0.5 * np.sum(a_m * np.abs(residuals)**2)\n\n    # --- Main Calculation ---\n    \n    # 1. Generate measured data d_m from the true domain D_star\n    d_measured = compute_far_field(obs_dirs, c_star, 'ellipse', {'a': a_star, 'b': b_star})\n    \n    # 2. Compute F_D and residuals for the current domain D (disk)\n    F_D_disk = compute_far_field(obs_dirs, c_disk, 'disk', {'R': R_disk})\n    residuals = F_D_disk - d_measured\n\n    # 3. Setup for boundary integrals (common for Test A and B)\n    N_bnd = 1000  # Number of points for boundary discretization\n    theta_bnd = np.linspace(0, 2 * np.pi, N_bnd, endpoint=False)\n    y_bnd = R_disk * np.stack((np.cos(theta_bnd), np.sin(theta_bnd)), axis=-1)\n    \n    q_unscaled_vecs = d_inc - obs_dirs\n    # f_m(y) = k^2 * chi * exp(i * k * (d-x_m).y)\n    # Shape: (M, N_bnd)\n    fm_on_bnd = (k**2 * chi) * np.exp(1j * k * (q_unscaled_vecs @ y_bnd.T))\n\n    # G(y) = Re(sum_m a_m * f_m(y) * conj(z_m))\n    # Shape: (N_bnd,)\n    G_y = np.real(np.sum(a_m * fm_on_bnd.T * np.conj(residuals), axis=1))\n    \n    # --- Test A: Uniform Expansion ---\n    Vn_A = 1.0\n    ds_A = R_disk * (2 * np.pi / N_bnd) # for uniform theta sampling\n    dJ_pred_A = np.sum(Vn_A * G_y * ds_A)\n    \n    J_D = cost_functional_J(F_D_disk, d_measured)\n    F_D_eps_A = compute_far_field(obs_dirs, c_disk, 'disk', {'R': R_disk + epsilon})\n    J_D_eps_A = cost_functional_J(F_D_eps_A, d_measured)\n    dJ_fd_A = (J_D_eps_A - J_D) / epsilon\n    \n    rel_error_A = np.abs(dJ_pred_A - dJ_fd_A) / np.maximum(np.abs(dJ_fd_A), 1e-12)\n\n    # --- Test B: Rigid Translation ---\n    t_vec = np.array([0.02, -0.01])\n    normals_bnd = y_bnd / R_disk\n    Vn_B = normals_bnd @ t_vec\n    ds_B = R_disk * (2 * np.pi / N_bnd)\n    dJ_pred_B = np.sum(Vn_B * G_y * ds_B)\n    \n    F_D_eps_B = compute_far_field(obs_dirs, c_disk + epsilon * t_vec, 'disk', {'R': R_disk})\n    J_D_eps_B = cost_functional_J(F_D_eps_B, d_measured)\n    dJ_fd_B = (J_D_eps_B - J_D) / epsilon\n    \n    rel_error_B = np.abs(dJ_pred_B - dJ_fd_B) / np.maximum(np.abs(dJ_fd_B), 1e-12)\n\n    # --- Test C: Zero-Residual Edge Case ---\n    # Current domain D is now D_star\n    F_D_star = compute_far_field(obs_dirs, c_star, 'ellipse', {'a': a_star, 'b': b_star})\n    residuals_C = F_D_star - d_measured  # Should be near machine precision zero\n\n    # Evaluate G(y) on the ellipse boundary\n    theta_bnd_ellipse = np.linspace(0, 2 * np.pi, N_bnd, endpoint=False)\n    y_bnd_ellipse_x = c_star[0] + a_star * np.cos(theta_bnd_ellipse)\n    y_bnd_ellipse_y = c_star[1] + b_star * np.sin(theta_bnd_ellipse)\n    y_bnd_ellipse = np.stack((y_bnd_ellipse_x, y_bnd_ellipse_y), axis=-1)\n    \n    fm_on_bnd_ellipse = (k**2 * chi) * np.exp(1j * k * (q_unscaled_vecs @ y_bnd_ellipse.T))\n    G_y_ellipse = np.real(np.sum(a_m * fm_on_bnd_ellipse.T * np.conj(residuals_C), axis=1))\n\n    max_G_C = np.max(np.abs(G_y_ellipse))\n\n    # --- Final Output ---\n    results = [rel_error_A, rel_error_B, max_G_C]\n    print(f\"[{','.join(f'{r:.10e}' for r in results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "掌握了形状导数的基本概念后，下一步是为实际的电磁逆问题计算这一导数。在处理由偏微分方程约束的大规模优化问题时，伴随状态法（Adjoint-State Method）是一种最高效的梯度计算策略。本实践将指导你应用伴随状态法，推导并实现一个完整的工作流程：从亥姆霍兹方程描述的物理模型出发，计算数据失配泛函相对于介电常数分布的梯度，并最终通过链式法则得到关于水平集函数的梯度。这是执行基于梯度的形状优化的核心技能。",
            "id": "3323749",
            "problem": "本题要求您在一个由计算电磁学启发的标量频域模型中，为一个分段常数相对介电常数的水平集参数化推导、实现并评估其伴随态梯度组装。目标是通过最小化模拟场和观测场之间的数据失配来重建嵌入在均匀背景中的一个嵌入体的形状，其中使用伴随态方法来获得关于水平集函数的梯度。\n\n请从以下基本要素开始。\n\n1) 控制方程和域。考虑在单位正方形域上、具有齐次狄利克雷边界条件的标量频域模型。设内部网格大小为 $N \\times N$，网格间距为 $h = \\frac{1}{N+1}$。设未知复标量场为 $u:\\Omega \\to \\mathbb{C}$，由以下线性偏微分方程控制\n$$\n-\\Delta u(\\mathbf{x}) - k_0^2 \\, \\varepsilon_r(\\mathbf{x}) \\, u(\\mathbf{x}) + i \\, \\tau \\, u(\\mathbf{x}) = f(\\mathbf{x}),\n$$\n其中 $\\mathbf{x}=(x,y)\\in \\Omega=(0,1)\\times(0,1)$，$\\Delta$ 是拉普拉斯算子，$k_0$ 是给定的自由空间波数，$\\varepsilon_r(\\mathbf{x})$ 是空间变化的相对介电常数，$i$ 是虚数单位，$\\tau0$ 是一个小的吸收参数，$f$ 是一个点源。齐次狄利克雷边界条件强制在 $\\partial \\Omega$ 上 $u=0$。\n\n2) 数据失配。有 $M$ 个探测器位于内部网格点 $\\{\\mathbf{x}_m\\}_{m=1}^M$。将预测数据向量 $\\mathbf{d}_{\\mathrm{pred}}\\in\\mathbb{C}^M$ 定义为 $u$ 在这些探测器点上的采样，并设一个观测数据向量 $\\mathbf{d}_{\\mathrm{obs}}\\in\\mathbb{C}^M$。目标泛函是最小二乘数据失配\n$$\nJ(u) = \\tfrac{1}{2} \\sum_{m=1}^M \\left| u(\\mathbf{x}_m) - d_{\\mathrm{obs},m} \\right|^2.\n$$\n\n3) 介电常数的水平集参数化。引入一个水平集函数 $\\phi:\\Omega\\to\\mathbb{R}$，使得嵌入体是 $\\phi(\\mathbf{x}) > 0$ 的区域。相对介电常数通过一个平滑的亥维赛德函数 $H_\\beta$ 参数化为一个两相介质：\n$$\n\\varepsilon_r(\\mathbf{x}) = \\varepsilon_{\\text{out}} + \\left(\\varepsilon_{\\text{in}} - \\varepsilon_{\\text{out}}\\right) H_\\beta\\!\\left(\\phi(\\mathbf{x})\\right),\n$$\n其中 $\\varepsilon_{\\text{in}}$ 和 $\\varepsilon_{\\text{out}}$ 是常数。宽度参数为 $\\beta0$ 的平滑亥维赛德函数 $H_\\beta$ 定义为\n$$\nH_\\beta(s) = \n\\begin{cases}\n0,   s \\le -\\beta,\\\\\n\\tfrac{1}{2}\\left(1 + \\tfrac{s}{\\beta} + \\tfrac{1}{\\pi}\\sin\\left(\\tfrac{\\pi s}{\\beta}\\right)\\right),   |s|  \\beta,\\\\\n1,   s \\ge \\beta.\n\\end{cases}\n$$\n其导数是平滑的狄拉克δ函数\n$$\n\\delta_\\beta(s) = H_\\beta'(s) =\n\\begin{cases}\n0,  |s|\\ge\\beta,\\\\\n\\tfrac{1}{2\\beta}\\left(1 + \\cos\\left(\\tfrac{\\pi s}{\\beta}\\right)\\right),  |s|\\beta.\n\\end{cases}\n$$\n\n4) 离散模型。在 $N\\times N$ 的内部网格上，使用标准的五点有限差分格式来近似带齐次狄利克雷边界条件的 $-\\Delta$。设 $\\mathbf{A}(\\varepsilon_r)$ 为离散算子，使得\n$$\n\\mathbf{A}(\\varepsilon_r)\\,\\mathbf{u} = \\mathbf{b},\n$$\n其中 $\\mathbf{u}\\in\\mathbb{C}^{N^2}$ 是离散化场，$\\mathbf{b}\\in\\mathbb{C}^{N^2}$ 是离散化点源。该算子具有以下形式\n$$\n\\mathbf{A}(\\varepsilon_r) = \\mathbf{L} + \\operatorname{diag}\\!\\left(-k_0^2 \\,\\varepsilon_r + i\\,\\tau\\right),\n$$\n其中 $\\mathbf{L}$ 是 $-\\Delta$ 的离散近似。\n\n5) 伴随态方法。引入采样算子 $\\mathbf{P}:\\mathbb{C}^{N^2}\\to\\mathbb{C}^M$，它在探测器索引处选择条目。泛函为 $J(\\mathbf{u}) = \\tfrac{1}{2}\\|\\mathbf{P}\\mathbf{u}-\\mathbf{d}_{\\mathrm{obs}}\\|_2^2$。伴随态 $\\mathbf{p}\\in\\mathbb{C}^{N^2}$ 求解伴随线性系统\n$$\n\\mathbf{A}(\\varepsilon_r)^\\ast \\,\\mathbf{p} = \\mathbf{P}^\\ast\\!\\left(\\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}}\\right),\n$$\n其中 $(\\cdot)^\\ast$ 表示共轭转置。关于 $\\varepsilon_r$ 的梯度是通过伴随态方法，对拉格朗日量求关于 $\\varepsilon_r$ 的导数得到的。\n\n6) 水平集梯度组装。链式法则将关于水平集场的导数与关于介电常数的导数联系起来：\n$$\n\\frac{\\partial J}{\\partial \\phi}(\\mathbf{x}) = \\frac{\\partial J}{\\partial \\varepsilon_r}(\\mathbf{x}) \\cdot \\frac{\\partial \\varepsilon_r}{\\partial \\phi}(\\mathbf{x}) = \\frac{\\partial J}{\\partial \\varepsilon_r}(\\mathbf{x}) \\cdot \\left(\\varepsilon_{\\text{in}}-\\varepsilon_{\\text{out}}\\right)\\delta_\\beta\\!\\left(\\phi(\\mathbf{x})\\right).\n$$\n\n您的任务是：\n\na) 给定算子为 $\\mathbf{A}(\\varepsilon_r) = \\mathbf{L} + \\operatorname{diag}(-k_0^2 \\varepsilon_r + i \\tau)$，从第一性原理出发，使用变分法和伴随态方法，推导出 $\\frac{\\partial J}{\\partial \\varepsilon_r}(\\mathbf{x})$ 关于正向场 $u$ 和伴随场 $p$ 的显式逐点表达式。\n\nb) 使用第6项中的链式法则，在网格上组装水平集梯度 $\\mathcal{G}(\\mathbf{x}) = \\frac{\\partial J}{\\partial \\phi}(\\mathbf{x})$。\n\nc) 实现一个完整的程序，对下面的每个测试用例，计算组装梯度的离散$\\ell^2$范数，\n$$\n\\left\\|\\mathcal{G}\\right\\|_{2,h} = \\left( \\sum_{j=1}^{N^2} \\left|\\mathcal{G}_j\\right|^2 \\, h^2 \\right)^{1/2},\n$$\n并为每个测试用例输出一个实数。最终输出必须是单行文本，包含一个用方括号括起来的、逗号分隔的范数列表。\n\n所有测试用例使用的实现细节和通用设置：\n\n- 网格：使用 $N=30$, $h=\\frac{1}{N+1}$ 和齐次狄利克雷边界条件。使用标准的五点模板构建 $\\mathbf{L}$，使得 $\\mathbf{L} = \\mathbf{I}_y\\otimes \\mathbf{T} + \\mathbf{T}\\otimes \\mathbf{I}_x$，其中 $\\mathbf{T}$ 是一个 $N\\times N$ 的三对角矩阵，主对角线元素为 $\\frac{2}{h^2}$，次对角线元素为 $-\\frac{1}{h^2}$。\n\n- 吸收：设置 $\\tau = 1.0$。\n\n- 源：一个位于 $(x_s,y_s)=(0.2,0.5)$ 的点源，以单位振幅注入到最近的内部网格节点，作为右端项 $\\mathbf{b}$。\n\n- 探测器：$M=10$ 个点。在以 $(0.5,0.5)$ 为中心、半径为 $r_d=0.45$ 的圆环上，于角度 $\\theta_m = \\frac{2\\pi m}{8}$（$m=0,1,\\dots,7$）处放置8个探测器，并在 $(0.5,0.3)$ 和 $(0.5,0.7)$ 处放置2个内部探测器。在最近的内部网格节点上进行采样。\n\n- 水平集形状：水平集函数是一个到圆的有向距离，\n$$\n\\phi(\\mathbf{x}) = R - \\sqrt{(x-x_0)^2 + (y-y_0)^2},\n$$\n因此嵌入体是以 $(x_0,y_0)$ 为中心、半径为 $R$ 的圆盘。背景是 $\\phi(\\mathbf{x})\\le 0$ 的区域。在所有测试用例中均使用 $(x_0,y_0)=(0.5,0.5)$。\n\n- 相对介电常数映射：$\\varepsilon_r(\\mathbf{x}) = \\varepsilon_{\\text{out}} + (\\varepsilon_{\\text{in}}-\\varepsilon_{\\text{out}}) H_\\beta(\\phi(\\mathbf{x}))$。\n\n- 观测数据构造：对于每个测试用例，定义一个半径为 $R_{\\text{true}}$ 的“真实”形状，通过求解具有与真实形状对应的 $\\varepsilon_r$ 的正向问题来生成 $\\mathbf{d}_{\\mathrm{obs}}$。“重建”形状的半径 $R_{\\text{rec}}$ 用于构建算子，以求解您必须组装其梯度的正向场和伴随场。\n\n- 复数运算：所有线性求解都是复值的。伴随系统使用共轭转置算子 $\\mathbf{A}^\\ast$。\n\n测试套件：\n\n- 情况1（理想情况，梯度接近于零）：$k_0=5.0$，$\\varepsilon_{\\text{in}}=4.0$，$\\varepsilon_{\\text{out}}=1.0$，$\\beta=2h$，$R_{\\text{true}}=0.25$，$R_{\\text{rec}}=0.25$。\n\n- 情况2（对比度失配）：$k_0=5.0$，$\\varepsilon_{\\text{in}}=4.0$，$\\varepsilon_{\\text{out}}=1.0$，$\\beta=2h$，$R_{\\text{true}}=0.30$，$R_{\\text{rec}}=0.20$。\n\n- 情况3（平滑度较小、对比度和频率降低的边缘情况）：$k_0=3.0$，$\\varepsilon_{\\text{in}}=2.0$，$\\varepsilon_{\\text{out}}=1.0$，$\\beta=0.5h$，$R_{\\text{true}}=0.30$，$R_{\\text{rec}}=0.20$。\n\n对于每种情况，使用上述通用设置并计算离散$\\ell^2$范数 $\\|\\mathcal{G}\\|_{2,h}$，单位为实数，无需特定物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的结果列表（例如，$[\\text{result1},\\text{result2},\\text{result3}]$）。每个条目必须是对应于相应测试用例范数的浮点数，按情况1、2、3的顺序排列。",
            "solution": "该问题要求在一个二维标量波问题中，推导并实现一种伴随态方法，用以计算一个数据失配泛函相对于一个参数化嵌入体形状的水平集函数的梯度。解决方案分三个阶段进行：首先，我们验证问题陈述的有效性；其次，我们推导梯度的必要解析表达式；第三，我们详细说明数值实现。\n\n### 问题验证\n问题定义良好且在科学上是合理的。\n*   **提取的已知条件**：控制偏微分方程、边界条件、目标泛函、水平集参数化、离散模型、伴随公式，以及所有数值参数（$N=30$，$\\tau=1.0$，源/探测器位置，材料属性 $\\varepsilon_{\\text{in}}, \\varepsilon_{\\text{out}}$，以及测试用例细节）都已明确给出。\n*   **科学依据**：该模型基于标量亥姆霍兹方程，这是频域电磁学中的一个标准近似。使用伴随态方法进行灵敏度分析和使用水平集函数进行形状优化是计算反演问题中已建立的严谨技术。\n*   **适定性**：包含吸收项 $\\tau  0$ 确保了正向算子 $\\mathbf{A}(\\varepsilon_r)$ 是可逆的，从而保证了正向场 $\\mathbf{u}$ 以及伴随场 $\\mathbf{p}$ 的解是唯一的。计算梯度是一项定义明确的数学运算。\n*   **完整性和一致性**：问题陈述是自洽的，为解析推导和数值实现提供了所有必要信息。所提供的数据或约束中没有矛盾。\n\n问题被判定为**有效**。我们现在开始求解。\n\n### 伴随态梯度推导\n\n核心任务是找到目标泛函 $J$ 关于水平集函数 $\\phi$ 的梯度。我们使用链式法则：$\\frac{\\partial J}{\\partial \\phi} = \\frac{\\partial J}{\\partial \\varepsilon_r} \\frac{\\partial \\varepsilon_r}{\\partial \\phi}$。我们首先使用伴随态方法推导 $\\frac{\\partial J}{\\partial \\varepsilon_r}$ 的表达式。\n\n该问题是一个约束优化问题：最小化 $J(\\mathbf{u})$，约束条件为状态方程 $\\mathbf{A}(\\boldsymbol{\\varepsilon}_r)\\mathbf{u} = \\mathbf{b}$，其中 $\\boldsymbol{\\varepsilon}_r$ 是每个网格点上介电常数值的向量。我们引入拉格朗日泛函 $\\mathcal{L}$，并使用伴随态 $\\mathbf{p} \\in \\mathbb{C}^{N^2}$ 作为状态方程约束的拉格朗日乘子：\n$$\n\\mathcal{L}(\\mathbf{u}, \\mathbf{p}, \\boldsymbol{\\varepsilon}_r) = J(\\mathbf{u}) - \\Re\\left[ \\mathbf{p}^\\ast (\\mathbf{A}(\\boldsymbol{\\varepsilon}_r)\\mathbf{u} - \\mathbf{b}) \\right]\n$$\n离散形式的目标泛函是 $J(\\mathbf{u}) = \\frac{1}{2}\\|\\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}}\\|_2^2 = \\frac{1}{2}(\\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}})^\\ast(\\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}})$。\n\n$J$ 关于参数 $\\boldsymbol{\\varepsilon}_r$ 的梯度由拉格朗日量的偏导数给出，即 $\\frac{dJ}{d\\boldsymbol{\\varepsilon}_r} = \\frac{\\partial\\mathcal{L}}{\\partial\\boldsymbol{\\varepsilon}_r}$，前提是平稳性条件 $\\frac{\\partial\\mathcal{L}}{\\partial\\mathbf{u}} = 0$ 和 $\\frac{\\partial\\mathcal{L}}{\\partial\\mathbf{p}} = 0$ 成立。后者仅恢复了状态方程 $\\mathbf{A}\\mathbf{u}=\\mathbf{b}$。前者定义了伴随方程。\n\n使用复（Wirtinger）分析，关于 $\\mathbf{u}$（特别是其共轭 $\\mathbf{u}^\\ast$）的平稳性条件是 $\\frac{\\partial \\mathcal{L}}{\\partial \\mathbf{u}^\\ast} = 0$。我们有：\n$$\n\\frac{\\partial J}{\\partial \\mathbf{u}^\\ast} = \\frac{1}{2}\\mathbf{P}^\\ast(\\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}})\n$$\n项 $\\Re[\\mathbf{p}^\\ast \\mathbf{A}\\mathbf{u}]$ 可以写为 $\\frac{1}{2}(\\mathbf{p}^\\ast \\mathbf{A}\\mathbf{u} + \\mathbf{u}^\\ast \\mathbf{A}^\\ast \\mathbf{p})$。它关于 $\\mathbf{u}^\\ast$ 的导数是 $\\frac{1}{2}\\mathbf{A}^\\ast\\mathbf{p}$。因此，平稳性条件变为：\n$$\n\\frac{\\partial\\mathcal{L}}{\\partial \\mathbf{u}^\\ast} = \\frac{1}{2}\\mathbf{P}^\\ast(\\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}}) - \\frac{1}{2}\\mathbf{A}(\\boldsymbol{\\varepsilon}_r)^\\ast\\mathbf{p} = 0\n$$\n这导出了**伴随方程**：\n$$\n\\mathbf{A}(\\boldsymbol{\\varepsilon}_r)^\\ast \\mathbf{p} = \\mathbf{P}^\\ast(\\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}})\n$$\n这与问题陈述中给出的方程相符。定义了伴随态 $\\mathbf{p}$ 后，我们现在可以计算关于介电常数向量 $\\boldsymbol{\\varepsilon}_r$ 的梯度。$J$ 对介电常数向量的单个分量 $\\varepsilon_{r,j}$ 的全导数为：\n$$\n\\frac{dJ}{d\\varepsilon_{r,j}} = \\frac{\\partial \\mathcal{L}}{\\partial \\varepsilon_{r,j}} = -\\Re\\left[ \\mathbf{p}^\\ast \\frac{\\partial \\mathbf{A}(\\boldsymbol{\\varepsilon}_r)}{\\partial \\varepsilon_{r,j}} \\mathbf{u} \\right]\n$$\n离散算子为 $\\mathbf{A}(\\boldsymbol{\\varepsilon}_r) = \\mathbf{L} + \\operatorname{diag}(-k_0^2 \\boldsymbol{\\varepsilon}_r + i\\tau)$。它对 $\\varepsilon_{r,j}$ 的导数是一个除了 $(j,j)$ 元素外处处为零的矩阵：\n$$\n\\frac{\\partial \\mathbf{A}(\\boldsymbol{\\varepsilon}_r)}{\\partial \\varepsilon_{r,j}} = -k_0^2 \\mathbf{e}_j \\mathbf{e}_j^T\n$$\n其中 $\\mathbf{e}_j$ 是第 $j$ 个标准基向量。将此代入梯度表达式：\n$$\n\\frac{dJ}{d\\varepsilon_{r,j}} = -\\Re\\left[ \\mathbf{p}^\\ast (-k_0^2 \\mathbf{e}_j \\mathbf{e}_j^T) \\mathbf{u} \\right] = \\Re\\left[ k_0^2 \\mathbf{p}^\\ast (\\mathbf{e}_j \\mathbf{e}_j^T \\mathbf{u}) \\right] = \\Re\\left[ k_0^2 (\\bar{p}_j u_j) \\right]\n$$\n其中 $p_j$ 和 $u_j$ 分别是伴随场和正向场的第 $j$ 个分量。由此得到关于介电常数梯度的逐点表达式为：\n$$\n\\frac{\\partial J}{\\partial \\varepsilon_r}(\\mathbf{x}) = \\Re\\left( k_0^2 \\, \\overline{p(\\mathbf{x})} \\, u(\\mathbf{x}) \\right)\n$$\n这完成了任务(a)。\n\n### 水平集梯度组装\n\n对于任务(b)，我们使用给定的链式法则来组装关于水平集函数 $\\phi$ 的梯度：\n$$\n\\mathcal{G}(\\mathbf{x}) = \\frac{\\partial J}{\\partial \\phi}(\\mathbf{x}) = \\frac{\\partial J}{\\partial \\varepsilon_r}(\\mathbf{x}) \\cdot \\frac{\\partial \\varepsilon_r}{\\partial \\phi}(\\mathbf{x})\n$$\n问题指明了介电常数参数化的导数：\n$$\n\\frac{\\partial \\varepsilon_r}{\\partial \\phi}(\\mathbf{x}) = (\\varepsilon_{\\text{in}} - \\varepsilon_{\\text{out}}) \\delta_\\beta(\\phi(\\mathbf{x}))\n$$\n其中 $\\delta_\\beta$ 是平滑的狄拉克δ函数。将其与任务(a)的结果结合，我们得到在每个网格点 $\\mathbf{x}$ 处水平集梯度的最终表达式：\n$$\n\\mathcal{G}(\\mathbf{x}) = \\Re\\left( k_0^2 \\, \\overline{p(\\mathbf{x})} \\, u(\\mathbf{x}) \\right) \\cdot (\\varepsilon_{\\text{in}} - \\varepsilon_{\\text{out}}) \\delta_\\beta(\\phi(\\mathbf{x}))\n$$\n\n### 算法流程\n\n对于任务(c)，我们实现一个程序，对每个测试用例遵循以下步骤：\n1.  **设置**：定义网格参数（$N=30, h=1/31$）、网格坐标、离散拉普拉斯算子 $\\mathbf{L}$、源向量 $\\mathbf{b}$ 以及探测器位置/索引。\n2.  **生成观测数据**：对于给定的测试用例，使用真实半径 $R_{\\text{true}}$ 构造“真实”介电常数 $\\boldsymbol{\\varepsilon}_{r, \\text{true}}$。组装真实系统矩阵 $\\mathbf{A}_{\\text{true}}$ 并求解正向问题 $\\mathbf{A}_{\\text{true}}\\mathbf{u}_{\\text{true}} = \\mathbf{b}$ 以得到 $\\mathbf{u}_{\\text{true}}$。观测数据为 $\\mathbf{d}_{\\mathrm{obs}} = \\mathbf{P}\\mathbf{u}_{\\text{true}}$。\n3.  **求解正向问题**：使用重建半径 $R_{\\text{rec}}$ 构造“重建”介电常数 $\\boldsymbol{\\varepsilon}_{r, \\text{rec}}$。组装相应的矩阵 $\\mathbf{A}_{\\text{rec}}$ 并求解正向问题 $\\mathbf{A}_{\\text{rec}}\\mathbf{u} = \\mathbf{b}$ 以找到状态场 $\\mathbf{u}$。\n4.  **求解伴随问题**：计算数据残差 $\\mathbf{r} = \\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}}$。构建伴随源 $\\mathbf{b}_{\\text{adj}} = \\mathbf{P}^\\ast \\mathbf{r}$。求解伴随系统 $\\mathbf{A}_{\\text{rec}}^\\ast \\mathbf{p} = \\mathbf{b}_{\\text{adj}}$ 以得到伴随场 $\\mathbf{p}$。\n5.  **组装梯度**：\n    *   在每个网格点 $j$ 计算介电常数梯度项：$\\left(\\frac{\\partial J}{\\partial \\varepsilon_r}\\right)_j = \\Re(k_0^2 \\, \\bar{p}_j \\, u_j)$。\n    *   使用 $R_{\\text{rec}}$ 计算水平集函数 $\\phi(\\mathbf{x}_j)$。\n    *   在每个网格点 $j$ 计算链式法则因子：$\\left(\\frac{\\partial \\varepsilon_r}{\\partial \\phi}\\right)_j = (\\varepsilon_{\\text{in}} - \\varepsilon_{\\text{out}}) \\delta_\\beta(\\phi(\\mathbf{x}_j))$。\n    *   将它们组合起来得到水平集梯度向量：$\\mathcal{G}_j = \\left(\\frac{\\partial J}{\\partial \\varepsilon_r}\\right)_j \\cdot \\left(\\frac{\\partial \\varepsilon_r}{\\partial \\phi}\\right)_j$。\n6.  **计算范数**：计算梯度的离散$\\ell^2$范数：$\\|\\mathcal{G}\\|_{2,h} = \\left( \\sum_{j=1}^{N^2} |\\mathcal{G}_j|^2 h^2 \\right)^{1/2}$。此值为该测试用例的结果。\n\n对测试套件中的所有测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the adjoint-state gradient assembly problem for the given test cases.\n    \"\"\"\n    # Common setup parameters\n    N = 30\n    h = 1.0 / (N + 1)\n    tau = 1.0\n    src_pos = (0.2, 0.5)\n    \n    # Detector positions\n    det_pos = []\n    # 8 detectors on a ring\n    r_d, x_c, y_c = 0.45, 0.5, 0.5\n    for m in range(8):\n        angle = 2.0 * np.pi * m / 8.0\n        det_pos.append((x_c + r_d * np.cos(angle), y_c + r_d * np.sin(angle)))\n    # 2 interior detectors\n    det_pos.extend([(0.5, 0.3), (0.5, 0.7)])\n    \n    # Test case suite\n    test_cases = [\n        # (k0, eps_in, eps_out, beta_factor, R_true, R_rec)\n        (5.0, 4.0, 1.0, 2.0, 0.25, 0.25),\n        (5.0, 4.0, 1.0, 2.0, 0.30, 0.20),\n        (3.0, 2.0, 1.0, 0.5, 0.30, 0.20),\n    ]\n\n    # --- Grid and Operator Setup ---\n    # Create 1D and 2D grid coordinates\n    grid_1d = np.linspace(h, 1.0 - h, N)\n    X, Y = np.meshgrid(grid_1d, grid_1d)\n    coords_flat = np.vstack((X.ravel(), Y.ravel())).T\n\n    # 1D Laplacian matrix T\n    T_diags = [-1.0, 2.0, -1.0]\n    T_offsets = [-1, 0, 1]\n    T = sparse.diags(T_diags, T_offsets, shape=(N, N)) / h**2\n    \n    # 2D Laplacian operator L using Kronecker sum\n    I_N = sparse.eye(N)\n    L = sparse.kronsum(T, T).tocsc()\n\n    # Source vector b\n    src_x_idx = int(round(src_pos[0] / h)) - 1\n    src_y_idx = int(round(src_pos[1] / h)) - 1\n    src_flat_idx = src_y_idx * N + src_x_idx\n    b = np.zeros(N**2, dtype=complex)\n    b[src_flat_idx] = 1.0\n\n    # Detector indices\n    det_indices = []\n    for x_d, y_d in det_pos:\n        det_x_idx = int(round(x_d / h)) - 1\n        det_y_idx = int(round(y_d / h)) - 1\n        det_indices.append(det_y_idx * N + det_x_idx)\n    det_indices = np.array(det_indices)\n\n    # --- Helper Functions ---\n    def H_beta(s, beta):\n        res = np.zeros_like(s)\n        mask_mid = np.abs(s)  beta\n        s_mid = s[mask_mid]\n        res[s >= beta] = 1.0\n        res[mask_mid] = 0.5 * (1.0 + s_mid / beta + (1.0 / np.pi) * np.sin(np.pi * s_mid / beta))\n        return res\n\n    def delta_beta(s, beta):\n        res = np.zeros_like(s)\n        mask = np.abs(s)  beta\n        s_mid = s[mask]\n        res[mask] = (0.5 / beta) * (1.0 + np.cos(np.pi * s_mid / beta))\n        return res\n    \n    def get_epsilon_r(R, beta, eps_in, eps_out):\n        phi_center = (0.5, 0.5)\n        dist = np.sqrt((coords_flat[:, 0] - phi_center[0])**2 + (coords_flat[:, 1] - phi_center[1])**2)\n        phi = R - dist\n        return eps_out + (eps_in - eps_out) * H_beta(phi, beta)\n\n    results = []\n    for case in test_cases:\n        k0, eps_in, eps_out, beta_factor, R_true, R_rec = case\n        beta = beta_factor * h\n\n        # 1. Generate observed data d_obs\n        eps_r_true = get_epsilon_r(R_true, beta, eps_in, eps_out)\n        A_true_diag = -k0**2 * eps_r_true + 1j * tau\n        A_true = L + sparse.diags(A_true_diag)\n        u_true = spsolve(A_true, b)\n        d_obs = u_true[det_indices]\n\n        # 2. Solve forward problem for reconstruction state u\n        eps_r_rec = get_epsilon_r(R_rec, beta, eps_in, eps_out)\n        A_rec_diag = -k0**2 * eps_r_rec + 1j * tau\n        A_rec = L + sparse.diags(A_rec_diag)\n        u = spsolve(A_rec, b)\n\n        # 3. Solve adjoint problem for p\n        residual = u[det_indices] - d_obs\n        b_adj = np.zeros(N**2, dtype=complex)\n        b_adj[det_indices] = residual\n        \n        A_adj = A_rec.conj().T\n        p = spsolve(A_adj, b_adj)\n\n        # 4. Assemble level-set gradient G\n        dJ_deps = np.real(k0**2 * np.conj(p) * u)\n        \n        phi_center = (0.5, 0.5)\n        dist_rec = np.sqrt((coords_flat[:, 0] - phi_center[0])**2 + (coords_flat[:, 1] - phi_center[1])**2)\n        phi_rec = R_rec - dist_rec\n        \n        deps_dphi = (eps_in - eps_out) * delta_beta(phi_rec, beta)\n        \n        G = dJ_deps * deps_dphi\n        \n        # 5. Compute the norm of the gradient\n        norm_G = np.sqrt(np.sum(np.abs(G)**2) * h**2)\n        results.append(norm_G)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "计算出梯度（即形状演化的速度场 $V$）之后，最后一步就是根据该速度场来实际地演化水平集函数 $\\phi$，从而更新几何形状。这个演化过程由一个哈密顿-雅可比（Hamilton-Jacobi）类型的偏微分方程 $\\frac{\\partial \\phi}{\\partial t} + V|\\nabla \\phi| = 0$ 描述。本实践聚焦于求解该方程的数值方法，它将带你深入了解水平集方法的数值引擎，通过实现并比较一个简单的中心差分格式和一个更为稳健的迎风格式，让你亲身体会保证数值稳定性和准确性的重要性。",
            "id": "3323768",
            "problem": "您的任务是推导并实现两种用于计算电磁学中形状重构的水平集偏微分方程（PDE）的数值离散格式。从基本原理出发，从头开始构建算法。最终目标是在一组受控的合成速度场上比较这两种格式，这些速度场模仿了从电磁逆散射中的形状梯度派生出的下降方向。\n\n考虑一个二维计算域 $\\Omega = [0,1]\\times[0,1]$，该域由一个包含 $N\\times N$ 个点的均匀笛卡尔网格离散化（$N$ 在测试套件中指定）。设水平集函数表示为 $\\phi(x,y,t)$，并约定预测的形状对应于子水平集 $\\{\\phi  0\\}$。其演化方程为\n$$\n\\frac{\\partial \\phi}{\\partial t} + V(x,y)\\, \\lvert\\nabla \\phi\\rvert \\;=\\; \\mu\\,\\kappa(\\phi)\\,\\lvert\\nabla \\phi\\rvert,\n$$\n其中 $V(x,y)$ 是一个给定的法向速度场，表示一个与形状梯度成比例的下降方向，$\\mu0$ 是一个曲率正则化参数，$\\kappa(\\phi)$ 是由下式定义的水平集的平均曲率\n$$\n\\kappa(\\phi) \\;=\\; \\nabla \\cdot \\left(\\frac{\\nabla \\phi}{\\lvert \\nabla \\phi \\rvert}\\right),\n$$\n为避免除以零，分母中采用标准的 $\\epsilon$-正则化。\n\n电磁学背景及 $V(x,y)$ 的来源：在横电（TE）极化的频域麦克斯韦方程组中，总电场 $E_z$ 满足从非均匀介质中的麦克斯韦方程组推导出的亥姆霍兹方程。一个典型的逆问题是最小化一个失配泛函 $J(\\Omega)=\\frac{1}{2}\\int_{\\Gamma}\\lvert E^{\\mathrm{comp}}(\\Omega)-E^{\\mathrm{meas}}\\rvert^2\\,\\mathrm{d}s$，其中 $\\Gamma$ 是一条观测曲线。$J$ 的形状导数或拓扑导数提供了一个下降方向，其在法线方向上的投影产生了一个适合水平集演化的速度 $V(x,y)$，即界面法向运动会使 $J$ 下降。在本任务中，$V(x,y)$ 将作为合成场提供，这些场是此类下降方向在科学上合理的代理。\n\n您的任务是：\n- 从基本原理出发，为 Hamilton-Jacobi 项 $V(x,y)\\lvert\\nabla \\phi\\rvert$ 和曲率项推导两种一致的半离散近似。\n    1. 一种用于 Hamilton-Jacobi 项的单调迎风 Godunov 格式，该格式考虑 $V(x,y)$ 的符号，并使用单边差分来近似 $\\lvert\\nabla \\phi\\rvert$，以符合因果性。\n    2. 一种用于 Hamilton-Jacobi 项的中心差分基准格式，它使用中心差分计算 $\\nabla \\phi$，并从这些中心差分计算 $\\lvert\\nabla \\phi\\rvert$。\n- 对于曲率项，使用中心差分近似 $\\nabla \\phi$，构造单位法向量 $n=\\nabla\\phi/\\lvert\\nabla\\phi\\rvert$，并用中心差分近似 $\\kappa(\\phi)=\\nabla\\cdot n$。对分母使用 $\\epsilon$-正则化 $\\lvert\\nabla\\phi\\rvert_{\\epsilon}=\\sqrt{\\phi_x^2+\\phi_y^2+\\epsilon^2}$（$\\epsilon0$）。\n- 采用齐次诺伊曼边界条件（法向导数为零），通过将那些本应延伸到域外的单边模板的边界有限差分设置为零来实现。\n- 使用显式前向欧拉时间积分 $t^{n+1}=t^n+\\Delta t$。根据 Courant–Friedrichs–Lewy (CFL) 条件选择时间步长 $\\Delta t$，CFL 因子为 $c_{\\mathrm{CFL}}$，网格间距为 $h$，即 $\\Delta t = c_{\\mathrm{CFL}}\\frac{h}{\\max_{x,y}\\lvert V(x,y)\\rvert+\\delta}$，其中 $\\delta$ 是一个小的正数，以避免在 $V\\equiv 0$ 时除以零。\n\n初始化和单位：\n- 将 $\\phi(x,y,0)$ 初始化为到以 $(x_0,y_0)$ 为中心、半径为 $r_0$ 的圆的有向距离，即\n$$\n\\phi(x,y,0) = \\sqrt{(x-x_0)^2+(y-y_0)^2}-r_0,\n$$\n其中 $(x_0,y_0)=(0.5,0.5)$ 且 $r_0=0.25$。所有量均为无量纲。\n\n实现这两种格式，并为每个测试用例执行单个时间步。对于每个测试用例，计算并返回两种格式之间的定量差异度量：\n$$\n\\mathrm{err} = \\left(\\frac{1}{N^2}\\sum_{i,j}\\left(\\phi^{n+1}_{\\mathrm{upwind}}(i,j)-\\phi^{n+1}_{\\mathrm{central}}(i,j)\\right)^2\\right)^{1/2}.\n$$\n\n测试套件：\n- 使用 $N=64$，域 $[0,1]\\times[0,1]$，网格间距 $h=1/(N-1)$，以及单个时间步的前向欧拉法。对于每个测试用例，按指定设置 $(\\mu,\\epsilon,c_{\\mathrm{CFL}})$。\n    1. 正常路径：$V(x,y)=\\alpha \\exp\\left(-\\frac{(x-0.5)^2+(y-0.5)^2}{\\sigma^2}\\right)$，其中 $\\alpha=2.0, \\sigma^2=0.02, \\mu=0.01, \\epsilon=10^{-6}, c_{\\mathrm{CFL}}=0.25$。\n    2. 边界驱动：当 $x  0.05$ 时 $V(x,y)=\\alpha$，否则 $V(x,y)=0$；$\\alpha=1.5, \\mu=0.005, \\epsilon=10^{-6}, c_{\\mathrm{CFL}}=0.30$。\n    3. 曲率主导：$V(x,y)=0$ 恒成立；$\\mu=0.02, \\epsilon=10^{-6}, c_{\\mathrm{CFL}}=0.45$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，即 $[\\mathrm{err}_1,\\mathrm{err}_2,\\mathrm{err}_3]$，其中 $\\mathrm{err}_k$ 是测试用例 $k$ 的差异。所有输出都是无单位浮点数。",
            "solution": "目标是推导并实现两种不同的数值格式，用于求解给定的水平集演化方程：\n$$\n\\frac{\\partial \\phi}{\\partial t} + V(x,y)\\, \\lvert\\nabla \\phi\\rvert \\;=\\; \\mu\\,\\kappa(\\phi)\\,\\lvert\\nabla \\phi\\rvert\n$$\n该偏微分方程（PDE）模拟了水平集函数 $\\phi(x,y,t)$ 的演化。方程可以重排以突出其组成部分：一个对流 Hamilton-Jacobi (HJ) 项和一个正则化曲率项。其半离散形式为：\n$$\n\\frac{d\\phi}{dt} = -V(x,y)\\,\\lvert\\nabla \\phi\\rvert + \\mu\\,\\kappa(\\phi)\\,\\lvert\\nabla \\phi\\rvert = -H(\\phi) + C(\\phi)\n$$\n其中 $H(\\phi)$ 代表 HJ 项，$C(\\phi)$ 代表曲率项。我们将开发两种格式，它们在 Hamilton-Jacobi 项 $H(\\phi)$ 的近似上有所不同，但对曲率项 $C(\\phi)$ 使用相同的中心离散近似。\n\n我们考虑在域 $\\Omega = [0,1]\\times[0,1]$ 上使用一个包含 $N \\times N$ 个点的均匀笛卡尔网格。在 $x$ 和 $y$ 方向上的网格间距均为 $h = 1/(N-1)$。在网格点 $(x_i, y_j) = (ih, jh)$ 和时间 $t_n = n\\Delta t$ 处的离散水平集函数记为 $\\phi_{i,j}^n$。\n\n时间演化通过显式前向欧拉格式处理：\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^n + \\Delta t \\left( -H_{i,j}(\\phi^n) + C_{i,j}(\\phi^n) \\right)\n$$\n时间步长 $\\Delta t$ 由 Courant-Friedrichs-Lewy (CFL) 条件确定：\n$$\n\\Delta t = c_{\\mathrm{CFL}}\\frac{h}{\\max_{i,j}\\lvert V_{i,j}\\rvert+\\delta}\n$$\n其中 $c_{\\mathrm{CFL}}$ 是 CFL 因子，$\\delta$ 是一个小的正常数（我们选择 $\\delta=10^{-9}$）以防止除以零。\n\n### 空间离散化\n通过将任何需要域外点的有限差分模板设置为零来施加齐次诺伊曼边界条件。\n\n#### 曲率项离散化（两种格式通用）\n曲率项为 $C(\\phi) = \\mu\\,\\kappa(\\phi)\\,\\lvert\\nabla \\phi\\rvert$。平均曲率为 $\\kappa(\\phi) = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{\\lvert\\nabla \\phi\\rvert} \\right)$。\n\n1.  **梯度近似**：我们首先使用二阶中心差分在每个网格点 $(i,j)$ 处近似 $\\nabla \\phi$：\n    $$\n    (\\phi_x)_{i,j} = \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2h}, \\quad (\\phi_y)_{i,j} = \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2h}\n    $$\n    根据诺伊曼条件，在边界上，这些导数设置为零。例如，在 $i=0$ 处，$(\\phi_x)_{0,j} = 0$。\n\n2.  **正则化梯度模**：梯度模经过正则化以防止除以零：\n    $$\n    \\lvert\\nabla\\phi\\rvert_{\\epsilon, i,j} = \\sqrt{(\\phi_x)_{i,j}^2 + (\\phi_y)_{i,j}^2 + \\epsilon^2}\n    $$\n\n3.  **单位法向量**：然后计算单位法向量 $n = (n_x, n_y)$ 的分量：\n    $$\n    (n_x)_{i,j} = \\frac{(\\phi_x)_{i,j}}{\\lvert\\nabla\\phi\\rvert_{\\epsilon, i,j}}, \\quad (n_y)_{i,j} = \\frac{(\\phi_y)_{i,j}}{\\lvert\\nabla\\phi\\rvert_{\\epsilon, i,j}}\n    $$\n\n4.  **曲率（法向量的散度）**：曲率 $\\kappa = \\nabla \\cdot n$ 也使用中心差分进行近似：\n    $$\n    \\kappa_{i,j} = \\frac{(n_x)_{i+1,j} - (n_x)_{i-1,j}}{2h} + \\frac{(n_y)_{i,j+1} - (n_y)_{i,j-1}}{2h}\n    $$\n    在边界处，诸如 $\\frac{\\partial n_x}{\\partial x}$ 的导数被设置为零。这需要首先在整个网格上计算 $n_x$ 和 $n_y$，然后应用中心差分算子计算散度。\n\n5.  **完整曲率项**：完整的离散曲率项是：\n    $$\n    C_{i,j}(\\phi) = \\mu \\cdot \\kappa_{i,j} \\cdot \\lvert\\nabla\\phi\\rvert_{\\epsilon, i,j}\n    $$\n\n#### Hamilton-Jacobi 项离散化\n此项 $H(\\phi) = V(x,y)\\lvert\\nabla\\phi\\rvert$ 是两种格式的分歧之处。\n\n**1. 中心差分格式**\n这是一种基准的、非迎风的格式。它使用与曲率项相同的中心差分近似。\n$$\nH_{i,j}^{\\text{central}}(\\phi) = V_{i,j} \\cdot \\lvert\\nabla\\phi\\rvert_{\\epsilon, i,j}\n$$\n其中 $\\lvert\\nabla\\phi\\rvert_{\\epsilon, i,j}$ 是先前从 $\\phi$ 的中心差分计算出的相同正则化梯度模。\n\n**2. 迎风 Godunov 格式**\n该格式通过使用基于信息流方向选择的单边差分，为 Hamilton-Jacobi 方程提供了更稳定的离散化。信息流方向由速度场 $V(x,y)$ 的符号确定。\n\n首先，我们定义单边有限差分算子：\n-   向前差分：$D_x^+\\phi_{i,j} = \\frac{\\phi_{i+1,j}-\\phi_{i,j}}{h}$，$D_y^+\\phi_{i,j} = \\frac{\\phi_{i,j+1}-\\phi_{i,j}}{h}$\n-   向后差分：$D_x^-\\phi_{i,j} = \\frac{\\phi_{i,j}-\\phi_{i-1,j}}{h}$，$D_y^-\\phi_{i,j} = \\frac{\\phi_{i,j}-\\phi_{i,j-1}}{h}$\n在边界处，指向域外的模板设置为零。\n\n数值哈密顿量是基于一种 Engquist-Osher 格式构建的。我们将速度 $V_{i,j}$ 分解为其正部和负部，$V_{i,j}^+ = \\max(V_{i,j}, 0)$ 和 $V_{i,j}^- = \\min(V_{i,j}, 0)$。\n\n-   对于 $V_{i,j}  0$（向外传播），信息从形状内部（$\\phi  0$）流出。迎风梯度模为：\n    $$\n    |\\nabla\\phi|_{i,j}^{+, \\text{upwind}} = \\sqrt{ \\left(\\max(D_x^-\\phi_{i,j}, 0)\\right)^2 + \\left(\\min(D_x^+\\phi_{i,j}, 0)\\right)^2 + \\left(\\max(D_y^-\\phi_{i,j}, 0)\\right)^2 + \\left(\\min(D_y^+\\phi_{i,j}, 0)\\right)^2 }\n    $$\n-   对于 $V_{i,j}  0$（向内传播），信息从外部（$\\phi  0$）流入。迎风梯度模为：\n    $$\n    |\\nabla\\phi|_{i,j}^{-, \\text{upwind}} = \\sqrt{ \\left(\\min(D_x^-\\phi_{i,j}, 0)\\right)^2 + \\left(\\max(D_x^+\\phi_{i,j}, 0)\\right)^2 + \\left(\\min(D_y^-\\phi_{i,j}, 0)\\right)^2 + \\left(\\max(D_y^+\\phi_{i,j}, 0)\\right)^2 }\n    $$\n\n完整的迎风 Hamilton-Jacobi 项是这些贡献的总和：\n$$\nH_{i,j}^{\\text{upwind}}(\\phi) = V_{i,j}^+ \\cdot |\\nabla\\phi|_{i,j}^{+, \\text{upwind}} + V_{i,j}^- \\cdot |\\nabla\\phi|_{i,j}^{-, \\text{upwind}}\n$$\n请注意，为了数值稳定性，在实现时，平方根内部会隐式地添加一个小的 $\\epsilon$ 项。\n\n### 最终算法\n对于每个测试用例：\n1.  将 $\\phi^0$ 初始化为到圆的有向距离。\n2.  计算时间步长 $\\Delta t$。\n3.  使用中心差分计算公共曲率项 $C(\\phi^0)$。\n4.  计算中心差分 HJ 项 $H^{\\text{central}}(\\phi^0)$。\n5.  计算迎风 HJ 项 $H^{\\text{upwind}}(\\phi^0)$。\n6.  为每种格式执行一个前向欧拉步：\n    $$\n    \\phi^{\\text{central}, 1} = \\phi^0 + \\Delta t \\left( -H^{\\text{central}}(\\phi^0) + C(\\phi^0) \\right)\n    $$\n    $$\n    \\phi^{\\text{upwind}, 1} = \\phi^0 + \\Delta t \\left( -H^{\\text{upwind}}(\\phi^0) + C(\\phi^0) \\right)\n    $$\n7.  计算两个结果场之间的均方根差异：\n    $$\n    \\mathrm{err} = \\left(\\frac{1}{N^2}\\sum_{i,j=0}^{N-1}\\left(\\phi^{\\text{upwind}, 1}_{i,j}-\\phi^{\\text{central}, 1}_{i,j}\\right)^2\\right)^{1/2}\n    $$\nHJ 项近似 $H^{\\text{central}}$ 和 $H^{\\text{upwind}}$ 的差异是该差异的唯一来源。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements two numerical schemes for a level-set PDE,\n    and computes the discrepancy between them for a set of test cases.\n    \"\"\"\n\n    def get_initial_phi(x, y, x0=0.5, y0=0.5, r0=0.25):\n        \"\"\"Initializes phi as a signed distance to a circle.\"\"\"\n        return np.sqrt((x - x0)**2 + (y - y0)**2) - r0\n\n    def get_velocity_field(x, y, case):\n        \"\"\"Generates the velocity field V(x,y) for a given test case.\"\"\"\n        if case == 1:\n            alpha, sigma2 = 2.0, 0.02\n            return alpha * np.exp(-((x - 0.5)**2 + (y - 0.5)**2) / sigma2)\n        elif case == 2:\n            alpha = 1.5\n            V = np.zeros_like(x)\n            V[x  0.05] = alpha\n            return V\n        elif case == 3:\n            return np.zeros_like(x)\n        return None\n\n    def compute_derivatives_central(phi, h):\n        \"\"\"Computes central differences for the gradient.\"\"\"\n        phi_x = np.zeros_like(phi)\n        phi_y = np.zeros_like(phi)\n\n        phi_x[1:-1, :] = (phi[2:, :] - phi[:-2, :]) / (2 * h)\n        phi_y[:, 1:-1] = (phi[:, 2:] - phi[:, :-2]) / (2 * h)\n        \n        return phi_x, phi_y\n\n    def compute_derivatives_one_sided(phi, h):\n        \"\"\"Computes one-sided differences.\"\"\"\n        phi_x_p = np.zeros_like(phi)\n        phi_x_m = np.zeros_like(phi)\n        phi_y_p = np.zeros_like(phi)\n        phi_y_m = np.zeros_like(phi)\n\n        phi_x_p[:-1, :] = (phi[1:, :] - phi[:-1, :]) / h\n        phi_x_m[1:, :] = (phi[1:, :] - phi[:-1, :]) / h\n        \n        phi_y_p[:, :-1] = (phi[:, 1:] - phi[:, :-1]) / h\n        phi_y_m[:, 1:] = (phi[:, 1:] - phi[:, :-1]) / h\n        \n        return phi_x_p, phi_x_m, phi_y_p, phi_y_m\n\n    def compute_rhs(phi, h, V, mu, epsilon, scheme):\n        \"\"\"Computes the right-hand side of the PDE evolution.\"\"\"\n        # Common Curvature Term Calculation\n        phi_x_c, phi_y_c = compute_derivatives_central(phi, h)\n        grad_phi_mag_central_eps = np.sqrt(phi_x_c**2 + phi_y_c**2 + epsilon**2)\n        \n        nx = phi_x_c / grad_phi_mag_central_eps\n        ny = phi_y_c / grad_phi_mag_central_eps\n\n        nx_x, _ = compute_derivatives_central(nx, h)\n        _, ny_y = compute_derivatives_central(ny, h)\n        \n        kappa = nx_x + ny_y\n        \n        curvature_term = mu * kappa * grad_phi_mag_central_eps\n\n        # Hamilton-Jacobi Term Calculation\n        if scheme == 'central':\n            hj_term = V * grad_phi_mag_central_eps\n        elif scheme == 'upwind':\n            phi_x_p, phi_x_m, phi_y_p, phi_y_m = compute_derivatives_one_sided(phi, h)\n            \n            V_pos = np.maximum(V, 0)\n            V_neg = np.minimum(V, 0)\n\n            grad_mag_sq_pos = (np.maximum(phi_x_m, 0))**2 + (np.minimum(phi_x_p, 0))**2 + \\\n                              (np.maximum(phi_y_m, 0))**2 + (np.minimum(phi_y_p, 0))**2\n            \n            grad_mag_sq_neg = (np.minimum(phi_x_m, 0))**2 + (np.maximum(phi_x_p, 0))**2 + \\\n                              (np.minimum(phi_y_m, 0))**2 + (np.maximum(phi_y_p, 0))**2\n\n            hj_term = V_pos * np.sqrt(grad_mag_sq_pos + epsilon**2) + \\\n                      V_neg * np.sqrt(grad_mag_sq_neg + epsilon**2)\n        \n        return -hj_term + curvature_term\n\n    # General parameters\n    N = 64\n    h = 1.0 / (N - 1)\n    delta = 1e-9\n    \n    # Grid setup\n    x_1d = np.linspace(0.0, 1.0, N)\n    y_1d = np.linspace(0.0, 1.0, N)\n    x, y = np.meshgrid(x_1d, y_1d, indexing='ij')\n\n    # Initial condition\n    phi_0 = get_initial_phi(x, y)\n\n    # Test suite\n    test_cases = [\n        # (case_id, mu, epsilon, cfl_factor)\n        (1, 0.01, 1e-6, 0.25),\n        (2, 0.005, 1e-6, 0.30),\n        (3, 0.02, 1e-6, 0.45)\n    ]\n    \n    results = []\n    \n    for case_id, mu, epsilon, cfl_factor in test_cases:\n        # Get velocity field for the case\n        V = get_velocity_field(x, y, case_id)\n        \n        # Calculate time step\n        max_v = np.max(np.abs(V))\n        dt = cfl_factor * h / (max_v + delta)\n\n        # Compute one step for central scheme\n        rhs_central = compute_rhs(phi_0, h, V, mu, epsilon, 'central')\n        phi_central_step = phi_0 + dt * rhs_central\n\n        # Compute one step for upwind scheme\n        rhs_upwind = compute_rhs(phi_0, h, V, mu, epsilon, 'upwind')\n        phi_upwind_step = phi_0 + dt * rhs_upwind\n\n        # Calculate discrepancy\n        err = np.sqrt(np.mean((phi_upwind_step - phi_central_step)**2))\n        results.append(err)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}