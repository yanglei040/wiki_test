{
    "hands_on_practices": [
        {
            "introduction": "要优化一个形状，我们首先需要知道如何改变它才能改进我们的目标函数。本练习将指导您完成伴随态方法的推导和实现，这是一种高效计算形状梯度的强大技术。通过构建一个完整的程序来计算数据失配泛函关于参数化介电常数的水平集函数 $\\phi$ 的梯度，您将掌握任何基于梯度的形状重构算法的基石。",
            "id": "3323749",
            "problem": "您的任务是为标量频域模型中分段常数相对介电常数的水平集参数化推导、实现和评估一种伴随态梯度组装方法。该模型受计算电磁学启发。目标是通过最小化模拟场与观测场之间的数据失配来重建嵌入在均匀背景中的夹杂物形状，并使用伴随态方法获取关于水平集函数的梯度。\n\n从以下基本基础开始。\n\n1) 控制方程和域。考虑在单位正方形域上的标量频域模型，其具有均匀狄利克雷边界条件。设内部网格大小为 $N \\times N$，网格间距为 $h = \\frac{1}{N+1}$。令未知复标量场为 $u:\\Omega \\to \\mathbb{C}$，由以下线性偏微分方程控制\n$$\n-\\Delta u(\\mathbf{x}) - k_0^2 \\, \\varepsilon_r(\\mathbf{x}) \\, u(\\mathbf{x}) + i \\, \\tau \\, u(\\mathbf{x}) = f(\\mathbf{x}),\n$$\n其中 $\\mathbf{x}=(x,y)\\in \\Omega=(0,1)\\times(0,1)$，$\\Delta$ 是拉普拉斯算子，$k_0$ 是给定的自由空间波数，$\\varepsilon_r(\\mathbf{x})$ 是空间变化的相对介电常数，$i$ 是虚数单位，$\\tau>0$ 是一个小的吸收参数，$f$ 是一个点源。均匀狄利克雷边界条件强制在 $\\partial \\Omega$ 上 $u=0$。\n\n2) 数据失配。在内部网格点 $\\{\\mathbf{x}_m\\}_{m=1}^M$ 处有 $M$ 个探测器。定义预测数据向量 $\\mathbf{d}_{\\mathrm{pred}}\\in\\mathbb{C}^M$ 为 $u$ 在这些探测器点上的采样值，以及一个观测数据向量 $\\mathbf{d}_{\\mathrm{obs}}\\in\\mathbb{C}^M$。目标泛函是最小二乘数据失配\n$$\nJ(u) = \\tfrac{1}{2} \\sum_{m=1}^M \\left| u(\\mathbf{x}_m) - d_{\\mathrm{obs},m} \\right|^2.\n$$\n\n3) 介电常数的水平集参数化。引入一个水平集函数 $\\phi:\\Omega\\to\\mathbb{R}$，使得夹杂物是 $\\phi(\\mathbf{x}) < 0$ 的区域。相对介电常数通过一个平滑的亥维赛函数 $H_\\beta$ 参数化为两相介质：\n$$\n\\varepsilon_r(\\mathbf{x}) = \\varepsilon_{\\text{out}} + \\left(\\varepsilon_{\\text{in}} - \\varepsilon_{\\text{out}}\\right) (1 - H_\\beta\\!\\left(\\phi(\\mathbf{x})\\right)),\n$$\n其中 $\\varepsilon_{\\text{in}}$ 和 $\\varepsilon_{\\text{out}}$ 是常数。具有宽度参数 $\\beta>0$ 的平滑亥维赛函数 $H_\\beta$ 定义为\n$$\nH_\\beta(s) = \n\\begin{cases}\n0, & s \\le -\\beta, \\\\\n\\tfrac{1}{2}\\left(1 + \\tfrac{s}{\\beta} + \\tfrac{1}{\\pi}\\sin\\left(\\tfrac{\\pi s}{\\beta}\\right)\\right), & |s| < \\beta, \\\\\n1, & s \\ge \\beta.\n\\end{cases}\n$$\n其导数是平滑的狄拉克δ函数\n$$\n\\delta_\\beta(s) = H_\\beta'(s) =\n\\begin{cases}\n0, & |s| \\ge \\beta, \\\\\n\\tfrac{1}{2\\beta}\\left(1 + \\cos\\left(\\tfrac{\\pi s}{\\beta}\\right)\\right), & |s| < \\beta.\n\\end{cases}\n$$\n\n4) 离散模型。在 $N\\times N$ 的内部网格上使用标准的五点有限差分格式来近似带均匀狄利克雷边界条件的 $-\\Delta$。设 $\\mathbf{A}(\\varepsilon_r)$ 为离散算子，使得\n$$\n\\mathbf{A}(\\varepsilon_r)\\,\\mathbf{u} = \\mathbf{b},\n$$\n其中 $\\mathbf{u}\\in\\mathbb{C}^{N^2}$ 是离散化场，$\\mathbf{b}\\in\\mathbb{C}^{N^2}$ 是离散化点源。该算子形式为\n$$\n\\mathbf{A}(\\varepsilon_r) = \\mathbf{L} + \\operatorname{diag}\\!\\left(-k_0^2 \\,\\varepsilon_r + i\\,\\tau\\right),\n$$\n其中 $\\mathbf{L}$ 是 $-\\Delta$ 的离散近似。\n\n5) 伴随态方法。引入采样算子 $\\mathbf{P}:\\mathbb{C}^{N^2}\\to\\mathbb{C}^M$，它选择探测器索引处的条目。泛函为 $J(\\mathbf{u}) = \\tfrac{1}{2}\\|\\mathbf{P}\\mathbf{u}-\\mathbf{d}_{\\mathrm{obs}}\\|_2^2$。伴随态 $\\mathbf{p}\\in\\mathbb{C}^{N^2}$ 求解伴随线性系统\n$$\n\\mathbf{A}(\\varepsilon_r)^\\ast \\,\\mathbf{p} = \\mathbf{P}^\\ast\\!\\left(\\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}}\\right),\n$$\n其中 $(\\cdot)^\\ast$ 表示共轭转置。关于 $\\varepsilon_r$ 的梯度是通过伴随态方法对拉格朗日函数关于 $\\varepsilon_r$ 求导得到的。\n\n6) 水平集梯度组装。链式法则将关于水平集场的导数与关于介电常数的导数联系起来：\n$$\n\\frac{\\partial J}{\\partial \\phi}(\\mathbf{x}) = \\frac{\\partial J}{\\partial \\varepsilon_r}(\\mathbf{x}) \\cdot \\frac{\\partial \\varepsilon_r}{\\partial \\phi}(\\mathbf{x}) = \\frac{\\partial J}{\\partial \\varepsilon_r}(\\mathbf{x}) \\cdot \\left(\\varepsilon_{\\text{in}}-\\varepsilon_{\\text{out}}\\right)(- \\delta_\\beta\\!\\left(\\phi(\\mathbf{x})\\right)).\n$$\n\n您的任务是：\n\na) 使用变分法和伴随态方法，从第一性原理出发，推导 $\\frac{\\partial J}{\\partial \\varepsilon_r}(\\mathbf{x})$ 的显式逐点表达式，该表达式用正向场 $u$ 和伴随场 $p$ 表示，已知算子为 $\\mathbf{A}(\\varepsilon_r) = \\mathbf{L} + \\operatorname{diag}(-k_0^2 \\varepsilon_r + i \\tau)$。\n\nb) 使用第 $6$ 项中的链式法则在网格上组装水平集梯度 $\\mathcal{G}(\\mathbf{x}) = \\frac{\\partial J}{\\partial \\phi}(\\mathbf{x})$。\n\nc) 实现一个完整的程序，对下面的每个测试用例，计算组装梯度的离散$\\ell^2$范数，\n$$\n\\left\\|\\mathcal{G}\\right\\|_{2,h} = \\left( \\sum_{j=1}^{N^2} \\left|\\mathcal{G}_j\\right|^2 \\, h^2 \\right)^{1/2},\n$$\n并为每个测试用例输出一个实数。最终输出必须是包含这些范数的单行逗号分隔列表，并用方括号括起来。\n\n所有测试用例将使用的实现细节和通用设置：\n\n- 网格：使用 $N=30$，$h=\\frac{1}{N+1}$，以及均匀狄利克雷边界条件。使用标准的五点模板构建 $\\mathbf{L}$，使得 $\\mathbf{L} = \\mathbf{I}_y\\otimes \\mathbf{T} + \\mathbf{T}\\otimes \\mathbf{I}_x$，其中 $\\mathbf{T}$ 是一个 $N\\times N$ 的三对角矩阵，主对角线元素为 $\\frac{2}{h^2}$，次对角线元素为 $-\\frac{1}{h^2}$。\n\n- 吸收：设置 $\\tau = 1.0$。\n\n- 源：位于 $(x_s,y_s)=(0.2,0.5)$ 的点源，以单位振幅注入到右手边 $\\mathbf{b}$ 中最近的内部网格节点上。\n\n- 探测器：$M=10$ 个点。在以 $(0.5,0.5)$ 为中心、半径为 $r_d=0.45$ 的圆环上，以角度 $\\theta_m = \\frac{2\\pi m}{8}$（$m=0,1,\\dots,7$）放置 $8$ 个探测器，并在 $(0.5,0.3)$ 和 $(0.5,0.7)$ 处放置 $2$ 个内部探测器。在最近的内部网格节点上进行采样。\n\n- 水平集形状：水平集函数是到圆的符号距离，\n$$\n\\phi(\\mathbf{x}) = \\sqrt{(x-x_0)^2 + (y-y_0)^2} - R,\n$$\n因此夹杂物是半径为 $R$、中心在 $(x_0,y_0)$ 的圆盘。背景是 $\\phi(\\mathbf{x}) > 0$ 的区域。在所有测试用例中均使用 $(x_0,y_0)=(0.5,0.5)$。\n\n- 相对介电常数映射：$\\varepsilon_r(\\mathbf{x}) = \\varepsilon_{\\text{out}} + (\\varepsilon_{\\text{in}}-\\varepsilon_{\\text{out}}) (1-H_\\beta(\\phi(\\mathbf{x})))$。\n\n- 观测数据构造：对于每个测试用例，定义一个半径为 $R_{\\text{true}}$ 的“真实”形状，通过求解与真实形状对应的 $\\varepsilon_r$ 的正向问题来生成 $\\mathbf{d}_{\\mathrm{obs}}$。半径为 $R_{\\text{rec}}$ 的“重建”形状用于构建算子，以计算您必须组装其梯度的正向和伴随场。\n\n- 复数运算：所有线性求解都是复数值的。伴随系统使用共轭转置算子 $\\mathbf{A}^\\ast$。\n\n测试套件：\n\n- 情况 $1$（理想情况，梯度接近于零）：$k_0=5.0$，$\\varepsilon_{\\text{in}}=4.0$，$\\varepsilon_{\\text{out}}=1.0$，$\\beta=2h$，$R_{\\text{true}}=0.25$，$R_{\\text{rec}}=0.25$。\n\n- 情况 $2$（对比度失配）：$k_0=5.0$，$\\varepsilon_{\\text{in}}=4.0$，$\\varepsilon_{\\text{out}}=1.0$，$\\beta=2h$，$R_{\\text{true}}=0.30$，$R_{\\text{rec}}=0.20$。\n\n- 情况 $3$（平滑度更小、对比度和频率降低的边缘情况）：$k_0=3.0$，$\\varepsilon_{\\text{in}}=2.0$，$\\varepsilon_{\\text{out}}=1.0$，$\\beta=0.5h$，$R_{\\text{true}}=0.30$，$R_{\\text{rec}}=0.20$。\n\n对于每种情况，使用上述通用设置并计算离散$\\ell^2$范数 $\\|\\mathcal{G}\\|_{2,h}$，以实数单位表示，不需要特殊的物理单位。您的程序应生成单行输出，其中包含一个逗号分隔的结果列表，并用方括号括起来（例如，$[\\text{result1},\\text{result2},\\text{result3}]$）。每个条目必须是一个浮点数，对应于相应测试用例的范数，顺序为情况 1、2、3。",
            "solution": "该问题要求推导并实现一种伴随态方法，用于计算数据失配泛函相对于水平集函数的梯度，该水平集函数参数化了二维标量波问题中夹杂物的形状。解决方案分三个阶段进行：首先，我们验证问题陈述；其次，我们推导梯度所需的解析表达式；第三，我们详细说明数值实现。\n\n### 问题验证\n该问题定义明确且科学上合理。\n*   **提取的已知条件**：控制偏微分方程、边界条件、目标泛函、水平集参数化、离散模型、伴随公式以及所有数值参数（$N=30$，$\\tau=1.0$，源/探测器位置，材料属性 $\\varepsilon_{\\text{in}}, \\varepsilon_{\\text{out}}$，以及测试用例细节）都已明确提供。\n*   **科学依据**：该模型基于标量亥姆霍兹方程，这是频域电磁学中的标准近似。使用伴随态方法进行灵敏度分析和使用水平集函数进行形状优化是计算反演问题中已建立的严谨技术。\n*   **适定性**：包含吸收项 $\\tau > 0$ 确保了正向算子 $\\mathbf{A}(\\varepsilon_r)$ 是可逆的，从而保证了正向场 $\\mathbf{u}$ 以及随之的伴随场 $\\mathbf{p}$ 有唯一解。计算梯度的任务是一个定义明确的数学运算。\n*   **完整性与一致性**：问题陈述是自包含的，提供了进行解析推导和数值实现所需的所有信息。所提供的数据或约束中没有矛盾。\n\n该问题被判定为**有效**。我们现在着手求解。\n\n### 伴随态梯度推导\n\n核心任务是找到目标泛函 $J$ 相对于水平集函数 $\\phi$ 的梯度。我们使用链式法则：$\\frac{\\partial J}{\\partial \\phi} = \\frac{\\partial J}{\\partial \\varepsilon_r} \\frac{\\partial \\varepsilon_r}{\\partial \\phi}$。我们首先使用伴随态方法推导 $\\frac{\\partial J}{\\partial \\varepsilon_r}$ 的表达式。\n\n这是一个约束优化问题：最小化 $J(\\mathbf{u})$，约束条件为状态方程 $\\mathbf{A}(\\boldsymbol{\\varepsilon}_r)\\mathbf{u} = \\mathbf{b}$，其中 $\\boldsymbol{\\varepsilon}_r$ 是每个网格点上介电常数值的向量。我们引入拉格朗日泛函 $\\mathcal{L}$，并以伴随态 $\\mathbf{p} \\in \\mathbb{C}^{N^2}$ 作为状态方程约束的拉格朗日乘子：\n$$\n\\mathcal{L}(\\mathbf{u}, \\mathbf{p}, \\boldsymbol{\\varepsilon}_r) = J(\\mathbf{u}) - \\Re\\left[ \\mathbf{p}^\\ast (\\mathbf{A}(\\boldsymbol{\\varepsilon}_r)\\mathbf{u} - \\mathbf{b}) \\right]\n$$\n离散形式的目标泛函是 $J(\\mathbf{u}) = \\frac{1}{2}\\|\\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}}\\|_2^2 = \\frac{1}{2}(\\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}})^\\ast(\\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}})$。\n\n$J$ 相对于参数 $\\boldsymbol{\\varepsilon}_r$ 的梯度由拉格朗日函数的偏导数给出，即 $\\frac{dJ}{d\\boldsymbol{\\varepsilon}_r} = \\frac{\\partial\\mathcal{L}}{\\partial\\boldsymbol{\\varepsilon}_r}$，前提是定常条件 $\\frac{\\partial\\mathcal{L}}{\\partial\\mathbf{u}} = 0$ 和 $\\frac{\\partial\\mathcal{L}}{\\partial\\mathbf{p}} = 0$ 成立。后者仅恢复了状态方程 $\\mathbf{A}\\mathbf{u}=\\mathbf{b}$。前者定义了伴随方程。\n\n使用复（Wirtinger）分析，关于 $\\mathbf{u}$（具体是其共轭 $\\mathbf{u}^\\ast$）的定常条件是 $\\frac{\\partial \\mathcal{L}}{\\partial \\mathbf{u}^\\ast} = 0$。我们有：\n$$\n\\frac{\\partial J}{\\partial \\mathbf{u}^\\ast} = \\frac{1}{2}\\mathbf{P}^\\ast(\\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}})\n$$\n项 $\\Re[\\mathbf{p}^\\ast \\mathbf{A}\\mathbf{u}]$ 可以写成 $\\frac{1}{2}(\\mathbf{p}^\\ast \\mathbf{A}\\mathbf{u} + \\mathbf{u}^\\ast \\mathbf{A}^\\ast \\mathbf{p})$。它关于 $\\mathbf{u}^\\ast$ 的导数是 $\\frac{1}{2}\\mathbf{A}^\\ast\\mathbf{p}$。因此，定常条件变为：\n$$\n\\frac{\\partial\\mathcal{L}}{\\partial \\mathbf{u}^\\ast} = \\frac{1}{2}\\mathbf{P}^\\ast(\\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}}) - \\frac{1}{2}\\mathbf{A}(\\boldsymbol{\\varepsilon}_r)^\\ast\\mathbf{p} = 0\n$$\n这导出了**伴随方程**：\n$$\n\\mathbf{A}(\\boldsymbol{\\varepsilon}_r)^\\ast \\mathbf{p} = \\mathbf{P}^\\ast(\\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}})\n$$\n这与问题陈述中给出的方程相符。定义了伴随态 $\\mathbf{p}$ 后，我们现在可以计算关于介电常数向量 $\\boldsymbol{\\varepsilon}_r$ 的梯度。$J$ 关于介电常数向量单个分量 $\\varepsilon_{r,j}$ 的全导数为：\n$$\n\\frac{dJ}{d\\varepsilon_{r,j}} = \\frac{\\partial \\mathcal{L}}{\\partial \\varepsilon_{r,j}} = -\\Re\\left[ \\mathbf{p}^\\ast \\frac{\\partial \\mathbf{A}(\\boldsymbol{\\varepsilon}_r)}{\\partial \\varepsilon_{r,j}} \\mathbf{u} \\right]\n$$\n离散算子为 $\\mathbf{A}(\\boldsymbol{\\varepsilon}_r) = \\mathbf{L} + \\operatorname{diag}(-k_0^2 \\boldsymbol{\\varepsilon}_r + i\\tau)$。其关于 $\\varepsilon_{r,j}$ 的导数是一个在 $(j,j)$ 元素之外全为零的矩阵：\n$$\n\\frac{\\partial \\mathbf{A}(\\boldsymbol{\\varepsilon}_r)}{\\partial \\varepsilon_{r,j}} = -k_0^2 \\mathbf{e}_j \\mathbf{e}_j^T\n$$\n其中 $\\mathbf{e}_j$ 是第 $j$ 个标准基向量。将此代入梯度表达式：\n$$\n\\frac{dJ}{d\\varepsilon_{r,j}} = -\\Re\\left[ \\mathbf{p}^\\ast (-k_0^2 \\mathbf{e}_j \\mathbf{e}_j^T) \\mathbf{u} \\right] = \\Re\\left[ k_0^2 \\mathbf{p}^\\ast (\\mathbf{e}_j \\mathbf{e}_j^T \\mathbf{u}) \\right] = \\Re\\left[ k_0^2 (\\bar{p}_j u_j) \\right]\n$$\n其中 $p_j$ 和 $u_j$ 分别是伴随场和正向场的第 $j$ 个分量。因此，关于介电常数的梯度的逐点表达式为：\n$$\n\\frac{\\partial J}{\\partial \\varepsilon_r}(\\mathbf{x}) = \\Re\\left( k_0^2 \\, \\overline{p(\\mathbf{x})} \\, u(\\mathbf{x}) \\right)\n$$\n这完成了任务 (a)。\n\n### 水平集梯度组装\n\n对于任务 (b)，我们使用提供的链式法则组装关于水平集函数 $\\phi$ 的梯度：\n$$\n\\mathcal{G}(\\mathbf{x}) = \\frac{\\partial J}{\\partial \\phi}(\\mathbf{x}) = \\frac{\\partial J}{\\partial \\varepsilon_r}(\\mathbf{x}) \\cdot \\frac{\\partial \\varepsilon_r}{\\partial \\phi}(\\mathbf{x})\n$$\n问题中指定了介电常数参数化的导数：\n$$\n\\frac{\\partial \\varepsilon_r}{\\partial \\phi}(\\mathbf{x}) = (\\varepsilon_{\\text{in}} - \\varepsilon_{\\text{out}}) (-\\delta_\\beta(\\phi(\\mathbf{x})))\n$$\n其中 $\\delta_\\beta$ 是平滑的狄拉克δ函数。将其与任务 (a) 的结果结合，我们得到每个网格点 $\\mathbf{x}$ 处水平集梯度的最终表达式：\n$$\n\\mathcal{G}(\\mathbf{x}) = - \\Re\\left( k_0^2 \\, \\overline{p(\\mathbf{x})} \\, u(\\mathbf{x}) \\right) \\cdot (\\varepsilon_{\\text{in}} - \\varepsilon_{\\text{out}}) \\delta_\\beta(\\phi(\\mathbf{x}))\n$$\n\n### 算法流程\n\n对于任务 (c)，我们实现一个程序，对每个测试用例执行以下步骤：\n1.  **设置**：定义网格参数（$N=30, h=1/31$）、网格坐标、离散拉普拉斯算子 $\\mathbf{L}$、源向量 $\\mathbf{b}$ 和探测器位置/索引。\n2.  **生成观测数据**：对于给定的测试用例，使用真实半径 $R_{\\text{true}}$ 构建“真实”介电常数 $\\boldsymbol{\\varepsilon}_{r, \\text{true}}$。组装真实系统矩阵 $\\mathbf{A}_{\\text{true}}$ 并求解正向问题 $\\mathbf{A}_{\\text{true}}\\mathbf{u}_{\\text{true}} = \\mathbf{b}$ 得到 $\\mathbf{u}_{\\text{true}}$。观测数据为 $\\mathbf{d}_{\\mathrm{obs}} = \\mathbf{P}\\mathbf{u}_{\\text{true}}$。\n3.  **求解正向问题**：使用重建半径 $R_{\\text{rec}}$ 构建“重建”介电常数 $\\boldsymbol{\\varepsilon}_{r, \\text{rec}}$。组装相应的矩阵 $\\mathbf{A}_{\\text{rec}}$ 并求解正向问题 $\\mathbf{A}_{\\text{rec}}\\mathbf{u} = \\mathbf{b}$ 以找到状态场 $\\mathbf{u}$。\n4.  **求解伴随问题**：计算数据残差 $\\mathbf{r} = \\mathbf{P}\\mathbf{u} - \\mathbf{d}_{\\mathrm{obs}}$。构建伴随源 $\\mathbf{b}_{\\text{adj}} = \\mathbf{P}^\\ast \\mathbf{r}$。求解伴随系统 $\\mathbf{A}_{\\text{rec}}^\\ast \\mathbf{p} = \\mathbf{b}_{\\text{adj}}$ 以得到伴随场 $\\mathbf{p}$。\n5.  **组装梯度**：\n    *   在每个网格点 $j$ 计算介电常数梯度项：$\\left(\\frac{\\partial J}{\\partial \\varepsilon_r}\\right)_j = \\Re(k_0^2 \\, \\bar{p}_j \\, u_j)$。\n    *   使用 $R_{\\text{rec}}$ 计算水平集函数 $\\phi(\\mathbf{x}_j)$。\n    *   在每个网格点 $j$ 计算链式法则因子：$\\left(\\frac{\\partial \\varepsilon_r}{\\partial \\phi}\\right)_j = (\\varepsilon_{\\text{in}} - \\varepsilon_{\\text{out}}) (-\\delta_\\beta(\\phi(\\mathbf{x}_j)))$。\n    *   将它们组合起来得到水平集梯度向量：$\\mathcal{G}_j = \\left(\\frac{\\partial J}{\\partial \\varepsilon_r}\\right)_j \\cdot \\left(\\frac{\\partial \\varepsilon_r}{\\partial \\phi}\\right)_j$。\n6.  **计算范数**：计算梯度的离散 $\\ell^2$ 范数：$\\|\\mathcal{G}\\|_{2,h} = \\left( \\sum_{j=1}^{N^2} |\\mathcal{G}_j|^2 h^2 \\right)^{1/2}$。此值为该测试用例的结果。\n\n对测试套件中的所有测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the adjoint-state gradient assembly problem for the given test cases.\n    \"\"\"\n    # Common setup parameters\n    N = 30\n    h = 1.0 / (N + 1)\n    tau = 1.0\n    src_pos = (0.2, 0.5)\n    \n    # Detector positions\n    det_pos = []\n    # 8 detectors on a ring\n    r_d, x_c, y_c = 0.45, 0.5, 0.5\n    for m in range(8):\n        angle = 2.0 * np.pi * m / 8.0\n        det_pos.append((x_c + r_d * np.cos(angle), y_c + r_d * np.sin(angle)))\n    # 2 interior detectors\n    det_pos.extend([(0.5, 0.3), (0.5, 0.7)])\n    \n    # Test case suite\n    test_cases = [\n        # (k0, eps_in, eps_out, beta_factor, R_true, R_rec)\n        (5.0, 4.0, 1.0, 2.0, 0.25, 0.25),\n        (5.0, 4.0, 1.0, 2.0, 0.30, 0.20),\n        (3.0, 2.0, 1.0, 0.5, 0.30, 0.20),\n    ]\n\n    # --- Grid and Operator Setup ---\n    # Create 1D and 2D grid coordinates\n    grid_1d = np.linspace(h, 1.0 - h, N)\n    X, Y = np.meshgrid(grid_1d, grid_1d)\n    coords_flat = np.vstack((X.ravel(), Y.ravel())).T\n\n    # 1D Laplacian matrix T\n    T_diags = [-1.0, 2.0, -1.0]\n    T_offsets = [-1, 0, 1]\n    T = sparse.diags(T_diags, T_offsets, shape=(N, N)) / h**2\n    \n    # 2D Laplacian operator L using Kronecker sum\n    I_N = sparse.eye(N)\n    L = sparse.kronsum(T, T).tocsc()\n\n    # Source vector b\n    src_x_idx = int(round(src_pos[0] / h)) - 1\n    src_y_idx = int(round(src_pos[1] / h)) - 1\n    src_flat_idx = src_y_idx * N + src_x_idx\n    b = np.zeros(N**2, dtype=complex)\n    b[src_flat_idx] = 1.0\n\n    # Detector indices\n    det_indices = []\n    for x_d, y_d in det_pos:\n        det_x_idx = int(round(x_d / h)) - 1\n        det_y_idx = int(round(y_d / h)) - 1\n        det_indices.append(det_y_idx * N + det_x_idx)\n    det_indices = np.array(det_indices)\n\n    # --- Helper Functions ---\n    def H_beta(s, beta):\n        res = np.zeros_like(s)\n        mask_mid = np.abs(s)  beta\n        s_mid = s[mask_mid]\n        res[s >= beta] = 1.0\n        res[mask_mid] = 0.5 * (1.0 + s_mid / beta + (1.0 / np.pi) * np.sin(np.pi * s_mid / beta))\n        return res\n\n    def delta_beta(s, beta):\n        res = np.zeros_like(s)\n        mask = np.abs(s)  beta\n        s_mid = s[mask]\n        res[mask] = (0.5 / beta) * (1.0 + np.cos(np.pi * s_mid / beta))\n        return res\n    \n    def get_epsilon_r(R, beta, eps_in, eps_out):\n        phi_center = (0.5, 0.5)\n        dist = np.sqrt((coords_flat[:, 0] - phi_center[0])**2 + (coords_flat[:, 1] - phi_center[1])**2)\n        phi = dist - R\n        return eps_out + (eps_in - eps_out) * (1.0 - H_beta(phi, beta))\n\n    results = []\n    for case in test_cases:\n        k0, eps_in, eps_out, beta_factor, R_true, R_rec = case\n        beta = beta_factor * h\n\n        # 1. Generate observed data d_obs\n        eps_r_true = get_epsilon_r(R_true, beta, eps_in, eps_out)\n        A_true_diag = -k0**2 * eps_r_true + 1j * tau\n        A_true = L + sparse.diags(A_true_diag)\n        u_true = spsolve(A_true, b)\n        d_obs = u_true[det_indices]\n\n        # 2. Solve forward problem for reconstruction state u\n        eps_r_rec = get_epsilon_r(R_rec, beta, eps_in, eps_out)\n        A_rec_diag = -k0**2 * eps_r_rec + 1j * tau\n        A_rec = L + sparse.diags(A_rec_diag)\n        u = spsolve(A_rec, b)\n\n        # 3. Solve adjoint problem for p\n        residual = u[det_indices] - d_obs\n        b_adj = np.zeros(N**2, dtype=complex)\n        b_adj[det_indices] = residual\n        \n        A_adj = A_rec.conj().T\n        p = spsolve(A_adj, b_adj)\n\n        # 4. Assemble level-set gradient G\n        dJ_deps = np.real(k0**2 * np.conj(p) * u)\n        \n        phi_center = (0.5, 0.5)\n        dist_rec = np.sqrt((coords_flat[:, 0] - phi_center[0])**2 + (coords_flat[:, 1] - phi_center[1])**2)\n        phi_rec = dist_rec - R_rec\n        \n        deps_dphi = (eps_in - eps_out) * (-delta_beta(phi_rec, beta))\n        \n        G = dJ_deps * deps_dphi\n        \n        # 5. Compute the norm of the gradient\n        norm_G = np.sqrt(np.sum(np.abs(G)**2) * h**2)\n        results.append(norm_G)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一旦计算出形状梯度（它可被视为一个速度场 $V$），我们就需要用它来实际移动形状的边界。本练习旨在解决下一个关键步骤：根据这个速度场演化水平集函数。您将实现并比较两种用于求解控制水平集演化的哈密顿-雅可比方程的基本数值格式（一种稳定的迎风格式和一种更简单的中心差分格式），从而深入理解形状优化所需的数值稳定性和准确性。",
            "id": "3323768",
            "problem": "您的任务是为用于计算电磁学中形状重构的水平集偏微分方程 (PDE) 推导并实现两种数值离散格式。从基本原理出发，构建算法。最终目标是在一组受控的合成速度场上比较这两种格式，这些速度场模仿了电磁逆散射中由形状梯度导出的下降方向。\n\n考虑一个二维计算域 $\\Omega = [0,1]\\times[0,1]$，该区域由一个包含 $N\\times N$ 个点的均匀笛卡尔网格离散化（其中 $N$ 在测试套件中指定）。设水平集函数表示为 $\\phi(x,y,t)$，按照约定，预测的形状对应于子水平集 $\\{\\phi0\\}$。其演化方程为\n$$\n\\frac{\\partial \\phi}{\\partial t} + V(x,y)\\, \\lvert\\nabla \\phi\\rvert \\;=\\; \\mu\\,\\kappa(\\phi)\\,\\lvert\\nabla \\phi\\rvert,\n$$\n其中 $V(x,y)$ 是一个给定的法向速度场，表示与形状梯度成比例的下降方向；$\\mu0$ 是一个曲率正则化参数；$\\kappa(\\phi)$ 是由下式定义的水平集的平均曲率\n$$\n\\kappa(\\phi) \\;=\\; \\nabla \\cdot \\left(\\frac{\\nabla \\phi}{\\lvert \\nabla \\phi \\rvert}\\right),\n$$\n分母中采用标准的 $\\epsilon$-正则化以避免除以零。\n\n关于电磁学背景以及 $V(x,y)$ 的来源：在用于横电 (TE) 极化的频域麦克斯韦方程组中，总电场 $E_z$ 满足从非均匀介质中的麦克斯韦方程组导出的 Helmholtz 方程。一个典型的逆问题是最小化一个失配泛函 $J(\\Omega)=\\frac{1}{2}\\int_{\\Gamma}\\lvert E^{\\mathrm{comp}}(\\Omega)-E^{\\mathrm{meas}}\\rvert^2\\,\\mathrm{d}s$，其中 $\\Gamma$ 是一条观测曲线。$J$ 的形状导数或拓扑导数提供了一个下降方向，其在法线上的投影产生了一个适合水平集演化的速度 $V(x,y)$，即界面法向运动使得 $J$ 下降。在本任务中，$V(x,y)$ 将作为合成场提供，这些场是此类下降方向在科学上合理的代理。\n\n您的任务是：\n- 从基本原理出发，为 Hamilton-Jacobi 项 $V(x,y)\\lvert\\nabla \\phi\\rvert$ 和曲率项推导两种一致的半离散近似。\n    1. 一种用于 Hamilton-Jacobi 项的单调迎风 Godunov 格式，该格式考虑 $V(x,y)$ 的符号，并使用单边差分来近似 $\\lvert\\nabla \\phi\\rvert$，以符合因果关系。\n    2. 一种用于 Hamilton-Jacobi 项的中心差分基线格式，该格式使用中心差分计算 $\\nabla \\phi$，并从这些中心差分计算 $\\lvert\\nabla \\phi\\rvert$。\n- 对于曲率项，使用 $\\nabla \\phi$ 的中心差分近似，构造单位法向量 $n=\\nabla\\phi/\\lvert\\nabla\\phi\\rvert$，并用中心差分近似 $\\kappa(\\phi)=\\nabla\\cdot n$。对于 $\\epsilon0$，使用一个 $\\epsilon$-正则化分母 $\\lvert\\nabla\\phi\\rvert_{\\epsilon}=\\sqrt{\\phi_x^2+\\phi_y^2+\\epsilon^2}$。\n- 采用齐次 Neumann 边界条件（法向导数为零），通过将那些单边模板会延伸到域外的边界有限差分设置为零来实现。\n- 使用显式前向欧拉时间积分 $t^{n+1}=t^n+\\Delta t$。通过 Courant–Friedrichs–Lewy (CFL) 条件选择时间步长 $\\Delta t$，其系数为 $c_{\\mathrm{CFL}}$，网格间距为 $h$，即 $\\Delta t = c_{\\mathrm{CFL}}\\frac{h}{\\max_{x,y}\\lvert V(x,y)\\rvert+\\delta}$，其中 $\\delta$ 是一个小的正数，以在 $V\\equiv 0$ 时避免除以零。\n\n初始化和单位：\n- 将 $\\phi(x,y,0)$ 初始化为到以 $(x_0,y_0)$ 为中心、半径为 $r_0$ 的圆的符号距离，即\n$$\n\\phi(x,y,0) = \\sqrt{(x-x_0)^2+(y-y_0)^2}-r_0,\n$$\n其中 $(x_0,y_0)=(0.5,0.5)$ 且 $r_0=0.25$。所有量均为无量纲。\n\n实现这两种格式，并对每个测试用例执行单个时间步。对于每个测试用例，计算并返回两种格式之间的定量差异度量：\n$$\n\\mathrm{err} = \\left(\\frac{1}{N^2}\\sum_{i,j}\\left(\\phi^{n+1}_{\\mathrm{upwind}}(i,j)-\\phi^{n+1}_{\\mathrm{central}}(i,j)\\right)^2\\right)^{1/2}.\n$$\n\n测试套件：\n- 使用 $N=64$，域 $[0,1]\\times[0,1]$，网格间距 $h=1/(N-1)$，以及单步前向欧拉法。对于每个测试用例，按指定设置 $(\\mu,\\epsilon,c_{\\mathrm{CFL}})$。\n    1. 理想情况: $V(x,y)=\\alpha \\exp\\left(-\\frac{(x-0.5)^2+(y-0.5)^2}{\\sigma^2}\\right)$，其中 $\\alpha=2.0$, $\\sigma^2=0.02$, $\\mu=0.01$, $\\epsilon=10^{-6}$, $c_{\\mathrm{CFL}}=0.25$。\n    2. 边界驱动: $V(x,y)=\\alpha$ 当 $x0.05$ 时，否则 $V(x,y)=0$；$\\alpha=1.5$, $\\mu=0.005$, $\\epsilon=10^{-6}$, $c_{\\mathrm{CFL}}=0.30$。\n    3. 曲率主导: $V(x,y)=0$ 恒成立；$\\mu=0.02$, $\\epsilon=10^{-6}$, $c_{\\mathrm{CFL}}=0.45$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，即 $[\\mathrm{err}_1,\\mathrm{err}_2,\\mathrm{err}_3]$，其中 $\\mathrm{err}_k$ 是测试用例 $k$ 的差异。所有输出都是无量纲浮点数。",
            "solution": "目标是为给定的水平集演化方程推导并实现两种不同的数值格式：\n$$\n\\frac{\\partial \\phi}{\\partial t} + V(x,y)\\, \\lvert\\nabla \\phi\\rvert \\;=\\; \\mu\\,\\kappa(\\phi)\\,\\lvert\\nabla \\phi\\rvert\n$$\n该偏微分方程 (PDE) 模拟了水平集函数 $\\phi(x,y,t)$ 的演化。该方程可以重排以突出其组成部分：一个对流 Hamilton-Jacobi (HJ) 项和一个正则化曲率项。其半离散形式为：\n$$\n\\frac{d\\phi}{dt} = -V(x,y)\\,\\lvert\\nabla \\phi\\rvert + \\mu\\,\\kappa(\\phi)\\,\\lvert\\nabla \\phi\\rvert = -H(\\phi) + C(\\phi)\n$$\n其中 $H(\\phi)$ 表示 HJ 项，$C(\\phi)$ 表示曲率项。我们将开发两种格式，它们在 Hamilton-Jacobi 项 $H(\\phi)$ 的近似上有所不同，但对曲率项 $C(\\phi)$ 使用共同的中心离散近似。\n\n我们考虑在域 $\\Omega = [0,1]\\times[0,1]$ 上的一个具有 $N \\times N$ 个点的均匀笛卡尔网格。在 $x$ 和 $y$ 方向上的网格间距均为 $h = 1/(N-1)$。在网格点 $(x_i, y_j) = (ih, jh)$ 和时间 $t_n = n\\Delta t$ 的离散水平集函数表示为 $\\phi_{i,j}^n$。\n\n时间演化通过显式前向欧拉格式处理：\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^n + \\Delta t \\left( -H_{i,j}(\\phi^n) + C_{i,j}(\\phi^n) \\right)\n$$\n时间步长 $\\Delta t$ 由 Courant-Friedrichs-Lewy (CFL) 条件确定：\n$$\n\\Delta t = c_{\\mathrm{CFL}}\\frac{h}{\\max_{i,j}\\lvert V_{i,j}\\rvert+\\delta}\n$$\n其中 $c_{\\mathrm{CFL}}$ 是 CFL 因子，$\\delta$ 是一个小的正常数（我们选择 $\\delta=10^{-9}$）以防止除以零。\n\n### 空间离散化\n齐次 Neumann 边界条件通过将任何需要域外点的有限差分模板设置为零来施加。\n\n#### 曲率项离散化（两种格式通用）\n曲率项为 $C(\\phi) = \\mu\\,\\kappa(\\phi)\\,\\lvert\\nabla \\phi\\rvert$。平均曲率为 $\\kappa(\\phi) = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{\\lvert\\nabla \\phi\\rvert} \\right)$。\n\n1.  **梯度近似**：我们首先使用二阶中心差分在每个网格点 $(i,j)$ 处近似 $\\nabla \\phi$：\n    $$\n    (\\phi_x)_{i,j} = \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2h}, \\quad (\\phi_y)_{i,j} = \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2h}\n    $$\n    在边界处，根据 Neumann 条件，这些导数被设置为零。例如，在 $i=0$ 处，$(\\phi_x)_{0,j} = 0$。\n\n2.  **正则化梯度模**：梯度的模被正则化以防止除以零：\n    $$\n    \\lvert\\nabla\\phi\\rvert_{\\epsilon, i,j} = \\sqrt{(\\phi_x)_{i,j}^2 + (\\phi_y)_{i,j}^2 + \\epsilon^2}\n    $$\n\n3.  **单位法向量**：然后计算单位法向量 $n = (n_x, n_y)$ 的分量：\n    $$\n    (n_x)_{i,j} = \\frac{(\\phi_x)_{i,j}}{\\lvert\\nabla\\phi\\rvert_{\\epsilon, i,j}}, \\quad (n_y)_{i,j} = \\frac{(\\phi_y)_{i,j}}{\\lvert\\nabla\\phi\\rvert_{\\epsilon, i,j}}\n    $$\n\n4.  **曲率（法向量的散度）**：曲率 $\\kappa = \\nabla \\cdot n$ 也使用中心差分进行近似：\n    $$\n    \\kappa_{i,j} = \\frac{(n_x)_{i+1,j} - (n_x)_{i-1,j}}{2h} + \\frac{(n_y)_{i,j+1} - (n_y)_{i,j-1}}{2h}\n    $$\n    在边界处，像 $\\frac{\\partial n_x}{\\partial x}$ 这样的导数被设置为零。这需要首先在整个网格上计算 $n_x$ 和 $n_y$，然后对散度应用中心差分算子。\n\n5.  **完整曲率项**：完整的离散化曲率项为：\n    $$\n    C_{i,j}(\\phi) = \\mu \\cdot \\kappa_{i,j} \\cdot \\lvert\\nabla\\phi\\rvert_{\\epsilon, i,j}\n    $$\n\n#### Hamilton-Jacobi 项离散化\n这一项，$H(\\phi) = V(x,y)\\lvert\\nabla\\phi\\rvert$，是两种格式产生差异的地方。\n\n**1. 中心差分格式**\n这是一种基线的非迎风格式。它使用与曲率项相同的中心差分近似。\n$$\nH_{i,j}^{\\text{central}}(\\phi) = V_{i,j} \\cdot \\lvert\\nabla\\phi\\rvert_{\\epsilon, i,j}\n$$\n其中 $\\lvert\\nabla\\phi\\rvert_{\\epsilon, i,j}$ 是先前从 $\\phi$ 的中心差分计算出的相同正则化梯度模。\n\n**2. 迎风 Godunov 格式**\n该格式通过使用基于信息流动方向选择的单边差分，为 Hamilton-Jacobi 方程提供了更稳定的离散化。信息流动方向由速度场 $V(x,y)$ 的符号确定。\n\n首先，我们定义单边有限差分算子：\n-   前向差分：$D_x^+\\phi_{i,j} = \\frac{\\phi_{i+1,j}-\\phi_{i,j}}{h}$，$D_y^+\\phi_{i,j} = \\frac{\\phi_{i,j+1}-\\phi_{i,j}}{h}$\n-   后向差分：$D_x^-\\phi_{i,j} = \\frac{\\phi_{i,j}-\\phi_{i-1,j}}{h}$，$D_y^-\\phi_{i,j} = \\frac{\\phi_{i,j}-\\phi_{i,j-1}}{h}$\n在边界处，指向外部的模板设置为零。\n\n数值哈密顿量是基于 Engquist-Osher 格式构建的。我们将速度 $V_{i,j}$ 分解为其正部和负部，$V_{i,j}^+ = \\max(V_{i,j}, 0)$ 和 $V_{i,j}^- = \\min(V_{i,j}, 0)$。\n\n-   对于 $V_{i,j}  0$（向外传播），信息从形状内部（$\\phi  0$）流出。迎风梯度模为：\n    $$\n    |\\nabla\\phi|_{i,j}^{+, \\text{upwind}} = \\sqrt{ \\left(\\max(D_x^-\\phi_{i,j}, 0)\\right)^2 + \\left(\\min(D_x^+\\phi_{i,j}, 0)\\right)^2 + \\left(\\max(D_y^-\\phi_{i,j}, 0)\\right)^2 + \\left(\\min(D_y^+\\phi_{i,j}, 0)\\right)^2 }\n    $$\n-   对于 $V_{i,j}  0$（向内传播），信息从外部（$\\phi  0$）流入。迎风梯度模为：\n    $$\n    |\\nabla\\phi|_{i,j}^{-, \\text{upwind}} = \\sqrt{ \\left(\\min(D_x^-\\phi_{i,j}, 0)\\right)^2 + \\left(\\max(D_x^+\\phi_{i,j}, 0)\\right)^2 + \\left(\\min(D_y^-\\phi_{i,j}, 0)\\right)^2 + \\left(\\max(D_y^+\\phi_{i,j}, 0)\\right)^2 }\n    $$\n\n完整的迎风 Hamilton-Jacobi 项是这些贡献的总和：\n$$\nH_{i,j}^{\\text{upwind}}(\\phi) = V_{i,j}^+ \\cdot |\\nabla\\phi|_{i,j}^{+, \\text{upwind}} + V_{i,j}^- \\cdot |\\nabla\\phi|_{i,j}^{-, \\text{upwind}}\n$$\n请注意，为保证数值稳定性，在实现时，在平方根内隐式地添加了一个小的 $\\epsilon$ 项。\n\n### 最终算法\n对于每个测试用例：\n1.  将 $\\phi^0$ 初始化为到圆的符号距离。\n2.  计算时间步长 $\\Delta t$。\n3.  使用中心差分计算公共曲率项 $C(\\phi^0)$。\n4.  计算中心差分 HJ 项 $H^{\\text{central}}(\\phi^0)$。\n5.  计算迎风 HJ 项 $H^{\\text{upwind}}(\\phi^0)$。\n6.  对每种格式执行一个前向欧拉步：\n    $$\n    \\phi^{\\text{central}, 1} = \\phi^0 + \\Delta t \\left( -H^{\\text{central}}(\\phi^0) + C(\\phi^0) \\right)\n    $$\n    $$\n    \\phi^{\\text{upwind}, 1} = \\phi^0 + \\Delta t \\left( -H^{\\text{upwind}}(\\phi^0) + C(\\phi^0) \\right)\n    $$\n7.  计算两个结果场之间的均方根差异：\n    $$\n    \\mathrm{err} = \\left(\\frac{1}{N^2}\\sum_{i,j=0}^{N-1}\\left(\\phi^{\\text{upwind}, 1}_{i,j}-\\phi^{\\text{central}, 1}_{i,j}\\right)^2\\right)^{1/2}\n    $$\nHJ 项近似 $H^{\\text{central}}$ 和 $H^{\\text{upwind}}$ 的差异是这种差异的唯一来源。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements two numerical schemes for a level-set PDE,\n    and computes the discrepancy between them for a set of test cases.\n    \"\"\"\n\n    def get_initial_phi(x, y, x0=0.5, y0=0.5, r0=0.25):\n        \"\"\"Initializes phi as a signed distance to a circle.\"\"\"\n        return np.sqrt((x - x0)**2 + (y - y0)**2) - r0\n\n    def get_velocity_field(x, y, case):\n        \"\"\"Generates the velocity field V(x,y) for a given test case.\"\"\"\n        if case == 1:\n            alpha, sigma2 = 2.0, 0.02\n            return alpha * np.exp(-((x - 0.5)**2 + (y - 0.5)**2) / sigma2)\n        elif case == 2:\n            alpha = 1.5\n            V = np.zeros_like(x)\n            V[x  0.05] = alpha\n            return V\n        elif case == 3:\n            return np.zeros_like(x)\n        return None\n\n    def compute_derivatives_central(phi, h):\n        \"\"\"Computes central differences for the gradient.\"\"\"\n        phi_x = np.zeros_like(phi)\n        phi_y = np.zeros_like(phi)\n\n        phi_x[1:-1, :] = (phi[2:, :] - phi[:-2, :]) / (2 * h)\n        phi_y[:, 1:-1] = (phi[:, 2:] - phi[:, :-2]) / (2 * h)\n        \n        return phi_x, phi_y\n\n    def compute_derivatives_one_sided(phi, h):\n        \"\"\"Computes one-sided differences.\"\"\"\n        phi_x_p = np.zeros_like(phi)\n        phi_x_m = np.zeros_like(phi)\n        phi_y_p = np.zeros_like(phi)\n        phi_y_m = np.zeros_like(phi)\n\n        phi_x_p[:-1, :] = (phi[1:, :] - phi[:-1, :]) / h\n        phi_x_m[1:, :] = (phi[1:, :] - phi[:-1, :]) / h\n        \n        phi_y_p[:, :-1] = (phi[:, 1:] - phi[:, :-1]) / h\n        phi_y_m[:, 1:] = (phi[:, 1:] - phi[:, :-1]) / h\n        \n        return phi_x_p, phi_x_m, phi_y_p, phi_y_m\n\n    def compute_rhs(phi, h, V, mu, epsilon, scheme):\n        \"\"\"Computes the right-hand side of the PDE evolution.\"\"\"\n        # Common Curvature Term Calculation\n        phi_x_c, phi_y_c = compute_derivatives_central(phi, h)\n        grad_phi_mag_central_eps = np.sqrt(phi_x_c**2 + phi_y_c**2 + epsilon**2)\n        \n        nx = phi_x_c / grad_phi_mag_central_eps\n        ny = phi_y_c / grad_phi_mag_central_eps\n\n        nx_x, _ = compute_derivatives_central(nx, h)\n        _, ny_y = compute_derivatives_central(ny, h)\n        \n        kappa = nx_x + ny_y\n        \n        curvature_term = mu * kappa * grad_phi_mag_central_eps\n\n        # Hamilton-Jacobi Term Calculation\n        if scheme == 'central':\n            hj_term = V * grad_phi_mag_central_eps\n        elif scheme == 'upwind':\n            phi_x_p, phi_x_m, phi_y_p, phi_y_m = compute_derivatives_one_sided(phi, h)\n            \n            V_pos = np.maximum(V, 0)\n            V_neg = np.minimum(V, 0)\n\n            grad_mag_sq_pos = (np.maximum(phi_x_m, 0))**2 + (np.minimum(phi_x_p, 0))**2 + \\\n                              (np.maximum(phi_y_m, 0))**2 + (np.minimum(phi_y_p, 0))**2\n            \n            grad_mag_sq_neg = (np.minimum(phi_x_m, 0))**2 + (np.maximum(phi_x_p, 0))**2 + \\\n                              (np.minimum(phi_y_m, 0))**2 + (np.maximum(phi_y_p, 0))**2\n\n            hj_term = V_pos * np.sqrt(grad_mag_sq_pos + epsilon**2) + \\\n                      V_neg * np.sqrt(grad_mag_sq_neg + epsilon**2)\n        \n        return -hj_term + curvature_term\n\n    # General parameters\n    N = 64\n    h = 1.0 / (N - 1)\n    delta = 1e-9\n    \n    # Grid setup\n    x_1d = np.linspace(0.0, 1.0, N)\n    y_1d = np.linspace(0.0, 1.0, N)\n    x, y = np.meshgrid(x_1d, y_1d, indexing='ij')\n\n    # Initial condition\n    phi_0 = get_initial_phi(x, y)\n\n    # Test suite\n    test_cases = [\n        # (case_id, mu, epsilon, cfl_factor)\n        (1, 0.01, 1e-6, 0.25),\n        (2, 0.005, 1e-6, 0.30),\n        (3, 0.02, 1e-6, 0.45)\n    ]\n    \n    results = []\n    \n    for case_id, mu, epsilon, cfl_factor in test_cases:\n        # Get velocity field for the case\n        V = get_velocity_field(x, y, case_id)\n        \n        # Calculate time step\n        max_v = np.max(np.abs(V))\n        dt = cfl_factor * h / (max_v + delta)\n\n        # Compute one step for central scheme\n        rhs_central = compute_rhs(phi_0, h, V, mu, epsilon, 'central')\n        phi_central_step = phi_0 + dt * rhs_central\n\n        # Compute one step for upwind scheme\n        rhs_upwind = compute_rhs(phi_0, h, V, mu, epsilon, 'upwind')\n        phi_upwind_step = phi_0 + dt * rhs_upwind\n\n        # Calculate discrepancy\n        err = np.sqrt(np.mean((phi_upwind_step - phi_central_step)**2))\n        results.append(err)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际场景中，我们常常使用多种不同的入射波来探测一个物体，如果每次入射都需要求解一个伴随问题，这将导致巨大的计算成本。这个高级实践介绍了一个强大的理论工具——互易性原理，来显著降低这种计算负担。通过重新表述梯度，您将学习如何用少数几次类正向求解来替代大量的伴随求解，这是使大规模反演问题在计算上变得可行的一项关键技术。",
            "id": "3323776",
            "problem": "考虑一个在有界域 $\\Omega \\subset \\mathbb{R}^{2}$ 中的二维时谐横电 (TE) 散射问题，其单位外法线为 $\\mathbf{n}$。在角频率为 $\\omega$ 的第 $p$ 次照明下，平面外电场 $u_{p}(\\mathbf{r}) \\in \\mathbb{C}$ 满足标量亥姆霍兹方程\n$$\n\\nabla \\cdot \\left(\\mu^{-1}(\\mathbf{r}) \\nabla u_{p}(\\mathbf{r})\\right) + \\omega^{2} \\,\\epsilon(\\mathbf{r};\\phi)\\, u_{p}(\\mathbf{r}) = q_{p}(\\mathbf{r}) \\quad \\text{在 } \\Omega \\text{ 中},\n$$\n在 $\\partial \\Omega$ 上具有互易且能量守恒的边界条件，这些条件使得算子在实值系数下是自伴的。假设 $\\mu(\\mathbf{r})0$ 且介电常数通过一个平滑指示函数由水平集函数 $\\phi$ 参数化，\n$$\n\\epsilon(\\mathbf{r};\\phi) = \\epsilon_{0} + \\left(\\epsilon_{1} - \\epsilon_{0}\\right) H_{\\beta}\\!\\left(\\phi(\\mathbf{r})\\right),\n$$\n其中 $H_{\\beta}$ 是亥维赛德函数的一个光滑近似，其导数为 $H'_{\\beta}=\\delta_{\\beta}$。设计变量是 $\\phi$，且 $\\epsilon_{0},\\epsilon_{1}0$ 是常数。\n\n测量由一个线性算子 $C: L^{2}(\\Omega) \\to \\mathbb{C}^{M}$ 建模，其形式为\n$$\n\\left[C u\\right]_{m} = \\int_{\\Omega} c_{m}(\\mathbf{r})\\, u(\\mathbf{r})\\, d\\mathbf{r}, \\quad m=1,\\dots,M,\n$$\n其中 $c_{m} \\in L^{2}(\\Omega)$ 是实值的、平方可积的传感器分布。设 $d_{p} \\in \\mathbb{C}^{M}$ 表示第 $p$ 次照明的数据，定义最小二乘失配函数\n$$\nJ(\\phi) = \\frac{1}{2} \\sum_{p=1}^{P} \\left\\| C u_{p} - d_{p} \\right\\|_{2}^{2},\n$$\n其中每个 $u_{p}$ 都是在当前 $\\phi$ 下求解正问题得到的。\n\n从简化为 TE 标量亥姆霍兹形式的麦克斯韦方程组出发，利用复 $L^{2}$ 内积的伴随定义以及电磁互易性（对于实介质和互易边界，格林函数的对称性），执行拉格朗日形式主义，推导 $J$ 相对于 $\\phi$ 的弗雷歇导数。然后，利用互易性，通过引入 $M$ 个互易的“接收场” $w_{m}$ 来消除每次照明都需要进行一次伴随求解的需要。这些接收场仅依赖于测量模式 $c_{m}$ 和当前介质 $\\epsilon(\\cdot;\\phi)$，而不依赖于照明索引 $p$。\n\n具体来说，定义数据残差 $r_{p} = C u_{p} - d_{p} \\in \\mathbb{C}^{M}$，其分量为 $r_{p,m} = \\left[C u_{p}\\right]_{m} - d_{p,m}$。证明存在场 $w_{m}$，它们求解的是以 $c_{m}$ 构造的右端项的正向型方程，使得全梯度 $\\delta J/\\delta \\phi$ 可以仅用 $\\{u_{p}\\}_{p=1}^{P}$、$\\{w_{m}\\}_{m=1}^{M}$ 和 $\\{r_{p,m}\\}$ 来表示，而无需进行以 $p$ 为索引的伴随求解。\n\n你的最终答案必须是点态梯度 $\\delta J/\\delta \\phi(\\mathbf{r})$ 的一个单一闭式解析表达式，用 $\\omega$、$\\epsilon_{0}$、$\\epsilon_{1}$、$\\delta_{\\beta}$、正向场 $u_{p}$、接收场 $w_{m}$ 和残差 $r_{p,m}$ 来表示。不要提供不等式或待解方程；答案必须是 $\\delta J/\\delta \\phi(\\mathbf{r})$ 的显式表达式。如果出现任何复数量，你的表达式必须在构造上是实值的。将最终结果表示为 $\\mathbf{r}$ 的函数，并且不要在最终表达式中包含物理单位。",
            "solution": "用户想要推导一个代价泛函 $J$ 相对于一个水平集函数 $\\phi$ 的弗雷歇导数，该问题是关于由 TE 亥姆霍兹方程控制的逆散射问题。推导过程必须首先使用拉格朗日方法找到基于伴随的梯度，然后利用互易性将其重新表述为前向传播的“接收场”的形式，从而避免为每次照明都进行一次伴随求解。\n\n### 第一步：问题验证\n我已对问题陈述进行了验证。\n\n-   **提取的已知条件**：\n    1.  **正问题**：$\\nabla \\cdot (\\mu^{-1} \\nabla u_p) + \\omega^2 \\epsilon(\\mathbf{r};\\phi) u_p = q_p$，在 $\\Omega \\subset \\mathbb{R}^2$ 中。\n    2.  **介电常数**：$\\epsilon(\\mathbf{r};\\phi) = \\epsilon_0 + (\\epsilon_1 - \\epsilon_0)H_\\beta(\\phi(\\mathbf{r}))$。\n    3.  **测量算子**：$[Cu]_m = \\int_{\\Omega} c_m(\\mathbf{r})u(\\mathbf{r}) d\\mathbf{r}$，其中 $c_m$ 为实数。\n    4.  **代价泛函**：$J(\\phi) = \\frac{1}{2} \\sum_{p=1}^{P} \\|Cu_p - d_p\\|_2^2$。\n    5.  **算子性质**：正向算子在实值系数下是自伴的，这是互易性和指定边界条件的结果。\n\n-   **验证结论**：该问题是**有效的**。它构成了计算反问题和优化领域中一个标准的、适定的任务。它具有科学依据，形式上明确，并且是客观的。推导所需的所有要素均已提供。\n\n### 第二步：弗雷歇导数的推导\n\n目标是求出弗雷歇导数 $\\frac{\\delta J}{\\delta \\phi}$，它是描述 $J$ 因微小扰动 $\\delta\\phi$ 而变化的线性泛函的核。我们采用伴随状态法。\n\n代价泛函 $J$ 因场 $\\{u_p\\}$ 变化而引起的变化由其相对于 $u_p$ 的弗雷歇导数给出。对于扰动 $\\delta u_p$，总变分 $\\delta J$ 为：\n$$ \\delta J = \\text{Re} \\sum_{p=1}^{P} \\langle \\nabla_{u_p} J, \\delta u_p \\rangle_{L^2(\\Omega)} $$\n其中 $\\nabla_{u_p} J$ 是 $J$ 相对于 $u_p$ 的梯度。根据 $J$ 的定义，\n$$ J = \\frac{1}{2} \\sum_{p=1}^{P} \\sum_{m=1}^{M} ([Cu_p]_m - d_{p,m}) \\overline{([Cu_p]_m - d_{p,m})} = \\frac{1}{2} \\sum_{p=1}^{P} \\sum_{m=1}^{M} r_{p,m} \\overline{r_{p,m}} $$\n相对于 $u_p$ 的变分为：\n$$ \\delta J = \\text{Re} \\sum_{p,m} \\overline{r_{p,m}} [C \\delta u_p]_m = \\text{Re} \\sum_{p,m} \\overline{r_{p,m}} \\int_{\\Omega} c_m(\\mathbf{r}) \\delta u_p(\\mathbf{r}) d\\mathbf{r} $$\n$$ \\delta J = \\text{Re} \\sum_{p} \\int_{\\Omega} \\left( \\sum_{m} c_m(\\mathbf{r}) \\overline{r_{p,m}} \\right) \\delta u_p(\\mathbf{r}) d\\mathbf{r} $$\n这个表达式不符合标准内积形式 $\\langle \\nabla_{u_p} J, \\delta u_p \\rangle = \\int_{\\Omega} (\\nabla_{u_p} J) \\overline{\\delta u_p} d\\mathbf{r}$。\n我们使用 $C$ 的伴随算子，记为 $C^*$。对于复 $L^2$ 内积 $\\langle f,g \\rangle = \\int f \\bar{g} d\\Omega$，伴随算子 $C^*: \\mathbb{C}^M \\to L^2(\\Omega)$ 由 $\\langle Cu, v \\rangle_{\\mathbb{C}^M} = \\langle u, C^*v \\rangle_{L^2}$ 定义。\n$$ \\langle Cu, v \\rangle = \\sum_{m=1}^{M} [Cu]_m \\overline{v_m} = \\sum_{m=1}^{M} \\left(\\int_{\\Omega} c_m u \\, d\\mathbf{r} \\right) \\overline{v_m} = \\int_{\\Omega} u(\\mathbf{r}) \\left( \\sum_{m=1}^{M} c_m(\\mathbf{r}) \\overline{v_m} \\right) d\\mathbf{r} $$\n因为我们需要此式等于 $\\int_{\\Omega} u(\\mathbf{r}) \\overline{(C^*v)(\\mathbf{r})} d\\mathbf{r}$，所以我们有 $(C^*v)(\\mathbf{r}) = \\sum_m \\overline{c_m} v_m$。由于 $c_m$ 是实值的，因此 $(C^*v)(\\mathbf{r}) = \\sum_m c_m v_m$。\n$J$ 相对于 $u_p$ 的梯度因此是 $\\nabla_{u_p} J = C^* r_p = \\sum_{m=1}^{M} c_m r_{p,m}$。\n\n$J$ 相对于 $\\phi$ 的全弗雷歇导数是\n$$ \\frac{dJ}{d\\phi}[\\delta\\phi] = \\frac{\\partial J}{\\partial \\phi}[\\delta\\phi] + \\text{Re} \\sum_{p=1}^{P} \\left\\langle \\nabla_{u_p} J, \\frac{\\partial u_p}{\\partial \\phi}[\\delta\\phi] \\right\\rangle $$\n第一项 $\\frac{\\partial J}{\\partial \\phi}$（偏导数）为零，因为 $J$ 不显式依赖于 $\\phi$。项 $\\frac{\\partial u_p}{\\partial \\phi}[\\delta\\phi]$ 是 $u_p$ 因 $\\delta\\phi$ 引起的改变量。\n令 $\\mathcal{L}_{\\phi} u_p = \\nabla \\cdot (\\mu^{-1} \\nabla u_p) + \\omega^2 \\epsilon(\\phi) u_p$。正问题方程为 $\\mathcal{L}_{\\phi} u_p = q_p$。对 $\\phi$ 求导得到：\n$$ \\mathcal{L}_{\\phi} \\left( \\frac{\\partial u_p}{\\partial \\phi}[\\delta\\phi] \\right) + \\left( \\frac{\\partial \\mathcal{L}_{\\phi}}{\\partial \\phi}[\\delta\\phi] \\right) u_p = 0 $$\n算子的导数为 $\\frac{\\partial \\mathcal{L}_{\\phi}}{\\partial \\phi}[\\delta\\phi] = \\omega^2 \\frac{\\partial \\epsilon}{\\partial \\phi}[\\delta\\phi]$。\n$$ \\frac{\\partial\\epsilon}{\\partial\\phi}[\\delta\\phi] = \\left(\\epsilon_{1} - \\epsilon_{0}\\right) H'_{\\beta}(\\phi) \\delta\\phi = \\left(\\epsilon_{1} - \\epsilon_{0}\\right) \\delta_{\\beta}(\\phi) \\delta\\phi $$\n所以，$\\frac{\\partial u_p}{\\partial \\phi}[\\delta\\phi] = - \\mathcal{L}_{\\phi}^{-1} \\left( \\omega^2 (\\epsilon_1 - \\epsilon_0) \\delta_{\\beta}(\\phi) \\delta\\phi \\, u_p \\right)$。\n将此代入 $\\frac{dJ}{d\\phi}$ 的表达式中：\n$$ \\frac{dJ}{d\\phi}[\\delta\\phi] = \\text{Re} \\sum_{p=1}^{P} \\left\\langle C^*r_p, - \\mathcal{L}_{\\phi}^{-1} \\left( \\omega^2 (\\epsilon_1 - \\epsilon_0) \\delta_{\\beta}(\\phi) \\delta\\phi \\, u_p \\right) \\right\\rangle $$\n利用伴随算子的定义 $\\langle f, A^{-1}g \\rangle = \\langle (A^{-1})^*f, g \\rangle$，我们将 $\\mathcal{L}_{\\phi}^{-1}$ 移到内积的另一边：\n$$ \\frac{dJ}{d\\phi}[\\delta\\phi] = \\text{Re} \\sum_{p=1}^{P} \\left\\langle -(\\mathcal{L}_{\\phi}^{-1})^* (C^*r_p), \\omega^2 (\\epsilon_1 - \\epsilon_0) \\delta_{\\beta}(\\phi) \\delta\\phi \\, u_p \\right\\rangle $$\n我们为每次照明 $p$ 定义伴随场 $\\lambda_p$ 如下：\n$$ \\lambda_p = (\\mathcal{L}_{\\phi}^{-1})^* (C^*r_p) \\quad \\implies \\quad \\mathcal{L}_{\\phi}^* \\lambda_p = C^*r_p $$\n问题陈述中指出正向算子 $\\mathcal{L}_{\\phi}$ 是自伴的（$\\mathcal{L}_{\\phi}^* = \\mathcal{L}_{\\phi}$），这是材料互易性和适当边界条件的结果。因此，伴随方程为：\n$$ \\mathcal{L}_{\\phi} \\lambda_p = C^*r_p \\quad \\iff \\quad \\nabla \\cdot (\\mu^{-1} \\nabla \\lambda_p) + \\omega^2 \\epsilon(\\phi) \\lambda_p = \\sum_{m=1}^{M} c_m(\\mathbf{r}) r_{p,m} $$\n将 $\\lambda_p$ 代回导数表达式中：\n$$ \\frac{dJ}{d\\phi}[\\delta\\phi] = \\text{Re} \\sum_{p=1}^{P} \\left\\langle -\\lambda_p, \\omega^2 (\\epsilon_1 - \\epsilon_0) \\delta_{\\beta}(\\phi) \\delta\\phi \\, u_p \\right\\rangle $$\n$$ = \\int_{\\Omega} \\left( -\\omega^2 (\\epsilon_1 - \\epsilon_0) \\delta_{\\beta}(\\phi(\\mathbf{r})) \\text{Re} \\sum_{p=1}^{P} u_p(\\mathbf{r}) \\overline{\\lambda_p(\\mathbf{r})} \\right) \\delta\\phi(\\mathbf{r}) \\, d\\mathbf{r} $$\n从这个积分形式中，我们识别出弗雷歇导数（梯度）：\n$$ \\frac{\\delta J}{\\delta \\phi}(\\mathbf{r}) = - \\omega^2 (\\epsilon_1 - \\epsilon_0) \\delta_{\\beta}(\\phi(\\mathbf{r})) \\text{Re} \\left( \\sum_{p=1}^{P} u_p(\\mathbf{r}) \\overline{\\lambda_p(\\mathbf{r})} \\right) $$\n\n### 第三步：应用互易性简化梯度\n\n上述表达式需要求解 $P$ 个正问题以得到 $u_p$ 和 $P$ 个伴随问题以得到 $\\lambda_p$。我们可以通过利用伴随方程的线性和算子 $\\mathcal{L}_\\phi$ 的自伴性（互易性）来减少求解次数。\n\n伴随方程的源项是线性组合 $\\sum_m c_m r_{p,m}$。我们定义一组 $M$ 个“接收场” $w_m(\\mathbf{r})$，作为正向型问题的解，其中每个场由单个传感器分布 $c_m$ 驱动：\n$$ \\mathcal{L}_{\\phi} w_m = c_m \\quad \\iff \\quad \\nabla \\cdot (\\mu^{-1} \\nabla w_m) + \\omega^2 \\epsilon(\\phi) w_m = c_m(\\mathbf{r}), \\quad m = 1, \\dots, M $$\n这些场 $w_m$ 依赖于介质 $\\phi$ 但不依赖于照明索引 $p$。根据线性性质，伴随方程的解 $\\lambda_p$ 可以由这些接收场构造：\n$$ \\lambda_p = \\mathcal{L}_{\\phi}^{-1} \\left( \\sum_{m=1}^{M} c_m r_{p,m} \\right) = \\sum_{m=1}^{M} r_{p,m} \\left( \\mathcal{L}_{\\phi}^{-1} c_m \\right) = \\sum_{m=1}^{M} r_{p,m} w_m(\\mathbf{r}) $$\n现在，我们将 $\\lambda_p$ 的这个表达式代入梯度公式中：\n$$ \\frac{\\delta J}{\\delta \\phi}(\\mathbf{r}) = - \\omega^2 (\\epsilon_1 - \\epsilon_0) \\delta_{\\beta}(\\phi(\\mathbf{r})) \\text{Re} \\left( \\sum_{p=1}^{P} u_p(\\mathbf{r}) \\overline{\\left( \\sum_{m=1}^{M} r_{p,m} w_m(\\mathbf{r}) \\right)} \\right) $$\n利用求和的线性和复共轭的性质：\n$$ \\frac{\\delta J}{\\delta \\phi}(\\mathbf{r}) = - \\omega^2 (\\epsilon_1 - \\epsilon_0) \\delta_{\\beta}(\\phi(\\mathbf{r})) \\text{Re} \\left( \\sum_{p=1}^{P} \\sum_{m=1}^{M} u_p(\\mathbf{r}) \\overline{r_{p,m}} \\overline{w_m(\\mathbf{r})} \\right) $$\n这是梯度的最终表达式。它需要求解 $P$ 个正问题以得到 $\\{u_p\\}$ 和 $M$ 个正向型问题以得到 $\\{w_m\\}$。当测量/传感器数量 $M$ 远小于照明次数 $P$ 时，这在计算上是有利的。该表达式是显式实值的，并由指定的量构造而成。\n\n为了清晰起见，我们可以重新排列求和顺序：\n$$ \\frac{\\delta J}{\\delta \\phi}(\\mathbf{r}) = -\\omega^{2} (\\epsilon_{1} - \\epsilon_{0}) \\delta_{\\beta}(\\phi(\\mathbf{r})) \\text{Re} \\left( \\sum_{m=1}^{M} \\overline{w_m(\\mathbf{r})} \\sum_{p=1}^{P} \\overline{r_{p,m}} u_p(\\mathbf{r}) \\right) $$",
            "answer": "$$ \\boxed{-\\omega^{2} \\left(\\epsilon_{1} - \\epsilon_{0}\\right) \\delta_{\\beta}(\\phi(\\mathbf{r})) \\text{Re} \\left( \\sum_{p=1}^{P} \\sum_{m=1}^{M} \\overline{r_{p,m}} u_{p}(\\mathbf{r}) \\overline{w_{m}(\\mathbf{r})} \\right)} $$"
        }
    ]
}