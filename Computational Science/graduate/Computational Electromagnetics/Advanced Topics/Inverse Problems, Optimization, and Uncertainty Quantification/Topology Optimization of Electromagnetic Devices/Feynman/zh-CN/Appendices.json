{
    "hands_on_practices": [
        {
            "introduction": "在电磁设备的拓扑优化中，直接应用优化算法常会导致棋盘格和网格依赖等非物理结果。为了获得清晰且可制造的设计，必须引入正则化技术。本实践将指导您实现两种核心的正则化方法：密度过滤器和亥维赛德投影，并通过一个代理目标函数来研究它们如何抑制伪影并促成近乎二值的材料分布。",
            "id": "3356441",
            "problem": "考虑在有界域中，在均匀笛卡尔网格上离散的时谐麦克斯韦方程组，其角频率为 $\\omega$，电场为 $\\mathbf{E}$，磁导率为 $\\mu$，介电常数为 $\\varepsilon$，外加电流密度为 $\\mathbf{J}$。控制方程可以写成旋度-旋度形式\n$$\n\\nabla \\times \\left( \\mu^{-1} \\nabla \\times \\mathbf{E} \\right) - \\omega^2 \\varepsilon(\\rho) \\mathbf{E} = i \\omega \\mathbf{J},\n$$\n其中 $\\varepsilon(\\rho)$ 表示依赖于单元设计变量密度 $\\rho \\in [0,1]$ 的材料插值。在基于密度的拓扑优化中，强制施加最小特征尺寸和促进近二元材料对于抑制非物理棋盘格和灰色区域至关重要，这些问题会降低电磁性能和可制造性。一种标准方法是组合使用空间密度滤波器和光滑亥维赛德投影：\n$$\n\\tilde{\\rho} = \\mathrm{proj}\\!\\left( \\mathrm{filter}(\\rho) \\right),\n$$\n其中 $\\mathrm{filter}$ 强制施加最小长度尺度，而 $\\mathrm{proj}$ 将密度推向 $0$ 或 $1$，同时为基于梯度的优化保持可微性。\n\n你将实现以下算子，并分析投影锐度参数的延拓策略以减少棋盘格：\n\n1. 密度滤波器。假设网格大小为 $N \\times N$，单位网格间距。对于给定的滤波器半径 $r > 0$，定义权重\n$$\nw_{ij} = \\max\\!\\left( 0,\\, r - d_{ij} \\right),\n$$\n其中 $d_{ij}$ 是像素 $i$ 和像素 $j$ 之间的欧几里得距离（以网格间距为单位）（$i$ 和 $j$ 索引网格位置）。像素 $i$ 处的滤波后密度为\n$$\n\\hat{\\rho}_i = \\frac{\\sum_j w_{ij} \\rho_j}{\\sum_j w_{ij}}.\n$$\n在均匀网格上，$w_{ij}$ 仅取决于像素之间的相对偏移，因此滤波可以通过与径向对称核进行卷积，然后进行逐点归一化来实现：\n$$\n\\hat{\\rho} = \\frac{K * \\rho}{K * \\mathbf{1}},\n$$\n其中 $K$ 是权重 $w_{ij}$ 的核，* 表示在边界处进行零填充的离散卷积，$\\mathbf{1}$ 是全1图像。\n\n2. 亥维赛德投影。对于锐度参数 $\\beta > 0$ 和阈值 $\\eta \\in (0,1)$，使用光滑投影\n$$\n\\tilde{\\rho}_i = \\frac{\\tanh\\!\\left( \\beta \\eta \\right) + \\tanh\\!\\left( \\beta (\\hat{\\rho}_i - \\eta) \\right)}{\\tanh\\!\\left( \\beta \\eta \\right) + \\tanh\\!\\left( \\beta (1 - \\eta) \\right)}.\n$$\n该映射相对于 $\\hat{\\rho}$ 是可微的，基于梯度的更新所需的导数为\n$$\n\\frac{\\partial \\tilde{\\rho}_i}{\\partial \\hat{\\rho}_i} = \\frac{\\beta \\left( 1 - \\tanh^2\\!\\left( \\beta (\\hat{\\rho}_i - \\eta) \\right) \\right)}{\\tanh\\!\\left( \\beta \\eta \\right) + \\tanh\\!\\left( \\beta (1 - \\eta) \\right)}.\n$$\n\n3. 用于正则化和二值化的代理目标。为了在不求解完整电磁场的情况下研究滤波和投影的效果，考虑关于投影后密度的代理泛函\n$$\n\\Phi(\\tilde{\\rho}) = \\lambda_{\\mathrm{smooth}} \\sum_{i} \\left\\| \\nabla \\tilde{\\rho}_i \\right\\|^2 \\;+\\; \\lambda_{\\mathrm{binary}} \\sum_i \\tilde{\\rho}_i (1 - \\tilde{\\rho}_i) \\;+\\; \\lambda_{\\mathrm{target}} \\sum_i T_i \\tilde{\\rho}_i,\n$$\n其中 $\\nabla$ 是单位间距的离散梯度，$\\left\\| \\nabla \\tilde{\\rho}_i \\right\\|^2$ 在光滑项的梯度中通过标准的5点离散拉普拉斯算子实现，而 $T$ 是一个固定的目标掩模，用于鼓励在指定子区域内存在材料。相对于 $\\tilde{\\rho}$ 的导数为\n$$\n\\frac{\\partial \\Phi}{\\partial \\tilde{\\rho}} = -2 \\lambda_{\\mathrm{smooth}} \\Delta \\tilde{\\rho} + \\lambda_{\\mathrm{binary}} (1 - 2 \\tilde{\\rho}) + \\lambda_{\\mathrm{target}} T,\n$$\n其中 $\\Delta$ 表示离散拉普拉斯算子。链式法则给出了相对于原始设计变量 $\\rho$ 的梯度：\n$$\n\\frac{\\partial \\Phi}{\\partial \\rho_j} = \\sum_i \\left( \\frac{\\partial \\Phi}{\\partial \\tilde{\\rho}_i} \\cdot \\frac{\\partial \\tilde{\\rho}_i}{\\partial \\hat{\\rho}_i} \\cdot \\frac{\\partial \\hat{\\rho}_i}{\\partial \\rho_j} \\right) \\;=\\; \\sum_i \\left( g^{\\mathrm{tilde}}_i \\cdot s_i \\cdot \\frac{w_{ij}}{\\sum_k w_{ik}} \\right),\n$$\n其中 $g^{\\mathrm{tilde}} = \\partial \\Phi / \\partial \\tilde{\\rho}$ 且 $s_i = \\partial \\tilde{\\rho}_i / \\partial \\hat{\\rho}_i$。在计算上，这可以通过将场 $g^{\\mathrm{tilde}} \\cdot s / (K * \\mathbf{1})$ 与核 $K$ 进行卷积来评估。\n\n4. 关于 $\\beta$ 的延拓策略。延拓策略选择一系列递增的 $\\beta$ 值，以逐渐锐化投影，同时避免可能锁定棋盘格模式的过早不可微性。你将模拟在 $\\rho$ 上的梯度下降更新，步长为 $\\alpha > 0$，在计划中的每个 $\\beta$ 值下进行固定次数的迭代：\n$$\n\\rho^{(k+1)} = \\mathrm{clip}_{[0,1]}\\!\\left( \\rho^{(k)} - \\alpha \\frac{\\partial \\Phi}{\\partial \\rho}\\bigg|_{\\rho^{(k)}} \\right),\n$$\n其中在每次迭代中，$\\hat{\\rho} = \\mathrm{filter}(\\rho)$，$\\tilde{\\rho} = \\mathrm{proj}_{\\beta,\\eta}(\\hat{\\rho})$，并且 $\\partial \\Phi / \\partial \\rho$ 通过上述链式法则计算。\n\n5. 指标。完成延拓计划后，在最终的 $\\tilde{\\rho}$ 上计算以下两个指标：\n- 棋盘格指数\n$$\nI_{\\mathrm{cb}} = \\frac{\\left| \\sum_{i,j} \\tilde{\\rho}_{ij} (-1)^{i + j} \\right|}{\\sum_{i,j} \\left| \\tilde{\\rho}_{ij} \\right|}.\n$$\n该指标量化了与交替高频模式的归一化相关性。\n- 灰度（二元性惩罚）\n$$\nG = \\frac{1}{N^2} \\sum_{i,j} 4 \\tilde{\\rho}_{ij} (1 - \\tilde{\\rho}_{ij}),\n$$\n对于完美的二元设计，其值为 $0$；当所有条目等于 $0.5$ 时，其值为 $1$。\n\n实现细节：\n- 使用单位网格间距；滤波器半径 $r$ 以网格间距为单位进行度量。\n- 在边界处使用零填充进行卷积。\n- 对离散拉普拉斯算子使用标准的5点模板，并通过复制边缘进行类诺伊曼处理。\n- 使用 $\\lambda_{\\mathrm{smooth}} = 0.1$，$\\lambda_{\\mathrm{binary}} = 1.0$，$\\lambda_{\\mathrm{target}} = 0.05$ 以及步长 $\\alpha = 0.2$。\n- 目标掩模 $T$ 定义为：在网格中心的 $6 \\times 6$ 方框内 $T_{ij} = -1$，其他地方 $T_{ij} = 0$；这鼓励材料在中心区域出现。\n\n测试套件：\n对于每个测试用例，运行延拓计划，每个 $\\beta$ 值的迭代次数固定为 $10$。\n\n- 测试用例 1 (理想路径): $N = 16$, $r = 3.0$, $\\eta = 0.5$, 计划 $\\beta = [1.0, 2.0, 4.0, 8.0]$, 初始 $\\rho$ 在 $[0,1]$ 上独立同分布，随机种子为 $0$。\n- 测试用例 2 (边界条件：均匀初始设计): $N = 16$, $r = 3.0$, $\\eta = 0.5$, 计划 $\\beta = [1.0, 2.0, 4.0, 8.0]$, 所有 $i,j$ 的初始 $\\rho_{ij} = 0.5$。\n- 测试用例 3 (边缘情况：几乎没有滤波和激进的投影): $N = 16$, $r = 1.0$, $\\eta = 0.5$, 计划 $\\beta = [16.0, 16.0, 16.0, 16.0]$, 如果 $(i + j)$ 为偶数，则初始 $\\rho_{ij} = 1$，否则 $\\rho_{ij} = 0$（完美棋盘格）。\n- 测试用例 4 (大滤波器半径和非单调延拓): $N = 16$, $r = 7.9$, $\\eta = 0.5$, 计划 $\\beta = [1.0, 1.0, 2.0, 1.0, 4.0]$, 初始 $\\rho$ 在 $[0,1]$ 上独立同分布，随机种子为 $42$。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果是一个双元素列表 $[I_{\\mathrm{cb}}, G]$，两个条目均为浮点数。总输出是这些按测试用例排列的列表的列表，例如 $\\left[ [I_{\\mathrm{cb},1}, G_1], [I_{\\mathrm{cb},2}, G_2], [I_{\\mathrm{cb},3}, G_3], [I_{\\mathrm{cb},4}, G_4] \\right]$。",
            "solution": "我们从时谐麦克斯韦方程组开始，其离散形式会导出一个旋度-旋度算子和一个材料插值 $\\varepsilon(\\rho)$，该插值将电磁响应与设计变量密度场 $\\rho \\in [0,1]$ 联系起来。在基于密度的拓扑优化中，由于旋度-旋度算子和刚度插值的离散性质，可能会在网格尺度上出现数值振荡，这表现为棋盘格：一种交替的高频模式，它能最小化离散能量，但并不对应于物理上可实现的结构。强制施加最小特征尺寸和促进近二元设计是标准的补救措施。\n\n强制施加最小特征尺寸是通过对设计变量应用空间滤波器来完成的。在单位间距的网格上，半径为 $r$ 的基于距离的滤波器使用权重 $w_{ij} = \\max(0, r - d_{ij})$ 来形成\n$$\n\\hat{\\rho}_i = \\frac{\\sum_j w_{ij} \\rho_j}{\\sum_j w_{ij}}.\n$$\n由于 $w_{ij}$ 仅取决于相对偏移，我们可以将其实现为与核 $K$ 的卷积，然后使用 $K * \\mathbf{1}$ 进行逐点归一化。这会抑制小于 $r$ 的特征，并衰减导致棋盘格的高空间频率。\n\n为了鼓励近二元材料，我们应用一个阈值为 $\\eta$、锐度为 $\\beta$ 的光滑亥维赛德投影：\n$$\n\\tilde{\\rho}_i = \\frac{\\tanh\\!\\left( \\beta \\eta \\right) + \\tanh\\!\\left( \\beta (\\hat{\\rho}_i - \\eta) \\right)}{\\tanh\\!\\left( \\beta \\eta \\right) + \\tanh\\!\\left( \\beta (1 - \\eta) \\right)}.\n$$\n当 $\\beta \\to \\infty$ 时，该映射趋近于阶跃函数，但对于有限的 $\\beta$，它仍然是可微的。其导数为\n$$\n\\frac{\\partial \\tilde{\\rho}_i}{\\partial \\hat{\\rho}_i} = \\frac{\\beta \\left( 1 - \\tanh^2\\!\\left( \\beta (\\hat{\\rho}_i - \\eta) \\right) \\right)}{\\tanh\\!\\left( \\beta \\eta \\right) + \\tanh\\!\\left( \\beta (1 - \\eta) \\right)}.\n$$\n该导数缩放了灵敏度，控制着投影的锐度如何影响梯度。\n\n为了在不求解电磁场的情况下研究这些算子的效果，我们定义一个代理目标，该目标编码了两种正则化机制和一个温和的目标偏好：\n$$\n\\Phi(\\tilde{\\rho}) = \\lambda_{\\mathrm{smooth}} \\sum_i \\left\\| \\nabla \\tilde{\\rho}_i \\right\\|^2 + \\lambda_{\\mathrm{binary}} \\sum_i \\tilde{\\rho}_i (1 - \\tilde{\\rho}_i) + \\lambda_{\\mathrm{target}} \\sum_i T_i \\tilde{\\rho}_i.\n$$\n第一项惩罚 $\\tilde{\\rho}$ 中的高梯度，类似于不鼓励可能导致数值伪影的快速材料变化。第二项通过使 $\\tilde{\\rho}_i$ 接近 $0$ 或 $1$ 来惩罚灰色区域。第三项引入一个简单的目标掩模 $T$，使问题变得非平凡，并模仿对场可能集中的区域中材料的偏好。为计算梯度，我们对 $\\left\\| \\nabla \\tilde{\\rho} \\right\\|^2$ 使用离散5点拉普拉斯算子 $\\Delta$，得到\n$$\n\\frac{\\partial \\Phi}{\\partial \\tilde{\\rho}} = -2 \\lambda_{\\mathrm{smooth}} \\Delta \\tilde{\\rho} + \\lambda_{\\mathrm{binary}} (1 - 2 \\tilde{\\rho}) + \\lambda_{\\mathrm{target}} T.\n$$\n\n链式法则将灵敏度传播回 $\\rho$：\n$$\n\\frac{\\partial \\Phi}{\\partial \\rho_j} = \\sum_i \\left( \\frac{\\partial \\Phi}{\\partial \\tilde{\\rho}_i} \\cdot \\frac{\\partial \\tilde{\\rho}_i}{\\partial \\hat{\\rho}_i} \\cdot \\frac{\\partial \\hat{\\rho}_i}{\\partial \\rho_j} \\right).\n$$\n给定\n$$\n\\frac{\\partial \\hat{\\rho}_i}{\\partial \\rho_j} = \\frac{w_{ij}}{\\sum_k w_{ik}},\n$$\n计算简化为形成场\n$$\ng^{\\mathrm{hat}}_i = \\frac{\\partial \\Phi}{\\partial \\tilde{\\rho}_i} \\cdot \\frac{\\partial \\tilde{\\rho}_i}{\\partial \\hat{\\rho}_i}, \\quad f_i = \\frac{g^{\\mathrm{hat}}_i}{\\sum_k w_{ik}},\n$$\n并用核 $K$ 卷积 $f$：\n$$\n\\frac{\\partial \\Phi}{\\partial \\rho} = K * f.\n$$\n这与滤波器归一化保持一致，并通过零填充和归一化图 $K * \\mathbf{1}$ 正确地考虑了边界效应。\n\n我们执行步长为 $\\alpha$ 的梯度下降，并进行 $[0,1]$ 范围的裁剪，以强制施加 $\\rho$ 上的箱式约束：\n$$\n\\rho^{(k+1)} = \\mathrm{clip}_{[0,1]}\\!\\left( \\rho^{(k)} - \\alpha \\frac{\\partial \\Phi}{\\partial \\rho} \\right).\n$$\n在每次迭代中，我们重新计算 $\\hat{\\rho} = \\mathrm{filter}(\\rho)$，$\\tilde{\\rho} = \\mathrm{proj}(\\hat{\\rho})$，并通过链式法则计算梯度。\n\n对 $\\beta$ 的延拓是通过首先使用中等的 $\\beta$ 值运行几次迭代，然后增加 $\\beta$ 以锐化投影来执行的。其基本原理是，小的 $\\beta$ 保持了灵敏度的光滑性，允许滤波器和平滑度惩罚项在投影推向二值化之前抑制高频内容。过早使用过于激进的 $\\beta$ 会锁定高频棋盘格，尤其是在滤波器半径 $r$ 很小的情况下。\n\n我们在最终的 $\\tilde{\\rho}$ 上评估两个指标：\n- 棋盘格指数\n$$\nI_{\\mathrm{cb}} = \\frac{\\left| \\sum_{i,j} \\tilde{\\rho}_{ij} (-1)^{i+j} \\right|}{\\sum_{i,j} \\left| \\tilde{\\rho}_{ij} \\right|}.\n$$\n如果 $\\tilde{\\rho}$ 与棋盘格非常相似，则分子相对于分母会变得很大，在极端情况下接近 $1$。对于均匀或低频模式，分子会抵消，$I_{\\mathrm{cb}}$ 会变小。\n- 灰度\n$$\nG = \\frac{1}{N^2} \\sum_{i,j} 4 \\tilde{\\rho}_{ij} (1 - \\tilde{\\rho}_{ij}),\n$$\n对于二元设计，其值为 $0$；对于均匀的 $\\tilde{\\rho} = 0.5$，其值为 $1$。\n\n我们使用固定的常数 $\\lambda_{\\mathrm{smooth}} = 0.1$, $\\lambda_{\\mathrm{binary}} = 1.0$, $\\lambda_{\\mathrm{target}} = 0.05$ 和 $\\alpha = 0.2$。目标掩模 $T$ 在中心的 $6 \\times 6$ 方框内为 $-1$，其他地方为 $0$，这在最小化 $\\Phi$ 时有效地激励了材料在中间区域的存在。\n\n测试套件探讨了：\n- 一个典型案例（$N = 16$, $r = 3.0$, $\\eta = 0.5$, 计划 $\\beta = [1.0, 2.0, 4.0, 8.0]$），使用随机初始 $\\rho$ 来验证预期行为。\n- 一个均匀的初始 $\\rho = 0.5$，以测试在相同计划下二值化和目标偏好如何相互作用。\n- 一个几乎没有滤波（$r = 1.0$）和激进投影（$\\beta$ 固定为 $16.0$）的案例，从一个完美的棋盘格开始，以暴露滤波不足时的失败模式。\n- 一个大滤波器半径（$r = 7.9$）和非单调计划 $\\beta = [1.0, 1.0, 2.0, 1.0, 4.0]$，以测试在强平滑下的鲁棒性。\n\n每个测试用例的算法步骤：\n1. 根据用例定义初始化 $\\rho$。\n2. 对于计划中的每个 $\\beta$，执行 $10$ 次梯度下降迭代：\n   - 构建半径为 $r$ 的核 $K$，权重为 $w_{ij} = \\max(0, r - \\sqrt{\\Delta x^2 + \\Delta y^2})$。\n   - 计算 $\\hat{\\rho} = (K * \\rho) / (K * \\mathbf{1})$。\n   - 通过投影公式计算 $\\tilde{\\rho}$。\n   - 计算 $\\partial \\Phi / \\partial \\tilde{\\rho} = -2 \\lambda_{\\mathrm{smooth}} \\Delta \\tilde{\\rho} + \\lambda_{\\mathrm{binary}} (1 - 2 \\tilde{\\rho}) + \\lambda_{\\mathrm{target}} T$。\n   - 计算 $s = \\partial \\tilde{\\rho} / \\partial \\hat{\\rho}$ 和 $g^{\\mathrm{hat}} = (\\partial \\Phi / \\partial \\tilde{\\rho}) \\cdot s$。\n   - 计算 $f = g^{\\mathrm{hat}} / (K * \\mathbf{1})$，然后 $\\partial \\Phi / \\partial \\rho = K * f$。\n   - 更新 $\\rho \\leftarrow \\mathrm{clip}_{[0,1]}( \\rho - \\alpha \\, \\partial \\Phi / \\partial \\rho )$。\n3. 计划结束后，使用最后一个 $\\beta$ 和滤波器半径 $r$ 计算最终的 $\\tilde{\\rho}$，然后评估 $I_{\\mathrm{cb}}$ 和 $G$。\n4. 返回序对 $[I_{\\mathrm{cb}}, G]$。\n\n单行输出将四个测试用例的结果聚合为一个双元素列表的列表。该实验从第一性原理出发，并与电磁正则化需求相一致，展示了滤波和光滑投影与延拓相结合如何影响设计变量中的高频伪影和二值性，为在锐化材料分布之前抑制棋盘格提供了一种计算上合理的方法。",
            "answer": "```python\nimport numpy as np\n\n# Implement density filter and Heaviside projection with continuation on beta.\n# Environment: Python 3.12, numpy 1.23.5, scipy 1.11.4 allowed but not needed.\n\ndef build_kernel(radius: float):\n    \"\"\"\n    Build a radially symmetric distance-weighted kernel K with weights\n    w(dx,dy) = max(0, radius - sqrt(dx^2 + dy^2)),\n    over offsets in the square [-R, R] x [-R, R], where R = ceil(radius).\n    \"\"\"\n    R = int(np.ceil(radius))\n    size = 2 * R + 1\n    K = np.zeros((size, size), dtype=np.float64)\n    for i in range(size):\n        for j in range(size):\n            dx = i - R\n            dy = j - R\n            dist = np.sqrt(dx * dx + dy * dy)\n            w = max(0.0, radius - dist)\n            K[i, j] = w\n    return K\n\ndef convolve2d_same(image: np.ndarray, kernel: np.ndarray):\n    \"\"\"\n    Convolve a 2D image with kernel using zero padding, output same size as image.\n    \"\"\"\n    H, W = image.shape\n    kH, kW = kernel.shape\n    pad_h = kH // 2\n    pad_w = kW // 2\n    # Pad image with zeros\n    padded = np.pad(image, ((pad_h, pad_h), (pad_w, pad_w)), mode='constant', constant_values=0.0)\n    result = np.zeros_like(image, dtype=np.float64)\n    # Flip kernel for convolution\n    kflip = kernel[::-1, ::-1]\n    for i in range(H):\n        for j in range(W):\n            window = padded[i:i + kH, j:j + kW]\n            result[i, j] = np.sum(window * kflip)\n    return result\n\ndef density_filter(rho: np.ndarray, kernel: np.ndarray):\n    \"\"\"\n    Apply density filter: hat_rho = (K * rho) / (K * 1).\n    \"\"\"\n    ones = np.ones_like(rho, dtype=np.float64)\n    num = convolve2d_same(rho, kernel)\n    den = convolve2d_same(ones, kernel)\n    # Avoid division by zero by adding tiny epsilon\n    eps = 1e-12\n    hat_rho = num / (den + eps)\n    return hat_rho, den\n\ndef heaviside_projection(hat_rho: np.ndarray, beta: float, eta: float):\n    \"\"\"\n    Smooth Heaviside projection with sharpness beta and threshold eta.\n    \"\"\"\n    th_eta = np.tanh(beta * eta)\n    th_one = np.tanh(beta * (1.0 - eta))\n    denom = th_eta + th_one\n    proj = (th_eta + np.tanh(beta * (hat_rho - eta))) / denom\n    return proj\n\ndef dproj_dhat(hat_rho: np.ndarray, beta: float, eta: float):\n    \"\"\"\n    Derivative of the smooth Heaviside projection with respect to hat_rho.\n    \"\"\"\n    th_eta = np.tanh(beta * eta)\n    th_one = np.tanh(beta * (1.0 - eta))\n    denom = th_eta + th_one\n    tanh_arg = np.tanh(beta * (hat_rho - eta))\n    deriv = beta * (1.0 - tanh_arg ** 2) / denom\n    return deriv\n\ndef laplacian_5pt(u: np.ndarray):\n    \"\"\"\n    Discrete 5-point Laplacian with Neumann-like edge handling by replication.\n    \"\"\"\n    H, W = u.shape\n    # Pad by replication\n    up = np.pad(u, ((1,1),(1,1)), mode='edge')\n    center = up[1:-1, 1:-1]\n    left = up[1:-1, 0:-2]\n    right = up[1:-1, 2:]\n    upv = up[0:-2, 1:-1]\n    down = up[2:, 1:-1]\n    lap = (left + right + upv + down - 4.0 * center)\n    return lap\n\ndef surrogate_gradient_tilde(tilde_rho: np.ndarray, lamb_smooth: float, lamb_binary: float, lamb_target: float, T: np.ndarray):\n    \"\"\"\n    Compute dPhi/d(tilde_rho) for the surrogate objective.\n    \"\"\"\n    grad = -2.0 * lamb_smooth * laplacian_5pt(tilde_rho) + lamb_binary * (1.0 - 2.0 * tilde_rho) + lamb_target * T\n    return grad\n\ndef checkerboard_index(tilde_rho: np.ndarray):\n    \"\"\"\n    Compute checkerboard index I_cb = |sum tilde_rho * (-1)^(i+j)| / sum |tilde_rho|.\n    \"\"\"\n    H, W = tilde_rho.shape\n    # Build alternating sign pattern\n    ii, jj = np.indices((H, W))\n    sign = ((ii + jj) % 2) * 2 - 1  # values in {-1, +1}\n    num = np.abs(np.sum(tilde_rho * sign))\n    den = np.sum(np.abs(tilde_rho)) + 1e-12\n    return float(num / den)\n\ndef grayness(tilde_rho: np.ndarray):\n    \"\"\"\n    Compute grayness G = mean(4 * x * (1 - x)).\n    \"\"\"\n    g = 4.0 * tilde_rho * (1.0 - tilde_rho)\n    return float(np.mean(g))\n\ndef run_case(N: int, r: float, eta: float, beta_schedule: list, rho_init: np.ndarray, iterations_per_beta: int = 10,\n             lamb_smooth: float = 0.1, lamb_binary: float = 1.0, lamb_target: float = 0.05, alpha: float = 0.2):\n    \"\"\"\n    Run continuation schedule on a test case and return [I_cb, G] on final projected density.\n    \"\"\"\n    # Build target mask T: central 6x6 box has -1, else 0\n    T = np.zeros((N, N), dtype=np.float64)\n    c0 = N // 2 - 3\n    c1 = N // 2 + 3\n    T[c0:c1, c0:c1] = -1.0\n\n    # Build kernel once per case (radius fixed)\n    K = build_kernel(r)\n    rho = rho_init.copy()\n\n    for beta in beta_schedule:\n        for _ in range(iterations_per_beta):\n            hat_rho, den_map = density_filter(rho, K)\n            tilde = heaviside_projection(hat_rho, beta, eta)\n            # Gradient on tilde_rho\n            g_tilde = surrogate_gradient_tilde(tilde, lamb_smooth, lamb_binary, lamb_target, T)\n            # Chain rule through projection\n            s = dproj_dhat(hat_rho, beta, eta)\n            g_hat = g_tilde * s\n            # Divide by local filter normalization\n            f = g_hat / (den_map + 1e-12)\n            # Gradient wrt rho is convolution of f with K\n            g_rho = convolve2d_same(f, K)\n            # Update and clip\n            rho = np.clip(rho - alpha * g_rho, 0.0, 1.0)\n\n    # Final metrics computed on final projected density with last beta\n    hat_rho, _ = density_filter(rho, K)\n    tilde = heaviside_projection(hat_rho, beta_schedule[-1], eta)\n    Icb = checkerboard_index(tilde)\n    G = grayness(tilde)\n    return [Icb, G]\n\ndef solve():\n    # Define test cases from the problem statement.\n    # Test case 1: happy path\n    N1 = 16\n    r1 = 3.0\n    eta1 = 0.5\n    beta_sched1 = [1.0, 2.0, 4.0, 8.0]\n    rng1 = np.random.default_rng(0)\n    rho_init1 = rng1.random((N1, N1))\n\n    # Test case 2: uniform initial design\n    N2 = 16\n    r2 = 3.0\n    eta2 = 0.5\n    beta_sched2 = [1.0, 2.0, 4.0, 8.0]\n    rho_init2 = np.full((N2, N2), 0.5, dtype=np.float64)\n\n    # Test case 3: near-absent filtering with aggressive projection, starting from perfect checkerboard\n    N3 = 16\n    r3 = 1.0\n    eta3 = 0.5\n    beta_sched3 = [16.0, 16.0, 16.0, 16.0]\n    ii3, jj3 = np.indices((N3, N3))\n    rho_init3 = (((ii3 + jj3) % 2) == 0).astype(np.float64)\n\n    # Test case 4: large filter radius with non-monotone continuation, random seed 42\n    N4 = 16\n    r4 = 7.9\n    eta4 = 0.5\n    beta_sched4 = [1.0, 1.0, 2.0, 1.0, 4.0]\n    rng4 = np.random.default_rng(42)\n    rho_init4 = rng4.random((N4, N4))\n\n    results = []\n    results.append(run_case(N1, r1, eta1, beta_sched1, rho_init1))\n    results.append(run_case(N2, r2, eta2, beta_sched2, rho_init2))\n    results.append(run_case(N3, r3, eta3, beta_sched3, rho_init3))\n    results.append(run_case(N4, r4, eta4, beta_sched4, rho_init4))\n\n    # Final print statement in the exact required format: single line, comma-separated list enclosed in brackets.\n    # Each result is a two-element list [I_cb, G].\n    def fmt_pair(pair):\n        # Format floats with adequate precision\n        return \"[\" + \",\".join(f\"{x:.6f}\" for x in pair) + \"]\"\n    print(\"[\" + \",\".join(fmt_pair(res) for res in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "基于梯度的优化算法的成功完全依赖于梯度计算的准确性。在开发复杂的优化模型时，验证伴随法等方法得到的灵敏度至关重要。本实践将引导您从第一性原理出发，为二维电磁散射问题推导伴随灵敏度，并使用高精度的复步法来验证其正确性，从而掌握确保优化代码可靠性的关键技能。",
            "id": "3356381",
            "problem": "您的任务是为用于拓扑优化的频域电磁模型设计并实现一个复步梯度检验，用于检验标量目标函数对空间分布的材料密度的灵敏度。该问题必须在计算电磁学的框架内提出，并从第一性原理出发。\n\n考虑在谐波时间依赖下的二维横电（TE）极化。从麦克斯韦方程组及其频域形式出发，标量TE场满足一个亥姆霍兹型方程。在归一化单位下（并假设磁导率均匀），平面外场的控制方程的强形式为\n$$\n\\nabla^2 u(\\mathbf{x}) + \\omega^2 \\mu \\epsilon(\\rho(\\mathbf{x}))\\, u(\\mathbf{x}) = s(\\mathbf{x}),\n$$\n其中 $u$ 是平面外电场分量，$\\omega$ 是角频率，$\\mu$ 是磁导率（常数），$\\epsilon(\\rho)$ 是随空间变化的介电常数，作为材料密度变量 $\\rho(\\mathbf{x}) \\in [0,1]$ 的函数，而 $s$ 是一个给定的源分布。假设在方形域上采用齐次狄利克雷边界条件以保证良定性。\n\n使用频域有限差分（FDFD）方法离散化控制方程，得到一个线性系统\n$$\nA(\\rho)\\, u = b,\n$$\n其中 $A(\\rho) = K + \\omega^2 \\mu\\, M(\\rho)$，$K$ 是在 $N \\times N$ 内部网格上带有齐次狄利克雷边界条件的离散拉普拉斯算子，$M(\\rho)$ 是一个对角矩阵，其对角线上的元素是在相应网格点 $i$ 处的 $\\epsilon(\\rho_i)$。采用一个物理上合理、单调递增的介电常数材料插值\n$$\n\\epsilon(\\rho) = \\epsilon_{\\min} + (\\epsilon_{\\max} - \\epsilon_{\\min})\\, \\rho,\n$$\n其中 $\\epsilon_{\\min}$ 和 $\\epsilon_{\\max}$ 为实数且为正。\n\n定义一个复值目标函数\n$$\nf(u) = c^\\top u,\n$$\n其中 $c$ 是一个固定的实数权重向量，用于选择场的一个线性泛函（例如，目标位置的场振幅或某个区域上的加权和）。该目标函数适用于伴随灵敏度分析和复步验证，因为它对 $u$ 是线性的，并通过 $u(\\rho)$ 对参数是全纯的。\n\n您的任务是：\n- 从离散的控制方程和目标函数的定义出发，仅从上述第一性原理推导基于伴随方法的灵敏度 $df/d\\rho$ 的表达式。您的推导必须明确应用链式法则、状态方程的线性化，以及通过适当的转置系统引入伴随场。您必须通过明确说明任何假设（例如，常数 $\\mu$，实数 $\\epsilon(\\rho)$）来确保科学真实性。\n- 设计并实现一个复步梯度检验。即，在设计空间中选择一个方向向量 $d$，用一个小的实数增量 $\\Delta$ 将设计变量扰动为 $\\rho \\mapsto \\rho + i\\, \\Delta\\, d$，求解扰动后的复数系统，评估 $f$，并计算方向导数的估计值\n$$\n\\frac{d f}{d \\rho}\\cdot d \\approx \\frac{\\operatorname{Im}\\left[f\\left(\\rho + i\\, \\Delta\\, d\\right)\\right]}{\\Delta}.\n$$\n解释当 $\\epsilon(\\rho)$ 为实数且从 $\\rho$到 $A(\\rho)$ 的映射是解析的时，为什么这个过程是有效的，以及它如何避免相减抵消。\n\n您的程序必须：\n- 使用标准的五点模板，在齐次狄利克雷边界条件下，为 $N \\times N$ 内部网格构建 $K$，并组装 $A(\\rho) = K + \\omega^2 \\mu\\, \\operatorname{diag}(\\epsilon(\\rho))$。\n- 将 $b$ 构建为位于内部网格左侧附近的单点源，将 $c$ 构建为位于右侧附近的选择器（具体索引在下文指定）。\n- 计算伴随灵敏度向量 $g = df/d\\rho$ 和针对指定方向 $d$ 与增量 $\\Delta$ 的复步方向导数。\n- 对于每个测试用例，报告伴随方向导数 $g \\cdot d$ 和复步估计值之间的相对误差，定义为\n$$\n\\mathrm{err} = \\frac{\\left|\\, (g \\cdot d) - \\frac{\\operatorname{Im}(f(\\rho + i\\, \\Delta\\, d))}{\\Delta} \\,\\right|}{\\max\\left(\\left|g \\cdot d\\right|, 10^{-12}\\right)}.\n$$\n\n使用以下固定参数和测试套件：\n- 网格大小：每个维度 $N = 12$ 个内部点。网格间距归一化为 $1$。\n- 角频率：$\\omega = 10$（无量纲归一化单位）。\n- 磁导率：$\\mu = 1$（归一化单位）。\n- 介电常数界限：$\\epsilon_{\\min} = 1$, $\\epsilon_{\\max} = 12$。\n- 源向量 $b$：在网格索引 $(i,j) = (N//2, 1)$ 处具有单位振幅，使用行主序映射到单个索引。\n- 目标选择器 $c$：在相同排序下，位于网格索引 $(i,j) = (N//2, N-2)$ 处的单位选择器。\n- 设计变量 $\\rho \\in \\mathbb{R}^{N^2}$，其元素在 $[0,1]$ 范围内。\n\n测试用例：\n1. 理想路径：随机 $\\rho$ 从 $[0,1]$ 区间均匀抽取，种子为 $42$；方向 $d$ 是一个归一化为单位欧几里得范数的随机向量（相同种子）；复步增量 $\\Delta = 10^{-20}$。\n2. 步长鲁棒性：与用例1相同，但 $\\Delta = 10^{-10}$。\n3. 边界设计极端情况：均匀设计 $\\rho = \\mathbf{0}$，方向 $d$ 是一个选择中心网格索引 $(i,j) = (N//2, N//2)$ 的标准基向量，且 $\\Delta = 10^{-20}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3]\"），每个结果是一个浮点数，等于相应测试用例的上述定义的相对误差。输出中不需要物理单位，因为这些量是无量纲数。",
            "solution": "该问题要求对频域电磁模型的伴随灵敏度分析进行推导和验证，并使用复步法作为高精度基准。推导和实现将根据问题陈述中列出的第一性原理进行。\n\n### 1. 伴随灵敏度分析推导\n\n分析始于控制电场 $u$ 和标量目标函数 $f$ 的离散方程组。\n\n**给定：**\n- 状态方程：$A(\\rho)u = b$，其中 $A(\\rho) = K + \\omega^2 \\mu M(\\rho)$\n- 目标函数：$f(u) = c^\\top u$\n\n在此，$\\rho$ 是设计变量（材料密度）的向量，$u$ 是状态向量（离散化的电场），$b$ 是源向量，$c$ 是目标权重向量。我们假设对于给定的参数，$A$ 是可逆的，从而确保 $u$ 有唯一解。目标是计算目标函数相对于设计变量的梯度，$g = \\frac{df}{d\\rho}$。\n\n梯度的分量为 $g_j = \\frac{df}{d\\rho_j}$，对应每个设计变量 $\\rho_j$。我们对目标函数 $f(u(\\rho))$ 应用链式法则：\n$$\n\\frac{df}{d\\rho_j} = \\frac{\\partial f}{\\partial u} \\frac{du}{d\\rho_j}\n$$\n项 $\\frac{\\partial f}{\\partial \\rho_j}$ 为零，因为 $f$ 仅通过 $u$ 隐式地依赖于 $\\rho_j$。根据定义 $f(u)=c^\\top u$，我们有 $\\frac{\\partial f}{\\partial u} = c^\\top$。因此，\n$$\n\\frac{df}{d\\rho_j} = c^\\top \\frac{du}{d\\rho_j}\n$$\n为了求得状态灵敏度向量 $\\frac{du}{d\\rho_j}$，我们将状态方程 $A u = b$ 对 $\\rho_j$ 求导。假设源向量 $b$ 与 $\\rho$ 无关。\n$$\n\\frac{d}{d\\rho_j} (A(\\rho) u(\\rho)) = \\frac{d b}{d\\rho_j} = 0\n$$\n应用乘法法则：\n$$\n\\frac{\\partial A}{\\partial \\rho_j} u + A \\frac{du}{d\\rho_j} = 0\n$$\n求解 $\\frac{du}{d\\rho_j}$：\n$$\n\\frac{du}{d\\rho_j} = -A^{-1} \\frac{\\partial A}{\\partial \\rho_j} u\n$$\n将此代回灵敏度的表达式中：\n$$\n\\frac{df}{d\\rho_j} = -c^\\top A^{-1} \\frac{\\partial A}{\\partial \\rho_j} u\n$$\n该表达式构成了灵敏度分析的“直接法”。如果设计变量的数量（$N^2$）很大，这种方法的计算成本会很高，因为它需要为每个变量求解 $A^{-1}$与一个向量的乘积。\n\n为了推导更高效的伴随法，我们重新组合这些项。我们定义伴随向量 $\\lambda$ 为以下线性系统的解：\n$$\nA^\\top \\lambda = c\n$$\n这使我们能够写出 $\\lambda^\\top = c^\\top (A^\\top)^{-1} = c^\\top (A^{-1})^\\top$。如果 $A$ 是对称的，如此处的情况（$K$ 是实对称矩阵，$M(\\rho)$ 是实对角矩阵，所以 $A$ 是实对称矩阵），则 $A^\\top = A$ 且 $\\lambda^\\top = c^\\top A^{-1}$。灵敏度表达式随后变为：\n$$\n\\frac{df}{d\\rho_j} = -\\lambda^\\top \\frac{\\partial A}{\\partial \\rho_j} u\n$$\n伴随法只需要一次正向求解（$Au=b$）来求得 $u$，以及一次伴随求解（$A^\\top \\lambda=c$）来求得 $\\lambda$。一旦 $u$ 和 $\\lambda$ 已知，每个 $\\rho_j$ 的梯度分量就可以高效地计算出来。\n\n现在，我们来求 $\\frac{\\partial A}{\\partial \\rho_j}$ 的具体形式。矩阵 $A$ 定义为 $A(\\rho) = K + \\omega^2 \\mu M(\\rho)$。离散拉普拉斯算子 $K$、角频率 $\\omega$ 和磁导率 $\\mu$ 相对于 $\\rho$ 都是常数。质量矩阵 $M(\\rho)$ 是对角矩阵，其对角线元素由材料插值规则给出：\n$M(\\rho) = \\operatorname{diag}(\\epsilon(\\rho_i))$，其中 $\\epsilon(\\rho_i) = \\epsilon_{\\min} + (\\epsilon_{\\max} - \\epsilon_{\\min})\\rho_i$。\n\n$A$ 对 $\\rho_j$ 的偏导数为：\n$$\n\\frac{\\partial A}{\\partial \\rho_j} = \\omega^2 \\mu \\frac{\\partial M(\\rho)}{\\partial \\rho_j}\n$$\n矩阵 $\\frac{\\partial M(\\rho)}{\\partial \\rho_j}$ 是一个对角矩阵，其中只有第 $j$ 个对角元素非零：\n$$\n\\left(\\frac{\\partial M(\\rho)}{\\partial \\rho_j}\\right)_{ii} = \\frac{d\\epsilon(\\rho_i)}{d\\rho_j} = (\\epsilon_{\\max} - \\epsilon_{\\min}) \\delta_{ij}\n$$\n其中 $\\delta_{ij}$ 是克罗内克 δ。因此，$\\frac{\\partial A}{\\partial \\rho_j}$ 是一个只有一个非零项的矩阵，该非零项位于位置 $(j,j)$，其值为 $\\omega^2 \\mu (\\epsilon_{\\max} - \\epsilon_{\\min})$。\n于是灵敏度为：\n$$\n\\frac{df}{d\\rho_j} = -\\lambda^\\top \\left( \\omega^2 \\mu (\\epsilon_{\\max} - \\epsilon_{\\min}) E_{jj} \\right) u\n$$\n其中 $E_{jj}$ 是一个在 $(j,j)$ 位置为 $1$、其余位置为零的矩阵。这可以简化为：\n$$\n\\frac{df}{d\\rho_j} = - \\omega^2 \\mu (\\epsilon_{\\max} - \\epsilon_{\\min}) \\lambda_j u_j\n$$\n完整的梯度向量 $g = df/d\\rho$ 可以使用哈达玛（逐元素）积 $\\odot$ 紧凑地表示为：\n$$\ng = - \\omega^2 \\mu (\\epsilon_{\\max} - \\epsilon_{\\min}) (\\lambda \\odot u)\n$$\n\n### 2. 复步梯度检验\n\n复步法是一种数值微分技术，它能提供高精度的导数，同时避免了有限差分法中固有的相减抵消误差。\n\n考虑一个标量函数 $g(\\alpha) = f(\\rho + \\alpha d)$，其中 $\\alpha$ 是一个标量，$d$ 是一个方向向量。$f$ 在 $\\rho$ 处沿方向 $d$ 的方向导数是 $g'(0)$。为了计算它，我们使用一个复数步长。如果函数 $f$（以及 $g$）是解析的，它可以在 $\\alpha=0$ 附近展开成泰勒级数。在一个纯虚数步长 $\\alpha = i\\Delta$ 处进行求值：\n$$\ng(i\\Delta) = g(0) + g'(0)(i\\Delta) + \\frac{g''(0)}{2!}(i\\Delta)^2 + \\frac{g'''(0)}{3!}(i\\Delta)^3 + \\mathcal{O}(\\Delta^4)\n$$\n$$\ng(i\\Delta) = g(0) + i g'(0)\\Delta - \\frac{g''(0)}{2}\\Delta^2 - i \\frac{g'''(0)}{6}\\Delta^3 + \\mathcal{O}(\\Delta^4)\n$$\n假设当 $\\alpha$ 为实数时 $g(\\alpha)$ 也为实数，那么 $g(0) = f(\\rho)$ 是实数，其各阶导数 $g^{(k)}(0)$ 也都是实数。取上述方程的虚部：\n$$\n\\operatorname{Im}[g(i\\Delta)] = g'(0)\\Delta - \\frac{g'''(0)}{6}\\Delta^3 + \\mathcal{O}(\\Delta^5)\n$$\n求解 $g'(0)$：\n$$\ng'(0) = \\frac{\\operatorname{Im}[g(i\\Delta)]}{\\Delta} + \\frac{g'''(0)}{6}\\Delta^2 + \\mathcal{O}(\\Delta^4)\n$$\n因此，方向导数的复步近似为：\n$$\n\\frac{df}{d\\rho} \\cdot d = g'(0) \\approx \\frac{\\operatorname{Im}[f(\\rho + i\\Delta d)]}{\\Delta}\n$$\n首项误差项的阶数为 $\\mathcal{O}(\\Delta^2)$，这允许通过选择一个非常小的 $\\Delta$（例如 $\\Delta=10^{-20}$）来获得高精度。关键在于，这个公式不涉及两个几乎相等的数的相减，从而绕过了在小步长情况下困扰有限差分方案的舍入误差。\n\n该方法对当前问题有效，因为映射 $\\rho \\mapsto f(\\rho)$ 是解析的。这可以通过检查依赖链来看出：\n1.  $\\rho \\mapsto \\epsilon(\\rho) = \\epsilon_{\\min} + (\\epsilon_{\\max} - \\epsilon_{\\min})\\rho$。这是一个线性函数，因此是解析的。\n2.  $\\epsilon(\\rho) \\mapsto A(\\rho) = K + \\omega^2 \\mu \\operatorname{diag}(\\epsilon(\\rho))$。这个函数对 $\\epsilon$ 也是线性的，因此对 $\\rho$ 是解析的。\n3.  $A(\\rho) \\mapsto u(\\rho) = A(\\rho)^{-1}b$。矩阵求逆是一个解析操作，所以只要 $A(\\rho)$ 是非奇异的，$u(\\rho)$ 就是解析的。假设该问题是非共振的。\n4.  $u(\\rho) \\mapsto f(u) = c^\\top u$。这是一个线性泛函，它是解析的。\n\n由于解析函数的复合仍然是解析函数，因此 $f(\\rho)$ 是解析的，这为使用复步法提供了正当性。\n\n### 3. 实现与验证\n\n实现将按以下步骤进行：\n1.  为具有齐次狄利克雷边界条件的 $N \\times N$ 内部网格构建离散拉普拉斯算子 $K$。\n2.  对每个测试用例，定义设计向量 $\\rho$ 和方向向量 $d$。\n3.  **伴随法**：\n    a. 计算 $\\epsilon(\\rho)$ 并组装实对称矩阵 $A(\\rho)$。\n    b. 求解正向系统 $A u = b$ 以获得场 $u$。\n    c. 求解伴随系统 $A^{\\top} \\lambda = c$（由于对称性，即为 $A \\lambda = c$）以获得伴随场 $\\lambda$。\n    d. 使用推导出的公式计算梯度向量 $g$。\n    e. 计算方向导数 $g \\cdot d$。\n4.  **复步法**：\n    a. 构成复数设计向量 $\\rho_{\\text{cs}} = \\rho + i\\Delta d$。\n    b. 计算复介电常数 $\\epsilon(\\rho_{\\text{cs}})$ 并组装复对称矩阵 $A(\\rho_{\\text{cs}})$。\n    c. 求解复数系统 $A_{\\text{cs}} u_{\\text{cs}} = b$ 以获得复数场 $u_{\\text{cs}}$。\n    d. 评估复数目标 $f_{\\text{cs}} = c^\\top u_{\\text{cs}}$。\n    e. 计算方向导数近似值 $\\operatorname{Im}(f_{\\text{cs}})/\\Delta$。\n5.  按照规定计算伴随法和复步法结果之间的相对误差。这可作为对伴随法实现的验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, kron, eye\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the problem of validating adjoint sensitivities for a 2D FDFD\n    electromagnetic model using the complex-step method.\n    \"\"\"\n    # Define fixed parameters from the problem statement.\n    N = 12\n    omega = 10.0\n    mu = 1.0\n    eps_min = 1.0\n    eps_max = 12.0\n    grid_spacing = 1.0\n\n    # Total number of degrees of freedom (interior grid points)\n    N_dof = N * N\n\n    # Construct the 2D discrete Laplacian K for an N x N interior grid\n    # with homogeneous Dirichlet boundary conditions.\n    # The five-point stencil for del^2 u is (u_i-1 + u_i+1 + ... - 4*u_i) / h^2.\n    # With h=1, the matrix entries are 1 for neighbors and -4 for the center.\n    # We use the kronecker product of 1D Laplacian matrices to build the 2D operator.\n    T_N = diags([1, -2, 1], [-1, 0, 1], shape=(N, N), format='csc') / (grid_spacing**2)\n    I_N = eye(N, format='csc')\n    K = kron(I_N, T_N) + kron(T_N, I_N)\n\n    # Define source vector b and objective selector c.\n    # Indices are based on row-major ordering: idx = row * N + col.\n    src_idx = (N // 2) * N + 1\n    obj_idx = (N // 2) * N + (N - 2)\n\n    b = np.zeros(N_dof, dtype=np.float64)\n    b[src_idx] = 1.0\n\n    c = np.zeros(N_dof, dtype=np.float64)\n    c[obj_idx] = 1.0\n\n    # Define the test cases.\n    test_cases = [\n        {'seed': 42, 'rho_type': 'random', 'd_type': 'random_normalized', 'delta': 1e-20},\n        {'seed': 42, 'rho_type': 'random', 'd_type': 'random_normalized', 'delta': 1e-10},\n        {'seed': None, 'rho_type': 'zeros', 'd_type': 'basis', 'delta': 1e-20},\n    ]\n\n    results = []\n    \n    # Process each test case\n    for case in test_cases:\n        # --- 1. Set up design (rho) and direction (d) vectors for the case ---\n        if case['rho_type'] == 'random':\n            rng = np.random.default_rng(case['seed'])\n            rho = rng.random(N_dof)\n        elif case['rho_type'] == 'zeros':\n            rho = np.zeros(N_dof)\n\n        if case['d_type'] == 'random_normalized':\n            # Use the same seed for d to ensure reproducibility with rho\n            rng = np.random.default_rng(case['seed'])\n            d = rng.random(N_dof)\n            d /= np.linalg.norm(d)\n        elif case['d_type'] == 'basis':\n            d_idx = (N // 2) * N + (N // 2)\n            d = np.zeros(N_dof)\n            d[d_idx] = 1.0\n        \n        delta = case['delta']\n\n        # --- 2. Adjoint Sensitivity Calculation ---\n        # Material interpolation: eps(rho)\n        eps_rho = eps_min + (eps_max - eps_min) * rho\n        M_rho = diags(eps_rho, 0, shape=(N_dof, N_dof), format='csc')\n        \n        # System matrix: A(rho) = K + omega^2 * mu * M(rho)\n        A = K + (omega**2 * mu) * M_rho\n\n        # Solve forward problem: A * u = b\n        u = spsolve(A, b)\n        \n        # Solve adjoint problem: A.T * lambda = c\n        # Since A is real and symmetric, A.T = A.\n        lambda_adj = spsolve(A.T, c)\n\n        # Compute gradient vector g = df/d(rho)\n        # g_j = -omega^2 * mu * (eps_max - eps_min) * lambda_j * u_j\n        g = -(omega**2 * mu * (eps_max - eps_min)) * (lambda_adj * u)\n        \n        # Compute directional derivative: g . d\n        adjoint_deriv = np.dot(g, d)\n\n        # --- 3. Complex-Step Derivative Calculation ---\n        # Perturb design variable: rho_cs = rho + i*delta*d\n        rho_cs = rho + 1j * delta * d\n        \n        # Complex material properties and system matrix\n        eps_rho_cs = eps_min + (eps_max - eps_min) * rho_cs\n        M_rho_cs = diags(eps_rho_cs, 0, shape=(N_dof, N_dof), format='csc')\n        A_cs = K + (omega**2 * mu) * M_rho_cs\n        \n        # Solve complex forward system: A_cs * u_cs = b\n        u_cs = spsolve(A_cs, b)\n        \n        # Evaluate complex objective function: f_cs = c.T * u_cs\n        f_cs = np.dot(c, u_cs)\n        \n        # Compute complex-step derivative estimate\n        cs_deriv = np.imag(f_cs) / delta\n\n        # --- 4. Calculate Relative Error ---\n        numerator = np.abs(adjoint_deriv - cs_deriv)\n        # Use a floor for the denominator to handle cases where the derivative is near zero\n        denominator = np.maximum(np.abs(adjoint_deriv), 1e-12)\n        relative_error = numerator / denominator\n        \n        results.append(relative_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}