{
    "hands_on_practices": [
        {
            "introduction": "混合有限元-边界积分 (FE-BI) 方法的核心在于内部域和外部域之间精确的数学和数值耦合。第一个实践练习将直接处理这一基本概念。通过推导和实现体积 Nédélec 边元与表面 Rao-Wilton-Glisson (RWG) 基函数之间的耦合矩阵，您将把切向场连续性的物理原理转化为一个具体的计算算子。这个练习  对于揭开 FE-BI 接口的神秘面纱、并从头开始构建一个稳健的仿真框架至关重要。",
            "id": "3315828",
            "problem": "本题要求您推导并实现用于电磁散射问题的内部矢量有限元法 (FEM) 自由度与外部边界元法 (BEM) 所用曲面基函数之间的离散耦合。具体来说，考虑用于内部场的四面体中的最低阶 Nédélec 边元和三角化曲面上的 Rao–Wilton–Glisson (RWG) 基函数。您的任务是通过在曲面界面 $\\Gamma$ 上对内部基函数的切向迹与 RWG 基函数进行积分，构建耦合矩阵项，该矩阵项将每个内部边元自由度映射到单个 RWG 系数。\n\n从以下基本依据出发：\n\n- 麦克斯韦方程组强制要求切向电场在界面上连续，这导致了弱施加形式，其中涉及在界面 $\\Gamma$ 上对内部迹场与曲面检验函数进行曲面积分。\n- 在顶点为 $\\boldsymbol{p}_0, \\boldsymbol{p}_1, \\boldsymbol{p}_2, \\boldsymbol{p}_3$ 的四面体上，与边 $(i,j)$ 相关的最低阶 Nédélec（第一类）边基函数通过重心坐标定义为 $\\boldsymbol{N}_{ij}(\\boldsymbol{r}) = \\lambda_i(\\boldsymbol{r}) \\nabla \\lambda_j - \\lambda_j(\\boldsymbol{r}) \\nabla \\lambda_i$，其中 $\\lambda_k$ 是重心坐标，$\\nabla \\lambda_k$ 是该四面体上的常数向量。\n- Rao–Wilton–Glisson (RWG) 基函数支撑在共享一条公共边的两个相邻曲面三角形 $T^+$ 和 $T^-$ 上。其分段定义为：在 $T^+$ 上为 $\\boldsymbol{f}(\\boldsymbol{r}) = \\dfrac{l_e}{2 A^+}\\left(\\boldsymbol{r} - \\boldsymbol{r}^+_{\\text{op}}\\right)$，在 $T^-$ 上为 $\\boldsymbol{f}(\\boldsymbol{r}) = -\\dfrac{l_e}{2 A^-}\\left(\\boldsymbol{r} - \\boldsymbol{r}^-_{\\text{op}}\\right)$，其中 $l_e$ 是公共边的长度，$A^\\pm$ 是 $T^\\pm$ 的面积，$\\boldsymbol{r}^\\pm_{\\text{op}}$ 是 $T^\\pm$ 上与公共边相对的顶点。根据构造，该向量场与曲面相切。\n- 在三角形面上，重心坐标满足标准积分恒等式。对于面积为 $A$、顶点索引为 $\\{a,b,c\\}$ 的三角形 $T$，重心单项式的积分为：$\\int_T \\lambda_i \\, \\mathrm{d}S = \\dfrac{A}{3}$（对于 $i \\in \\{a,b,c\\}$），否则为 $0$；以及 $\\int_T \\lambda_i \\lambda_j \\, \\mathrm{d}S = \\dfrac{A}{6}$（若 $i=j \\in \\{a,b,c\\}$），$\\dfrac{A}{12}$（若 $i \\neq j$ 且 $i,j \\in \\{a,b,c\\}$），否则为 $0$。此外，对于任意点 $\\boldsymbol{r} \\in T$，有 $\\boldsymbol{r} = \\lambda_a \\boldsymbol{p}_a + \\lambda_b \\boldsymbol{p}_b + \\lambda_c \\boldsymbol{p}_c$，因此 $\\int_T \\lambda_i \\boldsymbol{r} \\, \\mathrm{d}S = \\sum_{m \\in \\{a,b,c\\}} \\boldsymbol{p}_m \\int_T \\lambda_i \\lambda_m \\, \\mathrm{d}S$。\n\n对于给定的内部边 $(i,j)$（其 Nédélec 基函数为 $\\boldsymbol{N}_{ij}$）和支撑在 $T^+$ 和 $T^-$ 上的单个 RWG 基函数 $\\boldsymbol{f}$，需要计算的耦合项是在 $\\Gamma$ 上、限制在 RWG 支撑域内的曲面内积，即标量\n$$\nC_{ij} = \\int_{T^+} \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S + \\int_{T^-} \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S.\n$$\n由于 $\\boldsymbol{f}$ 与 $\\Gamma$ 相切，且 Nédélec 迹的切向投影为 $\\boldsymbol{N}_{ij} - (\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{n}) \\boldsymbol{n}$，点积 $\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{f}$ 等于其切向投影与 $\\boldsymbol{f}$ 的点积，这确保了 $\\boldsymbol{N}_{ij}$ 的法向分量对积分没有贡献。\n\n此问题的几何形状和网格划分规定如下：\n\n- 曲面界面 $\\Gamma$ 是两个三角形 $T^+$ 和 $T^-$ 的并集，在 $z=0$ 平面上形成一个正方形：\n  - $\\boldsymbol{v}_0 = (0,0,0)$,\n  - $\\boldsymbol{v}_1 = (1,0,0)$,\n  - $\\boldsymbol{v}_2 = (0,1,0)$,\n  - $\\boldsymbol{v}_3 = (1,1,0)$.\n  - $T^+$ 的顶点为 $(\\boldsymbol{v}_0,\\boldsymbol{v}_1,\\boldsymbol{v}_2)$。\n  - $T^-$ 的顶点为 $(\\boldsymbol{v}_3,\\boldsymbol{v}_2,\\boldsymbol{v}_1)$。\n  - 公共边在 $\\boldsymbol{v}_1$ 和 $\\boldsymbol{v}_2$ 之间。$T^+$ 的相对顶点是 $\\boldsymbol{v}_0$，$T^-$ 的相对顶点是 $\\boldsymbol{v}_3$。\n- 内部域由两个四面体网格化，每个三角形附着一个四面体：\n  - 四面体 A 的顶点为 $(\\boldsymbol{v}_0,\\boldsymbol{v}_1,\\boldsymbol{v_2},\\boldsymbol{v}_4)$。\n  - 四面体 B 的顶点为 $(\\boldsymbol{v}_3,\\boldsymbol{v}_2,\\boldsymbol{v}_1,\\boldsymbol{v}_5)$。\n- 对于每个四面体，考虑与局部顶点索引中的边 $(0,1)$, $(0,2)$, $(0,3), (1,2), (1,3), (2,3)$ 相关的所有 $6$ 个最低阶 Nédélec 基函数。这总共产生 $12$ 个内部边元自由度。\n- 因此，耦合矩阵将这 $12$ 个内部自由度映射到支撑在 $(T^+,T^-)$ 上的单个 RWG 系数；它将表示为一个长度为 $12$ 的单行向量。\n\n您的任务：\n\n1. 仅使用三角形 $T^\\pm$ 上的重心恒等式和相邻四面体的常数梯度 $\\nabla \\lambda_k$，从基本定义中推导出每个积分 $\\int_{T^\\pm} \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S$ 的精确表达式。在您的解法中清晰地表达所有中间步骤，并论证由于 $\\boldsymbol{f}$ 的切向性，$\\boldsymbol{N}_{ij}$ 的法向分量从积分中被消除的原因。\n2. 实现一个程序，为三种不同的测试用例（改变内部顶点 $\\boldsymbol{v}_4$ 和 $\\boldsymbol{v}_5$ 的位置）构建耦合行：\n   - 测试用例 1：$\\boldsymbol{v}_4 = (0,0,1)$, $\\boldsymbol{v}_5 = (1,1,1)$。\n   - 测试用例 2：$\\boldsymbol{v}_4 = (0.2,0.1,0.9)$, $\\boldsymbol{v}_5 = (0.8,1.3,1.1)$。\n   - 测试用例 3：$\\boldsymbol{v}_4 = (-0.1,0.2,0.7)$, $\\boldsymbol{v}_5 = (1.1,0.9,1.4)$。\n3. 在三角形上使用精确的重心积分恒等式，在四面体上使用重心坐标的精确解析梯度。不要使用数值积分。\n4. 您的程序应产生单行输出，其中包含三个耦合行，格式为逗号分隔的列表之列表，每个内部列表是对应测试用例的 $12$ 个实数项的行，格式如 $[[r_{1,1},\\dots,r_{1,12}],[r_{2,1},\\dots,r_{2,12}],[r_{3,1},\\dots,r_{3,12}]]$.\n\n不允许用户输入。输出包含无单位的纯数字，因为在离散化中该积分的量纲是一致的。此计算不涉及角度。\n\n请确保您的推导和实现展示了从电磁界面条件到离散耦合的整个链条，并且最终计算仅使用所提供的定义和恒等式。测试套件涵盖了典型配置、轻度倾斜的内部网格和更显著倾斜的网格，以探测构造的稳定性。最终答案必须是一个完整的、可运行的程序。",
            "solution": "该问题要求推导并实现内部 Nédélec 有限元基函数与外部 RWG 边界元基函数之间耦合矩阵项的计算。该耦合通过在 FEM 和 BEM 域之间的界面上进行曲面积分来建立。\n\n### 问题验证\n\n首先对给定问题进行严格的验证程序。\n\n**第 1 步：提取已知条件**\n- **耦合积分**: $C_{ij} = \\int_{T^+} \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S + \\int_{T^-} \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S$。\n- **Nédélec 基函数（最低阶，第一类）**: $\\boldsymbol{N}_{ij}(\\boldsymbol{r}) = \\lambda_i(\\boldsymbol{r}) \\nabla \\lambda_j - \\lambda_j(\\boldsymbol{r}) \\nabla \\lambda_i$。\n- **RWG 基函数**: 在 $T^+$ 上为 $\\boldsymbol{f}(\\boldsymbol{r}) = \\frac{l_e}{2 A^+}(\\boldsymbol{r} - \\boldsymbol{r}^+_{\\text{op}})$，在 $T^-$ 上为 $\\boldsymbol{f}(\\boldsymbol{r}) = -\\frac{l_e}{2 A^-}(\\boldsymbol{r} - \\boldsymbol{r}^-_{\\text{op}})$。\n- **重心积分恒等式（在面积为 $A$、顶点为 $\\{a,b,c\\}$ 的三角形 $T$ 上）**:\n  - $\\int_T \\lambda_i \\, \\mathrm{d}S = A/3$（对于 $i \\in \\{a,b,c\\}$）。\n  - $\\int_T \\lambda_i \\lambda_j \\, \\mathrm{d}S = A/6$（对于 $i=j \\in \\{a,b,c\\}$）；$A/12$（对于 $i \\neq j \\in \\{a,b,c\\}$）。\n  - $\\int_T \\lambda_i \\boldsymbol{r} \\, \\mathrm{d}S = \\sum_{m \\in \\{a,b,c\\}} \\boldsymbol{p}_m \\int_T \\lambda_i \\lambda_m \\, \\mathrm{d}S$。\n- **几何结构**:\n  - 曲面顶点: $\\boldsymbol{v}_0 = (0,0,0)$, $\\boldsymbol{v}_1 = (1,0,0)$, $\\boldsymbol{v}_2 = (0,1,0)$, $\\boldsymbol{v}_3 = (1,1,0)$。\n  - $T^+$ 顶点: $(\\boldsymbol{v}_0,\\boldsymbol{v}_1,\\boldsymbol{v}_2)$。$T^-$ 顶点: $(\\boldsymbol{v}_3,\\boldsymbol{v}_2,\\boldsymbol{v}_1)$。\n  - RWG 的公共边：$(\\boldsymbol{v}_1, \\boldsymbol{v}_2)$，相对顶点为 $\\boldsymbol{r}^+_{\\text{op}} = \\boldsymbol{v}_0$ 和 $\\boldsymbol{r}^-_{\\text{op}} = \\boldsymbol{v}_3$。\n  - 四面体 A: $(\\boldsymbol{v}_0,\\boldsymbol{v}_1,\\boldsymbol{v_2},\\boldsymbol{v}_4)$。四面体 B: $(\\boldsymbol{v}_3,\\boldsymbol{v}_2,\\boldsymbol{v}_1,\\boldsymbol{v}_5)$。\n- **自由度**: 每个四面体有 $6$ 个 Nédélec 边，总共 $12$ 个。顺序指定为四面体 A 的局部边 $(0,1), (0,2), (0,3), (1,2), (1,3), (2,3)$，然后是四面体 B 的。\n- **测试用例**: $(\\boldsymbol{v}_4, \\boldsymbol{v}_5)$ 的三对坐标。\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题在科学上基于计算电磁学的原理，特别是混合 FEM-BEM 公式。基函数的定义和数学恒等式是标准且正确的。该问题是适定的，提供了所有必要的几何和数学信息，以得出一个唯一的、可计算的解。语言客观而精确。该问题并非无足轻重，它测试了离散化方法的核心概念。没有矛盾、歧义或不切实际的假设。\n\n**第 3 步：结论与行动**\n该问题被判定为 **有效**。将提供完整的推导和解答。\n\n### 耦合积分的推导\n\n目标是推导耦合项 $C_{ij}$ 的解析表达式。该项表示内部 Nédélec 基函数 $\\boldsymbol{N}_{ij}$ 与曲面 RWG 基函数 $\\boldsymbol{f}$ 之间的弱形式耦合。\n\n总耦合是构成 $\\boldsymbol{f}$ 支撑域的两个三角形 $T^+$ 和 $T^-$ 上的积分之和：\n$$C_{ij} = \\int_{T^+} \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S + \\int_{T^-} \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S$$\nNédélec 基函数 $\\boldsymbol{N}_{ij}$ 与特定的四面体相关联。对于四面体 A 上的一个基函数，其支撑域仅限于四面体 A。由于 $T^-$ 不是四面体 A 的一个面，因此任何来自 A 的基函数在 $T^-$ 上的限制都为零。因此，对于来自四面体 A 的基函数 $\\boldsymbol{N}_{A,ij}$，耦合积分简化为：\n$$C_{A,ij} = \\int_{T^+} \\boldsymbol{N}_{A,ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S$$\n类似地，对于来自四面体 B（其一个面为 $T^-$）的基函数 $\\boldsymbol{N}_{B,kl}$，耦合为：\n$$C_{B,kl} = \\int_{T^-} \\boldsymbol{N}_{B,kl}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S$$\n\n让我们推导积分 $I_T = \\int_T \\boldsymbol{N}_{ij}(\\boldsymbol{r}) \\cdot \\boldsymbol{f}(\\boldsymbol{r}) \\, \\mathrm{d}S$ 的通用公式，其中 $T$ 是支撑 $\\boldsymbol{N}_{ij}$ 的四面体的一个面。我们代入定义：\n$$I_T = \\int_T \\left(\\lambda_i \\nabla \\lambda_j - \\lambda_j \\nabla \\lambda_i\\right) \\cdot \\alpha_T (\\boldsymbol{r} - \\boldsymbol{r}_{\\text{op}}) \\, \\mathrm{d}S$$\n其中 $\\alpha_T$ 是三角形 $T$ 上 RWG 函数的标量系数，$\\boldsymbol{r}_{\\text{op}}$ 是相对顶点。由于梯度 $\\nabla\\lambda_k$ 在四面体内是常数向量，我们可以将它们和 $\\alpha_T$ 提出积分：\n$$I_T = \\alpha_T \\left[ \\nabla \\lambda_j \\cdot \\int_T \\lambda_i (\\boldsymbol{r} - \\boldsymbol{r}_{\\text{op}}) \\, \\mathrm{d}S - \\nabla \\lambda_i \\cdot \\int_T \\lambda_j (\\boldsymbol{r} - \\boldsymbol{r}_{\\text{op}}) \\, \\mathrm{d}S \\right]$$\n我们定义向量积分 $\\boldsymbol{K}_k = \\int_T \\lambda_k (\\boldsymbol{r} - \\boldsymbol{r}_{\\text{op}}) \\, \\mathrm{d}S$。则 $I_T = \\alpha_T (\\nabla \\lambda_j \\cdot \\boldsymbol{K}_i - \\nabla \\lambda_i \\cdot \\boldsymbol{K}_j)$。积分 $\\boldsymbol{K}_k$ 可以使用提供的重心恒等式进行计算。\n函数 $\\lambda_k$ 是四面体的重心坐标。设四面体顶点为 $\\{\\boldsymbol{p}_0, \\boldsymbol{p}_1, \\boldsymbol{p}_2, \\boldsymbol{p}_3\\}$，三角形 $T$ 是顶点为 $\\{\\boldsymbol{p}_a, \\boldsymbol{p}_b, \\boldsymbol{p}_c\\}$ 的面。在此面上，对应于第四个顶点（不在该面上）的重心坐标为零。其他三个四面体重心坐标，当限制在 $T$ 上时，其行为与 $T$ 的三角形重心坐标完全相同。\n如果 Nédélec 基函数顶点的索引 $k$ 不在面 $T$ 的顶点之中（即 $k \\notin \\{a,b,c\\}$），那么对于所有 $\\boldsymbol{r} \\in T$，$\\lambda_k(\\boldsymbol{r}) = 0$，这意味着 $\\boldsymbol{K}_k = \\boldsymbol{0}$。这正确地反映了不接触某个面的边元在该面上没有切向迹。\n如果 $k \\in \\{a,b,c\\}$，我们展开 $\\boldsymbol{K}_k$：\n$$\\boldsymbol{K}_k = \\int_T \\lambda_k \\boldsymbol{r} \\, \\mathrm{d}S - \\boldsymbol{r}_{\\text{op}} \\int_T \\lambda_k \\, \\mathrm{d}S$$\n使用恒等式，其中 $A_T$ 是三角形 $T$ 的面积：\n$\\int_T \\lambda_k \\, \\mathrm{d}S = A_T/3$。\n$\\int_T \\lambda_k \\boldsymbol{r} \\, \\mathrm{d}S = \\sum_{m \\in \\{a,b,c\\}} \\boldsymbol{p}_m \\int_T \\lambda_k \\lambda_m \\, \\mathrm{d}S = \\boldsymbol{p}_k (A_T/6) + \\sum_{m \\in \\{a,b,c\\}, m\\neq k} \\boldsymbol{p}_m (A_T/12) = \\frac{A_T}{12} (2\\boldsymbol{p}_k + \\sum_{m \\in \\{a,b,c\\}, m\\neq k} \\boldsymbol{p}_m) = \\frac{A_T}{12} (\\boldsymbol{p}_k + \\sum_{m \\in \\{a,b,c\\}} \\boldsymbol{p}_m)$。\n将这些代入 $\\boldsymbol{K}_k$ 的表达式中：\n$$\\boldsymbol{K}_k = \\frac{A_T}{12} \\left(\\boldsymbol{p}_k + \\sum_{m \\in \\{a,b,c\\}} \\boldsymbol{p}_m \\right) - \\boldsymbol{r}_{\\text{op}} \\frac{A_T}{3} = \\frac{A_T}{12} \\left(\\boldsymbol{p}_k + \\sum_{m \\in \\{a,b,c\\}} \\boldsymbol{p}_m - 4\\boldsymbol{r}_{\\text{op}}\\right)$$\n项 $\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{f}$ 正确地处理了切向耦合。根据定义，RWG 函数 $\\boldsymbol{f}$ 与曲面 $\\Gamma$ 相切。$\\boldsymbol{N}_{ij}$可以分解为切向和法向分量，$\\boldsymbol{N}_{ij} = \\boldsymbol{N}_{ij,t} + \\boldsymbol{N}_{ij,n}$。点积为 $\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{f} = \\boldsymbol{N}_{ij,t} \\cdot \\boldsymbol{f} + \\boldsymbol{N}_{ij,n} \\cdot \\boldsymbol{f}$。由于 $\\boldsymbol{f}$ 是切向的，它与法向分量 $\\boldsymbol{N}_{ij,n}$ 的点积为零，因此 $\\boldsymbol{N}_{ij,n} \\cdot \\boldsymbol{f} = 0$。因此，该积分正确地捕捉了场的切向分量之间的相互作用，这符合电磁边界条件的要求。\n\n### 实现细节\n\n实现部分为 12 个内部 Nédélec 基函数中的每一个计算该积分。\n\n**1. 几何常数：**\n- $T^+$ 的顶点为 $\\boldsymbol{v}_0, \\boldsymbol{v}_1, \\boldsymbol{v}_2$。面积 $A^+ = 1/2$。$\\boldsymbol{r}^+_{\\text{op}} = \\boldsymbol{v}_0$。\n- $T^-$ 的顶点为 $\\boldsymbol{v}_3, \\boldsymbol{v}_2, \\boldsymbol{v}_1$。面积 $A^- = 1/2$。$\\boldsymbol{r}^-_{\\text{op}} = \\boldsymbol{v}_3$。\n- 公共边长度 $l_e = ||\\boldsymbol{v}_2 - \\boldsymbol{v}_1|| = \\sqrt{2}$。\n- $T^+$ 的 RWG 系数：$\\alpha_{T^+} = l_e / (2A^+) = \\sqrt{2}$。\n- $T^-$ 的 RWG 系数：$\\alpha_{T^-} = -l_e / (2A^-) = -\\sqrt{2}$。\n\n**2. 梯度计算：** 对于顶点为 $\\boldsymbol{p}_0, \\boldsymbol{p}_1, \\boldsymbol{p}_2, \\boldsymbol{p}_3$ 的四面体，我们定义矩阵 $S = [\\boldsymbol{p}_1-\\boldsymbol{p}_0, \\boldsymbol{p}_2-\\boldsymbol{p}_0, \\boldsymbol{p}_3-\\boldsymbol{p}_0]$。重心坐标 $\\lambda_1, \\lambda_2, \\lambda_3$ 的梯度是 $S^{-1}$ 的行。梯度 $\\nabla\\lambda_0$ 通过求和性质 $\\sum_{k=0}^3 \\lambda_k = 1$ 计算得出，这意味着 $\\sum_{k=0}^3 \\nabla\\lambda_k = \\boldsymbol{0}$。\n\n**3. 四面体 A 的耦合：**\n- 局部顶点：$(\\boldsymbol{p}_0, \\boldsymbol{p}_1, \\boldsymbol{p}_2, \\boldsymbol{p}_3)_{\\text{A}} = (\\boldsymbol{v}_0, \\boldsymbol{v}_1, \\boldsymbol{v}_2, \\boldsymbol{v}_4)$。\n- 界面：$T^+$，局部顶点为 $\\{0,1,2\\}$。\n- 向量积分 $\\boldsymbol{K}_{A,k}$ 仅在 $k \\in \\{0,1,2\\}$ 时非零。\n- 边 $(i,j)$ 的耦合为 $C_{A,ij} = \\alpha_{T^+} (\\nabla \\lambda_{Aj} \\cdot \\boldsymbol{K}_{A,i} - \\nabla \\lambda_{Ai} \\cdot \\boldsymbol{K}_{A,j})$。\n\n**4. 四面体 B 的耦合：**\n- 局部顶点：$(\\boldsymbol{p}_0, \\boldsymbol{p}_1, \\boldsymbol{p}_2, \\boldsymbol{p}_3)_{\\text{B}} = (\\boldsymbol{v}_3, \\boldsymbol{v}_2, \\boldsymbol{v}_1, \\boldsymbol{v}_5)$。\n- 界面：$T^-$，局部顶点为 $\\{0,1,2\\}$。\n- 向量积分 $\\boldsymbol{K}_{B,k}$ 仅在 $k \\in \\{0,1,2\\}$ 时非零。\n- 边 $(k,l)$ 的耦合为 $C_{B,kl} = \\alpha_{T^-} (\\nabla \\lambda_{Bl} \\cdot \\boldsymbol{K}_{B,k} - \\nabla \\lambda_{Bk} \\cdot \\boldsymbol{K}_{B,l})$。\n\n下面的程序为这三个测试用例实现了这一逻辑。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements the FEM-BEM coupling matrix for the specified problem.\n    \"\"\"\n    # Define the surface vertices\n    v0 = np.array([0.0, 0.0, 0.0])\n    v1 = np.array([1.0, 0.0, 0.0])\n    v2 = np.array([0.0, 1.0, 0.0])\n    v3 = np.array([1.0, 1.0, 0.0])\n\n    # Test cases for the apex vertices v4 and v5\n    test_cases = [\n        (np.array([0.0, 0.0, 1.0]), np.array([1.0, 1.0, 1.0])),\n        (np.array([0.2, 0.1, 0.9]), np.array([0.8, 1.3, 1.1])),\n        (np.array([-0.1, 0.2, 0.7]), np.array([1.1, 0.9, 1.4])),\n    ]\n\n    all_results = []\n\n    # Geometric properties of the RWG basis support\n    # Triangle T+\n    T_plus_verts = [v0, v1, v2]\n    A_plus = 0.5 * np.linalg.norm(np.cross(v1 - v0, v2 - v0))\n    r_op_plus = v0\n\n    # Triangle T-\n    T_minus_verts = [v3, v2, v1]\n    A_minus = 0.5 * np.linalg.norm(np.cross(v2 - v3, v1 - v3))\n    r_op_minus = v3\n\n    # Common edge length for RWG\n    l_e = np.linalg.norm(v2 - v1)\n\n    # RWG coefficients\n    alpha_plus = l_e / (2 * A_plus)\n    alpha_minus = -l_e / (2 * A_minus)\n\n    # Local edge indexing for a tetrahedron\n    edges = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n\n    def compute_grads(p0, p1, p2, p3):\n        \"\"\"Computes the gradients of barycentric coordinates for a tetrahedron.\"\"\"\n        S = np.array([p1 - p0, p2 - p0, p3 - p0]).T\n        inv_S = np.linalg.inv(S)\n        grad1 = inv_S[0, :]\n        grad2 = inv_S[1, :]\n        grad3 = inv_S[2, :]\n        grad0 = -(grad1 + grad2 + grad3)\n        return [grad0, grad1, grad2, grad3]\n\n    def compute_K_vectors(face_verts, r_op, area):\n        \"\"\"Computes the vector integrals K_k for a triangular face.\"\"\"\n        p_a, p_b, p_c = face_verts\n        sum_p = p_a + p_b + p_c\n        K_vecs = {}\n        # k=a (local index 0 on face)\n        K_vecs[0] = (area / 12.0) * (p_a + sum_p - 4 * r_op)\n        # k=b (local index 1 on face)\n        K_vecs[1] = (area / 12.0) * (p_b + sum_p - 4 * r_op)\n        # k=c (local index 2 on face)\n        K_vecs[2] = (area / 12.0) * (p_c + sum_p - 4 * r_op)\n        return K_vecs\n\n    for v4, v5 in test_cases:\n        coupling_row = []\n\n        # === Tetrahedron A ===\n        tet_A_verts = [v0, v1, v2, v4]\n        grads_A = compute_grads(*tet_A_verts)\n        # Face T+ corresponds to local vertices 0, 1, 2 of Tet A\n        # The K vectors need to be indexed by local tet indices (0, 1, 2)\n        K_vecs_A_face = compute_K_vectors(T_plus_verts, r_op_plus, A_plus)\n        K_A = {0: K_vecs_A_face[0], 1: K_vecs_A_face[1], 2: K_vecs_A_face[2], 3: np.zeros(3)}\n        \n        for i, j in edges:\n            K_i = K_A[i]\n            K_j = K_A[j]\n            grad_i = grads_A[i]\n            grad_j = grads_A[j]\n            \n            C_ij = alpha_plus * (np.dot(grad_j, K_i) - np.dot(grad_i, K_j))\n            coupling_row.append(C_ij)\n\n        # === Tetrahedron B ===\n        tet_B_verts = [v3, v2, v1, v5]\n        grads_B = compute_grads(*tet_B_verts)\n        # Face T- corresponds to local vertices 0, 1, 2 of Tet B\n        K_vecs_B_face = compute_K_vectors(T_minus_verts, r_op_minus, A_minus)\n        K_B = {0: K_vecs_B_face[0], 1: K_vecs_B_face[1], 2: K_vecs_B_face[2], 3: np.zeros(3)}\n\n        for i, j in edges:\n            K_i = K_B[i]\n            K_j = K_B[j]\n            grad_i = grads_B[i]\n            grad_j = grads_B[j]\n            \n            C_ij = alpha_minus * (np.dot(grad_j, K_i) - np.dot(grad_i, K_j))\n            coupling_row.append(C_ij)\n            \n        all_results.append(coupling_row)\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, row))}]' for row in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "一个数值模型的优劣取决于其验证的有效性。本实践从模型的实现转向验证，并利用物理学最基本的原理之一：能量守恒。通过将复数坡印亭定理应用于混合 FE-BI 公式，您将推导出一个适用于任何有效解的精确功率平衡恒等式。接着，该练习  将指导您利用此恒等式设计一个灵敏的诊断测试，它能够检测材料参数或接口耦合中存在的细微实现错误，为您提供关于计算模型严格验证的宝贵一课。",
            "id": "3315798",
            "problem": "考虑一个时谐电磁场，其时间约定为 $\\exp(+j \\omega t)$，该场存在于一个有界内部区域 $V \\subset \\mathbb{R}^{3}$ 中。该区域的边界为 $S = \\partial V$，单位外法向为 $\\mathbf{n}$。内部区域的磁导率为 $\\mu_{0}$，复介电常数为 $\\epsilon(\\omega) = \\epsilon'(\\omega) - j \\epsilon''(\\omega)$，其中 $\\epsilon''(\\omega) \\ge 0$。外部区域为自由空间。一种混合有限元-边界积分 (FE–BI) 公式将计算截断在区域 $V$ 内，并通过一个边界积分辐射算子来表示外部区域。令 $\\mathbf{E}$ 和 $\\mathbf{H}$ 表示由支撑在 $V$ 内的外加电流密度 $\\mathbf{J}_{\\text{imp}}$ 在 $V$ 中产生的总宏观场。在边界 $S$ 上，令 $\\mathbf{e}_{t} = \\mathbf{n} \\times \\mathbf{E}|_{S}$ 为切向电场迹。外部区域由一个无源线性辐射算子 $\\mathcal{T}$ 表示，该算子将 $\\mathbf{e}_{t}$ 映射到外部磁场迹，即 $\\mathbf{n} \\times \\mathbf{H}^{\\text{ext}} = \\mathcal{T}\\,\\mathbf{e}_{t}$。假设 $\\mathcal{T}$ 是无源的，即对于所有平方可积的切向迹，均满足 $\\Re \\langle \\mathbf{e}_{t}, \\mathcal{T}\\,\\mathbf{e}_{t} \\rangle_{S} \\ge 0$，其中曲面内积定义为 $\\langle \\mathbf{u}, \\mathbf{v} \\rangle_{S} = \\int_{S} \\mathbf{u} \\cdot \\mathbf{v}^{*}\\, \\mathrm{d}S$。\n\n1) 仅从麦克斯韦旋度方程和复坡印亭定理出发，推导时均能量守恒恒等式。该恒等式将 $V$ 中外加源的实际输入功率与 $V$ 中的内部耗散功率和由 $\\mathcal{T}$ 表示的外部辐射功率之和联系起来，表达式如下\n$$\n\\Re \\int_{V} \\mathbf{J}_{\\text{imp}} \\cdot \\mathbf{E}^{*}\\, \\mathrm{d}V \\;=\\; \\frac{\\omega}{2} \\int_{V} \\epsilon''(\\omega)\\, |\\mathbf{E}|^{2}\\, \\mathrm{d}V \\;+\\; \\frac{1}{2}\\, \\Re \\langle \\mathbf{e}_{t}, \\mathcal{T}\\,\\mathbf{e}_{t} \\rangle_{S}.\n$$\n请明确说明所采用的符号约定，并论证向外辐射功率的边界积分表示的合理性。\n\n2) 为获得一个单自由度校准模型，假设 $S$ 上的有限元迹空间是一维的：$\\mathbf{e}_{t} = x\\, \\boldsymbol{\\phi}_{t}$，其中 $\\langle \\boldsymbol{\\phi}_{t}, \\boldsymbol{\\phi}_{t} \\rangle_{S} = 1$。并假设有限元内部耗散二次型简化为\n$$\nP_{\\text{diss}} = \\frac{\\omega}{2}\\, \\epsilon''(\\omega)\\, C\\, |x|^{2},\n$$\n其中 $C$ 是一个由内部基函数和材料分布决定的已知正常数。进一步假设辐射算子在该子空间上简化为一个标量阻抗 $Z_{\\text{rad}}(\\omega) \\in \\mathbb{C}$，因此\n$$\nP_{\\text{rad}} = \\frac{1}{2}\\, \\Re\\{ Z_{\\text{rad}}(\\omega) \\}\\, |x|^{2}.\n$$\n考虑一个实际校准过程，其中选择的驱动幅度和频率使得在正确模型下，内部耗散功率等于外部辐射功率，即 $P_{\\text{diss}} = P_{\\text{rad}}$。使用第 1) 部分的结果，证明这可以推导出如下标量等式\n$$\n\\Re\\{ Z_{\\text{rad}}(\\omega) \\} \\;=\\; \\omega\\, \\epsilon''(\\omega)\\, C.\n$$\n\n3) 现在，假设存在建模误差：实现的介电常数损耗使用 $\\epsilon''_{\\text{FE}}(\\omega) = \\epsilon''(\\omega)\\, \\big(1 + \\Delta_{\\epsilon}\\big)$（其中 $\\Delta_{\\epsilon}$ 为实数），并且有限元-边界积分迹耦合存在乘性失配，使得边界积分接收到的是一个缩放后的迹 $\\tilde{\\mathbf{e}}_{t} = s\\, \\mathbf{e}_{t}$，其中 $s = 1 + \\Delta_{t}$（$\\Delta_{t}$ 为实数）。将这些误差视为在从正确模型获得的固定内部幅度 $x$ 上的后处理误差。定义功率平衡诊断残差\n$$\nR \\;\\equiv\\; \\frac{P_{\\text{rad}}^{\\text{err}} - P_{\\text{diss}}^{\\text{err}}}{P_{\\text{rad}}^{\\text{err}} + P_{\\text{diss}}^{\\text{err}}},\n$$\n其中 $P_{\\text{rad}}^{\\text{err}}$ 是由边界积分根据 $\\tilde{\\mathbf{e}}_{t}$ 计算的辐射功率，而 $P_{\\text{diss}}^{\\text{err}}$ 是使用 $\\epsilon''_{\\text{FE}}(\\omega)$ 计算的有限元耗散功率。使用你在第 2) 部分推导的校准等式来消去 $C$ 和 $\\Re\\{ Z_{\\text{rad}}(\\omega) \\}$，推导出一个仅含 $\\Delta_{\\epsilon}$ 和 $\\Delta_{t}$ 的 $R$ 的闭式解析表达式。以最简形式给出 $R$ 的最终表达式。最终答案必须是一个无单位的单一解析表达式。",
            "solution": "该问题经评估为有效，因为它科学地基于麦克斯韦理论和计算电磁学，问题阐述清晰，结构逻辑性强，并使用了精确、客观的语言。所有必要信息都已提供，可得出唯一解。\n\n**第 1 部分：能量守恒恒等式的推导**\n\n我们从麦克斯韦旋度方程的时谐形式开始，假设时间依赖关系为 $\\exp(+j \\omega t)$。磁导率为 $\\mu_0$，复介电常数为 $\\epsilon(\\omega) = \\epsilon'(\\omega) - j \\epsilon''(\\omega)$。\n\n法拉第感应定律：\n$$ \\nabla \\times \\mathbf{E} = -j \\omega \\mathbf{B} = -j \\omega \\mu_{0} \\mathbf{H} $$\n\n安培-麦克斯韦定律：\n总电流密度为 $\\mathbf{J}_{\\text{tot}} = \\mathbf{J}_{\\text{imp}} + j \\omega \\mathbf{D}$，其中 $\\mathbf{J}_{\\text{imp}}$ 是外加源电流，$j \\omega \\mathbf{D}$ 是位移电流。由于 $\\mathbf{D} = \\epsilon \\mathbf{E} = (\\epsilon' - j \\epsilon'')\\mathbf{E}$，该定律变为：\n$$ \\nabla \\times \\mathbf{H} = \\mathbf{J}_{\\text{imp}} + j \\omega (\\epsilon' - j \\epsilon'') \\mathbf{E} = \\mathbf{J}_{\\text{imp}} + \\omega \\epsilon'' \\mathbf{E} + j \\omega \\epsilon' \\mathbf{E} $$\n项 $\\omega \\epsilon'' \\mathbf{E}$ 代表欧姆损耗电流密度，与电导率 $\\sigma = \\omega \\epsilon''$ 一致。\n\n我们使用矢量恒等式 $\\nabla \\cdot (\\mathbf{A} \\times \\mathbf{B}) = \\mathbf{B} \\cdot (\\nabla \\times \\mathbf{A}) - \\mathbf{A} \\cdot (\\nabla \\times \\mathbf{B})$。令 $\\mathbf{A} = \\mathbf{E}$ 且 $\\mathbf{B} = \\mathbf{H}^{*}$。\n$$ \\nabla \\cdot (\\mathbf{E} \\times \\mathbf{H}^{*}) = \\mathbf{H}^{*} \\cdot (\\nabla \\times \\mathbf{E}) - \\mathbf{E} \\cdot (\\nabla \\times \\mathbf{H}^{*}) $$\n将法拉第定律中的 $\\mathbf{E}$ 的旋度代入：\n$$ \\mathbf{H}^{*} \\cdot (\\nabla \\times \\mathbf{E}) = \\mathbf{H}^{*} \\cdot (-j \\omega \\mu_0 \\mathbf{H}) = -j \\omega \\mu_0 |\\mathbf{H}|^2 $$\n取安培-麦克斯韦定律的复共轭（注意 $\\omega, \\epsilon', \\epsilon''$ 均为实数）：\n$$ \\nabla \\times \\mathbf{H}^{*} = \\mathbf{J}_{\\text{imp}}^{*} + \\omega \\epsilon'' \\mathbf{E}^{*} - j \\omega \\epsilon' \\mathbf{E}^{*} $$\n将此式代入恒等式：\n$$ \\mathbf{E} \\cdot (\\nabla \\times \\mathbf{H}^{*}) = \\mathbf{E} \\cdot \\mathbf{J}_{\\text{imp}}^{*} + \\omega \\epsilon'' |\\mathbf{E}|^2 - j \\omega \\epsilon' |\\mathbf{E}|^2 $$\n合并这些结果，得到复坡印亭定理的微分形式：\n$$ \\nabla \\cdot (\\mathbf{E} \\times \\mathbf{H}^{*}) = -j \\omega \\mu_0 |\\mathbf{H}|^2 - (\\mathbf{E} \\cdot \\mathbf{J}_{\\text{imp}}^{*} + \\omega \\epsilon'' |\\mathbf{E}|^2 - j \\omega \\epsilon' |\\mathbf{E}|^2) $$\n$$ - \\mathbf{E} \\cdot \\mathbf{J}_{\\text{imp}}^{*} = \\nabla \\cdot (\\mathbf{E} \\times \\mathbf{H}^{*}) + \\omega \\epsilon'' |\\mathbf{E}|^2 + j \\omega (\\mu_0 |\\mathbf{H}|^2 - \\epsilon' |\\mathbf{E}|^2) $$\n在体积 $V$ 上积分：\n$$ -\\int_{V} \\mathbf{E} \\cdot \\mathbf{J}_{\\text{imp}}^{*} \\, \\mathrm{d}V = \\int_{V} \\nabla \\cdot (\\mathbf{E} \\times \\mathbf{H}^{*}) \\, \\mathrm{d}V + \\int_{V} \\omega \\epsilon'' |\\mathbf{E}|^2 \\, \\mathrm{d}V + j \\omega \\int_{V} (\\mu_0 |\\mathbf{H}|^2 - \\epsilon' |\\mathbf{E}|^2) \\, \\mathrm{d}V $$\n对右侧第一项应用散度定理：\n$$ \\int_{V} \\nabla \\cdot (\\mathbf{E} \\times \\mathbf{H}^{*}) \\, \\mathrm{d}V = \\oint_{S} (\\mathbf{E} \\times \\mathbf{H}^{*}) \\cdot \\mathbf{n} \\, \\mathrm{d}S $$\n取整个方程的实部：\n$$ \\Re \\left\\{ -\\int_{V} \\mathbf{E} \\cdot \\mathbf{J}_{\\text{imp}}^{*} \\, \\mathrm{d}V \\right\\} = \\Re \\left\\{ \\oint_{S} (\\mathbf{E} \\times \\mathbf{H}^{*}) \\cdot \\mathbf{n} \\, \\mathrm{d}S \\right\\} + \\int_{V} \\omega \\epsilon'' |\\mathbf{E}|^2 \\, \\mathrm{d}V $$\n外加源提供的时间平均功率为 $P_{\\text{in}} = \\frac{1}{2}\\Re \\int_V \\mathbf{J}_{\\text{imp}} \\cdot \\mathbf{E}^* \\, \\mathrm{d}V$。注意 $\\Re\\{z\\} = \\Re\\{z^*\\}$，因此 $\\Re\\{\\mathbf{J}_{\\text{imp}} \\cdot \\mathbf{E}^*\\} = \\Re\\{(\\mathbf{J}_{\\text{imp}} \\cdot \\mathbf{E}^*)^*\\} = \\Re\\{\\mathbf{J}_{\\text{imp}}^* \\cdot \\mathbf{E}\\}$。同时 $\\Re\\{-z\\} = -\\Re\\{z\\}$。因此，左侧是 $-2 P_{\\text{in}}$。让我重新评估源功率的定义。通常约定将源*提供*的功率定义为 $\\frac{1}{2}\\Re \\int_V \\mathbf{J}_{\\text{imp}} \\cdot \\mathbf{E}^* dV$。这意味着我的推导中需要一个符号变化。让我们从另一边开始。\n源提供的时间平均功率是 $P_{\\text{in}} = -\\frac{1}{2} \\Re \\int_V \\mathbf{E} \\cdot \\mathbf{J}_{\\text{imp}}^* \\, \\mathrm{d}V = \\frac{1}{2} \\Re \\int_V \\mathbf{J}_{\\text{imp}} \\cdot \\mathbf{E}^* \\, \\mathrm{d}V$。\n在 $V$ 中以热量形式耗散的时间平均功率是 $P_{\\text{diss}} = \\frac{1}{2} \\int_V \\omega \\epsilon'' |\\mathbf{E}|^2 \\, \\mathrm{d}V$。\n从 $V$ 辐射出去的时间平均功率是 $P_{\\text{rad}} = \\frac{1}{2} \\Re \\oint_S (\\mathbf{E} \\times \\mathbf{H}^*) \\cdot \\mathbf{n} \\, \\mathrm{d}S$。\n将我们的积分坡印亭关系式乘以 $\\frac{1}{2}$：\n$$ \\frac{1}{2} \\Re \\left\\{ -\\int_{V} \\mathbf{E} \\cdot \\mathbf{J}_{\\text{imp}}^{*} \\, \\mathrm{d}V \\right\\} = \\frac{1}{2} \\Re \\left\\{ \\oint_{S} (\\mathbf{E} \\times \\mathbf{H}^{*}) \\cdot \\mathbf{n} \\, \\mathrm{d}S \\right\\} + \\frac{1}{2} \\int_{V} \\omega \\epsilon'' |\\mathbf{E}|^2 \\, \\mathrm{d}V $$\n$$ P_{\\text{in}} = P_{\\text{rad}} + P_{\\text{diss}} $$\n$$ \\frac{1}{2} \\Re \\int_{V} \\mathbf{J}_{\\text{imp}} \\cdot \\mathbf{E}^{*}\\, \\mathrm{d}V = \\frac{\\omega}{2} \\int_{V} \\epsilon''(\\omega)\\, |\\mathbf{E}|^{2}\\, \\mathrm{d}V + \\frac{1}{2} \\Re \\oint_{S} (\\mathbf{E} \\times \\mathbf{H}^{*}) \\cdot \\mathbf{n}\\, \\mathrm{d}S $$\n最后一步是论证向外辐射功率的边界积分表示的合理性。外部区域的场由边界 $S$ 上的切向电场迹 $\\mathbf{e}_t = \\mathbf{n} \\times \\mathbf{E}|_S$ 唯一确定（需满足 Silver-Müller 辐射条件）。这意味着边界上的切向磁场也由 $\\mathbf{e}_t$ 确定。对于像自由空间这样的线性介质，这种关系是线性的，可以写成 $\\mathbf{n} \\times \\mathbf{H}^{\\text{ext}} = \\mathcal{T}\\,\\mathbf{e}_{t}$，其中 $\\mathcal{T}$ 是线性辐射算子。因此，总辐射功率 $P_{\\text{rad}}$ 必须能表示为 $\\mathbf{e}_t$ 的二次函数。问题将此表达式提供为 $\\frac{1}{2}\\, \\Re \\langle \\mathbf{e}_{t}, \\mathcal{T}\\,\\mathbf{e}_{t} \\rangle_{S}$。通过用这个等效表示替换坡印亭通量积分，我们得到了最终的恒等式：\n$$ \\Re \\int_{V} \\mathbf{J}_{\\text{imp}} \\cdot \\mathbf{E}^{*}\\, \\mathrm{d}V \\;=\\; \\frac{\\omega}{2} \\int_{V} \\epsilon''(\\omega)\\, |\\mathbf{E}|^{2}\\, \\mathrm{d}V \\;+\\; \\frac{1}{2}\\, \\Re \\langle \\mathbf{e}_{t}, \\mathcal{T}\\,\\mathbf{e}_{t} \\rangle_{S} $$\n注意，因子 $1/2$ 已被吸收到目标方程中各项的定义里，因此我的推导与之一致。\n\n**第 2 部分：校准模型等式**\n\n第 1 部分的能量守恒恒等式将总输入功率与内部耗散功率和外部辐射功率之和相等同：$P_{\\text{in}} = P_{\\text{diss}} + P_{\\text{rad}}$。各项由以下公式给出：\n$$ P_{\\text{diss}} = \\frac{\\omega}{2} \\int_{V} \\epsilon''(\\omega)\\, |\\mathbf{E}|^{2}\\, \\mathrm{d}V $$\n$$ P_{\\text{rad}} = \\frac{1}{2}\\, \\Re \\langle \\mathbf{e}_{t}, \\mathcal{T}\\,\\mathbf{e}_{t} \\rangle_{S} $$\n在单自由度模型中，这些量被简化。内部耗散功率由以下公式给出：\n$$ P_{\\text{diss}} = \\frac{\\omega}{2}\\, \\epsilon''(\\omega)\\, C\\, |x|^{2} $$\n辐射功率由以下公式给出：\n$$ P_{\\text{rad}} = \\frac{1}{2}\\, \\Re\\{ Z_{\\text{rad}}(\\omega) \\}\\, |x|^{2} $$\n$P_{\\text{rad}}$ 的这个表达式是通过将 $\\mathbf{e}_t = x\\,\\boldsymbol{\\phi}_t$ 代入通用形式得到的，其中 $Z_{\\text{rad}}(\\omega) = \\langle \\boldsymbol{\\phi}_t, \\mathcal{T} \\boldsymbol{\\phi}_t \\rangle_S$。\n校准条件是内部耗散等于外部辐射功率：$P_{\\text{diss}} = P_{\\text{rad}}$。\n将模型表达式代入此条件：\n$$ \\frac{\\omega}{2}\\, \\epsilon''(\\omega)\\, C\\, |x|^{2} = \\frac{1}{2}\\, \\Re\\{ Z_{\\text{rad}}(\\omega) \\}\\, |x|^{2} $$\n假设存在非平凡解（$x \\neq 0$），我们可以将两边同时除以 $\\frac{1}{2}|x|^2$，得到所需的标量等式：\n$$ \\omega\\, \\epsilon''(\\omega)\\, C = \\Re\\{ Z_{\\text{rad}}(\\omega) \\} $$\n\n**第 3 部分：功率平衡诊断残差**\n\n我们给出了一个根据错误的功率计算定义的诊断残差 $R$：\n$$ R = \\frac{P_{\\text{rad}}^{\\text{err}} - P_{\\text{diss}}^{\\text{err}}}{P_{\\text{rad}}^{\\text{err}} + P_{\\text{diss}}^{\\text{err}}} $$\n错误的耗散功率 $P_{\\text{diss}}^{\\text{err}}$ 是使用不正确的介电常数损耗 $\\epsilon''_{\\text{FE}}(\\omega) = \\epsilon''(\\omega)\\,(1 + \\Delta_{\\epsilon})$ 计算的。该计算基于正确的场幅度 $x$。\n$$ P_{\\text{diss}}^{\\text{err}} = \\frac{\\omega}{2}\\, \\epsilon''_{\\text{FE}}(\\omega)\\, C\\, |x|^{2} = \\frac{\\omega}{2}\\, \\epsilon''(\\omega)\\,(1 + \\Delta_{\\epsilon})\\, C\\, |x|^{2} $$\n错误的辐射功率 $P_{\\text{rad}}^{\\text{err}}$ 是根据一个缩放后的切向迹 $\\tilde{\\mathbf{e}}_{t} = s\\,\\mathbf{e}_{t}$ 计算的，其中 $s = 1 + \\Delta_{t}$ 是一个实数缩放因子。\n$$ P_{\\text{rad}}^{\\text{err}} = \\frac{1}{2}\\, \\Re \\langle \\tilde{\\mathbf{e}}_{t}, \\mathcal{T}\\,\\tilde{\\mathbf{e}}_{t} \\rangle_{S} = \\frac{1}{2}\\, \\Re \\langle s\\,\\mathbf{e}_{t}, \\mathcal{T}\\,(s\\,\\mathbf{e}_{t}) \\rangle_{S} $$\n利用 $\\mathcal{T}$ 的线性和内积的性质：\n$$ P_{\\text{rad}}^{\\text{err}} = \\frac{1}{2}\\, \\Re \\{ s s^* \\langle \\mathbf{e}_{t}, \\mathcal{T}\\,\\mathbf{e}_{t} \\rangle_{S} \\} = \\frac{1}{2}\\, |s|^2 \\Re \\langle \\mathbf{e}_{t}, \\mathcal{T}\\,\\mathbf{e}_{t} \\rangle_{S} $$\n由于 $s$ 是实数，所以 $|s|^2 = s^2 = (1+\\Delta_t)^2$。项 $\\frac{1}{2}\\, \\Re \\langle \\mathbf{e}_{t}, \\mathcal{T}\\,\\mathbf{e}_{t} \\rangle_{S}$ 是正确的辐射功率 $P_{\\text{rad}} = \\frac{1}{2} \\Re\\{Z_{\\text{rad}}\\} |x|^2$。\n$$ P_{\\text{rad}}^{\\text{err}} = (1+\\Delta_t)^2 \\left( \\frac{1}{2}\\, \\Re\\{ Z_{\\text{rad}}(\\omega) \\}\\, |x|^{2} \\right) $$\n现在，我们将 $P_{\\text{diss}}^{\\text{err}}$ 和 $P_{\\text{rad}}^{\\text{err}}$ 的这些表达式代入 $R$ 的公式中：\n$$ R = \\frac{(1+\\Delta_t)^2 \\left( \\frac{1}{2}\\, \\Re\\{Z_{\\text{rad}}\\} |x|^2 \\right) - \\frac{\\omega}{2}\\, \\epsilon''(1+\\Delta_\\epsilon) C |x|^2}{(1+\\Delta_t)^2 \\left( \\frac{1}{2}\\, \\Re\\{Z_{\\text{rad}}\\} |x|^2 \\right) + \\frac{\\omega}{2}\\, \\epsilon''(1+\\Delta_\\epsilon) C |x|^2} $$\n公因子 $\\frac{1}{2}|x|^2$ 从分子和分母中消去：\n$$ R = \\frac{(1+\\Delta_t)^2 \\Re\\{Z_{\\text{rad}}\\} - \\omega \\epsilon''(1+\\Delta_\\epsilon) C}{(1+\\Delta_t)^2 \\Re\\{Z_{\\text{rad}}\\} + \\omega \\epsilon''(1+\\Delta_\\epsilon) C} $$\n我们现在使用第 2 部分推导出的校准等式：$\\Re\\{ Z_{\\text{rad}}(\\omega) \\} = \\omega\\, \\epsilon''(\\omega)\\, C$。让我们用 $K_0$ 表示这个共同的值。将 $\\Re\\{Z_{\\text{rad}}\\}$ 和 $\\omega \\epsilon'' C$ 都替换为 $K_0$：\n$$ R = \\frac{(1+\\Delta_t)^2 K_0 - (1+\\Delta_\\epsilon) K_0}{(1+\\Delta_t)^2 K_0 + (1+\\Delta_\\epsilon) K_0} $$\n由于 $K_0 = \\omega \\epsilon'' C > 0$，我们可以从分子和分母中消去 $K_0$：\n$$ R = \\frac{(1+\\Delta_t)^2 - (1+\\Delta_\\epsilon)}{(1+\\Delta_t)^2 + (1+\\Delta_\\epsilon)} $$\n最后，我们展开各项以获得最简形式：\n$$ (1+\\Delta_t)^2 = 1 + 2\\Delta_t + \\Delta_t^2 $$\n$$ R = \\frac{(1 + 2\\Delta_t + \\Delta_t^2) - (1 + \\Delta_\\epsilon)}{(1 + 2\\Delta_t + \\Delta_t^2) + (1 + \\Delta_\\epsilon)} = \\frac{2\\Delta_t + \\Delta_t^2 - \\Delta_\\epsilon}{2 + 2\\Delta_t + \\Delta_t^2 + \\Delta_\\epsilon} $$\n这个 $R$ 的表达式仅依赖于建模误差参数 $\\Delta_t$ 和 $\\Delta_\\epsilon$，符合要求。\n重新排列各项，按 $\\Delta_t$ 的幂次分组：\n$$ R = \\frac{\\Delta_t^2 + 2\\Delta_t - \\Delta_\\epsilon}{\\Delta_t^2 + 2\\Delta_t + \\Delta_\\epsilon + 2} $$",
            "answer": "$$\\boxed{\\frac{\\Delta_t^2 + 2\\Delta_t - \\Delta_\\epsilon}{\\Delta_t^2 + 2\\Delta_t + \\Delta_\\epsilon + 2}}$$"
        },
        {
            "introduction": "在拥有一个经过验证的模型之后，接下来的挑战是计算效率。本实践将介绍一种强大的技术——目标导向的自适应网格加密 (AMR)，以智能地分配计算资源。您将不再是均匀地加密网格，而是实现一种使用“后验”误差估计器的算法，以识别哪些单元（无论是体积内的有限元单元还是表面上的边界元单元）对远场方向图的误差贡献最大。这个练习  将教您构建一个更智能的求解器，它能够动态地平衡精度和成本，这是为复杂、真实的散射问题创建高效工具的关键一步。",
            "id": "3315744",
            "problem": "考虑自由空间中的时谐电磁散射问题，其中角频率为 $\\omega$ 的电场 $\\mathbf{E}$ 满足麦克斯韦方程组。在一种混合离散化方法中，有界体域 $\\Omega$ 内的有限元法 (FEM) 与包围表面 $\\Gamma$ 上的边界积分 (BI) 方程相耦合。其中，FEM 用于近似内部场，而 BI 则施加辐射条件并表示外部场。有限元-边界积分混合方法旨在求解 $\\mathbf{E}_h$，使其同时满足体弱形式和边界积分耦合条件。在给定观测方向上的远场振幅是电磁场的一个线性泛函 $J(\\mathbf{E})$（例如，通过 Stratton–Chu 表示法），而我们关注的量是远场误差 $|J(\\mathbf{E}) - J(\\mathbf{E}_h)|$。\n\n从内部区域的时谐麦克斯韦旋度-旋度方程\n$$\n\\nabla \\times \\left( \\mu^{-1} \\nabla \\times \\mathbf{E} \\right) - \\omega^2 \\varepsilon \\mathbf{E} = \\mathbf{0} \\quad \\text{in } \\Omega,\n$$\n其中 $\\mu$ 是磁导率，$\\varepsilon$ 是介电常数，以及在 $\\Gamma$ 上施加外部区域外行辐射条件的边界积分公式出发，面向目标的后验误差分析得出一个误差表示，该表示将远场误差分解为由伴随（对偶）解加权的体残差和边界残差的贡献。用 $\\{K_i\\}_{i=1}^{N_{\\mathrm{vol}}}$ 表示特征尺寸为 $\\{h_i^{\\mathrm{vol}}\\}$ 的四面体体单元集合，用 $\\{T_j\\}_{j=1}^{N_{\\mathrm{surf}}}$ 表示特征尺寸为 $\\{h_j^{\\mathrm{surf}}\\}$ 的三角形面单元集合。设自由空间光速为 $c = 2.99792458 \\times 10^8\\,\\mathrm{m/s}$，波数为 $k = 2\\pi f/c$，其中 $f$ 是以 $\\mathrm{Hz}$ 为单位的频率。\n\n定义与网格尺寸和波数成比例的、可计算的局部指标，用于表示体和面的贡献，\n$$\n\\eta_i^{\\mathrm{vol}} = A_{\\mathrm{vol}} \\left(k\\, h_i^{\\mathrm{vol}}\\right)^{p_{\\mathrm{vol}}} \\rho_i, \\quad\n\\eta_j^{\\mathrm{surf}} = A_{\\mathrm{surf}} \\left(k\\, h_j^{\\mathrm{surf}}\\right)^{p_{\\mathrm{surf}}} \\sigma_j,\n$$\n其中 $A_{\\mathrm{vol}}$ 和 $A_{\\mathrm{surf}}$ 是反映材料对比度和离散化阶数的正常数，$p_{\\mathrm{vol}}>0$ 和 $p_{\\mathrm{surf}}>0$ 是收敛指数，$\\rho_i>0$ 和 $\\sigma_j>0$ 是可计算的残差幅值。设 $w_i^{\\mathrm{vol}}$ 和 $w_j^{\\mathrm{surf}}$ 为基于伴随解的正影响权重，反映了远场泛函 $J(\\mathbf{E})$ 对相应单元中扰动的灵敏度。在本问题中，假设权重由以下模型给出\n$$\nw_i^{\\mathrm{vol}} = \\frac{1}{1 + \\left(k\\, h_i^{\\mathrm{vol}}\\right)^2}, \\qquad\nw_j^{\\mathrm{surf}} = \\frac{1}{1 + \\left(k\\, h_j^{\\mathrm{surf}}\\right)}.\n$$\n定义远场误差估计子为\n$$\n\\mathcal{E}_{\\mathrm{ff}} = \\left( \\sum_{i=1}^{N_{\\mathrm{vol}}} w_i^{\\mathrm{vol}} \\left(\\eta_i^{\\mathrm{vol}}\\right)^2 + \\sum_{j=1}^{N_{\\mathrm{surf}}} w_j^{\\mathrm{surf}} \\left(\\eta_j^{\\mathrm{surf}}\\right)^2 \\right)^{1/2},\n$$\n并假设加密一个体单元 $K_i$ 会使其尺寸减半 $h_i^{\\mathrm{vol}} \\mapsto h_i^{\\mathrm{vol}}/2$，类似地，对于面单元 $T_j$ 其尺寸变化为 $h_j^{\\mathrm{surf}} \\mapsto h_j^{\\mathrm{surf}}/2$。在这种加密下，指标根据缩放指数收缩：\n$$\n\\eta_i^{\\mathrm{vol}} \\mapsto 2^{-p_{\\mathrm{vol}}}\\, \\eta_i^{\\mathrm{vol}}, \\qquad\n\\eta_j^{\\mathrm{surf}} \\mapsto 2^{-p_{\\mathrm{surf}}}\\, \\eta_j^{\\mathrm{surf}},\n$$\n并且权重根据新的尺寸进行更新。设加密一个体单元的计算成本为 $c_{\\mathrm{vol}}>0$，加密一个面单元的计算成本为 $c_{\\mathrm{surf}}>0$。\n\n任务。提出并实现一种自适应加密算法，在每次迭代中，选择一个体四面体或一个面三角形进行加密，以在目标容差 $\\varepsilon_{\\mathrm{ff}}$ 的约束下最小化远场误差估计子 $\\mathcal{E}_{\\mathrm{ff}}$。该选择必须通过最大化每单位成本的预测误差减少量来平衡体加密和面加密。也就是说，对于每个候选单元，使用给定的指标和权重模型，预测因其尺寸减半而导致的 $\\mathcal{E}_{\\mathrm{ff}}^2$ 的减少量，并选择使预测减少量与加密成本之比最大的单元。重复此过程，直到 $\\mathcal{E}_{\\mathrm{ff}} \\le \\varepsilon_{\\mathrm{ff}}$ 或达到最大迭代次数。对于每个测试用例，程序必须输出一个列表，其中包含一个布尔值（表示是否达到容差）、总迭代次数、总体加密次数、总面加密次数以及最终的估计远场误差 $\\mathcal{E}_{\\mathrm{ff}}$。\n\n使用以下确定性的残差幅值：\n$$\n\\rho_i = \\frac{1}{1+i}, \\qquad \\sigma_j = \\frac{1}{1+j}.\n$$\n使用以下确定性的初始单元尺寸：\n$$\nh_i^{\\mathrm{vol}} = \\bar{h}_{\\mathrm{vol}} \\left(1 + 0.3\\sin(i)\\right), \\qquad\nh_j^{\\mathrm{surf}} = \\bar{h}_{\\mathrm{surf}} \\left(1 + 0.3\\cos(j)\\right),\n$$\n其中 $\\bar{h}_{\\mathrm{vol}}>0$ 且 $\\bar{h}_{\\mathrm{surf}}>0$。\n\n在一个无需任何外部输入的单一程序中实现该算法，并为以下测试套件生成结果。所有物理量必须使用国际单位制 (SI)。频率单位必须是 $\\mathrm{Hz}$，长度单位必须是 $\\mathrm{m}$，远场误差容差和估计子必须是无量纲的。最终的远场误差必须以十进制数报告。\n\n测试套件：\n- 情况 1 (理想情况)：$f = 3.0\\times 10^9\\,\\mathrm{Hz}$, $L = 0.1\\,\\mathrm{m}$, $N_{\\mathrm{vol}} = 32$, $N_{\\mathrm{surf}} = 64$, $\\bar{h}_{\\mathrm{vol}} = L/20$, $\\bar{h}_{\\mathrm{surf}} = L/30$, $A_{\\mathrm{vol}} = 1.0$, $A_{\\mathrm{surf}} = 1.0$, $p_{\\mathrm{vol}} = 1.0$, $p_{\\mathrm{surf}} = 1.0$, $c_{\\mathrm{vol}} = 2.0$, $c_{\\mathrm{surf}} = 1.0$, $\\varepsilon_{\\mathrm{ff}} = 1.0\\times 10^{-3}$, 最大迭代次数 $= 1000$。\n- 情况 2 (严格容差边界)：$f = 1.0\\times 10^{10}\\,\\mathrm{Hz}$, $L = 0.2\\,\\mathrm{m}$, $N_{\\mathrm{vol}} = 40$, $N_{\\mathrm{surf}} = 80$, $\\bar{h}_{\\mathrm{vol}} = 0.01\\,\\mathrm{m}$, $\\bar{h}_{\\mathrm{surf}} = 0.007\\,\\mathrm{m}$, $A_{\\mathrm{vol}} = 1.0$, $A_{\\mathrm{surf}} = 1.5$, $p_{\\mathrm{vol}} = 1.0$, $p_{\\mathrm{surf}} = 1.0$, $c_{\\mathrm{vol}} = 2.0$, $c_{\\mathrm{surf}} = 1.0$, $\\varepsilon_{\\mathrm{ff}} = 1.0\\times 10^{-6}$, 最大迭代次数 $= 600$。\n- 情况 3 (低频和成本不平衡)：$f = 1.0\\times 10^8\\,\\mathrm{Hz}$, $L = 0.5\\,\\mathrm{m}$, $N_{\\mathrm{vol}} = 20$, $N_{\\mathrm{surf}} = 40$, $\\bar{h}_{\\mathrm{vol}} = 0.02\\,\\mathrm{m}$, $\\bar{h}_{\\mathrm{surf}} = 0.015\\,\\mathrm{m}$, $A_{\\mathrm{vol}} = 0.8$, $A_{\\mathrm{surf}} = 1.2$, $p_{\\mathrm{vol}} = 1.0$, $p_{\\mathrm{surf}} = 1.0$, $c_{\\mathrm{vol}} = 1.5$, $c_{\\mathrm{surf}} = 1.0$, $\\varepsilon_{\\mathrm{ff}} = 1.0\\times 10^{-4}$, 最大迭代次数 $= 600$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个测试用例的结果本身也是一个列表，顺序为 $\\left[\\text{success}, \\text{iterations}, \\text{volume\\_refinements}, \\text{surface\\_refinements}, \\mathcal{E}_{\\mathrm{ff}}\\right]$。例如，输出应如下所示 $\\left[[\\text{True},10,5,7,9.1e-4],[\\text{False},600,320,280,2.3e-6],[\\text{True},\\dots]\\right]$，其中的数字是您的程序计算出的实际值。",
            "solution": "该问题要求为计算电磁学中的有限元-边界积分 (FEM-BI) 混合方法设计并实现一种面向目标的自适应网格加密 (AMR) 算法。其目标是高效地将特定关注量（即远场振幅）的估计误差降低到给定容差 $\\varepsilon_{\\mathrm{ff}}$ 以下。该算法必须迭代地加密体单元（四面体）或面单元（三角形），其选择依据是哪种加密能提供每单位计算成本下的最大预测误差减少量。\n\n所提出的算法是一个贪心的迭代过程。在每一步中，它会识别出最值得加密的单个单元，并相应地更新网格状态。此过程重复进行，直到估计误差 $\\mathcal{E}_{\\mathrm{ff}}$ 低于目标容差 $\\varepsilon_{\\mathrm{ff}}$ 或达到最大迭代次数。\n\n该算法的核心组成部分如下：\n\n1.  **状态表示**：在任何一次迭代中，离散化域的状态由所有体单元和面单元的特征尺寸集合 $\\{h_i^{\\mathrm{vol}}\\}_{i=1}^{N_{\\mathrm{vol}}}$ 和 $\\{h_j^{\\mathrm{surf}}\\}_{j=1}^{N_{\\mathrm{surf}}}$ 定义。根据问题定义，所有其他参数（如残差幅值 $\\rho_i$ 和 $\\sigma_j$）在整个仿真过程中对每个单元都假定为固定的。\n\n2.  **误差估计子计算**：在每次迭代中，计算总的远场误差估计子 $\\mathcal{E}_{\\mathrm{ff}}$。该估计子是所有单元上加权的局部误差指标平方和的平方根：\n    $$\n    \\mathcal{E}_{\\mathrm{ff}} = \\left( \\sum_{i=1}^{N_{\\mathrm{vol}}} w_i^{\\mathrm{vol}} \\left(\\eta_i^{\\mathrm{vol}}\\right)^2 + \\sum_{j=1}^{N_{\\mathrm{surf}}} w_j^{\\mathrm{surf}} \\left(\\eta_j^{\\mathrm{surf}}\\right)^2 \\right)^{1/2}\n    $$\n    各个分量根据当前的单元尺寸计算：\n    -   波数为 $k = 2\\pi f/c$。\n    -   局部指标：$\\eta_i^{\\mathrm{vol}} = A_{\\mathrm{vol}} \\left(k\\, h_i^{\\mathrm{vol}}\\right)^{p_{\\mathrm{vol}}} \\rho_i$ 和 $\\eta_j^{\\mathrm{surf}} = A_{\\mathrm{surf}} \\left(k\\, h_j^{\\mathrm{surf}}\\right)^{p_{\\mathrm{surf}}} \\sigma_j$。\n    -   伴随权重：$w_i^{\\mathrm{vol}} = \\frac{1}{1 + \\left(k\\, h_i^{\\mathrm{vol}}\\right)^2}$ 和 $w_j^{\\mathrm{surf}} = \\frac{1}{1 + \\left(k\\, h_j^{\\mathrm{surf}}\\right)}$。\n\n3.  **加密选择准则**：该算法采用一种考虑成本的贪心策略。为了选择要加密的单元，我们预测加密每个候选单元将导致的误差平方 $\\mathcal{E}_{\\mathrm{ff}}^2$ 的减少量。这在潜在的误差减少量与加密的计算成本之间取得了平衡。\n\n    对于给定的体单元 $K_i$，其当前对误差平方的贡献为 $C_i^{\\mathrm{vol}} = w_i^{\\mathrm{vol}} \\left(\\eta_i^{\\mathrm{vol}}\\right)^2$。如果我们加密该单元，其尺寸将变为 $h_i^{\\mathrm{vol, new}} = h_i^{\\mathrm{vol}}/2$。根据问题的缩放规则，指标收缩为 $\\eta_i^{\\mathrm{vol, new}} = 2^{-p_{\\mathrm{vol}}} \\eta_i^{\\mathrm{vol}}$。权重更新为 $w_i^{\\mathrm{vol, new}} = \\frac{1}{1 + \\left(k h_i^{\\mathrm{vol, new}}\\right)^2}$。对误差平方的新贡献将是 $C_i^{\\mathrm{vol, new}} = w_i^{\\mathrm{vol, new}} (\\eta_i^{\\mathrm{vol, new}})^2$。\n\n    因此，加密单元 $K_i$ 带来的 $\\mathcal{E}_{\\mathrm{ff}}^2$ 的预测减少量为 $\\Delta_i^{\\mathrm{vol}} = C_i^{\\mathrm{vol}} - C_i^{\\mathrm{vol, new}}$。表示每单位成本误差减少量的选择度量为：\n    $$\n    M_i^{\\mathrm{vol}} = \\frac{\\Delta_i^{\\mathrm{vol}}}{c_{\\mathrm{vol}}}\n    $$\n    对于每个面单元 $T_j$，计算一个类似的度量 $M_j^{\\mathrm{surf}}$：\n    $$\n    M_j^{\\mathrm{surf}} = \\frac{\\Delta_j^{\\mathrm{surf}}}{c_{\\mathrm{surf}}} = \\frac{w_j^{\\mathrm{surf}} (\\eta_j^{\\mathrm{surf}})^2 - w_j^{\\mathrm{surf, new}} (\\eta_j^{\\mathrm{surf, new}})^2}{c_{\\mathrm{surf}}}\n    $$\n    在每次迭代中，算法为所有 $i \\in \\{1, \\dots, N_{\\mathrm{vol}}\\}$ 计算 $M_i^{\\mathrm{vol}}$，为所有 $j \\in \\{1, \\dots, N_{\\mathrm{surf}}\\}$ 计算 $M_j^{\\mathrm{surf}}$。选择所有这些度量中值最大的对应单元进行加密。\n\n4.  **自适应循环与终止**：整个算法按以下步骤进行：\n    a. 根据提供的公式初始化单元尺寸 $\\{h_i^{\\mathrm{vol}}\\}$ 和 $\\{h_j^{\\mathrm{surf}}\\}$ 以及残差幅值 $\\{\\rho_i\\}$ 和 $\\{\\sigma_j\\}$。将迭代和加密计数器初始化为 0。\n    b. 启动主循环，该循环最多运行设定的最大迭代次数。\n    c. 在每次迭代中，计算当前的总误差估计子 $\\mathcal{E}_{\\mathrm{ff}}$。\n    d. 检查终止条件：如果 $\\mathcal{E}_{\\mathrm{ff}} \\le \\varepsilon_{\\mathrm{ff}}$，则表示已达到容差。循环终止，并记录为成功。\n    e. 如果未终止，则为所有单元计算选择度量 $M_i^{\\mathrm{vol}}$ 和 $M_j^{\\mathrm{surf}}$。\n    f. 找出具有全局最大度量值的单元（体单元或面单元）。\n    g. 加密所选单元：将其尺寸更新为原来的一半 ($h \\mapsto h/2$)。\n    h. 增加相应的加密计数器（体或面）和总迭代计数器。\n    i. 如果循环因达到最大迭代次数限制而完成，但仍未满足容差，则过程终止并报告未能收敛。\n    j. 终止时，报告成功状态、总迭代次数、总体加密和面加密的总次数，以及 $\\mathcal{E}_{\\mathrm{ff}}$ 的最终值。\n\n该算法使用 NumPy 实现，以高效地对所有单元的指标、权重和度量进行向量化计算，从而避免了在 Python 中使用缓慢的显式循环。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the adaptive refinement simulation for all test cases.\n    \"\"\"\n    \n    # Speed of light in m/s\n    c = 2.99792458e8\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1 (happy path)\n        {'f': 3.0e9, 'L': 0.1, 'N_vol': 32, 'N_surf': 64, 'h_bar_vol_factor': 1/20.0, 'h_bar_surf_factor': 1/30.0,\n         'A_vol': 1.0, 'A_surf': 1.0, 'p_vol': 1.0, 'p_surf': 1.0, 'c_vol': 2.0, 'c_surf': 1.0,\n         'tol': 1.0e-3, 'max_iter': 1000},\n        # Case 2 (tight tolerance boundary)\n        {'f': 1.0e10, 'L': 0.2, 'N_vol': 40, 'N_surf': 80, 'h_bar_vol': 0.01, 'h_bar_surf': 0.007,\n         'A_vol': 1.0, 'A_surf': 1.5, 'p_vol': 1.0, 'p_surf': 1.0, 'c_vol': 2.0, 'c_surf': 1.0,\n         'tol': 1.0e-6, 'max_iter': 600},\n        # Case 3 (low frequency and cost imbalance)\n        {'f': 1.0e8, 'L': 0.5, 'N_vol': 20, 'N_surf': 40, 'h_bar_vol': 0.02, 'h_bar_surf': 0.015,\n         'A_vol': 0.8, 'A_surf': 1.2, 'p_vol': 1.0, 'p_surf': 1.0, 'c_vol': 1.5, 'c_surf': 1.0,\n         'tol': 1.0e-4, 'max_iter': 600}\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_simulation(params, c)\n        all_results.append(result)\n    \n    # Format the output string to match the required format exactly\n    output_parts = []\n    for r in all_results:\n        # Format: [success, iterations, volume_refinements, surface_refinements, E_ff]\n        # str(bool) gives 'True'/'False'\n        part = f\"[{str(r[0])},{r[1]},{r[2]},{r[3]},{r[4]}]\"\n        output_parts.append(part)\n    \n    print(f\"[{','.join(output_parts)}]\")\n\n\ndef run_simulation(params, c):\n    \"\"\"\n    Runs the adaptive refinement algorithm for a single test case.\n    \"\"\"\n    # Unpack parameters\n    f = params['f']\n    N_vol, N_surf = params['N_vol'], params['N_surf']\n    A_vol, A_surf = params['A_vol'], params['A_surf']\n    p_vol, p_surf = params['p_vol'], params['p_surf']\n    c_vol, c_surf = params['c_vol'], params['c_surf']\n    tol, max_iter = params['tol'], params['max_iter']\n\n    if 'h_bar_vol_factor' in params:\n        L = params['L']\n        h_bar_vol = L * params['h_bar_vol_factor']\n        h_bar_surf = L * params['h_bar_surf_factor']\n    else:\n        h_bar_vol = params['h_bar_vol']\n        h_bar_surf = params['h_bar_surf']\n        \n    k = 2 * np.pi * f / c\n\n    # Initialization\n    # Indices for deterministic formulas (1-based)\n    vol_indices = np.arange(1, N_vol + 1)\n    surf_indices = np.arange(1, N_surf + 1)\n\n    # Residual amplitudes (fixed)\n    rho_vol = 1.0 / (1.0 + vol_indices)\n    sigma_surf = 1.0 / (1.0 + surf_indices)\n\n    # Initial element sizes\n    h_vol = h_bar_vol * (1.0 + 0.3 * np.sin(vol_indices))\n    h_surf = h_bar_surf * (1.0 + 0.3 * np.cos(surf_indices))\n\n    iterations = 0\n    vol_refinements = 0\n    surf_refinements = 0\n    success = False\n    E_ff = float('inf')\n\n    for i in range(max_iter):\n        iterations = i\n\n        # Calculate current error estimator\n        kh_vol = k * h_vol\n        kh_surf = k * h_surf\n\n        eta_vol = A_vol * (kh_vol ** p_vol) * rho_vol\n        eta_surf = A_surf * (kh_surf ** p_surf) * sigma_surf\n        \n        w_vol = 1.0 / (1.0 + kh_vol**2)\n        w_surf = 1.0 / (1.0 + kh_surf)\n        \n        contrib_sq_vol = w_vol * eta_vol**2\n        contrib_sq_surf = w_surf * eta_surf**2\n        \n        E_ff_sq = np.sum(contrib_sq_vol) + np.sum(contrib_sq_surf)\n        E_ff = np.sqrt(E_ff_sq)\n\n        if E_ff = tol:\n            success = True\n            break\n        \n        # Predict error reduction for all elements\n        \n        # Volume elements\n        kh_vol_new = kh_vol / 2.0\n        eta_vol_new = eta_vol * (2.0**(-p_vol))\n        w_vol_new = 1.0 / (1.0 + kh_vol_new**2)\n        contrib_sq_vol_new = w_vol_new * eta_vol_new**2\n        reductions_vol = contrib_sq_vol - contrib_sq_vol_new\n        metrics_vol = reductions_vol / c_vol\n\n        # Surface elements\n        kh_surf_new = kh_surf / 2.0\n        eta_surf_new = eta_surf * (2.0**(-p_surf))\n        w_surf_new = 1.0 / (1.0 + kh_surf_new)\n        contrib_sq_surf_new = w_surf_new * eta_surf_new**2\n        reductions_surf = contrib_sq_surf - contrib_sq_surf_new\n        metrics_surf = reductions_surf / c_surf\n\n        # Select element with max metric and refine\n        best_vol_idx = np.argmax(metrics_vol)\n        best_surf_idx = np.argmax(metrics_surf)\n        \n        if metrics_vol[best_vol_idx] >= metrics_surf[best_surf_idx]:\n            h_vol[best_vol_idx] /= 2.0\n            vol_refinements += 1\n        else:\n            h_surf[best_surf_idx] /= 2.0\n            surf_refinements += 1\n    \n    # If loop finished due to max_iter, one final calculation of E_ff is needed\n    if not success:\n      iterations += 1\n      # Recalculate final error after the last refinement\n      kh_vol = k * h_vol\n      kh_surf = k * h_surf\n      eta_vol = A_vol * (kh_vol ** p_vol) * rho_vol\n      eta_surf = A_surf * (kh_surf ** p_surf) * sigma_surf\n      w_vol = 1.0 / (1.0 + kh_vol**2)\n      w_surf = 1.0 / (1.0 + kh_surf)\n      contrib_sq_vol = w_vol * eta_vol**2\n      contrib_sq_surf = w_surf * eta_surf**2\n      E_ff_sq = np.sum(contrib_sq_vol) + np.sum(contrib_sq_surf)\n      E_ff = np.sqrt(E_ff_sq)\n\n    return [success, iterations, vol_refinements, surf_refinements, E_ff]\n\nsolve()\n```"
        }
    ]
}