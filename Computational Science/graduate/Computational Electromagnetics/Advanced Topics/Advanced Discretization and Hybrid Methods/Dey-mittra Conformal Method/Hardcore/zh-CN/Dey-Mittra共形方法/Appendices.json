{
    "hands_on_practices": [
        {
            "introduction": "在深入研究任何高级数值方法的实现细节之前，首先从根本上理解其为何优越是至关重要的。本节的第一个实践是一个理论推导练习，旨在通过解析方法揭示 Dey-Mittra 方法的核心优势。我们将直接比较阶梯近似和 Dey-Mittra 共形方法在处理弯曲完美电导体（PEC）边界时的表现，通过推导由于几何近似误差导致的场误差与网格尺寸 $h$ 之间的标度关系 ()，从而定量地证明 Dey-Mittra 方法如何将精度从一阶提升到二阶。",
            "id": "3298046",
            "problem": "考虑一个单连通域中的时谐麦克斯韦方程组，其边界 $\\Gamma$ 为 $\\mathcal{C}^{2}$ 类的光滑理想电导体（PEC）边界。设外法向单位向量为 $\\hat{\\boldsymbol{n}}$，切向电场迹为 $E_{t}=\\hat{\\boldsymbol{t}}\\cdot\\boldsymbol{E}$，其中 $\\hat{\\boldsymbol{t}}$ 是 $\\Gamma$ 的任意单位切向量。PEC 上的精确边界条件为 $E_{t}|_{\\Gamma}=0$。假设精确解在 $\\Gamma$ 的一个管状邻域内是光滑的，因此在局部法向坐标 $(s,n)$ 中，其中 $n$ 是沿 $\\hat{\\boldsymbol{n}}$ 到 $\\Gamma$ 的有符号距离，精确的切向场可展开为\n$$\nE_{t}(s,n)=A(s)\\,n+B(s)\\,n^{2}+\\mathcal{O}(n^{3}),\n$$\n其中 $A(s)=\\partial E_{t}/\\partial n|_{\\Gamma}$ 通常为有限且非零。\n\n假设使用间距为 $h$ 的均匀笛卡尔网格。比较两种边界表示方法：\n- 标准 Yee 时域有限差分（FDTD）方案所使用的阶梯状边界，记为 $\\Gamma_{\\text{stair}}$，它是由与网格对齐的平面面元组成的并集，用于近似 $\\Gamma$。\n- Dey–Mittra 共形方法边界，记为 $\\Gamma_{\\text{DM}}$，它在每个切割单元内，用一个由 $\\Gamma$ 与网格边交点确定的平面来替换该部分 $\\Gamma$，并通过面积和长度分数来修正旋度算子（即 Dey–Mittra 共形 FDTD）。\n\n假设 $\\Gamma$ 的主曲率有界，并令 $\\kappa(s)$ 表示弧长坐标 $s$ 处的代表性曲率大小（对于一个曲面，可取 $\\kappa(s)$ 为主曲率大小的最大值）。令 $\\delta n_{\\text{stair}}(s)$ 和 $\\delta n_{\\text{DM}}(s)$ 分别表示从 $\\Gamma$ 到 $\\Gamma_{\\text{stair}}$ 和从 $\\Gamma$ 到 $\\Gamma_{\\text{DM}}$ 的有符号法向偏移量，该偏移量沿 $\\hat{\\boldsymbol{n}}$ 测量。仅使用：\n- PEC 边界条件，\n- 法向坐标下 $E_{t}(s,n)$ 的光滑性（泰勒展开），\n- 从 $\\Gamma_{\\text{stair}}$ 和 $\\Gamma_{\\text{DM}}$ 的构造以及 $\\Gamma$ 的光滑性推断出的几何近似属性，\n推导在近似边界上施加 $E_{t}=0$ 条件所产生的、在真实边界上的伪切向电场的首项标度（相对于 $h$）。也就是说，推导下式中的阶数 $p_{\\text{stair}}$ 和 $p_{\\text{DM}}$：\n$$\n\\left|E_{t}^{\\text{num}}(s,0)\\right|\\sim C_{\\text{stair}}(s)\\,h^{p_{\\text{stair}}}\n\\quad\\text{和}\\quad\n\\left|E_{t}^{\\text{num}}(s,0)\\right|\\sim C_{\\text{DM}}(s)\\,h^{p_{\\text{DM}}},\n$$\n当 $h\\to 0$ 时，其中 $C_{\\text{stair}}(s)$ 和 $C_{\\text{DM}}(s)$ 是与 $h$ 无关的系数。你的推导必须通过法向泰勒展开，明确地将几何引起的偏移量 $\\delta n_{\\text{stair}}$ 和 $\\delta n_{\\text{DM}}$ 与 $E_{t}^{\\text{num}}(s,0)$ 联系起来，并且必须从 $\\Gamma_{\\text{stair}}$ 和 $\\Gamma_{\\text{DM}}$ 的几何考虑出发，论证这些偏移量的标度关系。\n\n请以行矩阵的形式提供最终答案对 $\\left(p_{\\text{stair}},\\,p_{\\text{DM}}\\right)$。不要包含单位。无需进行数值取整。",
            "solution": "首先确认问题是自洽的，在计算电磁学领域有科学依据，并且是适定的。所有提供的信息都是一致的，足以推导出唯一解。\n\n问题的核心是确定理想电导体（PEC）边界的几何表示误差如何转化为真实边界上切向电场 $E_t$ 的误差。数值方法将 PEC 边界条件 $E_t = 0$ 施加在近似边界上，而不是在真实的光滑边界 $\\Gamma$ 上。我们可以将这个近似边界通常记为 $\\Gamma_{\\text{approx}}$。这个近似边界距离真实边界一个有符号法向距离 $n = \\delta n(s)$，其中 $s$ 是沿 $\\Gamma$ 的弧长坐标。\n\n令 $E_t^{\\text{num}}(s,n)$ 表示数值解在局部法向坐标 $(s,n)$ 中的切向电场分量。数值格式在 $\\Gamma_{\\text{approx}}$ 上强制施加边界条件，这意味着：\n$$\nE_t^{\\text{num}}(s, \\delta n(s)) = 0\n$$\n我们需要求解的是真实边界 $\\Gamma$（对应于位置 $n=0$）上的伪切向场。这个值就是 $E_t^{\\text{num}}(s, 0)$。假设数值解 $E_t^{\\text{num}}(s, n)$ 对于小的 $n$ 是法向坐标 $n$ 的光滑函数，我们可以在 $n=0$ 附近写出其泰勒级数展开：\n$$\nE_t^{\\text{num}}(s, n) = E_t^{\\text{num}}(s, 0) + \\left.\\frac{\\partial E_t^{\\text{num}}}{\\partial n}\\right|_{n=0} n + \\mathcal{O}(n^2)\n$$\n代入 $n = \\delta n(s)$ 并使用条件 $E_t^{\\text{num}}(s, \\delta n(s)) = 0$，我们得到：\n$$\n0 = E_t^{\\text{num}}(s, 0) + \\left.\\frac{\\partial E_t^{\\text{num}}}{\\partial n}\\right|_{n=0} \\delta n(s) + \\mathcal{O}((\\delta n(s))^2)\n$$\n求解真实边界上的伪场，我们发现：\n$$\nE_t^{\\text{num}}(s, 0) = - \\left.\\frac{\\partial E_t^{\\text{num}}}{\\partial n}\\right|_{n=0} \\delta n(s) - \\mathcal{O}((\\delta n(s))^2)\n$$\n对于一个收敛的数值格式，当网格间距 $h \\to 0$ 时，数值解及其导数应收敛于精确解及其导数。问题给出了边界附近精确场的展开式：$E_t(s,n) = A(s)n + B(s)n^2 + \\mathcal{O}(n^3)$。精确场在边界处的法向导数为 $\\partial E_t/\\partial n|_{n=0} = A(s)$。因此，我们可以用这个值来近似数值解的导数：\n$$\n\\left.\\frac{\\partial E_t^{\\text{num}}}{\\partial n}\\right|_{n=0} \\approx \\left.\\frac{\\partial E_t}{\\partial n}\\right|_{n=0} = A(s)\n$$\n问题指出 $A(s)$ 通常是有限且非零的。因此，在首项上，伪切向场与近似边界的几何偏移量成正比：\n$$\nE_t^{\\text{num}}(s, 0) \\approx -A(s) \\delta n(s)\n$$\n因此，误差的量级为 $|E_t^{\\text{num}}(s, 0)| \\sim |A(s)| |\\delta n(s)|$。任务简化为确定两种指定边界表示方法下，法向偏移量 $|\\delta n(s)|$ 相对于网格间距 $h$ 的标度阶数。\n\n**阶梯法 ($\\Gamma_{\\text{stair}}$)**\n\n阶梯近似用一组与笛卡尔网格坐标轴对齐的平面面元来表示光滑边界 $\\Gamma$。对于光滑边界 $\\Gamma$ 上任何法线不与网格轴完全对齐的点，阶梯边界 $\\Gamma_{\\text{stair}}$ 都会在局部发生位移。$\\Gamma$ 上的点与其所在网格单元的面之间的最大距离，从根本上受限于单元尺寸 $h$。法向偏移量 $\\delta n_{\\text{stair}}(s)$ 是该位移在法向方向 $\\hat{\\boldsymbol{n}}(s)$ 上的投影。除特殊情况（例如，与网格对齐的平坦边界）外，在几乎所有点 $s$ 处，该偏移量都与网格间距 $h$ 同阶。\n更正式地说，从点 $P \\in \\Gamma$ 到离散边界 $\\Gamma_{\\text{stair}}$ 的距离由一个常数乘以 $h$ 所界定。因此，我们有：\n$$\n|\\delta n_{\\text{stair}}(s)| = \\mathcal{O}(h)\n$$\n这是一个一阶几何近似误差。将此标度关系代入我们的误差表达式，可得伪切向场的标度关系：\n$$\n|E_t^{\\text{num}}(s,0)| \\sim |A(s)| |\\delta n_{\\text{stair}}(s)| = \\mathcal{O}(h)\n$$\n将其与所需形式 $|E_t^{\\text{num}}(s,0)| \\sim C_{\\text{stair}}(s) h^{p_{\\text{stair}}}$ 进行比较，我们确定阶梯法的精度阶数为：\n$$\np_{\\text{stair}} = 1\n$$\n\n**Dey–Mittra 共形方法 ($\\Gamma_{\\text{DM}}$)**\n\nDey–Mittra 方法提供了一种更复杂的近似。在每个被边界 $\\Gamma$“切割”的网格单元内，该方法用一个平面面元 $\\Gamma_{\\text{DM}}$ 来替换 $\\Gamma$ 的曲线段。该面元是根据真实边界 $\\Gamma$ 与网格单元边的交点构建的。\n为了分析几何误差，考虑在 $\\Gamma$ 上某点建立一个局部坐标系，原点在该点，一个轴与 $\\Gamma$ 相切，另一个轴与 $\\Gamma$垂直。由于 $\\Gamma$ 是 $\\mathcal{C}^2$ 类的，它可以在局部被抛物线近似。描述边界的函数形式为 $n(t) = \\frac{1}{2}\\kappa t^2 + \\mathcal{O}(t^3)$，其中 $t$ 是切向坐标，$\\kappa$ 是局部曲率。从这个角度看，Dey–Mittra 近似相当于用弦来代替这段抛物线弧。这条弦的长度约为 $h$ 阶。\n一个标准的几何结论指出，抛物线弧与其弦之间的最大距离与曲率以及弦长的平方成正比。曲线 $y(x) = \\frac{1}{2}\\kappa x^2$ 与连接 $(\\pm L/2, \\frac{1}{2}\\kappa(L/2)^2)$ 的弦之间的误差在 $x=0$ 处最大，其值为 $\\frac{1}{8}\\kappa L^2$。由于特征长度 $L$ 与网格尺寸 $h$ 成比例，法向偏移量 $\\delta n_{\\text{DM}}(s)$ 与局部曲率 $\\kappa(s)$ 和 $h^2$ 成正比。\n$$\n|\\delta n_{\\text{DM}}(s)| = \\mathcal{O}(\\kappa(s) h^2)\n$$\n由于问题说明曲率有界，这代表了一个二阶几何近似误差：\n$$\n|\\delta n_{\\text{DM}}(s)| = \\mathcal{O}(h^2)\n$$\n将此改进的几何标度关系代入场误差的表达式：\n$$\n|E_t^{\\text{num}}(s,0)| \\sim |A(s)| |\\delta n_{\\text{DM}}(s)| = \\mathcal{O}(h^2)\n$$\n将其与形式 $|E_t^{\\text{num}}(s,0)| \\sim C_{\\text{DM}}(s) h^{p_{\\text{DM}}}$ 进行比较，我们确定 Dey–Mittra 共形方法的精度阶数为：\n$$\np_{\\text{DM}} = 2\n$$\n总之，施加 PEC 边界条件所产生的主要误差源于边界的位置不准确。阶梯法的一阶几何误差导致一阶场误差，而 Dey-Mittra 共形方法的二阶几何误差导致二阶场误差。\n\n因此得到的阶数为 $p_{\\text{stair}}=1$ 和 $p_{\\text{DM}}=2$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理解了 Dey-Mittra 方法在理论上的二阶精度后，我们自然会转向其实现的核心——精确的几何计算。此项实践将引导您解决 Dey-Mittra 方法中最基本也是最关键的部分：当一个平面型 PEC 边界切割一个三维 Yee 单元时，如何稳健地计算每个被切割面元的有效面积分数。通过设计并实现一个基于凸多边形裁剪的算法 ()，您将掌握构建任何基于 Dey-Mittra 的 FDTD 代码所必需的基础几何处理技能。",
            "id": "3298079",
            "problem": "考虑计算电磁学中用于完美电导体（PEC）建模的 Dey and Mittra 离散几何共形方法。在该方法中，穿过 Yee 单元的 PEC 边界效应由分数几何度量表示。对于一个被切割的面，有效面积是该面位于 PEC 非导电侧部分的度量，面积分数是比值 $A_f/A$，其中 $A_f$ 是被切割面的面积，$A$ 是完整面的面积。\n\n给定一个立方体 Yee 单元，即 $\\mathbb{R}^3$中的单位立方体 $[0,1]^3$，以及一个平面 PEC，表示为仿射函数的零水平集\n$$\n\\phi(\\mathbf{x}) \\equiv \\mathbf{n}\\cdot \\mathbf{x} + d = 0,\n$$\n其中 $\\mathbf{n}\\in\\mathbb{R}^3$ 是非零向量，$d\\in\\mathbb{R}$。非导电（空气）区域定义为闭合半空间 $\\{\\mathbf{x}\\in\\mathbb{R}^3 : \\phi(\\mathbf{x}) \\ge 0\\}$。PEC 占据互补的闭合半空间 $\\{\\mathbf{x}\\in\\mathbb{R}^3 : \\phi(\\mathbf{x}) \\le 0\\}$。\n\n对于单位立方体的六个面，表示为\n- $x=0$，\n- $x=1$，\n- $y=0$，\n- $y=1$，\n- $z=0$，\n- $z=1$，\n\n定义面积分数\n$$\n\\frac{A_f}{A} \\equiv \\frac{\\text{area}\\left(\\{\\mathbf{x}\\in \\text{face} : \\phi(\\mathbf{x}) \\ge 0\\}\\right)}{\\text{area}(\\text{face})}.\n$$\n因为该立方体是单位立方体，所以每个面的面积都为 1，因此分数 $\\frac{A_f}{A}$ 是无量纲的，并且等于该面上交集的面积。\n\n任务：\n1. 从第一性原理出发，即曲面上面积的积分定义以及将 $A_f$ 解释为指示函数的积分，设计一个鲁棒的算法，对于由 $(\\mathbf{n}, d)$ 定义的给定平面，计算六个面中每一个的 $\\frac{A_f}{A}$。您的算法必须仅依赖于不依赖于任何网格尺寸细化的基本凸几何运算，并且必须对 $\\mathbf{n}$ 的任何方向和任何实数 $d$ 都有效。您必须确保正确处理退化情况，例如平面不与立方体相交、沿某条边相切或穿过某个顶点的情况。\n2. 证明您的算法是正确的，即它能精确计算平面 PEC 切割下 $\\frac{A_f}{A}$ 的积分定义，并确定其每个面的计算复杂度为 $\\mathcal{O}(1)$，与几何参数和网格细化无关。您的证明必须基于原理，并从面和半空间的凸性以及平面中多边形裁剪的性质推导得出。\n3. 将您的算法实现为一个完整的、可运行的程序，该程序不接受任何输入，并为以下平面测试套件计算面积分数，每个平面由 $(n_x, n_y, n_z, d)$ 给出，非导电侧由 $\\phi(\\mathbf{x}) \\ge 0$ 定义：\n   - 测试 $1$：$(1, 0, 0, -0.5)$。\n   - 测试 $2$：$(1, 1, 1, -0.75)$。\n   - 测试 $3$：$(0, 0, 1, -1.2)$。\n   - 测试 $4$：$(0, 0, 1, 0.1)$。\n   - 测试 $5$：$(1, 0, 0, -10^{-9})$。\n   所有数字都是实数，并以标准十进制形式书写，除了 $10^{-9}$，它表示一个非常小的数的科学记数法。\n4. 您的程序的输出必须是单行，按顺序包含每个测试用例的六个面积分数列表，对应于面 $[x{=}0, x{=}1, y{=}0, y{=}1, z{=}0, z{=}1]$。将所有测试的结果汇总到一个列表的列表中。所需的最终输出格式必须是严格的单行，其中包含一个类似 Python 的浮点数列表的列表，例如\n$$\n[\\,[f_{1,x0}, f_{1,x1}, f_{1,y0}, f_{1,y1}, f_{1,z0}, f_{1,z1}],\\ldots,[f_{5,x0}, f_{5,x1}, f_{5,y0}, f_{5,y1}, f_{5,z0}, f_{5,z1}]\\,].\n$$\n\n科学和算法约束：\n- 仅使用定义 $A_f = \\int_{\\text{face}} \\mathbf{1}_{\\{\\phi(\\mathbf{x}) \\ge 0\\}} \\, \\mathrm{d}S$（其中 $\\mathbf{1}$ 是指示函数）、面和半空间的凸性以及平面多边形面积公式来推导和证明您的方法。不要假设或使用任何预先推导出的 Dey–Mittra 分数面积公式或任何基于查找的快捷方式。\n- 不涉及角度；由于 $\\frac{A_f}{A}$ 是无量纲的，因此不需要单位。\n- 您的算法应在每个面的局部二维坐标图上运行，并且必须对所有指定的测试都具有鲁棒性。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是对应于一个测试用例的六个浮点数的列表，如上所述（例如，$[[\\cdots],[\\cdots],\\ldots]$）。",
            "solution": "我们从 Dey–Mittra 对切割面的共形解释开始：一个被完美电导体（PEC）界面切割的 Yee 单元中的面 $\\mathcal{F}$ 的有效面积 $A_f$ 是曲面积分\n$$\nA_f \\equiv \\int_{\\mathcal{F}} \\mathbf{1}_{\\{\\phi(\\mathbf{x}) \\ge 0\\}} \\, \\mathrm{d}S,\n$$\n其中 $\\phi(\\mathbf{x}) \\equiv \\mathbf{n}\\cdot \\mathbf{x} + d$ 是一个仿射函数，其零点集是界面平面，其非导电（空气）侧是闭合半空间 $\\{\\phi(\\mathbf{x}) \\ge 0\\}$。面积分数为 $\\frac{A_f}{A}$，其中 $A \\equiv \\int_{\\mathcal{F}} 1 \\,\\mathrm{d}S$ 是完整面的面积。对于单位立方体，$A=1$。\n\n基于原理的几何简化。单位立方体的每个面 $\\mathcal{F}$ 都是一个坐标平面的凸正方形子集，我们将其视为一个二维仿射子空间。仿射函数 $\\phi$ 在该平面上的限制是另一个二维变量的仿射函数。因此，\n$$\n\\mathcal{F}\\cap\\{\\phi\\ge 0\\} = \\{\\mathbf{x}\\in \\mathcal{F} : \\phi(\\mathbf{x})\\ge 0\\}\n$$\n是两个凸集的交集：一个凸多边形（正方形面）和一个在该二维仿射子空间中的闭合半平面。根据凸性，该交集是一个凸多边形（可能为空、等于整个正方形，或在退化情况下为低维，如线段）。其面积恰好是\n$$\nA_f = \\int_{\\mathcal{F}} \\mathbf{1}_{\\{\\phi\\ge 0\\}} \\,\\mathrm{d}S = \\text{area of the polygon } \\mathcal{P} = \\mathcal{F}\\cap \\{\\phi\\ge 0\\}.\n$$\n\n局部坐标。通过固定一个笛卡尔坐标并让另外两个在 $[0,1]$ 上变化来指定一个面。例如，对于面 $x=0$，定义局部坐标 $(u,v) \\equiv (y,z)$ 和嵌入 $\\mathbf{x}(u,v) = (0,u,v)$，其中 $(u,v)\\in [0,1]^2$。那么\n$$\n\\phi(\\mathbf{x}(u,v)) = n_x \\cdot 0 + n_y u + n_z v + d = a u + b v + c,\n$$\n其中 $a \\equiv n_y$，$b \\equiv n_z$，$c \\equiv d$。因此，在局部坐标中，可行集是单位正方形 $[0,1]^2$ 与半平面 $\\{a u + b v + c \\ge 0\\}$ 的交集。对于面 $x=1$（其中 $c \\equiv n_x + d$）、$y=0$（$a \\equiv n_x$，$b \\equiv n_z$，$c \\equiv d$）、$y=1$（$c \\equiv n_y + d$）、$z=0$（$a \\equiv n_x$，$b \\equiv n_y$，$c \\equiv d$）和 $z=1$（$c \\equiv n_z + d$），也存在类似的简化。\n\n算法设计。在每个面的局部 $(u,v)$ 坐标中，使用一个常数时间平面多边形裁剪算法计算凸多边形 $\\mathcal{P} \\equiv [0,1]^2 \\cap \\{a u + b v + c \\ge 0\\}$ 的面积：\n1. 将正方形多边形初始化为有序的顶点列表\n$$\n\\mathcal{S} = \\{(0,0), (1,0), (1,1), (0,1)\\}.\n$$\n2. 使用专用于单个半平面的 Sutherland–Hodgman 算法，根据单个线性不等式 $a u + b v + c \\ge 0$ 裁剪 $\\mathcal{S}$：\n   - 对于从顶点 $(u_i,v_i)$ 到 $(u_{i+1},v_{i+1})$ 的每条有向边，计算带符号值 $s_i = a u_i + b v_i + c$ 和 $s_{i+1} = a u_{i+1} + b v_{i+1} + c$。\n   - 如果 $s \\ge 0$，则顶点被分类为内部（为保证鲁棒性，使用数值容差）。\n   - 输出顶点列表由标准的四种情况构建：出到出（不添加任何内容）、出到入（添加交点）、入到入（添加终点）、入到出（添加交点而不添加其他内容）。沿线段的交点通过求解参数 $t\\in[0,1]$ 的线性方程确定：\n     $$\n     a\\,(u_i + t(u_{i+1}-u_i)) + b\\,(v_i + t(v_{i+1}-v_i)) + c = 0\n     \\quad \\Rightarrow \\quad\n     t = -\\frac{s_i}{a(u_{i+1}-u_i) + b(v_{i+1}-v_i)}.\n     $$\n     如果分母为零，则边与裁剪线平行；在这种情况下不添加交点，因为两个端点要么都在内部（保留终点），要么都在外部（不添加任何内容）。\n3. 生成的顶点列表描述了 $\\mathcal{P}$。使用鞋带公式计算其面积：\n$$\n\\text{area}(\\mathcal{P}) = \\frac{1}{2}\\left| \\sum_{i=1}^{m} u_i v_{i+1} - v_i u_{i+1} \\right|,\n$$\n其中索引 $i{+}1$ 模 $m$ 进行循环， $m$ 是顶点数。如果 $m  3$，面积为零。\n4. 由于完整面的面积为 $A=1$，因此分数为 $\\frac{A_f}{A}=\\text{area}(\\mathcal{P})$。\n\n正确性证明。我们证明该算法返回精确的 $A_f$：\n\n- 根据定义，$A_f = \\int_{\\mathcal{F}} \\mathbf{1}_{\\{\\phi\\ge 0\\}} \\,\\mathrm{d}S$。在平面上使用局部参数化 $\\mathbf{x}(u,v)$，对于单位坐标面，$\\mathrm{d}S = \\mathrm{d}u\\,\\mathrm{d}v$（相差一个等于 1 的常数雅可比行列式）。因此，\n  $$\n  A_f = \\int_{[0,1]^2} \\mathbf{1}_{\\{a u + b v + c \\ge 0\\}} \\,\\mathrm{d}u\\,\\mathrm{d}v\n      = \\text{area}\\left( [0,1]^2 \\cap \\{a u + b v + c \\ge 0\\} \\right).\n  $$\n- 集合 $\\{a u + b v + c \\ge 0\\}$ 是 $\\mathbb{R}^2$ 中的一个闭合半平面。一个凸多边形（单位正方形）与一个闭合半平面的交集是一个凸多边形 $\\mathcal{P}$（可能为空或退化）。\n- 用于通过半平面裁剪多边形的 Sutherland–Hodgman 算法，通过遍历输入多边形的边，在半平面边界切割边的地方输出顶点和交点，从而精确构造出 $\\mathcal{P}$ 的顶点集。Sutherland–Hodgman 算法的正确性是经典的，其依据是：输出是通过与半平面逐步求交而形成的凸多边形交集，且该算法枚举了支撑半空间的约束，保留了所有满足约束的顶点，并在每个边的交叉处插入顶点。形式上，如果 $\\mathcal{Q}$ 是输入多边形，$H$ 是一个闭合半平面，算法返回 $\\mathcal{Q}\\cap H$ 作为一个多边形，其顶点沿 $\\partial(\\mathcal{Q}\\cap H)$ 按循环顺序出现。\n- 鞋带公式能够计算任何给定有序顶点的非自相交多边形的精确面积。由于 $\\mathcal{P}$ 是凸的，且算法按循环顺序输出顶点，因此鞋带公式能精确地得出 $\\text{area}(\\mathcal{P})$。\n- 综合以上各点，该算法能精确计算 $A_f$；除以 $A=1$ 得到 $\\frac{A_f}{A}$。\n\n退化情况处理与鲁棒性。如果平面不与面相交或完全位于一侧，则不等式 $a u + b v + c \\ge 0$ 对所有 $(u,v)\\in[0,1]^2$ 要么为真（全区域），要么为假（零区域）；裁剪算法会相应地返回原始正方形或空多边形。如果边界线 $a u + b v + c = 0$ 与某条边重合或穿过某个顶点，算法在包含性的 $s\\ge 0$ 分类下仍然正确，因为交集多边形仍然是良定义的（可能存在共线的相邻顶点），并且鞋带公式计算的面积会相应地减少。通过在内部测试和交点计算的分母检查中使用一个小的容差来确保数值鲁棒性。\n\n计算复杂度。输入多边形有固定数量的顶点 $m=4$，并被单个半平面裁剪。Sutherland–Hodgman 算法对 $m$ 条边中的每一条处理一次，每条边的算术运算量是常数，并且每条边最多增加一个交点。因此，每个面的操作次数受一个与几何形状和网格大小无关的常数限制，即 $\\mathcal{O}(1)$。对生成的多边形进行鞋带公式面积计算，对于四边形的单半平面裁剪，最多有 $m{+}2 \\le 6$ 个顶点，其复杂度也是 $\\mathcal{O}(1)$。因此，对于每个被切割的面，总计算复杂度为 $\\mathcal{O}(1)$。\n\n实现细节。我们为每个面实现上述算法，使用适当的局部映射和参数 $(a,b,c)$：\n- 对于 $x=0$：$(u,v)=(y,z)$，$(a,b,c)=(n_y, n_z, d)$。\n- 对于 $x=1$：$(u,v)=(y,z)$，$(a,b,c)=(n_y, n_z, n_x + d)$。\n- 对于 $y=0$：$(u,v)=(x,z)$，$(a,b,c)=(n_x, n_z, d)$。\n- 对于 $y=1$：$(u,v)=(x,z)$，$(a,b,c)=(n_x, n_z, n_y + d)$。\n- 对于 $z=0$：$(u,v)=(x,y)$，$(a,b,c)=(n_x, n_y, d)$。\n- 对于 $z=1$：$(u,v)=(x,y)$，$(a,b,c)=(n_x, n_y, n_z + d)$。\n\n测试套件规范。我们为以下平面计算面积分数：\n- 测试 $1$：$(1, 0, 0, -0.5)$。\n- 测试 $2$：$(1, 1, 1, -0.75)$。\n- 测试 $3$：$(0, 0, 1, -1.2)$。\n- 测试 $4$：$(0, 0, 1, 0.1)$。\n- 测试 $5$：$(1, 0, 0, -10^{-9})$。\n\n最终程序以如下形式输出单行：\n$$\n\\big[\\,[f_{1,x0}, f_{1,x1}, f_{1,y0}, f_{1,y1}, f_{1,z0}, f_{1,z1}],\\,[f_{2,x0}, \\ldots, f_{2,z1}],\\,\\ldots,\\,[f_{5,x0}, \\ldots, f_{5,z1}]\\,\\big],\n$$\n这是一个浮点数列表的列表，对应于每个测试用例中按顺序 $[x{=}0, x{=}1, y{=}0, y{=}1, z{=}0, z{=}1]$排列的六个面。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef clip_polygon_by_halfplane(polygon, a, b, c, tol=1e-12):\n    \"\"\"\n    Clip a convex polygon (list of (u,v) tuples) by the half-plane a*u + b*v + c = 0.\n    Returns a list of (u,v) tuples for the clipped polygon in CCW order.\n    \"\"\"\n    if not polygon:\n        return []\n\n    def value(pt):\n        return a * pt[0] + b * pt[1] + c\n\n    output = []\n    n = len(polygon)\n    for i in range(n):\n        P = polygon[i]\n        Q = polygon[(i + 1) % n]\n        sP = value(P)\n        sQ = value(Q)\n        inP = sP = -tol\n        inQ = sQ = -tol\n\n        if inP and inQ:\n            # Both inside: keep Q\n            output.append(Q)\n        elif inP and not inQ:\n            # P in, Q out: add intersection only\n            denom = a * (Q[0] - P[0]) + b * (Q[1] - P[1])\n            if abs(denom)  tol:\n                t = -sP / denom\n                Iu = P[0] + t * (Q[0] - P[0])\n                Iv = P[1] + t * (Q[1] - P[1])\n                output.append((Iu, Iv))\n            # else: edge parallel to boundary; nothing to add\n        elif (not inP) and inQ:\n            # P out, Q in: add intersection then Q\n            denom = a * (Q[0] - P[0]) + b * (Q[1] - P[1])\n            if abs(denom)  tol:\n                t = -sP / denom\n                Iu = P[0] + t * (Q[0] - P[0])\n                Iv = P[1] + t * (Q[1] - P[1])\n                output.append((Iu, Iv))\n            # If parallel and both not inside, do nothing; if parallel and Q is inside, we still append Q\n            output.append(Q)\n        else:\n            # both outside: append nothing\n            pass\n\n    # Remove nearly duplicate consecutive vertices to improve robustness\n    cleaned = []\n    for pt in output:\n        if not cleaned:\n            cleaned.append(pt)\n        else:\n            if abs(pt[0] - cleaned[-1][0])  tol or abs(pt[1] - cleaned[-1][1])  tol:\n                cleaned.append(pt)\n    # If polygon closes back to the start with tiny difference, drop last\n    if len(cleaned) = 2:\n        if abs(cleaned[0][0] - cleaned[-1][0]) = tol and abs(cleaned[0][1] - cleaned[-1][1]) = tol:\n            cleaned.pop()\n\n    return cleaned\n\ndef polygon_area(poly):\n    \"\"\"\n    Compute area of a polygon given as a list of (u,v) tuples using the shoelace formula.\n    Returns a nonnegative float.\n    \"\"\"\n    m = len(poly)\n    if m  3:\n        return 0.0\n    area2 = 0.0\n    for i in range(m):\n        u1, v1 = poly[i]\n        u2, v2 = poly[(i + 1) % m]\n        area2 += u1 * v2 - v1 * u2\n    return abs(area2) * 0.5\n\ndef face_fraction_for_plane(n, d, tol=1e-12):\n    \"\"\"\n    Compute [A_x0, A_x1, A_y0, A_y1, A_z0, A_z1] area fractions for unit cube faces\n    given plane phi(x)=n.x + d = 0, air side phi=0.\n\n    n: tuple/list of (nx, ny, nz)\n    d: float\n    \"\"\"\n    nx, ny, nz = n\n    # Base square polygon in local (u,v) coordinates\n    square = [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)]\n\n    results = []\n\n    # x = 0 face: (u,v) = (y,z), inequality: ny*u + nz*v + d = 0\n    a, b, c = ny, nz, d\n    poly = clip_polygon_by_halfplane(square, a, b, c, tol)\n    results.append(polygon_area(poly))  # area since face area is 1\n\n    # x = 1 face: (u,v) = (y,z), inequality: ny*u + nz*v + (nx + d) = 0\n    a, b, c = ny, nz, nx + d\n    poly = clip_polygon_by_halfplane(square, a, b, c, tol)\n    results.append(polygon_area(poly))\n\n    # y = 0 face: (u,v) = (x,z), inequality: nx*u + nz*v + d = 0\n    a, b, c = nx, nz, d\n    poly = clip_polygon_by_halfplane(square, a, b, c, tol)\n    results.append(polygon_area(poly))\n\n    # y = 1 face: (u,v) = (x,z), inequality: nx*u + nz*v + (ny + d) = 0\n    a, b, c = nx, nz, ny + d\n    poly = clip_polygon_by_halfplane(square, a, b, c, tol)\n    results.append(polygon_area(poly))\n\n    # z = 0 face: (u,v) = (x,y), inequality: nx*u + ny*v + d = 0\n    a, b, c = nx, ny, d\n    poly = clip_polygon_by_halfplane(square, a, b, c, tol)\n    results.append(polygon_area(poly))\n\n    # z = 1 face: (u,v) = (x,y), inequality: nx*u + ny*v + (nz + d) = 0\n    a, b, c = nx, ny, nz + d\n    poly = clip_polygon_by_halfplane(square, a, b, c, tol)\n    results.append(polygon_area(poly))\n\n    # Clamp tiny numerical drift into [0,1]\n    clamped = [min(1.0, max(0.0, r)) for r in results]\n    return clamped\n\ndef solve():\n    # Define the test cases from the problem statement as (nx, ny, nz, d).\n    test_cases = [\n        (1.0, 0.0, 0.0, -0.5),\n        (1.0, 1.0, 1.0, -0.75),\n        (0.0, 0.0, 1.0, -1.2),\n        (0.0, 0.0, 1.0, 0.1),\n        (1.0, 0.0, 0.0, -1e-9),\n    ]\n\n    results = []\n    for nx, ny, nz, d in test_cases:\n        fracs = face_fraction_for_plane((nx, ny, nz), d)\n        results.append(fracs)\n\n    # Final print statement in the exact required format.\n    # Produce a Python-like list of lists of floats on a single line.\n    # Use default string conversion for floats.\n    print(str(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在建立了理论基础并掌握了核心几何算法之后，最后的步骤是将物理定律与几何处理相结合，并验证整个方法的正确性。本项实践将向您介绍一种在数值方法开发中广泛使用的强大验证工具——“补丁测试”（Patch Test），它在此处通过“人造解法”（Method of Manufactured Solutions）来实现。您将构建一个精确满足麦克斯韦方程积分形式的场解，并用它来检验您实现的 Dey-Mittra 离散算子是否能以预期的二阶精度再现这些物理关系 ()，从而完成从理论到实践验证的闭环。",
            "id": "3298002",
            "problem": "考虑在介电常数为 $\\epsilon$、磁导率为 $\\mu$ 的均匀、各向同性自由空间中的三维麦克斯韦方程组的积分形式。在角频率为 $\\omega$ 的相量频域中，法拉第定律在一个边界为 $\\partial \\mathcal{S}$ 的光滑开曲面 $\\mathcal{S}$ 上表示为\n$$\n\\oint_{\\partial \\mathcal{S}} \\mathbf{E} \\cdot d\\boldsymbol{\\ell} \\;=\\; -\\,i\\,\\omega\\,\\mu \\int_{\\mathcal{S}} \\mathbf{H}\\cdot \\mathbf{n}_{\\mathcal{S}}\\, dS,\n$$\n其中 $\\mathbf{n}_{\\mathcal{S}}$ 是 $\\mathcal{S}$ 的单位法向量，$i$ 是虚数单位。我们关注在时域有限差分 (FDTD) 框架下，对单个切割单元上的 Dey–Mittra 共形方法进行的局部斑块测试。Dey–Mittra (DM) 方法修改了被理想电导体 (PEC) 部分切割的 Yee 元胞的边和面的几何量（长度和面积），同时保持场自由度在规范的 Yee 位置上。PEC 边界强制导体表面的切向电场为零，因此内部导体边界对围线积分的贡献为零。\n\n您将构造一个时谐平面波的构造解，该解能精确满足麦克斯韦旋度方程，并在切割平面上强制满足 PEC 切向电场条件。设 $\\mathbf{n}$ 为 PEC 平面的固定单位法向量，$\\mathbf{k}$ 为一个满足 $\\mathbf{k}\\cdot \\mathbf{n} = 0$ 的波矢量，自由空间参数的选择使得 $|\\mathbf{k}| = \\omega \\sqrt{\\mu\\,\\epsilon}$。定义相量场\n$$\n\\mathbf{E}(\\mathbf{r}) \\;=\\; E_0\\, e^{\\,i\\,\\mathbf{k}\\cdot\\mathbf{r}}\\, \\mathbf{n}, \\qquad\n\\mathbf{H}(\\mathbf{r}) \\;=\\; \\frac{1}{\\mu\\,\\omega}\\, \\mathbf{k}\\times \\mathbf{E}(\\mathbf{r}),\n$$\n其中 $E_0$ 是一个实数振幅。只要 $|\\mathbf{k}| = \\omega \\sqrt{\\mu \\epsilon}$ 且 $\\mathbf{k}\\cdot \\mathbf{E} = 0$，这些场就满足 $\\nabla\\times \\mathbf{E} = -\\,i\\,\\omega\\,\\mu\\,\\mathbf{H}$ 和 $\\nabla\\times \\mathbf{H} = i\\,\\omega\\,\\epsilon\\,\\mathbf{E}$，后一个条件由于 $\\mathbf{E}$ 平行于 $\\mathbf{n}$ 且 $\\mathbf{k}\\cdot \\mathbf{n} = 0$ 而得到保证。因为 $\\mathbf{E}$ 平行于 $\\mathbf{n}$，所以 $\\mathbf{E}$ 在 PEC 平面上的切向分量为零，满足 PEC 条件。\n\n考虑一个尺寸为 $h$ 的立方单元位于 $z = 0$ 处的一个 Yee 表面 $\\mathcal{S}_z$，因此 $\\mathcal{S}_z = \\{(x,y,0)\\,:\\,0\\le x\\le h,\\,0\\le y\\le h\\}$，其边界 $\\partial \\mathcal{S}_z$ 由四条坐标轴对齐的边构成，按逆时针方向定向（根据右手定则，$\\mathbf{n}_{\\mathcal{S}} = \\hat{\\mathbf{z}}$）。一个平面法向量为 $\\mathbf{n}$、平面参数为 $d$ 的 PEC 半空间切割该单元；$\\mathcal{S}_z$ 的开放（非导电）部分是通过半空间 $\\mathbf{n}\\cdot \\mathbf{r} \\le d$ 在 $z=0$ 处对正方形 $[0,h]\\times[0,h]$ 进行裁剪后得到的多边形。类似地，每个边界边在满足相同半空间不等式的部分是开放的。\n\nDey–Mittra 离散几何量的定义如下：\n- 对于 $\\partial \\mathcal{S}_z$ 的每条有向边 $e$，其开放长度 $L_e$ 是满足 $\\mathbf{n}\\cdot \\mathbf{r} \\le d$ 的线段的长度。DM 线积分近似使用开放线段上切向电场的中点值，即：\n$$\nI_{\\mathrm{DM}}^{(e)} \\;=\\; \\left(\\mathbf{E}(\\mathbf{r}_{e,\\mathrm{mid}})\\cdot \\mathbf{t}_e\\right)\\, L_e,\n$$\n其中 $\\mathbf{t}_e$ 是与 $\\partial \\mathcal{S}_z$ 方向一致的边 $e$ 的单位切向量，$\\mathbf{r}_{e,\\mathrm{mid}}$ 是 $e$ 的开放线段的中点。\n- 对于面积为 $A_{\\mathcal{P}}$ 的开放多边形 $\\mathcal{P}\\subset \\mathcal{S}_z$，DM 磁通量近似使用法向磁场的形心值，\n$$\n\\Phi_{\\mathrm{DM}} \\;=\\; \\left(\\mathbf{H}(\\mathbf{r}_{\\mathcal{P},\\mathrm{centroid}})\\cdot \\hat{\\mathbf{z}}\\right)\\, A_{\\mathcal{P}}.\n$$\n\n法拉第定律在切割面上的 DM 残差为复数\n$$\nR(h;\\mathbf{n},d,\\mathbf{k}) \\;=\\; \\sum_{e\\subset \\partial \\mathcal{S}_z} I_{\\mathrm{DM}}^{(e)} \\;+\\; i\\,\\omega\\,\\mu\\, \\Phi_{\\mathrm{DM}}.\n$$\n对于上述构造解和平面 PEC 表面，由于沿内部切割线段的 PEC 切向条件和精确的麦克斯韦积分关系，精确残差为零。因此，DM 残差的模 $|R|$ 衡量了局部的 DM 相容性误差。如果 $|R| = \\mathcal{O}(h^2)$，则称 DM 方法在该斑块上能以二阶精度再现积分关系。\n\n您的任务是实现一个程序，该程序能够：\n- 对于给定的 $\\mathbf{n}$、$d$、$\\mathbf{k}$ 和 $h$，计算开放边的长度 $L_e$、中点位置 $\\mathbf{r}_{e,\\mathrm{mid}}$、裁剪后的开放多边形 $\\mathcal{P}$、其面积 $A_{\\mathcal{P}}$ 和形心 $\\mathbf{r}_{\\mathcal{P},\\mathrm{centroid}}$。\n- 对三个依次减半的网格尺寸 $h$，计算 $R(h;\\mathbf{n},d,\\mathbf{k})$ 及其模 $|R|$。\n- 通过计算成对的比率\n$$\np_1 \\;=\\; \\frac{\\ln\\left(|R(h_1)|/|R(h_2)|\\right)}{\\ln\\left(h_1/h_2\\right)}, \\qquad\np_2 \\;=\\; \\frac{\\ln\\left(|R(h_2)|/|R(h_3)|\\right)}{\\ln\\left(h_2/h_3\\right)},\n$$\n来估计观测阶 $p$，并返回保守估计值 $\\min(p_1,p_2)$。\n\n使用以下参数集测试套件，每个测试集包含三个网格尺寸 $h\\in\\{\\,h_1, h_2, h_3\\,\\}$，其中 $h_1 = 0.2$，$h_2 = 0.1$，$h_3 = 0.05$：\n- 测试 A（一般斜切）：$\\mathbf{n} = \\frac{1}{\\|\\mathbf{v}\\|}\\mathbf{v}$，其中 $\\mathbf{v} = (0.8,\\,0.6,\\,0.3)$，$d = \\alpha h$，其中 $\\alpha = 0.7$，平面波振幅 $E_0 = 1$，自由空间参数 $\\mu = 1$，$\\epsilon = 1$，且 $|\\mathbf{k}| = \\omega \\sqrt{\\mu \\epsilon}$，其中 $|\\mathbf{k}| = k_0 = 5.0$。选择与 $\\mathbf{n}$ 垂直的 $\\mathbf{k}$，并使 $\\mathbf{k}\\times \\mathbf{n}$ 的 $z$ 分量非零。\n- 测试 B（近角点切割）：$\\mathbf{n} = \\frac{1}{\\|\\mathbf{v}\\|}\\mathbf{v}$，其中 $\\mathbf{v} = (0.8,\\,0.6,\\,0.1)$，$d = \\alpha h$，其中 $\\alpha = 0.1$，$E_0 = 1$，$\\mu = 1$，$\\epsilon = 1$，且 $k_0 = 7.0$，选择的 $\\mathbf{k}\\perp \\mathbf{n}$ 使得 $(\\mathbf{k}\\times \\mathbf{n})\\cdot \\hat{\\mathbf{z}}\\neq 0$。\n- 测试 C（面无切割；完全开放）：$\\mathbf{n} = \\frac{1}{\\|\\mathbf{v}\\|}\\mathbf{v}$，其中 $\\mathbf{v} = (0.3,\\,0.4,\\,0.5)$，$d = \\alpha h$，其中 $\\alpha = 1.5$，$E_0 = 1$，$\\mu = 1$，$\\epsilon = 1$，且 $k_0 = 3.0$，$\\mathbf{k}\\perp \\mathbf{n}$ 的选择同上。\n\n所有量均为无量纲，角度以弧度为单位。您的程序必须：\n- 实现对正方形 $[0,h]\\times[0,h]$ 在 $z=0$ 处被半空间 $\\mathbf{n}\\cdot \\mathbf{r} \\le d$ 进行的稳健多边形裁剪。\n- 为每个测试计算 $h\\in\\{\\,0.2,\\,0.1,\\,0.05\\,\\}$ 时的 DM 残差模 $|R|$。\n- 按前述方法为每个测试用例计算并报告保守的观测阶 $\\min(p_1,p_2)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试 A、B、C 的顺序列出结果，即 $\\big[ p_{\\mathrm{A}}, p_{\\mathrm{B}}, p_{\\mathrm{C}} \\big]$，其中每个 $p$ 都是一个浮点数。",
            "solution": "用户要求实现一个程序，以数值方式验证电磁学中 Dey-Mittra (DM) 共形方法的精度阶。这涉及在单个切割单元面上使用构造的平面波解进行斑块测试。该问题是适定的且科学上是合理的，为几何、物理和数值分析提供了清晰的指令集。我们将按详细的、分步的方案进行求解。\n\n问题的核心是为一系列递减的网格尺寸 $h$ 计算 DM 残差 $R$，然后利用这些残差来估计方法的收敛阶 $p$。残差定义为：\n$$\nR(h;\\mathbf{n},d,\\mathbf{k}) \\;=\\; \\sum_{e\\subset \\partial \\mathcal{S}_z} I_{\\mathrm{DM}}^{(e)} \\;+\\; i\\,\\omega\\,\\mu\\, \\Phi_{\\mathrm{DM}}\n$$\n该表达式代表了法拉第感应定律的离散版本。第一项是电场 $\\mathbf{E}$ 沿单元面边界开放部分的离散线积分，第二项是磁场 $\\mathbf{H}$ 穿过该面开放区域的磁通量的离散时间导数。对于在包含理想电导体 (PEC) 的域上的精确解，该表达式的解析值为零。因此，数值近似的非零值 $R$ 代表了 DM 格式的局部截断误差。如果模 $|R|$ 的缩放行为如同 $\\mathcal{O}(h^p)$，则 $p$ 是精度阶。\n\n求解过程可以分解为三个主要部分：\n1.  **几何处理**：对于给定的单元尺寸 $h$ 和由 $\\mathbf{n}\\cdot \\mathbf{r} = d$ 定义的切割平面，我们必须确定未被 PEC 占用的“开放”区域的几何形状。这涉及到在 $z=0$ 处，用半空间 $\\mathbf{n}\\cdot \\mathbf{r} \\le d$ 来裁剪正方形单元面 $[0,h]\\times[0,h]$。这将产生一个凸多边形 $\\mathcal{P}$。我们需要计算其面积 $A_{\\mathcal{P}}$ 和形心 $\\mathbf{r}_{\\mathcal{P},\\mathrm{centroid}}$。我们还必须确定正方形四个边界边上各自开放线段的长度 $L_e$ 和中点 $\\mathbf{r}_{e,\\mathrm{mid}}$。\n2.  **场值计算与离散化**：我们使用提供的构造平面波解来计算电场 $\\mathbf{E}(\\mathbf{r})$ 和磁场 $\\mathbf{H}(\\mathbf{r})$。这些场在几何步骤中确定的特定点（边中点和多边形形心）上进行求值，以计算线积分的 DM 近似 $I_{\\mathrm{DM}}^{(e)}$ 和磁通量的 DM 近似 $\\Phi_{\\mathrm{DM}}$。\n3.  **残差与阶的计算**：将离散项组合起来形成复数残差 $R$。我们对三个网格尺寸（$h_1=0.2$, $h_2=0.1$, $h_3=0.05$）重复此过程，以获得三个残差的模 $|R_1|, |R_2|, |R_3|$。然后使用公式 $p = \\log_{h_1/h_2} (|R_1|/|R_2|)$ 成对地估计收敛阶。对每个测试用例，报告保守估计值 $\\min(p_1, p_2)$。\n\n我们现在将详细说明实现步骤。\n\n**步骤 1：设置和参数定义**\n对于每个测试用例，我们首先建立物理和几何常数。材料参数为 $\\mu=1$ 和 $\\epsilon=1$。平面波振幅为 $E_0=1$。角频率 $\\omega$ 等于波数大小 $k_0=|\\mathbf{k}|$，因为 $\\omega = |\\mathbf{k}| / \\sqrt{\\mu\\epsilon}$。切割平面的法向量 $\\mathbf{n}$ 通过将给定的向量 $\\mathbf{v}$ 归一化得到。波矢量 $\\mathbf{k}$ 必须满足 $\\mathbf{k}\\cdot\\mathbf{n}=0$ 和 $(\\mathbf{k}\\times\\mathbf{n})\\cdot\\hat{\\mathbf{z}} \\ne 0$。一个满足这些条件的确定性选择是令 $\\mathbf{k}$ 与 $\\hat{\\mathbf{z}} \\times \\mathbf{n}$ 成正比。该向量保证与 $\\mathbf{n}$ 正交。只要 $\\mathbf{n}$ 不平行于 $\\hat{\\mathbf{z}}$（所有测试用例中均是如此），该向量就非零，并且条件 $(\\mathbf{k}\\times\\mathbf{n})\\cdot\\hat{\\mathbf{z}} \\ne 0$ 也得到满足。因此我们定义 $\\mathbf{k} = k_0 \\, (\\hat{\\mathbf{z}} \\times \\mathbf{n}) / \\|\\hat{\\mathbf{z}} \\times \\mathbf{n}\\|$。\n\n**步骤 2：几何计算**\n这是实现中最复杂的部分。\n- **多边形裁剪**：开放多边形 $\\mathcal{P}$ 是正方形单元面 $\\mathcal{S}_z$ 和半空间 $\\mathbf{n}\\cdot\\mathbf{r} \\le d$ 的交集。在 $z=0$ 时，这简化为用半平面 $n_x x + n_y y \\le d$ 来裁剪二维正方形 $[0,h]\\times[0,h]$。我们使用 Sutherland-Hodgman 算法，该算法非常适合用一个凸裁剪区域（半平面）来裁剪一个凸多边形（我们的正方形）。该算法遍历正方形的边，为裁剪后的多边形生成一个新的顶点列表。\n- **多边形面积与形心**：给定裁剪后多边形 $\\mathcal{P}$ 的有序顶点，我们使用多边形形状的标准公式计算其面积 $A_{\\mathcal{P}}$ 和形心 $\\mathbf{r}_{\\mathcal{P},\\mathrm{centroid}}$。面积通过鞋带公式计算：$A = \\frac{1}{2} \\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i)$。形心分量为 $C_x = \\frac{1}{6A} \\sum_{i=0}^{N-1} (x_i + x_{i+1})(x_i y_{i+1} - x_{i+1} y_i)$ 和 $C_y = \\frac{1}{6A} \\sum_{i=0}^{N-1} (y_i + y_{i+1})(x_i y_{i+1} - x_{i+1} y_i)$。对于面积接近于零的情况需要特别小心处理。\n- **边裁剪**：对于正方形的四个边界边（由 $t \\in [0,1]$ 参数化），条件 $\\mathbf{n}\\cdot\\mathbf{r}(t) \\le d$ 定义了一个对应于开放线段的子区间 $[t_{start}, t_{end}]$。开放长度为 $L_e = (t_{end} - t_{start})h$，中点对应于 $t_{mid} = (t_{start} + t_{end})/2$。\n\n**步骤 3：计算 DM 残差**\n确定所有几何量后，我们计算残差 $R$ 的两项：\n- **线积分求和**：对于每条边 $e$，我们计算 $I_{\\mathrm{DM}}^{(e)} = (\\mathbf{E}(\\mathbf{r}_{e,\\mathrm{mid}})\\cdot \\mathbf{t}_e)\\, L_e$。电场是一个复向量，由 $\\mathbf{E}(\\mathbf{r}) = E_0 e^{i\\mathbf{k}\\cdot\\mathbf{r}} \\mathbf{n}$ 给出。求和结果 $\\sum_e I_{\\mathrm{DM}}^{(e)}$ 是一个复数。\n- **磁通量项**：我们计算 $\\Phi_{\\mathrm{DM}} = (\\mathbf{H}(\\mathbf{r}_{\\mathcal{P},\\mathrm{centroid}})\\cdot \\hat{\\mathbf{z}})\\, A_{\\mathcal{P}}$。磁场为 $\\mathbf{H}(\\mathbf{r}) = \\frac{1}{\\mu\\omega}\\mathbf{k}\\times \\mathbf{E}(\\mathbf{r}) = \\frac{E_0}{\\mu\\omega} e^{i\\mathbf{k}\\cdot\\mathbf{r}} (\\mathbf{k}\\times \\mathbf{n})$。然后该项乘以 $i\\omega\\mu$。\n\n**步骤 4：估计收敛阶**\n对每个网格尺寸 $h \\in \\{0.2, 0.1, 0.05\\}$ 执行以上步骤。这将产生一个包含三个残差模的列表 $|R(h_1)|$、 $|R(h_2)|$、 $|R(h_3)|$。然后我们计算两个成对的阶估计：\n$$\np_1 \\;=\\; \\frac{\\ln(|R(h_1)|/|R(h_2)|)}{\\ln(h_1/h_2)}, \\qquad p_2 \\;=\\; \\frac{\\ln(|R(h_2)|/|R(h_3)|)}{\\ln(h_2/h_3)}\n$$\n由于 $h_{i+1}=h_i/2$，每种情况下的分母都是 $\\ln(2)$。每个测试用例的最终报告值是 $\\min(p_1, p_2)$，提供了收敛阶的保守估计。整个过程在下面的 Python 程序中实现了自动化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the observed order of convergence for the Dey-Mittra method\n    on a single cut-cell face for three different test cases.\n    \"\"\"\n\n    # --- Geometric Helper Functions ---\n\n    def clip_polygon(subject_polygon, n_xy, d_plane):\n        \"\"\"Clips a convex polygon against a half-plane using Sutherland-Hodgman.\"\"\"\n        output_list = []\n        if not subject_polygon:\n            return []\n        \n        tol = 1e-14\n        \n        S = subject_polygon[-1]\n        s_val = np.dot(n_xy, S) - d_plane\n        \n        for E in subject_polygon:\n            e_val = np.dot(n_xy, E) - d_plane\n            \n            s_inside = s_val = tol\n            e_inside = e_val = tol\n\n            # Calculate intersection point if edge crosses the boundary\n            if abs(s_val - e_val) > tol:\n                t = s_val / (s_val - e_val)\n                intersection_point = S + t * (E - S)\n            else: # Edge is parallel to the clipping line\n                intersection_point = None\n\n            if e_inside:\n                if not s_inside:\n                    if intersection_point is not None:\n                        output_list.append(intersection_point)\n                output_list.append(E)\n            elif s_inside:\n                if intersection_point is not None:\n                    output_list.append(intersection_point)\n            \n            S = E\n            s_val = e_val\n        return output_list\n\n    def polygon_area(vertices):\n        \"\"\"Calculates the signed area of a polygon using the shoelace formula.\"\"\"\n        if len(vertices)  3:\n            return 0.0\n        area = 0.0\n        for i in range(len(vertices)):\n            p1 = vertices[i]\n            p2 = vertices[(i + 1) % len(vertices)]\n            area += p1[0] * p2[1] - p2[0] * p1[1]\n        return area / 2.0\n\n    def polygon_centroid(vertices, area):\n        \"\"\"Calculates the centroid of a polygon.\"\"\"\n        if len(vertices)  3 or abs(area)  1e-14:\n            if len(vertices) > 0:\n                return sum(vertices) / len(vertices)\n            return np.array([0.0, 0.0])\n        \n        centroid_x, centroid_y = 0.0, 0.0\n        for i in range(len(vertices)):\n            p1 = vertices[i]\n            p2 = vertices[(i + 1) % len(vertices)]\n            cross_prod = p1[0] * p2[1] - p2[0] * p1[1]\n            centroid_x += (p1[0] + p2[0]) * cross_prod\n            centroid_y += (p1[1] + p2[1]) * cross_prod\n        \n        return np.array([centroid_x, centroid_y]) / (6.0 * area)\n\n    # --- Main computation logic ---\n    \n    test_cases = [\n        # (v vector, alpha, k0)\n        (np.array([0.8, 0.6, 0.3]), 0.7, 5.0),\n        (np.array([0.8, 0.6, 0.1]), 0.1, 7.0),\n        (np.array([0.3, 0.4, 0.5]), 1.5, 3.0),\n    ]\n\n    h_vals = [0.2, 0.1, 0.05]\n    result_orders = []\n    \n    for v, alpha, k0 in test_cases:\n        # Define physical parameters and fields for the test case\n        E0 = 1.0\n        mu = 1.0\n        omega = k0\n        n = v / np.linalg.norm(v)\n        \n        k_dir = np.cross(np.array([0.0, 0.0, 1.0]), n)\n        if np.linalg.norm(k_dir)  1e-12: # Handle case where n is parallel to z-axis\n            k_dir = np.cross(np.array([1.0, 0.0, 0.0]), n)\n        k = k0 * k_dir / np.linalg.norm(k_dir)\n\n        def E_field(r):\n            return E0 * np.exp(1j * np.dot(k, r)) * n\n\n        def H_field(r):\n            return (E0 / (mu * omega)) * np.cross(k, n) * np.exp(1j * np.dot(k, r))\n\n        # Calculate residual for each mesh size h\n        R_magnitudes = []\n        for h in h_vals:\n            d = alpha * h\n            n_xy = n[:2]\n            \n            # Clip the square face [0,h]x[0,h]\n            square_verts_2d = [np.array([0.,0.]), np.array([h,0.]), np.array([h,h]), np.array([0.,h])]\n            clipped_poly_2d = clip_polygon(square_verts_2d, n_xy, d)\n            \n            # Compute DM flux term\n            flux_term = 0.0 + 0.0j\n            area_val = polygon_area(clipped_poly_2d)\n            if abs(area_val) > 1e-14:\n                centroid_2d = polygon_centroid(clipped_poly_2d, area_val)\n                r_centroid = np.array([centroid_2d[0], centroid_2d[1], 0.0])\n                H_at_centroid = H_field(r_centroid)\n                phi_dm = H_at_centroid[2] * abs(area_val)\n                flux_term = 1j * omega * mu * phi_dm\n\n            # Compute DM line integral term\n            line_integral_term = 0.0 + 0.0j\n            edge_defs = [\n                (np.array([0., 0., 0.]), np.array([h, 0., 0.])),\n                (np.array([h, 0., 0.]), np.array([h, h, 0.])),\n                (np.array([h, h, 0.]), np.array([0., h, 0.])),\n                (np.array([0., h, 0.]), np.array([0., 0., 0.]))\n            ]\n            \n            for p0, p1 in edge_defs:\n                v0_val = np.dot(n_xy, p0[:2]) - d\n                v1_val = np.dot(n_xy, p1[:2]) - d\n                tol = 1e-14\n\n                t_start, t_end = 0.0, 1.0 # Default is fully open\n                if v0_val > tol and v1_val > tol: # Fully cut\n                    t_start, t_end = 0.0, 0.0 \n                elif v0_val = tol and v1_val > tol: # Cut at p1 end\n                    if abs(v0_val - v1_val) > tol: t_end = v0_val / (v0_val - v1_val)\n                elif v0_val > tol and v1_val = tol: # Cut at p0 end\n                    if abs(v0_val - v1_val) > tol: t_start = v0_val / (v0_val - v1_val)\n\n                if t_end > t_start:\n                    open_length = (t_end - t_start) * h\n                    t_mid = (t_start + t_end) / 2.0\n                    r_mid = p0 + t_mid * (p1 - p0)\n                    E_at_mid = E_field(r_mid)\n                    t_e = (p1 - p0) / h\n                    line_integral_term += np.dot(E_at_mid, t_e) * open_length\n\n            residual = line_integral_term + flux_term\n            R_magnitudes.append(np.abs(residual))\n            \n        # Estimate order of convergence\n        if any(r = 1e-15 for r in R_magnitudes):\n            p1 = p2 = float('inf')\n        else:\n            p1 = np.log(R_magnitudes[0] / R_magnitudes[1]) / np.log(h_vals[0] / h_vals[1])\n            p2 = np.log(R_magnitudes[1] / R_magnitudes[2]) / np.log(h_vals[1] / h_vals[2])\n\n        result_orders.append(min(p1, p2))\n        \n    print(f\"[{','.join(map(str, result_orders))}]\")\n\nsolve()\n```"
        }
    ]
}