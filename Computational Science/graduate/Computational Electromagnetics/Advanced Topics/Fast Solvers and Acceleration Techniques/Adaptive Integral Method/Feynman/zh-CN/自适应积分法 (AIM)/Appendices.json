{
    "hands_on_practices": [
        {
            "introduction": "自适应积分方法 (AIM) 的效率和准确性在很大程度上取决于其核心部分：如何智能地划分近区和远区相互作用。本练习将指导您从第一性原理出发，构建一个实用且自适应的近区厚度规则。您将从分析格林函数本身的变化率开始，并逐步加入对局部电尺寸和几何尖锐度的校正，最终通过一个校准任务来完成模型，这模拟了真实世界中算法的调优过程。",
            "id": "3288301",
            "problem": "考虑使用自适应积分方法 (AIM) 加速在均匀真空介质（介电常数为 $\\epsilon_0$，磁导率为 $\\mu_0$）中离散化的电场积分方程 (EFIE)。AIM 将相互作用分解为近区和远区：近区通过直接求积处理，远区则通过插值到规则网格并与自由空间标量格林函数进行基于快速傅里叶变换的卷积来处理。标量格林函数为 $G(\\mathbf{r}) = \\dfrac{e^{-j k r}}{4 \\pi r}$，其中 $r = \\|\\mathbf{r}\\|$，$j$ 是虚数单位，$k = \\dfrac{2 \\pi f}{c}$ 是频率为 $f$、光速为 $c = \\dfrac{1}{\\sqrt{\\mu_0 \\epsilon_0}}$ 时的自由空间波数。当核函数在网格步长 $h$ 上足够光滑时，远区近似是准确的，而对于距离小于近区厚度 $t_{\\mathrm{nz}}$ 的相互作用，则进行精确处理，以控制奇异性和快速变化。\n\n任务1（从第一性原理推导）：从 $G(r) = \\dfrac{e^{-j k r}}{4 \\pi r}$ 出发，要求 $G$ 在一个网格步长 $h$ 上的局部相对变化满足 $\\left|\\dfrac{G'(r)}{G(r)}\\right| h \\le \\varepsilon$，其中 $\\varepsilon \\in (0,1)$ 是一个无量纲容差，且 $G'(r) = \\dfrac{d G}{d r}$。推导出一个阈值距离 $r_\\varepsilon$ 的显式表达式，在该距离上该边界变为紧致。然后，为不等式因 $\\left(\\dfrac{\\varepsilon}{h}\\right)^2 \\le k^2$ 而无法满足的情况，指定一个鲁棒的备用方案。\n\n任务2（复合自适应规则）：引入局部电尺寸 $k a$（其中 $a$ 是特征局部网格单元尺寸），以考虑单元覆盖范围内的相位变化。进一步引入基于相邻网格面元之间二面角 $\\phi$（单位为度）的尖锐边缘校正，其中 $\\phi = 180^\\circ$ 表示局部平坦，较小的 $\\phi$ 表示更尖锐的边缘。定义边缘锐度因子 $s(\\phi) = \\sin\\!\\left(\\dfrac{\\pi - \\phi_{\\mathrm{rad}}}{2}\\right)$，其中 $\\phi_{\\mathrm{rad}}$ 是以弧度为单位的角度。提出以下复合自适应近区厚度规则：\n$$\nt_{\\mathrm{nz}}(k, a, h, \\varepsilon, \\phi; \\alpha, \\beta) \\;=\\; \\min\\!\\Bigg(3 a,\\; r_\\varepsilon + \\alpha\\, a\\, \\max\\!\\left(0,\\, \\frac{k a}{2 \\varepsilon} - 1\\right) + \\beta\\, a\\, s(\\phi)\\Bigg),\n$$\n其中 $\\alpha$ 和 $\\beta$ 是无量纲校准参数，$r_\\varepsilon$ 是任务1中得到的阈值距离，上限 $3 a$ 防止在网格步长过粗时近区的无界增长。\n\n任务3（使用尖锐边缘测试问题进行校准）：使用三个校准问题，通过最小二乘法校准 $\\alpha$ 和 $\\beta$，这些问题提供了以米为单位的近区厚度真值 $t_{\\mathrm{gt}}$。使用 $k = \\dfrac{2 \\pi f}{c}$，其中 $c = \\dfrac{1}{\\sqrt{\\mu_0 \\epsilon_0}}$，$\\mu_0 = 4 \\pi \\times 10^{-7}\\ \\mathrm{H/m}$，且 $\\epsilon_0 \\approx 8.854187817 \\times 10^{-12}\\ \\mathrm{F/m}$。\n\n校准问题（角度单位为度，距离单位为米，频率单位为赫兹，答案单位为米）：\n- 问题 C1: $f = 1\\ \\mathrm{GHz}$，$a = 0.05\\ \\mathrm{m}$，$h = 0.01\\ \\mathrm{m}$，$\\phi = 60^\\circ$，$\\varepsilon = 0.3$，$t_{\\mathrm{gt}} = 0.102438\\ \\mathrm{m}$。\n- 问题 C2: $f = 0.5\\ \\mathrm{GHz}$，$a = 0.02\\ \\mathrm{m}$，$h = 0.005\\ \\mathrm{m}$，$\\phi = 120^\\circ$，$\\varepsilon = 0.2$，$t_{\\mathrm{gt}} = 0.028405\\ \\mathrm{m}$。\n- 问题 C3: $f = 2\\ \\mathrm{GHz}$，$a = 0.02\\ \\mathrm{m}$，$h = 0.01\\ \\mathrm{m}$，$\\phi = 45^\\circ$，$\\varepsilon = 0.2$，$t_{\\mathrm{gt}} = 0.048660\\ \\mathrm{m}$。\n\n在所有校准问题中，根据给定的 $f$ 计算 $k$。对于 $r_\\varepsilon$，使用任务1的推导，如果 $\\left(\\dfrac{\\varepsilon}{h}\\right)^2 \\le k^2$，则使用备用方案 $r_\\varepsilon = a$。通过从 $t_{\\mathrm{gt}}$ 中减去 $r_\\varepsilon$，并对两个特征 $a \\max\\!\\left(0, \\dfrac{k a}{2 \\varepsilon} - 1\\right)$ 和 $a s(\\phi)$ 进行回归来建立线性系统，以估计 $\\alpha$ 和 $\\beta$。\n\n任务4（在测试集上进行预测）：使用校准后的 $(\\alpha, \\beta)$，为以下三个测试问题中的每一个计算近区整数层数 $L = \\left\\lceil \\dfrac{t_{\\mathrm{nz}}}{h} \\right\\rceil$。角度单位为度，距离单位为米，频率单位为赫兹，$t_{\\mathrm{nz}}$ 的要求输出单位是米，但程序必须输出整数层数。\n\n测试集：\n- 测试 T1（远区边界条件不满足，光滑面）：$f = 3\\ \\mathrm{GHz}$，$a = 0.04\\ \\mathrm{m}$，$h = 0.008\\ \\mathrm{m}$，$\\phi = 180^\\circ$，$\\varepsilon = 0.25$。\n- 测试 T2（小电尺寸，中等锐度边缘）：$f = 0.3\\ \\mathrm{GHz}$，$a = 0.005\\ \\mathrm{m}$，$h = 0.002\\ \\mathrm{m}$，$\\phi = 150^\\circ$，$\\varepsilon = 0.3$。\n- 测试 T3（中等电尺寸，直角边缘）：$f = 1.5\\ \\mathrm{GHz}$，$a = 0.03\\ \\mathrm{m}$，$h = 0.006\\ \\mathrm{m}$，$\\phi = 90^\\circ$，$\\varepsilon = 0.25$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $\\left[L_{\\mathrm{T1}}, L_{\\mathrm{T2}}, L_{\\mathrm{T3}}\\right]$，分别对应于测试 T1、T2 和 T3。例如，形如 $\\left[15,4,12\\right]$ 的输出是可以接受的。",
            "solution": "该问题被验证为具有科学依据、适定且客观。它包含一套完整且一致的数据和指令，用于推导、校准和应用自适应积分方法 (AIM) 中的近区厚度模型。我们将通过依次解决每个任务来进行求解。\n\n### 任务1：阈值距离 $r_\\varepsilon$ 的推导\n\n分析从自由空间标量格林函数开始，其表达式为：\n$$\nG(r) = \\frac{e^{-j k r}}{4 \\pi r}\n$$\n其中 $r = \\|\\mathbf{r}\\|$ 是距离，$j$ 是虚数单位，$k$ 是波数。我们的任务是基于 $G(r)$ 的局部相对变化找到一个阈值距离 $r_\\varepsilon$。第一步是计算 $G(r)$ 相对于 $r$ 的导数：\n$$\nG'(r) = \\frac{d}{dr} G(r) = \\frac{d}{dr} \\left( \\frac{e^{-jkr}}{4\\pi r} \\right) = \\frac{1}{4\\pi} \\left( \\frac{-jke^{-jkr} \\cdot r - e^{-jkr} \\cdot 1}{r^2} \\right) = \\frac{e^{-jkr}}{4\\pi r^2}(-jkr - 1)\n$$\n相对变化率是比率 $\\frac{G'(r)}{G(r)}$：\n$$\n\\frac{G'(r)}{G(r)} = \\frac{\\frac{e^{-jkr}}{4\\pi r^2}(-jkr - 1)}{\\frac{e^{-jkr}}{4\\pi r}} = \\frac{-jkr - 1}{r} = -jk - \\frac{1}{r}\n$$\n这个复数的模是：\n$$\n\\left| \\frac{G'(r)}{G(r)} \\right| = \\left| -jk - \\frac{1}{r} \\right| = \\sqrt{(-k)^2 + \\left(-\\frac{1}{r}\\right)^2} = \\sqrt{k^2 + \\frac{1}{r^2}}\n$$\n远区近似的条件是，在一个网格步长 $h$ 上的相对变化受容差 $\\varepsilon$ 的限制：\n$$\n\\left| \\frac{G'(r)}{G(r)} \\right| h \\le \\varepsilon\n$$\n阈值距离 $r_\\varepsilon$ 定义在边界紧致处，即等式成立：\n$$\nh \\sqrt{k^2 + \\frac{1}{r_\\varepsilon^2}} = \\varepsilon\n$$\n我们求解该方程以得到 $r_\\varepsilon$：\n$$\n\\sqrt{k^2 + \\frac{1}{r_\\varepsilon^2}} = \\frac{\\varepsilon}{h}\n$$\n$$\nk^2 + \\frac{1}{r_\\varepsilon^2} = \\left(\\frac{\\varepsilon}{h}\\right)^2\n$$\n$$\n\\frac{1}{r_\\varepsilon^2} = \\left(\\frac{\\varepsilon}{h}\\right)^2 - k^2\n$$\n$$\nr_\\varepsilon^2 = \\frac{1}{\\left(\\frac{\\varepsilon}{h}\\right)^2 - k^2}\n$$\n对距离取正平方根，得到 $r_\\varepsilon$ 的显式表达式：\n$$\nr_\\varepsilon = \\frac{1}{\\sqrt{\\left(\\frac{\\varepsilon}{h}\\right)^2 - k^2}}\n$$\n为使 $r_\\varepsilon$ 是一个实正数，分母中平方根下的量必须为正，这意味着条件 $\\left(\\frac{\\varepsilon}{h}\\right)^2 - k^2 > 0$，或 $\\left(\\frac{\\varepsilon}{h}\\right)^2 > k^2$。问题为该不等式不满足的情况，即当 $\\left(\\frac{\\varepsilon}{h}\\right)^2 \\le k^2$ 时，指定了一个鲁棒的备用方案。在这种情况下，格林函数变化过快，以至于网格即使在渐近情况下也无法分辨，阈值距离被设置为特征单元尺寸 $a$。因此，$r_\\varepsilon$ 的完整规则是：\n$$\nr_\\varepsilon = \\begin{cases} \\dfrac{1}{\\sqrt{\\left(\\frac{\\varepsilon}{h}\\right)^2 - k^2}}  \\text{若 } \\left(\\frac{\\varepsilon}{h}\\right)^2 > k^2 \\\\ a  \\text{若 } \\left(\\frac{\\varepsilon}{h}\\right)^2 \\le k^2 \\end{cases}\n$$\n\n### 任务2和3：模型校准\n\n复合自适应近区厚度规则如下：\n$$\nt_{\\mathrm{nz}}(k, a, h, \\varepsilon, \\phi; \\alpha, \\beta) \\;=\\; \\min\\!\\Bigg(3 a,\\; r_\\varepsilon + \\alpha\\, a\\, \\max\\!\\left(0,\\, \\frac{k a}{2 \\varepsilon} - 1\\right) + \\beta\\, a\\, s(\\phi)\\Bigg)\n$$\n其中 $s(\\phi) = \\sin\\!\\left(\\frac{\\pi - \\phi_{\\mathrm{rad}}}{2}\\right)$。参数 $\\alpha$ 和 $\\beta$ 将使用最小二乘法对三个提供的真值问题（C1、C2、C3）进行拟合来校准。通过分离包含 $\\alpha$ 和 $\\beta$ 的项来构建回归模型：\n$$\nt_{\\mathrm{gt}} - r_\\varepsilon \\approx \\alpha\\, \\underbrace{a\\, \\max\\!\\left(0,\\, \\frac{k a}{2 \\varepsilon} - 1\\right)}_{x_1} + \\beta\\, \\underbrace{a\\, s(\\phi)}_{x_2}\n$$\n这定义了一个线性系统 $\\mathbf{y} = \\mathbf{Xp}$，其中 $\\mathbf{p} = [\\alpha, \\beta]^T$。我们为三个校准问题计算向量 $\\mathbf{y}$ 和矩阵 $\\mathbf{X}$。使用的常数是 $\\mu_0 = 4 \\pi \\times 10^{-7}\\ \\mathrm{H/m}$ 和 $\\epsilon_0 = 8.854187817 \\times 10^{-12}\\ \\mathrm{F/m}$，由此可得光速 $c = (\\mu_0\\epsilon_0)^{-1/2} \\approx 299792458.02\\ \\mathrm{m/s}$。\n\n**校准问题 C1：**\n已知：$f = 1\\ \\mathrm{GHz}$，$a = 0.05\\ \\mathrm{m}$，$h = 0.01\\ \\mathrm{m}$，$\\phi = 60^\\circ$，$\\varepsilon = 0.3$，$t_{\\mathrm{gt}} = 0.102438\\ \\mathrm{m}$。\n计算：\n$k = \\frac{2\\pi f}{c} \\approx 20.958\\ \\mathrm{rad/m}$。\n检查 $r_\\varepsilon$：$(\\frac{\\varepsilon}{h})^2 = (\\frac{0.3}{0.01})^2 = 900$；$k^2 \\approx 439.257$。由于 $900 > 439.257$，我们使用推导出的公式：$r_{\\varepsilon,1} \\approx 0.046588\\ \\mathrm{m}$。\n特征 $x_{1,1} = 0.05 \\cdot \\max(0, \\frac{20.958 \\cdot 0.05}{2 \\cdot 0.3} - 1) \\approx 0.037327\\ \\mathrm{m}$。\n特征 $x_{2,1} = 0.05 \\cdot \\sin(\\frac{\\pi - \\pi/3}{2}) \\approx 0.043301\\ \\mathrm{m}$。\n目标 $y_1 = t_{\\mathrm{gt},1} - r_{\\varepsilon,1} = 0.102438 - 0.046588 = 0.055850\\ \\mathrm{m}$。\n\n**校准问题 C2：**\n已知：$f = 0.5\\ \\mathrm{GHz}$，$a = 0.02\\ \\mathrm{m}$，$h = 0.005\\ \\mathrm{m}$，$\\phi = 120^\\circ$，$\\varepsilon = 0.2$，$t_{\\mathrm{gt}} = 0.028405\\ \\mathrm{m}$。\n计算：\n$k = \\frac{2\\pi f}{c} \\approx 10.479\\ \\mathrm{rad/m}$。\n检查 $r_\\varepsilon$：$(\\frac{\\varepsilon}{h})^2 = (\\frac{0.2}{0.005})^2 = 1600$；$k^2 \\approx 109.814$。由于 $1600 > 109.814$，我们使用公式：$r_{\\varepsilon,2} \\approx 0.025905\\ \\mathrm{m}$。\n特征 $x_{1,2} = 0.02 \\cdot \\max(0, \\frac{10.479 \\cdot 0.02}{2 \\cdot 0.2} - 1) = 0\\ \\mathrm{m}$。\n特征 $x_{2,2} = 0.02 \\cdot \\sin(\\frac{\\pi - 2\\pi/3}{2}) = 0.01\\ \\mathrm{m}$。\n目标 $y_2 = t_{\\mathrm{gt},2} - r_{\\varepsilon,2} = 0.028405 - 0.025905 = 0.002500\\ \\mathrm{m}$。\n\n**校准问题 C3：**\n已知：$f = 2\\ \\mathrm{GHz}$，$a = 0.02\\ \\mathrm{m}$，$h = 0.01\\ \\mathrm{m}$，$\\phi = 45^\\circ$，$\\varepsilon = 0.2$，$t_{\\mathrm{gt}} = 0.048660\\ \\mathrm{m}$。\n计算：\n$k = \\frac{2\\pi f}{c} \\approx 41.917\\ \\mathrm{rad/m}$。\n检查 $r_\\varepsilon$：$(\\frac{\\varepsilon}{h})^2 = (\\frac{0.2}{0.01})^2 = 400$；$k^2 \\approx 1757.027$。由于 $400 \\le 1757.027$，我们使用备用方案：$r_{\\varepsilon,3} = a = 0.02\\ \\mathrm{m}$。\n特征 $x_{1,3} = 0.02 \\cdot \\max(0, \\frac{41.917 \\cdot 0.02}{2 \\cdot 0.2} - 1) \\approx 0.021917\\ \\mathrm{m}$。\n特征 $x_{2,3} = 0.02 \\cdot \\sin(\\frac{\\pi - \\pi/4}{2}) \\approx 0.018478\\ \\mathrm{m}$。\n目标 $y_3 = t_{\\mathrm{gt},3} - r_{\\varepsilon,3} = 0.048660 - 0.02 = 0.028660\\ \\mathrm{m}$。\n\n线性系统为：\n$$\n\\begin{pmatrix} 0.055850 \\\\ 0.002500 \\\\ 0.028660 \\end{pmatrix} = \\begin{pmatrix} 0.037327  0.043301 \\\\ 0.0  0.01 \\\\ 0.021917  0.018478 \\end{pmatrix} \\begin{pmatrix} \\alpha \\\\ \\beta \\end{pmatrix}\n$$\n使用线性最小二乘法求解这个超定系统，得到校准后的参数：\n$$\n\\alpha \\approx 1.20002 \\quad \\text{和} \\quad \\beta \\approx 0.24997\n$$\n在后续计算中，我们将使用这些拟合值。\n\n### 任务4：在测试集上进行预测\n\n现在我们应用校准后的模型来计算三个测试问题的近区整数层数 $L = \\lceil \\frac{t_{\\mathrm{nz}}}{h} \\rceil$。\n\n**测试 T1：**\n已知：$f = 3\\ \\mathrm{GHz}$，$a = 0.04\\ \\mathrm{m}$，$h = 0.008\\ \\mathrm{m}$，$\\phi = 180^\\circ$，$\\varepsilon = 0.25$。\n计算：\n$k \\approx 62.875\\ \\mathrm{rad/m}$。\n检查 $r_\\varepsilon$：$(\\frac{\\varepsilon}{h})^2 \\approx 976.56$；$k^2 \\approx 3953.30$。由于 $(\\frac{\\varepsilon}{h})^2 \\le k^2$，我们使用备用方案 $r_\\varepsilon = a = 0.04\\ \\mathrm{m}$。\n$\\alpha$ 项：$1.20002 \\cdot 0.04 \\cdot \\max(0, \\frac{62.875 \\cdot 0.04}{2 \\cdot 0.25} - 1) \\approx 0.19345\\ \\mathrm{m}$。\n$\\beta$ 项：$0.24997 \\cdot 0.04 \\cdot \\sin(\\frac{\\pi - \\pi}{2}) = 0\\ \\mathrm{m}$。\n未加帽的厚度：$t'_{\\mathrm{nz}} = 0.04 + 0.19345 + 0 = 0.23345\\ \\mathrm{m}$。\n加帽后的厚度：$t_{\\mathrm{nz}} = \\min(3a, t'_{\\mathrm{nz}}) = \\min(0.12, 0.23345) = 0.12\\ \\mathrm{m}$。\n层数：$L_{\\mathrm{T1}} = \\lceil \\frac{0.12}{0.008} \\rceil = \\lceil 15 \\rceil = 15$。\n\n**测试 T2：**\n已知：$f = 0.3\\ \\mathrm{GHz}$，$a = 0.005\\ \\mathrm{m}$，$h = 0.002\\ \\mathrm{m}$，$\\phi = 150^\\circ$，$\\varepsilon = 0.3$。\n计算：\n$k \\approx 6.288\\ \\mathrm{rad/m}$。\n检查 $r_\\varepsilon$：$(\\frac{\\varepsilon}{h})^2 = 22500$；$k^2 \\approx 39.53$。由于 $(\\frac{\\varepsilon}{h})^2 > k^2$，我们使用公式 $r_\\varepsilon \\approx 0.006673\\ \\mathrm{m}$。\n$\\alpha$ 项：$1.20002 \\cdot 0.005 \\cdot \\max(0, \\frac{6.288 \\cdot 0.005}{2 \\cdot 0.3} - 1) = 0\\ \\mathrm{m}$。\n$\\beta$ 项：$0.24997 \\cdot 0.005 \\cdot \\sin(\\frac{\\pi - 5\\pi/6}{2}) \\approx 0.000323\\ \\mathrm{m}$。\n未加帽的厚度：$t'_{\\mathrm{nz}} = 0.006673 + 0 + 0.000323 = 0.006996\\ \\mathrm{m}$。\n加帽后的厚度：$t_{\\mathrm{nz}} = \\min(3a, t'_{\\mathrm{nz}}) = \\min(0.015, 0.006996) = 0.006996\\ \\mathrm{m}$。\n层数：$L_{\\mathrm{T2}} = \\lceil \\frac{0.006996}{0.002} \\rceil = \\lceil 3.498 \\rceil = 4$。\n\n**测试 T3：**\n已知：$f = 1.5\\ \\mathrm{GHz}$，$a = 0.03\\ \\mathrm{m}$，$h = 0.006\\ \\mathrm{m}$，$\\phi = 90^\\circ$，$\\varepsilon = 0.25$。\n计算：\n$k \\approx 31.438\\ \\mathrm{rad/m}$。\n检查 $r_\\varepsilon$：$(\\frac{\\varepsilon}{h})^2 \\approx 1736.11$；$k^2 \\approx 988.27$。由于 $(\\frac{\\varepsilon}{h})^2 > k^2$，我们使用公式 $r_\\varepsilon \\approx 0.036567\\ \\mathrm{m}$。\n$\\alpha$ 项：$1.20002 \\cdot 0.03 \\cdot \\max(0, \\frac{31.438 \\cdot 0.03}{2 \\cdot 0.25} - 1) \\approx 0.031906\\ \\mathrm{m}$。\n$\\beta$ 项：$0.24997 \\cdot 0.03 \\cdot \\sin(\\frac{\\pi - \\pi/2}{2}) \\approx 0.005303\\ \\mathrm{m}$。\n未加帽的厚度：$t'_{\\mathrm{nz}} = 0.036567 + 0.031906 + 0.005303 = 0.073776\\ \\mathrm{m}$。\n加帽后的厚度：$t_{\\mathrm{nz}} = \\min(3a, t'_{\\mathrm{nz}}) = \\min(0.09, 0.073776) = 0.073776\\ \\mathrm{m}$。\n层数：$L_{\\mathrm{T3}} = \\lceil \\frac{0.073776}{0.006} \\rceil = \\lceil 12.296 \\rceil = 13$。\n\n整数层数的最终结果是 $L_{\\mathrm{T1}} = 15$，$L_{\\mathrm{T2}} = 4$ 和 $L_{\\mathrm{T3}} = 13$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the multi-part problem related to the Adaptive Integral Method (AIM).\n    1. Defines physical constants and helper functions.\n    2. Calibrates parameters alpha and beta using least squares on calibration data.\n    3. Applies the calibrated model to a test suite to compute near-zone layer counts.\n    \"\"\"\n    \n    # Constants\n    MU_0 = 4 * np.pi * 1e-7  # Permeability of free space (H/m)\n    EPSILON_0 = 8.854187817e-12  # Permittivity of free space (F/m)\n    C = 1 / np.sqrt(MU_0 * EPSILON_0)  # Speed of light in vacuum (m/s)\n\n    def calculate_k(f):\n        \"\"\"Calculates the wavenumber k.\"\"\"\n        return 2 * np.pi * f / C\n\n    def calculate_r_epsilon(k, h, a, epsilon):\n        \"\"\"Calculates the threshold distance r_epsilon with its fallback rule.\"\"\"\n        eps_h_sq = (epsilon / h)**2\n        k_sq = k**2\n        if eps_h_sq > k_sq:\n            return 1 / np.sqrt(eps_h_sq - k_sq)\n        else:\n            return a\n\n    def calculate_s_phi(phi_deg):\n        \"\"\"Calculates the edge sharpness factor s(phi).\"\"\"\n        phi_rad = np.deg2rad(phi_deg)\n        return np.sin((np.pi - phi_rad) / 2)\n\n    # --- Task 3: Calibration ---\n    calibration_problems = [\n        # (f, a, h, phi, epsilon, t_gt)\n        (1e9, 0.05, 0.01, 60, 0.3, 0.102438),  # C1\n        (0.5e9, 0.02, 0.005, 120, 0.2, 0.028405), # C2 (Corrected value)\n        (2e9, 0.02, 0.01, 45, 0.2, 0.048660),   # C3\n    ]\n\n    X_cal = []\n    y_cal = []\n\n    for f, a, h, phi_deg, epsilon, t_gt in calibration_problems:\n        k = calculate_k(f)\n        r_eps = calculate_r_epsilon(k, h, a, epsilon)\n        \n        # Feature 1 for alpha\n        x1_term = a * max(0, (k * a) / (2 * epsilon) - 1)\n        \n        # Feature 2 for beta\n        s_phi = calculate_s_phi(phi_deg)\n        x2_term = a * s_phi\n        \n        X_cal.append([x1_term, x2_term])\n        y_cal.append(t_gt - r_eps)\n\n    X_matrix = np.array(X_cal)\n    y_vector = np.array(y_cal)\n\n    # Perform least squares to find alpha and beta\n    params, _, _, _ = np.linalg.lstsq(X_matrix, y_vector, rcond=None)\n    alpha_cal, beta_cal = params\n\n    # --- Task 4: Prediction on Test Suite ---\n    test_suite = [\n        # (f, a, h, phi, epsilon)\n        (3e9, 0.04, 0.008, 180, 0.25),  # T1\n        (0.3e9, 0.005, 0.002, 150, 0.3),  # T2\n        (1.5e9, 0.03, 0.006, 90, 0.25), # T3\n    ]\n\n    results = []\n    \n    def calculate_t_nz(k, a, h, phi_deg, epsilon, alpha, beta):\n        \"\"\"Calculates the composite near-zone thickness t_nz.\"\"\"\n        r_eps = calculate_r_epsilon(k, h, a, epsilon)\n        \n        term_alpha = alpha * a * max(0, (k * a) / (2 * epsilon) - 1)\n        \n        s_phi = calculate_s_phi(phi_deg)\n        term_beta = beta * a * s_phi\n        \n        uncapped_t_nz = r_eps + term_alpha + term_beta\n        \n        return min(3 * a, uncapped_t_nz)\n\n    for f, a, h, phi_deg, epsilon in test_suite:\n        k = calculate_k(f)\n        t_nz = calculate_t_nz(k, a, h, phi_deg, epsilon, alpha_cal, beta_cal)\n        \n        # Calculate integer layer count L\n        L = int(np.ceil(t_nz / h))\n        results.append(L)\n\n    # Final output format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在设计了 AIM 算法的核心（如近区划分）之后，一个关键的工程步骤是分析其资源需求，其中内存占用是限制大规模仿真的首要因素。本练习将引导您剖析 AIM 实现的总内存占用，将其分解为几个关键部分：存储谱域格林函数的 FFT 网格、用于基函数与网格之间映射的投影模板，以及存储直接计算的近场相互作用矩阵。通过这个过程，您将理解这些组件的渐进行为和实际影响，从而能够在设计解决方案时做出更明智的权衡。",
            "id": "3288298",
            "problem": "考虑一个用于电场积分方程 (EFIE) 的三维快速傅里叶变换 (FFT) 加速的自适应积分法 (AIM) 实现，该实现采用矩量法 (MoM) 离散化，并使用 $N$ 个 Rao–Wilton–Glisson 基函数。未知量分布在一个尺寸为 $L_{x}$、$L_{y}$ 和 $L_{z}$ 的矩形边界框内，在自由空间中以频率 $f$ 激励。AIM 采用一个均匀的笛卡尔 FFT 网格，该网格通过对波长 $\\lambda$ 强制执行奈奎斯特-香农采样条件来自适应地选择，并在三个坐标方向上具有各向异性的过采样因子 $s_{x}$、$s_{y}$ 和 $s_{z}$。具体来说，网格间距为 $h_{i} = \\lambda / (2 s_{i})$，其中 $i \\in \\{x,y,z\\}$，并且每个方向上的网格大小都进行填充以减轻循环卷积的影响，即 $N_{i} = \\gamma_{i} \\,\\lceil L_{i} / h_{i} \\rceil$，其中填充因子 $\\gamma_{i} \\geq 1$。AIM 存储了所有 FFT 网格波数下的谱域并矢格林函数 $\\hat{G}(\\boldsymbol{\\kappa})$，每个网格点有 $d_{G}$ 个唯一分量，每个分量都存储为一个复数双精度数。\n\n除了 $\\hat{G}$，AIM 还存储了投影模板，用于将基函数映射到网格，并将网格场映射回测试函数。假设采用三线性投影，每个基函数的每次投影有 $n_{s}$ 个模板点，每个模板点存储一个权重（一个实数双精度数）和三个整数网格索引。源到网格和网格到测试的模板都分开存储。最后，AIM 将近场相互作用存储为一个唯一的稀疏列表，其中包含在指定几何邻近范围内的基函数对；假设每个未知量平均有 $n_{\\mathrm{nf}}$ 个近邻，并且存储为每个唯一对保留一个复耦合值以及标识该对的两个整数索引。\n\n使用以下物理上一致的参数：\n- 光速 $c = 3.0 \\times 10^{8} \\,\\text{m/s}$，工作频率 $f = 3.0 \\times 10^{9} \\,\\text{Hz}$，因此波长 $\\lambda = c/f$。\n- 边界框尺寸 $L_{x} = 0.47 \\,\\text{m}$，$L_{y} = 0.36 \\,\\text{m}$，$L_{z} = 0.22 \\,\\text{m}$。\n- 过采样因子 $s_{x} = 1.4$，$s_{y} = 1.25$，$s_{z} = 1.05$，以及填充因子 $\\gamma_{x} = \\gamma_{y} = \\gamma_{z} = 2$。\n- 并矢格林函数存储：每个网格点有 $d_{G} = 6$ 个唯一分量，每个分量存储为一个复双精度数（$16$ 字节）。\n- 投影模板：每次投影每个基函数有 $n_{s} = 8$ 个点；每个模板点存储一个实双精度数（$8$ 字节）和三个 $4$ 字节整数（总计 $12$ 字节）用于网格索引；源到网格和网格到测试的模板都进行存储。\n- 近场：每个未知量的平均近邻数 $n_{\\mathrm{nf}} = 28$；每个唯一对的存储包括一个复双精度数（$16$ 字节）和两个 $4$ 字节整数（总计 $8$ 字节）。\n- 未知量数量 $N = 450{,}000$。\n\n从 $h_{i}$ 的采样要求和填充后网格大小 $N_{i}$ 的定义出发，推导每个内存分量对 $N$ 和自适应网格参数的渐近依赖关系，然后计算实际的总内存占用\n$$\nM_{\\text{total}} = M_{\\hat{G}} + M_{\\text{stencils}} + M_{\\text{near-field}}\n$$\n以兆字节（megabytes）为单位，其中一兆字节定义为 $10^{6}$ 字节。将您的最终数值答案四舍五入到四位有效数字，并以兆字节表示。只提供 $M_{\\text{total}}$ 的单个数值作为最终答案。清晰地陈述您的推理和中间步骤，论证自适应网格选择对渐近和实际内存使用的影响。",
            "solution": "该问题陈述经评估具有科学依据、适定、客观且内部一致。它提供了计算指定自适应积分法 (AIM) 实现总内存占用所需的所有必要参数和定义。这些参数在物理上是现实的，所述方法与计算电磁学的标准实践一致。因此，该问题是有效的，我们继续进行求解。\n\n总内存占用 $M_{\\text{total}}$ 是谱域格林函数所需内存 $M_{\\hat{G}}$、投影模板所需内存 $M_{\\text{stencils}}$ 和近场阻抗矩阵所需内存 $M_{\\text{near-field}}$ 的总和。\n$$\nM_{\\text{total}} = M_{\\hat{G}} + M_{\\text{stencils}} + M_{\\text{near-field}}\n$$\n\n首先，我们分析每个内存分量对未知量数量 $N$ 的渐近依赖关系。对于表面网格，未知量数量 $N$ 与表面积除以平均单元尺寸的平方成正比。如果物体的特征尺寸为 $L_{\\text{obj}}$，则其表面积按 $L_{\\text{obj}}^2$ 比例变化。这意味着边界框的线性维度 $L_i$ 按 $L_{\\text{obj}}$ 比例变化，而 $L_{\\text{obj}}$ 又按 $\\sqrt{N}$ 比例变化。网格间距 $h_i$ 与波长 $\\lambda$ 成正比，对于固定频率，$\\lambda$ 是一个常数。\n因此，每个维度上的 FFT 网格点数 $N_i$ 按以下比例变化：\n$$\nN_i = \\gamma_i \\lceil L_i / h_i \\rceil \\propto L_i \\propto \\sqrt{N}\n$$\nFFT 网格中的总点数是 $N_g = N_x N_y N_z$。其缩放关系为：\n$$\nN_g \\propto (\\sqrt{N})^3 = N^{3/2}\n$$\n\n现在可以渐近地分析每个分量的内存：\n1.  $M_{\\hat{G}}$：格林函数的内存与网格总点数 $N_g$ 成正比。因此，渐近缩放关系为 $M_{\\hat{G}} \\propto O(N^{3/2})$。\n2.  $M_{\\text{stencils}}$：投影模板的内存与基函数数量 $N$ 成正比。因此，渐近缩放关系为 $M_{\\text{stencils}} \\propto O(N)$。\n3.  $M_{\\text{near-field}}$：假设每个未知量的平均近邻数 $n_{\\mathrm{nf}}$ 是常数，近场相互作用的内存也与基函数数量 $N$ 成正比。因此，渐近缩放关系为 $M_{\\text{near-field}} \\propto O(N)$。\n\n对于大的 $N$，总内存 $M_{\\text{total}}$ 由格林函数存储的 $O(N^{3/2})$ 项主导，这是 FFT 加速方法的一个特征。\n\n接下来，我们使用给定参数对每个内存分量进行实际计算。\n\n首先，我们计算波长 $\\lambda$：\n$$\n\\lambda = \\frac{c}{f} = \\frac{3.0 \\times 10^{8} \\,\\text{m/s}}{3.0 \\times 10^{9} \\,\\text{Hz}} = 0.1 \\,\\text{m}\n$$\n\n接下来，我们使用过采样因子 $s_i$ 确定 AIM 网格间距 $h_i$：\n$$\nh_x = \\frac{\\lambda}{2 s_x} = \\frac{0.1}{2 \\times 1.4} = \\frac{0.1}{2.8} \\,\\text{m} \\\\\nh_y = \\frac{\\lambda}{2 s_y} = \\frac{0.1}{2 \\times 1.25} = \\frac{0.1}{2.5} = 0.04 \\,\\text{m} \\\\\nh_z = \\frac{\\lambda}{2 s_z} = \\frac{0.1}{2 \\times 1.05} = \\frac{0.1}{2.1} \\,\\text{m}\n$$\n\n现在，我们使用边界框尺寸 $L_i$ 和填充因子 $\\gamma_i = 2$ 计算填充后的 FFT 网格维度 $N_i$：\n$$\nN_x = \\gamma_x \\left\\lceil \\frac{L_x}{h_x} \\right\\rceil = 2 \\left\\lceil \\frac{0.47}{0.1 / 2.8} \\right\\rceil = 2 \\lceil 0.47 \\times 28 \\rceil = 2 \\lceil 13.16 \\rceil = 2 \\times 14 = 28 \\\\\nN_y = \\gamma_y \\left\\lceil \\frac{L_y}{h_y} \\right\\rceil = 2 \\left\\lceil \\frac{0.36}{0.04} \\right\\rceil = 2 \\lceil 9 \\rceil = 2 \\times 9 = 18 \\\\\nN_z = \\gamma_z \\left\\lceil \\frac{L_z}{h_z} \\right\\rceil = 2 \\left\\lceil \\frac{0.22}{0.1 / 2.1} \\right\\rceil = 2 \\lceil 0.22 \\times 21 \\rceil = 2 \\lceil 4.62 \\rceil = 2 \\times 5 = 10\n$$\nFFT 网格中的总点数是：\n$$\nN_g = N_x \\times N_y \\times N_z = 28 \\times 18 \\times 10 = 5040\n$$\n\n有了这些中间值，我们就可以计算每个分量的内存。\n\n1.  谱域格林函数的内存 $M_{\\hat{G}}$：\n存储包括每个网格点 $d_G = 6$ 个唯一的复双精度分量。每个复双精度数是 $16$ 字节。\n$$\nM_{\\hat{G}} = N_g \\times d_G \\times (16 \\,\\text{bytes/component}) = 5040 \\times 6 \\times 16 = 483,840 \\,\\text{bytes}\n$$\n\n2.  投影模板的内存 $M_{\\text{stencils}}$：\n对于所有 $N = 450,000$ 个基函数，源到网格和网格到测试的模板都进行存储。每个模板有 $n_s = 8$ 个点。每个点存储一个实双精度数（$8$ 字节）和三个 $4$ 字节整数（$3 \\times 4 = 12$ 字节），每个模板点总共 $8+12=20$ 字节。\n$$\nM_{\\text{stencils}} = 2 \\times N \\times n_s \\times (20 \\,\\text{bytes/point}) = 2 \\times 450,000 \\times 8 \\times 20 = 144,000,000 \\,\\text{bytes}\n$$\n\n3.  近场相互作用的内存 $M_{\\text{near-field}}$：\n$N=450,000$ 个未知量中的每一个平均有 $n_{\\mathrm{nf}}=28$ 个近邻。相互作用以唯一对的形式存储。唯一对的数量是 $\\frac{N \\times n_{\\mathrm{nf}}}{2}$。每对的存储包括一个复双精度数（$16$ 字节）和两个用于索引的 $4$ 字节整数（$2 \\times 4 = 8$ 字节），每对总共 $16+8=24$ 字节。\n$$\nM_{\\text{near-field}} = \\frac{N \\times n_{\\mathrm{nf}}}{2} \\times (24 \\,\\text{bytes/pair}) = \\frac{450,000 \\times 28}{2} \\times 24 = 6,300,000 \\times 24 = 151,200,000 \\,\\text{bytes}\n$$\n\n最后，以字节为单位的总内存占用是这些分量的总和：\n$$\nM_{\\text{total}} = M_{\\hat{G}} + M_{\\text{stencils}} + M_{\\text{near-field}} = 483,840 + 144,000,000 + 151,200,000 = 295,683,840 \\,\\text{bytes}\n$$\n\n使用定义 $1 \\,\\text{MB} = 10^6 \\,\\text{bytes}$，转换为兆字节：\n$$\nM_{\\text{total}} = \\frac{295,683,840}{10^6} \\,\\text{MB} = 295.68384 \\,\\text{MB}\n$$\n将结果四舍五入到四位有效数字，得到 $295.7 \\,\\text{MB}$。",
            "answer": "$$ \\boxed{295.7} $$"
        },
        {
            "introduction": "在评估了算法的内存成本之后，我们自然会关注其计算性能——即运行速度。本练习将介绍一种先进的性能建模方法，即屋顶线模型 (roofline model)，用于预测 AIM 在现代计算硬件（如 CPU 和 GPU）上的吞吐量。您将学习如何通过分析计算核心（近场矩阵向量乘积和远场 FFT）的算术强度与内存带宽之间的关系来预测执行时间，并探索如何通过计算与通信重叠等策略来优化异构系统上的性能。",
            "id": "3288252",
            "problem": "您的任务是为计算电磁学中用于加速边界积分方程求解器的自适应积分方法 (AIM) 设计并实现一个定量性能模型。在 AIM 中，阻抗矩阵被分解为一个近区部分和一个远区部分。近区部分表示为 $\\mathbf{Z}_{\\text{near}}$，以稀疏矩阵向量乘积的形式应用；远区部分则通过在规则网格上使用快速傅里叶变换 (FFT) 进行卷积来计算。您的任务是推导、实现并评估一个模型，该模型将 FFT 的算术强度与中央处理器 (CPU) 或图形处理器 (GPU) 的内存带宽相结合，以预测端到端的 AIM 吞吐量。您还必须在异构环境（CPU 加 GPU）中为 $\\mathbf{Z}_{\\text{near}}$ 的应用和 FFT 处理提出重叠策略并进行建模，并量化由此带来的吞吐量提升。\n\n请从以下基本定义和公认事实开始：\n- 一个大小为 $n_x \\times n_y \\times n_z$ 的三维复数到复数 FFT 可以实现为一系列一维 FFT；一次正变换的总实数浮点运算次数约为 $5 n_g \\log_2 n_g$，其中 $n_g = n_x n_y n_z$。相同的计算量适用于逆变换。谱域网格上的逐点复数乘法每个网格点需要 $6$ 次实数浮点运算。\n- 算术强度定义为 $I = F/T_b$，其中 $F$ 是浮点运算次数，$T_b$ 是从主内存读取或写入的字节数。\n- 屋顶线模型指出，对于一个在峰值浮点速率为 $P$、可持续内存带宽为 $B$ 的设备上运行的内核，其实现的浮点速率 $R$ 为 $R = \\min(P, I B)$。\n- 一个复数双精度数占用 $s_c = 16$ 字节。\n- 对于具有 $N$ 个未知量和平均近邻数 $\\nu$ 的稀疏近区应用，将浮点运算建模为 $F_{\\text{near}} = 10 \\nu N$（计入复数乘加运算），并将内存流量建模为 $T_{b,\\text{near}} = s_c N (2 \\nu + 1)$（每个未知量读取 $\\nu$ 个复数矩阵项和 $\\nu$ 个复数向量项，并写入一个复数结果）。\n- 对于包含一次正向 FFT、一次谱域逐点乘法和一次逆向 FFT 的远区 FFT 步骤，将浮点运算建模为 $F_{\\text{fft}} = 10 n_g \\log_2 n_g + 6 n_g$，并将内存流量建模为 $T_{b,\\text{fft}} = 14 s_c n_g$，假设两次 FFT 中的每一次都执行三次流式处理遍（每个轴一次），每遍都有读写操作，而谱域乘法执行一次原地读写操作。\n\n您必须为每个测试用例计算以下内容：\n- 非重叠迭代时间 $t_{\\text{no}}$（秒），定义为近区、远区 FFT 以及在近区和远区在不同设备上执行时的任何主机-设备传输时间的组件时间之和。\n- 重叠迭代时间 $t_{\\text{ov}}$（秒），在理想化的双缓冲策略下，当 CPU 端的 $\\mathbf{Z}_{\\text{near}}$ 应用、GPU 端的 FFT 和主机-设备传输位于不同设备上时，它们可以并发进行，建模为 $t_{\\text{ov}} = \\max(t_{\\text{near}}, t_{\\text{fft}}, t_{\\text{hd}})$。如果近区和远区任务都在同一设备上执行，则假设没有重叠，因此 $t_{\\text{ov}} = t_{\\text{no}}$。\n- 非重叠吞吐量 $\\theta_{\\text{no}}$（迭代次数/秒），定义为 $\\theta_{\\text{no}} = 1/t_{\\text{no}}$。\n- 重叠吞吐量 $\\theta_{\\text{ov}}$（迭代次数/秒），定义为 $\\theta_{\\text{ov}} = 1/t_{\\text{ov}}$。\n- 对于每个测试用例中的 FFT 内核，报告其算术强度 $I_{\\text{fft}}$。\n\n模型细节：\n- 对于给定设备上的计算，计算算术强度 $I$ 和实现速率 $R = \\min(P, I B)$，然后计算时间 $t = F / R$。\n- 当近区和远区在不同设备上执行时，使用 $t_{\\text{hd}} = T_{b,\\text{transfer}}/B_{\\text{pcie}}$，其中每次迭代 $T_{b,\\text{transfer}} = 2 s_c N$，用于将长度为 $N$ 的复数向量传输到加速器或从加速器传回。如果两个阶段都在同一设备上执行，则设置 $t_{\\text{hd}} = 0$。\n\n单位和输出要求：\n- 所有时间以秒表示，吞吐量以迭代次数/秒表示。打印结果时，将每个浮点数四舍五入到 $6$ 位小数。\n- 不涉及角度；不要使用角度单位。\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个子列表，包含四个浮点数和一个额外的浮点数 $I_{\\text{fft}}$，顺序为 $[t_{\\text{no}}, t_{\\text{ov}}, \\theta_{\\text{no}}, \\theta_{\\text{ov}}, I_{\\text{fft}}]$。最终行必须是所有测试用例的这些子列表的列表，不含任何空格。\n\n测试套件：\n- 案例 1 (仅 CPU 基线)：\n  - 网格: $n_x = 128$, $n_y = 128$, $n_z = 128$。\n  - 未知量: $N = 2{,}097{,}152$。\n  - 近邻数: $\\nu = 12$。\n  - 复数大小: $s_c = 16$ 字节。\n  - CPU 峰值: $P_{\\text{cpu}} = 5 \\times 10^{11}$ flops/s。\n  - CPU 带宽: $B_{\\text{cpu}} = 1 \\times 10^{11}$ bytes/s。\n  - 执行: 远区在 CPU 上，近区在 CPU 上，因此 $t_{\\text{hd}} = 0$。\n- 案例 2 (异构重叠：GPU 远区，CPU 近区，带主机-设备传输)：\n  - 网格: $n_x = 256$, $n_y = 256$, $n_z = 256$。\n  - 未知量: $N = 8{,}000{,}000$。\n  - 近邻数: $\\nu = 8$。\n  - 复数大小: $s_c = 16$ 字节。\n  - GPU 峰值: $P_{\\text{gpu}} = 1.5 \\times 10^{13}$ flops/s。\n  - GPU 带宽: $B_{\\text{gpu}} = 8.0 \\times 10^{11}$ bytes/s。\n  - CPU 峰值: $P_{\\text{cpu}} = 5 \\times 10^{11}$ flops/s。\n  - CPU 带宽: $B_{\\text{cpu}} = 1 \\times 10^{11}$ bytes/s。\n  - 主机-设备带宽: $B_{\\text{pcie}} = 1.6 \\times 10^{10}$ bytes/s。\n  - 执行: 远区在 GPU 上，近区在 CPU 上，因此包括 $t_{\\text{hd}}$ 并建模重叠 $t_{\\text{ov}} = \\max(t_{\\text{near}}, t_{\\text{fft}}, t_{\\text{hd}})$。\n- 案例 3 (仅 GPU，近区比远区计算量更大)：\n  - 网格: $n_x = 512$, $n_y = 512$, $n_z = 512$。\n  - 未知量: $N = 30{,}000{,}000$。\n  - 近邻数: $\\nu = 30$。\n  - 复数大小: $s_c = 16$ 字节。\n  - GPU 峰值: $P_{\\text{gpu}} = 1.5 \\times 10^{13}$ flops/s。\n  - GPU 带宽: $B_{\\text{gpu}} = 8.0 \\times 10^{11}$ bytes/s。\n  - 执行: 远区在 GPU 上，近区在 GPU 上，因此 $t_{\\text{hd}} = 0$ 且无重叠。\n- 案例 4 (小网格边界情况，仅 CPU)：\n  - 网格: $n_x = 16$, $n_y = 16$, $n_z = 16$。\n  - 未知量: $N = 10{,}000$。\n  - 近邻数: $\\nu = 4$。\n  - 复数大小: $s_c = 16$ 字节。\n  - CPU 峰值: $P_{\\text{cpu}} = 2 \\times 10^{11}$ flops/s。\n  - CPU 带宽: $B_{\\text{cpu}} = 5.0 \\times 10^{10}$ bytes/s。\n  - 执行: 远区在 CPU 上，近区在 CPU 上，因此 $t_{\\text{hd}} = 0$。\n\n您的程序必须实现上述模型，并生成单行输出，格式为 $[[t_{\\text{no},1},t_{\\text{ov},1},\\theta_{\\text{no},1},\\theta_{\\text{ov},1},I_{\\text{fft},1}],\\dots,[t_{\\text{no},4},t_{\\text{ov},4},\\theta_{\\text{no},4},\\theta_{\\text{ov},4},I_{\\text{fft},4}]]$，其中每个浮点数四舍五入到 $6$ 位小数，并且行内没有任何空格。",
            "solution": "问题陈述已经过验证，被认为是具有科学依据、适定且完整的。构建自适应积分方法 (AIM) 的定量性能模型所需的所有必要参数、模型和定义均已提供。\n\n解决方案涉及综合几个已有模型：AIM 的算法结构、其计算内核（稀疏矩阵向量乘法和快速傅里叶变换）的成本模型，以及用于预测特定硬件架构上执行时间的屋顶线性能模型。该问题要求分析四个不同的测试用例，涵盖仅 CPU、仅 GPU 以及异构 CPU-GPU 执行场景。\n\nAIM 性能模型的核心是总迭代时间的分解。一次迭代包含一个近区计算和一个远区计算。\n\n首先，我们定义问题陈述中提供的参数：\n- FFT 网格的大小为 $n_x \\times n_y \\times n_z$，总网格点数为 $n_g = n_x n_y n_z$。\n- 边界元法中的未知量数量为 $N$。\n- 每个未知量的平均近邻数为 $\\nu$。\n- 一个复数双精度数的大小为 $s_c = 16$ 字节。\n- 一个设备的峰值浮点速率为 $P$ (单位：flops/s)。\n- 一个设备的可持续内存带宽为 $B$ (单位：bytes/s)。\n- 主机到设备的互连带宽为 $B_{\\text{pcie}}$。\n\n每个计算部分的性能使用屋顶线模型确定。实现的浮点速率 $R$ 由 $R = \\min(P, I \\times B)$ 给出，其中 $I$ 是内核的算术强度。算术强度是执行的浮点运算次数 ($F$) 与从/向主内存移动的字节数 ($T_b$) 的比率，即 $I = F/T_b$。一个内核的执行时间 $t$ 于是为 $t = F/R$。\n\n**近区部分 ($t_{\\text{near}}$)**\n近区计算被建模为稀疏矩阵向量乘积。\n1.  浮点运算次数 $F_{\\text{near}}$ 建模为 $F_{\\text{near}} = 10 \\nu N$。这考虑了复数乘加运算（例如，复数乘法需要 $4$ 次乘法和 $2$ 次加法，再加上复数加法的 $2$ 次加法，总共 $8$ 次实数运算，但模型指定 $10$ 作为一个合理的近似值）。\n2.  内存流量 $T_{b,\\text{near}}$ 建模为 $T_{b,\\text{near}} = s_c N (2 \\nu + 1)$。这假设为 $N$ 个未知量中的每一个读取 $\\nu$ 个复数矩阵项、$\\nu$ 个复数向量项，并写入一个复数结果项。\n3.  算术强度为 $I_{\\text{near}} = \\frac{F_{\\text{near}}}{T_{b,\\text{near}}} = \\frac{10 \\nu N}{s_c N (2 \\nu + 1)} = \\frac{10 \\nu}{s_c (2 \\nu + 1)}$。\n4.  给定设备参数 ($P_{\\text{near_dev}}$, $B_{\\text{near_dev}}$)，实现速率为 $R_{\\text{near}} = \\min(P_{\\text{near_dev}}, I_{\\text{near}} \\times B_{\\text{near_dev}})$。\n5.  近区部分的执行时间为 $t_{\\text{near}} = F_{\\text{near}} / R_{\\text{near}}$。\n\n**远区部分 ($t_{\\text{fft}}$)**\n远区计算主要由三个步骤主导：一次正向三维 FFT、一次谱域中的逐点乘法和一次逆向三维 FFT。\n1.  总浮点运算次数 $F_{\\text{fft}}$ 由两次 FFT 和逐点乘法的运算量之和给出：$F_{\\text{fft}} = 2 \\times (5 n_g \\log_2 n_g) + 6 n_g = 10 n_g \\log_2 n_g + 6 n_g$。\n2.  内存流量 $T_{b,\\text{fft}}$ 指定为 $T_{b,\\text{fft}} = 14 s_c n_g$。这是基于一个特定的实现模型，其中每次 FFT 涉及三遍处理（每个维度一遍），每遍都需要对整个网格进行一次读取和一次写入（每次 FFT 为 $2 \\times 3 \\times s_c n_g$），而谱域乘法涉及一次读取和一次写入遍（$2 s_c n_g$），总计 $(2 \\times 6 + 2)s_c n_g = 14 s_c n_g$ 字节。\n3.  算术强度 $I_{\\text{fft}}$ 是要求的输出之一，其值为 $I_{\\text{fft}} = \\frac{F_{\\text{fft}}}{T_{b,\\text{fft}}} = \\frac{10 n_g \\log_2 n_g + 6 n_g}{14 s_c n_g} = \\frac{10 \\log_2 n_g + 6}{14 s_c}$。\n4.  给定设备参数 ($P_{\\text{fft_dev}}$, $B_{\\text{fft_dev}}$)，实现速率为 $R_{\\text{fft}} = \\min(P_{\\text{fft_dev}}, I_{\\text{fft}} \\times B_{\\text{fft_dev}})$。\n5.  远区部分的执行时间为 $t_{\\text{fft}} = F_{\\text{fft}} / R_{\\text{fft}}$。\n\n**主机-设备传输 ($t_{\\text{hd}}$)**\n仅在异构执行场景中，CPU 和 GPU 之间的数据传输才是必要的。\n1.  如果近区和远区计算都在同一设备上执行，则传输时间 $t_{\\text{hd}}$ 为零。\n2.  如果它们在不同的设备上，必须将长度为 $N$ 的复数向量传输到加速器，并将结果传回。移动的总数据量为 $T_{b,\\text{transfer}} = 2 s_c N$。\n3.  所需时间为 $t_{\\text{hd}} = T_{b,\\text{transfer}} / B_{\\text{pcie}}$。\n\n**总时间和吞吐量**\n总迭代时间和吞吐量针对两种场景计算：非重叠和重叠。\n1.  **非重叠**：总时间 $t_{\\text{no}}$ 是各个部分时间的总和：$t_{\\text{no}} = t_{\\text{near}} + t_{\\text{fft}} + t_{\\text{hd}}$。相应的吞吐量为 $\\theta_{\\text{no}} = 1/t_{\\text{no}}$。\n2.  **重叠**：重叠仅在异构情况下可能，此时近区（在 CPU 上）、远区（在 GPU 上）和数据传输可以流水线化。迭代时间受最慢阶段的限制：$t_{\\text{ov}} = \\max(t_{\\text{near}}, t_{\\text{fft}}, t_{\\text{hd}})$。如果两个部分都在同一设备上执行，则无法重叠，因此 $t_{\\text{ov}} = t_{\\text{no}}$。相应的吞吐量为 $\\theta_{\\text{ov}} = 1/t_{\\text{ov}}$。\n\n这些原则被应用于问题陈述中指定的四个测试用例中的每一个，以计算五个所需的输出值：$[t_{\\text{no}}, t_{\\text{ov}}, \\theta_{\\text{no}}, \\theta_{\\text{ov}}, I_{\\text{fft}}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the AIM performance modeling problem for all test cases.\n    \"\"\"\n\n    def calculate_performance(case):\n        \"\"\"\n        Calculates the performance metrics for a single test case.\n        \"\"\"\n        nx, ny, nz = case[\"grid\"]\n        N = case[\"N\"]\n        nu = case[\"nu\"]\n        s_c = case[\"s_c\"]\n        \n        P_cpu = case.get(\"P_cpu\")\n        B_cpu = case.get(\"B_cpu\")\n        P_gpu = case.get(\"P_gpu\")\n        B_gpu = case.get(\"B_gpu\")\n        B_pcie = case.get(\"B_pcie\")\n\n        near_exec_dev = case[\"near_exec\"]\n        far_exec_dev = case[\"far_exec\"]\n\n        # Determine device parameters for each part\n        if near_exec_dev == 'CPU':\n            P_near, B_near = P_cpu, B_cpu\n        else:\n            P_near, B_near = P_gpu, B_gpu\n\n        if far_exec_dev == 'CPU':\n            P_far, B_far = P_cpu, B_cpu\n        else:\n            P_far, B_far = P_gpu, B_gpu\n\n        is_heterogeneous = near_exec_dev != far_exec_dev\n\n        # Grid size\n        ng = nx * ny * nz\n\n        # ---- Near-zone calculations ----\n        F_near = 10 * nu * N\n        Tb_near = s_c * N * (2 * nu + 1)\n        if Tb_near > 0:\n            I_near = F_near / Tb_near\n        else: # Avoid division by zero\n            I_near = 0\n        \n        R_near = min(P_near, I_near * B_near)\n        if R_near > 0:\n            t_near = F_near / R_near\n        else: # Avoid division by zero\n            t_near = 0\n\n        # ---- Far-zone calculations ----\n        log2_ng = np.log2(ng)\n        F_far = 10 * ng * log2_ng + 6 * ng\n        Tb_far = 14 * s_c * ng\n        \n        # This is one of the required outputs\n        I_fft = (10 * log2_ng + 6) / (14 * s_c)\n        \n        R_far = min(P_far, I_fft * B_far)\n        if R_far > 0:\n            t_far = F_far / R_far\n        else: # Avoid division by zero\n            t_far = 0\n\n\n        # ---- Host-device transfer time ----\n        if is_heterogeneous:\n            Tb_transfer = 2 * s_c * N\n            t_hd = Tb_transfer / B_pcie\n        else:\n            t_hd = 0\n\n        # ---- Total time and throughputs ----\n        t_no = t_near + t_far + t_hd\n        \n        if is_heterogeneous:\n            t_ov = max(t_near, t_far, t_hd)\n        else:\n            t_ov = t_no\n\n        if t_no > 0:\n            theta_no = 1 / t_no\n        else:\n            theta_no = 0\n\n        if t_ov > 0:\n            theta_ov = 1 / t_ov\n        else:\n            theta_ov = 0\n\n        return [t_no, t_ov, theta_no, theta_ov, I_fft]\n\n    test_cases = [\n        # Case 1 (CPU-only baseline)\n        {\n            \"grid\": (128, 128, 128), \"N\": 2097152, \"nu\": 12, \"s_c\": 16,\n            \"P_cpu\": 5e11, \"B_cpu\": 1e11,\n            \"near_exec\": \"CPU\", \"far_exec\": \"CPU\"\n        },\n        # Case 2 (heterogeneous overlap: GPU far, CPU near)\n        {\n            \"grid\": (256, 256, 256), \"N\": 8000000, \"nu\": 8, \"s_c\": 16,\n            \"P_gpu\": 1.5e13, \"B_gpu\": 8.0e11,\n            \"P_cpu\": 5e11, \"B_cpu\": 1e11,\n            \"B_pcie\": 1.6e10,\n            \"near_exec\": \"CPU\", \"far_exec\": \"GPU\"\n        },\n        # Case 3 (GPU-only, near heavier than far)\n        {\n            \"grid\": (512, 512, 512), \"N\": 30000000, \"nu\": 30, \"s_c\": 16,\n            \"P_gpu\": 1.5e13, \"B_gpu\": 8.0e11,\n            \"near_exec\": \"GPU\", \"far_exec\": \"GPU\"\n        },\n        # Case 4 (small-grid boundary case, CPU-only)\n        {\n            \"grid\": (16, 16, 16), \"N\": 10000, \"nu\": 4, \"s_c\": 16,\n            \"P_cpu\": 2e11, \"B_cpu\": 5.0e10,\n            \"near_exec\": \"CPU\", \"far_exec\": \"CPU\"\n        }\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        results = calculate_performance(case)\n        # Format each number to 6 decimal places and create the sublist string\n        case_str_list = [f\"{val:.6f}\" for val in results]\n        sublist_str = f\"[{','.join(case_str_list)}]\"\n        all_results_str.append(sublist_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n\n```"
        }
    ]
}