{
    "hands_on_practices": [
        {
            "introduction": "快速多极子方法（FMM）的效率源于其对空间和相互作用的巧妙分层处理。为了真正掌握其核心机制，我们必须从基本单元入手。这项练习  将引导你通过第一性原理，为一个八叉树分解中的基本单元（叶节点盒）具体计算其近场和远场伙伴的数量，从而加深对作为算法基石的“邻居集”（neighbor set）和“相互作用列表”（interaction list）的理解。",
            "id": "3307042",
            "problem": "考虑在用于求解由矢量亥姆霍兹方程控制的时谐电磁散射问题的矩量法（MoM）离散化中，使用快速多极子方法（FMM）加速的均匀八叉树空间分解。计算域为一个立方体，八叉树被均匀细化到第 $\\ell$ 层，因此每个非叶子方块恰好有 $8$ 个子方块，每个第 $\\ell$ 层的叶子方块的边长为 $h_{\\ell}$。设 $\\mathcal{B}$ 为第 $\\ell$ 层的一个内部叶子方块（即，其父方块及其父方块的所有邻居都完全存在于均匀网格中，因此没有边界截断）。\n\n定义第 $\\ell$ 层的邻居集合 $\\mathcal{N}(\\mathcal{B})$ 为所有闭包与 $\\mathcal{B}$ 的闭包相交的第 $\\ell$ 层方块的集合，但不包括 $\\mathcal{B}$ 本身。定义第 $\\ell$ 层的相互作用列表 $\\mathcal{I}(\\mathcal{B})$ 为所有作为 $\\mathcal{B}$ 的父方块的邻居集合中的第 $(\\ell-1)$ 层方块的子方块的第 $\\ell$ 层方块的集合，但不包括任何属于 $\\mathcal{N}(\\mathcal{B})$ 的第 $\\ell$ 层方块。\n\n根据FMM层次结构中近场和远场相互作用划分的基本原理，计算在这些假设下，均匀网格中这个内部叶子方块的邻居集合和相互作用列表的基数 $|\\mathcal{N}(\\mathcal{B})|$ 和 $|\\mathcal{I}(\\mathcal{B})|$。将你的最终答案表示为一个双元素行向量 $\\left(N_{\\text{near}}, N_{\\text{far}}\\right)$，其中 $N_{\\text{near}} = |\\mathcal{N}(\\mathcal{B})|$ 且 $N_{\\text{far}} = |\\mathcal{I}(\\mathcal{B})|$。\n\n你的最终答案必须是精确整数。表示答案时无需单位。无需四舍五入。",
            "solution": "用户提供的问题陈述已经过验证，被认为是科学上合理的、适定的、客观且自洽的。该问题要求计算在快速多极子方法（FMM）中使用的均匀八叉树分解中，一个内部叶子方块的邻居集合和相互作用列表的基数。我们根据所提供的定义进行求解。\n\n设 $\\mathcal{B}$ 为均匀八叉树第 $\\ell$ 层的一个内部叶子方块。问题要求计算两个量：$N_{\\text{near}} = |\\mathcal{N}(\\mathcal{B})|$ 和 $N_{\\text{far}} = |\\mathcal{I}(\\mathcal{B})|$。\n\n**第一部分：邻居集合基数 $N_{\\text{near}}$ 的计算**\n\n邻居集合 $\\mathcal{N}(\\mathcal{B})$ 被定义为所有闭包与 $\\mathcal{B}$ 的闭包相交的第 $\\ell$ 层方块的集合，但不包括 $\\mathcal{B}$ 本身。\n由于 $\\mathcal{B}$ 是一个均匀八叉树中的内部叶子方块，我们可以将其想象为一个由相同立方体组成的 $3 \\times 3 \\times 3$ 网格的中心立方体。如果一个方块的闭包与中心方块的闭包共享一个面、一条边或一个顶点，则它们的闭包相交。满足此条件的方块恰好是围绕并包含中心方块的 $3 \\times 3 \\times 3$ 网格中的所有方块。\n\n这个 $3 \\times 3 \\times 3$ 排列中的方块总数为 $3^3 = 27$。\n这个计数包括了方块 $\\mathcal{B}$ 本身。$\\mathcal{N}(\\mathcal{B})$ 的定义明确排除了 $\\mathcal{B}$。因此，邻居的数量是排列中的总方块数减一。\n\n$$N_{\\text{near}} = |\\mathcal{N}(\\mathcal{B})| = 3^3 - 1 = 27 - 1 = 26$$\n\n这 $26$ 个方块构成了方块 $\\mathcal{B}$ 的“近场”，在矩量法（MoM）中，这些相互作用是直接计算的，没有使用FMM加速。\n\n**第二部分：相互作用列表基数 $N_{\\text{far}}$ 的计算**\n\n相互作用列表 $\\mathcal{I}(\\mathcal{B})$ 被定义为所有作为 $\\mathcal{B}$ 的父方块的邻居集合中的第 $(\\ell-1)$ 层方块的子方块的第 $\\ell$ 层方块的集合，但不包括任何属于 $\\mathcal{N}(\\mathcal{B})$ 的第 $\\ell$ 层方块。\n\n让我们系统地分解这个定义。\n1.  **父方块及其邻居：** 设 $\\mathcal{P}(\\mathcal{B})$ 表示方块 $\\mathcal{B}$ 的父方块。$\\mathcal{P}(\\mathcal{B})$ 是一个第 $\\ell-1$ 层的方块。由于 $\\mathcal{B}$ 是一个内部叶子方块，其父方块 $\\mathcal{P}(\\mathcal{B})$ 是一个内部非叶子方块。父方块的邻居集合 $\\mathcal{N}(\\mathcal{P}(\\mathcal{B}))$ 的定义与 $\\mathcal{N}(\\mathcal{B})$ 类似，但在第 $\\ell-1$ 层。遵循与第一部分相同的逻辑，父方块的邻居数量为：\n    $$|\\mathcal{N}(\\mathcal{P}(\\mathcal{B}))| = 3^3 - 1 = 26$$\n    因此，在第 $\\ell-1$ 层有 $26$ 个方块是 $\\mathcal{P}(\\mathcal{B})$ 的邻居。\n\n2.  **父方块邻居的子方块：** 问题陈述说明每个非叶子方块恰好有 $8$ 个子方块。$\\mathcal{N}(\\mathcal{P}(\\mathcal{B}))$ 中的方块位于第 $\\ell-1$ 层，是第 $\\ell$ 层方块的父方块，因此它们是非叶子方块。设 $\\mathcal{C}$ 为 $\\mathcal{N}(\\mathcal{P}(\\mathcal{B}))$ 中所有方块的子方块的集合。$\\mathcal{C}$ 中的总方块数为：\n    $$|\\mathcal{C}| = |\\mathcal{N}(\\mathcal{P}(\\mathcal{B}))| \\times 8 = 26 \\times 8 = 208$$\n    这个集合 $\\mathcal{C}$ 构成了相互作用列表的候选池。\n\n3.  **排除近场方块：** $\\mathcal{I}(\\mathcal{B})$ 的定义要求从 $\\mathcal{C}$ 中排除任何也属于邻居集合 $\\mathcal{N}(\\mathcal{B})$ 的方块。形式上，$\\mathcal{I}(\\mathcal{B}) = \\mathcal{C} \\setminus \\mathcal{N}(\\mathcal{B})$。因此基数为：\n    $$|\\mathcal{I}(\\mathcal{B})| = |\\mathcal{C}| - |\\mathcal{C} \\cap \\mathcal{N}(\\mathcal{B})|$$\n    我们需要确定交集的大小，即 $|\\mathcal{C} \\cap \\mathcal{N}(\\mathcal{B})|$。一个方块 $B'$ 在这个交集中的充要条件是 ($B' \\in \\mathcal{C}$) 并且 ($B' \\in \\mathcal{N}(\\mathcal{B})$)。\n    - $B' \\in \\mathcal{C}$ 意味着 $B'$ 的父方块 $\\mathcal{P}(B')$ 必须是 $\\mathcal{P}(\\mathcal{B})$ 的一个邻居，即 $\\mathcal{P}(B') \\in \\mathcal{N}(\\mathcal{P}(\\mathcal{B}))$。\n    - $B' \\in \\mathcal{N}(\\mathcal{B})$ 意味着 $B'$ 是 $\\mathcal{B}$ 的 $26$ 个邻居之一。\n\n    为了计算满足这两个条件的方块数量，我们可以根据 $\\mathcal{B}$ 的 $26$ 个邻居的父方块来对它们进行分类。$\\mathcal{N}(\\mathcal{B})$ 中任何方块 $B'$ 的父方块要么与 $\\mathcal{B}$ 的父方块 $\\mathcal{P}(\\mathcal{B})$ 相同，要么是 $\\mathcal{P}(\\mathcal{B})$ 的一个邻居。\n    \n    a) **具有相同父方块的邻居：** 这些是 $\\mathcal{B}$ 的兄弟方块。父方块 $\\mathcal{P}(\\mathcal{B})$ 包含 $2^3=8$ 个子方块，其中之一是 $\\mathcal{B}$。另外 $8 - 1 = 7$ 个子方块都是 $\\mathcal{B}$ 的邻居（至少共享一个顶点），因此它们在 $\\mathcal{N}(\\mathcal{B})$ 中。由于它们的父方块是 $\\mathcal{P}(\\mathcal{B})$，而 $\\mathcal{P}(\\mathcal{B})$ 不在 $\\mathcal{N}(\\mathcal{P}(\\mathcal{B}))$ 中，所以这 $7$ 个方块不在集合 $\\mathcal{C}$ 中。\n\n    b) **具有不同父方块的邻居：** 这些是 $\\mathcal{B}$ 的其余邻居。邻居总数为 $26$。由于 $7$ 个是兄弟方块，其余的 $26 - 7 = 19$ 个邻居的父方块必须与 $\\mathcal{P}(\\mathcal{B})$ 不同。为了让这 $19$ 个方块成为 $\\mathcal{B}$ 的邻居，它们的父方块必须是 $\\mathcal{P}(\\mathcal{B})$ 的邻居。因此，这 $19$ 个方块的父方块在 $\\mathcal{N}(\\mathcal{P}(\\mathcal{B}))$ 中，这意味着，根据定义，它们属于集合 $\\mathcal{C}$。\n\n    通过此分析，我们发现候选集 $\\mathcal{C}$ 和邻居集 $\\mathcal{N}(\\mathcal{B})$ 的交集恰好由这 $19$ 个非兄弟邻居组成。\n    $$|\\mathcal{C} \\cap \\mathcal{N}(\\mathcal{B})| = 19$$\n\n4.  **最终计算：** 我们现在可以计算相互作用列表的基数：\n    $$N_{\\text{far}} = |\\mathcal{I}(\\mathcal{B})| = |\\mathcal{C}| - |\\mathcal{C} \\cap \\mathcal{N}(\\mathcal{B})| = 208 - 19 = 189$$\n\n    这 $189$ 个方块离 $\\mathcal{B}$“足够远”（不是直接邻居），但又足够近，以至于它们的父方块是 $\\mathcal{B}$ 的父方块的邻居。这些是在FMM算法中通常执行多极子到局部转换的方块。\n\n总之，对于均匀八叉树中的一个内部叶子方块，近场邻居的数量为 $N_{\\text{near}} = 26$，远场相互作用列表中的方块数量为 $N_{\\text{far}} = 189$。问题要求答案以双元素行向量 $(N_{\\text{near}}, N_{\\text{far}})$ 的形式给出。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n26  189\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在理解了 FMM 的分层结构之后，下一个关键问题是其计算精度。FMM 使用截断的多极展开来近似远场相互作用，而截断阶数 $p$ 是控制这一近似程度的核心参数。这项编程练习  让你能够通过数值实验，亲手探索截断阶数 $p$、目标的电尺寸以及由此产生的误差之间的关系，从而对计算成本与精度之间的权衡获得直观感受。",
            "id": "3306982",
            "problem": "考虑一个半径为 $a$ 的理想电导体 (PEC) 球体，被角频率为 $\\omega$、真空介电常数为 $\\epsilon$、真空磁导率为 $\\mu$ 的时谐平面波照射，其自由空间波数为 $k = \\omega \\sqrt{\\mu \\epsilon}$。电场积分方程 (EFIE) 强制执行边界条件，即导体表面上的总切向电场为零，这是 PEC 边界条件下麦克斯韦方程组的直接推论。多层快速多极子算法 (MLFMA) 通过使用多极子展开来加速表面电流辐射场的计算，其截断由阶数 $p$ 控制，更高的 $p$ 值会保留更多的多极子项。在基于多极子的电磁散射公式中，平移算子涉及记为 $h_n^{(1)}(\\cdot)$ 的第一类球形汉克尔函数，而截断阶数 $p$ 决定了这些项中保留多少项。\n\n设计一个使用无量纲形式 $x = k a$ 的数值实验，量化截断阶数 $p$ 如何影响以下两个度量指标：\n- 与忽略的多极子内容相关的 EFIE 残差范数 $\\| r \\|$，通过被忽略的球面波的能量来建模；以及\n- 球形汉克尔尾部误差大小，定义为截断的球形汉克尔级数尾部 $\\sum_{n>p} h_n^{(1)}(x)$ 的标量大小。\n\n从以下基本出发点开始：PEC 边界条件强制切向电场为零，并且在多极子框架中，场被展开为矢量球谐函数，其径向依赖性由球形贝塞尔函数和球形汉克尔函数给出。利用球谐函数的正交性以及 MLFMA 截断会丢弃高阶多极子这一事实，为残差范数和尾部误差构造可计算的代理指标。不要使用任何绕过这些基础的唯象简化公式。\n\n在一个单一、完整、可运行的程序中实现以下实验：\n- 完全使用无量纲参数 $x = k a$，并将入射场振幅设为单位1，以使所有结果都是无量纲和无单位的。不需要物理单位。\n- 对于给定的数对 $(x, p)$，将无穷级数截断的安全有限上界 $N_{\\max}$ 定义为 $N_{\\max} = \\max(p+1, \\lceil x + 30 \\rceil)$，以确保在从 $x \\ll 1$ 到 $x \\gg 1$ 的各种情况下数值收敛。\n- 将残差范数代理指标定义为 $\\| r \\| = \\sqrt{ \\sum_{n=p+1}^{N_{\\max}} w_n \\left| h_n^{(1)}(x) \\right|^2 }$，其中 $w_n = 2 n + 1$ 表示球谐函数中的模态简并度。\n- 将球形汉克尔尾部误差大小定义为 $T_p(x) = \\left| \\sum_{n=p+1}^{N_{\\max}} h_n^{(1)}(x) \\right|$。\n- 为每个测试用例计算这两个度量指标，并以浮点数形式报告。此处角度单位无关紧要，因为计算是纯粹径向的，只与 $x$ 有关。\n\n使用以下 $(x, p)$ 对的测试套件来测试不同的区域和截断水平：\n- 情况 1：$x = 0.1$, $p = 0$。\n- 情况 2：$x = 0.1$, $p = 2$。\n- 情况 3：$x = 1.0$, $p = 0$。\n- 情况 4：$x = 1.0$, $p = 4$。\n- 情况 5：$x = 10.0$, $p = 5$。\n- 情况 6：$x = 10.0$, $p = 15$。\n- 情况 7：$x = 50.0$, $p = 30$。\n- 情况 8：$x = 50.0$, $p = 70$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个项目对应一个测试用例，并且是双元素列表 $[\\| r \\|, T_p(x)]$，其中每个浮点数四舍五入到10位有效数字，例如 $[[\\| r \\|_1, T_p(x_1)], \\ldots, [\\| r \\|_8, T_p(x_8)]]$。",
            "solution": "该问题是有效的。它在计算电磁学方面有科学依据，提法恰当，提供了所有必要信息，并且其表述是客观的。该问题要求进行一个数值实验，以量化在基于多极子的电磁散射方法中截断阶数的影响。在像快速多极子方法 (FMM) 及其多层变体 (MLFMA) 这样的算法中，这是一个标准且重要的考虑因素。\n\n其物理背景是时谐平面波从一个半径为 $a$ 的理想电导体 (PEC) 球体发生的散射。解是使用电场积分方程 (EFIE) 构建的，该方程强制执行边界条件，即导体表面上的总切向电场必须为零：$\\vec{E}_{\\text{tan}}^{\\text{inc}} + \\vec{E}_{\\text{tan}}^{\\text{scat}} = 0$。散射场 $\\vec{E}^{\\text{scat}}$ 是由球体上的感应表面电流 $\\vec{J}_s$ 产生的。\n\n在球坐标系中，场可以自然地使用矢量球谐函数进行展开。出射散射波的径向依赖性由第一类球形汉克尔函数 $h_n^{(1)}(kr)$ 描述，其中 $k$ 是自由空间波数，$r$ 是径向距离。散射场的完整表示需要一个由这些函数组成的无穷级数，其阶数 $n$ 从 $0$ 到 $\\infty$。\n\n多层快速多极子算法 (MLFMA) 是一种用于求解 EFIE 的加速技术。它通过将源和观察点分组，避免了对所有成对相互作用的直接计算。来自远处源群的场由一个截断的多极子展开式表示。截断阶数（记为 $p$）规定了只保留阶数最高为 $n=p$ 的多极子项。这种截断是 MLFMA 中可控误差的一个主要来源。该问题要求使用两个基于被忽略的高阶项 ($n > p$) 且具有物理动机的度量指标来量化此误差。\n\n分析是使用无量纲参数 $x = ka$ 进行的，它代表球体的电尺寸。\n\n第一个度量指标是球体表面残差场的 L2 范数的一个代理指标，定义为\n$$\n\\| r \\| = \\sqrt{ \\sum_{n=p+1}^{N_{\\max}} w_n \\left| h_n^{(1)}(x) \\right|^2 }\n$$\n这个公式的合理性基于模态展开的原理。球体外部散射场的总能量与展开系数的平方幅值之和相关。根据矢量球谐函数在球面上的正交性，表面上场的 L2 范数的平方与其模态分量的平方幅值之和成正比。项 $\\left| h_n^{(1)}(x) \\right|^2$ 代表了阶数为 $n$ 的单个径向模式对球体表面能量密度的贡献。权重 $w_n = 2n+1$ 解释了模态简并度，因为对于每个阶数 $n$，都有 $2n+1$ 个正交的角向模式（球谐函数 $Y_{nm}$）。求和范围涵盖了从 $n=p+1$ 到一个足够大的阶数 $N_{\\max}$ 的被忽略的模式，以确保无穷级数的尾部被捕获。因此，$\\| r \\|$ 模拟了场展开中被截断部分的能量含量，这对应于满足 EFIE 边界条件时的误差。\n\n第二个度量指标是球形汉克尔尾部误差大小，定义为\n$$\nT_p(x) = \\left| \\sum_{n=p+1}^{N_{\\max}} h_n^{(1)}(x) \\right|\n$$\n这是对球形汉克尔函数级数收敛性的一个更直接的度量。它代表了径向展开中所有被截断项之和的幅值。虽然它不直接是能量范数，但对于线性依赖于这些径向函数之和的量，它为截断误差提供了一个有价值且直接的评估。\n\n求和的上限 $N_{\\max} = \\max(p+1, \\lceil x + 30 \\rceil)$ 是一个确保数值收敛的实用选择。对于小的 $x$，汉克尔函数随 $n$ 迅速衰减，因此需要的项数较少。对于大的 $x$，在渐近衰减开始之前需要更多的项，这种行为由对 $x$ 的依赖性所体现。常数 $30$ 提供了一个安全余量。\n\n每个测试用例 $(x, p)$ 的计算步骤如下：\n1.  根据 $x$ 和 $p$ 确定求和上限 $N_{\\max}$。\n2.  定义求和指数的范围 $n \\in [p+1, p+2, \\ldots, N_{\\max}]$。\n3.  对于此范围内的每个 $n$，计算第一类球形汉克尔函数 $h_n^{(1)}(x)$。这是一个复值函数，由 $h_n^{(1)}(x) = j_n(x) + i y_n(x)$ 给出，其中 $j_n(x)$ 和 $y_n(x)$ 分别是第一类和第二类球形贝塞尔函数。这些函数在像 `SciPy` 这样的科学计算库中是现成可用的。\n4.  通过在 $n$ 的范围内对 $(2n+1)|h_n^{(1)}(x)|^2$ 求和，然后取和的平方根，来计算残差范数 $\\| r \\|$。\n5.  通过在 $n$ 的范围内对复数值 $h_n^{(1)}(x)$ 求和，然后取复数和的绝对值，来计算尾部误差 $T_p(x)$。\n6.  然后为每个 $(x, p)$ 对报告结果 $[\\| r \\|, T_p(x)]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn, spherical_yn\n\ndef solve():\n    \"\"\"\n    Computes the residual norm and Hankel tail error for a set of test cases\n    related to the fast multipole method for electromagnetic scattering.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (x, p) pairs\n        (0.1, 0),\n        (0.1, 2),\n        (1.0, 0),\n        (1.0, 4),\n        (10.0, 5),\n        (10.0, 15),\n        (50.0, 30),\n        (50.0, 70),\n    ]\n\n    results = []\n    for x, p in test_cases:\n        # Step 1: Define the safe finite upper limit for truncation.\n        # N_max must be an integer for use in arange.\n        N_max = int(max(p + 1, np.ceil(x + 30)))\n\n        # Handle the case where the summation is empty.\n        if p + 1 > N_max:\n            residual_norm = 0.0\n            tail_error = 0.0\n            results.append([residual_norm, tail_error])\n            continue\n\n        # Step 2: Define the range of summation indices n.\n        n_values = np.arange(p + 1, N_max + 1)\n\n        # Step 3: Compute the spherical Hankel functions of the first kind.\n        # h_n^(1)(x) = j_n(x) + i * y_n(x)\n        # Using the sequence evaluation capability of scipy functions for efficiency.\n        jn_values = spherical_jn(n_values, x)\n        yn_values = spherical_yn(n_values, x)\n        h_n_1_values = jn_values + 1j * yn_values\n\n        # Step 4: Compute the residual norm proxy ||r||.\n        # ||r|| = sqrt( sum_{n=p+1}^{N_max} w_n * |h_n^(1)(x)|^2 )\n        # where w_n = 2n + 1\n        w_n = 2 * n_values + 1\n        residual_norm_sq = np.sum(w_n * np.abs(h_n_1_values)**2)\n        residual_norm = np.sqrt(residual_norm_sq)\n\n        # Step 5: Compute the spherical Hankel tail error magnitude T_p(x).\n        # T_p(x) = | sum_{n=p+1}^{N_max} h_n^(1)(x) |\n        tail_error = np.abs(np.sum(h_n_1_values))\n\n        # Step 6: Store the pair of metrics.\n        results.append([residual_norm, tail_error])\n\n    # Final print statement in the exact required format.\n    # Format each float to 10 significant digits using the 'g' format specifier.\n    formatted_pairs = [f\"[{format(pair[0], '.10g')}, {format(pair[1], '.10g')}]\" for pair in results]\n    final_output = f\"[{','.join(formatted_pairs)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "先进的数值算法必须在广泛的参数范围内保持其鲁棒性。FMM 常用于加速求解的电场积分方程（EFIE）存在一个棘手的“低频崩溃”问题：当目标尺寸远小于波长时，方程会变得数值不稳定。最后一个实践练习  深入探讨了这一关键挑战，你将通过实现一个简化的“环路-树”（loop-tree）预条件子，亲眼见证它如何修正不良的矩阵条件数，从而确保算法的可靠性。",
            "id": "3307026",
            "problem": "给定一个针对理想电导体 (PEC) 散射的电场积分方程 (EFIE) 算子的简化离散模型，该模型捕捉了低频崩溃现象及其在多层快速多极子算法 (MLFMA) 框架内通过环-树预处理得到的缓解。其底层物理模型基于麦克斯韦方程组和时谐场的 EFIE 公式。EFIE 算子是矢量势项和标量势项之和，其离散形式可以表示为矩阵\n$$\nZ(k) \\equiv j \\omega \\mu L + \\frac{1}{j \\omega \\epsilon} C\n$$\n其中 $j$ 是虚数单位，$\\omega$ 是角频率，$\\mu$ 是磁导率，$\\epsilon$ 是介电常数，$k$ 是以 $\\mathrm{rad}/\\mathrm{m}$ 为单位的波数，满足 $k = \\omega \\sqrt{\\mu \\epsilon}$。矩阵 $L$ 和 $C$ 分别代表离散矢量势算子（与磁格林函数成比例）和离散标量势算子（与电格林函数成比例）。对于典型的散度整合基函数，如 Rao-Wilton-Glisson (RWG) 函数，EFIE 表现出一个无散（环）子空间和一个与电流的亥姆霍兹分解相关的无旋（树）子空间。在低频 ($k \\to 0$) 时，$j\\omega\\mu L$ 项的量级为 $O(k)$，而 $\\frac{1}{j \\omega \\epsilon} C$ 项的量级为 $O(1/k)$，导致未经预处理的算子出现严重的病态。\n\n在本问题中，您将需要：\n1. 根据给定的分块矩阵 $L$ 和 $C$，为指定的 $k$ 值构造 $Z(k)$。其中，未知数被排序，使得前半部分对应于无散（环）子空间，后半部分对应于无旋（树）子空间。\n2. 应用一个对角的环-树预处理器，它将无散部分以 $O(1)$ 的比例缩放，并将无旋部分乘以一个为平衡低频缩放而选择的因子。具体来说，为了模拟同时对展开函数和测试函数进行缩放，考虑双边对角变换\n$$\nZ_{\\mathrm{pre}}(k) \\equiv M(k) Z(k) N(k)\n$$\n其中\n$$\nM(k) = \\mathrm{diag}\\big( \\underbrace{1,\\dots,1}_{\\text{环分块}}, \\underbrace{k,\\dots,k}_{\\text{树分块}} \\big),\n\\qquad\nN(k) = \\mathrm{diag}\\big( \\underbrace{1,\\dots,1}_{\\text{环分块}}, \\underbrace{k,\\dots,k}_{\\text{树分块}} \\big)\n$$\n这种对角双边缩放是环-树预处理的一个简化模型，它通过平衡与无散和无旋子空间相关的贡献来消除 $O(1/k)$ 的差异，从而产生一个在 $k \\to 0$ 时条件数得到改善的算子。\n\n3. 使用矩阵 $2$-范数计算谱条件数 $\\kappa(Z) = \\|\\sigma_{\\max}(Z) / \\sigma_{\\min}(Z)\\|$，其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 分别是 $Z$ 的最大和最小奇异值。对 $\\kappa(Z_{\\mathrm{pre}})$ 重复此计算。\n\n使用以下常数和数据：\n- 光速 $c = 299{,}792{,}458 \\, \\mathrm{m/s}$。\n- 真空磁导率 $\\mu_0 = 4\\pi \\times 10^{-7} \\, \\mathrm{H/m}$。\n- 真空介电常数 $\\epsilon_0 = 8.854187817 \\times 10^{-12} \\, \\mathrm{F/m}$。\n- 角频率与波数的关系为 $\\omega = k \\, c$。\n- 离散系统的维度为 $8$，划分为一个 $4$ 维的环分块和一个 $4$ 维的树分块。\n\n矩阵 $L$ 和 $C$ 由 $4 \\times 4$ 的分块指定，\n$$\nL =\n\\begin{bmatrix}\nL_{\\ell\\ell}  L_{\\ell t} \\\\\nL_{t \\ell}  L_{tt}\n\\end{bmatrix},\n\\qquad\nC =\n\\begin{bmatrix}\nC_{\\ell\\ell}  C_{\\ell t} \\\\\nC_{t \\ell}  C_{tt}\n\\end{bmatrix}\n$$\n其数值项为\n$$\nL_{\\ell\\ell} =\n\\begin{bmatrix}\n2.0  0.5  0.3  0.2 \\\\\n0.5  2.0  0.4  0.3 \\\\\n0.3  0.4  2.0  0.5 \\\\\n0.2  0.3  0.5  2.0\n\\end{bmatrix},\n\\quad\nL_{tt} =\n\\begin{bmatrix}\n1.0  0.3  0.2  0.1 \\\\\n0.3  1.0  0.3  0.2 \\\\\n0.2  0.3  1.0  0.3 \\\\\n0.1  0.2  0.3  1.0\n\\end{bmatrix}\n$$\n$$\nL_{\\ell t} =\n\\begin{bmatrix}\n0.2  0.1  0.1  0.0 \\\\\n0.1  0.2  0.1  0.1 \\\\\n0.1  0.1  0.2  0.1 \\\\\n0.0  0.1  0.1  0.2\n\\end{bmatrix},\n\\qquad\nL_{t \\ell} = L_{\\ell t}^{\\top}\n$$\n$$\nC_{\\ell\\ell} =\n\\begin{bmatrix}\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0\n\\end{bmatrix},\n\\quad\nC_{\\ell t} =\n\\begin{bmatrix}\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0\n\\end{bmatrix}\n$$\n$$\nC_{t \\ell} =\n\\begin{bmatrix}\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0\n\\end{bmatrix},\n\\quad\nC_{tt} =\n\\begin{bmatrix}\n3.0  0.5  0.4  0.3 \\\\\n0.5  3.0  0.5  0.4 \\\\\n0.4  0.5  3.0  0.5 \\\\\n0.3  0.4  0.5  3.0\n\\end{bmatrix}\n$$\n这些分块将 $L$ 和 $C$ 定义为 $8 \\times 8$ 的分块矩阵。所选的 $C$ 仅在树分块上非零，这模拟了对于散度整合基函数，标量势项仅作用于无旋分量，从而引发低频崩溃的事实。\n\n任务：\n- 对于下面测试集中的每个给定 $k$，计算如上定义的 $\\kappa(Z(k))$ 和 $\\kappa(Z_{\\mathrm{pre}}(k))$。条件数是无量纲量。\n- 使用以 $\\mathrm{rad}/\\mathrm{m}$ 为单位的 $k$，并使用 $\\omega = k \\, c$ 计算以 $\\mathrm{rad}/\\mathrm{s}$ 为单位的 $\\omega$。\n\n测试集（波数单位为 $\\mathrm{rad}/\\mathrm{m}$）：\n- 情况 1 (happy path)：$k = 1.0$。\n- 情况 2 (moderately small)：$k = 0.1$。\n- 情况 3 (small)：$k = 0.01$。\n- 情况 4 (edge, extremely small)：$k = 10^{-6}$。\n- 情况 5 (larger)：$k = 5.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的、包含 $10$ 个浮点值的逗号分隔列表。这些值必须按以下顺序排列：$\\big[\\kappa(Z(1.0)), \\kappa(Z_{\\mathrm{pre}}(1.0)), \\kappa(Z(0.1)), \\kappa(Z_{\\mathrm{pre}}(0.1)), \\kappa(Z(0.01)), \\kappa(Z_{\\mathrm{pre}}(0.01)), \\kappa(Z(10^{-6})), \\kappa(Z_{\\mathrm{pre}}(10^{-6})), \\kappa(Z(5.0)), \\kappa(Z_{\\mathrm{pre}}(5.0))\\big]$。不应打印任何其他文本。",
            "solution": "我们从均匀各向同性介质中的时谐麦克斯韦方程组开始，其磁导率为 $\\mu$，介电常数为 $\\epsilon$，角频率为 $\\omega$：\n$$\n\\nabla \\times \\mathbf{E} = - j \\omega \\mu \\mathbf{H}, \\qquad \\nabla \\times \\mathbf{H} = j \\omega \\epsilon \\mathbf{E} + \\mathbf{J}\n$$\n其中 $\\mathbf{J}$ 是源电流密度。对于理想电导体 (PEC) 散射问题，散射场满足一个边界积分方程，该方程通过在导体表面施加切向电场为零的边界条件得到。电场积分方程 (EFIE) 可以用矢量势（磁格林函数）和标量势（电格林函数）来表示。在使用散度整合基函数（例如 Rao-Wilton-Glisson (RWG) 函数）的伽辽金离散化中，EFIE 算子具有以下形式：\n$$\nZ(\\omega) = j \\omega \\mu L + \\frac{1}{j \\omega \\epsilon} C\n$$\n其中 $L$ 来自矢量势，$C$ 来自标量势，两者都是由边界积分算子定义的稠密矩阵。波数 $k$ 通过 $k = \\omega \\sqrt{\\mu \\epsilon}$ 与频率相关，或者 $\\omega = k c$，其中光速 $c = \\frac{1}{\\sqrt{\\mu \\epsilon}}$。\n\n当 $k \\to 0$ 时，这两项的量级是不同的：矢量势项 $j \\omega \\mu L$ 的行为类似于 $O(k)$，而标量势项 $\\frac{1}{j \\omega \\epsilon} C$ 的行为类似于 $O(1/k)$。对于散度整合子空间，无旋部分（树空间）受 $C$ 的强烈影响，而无散部分（环空间）的散度为零，因此 $C$ 对环分块的作用可以忽略不计。在此处使用的简化分块结构模型中，\n$$\nL = \\begin{bmatrix} L_{\\ell\\ell}   L_{\\ell t} \\\\ L_{t\\ell}   L_{tt} \\end{bmatrix},\n\\qquad\nC = \\begin{bmatrix} C_{\\ell\\ell}   C_{\\ell t} \\\\ C_{t\\ell}   C_{tt} \\end{bmatrix}\n$$\n其中 $C_{\\ell\\ell} = C_{\\ell t} = C_{t\\ell} = 0$ 且 $C_{tt} \\neq 0$。因此，未经预处理的算子具有以下分块形式：\n$$\nZ(k) = j \\omega \\mu \\begin{bmatrix} L_{\\ell\\ell}   L_{\\ell t} \\\\ L_{t\\ell}   L_{tt} \\end{bmatrix}\n+\n\\frac{1}{j \\omega \\epsilon} \\begin{bmatrix} 0   0 \\\\ 0   C_{tt} \\end{bmatrix}\n$$\n在环子空间上，当 $k \\to 0$ 时，主要贡献来自 $j \\omega \\mu L_{\\ell\\ell}$，其量级为 $O(k)$。在树子空间上，主要贡献来自 $\\frac{1}{j \\omega \\epsilon} C_{tt}$，其量级为 $O(1/k)$。因此，谱条件数满足：\n$$\n\\kappa(Z(k)) \\approx \\frac{O(1/k)}{O(k)} = O\\left(\\frac{1}{k^2}\\right)\n$$\n这代表了低频崩溃：当 $k \\to 0$ 时，算子变得越来越病态。\n\n为了缓解这个问题，环-树预处理通过缩放无散子空间和无旋子空间来平衡这些项。一种实用的方法是应用双边对角变换，将与树子空间相关的测试函数和展开系数都乘以波数 $k$，同时保持环子空间不变：\n$$\nM(k) = \\mathrm{diag}\\big( \\underbrace{1,\\dots,1}_{\\text{环分块}}, \\underbrace{k,\\dots,k}_{\\text{树分块}} \\big),\n\\qquad\nN(k) = \\mathrm{diag}\\big( \\underbrace{1,\\dots,1}_{\\text{环分块}}, \\underbrace{k,\\dots,k}_{\\text{树分块}} \\big)\n$$\n并定义\n$$\nZ_{\\mathrm{pre}}(k) = M(k) Z(k) N(k)\n$$\n考虑此变换下两部分贡献的量级变化：\n- 矢量势部分变为 $M(k) \\left( j \\omega \\mu L \\right) N(k)$。因为 $M(k)$ 和 $N(k)$ 是对角矩阵，其在环分块上的因子为 $1$，在树分块上的因子为 $k$，并且 $L$ 耦合了环和树子空间，所以这部分的总量级仍然是 $O(k)$，但在子空间之间是平衡的。\n- 标量势部分变为\n$$\nM(k) \\left( \\frac{1}{j \\omega \\epsilon} C \\right) N(k) =\n\\frac{1}{j \\omega \\epsilon} M(k) \\begin{bmatrix} 0  0 \\\\ 0  C_{tt} \\end{bmatrix} N(k)\n=\n\\frac{1}{j \\omega \\epsilon} \\begin{bmatrix} 0  0 \\\\ 0  k^2 C_{tt} \\end{bmatrix}\n$$\n由于 $\\frac{1}{\\omega}$ 的量级为 $1/k$，来自双边缩放的因子 $k^2$ 产生了一个总体的 $k$ 因子：$\\frac{1}{\\omega} \\cdot k^2 \\sim k$，因此经过预处理后，标量势在树子空间上的贡献的量级为 $O(k)$。因此，变换后的算子满足：\n$Z_{\\mathrm{pre}}(k) \\sim O(k)$ 对于无散和无旋分块均如此，\n这使得条件数在 $k \\to 0$ 时保持有界：\n$$\n\\kappa\\left(Z_{\\mathrm{pre}}(k)\\right) = O(1)\n$$\n\n这种预处理思想与环-树（分层）静态预处理一致，后者在低频时均衡了 EFIE 的无散和无旋部分的量级。请注意，多层快速多极子算法 (MLFMA) 加速了矩阵向量乘积，但并未改变算子的谱；因此，无论算子是直接应用还是通过 MLFMA 应用，条件数分析都同样适用。\n\n算法步骤：\n1. 设置物理常数 $c$、$\\mu_0$、$\\epsilon_0$，并对每个 $k$ 计算 $\\omega = k c$。\n2. 从给定的分块组装 $8 \\times 8$ 矩阵 $L$ 和 $C$。\n3. 构造 $Z(k) = j \\omega \\mu_0 L + \\frac{1}{j \\omega \\epsilon_0} C$。\n4. 构造 $M(k)$ 和 $N(k)$ 作为对角矩阵，其元素 $(1,\\dots,1,k,\\dots,k)$ 分别对应环和树的索引。\n5. 构造 $Z_{\\mathrm{pre}}(k) = M(k) Z(k) N(k)$。\n6. 使用最大奇异值与最小奇异值的比值（矩阵 $2$-范数条件数）计算 $\\kappa(Z(k))$ 和 $\\kappa(Z_{\\mathrm{pre}}(k))$。\n7. 对所有测试波数重复上述步骤，并以指定的单行格式输出结果。\n\n这个过程是自洽的，遵循了从基本电磁定律推导出的 EFIE 低频缩放特性，并提供了一个具体的数值验证，证明了环-树预处理在 $k \\to 0$ 时能够稳定条件数。",
            "answer": "```python\nimport numpy as np\n\ndef build_blocks():\n    # Loop-loop block for L (4x4)\n    L_ll = np.array([\n        [2.0, 0.5, 0.3, 0.2],\n        [0.5, 2.0, 0.4, 0.3],\n        [0.3, 0.4, 2.0, 0.5],\n        [0.2, 0.3, 0.5, 2.0]\n    ], dtype=float)\n    # Tree-tree block for L (4x4)\n    L_tt = np.array([\n        [1.0, 0.3, 0.2, 0.1],\n        [0.3, 1.0, 0.3, 0.2],\n        [0.2, 0.3, 1.0, 0.3],\n        [0.1, 0.2, 0.3, 1.0]\n    ], dtype=float)\n    # Loop-tree and tree-loop coupling in L (4x4)\n    L_lt = np.array([\n        [0.2, 0.1, 0.1, 0.0],\n        [0.1, 0.2, 0.1, 0.1],\n        [0.1, 0.1, 0.2, 0.1],\n        [0.0, 0.1, 0.1, 0.2]\n    ], dtype=float)\n    L_tl = L_lt.T\n\n    # Assemble L (8x8)\n    top = np.hstack((L_ll, L_lt))\n    bottom = np.hstack((L_tl, L_tt))\n    L = np.vstack((top, bottom))\n\n    # C blocks: only tree-tree is nonzero to emulate scalar potential acting on irrotational space\n    C_ll = np.zeros((4,4), dtype=float)\n    C_lt = np.zeros((4,4), dtype=float)\n    C_tl = np.zeros((4,4), dtype=float)\n    C_tt = np.array([\n        [3.0, 0.5, 0.4, 0.3],\n        [0.5, 3.0, 0.5, 0.4],\n        [0.4, 0.5, 3.0, 0.5],\n        [0.3, 0.4, 0.5, 3.0]\n    ], dtype=float)\n\n    # Assemble C (8x8)\n    top_C = np.hstack((C_ll, C_lt))\n    bottom_C = np.hstack((C_tl, C_tt))\n    C = np.vstack((top_C, bottom_C))\n\n    return L, C\n\ndef efie_operator(k, L, C, mu0, eps0, c):\n    # omega = k c\n    omega = k * c\n    # Z(k) = j * omega * mu0 * L + (1/(j * omega * eps0)) * C\n    j = 1j\n    Z = j * omega * mu0 * L + (1.0 / (j * omega * eps0)) * C\n    return Z\n\ndef loop_tree_preconditioners(k, n_loop, n_tree):\n    # Two-sided diagonal scaling: M(k) and N(k)\n    # M has 1 for loop rows, k for tree rows\n    # N has 1 for loop cols, k for tree cols\n    M_diag = np.array([1.0]*n_loop + [k]*n_tree, dtype=float)\n    N_diag = np.array([1.0]*n_loop + [k]*n_tree, dtype=float)\n    M = np.diag(M_diag)\n    N = np.diag(N_diag)\n    return M, N\n\ndef condition_number(Z):\n    # Compute 2-norm condition number using SVD\n    s = np.linalg.svd(Z, compute_uv=False)\n    # Avoid division by zero in pathological cases\n    s_max = np.max(s)\n    s_min = np.min(s)\n    return float(s_max / s_min)\n\ndef solve():\n    # Physical constants\n    c = 299_792_458.0  # m/s\n    mu0 = 4.0e-7 * np.pi  # H/m\n    eps0 = 8.854187817e-12  # F/m\n\n    # Build operators\n    L, C = build_blocks()\n    n = L.shape[0]\n    n_loop = n_tree = n // 2\n\n    # Test suite of wavenumbers k [rad/m]\n    test_ks = [1.0, 0.1, 0.01, 1e-6, 5.0]\n\n    results = []\n    for k in test_ks:\n        Z = efie_operator(k, L, C, mu0, eps0, c)\n        kappa_Z = condition_number(Z)\n        M, N = loop_tree_preconditioners(k, n_loop, n_tree)\n        Z_pre = M @ Z @ N\n        kappa_Zpre = condition_number(Z_pre)\n        results.extend([kappa_Z, kappa_Zpre])\n\n    # Print single-line output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}