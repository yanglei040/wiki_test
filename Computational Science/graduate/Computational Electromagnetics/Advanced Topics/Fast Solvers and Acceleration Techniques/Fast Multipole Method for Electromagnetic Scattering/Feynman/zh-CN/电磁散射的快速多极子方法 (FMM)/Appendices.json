{
    "hands_on_practices": [
        {
            "introduction": "快速多极子方法（FMM）的效率源于其对相互作用的巧妙划分：对空间邻近的“近场”区域进行直接计算，而对“远场”区域则采用多极子展开进行近似。本练习将引导您在一个理想化的均匀八叉树网格中，通过第一性原理具体计算一个单元的近场邻居集和远场相互作用列表的大小。通过亲自实践这个核心的计数过程，您将对FMM算法的空间分解和相互作用分类建立起牢固而直观的理解。",
            "id": "3307042",
            "problem": "考虑在由矢量亥姆霍兹方程控制的时谐电磁散射问题的矩量法 (MoM) 离散化中，使用快速多极子方法 (FMM) 加速时所采用的均匀八叉树空间分解。计算域为一个立方体，八叉树被均匀细化至层级 $\\ell$，使得每个非叶节点盒恰好有 $8$ 个子节点，且每个在层级 $\\ell$ 的叶节点盒的边长为 $h_{\\ell}$。设 $\\mathcal{B}$ 为层级 $\\ell$ 的一个内部叶节点盒（即，其父节点及其父节点的所有邻居都完全存在于均匀网格中，因此没有边界截断）。\n\n定义层级 $\\ell$ 的邻居集 $\\mathcal{N}(\\mathcal{B})$，其包含所有在层级 $\\ell$ 且其闭包与 $\\mathcal{B}$ 的闭包相交的盒，但不包括 $\\mathcal{B}$ 本身。定义层级 $\\ell$ 的相互作用列表 $\\mathcal{I}(\\mathcal{B})$，其包含所有作为“$\\mathcal{B}$ 的父节点的邻居集中的层级 $(\\ell-1)$ 盒”的子节点的层级 $\\ell$ 盒，但不包括任何属于 $\\mathcal{N}(\\mathcal{B})$ 的层级 $\\ell$ 盒。\n\n根据在 FMM 层次结构中划分近场和远场相互作用的第一性原理，计算在此假设下，均匀网格中这个内部叶节点盒的邻居集基数 $\\lvert \\mathcal{N}(\\mathcal{B}) \\rvert$ 和相互作用列表基数 $\\lvert \\mathcal{I}(\\mathcal{B}) \\rvert$。报告您的最终答案为一个两元素的行向量 $\\left(N_{\\text{near}}, N_{\\text{far}}\\right)$，其中 $N_{\\text{near}} = \\lvert \\mathcal{N}(\\mathcal{B}) \\rvert$ 且 $N_{\\text{far}} = \\lvert \\mathcal{I}(\\mathcal{B}) \\rvert$。\n\n您的最终答案必须是精确整数。以无单位的形式表达您的答案。无需四舍五入。",
            "solution": "用户提供的问题陈述已经过验证，并被认定为具有科学依据、适定、客观且自洽。该问题要求计算在快速多极子方法 (FMM) 中使用的均匀八叉树分解中，一个内部叶节点盒的邻居集和相互作用列表的基数。我们根据所提供的定义进行求解。\n\n设 $\\mathcal{B}$ 为均匀八叉树层级 $\\ell$ 的一个内部叶节点盒。问题要求两个量：$N_{\\text{near}} = \\lvert \\mathcal{N}(\\mathcal{B}) \\rvert$ 和 $N_{\\text{far}} = \\lvert \\mathcal{I}(\\mathcal{B}) \\rvert$。\n\n**第一部分：邻居集基数 $N_{\\text{near}}$ 的计算**\n\n邻居集 $\\mathcal{N}(\\mathcal{B})$ 定义为所有在层级 $\\ell$ 且其闭包与 $\\mathcal{B}$ 的闭包相交的盒的集合，但不包括 $\\mathcal{B}$ 本身。\n由于 $\\mathcal{B}$ 是均匀八叉树中的一个内部叶节点盒，我们可以将其想象为一个由相同立方体构成的 $3 \\times 3 \\times 3$ 网格中的中心立方体。如果一个盒的闭包与中心盒的闭包共享一个面、一条边或一个顶点，则它们的闭包相交。满足此条件的盒正是包围并包含中心盒的 $3 \\times 3 \\times 3$ 网格中的所有盒。\n\n在这个 $3 \\times 3 \\times 3$ 排列中，盒的总数为 $3^3 = 27$。\n这个计数包括了盒 $\\mathcal{B}$ 本身。$\\mathcal{N}(\\mathcal{B})$ 的定义明确排除了 $\\mathcal{B}$。因此，邻居的数量是该排列中盒的总数减一。\n\n$$N_{\\text{near}} = \\lvert \\mathcal{N}(\\mathcal{B}) \\rvert = 3^3 - 1 = 27 - 1 = 26$$\n\n这 $26$ 个盒构成了盒 $\\mathcal{B}$ 的“近场”，在矩量法 (MoM) 中，它们之间的相互作用是直接计算的，不使用 FMM 加速。\n\n**第二部分：相互作用列表基数 $N_{\\text{far}}$ 的计算**\n\n相互作用列表 $\\mathcal{I}(\\mathcal{B})$ 定义为所有作为“$\\mathcal{B}$ 的父节点的邻居集中的层级 $(\\ell-1)$ 盒”的子节点的层级 $\\ell$ 盒的集合，但不包括任何属于 $\\mathcal{N}(\\mathcal{B})$ 的层级 $\\ell$ 盒。\n\n让我们系统地分解这个定义。\n1.  **父节点盒及其邻居：** 设 $\\mathcal{P}(\\mathcal{B})$ 表示盒 $\\mathcal{B}$ 的父节点。$\\mathcal{P}(\\mathcal{B})$ 是一个在层级 $\\ell-1$ 的盒。由于 $\\mathcal{B}$ 是一个内部叶节点盒，其父节点 $\\mathcal{P}(\\mathcal{B})$ 是一个内部非叶节点盒。父节点的邻居集 $\\mathcal{N}(\\mathcal{P}(\\mathcal{B}))$ 的定义与 $\\mathcal{N}(\\mathcal{B})$ 类似，但在层级 $\\ell-1$ 上。遵循与第一部分相同的逻辑，父节点盒的邻居数量为：\n    $$\\lvert \\mathcal{N}(\\mathcal{P}(\\mathcal{B})) \\rvert = 3^3 - 1 = 26$$\n    因此，在层级 $\\ell-1$ 有 $26$ 个盒是 $\\mathcal{P}(\\mathcal{B})$ 的邻居。\n\n2.  **父节点邻居的子节点：** 问题陈述说明每个非叶节点盒恰好有 $8$ 个子节点。$\\mathcal{N}(\\mathcal{P}(\\mathcal{B}))$ 中的盒位于层级 $\\ell-1$，并且是层级 $\\ell$ 盒的父节点，因此它们是非叶节点盒。设 $\\mathcal{C}$ 为 $\\mathcal{N}(\\mathcal{P}(\\mathcal{B}))$ 中所有盒的子节点的集合。$\\mathcal{C}$ 中盒的总数为：\n    $$\\lvert \\mathcal{C} \\rvert = \\lvert \\mathcal{N}(\\mathcal{P}(\\mathcal{B})) \\rvert \\times 8 = 26 \\times 8 = 208$$\n    这个集合 $\\mathcal{C}$ 构成了相互作用列表的候选池。\n\n3.  **排除近场盒：** $\\mathcal{I}(\\mathcal{B})$ 的定义要求从 $\\mathcal{C}$ 中排除任何也属于邻居集 $\\mathcal{N}(\\mathcal{B})$ 的盒。形式上，$\\mathcal{I}(\\mathcal{B}) = \\mathcal{C} \\setminus \\mathcal{N}(\\mathcal{B})$。因此基数为：\n    $$\\lvert \\mathcal{I}(\\mathcal{B}) \\rvert = \\lvert \\mathcal{C} \\rvert - \\lvert \\mathcal{C} \\cap \\mathcal{N}(\\mathcal{B}) \\rvert$$\n    我们需要确定交集的大小，即 $\\lvert \\mathcal{C} \\cap \\mathcal{N}(\\mathcal{B}) \\rvert$。一个盒 $B'$ 在此交集中，当且仅当 ($B' \\in \\mathcal{C}$) 且 ($B' \\in \\mathcal{N}(\\mathcal{B})$)。\n    - $B' \\in \\mathcal{C}$ 意味着 $B'$ 的父节点 $\\mathcal{P}(B')$ 必须是 $\\mathcal{P}(\\mathcal{B})$ 的一个邻居，即 $\\mathcal{P}(B') \\in \\mathcal{N}(\\mathcal{P}(\\mathcal{B}))$。\n    - $B' \\in \\mathcal{N}(\\mathcal{B})$ 意味着 $B'$ 是 $\\mathcal{B}$ 的 $26$ 个邻居之一。\n\n    为了对满足这两个条件的盒进行计数，我们可以根据其父节点关系对 $\\mathcal{B}$ 的 $26$ 个邻居进行分类。$\\mathcal{N}(\\mathcal{B})$ 中任何盒 $B'$ 的父节点，要么与 $\\mathcal{B}$ 的父节点 $\\mathcal{P}(\\mathcal{B})$ 相同，要么是 $\\mathcal{P}(\\mathcal{B})$ 的一个邻居。\n    \n    a) **具有相同父节点的邻居：** 这些是 $\\mathcal{B}$ 的兄弟节点。父节点盒 $\\mathcal{P}(\\mathcal{B})$ 包含 $2^3=8$ 个子节点，其中一个是 $\\mathcal{B}$。另外 $8 - 1 = 7$ 个子节点都是 $\\mathcal{B}$ 的邻居（至少共享一个顶点），因此它们在 $\\mathcal{N}(\\mathcal{B})$ 中。由于它们的父节点是 $\\mathcal{P}(\\mathcal{B})$，而 $\\mathcal{P}(\\mathcal{B})$ 不在 $\\mathcal{N}(\\mathcal{P}(\\mathcal{B}))$ 中，所以这 $7$ 个盒不在集合 $\\mathcal{C}$ 中。\n\n    b) **具有不同父节点的邻居：** 这些是 $\\mathcal{B}$ 的剩余邻居。邻居总数为 $26$。由于有 $7$ 个是兄弟节点，剩余的 $26 - 7 = 19$ 个邻居的父节点必然不同于 $\\mathcal{P}(\\mathcal{B})$。要使这 $19$ 个盒成为 $\\mathcal{B}$ 的邻居，它们的父节点必须是 $\\mathcal{P}(\\mathcal{B})$ 的邻居。因此，这 $19$ 个盒的父节点在 $\\mathcal{N}(\\mathcal{P}(\\mathcal{B}))$ 中，这意味着根据定义，它们属于集合 $\\mathcal{C}$。\n\n    通过此分析，我们发现候选集 $\\mathcal{C}$ 和邻居集 $\\mathcal{N}(\\mathcal{B})$ 的交集恰好由这 $19$ 个非兄弟节点的邻居组成。\n    $$\\lvert \\mathcal{C} \\cap \\mathcal{N}(\\mathcal{B}) \\rvert = 19$$\n\n4.  **最终计算：** 现在我们可以计算相互作用列表的基数：\n    $$N_{\\text{far}} = \\lvert \\mathcal{I}(\\mathcal{B}) \\rvert = \\lvert \\mathcal{C} \\rvert - \\lvert \\mathcal{C} \\cap \\mathcal{N}(\\mathcal{B}) \\rvert = 208 - 19 = 189$$\n\n    这 $189$ 个盒距离 $\\mathcal{B}$ “足够远”（不是直接邻居），但又“足够近”，以至于它们的父节点盒是 $\\mathcal{B}$ 的父节点的邻居。在 FMM 算法中，通常对这些盒执行多极子到局部展开的转换。\n\n总之，对于一个均匀八叉树中的内部叶节点盒，近场邻居的数量为 $N_{\\text{near}} = 26$，远场相互作用列表中的盒数量为 $N_{\\text{far}} = 189$。问题要求以一个两元素的行向量 $(N_{\\text{near}}, N_{\\text{far}})$ 的形式给出答案。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n26  189\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "FMM/MLFMA的核心在于使用有限阶多极子展开来近似远场相互作用，而展开式的截断是算法中可控误差的主要来源。本练习旨在通过一个数值实验，让您亲手量化这种截断误差，它直接关联到算法的精度。您将探索多极子展开的截断阶数 $p$ 与散射体电尺寸 $ka$ 如何共同影响基于球汉克尔函数定义的误差度量，从而深刻理解在不同频率和精度要求下如何选择合适的算法参数。",
            "id": "3306982",
            "problem": "考虑一个半径为 $a$ 的理想电导体（PEC）球体，被一个角频率为 $\\omega$、真空介电常数为 $\\epsilon$、真空磁导率为 $\\mu$ 的时谐平面波照射，其自由空间波数为 $k = \\omega \\sqrt{\\mu \\epsilon}$。电场积分方程（EFIE）强制施加了导体表面总切向电场为零的边界条件，这是PEC边界条件下麦克斯韦方程组（Maxwell's equations）的直接推论。多层快速多极子算法（MLFMA）通过使用多极子展开来加速表面电流辐射场的计算，其截断由阶数 $p$ 控制，较高的 $p$ 值会保留更多的多极子项。在基于多极子的电磁散射公式中，平移算子涉及第一类球汉克尔函数（spherical Hankel functions of the first kind），记为 $h_n^{(1)}(\\cdot)$，截断阶数 $p$ 决定了保留多少项。\n\n设计一个使用无量纲参数 $x = k a$ 的数值实验，以量化截断阶数 $p$ 如何影响以下两个度量指标：\n- 与省略的多极子内容相关的EFIE残差范数 $\\| r \\|$，通过被忽略的球面波的能量进行建模；以及\n- 球汉克尔级数尾部误差大小，定义为截断的球汉克尔级数尾部 $\\sum_{n>p} h_n^{(1)}(x)$ 的标量大小。\n\n从以下基本出发点开始：PEC边界条件强制切向电场为零；在多极子框架中，场在矢量球谐函数中展开，其径向依赖性由球贝塞尔函数和球汉克尔函数给出。利用球谐函数的正交性以及MLFMA截断会舍弃高阶多极子这一事实，为残差范数和尾部误差构建可计算的代理指标。不要使用任何绕过这些基础的唯象简化公式。\n\n在一个单一、完整、可运行的程序中实现以下实验：\n- 完全使用无量纲参数 $x = k a$ 进行计算，并将入射场振幅设为1，从而使所有结果都是无量纲和无单位的。不需要任何物理单位。\n- 对于给定的数对 $(x, p)$，定义一个安全的有限上界 $N_{\\max}$ 用于截断无穷级数，其表达式为 $N_{\\max} = \\max(p+1, \\lceil x + 30 \\rceil)$，以确保在从 $x \\ll 1$ 到 $x \\gg 1$ 的各种情况下数值收敛。\n- 将残差范数代理指标定义为 $\\| r \\| = \\sqrt{ \\sum_{n=p+1}^{N_{\\max}} w_n \\left| h_n^{(1)}(x) \\right|^2 }$，其中 $w_n = 2 n + 1$ 表示球谐函数中的模式简并度。\n- 将球汉克尔级数尾部误差大小定义为 $T_p(x) = \\left| \\sum_{n=p+1}^{N_{\\max}} h_n^{(1)}(x) \\right|$。\n- 为每个测试案例计算这两个度量指标，并以浮点数形式报告。角度单位在此无关紧要，因为计算是纯粹径向的（仅与 $x$ 相关）。\n\n使用以下 $(x, p)$ 对的测试套件来检验不同的区域和截断水平：\n- 案例 1：$x = 0.1$，$p = 0$。\n- 案例 2：$x = 0.1$，$p = 2$。\n- 案例 3：$x = 1.0$，$p = 0$。\n- 案例 4：$x = 1.0$，$p = 4$。\n- 案例 5：$x = 10.0$，$p = 5$。\n- 案例 6：$x = 10.0$，$p = 15$。\n- 案例 7：$x = 50.0$，$p = 30$。\n- 案例 8：$x = 50.0$，$p = 70$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每一项对应一个测试案例，是一个双元素列表 $[\\| r \\|, T_p(x)]$，其中每个浮点数四舍五入到10位有效数字，例如 $[[\\| r \\|_1, T_p(x_1)], \\ldots, [\\| r \\|_8, T_p(x_8)]]$。",
            "solution": "该问题是有效的。它在计算电磁学方面有科学依据，提供了所有必要信息，是适定的，并且其表述是客观的。该问题要求进行一个数值实验，以量化在基于多极子的电磁散射方法中截断阶数的影响。这在快速多极子方法（FMM）及其多层变体（MLFMA）等算法中是一个标准且重要的考虑因素。\n\n物理背景是时谐平面波从一个半径为 $a$ 的理想电导体（PEC）球体上的散射。其解是使用电场积分方程（EFIE）构建的，该方程强制执行导体表面的总切向电场必须为零的边界条件：$\\vec{E}_{\\text{tan}}^{\\text{inc}} + \\vec{E}_{\\text{tan}}^{\\text{scat}} = 0$。散射场 $\\vec{E}^{\\text{scat}}$ 是由球体上的感应表面电流 $\\vec{J}_s$ 产生的。\n\n在球坐标系中，场很自然地使用矢量球谐函数进行展开。出射散射波的径向依赖性由第一类球汉克尔函数 $h_n^{(1)}(kr)$ 描述，其中 $k$ 是自由空间波数，$r$ 是径向距离。要完整表示散射场，需要一个由这些函数组成的无穷级数，其阶数 $n$ 从 $0$ 到 $\\infty$。\n\n多层快速多极子算法（MLFMA）是一种求解EFIE的加速技术。它通过将源和观察点分组来避免直接计算所有两两之间的相互作用。来自远处源群的场由一个截断的多极子展开表示。截断阶数（记为 $p$）决定了只保留阶数至多为 $n=p$ 的多极子项。这种截断是MLFMA中可控误差的一个主要来源。该问题要求使用两个基于被忽略的高阶项（$n > p$）且具有物理动机的度量指标来量化此误差。\n\n分析是使用无量纲参数 $x = ka$ 进行的，该参数表示球体的电尺寸。\n\n第一个度量指标是球体表面残差场的L2范数的一个代理指标，定义为\n$$\n\\| r \\| = \\sqrt{ \\sum_{n=p+1}^{N_{\\max}} w_n \\left| h_n^{(1)}(x) \\right|^2 }\n$$\n这个公式的合理性基于模式展开的原理。球体外部散射场的总能量与展开系数的幅度平方和有关。根据矢量球谐函数在球面上的正交性，表面上场的L2范数的平方与其模式分量的幅度平方和成正比。项 $\\left| h_n^{(1)}(x) \\right|^2$ 表示阶数为 $n$ 的单个径向模式对球体表面能量密度的贡献。权重 $w_n = 2n+1$ 解释了模式简并度，因为对于每个阶数 $n$，存在 $2n+1$ 个正交的角向模式（球谐函数 $Y_{nm}$）。求和范围是从 $n=p+1$ 开始的被忽略模式，直到一个足够大的阶数 $N_{\\max}$，以确保无穷级数的尾部被捕捉到。因此，$\\| r \\|$ 建模了场展开中被截断部分的能量内容，这对应于满足EFIE边界条件时的误差。\n\n第二个度量指标是球汉克尔级数尾部误差大小，定义为\n$$\nT_p(x) = \\left| \\sum_{n=p+1}^{N_{\\max}} h_n^{(1)}(x) \\right|\n$$\n这是对球汉克尔函数级数收敛性的一个更直接的度量。它表示径向展开中所有被截断项之和的幅度。虽然它不直接是能量范数，但对于线性依赖于这些径向函数之和的量，它提供了一个有价值且直接的截断误差评估。\n\n求和上限 $N_{\\max} = \\max(p+1, \\lceil x + 30 \\rceil)$ 是一个确保数值收敛的实用选择。对于小的 $x$，汉克尔函数随 $n$ 快速衰减，因此需要较少的项。对于大的 $x$，在渐近衰减开始之前需要更多的项，这种行为通过对 $x$ 的依赖性得以体现。常数 $30$ 提供了一个安全余量。\n\n每个测试案例 $(x, p)$ 的计算流程如下：\n1.  根据 $x$ 和 $p$ 确定求和上限 $N_{\\max}$。\n2.  定义求和指数的范围 $n \\in [p+1, p+2, \\ldots, N_{\\max}]$。\n3.  对于此范围内的每个 $n$，计算第一类球汉克尔函数 $h_n^{(1)}(x)$。这是一个复值函数，由 $h_n^{(1)}(x) = j_n(x) + i y_n(x)$ 给出，其中 $j_n(x)$ 和 $y_n(x)$ 分别是第一类和第二类球贝塞尔函数。这些函数在像 `SciPy` 这样的科学计算库中是现成可用的。\n4.  通过在 $n$ 的范围内对 $(2n+1)|h_n^{(1)}(x)|^2$ 求和，然后取和的平方根，来计算残差范数 $\\| r \\|$。\n5.  通过在 $n$ 的范围内对复数值 $h_n^{(1)}(x)$ 求和，然后取复数和的绝对值，来计算尾部误差 $T_p(x)$。\n6.  然后为每个 $(x, p)$ 对报告结果 $[\\| r \\|, T_p(x)]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn, spherical_yn\n\ndef solve():\n    \"\"\"\n    Computes the residual norm and Hankel tail error for a set of test cases\n    related to the fast multipole method for electromagnetic scattering.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (x, p) pairs\n        (0.1, 0),\n        (0.1, 2),\n        (1.0, 0),\n        (1.0, 4),\n        (10.0, 5),\n        (10.0, 15),\n        (50.0, 30),\n        (50.0, 70),\n    ]\n\n    results = []\n    for x, p in test_cases:\n        # Step 1: Define the safe finite upper limit for truncation.\n        # N_max must be an integer for use in arange.\n        N_max = int(max(p + 1, np.ceil(x + 30)))\n\n        # Handle the case where the summation is empty.\n        if p + 1 > N_max:\n            residual_norm = 0.0\n            tail_error = 0.0\n            results.append([residual_norm, tail_error])\n            continue\n\n        # Step 2: Define the range of summation indices n.\n        n_values = np.arange(p + 1, N_max + 1)\n\n        # Step 3: Compute the spherical Hankel functions of the first kind.\n        # h_n^(1)(x) = j_n(x) + i * y_n(x)\n        # Using the sequence evaluation capability of scipy functions for efficiency.\n        jn_values = spherical_jn(n_values, x)\n        yn_values = spherical_yn(n_values, x)\n        h_n_1_values = jn_values + 1j * yn_values\n\n        # Step 4: Compute the residual norm proxy ||r||.\n        # ||r|| = sqrt( sum_{n=p+1}^{N_max} w_n * |h_n^(1)(x)|^2 )\n        # where w_n = 2n + 1\n        w_n = 2 * n_values + 1\n        residual_norm_sq = np.sum(w_n * np.abs(h_n_1_values)**2)\n        residual_norm = np.sqrt(residual_norm_sq)\n\n        # Step 5: Compute the spherical Hankel tail error magnitude T_p(x).\n        # T_p(x) = | sum_{n=p+1}^{N_max} h_n^(1)(x) |\n        tail_error = np.abs(np.sum(h_n_1_values))\n\n        # Step 6: Store the pair of metrics.\n        results.append([residual_norm, tail_error])\n\n    # Final print statement in the exact required format.\n    # Format each float to 10 significant digits using the 'g' format specifier.\n    formatted_pairs = [f\"[{format(pair[0], '.10g')}, {format(pair[1], '.10g')}]\" for pair in results]\n    final_output = f\"[{','.join(formatted_pairs)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在实际应用中，基于电场积分方程（EFIE）的求解器在处理低频问题时会面临一个严重的数值挑战，即“低频崩溃”现象。当频率趋近于零时，系统矩阵的条件数会因矢量势和标量势贡献的尺度失衡而急剧恶化，导致迭代求解失败。本练习提供了一个简化的离散模型，让您动手实践并验证解决这一问题的关键技术——环路-树（loop-tree）预处理。您将通过计算和对比预处理前后的矩阵条件数，直观地看到该技术如何有效克服低频不稳定性，这是构建稳健电磁求解器的必备知识。",
            "id": "3307026",
            "problem": "给定一个用于理想电导体 (PEC) 散射的电场积分方程 (EFIE) 算子的简化离散模型。该模型在多层快速多极子算法 (MLFMA) 框架内捕捉了低频崩溃现象及其通过环-树预条件处理的缓解方法。其基础物理模型基于麦克斯韦方程组和时谐场的 EFIE 公式。EFIE 算子是矢量势项和标量势项之和，其离散形式可以表示为矩阵\n$$\nZ(k) \\equiv j \\,\\omega \\,\\mu \\, L \\;+\\; \\frac{1}{j \\,\\omega \\,\\epsilon} \\, C,\n$$\n其中 $j$ 是虚数单位，$\\omega$ 是角频率，$\\mu$ 是磁导率，$\\epsilon$ 是介电常数， $k$ 是波数（单位为 $\\mathrm{rad}/\\mathrm{m}$），满足 $k = \\omega \\sqrt{\\mu \\epsilon}$。矩阵 $L$ 和 $C$ 分别代表离散矢量势算子（与磁格林函数成正比）和离散标量势算子（与电格林函数成正比）。对于典型的散度整合基函数，如 Rao-Wilton-Glisson (RWG) 函数，EFIE 表现出一个无散（环）子空间和一个无旋（树）子空间，这与电流的亥姆霍兹分解有关。在低频 ($k \\to 0$) 时，$j\\,\\omega\\,\\mu\\,L$ 项的标度为 $O(k)$，而 $\\frac{1}{j \\,\\omega \\,\\epsilon} C$ 项的标度为 $O(1/k)$，导致未经预条件处理的算子出现严重的病态问题。\n\n在本问题中，您将需要：\n1. 根据给定的分块矩阵 $L$ 和 $C$，为指定的 $k$ 值构建 $Z(k)$。其中，未知量被排序，使得前半部分对应于无散（环）子空间，后半部分对应于无旋（树）子空间。\n2. 应用一个对角环-树预条件子，它将无散部分以 $O(1)$ 比例缩放，并将无旋部分乘以一个旨在平衡低频缩放的因子。具体来说，为了模拟展开函数和测试函数的同时缩放，请考虑双边对角变换\n$$\nZ_{\\mathrm{pre}}(k) \\equiv M(k) \\, Z(k) \\, N(k),\n$$\n其中\n$$\nM(k) = \\mathrm{diag}\\big( \\underbrace{1,\\dots,1}_{\\text{环路块}}, \\underbrace{k,\\dots,k}_{\\text{树形块}} \\big),\n\\qquad\nN(k) = \\mathrm{diag}\\big( \\underbrace{1,\\dots,1}_{\\text{环路块}}, \\underbrace{k,\\dots,k}_{\\text{树形块}} \\big).\n$$\n这种对角双边缩放是环-树预条件处理的一个简化模型，它通过平衡与无散子空间和无旋子空间相关的贡献来消除 $O(1/k)$ 的差异，从而在 $k \\to 0$ 时产生一个条件数得到改善的算子。\n\n3. 使用矩阵2-范数计算谱条件数 $\\kappa(Z) = \\sigma_{\\max}(Z) / \\sigma_{\\min}(Z)$，其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 分别是 $Z$ 的最大和最小奇异值。对 $\\kappa(Z_{\\mathrm{pre}})$ 重复此计算。\n\n使用以下常数和数据：\n- 光速 $c = 299{,}792{,}458 \\, \\mathrm{m/s}$。\n- 真空磁导率 $\\mu_0 = 4\\pi \\times 10^{-7} \\, \\mathrm{H/m}$。\n- 真空介电常数 $\\epsilon_0 = 8.854187817 \\times 10^{-12} \\, \\mathrm{F/m}$。\n- 角频率通过 $\\omega = k \\, c$ 与波数相关。\n- 离散系统的维度为 $8$，划分为一个 $4$ 维的环路块和一个 $4$ 维的树形块。\n\n矩阵 $L$ 和 $C$ 由 $4 \\times 4$ 的分块指定，\n$$\nL \\;=\\;\n\\begin{bmatrix}\nL_{\\ell\\ell}  L_{\\ell t} \\\\\nL_{t \\ell}  L_{tt}\n\\end{bmatrix},\n\\qquad\nC \\;=\\;\n\\begin{bmatrix}\nC_{\\ell\\ell}  C_{\\ell t} \\\\\nC_{t \\ell}  C_{tt}\n\\end{bmatrix},\n$$\n其数值项为\n$$\nL_{\\ell\\ell} \\;=\\;\n\\begin{bmatrix}\n2.0  0.5  0.3  0.2 \\\\\n0.5  2.0  0.4  0.3 \\\\\n0.3  0.4  2.0  0.5 \\\\\n0.2  0.3  0.5  2.0\n\\end{bmatrix},\n\\quad\nL_{tt} \\;=\\;\n\\begin{bmatrix}\n1.0  0.3  0.2  0.1 \\\\\n0.3  1.0  0.3  0.2 \\\\\n0.2  0.3  1.0  0.3 \\\\\n0.1  0.2  0.3  1.0\n\\end{bmatrix},\n$$\n$$\nL_{\\ell t} \\;=\\;\n\\begin{bmatrix}\n0.2  0.1  0.1  0.0 \\\\\n0.1  0.2  0.1  0.1 \\\\\n0.1  0.1  0.2  0.1 \\\\\n0.0  0.1  0.1  0.2\n\\end{bmatrix},\n\\qquad\nL_{t \\ell} \\;=\\; L_{\\ell t}^{\\top},\n$$\n$$\nC_{\\ell\\ell} \\;=\\;\n\\begin{bmatrix}\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0\n\\end{bmatrix},\n\\quad\nC_{\\ell t} \\;=\\;\n\\begin{bmatrix}\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0\n\\end{bmatrix},\n$$\n$$\nC_{t \\ell} \\;=\\;\n\\begin{bmatrix}\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0 \\\\\n0.0  0.0  0.0  0.0\n\\end{bmatrix},\n\\quad\nC_{tt} \\;=\\;\n\\begin{bmatrix}\n3.0  0.5  0.4  0.3 \\\\\n0.5  3.0  0.5  0.4 \\\\\n0.4  0.5  3.0  0.5 \\\\\n0.3  0.4  0.5  3.0\n\\end{bmatrix}.\n$$\n这些分块将 $L$ 和 $C$ 定义为 $8 \\times 8$ 的分块矩阵。所选的 $C$ 仅在树形块上非零，这模拟了对于散度整合基函数，标量势项仅作用于无旋分量，从而引发低频崩溃这一事实。\n\n任务：\n- 对于下面测试套件中给定的每个 $k$，计算如上定义的 $\\kappa(Z(k))$ 和 $\\kappa(Z_{\\mathrm{pre}}(k))$。条件数是无量纲量。\n- 使用单位为 $\\mathrm{rad}/\\mathrm{m}$ 的 $k$，并使用 $\\omega = k \\, c$ 计算单位为 $\\mathrm{rad}/\\mathrm{s}$ 的 $\\omega$。\n\n测试套件（波数单位为 $\\mathrm{rad}/\\mathrm{m}$）：\n- 情况 1（常规情况）：$k = 1.0$。\n- 情况 2（中等小值）：$k = 0.1$。\n- 情况 3（小值）：$k = 0.01$。\n- 情况 4（边界情况，极小值）：$k = 10^{-6}$。\n- 情况 5（较大值）：$k = 5.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的、包含$10$个浮点值的逗号分隔列表。这些值必须按 $\\big[\\kappa(Z(1.0)), \\kappa(Z_{\\mathrm{pre}}(1.0)), \\kappa(Z(0.1)), \\kappa(Z_{\\mathrm{pre}}(0.1)), \\kappa(Z(0.01)), \\kappa(Z_{\\mathrm{pre}}(0.01)), \\kappa(Z(10^{-6})), \\kappa(Z_{\\mathrm{pre}}(10^{-6})), \\kappa(Z(5.0)), \\kappa(Z_{\\mathrm{pre}}(5.0))\\big]$ 的顺序排列。不应打印任何其他文本。",
            "solution": "我们从均匀各向同性介质中的时谐麦克斯韦方程组开始，其中磁导率为 $\\mu$，介电常数为 $\\epsilon$，角频率为 $\\omega$：\n$$\n\\nabla \\times \\mathbf{E} = - j \\,\\omega \\,\\mu \\, \\mathbf{H}, \\qquad \\nabla \\times \\mathbf{H} = j \\,\\omega \\,\\epsilon \\, \\mathbf{E} + \\mathbf{J},\n$$\n其中 $\\mathbf{J}$ 是源电流密度。对于理想电导体 (PEC) 散射，通过在表面上强制切向电场为零，可以得到散射场满足的边界积分方程。电场积分方程 (EFIE) 可以用矢量势（磁格林函数）和标量势（电格林函数）来表示。在使用散度整合基函数（例如 Rao-Wilton-Glisson (RWG) 函数）的伽辽金离散化中，EFIE 算子具有以下形式\n$$\nZ(\\omega) = j \\,\\omega \\,\\mu \\, L \\;+\\; \\frac{1}{j \\,\\omega \\,\\epsilon} \\, C,\n$$\n其中 $L$ 来自矢量势，$C$ 来自标量势，两者都是由边界积分算子定义的稠密矩阵。波数 $k$ 通过 $k = \\omega \\sqrt{\\mu \\epsilon}$ 与频率相关，或者 $\\omega = k \\, c$，其中光速 $c = \\frac{1}{\\sqrt{\\mu \\epsilon}}$。\n\n当 $k \\to 0$ 时，这两项的标度是不同的：矢量势项 $j \\,\\omega \\,\\mu \\, L$ 的行为类似于 $O(k)$，而标量势项 $\\frac{1}{j \\,\\omega \\,\\epsilon} C$ 的行为类似于 $O(1/k)$。对于散度整合子空间，无旋部分（树空间）受到 $C$ 的强烈影响，而无散部分（环空间）的散度为零，因此 $C$ 对环路块的作用可以忽略不计。在此处使用的简化分块结构模型中，\n$$\nL = \\begin{bmatrix} L_{\\ell\\ell}  L_{\\ell t} \\\\ L_{t\\ell}  L_{tt} \\end{bmatrix},\n\\qquad\nC = \\begin{bmatrix} C_{\\ell\\ell}  C_{\\ell t} \\\\ C_{t\\ell}  C_{tt} \\end{bmatrix},\n$$\n其中 $C_{\\ell\\ell} = C_{\\ell t} = C_{t\\ell} = 0$ 且 $C_{tt} \\neq 0$。因此，未经预条件处理的算子具有以下分块\n$$\nZ(k) = j \\, \\omega \\, \\mu \\begin{bmatrix} L_{\\ell\\ell}  L_{\\ell t} \\\\ L_{t\\ell}  L_{tt} \\end{bmatrix}\n\\;+\\;\n\\frac{1}{j \\, \\omega \\, \\epsilon} \\begin{bmatrix} 0  0 \\\\ 0  C_{tt} \\end{bmatrix}.\n$$\n在环路子空间上，当 $k \\to 0$ 时，主要贡献来自 $j \\,\\omega \\,\\mu \\, L_{\\ell\\ell}$，其标度类似于 $O(k)$。在树形子空间上，主要贡献来自 $\\frac{1}{j \\,\\omega \\,\\epsilon} C_{tt}$，其标度类似于 $O(1/k)$。因此，谱条件数满足\n$$\n\\kappa(Z(k)) \\approx \\frac{O(1/k)}{O(k)} = O\\!\\left(\\frac{1}{k^2}\\right),\n$$\n这代表了低频崩溃：随着 $k \\to 0$，算子变得越来越病态。\n\n为了缓解这个问题，环-树预条件处理通过缩放无散和无旋子空间来平衡这些项。一种实用的方法是应用双边对角变换，将与树子空间相关的测试函数和展开系数都乘以波数 $k$，同时保持环路子空间不变：\n$$\nM(k) = \\mathrm{diag}\\big( \\underbrace{1,\\dots,1}_{\\text{环路块}}, \\underbrace{k,\\dots,k}_{\\text{树形块}} \\big),\n\\qquad\nN(k) = \\mathrm{diag}\\big( \\underbrace{1,\\dots,1}_{\\text{环路块}}, \\underbrace{k,\\dots,k}_{\\text{树形块}} \\big),\n$$\n并定义\n$$\nZ_{\\mathrm{pre}}(k) = M(k) \\, Z(k) \\, N(k).\n$$\n考虑在此变换下这两部分贡献的标度：\n- 矢量势部分变为 $M(k) \\left( j \\, \\omega \\, \\mu \\, L \\right) N(k)$。因为 $M(k)$ 和 $N(k)$ 是对角矩阵，其在环路块上的因子为 $1$，在树形块上的因子为 $k$，并且 $L$ 耦合了环路和树形子空间，所以这部分的总体量级仍然按 $O(k)$ 缩放，但在子空间之间得到了平衡。\n- 标量势部分变为\n$$\nM(k) \\left( \\frac{1}{j \\, \\omega \\, \\epsilon} \\, C \\right) N(k) \\;=\\;\n\\frac{1}{j \\, \\omega \\, \\epsilon} \\, M(k) \\begin{bmatrix} 0  0 \\\\ 0  C_{tt} \\end{bmatrix} N(k)\n\\;=\\;\n\\frac{1}{j \\, \\omega \\, \\epsilon} \\begin{bmatrix} 0  0 \\\\ 0  k^2 \\, C_{tt} \\end{bmatrix}.\n$$\n由于 $\\frac{1}{\\omega}$ 的标度类似于 $1/k$，来自双边缩放的因子 $k^2$ 产生了一个总体的 $k$ 因子：$\\frac{1}{\\omega} \\cdot k^2 \\sim k$，因此预条件处理后的标量势贡献在整个树形子空间上的标度类似于 $O(k)$。因此，变换后的算子满足\n$$\nZ_{\\mathrm{pre}}(k) \\sim O(k) \\quad \\text{对于无散和无旋块皆是如此},\n$$\n从而得到一个在 $k \\to 0$ 时保持有界的条件数：\n$$\n\\kappa\\!\\left(Z_{\\mathrm{pre}}(k)\\right) = O(1).\n$$\n\n这种预处理思想与环-树（分层）静态预条件处理相一致，后者在低频时均衡了 EFIE 的无散部分和无旋部分的标度。请注意，多层快速多极子算法 (MLFMA) 加速了矩阵向量乘法，但并未改变算子的谱；因此，无论算子是直接应用还是通过 MLFMA 应用，条件数分析都同样适用。\n\n算法步骤：\n1. 设置物理常数 $c$、$\\mu_0$、$\\epsilon_0$，并为每个 $k$ 计算 $\\omega = k c$。\n2. 根据给定的分块组装 $8 \\times 8$ 矩阵 $L$ 和 $C$。\n3. 构建 $Z(k) = j \\, \\omega \\, \\mu_0 \\, L + \\frac{1}{j \\, \\omega \\, \\epsilon_0} \\, C$。\n4. 构建对角矩阵 $M(k)$ 和 $N(k)$，其对角线元素分别为 $(1,\\dots,1,k,\\dots,k)$，对应环路和树形索引。\n5. 构建 $Z_{\\mathrm{pre}}(k) = M(k) \\, Z(k) \\, N(k)$。\n6. 使用最大奇异值与最小奇异值的比值（即矩阵2-范数条件数）计算 $\\kappa(Z(k))$ 和 $\\kappa(Z_{\\mathrm{pre}}(k))$。\n7. 对所有测试波数重复以上步骤，并按指定的单行格式输出结果。\n\n此过程是自洽的，遵循从基本电磁定律推导出的 EFIE 低频标度特性，并提供了一个具体的数值验证，证明环-树预条件处理在 $k \\to 0$ 时能够稳定条件数。",
            "answer": "```python\nimport numpy as np\n\ndef build_blocks():\n    # Loop-loop block for L (4x4)\n    L_ll = np.array([\n        [2.0, 0.5, 0.3, 0.2],\n        [0.5, 2.0, 0.4, 0.3],\n        [0.3, 0.4, 2.0, 0.5],\n        [0.2, 0.3, 0.5, 2.0]\n    ], dtype=float)\n    # Tree-tree block for L (4x4)\n    L_tt = np.array([\n        [1.0, 0.3, 0.2, 0.1],\n        [0.3, 1.0, 0.3, 0.2],\n        [0.2, 0.3, 1.0, 0.3],\n        [0.1, 0.2, 0.3, 1.0]\n    ], dtype=float)\n    # Loop-tree and tree-loop coupling in L (4x4)\n    L_lt = np.array([\n        [0.2, 0.1, 0.1, 0.0],\n        [0.1, 0.2, 0.1, 0.1],\n        [0.1, 0.1, 0.2, 0.1],\n        [0.0, 0.1, 0.1, 0.2]\n    ], dtype=float)\n    L_tl = L_lt.T\n\n    # Assemble L (8x8)\n    top = np.hstack((L_ll, L_lt))\n    bottom = np.hstack((L_tl, L_tt))\n    L = np.vstack((top, bottom))\n\n    # C blocks: only tree-tree is nonzero to emulate scalar potential acting on irrotational space\n    C_ll = np.zeros((4,4), dtype=float)\n    C_lt = np.zeros((4,4), dtype=float)\n    C_tl = np.zeros((4,4), dtype=float)\n    C_tt = np.array([\n        [3.0, 0.5, 0.4, 0.3],\n        [0.5, 3.0, 0.5, 0.4],\n        [0.4, 0.5, 3.0, 0.5],\n        [0.3, 0.4, 0.5, 3.0]\n    ], dtype=float)\n\n    # Assemble C (8x8)\n    top_C = np.hstack((C_ll, C_lt))\n    bottom_C = np.hstack((C_tl, C_tt))\n    C = np.vstack((top_C, bottom_C))\n\n    return L, C\n\ndef efie_operator(k, L, C, mu0, eps0, c):\n    # omega = k c\n    omega = k * c\n    # Z(k) = j * omega * mu0 * L + (1/(j * omega * eps0)) * C\n    j = 1j\n    Z = j * omega * mu0 * L + (1.0 / (j * omega * eps0)) * C\n    return Z\n\ndef loop_tree_preconditioners(k, n_loop, n_tree):\n    # Two-sided diagonal scaling: M(k) and N(k)\n    # M has 1 for loop rows, k for tree rows\n    # N has 1 for loop cols, k for tree cols\n    M_diag = np.array([1.0]*n_loop + [k]*n_tree, dtype=float)\n    N_diag = np.array([1.0]*n_loop + [k]*n_tree, dtype=float)\n    M = np.diag(M_diag)\n    N = np.diag(N_diag)\n    return M, N\n\ndef condition_number(Z):\n    # Compute 2-norm condition number using SVD\n    s = np.linalg.svd(Z, compute_uv=False)\n    # Avoid division by zero in pathological cases\n    s_max = np.max(s)\n    s_min = np.min(s)\n    return float(s_max / s_min)\n\ndef solve():\n    # Physical constants\n    c = 299_792_458.0  # m/s\n    mu0 = 4.0e-7 * np.pi  # H/m\n    eps0 = 8.854187817e-12  # F/m\n\n    # Build operators\n    L, C = build_blocks()\n    n = L.shape[0]\n    n_loop = n_tree = n // 2\n\n    # Test suite of wavenumbers k [rad/m]\n    test_ks = [1.0, 0.1, 0.01, 1e-6, 5.0]\n\n    results = []\n    for k in test_ks:\n        Z = efie_operator(k, L, C, mu0, eps0, c)\n        kappa_Z = condition_number(Z)\n        M, N = loop_tree_preconditioners(k, n_loop, n_tree)\n        Z_pre = M @ Z @ N\n        kappa_Zpre = condition_number(Z_pre)\n        results.extend([kappa_Z, kappa_Zpre])\n\n    # Print single-line output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}