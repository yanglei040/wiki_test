{
    "hands_on_practices": [
        {
            "introduction": "要真正领会预修正快速傅里叶变换（pFFT）方法的威力，量化其相对于传统方法的优势至关重要。第一个实践练习将聚焦于一个基本方面：内存效率。通过为一个实际的电磁问题计算和比较内存占用 ，你将具体理解 pFFT 方法为何能够解决那些使用密集矩阵方法难以处理的大规模问题。",
            "id": "3343090",
            "problem": "一个边长为 $L_{x} = 1~\\mathrm{m}$、$L_{y} = 0.5~\\mathrm{m}$ 和 $L_{z} = 0.2~\\mathrm{m}$ 的矩形理想导电盒，通过使用矩量法 (MoM) 离散化的表面电流公式进行建模。假设在频率 $f = 3~\\mathrm{GHz}$ 和光速 $c = 3 \\times 10^{8}~\\mathrm{m/s}$ 下进行时谐激励，因此波长为 $\\lambda = c/f$。设表面网格的平均边长为 $h = \\lambda/10$。对于 Rao–Wilton–Glisson 基函数，将未知数的数量近似为 $N \\approx 2A/h^{2}$，其中 $A = 2(L_{x}L_{y} + L_{x}L_{z} + L_{y}L_{z})$ 是总表面积。\n\n考虑使用预修正快速傅里叶变换 (pFFT) 方法加速矩阵-向量乘积。pFFT 使用一个均匀的三维卷积网格，其沿各轴的间距与 $h$ 相匹配，因此网格大小为 $n_{x} = L_{x}/h$、$n_{y} = L_{y}/h$ 和 $n_{z} = L_{z}/h$，网格点总数为 $M = n_{x} n_{y} n_{z}$。假设 pFFT 具有以下内存组件：\n- 一组 $a = 4$ 个复数实空间或工作空间网格数组，每个数组的长度为 $M$。\n- 一个预先计算的谱域标量格林函数核，存储为 $k = 1$ 个长度为 $M$ 的复数网格数组。\n- 一个以压缩稀疏行 (CSR) 格式存储的稀疏预修正矩阵，每行平均有 $s = 60$ 个非零元。在 CSR 中，复数值以每个复数 $b_{c} = 16$ 字节存储，列索引以每个整数 $b_{i} = 4$ 字节存储，长度为 $N+1$ 的行指针数组以每个整数 $b_{i} = 4$ 字节存储。\n\n对于密集 MoM，假设阻抗矩阵存储为 $N \\times N$ 个复双精度条目，每个条目占用 $b_{c} = 16$ 字节。\n\n从以上定义和离散化假设出发，推导 pFFT 和密集 MoM 的总内存（以字节为单位）的符号表达式，代入给定参数，并计算比率\n$$R = \\frac{\\text{memory}_{\\mathrm{pFFT}}}{\\text{memory}_{\\mathrm{MoM}}}.$$\n将最终比率 $R$ 表示为小数，并将您的答案四舍五入到四位有效数字。",
            "solution": "首先根据既定标准对问题陈述进行验证。\n\n### 第 1 步：提取已知条件\n- 矩形盒的边长：$L_{x} = 1~\\mathrm{m}$、$L_{y} = 0.5~\\mathrm{m}$、$L_{z} = 0.2~\\mathrm{m}$。\n- 激励频率：$f = 3~\\mathrm{GHz} = 3 \\times 10^{9}~\\mathrm{Hz}$。\n- 光速：$c = 3 \\times 10^{8}~\\mathrm{m/s}$。\n- 波长定义：$\\lambda = c/f$。\n- 表面网格的平均边长：$h = \\lambda/10$。\n- 未知数数量的近似（Rao–Wilton–Glisson 基函数）：$N \\approx 2A/h^{2}$。\n- 总表面积：$A = 2(L_{x}L_{y} + L_{x}L_{z} + L_{y}L_{z})$。\n- pFFT 卷积网格大小：$n_{x} = L_{x}/h$、$n_{y} = L_{y}/h$、$n_{z} = L_{z}/h$。\n- pFFT 网格点总数：$M = n_{x} n_{y} n_{z}$。\n- pFFT 工作空间网格数组数量：$a = 4$。\n- pFFT 格林函数核数组数量：$k = 1$。\n- 稀疏预修正矩阵每行的平均非零元数：$s = 60$。\n- 每个复数的字节数：$b_{c} = 16$。\n- CSR 格式中每个整数的字节数：$b_{i} = 4$。\n- 密集 MoM 阻抗矩阵大小：$N \\times N$，每个条目都是一个复数。\n- 要求输出：比率 $R = \\frac{\\text{memory}_{\\mathrm{pFFT}}}{\\text{memory}_{\\mathrm{MoM}}}$ 四舍五入到四位有效数字。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题具有科学依据，为计算电磁学中两种公认的数值方法（密集 MoM 和 pFFT）提供了内存需求的标准比较。所有术语均按该领域的常规方式定义。该问题是适定的，提供了计算唯一数值答案所需的所有参数和公式。该设置是自洽且一致的。不存在科学、逻辑或事实上的缺陷。\n\n### 第 3 步：结论与行动\n该问题被判定为**有效**。将提供完整的解答。\n\n首先，我们推导每种方法所需内存的符号表达式。\n\n对于密集矩量法 (MoM)，内存主要由存储 $N \\times N$ 阻抗矩阵所占用。由于每个元素都是一个需要 $b_{c}$ 字节的复数，总内存为：\n$$ \\text{memory}_{\\mathrm{MoM}} = N^{2} b_{c} $$\n\n对于预修正快速傅里叶变换 (pFFT) 方法，总内存是三个组成部分的总和：\n1.  工作空间和核网格数组。有 $a$ 个工作空间数组和 $k$ 个核数组，每个都是大小为 $M$ 的复数网格。这部分的内存为：\n    $$ \\text{memory}_{\\mathrm{grids}} = (a + k) M b_{c} $$\n2.  稀疏预修正矩阵，以压缩稀疏行 (CSR) 格式存储。行数为 $N$，每行平均非零元素数量为 $s$。因此，非零元总数约为 $\\text{nnz} = Ns$。CSR 格式需要存储：\n    - 非零复数值：$\\text{nnz} \\times b_{c} = N s b_{c}$。\n    - 每个非零值的列索引：$\\text{nnz} \\times b_{i} = N s b_{i}$。\n    - 长度为 $N+1$ 的行指针数组：$(N+1) b_{i}$。\n    预修正矩阵的总内存为：\n    $$ \\text{memory}_{\\mathrm{CSR}} = N s b_{c} + N s b_{i} + (N+1) b_{i} = N s (b_{c} + b_{i}) + (N+1) b_{i} $$\n\npFFT 方法的总内存是这些组成部分的总和：\n$$ \\text{memory}_{\\mathrm{pFFT}} = \\text{memory}_{\\mathrm{grids}} + \\text{memory}_{\\mathrm{CSR}} = (a + k) M b_{c} + N s (b_{c} + b_{i}) + (N+1) b_{i} $$\n\n因此，比率 $R$ 为：\n$$ R = \\frac{\\text{memory}_{\\mathrm{pFFT}}}{\\text{memory}_{\\mathrm{MoM}}} = \\frac{(a + k) M b_{c} + N s (b_{c} + b_{i}) + (N+1) b_{i}}{N^{2} b_{c}} $$\n\n接下来，我们根据给定数据计算中间参数的数值。\n波长 $\\lambda$ 是：\n$$ \\lambda = \\frac{c}{f} = \\frac{3 \\times 10^{8}~\\mathrm{m/s}}{3 \\times 10^{9}~\\mathrm{Hz}} = 0.1~\\mathrm{m} $$\n网格的平均边长 $h$ 是：\n$$ h = \\frac{\\lambda}{10} = \\frac{0.1~\\mathrm{m}}{10} = 0.01~\\mathrm{m} $$\n盒子的总表面积 $A$ 是：\n$$ A = 2(L_{x}L_{y} + L_{x}L_{z} + L_{y}L_{z}) = 2((1)(0.5) + (1)(0.2) + (0.5)(0.2))~\\mathrm{m}^{2} $$\n$$ A = 2(0.5 + 0.2 + 0.1)~\\mathrm{m}^{2} = 2(0.8)~\\mathrm{m}^{2} = 1.6~\\mathrm{m}^{2} $$\n未知数的数量 $N$ 是：\n$$ N \\approx \\frac{2A}{h^{2}} = \\frac{2(1.6)}{(0.01)^{2}} = \\frac{3.2}{0.0001} = 32000 $$\npFFT 网格的维度是：\n$$ n_{x} = \\frac{L_{x}}{h} = \\frac{1}{0.01} = 100 $$\n$$ n_{y} = \\frac{L_{y}}{h} = \\frac{0.5}{0.01} = 50 $$\n$$ n_{z} = \\frac{L_{z}}{h} = \\frac{0.2}{0.01} = 20 $$\n网格点总数 $M$ 是：\n$$ M = n_{x} n_{y} n_{z} = (100)(50)(20) = 100000 $$\n\n现在，我们可以计算每种方法所需的内存（以字节为单位）。\n$$ \\text{memory}_{\\mathrm{MoM}} = N^{2} b_{c} = (32000)^{2} \\times 16 = 1024000000 \\times 16 = 16384000000~\\text{bytes} $$\n对于 pFFT 内存，我们使用以下数值：$a=4$、$k=1$、$s=60$、$b_{c}=16$、$b_{i}=4$、$N=32000$ 和 $M=100000$。\n$$ \\text{memory}_{\\mathrm{pFFT}} = (4+1)(100000)(16) + (32000)(60)(16+4) + (32000+1)(4) $$\n$$ \\text{memory}_{\\mathrm{pFFT}} = (5)(100000)(16) + (32000)(60)(20) + (32001)(4) $$\n$$ \\text{memory}_{\\mathrm{pFFT}} = 8000000 + 38400000 + 128004 $$\n$$ \\text{memory}_{\\mathrm{pFFT}} = 46528004~\\text{bytes} $$\n\n最后，我们计算比率 $R$：\n$$ R = \\frac{46528004}{16384000000} \\approx 0.00283984399 $$\n将结果四舍五入到四位有效数字，得到：\n$$ R \\approx 0.002840 $$\n这个结果表明，对于这类问题，pFFT 方法相比于密集 MoM 具有显著的内存优势。",
            "answer": "$$\\boxed{0.002840}$$"
        },
        {
            "introduction": "了解了 pFFT 的高效性之后，我们现在深入探讨其核心机制：预修正技术。该方法的精度关键在于修正基于 FFT 的卷积所引入的近场误差。这项动手实践将指导你实现并验证这一关键步骤 ，通过对比简单的点采样近似与高精度的直接积分计算，来揭示预修正的必要性与有效性。",
            "id": "3343124",
            "problem": "给定单位正方形上的一个均匀方形网格，由 $M \\times M$ 个面元组成，面元边长为 $h = 1/M$，其中心位于笛卡尔坐标 $x_i = \\left( \\left(i_x + \\tfrac{1}{2}\\right)h,\\left(i_y + \\tfrac{1}{2}\\right)h \\right)$，其中 $i_x,i_y \\in \\{0,1,\\dots,M-1\\}$。考虑在此网格上使用一个平滑衰减核，对分段常数源分布 $q(x)$ 的势进行卷积表示：\n$$\nK(r) = \\frac{e^{-\\mu r}}{\\sqrt{r^2 + \\epsilon^2}},\n$$\n其中 $r$ 是欧几里得距离，$\\mu > 0$ 是一个衰减参数，$\\epsilon > 0$ 是一个正则化长度，它模拟了有限厚度的基函数并移除了 $r=0$ 处的奇点。面元中心的离散势将通过在方形面元上进行面元到面元的相互作用来计算。\n\n预校正快速傅里叶变换（PC-FFT）方法通过用更高精度的积分替换那些近邻网格偏移项，来校正基于傅里叶的卷积中由点采样引入的近场相互作用的不准确性。在本问题中，你将：\n\n1.  构建一个大小为 $(2M-1)\\times(2M-1)$ 的点采样离散核 $K_{\\text{pt}}(u,v)$，它通过以下方式近似偏移量为 $(u,v) \\in \\{-M+1,\\dots,M-1\\}^2$ 的面元到面元的相互作用：\n    $$\n    K_{\\text{pt}}(u,v) = h^2 K\\left(\\sqrt{(uh)^2 + (vh)^2}\\right),\n    $$\n    这对应于将源面元的贡献近似为其中心的贡献，并按面元面积 $h^2$ 进行缩放。\n\n2.  通过计算以下积分，构建一个相同大小的直接求积离散核 $K_{\\text{dir}}(u,v)$：\n    $$\n    K_{\\text{dir}}(u,v) \\approx \\iint_{P_{u,v}} K\\left(\\sqrt{(uh + \\Delta x)^2 + (vh + \\Delta y)^2}\\right)\\, d\\Delta x\\, d\\Delta y,\n    $$\n    其中 $P_{u,v}$ 是中心位于 $(uh,vh)$、边长为 $h$ 的源面元正方形，积分使用张量积中点法则（每个维度 $S$ 个点）进行评估。具体来说，使用中点 $\\Delta x_i = \\left(\\frac{i+\\frac{1}{2}}{S} - \\frac{1}{2}\\right)h$ 和 $\\Delta y_j = \\left(\\frac{j+\\frac{1}{2}}{S} - \\frac{1}{2}\\right)h$（其中 $i,j\\in\\{0,1,\\dots,S-1\\}$）以及权重 $w = h^2/S^2$：\n    $$\n    K_{\\text{dir}}(u,v) \\approx \\sum_{i=0}^{S-1}\\sum_{j=0}^{S-1} K\\left(\\sqrt{(uh + \\Delta x_i)^2 + (vh + \\Delta y_j)^2}\\right)\\, w.\n    $$\n\n3.  将近场模板定义为满足 $|u| \\le r_c$ 和 $|v| \\le r_c$ 的偏移量 $(u,v)$ 集合，其中 $r_c$ 是一个小的非负整数半径。构建预校正核 $K_{\\text{pc}}(u,v)$ 如下：\n    $$\n    K_{\\text{pc}}(u,v) = \\begin{cases}\n    K_{\\text{dir}}(u,v),  \\text{若 } |u|\\le r_c \\text{ 且 } |v|\\le r_c,\\\\\n    K_{\\text{pt}}(u,v),  \\text{其他情况}。\n    \\end{cases}\n    $$\n\n4.  对于一个确定性源分布 $q_{i_x,i_y} = \\sin(2\\pi x_{i_x})\\sin(2\\pi y_{i_y}) + 0.25\\cos(4\\pi x_{i_x})$，使用快速傅里叶变换（FFT）通过以下关系，在面元中心计算由核 $K_{\\text{pt}}$、$K_{\\text{pc}}$ 和 $K_{\\text{dir}}$ 产生的势的线性卷积：\n    $$\n    \\phi(\\cdot) = (q * K)(\\cdot)\n    $$\n    使用基于二维 FFT 的卷积来实现线性卷积。所有量都是无量纲的。\n\n从边界积分方程中势的积分表示和计算电磁学中 PC-FFT 方法的定义出发，推导为什么近场校正是必要的，以及它是如何如上实现的。然后，通过计算以下量，量化预校正对最坏情况近场项的影响，并确认校正后的值与直接结果相匹配：\n\n- 点采样核的最坏情况下的近场项绝对误差：\n  $$\n  E_{\\text{near}}^{\\text{pt}} = \\max_{\\substack{|u|\\le r_c\\\\|v|\\le r_c}} \\left|K_{\\text{dir}}(u,v) - K_{\\text{pt}}(u,v)\\right|.\n  $$\n\n- 预校正后最坏情况下的近场项绝对误差：\n  $$\n  E_{\\text{near}}^{\\text{pc}} = \\max_{\\substack{|u|\\le r_c\\\\|v|\\le r_c}} \\left|K_{\\text{dir}}(u,v) - K_{\\text{pc}}(u,v)\\right|.\n  $$\n\n- 比较 $K_{\\text{pt}}$ 与 $K_{\\text{dir}}$ 时，仅近场势贡献的最坏情况绝对误差：\n  $$\n  E_{\\phi,\\text{near}}^{\\text{pt}} = \\max_{i_x,i_y} \\left| \\left(q * K_{\\text{pt,near}}\\right)_{i_x,i_y} - \\left(q * K_{\\text{dir,near}}\\right)_{i_x,i_y} \\right|,\n  $$\n  其中 $K_{\\text{pt,near}}$ 和 $K_{\\text{dir,near}}$ 是在近场模板上等于 $K_{\\text{pt}}$ 或 $K_{\\text{dir}}$，在其他地方为零的核。\n\n- 一个布尔值，指示预校正的仅近场势是否在数值容差 $10^{-12}$ 内与直接的仅近场势完全匹配：\n  $$\n  B_{\\text{near}}^{\\text{pc}} = \\left[ \\max_{i_x,i_y} \\left| \\left(q * K_{\\text{pc,near}}\\right)_{i_x,i_y} - \\left(q * K_{\\text{dir,near}}\\right)_{i_x,i_y} \\right|  10^{-12} \\right],\n  $$\n  其中 $K_{\\text{pc,near}}$ 在近场模板上等于 $K_{\\text{pc}}$，在其他地方为零。\n\n您的程序必须对以下参数值测试套件实现上述计算，每个案例指定为 $(M,r_c,\\mu,S)$，并将 $\\epsilon$ 设置为 $\\epsilon = 0.5h$：\n- 案例 1（一般情况）：$(M=12, r_c=1, \\mu=0.04, S=48)$。\n- 案例 2（自相互作用项边界情况）：$(M=10, r_c=0, \\mu=0.02, S=64)$。\n- 案例 3（更宽的近场模板情况）：$(M=14, r_c=2, \\mu=0.08, S=32)$。\n\n所有量都是无量纲的，且不出现角度。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。对于每个测试案例，输出一个包含四个条目的子列表，顺序为 $[E_{\\text{near}}^{\\text{pt}}, E_{\\text{near}}^{\\text{pc}}, E_{\\phi,\\text{near}}^{\\text{pt}}, B_{\\text{near}}^{\\text{pc}}]$，并将三个子列表聚合成一个单一列表，例如，\"[[x11,x12,x13,b1],[x21,x22,x23,b2],[x31,x32,x33,b3]]\"，其中每个 $xij$ 是一个浮点数，每个 $bk$ 是一个布尔值。",
            "solution": "当前的问题是在积分方程的数值方法领域中一个明确定义的计算练习，具体涉及预校正快速傅里叶变换（PC-FFT）方法。所有参数、方程和任务都得到了足够清晰的说明，并且在科学上是合理的，为一个数值解构成了有效的基础。该问题植根于计算电磁学和物理学的既定原理，涉及通过与正则化的屏蔽库仑核进行卷积来计算势。该过程是客观、一致且计算可行的。因此，可以构建一个完整的解决方案。\n\n在许多物理学和工程领域，基本任务是计算由一个定义域 $\\Omega$ 上的源分布 $q(x')$ 产生的势场 $\\phi(x)$。这由第一类弗雷德霍姆积分方程表示：\n$$\n\\phi(x) = \\int_{\\Omega} K(x, x') q(x') d\\Omega'\n$$\n这里，$K(x, x')$ 是核函数或格林函数，描述了位于 $x'$ 的点源对 $x$ 处势的影响。对于在均匀网格上具有平移不变性的问题，核函数仅取决于位移矢量 $x-x'$，即 $K(x, x') = K(x-x')$。\n\n直接用数值方法求解此积分方程通常涉及将定义域 $\\Omega$ 离散化为一组 $N$ 个更小的元素或面元，即 $\\{P_j\\}_{j=1}^N$。假设源为分段常数近似，即对于所有 $x' \\in P_j$，$q(x') = q_j$，则面元 $P_i$ 中心 $x_i$ 处的势由以下求和给出：\n$$\n\\phi_i = \\sum_{j=1}^{N} q_j \\left( \\int_{P_j} K(x_i - x') d\\Omega' \\right)\n$$\n这可以写成矩阵向量乘积 $\\boldsymbol{\\phi} = \\mathbf{A}\\mathbf{q}$，其中矩阵项 $A_{ij}$ 是核在源面元 $P_j$ 上的积分。对于一个 $M \\times M$ 面元的均匀网格，$N=M^2$，相互作用矩阵 $\\mathbf{A}$ 成为一个块托普利茨矩阵，反映了平移不变性。矩阵向量乘积是一个离散卷积：\n$$\n\\phi_i = \\sum_{j} q_j \\mathcal{K}_{i-j}\n$$\n其中 $\\mathcal{K}_{i-j} = \\int_{P_j} K(x_i - x') d\\Omega'$ 是对应于偏移量 $i-j$ 的面元积分核。这种卷积可以使用快速傅里叶变换（FFT）以 $O(N \\log N)$ 的计算复杂度计算，通过卷积定理：$\\mathcal{F}(\\boldsymbol{\\phi}) = \\mathcal{F}(\\mathbf{q}) \\odot \\mathcal{F}(\\boldsymbol{\\mathcal{K}})$，其中 $\\odot$ 表示逐元素乘积。\n\n近场校正的必要性源于使用这种基于 FFT 的方法的实际困难。FFT 需要在网格上获得核函数值 $\\mathcal{K}$。对 $\\mathcal{K}_{i-j}$ 的一个直接且计算成本低的近似是使用点对点相互作用，其中整个源面元 $P_j$ 由其中心 $x_j$ 处的一个点电荷表示。然后，该相互作用按面元面积 $h^2$ 进行缩放。这就产生了问题中定义的点采样核：\n$$\nK_{\\text{pt}}(x_i - x_j) = h^2 K(x_i - x_j)\n$$\n只有当面元之间的距离 $|x_i - x_j|$ 远大于面元尺寸 $h$ 时，这种近似才是准确的。对于邻近的面元（“近场”），核函数 $K(r)$ 在源面元 $P_j$ 的区域内可能变化很大。对于给定的核 $K(r) = e^{-\\mu r}/\\sqrt{r^2 + \\epsilon^2}$，当 $r$ 很小时，函数及其梯度都很大，使得点采样近似对于小间距非常不准确。近场核项的这种不准确性导致计算出的势 $\\boldsymbol{\\phi}$ 出现显著误差。\n\n预校正快速傅里叶变换（PC-FFT）方法修正了这个问题。其核心思想是，对于大部分相互作用（“远场”），使用高效的基于 FFT 的卷积，因为此时它是准确的；并校正错误的近场贡献。这是通过在执行卷积之前创建一个“预校正”核 $K_{\\text{pc}}$ 来实现的。\n\n正如问题中所述，这是按以下方式实现的：\n1.  对于所选半径 $r_c$ 内的近场偏移 $(u,v)$，计算一个高精度的“直接”核 $K_{\\text{dir}}(u,v)$。这是通过使用高阶数值求积来近似积分 $\\int_{P_j} K(x_i - x') d\\Omega'$，为相互作用提供一个基准值。\n2.  对于所有其他的“远场”偏移，使用成本低廉的点采样核 $K_{\\text{pt}}(u,v)$。\n3.  将这两者结合起来形成预校正核：\n    $$\n    K_{\\text{pc}}(u,v) = \\begin{cases}\n    K_{\\text{dir}}(u,v),  \\text{若 } |u|\\le r_c \\text{ 且 } |v|\\le r_c \\text{ (近场)}\\\\\n    K_{\\text{pt}}(u,v),  \\text{其他情况 (远场)}\n    \\end{cases}\n    $$\n最终的势随后通过源 $q$ 与此混合核 $K_{\\text{pc}}$ 的基于 FFT 的卷积一步计算得出。该方法有效地用其准确的、直接积分的对应项替换了点采样核中不准确的近场项。由于近场相互作用的数量很少（与 $(2r_c+1)^2$ 成正比），为这少数偏移计算 $K_{\\text{dir}}$ 的成本是可控的，并且保留了基于 FFT 的卷积的整体 $O(N \\log N)$ 复杂度。\n\n待计算的量用于验证这一推理：\n- $E_{\\text{near}}^{\\text{pt}}$ 量化了点采样近似在近场中引入的巨大误差。\n- $E_{\\text{near}}^{\\text{pc}}$ 确认预校正步骤成功替换了近场核项，将这些特定项的误差减小到零（在机器精度内）。\n- $E_{\\phi,\\text{near}}^{\\text{pt}}$ 衡量了近场核误差对最终势计算的影响，隔离了来自近邻相互作用的贡献。\n- $B_{\\text{near}}^{\\text{pc}}$ 确认，当使用预校正核计算时，来自近邻的势贡献与使用高精度直接求积核为相同邻居计算的势完全匹配。这证明了校正的有效性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import fftconvolve\nimport math\n\ndef solve():\n    \"\"\"\n    Implements the PC-FFT analysis for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (M, r_c, mu, S)\n        (12, 1, 0.04, 48),\n        (10, 0, 0.02, 64),\n        (14, 2, 0.08, 32),\n    ]\n\n    all_results = []\n\n    for M, r_c, mu, S in test_cases:\n        h = 1.0 / M\n        epsilon = 0.5 * h\n\n        # Define the kernel function K(r)\n        def kernel_func(r, mu_param, eps_param):\n            # Handle r=0 case, which is possible with uh=0, vh=0\n            # and dx=0, dy=0 in quadrature, though unlikely with midpoint rule.\n            # The epsilon term prevents division by zero.\n            return np.exp(-mu_param * r) / np.sqrt(r**2 + eps_param**2)\n\n        # 1. Construct kernels K_pt and K_dir\n        kernel_size = 2 * M - 1\n        K_pt = np.zeros((kernel_size, kernel_size))\n        K_dir = np.zeros((kernel_size, kernel_size))\n\n        u_offsets = np.arange(-M + 1, M)\n        v_offsets = np.arange(-M + 1, M)\n        \n        # Grid of offsets (u,v) for vectorization\n        U_grid, V_grid = np.meshgrid(u_offsets, v_offsets, indexing='xy')\n        \n        # Point-sampled kernel K_pt\n        R_pt = np.sqrt((U_grid * h)**2 + (V_grid * h)**2)\n        K_pt = h**2 * kernel_func(R_pt, mu, epsilon)\n\n        # Direct-quadrature kernel K_dir\n        quad_indices = np.arange(S)\n        delta_x = ((quad_indices + 0.5) / S - 0.5) * h\n        delta_y = ((quad_indices + 0.5) / S - 0.5) * h\n        w = h**2 / S**2\n        \n        # Vectorized quadrature summation\n        for v_idx, v in enumerate(v_offsets):\n            for u_idx, u in enumerate(u_offsets):\n                # Positions inside the source panel relative to the origin\n                x_quad = u * h + delta_x[:, np.newaxis]\n                y_quad = v * h + delta_y[np.newaxis, :]\n                \n                # Distances for all quadrature points\n                r_quad = np.sqrt(x_quad**2 + y_quad**2)\n                \n                # Sum kernel values and multiply by weight\n                integral_sum = np.sum(kernel_func(r_quad, mu, epsilon))\n                K_dir[v_idx, u_idx] = integral_sum * w\n\n        # 2. Define near-field stencil and build K_pc\n        near_mask = (np.abs(U_grid) = r_c)  (np.abs(V_grid) = r_c)\n        \n        K_pc = K_pt.copy()\n        K_pc[near_mask] = K_dir[near_mask]\n\n        # 3. Compute error metrics for kernels\n        E_near_pt = np.max(np.abs(K_dir[near_mask] - K_pt[near_mask])) if np.any(near_mask) else 0.0\n        E_near_pc = np.max(np.abs(K_dir[near_mask] - K_pc[near_mask])) if np.any(near_mask) else 0.0\n\n        # 4. Compute potential contributions via convolution\n        # Source distribution q\n        ix = np.arange(M)\n        iy = np.arange(M)\n        x_centers = (ix + 0.5) * h\n        y_centers = (iy + 0.5) * h\n        X_q, Y_q = np.meshgrid(x_centers, y_centers, indexing='xy')\n        q = np.sin(2 * np.pi * X_q) * np.sin(2 * np.pi * Y_q) + 0.25 * np.cos(4 * np.pi * X_q)\n\n        # Near-field-only kernels\n        K_pt_near = np.zeros_like(K_pt)\n        K_pt_near[near_mask] = K_pt[near_mask]\n        \n        K_dir_near = np.zeros_like(K_dir)\n        K_dir_near[near_mask] = K_dir[near_mask]\n        \n        K_pc_near = np.zeros_like(K_pc)\n        K_pc_near[near_mask] = K_pc[near_mask]\n\n        # Convolutions\n        # scipy.signal.fftconvolve with mode='same' calculates the linear convolution\n        # and returns the central part of the output that is the same size as the first input (q).\n        phi_pt_near = fftconvolve(q, K_pt_near, mode='same')\n        phi_dir_near = fftconvolve(q, K_dir_near, mode='same')\n        phi_pc_near = fftconvolve(q, K_pc_near, mode='same')\n        \n        # Error metrics for potential\n        E_phi_near_pt = np.max(np.abs(phi_pt_near - phi_dir_near))\n        \n        # Boolean check for PC potential\n        B_near_pc = np.max(np.abs(phi_pc_near - phi_dir_near))  1e-12\n\n        all_results.append([E_near_pt, E_near_pc, E_phi_near_pt, B_near_pc])\n\n    # Final print statement\n    # The string representation of list of lists with booleans will be e.g.,\n    # [[0.1, 0.0, 0.2, True], [0.3, 0.0, 0.4, True]]\n    # This is joined by commas to give:\n    # \"[[0.1, 0.0, 0.2, True],[0.3, 0.0, 0.4, True]]\"\n    # as string, which matches the required format schema.\n    final_str = \",\".join(map(str, all_results))\n    print(f\"[{final_str}]\")\n\n\nsolve()\n\n```"
        },
        {
            "introduction": "我们的最后一个实践练习将探讨一个更微妙但对 pFFT 方法的稳定性至关重要的方面：离散电荷守恒。一个稳健的数值方案必须尊重其背后的物理原理，而在电磁学中，这包括电荷守恒。这项练习将向你展示，投影算子中一个看似微小的缺陷如何导致灾难性的低频不稳定性 ，从而让你深刻体会到理论严谨性在计算科学中的重要性。",
            "id": "3343081",
            "problem": "您的任务是构建一个最小数值实验，以分离并展示在计算电磁学的预修正快速傅里叶变换 (pFFT) 方法中，投影算子内部电荷守恒的作用。重点在于验证，违反投影算子中的离散电荷守恒会导致由格林函数的零波数分量驱动的低频不稳定性。您的程序必须从基本原理出发实现以下内容。\n\n从频域中的连续性方程和位势理论开始。频域连续性方程为 $i \\omega \\rho + \\nabla \\cdot \\mathbf{J} = 0$，这意味着任何一致的离散化都必须满足电荷守恒。考虑一个标量屏蔽泊松模型作为频域亥姆霍兹算子的代理，其格林函数 $G$ 满足 $(k^{2} - \\nabla^{2}) G = \\delta$，傅里叶符号为 $\\widehat{G}(\\boldsymbol{\\xi}) = \\frac{1}{k^{2} + \\|\\boldsymbol{\\xi}\\|^{2}}$。零波数 ($\\boldsymbol{\\xi}=\\mathbf{0}$) 分量为 $\\widehat{G}(\\mathbf{0}) = 1/k^{2}$，当 $k \\to 0$ 时，该值会变得任意大。在 pFFT 中，源通过一个投影（或“电荷分配”）算子 $P$ 映射到一个均匀网格上，在傅里叶域中使用快速傅里叶变换 (FFT) 进行卷积，然后通过 $P^{T}$ 映射回来。$P$ 的单位分解性质确保了在离散层面上的总电荷守恒。如果 $P$ 以一种与源电荷相关的方式破坏了这一性质，那么即使真实源的净电荷为零，也可能会引入一个非零的直流 (DC) 分量。该直流分量被因子 $\\widehat{G}(\\mathbf{0}) = 1/k^{2}$ 放大，从而产生低频不稳定性。\n\n实现一个具有以下规格的一维、周期性、离散的 pFFT 矩阵向量乘积模拟器：\n\n- 几何结构与采样：\n  - 长度为 $1$ 的周期性域。\n  - 包含 $M$ 个节点的均匀网格，节点位置为 $x_{j} = \\frac{j}{M}$，其中 $j \\in \\{0,1,\\dots,M-1\\}$。\n  - $N$ 个源面元，位置为 $x_{i}^{(p)} = \\frac{i + 1/2}{N}$，其中 $i \\in \\{0,1,\\dots,N-1\\}$。\n\n- 源电荷：\n  - 定义一个中性源向量 $q \\in \\mathbb{R}^{N}$，其中对于 $0 \\le i  N/2$，$q_{i} = 1$；对于 $N/2 \\le i  N$，$q_{i} = -1$。这确保了 $\\sum_{i=0}^{N-1} q_{i} = 0$。\n\n- 投影（电荷分配）算子 $P$ (一维中的一阶“云中单元”)：\n  - 令面元 $i$ 的小数坐标为 $\\alpha_{i} = M x_{i}^{(p)} - \\lfloor M x_{i}^{(p)} \\rfloor \\in [0,1)$，其左侧网格索引为 $j_{i} = \\lfloor M x_{i}^{(p)} \\rfloor$（索引对 $M$ 取模）。\n  - 守恒情况：从面元 $i$ 到节点 $j_{i}$ 和 $j_{i}+1$ 的两个非零权重为 $w_{\\text{L}}^{(i)} = 1 - \\alpha_{i}$ 和 $w_{\\text{R}}^{(i)} = \\alpha_{i}$。由于对所有 $i$ 都有 $w_{\\text{L}}^{(i)} + w_{\\text{R}}^{(i)} = 1$，这满足单位分解性质。\n  - 故意破坏（非守恒）的情况：定义一个依赖于面元的缩放因子 $s_{i} = 1 + \\varepsilon \\, q_{i}$，其中 $\\varepsilon  0$。将权重替换为 $\\widetilde{w}_{\\text{L}}^{(i)} = s_{i} \\, (1 - \\alpha_{i})$ 和 $\\widetilde{w}_{\\text{R}}^{(i)} = s_{i} \\, \\alpha_{i}$。这违反了单位分解性质，因为 $\\widetilde{w}_{\\text{L}}^{(i)} + \\widetilde{w}_{\\text{R}}^{(i)} = s_{i} \\ne 1$ 且与 $q_{i}$ 相关。因此，即使 $\\sum_{i} q_{i} = 0$，网格上累积的电荷也会获得一个非零的直流分量：\n    $\n    \\sum_{j=0}^{M-1} (P q)_{j} = \\sum_{i=0}^{N-1} s_{i} q_{i} = \\sum_{i=0}^{N-1} (1 + \\varepsilon q_{i}) q_{i} = \\varepsilon \\sum_{i=0}^{N-1} q_{i}^{2} = \\varepsilon N.\n    $\n    这个直流泄漏随后被零波数处的傅里叶符号 $\\widehat{G}(\\mathbf{0}) = 1/k^{2}$ 放大，产生低频不稳定性。\n\n- 傅里叶域卷积：\n  - 使用网格上的离散傅里叶变换计算与屏蔽泊松格林函数的卷积。令角频率为 $\\xi_{m} = 2\\pi \\, m$，其中 $m \\in \\{0,1,\\dots,M-1\\}$，按标准离散傅里叶变换周期性解释（负频率折叠）。定义符号\n    $\n    \\widehat{G}(\\xi_{m}) = \\frac{1}{k^{2} + \\xi_{m}^{2}}.\n    $\n    网格电位通过以下方式获得：\n    $\n    \\phi = \\mathcal{F}^{-1}\\!\\left( \\widehat{G} \\cdot \\mathcal{F}(P q) \\right).\n    $\n    然后通过反向投影 $v = P^{T} \\phi$ 获得面元电位，使用与前向投影中相同的权重（守恒或破坏的）。\n\n- 矩阵向量乘积总结：\n  - 总体算子为 $v = P^{T} \\, \\mathcal{F}^{-1}\\!\\left( \\widehat{G} \\cdot \\mathcal{F}(P q) \\right)$，在守恒和破坏的情况下都是如此，但使用的 $P$ 不同。\n\n- 报告的度量指标：\n  - 对于每个测试用例，计算面元电位向量 $v$ 的欧几里得范数 $\\|v\\|_{2}$。该度量指标是无量纲的。\n\n要实现和评估的测试套件：\n\n- 情况1：$M = 128$, $N = 64$, $k = 10^{-3}$, $\\varepsilon = 0$, 使用守恒的 $P$。\n- 情况2：$M = 128$, $N = 64$, $k = 10^{-3}$, $\\varepsilon = 0.05$, 使用故意破坏的 $P$。\n- 情况3：$M = 128$, $N = 64$, $k = 1$, $\\varepsilon = 0.05$, 使用故意破坏的 $P$。\n\n对于所有情况：\n- 使用如上所述相同的 $q$ 和 $x_{i}^{(p)}$。\n- 此问题中不使用角度；没有适用的角度单位。\n- 不涉及物理单位；所有量均为无量纲。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与上述情况一致，每个浮点数格式化为六位小数，例如：“[r1,r2,r3]”。\n\n程序必须是完整且可按原样运行的，无需用户输入或外部文件。它必须使用快速傅里叶变换 (FFT) 来执行卷积，并且必须实现所述的守恒和故意破坏的两种投影算子。数值结果必须通过执行程序获得；不要硬编码预期输出。",
            "solution": "问题陈述是有效的。它提出了一个定义明确的数值实验，该实验基于计算电磁学的既定原理，特别是预修正快速傅里叶变换 (pFFT) 方法。该问题是自洽的、数学上一致且没有歧义的。它要求实现一个标准算法来演示一个已知的数值赝象，这是一项合理的科学和教学任务。\n\n目标是构建一个一维数值实验，证明 pFFT 投影算子中违反离散电荷守恒会导致低频不稳定性。这种不稳定性是由格林函数符号中相应的发散项放大了电荷密度的虚假直流（零波数）分量所驱动的。我们将为一个屏蔽泊松问题实现 pFFT 矩阵向量乘积，并比较一个电荷守恒的投影方案和一个故意设为非守恒的方案。\n\n首先，我们建立模拟的几何结构。问题定义在一个长度为 $L=1$ 的一维周期域上。我们定义一个包含 $M$ 个节点的均匀计算网格，节点位置为 $x_{j} = \\frac{j}{M}$，其中整数 $j \\in \\{0, 1, \\dots, M-1\\}$。我们还定义了 $N$ 个源面元，代表离散电荷，其位置为 $x_{i}^{(p)} = \\frac{i + 1/2}{N}$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$。\n\n接下来，我们定义源分布。指定一个电荷向量 $q \\in \\mathbb{R}^{N}$，使得系统是电中性的。电荷由 $q_{i} = 1$ (对于 $0 \\le i  N/2$) 和 $q_{i} = -1$ (对于 $N/2 \\le i  N$) 给出。这种构造确保了总电荷为零：\n$$\n\\sum_{i=0}^{N-1} q_{i} = \\sum_{i=0}^{N/2-1} 1 + \\sum_{i=N/2}^{N-1} (-1) = \\frac{N}{2} - \\frac{N}{2} = 0\n$$\n\npFFT方法的核心涉及将这些离散的源电荷映射到均匀网格上。这是通过一个投影算子 $P$ 完成的。得到的网格电荷密度为 $\\rho = Pq$。在这里，我们使用一阶“云中单元” (CIC) 方案。对于每个位于位置 $x_{i}^{(p)}$ 的源面元 $i$，我们找到其左侧最近的网格点，其索引为 $j_{i} = \\lfloor M x_{i}^{(p)} \\rfloor$，以及其小数位移 $\\alpha_{i} = M x_{i}^{(p)} - j_{i}$。然后，电荷 $q_i$ 被分配到两个相邻的网格节点 $j_i$ 和 $(j_i+1) \\pmod M$。\n\n在电荷守恒的情况下，投影权重为 $w_{\\text{L}}^{(i)} = 1 - \\alpha_{i}$ 和 $w_{\\text{R}}^{(i)} = \\alpha_{i}$。任何面元的权重之和为 $w_{\\text{L}}^{(i)} + w_{\\text{R}}^{(i)} = 1$。这个被称为单位分解的性质保证了离散电荷守恒。网格上的总电荷为：\n$$\n\\sum_{j=0}^{M-1} \\rho_{j} = \\sum_{j=0}^{M-1} (Pq)_{j} = \\sum_{i=0}^{N-1} (w_{\\text{L}}^{(i)} + w_{\\text{R}}^{(i)}) q_{i} = \\sum_{i=0}^{N-1} (1) q_{i} = 0\n$$\n由于网格总电荷为零，其直流分量（其离散傅里叶变换的 $m=0$ 项）也为零。\n\n为了演示这种不稳定性，我们故意破坏这个守恒性质。我们引入一个依赖于面元的缩放因子 $s_{i} = 1 + \\varepsilon q_{i}$，其中 $\\varepsilon$ 是一个小的正参数。新的非守恒权重为 $\\widetilde{w}_{\\text{L}}^{(i)} = s_{i}(1 - \\alpha_{i})$ 和 $\\widetilde{w}_{\\text{R}}^{(i)} = s_{i} \\alpha_{i}$。这些权重之和现在是 $s_{i}$，不等于 $1$。投影到网格上的总电荷变为：\n$$\n\\sum_{j=0}^{M-1} \\widetilde{\\rho}_{j} = \\sum_{i=0}^{N-1} s_{i} q_{i} = \\sum_{i=0}^{N-1} (1 + \\varepsilon q_{i}) q_{i} = \\sum_{i=0}^{N-1} q_{i} + \\varepsilon \\sum_{i=0}^{N-1} q_{i}^{2}\n$$\n由于对所有 $i$ 都有 $\\sum q_i = 0$ 且 $q_i^2 = 1$，上式可简化为：\n$$\n\\sum_{j=0}^{M-1} \\widetilde{\\rho}_{j} = 0 + \\varepsilon \\sum_{i=0}^{N-1} 1 = \\varepsilon N\n$$\n这个非零和是网格电荷的直流分量，是一个由被破坏的投影算子直接导致的数值赝象。\n\n一旦电荷分布到网格上，我们求解屏蔽泊松方程 $(k^2 - \\nabla^2) \\phi = \\rho$ 来找到网格电位 $\\phi$。这在傅里叶域中可以高效地执行。操作为 $\\phi = \\mathcal{F}^{-1}(\\widehat{G} \\cdot \\mathcal{F}(\\rho))$，其中 $\\mathcal{F}$ 是离散傅里叶变换 (DFT)，$\\widehat{G}$ 是格林函数的傅里叶符号。对于长度为 $L=1$ 的域上的一维问题，与 DFT 索引 $m \\in \\{0, 1, \\dots, M-1\\}$ 对应的离散角频率是 $\\xi_m = 2 \\pi f_m$，其中 $f_m$ 是由标准 FFT 库（例如 `numpy.fft.fftfreq`）生成的频率，这些库能正确处理负频率的折叠。格林函数的傅里叶符号是：\n$$\n\\widehat{G}(\\xi_m) = \\frac{1}{k^2 + \\xi_m^2}\n$$\n关键项是零波数分量，即 $m=0$，此时 $\\xi_0 = 0$。这给出 $\\widehat{G}(0) = 1/k^2$。电位的傅里叶变换的 $m=0$ 分量是 $\\widehat{\\phi}_0 = \\widehat{G}(0) \\widehat{\\rho}_0 = \\frac{1}{k^2} \\sum_{j=0}^{M-1} \\rho_j$。在守恒情况下，$\\sum \\rho_j = 0$，所以该项为零。在非守恒情况下，$\\sum \\widetilde{\\rho}_j = \\varepsilon N$，导致 $\\widehat{\\phi}_0 = \\frac{\\varepsilon N}{k^2}$。对于小的 $k$，该项变得非常大，给电位 $\\phi$ 引入一个大的恒定偏移。\n\n最后，电位从网格插值回原始源面元的位置。这个反向投影是投影算子 $P$ 的转置 $P^T$。面元 $i$ 处的电位是其所耦合的网格节点上电位的加权平均：$v_i = \\sum_{j} (P^T)_{ij} \\phi_j$。对于 CIC 方案，这简化为 $v_i = w_{\\text{L}}^{(i)} \\phi_{j_i} + w_{\\text{R}}^{(i)} \\phi_{(j_i+1) \\pmod M}$，使用与前向投影相同的权重（守恒或破坏的）。最终要报告的结果是该面元电位向量的欧几里得范数 $\\|v\\|_2$。\n\n我们分析三种情况：\n1.  **情况1：($M=128, N=64, k=10^{-3}, \\varepsilon=0$)：** 这是守恒情况。由于 $\\varepsilon=0$，$s_i=1$ 且电荷守恒。$\\rho$ 的直流分量为零。尽管 $k$ 很小，但大的因子 $1/k^2$ 乘以零，所以没有不稳定性发生。我们预期 $\\|v\\|_2$ 会是一个适中的值。\n2.  **情况2：($M=128, N=64, k=10^{-3}, \\varepsilon=0.05$)：** 这是具有小 $k$ 的非守恒情况。产生了一个虚假的直流网格电荷 $\\varepsilon N = 0.05 \\times 64 = 3.2$。该值被 $1/k^2 = 1/(10^{-3})^2 = 10^6$ 放大。这导致网格上产生一个非常大的电位偏移，从而导致一个非常大的 $\\|v\\|_2$。\n3.  **情况3：($M=128, N=64, k=1, \\varepsilon=0.05$)：** 这是一个具有大 $k$ 的非守恒情况。虚假的直流电荷同样是 $\\varepsilon N = 3.2$。然而，放大因子现在仅为 $1/k^2 = 1/1^2 = 1$。守恒误差的影响被抑制了。我们预期 $\\|v\\|_2$ 会比情况2小得多，并且与情况1相当。\n\n实现将遵循这些步骤来为每种情况计算 $\\|v\\|_2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a minimal pFFT experiment to demonstrate the effect of \n    charge conservation on low-frequency stability.\n    \"\"\"\n\n    test_cases = [\n        # (M, N, k, epsilon)\n        (128, 64, 1e-3, 0.0),    # Case 1: Conservative\n        (128, 64, 1e-3, 0.05),   # Case 2: Non-conservative, small k\n        (128, 64, 1.0, 0.05),    # Case 3: Non-conservative, large k\n    ]\n\n    results = []\n\n    for M, N, k, epsilon in test_cases:\n        # Define domain and geometry\n        L = 1.0  # Domain length\n        \n        # Source panel positions\n        # x_p_i = (i + 1/2) / N for i in {0, ..., N-1}\n        panel_indices = np.arange(N)\n        x_p = (panel_indices + 0.5) / N\n\n        # Source charges: total charge is zero\n        # q_i = 1 for i  N/2, q_i = -1 for i >= N/2\n        q = np.ones(N)\n        q[N // 2:] = -1.0\n\n        # --- Step 1: Projection (Charge assignment) P ---\n        # Map panel charges q to grid charges rho\n        \n        # Grid charge vector\n        rho = np.zeros(M)\n        \n        # Panel-dependent scaling for (non-)conservation\n        # s_i = 1 + epsilon * q_i. If epsilon=0, s_i=1 (conservative).\n        s = 1.0 + epsilon * q\n\n        # Calculate projection weights (Cloud-in-Cell)\n        # Fractional coordinate of panel i: alpha_i\n        # Left grid index of panel i: j_indices_i\n        scaled_pos = M * x_p\n        j_indices = np.floor(scaled_pos).astype(int)\n        alpha = scaled_pos - j_indices\n\n        # Weights for each panel\n        # Conservative: w_L = 1 - alpha, w_R = alpha\n        # Broken: w_L = s * (1 - alpha), w_R = s * alpha\n        weights_L = s * (1.0 - alpha)\n        weights_R = s * alpha\n\n        # Project charges onto the grid\n        for i in range(N):\n            j = j_indices[i]\n            # Use modulo M for periodic boundary conditions\n            rho[j] += weights_L[i] * q[i]\n            rho[(j + 1) % M] += weights_R[i] * q[i]\n            \n        # --- Step 2: Fourier-domain Convolution ---\n        # phi = IFFT(G_hat * FFT(rho))\n\n        # Get discrete frequencies for the DFT on a grid of M points\n        # over a domain of length L. freq = [0, 1/L, 2/L, ..., -2/L, -1/L]\n        # Since L=1, d=1/M and freq = np.fft.fftfreq(M, d=1/M) gives wave numbers.\n        wave_numbers = np.fft.fftfreq(M, d=L/M)\n        \n        # Angular frequencies xi = 2*pi*k\n        xi_m = 2.0 * np.pi * wave_numbers\n        \n        # Green's function symbol in Fourier domain\n        # G_hat = 1 / (k^2 + xi_m^2)\n        # k is always > 0, so no division by zero at m=0.\n        G_hat = 1.0 / (k**2 + xi_m**2)\n\n        # Perform convolution\n        rho_hat = np.fft.fft(rho)\n        phi_hat = G_hat * rho_hat\n        phi = np.fft.ifft(phi_hat)\n        \n        # The grid potential should be real, but ifft might produce small\n        # imaginary parts due to numerical precision.\n        phi = np.real(phi)\n\n        # --- Step 3: Back-projection (Interpolation) P^T ---\n        # Interpolate grid potential phi to panel potentials v\n        \n        v = np.zeros(N)\n        for i in range(N):\n            j = j_indices[i]\n            # Interpolate using the same weights as projection (P^T)\n            v[i] = weights_L[i] * phi[j] + weights_R[i] * phi[(j + 1) % M]\n\n        # --- Step 4: Compute Metric ---\n        # Report the Euclidean norm of the panel potential vector\n        norm_v = np.linalg.norm(v)\n        results.append(f\"{norm_v:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}