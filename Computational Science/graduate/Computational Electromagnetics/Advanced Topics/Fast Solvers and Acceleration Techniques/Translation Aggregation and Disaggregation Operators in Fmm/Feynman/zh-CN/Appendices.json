{
    "hands_on_practices": [
        {
            "introduction": "快速多极子方法（FMM）的精度取决于对格林函数球谐波展开中无限级数的截断。本练习旨在通过第一性原理推导此截断误差的上界，从而掌握如何根据预设精度要求选择合适的展开阶数 $p$。这项实践将理论公式与算法参数选择直接联系起来，是理解 FMM 中精度与计算成本权衡的关键一步。",
            "id": "3357134",
            "problem": "考虑自由空间中波数为 $k$ 的三维时谐标量亥姆霍兹方程及其相关的格林函数。在计算电磁学的快速多极子方法 (FMM) 设置中，限制在半径为 $a$ 的球形盒子内的源被聚合成阶数为 $p$ 的截断多极展开，平移到间隔至少为 $R>a$ 的目标盒子，然后被分解为局部展开。平移（多极到局部）截断误差源于在格林函数的球面波加法表示中忽略了阶数高于 $p$ 的项。\n\n从亥姆霍兹格林函数的球面波加法定理出发，并仅使用球贝塞尔函数和球汉克尔函数的标准不等式，推导出一个关于 $k$、$a$、$R$ 和 $p$ 的显式上界，该上界用于描述包含在 $|{\\bf r}'|\\le a$ 中的源簇与目标区域 $|{\\bf r}|\\ge R$ 之间的平移截断误差。然后，对于频率满足 $ka=5$ 且盒子充分分离满足 $R=3a$ 的情况，选择能保证平移误差界不超过 $\\varepsilon=10^{-6}$ 的最小整数截断阶数 $p$。\n\n最后，在所求得的 $p$ 值处计算您的误差界，以得到平移误差的数值估计。以如下顺序提供您的最终答案，其形式为一个数对：\n- 最小截断阶数 $p$，以及\n- 对应的误差界数值，\n\n将误差估计四舍五入到两位有效数字。该误差是无量纲的，因此报告时无需单位。",
            "solution": "用户希望找到快速多极子方法 (FMM) 中平移截断误差的一个上界，并用它来确定在给定精度下所需的截断阶数 `p`。\n\n### 第 1 步：问题验证\n\n*   **提取的已知条件：**\n    *   方程：三维时谐标量亥姆霍兹方程。\n    *   格林函数：自由空间，波数 $k$。\n    *   方法：快速多极子方法 (FMM)。\n    *   源区域：半径为 $a$ 的球形盒子， $|{\\bf r}'| \\le a$。\n    *   目标区域：半径为 $R$ 的球体外部， $|{\\bf r}| \\ge R$。\n    *   约束条件：$R > a$。\n    *   误差来源：截断格林函数的球面波加法定理，忽略阶数 $l > p$ 的项。\n    *   工具：球贝塞尔函数和球汉克尔函数的标准不等式。\n    *   参数：$ka=5$，$R=3a$。\n    *   要求精度：误差界 $\\varepsilon \\le 10^{-6}$。\n    *   任务 1：推导一个关于 $k$、$a$、$R$ 和 $p$ 的截断误差显式上界。\n    *   任务 2：对于给定的参数，找到满足精度要求的最小整数 $p$。\n    *   任务 3：计算该 $p$ 值对应的误差界数值。\n\n*   **验证分析：**\n    *   该问题在科学上植根于波传播的数学物理和标准数值方法（FMM）。亥姆霍兹方程、格林函数、球谐函数和特殊函数都是其核心概念。\n    *   该问题是适定的。条件 $R>a$ 确保了球面波加法定理的收敛性，这是该方法的一个先决条件。它要求推导一个界并进行后续计算，其答案是唯一且可验证的。\n    *   该问题是客观的，使用了精确的数学和物理术语。\n    *   问题设置是一致和完整的，提供了执行计算所需的所有参数。$ka=5$ 和 $R=3a$ 是 FMM 应用中的典型值。\n    *   该问题没有违反任何无效性标准。\n\n*   **结论：**问题有效。\n\n### 第 2 步：误差界的推导\n\n自由空间中亥姆霍兹方程的时谐标量格林函数由 $G({\\bf r}, {\\bf r}') = \\frac{\\exp(ik|{\\bf r} - {\\bf r}'|)}{4\\pi|{\\bf r} - {\\bf r}'|}$ 给出。对于 $|{\\bf r}| > |{\\bf r}'|$，球面波加法定理允许将其展开为：\n$$\n\\frac{\\exp(ik|{\\bf r} - {\\bf r}'|)}{|{\\bf r} - {\\bf r}'|} = ik \\sum_{l=0}^{\\infty} (2l+1) \\sum_{m=-l}^{l} j_l(kr') h_l^{(1)}(kr) Y_{lm}(\\hat{r}) Y_{lm}^*(\\hat{r}')\n$$\n这里，$j_l$ 是第一类球贝塞尔函数，$h_l^{(1)}$ 是第一类球汉克尔函数，$Y_{lm}$ 是球谐函数。该表达式通常使用球谐加法定理 $\\sum_{m=-l}^{l} Y_{lm}(\\hat{r}) Y_{lm}^*(\\hat{r}') = \\frac{2l+1}{4\\pi} P_l(\\hat{r} \\cdot \\hat{r}')$ 以勒让德多项式 $P_l$ 的形式写出。\n\n问题指出误差是无量纲的。这表明我们应该考虑格林函数展开的无量纲形式中的误差。我们定义一个无量纲量 $g({\\bf r}, {\\bf r}') = \\frac{\\exp(ik|{\\bf r} - {\\bf r}'|)}{ik|{\\bf r} - {\\bf r}'|}$。其展开式为：\n$$\ng({\\bf r}, {\\bf r}') = \\sum_{l=0}^{\\infty} (2l+1) j_l(kr') h_l^{(1)}(kr) P_l(\\hat{r} \\cdot \\hat{r}')\n$$\n截断误差 $\\epsilon_p$ 是 $g$ 与其在阶数 $p$ 处截断的级数之差的模：\n$$\n\\epsilon_p({\\bf r}, {\\bf r}') = \\left| \\sum_{l=p+1}^{\\infty} (2l+1) j_l(kr') h_l^{(1)}(kr) P_l(\\hat{r} \\cdot \\hat{r}') \\right|\n$$\n为了找到一个独立于特定源和目标位置（在定义区域内）的上界，我们对 $|{\\bf r}'| \\le a$ 和 $|{\\bf r}| \\ge R$ 以及所有角度取最大值。使用三角不等式和 $|P_l(x)| \\le 1$ 的事实：\n$$\n\\epsilon_p \\le \\sum_{l=p+1}^{\\infty} (2l+1) \\max_{|{\\bf r}'|\\le a} |j_l(kr')| \\max_{|{\\bf r}|\\ge R} |h_l^{(1)}(kr)|\n$$\n对于 $l > ka$，函数 $|j_l(x)|$ 在 $x",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n10 & 5.6 \\times 10^{-7}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在FMM中，一个核心算法决策是区分何时使用多极矩近似（远场），何时进行直接计算（近场）。本练习将平移误差理论应用于实践，要求你设计并实现一个稳健的近场-远场切换准则。你将编写一个程序，以计算在给定误差容限下，多极矩到局部展开（M2L）平移所需满足的最小分离距离，这对于构建高效且可靠的FMM求解器至关重要。",
            "id": "3357113",
            "problem": "要求您为计算电磁学中使用的亥姆霍兹方程设计一种用于快速多极子方法（FMM）的鲁棒的近-远场切换准则。该切换是基于保证的簇分离，在直接相互作用与多极/局域展开之间进行。目标是确保仅当球汉克尔展开尾部的截断误差界低于用户指定的容差时，才使用多极到局域（M2L）转换。您必须构建此准则，使其对复波数有效，然后计算达到指定误差容差的最小切换距离。\n\n从一个基本前提开始：标量亥姆霍兹方程的时谐自由空间格林函数由 $G(\\mathbf{r},\\mathbf{r}')=\\dfrac{\\exp(i k \\|\\mathbf{r}-\\mathbf{r}'\\|)}{\\|\\mathbf{r}-\\mathbf{r}'\\|}$ 给出，其中 $k \\in \\mathbb{C}$ 是波数，对于无源介质，$\\operatorname{Im}(k) \\ge 0$。使用经过充分验证的加法定理，将 $G$ 表示为涉及球贝塞尔函数 $j_n$ 和第一类球汉克尔函数 $h_n^{(1)}$ 的收敛球谐波展开。对于两个包含源点和目标点的不相交球（簇），其中心位于一条直线上，中心距为 $R$，源球半径为 $a_s$，目标球半径为 $a_t$，保证分离需要满足 $R > a_s + a_t$。在这种分离配置下，加法定理展开式绝对收敛，且对于阶数 $n > p$ 的尾部，可以通过对在最坏情况半径 $r_ = a_s$ 和 $r_> = R - a_t$ 处求值的球贝塞尔和球汉克尔项应用三角不等式来进行界定。\n\n将阶数为 $p$ 的 M2L 转换的截断误差代理定义为\n$$\nE_p(R;k,a_s,a_t) = \\sum_{n=p+1}^{\\infty} (2n+1)\\,\\big|j_n(k\\,r_)\\,h_n^{(1)}(k\\,r_>)\\big|,\n$$\n这是一个无量纲的界，通过对加法定理的尾部在方位角自由度上求和并应用三角不等式推导得出。在本问题中，您将通过求和计算 $E_p$ 的数值严格近似值，直到各项足够小为止，这需要利用球贝塞尔函数和球汉克尔函数对复宗量的已知行为，即它们与普通贝塞尔函数和汉克尔函数的关系。\n\n您的任务：\n- 给定 $k \\in \\mathbb{C}$，$a_s \\in \\mathbb{R}_+$，$a_t \\in \\mathbb{R}_+$，整数展开阶数 $p \\ge 0$ 和误差容差 $\\varepsilon \\in \\mathbb{R}_+$，设计一个近-远场切换准则：当且仅当在 $R  a_s + a_t$ 的条件下满足 $E_p(R;k,a_s,a_t) \\le \\varepsilon$ 时，使用多极/局域展开，否则使用直接相互作用。\n- 对于每个测试用例，计算最小切换距离 $R_{\\text{switch}}$（单位：米），该距离定义为满足 $E_p(R;k,a_s,a_t) \\le \\varepsilon$ 且严格大于 $a_s + a_t$ 的最小 $R$。使用一个数值稳定的搜索过程，该过程的合理性基于在保证分离的条件下，尾部界随 $R$ 增大而单调衰减的特性。\n- 您的程序必须通过与普通贝塞尔函数的关系来实现针对复宗量的球汉克尔函数 $h_n^{(1)}$ 和球贝塞尔函数 $j_n$：\n$$\nj_n(z) = \\sqrt{\\frac{\\pi}{2z}} J_{n+\\tfrac{1}{2}}(z), \\quad\nh_n^{(1)}(z) = \\sqrt{\\frac{\\pi}{2z}} H_{n+\\tfrac{1}{2}}^{(1)}(z),\n$$\n并且必须以严格的内部容差对无限尾部和进行数值逼近。您必须使用最坏情况半径 $r_ = a_s$ 和 $r_> = R - a_t$ 来确保正确性，这对应于 FMM 转换链中聚集（源到多极，S2M）和散开（局域到目标，L2T）算子的极端几何配置。转换算子（多极到局域，M2L）是此界中 $E_p$ 的唯一贡献者。\n\n单位和输出：\n- 距离使用米，波数 $k$ 使用弧度/米。\n- 所有距离均以米表示。\n- 角度不是直接必需的；如果出现，必须以弧度为单位。\n- 对于每个测试用例，输出计算出的 $R_{\\text{switch}}$，作为一个浮点数，四舍五入到五位小数。\n\n测试套件：\n- 用例 $1$：$k = \\dfrac{2\\pi}{0.5}\\,\\text{rad/m}$，$a_s = 0.1\\,\\text{m}$，$a_t = 0.1\\,\\text{m}$，$p = 10$，$\\varepsilon = 10^{-6}$。\n- 用例 $2$（边界敏感）：$k = 20\\,\\text{rad/m}$，$a_s = 0.2\\,\\text{m}$，$a_t = 0.2\\,\\text{m}$，$p = 6$，$\\varepsilon = 10^{-4}$。\n- 用例 $3$（衰减介质）：$k = 30 + 5 i\\,\\text{rad/m}$，$a_s = 0.15\\,\\text{m}$，$a_t = 0.1\\,\\text{m}$，$p = 8$，$\\varepsilon = 10^{-8}$。\n- 用例 $4$（高频，低阶）：$k = 100\\,\\text{rad/m}$，$a_s = 0.05\\,\\text{m}$，$a_t = 0.05\\,\\text{m}$，$p = 5$，$\\varepsilon = 10^{-5}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,r_3,r_4]$，其中 $r_i$ 是各测试用例计算出的 $R_{\\text{switch}}$ 值（单位为米），每个值都四舍五入到五位小数。",
            "solution": "用户问题已经过验证，概述如下。\n\n### 步骤 1：提取已知条件\n- **格林函数**：$G(\\mathbf{r},\\mathbf{r}')=\\dfrac{\\exp(i k \\|\\mathbf{r}-\\mathbf{r}'\\|)}{\\|\\mathbf{r}-\\mathbf{r}'\\|}$\n- **波数**：$k \\in \\mathbb{C}$，其中 $\\operatorname{Im}(k) \\ge 0$。\n- **簇几何结构**：源球半径 $a_s$，目标球半径 $a_t$，中心距 $R$。\n- **分离条件**：$R  a_s + a_t$。\n- **截断误差代理**：$E_p(R;k,a_s,a_t) = \\sum_{n=p+1}^{\\infty} (2n+1)\\,\\big|j_n(k\\,r_)\\,h_n^{(1)}(k\\,r_>)\\big|$。\n- **最坏情况半径**：$r_ = a_s$ 和 $r_> = R - a_t$。\n- **切换准则**：当且仅当对于 $R  a_s + a_t$ 时 $E_p(R;k,a_s,a_t) \\le \\varepsilon$，使用多极/局域展开。\n- **目标**：计算最小切换距离 $R_{\\text{switch}}$，即满足 $E_p(R;k,a_s,a_t) \\le \\varepsilon$ 的最小 $R  a_s + a_t$。\n- **特殊函数定义**：\n  - 球贝塞尔函数：$j_n(z) = \\sqrt{\\frac{\\pi}{2z}} J_{n+\\tfrac{1}{2}}(z)$。\n  - 第一类球汉克尔函数：$h_n^{(1)}(z) = \\sqrt{\\frac{\\pi}{2z}} H_{n+\\tfrac{1}{2}}^{(1)}(z)$。\n- **测试用例**：\n  - 用例 $1$：$k = \\dfrac{2\\pi}{0.5}\\,\\text{rad/m}$，$a_s = 0.1\\,\\text{m}$，$a_t = 0.1\\,\\text{m}$，$p = 10$，$\\varepsilon = 10^{-6}$。\n  - 用例 $2$：$k = 20\\,\\text{rad/m}$，$a_s = 0.2\\,\\text{m}$，$a_t = 0.2\\,\\text{m}$，$p = 6$，$\\varepsilon = 10^{-4}$。\n  - 用例 $3$：$k = 30 + 5 i\\,\\text{rad/m}$，$a_s = 0.15\\,\\text{m}$，$a_t = 0.1\\,\\text{m}$，$p = 8$，$\\varepsilon = 10^{-8}$。\n  - 用例 $4$：$k = 100\\,\\text{rad/m}$，$a_s = 0.05\\,\\text{m}$，$a_t = 0.05\\,\\text{m}$，$p = 5$，$\\varepsilon = 10^{-5}$。\n- **输出**：每个测试用例的 $R_{\\text{switch}}$ 值的逗号分隔列表，四舍五入到五位小数，并用方括号括起来。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于标量亥姆霍兹方程的快速多极子方法（FMM）的标准公式。格林函数、球谐波加法定理、球贝塞尔和汉克尔函数的定义，以及多极到局域（M2L）算子的截断误差界概念，都是计算电磁学和数学物理中的基本且正确的原理。\n- **适定性**：该问题是适定的。它要求找到满足误差容差的最小距离 $R_{\\text{switch}}$。误差函数 $E_p(R)$ 是分离距离 $R$ 的函数。对于分离的簇（$R  a_s + a_t$），由于 $|h_n^{(1)}(z)|$ 随 $|z|$ 衰减，项 $|j_n(k a_s) h_n^{(1)}(k(R-a_t))|$ 的大小随 $R$ 的增加而减小。这确保了 $E_p(R)$ 是 $R$ 的单调递减函数。因此，对于给定的容差 $\\varepsilon$，方程 $E_p(R) = \\varepsilon$ 存在唯一解，可以使用标准的数值求根算法找到该解。\n- **客观性**：问题以精确的数学和算法术语陈述。目标是基于一组给定的公式和参数计算一个特定的数值量，这是一项完全客观的任务。\n\n该问题没有表现出验证标准中列出的任何缺陷（例如，科学上不健全、模糊、信息缺失）。所提供的参数在物理上和量纲上都是一致的。\n\n### 步骤 3：结论和行动\n问题有效。将制定一个合理的解决方案。\n\n### 解决方案和算法设计\n\n核心任务是为快速多极子方法的实现确定近-远场切换距离 $R_{\\text{switch}}$。此距离定义为两个簇（半径为 $a_s$ 的源簇和半径为 $a_t$ 的目标簇）之间的最小分离距离 $R$，在该距离下，由代理 $E_p(R)$ 估计的 M2L 转换误差低于指定的容差 $\\varepsilon$。控制方程为 $E_p(R_{\\text{switch}}) = \\varepsilon$，并受几何约束 $R_{\\text{switch}}  a_s + a_t$ 的限制。\n\n解决方案包括三个主要部分：\n1.  一个用于数值计算截断误差代理 $E_p(R)$ 的函数。\n2.  实现所需的特殊函数，即针对复宗量的球贝塞尔函数和球汉克尔函数。\n3.  一个用于求解 $R_{\\text{switch}}$ 的数值求根过程。\n\n**1. 计算截断误差代理 $E_p(R)$**\n\n误差代理由以下无穷级数给出：\n$$\nE_p(R;k,a_s,a_t) = \\sum_{n=p+1}^{\\infty} (2n+1)\\,\\big|j_n(k\\,a_s)\\,h_n^{(1)}(k(R-a_t))\\big|\n$$\n其中 $r_ = a_s$ 和 $r_> = R - a_t$ 表示各自簇内源和目标的最坏情况半径。为了进行数值计算，必须截断这个无穷和。对于 $R  a_s + a_t$，加法定理的收敛性得到保证，这意味着级数项对于大的 $n$ 必须衰减到零。这些项以与比率 $|a_s / (R-a_t)|  1$ 相关的几何速率衰减。我们将通过对有限数量的项（$n$ 从 $p+1$ 到一个足够大的上界 $n_{\\text{max}}$）求和来近似该和。保守地选择 $n_{\\text{max}} = p + 50$ 可确保对于所有测试用例，被忽略的级数尾部比所需精度小数个数量级。\n\n**2. 实现球函数**\n\n球贝塞尔函数 $j_n(z)$ 和汉克尔函数 $h_n^{(1)}(z)$ 是针对复宗量 $z$ 计算的，使用它们以普通半整数阶贝塞尔和汉克尔函数表示的定义，这些函数在 `scipy.special` 库中可用：\n-   $j_n(z) = \\sqrt{\\frac{\\pi}{2z}} J_{n+\\frac{1}{2}}(z)$，使用 `scipy.special.jv` 实现。\n-   $h_n^{(1)}(z) = \\sqrt{\\frac{\\pi}{2z}} H_{n+\\frac{1}{2}}^{(1)}(z)$，使用 `scipy.special.hankel1` 实现。\n\n这些函数将在误差计算的求和循环内被调用，参数为 $z_j = k a_s$ 和 $z_h = k (R-a_t)$。\n\n**3. 求解 $R_{\\text{switch}}$ 的求根**\n\n寻找 $R_{\\text{switch}}$ 的问题转化为寻找函数 $f(R) = E_p(R) - \\varepsilon = 0$ 的根。如前所述，$E_p(R)$ 在 $R  a_s + a_t$ 时单调递减。这一特性使得该问题非常适合使用像布伦特-德克尔方法（Brent-Dekker method）这样的区间求根算法，该方法在 `scipy.optimize.brentq` 中提供。\n\n每个测试用例的算法如下：\na. 定义目标函数 `objective_func(R)`，它返回 $E_p(R) - \\varepsilon$。\nb. 确定搜索的绝对下限 $R_{\\text{min}} = a_s + a_t$。\nc. 在一个略大于 $R_{\\text{min}}$ 的点 $R$ 处检查 `objective_func` 的值。如果为负，则表示对于所有有效的 $R$，$E_p(R)  \\varepsilon$。在这种情况下，多极展开总是足够精确，切换距离实际上就是几何有效性的边界本身，因此 $R_{\\text{switch}} = a_s + a_t$。\nd. 如果函数在下限处为正，则找到一个搜索区间 $[R_a, R_b]$ 使得 $f(R_a)  0$ 且 $f(R_b)  0$。我们可以将 $R_a$ 设置为略大于 $R_{\\text{min}}$。然后，我们通过一个初始猜测（例如，$R_b = 2 R_a$）并迭代地将其加倍来找到一个上界 $R_b$，直到 $f(R_b)$ 的符号变为负。\ne. 有了有效的区间后，调用 `scipy.optimize.brentq` 以高精度找到根 $R_{\\text{switch}}$。\nf. 最终结果按要求四舍五入到五位小数。\n\n这种系统化的方法保证了对每个给定测试用例的切换距离进行鲁棒而准确的计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import jv, hankel1\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for the minimal switching distance R_switch for each test case.\n    \"\"\"\n\n    def spherical_jn(n, z):\n        \"\"\"\n        Computes the spherical Bessel function of the first kind j_n(z)\n        for integer order n and complex argument z.\n        \"\"\"\n        # For z=0, j_0(0) = 1 and j_n(0) = 0 for n > 0.\n        if z == 0:\n            return 1.0 if n == 0 else 0.0\n        return np.sqrt(np.pi / (2.0 * z)) * jv(n + 0.5, z)\n\n    def spherical_h1n(n, z):\n        \"\"\"\n        Computes the spherical Hankel function of the first kind h_n^(1)(z)\n        for integer order n and complex argument z.\n        \"\"\"\n        # h_n^(1)(z) has a singularity at z=0.\n        if z == 0:\n            return complex(np.inf, -np.inf)\n        return np.sqrt(np.pi / (2.0 * z)) * hankel1(n + 0.5, z)\n\n    def calculate_error_proxy(R, k, a_s, a_t, p):\n        \"\"\"\n        Calculates the truncation error proxy E_p for the M2L translation.\n        \"\"\"\n        # The separation must be guaranteed, R > a_s + a_t.\n        # If not, the expansion doesn't converge, error is infinite.\n        if R = a_s + a_t:\n            return np.inf\n\n        r_less = a_s\n        r_great = R - a_t\n\n        z_j = k * r_less\n        z_h = k * r_great\n\n        # Sum a sufficient number of terms in the tail of the series.\n        # p + 50 is a conservative choice that guarantees convergence\n        # to a high precision for the given test cases.\n        n_max = p + 50\n        \n        total_error = 0.0\n        # The sum starts from n = p + 1.\n        for n in range(p + 1, n_max + 1):\n            term = (2 * n + 1) * np.abs(spherical_jn(n, z_j) * spherical_h1n(n, z_h))\n            total_error += term\n            # A dynamic convergence check could be used for optimization,\n            # but a fixed large number of terms is robust.\n        \n        return total_error\n\n    def find_switching_distance(k, a_s, a_t, p, epsilon):\n        \"\"\"\n        Finds the minimal R > a_s + a_t such that E_p(R) = epsilon.\n        \"\"\"\n        R_min = a_s + a_t\n\n        def objective_func(R):\n            \"\"\"The function whose root we want to find: E_p(R) - epsilon = 0.\"\"\"\n            return calculate_error_proxy(R, k, a_s, a_t, p) - epsilon\n\n        # Check if the error is already below the tolerance at minimal separation.\n        # Use a small delta to ensure R > R_min.\n        try:\n            val_at_min_R = objective_func(R_min * (1.0 + 1e-12))\n        except (ValueError, TypeError): # Can happen if functions misbehave at boundary\n             val_at_min_R = np.inf\n\n        if val_at_min_R = 0:\n            # If error is already low, the switching distance is the minimum possible.\n            return R_min\n\n        # Establish a search bracket [R_a, R_b] for the root-finder.\n        # R_a is the lower bound, slightly perturbed from R_min.\n        R_a = R_min * (1.0 + 1e-9)\n\n        # Find an upper bound R_b where the objective function is negative.\n        # Start with a reasonable guess and expand the interval if needed.\n        R_b = 2.0 * R_a if R_a > 1e-9 else 1.0 # Handle R_min=0 case\n        safety_counter = 0\n        while objective_func(R_b) > 0:\n            R_b *= 2.0\n            safety_counter += 1\n            if safety_counter > 50: # Avoid infinite loop\n                raise RuntimeError(\n                    f\"Could not find an upper bracket for root search for case \"\n                    f\"(k={k}, a_s={a_s}, a_t={a_t}, p={p}, eps={epsilon}).\"\n                )\n\n        # Use Brent's method to find the root with high tolerance.\n        R_switch = brentq(objective_func, R_a, R_b, xtol=1e-12, rtol=1e-12)\n        return R_switch\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2.0 * np.pi / 0.5, 0.1, 0.1, 10, 1e-6),\n        (20.0, 0.2, 0.2, 6, 1e-4),\n        (30.0 + 5.0j, 0.15, 0.1, 8, 1e-8),\n        (100.0, 0.05, 0.05, 5, 1e-5),\n    ]\n\n    results = []\n    for case in test_cases:\n        k_val, a_s_val, a_t_val, p_val, eps_val = case\n        r_switch = find_switching_distance(k_val, a_s_val, a_t_val, p_val, eps_val)\n        # Round the final result to 5 decimal places as specified.\n        results.append(f\"{r_switch:.5f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "实现了复杂的FMM算子后，验证其正确性是一个巨大的挑战。本练习介绍了一种基于物理互易性和数值一致性的强大自检验方法。通过在一个闭合曲面上先后执行“局部展开到点”（L2P）和“点到多极矩”（P2M）操作，并检验一个守恒量是否得以保持，我们可以有效地验证算子实现的正确性，而无需外部的“黄金标准”参考解。",
            "id": "3357105",
            "problem": "考虑一个在均匀介质中的二维时谐场，该场由标量亥姆霍兹方程 $\\nabla^2 u + k^2 u = 0$ 控制，其中 $u$ 是一个复值场，$k$ 是波数。在快速多极子方法（FMM）中，使用了两个基本算子：局部到点（L2P）算子，它在指定的目标点上评估局部展开；以及点到多极子（P2M）算子，它将点数据聚合到以选定中心为中心的多极子展开中。您将在一个封闭的圆形表面上构建一个基于互易性的自测试，以评估先进行 L2P 再进行 P2M 的复合操作是否能在指定的容差 $\\epsilon$ 内，近似地使一个类似功率的表面平均二次量守恒。\n\n假设一个以原点为中心、半径为 $R_s$ 的圆形表面。严格在极坐标 $(r,\\theta)$ 下工作，其中 $\\theta$ 以弧度为单位。对标量亥姆霍兹方程使用分离变量法，并使用由此分离产生的标准柱面基函数。假设在圆内部关于原点有一个阶数为 $p$ 的带限局部展开，在圆外部关于原点有一个阶数为 $p$ 的出射多极子展开。在圆形表面上，以角度 $\\theta_m = \\frac{2\\pi m}{N}$（对于整数 $m \\in \\{0,1,\\dots,N-1\\}$）取 $N$ 个等间距样本。\n\n将表面平均二次量定义为在圆上采样的场的模平方的角度平均值，即 $P_{\\text{surf}} = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} |u(R_s,\\theta)|^2 \\, d\\theta$。您的程序必须实现以下测试协议：\n\n- 在原点构建一个局部展开，其系数为 $b_n$，对于整数索引 $n$ 满足 $|n| \\leq p$。系数由 $b_n = \\exp(-\\alpha |n|) \\exp(i n \\delta)$ 确定性地给出，其中 $\\alpha  0$ 和 $\\delta$（以弧度为单位）是实数参数。\n- 应用局部到点（L2P）算子，在半径为 $R_s$ 的圆上、在采样角度 $\\theta_m$ 处评估场，得到样本 $u_m = u(R_s,\\theta_m)$。\n- 根据圆上的采样值 $u_m$，应用点到多极子（P2M）算子来确定关于原点的出射多极子系数 $a_n$，对于相同的带限 $|n| \\leq p$。使用分离变量法和圆上的正交性，以数学上一致的方式执行此聚合。\n- 使用均匀角度网格上的梯形法则计算 $P_{\\text{surf}}$ 的离散近似，即，用样本 $|u_m|^2$ 的均匀平均值代替角度积分。\n- 使用出射多极子系数 $a_n$，计算表面平均二次量的相应重构，其方式应与圆上的分离变量表示和角度基的正交性相一致。确切的公式必须从第一性原理推导得出；不要在没有论证的情况下假设快捷恒等式。\n- 报告两个计算出的二次量之间的相对差异是否不超过指定的容差 $\\epsilon$，即，是否满足 $\\frac{|P_{\\text{out}} - P_{\\text{surf}}|}{\\max(P_{\\text{surf}},\\eta)} \\leq \\epsilon$，其中 $P_{\\text{out}}$ 是根据出射多极子表示计算出的量，$\\eta$ 是一个小的正常数，仅用于在 $P_{\\text{surf}}$ 为零时防止除以零。\n\n角度必须以弧度处理，所有量纲均为无量纲。使用适用于标量亥姆霍兹设置的柱面函数。程序必须为提供的测试套件中的每个参数集实现此测试，并生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n\n测试套件：\n- 案例 1 (正常路径): $k = 3.0$, $R_s = 1.0$, $p = 6$, $N = 64$, $\\alpha = 0.4$, $\\delta = 0.3$, $\\epsilon = 10^{-10}$。\n- 案例 2 (最小采样边界): $k = 5.0$, $R_s = 0.7$, $p = 10$, $N = 21$, $\\alpha = 0.25$, $\\delta = 0.5$, $\\epsilon = 10^{-9}$。\n- 案例 3 (欠解析边缘案例): $k = 8.0$, $R_s = 1.2$, $p = 12$, $N = 16$, $\\alpha = 0.3$, $\\delta = 0.1$, $\\epsilon = 10^{-6}$。\n- 案例 4 (零阶健全性检查): $k = 2.0$, $R_s = 0.5$, $p = 0$, $N = 8$, $\\alpha = 0.6$, $\\delta = 0.0$, $\\epsilon = 10^{-12}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[result_1,result_2,result_3,result_4]$），其中每个 $result_i$ 是一个布尔值，指示该案例的基于互易性的功率守恒测试是否通过。",
            "solution": "问题陈述被评估为有效。它在科学上基于波传播理论和数值方法，特别是快速多极子方法（FMM）。它是一个适定问题，所有必要的参数和过程都已定义，从而导出一个唯一且可验证的解。语言客观而精确。\n\n问题的核心是一个自洽性测试，针对局部到点（L2P）和点到多极子（P2M）算子，在二维标量亥姆霍兹方程 $(\\nabla^2 + k^2)u = 0$ 的背景下进行，其中 $k$ 是波数。该测试在圆形边界上执行。\n\n首先，我们建立基于极坐标 $(r, \\theta)$ 中分离变量法的数学框架。亥姆霍兹方程的解可以表示为柱面基函数的级数。\n\n一个局部展开，代表在原点处正则的场，使用第一类贝塞尔函数 $J_n(z)$ 构建。对于阶数为 $p$ 的带限，此展开为：\n$$u_{\\text{loc}}(r, \\theta) = \\sum_{n=-p}^{p} b_n J_n(kr) e^{in\\theta}$$\n这里，$b_n$ 是局部展开系数，由确定性公式 $b_n = \\exp(-\\alpha |n|) \\exp(i n \\delta)$ 给出。\n\n一个出射多极子展开，代表一个向外辐射并满足索末菲辐射条件的场，使用第一类汉克尔函数 $H_n^{(1)}(z)$ 构建：\n$$u_{\\text{out}}(r, \\theta) = \\sum_{n=-p}^{p} a_n H_n^{(1)}(kr) e^{in\\theta}$$\n其中 $a_n$ 是出射多极子展开系数。对于负索引 $n$，使用恒等式 $J_{-n}(z) = (-1)^n J_n(z)$ 和 $H_{-n}^{(1)}(z) = (-1)^n H_n^{(1)}(z)$。\n\n测试协议涉及一系列操作：\n\n1.  **L2P（局部到点）操作**：我们在半径为 $R_s$ 的圆形表面上，以角度 $\\theta_m = \\frac{2\\pi m}{N}$（对于 $m \\in \\{0, 1, \\dots, N-1\\}$）在 $N$ 个等间距点上评估局部展开。得到的场样本 $u_m$ 为：\n    $$u_m = u_{\\text{loc}}(R_s, \\theta_m) = \\sum_{n=-p}^{p} b_n J_n(kR_s) e^{in\\theta_m}$$\n\n2.  **表面平均功率，$P_{\\text{surf}}$**：问题定义了表面平均二次量 $P_{\\text{surf}} = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} |u(R_s, \\theta)|^2 d\\theta$。我们使用均匀角度网格上的梯形法则计算其离散近似。角度步长为 $\\Delta\\theta = \\frac{2\\pi}{N}$ 时，这变为：\n    $$P_{\\text{surf}} \\approx \\frac{1}{N} \\sum_{m=0}^{N-1} |u_m|^2$$\n\n3.  **P2M（点到多极子）操作**：我们从场样本 $u_m$ 中确定出射多极子系数 $a_n$。这涉及一个逆操作：找到圆上场的傅里叶级数表示的系数。利用复指数的正交性，连续关系为 $a_n H_n^{(1)}(kR_s) = \\frac{1}{2\\pi} \\int_0^{2\\pi} u(R_s, \\theta) e^{-in\\theta} d\\theta$。将该积分离散化（等同于执行离散傅里叶变换分析）得到：\n    $$a_n \\approx \\frac{1}{N H_n^{(1)}(kR_s)} \\sum_{m=0}^{N-1} u_m e^{-in\\theta_m}$$\n    此公式允许我们将点数据 $\\{u_m\\}$ 聚合为一组多极子系数 $\\{a_n\\}$。\n\n4.  **重构功率，$P_{\\text{out}}$**：我们使用推导出的多极子系数 $a_n$ 计算类似的表面平均功率。通过将出射展开代入 $P_{\\text{surf}}$ 的积分定义并应用傅里叶级数的帕塞瓦尔定理，我们得到一个用系数表示的表达式：\n    $$P_{\\text{out}} = \\frac{1}{2\\pi} \\int_0^{2\\pi} \\left| \\sum_{n=-p}^{p} a_n H_n^{(1)}(kR_s) e^{in\\theta} \\right|^2 d\\theta = \\sum_{n=-p}^{p} |a_n H_n^{(1)}(kR_s)|^2 = \\sum_{n=-p}^{p} |a_n|^2 |H_n^{(1)}(kR_s)|^2$$\n\n5.  **互易性检查**：最后一步是比较 $P_{\\text{surf}}$ 和 $P_{\\text{out}}$。这两个量的一致性关键取决于采样率 $N$。如果采样足以解析展开中的所有模式，即，如果满足奈奎斯特准则 $N \\ge 2p+1$，那么离散傅里叶变换就能准确地捕捉到连续域的正交性。在这个良好解析的体系中，系数之间的关系是 $a_n = b_n \\frac{J_n(kR_s)}{H_n^{(1)}(kR_s)}$。将此代入 $P_{\\text{out}}$ 的表达式表明，理论上，$P_{\\text{out}} = \\sum |b_n|^2 |J_n(kR_s)|^2$，这与通过帕塞瓦尔定理从局部展开推导出的 $P_{\\text{surf}}$ 的精确值相同。因此，对于 $N \\ge 2p+1$，我们期望 $\\frac{|P_{\\text{out}} - P_{\\text{surf}}|}{\\max(P_{\\text{surf}},\\eta)} \\le \\epsilon$。\n    然而，如果 $N  2p+1$，离散傅里叶分析会遭受混叠效应。高频分量（大的 $|n|$）被错误地映射到低频分量上，从而破坏了 $a_n$ 和 $b_n$ 之间的简单关系。这会引入显著误差，测试预计会失败。参数 $\\eta$ 是一个小的正则化常数，用于防止除以零。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import jv, hankel1\n\n# Set a small constant to prevent division by zero in the relative error calculation.\nETA = 1e-30\n\ndef reciprocity_test(k, Rs, p, N, alpha, delta, epsilon):\n    \"\"\"\n    Performs the reciprocity-based self-test for a given set of parameters.\n\n    The test follows these steps:\n    1.  Construct local expansion coefficients 'b_n'.\n    2.  Perform L2P: Evaluate the field 'u_m' on a circle from 'b_n'.\n    3.  Calculate the surface-averaged power 'P_surf' from 'u_m'.\n    4.  Perform P2M: Aggregate 'u_m' to get outgoing multipole coefficients 'a_n'.\n    5.  Calculate the reconstructed power 'P_out' from 'a_n'.\n    6.  Compare 'P_surf' and 'P_out' to check for conservation.\n    \"\"\"\n\n    # --- Step 1: Construct local expansion coefficients 'b_n' ---\n    # The modes/indices 'n' range from -p to p.\n    n_vals = np.arange(-p, p + 1)\n    b_n = np.exp(-alpha * np.abs(n_vals)) * np.exp(1j * n_vals * delta)\n\n    # --- Step 2: L2P (Local-to-Point) Operation ---\n    # Evaluate the local expansion on a circle of radius Rs.\n    # The field u(r, theta) is sum(b_n * J_n(kr) * exp(i*n*theta)).\n    \n    # Angular sample points\n    theta_m = (2 * np.pi / N) * np.arange(N)\n\n    # Calculate Bessel functions J_n(k*Rs). scipy.special.jv handles negative n.\n    jv_vals = jv(n_vals, k * Rs)\n    \n    # Coefficients of the Fourier series for the field on the circle\n    field_coeffs = b_n * jv_vals\n\n    # Evaluate the field samples u_m by synthesizing the Fourier series.\n    # This is an inverse discrete Fourier transform. A matrix-vector product is efficient.\n    # kernel[m, i] = exp(i * n_vals[i] * theta_m[m])\n    kernel_l2p = np.exp(1j * np.outer(theta_m, n_vals))\n    u_m = kernel_l2p @ field_coeffs\n\n    # --- Step 3: Calculate P_surf ---\n    # Approximate the surface-averaged power using the trapezoidal rule on the samples.\n    # P_surf = (1/N) * sum(|u_m|^2)\n    P_surf = np.mean(np.abs(u_m)**2)\n\n    # --- Step 4: P2M (Point-to-Multipole) Operation ---\n    # Aggregate point samples u_m into outgoing multipole coefficients a_n.\n    # a_n = (1 / (N * H_n(kRs))) * sum(u_m * exp(-i*n*theta_m))\n\n    # Calculate Hankel functions H_n^(1)(k*Rs). scipy.special.hankel1 handles negative n.\n    hankel1_vals = hankel1(n_vals, k * Rs)\n    \n    # The sum is a discrete Fourier transform analysis.\n    # kernel[i, m] = exp(-i * n_vals[i] * theta_m[m])\n    kernel_p2m = np.exp(-1j * np.outer(n_vals, theta_m))\n    fourier_sum = kernel_p2m @ u_m\n    \n    # Calculate a_n, handling potential division by zero for Hankel functions\n    # (though H_n^(1)(z) is zero only for z=0, which is not the case here).\n    a_n = fourier_sum / (N * hankel1_vals)\n\n    # --- Step 5: Calculate P_out ---\n    # Reconstruct the surface-averaged power from the multipole coefficients.\n    # P_out = sum(|a_n * H_n(kRs)|^2)\n    P_out = np.sum(np.abs(a_n * hankel1_vals)**2)\n    \n    # --- Step 6: Compare and return result ---\n    # Check if the relative difference is within the tolerance epsilon.\n    relative_diff = np.abs(P_out - P_surf) / max(P_surf, ETA)\n    \n    return relative_diff = epsilon\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (k, Rs, p, N, alpha, delta, epsilon)\n        (3.0, 1.0, 6, 64, 0.4, 0.3, 1e-10),  # Case 1: Well-resolved\n        (5.0, 0.7, 10, 21, 0.25, 0.5, 1e-9),   # Case 2: Nyquist boundary\n        (8.0, 1.2, 12, 16, 0.3, 0.1, 1e-6),   # Case 3: Under-resolved (aliased)\n        (2.0, 0.5, 0, 8, 0.6, 0.0, 1e-12)    # Case 4: Zeroth-order check\n    ]\n\n    results = []\n    for case in test_cases:\n        k, Rs, p, N, alpha, delta, epsilon = case\n        result = reciprocity_test(k, Rs, p, N, alpha, delta, epsilon)\n        results.append(str(result))\n\n    # Print the final output in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}