{
    "hands_on_practices": [
        {
            "introduction": "自适应交叉近似（ACA）为何能被视为一种“快速”算法？其效率的理论基础是什么？本练习将引导你推导在层次矩阵（H-matrix）框架下，ACA算法的关键计算复杂度。通过这个推导，你将能从第一性原理出发，验证其准线性缩放特性，这正是ACA能够高效处理大规模问题的核心所在 ()。",
            "id": "3287917",
            "problem": "在时谐计算电磁学的边界积分表述中，对 $N$ 个边界未知量进行伽辽金离散化，会产生一个稠密系统矩阵，其元素由一个弱奇异核的成对求值给出。分层矩阵（H-矩阵）表示法使用索引集上的平衡聚类树将矩阵划分为块，并通过低秩压缩处理良隔（可容许）块，直接处理近场块。考虑一个构建在深度为 $\\mathcal{O}(\\log N)$ 的平衡二叉聚类树上的H-矩阵，其中可容许块的数量为 $\\mathcal{O}(N \\log N)$，每个核函数元素的求值成本为 $\\mathcal{O}(1)$。\n\n对于一个可容许块 $\\mathbf{B} \\in \\mathbb{C}^{m \\times n}$，自适应交叉近似（ACA）通过迭代地添加秩-1外积来寻求秩-r分解，直到满足预设的容差。在每次ACA迭代中，通过扫描当前残差的列向量和行向量的模（或它们的即时求值），选择一个主元列索引 $j_{k}$ 和一个主元行索引 $i_{k}$，并通过核函数调用来求值相应的主元列和主元行。假设以下在快速构建中为标准的建模假设：\n- 每次完整主元列的求值需要 $\\mathcal{O}(m)$ 次核函数调用，扫描它以选择 $i_{k}$ 需要额外的 $\\mathcal{O}(m)$ 次运算。\n- 每次完整主元行的求值需要 $\\mathcal{O}(n)$ 次核函数调用，扫描它以选择 $j_{k+1}$ 需要额外的 $\\mathcal{O}(n)$ 次运算。\n- 为秩-1更新构建和附加长度为 $m$ 和长度为 $n$ 的因子向量，包括必要的重新缩放，每次迭代需要 $\\mathcal{O}(m+n)$ 次算术运算。\n- 当达到数值秩 $r$（对于固定的频率和可容许性参数，该秩独立于 $N$）时，算法终止。\n\n仅使用这些假设，并且不调用任何现成的复杂度公式，完成以下任务：\n- 以大$\\mathcal{O}$表示法，推导单个块的操作计数，作为 $m$、$n$ 和 $r$ 的函数，其中包括主元搜索和列/行求值。\n- 然后，将此成本在H-矩阵的所有可容许块上进行累加，以大$\\mathcal{O}$表示法获得总的渐近成本，作为 $N$ 和 $r$ 的函数。推导中仅使用以下事实：在平衡树中，可容许块的数量为 $\\mathcal{O}(N \\log N)$，并且每个索引在各层级中参与 $\\mathcal{O}(\\log N)$ 次可容许相互作用。\n\n仅报告所有可容许块上的最终总渐近成本，以大$\\mathcal{O}$表示法作为您的答案。不需要数值近似。",
            "solution": "该问题是有效的。它在科学上基于计算科学中快速多极子和分层矩阵方法这一成熟领域。问题是适定的，提供了一套清晰的假设和一个明确定义的目标。它的陈述是客观的，并包含足够、一致的信息，以便对所要求的渐近复杂度进行严格推导。\n\n总渐近成本的推导分为两个主要阶段：首先，确定对单个可容许块应用自适应交叉近似（ACA）的成本；其次，将此成本在H-矩阵结构内的所有可容许块上进行累加。\n\n首先，我们确定为单个可容许块 $\\mathbf{B} \\in \\mathbb{C}^{m \\times n}$ 构建一个秩-r ACA的计算成本。ACA算法是迭代的，每步构建一个秩-1更新，共进行 $r$ 步，因为假定目标秩 $r$ 会被达到。我们基于所提供的假设来分析单次迭代（例如第 $k$ 次迭代）的成本。\n\n$1$. 必须选择并求值一个主元列。这需要选择一个索引 $j_k$。然后计算残差矩阵的相应列。问题陈述，求值完整主元列的成本（通过核函数调用）为 $\\mathcal{O}(m)$。\n$2$. 然后扫描此列以找到对应最大模条目的主元行索引 $i_k$。此扫描需要额外的 $\\mathcal{O}(m)$ 次运算。\n$3$. 然后求值与索引 $i_k$ 对应的主元行。这需要 $\\mathcal{O}(n)$ 次运算。\n$4$. 扫描此行以找到下一个主元列索引 $j_{k+1}$。此扫描需要额外的 $\\mathcal{O}(n)$ 次运算。\n$5$. 最后，形成并缩放秩-1更新向量（一个长度为 $m$ 的列向量和一个长度为 $n$ 的行向量）。据称这需要 $\\mathcal{O}(m+n)$ 次算术运算。\n\nACA单次迭代的总成本是这些步骤成本的总和：\n$$ \\text{Cost per iteration} = \\mathcal{O}(m) + \\mathcal{O}(m) + \\mathcal{O}(n) + \\mathcal{O}(n) + \\mathcal{O}(m+n) = \\mathcal{O}(m+n) $$\n由于算法执行 $r$ 次这样的迭代以达到目标秩，并且秩 $r$ 独立于 $m$ 和 $n$，因此近似单个 $m \\times n$ 块的总成本为：\n$$ \\text{Cost}_{\\text{ACA}}(\\mathbf{B}) = r \\cdot \\mathcal{O}(m+n) = \\mathcal{O}(r(m+n)) $$\n接下来，我们将此单位块成本在H-矩阵中的所有可容许块上进行累加。设 $\\mathcal{A}$ 为所有可容许块的集合。每个块对应于一个行索引聚类 $\\tau$ 和一个列索引聚类 $\\sigma$ 之间的相互作用，使得块的大小为 $|\\tau| \\times |\\sigma|$。总成本 $C_{\\text{total}}$ 是 $\\mathcal{A}$ 中所有块的成本之和。\n$$ C_{\\text{total}} = \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} \\text{Cost}_{\\text{ACA}}(\\mathbf{B}_{\\tau, \\sigma}) = \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} \\mathcal{O}(r(|\\tau| + |\\sigma|)) $$\n由于 $r$ 是相对于求和的常数因子，我们可以写成：\n$$ C_{\\text{total}} = \\mathcal{O}(r) \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} (|\\tau| + |\\sigma|) = \\mathcal{O}(r) \\left( \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} |\\tau| + \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} |\\sigma| \\right) $$\n为了求出这个和，我们使用所提供的关键信息：“每个索引在各层级中参与 $\\mathcal{O}(\\log N)$ 次可容许相互作用”。我们来分析第一个和，$S_{\\text{rows}} = \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} |\\tau|$。我们可以通过首先对单个行索引 $p \\in \\{1, \\dots, N\\}$ 求和来重写这个和：\n$$ S_{\\text{rows}} = \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} \\sum_{p \\in \\tau} 1 $$\n通过交换求和顺序，我们得到：\n$$ S_{\\text{rows}} = \\sum_{p=1}^{N} \\sum_{\\substack{(\\tau, \\sigma) \\in \\mathcal{A} \\\\ p \\in \\tau}} 1 $$\n内部的和计算了索引 $p$ 作为行聚类 $\\tau$ 成员的可容许块 $(\\tau, \\sigma)$ 的数量。根据问题陈述，对于每个索引 $p$，这个数量是 $\\mathcal{O}(\\log N)$。将此代入 $S_{\\text{rows}}$ 的表达式中：\n$$ S_{\\text{rows}} = \\sum_{p=1}^{N} \\mathcal{O}(\\log N) = N \\cdot \\mathcal{O}(\\log N) = \\mathcal{O}(N \\log N) $$\n根据基于对称性的相同论证，对列维度的求和 $S_{\\text{cols}} = \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} |\\sigma|$ 也是 $\\mathcal{O}(N \\log N)$。\n$$ S_{\\text{cols}} = \\sum_{q=1}^{N} \\sum_{\\substack{(\\tau, \\sigma) \\in \\mathcal{A} \\\\ q \\in \\sigma}} 1 = \\sum_{q=1}^{N} \\mathcal{O}(\\log N) = \\mathcal{O}(N \\log N) $$\n最后，我们将这些结果代回到总成本的表达式中：\n$$ C_{\\text{total}} = \\mathcal{O}(r) (S_{\\text{rows}} + S_{\\text{cols}}) = \\mathcal{O}(r) (\\mathcal{O}(N \\log N) + \\mathcal{O}(N \\log N)) $$\n这可以简化为基于ACA的所有可容许块组装的最终渐近总成本。\n$$ C_{\\text{total}} = \\mathcal{O}(r N \\log N) $$\n此复杂度表示构建H-矩阵远场部分的压缩表示所需的算术运算总数。",
            "answer": "$$\n\\boxed{\\mathcal{O}(r N \\log N)}\n$$"
        },
        {
            "introduction": "理论算法在应用于物理问题时，必须考虑其数值实现是否会破坏底层的物理守恒律。在电磁学中，互易性原理表现为矩量法矩阵的对称性 ($Z = Z^\\top$)，然而标准的ACA算法在迭代过程中可能会破坏这种对称性。本练习要求你通过编码实践，实现一个修正的ACA算法，以在近似过程中强制保持对称性，从而深入理解算法的数值稳定性与物理约束之间的联系 ()。",
            "id": "3287916",
            "problem": "你的任务是研究在自适应交叉近似 (ACA) 主元选择过程中，对于复数值、不定的电场积分方程 (EFIE) 阻抗块的对称性保持问题。考虑一个均匀、各向同性、互易的介质，因此通过矩量法 (MoM) 在 Galerkin 方案下使用相同的测试函数和基函数构建的电场积分方程 (EFIE) 阻抗矩阵 $Z$ 满足互易对称性 $Z = Z^\\top$（转置，而非共轭转置）。对于半径为 $R$ 的圆形导线上的 $N$ 个配置点集合，定义平面上圆周的位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$，其中 $\\mathbf{r}_i = \\left(R \\cos\\theta_i, R \\sin\\theta_i, 0\\right)$ 且 $\\theta_i = 2\\pi(i-1)/N$。设波数为 $k$（单位：弧度/米），面元尺寸参数为 $a$（单位：米）。自由空间标量格林函数定义为 $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{e^{\\mathrm{i} k \\|\\mathbf{r} - \\mathbf{r}'\\|}}{\\|\\mathbf{r} - \\mathbf{r}'\\|}$，EFIE 块的元素近似为\n$$\nZ_{ij} = a^2 \\, G\\!\\left(\\mathbf{r}_i,\\mathbf{r}_j\\right) = a^2 \\, \\frac{e^{\\mathrm{i} k d_{ij}}}{d_{ij}},\n$$\n其中 $d_{ij} = \\max\\!\\left(\\|\\mathbf{r}_i - \\mathbf{r}_j\\|, a\\right)$ 通过使用 $d_{ii} = a$ 对对角线进行正则化。距离 $\\|\\cdot\\|$ 和 $a$ 的单位是米，而 $k$ 的单位是弧度/米。这种构造方法通过互易对称性 $G(\\mathbf{r},\\mathbf{r}') = G(\\mathbf{r}',\\mathbf{r})$ 产生一个复数值、不定的矩阵 $Z$，该矩阵满足 $Z = Z^\\top$。\n\n将自适应交叉近似 (ACA) 的近似矩阵 $Z_{\\text{ACA}}$ 定义为 $K$ 个带有残差驱动主元选择的秩一更新之和。在一次从未校正的、从零近似开始的单边 ACA 迭代中，在第 $t$ 次迭代时：\n1. 计算残差 $R^{(t)} = Z - Z_{\\text{ACA}}^{(t)}$。\n2. 选择一个主元索引 $(i_t,j_t)$ 以最大化 $\\left|R^{(t)}_{i_t,j_t}\\right|$。\n3. 构建列向量 $c_t = R^{(t)}(:,j_t)$、行向量 $r_t = R^{(t)}(i_t,:)$ 和主元 $p_t = R^{(t)}_{i_t,j_t}$。\n4. 更新 $Z_{\\text{ACA}}^{(t+1)} = Z_{\\text{ACA}}^{(t)} + \\frac{1}{p_t} \\, c_t \\, r_t^\\top$。\n\n众所周知，即使 $Z$ 是对称的，未校正的更新也会破坏互易对称性，因为 $\\frac{1}{p_t} \\, c_t \\, r_t^\\top$ 通常不是对称的。一种恢复互易对称性的简单主元校正方法是将每个秩一更新对称化为\n$$\n\\Delta Z_t^{\\text{sym}} = \\frac{1}{2}\\left(\\frac{1}{p_t} c_t r_t^\\top + \\left(\\frac{1}{p_t} c_t r_t^\\top\\right)^\\top\\right),\n$$\n这会强制 $\\Delta Z_t^{\\text{sym}} = \\left(\\Delta Z_t^{\\text{sym}}\\right)^\\top$，从而对所有 $t$ 保持 $Z_{\\text{ACA}}^{(t)} = \\left(Z_{\\text{ACA}}^{(t)}\\right)^\\top$。\n\n你的任务是实现未校正和主元校正的 ACA 方案，计算每种近似的对称性缺陷，并验证主元校正方案是否达到指定的容差。使用以下定义：\n- 近似矩阵 $A$ 的相对对称性缺陷为\n$$\n\\delta(A) = \\frac{\\|A - A^\\top\\|_F}{\\|Z\\|_F},\n$$\n其中 $\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。\n- ACA 在迭代次数达到 $K$ 或当前主元的大小低于一个小的数值阈值 $\\tau$ 时终止。\n\n为每个测试用例构建 $Z$，使用相同的 $(K,\\tau)$ 分别通过未校正 ACA 和主元校正 ACA 计算 $Z_{\\text{ACA}}$，并报告主元校正的 $Z_{\\text{ACA}}$ 是否对给定的容差 $\\epsilon$ 满足 $\\delta\\!\\left(Z_{\\text{ACA}}\\right) \\le \\epsilon$。\n\n单位和数值约定：\n- 距离 $\\|\\mathbf{r}_i - \\mathbf{r}_j\\|$ 和面元尺寸 $a$ 的单位必须是米。\n- 波数 $k$ 的单位必须是弧度/米。\n- 用于在圆上放置点的角度单位是弧度。\n- 容差 $\\epsilon$ 是无量纲的，必须作为小数值处理。\n\n测试套件：\n- 用例 1：$N=32$，$R=0.5$ 米，$a=0.02$ 米，$k=10.0$ 弧度/米，$K=8$，$\\tau=10^{-14}$，$\\epsilon=10^{-10}$。\n- 用例 2：$N=48$，$R=0.5$ 米，$a=0.015$ 米，$k=20.0$ 弧度/米，$K=10$，$\\tau=10^{-14}$，$\\epsilon=10^{-12}$。\n- 用例 3：$N=24$，$R=0.5$ 米，$a=0.05$ 米，$k=3.0$ 弧度/米，$K=6$，$\\tau=10^{-14}$，$\\epsilon=10^{-9}$。\n- 用例 4：$N=12$，$R=0.5$ 米，$a=0.10$ 米，$k=1.0$ 弧度/米，$K=5$，$\\tau=10^{-14}$，$\\epsilon=10^{-12}$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[result1,result2,result3]\"）。对于每个测试用例，如果主元校正的 $Z_{\\text{ACA}}$ 满足 $\\delta\\!\\left(Z_{\\text{ACA}}\\right) \\le \\epsilon$，则输出布尔值 true，否则输出 false。最终输出必须采用以下形式\n$$\n[\\text{bool}_1,\\text{bool}_2,\\text{bool}_3,\\text{bool}_4].\n$$",
            "solution": "该问题要求分析自适应交叉近似 (ACA) 算法在应用于由电场积分方程 (EFIE) 的矩量法 (MoM) 离散化产生的复对称矩阵时的对称性保持情况。我们必须实现标准的、未校正的 ACA 和一个经过主元校正的、对称化的版本，然后对一组给定的测试用例，验证后者是否在指定容差内保持对称性。\n\n首先，我们为阻抗矩阵 $Z$ 建立数学基础。该问题设置在均匀、各向同性和互易的介质中。当使用 Galerkin 方案对 EFIE 进行离散化时（其中测试函数与基函数相同），得到的阻抗矩阵 $Z$ 继承了其底层物理学的互易性。这表现为矩阵是对称的，$Z = Z^\\top$，而非厄米特矩阵。矩阵元素 $Z_{ij}$ 由一个使用点源标量格林函数的简化模型给出：\n$$\nZ_{ij} = a^2 \\, G\\!\\left(\\mathbf{r}_i,\\mathbf{r}_j\\right) = a^2 \\, \\frac{e^{\\mathrm{i} k d_{ij}}}{d_{ij}}\n$$\n其中 $k$ 是波数，$a$ 是面元尺寸参数，$\\mathbf{r}_i, \\mathbf{r}_j$ 是配置点。距离 $d_{ij}$ 被正则化以处理对角线元素（$i=j$），因为其物理距离 $\\|\\mathbf{r}_i - \\mathbf{r}_i\\|$ 为 0。正则化定义为 $d_{ij} = \\max\\!\\left(\\|\\mathbf{r}_i - \\mathbf{r}_j\\|, a\\right)$，这确保了 $d_{ii}=a$，从而防止了除零奇异点。由于欧几里得距离是对称的，即 $\\|\\mathbf{r}_i - \\mathbf{r}_j\\| = \\|\\mathbf{r}_j - \\mathbf{r}_i\\|$，因此 $d_{ij} = d_{ji}$，从而 $Z_{ij} = Z_{ji}$，这证实了所构建的矩阵 $Z$ 确实是对称的。\n\n问题的核心在于 ACA 算法，这是一种生成矩阵低秩近似的快速方法。近似矩阵 $Z_{\\text{ACA}}$ 是通过迭代构建为一系列秩-1 矩阵之和：$Z_{\\text{ACA}} = \\sum_{t=1}^K \\Delta Z_t$。在标准的、未校正的 ACA 方案中，第 $t$ 次迭代的过程如下：\n1. 残差矩阵为 $R^{(t)} = Z - Z_{\\text{ACA}}^{(t)}$，其中 $Z_{\\text{ACA}}^{(t)}$ 是经过 $t-1$ 步后的近似矩阵。初始时，$Z_{\\text{ACA}}^{(1)}$ 是一个零矩阵。\n2. 通过在当前残差中找到绝对值最大的元素来选择主元 $(i_t, j_t)$：$(i_t, j_t) = \\operatorname{argmax}_{(i,j)} |R^{(t)}_{i,j}|$。\n3. 从残差中提取相应的行向量 $r_t = R^{(t)}(i_t, :)$、列向量 $c_t = R^{(t)}(:, j_t)$ 和主元值 $p_t = R^{(t)}_{i_t, j_t}$。\n4. 形成一个秩-1 更新并加到近似矩阵上：$\\Delta Z_t = \\frac{1}{p_t} c_t r_t^\\top$。\n\n问题出现在第 4 步。即使原始矩阵 $Z$ 是对称的，秩-1 更新 $\\Delta Z_t = \\frac{1}{p_t} c_t r_t^\\top$ 通常也不是对称的。这是因为主元选择过程不保证 $i_t=j_t$，而且即使保证了，列向量 $c_t$ 和行向量 $r_t$ 也是从一个可能在先前步骤中已经失去对称性的残差矩阵中提取的。因此，最终的近似矩阵 $Z_{\\text{ACA}}$ 将不是对称的。\n\n为纠正此问题，提出了一种主元校正方案。主元选择过程（步骤 1-3）保持不变，确保了相同的残差驱动的自适应性。然而，更新步骤被修改以显式地强制对称性。新的秩-1 更新 $\\Delta Z_t^{\\text{sym}}$ 是原始更新的对称化版本：\n$$\n\\Delta Z_t^{\\text{sym}} = \\frac{1}{2}\\left(\\frac{1}{p_t} c_t r_t^\\top + \\left(\\frac{1}{p_t} c_t r_t^\\top\\right)^\\top\\right) = \\frac{1}{2p_t}\\left(c_t r_t^\\top + r_t c_t^\\top\\right)\n$$\n由于根据构造 $(\\Delta Z_t^{\\text{sym}})^\\top = \\Delta Z_t^{\\text{sym}}$，在每一步加上这个更新可以保证，如果近似矩阵 $Z_{\\text{ACA}}^{(t)}$ 是对称的，那么 $Z_{\\text{ACA}}^{(t+1)} = Z_{\\text{ACA}}^{(t)} + \\Delta Z_t^{\\text{sym}}$ 也将是对称的。从一个对称的零矩阵开始，最终的近似矩阵 $Z_{\\text{ACA}}$ 保证是对称的。\n\n任务是实现这个校正后的方案并量化其成功程度。成功的度量标准是相对对称性缺陷，定义为：\n$$\n\\delta(A) = \\frac{\\|A - A^\\top\\|_F}{\\|Z\\|_F}\n$$\n其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。对于主元校正方案，我们期望这个缺陷非常接近机器精度，因为不对称性的主要来源是浮点舍入误差。算法在 $K$ 次迭代后，或当主元大小 $|p_t|$ 低于数值阈值 $\\tau$ 时终止。\n\n解决方案按以下步骤进行：\n1. 对于每个测试用例，我们首先在半径为 $R$ 的圆上生成 $N$ 个配置点 $\\mathbf{r}_i$。\n2. 然后，我们根据给定公式构建完整的 $N \\times N$ 复对称矩阵 $Z$，计算正则化的距离 $d_{ij}$，然后计算矩阵元素 $Z_{ij}$。\n3. 我们实现带有对称化更新规则的 ACA 算法。该算法从残差中迭代地确定主元，构建对称化的秩-1 更新，将其加到近似矩阵上，并从残差中减去它。这个过程持续进行，直到完成 $K$ 次迭代或主元大小低于 $\\tau$。\n4. ACA 过程终止后，我们计算所得近似矩阵的相对对称性缺陷 $\\delta(Z_{\\text{ACA}})$。\n5. 最后，我们检查对于给定的容差 $\\epsilon$，是否有 $\\delta(Z_{\\text{ACA}}) \\le \\epsilon$。对每个测试用例记录此检查的布尔结果。\n6. 这些布尔结果的集合构成了最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of verifying symmetry preservation in pivot-corrected ACA.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Format: (N, R, a, k, K, tau, epsilon)\n    test_cases = [\n        (32, 0.5, 0.02, 10.0, 8, 1e-14, 1e-10),\n        (48, 0.5, 0.015, 20.0, 10, 1e-14, 1e-12),\n        (24, 0.5, 0.05, 3.0, 6, 1e-14, 1e-9),\n        (12, 0.5, 0.10, 1.0, 5, 1e-14, 1e-12),\n    ]\n\n    def run_aca_case(N, R, a, k, K, tau, epsilon):\n        \"\"\"\n        Runs a single test case for the ACA symmetry check.\n        \n        Args:\n            N (int): Number of collocation points.\n            R (float): Radius of the circular wire in meters.\n            a (float): Patch size parameter for regularization in meters.\n            k (float): Wavenumber in radians per meter.\n            K (int): Maximum number of ACA iterations.\n            tau (float): Pivot magnitude termination threshold.\n            epsilon (float): Tolerance for the relative symmetry defect.\n\n        Returns:\n            bool: True if the symmetry defect condition is met, False otherwise.\n        \"\"\"\n        # Step 1: Generate collocation points on a circle in the x-y plane.\n        thetas = 2 * np.pi * np.arange(N) / N\n        points = np.zeros((N, 3))\n        points[:, 0] = R * np.cos(thetas)\n        points[:, 1] = R * np.sin(thetas)\n\n        # Step 2: Construct the full impedance matrix Z.\n        # Vectorized computation of pairwise Euclidean distances.\n        diffs = points[:, np.newaxis, :] - points[np.newaxis, :, :]\n        dist_euc = np.linalg.norm(diffs, axis=2)\n        \n        # Apply regularization: d_ij = max(||r_i - r_j||, a)\n        dist_reg = np.maximum(dist_euc, a)\n        \n        # Calculate the matrix Z. Use np.complex128 for precision.\n        # To avoid division by zero if a=0 (not in tests, but good practice),\n        # handle the diagonal separately. However, dist_reg is never zero here.\n        Z = (a**2) * np.exp(1j * k * dist_reg) / dist_reg\n        Z = Z.astype(np.complex128)\n\n        # Step 3: Run the pivot-corrected ACA algorithm.\n        Z_aca = np.zeros_like(Z, dtype=np.complex128)\n        residual = Z.copy()\n        \n        for _ in range(K):\n            # Find the pivot (i_t, j_t) by maximizing |R_ij|.\n            flat_idx = np.argmax(np.abs(residual))\n            i_t, j_t = np.unravel_index(flat_idx, residual.shape)\n            \n            # Get the pivot value.\n            p_t = residual[i_t, j_t]\n            \n            # Check for termination condition based on pivot magnitude.\n            if np.abs(p_t)  tau:\n                break\n            \n            # Extract the pivot row and column from the residual.\n            c_t = residual[:, j_t]\n            r_t = residual[i_t, :]\n            \n            # Form the rank-1 update.\n            update_term = np.outer(c_t, r_t) / p_t\n            \n            # Symmetrize the update to enforce reciprocity.\n            sym_update = 0.5 * (update_term + update_term.T)\n            \n            # Update the ACA approximation and the residual.\n            Z_aca += sym_update\n            residual -= sym_update\n            \n        # Step 4: Calculate the relative symmetry defect.\n        norm_Z_F = np.linalg.norm(Z, 'fro')\n        \n        # Guard against norm_Z_F being zero for an all-zero matrix.\n        if norm_Z_F == 0:\n            # If Z is zero, the only valid approximation is also zero.\n            # A non-zero approximation would have infinite relative defect.\n            return np.linalg.norm(Z_aca - Z_aca.T, 'fro') == 0\n\n        sym_error_norm_F = np.linalg.norm(Z_aca - Z_aca.T, 'fro')\n        defect = sym_error_norm_F / norm_Z_F\n        \n        # Step 5: Verify if the defect is within the prescribed tolerance.\n        return defect = epsilon\n\n    results = []\n    for case in test_cases:\n        result = run_aca_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format \"[bool_1,bool_2,bool_3,bool_4]\".\n    # Python's str(True) is 'True'; convert to lowercase 'true' as per example format.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "自适应交叉近似（ACA）不仅是一种矩阵压缩工具，其输出的数值秩本身也蕴含着丰富的物理信息。相互作用矩阵块的数值秩与其所描述的波现象的物理复杂度直接相关。这项高级实践将指导你利用ACA秩作为一种后验误差指示器，来驱动一个自适应网格加密方案。通过模拟一个接近谐振的腔体，你将看到数值秩如何动态地反映出物理场的复杂区域，并学会利用这一信息来智能地优化计算网格 ()。",
            "id": "3287860",
            "problem": "您需要实现一个完整、可运行的程序，该程序为由自适应交叉近似 (ACA) 秩驱动的边界元相互作用构建一个后验自适应网格加密指示器，并用它来决定哪些边界几何片需要加密。其物理背景是一个二维理想电导方腔，通过标量亥姆霍兹方程的边界积分公式进行建模，数值核函数是二维自由空间格林函数。目标是使用一个简单且通用的计算代理来演示近共振波数如何在非对角相互作用块中引起更高的数值秩，从而根据基于秩的指示器触发更多的网格加密。\n\n请从以下基础开始：\n- 二维时谐标量亥姆霍兹方程为 $\\nabla^2 u + k^2 u = 0$，其中 $u$ 是场，$k$ 是波数。\n- 亥姆霍兹算子的二维自由空间格林函数为 $G_k(\\mathbf{r}, \\mathbf{r}') = \\dfrac{i}{4} H_0^{(1)}(k \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert)$，其中 $H_0^{(1)}$ 是第一类零阶汉克尔函数，$\\lVert \\cdot \\rVert$ 表示欧几里得范数。\n- 对于均匀边界离散化，配置边界元矩阵的元素为 $G_{ij} = G_k(\\mathbf{r}_i, \\mathbf{r}_j) w_j$（当 $i \\neq j$ 时），其中 $\\mathbf{r}_j$ 是面元中点，$w_j$ 是面元长度。自作用项 $i = j$ 对应一个弱奇异性，在本问题中仅考虑非对角片间相互作用时无需处理。\n- 自适应交叉近似 (ACA) 通过自适应地选择主元行和列来形成秩-$r$ 更新，从而构建矩阵块的低秩近似，直到达到相对残差范数容差，由此提供了一个数据驱动的估计量，用于估计将一个块近似到指定精度所需的数值秩。\n\n您必须实现以下步骤：\n1. 几何与离散化。考虑一个边长为 $a = 1$ 的方腔，其边界被均匀离散为 $M = 160$ 个直线面元。使用 $M = 160$ 个面元。将面元长度记为 $h = \\dfrac{4}{M}$，面元中点记为 $\\{\\mathbf{r}_j\\}_{j=1}^M$，从底边中点开始按逆时针顺序排列。构建稠密复值矩阵 $G \\in \\mathbb{C}^{M \\times M}$，其元素为\n   - $G_{ij} = \\dfrac{i}{4} H_0^{(1)}\\!\\left(k \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert\\right) h$，当 $i \\neq j$ 时，\n   - $G_{ii} = 0$（在此任务中不使用对角线元素）。\n2. 片分区。将索引集 $\\{1,2,\\dots,M\\}$ 划分为 $P = 8$ 个大小相等的连续片，每个片包含 $M/P = 20$ 个连续索引，并保持边界顺序。\n3. 基于 ACA 的秩指示器。对于给定的波数 $k$，对每个片 $p \\in \\{0,1,\\dots,P-1\\}$：\n   - 定义相邻集合 $\\mathcal{N}(p) = \\{(p-1) \\bmod P, (p+1) \\bmod P\\}$。\n   - 对于每个相邻片 $q \\in \\mathcal{N}(p)$，形成非对角相互作用块 $B_{pq} = G[I_p, I_q]$，其中 $I_p$ 和 $I_q$ 分别是片 $p$ 和 $q$ 的索引集。\n   - 估计 $B_{pq}$ 的 ACA 数值秩 $r_{pq}$，该秩为最小整数 $r$，使得 ACA 近似的弗罗贝尼乌斯范数相对残差小于容差 $\\varepsilon = 10^{-3}$，并有硬上限 $r \\leq \\min(\\lvert I_p \\rvert, \\lvert I_q \\rvert)$。\n   - 定义片指示器为 $I_p = \\max_{q \\in \\mathcal{N}(p)} r_{pq}$。\n4. 加密决策规则。给定秩阈值 $R_{\\mathrm{thr}} = 6$，当且仅当 $I_p  R_{\\mathrm{thr}}$ 时，标记片 $p$ 进行加密。一个加密步骤会将每个标记片的面元分割成两个相等的面元，但对于此任务，您只需报告每个测试用例在第一次迭代时将被加密的片的数量。\n5. 通过近共振行为进行验证。考虑一个具有狄利克雷边界条件的二维矩形腔，其特征波数约为 $k_{mn} \\approx \\pi \\sqrt{m^2 + n^2}/a$（其中 $m, n$ 为正整数）。使用 $a=1$ 并以近共振情况 $k \\approx \\pi \\sqrt{2}$ 为目标，这是方腔的 $(m,n)=(1,1)$ 模。虽然使用自由空间核的边界积分是一种简化，但为解析振荡相互作用所需的块秩通常随 $k$ 的增加而增加，从而使得基于秩的自适应加密指示器成为可能。\n\n您必须实现完整的程序，包括 ACA 例程，并对以下波数测试集评估加密计数：\n- 测试用例 1（低频基线）：$k = 0.2$。\n- 测试用例 2（离共振中等频率）：$k = 1.0$。\n- 测试用例 3（近共振）：$k = \\pi \\sqrt{2}$。\n\n对于每个测试用例，运行上述步骤并计算满足 $I_p  R_{\\mathrm{thr}}$ 的片的整数数量。您的程序应生成单行输出，其中包含一个逗号分隔并用方括号括起来的结果列表，按测试用例的顺序排列，例如 $[n_1,n_2,n_3]$，其中每个 $n_j$ 是测试用例 $j$ 中标记为需要加密的片的计数。输出中不需要角度或有量纲的物理单位，因为结果是无量纲整数。确保本问题中出现的所有数值常数和参数，包括 $M = 160$、$P = 8$、$\\varepsilon = 10^{-3}$ 和 $R_{\\mathrm{thr}} = 6$，都完全按照规定使用。",
            "solution": "该问题要求实现一个计算程序，以识别离散化边界上需要进行网格加密的区域。其背景是使用边界元法 (BEM) 在方腔内数值求解二维标量亥姆霍兹方程 $\\nabla^2 u + k^2 u = 0$。加密决策基于一个后验误差指示器，该指示器源自边界片之间相互作用矩阵的数值秩，这些数值秩通过自适应交叉近似 (ACA) 算法估算。需要验证的核心假设是，近共振波数会导致更高的数值秩，从而触发更多的加密。\n\n解决方案按以下逻辑步骤构建：\n\n1.  **边界离散化与矩阵构建**：\n    边长为 $a=1$ 的方腔边界被离散为 $M=160$ 个均匀的直线段，或称面元。总周长为 $4a=4$，因此每个面元的长度为 $h = 4/M = 0.025$。几何结构由一组面元中点 $\\{\\mathbf{r}_j\\}_{j=1}^M$ 定义。按照规定，排序始于底边中点 $(0.5, 0)$ 处最后一个面元和第一个面元之间的边界，并按逆时针方向进行。\n\n    亥姆霍兹方程的边界元法通过一个涉及自由空间格林函数的积分方程来关联边界值。对于配置法，这会产生一个稠密线性系统 $G \\mathbf{x} = \\mathbf{y}$。矩阵 $G \\in \\mathbb{C}^{M \\times M}$ 表示所有面元对之间的相互作用。其元素由下式给出：\n    $$ G_{ij} = G_k(\\mathbf{r}_i, \\mathbf{r}_j) w_j = \\frac{i}{4} H_0^{(1)}(k \\|\\mathbf{r}_i - \\mathbf{r}_j\\|) h $$\n    其中 $i \\neq j$。这里，$k$ 是波数，$H_0^{(1)}$ 是第一类零阶汉克尔函数，表示出射柱面波，$w_j = h$ 是积分权重，取为面元长度。对角线元素 $G_{ii}$ 涉及一个奇异核，在本问题中不需要，因此我们将其设置为 $G_{ii}=0$。\n\n2.  **基于片的分区**：\n    为了局部地分析相互作用，所有面元索引的集合 $\\{0, 1, \\dots, M-1\\}$ 被划分为 $P=8$ 个连续的、不重叠的片。每个片 $p \\in \\{0, \\dots, P-1\\}$ 包含 $M/P = 20$ 个连续的面元索引。这种分区将稠密矩阵 $G$ 划分为一个 $P \\times P$ 的块矩阵，其中每个块 $B_{pq} = G[I_p, I_q]$ 包含片 $p$ 中的面元与片 $q$ 中的面元之间的相互作用。\n\n3.  **用于秩估计的自适应交叉近似 (ACA)**：\n    相互作用块 $B_{pq}$ 的数值秩为其复杂性提供了一个定量度量。平滑、缓慢变化的相互作用可以通过低秩近似精确表示，而高度振荡的相互作用则需要更高的秩。ACA 是一种纯代数、仅基于矩阵的算法，用于构建这种低秩近似 $B_{pq} \\approx U V^H$，其中 $U$ 和 $V$ 是具有少量列（即 $r$）的矩阵。\n\n    该算法迭代进行。从一个残差矩阵 $R_0 = B_{pq}$ 开始，在每一步 $k$，它在当前残差 $R_k$ 中识别出绝对值最大的元素（主元）。一个由 $R_k$ 的相应行和列构成的秩-1 矩阵被用来更新近似，并相应地更新残差：$R_{k+1} = R_k - \\mathbf{u}_k \\mathbf{v}_k^H$。这个过程持续进行，直到残差的弗罗贝尼乌斯范数 $\\|R_r\\|_F$ 相对于原始块的范数低于指定的容差，即 $\\|B_{pq} - U_r V_r^H\\|_F \\leq \\varepsilon \\|B_{pq}\\|_F$。达到此标准所需的步数 $r$ 即为该块在容差 $\\varepsilon=10^{-3}$ 下的估计数值秩。\n\n4.  **基于秩的加密指示器**：\n    该指示器背后的物理原理是，近共振腔内的场是高度复杂和振荡的。这种复杂性反映在 BEM 矩阵中，即对应于这些复杂场的相互作用块表现出高数值秩。因此，秩可以作为局部解误差的有效代理。\n\n    对于每个片 $p$，我们考虑它与沿边界的直接相邻片之间的相互作用，这些相邻片由集合 $\\mathcal{N}(p) = \\{(p-1) \\bmod P, (p+1) \\bmod P\\}$ 定义。相应相互作用块的 ACA 估计秩 $r_{pq}$（其中 $q \\in \\mathcal{N}(p)$）量化了这些相互作用的复杂性。高秩表示当前网格难以解析这些片之间潜在的场行为。为保守起见，片 $p$ 的加密指示器被定义为这些秩的最大值：\n    $$ I_p = \\max_{q \\in \\mathcal{N}(p)} r_{pq} $$\n\n5.  **加密决策与验证**：\n    应用一个简单的决策规则：如果一个片 $p$ 的指示器 $I_p$ 超过了预定义的阈值 $R_{\\mathrm{thr}}=6$，则标记该片进行加密。这意味着，只要与任一相邻片的相互作用足够复杂，该片的离散化就被认为是不充分的。\n\n    验证通过测试三个波数来进行：\n    -   $k = 0.2$：一个低频，远离任何共振。相互作用预计是平滑的，导致低秩且无需加密。\n    -   $k = 1.0$：一个中等的、离共振的频率。秩可能会略有增加，但预计将保持在阈值以下。\n    -   $k = \\pi\\sqrt{2} \\approx 4.44$：选择此值是为了接近方形狄利克雷腔的基共振模 $(1,1)$（$k_{11} = \\pi \\sqrt{1^2+1^2}/a$）。在近共振时，场变得高度振荡，我们预计数值秩将显著增加，导致指示器 $I_p$ 超过阈值 $R_{\\mathrm{thr}}$，从而触发多个片的加密。\n\n该实现将构建几何结构和 BEM 矩阵，然后对每个测试用例的波数，迭代遍历所有片，计算相邻相互作用的 ACA 秩，评估指示器，并计算满足加密标准的片的数量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import hankel1\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Problem constants\n    a = 1.0  # Side length of the square cavity\n    M = 160  # Total number of panels\n    P = 8    # Number of patches\n    epsilon = 1e-3  # ACA relative tolerance\n    R_thr = 6      # Rank threshold for refinement\n\n    # Test cases\n    test_cases_k = [\n        0.2,                   # Low-frequency baseline\n        1.0,                   # Off-resonant moderate\n        np.pi * np.sqrt(2.0),  # Near-resonant\n    ]\n\n    # Generate geometry once, as it's independent of k\n    panel_midpoints, panel_length = generate_geometry(M, a)\n\n    results = []\n    for k in test_cases_k:\n        # 1. Construct the BEM matrix for the given wavenumber k\n        G = build_bem_matrix(k, panel_midpoints, panel_length)\n        \n        # 2. Calculate the number of patches to refine\n        refinement_count = calculate_refinement_count(G, M, P, epsilon, R_thr)\n        results.append(refinement_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef generate_geometry(M, a):\n    \"\"\"\n    Generates the panel midpoints for a square cavity.\n    The ordering starts from the right of the middle of the bottom edge and proceeds counter-clockwise.\n    \"\"\"\n    if M % 4 != 0:\n        raise ValueError(\"M must be a multiple of 4.\")\n    \n    M_side = M // 4\n    h = a / M_side\n    \n    points = np.zeros((M, 2))\n    \n    # The split point is at (0.5*a, 0).\n    # Panels are ordered starting from the right of this split point.\n    \n    # Indices 0 to M_side/2 - 1: Bottom-right edge\n    n_br = M_side // 2\n    for j in range(n_br):\n        points[j, 0] = a * 0.5 + (j + 0.5) * h\n        points[j, 1] = 0.0\n\n    # Indices n_br to n_br + M_side - 1: Right edge\n    for j in range(M_side):\n        idx = j + n_br\n        points[idx, 0] = a\n        points[idx, 1] = (j + 0.5) * h\n\n    # Indices n_br + M_side to n_br + 2*M_side - 1: Top edge\n    for j in range(M_side):\n        idx = j + n_br + M_side\n        points[idx, 0] = a - (j + 0.5) * h\n        points[idx, 1] = a\n\n    # Indices n_br + 2*M_side to n_br + 3*M_side - 1: Left edge\n    for j in range(M_side):\n        idx = j + n_br + 2 * M_side\n        points[idx, 0] = 0.0\n        points[idx, 1] = a - (j + 0.5) * h\n\n    # Indices n_br + 3*M_side to M-1: Bottom-left edge\n    for j in range(n_br):\n        idx = j + n_br + 3 * M_side\n        points[idx, 0] = (j + 0.5) * h\n        points[idx, 1] = 0.0\n        \n    return points, 4.0 * a / M\n\n\ndef build_bem_matrix(k, panel_midpoints, h):\n    \"\"\"\n    Constructs the dense BEM matrix G.\n    \"\"\"\n    M = panel_midpoints.shape[0]\n    \n    # Use broadcasting for efficient distance calculation\n    # diffs.shape = (M, M, 2)\n    diffs = panel_midpoints[:, np.newaxis, :] - panel_midpoints[np.newaxis, :, :]\n    # distances.shape = (M, M)\n    distances = np.linalg.norm(diffs, axis=2)\n    \n    # Avoid division by zero for diagonal elements, though they will be overwritten\n    np.fill_diagonal(distances, 1.0)\n    \n    # Calculate Green's function values\n    G = (1j / 4.0) * hankel1(0, k * distances) * h\n    \n    # Set diagonal elements to 0 as specified\n    np.fill_diagonal(G, 0)\n    \n    return G\n\n\ndef aca(matrix_block, tol):\n    \"\"\"\n    Estimates the numerical rank of a matrix block using Adaptive Cross Approximation.\n    \"\"\"\n    m, n = matrix_block.shape\n    max_rank = min(m, n)\n    \n    residual = matrix_block.copy()\n    norm_fro_orig_sq = np.sum(np.abs(matrix_block)**2)\n\n    if norm_fro_orig_sq == 0:\n        return 0\n    \n    rank = 0\n    for r in range(max_rank):\n        # Find the pivot element in the current residual matrix\n        flat_idx = np.argmax(np.abs(residual))\n        i_piv, j_piv = np.unravel_index(flat_idx, residual.shape)\n        \n        pivot_val = residual[i_piv, j_piv]\n        \n        # If residual matrix is numerically zero, stop\n        if np.abs(pivot_val)**2  1e-30 * norm_fro_orig_sq:\n            break\n            \n        u_vec = residual[:, j_piv].reshape(m, 1)\n        v_vec_H = (residual[i_piv, :] / pivot_val).reshape(1, n)\n        \n        # Update the residual with a rank-1 matrix\n        residual -= u_vec @ v_vec_H\n        \n        rank += 1\n        \n        # Check stopping criterion based on Frobenius norm of the residual\n        norm_fro_res_sq = np.sum(np.abs(residual)**2)\n        if norm_fro_res_sq  tol**2 * norm_fro_orig_sq:\n            return rank\n            \n    return rank\n\n\ndef calculate_refinement_count(G, M, P, epsilon, R_thr):\n    \"\"\"\n    Calculates the number of patches to be refined based on ACA ranks.\n    \"\"\"\n    panels_per_patch = M // P\n    refinement_count = 0\n    \n    for p in range(P):\n        # Define neighbor patches\n        q_prev = (p - 1 + P) % P\n        q_next = (p + 1) % P\n        \n        # Get index sets for the current patch and its neighbors\n        I_p_slice = slice(p * panels_per_patch, (p + 1) * panels_per_patch)\n        I_q_prev_slice = slice(q_prev * panels_per_patch, (q_prev + 1) * panels_per_patch)\n        I_q_next_slice = slice(q_next * panels_per_patch, (q_next + 1) * panels_per_patch)\n        \n        # Extract interaction blocks\n        B_pq_prev = G[I_p_slice, I_q_prev_slice]\n        B_pq_next = G[I_p_slice, I_q_next_slice]\n        \n        # Estimate numerical ranks using ACA\n        r_pq_prev = aca(B_pq_prev, epsilon)\n        r_pq_next = aca(B_pq_next, epsilon)\n        \n        # Define patch indicator\n        Indicator_p = max(r_pq_prev, r_pq_next)\n        \n        # Apply refinement rule\n        if Indicator_p > R_thr:\n            refinement_count += 1\n            \n    return refinement_count\n\n# Entry point of the script\nif __name__ == \"__main__\":\n    # Correction in the aca function for Python 3.9+ compatibility\n    # The original implementation of the ACA update used np.outer, which does not handle complex\n    # conjugation for the second vector correctly for a rank-1 update (u * v^H).\n    # Correcting it to use matrix multiplication with explicit reshaping.\n    original_aca = aca\n    def aca_fixed(matrix_block, tol):\n        m, n = matrix_block.shape\n        max_rank = min(m, n)\n        residual = matrix_block.copy()\n        norm_fro_orig_sq = np.sum(np.abs(matrix_block)**2)\n        if norm_fro_orig_sq == 0:\n            return 0\n        rank = 0\n        for r in range(max_rank):\n            flat_idx = np.argmax(np.abs(residual))\n            i_piv, j_piv = np.unravel_index(flat_idx, residual.shape)\n            pivot_val = residual[i_piv, j_piv]\n            if np.abs(pivot_val)**2  1e-30 * norm_fro_orig_sq:\n                break\n            u_vec = residual[:, j_piv].reshape(m, 1)\n            # The rank-1 update for ACA on A = UV^H requires v_k = (R_{i_k,:})^H / conj(p_k)\n            # which means R_k+1 = R_k - u_k * v_k^H.\n            # v_k^H = R_{i_k,:} / p_k.\n            v_vec_T_equiv = residual[i_piv, :] / pivot_val\n            residual -= np.outer(u_vec, v_vec_T_equiv) # This is u * v^T, not u * v^H. For complex matrices, it should be u * (v^H)\n            \n            # The line above is a subtle bug source. For complex matrices, the outer product np.outer(a,b) is a * b, not a * b.conj().\n            # Let's fix this update step to be robust for complex matrices.\n            # The update is u_k v_k^T. The original solution had a slight error in not conjugating.\n            # The problem statement in the parent document uses v_k^T, implying no conjugate transpose.\n            # So, R_k+1 = R_k - u_k * v_k^T.\n            # However, the numerical analysis convention is often A approx U V^H. Let's stick to the text's v_k^T.\n            # The original code's `np.outer(u_vec, v_vec_T)` is correct for v_k^T, so let's revert to a simplified version.\n            u_vec = residual[:, j_piv]\n            v_vec_T = residual[i_piv, :] / pivot_val\n            residual -= np.outer(u_vec, v_vec_T)\n            \n            rank += 1\n            norm_fro_res_sq = np.sum(np.abs(residual)**2)\n            if norm_fro_res_sq  tol**2 * norm_fro_orig_sq:\n                return rank\n        return rank\n    # Overwrite the function with the bug-fixed version.\n    # The original implementation in the answer had a reshape error. np.outer takes 1D arrays.\n    # Correcting the bug in my own thought process.\n    def aca_final(matrix_block, tol):\n        m, n = matrix_block.shape\n        max_rank = min(m, n)\n        residual = matrix_block.copy()\n        norm_fro_orig_sq = np.sum(np.abs(matrix_block)**2)\n        if norm_fro_orig_sq  1e-30:\n            return 0\n        rank = 0\n        for r in range(max_rank):\n            flat_idx = np.argmax(np.abs(residual))\n            i_piv, j_piv = np.unravel_index(flat_idx, residual.shape)\n            pivot_val = residual[i_piv, j_piv]\n            if np.abs(pivot_val)**2  1e-30 * norm_fro_orig_sq:\n                break\n            u_vec = residual[:, j_piv]\n            v_vec_T = residual[i_piv, :] / pivot_val\n            residual -= np.outer(u_vec, v_vec_T)\n            rank += 1\n            norm_fro_res_sq = np.sum(np.abs(residual)**2)\n            if norm_fro_res_sq  tol**2 * norm_fro_orig_sq:\n                return rank\n        return rank\n        \n    # Re-assign the function to be used\n    global aca\n    aca = aca_final\n    solve()\n```"
        }
    ]
}