{
    "hands_on_practices": [
        {
            "introduction": "自适应交叉近似（ACA）等快速算法的核心优势在于其计算效率。本练习将引导您从第一性原理出发，推导在分层矩阵（H-matrix）框架下使用ACA进行矩阵压缩所需的总运算成本。通过这个推导，您将深入理解为何ACA能够将稠密矩阵的组装复杂度从 $O(N^2)$ 降低到准线性复杂度 $O(N \\log N)$，这是现代快速求解器有效性的理论基石。",
            "id": "3287917",
            "problem": "在时谐计算电磁学的边界积分公式中，对 $N$ 个边界未知量进行伽辽金（Galerkin）离散化，会产生一个稠密系统矩阵，其元素由弱奇异核的成对求值给出。分层矩阵（H-矩阵）表示法使用索引集上的平衡聚类树将矩阵划分为块，并通过低秩压缩处理远场（可容许）块，直接处理近场块。考虑一个建立在深度为 $\\mathcal{O}(\\log N)$ 的平衡二元聚类树上的H-矩阵，其中可容许块的数量为 $\\mathcal{O}(N \\log N)$，每个核函数项的求值成本为 $\\mathcal{O}(1)$。\n\n对于一个可容许块 $\\mathbf{B} \\in \\mathbb{C}^{m \\times n}$，自适应交叉近似（Adaptive Cross Approximation, ACA）通过迭代添加秩-1外积来寻求秩-$r$分解，直到满足预设的容差。在每次ACA迭代中，通过扫描当前残差的列向量和行向量（或它们的即时求值）的幅值来选择主元列索引 $j_{k}$ 和主元行索引 $i_{k}$，并相应地通过核函数调用来求值主元列和主元行。假设以下在快速构建中标准的建模假设：\n- 每次完整主元列的求值成本为 $\\mathcal{O}(m)$ 次核函数调用，扫描它以选择 $i_{k}$ 的额外成本为 $\\mathcal{O}(m)$ 次运算。\n- 每次完整主元行的求值成本为 $\\mathcal{O}(n)$ 次核函数调用，扫描它以选择 $j_{k+1}$ 的额外成本为 $\\mathcal{O}(n)$ 次运算。\n- 为秩-1更新构建和附加长度为 $m$ 和长度为 $n$ 的因子向量，包括必要的重新缩放，每次迭代的成本为 $\\mathcal{O}(m+n)$ 次算术运算。\n- 当达到数值秩 $r$（对于固定的频率和可容许性参数，该秩独立于 $N$）时，算法终止。\n\n仅使用这些假设，并且不引用任何现成的复杂度公式，完成以下任务：\n- 以 $\\mathcal{O}$ 表示法，推导单个块的操作计数，作为 $m$、$n$ 和 $r$ 的函数，其中包括主元搜索和列/行求值。\n- 然后，将此成本在H-矩阵的所有可容许块上进行汇总，以 $\\mathcal{O}$ 表示法获得总的渐近成本，作为 $N$ 和 $r$ 的函数，仅使用以下事实：在平衡树中可容许块的数量为 $\\mathcal{O}(N \\log N)$，并且每个索引在所有层级上参与 $\\mathcal{O}(\\log N)$ 次可容许交互。\n\n仅报告所有可容许块上的最终渐近总成本，以 $\\mathcal{O}$ 表示法作为您的答案。不需要数值近似。",
            "solution": "该问题是有效的。它在科学上植根于计算科学中快速多极子和分层矩阵方法的成熟领域。该问题是适定的，提供了一套清晰的假设和一个明确定义的目标。它的陈述是客观的，并包含足够、一致的信息，以便对所要求的渐近复杂度进行严格的推导。\n\n总渐近成本的推导分两个主要阶段进行：首先，确定将自适应交叉近似（ACA）应用于单个可容许块的成本；其次，在H-矩阵结构内将此成本在所有可容许块上进行汇总。\n\n首先，我们确定为单个可容许块 $\\mathbf{B} \\in \\mathbb{C}^{m \\times n}$ 构建秩-$r$ ACA的计算成本。ACA算法是迭代的，每一步构建一个秩-1更新，总共进行 $r$ 步，因为假设达到了目标秩 $r$。我们根据所提供的假设分析单次迭代（例如第 $k$ 次迭代）的成本。\n\n$1$. 必须选择并求值一个主元列。这需要选择一个索引 $j_k$。然后计算残差矩阵的相应列。问题陈述指出，求值完整主元列（通过核函数调用）的成本为 $\\mathcal{O}(m)$。\n$2$. 然后扫描此列以找到对应最大幅值项的主元行索引 $i_k$。此扫描的额外成本为 $\\mathcal{O}(m)$ 次运算。\n$3$. 然后求值与索引 $i_k$ 对应的主元行。此成本为 $\\mathcal{O}(n)$ 次运算。\n$4$. 扫描此行以找到下一个主元列索引 $j_{k+1}$。此扫描的额外成本为 $\\mathcal{O}(n)$ 次运算。\n$5$. 最后，形成并缩放秩-1更新向量（一个长度为 $m$ 的列向量和一个长度为 $n$ 的行向量）。据称此成本为 $\\mathcal{O}(m+n)$ 次算术运算。\n\nACA单次迭代的总成本是这些步骤成本的总和：\n$$ \\text{每次迭代成本} = \\mathcal{O}(m) + \\mathcal{O}(m) + \\mathcal{O}(n) + \\mathcal{O}(n) + \\mathcal{O}(m+n) = \\mathcal{O}(m+n) $$\n由于算法执行 $r$ 次此类迭代以达到目标秩，且秩 $r$ 与 $m$ 和 $n$ 无关，因此逼近单个 $m \\times n$ 块的总成本为：\n$$ \\text{Cost}_{\\text{ACA}}(\\mathbf{B}) = r \\cdot \\mathcal{O}(m+n) = \\mathcal{O}(r(m+n)) $$\n接下来，我们将此单块成本在H-矩阵中的所有可容许块上进行汇总。设 $\\mathcal{A}$ 为所有可容许块的集合。每个块对应于一个行索引聚类 $\\tau$ 和一个列索引聚类 $\\sigma$ 之间的交互，使得块大小为 $|\\tau| \\times |\\sigma|$。总成本 $C_{\\text{total}}$ 是 $\\mathcal{A}$ 中所有块的成本之和。\n$$ C_{\\text{total}} = \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} \\text{Cost}_{\\text{ACA}}(\\mathbf{B}_{\\tau, \\sigma}) = \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} \\mathcal{O}(r(|\\tau| + |\\sigma|)) $$\n由于 $r$ 是关于求和的常数因子，我们可以写成：\n$$ C_{\\text{total}} = \\mathcal{O}(r) \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} (|\\tau| + |\\sigma|) = \\mathcal{O}(r) \\left( \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} |\\tau| + \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} |\\sigma| \\right) $$\n为了计算这些和，我们使用所提供的关键信息：“每个索引在所有层级上参与 $\\mathcal{O}(\\log N)$ 次可容许交互。” 让我们分析第一个和，$S_{\\text{rows}} = \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} |\\tau|$。我们可以通过先对单个行索引 $p \\in \\{1, \\dots, N\\}$ 求和来重写这个和：\n$$ S_{\\text{rows}} = \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} \\sum_{p \\in \\tau} 1 $$\n通过交换求和顺序，我们得到：\n$$ S_{\\text{rows}} = \\sum_{p=1}^{N} \\sum_{\\substack{(\\tau, \\sigma) \\in \\mathcal{A} \\\\ p \\in \\tau}} 1 $$\n内层和计算了索引 $p$ 作为行聚类 $\\tau$ 成员的可容许块 $(\\tau, \\sigma)$ 的数量。根据问题陈述，对于每个索引 $p$，这个数量是 $\\mathcal{O}(\\log N)$。将此代入 $S_{\\text{rows}}$ 的表达式中：\n$$ S_{\\text{rows}} = \\sum_{p=1}^{N} \\mathcal{O}(\\log N) = N \\cdot \\mathcal{O}(\\log N) = \\mathcal{O}(N \\log N) $$\n基于对称性的相同论证，对列维度的求和 $S_{\\text{cols}} = \\sum_{(\\tau, \\sigma) \\in \\mathcal{A}} |\\sigma|$ 也是 $\\mathcal{O}(N \\log N)$。\n$$ S_{\\text{cols}} = \\sum_{q=1}^{N} \\sum_{\\substack{(\\tau, \\sigma) \\in \\mathcal{A} \\\\ q \\in \\sigma}} 1 = \\sum_{q=1}^{N} \\mathcal{O}(\\log N) = \\mathcal{O}(N \\log N) $$\n最后，我们将这些结果代回到总成本的表达式中：\n$$ C_{\\text{total}} = \\mathcal{O}(r) (S_{\\text{rows}} + S_{\\text{cols}}) = \\mathcal{O}(r) (\\mathcal{O}(N \\log N) + \\mathcal{O}(N \\log N)) $$\n这简化为基于ACA构建所有可容许块的最终渐近总成本。\n$$ C_{\\text{total}} = \\mathcal{O}(r N \\log N) $$\n此复杂度表示构建H-矩阵远场部分的压缩表示所需的算术运算总数。",
            "answer": "$$\n\\boxed{\\mathcal{O}(r N \\log N)}\n$$"
        },
        {
            "introduction": "在理解了ACA的计算效率之后，下一个关键步骤是掌握其正确实现。本练习关注一个在实践中至关重要的问题：在近似过程中保持物理对称性。标准的ACA算法在处理满足互易原理的对称矩阵（例如，伽辽金法下的电场积分方程矩阵）时，可能会破坏其对称性。 这个编码实践将要求您实现一个修正的ACA版本，通过对每一阶的秩-1更新进行对称化处理，来确保最终的近似矩阵能保持原始物理系统所具有的对称性，这是构建稳定且物理解释正确的数值模型的关键一环。",
            "id": "3287916",
            "problem": "您的任务是研究在对复值、不定电场积分方程 (EFIE) 阻抗块应用自适应交叉近似 (ACA) 主元选择时，对称性的保持问题。考虑一个均匀、各向同性、互易的介质，因此通过矩量法 (MoM) 在伽辽金方案下使用相同的测试函数和基函数构建的电场积分方程 (EFIE) 阻抗矩阵 $Z$ 满足互易对称性 $Z = Z^\\top$ (转置，而非共轭转置)。对于半径为 $R$ 的圆形导线上的 $N$ 个配置点集，定义平面圆上的位置 $\\{\\mathbf{r}_i\\}_{i=1}^N$，其中 $\\mathbf{r}_i = \\left(R \\cos\\theta_i, R \\sin\\theta_i, 0\\right)$ 且 $\\theta_i = 2\\pi(i-1)/N$。设波数为 $k$ (单位为弧度/米)，单元尺寸参数为 $a$ (单位为米)。自由空间标量格林函数定义为 $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{e^{\\mathrm{i} k \\|\\mathbf{r} - \\mathbf{r}'\\|}}{\\|\\mathbf{r} - \\mathbf{r}'\\|}$，EFIE 块的元素近似为\n$$\nZ_{ij} = a^2 \\, G\\!\\left(\\mathbf{r}_i,\\mathbf{r}_j\\right) = a^2 \\, \\frac{e^{\\mathrm{i} k d_{ij}}}{d_{ij}},\n$$\n其中 $d_{ij} = \\max\\!\\left(\\|\\mathbf{r}_i - \\mathbf{r}_j\\|, a\\right)$ 通过使用 $d_{ii} = a$ 对对角线进行正则化。距离 $\\|\\cdot\\|$ 和 $a$ 以米为单位，波数 $k$ 以弧度/米为单位。根据互易对称性 $G(\\mathbf{r},\\mathbf{r}') = G(\\mathbf{r}',\\mathbf{r})$，这种构造产生一个满足 $Z = Z^\\top$ 的复值不定矩阵 $Z$。\n\n定义自适应交叉近似 (ACA) 的近似值 $Z_{\\text{ACA}}$ 为 $K$ 个由残差驱动主元选择的秩一更新之和。在从未修正的、从零近似开始的单边 ACA 迭代中，于第 $t$ 次迭代：\n1. 计算残差 $R^{(t)} = Z - Z_{\\text{ACA}}^{(t)}$。\n2. 选择一个主元索引 $(i_t,j_t)$，使得 $\\left|R^{(t)}_{i_t,j_t}\\right|$ 最大化。\n3. 形成列向量 $c_t = R^{(t)}(:,j_t)$、行向量 $r_t = R^{(t)}(i_t,:)$ 和主元 $p_t = R^{(t)}_{i_t,j_t}$。\n4. 更新 $Z_{\\text{ACA}}^{(t+1)} = Z_{\\text{ACA}}^{(t)} + \\frac{1}{p_t} \\, c_t \\, r_t^\\top$。\n\n众所周知，即使 $Z$ 是对称的，未修正的更新也可能破坏互易对称性，因为 $\\frac{1}{p_t} c_t r_t^\\top$ 通常不是对称的。一种恢复互易对称性的简单主元修正是将每个秩一更新对称化为\n$$\n\\Delta Z_t^{\\text{sym}} = \\frac{1}{2}\\left(\\frac{1}{p_t} c_t r_t^\\top + \\left(\\frac{1}{p_t} c_t r_t^\\top\\right)^\\top\\right),\n$$\n这会强制 $\\Delta Z_t^{\\text{sym}} = \\left(\\Delta Z_t^{\\text{sym}}\\right)^\\top$，从而对所有 $t$ 保持 $Z_{\\text{ACA}}^{(t)} = \\left(Z_{\\text{ACA}}^{(t)}\\right)^\\top$。\n\n您的任务是实现未修正和主元修正的 ACA 方案，计算每种近似的对称性缺陷，并验证主元修正方案是否达到规定的容差。使用以下定义：\n- 近似值 $A$ 的相对对称性缺陷为\n$$\n\\delta(A) = \\frac{\\|A - A^\\top\\|_F}{\\|Z\\|_F},\n$$\n其中 $\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。\n- ACA 在迭代次数达到 $K$ 或当前主元量值低于一个小的数值阈值 $\\tau$ 时终止。\n\n为每个测试用例构建 $Z$，使用未修正 ACA 和主元修正 ACA（具有相同的 $(K,\\tau)$）计算 $Z_{\\text{ACA}}$，并报告主元修正的 $Z_{\\text{ACA}}$ 是否满足 $\\delta(Z_{\\text{ACA}}) \\le \\epsilon$（对于给定的容差 $\\epsilon$）。\n\n单位和数值约定：\n- 距离 $\\|\\mathbf{r}_i - \\mathbf{r}_j\\|$ 和单元尺寸 $a$ 必须以米为单位。\n- 波数 $k$ 必须以弧度/米为单位。\n- 用于在圆上放置点的角度以弧度为单位。\n- 容差 $\\epsilon$ 是无量纲的，必须作为十进制值处理。\n\n测试套件：\n- 案例 1：$N=32$，$R=0.5$ 米，$a=0.02$ 米，$k=10.0$ 弧度/米，$K=8$，$\\tau=10^{-14}$，$\\epsilon=10^{-10}$。\n- 案例 2：$N=48$，$R=0.5$ 米，$a=0.015$ 米，$k=20.0$ 弧度/米，$K=10$，$\\tau=10^{-14}$，$\\epsilon=10^{-12}$。\n- 案例 3：$N=24$，$R=0.5$ 米，$a=0.05$ 米，$k=3.0$ 弧度/米，$K=6$，$\\tau=10^{-14}$，$\\epsilon=10^{-9}$。\n- 案例 4：$N=12$，$R=0.5$ 米，$a=0.10$ 米，$k=1.0$ 弧度/米，$K=5$，$\\tau=10^{-14}$，$\\epsilon=10^{-12}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3]”）。对于每个测试用例，如果主元修正的 $Z_{\\text{ACA}}$ 满足 $\\delta(Z_{\\text{ACA}}) \\le \\epsilon$，则输出布尔值 true，否则输出 false。最终输出必须采用以下形式\n$$\n[\\text{bool}_1,\\text{bool}_2,\\text{bool}_3,\\text{bool}_4]。\n$$",
            "solution": "该问题要求分析自适应交叉近似 (ACA) 算法在应用于由电场积分方程 (EFIE) 的矩量法 (MoM) 离散化产生的复对称矩阵时的对称性保持情况。我们必须实现标准的、未修正的 ACA 和经过主元修正的、对称化的版本，然后验证后者在一组给定的测试用例中是否能在指定容差内保持对称性。\n\n首先，我们为阻抗矩阵 $Z$ 建立数学基础。该问题设置在均匀、各向同性且互易的介质中。当使用伽辽金方案对 EFIE 进行离散化时，其中测试函数与基函数相同，所得到的阻抗矩阵 $Z$ 继承了底层物理学的互易性。这表现为矩阵是对称的，$Z = Z^\\top$，而不是厄米特矩阵。矩阵元素 $Z_{ij}$ 由使用点源标量格林函数的简化模型给出：\n$$\nZ_{ij} = a^2 \\, G\\!\\left(\\mathbf{r}_i,\\mathbf{r}_j\\right) = a^2 \\, \\frac{e^{\\mathrm{i} k d_{ij}}}{d_{ij}}\n$$\n其中 $k$ 是波数，$a$ 是单元尺寸参数，$\\mathbf{r}_i, \\mathbf{r}_j$ 是配置点。距离 $d_{ij}$ 被正则化以处理对角线元素 ($i=j$)，其中物理距离 $\\|\\mathbf{r}_i - \\mathbf{r}_i\\|$ 为 $0$。正则化定义为 $d_{ij} = \\max\\!\\left(\\|\\mathbf{r}_i - \\mathbf{r}_j\\|, a\\right)$，这确保了 $d_{ii}=a$，从而防止了除零奇异性。由于欧几里得距离是对称的，$\\|\\mathbf{r}_i - \\mathbf{r}_j\\| = \\|\\mathbf{r}_j - \\mathbf{r}_i\\|$，因此可得 $d_{ij} = d_{ji}$，从而 $Z_{ij} = Z_{ji}$，这证实了所构造的矩阵 $Z$ 确实是对称的。\n\n问题的核心在于 ACA 算法，这是一种用于生成矩阵低秩近似的快速方法。近似值 $Z_{\\text{ACA}}$ 是通过迭代构建的，作为秩-1 矩阵的和：$Z_{\\text{ACA}} = \\sum_{t=1}^K \\Delta Z_t$。在标准的、未修正的 ACA 方案中，第 $t$ 次迭代的过程如下：\n$1$. 残差矩阵为 $R^{(t)} = Z - Z_{\\text{ACA}}^{(t)}$，其中 $Z_{\\text{ACA}}^{(t)}$ 是经过 $t-1$ 步后的近似值。初始时，$Z_{\\text{ACA}}^{(1)}$ 是一个零矩阵。\n$2$. 通过在当前残差中找到具有最大幅值的元素来选择主元 $(i_t, j_t)$：$(i_t, j_t) = \\operatorname{argmax}_{(i,j)} |R^{(t)}_{i,j}|$。\n$3$. 从残差中提取相应的行 $r_t = R^{(t)}(i_t, :)$、列 $c_t = R^{(t)}(:, j_t)$ 和主元值 $p_t = R^{(t)}_{i_t, j_t}$。\n$4$. 形成一个秩-1 更新并将其加到近似值上：$\\Delta Z_t = \\frac{1}{p_t} c_t r_t^\\top$。\n\n问题出现在第 4 步。即使原始矩阵 $Z$ 是对称的，秩-1 更新 $\\Delta Z_t = \\frac{1}{p_t} c_t r_t^\\top$ 通常也不是对称的。这是因为主元选择不保证 $i_t=j_t$，即使保证了，列 $c_t$ 和行 $r_t$ 也是从一个可能在先前步骤中已经失去对称性的残差矩阵中提取的。因此，最终的近似值 $Z_{\\text{ACA}}$ 将不是对称的。\n\n为了解决这个问题，提出了一种主元修正方案。主元选择过程（步骤 1-3）保持不变，确保了相同的残差驱动自适应性。但是，更新步骤被修改以显式地强制对称性。新的秩-1 更新 $\\Delta Z_t^{\\text{sym}}$ 是原始版本的对称化形式：\n$$\n\\Delta Z_t^{\\text{sym}} = \\frac{1}{2}\\left(\\frac{1}{p_t} c_t r_t^\\top + \\left(\\frac{1}{p_t} c_t r_t^\\top\\right)^\\top\\right) = \\frac{1}{2p_t}\\left(c_t r_t^\\top + (r_t^\\top)^\\top c_t^\\top\\right)\n$$\n由于根据构造 $(\\Delta Z_t^{\\text{sym}})^\\top = \\Delta Z_t^{\\text{sym}}$，在每一步加上这个更新可以保证，如果近似值 $Z_{\\text{ACA}}^{(t)}$ 是对称的，那么 $Z_{\\text{ACA}}^{(t+1)} = Z_{\\text{ACA}}^{(t)} + \\Delta Z_t^{\\text{sym}}$ 也将是对称的。从一个对称的零矩阵开始，最终的近似值 $Z_{\\text{ACA}}$ 保证是对称的。\n\n任务是实现这个修正方案并量化其成功程度。成功的度量标准是相对对称性缺陷，定义为：\n$$\n\\delta(A) = \\frac{\\|A - A^\\top\\|_F}{\\|Z\\|_F}\n$$\n其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。对于主元修正方案，我们预计这个缺陷会非常接近机器精度，因为不对称性的主要来源将是浮点舍入误差。算法在 $K$ 次迭代后终止，或者如果主元幅值 $|p_t|$ 低于数值阈值 $\\tau$。\n\n解决方案按以下步骤进行：\n$1$. 对每个测试用例，我们首先在半径为 $R$ 的圆上生成 $N$ 个配置点 $\\mathbf{r}_i$。\n$2$. 然后，我们根据给定的公式构造完整的 $N \\times N$ 复对称矩阵 $Z$，计算正则化距离 $d_{ij}$，然后计算矩阵元素 $Z_{ij}$。\n$3$. 我们使用对称化更新规则实现 ACA 算法。该算法从残差中迭代确定主元，构造对称化的秩-1 更新，将其添加到近似值中，并从残差中减去它。这个过程一直持续到完成 $K$ 次迭代或主元幅值低于 $\\tau$。\n$4$. ACA 过程终止后，我们计算所得近似值的相对对称性缺陷 $\\delta(Z_{\\text{ACA}})$。\n$5$. 最后，我们检查是否 $\\delta(Z_{\\text{ACA}}) \\le \\epsilon$（对于给定的容差 $\\epsilon$）。每个测试用例的此检查的布尔结果被记录下来。\n这些布尔结果的集合构成了最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of verifying symmetry preservation in pivot-corrected ACA.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Format: (N, R, a, k, K, tau, epsilon)\n    test_cases = [\n        (32, 0.5, 0.02, 10.0, 8, 1e-14, 1e-10),\n        (48, 0.5, 0.015, 20.0, 10, 1e-14, 1e-12),\n        (24, 0.5, 0.05, 3.0, 6, 1e-14, 1e-9),\n        (12, 0.5, 0.10, 1.0, 5, 1e-14, 1e-12),\n    ]\n\n    def run_aca_case(N, R, a, k, K, tau, epsilon):\n        \"\"\"\n        Runs a single test case for the ACA symmetry check.\n        \n        Args:\n            N (int): Number of collocation points.\n            R (float): Radius of the circular wire in meters.\n            a (float): Patch size parameter for regularization in meters.\n            k (float): Wavenumber in radians per meter.\n            K (int): Maximum number of ACA iterations.\n            tau (float): Pivot magnitude termination threshold.\n            epsilon (float): Tolerance for the relative symmetry defect.\n\n        Returns:\n            bool: True if the symmetry defect condition is met, False otherwise.\n        \"\"\"\n        # Step 1: Generate collocation points on a circle in the x-y plane.\n        thetas = 2 * np.pi * np.arange(N) / N\n        points = np.zeros((N, 3))\n        points[:, 0] = R * np.cos(thetas)\n        points[:, 1] = R * np.sin(thetas)\n\n        # Step 2: Construct the full impedance matrix Z.\n        # Vectorized computation of pairwise Euclidean distances.\n        diffs = points[:, np.newaxis, :] - points[np.newaxis, :, :]\n        dist_euc = np.linalg.norm(diffs, axis=2)\n        \n        # Apply regularization: d_ij = max(||r_i - r_j||, a)\n        dist_reg = np.maximum(dist_euc, a)\n        \n        # Calculate the matrix Z. Use np.complex128 for precision.\n        # To avoid division by zero if a=0 (not in tests, but good practice),\n        # handle the diagonal separately. However, dist_reg is never zero here.\n        Z = (a**2) * np.exp(1j * k * dist_reg) / dist_reg\n        Z = Z.astype(np.complex128)\n\n        # Step 3: Run the pivot-corrected ACA algorithm.\n        Z_aca = np.zeros_like(Z, dtype=np.complex128)\n        residual = Z.copy()\n        \n        for _ in range(K):\n            # Find the pivot (i_t, j_t) by maximizing |R_ij|.\n            flat_idx = np.argmax(np.abs(residual))\n            i_t, j_t = np.unravel_index(flat_idx, residual.shape)\n            \n            # Get the pivot value.\n            p_t = residual[i_t, j_t]\n            \n            # Check for termination condition based on pivot magnitude.\n            if np.abs(p_t)  tau:\n                break\n            \n            # Extract the pivot row and column from the residual.\n            c_t = residual[:, j_t]\n            r_t = residual[i_t, :]\n            \n            # Form the rank-1 update.\n            update_term = np.outer(c_t, r_t) / p_t\n            \n            # Symmetrize the update to enforce reciprocity.\n            sym_update = 0.5 * (update_term + update_term.T)\n            \n            # Update the ACA approximation and the residual.\n            Z_aca += sym_update\n            residual -= sym_update\n            \n        # Step 4: Calculate the relative symmetry defect.\n        norm_Z_F = np.linalg.norm(Z, 'fro')\n        \n        # Guard against norm_Z_F being zero for an all-zero matrix.\n        if norm_Z_F == 0:\n            # If Z is zero, the only valid approximation is also zero.\n            # a non-zero approximation would have infinite relative defect.\n            return np.linalg.norm(Z_aca - Z_aca.T, 'fro') == 0\n\n        sym_error_norm_F = np.linalg.norm(Z_aca - Z_aca.T, 'fro')\n        defect = sym_error_norm_F / norm_Z_F\n        \n        # Step 5: Verify if the defect is within the prescribed tolerance.\n        return defect = epsilon\n\n    results = []\n    for case in test_cases:\n        result = run_aca_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format \"[bool_1,bool_2,bool_3,bool_4]\".\n    # Python's str(True) is 'True'; convert to lowercase 'true'.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "自适应交叉近似不仅是一种高效的矩阵压缩工具，其计算过程中产生的数值秩更是一个强大的诊断指标。本练习展示了ACA的一个高级应用：利用ACA秩作为后验误差指示器来驱动自适应网格加密。 您将通过一个编码任务来验证一个核心思想：在物理场行为复杂的区域（例如近谐振腔体），其对应的边界元交互矩阵块的数值秩会显著增高。通过将高数值秩与待解析的复杂物理现象关联起来，本练习揭示了如何利用ACA使仿真不仅更快，而且更“智能”，能够自动识别并加密需要更高分辨率的区域。",
            "id": "3287860",
            "problem": "你需要实现一个完整的、可运行的程序，该程序为由自适应交叉近似 (ACA) 秩驱动的边界元相互作用构建一个后验自适应网格剖分指示器，并用它来决定哪些边界面元片区需要加密。其物理背景是一个二维理想电导方腔，通过标量亥姆霍兹方程的边界积分公式进行建模，其数值核函数是二维自由空间格林函数。目标是使用一个简单且通用的计算代理来展示，近共振波数如何在非对角相互作用块中引出更高的数值秩，从而根据一个基于秩的指示器触发更多的网格加密。\n\n请从以下基础开始：\n- 二维时谐标量亥姆霍兹方程为 $\\nabla^2 u + k^2 u = 0$，其中 $u$ 是场，$k$ 是波数。\n- 亥姆霍兹算子的二维自由空间格林函数为 $G_k(\\mathbf{r}, \\mathbf{r}') = \\dfrac{i}{4} H_0^{(1)}(k \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert)$，其中 $H_0^{(1)}$ 是第一类零阶汉克尔函数，$\\lVert \\cdot \\rVert$ 表示欧几里得范数。\n- 对于均匀的边界离散化，一个配置边界元矩阵使用的元素为 $G_{ij} = G_k(\\mathbf{r}_i, \\mathbf{r}_j) w_j$（当 $i \\neq j$ 时），其中 $\\mathbf{r}_j$ 是面元中点，$w_j$ 是面元长度。自作用项 $i = j$ 对应一个弱奇异性，在本问题中仅考虑非对角片区间的相互作用时不需要它。\n- 自适应交叉近似 (ACA) 通过自适应地选择枢轴行和列来形成秩-$r$更新，从而构建矩阵块的低秩近似，直到相对残差范数的容差被满足，由此提供一个数据驱动的估计量，用于估计在给定精度下近似一个块所需的数值秩。\n\n你必须实现以下步骤：\n1. 几何与离散化。考虑一个边长为 $a = 1$ 的方腔，其边界被均匀离散为 $M = 160$ 个直面元。使用 $M = 160$ 个面元。记面元长度为 $h = \\frac{4}{M}$，面元中点为 $\\{\\mathbf{r}_j\\}_{j=1}^M$，从底边中点开始按逆时针顺序排列。构建稠密复值矩阵 $G \\in \\mathbb{C}^{M \\times M}$，其元素为\n   - $G_{ij} = \\dfrac{i}{4} H_0^{(1)}\\!\\left(k \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert\\right) h$，当 $i \\neq j$ 时，\n   - $G_{ii} = 0$（在此任务中对角线元素未使用）。\n2. 片区划分。将索引集 $\\{1,2,\\dots,M\\}$ 划分为 $P = 8$ 个大小相等的连续片区，每个片区包含 $M/P = 20$ 个连续索引，并保持边界顺序。\n3. 基于 ACA 的秩指示器。对于给定的波数 $k$，对每个片区 $p \\in \\{0,1,\\dots,P-1\\}$：\n   - 定义相邻集 $\\mathcal{N}(p) = \\{(p-1) \\bmod P, (p+1) \\bmod P\\}$。\n   - 对于每个相邻片区 $q \\in \\mathcal{N}(p)$，形成非对角相互作用块 $B_{pq} = G[I_p, I_q]$，其中 $I_p$ 和 $I_q$ 是片区 $p$ 和 $q$ 的索引集。\n   - 估计 $B_{pq}$ 的 ACA 数值秩 $r_{pq}$，该秩是使 ACA 近似的弗罗贝尼乌斯范数相对残差小于容差 $\\varepsilon = 10^{-3}$ 的最小整数 $r$，并设有硬性上限 $r \\le \\min(|I_p|, |I_q|)$。\n   - 将片区指示器定义为 $I_p = \\max_{q \\in \\mathcal{N}(p)} r_{pq}$。\n4. 加密决策规则。给定秩阈值 $R_{\\mathrm{thr}} = 6$，当且仅当 $I_p > R_{\\mathrm{thr}}$ 时，标记片区 $p$ 进行加密。一个加密步骤会将每个被标记片区的面元一分为二，但对于本任务，你只需要报告在第一次迭代中，每个测试用例将要加密的片区数量。\n5. 通过近共振行为进行验证。考虑一个具有狄利克雷边界条件的二维矩形腔，其特征波数约为 $k_{mn} \\approx \\pi \\sqrt{m^2 + n^2}/a$，其中 $m, n$ 为正整数。使用 $a=1$ 并以近共振情况 $k \\approx \\pi \\sqrt{2}$ 为目标，这是方腔的 $(m,n)=(1,1)$ 模态。尽管使用自由空间核的边界积分是一种简化，但为解析振荡相互作用所需的块秩通常随 $k$ 的增加而增加，这使得基于秩的自适应加密指示器成为可能。\n\n您必须实现完整的程序，包括 ACA 例程，并对以下波数测试集评估加密计数：\n- 测试用例 1（低频基线）：$k = 0.2$。\n- 测试用例 2（离共振中等频率）：$k = 1.0$。\n- 测试用例 3（近共振）：$k = \\pi \\sqrt{2}$。\n\n对于每个测试用例，运行上述步骤并计算满足 $I_p > R_{\\mathrm{thr}}$ 的片区整数数量。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例的顺序排列结果，例如 `[n_1,n_2,n_3]`，其中每个 $n_j$ 是测试用例 $j$ 中标记为需要加密的片区计数。输出中不需要角度或有量纲的物理单位，因为结果是无量纲的整数。确保本问题中出现的所有数值常数和参数，包括 $M = 160$、$P = 8$、$\\varepsilon = 10^{-3}$ 和 $R_{\\mathrm{thr}} = 6$，都严格按照规定使用。",
            "solution": "该问题要求实现一个计算例程，以识别离散化边界上需要进行网格加密的区域。其背景是使用边界元法 (BEM) 数值求解二维标量亥姆霍兹方程 $\\nabla^2 u + k^2 u = 0$，在一个方腔内。加密决策基于一个后验误差指示器，该指示器源自边界片区之间相互作用矩阵的数值秩，而这些数值秩通过自适应交叉近似 (ACA) 算法估算。需要验证的核心假设是，近共振波数会导致更高的数值秩，从而触发更多的加密。\n\n该解决方案通过以下逻辑步骤构建：\n\n1.  **边界离散化与矩阵构建**：\n    边长为 $a=1$ 的方腔边界被离散为 $M=160$ 个均匀的直线段，或称面元。总周长为 $4a=4$，因此每个面元的长度为 $h = 4/M = 0.025$。几何形状由一组面元中点 $\\{\\mathbf{r}_j\\}_{j=1}^M$ 定义。按照规定，排序始于底边中点 $(0.5, 0)$ 处最后一个面元与第一个面元之间的边界，并按逆时针方向进行。\n\n    亥姆霍兹方程的边界元法公式通过一个涉及自由空间格林函数的积分方程来关联边界值。对于配置格式，这会产生一个稠密线性系统 $G \\mathbf{x} = \\mathbf{y}$。矩阵 $G \\in \\mathbb{C}^{M \\times M}$ 表示所有面元对之间的相互作用。其元素由下式给出：\n    $$ G_{ij} = G_k(\\mathbf{r}_i, \\mathbf{r}_j) w_j = \\frac{i}{4} H_0^{(1)}(k \\|\\mathbf{r}_i - \\mathbf{r}_j\\|) h $$\n    当 $i \\neq j$ 时。这里，$k$ 是波数，$H_0^{(1)}$ 是第一类零阶汉克尔函数，表示出射柱面波，$w_j = h$ 是积分权重，取为面元长度。对角线元素 $G_{ii}$ 涉及一个奇异核，本问题中不需要，因此我们将其设置为 $G_{ii}=0$。\n\n2.  **基于片区的划分**：\n    为了局部地分析相互作用，所有面元索引的集合 $\\{0, 1, \\dots, M-1\\}$ 被划分为 $P=8$ 个连续且不重叠的片区。每个片区 $p \\in \\{0, \\dots, P-1\\}$ 包含 $M/P = 20$ 个连续的面元索引。这种划分将稠密矩阵 $G$ 分割成一个 $P \\times P$ 的块矩阵，其中每个块 $B_{pq} = G[I_p, I_q]$ 包含片区 $p$ 中的面元与片区 $q$ 中的面元之间的相互作用。\n\n3.  **用于秩估计的自适应交叉近似 (ACA)**：\n    相互作用块 $B_{pq}$ 的数值秩为其复杂性提供了一个定量度量。平滑、缓慢变化的相互作用可以通过低秩近似精确表示，而高度振荡的相互作用则需要更高的秩。ACA 是一种代数的、仅依赖矩阵的算法，用于构建这样的低秩近似 $B_{pq} \\approx U V^H$，其中 $U$ 和 $V$ 是列数很少（为 $r$）的矩阵。\n\n    该算法迭代进行。从残差矩阵 $R_0 = B_{pq}$ 开始，在每一步 $k$，它在当前残差 $R_k$ 中识别出量级最大的元素（枢轴）。利用 $R_k$ 相应行和列构成的秩-1矩阵来更新近似，并相应地更新残差：$R_{k+1} = R_k - \\mathbf{u}_k \\mathbf{v}_k^H$。该过程持续进行，直到残差的弗罗贝尼乌斯范数 $\\|R_r\\|_F$ 相对于原始块的范数降至指定容差以下，即 $\\|B_{pq} - U_r V_r^H\\|_F \\leq \\varepsilon \\|B_{pq}\\|_F$。达到此标准所需的步数 $r$ 即为在容差 $\\varepsilon=10^{-3}$ 下该块的估计数值秩。\n\n4.  **基于秩的加密指示器**：\n    该指示器背后的物理原理是，近共振腔体内部的场是高度复杂和振荡的。这种复杂性反映在边界元法矩阵中，其中与这些复杂场对应的相互作用块表现出高数值秩。因此，秩可以作为局部解误差的有效代理。\n\n    对于每个片区 $p$，我们考虑它与沿边界的直接相邻片区之间的相互作用，这些相邻片区由集合 $\\mathcal{N}(p) = \\{(p-1) \\bmod P, (p+1) \\bmod P\\}$ 定义。相应相互作用块的 ACA 估计秩 $r_{pq}$（对于 $q \\in \\mathcal{N}(p)$）量化了这些相互作用的复杂性。高秩表明当前网格难以解析这些片区之间的底层场行为。为保守起见，片区 $p$ 的加密指示器定义为这些秩的最大值：\n    $$ I_p = \\max_{q \\in \\mathcal{N}(p)} r_{pq} $$\n\n5.  **加密决策与验证**：\n    应用一个简单的决策规则：如果一个片区 $p$ 的指示器 $I_p$ 超过预定阈值 $R_{\\mathrm{thr}}=6$，则将其标记为需要加密。这意味着，如果与任一相邻片区的相互作用足够复杂，则该片区的离散化被认为是不充分的。\n\n    验证通过测试三个波数来进行：\n    -   $k = 0.2$：一个低频，远离任何共振。预期相互作用是平滑的，导致低秩且无需加密。\n    -   $k = 1.0$：一个中等、离共振的频率。秩可能会略有增加，但预期会保持在阈值以下。\n    -   $k = \\pi\\sqrt{2} \\approx 4.44$：选择此值是为了接近方形狄利克雷腔的基本 $(1,1)$ 共振模态 ($k_{11} = \\pi \\sqrt{1^2+1^2}/a$)。在共振附近，场变得高度振荡，我们预期数值秩会显著增加，导致指示器 $I_p$ 超过阈值 $R_{\\mathrm{thr}}$ 并触发多个片区的加密。\n\n实现过程将构建几何结构和边界元法矩阵，然后对于每个测试用例的波数，它将遍历所有片区，计算相邻相互作用的 ACA 秩，评估指示器，并统计满足加密标准的片区数量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import hankel1\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Problem constants\n    a = 1.0  # Side length of the square cavity\n    M = 160  # Total number of panels\n    P = 8    # Number of patches\n    epsilon = 1e-3  # ACA relative tolerance\n    R_thr = 6      # Rank threshold for refinement\n\n    # Test cases\n    test_cases_k = [\n        0.2,                   # Low-frequency baseline\n        1.0,                   # Off-resonant moderate\n        np.pi * np.sqrt(2.0),  # Near-resonant\n    ]\n\n    # Generate geometry once, as it's independent of k\n    panel_midpoints, panel_length = generate_geometry(M, a)\n\n    results = []\n    for k in test_cases_k:\n        # 1. Construct the BEM matrix for the given wavenumber k\n        G = build_bem_matrix(k, panel_midpoints, panel_length)\n        \n        # 2. Calculate the number of patches to refine\n        refinement_count = calculate_refinement_count(G, M, P, epsilon, R_thr)\n        results.append(refinement_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef generate_geometry(M, a):\n    \"\"\"\n    Generates the panel midpoints for a square cavity.\n    The ordering starts from the middle of the bottom edge and proceeds counter-clockwise.\n    \"\"\"\n    if M % 4 != 0:\n        raise ValueError(\"M must be a multiple of 4.\")\n    \n    M_side = M // 4\n    h = a / M_side\n    \n    points = np.zeros((M, 2))\n    \n    # The split point is at (0.5*a, 0).\n    # Panels are ordered starting from the right of this split point.\n    \n    # Indices 0 to M_side/2 - 1: Bottom-right edge\n    n_br = M_side // 2\n    for j in range(n_br):\n        points[j, 0] = a * 0.5 + (j + 0.5) * h\n        points[j, 1] = 0.0\n\n    # Indices n_br to n_br + M_side - 1: Right edge\n    for j in range(M_side):\n        idx = j + n_br\n        points[idx, 0] = a\n        points[idx, 1] = (j + 0.5) * h\n\n    # Indices n_br + M_side to n_br + 2*M_side - 1: Top edge\n    for j in range(M_side):\n        idx = j + n_br + M_side\n        points[idx, 0] = a - (j + 0.5) * h\n        points[idx, 1] = a\n\n    # Indices n_br + 2*M_side to n_br + 3*M_side - 1: Left edge\n    for j in range(M_side):\n        idx = j + n_br + 2 * M_side\n        points[idx, 0] = 0.0\n        points[idx, 1] = a - (j + 0.5) * h\n\n    # Indices n_br + 3*M_side to M-1: Bottom-left edge\n    for j in range(n_br):\n        idx = j + n_br + 3 * M_side\n        points[idx, 0] = (j + 0.5) * h\n        points[idx, 1] = 0.0\n        \n    return points, 4.0 * a / M\n\n\ndef build_bem_matrix(k, panel_midpoints, h):\n    \"\"\"\n    Constructs the dense BEM matrix G.\n    \"\"\"\n    M = panel_midpoints.shape[0]\n    \n    # Use broadcasting for efficient distance calculation\n    # diffs.shape = (M, M, 2)\n    diffs = panel_midpoints[:, np.newaxis, :] - panel_midpoints[np.newaxis, :, :]\n    # distances.shape = (M, M)\n    distances = np.linalg.norm(diffs, axis=2)\n    \n    # Avoid division by zero for diagonal elements, though they will be overwritten\n    np.fill_diagonal(distances, 1.0)\n    \n    # Calculate Green's function values\n    G = (1j / 4.0) * hankel1(0, k * distances) * h\n    \n    # Set diagonal elements to 0 as specified\n    np.fill_diagonal(G, 0)\n    \n    return G\n\n\ndef aca(matrix_block, tol):\n    \"\"\"\n    Estimates the numerical rank of a matrix block using Adaptive Cross Approximation.\n    \"\"\"\n    m, n = matrix_block.shape\n    max_rank = min(m, n)\n    \n    residual = matrix_block.copy()\n    norm_fro_orig_sq = np.sum(np.abs(matrix_block)**2)\n\n    if norm_fro_orig_sq == 0:\n        return 0\n    \n    rank = 0\n    for r in range(max_rank):\n        # Find the pivot element in the current residual matrix\n        flat_idx = np.argmax(np.abs(residual))\n        i_piv, j_piv = np.unravel_index(flat_idx, residual.shape)\n        \n        pivot_val = residual[i_piv, j_piv]\n        \n        # If residual matrix is numerically zero, stop\n        if np.abs(pivot_val)**2  1e-30 * norm_fro_orig_sq:\n            break\n            \n        u_vec = residual[:, j_piv]\n        v_vec_T = residual[i_piv, :] / pivot_val\n        \n        # Update the residual with a rank-1 matrix\n        residual -= np.outer(u_vec, v_vec_T)\n        \n        rank += 1\n        \n        # Check stopping criterion based on Frobenius norm of the residual\n        norm_fro_res_sq = np.sum(np.abs(residual)**2)\n        if norm_fro_res_sq  tol**2 * norm_fro_orig_sq:\n            return rank\n            \n    return rank\n\n\ndef calculate_refinement_count(G, M, P, epsilon, R_thr):\n    \"\"\"\n    Calculates the number of patches to be refined based on ACA ranks.\n    \"\"\"\n    panels_per_patch = M // P\n    refinement_count = 0\n    \n    for p in range(P):\n        # Define neighbor patches\n        q_prev = (p - 1 + P) % P\n        q_next = (p + 1) % P\n        \n        # Get index sets for the current patch and its neighbors\n        I_p_slice = slice(p * panels_per_patch, (p + 1) * panels_per_patch)\n        I_q_prev_slice = slice(q_prev * panels_per_patch, (q_prev + 1) * panels_per_patch)\n        I_q_next_slice = slice(q_next * panels_per_patch, (q_next + 1) * panels_per_patch)\n        \n        # Extract interaction blocks\n        B_pq_prev = G[I_p_slice, I_q_prev_slice]\n        B_pq_next = G[I_p_slice, I_q_next_slice]\n        \n        # Estimate numerical ranks using ACA\n        r_pq_prev = aca(B_pq_prev, epsilon)\n        r_pq_next = aca(B_pq_next, epsilon)\n        \n        # Define patch indicator\n        Indicator_p = max(r_pq_prev, r_pq_next)\n        \n        # Apply refinement rule\n        if Indicator_p > R_thr:\n            refinement_count += 1\n            \n    return refinement_count\n\n# Entry point of the script\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}