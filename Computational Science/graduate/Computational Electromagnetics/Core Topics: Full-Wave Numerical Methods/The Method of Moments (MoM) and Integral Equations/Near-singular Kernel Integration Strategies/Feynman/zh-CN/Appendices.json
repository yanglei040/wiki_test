{
    "hands_on_practices": [
        {
            "introduction": "精确处理近奇异核积分是边界元方法等计算技术中的核心挑战。幸运的是，对于一些标准几何构型，例如带恒定电荷密度的矩形板，其产生的势可以被解析地推导出来。这个练习  将引导您推导这样一个闭式解，它将作为评估和比较不同近奇异积分方案准确性的黄金标准基准。",
            "id": "3333343",
            "problem": "考虑三维自由空间中拉普拉斯方程的标量静电单层势，其自由空间格林函数为 $G(\\mathbf{r},\\mathbf{r}') = \\frac{1}{4 \\pi |\\mathbf{r}-\\mathbf{r}'|}$。设 $\\Gamma$ 是一个位于 $z=0$ 平面内的平面矩形板，其角点 $(x,y) \\in [a_{1},a_{2}] \\times [b_{1},b_{2}]$，并设面源密度为常数 $\\sigma(\\mathbf{r}') \\equiv \\sigma_{0}$。对于一个板外目标点 $\\mathbf{r}_{0} = (x_{0},y_{0},z_{0})$（其中 $z_{0} \\neq 0$），单层势为\n$$\nu(\\mathbf{r}_{0}) \\;=\\; \\int_{\\Gamma} G(\\mathbf{r},\\mathbf{r}_{0}) \\, \\sigma(\\mathbf{r}) \\, \\mathrm{d}S(\\mathbf{r}).\n$$\n仅从此定义和 $G$ 的形式出发，且不引用任何预先制表的闭式公式，推导出一个用 $a_{1},a_{2},b_{1},b_{2},x_{0},y_{0},z_{0}$ 和 $\\sigma_{0}$ 表示的 $u(\\mathbf{r}_{0})$ 的解析表达式。你的推导应通过系统的积分和有效的代数变换进行，使用单层算子和格林函数的基本定义。仔细说明所做的任何变量替换，并为你使用的任何反三角函数或对数函数的分支提供理据。假设 $\\ln(\\cdot)$ 和 $\\arctan(\\cdot)$ 使用主分支，并指明角度以弧度为单位。\n\n然后，解释当 $|z_{0}|$ 相对于板的尺寸很小（这在边界元法（BEM）中很常见）时，这个解析结果如何能被用作一个基准，来评估和比较逼近同一积分的不同近奇异积分格式的准确性。在你的解释中，定义一个无量纲的到板距离参数和一个具体的误差度量，该度量适用于在目标点接近板时比较不同方法。\n\n答案要求：\n- 作为一个最终答案，提供一个只依赖于 $a_{1},a_{2},b_{1},b_{2},x_{0},y_{0},z_{0}$ 和 $\\sigma_{0}$ 的 $u(\\mathbf{r}_{0})$ 的单一闭式解析表达式，使用初等函数表示。\n- 不要近似或四舍五入；不需要进行数值计算。\n- 所有反三角函数的值都使用弧度。",
            "solution": "该问题陈述是势论中的一个适定且有科学依据的问题，势论是静电学和计算方法中的一个基础课题。所有参数都定义清晰，条件自洽。该问题是有效的。我们开始推导。\n\n由于一个位于矩形板 $\\Gamma$ 上的常数面电荷密度 $\\sigma_{0}$，在目标点 $\\mathbf{r}_{0} = (x_{0}, y_{0}, z_{0})$ 处的单层势 $u(\\mathbf{r}_{0})$ 由以下积分给出：\n$$ u(\\mathbf{r}_{0}) = \\int_{\\Gamma} \\frac{\\sigma_{0}}{4 \\pi |\\mathbf{r}-\\mathbf{r}_{0}|} \\, \\mathrm{d}S(\\mathbf{r}) $$\n板 $\\Gamma$ 由 $z=0$ 平面中的区域 $[a_{1}, a_{2}] \\times [b_{1}, b_{2}]$ 定义。积分点为 $\\mathbf{r} = (x, y, 0)$。面元为 $\\mathrm{d}S(\\mathbf{r}) = \\mathrm{d}x \\, \\mathrm{d}y$。距离项为 $|\\mathbf{r}-\\mathbf{r}_{0}| = \\sqrt{(x-x_{0})^2 + (y-y_{0})^2 + z_{0}^2}$。积分变为：\n$$ u(\\mathbf{r}_{0}) = \\frac{\\sigma_{0}}{4 \\pi} \\int_{b_{1}}^{b_{2}} \\int_{a_{1}}^{a_{2}} \\frac{1}{\\sqrt{(x-x_{0})^2 + (y-y_{0})^2 + z_{0}^2}} \\, \\mathrm{d}x \\, \\mathrm{d}y $$\n为了简化表达式，我们进行变量替换，使原点位于投影目标点 $(x_0, y_0, 0)$。令 $\\xi = x - x_{0}$ 和 $\\eta = y - y_{0}$。积分限变为 $\\xi \\in [a_{1}-x_{0}, a_{2}-x_{0}]$ 和 $\\eta \\in [b_{1}-y_{0}, b_{2}-y_{0}]$。我们定义 $\\xi_{1}=a_{1}-x_{0}$，$\\xi_{2}=a_{2}-x_{0}$，$\\eta_{1}=b_{1}-y_{0}$，和 $\\eta_{2}=b_{2}-y_{0}$。现在积分为：\n$$ u(\\mathbf{r}_{0}) = \\frac{\\sigma_{0}}{4 \\pi} \\int_{\\eta_{1}}^{\\eta_{2}} \\int_{\\xi_{1}}^{\\xi_{2}} \\frac{1}{\\sqrt{\\xi^2 + \\eta^2 + z_{0}^2}} \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta $$\n这个定积分的值可以通过定义一个不定积分函数 $\\Phi(\\xi, \\eta, z_0)$ 并在变换后区域的四个角点上求值来表示：\n$$ \\Phi(\\xi, \\eta, z_0) = \\iint \\frac{1}{\\sqrt{\\xi^2 + \\eta^2 + z_0^2}} \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta $$\n势则由以下叠加给出：\n$$ u(\\mathbf{r}_{0}) = \\frac{\\sigma_{0}}{4 \\pi} \\left[ \\Phi(\\xi_{2}, \\eta_{2}, z_0) - \\Phi(\\xi_{1}, \\eta_{2}, z_0) - \\Phi(\\xi_{2}, \\eta_{1}, z_0) + \\Phi(\\xi_{1}, \\eta_{1}, z_0) \\right] $$\n我们的任务简化为推导函数 $\\Phi(\\xi, \\eta, z_0)$。我们可以通过系统积分来进行。首先，我们对 $\\xi$ 进行积分：\n$$ I_{\\xi}(\\eta) = \\int \\frac{\\mathrm{d}\\xi}{\\sqrt{\\xi^2 + (\\eta^2 + z_0^2)}} $$\n这是一个标准的积分形式。其解为：\n$$ \\int \\frac{\\mathrm{d}u}{\\sqrt{u^2 + A^2}} = \\ln\\left(u + \\sqrt{u^2 + A^2}\\right) $$\n其中，恒等式 $\\operatorname{arcsinh}(u/A) = \\ln(u/A + \\sqrt{(u/A)^2+1}) = \\ln(u+\\sqrt{u^2+A^2}) - \\ln(A)$ 表明结果是一个对数。因此，\n$$ I_{\\xi}(\\eta) = \\ln\\left(\\xi + \\sqrt{\\xi^2 + \\eta^2 + z_0^2}\\right) $$\n接下来，我们必须将 $I_{\\xi}(\\eta)$ 对 $\\eta$ 积分以求得 $\\Phi$。这个积分是不平凡的，但一个已知且满足 $\\frac{\\partial^2\\Phi}{\\partial\\xi\\partial\\eta} = \\frac{1}{\\sqrt{\\xi^2+\\eta^2+z_0^2}}$ 的函数 $\\Phi(\\xi, \\eta, z_0)$ 是：\n$$ \\Phi(\\xi, \\eta, z_0) = \\xi \\ln\\left(\\eta + \\sqrt{\\xi^2+\\eta^2+z_0^2}\\right) + \\eta \\ln\\left(\\xi + \\sqrt{\\xi^2+\\eta^2+z_0^2}\\right) - z_0 \\arctan\\left(\\frac{\\xi\\eta}{z_0\\sqrt{\\xi^2+\\eta^2+z_0^2}}\\right) $$\n“不引用预先制表的公式”这一约束要求我们证明这个结果。我们可以通过微分来验证它。我们期望 $\\frac{\\partial^2\\Phi}{\\partial\\xi\\partial\\eta} = \\frac{1}{\\sqrt{\\xi^2+\\eta^2+z_0^2}} = \\frac{1}{r}$。我们首先对 $\\eta$ 求导。令 $r = \\sqrt{\\xi^2+\\eta^2+z_0^2}$。\n$$ \\frac{\\partial\\Phi}{\\partial\\eta} = \\frac{\\partial}{\\partial\\eta}\\left[\\xi \\ln(\\eta + r)\\right] + \\frac{\\partial}{\\partial\\eta}\\left[\\eta \\ln(\\xi + r)\\right] - \\frac{\\partial}{\\partial\\eta}\\left[z_0 \\arctan\\left(\\frac{\\xi\\eta}{z_0 r}\\right)\\right] $$\n经过计算（涉及分部求导和代数化简），可以得到：\n$$ \\frac{\\partial\\Phi}{\\partial\\eta} = \\ln(\\xi+r) + \\frac{\\eta^2}{\\eta^2+z_0^2} $$\n接下来，我们对此表达式关于 $\\xi$ 求导：\n$$ \\frac{\\partial^2\\Phi}{\\partial\\xi\\partial\\eta} = \\frac{\\partial}{\\partial\\xi}\\left(\\ln(\\xi+r) + \\frac{\\eta^2}{\\eta^2+z_0^2}\\right) = \\frac{1+\\partial r/\\partial\\xi}{\\xi+r} + 0 = \\frac{1+\\xi/r}{\\xi+r} = \\frac{(r+\\xi)/r}{r+\\xi} = \\frac{1}{r} $$\n这验证了所提出的 $\\Phi$ 是正确的（在相差仅依赖于 $\\xi$ 或 $\\eta$ 的函数的情形下）。通过对称性可以确定其完整形式。\n\n必须指定 $\\arctan(\\cdot)$ 的分支。由于 $z_0 \\neq 0$，平方根的参数总是正的。对于 $z_00$，令 $\\arctan$ 的范围为 $(-\\pi/2, \\pi/2)$。其参数 $\\frac{\\xi\\eta}{z_0\\sqrt{\\dots}}$ 是良态的。按要求使用主分支。\n项 $\\ln(\\eta+\\sqrt{\\dots})$ 要求其参数为正。由于 $\\sqrt{\\dots} \\ge |\\eta|$，该参数仅在 $\\eta \\le 0$ 且 $\\xi=z_0=0$ 时为零，而本题 $z_0 \\neq 0$ 的条件排除了这种情况。\n\n综合所有部分，势 $u(\\mathbf{r}_{0})$ 由下式给出：\n$$ u(\\mathbf{r}_{0}) = \\frac{\\sigma_{0}}{4 \\pi} \\sum_{i=1}^{2} \\sum_{j=1}^{2} (-1)^{i+j} \\Phi(a_{i}-x_{0}, b_{j}-y_{0}, z_{0}) $$\n令 $\\xi_{i} = a_{i}-x_{0}$ 和 $\\eta_{j} = b_{j}-y_{0}$。令 $r_{ij} = \\sqrt{\\xi_{i}^2 + \\eta_{j}^2 + z_{0}^2}$。最终表达式为：\n$$ u(\\mathbf{r}_{0}) = \\frac{\\sigma_{0}}{4\\pi} \\sum_{i=1}^{2} \\sum_{j=1}^{2} (-1)^{i+j} \\left[ \\xi_{i} \\ln(\\eta_{j} + r_{ij}) + \\eta_{j} \\ln(\\xi_{i} + r_{ij}) - z_{0} \\arctan\\left(\\frac{\\xi_{i}\\eta_{j}}{z_{0}r_{ij}}\\right) \\right] $$\n这个表达式就是闭式解析解。\n\n现在，对于问题的第二部分。这个解析解可以作为一个精确的基准，用于验证数值积分格式，尤其是在近奇异积分这一具有挑战性的情况下。当目标点 $\\mathbf{r}_{0}$ 非常靠近板 $\\Gamma$ 时，即 $|z_{0}|$ 相对于板的尺寸很小时，就会出现这种情况。\n对于这样的比较，一个无量纲的距离参数是必不可少的。我们可以将其定义为：\n$$ \\delta = \\frac{|z_{0}|}{L} $$\n其中 $L$ 是板的特征长度，例如，其面积的平方根，$L = \\sqrt{(a_2-a_1)(b_2-b_1)}$。\n\n为了比较不同的数值积分方法（例如，标准高斯积分、Duffy变换、奇异性减去法），我们需要一个具体的误差度量。相对误差是一个合适的选择：\n$$ E_{rel}(\\delta) = \\frac{|u_{num}(\\mathbf{r}_{0}) - u(\\mathbf{r}_{0})|}{|u(\\mathbf{r}_{0})|} $$\n这里，$u_{num}(\\mathbf{r}_{0})$ 是数值格式的结果，而 $u(\\mathbf{r}_{0})$ 是从上面推导的解析公式得到的精确值。一个有效的比较方法是，为一系列递减的 $\\delta$ 值（即目标点越来越接近板）计算 $E_{rel}$。\n\n通过在双对数坐标上绘制不同数值方法的 $E_{rel}$ 对 $\\delta$ 的曲线，可以直接可视化并比较它们在近奇异区域的准确性和收敛率。一个稳健的近奇异积分方法即使在 $\\delta$ 非常小的情况下也能保持较低的相对误差，而标准方法通常在 $\\delta \\rightarrow 0$ 时精度会迅速下降。这种系统性的比较能够对边界元法（BEM）模拟中最合适的积分策略进行严格的评估和选择，在这类模拟中，近场相互作用是常见的，并且对整体精度至关重要。\n\n最终答案是 $u(\\mathbf{r}_{0})$ 的显式表达式。",
            "answer": "$$ \\boxed{ \\frac{\\sigma_{0}}{4\\pi} \\sum_{i=1}^{2} \\sum_{j=1}^{2} (-1)^{i+j} \\left[ (a_{i}-x_{0}) \\ln\\left(b_{j}-y_{0} + r_{ij}\\right) + (b_{j}-y_{0}) \\ln\\left(a_{i}-x_{0} + r_{ij}\\right) - z_{0} \\arctan\\left(\\frac{(a_{i}-x_{0})(b_{j}-y_{0})}{z_{0}r_{ij}}\\right) \\right] \\text{ 其中 } r_{ij} = \\sqrt{(a_{i}-x_{0})^2 + (b_{j}-y_{0})^2 + z_{0}^2} } $$"
        },
        {
            "introduction": "在建立了分析基准之后，我们转向为特定奇异性量身定制的数值技术。对于光滑闭合边界上的积分，其核函数常常呈现对数奇异性，此时标准的求积法则会失效。本练习  将引导您应用专为处理此类周期性对数奇异性而设计的Kress求积法，并将其结果与解析解进行比较，从而深刻理解为特定问题选择合适数值工具的重要性。",
            "id": "3333363",
            "problem": "对于给定的二维拉普拉斯方程，与闭合光滑曲线和标量密度相关的单层势被定义为密度与拉普拉斯算子自由空间格林函数的卷积。在二维空间中，自由空间格林函数是拉普拉斯方程的基本解，由对数核给出。考虑由 $x(\\theta) = (\\cos\\theta, \\sin\\theta)$（其中 $\\theta \\in [0, 2\\pi)$）参数化的单位圆和单层势\n$$\nS\\sigma(r_0) = \\int_{0}^{2\\pi} G(r_0, x(\\theta)) \\, \\sigma(\\theta) \\, d\\theta,\n$$\n其中 $G(r_0, x(\\theta)) = -\\frac{1}{2\\pi}\\log\\left|r_0 - x(\\theta)\\right|$，密度为 $\\sigma(\\theta) = \\cos(m\\theta)$，其中整数 $m \\ge 1$。目标点在极坐标中由半径 $\\rho$ 和极角 $\\theta_0$ 指定，即 $r_0 = (\\rho\\cos\\theta_0, \\rho\\sin\\theta_0)$。将与单位圆的偏移量定义为 $d$，并让边标志指示目标点是在圆外（$\\rho = 1 + d$，其中 $d \\ge 0$）、圆内（$\\rho = 1 - d$，其中 $0 \\le d  1$），还是在边界上（$\\rho = 1$，对应于 $d = 0$）。\n\n仅从以下基本基础出发：\n- 二维拉普拉斯单层势的定义，其自由空间格林函数为 $G(r, r') = -\\frac{1}{2\\pi}\\log|r - r'|$。\n- 单位圆的参数化 $x(\\theta) = (\\cos\\theta, \\sin\\theta)$ 以及 $|x'(\\theta)| = 1$ 的事实，因此线元为 $d s = d\\theta$。\n- 三角函数在一个周期上的标准正交关系和傅里叶级数的基本知识。\n\n任务：\n1) 对于位于角度为 $\\theta_0$、半径为 $\\rho \\neq 1$ 的射线上的离面目标点 $r_0$，推导 $\\sigma(\\theta) = \\cos(m\\theta)$ 时 $S\\sigma(r_0)$ 的解析值。用 $\\rho$、$m$ 和 $\\theta_0$ 显式表达你的结果。角度必须以弧度为单位。你的最终表达式必须对 $\\rho  1$ 和 $\\rho > 1$ 都有效。\n2) 将你的推导特殊化至边界面极限 $\\rho \\to 1$（即 $d \\to 0$），以获得在 $x(\\theta_0)$ 处的单层势的边界值。\n3) 设计并实现一种数值求积方法，在 $[0,2\\pi)$ 上使用偶数 $N$ 的等距节点 $\\theta_j = \\frac{2\\pi j}{N}$ 来近似 $S\\sigma(r_0)$。对于离面目标点（$\\rho \\ne 1$），被积函数是光滑的；应用周期梯形法则来近似该积分。对于边界面目标点（$\\rho = 1$），核函数具有 $\\log\\left(4\\sin^2\\frac{\\theta-\\theta_0}{2}\\right)$ 形式的对数奇异性；应用 Kress 求积法（即，使用特殊的周期权重，这些权重能够在选定的网格上精确地对高达奈奎斯特频率的三角多项式与对数核的乘积进行积分）。在边界面情况下，将情况限制为 $\\theta_0$ 恰好是求积节点之一。\n4) 对于以下测试套件，将数值近似与解析结果进行比较。对每种情况，计算绝对误差，结果为浮点数。\n\n使用以下测试套件，其参数为元组 $(m,\\theta_0,d,\\text{side},N)$：\n- 案例 A (圆外，光滑): $(3, 1.1, 0.3, \\text{\"outside\"}, 256)$。\n- 案例 B (圆内，光滑): $(4, 2.2, 0.25, \\text{\"inside\"}, 256)$。\n- 案例 C (圆外，近奇异): $(7, 1.7, 10^{-6}, \\text{\"outside\"}, 4096)$。\n- 案例 D (边界面，奇异，需要Kress方法；确保 $\\theta_0$ 是一个节点): $(5, 0.0, 0.0, \\text{\"boundary\"}, 256)$。\n\n定义与约定：\n- 对于 \"outside\" 边，使用 $\\rho = 1 + d$，$d \\ge 0$。\n- 对于 \"inside\" 边，使用 $\\rho = 1 - d$，$0 \\le d  1$。\n- 对于 \"boundary\" 边，使用 $\\rho = 1$（因此 $d = 0$），并确保 $\\theta_0 = \\frac{2\\pi j}{N}$（对于某个整数 $j$），使其恰好是一个网格节点。\n- 所有角度均以弧度为单位。\n\n你的程序必须：\n- 实现步骤 1-2 中推导的解析公式。\n- 实现用于离面求值的周期梯形法则和用于在网格节点处进行边界面求值的 Kress 求积法。Kress 求积法必须使用从对数核的傅里叶级数表示中导出的权重，并且必须对偶数 $N$ 有效。\n- 生成单行输出，其中包含案例 A–D 的绝对误差，格式为逗号分隔的 Python 列表，例如 `\"[eA,eB,eC,eD]\"`。不应打印任何其他文本。\n\n所有输出都是无量纲的，并应以 Python 默认格式的标准浮点数打印。答案必须是完全自包含的，并且无需任何用户输入即可运行。最终输出格式是如上所述的单行 Python 列表字面量。",
            "solution": "该问题要求推导单位圆上的二维拉普拉斯单层势的解析公式，将其特殊化到边界上，并实现数值求积方法以进行比较。\n\n单层势 $S\\sigma(r_0)$ 由下式给出\n$$S\\sigma(r_0) = \\int_{0}^{2\\pi} G(r_0, x(\\theta)) \\, \\sigma(\\theta) \\, d\\theta$$\n其中域是单位圆，由 $x(\\theta) = (\\cos\\theta, \\sin\\theta)$ 参数化，密度为 $\\sigma(\\theta) = \\cos(m\\theta)$（整数 $m \\ge 1$），格林函数为 $G(r_0, x(\\theta)) = -\\frac{1}{2\\pi}\\log\\left|r_0 - x(\\theta)\\right|$。目标点为 $r_0 = (\\rho\\cos\\theta_0, \\rho\\sin\\theta_0)$。线元为 $ds = |x'(\\theta)|d\\theta = d\\theta$。\n\n**1. 解析推导（离面，$\\rho \\neq 1$）**\n\n首先，我们确定距离 $|r_0 - x(\\theta)|$。\n\\begin{align*} |r_0 - x(\\theta)|^2 = \\|(\\rho\\cos\\theta_0 - \\cos\\theta, \\rho\\sin\\theta_0 - \\sin\\theta)\\|^2 \\\\ = (\\rho\\cos\\theta_0 - \\cos\\theta)^2 + (\\rho\\sin\\theta_0 - \\sin\\theta)^2 \\\\ = \\rho^2\\cos^2\\theta_0 - 2\\rho\\cos\\theta_0\\cos\\theta + \\cos^2\\theta + \\rho^2\\sin^2\\theta_0 - 2\\rho\\sin\\theta_0\\sin\\theta + \\sin^2\\theta \\\\ = \\rho^2(\\cos^2\\theta_0 + \\sin^2\\theta_0) + (\\cos^2\\theta + \\sin^2\\theta) - 2\\rho(\\cos\\theta_0\\cos\\theta + \\sin\\theta_0\\sin\\theta) \\\\ = \\rho^2 + 1 - 2\\rho\\cos(\\theta - \\theta_0)\\end{align*}\n单层势积分变为：\n$$ S\\sigma(r_0) = -\\frac{1}{2\\pi} \\int_0^{2\\pi} \\log\\left(\\sqrt{\\rho^2 + 1 - 2\\rho\\cos(\\theta - \\theta_0)}\\right) \\cos(m\\theta) \\, d\\theta $$\n$$ S\\sigma(r_0) = -\\frac{1}{4\\pi} \\int_0^{2\\pi} \\log\\left(\\rho^2 + 1 - 2\\rho\\cos(\\theta - \\theta_0)\\right) \\cos(m\\theta) \\, d\\theta $$\n为计算此积分，我们使用对数项的傅里叶级数展开。相关恒等式为：\n$$ \\log(1 - 2z\\cos\\phi + z^2) = -2 \\sum_{k=1}^{\\infty} \\frac{z^k}{k} \\cos(k\\phi), \\quad |z|1 $$\n我们必须考虑目标点半径 $\\rho$ 的两种情况。\n\n情况1：$\\rho  1$（圆内）。\n令 $z = \\rho$ 且 $\\phi = \\theta - \\theta_0$。由于 $\\rho  1$，该展开有效。\n$$ \\log(1 - 2\\rho\\cos(\\theta-\\theta_0) + \\rho^2) = -2 \\sum_{k=1}^{\\infty} \\frac{\\rho^k}{k} \\cos(k(\\theta-\\theta_0)) $$\n将此代入 $S\\sigma(r_0)$ 的积分中：\n$$ S\\sigma(r_0) = -\\frac{1}{4\\pi} \\int_0^{2\\pi} \\left( -2 \\sum_{k=1}^{\\infty} \\frac{\\rho^k}{k} \\cos(k(\\theta-\\theta_0)) \\right) \\cos(m\\theta) \\, d\\theta $$\n$$ S\\sigma(r_0) = \\frac{1}{2\\pi} \\sum_{k=1}^{\\infty} \\frac{\\rho^k}{k} \\int_0^{2\\pi} \\cos(k(\\theta-\\theta_0)) \\cos(m\\theta) \\, d\\theta $$\n该积分使用三角恒等式和正交性进行计算：\n$$ \\int_0^{2\\pi} \\cos(k(\\theta-\\theta_0)) \\cos(m\\theta) \\, d\\theta = \\int_0^{2\\pi} (\\cos(k\\theta)\\cos(k\\theta_0) + \\sin(k\\theta)\\sin(k\\theta_0)) \\cos(m\\theta) \\, d\\theta $$\n由于 $m \\ge 1$ 且 $k \\ge 1$，正交关系给出 $\\int_0^{2\\pi} \\sin(k\\theta)\\cos(m\\theta)d\\theta = 0$ 和 $\\int_0^{2\\pi} \\cos(k\\theta)\\cos(m\\theta)d\\theta = \\pi \\delta_{km}$。\n仅当 $k=m$ 时积分非零，结果为 $\\pi \\cos(m\\theta_0)$。该级数收敛为单项：\n$$ S\\sigma(r_0) = \\frac{1}{2\\pi} \\frac{\\rho^m}{m} (\\pi \\cos(m\\theta_0)) = \\frac{\\rho^m}{2m} \\cos(m\\theta_0) $$\n\n情况2：$\\rho > 1$（圆外）。\n我们从对数的自变量中因子分解出 $\\rho^2$：\n$$ \\log(\\rho^2 + 1 - 2\\rho\\cos(\\theta - \\theta_0)) = \\log\\left(\\rho^2\\left(1 - \\frac{2}{\\rho}\\cos(\\theta - \\theta_0) + \\frac{1}{\\rho^2}\\right)\\right) = 2\\log\\rho + \\log\\left(1 - 2\\frac{1}{\\rho}\\cos(\\theta - \\theta_0) + \\left(\\frac{1}{\\rho}\\right)^2\\right) $$\n令 $z = 1/\\rho$。由于 $\\rho > 1$，我们有 $|z|  1$，展开式有效：\n$$ \\log(\\dots) = 2\\log\\rho - 2 \\sum_{k=1}^{\\infty} \\frac{(1/\\rho)^k}{k} \\cos(k(\\theta-\\theta_0)) $$\n将此代入 $S\\sigma(r_0)$ 的积分中：\n$$ S\\sigma(r_0) = -\\frac{1}{4\\pi} \\int_0^{2\\pi} \\left( 2\\log\\rho - 2 \\sum_{k=1}^{\\infty} \\frac{\\rho^{-k}}{k} \\cos(k(\\theta-\\theta_0)) \\right) \\cos(m\\theta) \\, d\\theta $$\n第一项的积分为零：因为 $m \\ge 1$，所以 $-\\frac{2\\log\\rho}{4\\pi}\\int_0^{2\\pi}\\cos(m\\theta)d\\theta = 0$。\n第二部分与情况1相同，只是将 $\\rho$ 替换为 $\\rho^{-1}$：\n$$ S\\sigma(r_0) = \\frac{1}{2\\pi} \\sum_{k=1}^{\\infty} \\frac{\\rho^{-k}}{k} \\int_0^{2\\pi} \\cos(k(\\theta-\\theta_0)) \\cos(m\\theta) \\, d\\theta = \\frac{\\rho^{-m}}{2m} \\cos(m\\theta_0) $$\n\n结合两种情况，$\\rho \\neq 1$ 时的解析解为：\n$$ S\\sigma(r_0) = \\begin{cases} \\displaystyle \\frac{\\rho^m}{2m} \\cos(m\\theta_0),  \\rho  1 \\\\ \\displaystyle \\frac{\\rho^{-m}}{2m} \\cos(m\\theta_0),  \\rho > 1 \\end{cases} $$\n\n**2. 解析推导（边界面，$\\rho \\to 1$）**\n\n为了求得边界上的势值，我们分别从内部和外部取 $\\rho \\to 1$ 的极限：\n$$ \\lim_{\\rho \\to 1^-} S\\sigma(r_0) = \\lim_{\\rho \\to 1^-} \\frac{\\rho^m}{2m} \\cos(m\\theta_0) = \\frac{1}{2m} \\cos(m\\theta_0) $$\n$$ \\lim_{\\rho \\to 1^+} S\\sigma(r_0) = \\lim_{\\rho \\to 1^+} \\frac{\\rho^{-m}}{2m} \\cos(m\\theta_0) = \\frac{1}{2m} \\cos(m\\theta_0) $$\n极限存在且唯一，因此对于边界（$\\rho=1$）上的点 $x(\\theta_0)$：\n$$ S\\sigma(x(\\theta_0)) = \\frac{1}{2m} \\cos(m\\theta_0) $$\n\n**3. 数值求积设计**\n\n该积分在由 $N$ 个等距节点 $\\theta_j = 2\\pi j/N$（其中 $j=0, 1, \\dots, N-1$）组成的网格上进行近似。\n\n离面情况（$\\rho \\neq 1$）：\n被积函数是一个关于 $\\theta$ 的光滑、$2\\pi$-周期函数。对于此类函数，周期梯形法则表现出谱精度。该法则将积分近似为：\n$$ S_N(r_0) = \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} G(r_0, x(\\theta_j)) \\sigma(\\theta_j) $$\n代入 $G$ 和 $\\sigma$ 的表达式：\n$$ S_N(r_0) = \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} \\left(-\\frac{1}{4\\pi}\\log(\\rho^2+1-2\\rho\\cos(\\theta_j-\\theta_0))\\right) \\cos(m\\theta_j) $$\n$$ S_N(r_0) = -\\frac{1}{2N} \\sum_{j=0}^{N-1} \\log(\\rho^2+1-2\\rho\\cos(\\theta_j-\\theta_0)) \\cos(m\\theta_j) $$\n\n边界面情况（$\\rho = 1$）：\n当 $\\rho=1$ 时，目标点 $r_0 = x(\\theta_0)$ 位于积分路径上。当 $\\theta \\to \\theta_0$ 时，核函数 $G(x(\\theta_0), x(\\theta))$ 变为奇异。\n$$ |x(\\theta_0) - x(\\theta)|^2 = 1+1-2\\cos(\\theta-\\theta_0) = 2(1-\\cos(\\theta-\\theta_0)) = 4\\sin^2\\left(\\frac{\\theta-\\theta_0}{2}\\right) $$\n该核函数具有对数奇异性：\n$$ G(x(\\theta_0), x(\\theta)) = -\\frac{1}{2\\pi}\\log\\left|2\\sin\\left(\\frac{\\theta-\\theta_0}{2}\\right)\\right| = -\\frac{1}{4\\pi}\\log\\left(4\\sin^2\\left(\\frac{\\theta-\\theta_0}{2}\\right)\\right) $$\n标准梯形法则失效。Kress 求积法是为这类奇异积分设计的。对于形式为 $I = \\int_0^{2\\pi} \\log(4\\sin^2(t/2)) f(t) dt$ 的积分，Kress 求积近似为 $Q_N[f] = \\sum_{j=0}^{N-1} T_j f(t_j)$，其中 $t_j = 2\\pi j/N$。对于偶数点 $N$，权重 $T_j$ 由下式给出：\n$$ T_j = -\\frac{4\\pi}{N} \\sum_{k=1}^{N/2-1} \\frac{1}{k} \\cos\\left(\\frac{2\\pi j k}{N}\\right) - \\frac{2\\pi}{N^2}(-1)^j $$\n我们的积分是 $S\\sigma(x(\\theta_0)) = -\\frac{1}{4\\pi} \\int_0^{2\\pi} \\log\\left(4\\sin^2\\left(\\frac{\\theta-\\theta_0}{2}\\right)\\right) \\cos(m\\theta) d\\theta$。\n问题陈述目标点 $\\theta_0$ 是一个网格节点，$\\theta_0 = \\theta_l = 2\\pi l/N$（对于某个整数 $l$）。通过平移积分变量，该积分可以由循环卷积近似：\n$$ S_N(x(\\theta_l)) = -\\frac{1}{4\\pi} \\sum_{j=0}^{N-1} T_{j-l} \\cos(m\\theta_j) $$\n其中 $T$ 的下标是模 $N$ 的。",
            "answer": "```python\nimport numpy as np\nfrom math import pi\n\ndef solve():\n    \"\"\"\n    Solves the Laplace single-layer potential problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # (m, theta_0, d, side, N)\n        (3, 1.1, 0.3, \"outside\", 256),   # Case A\n        (4, 2.2, 0.25, \"inside\", 256),    # Case B\n        (7, 1.7, 1e-6, \"outside\", 4096),  # Case C\n        (5, 0.0, 0.0, \"boundary\", 256)   # Case D\n    ]\n\n    def analytic_solution(m: int, rho: float, theta0: float) - float:\n        \"\"\"\n        Computes the analytic solution for the single-layer potential.\n        \"\"\"\n        if abs(rho - 1.0)  1e-15:  # On-surface case\n            val = 1.0 / (2.0 * m) * np.cos(m * theta0)\n        elif rho  1.0:  # Inside\n            val = (rho**m) / (2.0 * m) * np.cos(m * theta0)\n        else:  # Outside\n            val = (rho**-m) / (2.0 * m) * np.cos(m * theta0)\n        return val\n\n    def compute_kress_weights(N: int) - np.ndarray:\n        \"\"\"\n        Computes the Kress quadrature weights for the logarithmic kernel.\n        \"\"\"\n        if N % 2 != 0:\n            raise ValueError(\"N must be even for this Kress weight formula.\")\n        \n        j_vals = np.arange(N)\n        k_vals = np.arange(1, N // 2)\n        \n        # Vectorized computation of the sum term\n        sum_term = np.sum( (1.0 / k_vals[:, np.newaxis]) * \n                           np.cos(2 * pi * k_vals[:, np.newaxis] * j_vals[np.newaxis, :] / N), axis=0)\n                           \n        T = -(4.0 * pi / N) * sum_term - (2.0 * pi / N**2) * ((-1)**j_vals)\n        return T\n\n    def numerical_solution(m, theta0, d, side, N):\n        \"\"\"\n        Computes the numerical solution using appropriate quadrature.\n        \"\"\"\n        theta = 2.0 * pi * np.arange(N) / N\n        sigma_vals = np.cos(m * theta)\n        \n        if side == \"boundary\":\n            # On-surface, Kress quadrature\n            if not np.isclose(d, 0.0):\n                 raise ValueError(\"For boundary case, d must be 0.\")\n\n            # Find the index l of the node corresponding to theta0\n            l = int(round(theta0 * N / (2.0 * pi)))\n            if not np.isclose(theta0, l * 2.0 * pi / N):\n                raise ValueError(\"For boundary case, theta0 must be a grid node.\")\n\n            kress_weights = compute_kress_weights(N)\n            # The sum is a circular convolution Sum_j T_{j-l}*sigma_j\n            # which is implemented by rolling the weights array.\n            kress_weights_shifted = np.roll(kress_weights, l)\n            \n            integral_approx = np.dot(kress_weights_shifted, sigma_vals)\n            \n            # The potential is (-1/4pi) * integral_approx\n            num_val = -1.0 / (4.0 * pi) * integral_approx\n            \n        else:\n            # Off-surface, periodic trapezoidal rule\n            if side == \"outside\":\n                rho = 1.0 + d\n            elif side == \"inside\":\n                rho = 1.0 - d\n            else:\n                raise ValueError(\"Invalid side specified.\")\n\n            log_arg = rho**2 + 1.0 - 2.0 * rho * np.cos(theta - theta0)\n            integrand = np.log(log_arg) * sigma_vals\n            \n            # The potential is (-1/2N) * Sum(integrand)\n            num_val = -1.0 / (2.0 * N) * np.sum(integrand)\n\n        return num_val\n\n    results = []\n    for m, theta0, d, side, N in test_cases:\n        if side == \"outside\":\n            rho = 1.0 + d\n        elif side == \"inside\":\n            rho = 1.0 - d\n        else: # boundary\n            rho = 1.0\n\n        ana_val = analytic_solution(m, rho, theta0)\n        num_val = numerical_solution(m, theta0, d, side, N)\n        \n        error = abs(ana_val - num_val)\n        results.append(error)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们已经学习了如何利用解析方法和专门的数值格式来获得精确的积分结果，但一个实际的算法如何能自动判断在何处需要投入更多的计算资源呢？关键在于对局部积分误差进行估计。本练习  将引导您通过对被积函数进行渐近展开，推导出一个考虑了局部曲率和密度函数变化的误差估计器，这是构建自适应算法的基石。掌握这种方法，您就能设计出智能的计算程序，它能够自动在难点区域加密剖分，从而在保证精度的同时实现高效计算。",
            "id": "3333358",
            "problem": "考虑一个出现在计算电磁学边界积分公式中的光滑曲面片，需要在此曲面片上计算一个核函数的近奇异积分。设目标点位于曲面上的一个最近点，并沿局部单位法向量偏移一小段距离。我们感兴趣的积分是拉普拉斯单层势，它是计算电磁学中遇到的核函数的近奇异行为的一个公认的近似模型，其定义为积分 $$I = \\int_{\\Gamma} \\frac{\\phi(\\mathbf{y})}{4\\pi\\lVert \\mathbf{x}-\\mathbf{y}\\rVert} \\, \\mathrm{d}S_{\\mathbf{y}},$$ 其中 $\\Gamma$ 是光滑曲面上的一个小面板，$\\mathbf{x}$ 是一个从最近点 $\\mathbf{y}_0 \\in \\Gamma$ 沿单位法向量 $\\mathbf{n}_0$ 偏移距离 $d$ 的点，而 $\\phi$ 是一个光滑的表面密度。\n\n在 $\\mathbf{y}_0$ 点的局部主方向上进行分析，并通过带有主曲率 $\\kappa_1$ 和 $\\kappa_2$ 的局部 Monge 参数化来对该曲面片建模，从而得到 $$\\mathbf{y}(u,v) \\approx \\mathbf{y}_0 + u\\,\\mathbf{t}_1 + v\\,\\mathbf{t}_2 + \\frac{1}{2}\\left(\\kappa_1 u^2 + \\kappa_2 v^2\\right)\\mathbf{n}_0,$$ 且面积元满足 $$\\mathrm{d}S \\approx \\left( 1 + \\frac{1}{2}\\left(\\kappa_1^2 u^2 + \\kappa_2^2 v^2\\right) \\right) \\,\\mathrm{d}u\\,\\mathrm{d}v.$$ 假设密度在 $\\mathbf{y}_0$ 点附近有一个光滑的表面泰勒展开，形式为 $$\\phi(\\mathbf{y}(u,v)) \\approx \\phi_0 + g_1 u + g_2 v + \\frac{1}{2}\\left(h_{11} u^2 + 2 h_{12} u v + h_{22} v^2\\right),$$ 其中 $\\phi_0 = \\phi(\\mathbf{y}_0)$，$(g_1,g_2)$ 是局部表面梯度的分量，而 $(h_{11},h_{12},h_{22})$ 是局部表面海森矩阵的分量。在这些坐标系中，考虑一个以原点 $(u,v)=(0,0)$ 为中心、边长为 $h$ 的方形面板，并使用单点（形心）法则来近似其贡献，即在面板中心计算被积函数的值，然后乘以面板面积。\n\n从这些定义和近似出发，并使用对 $\\lVert\\mathbf{x}-\\mathbf{y}\\rVert$ 和 $\\mathrm{d}S$ 的第一性原理渐近展开，推导积分 $I$ 的单点形心求积的误差估计量 $E_{\\mathrm{est}}$。该估计量需要捕捉到由核函数变化、局部曲率 $(\\kappa_1,\\kappa_2)$ 和局部表面海森矩阵的迹 $H_{\\mathrm{tr}} = h_{11}+h_{22}$ 引起的主导修正项。您可以假设面板足够小，以至于主导阶项占主导地位。为获得闭式系数，用一个半径为 $a$ 的等面积圆盘替换方形面板，使得 $$\\pi a^2 = h^2,$$ 并用 $a$ 和偏移距离 $d$ 表示所需的径向积分。您的估计量必须是一个标量，并且其设计应能与用户指定的容差 $\\tau$ 进行比较，以决定是否应对面板进行加密。\n\n您的程序必须实现所推导的估计量，并对以下每个测试用例产生自适应加密决策。在每个用例中，输入参数为偏移距离 $d$、面板尺寸 $h$、局部密度值 $\\phi_0$、主曲率 $(\\kappa_1,\\kappa_2)$、局部海森迹 $H_{\\mathrm{tr}}$ 和容差 $\\tau$。\n\n测试套件：\n- 用例 1：$d = 0.5$, $h = 0.5$, $\\phi_0 = 1.0$, $\\kappa_1 = 0.0$, $\\kappa_2 = 0.0$, $H_{\\mathrm{tr}} = 0.1$, $\\tau = 10^{-3}$。\n- 用例 2：$d = 0.01$, $h = 0.2$, $\\phi_0 = 1.0$, $\\kappa_1 = 0.2$, $\\kappa_2 = 0.2$, $H_{\\mathrm{tr}} = 0.5$, $\\tau = 10^{-3}$。\n- 用例 3：$d = 2.5$, $h = 0.5$, $\\phi_0 = 1.0$, $\\kappa_1 = 1.0$, $\\kappa_2 = 1.0$, $H_{\\mathrm{tr}} = 0.2$, $\\tau = 10^{-3}$。\n- 用例 4：$d = 0.25$, $h = 0.5$, $\\phi_0 = 1.0$, $\\kappa_1 = 2.0$, $\\kappa_2 = -1.0$, $H_{\\mathrm{tr}} = 1.0$, $\\tau = 10^{-2}$。\n- 用例 5：$d = 0.05$, $h = 0.5$, $\\phi_0 = 0.1$, $\\kappa_1 = 0.0$, $\\kappa_2 = 0.0$, $H_{\\mathrm{tr}} = 0.0$, $\\tau = 10^{-3}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每一项都是一个布尔值，指示是否应为相应情况加密面板，即格式必须完全为 $$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5].$$",
            "solution": "目标是为一个近奇异边界积分的单点形心求积推导误差估计量，并用它来决定是否需要进行面板加密。该积分为拉普拉斯单层势：\n$$I = \\int_{\\Gamma} \\frac{\\phi(\\mathbf{y})}{4\\pi\\lVert \\mathbf{x}-\\mathbf{y}\\rVert} \\, \\mathrm{d}S_{\\mathbf{y}}$$\n单点形心求积法则是通过在面板中心 $\\mathbf{y}_0$ 处计算被积函数的值，然后乘以面板的平面面积 $h^2$ 来近似该积分。点 $\\mathbf{y}_0$ 是局部坐标系中的原点 $(u,v)=(0,0)$。\n$$I_{\\mathrm{approx}} = \\left. \\frac{\\phi(\\mathbf{y})}{4\\pi\\lVert \\mathbf{x}-\\mathbf{y}\\rVert} \\right|_{\\mathbf{y}=\\mathbf{y}_0} \\times (\\text{Area}) = \\frac{\\phi(\\mathbf{y}_0)}{4\\pi\\lVert \\mathbf{x}-\\mathbf{y}_0\\rVert} h^2$$\n给定 $\\mathbf{x} = \\mathbf{y}_0 + d\\,\\mathbf{n}_0$ 和 $\\phi_0 = \\phi(\\mathbf{y}_0)$，我们有 $\\lVert \\mathbf{x}-\\mathbf{y}_0\\rVert = d$。该近似值为：\n$$I_{\\mathrm{approx}} = \\frac{\\phi_0 h^2}{4\\pi d}$$\n误差为 $E = I - I_{\\mathrm{approx}}$。为了估计此误差，我们必须通过纳入指定的更高阶效应来计算一个更精确的 $I$ 版本：核函数变化、表面曲率和密度变化。\n\n为使积分易于处理，我们将边长为 $h$ 的方形面板替换为等面积的圆形圆盘，其半径 $a$ 满足 $\\pi a^2 = h^2$。然后，我们在局部切平面中使用极坐标 $(r, \\theta)$，其中 $u=r\\cos\\theta$ 且 $v=r\\sin\\theta$。\n\n首先，我们展开被积函数的分量。\n曲面上一点的位置向量为 $\\mathbf{y}(u,v) \\approx u\\,\\mathbf{t}_1 + v\\,\\mathbf{t}_2 + \\frac{1}{2}(\\kappa_1 u^2 + \\kappa_2 v^2)\\mathbf{n}_0$。目标点是 $\\mathbf{x} = d\\,\\mathbf{n}_0$。距离的平方是：\n$$\\lVert \\mathbf{x}-\\mathbf{y} \\rVert^2 = u^2 + v^2 + \\left(d - \\frac{1}{2}(\\kappa_1 u^2 + \\kappa_2 v^2)\\right)^2 \\approx r^2 + d^2 - d(\\kappa_1 u^2 + \\kappa_2 v^2)$$\n其中 $r^2 = u^2+v^2$。我们对核函数 $1/\\lVert \\mathbf{x}-\\mathbf{y} \\rVert$ 使用二项式展开：\n$$\\frac{1}{\\lVert \\mathbf{x}-\\mathbf{y}\\rVert} \\approx \\frac{1}{\\sqrt{d^2+r^2}} \\left(1 - \\frac{d(\\kappa_1 u^2 + \\kappa_2 v^2)}{d^2+r^2}\\right)^{-1/2} \\approx \\frac{1}{\\sqrt{d^2+r^2}} \\left(1 + \\frac{d(\\kappa_1 u^2 + \\kappa_2 v^2)}{2(d^2+r^2)}\\right)$$\n表面密度展开为：\n$$\\phi(\\mathbf{y}(u,v)) \\approx \\phi_0 + g_1 u + g_2 v + \\frac{1}{2}(h_{11} u^2 + 2 h_{12} u v + h_{22} v^2)$$\n面积元由 $\\mathrm{d}S \\approx (1 + \\frac{1}{2}(\\kappa_1^2 u^2 + \\kappa_2^2 v^2))\\,\\mathrm{d}u\\,\\mathrm{d}v$ 给出。\n\n积分为 $I = \\frac{1}{4\\pi} \\int_{\\text{disk}} \\phi(\\mathbf{y}) \\frac{1}{\\lVert \\mathbf{x}-\\mathbf{y}\\rVert} (1 + \\frac{1}{2}(\\kappa_1^2 u^2 + \\kappa_2^2 v^2))\\,\\mathrm{d}u\\,\\mathrm{d}v$。\n我们组装被积函数，保留 $u$ 和 $v$ 的偶次项，因为奇次项在对称圆盘上的积分为零。\n$$I(u,v) \\approx \\frac{1}{4\\pi\\sqrt{d^2+r^2}} \\left[ \\phi_0 + \\frac{\\phi_0 d(\\kappa_1 u^2 + \\kappa_2 v^2)}{2(d^2+r^2)} + \\frac{1}{2}(h_{11}u^2+h_{22}v^2) + \\frac{\\phi_0}{2}(\\kappa_1^2 u^2 + \\kappa_2^2 v^2) \\right]$$\n我们在半径为 $a$ 的圆盘上对此进行积分。在极坐标中，$\\mathrm{d}u \\mathrm{d}v = r\\,\\mathrm{d}r\\,\\mathrm{d}\\theta$。我们使用恒等式 $\\int_0^{2\\pi}\\cos^2\\theta\\,\\mathrm{d}\\theta=\\pi$ 和 $\\int_0^{2\\pi}\\sin^2\\theta\\,\\mathrm{d}\\theta=\\pi$。这意味着对于函数 $f(r)$，像 $\\int_{\\text{disk}} f(r) u^2 \\,\\mathrm{d}u\\mathrm{d}v = \\pi \\int_0^a f(r) r^3 \\,\\mathrm{d}r$ 这样的项成立。\n该积分可分为四个部分：\n$I \\approx I_{\\text{base}} + I_\\kappa + I_H + I_{\\kappa^2}$\n1. 来自常数项 $\\phi_0$ 的基本积分：\n$$I_{\\text{base}} = \\frac{1}{4\\pi} \\int_0^{2\\pi}\\int_0^a \\frac{\\phi_0}{\\sqrt{d^2+r^2}} r\\,\\mathrm{d}r\\,\\mathrm{d}\\theta = \\frac{\\phi_0}{2} \\int_0^a \\frac{r}{\\sqrt{d^2+r^2}} \\mathrm{d}r = \\frac{\\phi_0}{2} [\\sqrt{d^2+r^2}]_0^a = \\frac{\\phi_0}{2}(\\sqrt{d^2+a^2}-d)$$\n2. 来自核函数对表面曲率 $(\\kappa_1, \\kappa_2)$ 依赖性的修正项：\n$$I_\\kappa = \\frac{1}{4\\pi} \\int_{\\text{disk}} \\frac{\\phi_0 d(\\kappa_1 u^2 + \\kappa_2 v^2)}{2(d^2+r^2)^{3/2}} \\mathrm{d}u\\mathrm{d}v = \\frac{\\phi_0 d(\\kappa_1+\\kappa_2)}{8} \\int_0^a \\frac{r^3}{(d^2+r^2)^{3/2}}\\mathrm{d}r$$\n3. 来自密度变化（海森迹 $H_{\\mathrm{tr}}=h_{11}+h_{22}$）的修正项：\n$$I_H = \\frac{1}{4\\pi} \\int_{\\text{disk}} \\frac{h_{11}u^2+h_{22}v^2}{2\\sqrt{d^2+r^2}} \\mathrm{d}u\\mathrm{d}v = \\frac{H_{\\mathrm{tr}}}{8} \\int_0^a \\frac{r^3}{\\sqrt{d^2+r^2}}\\mathrm{d}r$$\n4. 来自面积元变化的修正项：\n$$I_{\\kappa^2} = \\frac{1}{4\\pi} \\int_{\\text{disk}} \\frac{\\phi_0}{\\sqrt{d^2+r^2}}\\frac{1}{2}(\\kappa_1^2 u^2+\\kappa_2^2 v^2) \\mathrm{d}u\\mathrm{d}v = \\frac{\\phi_0(\\kappa_1^2+\\kappa_2^2)}{8} \\int_0^a \\frac{r^3}{\\sqrt{d^2+r^2}}\\mathrm{d}r$$\n总误差为 $E = I - I_{\\mathrm{approx}} = (I_{\\text{base}} - I_{\\mathrm{approx}}) + I_H + I_\\kappa + I_{\\kappa^2}$。令 $E_1 = I_{\\text{base}} - I_{\\mathrm{approx}}$，$E_2 = I_H+I_{\\kappa^2}$，以及 $E_3 = I_\\kappa$。估计量为 $E_{\\mathrm{est}} = |E_1 + E_2 + E_3|$。\n\n所需的径向积分计算结果为：\n$$J_1(a,d) = \\int_0^a \\frac{r^3}{\\sqrt{d^2+r^2}}\\mathrm{d}r = \\frac{(a^2-2d^2)\\sqrt{d^2+a^2} + 2d^3}{3}$$\n$$J_2(a,d) = \\int_0^a \\frac{r^3}{(d^2+r^2)^{3/2}}\\mathrm{d}r = \\sqrt{d^2+a^2} + \\frac{d^2}{\\sqrt{d^2+a^2}} - 2d = \\frac{(\\sqrt{d^2+a^2}-d)^2}{\\sqrt{d^2+a^2}}$$\n使用这些结果，误差贡献为：\n$$E_1 = \\frac{\\phi_0}{2}(\\sqrt{d^2+a^2}-d) - \\frac{\\phi_0 a^2}{4d}$$\n$$E_2 = (I_H + I_{\\kappa^2}) = \\frac{1}{8}(H_{\\mathrm{tr}} + \\phi_0(\\kappa_1^2+\\kappa_2^2)) J_1(a,d)$$\n$$E_3 = I_\\kappa = \\frac{\\phi_0 d(\\kappa_1+\\kappa_2)}{8} J_2(a,d)$$\n为确保小 $d$ 值的数值稳定性，$E_1$ 可以被重构。令 $S=\\sqrt{d^2+a^2}$。\n$$E_1 = \\frac{\\phi_0}{2}\\left(\\frac{a^2}{S+d} - \\frac{a^2}{2d}\\right) = \\frac{\\phi_0 a^2}{2}\\frac{2d - (S+d)}{2d(S+d)} = \\frac{\\phi_0 a^2 (d-S)}{4d(S+d)}$$\n最终的误差估计量是这些修正项之和的绝对值：\n$$E_{\\mathrm{est}} = \\left| E_1 + E_2 + E_3 \\right|$$\n加密准则为 $E_{\\mathrm{est}}  \\tau$。\n用于实现的最终公式，其中 $a^2 = h^2/\\pi$：\n令 $S = \\sqrt{d^2+h^2/\\pi}$。\n$$E_1 = \\frac{\\phi_0 (h^2/\\pi)}{4} \\frac{d-S}{d(S+d)}$$\n$$E_2 = \\frac{1}{8}\\left(H_{\\mathrm{tr}} + \\phi_0(\\kappa_1^2+\\kappa_2^2)\\right) \\frac{(h^2/\\pi-2d^2)S + 2d^3}{3}$$\n$$E_3 = \\frac{\\phi_0 d(\\kappa_1+\\kappa_2)}{8} \\frac{(S-d)^2}{S}$$\n$$E_{\\mathrm{est}} = |E_1 + E_2 + E_3|$$",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates an error estimator for a one-point quadrature rule for a\n    near-singular integral and decides whether panel refinement is needed.\n    \"\"\"\n    test_cases = [\n        # d, h, phi_0, k1, k2, H_tr, tau\n        (0.5, 0.5, 1.0, 0.0, 0.0, 0.1, 1e-3),\n        (0.01, 0.2, 1.0, 0.2, 0.2, 0.5, 1e-3),\n        (2.5, 0.5, 1.0, 1.0, 1.0, 0.2, 1e-3),\n        (0.25, 0.5, 1.0, 2.0, -1.0, 1.0, 1e-2),\n        (0.05, 0.5, 0.1, 0.0, 0.0, 0.0, 1e-3),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        d, h, phi_0, k1, k2, H_tr, tau = case\n        \n        # Area of the equivalent disk, a^2 = h^2 / pi\n        a_sq = h**2 / np.pi\n        \n        # Auxiliary variable S = sqrt(d^2 + a^2)\n        S = np.sqrt(d**2 + a_sq)\n\n        # Contribution 1: Error from approximating the kernel 1/R\n        # This is (I_base - I_approx)\n        # Numerically stable form: E1 = phi_0/2 * (a^2/(S+d) - a^2/(2d))\n        E1_numerator = phi_0 * a_sq * (d - S)\n        E1_denominator = 4 * d * (S + d)\n        E1 = E1_numerator / E1_denominator\n        \n        # Contribution 2: Error from density variation (Hessian) and area element curvature (k^2)\n        # Both terms involve the same radial integral J1.\n        # J1 = integral(r^3 / sqrt(d^2+r^2)) dr from 0 to a\n        J1_integrand = (a_sq - 2*d**2) * S + 2*d**3\n        J1 = J1_integrand / 3.0\n        E2_prefactor = (H_tr + phi_0 * (k1**2 + k2**2)) / 8.0\n        E2 = E2_prefactor * J1\n        \n        # Contribution 3: Error from kernel dependence on surface curvature (k)\n        # This term involves a radial integral J2.\n        # J2 = integral(r^3 / (d^2+r^2)^(3/2)) dr from 0 to a\n        # Numerically stable form: J2 = (S-d)^2 / S\n        J2 = (S - d)**2 / S\n        E3_prefactor = (phi_0 * d * (k1 + k2)) / 8.0\n        E3 = E3_prefactor * J2\n        \n        # Total error estimator is the absolute value of the sum of corrections\n        E_est = np.abs(E1 + E2 + E3)\n        \n        # Decision: refine if the estimated error exceeds the tolerance\n        should_refine = E_est  tau\n        results.append(should_refine)\n\n    # Format the output as a comma-separated list of booleans\n    # The map(str,...) and .lower() is to match the required output format, e.g., [True,False] - [true,false]\n    print(f\"[{','.join(map(lambda x: str(x).lower(), results))}]\")\n\nsolve()\n```"
        }
    ]
}