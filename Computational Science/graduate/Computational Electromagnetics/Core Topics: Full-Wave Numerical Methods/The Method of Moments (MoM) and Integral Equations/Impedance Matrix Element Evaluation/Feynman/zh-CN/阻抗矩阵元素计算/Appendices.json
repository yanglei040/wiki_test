{
    "hands_on_practices": [
        {
            "introduction": "在矩量法中，电场积分方程（EFIE）的阻抗矩阵元素包含奇异项，特别是在基函数共享公共边时，这些奇异性使得数值积分变得非常棘手。此练习将引导您通过理论推导，将一个关键的奇异面积分贡献转化为等效的边界线积分，从而更精确地处理这种奇异性。通过解析计算这个简化的对数核积分 ，您将对EFIE的数学结构及其奇异性的物理来源有更深刻的认识。",
            "id": "3317613",
            "problem": "考虑用于理想电导体散射体的矩量法 (MoM) 中的电场积分方程 (EFIE)，该散射体通过三角形表面贴片上的 Rao–Wilton–Glisson (RWG) 基函数进行离散。EFIE 阻抗矩阵元 $Z_{mn}$ 包含一个由表面散度相互作用形成的标量势贡献。重点关注两个 RWG 基函数 $\\mathbf{f}_{m}$ 和 $\\mathbf{f}_{n}$ 之间的配对相互作用，这两个函数都支集在共享一条长度为 $\\ell$ 的笔直公共边 $e$ 的同一共面三角形对 $T^{+}$ 和 $T^{-}$ 上。在一个局部坐标系中，令 $s$ 表示沿边 $e$ 的弧长，令 $t$ 表示在 $T^{+}$ 或 $T^{-}$ 内垂直于该边的距离。当 $T^{+}$ 和 $T^{-}$ 沿着 $e$ 接触时，表面散度项包含了导致近边贡献的奇异行为。\n\n从 EFIE 阻抗矩阵元的标量势部分出发，对源贴片使用表面散度定理（曲面积分的分部积分法），将源端面积分转换为沿 $\\partial T^{+} \\cup \\partial T^{-}$ 的边界线积分。利用 RWG 基函数在内部的连续性及其分段线性结构，论证对于接触对，唯一保留下来的边界贡献产生于共享边 $e$。在 $e$ 的紧邻区域内，根据准静态近似，将简化的边-边核函数建模为二维拉普拉斯格林函数 $G_{\\text{2D}}(s,s') = -\\frac{1}{2\\pi} \\ln|s - s'|$，该函数捕获了在沿进入 $T^{+}$ 和 $T^{-}$ 的微小法向距离 $t$ 积分后发生的局部余维-1简化。假设 RWG 基函数沿 $e$ 的迹具有单位归一化的边权重，从而使得边贡献与一个纯几何的双重线积分成正比。定义\n$$\nJ(\\ell) \\equiv \\int_{0}^{\\ell} \\int_{0}^{\\ell} \\ln|s - s'| \\, ds \\, ds'.\n$$\n通过曲面分部积分推导出这个等效的边线积分，然后求出 $J(\\ell)$ 的闭合形式解。你的最终答案必须是 $J(\\ell)$ 的单一解析表达式。",
            "solution": "### 概念推导\n阻抗矩阵元 $Z_{mn}$ 的标量势部分源于电荷密度之间的相互作用。对于共享公共边 $e$ 的两个共面 RWG 基函数 $\\mathbf{f}_m$ 和 $\\mathbf{f}_n$ 的自相互作用（即 $m=n$），相关的电荷密度 $\\rho_n \\propto \\nabla_S \\cdot \\mathbf{f}_n$ 在两个三角形 $T^+$ 和 $T^-$ 上是分段常数，且符号相反。这种沿边 $e$ 的电荷不连续性形成了一个电偶极子层，其相互作用在边附近表现出奇异性。\n\n通过应用基于格林恒等式的变换（问题中概括为“表面散度定理”），可以将由面电荷产生的势的面积分转换为沿其边界的线积分。对于自作用项，奇异性主要由沿公共边 $e$ 的相互作用决定。\n\n在准静态和近场近似下，三维格林函数核 $1/R$ 的相互作用可以被有效地简化为一个二维对数核 $-\\frac{1}{2\\pi}\\ln|s-s'|$，其中 $s$ 和 $s'$ 是沿边 $e$ 的坐标。假设沿边的基函数迹（边权重）为单位归一化，标量势奇异贡献的主要部分与双重线积分 $J(\\ell)$ 成正比。\n\n### 积分计算\n我们需要计算积分：\n$$J(\\ell) = \\int_{0}^{\\ell} \\int_{0}^{\\ell} \\ln|s - s'| \\, ds \\, ds'$$\n首先，计算关于 $s$ 的内层积分 $I(s') = \\int_{0}^{\\ell} \\ln|s - s'| \\, ds$。为了处理绝对值，我们在 $s=s'$ 处拆分积分：\n$$I(s') = \\int_{0}^{s'} \\ln(s' - s) \\, ds + \\int_{s'}^{\\ell} \\ln(s - s') \\, ds$$\n利用积分公式 $\\int \\ln(x) dx = x \\ln(x) - x$，我们得到：\n$\\int_{0}^{s'} \\ln(s' - s) \\, ds = \\int_{0}^{s'} \\ln(u) \\, du = [u \\ln(u) - u]_0^{s'} = s' \\ln(s') - s'$\n$\\int_{s'}^{\\ell} \\ln(s - s') \\, ds = \\int_{0}^{\\ell-s'} \\ln(v) \\, dv = [v \\ln(v) - v]_0^{\\ell-s'} = (\\ell-s') \\ln(\\ell-s') - (\\ell-s')$\n因此，内层积分为：\n$$I(s') = s' \\ln(s') - s' + (\\ell-s') \\ln(\\ell-s') - (\\ell-s') = s' \\ln(s') + (\\ell-s') \\ln(\\ell-s') - \\ell$$\n接下来，我们计算关于 $s'$ 的外层积分：\n$$J(\\ell) = \\int_{0}^{\\ell} I(s') \\, ds' = \\int_{0}^{\\ell} [s' \\ln(s') + (\\ell-s') \\ln(\\ell-s') - \\ell] \\, ds'$$\n$$J(\\ell) = \\int_{0}^{\\ell} s' \\ln(s') \\, ds' + \\int_{0}^{\\ell} (\\ell-s') \\ln(\\ell-s') \\, ds' - \\int_{0}^{\\ell} \\ell \\, ds'$$\n利用分部积分法，我们知道 $\\int x \\ln(x) dx = \\frac{x^2}{2} \\ln(x) - \\frac{x^2}{4}$。因此：\n$\\int_{0}^{\\ell} s' \\ln(s') \\, ds' = \\left[\\frac{(s')^2}{2} \\ln(s') - \\frac{(s')^2}{4}\\right]_0^\\ell = \\frac{\\ell^2}{2} \\ln(\\ell) - \\frac{\\ell^2}{4}$\n第二个积分通过变量替换 $u = \\ell-s'$ 可知与第一个积分相等。第三个积分是 $-\\ell^2$。\n将所有部分相加：\n$$J(\\ell) = \\left(\\frac{\\ell^2}{2} \\ln(\\ell) - \\frac{\\ell^2}{4}\\right) + \\left(\\frac{\\ell^2}{2} \\ln(\\ell) - \\frac{\\ell^2}{4}\\right) - \\ell^2$$\n$$J(\\ell) = \\ell^2 \\ln(\\ell) - \\frac{\\ell^2}{2} - \\ell^2 = \\ell^2 \\ln(\\ell) - \\frac{3}{2} \\ell^2$$\n最终得到闭合形式解。",
            "answer": "$$\n\\boxed{\\ell^{2} \\left(\\ln(\\ell) - \\frac{3}{2}\\right)}\n$$"
        },
        {
            "introduction": "在解析地理解了积分方程中的奇异性挑战之后，下一步是构建一个数值求解器。本练习将从最基本的一维问题——细导线——入手，指导您将理论转化为具体的代码实现。您将使用数值积分方法计算细导线的阻抗矩阵元素，这不仅是矩量法编程的经典入门实践 ，也强化了从连续的积分方程到离散的矩阵系统之间的核心联系。",
            "id": "3317567",
            "problem": "考虑一根与自由空间中$x$轴对齐、半径为$a$的有限长理想电导细直导线。在使用矩量法（MoM）求解的电场积分方程（EFIE）中，采用脉冲（分段常数）基函数和伽辽金测试法来构建阻抗矩阵。本题仅关注磁矢量势对EFIE算子的贡献，并忽略标量势项。\n\n从第一性原理出发，利用麦克斯韦方程组和自由空间标量格林函数，推导并计算在线段$\\Gamma_m = [x_m^{(1)}, x_m^{(2)}]$和$\\Gamma_n = [x_n^{(1)}, x_n^{(2)}]$上支撑的两个脉冲基函数之间的伽辽金阻抗矩阵元的磁矢量势贡献。假设导线的有限半径通过将欧几里得距离替换为$R(x,x') = \\sqrt{(x - x')^2 + a^2}$来正则化轴上奇异性。自由空间标量格林函数为$G(R) = \\dfrac{e^{-j k R}}{4\\pi R}$，其中$k = \\omega \\sqrt{\\mu_0 \\epsilon_0}$，$\\omega = 2\\pi f$，$\\mu_0$是真空磁导率，$\\epsilon_0$是真空介电常数。磁矢量势部分的伽辽金阻抗矩阵元为\n$$\nZ_{mn}^{(A)} = j \\,\\omega \\,\\mu_0 \\int_{\\Gamma_m} \\int_{\\Gamma_n} G\\!\\left(R(x,x')\\right)\\, \\mathrm{d}x' \\,\\mathrm{d}x.\n$$\n所有长度单位均须为米，频率单位为赫兹，输出阻抗值的单位为欧姆。\n\n您的任务是实现一个完整的、自包含的程序，该程序针对指定的测试套件，使用高阶张量积高斯求积法在两个线段上数值计算$Z_{mn}^{(A)}$的实部，并采用给定的正则化$R(x,x') = \\sqrt{(x-x')^2 + a^2}$。数值积分必须直接在二重积分上执行，不得进行解析简化。程序设计应能通过适当选择足够高的求积阶数来稳健地处理近奇异配置（例如，重叠或相邻的段）。\n\n使用以下物理常数：$\\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{H/m}$ 和 $\\epsilon_0 = 8.854187817 \\times 10^{-12}\\,\\mathrm{F/m}$。对于每个测试用例，波数为$k = \\omega \\sqrt{\\mu_0 \\epsilon_0}$，其中$\\omega = 2\\pi f$。虚数单位为$j = \\sqrt{-1}$。\n\n实现程序以处理以下测试套件。每个测试用例是一个元组$(f, a, x_m^{(1)}, x_m^{(2)}, x_n^{(1)}, x_n^{(2)})$：\n- 测试 1（自作用项，中等频率，中等半径）：$(300\\times 10^6,\\; 1\\times 10^{-3},\\; -0.025,\\; 0.025,\\; -0.025,\\; 0.025)$\n- 测试 2（带有小间隙的相邻段）：$(300\\times 10^6,\\; 1\\times 10^{-3},\\; -0.05,\\; 0.0,\\; 0.001,\\; 0.051)$\n- 测试 3（远距离分离的段）：$(300\\times 10^6,\\; 1\\times 10^{-3},\\; -0.025,\\; 0.025,\\; 0.975,\\; 1.025)$\n- 测试 4（准静态区，较小半径）：$(1\\times 10^3,\\; 1\\times 10^{-4},\\; -0.025,\\; 0.025,\\; -0.025,\\; 0.025)$\n\n对于每个测试用例，计算$Z_{mn}^{(A)}$的实部，并以欧姆为单位表示。您的程序必须输出一行，包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含测试用例的结果，每个结果四舍五入到$6$位小数，例如$[z_1,z_2,z_3,z_4]$，其中每个$z_i$是测试$i$的$Z_{mn}^{(A)}$的实部（单位为欧姆）。\n\n您的解决方案必须仅依赖于对给定二重积分使用指定正则化的数值评估。该算法必须是通用的，适用于任何线段对和任何正频率。不要使用外部文件或用户输入。最终程序必须能够直接运行。",
            "solution": "用户提供的问题已经过分析和验证。它构成了一个计算电磁学领域中适定的、有科学依据的问题。所有必要的参数和定义都已提供，不存在不一致或模糊之处。因此，我们可以着手提供一个完整的解决方案。\n\n主要目标是计算阻抗矩阵元$Z_{mn}^{(A)}$的实部，该项源于用矩量法（MoM）求解细导线电场积分方程（EFIE）时磁矢量势的贡献。问题指定了使用脉冲基函数和伽辽金测试法。\n\n阻抗元的表达式为：\n$$\nZ_{mn}^{(A)} = j \\,\\omega \\,\\mu_0 \\int_{\\Gamma_m} \\int_{\\Gamma_n} G\\!\\left(R(x,x')\\right)\\, \\mathrm{d}x' \\,\\mathrm{d}x\n$$\n其中$j = \\sqrt{-1}$是虚数单位，$\\omega$是角频率，$\\mu_0$是真空磁导率。积分域是导线段$\\Gamma_m = [x_m^{(1)}, x_m^{(2)}]$和$\\Gamma_n = [x_n^{(1)}, x_n^{(2)}]$。\n\n积分核是自由空间标量格林函数$G(R) = \\frac{e^{-j k R}}{4\\pi R}$，在正则化距离$R(x,x') = \\sqrt{(x - x')^2 + a^2}$处求值。这里，$a$是导线半径，$k = \\omega/c_0$是自由空间波数，$c_0 = 1/\\sqrt{\\mu_0 \\epsilon_0}$是真空中的光速。\n\n为了求$Z_{mn}^{(A)}$的实部，我们首先代入格林函数并使用欧拉公式$e^{-j\\theta} = \\cos(\\theta) - j\\sin(\\theta)$：\n$$\nG(R) = \\frac{\\cos(k R) - j \\sin(k R)}{4\\pi R}\n$$\n该二重积分可以分解为其实部和虚部：\n$$\nI_{mn} = \\int_{\\Gamma_m} \\int_{\\Gamma_n} G(R) \\, \\mathrm{d}x' \\, \\mathrm{d}x = \\int_{\\Gamma_m} \\int_{\\Gamma_n} \\frac{\\cos(kR)}{4\\pi R} \\, \\mathrm{d}x' \\, \\mathrm{d}x - j \\int_{\\Gamma_m} \\int_{\\Gamma_n} \\frac{\\sin(kR)}{4\\pi R} \\, \\mathrm{d}x' \\, \\mathrm{d}x\n$$\n设该积分的实部为$I_{Re}$，虚部为$I_{Im}$。则$I_{mn} = I_{Re} + j I_{Im}$，其中$I_{Im} = - \\int_{\\Gamma_m} \\int_{\\Gamma_n} \\frac{\\sin(kR)}{4\\pi R} \\, \\mathrm{d}x' \\, \\mathrm{d}x$。\n\n将此代回$Z_{mn}^{(A)}$的表达式中：\n$$\nZ_{mn}^{(A)} = j \\,\\omega \\,\\mu_0 (I_{Re} + j I_{Im}) = j\\,\\omega\\,\\mu_0 I_{Re} + j^2\\,\\omega\\,\\mu_0 I_{Im} = -\\omega\\,\\mu_0 I_{Im} + j\\,\\omega\\,\\mu_0 I_{Re}\n$$\n因此，$Z_{mn}^{(A)}$的实部为：\n$$\n\\mathrm{Re}\\{Z_{mn}^{(A)}\\} = -\\omega\\,\\mu_0 I_{Im} = -\\omega\\,\\mu_0 \\left( - \\int_{\\Gamma_m} \\int_{\\Gamma_n} \\frac{\\sin(kR)}{4\\pi R} \\, \\mathrm{d}x' \\, \\mathrm{d}x \\right)\n$$\n$$\n\\mathrm{Re}\\{Z_{mn}^{(A)}\\} = \\frac{\\omega \\mu_0}{4\\pi} \\int_{x_m^{(1)}}^{x_m^{(2)}} \\int_{x_n^{(1)}}^{x_n^{(2)}} \\frac{\\sin(k \\sqrt{(x-x')^2 + a^2})}{\\sqrt{(x-x')^2 + a^2}} \\, \\mathrm{d}x' \\, \\mathrm{d}x\n$$\n这就是最终需要进行数值计算的积分。被积函数是一个标度的sinc函数$\\mathrm{sinc}(kR) = \\sin(kR)/(kR)$，其性质良好。使用半径$a > 0$的正则化确保了分母$R$永远不为零，从而防止了奇异性的出现。\n\n问题要求使用张量积高斯求积法进行数值计算。该方法将标准区间$[-1, 1]$上的定积分近似为一个加权和：\n$$\n\\int_{-1}^{1} f(u) \\, \\mathrm{d}u \\approx \\sum_{i=1}^{N} w_i f(u_i)\n$$\n其中$u_i$是求积节点（$N$阶勒让德多项式的根），$w_i$是相应的权重。为了将其应用于我们的任意积分区间，我们对每个积分执行线性变量替换。\n\n对于$x \\in [x_m^{(1)}, x_m^{(2)}]$上的外层积分：令$x = x_m^{(c)} + u h_m$，其中$x_m^{(c)} = \\frac{x_m^{(1)} + x_m^{(2)}}{2}$是区间$\\Gamma_m$的中心，$h_m = \\frac{x_m^{(2)} - x_m^{(1)}}{2}$是其半宽。则$\\mathrm{d}x = h_m \\mathrm{d}u$，其中$u \\in [-1,1]$。\n\n对于$x' \\in [x_n^{(1)}, x_n^{(2)}]$上的内层积分：类似地，令$x' = x_n^{(c)} + v h_n$，其中$x_n^{(c)} = \\frac{x_n^{(1)} + x_n^{(2)}}{2}$，$h_n = \\frac{x_n^{(2)} - x_n^{(1)}}{2}$。则$\\mathrm{d}x' = h_n \\mathrm{d}v$，其中$v \\in [-1,1]$。\n\n二重积分变换为：\n$$\n\\mathrm{Re}\\{Z_{mn}^{(A)}\\} = \\frac{\\omega \\mu_0 h_m h_n}{4\\pi} \\int_{-1}^{1} \\int_{-1}^{1} \\frac{\\sin(k R(u,v))}{R(u,v)} \\, \\mathrm{d}v \\, \\mathrm{d}u\n$$\n其中$R(u,v) = \\sqrt{((x_m^{(c)} + u h_m) - (x_n^{(c)} + v h_n))^2 + a^2}$。\n\n对每个维度应用具有$N$个点的张量积高斯求积法则，我们得到数值近似：\n$$\n\\mathrm{Re}\\{Z_{mn}^{(A)}\\} \\approx \\frac{\\omega \\mu_0 h_m h_n}{4\\pi} \\sum_{i=1}^{N} \\sum_{j=1}^{N} w_i w_j \\frac{\\sin(k R_{ij})}{R_{ij}}\n$$\n其中$u_i$和$v_j$是求积节点，$w_i$和$w_j$是权重，$R_{ij}$是距离$R(u_i,v_j)$。对于伽辽金测试法，基函数和测试函数的域通常是相同的，但该公式是通用的。\n\n选择一个高的求积阶数$N$以确保精度，特别是对于自相互作用项（其中$\\Gamma_m = \\Gamma_n$）或相邻段，因为此时被积函数在$x=x'$附近变得更加尖锐。对于指定的测试用例，$N=96$是一个稳健的取值。\n\n实现将定义一个函数来执行此计算。物理常数$\\mu_0$和$\\epsilon_0$用于计算$c_0$和$k$。对于每个测试用例，参数$(f, a, x_m^{(1)}, x_m^{(2)}, x_n^{(1)}, x_n^{(2)})$被传递给此函数。最终结果被收集、格式化为6位小数并打印出来。为了数值稳定性，建议使用`numpy.sinc`，注意其定义要求将参数按$\\pi$进行缩放。表达式$\\sin(y)/y$等效于`numpy.sinc(y/numpy.pi)`。因此，被积函数可以写为$k \\times \\mathrm{numpy.sinc}(kR/\\pi)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Solves the problem by numerically evaluating the impedance matrix elements\n    for the provided test cases.\n    \"\"\"\n\n    # Physical constants as specified in the problem\n    MU_0 = 4 * np.pi * 1e-7\n    EPSILON_0 = 8.854187817e-12\n    C_0 = 1 / np.sqrt(MU_0 * EPSILON_0)\n\n    def evaluate_z_mn_a_real(f, a, xm1, xm2, xn1, xn2, n_quad):\n        \"\"\"\n        Calculates the real part of Z_mn^(A) using tensor-product Gaussian quadrature.\n        \n        Args:\n            f (float): Frequency in Hertz.\n            a (float): Wire radius in meters.\n            xm1 (float): Start of segment m in meters.\n            xm2 (float): End of segment m in meters.\n            xn1 (float): Start of segment n in meters.\n            xn2 (float): End of segment n in meters.\n            n_quad (int): Order of Gaussian quadrature.\n            \n        Returns:\n            float: The real part of the impedance element Z_mn^(A) in Ohms.\n        \"\"\"\n        omega = 2 * np.pi * f\n        k = omega / C_0\n\n        # Get Gauss-Legendre nodes and weights for the interval [-1, 1]\n        nodes, weights = roots_legendre(n_quad)\n\n        # Calculate interval centers and half-widths for the change of variables\n        xm_c = (xm1 + xm2) / 2.0\n        hm = (xm2 - xm1) / 2.0\n        xn_c = (xn1 + xn2) / 2.0\n        hn = (xn2 - xn1) / 2.0\n\n        # Handle zero-length segments\n        if hm == 0 or hn == 0:\n            return 0.0\n\n        # Map nodes from [-1, 1] to the physical segment intervals [xm1, xm2] and [xn1, xn2]\n        x_nodes = xm_c + nodes * hm\n        xp_nodes = xn_c + nodes * hn\n\n        # Perform 2D numerical integration using the tensor-product rule\n        integral_sum = 0.0\n        for i in range(n_quad):\n            for j in range(n_quad):\n                x = x_nodes[i]\n                xp = xp_nodes[j]\n                wi = weights[i]\n                wj = weights[j]\n\n                # Calculate the regularized distance R(x, x')\n                dx_sq = (x - xp)**2\n                R = np.sqrt(dx_sq + a**2)\n                \n                # Evaluate the integrand sin(k*R)/R.\n                # This formulation is numerically stable for small R because a > 0.\n                # For enhanced stability, one could use k * np.sinc(k * R / np.pi)\n                # but direct division is fine here since R is never zero.\n                if R == 0.0:\n                    # This case does not occur since a > 0, but as a safeguard.\n                    # The limit of sin(k*R)/R as R->0 is k.\n                    integrand = k\n                else:\n                    integrand = np.sin(k * R) / R\n\n                integral_sum += wi * wj * integrand\n\n        # Combine terms to get the final result\n        prefactor = (omega * MU_0) / (4 * np.pi)\n        result = prefactor * hm * hn * integral_sum\n        return result\n\n    # The test suite provided in the problem statement\n    test_cases = [\n        # (f, a, x_m^(1), x_m^(2), x_n^(1), x_n^(2))\n        (300e6, 1e-3, -0.025, 0.025, -0.025, 0.025),\n        (300e6, 1e-3, -0.05, 0.0, 0.001, 0.051),\n        (300e6, 1e-3, -0.025, 0.025, 0.975, 1.025),\n        (1e3, 1e-4, -0.025, 0.025, -0.025, 0.025),\n    ]\n\n    # A high quadrature order is chosen for accuracy, especially for self-terms\n    # and near-singular configurations.\n    N_QUAD = 96\n    \n    results = []\n    for case in test_cases:\n        z_real = evaluate_z_mn_a_real(*case, n_quad=N_QUAD)\n        results.append(f\"{z_real:.6f}\")\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "直接的矩量法由于其 $O(M^2)$ 的内存和计算复杂度，在求解大规模问题时并不可行。为了克服这一瓶颈，必须采用更先进的快速算法。本练习将向您介绍分层矩阵（Hierarchical Matrix, $\\mathcal{H}$-matrix）的核心思想，它利用了远场相互作用可以被低秩矩阵有效近似的特性。您将通过实践  学习如何判断矩阵块的可容许性、计算远场块的数值秩，并估算由此带来的计算加速效果，从而初步掌握解决大规模积分方程问题的关键技术。",
            "id": "3317604",
            "problem": "你需要推导并实现一个程序，为时谐激励下的细直导线的一维离散化所关联的阻抗矩阵构建和分析其分层矩阵表示。阻抗矩阵的元素源于亥姆霍兹方程的自由空间标量格林函数的二重积分。从基本的电磁定律和定义出发，并使用 LaTeX 表达所有数学量。然后，实现一个对容许的远场块使用低秩近似的分层矩阵。最后，预测并测量这些块的数值秩，并估计其对组装时间的影响。\n\n从频率域中无源均匀介质的宏观麦克斯韦方程组开始，其角频率为 $\\omega$，介电常数为 $\\epsilon$，磁导率为 $\\mu$。对于具有 $\\mathrm{e}^{\\mathrm{j} \\omega t}$ 约定的时谐场，电场 $\\mathbf{E}$ 满足矢量亥姆霍兹方程。亥姆霍兹方程的标量自由空间格林函数 $G(\\mathbf{r},\\mathbf{r}')$ 满足\n$$\n\\left(\\nabla^2 + k^2\\right) G(\\mathbf{r},\\mathbf{r}') = -\\delta(\\mathbf{r}-\\mathbf{r}'),\n$$\n其中 $k = \\omega \\sqrt{\\mu \\epsilon}$ 是波数。在三维空间中，\n$$\nG(\\mathbf{r},\\mathbf{r}') = \\frac{\\mathrm{e}^{\\mathrm{j} k \\|\\mathbf{r}-\\mathbf{r}'\\|}}{4 \\pi \\|\\mathbf{r}-\\mathbf{r}'\\|}.\n$$\n\n考虑一根与 $x$ 轴对齐的细直导线，占据区间 $[0,L]$，其中 $L$ 是总长度。将 $[0,L]$ 离散化为 $M$ 个长度为 $h = L/M$ 的均匀段（面板），索引为 $i = 0,1,\\dots,M-1$。使用在第 $i$ 个面板上支撑的分段常数基函数 $\\phi_i(x)$：\n$$\n\\phi_i(x) = \\begin{cases}\n1  \\text{若 } x \\in [i h, (i+1) h],\\\\\n0  \\text{其他情况}。\n\\end{cases}\n$$\n定义阻抗矩阵 $Z \\in \\mathbb{C}^{M \\times M}$，其元素为\n$$\nZ_{ij} = \\int_{i h}^{(i+1) h} \\int_{j h}^{(j+1) h} \\frac{\\mathrm{e}^{\\mathrm{j} k |x - x'|}}{4 \\pi |x - x'|} \\,\\mathrm{d}x' \\,\\mathrm{d}x,\n$$\n其中距离近似为沿直线的 $|x-x'|$。当 $i=j$ 时，被积函数在 $x=x'$ 处有一个弱奇异点，必须以稳定的方式进行数值处理。\n\n将索引集 $\\{0,1,\\dots,M-1\\}$ 划分为连续的簇，并构建一个块簇树。对于由一对索引集为 $I_A$ 和 $I_B$ 的簇 $A$ 和 $B$ 定义的任何块，定义簇的直径\n$$\n\\operatorname{diam}(A) = \\max_{i \\in I_A} (i+1)h - \\min_{i \\in I_A} i h = |I_A| h,\n$$\n对于 $B$ 也类似。设分离距离为 $A$ 和 $B$ 的支撑区间之间的最小间隙，\n$$\n\\operatorname{sep}(A,B) = \\max\\bigl(0, \\max(\\min_{j \\in I_B} j h - \\max_{i \\in I_A} (i+1) h,\\; \\min_{i \\in I_A} i h - \\max_{j \\in I_B} (j+1) h)\\bigr),\n$$\n如果区间重叠或接触，则该值为零。采用带参数 $\\eta > 0$ 的容许性条件：\n$$\n\\operatorname{sep}(A,B) \\ge \\eta \\max\\left(\\operatorname{diam}(A), \\operatorname{diam}(B)\\right).\n$$\n对于容许块，通过截断块子矩阵的奇异值分解（SVD）来使用低秩近似，使其秩满足在弗罗贝尼乌斯范数下的预定相对误差容限 $\\varepsilon$。对于非容许块，使用完整的稠密表示。\n\n对于容许的块，格林函数核在 $A \\times B$ 上是光滑的，允许通过分离的低秩展开进行近似。提供一个理论上合理的秩 $r_{\\mathrm{pred}}$ 的估计，该估计以波数 $k$、簇直径和分离距离表示。使用一个简单的预测器形式\n$$\nr_{\\mathrm{pred}} = \\left\\lceil \\alpha \\frac{k \\, a}{\\xi} + \\beta \\log \\frac{1}{\\varepsilon} \\right\\rceil,\n$$\n其中 $a = \\max\\bigl(\\operatorname{diam}(A),\\operatorname{diam}(B)\\bigr)$ 是特征尺寸，$\\xi = \\operatorname{sep}(A,B)/a$ 是归一化分离度，$\\alpha$ 和 $\\beta$ 是概括解析近似性质的量级为1的正实数。将 $r_{\\mathrm{pred}}$ 的值限定在不小于 $1$ 且不大于 $\\min(|I_A|,|I_B|)$ 的范围内，对于非容许块，设置 $r_{\\mathrm{pred}} = \\min(|I_A|,|I_B|)$。\n\n在数值上，使用高斯-勒让德求积法，在每个面板的两个积分上都使用 $Q$ 个节点来近似 $Z_{ij}$ 的二重积分。使用每个面板上的求积节点和权重来构建块矩阵的元素。为了处理 $i=j$ 时的弱奇异性，采用一种正则化方法，例如用 $\\max(|x-x'|, \\delta)$ 替换 $|x-x'|$，其中 $\\delta$ 是一个与网格尺寸 $h$ 成比例的小量。\n\n为块定义一个组装时间代理（操作计数）：\n- 对于一个大小为 $|I_A| \\times |I_B|$ 的稠密块，在每个积分中使用 $Q$ 个求积点，设置\n$$\n\\mathrm{ops}_{\\mathrm{dense}} = |I_A| \\, |I_B| \\, Q^2.\n$$\n- 对于一个用数值秩 $r_{\\mathrm{num}}$ 表示的容许块，通过以下方式近似分层组装成本\n$$\n\\mathrm{ops}_{\\mathcal{H}} = r_{\\mathrm{num}} \\, (|I_A| + |I_B|) \\, Q + r_{\\mathrm{num}}^2,\n$$\n对于非容许块，使用 $\\mathrm{ops}_{\\mathcal{H}} = \\mathrm{ops}_{\\mathrm{dense}}$。\n\n计算加速比代理\n$$\nS = \\frac{\\mathrm{ops}_{\\mathrm{dense}}}{\\mathrm{ops}_{\\mathcal{H}}}.\n$$\n\n实现一个程序，对于下面描述的每个测试用例，构建块子矩阵 $(A,B)$，计算截断的SVD以确定满足容限 $\\varepsilon$ 的 $r_{\\mathrm{num}}$，评估截断实现的实际相对弗罗贝尼乌斯误差，计算 $r_{\\mathrm{pred}}$，并计算 $\\mathrm{ops}_{\\mathrm{dense}}$、$\\mathrm{ops}_{\\mathcal{H}}$ 和 $S$。\n\n所有距离必须以米为单位表示，波数 $k$ 必须以弧度/米为单位表示，所有报告的浮点数量必须以十进制形式表示。此公式中不出现角度。除了指定的输入参数外，最终输出是无单位的。\n\n使用以下测试套件以确保覆盖范围：\n- 在所有情况下使用 $L = 1\\,\\mathrm{m}$，$M = 64$，$Q = 8$，$\\eta = 1$，以及正则化 $\\delta = 10^{-6} h$，其中 $h = L/M$。\n- 簇索引是由起始索引 $s$ 和大小 $n$ 指定的连续范围 $\\{s, s+1, \\dots, s+n-1\\}$。\n\n测试用例：\n1. 用例 1：$k = 20\\,\\mathrm{rad/m}$，$\\varepsilon = 10^{-4}$，簇 $A$：$s_A = 0$, $n_A = 8$，簇 $B$：$s_B = 24$, $n_B = 8$。\n2. 用例 2：$k = 5\\,\\mathrm{rad/m}$，$\\varepsilon = 10^{-6}$，簇 $A$：$s_A = 0$, $n_A = 8$，簇 $B$：$s_B = 56$, $n_B = 8$。\n3. 用例 3：$k = 40\\,\\mathrm{rad/m}$，$\\varepsilon = 10^{-4}$，簇 $A$：$s_A = 16$, $n_A = 8$，簇 $B$：$s_B = 24$, $n_B = 8$。\n4. 用例 4：$k = 20\\,\\mathrm{rad/m}$，$\\varepsilon = 10^{-5}$，簇 $A$：$s_A = 8$, $n_A = 8$，簇 $B$：$s_B = 8$, $n_B = 8$。\n5. 用例 5：$k = 80\\,\\mathrm{rad/m}$，$\\varepsilon = 10^{-4}$，簇 $A$：$s_A = 0$, $n_A = 16$，簇 $B$：$s_B = 32$, $n_B = 16$。\n\n对于每个测试用例，输出一个列表，包含\n$$\n\\bigl[r_{\\mathrm{pred}},\\; r_{\\mathrm{num}},\\; E_{\\mathrm{rel}},\\; \\mathrm{ops}_{\\mathrm{dense}},\\; \\mathrm{ops}_{\\mathcal{H}},\\; S\\bigr],\n$$\n其中 $E_{\\mathrm{rel}}$ 是截断SVD实现的相对弗罗贝尼乌斯误差。\n\n您的程序应生成单行输出，包含这些列表的逗号分隔列表，并用方括号括起来，不含空格，例如，\n$$\n[\\,[1,2,0.001,64,32,2.0],[\\dots]\\,].\n$$",
            "solution": "该问题要求推导并实现一种方法，用于分析由一维细导线天线的积分方程离散化所产生的阻抗矩阵 $Z$ 的分层矩阵结构。该分析涉及构建矩阵的特定块，确定它们对于低秩近似的容许性，计算其数值秩，并将其与理论预测进行比较。最后，估计使用分层表示所带来的计算节省。\n\n### 理论公式\n\n物理问题涉及从细直导线进行的简谐电磁散射。对于时谐依赖关系 $\\mathrm{e}^{\\mathrm{j} \\omega t}$，在由介电常数 $\\epsilon$ 和磁导率 $\\mu$ 表征的无源均匀介质中，电场 $\\mathbf{E}$ 满足矢量亥姆霍兹方程：\n$$\n\\nabla \\times \\nabla \\times \\mathbf{E} - k^2 \\mathbf{E} = \\mathbf{0},\n$$\n其中 $k = \\omega \\sqrt{\\mu \\epsilon}$ 是波数。这可以通过积分方程公式求解。电场与标量势 $\\Phi$ 和矢量势 $\\mathbf{A}$ 的关系为 $\\mathbf{E} = -\\mathrm{j}\\omega\\mathbf{A} - \\nabla\\Phi$。两种势都可以表示为源（电流 $\\mathbf{J}$ 和电荷 $\\rho$）与自由空间格林函数 $G(\\mathbf{r},\\mathbf{r}')$ 的卷积，后者是以下方程的解：\n$$\n(\\nabla^2 + k^2) G(\\mathbf{r},\\mathbf{r}') = -\\delta(\\mathbf{r}-\\mathbf{r}').\n$$\n在三维空间中，该格林函数由下式给出：\n$$\nG(\\mathbf{r},\\mathbf{r}') = \\frac{\\mathrm{e}^{\\mathrm{j} k \\|\\mathbf{r}-\\mathbf{r}'\\|}}{4 \\pi \\|\\mathbf{r}-\\mathbf{r}'\\|}.\n$$\n该问题考虑了一个沿 $x$ 轴从 $x=0$ 到 $x=L$ 的简化一维导体。两点 $\\mathbf{r}=(x,0,0)$ 和 $\\mathbf{r}'=(x',0,0)$ 之间的距离近似为 $\\|\\mathbf{r}-\\mathbf{r}'\\| \\approx |x-x'|$。问题使用矩量法 (MoM) 来离散化控制积分方程。导体被分为 $M$ 个长度为 $h = L/M$ 的段。未知电流分布在一组分段常数函数 $\\phi_i(x)$ 的基中展开：\n$$\n\\phi_i(x) = \\begin{cases}\n1  \\text{若 } x \\in [i h, (i+1) h] \\\\\n0  \\text{其他情况}。\n\\end{cases}\n$$\n应用伽辽金法，其中测试函数与基函数相同，得到一个稠密线性系统 $Z I = V$，其中 $I$ 是未知电流系数的向量，$Z$ 是阻抗矩阵。元素 $Z_{ij}$ 表示段 $i$ 和段 $j$ 之间的互阻抗。它通过对相应基函数的支撑域进行二重积分计算得出：\n$$\nZ_{ij} = \\int_{\\mathbb{R}} \\int_{\\mathbb{R}} \\phi_i(x) G(x,x') \\phi_j(x') \\,\\mathrm{d}x' \\,\\mathrm{d}x = \\int_{i h}^{(i+1) h} \\int_{j h}^{(j+1) h} \\frac{\\mathrm{e}^{\\mathrm{j} k |x - x'|}}{4 \\pi |x - x'|} \\,\\mathrm{d}x' \\,\\mathrm{d}x.\n$$\n\n### 数值离散化与奇异性处理\n\n$Z_{ij}$ 的二重积分使用高斯-勒让德求积法进行数值计算。对于每个面板，使用 $Q$ 个求积节点。设 $\\{\\xi_p, w_p\\}_{p=1}^Q$ 是区间 $[-1, 1]$ 上的标准高斯-勒让德节点和权重。对面板 $i$ 和 $j$ 的积分进行变换：\n- 对于 $x \\in [ih, (i+1)h]$，我们使用映射 $x(\\xi) = (i+0.5)h + \\xi \\frac{h}{2}$，因此 $\\mathrm{d}x = \\frac{h}{2} \\mathrm{d}\\xi$。\n- 对于 $x' \\in [jh, (j+1)h]$，我们使用 $x'(\\xi') = (j+0.5)h + \\xi' \\frac{h}{2}$，因此 $\\mathrm{d}x' = \\frac{h}{2} \\mathrm{d}\\xi'$。\n\n积分变为：\n$$\nZ_{ij} \\approx \\frac{1}{4\\pi} \\left(\\frac{h}{2}\\right)^2 \\sum_{p=1}^Q \\sum_{q=1}^Q w_p w_q \\frac{\\mathrm{e}^{\\mathrm{j} k |x(\\xi_p) - x'(\\xi'_q)|}}{|x(\\xi_p) - x'(\\xi'_q)|}.\n$$\n当 $i=j$ 时，核 $1/|x-x'|$ 在 $x=x'$ 处有一个可积（弱）奇异点。标准求积法则可能会失效或不准确。问题指定了一种正则化技术：用 $\\max(|x-x'|, \\delta)$ 替换距离 $|x-x'|$，其中 $\\delta$ 是一个很小的参数。这消除了奇异点，从而允许稳定的数值积分。\n\n### 分层矩阵框架与容许性\n\n分层矩阵方法的核心是将稠密矩阵 $Z$ 分割成块，并用低秩表示来近似某些块。一个块子矩阵 $Z_{AB}$ 由两个索引簇 $A$ 和 $B$ 定义，它们的索引集分别为 $I_A$ 和 $I_B$。块的低秩可近似性取决于相应簇的几何分离。这通过容许性条件来形式化。\n\n首先，我们为簇定义几何属性：\n- **簇直径**：对于一个大小为 $|I_A|$ 的连续簇，$\\operatorname{diam}(A) = (\\max_{i \\in I_A} (i+1) - \\min_{i \\in I_A} i)h = |I_A|h$。\n- **分离距离**：$\\operatorname{sep}(A,B)$ 是对应于簇 $A$ 和 $B$ 的空间域之间的最小距离。对于分别从 $s_A$ 和 $s_B$ 开始、大小为 $n_A$ 和 $n_B$ 的连续簇，其域为 $[s_A h, (s_A+n_A)h]$ 和 $[s_B h, (s_B+n_B)h]$。分离距离为：\n$$\n\\operatorname{sep}(A,B) = h \\cdot \\max(0, s_B - (s_A+n_A), s_A - (s_B+n_B)).\n$$\n- **容许性条件**：如果一个块 $(A,B)$ 的簇相对于其大小是良好分离的，则该块被认为是容许的（或“远场”）。使用参数 $\\eta > 0$：\n$$\n\\operatorname{sep}(A,B) \\ge \\eta \\max(\\operatorname{diam}(A), \\operatorname{diam}(B)).\n$$\n如果此条件成立，则核函数 $G(x,x')$ 对于簇 $A$ 域中的 $x$ 和簇 $B$ 域中的 $x'$ 是光滑的，这允许对矩阵块 $Z_{AB}$ 进行有效的低秩近似。\n\n### 低秩近似与秩预测\n\n对于一个大小为 $n_A \\times n_B$ 的容许块 $Z_{AB}$，我们可以找到一个低秩近似。奇异值分解 (SVD)，$Z_{AB} = U \\Sigma V^H$，通过保留前 $r$ 个奇异值和奇异向量，提供了最优的秩-$r$ 近似。数值秩 $r_{\\mathrm{num}}$ 是满足给定相对误差容限 $\\varepsilon$（在弗罗贝尼乌斯范数下）的最小秩 $r$：\n$$\n\\frac{\\|Z_{AB} - Z_{AB}^{(r)}\\|_F}{\\|Z_{AB}\\|_F} = \\frac{\\sqrt{\\sum_{k=r+1}^{\\min(n_A,n_B)} \\sigma_k^2}}{\\sqrt{\\sum_{k=1}^{\\min(n_A,n_B)} \\sigma_k^2}} \\le \\varepsilon,\n$$\n其中 $Z_{AB}^{(r)}$ 是秩-$r$ 的截断SVD近似，$\\sigma_k$ 是奇异值。\n\n问题提供了一个秩的理论预测器：\n$$\nr_{\\mathrm{pred}} = \\left\\lceil \\alpha \\frac{k \\, a}{\\xi} + \\beta \\log \\frac{1}{\\varepsilon} \\right\\rceil,\n$$\n其中 $a = \\max(\\operatorname{diam}(A), \\operatorname{diam}(B))$ 且 $\\xi = \\operatorname{sep}(A,B)/a$。常数 $\\alpha$ 和 $\\beta$ 被说明为量级为1。基于此，我们选择 $\\alpha=1$ 和 $\\beta=1$，这是一个常见的简化。预测的秩被限制在至少为 $1$ 且至多为块的维度 $\\min(n_A, n_B)$。对于非容许块，预测为满秩：$r_{\\mathrm{pred}} = \\min(n_A, n_B)$。\n\n### 复杂度与加速估计\n\n分层矩阵方法的计算优势通过比较操作计数来估计。\n- **稠密组装**：构建一个 $n_A \\times n_B$ 的稠密块，每个维度使用 $Q$ 点求积，需要嵌套循环，导致计算成本代理为：\n$$\n\\mathrm{ops}_{\\mathrm{dense}} = n_A \\cdot n_B \\cdot Q^2.\n$$\n- **分层组装**：对于一个容许块，构造一个低秩表示。成本主要由形成低秩因子决定，由以下代理给出：\n$$\n\\mathrm{ops}_{\\mathcal{H}} = r_{\\mathrm{num}} (n_A + n_B) Q + r_{\\mathrm{num}}^2.\n$$\n对于非容许块，不进行近似，因此 $\\mathrm{ops}_{\\mathcal{H}} = \\mathrm{ops}_{\\mathrm{dense}}$。\n- **加速比代理**：估计的加速比是该比率：\n$$\nS = \\frac{\\mathrm{ops}_{\\mathrm{dense}}}{\\mathrm{ops}_{\\mathcal{H}}}.\n$$\n\n### 算法摘要\n对于每个测试用例，执行以下步骤：\n1. 解析用例参数：$k, \\varepsilon$, 和簇定义 ($s_A, n_A, s_B, n_B$)。\n2. 计算派生的几何参数：$\\operatorname{diam}(A)$, $\\operatorname{diam}(B)$, $\\operatorname{sep}(A,B)$, 和 $a$。\n3. 使用给定的条件和 $\\eta=1$ 来确定块 $(A,B)$ 是否容许。\n4. 使用指定的公式、我们选择的 $\\alpha=1, \\beta=1$ 以及对容许/非容许块的适当规则来计算预测秩 $r_{\\mathrm{pred}}$。\n5. 使用 $Q$ 点高斯-勒让德求积法组装稠密块矩阵 $Z_{AB} \\in \\mathbb{C}^{n_A \\times n_B}$，对全局矩阵 $Z$ 的对角线元素应用奇异性正则化。\n6. 计算 $Z_{AB}$ 的奇异值。\n7. 通过找到满足相对弗罗贝尼乌斯误差容限 $\\varepsilon$ 的最小秩来确定数值秩 $r_{\\mathrm{num}}$。\n8. 计算使用秩 $r_{\\mathrm{num}}$ 实现的实际相对误差 $E_{\\mathrm{rel}}$。\n9. 计算操作计数代理 $\\mathrm{ops}_{\\mathrm{dense}}$ 和 $\\mathrm{ops}_{\\mathcal{H}}$，以及加速比 $S$。\n10. 格式化并收集结果 $\\bigl[r_{\\mathrm{pred}},\\; r_{\\mathrm{num}},\\; E_{\\mathrm{rel}},\\; \\mathrm{ops}_{\\mathrm{dense}},\\; \\mathrm{ops}_{\\mathcal{H}},\\; S\\bigr]$。\n\n此过程应用于所有测试用例，以生成最终输出。",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\nfrom scipy.linalg import svdvals\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to execute the analysis for all test cases.\n    \"\"\"\n    \n    # Global parameters\n    L = 1.0  # m\n    M = 64\n    Q = 8\n    eta = 1.0\n    h = L / M\n    delta_reg = 1e-6 * h\n\n    # Quadrature nodes and weights on [-1, 1]\n    quad_nodes, quad_weights = leggauss(Q)\n\n    # Test cases\n    test_cases = [\n        # k, eps, (s_A, n_A), (s_B, n_B)\n        (20.0, 1e-4, (0, 8), (24, 8)),\n        (5.0, 1e-6, (0, 8), (56, 8)),\n        (40.0, 1e-4, (16, 8), (24, 8)),\n        (20.0, 1e-5, (8, 8), (8, 8)),\n        (80.0, 1e-4, (0, 16), (32, 16)),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        k, eps, cluster_A_def, cluster_B_def = case\n        s_A, n_A = cluster_A_def\n        s_B, n_B = cluster_B_def\n        \n        # 1. Calculate cluster properties\n        diam_A = n_A * h\n        diam_B = n_B * h\n        \n        # Separation distance\n        # Interval for A: [s_A*h, (s_A+n_A)*h]\n        # Interval for B: [s_B*h, (s_B+n_B)*h]\n        gap = max(0, s_B - (s_A + n_A), s_A - (s_B + n_B))\n        sep_AB = gap * h\n        \n        # Admissibility check\n        a = max(diam_A, diam_B)\n        is_admissible = sep_AB >= eta * a\n        \n        # 2. Calculate predicted rank\n        if is_admissible:\n            if sep_AB > 0:\n                xi = sep_AB / a\n                alpha = 1.0  # Assumed constant of order unity\n                beta = 1.0   # Assumed constant of order unity\n                r_pred_raw = alpha * (k * a / xi) + beta * math.log(1.0 / eps)\n                r_pred = math.ceil(r_pred_raw)\n                r_pred = max(1, min(r_pred, n_A, n_B))\n            else: # sep_AB is 0, so should not be admissible, but as a fallback\n                r_pred = min(n_A, n_B)\n        else:\n            r_pred = min(n_A, n_B)\n\n        # 3. Assemble the block matrix Z_AB\n        Z_AB = np.zeros((n_A, n_B), dtype=np.complex128)\n        \n        for i_idx in range(n_A):\n            for j_idx in range(n_B):\n                i_global = s_A + i_idx\n                j_global = s_B + j_idx\n                \n                # Map quadrature points to panels i_global and j_global\n                x_nodes = (i_global + 0.5) * h + quad_nodes * h / 2.0\n                xp_nodes = (j_global + 0.5) * h + quad_nodes * h / 2.0\n                \n                integral_val = 0.0j\n                for p in range(Q):\n                    for q in range(Q):\n                        x = x_nodes[p]\n                        xp = xp_nodes[q]\n                        dist = abs(x - xp)\n                        \n                        # Apply regularization for singular term\n                        if i_global == j_global:\n                            dist = max(dist, delta_reg)\n                        \n                        if dist > 0:\n                            kernel_val = np.exp(1j * k * dist) / (4 * np.pi * dist)\n                            integral_val += quad_weights[p] * quad_weights[q] * kernel_val\n                \n                Z_AB[i_idx, j_idx] = integral_val * (h / 2.0)**2\n\n        # 4. Compute SVD and numerical rank\n        s = svdvals(Z_AB)\n        s_sq_sorted = s**2\n        total_norm_sq = np.sum(s_sq_sorted)\n\n        r_num = min(n_A, n_B)\n        if total_norm_sq > 0:\n            trunc_err_sq = 0.0\n            found = False\n            for r in range(len(s) - 1, -1, -1):\n                trunc_err_sq += s_sq_sorted[r]\n                if np.sqrt(trunc_err_sq / total_norm_sq) > eps:\n                    r_num = r + 1\n                    found = True\n                    break\n            if not found: # All singular values can be truncated\n                r_num = 0\n\n        # 5. Calculate actual relative error for r_num\n        E_rel = 0.0\n        if total_norm_sq > 0:\n            err_sq_for_r_num = np.sum(s_sq_sorted[r_num:])\n            E_rel = np.sqrt(err_sq_for_r_num / total_norm_sq)\n        \n        # 6. Compute operation counts and speedup\n        ops_dense = n_A * n_B * (Q**2)\n        \n        if is_admissible:\n            ops_H = r_num * (n_A + n_B) * Q + r_num**2\n        else:\n            ops_H = ops_dense\n\n        # Prevent division by zero if ops_H is 0 (e.g., zero matrix, r_num=0)\n        speedup = ops_dense / ops_H if ops_H > 0 else float('inf')\n\n        # Convert to int where appropriate\n        r_pred = int(r_pred)\n        ops_dense = int(ops_dense)\n        ops_H = int(ops_H)\n        \n        results.append(f\"[{r_pred},{r_num},{E_rel:.6f},{ops_dense},{ops_H},{speedup:.6f}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}