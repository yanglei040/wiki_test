{
    "hands_on_practices": [
        {
            "introduction": "A deep understanding of computational electromagnetics begins with the analytical properties of the underlying integral operators. This first practice provides a foundational exercise in deriving the singular contribution of the Magnetic Field Integral Equation (MFIE) to the impedance matrix diagonal . By applying the jump conditions for boundary integral operators, you will analytically evaluate the local, non-integral term for a canonical Rao-Wilton-Glisson (RWG) basis function, gaining crucial insight into the structure of the Combined Field Integral Equation (CFIE).",
            "id": "3317565",
            "problem": "Consider a perfectly electrically conducting (PEC) smooth closed surface discretized by two identical equilateral planar triangles of side length $s$ that share a common edge. Use a single Rao–Wilton–Glisson (RWG) basis function $\\mathbf{f}$ supported on these two triangles and employ a Galerkin testing scheme with the same RWG function. Assume free-space with permittivity $\\varepsilon$, permeability $\\mu$, wavenumber $k$, and wave impedance $\\eta = \\sqrt{\\mu/\\varepsilon}$. The Combined Field Integral Equation (CFIE) is formed as a convex combination of the Electric Field Integral Equation (EFIE) and the Magnetic Field Integral Equation (MFIE) with parameter $\\alpha \\in (0,1)$, so that the CFIE operator is $\\,\\alpha\\,\\mathcal{T}_{\\mathrm{E}} + (1-\\alpha)\\,\\eta\\,\\mathcal{T}_{\\mathrm{M}}\\,$ acting on the surface current density $\\mathbf{J}$. \n\nStarting from the time-harmonic Maxwell equations $\\,\\nabla \\times \\mathbf{E} = -i \\omega \\mu \\mathbf{H}\\,$ and $\\,\\nabla \\times \\mathbf{H} = i \\omega \\varepsilon \\mathbf{E} + \\mathbf{J}\\,$, the free-space Green's function $\\,G(\\mathbf{r},\\mathbf{r}')=\\exp(-i k |\\mathbf{r}-\\mathbf{r}'|)/(4\\pi |\\mathbf{r}-\\mathbf{r}'|)\\,$, and the boundary integral representation of the scattered magnetic field due to a surface current sheet, use the canonical jump relations of singular boundary integral operators on smooth closed surfaces to identify the principal value contribution of the MFIE. Then, under the assumption that local curvature over the two-triangle support is negligible so the planar RWG geometry is valid, evaluate the singular MFIE contribution to the CFIE diagonal impedance matrix element $Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}}$ associated with $\\mathbf{f}$, expressed via the Galerkin bilinear form $\\,\\langle \\mathbf{f}, \\cdot \\rangle = \\int_{S} \\mathbf{f}(\\mathbf{r}) \\cdot (\\cdot)\\, \\mathrm{d}S\\,$. \n\nTo carry out the calculation, use the standard RWG definition on an equilateral pair: on the “positive” triangle $T^{+}$ with free vertex at $\\mathbf{r}^{+}$, set $\\,\\mathbf{f}(\\mathbf{r}) = \\dfrac{\\ell}{2 A}\\, \\boldsymbol{\\rho}^{+}(\\mathbf{r})\\,$, and on the “negative” triangle $T^{-}$ with free vertex at $\\mathbf{r}^{-}$, set $\\,\\mathbf{f}(\\mathbf{r}) = -\\dfrac{\\ell}{2 A}\\, \\boldsymbol{\\rho}^{-}(\\mathbf{r})\\,$, where $\\,\\ell=s\\,$ is the common edge length, $\\,A=\\dfrac{\\sqrt{3}}{4}s^{2}\\,$ is the triangle area, and $\\,\\boldsymbol{\\rho}^{\\pm}(\\mathbf{r})$ is the in-triangle vector from the free vertex to the point $\\mathbf{r}$. Parameterize each equilateral triangle by $\\,\\mathbf{r}(u,v)=u\\,\\mathbf{a}+v\\,\\mathbf{b}\\,$ with $\\,u\\ge 0\\,$, $\\,v\\ge 0\\,$, $\\,u+v\\le 1\\,$, where $\\,\\mathbf{a}\\,$ and $\\,\\mathbf{b}\\,$ are edge vectors of lengths $\\,|\\mathbf{a}|=|\\mathbf{b}|=s\\,$ and mutual angle $\\,60^{\\circ}\\,$. The area element satisfies $\\,\\mathrm{d}S = |\\mathbf{a}\\times \\mathbf{b}|\\, \\mathrm{d}u\\,\\mathrm{d}v\\,$, with $\\,|\\mathbf{a}\\times \\mathbf{b}| = \\dfrac{\\sqrt{3}}{2}s^{2}\\,$.\n\nExpress your final answer as a closed-form analytic expression for $\\,Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}}\\,$ in terms of $\\,\\alpha\\,$, $\\,\\eta\\,$, and $\\,s\\,$. No numerical rounding is required and no physical units should be included in the final expression.",
            "solution": "The problem requires the evaluation of the singular contribution of the Magnetic Field Integral Equation (MFIE) to the diagonal impedance matrix element of the Combined Field Integral Equation (CFIE), using a Galerkin scheme with a Rao-Wilton-Glisson (RWG) basis function.\n\nThe problem statement has been validated and is deemed scientifically grounded, well-posed, and objective. All provided definitions and parameters are consistent with standard literature in computational electromagnetics.\n\nThe CFIE operator, acting on a surface current density $\\mathbf{J}$, is given as $\\mathcal{L}_{\\mathrm{CFIE}} = \\alpha\\,\\mathcal{T}_{\\mathrm{E}} + (1-\\alpha)\\,\\eta\\,\\mathcal{T}_{\\mathrm{M}}$, where $\\mathcal{T}_{\\mathrm{E}}$ and $\\mathcal{T}_{\\mathrm{M}}$ are the Electric and Magnetic Field Integral Equation operators, respectively, $\\alpha \\in (0,1)$ is a combination parameter, and $\\eta$ is the wave impedance of the medium.\n\nIn a Galerkin-based Method of Moments (MoM) formulation, a diagonal impedance element $Z$ associated with a basis function $\\mathbf{f}$ is given by the inner product:\n$$Z = \\langle \\mathbf{f}, \\mathcal{L}_{\\mathrm{CFIE}}(\\mathbf{f}) \\rangle = \\int_{S} \\mathbf{f}(\\mathbf{r}) \\cdot \\left[ \\alpha\\,\\mathcal{T}_{\\mathrm{E}}(\\mathbf{f})(\\mathbf{r}) + (1-\\alpha)\\,\\eta\\,\\mathcal{T}_{\\mathrm{M}}(\\mathbf{f})(\\mathbf{r}) \\right] \\mathrm{d}S$$\nThe problem directs us to find the singular contribution arising from the MFIE part of this expression. The MFIE operator relates the surface current density $\\mathbf{J}$ to the incident magnetic field. Its formulation involves an integral operator whose kernel is singular. The behavior of this operator at the surface is described by jump conditions. The scattered magnetic field $\\mathbf{H}^s$ at a point $\\mathbf{r}$ is given by $\\mathbf{H}^s(\\mathbf{r}) = \\nabla \\times \\int_S \\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}') \\mathrm{d}S'$, where $G$ is the free-space Green's function. The jump condition for the tangential component of this field across the surface $S$ gives rise to a local term and a principal value (P.V.) integral. The MFIE operator acting on the current $\\mathbf{J}$ can be expressed as:\n$$\\mathcal{T}_{\\mathrm{M}}(\\mathbf{J})(\\mathbf{r}) = \\frac{1}{2}\\mathbf{J}(\\mathbf{r}) + \\mathbf{\\hat{n}}(\\mathbf{r}) \\times \\mathrm{P.V.} \\int_S \\nabla G(\\mathbf{r}, \\mathbf{r}') \\times \\mathbf{J}(\\mathbf{r}') \\mathrm{d}S'$$\nThe term $\\frac{1}{2}\\mathbf{J}(\\mathbf{r})$ is the local, non-integral contribution that arises from the singularity of the Green's function kernel. This is the \"principal value contribution\" isolated by the jump relation, which the problem asks us to evaluate. The other term, the Cauchy Principal Value integral, is computationally intensive but is weakly singular and will not be considered part of the \"singular contribution\" in this context. The EFIE operator $\\mathcal{T}_{\\mathrm{E}}$ involves a stronger (hyper-singular) singularity, which is handled differently and is not the focus here.\n\nThe singular contribution to the CFIE operator is therefore $\\mathcal{L}_{\\mathrm{CFIE}}^{\\mathrm{(sing)}} = (1-\\alpha)\\eta\\,\\mathcal{T}_{\\mathrm{M}}^{\\mathrm{(sing)}}$, where $\\mathcal{T}_{\\mathrm{M}}^{\\mathrm{(sing)}}(\\mathbf{f}) = \\frac{1}{2}\\mathbf{f}$.\nThe corresponding singular contribution to the diagonal impedance element $Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}}$ is:\n$$Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}} = \\left\\langle \\mathbf{f}, (1-\\alpha)\\eta \\left(\\frac{1}{2}\\mathbf{f}\\right) \\right\\rangle = \\frac{1}{2}(1-\\alpha)\\eta \\int_{S} \\mathbf{f}(\\mathbf{r}) \\cdot \\mathbf{f}(\\mathbf{r}) \\, \\mathrm{d}S = \\frac{1}{2}(1-\\alpha)\\eta \\int_{S} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S$$\nThe integral is over the support of $\\mathbf{f}$, which consists of two adjacent equilateral triangles, $T^{+}$ and $T^{-}$. Due to the symmetry of the basis function definition on the two identical triangles, the integral over the full support is twice the integral over one triangle:\n$$\\int_{S} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S = \\int_{T^{+}} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S + \\int_{T^{-}} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S = 2 \\int_{T^{+}} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S$$\nThe RWG basis function on the \"positive\" triangle $T^{+}$ is defined as $\\mathbf{f}(\\mathbf{r}) = \\frac{\\ell}{2A} \\boldsymbol{\\rho}^{+}(\\mathbf{r})$, where $\\ell=s$ is the side length, $A=\\frac{\\sqrt{3}}{4}s^2$ is the area of a single triangle, and $\\boldsymbol{\\rho}^{+}(\\mathbf{r}) = \\mathbf{r} - \\mathbf{r}^{+}$ is the position vector from the free vertex $\\mathbf{r}^{+}$ to a point $\\mathbf{r} \\in T^{+}$.\nThe integral over $T^{+}$ becomes:\n$$\\int_{T^{+}} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S = \\int_{T^{+}} \\left| \\frac{s}{2A} \\boldsymbol{\\rho}^{+}(\\mathbf{r}) \\right|^2 \\, \\mathrm{d}S = \\left(\\frac{s}{2A}\\right)^2 \\int_{T^{+}} |\\boldsymbol{\\rho}^{+}(\\mathbf{r})|^2 \\, \\mathrm{d}S$$\nThe integral $\\int_{T^{+}} |\\boldsymbol{\\rho}^{+}(\\mathbf{r})|^2 \\, \\mathrm{d}S$ is the polar moment of inertia of the triangular area $T^{+}$ about its free vertex, assuming a uniform mass density of $1$. We can evaluate this by parameterizing the triangle. Let the free vertex $\\mathbf{r}^{+}$ be at the origin. The other vertices are defined by vectors $\\mathbf{a}$ and $\\mathbf{b}$ of length $s$ with an angle of $60^{\\circ}$ between them. A point $\\mathbf{r}$ in the triangle is $\\mathbf{r}(u,v) = u\\mathbf{a} + v\\mathbf{b}$ for $u \\ge 0, v \\ge 0, u+v \\le 1$.\nThen $|\\boldsymbol{\\rho}^{+}(\\mathbf{r})|^2 = |\\mathbf{r}|^2 = |u\\mathbf{a} + v\\mathbf{b}|^2 = u^2|\\mathbf{a}|^2 + v^2|\\mathbf{b}|^2 + 2uv(\\mathbf{a}\\cdot\\mathbf{b}) = s^2(u^2+v^2+uv)$.\nThe area element is $\\mathrm{d}S = |\\mathbf{a} \\times \\mathbf{b}| \\mathrm{d}u\\mathrm{d}v = s^2\\sin(60^{\\circ})\\mathrm{d}u\\mathrm{d}v = \\frac{\\sqrt{3}}{2}s^2 \\mathrm{d}u\\mathrm{d}v$.\nThe integral is:\n$$\\int_{T^{+}} |\\boldsymbol{\\rho}^{+}(\\mathbf{r})|^2 \\, \\mathrm{d}S = \\int_{u=0}^{1} \\int_{v=0}^{1-u} s^2(u^2+v^2+uv) \\left(\\frac{\\sqrt{3}}{2}s^2\\right) \\mathrm{d}v\\mathrm{d}u$$\n$$ = \\frac{\\sqrt{3}}{2}s^4 \\int_{u=0}^{1}\\int_{v=0}^{1-u} (u^2+v^2+uv) \\mathrm{d}v\\mathrm{d}u$$\nUsing the standard integral formula over a unit simplex, $\\int_{0}^{1}\\int_{0}^{1-u} u^a v^b \\mathrm{d}v\\mathrm{d}u = \\frac{a!b!}{(a+b+2)!}$:\n$$\\int_{0}^{1}\\int_{0}^{1-u} u^2 \\mathrm{d}v\\mathrm{d}u = \\frac{2!0!}{4!} = \\frac{2}{24} = \\frac{1}{12}$$\n$$\\int_{0}^{1}\\int_{0}^{1-u} v^2 \\mathrm{d}v\\mathrm{d}u = \\frac{0!2!}{4!} = \\frac{2}{24} = \\frac{1}{12}$$\n$$\\int_{0}^{1}\\int_{0}^{1-u} uv \\mathrm{d}v\\mathrm{d}u = \\frac{1!1!}{4!} = \\frac{1}{24}$$\nThe sum of these integrals is $\\frac{1}{12} + \\frac{1}{12} + \\frac{1}{24} = \\frac{2+2+1}{24} = \\frac{5}{24}$.\nSo, the polar moment of inertia is:\n$$\\int_{T^{+}} |\\boldsymbol{\\rho}^{+}(\\mathbf{r})|^2 \\, \\mathrm{d}S = \\frac{\\sqrt{3}}{2}s^4 \\left(\\frac{5}{24}\\right) = \\frac{5\\sqrt{3}}{48}s^4$$\nNow we substitute this back. The pre-factor is:\n$$\\left(\\frac{s}{2A}\\right)^2 = \\left(\\frac{s}{2 \\cdot \\frac{\\sqrt{3}}{4}s^2}\\right)^2 = \\left(\\frac{s}{\\frac{\\sqrt{3}}{2}s^2}\\right)^2 = \\left(\\frac{2}{\\sqrt{3}s}\\right)^2 = \\frac{4}{3s^2}$$\nThe integral over one triangle is:\n$$\\int_{T^{+}} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S = \\left(\\frac{4}{3s^2}\\right) \\left(\\frac{5\\sqrt{3}}{48}s^4\\right) = \\frac{20\\sqrt{3}}{144}s^2 = \\frac{5\\sqrt{3}}{36}s^2$$\nThe total integral over the support $S = T^{+} \\cup T^{-}$ is:\n$$\\int_{S} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S = 2 \\times \\frac{5\\sqrt{3}}{36}s^2 = \\frac{5\\sqrt{3}}{18}s^2$$\nFinally, we can compute the value of $Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}}$:\n$$Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}} = \\frac{1}{2}(1-\\alpha)\\eta \\left( \\frac{5\\sqrt{3}}{18}s^2 \\right) = \\frac{5\\sqrt{3}}{36}(1-\\alpha)\\eta s^2$$\nThis expression represents the singular contribution of the MFIE operator to the diagonal impedance element as requested.",
            "answer": "$$\n\\boxed{\\frac{5\\sqrt{3}}{36}(1-\\alpha)\\eta s^{2}}\n$$"
        },
        {
            "introduction": "After exploring the analytical structure of an impedance element, the next step is to compute its value numerically. This practice guides you through the process of translating the theoretical integral for the magnetic vector potential into a working computational code for a simple wire antenna model . You will implement a robust numerical quadrature scheme and apply a standard regularization technique to handle the kernel's singularity, bridging the gap between mathematical theory and practical implementation.",
            "id": "3317567",
            "problem": "Consider a perfectly electrically conducting thin straight wire of finite radius $a$ aligned with the $x$-axis in free space. In the Electric Field Integral Equation (EFIE) solved by the Method of Moments (MoM), pulse (piecewise constant) basis functions and Galerkin testing are used to form the impedance matrix. Focus exclusively on the magnetic vector potential contribution to the EFIE operator and ignore the scalar potential term.\n\nStarting from first principles, use Maxwell's equations and the free-space scalar Green's function to derive and evaluate the magnetic vector potential contribution to the Galerkin impedance matrix element between two pulse basis functions supported on segments $\\Gamma_m = [x_m^{(1)}, x_m^{(2)}]$ and $\\Gamma_n = [x_n^{(1)}, x_n^{(2)}]$ of the wire. Assume the wire’s finite radius regularizes the on-axis singularity by replacing the Euclidean distance with $R(x,x') = \\sqrt{(x - x')^2 + a^2}$ throughout. The free-space scalar Green's function is $G(R) = \\dfrac{e^{-i k R}}{4\\pi R}$, where $k = \\omega \\sqrt{\\mu_0 \\epsilon_0}$, $\\omega = 2\\pi f$, $\\mu_0$ is the vacuum permeability, and $\\epsilon_0$ is the vacuum permittivity. The Galerkin impedance matrix element for the magnetic vector potential part is\n$$\nZ_{mn}^{(A)} = i \\,\\omega \\,\\mu_0 \\int_{\\Gamma_m} \\int_{\\Gamma_n} G\\!\\left(R(x,x')\\right)\\, \\mathrm{d}x' \\,\\mathrm{d}x.\n$$\nAll lengths must be treated in meters, frequency in Hertz, and output impedance values in Ohms.\n\nYour task is to implement a complete, self-contained program that, for a specified test suite, numerically evaluates the real part of $Z_{mn}^{(A)}$ using high-order tensor-product Gaussian quadrature over the two segments, with the regularization $R(x,x') = \\sqrt{(x-x')^2 + a^2}$ as given. The numerical integration must be performed directly on the double integral without analytical simplifications. The program should be designed to handle near-singular configurations robustly (e.g., overlapping or adjacent segments) by appropriately selecting sufficient quadrature order.\n\nUse the following physical constants: $\\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{H/m}$ and $\\epsilon_0 = 8.854187817 \\times 10^{-12}\\,\\mathrm{F/m}$. The wave number is $k = \\omega \\sqrt{\\mu_0 \\epsilon_0}$ with $\\omega = 2\\pi f$ for each test case. The imaginary unit is $i = \\sqrt{-1}$.\n\nImplement the program to process the following test suite. Each test case is a tuple $(f, a, x_m^{(1)}, x_m^{(2)}, x_n^{(1)}, x_n^{(2)})$:\n- Test $1$ (self term, moderate frequency, moderate radius): $(300\\times 10^6,\\; 1\\times 10^{-3},\\; -0.025,\\; 0.025,\\; -0.025,\\; 0.025)$\n- Test $2$ (adjacent segments with a small gap): $(300\\times 10^6,\\; 1\\times 10^{-3},\\; -0.05,\\; 0.0,\\; 0.001,\\; 0.051)$\n- Test $3$ (far-separated segments): $(300\\times 10^6,\\; 1\\times 10^{-3},\\; -0.025,\\; 0.025,\\; 0.975,\\; 1.025)$\n- Test $4$ (quasi-static regime with smaller radius): $(1\\times 10^3,\\; 1\\times 10^{-4},\\; -0.025,\\; 0.025,\\; -0.025,\\; 0.025)$\n\nFor each test case, compute the real part of $Z_{mn}^{(A)}$ and express it in Ohms. Your program must output a single line containing a comma-separated list enclosed in square brackets. The list must contain the results for the test cases in order, each rounded to $6$ decimal places, for example $[z_1,z_2,z_3,z_4]$, where each $z_i$ is the real part of $Z_{mn}^{(A)}$ for Test $i$ in Ohms.\n\nYour solution must rely only on the numerical evaluation of the given double integral with the specified regularization. The algorithm must be general and apply to any pair of segments and any positive frequency. Do not use external files or user input. The final program must be runnable as is.",
            "solution": "The user-provided problem has been analyzed and validated. It constitutes a well-posed, scientifically grounded problem in computational electromagnetics. All necessary parameters and definitions are provided, and no inconsistencies or ambiguities are present. We may therefore proceed with a complete solution.\n\nThe primary objective is to compute the real part of the impedance matrix element $Z_{mn}^{(A)}$, which arises from the magnetic vector potential contribution in the Method of Moments (MoM) solution of the Electric Field Integral Equation (EFIE) for a thin wire. The problem specifies the use of pulse basis functions and Galerkin testing.\n\nThe expression for the impedance element is given as:\n$$\nZ_{mn}^{(A)} = i \\,\\omega \\,\\mu_0 \\int_{\\Gamma_m} \\int_{\\Gamma_n} G\\!\\left(R(x,x')\\right)\\, \\mathrm{d}x' \\,\\mathrm{d}x\n$$\nwhere $i = \\sqrt{-1}$ is the imaginary unit, $\\omega$ is the angular frequency, and $\\mu_0$ is the vacuum permeability. The integration domains are the wire segments $\\Gamma_m = [x_m^{(1)}, x_m^{(2)}]$ and $\\Gamma_n = [x_n^{(1)}, x_n^{(2)}]$.\n\nThe kernel of the integral is the free-space scalar Green's function $G(R) = \\frac{e^{-i k R}}{4\\pi R}$, evaluated at a regularized distance $R(x,x') = \\sqrt{(x - x')^2 + a^2}$. Here, $a$ is the wire radius, $k = \\omega/c_0$ is the free-space wavenumber, and $c_0 = 1/\\sqrt{\\mu_0 \\epsilon_0}$ is the speed of light in vacuum.\n\nTo find the real part of $Z_{mn}^{(A)}$, we first substitute the Green's function and use Euler's formula, $e^{-i\\theta} = \\cos(\\theta) - i\\sin(\\theta)$:\n$$\nG(R) = \\frac{\\cos(k R) - i \\sin(k R)}{4\\pi R}\n$$\nThe double integral can be split into its real and imaginary parts:\n$$\nI_{mn} = \\int_{\\Gamma_m} \\int_{\\Gamma_n} G(R) \\, \\mathrm{d}x' \\, \\mathrm{d}x = \\int_{\\Gamma_m} \\int_{\\Gamma_n} \\frac{\\cos(kR)}{4\\pi R} \\, \\mathrm{d}x' \\, \\mathrm{d}x - i \\int_{\\Gamma_m} \\int_{\\Gamma_n} \\frac{\\sin(kR)}{4\\pi R} \\, \\mathrm{d}x' \\, \\mathrm{d}x\n$$\nLet the real part of this integral be $I_{Re}$ and the imaginary part be $I_{Im}$. Then $I_{mn} = I_{Re} + i I_{Im}$, where:\n$$\nI_{Im} = - \\int_{\\Gamma_m} \\int_{\\Gamma_n} \\frac{\\sin(kR)}{4\\pi R} \\, \\mathrm{d}x' \\, \\mathrm{d}x\n$$\nSubstituting this back into the expression for $Z_{mn}^{(A)}$:\n$$\nZ_{mn}^{(A)} = i \\,\\omega \\,\\mu_0 (I_{Re} + i I_{Im}) = i\\,\\omega\\,\\mu_0 I_{Re} + i^2\\,\\omega\\,\\mu_0 I_{Im} = -\\omega\\,\\mu_0 I_{Im} + i\\,\\omega\\,\\mu_0 I_{Re}\n$$\nThe real part of $Z_{mn}^{(A)}$ is therefore:\n$$\n\\mathrm{Re}\\{Z_{mn}^{(A)}\\} = -\\omega\\,\\mu_0 I_{Im} = -\\omega\\,\\mu_0 \\left( - \\int_{\\Gamma_m} \\int_{\\Gamma_n} \\frac{\\sin(kR)}{4\\pi R} \\, \\mathrm{d}x' \\, \\mathrm{d}x \\right)\n$$\n$$\n\\mathrm{Re}\\{Z_{mn}^{(A)}\\} = \\frac{\\omega \\mu_0}{4\\pi} \\int_{x_m^{(1)}}^{x_m^{(2)}} \\int_{x_n^{(1)}}^{x_n^{(2)}} \\frac{\\sin(k \\sqrt{(x-x')^2 + a^2})}{\\sqrt{(x-x')^2 + a^2}} \\, \\mathrm{d}x' \\, \\mathrm{d}x\n$$\nThis is the final integral to be evaluated numerically. The integrand, a scaled sinc function $\\mathrm{sinc}(kR) = \\sin(kR)/(kR)$, is well-behaved. The regularization with radius $a > 0$ ensures the denominator $R$ is never zero, preventing a singularity.\n\nThe problem requires numerical evaluation using tensor-product Gaussian quadrature. This method approximates a definite integral over a canonical interval $[-1, 1]$ as a weighted sum:\n$$\n\\int_{-1}^{1} f(u) \\, \\mathrm{d}u \\approx \\sum_{i=1}^{N} w_i f(u_i)\n$$\nwhere $u_i$ are the quadrature nodes (roots of the $N$-th order Legendre polynomial) and $w_i$ are the corresponding weights. To apply this to our arbitrary integration intervals, we perform a linear change of variables for each integral.\n\nFor the outer integral over $x \\in [x_m^{(1)}, x_m^{(2)}]$:\nLet $x = x_m^{(c)} + u h_m$, where $x_m^{(c)} = \\frac{x_m^{(1)} + x_m^{(2)}}{2}$ is the center and $h_m = \\frac{x_m^{(2)} - x_m^{(1)}}{2}$ is the half-width of the interval $\\Gamma_m$. Then $\\mathrm{d}x = h_m \\mathrm{d}u$, with $u \\in [-1,1]$.\n\nFor the inner integral over $x' \\in [x_n^{(1)}, x_n^{(2)}]$:\nSimilarly, let $x' = x_n^{(c)} + v h_n$, where $x_n^{(c)} = \\frac{x_n^{(1)} + x_n^{(2)}}{2}$ and $h_n = \\frac{x_n^{(2)} - x_n^{(1)}}{2}$. Then $\\mathrm{d}x' = h_n \\mathrm{d}v$, with $v \\in [-1,1]$.\n\nThe double integral transforms to:\n$$\n\\mathrm{Re}\\{Z_{mn}^{(A)}\\} = \\frac{\\omega \\mu_0 h_m h_n}{4\\pi} \\int_{-1}^{1} \\int_{-1}^{1} \\frac{\\sin(k R(u,v))}{R(u,v)} \\, \\mathrm{d}v \\, \\mathrm{d}u\n$$\nwhere $R(u,v) = \\sqrt{((x_m^{(c)} + u h_m) - (x_n^{(c)} + v h_n))^2 + a^2}$.\n\nApplying the tensor-product Gaussian quadrature rule with $N$ points for each dimension, we obtain the numerical approximation:\n$$\n\\mathrm{Re}\\{Z_{mn}^{(A)}\\} \\approx \\frac{\\omega \\mu_0 h_m h_n}{4\\pi} \\sum_{i=1}^{N} \\sum_{j=1}^{N} w_i w_j \\frac{\\sin(k R_{ij})}{R_{ij}}\n$$\nwhere $u_i$ and $v_j$ are the quadrature nodes, $w_i$ and $w_j$ are the weights, and $R_{ij}$ is the distance $R(u_i,v_j)$. For Galerkin testing, the basis and test function domains are typically identical, but the formulation is general.\n\nA high quadrature order $N$ is chosen to ensure accuracy, particularly for self-interaction terms (where $\\Gamma_m = \\Gamma_n$) or adjacent segments, as the integrand becomes more sharply peaked around $x=x'$. A value of $N=96$ is robust for the specified test cases.\n\nThe implementation will define a function to perform this calculation. Physical constants $\\mu_0$ and $\\epsilon_0$ are used to compute $c_0$ and $k$. For each test case, the parameters $(f, a, x_m^{(1)}, x_m^{(2)}, x_n^{(1)}, x_n^{(2)})$ are passed to this function. The final results are collected, formatted to $6$ decimal places, and printed. The use of `numpy.sinc` is advisable for numerical stability, noting its definition requires scaling the argument by $\\pi$. The expression $\\sin(y)/y$ is equivalent to `numpy.sinc(y/numpy.pi)`. The integrand can thus be written as $k \\times \\mathrm{numpy.sinc}(kR/\\pi)$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Solves the problem by numerically evaluating the impedance matrix elements\n    for the provided test cases.\n    \"\"\"\n\n    # Physical constants as specified in the problem\n    MU_0 = 4 * np.pi * 1e-7\n    EPSILON_0 = 8.854187817e-12\n    C_0 = 1 / np.sqrt(MU_0 * EPSILON_0)\n\n    def evaluate_z_mn_a_real(f, a, xm1, xm2, xn1, xn2, n_quad):\n        \"\"\"\n        Calculates the real part of Z_mn^(A) using tensor-product Gaussian quadrature.\n        \n        Args:\n            f (float): Frequency in Hertz.\n            a (float): Wire radius in meters.\n            xm1 (float): Start of segment m in meters.\n            xm2 (float): End of segment m in meters.\n            xn1 (float): Start of segment n in meters.\n            xn2 (float): End of segment n in meters.\n            n_quad (int): Order of Gaussian quadrature.\n            \n        Returns:\n            float: The real part of the impedance element Z_mn^(A) in Ohms.\n        \"\"\"\n        omega = 2 * np.pi * f\n        k = omega / C_0\n\n        # Get Gauss-Legendre nodes and weights for the interval [-1, 1]\n        nodes, weights = roots_legendre(n_quad)\n\n        # Calculate interval centers and half-widths for the change of variables\n        xm_c = (xm1 + xm2) / 2.0\n        hm = (xm2 - xm1) / 2.0\n        xn_c = (xn1 + xn2) / 2.0\n        hn = (xn2 - xn1) / 2.0\n\n        # Handle zero-length segments\n        if hm == 0 or hn == 0:\n            return 0.0\n\n        # Map nodes from [-1, 1] to the physical segment intervals [xm1, xm2] and [xn1, xn2]\n        x_nodes = xm_c + nodes * hm\n        xp_nodes = xn_c + nodes * hn\n\n        # Perform 2D numerical integration using the tensor-product rule\n        integral_sum = 0.0\n        for i in range(n_quad):\n            for j in range(n_quad):\n                x = x_nodes[i]\n                xp = xp_nodes[j]\n                wi = weights[i]\n                wj = weights[j]\n\n                # Calculate the regularized distance R(x, x')\n                dx_sq = (x - xp)**2\n                R = np.sqrt(dx_sq + a**2)\n                \n                # Evaluate the integrand sin(k*R)/R.\n                # This formulation is numerically stable for small R because a > 0.\n                # For enhanced stability, one could use k * np.sinc(k * R / np.pi)\n                # but direct division is fine here since R is never zero.\n                if R == 0.0:\n                    # This case does not occur since a > 0, but as a safeguard.\n                    # The limit of sin(k*R)/R as R->0 is k.\n                    integrand = k\n                else:\n                    integrand = np.sin(k * R) / R\n\n                integral_sum += wi * wj * integrand\n\n        # Combine terms to get the final result\n        prefactor = (omega * MU_0) / (4 * np.pi)\n        result = prefactor * hm * hn * integral_sum\n        return result\n\n    # The test suite provided in the problem statement\n    test_cases = [\n        # (f, a, x_m^(1), x_m^(2), x_n^(1), x_n^(2))\n        (300e6, 1e-3, -0.025, 0.025, -0.025, 0.025),\n        (300e6, 1e-3, -0.05, 0.0, 0.001, 0.051),\n        (300e6, 1e-3, -0.025, 0.025, 0.975, 1.025),\n        (1e3, 1e-4, -0.025, 0.025, -0.025, 0.025),\n    ]\n\n    # A high quadrature order is chosen for accuracy, especially for self-terms\n    # and near-singular configurations.\n    N_QUAD = 96\n    \n    results = []\n    for case in test_cases:\n        z_real = evaluate_z_mn_a_real(*case, n_quad=N_QUAD)\n        results.append(f\"{z_real:.6f}\")\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While computing individual impedance elements is fundamental, solving large-scale problems requires efficiently handling the entire matrix. This practice introduces the powerful concept of hierarchical matrices ($\\mathcal{H}$-matrices), which exploit the physics of wave propagation to compress blocks corresponding to well-separated parts of the geometry . You will implement the core logic of admissibility testing and low-rank approximation, revealing the principles that enable fast and scalable integral equation solvers.",
            "id": "3317604",
            "problem": "You are to derive and implement a program that constructs and analyzes a hierarchical matrix representation for the impedance matrix associated with a one-dimensional discretization of a thin straight conductor under time-harmonic excitation. The impedance matrix entries arise from the double-integral of the free-space scalar Green's function of the Helmholtz equation. Begin from fundamental electromagnetic laws and definitions, and express all mathematical quantities in LaTeX. Then, implement a hierarchical matrix that uses low-rank approximations for admissible far-field blocks. Finally, predict and measure numerical ranks for these blocks and estimate the impact on assembly time.\n\nStart from the macroscopic Maxwell's equations in the frequency domain for a source-free homogeneous medium with angular frequency $\\omega$, permittivity $\\epsilon$, and permeability $\\mu$. For time-harmonic fields with $\\mathrm{e}^{\\mathrm{i} \\omega t}$ convention, the electric field $\\mathbf{E}$ satisfies the vector Helmholtz equation. The scalar free-space Green's function $G(\\mathbf{r},\\mathbf{r}')$ of the Helmholtz equation solves\n$$\n\\left(\\nabla^2 + k^2\\right) G(\\mathbf{r},\\mathbf{r}') = -\\delta(\\mathbf{r}-\\mathbf{r}'),\n$$\nwhere $k = \\omega \\sqrt{\\mu \\epsilon}$ is the wavenumber. In three dimensions,\n$$\nG(\\mathbf{r},\\mathbf{r}') = \\frac{\\mathrm{e}^{-\\mathrm{i} k \\|\\mathbf{r}-\\mathbf{r}'\\|}}{4 \\pi \\|\\mathbf{r}-\\mathbf{r}'\\|}.\n$$\n\nConsider a thin straight conductor aligned with the $x$-axis, occupying the interval $[0,L]$ where $L$ is the total length. Discretize $[0,L]$ into $M$ uniform segments (panels) of length $h = L/M$, with indices $i = 0,1,\\dots,M-1$. Use piecewise-constant basis functions $\\phi_i(x)$ supported on the $i$-th panel:\n$$\n\\phi_i(x) = \\begin{cases}\n1 & \\text{for } x \\in [i h, (i+1) h],\\\\\n0 & \\text{otherwise}.\n\\end{cases}\n$$\nDefine the impedance matrix $Z \\in \\mathbb{C}^{M \\times M}$ with entries\n$$\nZ_{ij} = \\int_{i h}^{(i+1) h} \\int_{j h}^{(j+1) h} \\frac{\\mathrm{e}^{-\\mathrm{i} k |x - x'|}}{4 \\pi |x - x'|} \\,\\mathrm{d}x' \\,\\mathrm{d}x,\n$$\nwhere the distance is approximated by $|x-x'|$ along the line. When $i=j$, the integrand has a weak singularity at $x=x'$, which must be handled numerically in a stable manner.\n\nPartition the index set $\\{0,1,\\dots,M-1\\}$ into contiguous clusters and build a block cluster tree. For any block defined by a pair of clusters $A$ and $B$ with index sets $I_A$ and $I_B$, define the cluster diameters\n$$\n\\operatorname{diam}(A) = \\max_{i \\in I_A} (i+1)h - \\min_{i \\in I_A} i h = |I_A| h,\n$$\nand similarly for $B$. Let the separation distance be the minimum gap between the support intervals of $A$ and $B$,\n$$\n\\operatorname{sep}(A,B) = \\max\\bigl(0, \\max(\\min_{j \\in I_B} j h - \\max_{i \\in I_A} (i+1) h,\\; \\min_{i \\in I_A} i h - \\max_{j \\in I_B} (j+1) h)\\bigr),\n$$\nwhich is zero if the intervals overlap or touch. Adopt the admissibility condition with parameter $\\eta > 0$:\n$$\n\\operatorname{sep}(A,B) \\ge \\eta \\max\\left(\\operatorname{diam}(A), \\operatorname{diam}(B)\\right).\n$$\nFor admissible blocks, use a low-rank approximation by truncating the singular value decomposition (SVD) of the block submatrix to a rank that meets a prescribed relative error tolerance $\\varepsilon$ in Frobenius norm. For non-admissible blocks, use the full dense representation.\n\nFor blocks that are admissible, the Green's function kernel is smooth over $A \\times B$, allowing approximation by a separated low-rank expansion. Provide a theoretically motivated estimate of the rank $r_{\\mathrm{pred}}$ in terms of the wavenumber $k$, the cluster diameters, and the separation distance. Use a simple predictor of the form\n$$\nr_{\\mathrm{pred}} = \\left\\lceil \\alpha \\frac{k \\, a}{\\xi} + \\beta \\log \\frac{1}{\\varepsilon} \\right\\rceil,\n$$\nwhere $a = \\max\\bigl(\\operatorname{diam}(A),\\operatorname{diam}(B)\\bigr)$ is the characteristic size, $\\xi = \\operatorname{sep}(A,B)/a$ is the normalized separation, and $\\alpha$ and $\\beta$ are positive constants of order unity summarizing analytic approximation properties. Saturate $r_{\\mathrm{pred}}$ to be at least $1$ and at most $\\min(|I_A|,|I_B|)$, and for non-admissible blocks set $r_{\\mathrm{pred}} = \\min(|I_A|,|I_B|)$.\n\nNumerically, approximate the double-integral for $Z_{ij}$ with Gauss–Legendre quadrature using $Q$ nodes per panel along both integrals. Use quadrature nodes and weights on each panel to construct the block matrix entries. To handle the weak singularity when $i=j$, employ a regularization such as replacing $|x-x'|$ by $\\max(|x-x'|, \\delta)$ with a small $\\delta$ proportional to the mesh size $h$.\n\nDefine an assembly time proxy (operation count) for a block:\n- For a dense block of size $|I_A| \\times |I_B|$, using $Q$ quadrature points in each integral, set\n$$\n\\mathrm{ops}_{\\mathrm{dense}} = |I_A| \\, |I_B| \\, Q^2.\n$$\n- For an admissible block represented with numerical rank $r_{\\mathrm{num}}$, approximate the hierarchical assembly cost by\n$$\n\\mathrm{ops}_{\\mathcal{H}} = r_{\\mathrm{num}} \\, (|I_A| + |I_B|) \\, Q + r_{\\mathrm{num}}^2,\n$$\nand for non-admissible blocks use $\\mathrm{ops}_{\\mathcal{H}} = \\mathrm{ops}_{\\mathrm{dense}}$.\n\nCompute the speedup proxy\n$$\nS = \\frac{\\mathrm{ops}_{\\mathrm{dense}}}{\\mathrm{ops}_{\\mathcal{H}}}.\n$$\n\nImplement a program that, for each test case described below, constructs the block submatrix for $(A,B)$, computes the truncated SVD to determine $r_{\\mathrm{num}}$ meeting tolerance $\\varepsilon$, evaluates the actual relative Frobenius error achieved by the truncation, computes $r_{\\mathrm{pred}}$, and computes $\\mathrm{ops}_{\\mathrm{dense}}$, $\\mathrm{ops}_{\\mathcal{H}}$, and $S$.\n\nAll distances must be expressed in meters, the wavenumber $k$ must be expressed in radians per meter, and all reported floating-point quantities must be in decimal form. Angles do not appear in this formulation. The final outputs are unitless except for the input parameters as specified.\n\nUse the following test suite to ensure coverage:\n- Use $L = 1\\,\\mathrm{m}$, $M = 64$, $Q = 8$, $\\eta = 1$, and regularization $\\delta = 10^{-6} h$ for all cases, where $h = L/M$.\n- Cluster indices are contiguous ranges $\\{s, s+1, \\dots, s+n-1\\}$ specified by a start index $s$ and size $n$.\n\nTest cases:\n1. Case $1$: $k = 20\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-4}$, cluster $A$: $s_A = 0$, $n_A = 8$, cluster $B$: $s_B = 24$, $n_B = 8$.\n2. Case $2$: $k = 5\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-6}$, cluster $A$: $s_A = 0$, $n_A = 8$, cluster $B$: $s_B = 56$, $n_B = 8$.\n3. Case $3$: $k = 40\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-4}$, cluster $A$: $s_A = 16$, $n_A = 8$, cluster $B$: $s_B = 24$, $n_B = 8$.\n4. Case $4$: $k = 20\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-5}$, cluster $A$: $s_A = 8$, $n_A = 8$, cluster $B$: $s_B = 8$, $n_B = 8$.\n5. Case $5$: $k = 80\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-4}$, cluster $A$: $s_A = 0$, $n_A = 16$, cluster $B$: $s_B = 32$, $n_B = 16$.\n\nFor each test case, output a list containing\n$$\n\\bigl[r_{\\mathrm{pred}},\\; r_{\\mathrm{num}},\\; E_{\\mathrm{rel}},\\; \\mathrm{ops}_{\\mathrm{dense}},\\; \\mathrm{ops}_{\\mathcal{H}},\\; S\\bigr],\n$$\nwhere $E_{\\mathrm{rel}}$ is the achieved relative Frobenius error of the truncated SVD.\n\nYour program should produce a single line of output containing the results as a comma-separated list of these lists enclosed in square brackets with no spaces, for example, \n$$\n[\\,[1,2,0.001,64,32,2.0],[\\dots]\\,].\n$$",
            "solution": "The problem requires the derivation and implementation of a method to analyze the hierarchical matrix structure of an impedance matrix $Z$ arising from the discretization of an integral equation for a one-dimensional thin wire antenna. This analysis involves constructing specific blocks of the matrix, determining their admissibility for low-rank approximation, computing their numerical rank, and comparing it to a theoretical prediction. Finally, the computational savings from using a hierarchical representation are estimated.\n\n### Theoretical Formulation\n\nThe physical problem concerns time-harmonic electromagnetic scattering from a thin straight conductor. For a time-harmonic dependence $\\mathrm{e}^{\\mathrm{i} \\omega t}$, the electric field $\\mathbf{E}$ in a source-free, homogeneous medium characterized by permittivity $\\epsilon$ and permeability $\\mu$ satisfies the vector Helmholtz equation:\n$$\n\\nabla \\times \\nabla \\times \\mathbf{E} - k^2 \\mathbf{E} = \\mathbf{0},\n$$\nwhere $k = \\omega \\sqrt{\\mu \\epsilon}$ is the wavenumber. This can be solved using an integral equation formulation. The electric field is related to the scalar potential $\\Phi$ and vector potential $\\mathbf{A}$ as $\\mathbf{E} = -\\mathrm{i}\\omega\\mathbf{A} - \\nabla\\Phi$. Both potentials can be expressed as convolutions of the sources (currents $\\mathbf{J}$ and charges $\\rho$) with the free-space Green's function, $G(\\mathbf{r},\\mathbf{r}')$, which is the solution to:\n$$\n(\\nabla^2 + k^2) G(\\mathbf{r},\\mathbf{r}') = -\\delta(\\mathbf{r}-\\mathbf{r}').\n$$\nIn three dimensions, this Green's function is given by:\n$$\nG(\\mathbf{r},\\mathbf{r}') = \\frac{\\mathrm{e}^{-\\mathrm{i} k \\|\\mathbf{r}-\\mathbf{r}'\\|}}{4 \\pi \\|\\mathbf{r}-\\mathbf{r}'\\|}.\n$$\nThe problem considers a simplified one-dimensional conductor along the $x$-axis from $x=0$ to $x=L$. The distance between two points $\\mathbf{r}=(x,0,0)$ and $\\mathbf{r}'=(x',0,0)$ is approximated by $\\|\\mathbf{r}-\\mathbf{r}'\\| \\approx |x-x'|$. The problem uses the Method of Moments (MoM) to discretize the governing integral equation. The conductor is divided into $M$ segments of length $h = L/M$. The unknown current distribution is expanded in a basis of piecewise-constant functions $\\phi_i(x)$:\n$$\n\\phi_i(x) = \\begin{cases}\n1 & \\text{for } x \\in [i h, (i+1) h] \\\\\n0 & \\text{otherwise}.\n\\end{cases}\n$$\nApplying Galerkin's method, where the testing functions are the same as the basis functions, yields a dense linear system $Z I = V$, where $I$ is the vector of unknown current coefficients and $Z$ is the impedance matrix. The entry $Z_{ij}$ represents the mutual impedance between segment $i$ and segment $j$. It is calculated by a double integral over the supports of the respective basis functions:\n$$\nZ_{ij} = \\int_{\\mathbb{R}} \\int_{\\mathbb{R}} \\phi_i(x) G(x,x') \\phi_j(x') \\,\\mathrm{d}x' \\,\\mathrm{d}x = \\int_{i h}^{(i+1) h} \\int_{j h}^{(j+1) h} \\frac{\\mathrm{e}^{-\\mathrm{i} k |x - x'|}}{4 \\pi |x - x'|} \\,\\mathrm{d}x' \\,\\mathrm{d}x.\n$$\n\n### Numerical Discretization and Singularity Treatment\n\nThe double integral for $Z_{ij}$ is evaluated numerically using Gauss-Legendre quadrature. For each panel, $Q$ quadrature nodes are used. Let $\\{\\xi_p, w_p\\}_{p=1}^Q$ be the standard Gauss-Legendre nodes and weights on the interval $[-1, 1]$. The integrals over panels $i$ and $j$ are transformed:\n- For $x \\in [ih, (i+1)h]$, we use the mapping $x(\\xi) = (i+0.5)h + \\xi \\frac{h}{2}$, so $\\mathrm{d}x = \\frac{h}{2} \\mathrm{d}\\xi$.\n- For $x' \\in [jh, (j+1)h]$, we use $x'(\\xi') = (j+0.5)h + \\xi' \\frac{h}{2}$, so $\\mathrm{d}x' = \\frac{h}{2} \\mathrm{d}\\xi'$.\n\nThe integral becomes:\n$$\nZ_{ij} \\approx \\frac{1}{4\\pi} \\left(\\frac{h}{2}\\right)^2 \\sum_{p=1}^Q \\sum_{q=1}^Q w_p w_q \\frac{\\mathrm{e}^{-\\mathrm{i} k |x(\\xi_p) - x'(\\xi'_q)|}}{|x(\\xi_p) - x'(\\xi'_q)|}.\n$$\nWhen $i=j$, the kernel $1/|x-x'|$ has an integrable (weak) singularity at $x=x'$. Standard quadrature rules may fail or be inaccurate. The problem specifies a regularization technique: replacing the distance $|x-x'|$ with $\\max(|x-x'|, \\delta)$, where $\\delta$ is a small parameter. This removes the singularity, allowing for stable numerical integration.\n\n### Hierarchical Matrix Framework and Admissibility\n\nThe core of the hierarchical matrix method is to partition the dense matrix $Z$ into blocks and approximate certain blocks with a low-rank representation. A block submatrix $Z_{AB}$ is defined by two clusters of indices, $A$ and $B$, with index sets $I_A$ and $I_B$. The low-rank approximability of a block depends on the geometric separation of the corresponding clusters. This is formalized by the admissibility condition.\n\nFirst, we define geometric properties for the clusters:\n- **Cluster Diameter**: $\\operatorname{diam}(A) = (\\max_{i \\in I_A} (i+1) - \\min_{i \\in I_A} i)h = |I_A|h$ for a contiguous cluster of size $|I_A|$.\n- **Separation Distance**: $\\operatorname{sep}(A,B)$ is the minimum distance between the spatial domains corresponding to clusters $A$ and $B$. For contiguous clusters starting at $s_A$ and $s_B$ with sizes $n_A$ and $n_B$ respectively, the domains are $[s_A h, (s_A+n_A)h]$ and $[s_B h, (s_B+n_B)h]$. The separation is:\n$$\n\\operatorname{sep}(A,B) = h \\cdot \\max(0, s_B - (s_A+n_A), s_A - (s_B+n_B)).\n$$\n- **Admissibility Condition**: A block $(A,B)$ is deemed admissible (or \"far-field\") if its clusters are well-separated relative to their size. With a parameter $\\eta > 0$:\n$$\n\\operatorname{sep}(A,B) \\ge \\eta \\max(\\operatorname{diam}(A), \\operatorname{diam}(B)).\n$$\nIf this condition holds, the kernel function $G(x,x')$ is smooth for $x$ in cluster $A$'s domain and $x'$ in cluster $B$'s domain, which allows for an efficient low-rank approximation of the matrix block $Z_{AB}$.\n\n### Low-Rank Approximation and Rank Prediction\n\nFor an admissible block $Z_{AB}$ of size $n_A \\times n_B$, we can find a low-rank approximation. The Singular Value Decomposition (SVD), $Z_{AB} = U \\Sigma V^H$, provides the optimal rank-$r$ approximation by keeping the first $r$ singular values and vectors. The numerical rank, $r_{\\mathrm{num}}$, is the smallest rank $r$ that satisfies a given relative error tolerance $\\varepsilon$ in the Frobenius norm:\n$$\n\\frac{\\|Z_{AB} - Z_{AB}^{(r)}\\|_F}{\\|Z_{AB}\\|_F} = \\frac{\\sqrt{\\sum_{k=r+1}^{\\min(n_A,n_B)} \\sigma_k^2}}{\\sqrt{\\sum_{k=1}^{\\min(n_A,n_B)} \\sigma_k^2}} \\le \\varepsilon,\n$$\nwhere $Z_{AB}^{(r)}$ is the rank-$r$ truncated SVD approximation and $\\sigma_k$ are the singular values.\n\nThe problem provides a theoretical predictor for the rank:\n$$\nr_{\\mathrm{pred}} = \\left\\lceil \\alpha \\frac{k \\, a}{\\xi} + \\beta \\log \\frac{1}{\\varepsilon} \\right\\rceil,\n$$\nwhere $a = \\max(\\operatorname{diam}(A), \\operatorname{diam}(B))$ and $\\xi = \\operatorname{sep}(A,B)/a$. The constants $\\alpha$ and $\\beta$ are stated to be of order unity. Based on this, we choose $\\alpha=1$ and $\\beta=1$, a common simplification. The predicted rank is saturated to be at least $1$ and at most the dimension of the block, $\\min(n_A, n_B)$. For non-admissible blocks, the full rank is predicted: $r_{\\mathrm{pred}} = \\min(n_A, n_B)$.\n\n### Complexity and Speedup Estimation\n\nThe computational benefit of the hierarchical matrix approach is estimated by comparing operation counts.\n- **Dense Assembly**: Constructing a dense $n_A \\times n_B$ block with $Q$-point quadrature per dimension requires nested loops, leading to a computational cost proxy of:\n$$\n\\mathrm{ops}_{\\mathrm{dense}} = n_A \\cdot n_B \\cdot Q^2.\n$$\n- **Hierarchical Assembly**: For an admissible block, a low-rank representation is constructed. The cost is dominated by forming the low-rank factors and is given by the proxy:\n$$\n\\mathrm{ops}_{\\mathcal{H}} = r_{\\mathrm{num}} (n_A + n_B) Q + r_{\\mathrm{num}}^2.\n$$\nFor non-admissible blocks, no approximation is made, so $\\mathrm{ops}_{\\mathcal{H}} = \\mathrm{ops}_{\\mathrm{dense}}$.\n- **Speedup Proxy**: The estimated speedup is the ratio:\n$$\nS = \\frac{\\mathrm{ops}_{\\mathrm{dense}}}{\\mathrm{ops}_{\\mathcal{H}}}.\n$$\n\n### Algorithm Summary\nFor each test case, the following steps are executed:\n1.  Parse the case parameters: $k, \\varepsilon$, and cluster definitions ($s_A, n_A, s_B, n_B$).\n2.  Calculate derived geometric parameters: $\\operatorname{diam}(A)$, $\\operatorname{diam}(B)$, $\\operatorname{sep}(A,B)$, and $a$.\n3.  Determine if the block $(A,B)$ is admissible using the given condition with $\\eta=1$.\n4.  Calculate the predicted rank $r_{\\mathrm{pred}}$ using the specified formula, our choice of $\\alpha=1, \\beta=1$, and the appropriate rule for admissible/non-admissible blocks.\n5.  Assemble the dense block matrix $Z_{AB} \\in \\mathbb{C}^{n_A \\times n_B}$ using $Q$-point Gauss-Legendre quadrature, applying the singularity regularization for diagonal entries of the global matrix $Z$.\n6.  Compute the singular values of $Z_{AB}$.\n7.  Determine the numerical rank $r_{\\mathrm{num}}$ by finding the smallest rank satisfying the relative Frobenius error tolerance $\\varepsilon$.\n8.  Calculate the actual relative error $E_{\\mathrm{rel}}$ achieved with rank $r_{\\mathrm{num}}$.\n9.  Compute the operation count proxies $\\mathrm{ops}_{\\mathrm{dense}}$ and $\\mathrm{ops}_{\\mathcal{H}}$, and the speedup $S$.\n10. Format and collect the results $\\bigl[r_{\\mathrm{pred}},\\; r_{\\mathrm{num}},\\; E_{\\mathrm{rel}},\\; \\mathrm{ops}_{\\mathrm{dense}},\\; \\mathrm{ops}_{\\mathcal{H}},\\; S\\bigr]$.\n\nThis procedure is applied to all test cases to generate the final output.",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\nfrom scipy.linalg import svdvals\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to execute the analysis for all test cases.\n    \"\"\"\n    \n    # Global parameters\n    L = 1.0  # m\n    M = 64\n    Q = 8\n    eta = 1.0\n    h = L / M\n    delta_reg = 1e-6 * h\n\n    # Quadrature nodes and weights on [-1, 1]\n    quad_nodes, quad_weights = leggauss(Q)\n\n    # Test cases\n    test_cases = [\n        # k, eps, (s_A, n_A), (s_B, n_B)\n        (20.0, 1e-4, (0, 8), (24, 8)),\n        (5.0, 1e-6, (0, 8), (56, 8)),\n        (40.0, 1e-4, (16, 8), (24, 8)),\n        (20.0, 1e-5, (8, 8), (8, 8)),\n        (80.0, 1e-4, (0, 16), (32, 16)),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        k, eps, cluster_A_def, cluster_B_def = case\n        s_A, n_A = cluster_A_def\n        s_B, n_B = cluster_B_def\n        \n        # 1. Calculate cluster properties\n        diam_A = n_A * h\n        diam_B = n_B * h\n        \n        # Separation distance\n        # Interval for A: [s_A*h, (s_A+n_A)*h]\n        # Interval for B: [s_B*h, (s_B+n_B)*h]\n        gap = max(0, s_B - (s_A + n_A), s_A - (s_B + n_B))\n        sep_AB = gap * h\n        \n        # Admissibility check\n        a = max(diam_A, diam_B)\n        is_admissible = sep_AB >= eta * a\n        \n        # 2. Calculate predicted rank\n        if is_admissible:\n            if sep_AB > 0:\n                xi = sep_AB / a\n                alpha = 1.0  # Assumed constant of order unity\n                beta = 1.0   # Assumed constant of order unity\n                r_pred_raw = alpha * (k * a / xi) + beta * math.log(1.0 / eps)\n                r_pred = math.ceil(r_pred_raw)\n                r_pred = max(1, min(r_pred, n_A, n_B))\n            else: # sep_AB is 0, so should not be admissible, but as a fallback\n                r_pred = min(n_A, n_B)\n        else:\n            r_pred = min(n_A, n_B)\n\n        # 3. Assemble the block matrix Z_AB\n        Z_AB = np.zeros((n_A, n_B), dtype=np.complex128)\n        \n        for i_idx in range(n_A):\n            for j_idx in range(n_B):\n                i_global = s_A + i_idx\n                j_global = s_B + j_idx\n                \n                # Map quadrature points to panels i_global and j_global\n                x_nodes = (i_global + 0.5) * h + quad_nodes * h / 2.0\n                xp_nodes = (j_global + 0.5) * h + quad_nodes * h / 2.0\n                \n                integral_val = 0.0j\n                for p in range(Q):\n                    for q in range(Q):\n                        x = x_nodes[p]\n                        xp = xp_nodes[q]\n                        dist = abs(x - xp)\n                        \n                        # Apply regularization for singular term\n                        if i_global == j_global:\n                            dist = max(dist, delta_reg)\n                        \n                        if dist > 0:\n                            kernel_val = np.exp(-1j * k * dist) / (4 * np.pi * dist)\n                            integral_val += quad_weights[p] * quad_weights[q] * kernel_val\n                \n                Z_AB[i_idx, j_idx] = integral_val * (h / 2.0)**2\n\n        # 4. Compute SVD and numerical rank\n        s = svdvals(Z_AB)\n        s_sq_sorted = s**2\n        total_norm_sq = np.sum(s_sq_sorted)\n\n        r_num = min(n_A, n_B)\n        if total_norm_sq > 0:\n            trunc_err_sq = 0.0\n            found = False\n            for r in range(len(s) - 1, -1, -1):\n                trunc_err_sq += s_sq_sorted[r]\n                if np.sqrt(trunc_err_sq / total_norm_sq) > eps:\n                    r_num = r + 1\n                    found = True\n                    break\n            if not found: # All singular values can be truncated\n                r_num = 0\n\n        # 5. Calculate actual relative error for r_num\n        E_rel = 0.0\n        if total_norm_sq > 0:\n            err_sq_for_r_num = np.sum(s_sq_sorted[r_num:])\n            E_rel = np.sqrt(err_sq_for_r_num / total_norm_sq)\n        \n        # 6. Compute operation counts and speedup\n        ops_dense = n_A * n_B * (Q**2)\n        \n        if is_admissible:\n            ops_H = r_num * (n_A + n_B) * Q + r_num**2\n        else:\n            ops_H = ops_dense\n\n        # Prevent division by zero if ops_H is 0 (e.g., zero matrix, r_num=0)\n        speedup = ops_dense / ops_H if ops_H > 0 else float('inf')\n\n        # Convert to int where appropriate\n        r_pred = int(r_pred)\n        ops_dense = int(ops_dense)\n        ops_H = int(ops_H)\n        \n        results.append(f\"[{r_pred},{r_num},{E_rel:.6f},{ops_dense},{ops_H},{speedup:.6f}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}