{
    "hands_on_practices": [
        {
            "introduction": "A correct physical model of electromagnetic scattering must ensure that scattered waves propagate away from the object and do not spontaneously converge back upon it. This principle is mathematically enforced by the Sommerfeld radiation condition, which dictates the use of an \"outgoing\" Green's function in the volume integral equation (VIE). This exercise provides a concrete, one-dimensional demonstration of this fundamental concept by tasking you to compute and compare scattered fields generated by correct, incorrect, and numerically compromised Green's functions, and to quantify the resulting non-physical reflections .",
            "id": "3359707",
            "problem": "Consider the frequency-domain scattering of electromagnetic waves from a weakly inhomogeneous, isotropic dielectric in a homogeneous background, formulated via the Volume Integral Equation (VIE). Starting from Maxwell's equations in the frequency domain, one arrives at the Lippmann–Schwinger-type VIE for the electric field, where the dyadic Green's function enforces the Sommerfeld radiation condition. In a one-dimensional reduction that captures the essential behavior while remaining computationally tractable, one studies the scalar Helmholtz equation for a field $u(x)$ and background wavenumber $k$, with a compactly supported susceptibility profile $\\chi(x)$ representing a weak dielectric contrast. The scalar VIE under the first Born approximation can be written as\n$$\nu_{\\text{scat}}(x) \\approx k^2 \\int_{-\\infty}^{\\infty} \\chi(x')\\, u_{\\text{inc}}(x')\\, G(x - x')\\, \\mathrm{d}x',\n$$\nwhere $u_{\\text{inc}}(x) = e^{i k x}$ is the incident plane wave and $G(\\cdot)$ is the scalar Green's function associated with the one-dimensional Helmholtz operator. The correct enforcement of the Sommerfeld radiation condition requires the use of the outgoing fundamental solution\n$$\nG_{\\text{out}}(x) = \\frac{i}{2k}\\, e^{i k |x|},\n$$\nwhich satisfies $\\frac{\\mathrm{d}^2 G}{\\mathrm{d}x^2} + k^2 G = -\\delta(x)$ and radiates away from sources. A non-radiating (standing-wave) choice constructed by taking the real part of the outgoing solution is\n$$\nG_{\\text{stand}}(x) = \\operatorname{Re}\\left(\\frac{i}{2k} e^{i k |x|}\\right) = -\\frac{1}{2k}\\, \\sin(k |x|),\n$$\nwhich also satisfies $\\frac{\\mathrm{d}^2 G}{\\mathrm{d}x^2} + k^2 G = -\\delta(x)$ in the distributional sense, but violates the radiation condition by superposing incoming and outgoing components.\n\nIn numerical practice, one often truncates the computational domain or applies windowing approximations to accelerate the evaluation of VIE operators. Such finite-domain truncation can be emulated by imposing periodic images with period $L_{\\text{box}}$, effectively replacing the free-space Green's function by a periodic-image sum\n$$\nG_{\\text{per}}(x;\\,L_{\\text{box}},P) = \\sum_{p=-P}^{P} G_{\\text{out}}(x + p L_{\\text{box}}),\n$$\nwhich introduces spurious interactions from images of the scatterer and can manifest as artificial incoming waves (reflections) in observation regions.\n\nYour task is to implement a program that:\n1. Discretizes the susceptibility as a Gaussian,\n$$\n\\chi(x) = \\chi_0 \\exp\\!\\left(-\\frac{x^2}{2 \\sigma^2}\\right),\n$$\nsupported numerically on a finite interval $[-L_{\\text{scat}}/2,\\, L_{\\text{scat}}/2]$ in meters, with uniform grid spacing $\\Delta x$.\n2. Computes the scattered field $u_{\\text{scat}}(x)$ on a right-hand observation window $x \\in [x_{\\min}, x_{\\max}]$ using three operator choices:\n   - Outgoing free-space $G_{\\text{out}}$ (radiation enforced).\n   - Standing-wave $G_{\\text{stand}}$ (radiation violated).\n   - Outgoing periodic-image sum $G_{\\text{per}}$ with specified $L_{\\text{box}}$ and number of images $P$ (finite-domain truncation).\n3. Quantifies spurious reflections on the right by fitting the scattered field over the observation window to a two-mode model,\n$$\nu_{\\text{scat}}(x) \\approx A_{\\text{out}}\\, e^{i k x} + A_{\\text{in}}\\, e^{-i k x},\n$$\nvia complex least squares, and outputs the reflection ratio\n$r = \\frac{|A_{\\text{in}}|}{|A_{\\text{out}}|}$,\na dimensionless float. This ratio isolates the component corresponding to an incoming wave from $+\\infty$ on the right.\n\nUse the following fixed physical and numerical settings unless overridden in a test case: the distance unit is meters and wavenumber is in radians per meter. Let the background wavenumber be $k = 10$ (radians per meter). Use $\\chi_0 = 0.05$ (dimensionless), $\\sigma = 0.2$ meters, $L_{\\text{scat}} = 2.0$ meters, $\\Delta x = 0.002$ meters, $x_{\\min} = 5.0$ meters, $x_{\\max} = 6.0$ meters, and sample the observation window uniformly with a resolution compatible with $\\Delta x$.\n\nDesign a robust and numerically stable algorithm that:\n- Assembles the discrete Born operator by vectorized evaluation of the chosen Green's function over $|x - x'|$, multiplying by $k^2 \\chi(x') u_{\\text{inc}}(x') \\Delta x$, and summing over source points $x'$.\n- For the periodic-image case, uses the sum over images $p = -P,\\ldots,P$ of the outgoing kernel evaluated at $(x - x') + p L_{\\text{box}}$ to emulate finite-domain truncation.\n- Performs a complex least-squares fit to estimate $A_{\\text{out}}$ and $A_{\\text{in}}$ and returns $r$.\n\nTest Suite and Output Specification:\nCompute and report the reflection ratio $r$ for the following four test cases, which probe the enforcement of the radiation condition and the impact of finite-domain truncation:\n\n- Case 1 (Happy path, radiation enforced): $G = G_{\\text{out}}$.\n- Case 2 (Radiation violated): $G = G_{\\text{stand}}$.\n- Case 3 (Finite-domain truncation, mild): $G = G_{\\text{per}}$ with $L_{\\text{box}} = 20.0$ meters and $P = 1$.\n- Case 4 (Finite-domain truncation, severe): $G = G_{\\text{per}}$ with $L_{\\text{box}} = 8.0$ meters and $P = 3$.\n\nThe final output of your program must be a single line containing the four reflection ratios as a comma-separated list enclosed in square brackets, for example,\n$[\\text{r}_1,\\text{r}_2,\\text{r}_3,\\text{r}_4]$,\nwith each $\\text{r}_j$ reported as a floating-point number (dimensionless). No additional text should be printed. Angles are measured in radians throughout, and distances in meters; the output ratios are dimensionless and require no unit conversion or rounding to a specific number of significant figures, but they must be valid floating-point values.",
            "solution": "The user's problem is first assessed for validity.\n\n### Step 1: Extract Givens\n-   **Governing Equation**: The scalar volume integral equation (VIE) for the scattered field $u_{\\text{scat}}(x)$ under the first Born approximation is given by $u_{\\text{scat}}(x) \\approx k^2 \\int_{-\\infty}^{\\infty} \\chi(x')\\, u_{\\text{inc}}(x')\\, G(x - x')\\, \\mathrm{d}x'$.\n-   **Incident Field**: The incident plane wave is $u_{\\text{inc}}(x) = e^{i k x}$.\n-   **Susceptibility**: The susceptibility profile is a Gaussian, $\\chi(x) = \\chi_0 \\exp\\!\\left(-\\frac{x^2}{2 \\sigma^2}\\right)$, numerically supported on the interval $[-L_{\\text{scat}}/2,\\, L_{\\text{scat}}/2]$.\n-   **Green's Functions**:\n    1.  Outgoing (free-space): $G_{\\text{out}}(x) = \\frac{i}{2k}\\, e^{i k |x|}$.\n    2.  Standing-wave: $G_{\\text{stand}}(x) = -\\frac{1}{2k}\\, \\sin(k |x|)$.\n    3.  Periodic (for domain truncation emulation): $G_{\\text{per}}(x;\\,L_{\\text{box}},P) = \\sum_{p=-P}^{P} G_{\\text{out}}(x + p L_{\\text{box}})$.\n-   **Analysis Model**: The scattered field in the observation window is fitted to the model $u_{\\text{scat}}(x) \\approx A_{\\text{out}}\\, e^{i k x} + A_{\\text{in}}\\, e^{-i k x}$.\n-   **Quantity to Compute**: The reflection ratio $r = \\frac{|A_{\\text{in}}|}{|A_{\\text{out}}|}$.\n-   **Physical and Numerical Parameters**:\n    -   Background wavenumber: $k = 10$ rad/m.\n    -   Peak susceptibility: $\\chi_0 = 0.05$.\n    -   Gaussian width: $\\sigma = 0.2$ m.\n    -   Scatterer support length: $L_{\\text{scat}} = 2.0$ m.\n    -   Grid spacing: $\\Delta x = 0.002$ m.\n    -   Observation window: $[x_{\\min}, x_{\\max}] = [5.0, 6.0]$ m.\n-   **Test Cases**:\n    1.  $G = G_{\\text{out}}$.\n    2.  $G = G_{\\text{stand}}$.\n    3.  $G = G_{\\text{per}}$ with $L_{\\text{box}} = 20.0$ m, $P = 1$.\n    4.  $G = G_{\\text{per}}$ with $L_{\\text{box}} = 8.0$ m, $P = 3$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the principles of wave scattering theory and computational electromagnetics. The mathematical formulation, including the Lippmann-Schwinger equation, Helmholtz Green's functions, and the Born approximation, is standard and correct. The problem is well-posed, providing all necessary parameters and definitions to construct a numerical solution. The language is objective and precise. The test cases are designed to probe a fundamental physical concept—the Sommerfeld radiation condition—and a common numerical artifact, making the problem a meaningful exercise rather than a trivial calculation. The parameters are physically reasonable and lead to a computationally feasible task.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be developed.\n\n### Principle-Based Design of the Solution\n\nThe solution involves three main stages: discretizing the volume integral equation, computing the scattered field for different Green's functions, and analyzing the resulting field to quantify spurious reflections.\n\n**1. Discretization of the Integral Equation**\nThe core of the problem is the VIE, $u_{\\text{scat}}(x) \\approx \\int_{-\\infty}^{\\infty} G(x - x')\\, J(x')\\, \\mathrm{d}x'$, where we define the source density as $J(x') = k^2 \\chi(x') u_{\\text{inc}}(x')$. To solve this numerically, we employ a standard method-of-moments approach with point-matching (collocation) and a pulse basis, which simplifies to a Riemann sum.\n\nFirst, we define two discrete grids:\n-   A source grid, $x'_j$, that samples the scatterer region $[-L_{\\text{scat}}/2, L_{\\text{scat}}/2]$. The points are uniformly spaced with step $\\Delta x = 0.002$ m.\n-   An observation grid, $x_i$, that samples the observation window $[x_{\\min}, x_{\\max}] = [5.0, 6.0]$ m, also with spacing $\\Delta x$.\n\nThe continuous integral is approximated by the sum:\n$$\nu_{\\text{scat}}(x_i) \\approx \\sum_j G(x_i - x'_j)\\, J(x'_j)\\, \\Delta x\n$$\nThis can be expressed as a matrix-vector product. Let $\\mathbf{u}_{\\text{scat}}$ be a column vector of the scattered field values at points $x_i$, and $\\mathbf{J}$ be a column vector of the source density values $J(x'_j)$ at points $x'_j$. The equation becomes:\n$$\n\\mathbf{u}_{\\text{scat}} = \\mathbf{G} \\cdot \\mathbf{J} \\cdot \\Delta x\n$$\nwhere $\\mathbf{G}$ is a matrix whose elements are $G_{ij} = G(x_i - x'_j)$.\n\n**2. Assembling the Operator Matrix $\\mathbf{G}$**\nThe algorithm computes a different $\\mathbf{G}$ matrix for each of the four test cases.\n\n-   **Case 1: Outgoing Green's Function ($G_{\\text{out}}$)**\n    The matrix elements are populated using the formula for the correct radiating solution:\n    $G_{ij} = G_{\\text{out}}(x_i - x'_j) = \\frac{i}{2k} e^{i k |x_i - x'_j|}$. Physically, this ensures that energy scattered from any source point $x'_j$ propagates outward, away from the source, satisfying the Sommerfeld radiation condition.\n\n-   **Case 2: Standing-Wave Green's Function ($G_{\\text{stand}}$)**\n    The matrix elements use the non-radiating kernel:\n    $G_{ij} = G_{\\text{stand}}(x_i - x'_j) = -\\frac{1}{2k} \\sin(k |x_i - x'_j|)$.\n    This Green's function is the real part of $G_{\\text{out}}$ and represents a superposition of an outgoing wave and an incoming wave of equal amplitude. Its use violates the radiation condition and is expected to produce a scattered field with a significant non-physical incoming component.\n\n-   **Cases 3 & 4: Periodic Green's Function ($G_{\\text{per}}$)**\n    This formulation emulates the effect of truncating an infinite domain to a finite periodic one. The matrix elements are calculated by summing the contributions from the primary source and its periodic images:\n    $G_{ij} = G_{\\text{per}}(x_i - x'_j; L_{\\text{box}}, P) = \\sum_{p=-P}^{P} G_{\\text{out}}((x_i - x'_j) + p L_{\\text{box}})$.\n    Each term $p \\neq 0$ represents a spurious interaction with a periodic copy of the scatterer. These interactions manifest as waves arriving at the observation window from directions inconsistent with radiation from the true scatterer, creating artificial reflections. Case 3, with a large period $L_{\\text{box}} = 20.0$ m, should show small reflections. Case 4, with a smaller period $L_{\\text{box}} = 8.0$ m and more images, should show severe reflection artifacts.\n\n**3. Least-Squares Analysis for Reflection Ratio**\nAfter computing the discrete scattered field vector $\\mathbf{u}_{\\text{scat}}$ for a given case, we need to quantify the reflection. The scattered field in the observation window (which is in the far-field region to the right of the scatterer) is modeled as a superposition of a right-propagating (outgoing) wave and a left-propagating (incoming) wave:\n$$\nu_{\\text{scat}}(x_i) \\approx A_{\\text{out}}\\, e^{i k x_i} + A_{\\text{in}}\\, e^{-i k x_i}\n$$\nThis is a linear model for the unknown complex amplitudes $A_{\\text{out}}$ and $A_{\\text{in}}$. We can write this for all observation points as a linear system $\\mathbf{M} \\mathbf{a} \\approx \\mathbf{u}_{\\text{scat}}$, where:\n-   $\\mathbf{a} = [A_{\\text{out}}, A_{\\text{in}}]^T$ is the vector of unknown coefficients.\n-   $\\mathbf{M}$ is an $N_{\\text{obs}} \\times 2$ matrix whose columns are the basis functions evaluated at the observation points, i.e., $M_{i1} = e^{i k x_i}$ and $M_{i2} = e^{-i k x_i}$.\n\nThe coefficients $A_{\\text{out}}$ and $A_{\\text{in}}$ are found by solving this system in a complex least-squares sense, which minimizes the norm of the residual $||\\mathbf{M} \\mathbf{a} - \\mathbf{u}_{\\text{scat}}||^2$. The `numpy.linalg.lstsq` function is used for this purpose.\n\nFinally, the reflection ratio $r$ is computed as the ratio of the magnitudes of the incoming and outgoing wave amplitudes:\n$$\nr = \\frac{|A_{\\text{in}}|}{|A_{\\text{out}}|}\n$$\nThis value provides a quantitative measure of the violation of the radiation condition. For a perfectly outgoing wave, $r = 0$. For a pure standing wave, $r = 1$. The periodic cases will yield intermediate values depending on the severity of the spurious reflections.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes spurious reflection ratios for 1D electromagnetic scattering\n    using different Green's function formulations in a Volume Integral Equation.\n    \"\"\"\n\n    def calculate_reflection_ratio(G_type, G_params={}):\n        \"\"\"\n        Calculates the reflection ratio for a single numerical experiment.\n\n        Args:\n            G_type (str): The type of Green's function to use ('out', 'stand', 'per').\n            G_params (dict): Parameters for the Green's function, e.g., L_box and P.\n\n        Returns:\n            float: The computed reflection ratio r = |A_in| / |A_out|.\n        \"\"\"\n        # Define fixed physical and numerical settings\n        k = 10.0          # Wavenumber (rad/m)\n        chi0 = 0.05       # Peak susceptibility (dimensionless)\n        sigma = 0.2       # Gaussian width of susceptibility (m)\n        L_scat = 2.0      # Length of scatterer support (m)\n        dx = 0.002        # Grid spacing (m)\n        x_min_obs = 5.0   # Start of observation window (m)\n        x_max_obs = 6.0   # End of observation window (m)\n\n        # 1. Discretize domains\n        # Source grid (where the scatterer exists)\n        num_pts_scat = int(round(L_scat / dx)) + 1\n        x_prime = np.linspace(-L_scat / 2, L_scat / 2, num_pts_scat)\n\n        # Observation grid (where the scattered field is measured)\n        num_pts_obs = int(round((x_max_obs - x_min_obs) / dx)) + 1\n        x_obs = np.linspace(x_min_obs, x_max_obs, num_pts_obs)\n\n        # 2. Define the source density J(x') = k^2 * chi(x') * u_inc(x')\n        chi_profile = chi0 * np.exp(-x_prime**2 / (2 * sigma**2))\n        u_inc = np.exp(1j * k * x_prime)\n        source = k**2 * chi_profile * u_inc\n\n        # 3. Assemble the discrete Green's function operator matrix G\n        # G_ij = G(x_obs[i] - x_prime[j])\n        z = x_obs[:, None] - x_prime[None, :]\n\n        if G_type == 'out':\n            # Outgoing (radiating) Green's function\n            G_matrix = (1j / (2 * k)) * np.exp(1j * k * np.abs(z))\n        elif G_type == 'stand':\n            # Standing-wave (non-radiating) Green's function\n            G_matrix = (-1 / (2 * k)) * np.sin(k * np.abs(z))\n        elif G_type == 'per':\n            # Periodic sum of outgoing Green's functions\n            L_box = G_params['L_box']\n            P = G_params['P']\n            G_matrix = np.zeros_like(z, dtype=np.complex128)\n            p_range = np.arange(-P, P + 1)\n            for p in p_range:\n                z_shifted = z + p * L_box\n                G_matrix += (1j / (2 * k)) * np.exp(1j * k * np.abs(z_shifted))\n        else:\n            raise ValueError(f\"Unknown Green's function type: {G_type}\")\n\n        # 4. Compute the scattered field via discrete convolution\n        # u_scat = integral G(x-x') J(x') dx' -> sum_j G_ij * J_j * dx\n        u_scat = G_matrix @ source * dx\n\n        # 5. Perform least-squares fit to find A_out and A_in\n        # Model: u_scat(x) = A_out * exp(ikx) + A_in * exp(-ikx)\n        # This is a linear system: M * [A_out, A_in]^T = u_scat\n        M = np.stack([\n            np.exp(1j * k * x_obs),   # Basis function for outgoing wave\n            np.exp(-1j * k * x_obs)  # Basis function for incoming wave\n        ], axis=1)\n\n        # Solve for the coefficients [A_out, A_in]\n        coeffs, _, _, _ = np.linalg.lstsq(M, u_scat, rcond=None)\n        A_out, A_in = coeffs[0], coeffs[1]\n\n        # 6. Calculate the reflection ratio\n        # A_out should be non-zero for a non-trivial scatterer\n        if np.abs(A_out) == 0:\n            return np.inf if np.abs(A_in) > 0 else 0.0\n        \n        r = np.abs(A_in) / np.abs(A_out)\n        return r\n\n    # Define the test suite\n    test_cases = [\n        {'type': 'out', 'params': {}},\n        {'type': 'stand', 'params': {}},\n        {'type': 'per', 'params': {'L_box': 20.0, 'P': 1}},\n        {'type': 'per', 'params': {'L_box': 8.0, 'P': 3}}\n    ]\n\n    # Run all test cases and collect results\n    results = []\n    for case in test_cases:\n        ratio = calculate_reflection_ratio(case['type'], case['params'])\n        results.append(ratio)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "One of the most significant practical challenges in implementing volume integral equations is the numerical evaluation of singular integrals that arise in \"self-interaction\" terms. When the observation point lies within the source element, the Green's function kernel becomes singular, and standard quadrature rules fail. This practice introduces the Duffy transform, an elegant and powerful coordinate transformation that regularizes the integral by precisely canceling the kernel's singularity with a term from the transformation's Jacobian, rendering the integrand smooth and suitable for standard numerical integration techniques. You will implement this method for a tetrahedral element and validate its accuracy .",
            "id": "3359660",
            "problem": "Consider the time-harmonic Maxwell equations in free space and the associated free-space dyadic Green's function. The free-space scalar Green's function is defined by $g_k(\\mathbf{r}) = \\dfrac{e^{ik\\|\\mathbf{r}\\|}}{4\\pi\\|\\mathbf{r}\\|}$, and in the static limit $k \\to 0$ it reduces to $g_0(\\mathbf{r}) = \\dfrac{1}{4\\pi\\|\\mathbf{r}\\|}$. The free-space dyadic Green's function is given by $\\mathbf{G}_k(\\mathbf{r}) = \\left(\\mathbf{I} + \\dfrac{1}{k^2}\\nabla\\nabla\\right) g_k(\\mathbf{r})$, where $\\mathbf{I}$ is the identity dyad and $\\nabla\\nabla$ denotes the Hessian operator. In Volume Integral Equation formulations, integrals of the form $\\displaystyle \\int_T g_0(\\mathbf{r}-\\mathbf{r}_0)\\,\\mathrm{d}V$ and dyadic operations with $\\nabla\\nabla g_0$ over a tetrahedral element $T$ arise when the source point $\\mathbf{r}_0$ is inside $T$, leading to a weak and structured singularity at $\\mathbf{r}=\\mathbf{r}_0$.\n\nYou are tasked with implementing the Duffy transform on tetrahedral elements to regularize weakly singular integrals of the scalar kernel $g_0(\\mathbf{r})$ for the self-term (source point at a vertex). Specifically, work with a tetrahedron $T$ defined by vertices $(\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{v}_3)$ with the singularity located at the vertex $\\mathbf{v}_0$, and edges $\\mathbf{a}_1=\\mathbf{v}_1-\\mathbf{v}_0$, $\\mathbf{a}_2=\\mathbf{v}_2-\\mathbf{v}_0$, $\\mathbf{a}_3=\\mathbf{v}_3-\\mathbf{v}_0$. Use the Duffy mapping\n$$\n\\mathbf{r}(u,v,w) = \\mathbf{v}_0 + u\\,\\mathbf{a}_1 + u\\,v\\,\\mathbf{a}_2 + u\\,v\\,w\\,\\mathbf{a}_3,\n$$\nwith $u\\in[0,1]$, $v\\in[0,1]$, $w\\in[0,1]$, and the Jacobian determinant\n$$\nJ(u,v,w) = u^2 v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|.\n$$\nLet $\\mathbf{s}(v,w) = \\mathbf{a}_1 + v\\,\\mathbf{a}_2 + v\\,w\\,\\mathbf{a}_3$, so that $\\|\\mathbf{r}-\\mathbf{v}_0\\| = u\\,\\|\\mathbf{s}(v,w)\\|$.\n\n1) Derive from first principles the regularized integral for the scalar kernel over $T$ in the static limit,\n$I_{\\text{full}} = \\int_T g_0(\\mathbf{r}-\\mathbf{v}_0)\\,\\mathrm{d}V$,\nshowing that under the Duffy transform this becomes a smooth integral over $[0,1]^3$ and explicitly obtain the integrand in terms of $u$, $v$, $w$, $\\mathbf{s}(v,w)$, and $\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|$.\n\n2) Consider the analytic self-term obtained by excluding a small spherical neighborhood of radius $\\varepsilon$ around $\\mathbf{v}_0$ and integrating only over the trihedral cone defined by the rays $\\mathbf{a}_1$, $\\mathbf{a}_2$, $\\mathbf{a}_3$. Let $\\hat{\\mathbf{a}}_i = \\mathbf{a}_i / \\|\\mathbf{a}_i\\|$ be the unit direction vectors defining the trihedral cone at the vertex. The solid angle of this cone is\n$$\n\\Omega = 2\\,\\arctan\\!\\left(\\frac{\\left|\\det\\left[\\hat{\\mathbf{a}}_1\\ \\hat{\\mathbf{a}}_2\\ \\hat{\\mathbf{a}}_3\\right]\\right|}{1 + \\hat{\\mathbf{a}}_1\\cdot\\hat{\\mathbf{a}}_2 + \\hat{\\mathbf{a}}_2\\cdot\\hat{\\mathbf{a}}_3 + \\hat{\\mathbf{a}}_3\\cdot\\hat{\\mathbf{a}}_1}\\right),\n$$\nwith angles in radians. Show that the analytic self-term for the scalar kernel within the excluded spherical region intersected with the trihedral cone is\n$I_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) = \\frac{\\varepsilon^2}{2}\\,\\frac{\\Omega}{4\\pi}.$\n\n3) Using the Duffy transform, express the numerical integral for the contribution from the region inside the trihedral cone with $\\|\\mathbf{r}-\\mathbf{v}_0\\| \\le \\varepsilon$ as\n$$\nI_{\\text{ball}}^{\\text{numeric}}(\\varepsilon) = \\int_0^1\\!\\!\\int_0^1 \\left[\\int_0^{u_{\\max}(v,w)} \\frac{1}{4\\pi u\\|\\mathbf{s}(v,w)\\|}\\, u^2 v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|\\,\\mathrm{d}u \\right] \\mathrm{d}v\\,\\mathrm{d}w,\n$$\nwhere $u_{\\max}(v,w) = \\min\\!\\left(1,\\,\\dfrac{\\varepsilon}{\\|\\mathbf{s}(v,w)\\|}\\right)$. Simplify the inner integral with respect to $u$ to obtain a numerically convenient expression. Similarly, write\n$$\nI_{\\text{rest}}^{\\text{numeric}}(\\varepsilon) = \\int_0^1\\!\\!\\int_0^1 \\left[\\int_{u_{\\max}(v,w)}^{1} \\frac{1}{4\\pi u\\|\\mathbf{s}(v,w)\\|}\\, u^2 v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|\\,\\mathrm{d}u \\right] \\mathrm{d}v\\,\\mathrm{d}w,\n$$\nand verify numerically that $I_{\\text{full}} \\approx I_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) + I_{\\text{rest}}^{\\text{numeric}}(\\varepsilon)$ to high accuracy for small $\\varepsilon$.\n\nYour program must implement high-order numerical quadrature in $v$ and $w$ using Gauss-Legendre rules mapped to $[0,1]$ and perform the $u$-integral analytically after Duffy regularization using the derived expressions.\n\nTest Suite:\nUse the following tetrahedra and exclusion radii $(\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{v}_3,\\varepsilon)$:\n- Case 1 (regular-like tetrahedron):\n  - $\\mathbf{v}_0 = (0,0,0)$,\n  - $\\mathbf{v}_1 = (1,0,0)$,\n  - $\\mathbf{v}_2 = \\left(\\dfrac{1}{2}, \\dfrac{\\sqrt{3}}{2}, 0\\right)$,\n  - $\\mathbf{v}_3 = \\left(\\dfrac{1}{2}, \\dfrac{\\sqrt{3}}{6}, \\sqrt{\\dfrac{2}{3}}\\right)$,\n  - $\\varepsilon = 0.05$.\n- Case 2 (skew tetrahedron):\n  - $\\mathbf{v}_0 = (0,0,0)$,\n  - $\\mathbf{v}_1 = (2.0, 0.1, 0.0)$,\n  - $\\mathbf{v}_2 = (0.2, 1.5, -0.1)$,\n  - $\\mathbf{v}_3 = (-0.1, 0.3, 0.9)$,\n  - $\\varepsilon = 0.02$.\n- Case 3 (small tetrahedron):\n  - $\\mathbf{v}_0 = (0,0,0)$,\n  - $\\mathbf{v}_1 = (10^{-3}, 0, 0)$,\n  - $\\mathbf{v}_2 = (0, 10^{-3}, 0)$,\n  - $\\mathbf{v}_3 = (0, 0, 2\\cdot 10^{-3})$,\n  - $\\varepsilon = 10^{-5}$.\n\nFinal Output:\nYour program should produce a single line of output containing six floating-point numbers corresponding to the absolute errors for each case, in the order:\n`[E1(1),E2(1),E1(2),E2(2),E1(3),E2(3)]`,\nwhere for case $i$,\n- $E_{1}^{(i)} = \\left|I_{\\text{ball}}^{\\text{numeric}}(\\varepsilon) - I_{\\text{ball}}^{\\text{analytic}}(\\varepsilon)\\right|$,\n- $E_{2}^{(i)} = \\left|I_{\\text{full}} - \\left(I_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) + I_{\\text{rest}}^{\\text{numeric}}(\\varepsilon)\\right)\\right|$.\nAll angles must be treated in radians. No physical units are required; all quantities are dimensionless values resulting from the chosen coordinates and $\\varepsilon$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[result1,result2,...]`).",
            "solution": "The problem is subjected to validation before proceeding to a solution.\n\n### Step 1: Extract Givens\n- **Scalar Green's function (static limit)**: $g_0(\\mathbf{r}) = \\dfrac{1}{4\\pi\\|\\mathbf{r}\\|}$.\n- **Integral to evaluate**: $I_{\\text{full}} = \\displaystyle \\int_T g_0(\\mathbf{r}-\\mathbf{v}_0)\\,\\mathrm{d}V$, where $T$ is a tetrahedron with vertices $(\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{v}_3)$ and the singularity is at $\\mathbf{v}_0$.\n- **Edge vectors**: $\\mathbf{a}_1=\\mathbf{v}_1-\\mathbf{v}_0$, $\\mathbf{a}_2=\\mathbf{v}_2-\\mathbf{v}_0$, $\\mathbf{a}_3=\\mathbf{v}_3-\\mathbf{v}_0$.\n- **Duffy mapping**: $\\mathbf{r}(u,v,w) = \\mathbf{v}_0 + u\\,\\mathbf{a}_1 + u\\,v\\,\\mathbf{a}_2 + u\\,v\\,w\\,\\mathbf{a}_3$, for $u,v,w \\in[0,1]$.\n- **Jacobian determinant**: $J(u,v,w) = u^2 v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|$.\n- **Auxiliary vector and distance**: $\\mathbf{s}(v,w) = \\mathbf{a}_1 + v\\,\\mathbf{a}_2 + v\\,w\\,\\mathbf{a}_3$, such that $\\|\\mathbf{r}-\\mathbf{v}_0\\| = u\\,\\|\\mathbf{s}(v,w)\\|$.\n- **Solid angle formula**: $\\Omega = 2\\,\\arctan\\!\\left(\\frac{\\left|\\det\\left[\\hat{\\mathbf{a}}_1\\ \\hat{\\mathbf{a}}_2\\ \\hat{\\mathbf{a}}_3\\right]\\right|}{1 + \\hat{\\mathbf{a}}_1\\cdot\\hat{\\mathbf{a}}_2 + \\hat{\\mathbf{a}}_2\\cdot\\hat{\\mathbf{a}}_3 + \\hat{\\mathbf{a}}_3\\cdot\\hat{\\mathbf{a}}_1}\\right)$, with $\\hat{\\mathbf{a}}_i = \\mathbf{a}_i / \\|\\mathbf{a}_i\\|$.\n- **Analytic self-term**: $I_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) = \\frac{\\varepsilon^2}{2}\\,\\frac{\\Omega}{4\\pi}$.\n- **Numerical integral definitions**: $I_{\\text{ball}}^{\\text{numeric}}(\\varepsilon)$ and $I_{\\text{rest}}^{\\text{numeric}}(\\varepsilon)$ over sub-domains defined by $u_{\\max}(v,w) = \\min\\!\\left(1,\\,\\dfrac{\\varepsilon}{\\|\\mathbf{s}(v,w)\\|}\\right)$.\n- **Test cases and error metrics**: Three sets of tetrahedral vertices and exclusion radii $\\varepsilon$ are provided. Two error metrics, $E_{1}$ and $E_{2}$, are to be computed.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is analyzed against the validation criteria.\n- **Scientifically Grounded**: The problem is founded on established principles of computational electromagnetics, specifically the boundary element method and volume integral equations. The Duffy transform is a standard, mathematically sound technique for regularizing singular integrals over simplices. The formulas for the Green's function and solid angle are correct.\n- **Well-Posed**: All necessary information is provided. The definitions, transformations, and goals are clear, precise, and lead to a unique, computable solution.\n- **Objective**: The language is formal and unbiased. The problem requires mathematical derivation and numerical computation, not subjective interpretation.\n\nNo flaws are found. The problem is complete, consistent, and scientifically valid.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A full solution will be provided.\n\n### Solution Derivations and Numerical Strategy\n\nThe solution is presented in three parts, corresponding to the tasks outlined in the problem statement.\n\n**Part 1: Regularization of the Full Integral using the Duffy Transform**\n\nThe objective is to regularize the weakly singular integral\n$$\nI_{\\text{full}} = \\int_T g_0(\\mathbf{r}-\\mathbf{v}_0)\\,\\mathrm{d}V = \\int_T \\frac{1}{4\\pi\\|\\mathbf{r}-\\mathbf{v}_0\\|}\\,\\mathrm{d}V.\n$$\nThe singularity occurs at $\\mathbf{r} = \\mathbf{v}_0$, where the denominator vanishes. We apply the given Duffy coordinate transformation to map the tetrahedron $T$ in $(\\mathbf{r})$ space to the unit cube $[0,1]^3$ in $(u,v,w)$ space.\nThe transformation is $\\mathbf{r}(u,v,w) = \\mathbf{v}_0 + u\\,\\mathbf{a}_1 + u\\,v\\,\\mathbf{a}_2 + u\\,v\\,w\\,\\mathbf{a}_3$.\nThe position vector relative to the singular point is $\\mathbf{r}-\\mathbf{v}_0 = u(\\mathbf{a}_1 + v\\,\\mathbf{a}_2 + v\\,w\\,\\mathbf{a}_3) = u\\,\\mathbf{s}(v,w)$.\nThe distance to the singular point is thus $\\|\\mathbf{r}-\\mathbf{v}_0\\| = u\\,\\|\\mathbf{s}(v,w)\\|$, for $u \\ge 0$.\nThe differential volume element transforms according to $\\mathrm{d}V = |J(u,v,w)|\\,\\mathrm{d}u\\,\\mathrm{d}v\\,\\mathrm{d}w$, where the Jacobian determinant is given as $J(u,v,w) = u^2 v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|$. It is non-negative over the integration domain.\n\nSubstituting these into the integral expression:\n$$\nI_{\\text{full}} = \\int_0^1 \\int_0^1 \\int_0^1 \\frac{1}{4\\pi u\\|\\mathbf{s}(v,w)\\|} \\left( u^2 v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right| \\right) \\,\\mathrm{d}u\\,\\mathrm{d}v\\,\\mathrm{d}w.\n$$\nThe factor of $u$ in the denominator cancels with one factor of $u$ from the Jacobian's $u^2$ term. The resulting integrand is:\n$$\n\\text{Integrand} = \\frac{u\\,v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|}{4\\pi \\|\\mathbf{s}(v,w)\\|}.\n$$\nThis integrand is now regular. The potential singularity at $u=0$ has been removed, as the integrand is now zero at $u=0$. For a non-degenerate tetrahedron, $\\|\\mathbf{s}(v,w)\\|>0$ over the integration domain, so the denominator is well-behaved. The integral becomes:\n$$\nI_{\\text{full}} = \\int_0^1 \\int_0^1 \\int_0^1 \\frac{u\\,v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|}{4\\pi \\|\\mathbf{s}(v,w)\\|} \\,\\mathrm{d}u\\,\\mathrm{d}v\\,\\mathrm{d}w.\n$$\nThis is a smooth integral over the unit cube, suitable for numerical quadrature.\n\n**Part 2: Analytic Self-Term in a Small Spherical Neighborhood**\n\nWe are asked to show that the integral of $g_0(\\mathbf{r}-\\mathbf{v}_0)$ over the intersection of a sphere of radius $\\varepsilon$ centered at $\\mathbf{v}_0$ and the trihedral cone formed by the tetrahedron's vertex equals $I_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) = \\frac{\\varepsilon^2}{2}\\,\\frac{\\Omega}{4\\pi}$.\n\nLet the region of integration be $V_\\varepsilon$, which is the part of the ball $B_\\varepsilon(\\mathbf{v}_0)$ that lies inside the cone. We use spherical coordinates $(\\rho, \\theta, \\phi)$ centered at $\\mathbf{v}_0$, so $\\rho = \\|\\mathbf{r}-\\mathbf{v}_0\\|$. The differential volume element is $\\mathrm{d}V = \\rho^2 \\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi = \\rho^2 \\mathrm{d}\\Omega'$, where $\\mathrm{d}\\Omega'$ is the differential solid angle.\nThe integral is:\n$$\nI_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) = \\int_{V_\\varepsilon} \\frac{1}{4\\pi\\rho} \\mathrm{d}V = \\int_{\\text{cone}} \\left( \\int_0^\\varepsilon \\frac{1}{4\\pi\\rho} \\rho^2\\,\\mathrm{d}\\rho \\right) \\mathrm{d}\\Omega'.\n$$\nFirst, we evaluate the radial integral:\n$$\n\\int_0^\\varepsilon \\frac{\\rho}{4\\pi}\\,\\mathrm{d}\\rho = \\frac{1}{4\\pi} \\left[ \\frac{\\rho^2}{2} \\right]_0^\\varepsilon = \\frac{\\varepsilon^2}{8\\pi}.\n$$\nThis result is a constant with respect to the angular integration. Now, we integrate over the solid angle $\\Omega$ of the cone:\n$$\nI_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) = \\int_{\\text{cone}} \\frac{\\varepsilon^2}{8\\pi} \\mathrm{d}\\Omega' = \\frac{\\varepsilon^2}{8\\pi} \\int_{\\text{cone}} \\mathrm{d}\\Omega' = \\frac{\\varepsilon^2}{8\\pi} \\Omega.\n$$\nThis can be written as $\\frac{\\varepsilon^2}{2} \\frac{\\Omega}{4\\pi}$, which confirms the given formula.\n\n**Part 3: Numerical Evaluation and Verification**\n\nThe integral $I_{\\text{full}}$ can be split into two parts: one over the region where $\\|\\mathbf{r}-\\mathbf{v}_0\\| \\le \\varepsilon$ (inside the ball, $I_{\\text{ball}}$) and one where $\\|\\mathbf{r}-\\mathbf{v}_0\\| > \\varepsilon$ (rest of the volume, $I_{\\text{rest}}$). In Duffy coordinates, the condition $\\|\\mathbf{r}-\\mathbf{v}_0\\| \\le \\varepsilon$ becomes $u\\|\\mathbf{s}(v,w)\\| \\le \\varepsilon$, or $u \\le \\varepsilon/\\|\\mathbf{s}(v,w)\\|$. Since we also require $u \\le 1$, the upper integration limit for the ball region is $u_{\\max}(v,w) = \\min\\left(1, \\frac{\\varepsilon}{\\|\\mathbf{s}(v,w)\\|}\\right)$.\n\nThe integral over $u$ can be performed analytically. Let $C(v,w) = \\frac{v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|}{4\\pi \\|\\mathbf{s}(v,w)\\|}$. The integrand is $C(v,w) u$.\n\nFor $I_{\\text{full}}$, we integrate $u$ from $0$ to $1$:\n$$\n\\int_0^1 C(v,w) u\\,\\mathrm{d}u = C(v,w) \\left[\\frac{u^2}{2}\\right]_0^1 = \\frac{C(v,w)}{2}.\n$$\nThus, the integrand for the $(v,w)$ quadrature for $I_{\\text{full}}$ is $\\frac{v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|}{8\\pi \\|\\mathbf{s}(v,w)\\|}$.\n\nFor $I_{\\text{ball}}^{\\text{numeric}}(\\varepsilon)$, we integrate $u$ from $0$ to $u_{\\max}$:\n$$\n\\int_0^{u_{\\max}} C(v,w) u\\,\\mathrm{d}u = C(v,w) \\left[\\frac{u^2}{2}\\right]_0^{u_{\\max}} = \\frac{C(v,w)}{2} (u_{\\max})^2.\n$$\nThe integrand for the $(v,w)$ quadrature is $\\frac{v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|}{8\\pi \\|\\mathbf{s}(v,w)\\|} \\left(u_{\\max}(v,w)\\right)^2$.\n\nFor $I_{\\text{rest}}^{\\text{numeric}}(\\varepsilon)$, we integrate $u$ from $u_{\\max}$ to $1$:\n$$\n\\int_{u_{\\max}}^1 C(v,w) u\\,\\mathrm{d}u = C(v,w) \\left[\\frac{u^2}{2}\\right]_{u_{\\max}}^1 = \\frac{C(v,w)}{2} (1 - (u_{\\max})^2).\n$$\nThe integrand for the $(v,w)$ quadrature is $\\frac{v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|}{8\\pi \\|\\mathbf{s}(v,w)\\|} \\left(1 - \\left(u_{\\max}(v,w)\\right)^2\\right)$.\n\nThe remaining two-dimensional integrals over $(v,w) \\in [0,1]^2$ are smooth and can be accurately computed using a high-order Gauss-Legendre quadrature rule. By construction, the numerical evaluation will exactly satisfy $I_{\\text{full}}^{\\text{numeric}} = I_{\\text{ball}}^{\\text{numeric}}(\\varepsilon) + I_{\\text{rest}}^{\\text{numeric}}(\\varepsilon)$ up to machine precision. Consequently, the two error metrics to be computed,\n$$\nE_1 = \\left|I_{\\text{ball}}^{\\text{numeric}}(\\varepsilon) - I_{\\text{ball}}^{\\text{analytic}}(\\varepsilon)\\right|\n$$\n$$\nE_2 = \\left|I_{\\text{full}}^{\\text{numeric}} - \\left(I_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) + I_{\\text{rest}}^{\\text{numeric}}(\\varepsilon)\\right)\\right|\n$$\nwill also be identical up to machine precision, because\n$E_2 = \\left|(I_{\\text{ball}}^{\\text{numeric}} + I_{\\text{rest}}^{\\text{numeric}}) - (I_{\\text{ball}}^{\\text{analytic}} + I_{\\text{rest}}^{\\text{numeric}})\\right| = \\left|I_{\\text{ball}}^{\\text{numeric}} - I_{\\text{ball}}^{\\text{analytic}}\\right| = E_1$.\nThe magnitude of these errors indicates how well the analytical solid-angle-based formula for the near-field contribution matches the result from a robust numerical integration method. A small error validates both the analytical formula and the numerical implementation.\nThe implementation will use a 2D tensor product of a 32-point Gauss-Legendre rule mapped to the interval $[0,1]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef get_gauss_legendre_quadrature(n):\n    \"\"\"\n    Returns points and weights for Gauss-Legendre quadrature on [0, 1].\n    \n    Args:\n        n (int): The number of quadrature points.\n        \n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: Quadrature points in [0, 1].\n            - np.ndarray: Quadrature weights for the [0, 1] interval.\n    \"\"\"\n    points, weights = roots_legendre(n)\n    # Map from [-1, 1] to [0, 1]\n    mapped_points = (points + 1.0) / 2.0\n    mapped_weights = weights / 2.0\n    return mapped_points, mapped_weights\n\ndef compute_errors(v0, v1, v2, v3, eps, Np=32):\n    \"\"\"\n    Computes the integral errors E1 and E2 for a given tetrahedron.\n    \n    Args:\n        v0, v1, v2, v3 (tuple): Coordinates of the tetrahedron vertices.\n        eps (float): Radius of the exclusion sphere.\n        Np (int): Number of points for Gauss-Legendre quadrature.\n        \n    Returns:\n        tuple: A tuple containing the errors (E1, E2).\n    \"\"\"\n    # Define edge vectors a_i from the singular vertex v0\n    a1 = np.array(v1) - np.array(v0)\n    a2 = np.array(v2) - np.array(v0)\n    a3 = np.array(v3) - np.array(v0)\n    \n    # The matrix A is formed by the edge vectors as columns\n    A_matrix = np.array([a1, a2, a3]).T\n    det_A = np.linalg.det(A_matrix)\n    \n    # === Part 1: Analytic Ball Integral Calculation ===\n    \n    # Normalize edge vectors\n    norm_a1 = np.linalg.norm(a1)\n    norm_a2 = np.linalg.norm(a2)\n    norm_a3 = np.linalg.norm(a3)\n    \n    a1_hat = a1 / norm_a1 if norm_a1 > 0 else a1\n    a2_hat = a2 / norm_a2 if norm_a2 > 0 else a2\n    a3_hat = a3 / norm_a3 if norm_a3 > 0 else a3\n\n    # Determinant of normalized vectors\n    A_hat_matrix = np.array([a1_hat, a2_hat, a3_hat]).T\n    det_A_hat = np.linalg.det(A_hat_matrix)\n    \n    # Dot products for the solid angle formula\n    dot12 = np.dot(a1_hat, a2_hat)\n    dot23 = np.dot(a2_hat, a3_hat)\n    dot31 = np.dot(a3_hat, a1_hat)\n    \n    # Solid angle calculation using the given formula\n    omega_numerator = np.abs(det_A_hat)\n    omega_denominator = 1.0 + dot12 + dot23 + dot31\n    if omega_denominator <= 0:\n        # This case should not happen for a valid, convex trihedral angle\n        solid_angle_Omega = np.pi if omega_numerator > 0 else 0\n    else:\n        solid_angle_Omega = 2.0 * np.arctan(omega_numerator / omega_denominator)\n    \n    i_ball_analytic = (eps**2 / 2.0) * (solid_angle_Omega / (4.0 * np.pi))\n\n    # === Part 2: Numerical Integration using Duffy Transform ===\n    \n    points, weights = get_gauss_legendre_quadrature(Np)\n    v_points, w_points = points, points\n    v_weights, w_weights = weights, weights\n    \n    i_full_numeric = 0.0\n    i_ball_numeric = 0.0\n    i_rest_numeric = 0.0\n    \n    for i in range(Np):\n        v = v_points[i]\n        wv = v_weights[i]\n        for j in range(Np):\n            w = w_points[j]\n            ww = w_weights[j]\n            \n            # Calculate s(v, w) and its norm\n            s_vec = a1 + v * a2 + v * w * a3\n            norm_s = np.linalg.norm(s_vec)\n            \n            # Common factor from analytic integration over u\n            common_factor = v * np.abs(det_A) / (8.0 * np.pi * norm_s)\n            \n            # Integrand for I_full (after u-integration)\n            # The original u-integral is C * u, from 0 to 1, giving C * 1/2.\n            # C = v * |det| / (4 * pi * ||s||), so C/2 = common_factor\n            integrand_full = common_factor  # Note: The problem had ∫ u du * ..., this is the result of that\n                                             # For I_full, the integral of u from 0 to 1 is 1/2.\n                                             # So we multiply by 2 to get the original C factor, and integrate u^2/2 to get final result.\n                                             # No, the code is integrating the already u-integrated kernel.\n                                             # f_full_integrand(v,w) = v*|det|/(8*pi*||s||) \n            i_full_numeric += wv * ww * integrand_full\n            \n            # Calculate u_max for splitting the integral\n            u_max = min(1.0, eps / norm_s)\n            \n            # Add contributions to ball and rest integrals\n            i_ball_numeric += wv * ww * (common_factor * u_max**2)\n            i_rest_numeric += wv * ww * (common_factor * (1.0 - u_max**2))\n            \n    # === Part 3: Error Calculation ===\n    \n    e1 = np.abs(i_ball_numeric - i_ball_analytic)\n    e2 = np.abs(i_full_numeric - (i_ball_analytic + i_rest_numeric))\n    \n    return e1, e2\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (regular-like tetrahedron)\n        {\n            \"v0\": (0.0, 0.0, 0.0),\n            \"v1\": (1.0, 0.0, 0.0),\n            \"v2\": (0.5, np.sqrt(3.0)/2.0, 0.0),\n            \"v3\": (0.5, np.sqrt(3.0)/6.0, np.sqrt(2.0/3.0)),\n            \"eps\": 0.05\n        },\n        # Case 2 (skew tetrahedron)\n        {\n            \"v0\": (0.0, 0.0, 0.0),\n            \"v1\": (2.0, 0.1, 0.0),\n            \"v2\": (0.2, 1.5, -0.1),\n            \"v3\": (-0.1, 0.3, 0.9),\n            \"eps\": 0.02\n        },\n        # Case 3 (small tetrahedron)\n        {\n            \"v0\": (0.0, 0.0, 0.0),\n            \"v1\": (1.0e-3, 0.0, 0.0),\n            \"v2\": (0.0, 1.0e-3, 0.0),\n            \"v3\": (0.0, 0.0, 2.0e-3),\n            \"eps\": 1.0e-5\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        e1, e2 = compute_errors(\n            case[\"v0\"], case[\"v1\"], case[\"v2\"], case[\"v3\"], case[\"eps\"]\n        )\n        results.extend([e1, e2])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The stability and physical accuracy of a VIE formulation depend critically on the choice of basis functions used to represent the unknown fields. While simple, node-based interpolations are tempting, they often fail to respect the underlying structure of Maxwell's equations, leading to the generation of non-physical, or \"spurious,\" modes that contaminate the solution. This advanced exercise uses Fourier analysis to provide a clear theoretical demonstration of this phenomenon, contrasting a naive nodal discretization with a proper curl-conforming approach. By analyzing the system's eigenvalues, you will see precisely why function spaces that correctly handle the curl operator are essential for robust electromagnetic simulations .",
            "id": "3359681",
            "problem": "Consider the frequency-domain vector Volume Integral Equation (VIE) for time-harmonic electromagnetic scattering of the electric field $\\mathbf{E}(\\mathbf{r})$ by a homogeneous, isotropic inclusion with electric susceptibility $\\chi$ embedded in a homogeneous background of wavenumber $k_0$. The VIE can be written in terms of the scalar Helmholtz Green convolution and the gradient operator, starting from Maxwell’s equations and the constitutive relation for polarization. Work within a periodic cubic domain of side length $L$ (in meters), and represent fields by discrete Fourier modes indexed by integer triplets $\\mathbf{n} = (n_x,n_y,n_z)$ with $n_x,n_y,n_z \\in \\{-N/2,\\ldots,N/2-1\\}$ (where $N$ is an even integer). Define the corresponding wavevector as $\\mathbf{g} = \\frac{2\\pi}{L}\\mathbf{n}$ and its squared magnitude as $g^2 = \\lVert \\mathbf{g} \\rVert^2$.\n\nYour task is to demonstrate, in a mathematically controlled setting that is faithful to the VIE structure, how a nodal volumetric discretization (not conforming to the curl operator) produces spurious resonances that are absent in a curl-conforming edge-based discretization. To do this, follow the steps below:\n\n- Starting from the fundamental Maxwell curl-curl equation, the vector Helmholtz operator, and the vector Lippmann–Schwinger representation (all standard and well-tested in computational electromagnetics), derive in the Fourier domain an operator symbol for the homogeneous inclusion case that acts on each Fourier mode $\\mathbf{g}$. Show that a curl-conforming edge-based discretization is equivalent to an operator that acts differently on the transverse and longitudinal subspaces relative to $\\mathbf{g}$. Conclude that the longitudinal component is not resonant in this formulation.\n\n- Construct a “naive” nodal discretization surrogate that treats the integral kernel as if it were a scalar Helmholtz Green convolution times the identity dyad, thereby failing to enforce the Helmholtz decomposition or any $\\nabla \\times$-conforming constraint. Derive the per-mode operator symbol under this surrogate and show that it acts identically on transverse and longitudinal components, creating additional non-physical (spurious) resonances in the longitudinal subspace.\n\n- For a periodic grid of size $N \\times N \\times N$ with even $N$, define the set of integer triplets $\\mathbf{n}$ as above and let $m(\\mathbf{n}) = n_x^2 + n_y^2 + n_z^2$. For a given $k_0$ and $L$, introduce the dimensionless parameter $s = \\left(\\frac{k_0 L}{2\\pi}\\right)^2$. Using your derived operator symbols:\n  1. Obtain the longitudinal eigenvalue for the curl-conforming edge-based operator, denoted $\\lambda_L^{\\mathrm{edge}}$, as a function of $\\chi$. Show it does not depend on $m(\\mathbf{n})$ and does not create resonances for $\\chi > -1$.\n  2. Obtain the longitudinal eigenvalue for the naive nodal operator, denoted $\\lambda_L^{\\mathrm{nodal}}(m)$, as a function of $m(\\mathbf{n})$ and $\\chi$, and determine the condition on $m(\\mathbf{n})$ under which $\\lambda_L^{\\mathrm{nodal}}(m)$ vanishes (spurious resonance).\n  3. Define the spurious resonance count $\\Delta$ as the number of Fourier modes (counting all integer triplets $\\mathbf{n}$ in the prescribed range) for which $\\lambda_L^{\\mathrm{nodal}}(m)$ is numerically zero while $\\lambda_L^{\\mathrm{edge}}$ is not numerically zero. Use a strict numerical zero test with a tolerance $\\tau$; treat an eigenvalue as zero if its absolute value is strictly less than $\\tau$.\n\n- Physical and numerical units: use $L$ in meters and $k_0$ in radians per meter. Angles are in radians. The susceptibility $\\chi$ is dimensionless. The spurious resonance count $\\Delta$ is a unitless integer.\n\n- Implement a program that computes $\\Delta$ for each of the test cases below. Use the exact integer lattice described. When building the per-mode longitudinal eigenvalues, express them in terms of $m(\\mathbf{n})$ and $s$ to avoid floating-point cancellation. Use the strict zero test with tolerance $\\tau$ as given in each test case. If a denominator equal to zero appears in the nodal longitudinal eigenvalue formula for some $m(\\mathbf{n})$, skip that mode for zero-testing (it neither contributes to nor subtracts from the count).\n\nTest suite (each tuple is $(N,L,k_0,\\chi,\\tau)$):\n\n- Case $1$: $(8,\\,1\\,\\text{m},\\,4\\pi\\,\\text{rad/m},\\,0.5,\\,10^{-12})$.\n- Case $2$: $(8,\\,1\\,\\text{m},\\,4\\pi\\,\\text{rad/m},\\,1.0,\\,10^{-12})$.\n- Case $3$: $(8,\\,1\\,\\text{m},\\,4\\pi\\,\\text{rad/m},\\,0.3,\\,10^{-12})$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[result1,result2,result3]`), where each result is the integer $\\Delta$ for the corresponding test case, in the same order as above. The expected unit for each reported $\\Delta$ is “count” (unitless integer). The output must contain no other text.",
            "solution": "The problem requires a comparative analysis of two different discretization approaches for the frequency-domain Volume Integral Equation (VIE) in electromagnetics, specifically to demonstrate the emergence of spurious, non-physical resonances in a naive nodal discretization. We will first derive the operator symbols for a curl-conforming edge-based discretization and a naive nodal discretization in the Fourier domain. Subsequently, we will derive the conditions for spurious resonances and implement a program to count them for the given test cases.\n\n### Fundamental Formulation\n\nThe time-harmonic electric field $\\mathbf{E}(\\mathbf{r})$ within a homogeneous, isotropic dielectric scatterer of susceptibility $\\chi$ embedded in a background with wavenumber $k_0$ is described by the Lippmann-Schwinger Volume Integral Equation. Neglecting the incident field to analyze the system's intrinsic modes, the equation is:\n$$ \\mathbf{E}(\\mathbf{r}) = k_0^2 \\chi \\int_V \\bar{\\mathbf{G}}_0(\\mathbf{r}, \\mathbf{r}') \\cdot \\mathbf{E}(\\mathbf{r}') \\, dV' $$\nwhere $\\bar{\\mathbf{G}}_0(\\mathbf{r}, \\mathbf{r}')$ is the dyadic Green's function of the background medium, which satisfies $(\\nabla \\times \\nabla \\times - k_0^2 \\mathbf{I}) \\bar{\\mathbf{G}}_0 = \\mathbf{I} \\delta(\\mathbf{r}-\\mathbf{r}')$. In a periodic domain of side $L$, we work in the Fourier domain where fields and operators are represented by their discrete Fourier series coefficients. A spatial position $\\mathbf{r}$ corresponds to a set of Fourier modes indexed by integer triplets $\\mathbf{n} = (n_x, n_y, n_z)$, with a corresponding wavevector $\\mathbf{g} = \\frac{2\\pi}{L}\\mathbf{n}$. Under the Fourier transform, the convolution becomes a product:\n$$ \\hat{\\mathbf{E}}(\\mathbf{g}) = k_0^2 \\chi \\hat{\\bar{\\mathbf{G}}}_0(\\mathbf{g}) \\cdot \\hat{\\mathbf{E}}(\\mathbf{g}) $$\nThis can be written as a homogeneous linear system for each mode $\\mathbf{g}$:\n$$ \\left[ \\mathbf{I} - k_0^2 \\chi \\hat{\\bar{\\mathbf{G}}}_0(\\mathbf{g}) \\right] \\hat{\\mathbf{E}}(\\mathbf{g}) = \\mathbf{0} $$\nA non-trivial solution (a resonance or mode) exists if the operator $\\mathbf{A}(\\mathbf{g}) = \\mathbf{I} - k_0^2 \\chi \\hat{\\bar{\\mathbf{G}}}_0(\\mathbf{g})$ is singular, i.e., if it has a zero eigenvalue.\n\n### Curl-Conforming (Edge-Based) Discretization Operator\n\nA curl-conforming discretization, correctly representing the structure of Maxwell's equations, corresponds to using the full dyadic Green's function. The Fourier transform of the dyadic Green's function derived from the vector Helmholtz equation is:\n$$ \\hat{\\bar{\\mathbf{G}}}_0(\\mathbf{g}) = \\left( \\mathbf{I} + \\frac{1}{k_0^2} \\nabla\\nabla \\right) \\hat{G}_0(\\mathbf{g}) \\xrightarrow{\\mathcal{F}} \\left( \\mathbf{I} - \\frac{\\mathbf{g}\\mathbf{g}^T}{k_0^2} \\right) \\frac{1}{g^2 - k_0^2} $$\nwhere $g^2 = \\lVert\\mathbf{g}\\rVert^2$ and $\\mathbf{g}\\mathbf{g}^T$ is the outer product dyad. Note that for $\\mathbf{g}=0$, this form is indeterminate, but we consider $\\mathbf{g} \\neq \\mathbf{0}$.\n\nThis operator acts differently on vector components that are longitudinal (parallel to $\\mathbf{g}$) and transverse (perpendicular to $\\mathbf{g}$). Let $\\hat{\\mathbf{E}} = \\hat{\\mathbf{E}}_L + \\hat{\\mathbf{E}}_T$.\nFor a transverse vector $\\hat{\\mathbf{E}}_T$ (where $\\mathbf{g} \\cdot \\hat{\\mathbf{E}}_T = 0$):\n$$ \\hat{\\bar{\\mathbf{G}}}_0(\\mathbf{g}) \\cdot \\hat{\\mathbf{E}}_T = \\frac{1}{g^2 - k_0^2} \\left( \\mathbf{I} - \\frac{\\mathbf{g}\\mathbf{g}^T}{k_0^2} \\right) \\hat{\\mathbf{E}}_T = \\frac{1}{g^2 - k_0^2} (\\hat{\\mathbf{E}}_T - \\mathbf{0}) = \\frac{1}{g^2 - k_0^2} \\hat{\\mathbf{E}}_T $$\nFor a longitudinal vector $\\hat{\\mathbf{E}}_L$ (where $\\hat{\\mathbf{E}}_L = \\alpha \\mathbf{g}$ for some scalar $\\alpha$):\n$$ \\hat{\\bar{\\mathbf{G}}}_0(\\mathbf{g}) \\cdot \\hat{\\mathbf{E}}_L = \\frac{1}{g^2 - k_0^2} \\left( \\mathbf{I} - \\frac{\\mathbf{g}\\mathbf{g}^T}{k_0^2} \\right) \\hat{\\mathbf{E}}_L = \\frac{1}{g^2 - k_0^2}} \\left(\\hat{\\mathbf{E}}_L - \\frac{\\mathbf{g}(\\mathbf{g} \\cdot \\hat{\\mathbf{E}}_L)}{k_0^2}\\right) = \\frac{1}{g^2 - k_0^2} \\left(\\hat{\\mathbf{E}}_L - \\frac{g^2}{k_0^2}\\hat{\\mathbf{E}}_L\\right) = \\frac{1 - g^2/k_0^2}{g^2 - k_0^2} \\hat{\\mathbf{E}}_L = -\\frac{1}{k_0^2} \\hat{\\mathbf{E}}_L $$\nThe system operator for this curl-conforming formulation, $\\mathbf{A}^{\\mathrm{edge}}(\\mathbf{g}) = \\mathbf{I} - k_0^2 \\chi \\hat{\\bar{\\mathbf{G}}}_0(\\mathbf{g})$, thus has distinct eigenvalues for each subspace. The longitudinal eigenvalue, requested as $\\lambda_L^{\\mathrm{edge}}$, is:\n$$ \\lambda_L^{\\mathrm{edge}} = 1 - k_0^2 \\chi \\left( -\\frac{1}{k_0^2} \\right) = 1 + \\chi $$\nThis eigenvalue depends only on the material susceptibility $\\chi$ and not on the mode index $\\mathbf{n}$ (or $m(\\mathbf{n})$). A resonance occurs if $\\lambda_L^{\\mathrm{edge}} = 0$, which implies $\\chi = -1$. For any $\\chi > -1$, as specified in the problem, $\\lambda_L^{\\mathrm{edge}} \\neq 0$. Therefore, this formulation correctly predicts no non-physical (spurious) longitudinal resonances.\n\n### Naive Nodal Discretization Operator\n\nA \"naive\" nodal discretization fails to respect the curl-conforming structure. The problem models this by treating the integral kernel as a scalar Green's function $G_0$ times the identity dyad $\\mathbf{I}$. This surrogate Green's function is $\\bar{\\mathbf{G}}_{\\text{naive}} = G_0 \\mathbf{I}$. In the Fourier domain, this becomes:\n$$ \\hat{\\bar{\\mathbf{G}}}_{\\text{naive}}(\\mathbf{g}) = \\hat{G}_0(\\mathbf{g}) \\mathbf{I} = \\frac{1}{g^2 - k_0^2} \\mathbf{I} $$\nThis operator is a scalar multiple of the identity dyad $\\mathbf{I}$, meaning it acts identically on all vector components, regardless of their orientation to $\\mathbf{g}$. The system operator for the naive formulation is:\n$$ \\mathbf{A}^{\\mathrm{nodal}}(\\mathbf{g}) = \\mathbf{I} - k_0^2 \\chi \\hat{\\bar{\\mathbf{G}}}_{\\text{naive}}(\\mathbf{g}) = \\left( 1 - \\frac{k_0^2 \\chi}{g^2 - k_0^2} \\right) \\mathbf{I} $$\nThis operator has a single, degenerate eigenvalue that applies to both transverse and longitudinal components. The longitudinal eigenvalue is thus:\n$$ \\lambda_L^{\\mathrm{nodal}}(\\mathbf{g}) = 1 - \\frac{k_0^2 \\chi}{g^2 - k_0^2} $$\nTo express this in terms of the problem's dimensionless parameters, we use $g^2 = \\left(\\frac{2\\pi}{L}\\right)^2 m(\\mathbf{n})$ and $k_0^2 = s \\left(\\frac{2\\pi}{L}\\right)^2$, where $m(\\mathbf{n})=n_x^2+n_y^2+n_z^2$ and $s = \\left(\\frac{k_0 L}{2\\pi}\\right)^2$.\n$$ \\lambda_L^{\\mathrm{nodal}}(m) = 1 - \\frac{s \\left(\\frac{2\\pi}{L}\\right)^2 \\chi}{m(\\mathbf{n}) \\left(\\frac{2\\pi}{L}\\right)^2 - s \\left(\\frac{2\\pi}{L}\\right)^2} = 1 - \\frac{s\\chi}{m(\\mathbf{n}) - s} = \\frac{m(\\mathbf{n}) - s(1+\\chi)}{m(\\mathbf{n}) - s} $$\n\n### Spurious Resonance Condition and Counting\n\nA spurious longitudinal resonance occurs when $\\lambda_L^{\\mathrm{nodal}}(m) = 0$. From the expression above, this requires the numerator to be zero (and the denominator to be non-zero):\n$$ m(\\mathbf{n}) - s(1+\\chi) = 0 \\implies m(\\mathbf{n}) = s(1+\\chi) $$\nSince $m(\\mathbf{n})$ is the sum of three squared integers, it must be an integer. Therefore, a spurious resonance can only occur if the value $s(1+\\chi)$ is an integer.\n\nThe task is to compute the spurious resonance count $\\Delta$, defined as the number of Fourier modes $\\mathbf{n}$ for which $\\lambda_L^{\\mathrm{nodal}}$ is numerically zero while $\\lambda_L^{\\mathrm{edge}}$ is not. For the given test cases with $\\chi > 0$, $\\lambda_L^{\\mathrm{edge}} = 1+\\chi$ is never zero. Thus, we only need to count the modes where $|\\lambda_L^{\\mathrm{nodal}}(m(\\mathbf{n}))| < \\tau$. Given that $m(\\mathbf{n})$ is an integer, this condition is only practically met if $m(\\mathbf{n})$ is equal to an integer value that $s(1+\\chi)$ represents.\n\nThe computational procedure is as follows:\n1. For a given test case $(N, L, k_0, \\chi, \\tau)$, calculate $s = \\left(\\frac{k_0 L}{2\\pi}\\right)^2$.\n2. Calculate the resonance target value $M_{\\text{res}} = s(1+\\chi)$.\n3. If $M_{\\text{res}}$ is not an integer (i.e., $|M_{\\text{res}} - \\text{round}(M_{\\text{res}})| \\ge \\tau$), then no integer $m(\\mathbf{n})$ can satisfy the resonance condition, so $\\Delta = 0$.\n4. If $M_{\\text{res}}$ is numerically an integer, let this integer be $M_{\\text{target}} = \\text{round}(M_{\\text{res}})$. We then count all integer triplets $\\mathbf{n}=(n_x, n_y, n_z)$ with components in $\\{-N/2, \\dots, N/2-1\\}$ such that:\n   a. $m(\\mathbf{n}) = n_x^2 + n_y^2 + n_z^2 = M_{\\text{target}}$.\n   b. The denominator condition $m(\\mathbf{n}) - s \\neq 0$ is satisfied. If $M_{\\text{target}} = s$, these modes would not be counted even if resonant; however, for $\\chi>0$, $M_{\\text{target}} = s(1+\\chi) > s$, so this exclusion is not triggered for resonant modes. We must exclude any non-resonant modes where $m(\\mathbf{n})=s$ during the check.\n\nThis procedure correctly identifies and counts the spurious modes introduced by the naive discretization.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the spurious resonance count Delta for each test case.\n    \"\"\"\n    # Test suite (each tuple is (N, L, k_0, chi, tau)):\n    test_cases = [\n        # Case 1: (8, 1 m, 4*pi rad/m, 0.5, 1e-12)\n        (8, 1.0, 4.0 * np.pi, 0.5, 1e-12),\n        # Case 2: (8, 1 m, 4*pi rad/m, 1.0, 1e-12)\n        (8, 1.0, 4.0 * np.pi, 1.0, 1e-12),\n        # Case 3: (8, 1 m, 4*pi rad/m, 0.3, 1e-12)\n        (8, 1.0, 4.0 * np.pi, 0.3, 1e-12),\n    ]\n\n    results = []\n    for N, L, k0, chi, tau in test_cases:\n        # Calculate the dimensionless parameter s\n        s = (k0 * L / (2.0 * np.pi))**2\n\n        # Calculate the target m_res value for spurious resonance from m - s(1+chi) = 0\n        m_res_target = s * (1.0 + chi)\n\n        delta_count = 0\n\n        # Check if m_res_target is numerically an integer.\n        # If not, no integer m(n) can cause a resonance, so the count is 0.\n        # A small tolerance is used for this floating-point comparison.\n        m_target_int = int(round(m_res_target))\n        if abs(m_res_target - m_target_int) < tau:\n            # m_res_target is an integer. We now count the modes n for which m(n) = m_target_int.\n            \n            # The edge-based longitudinal eigenvalue lambda_L^edge = 1 + chi.\n            # For chi > -1, this is never zero. The problem statement's chi values are all positive.\n            # We must check |1 + chi| >= tau, which holds for all test cases.\n            if abs(1.0 + chi) < tau:\n                # This case is not expected but included for completeness.\n                # If lambda_L^edge is also zero, it's not a spurious resonance.\n                results.append(0)\n                continue\n\n            # Define the range for integer indices n_x, n_y, n_z\n            # For even N, range is {-N/2, ..., N/2 - 1}\n            idx_min = -N // 2\n            idx_max = N // 2\n            idx_range = range(idx_min, idx_max)\n            \n            count_for_case = 0\n            for nx in idx_range:\n                for ny in idx_range:\n                    for nz in idx_range:\n                        m_n = nx**2 + ny**2 + nz**2\n\n                        # Per problem statement, skip modes where the denominator (m-s) is zero.\n                        # Using a small tolerance for floating point comparison.\n                        if abs(m_n - s) < 1e-9:\n                            continue\n\n                        # Check if m_n matches the integer target for resonance.\n                        if m_n == m_target_int:\n                            # This mode exhibits a spurious resonance.\n                            count_for_case += 1\n            \n            delta_count = count_for_case\n        else:\n            # m_res_target is not an integer, so no integer m(n) can match it.\n            delta_count = 0\n            \n        results.append(delta_count)\n\n    # Format the final output as a single line: a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}