{
    "hands_on_practices": [
        {
            "introduction": "This practice addresses a cornerstone challenge in volume integral equation methods: the accurate numerical evaluation of singular integrals. When the observation point lies within the source domain, the Green's function kernel becomes singular, requiring specialized techniques to render the integral tractable. This exercise will guide you through the implementation of the Duffy transform, a powerful coordinate mapping that regularizes the weak singularity of the static Green's function over a tetrahedral element, making it amenable to standard high-order quadrature rules .",
            "id": "3359660",
            "problem": "Consider the time-harmonic Maxwell equations in free space and the associated free-space dyadic Green's function. The free-space scalar Green's function is defined by $g_k(\\mathbf{r}) = \\dfrac{e^{ik\\|\\mathbf{r}\\|}}{4\\pi\\|\\mathbf{r}\\|}$, and in the static limit $k \\to 0$ it reduces to $g_0(\\mathbf{r}) = \\dfrac{1}{4\\pi\\|\\mathbf{r}\\|}$. The free-space dyadic Green's function is given by $\\mathbf{G}_k(\\mathbf{r}) = \\left(\\mathbf{I} + \\dfrac{1}{k^2}\\nabla\\nabla\\right) g_k(\\mathbf{r})$, where $\\mathbf{I}$ is the identity dyad and $\\nabla\\nabla$ denotes the Hessian operator. In Volume Integral Equation formulations, integrals of the form $\\displaystyle \\int_T g_0(\\mathbf{r}-\\mathbf{r}_0)\\,\\mathrm{d}V$ and dyadic operations with $\\nabla\\nabla g_0$ over a tetrahedral element $T$ arise when the source point $\\mathbf{r}_0$ is inside $T$, leading to a weak and structured singularity at $\\mathbf{r}=\\mathbf{r}_0$.\n\nYou are tasked with implementing the Duffy transform on tetrahedral elements to regularize weakly singular integrals of the scalar kernel $g_0(\\mathbf{r})$ for the self-term (source point at a vertex). Specifically, work with a tetrahedron $T$ defined by vertices $(\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{v}_3)$ with the singularity located at the vertex $\\mathbf{v}_0$, and edges $\\mathbf{a}_1=\\mathbf{v}_1-\\mathbf{v}_0$, $\\mathbf{a}_2=\\mathbf{v}_2-\\mathbf{v}_0$, $\\mathbf{a}_3=\\mathbf{v}_3-\\mathbf{v}_0$. Use the Duffy mapping\n$$\n\\mathbf{r}(u,v,w) = \\mathbf{v}_0 + u\\,\\mathbf{a}_1 + u\\,v\\,\\mathbf{a}_2 + u\\,v\\,w\\,\\mathbf{a}_3,\n$$\nwith $u\\in[0,1]$, $v\\in[0,1]$, $w\\in[0,1]$, and the Jacobian determinant\n$$\nJ(u,v,w) = u^2 v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|.\n$$\nLet $\\mathbf{s}(v,w) = \\mathbf{a}_1 + v\\,\\mathbf{a}_2 + v\\,w\\,\\mathbf{a}_3$, so that $\\|\\mathbf{r}-\\mathbf{v}_0\\| = u\\,\\|\\mathbf{s}(v,w)\\|$.\n\n1) Derive from first principles the regularized integral for the scalar kernel over $T$ in the static limit,\n$$\nI_{\\text{full}} = \\int_T g_0(\\mathbf{r}-\\mathbf{v}_0)\\,\\mathrm{d}V,\n$$\nshowing that under the Duffy transform this becomes a smooth integral over $[0,1]^3$ and explicitly obtain the integrand in terms of $u$, $v$, $w$, $\\mathbf{s}(v,w)$, and $\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|$.\n\n2) Consider the analytic self-term obtained by excluding a small spherical neighborhood of radius $\\varepsilon$ around $\\mathbf{v}_0$ and integrating only over the trihedral cone defined by the rays $\\mathbf{a}_1$, $\\mathbf{a}_2$, $\\mathbf{a}_3$. Let $\\hat{\\mathbf{a}}_i = \\mathbf{a}_i / \\|\\mathbf{a}_i\\|$ be the unit direction vectors defining the trihedral cone at the vertex. The solid angle of this cone is\n$$\n\\Omega = 2\\,\\arctan\\!\\left(\\frac{\\left|\\det\\left[\\hat{\\mathbf{a}}_1\\ \\hat{\\mathbf{a}}_2\\ \\hat{\\mathbf{a}}_3\\right]\\right|}{1 + \\hat{\\mathbf{a}}_1\\cdot\\hat{\\mathbf{a}}_2 + \\hat{\\mathbf{a}}_2\\cdot\\hat{\\mathbf{a}}_3 + \\hat{\\mathbf{a}}_3\\cdot\\hat{\\mathbf{a}}_1}\\right),\n$$\nwith angles in radians. Show that the analytic self-term for the scalar kernel within the excluded spherical region intersected with the trihedral cone is\n$$\nI_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) = \\frac{\\varepsilon^2}{2}\\,\\frac{\\Omega}{4\\pi}.\n$$\n\n3) Using the Duffy transform, express the numerical integral for the contribution from the region inside the trihedral cone with $\\|\\mathbf{r}-\\mathbf{v}_0\\| \\le \\varepsilon$ as\n$$\nI_{\\text{ball}}^{\\text{numeric}}(\\varepsilon) = \\int_0^1\\!\\!\\int_0^1 \\left[\\int_0^{u_{\\max}(v,w)} \\frac{1}{4\\pi u\\|\\mathbf{s}(v,w)\\|}\\, u^2 v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|\\,\\mathrm{d}u \\right] \\mathrm{d}v\\,\\mathrm{d}w,\n$$\nwhere $u_{\\max}(v,w) = \\min\\!\\left(1,\\,\\dfrac{\\varepsilon}{\\|\\mathbf{s}(v,w)\\|}\\right)$. Simplify the inner integral with respect to $u$ to obtain a numerically convenient expression. Similarly, write\n$$\nI_{\\text{rest}}^{\\text{numeric}}(\\varepsilon) = \\int_0^1\\!\\!\\int_0^1 \\left[\\int_{u_{\\max}(v,w)}^{1} \\frac{1}{4\\pi u\\|\\mathbf{s}(v,w)\\|}\\, u^2 v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|\\,\\mathrm{d}u \\right] \\mathrm{d}v\\,\\mathrm{d}w,\n$$\nand verify numerically that $I_{\\text{full}} \\approx I_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) + I_{\\text{rest}}^{\\text{numeric}}(\\varepsilon)$ to high accuracy for small $\\varepsilon$.\n\nYour program must implement high-order numerical quadrature in $v$ and $w$ using Gauss-Legendre rules mapped to $[0,1]$ and perform the $u$-integral analytically after Duffy regularization using the derived expressions.\n\nTest Suite:\nUse the following tetrahedra and exclusion radii $(\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{v}_3,\\varepsilon)$:\n- Case 1 (regular-like tetrahedron):\n  - $\\mathbf{v}_0 = (0,0,0)$,\n  - $\\mathbf{v}_1 = (1,0,0)$,\n  - $\\mathbf{v}_2 = \\left(\\dfrac{1}{2}, \\dfrac{\\sqrt{3}}{2}, 0\\right)$,\n  - $\\mathbf{v}_3 = \\left(\\dfrac{1}{2}, \\dfrac{\\sqrt{3}}{6}, \\sqrt{\\dfrac{2}{3}}\\right)$,\n  - $\\varepsilon = 0.05$.\n- Case 2 (skew tetrahedron):\n  - $\\mathbf{v}_0 = (0,0,0)$,\n  - $\\mathbf{v}_1 = (2.0, 0.1, 0.0)$,\n  - $\\mathbf{v}_2 = (0.2, 1.5, -0.1)$,\n  - $\\mathbf{v}_3 = (-0.1, 0.3, 0.9)$,\n  - $\\varepsilon = 0.02$.\n- Case 3 (small tetrahedron):\n  - $\\mathbf{v}_0 = (0,0,0)$,\n  - $\\mathbf{v}_1 = (10^{-3}, 0, 0)$,\n  - $\\mathbf{v}_2 = (0, 10^{-3}, 0)$,\n  - $\\mathbf{v}_3 = (0, 0, 2\\cdot 10^{-3})$,\n  - $\\varepsilon = 10^{-5}$.\n\nFinal Output:\nYour program should produce a single line of output containing six floating-point numbers corresponding to the absolute errors for each case, in the order:\n$[E_{1}^{(1)},E_{2}^{(1)},E_{1}^{(2)},E_{2}^{(2)},E_{1}^{(3)},E_{2}^{(3)}]$,\nwhere for case $i$,\n- $E_{1}^{(i)} = \\left|I_{\\text{ball}}^{\\text{numeric}}(\\varepsilon) - I_{\\text{ball}}^{\\text{analytic}}(\\varepsilon)\\right|$,\n- $E_{2}^{(i)} = \\left|I_{\\text{full}} - \\left(I_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) + I_{\\text{rest}}^{\\text{numeric}}(\\varepsilon)\\right)\\right|$.\nAll angles must be treated in radians. No physical units are required; all quantities are dimensionless values resulting from the chosen coordinates and $\\varepsilon$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\").",
            "solution": "The problem is subjected to validation before proceeding to a solution.\n\n### Step 1: Extract Givens\n- **Scalar Green's function (static limit)**: $g_0(\\mathbf{r}) = \\dfrac{1}{4\\pi\\|\\mathbf{r}\\|}$.\n- **Integral to evaluate**: $I_{\\text{full}} = \\displaystyle \\int_T g_0(\\mathbf{r}-\\mathbf{v}_0)\\,\\mathrm{d}V$, where $T$ is a tetrahedron with vertices $(\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{v}_3)$ and the singularity is at $\\mathbf{v}_0$.\n- **Edge vectors**: $\\mathbf{a}_1=\\mathbf{v}_1-\\mathbf{v}_0$, $\\mathbf{a}_2=\\mathbf{v}_2-\\mathbf{v}_0$, $\\mathbf{a}_3=\\mathbf{v}_3-\\mathbf{v}_0$.\n- **Duffy mapping**: $\\mathbf{r}(u,v,w) = \\mathbf{v}_0 + u\\,\\mathbf{a}_1 + u\\,v\\,\\mathbf{a}_2 + u\\,v\\,w\\,\\mathbf{a}_3$, for $u,v,w \\in[0,1]$.\n- **Jacobian determinant**: $J(u,v,w) = u^2 v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|$.\n- **Auxiliary vector and distance**: $\\mathbf{s}(v,w) = \\mathbf{a}_1 + v\\,\\mathbf{a}_2 + v\\,w\\,\\mathbf{a}_3$, such that $\\|\\mathbf{r}-\\mathbf{v}_0\\| = u\\,\\|\\mathbf{s}(v,w)\\|$.\n- **Solid angle formula**: $\\Omega = 2\\,\\arctan\\!\\left(\\frac{\\left|\\det\\left[\\hat{\\mathbf{a}}_1\\ \\hat{\\mathbf{a}}_2\\ \\hat{\\mathbf{a}}_3\\right]\\right|}{1 + \\hat{\\mathbf{a}}_1\\cdot\\hat{\\mathbf{a}}_2 + \\hat{\\mathbf{a}}_2\\cdot\\hat{\\mathbf{a}}_3 + \\hat{\\mathbf{a}}_3\\cdot\\hat{\\mathbf{a}}_1}\\right)$, with $\\hat{\\mathbf{a}}_i = \\mathbf{a}_i / \\|\\mathbf{a}_i\\|$.\n- **Analytic self-term**: $I_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) = \\frac{\\varepsilon^2}{2}\\,\\frac{\\Omega}{4\\pi}$.\n- **Numerical integral definitions**: $I_{\\text{ball}}^{\\text{numeric}}(\\varepsilon)$ and $I_{\\text{rest}}^{\\text{numeric}}(\\varepsilon)$ over sub-domains defined by $u_{\\max}(v,w) = \\min\\!\\left(1,\\,\\dfrac{\\varepsilon}{\\|\\mathbf{s}(v,w)\\|}\\right)$.\n- **Test cases and error metrics**: Three sets of tetrahedral vertices and exclusion radii $\\varepsilon$ are provided. Two error metrics, $E_{1}$ and $E_{2}$, are to be computed.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is analyzed against the validation criteria.\n- **Scientifically Grounded**: The problem is founded on established principles of computational electromagnetics, specifically the boundary element method and volume integral equations. The Duffy transform is a standard, mathematically sound technique for regularizing singular integrals over simplices. The formulas for the Green's function and solid angle are correct.\n- **Well-Posed**: All necessary information is provided. The definitions, transformations, and goals are clear, precise, and lead to a unique, computable solution.\n- **Objective**: The language is formal and unbiased. The problem requires mathematical derivation and numerical computation, not subjective interpretation.\n\nNo flaws are found. The problem is complete, consistent, and scientifically valid.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A full solution will be provided.\n\n### Solution Derivations and Numerical Strategy\n\nThe solution is presented in three parts, corresponding to the tasks outlined in the problem statement.\n\n**Part 1: Regularization of the Full Integral using the Duffy Transform**\n\nThe objective is to regularize the weakly singular integral\n$$\nI_{\\text{full}} = \\int_T g_0(\\mathbf{r}-\\mathbf{v}_0)\\,\\mathrm{d}V = \\int_T \\frac{1}{4\\pi\\|\\mathbf{r}-\\mathbf{v}_0\\|}\\,\\mathrm{d}V.\n$$\nThe singularity occurs at $\\mathbf{r} = \\mathbf{v}_0$, where the denominator vanishes. We apply the given Duffy coordinate transformation to map the tetrahedron $T$ in $(\\mathbf{r})$ space to the unit cube $[0,1]^3$ in $(u,v,w)$ space.\nThe transformation is $\\mathbf{r}(u,v,w) = \\mathbf{v}_0 + u\\,\\mathbf{a}_1 + u\\,v\\,\\mathbf{a}_2 + u\\,v\\,w\\,\\mathbf{a}_3$.\nThe position vector relative to the singular point is $\\mathbf{r}-\\mathbf{v}_0 = u(\\mathbf{a}_1 + v\\,\\mathbf{a}_2 + v\\,w\\,\\mathbf{a}_3) = u\\,\\mathbf{s}(v,w)$.\nThe distance to the singular point is thus $\\|\\mathbf{r}-\\mathbf{v}_0\\| = u\\,\\|\\mathbf{s}(v,w)\\|$, for $u \\ge 0$.\nThe differential volume element transforms according to $\\mathrm{d}V = |J(u,v,w)|\\,\\mathrm{d}u\\,\\mathrm{d}v\\,\\mathrm{d}w$, where the Jacobian determinant is given as $J(u,v,w) = u^2 v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|$. It is non-negative over the integration domain.\n\nSubstituting these into the integral expression:\n$$\nI_{\\text{full}} = \\int_0^1 \\int_0^1 \\int_0^1 \\frac{1}{4\\pi u\\|\\mathbf{s}(v,w)\\|} \\left( u^2 v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right| \\right) \\,\\mathrm{d}u\\,\\mathrm{d}v\\,\\mathrm{d}w.\n$$\nThe factor of $u$ in the denominator cancels with one factor of $u$ from the Jacobian's $u^2$ term. The resulting integrand is:\n$$\n\\text{Integrand} = \\frac{u\\,v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|}{4\\pi \\|\\mathbf{s}(v,w)\\|}.\n$$\nThis integrand is now regular. The potential singularity at $u=0$ has been removed, as the integrand is now zero at $u=0$. For a non-degenerate tetrahedron, $\\|\\mathbf{s}(v,w)\\|>0$ over the integration domain, so the denominator is well-behaved. The integral becomes:\n$$\nI_{\\text{full}} = \\int_0^1 \\int_0^1 \\int_0^1 \\frac{u\\,v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|}{4\\pi \\|\\mathbf{s}(v,w)\\|} \\,\\mathrm{d}u\\,\\mathrm{d}v\\,\\mathrm{d}w.\n$$\nThis is a smooth integral over the unit cube, suitable for numerical quadrature.\n\n**Part 2: Analytic Self-Term in a Small Spherical Neighborhood**\n\nWe are asked to show that the integral of $g_0(\\mathbf{r}-\\mathbf{v}_0)$ over the intersection of a sphere of radius $\\varepsilon$ centered at $\\mathbf{v}_0$ and the trihedral cone formed by the tetrahedron's vertex equals $I_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) = \\frac{\\varepsilon^2}{2}\\,\\frac{\\Omega}{4\\pi}$.\n\nLet the region of integration be $V_\\varepsilon$, which is the part of the ball $B_\\varepsilon(\\mathbf{v}_0)$ that lies inside the cone. We use spherical coordinates $(\\rho, \\theta, \\phi)$ centered at $\\mathbf{v}_0$, so $\\rho = \\|\\mathbf{r}-\\mathbf{v}_0\\|$. The differential volume element is $\\mathrm{d}V = \\rho^2 \\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi = \\rho^2 \\mathrm{d}\\Omega'$, where $\\mathrm{d}\\Omega'$ is the differential solid angle.\nThe integral is:\n$$\nI_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) = \\int_{V_\\varepsilon} \\frac{1}{4\\pi\\rho} \\mathrm{d}V = \\int_{\\text{cone}} \\left( \\int_0^\\varepsilon \\frac{1}{4\\pi\\rho} \\rho^2\\,\\mathrm{d}\\rho \\right) \\mathrm{d}\\Omega'.\n$$\nFirst, we evaluate the radial integral:\n$$\n\\int_0^\\varepsilon \\frac{\\rho}{4\\pi}\\,\\mathrm{d}\\rho = \\frac{1}{4\\pi} \\left[ \\frac{\\rho^2}{2} \\right]_0^\\varepsilon = \\frac{\\varepsilon^2}{8\\pi}.\n$$\nThis result is a constant with respect to the angular integration. Now, we integrate over the solid angle $\\Omega$ of the cone:\n$$\nI_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) = \\int_{\\text{cone}} \\frac{\\varepsilon^2}{8\\pi} \\mathrm{d}\\Omega' = \\frac{\\varepsilon^2}{8\\pi} \\int_{\\text{cone}} \\mathrm{d}\\Omega' = \\frac{\\varepsilon^2}{8\\pi} \\Omega.\n$$\nThis can be written as $\\frac{\\varepsilon^2}{2} \\frac{\\Omega}{4\\pi}$, which confirms the given formula.\n\n**Part 3: Numerical Evaluation and Verification**\n\nThe integral $I_{\\text{full}}$ can be split into two parts: one over the region where $\\|\\mathbf{r}-\\mathbf{v}_0\\| \\le \\varepsilon$ (inside the ball, $I_{\\text{ball}}$) and one where $\\|\\mathbf{r}-\\mathbf{v}_0\\| > \\varepsilon$ (rest of the volume, $I_{\\text{rest}}$). In Duffy coordinates, the condition $\\|\\mathbf{r}-\\mathbf{v}_0\\| \\le \\varepsilon$ becomes $u\\|\\mathbf{s}(v,w)\\| \\le \\varepsilon$, or $u \\le \\varepsilon/\\|\\mathbf{s}(v,w)\\|$. Since we also require $u \\le 1$, the upper integration limit for the ball region is $u_{\\max}(v,w) = \\min\\left(1, \\frac{\\varepsilon}{\\|\\mathbf{s}(v,w)\\|}\\right)$.\n\nThe integral over $u$ can be performed analytically. Let $C(v,w) = \\frac{v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|}{4\\pi \\|\\mathbf{s}(v,w)\\|}$. The integrand is $C(v,w) u$.\n\nFor $I_{\\text{full}}$, we integrate $u$ from $0$ to $1$:\n$$\n\\int_0^1 C(v,w) u\\,\\mathrm{d}u = C(v,w) \\left[\\frac{u^2}{2}\\right]_0^1 = \\frac{C(v,w)}{2}.\n$$\nThus, the integrand for the $(v,w)$ quadrature for $I_{\\text{full}}$ is $\\frac{v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|}{8\\pi \\|\\mathbf{s}(v,w)\\|}$.\n\nFor $I_{\\text{ball}}^{\\text{numeric}}(\\varepsilon)$, we integrate $u$ from $0$ to $u_{\\max}$:\n$$\n\\int_0^{u_{\\max}} C(v,w) u\\,\\mathrm{d}u = C(v,w) \\left[\\frac{u^2}{2}\\right]_0^{u_{\\max}} = \\frac{C(v,w)}{2} (u_{\\max})^2.\n$$\nThe integrand for the $(v,w)$ quadrature is $\\frac{v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|}{8\\pi \\|\\mathbf{s}(v,w)\\|} \\left(u_{\\max}(v,w)\\right)^2$.\n\nFor $I_{\\text{rest}}^{\\text{numeric}}(\\varepsilon)$, we integrate $u$ from $u_{\\max}$ to $1$:\n$$\n\\int_{u_{\\max}}^1 C(v,w) u\\,\\mathrm{d}u = C(v,w) \\left[\\frac{u^2}{2}\\right]_{u_{\\max}}^1 = \\frac{C(v,w)}{2} (1 - (u_{\\max})^2).\n$$\nThe integrand for the $(v,w)$ quadrature is $\\frac{v\\,\\left|\\det\\left[\\mathbf{a}_1\\ \\mathbf{a}_2\\ \\mathbf{a}_3\\right]\\right|}{8\\pi \\|\\mathbf{s}(v,w)\\|} \\left(1 - \\left(u_{\\max}(v,w)\\right)^2\\right)$.\n\nThe remaining two-dimensional integrals over $(v,w) \\in [0,1]^2$ are smooth and can be accurately computed using a high-order Gauss-Legendre quadrature rule. By construction, the numerical evaluation will exactly satisfy $I_{\\text{full}}^{\\text{numeric}} = I_{\\text{ball}}^{\\text{numeric}}(\\varepsilon) + I_{\\text{rest}}^{\\text{numeric}}(\\varepsilon)$ up to machine precision. Consequently, the two error metrics to be computed,\n$$\nE_1 = \\left|I_{\\text{ball}}^{\\text{numeric}}(\\varepsilon) - I_{\\text{ball}}^{\\text{analytic}}(\\varepsilon)\\right|\n$$\n$$\nE_2 = \\left|I_{\\text{full}}^{\\text{numeric}} - \\left(I_{\\text{ball}}^{\\text{analytic}}(\\varepsilon) + I_{\\text{rest}}^{\\text{numeric}}(\\varepsilon)\\right)\\right|\n$$\nwill also be identical up to machine precision, because\n$E_2 = \\left|(I_{\\text{ball}}^{\\text{numeric}} + I_{\\text{rest}}^{\\text{numeric}}) - (I_{\\text{ball}}^{\\text{analytic}} + I_{\\text{rest}}^{\\text{numeric}})\\right| = \\left|I_{\\text{ball}}^{\\text{numeric}} - I_{\\text{ball}}^{\\text{analytic}}\\right| = E_1$.\nThe magnitude of these errors indicates how well the analytical solid-angle-based formula for the near-field contribution matches the result from a robust numerical integration method. A small error validates both the analytical formula and the numerical implementation.\nThe implementation will use a 2D tensor product of a 32-point Gauss-Legendre rule mapped to the interval $[0,1]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef get_gauss_legendre_quadrature(n):\n    \"\"\"\n    Returns points and weights for Gauss-Legendre quadrature on [0, 1].\n    \n    Args:\n        n (int): The number of quadrature points.\n        \n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: Quadrature points in [0, 1].\n            - np.ndarray: Quadrature weights for the [0, 1] interval.\n    \"\"\"\n    points, weights = roots_legendre(n)\n    # Map from [-1, 1] to [0, 1]\n    mapped_points = (points + 1.0) / 2.0\n    mapped_weights = weights / 2.0\n    return mapped_points, mapped_weights\n\ndef compute_errors(v0, v1, v2, v3, eps, Np=32):\n    \"\"\"\n    Computes the integral errors E1 and E2 for a given tetrahedron.\n    \n    Args:\n        v0, v1, v2, v3 (tuple): Coordinates of the tetrahedron vertices.\n        eps (float): Radius of the exclusion sphere.\n        Np (int): Number of points for Gauss-Legendre quadrature.\n        \n    Returns:\n        tuple: A tuple containing the errors (E1, E2).\n    \"\"\"\n    # Define edge vectors a_i from the singular vertex v0\n    a1 = np.array(v1) - np.array(v0)\n    a2 = np.array(v2) - np.array(v0)\n    a3 = np.array(v3) - np.array(v0)\n    \n    # The matrix A is formed by the edge vectors as columns\n    A_matrix = np.array([a1, a2, a3]).T\n    det_A = np.linalg.det(A_matrix)\n    \n    # === Part 1: Analytic Ball Integral Calculation ===\n    \n    # Normalize edge vectors\n    norm_a1 = np.linalg.norm(a1)\n    norm_a2 = np.linalg.norm(a2)\n    norm_a3 = np.linalg.norm(a3)\n    \n    a1_hat = a1 / norm_a1 if norm_a1 > 0 else a1\n    a2_hat = a2 / norm_a2 if norm_a2 > 0 else a2\n    a3_hat = a3 / norm_a3 if norm_a3 > 0 else a3\n\n    # Determinant of normalized vectors\n    A_hat_matrix = np.array([a1_hat, a2_hat, a3_hat]).T\n    det_A_hat = np.linalg.det(A_hat_matrix)\n    \n    # Dot products for the solid angle formula\n    dot12 = np.dot(a1_hat, a2_hat)\n    dot23 = np.dot(a2_hat, a3_hat)\n    dot31 = np.dot(a3_hat, a1_hat)\n    \n    # Solid angle calculation using the given formula\n    omega_numerator = np.abs(det_A_hat)\n    omega_denominator = 1.0 + dot12 + dot23 + dot31\n    if omega_denominator <= 0:\n        # This case should not happen for a valid, convex trihedral angle\n        solid_angle_Omega = np.pi if omega_numerator > 0 else 0\n    else:\n        solid_angle_Omega = 2.0 * np.arctan(omega_numerator / omega_denominator)\n    \n    i_ball_analytic = (eps**2 / 2.0) * (solid_angle_Omega / (4.0 * np.pi))\n\n    # === Part 2: Numerical Integration using Duffy Transform ===\n    \n    points, weights = get_gauss_legendre_quadrature(Np)\n    v_points, w_points = points, points\n    v_weights, w_weights = weights, weights\n    \n    i_full_numeric = 0.0\n    i_ball_numeric = 0.0\n    i_rest_numeric = 0.0\n    \n    for i in range(Np):\n        v = v_points[i]\n        wv = v_weights[i]\n        for j in range(Np):\n            w = w_points[j]\n            ww = w_weights[j]\n            \n            # Calculate s(v, w) and its norm\n            s_vec = a1 + v * a2 + v * w * a3\n            norm_s = np.linalg.norm(s_vec)\n            \n            # Common factor from analytic integration over u\n            common_factor = v * np.abs(det_A) / (8.0 * np.pi * norm_s)\n            \n            # Integrand for I_full (after u-integration)\n            # The original u-integral is C * u, from 0 to 1, giving C * 1/2.\n            # C = v * |det| / (4 * pi * ||s||), so C/2 = common_factor\n            integrand_full = common_factor  # Note: The problem had ∫ u du * ..., this is the result of that\n                                             # For I_full, the integral of u from 0 to 1 is 1/2.\n                                             # So we multiply by 2 to get the original C factor, and integrate u^2/2 to get final result.\n                                             # No, the code is integrating the already u-integrated kernel.\n                                             # f_full_integrand(v,w) = v*|det|/(8*pi*||s||) \n            i_full_numeric += wv * ww * integrand_full\n            \n            # Calculate u_max for splitting the integral\n            u_max = min(1.0, eps / norm_s)\n            \n            # Add contributions to ball and rest integrals\n            i_ball_numeric += wv * ww * (common_factor * u_max**2)\n            i_rest_numeric += wv * ww * (common_factor * (1.0 - u_max**2))\n            \n    # === Part 3: Error Calculation ===\n    \n    e1 = np.abs(i_ball_numeric - i_ball_analytic)\n    e2 = np.abs(i_full_numeric - (i_ball_analytic + i_rest_numeric))\n    \n    return e1, e2\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (regular-like tetrahedron)\n        {\n            \"v0\": (0.0, 0.0, 0.0),\n            \"v1\": (1.0, 0.0, 0.0),\n            \"v2\": (0.5, np.sqrt(3.0)/2.0, 0.0),\n            \"v3\": (0.5, np.sqrt(3.0)/6.0, np.sqrt(2.0/3.0)),\n            \"eps\": 0.05\n        },\n        # Case 2 (skew tetrahedron)\n        {\n            \"v0\": (0.0, 0.0, 0.0),\n            \"v1\": (2.0, 0.1, 0.0),\n            \"v2\": (0.2, 1.5, -0.1),\n            \"v3\": (-0.1, 0.3, 0.9),\n            \"eps\": 0.02\n        },\n        # Case 3 (small tetrahedron)\n        {\n            \"v0\": (0.0, 0.0, 0.0),\n            \"v1\": (1.0e-3, 0.0, 0.0),\n            \"v2\": (0.0, 1.0e-3, 0.0),\n            \"v3\": (0.0, 0.0, 2.0e-3),\n            \"eps\": 1.0e-5\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        e1, e2 = compute_errors(\n            case[\"v0\"], case[\"v1\"], case[\"v2\"], case[\"v3\"], case[\"eps\"]\n        )\n        results.extend([e1, e2])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A correct physical model of wave scattering requires that scattered energy propagates away from the source, a principle formalized by the Sommerfeld radiation condition. This practice demonstrates the critical role of the Green's function in enforcing this condition within a volume integral equation framework. By comparing a physically correct \"outgoing\" kernel with an incorrect \"standing-wave\" kernel in a simplified one-dimensional setting, you will quantify the non-physical reflections that arise from violating the radiation condition and see how numerical domain truncation can produce similar spurious effects .",
            "id": "3359707",
            "problem": "Consider the frequency-domain scattering of electromagnetic waves from a weakly inhomogeneous, isotropic dielectric in a homogeneous background, formulated via the Volume Integral Equation (VIE). Starting from Maxwell's equations in the frequency domain, one arrives at the Lippmann–Schwinger-type VIE for the electric field, where the dyadic Green's function enforces the Sommerfeld radiation condition. In a one-dimensional reduction that captures the essential behavior while remaining computationally tractable, one studies the scalar Helmholtz equation for a field $u(x)$ and background wavenumber $k$, with a compactly supported susceptibility profile $\\chi(x)$ representing a weak dielectric contrast. The scalar VIE under the first Born approximation can be written as\n$$\nu_{\\text{scat}}(x) \\approx k^2 \\int_{-\\infty}^{\\infty} \\chi(x')\\, u_{\\text{inc}}(x')\\, G(x - x')\\, \\mathrm{d}x',\n$$\nwhere $u_{\\text{inc}}(x) = e^{i k x}$ is the incident plane wave and $G(\\cdot)$ is the scalar Green's function associated with the one-dimensional Helmholtz operator. The correct enforcement of the Sommerfeld radiation condition requires the use of the outgoing fundamental solution\n$$\nG_{\\text{out}}(x) = \\frac{i}{2k}\\, e^{i k |x|},\n$$\nwhich satisfies $\\frac{\\mathrm{d}^2 G}{\\mathrm{d}x^2} + k^2 G = -\\delta(x)$ and radiates away from sources. A non-radiating (standing-wave) choice constructed by taking the real part of the outgoing solution is\n$$\nG_{\\text{stand}}(x) = \\operatorname{Re}\\left(\\frac{i}{2k} e^{i k |x|}\\right) = -\\frac{1}{2k}\\, \\sin(k |x|),\n$$\nwhich also satisfies $\\frac{\\mathrm{d}^2 G}{\\mathrm{d}x^2} + k^2 G = -\\delta(x)$ in the distributional sense, but violates the radiation condition by superposing incoming and outgoing components.\n\nIn numerical practice, one often truncates the computational domain or applies windowing approximations to accelerate the evaluation of VIE operators. Such finite-domain truncation can be emulated by imposing periodic images with period $L_{\\text{box}}$, effectively replacing the free-space Green's function by a periodic-image sum\n$$\nG_{\\text{per}}(x;\\,L_{\\text{box}},P) = \\sum_{p=-P}^{P} G_{\\text{out}}(x + p L_{\\text{box}}),\n$$\nwhich introduces spurious interactions from images of the scatterer and can manifest as artificial incoming waves (reflections) in observation regions.\n\nYour task is to implement a program that:\n1. Discretizes the susceptibility as a Gaussian,\n$$\n\\chi(x) = \\chi_0 \\exp\\!\\left(-\\frac{x^2}{2 \\sigma^2}\\right),\n$$\nsupported numerically on a finite interval $[-L_{\\text{scat}}/2,\\, L_{\\text{scat}}/2]$ in meters, with uniform grid spacing $\\Delta x$.\n2. Computes the scattered field $u_{\\text{scat}}(x)$ on a right-hand observation window $x \\in [x_{\\min}, x_{\\max}]$ using three operator choices:\n   - Outgoing free-space $G_{\\text{out}}$ (radiation enforced).\n   - Standing-wave $G_{\\text{stand}}$ (radiation violated).\n   - Outgoing periodic-image sum $G_{\\text{per}}$ with specified $L_{\\text{box}}$ and number of images $P$ (finite-domain truncation).\n3. Quantifies spurious reflections on the right by fitting the scattered field over the observation window to a two-mode model,\n$$\nu_{\\text{scat}}(x) \\approx A_{\\text{out}}\\, e^{i k x} + A_{\\text{in}}\\, e^{-i k x},\n$$\nvia complex least squares, and outputs the reflection ratio\n$$\nr = \\frac{|A_{\\text{in}}|}{|A_{\\text{out}}|},\n$$\na dimensionless float. This ratio isolates the component corresponding to an incoming wave from $+\\infty$ on the right.\n\nUse the following fixed physical and numerical settings unless overridden in a test case: the distance unit is meters and wavenumber is in radians per meter. Let the background wavenumber be $k = 10$ (radians per meter). Use $\\chi_0 = 0.05$ (dimensionless), $\\sigma = 0.2$ meters, $L_{\\text{scat}} = 2.0$ meters, $\\Delta x = 0.002$ meters, $x_{\\min} = 5.0$ meters, $x_{\\max} = 6.0$ meters, and sample the observation window uniformly with a resolution compatible with $\\Delta x$.\n\nDesign a robust and numerically stable algorithm that:\n- Assembles the discrete Born operator by vectorized evaluation of the chosen Green's function over $|x - x'|$, multiplying by $k^2 \\chi(x') u_{\\text{inc}}(x') \\Delta x$, and summing over source points $x'$.\n- For the periodic-image case, uses the sum over images $p = -P,\\ldots,P$ of the outgoing kernel evaluated at $(x - x') + p L_{\\text{box}}$ to emulate finite-domain truncation.\n- Performs a complex least-squares fit to estimate $A_{\\text{out}}$ and $A_{\\text{in}}$ and returns $r$.\n\nTest Suite and Output Specification:\nCompute and report the reflection ratio $r$ for the following four test cases, which probe the enforcement of the radiation condition and the impact of finite-domain truncation:\n\n- Case 1 (Happy path, radiation enforced): $G = G_{\\text{out}}$.\n- Case 2 (Radiation violated): $G = G_{\\text{stand}}$.\n- Case 3 (Finite-domain truncation, mild): $G = G_{\\text{per}}$ with $L_{\\text{box}} = 20.0$ meters and $P = 1$.\n- Case 4 (Finite-domain truncation, severe): $G = G_{\\text{per}}$ with $L_{\\text{box}} = 8.0$ meters and $P = 3$.\n\nThe final output of your program must be a single line containing the four reflection ratios as a comma-separated list enclosed in square brackets, for example,\n$$\n[\\text{r}_1,\\text{r}_2,\\text{r}_3,\\text{r}_4],\n$$\nwith each $\\text{r}_j$ reported as a floating-point number (dimensionless). No additional text should be printed. Angles are measured in radians throughout, and distances in meters; the output ratios are dimensionless and require no unit conversion or rounding to a specific number of significant figures, but they must be valid floating-point values.",
            "solution": "The user's problem is first assessed for validity.\n\n### Step 1: Extract Givens\n-   **Governing Equation**: The scalar volume integral equation (VIE) for the scattered field $u_{\\text{scat}}(x)$ under the first Born approximation is given by $u_{\\text{scat}}(x) \\approx k^2 \\int_{-\\infty}^{\\infty} \\chi(x')\\, u_{\\text{inc}}(x')\\, G(x - x')\\, \\mathrm{d}x'$.\n-   **Incident Field**: The incident plane wave is $u_{\\text{inc}}(x) = e^{i k x}$.\n-   **Susceptibility**: The susceptibility profile is a Gaussian, $\\chi(x) = \\chi_0 \\exp\\!\\left(-\\frac{x^2}{2 \\sigma^2}\\right)$, numerically supported on the interval $[-L_{\\text{scat}}/2,\\, L_{\\text{scat}}/2]$.\n-   **Green's Functions**:\n    1.  Outgoing (free-space): $G_{\\text{out}}(x) = \\frac{i}{2k}\\, e^{i k |x|}$.\n    2.  Standing-wave: $G_{\\text{stand}}(x) = -\\frac{1}{2k}\\, \\sin(k |x|)$.\n    3.  Periodic (for domain truncation emulation): $G_{\\text{per}}(x;\\,L_{\\text{box}},P) = \\sum_{p=-P}^{P} G_{\\text{out}}(x + p L_{\\text{box}})$.\n-   **Analysis Model**: The scattered field in the observation window is fitted to the model $u_{\\text{scat}}(x) \\approx A_{\\text{out}}\\, e^{i k x} + A_{\\text{in}}\\, e^{-i k x}$.\n-   **Quantity to Compute**: The reflection ratio $r = \\frac{|A_{\\text{in}}|}{|A_{\\text{out}}|}$.\n-   **Physical and Numerical Parameters**:\n    -   Background wavenumber: $k = 10$ rad/m.\n    -   Peak susceptibility: $\\chi_0 = 0.05$.\n    -   Gaussian width: $\\sigma = 0.2$ m.\n    -   Scatterer support length: $L_{\\text{scat}} = 2.0$ m.\n    -   Grid spacing: $\\Delta x = 0.002$ m.\n    -   Observation window: $[x_{\\min}, x_{\\max}] = [5.0, 6.0]$ m.\n-   **Test Cases**:\n    1.  $G = G_{\\text{out}}$.\n    2.  $G = G_{\\text{stand}}$.\n    3.  $G = G_{\\text{per}}$ with $L_{\\text{box}} = 20.0$ m, $P = 1$.\n    4.  $G = G_{\\text{per}}$ with $L_{\\text{box}} = 8.0$ m, $P = 3$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the principles of wave scattering theory and computational electromagnetics. The mathematical formulation, including the Lippmann-Schwinger equation, Helmholtz Green's functions, and the Born approximation, is standard and correct. The problem is well-posed, providing all necessary parameters and definitions to construct a numerical solution. The language is objective and precise. The test cases are designed to probe a fundamental physical concept—the Sommerfeld radiation condition—and a common numerical artifact, making the problem a meaningful exercise rather than a trivial calculation. The parameters are physically reasonable and lead to a computationally feasible task.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be developed.\n\n### Principle-Based Design of the Solution\n\nThe solution involves three main stages: discretizing the volume integral equation, computing the scattered field for different Green's functions, and analyzing the resulting field to quantify spurious reflections.\n\n**1. Discretization of the Integral Equation**\nThe core of the problem is the VIE, $u_{\\text{scat}}(x) \\approx \\int_{-\\infty}^{\\infty} G(x - x')\\, J(x')\\, \\mathrm{d}x'$, where we define the source density as $J(x') = k^2 \\chi(x') u_{\\text{inc}}(x')$. To solve this numerically, we employ a standard method-of-moments approach with point-matching (collocation) and a pulse basis, which simplifies to a Riemann sum.\n\nFirst, we define two discrete grids:\n-   A source grid, $x'_j$, that samples the scatterer region $[-L_{\\text{scat}}/2, L_{\\text{scat}}/2]$. The points are uniformly spaced with step $\\Delta x = 0.002$ m.\n-   An observation grid, $x_i$, that samples the observation window $[x_{\\min}, x_{\\max}] = [5.0, 6.0]$ m, also with spacing $\\Delta x$.\n\nThe continuous integral is approximated by the sum:\n$$\nu_{\\text{scat}}(x_i) \\approx \\sum_j G(x_i - x'_j)\\, J(x'_j)\\, \\Delta x\n$$\nThis can be expressed as a matrix-vector product. Let $\\mathbf{u}_{\\text{scat}}$ be a column vector of the scattered field values at points $x_i$, and $\\mathbf{J}$ be a column vector of the source density values $J(x'_j)$ at points $x'_j$. The equation becomes:\n$$\n\\mathbf{u}_{\\text{scat}} = \\mathbf{G} \\cdot \\mathbf{J} \\cdot \\Delta x\n$$\nwhere $\\mathbf{G}$ is a matrix whose elements are $G_{ij} = G(x_i - x'_j)$.\n\n**2. Assembling the Operator Matrix $\\mathbf{G}$**\nThe algorithm computes a different $\\mathbf{G}$ matrix for each of the four test cases.\n\n-   **Case 1: Outgoing Green's Function ($G_{\\text{out}}$)**\n    The matrix elements are populated using the formula for the correct radiating solution:\n    $G_{ij} = G_{\\text{out}}(x_i - x'_j) = \\frac{i}{2k} e^{i k |x_i - x'_j|}$. Physically, this ensures that energy scattered from any source point $x'_j$ propagates outward, away from the source, satisfying the Sommerfeld radiation condition.\n\n-   **Case 2: Standing-Wave Green's Function ($G_{\\text{stand}}$)**\n    The matrix elements use the non-radiating kernel:\n    $G_{ij} = G_{\\text{stand}}(x_i - x'_j) = -\\frac{1}{2k} \\sin(k |x_i - x'_j|)$.\n    This Green's function is the real part of $G_{\\text{out}}$ and represents a superposition of an outgoing wave and an incoming wave of equal amplitude. Its use violates the radiation condition and is expected to produce a scattered field with a significant non-physical incoming component.\n\n-   **Cases 3 & 4: Periodic Green's Function ($G_{\\text{per}}$)**\n    This formulation emulates the effect of truncating an infinite domain to a finite periodic one. The matrix elements are calculated by summing the contributions from the primary source and its periodic images:\n    $G_{ij} = G_{\\text{per}}(x_i - x'_j; L_{\\text{box}}, P) = \\sum_{p=-P}^{P} G_{\\text{out}}((x_i - x'_j) + p L_{\\text{box}})$.\n    Each term $p \\neq 0$ represents a spurious interaction with a periodic copy of the scatterer. These interactions manifest as waves arriving at the observation window from directions inconsistent with radiation from the true scatterer, creating artificial reflections. Case 3, with a large period $L_{\\text{box}} = 20.0$ m, should show small reflections. Case 4, with a smaller period $L_{\\text{box}} = 8.0$ m and more images, should show severe reflection artifacts.\n\n**3. Least-Squares Analysis for Reflection Ratio**\nAfter computing the discrete scattered field vector $\\mathbf{u}_{\\text{scat}}$ for a given case, we need to quantify the reflection. The scattered field in the observation window (which is in the far-field region to the right of the scatterer) is modeled as a superposition of a right-propagating (outgoing) wave and a left-propagating (incoming) wave:\n$$\nu_{\\text{scat}}(x_i) \\approx A_{\\text{out}}\\, e^{i k x_i} + A_{\\text{in}}\\, e^{-i k x_i}\n$$\nThis is a linear model for the unknown complex amplitudes $A_{\\text{out}}$ and $A_{\\text{in}}$. We can write this for all observation points as a linear system $\\mathbf{M} \\mathbf{a} \\approx \\mathbf{u}_{\\text{scat}}$, where:\n-   $\\mathbf{a} = [A_{\\text{out}}, A_{\\text{in}}]^T$ is the vector of unknown coefficients.\n-   $\\mathbf{M}$ is an $N_{\\text{obs}} \\times 2$ matrix whose columns are the basis functions evaluated at the observation points, i.e., $M_{i1} = e^{i k x_i}$ and $M_{i2} = e^{-i k x_i}$.\n\nThe coefficients $A_{\\text{out}}$ and $A_{\\text{in}}$ are found by solving this system in a complex least-squares sense, which minimizes the norm of the residual $||\\mathbf{M} \\mathbf{a} - \\mathbf{u}_{\\text{scat}}||^2$. The `numpy.linalg.lstsq` function is used for this purpose.\n\nFinally, the reflection ratio $r$ is computed as the ratio of the magnitudes of the incoming and outgoing wave amplitudes:\n$$\nr = \\frac{|A_{\\text{in}}|}{|A_{\\text{out}}|}\n$$\nThis value provides a quantitative measure of the violation of the radiation condition. For a perfectly outgoing wave, $r = 0$. For a pure standing wave, $r = 1$. The periodic cases will yield intermediate values depending on the severity of the spurious reflections.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes spurious reflection ratios for 1D electromagnetic scattering\n    using different Green's function formulations in a Volume Integral Equation.\n    \"\"\"\n\n    def calculate_reflection_ratio(G_type, G_params={}):\n        \"\"\"\n        Calculates the reflection ratio for a single numerical experiment.\n\n        Args:\n            G_type (str): The type of Green's function to use ('out', 'stand', 'per').\n            G_params (dict): Parameters for the Green's function, e.g., L_box and P.\n\n        Returns:\n            float: The computed reflection ratio r = |A_in| / |A_out|.\n        \"\"\"\n        # Define fixed physical and numerical settings\n        k = 10.0          # Wavenumber (rad/m)\n        chi0 = 0.05       # Peak susceptibility (dimensionless)\n        sigma = 0.2       # Gaussian width of susceptibility (m)\n        L_scat = 2.0      # Length of scatterer support (m)\n        dx = 0.002        # Grid spacing (m)\n        x_min_obs = 5.0   # Start of observation window (m)\n        x_max_obs = 6.0   # End of observation window (m)\n\n        # 1. Discretize domains\n        # Source grid (where the scatterer exists)\n        num_pts_scat = int(round(L_scat / dx)) + 1\n        x_prime = np.linspace(-L_scat / 2, L_scat / 2, num_pts_scat)\n\n        # Observation grid (where the scattered field is measured)\n        num_pts_obs = int(round((x_max_obs - x_min_obs) / dx)) + 1\n        x_obs = np.linspace(x_min_obs, x_max_obs, num_pts_obs)\n\n        # 2. Define the source density J(x') = k^2 * chi(x') * u_inc(x')\n        chi_profile = chi0 * np.exp(-x_prime**2 / (2 * sigma**2))\n        u_inc = np.exp(1j * k * x_prime)\n        source = k**2 * chi_profile * u_inc\n\n        # 3. Assemble the discrete Green's function operator matrix G\n        # G_ij = G(x_obs[i] - x_prime[j])\n        z = x_obs[:, None] - x_prime[None, :]\n\n        if G_type == 'out':\n            # Outgoing (radiating) Green's function\n            G_matrix = (1j / (2 * k)) * np.exp(1j * k * np.abs(z))\n        elif G_type == 'stand':\n            # Standing-wave (non-radiating) Green's function\n            G_matrix = (-1 / (2 * k)) * np.sin(k * np.abs(z))\n        elif G_type == 'per':\n            # Periodic sum of outgoing Green's functions\n            L_box = G_params['L_box']\n            P = G_params['P']\n            G_matrix = np.zeros_like(z, dtype=np.complex128)\n            p_range = np.arange(-P, P + 1)\n            for p in p_range:\n                z_shifted = z + p * L_box\n                G_matrix += (1j / (2 * k)) * np.exp(1j * k * np.abs(z_shifted))\n        else:\n            raise ValueError(f\"Unknown Green's function type: {G_type}\")\n\n        # 4. Compute the scattered field via discrete convolution\n        # u_scat = integral G(x-x') J(x') dx' -> sum_j G_ij * J_j * dx\n        u_scat = G_matrix @ source * dx\n\n        # 5. Perform least-squares fit to find A_out and A_in\n        # Model: u_scat(x) = A_out * exp(ikx) + A_in * exp(-ikx)\n        # This is a linear system: M * [A_out, A_in]^T = u_scat\n        M = np.stack([\n            np.exp(1j * k * x_obs),   # Basis function for outgoing wave\n            np.exp(-1j * k * x_obs)  # Basis function for incoming wave\n        ], axis=1)\n\n        # Solve for the coefficients [A_out, A_in]\n        coeffs, _, _, _ = np.linalg.lstsq(M, u_scat, rcond=None)\n        A_out, A_in = coeffs[0], coeffs[1]\n\n        # 6. Calculate the reflection ratio\n        # A_out should be non-zero for a non-trivial scatterer\n        if np.abs(A_out) == 0:\n            return np.inf if np.abs(A_in) > 0 else 0.0\n        \n        r = np.abs(A_in) / np.abs(A_out)\n        return r\n\n    # Define the test suite\n    test_cases = [\n        {'type': 'out', 'params': {}},\n        {'type': 'stand', 'params': {}},\n        {'type': 'per', 'params': {'L_box': 20.0, 'P': 1}},\n        {'type': 'per', 'params': {'L_box': 8.0, 'P': 3}}\n    ]\n\n    # Run all test cases and collect results\n    results = []\n    for case in test_cases:\n        ratio = calculate_reflection_ratio(case['type'], case['params'])\n        results.append(ratio)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Verifying the correctness of a complex numerical solver is a critical task in computational science, and testing for fundamental physical symmetries provides a robust methodology. This exercise focuses on implementing a numerical test for electromagnetic reciprocity, a principle that relates the fields at swapped source and observation points. You will implement the full dyadic Green's function for the electric field and develop a quantitative measure to assess whether your discretized operator preserves reciprocity, distinguishing between physical non-reciprocity in materials and symmetry-breaking numerical artifacts .",
            "id": "3359666",
            "problem": "Consider a time-harmonic electromagnetic field with angular frequency $\\omega$ in a homogeneous background characterized by vacuum permittivity $\\varepsilon_{0}$ and vacuum permeability $\\mu_{0}$. Let the background wavenumber be $k = \\omega \\sqrt{\\varepsilon_{0}\\mu_{0}}$. In the volume integral equation formulation for the electric field $\\mathbf{E}(\\mathbf{r})$, the scattered field is represented through the dyadic Green's function $\\overline{\\overline{G}}(\\mathbf{r},\\mathbf{r}')$ and the electric susceptibility tensor $\\overline{\\overline{\\chi}}(\\mathbf{r}')$, via a kernel action $\\int \\overline{\\overline{G}}(\\mathbf{r},\\mathbf{r}') \\, \\overline{\\overline{\\chi}}(\\mathbf{r}') \\, \\mathbf{E}(\\mathbf{r}') \\, \\mathrm{d}V'$. For a reciprocal homogeneous background, the dyadic Green's function satisfies the reciprocity relation $G_{ij}(\\mathbf{r},\\mathbf{r}') = G_{ji}(\\mathbf{r}',\\mathbf{r})$.\n\nStarting from first principles (Maxwell's equations in the frequency domain and the definition of the dyadic Green's function for the vector Helmholtz operator), derive a computational test to assess discrete reciprocity of the composite kernel $K_{ij}(\\mathbf{r},\\mathbf{r}') = \\sum_{m} G_{im}(\\mathbf{r},\\mathbf{r}') \\, \\chi_{mj}(\\mathbf{r}')$ when discretized on a finite set of source-observation points. Your test must compute a dimensionless residual\n$$\n\\eta = \\frac{\\max\\limits_{\\substack{p \\neq q \\\\ i,j \\in \\{x,y,z\\}}} \\left| K_{ij}(\\mathbf{r}_{p},\\mathbf{r}_{q}) - K_{ji}(\\mathbf{r}_{q},\\mathbf{r}_{p}) \\right|}{\\max\\limits_{\\substack{p \\neq q \\\\ i,j \\in \\{x,y,z\\}}} \\left| K_{ij}(\\mathbf{r}_{p},\\mathbf{r}_{q}) \\right|},\n$$\nand decide whether reciprocity holds within a prescribed tolerance $\\tau$ by returning a boolean flag that is true if $\\eta \\le \\tau$ and false otherwise.\n\nUse the free-space dyadic Green's function for the electric field,\n$$\n\\overline{\\overline{G}}(\\mathbf{r},\\mathbf{r}') = \\left( \\overline{\\overline{I}} + \\frac{1}{k^{2}} \\nabla \\nabla \\right) g(R), \\quad g(R) = \\frac{e^{\\mathrm{i} k R}}{4\\pi R}, \\quad R = \\|\\mathbf{r} - \\mathbf{r}'\\|,\n$$\nand implement the analytic identity\n$$\n\\nabla \\nabla g(R) = g''(R) \\, \\hat{\\mathbf{R}} \\hat{\\mathbf{R}} + \\frac{g'(R)}{R} \\left( \\overline{\\overline{I}} - \\hat{\\mathbf{R}} \\hat{\\mathbf{R}} \\right), \\quad \\hat{\\mathbf{R}} = \\frac{\\mathbf{r}-\\mathbf{r}'}{R},\n$$\nwith $g'(R)$ and $g''(R)$ denoting the first and second derivatives of $g(R)$ with respect to $R$. Construct the composite kernel as $K(\\mathbf{r}_{p},\\mathbf{r}_{q}) = \\overline{\\overline{G}}(\\mathbf{r}_{p},\\mathbf{r}_{q}) \\, \\overline{\\overline{\\chi}}(\\mathbf{r}_{q})$ for $p \\neq q$. Exclude self-interactions with $p=q$ from the residual calculation.\n\nIn addition to the analytic computation of $\\overline{\\overline{G}}$, include an alternative biased approximation of the derivative terms that evaluates $g'(R)$ and $g''(R)$ at $R+\\epsilon$ for the ordered pair $(\\mathbf{r}_{p},\\mathbf{r}_{q})$ and at $R-\\epsilon$ for $(\\mathbf{r}_{q},\\mathbf{r}_{p})$, with a small positive bias $\\epsilon$. This models a symmetry-breaking numerical artifact (for example, a staggered-grid or one-sided difference scheme) and should increase the residual even for symmetric $\\overline{\\overline{\\chi}}$.\n\nAll quantities must be treated as dimensionless in this problem, and all reported numbers must be dimensionless. Angles, if any arise, must be in radians, but this problem does not require angle reporting. Your program must implement the residual $\\eta$ and the boolean decision for a set of test cases and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is a list of the form $[\\eta, \\text{boolean}]$.\n\nImplement the following test suite:\n\n- Test case $1$ (reciprocal, isotropic, analytic kernel):\n  - Wavenumber $k = 10$.\n  - Points $\\mathbf{r}_{p}$: $\\left[ [0.0, 0.0, 0.0], [0.3, 0.0, 0.1], [0.0, 0.25, 0.2], [0.2, 0.2, 0.3], [0.35, 0.10, 0.25] \\right]$.\n  - Susceptibility $\\overline{\\overline{\\chi}} = \\alpha \\overline{\\overline{I}}$ with $\\alpha = 0.5$.\n  - Tolerance $\\tau = 10^{-10}$.\n  - Kernel method: analytic.\n\n- Test case $2$ (nonreciprocal, anisotropic, analytic kernel):\n  - Wavenumber $k = 10$.\n  - Same points as in test case $1$.\n  - Susceptibility\n    $$\n    \\overline{\\overline{\\chi}} =\n    \\begin{bmatrix}\n    0.0 & 0.2 & 0.0 \\\\\n    -0.1 & 0.0 & 0.0 \\\\\n    0.0 & 0.0 & 0.0\n    \\end{bmatrix}.\n    $$\n  - Tolerance $\\tau = 10^{-10}$.\n  - Kernel method: analytic.\n\n- Test case $3$ (reciprocal, symmetric anisotropy, near-field separations, analytic kernel):\n  - Wavenumber $k = 50$.\n  - Points $\\mathbf{r}_{p}$: $\\left[ [0.0, 0.0, 0.0], [0.001, 0.0, 0.0], [0.02, 0.02, 0.0] \\right]$.\n  - Susceptibility\n    $$\n    \\overline{\\overline{\\chi}} =\n    \\begin{bmatrix}\n    0.3 & 0.1 & 0.0 \\\\\n    0.1 & 0.5 & 0.0 \\\\\n    0.0 & 0.0 & 0.8\n    \\end{bmatrix}.\n    $$\n  - Tolerance $\\tau = 10^{-10}$.\n  - Kernel method: analytic.\n\n- Test case $4$ (reciprocal, isotropic, biased derivative artifact):\n  - Wavenumber $k = 10$.\n  - Same points as in test case $1$.\n  - Susceptibility $\\overline{\\overline{\\chi}} = \\alpha \\overline{\\overline{I}}$ with $\\alpha = 0.5$.\n  - Tolerance $\\tau = 10^{-10}$.\n  - Kernel method: biased with bias $\\epsilon = 10^{-9}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[[\\eta_{1},\\text{boolean}_{1}],[\\eta_{2},\\text{boolean}_{2}],\\ldots]$).",
            "solution": "The problem requires the implementation of a numerical test to verify the reciprocity of a composite kernel $K_{ij}(\\mathbf{r}_p, \\mathbf{r}_q)$ used in electromagnetic volume integral equations. The solution involves deriving the condition for reciprocity, implementing the dyadic Green's function, and designing the algorithm to compute the specified residual $\\eta$.\n\n### 1. Reciprocity of the Composite Kernel\n\nThe composite kernel is defined by the matrix product of the dyadic Green's function $\\overline{\\overline{G}}$ and the susceptibility tensor $\\overline{\\overline{\\chi}}$. For an observation point $\\mathbf{r}_p$ and a source point $\\mathbf{r}_q$, the discretized kernel is $\\overline{\\overline{K}}(\\mathbf{r}_p, \\mathbf{r}_q) = \\overline{\\overline{G}}(\\mathbf{r}_p, \\mathbf{r}_q) \\overline{\\overline{\\chi}}(\\mathbf{r}_q)$. The reciprocity test compares the element $K_{ij}(\\mathbf{r}_p, \\mathbf{r}_q)$ with $K_{ji}(\\mathbf{r}_q, \\mathbf{r}_p)$.\n\nLet $\\mathbf{A} = \\overline{\\overline{K}}(\\mathbf{r}_p, \\mathbf{r}_q) = \\overline{\\overline{G}}(\\mathbf{r}_p, \\mathbf{r}_q) \\overline{\\overline{\\chi}}$ and $\\mathbf{B} = \\overline{\\overline{K}}(\\mathbf{r}_q, \\mathbf{r}_p) = \\overline{\\overline{G}}(\\mathbf{r}_q, \\mathbf{r}_p) \\overline{\\overline{\\chi}}$. The test condition is $\\mathbf{A} = \\mathbf{B}^T$, which expands to:\n$$\n\\overline{\\overline{G}}(\\mathbf{r}_p, \\mathbf{r}_q) \\overline{\\overline{\\chi}} = \\left( \\overline{\\overline{G}}(\\mathbf{r}_q, \\mathbf{r}_p) \\overline{\\overline{\\chi}} \\right)^T = \\overline{\\overline{\\chi}}^T \\overline{\\overline{G}}(\\mathbf{r}_q, \\mathbf{r}_p)^T\n$$\nThe background medium is reciprocal, so the dyadic Green's function satisfies $\\overline{\\overline{G}}(\\mathbf{r}, \\mathbf{r}') = \\overline{\\overline{G}}(\\mathbf{r}', \\mathbf{r})^T$. Applying this symmetry relation, the condition for composite kernel reciprocity becomes:\n$$\n\\overline{\\overline{G}}(\\mathbf{r}_p, \\mathbf{r}_q) \\overline{\\overline{\\chi}} = \\overline{\\overline{\\chi}}^T \\overline{\\overline{G}}(\\mathbf{r}_p, \\mathbf{r}_q)\n$$\nThis equation reveals that the composite kernel is reciprocal if the susceptibility tensor is symmetric ($\\overline{\\overline{\\chi}} = \\overline{\\overline{\\chi}}^T$) and commutes with the Green's dyadic ($[\\overline{\\overline{G}}, \\overline{\\overline{\\chi}}] = \\mathbf{0}$). This holds for isotropic media ($\\overline{\\overline{\\chi}} = \\alpha\\overline{\\overline{I}}$) but not generally for anisotropic media. The residual $\\eta$ measures the degree to which this condition is violated.\n\n### 2. Implementation of the Dyadic Green's Function\n\nThe free-space dyadic Green's function for the electric field is given by:\n$$\n\\overline{\\overline{G}}(\\mathbf{r},\\mathbf{r}') = \\left( \\overline{\\overline{I}} + \\frac{1}{k^{2}} \\nabla \\nabla \\right) g(R)\n$$\nwhere $g(R) = \\frac{e^{\\mathrm{i} k R}}{4\\pi R}$ and $R = \\|\\mathbf{r} - \\mathbf{r}'\\|$. We need the first and second derivatives of $g(R)$ with respect to $R$:\n$$\ng'(R) = \\frac{\\mathrm{d}g}{\\mathrm{d}R} = \\frac{e^{\\mathrm{i}kR}}{4\\pi} \\left( \\frac{\\mathrm{i}k}{R} - \\frac{1}{R^2} \\right)\n$$\n$$\ng''(R) = \\frac{\\mathrm{d}^2g}{\\mathrm{d}R^2} = \\frac{e^{\\mathrm{i}kR}}{4\\pi} \\left( \\frac{(\\mathrm{i}k)^2}{R} - \\frac{2\\mathrm{i}k}{R^2} + \\frac{2}{R^3} \\right) = \\frac{e^{\\mathrm{i}kR}}{4\\pi} \\left( -\\frac{k^2}{R} - \\frac{2\\mathrm{i}k}{R^2} + \\frac{2}{R^3} \\right)\n$$\nUsing the provided identity for $\\nabla\\nabla g(R)$, the dyadic Green's function can be assembled numerically. The term $\\hat{\\mathbf{R}}\\hat{\\mathbf{R}}$ is the outer product of the normalized separation vector $\\hat{\\mathbf{R}} = (\\mathbf{r}-\\mathbf{r}')/R$.\n\n### 3. Algorithmic Procedure\n\nThe algorithm for computing the residual $\\eta$ for a set of $N$ points is as follows:\n1.  Initialize `max_abs_K` and `max_abs_diff` to zero.\n2.  Iterate through all $N(N-1)$ distinct ordered pairs of point indices $(p, q)$ where $p \\neq q$.\n3.  For each pair $(p, q)$:\n    a.  Compute the kernel matrix $\\overline{\\overline{K}}_{pq} = \\overline{\\overline{G}}(\\mathbf{r}_p, \\mathbf{r}_q) \\overline{\\overline{\\chi}}$. For the `biased` method, the derivatives $g'$ and $g''$ are evaluated at $R_{pq}+\\epsilon$.\n    b.  Compute the kernel matrix $\\overline{\\overline{K}}_{qp} = \\overline{\\overline{G}}(\\mathbf{r}_q, \\mathbf{r}_p) \\overline{\\overline{\\chi}}$. For the `biased` method, the derivatives are evaluated at $R_{qp}-\\epsilon$. Note $R_{pq}=R_{qp}$.\n    c.  Calculate the difference matrix $\\overline{\\overline{D}}_{pq} = \\overline{\\overline{K}}_{pq} - \\overline{\\overline{K}}_{qp}^T$.\n    d.  Update the running maximums by taking the element-wise maximum absolute value over all computed matrices:\n        `max_abs_K = max(max_abs_K, max(abs(K_pq)))`\n        `max_abs_diff = max(max_abs_diff, max(abs(D_pq)))`\n4.  After the loop, compute the final residual $\\eta = \\text{max\\_abs\\_diff} / \\text{max\\_abs\\_K}$ (if $\\text{max\\_abs\\_K} > 0$).\n5.  Compare $\\eta$ with the tolerance $\\tau$ to set the boolean reciprocity flag.\n\nThis procedure rigorously implements the test defined in the problem. The `analytic` method uses $\\epsilon=0$ and should yield a residual near machine precision for reciprocal cases. The `biased` method models numerical errors and is expected to produce a non-zero residual even for analytically reciprocal materials.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_G(r_obs, r_src, k, bias=0.0):\n    \"\"\"\n    Calculates the 3x3 dyadic Green's function for the electric field.\n    \n    Args:\n        r_obs (np.ndarray): Observation point coordinates (3,).\n        r_src (np.ndarray): Source point coordinates (3,).\n        k (float): Wavenumber.\n        bias (float): Small value to add to R for derivative calculations,\n                      modeling numerical artifacts.\n                      \n    Returns:\n        np.ndarray: The 3x3 complex Green's function matrix.\n    \"\"\"\n    R_vec = r_obs - r_src\n    R = np.linalg.norm(R_vec)\n    \n    if R < 1e-12:  # Avoid division by zero for coincident points\n        return np.full((3, 3), np.nan, dtype=np.complex128)\n\n    R_hat = R_vec / R\n    I = np.identity(3)\n    \n    # R_deriv is the distance at which derivatives are evaluated\n    R_deriv = R + bias\n\n    # Scalar Green's function g(R) is always evaluated at the true distance R\n    g_val = np.exp(1j * k * R) / (4 * np.pi * R)\n\n    # First and second derivatives, g'(R_deriv) and g''(R_deriv)\n    # The exponential term must also be evaluated at the biased distance\n    exp_term_deriv = np.exp(1j * k * R_deriv)\n    \n    g_p = exp_term_deriv / (4 * np.pi) * (1j * k / R_deriv - 1 / R_deriv**2)\n    g_pp = exp_term_deriv / (4 * np.pi) * ((1j * k)**2 / R_deriv - 2 * 1j * k / R_deriv**2 + 2 / R_deriv**3)\n\n    # Assemble the nabla-nabla-g term.\n    # The 1/R term in the identity is evaluated at the true distance R.\n    outer_R_hat = np.outer(R_hat, R_hat)\n    nabla_nabla_g = g_pp * outer_R_hat + (g_p / R) * (I - outer_R_hat)\n    \n    # Assemble the full dyadic Green's function\n    G_dyadic = I * g_val + (1 / k**2) * nabla_nabla_g\n    \n    return G_dyadic\n\ndef solve():\n    \"\"\"\n    Main solver function to run the reciprocity tests.\n    \"\"\"\n    # Define test cases\n    points1 = [\n        [0.0, 0.0, 0.0], [0.3, 0.0, 0.1], [0.0, 0.25, 0.2],\n        [0.2, 0.2, 0.3], [0.35, 0.10, 0.25]\n    ]\n    points2 = [\n        [0.0, 0.0, 0.0], [0.001, 0.0, 0.0], [0.02, 0.02, 0.0]\n    ]\n\n    test_cases = [\n        # (k, points, chi_matrix, tolerance, method, bias_epsilon)\n        (10.0, points1, 0.5 * np.identity(3), 1e-10, 'analytic', 0.0),\n        (10.0, points1, np.array([[0.0, 0.2, 0.0], [-0.1, 0.0, 0.0], [0.0, 0.0, 0.0]]), 1e-10, 'analytic', 0.0),\n        (50.0, points2, np.array([[0.3, 0.1, 0.0], [0.1, 0.5, 0.0], [0.0, 0.0, 0.8]]), 1e-10, 'analytic', 0.0),\n        (10.0, points1, 0.5 * np.identity(3), 1e-10, 'biased', 1e-9)\n    ]\n\n    results = []\n    \n    for k_val, points_list, chi_matrix, tau, method, epsilon in test_cases:\n        points = np.array(points_list, dtype=float)\n        num_points = points.shape[0]\n        \n        max_abs_K = 0.0\n        max_abs_diff = 0.0\n        \n        # Iterate over all distinct ordered pairs of points (p, q)\n        for p in range(num_points):\n            for q in range(num_points):\n                if p == q:\n                    continue\n\n                r_p = points[p]\n                r_q = points[q]\n\n                # Calculate K(p, q)\n                bias_pq = epsilon if method == 'biased' else 0.0\n                G_pq = calculate_G(r_p, r_q, k_val, bias_pq)\n                K_pq = G_pq @ chi_matrix\n                \n                # Calculate K(q, p)\n                bias_qp = -epsilon if method == 'biased' else 0.0\n                G_qp = calculate_G(r_q, r_p, k_val, bias_qp)\n                K_qp = G_qp @ chi_matrix\n                \n                # Calculate the difference matrix D_pq = K_pq - (K_qp)^T\n                Diff_pq = K_pq - K_qp.T\n                \n                # Update the running maximums\n                max_abs_K = max(max_abs_K, np.max(np.abs(K_pq)))\n                max_abs_diff = max(max_abs_diff, np.max(np.abs(Diff_pq)))\n\n        # Calculate the residual eta\n        if max_abs_K < 1e-15: # Handle cases where K might be zero\n            eta = 0.0\n        else:\n            eta = max_abs_diff / max_abs_K\n            \n        # Perform the reciprocity check\n        is_reciprocal = eta <= tau\n        \n        results.append([eta, is_reciprocal])\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join([f'[{res[0]},{str(res[1]).lower()}]' for res in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}