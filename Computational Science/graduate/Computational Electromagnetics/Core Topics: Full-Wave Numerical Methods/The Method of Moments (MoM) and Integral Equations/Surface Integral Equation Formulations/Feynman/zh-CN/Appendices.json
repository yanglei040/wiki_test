{
    "hands_on_practices": [
        {
            "introduction": "表面积分方程的矩量法求解器，其精度在很大程度上取决于矩阵元素的精确计算。本练习将深入探讨其中最具挑战性的“自积分”情形，即积分核函数出现奇异性的情况。通过对一个典型的三角形单元进行解析积分 ，你将亲身体会到该奇异性的本质，并掌握稳定处理该问题所需的解析技巧。",
            "id": "3352477",
            "problem": "在对理想电导体散射体的电场积分方程 (EFIE) 进行矩量法离散化时，自由空间格林函数核的奇异部分在低频极限下简化为与 $1/R$ 成正比的拉普拉斯核，其中 $R$ 是观测点与源点之间的欧几里得距离。对于重合的测试单元和源单元，其在平面片元上的相关几何积分是弱奇异但有限的，并且必须进行解析处理，以保持曲面积分方程公式的精度和稳定性。\n\n考虑一个位于 $z=0$ 平面上的平面参考三角片元，其顶点分别为 $(0,0,0)$、$(1,0,0)$ 和 $(0,1,0)$。将观测点置于原点 $(0,0,0)$，因此对于三角形上的任意源点 $(x,y,0)$，核距离为 $R=\\sqrt{x^{2}+y^{2}}$。从第一性原理（核的定义和有效的变量替换）出发，进行坐标变换以消除弱奇异性，并计算积分\n$$\nI \\equiv \\iint_{T} \\frac{1}{\\sqrt{x^{2}+y^{2}}} \\, dx \\, dy,\n$$\n其中 $T=\\{(x,y)\\,:\\, x\\ge 0,\\; y\\ge 0,\\; x+y\\le 1\\}$ 是参考三角形。在您的推导中，请明确指出任何对数贡献的来源，以及在曲面积分方程公式的数值积分中必须谨慎处理的特定对数项。请将您的最终结果表示为闭式解析表达式。最终答案无需数值近似。",
            "solution": "所述问题具有科学依据、是适定的、客观的，并包含获得唯一解所需的所有必要信息。它代表了计算电磁学中针对曲面积分方程的矩量法中的一个标准且基础的计算。因此，我们可以开始推导。\n\n问题要求计算积分\n$$\nI \\equiv \\iint_{T} \\frac{1}{\\sqrt{x^{2}+y^{2}}} \\, dx \\, dy\n$$\n其中积分域 $T$ 是 $z=0$ 平面中顶点为 $(0,0,0)$、$(1,0,0)$ 和 $(0,1,0)$ 的三角形。该区域由不等式 $x \\ge 0$、$y \\ge 0$ 和 $x+y \\le 1$ 描述。被积函数在原点 $(0,0,0)$ 处有一个弱奇异点，该点是三角形的一个顶点。\n\n为计算此积分，我们执行从笛卡尔坐标 $(x,y)$ 到极坐标 $(r,\\theta)$ 的坐标变换。这是处理形如 $1/R$ 的奇异性的标准程序，其中 $R=\\sqrt{x^2+y^2}$ 是与奇异点之间的径向距离。变换定义如下：\n$$\nx = r \\cos\\theta\n$$\n$$\ny = r \\sin\\theta\n$$\n微分面积元 $dx \\, dy$ 根据变换的雅可比行列式进行变换：\n$$\ndx \\, dy = |J| \\, dr \\, d\\theta = r \\, dr \\, d\\theta\n$$\n被积函数，即积分核，变为：\n$$\n\\frac{1}{\\sqrt{x^{2}+y^{2}}} = \\frac{1}{\\sqrt{(r\\cos\\theta)^{2} + (r\\sin\\theta)^{2}}} = \\frac{1}{\\sqrt{r^{2}(\\cos^{2}\\theta + \\sin^{2}\\theta)}} = \\frac{1}{r}\n$$\n将这些代入积分，我们观察到一个关键的抵消：\n$$\n\\frac{1}{\\sqrt{x^{2}+y^{2}}} dx \\, dy = \\frac{1}{r} (r \\, dr \\, d\\theta) = dr \\, d\\theta\n$$\n这种变换通过用雅可比行列式中的因子 $r$ 抵消 $1/r$ 奇异性，有效地对积分进行了正则化。问题现在简化为在变换后的域上对常数函数 $1$ 进行积分。\n\n接下来，我们必须确定与三角形域 $T$ 相对应的 $r$ 和 $\\theta$ 的积分限。\n条件 $x \\ge 0$ 和 $y \\ge 0$ 将角度 $\\theta$ 限制在第一象限，因为 $r \\ge 0$。因此，$\\theta$ 的积分限为：\n$$\n0 \\le \\theta \\le \\frac{\\pi}{2}\n$$\n第三个条件 $x+y \\le 1$ 定义了径向坐标 $r$ 的上界。代入极坐标表达式：\n$$\nr \\cos\\theta + r \\sin\\theta \\le 1\n$$\n$$\nr(\\cos\\theta + \\sin\\theta) \\le 1\n$$\n由于对于 $\\theta \\in [0, \\pi/2]$，$\\cos\\theta + \\sin\\theta > 0$，我们可以将 $r$ 的上界写为：\n$$\nr \\le \\frac{1}{\\cos\\theta + \\sin\\theta}\n$$\n$r$ 的下界是 $0$。因此，极坐标下的积分为：\n$$\nI = \\int_{0}^{\\frac{\\pi}{2}} \\int_{0}^{\\frac{1}{\\cos\\theta + \\sin\\theta}} 1 \\, dr \\, d\\theta\n$$\n我们首先计算关于 $r$ 的内层积分：\n$$\n\\int_{0}^{\\frac{1}{\\cos\\theta + \\sin\\theta}} 1 \\, dr = [r]_{0}^{\\frac{1}{\\cos\\theta + \\sin\\theta}} = \\frac{1}{\\cos\\theta + \\sin\\theta}\n$$\n现在，剩下关于 $\\theta$ 的外层积分：\n$$\nI = \\int_{0}^{\\frac{\\pi}{2}} \\frac{1}{\\cos\\theta + \\sin\\theta} \\, d\\theta\n$$\n为了计算这个积分，我们使用辅助角公式，将分母表示为 $A\\cos(\\theta-\\alpha)$ 的形式。我们设 $\\cos\\theta + \\sin\\theta = A(\\cos\\theta\\cos\\alpha + \\sin\\theta\\sin\\alpha)$。通过比较 $\\cos\\theta$ 和 $\\sin\\theta$ 的系数，我们得到 $A\\cos\\alpha = 1$ 和 $A\\sin\\alpha = 1$。将这两个方程平方并相加，得到 $A^2(\\cos^2\\alpha + \\sin^2\\alpha) = 1^2 + 1^2$，即 $A^2 = 2$，所以 $A=\\sqrt{2}$。两式相除得到 $\\tan\\alpha=1$，所以 $\\alpha = \\pi/4$。\n因此，分母为 $\\cos\\theta + \\sin\\theta = \\sqrt{2}\\cos(\\theta - \\pi/4)$。积分变为：\n$$\nI = \\int_{0}^{\\frac{\\pi}{2}} \\frac{1}{\\sqrt{2}\\cos(\\theta - \\pi/4)} \\, d\\theta = \\frac{1}{\\sqrt{2}} \\int_{0}^{\\frac{\\pi}{2}} \\sec\\left(\\theta - \\frac{\\pi}{4}\\right) \\, d\\theta\n$$\n让我们进行换元 $u = \\theta - \\pi/4$。那么 $du = d\\theta$。$u$ 的积分限为：\n当 $\\theta=0$ 时，$u = -\\pi/4$。\n当 $\\theta=\\pi/2$ 时，$u = \\pi/2 - \\pi/4 = \\pi/4$。\n积分变换为：\n$$\nI = \\frac{1}{\\sqrt{2}} \\int_{-\\pi/4}^{\\pi/4} \\sec(u) \\, du\n$$\n$\\sec(u)$ 的标准原函数是 $\\ln|\\sec(u) + \\tan(u)|$。在积分限上求值：\n$$\nI = \\frac{1}{\\sqrt{2}} \\left[ \\ln|\\sec(u) + \\tan(u)| \\right]_{-\\pi/4}^{\\pi/4}\n$$\n$$\nI = \\frac{1}{\\sqrt{2}} \\left( \\ln\\left|\\sec\\left(\\frac{\\pi}{4}\\right) + \\tan\\left(\\frac{\\pi}{4}\\right)\\right| - \\ln\\left|\\sec\\left(-\\frac{\\pi}{4}\\right) + \\tan\\left(-\\frac{\\pi}{4}\\right)\\right| \\right)\n$$\n代入数值 $\\sec(\\pi/4) = \\sqrt{2}$、$\\tan(\\pi/4) = 1$、$\\sec(-\\pi/4) = \\sqrt{2}$ 和 $\\tan(-\\pi/4) = -1$：\n$$\nI = \\frac{1}{\\sqrt{2}} \\left( \\ln|\\sqrt{2} + 1| - \\ln|\\sqrt{2} - 1| \\right)\n$$\n由于 $\\sqrt{2}+1 > 0$ 且 $\\sqrt{2}-1 > 0$，绝对值符号可以去掉。利用对数性质 $\\ln(a) - \\ln(b) = \\ln(a/b)$：\n$$\nI = \\frac{1}{\\sqrt{2}} \\ln\\left(\\frac{\\sqrt{2}+1}{\\sqrt{2}-1}\\right)\n$$\n为了简化对数的自变量，我们将分子和分母同乘以分母的共轭式：\n$$\n\\frac{\\sqrt{2}+1}{\\sqrt{2}-1} = \\frac{(\\sqrt{2}+1)(\\sqrt{2}+1)}{(\\sqrt{2}-1)(\\sqrt{2}+1)} = \\frac{(\\sqrt{2}+1)^{2}}{2-1} = (\\sqrt{2}+1)^{2}\n$$\n将此结果代回 $I$ 的表达式中：\n$$\nI = \\frac{1}{\\sqrt{2}} \\ln\\left( (\\sqrt{2}+1)^{2} \\right) = \\frac{2}{\\sqrt{2}} \\ln(\\sqrt{2}+1) = \\sqrt{2}\\ln(1+\\sqrt{2})\n$$\n问题还要求明确对数贡献的来源。对数来自于问题的角度积分部分，特别是对正割函数 $\\sec(u)$ 的积分。该积分自然地得到一个对数函数。虽然极坐标变换消除了原始的 $1/r$ 代数奇异性，但积分域边界的几何形状在极坐标下表示时，会产生一个被积函数 $f(\\theta)$，其原函数包含对数项。\n\n在曲面积分方程的数值积分背景下，进行这种解析计算正是为了避免对奇异函数进行数值积分的困难。然而，如果使用仅基于正则化（例如，Duffy变换）的更通用的数值方案，坐标变换会将积分转化为 $\\int_0^1 \\int_0^1 f(u,v) \\, du \\, dv$ 的形式，其中新的被积函数 $f(u,v)$ 不再具有代数奇异性，但可能包含形如 $\\ln(u)$ 的项。这个可积的对数奇异性 $\\ln(u)$ 就是必须谨慎处理的项，通常通过采用专门的求积法则（如高斯-对数求积）来获得精确的数值结果。",
            "answer": "$$\n\\boxed{\\sqrt{2}\\ln(1+\\sqrt{2})}\n$$"
        },
        {
            "introduction": "现实世界中的散射问题通常涉及带有尖锐边缘或顶点的物体，这些几何特征会在表面感应电流上引起奇异行为。简单的均匀离散化无法准确捕捉这些奇异点。本编程练习  将展示网格“加密”技术（即在几何奇异点附近加密网格）的必要性，并让你量化该技术对数值解收敛速度的显著影响。",
            "id": "3352485",
            "problem": "考虑一个静电散射代理模型，该模型捕捉了曲面积分方程 (SIE) 公式在尖锐几何特征附近的本质奇异行为。从麦克斯韦方程组出发，在忽略时间依赖性的静力学极限下，电场满足 $\\nabla \\times \\mathbf{E} = \\mathbf{0}$ 和 $\\nabla \\cdot \\mathbf{E} = \\rho/\\varepsilon$。通过 $\\mathbf{E} = -\\nabla u$ 引入电势 $u$，在一个完美导电包体外部的无源区域中，可以得到 $\\Delta u = 0$，并在导体边界上满足狄利克雷边界条件 $u = u_0$。在二维情况下，设 $S$ 表示一个薄的完美导电屏，模型为 $x$ 轴上的线段 $[-1,1]$。可以使用二维拉普拉斯格林函数 $G(x,y) = -\\frac{1}{2\\pi}\\log|x - y|$，通过单层势来表示 $u$。该表示在边界上的限制产生了一个针对未知表面电荷密度 $\\sigma$ 的第一类 SIE 方程，\n$$\n\\int_{-1}^{1} G(x,y)\\,\\sigma(y)\\,\\mathrm{d}y = g(x), \\quad x \\in (-1,1),\n$$\n其中 $g(x)$ 是给定的边界数据。\n\n在尖锐边缘和尖端附近，曲面积分方程的解通常表现出奇异行为。对于这个屏线段，在某些恒定边界数据下，精确的表面电荷密度在端点 $x=\\pm1$ 附近的行为类似于 $C/\\sqrt{1 - x^{2}}$，这模仿了典型的楔形尖端奇异性。你的任务是实现并分析一种能够捕捉这种奇异性的离散化策略和网格加密方案，并量化数值 SIE 解相对于加密指数的收敛速度，并与均匀细化进行比较。\n\n你必须实现以下步骤和设计选择：\n\n1. 方程构建与离散化：\n   - 使用核为 $G(x,y) = -\\frac{1}{2\\pi}\\log|x - y|$ 的单层算子来构建线段 $[-1,1]$ 上的 SIE 方程 $\\int_{-1}^{1} G(x,y)\\,\\sigma(y)\\,\\mathrm{d}y = g(x)$。\n   - 将狄利克雷边界数据设置为常数 $g(x) = \\frac{\\log 2}{2}$，这会在 $\\sigma$ 中引发楔形尖端特有的端点奇异性。\n   - 使用分片常数基函数的基于单元的配置法对积分方程进行离散化。将 $[-1,1]$ 分割为 $N$ 个单元，其端点为 $\\{a_j,b_j\\}_{j=1}^{N}$，并使用配置点 $x_i = \\frac{a_i + b_i}{2}$。\n   - 组装稠密系统矩阵 $A \\in \\mathbb{R}^{N \\times N}$，其元素为\n     $$\n     A_{ij} = \\int_{a_j}^{b_j} G(x_i,y)\\,\\mathrm{d}y = -\\frac{1}{2\\pi}\\int_{a_j}^{b_j} \\log|x_i - y|\\,\\mathrm{d}y,\n     $$\n     对于每个单元上的常数基函数，该积分可通过微积分精确求值。求解 $A \\boldsymbol{\\sigma} = \\boldsymbol{g}$ 以获得单元常数未知量 $\\{\\sigma_j\\}_{j=1}^{N}$，其中 $\\boldsymbol{g}$ 是元素为 $g(x_i)$ 的常数向量。\n\n2. 网格设计：\n   - 实现一个均匀网格 ($p = 1$)，其单元端点为 $x_k = -1 + 2s_k$，其中 $s_k = \\frac{k}{N}$，$k = 0,1,\\dots,N$。\n   - 通过映射\n     $$\n     \\beta_p(s) = \\frac{s^{p}}{s^{p} + (1 - s)^{p}}, \\quad x_k = -1 + 2\\,\\beta_p\\!\\left(\\frac{k}{N}\\right), \\quad k = 0,1,\\dots,N,\n     $$\n     实现一个针对通用加密指数 $p \\geq 1$ 的对称加密网格。该映射将单元聚集在 $x=\\pm1$ 附近，以更好地解析端点奇异性。使用节点 $\\{x_k\\}$ 作为 $\\{a_j,b_j\\}$，其中 $a_j = x_{j-1}$ 和 $b_j = x_j$。\n\n3. 误差度量与收敛速度：\n   - 对于每个离散化方案，定义配置点 $x_i = \\frac{a_i + b_i}{2}$，并将数值密度 $\\sigma_i$ 与在 $x_i$ 处求值的精确奇异剖面 $\\sigma^{\\star}(x) = \\frac{1}{\\sqrt{1 - x^{2}}}$ 进行比较。\n   - 计算离散 $L^{2}$ 误差\n     $$\n     E(N,p) = \\left(\\sum_{i=1}^{N} \\left(\\sigma_i - \\sigma^{\\star}(x_i)\\right)^{2} \\,(b_i - a_i)\\right)^{1/2}.\n     $$\n   - 对于在相同加密指数 $p$ 下具有单元数 $N_1$ 和 $N_2$ 的两个离散化方案，估计关于 $N$ 的实验收敛阶 (EOC) 为\n     $$\n     \\mathrm{EOC}(N_1,N_2,p) = \\frac{\\log\\left(\\frac{E(N_1,p)}{E(N_2,p)}\\right)}{\\log\\left(\\frac{N_2}{N_1}\\right)}.\n     $$\n\n4. 测试套件：\n   - 实现以下测试用例，每个用例由 $(N_1,N_2,p)$ 定义：\n     - $(N_1,N_2,p) = (32,64,1)$,\n     - $(N_1,N_2,p) = (32,64,2)$,\n     - $(N_1,N_2,p) = (32,64,4)$,\n     - $(N_1,N_2,p) = (16,32,8)$,\n     - $(N_1,N_2,p) = (8,16,1)$.\n   - 选择这些用例是为了覆盖均匀基线、中度加密、强加密以及一个低 $N$ 值的边缘情况。\n\n5. 最终输出格式：\n   - 你的程序必须输出一行，其中包含上述测试用例的估计收敛速度，顺序完全一致，格式为逗号分隔的 Python 风格列表。每个数字必须四舍五入到六位小数。例如，输出行应如下所示\n     $$\n     [r_1,r_2,r_3,r_4,r_5]\n     $$\n     其中 $r_i$ 是对应于五个测试用例的四舍五入后的 $\\mathrm{EOC}$ 值。\n\n所有数学运算都应以数值方式实现，程序必须是自包含的，无需任何外部输入即可产生单行输出。此问题不涉及任何物理单位或角度；所有量都是无量纲的。你的实现必须仅依赖于所描述的积分方程、离散化和网格策略，以量化加密在楔形和尖端附近对 SIE 解收敛速度的影响。",
            "solution": "该问题要求实现并分析一种数值方法，以求解一个特定的一维静电学曲面积分方程 (SIE)。目标是量化网格加密对解的收敛速度的影响，尤其是在捕捉尖锐边缘附近电荷密度的奇异行为方面。\n\n控制方程是关于区间 $[-1,1]$ 上未知表面电荷密度 $\\sigma(y)$ 的第一类弗雷德霍姆积分方程：\n$$\n\\int_{-1}^{1} G(x,y)\\,\\sigma(y)\\,\\mathrm{d}y = g(x), \\quad x \\in (-1,1)\n$$\n这里，$G(x,y) = -\\frac{1}{2\\pi}\\log|x - y|$ 是拉普拉斯算子的二维格林函数，右侧是给定的恒定势 $g(x) = \\frac{\\log 2}{2}$。对于这个特定的势，已知的精确电荷密度为 $\\sigma^{\\star}(x) = \\frac{1}{\\sqrt{1 - x^{2}}}$，它在端点 $x = \\pm 1$ 处表现出奇异性。\n\n我们的方法是使用基于单元的配置法来求解这个积分方程，该方法也被称为边界元法 (BEM) 或矩量法 (MoM)。\n\n**1. 离散化与矩阵构建**\n\n我们将域 $[-1,1]$ 划分为 $N$ 个连续的单元或元素。设第 $j$ 个单元是区间 $[a_j, b_j]$。我们将未知的电荷密度 $\\sigma(y)$ 近似为分片常数函数：\n$$\n\\sigma(y) \\approx \\sum_{j=1}^{N} \\sigma_j \\phi_j(y)\n$$\n其中 $\\sigma_j$ 是第 $j$ 个单元上电荷密度的未知常数值，而 $\\phi_j(y)$ 是一个基函数，当 $y \\in [a_j, b_j]$ 时为 $1$，否则为 $0$。\n\n将此近似代入积分方程得到：\n$$\n\\sum_{j=1}^{N} \\sigma_j \\int_{a_j}^{b_j} G(x,y)\\,\\mathrm{d}y = g(x)\n$$\n为了确定 $N$ 个未知系数 $\\{\\sigma_j\\}$，我们在 $N$ 个不同的配置点上强制执行此方程。对于分片常数基函数，一个标准的选择是使用每个单元的中点作为配置点，即 $x_i = \\frac{a_i + b_i}{2}$，$i=1, \\dots, N$。这会导出一个线性方程组 $A\\boldsymbol{\\sigma} = \\boldsymbol{g}$，其中 $\\boldsymbol{\\sigma} = [\\sigma_1, \\dots, \\sigma_N]^T$ 是未知系数向量，$\\boldsymbol{g}$ 是在配置点上求值的右侧值向量，$g_i = g(x_i) = \\frac{\\log 2}{2}$，$A$ 是 $N \\times N$ 的系统矩阵。\n\n矩阵 $A$ 的元素由格林函数在每个单元上的积分给出：\n$$\nA_{ij} = \\int_{a_j}^{b_j} G(x_i,y)\\,\\mathrm{d}y = -\\frac{1}{2\\pi}\\int_{a_j}^{b_j} \\log|x_i - y|\\,\\mathrm{d}y\n$$\n这个积分可以解析地计算。$\\log|c-y|$ 关于 $y$ 的不定积是 $(y-c)\\log|y-c| - y$。在单元端点 $a_j$ 和 $b_j$ 处求值得到：\n$$\n\\int_{a_j}^{b_j} \\log|x_i - y|\\,\\mathrm{d}y = \\left[ (y-x_i)\\log|y-x_i| - y \\right]_{y=a_j}^{y=b_j}\n$$\n$$\n= \\left( (b_j-x_i)\\log|b_j-x_i| - b_j \\right) - \\left( (a_j-x_i)\\log|a_j-x_i| - a_j \\right)\n$$\n$$\n= (b_j-x_i)\\log|b_j-x_i| - (a_j-x_i)\\log|a_j-x_i| - (b_j-a_j)\n$$\n这个公式对于非对角线 ($i \\neq j$) 和对角线 ($i=j$) 元素都有效，因为对数奇异性是可积的。矩阵元素的最终表达式为：\n$$\nA_{ij} = -\\frac{1}{2\\pi} \\left( (b_j-x_i)\\log|b_j-x_i| - (a_j-x_i)\\log|a_j-x_i| - (b_j-a_j) \\right)\n$$\n\n**2. 网格生成**\n\n数值解的精度高度依赖于单元的布置。为了解析 $x = \\pm 1$ 处的奇异性，单元必须在端点附近变得更小。这通过使用加密网格来实现。\n\n我们生成一组 $N+1$ 个节点 $\\{x_k\\}_{k=0}^N$ 来定义单元边界。第 $j$ 个单元是 $[a_j, b_j] = [x_{j-1}, x_j]$。节点是通过从区间 $[0,1]$ 中的均匀网格 $s_k = k/N$（其中 $k=0, \\dots, N$）到物理域 $[-1,1]$ 的一个映射来定义的。加密由一个参数 $p \\geq 1$ 控制。\n加密函数为：\n$$\n\\beta_p(s) = \\frac{s^{p}}{s^{p} + (1 - s)^{p}}\n$$\n物理节点位置则为：\n$$\nx_k = -1 + 2\\,\\beta_p\\!\\left(\\frac{k}{N}\\right)\n$$\n当 $p=1$ 时，$\\beta_1(s) = s$，这会产生一个节点等距的均匀网格。当 $p > 1$ 时，函数 $\\beta_p(s)$ 在 $s=0$ 和 $s=1$ 附近有陡峭的斜率，这将节点 $x_k$ 聚集到端点 $-1$ 和 $1$ 附近。对于 $\\frac{1}{\\sqrt{1-x^2}}$ 类型的奇异性，选择 $p=2$ 已知是特别有效的。\n\n**3. 误差计算与收敛性分析**\n\n在组装矩阵 $A$ 和向量 $\\boldsymbol{g}$ 之后，我们求解稠密线性系统 $A\\boldsymbol{\\sigma} = \\boldsymbol{g}$ 以获得数值解系数 $\\sigma_i$。为了量化精度，我们通过将此数值解与在配置点 $x_i$ 处求值的已知精确解 $\\sigma^{\\star}(x) = \\frac{1}{\\sqrt{1-x^2}}$ 进行比较来计算误差。\n\n离散 $L^2$ 误差定义为在所有单元上的加权和：\n$$\nE(N,p) = \\left(\\sum_{i=1}^{N} \\left(\\sigma_i - \\sigma^{\\star}(x_i)\\right)^{2} \\,(b_i - a_i)\\right)^{1/2}\n$$\n其中 $(b_i-a_i)$ 是第 $i$ 个单元的长度。\n\n为了分析收敛行为，我们计算实验收敛阶 (EOC)。EOC 衡量的是随着单元数 $N$ 的增加，误差减小的速率。对于具有单元数 $N_1$ 和 $N_2$（通常 $N_2 > N_1$）的两个离散化方案，EOC 估计为：\n$$\n\\mathrm{EOC}(N_1,N_2,p) = \\frac{\\log\\left(\\frac{E(N_1,p)}{E(N_2,p)}\\right)}{\\log\\left(\\frac{N_2}{N_1}\\right)}\n$$\n更高的 EOC 表示更快的收敛。对于均匀网格 ($p=1$)，由于未解析的奇异性，EOC 预计会很低（理论上为 $0.5$）。适当选择的加密 ($p=2$) 应能显著提高 EOC（理论上达到 $1.5$）。过度加密 ($p>2$) 可能会降低性能，因为误差会由域中心较大的单元主导。\n\n实现将包括生成网格、组装矩阵、求解系统以及为指定的测试用例计算 EOC 的函数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve as sp_solve\n\ndef create_mesh(N, p):\n    \"\"\"\n    Generates a graded mesh on [-1, 1] with N panels and grading exponent p.\n\n    Args:\n        N (int): Number of panels.\n        p (float): Grading exponent. p=1 corresponds to a uniform mesh.\n\n    Returns:\n        tuple: A tuple containing:\n            - collocation_pts (np.ndarray): Midpoints of the panels.\n            - panel_endpoints_a (np.ndarray): Start points of the panels.\n            - panel_endpoints_b (np.ndarray): End points of the panels.\n            - panel_lengths (np.ndarray): Lengths of the panels.\n    \"\"\"\n    s = np.linspace(0, 1, N + 1)\n    \n    # Grading function beta_p(s)\n    if p == 1.0:\n        beta_s = s\n    else:\n        s_p = s**p\n        one_minus_s_p = (1 - s)**p\n        # Add a small epsilon for numerical stability at s=0 and s=1, though numpy handles it.\n        # This becomes relevant if s_p and one_minus_s_p are both zero, which isn't the case here.\n        denominator = s_p + one_minus_s_p\n        beta_s = s_p / denominator\n        \n    endpoints = -1 + 2 * beta_s\n    \n    panel_endpoints_a = endpoints[:-1]\n    panel_endpoints_b = endpoints[1:]\n    \n    collocation_pts = (panel_endpoints_a + panel_endpoints_b) / 2\n    panel_lengths = panel_endpoints_b - panel_endpoints_a\n    \n    return collocation_pts, panel_endpoints_a, panel_endpoints_b, panel_lengths\n\ndef compute_error(N, p):\n    \"\"\"\n    Computes the discrete L2 error for a given discretization (N, p).\n    \"\"\"\n    collocation_pts, aj, bj, panel_lengths = create_mesh(N, p)\n    \n    # Assemble the matrix A using vectorized operations\n    xi = collocation_pts[:, np.newaxis] # Shape (N, 1)\n    aj_row = aj[np.newaxis, :]         # Shape (1, N)\n    bj_row = bj[np.newaxis, :]         # Shape (1, N)\n\n    # Use a helper for x*log|x| to handle x=0 case, though not strictly needed here\n    # as collocation points are never at panel boundaries.\n    def x_log_abs_x(x):\n        # np.log(0) is -inf, 0 * -inf is nan. We want it to be 0.\n        res = np.zeros_like(x, dtype=float)\n        mask = x != 0\n        res[mask] = x[mask] * np.log(np.abs(x[mask]))\n        return res\n        \n    term1 = x_log_abs_x(bj_row - xi)\n    term2 = x_log_abs_x(aj_row - xi)\n    \n    integral_val = term1 - term2 - (bj_row - aj_row)\n    A = -1 / (2 * np.pi) * integral_val\n\n    # Assemble the right-hand side vector g\n    g_val = np.log(2) / 2\n    g_vector = np.full(N, g_val)\n    \n    # Solve the linear system A * sigma = g\n    sigma = sp_solve(A, g_vector)\n    \n    # Compute the exact solution at collocation points\n    # 1 - x^2 can be calculated stably as (1-x)(1+x)\n    one_minus_x2 = 1 - collocation_pts**2\n    # Ensure no division by zero for points very close to +/- 1\n    one_minus_x2[one_minus_x2 = 0] = np.finfo(float).eps\n    exact_sigma = 1 / np.sqrt(one_minus_x2)\n    \n    # Compute the discrete L2 error\n    error_sq_sum = np.sum((sigma - exact_sigma)**2 * panel_lengths)\n    error = np.sqrt(error_sq_sum)\n    \n    return error\n\ndef calculate_eoc(N1, N2, p):\n    \"\"\"\n    Calculates the Experimental Order of Convergence (EOC).\n    \"\"\"\n    error1 = compute_error(N1, p)\n    error2 = compute_error(N2, p)\n    \n    eoc = np.log(error1 / error2) / np.log(N2 / N1)\n    \n    return eoc\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # test_cases are (N1, N2, p)\n    test_cases = [\n        (32, 64, 1),\n        (32, 64, 2),\n        (32, 64, 4),\n        (16, 32, 8),\n        (8, 16, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        N1, N2, p = case\n        eoc = calculate_eoc(N1, N2, p)\n        # Round to six decimal places as required.\n        results.append(round(eoc, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了离散化策略，选择合适的积分方程（EFIE、MFIE 或混合的 CFIE）对于确保在所有频率下获得唯一且良态的解至关重要。本练习  利用一个简化但具有代表性的谱模型，来探索优化组合场积分方程（CFIE）的艺术。你将设计并比较不同的策略来选择混合参数 $\\alpha$，以最小化系统矩阵的条件数，从而揭示如何在不同方程的优缺点之间进行权衡，以获得稳健的宽带性能。",
            "id": "3352519",
            "problem": "您的任务是设计并评估一种频率自适应策略，该策略用于计算电磁学中表面积分方程公式的一个在科学上忠实但简化的谱代理模型中的组合场积分方程 (CFIE) 参数。目标是确定一个参数函数 $\\alpha(k)$，其中 $\\alpha(k) \\in [0,1]$，以在一系列波数 $k$（单位为弧度/米）的扫描中，最小化离d散化 CFIE 系统矩阵的条件数。您将比较一个均匀选择 $\\alpha(k) \\equiv \\alpha$ 和一个在每个 $k$ 值下选择的自适应策略 $\\alpha(k)$。\n\n物理基础是用于描述来自理想电导体 (PEC) 闭合表面散射的时谐麦克斯韦方程组。经过标准的边界积分方程公式化和使用 Rao–Wilton–Glisson (RWG) 基函数进行离散化后，可得到电场积分方程 (EFIE) 和磁场积分方程 (MFIE) 的系统矩阵，分别表示为 $\\mathbf{A}_{\\mathrm{E}}(k)$ 和 $\\mathbf{A}_{\\mathrm{M}}(k)$。CFIE 矩阵构造如下：\n$$\n\\mathbf{A}_{\\mathrm{C}}(\\alpha,k) \\triangleq \\alpha\\,\\mathbf{A}_{\\mathrm{E}}(k) + \\left(1-\\alpha\\right)\\,\\mathbf{A}_{\\mathrm{M}}(k),\n$$\n其中 $\\alpha \\in [0,1]$ 是 CFIE 混合参数。一个非奇异矩阵 $\\mathbf{B}$ 的条件数定义为\n$$\n\\kappa(\\mathbf{B}) \\triangleq \\|\\mathbf{B}\\|_{2}\\,\\|\\mathbf{B}^{-1}\\|_{2},\n$$\n对于可对角化的对称正定代理模型，该值简化为最大特征值与最小特征值之比。\n\n为了使问题在计算上易于处理，同时保留关键的谱特征（EFIE 的低频失效和内部共振凹陷），您将使用一个谱代理模型，其中 $\\mathbf{A}_{\\mathrm{E}}(k)$ 和 $\\mathbf{A}_{\\mathrm{M}}(k)$ 在一个具有 $N$ 个模式的固定正交归一基中是对角的，并且具有依赖于 $k$ 的正特征值 $\\{\\lambda_{\\mathrm{E},i}(k)\\}_{i=1}^N$ 和 $\\{\\lambda_{\\mathrm{M},i}(k)\\}_{i=1}^N$。于是，CFIE 的特征值为\n$$\n\\lambda_{\\mathrm{C},i}(\\alpha,k) = \\alpha\\,\\lambda_{\\mathrm{E},i}(k) + \\left(1-\\alpha\\right)\\,\\lambda_{\\mathrm{M},i}(k), \\quad i\\in\\{1,\\dots,N\\}.\n$$\nCFIE 代理模型的条件数为\n$$\n\\kappa(\\alpha,k) = \\frac{\\max_{i}\\lambda_{\\mathrm{C},i}(\\alpha,k)}{\\min_{i}\\lambda_{\\mathrm{C},i}(\\alpha,k)}.\n$$\n\n使用 $N=6$ 个模式。通过带有窄共振凹陷的低阶多项式基线来定义 EFIE 特征值：\n$$\n\\lambda_{\\mathrm{E},i}(k) = \\left(a_i + b_i\\,k + c_i\\,k^2\\right)\\,\\prod_{r \\in \\mathcal{R}_i}\\left(1 - h_{i,r}\\,\\exp\\left(-\\frac{(k-k_{i,r})^2}{2\\,\\sigma_{i,r}^2}\\right)\\right),\n$$\n其中 $k$ 的单位是弧度/米。MFIE 特征值由带有平缓光滑凸起的缓慢变化基线定义：\n$$\n\\lambda_{\\mathrm{M},i}(k) = u_i + \\frac{v_i}{1+k} + \\sum_{m \\in \\mathcal{M}_i} g_{i,m}\\,\\exp\\left(-\\frac{(k-\\mu_{i,m})^2}{2\\,\\tau_{i,m}^2}\\right).\n$$\n在下面的扫描中，所有特征值对于所有 $k$ 都必须保持严格为正。使用以下常数（所有标量均为实数且严格为正）：\n\n- 对于 EFIE 系数 $\\{a_i\\}_{i=1}^{6}$，$\\{b_i\\}_{i=1}^{6}$，$\\{c_i\\}_{i=1}^{6}$：\n  - $a_1 = 10^{-3}$，$a_2 = 0.3$，$a_3 = 0.4$，$a_4 = 10^{-3}$，$a_5 = 0.6$，$a_6 = 0.8$。\n  - $b_1 = 0.05$，$b_2 = 0.04$，$b_3 = 0.02$，$b_4 = 0.07$，$b_5 = 0.03$，$b_6 = 0.01$。\n  - $c_1 = 0.005$，$c_2 = 0.003$，$c_3 = 0.004$，$c_4 = 0.006$，$c_5 = 0.002$，$c_6 = 0.003$。\n- EFIE 共振集 $\\mathcal{R}_i$：\n  - $\\mathcal{R}_2 = \\{r\\}$，其中 $k_{2,r} = 3.0$，$\\sigma_{2,r} = 0.2$，$h_{2,r} = 0.9$。\n  - $\\mathcal{R}_5 = \\{r\\}$，其中 $k_{5,r} = 7.5$，$\\sigma_{5,r} = 0.25$，$h_{5,r} = 0.85$。\n  - 对于 $i \\in \\{1,3,4,6\\}$，$\\mathcal{R}_i = \\emptyset$。\n- 对于 MFIE 系数 $\\{u_i\\}_{i=1}^{6}$，$\\{v_i\\}_{i=1}^{6}$：\n  - $u_1 = 0.9$，$u_2 = 1.0$，$u_3 = 1.1$，$u_4 = 0.8$，$u_5 = 1.2$，$u_6 = 1.0$。\n  - $v_1 = 0.3$，$v_2 = 0.25$，$v_3 = 0.2$，$v_4 = 0.35$，$v_5 = 0.15$，$v_6 = 0.22$。\n- MFIE 凸起集 $\\mathcal{M}_i$：\n  - $\\mathcal{M}_3 = \\{m\\}$，其中 $\\mu_{3,m} = 6.0$，$\\tau_{3,m} = 0.4$，$g_{3,m} = 0.10$。\n  - $\\mathcal{M}_6 = \\{m\\}$，其中 $\\mu_{6,m} = 4.0$，$\\tau_{6,m} = 0.3$，$g_{6,m} = 0.08$。\n  - 对于 $i \\in \\{1,2,4,5\\}$，$\\mathcal{M}_i = \\emptyset$。\n\n您的目标是设计、实现并比较以下两种 CFIE 参数选择策略：\n\n- 均匀策略：选择单个 $\\alpha^{\\star} \\in [0,1]$，以最小化在频率扫描 $\\{k_j\\}_{j=1}^{M}$ 上的平均对数条件数：\n$$\nJ(\\alpha) \\triangleq \\frac{1}{M}\\sum_{j=1}^{M} \\log \\kappa(\\alpha,k_j).\n$$\n- 频率自适应策略：为每个 $k_j$ 选择 $\\alpha^{\\star}(k_j) \\in [0,1]$ 以最小化 $\\kappa(\\alpha,k_j)$。\n\n对于这两种策略，报告扫描范围内的几何平均条件数，定义为\n$$\n\\mathrm{GM} \\triangleq \\exp\\left(\\frac{1}{M}\\sum_{j=1}^{M} \\log \\kappa(\\cdot,k_j)\\right).\n$$\n\n数值步骤与约束：\n\n- 将 $\\alpha$ 限制在 $[0,1]$ 上的一个稠密均匀网格上，步长为 $\\Delta \\alpha = 0.001$。这包括两个端点 $\\alpha=0$ 和 $\\alpha=1$。\n- 波数 $k$ 的单位是弧度/米 (rad/m)。条件数是无量纲的。\n- 按照描述实现代理模型，并确保在扫描中的每个 $k$ 值下，所有特征值都保持严格为正。\n\n测试套件：\n\n使用以下三个测试用例，每个用例包含 $M=61$ 个线性间隔点：\n\n- 用例 A (宽带多共振)：$k \\in [0.5,10.0]$ rad/m。\n- 用例 B (低频重点)：$k \\in [0.1,2.0]$ rad/m。\n- 用例 C (中高频)：$k \\in [3.0,9.0]$ rad/m。\n\n对于每个用例，计算并输出以下四个量：\n\n- 在扫描中最小化 $J(\\alpha)$ 的最优均匀 $\\alpha^{\\star}$。\n- 均匀策略的几何平均条件数 $\\mathrm{GM}_{\\mathrm{unif}}$。\n- 自适应策略的几何平均条件数 $\\mathrm{GM}_{\\mathrm{adapt}}$。\n- 改进因子 $R \\triangleq \\mathrm{GM}_{\\mathrm{unif}} / \\mathrm{GM}_{\\mathrm{adapt}}$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个扁平化的、逗号分隔的列表，列表由12个浮点数值组成，并用方括号括起来，按用例顺序排列如下\n$$\n[\\alpha^{\\star}_{\\mathrm{A}}, \\mathrm{GM}_{\\mathrm{unif,A}}, \\mathrm{GM}_{\\mathrm{adapt,A}}, R_{\\mathrm{A}}, \\alpha^{\\star}_{\\mathrm{B}}, \\mathrm{GM}_{\\mathrm{unif,B}}, \\mathrm{GM}_{\\mathrm{adapt,B}}, R_{\\mathrm{B}}, \\alpha^{\\star}_{\\mathrm{C}}, \\mathrm{GM}_{\\mathrm{unif,C}}, \\mathrm{GM}_{\\mathrm{adapt,C}}, R_{\\mathrm{C}}].\n$$\n所有输出必须四舍五入到恰好4位小数。不应打印任何其他文本。波数 $k$ 必须以弧度/米 (rad/m) 处理，所有要报告的量都是无量纲的。本问题不使用角度。不得出现百分比；如果计算了任何比率，必须以小数形式给出。程序必须是完全自包含的，无需任何输入。",
            "solution": "该问题是有效的，因为它在计算电磁学方面有科学依据，问题定义明确，并提供了一套完整且一致的定义和数据。任务是使用一个简化但具有代表性的谱代理模型，评估和比较兩種選擇组合场积分方程 (CFIE) 混合参数 $\\alpha$ 的策略。\n\n该问题的基础在于理想电导体 (PEC) 体电磁散射的积分方程公式。电场积分方程 (EFIE) 和磁场积分方程 (MFIE) 的离散化产生了线性系统，其矩阵分别为 $\\mathbf{A}_{\\mathrm{E}}(k)$ 和 $\\mathbf{A}_{\\mathrm{M}}(k)$，其中 $k$ 是波数。CFIE 结合了这两者以克服诸如内部共振和低频失效等数值问题。CFIE 系统矩阵是一个线性组合：\n$$\n\\mathbf{A}_{\\mathrm{C}}(\\alpha,k) = \\alpha\\,\\mathbf{A}_{\\mathrm{E}}(k) + \\left(1-\\alpha\\right)\\,\\mathbf{A}_{\\mathrm{M}}(k)\n$$\n其中混合参数 $\\alpha$ 通常选择在 $[0, 1]$ 范围内。该矩阵的条件，由其条件数 $\\kappa(\\mathbf{A}_{\\mathrm{C}})$ 衡量，对迭代求解器的性能至关重要。\n\n本问题采用了一个代理模型，其中矩阵是对角矩阵，具有 $N=6$ 个模式。$\\mathbf{A}_{\\mathrm{E}}(k)$ 和 $\\mathbf{A}_{\\mathrm{M}}(k)$ 的特征值由函数 $\\lambda_{\\mathrm{E},i}(k)$ 和 $\\lambda_{\\mathrm{M},i}(k)$ 给出，其中 $i \\in \\{1, \\dots, 6\\}$。这些函数旨在模仿其完整矩阵对应物的已知谱行为。具体来说，EFIE 代理模型的特征值由以下公式给出：\n$$\n\\lambda_{\\mathrm{E},i}(k) = \\left(a_i + b_i\\,k + c_i\\,k^2\\right)\\,\\prod_{r \\in \\mathcal{R}_i}\\left(1 - h_{i,r}\\,\\exp\\left(-\\frac{(k-k_{i,r})^2}{2\\,\\sigma_{i,r}^2}\\right)\\right)\n$$\n此形式包括一个多项式基线，对于某些模式（$i=1, 4$），其常数项 $a_i=10^{-3}$ 很小，用以模拟低频病态；还包括一个高斯凹陷的乘积，用以表示尖锐的内部共振。MFIE 代理模型的特征值为：\n$$\n\\lambda_{\\mathrm{M},i}(k) = u_i + \\frac{v_i}{1+k} + \\sum_{m \\in \\mathcal{M}_i} g_{i,m}\\,\\exp\\left(-\\frac{(k-\\mu_{i,m})^2}{2\\,\\tau_{i,m}^2}\\right)\n$$\n此形式在低频（$k \\to 0$）时表现良好，并包含了平滑的谱特征。所有提供的参数确保了在指定的 $k$ 范围内特征值严格为正。\n\n对于此对角代理模型，CFIE 矩阵的特征值是 EFIE 和 MFIE 特征值的简单线性组合：\n$$\n\\lambda_{\\mathrm{C},i}(\\alpha,k) = \\alpha\\,\\lambda_{\\mathrm{E},i}(k) + \\left(1-\\alpha\\right)\\,\\lambda_{\\mathrm{M},i}(k)\n$$\n对于正定对角矩阵，条件数是最大特征值与最小特征值之比，因此简化为：\n$$\n\\kappa(\\alpha,k) = \\frac{\\max_{i}\\lambda_{\\mathrm{C},i}(\\alpha,k)}{\\min_{i}\\lambda_{\\mathrm{C},i}(\\alpha,k)}\n$$\n目标是找到一个最优的 $\\alpha$ 以最小化此条件数。比较了两种策略。\n\n**1. 频率自适应策略**\n\n此策略通过为给定频率扫描 $\\{k_j\\}_{j=1}^M$ 中的每个单独波数 $k_j$ 选择一个最优的 $\\alpha$ 来寻求最佳性能。在每个 $k_j$ 处的优化问题是：\n$$\n\\alpha^{\\star}(k_j) = \\underset{\\alpha \\in \\{0, \\Delta\\alpha, \\dots, 1\\}}{\\arg\\min} \\kappa(\\alpha, k_j)\n$$\n其中对 $\\alpha$ 的搜索是在 $[0,1]$ 上的一个离散网格上进行的，步长为 $\\Delta\\alpha = 0.001$。此策略的整体性能通过所得最小化条件数的几何平均值来衡量：\n$$\n\\mathrm{GM}_{\\mathrm{adapt}} = \\exp\\left(\\frac{1}{M}\\sum_{j=1}^{M} \\log \\kappa(\\alpha^{\\star}(k_j),k_j)\\right)\n$$\n这为 CFIE 方法可实现的最佳条件设定了一个基准。\n\n**2. 均匀策略**\n\n此策略寻求一个单一的、固定的 $\\alpha$ 值，在整个频率扫描范围内平均表现良好。最优的均匀参数 $\\alpha^{\\star}$ 通过最小化平均对数条件数找到：\n$$\nJ(\\alpha) = \\frac{1}{M}\\sum_{j=1}^{M} \\log \\kappa(\\alpha,k_j)\n$$\n因此，优化问题是：\n$$\n\\alpha^{\\star} = \\underset{\\alpha \\in \\{0, \\Delta\\alpha, \\dots, 1\\}}{\\arg\\min} J(\\alpha)\n$$\n此策略的性能是使用这个单一的最优 $\\alpha^{\\star}$ 在所有频率上评估的几何平均条件数：\n$$\n\\mathrm{GM}_{\\mathrm{unif}} = \\exp\\left(\\frac{1}{M}\\sum_{j=1}^{M} \\log \\kappa(\\alpha^{\\star},k_j)\\right) = \\exp(J(\\alpha^{\\star}))\n$$\n两种策略之间的比较通过改进因子 $R = \\mathrm{GM}_{\\mathrm{unif}} / \\mathrm{GM}_{\\mathrm{adapt}}$ 来量化。\n\n解决每个测试用例问题的算法流程如下：\n1.  在 $[0,1]$ 上定义包含 1001 个点的 $\\alpha$ 离散网格，并为特定用例定义包含 $M=61$ 个点的波数 $k$ 网格。\n2.  向量化特征值的计算。对于 $k_j$值的数组，计算 EFIE 特征值的 $6 \\times M$ 矩阵 $[\\lambda_{\\mathrm{E},i}(k_j)]$ 和 MFIE 特征值的 $6 \\times M$ 矩阵 $[\\lambda_{\\mathrm{M},i}(k_j)]$。\n3.  使用 $\\alpha$ 网格上的广播操作，构建一个 $1001 \\times 6 \\times M$ 的 CFIE 特征值张量 $\\lambda_{\\mathrm{C},i}(\\alpha_p, k_j)$。\n4.  通过沿模式轴（$i$）取最大值与最小值的比率，计算 $1001 \\times M$ 的条件数矩阵 $[\\kappa(\\alpha_p, k_j)]$。\n5.  为评估自适应策略，沿 $\\alpha$ 轴为每个 $k_j$ 找到最小条件数。计算这些最小值的几何平均值以得到 $\\mathrm{GM}_{\\mathrm{adapt}}$。\n6.  为评估均匀策略，通过沿 $k$ 轴对每个 $\\alpha_p$ 取条件数对数的平均值来计算成本函数 $J(\\alpha_p)$。找到最小化 $J(\\alpha_p)$ 的 $\\alpha_p$ 以得到 $\\alpha^{\\star}$。$J$ 的最小值是 $\\log(\\mathrm{GM}_{\\mathrm{unif}})$，因此 $\\mathrm{GM}_{\\mathrm{unif}} = \\exp(\\min J(\\alpha_p))$。\n7.  计算改进因子 $R$ 并收集给定用例所需的四个值。\n8.  对所有三个测试用例重复此过程，并按规定格式化最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the CFIE parameter optimization problem for three test cases.\n    \"\"\"\n    \n    # Define model parameters\n    N = 6\n    # EFIE parameters\n    a = np.array([1e-3, 0.3, 0.4, 1e-3, 0.6, 0.8])\n    b = np.array([0.05, 0.04, 0.02, 0.07, 0.03, 0.01])\n    c = np.array([0.005, 0.003, 0.004, 0.006, 0.002, 0.003])\n    efie_res = {\n        1: {'k': 3.0, 'sigma': 0.2, 'h': 0.9},   # i=2\n        4: {'k': 7.5, 'sigma': 0.25, 'h': 0.85} # i=5\n    }\n    \n    # MFIE parameters\n    u = np.array([0.9, 1.0, 1.1, 0.8, 1.2, 1.0])\n    v = np.array([0.3, 0.25, 0.2, 0.35, 0.15, 0.22])\n    mfie_bumps = {\n        2: {'mu': 6.0, 'tau': 0.4, 'g': 0.10}, # i=3\n        5: {'mu': 4.0, 'tau': 0.3, 'g': 0.08}  # i=6\n    }\n    \n    def compute_lambda_E(k_vals):\n        \"\"\"Computes EFIE eigenvalues for all modes over a range of k.\"\"\"\n        lambda_E = np.zeros((N, len(k_vals)))\n        k_vals_sq = k_vals**2\n        for i in range(N):\n            poly_part = a[i] + b[i] * k_vals + c[i] * k_vals_sq\n            res_product = 1.0\n            if i in efie_res:\n                params = efie_res[i]\n                res_product *= (1 - params['h'] * np.exp(-(k_vals - params['k'])**2 / (2 * params['sigma']**2)))\n            lambda_E[i, :] = poly_part * res_product\n        return lambda_E\n\n    def compute_lambda_M(k_vals):\n        \"\"\"Computes MFIE eigenvalues for all modes over a range of k.\"\"\"\n        lambda_M = np.zeros((N, len(k_vals)))\n        for i in range(N):\n            base_part = u[i] + v[i] / (1 + k_vals)\n            bump_sum = 0.0\n            if i in mfie_bumps:\n                params = mfie_bumps[i]\n                bump_sum += params['g'] * np.exp(-(k_vals - params['mu'])**2 / (2 * params['tau']**2))\n            lambda_M[i, :] = base_part + bump_sum\n        return lambda_M\n        \n    test_cases = [\n        {'name': 'A', 'k_range': [0.5, 10.0]},\n        {'name': 'B', 'k_range': [0.1, 2.0]},\n        {'name': 'C', 'k_range': [3.0, 9.0]},\n    ]\n    M = 61\n    delta_alpha = 0.001\n    alpha_vals = np.linspace(0, 1, int(1/delta_alpha) + 1)\n    \n    final_results = []\n    \n    for case in test_cases:\n        k_vals = np.linspace(case['k_range'][0], case['k_range'][1], M)\n        \n        # Pre-compute eigenvalues\n        lambda_E_ik = compute_lambda_E(k_vals)\n        lambda_M_ik = compute_lambda_M(k_vals)\n        \n        # Vectorized calculation of CFIE eigenvalues and condition numbers\n        # Reshape for broadcasting:\n        # alpha_vals: (P, 1, 1) where P = number of alpha samples\n        # lambda_E/M_ik: (1, N, M) where N=modes, M=k samples\n        alpha_p11 = alpha_vals[:, np.newaxis, np.newaxis]\n        lambda_E_1NM = lambda_E_ik[np.newaxis, :, :]\n        lambda_M_1NM = lambda_M_ik[np.newaxis, :, :]\n        \n        # CFIE eigenvalues: (P, N, M)\n        lambda_C_piM = alpha_p11 * lambda_E_1NM + (1 - alpha_p11) * lambda_M_1NM\n        \n        # Condition numbers: (P, M)\n        kappa_pM = np.max(lambda_C_piM, axis=1) / np.min(lambda_C_piM, axis=1)\n        \n        # --- Frequency-adaptive strategy ---\n        min_kappa_adaptive_M = np.min(kappa_pM, axis=0)\n        log_kappa_adaptive_M = np.log(min_kappa_adaptive_M)\n        GM_adapt = np.exp(np.mean(log_kappa_adaptive_M))\n\n        # --- Uniform strategy ---\n        log_kappa_pM = np.log(kappa_pM)\n        J_p = np.mean(log_kappa_pM, axis=1)\n        \n        opt_alpha_idx = np.argmin(J_p)\n        alpha_star_uniform = alpha_vals[opt_alpha_idx]\n        \n        min_J = J_p[opt_alpha_idx]\n        GM_unif = np.exp(min_J)\n        \n        # --- Improvement Factor ---\n        R = GM_unif / GM_adapt\n        \n        final_results.extend([\n            round(alpha_star_uniform, 4),\n            round(GM_unif, 4),\n            round(GM_adapt, 4),\n            round(R, 4)\n        ])\n        \n    # Format and print the final output\n    print(f\"[{','.join(f'{v:.4f}' for v in final_results)}]\")\n\nsolve()\n```"
        }
    ]
}