{
    "hands_on_practices": [
        {
            "introduction": "本节将通过一个基础实践来开启我们的学习。我们将运用“人造解方法”（Method of Manufactured Solutions）这一强大的代码验证工具。通过先设定一个已知的精确解，然后反推出积分方程对应的源项，我们可以精确地衡量我们实现的数值方法的准确性和收敛阶，这是构建可靠科学计算程序的基石。这个练习将帮助您掌握点匹配（配点）方法的核心实现流程，并学会如何通过数值实验来验证理论收敛性。",
            "id": "3341400",
            "problem": "考虑区间 $[0,1]$ 上的一维第二类 Fredholm 积分方程，其形式如下：\n$$\nu(x) - \\lambda \\int_{0}^{1} e^{-|x - x'|}\\,u(x')\\,dx' = f(x), \\quad x \\in [0,1].\n$$\n使用“人造解”方法 (method of manufactured solutions)，令精确解为解析函数 $u(x) = e^{x}$。您的第一个任务是通过将 $u(x)$ 代入积分方程，并以 $x$ 和 $\\lambda$ 的形式精确计算该积分，来构造相应的右端项 $f(x)$。您的第二个任务是实现一个在均匀网格上使用分片线性基函数的点匹配（配置）法 (point-matching (collocation) scheme) 来近似 $u(x)$，并通过均匀网格细化来凭经验量化所观察到的收敛阶。\n\n从以下基本概念出发：\n- 第二类 Fredholm 积分方程的定义，即 $u - \\lambda \\mathcal{K}u = f$，其中 $(\\mathcal{K}u)(x) = \\int_{0}^{1} K(x,x') u(x')\\,dx'$。\n- 点匹配（配置）法：用一个在基底 $\\{\\phi_j(x)\\}$ 中表达的有限维函数 $u_h(x)$ 来近似 $u(x)$，并在选定的点上强制满足该方程，以形成一个方阵线性系统。\n\n使用以下设置：\n- 令核函数为 $K(x,x') = e^{-|x-x'|}$。\n- 使用 $[0,1]$ 的一个均匀划分，包含 $N$ 个子区间和节点 $x_j = j h$，其中 $h = 1/N$ 且 $j \\in \\{0,1,\\dots,N\\}$。\n- 使用与均匀节点相关的连续分片线性“帽”函数 (hat functions) $\\{\\phi_j(x)\\}_{j=0}^{N}$。\n- 令配置点为所有网格节点 $x_i$，其中 $i \\in \\{0,1,\\dots,N\\}$。\n- 对每个单元上的离散系统中出现的积分项使用精确的数值积分进行近似，确保积分误差与离散化误差相比可以忽略不计，从而使观察到的收敛阶反映的是方法本身，而不是积分方法的误差。\n\n离散化公式要求：\n- 将 $u_h(x)$ 表示为 $u_h(x) = \\sum_{j=0}^{N} a_j \\phi_j(x)$。\n- 在每个节点 $x_i$ 处强制满足方程，以获得关于系数 $\\{a_j\\}$ 的线性系统：\n$$\n\\sum_{j=0}^{N} a_j \\phi_j(x_i) - \\lambda \\sum_{j=0}^{N} a_j \\int_{0}^{1} e^{-|x_i - x'|} \\phi_j(x')\\,dx' = f(x_i).\n$$\n- 注意到 $\\phi_j(x_i) = \\delta_{ij}$，因此系统简化为：\n$$\na_i - \\lambda \\sum_{j=0}^{N} a_j \\left(\\int_{0}^{1} e^{-|x_i - x'|} \\phi_j(x')\\,dx'\\right) = f(x_i), \\quad i \\in \\{0,\\dots,N\\}.\n$$\n- 组装并求解该系统以得到 $\\{a_j\\}$。\n\n误差和收敛阶：\n- 将 $L^2$ 误差定义为\n$$\n\\|u - u_h\\|_{L^2(0,1)} = \\left( \\int_{0}^{1} \\left(u(x) - u_h(x)\\right)^2 dx \\right)^{1/2}.\n$$\n- 在每个单元上使用足够高阶的数值积分来估计 $L^2$ 误差的积分，以避免积分误差的干扰。\n- 对于每个细化级别 $N \\in \\{8,16,32,64\\}$，计算 $L^2$ 误差，记为 $e_N$。\n- 计算连续细化之间的观察收敛阶，公式如下：\n$$\n\\rho_{N \\to 2N} = \\frac{\\log\\left(e_{N} / e_{2N}\\right)}{\\log(2)}.\n$$\n\n测试套件：\n- 使用参数 $\\lambda$ 的三个值：$\\lambda \\in \\{0.0, 0.5, 0.9\\}$。\n- 对于测试套件中的每个 $\\lambda$，计算 $N \\in \\{8,16,32,64\\}$ 时的观察收敛阶，生成列表 $[\\rho_{8 \\to 16}, \\rho_{16 \\to 32}, \\rho_{32 \\to 64}]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目按顺序对应 $\\lambda = 0.0$、$\\lambda = 0.5$、$\\lambda = 0.9$ 的值。\n- 每个条目本身应是一个包含三个浮点数的列表 $[\\rho_{8 \\to 16}, \\rho_{16 \\to 32}, \\rho_{32 \\to 64}]$，并四舍五入到 $6$ 位小数。\n- 例如，输出格式必须类似于 $[[r_{1,1},r_{1,2},r_{1,3}],[r_{2,1},r_{2,2},r_{2,3}],[r_{3,1},r_{3,2},r_{3,3}]]$，不含空格。\n\n角度单位不适用。不存在物理单位，所有量均为无量纲量。",
            "solution": "用户提供的问题已经过分析和验证。\n- **科学基础**：该问题基于 Fredholm 积分方程理论和数值分析，特别是“人造解”方法和点匹配有限元法。这些都是标准的、完善的数学和计算课题。\n- **问题设定**：该问题是适定的 (well-posed)。与核函数 $K(x,x') = e^{-|x-x'|}$ 对应的积分算子是 $L^2([0,1])$ 上的一个紧自伴算子。对于任何满足 $\\lambda^{-1}$ 不是 $\\mathcal{K}$ 的特征值的 $\\lambda$，方程 $u - \\lambda \\mathcal{K}u = f$ 的唯一解都得到保证。最大特征值（谱半径）$\\rho(\\mathcal{K})$ 约为 $0.787$。对于所有测试值 $\\lambda \\in \\{0.0, 0.5, 0.9\\}$，条件 $|\\lambda|\\rho(\\mathcal{K}) < 1$ 均满足，从而确保了方程的适定性。\n- **客观性和完整性**：问题陈述是客观、精确的，并提供了所有必要信息，包括方程、人造解、数值方法规范、误差度量和测试参数。\n\n该问题被认为是有效的，完整的解决方案如下：\n\n### 第一部分：构造右端项 $f(x)$\n\n“人造解”方法要求将选定的精确解 $u(x)$ 代入积分方程，以确定相应的右端项（或源项） $f(x)$。给定的积分方程是：\n$$\nu(x) - \\lambda \\int_{0}^{1} e^{-|x - x'|}\\,u(x')\\,dx' = f(x), \\quad x \\in [0,1]\n$$\n使用人造解 $u(x) = e^x$，我们首先计算积分项，记为 $I(x)$：\n$$\nI(x) = \\int_{0}^{1} e^{-|x - x'|} e^{x'} \\,dx'\n$$\n为计算该积分，我们必须在 $x' = x$ 处分割积分域，以处理绝对值项 $|x - x'|$：\n$$\nI(x) = \\int_{0}^{x} e^{-(x - x')} e^{x'} \\,dx' + \\int_{x}^{1} e^{-(x' - x)} e^{x'} \\,dx'\n$$\n我们分别计算每个部分。对于第一个积分：\n$$\n\\int_{0}^{x} e^{-x} e^{x'} e^{x'} \\,dx' = e^{-x} \\int_{0}^{x} e^{2x'} \\,dx' = e^{-x} \\left[ \\frac{1}{2} e^{2x'} \\right]_{0}^{x} = e^{-x} \\left( \\frac{1}{2}e^{2x} - \\frac{1}{2} \\right) = \\frac{1}{2}e^x - \\frac{1}{2}e^{-x} = \\sinh(x)\n$$\n对于第二个积分：\n$$\n\\int_{x}^{1} e^{-x'} e^{x} e^{x'} \\,dx' = e^{x} \\int_{x}^{1} 1 \\,dx' = e^{x} [x']_{x}^{1} = e^x(1 - x)\n$$\n合并这两个部分，得到 $I(x)$ 的完整表达式：\n$$\nI(x) = \\left( \\frac{1}{2}e^x - \\frac{1}{2}e^{-x} \\right) + (e^x - x e^x) = \\left(\\frac{3}{2} - x\\right)e^x - \\frac{1}{2}e^{-x}\n$$\n最后，我们将此结果代回原方程，求得 $f(x)$：\n$$\nf(x) = u(x) - \\lambda I(x) = e^x - \\lambda \\left[ \\left(\\frac{3}{2} - x\\right)e^x - \\frac{1}{2}e^{-x} \\right]\n$$\n$$\nf(x) = \\left(1 - \\lambda\\left(\\frac{3}{2} - x\\right)\\right)e^x + \\frac{\\lambda}{2}e^{-x} = \\left(1 - \\frac{3\\lambda}{2} + \\lambda x\\right)e^x + \\frac{\\lambda}{2}e^{-x}\n$$\n这就是用于测试数值格式的右端项函数 $f(x)$ 的解析表达式。\n\n### 第二部分：使用点匹配法进行离散化\n\n我们使用基函数的线性组合来近似解 $u(x)$。区间 $[0,1]$ 被划分为 $N$ 个宽度为 $h=1/N$ 的均匀子区间，节点位于 $x_j = j h$，其中 $j \\in \\{0, 1, \\dots, N\\}$。基函数 $\\{\\phi_j(x)\\}_{j=0}^N$ 是连续的分片线性“帽”函数，其中 $\\phi_j(x)$ 在节点 $x_j$ 处的值为 1，在所有其他节点 $x_k$ （其中 $k \\ne j$）处的值为 0。\n近似解 $u_h(x)$ 写为：\n$$\nu_h(x) = \\sum_{j=0}^{N} a_j \\phi_j(x)\n$$\n其中 $\\{a_j\\}$ 是待确定的未知系数。在此基底下，系数 $a_j$ 代表近似解在节点 $x_j$ 处的值，即 $a_j = u_h(x_j)$。\n\n点匹配（或配置）法在一组离散点上强制满足积分方程。我们使用网格节点 $\\{x_i\\}_{i=0}^N$ 作为配置点。将 $u_h(x)$ 代入积分方程并在每个 $x_i$ 处求值，得到以下系统：\n$$\nu_h(x_i) - \\lambda \\int_{0}^{1} e^{-|x_i - x'|} u_h(x') \\,dx' = f(x_i), \\quad i \\in \\{0, \\dots, N\\}\n$$\n代入 $u_h(x)$ 的展开式可得：\n$$\n\\sum_{j=0}^{N} a_j \\phi_j(x_i) - \\lambda \\sum_{j=0}^{N} a_j \\int_{0}^{1} e^{-|x_i - x'|} \\phi_j(x') \\,dx' = f(x_i)\n$$\n由于性质 $\\phi_j(x_i) = \\delta_{ij}$ (Kronecker delta)，第一项简化为 $a_i$。这导出了关于系数 $\\mathbf{a} = [a_0, \\dots, a_N]^T$ 的 $(N+1) \\times (N+1)$ 线性方程组：\n$$\na_i - \\lambda \\sum_{j=0}^{N} a_j M_{ij} = f(x_i), \\quad i \\in \\{0, \\dots, N\\}\n$$\n其矩阵形式为 $(I - \\lambda M)\\mathbf{a} = \\mathbf{f}$，其中 $I$ 是单位矩阵，$\\mathbf{f}$ 是元素为 $f_i = f(x_i)$ 的向量，而 $M$ 是矩阵，其元素为：\n$$\nM_{ij} = \\int_{0}^{1} e^{-|x_i - x'|} \\phi_j(x') \\,dx'\n$$\n基函数 $\\phi_j(x')$ 的支集限于区间 $[x_{j-1}, x_{j+1}]$（对于 $j=0$ 和 $j=N$ 的端点情况有所调整）。$M_{ij}$ 的积分涉及一个指数函数和一个分片线性函数的乘积。尽管存在解析解，但计算过程繁琐。为确保所要求的高精度，我们对 $\\phi_j(x')$ 的每个线性段使用高阶高斯积分来计算这些积分，从而使积分误差与方法固有的离散化误差相比可以忽略不计。\n\n### 第三部分：误差分析与收敛阶\n\n求解出系数 $\\mathbf{a}$ 的线性系统后，我们得到近似解 $u_h(x)$。近似误差通过 $L^2$ 范数来量化：\n$$\n\\|u - u_h\\|_{L^2} = \\left( \\int_{0}^{1} (u(x) - u_h(x))^2 \\,dx \\right)^{1/2}\n$$\n该积分通过对每个单元 $[x_k, x_{k+1}]$ 上的贡献求和来进行数值计算：\n$$\n\\|u - u_h\\|_{L^2}^2 = \\sum_{k=0}^{N-1} \\int_{x_k}^{x_{k+1}} \\left(e^x - \\left(a_k \\frac{x_{k+1}-x}{h} + a_{k+1} \\frac{x-x_k}{h}\\right)\\right)^2 \\,dx\n$$\n与矩阵组装类似，我们在每个单元上采用高阶高斯积分来精确计算误差积分。\n\n对于光滑解，该方法的理论收敛阶为 $O(h^2)$，这意味着误差 $e_N = \\|u - u_h\\|_{L^2}$ 应与 $(1/N)^2$ 成正比。我们通过计算从 $N$ 到 $2N$ 个区间的两次连续网格细化之间的观察收敛阶 $\\rho$ 来凭经验验证这一点：\n$$\n\\rho_{N \\to 2N} = \\frac{\\log(e_N / e_{2N})}{\\log(2)}\n$$\n收敛阶 $\\rho \\approx 2$ 将证实该方法预期的二阶精度。对于 $\\lambda=0$，问题简化为对 $u(x)=e^x$ 的分片线性插值，其 $L^2$ 误差已知为 $O(h^2)$，这为实现提供了一个强有力的基线测试。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Fredholm integral equation using point-matching and computes\n    convergence rates for different values of lambda.\n    \"\"\"\n    LAMBDAS = [0.0, 0.5, 0.9]\n    N_VALS = [8, 16, 32, 64]\n    QUAD_ORDER = 16  # High order for negligible quadrature error\n\n    all_lambda_rates = []\n\n    # Get Gauss-Legendre quadrature points and weights on [-1, 1]\n    quad_points, quad_weights = np.polynomial.legendre.leggauss(QUAD_ORDER)\n\n    for lambda_val in LAMBDAS:\n        errors = []\n        for N in N_VALS:\n            h = 1.0 / N\n            x_nodes = np.linspace(0.0, 1.0, N + 1)\n\n            # Define exact solution and manufactured right-hand side\n            u_exact = lambda x: np.exp(x)\n            f_rhs = lambda x: (1.0 - 1.5 * lambda_val + lambda_val * x) * np.exp(x) + (lambda_val / 2.0) * np.exp(-x)\n\n            # The coefficients a_j are the approximations to u(x_j)\n            if lambda_val == 0.0:\n                # For lambda=0, u(x) = f(x). The collocation system is a_i = f(x_i).\n                # The manufactured f(x) for lambda=0 is e^x.\n                # So a_i = exp(x_i). This is equivalent to interpolating the exact solution.\n                a_coeffs = u_exact(x_nodes)\n            else:\n                # Assemble the system matrix M\n                M = np.zeros((N + 1, N + 1))\n                for i in range(N + 1):\n                    xi = x_nodes[i]\n                    for j in range(N + 1):\n                        # M_ij = integral of exp(-|xi - x'|) * phi_j(x') dx' from 0 to 1.\n                        # phi_j(x') is non-zero only on [x_{j-1}, x_{j+1}].\n                        \n                        integral_val = 0.0\n                        \n                        # Left part of hat function, on [x_{j-1}, x_j] for j > 0\n                        if j > 0:\n                            x_start, x_end = x_nodes[j-1], x_nodes[j]\n                            xp = 0.5 * (x_end - x_start) * quad_points + 0.5 * (x_start + x_end)\n                            phi_j_vals = (xp - x_start) / h\n                            kernel_vals = np.exp(-np.abs(xi - xp))\n                            integral_val += 0.5 * (x_end - x_start) * np.sum(quad_weights * kernel_vals * phi_j_vals)\n                        \n                        # Right part of hat function, on [x_j, x_{j+1}] for j  N\n                        if j  N:\n                            x_start, x_end = x_nodes[j], x_nodes[j+1]\n                            xp = 0.5 * (x_end - x_start) * quad_points + 0.5 * (x_start + x_end)\n                            phi_j_vals = (x_end - xp) / h\n                            kernel_vals = np.exp(-np.abs(xi - xp))\n                            integral_val += 0.5 * (x_end - x_start) * np.sum(quad_weights * kernel_vals * phi_j_vals)\n                        \n                        M[i, j] = integral_val\n                \n                # Form and solve the linear system (I - lambda * M) a = f\n                A_matrix = np.eye(N + 1) - lambda_val * M\n                f_vector = f_rhs(x_nodes)\n                a_coeffs = np.linalg.solve(A_matrix, f_vector)\n            \n            # Compute the L2 error ||u - u_h||\n            l2_error_sq = 0.0\n            for k in range(N):\n                # Integrate over element [x_k, x_{k+1}]\n                x_start, x_end = x_nodes[k], x_nodes[k+1]\n                \n                # Map quadrature points to the current element\n                xp = 0.5 * (x_end - x_start) * quad_points + 0.5 * (x_start + x_end)\n                \n                # Evaluate numerical solution u_h(x) at quadrature points\n                # On [x_k, x_k+1], u_h is a linear combination of phi_k and phi_{k+1}\n                phi_k_vals = (x_end - xp) / h\n                phi_k1_vals = (xp - x_start) / h\n                u_h_vals = a_coeffs[k] * phi_k_vals + a_coeffs[k+1] * phi_k1_vals\n                \n                # Evaluate exact solution u(x) at quadrature points\n                u_exact_vals = u_exact(xp)\n                \n                # Add element's contribution to the squared L2 error integral\n                integrand_vals = (u_exact_vals - u_h_vals)**2\n                l2_error_sq += 0.5 * (x_end - x_start) * np.sum(quad_weights * integrand_vals)\n            \n            errors.append(np.sqrt(l2_error_sq))\n\n        # Compute observed convergence rates for the current lambda\n        rates = []\n        for i in range(len(N_VALS) - 1):\n            # rate = log2(error_N / error_2N)\n            rate = np.log(errors[i] / errors[i+1]) / np.log(2.0)\n            rates.append(rate)\n        \n        all_lambda_rates.append(rates)\n\n    # Format the final output string as specified: [[r1,r2,r3],[r4,r5,r6],[r7,r8,r9]]\n    formatted_rates_str = []\n    for rates_list in all_lambda_rates:\n        formatted_list = [f\"{rate:.6f}\" for rate in rates_list]\n        formatted_rates_str.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output_str = f\"[{','.join(formatted_rates_str)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本的验证流程后，我们将把这些原则应用于一个经典的物理问题：二维电磁散射。这个练习将抽象的数值方法与具体的工程应用（例如计算雷达散射截面）联系起来。我们将通过数值求解完美电导体圆柱体的散射场，并将其与基于柱谐函数的精确解析解进行对比，这是验证物理和工程领域代码的另一种标准技术。",
            "id": "3341417",
            "problem": "考虑一个半径为 $a$ 的理想电导体 (perfectly electrically conducting) 圆柱在横磁极化 ($\\mathrm{TM}_z$) 条件下的二维时谐电磁散射问题，因此唯一的非零电场分量是 $E_z(x,y)$，其时间依赖性为 $e^{i \\omega t}$。根据频域中的麦克斯韦方程组和柱坐标下的分离变量法，标量总场 $u(x,y) = E_z(x,y)$ 在 $\\mathbb{R}^2 \\setminus \\{r \\le a\\}$ 区域内满足齐次亥姆霍兹方程\n$$\n\\nabla^2 u + k^2 u = 0,\n$$\n并在导体表面满足狄利克雷边界条件\n$$\nu(a,\\theta) = 0.\n$$\n设入射场为如下形式的平面波\n$$\nu^{\\mathrm{inc}}(r,\\theta) = e^{i k r \\cos(\\theta - \\theta_{\\mathrm{inc}})},\n$$\n其中 $k = \\omega \\sqrt{\\mu \\epsilon}$ 是自由空间波数，$r$ 是径向坐标，$\\theta$ 是角坐标，$\\theta_{\\mathrm{inc}}$ 是从 $x$ 轴测量的入射角。散射场 $u^{\\mathrm{scat}}$ 满足索末菲辐射条件。散射场的远场模式通过大 $r$ 渐近行为定义（单位为弧度）：\n$$\nu^{\\mathrm{scat}}(r,\\phi) \\sim \\sqrt{\\frac{2}{\\pi k r}} e^{i \\left( k r - \\frac{\\pi}{4} \\right)} F(\\phi), \\quad r \\to \\infty,\n$$\n其中 $\\phi$ 是观测角（单位为弧度），$F(\\phi)$ 是无量纲的远场振幅。\n\n任务 A (推导)。从所述的亥姆霍兹模型和边界条件出发，并使用出射柱谐波作为散射场的基，\n$$\nu^{\\mathrm{scat}}(r,\\theta) \\approx \\sum_{n=-N}^{N} c_n H_n^{(1)}(k r) e^{i n \\theta},\n$$\n推导一个在圆形边界 $r = a$ 上的点匹配（边界配置）离散化方法。选择 $M$ 个等距边界角 $\\theta_m = 2\\pi m / M$，$m=0,1,\\ldots,M-1$，其中 $M \\ge 2N+1$（整数），并在这些角度上强制施加狄利克雷边界条件。清晰地陈述得到的用于确定截断系数向量 $\\{c_n\\}_{n=-N}^{N}$ 的离散线性系统，并解释为什么当 $M  2N+1$ 时，最小二乘解是合适的。\n\n任务 B (远场)。仅使用基的正交性和出射柱面波的大宗量渐近式，表达由截断系数向量 $\\{c_n\\}_{n=-N}^{N}$ 计算出的离散远场振幅 $F_N(\\phi)$，其单位相对于 $F(\\phi)$ 是无量纲的。所有角度均使用弧度，并将 $F_N(\\phi)$ 作为 $\\phi$ 的复值函数给出。\n\n任务 C (解析参考解)。不借助任何数值方法，利用分离变量法和圆上的边界条件，得到在 $\\mathrm{TM}_z$ 照明下理想电导体圆柱的精确模态系数公式，用贝塞尔函数和汉克尔函数表示。根据这些精确系数，将参考远场振幅 $F_{\\mathrm{ref}}(\\phi)$ 定义为一个快速收敛的截断级数，并解释如何选择截断指数来控制截断误差。\n\n任务 D (误差量化)。对于一个均匀的观测角网格 $\\phi_j = 2\\pi j / Q$，$j = 0, 1, \\ldots, Q-1$，定义数值远场振幅与参考远场振幅之间的以下相对误差度量：\n- 相对离散 $L^2$ 误差，\n$$\n\\mathcal{E}_2 = \\frac{\\sqrt{\\frac{1}{Q} \\sum_{j=0}^{Q-1} \\left| F_N(\\phi_j) - F_{\\mathrm{ref}}(\\phi_j) \\right|^2 }}{\\sqrt{\\frac{1}{Q} \\sum_{j=0}^{Q-1} \\left| F_{\\mathrm{ref}}(\\phi_j) \\right|^2 }},\n$$\n- 相对离散 $L^\\infty$ 误差，\n$$\n\\mathcal{E}_\\infty = \\frac{\\max_{0 \\le j \\le Q-1} \\left| F_N(\\phi_j) - F_{\\mathrm{ref}}(\\phi_j) \\right|}{\\max_{0 \\le j \\le Q-1} \\left| F_{\\mathrm{ref}}(\\phi_j) \\right|}.\n$$\n\n编程要求和测试套件。实现一个完整的程序，该程序：\n- 使用 $a = 1\\,\\mathrm{m}$ 和 $\\theta_{\\mathrm{inc}} = 0$ (弧度)，因此 $k a$ 是无量纲的，且等于测试套件中列出的参数 $k a$。\n- 应用任务 A 中的点匹配离散化，其中 $M = s \\cdot (2N+1)$，$s$ 是由测试套件提供的过采样因子（整数）。\n- 在一个大小为 $Q = 720$ 的均匀观测网格上计算任务 B 中的 $F_N(\\phi)$（角度单位为弧度）。\n- 使用一个足够大的截断指数 $N_{\\mathrm{ref}}$ 构建任务 C 中的 $F_{\\mathrm{ref}}(\\phi)$，以确保截断误差相对于离散化误差可以忽略不计；您必须在解答中证明您的选择，并在代码中实现它。\n- 计算任务 D 中的 $\\mathcal{E}_2$ 和 $\\mathcal{E}_\\infty$。\n\n测试套件。为以下三组参数运行您的程序，每组参数产生两个浮点数 $\\mathcal{E}_2$ 和 $\\mathcal{E}_\\infty$：\n- 情况 1：$k a = 3.0$, $N = 3$, $s = 1$。\n- 情况 2：$k a = 3.0$, $N = 10$, $s = 2$。\n- 情况 3：$k a = 10.0$, $N = 20$, $s = 2$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是对应一个测试用例的双元素列表 $[\\mathcal{E}_2, \\mathcal{E}_\\infty]$，顺序与测试套件一致。角度必须使用弧度，所有量均为无量纲。例如，输出格式必须如下所示：\n[[e2_case1,einf_case1],[e2_case2,einf_case2],[e2_case3,einf_case3]]。",
            "solution": "该问题在科学和数学上是合理的、适定的，并包含了唯一解所需的所有信息。我们继续进行推导和实现。该问题涉及确定在横磁 ($\\mathrm{TM}_z$) 照明下，理想电导体 (PEC) 圆柱的散射电磁场。\n\n任务 A：点匹配离散化\n\n总场 $u(r,\\theta)$ 是入射场 $u^{\\mathrm{inc}}(r,\\theta)$ 和散射场 $u^{\\mathrm{scat}}(r,\\theta)$ 之和，即 $u = u^{\\mathrm{inc}} + u^{\\mathrm{scat}}$。在半径为 $a$ 的理想电导体圆柱表面上的狄利克雷边界条件要求总的切向电场为零。对于此 $\\mathrm{TM}_z$ 情况，这意味着 $u(a,\\theta) = E_z(a,\\theta) = 0$。此条件意味着散射场必须在边界上抵消入射场：\n$$\nu^{\\mathrm{scat}}(a,\\theta) = -u^{\\mathrm{inc}}(a,\\theta)\n$$\n入射场是平面波，由 $u^{\\mathrm{inc}}(r,\\theta) = e^{i k r \\cos(\\theta - \\theta_{\\mathrm{inc}})}$ 给出。对于指定的入射角 $\\theta_{\\mathrm{inc}}=0$ 的情况，这简化为 $u^{\\mathrm{inc}}(r,\\theta) = e^{i k r \\cos\\theta}$。\n\n散射场由一个截断的出射柱面波（柱谐波）级数近似，该级数固有地满足索末菲辐射条件：\n$$\nu^{\\mathrm{scat}}(r,\\theta) \\approx u_N^{\\mathrm{scat}}(r,\\theta) = \\sum_{n=-N}^{N} c_n H_n^{(1)}(k r) e^{i n \\theta}\n$$\n这里，$c_n$ 是未知的复系数，$H_n^{(1)}$ 是第一类 $n$ 阶汉克尔函数，级数被截断为 $2N+1$ 个模式。\n\n点匹配法，或称边界配置法，是在一组离散点上强制施加边界条件。我们在圆柱边界上选择 $M$ 个等距点，其角位置为 $\\theta_m = 2\\pi m / M$，$m=0, 1, \\ldots, M-1$。在每个点上，我们强制施加边界条件：\n$$\nu_N^{\\mathrm{scat}}(a,\\theta_m) = -u^{\\mathrm{inc}}(a,\\theta_m)\n$$\n代入场的表达式，我们得到一个关于 $2N+1$ 个未知系数 $\\{c_n\\}_{n=-N}^{N}$ 的 $M$ 个线性方程组：\n$$\n\\sum_{n=-N}^{N} c_n H_n^{(1)}(ka) e^{i n \\theta_m} = -e^{i k a \\cos \\theta_m}, \\quad m=0, 1, \\ldots, M-1\n$$\n该系统可以写成矩阵形式 $\\mathbf{A}\\mathbf{c} = \\mathbf{b}$，其中：\n- $\\mathbf{c}$ 是未知系数的 $(2N+1) \\times 1$ 列向量，$[c_{-N}, c_{-N+1}, \\ldots, c_N]^T$。\n- $\\mathbf{b}$ 是 $M \\times 1$ 列向量，表示在配置点处采样的入射场的负值，其元素为 $b_m = -e^{i k a \\cos \\theta_m}$。\n- $\\mathbf{A}$ 是 $M \\times (2N+1)$ 的系统矩阵，其元素由基函数在配置点处的值给出。第 $m$ 行和对应于索引 $n$ 的列的元素是 $A_{m,n} = H_n^{(1)}(ka) e^{i n \\theta_m}$。\n\n问题陈述 $M \\ge 2N+1$：\n- 如果 $M = 2N+1$，矩阵 $\\mathbf{A}$ 是方阵。对于圆形边界，该矩阵是可逆的，可以通过直接求逆 $\\mathbf{c} = \\mathbf{A}^{-1}\\mathbf{b}$ 找到 $\\mathbf{c}$ 的唯一解。\n- 如果 $M  2N+1$，系统是超定的，意味着方程的数量多于未知数的数量。由于级数的截断（一种建模误差），可能不存在同时满足所有 $M$ 个方程的精确解。在这种情况下，最小二乘解是合适的。我们寻找最小化残差的欧几里得范数 $\\|\\mathbf{A}\\mathbf{c} - \\mathbf{b}\\|_2$ 的向量 $\\mathbf{c}$。该最小化问题的解由正规方程给出：\n    $$\n    (\\mathbf{A}^H \\mathbf{A})\\mathbf{c} = \\mathbf{A}^H \\mathbf{b}\n    $$\n    其中 $\\mathbf{A}^H$ 是 $\\mathbf{A}$ 的共轭转置（厄米）矩阵。如果 $\\mathbf{A}$ 具有满列秩，则矩阵 $\\mathbf{A}^H \\mathbf{A}$ 是可逆的，最小二乗解是唯一的：$\\mathbf{c} = (\\mathbf{A}^H \\mathbf{A})^{-1}\\mathbf{A}^H\\mathbf{b}$。在数值计算上，这通常使用更稳定的方法（如 QR 或 SVD 分解）来求解。\n\n任务 B：离散远场振幅\n\n远场模式 $F(\\phi)$ 由散射场在大 $r$ 时的渐近行为定义。第一类汉克尔函数在大宗量 $z$ 时的渐近形式为：\n$$\nH_n^{(1)}(z) \\sim \\sqrt{\\frac{2}{\\pi z}} e^{i(z - n\\pi/2 - \\pi/4)} \\quad \\text{as } z \\to \\infty\n$$\n将此代入散射场 $u_N^{\\mathrm{scat}}$ 的截断级数中，我们设 $z=kr$ 并将观测角 $\\phi$ 与坐标 $\\theta$ 等同：\n$$\nu_N^{\\mathrm{scat}}(r,\\phi) \\approx \\sum_{n=-N}^{N} c_n \\left( \\sqrt{\\frac{2}{\\pi k r}} e^{i(k r - n\\pi/2 - \\pi/4)} \\right) e^{i n \\phi}\n$$\n提取不依赖于求和索引 $n$ 的项：\n$$\nu_N^{\\mathrm{scat}}(r,\\phi) \\approx \\sqrt{\\frac{2}{\\pi k r}} e^{i(k r - \\pi/4)} \\sum_{n=-N}^{N} c_n e^{-i n\\pi/2} e^{i n \\phi}\n$$\n将其与定义 $u^{\\mathrm{scat}}(r,\\phi) \\sim \\sqrt{\\frac{2}{\\pi k r}} e^{i(k r - \\pi/4)} F(\\phi)$ 进行比较，我们确定离散远场振幅 $F_N(\\phi)$ 为：\n$$\nF_N(\\phi) = \\sum_{n=-N}^{N} c_n e^{-i n\\pi/2} e^{i n \\phi} = \\sum_{n=-N}^{N} c_n (-i)^n e^{i n \\phi}\n$$\n此表达式提供了作为观测角 $\\phi$ 的复值函数的远场模式，该模式由离散系数 $c_n$ 计算得出。\n\n任务 C：解析参考解\n\n为了获得解析解，我们不截断级数展开。入射平面波使用 Jacobi-Anger 恒等式（其中 $\\theta_{\\mathrm{inc}}=0$）展开为柱谐波：\n$$\nu^{\\mathrm{inc}}(r,\\theta) = \\sum_{n=-\\infty}^{\\infty} i^n J_n(kr) e^{i n \\theta}\n$$\n其中 $J_n$ 是第一类贝塞尔函数。散射场展开为出射波，因为它们必须满足索末菲辐射条件：\n$$\nu^{\\mathrm{scat}}(r,\\theta) = \\sum_{n=-\\infty}^{\\infty} c_n^{\\mathrm{exact}} H_n^{(1)}(kr) e^{i n \\theta}\n$$\n总场 $u = u^{\\mathrm{inc}} + u^{\\mathrm{scat}}$ 必须在所有 $\\theta \\in [0, 2\\pi)$ 上满足边界条件 $u(a,\\theta)=0$。\n$$\n\\sum_{n=-\\infty}^{\\infty} i^n J_n(ka) e^{i n \\theta} + \\sum_{n=-\\infty}^{\\infty} c_n^{\\mathrm{exact}} H_n^{(1)}(ka) e^{i n \\theta} = 0\n$$\n$$\n\\sum_{n=-\\infty}^{\\infty} \\left[ i^n J_n(ka) + c_n^{\\mathrm{exact}} H_n^{(1)}(ka) \\right] e^{i n \\theta} = 0\n$$\n由于复指数 $\\{e^{i n \\theta}\\}$ 在区间 $[0, 2\\pi)$ 上的正交性，为了使方程对所有 $\\theta$ 成立，级数中的每一项都必须为零。\n$$\ni^n J_n(ka) + c_n^{\\mathrm{exact}} H_n^{(1)}(ka) = 0\n$$\n求解精确模态系数 $c_n^{\\mathrm{exact}}$ 可得：\n$$\nc_n^{\\mathrm{exact}} = -i^n \\frac{J_n(ka)}{H_n^{(1)}(ka)}\n$$\n精确的远场振幅 $F(\\phi)$ 通过在远场求和公式中使用这些系数得到：\n$$\nF(\\phi) = \\sum_{n=-\\infty}^{\\infty} c_n^{\\mathrm{exact}} (-i)^n e^{i n \\phi} = \\sum_{n=-\\infty}^{\\infty} \\left( -i^n \\frac{J_n(ka)}{H_n^{(1)}(ka)} \\right) (-i)^n e^{i n \\phi} = -\\sum_{n=-\\infty}^{\\infty} \\frac{J_n(ka)}{H_n^{(1)}(ka)} e^{i n \\phi}\n$$\n对于数值参考，这个无限级数必须被截断。我们通过在索引 $N_{\\mathrm{ref}}$ 处截断来定义参考远场振幅 $F_{\\mathrm{ref}}(\\phi)$：\n$$\nF_{\\mathrm{ref}}(\\phi) = -\\sum_{n=-N_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}} \\frac{J_n(ka)}{H_n^{(1)}(ka)} e^{i n \\phi}\n$$\n截断指数 $N_{\\mathrm{ref}}$ 的选择必须足够大，以使该参考级数的截断误差与待测的点匹配解的离散化误差相比可以忽略不计。当 $|n|  ka$ 时，项 $|J_n(ka)/H_n^{(1)}(ka)|$ 的大小会极快地衰减。一个稳健的规则是选择 $N_{\\mathrm{ref}}$ 显著大于数值截断指数 $N$ 和电尺寸 $ka$。我们将使用 $N_{\\mathrm{ref}} = \\max(2N, \\lfloor ka \\rfloor + 20)$，这确保了在指定的测试用例中参考解的高精度。\n\n任务 D：误差量化\n\n数值远场振幅 $F_N(\\phi)$ 和参考远场振幅 $F_{\\mathrm{ref}}(\\phi)$ 之间的相对误差使用两个离散范数进行量化。两者都在一个包含 $Q$ 个观测角 $\\phi_j = 2\\pi j / Q$（其中 $j=0, 1, \\ldots, Q-1$）的均匀网格上进行评估。\n\n相对离散 $L^2$ 误差 $\\mathcal{E}_2$ 衡量均方根差异：\n$$\n\\mathcal{E}_2 = \\frac{\\sqrt{\\frac{1}{Q} \\sum_{j=0}^{Q-1} \\left| F_N(\\phi_j) - F_{\\mathrm{ref}}(\\phi_j) \\right|^2 }}{\\sqrt{\\frac{1}{Q} \\sum_{j=0}^{Q-1} \\left| F_{\\mathrm{ref}}(\\phi_j) \\right|^2 }}\n$$\n相对离散 $L^\\infty$ 误差 $\\mathcal{E}_\\infty$ 衡量最大相对差异：\n$$\n\\mathcal{E}_\\infty = \\frac{\\max_{0 \\le j \\le Q-1} \\left| F_N(\\phi_j) - F_{\\mathrm{ref}}(\\phi_j) \\right|}{\\max_{0 \\le j \\le Q-1} \\left| F_{\\mathrm{ref}}(\\phi_j) \\right|}\n$$\n这些度量提供了对数值点匹配解精度的归一化测量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import jv, hankel1\n\ndef solve():\n    \"\"\"\n    Solves for the scattering from a PEC circular cylinder using point matching and\n    computes the error against an analytic reference solution for given test cases.\n    \"\"\"\n    # Test suite parameters: (ka, N, s)\n    # ka: dimensionless electrical size\n    # N: truncation index for the scattered field series\n    # s: oversampling factor for point-matching\n    test_cases = [\n        (3.0, 3, 1),\n        (3.0, 10, 2),\n        (10.0, 20, 2),\n    ]\n\n    # Number of observation points for far-field evaluation\n    Q = 720\n    # Observation angles from 0 to 2*pi (exclusive)\n    phi_obs = np.linspace(0, 2 * np.pi, Q, endpoint=False)\n    \n    results = []\n    for ka, N, s in test_cases:\n        # Determine the number of collocation points\n        M = s * (2 * N + 1)\n        # Collocation angles on the cylinder boundary\n        thetas_col = np.linspace(0, 2 * np.pi, M, endpoint=False)\n        \n        # --- Task A: Point-Matching Discretization and Solution ---\n        # Mode indices for the truncated series from -N to N\n        n_modes = np.arange(-N, N + 1)\n        \n        # Build the system matrix A, where A_mn = H_n^(1)(ka) * exp(i*n*theta_m)\n        # We use broadcasting for an efficient construction.\n        # h1_vals has shape (2N+1,)\n        h1_vals = hankel1(n_modes, ka)\n        # exp_vals has shape (M, 2N+1)\n        exp_vals = np.exp(1j * np.outer(thetas_col, n_modes))\n        # Broadcast h1_vals to (1, 2N+1) and element-wise multiply with exp_vals\n        A = h1_vals[np.newaxis, :] * exp_vals\n        \n        # Build the right-hand side vector b, where b_m = -exp(i*ka*cos(theta_m))\n        b = -np.exp(1j * ka * np.cos(thetas_col))\n        \n        # Solve the linear system Ac = b for the coefficients c.\n        # np.linalg.lstsq is used as it handles both square (M=2N+1) and\n        # overdetermined (M  2N+1) systems robustly.\n        c_numerical, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n        \n        # --- Task B: Compute Numerical Far-Field Amplitude F_N ---\n        # F_N(phi) = sum_{n=-N to N} c_n * (-i)^n * exp(i*n*phi)\n        far_field_phase = (-1j)**n_modes\n        exp_obs = np.exp(1j * np.outer(phi_obs, n_modes))\n        # The '@' operator performs matrix-vector multiplication\n        F_N = exp_obs @ (c_numerical * far_field_phase)\n\n        # --- Task C: Compute Analytic Reference Far-Field F_ref ---\n        # Choose a sufficiently large truncation index for the reference series\n        # to ensure its truncation error is negligible.\n        N_ref = int(max(2 * N, np.floor(ka) + 20))\n        n_ref_modes = np.arange(-N_ref, N_ref + 1)\n\n        # Compute coefficients for the reference far-field series: d_n = -J_n(ka)/H_n^(1)(ka)\n        d_n_ref = -jv(n_ref_modes, ka) / hankel1(n_ref_modes, ka)\n        \n        # F_ref(phi) = sum_{n=-N_ref to N_ref} d_n * exp(i*n*phi)\n        exp_ref = np.exp(1j * np.outer(phi_obs, n_ref_modes))\n        F_ref = exp_ref @ d_n_ref\n        \n        # --- Task D: Error Quantification ---\n        diff = F_N - F_ref\n        \n        # Relative L2 error\n        E2_num = np.sqrt(np.mean(np.abs(diff)**2))\n        E2_den = np.sqrt(np.mean(np.abs(F_ref)**2))\n        E2 = E2_num / E2_den\n        \n        # Relative L-infinity error\n        Einf_num = np.max(np.abs(diff))\n        Einf_den = np.max(np.abs(F_ref))\n        Einf = Einf_num / Einf_den\n        \n        results.append([E2, Einf])\n        \n    # The final print statement must match the specified format.\n    # The `str` of a list includes the brackets, so we join these strings.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将探讨一项用于验证前沿三维电磁仿真工具的高级实践。对于像电场积分方程（EFIE）这样复杂的矢量积分方程，精确的解析解极为罕见，这使得代码验证充满挑战。本练习将演示一种精妙的人造解方法，它使用矢量球谐函数来构造一个无散的表面电流，并通过在偏移表面上进行测试来巧妙地处理奇异性问题，这反映了工业级代码开发中的专业实践。",
            "id": "3341444",
            "problem": "要求您在自由空间中的球体上设计一个制造的表面电流密度 $\\mathbf{J}$，并计算用于验证电场积分方程 (EFIE) 配置点实现的相应入射场。您制造的解必须采用点匹配测试程序：构造入射场，使其在选定的一组匹配（配置）点上满足 EFIE 边界条件，同时在一个位于表面外部不远处的球面上的一组不同的非匹配点上评估验证误差度量。目标是推导 EFIE 算子的一种有原则且可测试的计算方法，并生成一个数值误差度量，以反映当积分算子使用粗糙求积进行离散化时点匹配程序的质量。\n\n从均匀自由空间中的时谐麦克斯韦方程组开始，采用 $\\mathrm{e}^{\\mathrm{i}\\omega t}$ 的时间约定。总电场 $\\mathbf{E}$ 在理想电导体 (PEC) 表面上满足电场积分方程，\n$$\n\\hat{\\mathbf{n}}(\\mathbf{r}_s) \\times \\left(\\mathbf{E}^{\\text{inc}}(\\mathbf{r}_s) + \\mathbf{E}^{\\text{scat}}(\\mathbf{r}_s)\\right) = \\mathbf{0},\n$$\n其中 $\\hat{\\mathbf{n}}$ 是表面点 $\\mathbf{r}_s$ 处的外法向单位矢量，$\\mathbf{E}^{\\text{inc}}$ 是入射场，$\\mathbf{E}^{\\text{scat}}$ 是由感应表面电流密度 $\\mathbf{J}(\\mathbf{r}_s)$ 散射的场。对于一般的表面电流 $\\mathbf{J}$，散射场由经典的 EFIE 算子给出，\n$$\n\\mathbf{E}^{\\text{scat}}(\\mathbf{r}) = \\mathrm{i}\\omega \\mu_0 \\int_S G(\\mathbf{r},\\mathbf{r}') \\mathbf{J}(\\mathbf{r}') \\,\\mathrm{d}S' + \\frac{1}{\\mathrm{i}\\omega \\varepsilon_0} \\nabla \\int_S G(\\mathbf{r},\\mathbf{r}') \\nabla'_s\\cdot\\mathbf{J}(\\mathbf{r}') \\,\\mathrm{d}S',\n$$\n其中 $G(\\mathbf{r},\\mathbf{r}') = \\frac{\\mathrm{e}^{\\mathrm{i}k\\|\\mathbf{r}-\\mathbf{r}'\\|}}{4\\pi\\|\\mathbf{r}-\\mathbf{r}'\\|}$ 是自由空间格林函数，$k=\\omega\\sqrt{\\mu_0\\varepsilon_0}$ 是自由空间波数，$\\nabla'_s\\cdot$ 是在 $\\mathbf{r}'$ 处的表面散度。如果选择的制造电流 $\\mathbf{J}$ 是无表面散度的，那么标量势项将消失，只有矢量势项有贡献。\n\n您将使用环形矢量球谐函数 $\\mathbf{X}_{\\ell m}$ 在半径为 $a$ 的球体上制造一个光滑、无散度、切向的表面电流密度：\n$$\n\\mathbf{J}(\\theta,\\phi) = J_0\\,\\mathbf{X}_{\\ell m}(\\theta,\\phi),\n$$\n其中 $(\\theta,\\phi)$ 是球面上的极角和方位角，$\\ell\\ge 1$ 且 $|m|\\le \\ell$，$J_0$ 的单位是 $\\mathrm{A}/\\mathrm{m}$，并且\n$$\n\\mathbf{X}_{\\ell m}(\\theta,\\phi) = \\frac{1}{\\sqrt{\\ell(\\ell+1)}}\\left(\\hat{\\boldsymbol{\\phi}}\\;\\frac{\\partial Y_{\\ell m}}{\\partial \\theta} - \\hat{\\boldsymbol{\\theta}}\\;\\frac{1}{\\sin\\theta}\\frac{\\partial Y_{\\ell m}}{\\partial \\phi}\\right),\n$$\n其中 $Y_{\\ell m}$ 是复球谐函数，$\\hat{\\boldsymbol{\\theta}}$、$\\hat{\\boldsymbol{\\phi}}$ 是标准正交切向基。该电流严格切向，并在球面上满足 $\\nabla_s\\cdot\\mathbf{J}=0$。\n\n为避免在表面上精确处理奇异积分，我们在半径为 $a+\\delta$ 的球面上计算场，其中 $\\delta0$ 且与波长 $\\lambda=2\\pi/k$ 相比很小。在这个偏移球体上的任何观测点 $(\\theta_0,\\phi_0)$，强制执行 PEC EFIE 边界条件的所需入射场构造为\n$$\n\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\theta_0,\\phi_0) = -\\,\\mathbf{E}^{\\text{scat}}_{\\parallel}(\\theta_0,\\phi_0),\n$$\n其中符号 $\\parallel$ 表示到与径向单位矢量正交的局部切平面上的切向投影。右侧出现的散射场必须通过数值上精确的求积（使用中点法则的精细球面积分乘积网格）来计算，以作为制造的参考入射场。为模拟使用 EFIE 算子粗糙离散化的配置点代码，再次使用更粗糙的球面积分乘积网格和中点法则计算 $\\mathbf{E}^{\\text{scat}}_{\\parallel}$，并在非匹配点上定义一个逐点残差\n$$\n\\mathcal{R}(\\theta_0,\\phi_0) = \\left\\|\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\theta_0,\\phi_0) + \\mathbf{E}^{\\text{scat}}_{\\parallel,\\text{coarse}}(\\theta_0,\\phi_0)\\right\\|_2.\n$$\n报告在一组指定的非匹配点$\\{(\\theta_i,\\phi_i)\\}_{i=1}^M$上的相对均方根 (RMS) 误差，\n$$\n\\epsilon_{\\text{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{i=1}^M \\left(\\frac{\\mathcal{R}(\\theta_i,\\phi_i)}{\\left\\|\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\theta_i,\\phi_i)\\right\\|_2}\\right)^2 }.\n$$\n\n程序实现细节：\n- 使用自由空间常数 $\\mu_0 = 4\\pi\\times 10^{-7}\\,\\mathrm{H/m}$ 和 $\\varepsilon_0 \\approx 8.8541878176\\times 10^{-12}\\,\\mathrm{F/m}$，其中 $\\omega = 2\\pi f$ 且 $k = \\omega\\sqrt{\\mu_0\\varepsilon_0}$。\n- 电流密度 $\\mathbf{J}$ 以 $\\mathrm{A}/\\mathrm{m}$ 表示，电场 $\\mathbf{E}$ 以 $\\mathrm{V}/\\mathrm{m}$ 表示。角度 $\\theta$ 和 $\\phi$ 必须以弧度为单位。\n- 在具有 $(N_\\theta,N_\\phi)$ 个点的球面积分乘积网格上使用中点法则：中心点位于 $(\\theta_i,\\phi_j)$，其中 $\\theta_i = (i+\\tfrac{1}{2})\\Delta\\theta$，$\\phi_j = (j+\\tfrac{1}{2})\\Delta\\phi$，$\\Delta\\theta = \\pi/N_\\theta$，$\\Delta\\phi = 2\\pi/N_\\phi$，面积元为 $a^2 \\sin\\theta\\,\\Delta\\theta\\,\\Delta\\phi$。\n- 散射场贡献简化为矢量势项，\n$$\n\\mathbf{E}^{\\text{scat}}(\\mathbf{r}) = \\mathrm{i}\\omega\\mu_0 \\int_S \\frac{\\mathrm{e}^{\\mathrm{i}k\\|\\mathbf{r}-\\mathbf{r}'\\|}}{4\\pi\\|\\mathbf{r}-\\mathbf{r}'\\|} \\mathbf{J}(\\mathbf{r}')\\,\\mathrm{d}S',\n$$\n切向分量通过减去径向投影得到：$\\mathbf{E}_{\\parallel} = \\mathbf{E} - (\\mathbf{E}\\cdot \\hat{\\mathbf{r}})\\hat{\\mathbf{r}}$。\n- 为保证数值稳定性，选择其 $\\theta$ 值避开两极的非匹配测试点。\n\n测试套件：\n对于所有测试用例，使用相同的非匹配点集 $\\{(\\theta_i,\\phi_i)\\}_{i=1}^9$\n$$\n\\begin{aligned}\n(\\theta_1,\\phi_1) = (0.3\\pi,\\,0.1\\pi),\\quad (\\theta_2,\\phi_2) = (0.45\\pi,\\,0.35\\pi),\\quad (\\theta_3,\\phi_3) = (0.6\\pi,\\,1.2\\pi),\\\\\n(\\theta_4,\\phi_4) = (0.2\\pi,\\,2.0\\pi),\\quad (\\theta_5,\\phi_5) = (0.75\\pi,\\,2.4\\pi),\\quad (\\theta_6,\\phi_6) = (0.5\\pi,\\,3.1\\pi),\\\\\n(\\theta_7,\\phi_7) = (0.65\\pi,\\,1.7\\pi),\\quad (\\theta_8,\\phi_8) = (0.4\\pi,\\,2.8\\pi),\\quad (\\theta_9,\\phi_9) = (0.85\\pi,\\,0.9\\pi).\n\\end{aligned}\n$$\n将四个测试用例定义为参数元组 $(a, f, \\ell, m, J_0, \\alpha, N_\\theta^{\\text{coarse}}, N_\\phi^{\\text{coarse}}, N_\\theta^{\\text{fine}}, N_\\phi^{\\text{fine}})$，其中 $\\delta = \\alpha \\lambda$ 且 $\\lambda = 2\\pi/k$：\n- 用例1（正常路径）：$(a, f, \\ell, m, J_0, \\alpha, N_\\theta^{\\text{coarse}}, N_\\phi^{\\text{coarse}}, N_\\theta^{\\text{fine}}, N_\\phi^{\\text{fine}}) = (0.37\\,\\mathrm{m}, 500\\,\\mathrm{MHz}, 3, 1, 1.0\\,\\mathrm{A/m}, 0.05, 24, 48, 40, 80)$。\n- 用例2（粗糙求积边缘情况）：$(0.37\\,\\mathrm{m}, 500\\,\\mathrm{MHz}, 3, 1, 1.0\\,\\mathrm{A/m}, 0.05, 8, 16, 40, 80)$。\n- 用例3（高频）：$(0.50\\,\\mathrm{m}, 1200\\,\\mathrm{MHz}, 4, 2, 1.0\\,\\mathrm{A/m}, 0.02, 20, 40, 40, 80)$。\n- 用例4（低频）：$(0.50\\,\\mathrm{m}, 50\\,\\mathrm{MHz}, 2, 1, 1.0\\,\\mathrm{A/m}, 0.05, 24, 48, 40, 80)$。\n\n您的程序必须：\n- 如上所述，从 $\\mathbf{X}_{\\ell m}$ 构造 $\\mathbf{J}$。\n- 使用精细网格计算 $\\mathbf{E}^{\\text{inc}}_{\\parallel}$，并将其设置为在半径 $a+\\delta$ 处计算的 $-\\mathbf{E}^{\\text{scat}}_{\\parallel}$。\n- 在相同的非匹配点上计算粗糙网格的散射切向场 $\\mathbf{E}^{\\text{scat}}_{\\parallel,\\text{coarse}}$。\n- 对每个测试用例，在九个非匹配点上汇总相对均方根误差 $\\epsilon_{\\text{RMS}}$。\n\n最终输出：\n您的程序应生成单行输出，其中包含四个 $\\epsilon_{\\text{RMS}}$ 值，按上述测试用例的顺序排列，形式为逗号分隔的列表并用方括号括起来 (例如，$[\\epsilon_1,\\epsilon_2,\\epsilon_3,\\epsilon_4]$)。不应打印任何附加文本。所有角度必须解释为弧度，所有长度单位为米，电流密度单位为 $\\mathrm{A}/\\mathrm{m}$，电场单位为 $\\mathrm{V}/\\mathrm{m}$。打印的数值是无量纲的相对误差，必须是标准的浮点数。",
            "solution": "该问题要求为基于电场积分方程 (EFIE) 的计算电磁学代码设计和实现一个验证测试。这是通过制造解方法 (MMS) 完成的，其中为表面电流密度假设一个已知的非平凡解，并从中导出维持该解所需的相应入射场。然后，通过将其输出与已知解进行比较，可以评估数值 EFIE 算子的准确性。\n\n让我们首先对问题的各个组成部分进行形式化。几何形状是自由空间中半径为 $a$ 的球体。时谐约定为 $\\mathrm{e}^{\\mathrm{i}\\omega t}$。\n\n基本方程是理想电导体 (PEC) 的 EFIE，它指出总电场的切向分量必须在表面 $S$ 上为零：\n$$\n\\hat{\\mathbf{n}}(\\mathbf{r}_s) \\times \\left(\\mathbf{E}^{\\text{inc}}(\\mathbf{r}_s) + \\mathbf{E}^{\\text{scat}}(\\mathbf{r}_s)\\right) = \\mathbf{0} \\quad \\text{for } \\mathbf{r}_s \\in S\n$$\n这等价于声明散射场的切向分量必须是入射场切向分量的负值：$\\mathbf{E}^{\\text{scat}}_{\\parallel}(\\mathbf{r}_s) = -\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\mathbf{r}_s)$。\n\n在观测点 $\\mathbf{r}$ 处的散射场 $\\mathbf{E}^{\\text{scat}}$ 是由表面电流密度 $\\mathbf{J}$ 通过积分算子生成的：\n$$\n\\mathbf{E}^{\\text{scat}}(\\mathbf{r}) = \\mathrm{i}\\omega \\mu_0 \\int_S G(\\mathbf{r},\\mathbf{r}') \\mathbf{J}(\\mathbf{r}') \\,\\mathrm{d}S' + \\frac{1}{\\mathrm{i}\\omega \\varepsilon_0} \\nabla \\int_S G(\\mathbf{r},\\mathbf{r}') \\nabla'_s\\cdot\\mathbf{J}(\\mathbf{r}') \\,\\mathrm{d}S'\n$$\n其中 $G(\\mathbf{r},\\mathbf{r}') = \\frac{\\mathrm{e}^{\\mathrm{i}k\\|\\mathbf{r}-\\mathbf{r}'\\|}}{4\\pi\\|\\mathbf{r}-\\mathbf{r}'\\|}$ 是标量自由空间格林函数，$k=\\omega\\sqrt{\\mu_0\\varepsilon_0}$ 是波数，$\\mu_0, \\varepsilon_0$ 分别是自由空间的磁导率和介电常数。\n\n为电流密度制造的解被选为单个环形矢量球谐函数，这确保了它与球面相切且表面无散度（$\\nabla_s\\cdot\\mathbf{J}=0$）：\n$$\n\\mathbf{J}(\\theta',\\phi') = J_0\\,\\mathbf{X}_{\\ell m}(\\theta',\\phi')\n$$\n此处，$(\\theta', \\phi')$ 是源球面上的球坐标角度，$J_0$ 是一个恒定振幅，以及\n$$\n\\mathbf{X}_{\\ell m}(\\theta',\\phi') = \\frac{1}{\\sqrt{\\ell(\\ell+1)}}\\left(\\hat{\\boldsymbol{\\phi}}'\\;\\frac{\\partial Y_{\\ell m}}{\\partial \\theta'} - \\hat{\\boldsymbol{\\theta}}'\\;\\frac{1}{\\sin\\theta'}\\frac{\\partial Y_{\\ell m}}{\\partial \\phi'}\\right)\n$$\n其中 $Y_{\\ell m}$ 是标准的复球谐函数。性质 $\\nabla_s\\cdot\\mathbf{J}=0$ 通过消除标量势项（第二个积分）简化了散射场表达式，仅留下矢量势项：\n$$\n\\mathbf{E}^{\\text{scat}}(\\mathbf{r}) = \\mathrm{i}\\omega\\mu_0 \\int_S G(\\mathbf{r},\\mathbf{r}') \\mathbf{J}(\\mathbf{r}')\\,\\mathrm{d}S'\n$$\n\n对于数值计算，我们离散化这个积分。观测点 $\\mathbf{r}$ 位于半径为 $a+\\delta$（其中 $\\delta  0$）的球面上，源点 $\\mathbf{r}'$ 位于半径为 $a$ 的球面上。这个偏移量 $\\delta$ 避免了当 $\\mathbf{r}=\\mathbf{r}'$ 时格林函数中的奇异性。我们在 $(\\theta', \\phi')$ 的规则网格上使用中点法则。积分变为一个和：\n$$\n\\mathbf{E}^{\\text{scat}}(\\mathbf{r}) \\approx \\mathrm{i}\\omega\\mu_0 \\sum_{j=0}^{N_\\theta-1} \\sum_{k=0}^{N_\\phi-1} G(\\mathbf{r},\\mathbf{r}'_{jk}) \\mathbf{J}(\\mathbf{r}'_{jk}) a^2 \\sin(\\theta'_j) \\Delta\\theta \\Delta\\phi\n$$\n其中 $\\Delta\\theta = \\pi/N_\\theta$，$\\Delta\\phi = 2\\pi/N_\\phi$，网格中心为 $\\theta'_j = (j+0.5)\\Delta\\theta$，$\\phi'_k = (k+0.5)\\Delta\\phi$。\n\n电流密度矢量 $\\mathbf{J}$ 和场 $\\mathbf{E}^{\\text{scat}}$ 必须在一个共同的全局坐标系，即笛卡尔坐标系 $(\\hat{\\mathbf{x}},\\hat{\\mathbf{y}},\\hat{\\mathbf{z}})$ 中表示，以便执行矢量加法。每个源点 $(\\theta', \\phi')$ 的球坐标基矢量 $(\\hat{\\mathbf{r}}', \\hat{\\boldsymbol{\\theta}}', \\hat{\\boldsymbol{\\phi}}')$ 被转换为笛卡尔坐标：\n\\begin{align*} \\hat{\\mathbf{r}}' = \\sin\\theta'\\cos\\phi'\\,\\hat{\\mathbf{x}} + \\sin\\theta'\\sin\\phi'\\,\\hat{\\mathbf{y}} + \\cos\\theta'\\,\\hat{\\mathbf{z}} \\\\ \\hat{\\boldsymbol{\\theta}}' = \\cos\\theta'\\cos\\phi'\\,\\hat{\\mathbf{x}} + \\cos\\theta'\\sin\\phi'\\,\\hat{\\mathbf{y}} - \\sin\\theta'\\,\\hat{\\mathbf{z}} \\\\ \\hat{\\boldsymbol{\\phi}}' = -\\sin\\phi'\\,\\hat{\\mathbf{x}} + \\cos\\phi'\\,\\hat{\\mathbf{y}} \\end{align*}\n计算 $\\mathbf{J}(\\theta', \\phi') = J_{\\theta'}\\hat{\\boldsymbol{\\theta}}' + J_{\\phi'}\\hat{\\boldsymbol{\\phi}}'$ 的分量。对 $\\phi'$ 的导数很简单：$\\frac{\\partial Y_{\\ell m}}{\\partial \\phi'} = \\mathrm{i}m Y_{\\ell m}$。对 $\\theta'$ 的导数可以使用涉及其他球谐函数的递推关系来稳定地计算：\n$$\n\\frac{\\partial Y_{\\ell m}}{\\partial \\theta'} = \\frac{1}{2} \\left[ \\sqrt{(\\ell-m)(\\ell+m+1)} e^{-\\mathrm{i}\\phi'} Y_{\\ell,m+1} - \\sqrt{(\\ell+m)(\\ell-m+1)} e^{\\mathrm{i}\\phi'} Y_{\\ell,m-1} \\right]\n$$\n此关系对于 `scipy.special.sph_harm` 使用的 Condon-Shortley 相位约定有效。\n\n制造的入射场 $\\mathbf{E}^{\\text{inc}}_{\\parallel}$ 定义为在观测点完全抵消切向散射场的场。参考散射场是使用精细求积网格（$N_\\theta^{\\text{fine}}, N_\\phi^{\\text{fine}}$）计算的：\n$$\n\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\mathbf{r}) = - \\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{fine}}(\\mathbf{r})\n$$\n切向投影通过减去径向分量来执行：$\\mathbf{E}_{\\parallel} = \\mathbf{E} - (\\mathbf{E}\\cdot\\hat{\\mathbf{r}})\\hat{\\mathbf{r}}$，其中 $\\hat{\\mathbf{r}} = \\mathbf{r}/\\|\\mathbf{r}\\|$。\n\n为了测试一个精度较低的算子，我们再次计算散射场，这次使用粗糙求积网格（$N_\\theta^{\\text{coarse}}, N_\\phi^{\\text{coarse}}$），以获得 $\\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{coarse}}$。在观测点 $\\mathbf{r}_i$ 处的逐点残差是与预期边界条件的偏差：\n$$\n\\mathcal{R}(\\mathbf{r}_i) = \\left\\| \\mathbf{E}^{\\text{inc}}_{\\parallel}(\\mathbf{r}_i) + \\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{coarse}}(\\mathbf{r}_i) \\right\\|_2 = \\left\\| \\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{coarse}}(\\mathbf{r}_i) - \\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{fine}}(\\mathbf{r}_i) \\right\\|_2\n$$\n最终的误差度量是相对均方根 (RMS) 误差，在 $M=9$ 个非匹配观测点上取平均：\n$$\n\\epsilon_{\\text{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{i=1}^M \\left( \\frac{\\mathcal{R}(\\mathbf{r}_i)}{\\|\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\mathbf{r}_i)\\|_2} \\right)^2} = \\sqrt{\\frac{1}{M}\\sum_{i=1}^M \\left( \\frac{\\|\\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{coarse}}(\\mathbf{r}_i) - \\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{fine}}(\\mathbf{r}_i)\\|_2}{\\|\\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{fine}}(\\mathbf{r}_i)\\|_2} \\right)^2}\n$$\n该度量量化了由 EFIE 算子的粗糙离散化引入的误差，该误差是相对于真实解场的幅值而言的。对指定的四个测试用例中的每一个重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import sph_harm\nfrom scipy.constants import mu_0, epsilon_0, c\n\ndef solve():\n    \"\"\"\n    Main orchestrator for solving the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # (a, f, l, m, J0, alpha, N_theta_coarse, N_phi_coarse, N_theta_fine, N_phi_fine)\n        (0.37, 500e6, 3, 1, 1.0, 0.05, 24, 48, 40, 80),\n        (0.37, 500e6, 3, 1, 1.0, 0.05, 8, 16, 40, 80),\n        (0.50, 1200e6, 4, 2, 1.0, 0.02, 20, 40, 40, 80),\n        (0.50, 50e6, 2, 1, 1.0, 0.05, 24, 48, 40, 80),\n    ]\n\n    # Non-matched test points (theta, phi) in radians\n    non_matched_points_sph = np.array([\n        (0.3 * np.pi, 0.1 * np.pi), (0.45 * np.pi, 0.35 * np.pi),\n        (0.6 * np.pi, 1.2 * np.pi), (0.2 * np.pi, 2.0 * np.pi),\n        (0.75 * np.pi, 2.4 * np.pi), (0.5 * np.pi, 3.1 * np.pi),\n        (0.65 * np.pi, 1.7 * np.pi), (0.4 * np.pi, 2.8 * np.pi),\n        (0.85 * np.pi, 0.9 * np.pi)\n    ])\n\n    results = []\n    for case in test_cases:\n        a, f, l, m, J0, alpha, N_theta_coarse, N_phi_coarse, N_theta_fine, N_phi_fine = case\n\n        omega = 2 * np.pi * f\n        k = omega / c # k = omega * sqrt(mu_0 * epsilon_0)\n        wavelength = 2 * np.pi / k\n        delta = alpha * wavelength\n        \n        r_obs_mag = a + delta\n        obs_points_cart = np.array([\n            r_obs_mag * np.array([\n                np.sin(th) * np.cos(ph),\n                np.sin(th) * np.sin(ph),\n                np.cos(th)\n            ]) for th, ph in non_matched_points_sph\n        ])\n\n        E_scat_fine_tangential = compute_scattered_field(\n            obs_points_cart, a, k, omega, J0, l, m, N_theta_fine, N_phi_fine\n        )\n        \n        E_scat_coarse_tangential = compute_scattered_field(\n            obs_points_cart, a, k, omega, J0, l, m, N_theta_coarse, N_phi_coarse\n        )\n\n        E_inc_tangential = -E_scat_fine_tangential\n\n        # E_inc is a numpy array of shape (M, 3)\n        # E_scat_coarse is also a numpy array of shape (M, 3)\n        residual_vectors = E_inc_tangential + E_scat_coarse_tangential\n        \n        # Norms are computed along the last axis (axis=1)\n        residual_norms = np.linalg.norm(residual_vectors, axis=1)\n        inc_field_norms = np.linalg.norm(E_inc_tangential, axis=1)\n\n        # To avoid division by zero, though unlikely for these test points\n        inc_field_norms[inc_field_norms == 0] = 1e-16\n\n        relative_errors = residual_norms / inc_field_norms\n        rms_error = np.sqrt(np.mean(relative_errors**2))\n        results.append(rms_error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef compute_dYlm_dtheta(m, l, theta, phi):\n    \"\"\"\n    Computes the derivative of the spherical harmonic Y_lm with respect to theta.\n    Uses the stable recurrence relation involving Y_l,m-1 and Y_l,m+1.\n    \"\"\"\n    if l == 0:\n        return np.zeros_like(theta, dtype=complex)\n\n    # Term 1: involving Y_l,m+1\n    # This term is zero if m = l\n    if m == l:\n        c1 = 0\n    else:\n        c1 = np.sqrt((l - m) * (l + m + 1))\n    \n    Y_lm_plus_1 = sph_harm(m + 1, l, phi, theta)\n    term1 = 0.5 * c1 * np.exp(-1j * phi) * Y_lm_plus_1\n\n    # Term 2: involving Y_l,m-1\n    # This term is zero if m = -l\n    if m == -l:\n        c2 = 0\n    else:\n        c2 = np.sqrt((l + m) * (l - m + 1))\n        \n    Y_lm_minus_1 = sph_harm(m - 1, l, phi, theta)\n    term2 = -0.5 * c2 * np.exp(1j * phi) * Y_lm_minus_1\n\n    return term1 + term2\n\ndef compute_scattered_field(obs_points_cart, a, k, omega, J0, l, m, N_theta, N_phi):\n    \"\"\"\n    Computes the scattered electric field by numerically integrating over the sphere.\n    \"\"\"\n    # Create the source grid for integration\n    d_theta = np.pi / N_theta\n    d_phi = 2 * np.pi / N_phi\n    \n    theta_s = (np.arange(N_theta) + 0.5) * d_theta\n    phi_s = (np.arange(N_phi) + 0.5) * d_phi\n    \n    theta_s_grid, phi_s_grid = np.meshgrid(theta_s, phi_s, indexing='ij')\n\n    # Compute current density J at all source points\n    # 1. Spherical harmonics and their derivatives\n    Y_lm = sph_harm(m, l, phi_s_grid, theta_s_grid)\n    dYlm_dphi = 1j * m * Y_lm\n    dYlm_dtheta_vals = compute_dYlm_dtheta(m, l, theta_s_grid, phi_s_grid)\n    \n    # Avoid division by zero at poles (though midpoint rule already does)\n    sin_theta_s = np.sin(theta_s_grid)\n    sin_theta_s[sin_theta_s == 0] = 1e-16\n    \n    # 2. Components of X_lm in spherical coordinates\n    X_theta = - (1 / np.sqrt(l * (l + 1))) * (1 / sin_theta_s) * dYlm_dphi\n    X_phi = (1 / np.sqrt(l * (l + 1))) * dYlm_dtheta_vals\n\n    # 3. Current density vector J in local spherical coordinates\n    J_theta = J0 * X_theta\n    J_phi = J0 * X_phi\n    \n    # 4. Convert J to Cartesian coordinates for integration\n    # Cartesian components of spherical basis vectors\n    e_theta_x = np.cos(theta_s_grid) * np.cos(phi_s_grid)\n    e_theta_y = np.cos(theta_s_grid) * np.sin(phi_s_grid)\n    e_theta_z = -np.sin(theta_s_grid)\n    e_phi_x = -np.sin(phi_s_grid)\n    e_phi_y = np.cos(phi_s_grid)\n    # e_phi_z is always 0\n    \n    J_x = J_theta * e_theta_x + J_phi * e_phi_x\n    J_y = J_theta * e_theta_y + J_phi * e_phi_y\n    J_z = J_theta * e_theta_z # J_phi has no z-component\n    \n    J_cartesian = np.stack((J_x, J_y, J_z), axis=-1) # Shape: (N_theta, N_phi, 3)\n\n    # Source point positions in Cartesian coordinates\n    r_prime_x = a * np.sin(theta_s_grid) * np.cos(phi_s_grid)\n    r_prime_y = a * np.sin(theta_s_grid) * np.sin(phi_s_grid)\n    r_prime_z = a * np.cos(theta_s_grid)\n    r_prime = np.stack((r_prime_x, r_prime_y, r_prime_z), axis=-1)\n\n    # Integration area element\n    dS = a**2 * np.sin(theta_s_grid) * d_theta * d_phi\n\n    E_scat_tangential = []\n    \n    # Loop over each observation point\n    for r_obs in obs_points_cart:\n        # Vector from source to observation point\n        dr = r_obs - r_prime  # Shape: (N_theta, N_phi, 3)\n        dist = np.linalg.norm(dr, axis=-1) # Shape: (N_theta, N_phi)\n\n        # Green's function\n        G = np.exp(1j * k * dist) / (4 * np.pi * dist)\n\n        # Integrand (vector)\n        integrand = G[..., np.newaxis] * J_cartesian * dS[..., np.newaxis]\n        \n        # Sum over grid points to get E_scat (vector)\n        E_scat_vec = np.sum(integrand, axis=(0, 1)) * 1j * omega * mu_0\n\n        # Project to tangential component at observation point\n        r_obs_hat = r_obs / np.linalg.norm(r_obs)\n        E_scat_radial_comp = np.dot(E_scat_vec, r_obs_hat) * r_obs_hat\n        E_scat_tangential_vec = E_scat_vec - E_scat_radial_comp\n        \n        E_scat_tangential.append(E_scat_tangential_vec)\n\n    return np.array(E_scat_tangential)\n\nsolve()\n```"
        }
    ]
}