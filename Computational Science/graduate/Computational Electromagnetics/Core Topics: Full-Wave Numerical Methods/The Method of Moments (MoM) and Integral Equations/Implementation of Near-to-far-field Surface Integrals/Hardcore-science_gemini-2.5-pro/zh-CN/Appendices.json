{
    "hands_on_practices": [
        {
            "introduction": "对任何电磁仿真工具的一个鲁棒性测试是其维持基本物理定律的能力。本练习要求您从第一性原理出发，实现一个近场到远场的变换，并用它来数值验证电磁学的基石——洛伦兹互易定理。通过计算两个天线之间的传递函数并在交换其角色后确认其对称性，您将能够验证数值积分的正确性，并加深对底层理论的理解。",
            "id": "3317922",
            "problem": "您需要基于电磁学第一性原理实现一个完整的算法，通过在一个封闭曲面上由切向场构建的近场-远场曲面积分来验证电磁互易性。其目标是仅使用在惠更斯（Huygens）曲面上测量的场来计算两个无限小天线之间的复数传输量，然后验证当发射器和接收器的角色互换时，传递函数在由于离散化而指定的容差范围内是对称的。\n\n从自由空间中角频率为 $\\omega$、波数为 $k$、介电常数为 $\\varepsilon_0$、磁导率为 $\\mu_0$、本征阻抗为 $\\eta_0$ 的时谐麦克斯韦（Maxwell）方程出发。在一个封闭曲面上应用电磁等效原理，通过由该曲面上的切向近场构建的等效电和磁表面电流来表示辐射场。将每个天线建模为曲面内部具有指定电偶极矩矢量的无限小电偶极子。推导在整个近场区都有效的点电偶极子源的近场表达式，然后通过基于这些等效电流的近场-远场变换，将任意观测方向上的远场表示为仅与曲面相关的量。使用这些推导出的表达式来数值计算传递函数并检验对称性。\n\n场景规范：\n- 介质：自由空间，介电常数 $\\varepsilon_0$ 单位为 $\\mathrm{F/m}$，磁导率 $\\mu_0$ 单位为 $\\mathrm{H/m}$，波数 $k = \\omega \\sqrt{\\mu_0 \\varepsilon_0}$ 单位为 $\\mathrm{rad/m}$，本征阻抗 $\\eta_0 = \\sqrt{\\mu_0 / \\varepsilon_0}$ 单位为 $\\Omega$。\n- 源模型：位于原点的无限小电偶极子，电偶极矩矢量为 $\\mathbf{p}$ 单位为 $\\mathrm{C \\cdot m}$，时间依赖性为 $\\mathrm{e}^{j \\omega t}$。\n- 测量曲面 $S$：一个以原点为中心、边长为 $L$ 的立方体，每个面离散化为 $N \\times N$ 个面元。对于每个面元，使用其中心位置 $\\mathbf{r}'$、单位法向量 $\\hat{\\mathbf{n}}(\\mathbf{r}')$ 和面积 $\\Delta S$。\n- 曲面 $S$ 上的等效电流：使用曲面 $S$ 上的切向电场 $\\mathbf{E}(\\mathbf{r}')$ 和磁场 $\\mathbf{H}(\\mathbf{r}')$ 构建。\n- 远场评估：在沿单位方向 $\\hat{\\mathbf{k}}$ 距离为 $R$ 的一个点上，通过对等效电流的适当组合在 $S$ 上积分，计算辐射远区电场 $\\mathbf{E}_\\infty(\\hat{\\mathbf{k}};R)$。\n- 传输量：对于一个单位方向矢量为 $\\hat{\\mathbf{u}}_{\\mathrm{rx}}$ 的接收无限小偶极子，定义一个与感应电压成正比的复标量，当天线 $\\mathrm{A}$ 发射、$\\mathrm{B}$ 接收时为 $S_{21} = \\hat{\\mathbf{u}}_{\\mathrm{rx}} \\cdot \\mathbf{E}_\\infty(\\hat{\\mathbf{k}};R)$。当角色互换时，类似地定义 $S_{12}$。您必须检查 $|S_{21} - S_{12}| \\le \\delta$，其中 $\\delta$ 是一个指定的非负容差。\n\n算法要求：\n1. 推导由位于原点、矩为 $\\mathbf{p}$ 的点电偶极子在曲面 $S$ 上产生的精确近场 $\\mathbf{E}(\\mathbf{r}')$ 和 $\\mathbf{H}(\\mathbf{r}')$。\n2. 根据这些表面场，在曲面 $S$ 上使用等效原理构建等效电和磁表面电流。\n3. 推导一个基于这些等效电流的近场-远场曲面积分，该积分可在观测方向 $\\hat{\\mathbf{k}}$ 和距离 $R$ 处产生远区电场 $\\mathbf{E}_\\infty(\\hat{\\mathbf{k}};R)$。\n4. 在离散化的立方体 $S$ 上数值实现该曲面积分。\n5. 对于指定的天线方向和观测方向，计算复数传输标量 $S_{21}$ 和 $S_{12}$，并在给定容差 $\\delta$ 内验证对称条件。\n\n单位：\n- 距离必须以米表示。\n- 频率必须以赫兹表示。\n- 传输量 $S_{21}$ 和 $S_{12}$ 以及绝对差值必须分别视为无量纲的复数量和实数量。\n\n测试套件：\n对于每个测试，发射器是一个被同一个立方体曲面 $S$ 包围、位于原点的无限小电偶极子。接收器放置在远场区，沿指定单位方向距离为 $R$ 的位置。当角色互换时，重复该过程，发射器仍在原点，但接收器放置在相反方向，以保持对称的自由空间路径长度。使用以下参数的测试用例：\n\n- 测试 1 (正常路径)：\n  - 立方体边长 $L = 1.0$ 米。\n  - 离散化 $N = 24$ 个面元/面维度。\n  - 频率 $f = 300 \\times 10^6$ 赫兹。\n  - 距离 $R = 20.0$ 米。\n  - 发射器方向 $\\hat{\\mathbf{u}}_{\\mathrm{A}} = [0, 1, 0]$。\n  - 接收器方向 $\\hat{\\mathbf{u}}_{\\mathrm{B}} = [1, 0, 0]$。\n  - 接收器方向 $\\hat{\\mathbf{k}}_{\\mathrm{B}} = [1, 0, 0]$；互换后的接收器方向 $\\hat{\\mathbf{k}}_{\\mathrm{A}} = [-1, 0, 0]$。\n  - 容差 $\\delta = 1 \\times 10^{-3}$。\n\n- 测试 2 (更粗糙的离散化，更宽松的容差)：\n  - $L = 1.0$ 米, $N = 8$, $f = 300 \\times 10^6$ 赫兹, $R = 20.0$ 米。\n  - $\\hat{\\mathbf{u}}_{\\mathrm{A}} = [0, 1, 0]$, $\\hat{\\mathbf{u}}_{\\mathrm{B}} = [1, 0, 0]$。\n  - $\\hat{\\mathbf{k}}_{\\mathrm{B}} = [1, 0, 0]$, $\\hat{\\mathbf{k}}_{\\mathrm{A}} = [-1, 0, 0]$。\n  - $\\delta = 1 \\times 10^{-2}$。\n\n- 测试 3 (轴向零点边缘情况)：\n  - $L = 1.0$ 米, $N = 12$, $f = 300 \\times 10^6$ 赫兹, $R = 20.0$ 米。\n  - $\\hat{\\mathbf{u}}_{\\mathrm{A}} = [0, 0, 1]$, $\\hat{\\mathbf{u}}_{\\mathrm{B}} = [0, 0, 1]$。\n  - $\\hat{\\mathbf{k}}_{\\mathrm{B}} = [0, 0, 1]$, $\\hat{\\mathbf{k}}_{\\mathrm{A}} = [0, 0, -1]$。\n  - $\\delta = 2 \\times 10^{-3}$。\n\n程序输出规范：\n您的程序必须生成单行输出，其中包含一个与三个测试相对应的逗号分隔的布尔值 Python 列表，顺序与上文一致。如果该测试的对称条件 $|S_{21} - S_{12}| \\le \\delta$ 得到满足，则相应的布尔值为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。例如，输出格式必须与 $\\left[\\mathrm{True},\\mathrm{False},\\mathrm{True}\\right]$ 完全相同。",
            "solution": "用户问题是计算电磁学中一个有效且适定性良好的任务。它要求实现一个数值算法来验证电磁互易性原理。解决方案将首先从第一性原理推导出必要的理论表达式，然后详细说明其实现的数值算法。\n\n### 1. 理论基础\n\n分析基于自由空间中的时谐麦克斯韦（Maxwell）方程，假设时间依赖关系为 $e^{j \\omega t}$。介质由介电常数 $\\varepsilon_0$、磁导率 $\\mu_0$、角频率 $\\omega$、波数 $k = \\omega / c = \\omega\\sqrt{\\mu_0\\varepsilon_0}$ 和本征阻抗 $\\eta_0 = \\sqrt{\\mu_0/\\varepsilon_0}$ 来表征。\n\n#### 1.1 无限小电偶极子的场\n\n位于原点、偶极矩矢量为 $\\mathbf{p}$ 的无限小电偶极子在整个空间中产生电场和磁场。在位置矢量 $\\mathbf{r}$ (其中 $r=|\\mathbf{r}|$ 且 $\\hat{\\mathbf{r}}=\\mathbf{r}/r$) 处，这些场的精确表达式为：\n\n电场 $\\mathbf{E}(\\mathbf{r})$ 为：\n$$\n\\mathbf{E}(\\mathbf{r}; \\mathbf{p}) = \\frac{e^{-jkr}}{4\\pi\\varepsilon_0} \\left\\{ k^2 \\frac{(\\hat{\\mathbf{r}} \\times \\mathbf{p}) \\times \\hat{\\mathbf{r}}}{r} + \\left(\\frac{1}{r^3} + \\frac{jk}{r^2}\\right) \\left(3\\hat{\\mathbf{r}}(\\hat{\\mathbf{r}}\\cdot\\mathbf{p}) - \\mathbf{p}\\right) \\right\\}\n$$\n磁场 $\\mathbf{H}(\\mathbf{r})$ 为：\n$$\n\\mathbf{H}(\\mathbf{r}; \\mathbf{p}) = \\frac{j\\omega}{4\\pi} \\left(jk + \\frac{1}{r}\\right) \\frac{e^{-jkr}}{r} (\\mathbf{p} \\times \\hat{\\mathbf{r}})\n$$\n这些公式在近场区和远场区都有效，并将用于确定 Huygens 曲面上的切向场。为了数值计算的目的，偶极矩的幅度取为单位1，即 $\\mathbf{p} = \\hat{\\mathbf{u}}$，其中 $\\hat{\\mathbf{u}}$ 是指定的方向矢量。\n\n#### 1.2 电磁等效原理\n\n电磁等效原理（Huygens 原理的一种形式）允许通过将源替换为封闭曲面 $S$ 上的一组等效电和磁表面电流来计算由该曲面内包含的源辐射的场。这些电流是根据曲面上场的切向分量定义的。对于曲面 $S$ 上一点 $\\mathbf{r}'$ 处的向外法向量 $\\hat{\\mathbf{n}}(\\mathbf{r}')$，等效电流定义为：\n\n等效电表面电流：\n$$\n\\mathbf{J}_s(\\mathbf{r}') = \\hat{\\mathbf{n}}(\\mathbf{r}') \\times \\mathbf{H}(\\mathbf{r}')\n$$\n等效磁表面电流：\n$$\n\\mathbf{M}_s(\\mathbf{r}') = -\\hat{\\mathbf{n}}(\\mathbf{r}') \\times \\mathbf{E}(\\mathbf{r}')\n$$\n这些在自由空间中辐射的电流，在 $S$ 外部复现了原始源的场。\n\n#### 1.3 近场-远场变换 (NFFT)\n\n这些表面电流产生的远区电场可以通过曲面积分计算。远场近似简化了积分公式中的格林函数。我们首先为给定的远场观测方向 $\\hat{\\mathbf{k}}$ 定义辐射矢量 $\\mathbf{N}(\\hat{\\mathbf{k}})$ 和 $\\mathbf{L}(\\hat{\\mathbf{k}})$：\n$$\n\\mathbf{N}(\\hat{\\mathbf{k}}) = \\iint_S \\mathbf{J}_s(\\mathbf{r}') e^{jk\\hat{\\mathbf{k}}\\cdot\\mathbf{r}'} dS'\n$$\n$$\n\\mathbf{L}(\\hat{\\mathbf{k}}) = \\iint_S \\mathbf{M}_s(\\mathbf{r}') e^{jk\\hat{\\mathbf{k}}\\cdot\\mathbf{r}'} dS'\n$$\n在方向 $\\hat{\\mathbf{k}}$ 上、距离为 $R$ 的远区电场 $\\mathbf{E}_\\infty$ 则由下式给出：\n$$\n\\mathbf{E}_\\infty(R\\hat{\\mathbf{k}}) \\approx \\frac{-jk e^{-jkR}}{4\\pi R} \\left[ \\eta_0 \\left(\\mathbf{N}(\\hat{\\mathbf{k}}) - \\left(\\mathbf{N}(\\hat{\\mathbf{k}}) \\cdot \\hat{\\mathbf{k}}\\right)\\hat{\\mathbf{k}}\\right) + \\left(\\mathbf{L}(\\hat{\\mathbf{k}}) \\times \\hat{\\mathbf{k}}\\right) \\right]\n$$\n项 $\\mathbf{N} - (\\mathbf{N} \\cdot \\hat{\\mathbf{k}})\\hat{\\mathbf{k}}$ 表示 $\\mathbf{N}$ 垂直于传播方向 $\\hat{\\mathbf{k}}$ 的分量。叉积 $\\mathbf{L} \\times \\hat{\\mathbf{k}}$ 本身也是横向的。\n\n### 2. 互易性验证\n\n洛伦兹（Lorentz）互易定理应用于两组源 $(\\mathbf{J}_1, \\mathbf{M}_1)$ 和 $(\\mathbf{J}_2, \\mathbf{M}_2)$ 时，会导致它们产生的场之间的关系。对于两个无限小电偶极子，位于 $\\mathbf{r}_1$ 的 $\\mathbf{p}_1$ 和位于 $\\mathbf{r}_2$ 的 $\\mathbf{p}_2$，该定理意味着 $\\mathbf{p}_1 \\cdot \\mathbf{E}_2(\\mathbf{r}_1) = \\mathbf{p}_2 \\cdot \\mathbf{E}_1(\\mathbf{r}_2)$。\n\n在这个问题中，定义了一个特定的互易性测试：\n1.  **对于 $S_{21}$**：一个矩为 $\\mathbf{p}_A$ 的发射器 (A) 位于原点。在方向 $\\hat{\\mathbf{k}}_B$ 上测量远场 $\\mathbf{E}_{\\infty, A}$。传输量是该场在接收器 (B) 方向 $\\hat{\\mathbf{u}}_B$ 上的投影：$S_{21} = \\hat{\\mathbf{u}}_B \\cdot \\mathbf{E}_{\\infty, A}(R\\hat{\\mathbf{k}}_B; \\mathbf{p}_A)$。\n\n2.  **对于 $S_{12}$**：角色互换。矩为 $\\mathbf{p}_B$ 的发射器 (B) 现在位于原点。接收器 (A) 位于远场的相反方向 $\\hat{\\mathbf{k}}_A = -\\hat{\\mathbf{k}}_B$。传输量为 $S_{12} = \\hat{\\mathbf{u}}_A \\cdot \\mathbf{E}_{\\infty, B}(R\\hat{\\mathbf{k}}_A; \\mathbf{p}_B)$。\n\n从解析上看，位于原点的偶极子 $\\mathbf{p}$ 的远场为 $\\mathbf{E}_\\infty \\propto (\\hat{\\mathbf{k}} \\times \\mathbf{p}) \\times \\hat{\\mathbf{k}}$。\n$S_{21}$ 与 $\\hat{\\mathbf{u}}_B \\cdot ((\\hat{\\mathbf{k}}_B \\times \\mathbf{p}_A) \\times \\hat{\\mathbf{k}}_B) = (\\mathbf{p}_A \\cdot \\hat{\\mathbf{u}}_B) - (\\mathbf{p}_A \\cdot \\hat{\\mathbf{k}}_B)(\\hat{\\mathbf{u}}_B \\cdot \\hat{\\mathbf{k}}_B)$ 成正比。\n$S_{12}$ 与 $\\hat{\\mathbf{u}}_A \\cdot ((\\hat{\\mathbf{k}}_A \\times \\mathbf{p}_B) \\times \\hat{\\mathbf{k}}_A)$ 成正比。代入 $\\hat{\\mathbf{k}}_A = -\\hat{\\mathbf{k}}_B$，这变为 $\\hat{\\mathbf{u}}_A \\cdot ((\\hat{\\mathbf{k}}_B \\times \\mathbf{p}_B) \\times \\hat{\\mathbf{k}}_B) = (\\mathbf{p}_B \\cdot \\hat{\\mathbf{u}}_A) - (\\mathbf{p}_B \\cdot \\hat{\\mathbf{k}}_B)(\\hat{\\mathbf{u}}_A \\cdot \\hat{\\mathbf{k}}_B)$。\n当 $\\mathbf{p}_A = \\hat{\\mathbf{u}}_A$ 和 $\\mathbf{p}_B = \\hat{\\mathbf{u}}_B$ 时，这两个表达式是相同的，这从解析上证实了 $S_{21}=S_{12}$。数值计算会引入误差，目标是验证这些误差很小，且对称性在容差 $\\delta$ 内成立。\n\n### 3. 数值算法\n\n辐射矢量 $\\mathbf{N}$ 和 $\\mathbf{L}$ 的曲面积分通过在离散化曲面上的求和来近似。\n\n1.  **曲面离散化**：边长为 $L$ 的立方体 Huygens 曲面被分为 6 个面。每个面被离散化为一个 $N \\times N$ 的方形面元网格。对于每个面元 $i$，计算其中心位置 $\\mathbf{r}'_i$、向外单位法向量 $\\hat{\\mathbf{n}}_i$ 和面积 $\\Delta S = (L/N)^2$。\n\n2.  **通过求和进行积分**：$\\mathbf{N}$ 和 $\\mathbf{L}$ 的积分计算为黎曼和：\n    $$\n    \\mathbf{N}(\\hat{\\mathbf{k}}) \\approx \\sum_{i=1}^{6N^2} \\mathbf{J}_s(\\mathbf{r}'_i) e^{jk\\hat{\\mathbf{k}}\\cdot\\mathbf{r}'_i} \\Delta S\n    $$\n    $$\n    \\mathbf{L}(\\hat{\\mathbf{k}}) \\approx \\sum_{i=1}^{6N^2} \\mathbf{M}_s(\\mathbf{r}'_i) e^{jk\\hat{\\mathbf{k}}\\cdot\\mathbf{r}'_i} \\Delta S\n    $$\n\n3.  **计算步骤**：对于每个测试用例，算法按以下步骤进行：\n    a. 根据给定的频率 $f$ 计算物理常数：$\\omega=2\\pi f$, $k=\\omega/c$。\n    b. 为立方体曲面生成面元网格。\n    c. **计算 $S_{21}$**：\n        i. 设置 $\\mathbf{p} = \\hat{\\mathbf{u}}_A$。\n        ii. 通过对所有面元求和，数值计算 $\\mathbf{N}_A(\\hat{\\mathbf{k}}_B)$ 和 $\\mathbf{L}_A(\\hat{\\mathbf{k}}_B)$。对每个面元，这涉及评估 $\\mathbf{E}(\\mathbf{r}'_i; \\mathbf{p})$ 和 $\\mathbf{H}(\\mathbf{r}'_i; \\mathbf{p})$ 以找到等效电流。\n        iii. 使用 NFFT 公式以及 $\\mathbf{N}_A$、$\\mathbf{L}_A$ 和 $\\hat{\\mathbf{k}}_B$ 计算 $\\mathbf{E}_{\\infty, A}$。\n        iv. 计算 $S_{21} = \\hat{\\mathbf{u}}_B \\cdot \\mathbf{E}_{\\infty, A}$。\n    d. **计算 $S_{12}$**：\n        i. 设置 $\\mathbf{p} = \\hat{\\mathbf{u}}_B$。\n        ii. 通过对所有面元求和，使用远场方向 $\\hat{\\mathbf{k}}_A$ 来数值计算 $\\mathbf{N}_B(\\hat{\\mathbf{k}}_A)$ 和 $\\mathbf{L}_B(\\hat{\\mathbf{k}}_A)$。\n        iii. 使用 NFFT 公式以及 $\\mathbf{N}_B$、$\\mathbf{L}_B$ 和 $\\hat{\\mathbf{k}}_A$ 计算 $\\mathbf{E}_{\\infty, B}$。\n        iv. 计算 $S_{12} = \\hat{\\mathbf{u}}_A \\cdot \\mathbf{E}_{\\infty, B}$。\n    e. **验证**：检查条件 $|S_{21} - S_{12}| \\le \\delta$ 是否满足。结果是一个布尔值。\n\n此过程对问题陈述中指定的所有测试用例重复进行。测试用例均为解析零点这一事实，为数值方法保持底层物理对称性的能力提供了严格的测试，因为任何计算出的非零场都是由数值近似误差引起的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import constants\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the results.\n    \"\"\"\n    # Physical constants\n    c0 = constants.c\n    eps0 = constants.epsilon_0\n    mu0 = constants.mu_0\n    eta0 = np.sqrt(mu0 / eps0)\n    \n    # Test cases from the problem statement\n    test_cases = [\n        {\n            \"L\": 1.0, \"N\": 24, \"f\": 300e6, \"R\": 20.0,\n            \"u_A\": np.array([0, 1, 0]), \"u_B\": np.array([1, 0, 0]),\n            \"k_B\": np.array([1, 0, 0]), \"k_A\": np.array([-1, 0, 0]),\n            \"delta\": 1e-3\n        },\n        {\n            \"L\": 1.0, \"N\": 8, \"f\": 300e6, \"R\": 20.0,\n            \"u_A\": np.array([0, 1, 0]), \"u_B\": np.array([1, 0, 0]),\n            \"k_B\": np.array([1, 0, 0]), \"k_A\": np.array([-1, 0, 0]),\n            \"delta\": 1e-2\n        },\n        {\n            \"L\": 1.0, \"N\": 12, \"f\": 300e6, \"R\": 20.0,\n            \"u_A\": np.array([0, 0, 1]), \"u_B\": np.array([0, 0, 1]),\n            \"k_B\": np.array([0, 0, 1]), \"k_A\": np.array([0, 0, -1]),\n            \"delta\": 2e-3\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        # Unpack parameters\n        L, N, f, R = params[\"L\"], params[\"N\"], params[\"f\"], params[\"R\"]\n        u_A, u_B = params[\"u_A\"], params[\"u_B\"]\n        k_B, k_A = params[\"k_B\"], params[\"k_A\"]\n        delta = params[\"delta\"]\n\n        # Derived parameters\n        omega = 2 * np.pi * f\n        k = omega / c0\n        \n        # Generate the surface mesh\n        patches = generate_cube_surface(L, N)\n        \n        # Calculate S21 and S12\n        s21 = calculate_transfer_quantity(u_A, u_B, k_B, patches, k, omega, R, eps0, eta0)\n        s12 = calculate_transfer_quantity(u_B, u_A, k_A, patches, k, omega, R, eps0, eta0)\n        \n        # Verify reciprocity\n        is_symmetric = np.abs(s21 - s12) = delta\n        results.append(is_symmetric)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef generate_cube_surface(L, N):\n    \"\"\"\n    Generates a list of patches for a cube surface centered at the origin.\n    Each patch is represented by its center, normal vector, and area.\n    \"\"\"\n    patches = []\n    dL = L / N\n    dS = dL * dL\n    \n    # Grid for one face\n    grid_coords = np.linspace(-L/2 + dL/2, L/2 - dL/2, N)\n    \n    # +/- X faces\n    for i in range(N):\n        for j in range(N):\n            # +X face\n            patches.append((np.array([L/2, grid_coords[i], grid_coords[j]]), np.array([1, 0, 0]), dS))\n            # -X face\n            patches.append((np.array([-L/2, grid_coords[i], grid_coords[j]]), np.array([-1, 0, 0]), dS))\n    \n    # +/- Y faces\n    for i in range(N):\n        for j in range(N):\n            # +Y face\n            patches.append((np.array([grid_coords[i], L/2, grid_coords[j]]), np.array([0, 1, 0]), dS))\n            # -Y face\n            patches.append((np.array([grid_coords[i], -L/2, grid_coords[j]]), np.array([0, -1, 0]), dS))\n    \n    # +/- Z faces\n    for i in range(N):\n        for j in range(N):\n            # +Z face\n            patches.append((np.array([grid_coords[i], grid_coords[j], L/2]), np.array([0, 0, 1]), dS))\n            # -Z face\n            patches.append((np.array([grid_coords[i], grid_coords[j], -L/2]), np.array([0, 0, -1]), dS))\n            \n    return patches\n\n\ndef get_dipole_fields(r_prime, p, k, omega, eps0):\n    \"\"\"\n    Calculates the E and H fields from an infinitesimal dipole at the origin.\n    Args:\n        r_prime (np.ndarray): Position vector of the observation point.\n        p (np.ndarray): Dipole moment vector.\n        k (float): Wavenumber.\n        omega (float): Angular frequency.\n        eps0 (float): Vacuum permittivity.\n    Returns:\n        (E_field, H_field) tuple of np.ndarray.\n    \"\"\"\n    r_norm = np.linalg.norm(r_prime)\n    if r_norm == 0:\n        # Avoid singularity at the origin, though not expected for surface points\n        return (np.zeros(3, dtype=complex), np.zeros(3, dtype=complex))\n    \n    r_hat = r_prime / r_norm\n    \n    # Common phase factor\n    exp_term = np.exp(-1j * k * r_norm)\n\n    # E-field calculation\n    r_hat_dot_p = np.dot(r_hat, p)\n    term1_E = k**2 * np.cross(np.cross(r_hat, p), r_hat) / r_norm\n    term2_E = (1 / r_norm**3 + 1j * k / r_norm**2) * (3 * r_hat * r_hat_dot_p - p)\n    E_field = (exp_term / (4 * np.pi * eps0)) * (term1_E + term2_E)\n    \n    # H-field calculation\n    p_cross_r_hat = np.cross(p, r_hat)\n    term1_H = (1j * k + 1 / r_norm) * (exp_term / r_norm) * p_cross_r_hat\n    H_field = (1j * omega / (4 * np.pi)) * term1_H\n    \n    return E_field, H_field\n\ndef calculate_transfer_quantity(p_tx, u_rx, k_hat_rx, patches, k, omega, R, eps0, eta0):\n    \"\"\"\n    Calculates a single transfer quantity S_ij using the NFFT algorithm.\n    Args:\n        p_tx (np.ndarray): Transmitter dipole orientation vector.\n        u_rx (np.ndarray): Receiver dipole orientation vector.\n        k_hat_rx (np.ndarray): Receiver far-field direction vector.\n        patches (list): List of surface patches.\n        k, omega, R, eps0, eta0: Physical parameters.\n    Returns:\n        Complex scalar transfer quantity S_ij.\n    \"\"\"\n    # Dipole moment p0 is assumed to be 1 C.m\n    p_vec = p_tx.astype(float)\n    \n    N_rad = np.zeros(3, dtype=complex)\n    L_rad = np.zeros(3, dtype=complex)\n    \n    for r_prime, n_hat, dS in patches:\n        # Calculate near fields on the patch\n        E_near, H_near = get_dipole_fields(r_prime, p_vec, k, omega, eps0)\n\n        # Calculate equivalent currents\n        Js = np.cross(n_hat, H_near)\n        Ms = -np.cross(n_hat, E_near)\n        \n        # Phase term for NFFT integral\n        phase_term = np.exp(1j * k * np.dot(k_hat_rx, r_prime))\n        \n        # Accumulate radiation vectors (numerical integration)\n        N_rad += Js * phase_term * dS\n        L_rad += Ms * phase_term * dS\n        \n    # Calculate far-field vector F\n    N_transverse = N_rad - np.dot(N_rad, k_hat_rx) * k_hat_rx\n    L_cross_k = np.cross(L_rad, k_hat_rx)\n    F_vector = eta0 * N_transverse + L_cross_k\n    \n    # Calculate full far-field E_infinity\n    prefactor = (-1j * k * np.exp(-1j * k * R)) / (4 * np.pi * R)\n    E_inf = prefactor * F_vector\n    \n    # Compute transfer quantity\n    S = np.dot(u_rx, E_inf)\n    \n    return S\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在实际应用中，近场数据通常来自数值求解器，并可能包含离散化带来的伪影，例如垂直于积分表面的非物理场分量，这违反了连续理论的假设。本练习旨在解决这个常见问题，要求您实现一个投影算子来强制场的切向性。通过量化远场精度的提升，您将学到一种提高数值模拟鲁棒性的关键技术。",
            "id": "3317900",
            "problem": "考虑一个采用 $e^{+i\\omega t}$ 时谐约定的时谐电磁场，该场存在于均匀、各向同性、无源的介质中，其介电常数为 $\\epsilon$，磁导率为 $\\mu$，波数为 $k=\\omega\\sqrt{\\mu\\epsilon}$，波阻抗为 $\\eta=\\sqrt{\\mu/\\epsilon}$。设 $\\mathcal{S}$ 为一个闭合的惠更斯面，由一个以原点为中心、边长为 $L$ 的立方体的六个面组成。记 $\\hat{\\mathbf{n}}(\\mathbf{r})$ 为 $\\mathcal{S}$ 上表面点 $\\mathbf{r}\\in\\mathcal{S}$ 处的外向单位法向量。近场-远场表面积分利用 $\\mathcal{S}$ 上的等效电、磁表面流，在给定的观测方向 $\\hat{\\mathbf{r}}$ 上产生辐射远场。\n\n从微分形式的宏观麦克斯韦方程组出发：\n$$\\nabla\\times\\mathbf{E}= -i\\omega\\mu\\,\\mathbf{H},\\qquad \\nabla\\times\\mathbf{H}= i\\omega\\epsilon\\,\\mathbf{E},\\qquad \\nabla\\cdot\\epsilon\\mathbf{E}=0,\\qquad \\nabla\\cdot\\mu\\mathbf{H}=0,$$\n并结合表面等效原理，推导远区电场 $\\mathbf{E}_\\infty(\\hat{\\mathbf{r}})$ 的原理性表达式，该表达式应以定义在 $\\mathcal{S}$ 上的等效电、磁流的表面积分形式表示。你的推导必须明确由离散化引起的场在 $\\mathcal{S}$ 上的任何法向分量的影响，并且必须证明为什么对于惠更斯面上的Love等效公式，只有切向分量是物理上允许的。\n\n你需要构建近场-远场变换的离散实现，并评估由离散化引起的 $\\mathcal{S}$ 上非物理法向分量的影响。具体而言：\n\n- 推导一个投影算子 $\\mathcal{Q}(\\hat{\\mathbf{n}})$，它作用于表面点上的矢量场样本 $\\mathbf{v}\\in\\mathbb{R}^3$，在欧几里得范数下对 $\\mathbf{v}$ 产生最小扰动的同时，强制执行离散约束 $\\hat{\\mathbf{n}}\\cdot\\mathbf{E}=0$ 和 $\\hat{\\mathbf{n}}\\cdot\\mathbf{H}=0$。请用 $\\hat{\\mathbf{n}}$ 显式地表达 $\\mathcal{Q}$。\n\n- 利用表面等效原理，将远区场 $\\mathbf{E}_\\infty(\\hat{\\mathbf{r}})$ 表示为等效表面流的泛函。然后，提供一个离散求积公式，通过对立方体每个面上均匀离散化的表面点集进行加权求和，来近似连续表面积分。该求积必须包含在每个表面点上计算的相位因子 $e^{ik\\,\\hat{\\mathbf{r}}\\cdot\\mathbf{r}}$。\n\n- 实现一个测试场景，其中通过一个平滑的面局域分布在 $\\mathcal{S}$ 上合成切向场 $\\mathbf{E}_t(\\mathbf{r})$ 和 $\\mathbf{H}_t(\\mathbf{r})=(1/\\eta)\\,\\hat{\\mathbf{n}}(\\mathbf{r})\\times \\mathbf{E}_t(\\mathbf{r})$：\n$$\\mathbf{E}_t(\\mathbf{r})=\\mathbf{t}_{\\text{face}}(\\mathbf{r})\\,E_0\\,\\exp\\!\\left(-\\frac{\\|\\mathbf{u}_{\\text{face}}(\\mathbf{r})\\|^2}{\\sigma^2}\\right),$$\n其中 $\\mathbf{t}_{\\text{face}}(\\mathbf{r})$ 是该面上的单位切向方向，$\\mathbf{u}_{\\text{face}}(\\mathbf{r})$ 是从该面中心测量的面内位置向量。利用此分布定义 $\\mathcal{S}$ 上的精确切向等效流 $\\mathbf{M}_s(\\mathbf{r})=-\\hat{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{E}_t(\\mathbf{r})$ 和 $\\mathbf{J}_s(\\mathbf{r})=\\hat{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{H}_t(\\mathbf{r})$，并通过你的离散近场-远场变换计算一个参考远场 $\\mathbf{E}_\\infty^{\\text{ref}}(\\hat{\\mathbf{r}})$。\n\n- 通过用法向噪声污染测量场，并使用通过将 $\\hat{\\mathbf{n}}(\\mathbf{r})$ 绕固定轴旋转一个小角度得到的受扰（未对准）法向量 $\\tilde{\\mathbf{n}}(\\mathbf{r})$，来模拟离散化引起的非物理法向分量。根据受污染的测量值定义朴素电流 $\\mathbf{M}_s^{\\text{naive}}(\\mathbf{r})=-\\tilde{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{E}_{\\text{meas}}(\\mathbf{r})$ 和 $\\mathbf{J}_s^{\\text{naive}}(\\mathbf{r})=\\tilde{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{H}_{\\text{meas}}(\\mathbf{r})$。同时定义投影场 $\\mathbf{E}_{\\text{proj}}(\\mathbf{r})=\\mathcal{Q}(\\hat{\\mathbf{n}}(\\mathbf{r}))\\,\\mathbf{E}_{\\text{meas}}(\\mathbf{r})$ 和 $\\mathbf{H}_{\\text{proj}}(\\mathbf{r})=\\mathcal{Q}(\\hat{\\mathbf{n}}(\\mathbf{r}))\\,\\mathbf{H}_{\\text{meas}}(\\mathbf{r})$，并形成校正电流 $\\mathbf{M}_s^{\\text{proj}}(\\mathbf{r})=-\\hat{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{E}_{\\text{proj}}(\\mathbf{r})$ 和 $\\mathbf{J}_s^{\\text{proj}}(\\mathbf{r})=\\hat{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{H}_{\\text{proj}}(\\mathbf{r})$。\n\n- 对于由极角 $\\theta$ 和方位角 $\\phi$（单位为弧度）参数化的一组观测方向 $\\{\\hat{\\mathbf{r}}_m\\}$，计算朴素远场和投影远场的相对 $\\ell^2$ 误差：\n$$\\varepsilon_{\\text{naive}}=\\sqrt{\\frac{\\sum_m\\|\\mathbf{E}_\\infty^{\\text{naive}}(\\hat{\\mathbf{r}}_m)-\\mathbf{E}_\\infty^{\\text{ref}}(\\hat{\\mathbf{r}}_m)\\|_2^2}{\\sum_m\\|\\mathbf{E}_\\infty^{\\text{ref}}(\\hat{\\mathbf{r}}_m)\\|_2^2}},\\qquad \\varepsilon_{\\text{proj}}=\\sqrt{\\frac{\\sum_m\\|\\mathbf{E}_\\infty^{\\text{proj}}(\\hat{\\mathbf{r}}_m)-\\mathbf{E}_\\infty^{\\text{ref}}(\\hat{\\mathbf{r}}_m)\\|_2^2}{\\sum_m\\|\\mathbf{E}_\\infty^{\\text{ref}}(\\hat{\\mathbf{r}}_m)\\|_2^2}}.$$\n报告改善因子 $\\rho=\\varepsilon_{\\text{naive}}/\\varepsilon_{\\text{proj}}$。\n\n在数值评估中使用以下符合物理现实的常数和几何结构：立方体边长 $L=1\\,\\mathrm{m}$，光速 $c=299{,}792{,}458\\,\\mathrm{m/s}$，频率 $f=300\\,\\mathrm{MHz}$，波长 $\\lambda=c/f=1\\,\\mathrm{m}$，波数 $k=2\\pi/\\lambda=2\\pi\\,\\mathrm{rad/m}$，以及阻抗 $\\eta\\approx 376.730313668\\,\\Omega$。使用场振幅 $E_0=1\\,\\mathrm{V/m}$ 和高斯宽度 $\\sigma=L/3\\,\\mathrm{m}$。观测方向应以 $(\\theta,\\phi)$（单位为弧度）指定。法向量扰动角度输入必须以度为单位指定。表面求积应在每个面上使用 $N\\times N$ 个点，这些点位于单元中心，并具有统一的面积权重。\n\n设计一个包含4种情况的测试套件，以探究不同的离散化效应：\n- 情况1：法向量扰动角度 $5^\\circ$，污染幅度 $\\alpha_E=0$ 和 $\\alpha_H=0$，以及 $N=20$。\n- 情况2：法向量扰动角度 $5^\\circ$，污染幅度 $\\alpha_E=0.1$ 和 $\\alpha_H=0.1$，以及 $N=20$。\n- 情况3：法向量扰动角度 $15^\\circ$，污染幅度 $\\alpha_E=0.5$ 和 $\\alpha_H=0.5$，以及 $N=20$。\n- 情况4：法向量扰动角度 $10^\\circ$，污染幅度 $\\alpha_E=0.2$ 和 $\\alpha_H=0.2$，以及 $N=8$。\n\n你的程序必须使用固定的随机种子计算这四种情况下的改善因子 $\\rho$ 以保证可复现性，并生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\rho_1,\\rho_2,\\rho_3,\\rho_4]$）。输出条目必须是浮点数。观测集中的所有角度都必须是弧度。最终的数值输出中无需包含任何物理单位，因为所报告的量是无量纲的。",
            "solution": "该问题要求推导并实现一个在闭合立方体表面上的电磁场近场-远场变换，并特别关注评估和校正由离散化引起的非物理场分量所产生的误差。\n\n### 1. 理论基础：表面等效原理与远场辐射\n\n近场-远场变换的基础是表面等效原理，它是从矢量格林定理或Stratton-Chu公式推导出的惠更斯原理的扩展。该原理指出，无源体积 $V$ 内的电磁场 $(\\mathbf{E}, \\mathbf{H})$ 可以由放置在包围 $V$ 的闭合曲面 $\\mathcal{S}$ 上的一组等效电、磁表面流 $\\mathbf{J}_s$ 和 $\\mathbf{M}_s$ 精确再现。这些电流在与填充 $V$ 的介质相同的均匀介质中辐射。时谐约定取为 $e^{+i\\omega t}$。\n\n等效流根据 $\\mathcal{S}$ 上场的切向分量定义：\n$$ \\mathbf{J}_s(\\mathbf{r}') = \\hat{\\mathbf{n}}(\\mathbf{r}') \\times \\mathbf{H}(\\mathbf{r}') $$\n$$ \\mathbf{M}_s(\\mathbf{r}') = -\\hat{\\mathbf{n}}(\\mathbf{r}') \\times \\mathbf{E}(\\mathbf{r}') $$\n其中 $\\mathbf{r}' \\in \\mathcal{S}$ 是表面上的一个点，$\\hat{\\mathbf{n}}(\\mathbf{r}')$ 是外向单位法向量。\n\n这些电流在整个空间中产生场。在离原点大距离 $r = \\|\\mathbf{r}\\|$ 处、方向为 $\\hat{\\mathbf{r}}=\\mathbf{r}/r$ 的远区电场 $\\mathbf{E}_\\infty$ 可以通过辐射积分的远场近似来求得。关键步骤是将源点 $\\mathbf{r}'$ 到观测点 $\\mathbf{r}$ 的距离近似为 $\\|\\mathbf{r}-\\mathbf{r}'\\| \\approx r - \\hat{\\mathbf{r}}\\cdot\\mathbf{r}'$。对于空间依赖性为 $e^{-ikr}$ 的出射波，格林函数变为 $\\frac{e^{-ik\\|\\mathbf{r}-\\mathbf{r}'\\|}}{4\\pi\\|\\mathbf{r}-\\mathbf{r}'\\|} \\approx \\frac{e^{-ikr}}{4\\pi r}e^{ik\\hat{\\mathbf{r}}\\cdot\\mathbf{r}'}$。\n\n远场可以方便地用两个辐射矢量 $\\mathbf{N}(\\hat{\\mathbf{r}})$ 和 $\\mathbf{L}(\\hat{\\mathbf{r}})$ 来表示，它们是表面流的空间傅里叶变换：\n$$ \\mathbf{N}(\\hat{\\mathbf{r}}) = \\iint_{\\mathcal{S}} \\mathbf{J}_s(\\mathbf{r}') e^{ik\\hat{\\mathbf{r}}\\cdot\\mathbf{r}'} dS' $$\n$$ \\mathbf{L}(\\hat{\\mathbf{r}}) = \\iint_{\\mathcal{S}} \\mathbf{M}_s(\\mathbf{r}') e^{ik\\hat{\\mathbf{r}}\\cdot\\mathbf{r}'} dS' $$\n其中 $k=\\omega\\sqrt{\\mu\\epsilon}$ 是波数。\n\n远区电场横向于传播方向 $\\hat{\\mathbf{r}}$，并由下式给出：\n$$ \\mathbf{E}_\\infty(\\mathbf{r}) \\approx C(r) \\left[ -\\eta \\hat{\\mathbf{r}}\\times(\\hat{\\mathbf{r}}\\times\\mathbf{N}(\\hat{\\mathbf{r}})) - \\hat{\\mathbf{r}}\\times\\mathbf{L}(\\hat{\\mathbf{r}}) \\right] $$\n其中 $C(r) = \\frac{-ik e^{-ikr}}{4\\pi r}$ 是一个表示传播和衰减的复标量，$\\eta=\\sqrt{\\mu/\\epsilon}$ 是波阻抗。由于误差度量涉及场幅值的比率，这个公共因子 $C(r)$ 将会抵消。因此，我们关心的是远场的矢量部分：\n$$ \\mathbf{E}_{\\infty,\\text{vec}}(\\hat{\\mathbf{r}}) = -\\eta \\hat{\\mathbf{r}}\\times(\\hat{\\mathbf{r}}\\times\\mathbf{N}(\\hat{\\mathbf{r}})) - \\hat{\\mathbf{r}}\\times\\mathbf{L}(\\hat{\\mathbf{r}}) $$\n该表达式正确地显示了远场是横向的，因为 $\\hat{\\mathbf{r}} \\cdot \\mathbf{E}_{\\infty,\\text{vec}}(\\hat{\\mathbf{r}}) = 0$。\n\n### 2. 场分量的作用与离散化误差\n\n等效原理中 $\\mathbf{J}_s$ 和 $\\mathbf{M}_s$ 的定义仅涉及 $\\mathcal{S}$ 上场的切向分量，因为与 $\\hat{\\mathbf{n}}$ 的叉积会消除任何法向分量。在无源区域内的精确物理情景中，麦克斯韦方程组要求 $\\nabla\\cdot\\mathbf{E}=0$ 和 $\\nabla\\cdot\\mathbf{H}=0$。这意味着法向场分量与切向场分量的表面散度之间存在关系，该关系由等效电荷和电流的连续性方程决定：$\\nabla_s \\cdot \\mathbf{J}_s = -i\\omega (\\epsilon \\hat{\\mathbf{n}}\\cdot\\mathbf{E})$ 和 $\\nabla_s \\cdot \\mathbf{M}_s = -i\\omega (\\mu \\hat{\\mathbf{n}}\\cdot\\mathbf{H})$。\n\n在数值模拟（例如，FDTD、FEM）中，离散化误差可能导致违反无散条件，从而在惠更斯面上产生虚假的、非物理的法向分量。这些采样场 $(\\mathbf{E}_{\\text{meas}}, \\mathbf{H}_{\\text{meas}})$ 可能具有 $\\hat{\\mathbf{n}}\\cdot\\mathbf{E}_{\\text{meas}} \\neq 0$ 和 $\\hat{\\mathbf{n}}\\cdot\\mathbf{H}_{\\text{meas}} \\neq 0$，且其方式与切向场不一致。此外，表面的离散表示可能导致受扰动的法向量 $\\tilde{\\mathbf{n}} \\neq \\hat{\\mathbf{n}}$。\n\n如果使用这些不完美的数据朴素地计算电流，例如 $\\mathbf{J}_s^{\\text{naive}}=\\tilde{\\mathbf{n}}\\times\\mathbf{H}_{\\text{meas}}$，误差将是双重的：\n1. 使用了受扰动的法向量 $\\tilde{\\mathbf{n}}$ 而不是真实的法向量 $\\hat{\\mathbf{n}}$。\n2. $\\mathbf{H}_{\\text{meas}}$ 的非物理法向分量本不应对电流有贡献，但由于当 $\\tilde{\\mathbf{n}}$ 与 $\\hat{\\mathbf{n}}$ 不平行时 $\\tilde{\\mathbf{n}}\\times(\\mathbf{H}_{\\text{meas}}\\cdot\\hat{\\mathbf{n}})\\hat{\\mathbf{n}} \\neq 0$，导致其错误地“泄漏”到计算中。\n\n### 3. 通过切向投影进行误差缓解\n\n为解决这些误差，我们可以强制执行只有切向场对电流有贡献的物理约束。这可以通过将测量场投影到由真实法向量 $\\hat{\\mathbf{n}}$ 定义的切平面上来实现。\n我们寻求一个投影算子 $\\mathcal{Q}(\\hat{\\mathbf{n}})$，它对于任意矢量 $\\mathbf{v}$，生成一个矢量 $\\mathbf{v}_{\\text{proj}}$，使得 $\\hat{\\mathbf{n}}\\cdot\\mathbf{v}_{\\text{proj}}=0$，同时最小化欧几里得距离 $\\|\\mathbf{v}-\\mathbf{v}_{\\text{proj}}\\|_2$。这可以通过标准正交投影来解决。任何矢量 $\\mathbf{v}$ 都可以分解为 $\\mathbf{v} = \\mathbf{v}_{\\|} + \\mathbf{v}_{\\perp}$，其中 $\\mathbf{v}_{\\|} = (\\mathbf{v}\\cdot\\hat{\\mathbf{n}})\\hat{\\mathbf{n}}$ 是平行于 $\\hat{\\mathbf{n}}$ 的分量，$\\mathbf{v}_{\\perp}$ 是垂直于 $\\hat{\\mathbf{n}}$ 的分量。所需的投影即为 $\\mathbf{v}_{\\perp}$。\n$$ \\mathcal{Q}(\\hat{\\mathbf{n}})\\mathbf{v} = \\mathbf{v}_{\\perp} = \\mathbf{v} - \\mathbf{v}_{\\|} = \\mathbf{v} - (\\mathbf{v}\\cdot\\hat{\\mathbf{n}})\\hat{\\mathbf{n}} $$\n在矩阵形式中，若 $\\hat{\\mathbf{n}}$ 为列向量，该算子为 $\\mathcal{Q}(\\hat{\\mathbf{n}}) = \\mathbf{I} - \\hat{\\mathbf{n}}\\hat{\\mathbf{n}}^T$，其中 $\\mathbf{I}$ 是 $3 \\times 3$ 单位矩阵。\n\n通过将此算子应用于测量场，我们定义投影场：\n$$ \\mathbf{E}_{\\text{proj}}(\\mathbf{r}) = \\mathcal{Q}(\\hat{\\mathbf{n}}(\\mathbf{r}))\\,\\mathbf{E}_{\\text{meas}}(\\mathbf{r}) \\qquad \\mathbf{H}_{\\text{proj}}(\\mathbf{r}) = \\mathcal{Q}(\\hat{\\mathbf{n}}(\\mathbf{r}))\\,\\mathbf{H}_{\\text{meas}}(\\mathbf{r}) $$\n这些投影场保证了与真实表面相切。然后使用真实法向量和这些投影场来计算校正后的电流：\n$$ \\mathbf{M}_s^{\\text{proj}}(\\mathbf{r})=-\\hat{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{E}_{\\text{proj}}(\\mathbf{r}) \\qquad \\mathbf{J}_s^{\\text{proj}}(\\mathbf{r})=\\hat{\\mathbf{n}}(\\mathbf{r})\\times\\mathbf{H}_{\\text{proj}}(\\mathbf{r}) $$\n\n### 4. 在立方体表面上的离散实现\n\n辐射矢量 $\\mathbf{N}$ 和 $\\mathbf{L}$ 的表面积分使用求积法则进行数值计算。惠更斯面 $\\mathcal{S}$ 是一个边长为 $L$ 的立方体，由六个面 $\\mathcal{S} = \\bigcup_{j=1}^6 \\mathcal{S}_j$ 组成。每个面 $\\mathcal{S}_j$ 被离散化为一个 $N \\times N$ 的均匀单元格网格。对 $\\mathcal{S}$ 的积分变为对 $6N^2$ 个单元格积分的总和。使用中点法则，该积分通过对单元中心的加权求和来近似。\n设 $\\mathcal{S}$ 上所有单元中心的集合为 $\\{\\mathbf{r}_i\\}_{i=1}^{6N^2}$，每个单元的面积为 $\\Delta S = (L/N)^2$。辐射矢量的离散近似为：\n$$ \\mathbf{N}(\\hat{\\mathbf{r}}) \\approx \\sum_{i=1}^{6N^2} \\mathbf{J}_s(\\mathbf{r}_i) e^{ik\\hat{\\mathbf{r}}\\cdot\\mathbf{r}_i} \\Delta S $$\n$$ \\mathbf{L}(\\hat{\\mathbf{r}}) \\approx \\sum_{i=1}^{6N^2} \\mathbf{M}_s(\\mathbf{r}_i) e^{ik\\hat{\\mathbf{r}}\\cdot\\mathbf{r}_i} \\Delta S $$\n\n### 5. 数值测试流程总结\n\n该问题指定了一个数值实验，以量化投影方法的有效性。\n1.  **参考计算**：参考远场 $\\mathbf{E}_\\infty^{\\text{ref}}$ 是根据精确表面几何上的理想切向场 $\\mathbf{E}_t, \\mathbf{H}_t$ 计算得出的。电流为 $\\mathbf{M}_s^{\\text{ref}} = -\\hat{\\mathbf{n}}\\times\\mathbf{E}_t$ 和 $\\mathbf{J}_s^{\\text{ref}} = \\hat{\\mathbf{n}}\\times\\mathbf{H}_t$，其中 $\\mathbf{E}_t$ 根据构造是切向的。\n2.  **朴素计算**：通过法向噪声污染场以创建 $\\mathbf{E}_{\\text{meas}}, \\mathbf{H}_{\\text{meas}}$，并将表面法向量扰动为 $\\tilde{\\mathbf{n}}$。从电流 $\\mathbf{M}_s^{\\text{naive}} = -\\tilde{\\mathbf{n}}\\times\\mathbf{E}_{\\text{meas}}$ 和 $\\mathbf{J}_s^{\\text{naive}} = \\tilde{\\mathbf{n}}\\times\\mathbf{H}_{\\text{meas}}$ 计算朴素远场 $\\mathbf{E}_\\infty^{\\text{naive}}$。\n3.  **投影计算**：从电流 $\\mathbf{M}_s^{\\text{proj}}$ 和 $\\mathbf{J}_s^{\\text{proj}}$ 计算校正后的远场 $\\mathbf{E}_\\infty^{\\text{proj}}$，这些电流是根据投影场 $\\mathbf{E}_{\\text{proj}} = \\mathcal{Q}(\\hat{\\mathbf{n}})\\mathbf{E}_{\\text{meas}}$ 和 $\\mathbf{H}_{\\text{proj}} = \\mathcal{Q}(\\hat{\\mathbf{n}})\\mathbf{H}_{\\text{meas}}$ 使用真实法向量 $\\hat{\\mathbf{n}}$ 推导出来的。\n\n通过在一组观测方向 $\\{\\hat{\\mathbf{r}}_m\\}$ 上比较朴素和投影远场与参考远场，计算相对 $\\ell^2$ 误差 $\\varepsilon_{\\text{naive}}$ 和 $\\varepsilon_{\\text{proj}}$。改善因子是比率 $\\rho = \\varepsilon_{\\text{naive}} / \\varepsilon_{\\text{proj}}$，它量化了投影方法所实现的误差减小程度。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the near-to-far-field simulation for the given test cases.\n    \"\"\"\n    # Physical and numerical constants\n    L = 1.0  # Cube side length in meters\n    f = 300.0e6  # Frequency in Hz\n    c = 299792458.0  # Speed of light in m/s\n    # The problem implies using lambda=1m and k=2pi for simplicity.\n    lambda_ = 1.0\n    k = 2 * np.pi / lambda_\n    eta = 376.730313668  # Impedance of free space in Ohms\n    E0 = 1.0  # Field amplitude in V/m\n    sigma = L / 3.0  # Gaussian width\n    \n    # Set fixed random seed for reproducibility\n    np.random.seed(0)\n\n    # Define the observation grid\n    n_theta = 30\n    n_phi = 60\n    theta_vals = np.linspace(1e-3, np.pi - 1e-3, n_theta)  # Avoid poles\n    phi_vals = np.linspace(0, 2 * np.pi, n_phi, endpoint=False)\n    theta_grid, phi_grid = np.meshgrid(theta_vals, phi_vals)\n    r_hats = np.array([\n        np.sin(theta_grid) * np.cos(phi_grid),\n        np.sin(theta_grid) * np.sin(phi_grid),\n        np.cos(theta_grid)\n    ]).T.reshape(-1, 3)\n\n    # Test cases from the problem statement\n    test_cases = [\n        {'angle_deg': 5, 'alpha_E': 0.0, 'alpha_H': 0.0, 'N': 20},\n        {'angle_deg': 5, 'alpha_E': 0.1, 'alpha_H': 0.1, 'N': 20},\n        {'angle_deg': 15, 'alpha_E': 0.5, 'alpha_H': 0.5, 'N': 20},\n        {'angle_deg': 10, 'alpha_E': 0.2, 'alpha_H': 0.2, 'N': 8},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        angle_deg = case['angle_deg']\n        alpha_E = case['alpha_E']\n        alpha_H = case['alpha_H']\n\n        # 1. Generate surface points and normals for the cube\n        ds = (L / N)**2\n        face_centers = L / 2.0 * np.array([\n            [1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]\n        ])\n        \n        # Define tangent vectors for each face for E-field polarization\n        t_vectors = np.array([\n            [0, 1, 0], [0, 1, 0], [0, 0, 1], [0, 0, 1], [1, 0, 0], [1, 0, 0]\n        ])\n\n        u_coords = np.linspace(-L / 2 + L / (2 * N), L / 2 - L / (2 * N), N)\n        v_coords = np.linspace(-L / 2 + L / (2 * N), L / 2 - L / (2 * N), N)\n        u_grid, v_grid = np.meshgrid(u_coords, v_coords)\n        uv_pairs = np.stack([u_grid.ravel(), v_grid.ravel()], axis=-1)\n\n        surface_points = []\n        surface_normals = []\n        tangent_vecs_on_surface = []\n        in_face_vecs_sq_norm = np.sum(uv_pairs**2, axis=1)\n\n        for i, center in enumerate(face_centers):\n            normal = center / np.linalg.norm(center)\n            \n            # Map uv_pairs to 3D points on the face\n            u_ax = t_vectors[i]\n            v_ax = np.cross(normal, u_ax)\n            \n            points_on_face = center + uv_pairs[:, 0, None] * u_ax + uv_pairs[:, 1, None] * v_ax\n            surface_points.append(points_on_face)\n            surface_normals.extend([normal] * (N * N))\n            tangent_vecs_on_surface.extend([u_ax] * (N * N))\n        \n        r_primes = np.concatenate(surface_points)\n        n_hats = np.array(surface_normals)\n        t_faces = np.array(tangent_vecs_on_surface)\n        u_face_sq_norms = np.tile(in_face_vecs_sq_norm, 6)\n\n        # 2. Synthesize fields and currents (Reference, Naive, Projected)\n        \n        # Reference fields (purely tangential)\n        gauss_factor = E0 * np.exp(-u_face_sq_norms / sigma**2)\n        E_t = t_faces * gauss_factor[:, np.newaxis]\n        H_t = (1/eta) * np.cross(n_hats, E_t)\n\n        M_ref = -np.cross(n_hats, E_t)\n        J_ref = np.cross(n_hats, H_t)\n\n        # Measured fields (with noise) and perturbed normals\n        noise_E = np.random.randn(len(r_primes))\n        noise_H = np.random.randn(len(r_primes))\n        E_meas = E_t + n_hats * (alpha_E * E0 * noise_E)[:, np.newaxis]\n        H_meas = H_t + n_hats * (alpha_H * (E0/eta) * noise_H)[:, np.newaxis]\n        \n        rot_axis = np.array([0, 1, 0])\n        angle_rad = np.deg2rad(angle_deg)\n        n_tildes = np.array([\n            v * np.cos(angle_rad) + np.cross(rot_axis, v) * np.sin(angle_rad) + \n            rot_axis * np.dot(rot_axis, v) * (1 - np.cos(angle_rad))\n            for v in n_hats\n        ])\n        \n        # Naive currents\n        M_naive = -np.cross(n_tildes, E_meas)\n        J_naive = np.cross(n_tildes, H_meas)\n        \n        # Projected fields and currents\n        E_proj = E_meas - np.sum(E_meas * n_hats, axis=1)[:, np.newaxis] * n_hats\n        H_proj = H_meas - np.sum(H_meas * n_hats, axis=1)[:, np.newaxis] * n_hats\n        M_proj = -np.cross(n_hats, E_proj)\n        J_proj = np.cross(n_hats, H_proj)\n\n        # 3. Calculate far fields for each case\n        \n        def calculate_far_field(J_s, M_s):\n            phase_matrix = np.exp(1j * k * (r_hats @ r_primes.T))\n            \n            # Using (M, P) @ (P, 3) -> (M, 3) for vectorized calculation\n            N_vecs = phase_matrix @ (J_s * ds)\n            L_vecs = phase_matrix @ (M_s * ds)\n            \n            r_hats_x_L = np.cross(r_hats, L_vecs)\n            r_hats_x_N = np.cross(r_hats, N_vecs)\n            r_hats_x_r_hats_x_N = np.cross(r_hats, r_hats_x_N)\n\n            E_vec = -eta * r_hats_x_r_hats_x_N - r_hats_x_L\n            return E_vec\n\n        E_ff_ref = calculate_far_field(J_ref, M_ref)\n        E_ff_naive = calculate_far_field(J_naive, M_naive)\n        E_ff_proj = calculate_far_field(J_proj, M_proj)\n\n        # 4. Compute errors and improvement factor\n        \n        norm_ref_sq = np.sum(np.abs(E_ff_ref)**2)\n        \n        diff_naive_sq = np.sum(np.abs(E_ff_naive - E_ff_ref)**2)\n        diff_proj_sq = np.sum(np.abs(E_ff_proj - E_ff_ref)**2)\n\n        eps_naive = np.sqrt(diff_naive_sq / norm_ref_sq) if norm_ref_sq > 0 else 0\n        eps_proj = np.sqrt(diff_proj_sq / norm_ref_sq) if norm_ref_sq > 0 else 0\n\n        if eps_proj  1e-15: # If projected error is numerically zero\n            rho = np.inf if eps_naive > 1e-15 else 1.0\n        else:\n            rho = eps_naive / eps_proj\n            \n        results.append(rho)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了最大化计算效率，近场到远场积分面通常被放置在仿真区域的吸收边界——完美匹配层（PML）内部。这带来了挑战，因为PML内部的场在解析上是扭曲的。本练习将指导您推导并实现一种基于PML复坐标伸展的校正方法，即使从这个非物理区域采样，也能实现准确的远场预测。",
            "id": "3317929",
            "problem": "实现、论证并评估一个在自由空间中的二维标量横磁极化（TM$^z$）基准问题的近场-远场变换，其中可用的近场数据采样于一个可能任意靠近或位于完美匹配层（PML）内部的圆形轮廓上。您的实现必须基于标量亥姆霍兹公式和等效原理，并且必须包含一个从逆向拉伸映射导出的校正。您必须在一个线源（二维赫兹偶极子）基准问题上，计算并比较使用和不使用所提出的校正方法所获得的远场。\n\n从以下基本理论出发：\n\n- 频域中的麦克斯韦方程组表明，对于TM$^z$极化，在一个均匀、各向同性的无源区域中，平面外电场$E_z(\\mathbf{r})$满足标量亥姆霍兹方程$\\nabla^2 E_z(\\mathbf{r}) + k^2 E_z(\\mathbf{r}) = 0$，其中$k = \\omega \\sqrt{\\mu_0 \\epsilon_0}$是自由空间波数。\n- 自由空间中二维标量亥姆霍兹方程的格林函数是$G(\\mathbf{r},\\mathbf{r}') = \\dfrac{\\mathrm{j}}{4} H_0^{(1)}\\!\\left(k \\left\\lVert \\mathbf{r} - \\mathbf{r}' \\right\\rVert \\right)$，其中$H_0^{(1)}(\\cdot)$是第一类零阶汉克尔函数。\n- 对于一个包围源的封闭轮廓$\\Gamma$外的观察点$\\mathbf{r}$，其场可以通过一个边界积分来表示。该积分涉及轮廓$\\Gamma$上的$E_z$及其外法向导数$\\partial E_z/\\partial n'$，以及格林函数$G$及其相对于$\\mathbf{r}' \\in \\Gamma$的外法向导数。在您的设计中，不要假定任何快捷公式；您必须从这些基础出发，推导并实现相应的法向导数和度量。\n\n按如下方式定义基准问题和数据模型：\n\n- 一个位于原点的二维线源产生解析的自由空间场$E_z^{\\mathrm{free}}(\\mathbf{r}) = H_0^{(1)}\\!\\left(k \\left\\lVert \\mathbf{r} \\right\\rVert \\right)$及其径向导数$\\dfrac{\\partial E_z^{\\mathrm{free}}}{\\partial r}(\\mathbf{r}) = -k\\, H_1^{(1)}\\!\\left(k \\left\\lVert \\mathbf{r} \\right\\rVert \\right)$，其中$H_1^{(1)}(\\cdot)$是第一类一阶汉克尔函数，$r = \\left\\lVert \\mathbf{r} \\right\\rVert$。\n- 一个内径为$R_0$、厚度为$L$的径向PML通过沿径向的复坐标拉伸来建模：\n  $$ s_r(r) = \\begin{cases}\n  1,  r  R_0,\\\\\n  1 + \\mathrm{j}\\,\\alpha \\left(\\dfrac{r - R_0}{L}\\right)^m,  R_0 \\le r \\le R_0 + L,\\\\\n  1 + \\mathrm{j}\\,\\alpha,  r > R_0 + L,\n  \\end{cases}\n  $$\n  以及相关的复拉伸径向坐标\n  $$ \\tilde{r}(r) = \\begin{cases}\n  r,  r  R_0,\\\\\n  R_0 + \\displaystyle\\int_{R_0}^{r} s_r(\\rho)\\, \\mathrm{d}\\rho,  r \\ge R_0,\n  \\end{cases}\n  $$\n  因此，在PML环形区域内，解析模拟的“记录”场为$E_z^{\\mathrm{rec}}(r) = H_0^{(1)}\\!\\left(k\\,\\tilde{r}(r)\\right)$，根据链式法则，其相对于物理半径的外法向导数为$\\dfrac{\\partial E_z^{\\mathrm{rec}}}{\\partial r}(r) = -k\\,H_1^{(1)}\\!\\left(k\\,\\tilde{r}(r)\\right)\\, s_r(r)$。\n- 近场数据在一个以原点为中心、半径为$R_c$的圆形轮廓$\\Gamma$上采样，其单位外法向量为$\\hat{\\mathbf{n}}'(\\theta)$，线元为$\\mathrm{d}\\ell' = R_c\\,\\mathrm{d}\\theta$，由极角$\\theta \\in [0, 2\\pi)$参数化。\n\n提出并实现以下逆向拉伸校正：\n\n- 直接使用记录场$E_z^{\\mathrm{rec}}$作为场数据，但通过逆度量因子校正外法向导数，\n  $$ \\left(\\dfrac{\\partial E_z}{\\partial n'}\\right)_{\\mathrm{corr}} = \\dfrac{1}{s_r(R_c)} \\left(\\dfrac{\\partial E_z^{\\mathrm{rec}}}{\\partial n'}\\right), $$\n  这对应于在复坐标拉伸变换下对法向导数的拉回操作。对于纯径向拉伸，在圆形轮廓上的线元缩放保持不变，即$\\mathrm{d}\\ell'_{\\mathrm{corr}} = \\mathrm{d}\\ell'$。\n- 使用边界积分两次计算观测半径为$R_{\\mathrm{obs}}$的圆上的远场：一次使用未校正数据$(E_z^{\\mathrm{rec}},\\, \\partial E_z^{\\mathrm{rec}}/\\partial n')$，一次使用校正后数据$(E_z^{\\mathrm{rec}},\\, (\\partial E_z/\\partial n')_{\\mathrm{corr}})$。\n\n数值规格：\n\n- 使用真空光速$c_0 = \\dfrac{1}{\\sqrt{\\mu_0 \\epsilon_0}}$，其中$\\mu_0 = 4\\pi \\times 10^{-7}\\,\\text{H/m}$，$\\epsilon_0 = 8.854187817 \\times 10^{-12}\\,\\text{F/m}$。工作频率为$f = 3.0 \\times 10^{8}\\,\\text{Hz}$，因此$\\omega = 2\\pi f$且$k = \\dfrac{\\omega}{c_0}$。距离单位为米，角度单位为弧度。\n- 使用PML参数$\\alpha = 2.0$和$m = 2$，内径$R_0 = 1.0\\,\\text{m}$，厚度$L = 0.5\\,\\text{m}$。\n- 使用观测圆半径$R_{\\mathrm{obs}} = 5.0\\,\\text{m}$。在$\\phi \\in [0, 2\\pi)$的均匀角度网格上评估远场。\n\n测试套件：\n\n对于以下四个轮廓半径$R_c$中的每一个，分别计算未校正和校正情况下，观测圆上数值重构场与解析自由空间场$E_z^{\\mathrm{free}}$之间的相对均方根误差。然后报告改善因子，定义为校正后误差与未校正误差之比（小于$1$的数值表示有改善）：\n\n- 情况1：$R_c = 0.95\\,\\text{m}$（刚好在物理区域内部）。\n- 情况2：$R_c = 1.00\\,\\text{m}$（在PML交界面上）。\n- 情况3：$R_c = 1.10\\,\\text{m}$（浅层PML内部）。\n- 情况4：$R_c = 1.40\\,\\text{m}$（深层PML内部）。\n\n算法约束：\n\n- 使用$\\theta$的均匀参数化来离散化轮廓积分。您必须根据格林函数的定义以及应用于$H_0^{(1)}(\\cdot)$的链式法则来计算所需的外法向导数。\n- 每种情况的最终结果是一个浮点数：定义为$\\mathrm{err}_{\\mathrm{corr}} / \\mathrm{err}_{\\mathrm{uncorr}}$的改善因子，其中每个误差是差值的平方幅值对角度的平均值与解析场平方幅值对角度的平均值之比的平方根。\n\n要求的最终输出格式：\n\n- 您的程序必须生成单行输出，其中包含一个Python风格的列表，按情况1到4的顺序列出四个改善因子，每个元素以十进制数打印。例如，输出格式必须与$[x_1,x_2,x_3,x_4]$完全一样（没有空格）。\n\n角度单位：弧度。所有距离必须以米为单位。频率以赫兹为单位。场值为无量纲的复振幅，已根据上述采用的解析格林函数约定进行归一化。输出必须是改善因子，为通过默认Python字符串转换四舍五入的无量纲实数。",
            "solution": "该问题要求实现和评估一个二维标量横磁（TM$^z$）波问题的近场-远场（NFTF）变换。该变换必须能处理在可能位于完美匹配层（PML）内的圆形轮廓$\\Gamma$上采样的近场数据。该解决方案基于从格林第二恒等式导出的标量基尔霍夫-亥姆霍兹边界积分，并整合了一种针对PML干涉的校正方法。\n\n**1. 理论基础：边界积分方程**\n\n对于无源、均匀、各向同性区域中的TM$^z$波，其平面外电场分量$E_z(\\mathbf{r})$满足标量亥姆霍兹方程：\n$$\n\\nabla^2 E_z(\\mathbf{r}) + k^2 E_z(\\mathbf{r}) = 0\n$$\n其中，$k = \\omega/c_0$是自由空间波数，$\\omega = 2\\pi f$是角频率，$c_0$是真空中的光速。\n\n位于包含所有源的封闭区域$\\Omega$之外的观察点$\\mathbf{r}$处的场$E_z(\\mathbf{r})$，可以从其边界轮廓$\\Gamma = \\partial\\Omega$上的场值重构。这由基尔霍夫-亥姆霍兹边界积分公式给出：\n$$\nE_z(\\mathbf{r}) = \\oint_{\\Gamma} \\left[ E_z(\\mathbf{r}') \\frac{\\partial G(\\mathbf{r}, \\mathbf{r}')}{\\partial n'} - G(\\mathbf{r}, \\mathbf{r}') \\frac{\\partial E_z(\\mathbf{r}')}{\\partial n'} \\right] \\, \\mathrm{d}\\ell'\n$$\n这里，$\\mathbf{r}' \\in \\Gamma$是积分轮廓上的源点，$\\hat{\\mathbf{n}}'$是$\\Gamma$在$\\mathbf{r}'$处的单位外法向量，$\\partial/\\partial n' = \\hat{\\mathbf{n}}' \\cdot \\nabla'$表示相对于源坐标的外法向导数，$\\mathrm{d}\\ell'$是微分弧长元。\n\n函数$G(\\mathbf{r}, \\mathbf{r}')$是二维亥姆霍兹方程的自由空间格林函数，它代表了来自单位强度线源的场：\n$$\nG(\\mathbf{r}, \\mathbf{r}') = \\frac{\\mathrm{j}}{4} H_0^{(1)}\\!\\left(k \\left\\lVert \\mathbf{r} - \\mathbf{r}' \\right\\rVert \\right)\n$$\n其中$\\mathrm{j} = \\sqrt{-1}$是虚数单位，$H_0^{(1)}$是第一类零阶汉克尔函数。\n\n**2. 被积项的推导**\n\n为了实现该积分，我们必须推导格林函数法向导数$\\partial G/\\partial n'$的显式表达式。使用链式法则，我们有：\n$$\n\\frac{\\partial G(\\mathbf{r}, \\mathbf{r}')}{\\partial n'} = \\nabla' G(\\mathbf{r}, \\mathbf{r}') \\cdot \\hat{\\mathbf{n}}'\n$$\n令$u = \\left\\lVert \\mathbf{r} - \\mathbf{r}' \\right\\rVert$。$G$相对于$\\mathbf{r}'$的梯度是：\n$$\n\\nabla' G = \\frac{\\mathrm{d}G}{\\mathrm{d}u} \\nabla' u = \\left( \\frac{\\mathrm{j}}{4} \\frac{\\mathrm{d}}{\\mathrm{d}u} H_0^{(1)}(ku) \\right) \\left( \\frac{-(\\mathbf{r} - \\mathbf{r}')}{u} \\right)\n$$\n使用恒等式$\\frac{\\mathrm{d}}{\\mathrm{d}z} H_0^{(1)}(z) = -H_1^{(1)}(z)$，其中$H_1^{(1)}$是第一类一阶汉克尔函数，我们得到：\n$$\n\\nabla' G = \\left( \\frac{\\mathrm{j}}{4} \\left(-k H_1^{(1)}(ku)\\right) \\right) \\left( \\frac{-(\\mathbf{r} - \\mathbf{r}')}{u} \\right) = \\frac{\\mathrm{j}k}{4u} H_1^{(1)}(ku) (\\mathbf{r} - \\mathbf{r}')\n$$\n因此，法向导数为：\n$$\n\\frac{\\partial G(\\mathbf{r}, \\mathbf{r}')}{\\partial n'} = \\frac{\\mathrm{j}k}{4 \\left\\lVert \\mathbf{r} - \\mathbf{r}' \\right\\rVert} H_1^{(1)}\\!\\left(k \\left\\lVert \\mathbf{r} - \\mathbf{r}' \\right\\rVert\\right) (\\mathbf{r} - \\mathbf{r}') \\cdot \\hat{\\mathbf{n}}'\n$$\n\n**3. 特定问题的公式**\n\n该问题定义了一个柱对称的设置。积分轮廓$\\Gamma$是一个半径为$R_c$的圆，参数化为$\\mathbf{r}'(\\theta) = (R_c \\cos\\theta, R_c \\sin\\theta)$，其中$\\theta \\in [0, 2\\pi)$。外法向量为$\\hat{\\mathbf{n}}' = (\\cos\\theta, \\sin\\theta)$，即径向单位向量$\\hat{\\mathbf{r}}'$。线元为$\\mathrm{d}\\ell' = R_c \\, \\mathrm{d}\\theta$。观察点位于半径为$R_{\\mathrm{obs}}$的圆上，参数化为$\\mathbf{r}(\\phi) = (R_{\\mathrm{obs}} \\cos\\phi, R_{\\mathrm{obs}} \\sin\\phi)$。\n\n由于源和几何形状的柱对称性，重构的场$E_z(\\mathbf{r})$将与观察角$\\phi$无关。因此，我们可以通过对$\\theta \\in [0, 2\\pi)$积分来计算单个点（例如$\\mathbf{r}_{\\mathrm{obs}} = (R_{\\mathrm{obs}}, 0)$）的场。对于此设置：\n- $\\left\\lVert \\mathbf{r}_{\\mathrm{obs}} - \\mathbf{r}'(\\theta) \\right\\rVert = \\sqrt{(R_{\\mathrm{obs}} - R_c \\cos\\theta)^2 + (-R_c \\sin\\theta)^2} = \\sqrt{R_{\\mathrm{obs}}^2 - 2R_{\\mathrm{obs}}R_c\\cos\\theta + R_c^2}$。\n- $(\\mathbf{r}_{\\mathrm{obs}} - \\mathbf{r}'(\\theta)) \\cdot \\hat{\\mathbf{n}}'(\\theta) = (R_{\\mathrm{obs}}\\hat{\\mathbf{x}} - R_c\\hat{\\mathbf{r}}') \\cdot \\hat{\\mathbf{r}}' = R_{\\mathrm{obs}}(\\hat{\\mathbf{x}} \\cdot \\hat{\\mathbf{r}}') - R_c(\\hat{\\mathbf{r}}' \\cdot \\hat{\\mathbf{r}}') = R_{\\mathrm{obs}}\\cos\\theta - R_c$。\n\n**4. PML模型和近场数据**\n\n近场数据并非来自纯自由空间仿真，而是来自一个被径向PML截断的区域。PML通过径向坐标$r$的复坐标拉伸因子$s_r(r)$来建模。对于PML内部的半径$r$（$R_0 \\le r \\le R_0+L$），该因子为$s_r(r) = 1 + \\mathrm{j}\\,\\alpha \\left(\\frac{r - R_0}{L}\\right)^m$，其中$m=2$。这导致了一个复拉伸径向坐标$\\tilde{r}(r) = R_0 + \\int_{R_0}^r s_r(\\rho)\\,\\mathrm{d}\\rho$，适用于$r \\ge R_0$。当$m=2$时计算该积分得到：\n$$\n\\tilde{r}(r) = R_0 + (r-R_0) + \\frac{\\mathrm{j}\\alpha}{3L^2}(r-R_0)^3 \\quad \\text{for } R_0 \\le r \\le R_0+L\n$$\n对于$r  R_0$，$s_r(r)=1$且$\\tilde{r}(r)=r$。\n\n在半径为$R_c$的轮廓$\\Gamma$上的“记录”场是通过将$\\tilde{r}(R_c)$代入线源的解析解得到的：\n- $E_z^{\\mathrm{rec}}(R_c) = H_0^{(1)}\\!\\left(k\\,\\tilde{r}(R_c)\\right)$。\n- 法向（径向）导数通过链式法则获得：$\\dfrac{\\partial E_z^{\\mathrm{rec}}}{\\partial n'}(R_c) = \\dfrac{\\mathrm{d}}{\\mathrm{d}r} H_0^{(1)}(k\\tilde{r}(r))\\big|_{r=R_c} = -k H_1^{(1)}(k\\tilde{r}(R_c)) \\frac{\\mathrm{d}\\tilde{r}}{\\mathrm{d}r}\\big|_{r=R_c} = -k H_1^{(1)}(k\\tilde{r}(R_c)) s_r(R_c)$。\n\n**5. 未校正与校正变换**\n\nNFTF积分假定场为自由空间场。直接使用受PML影响的场是“未校正”方法。\n- **未校正数据**：\n  - $E_z^{\\mathrm{uncorr}} = E_z^{\\mathrm{rec}}(R_c)$\n  - $\\left(\\dfrac{\\partial E_z}{\\partial n'}\\right)_{\\mathrm{uncorr}} = \\dfrac{\\partial E_z^{\\mathrm{rec}}}{\\partial n'}(R_c)$\n\nPML从根本上改变了场的行为。所提出的校正旨在通过除以复拉伸因子（即坐标变换的度量分量）来逆转这种对法向导数的影响。这是一个拉回操作，试图恢复一个更能代表自由空间传播的导数。\n- **校正后数据**：\n  - $E_z^{\\mathrm{corr}} = E_z^{\\mathrm{rec}}(R_c)$（场值本身未被校正）\n  - $\\left(\\dfrac{\\partial E_z}{\\partial n'}\\right)_{\\mathrm{corr}} = \\dfrac{1}{s_r(R_c)} \\left(\\dfrac{\\partial E_z^{\\mathrm{rec}}}{\\partial n'}\\right) = -k H_1^{(1)}(k\\tilde{r}(R_c))$\n\n**6. 数值实现与评估**\n\n边界积分使用简单的求积法则（在$\\theta$的均匀网格上使用梯形或中点法则）进行数值计算。对于$N_p$个离散点$\\theta_i = 2\\pi i/N_p$，在$\\mathbf{r}_{\\mathrm{obs}}$处的场积分变成一个求和：\n$$\nE_z^{\\mathrm{num}} \\approx \\sum_{i=0}^{N_p-1} \\left[ E_z^{\\mathrm{data}} \\frac{\\partial G(\\mathbf{r}_{\\mathrm{obs}}, \\mathbf{r}'_i)}{\\partial n'} - G(\\mathbf{r}_{\\mathrm{obs}}, \\mathbf{r}'_i) \\left(\\frac{\\partial E_z}{\\partial n'}\\right)_{\\mathrm{data}} \\right] R_c \\Delta\\theta\n$$\n其中$\\mathbf{r}'_i = \\mathbf{r}'(\\theta_i)$且$\\Delta\\theta=2\\pi/N_p$。项$E_z^{\\mathrm{data}}$和$(\\partial E_z/\\partial n')_{\\mathrm{data}}$相对于$\\theta$是常数，取自未校正或校正数据集。\n\n重构的准确性通过将数值结果$E_z^{\\mathrm{num}}$与观测半径处已知的解析自由空间场$E_z^{\\mathrm{anal}} = H_0^{(1)}(k R_{\\mathrm{obs}})$进行比较来评估。相对均方根误差定义为：\n$$\n\\mathrm{err} = \\sqrt{\\frac{\\int_0^{2\\pi} |E_z^{\\mathrm{num}}(\\phi) - E_z^{\\mathrm{anal}}(\\phi)|^2 \\, \\mathrm{d}\\phi}{\\int_0^{2\\pi} |E_z^{\\mathrm{anal}}(\\phi)|^2 \\, \\mathrm{d}\\phi}}\n$$\n由于对称性，数值场和解析场都相对于观察角$\\phi$是常数，因此上式简化为：\n$$\n\\mathrm{err} = \\frac{|E_z^{\\mathrm{num}} - E_z^{\\mathrm{anal}}|}{|E_z^{\\mathrm{anal}}|}\n$$\n改善因子是校正后误差与未校正误差之比：$I = \\mathrm{err}_{\\mathrm{corr}} / \\mathrm{err}_{\\mathrm{uncorr}}$。值$I  1$表示校正提高了准确性。对于轮廓在自由空间内的情况（$R_c  R_0$），我们有$s_r(R_c)=1$，所以校正后和未校正的数据是相同的。这意味着$\\mathrm{err}_{\\mathrm{corr}} = \\mathrm{err}_{\\mathrm{uncorr}}$，改善因子必须为$1$。这可作为实现正确性的验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import hankel1\n\ndef solve():\n    \"\"\"\n    Implements and assesses a near-to-far-field transformation for a 2D TMz\n    problem with near-field data sampled from within a PML.\n    \"\"\"\n\n    # --- 1. Define Constants and Parameters ---\n    # Physical constants\n    mu0 = 4 * np.pi * 1e-7  # H/m\n    eps0 = 8.854187817e-12 # F/m\n    c0 = 1 / np.sqrt(mu0 * eps0) # m/s\n\n    # Wave parameters\n    f = 3.0e8  # Hz\n    omega = 2 * np.pi * f # rad/s\n    k = omega / c0 # rad/m\n\n    # PML parameters\n    alpha = 2.0\n    m = 2.0\n    R0 = 1.0  # m\n    L = 0.5   # m\n\n    # Geometry\n    Robs = 5.0 # m\n    \n    # Numerical integration points\n    Np = 2000\n\n    # Test cases\n    test_cases = [0.95, 1.00, 1.10, 1.40]\n\n    # --- 2. Helper Functions ---\n    def s_r(r, R0, L, alpha, m):\n        \"\"\"Calculates the complex stretching factor s_r(r).\"\"\"\n        if r  R0:\n            return 1.0 + 0.0j\n        elif R0 = r = R0 + L:\n            return 1.0 + 1j * alpha * ((r - R0) / L)**m\n        else: # r > R0 + L\n            return 1.0 + 1j * alpha\n\n    def tilde_r(r, R0, L, alpha, m):\n        \"\"\"Calculates the complex-stretched radial coordinate tilde_r(r).\"\"\"\n        if r  R0:\n            return r + 0.0j\n        \n        m_float = float(m)\n        integral_part = (r - R0) + (1j * alpha / (L**m_float * (m_float + 1))) * (r - R0)**(m_float + 1)\n        \n        if R0 = r = R0 + L:\n            return R0 + integral_part\n        else: # r > R0 + L. Not needed for this problem's test cases, but for completeness:\n            # Integral from R0 to R0+L\n            int_pml_layer = L + (1j * alpha * L) / (m_float + 1)\n            # Integral from R0+L to r\n            int_outer = (1 + 1j * alpha) * (r - (R0 + L))\n            return R0 + int_pml_layer + int_outer\n\n    def compute_far_field(Rc, Robs, k, Ez_data, dEz_dn_data, Np):\n        \"\"\"\n        Computes the far field at a single observation point (Robs, 0)\n        using the boundary integral equation.\n        \"\"\"\n        d_theta = 2 * np.pi / Np\n        integral_sum = 0.0 + 0.0j\n\n        for i in range(Np):\n            theta = i * d_theta\n            \n            # Distance from source point on contour to observation point\n            u = np.sqrt(Robs**2 - 2 * Robs * Rc * np.cos(theta) + Rc**2)\n            \n            # (r_obs - r') dot n'\n            dot_product = Robs * np.cos(theta) - Rc\n            \n            # Green's function and its normal derivative\n            G = (1j / 4) * hankel1(0, k * u)\n            dG_dn = (1j * k / (4 * u)) * hankel1(1, k * u) * dot_product\n            \n            # Integrand for this point\n            integrand = (Ez_data * dG_dn - G * dEz_dn_data)\n            \n            # Add contribution to sum (d_ell = Rc * d_theta)\n            integral_sum += integrand * Rc * d_theta\n            \n        return integral_sum\n\n    # --- 3. Main Calculation Loop ---\n    results = []\n    \n    # Analytic field at observation circle for error comparison\n    Ez_anal = hankel1(0, k * Robs)\n    abs_Ez_anal = np.abs(Ez_anal)\n\n    for Rc in test_cases:\n        # Calculate near-field \"recorded\" data on contour of radius Rc\n        sr_Rc = s_r(Rc, R0, L, alpha, m)\n        tr_Rc = tilde_r(Rc, R0, L, alpha, m)\n        \n        Ez_rec = hankel1(0, k * tr_Rc)\n        dEz_rec_dn = -k * sr_Rc * hankel1(1, k * tr_Rc) # Chain rule derivative\n        \n        # --- Uncorrected case ---\n        dEz_uncorr_dn = dEz_rec_dn\n        Ez_uncorr = compute_far_field(Rc, Robs, k, Ez_rec, dEz_uncorr_dn, Np)\n        err_uncorr = np.abs(Ez_uncorr - Ez_anal) / abs_Ez_anal\n\n        # --- Corrected case ---\n        dEz_corr_dn = dEz_rec_dn / sr_Rc\n        Ez_corr = compute_far_field(Rc, Robs, k, Ez_rec, dEz_corr_dn, Np)\n        err_corr = np.abs(Ez_corr - Ez_anal) / abs_Ez_anal\n        \n        # Calculate improvement factor\n        # Handle potential division by zero if uncorrected error is near zero\n        if err_uncorr  1e-15:\n             improvement = 1.0 if err_corr  1e-15 else float('inf')\n        else:\n             improvement = err_corr / err_uncorr\n        \n        results.append(improvement)\n\n    # --- 4. Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}