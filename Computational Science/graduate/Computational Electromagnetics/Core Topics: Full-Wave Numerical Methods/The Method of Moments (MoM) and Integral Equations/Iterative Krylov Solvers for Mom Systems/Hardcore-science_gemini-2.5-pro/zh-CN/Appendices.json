{
    "hands_on_practices": [
        {
            "introduction": "迭代求解器并不直接计算解的误差，而是计算残差，这是一个我们可以轻松获取的量。本练习探讨了可计算的残差与我们真正关心的解的精度之间的关键关系。理解这种由系统条件数调节的联系，是为任何迭代方法设定有意义的收敛准则的基础。",
            "id": "3321315",
            "problem": "考虑一个通过矩量法 (MoM) 离散化的理想电导体 (PEC) 散射体的电场积分方程 (EFIE)。使用 Rao-Wilton-Glisson (RWG) 基函数和伽辽金测试，该离散化产生一个复数域上的线性系统 $A x = b$，其中 $A \\in \\mathbb{C}^{n \\times n}$ 是稠密的矩量法系统矩阵，$x \\in \\mathbb{C}^{n}$ 包含表面电流密度的展开系数，$b \\in \\mathbb{C}^{n}$ 是由入射场构成的激励向量。采用诸如广义最小残差法 (GMRES) 之类的迭代克里洛夫方法来计算近似解 $x_{k}$，其残差为 $r_{k} = b - A x_{k}$，停止准则基于相对残差 $\\|r_{k}\\|_{2}/\\|b\\|_{2} \\leq \\tau$。\n\n从第一性原理出发——即定义 $r_{k} = b - A x_{k}$、$e_{k} = x - x_{k}$、$x = A^{-1} b$ 和 2-范数条件数 $\\kappa_{2}(A) = \\|A\\|_{2} \\|A^{-1}\\|_{2}$——推导一个关于相对残差的保守容差 $\\tau$，以保证表面电流的相对误差满足一个给定的上界，$\\|x - x_{k}\\|_{2} / \\|x\\|_{2} \\leq \\delta$。然后，在 $\\kappa_{2}(A) = 350$ 和 $\\delta = 5 \\times 10^{-3}$ 的情况下计算该容差。\n\n将最终容差表示为一个无量纲数，并将答案四舍五入到三位有效数字。",
            "solution": "目标是为相对残差 $\\|r_{k}\\|_{2}/\\|b\\|_{2} \\le \\tau$ 推导出一个容差 $\\tau$，以保证表面电流的相对误差 $\\|e_{k}\\|_{2}/\\|x\\|_{2} \\le \\delta$ 不超过一个预设值 $\\delta$。推导将从所提供的基本定义开始。\n\n关键量定义如下：\n1.  线性系统：$A x = b$，其中 $x = A^{-1} b$ 是精确解。\n2.  第 $k$ 次迭代的误差：$e_{k} = x - x_{k}$。\n3.  第 $k$ 次迭代的残差：$r_{k} = b - A x_{k}$。\n\n我们的第一步是建立误差向量 $e_{k}$ 和残差向量 $r_{k}$ 之间的直接关系。我们将表达式 $b = A x$ 代入残差的定义中：\n$$r_{k} = A x - A x_{k}$$\n根据矩阵乘法的分配律，我们可以提出矩阵 $A$：\n$$r_{k} = A (x - x_{k})$$\n根据误差向量 $e_{k}$ 的定义，我们有：\n$$r_{k} = A e_{k}$$\n假设矩阵 $A$ 是可逆的（这是存在唯一解 $x$ 的必要条件），我们可以通过乘以 $A$ 的逆矩阵，将误差向量表示为残差向量的函数：\n$$e_{k} = A^{-1} r_{k}$$\n这个方程将迭代过程中的未知量——误差，与可计算量——残差联系起来。\n\n接下来，我们转向向量范数来建立不等式。题目指定了欧几里得2-范数，记为 $\\|\\cdot\\|_{2}$。对等式 $e_{k} = A^{-1} r_{k}$ 两边取2-范数，并应用矩阵范数的次可乘性（即对于任意矩阵 $M$ 和向量 $v$ 都有 $\\|Mv\\|_{2} \\le \\|M\\|_{2}\\|v\\|_{2}$），我们得到误差范数的一个上界：\n$$\\|e_{k}\\|_{2} = \\|A^{-1} r_{k}\\|_{2} \\le \\|A^{-1}\\|_{2} \\|r_{k}\\|_{2}$$\n\n目标是为相对误差 $\\|e_{k}\\|_{2} / \\|x\\|_{2}$ 定界。为此，我们需要精确解范数 $\\|x\\|_{2}$ 的一个下界。我们从原始系统方程 $A x = b$ 开始，并对两边取2-范数：\n$$\\|b\\|_{2} = \\|A x\\|_{2}$$\n应用同样的次可乘性质，我们得到：\n$$\\|b\\|_{2} \\le \\|A\\|_{2} \\|x\\|_{2}$$\n假设激励向量 $b$ 非零（对于任何非平凡散射问题，这都是成立的），我们可以除以 $\\|A\\|_{2}$ 来建立 $\\|x\\|_{2}$ 的一个下界：\n$$\\|x\\|_{2} \\ge \\frac{\\|b\\|_{2}}{\\|A\\|_{2}}$$\n对这个不等式取倒数会反转不等号的方向，从而为 $1/\\|x\\|_{2}$ 提供一个上界：\n$$\\frac{1}{\\|x\\|_{2}} \\le \\frac{\\|A\\|_{2}}{\\|b\\|_{2}}$$\n\n现在我们可以结合 $\\|e_{k}\\|_{2}$ 的上界和 $1/\\|x\\|_{2}$ 的上界，来构成相对误差的一个上界：\n$$\\frac{\\|e_{k}\\|_{2}}{\\|x\\|_{2}} = \\|e_{k}\\|_{2} \\cdot \\frac{1}{\\|x\\|_{2}} \\le \\left( \\|A^{-1}\\|_{2} \\|r_{k}\\|_{2} \\right) \\cdot \\left( \\frac{\\|A\\|_{2}}{\\|b\\|_{2}} \\right)$$\n重新排列右侧的项，得到：\n$$\\frac{\\|e_{k}\\|_{2}}{\\|x\\|_{2}} \\le \\left( \\|A\\|_{2} \\|A^{-1}\\|_{2} \\right) \\left( \\frac{\\|r_{k}\\|_{2}}{\\|b\\|_{2}} \\right)$$\n项 $\\|A\\|_{2} \\|A^{-1}\\|_{2}$ 是矩阵 $A$ 的2-范数条件数的定义，记为 $\\kappa_{2}(A)$。代入此定义，得到关联相对误差与相对残差的基本不等式：\n$$\\frac{\\|e_{k}\\|_{2}}{\\|x\\|_{2}} \\le \\kappa_{2}(A) \\frac{\\|r_{k}\\|_{2}}{\\|b\\|_{2}}$$\n这个不等式表明，相对误差受相对残差的限制，并被系统矩阵的条件数所放大。这提供了一个最坏情况的估计。\n\n题目要求我们保证相对误差不大于一个指定值 $\\delta$：\n$$\\frac{\\|e_{k}\\|_{2}}{\\|x\\|_{2}} \\le \\delta$$\n迭代求解器的停止准则基于相对残差，$\\|r_{k}\\|_{2}/\\|b\\|_{2} \\le \\tau$。为了满足误差条件，我们必须设定容差 $\\tau$，使得相对误差的上界小于或等于 $\\delta$：\n$$\\kappa_{2}(A) \\frac{\\|r_{k}\\|_{2}}{\\|b\\|_{2}} \\le \\kappa_{2}(A) \\tau \\le \\delta$$\n为了求得所需的容差 $\\tau$，我们解关于 $\\tau$ 的不等式：\n$$\\kappa_{2}(A) \\tau \\le \\delta \\implies \\tau \\le \\frac{\\delta}{\\kappa_{2}(A)}$$\n一个保守的容差是能保证该条件成立的容差。能够提供此保证的 $\\tau$ 的最大可能值由等式给出：\n$$\\tau = \\frac{\\delta}{\\kappa_{2}(A)}$$\n任何更小的 $\\tau$ 值也能满足保证，但会不必要地严格，并可能导致比所需更多的迭代次数。\n\n最后，我们用给定的数值计算这个表达式：$\\kappa_{2}(A) = 350$ 和 $\\delta = 5 \\times 10^{-3}$。\n$$\\tau = \\frac{5 \\times 10^{-3}}{350}$$\n$$\\tau = \\frac{5}{350} \\times 10^{-3} = \\frac{1}{70} \\times 10^{-3}$$\n将分数 $1/70$ 转换为小数，我们有 $1/70 \\approx 0.0142857...$。\n$$\\tau \\approx 0.0142857 \\times 10^{-3} = 1.42857 \\times 10^{-5}$$\n题目要求将结果四舍五入到三位有效数字。\n$$\\tau \\approx 1.43 \\times 10^{-5}$$\n这就是所要求的关于相对残差的保守容差。",
            "answer": "$$\\boxed{1.43 \\times 10^{-5}}$$"
        },
        {
            "introduction": "随着电磁模型越来越精细（即网格加密），其对应的矩量法（MoM）系统矩阵的病态程度会随之恶化，导致标准迭代求解器的收敛速度急剧下降。本练习使用一个预测模型来量化这种性能退化，并展示一个精心设计的预条件子所带来的变革性影响。通过解决这个问题，您将具体地理解为什么预处理不仅是一种优化，更是解决大规模矩量法问题的必需品。",
            "id": "3321343",
            "problem": "考虑一个固定频率的电磁散射问题，该问题使用 Rao–Wilton–Glisson 基函数通过矩量法 (MoM) 进行离散化，得到一个线性系统 $A(h)\\,x=b$。其中，网格参数 $h$ 等于平均边长除以波长（无量纲）。假设以下经过经验验证的事实构成了推导的基础。\n\n- 在固定频率下（无低频缩放），电场积分方程 (EFIE) 矩阵 $A(h)$ 表现出密集离散化失效：其最小奇异值尺度约为 $O(h^{p_{\\alpha}})$，最大奇异值尺度约为 $O(h^{-p_{\\beta}})$，因此条件数 $\\kappa(h)$ 的尺度为 $O\\!\\left(h^{-(p_{\\alpha}+p_{\\beta})}\\right)$。EFIE 的一个常见情况是 $p_{\\alpha}=1$ 和 $p_{\\beta}=0$。\n- 广义最小残差 (GMRES) 方法在受 $p(0)=1$ 约束的多项式上最小化残差。当系数矩阵的值域或谱包含在正实轴上的一个实数区间 $[\\alpha,\\beta]$ 内时，切比雪夫多项式的极值性质可得出残差范数的最优多项式逼近界。\n- 一个准亥姆霍兹预条件子 $M$（例如，带有适当缩放的环-星分解或环-树分解）将系统转换为 $M^{-1}A(h)$，并抑制密集离散化失效，将谱聚集在正实轴上的一个与 $h$ 无关的区间 $[\\underline{\\alpha},\\overline{\\beta}]$ 内。因此，条件数基本上与 $h$ 无关。\n\n您的任务是预测当网格加密2倍（即 $h \\mapsto h/2$）时，在没有预处理和使用准亥姆霍兹预条件子两种情况下，GMRES 迭代次数如何变化。请使用纯数学术语进行计算，其中 $h$ 为无量纲。您必须在程序中实现以下建模假设。\n\n- 将未预处理的 $A(h)$ 的谱建模为包含在 $[\\alpha(h),\\beta(h)]$ 区间内，其中 $\\alpha(h)=c_{\\alpha}\\,h^{p_{\\alpha}}$ 且 $\\beta(h)=c_{\\beta}\\,h^{-p_{\\beta}}$，且 $c_{\\alpha}0$, $c_{\\beta}0$, $p_{\\alpha}\\ge 0$, $p_{\\beta}\\ge 0$。由此产生的条件数为 $\\kappa(h)=\\dfrac{\\beta(h)}{\\alpha(h)}=\\dfrac{c_{\\beta}}{c_{\\alpha}}\\,h^{-(p_{\\alpha}+p_{\\beta})}$。\n- 将预处理后的 $M^{-1}A(h)$ 的谱建模为 $[\\underline{\\alpha},\\overline{\\beta}]$，其中 $\\underline{\\alpha}0$ 和 $\\overline{\\beta}0$ 均与 $h$ 无关，从而得到一个与 $h$ 无关的条件数 $\\kappa_{p}=\\dfrac{\\overline{\\beta}}{\\underline{\\alpha}}$。\n- 使用正实数区间上的经典切比雪夫最优多项式残差界来作为 GMRES 残差衰减的上界。对于给定的容差 $\\varepsilon\\in(0,1)$ 和条件数 $\\kappa\\ge 1$，将预测迭代次数 $m(\\kappa,\\varepsilon)$ 定义为满足 $[\\alpha,\\beta]$ 上极小化极大值多项式的基于切比雪夫界的不等式的最小非负整数。使用从映射到 $[-1,1]$ 区间上的切比雪夫多项式的极值性质得出的标准闭式解来实现此定义。\n\n对于下面的每个测试用例，您必须计算当 $h$ 加密2倍时预测的 GMRES 迭代次数的变化，即未预处理情况下的 $\\Delta m_{\\mathrm{unprec}}=m(\\kappa(h/2),\\varepsilon)-m(\\kappa(h),\\varepsilon)$，以及预处理情况下的 $\\Delta m_{\\mathrm{prec}}=m(\\kappa_{p},\\varepsilon)-m(\\kappa_{p},\\varepsilon)$（如果 $\\kappa_{p}$ 严格与 $h$ 无关，则此值应为 $0$）。\n\n实现一个程序来评估以下测试套件。在每个测试用例中，所有参数都是无量纲的。网格加密总是以2倍为因子。\n\n- 测试用例1（理想情况，中等加密影响）：\n  - $h_{0}=0.1$, $c_{\\alpha}=0.8$, $p_{\\alpha}=1$, $c_{\\beta}=2.4$, $p_{\\beta}=0$, $\\underline{\\alpha}=0.5$, $\\overline{\\beta}=2.5$, $\\varepsilon=10^{-6}$。\n- 测试用例2（较粗的初始网格，影响较小）：\n  - $h_{0}=0.4$, $c_{\\alpha}=0.8$, $p_{\\alpha}=1$, $c_{\\beta}=2.4$, $p_{\\beta}=0$, $\\underline{\\alpha}=0.5$, $\\overline{\\beta}=2.5$, $\\varepsilon=10^{-6}$。\n- 测试用例3（紧容差边界情况）：\n  - $h_{0}=0.05$, $c_{\\alpha}=0.8$, $p_{\\alpha}=1$, $c_{\\beta}=2.4$, $p_{\\beta}=0$, $\\underline{\\alpha}=0.5$, $\\overline{\\beta}=2.5$, $\\varepsilon=10^{-12}$。\n- 测试用例4（变化的常数，宽松容差）：\n  - $h_{0}=0.08$, $c_{\\alpha}=0.6$, $p_{\\alpha}=1$, $c_{\\beta}=1.8$, $p_{\\beta}=0$, $\\underline{\\alpha}=0.7$, $\\overline{\\beta}=2.1$, $\\varepsilon=10^{-3}$。\n\n您的程序必须将结果聚合到单行中，并遵循以下确切格式：一个类似 Python 的列表的列表，其中每个内部列表对应一个测试用例，并按此顺序包含恰好两个整数 $[\\Delta m_{\\mathrm{unprec}}, \\Delta m_{\\mathrm{prec}}]$。例如，打印的行应类似于 $[[a,b],[c,d],\\dots]$，不含多余的空格或文本。\n\n由于 $h$ 已通过波长归一化，且所有量均为无量纲，因此不需要物理单位。所有角度（如果有）必须以弧度为单位，但此处未使用角度。所有最终数值答案必须为整数。",
            "solution": "## 问题验证\n\n### 步骤1：提取已知条件\n- **线性系统**：一个固定频率的电磁散射问题通过矩量法 (MoM) 离散化，得到一个线性系统 $A(h)\\,x=b$。\n- **网格参数**：$h$ 是经波长归一化的平均边长（无量纲）。\n- **未预处理矩阵的尺度特性**：$A(h)$ 的最小奇异值尺度为 $O(h^{p_{\\alpha}})$，最大奇异值尺度为 $O(h^{-p_{\\beta}})$。条件数 $\\kappa(h)$ 的尺度为 $O(h^{-(p_{\\alpha}+p_{\\beta})})$。\n- **EFIE 示例**：对于电场积分方程 (EFIE)，常见情况是 $p_{\\alpha}=1$ 和 $p_{\\beta}=0$。\n- **GMRES 方法**：使用广义最小残差 (GMRES) 方法。对于谱在正实数区间 $[\\alpha,\\beta]$ 内的矩阵，其收敛性由切比雪夫多项式界定。\n- **预条件子**：一个准亥姆霍兹预条件子 $M$ 将系统转换为 $M^{-1}A(h)$。预处理后矩阵的谱聚集在一个与 $h$ 无关的正实数区间 $[\\underline{\\alpha},\\overline{\\beta}]$ 内。\n- **未预处理谱模型**：$A(h)$ 的谱被建模为包含在 $[\\alpha(h),\\beta(h)]$ 内，其中 $\\alpha(h)=c_{\\alpha}\\,h^{p_{\\alpha}}$ 且 $\\beta(h)=c_{\\beta}\\,h^{-p_{\\beta}}$，且 $c_{\\alpha}0$, $c_{\\beta}0$, $p_{\\alpha}\\ge 0$, $p_{\\beta}\\ge 0$。\n- **未预处理条件数**：$\\kappa(h)=\\dfrac{\\beta(h)}{\\alpha(h)}=\\dfrac{c_{\\beta}}{c_{\\alpha}}\\,h^{-(p_{\\alpha}+p_{\\beta})}$。\n- **预处理谱模型**：$M^{-1}A(h)$ 的谱被建模为包含在 $[\\underline{\\alpha},\\overline{\\beta}]$ 内，其中 $\\underline{\\alpha}0$ 和 $\\overline{\\beta}0$ 与 $h$ 无关。\n- **预处理条件数**：$\\kappa_{p}=\\dfrac{\\overline{\\beta}}{\\underline{\\alpha}}$，与 $h$ 无关。\n- **迭代次数定义**：对于容差 $\\varepsilon\\in(0,1)$ 和条件数 $\\kappa\\ge 1$，预测的迭代次数 $m(\\kappa,\\varepsilon)$ 是满足基于切比雪夫界的不等式的最小非负整数。\n- **任务**：计算当网格加密2倍（$h \\mapsto h/2$）时，预测迭代次数的变化量 $\\Delta m_{\\mathrm{unprec}}=m(\\kappa(h/2),\\varepsilon)-m(\\kappa(h),\\varepsilon)$ 和 $\\Delta m_{\\mathrm{prec}}=m(\\kappa_{p},\\varepsilon)-m(\\kappa_{p},\\varepsilon)$。\n- **测试用例**：\n    - 用例1: $h_{0}=0.1$, $c_{\\alpha}=0.8$, $p_{\\alpha}=1$, $c_{\\beta}=2.4$, $p_{\\beta}=0$, $\\underline{\\alpha}=0.5$, $\\overline{\\beta}=2.5$, $\\varepsilon=10^{-6}$。\n    - 用例2: $h_{0}=0.4$, $c_{\\alpha}=0.8$, $p_{\\alpha}=1$, $c_{\\beta}=2.4$, $p_{\\beta}=0$, $\\underline{\\alpha}=0.5$, $\\overline{\\beta}=2.5$, $\\varepsilon=10^{-6}$。\n    - 用例3: $h_{0}=0.05$, $c_{\\alpha}=0.8$, $p_{\\alpha}=1$, $c_{\\beta}=2.4$, $p_{\\beta}=0$, $\\underline{\\alpha}=0.5$, $\\overline{\\beta}=2.5$, $\\varepsilon=10^{-12}$。\n    - 用例4: $h_{0}=0.08$, $c_{\\alpha}=0.6$, $p_{\\alpha}=1$, $c_{\\beta}=1.8$, $p_{\\beta}=0$, $\\underline{\\alpha}=0.7$, $\\overline{\\beta}=2.1$, $\\varepsilon=10^{-3}$。\n\n### 步骤2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估：\n- **科学依据**：问题陈述牢固地植根于计算电磁学和数值线性代数的原理。对矩量法 (MoM)、电场积分方程 (EFIE) 的密集离散化失效、准亥姆霍兹预条件子的行为、GMRES 算法及其通过切比雪夫多项式的收敛性分析的描述都是该领域中标准且成熟的概念。建模假设是这些现象的简化但物理和数学上一致的表示。\n- **良态**：问题定义精确。所有必要的参数和模型都已明确提供。任务是根据已定义的公式计算一个特定量，即迭代次数的变化。每个测试用例的输入是完整的，并且所需的输出格式是明确的。每个测试用例都存在唯一解。\n- **客观**：问题以正式、客观的语言陈述。没有主观评估、意见或非科学的主张。\n\n### 步驟3：結論與行動\n该问题科学合理、良态、客观且完整。因此，它被判定为 **有效**。将开发一个解决方案。\n\n## 解法\n\n目标是确定当网格参数 $h$ 加密2倍时，求解 MoM 线性系统 $A(h)x=b$ 所需的预测 GMRES 迭代次数的变化。我们分析原始（未预处理）系统和预处理系统。\n\n### GMRES 迭代次数模型\n对于谱包含在正实数区间 $[\\alpha, \\beta]$ 内的矩阵，GMRES 的收敛性可以用切比雪夫多项式来界定。$m$ 次迭代后相对残差范数的一个标准上界由下式给出：\n$$\n\\frac{\\|r_m\\|}{\\|r_0\\|} \\le 2 \\left( \\frac{\\sqrt{\\kappa} - 1}{\\sqrt{\\kappa} + 1} \\right)^m\n$$\n其中 $\\kappa = \\beta/\\alpha$ 是矩阵的条件数。\n\n我们的任务是找到预测的迭代次数 $m(\\kappa, \\varepsilon)$，定义为保证相对残差低于给定容差 $\\varepsilon \\in (0, 1)$ 的最小非负整数 $m$。因此，我们设置上界小于或等于 $\\varepsilon$：\n$$\n2 \\left( \\frac{\\sqrt{\\kappa} - 1}{\\sqrt{\\kappa} + 1} \\right)^m \\le \\varepsilon\n$$\n为求 $m$ 解此不等式。首先，分离出 $m$ 次幂的项：\n$$\n\\left( \\frac{\\sqrt{\\kappa} - 1}{\\sqrt{\\kappa} + 1} \\right)^m \\le \\frac{\\varepsilon}{2}\n$$\n对两边取自然对数：\n$$\nm \\ln\\left( \\frac{\\sqrt{\\kappa} - 1}{\\sqrt{\\kappa} + 1} \\right) \\le \\ln\\left( \\frac{\\varepsilon}{2} \\right)\n$$\n由于 $\\kappa \\ge 1$，项 $\\frac{\\sqrt{\\kappa} - 1}{\\sqrt{\\kappa} + 1}$ 介于 $0$ 和 $1$ 之间，其对数为负。因此，用它相除会使不等号反向：\n$$\nm \\ge \\frac{\\ln(\\varepsilon/2)}{\\ln\\left( \\frac{\\sqrt{\\kappa} - 1}{\\sqrt{\\kappa} + 1} \\right)}\n$$\n使用属性 $\\ln(1/x) = -\\ln(x)$，可以写成更方便的形式：\n$$\nm \\ge \\frac{\\ln(2/\\varepsilon)}{\\ln\\left( \\frac{\\sqrt{\\kappa} + 1}{\\sqrt{\\kappa} - 1} \\right)}\n$$\n预测的迭代次数 $m(\\kappa, \\varepsilon)$ 是满足此条件的最小整数。这可以通过对右侧表达式取上整得到。本问题中的所有情况都满足 $\\kappa  1$。\n$$\nm(\\kappa, \\varepsilon) = \\left\\lceil \\frac{\\ln(2/\\varepsilon)}{\\ln\\left( \\frac{\\sqrt{\\kappa} + 1}{\\sqrt{\\kappa} - 1} \\right)} \\right\\rceil\n$$\n\n### 未预处理系统分析\n对于未预处理的系统，条件数 $\\kappa(h)$ 取决于网格参数 $h$：\n$$\n\\kappa(h) = \\frac{c_{\\beta}}{c_{\\alpha}} h^{-(p_{\\alpha} + p_{\\beta})}\n$$\n设初始网格参数为 $h_0$。条件数为 $\\kappa_{\\text{before}} = \\kappa(h_0)$。初始迭代次数为：\n$$\nm_{\\text{before}} = m(\\kappa_{\\text{before}}, \\varepsilon)\n$$\n加密后，新的网格参数为 $h_{\\text{after}} = h_0 / 2$。新的条件数为：\n$$\n\\kappa_{\\text{after}} = \\kappa(h_0/2) = \\frac{c_{\\beta}}{c_{\\alpha}} \\left(\\frac{h_0}{2}\\right)^{-(p_{\\alpha} + p_{\\beta})} = \\kappa(h_0) \\cdot 2^{p_{\\alpha} + p_{\\beta}} = \\kappa_{\\text{before}} \\cdot 2^{p_{\\alpha} + p_{\\beta}}\n$$\n加密后的迭代次数为：\n$$\nm_{\\text{after}} = m(\\kappa_{\\text{after}}, \\varepsilon)\n$$\n迭代次数的变化是整数差：\n$$\n\\Delta m_{\\mathrm{unprec}} = m_{\\text{after}} - m_{\\text{before}}\n$$\n\n### 预处理系统分析\n准亥姆霍兹预条件子 $M$ 旨在修复密集离散化失效。预处理矩阵 $M^{-1}A(h)$ 的谱包含在一个与网格参数 $h$ 无关的区间 $[\\underline{\\alpha}, \\overline{\\beta}]$ 内。\n因此，预处理系统的条件数也与 $h$ 无关：\n$$\n\\kappa_p = \\frac{\\overline{\\beta}}{\\underline{\\alpha}}\n$$\n由于 $\\kappa_p$ 在网格加密时不变，预测的迭代次数 $m(\\kappa_p, \\varepsilon)$ 也保持恒定。因此，迭代次数的变化为零：\n$$\n\\Delta m_{\\mathrm{prec}} = m(\\kappa_p, \\varepsilon) - m(\\kappa_p, \\varepsilon) = 0\n$$\n\n### 测试用例计算\n对于每个测试用例，我们将应用这些公式。\n1.  对于未预处理的系统，计算 $\\kappa_{\\text{before}} = \\kappa(h_0)$ 和 $\\kappa_{\\text{after}} = \\kappa(h_0/2)$。\n2.  使用推导出的公式 $m(\\kappa, \\varepsilon)$ 求出 $m_{\\text{before}}$ 和 $m_{\\text{after}}$。\n3.  计算 $\\Delta m_{\\mathrm{unprec}} = m_{\\text{after}} - m_{\\text{before}}$。\n4.  设置 $\\Delta m_{\\mathrm{prec}} = 0$。\n每个用例的最终结果是整数对 $[\\Delta m_{\\mathrm{unprec}}, \\Delta m_{\\mathrm{prec}}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the change in GMRES iteration count for unpreconditioned and\n    preconditioned systems upon mesh refinement, based on a Chebyshev\n    convergence bound model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (h0, ca, pa, cb, pb, a_bar, b_bar, eps)\n    test_cases = [\n        (0.1, 0.8, 1, 2.4, 0, 0.5, 2.5, 1e-6),\n        (0.4, 0.8, 1, 2.4, 0, 0.5, 2.5, 1e-6),\n        (0.05, 0.8, 1, 2.4, 0, 0.5, 2.5, 1e-12),\n        (0.08, 0.6, 1, 1.8, 0, 0.7, 2.1, 1e-3),\n    ]\n\n    def calculate_iterations(kappa, epsilon):\n        \"\"\"\n        Calculates the predicted GMRES iteration count based on the\n        Chebyshev optimal polynomial bound for a real positive spectrum.\n\n        Args:\n            kappa (float): The condition number of the matrix.\n            epsilon (float): The desired relative residual tolerance.\n\n        Returns:\n            int: The smallest integer number of iterations predicted by the bound.\n        \"\"\"\n        # The model is valid for kappa  1. All test cases satisfy this.\n        if kappa = 1:\n            # A condition number of 1 implies convergence in 1 step.\n            # While this case isn't hit by the problem data, it's a good practice.\n            return 1\n        \n        # Upper bound on iterations m:\n        # m = ln(2/epsilon) / ln((sqrt(kappa) + 1) / (sqrt(kappa) - 1))\n        sqrt_kappa = np.sqrt(kappa)\n        numerator = np.log(2.0 / epsilon)\n        denominator = np.log((sqrt_kappa + 1.0) / (sqrt_kappa - 1.0))\n        \n        # The predicted iteration count is the smallest integer satisfying the bound.\n        m = np.ceil(numerator / denominator)\n        \n        return int(m)\n\n    results = []\n    for case in test_cases:\n        h0, ca, pa, cb, pb, a_bar, b_bar, eps = case\n        \n        # --- Unpreconditioned Case ---\n        \n        # Mesh parameters before and after refinement by a factor of 2.\n        h_before = h0\n        h_after = h0 / 2.0\n        \n        # Common factors for condition number calculation.\n        kappa_ratio = cb / ca\n        power_sum = pa + pb\n        \n        # Condition numbers before and after refinement.\n        kappa_before = kappa_ratio * (h_before ** -power_sum)\n        kappa_after = kappa_ratio * (h_after ** -power_sum)\n        \n        # Predicted iteration counts.\n        m_unprec_before = calculate_iterations(kappa_before, eps)\n        m_unprec_after = calculate_iterations(kappa_after, eps)\n        \n        delta_m_unprec = m_unprec_after - m_unprec_before\n        \n        # --- Preconditioned Case ---\n        \n        # The preconditioned condition number is independent of h.\n        # Therefore, the iteration count does not change upon mesh refinement.\n        delta_m_prec = 0\n        \n        results.append([delta_m_unprec, delta_m_prec])\n\n    # Final print statement in the exact required format.\n    print(f\"[[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "将算法理论应用于实际的高性能计算（HPC）环境，需要对资源进行仔细的核算。本实践问题深入探讨了运行大规模GMRES求解器的实际成本，重点关注内存占用、计算操作（浮点运算次数）和通信开销。通过分析诸如为提高数值稳定性而进行重正交化所带来的额外成本等权衡，您将更深刻地理解那些决定Krylov方法在真实世界中性能与可扩展性的关键因素。",
            "id": "3321331",
            "problem": "考虑一个频域电磁边界积分方程的矩量法（MoM）离散化，它产生一个维度为 $N = 10^{6}$、未知数为复数的线性系统 $A x = b$。您计划使用重启的广义最小残差方法（GMRES）来求解该系统，重启参数为 $m = 80$。该方法通过 Arnoldi 过程和经典 Gram–Schmidt 正交化实现，并启用完全再正交化以防止正交性的损失。\n\n假设采用以下建模和计算约定，这些约定反映了复数双精度算术的典型高性能实现：\n- 每个复数都以双精度存储，占用 $16$ 字节的内存。\n- 两个长度为 $N$ 的向量的复数内积计为约 $8N$ 次实数浮点运算（flops）。这模拟了按元素复数乘法所需的 $6N$ flops 和累加过程中复数加法所需的约 $2N$ flops（忽略 $O(1)$ 项）。\n- 对于长度为 $N$ 的向量和复标量 $\\alpha$，形式为 $y \\leftarrow y - \\alpha x$ 的缩放复数 axpy 运算计为 $8N$ flops（复数乘法 $6N$ flops，复数加法 $2N$ flops）。\n- 重启的 GMRES($m$) 存储由 Arnoldi 过程生成的 $(m+1)$ 个向量的 Krylov 基、$(m+1)\\times m$ 的上 Hessenberg 矩阵，以及恰好三个用于残差、预处理残差和临时乘积的额外长度为 $N$ 的复数工作向量。\n- 对于在 $P$ 个进程上的并行执行，每个复数内积引起一次全局归约；与单遍经典 Gram–Schmidt 相比，完全再正交化使内积的数量增加一倍。\n\n仅使用这些假设以及带有 Arnoldi 过程的 GMRES($m$) 的算法结构：\n1. 对于 $N = 10^{6}$ 和 $m = 80$，推导并计算存储 Krylov 基、上 Hessenberg 矩阵和三个额外工作向量所需的总内存占用（以吉字节 GiB 为单位；其中 $1\\,\\mathrm{GiB} = 2^{30}$ 字节）。\n2. 对于 $N = 10^{6}$ 和 $m = 80$，推导并计算在单遍经典 Gram–Schmidt 之外，完全再正交化在每个重启周期中施加的额外浮点运算次数。\n3. 对于 $m = 80$，确定由完全再正交化在每个重启周期中引起的额外全局点积归约次数。\n\n讨论计算出的这些数量如何影响缓存行为（例如，流式处理超过末级缓存的向量）和进程间通信（例如，由全局归约引起的同步），并使您的讨论基于推导出的计数值。\n\n作为您的最终数值输出，报告一个单行向量 $\\begin{pmatrix} M_{\\mathrm{GiB}}  F_{\\mathrm{add}}  R_{\\mathrm{add}} \\end{pmatrix}$，其中：\n- $M_{\\mathrm{GiB}}$ 是以 GiB 为单位的总内存占用，四舍五入到三位有效数字，\n- $F_{\\mathrm{add}}$ 是由于完全再正交化导致的每个重启周期的额外浮点运算次数，四舍五入到三位有效数字，\n- $R_{\\mathrm{add}}$ 是每个重启周期的额外全局点积归约次数，以精确整数报告。",
            "solution": "该问题要求计算使用完全再正交化的重启广义最小残差方法（GMRES($m$)）的内存占用、额外浮点运算（flops）和额外通信事件。计算基于所提供的参数和成本模型。\n\n首先，我们确定问题陈述中给出的参数：\n- 线性系统的维度为 $N = 10^{6}$。\n- GMRES 重启参数为 $m = 80$。\n- 每个复数占用 $16$ 字节。\n- $1\\,\\mathrm{GiB} = 2^{30}$ 字节。\n- 长度为 $N$ 的向量的复数内积成本为 $8N$ flops。\n- 长度为 $N$ 的向量的复数 axpy 运算成本为 $8N$ flops。\n\n### 1. 总内存占用 ($M$)\n\n总内存占用是存储 Krylov 基、Hessenberg 矩阵和指定工作向量所需存储空间的总和。\n\n- **Krylov 基**：Arnoldi 过程为 Krylov 子空间 $\\mathcal{K}_{m+1}(A, r_0)$ 生成一个标准正交基 $\\{q_1, q_2, \\ldots, q_{m+1}\\}$。这需要存储 $m+1$ 个向量，每个向量的长度为 $N$。复数值的数量为 $(m+1)N$。\n- **Hessenberg 矩阵**：Arnoldi 过程产生一个 $(m+1) \\times m$ 的上 Hessenberg 矩阵 $H_m$。复数值的数量为 $(m+1)m$。\n- **工作向量**：问题陈述指出，使用了 $3$ 个额外的长度为 $N$ 的复数工作向量。复数值的数量为 $3N$。\n\n需要存储的复数值总数 $C_{\\mathrm{total}}$ 是这些部分的总和：\n$$\nC_{\\mathrm{total}} = (m+1)N + 3N + (m+1)m = (m+4)N + (m+1)m\n$$\n以字节为单位的总内存占用 $M_{\\mathrm{bytes}}$ 是 $C_{\\mathrm{total}}$ 乘以一个复数的大小（$16$ 字节）：\n$$\nM_{\\mathrm{bytes}} = 16 \\times \\left( (m+4)N + (m+1)m \\right)\n$$\n为了将其转换为吉字节（GiB），我们除以 $2^{30}$。\n$$\nM_{\\mathrm{GiB}} = \\frac{16 \\times \\left( (m+4)N + (m+1)m \\right)}{2^{30}}\n$$\n代入给定值 $N = 10^{6}$ 和 $m = 80$：\n$$\nM_{\\mathrm{GiB}} = \\frac{16 \\times \\left( (80+4) \\times 10^{6} + (80+1) \\times 80 \\right)}{2^{30}}\n$$\n$$\nM_{\\mathrm{GiB}} = \\frac{16 \\times \\left( 84 \\times 10^{6} + 81 \\times 80 \\right)}{2^{30}} = \\frac{16 \\times \\left( 84,000,000 + 6480 \\right)}{1,073,741,824}\n$$\n$$\nM_{\\mathrm{GiB}} = \\frac{16 \\times 84,006,480}{1,073,741,824} = \\frac{1,344,103,680}{1,073,741,824} \\approx 1.25181 \\, \\mathrm{GiB}\n$$\n四舍五入到三位有效数字，总内存占用为 $M_{\\mathrm{GiB}} = 1.25 \\, \\mathrm{GiB}$。与向量的存储相比，Hessenberg 矩阵的存储（$16 \\times 6480 \\approx 104$ kB）可以忽略不计。\n\n### 2. 每个重启周期的额外浮点运算次数 ($F_{\\mathrm{add}}$)\n\nArnoldi 过程中的正交化是使用经典 Gram–Schmidt（CGS）方法执行的。在 Arnoldi 迭代的第 $j$ 步（对于 $j=1, \\ldots, m$），新向量 $v = A q_j$ 与现有的基向量 $\\{q_1, \\ldots, q_j\\}$ 进行正交化。单遍 CGS 涉及 $j$ 次内积（$h_{i,j} = q_i^H v$）和 $j$ 次 axpy 运算（$v \\leftarrow v - h_{i,j}q_i$）。\n\n完全再正交化意味着执行第二次 Gram-Schmidt 过程以纠正正交性的损失。这第二遍也涉及 $j$ 次内积和 $j$ 次 axpy 运算。因此，在第 $j$ 步由再正交化产生的*额外*工作包括 $j$ 次内积和 $j$ 次 axpy 运算。\n\n在一个完整的重启周期（$m$ 步 Arnoldi）中，额外内积的总数是从 $j=1$ 到 $m$ 的总和：\n$$\nN_{\\mathrm{ip, add}} = \\sum_{j=1}^{m} j = \\frac{m(m+1)}{2}\n$$\n类似地，额外 axpy 运算的总数是：\n$$\nN_{\\mathrm{axpy, add}} = \\sum_{j=1}^{m} j = \\frac{m(m+1)}{2}\n$$\n一次内积的成本给定为 $8N$ flops，一次 axpy 的成本也为 $8N$ flops。总的额外 flop 计数 $F_{\\mathrm{add}}$ 是：\n$$\nF_{\\mathrm{add}} = N_{\\mathrm{ip, add}} \\times (8N) + N_{\\mathrm{axpy, add}} \\times (8N)\n$$\n$$\nF_{\\mathrm{add}} = \\frac{m(m+1)}{2} \\times 8N + \\frac{m(m+1)}{2} \\times 8N = m(m+1) \\times 8N\n$$\n代入 $N = 10^6$ 和 $m = 80$：\n$$\nF_{\\mathrm{add}} = 80 \\times (80+1) \\times 8 \\times 10^{6} = 80 \\times 81 \\times 8 \\times 10^{6}\n$$\n$$\nF_{\\mathrm{add}} = 6480 \\times 8 \\times 10^{6} = 51840 \\times 10^{6} = 5.184 \\times 10^{10}\n$$\n四舍五入到三位有效数字，额外的 flop 计数为 $F_{\\mathrm{add}} = 5.18 \\times 10^{10}$ flops。\n\n### 3. 每个重启周期的额外全局归约次数 ($R_{\\mathrm{add}}$)\n\n问题陈述指出，每个复数内积引起一次全局归约。完全再正交化增加了第二组内积，因此增加了相应数量的全局归约。额外全局归约的次数 $R_{\\mathrm{add}}$ 等于先前计算的额外内积的次数。\n$$\nR_{\\mathrm{add}} = N_{\\mathrm{ip, add}} = \\frac{m(m+1)}{2}\n$$\n代入 $m=80$：\n$$\nR_{\\mathrm{add}} = \\frac{80 \\times (80+1)}{2} = 40 \\times 81 = 3240\n$$\n这是一个精确的整数值。\n\n### 对性能影响的讨论\n\n-   **缓存行为**：$M_{\\mathrm{GiB}} \\approx 1.25 \\, \\mathrm{GiB}$ 的总内存占用远大于现代 CPU 上典型的末级缓存（LLC），后者通常在几十兆字节的量级。一个长度为 $N$ 的向量需要 $10^6 \\times 16 \\, \\text{字节} = 16 \\, \\text{MB}$ 的存储空间。GMRES 的核心操作，如内积和 axpy 更新，涉及流式处理一个或多个这样的大向量。例如，在正交化步骤中，算法重复访问基向量 $\\{ q_1, \\ldots, q_j \\}$。随着基的大小 $j$ 的增长，需要访问的向量集合 $j \\times 16 \\, \\text{MB}$ 会迅速超过任何片上缓存。因此，这些向量操作是受内存带宽限制的；处理器花费大量时间等待从主 DRAM 中获取数据，而不是执行计算。高 flop 计数，包括额外的 $F_{\\mathrm{add}} \\approx 5.18 \\times 10^{10}$ flops，通常无法持续，因为算术单元因数据匮乏而闲置。\n\n-   **进程间通信**：在 $P$ 个进程的并行实现中，全局归约是需要所有进程通信的同步点。由完全再正交化引起的每个重启周期额外的 $R_{\\mathrm{add}} = 3240$ 次全局归约代表了显著的通信开销。这 $3240$ 次操作中的每一次（例如，一次 `MPI_Allreduce` 调用）都会引入延迟，因为进程必须等待最慢的参与者以及数据在网络上传输。总挂钟时间对网络延迟和带宽变得高度敏感。对于 $P$ 值很大的大规模并行系统，这些归约的成本可能会主导总运行时间，超过浮点运算的成本。这说明了可扩展数值算法中的一个基本权衡：对数值鲁棒性的需求（此处通过再正交化实现）通常以增加通信和同步为代价，而这会限制并行可扩展性。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1.25  5.18 \\times 10^{10}  3240 \\end{pmatrix}}\n$$"
        }
    ]
}