{
    "hands_on_practices": [
        {
            "introduction": "To effectively implement and troubleshoot numerical methods in electromagnetics, one must first grasp the underlying analytical structure of the integral equations. The Electric Field Integral Equation (EFIE) presents a significant numerical challenge due to a hypersingular kernel, which arises from the scalar potential term. This practice  provides a foundational theoretical exercise in regularizing this term, guiding you through a derivation that transforms the problematic operator into a more manageable form suitable for modern computational techniques.",
            "id": "3338424",
            "problem": "Consider a smooth, closed Perfect Electric Conductor (PEC) surface $S$ in free space, illuminated by a time-harmonic wave with angular frequency $\\omega$ and free-space wavenumber $k$. Denote the observation point by $\\mathbf{r}$ and the source point by $\\mathbf{r}'$, with separation $R = |\\mathbf{r} - \\mathbf{r}'|$. Let $G(\\mathbf{r}, \\mathbf{r}') = \\exp(-jk R)/(4\\pi R)$ be the free-space scalar Green's function that solves the Helmholtz equation in the sense of distributions. In the Electric Field Integral Equation (EFIE), the scalar potential contribution often appears in the form of the operator $\\nabla \\nabla \\cdot (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}'))$, where $\\mathbf{J}(\\mathbf{r}')$ is the induced surface current density on $S$.\n\nStarting from the vector calculus identity for the curl of a curl, the distributional Helmholtz equation for $G(\\mathbf{r}, \\mathbf{r}')$, and the fact that $\\mathbf{J}(\\mathbf{r}')$ is independent of the observation variable $\\mathbf{r}$, derive a formulation for the quantity $\\nabla \\nabla \\cdot (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}'))$ that isolates kernels which are at most weakly singular and are integrable over $S$ in the standard sense. Your derivation must carefully track which derivatives act on $\\mathbf{r}$ versus $\\mathbf{r}'$ and justify the handling of any distributional terms that arise. Express the final result as a single, closed-form analytic expression valid for use under a surface integral over $S$ with respect to $\\mathbf{r}'$.\n\nState your final expression explicitly in terms of the operators $\\nabla$, $\\nabla \\times$, the scalar Green's function $G(\\mathbf{r}, \\mathbf{r}')$, the wavenumber $k$, and the current density $\\mathbf{J}(\\mathbf{r}')$. No numerical computation is required, and no rounding is necessary. The final answer must be a single closed-form analytic expression.",
            "solution": "The objective is to find an alternative expression for the quantity $\\nabla \\nabla \\cdot (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}'))$. The notation $\\nabla \\nabla \\cdot$ represents the operator sequence $\\nabla(\\nabla \\cdot)$. The derivatives, denoted by $\\nabla$, are taken with respect to the observation point coordinate $\\mathbf{r}$. The current density $\\mathbf{J}(\\mathbf{r}')$ is a function of the source point coordinate $\\mathbf{r}'$ and is therefore treated as a constant vector with respect to the $\\nabla$ operator.\n\nThe starting point is the standard vector calculus identity that defines the vector Laplacian, which holds in the sense of distributions:\n$$\n\\nabla \\times (\\nabla \\times \\mathbf{A}) = \\nabla(\\nabla \\cdot \\mathbf{A}) - \\nabla^2 \\mathbf{A}\n$$\nIn this identity, $\\mathbf{A}$ is an arbitrary vector field. We are interested in the term $\\nabla(\\nabla \\cdot \\mathbf{A})$. By rearranging the identity, we can express it as:\n$$\n\\nabla(\\nabla \\cdot \\mathbf{A}) = \\nabla \\times (\\nabla \\times \\mathbf{A}) + \\nabla^2 \\mathbf{A}\n$$\nWe apply this identity to the vector field $\\mathbf{A}(\\mathbf{r}) = \\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}')$. The term we wish to reformulate is the left-hand side, $\\nabla(\\nabla \\cdot (\\mathbf{J}G))$.\n\nLet's analyze the term $\\nabla^2 \\mathbf{A} = \\nabla^2 (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}'))$. Since $\\mathbf{J}(\\mathbf{r}')$ is a constant vector with respect to the derivatives in $\\nabla$, we can factor it out of the differentiation:\n$$\n\\nabla^2 (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}')) = \\mathbf{J}(\\mathbf{r}') \\nabla^2 G(\\mathbf{r}, \\mathbf{r}')\n$$\nThe problem provides the distributional Helmholtz equation satisfied by the scalar Green's function, $G$:\n$$\n(\\nabla^2 + k^2)G(\\mathbf{r}, \\mathbf{r}') = -\\delta(\\mathbf{r} - \\mathbf{r}')\n$$\nwhere $k$ is the wavenumber and $\\delta(\\mathbf{r} - \\mathbf{r}')$ is the three-dimensional Dirac delta distribution. We can solve for $\\nabla^2 G$:\n$$\n\\nabla^2 G(\\mathbf{r}, \\mathbf{r}') = -k^2 G(\\mathbf{r}, \\mathbf{r}') - \\delta(\\mathbf{r} - \\mathbf{r}')\n$$\nSubstituting this expression for $\\nabla^2 G$ into our equation for $\\nabla^2 \\mathbf{A}$ yields:\n$$\n\\nabla^2 (\\mathbf{J}G) = \\mathbf{J}(-k^2 G - \\delta(\\mathbf{r} - \\mathbf{r}')) = -k^2 \\mathbf{J}G - \\mathbf{J}\\delta(\\mathbf{r} - \\mathbf{r}')\n$$\nNow, we substitute this result back into the rearranged vector identity for $\\nabla(\\nabla \\cdot (\\mathbf{J}G))$:\n$$\n\\nabla(\\nabla \\cdot (\\mathbf{J}G)) = \\nabla \\times (\\nabla \\times (\\mathbf{J}G)) + (-k^2 \\mathbf{J}G - \\mathbf{J}\\delta(\\mathbf{r} - \\mathbf{r}'))\n$$\nThis gives the final formulation for the target quantity:\n$$\n\\nabla \\nabla \\cdot (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}')) = \\nabla \\times (\\nabla \\times (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}'))) - k^2 \\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}') - \\mathbf{J}(\\mathbf{r}')\\delta(\\mathbf{r} - \\mathbf{r}')\n$$\nThis identity replaces the hypersingular operator $\\nabla\\nabla\\cdot$ (which behaves as $R^{-3}$ as $R=|\\mathbf{r}-\\mathbf{r}'|\\to 0$) with a sum of three terms. In the context of solving an integral equation numerically (e.g., via the Method of Moments), this new form is advantageous. The term with kernel $G$ is weakly singular ($O(R^{-1})$), the Dirac delta term is handled by singularity extraction, and the curl-curl term, while still containing a strongly singular kernel, can be regularized by transferring a derivative operator to a test function using integration by parts. This process makes the resulting integrals computationally tractable. The derived expression is the analytical foundation for this regularization procedure.",
            "answer": "$$\\boxed{\\nabla \\times (\\nabla \\times (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}'))) - k^2 \\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}') - \\mathbf{J}(\\mathbf{r}')\\delta(\\mathbf{r} - \\mathbf{r}')}$$"
        },
        {
            "introduction": "Moving from analytical theory to computational practice, it is crucial to see how different integral formulations perform in a concrete scenario. The Combined Field Integral Equation (CFIE) was developed to overcome the numerical instabilities of the EFIE, such as ill-conditioning at interior resonance frequencies or for challenging excitations. This hands-on coding benchmark  allows you to implement a semi-analytical solution for a canonical Perfect Electric Conductor (PEC) cylinder problem, directly comparing the accuracy of EFIE and CFIE against a known exact solution when a source is placed very close to the scatterer.",
            "id": "3338441",
            "problem": "Consider two-dimensional transverse magnetic polarization (TM$_z$) scattering by a Perfect Electric Conductor (PEC) circular cylinder of radius $a$ embedded in free space. The total electric field $u(\\mathbf{r})$ satisfies the scalar Helmholtz equation with wavenumber $k$, and the PEC boundary condition imposes $u(\\mathbf{r}) = 0$ on the boundary $\\Gamma = \\{ \\mathbf{r} : |\\mathbf{r}| = a \\}$. The incident field is generated by an elementary electric line source located at $\\mathbf{r}_s = (\\rho_s, \\theta_s)$ in polar coordinates, with $\\rho_s > a$, leading to a Green’s function $G(\\mathbf{r}, \\mathbf{r}_s) = \\dfrac{i}{4} H_0^{(1)}(k|\\mathbf{r} - \\mathbf{r}_s|)$, where $H_0^{(1)}$ is the Hankel function of the first kind of order zero. We set $\\theta_s = 0$ without loss of generality.\n\nYou will construct a modal benchmark to compare far-field errors from the Electric Field Integral Equation (EFIE) and the Combined Field Integral Equation (CFIE) when the source is placed close to the PEC boundary (highly near-field excitation). The aim is to examine whether CFIE improves accuracy by balancing near-field operator singularities through a second-kind formulation.\n\nStart from fundamental laws and core definitions of electromagnetic scattering, reduce to the scalar Helmholtz formulation for TM$_z$ in two dimensions, and use the addition theorem for cylindrical waves on a circle to obtain operator diagonalization in the Fourier basis. Do not assume any shortcut formulas not derived from these bases.\n\nAdopt the following canonical modal framework on the circular boundary:\n\n- Parameterize the boundary by the angle $\\theta \\in [0, 2\\pi)$, and expand boundary functions in Fourier modes $e^{i n \\theta}$ with integer $n$.\n- Let $u^{\\text{inc}}(a,\\theta)$ denote the incident field restricted to the boundary. Its Fourier coefficients $b_n$ satisfy\n$$\nu^{\\text{inc}}(a,\\theta) = \\sum_{n=-\\infty}^{\\infty} b_n e^{i n \\theta}.\n$$\n- The scattered field outside the cylinder admits a modal expansion\n$$\nu^{\\text{scat}}(r,\\theta) = \\sum_{n=-\\infty}^{\\infty} A_n H_n^{(1)}(k r) e^{i n \\theta}, \\quad r \\ge a,\n$$\nwhere $H_n^{(1)}$ is the Hankel function of the first kind of integer order $n$.\n- The EFIE (single-layer) representation uses a boundary density $\\mu(\\theta)$ such that\n$$\nu^{\\text{scat}}(\\mathbf{r}) = \\int_{\\Gamma} G(\\mathbf{r}, \\mathbf{r}') \\mu(\\theta') \\, d\\ell',\n$$\nand enforces $u^{\\text{inc}} + u^{\\text{scat}} = 0$ on $\\Gamma$ to solve for the Fourier coefficients $\\mu_n$ of $\\mu(\\theta) = \\sum \\mu_n e^{i n \\theta}$.\n- The CFIE uses the combined representation\n$$\nu^{\\text{scat}}(\\mathbf{r}) = \\int_{\\Gamma} \\frac{\\partial G(\\mathbf{r}, \\mathbf{r}')}{\\partial n'} \\mu(\\theta') \\, d\\ell' + i \\eta \\int_{\\Gamma} G(\\mathbf{r}, \\mathbf{r}') \\mu(\\theta') \\, d\\ell',\n$$\nwith a real coupling parameter $\\eta > 0$, and enforces the PEC boundary condition on $\\Gamma$ to solve for the Fourier coefficients $\\mu_n$.\n\nUsing the addition theorem on the circle, both the single-layer and double-layer boundary integral operators diagonalize in the Fourier basis with eigenvalues that depend only on $n$ and $k a$. Denote by $J_n$ the Bessel function of the first kind, and by $J_n'$ its derivative with respect to the argument. For the single-layer operator $S$ on $\\Gamma$ and the double-layer operator $K$ (source-normal derivative), their Fourier eigenvalues $s_n$ and $\\kappa_n$ satisfy\n$$\ns_n = \\frac{i \\pi a}{2} H_n^{(1)}(k a) J_n(k a), \\qquad \\kappa_n = \\frac{i \\pi a k}{2} H_n^{(1)}(k a) J_n'(k a).\n$$\nFrom the PEC boundary condition $u^{\\text{inc}} + u^{\\text{scat}} = 0$ on $\\Gamma$, the modal equations become:\n- EFIE: $s_n \\mu_n = - b_n$, hence $\\mu_n = - b_n / s_n$.\n- CFIE: $\\left( \\frac{1}{2} + \\kappa_n + i \\eta s_n \\right) \\mu_n = - b_n$, hence $\\mu_n = - b_n / \\left( \\frac{1}{2} + \\kappa_n + i \\eta s_n \\right)$.\n\nThe far-field at an observation point $(r_{\\text{obs}}, \\theta_{\\text{obs}})$ is assembled from the modal sums:\n- EFIE scattered field via single-layer:\n$$\nu^{\\text{scat}}_{\\text{EFIE}}(r_{\\text{obs}}, \\theta_{\\text{obs}}) \\approx \\frac{i}{4} a (2\\pi) \\sum_{n=-N}^{N} H_n^{(1)}(k r_{\\text{obs}}) J_n(k a) \\mu_n e^{i n \\theta_{\\text{obs}}}.\n$$\n- CFIE scattered field via combined representation:\n$$\nu^{\\text{scat}}_{\\text{CFIE}}(r_{\\text{obs}}, \\theta_{\\text{obs}}) \\approx \\frac{i}{4} a (2\\pi) \\sum_{n=-N}^{N} H_n^{(1)}(k r_{\\text{obs}}) \\left[ k J_n'(k a) + i \\eta J_n(k a) \\right] \\mu_n e^{i n \\theta_{\\text{obs}}}.\n$$\n\nFor a point source at $(\\rho_s, \\theta_s)$ with $\\rho_s > a$, the addition theorem yields the boundary coefficients\n$$\nb_n = \\frac{i}{4} H_n^{(1)}(k \\rho_s) J_n(k a) e^{- i n \\theta_s}.\n$$\nThe exact scattered field modal coefficients, obtained by enforcing $u^{\\text{inc}}(a,\\theta) + u^{\\text{scat}}(a,\\theta) = 0$ and orthogonality, satisfy\n$$\nA_n = - \\frac{b_n}{H_n^{(1)}(k a)}.\n$$\nThe exact far-field is then\n$$\nu^{\\text{scat}}_{\\text{exact}}(r_{\\text{obs}}, \\theta_{\\text{obs}}) \\approx \\sum_{n=-N_{\\text{ref}}}^{N_{\\text{ref}}} A_n H_n^{(1)}(k r_{\\text{obs}}) e^{i n \\theta_{\\text{obs}}}.\n$$\n\nYour program must:\n- Implement the above modal framework to compute EFIE and CFIE approximations using truncated sums of modes from $n=-N$ to $n=+N$, and compare each against the exact far-field computed with a larger reference truncation $N_{\\text{ref}}$.\n- Use the following fixed physical parameters: $a = 0.5$ meters, $k = 20.0$ radians per meter, $\\theta_s = 0.0$ radians, $\\theta_{\\text{obs}} = 0.0$ radians, $r_{\\text{obs}} = 5.0$ meters, $\\eta = 1.0$ (dimensionless).\n- Vary the source distance via $\\rho_s = a + d$ with small offsets $d$ to emulate highly near-field excitation.\n- Compute the relative complex-field error for each formulation as\n$$\n\\varepsilon_{\\star} = \\frac{\\left| u^{\\text{scat}}_{\\star}(r_{\\text{obs}}, \\theta_{\\text{obs}}) - u^{\\text{scat}}_{\\text{exact}}(r_{\\text{obs}}, \\theta_{\\text{obs}}) \\right|}{\\left| u^{\\text{scat}}_{\\text{exact}}(r_{\\text{obs}}, \\theta_{\\text{obs}}) \\right|},\n$$\nwith $\\star \\in \\{ \\text{EFIE}, \\text{CFIE} \\}$, expressed as a decimal number (unitless).\n\nAngles must be in radians. Distances must be in meters. The wavenumber must be in radians per meter.\n\nTest Suite:\n- Case $1$: $d = 0.05$, $N = 20$.\n- Case $2$: $d = 0.01$, $N = 20$.\n- Case $3$: $d = 0.005$, $N = 20$.\n- Case $4$ (boundary condition check): $d = 0.01$, $N = N_{\\text{ref}}$.\n- Case $5$ (increased truncation): $d = 0.005$, $N = 40$.\n\nUse $N_{\\text{ref}} = 120$ for the exact solution in all cases.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$$\n\\left[ \\varepsilon_{\\text{EFIE},1}, \\varepsilon_{\\text{CFIE},1}, \\varepsilon_{\\text{EFIE},2}, \\varepsilon_{\\text{CFIE},2}, \\varepsilon_{\\text{EFIE},3}, \\varepsilon_{\\text{CFIE},3}, \\varepsilon_{\\text{EFIE},4}, \\varepsilon_{\\text{CFIE},4}, \\varepsilon_{\\text{EFIE},5}, \\varepsilon_{\\text{CFIE},5} \\right].\n$$\nAll numerical outputs must be decimals (no percentage signs). Ensure scientific realism and self-consistency throughout.",
            "solution": "The solution is based on a modal analysis for the 2D TMz scattering problem, which exploits the circular geometry to find a semi-analytical solution in the Fourier domain. The core logic of the provided code follows the mathematical framework detailed in the problem description.\n\n1.  **Modal Representation:** All fields and source densities on the cylinder boundary are represented by their Fourier series. The boundary integral operators (single-layer $S$ and double-layer $K$) become diagonal in this basis, with eigenvalues $s_n$ and $\\kappa_n$ that depend on Bessel ($J_n$) and Hankel ($H_n^{(1)}$) functions.\n\n2.  **Exact Solution:** The reference solution is computed by directly enforcing the PEC boundary condition $u^{\\text{inc}} + u^{\\text{scat}} = 0$ on the modal expansions. This yields an exact expression for the scattered field coefficients $A_n$ in terms of the incident field coefficients $b_n$. The total scattered field is then summed over a high number of modes ($N_{\\text{ref}}$) to serve as a ground truth.\n\n3.  **Integral Equation Solutions (EFIE & CFIE):**\n    *   For the **EFIE**, the unknown density coefficients $\\mu_n^{\\text{EFIE}}$ are found by solving the modal equation $s_n \\mu_n = -b_n$. The scattered field is then constructed from this density.\n    *   For the **CFIE**, the density coefficients $\\mu_n^{\\text{CFIE}}$ are found by solving the second-kind modal equation $(\\frac{1}{2} + \\kappa_n + i\\eta s_n) \\mu_n = -b_n$. The scattered field is constructed using the combined single- and double-layer representation as specified.\n\n4.  **Implementation and Error Analysis:** The Python code implements these formulas for each test case. It uses `numpy` for vector operations and `scipy.special` for the required cylindrical functions (`jn`, `hankel1`, `jvp`). For each case, it calculates the scattered field from the EFIE and CFIE methods using a truncated number of modes $N$, and compares them to the reference solution to compute the relative error. The results from all test cases are collected and printed in the specified order and format.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import jn, hankel1, jvp\n\ndef solve():\n    \"\"\"\n    Solves the TM_z scattering problem for a PEC cylinder using modal analysis\n    for EFIE and CFIE formulations and computes the far-field error.\n    \"\"\"\n    # Fixed physical parameters\n    a = 0.5  # meters\n    k = 20.0  # radians per meter\n    theta_s = 0.0  # radians\n    r_obs = 5.0  # meters\n    theta_obs = 0.0  # radians\n    eta = 1.0  # dimensionless\n    N_ref = 120 # Reference truncation order\n\n    # Derived constants\n    ka = k * a\n    kr_obs = k * r_obs\n    i = 1j\n\n    test_cases = [\n        # (d, N)\n        (0.05, 20),\n        (0.01, 20),\n        (0.005, 20),\n        (0.01, N_ref), # Boundary condition check with N = N_ref\n        (0.005, 40),\n    ]\n\n    results = []\n\n    for d, N in test_cases:\n        rho_s = a + d\n        k_rho_s = k * rho_s\n\n        # Use complex128 for high precision\n        ka = np.complex128(ka)\n        kr_obs = np.complex128(kr_obs)\n        k_rho_s = np.complex128(k_rho_s)\n\n        # --- 1. Compute Exact Solution (Reference) ---\n        n_ref_vals = np.arange(-N_ref, N_ref + 1)\n        \n        # Incident field coefficients b_n\n        # b_n = (i/4) * H_n^(1)(k*rho_s) * J_n(k*a) * exp(-i*n*theta_s)\n        # Since theta_s = 0, exp term is 1\n        b_n_ref = (i / 4.0) * hankel1(n_ref_vals, k_rho_s) * jn(n_ref_vals, ka)\n\n        # Exact scattered field coefficients A_n\n        # A_n = -b_n / H_n^(1)(k*a)\n        A_n_exact = -b_n_ref / hankel1(n_ref_vals, ka)\n        \n        # Exact scattered field u_scat\n        # u_scat = sum(A_n * H_n^(1)(k*r_obs) * exp(i*n*theta_obs))\n        # Since theta_obs = 0, exp term is 1\n        u_scat_exact = np.sum(A_n_exact * hankel1(n_ref_vals, kr_obs))\n\n        # --- 2. Compute EFIE and CFIE solutions ---\n        n_vals = np.arange(-N, N + 1)\n        \n        # Incident field coefficients b_n for the truncated series\n        b_n = (i / 4.0) * hankel1(n_vals, k_rho_s) * jn(n_vals, ka)\n        \n        # Operator eigenvalues\n        h1_ka = hankel1(n_vals, ka)\n        jn_ka = jn(n_vals, ka)\n        jnp_ka = jvp(n_vals, ka, 1) # Derivative of J_n at ka\n\n        s_n = (i * np.pi * a / 2.0) * h1_ka * jn_ka\n        kappa_n = (i * np.pi * a * k / 2.0) * h1_ka * jnp_ka\n\n        # --- EFIE ---\n        # Solve for density mu_n: s_n * mu_n = -b_n\n        mu_n_efie = -b_n / s_n\n\n        # Compute scattered field from mu_n\n        h1_krobs = hankel1(n_vals, kr_obs)\n        u_scat_efie_modes = (i * np.pi * a / 2.0) * h1_krobs * jn_ka * mu_n_efie\n        u_scat_efie = np.sum(u_scat_efie_modes)\n        \n        # --- CFIE ---\n        # Solve for density mu_n: (1/2 + kappa_n + i*eta*s_n) * mu_n = -b_n\n        D_n_cfie = 0.5 + kappa_n + i * eta * s_n\n        mu_n_cfie = -b_n / D_n_cfie\n\n        # Compute scattered field from mu_n (using combined representation)\n        field_kernel_cfie = (k * jnp_ka + i * eta * jn_ka)\n        u_scat_cfie_modes = (i * np.pi * a / 2.0) * h1_krobs * field_kernel_cfie * mu_n_cfie\n        u_scat_cfie = np.sum(u_scat_cfie_modes)\n\n        # --- 3. Compute Relative Errors ---\n        # Avoid division by zero if exact field is zero (unlikely here)\n        norm_exact = np.abs(u_scat_exact)\n        if norm_exact  1e-30:\n            norm_exact = 1.0\n\n        err_efie = np.abs(u_scat_efie - u_scat_exact) / norm_exact\n        err_cfie = np.abs(u_scat_cfie - u_scat_exact) / norm_exact\n\n        results.extend([err_efie, err_cfie])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The effectiveness of the CFIE is not automatic; it depends on a judicious choice of its parameters, the blending factor $\\alpha$ and the impedance scaling $\\eta$. This final practice  elevates the analysis to a systems-level design problem, where the goal is to find optimal parameters that ensure robust performance across various operating conditions. By constructing and analyzing an abstract but representative discrete model, you will perform a sensitivity analysis and solve a robust optimization problem to select the best CFIE parameters, a crucial skill for developing reliable simulation tools.",
            "id": "3338426",
            "problem": "A perfectly electrically conducting (PEC) scatterer is analyzed in the frequency domain using boundary integral equations derived from Maxwell’s equations. The electric field integral equation (EFIE) and the magnetic field integral equation (MFIE), when discretized with a set of basis/testing functions, yield linear operators that relate the unknown surface current density to the incident fields. The combined field integral equation (CFIE) stabilizes the formulation by forming a weighted combination of EFIE and MFIE. Let the EFIE discrete operator be denoted by $Z_{\\mathrm{E}}(k) \\in \\mathbb{C}^{N \\times N}$ and the MFIE discrete operator be denoted by $Z_{\\mathrm{M}}(k) \\in \\mathbb{C}^{N \\times N}$, where $k$ is the wavenumber in $\\mathrm{rad/m}$ and $N$ is the number of spatial degrees of freedom. Let the corresponding right-hand sides for an incident plane wave be $v_{\\mathrm{E}}(k) \\in \\mathbb{C}^{N}$ and $v_{\\mathrm{M}}(k) \\in \\mathbb{C}^{N}$. Define the CFIE with weighting parameter $\\alpha \\in [0,1]$ and wave impedance parameter $\\eta  0$ (in $\\Omega$) as the discrete linear system\n$$\nA(\\alpha,\\eta;k)\\,J(\\alpha,\\eta;k) \\;=\\; b(\\alpha,\\eta;k),\n$$\nwhere\n$$\nA(\\alpha,\\eta;k) \\;=\\; \\alpha\\,Z_{\\mathrm{E}}(k) \\;+\\; (1-\\alpha)\\,\\eta\\,Z_{\\mathrm{M}}(k),\n$$\n$$\nb(\\alpha,\\eta;k) \\;=\\; \\alpha\\,v_{\\mathrm{E}}(k) \\;+\\; (1-\\alpha)\\,\\eta\\,v_{\\mathrm{M}}(k),\n$$\nand $J(\\alpha,\\eta;k) \\in \\mathbb{C}^{N}$ is the unknown surface current expansion coefficient vector. The task is to perform a sensitivity analysis of the CFIE solution with respect to $\\alpha$ and $\\eta$, and then formulate and solve a robust optimization problem that chooses $(\\alpha,\\eta)$ to minimize a weighted norm combining current oscillation and residual error.\n\nThe derivation must start from first principles: namely, the frequency-domain Maxwell’s equations, the PEC boundary condition $n \\times E_{\\mathrm{tot}} = 0$ on the surface, and the definition of EFIE and MFIE operators as linear maps resulting from integral equation discretization. For sensitivity, assume that $A(\\alpha,\\eta;k)$ is invertible for the parameter ranges considered. Use implicit differentiation of the discrete CFIE system to obtain expressions for $\\partial J/\\partial \\alpha$ and $\\partial J/\\partial \\eta$ in terms of $A$, $J$, and the parameter derivatives of $A$ and $b$.\n\nTo quantify current oscillation, use a discrete first-difference operator $D \\in \\mathbb{R}^{(N-1)\\times N}$ defined by $D_{i,i}=1$ and $D_{i,i+1}=-1$ for $i \\in \\{1,\\dots,N-1\\}$ and zeros otherwise. For a given $(\\alpha,\\eta;k)$, define the cost\n$$\n\\mathcal{C}(\\alpha,\\eta;k) \\;=\\; w_1\\,\\|D\\,J(\\alpha,\\eta;k)\\|_2^2 \\;+\\; w_2\\,\\|A(\\alpha,\\eta;k)\\,J(\\alpha,\\eta;k) - b(\\alpha,\\eta;k)\\|_2^2,\n$$\nwhere $w_1  0$ and $w_2  0$ are weights. The robust optimization over a finite scenario set $\\mathcal{S}$ with different wavenumbers and incident field perturbations is\n$$\n\\min_{\\alpha \\in [\\alpha_{\\min},\\alpha_{\\max}],\\;\\eta \\in [\\eta_{\\min},\\eta_{\\max}]} \\;\\max_{k \\in \\mathcal{S}} \\;\\mathcal{C}(\\alpha,\\eta;k).\n$$\n\nImplement this computational analysis using the following deterministic discrete model for operators and excitations, constructed to mimic key CFIE features while remaining fully specified for reproducibility:\n\n- Let $N = 6$ and define positions $x_i = (i-1)\\,\\Delta$ with $\\Delta = 0.1$ in $\\mathrm{m}$ for $i \\in \\{1,\\dots,6\\}$.\n- Define two base dense matrices $S \\in \\mathbb{R}^{N \\times N}$ and $T \\in \\mathbb{R}^{N \\times N}$ by\n$$\nS_{ij} \\;=\\; \\exp\\!\\left(-\\frac{|i-j|}{1.5}\\right) \\;+\\; 0.2\\,\\delta_{ij}, \\quad\nT_{ij} \\;=\\; \\frac{1}{1+|i-j|} \\;+\\; 0.1\\,\\delta_{ij},\n$$\nwhere $\\delta_{ij}$ is the Kronecker delta.\n- For a given wavenumber $k$ in $\\mathrm{rad/m}$, define\n$$\nZ_{\\mathrm{E}}(k) \\;=\\; S \\;+\\; j\\,k\\,T, \\qquad\nZ_{\\mathrm{M}}(k) \\;=\\; \\frac{1}{2}\\,I \\;+\\; j\\,\\frac{1}{k}\\,T,\n$$\nwhere $I$ is the $N \\times N$ identity and $j$ denotes the imaginary unit.\n- Let the free-space wave impedance $\\eta_0$ be $\\eta_0 = \\sqrt{\\mu_0/\\varepsilon_0} \\approx 376.730313668$ in $\\Omega$.\n- Define the incident electric field vector by\n$$\nv_{\\mathrm{E}}(k)_i \\;=\\; \\cos(k\\,x_i) \\;+\\; \\epsilon\\,\\sin(i),\n$$\nwith $\\epsilon \\ge 0$ the deterministic excitation perturbation amplitude; define $v_{\\mathrm{M}}(k) = v_{\\mathrm{E}}(k)/\\eta_0$ to be consistent with $H = E/\\eta_0$ in free space.\n\nFor sensitivity, use\n$$\n\\frac{\\partial J}{\\partial \\alpha} \\;\\text{solves}\\; A\\,\\frac{\\partial J}{\\partial \\alpha} \\;=\\; \\frac{\\partial b}{\\partial \\alpha} \\;-\\; \\frac{\\partial A}{\\partial \\alpha}\\,J,\n$$\n$$\n\\frac{\\partial J}{\\partial \\eta} \\;\\text{solves}\\; A\\,\\frac{\\partial J}{\\partial \\eta} \\;=\\; \\frac{\\partial b}{\\partial \\eta} \\;-\\; \\frac{\\partial A}{\\partial \\eta}\\,J,\n$$\nwith\n$$\n\\frac{\\partial A}{\\partial \\alpha} \\;=\\; Z_{\\mathrm{E}}(k) - \\eta\\,Z_{\\mathrm{M}}(k), \\quad\n\\frac{\\partial b}{\\partial \\alpha} \\;=\\; v_{\\mathrm{E}}(k) - \\eta\\,v_{\\mathrm{M}}(k),\n$$\n$$\n\\frac{\\partial A}{\\partial \\eta} \\;=\\; (1-\\alpha)\\,Z_{\\mathrm{M}}(k), \\quad\n\\frac{\\partial b}{\\partial \\eta} \\;=\\; (1-\\alpha)\\,v_{\\mathrm{M}}(k).\n$$\n\nTest suite and parameter coverage:\n\n- Use three scenarios $\\mathcal{S}$ to probe different behaviors:\n  1. Scenario $1$ (happy path): wavelength $\\lambda_1 = 0.5$ in $\\mathrm{m}$, $k_1 = 2\\pi/\\lambda_1$, perturbation $\\epsilon_1 = 0.0$.\n  2. Scenario $2$ (higher frequency with moderate perturbation): wavelength $\\lambda_2 = 0.3$ in $\\mathrm{m}$, $k_2 = 2\\pi/\\lambda_2$, perturbation $\\epsilon_2 = 0.1$.\n  3. Scenario $3$ (lower frequency with larger perturbation): wavelength $\\lambda_3 = 0.7$ in $\\mathrm{m}$, $k_3 = 2\\pi/\\lambda_3$, perturbation $\\epsilon_3 = 0.2$.\n- Sensitivity baseline: evaluate $\\partial J/\\partial \\alpha$ and $\\partial J/\\partial \\eta$ at $\\alpha = 0.5$ and $\\eta = \\eta_0$.\n- Robust optimization:\n  - Weights: $w_1 = 1.0$, $w_2 = 10^{-3}$.\n  - Feasible set: $\\alpha \\in [0.2,0.8]$ (dimensionless) sampled uniformly at $7$ points, and $\\eta \\in [0.9\\,\\eta_0, 1.1\\,\\eta_0]$ in $\\Omega$ sampled uniformly at $9$ points.\n  - Objective: minimize the maximum of $\\mathcal{C}(\\alpha,\\eta;k)$ over $k \\in \\mathcal{S}$.\n\nUnits: All spatial positions $x_i$ must be in $\\mathrm{m}$, all wavenumbers $k$ must be in $\\mathrm{rad/m}$, and the wave impedance $\\eta$ must be expressed in $\\Omega$. The weights $w_1$ and $w_2$ are dimensionless.\n\nYour program must:\n- Construct $Z_{\\mathrm{E}}(k)$, $Z_{\\mathrm{M}}(k)$, $v_{\\mathrm{E}}(k)$, and $v_{\\mathrm{M}}(k)$ for each scenario.\n- Assemble $A(\\alpha,\\eta;k)$ and $b(\\alpha,\\eta;k)$.\n- Solve for $J(\\alpha,\\eta;k)$ and compute sensitivities at the baseline $(\\alpha,\\eta) = (0.5,\\eta_0)$ for each scenario, reporting the Euclidean norms $\\|\\partial J/\\partial \\alpha\\|_2$ and $\\|\\partial J/\\partial \\eta\\|_2$.\n- Perform the robust optimization over the specified grids to find $(\\alpha^\\star,\\eta^\\star)$ that minimize $\\max_{k \\in \\mathcal{S}} \\mathcal{C}(\\alpha,\\eta;k)$, and report $(\\alpha^\\star,\\eta^\\star)$ and the minimized robust cost value $\\max_{k \\in \\mathcal{S}} \\mathcal{C}(\\alpha^\\star,\\eta^\\star;k)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list elements must be the following floats in order:\n$[\\|\\partial J/\\partial \\alpha\\|_2 \\text{ for scenario }1,\\;\\|\\partial J/\\partial \\eta\\|_2 \\text{ for scenario }1,\\;\\|\\partial J/\\partial \\alpha\\|_2 \\text{ for scenario }2,\\;\\|\\partial J/\\partial \\eta\\|_2 \\text{ for scenario }2,\\;\\|\\partial J/\\partial \\alpha\\|_2 \\text{ for scenario }3,\\;\\|\\partial J/\\partial \\eta\\|_2 \\text{ for scenario }3,\\;\\alpha^\\star,\\;\\eta^\\star,\\;\\max_{k \\in \\mathcal{S}} \\mathcal{C}(\\alpha^\\star,\\eta^\\star;k)]$. All $\\eta$ values must be in $\\Omega$.",
            "solution": "The solution implements the specified sensitivity analysis and robust optimization procedure based on the provided discrete model for the CFIE system. The code is structured into three parts: model construction, sensitivity calculation, and robust optimization.\n\n**1. Model Construction:**\nFirst, all constant matrices and parameters are defined: the base matrices $S$ and $T$, the first-difference operator $D$, and the spatial positions $x_i$. For each of the three scenarios, the wavenumber $k$ is calculated from the given wavelength. Then, the frequency-dependent EFIE and MFIE system matrices ($Z_{\\mathrm{E}}(k)$, $Z_{\\mathrm{M}}(k)$) and right-hand side vectors ($v_{\\mathrm{E}}(k)$, $v_{\\mathrm{M}}(k)$) are constructed according to the problem's formulas.\n\n**2. Sensitivity Analysis:**\nFor each scenario, the analysis is performed at the baseline point $(\\alpha, \\eta) = (0.5, \\eta_0)$.\n*   The baseline CFIE system matrix $A$ and vector $b$ are assembled.\n*   The baseline current vector $J$ is found by solving the linear system $A J = b$.\n*   The derivatives of $A$ and $b$ with respect to $\\alpha$ and $\\eta$ are computed.\n*   Two new linear systems are formed and solved to find the sensitivity vectors $\\partial J / \\partial \\alpha$ and $\\partial J / \\partial \\eta$.\n*   The Euclidean norm of each sensitivity vector is calculated and stored.\n\n**3. Robust Optimization:**\nA grid search is performed over the specified discrete sets of $\\alpha$ and $\\eta$ values.\n*   For each candidate pair $(\\alpha, \\eta)$, a loop runs through the three scenarios.\n*   In each scenario, the CFIE system $A J = b$ is assembled and solved for the current $J$.\n*   The cost function $\\mathcal{C}(\\alpha,\\eta;k) = w_1\\|DJ\\|_2^2 + w_2\\|AJ-b\\|_2^2$ is evaluated.\n*   The maximum cost across the three scenarios is determined for the current $(\\alpha, \\eta)$ pair.\n*   This maximum cost is compared with the best-so-far minimum-maximum cost. If the current pair yields a lower maximum cost, it is stored as the new best solution $(\\alpha^\\star, \\eta^\\star)$, and the minimum-maximum cost is updated.\n    \nFinally, the six sensitivity norms and the three results from the robust optimization ($\\alpha^\\star, \\eta^\\star$, and the final cost) are collected and printed in the required comma-separated format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the CFIE sensitivity and robust optimization problem.\n    \"\"\"\n    # ----------------------------------------------------------------------\n    # 1. DEFINE CONSTANTS AND PARAMETERS\n    # ----------------------------------------------------------------------\n    \n    # Global parameters\n    N = 6\n    DELTA = 0.1\n    ETA0 = 376.730313668\n    W1 = 1.0\n    W2 = 1e-3\n    j_imag = 1j\n\n    # Scenario definitions\n    scenarios = [\n        {'lambda': 0.5, 'epsilon': 0.0},  # Scenario 1\n        {'lambda': 0.3, 'epsilon': 0.1},  # Scenario 2\n        {'lambda': 0.7, 'epsilon': 0.2},  # Scenario 3\n    ]\n    for s in scenarios:\n        s['k'] = 2 * np.pi / s['lambda']\n\n    # Sensitivity analysis baseline\n    sensitivity_baseline = {'alpha': 0.5, 'eta': ETA0}\n\n    # Robust optimization parameter grids\n    alpha_grid = np.linspace(0.2, 0.8, 7)\n    eta_grid = np.linspace(0.9 * ETA0, 1.1 * ETA0, 9)\n\n    # ----------------------------------------------------------------------\n    # 2. CONSTRUCT BASE MATRICES AND OPERATORS\n    # ----------------------------------------------------------------------\n    \n    # Spatial positions x_i for i in {1,...,N}\n    x_pos = np.arange(N) * DELTA\n\n    # Base matrix S\n    S = np.zeros((N, N))\n    indices = np.arange(N)\n    for i in range(N):\n        for j_idx in range(N):\n            S[i, j_idx] = np.exp(-np.abs(i - j_idx) / 1.5)\n    S += 0.2 * np.eye(N)\n\n    # Base matrix T\n    T = np.zeros((N, N))\n    for i in range(N):\n        for j_idx in range(N):\n            T[i, j_idx] = 1.0 / (1.0 + np.abs(i - j_idx))\n    T += 0.1 * np.eye(N)\n\n    # First-difference operator D\n    D = np.eye(N - 1, N, k=0) - np.eye(N - 1, N, k=1)\n    \n    # ----------------------------------------------------------------------\n    # 3. PERFORM SENSITIVITY ANALYSIS\n    # ----------------------------------------------------------------------\n\n    sensitivity_results = []\n    \n    for scenario in scenarios:\n        k = scenario['k']\n        epsilon = scenario['epsilon']\n        \n        # Construct scenario-dependent operators and excitations\n        ZE = S + j_imag * k * T\n        ZM = 0.5 * np.eye(N) + j_imag * (1.0 / k) * T\n        vE = np.cos(k * x_pos) + epsilon * np.sin(np.arange(1, N + 1))\n        vM = vE / ETA0\n        \n        # Use baseline alpha and eta for sensitivity calculation\n        alpha_b = sensitivity_baseline['alpha']\n        eta_b = sensitivity_baseline['eta']\n        \n        # Assemble baseline system A*J = b and solve for J\n        A_base = alpha_b * ZE + (1 - alpha_b) * eta_b * ZM\n        b_base = alpha_b * vE + (1 - alpha_b) * eta_b * vM\n        J_base = np.linalg.solve(A_base, b_base)\n        \n        # Sensitivity with respect to alpha\n        dA_dalpha = ZE - eta_b * ZM\n        db_dalpha = vE - eta_b * vM\n        rhs_alpha = db_dalpha - dA_dalpha @ J_base\n        dJ_dalpha = np.linalg.solve(A_base, rhs_alpha)\n        norm_dJ_dalpha = np.linalg.norm(dJ_dalpha)\n        sensitivity_results.append(norm_dJ_dalpha)\n        \n        # Sensitivity with respect to eta\n        dA_deta = (1 - alpha_b) * ZM\n        db_deta = (1 - alpha_b) * vM\n        rhs_eta = db_deta - dA_deta @ J_base\n        dJ_deta = np.linalg.solve(A_base, rhs_eta)\n        norm_dJ_deta = np.linalg.norm(dJ_deta)\n        sensitivity_results.append(norm_dJ_deta)\n\n    # ----------------------------------------------------------------------\n    # 4. PERFORM ROBUST OPTIMIZATION\n    # ----------------------------------------------------------------------\n\n    min_max_cost = float('inf')\n    best_alpha = None\n    best_eta = None\n\n    # Pre-calculate scenario-dependent items that are independent of alpha and eta\n    scenario_data = []\n    for s in scenarios:\n        k_s = s['k']\n        epsilon_s = s['epsilon']\n        \n        ZE_s = S + j_imag * k_s * T\n        ZM_s = 0.5 * np.eye(N) + j_imag * (1.0 / k_s) * T\n        vE_s = np.cos(k_s * x_pos) + epsilon_s * np.sin(np.arange(1, N + 1))\n        vM_s = vE_s / ETA0\n        scenario_data.append({'ZE': ZE_s, 'ZM': ZM_s, 'vE': vE_s, 'vM': vM_s})\n\n    # Grid search over alpha and eta\n    for alpha_opt in alpha_grid:\n        for eta_opt in eta_grid:\n            \n            max_cost_this_pair = -1.0\n            \n            for s_data in scenario_data:\n                # Retrieve pre-calculated operators for the scenario\n                ZE, ZM, vE, vM = s_data['ZE'], s_data['ZM'], s_data['vE'], s_data['vM']\n\n                # Assemble A, b for the current (alpha, eta) and solve for J\n                A_opt = alpha_opt * ZE + (1 - alpha_opt) * eta_opt * ZM\n                b_opt = alpha_opt * vE + (1 - alpha_opt) * eta_opt * vM\n                \n                try:\n                    J_opt = np.linalg.solve(A_opt, b_opt)\n                except np.linalg.LinAlgError:\n                    # A singular matrix leads to an infinite cost for this parameter pair\n                    max_cost_this_pair = float('inf')\n                    break \n\n                # Calculate cost C = w1*||D*J||^2 + w2*||A*J - b||^2\n                term1 = W1 * (np.linalg.norm(D @ J_opt) ** 2)\n                residual = A_opt @ J_opt - b_opt\n                term2 = W2 * (np.linalg.norm(residual) ** 2)\n                cost = term1 + term2\n                \n                if cost > max_cost_this_pair:\n                    max_cost_this_pair = cost\n            \n            # Check if this (alpha, eta) pair gives a better robust performance\n            if max_cost_this_pair  min_max_cost:\n                min_max_cost = max_cost_this_pair\n                best_alpha = alpha_opt\n                best_eta = eta_opt\n                \n    # ----------------------------------------------------------------------\n    # 5. FORMAT AND PRINT FINAL RESULTS\n    # ----------------------------------------------------------------------\n    \n    final_results = sensitivity_results + [best_alpha, best_eta, min_max_cost]\n    \n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}