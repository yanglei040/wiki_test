{
    "hands_on_practices": [
        {
            "introduction": "在实现任何数值算法时，首要步骤之一是在一个具有已知解析解的问题上对其进行测试，以验证其正确性。本练习提供了一个针对奇异三角形积分的经典验证案例：我们将Duffy变换应用于一个等边三角形上的奇异积分，并将数值结果与精确的解析解进行比对。通过这个过程，我们不仅能建立对我们代码实现的信心，还能加深对Duffy变换如何从根本上解决奇异性问题的理解。",
            "id": "3302738",
            "problem": "针对三维散射问题中电场积分方程 (EFIE) 产生的奇异三角形积分，构建一个规范验证。使用 Duffy 变换在单个规范元上对积分进行正则化。考虑平面中边长为 $s > 0$ 的一个等边三角形，其奇异点位于其中一个顶点。在 EFIE 的静态（零波数）极限下，使用 Rao–Wilton–Glisson (RWG) 基函数时，待求值的弱奇异积分具有以下通用形式：\n$$\nI[w] \\;=\\; \\int_{T} \\frac{w(\\mathbf{r}')}{\\lVert \\mathbf{r}' - \\mathbf{r}_0 \\rVert} \\,\\mathrm{d}S',\n$$\n其中 $T$ 是该三角形，$\\mathbf{r}_0$ 是奇异点所在的顶点，而 $w(\\mathbf{r}')$ 是一个光滑权重，它编码了基函数/测试函数的局部行为。使用从单位正方形到三角形的 Duffy 变换来对与因子 $1/\\lVert \\mathbf{r}' - \\mathbf{r}_0 \\rVert$ 相关的奇异性进行正则化，并数值计算 $I[w]$。\n\n基本原理：\n- 静态极限下的电场积分方程 (EFIE) 涉及拉普拉斯格林函数 $G(\\mathbf{r},\\mathbf{r}') = \\frac{1}{4\\pi \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}$，当 $\\mathbf{r} \\to \\mathbf{r}'$ 时，在局部坐标系中其弱奇异性表现为 $1/\\rho$ 的行为，其中 $\\rho = \\lVert \\mathbf{r}' - \\mathbf{r}_0 \\rVert$。\n- Duffy 变换将单位正方形 $(u,v)\\in[0,1]^2$ 映射到一个以 $\\mathbf{r}_0$ 为一个顶点的三角形，其形式为 $\\mathbf{r}'(u,v) = u\\big(v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b}\\big)$，其中 $\\mathbf{a}$ 和 $\\mathbf{b}$ 是另外两个非奇异顶点的位置向量。雅可比行列式会贡献一个与 $u$ 成正比的因子，该因子消除了 $1/\\rho$ 奇异性。\n\n定义等边三角形如下：\n- 设奇异顶点位于原点 $\\mathbf{r}_0 = \\mathbf{0}$，选择 $\\mathbf{a}$ 和 $\\mathbf{b}$ 为两个相邻顶点，使得原点处的内角为 $\\pi/3$，且底边垂直于角平分线。设 $s$ 为边长，$h = \\frac{\\sqrt{3}}{2} s$ 为高。所有角度均以弧度解释。\n\n待测试的权重：\n- $w_0(\\mathbf{r}') = 1$（常数权重）。\n- $w_1(\\mathbf{r}') = \\lambda_0(\\mathbf{r}')$，即在奇异顶点处为 $1$、在对边上为 $0$ 的重心坐标（这是与 RWG 基函数相关的标量因子，该因子向对边线性趋于零）。\n\n数值任务：\n- 对上述等边三角形，实现一个经 Duffy 变换的求积方法，以计算给定边长 $s$ 下的 $I[w_0]$ 和 $I[w_1]$。在 $(u,v)\\in[0,1]^2$ 上使用张量积高斯-勒让德求积，其阶数需足以解析 Duffy 正则化后的被积函数。\n- 将你的数值结果与可从第一性原理针对等边几何推导出的解析表达式进行比较，并报告相对误差。\n\n角度单位说明：\n- 所有角度均为弧度。\n\n测试套件：\n- 情况 A: $s = 1.0$，权重 $w = w_0$。\n- 情况 B: $s = 1.0$，权重 $w = w_1$。\n- 情况 C: $s = 3.0$，权重 $w = w_0$。\n- 情况 D: $s = 10^{-6}$，权重 $w = w_0$。\n\n答案规格：\n- 对每种情况，计算相对误差，定义为\n$$\n\\varepsilon \\;=\\; \\frac{\\left| I_{\\text{num}} - I_{\\text{analytic}} \\right|}{\\left| I_{\\text{analytic}} \\right|}。\n$$\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为 [情况 A, 情况 B, 情况 C, 情况 D]。例如：“[eA,eB,eC,eD]”。不需要物理单位，每个条目必须是浮点值。",
            "solution": "用户提供的问题已通过验证，被认为是合理的。以下解决方案提出了一个在三角形域上的奇异积分的规范验证，该积分使用 Duffy 变换进行正则化。\n\n### 1. 问题描述\n\n待求值的积分形式为：\n$$\nI[w] \\;=\\; \\int_{T} \\frac{w(\\mathbf{r}')}{\\lVert \\mathbf{r}' - \\mathbf{r}_0 \\rVert} \\,\\mathrm{d}S'\n$$\n其中 $T$ 是一个边长为 $s$ 的等边三角形，$\\mathbf{r}_0$ 是 $T$ 的一个顶点，$w(\\mathbf{r}')$ 是一个光滑权重函数。由于 $1/\\lVert \\mathbf{r}' - \\mathbf{r}_0 \\rVert$ 核的存在，该积分是弱奇异的，这在电场积分方程 (EFIE) 的静态极限下出现。\n\n### 2. 几何设置与 Duffy 变换\n\n我们将奇异顶点置于原点，即 $\\mathbf{r}_0 = \\mathbf{0} = (0, 0)$。对于边长为 $s$ 且在原点处内角为 $\\pi/3$ 的等边三角形，另外两个顶点 $\\mathbf{a}$ 和 $\\mathbf{b}$ 的位置为：\n$$\n\\mathbf{a} = \\left(s\\cos\\frac{\\pi}{6}, s\\sin\\frac{\\pi}{6}\\right) = \\left(\\frac{s\\sqrt{3}}{2}, \\frac{s}{2}\\right)\n$$\n$$\n\\mathbf{b} = \\left(s\\cos\\left(-\\frac{\\pi}{6}\\right), s\\sin\\left(-\\frac{\\pi}{6}\\right)\\right) = \\left(\\frac{s\\sqrt{3}}{2}, -\\frac{s}{2}\\right)\n$$\nDuffy 变换将单位正方形 $(u,v) \\in [0,1]^2$ 映射到三角形 $T$，如下所示：\n$$\n\\mathbf{r}'(u,v) = u\\big(v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b}\\big)\n$$\n微分面积元 $\\mathrm{d}S'$ 通过变换的雅可比行列式与 $\\mathrm{d}u\\,\\mathrm{d}v$ 相关联：\n$$\n\\mathrm{d}S' = |J(u,v)| \\,\\mathrm{d}u\\,\\mathrm{d}v = \\left\\| \\frac{\\partial \\mathbf{r}'}{\\partial u} \\times \\frac{\\partial \\mathbf{r}'}{\\partial v} \\right\\| \\,\\mathrm{d}u\\,\\mathrm{d}v\n$$\n偏导数为：\n$$\n\\frac{\\partial \\mathbf{r}'}{\\partial u} = v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b}\n$$\n$$\n\\frac{\\partial \\mathbf{r}'}{\\partial v} = u(\\mathbf{a} - \\mathbf{b})\n$$\n它们的叉积是：\n$$\n\\frac{\\partial \\mathbf{r}'}{\\partial u} \\times \\frac{\\partial \\mathbf{r}'}{\\partial v} = u \\left( (v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b}) \\times (\\mathbf{a} - \\mathbf{b}) \\right) = -u (\\mathbf{a} \\times \\mathbf{b})\n$$\n其大小为 $|J(u,v)| = u \\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert$。项 $\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert$ 代表三角形面积的两倍，即 $2A_T$。对于我们的等边三角形，$A_T = \\frac{\\sqrt{3}}{4}s^2$，因此 $\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert = \\frac{\\sqrt{3}}{2}s^2$。雅可比行列式为：\n$$\n|J(u,v)| = u \\frac{\\sqrt{3}}{2}s^2\n$$\n\n### 3. 积分的正则化\n\n将变换代入积分，我们得到：\n$$\nI[w] = \\int_0^1 \\int_0^1 \\frac{w(\\mathbf{r}'(u,v))}{\\lVert \\mathbf{r}'(u,v) \\rVert} |J(u,v)| \\,\\mathrm{d}u\\,\\mathrm{d}v\n$$\n分母中的距离项为：\n$$\n\\lVert \\mathbf{r}'(u,v) \\rVert = \\lVert u(v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b}) \\rVert = u \\lVert v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b} \\rVert\n$$\nDuffy 变换的关键特性是，来自雅可比行列式的因子 $u$ 与来自距离项的因子 $u$ 相抵消，从而使被积函数正则化：\n$$\nI[w] = \\int_0^1 \\int_0^1 \\frac{w(\\mathbf{r}'(u,v))}{u \\lVert v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b} \\rVert} \\left( u \\frac{\\sqrt{3}}{2}s^2 \\right) \\,\\mathrm{d}u\\,\\mathrm{d}v = \\frac{\\sqrt{3}}{2}s^2 \\int_0^1 \\int_0^1 \\frac{w(\\mathbf{r}'(u,v))}{\\lVert v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b} \\rVert} \\,\\mathrm{d}u\\,\\mathrm{d}v\n$$\n让我们计算分母中范数的平方：\n$$\n\\lVert v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b} \\rVert^2 = v^2\\lVert\\mathbf{a}\\rVert^2 + (1-v)^2\\lVert\\mathbf{b}\\rVert^2 + 2v(1-v)(\\mathbf{a} \\cdot \\mathbf{b})\n$$\n由于 $\\lVert\\mathbf{a}\\rVert^2 = s^2$, $\\lVert\\mathbf{b}\\rVert^2 = s^2$, 且 $\\mathbf{a} \\cdot \\mathbf{b} = s^2\\cos(\\pi/3) = s^2/2$，上式变为：\n$$\ns^2 \\left( v^2 + (1-v)^2 + v(1-v) \\right) = s^2 (v^2 + 1 - 2v + v^2 + v - v^2) = s^2 (v^2 - v + 1)\n$$\n因此，正则化后的积分为：\n$$\nI[w] = \\frac{\\sqrt{3}}{2}s^2 \\int_0^1 \\int_0^1 \\frac{w(u,v)}{s \\sqrt{v^2 - v + 1}} \\,\\mathrm{d}u\\,\\mathrm{d}v = \\frac{\\sqrt{3}}{2}s \\int_0^1 \\int_0^1 \\frac{w(u,v)}{\\sqrt{v^2 - v + 1}} \\,\\mathrm{d}u\\,\\mathrm{d}v\n$$\n\n### 4. 权重函数分析\n\n我们在变换后的坐标系中分析两个指定的权重函数。\n\n**情况 1：常数权重, $w_0(\\mathbf{r}') = 1$**\n权重就是 $w_0(u,v) = 1$。积分变为：\n$$\nI[w_0] = \\frac{\\sqrt{3}}{2}s \\int_0^1 \\left(\\int_0^1 \\mathrm{d}u\\right) \\frac{1}{\\sqrt{v^2 - v + 1}} \\,\\mathrm{d}v = \\frac{\\sqrt{3}}{2}s \\int_0^1 \\frac{1}{\\sqrt{v^2 - v + 1}} \\,\\mathrm{d}v\n$$\n\n**情况 2：重心权重, $w_1(\\mathbf{r}') = \\lambda_0(\\mathbf{r}')$**\n对应于顶点 $\\mathbf{r}_0 = \\mathbf{0}$ 的重心坐标 $\\lambda_0$ 在 Duffy 映射 $\\mathbf{r}' = u \\mathbf{p} + (1-u)\\mathbf{0}$ 下由 $\\lambda_0 = 1-u$ 给出，其中 $\\mathbf{p}$ 是 $\\mathbf{r}_0$ 对边上的一个点。因此，$w_1(u,v) = 1-u$。积分为：\n$$\nI[w_1] = \\frac{\\sqrt{3}}{2}s \\int_0^1 \\int_0^1 \\frac{1-u}{\\sqrt{v^2 - v + 1}} \\,\\mathrm{d}u\\,\\mathrm{d}v = \\frac{\\sqrt{3}}{2}s \\left(\\int_0^1 (1-u)\\,\\mathrm{d}u\\right) \\left(\\int_0^1 \\frac{\\mathrm{d}v}{\\sqrt{v^2 - v + 1}}\\right)\n$$\n由于 $\\int_0^1 (1-u)\\,\\mathrm{d}u = 1/2$，我们发现一个直接关系：\n$$\nI[w_1] = \\frac{1}{2} I[w_0]\n$$\n\n### 5. 解析解\n\n两个积分都取决于 $K = \\int_0^1 \\frac{\\mathrm{d}v}{\\sqrt{v^2 - v + 1}}$ 的值。我们通过配方法来求解：\n$$\nK = \\int_0^1 \\frac{\\mathrm{d}v}{\\sqrt{(v - 1/2)^2 + 3/4}}\n$$\n使用换元法 $x = v - 1/2$，积分变为：\n$$\nK = \\int_{-1/2}^{1/2} \\frac{\\mathrm{d}x}{\\sqrt{x^2 + (\\sqrt{3}/2)^2}} = \\left[ \\ln\\left(x + \\sqrt{x^2 + 3/4}\\right) \\right]_{-1/2}^{1/2}\n$$\n$$\nK = \\ln\\left(\\frac{1}{2} + \\sqrt{\\frac{1}{4} + \\frac{3}{4}}\\right) - \\ln\\left(-\\frac{1}{2} + \\sqrt{\\frac{1}{4} + \\frac{3}{4}}\\right) = \\ln\\left(\\frac{3}{2}\\right) - \\ln\\left(\\frac{1}{2}\\right) = \\ln(3)\n$$\n积分的解析表达式为：\n$$\nI_{\\text{analytic}}[w_0] = \\frac{\\sqrt{3}}{2}s \\ln(3)\n$$\n$$\nI_{\\text{analytic}}[w_1] = \\frac{\\sqrt{3}}{4}s \\ln(3)\n$$\n\n### 6. 数值求积与误差分析\n\n将张量积高斯-勒让德求积应用于 $(u,v) \\in [0,1]^2$ 上的正则化二维积分。由于被积函数是可分的，二维求积等价于两个一维求积的乘积。对于一个一般的可分被积函数 $f(u,v) = g(u)h(v)$，数值积分为：\n$$\n\\int_0^1\\int_0^1 g(u)h(v)\\,\\mathrm{d}u\\,\\mathrm{d}v \\approx \\left(\\sum_i w_i' g(u_i)\\right) \\left(\\sum_j w_j' h(v_j)\\right)\n$$\n其中 $(u_i, w_i')$ 和 $(v_j, w_j')$ 是缩放到区间 $[0,1]$ 上的一维高斯-勒让德节点和权重。\n\n对于两种权重情况，数值误差主要由积分 $K = \\int_0^1 (v^2 - v + 1)^{-1/2} \\,\\mathrm{d}v$ 的近似决定。对 $u$ 的积分涉及多项式（$1$ 和 $1-u$），任何阶数 $n \\ge 1$ 的高斯-勒让德法则都能精确积分。设 $K$ 的数值近似为 $K_{\\text{num}}$。\n\n数值为：\n$$\nI_{\\text{num}}[w_0] = \\frac{\\sqrt{3}}{2}s K_{\\text{num}} \\quad \\text{和} \\quad I_{\\text{num}}[w_1] = \\frac{\\sqrt{3}}{4}s K_{\\text{num}}\n$$\n$w_0$ 的相对误差为：\n$$\n\\varepsilon_0 = \\frac{|I_{\\text{num}}[w_0] - I_{\\text{analytic}}[w_0]|}{|I_{\\text{analytic}}[w_0]|} = \\frac{|\\frac{\\sqrt{3}}{2}s K_{\\text{num}} - \\frac{\\sqrt{3}}{2}s \\ln(3)|}{|\\frac{\\sqrt{3}}{2}s \\ln(3)|} = \\frac{|K_{\\text{num}} - \\ln(3)|}{|\\ln(3)|}\n$$\n$w_1$ 的相对误差是相同的：\n$$\n\\varepsilon_1 = \\frac{|I_{\\text{num}}[w_1] - I_{\\text{analytic}}[w_1]|}{|I_{\\text{analytic}}[w_1]|} = \\frac{|\\frac{\\sqrt{3}}{4}s K_{\\text{num}} - \\frac{\\sqrt{3}}{4}s \\ln(3)|}{|\\frac{\\sqrt{3}}{4}s \\ln(3)|} = \\frac{|K_{\\text{num}} - \\ln(3)|}{|\\ln(3)|}\n$$\n这表明相对误差与边长 $s$ 和权重函数（$w_0$ 或 $w_1$）的选择无关。因此，所有四种测试情况预计将产生相同的相对误差。使用足够高阶的求积（例如，$n=64$），$K$ 的正则被积函数可以被精确地计算，以至于 $K_{\\text{num}}$ 与 $\\ln(3)$ 的标准 `float64` 表示相匹配，从而导致相对误差为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes the relative error for singular triangle integrals regularized\n    by the Duffy transformation, comparing numerical results to analytic solutions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of (side_length s, weight_type w).\n    test_cases = [\n        (1.0, 'w0'),       # Case A\n        (1.0, 'w1'),       # Case B\n        (3.0, 'w0'),       # Case C\n        (1.0e-6, 'w0'),    # Case D\n    ]\n\n    results = []\n    \n    # Use a sufficiently high quadrature order to resolve the smooth integrand.\n    # For a smooth (C-infinity) integrand, Gauss-Legendre quadrature converges\n    # exponentially. An order of 64 is more than sufficient to reach\n    # machine precision for the functions in this problem.\n    N_POINTS = 64\n\n    # Pre-calculate Gauss-Legendre nodes and weights for the interval [0, 1].\n    # roots_legendre returns for [-1, 1], so we scale them.\n    nodes_m11, weights_m11 = roots_legendre(N_POINTS)\n    nodes_01 = (nodes_m11.astype(np.float64) + 1.0) / 2.0\n    weights_01 = weights_m11.astype(np.float64) / 2.0\n\n    # The analytic value of the core 1D integral K = integral(1/sqrt(v^2-v+1)) dv from 0 to 1\n    analytic_K = np.log(3.0)\n\n    # Numerically compute the integral K using Gauss-Legendre quadrature.\n    # The integrand is evaluated at the scaled nodes.\n    v_integrand_at_nodes = 1.0 / np.sqrt(nodes_01**2 - nodes_01 + 1.0)\n    numerical_K = np.sum(weights_01 * v_integrand_at_nodes)\n\n    for s, weight_type in test_cases:\n        if weight_type == 'w0':\n            # For w0(r') = 1, the transformed weight is 1. The integral over u is 1.\n            # I[w0] = (sqrt(3)/2)*s * integral_u(1 du) * integral_v(...) dv\n            #       = (sqrt(3)/2)*s * 1 * K\n            numerical_val = (np.sqrt(3.0) / 2.0) * s * numerical_K\n            analytic_val = (np.sqrt(3.0) / 2.0) * s * analytic_K\n\n        elif weight_type == 'w1':\n            # For w1(r') = lambda_0, the transformed weight is 1-u.\n            # The integral of (1-u) from 0 to 1 is exactly 0.5.\n            # Gauss-Legendre quadrature integrates polynomials exactly.\n            # I[w1] = (sqrt(3)/2)*s * integral_u(1-u du) * integral_v(...) dv\n            #       = (sqrt(3)/2)*s * 0.5 * K\n            numerical_val = (np.sqrt(3.0) / 4.0) * s * numerical_K\n            analytic_val = (np.sqrt(3.0) / 4.0) * s * analytic_K\n        \n        else:\n            raise ValueError(f\"Unknown weight type: {weight_type}\")\n\n        # Compute the relative error.\n        # Check for analytic_val being zero to avoid division by zero, though not expected here.\n        if np.abs(analytic_val) > 0:\n            rel_error = np.abs(numerical_val - analytic_val) / np.abs(analytic_val)\n        else:\n            rel_error = np.abs(numerical_val)\n            \n        results.append(rel_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在许多实际的电磁计算场景中，尤其是在计算电场积分方程（EFIE）的自作用项时，奇异点并不总是方便地位于单元的顶点上。本练习将Duffy变换的应用范围从顶点奇异性扩展到更普遍的内部奇异性情况。我们将学习如何通过将原始积分区域分割成共享奇异点的子三角形，然后在每个子区域上分别应用Duffy变换，从而展示该方法在处理更一般问题时的灵活性和强大功能。",
            "id": "3302713",
            "problem": "您的任务是实现一种数值积分方法，用于计算单个平坦三角形面板上 Rao–Wilton–Glisson (RWG) 测试中出现的典型电场积分方程 (EFIE) 自作用项。您需要使用 Duffy 变换来正则化弱奇异核。\n\n计算必须以数学上严谨且自洽的方式进行，从频域标量格林函数的基本定义和三角形的标准仿射参数化出发。\n\n频域中的 EFIE 涉及亥姆霍兹方程的标量格林函数，其定义为 $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{e^{-j k \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}}{4 \\pi \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}$，其中 $k$ 是波数。针对本问题，您将计算一个具有以下形式的典型自作用项积分：\n$$\nI = \\int_{T} \\phi(\\mathbf{r}) \\, \\frac{e^{-j k \\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert}}{\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert} \\, \\mathrm{d}S,\n$$\n其中 $T$ 是三维空间中的一个平坦三角形，其顶点为 $\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_2 \\in \\mathbb{R}^3$，$\\mathbf{r}_0$ 是一个严格位于 $T$ 内部的固定观测点，而 $\\phi(\\mathbf{r})$ 是一个代表 RWG 测试加权的标量权重。该积分在 $\\mathbf{r} = \\mathbf{r}_0$ 处是弱奇异的，必须使用 Duffy 变换进行正则化。\n\n您必须从以下基本出发点着手：\n- 使用频域标量格林函数的定义 $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{e^{-j k \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}}{4 \\pi \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}$ 及其在 $k=0$ 时的静态极限。\n- 使用三角形的标准仿射参数化和基本的多变量微积分，特别是涉及雅可比行列式的变量替换定理。\n- 使用 Duffy 变换，通过将共享点 $\\mathbf{r}_0$ 的一组子三角形映射到一个张量积域来消除奇异性。\n\n通过将 $T$ 分割为三个共享公共顶点 $\\mathbf{r}_0$ 的子三角形 $T_i$ 来推导一种消除奇异性的积分方法，即 $T_0 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_0,\\mathbf{v}_1\\}$、$T_1 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_1,\\mathbf{v}_2\\}$ 和 $T_2 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_2,\\mathbf{v}_0\\}$。在每个子三角形 $T_i = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{a},\\mathbf{b}\\}$ 上，应用 Duffy 映射\n$$\n\\mathbf{r}(\\rho,\\sigma) = \\mathbf{r}_0 + \\rho \\big((1-\\sigma)\\,(\\mathbf{a}-\\mathbf{r}_0) + \\sigma \\, (\\mathbf{b}-\\mathbf{r}_0)\\big), \\quad \\rho \\in [0,1], \\ \\sigma \\in [0,1],\n$$\n并推导其相应的雅可比行列式以及 $1/\\lVert \\mathbf{r}-\\mathbf{r}_0 \\rVert$ 奇异性的抵消过程。然后，为每个子三角形在 $[0,1] \\times [0,1]$ 上设计一个每维 N 个点的张量高斯-勒让德法则，并证明最终的被积函数是正则的。\n\n标量权重 $\\phi(\\mathbf{r})$ 必须是以下之一：\n- 常数权重 $\\phi(\\mathbf{r}) = 1$，或\n- 线性重心权重 $\\phi(\\mathbf{r}) = \\lambda_0(\\mathbf{r})$，即与原始三角形 $T$ 的顶点 $\\mathbf{v}_0$ 相关联的重心坐标。\n\n您必须实现一个程序，该程序：\n- 使用国际单位制 (SI)。所有坐标必须以米为单位，波数 $k$ 以弧度/米为单位，指数函数使用弧度。最终报告的数值误差必须是无量纲小数。\n- 对于每个测试用例，使用经过 Duffy 变换的张量积高斯-勒让德积分（每维 N 个点）计算积分 $I_N$，其中 $N \\in \\{2, 4, 8, 16, 32\\}$。\n- 对于每个测试用例，使用相同的方案（每维 $N_{\\text{ref}} = 80$ 个点）计算一个参考值 $I_{\\text{ref}}$。\n- 对于每个测试用例和每个 $N$，报告由下式定义的相对误差：\n$$\n\\varepsilon_N = \\frac{\\lvert I_N - I_{\\text{ref}} \\rvert}{\\lvert I_{\\text{ref}} \\rvert},\n$$\n其中对于复值积分，模指的是复数模。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的、以逗号分隔的列表形式的结果。输出必须将所有测试用例的结果聚合到一个列表的列表中，其中每个测试用例的内部列表包含对应于 $N \\in \\{2, 4, 8, 16, 32\\}$ 的五个相对误差。例如，包含三个测试用例的输出应如下所示：\n$[[\\varepsilon_2^{(1)},\\varepsilon_4^{(1)},\\varepsilon_8^{(1)},\\varepsilon_{16}^{(1)},\\varepsilon_{32}^{(1)}],[\\varepsilon_2^{(2)},\\ldots],[\\varepsilon_2^{(3)},\\ldots]]$。\n\n使用以下测试套件：\n- 测试用例 A（正常路径）：边长为 1 米的等边三角形，顶点为 $\\mathbf{v}_0 = (0,0,0)$、$\\mathbf{v}_1 = (1,0,0)$、$\\mathbf{v}_2 = (0.5,\\sqrt{3}/2,0)$；观测点 $\\mathbf{r}_0$ 位于形心 $\\mathbf{r}_0 = (\\tfrac{1}{3}, \\tfrac{\\sqrt{3}}{6}, 0)$；权重 $\\phi(\\mathbf{r}) = 1$；波数 $k = 0$ 弧度/米。\n- 测试用例 B（近顶点观测和线性权重）：三角形顶点为 $\\mathbf{v}_0 = (0,0,0)$、$\\mathbf{v}_1 = (1,0,0)$、$\\mathbf{v}_2 = (1.001, 0.05, 0)$；观测点 $\\mathbf{r}_0 = \\mathbf{v}_0 + 0.01 (\\mathbf{v}_1 - \\mathbf{v}_0) + 0.01 (\\mathbf{v}_2 - \\mathbf{v}_0)$；权重 $\\phi(\\mathbf{r}) = \\lambda_0(\\mathbf{r})$；波数 $k = 0$ 弧度/米。\n- 测试用例 C（振荡核）：与测试用例 A 相同的三角形和观测点；权重 $\\phi(\\mathbf{r}) = 1$；波数 $k = 10$ 弧度/米。\n\n您的实现应数值稳定，严格遵守 Duffy 变换来处理奇异性，并按规定报告相对误差列表。角度必须以弧度为单位。最终打印的输出必须只包含带数字列表的列表的单行内容，不得包含任何额外文本。",
            "solution": "该问题要求对电场积分方程 (EFIE) 在单个平坦三角形单元背景下产生的弱奇异积分进行数值评估。该积分由下式给出\n$$\nI = \\int_{T} \\phi(\\mathbf{r}) \\, \\frac{e^{-j k \\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert}}{\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert} \\, \\mathrm{d}S\n$$\n其中 $T$ 是 $\\mathbb{R}^3$ 中的一个三角形，顶点为 $\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_2$，$\\mathbf{r}_0$ 是一个严格位于 $T$ 内部的观测点，$k$ 是波数，$\\phi(\\mathbf{r})$ 是一个标量权重函数。当 $\\mathbf{r} \\to \\mathbf{r}_0$ 时，被积函数具有 $1/\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert$ 形式的弱奇异性。标准的积分方法会失效或表现出较差的收敛性。为了解决这个问题，我们采用 Duffy 变换来对积分进行正则化。\n\n第一步是将三角形 $T$ 分割为三个不重叠的子三角形 $T_0, T_1, T_2$，它们共享奇异点 $\\mathbf{r}_0$ 作为公共顶点。这些子三角形由 $\\mathbf{r}_0$ 和原始三角形的顶点对的凸包定义：\n$$\nT_0 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_0,\\mathbf{v}_1\\}, \\quad T_1 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_1,\\mathbf{v}_2\\}, \\quad T_2 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_2,\\mathbf{v}_0\\}\n$$\n总积分是这些子三角形上积分的总和：\n$$\nI = \\sum_{i=0}^{2} \\int_{T_i} \\phi(\\mathbf{r}) \\, \\frac{e^{-j k \\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert}}{\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert} \\, \\mathrm{d}S\n$$\n我们考虑一个任意子三角形 $T_i = \\operatorname{conv}\\{\\mathbf{r}_0, \\mathbf{a}, \\mathbf{b}\\}$。我们应用 Duffy 变换，它将单位正方形 $(\\rho, \\sigma) \\in [0,1] \\times [0,1]$ 映射到这个子三角形。该映射由下式给出：\n$$\n\\mathbf{r}(\\rho,\\sigma) = \\mathbf{r}_0 + \\rho \\big((1-\\sigma)\\,(\\mathbf{a}-\\mathbf{r}_0) + \\sigma \\, (\\mathbf{b}-\\mathbf{r}_0)\\big)\n$$\n我们定义两个从奇异点出发张成该子三角形的向量：$\\mathbf{u} = \\mathbf{a} - \\mathbf{r}_0$ 和 $\\mathbf{v} = \\mathbf{b} - \\mathbf{r}_0$。该映射简化为：\n$$\n\\mathbf{r}(\\rho,\\sigma) = \\mathbf{r}_0 + \\rho \\big((1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v}\\big)\n$$\n于是，从奇异点出发的距离向量为 $\\mathbf{r}(\\rho,\\sigma) - \\mathbf{r}_0 = \\rho \\big((1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v}\\big)$，其模长为 $\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert = \\rho \\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert$，因为 $\\rho \\in [0,1]$。该表达式中的 $\\rho$ 项是原始坐标系中奇异性的来源，因为 $\\rho \\to 0$ 对应于 $\\mathbf{r} \\to \\mathbf{r}_0$。\n\n为了进行变量替换，我们必须计算变换的雅可比行列式。面积元 $\\mathrm{d}S$ 变换为 $\\mathrm{d}S = \\lVert \\frac{\\partial \\mathbf{r}}{\\partial \\rho} \\times \\frac{\\partial \\mathbf{r}}{\\partial \\sigma} \\rVert \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\sigma$。偏导数为：\n$$\n\\frac{\\partial \\mathbf{r}}{\\partial \\rho} = (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v}\n$$\n$$\n\\frac{\\partial \\mathbf{r}}{\\partial \\sigma} = \\rho(-\\mathbf{u} + \\mathbf{v}) = \\rho(\\mathbf{v} - \\mathbf{u})\n$$\n叉积为：\n$$\n\\frac{\\partial \\mathbf{r}}{\\partial \\rho} \\times \\frac{\\partial \\mathbf{r}}{\\partial \\sigma} = \\big((1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v}\\big) \\times \\rho(\\mathbf{v} - \\mathbf{u}) = \\rho \\big[ (1-\\sigma)(\\mathbf{u} \\times \\mathbf{v}) - \\sigma(\\mathbf{v} \\times \\mathbf{u}) \\big] = \\rho (\\mathbf{u} \\times \\mathbf{v})\n$$\n该向量的模，即曲面积分的雅可比行列式，为：\n$$\nJ(\\rho,\\sigma) = \\lVert \\rho (\\mathbf{u} \\times \\mathbf{v}) \\rVert = \\rho \\lVert \\mathbf{u} \\times \\mathbf{v} \\rVert\n$$\n将这些表达式代入 $T_i$ 上的积分，我们得到：\n$$\nI_i = \\int_0^1 \\int_0^1 \\phi(\\mathbf{r}(\\rho,\\sigma)) \\frac{e^{-j k \\rho \\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert}}{\\rho \\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert} \\left( \\rho \\lVert \\mathbf{u} \\times \\mathbf{v} \\rVert \\right) \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\sigma\n$$\n雅可比行列式中的因子 $\\rho$ 巧妙地抵消了分母中的奇异项 $\\rho$。这就是 Duffy 变换正则化能力的精髓所在。变换后的积分结果为：\n$$\nI_i = \\int_0^1 \\int_0^1 \\phi(\\mathbf{r}(\\rho,\\sigma)) \\, \\frac{e^{-j k \\rho \\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert}}{\\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert} \\, \\lVert \\mathbf{u} \\times \\mathbf{v} \\rVert \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\sigma\n$$\n现在这个被积函数是正则的。分母 $\\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert$ 是一个向量的长度，该向量是 $\\mathbf{u}$ 和 $\\mathbf{v}$ 的凸组合。由于 $\\mathbf{r}_0, \\mathbf{a}, \\mathbf{b}$ 构成一个非退化三角形，$\\mathbf{u}$ 和 $\\mathbf{v}$ 不共线，因此对于 $\\sigma \\in [0,1]$，该分母永远不为零。被积函数是光滑的，可以使用标准的数值积分方法（如张量积高斯-勒让德法则）精确计算。\n\n权重函数 $\\phi(\\mathbf{r})$ 也必须用新坐标表示。\n如果 $\\phi(\\mathbf{r}) = 1$，它仍然是 $1$。\n如果 $\\phi(\\mathbf{r}) = \\lambda_0(\\mathbf{r})$，即 $\\mathbf{r}$ 相对于原始三角形 $T$ 的顶点 $\\mathbf{v}_0$ 的重心坐标，我们必须为每个积分点 $\\mathbf{r}(\\rho,\\sigma)$ 计算它。使用面积比公式，$\\lambda_0(\\mathbf{r})$ 由下式给出：\n$$\n\\lambda_0(\\mathbf{r}) = \\frac{\\text{Area}(\\mathbf{r}, \\mathbf{v}_1, \\mathbf{v}_2)}{\\text{Area}(\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_2)} = \\frac{\\frac{1}{2} \\lVert (\\mathbf{v}_1 - \\mathbf{r}) \\times (\\mathbf{v}_2 - \\mathbf{r}) \\rVert}{\\frac{1}{2} \\lVert (\\mathbf{v}_1 - \\mathbf{v}_0) \\times (\\mathbf{v}_2 - \\mathbf{v}_0) \\rVert} = \\frac{\\lVert (\\mathbf{v}_1 - \\mathbf{r}) \\times (\\mathbf{v}_2 - \\mathbf{r}) \\rVert}{\\lVert (\\mathbf{v}_1 - \\mathbf{v}_0) \\times (\\mathbf{v}_2 - \\mathbf{v}_0) \\rVert}\n$$\n该表达式的计算方法是，首先找到 $\\mathbf{r}(\\rho,\\sigma)$，然后将其代入公式。\n\n数值积分使用一个 N 点的张量积高斯-勒让德积分来执行。设 $(\\xi_m, w_m)_{m=1}^N$ 为 $[0,1]$ 上的高斯-勒让德点和权重。子三角形 $T_i$ 上的积分近似为：\n$$\nI_i \\approx \\sum_{m=1}^{N} \\sum_{n=1}^{N} w_m w_n F(\\xi_m, \\xi_n)\n$$\n其中 $F(\\rho,\\sigma)$ 是正则化的被积函数：\n$$\nF(\\rho,\\sigma) = \\phi(\\mathbf{r}(\\rho,\\sigma)) \\, \\frac{e^{-j k \\rho \\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert}}{\\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert} \\, \\lVert \\mathbf{u} \\times \\mathbf{v} \\rVert\n$$\n总积分 $I$ 是三个子三角形结果的总和。对于每个测试用例，我们针对几个不同的 $N$ 值计算积分 $I_N$，并使用一个大的 $N_{\\text{ref}}$ 计算一个高精度参考值 $I_{\\text{ref}}$。然后相对误差按 $\\varepsilon_N = \\lvert I_N - I_{\\text{ref}} \\rvert / \\lvert I_{\\text{ref}} \\rvert$ 计算，其中 $\\lvert \\cdot \\rvert$ 是复数模。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef get_gauss_legendre_quadrature_1d(n_points):\n    \"\"\"\n    Returns Gauss-Legendre quadrature points and weights for the interval [0, 1].\n    \n    Args:\n        n_points (int): The number of quadrature points.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing points and weights.\n    \"\"\"\n    points, weights = roots_legendre(n_points)\n    # roots_legendre returns for [-1, 1], so we map to [0, 1]\n    mapped_points = 0.5 * (points + 1.0)\n    mapped_weights = 0.5 * weights\n    return mapped_points, mapped_weights\n\ndef evaluate_integral_on_subtriangle(r0, a, b, k, v_all, phi_type, n_points):\n    \"\"\"\n    Evaluates the regularized integral on a subtriangle conv(r0, a, b).\n    \n    Args:\n        r0 (np.ndarray): The singular observation point.\n        a (np.ndarray): First vertex of the subtriangle base.\n        b (np.ndarray): Second vertex of the subtriangle base.\n        k (float): Wavenumber.\n        v_all (list[np.ndarray]): Vertices of the original triangle [v0, v1, v2].\n        phi_type (str): Type of weighting function ('constant' or 'barycentric').\n        n_points (int): Number of Gauss points per dimension.\n        \n    Returns:\n        complex: The complex value of the integral over the subtriangle.\n    \"\"\"\n    points, weights = get_gauss_legendre_quadrature_1d(n_points)\n    \n    u = a - r0\n    v = b - r0\n    \n    jac_const = np.linalg.norm(np.cross(u, v))\n    \n    v0, v1, v2 = v_all\n    bary_denom = 0.0\n    if phi_type == 'barycentric':\n        bary_denom = np.linalg.norm(np.cross(v1 - v0, v2 - v0))\n    \n    integral_sum = 0.0 + 0.0j\n    \n    rho_vals, w_rho = points, weights\n    sigma_vals, w_sigma = points, weights\n    \n    for i in range(n_points):\n        rho = rho_vals[i]\n        for j in range(n_points):\n            sigma = sigma_vals[j]\n            \n            # Current mapped point in the original space\n            r_vec = r0 + rho * ((1 - sigma) * u + sigma * v)\n            \n            # Evaluate weight function phi\n            phi_val = 1.0\n            if phi_type == 'barycentric':\n                # Barycentric coordinate lambda_0 relative to v0\n                bary_num = np.linalg.norm(np.cross(v1 - r_vec, v2 - r_vec))\n                if bary_denom > 1e-15:\n                    phi_val = bary_num / bary_denom\n                else:\n                    phi_val = 0.0\n            \n            # Evaluate the regularized integrand\n            denom_vec = (1 - sigma) * u + sigma * v\n            denom_norm = np.linalg.norm(denom_vec)\n            \n            if denom_norm  1e-15:\n                # Should not happen for non-degenerate triangles\n                integrand_val = 0.0 + 0.0j\n            else:\n                if k == 0:\n                    kernel_val = 1.0 / denom_norm\n                else:\n                    kernel_val = np.exp(-1j * k * rho * denom_norm) / denom_norm\n\n                integrand_val = phi_val * kernel_val * jac_const\n\n            integral_sum += w_rho[i] * w_sigma[j] * integrand_val\n            \n    return integral_sum\n\ndef duffy_quadrature(vertices, r0, k, phi_type, n_points):\n    \"\"\"\n    Computes the singular integral over a triangle using Duffy transformation.\n    \n    Args:\n        vertices (list[np.ndarray]): List of 3 vertices of the triangle.\n        r0 (np.ndarray): The singular observation point.\n        k (float): Wavenumber.\n        phi_type (str): Type of weighting function ('constant' or 'barycentric').\n        n_points (int): Number of Gauss points per dimension.\n        \n    Returns:\n        complex: The numerically computed integral value.\n    \"\"\"\n    v0, v1, v2 = vertices\n    \n    # Define the three subtriangles\n    sub_triangles = [\n        (v0, v1),\n        (v1, v2),\n        (v2, v0)\n    ]\n    \n    total_integral = 0.0 + 0.0j\n    for a, b in sub_triangles:\n        total_integral += evaluate_integral_on_subtriangle(r0, a, b, k, vertices, phi_type, n_points)\n        \n    return total_integral\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute relative errors.\n    \"\"\"\n    test_cases = [\n        # Test case A\n        {\n            \"name\": \"A\",\n            \"vertices\": [np.array([0., 0., 0.]), np.array([1., 0., 0.]), np.array([0.5, np.sqrt(3)/2, 0.])],\n            \"r0\": np.array([1./3., np.sqrt(3)/6., 0.]),\n            \"k\": 0.0,\n            \"phi_type\": \"constant\"\n        },\n        # Test case B\n        {\n            \"name\": \"B\",\n            \"vertices\": [np.array([0., 0., 0.]), np.array([1., 0., 0.]), np.array([1.001, 0.05, 0.])],\n            \"r0\": np.array([0., 0., 0.]) + 0.01 * (np.array([1., 0., 0.]) - np.array([0., 0., 0.])) + 0.01 * (np.array([1.001, 0.05, 0.]) - np.array([0., 0., 0.])),\n            \"k\": 0.0,\n            \"phi_type\": \"barycentric\"\n        },\n        # Test case C\n        {\n            \"name\": \"C\",\n            \"vertices\": [np.array([0., 0., 0.]), np.array([1., 0., 0.]), np.array([0.5, np.sqrt(3)/2, 0.])],\n            \"r0\": np.array([1./3., np.sqrt(3)/6., 0.]),\n            \"k\": 10.0,\n            \"phi_type\": \"constant\"\n        }\n    ]\n\n    N_vals = [2, 4, 8, 16, 32]\n    N_ref = 80\n    \n    all_results = []\n\n    for case in test_cases:\n        v = case[\"vertices\"]\n        r0 = case[\"r0\"]\n        k = case[\"k\"]\n        phi = case[\"phi_type\"]\n\n        I_ref = duffy_quadrature(v, r0, k, phi, N_ref)\n        \n        errors = []\n        for N in N_vals:\n            I_N = duffy_quadrature(v, r0, k, phi, N)\n            \n            # The problem asks for the integral of phi * G_kernel, where G_kernel is without 4*pi\n            # The relative error is |I_N - I_ref| / |I_ref|\n            if np.abs(I_ref) > 1e-15:\n                # If reference is zero, error is absolute difference\n                error = np.abs(I_N - I_ref) / np.abs(I_ref)\n            else:\n                error = np.abs(I_N - I_ref)\n            errors.append(error)\n        \n        all_results.append(errors)\n    \n    # Format the output as a string list of lists, without spaces\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "数值方法的正确性往往取决于一些微妙的实现细节，这些细节虽小，却至关重要。本练习聚焦于其中一个关键细节：三角形顶点的排序和方向。这个看似简单的选择直接影响Duffy变换中雅可比行列式的符号，如果处理不当，可能会引入难以察觉的符号错误，导致整个计算结果失效。通过对比一个“朴素”实现和一个“稳健”实现，本练习将揭示为何在编写科学计算代码时，必须对几何方向保持一致性和警惕性。",
            "id": "3302708",
            "problem": "在计算电磁学中，当评估具有弱奇异性的核函数（例如三维中的静态格林函数）时，奇异三角形积分会出现在边界积分公式中。考虑一个非退化三角形，其顶点为 $\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2 \\in \\mathbb{R}^2$，并且有一个奇异点恰好位于其中一个三角形顶点上，记为 $\\mathbf{r}_0$。使用重心（面积）坐标，设 $\\lambda_0(\\mathbf{r})$是与顶点 $\\mathbf{r}_0$ 相关联的标量线性节点基函数。定义弱奇异积分\n$$\nI = \\iint_{T} \\frac{\\lambda_0(\\mathbf{r})}{\\|\\mathbf{r} - \\mathbf{r}_0\\|} \\, dA,\n$$\n其中 $T$ 是三角形域，$\\|\\cdot\\|$ 表示欧几里得范数，$dA$ 是面积元。Duffy 变换将单位正方形 $[0,1]^2$ 映射到 $T$ 以正则化该可积奇异点。此变换的雅可比行列式取决于三角形的顶点排序以及边与映射的对齐方式。在实践中，如果定向不一致，可能会出现数值符号错误。\n\n您的任务是实现一个程序，该程序：\n- 指定并强制执行一个规则，对三角形顶点和从奇异角点发出的两条边进行排序，以使 Duffy 映射锚定在奇异顶点上并具有一致的逆时针定向。\n- 对每个测试用例，用两种方式数值计算积分 $I$：\n  1. 一种朴素的 Duffy 实现，将映射锚定在奇异顶点上，但保留另外两个顶点的输入循环次序，并使用带符号的雅可比行列式，如果定向为顺时针，可能会导致积分为负。\n  2. 一种定向一致的 Duffy 实现，循环旋转顶点列表，使奇异顶点位于首位，然后在必要时交换余下的两个顶点，以使带符号面积为正，从而确保雅可比行列式为正且与基函数求值对齐。\n\n您必须将您的推导和实现基于以下基本定义和事实：\n- 三角形上的重心坐标和线性节点基函数 $\\lambda_i(\\mathbf{r})$，满足 $\\lambda_i(\\mathbf{v}_j) = \\delta_{ij}$ 和 $\\sum_{i=0}^2 \\lambda_i(\\mathbf{r}) = 1$。\n- 从 $[0,1]^2$ 到锚定在一个角点的三角形的 Duffy 变换，以及雅可比行列式定义为偏导数矩阵的行列式。\n- 三角形的带符号面积与 $\\det\\big([\\mathbf{v}_1-\\mathbf{v}_0,\\mathbf{v}_2-\\mathbf{v}_0]\\big)$ 成正比，其符号表示逆时针与顺时针定向。\n\n不要使用任何预先提供的快捷公式。从这些基本定义出发，推导您需要的任何恒等式。\n\n测试套件：\n- A例（理想情况，已为逆时针）：顶点 $\\big[(0,0),(1,0),(0,1)\\big]$，奇异顶点索引 $0$ 对应于 $\\mathbf{r}_0 = (0,0)$。\n- B例（顺时针排序）：顶点 $\\big[(0,0),(0,1),(1,0)\\big]$，奇异顶点索引 $0$ 对应于 $\\mathbf{r}_0 = (0,0)$。\n- C例（奇异顶点不在列表首位，不等边，已旋转）：顶点 $\\big[(1.0,0.2),(0.0,0.0),(0.7,0.9)\\big]$，奇异顶点索引 $1$ 对应于 $\\mathbf{r}_0 = (0,0)$。\n\n对于每个案例，计算两个浮点数：\n- $I_{\\text{naive}}$：通过朴素映射计算的积分（锚定在奇异顶点，对另外两个顶点使用输入的循环次序，使用带符号的雅可比行列式）。\n- $I_{\\text{consistent}}$：通过首先旋转顶点使奇异顶点位于首位，然后在必要时交换另外两个顶点以使带符号面积为正，然后使用具有正雅可比行列式大小的相应 Duffy 映射计算的积分。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序如下\n$$\n\\big[I_{\\text{naive}}^{(A)}, I_{\\text{consistent}}^{(A)}, I_{\\text{naive}}^{(B)}, I_{\\text{consistent}}^{(B)}, I_{\\text{naive}}^{(C)}, I_{\\text{consistent}}^{(C)}\\big].\n$$\n所有输出必须是有限实数。不需要物理单位。角度（如果有）必须以弧度为单位，但指定的任务不需要角度。不使用百分比。应选择数值积分容差，以使每个报告值的相对精度至少达到 $10^{-8}$。",
            "solution": "我们从基本定义开始。设三角形的顶点为 $\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2 \\in \\mathbb{R}^2$，奇异点 $\\mathbf{r}_0$ 位于其中一个顶点上。重心坐标 $\\lambda_i(\\mathbf{r})$ 满足 $\\lambda_i(\\mathbf{v}_j) = \\delta_{ij}$，$\\sum_{i=0}^2 \\lambda_i(\\mathbf{r}) = 1$，且与奇异顶点相关联的线性节点基函数是 $\\lambda_0(\\mathbf{r})$。我们关心的积分是\n$$\nI = \\iint_{T} \\frac{\\lambda_0(\\mathbf{r})}{\\|\\mathbf{r}-\\mathbf{r}_0\\|} \\, dA.\n$$\n为了消除 $\\mathbf{r}_0$ 处的可积奇异点，我们使用 Duffy 变换，这是一个从单位正方形 $[0,1]^2$ 到锚定在奇异角点的三角形的映射。用 $\\mathbf{e}_1 = \\mathbf{v}_1 - \\mathbf{v}_0$ 和 $\\mathbf{e}_2 = \\mathbf{v}_2 - \\mathbf{v}_0$ 表示从 $\\mathbf{v}_0$（必须是奇异顶点，以使映射与奇异点对齐）发出的两条边。定义映射\n$$\n\\mathbf{r}(\\xi,\\eta) = \\mathbf{v}_0 + \\xi\\Big((1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2\\Big),\n\\quad (\\xi,\\eta)\\in[0,1]^2.\n$$\n根据构造，当 $\\xi=0$ 时，$\\mathbf{r} = \\mathbf{v}_0$；当 $\\xi=1$ 时，$\\mathbf{r}$ 描绘了从 $\\mathbf{v}_1$ 到 $\\mathbf{v}_2$ 的线段。此映射的雅可比行列式是以 $\\partial \\mathbf{r}/\\partial \\xi$ 和 $\\partial \\mathbf{r}/\\partial \\eta$ 为列的矩阵的行列式。我们计算\n$$\n\\frac{\\partial \\mathbf{r}}{\\partial \\xi} = (1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2, \\qquad\n\\frac{\\partial \\mathbf{r}}{\\partial \\eta} = \\xi(\\mathbf{e}_2 - \\mathbf{e}_1).\n$$\n因此，雅可比行列式为\n$$\nJ(\\xi,\\eta) = \\det\\left[\\frac{\\partial \\mathbf{r}}{\\partial \\xi}, \\frac{\\partial \\mathbf{r}}{\\partial \\eta}\\right]\n= \\det\\Big[(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2,\\ \\xi(\\mathbf{e}_2 - \\mathbf{e}_1)\\Big].\n$$\n利用行列式在二维中的双线性和反对称性，上式可简化为\n$$\nJ(\\xi,\\eta) = \\xi\\ \\det[\\mathbf{e}_1,\\mathbf{e}_2],\n$$\n该式与 $\\eta$ 无关。$\\det[\\mathbf{e}_1,\\mathbf{e}_2]$ 的符号表示定向：正数表示逆时针，负数表示顺时针。\n\n现在我们在此映射下表示 $\\lambda_0(\\mathbf{r})$。由于 $\\mathbf{r}(\\xi,\\eta)$ 是 $\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2$ 的一个凸组合，其权重为 $\\lambda_0 = 1-\\xi$，$\\lambda_1 = \\xi (1-\\eta)$ 和 $\\lambda_2 = \\xi \\eta$，我们有\n$$\n\\lambda_0(\\mathbf{r}(\\xi,\\eta)) = 1 - \\xi.\n$$\n我们还表示到奇异点的距离：\n$$\n\\|\\mathbf{r}(\\xi,\\eta) - \\mathbf{r}_0\\| = \\|\\mathbf{r}(\\xi,\\eta) - \\mathbf{v}_0\\| = \\|\\xi((1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2)\\| = \\xi \\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|.\n$$\n将这些代入被积函数中，得到\n$$\n\\frac{\\lambda_0(\\mathbf{r}(\\xi,\\eta))}{\\|\\mathbf{r}(\\xi,\\eta)-\\mathbf{r}_0\\|} = \\frac{1-\\xi}{\\xi \\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|}.\n$$\n如果我们的目标是计算具有正测度的物理积分，面积元会变换为 $dA = |J(\\xi,\\eta)|\\, d\\xi\\, d\\eta$。有两种计算选择可以凸显定向问题：\n\n1. 朴素方法：将映射锚定在奇异顶点，但保留另外两个顶点的输入循环次序，并直接使用带符号的雅可比行列式 $J(\\xi,\\eta) = \\xi \\det[\\mathbf{e}_1,\\mathbf{e}_2]$，不取绝对值也不为修正定向而重新排序。计算出的积分为\n$$\nI_{\\text{naive}} = \\int_0^1 \\int_0^1 \\frac{1-\\xi}{\\xi \\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|} \\cdot \\Big(\\xi \\det[\\mathbf{e}_1,\\mathbf{e}_2]\\Big)\\, d\\xi\\, d\\eta.\n$$\n2. 定向一致方法：循环旋转顶点，使奇异顶点位于首位，然后在必要时交换另外两个顶点，以使 $\\det[\\mathbf{e}_1,\\mathbf{e}_2]  0$。使用正的雅可比行列式大小 $|J(\\xi,\\eta)| = \\xi\\, |\\det[\\mathbf{e}_1,\\mathbf{e}_2]|$。计算出的积分为\n$$\nI_{\\text{consistent}} = \\int_0^1 \\int_0^1 \\frac{1-\\xi}{\\xi \\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|} \\cdot \\Big(\\xi\\, |\\det[\\mathbf{e}_1,\\mathbf{e}_2]|\\Big)\\, d\\xi\\, d\\eta,\n$$\n其中 $\\mathbf{e}_1, \\mathbf{e}_2$ 取自经过定向校正的排序。\n\n在两种情况下，因子 $\\xi$ 都被消去，被积函数变得可分离：\n$$\nI_{\\square} = \\left(\\int_0^1 (1-\\xi)\\, d\\xi \\right) \\left(\\int_0^1 \\frac{\\kappa_{\\square}}{\\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|}\\, d\\eta \\right),\n$$\n其中 $\\kappa_{\\text{naive}} = \\det[\\mathbf{e}_1,\\mathbf{e}_2]$ 且 $\\kappa_{\\text{consistent}} = |\\det[\\mathbf{e}_1,\\mathbf{e}_2]|$，下标 $\\square$ 表示朴素或一致性评估。关于 $\\xi$ 的积分计算结果为\n$$\n\\int_0^1 (1-\\xi)\\, d\\xi = \\frac{1}{2}.\n$$\n因此\n$$\nI_{\\square} = \\frac{1}{2} \\int_0^1 \\frac{\\kappa_{\\square}}{\\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|}\\, d\\eta.\n$$\n分母仅取决于 $\\mathbf{e}_1$ 和 $\\mathbf{e}_2$ 的位置。交换 $\\mathbf{e}_1$ 和 $\\mathbf{e}_2$ 会反转线段的参数化，但由于映射 $\\eta \\mapsto 1-\\eta$ 保持了对称范数的积分不变，因此在 $\\eta \\in [0,1]$ 上的积分保持不变。因此，两种方法之间的唯一区别在于 $\\kappa_{\\square}$ 所携带的符号。如果输入的三角形以奇异顶点为首按顺时针列出，则 $\\det[\\mathbf{e}_1,\\mathbf{e}_2]  0$，$I_{\\text{naive}}$ 将为负，而 $I_{\\text{consistent}}$ 将为正且大小相同。这说明了为什么一致的定向可以避免符号错误：通过强制 $\\det[\\mathbf{e}_1,\\mathbf{e}_2]  0$，雅可比行列式的大小为正，积分具有正确的符号，而基函数 $\\lambda_0(\\mathbf{r}) = 1-\\xi$ 也是相对于同一定向进行一致求值的。\n\n避免符号错误并将奇异角点与 Duffy 映射对齐的算法步骤：\n- 给定一个输入顶点列表 $\\big[\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2\\big]$ 和奇异顶点的索引 $s \\in \\{0,1,2\\}$，循环旋转列表，使奇异顶点位于首位：$\\big[\\mathbf{v}_s,\\mathbf{v}_{s+1 \\bmod 3},\\mathbf{v}_{s+2 \\bmod 3}\\big]$。\n- 计算 $\\mathbf{e}_1 = \\mathbf{v}_1-\\mathbf{v}_0$ 和 $\\mathbf{e}_2 = \\mathbf{v}_2-\\mathbf{v}_0$，然后计算带符号面积的行列式 $\\det[\\mathbf{e}_1,\\mathbf{e}_2]$。\n- 如果 $\\det[\\mathbf{e}_1,\\mathbf{e}_2]  0$，交换 $\\mathbf{v}_1$ 和 $\\mathbf{v}_2$，使行列式变为正。这也交换了两条局部边，从而使雅可比行列式和基函数的求值保持一致对齐。\n- 使用锚定在 $\\mathbf{v}_0$ 的 Duffy 映射并进行数值积分。\n\n对于数值评估，可分离形式产生了一个在 $\\eta \\in [0,1]$ 上的一维积分：\n$$\nI_{\\text{naive}} = \\frac{1}{2}\\, \\det[\\mathbf{e}_1,\\mathbf{e}_2]\\ \\int_0^1 \\frac{d\\eta}{\\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|},\n\\quad\nI_{\\text{consistent}} = \\frac{1}{2}\\, \\big|\\det[\\mathbf{e}_1,\\mathbf{e}_2]\\big|\\ \\int_0^1 \\frac{d\\eta}{\\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|}.\n$$\n这个积分没有奇异性，因为对于非退化三角形，$\\mathbf{e}_1$ 和 $\\mathbf{e}_2$ 是不共线的。\n\n测试套件解释：\n- A例：$\\big[(0,0),(1,0),(0,1)\\big]$，奇异点索引为0，已是逆时针，因此 $I_{\\text{naive}}$ 和 $I_{\\text{consistent}}$ 均为正且相等。\n- B例：$\\big[(0,0),(0,1),(1,0)\\big]$，奇异点索引为0，是顺时针，因此 $I_{\\text{naive}}$ 是 A例值的负数，而 $I_{\\text{consistent}}$ 等于 A例的正值。\n- C例：$\\big[(1.0,0.2),(0.0,0.0),(0.7,0.9)\\big]$，奇异点索引为1，需要旋转以首先锚定奇异顶点；如果结果排序是顺时针，则朴素结果可能为负，而一致性结果为正。A例和B例的两个一致性结果匹配，而C例产生一个不同的正数，因为几何形状不同。\n\n该程序实现了这些步骤，使用具有严格容差的数值求积来评估一维积分，以达到至少 $10^{-8}$ 的相对精度，并按指定顺序将最终结果打印为单个列表。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef signed_area_det(e1: np.ndarray, e2: np.ndarray) - float:\n    # 2D cross product (determinant of [e1, e2])\n    return e1[0]*e2[1] - e1[1]*e2[0]\n\ndef rotate_vertices(vertices, start_index):\n    # Cyclically rotate so that vertices[start_index] becomes first\n    return vertices[start_index:] + vertices[:start_index]\n\ndef duffy_integral(vertices, singular_index, orientation_mode=\"naive\"):\n    \"\"\"\n    Compute I = ∫_T lambda0(r)/||r - r0|| dA using Duffy mapping anchored at the singular vertex.\n    orientation_mode: \"naive\" preserves input cyclic order after rotation to make singular first,\n                      uses signed determinant in the Jacobian.\n                      \"consistent\" enforces positive orientation by swapping v1,v2 if needed,\n                      uses positive determinant magnitude.\n    \"\"\"\n    # Ensure singular vertex is first by rotation\n    verts = rotate_vertices(vertices, singular_index)\n    v0 = np.array(verts[0], dtype=float)\n    v1 = np.array(verts[1], dtype=float)\n    v2 = np.array(verts[2], dtype=float)\n\n    # Edge vectors from the singular corner\n    e1 = v1 - v0\n    e2 = v2 - v0\n\n    det = signed_area_det(e1, e2)\n\n    if orientation_mode == \"consistent\":\n        # Enforce positive orientation\n        if det  0.0:\n            # swap e1 and e2\n            e1, e2 = e2, e1\n            det = -det  # now positive\n\n        det_factor = abs(det)\n    elif orientation_mode == \"naive\":\n        # Keep original cyclic order and signed determinant\n        det_factor = det\n    else:\n        raise ValueError(\"orientation_mode must be 'naive' or 'consistent'\")\n\n    # Define the 1D integrand over eta in [0,1]: det_factor / ||(1-eta)*e1 + eta*e2||\n    def integrand_eta(eta):\n        s = (1.0 - eta) * e1 + eta * e2\n        norm_s = np.hypot(s[0], s[1])\n        return det_factor / norm_s\n\n    # Perform numerical integration with tight tolerances\n    integ_val, _ = quad(integrand_eta, 0.0, 1.0, epsabs=1e-12, epsrel=1e-12, limit=200)\n    return 0.5 * integ_val\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (vertices list, singular_index)\n    test_cases = [\n        ([(0.0, 0.0), (1.0, 0.0), (0.0, 1.0)], 0),  # Case A\n        ([(0.0, 0.0), (0.0, 1.0), (1.0, 0.0)], 0),  # Case B\n        ([(1.0, 0.2), (0.0, 0.0), (0.7, 0.9)], 1),  # Case C\n    ]\n\n    results = []\n    for vertices, sidx in test_cases:\n        I_naive = duffy_integral(vertices, sidx, orientation_mode=\"naive\")\n        I_consistent = duffy_integral(vertices, sidx, orientation_mode=\"consistent\")\n        results.append(I_naive)\n        results.append(I_consistent)\n\n    # Final print statement in the exact required format.\n    # Use full precision string conversion for clarity.\n    print(f\"[{','.join(map(lambda x: f'{x:.15g}', results))}]\")\n\nsolve()\n```"
        }
    ]
}