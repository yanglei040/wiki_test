{
    "hands_on_practices": [
        {
            "introduction": "This first exercise guides you through the fundamental implementation of the Duffy transformation for a weakly singular integral, a common task in boundary element methods. You will start from first principles to partition a triangle around an interior singular point, apply the Duffy coordinate map to regularize the singularity, and use numerical quadrature to compute the integral . By observing the method's convergence as the number of quadrature points increases, you will gain a practical understanding of its power and effectiveness.",
            "id": "3302713",
            "problem": "You are tasked with implementing a numerical quadrature to evaluate a representative Electric Field Integral Equation (EFIE) self-term arising in Rao–Wilton–Glisson (RWG) testing on a single flat triangular panel, using the Duffy transformation to regularize the weakly singular kernel. The computation must be performed in a mathematically rigorous and self-contained fashion, starting from fundamental definitions of the frequency-domain scalar Green’s function and a standard affine parameterization of a triangle.\n\nThe EFIE in frequency domain involves the scalar Green’s function of the Helmholtz equation, defined by $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{e^{-j k \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}}{4 \\pi \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}$, where $k$ is the wavenumber. For the purpose of this problem, you will compute a representative self-term integral of the form\n$$\nI = \\int_{T} \\phi(\\mathbf{r}) \\, \\frac{e^{-j k \\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert}}{\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert} \\, \\mathrm{d}S,\n$$\nwhere $T$ is a single flat triangle in three-dimensional space with vertices $\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_2 \\in \\mathbb{R}^3$, $\\mathbf{r}_0$ is a fixed observation point strictly inside $T$, and $\\phi(\\mathbf{r})$ is a scalar weight that proxies an RWG test weighting. The integral is weakly singular at $\\mathbf{r} = \\mathbf{r}_0$ and must be regularized using a Duffy transformation.\n\nYou must proceed from the following fundamental base:\n- Use the scalar frequency-domain Green’s function definition $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{e^{-j k \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}}{4 \\pi \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}$ and its static limit when $k = 0$.\n- Use a standard affine parameterization of a triangle and basic multivariable calculus, specifically the change of variables theorem with Jacobians.\n- Use the Duffy transformation to remove the singularity by mapping from a fan of subtriangles sharing the point $\\mathbf{r}_0$ to a tensor-product domain.\n\nDerive a singularity-resolving quadrature by splitting $T$ into three subtriangles $T_i$ that share $\\mathbf{r}_0$ as a common vertex, namely $T_0 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_0,\\mathbf{v}_1\\}$, $T_1 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_1,\\mathbf{v}_2\\}$, and $T_2 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_2,\\mathbf{v}_0\\}$. On each subtriangle $T_i = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{a},\\mathbf{b}\\}$, apply the Duffy mapping\n$$\n\\mathbf{r}(\\rho,\\sigma) = \\mathbf{r}_0 + \\rho \\big((1-\\sigma)\\,(\\mathbf{a}-\\mathbf{r}_0) + \\sigma \\, (\\mathbf{b}-\\mathbf{r}_0)\\big), \\quad \\rho \\in [0,1], \\ \\sigma \\in [0,1],\n$$\nand derive the corresponding Jacobian and the cancellation of the $1/\\lVert \\mathbf{r}-\\mathbf{r}_0 \\rVert$ singularity. Then devise a tensor Gauss–Legendre rule with $N$ points per dimension on $[0,1] \\times [0,1]$ for each subtriangle, showing that the resulting integrand is regular.\n\nThe scalar weight $\\phi(\\mathbf{r})$ must be one of the following:\n- A constant weight $\\phi(\\mathbf{r}) = 1$, or\n- A linear barycentric weight $\\phi(\\mathbf{r}) = \\lambda_0(\\mathbf{r})$, the barycentric coordinate associated with vertex $\\mathbf{v}_0$ of the original triangle $T$.\n\nYou must implement a program that:\n- Uses the International System of Units (SI). All coordinates must be in meters, the wavenumber $k$ in radians per meter, and exponentials use radians. The final reported numerical errors must be dimensionless decimals.\n- For each test case, computes the integral $I_N$ using the Duffy-transformed tensor-product Gauss–Legendre quadrature with $N$ points per dimension, for $N \\in \\{2, 4, 8, 16, 32\\}$.\n- For each test case, computes a reference value $I_{\\text{ref}}$ using the same scheme with $N_{\\text{ref}} = 80$ points per dimension.\n- For each test case and each $N$, reports the relative error defined by\n$$\n\\varepsilon_N = \\frac{\\lvert I_N - I_{\\text{ref}} \\rvert}{\\lvert I_{\\text{ref}} \\rvert},\n$$\nwhere for complex-valued integrals the magnitude denotes the complex modulus.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The output must aggregate the results of all test cases into a single list of lists, where the inner list for each test case contains the five relative errors corresponding to $N \\in \\{2, 4, 8, 16, 32\\}$. For example, an output with three test cases should look like\n$[[\\varepsilon_2^{(1)},\\varepsilon_4^{(1)},\\varepsilon_8^{(1)},\\varepsilon_{16}^{(1)},\\varepsilon_{32}^{(1)}],[\\varepsilon_2^{(2)},\\ldots],[\\varepsilon_2^{(3)},\\ldots]]$.\n\nUse the following test suite:\n- Test case A (happy path): Equilateral triangle of side length $1$ meter with vertices $\\mathbf{v}_0 = (0,0,0)$, $\\mathbf{v}_1 = (1,0,0)$, $\\mathbf{v}_2 = (0.5,\\sqrt{3}/2,0)$; observation point $\\mathbf{r}_0$ at the centroid $\\mathbf{r}_0 = (\\tfrac{1}{3}, \\tfrac{\\sqrt{3}}{6}, 0)$; weight $\\phi(\\mathbf{r}) = 1$; wavenumber $k = 0$ radians per meter.\n- Test case B (near-vertex observation and linear weight): Triangle with vertices $\\mathbf{v}_0 = (0,0,0)$, $\\mathbf{v}_1 = (1,0,0)$, $\\mathbf{v}_2 = (1.001, 0.05, 0)$; observation point $\\mathbf{r}_0 = \\mathbf{v}_0 + 0.01 (\\mathbf{v}_1 - \\mathbf{v}_0) + 0.01 (\\mathbf{v}_2 - \\mathbf{v}_0)$; weight $\\phi(\\mathbf{r}) = \\lambda_0(\\mathbf{r})$; wavenumber $k = 0$ radians per meter.\n- Test case C (oscillatory kernel): Same triangle and observation point as in Test case A; weight $\\phi(\\mathbf{r}) = 1$; wavenumber $k = 10$ radians per meter.\n\nYour implementation should be numerically stable, adhere strictly to the Duffy transformation to handle the singularity, and report the relative error lists as specified. Angles must be in radians. The final printed output must contain only the single line with the numeric list of lists and no additional text.",
            "solution": "The problem requires the numerical evaluation of a weakly singular integral arising in the context of the Electric Field Integral Equation (EFIE) for a single flat triangular element. The integral is given by\n$$\nI = \\int_{T} \\phi(\\mathbf{r}) \\, \\frac{e^{-j k \\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert}}{\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert} \\, \\mathrm{d}S\n$$\nwhere $T$ is a triangle in $\\mathbb{R}^3$ with vertices $\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_2$, $\\mathbf{r}_0$ is an observation point strictly inside $T$, $k$ is the wavenumber, and $\\phi(\\mathbf{r})$ is a scalar weighting function. The integrand has a weak singularity of the form $1/\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert$ as $\\mathbf{r} \\to \\mathbf{r}_0$. Standard quadrature methods would fail or exhibit poor convergence. To overcome this, a Duffy transformation is employed to regularize the integral.\n\nThe first step is to partition the triangle $T$ into three non-overlapping subtriangles, $T_0, T_1$, and $T_2$, which share the singular point $\\mathbf{r}_0$ as a common vertex. The subtriangles are defined by the convex hulls of $\\mathbf{r}_0$ and pairs of vertices of the original triangle:\n$$\nT_0 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_0,\\mathbf{v}_1\\}, \\quad T_1 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_1,\\mathbf{v}_2\\}, \\quad T_2 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_2,\\mathbf{v}_0\\}\n$$\nThe total integral is the sum of the integrals over these subtriangles:\n$$\nI = \\sum_{i=0}^{2} \\int_{T_i} \\phi(\\mathbf{r}) \\, \\frac{e^{-j k \\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert}}{\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert} \\, \\mathrm{d}S\n$$\nLet us consider a generic subtriangle $T_i = \\operatorname{conv}\\{\\mathbf{r}_0, \\mathbf{a}, \\mathbf{b}\\}$. We apply the Duffy transformation, which maps the unit square $(\\rho, \\sigma) \\in [0,1] \\times [0,1]$ to this subtriangle. The mapping is given by:\n$$\n\\mathbf{r}(\\rho,\\sigma) = \\mathbf{r}_0 + \\rho \\big((1-\\sigma)\\,(\\mathbf{a}-\\mathbf{r}_0) + \\sigma \\, (\\mathbf{b}-\\mathbf{r}_0)\\big)\n$$\nLet's define two vectors spanning the subtriangle from the singular point: $\\mathbf{u} = \\mathbf{a} - \\mathbf{r}_0$ and $\\mathbf{v} = \\mathbf{b} - \\mathbf{r}_0$. The mapping simplifies to:\n$$\n\\mathbf{r}(\\rho,\\sigma) = \\mathbf{r}_0 + \\rho \\big((1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v}\\big)\n$$\nThe distance vector from the singularity is then $\\mathbf{r}(\\rho,\\sigma) - \\mathbf{r}_0 = \\rho \\big((1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v}\\big)$, and its magnitude is $\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert = \\rho \\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert$, since $\\rho \\in [0,1]$. The term $\\rho$ in this expression is the source of the singularity in the original coordinate system, as $\\rho \\to 0$ corresponds to $\\mathbf{r} \\to \\mathbf{r}_0$.\n\nTo perform a change of variables, we must compute the Jacobian of the transformation. The surface element $\\mathrm{d}S$ transforms as $\\mathrm{d}S = \\lVert \\frac{\\partial \\mathbf{r}}{\\partial \\rho} \\times \\frac{\\partial \\mathbf{r}}{\\partial \\sigma} \\rVert \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\sigma$. The partial derivatives are:\n$$\n\\frac{\\partial \\mathbf{r}}{\\partial \\rho} = (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v}\n$$\n$$\n\\frac{\\partial \\mathbf{r}}{\\partial \\sigma} = \\rho(-\\mathbf{u} + \\mathbf{v}) = \\rho(\\mathbf{v} - \\mathbf{u})\n$$\nThe cross product is:\n$$\n\\frac{\\partial \\mathbf{r}}{\\partial \\rho} \\times \\frac{\\partial \\mathbf{r}}{\\partial \\sigma} = \\big((1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v}\\big) \\times \\rho(\\mathbf{v} - \\mathbf{u}) = \\rho \\big[ (1-\\sigma)(\\mathbf{u} \\times \\mathbf{v}) - \\sigma(\\mathbf{v} \\times \\mathbf{u}) \\big] = \\rho (\\mathbf{u} \\times \\mathbf{v})\n$$\nThe magnitude of this vector, which is the Jacobian determinant for the surface integral, is:\n$$\nJ(\\rho,\\sigma) = \\lVert \\rho (\\mathbf{u} \\times \\mathbf{v}) \\rVert = \\rho \\lVert \\mathbf{u} \\times \\mathbf{v} \\rVert\n$$\nSubstituting these expressions into the integral over $T_i$, we get:\n$$\nI_i = \\int_0^1 \\int_0^1 \\phi(\\mathbf{r}(\\rho,\\sigma)) \\frac{e^{-j k \\rho \\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert}}{\\rho \\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert} \\left( \\rho \\lVert \\mathbf{u} \\times \\mathbf{v} \\rVert \\right) \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\sigma\n$$\nThe factor $\\rho$ in the Jacobian elegantly cancels the singular term $\\rho$ in the denominator. This is the essence of the Duffy transformation's regularizing power. The resulting transformed integral is:\n$$\nI_i = \\int_0^1 \\int_0^1 \\phi(\\mathbf{r}(\\rho,\\sigma)) \\, \\frac{e^{-j k \\rho \\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert}}{\\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert} \\, \\lVert \\mathbf{u} \\times \\mathbf{v} \\rVert \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\sigma\n$$\nThis integrand is now regular. The denominator $\\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert$ is the length of a vector that is a convex combination of $\\mathbf{u}$ and $\\mathbf{v}$. Since $\\mathbf{r}_0, \\mathbf{a}, \\mathbf{b}$ form a non-degenerate triangle, $\\mathbf{u}$ and $\\mathbf{v}$ are not collinear, and this denominator is never zero for $\\sigma \\in [0,1]$. The integrand is smooth and can be evaluated accurately using standard numerical quadrature, such as a tensor-product Gauss-Legendre rule.\n\nThe weighting function $\\phi(\\mathbf{r})$ must also be expressed in the new coordinates.\nIf $\\phi(\\mathbf{r}) = 1$, it remains $1$.\nIf $\\phi(\\mathbf{r}) = \\lambda_0(\\mathbf{r})$, the barycentric coordinate of $\\mathbf{r}$ with respect to vertex $\\mathbf{v}_0$ of the original triangle $T$, we must compute it for each quadrature point $\\mathbf{r}(\\rho,\\sigma)$. Using the area ratio formula, $\\lambda_0(\\mathbf{r})$ is given by:\n$$\n\\lambda_0(\\mathbf{r}) = \\frac{\\text{Area}(\\mathbf{r}, \\mathbf{v}_1, \\mathbf{v}_2)}{\\text{Area}(\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_2)} = \\frac{\\frac{1}{2} \\lVert (\\mathbf{v}_1 - \\mathbf{r}) \\times (\\mathbf{v}_2 - \\mathbf{r}) \\rVert}{\\frac{1}{2} \\lVert (\\mathbf{v}_1 - \\mathbf{v}_0) \\times (\\mathbf{v}_2 - \\mathbf{v}_0) \\rVert} = \\frac{\\lVert (\\mathbf{v}_1 - \\mathbf{r}) \\times (\\mathbf{v}_2 - \\mathbf{r}) \\rVert}{\\lVert (\\mathbf{v}_1 - \\mathbf{v}_0) \\times (\\mathbf{v}_2 - \\mathbf{v}_0) \\rVert}\n$$\nThis expression is evaluated by first finding $\\mathbf{r}(\\rho,\\sigma)$ and then substituting it into the formula.\n\nThe numerical integration is performed using a tensor-product Gauss-Legendre quadrature with $N$ points. Let $(\\xi_m, w_m)_{m=1}^N$ be the Gauss-Legendre points and weights on $[0,1]$. The integral over a subtriangle $T_i$ is approximated by:\n$$\nI_i \\approx \\sum_{m=1}^{N} \\sum_{n=1}^{N} w_m w_n F(\\xi_m, \\xi_n)\n$$\nwhere $F(\\rho,\\sigma)$ is the regularized integrand:\n$$\nF(\\rho,\\sigma) = \\phi(\\mathbf{r}(\\rho,\\sigma)) \\, \\frac{e^{-j k \\rho \\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert}}{\\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert} \\, \\lVert \\mathbf{u} \\times \\mathbf{v} \\rVert\n$$\nThe total integral $I$ is the sum of the results from the three subtriangles. For each test case, we compute the integral $I_N$ for several values of $N$, along with a high-precision reference value $I_{\\text{ref}}$ using a large $N_{\\text{ref}}$. The relative error is then calculated as $\\varepsilon_N = \\lvert I_N - I_{\\text{ref}} \\rvert / \\lvert I_{\\text{ref}} \\rvert$, where $\\lvert \\cdot \\rvert$ is the complex modulus.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef get_gauss_legendre_quadrature_1d(n_points):\n    \"\"\"\n    Returns Gauss-Legendre quadrature points and weights for the interval [0, 1].\n    \n    Args:\n        n_points (int): The number of quadrature points.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing points and weights.\n    \"\"\"\n    points, weights = roots_legendre(n_points)\n    # roots_legendre returns for [-1, 1], so we map to [0, 1]\n    mapped_points = 0.5 * (points + 1.0)\n    mapped_weights = 0.5 * weights\n    return mapped_points, mapped_weights\n\ndef evaluate_integral_on_subtriangle(r0, a, b, k, v_all, phi_type, n_points):\n    \"\"\"\n    Evaluates the regularized integral on a subtriangle conv(r0, a, b).\n    \n    Args:\n        r0 (np.ndarray): The singular observation point.\n        a (np.ndarray): First vertex of the subtriangle base.\n        b (np.ndarray): Second vertex of the subtriangle base.\n        k (float): Wavenumber.\n        v_all (list[np.ndarray]): Vertices of the original triangle [v0, v1, v2].\n        phi_type (str): Type of weighting function ('constant' or 'barycentric').\n        n_points (int): Number of Gauss points per dimension.\n        \n    Returns:\n        complex: The complex value of the integral over the subtriangle.\n    \"\"\"\n    points, weights = get_gauss_legendre_quadrature_1d(n_points)\n    \n    u = a - r0\n    v = b - r0\n    \n    jac_const = np.linalg.norm(np.cross(u, v))\n    \n    v0, v1, v2 = v_all\n    bary_denom = 0.0\n    if phi_type == 'barycentric':\n        bary_denom = np.linalg.norm(np.cross(v1 - v0, v2 - v0))\n    \n    integral_sum = 0.0 + 0.0j\n    \n    rho_vals, w_rho = points, weights\n    sigma_vals, w_sigma = points, weights\n    \n    for i in range(n_points):\n        rho = rho_vals[i]\n        for j in range(n_points):\n            sigma = sigma_vals[j]\n            \n            # Current mapped point in the original space\n            r_vec = r0 + rho * ((1 - sigma) * u + sigma * v)\n            \n            # Evaluate weight function phi\n            phi_val = 1.0\n            if phi_type == 'barycentric':\n                # Barycentric coordinate lambda_0 relative to v0\n                bary_num = np.linalg.norm(np.cross(v1 - r_vec, v2 - r_vec))\n                if bary_denom > 1e-15:\n                    phi_val = bary_num / bary_denom\n                else:\n                    phi_val = 0.0\n            \n            # Evaluate the regularized integrand\n            denom_vec = (1 - sigma) * u + sigma * v\n            denom_norm = np.linalg.norm(denom_vec)\n            \n            if denom_norm  1e-15:\n                # Should not happen for non-degenerate triangles\n                integrand_val = 0.0 + 0.0j\n            else:\n                if k == 0:\n                    kernel_val = 1.0 / denom_norm\n                else:\n                    kernel_val = np.exp(-1j * k * rho * denom_norm) / denom_norm\n\n                integrand_val = phi_val * kernel_val * jac_const\n\n            integral_sum += w_rho[i] * w_sigma[j] * integrand_val\n            \n    return integral_sum\n\ndef duffy_quadrature(vertices, r0, k, phi_type, n_points):\n    \"\"\"\n    Computes the singular integral over a triangle using Duffy transformation.\n    \n    Args:\n        vertices (list[np.ndarray]): List of 3 vertices of the triangle.\n        r0 (np.ndarray): The singular observation point.\n        k (float): Wavenumber.\n        phi_type (str): Type of weighting function ('constant' or 'barycentric').\n        n_points (int): Number of Gauss points per dimension.\n        \n    Returns:\n        complex: The numerically computed integral value.\n    \"\"\"\n    v0, v1, v2 = vertices\n    \n    # Define the three subtriangles\n    sub_triangles = [\n        (v0, v1),\n        (v1, v2),\n        (v2, v0)\n    ]\n    \n    total_integral = 0.0 + 0.0j\n    for a, b in sub_triangles:\n        total_integral += evaluate_integral_on_subtriangle(r0, a, b, k, vertices, phi_type, n_points)\n        \n    return total_integral\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute relative errors.\n    \"\"\"\n    test_cases = [\n        # Test case A\n        {\n            \"name\": \"A\",\n            \"vertices\": [np.array([0., 0., 0.]), np.array([1., 0., 0.]), np.array([0.5, np.sqrt(3)/2, 0.])],\n            \"r0\": np.array([1./3., np.sqrt(3)/6., 0.]),\n            \"k\": 0.0,\n            \"phi_type\": \"constant\"\n        },\n        # Test case B\n        {\n            \"name\": \"B\",\n            \"vertices\": [np.array([0., 0., 0.]), np.array([1., 0., 0.]), np.array([1.001, 0.05, 0.])],\n            \"r0\": np.array([0., 0., 0.]) + 0.01 * (np.array([1., 0., 0.]) - np.array([0., 0., 0.])) + 0.01 * (np.array([1.001, 0.05, 0.]) - np.array([0., 0., 0.])),\n            \"k\": 0.0,\n            \"phi_type\": \"barycentric\"\n        },\n        # Test case C\n        {\n            \"name\": \"C\",\n            \"vertices\": [np.array([0., 0., 0.]), np.array([1., 0., 0.]), np.array([0.5, np.sqrt(3)/2, 0.])],\n            \"r0\": np.array([1./3., np.sqrt(3)/6., 0.]),\n            \"k\": 10.0,\n            \"phi_type\": \"constant\"\n        }\n    ]\n\n    N_vals = [2, 4, 8, 16, 32]\n    N_ref = 80\n    \n    all_results = []\n\n    for case in test_cases:\n        v = case[\"vertices\"]\n        r0 = case[\"r0\"]\n        k = case[\"k\"]\n        phi = case[\"phi_type\"]\n\n        I_ref = duffy_quadrature(v, r0, k, phi, N_ref)\n        \n        errors = []\n        for N in N_vals:\n            I_N = duffy_quadrature(v, r0, k, phi, N)\n            \n            # The problem asks for the integral of phi * G_kernel, where G_kernel is without 4*pi\n            # The relative error is |I_N - I_ref| / |I_ref|\n            if np.abs(I_ref)  1e-15:\n                # If reference is zero, error is absolute difference\n                error = np.abs(I_N - I_ref)\n            else:\n                error = np.abs(I_N - I_ref) / np.abs(I_ref)\n            errors.append(error)\n        \n        all_results.append(errors)\n    \n    # Format the output as a string list of lists, without spaces\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "Numerical methods are sensitive to geometric conventions, and a common source of error when implementing coordinate transformations is incorrect orientation. This practice  focuses on the critical role of vertex ordering for a singularity located at a triangle corner. You will see firsthand how an inconsistent orientation can introduce sign errors in the Jacobian determinant and learn how to enforce a consistent counter-clockwise setup for robust and accurate results.",
            "id": "3302708",
            "problem": "In computational electromagnetics, singular triangle integrals arise in boundary integral formulations when evaluating kernels with weak singularities, such as the static Green’s function in three dimensions. Consider a nondegenerate triangle with vertices $\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2 \\in \\mathbb{R}^2$ and a singularity located exactly at one of the triangle’s vertices, denoted $\\mathbf{r}_0$. Using barycentric (area) coordinates, let $\\lambda_0(\\mathbf{r})$ be the scalar linear nodal basis function associated with the vertex at $\\mathbf{r}_0$. Define the weakly singular integral\n$$\nI = \\iint_{T} \\frac{\\lambda_0(\\mathbf{r})}{\\|\\mathbf{r} - \\mathbf{r}_0\\|} \\, dA,\n$$\nwhere $T$ is the triangular domain, $\\|\\cdot\\|$ denotes the Euclidean norm, and $dA$ is the area element. The Duffy transformation maps the unit square $[0,1]^2$ to $T$ to regularize the integrable singularity. The Jacobian determinant of this transformation depends on the triangle’s vertex ordering and the alignment of edges with the mapping. In practice, numerical sign errors can occur if the orientation is inconsistent.\n\nYour task is to implement a program that:\n- Specifies and enforces a rule to order triangle vertices and the two edges emanating from the singular corner so that the Duffy mapping is anchored at the singular vertex and has a consistent counterclockwise orientation.\n- Computes the integral $I$ numerically in two ways for each test case:\n  1. A naive Duffy implementation that anchors the mapping at the singular vertex but preserves the input cyclic ordering of the other two vertices and uses the signed Jacobian determinant, potentially resulting in a negative integral if the orientation is clockwise.\n  2. A consistent-orientation Duffy implementation that cyclically rotates the vertex list so the singular vertex is first, then swaps the remaining two vertices if necessary so that the signed area is positive, thereby ensuring the Jacobian is positive and aligned with the basis function evaluation.\n\nYou must base your derivation and implementation on the following fundamental definitions and facts:\n- Barycentric coordinates on a triangle and linear nodal basis functions $\\lambda_i(\\mathbf{r})$ with $\\lambda_i(\\mathbf{v}_j) = \\delta_{ij}$ and $\\sum_{i=0}^2 \\lambda_i(\\mathbf{r}) = 1$.\n- The Duffy transformation from $[0,1]^2$ to a triangle anchored at a corner and the definition of the Jacobian determinant as the determinant of the matrix of partial derivatives.\n- The signed area of a triangle proportional to $\\det\\big([\\mathbf{v}_1-\\mathbf{v}_0,\\mathbf{v}_2-\\mathbf{v}_0]\\big)$, whose sign encodes counterclockwise versus clockwise orientation.\n\nDo not use any pre-provided shortcut formulas. Start from these base definitions and derive any identities you need.\n\nTest suite:\n- Case $\\mathbf{A}$ (happy path, already counterclockwise): vertices $\\big[(0,0),(1,0),(0,1)\\big]$, singular vertex index $0$ corresponds to $\\mathbf{r}_0 = (0,0)$.\n- Case $\\mathbf{B}$ (clockwise ordering): vertices $\\big[(0,0),(0,1),(1,0)\\big]$, singular vertex index $0$ corresponds to $\\mathbf{r}_0 = (0,0)$.\n- Case $\\mathbf{C}$ (singular vertex not first in the list, scalene, rotated): vertices $\\big[(1.0,0.2),(0.0,0.0),(0.7,0.9)\\big]$, singular vertex index $1$ corresponds to $\\mathbf{r}_0 = (0,0)$.\n\nFor each case, compute two floating-point numbers:\n- $I_{\\text{naive}}$: the integral computed by the naive mapping (anchor at the singular vertex with the input cyclic order for the other two vertices, using the signed Jacobian determinant).\n- $I_{\\text{consistent}}$: the integral computed by first rotating the vertices so the singular vertex is first, then swapping the other two vertices if necessary so that the signed area is positive, and then using the corresponding Duffy mapping with a positive Jacobian magnitude.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n\\big[I_{\\text{naive}}^{(A)}, I_{\\text{consistent}}^{(A)}, I_{\\text{naive}}^{(B)}, I_{\\text{consistent}}^{(B)}, I_{\\text{naive}}^{(C)}, I_{\\text{consistent}}^{(C)}\\big].\n$$\nAll outputs must be finite real numbers. No physical units are required. Angles, if any, must be in radians, but the specified tasks do not require angles. Percentages are not used. The numerical integration tolerance should be chosen to achieve at least $10^{-8}$ relative accuracy for each reported value.",
            "solution": "We start from the foundational definitions. Let the triangle have vertices $\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2 \\in \\mathbb{R}^2$ with a singularity at $\\mathbf{r}_0$ equal to one of the vertices. The barycentric coordinates $\\lambda_i(\\mathbf{r})$ satisfy $\\lambda_i(\\mathbf{v}_j) = \\delta_{ij}$, $\\sum_{i=0}^2 \\lambda_i(\\mathbf{r}) = 1$, and the linear nodal basis associated with the singular vertex is $\\lambda_0(\\mathbf{r})$. The integral of interest is\n$$\nI = \\iint_{T} \\frac{\\lambda_0(\\mathbf{r})}{\\|\\mathbf{r}-\\mathbfr_0\\|} \\, dA.\n$$\nTo remove the integrable singularity at $\\mathbf{r}_0$, we use the Duffy transformation, which is a mapping from the unit square $[0,1]^2$ to the triangle anchored at the singular corner. Denote by $\\mathbf{e}_1 = \\mathbf{v}_1 - \\mathbf{v}_0$ and $\\mathbf{e}_2 = \\mathbf{v}_2 - \\mathbf{v}_0$ the two edges emanating from $\\mathbf{v}_0$ (which must be the singular vertex for the mapping to align with the singularity). Define the map\n$$\n\\mathbf{r}(\\xi,\\eta) = \\mathbf{v}_0 + \\xi\\Big((1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2\\Big),\n\\quad (\\xi,\\eta)\\in[0,1]^2.\n$$\nBy construction, when $\\xi=0$, $\\mathbf{r} = \\mathbf{v}_0$, and when $\\xi=1$, $\\mathbf{r}$ traces the segment from $\\mathbf{v}_1$ to $\\mathbf{v}_2$. The Jacobian of this mapping is the determinant of the matrix with columns $\\partial \\mathbf{r}/\\partial \\xi$ and $\\partial \\mathbf{r}/\\partial \\eta$. We compute\n$$\n\\frac{\\partial \\mathbf{r}}{\\partial \\xi} = (1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2, \\qquad\n\\frac{\\partial \\mathbf{r}}{\\partial \\eta} = \\xi(\\mathbf{e}_2 - \\mathbf{e}_1).\n$$\nTherefore, the Jacobian determinant is\n$$\nJ(\\xi,\\eta) = \\det\\left[\\frac{\\partial \\mathbf{r}}{\\partial \\xi}, \\frac{\\partial \\mathbf{r}}{\\partial \\eta}\\right]\n= \\det\\Big[(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2,\\ \\xi(\\mathbf{e}_2 - \\mathbf{e}_1)\\Big].\n$$\nUsing bilinearity and antisymmetry of the determinant in two dimensions, this simplifies to\n$$\nJ(\\xi,\\eta) = \\xi\\ \\det[\\mathbf{e}_1,\\mathbf{e}_2],\n$$\nwhich is independent of $\\eta$. The sign of $\\det[\\mathbf{e}_1,\\mathbf{e}_2]$ encodes the orientation: positive for counterclockwise and negative for clockwise.\n\nWe now express $\\lambda_0(\\mathbf{r})$ under this map. Since $\\mathbf{r}(\\xi,\\eta)$ is a convex combination of $\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2$ with weights $\\lambda_0 = 1-\\xi$, $\\lambda_1 = \\xi (1-\\eta)$, and $\\lambda_2 = \\xi \\eta$, we have\n$$\n\\lambda_0(\\mathbf{r}(\\xi,\\eta)) = 1 - \\xi.\n$$\nWe also express the distance to the singularity:\n$$\n\\|\\mathbf{r}(\\xi,\\eta) - \\mathbf{r}_0\\| = \\|\\mathbf{r}(\\xi,\\eta) - \\mathbf{v}_0\\| = \\|\\xi((1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2)\\| = \\xi \\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|.\n$$\nPlugging these into the integrand gives\n$$\n\\frac{\\lambda_0(\\mathbf{r}(\\xi,\\eta))}{\\|\\mathbf{r}(\\xi,\\eta)-\\mathbf{r}_0\\|} = \\frac{1-\\xi}{\\xi \\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|}.\n$$\nThe area element transforms as $dA = |J(\\xi,\\eta)|\\, d\\xi\\, d\\eta$ if we aim to compute the physical integral with positive measure. There are two computational choices that highlight the orientation issue:\n\n1. Naive approach: anchor the mapping at the singular vertex but preserve the input cyclic order of the other two vertices and use the signed Jacobian determinant $J(\\xi,\\eta) = \\xi \\det[\\mathbf{e}_1,\\mathbf{e}_2]$ directly, without taking an absolute value and without reordering to fix orientation. The computed integral is\n$$\nI_{\\text{naive}} = \\int_0^1 \\int_0^1 \\frac{1-\\xi}{\\xi \\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|} \\cdot \\Big(\\xi \\det[\\mathbf{e}_1,\\mathbf{e}_2]\\Big)\\, d\\xi\\, d\\eta.\n$$\n2. Consistent-orientation approach: cyclically rotate the vertices so that the singular vertex is first, then swap the other two vertices if necessary so that $\\det[\\mathbf{e}_1,\\mathbf{e}_2]  0$. Use the positive Jacobian magnitude $|J(\\xi,\\eta)| = \\xi\\, |\\det[\\mathbf{e}_1,\\mathbf{e}_2]|$. The computed integral is\n$$\nI_{\\text{consistent}} = \\int_0^1 \\int_0^1 \\frac{1-\\xi}{\\xi \\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|} \\cdot \\Big(\\xi\\, |\\det[\\mathbf{e}_1,\\mathbf{e}_2]|\\Big)\\, d\\xi\\, d\\eta,\n$$\nwith $\\mathbf{e}_1,\\mathbf{e}_2$ taken from the orientation-corrected ordering.\n\nIn both cases, the factor $\\xi$ cancels, and the integrand becomes separable:\n$$\nI_{\\square} = \\left(\\int_0^1 (1-\\xi)\\, d\\xi \\right) \\left(\\int_0^1 \\frac{\\kappa_{\\square}}{\\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|}\\, d\\eta \\right),\n$$\nwhere $\\kappa_{\\text{naive}} = \\det[\\mathbf{e}_1,\\mathbf{e}_2]$ and $\\kappa_{\\text{consistent}} = |\\det[\\mathbf{e}_1,\\mathbf{e}_2]|$, and the subscript $\\square$ denotes either the naive or consistent evaluation. The $\\xi$-integral evaluates to\n$$\n\\int_0^1 (1-\\xi)\\, d\\xi = \\frac{1}{2}.\n$$\nHence\n$$\nI_{\\square} = \\frac{1}{2} \\int_0^1 \\frac{\\kappa_{\\square}}{\\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|}\\, d\\eta.\n$$\nThe denominator depends only on the positions of $\\mathbf{e}_1$ and $\\mathbf{e}_2$. Swapping $\\mathbf{e}_1$ and $\\mathbf{e}_2$ reverses the parametrization of the segment but leaves the integral over $\\eta \\in [0,1]$ invariant because the mapping $\\eta \\mapsto 1-\\eta$ preserves the integral of a symmetric norm. Therefore, the only difference between the two approaches is the sign carried by $\\kappa_{\\square}$. If the input triangle is listed clockwise with the singular vertex first, then $\\det[\\mathbf{e}_1,\\mathbf{e}_2]  0$ and $I_{\\text{naive}}$ will be negative, whereas $I_{\\text{consistent}}$ will be positive with the same magnitude. This demonstrates why consistent orientation avoids sign errors: by enforcing $\\det[\\mathbf{e}_1,\\mathbf{e}_2]  0$, the Jacobian magnitude is positive and the integral has the correct sign, while the basis function $\\lambda_0(\\mathbf{r}) = 1-\\xi$ is consistently evaluated with respect to the same orientation.\n\nAlgorithmic steps to avoid sign errors and align the singular corner with the Duffy mapping:\n- Given an input vertex list $\\big[\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2\\big]$ and the index $s \\in \\{0,1,2\\}$ of the singular vertex, cyclically rotate the list so that the singular vertex is first: $\\big[\\mathbf{v}_s,\\mathbf{v}_{s+1 \\bmod 3},\\mathbf{v}_{s+2 \\bmod 3}\\big]$.\n- Compute $\\mathbf{e}_1 = \\mathbf{v}_1-\\mathbf{v}_0$ and $\\mathbf{e}_2 = \\mathbf{v}_2-\\mathbf{v}_0$, then the signed area determinant $\\det[\\mathbf{e}_1,\\mathbf{e}_2]$.\n- If $\\det[\\mathbf{e}_1,\\mathbf{e}_2]  0$, swap $\\mathbf{v}_1$ and $\\mathbf{v}_2$ so that the determinant becomes positive. This also swaps the two local edges, aligning the Jacobian and basis evaluation consistently.\n- Use the Duffy mapping anchored at $\\mathbf{v}_0$ and integrate numerically.\n\nFor numerical evaluation, the separable form yields a one-dimensional integral over $\\eta \\in [0,1]$:\n$$\nI_{\\text{naive}} = \\frac{1}{2}\\, \\det[\\mathbf{e}_1,\\mathbf{e}_2]\\ \\int_0^1 \\frac{d\\eta}{\\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|},\n\\quad\nI_{\\text{consistent}} = \\frac{1}{2}\\, \\big|\\det[\\mathbf{e}_1,\\mathbf{e}_2]\\big|\\ \\int_0^1 \\frac{d\\eta}{\\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|}.\n$$\nThis integral has no singularity because $\\mathbf{e}_1$ and $\\mathbf{e}_2$ are noncollinear for a nondegenerate triangle.\n\nTest suite interpretation:\n- Case $\\mathbf{A}$: $\\big[(0,0),(1,0),(0,1)\\big]$ with singular index $0$ is already counterclockwise, so both $I_{\\text{naive}}$ and $I_{\\text{consistent}}$ are positive and equal.\n- Case $\\mathbf{B}$: $\\big[(0,0),(0,1),(1,0)\\big]$ with singular index $0$ is clockwise, so $I_{\\text{naive}}$ is the negative of Case $\\mathbf{A}$’s value, while $I_{\\text{consistent}}$ equals Case $\\mathbf{A}$’s positive value.\n- Case $\\mathbf{C}$: $\\big[(1.0,0.2),(0.0,0.0),(0.7,0.9)\\big]$ with singular index $1$ requires rotation to anchor the singular vertex first; the naive result may be negative if the resulting order is clockwise, while the consistent result is positive. The two consistent results for Cases $\\mathbf{A}$ and $\\mathbf{B}$ match, and Case $\\mathbf{C}$ yields a different positive number because the geometry is different.\n\nThe program implements these steps, evaluates the one-dimensional integral using numerical quadrature with tight tolerances to achieve at least $10^{-8}$ relative accuracy, and prints the final results as a single list in the specified order.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef signed_area_det(e1: np.ndarray, e2: np.ndarray) - float:\n    # 2D cross product (determinant of [e1, e2])\n    return e1[0]*e2[1] - e1[1]*e2[0]\n\ndef rotate_vertices(vertices, start_index):\n    # Cyclically rotate so that vertices[start_index] becomes first\n    return vertices[start_index:] + vertices[:start_index]\n\ndef duffy_integral(vertices, singular_index, orientation_mode=\"naive\"):\n    \"\"\"\n    Compute I = ∫_T lambda0(r)/||r - r0|| dA using Duffy mapping anchored at the singular vertex.\n    orientation_mode: \"naive\" preserves input cyclic order after rotation to make singular first,\n                      uses signed determinant in the Jacobian.\n                      \"consistent\" enforces positive orientation by swapping v1,v2 if needed,\n                      uses positive determinant magnitude.\n    \"\"\"\n    # Ensure singular vertex is first by rotation\n    verts = rotate_vertices(vertices, singular_index)\n    v0 = np.array(verts[0], dtype=float)\n    v1 = np.array(verts[1], dtype=float)\n    v2 = np.array(verts[2], dtype=float)\n\n    # Edge vectors from the singular corner\n    e1 = v1 - v0\n    e2 = v2 - v0\n\n    det = signed_area_det(e1, e2)\n\n    if orientation_mode == \"consistent\":\n        # Enforce positive orientation\n        if det  0.0:\n            # swap e1 and e2\n            e1, e2 = e2, e1\n            det = -det  # now positive\n\n        det_factor = abs(det)\n    elif orientation_mode == \"naive\":\n        # Keep original cyclic order and signed determinant\n        det_factor = det\n    else:\n        raise ValueError(\"orientation_mode must be 'naive' or 'consistent'\")\n\n    # Define the 1D integrand over eta in [0,1]: det_factor / ||(1-eta)*e1 + eta*e2||\n    def integrand_eta(eta):\n        s = (1.0 - eta) * e1 + eta * e2\n        norm_s = np.hypot(s[0], s[1])\n        return det_factor / norm_s\n\n    # Perform numerical integration with tight tolerances\n    integ_val, _ = quad(integrand_eta, 0.0, 1.0, epsabs=1e-12, epsrel=1e-12, limit=200)\n    return 0.5 * integ_val\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (vertices list, singular_index)\n    test_cases = [\n        ([(0.0, 0.0), (1.0, 0.0), (0.0, 1.0)], 0),  # Case A\n        ([(0.0, 0.0), (0.0, 1.0), (1.0, 0.0)], 0),  # Case B\n        ([(1.0, 0.2), (0.0, 0.0), (0.7, 0.9)], 1),  # Case C\n    ]\n\n    results = []\n    for vertices, sidx in test_cases:\n        I_naive = duffy_integral(vertices, sidx, orientation_mode=\"naive\")\n        I_consistent = duffy_integral(vertices, sidx, orientation_mode=\"consistent\")\n        results.append(I_naive)\n        results.append(I_consistent)\n\n    # Final print statement in the exact required format.\n    # Use full precision string conversion for clarity.\n    print(f\"[{','.join(map(lambda x: f'{x:.15g}', results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The final step in developing a reliable numerical tool is to verify it against a known solution. This exercise  provides a canonical test case—an equilateral triangle—where a singular integral can be solved analytically. By comparing your numerical results against this exact benchmark, you will not only validate your implementation but also gain deeper insight into the structure of the transformed integral and its scaling properties.",
            "id": "3302738",
            "problem": "Construct a canonical verification of singular triangle integrals as they arise in the Electric Field Integral Equation (EFIE) for three-dimensional scattering, using the Duffy transformation to regularize the integrals on a single canonical element. Consider an equilateral triangle of side length $s  0$ in the plane, with a singularity located at one of its vertices. In the static (zero-wavenumber) limit of the EFIE with Rao–Wilton–Glisson (RWG) basis functions, the weakly singular integrals to be evaluated have the generic form\n$$\nI[w] \\;=\\; \\int_{T} \\frac{w(\\mathbf{r}')}{\\lVert \\mathbf{r}' - \\mathbf{r}_0 \\rVert} \\,\\mathrm{d}S',\n$$\nwhere $T$ is the triangle, $\\mathbf{r}_0$ is the vertex at which the singularity is located, and $w(\\mathbf{r}')$ is a smooth weight that encodes the local behavior of the basis/testing functions. Use the Duffy transformation from the unit square to the triangle to regularize the singularity associated with the factor $1/\\lVert \\mathbf{r}' - \\mathbf{r}_0 \\rVert$ and to compute $I[w]$ numerically.\n\nFundamental base:\n- The Electric Field Integral Equation (EFIE) in the static limit involves the Laplace Green’s function $G(\\mathbf{r},\\mathbf{r}') = \\frac{1}{4\\pi \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}$, whose weak singularity manifests as a $1/\\rho$ behavior when $\\mathbf{r} \\to \\mathbf{r}'$ in local coordinates with $\\rho = \\lVert \\mathbf{r}' - \\mathbf{r}_0 \\rVert$.\n- The Duffy transformation maps a unit square $(u,v)\\in[0,1]^2$ to a triangle with one vertex at $\\mathbf{r}_0$ as $\\mathbf{r}'(u,v) = u\\big(v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b}\\big)$, where $\\mathbf{a}$ and $\\mathbf{b}$ are the position vectors of the two non-singular vertices. The Jacobian determinant contributes a factor proportional to $u$, which cancels the $1/\\rho$ singularity.\n\nDefine the equilateral triangle as follows:\n- Let the singular vertex be at the origin $\\mathbf{r}_0 = \\mathbf{0}$, and choose $\\mathbf{a}$ and $\\mathbf{b}$ to be the two adjacent vertices such that the interior angle at the origin is $\\pi/3$ and the base is perpendicular to the angle bisector. Let $s$ be the side length and $h = \\frac{\\sqrt{3}}{2} s$ the altitude. All angles are to be interpreted in radians.\n\nWeights to be tested:\n- $w_0(\\mathbf{r}') = 1$ (constant weight).\n- $w_1(\\mathbf{r}') = \\lambda_0(\\mathbf{r}')$, the barycentric coordinate that equals $1$ at the singular vertex and $0$ on the opposite edge (this is the scalar factor associated with the RWG basis function that vanishes linearly toward the opposite edge).\n\nNumerical task:\n- Implement a Duffy-transformed quadrature to compute $I[w_0]$ and $I[w_1]$ on the equilateral triangle described above, for given side length $s$. Use a tensor-product Gauss–Legendre quadrature on $(u,v)\\in[0,1]^2$ with sufficient order to resolve the integrand after Duffy regularization.\n- Compare your numerical results against analytic expressions derivable from first principles for the equilateral geometry, and report the relative errors.\n\nAngle unit specification:\n- All angles are in radians.\n\nTest suite:\n- Case A: $s = 1.0$, weight $w = w_0$.\n- Case B: $s = 1.0$, weight $w = w_1$.\n- Case C: $s = 3.0$, weight $w = w_0$.\n- Case D: $s = 10^{-6}$, weight $w = w_0$.\n\nAnswer specification:\n- For each case, compute the relative error defined as\n$$\n\\varepsilon \\;=\\; \\frac{\\left| I_{\\text{num}} - I_{\\text{analytic}} \\right|}{\\left| I_{\\text{analytic}} \\right|}.\n$$\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order [Case A, Case B, Case C, Case D]. For example: \"[eA,eB,eC,eD]\". No physical units are required, and each entry must be a floating-point value.",
            "solution": "### 1. Problem Formulation\n\nThe integral to be evaluated is of the form:\n$$\nI[w] \\;=\\; \\int_{T} \\frac{w(\\mathbf{r}')}{\\lVert \\mathbf{r}' - \\mathbf{r}_0 \\rVert} \\,\\mathrm{d}S'\n$$\nwhere $T$ is an equilateral triangle of side length $s$, $\\mathbf{r}_0$ is a vertex of $T$, and $w(\\mathbf{r}')$ is a smooth weight function. This integral is weakly singular due to the $1/\\lVert \\mathbf{r}' - \\mathbf{r}_0 \\rVert$ kernel, which arises in the static limit of the Electric Field Integral Equation (EFIE).\n\n### 2. Geometric Setup and Duffy Transformation\n\nWe place the singular vertex at the origin, $\\mathbf{r}_0 = \\mathbf{0} = (0, 0)$. For an equilateral triangle of side $s$ with an interior angle of $\\pi/3$ at the origin, the other two vertices, $\\mathbf{a}$ and $\\mathbf{b}$, are positioned at:\n$$\n\\mathbf{a} = \\left(s\\cos\\frac{\\pi}{6}, s\\sin\\frac{\\pi}{6}\\right) = \\left(\\frac{s\\sqrt{3}}{2}, \\frac{s}{2}\\right)\n$$\n$$\n\\mathbf{b} = \\left(s\\cos\\left(-\\frac{\\pi}{6}\\right), s\\sin\\left(-\\frac{\\pi}{6}\\right)\\right) = \\left(\\frac{s\\sqrt{3}}{2}, -\\frac{s}{2}\\right)\n$$\nThe Duffy transformation maps the unit square $(u,v) \\in [0,1]^2$ to the triangle $T$ as follows:\n$$\n\\mathbf{r}'(u,v) = u\\big(v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b}\\big)\n$$\nThe differential area element $\\mathrm{d}S'$ is related to $\\mathrm{d}u\\,\\mathrm{d}v$ by the Jacobian determinant of the transformation:\n$$\n\\mathrm{d}S' = |J(u,v)| \\,\\mathrm{d}u\\,\\mathrm{d}v = \\left\\| \\frac{\\partial \\mathbf{r}'}{\\partial u} \\times \\frac{\\partial \\mathbf{r}'}{\\partial v} \\right\\| \\,\\mathrm{d}u\\,\\mathrm{d}v\n$$\nThe partial derivatives are:\n$$\n\\frac{\\partial \\mathbf{r}'}{\\partial u} = v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b}\n$$\n$$\n\\frac{\\partial \\mathbf{r}'}{\\partial v} = u(\\mathbf{a} - \\mathbf{b})\n$$\nTheir cross product is:\n$$\n\\frac{\\partial \\mathbf{r}'}{\\partial u} \\times \\frac{\\partial \\mathbf{r}'}{\\partial v} = u \\left( (v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b}) \\times (\\mathbf{a} - \\mathbf{b}) \\right) = -u (\\mathbf{a} \\times \\mathbf{b})\n$$\nThe magnitude is $|J(u,v)| = u \\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert$. The term $\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert$ represents twice the area of the triangle, $2A_T$. For our equilateral triangle, $A_T = \\frac{\\sqrt{3}}{4}s^2$, so $\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert = \\frac{\\sqrt{3}}{2}s^2$. The Jacobian is:\n$$\n|J(u,v)| = u \\frac{\\sqrt{3}}{2}s^2\n$$\n\n### 3. Regularization of the Integral\n\nSubstituting the transformation into the integral, we get:\n$$\nI[w] = \\int_0^1 \\int_0^1 \\frac{w(\\mathbf{r}'(u,v))}{\\lVert \\mathbf{r}'(u,v) \\rVert} |J(u,v)| \\,\\mathrm{d}u\\,\\mathrm{d}v\n$$\nThe distance term in the denominator is:\n$$\n\\lVert \\mathbf{r}'(u,v) \\rVert = \\lVert u(v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b}) \\rVert = u \\lVert v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b} \\rVert\n$$\nThe key feature of the Duffy transformation is that the factor of $u$ from the Jacobian cancels the factor of $u$ from the distance term, thus regularizing the integrand:\n$$\nI[w] = \\int_0^1 \\int_0^1 \\frac{w(\\mathbf{r}'(u,v))}{u \\lVert v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b} \\rVert} \\left( u \\frac{\\sqrt{3}}{2}s^2 \\right) \\,\\mathrm{d}u\\,\\mathrm{d}v = \\frac{\\sqrt{3}}{2}s^2 \\int_0^1 \\int_0^1 \\frac{w(\\mathbf{r}'(u,v))}{\\lVert v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b} \\rVert} \\,\\mathrm{d}u\\,\\mathrm{d}v\n$$\nLet's evaluate the squared magnitude in the denominator:\n$$\n\\lVert v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b} \\rVert^2 = v^2\\lVert\\mathbf{a}\\rVert^2 + (1-v)^2\\lVert\\mathbf{b}\\rVert^2 + 2v(1-v)(\\mathbf{a} \\cdot \\mathbf{b})\n$$\nWith $\\lVert\\mathbf{a}\\rVert^2 = s^2$, $\\lVert\\mathbf{b}\\rVert^2 = s^2$, and $\\mathbf{a} \\cdot \\mathbf{b} = s^2\\cos(\\pi/3) = s^2/2$, this becomes:\n$$\ns^2 \\left( v^2 + (1-v)^2 + v(1-v) \\right) = s^2 (v^2 + 1 - 2v + v^2 + v - v^2) = s^2 (v^2 - v + 1)\n$$\nThe regularized integral is thus:\n$$\nI[w] = \\frac{\\sqrt{3}}{2}s^2 \\int_0^1 \\int_0^1 \\frac{w(u,v)}{s \\sqrt{v^2 - v + 1}} \\,\\mathrm{d}u\\,\\mathrm{d}v = \\frac{\\sqrt{3}}{2}s \\int_0^1 \\int_0^1 \\frac{w(u,v)}{\\sqrt{v^2 - v + 1}} \\,\\mathrm{d}u\\,\\mathrm{d}v\n$$\n\n### 4. Analysis of Weight Functions\n\nWe analyze the two specified weight functions in the transformed coordinate system.\n\n**Case 1: Constant Weight, $w_0(\\mathbf{r}') = 1$**\nThe weight is simply $w_0(u,v) = 1$. The integral becomes:\n$$\nI[w_0] = \\frac{\\sqrt{3}}{2}s \\int_0^1 \\left(\\int_0^1 \\mathrm{d}u\\right) \\frac{1}{\\sqrt{v^2 - v + 1}} \\,\\mathrm{d}v = \\frac{\\sqrt{3}}{2}s \\int_0^1 \\frac{1}{\\sqrt{v^2 - v + 1}} \\,\\mathrm{d}v\n$$\n\n**Case 2: Barycentric Weight, $w_1(\\mathbf{r}') = \\lambda_0(\\mathbf{r}')$**\nThe barycentric coordinate $\\lambda_0$ corresponding to the vertex $\\mathbf{r}_0 = \\mathbf{0}$ is given by $\\lambda_0 = 1-u$ under the Duffy mapping $\\mathbf{r}' = u \\mathbf{p} + (1-u)\\mathbf{0}$, where $\\mathbf{p}$ is a point on the edge opposite $\\mathbf{r}_0$. Thus, $w_1(u,v) = 1-u$. The integral is:\n$$\nI[w_1] = \\frac{\\sqrt{3}}{2}s \\int_0^1 \\int_0^1 \\frac{1-u}{\\sqrt{v^2 - v + 1}} \\,\\mathrm{d}u\\,\\mathrm{d}v = \\frac{\\sqrt{3}}{2}s \\left(\\int_0^1 (1-u)\\,\\mathrm{d}u\\right) \\left(\\int_0^1 \\frac{\\mathrm{d}v}{\\sqrt{v^2 - v + 1}}\\right)\n$$\nSince $\\int_0^1 (1-u)\\,\\mathrm{d}u = 1/2$, we find a direct relationship:\n$$\nI[w_1] = \\frac{1}{2} I[w_0]\n$$\n\n### 5. Analytic Solution\n\nBoth integrals depend on the value of $K = \\int_0^1 \\frac{\\mathrm{d}v}{\\sqrt{v^2 - v + 1}}$. We solve this by completing the square:\n$$\nK = \\int_0^1 \\frac{\\mathrm{d}v}{\\sqrt{(v - 1/2)^2 + 3/4}}\n$$\nUsing the substitution $x = v - 1/2$, the integral becomes:\n$$\nK = \\int_{-1/2}^{1/2} \\frac{\\mathrm{d}x}{\\sqrt{x^2 + (\\sqrt{3}/2)^2}} = \\left[ \\ln\\left(x + \\sqrt{x^2 + 3/4}\\right) \\right]_{-1/2}^{1/2}\n$$\n$$\nK = \\ln\\left(\\frac{1}{2} + \\sqrt{\\frac{1}{4} + \\frac{3}{4}}\\right) - \\ln\\left(-\\frac{1}{2} + \\sqrt{\\frac{1}{4} + \\frac{3}{4}}\\right) = \\ln\\left(\\frac{3}{2}\\right) - \\ln\\left(\\frac{1}{2}\\right) = \\ln(3)\n$$\nThe analytic expressions for the integrals are:\n$$\nI_{\\text{analytic}}[w_0] = \\frac{\\sqrt{3}}{2}s \\ln(3)\n$$\n$$\nI_{\\text{analytic}}[w_1] = \\frac{\\sqrt{3}}{4}s \\ln(3)\n$$\n\n### 6. Numerical Quadrature and Error Analysis\n\nA tensor-product Gauss-Legendre quadrature is applied to the regularized 2D integral over $(u,v) \\in [0,1]^2$. Since the integrands are separable, the 2D quadrature is equivalent to the product of two 1D quadratures. For a general separable integrand $f(u,v) = g(u)h(v)$, the numerical integral is:\n$$\n\\int_0^1\\int_0^1 g(u)h(v)\\,\\mathrm{d}u\\,\\mathrm{d}v \\approx \\left(\\sum_i w_i' g(u_i)\\right) \\left(\\sum_j w_j' h(v_j)\\right)\n$$\nwhere $(u_i, w_i')$ and $(v_j, w_j')$ are the 1D Gauss-Legendre nodes and weights scaled to the interval $[0,1]$.\n\nFor both weight cases, the numerical error is dominated by the approximation of the integral $K = \\int_0^1 (v^2 - v + 1)^{-1/2} \\,\\mathrm{d}v$. The integrals over $u$ involve polynomials ($1$ and $1-u$) which are integrated exactly by any Gauss-Legendre rule of order $n \\ge 1$. Let the numerical approximation of $K$ be $K_{\\text{num}}$.\n\nThe numerical values are:\n$$\nI_{\\text{num}}[w_0] = \\frac{\\sqrt{3}}{2}s K_{\\text{num}} \\quad \\text{and} \\quad I_{\\text{num}}[w_1] = \\frac{\\sqrt{3}}{4}s K_{\\text{num}}\n$$\nThe relative error for $w_0$ is:\n$$\n\\varepsilon_0 = \\frac{|I_{\\text{num}}[w_0] - I_{\\text{analytic}}[w_0]|}{|I_{\\text{analytic}}[w_0]|} = \\frac{|\\frac{\\sqrt{3}}{2}s K_{\\text{num}} - \\frac{\\sqrt{3}}{2}s \\ln(3)|}{|\\frac{\\sqrt{3}}{2}s \\ln(3)|} = \\frac{|K_{\\text{num}} - \\ln(3)|}{|\\ln(3)|}\n$$\nThe relative error for $w_1$ is identical:\n$$\n\\varepsilon_1 = \\frac{|I_{\\text{num}}[w_1] - I_{\\text{analytic}}[w_1]|}{|I_{\\text{analytic}}[w_1]|} = \\frac{|\\frac{\\sqrt{3}}{4}s K_{\\text{num}} - \\frac{\\sqrt{3}}{4}s \\ln(3)|}{|\\frac{\\sqrt{3}}{4}s \\ln(3)|} = \\frac{|K_{\\text{num}} - \\ln(3)|}{|\\ln(3)|}\n$$\nThis demonstrates that the relative error is independent of the side length $s$ and the choice of weight function ($w_0$ or $w_1$). Consequently, all four test cases are expected to yield the same relative error. Using a sufficiently high-order quadrature (e.g., $n=64$), the regular integrand for $K$ can be evaluated so accurately that $K_{\\text{num}}$ matches the standard `float64` representation of $\\ln(3)$, resulting in a relative error of zero.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes the relative error for singular triangle integrals regularized\n    by the Duffy transformation, comparing numerical results to analytic solutions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of (side_length s, weight_type w).\n    test_cases = [\n        (1.0, 'w0'),       # Case A\n        (1.0, 'w1'),       # Case B\n        (3.0, 'w0'),       # Case C\n        (1.0e-6, 'w0'),    # Case D\n    ]\n\n    results = []\n    \n    # Use a sufficiently high quadrature order to resolve the smooth integrand.\n    # For a smooth (C-infinity) integrand, Gauss-Legendre quadrature converges\n    # exponentially. An order of 64 is more than sufficient to reach\n    # machine precision for the functions in this problem.\n    N_POINTS = 64\n\n    # Pre-calculate Gauss-Legendre nodes and weights for the interval [0, 1].\n    # roots_legendre returns for [-1, 1], so we scale them.\n    nodes_m11, weights_m11 = roots_legendre(N_POINTS)\n    nodes_01 = (nodes_m11.astype(np.float64) + 1.0) / 2.0\n    weights_01 = weights_m11.astype(np.float64) / 2.0\n\n    # The analytic value of the core 1D integral K = integral(1/sqrt(v^2-v+1)) dv from 0 to 1\n    analytic_K = np.log(3.0)\n\n    # Numerically compute the integral K using Gauss-Legendre quadrature.\n    # The integrand is evaluated at the scaled nodes.\n    v_integrand_at_nodes = 1.0 / np.sqrt(nodes_01**2 - nodes_01 + 1.0)\n    numerical_K = np.sum(weights_01 * v_integrand_at_nodes)\n\n    for s, weight_type in test_cases:\n        if weight_type == 'w0':\n            # For w0(r') = 1, the transformed weight is 1. The integral over u is 1.\n            # I[w0] = (sqrt(3)/2)*s * integral_u(1 du) * integral_v(...) dv\n            #       = (sqrt(3)/2)*s * 1 * K\n            numerical_val = (np.sqrt(3.0) / 2.0) * s * numerical_K\n            analytic_val = (np.sqrt(3.0) / 2.0) * s * analytic_K\n\n        elif weight_type == 'w1':\n            # For w1(r') = lambda_0, the transformed weight is 1-u.\n            # The integral of (1-u) from 0 to 1 is exactly 0.5.\n            # Gauss-Legendre quadrature integrates polynomials exactly.\n            # I[w1] = (sqrt(3)/2)*s * integral_u(1-u du) * integral_v(...) dv\n            #       = (sqrt(3)/2)*s * 0.5 * K\n            numerical_val = (np.sqrt(3.0) / 4.0) * s * numerical_K\n            analytic_val = (np.sqrt(3.0) / 4.0) * s * analytic_K\n        \n        else:\n            raise ValueError(f\"Unknown weight type: {weight_type}\")\n\n        # Compute the relative error.\n        # Check for analytic_val being zero to avoid division by zero, though not expected here.\n        if np.abs(analytic_val) > 0:\n            rel_error = np.abs(numerical_val - analytic_val) / np.abs(analytic_val)\n        else:\n            rel_error = np.abs(numerical_val)\n            \n        results.append(rel_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}