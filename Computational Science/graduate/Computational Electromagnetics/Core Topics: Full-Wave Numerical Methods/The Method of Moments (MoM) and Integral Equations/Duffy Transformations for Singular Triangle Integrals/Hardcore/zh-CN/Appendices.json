{
    "hands_on_practices": [
        {
            "introduction": "验证数值方法的正确性是实现它的关键第一步。在这个实践中，我们将把Duffy变换应用于一个具有高度对称性的简单情况——在等边三角形的顶点上存在一个奇点——这种情况可以推导出精确的解析解。通过将您的数值结果与一个已知的精确值进行直接比较，这个练习可以帮助您验证核心实现的正确性，为解决更复杂的问题打下坚实的基础。",
            "id": "3302738",
            "problem": "构建电场积分方程 (EFIE) 中出现的三维散射问题中的奇异三角形积分的典范验证，使用 Duffy 变换在单个典范单元上对积分进行正则化。考虑平面上一个边长为 $s  0$ 的等边三角形，其一个顶点处存在奇异点。在具有 Rao–Wilton–Glisson (RWG) 基函数的 EFIE 的静态（零波数）极限下，需要计算的弱奇异积分具有以下通用形式：\n$$\nI[w] \\;=\\; \\int_{T} \\frac{w(\\mathbf{r}')}{\\lVert \\mathbf{r}' - \\mathbf{r}_0 \\rVert} \\,\\mathrm{d}S',\n$$\n其中 $T$ 是该三角形，$\\mathbf{r}_0$ 是奇异点所在的顶点，而 $w(\\mathbf{r}')$ 是一个光滑权重，它编码了基函数/检验函数的局部行为。使用从单位正方形到三角形的 Duffy 变换来正则化与因子 $1/\\lVert \\mathbf{r}' - \\mathbf{r}_0 \\rVert$ 相关的奇异性，并数值计算 $I[w]$。\n\n基本原理：\n- 静态极限下的电场积分方程 (EFIE) 涉及拉普拉斯格林函数 $G(\\mathbf{r},\\mathbf{r}') = \\frac{1}{4\\pi \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}$，当在局部坐标中 $\\mathbf{r} \\to \\mathbf{r}'$ 时，其弱奇异性表现为 $1/\\rho$ 的行为，其中 $\\rho = \\lVert \\mathbf{r}' - \\mathbf{r}_0 \\rVert$。\n- Duffy 变换将一个单位正方形 $(u,v)\\in[0,1]^2$ 映射到一个顶点位于 $\\mathbf{r}_0$ 的三角形，其映射关系为 $\\mathbf{r}'(u,v) = u\\big(v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b}\\big)$，其中 $\\mathbf{a}$ 和 $\\mathbf{b}$ 是两个非奇异顶点的位置矢量。雅可比行列式贡献了一个与 $u$ 成正比的因子，该因子抵消了 $1/\\rho$ 的奇异性。\n\n定义等边三角形如下：\n- 设奇异顶点位于原点 $\\mathbf{r}_0 = \\mathbf{0}$，并选择 $\\mathbf{a}$ 和 $\\mathbf{b}$ 作为相邻的两个顶点，使得原点处的内角为 $\\pi/3$，且底边垂直于角平分线。设 $s$ 为边长，$h = \\frac{\\sqrt{3}}{2} s$ 为高。所有角度均以弧度为单位。\n\n待测试的权重：\n- $w_0(\\mathbf{r}') = 1$（常数权重）。\n- $w_1(\\mathbf{r}') = \\lambda_0(\\mathbf{r}')$，即在奇异顶点处等于 $1$，在对边上等于 $0$ 的重心坐标（这是与 RWG 基函数相关的标量因子，该基函数向对边线性递减至零）。\n\n数值任务：\n- 实现一个 Duffy 变换后的求积方法，以计算在上述等边三角形上，给定边长 $s$ 的 $I[w_0]$ 和 $I[w_1]$。在 $(u,v)\\in[0,1]^2$ 上使用足够高阶的张量积高斯-勒让德求积，以解析 Duffy 正则化后的被积函数。\n- 将您的数值结果与可从第一性原理为该等边几何形状推导出的解析表达式进行比较，并报告相对误差。\n\n角度单位说明：\n- 所有角度均以弧度为单位。\n\n测试套件：\n- 情况 A：$s = 1.0$，权重 $w = w_0$。\n- 情况 B：$s = 1.0$，权重 $w = w_1$。\n- 情况 C：$s = 3.0$，权重 $w = w_0$。\n- 情况 D：$s = 10^{-6}$，权重 $w = w_0$。\n\n答案规格：\n- 对每种情况，计算相对误差，定义为\n$$\n\\varepsilon \\;=\\; \\frac{\\left| I_{\\text{num}} - I_{\\text{analytic}} \\right|}{\\left| I_{\\text{analytic}} \\right|}.\n$$\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，顺序为 [情况 A, 情况 B, 情况 C, 情况 D]。例如：“[eA,eB,eC,eD]”。不需要物理单位，每个条目必须是浮点值。",
            "solution": "用户提供的问题已经过验证，被认为是合理的。以下解决方案提出了一个在三角形域上的奇异积分的典范验证，该积分使用 Duffy 变换进行正则化。\n\n### 1. 问题描述\n\n需要计算的积分形式如下：\n$$\nI[w] \\;=\\; \\int_{T} \\frac{w(\\mathbf{r}')}{\\lVert \\mathbf{r}' - \\mathbf{r}_0 \\rVert} \\,\\mathrm{d}S'\n$$\n其中 $T$ 是一个边长为 $s$ 的等边三角形，$\\mathbf{r}_0$ 是 $T$ 的一个顶点，$w(\\mathbf{r}')$ 是一个光滑权重函数。由于 $1/\\lVert \\mathbf{r}' - \\mathbf{r}_0 \\rVert$ 核的存在，该积分是弱奇异的，这在电场积分方程 (EFIE) 的静态极限下出现。\n\n### 2. 几何设置与Duffy变换\n\n我们将奇异顶点置于原点，即 $\\mathbf{r}_0 = \\mathbf{0} = (0, 0)$。对于一个边长为 $s$、在原点处内角为 $\\pi/3$ 的等边三角形，另外两个顶点 $\\mathbf{a}$ 和 $\\mathbf{b}$ 的位置为：\n$$\n\\mathbf{a} = \\left(s\\cos\\frac{\\pi}{6}, s\\sin\\frac{\\pi}{6}\\right) = \\left(\\frac{s\\sqrt{3}}{2}, \\frac{s}{2}\\right)\n$$\n$$\n\\mathbf{b} = \\left(s\\cos\\left(-\\frac{\\pi}{6}\\right), s\\sin\\left(-\\frac{\\pi}{6}\\right)\\right) = \\left(\\frac{s\\sqrt{3}}{2}, -\\frac{s}{2}\\right)\n$$\nDuffy 变换将单位正方形 $(u,v) \\in [0,1]^2$ 映射到三角形 $T$，如下所示：\n$$\n\\mathbf{r}'(u,v) = u\\big(v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b}\\big)\n$$\n微分面积元 $\\mathrm{d}S'$ 通过变换的雅可比行列式与 $\\mathrm{d}u\\,\\mathrm{d}v$ 相关联：\n$$\n\\mathrm{d}S' = |J(u,v)| \\,\\mathrm{d}u\\,\\mathrm{d}v = \\left\\| \\frac{\\partial \\mathbf{r}'}{\\partial u} \\times \\frac{\\partial \\mathbf{r}'}{\\partial v} \\right\\| \\,\\mathrm{d}u\\,\\mathrm{d}v\n$$\n偏导数是：\n$$\n\\frac{\\partial \\mathbf{r}'}{\\partial u} = v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b}\n$$\n$$\n\\frac{\\partial \\mathbf{r}'}{\\partial v} = u(\\mathbf{a} - \\mathbf{b})\n$$\n它们的叉积是：\n$$\n\\frac{\\partial \\mathbf{r}'}{\\partial u} \\times \\frac{\\partial \\mathbf{r}'}{\\partial v} = u \\left( (v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b}) \\times (\\mathbf{a} - \\mathbf{b}) \\right) = -u (\\mathbf{a} \\times \\mathbf{b})\n$$\n其大小为 $|J(u,v)| = u \\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert$。项 $\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert$ 表示三角形面积的两倍，即 $2A_T$。对于我们的等边三角形，$A_T = \\frac{\\sqrt{3}}{4}s^2$，所以 $\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert = \\frac{\\sqrt{3}}{2}s^2$。雅可比行列式为：\n$$\n|J(u,v)| = u \\frac{\\sqrt{3}}{2}s^2\n$$\n\n### 3. 积分的正则化\n\n将变换代入积分，我们得到：\n$$\nI[w] = \\int_0^1 \\int_0^1 \\frac{w(\\mathbf{r}'(u,v))}{\\lVert \\mathbf{r}'(u,v) \\rVert} |J(u,v)| \\,\\mathrm{d}u\\,\\mathrm{d}v\n$$\n分母中的距离项是：\n$$\n\\lVert \\mathbf{r}'(u,v) \\rVert = \\lVert u(v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b}) \\rVert = u \\lVert v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b} \\rVert\n$$\nDuffy 变换的关键特性是，来自雅可比行列式的因子 $u$ 与来自距离项的因子 $u$ 相抵消，从而使被积函数正则化：\n$$\nI[w] = \\int_0^1 \\int_0^1 \\frac{w(\\mathbf{r}'(u,v))}{u \\lVert v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b} \\rVert} \\left( u \\frac{\\sqrt{3}}{2}s^2 \\right) \\,\\mathrm{d}u\\,\\mathrm{d}v = \\frac{\\sqrt{3}}{2}s^2 \\int_0^1 \\int_0^1 \\frac{w(\\mathbf{r}'(u,v))}{\\lVert v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b} \\rVert} \\,\\mathrm{d}u\\,\\mathrm{d}v\n$$\n让我们计算分母中范数的平方：\n$$\n\\lVert v\\,\\mathbf{a} + (1-v)\\,\\mathbf{b} \\rVert^2 = v^2\\lVert\\mathbf{a}\\rVert^2 + (1-v)^2\\lVert\\mathbf{b}\\rVert^2 + 2v(1-v)(\\mathbf{a} \\cdot \\mathbf{b})\n$$\n当 $\\lVert\\mathbf{a}\\rVert^2 = s^2$，$\\lVert\\mathbf{b}\\rVert^2 = s^2$，以及 $\\mathbf{a} \\cdot \\mathbf{b} = s^2\\cos(\\pi/3) = s^2/2$ 时，上式变为：\n$$\ns^2 \\left( v^2 + (1-v)^2 + v(1-v) \\right) = s^2 (v^2 + 1 - 2v + v^2 + v - v^2) = s^2 (v^2 - v + 1)\n$$\n因此，正则化后的积分为：\n$$\nI[w] = \\frac{\\sqrt{3}}{2}s^2 \\int_0^1 \\int_0^1 \\frac{w(u,v)}{s \\sqrt{v^2 - v + 1}} \\,\\mathrm{d}u\\,\\mathrm{d}v = \\frac{\\sqrt{3}}{2}s \\int_0^1 \\int_0^1 \\frac{w(u,v)}{\\sqrt{v^2 - v + 1}} \\,\\mathrm{d}u\\,\\mathrm{d}v\n$$\n\n### 4. 权重函数分析\n\n我们在变换后的坐标系中分析两个指定的权重函数。\n\n**情况 1：常数权重, $w_0(\\mathbf{r}') = 1$**\n权重就是 $w_0(u,v) = 1$。积分变为：\n$$\nI[w_0] = \\frac{\\sqrt{3}}{2}s \\int_0^1 \\left(\\int_0^1 \\mathrm{d}u\\right) \\frac{1}{\\sqrt{v^2 - v + 1}} \\,\\mathrm{d}v = \\frac{\\sqrt{3}}{2}s \\int_0^1 \\frac{1}{\\sqrt{v^2 - v + 1}} \\,\\mathrm{d}v\n$$\n\n**情况 2：重心权重, $w_1(\\mathbf{r}') = \\lambda_0(\\mathbf{r}')$**\n与顶点 $\\mathbf{r}_0 = \\mathbf{0}$ 对应的重心坐标 $\\lambda_0$ 在 Duffy 映射 $\\mathbf{r}' = u \\mathbf{p} + (1-u)\\mathbf{0}$ 下由 $\\lambda_0 = 1-u$ 给出，其中 $\\mathbf{p}$ 是与 $\\mathbf{r}_0$ 相对的边上的一个点。因此，$w_1(u,v) = 1-u$。积分为：\n$$\nI[w_1] = \\frac{\\sqrt{3}}{2}s \\int_0^1 \\int_0^1 \\frac{1-u}{\\sqrt{v^2 - v + 1}} \\,\\mathrm{d}u\\,\\mathrm{d}v = \\frac{\\sqrt{3}}{2}s \\left(\\int_0^1 (1-u)\\,\\mathrm{d}u\\right) \\left(\\int_0^1 \\frac{\\mathrm{d}v}{\\sqrt{v^2 - v + 1}}\\right)\n$$\n由于 $\\int_0^1 (1-u)\\,\\mathrm{d}u = 1/2$，我们发现一个直接关系：\n$$\nI[w_1] = \\frac{1}{2} I[w_0]\n$$\n\n### 5. 解析解\n\n两个积分都取决于 $K = \\int_0^1 \\frac{\\mathrm{d}v}{\\sqrt{v^2 - v + 1}}$ 的值。我们通过配方法求解：\n$$\nK = \\int_0^1 \\frac{\\mathrm{d}v}{\\sqrt{(v - 1/2)^2 + 3/4}}\n$$\n使用换元法 $x = v - 1/2$，积分变为：\n$$\nK = \\int_{-1/2}^{1/2} \\frac{\\mathrm{d}x}{\\sqrt{x^2 + (\\sqrt{3}/2)^2}} = \\left[ \\ln\\left(x + \\sqrt{x^2 + 3/4}\\right) \\right]_{-1/2}^{1/2}\n$$\n$$\nK = \\ln\\left(\\frac{1}{2} + \\sqrt{\\frac{1}{4} + \\frac{3}{4}}\\right) - \\ln\\left(-\\frac{1}{2} + \\sqrt{\\frac{1}{4} + \\frac{3}{4}}\\right) = \\ln\\left(\\frac{3}{2}\\right) - \\ln\\left(\\frac{1}{2}\\right) = \\ln(3)\n$$\n积分的解析表达式为：\n$$\nI_{\\text{analytic}}[w_0] = \\frac{\\sqrt{3}}{2}s \\ln(3)\n$$\n$$\nI_{\\text{analytic}}[w_1] = \\frac{\\sqrt{3}}{4}s \\ln(3)\n$$\n\n### 6. 数值求积与误差分析\n\n将张量积高斯-勒让德求积应用于 $(u,v) \\in [0,1]^2$ 上的正则化二维积分。由于被积函数是可分离的，二维求积等价于两个一维求积的乘积。对于一个一般的可分离被积函数 $f(u,v) = g(u)h(v)$，数值积分为：\n$$\n\\int_0^1\\int_0^1 g(u)h(v)\\,\\mathrm{d}u\\,\\mathrm{d}v \\approx \\left(\\sum_i w_i' g(u_i)\\right) \\left(\\sum_j w_j' h(v_j)\\right)\n$$\n其中 $(u_i, w_i')$ 和 $(v_j, w_j')$ 是缩放到区间 $[0,1]$ 的一维高斯-勒让德节点和权重。\n\n对于两种权重情况，数值误差主要由积分 $K = \\int_0^1 (v^2 - v + 1)^{-1/2} \\,\\mathrm{d}v$ 的近似决定。对 $u$ 的积分涉及多项式（$1$ 和 $1-u$），任何阶数 $n \\ge 1$ 的高斯-勒让德法则都能精确积分。设 $K$ 的数值近似为 $K_{\\text{num}}$。\n\n数值为：\n$$\nI_{\\text{num}}[w_0] = \\frac{\\sqrt{3}}{2}s K_{\\text{num}} \\quad \\text{和} \\quad I_{\\text{num}}[w_1] = \\frac{\\sqrt{3}}{4}s K_{\\text{num}}\n$$\n对于 $w_0$ 的相对误差是：\n$$\n\\varepsilon_0 = \\frac{|I_{\\text{num}}[w_0] - I_{\\text{analytic}}[w_0]|}{|I_{\\text{analytic}}[w_0]|} = \\frac{|\\frac{\\sqrt{3}}{2}s K_{\\text{num}} - \\frac{\\sqrt{3}}{2}s \\ln(3)|}{|\\frac{\\sqrt{3}}{2}s \\ln(3)|} = \\frac{|K_{\\text{num}} - \\ln(3)|}{|\\ln(3)|}\n$$\n对于 $w_1$ 的相对误差是相同的：\n$$\n\\varepsilon_1 = \\frac{|I_{\\text{num}}[w_1] - I_{\\text{analytic}}[w_1]|}{|I_{\\text{analytic}}[w_1]|} = \\frac{|\\frac{\\sqrt{3}}{4}s K_{\\text{num}} - \\frac{\\sqrt{3}}{4}s \\ln(3)|}{|\\frac{\\sqrt{3}}{4}s \\ln(3)|} = \\frac{|K_{\\text{num}} - \\ln(3)|}{|\\ln(3)|}\n$$\n这表明相对误差与边长 $s$ 和权重函数（$w_0$ 或 $w_1$）的选择无关。因此，预计所有四种测试情况都会产生相同的相对误差。使用足够高阶的求积（例如，$n=64$），可以非常精确地计算 $K$ 的正则化被积函数，使得 $K_{\\text{num}}$ 与 $\\ln(3)$ 的标准 `float64` 表示相匹配，从而导致相对误差为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes the relative error for singular triangle integrals regularized\n    by the Duffy transformation, comparing numerical results to analytic solutions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of (side_length s, weight_type w).\n    test_cases = [\n        (1.0, 'w0'),       # Case A\n        (1.0, 'w1'),       # Case B\n        (3.0, 'w0'),       # Case C\n        (1.0e-6, 'w0'),    # Case D\n    ]\n\n    results = []\n    \n    # Use a sufficiently high quadrature order to resolve the smooth integrand.\n    # For a smooth (C-infinity) integrand, Gauss-Legendre quadrature converges\n    # exponentially. An order of 64 is more than sufficient to reach\n    # machine precision for the functions in this problem.\n    N_POINTS = 64\n\n    # Pre-calculate Gauss-Legendre nodes and weights for the interval [0, 1].\n    # roots_legendre returns for [-1, 1], so we scale them.\n    nodes_m11, weights_m11 = roots_legendre(N_POINTS)\n    nodes_01 = (nodes_m11.astype(np.float64) + 1.0) / 2.0\n    weights_01 = weights_m11.astype(np.float64) / 2.0\n\n    # The analytic value of the core 1D integral K = integral(1/sqrt(v^2-v+1)) dv from 0 to 1\n    analytic_K = np.log(3.0)\n\n    # Numerically compute the integral K using Gauss-Legendre quadrature.\n    # The integrand is evaluated at the scaled nodes.\n    v_integrand_at_nodes = 1.0 / np.sqrt(nodes_01**2 - nodes_01 + 1.0)\n    numerical_K = np.sum(weights_01 * v_integrand_at_nodes)\n\n    for s, weight_type in test_cases:\n        if weight_type == 'w0':\n            # For w0(r') = 1, the transformed weight is 1. The integral over u is 1.\n            # I[w0] = (sqrt(3)/2)*s * integral_u(1 du) * integral_v(...) dv\n            #       = (sqrt(3)/2)*s * 1 * K\n            numerical_val = (np.sqrt(3.0) / 2.0) * s * numerical_K\n            analytic_val = (np.sqrt(3.0) / 2.0) * s * analytic_K\n\n        elif weight_type == 'w1':\n            # For w1(r') = lambda_0, the transformed weight is 1-u.\n            # The integral of (1-u) from 0 to 1 is exactly 0.5.\n            # Gauss-Legendre quadrature integrates polynomials exactly.\n            # I[w1] = (sqrt(3)/2)*s * integral_u(1-u du) * integral_v(...) dv\n            #       = (sqrt(3)/2)*s * 0.5 * K\n            numerical_val = (np.sqrt(3.0) / 4.0) * s * numerical_K\n            analytic_val = (np.sqrt(3.0) / 4.0) * s * analytic_K\n        \n        else:\n            raise ValueError(f\"Unknown weight type: {weight_type}\")\n\n        # Compute the relative error.\n        # Check for analytic_val being zero to avoid division by zero, though not expected here.\n        if np.abs(analytic_val) > 0:\n            rel_error = np.abs(numerical_val - analytic_val) / np.abs(analytic_val)\n        else:\n            rel_error = np.abs(numerical_val)\n            \n        results.append(rel_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际的编程中，像顶点排序这样的几何细节可能会导致细微但关键的错误。这个实践聚焦于三角形的有向面积及其与Duffy变换雅可比行列式（Jacobian determinant）的关系。通过实现一个稳健的顶点排序方案，您将学会如何防止符号错误，并确保您的计算在任何输入顺序下都能保持一致，这是构建可靠的计算电磁学软件的一项至关重要的技能。",
            "id": "3302708",
            "problem": "在计算电磁学中，当评估具有弱奇异性的核函数（例如三维空间中的静态格林函数）时，奇异三角形积分会出现在边界积分公式中。考虑一个具有顶点 $\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2 \\in \\mathbb{R}^2$ 的非退化三角形，并且奇异点恰好位于其中一个三角形顶点，记为 $\\mathbf{r}_0$。使用重心（面积）坐标，设 $\\lambda_0(\\mathbf{r})$ 是与顶点 $\\mathbf{r}_0$ 相关联的标量线性节点基函数。定义弱奇异积分为\n$$\nI = \\iint_{T} \\frac{\\lambda_0(\\mathbf{r})}{\\|\\mathbf{r} - \\mathbf{r}_0\\|} \\, dA,\n$$\n其中 $T$ 是三角形域，$\\|\\cdot\\|$ 表示欧几里得范数，$dA$ 是面积元。Duffy变换将单位正方形 $[0,1]^2$ 映射到 $T$ 以对可积奇异点进行正则化。此变换的雅可比行列式取决于三角形的顶点排序以及边与映射的对齐方式。在实践中，如果方向不一致，可能会出现数值符号错误。\n\n您的任务是实现一个程序，该程序能够：\n- 指定并强制执行一条规则，以对三角形顶点和从奇异角点引出的两条边进行排序，从而使Duffy映射锚定在奇异顶点，并具有一致的逆时针方向。\n- 对每个测试用例，以两种方式数值计算积分 $I$：\n  1. 一种朴素的Duffy实现，它将映射锚定在奇异顶点，但保留输入中其他两个顶点的循环顺序，并使用有向雅可比行列式，如果方向是顺时针，可能会导致积分为负。\n  2. 一种一致方向的Duffy实现，它循环旋转顶点列表，使奇异顶点位于首位，然后在必要时交换其余两个顶点，以使有向面积为正，从而确保雅可比行列式为正且与基函数的求值对齐。\n\n您必须基于以下基本定义和事实进行推导和实现：\n- 三角形上的重心坐标和线性节点基函数 $\\lambda_i(\\mathbf{r})$，满足 $\\lambda_i(\\mathbf{v}_j) = \\delta_{ij}$ 和 $\\sum_{i=0}^2 \\lambda_i(\\mathbf{r}) = 1$。\n- 从 $[0,1]^2$ 到锚定于一个角点的三角形的Duffy变换，以及雅可比行列式定义为偏导数矩阵的行列式。\n- 三角形的有向面积与 $\\det\\big([\\mathbf{v}_1-\\mathbf{v}_0,\\mathbf{v}_2-\\mathbf{v}_0]\\big)$ 成正比，其符号编码了逆时针与顺时针方向。\n\n不要使用任何预先提供的快捷公式。从这些基本定义出发，推导出您需要的任何恒等式。\n\n测试套件：\n- 情况 $\\mathbf{A}$（理想情况，已经是逆时针）：顶点为 $\\big[(0,0),(1,0),(0,1)\\big]$，奇异顶点索引 $0$ 对应于 $\\mathbf{r}_0 = (0,0)$。\n- 情况 $\\mathbf{B}$（顺时针排序）：顶点为 $\\big[(0,0),(0,1),(1,0)\\big]$，奇异顶点索引 $0$ 对应于 $\\mathbf{r}_0 = (0,0)$。\n- 情况 $\\mathbf{C}$（奇异顶点不在列表首位，不等边，已旋转）：顶点为 $\\big[(1.0,0.2),(0.0,0.0),(0.7,0.9)\\big]$，奇异顶点索引 $1$ 对应于 $\\mathbf{r}_0 = (0,0)$。\n\n对于每种情况，计算两个浮点数：\n- $I_{\\text{naive}}$：通过朴素映射计算的积分（将映射锚定在奇异顶点，对其他两个顶点使用输入的循环顺序，并使用有向雅可比行列式）。\n- $I_{\\text{consistent}}$：通过首先旋转顶点使奇异顶点位于首位，然后在必要时交换其他两个顶点以使有向面积为正，最后使用相应的具有正雅可比行列式大小的Duffy映射计算的积分。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序如下\n$$\n\\big[I_{\\text{naive}}^{(A)}, I_{\\text{consistent}}^{(A)}, I_{\\text{naive}}^{(B)}, I_{\\text{consistent}}^{(B)}, I_{\\text{naive}}^{(C)}, I_{\\text{consistent}}^{(C)}\\big].\n$$\n所有输出必须是有限实数。不需要物理单位。如果存在角度，必须以弧度为单位，但指定的任务不需要角度。不使用百分比。数值积分的容差应选择得足够小，以使每个报告值的相对精度至少达到 $10^{-8}$。",
            "solution": "我们从基本定义开始。设三角形有顶点 $\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2 \\in \\mathbb{R}^2$，奇异点 $\\mathbf{r}_0$ 等于其中一个顶点。重心坐标 $\\lambda_i(\\mathbf{r})$ 满足 $\\lambda_i(\\mathbf{v}_j) = \\delta_{ij}$，$\\sum_{i=0}^2 \\lambda_i(\\mathbf{r}) = 1$，与奇异顶点相关的线性节点基函数是 $\\lambda_0(\\mathbf{r})$。我们感兴趣的积分是\n$$\nI = \\iint_{T} \\frac{\\lambda_0(\\mathbf{r})}{\\|\\mathbf{r}-\\mathbf{r}_0\\|} \\, dA.\n$$\n为了消除在 $\\mathbf{r}_0$ 处的可积奇异性，我们使用Duffy变换，这是一个从单位正方形 $[0,1]^2$ 到锚定于奇异角点的三角形的映射。记从 $\\mathbf{v}_0$（必须是奇异顶点，以使映射与奇异点对齐）引出的两条边为 $\\mathbf{e}_1 = \\mathbf{v}_1 - \\mathbf{v}_0$ 和 $\\mathbf{e}_2 = \\mathbf{v}_2 - \\mathbf{v}_0$。定义映射\n$$\n\\mathbf{r}(\\xi,\\eta) = \\mathbf{v}_0 + \\xi\\Big((1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2\\Big),\n\\quad (\\xi,\\eta)\\in[0,1]^2.\n$$\n根据构造，当 $\\xi=0$ 时，$\\mathbf{r} = \\mathbf{v}_0$；当 $\\xi=1$ 时，$\\mathbf{r}$ 描绘了从 $\\mathbf{v}_1$ 到 $\\mathbf{v}_2$ 的线段。此映射的雅可比行列式是其列为 $\\partial \\mathbf{r}/\\partial \\xi$ 和 $\\partial \\mathbf{r}/\\partial \\eta$ 的矩阵的行列式。我们计算\n$$\n\\frac{\\partial \\mathbf{r}}{\\partial \\xi} = (1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2, \\qquad\n\\frac{\\partial \\mathbf{r}}{\\partial \\eta} = \\xi(\\mathbf{e}_2 - \\mathbf{e}_1).\n$$\n因此，雅可比行列式为\n$$\nJ(\\xi,\\eta) = \\det\\left[\\frac{\\partial \\mathbf{r}}{\\partial \\xi}, \\frac{\\partial \\mathbf{r}}{\\partial \\eta}\\right]\n= \\det\\Big[(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2,\\ \\xi(\\mathbf{e}_2 - \\mathbf{e}_1)\\Big].\n$$\n利用行列式在二维空间中的双线性和反对称性，可将其简化为\n$$\nJ(\\xi,\\eta) = \\xi\\ \\det[\\mathbf{e}_1,\\mathbf{e}_2],\n$$\n这与 $\\eta$ 无关。$\\det[\\mathbf{e}_1,\\mathbf{e}_2]$ 的符号编码了方向：正值表示逆时针，负值表示顺时针。\n\n现在我们在此映射下表示 $\\lambda_0(\\mathbf{r})$。由于 $\\mathbf{r}(\\xi,\\eta)$ 是 $\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2$ 的凸组合，其权重为 $\\lambda_0 = 1-\\xi$，$\\lambda_1 = \\xi (1-\\eta)$ 和 $\\lambda_2 = \\xi \\eta$，我们有\n$$\n\\lambda_0(\\mathbf{r}(\\xi,\\eta)) = 1 - \\xi.\n$$\n我们还表示到奇异点的距离：\n$$\n\\|\\mathbf{r}(\\xi,\\eta) - \\mathbf{r}_0\\| = \\|\\mathbf{r}(\\xi,\\eta) - \\mathbf{v}_0\\| = \\|\\xi((1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2)\\| = \\xi \\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|.\n$$\n将这些代入被积函数中，得到\n$$\n\\frac{\\lambda_0(\\mathbf{r}(\\xi,\\eta))}{\\|\\mathbf{r}(\\xi,\\eta)-\\mathbf{r}_0\\|} = \\frac{1-\\xi}{\\xi \\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|}.\n$$\n面积元变换为 $dA = |J(\\xi,\\eta)|\\, d\\xi\\, d\\eta$，如果我们旨在计算具有正测度的物理积分。有两种计算选择可以突显方向问题：\n\n1. 朴素方法：将映射锚定在奇异顶点，但保留输入中其他两个顶点的循环顺序，并直接使用有向雅可比行列式 $J(\\xi,\\eta) = \\xi \\det[\\mathbf{e}_1,\\mathbf{e}_2]$，不取绝对值，也不为修正方向而重新排序。计算出的积分为\n$$\nI_{\\text{naive}} = \\int_0^1 \\int_0^1 \\frac{1-\\xi}{\\xi \\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|} \\cdot \\Big(\\xi \\det[\\mathbf{e}_1,\\mathbf{e}_2]\\Big)\\, d\\xi\\, d\\eta.\n$$\n2. 一致方向方法：循环旋转顶点，使奇异顶点位于首位，然后在必要时交换其他两个顶点，以使 $\\det[\\mathbf{e}_1,\\mathbf{e}_2]  0$。使用正的雅可比行列式大小 $|J(\\xi,\\eta)| = \\xi\\, |\\det[\\mathbf{e}_1,\\mathbf{e}_2]|$。计算出的积分为\n$$\nI_{\\text{consistent}} = \\int_0^1 \\int_0^1 \\frac{1-\\xi}{\\xi \\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|} \\cdot \\Big(\\xi\\, |\\det[\\mathbf{e}_1,\\mathbf{e}_2]|\\Big)\\, d\\xi\\, d\\eta,\n$$\n其中 $\\mathbf{e}_1,\\mathbf{e}_2$ 取自方向修正后的排序。\n\n在这两种情况下，因子 $\\xi$ 被消去，被积函数变得可分离变量：\n$$\nI_{\\square} = \\left(\\int_0^1 (1-\\xi)\\, d\\xi \\right) \\left(\\int_0^1 \\frac{\\kappa_{\\square}}{\\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|}\\, d\\eta \\right),\n$$\n其中 $\\kappa_{\\text{naive}} = \\det[\\mathbf{e}_1,\\mathbf{e}_2]$ 和 $\\kappa_{\\text{consistent}} = |\\det[\\mathbf{e}_1,\\mathbf{e}_2]|$，下标 $\\square$ 表示朴素或一致性求值。关于 $\\xi$ 的积分计算结果为\n$$\n\\int_0^1 (1-\\xi)\\, d\\xi = \\frac{1}{2}.\n$$\n因此\n$$\nI_{\\square} = \\frac{1}{2} \\int_0^1 \\frac{\\kappa_{\\square}}{\\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|}\\, d\\eta.\n$$\n分母仅取决于 $\\mathbf{e}_1$ 和 $\\mathbf{e}_2$ 的位置。交换 $\\mathbf{e}_1$ 和 $\\mathbf{e}_2$ 会反转线段的参数化，但由于映射 $\\eta \\mapsto 1-\\eta$ 保留了对称范数的积分，因此在 $\\eta \\in [0,1]$ 上的积分保持不变。因此，两种方法之间的唯一区别是由 $\\kappa_{\\square}$ 携带的符号。如果输入的三角形以奇异顶点为首位按顺时针列出，则 $\\det[\\mathbf{e}_1,\\mathbf{e}_2]  0$ 且 $I_{\\text{naive}}$ 将为负，而 $I_{\\text{consistent}}$ 将为正且大小相同。这说明了为什么一致的方向可以避免符号错误：通过强制 $\\det[\\mathbf{e}_1,\\mathbf{e}_2]  0$，雅可比行列式的大小为正，积分具有正确的符号，而基函数 $\\lambda_0(\\mathbf{r}) = 1-\\xi$ 的求值也与该方向保持一致。\n\n避免符号错误并将奇异角点与Duffy映射对齐的算法步骤：\n- 给定一个输入顶点列表 $\\big[\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2\\big]$ 和奇异顶点的索引 $s \\in \\{0,1,2\\}$，循环旋转列表，使奇异顶点位于首位：$\\big[\\mathbf{v}_s,\\mathbf{v}_{s+1 \\bmod 3},\\mathbf{v}_{s+2 \\bmod 3}\\big]$。\n- 计算 $\\mathbf{e}_1 = \\mathbf{v}_1-\\mathbf{v}_0$ 和 $\\mathbf{e}_2 = \\mathbf{v}_2-\\mathbf{v}_0$，然后计算有向面积行列式 $\\det[\\mathbf{e}_1,\\mathbf{e}_2]$。\n- 如果 $\\det[\\mathbf{e}_1,\\mathbf{e}_2]  0$，则交换 $\\mathbf{v}_1$ 和 $\\mathbf{v}_2$，使行列式变为正值。这也交换了两条局部边，从而使雅可比行列式和基函数求值一致对齐。\n- 使用锚定于 $\\mathbf{v}_0$ 的Duffy映射进行数值积分。\n\n对于数值评估，可分离形式产生一个在 $\\eta \\in [0,1]$ 上的一维积分：\n$$\nI_{\\text{naive}} = \\frac{1}{2}\\, \\det[\\mathbf{e}_1,\\mathbf{e}_2]\\ \\int_0^1 \\frac{d\\eta}{\\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|},\n\\quad\nI_{\\text{consistent}} = \\frac{1}{2}\\, \\big|\\det[\\mathbf{e}_1,\\mathbf{e}_2]\\big|\\ \\int_0^1 \\frac{d\\eta}{\\left\\|(1-\\eta)\\mathbf{e}_1 + \\eta \\mathbf{e}_2 \\right\\|}.\n$$\n对于非退化三角形，$\\mathbf{e}_1$ 和 $\\mathbf{e}_2$ 不共线，因此该积分没有奇异性。\n\n测试套件解释：\n- 情况 $\\mathbf{A}$：$\\big[(0,0),(1,0),(0,1)\\big]$，奇异点索引为 $0$，已经是逆时针方向，因此 $I_{\\text{naive}}$ 和 $I_{\\text{consistent}}$ 均为正且相等。\n- 情况 $\\mathbf{B}$：$\\big[(0,0),(0,1),(1,0)\\big]$，奇异点索引为 $0$，是顺时针方向，因此 $I_{\\text{naive}}$ 是情况 $\\mathbf{A}$ 值的负数，而 $I_{\\text{consistent}}$ 等于情况 $\\mathbf{A}$ 的正值。\n- 情况 $\\mathbf{C}$：$\\big[(1.0,0.2),(0.0,0.0),(0.7,0.9)\\big]$，奇异点索引为 $1$，需要旋转以将奇异顶点锚定在首位；如果得到的顺序是顺时针，朴素结果可能为负，而一致性结果为正。情况 $\\mathbf{A}$ 和 $\\mathbf{B}$ 的两个一致性结果匹配，而情况 $\\mathbf{C}$ 会产生一个不同的正数，因为几何形状不同。\n\n该程序实现了这些步骤，使用具有严格容差的数值积分法评估一维积分，以达到至少 $10^{-8}$ 的相对精度，并按指定顺序将最终结果打印为单个列表。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef signed_area_det(e1: np.ndarray, e2: np.ndarray) - float:\n    # 2D cross product (determinant of [e1, e2])\n    return e1[0]*e2[1] - e1[1]*e2[0]\n\ndef rotate_vertices(vertices, start_index):\n    # Cyclically rotate so that vertices[start_index] becomes first\n    return vertices[start_index:] + vertices[:start_index]\n\ndef duffy_integral(vertices, singular_index, orientation_mode=\"naive\"):\n    \"\"\"\n    Compute I = ∫_T lambda0(r)/||r - r0|| dA using Duffy mapping anchored at the singular vertex.\n    orientation_mode: \"naive\" preserves input cyclic order after rotation to make singular first,\n                      uses signed determinant in the Jacobian.\n                      \"consistent\" enforces positive orientation by swapping v1,v2 if needed,\n                      uses positive determinant magnitude.\n    \"\"\"\n    # Ensure singular vertex is first by rotation\n    verts = rotate_vertices(vertices, singular_index)\n    v0 = np.array(verts[0], dtype=float)\n    v1 = np.array(verts[1], dtype=float)\n    v2 = np.array(verts[2], dtype=float)\n\n    # Edge vectors from the singular corner\n    e1 = v1 - v0\n    e2 = v2 - v0\n\n    det = signed_area_det(e1, e2)\n\n    if orientation_mode == \"consistent\":\n        # Enforce positive orientation\n        if det  0.0:\n            # swap e1 and e2\n            e1, e2 = e2, e1\n            det = -det  # now positive\n\n        det_factor = abs(det)\n    elif orientation_mode == \"naive\":\n        # Keep original cyclic order and signed determinant\n        det_factor = det\n    else:\n        raise ValueError(\"orientation_mode must be 'naive' or 'consistent'\")\n\n    # Define the 1D integrand over eta in [0,1]: det_factor / ||(1-eta)*e1 + eta*e2||\n    def integrand_eta(eta):\n        s = (1.0 - eta) * e1 + eta * e2\n        norm_s = np.hypot(s[0], s[1])\n        return det_factor / norm_s\n\n    # Perform numerical integration with tight tolerances\n    integ_val, _ = quad(integrand_eta, 0.0, 1.0, epsabs=1e-12, epsrel=1e-12, limit=200)\n    return 0.5 * integ_val\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (vertices list, singular_index)\n    test_cases = [\n        ([(0.0, 0.0), (1.0, 0.0), (0.0, 1.0)], 0),  # Case A\n        ([(0.0, 0.0), (0.0, 1.0), (1.0, 0.0)], 0),  # Case B\n        ([(1.0, 0.2), (0.0, 0.0), (0.7, 0.9)], 1),  # Case C\n    ]\n\n    results = []\n    for vertices, sidx in test_cases:\n        I_naive = duffy_integral(vertices, sidx, orientation_mode=\"naive\")\n        I_consistent = duffy_integral(vertices, sidx, orientation_mode=\"consistent\")\n        results.append(I_naive)\n        results.append(I_consistent)\n\n    # Final print statement in the exact required format.\n    # Use full precision string conversion for clarity.\n    print(f\"[{','.join(map(lambda x: f'{x:.15g}', results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "奇点并非总能方便地位于顶点；它们可能出现在单元内的任何地方。在这个练习中，我们将推广Duffy方法，首先将原三角形分割成多个共享内部奇点作为公共顶点的子三角形。然后，对每个子三角形应用Duffy变换。这个练习展示了Duffy变换框架在处理任意位置弱奇点时的完全灵活性，并引入了数值收敛性研究的概念，以评估您实现的准确性和效率。",
            "id": "3302713",
            "problem": "您的任务是实现一个数值积分方法，用于计算在单个平坦三角片元上进行 Rao–Wilton–Glisson (RWG) 测试时出现的典型电场积分方程 (EFIE) 自积分项。该计算需使用 Duffy 变换来对弱奇异核进行正则化。此计算必须以数学上严谨且自洽的方式进行，从频域标量格林函数的基本定义和三角形的标准仿射参数化开始。\n\n频域中的 EFIE 涉及亥姆霍兹方程的标量格林函数，其定义为 $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{e^{-j k \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}}{4 \\pi \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}$，其中 $k$ 是波数。为解决此问题，您需要计算一个形如下式的典型自积分项：\n$$\nI = \\int_{T} \\phi(\\mathbf{r}) \\, \\frac{e^{-j k \\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert}}{\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert} \\, \\mathrm{d}S,\n$$\n其中 $T$ 是三维空间中的一个平坦三角形，其顶点为 $\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_2 \\in \\mathbb{R}^3$，$\\mathbf{r}_0$ 是一个严格位于 $T$ 内部的固定观测点，而 $\\phi(\\mathbf{r})$ 是一个代表 RWG 测试权重的标量权重函数。该积分在 $\\mathbf{r} = \\mathbf{r}_0$ 处是弱奇异的，必须使用 Duffy 变换进行正则化。\n\n您必须基于以下基本原理进行推导：\n- 使用频域标量格林函数的定义 $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{e^{-j k \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}}{4 \\pi \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}$ 及其在 $k=0$ 时的静态极限。\n- 使用三角形的标准仿射参数化和基本的多变量微积分，特别是包含雅可比行列式的变量替换定理。\n- 使用 Duffy 变换，通过将共享点 $\\mathbf{r}_0$ 的一组子三角形映射到张量积域来消除奇异性。\n\n通过将 $T$ 分割成三个共享公共顶点 $\\mathbf{r}_0$ 的子三角形 $T_i$（即 $T_0 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_0,\\mathbf{v}_1\\}$、$T_1 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_1,\\mathbf{v}_2\\}$ 和 $T_2 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_2,\\mathbf{v}_0\\}$），来推导一种消除奇异性的积分方法。在每个子三角形 $T_i = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{a},\\mathbf{b}\\}$ 上，应用 Duffy 映射\n$$\n\\mathbf{r}(\\rho,\\sigma) = \\mathbf{r}_0 + \\rho \\big((1-\\sigma)\\,(\\mathbf{a}-\\mathbf{r}_0) + \\sigma \\, (\\mathbf{b}-\\mathbf{r}_0)\\big), \\quad \\rho \\in [0,1], \\ \\sigma \\in [0,1],\n$$\n并推导相应的雅可比行列式以及 $1/\\lVert \\mathbf{r}-\\mathbf{r}_0 \\rVert$ 奇异性的消去过程。然后，为每个子三角形在 $[0,1] \\times [0,1]$ 上设计一个每维 $N$ 个点的张量高斯-勒让德法则，并证明变换后的被积函数是正则的。\n\n标量权重 $\\phi(\\mathbf{r})$ 必须是以下之一：\n- 常数权重 $\\phi(\\mathbf{r}) = 1$，或\n- 线性重心权重 $\\phi(\\mathbf{r}) = \\lambda_0(\\mathbf{r})$，即与原始三角形 $T$ 的顶点 $\\mathbf{v}_0$ 相关联的重心坐标。\n\n您必须实现一个程序，该程序：\n- 使用国际单位制 (SI)。所有坐标单位必须是米，波数 $k$ 的单位是弧度/米，指数函数使用弧度。最终报告的数值误差必须是无量纲小数。\n- 对于每个测试用例，使用 Duffy 变换后的张量积高斯-勒让德积分法（每维 $N$ 个点）计算积分 $I_N$，其中 $N \\in \\{2, 4, 8, 16, 32\\}$。\n- 对于每个测试用例，使用相同的方案（每维 $N_{\\text{ref}} = 80$ 个点）计算一个参考值 $I_{\\text{ref}}$。\n- 对于每个测试用例和每个 $N$，报告由下式定义的相对误差\n$$\n\\varepsilon_N = \\frac{\\lvert I_N - I_{\\text{ref}} \\rvert}{\\lvert I_{\\text{ref}} \\rvert},\n$$\n其中对于复值积分，模指的是复数模。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。输出必须将所有测试用例的结果聚合到一个列表的列表中，其中每个测试用例的内部列表包含对应于 $N \\in \\{2, 4, 8, 16, 32\\}$ 的五个相对误差。例如，包含三个测试用例的输出应如下所示：\n`[[\\varepsilon_2^{(1)},\\varepsilon_4^{(1)},\\varepsilon_8^{(1)},\\varepsilon_{16}^{(1)},\\varepsilon_{32}^{(1)}],[\\varepsilon_2^{(2)},\\ldots],[\\varepsilon_2^{(3)},\\ldots]]`。\n\n使用以下测试套件：\n- 测试用例 A (理想路径)：边长为 1 米的等边三角形，顶点为 $\\mathbf{v}_0 = (0,0,0)$, $\\mathbf{v}_1 = (1,0,0)$, $\\mathbf{v}_2 = (0.5,\\sqrt{3}/2,0)$；观测点 $\\mathbf{r}_0$ 位于形心 $\\mathbf{r}_0 = (\\tfrac{1}{3}, \\tfrac{\\sqrt{3}}{6}, 0)$；权重 $\\phi(\\mathbf{r}) = 1$；波数 $k = 0$ 弧度/米。\n- 测试用例 B (近顶点观测和线性权重)：三角形，顶点为 $\\mathbf{v}_0 = (0,0,0)$, $\\mathbf{v}_1 = (1,0,0)$, $\\mathbf{v}_2 = (1.001, 0.05, 0)$；观测点 $\\mathbf{r}_0 = \\mathbf{v}_0 + 0.01 (\\mathbf{v}_1 - \\mathbf{v}_0) + 0.01 (\\mathbf{v}_2 - \\mathbf{v}_0)$；权重 $\\phi(\\mathbf{r}) = \\lambda_0(\\mathbf{r})$；波数 $k = 0$ 弧度/米。\n- 测试用例 C (振荡核)：与测试用例 A 相同的三角形和观测点；权重 $\\phi(\\mathbf{r}) = 1$；波数 $k = 10$ 弧度/米。\n\n您的实现应数值稳定，严格遵循 Duffy 变换来处理奇异性，并按规定报告相对误差列表。角度必须以弧度为单位。最终的打印输出必须只包含带数字的列表的列表的单行内容，不得包含任何附加文本。",
            "solution": "该问题要求对单个平坦三角形单元在电场积分方程 (EFIE) 背景下产生的弱奇异积分进行数值计算。该积分由下式给出\n$$\nI = \\int_{T} \\phi(\\mathbf{r}) \\, \\frac{e^{-j k \\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert}}{\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert} \\, \\mathrm{d}S\n$$\n其中 $T$ 是 $\\mathbb{R}^3$ 中的一个三角形，顶点为 $\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_2$，$\\mathbf{r}_0$ 是一个严格位于 $T$ 内部的观测点，$k$ 是波数，$\\phi(\\mathbf{r})$ 是一个标量权重函数。当 $\\mathbf{r} \\to \\mathbf{r}_0$ 时，被积函数具有 $1/\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert$ 形式的弱奇异性。标准的积分方法会失效或表现出较差的收敛性。为解决此问题，我们采用 Duffy 变换来对积分进行正则化。\n\n第一步是将三角形 $T$ 分割成三个不重叠的子三角形 $T_0, T_1, T_2$，它们共享奇异点 $\\mathbf{r}_0$ 作为公共顶点。这些子三角形由 $\\mathbf{r}_0$ 和原始三角形的顶点对的凸包定义：\n$$\nT_0 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_0,\\mathbf{v}_1\\}, \\quad T_1 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_1,\\mathbf{v}_2\\}, \\quad T_2 = \\operatorname{conv}\\{\\mathbf{r}_0,\\mathbf{v}_2,\\mathbf{v}_0\\}\n$$\n总积分是这些子三角形上积分的总和：\n$$\nI = \\sum_{i=0}^{2} \\int_{T_i} \\phi(\\mathbf{r}) \\, \\frac{e^{-j k \\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert}}{\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert} \\, \\mathrm{d}S\n$$\n我们考虑一个通用的子三角形 $T_i = \\operatorname{conv}\\{\\mathbf{r}_0, \\mathbf{a}, \\mathbf{b}\\}$。我们应用 Duffy 变换，它将单位正方形 $(\\rho, \\sigma) \\in [0,1] \\times [0,1]$ 映射到这个子三角形。该映射由下式给出：\n$$\n\\mathbf{r}(\\rho,\\sigma) = \\mathbf{r}_0 + \\rho \\big((1-\\sigma)\\,(\\mathbf{a}-\\mathbf{r}_0) + \\sigma \\, (\\mathbf{b}-\\mathbf{r}_0)\\big)\n$$\n我们定义从奇异点出发张成该子三角形的两个向量：$\\mathbf{u} = \\mathbf{a} - \\mathbf{r}_0$ 和 $\\mathbf{v} = \\mathbf{b} - \\mathbf{r}_0$。该映射简化为：\n$$\n\\mathbf{r}(\\rho,\\sigma) = \\mathbf{r}_0 + \\rho \\big((1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v}\\big)\n$$\n于是，从奇异点出发的距离向量为 $\\mathbf{r}(\\rho,\\sigma) - \\mathbf{r}_0 = \\rho \\big((1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v}\\big)$，其模为 $\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert = \\rho \\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert$，因为 $\\rho \\in [0,1]$。此表达式中的 $\\rho$ 项是原始坐标系中奇异性的来源，因为 $\\rho \\to 0$ 对应于 $\\mathbf{r} \\to \\mathbf{r}_0$。\n\n为了进行变量替换，我们必须计算变换的雅可比行列式。面元 $\\mathrm{d}S$ 变换为 $\\mathrm{d}S = \\lVert \\frac{\\partial \\mathbf{r}}{\\partial \\rho} \\times \\frac{\\partial \\mathbf{r}}{\\partial \\sigma} \\rVert \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\sigma$。偏导数如下：\n$$\n\\frac{\\partial \\mathbf{r}}{\\partial \\rho} = (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v}\n$$\n$$\n\\frac{\\partial \\mathbf{r}}{\\partial \\sigma} = \\rho(-\\mathbf{u} + \\mathbf{v}) = \\rho(\\mathbf{v} - \\mathbf{u})\n$$\n叉积为：\n$$\n\\frac{\\partial \\mathbf{r}}{\\partial \\rho} \\times \\frac{\\partial \\mathbf{r}}{\\partial \\sigma} = \\big((1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v}\\big) \\times \\rho(\\mathbf{v} - \\mathbf{u}) = \\rho \\big[ (1-\\sigma)(\\mathbf{u} \\times \\mathbf{v}) - \\sigma(\\mathbf{v} \\times \\mathbf{u}) \\big] = \\rho (\\mathbf{u} \\times \\mathbf{v})\n$$\n该向量的模即为曲面积分的雅可比行列式：\n$$\nJ(\\rho,\\sigma) = \\lVert \\rho (\\mathbf{u} \\times \\mathbf{v}) \\rVert = \\rho \\lVert \\mathbf{u} \\times \\mathbf{v} \\rVert\n$$\n将这些表达式代入 $T_i$ 上的积分，我们得到：\n$$\nI_i = \\int_0^1 \\int_0^1 \\phi(\\mathbf{r}(\\rho,\\sigma)) \\frac{e^{-j k \\rho \\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert}}{\\rho \\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert} \\left( \\rho \\lVert \\mathbf{u} \\times \\mathbf{v} \\rVert \\right) \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\sigma\n$$\n雅可比行列式中的因子 $\\rho$ 巧妙地消去了分母中的奇异项 $\\rho$。这就是 Duffy 变换正则化能力的精髓所在。变换后得到的积分为：\n$$\nI_i = \\int_0^1 \\int_0^1 \\phi(\\mathbf{r}(\\rho,\\sigma)) \\, \\frac{e^{-j k \\rho \\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert}}{\\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert} \\, \\lVert \\mathbf{u} \\times \\mathbf{v} \\rVert \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\sigma\n$$\n此时，被积函数是正则的。分母 $\\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert$ 是一个向量的长度，该向量是 $\\mathbf{u}$ 和 $\\mathbf{v}$ 的凸组合。由于 $\\mathbf{r}_0, \\mathbf{a}, \\mathbf{b}$ 构成一个非退化三角形，$\\mathbf{u}$ 和 $\\mathbf{v}$ 不共线，因此对于 $\\sigma \\in [0,1]$，该分母永不为零。被积函数是光滑的，可以使用标准的数值积分方法（如张量积高斯-勒让德法则）进行精确计算。\n\n权重函数 $\\phi(\\mathbf{r})$ 也必须用新坐标表示。如果 $\\phi(\\mathbf{r}) = 1$，它仍然是 $1$。如果 $\\phi(\\mathbf{r}) = \\lambda_0(\\mathbf{r})$，即 $\\mathbf{r}$ 相对于原始三角形 $T$ 的顶点 $\\mathbf{v}_0$ 的重心坐标，我们必须为每个积分点 $\\mathbf{r}(\\rho,\\sigma)$ 计算它。使用面积比公式，$\\lambda_0(\\mathbf{r})$ 由下式给出：\n$$\n\\lambda_0(\\mathbf{r}) = \\frac{\\text{Area}(\\mathbf{r}, \\mathbf{v}_1, \\mathbf{v}_2)}{\\text{Area}(\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_2)} = \\frac{\\frac{1}{2} \\lVert (\\mathbf{v}_1 - \\mathbf{r}) \\times (\\mathbf{v}_2 - \\mathbf{r}) \\rVert}{\\frac{1}{2} \\lVert (\\mathbf{v}_1 - \\mathbf{v}_0) \\times (\\mathbf{v}_2 - \\mathbf{v}_0) \\rVert} = \\frac{\\lVert (\\mathbf{v}_1 - \\mathbf{r}) \\times (\\mathbf{v}_2 - \\mathbf{r}) \\rVert}{\\lVert (\\mathbf{v}_1 - \\mathbf{v}_0) \\times (\\mathbf{v}_2 - \\mathbf{v}_0) \\rVert}\n$$\n通过先求出 $\\mathbf{r}(\\rho,\\sigma)$，然后将其代入该公式即可计算此表达式。\n\n数值积分使用 $N$ 点的张量积高斯-勒让德积分法进行。设 $(\\xi_m, w_m)_{m=1}^N$ 为 $[0,1]$ 上的高斯-勒让德点和权重。子三角形 $T_i$ 上的积分近似为：\n$$\nI_i \\approx \\sum_{m=1}^{N} \\sum_{n=1}^{N} w_m w_n F(\\xi_m, \\xi_n)\n$$\n其中 $F(\\rho,\\sigma)$ 是正则化后的被积函数：\n$$\nF(\\rho,\\sigma) = \\phi(\\mathbf{r}(\\rho,\\sigma)) \\, \\frac{e^{-j k \\rho \\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert}}{\\lVert (1-\\sigma)\\mathbf{u} + \\sigma\\mathbf{v} \\rVert} \\, \\lVert \\mathbf{u} \\times \\mathbf{v} \\rVert\n$$\n总积分 $I$ 是三个子三角形结果的总和。对于每个测试用例，我们计算不同 $N$ 值下的积分 $I_N$，并使用一个较大的 $N_{\\text{ref}}$ 计算一个高精度参考值 $I_{\\text{ref}}$。然后，相对误差计算为 $\\varepsilon_N = \\lvert I_N - I_{\\text{ref}} \\rvert / \\lvert I_{\\text{ref}} \\rvert$，其中 $\\lvert \\cdot \\rvert$ 是复数模。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef get_gauss_legendre_quadrature_1d(n_points):\n    \"\"\"\n    Returns Gauss-Legendre quadrature points and weights for the interval [0, 1].\n    \n    Args:\n        n_points (int): The number of quadrature points.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing points and weights.\n    \"\"\"\n    points, weights = roots_legendre(n_points)\n    # roots_legendre returns for [-1, 1], so we map to [0, 1]\n    mapped_points = 0.5 * (points + 1.0)\n    mapped_weights = 0.5 * weights\n    return mapped_points, mapped_weights\n\ndef evaluate_integral_on_subtriangle(r0, a, b, k, v_all, phi_type, n_points):\n    \"\"\"\n    Evaluates the regularized integral on a subtriangle conv(r0, a, b).\n    \n    Args:\n        r0 (np.ndarray): The singular observation point.\n        a (np.ndarray): First vertex of the subtriangle base.\n        b (np.ndarray): Second vertex of the subtriangle base.\n        k (float): Wavenumber.\n        v_all (list[np.ndarray]): Vertices of the original triangle [v0, v1, v2].\n        phi_type (str): Type of weighting function ('constant' or 'barycentric').\n        n_points (int): Number of Gauss points per dimension.\n        \n    Returns:\n        complex: The complex value of the integral over the subtriangle.\n    \"\"\"\n    points, weights = get_gauss_legendre_quadrature_1d(n_points)\n    \n    u = a - r0\n    v = b - r0\n    \n    jac_const = np.linalg.norm(np.cross(u, v))\n    \n    v0, v1, v2 = v_all\n    bary_denom = 0.0\n    if phi_type == 'barycentric':\n        bary_denom = np.linalg.norm(np.cross(v1 - v0, v2 - v0))\n    \n    integral_sum = 0.0 + 0.0j\n    \n    rho_vals, w_rho = points, weights\n    sigma_vals, w_sigma = points, weights\n    \n    for i in range(n_points):\n        rho = rho_vals[i]\n        for j in range(n_points):\n            sigma = sigma_vals[j]\n            \n            # Current mapped point in the original space\n            r_vec = r0 + rho * ((1 - sigma) * u + sigma * v)\n            \n            # Evaluate weight function phi\n            phi_val = 1.0\n            if phi_type == 'barycentric':\n                # Barycentric coordinate lambda_0 relative to v0\n                bary_num = np.linalg.norm(np.cross(v1 - r_vec, v2 - r_vec))\n                if bary_denom > 1e-15:\n                    phi_val = bary_num / bary_denom\n                else:\n                    phi_val = 0.0\n            \n            # Evaluate the regularized integrand\n            denom_vec = (1 - sigma) * u + sigma * v\n            denom_norm = np.linalg.norm(denom_vec)\n            \n            if denom_norm  1e-15:\n                # Should not happen for non-degenerate triangles, but handle to avoid division by zero.\n                integrand_val = 0.0 + 0.0j\n            else:\n                if k == 0:\n                    kernel_val = 1.0 / denom_norm\n                else:\n                    kernel_val = np.exp(-1j * k * rho * denom_norm) / denom_norm\n\n                integrand_val = phi_val * kernel_val * jac_const\n\n            integral_sum += w_rho[i] * w_sigma[j] * integrand_val\n            \n    return integral_sum\n\ndef duffy_quadrature(vertices, r0, k, phi_type, n_points):\n    \"\"\"\n    Computes the singular integral over a triangle using Duffy transformation.\n    \n    Args:\n        vertices (list[np.ndarray]): List of 3 vertices of the triangle.\n        r0 (np.ndarray): The singular observation point.\n        k (float): Wavenumber.\n        phi_type (str): Type of weighting function ('constant' or 'barycentric').\n        n_points (int): Number of Gauss points per dimension.\n        \n    Returns:\n        complex: The numerically computed integral value.\n    \"\"\"\n    v0, v1, v2 = vertices\n    \n    # Define the three subtriangles\n    sub_triangles = [\n        (v0, v1),\n        (v1, v2),\n        (v2, v0)\n    ]\n    \n    total_integral = 0.0 + 0.0j\n    for a, b in sub_triangles:\n        total_integral += evaluate_integral_on_subtriangle(r0, a, b, k, vertices, phi_type, n_points)\n        \n    return total_integral\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute relative errors.\n    \"\"\"\n    test_cases = [\n        # Test case A\n        {\n            \"name\": \"A\",\n            \"vertices\": [np.array([0., 0., 0.]), np.array([1., 0., 0.]), np.array([0.5, np.sqrt(3)/2, 0.])],\n            \"r0\": np.array([1./3., np.sqrt(3)/6., 0.]),\n            \"k\": 0.0,\n            \"phi_type\": \"constant\"\n        },\n        # Test case B\n        {\n            \"name\": \"B\",\n            \"vertices\": [np.array([0., 0., 0.]), np.array([1., 0., 0.]), np.array([1.001, 0.05, 0.])],\n            \"r0\": np.array([0., 0., 0.]) + 0.01 * (np.array([1., 0., 0.]) - np.array([0., 0., 0.])) + 0.01 * (np.array([1.001, 0.05, 0.]) - np.array([0., 0., 0.])),\n            \"k\": 0.0,\n            \"phi_type\": \"barycentric\"\n        },\n        # Test case C\n        {\n            \"name\": \"C\",\n            \"vertices\": [np.array([0., 0., 0.]), np.array([1., 0., 0.]), np.array([0.5, np.sqrt(3)/2, 0.])],\n            \"r0\": np.array([1./3., np.sqrt(3)/6., 0.]),\n            \"k\": 10.0,\n            \"phi_type\": \"constant\"\n        }\n    ]\n\n    N_vals = [2, 4, 8, 16, 32]\n    N_ref = 80\n    \n    all_results = []\n\n    for case in test_cases:\n        v = case[\"vertices\"]\n        r0 = case[\"r0\"]\n        k = case[\"k\"]\n        phi = case[\"phi_type\"]\n\n        I_ref = duffy_quadrature(v, r0, k, phi, N_ref)\n        \n        errors = []\n        for N in N_vals:\n            I_N = duffy_quadrature(v, r0, k, phi, N)\n            \n            # The problem asks for the integral of phi * G_kernel, where G_kernel is without 4*pi\n            # The relative error is |I_N - I_ref| / |I_ref|\n            if np.abs(I_ref)  1e-15:\n                # If reference is zero, error is absolute difference\n                error = np.abs(I_N - I_ref)\n            else:\n                error = np.abs(I_N - I_ref) / np.abs(I_ref)\n            errors.append(error)\n        \n        all_results.append(errors)\n    \n    # Format the output as a string list of lists, without spaces\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n\n```"
        }
    ]
}