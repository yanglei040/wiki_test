{
    "hands_on_practices": [
        {
            "introduction": "This exercise forms the bedrock of applying the equivalence principle computationally. You will discretize the continuous Huygens boundary integral into a finite sum for a canonical two-dimensional problem, translating the elegant theory into a practical algorithm . By comparing your numerical result against a known analytical solution, you will directly verify the principle's accuracy and gain tangible intuition for the process of numerical quadrature in wave physics.",
            "id": "3314980",
            "problem": "Consider the two-dimensional ($2$D) time-harmonic Transverse Magnetic (TM) polarization in free space, where the scalar electric field component $E_z$ obeys the scalar Helmholtz equation. Let $u(\\mathbf{r})$ denote the scalar field $E_z(\\mathbf{r})$ for a single-frequency solution with angular frequency $\\omega$ and free-space wavenumber $k$ (in radians per meter). In free space, $u(\\mathbf{r})$ satisfies the homogeneous Helmholtz equation $(\\nabla^2 + k^2) u(\\mathbf{r}) = 0$ in regions without sources, and the fundamental solution (the free-space Green's function) for the $2$D Helmholtz equation is the function\n$$\nG(\\mathbf{r}, \\mathbf{r}') = \\frac{\\mathrm{i}}{4} H_0^{(1)}\\!\\big(k \\, \\lvert \\mathbf{r} - \\mathbf{r}' \\rvert \\big),\n$$\nwhere $H_\\nu^{(1)}$ is the Hankel function of the first kind and order $\\nu$, and $\\mathrm{i}$ denotes the imaginary unit. The Huygens equivalence principle expresses the field in the exterior of a closed contour $\\Gamma$ in terms of equivalent electric and magnetic source distributions on $\\Gamma$, which in the TM scalar setting reduce to a boundary integral representation involving the field and its normal derivative on $\\Gamma$.\n\nLet $\\Gamma$ be the circle of radius $a$ centered at the origin, parameterized by the angle $\\phi \\in [0, 2\\pi)$, with outward unit normal $\\hat{\\mathbf{n}}'(\\phi)$ pointing radially outward (into the exterior domain). Consider a point source located at the origin generating the exact field\n$$\nu(\\mathbf{r}) = \\frac{\\mathrm{i}}{4} H_0^{(1)}\\!\\big(k \\, r\\big),\n$$\nwhere $r = \\lvert \\mathbf{r} \\rvert$. On the boundary $\\Gamma$, the field and its outward normal derivative are\n$$\nu(a) = \\frac{\\mathrm{i}}{4} H_0^{(1)}\\!\\big(k \\, a\\big), \\quad \\frac{\\partial u}{\\partial n}\\bigg|_{r=a} = \\frac{\\mathrm{i}}{4} \\left(-k\\right) H_1^{(1)}\\!\\big(k \\, a\\big).\n$$\nThe scalar Huygens boundary integral representation for the exterior field at an observation point $\\mathbf{r}$ outside $\\Gamma$ is\n$$\nu(\\mathbf{r}) = \\int_{\\Gamma} \\left[ G(\\mathbf{r}, \\mathbf{r}') \\, \\frac{\\partial u(\\mathbf{r}')}{\\partial n'} - u(\\mathbf{r}') \\, \\frac{\\partial G(\\mathbf{r}, \\mathbf{r}')}{\\partial n'} \\right] \\, \\mathrm{d}s',\n$$\nwith $\\mathrm{d}s'$ the line element on $\\Gamma$, $\\hat{\\mathbf{n}}'$ the outward normal on $\\Gamma$, and\n$$\n\\frac{\\partial G(\\mathbf{r}, \\mathbf{r}')}{\\partial n'} = \\nabla' G(\\mathbf{r}, \\mathbf{r}') \\cdot \\hat{\\mathbf{n}}' = \\frac{\\mathrm{i} k}{4} H_1^{(1)}\\!\\big(k \\, R\\big) \\, \\left(\\hat{\\mathbf{n}}' \\cdot \\hat{\\mathbf{R}}\\right),\n$$\nwhere $R = \\lvert \\mathbf{r} - \\mathbf{r}' \\rvert$ and $\\hat{\\mathbf{R}} = (\\mathbf{r} - \\mathbf{r}')/R$. This representation embodies the equivalence principle: the exterior field is reproduced by equivalent sources on $\\Gamma$ that encode $u$ and its normal derivative.\n\nTask: Derive, implement, and test a numerical discretization of the Huygens surface integral on $\\Gamma$ using a uniform angular partition of $N$ panels and the midpoint rule. Specifically, parameterize $\\Gamma$ by $\\phi_m = \\left(m + \\frac{1}{2}\\right) \\Delta \\phi$ for $m \\in \\{0, 1, \\dots, N-1\\}$ with $\\Delta \\phi = \\frac{2\\pi}{N}$, source points $\\mathbf{r}'(\\phi_m) = a \\, [\\cos\\phi_m, \\sin\\phi_m]$, outward normals $\\hat{\\mathbf{n}}'(\\phi_m) = [\\cos\\phi_m, \\sin\\phi_m]$, and weights $w = a \\, \\Delta \\phi$. For an observation point specified in polar coordinates $(r_o, \\theta_o)$, compute the numerical approximation\n$$\nu_{\\mathrm{num}}(\\mathbf{r}_o) \\approx \\sum_{m=0}^{N-1} \\left[ G\\big(\\mathbf{r}_o, \\mathbf{r}'(\\phi_m)\\big) \\, \\frac{\\partial u}{\\partial n}\\bigg|_{r=a} - u(a) \\, \\frac{\\partial G\\big(\\mathbf{r}_o, \\mathbf{r}'(\\phi_m)\\big)}{\\partial n'} \\right] \\, w,\n$$\nand compare it to the exact field\n$$\nu_{\\mathrm{exact}}(\\mathbf{r}_o) = \\frac{\\mathrm{i}}{4} H_0^{(1)}\\!\\big(k \\, r_o\\big).\n$$\nCompute the relative error\n$$\n\\varepsilon = \\frac{\\lvert u_{\\mathrm{num}}(\\mathbf{r}_o) - u_{\\mathrm{exact}}(\\mathbf{r}_o) \\rvert}{\\lvert u_{\\mathrm{exact}}(\\mathbf{r}_o) \\rvert}.\n$$\n\nUse the following test suite, with all distances in meters and angles in radians, and the wavenumber $k$ in radians per meter:\n- Test case $1$ (happy path): $k = 20$, $a = 0.5$, $N = 200$, $r_o = 1.2$, $\\theta_o = 0.7$.\n- Test case $2$ (coarse discretization boundary case): $k = 20$, $a = 0.5$, $N = 16$, $r_o = 1.2$, $\\theta_o = 0.7$.\n- Test case $3$ (near-boundary edge case): $k = 20$, $a = 0.5$, $N = 400$, $r_o = 0.55$, $\\theta_o = 1.3$.\n- Test case $4$ (far-field case): $k = 20$, $a = 0.5$, $N = 200$, $r_o = 3.0$, $\\theta_o = 2.1$.\n\nYour program must compute the relative error $\\varepsilon$ for each test case and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places (e.g., $[0.001234,0.056789,0.000001,0.012345]$). Angles must be interpreted in radians, and the wavenumber must be in radians per meter. The output is dimensionless. No input should be read; all parameters are hard-coded according to the test suite above.",
            "solution": "The problem requires the numerical verification of the Huygens’ equivalence principle for a two-dimensional time-harmonic scalar field in free space. The field is generated by a line source at the origin, and its value in the exterior of a circular boundary is to be computed using a boundary integral representation. This numerical result will be compared against the known analytical solution to quantify the accuracy of the midpoint rule discretization.\n\nThe scalar field $u(\\mathbf{r})$ satisfies the homogeneous Helmholtz equation, $(\\nabla^2 + k^2) u(\\mathbf{r}) = 0$, for an implicit time-dependence of $e^{-\\mathrm{i}\\omega t}$, where $k$ is the free-space wavenumber. The exact field produced by a line source at the origin is given by the free-space Green's function centered at the origin:\n$$\nu_{\\mathrm{exact}}(\\mathbf{r}) = \\frac{\\mathrm{i}}{4} H_0^{(1)}\\!\\big(k \\, r\\big)\n$$\nwhere $r = \\lvert \\mathbf{r} \\rvert$, $H_0^{(1)}$ is the Hankel function of the first kind and zeroth order, and $\\mathrm{i}$ is the imaginary unit.\n\nAccording to the Huygens' principle, the field $u(\\mathbf{r})$ at any observation point $\\mathbf{r}$ in the domain exterior to a closed contour $\\Gamma$ can be reconstructed from the values of the field and its normal derivative on $\\Gamma$. For the two-dimensional scalar problem, this is expressed by the boundary integral equation:\n$$\nu(\\mathbf{r}) = \\int_{\\Gamma} \\left[ G(\\mathbf{r}, \\mathbf{r}') \\, \\frac{\\partial u(\\mathbf{r}')}{\\partial n'} - u(\\mathbf{r}') \\, \\frac{\\partial G(\\mathbf{r}, \\mathbf{r}')}{\\partial n'} \\right] \\, \\mathrm{d}s'\n$$\nHere, $\\mathbf{r}'$ is a point on the contour $\\Gamma$, $\\mathrm{d}s'$ is the differential arc length element, and $\\hat{\\mathbf{n}}'$ is the outward-pointing unit normal vector on $\\Gamma$. The kernel $G(\\mathbf{r}, \\mathbf{r}')$ is the free-space Green's function:\n$$\nG(\\mathbf{r}, \\mathbf{r}') = \\frac{\\mathrm{i}}{4} H_0^{(1)}\\!\\big(k \\, \\lvert \\mathbf{r} - \\mathbf{r}' \\rvert \\big)\n$$\nThe gradient of $G$ with respect to the source coordinates $\\mathbf{r}'$ is $\\nabla' G(\\mathbf{r}, \\mathbf{r}') = \\frac{\\mathrm{d}G}{\\mathrm{d}R} \\nabla' R$. With $R=\\lvert \\mathbf{r}-\\mathbf{r}' \\rvert$, we have $\\nabla' R = \\frac{\\mathbf{r}' - \\mathbf{r}}{R}$. The derivative of the Green's function with respect to its argument $z=kR$ is $\\frac{\\mathrm{d}}{\\mathrm{d}z} \\left(\\frac{\\mathrm{i}}{4} H_0^{(1)}(z)\\right) = \\frac{-\\mathrm{i}k}{4}H_1^{(1)}(z)$. Therefore,\n$$\n\\nabla' G(\\mathbf{r}, \\mathbf{r}') = \\frac{-\\mathrm{i}k}{4} H_1^{(1)}(kR)\\frac{\\mathbf{r}' - \\mathbf{r}}{R}\n$$\nThe normal derivative of the Green's function is thus\n$$\n\\frac{\\partial G(\\mathbf{r}, \\mathbf{r}')}{\\partial n'} = \\nabla' G(\\mathbf{r}, \\mathbf{r}') \\cdot \\hat{\\mathbf{n}}' = \\frac{-\\mathrm{i}k}{4} H_1^{(1)}(kR)\\frac{(\\mathbf{r}' - \\mathbf{r})\\cdot\\hat{\\mathbf{n}}'}{R} = \\frac{\\mathrm{i}k}{4} H_1^{(1)}(kR)\\frac{(\\mathbf{r} - \\mathbf{r}')\\cdot\\hat{\\mathbf{n}}'}{R}\n$$\nThis expression matches the formula provided in the problem statement, where $\\hat{\\mathbf{R}} = (\\mathbf{r} - \\mathbf{r}')/R$.\n\nFor this problem, $\\Gamma$ is a circle of radius $a$ centered at the origin. The boundary data required by the integral equation are derived from the known analytical solution:\n$$\nu(\\mathbf{r}')\\big|_{r'=a} = u(a) = \\frac{\\mathrm{i}}{4} H_0^{(1)}\\!\\big(k \\, a\\big)\n$$\n$$\n\\frac{\\partial u(\\mathbf{r}')}{\\partial n'}\\bigg|_{r'=a} = \\frac{\\partial u}{\\partial r'}\\bigg|_{r'=a} = \\frac{\\mathrm{d}}{\\mathrm{d}r'} \\left[ \\frac{\\mathrm{i}}{4} H_0^{(1)}\\!\\big(k \\, r'\\big) \\right]_{r'=a} = \\frac{-\\mathrm{i} k}{4} H_1^{(1)}\\!\\big(k \\, a\\big)\n$$\n\nThe task is to approximate the boundary integral using the midpoint rule. We partition the circular contour $\\Gamma$ into $N$ uniform panels. The midpoint of the $m$-th panel is located at an angle $\\phi_m = (m + \\frac{1}{2})\\Delta\\phi$ for $m \\in \\{0, 1, \\dots, N-1\\}$, where $\\Delta\\phi = 2\\pi/N$. The coordinates of the source point are $\\mathbf{r}'_m = (a\\cos\\phi_m, a\\sin\\phi_m)$. The panel length is $w = a\\Delta\\phi$.\n\nThe numerical approximation of the integral becomes the sum:\n$$\nu_{\\mathrm{num}}(\\mathbf{r}_o) = \\sum_{m=0}^{N-1} \\left[ G(\\mathbf{r}_o, \\mathbf{r}'_m) \\left(\\frac{-\\mathrm{i} k}{4} H_1^{(1)}\\!\\big(k \\, a\\big)\\right) - \\left(\\frac{\\mathrm{i}}{4} H_0^{(1)}\\!\\big(k \\, a\\big)\\right) \\frac{\\partial G(\\mathbf{r}_o, \\mathbf{r}'_m)}{\\partial n'_m} \\right] w\n$$\nwhere $\\mathbf{r}_o$ is the observation point given in polar coordinates $(r_o, \\theta_o)$.\n\nFor the implementation, we evaluate the geometric terms for each panel $m$. The distance $R_m = \\lvert \\mathbf{r}_o - \\mathbf{r}'_m \\rvert$ is calculated using the law of cosines:\n$$\nR_m = \\sqrt{r_o^2 + a^2 - 2ar_o\\cos(\\theta_o - \\phi_m)}\n$$\nThe outward normal at $\\mathbf{r}'_m$ is $\\hat{\\mathbf{n}}'_m = (\\cos\\phi_m, \\sin\\phi_m)$. The dot product required for the Green's function derivative is $\\hat{\\mathbf{n}}'_m \\cdot \\hat{\\mathbf{R}}_m = (\\hat{\\mathbf{n}}'_m \\cdot (\\mathbf{r}_o - \\mathbf{r}'_m)) / R_m$. The numerator is:\n$$\n\\hat{\\mathbf{n}}'_m \\cdot (\\mathbf{r}_o - \\mathbf{r}'_m) = \\hat{\\mathbf{n}}'_m \\cdot \\mathbf{r}_o - \\hat{\\mathbf{n}}'_m \\cdot \\mathbf{r}'_m = r_o \\cos(\\theta_o - \\phi_m) - a\n$$\nThis gives the term needed for the normal derivative of the Green's function. By substituting these expressions into the summation, we calculate $u_{\\mathrm{num}}(\\mathbf{r}_o)$.\n\nThe final step is to compute the relative error $\\varepsilon$ by comparing the numerical result against the exact analytical solution at the observation point, $u_{\\mathrm{exact}}(\\mathbf{r}_o) = \\frac{\\mathrm{i}}{4} H_0^{(1)}\\!\\big(k \\, r_o\\big)$:\n$$\n\\varepsilon = \\frac{\\lvert u_{\\mathrm{num}}(\\mathbf{r}_o) - u_{\\mathrm{exact}}(\\mathbf{r}_o) \\rvert}{\\lvert u_{\\mathrm{exact}}(\\mathbf{r}_o) \\rvert}\n$$\nThe provided Python code implements this algorithm for each test case. It uses vectorized computations with `NumPy` for efficiency and `SciPy` for the required Hankel functions, $H_0^{(1)}$ and $H_1^{(1)}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special as sp\n\ndef compute_error(k, a, N, r_o, theta_o):\n    \"\"\"\n    Computes the relative error of the numerical Huygens integral\n    approximation for a given set of parameters.\n\n    Args:\n        k (float): Wavenumber in radians/meter.\n        a (float): Radius of the circular contour in meters.\n        N (int): Number of panels for numerical integration.\n        r_o (float): Radial coordinate of the observation point in meters.\n        theta_o (float): Angular coordinate of the observation point in radians.\n\n    Returns:\n        float: The computed relative error.\n    \"\"\"\n    # Numerical constants and discretization parameters\n    i_unit = 1j\n    delta_phi = 2.0 * np.pi / N\n    # Midpoint rule weight (panel arc length)\n    w = a * delta_phi\n\n    # Midpoint angles for all N panels (vectorized)\n    m = np.arange(N)\n    phi_m = (m + 0.5) * delta_phi\n\n    # Observation point in Cartesian coordinates\n    xo = r_o * np.cos(theta_o)\n    yo = r_o * np.sin(theta_o)\n\n    # Source points on the contour in Cartesian coordinates (vectorized)\n    xp_m = a * np.cos(phi_m)\n    yp_m = a * np.sin(phi_m)\n\n    # Distances R_m from each source point to the observation point (vectorized)\n    # Using law of cosines for robustness and simplicity\n    R_m = np.sqrt(r_o**2 + a**2 - 2 * a * r_o * np.cos(theta_o - phi_m))\n\n    # --- Pre-calculate boundary data on the contour r=a ---\n    # Field u(a) on the boundary\n    u_on_a = (i_unit / 4.0) * sp.hankel1(0, k * a)\n    # Normal derivative ∂u/∂n on the boundary\n    du_dn_on_a = (-i_unit * k / 4.0) * sp.hankel1(1, k * a)\n\n    # --- Evaluate kernels of the integral equation (vectorized) ---\n    # Green's function G(r_o, r'_m)\n    G_m = (i_unit / 4.0) * sp.hankel1(0, k * R_m)\n\n    # Dot product (n' · R_hat) for the normal derivative of the Green's function\n    ndotRhat_m = (r_o * np.cos(theta_o - phi_m) - a) / R_m\n    \n    # Normal derivative of Green's function ∂G(r_o, r'_m)/∂n'\n    dGdn_m = (i_unit * k / 4.0) * sp.hankel1(1, k * R_m) * ndotRhat_m\n\n    # --- Compute the numerical integral using the midpoint rule ---\n    # Evaluate the integrand for each panel (vectorized)\n    integrand = G_m * du_dn_on_a - u_on_a * dGdn_m\n    \n    # Sum over all panels and multiply by the panel weight\n    u_num = np.sum(integrand) * w\n\n    # --- Compute the exact solution ---\n    u_exact = (i_unit / 4.0) * sp.hankel1(0, k * r_o)\n\n    # --- Compute the relative error ---\n    relative_error = np.abs(u_num - u_exact) / np.abs(u_exact)\n    \n    return relative_error\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (k, a, N, r_o, theta_o)\n    test_cases = [\n        (20.0, 0.5, 200, 1.2, 0.7),\n        (20.0, 0.5, 16, 1.2, 0.7),\n        (20.0, 0.5, 400, 0.55, 1.3),\n        (20.0, 0.5, 200, 3.0, 2.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        k, a, N, r_o, theta_o = case\n        error = compute_error(k, a, N, r_o, theta_o)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    # Each value is formatted to six decimal places.\n    print(f\"[{','.join([f'{err:.6f}' for err in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many modern electromagnetic devices, from antennas to metasurfaces, feature periodic geometries. This practice extends the equivalence principle to these important systems by formulating it within a single periodic unit cell using Floquet-Bloch theory . Your task is to analyze the field's spectral content in terms of Floquet modes and quantify a critical numerical artifact—aliasing—that occurs when these modes are sampled on a discrete grid, a key consideration for accurate modeling of periodic structures.",
            "id": "3314918",
            "problem": "Consider a planar Huygens surface placed at $z=0$ that closes a periodic unit cell of dimensions $L_x$ by $L_y$ with outward unit normal $\\hat{\\mathbf{n}}=\\hat{\\mathbf{z}}$. In computational electromagnetics, the equivalence principle replaces the fields outside the surface by equivalent electric and magnetic surface current densities that reproduce the original fields in the exterior. Let the tangential electric field be $\\mathbf{E}_{t}(x,y)$ and the tangential magnetic field be $\\mathbf{H}_{t}(x,y)$ on the Huygens surface. The equivalent electric and magnetic surface current densities are defined by the fundamental boundary relations\n$$\\mathbf{J}_{s}(x,y)=\\hat{\\mathbf{n}}\\times \\mathbf{H}_{t}(x,y),\\qquad \\mathbf{M}_{s}(x,y)=-\\hat{\\mathbf{n}}\\times \\mathbf{E}_{t}(x,y).$$\nAssume the fields satisfy periodic boundary conditions with Bloch–Floquet quasi-periodicity specified by transverse Bloch wavenumbers $k_{x0}$ and $k_{y0}$:\n$$\\mathbf{E}_{t}(x+L_x,y)=\\mathbf{E}_{t}(x,y)e^{\\mathrm{i} k_{x0} L_x},\\quad \\mathbf{E}_{t}(x,y+L_y)=\\mathbf{E}_{t}(x,y)e^{\\mathrm{i} k_{y0} L_y},$$\nand similarly for $\\mathbf{H}_{t}(x,y)$. It is convenient to factor out the Bloch phase and write the fields as\n$$\\mathbf{E}_{t}(x,y)=\\mathbf{E}_{0}\\,F(x,y)\\,e^{\\mathrm{i}(k_{x0}x+k_{y0}y)},\\qquad \\mathbf{H}_{t}(x,y)=\\mathbf{H}_{0}\\,G(x,y)\\,e^{\\mathrm{i}(k_{x0}x+k_{y0}y)},$$\nwhere $\\mathbf{E}_{0}=\\left(E_0\\cos\\psi, E_0\\sin\\psi, 0\\right)$ and $\\mathbf{H}_{0}=\\left(H_0\\cos\\phi, H_0\\sin\\phi, 0\\right)$ are constant tangential polarization vectors (angles expressed in radians), and $F(x,y)$ and $G(x,y)$ are $L_x$ by $L_y$ periodic scalar functions expanded in a double Floquet series\n$$F(x,y)=\\sum_{m\\in\\mathbb{Z}}\\sum_{n\\in\\mathbb{Z}}A_{m,n}\\,e^{\\mathrm{i}2\\pi\\left(\\frac{m x}{L_x}+\\frac{n y}{L_y}\\right)},\\qquad G(x,y)=\\sum_{m\\in\\mathbb{Z}}\\sum_{n\\in\\mathbb{Z}}B_{m,n}\\,e^{\\mathrm{i}2\\pi\\left(\\frac{m x}{L_x}+\\frac{n y}{L_y}\\right)}.$$\nConsequently, the dephased equivalent currents $\\tilde{\\mathbf{J}}_{s}(x,y)=\\mathbf{J}_{s}(x,y)e^{-\\mathrm{i}(k_{x0}x+k_{y0}y)}$ and $\\tilde{\\mathbf{M}}_{s}(x,y)=\\mathbf{M}_{s}(x,y)e^{-\\mathrm{i}(k_{x0}x+k_{y0}y)}$ have Floquet expansions indexed by $(m,n)$ with coefficients proportional to $A_{m,n}$ and $B_{m,n}$ respectively.\n\nIn practice, one numerically samples $\\tilde{\\mathbf{J}}_{s}(x,y)$ and $\\tilde{\\mathbf{M}}_{s}(x,y)$ on a uniform discrete grid of $N_x$ by $N_y$ points:\n$$x_p=\\frac{p L_x}{N_x},\\quad y_q=\\frac{q L_y}{N_y},\\quad p=0,\\dots,N_x-1,\\quad q=0,\\dots,N_y-1,$$\nand estimates modal coefficients by a two-dimensional Discrete Fourier Transform (DFT). The central Brillouin zone induced by sampling is defined by the index set\n$$\\mathcal{B}=\\left\\{(m,n): m\\in[-\\lfloor N_x/2\\rfloor,\\ldots,\\lfloor N_x/2\\rfloor-1],\\; n\\in[-\\lfloor N_y/2\\rfloor,\\ldots,\\lfloor N_y/2\\rfloor-1]\\right\\}.$$\nWhen the true Floquet content $(m,n)$ of $F$ and $G$ lies outside $\\mathcal{B}$, discrete sampling aliases those modes back into $\\mathcal{B}$ via residue classes modulo $N_x$ and $N_y$. Define the alias mapping $\\alpha(m;N_x)=((m+\\lfloor N_x/2\\rfloor)\\bmod N_x)-\\lfloor N_x/2\\rfloor$ and similarly for $n$.\n\nFor a fixed set of modal amplitudes $\\{A_{m,n}\\}$ and $\\{B_{m,n}\\}$, define the combined energy per mode by\n$$\\mathcal{E}_{m,n}=(E_0^2+H_0^2)\\left(|A_{m,n}|^2+|B_{m,n}|^2\\right),$$\nand define the true energy inside $\\mathcal{B}$ by\n$$\\mathcal{E}_{\\mathrm{true}}=\\sum_{(m,n)\\in \\mathcal{B}} \\mathcal{E}_{m,n},$$\nand the aliased energy inside $\\mathcal{B}$ by\n$$\\mathcal{E}_{\\mathrm{alias}}=\\sum_{(m,n)\\notin \\mathcal{B}} \\mathcal{E}_{m,n},$$\nwhich counts all energy that will be folded into the sampled central Brillouin zone. Quantify aliasing under discrete sampling by the aliased fraction\n$$\\eta=\\frac{\\mathcal{E}_{\\mathrm{alias}}}{\\mathcal{E}_{\\mathrm{true}}+\\mathcal{E}_{\\mathrm{alias}}},$$\nwith the convention that if both $\\mathcal{E}_{\\mathrm{true}}=0$ and $\\mathcal{E}_{\\mathrm{alias}}=0$ then $\\eta=0$.\n\nYour task is to write a complete, runnable program that for each of the following test cases:\n- constructs the dephased equivalent currents $\\tilde{\\mathbf{J}}_{s}(x,y)$ and $\\tilde{\\mathbf{M}}_{s}(x,y)$,\n- performs the DFT to recover sampled modal content (this is to internally verify the mapping, but it is not part of the final numerical output), and\n- computes the aliased fraction $\\eta$ using the energy definitions above.\n\nAll physical lengths $L_x$ and $L_y$ must be treated in meters, Bloch wavenumbers $k_{x0}$ and $k_{y0}$ in radians per meter, and angles $\\phi$ and $\\psi$ in radians. The final outputs $\\eta$ are dimensionless floats.\n\nTest suite:\n- Case $1$ (happy path; negligible aliasing expected):\n  - $L_x=0.2\\,\\mathrm{m}$, $L_y=0.2\\,\\mathrm{m}$,\n  - $N_x=32$, $N_y=32$,\n  - $k_{x0}=0.2\\times \\frac{2\\pi}{L_x}$, $k_{y0}=-0.3\\times \\frac{2\\pi}{L_y}$,\n  - $E_0=1.0$, $H_0=1.0$, $\\phi=0.7$ (radians), $\\psi=1.2$ (radians),\n  - Modal amplitudes (applied equally to $F$ and $G$, i.e., take $A_{m,n}=B_{m,n}$):\n    - $(m,n)=(0,0)$ with $|A_{0,0}|=1.0$,\n    - $(m,n)=(5,0)$ with $|A_{5,0}|=0.6$,\n    - $(m,n)=(-7,2)$ with $|A_{-7,2}|=0.4$,\n    - $(m,n)=(3,-6)$ with $|A_{3,-6}|=0.5$,\n    - $(m,n)=(9,9)$ with $|A_{9,9}|=0.3$.\n- Case $2$ (moderate aliasing; some content outside $\\mathcal{B}$):\n  - $L_x=0.2\\,\\mathrm{m}$, $L_y=0.2\\,\\mathrm{m}$,\n  - $N_x=8$, $N_y=8$,\n  - $k_{x0}=0.4\\times \\frac{2\\pi}{L_x}$, $k_{y0}=0.1\\times \\frac{2\\pi}{L_y}$,\n  - $E_0=2.0$, $H_0=1.5$, $\\phi=0.9$ (radians), $\\psi=0.3$ (radians),\n  - Modal amplitudes identical to Case $1$ (applied equally to $F$ and $G$).\n- Case $3$ (edge case; all content outside $\\mathcal{B}$):\n  - $L_x=0.2\\,\\mathrm{m}$, $L_y=0.2\\,\\mathrm{m}$,\n  - $N_x=6$, $N_y=6$,\n  - $k_{x0}=0.95\\times \\frac{\\pi}{L_x}$, $k_{y0}=0.95\\times \\frac{\\pi}{L_y}$,\n  - $E_0=1.0$, $H_0=1.0$, $\\phi=0.5$ (radians), $\\psi=1.1$ (radians),\n  - Modal amplitudes (applied equally to $F$ and $G$):\n    - $(m,n)=(5,5)$ with $|A_{5,5}|=1.0$,\n    - $(m,n)=(-4,4)$ with $|A_{-4,4}|=0.7$.\n\nImplementation details:\n- Use the sample grid $(x_p,y_q)$ and compute $F(x_p,y_q)$ and $G(x_p,y_q)$ from the specified modal amplitudes, then produce $\\mathbf{E}_{t}(x_p,y_q)$ and $\\mathbf{H}_{t}(x_p,y_q)$ and the dephased currents $\\tilde{\\mathbf{J}}_{s}(x_p,y_q)$ and $\\tilde{\\mathbf{M}}_{s}(x_p,y_q)$.\n- Compute the two-dimensional Fast Fourier Transform (FFT) of each dephased current component to verify the modal indexing and the alias mapping (no numerical values from the FFT need to be output; this is a verification step).\n- Compute $\\eta$ using the definitions of $\\mathcal{E}_{\\mathrm{true}}$ and $\\mathcal{E}_{\\mathrm{alias}}$ (note that $A_{m,n}$ and $B_{m,n}$ are identical in each case, so the combined energy simplifies accordingly).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3]$, where $r_i$ are the computed values of $\\eta$ for Cases $1$, $2$, and $3$ respectively.\n\nAll outputs $\\eta$ must be floats. Angles are in radians. If no energy is present in the sampled central Brillouin zone and no energy aliases into it, output $0.0$ for that case.",
            "solution": "The derivation begins from Maxwell's equations and the electromagnetic boundary conditions. On a closed surface with outward unit normal $\\hat{\\mathbf{n}}$, the equivalence principle prescribes the equivalent electric and magnetic surface currents required to reproduce the fields outside the surface: $\\mathbf{J}_{s}=\\hat{\\mathbf{n}}\\times \\mathbf{H}$ and $\\mathbf{M}_{s}=-\\hat{\\mathbf{n}}\\times \\mathbf{E}$. For a planar Huygens surface at $z=0$, the normal is $\\hat{\\mathbf{n}}=\\hat{\\mathbf{z}}$, so explicitly\n$$\\mathbf{J}_{s}(x,y)=\\hat{\\mathbf{z}}\\times \\mathbf{H}_{t}(x,y)=\\left(-H_{y}(x,y),\\,H_{x}(x,y),\\,0\\right),$$\n$$\\mathbf{M}_{s}(x,y)=-\\hat{\\mathbf{z}}\\times \\mathbf{E}_{t}(x,y)=\\left(E_{y}(x,y),\\,-E_{x}(x,y),\\,0\\right).$$\nUnder periodic boundary conditions with Bloch–Floquet quasi-periodicity, the tangential fields can be factored into a Bloch phase and a periodic part. Introduce constant tangential polarization vectors $\\mathbf{E}_{0}=\\left(E_0\\cos\\psi,E_0\\sin\\psi,0\\right)$ and $\\mathbf{H}_{0}=\\left(H_0\\cos\\phi,H_0\\sin\\phi,0\\right)$, with angles $\\psi$ and $\\phi$ in radians, and periodic scalar functions $F(x,y)$ and $G(x,y)$ that admit Fourier–Floquet expansions on the reciprocal lattice:\n$$F(x,y)=\\sum_{m\\in\\mathbb{Z}}\\sum_{n\\in\\mathbb{Z}}A_{m,n}e^{\\mathrm{i}2\\pi\\left(\\frac{m x}{L_x}+\\frac{n y}{L_y}\\right)},\\qquad G(x,y)=\\sum_{m\\in\\mathbb{Z}}\\sum_{n\\in\\mathbb{Z}}B_{m,n}e^{\\mathrm{i}2\\pi\\left(\\frac{m x}{L_x}+\\frac{n y}{L_y}\\right)}.$$\nWith Bloch wavenumbers $k_{x0}$ and $k_{y0}$, the tangential fields are\n$$\\mathbf{E}_{t}(x,y)=\\mathbf{E}_{0}\\,F(x,y)\\,e^{\\mathrm{i}(k_{x0}x+k_{y0}y)},\\qquad \\mathbf{H}_{t}(x,y)=\\mathbf{H}_{0}\\,G(x,y)\\,e^{\\mathrm{i}(k_{x0}x+k_{y0}y)}.$$\nIntroduce the dephased currents $\\tilde{\\mathbf{J}}_{s}(x,y)=\\mathbf{J}_{s}(x,y)e^{-\\mathrm{i}(k_{x0}x+k_{y0}y)}$ and $\\tilde{\\mathbf{M}}_{s}(x,y)=\\mathbf{M}_{s}(x,y)e^{-\\mathrm{i}(k_{x0}x+k_{y0}y)}$. Substituting the field representations and using linearity yields\n$$\\tilde{\\mathbf{J}}_{s}(x,y)=\\hat{\\mathbf{z}}\\times \\left(\\mathbf{H}_{0}\\,G(x,y)\\right)=\\left(-H_{0}\\sin\\phi,\\,H_{0}\\cos\\phi,\\,0\\right)G(x,y),$$\n$$\\tilde{\\mathbf{M}}_{s}(x,y)=-\\hat{\\mathbf{z}}\\times \\left(\\mathbf{E}_{0}\\,F(x,y)\\right)=\\left(E_{0}\\sin\\psi,\\,-E_{0}\\cos\\psi,\\,0\\right)F(x,y).$$\nTherefore, the Floquet content of the dephased equivalent currents is exactly that of $F$ and $G$, with vector-valued coefficients proportional to $A_{m,n}$ and $B_{m,n}$. For each mode $(m,n)$, the combined squared magnitude of the vector-valued coefficients is proportional to $(E_0^2+H_0^2)\\left(|A_{m,n}|^2+|B_{m,n}|^2\\right)$ because $\\left\\| \\left(-H_{0}\\sin\\phi,H_{0}\\cos\\phi,0\\right)\\right\\|^2=H_0^2$ and $\\left\\| \\left(E_{0}\\sin\\psi,-E_{0}\\cos\\psi,0\\right)\\right\\|^2=E_0^2$.\n\nTo estimate modal coefficients numerically, sample the dephased currents on the $N_x$ by $N_y$ grid points $x_p=pL_x/N_x$, $y_q=qL_y/N_y$ for $p=0,\\dots,N_x-1$, $q=0,\\dots,N_y-1$. A two-dimensional Discrete Fourier Transform (DFT), implemented as a Fast Fourier Transform (FFT), maps the samples to discrete spectral bins indexed by integers $k_x\\in\\{0,\\dots,N_x-1\\}$ and $k_y\\in\\{0,\\dots,N_y-1\\}$. To center the spectrum on the principal Brillouin zone, apply the standard frequency shift to obtain indices in $\\left[-\\lfloor N_x/2\\rfloor,\\dots,\\lfloor N_x/2\\rfloor-1\\right]$ and similarly for $n$. The central Brillouin zone $\\mathcal{B}$ induced by sampling is therefore\n$$\\mathcal{B}=\\left\\{(m,n): m\\in[-\\lfloor N_x/2\\rfloor,\\ldots,\\lfloor N_x/2\\rfloor-1],\\; n\\in[-\\lfloor N_y/2\\rfloor,\\ldots,\\lfloor N_y/2\\rfloor-1]\\right\\}.$$\nAny true Floquet index $(m,n)$ outside $\\mathcal{B}$ aliases into $\\mathcal{B}$ via the residue classes modulo $N_x$ and $N_y$. The centering alias map is\n$$\\alpha(m;N_x)=\\left((m+\\lfloor N_x/2\\rfloor)\\bmod N_x\\right)-\\lfloor N_x/2\\rfloor,\\qquad \\alpha(n;N_y)=\\left((n+\\lfloor N_y/2\\rfloor)\\bmod N_y\\right)-\\lfloor N_y/2\\rfloor.$$\nAccordingly, if $(m,n)\\notin \\mathcal{B}$ then the sampled spectrum contains that energy at bin $(\\alpha(m;N_x),\\alpha(n;N_y))$ in the centered discrete spectrum. Because the dephased equivalent currents factor the vector direction and the scalar periodic functions, the combined energy per mode is\n$$\\mathcal{E}_{m,n}=(E_0^2+H_0^2)\\left(|A_{m,n}|^2+|B_{m,n}|^2\\right),$$\nwhich is independent of the polarization angles $\\phi$ and $\\psi$. The true energy inside the sampled central Brillouin zone is\n$$\\mathcal{E}_{\\mathrm{true}}=\\sum_{(m,n)\\in \\mathcal{B}}\\mathcal{E}_{m,n},$$\nand the aliased energy that folds into $\\mathcal{B}$ from outside is\n$$\\mathcal{E}_{\\mathrm{alias}}=\\sum_{(m,n)\\notin \\mathcal{B}}\\mathcal{E}_{m,n}.$$\nA robust scalar quantifier of aliasing is the aliased fraction\n$$\\eta=\\frac{\\mathcal{E}_{\\mathrm{alias}}}{\\mathcal{E}_{\\mathrm{true}}+\\mathcal{E}_{\\mathrm{alias}}},$$\nwhich lies in $[0,1]$ and equals $0$ when all modal energy is within $\\mathcal{B}$ and equals $1$ when all modal energy lies outside $\\mathcal{B}$ and aliases completely.\n\nAlgorithmic procedure:\n- For each test case, compute the modal energy $\\mathcal{E}_{m,n}$ for each specified $(m,n)$ pair with given amplitudes $A_{m,n}$ and $B_{m,n}$ and given $E_0$ and $H_0$, assuming $A_{m,n}=B_{m,n}$ as specified. Accumulate $\\mathcal{E}_{\\mathrm{true}}$ over $(m,n)\\in\\mathcal{B}$ and $\\mathcal{E}_{\\mathrm{alias}}$ over $(m,n)\\notin\\mathcal{B}$.\n- Compute the aliased fraction $\\eta=\\mathcal{E}_{\\mathrm{alias}}/(\\mathcal{E}_{\\mathrm{true}}+\\mathcal{E}_{\\mathrm{alias}})$, with the special case $\\eta=0$ if both $\\mathcal{E}_{\\mathrm{true}}=0$ and $\\mathcal{E}_{\\mathrm{alias}}=0$.\n- As an internal verification step, construct $F(x_p,y_q)$ and $G(x_p,y_q)$ from the modal sums, form $\\mathbf{E}_{t}(x_p,y_q)$ and $\\mathbf{H}_{t}(x_p,y_q)$, and then the dephased currents $\\tilde{\\mathbf{J}}_{s}(x_p,y_q)$ and $\\tilde{\\mathbf{M}}_{s}(x_p,y_q)$. Apply a two-dimensional FFT and frequency shift to observe that the discrete spectral energy is concentrated at bins corresponding to $(\\alpha(m;N_x),\\alpha(n;N_y))$, confirming the alias mapping. This verification does not affect the computed $\\eta$ and is not part of the program’s printed output.\n\nFor the provided test suite:\n- Case $1$ has $(N_x,N_y)=(32,32)$, so $\\mathcal{B}$ contains all listed $(m,n)$, making $\\mathcal{E}_{\\mathrm{alias}}=0$ and $\\eta=0$.\n- Case $2$ has $(N_x,N_y)=(8,8)$, so several $(m,n)$ lie outside $\\mathcal{B}$ and contribute to $\\mathcal{E}_{\\mathrm{alias}}$, producing $0<\\eta<1$.\n- Case $3$ has $(N_x,N_y)=(6,6)$, and all listed $(m,n)$ lie outside $\\mathcal{B}$; therefore $\\mathcal{E}_{\\mathrm{true}}=0$ and $\\eta=1$ by the given definition (unless degenerate amplitudes are zero).\n\nThe final program implements these steps, computes $\\eta$ for each case, and prints a single line in the exact required format $[\\eta_1,\\eta_2,\\eta_3]$, where each $\\eta_i$ is a float.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef center_index(k: int, N: int) -> int:\n    \"\"\"Map integer k to centered index in [-N//2, ..., N//2-1].\"\"\"\n    return ((k + (N // 2)) % N) - (N // 2)\n\ndef in_central_zone(m: int, N: int) -> bool:\n    \"\"\"Check if integer m lies in the central Brillouin zone for size N.\"\"\"\n    return (-N // 2) <= m <= (N // 2 - 1)\n\ndef build_periodic_function(Lx, Ly, Nx, Ny, modes):\n    \"\"\"\n    Build periodic function F(x,y)=sum A_mn exp(i 2pi (m x/Lx + n y/Ly)),\n    sampled on the Nx-by-Ny grid. 'modes' is list of (m, n, amplitude).\n    \"\"\"\n    x = np.arange(Nx) * (Lx / Nx)\n    y = np.arange(Ny) * (Ly / Ny)\n    X, Y = np.meshgrid(x, y, indexing='xy')\n    F = np.zeros((Ny, Nx), dtype=np.complex128)\n    for m, n, amp in modes:\n        phase = 2.0 * np.pi * (m * X / Lx + n * Y / Ly)\n        F += amp * np.exp(1j * phase)\n    return F, X, Y\n\ndef compute_dephased_currents(Lx, Ly, Nx, Ny, kx0, ky0, E0, H0, phi, psi, modes):\n    \"\"\"\n    Compute dephased equivalent currents:\n    J_tilde = n x H_t * exp(-i(kx0 x + ky0 y)) and\n    M_tilde = - n x E_t * exp(-i(kx0 x + ky0 y)).\n    Assume F = G with given modes.\n    \"\"\"\n    F, X, Y = build_periodic_function(Lx, Ly, Nx, Ny, modes)\n    # Bloch phase\n    bloch = np.exp(1j * (kx0 * X + ky0 * Y))\n    # Tangential fields\n    Ex = E0 * np.cos(psi) * F * bloch\n    Ey = E0 * np.sin(psi) * F * bloch\n    Hx = H0 * np.cos(phi) * F * bloch\n    Hy = H0 * np.sin(phi) * F * bloch\n    # Equivalent currents at z=0 with normal z-hat\n    Jx = -Hy\n    Jy = Hx\n    Mx = Ey\n    My = -Ex\n    # Dephase\n    dephase = np.exp(-1j * (kx0 * X + ky0 * Y))\n    Jx_t = Jx * dephase\n    Jy_t = Jy * dephase\n    Mx_t = Mx * dephase\n    My_t = My * dephase\n    return Jx_t, Jy_t, Mx_t, My_t\n\ndef fft_verify(Jx_t, Jy_t, Mx_t, My_t):\n    \"\"\"\n    Perform 2D FFT and shift to verify modal positions.\n    Returns the combined spectral energy array (not used in final result).\n    \"\"\"\n    # 2D FFTs\n    JxF = np.fft.fftshift(np.fft.fft2(Jx_t))\n    JyF = np.fft.fftshift(np.fft.fft2(Jy_t))\n    MxF = np.fft.fftshift(np.fft.fft2(Mx_t))\n    MyF = np.fft.fftshift(np.fft.fft2(My_t))\n    # Combined energy across components\n    energy = (np.abs(JxF)**2 + np.abs(JyF)**2 + np.abs(MxF)**2 + np.abs(MyF)**2)\n    return energy\n\ndef alias_fraction(Lx, Ly, Nx, Ny, kx0, ky0, E0, H0, phi, psi, modes):\n    \"\"\"\n    Compute aliasing fraction eta = E_alias / (E_true + E_alias).\n    We assume A_mn = B_mn = amplitude provided in modes.\n    \"\"\"\n    # Combined energy per mode factor\n    factor = (E0**2 + H0**2) * 2.0  # since |A|^2 + |B|^2 with A=B => 2|A|^2\n    E_true = 0.0\n    E_alias = 0.0\n    for m, n, amp in modes:\n        Emn = factor * (np.abs(amp)**2)\n        in_m = in_central_zone(m, Nx)\n        in_n = in_central_zone(n, Ny)\n        if in_m and in_n:\n            E_true += Emn\n        else:\n            # This mode will alias into the central zone\n            E_alias += Emn\n    denom = E_true + E_alias\n    if denom == 0.0:\n        eta = 0.0\n    else:\n        eta = E_alias / denom\n\n    # Optional internal verification: build and FFT dephased currents\n    # (Not used in final printed output.)\n    Jx_t, Jy_t, Mx_t, My_t = compute_dephased_currents(Lx, Ly, Nx, Ny, kx0, ky0, E0, H0, phi, psi, modes)\n    _ = fft_verify(Jx_t, Jy_t, Mx_t, My_t)\n    return eta\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (Lx, Ly, Nx, Ny, kx0, ky0, E0, H0, phi, psi, modes)\n    case1_modes = [\n        (0, 0, 1.0),\n        (5, 0, 0.6),\n        (-7, 2, 0.4),\n        (3, -6, 0.5),\n        (9, 9, 0.3),\n    ]\n    case2_modes = case1_modes.copy()\n    case3_modes = [\n        (5, 5, 1.0),\n        (-4, 4, 0.7),\n    ]\n\n    Lx = 0.2\n    Ly = 0.2\n\n    case1 = (\n        Lx, Ly, 32, 32,\n        0.2 * (2.0 * np.pi / Lx), -0.3 * (2.0 * np.pi / Ly),\n        1.0, 1.0, 0.7, 1.2,\n        case1_modes\n    )\n    case2 = (\n        Lx, Ly, 8, 8,\n        0.4 * (2.0 * np.pi / Lx), 0.1 * (2.0 * np.pi / Ly),\n        2.0, 1.5, 0.9, 0.3,\n        case2_modes\n    )\n    case3 = (\n        Lx, Ly, 6, 6,\n        0.95 * (np.pi / Lx), 0.95 * (np.pi / Ly),\n        1.0, 1.0, 0.5, 1.1,\n        case3_modes\n    )\n\n    test_cases = [case1, case2, case3]\n\n    results = []\n    for (Lx, Ly, Nx, Ny, kx0, ky0, E0, H0, phi, psi, modes) in test_cases:\n        eta = alias_fraction(Lx, Ly, Nx, Ny, kx0, ky0, E0, H0, phi, psi, modes)\n        # Ensure a standard float representation\n        results.append(float(eta))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The equivalence principle must account for all fields on the Huygens surface, including non-propagating evanescent waves which store reactive energy and define the sub-wavelength features of the near field. This advanced exercise explores the challenges posed by these rapidly decaying fields, which are crucial for phenomena like superdirectivity but are easily lost in numerical simulations or physical measurements . You will not only quantify the loss of this evanescent spectral information but also implement a reconstruction algorithm to recover it, a task representative of advanced inverse problems in imaging and field characterization.",
            "id": "3314970",
            "problem": "Consider a two-dimensional, time-harmonic electromagnetic field in free space with angular frequency $\\omega$ and wavenumber $k_0 = \\omega/c$, where $c$ is the speed of light in vacuum. By the equivalence principle, any radiating structure enclosed by a Huygens surface can be replaced by equivalent surface currents that reproduce the same fields outside the surface. The angular spectrum representation expresses the field above a planar Huygens surface (taken as the plane $z=0$) as a superposition of plane-wave components parameterized by the transverse wavenumber $k_t$. For $|k_t| \\le k_0$, components are propagating with longitudinal wavenumber $k_z = \\sqrt{k_0^2 - k_t^2}$ and phase factor $e^{i k_z z}$. For $|k_t| > k_0$, components are evanescent with $k_z = i \\alpha$, where $\\alpha = \\sqrt{k_t^2 - k_0^2}$, and decay as $e^{-\\alpha z}$.\n\nA superdirective array produces a significant portion of its near-field energy in the evanescent spectrum ($|k_t| > k_0$). When the Huygens surface is placed too far from the array, the evanescent components decay in amplitude, and many fall below a measurement threshold, leading to an incomplete measured spectrum. The task is to quantify the fraction of evanescent energy lost due to this decay and to propose and implement extrapolation heuristics to reconstruct the original evanescent spectrum at the source plane from a thresholded, incomplete measurement at the Huygens surface.\n\nYou are to implement a program that models a synthetic superdirective angular spectrum and evaluates the loss and reconstruction quality under different Huygens surface distances. The synthetic true spectrum $\\tilde{E}_\\text{true}(k_t)$ at $z=0$ is defined over a uniform grid $k_t \\in [-k_{\\max}, k_{\\max}]$ with $k_{\\max} = 8 k_0$. The spectrum amplitude consists of two parts:\n- For $|k_t| \\le k_0$ (propagating region): $A_\\text{prop}(k_t) = 0.2 \\exp\\!\\left(-\\left(\\frac{|k_t|}{0.6\\,k_0}\\right)^2\\right)$.\n- For $|k_t| > k_0$ (evanescent region): $A_\\text{evan}(k_t) = \\frac{1}{1 + \\left(\\frac{|k_t| - k_0}{0.3\\,k_0}\\right)^2}$.\n\nThe complex spectrum is $\\tilde{E}_\\text{true}(k_t) = A(k_t)$, with zero phase for simplicity, where $A(k_t)$ equals $A_\\text{prop}(k_t)$ or $A_\\text{evan}(k_t)$ as appropriate. The measurement at a Huygens surface located at $z = d$ is modeled by the angular spectrum propagation factor:\n$$\nH(k_t, d) = \n\\begin{cases}\ne^{i \\sqrt{k_0^2 - k_t^2}\\, d}, & |k_t| \\le k_0,\\\\\ne^{-\\sqrt{k_t^2 - k_0^2}\\, d}, & |k_t| > k_0,\n\\end{cases}\n$$\nso that the measured spectrum is $\\tilde{E}_\\text{meas}(k_t; d) = \\tilde{E}_\\text{true}(k_t)\\, H(k_t, d)$.\n\nA measurement threshold is applied to the magnitude $|\\tilde{E}_\\text{meas}(k_t; d)|$. Any spectral sample with magnitude below $T = \\eta \\max_{k_t} |\\tilde{E}_\\text{meas}(k_t; d)|$ is treated as missing, where $\\eta$ is a specified relative threshold. Define the evanescent loss fraction as\n$$\nL(d, \\eta) = \\frac{\\sum_{|k_t| > k_0,\\ |\\tilde{E}_\\text{meas}(k_t; d)| < T} |\\tilde{E}_\\text{true}(k_t)|^2}{\\sum_{|k_t| > k_0} |\\tilde{E}_\\text{true}(k_t)|^2}.\n$$\n\nTo extrapolate a thresholded, incomplete evanescent spectrum back to the source plane, implement the following heuristic reconstruction at $z=0$:\n1. For samples with $|k_t| \\le k_0$, invert propagation: $\\tilde{E}_\\text{rec}(k_t; 0) = \\tilde{E}_\\text{meas}(k_t; d)\\, e^{-i \\sqrt{k_0^2 - k_t^2}\\, d}$.\n2. For evanescent samples with $|k_t| > k_0$ and $|\\tilde{E}_\\text{meas}(k_t; d)| \\ge T$, invert decay: $\\tilde{E}_\\text{rec}(k_t; 0) = \\tilde{E}_\\text{meas}(k_t; d)\\, e^{+\\sqrt{k_t^2 - k_0^2}\\, d}$.\n3. For missing evanescent samples with $|k_t| > k_0$ and $|\\tilde{E}_\\text{meas}(k_t; d)| < T$, estimate the amplitude by fitting a log-linear model $\\ln A(k_t) \\approx a + b\\, |k_t|$ using the available inverted evanescent amplitudes from step 2 and least squares. If fewer than three evanescent samples are available, use a fallback prior slope $b_\\text{prior} = -\\frac{1}{0.3\\,k_0}$ anchored at the smallest missing $|k_t|$ with continuity to the nearest available amplitude. Assign zero phase for the extrapolated evanescent components. The reconstructed complex spectrum for missing evanescent samples is then $\\tilde{E}_\\text{rec}(k_t; 0) = \\exp(a + b\\, |k_t|)$.\n\nQuantify the reconstruction quality on the evanescent spectrum by the normalized mean squared error\n$$\n\\text{NMSE}_\\text{evan}(d, \\eta) = \\frac{\\sum_{|k_t| > k_0} \\left|\\tilde{E}_\\text{rec}(k_t; 0) - \\tilde{E}_\\text{true}(k_t)\\right|^2}{\\sum_{|k_t| > k_0} \\left|\\tilde{E}_\\text{true}(k_t)\\right|^2}.\n$$\n\nUse the following physical constants and numerical parameters:\n- Speed of light $c = 299{,}792{,}458\\ \\text{m/s}$, frequency $f = 3.0 \\times 10^9\\ \\text{Hz}$, so $\\lambda_0 = c/f$ and $k_0 = 2\\pi/\\lambda_0$.\n- Spectral grid: $k_t \\in [-8 k_0, 8 k_0]$ sampled uniformly with $N = 2048$ points.\n\nTest suite:\n- Case 1 (boundary case): $d = 0 \\cdot \\lambda_0$, $\\eta = 10^{-6}$.\n- Case 2 (near field): $d = 0.1 \\cdot \\lambda_0$, $\\eta = 10^{-3}$.\n- Case 3 (moderate distance): $d = 0.5 \\cdot \\lambda_0$, $\\eta = 10^{-3}$.\n- Case 4 (far Huygens surface): $d = 1.0 \\cdot \\lambda_0$, $\\eta = 10^{-2}$.\n\nYour program must compute, for each test case, the pair $[L(d,\\eta), \\text{NMSE}_\\text{evan}(d,\\eta)]$ as floating-point numbers. No angles are involved, and no physical units are required in the output since both metrics are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list of two floats in the form\n$$\n\\big[\\ [L_1,\\ \\text{NMSE}_1],\\ [L_2,\\ \\text{NMSE}_2],\\ [L_3,\\ \\text{NMSE}_3],\\ [L_4,\\ \\text{NMSE}_4]\\ \\big].\n$$\nNo input should be read from the user, and no external files should be used. The implementation must follow the above model and heuristics exactly, starting from the fundamental definitions and using the specified numerical parameters.",
            "solution": "The user has provided a well-posed problem in computational electromagnetics that requires modeling the measurement and reconstruction of a superdirective source's angular spectrum. The problem is scientifically sound, with all necessary parameters and definitions provided. I will now proceed with a complete solution.\n\nThe core of the problem is to simulate the effects of measurement distance and sensitivity on the evanescent part of an electromagnetic field's angular spectrum. Evanescent waves decay exponentially away from their source, meaning that if a measurement (Huygens) surface is placed too far away, these high-frequency spatial components may fall below the noise floor or sensitivity limit of the measurement instrument. This loss of information degrades the accuracy with which the original source can be characterized. The problem asks us to quantify this loss and to evaluate a heuristic-based extrapolation method for reconstructing the missing spectral information.\n\nThe solution is implemented by following these steps for each test case defined by a measurement distance $d$ and a relative threshold $\\eta$.\n\n**1. Physical and Numerical Parameter Setup**\nFirst, we establish the physical constants and the numerical grid.\n-   The speed of light is $c = 299792458\\ \\text{m/s}$.\n-   The frequency is $f = 3.0 \\times 10^9\\ \\text{Hz}$.\n-   From these, we derive the free-space wavelength $\\lambda_0 = c/f$ and the free-space wavenumber $k_0 = 2\\pi/\\lambda_0$.\n-   A one-dimensional grid for the transverse wavenumber $k_t$ is defined, spanning from $-8k_0$ to $8k_0$ with $N=2048$ uniformly spaced points. This grid represents the \"k-space\" or spectral domain. The absolute value $|k_t|$ is pre-calculated for convenience.\n\n**2. True Spectrum Generation**\nA synthetic \"true\" angular spectrum at the source plane ($z=0$), denoted $\\tilde{E}_\\text{true}(k_t)$, is constructed according to the problem's definition. This spectrum is purely real (zero phase) and its amplitude $A(k_t)$ is defined piecewise:\n-   For the propagating region, where $|k_t| \\le k_0$, the amplitude is a Gaussian function:\n    $$\n    A_\\text{prop}(k_t) = 0.2 \\exp\\!\\left(-\\left(\\frac{|k_t|}{0.6\\,k_0}\\right)^2\\right)\n    $$\n-   For the evanescent region, where $|k_t| > k_0$, the amplitude is a Lorentzian-like function:\n    $$\n    A_\\text{evan}(k_t) = \\frac{1}{1 + \\left(\\frac{|k_t| - k_0}{0.3\\,k_0}\\right)^2}\n    $$\nThis model represents a superdirective source, which has significant energy radiated into the evanescent spectrum.\n\n**3. Measurement Simulation**\nThe field propagates from the source plane $z=0$ to the Huygens measurement surface at $z=d$. In the angular spectrum domain, this propagation is described by a multiplicative transfer function, $H(k_t, d)$:\n$$\nH(k_t, d) = e^{i k_z d}\n$$\nwhere $k_z$ is the longitudinal wavenumber.\n-   For propagating waves ($|k_t| \\le k_0$), $k_z = \\sqrt{k_0^2 - k_t^2}$ is real, and $H$ is a pure phase term.\n-   For evanescent waves ($|k_t| > k_0$), $k_z = i\\sqrt{k_t^2 - k_0^2} = i\\alpha$, and $H$ becomes a real-valued exponential decay term, $e^{-\\alpha d}$.\nThis is compactly implemented using complex arithmetic: $k_z = \\sqrt{k_0^2 - k_t^2 + 0i}$.\nThe measured spectrum at $z=d$ is thus $\\tilde{E}_\\text{meas}(k_t; d) = \\tilde{E}_\\text{true}(k_t) H(k_t, d)$.\n\nA measurement threshold $T$ is applied to simulate limited instrument sensitivity. $T$ is defined relative to the peak measured amplitude: $T = \\eta \\max_{k_t} |\\tilde{E}_\\text{meas}(k_t; d)|$. Any spectral component where $|\\tilde{E}_\\text{meas}| < T$ is considered \"missing\".\n\n**4. Evanescent Loss Fraction Calculation**\nThe fraction of the true evanescent energy that is lost due to thresholding is calculated as:\n$$\nL(d, \\eta) = \\frac{\\sum_{|k_t| > k_0,\\ |\\tilde{E}_\\text{meas}(k_t; d)| < T} |\\tilde{E}_\\text{true}(k_t)|^2}{\\sum_{|k_t| > k_0} |\\tilde{E}_\\text{true}(k_t)|^2}\n$$\nThis involves summing the power ($|\\tilde{E}|^2$) of the true spectrum over the evanescent components that were declared missing, and normalizing by the total power in the true evanescent spectrum.\n\n**5. Spectrum Reconstruction**\nAn extrapolation heuristic is applied to reconstruct the spectrum at the source plane, $\\tilde{E}_\\text{rec}(k_t; 0)$, from the thresholded measurement $\\tilde{E}_\\text{meas}$.\n1.  **Propagating Components ($|k_t| \\le k_0$):** Since propagating waves do not decay (only their phase changes), all components are assumed to be measured correctly. We invert the propagation by dividing by the transfer function: $\\tilde{E}_\\text{rec} = \\tilde{E}_\\text{meas} / H(k_t, d)$. This is equivalent to $\\tilde{E}_\\text{meas} e^{-i k_z d}$. This step perfectly recovers the true propagating spectrum.\n\n2.  **Available Evanescent Components:** For evanescent components that are *not* missing (i.e., $|\\tilde{E}_\\text{meas}| \\ge T$), we similarly invert the exponential decay: $\\tilde{E}_\\text{rec} = \\tilde{E}_\\text{meas} / H(k_t, d) = \\tilde{E}_\\text{meas} e^{\\alpha d}$. This correctly recovers the true amplitude for these components.\n\n3.  **Missing Evanescent Components:** For evanescent components that are missing, we must extrapolate.\n    -   **Standard Case (Sufficient Data):** If three or more evanescent components are available from step 2, we fit a log-linear model to their reconstructed amplitudes. We solve the least-squares problem for parameters $a$ and $b$ in the model $\\ln A(k_t) \\approx a + b |k_t|$, where $A(k_t) = |\\tilde{E}_\\text{rec}(k_t;0)|$. The amplitudes of the missing components are then estimated using this model: $A_\\text{rec}(k_t) = \\exp(a + b |k_t|)$. The phase is set to zero.\n    -   **Fallback Case (Insufficient Data):** If fewer than three evanescent components are available, we use a prior-based extrapolation. The slope of the log-linear model is fixed to $b_\\text{prior} = -1/(0.3k_0)$. The model needs to be \"anchored\" to ensure continuity. We find the available spectral sample (propagating or evanescent) with $|k_t|$ closest to the start of the missing region. Let its wavenumber and reconstructed amplitude be $|k_t|_\\text{anchor}$ and $A_\\text{anchor}$. The reconstructed amplitude for a missing component at $|k_t|_\\text{miss}$ is then given by $A_\\text{rec}(|k_t|_\\text{miss}) = A_\\text{anchor} \\exp(b_\\text{prior} (|k_t|_\\text{miss} - |k_t|_\\text{anchor}))$.\n\n**6. Reconstruction Error Calculation**\nThe quality of the reconstruction is quantified by the Normalized Mean Squared Error (NMSE), focusing only on the evanescent portion of the spectrum:\n$$\n\\text{NMSE}_\\text{evan}(d, \\eta) = \\frac{\\sum_{|k_t| > k_0} |\\tilde{E}_\\text{rec}(k_t; 0) - \\tilde{E}_\\text{true}(k_t)|^2}{\\sum_{|k_t| > k_0} |\\tilde{E}_\\text{true}(k_t)|^2}\n$$\nThis metric compares the reconstructed evanescent spectrum, including the extrapolated parts, to the original true evanescent spectrum.\n\nThis entire process is repeated for each of the four test cases specified in the problem statement. The resulting pairs of $[L, \\text{NMSE}_\\text{evan}]$ are collected and formatted for the final output. The special case $d=0$ serves as a baseline, for which both loss and error should be negligible, confirming the correctness of the implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational electromagnetics problem described.\n    Models the measurement and reconstruction of a superdirective antenna's angular spectrum.\n    \"\"\"\n\n    # Physical constants and numerical parameters\n    c = 299792458.0  # Speed of light, m/s\n    f = 3.0e9  # Frequency, Hz\n    lambda0 = c / f  # Wavelength, m\n    k0 = 2 * np.pi / lambda0  # Wavenumber, rad/m\n    N = 2048  # Number of points in spectral grid\n    k_max = 8 * k0\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (d_factor, eta)\n        (0.0, 1e-6),  # Case 1: boundary case\n        (0.1, 1e-3),  # Case 2: near field\n        (0.5, 1e-3),  # Case 3: moderate distance\n        (1.0, 1e-2),  # Case 4: far Huygens surface\n    ]\n\n    # Create the spectral grid\n    kt = np.linspace(-k_max, k_max, N)\n    kt_abs = np.abs(kt)\n\n    # 1. Generate the true spectrum at z=0\n    E_true = np.zeros(N, dtype=np.complex128)\n    \n    # Masks for propagating and evanescent regions\n    is_prop = kt_abs <= k0\n    is_evan = kt_abs > k0\n\n    # Propagating part\n    A_prop = 0.2 * np.exp(-((kt_abs[is_prop] / (0.6 * k0))**2))\n    E_true[is_prop] = A_prop\n\n    # Evanescent part\n    A_evan = 1.0 / (1.0 + ((kt_abs[is_evan] - k0) / (0.3 * k0))**2)\n    E_true[is_evan] = A_evan\n    \n    # Store total evanescent power for normalization\n    total_evan_power = np.sum(np.abs(E_true[is_evan])**2)\n\n    results = []\n    \n    for d_factor, eta in test_cases:\n        d = d_factor * lambda0\n\n        # 2. Simulate measurement at z=d\n        # Propagation factor H(kt, d)\n        # Using +0j makes sqrt work for negative arguments, producing correct imaginary k_z\n        k_z = np.sqrt(k0**2 - kt**2 + 0j)\n        H = np.exp(1j * k_z * d)\n\n        E_meas = E_true * H\n        E_meas_abs = np.abs(E_meas)\n        \n        # Apply measurement threshold\n        T = eta * np.max(E_meas_abs) if E_meas_abs.size > 0 else 0\n        is_missing = E_meas_abs < T\n\n        # 3. Calculate evanescent loss fraction L\n        is_evan_missing = is_evan & is_missing\n        lost_evan_power = np.sum(np.abs(E_true[is_evan_missing])**2)\n        \n        L = lost_evan_power / total_evan_power if total_evan_power > 0 else 0.0\n\n        # 4. Reconstruct the spectrum at z=0\n        E_rec = np.zeros(N, dtype=np.complex128)\n\n        # Step 1 & 2: Invert for all available (non-missing) samples\n        is_avail = ~is_missing\n        # Note: Inverting H can cause overflow if d is large and kt is large\n        # H can be very small. We must be careful.\n        # However, for available samples, E_meas is not too small, so E_meas/H should be fine.\n        E_rec[is_avail] = E_meas[is_avail] / H[is_avail]\n        \n        # Step 3: Extrapolate for missing evanescent samples\n        if np.any(is_evan_missing):\n            is_evan_avail = is_evan & is_avail\n            n_evan_avail = np.sum(is_evan_avail)\n\n            if n_evan_avail >= 3:\n                # Standard case: Log-linear least squares fit\n                kt_fit = kt_abs[is_evan_avail]\n                A_rec_avail = np.abs(E_rec[is_evan_avail])\n                \n                # Filter out zero amplitudes to avoid log(0)\n                valid_fit_indices = A_rec_avail > 0\n                if np.sum(valid_fit_indices) >= 2:\n                    log_A_fit = np.log(A_rec_avail[valid_fit_indices])\n                    \n                    # np.polyfit returns [slope, intercept] for degree 1\n                    b, a = np.polyfit(kt_fit[valid_fit_indices], log_A_fit, 1)\n\n                    kt_missing_vals = kt_abs[is_evan_missing]\n                    E_rec[is_evan_missing] = np.exp(a + b * kt_missing_vals)\n                else: # Fall back if not enough positive data points for fit\n                    n_evan_avail = 0 # force fallback\n\n            if n_evan_avail < 3: # Note: this catches failure from the inner if too\n                # Fallback case\n                b_prior = -1.0 / (0.3 * k0)\n                \n                # Find anchor point\n                kt_boundary = np.min(kt_abs[is_evan_missing])\n                \n                # Find available sample closest to the missing region boundary\n                avail_indices = np.where(is_avail)[0]\n                if avail_indices.size > 0:\n                    closest_avail_idx = avail_indices[np.argmin(np.abs(kt_abs[avail_indices] - kt_boundary))]\n                \n                    kt_anchor = kt_abs[closest_avail_idx]\n                    A_anchor = np.abs(E_rec[closest_avail_idx])\n\n                    # Extrapolate using the anchor and prior slope\n                    for idx in np.where(is_evan_missing)[0]:\n                        kt_current = kt_abs[idx]\n                        A_reconstructed = A_anchor * np.exp(b_prior * (kt_current - kt_anchor))\n                        E_rec[idx] = A_reconstructed\n                else:\n                    # Very unlikely case: no samples are available at all\n                    # Problem implies this won't happen. If it did, E_rec remains zero.\n                    pass\n\n        # 5. Calculate NMSE for evanescent spectrum\n        nmse_num = np.sum(np.abs(E_rec[is_evan] - E_true[is_evan])**2)\n        NMSE_evan = nmse_num / total_evan_power if total_evan_power > 0 else 0.0\n\n        results.append([L, NMSE_evan])\n    \n    # Format the final output string\n    # Using a nested list comprehension to format floats and then join\n    result_str = '[' + ','.join([f\"[{l:.6e},{n:.6e}]\" for l, n in results]) + ']'\n    \n    print(result_str)\n\nsolve()\n```"
        }
    ]
}