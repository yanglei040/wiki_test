{
    "hands_on_practices": [
        {
            "introduction": "The stability of many boundary integral formulations, including PMCHWT and Müller, hinges on their nature as second-kind integral equations, which feature a crucial identity operator. This identity term arises directly from the \"jump\" a field experiences when its source lies on the boundary surface itself. This practice guides you through the fundamental derivation of the famous $\\frac{1}{2}$ jump coefficient for the magnetic field integral operator, starting from the basic vector potential and analyzing the behavior of the singular Green's function kernel . Successfully completing this calculation provides a concrete understanding of how the local geometry of the surface gives rise to the essential identity term in the operator equations.",
            "id": "3298557",
            "problem": "Consider a smooth, orientable surface $S$ separating two homogeneous media with outward unit normal $\\hat{\\mathbf{n}}$. In boundary integral formulations for dielectric scattering, such as the Poggio–Miller–Chang–Harrington–Wu–Tsai (PMCHWT) formulation and the Müller formulation, the tangential trace of the magnetic field integral operator exhibits a jump across $S$ that is characterized by a local coefficient. This coefficient is a consequence of the singular structure of the free-space scalar Green’s function and is reflected in the Magnetic Field Integral Equation (MFIE).\n\nUsing only fundamental electromagnetic potentials, consider the free-space scalar Green’s function $G_{k}(\\mathbf{r},\\mathbf{r}')=\\exp\\!\\big(i k |\\mathbf{r}-\\mathbf{r}'|\\big)\\big/\\big(4\\pi |\\mathbf{r}-\\mathbf{r}'|\\big)$ and the magnetic vector potential representation of the scattered magnetic field,\n$$\n\\mathbf{H}(\\mathbf{r})=\\nabla\\times \\int_{S} G_{k}(\\mathbf{r},\\mathbf{r}')\\,\\mathbf{J}(\\mathbf{r}')\\,\\mathrm{d}S',\n$$\nwhere $\\mathbf{J}$ is a tangential surface current density on $S$. Let $\\mathbf{r}_{0}\\in S$ be a point on the surface, and set $\\mathbf{r}=\\mathbf{r}_{0}+\\zeta\\,\\hat{\\mathbf{n}}(\\mathbf{r}_{0})$ with $\\zeta0$ (approach from the exterior side). In a sufficiently small neighborhood of $\\mathbf{r}_{0}$, approximate $S$ by its tangent plane and assume $\\mathbf{J}(\\mathbf{r}')\\approx \\mathbf{J}_{0}$ is constant over this neighborhood, with $\\mathbf{J}_{0}\\cdot \\hat{\\mathbf{n}}(\\mathbf{r}_{0})=0$.\n\nFocusing only on the singular part of $G_{k}$, replace $G_{k}$ locally by its static part $1/(4\\pi|\\mathbf{r}-\\mathbf{r}'|)$. Show that the contribution to the tangential magnetic trace $\\hat{\\mathbf{n}}(\\mathbf{r}_{0})\\times \\mathbf{H}(\\mathbf{r})$ from a small planar disk of radius $R$ centered at $\\mathbf{r}_{0}$ is proportional to $\\mathbf{J}_{0}$ with proportionality factor equal to the following principal value limit:\n$$\nI(\\zeta,R)\\;=\\;\\int_{|\\boldsymbol{\\rho}|R}\\frac{1}{4\\pi}\\,\\frac{\\zeta}{\\big(|\\boldsymbol{\\rho}|^{2}+\\zeta^{2}\\big)^{3/2}}\\,\\mathrm{d}^{2}\\boldsymbol{\\rho},\\quad \\boldsymbol{\\rho}\\in\\mathbb{R}^{2},\n$$\nand that the jump coefficient is given by the limit\n$$\nI\\;=\\;\\lim_{\\zeta\\to 0^{+}}\\,\\lim_{R\\to\\infty}\\,I(\\zeta,R).\n$$\n\nCompute $I$ exactly. Express your final answer as a dimensionless real number. No rounding is required.",
            "solution": "We begin from the vector potential representation\n$$\n\\mathbf{H}(\\mathbf{r})=\\nabla\\times \\int_{S} G_{k}(\\mathbf{r},\\mathbf{r}')\\,\\mathbf{J}(\\mathbf{r}')\\,\\mathrm{d}S'.\n$$\nNear the singularity $\\mathbf{r}'\\to \\mathbf{r}$, the dominant behavior arises from the gradient of the Green’s function with respect to $\\mathbf{r}$. Using the product rule,\n$$\n\\nabla\\times\\big(G_{k}(\\mathbf{r},\\mathbf{r}')\\,\\mathbf{J}(\\mathbf{r}')\\big)=\\nabla G_{k}(\\mathbf{r},\\mathbf{r}')\\times \\mathbf{J}(\\mathbf{r}')+G_{k}(\\mathbf{r},\\mathbf{r}')\\,\\nabla\\times \\mathbf{J}(\\mathbf{r}'),\n$$\nand the latter term is weakly singular. Thus, the singular contribution to $\\mathbf{H}$ comes from $\\nabla G_{k}\\times \\mathbf{J}$. Moreover, the singularity is governed by the static part of $G_{k}$, so locally we replace\n$$\nG_{k}(\\mathbf{r},\\mathbf{r}')\\approx \\frac{1}{4\\pi |\\mathbf{R}|},\\quad \\mathbf{R}=\\mathbf{r}-\\mathbf{r}'.\n$$\nThen\n$$\n\\nabla G_{k}(\\mathbf{r},\\mathbf{r}')\\approx \\nabla\\left(\\frac{1}{4\\pi |\\mathbf{R}|}\\right)=-\\frac{\\mathbf{R}}{4\\pi |\\mathbf{R}|^{3}}.\n$$\nThe tangential magnetic trace involves $\\hat{\\mathbf{n}}(\\mathbf{r}_{0})\\times \\mathbf{H}(\\mathbf{r})$. Using the vector triple product,\n$$\n\\hat{\\mathbf{n}}(\\mathbf{r}_{0})\\times\\big(\\nabla G_{k}(\\mathbf{r},\\mathbf{r}')\\times \\mathbf{J}(\\mathbf{r}')\\big)\n= \\big(\\hat{\\mathbf{n}}(\\mathbf{r}_{0})\\cdot \\mathbf{J}(\\mathbf{r}')\\big)\\,\\nabla G_{k}(\\mathbf{r},\\mathbf{r}') - \\big(\\hat{\\mathbf{n}}(\\mathbf{r}_{0})\\cdot \\nabla G_{k}(\\mathbf{r},\\mathbf{r}')\\big)\\,\\mathbf{J}(\\mathbf{r}').\n$$\nBecause $\\mathbf{J}(\\mathbf{r}')$ is tangential, $\\hat{\\mathbf{n}}(\\mathbf{r}_{0})\\cdot \\mathbf{J}(\\mathbf{r}')=0$, and thus the singular contribution reduces to\n$$\n-\\big(\\hat{\\mathbf{n}}(\\mathbf{r}_{0})\\cdot \\nabla G_{k}(\\mathbf{r},\\mathbf{r}')\\big)\\,\\mathbf{J}(\\mathbf{r}').\n$$\nApproximating $G_{k}$ by $1/(4\\pi |\\mathbf{R}|)$ and setting $\\mathbf{r}=\\mathbf{r}_{0}+\\zeta\\,\\hat{\\mathbf{n}}(\\mathbf{r}_{0})$ with $\\zeta0$, we find\n$$\n\\hat{\\mathbf{n}}(\\mathbf{r}_{0})\\cdot \\nabla\\!\\left(\\frac{1}{4\\pi |\\mathbf{R}|}\\right)\n= \\hat{\\mathbf{n}}(\\mathbf{r}_{0})\\cdot\\left(-\\frac{\\mathbf{R}}{4\\pi |\\mathbf{R}|^{3}}\\right)=-\\frac{\\hat{\\mathbf{n}}(\\mathbf{r}_{0})\\cdot \\mathbf{R}}{4\\pi |\\mathbf{R}|^{3}}.\n$$\nTherefore, the singular part of the tangential magnetic trace contributes\n$$\n-\\left(-\\frac{\\hat{\\mathbf{n}}(\\mathbf{r}_{0})\\cdot \\mathbf{R}}{4\\pi |\\mathbf{R}|^{3}}\\right)\\mathbf{J}(\\mathbf{r}')=\\frac{\\hat{\\mathbf{n}}(\\mathbf{r}_{0})\\cdot \\mathbf{R}}{4\\pi |\\mathbf{R}|^{3}}\\,\\mathbf{J}(\\mathbf{r}').\n$$\nLocally approximate $S$ by its tangent plane at $\\mathbf{r}_{0}$, introduce planar coordinates $\\boldsymbol{\\rho}\\in\\mathbb{R}^{2}$ with $\\mathbf{r}'=\\mathbf{r}_{0}+\\boldsymbol{\\rho}$, and note that $\\mathbf{R}=\\mathbf{r}-\\mathbf{r}'=\\zeta\\,\\hat{\\mathbf{n}}(\\mathbf{r}_{0})-\\boldsymbol{\\rho}$. Hence $\\hat{\\mathbf{n}}(\\mathbf{r}_{0})\\cdot \\mathbf{R}=\\zeta$, and $|\\mathbf{R}|^{2}=|\\boldsymbol{\\rho}|^{2}+\\zeta^{2}$. Assuming $\\mathbf{J}(\\mathbf{r}')\\approx \\mathbf{J}_{0}$ is constant on the small patch, the contribution of a disk of radius $R$ around $\\mathbf{r}_{0}$ to the singular part becomes\n$$\n\\left(\\int_{|\\boldsymbol{\\rho}|R}\\frac{1}{4\\pi}\\,\\frac{\\zeta}{\\big(|\\boldsymbol{\\rho}|^{2}+\\zeta^{2}\\big)^{3/2}}\\,\\mathrm{d}^{2}\\boldsymbol{\\rho}\\right)\\mathbf{J}_{0}\n= I(\\zeta,R)\\,\\mathbf{J}_{0}.\n$$\nThe principal value coefficient is therefore\n$$\nI=\\lim_{\\zeta\\to 0^{+}}\\lim_{R\\to\\infty} I(\\zeta,R),\n$$\nwhich we now evaluate.\n\nCompute $I(\\zeta,R)$ in polar coordinates $\\boldsymbol{\\rho}=(\\rho,\\varphi)$ with $\\rho\\in[0,R]$ and $\\varphi\\in[0,2\\pi)$:\n$$\nI(\\zeta,R)=\\int_{0}^{R}\\int_{0}^{2\\pi}\\frac{1}{4\\pi}\\,\\frac{\\zeta}{\\big(\\rho^{2}+\\zeta^{2}\\big)^{3/2}}\\,\\rho\\,\\mathrm{d}\\varphi\\,\\mathrm{d}\\rho\n=\\frac{1}{2}\\int_{0}^{R}\\frac{\\zeta\\,\\rho}{\\big(\\rho^{2}+\\zeta^{2}\\big)^{3/2}}\\,\\mathrm{d}\\rho.\n$$\nLet $u=\\rho^{2}+\\zeta^{2}$ so that $\\mathrm{d}u=2\\rho\\,\\mathrm{d}\\rho$. Then\n$$\nI(\\zeta,R)=\\frac{1}{2}\\int_{\\zeta^{2}}^{R^{2}+\\zeta^{2}}\\frac{\\zeta}{2}\\,u^{-3/2}\\,\\mathrm{d}u\n=\\frac{1}{4}\\,\\zeta\\left[-2\\,u^{-1/2}\\right]_{\\zeta^{2}}^{R^{2}+\\zeta^{2}}\n=\\frac{1}{2}\\left(1-\\frac{\\zeta}{\\sqrt{R^{2}+\\zeta^{2}}}\\right).\n$$\nTaking $R\\to\\infty$ first gives\n$$\n\\lim_{R\\to\\infty} I(\\zeta,R)=\\frac{1}{2}\\left(1-\\lim_{R\\to\\infty}\\frac{\\zeta}{\\sqrt{R^{2}+\\zeta^{2}}}\\right)=\\frac{1}{2}.\n$$\nFinally, the limit $\\zeta\\to 0^{+}$ leaves the value unchanged:\n$$\nI=\\lim_{\\zeta\\to 0^{+}}\\left(\\lim_{R\\to\\infty} I(\\zeta,R)\\right)=\\frac{1}{2}.\n$$\nThus, the principal value integral that captures the local singular contribution to the tangential magnetic trace equals $I=1/2$, confirming the jump coefficient that appears in the Magnetic Field Integral Equation, and hence in the PMCHWT and Müller dielectric formulations.",
            "answer": "$$\\boxed{\\tfrac{1}{2}}$$"
        },
        {
            "introduction": "A significant challenge in computational electromagnetics is the \"low-frequency breakdown,\" where integral equation systems become severely ill-conditioned as the operational frequency approaches zero. This instability stems from an improper scaling between the solenoidal (divergence-free) and non-solenoidal (curl-free) components of the equivalent surface currents. This exercise presents a simplified but powerful model of this phenomenon and a state-of-the-art technique to resolve it . By applying a specific frequency- and impedance-based scaling and calculating the resulting matrix condition number, you will gain hands-on insight into how modern formulations achieve robustness from static to high-frequency regimes.",
            "id": "3298604",
            "problem": "Consider a smooth dielectric interface $\\Gamma$ separating two homogeneous isotropic media with permittivity-permeability pairs $(\\epsilon_{1},\\mu_{1})$ and $(\\epsilon_{2},\\mu_{2})$. Let $\\eta=\\sqrt{\\mu_{2}/\\epsilon_{2}}$ denote the intrinsic impedance of the exterior medium. The Poggio-Miller-Chang-Harrington-Wu-Tsai (PMCHWT) formulation and the Müller formulation introduce equivalent tangential electric and magnetic surface currents $\\mathbf{J}$ and $\\mathbf{M}$ on $\\Gamma$ to enforce the boundary conditions stemming from Maxwell’s equations. In the limit $k\\to 0$ with $k=\\omega\\sqrt{\\mu\\epsilon}$, it is known that naive discretizations of these formulations suffer from low-frequency breakdown due to incompatible $\\omega$-scalings of solenoidal and non-solenoidal components of $\\mathbf{J}$ and the coupling with $\\mathbf{M}$.\n\nWork on a simple two-triangle mesh that supports a single Rao-Wilton-Glisson (RWG) basis function on the interior edge. From this RWG pair, construct two orthogonal unit-norm surface-current modes $\\mathbf{f}_{L}$ (solenoidal or loop) and $\\mathbf{f}_{T}$ (non-solenoidal or tree) satisfying $\\nabla_{s}\\cdot \\mathbf{f}_{L}=0$ and $\\nabla_{s}\\cdot \\mathbf{f}_{T}\\neq 0$, where $\\nabla_{s}\\cdot$ is the surface divergence. Using quasi-static expansions of the electric field integral equation (EFIE) and magnetic field integral equation (MFIE) operators, the reduced $2\\times 2$ block that couples the non-solenoidal component of $\\mathbf{J}$ (coefficient $j_{T}$ in the $\\mathbf{f}_{T}$ direction) to the solenoidal component of $\\mathbf{M}$ (coefficient $m_{L}$ in the $\\mathbf{f}_{L}$ direction) can be modeled, for sufficiently small $k$, by the matrix\n$$\n\\mathbf{A}(\\omega)=\n\\begin{pmatrix}\n\\frac{C}{\\omega}  S \\\\\nS  \\omega L\n\\end{pmatrix},\n$$\nwhere $C0$ and $L0$ arise from the quasi-static scalar-potential and vector-potential energy inner products on the chosen mesh and $S\\in\\mathbb{R}$ is a bounded cross-coupling term that is independent of $\\omega$ at leading order. Specifically, $C$ and $L$ are defined by\n$$\nC=\\left\\langle \\nabla_{s}\\cdot \\mathbf{f}_{T},\\, \\mathcal{S}_{0}\\left(\\nabla_{s}\\cdot \\mathbf{f}_{T}\\right)\\right\\rangle,\\qquad\nL=\\left\\langle \\mathbf{f}_{L},\\, \\mathcal{T}_{0}\\mathbf{f}_{L}\\right\\rangle,\n$$\nwith $\\mathcal{S}_{0}$ the static single-layer potential operator and $\\mathcal{T}_{0}$ the static vector-potential operator, and $S=\\left\\langle \\mathbf{f}_{L},\\, \\mathcal{K}_{0}\\mathbf{f}_{T}\\right\\rangle$ for an appropriate compact cross-operator $\\mathcal{K}_{0}$ capturing loop–tree coupling in the static limit. All inner products are taken in the natural energy spaces on $\\Gamma$ and the three constants depend only on the two-triangle geometry and material pair.\n\nTo mitigate conditioning deterioration as $k\\to 0$, consider the following stabilization: split $\\mathbf{J}$ into its solenoidal and non-solenoidal components and scale these unknowns by frequency-dependent factors that balance their EFIE contributions, and scale the magnetic current by the exterior impedance, i.e., $\\mathbf{M}\\mapsto \\eta\\,\\mathbf{M}$. On the reduced two-mode subspace described above, apply the congruence transform $\\mathbf{B}=\\mathbf{P}^{\\top}\\mathbf{A}(\\omega)\\mathbf{P}$ with\n$$\n\\mathbf{P}=\\begin{pmatrix}\n\\omega^{1/2}  0 \\\\\n0  \\omega^{-1/2}\n\\end{pmatrix}\n\\begin{pmatrix}\n1  0 \\\\\n0  \\eta\n\\end{pmatrix},\n$$\nwhich corresponds to the frequency balancing of the non-solenoidal $\\mathbf{J}$ component and the impedance scaling of the solenoidal $\\mathbf{M}$ component. This yields the $k\\to 0$ limiting symmetric positive definite matrix\n$$\n\\mathbf{B}_{0}=\\lim_{\\omega\\to 0}\\mathbf{B}=\n\\begin{pmatrix}\nC  \\eta S \\\\\n\\eta S  \\eta^{2}L\n\\end{pmatrix}.\n$$\nLet $\\kappa_{2}(\\mathbf{B}_{0})$ denote the spectral condition number (ratio of largest to smallest singular value) of $\\mathbf{B}_{0}$, which for symmetric positive definite matrices equals the ratio of its largest to smallest eigenvalues.\n\nCompute the closed-form expression for $\\kappa_{2}(\\mathbf{B}_{0})$ in terms of $C$, $L$, $S$, and $\\eta$. Your final answer must be a single analytic expression; do not include any units.",
            "solution": "The task is to find the spectral condition number $\\kappa_2(\\mathbf{B}_0)$ of the $2 \\times 2$ symmetric positive definite matrix:\n$$\n\\mathbf{B}_{0} = \\begin{pmatrix} C  \\eta S \\\\ \\eta S  \\eta^{2}L \\end{pmatrix}\n$$\nThe spectral condition number is the ratio of the largest eigenvalue, $\\lambda_{\\max}$, to the smallest eigenvalue, $\\lambda_{\\min}$.\n$$\n\\kappa_{2}(\\mathbf{B}_{0}) = \\frac{\\lambda_{\\max}}{\\lambda_{\\min}}\n$$\nThe eigenvalues $\\lambda$ are the roots of the characteristic equation $\\det(\\mathbf{B}_{0} - \\lambda\\mathbf{I}) = 0$.\n$$\n\\det\\begin{pmatrix} C-\\lambda  \\eta S \\\\ \\eta S  \\eta^{2}L-\\lambda \\end{pmatrix} = 0\n$$\n$$\n(C-\\lambda)(\\eta^2 L - \\lambda) - (\\eta S)^2 = 0\n$$\n$$\n\\lambda^2 - (C + \\eta^2 L)\\lambda + C\\eta^2 L - \\eta^2 S^2 = 0\n$$\nThis is a quadratic equation for $\\lambda$. Using the quadratic formula, the roots are:\n$$\n\\lambda = \\frac{(C+\\eta^{2}L) \\pm \\sqrt{(C+\\eta^{2}L)^{2} - 4(C\\eta^{2}L - \\eta^2 S^2)}}{2}\n$$\nSimplifying the term under the square root:\n$$\n\\sqrt{(C^2 + 2C\\eta^2L + \\eta^4L^2) - 4C\\eta^2L + 4\\eta^2S^2} = \\sqrt{C^2 - 2C\\eta^2L + \\eta^4L^2 + 4\\eta^2S^2}\n$$\n$$\n= \\sqrt{(C-\\eta^2L)^2 + 4\\eta^2S^2}\n$$\nSo the eigenvalues are:\n$$\n\\lambda = \\frac{(C+\\eta^{2}L) \\pm \\sqrt{(C-\\eta^{2}L)^{2} + 4\\eta^{2}S^{2}}}{2}\n$$\nSince the matrix $\\mathbf{B}_0$ is positive definite, both eigenvalues are positive. The largest and smallest eigenvalues correspond to the '+' and '-' signs, respectively:\n$$\n\\lambda_{\\max} = \\frac{C+\\eta^{2}L + \\sqrt{(C-\\eta^{2}L)^{2} + 4\\eta^{2}S^{2}}}{2}\n$$\n$$\n\\lambda_{\\min} = \\frac{C+\\eta^{2}L - \\sqrt{(C-\\eta^{2}L)^{2} + 4\\eta^{2}S^{2}}}{2}\n$$\nThe condition number is the ratio of these two eigenvalues:\n$$\n\\kappa_{2}(\\mathbf{B}_{0}) = \\frac{\\lambda_{\\max}}{\\lambda_{\\min}} = \\frac{\\frac{C+\\eta^{2}L + \\sqrt{(C-\\eta^{2}L)^{2} + 4\\eta^{2}S^{2}}}{2}}{\\frac{C+\\eta^{2}L - \\sqrt{(C-\\eta^{2}L)^{2} + 4\\eta^{2}S^{2}}}{2}}\n$$\nCanceling the factor of $1/2$ from the numerator and denominator gives the final expression:\n$$\n\\kappa_{2}(\\mathbf{B}_{0}) = \\frac{C+\\eta^{2}L + \\sqrt{(C-\\eta^{2}L)^{2} + 4\\eta^{2}S^{2}}}{C+\\eta^{2}L - \\sqrt{(C-\\eta^{2}L)^{2} + 4\\eta^{2}S^{2}}}\n$$",
            "answer": "$$\n\\boxed{\\frac{C+\\eta^{2}L + \\sqrt{(C-\\eta^{2}L)^{2} + 4\\eta^{2}S^{2}}}{C+\\eta^{2}L - \\sqrt{(C-\\eta^{2}L)^{2} + 4\\eta^{2}S^{2}}}}\n$$"
        },
        {
            "introduction": "Beyond mathematical correctness and numerical stability, the practical utility of a computational method is determined by its efficiency. For large-scale problems, the choice between PMCHWT and Müller formulations can depend on their respective demands on memory and processing time. This practice provides a framework for modeling and comparing the computational cost of these two methods using a hardware-aware roofline model . By calculating the per-iteration time and memory requirements under various scenarios, you will develop a practical appreciation for how algorithm-hardware interactions and the choice of acceleration techniques dictate the real-world performance of advanced boundary integral methods.",
            "id": "3298535",
            "problem": "You are comparing the per-iteration computational cost of two boundary integral formulations for electromagnetic scattering by a homogeneous dielectric object: the Poggio–Miller–Chang–Harrington–Wu–Tsai (PMCHWT) formulation and the Müller formulation. Both formulations enforce the boundary conditions on tangential fields via surface equivalent electric and magnetic currents, discretized with Rao–Wilton–Glisson basis functions on a fixed mesh.\n\nStarting from the fact that both formulations produce a block operator of size $2N \\times 2N$ acting on the concatenated vector of $N$ electric-current coefficients and $N$ magnetic-current coefficients, the four blocks correspond to combinations of the electric field integral operator and the magnetic field integral operator. Denote the blocks by indices $[0,1,2,3]$ corresponding to $\\left[\\text{TT},\\text{TK},\\text{KT},\\text{KK}\\right]$, each of size $N \\times N$.\n\nYou must model one matrix–vector product (one iteration of a Krylov solver) using a near–far split and a roofline performance model as follows.\n\nFundamental modeling assumptions to be used:\n- Unknowns per current: $N_e = N_m = N$, giving a vector of length $2N$.\n- Near-field interactions:\n    - Each of the four blocks has an average of $z$ nonzero entries per row. Assume all four blocks have the same $z$.\n    - Near-field entries are preassembled and stored in compressed sparse row (CSR) format with:\n        - Complex values of size $b_v = 16$ bytes per entry.\n        - Column indices of size $b_i = 4$ bytes per entry.\n        - Row pointers of size $4$ bytes per row plus one extra pointer per block.\n    - Applying one stored complex entry requires $\\gamma = 8$ floating-point operations (a complex multiply–add).\n    - Bytes moved during apply for near-field per block per iteration equals the sum of reading the complex values and the indices for all stored entries plus reading the row pointer array once.\n- Far-field interactions:\n    - If “acceleration” is enabled, use a Fast Multipole Method-like model:\n        - For PMCHWT, per block floating-point operations is $c_{\\text{far}}^{\\text{PM}} \\cdot N \\cdot \\log_2(N)$ with $c_{\\text{far}}^{\\text{PM}} = 320$.\n        - For Müller, per block floating-point operations is $c_{\\text{far}}^{\\mu} \\cdot N \\cdot \\log_2(N)$ with $c_{\\text{far}}^{\\mu} = 300$.\n        - Auxiliary working memory per block is $m_{\\text{far}} \\cdot N$ with $m_{\\text{far}} = 64$ bytes.\n        - Bytes moved during apply for far-field per block per iteration equals the auxiliary working memory $m_{\\text{far}} \\cdot N$.\n    - If “acceleration” is disabled (dense on-the-fly far field), use:\n        - For PMCHWT, per block floating-point operations is $c_{\\text{dense}}^{\\text{PM}} \\cdot N \\cdot (N - z)$ with $c_{\\text{dense}}^{\\text{PM}} = 90$.\n        - For Müller, per block floating-point operations is $c_{\\text{dense}}^{\\mu} \\cdot N \\cdot (N - z)$ with $c_{\\text{dense}}^{\\mu} = 80$.\n        - Far-field extra memory per block is zero and far-field bytes moved during apply is set to zero.\n- Hardware roofline model:\n    - With peak floating-point rate $\\Phi$ in gigaflops per second and peak memory bandwidth $B$ in gigabytes per second, the time for a component with floating-point work $\\mathcal{F}$ and bytes moved $\\mathcal{M}$ is\n      $$ t = \\max\\left(\\frac{\\mathcal{F}}{\\Phi \\cdot 10^9}, \\frac{\\mathcal{M}}{B \\cdot 10^9}\\right) \\text{ seconds}. $$\n- Time and memory per iteration:\n    - Per iteration time is the sum across the four blocks of the near-field time and the far-field time. Express the final time in milliseconds, rounded to three decimals.\n    - Memory per iteration is the storage required for the near-field CSR data across all four blocks plus the auxiliary far-field working memory across all four blocks if acceleration is enabled (and zero otherwise). Express the final memory in megabytes (base $10^6$), rounded to three decimals.\n- Dominant block:\n    - For each formulation and test case, identify the block index in $\\{0,1,2,3\\}$ with the largest per-block time contribution (near plus far). If there is a tie, return the smallest index.\n\nYour program must implement the model above to compute, for each test case, a list containing:\n- The PMCHWT time per iteration in milliseconds,\n- The Müller time per iteration in milliseconds,\n- The PMCHWT memory per iteration in megabytes,\n- The Müller memory per iteration in megabytes,\n- The PMCHWT dominant block index,\n- The Müller dominant block index,\n- A boolean indicating whether PMCHWT is faster than Müller (true if strictly smaller time).\n\nUse the following test suite, which covers a typical case, a dense/unaccelerated case, a bandwidth-limited case, and a compute-limited case:\n- Test case $1$: $N = 6000$, $z = 14$, acceleration $= \\text{true}$, $\\Phi = 2000$ (gigaflops per second), $B = 200$ (gigabytes per second).\n- Test case $2$: $N = 1000$, $z = 10$, acceleration $= \\text{false}$, $\\Phi = 2000$, $B = 200$.\n- Test case $3$: $N = 20000$, $z = 20$, acceleration $= \\text{true}$, $\\Phi = 3000$, $B = 90$.\n- Test case $4$: $N = 8000$, $z = 8$, acceleration $= \\text{true}$, $\\Phi = 500$, $B = 250$.\n\nAngle units are not involved. No other physical units are needed beyond the specified time in milliseconds and memory in megabytes. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list in the order specified above. For example, a syntactically valid output shape is\n$$ [ [\\dots\\_1], [\\dots\\_2], [\\dots\\_3], [\\dots\\_4] ] $$\nwith all floating-point numbers rounded to three decimals.",
            "solution": "The problem requires creating a computational model to estimate the per-iteration time and memory costs for PMCHWT and Müller formulations. The total cost is the sum of costs for four identical blocks, where each block's cost is a sum of near-field and far-field contributions.\n\n**1. Near-Field Cost (per block):**\nThe near-field matrix is stored in CSR format.\n- Floating-point operations ($\\mathcal{F}_{\\text{near}}$): Each of the $N \\cdot z$ entries requires a complex multiply-add, costing $\\gamma=8$ FLOPs.\n  $\\mathcal{F}_{\\text{near}} = N \\cdot z \\cdot \\gamma = 8Nz$\n- Bytes moved ($\\mathcal{M}_{\\text{near}}$): This is the storage size. It includes values ($b_v=16$), column indices ($b_i=4$), and row pointers ($4$ bytes per row + one extra).\n  $\\mathcal{M}_{\\text{near}} = (N \\cdot z \\cdot b_v) + (N \\cdot z \\cdot b_i) + (N+1) \\cdot 4 = 16Nz + 4Nz + 4(N+1) = 20Nz + 4N + 4$\n- Time ($t_{\\text{near}}$): Calculated using the roofline model.\n  $t_{\\text{near}} = \\max\\left(\\frac{\\mathcal{F}_{\\text{near}}}{\\Phi \\cdot 10^9}, \\frac{\\mathcal{M}_{\\text{near}}}{B \\cdot 10^9}\\right)$\n\n**2. Far-Field Cost (per block):**\nThis depends on whether acceleration is enabled.\n\nCase (a): Acceleration Enabled (FMM-like)\n- Floating-point operations ($\\mathcal{F}_{\\text{far}}$):\n  - PMCHWT: $\\mathcal{F}_{\\text{far, PM}} = c_{\\text{far}}^{\\text{PM}} \\cdot N \\cdot \\log_2(N) = 320 N \\log_2(N)$\n  - Müller: $\\mathcal{F}_{\\text{far, M}} = c_{\\text{far}}^{\\mu} \\cdot N \\cdot \\log_2(N) = 300 N \\log_2(N)$\n- Bytes moved ($\\mathcal{M}_{\\text{far}}$): Equals the auxiliary working memory.\n  $\\mathcal{M}_{\\text{far}} = m_{\\text{far}} \\cdot N = 64N$\n- Time ($t_{\\text{far}}$):\n  - PMCHWT: $t_{\\text{far, PM}} = \\max\\left(\\frac{\\mathcal{F}_{\\text{far, PM}}}{\\Phi \\cdot 10^9}, \\frac{\\mathcal{M}_{\\text{far}}}{B \\cdot 10^9}\\right)$\n  - Müller: $t_{\\text{far, M}} = \\max\\left(\\frac{\\mathcal{F}_{\\text{far, M}}}{\\Phi \\cdot 10^9}, \\frac{\\mathcal{M}_{\\text{far}}}{B \\cdot 10^9}\\right)$\n- Auxiliary Memory: $M_{\\text{aux}} = m_{\\text{far}} \\cdot N = 64N$\n\nCase (b): Acceleration Disabled (Dense)\n- Floating-point operations ($\\mathcal{F}_{\\text{far}}$):\n  - PMCHWT: $\\mathcal{F}_{\\text{far, PM}} = c_{\\text{dense}}^{\\text{PM}} \\cdot N \\cdot (N-z) = 90N(N-z)$\n  - Müller: $\\mathcal{F}_{\\text{far, M}} = c_{\\text{dense}}^{\\mu} \\cdot N \\cdot (N-z) = 80N(N-z)$\n- Bytes moved ($\\mathcal{M}_{\\text{far}}$) is zero.\n- Time ($t_{\\text{far}}$) is purely compute-bound:\n  - PMCHWT: $t_{\\text{far, PM}} = \\frac{\\mathcal{F}_{\\text{far, PM}}}{\\Phi \\cdot 10^9}$\n  - Müller: $t_{\\text{far, M}} = \\frac{\\mathcal{F}_{\\text{far, M}}}{\\Phi \\cdot 10^9}$\n- Auxiliary Memory: $M_{\\text{aux}} = 0$\n\n**3. Total Time and Memory:**\n- Total Time: The time for one iteration is the sum of times for all 4 blocks, converted to milliseconds.\n  $T_{\\text{formulation}} = 4 \\cdot (t_{\\text{near}} + t_{\\text{far, formulation}}) \\cdot 1000$ ms\n- Total Memory: This is the CSR storage for 4 blocks plus the auxiliary memory for 4 blocks, converted to megabytes. Note that memory usage is identical for both formulations under this model.\n  $M_{\\text{total}} = (4 \\cdot \\mathcal{M}_{\\text{near}} + 4 \\cdot M_{\\text{aux}}) / 10^6$ MB\n\n**4. Dominant Block and Comparison:**\n- Dominant Block: Since all four blocks are modeled with identical costs, the per-block time is the same for all. The tie-breaking rule specifies returning the smallest index, which is 0.\n- Comparison: PMCHWT is faster if $T_{\\text{PMCHWT}}  T_{\\text{Müller}}$.\n\nThese equations are implemented in the provided Python script to generate the results for each test case.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n\n    # Define the constants from the problem statement.\n    CONSTANTS = {\n        'b_v': 16, # bytes per complex value\n        'b_i': 4,  # bytes per column index\n        'b_p': 4,  # bytes per row pointer entry\n        'gamma': 8, # FLOPs per complex multiply-add\n        'c_far_pm': 320,\n        'c_far_mu': 300,\n        'm_far': 64, # bytes\n        'c_dense_pm': 90,\n        'c_dense_mu': 80\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, z, acceleration, Phi, B)\n        (6000, 14, True, 2000, 200),\n        (1000, 10, False, 2000, 200),\n        (20000, 20, True, 3000, 90),\n        (8000, 8, True, 500, 250),\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        N, z, acceleration, Phi, B = case\n        result_list = compute_performance(N, z, acceleration, Phi, B, CONSTANTS)\n        \n        # Format the list into a string without spaces\n        formatted_items = []\n        for item in result_list:\n            if isinstance(item, float):\n                formatted_items.append(f\"{item:.3f}\")\n            elif isinstance(item, bool):\n                formatted_items.append(str(item).lower())\n            else:\n                formatted_items.append(str(item))\n        all_results_str.append(f\"[{','.join(formatted_items)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\ndef compute_performance(N, z, acceleration, Phi, B, C):\n    \"\"\"\n    Calculates the performance metrics for a single test case.\n    \"\"\"\n    \n    # Convert Giga units to base units\n    phi_val = Phi * 1e9  # GFLOPs/s to FLOPs/s\n    b_val = B * 1e9    # GB/s to B/s\n\n    # --- Near-Field Cost (per block) ---\n    # FLOPs for near-field apply\n    F_near = N * z * C['gamma']\n    # Bytes for near-field CSR matrix (values, indices, pointers)\n    M_near_bytes = N * z * (C['b_v'] + C['b_i']) + (N + 1) * C['b_p']\n    \n    # Time for near-field apply using roofline model\n    t_near_flops = F_near / phi_val\n    t_near_mem = M_near_bytes / b_val\n    t_near_sec = max(t_near_flops, t_near_mem)\n    \n    # --- Far-Field Cost (per block) ---\n    if acceleration:\n        # FMM-like accelerated model\n        log2_N = np.log2(N)\n        \n        # PMCHWT far-field\n        F_far_pm = C['c_far_pm'] * N * log2_N\n        M_far_bytes = C['m_far'] * N\n        t_far_pm_flops = F_far_pm / phi_val\n        t_far_pm_mem = M_far_bytes / b_val\n        t_far_pm_sec = max(t_far_pm_flops, t_far_pm_mem)\n        \n        # Müller far-field\n        F_far_mu = C['c_far_mu'] * N * log2_N\n        t_far_mu_flops = F_far_mu / phi_val\n        # Bytes moved is the same for both formulations\n        t_far_mu_sec = max(t_far_mu_flops, t_far_pm_mem) # Use t_far_pm_mem as they are identical\n        \n        aux_memory_per_block_bytes = M_far_bytes\n    else:\n        # Dense on-the-fly model\n        far_entries = N - z\n\n        # PMCHWT far-field\n        F_far_pm = C['c_dense_pm'] * N * far_entries\n        t_far_pm_sec = F_far_pm / phi_val\n        \n        # Müller far-field\n        F_far_mu = C['c_dense_mu'] * N * far_entries\n        t_far_mu_sec = F_far_mu / phi_val\n        \n        aux_memory_per_block_bytes = 0\n\n    # --- Total Time per Iteration ---\n    # Total time is for 4 identical blocks\n    total_time_pm_sec = 4 * (t_near_sec + t_far_pm_sec)\n    total_time_mu_sec = 4 * (t_near_sec + t_far_mu_sec)\n    \n    # Convert from seconds to milliseconds\n    total_time_pm_ms = total_time_pm_sec * 1000\n    total_time_mu_ms = total_time_mu_sec * 1000\n    \n    # --- Total Memory per Iteration ---\n    # Memory is the near-field CSR storage plus far-field auxiliary memory\n    total_near_storage_bytes = 4 * M_near_bytes\n    total_far_aux_bytes = 4 * aux_memory_per_block_bytes\n    total_memory_bytes = total_near_storage_bytes + total_far_aux_bytes\n    \n    # Convert from Bytes to Megabytes (1e6)\n    total_memory_mb = total_memory_bytes / 1e6\n\n    # --- Dominant Block ---\n    # Per the problem's simplifying assumptions, all blocks have identical costs.\n    # The tie-breaking rule states to return the smallest index.\n    pm_dominant_block = 0\n    mu_dominant_block = 0\n    \n    # --- Comparison ---\n    # Check for strictly smaller time before rounding\n    is_pmchwt_faster = total_time_pm_sec  total_time_mu_sec\n\n    # --- Assemble final list ---\n    return [\n        total_time_pm_ms,\n        total_time_mu_ms,\n        total_memory_mb,\n        total_memory_mb, # Memory is the same for both formulations\n        pm_dominant_block,\n        mu_dominant_block,\n        is_pmchwt_faster\n    ]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}