{
    "hands_on_practices": [
        {
            "introduction": "理解迭代方法的收敛特性是设计高效求解器的关键。本练习将引导你使用局部傅里叶分析（Local Fourier Analysis, LFA）这一强大工具，来深入剖析经典的逐次超松弛（Successive Over-Relaxation, SOR）法。通过亲手推导最佳松弛参数并预测其在多重网格环境下的误差平滑效果，你将对迭代过程的内部机制及其优化策略有更深刻的认识。",
            "id": "3299116",
            "problem": "在计算电磁学中，考虑一个均匀、无源、一维周期性介质中的静态旋度-旋度方程，该介质具有均匀的磁导率和电介质常数。在网格间距为 $h$ 的均匀 Yee 交错网格上，单个切向电场分量可简化为一个标量方程，其中离散的旋度-旋度算子等于标准的二阶差分算子\n$$\n(A u)_{j} \\;=\\; \\frac{1}{h^{2}}\\left(2 u_{j} - u_{j-1} - u_{j+1}\\right),\n$$\n并周期性地延拓到无限网格。我们希望使用逐次超松弛（SOR）方法，在词典序下求解 $A u = b$，其中松弛参数为 $\\omega > 0$。该方法基于分裂 $A = D - L - U$，其中 $D$ 是 $A$ 的对角部分，$L$ 是严格下三角部分，$U$ 是严格上三角部分。\n\n在无限网格上使用局部傅里叶分析，按以下步骤进行：\n\n1) 对于傅里叶模式 $e^{\\mathrm{i} j \\theta}$，推导 SOR 误差传播算子的傅里叶符号，其中 $\\theta \\in [0,\\pi]$ 是无量纲角频率（角度以弧度为单位）。将相应的放大因子记为 $g_{\\omega}(\\theta)$。\n\n2) 定义高频集为 $\\mathcal{H} = \\{\\theta \\in [\\pi/2, \\pi]\\}$。证明对于 $0  \\omega  2$，最坏情况下的高频放大在 $\\theta = \\pi/2$ 处达到，并将高频平滑因子写为\n$$\n\\sigma(\\omega) \\;=\\; \\max_{\\theta \\in \\mathcal{H}} \\, |g_{\\omega}(\\theta)| \\;=\\; |g_{\\omega}(\\tfrac{\\pi}{2})|.\n$$\n\n3) 确定在 $\\omega > 0$ 上使 $\\sigma(\\omega)$ 最小化的最优松弛参数 $\\omega_{\\star}$，并给出 $\\sigma(\\omega_{\\star})$ 的闭式解。\n\n4) 考虑一个双网格方法，该方法包含一个预平滑和一个后平滑 SOR 步骤，以及一个理想化的粗网格校正，该校正能精确消除所有低频误差分量 $\\theta \\in [0,\\pi/2)$，同时保持高频集 $\\mathcal{H}$ 不变。在此理想化条件下，预测双网格误差缩减因子为\n$$\n\\rho_{\\mathrm{TG}}(\\omega) \\;=\\; \\left(\\sigma(\\omega)\\right)^{2},\n$$\n并在 $\\omega_{\\star}$ 处计算其值。\n\n以包含最优松弛参数 $\\omega_{\\star}$ 和相应的双网格误差缩减因子 $\\rho_{\\mathrm{TG}}(\\omega_{\\star})$ 的数对形式，给出你的最终答案，要求为精确解析形式。最终答案中不要包含单位。如果你选择数值近似，请四舍五入到四位有效数字。",
            "solution": "问题陈述经确认为科学上合理、适定且客观。它描述了迭代多重网格方法的局部傅里叶分析（或冯·诺依曼分析）中的一个标准问题。所有术语均为标准术语，设置也具有一致性。\n\n解题过程遵循问题中概述的四个步骤。\n\n1) SOR 误差传播算子的傅里叶符号推导。\n\n离散算子由下式给出\n$$ (A u)_{j} = \\frac{1}{h^{2}}\\left(2 u_{j} - u_{j-1} - u_{j+1}\\right) $$\n我们考虑缩放后的算子 $A' = h^2 A$，使得 $(A' u)_{j} = 2 u_{j} - u_{j-1} - u_{j+1}$。待求解的系统是 $A'u = h^2 b$。\n算子 $A'$ 可以分裂为 $A' = D' - L' - U'$，其中 $D'$ 是对角部分，$L'$ 是严格下三角部分，$U'$ 是严格上三角部分。在一维词典序（从较小的 $j$ 到较大的 $j$）的背景下：\n- $(D'u)_j = 2u_j$\n- $(L'u)_j = u_{j-1}$\n- $(U'u)_j = u_{j+1}$\n\n用于求解 $A'u=b'$ 的逐次超松弛（SOR）迭代由分裂 $A' = D' - L' - U'$ 和松弛参数 $\\omega > 0$ 定义。在第 $k$ 次迭代时的误差 $e^{(k)} = u^{(k)}-u$ 根据以下方程传播：\n$$ (D' - \\omega L') e^{(k+1)} = ((1-\\omega)D' + \\omega U') e^{(k)} $$\n将此方程写出分量 $j$ 的形式：\n$$ 2 e_j^{(k+1)} - \\omega e_{j-1}^{(k+1)} = 2(1-\\omega) e_j^{(k)} + \\omega e_{j+1}^{(k)} $$\n我们分析误差的单个傅里叶模式的行为，$e_j^{(k)} = (g_{\\omega}(\\theta))^k e^{\\mathrm{i} j \\theta}$，其中 $g_{\\omega}(\\theta)$ 是无量纲角频率 $\\theta$ 的放大因子。将其代入误差传播方程，我们得到：\n$$ g_{\\omega}(\\theta) \\left( 2 e^{\\mathrm{i} j \\theta} - \\omega e^{\\mathrm{i} (j-1) \\theta} \\right) = 2(1-\\omega) e^{\\mathrm{i} j \\theta} + \\omega e^{\\mathrm{i} (j+1) \\theta} $$\n除以 $e^{\\mathrm{i} j \\theta}$（非零）：\n$$ g_{\\omega}(\\theta) \\left( 2 - \\omega e^{-\\mathrm{i} \\theta} \\right) = 2(1-\\omega) + \\omega e^{\\mathrm{i} \\theta} $$\n求解放大因子 $g_{\\omega}(\\theta)$ 得到其傅里叶符号：\n$$ g_{\\omega}(\\theta) = \\frac{2(1-\\omega) + \\omega e^{\\mathrm{i}\\theta}}{2 - \\omega e^{-\\mathrm{i}\\theta}} $$\n\n2) 高频平滑因子 $\\sigma(\\omega)$。\n\n高频集定义为 $\\mathcal{H} = \\{\\theta \\in [\\pi/2, \\pi]\\}$。平滑因子是此集合上的最坏情况（最大）放大因子：$\\sigma(\\omega) = \\max_{\\theta \\in \\mathcal{H}} |g_{\\omega}(\\theta)|$。\n我们来计算 $g_{\\omega}(\\theta)$ 的模的平方：\n$$ |g_{\\omega}(\\theta)|^2 = g_{\\omega}(\\theta) \\overline{g_{\\omega}(\\theta)} = \\frac{2(1-\\omega) + \\omega e^{\\mathrm{i}\\theta}}{2 - \\omega e^{-\\mathrm{i}\\theta}} \\cdot \\frac{2(1-\\omega) + \\omega e^{-\\mathrm{i}\\theta}}{2 - \\omega e^{\\mathrm{i}\\theta}} $$\n分子为：\n$$ N = \\left(2(1-\\omega) + \\omega \\cos\\theta \\right)^2 + (\\omega \\sin\\theta)^2 = 4(1-\\omega)^2 + 4\\omega(1-\\omega)\\cos\\theta + \\omega^2\\cos^2\\theta + \\omega^2\\sin^2\\theta = 4(1-2\\omega+\\omega^2) + 4\\omega(1-\\omega)\\cos\\theta + \\omega^2 = 5\\omega^2 - 8\\omega + 4 + (4\\omega - 4\\omega^2)\\cos\\theta $$\n分母为：\n$$ D = (2 - \\omega\\cos\\theta)^2 + (\\omega \\sin\\theta)^2 = 4 - 4\\omega\\cos\\theta + \\omega^2\\cos^2\\theta + \\omega^2\\sin^2\\theta = \\omega^2 + 4 - 4\\omega\\cos\\theta $$\n令 $f(c) = |g_{\\omega}(\\theta)|^2$，其中 $c = \\cos\\theta$。对于 $\\theta \\in [\\pi/2, \\pi]$，$c$ 位于区间 $[-1, 0]$ 内。\n$$ f(c) = \\frac{5\\omega^2-8\\omega+4 + (4\\omega-4\\omega^2)c}{\\omega^2+4 - 4\\omega c} $$\n为求最大值，我们计算关于 $c$ 的导数：\n$$ f'(c) = \\frac{(4\\omega-4\\omega^2)(\\omega^2+4-4\\omega c) - (5\\omega^2-8\\omega+4 + (4\\omega-4\\omega^2)c)(-4\\omega)}{(\\omega^2+4 - 4\\omega c)^2} $$\n$f'(c)$ 的符号由其分子决定。展开并化简后，包含 $c$ 的项相互抵消，分子变为：\n$$ \\text{Num}' = 4\\omega(8 - 12\\omega + 6\\omega^2 - \\omega^3) = 4\\omega(2-\\omega)^3 $$\n对于 $0  \\omega  2$，我们有 $4\\omega > 0$ 和 $(2-\\omega)^3 > 0$。因此，$f'(c) > 0$。这意味着 $f(c)$ 是 $c$ 的单调递增函数。\n$f(c)$ 在 $c \\in [-1, 0]$ 上的最大值在 $c=0$ 处取得，这对应于 $\\theta = \\pi/2$。\n因此，高频平滑因子为 $\\sigma(\\omega) = |g_{\\omega}(\\pi/2)|$。\n我们在 $\\theta = \\pi/2$ 处计算 $g_{\\omega}(\\theta)$ 的值：\n$$ g_{\\omega}(\\pi/2) = \\frac{2(1-\\omega) + \\omega e^{\\mathrm{i}\\pi/2}}{2 - \\omega e^{-\\mathrm{i}\\pi/2}} = \\frac{2-2\\omega + \\mathrm{i}\\omega}{2 + \\mathrm{i}\\omega} $$\n模的平方为：\n$$ \\sigma(\\omega)^2 = |g_{\\omega}(\\pi/2)|^2 = \\frac{(2-2\\omega)^2 + \\omega^2}{2^2 + \\omega^2} = \\frac{4 - 8\\omega + 4\\omega^2 + \\omega^2}{4+\\omega^2} = \\frac{5\\omega^2 - 8\\omega + 4}{\\omega^2 + 4} $$\n\n3) 最优松弛参数 $\\omega_{\\star}$。\n\n为了找到使 $\\sigma(\\omega)$ 最小化的最优松弛参数 $\\omega_{\\star}$，我们可以最小化 $\\sigma(\\omega)^2$。令 $S(\\omega) = \\sigma(\\omega)^2$。我们计算 $S(\\omega)$ 的导数并令其为零：\n$$ S'(\\omega) = \\frac{(10\\omega - 8)(\\omega^2+4) - (5\\omega^2-8\\omega+4)(2\\omega)}{(\\omega^2 + 4)^2} = 0 $$\n令分子为零，得到：\n$$ 10\\omega^3 - 8\\omega^2 + 40\\omega - 32 - (10\\omega^3 - 16\\omega^2 + 8\\omega) = 0 $$\n$$ 8\\omega^2 + 32\\omega - 32 = 0 \\implies \\omega^2 + 4\\omega - 4 = 0 $$\n求解关于 $\\omega$ 的二次方程：\n$$ \\omega = \\frac{-4 \\pm \\sqrt{16-4(1)(-4)}}{2} = \\frac{-4 \\pm \\sqrt{32}}{2} = \\frac{-4 \\pm 4\\sqrt{2}}{2} = -2 \\pm 2\\sqrt{2} $$\n由于 $\\omega > 0$，我们必须选择正根：\n$$ \\omega_{\\star} = 2\\sqrt{2} - 2 = 2(\\sqrt{2}-1) $$\n接下来，我们求最小平滑因子 $\\sigma(\\omega_{\\star})$。我们使用二次方程中的关系式 $\\omega_{\\star}^2 = 4 - 4\\omega_{\\star}$ 来简化 $S(\\omega_{\\star})$ 的表达式：\n$$ S(\\omega_{\\star}) = \\frac{5\\omega_{\\star}^2 - 8\\omega_{\\star} + 4}{\\omega_{\\star}^2 + 4} = \\frac{5(4-4\\omega_{\\star}) - 8\\omega_{\\star} + 4}{(4-4\\omega_{\\star}) + 4} = \\frac{20 - 20\\omega_{\\star} - 8\\omega_{\\star} + 4}{8 - 4\\omega_{\\star}} = \\frac{24-28\\omega_{\\star}}{8-4\\omega_{\\star}} = \\frac{6-7\\omega_{\\star}}{2-\\omega_{\\star}} $$\n代入 $\\omega_{\\star} = 2\\sqrt{2}-2$：\n$$ S(\\omega_{\\star}) = \\frac{6 - 7(2\\sqrt{2}-2)}{2 - (2\\sqrt{2}-2)} = \\frac{6 - 14\\sqrt{2} + 14}{4 - 2\\sqrt{2}} = \\frac{20 - 14\\sqrt{2}}{4 - 2\\sqrt{2}} = \\frac{10 - 7\\sqrt{2}}{2 - \\sqrt{2}} $$\n将分母有理化：\n$$ S(\\omega_{\\star}) = \\frac{10 - 7\\sqrt{2}}{2 - \\sqrt{2}} \\cdot \\frac{2 + \\sqrt{2}}{2 + \\sqrt{2}} = \\frac{20 + 10\\sqrt{2} - 14\\sqrt{2} - 14}{4-2} = \\frac{6 - 4\\sqrt{2}}{2} = 3 - 2\\sqrt{2} $$\n所以，$\\sigma(\\omega_{\\star})^2 = 3-2\\sqrt{2}$。我们可以认出这是 $(\\sqrt{2}-1)^2$。\n因此，最优平滑因子为 $\\sigma(\\omega_{\\star}) = \\sqrt{3-2\\sqrt{2}} = \\sqrt{(\\sqrt{2}-1)^2} = \\sqrt{2}-1$。\n\n4) 双网格误差缩减因子 $\\rho_{\\mathrm{TG}}(\\omega_{\\star})$。\n\n所述的双网格循环包括一个预平滑步骤、一个理想化的粗网格校正和一个后平滑步骤。预平滑器作用于误差，将每个傅里叶分量乘以 $g_{\\omega}(\\theta)$。理想化的粗网格校正完全消除所有低频误差分量（对于 $\\theta \\in [0, \\pi/2)$），同时保持高频分量（对于 $\\theta \\in \\mathcal{H} = [\\pi/2, \\pi]$）不变。然后，后平滑器作用于剩余的高频误差，再次将每个分量乘以 $g_{\\omega}(\\theta)$。\n因此，低频模式的放大因子为 $0$，而高频模式的放大因子为 $(g_{\\omega}(\\theta))^2$。总的双网格误差缩减因子是所有模式中的最大放大因子：\n$$ \\rho_{\\mathrm{TG}}(\\omega) = \\max_{\\theta \\in [0, \\pi]} |\\text{amplification}(\\theta)| = \\max \\left( \\max_{\\theta \\in [0, \\pi/2)} |0|, \\max_{\\theta \\in [\\pi/2, \\pi]} |(g_{\\omega}(\\theta))^2| \\right) $$\n$$ \\rho_{\\mathrm{TG}}(\\omega) = \\left( \\max_{\\theta \\in [\\pi/2, \\pi]} |g_{\\omega}(\\theta)| \\right)^2 = (\\sigma(\\omega))^2 $$\n这证实了问题陈述中提供的公式。\n我们在最优参数 $\\omega_{\\star}$ 处计算该因子的值：\n$$ \\rho_{\\mathrm{TG}}(\\omega_{\\star}) = (\\sigma(\\omega_{\\star}))^2 $$\n从上一步骤中，我们得到 $\\sigma(\\omega_{\\star})^2 = 3-2\\sqrt{2}$。\n因此，在最优松弛参数下的双网格误差缩减因子是\n$$ \\rho_{\\mathrm{TG}}(\\omega_{\\star}) = 3-2\\sqrt{2} $$\n最终答案是数对 $(\\omega_{\\star}, \\rho_{\\mathrm{TG}}(\\omega_{\\star}))$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2(\\sqrt{2}-1)  3-2\\sqrt{2}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "直接求解器在处理大型稀疏系统时的性能，很大程度上取决于如何最小化填充（fill-in）并有效利用并行计算资源。本练习通过一个具体的小型有限元网格，让你手动构建稀疏矩阵分解过程中的核心数据结构——消去树（elimination tree）。通过分析这个基本结构，你将直观地理解矩阵排序策略如何决定计算成本和并行任务的调度，从而揭开现代多波前求解器（multifrontal solver）的神秘面纱。",
            "id": "3299155",
            "problem": "一个单连通、均匀三维电介质中的静电势场由标量拉普拉斯方程建模，并使用小网格上的线性四面体单元通过有限元法（FEM）进行离散化。组装后的刚度矩阵是对称正定（SPD）的。该四面体网格由两个共享一个三角形面的四面体组成：\n- 四面体 $\\mathrm{T}_1$ 的顶点集为 $\\{1,2,3,4\\}$。\n- 四面体 $\\mathrm{T}_2$ 的顶点集为 $\\{1,2,3,5\\}$。\n\n假设采用标准的节点基函数和组装方式，使得全局刚度矩阵的对称稀疏模式连接了任何一对共同出现在至少一个四面体中的节点。\n\n考虑一个减少填充的置换 $P$，它将未知量排序为 $\\{4,5,1,2,3\\}$（即，新的列/行索引 $1$ 对应旧节点 $4$，新索引 $2$ 对应旧节点 $5$，新索引 $3$ 对应旧节点 $1$，新索引 $4$ 对应旧节点 $2$，新索引 $5$ 对应旧节点 $3$）。使用基于 Cholesky 分解的直接求解器。\n\n任务：\n- 仅使用稀疏 Cholesky 分解及其消去图的基本定义，构建在排序 $P$ 下的置换刚度矩阵的消去树。\n- 现在考虑一个多波前直接求解器，它将每一列视为一个独立的波前任务（无超节点合并）。第 $j$ 列的波前矩阵大小定义为 $f_j = 1 + d_j$，其中 $d_j$ 是在消去第 $j$ 列的瞬间，填充图中第 $j$ 列的更高索引邻居的数量。假设阶数为 $f$ 的波前矩阵的稠密 Cholesky 分解成本模型，即计算功为 $\\frac{1}{3} f^3$ 次浮点运算，并假设每次浮点运算的单位时间。假设有实际上无限的处理器且调度/通信开销可忽略不计，因此最小并行完成时间由消去树关键路径上节点权重 $\\frac{1}{3} f_j^3$ 的总和给出。\n\n对于此网格和排序，此模型所隐含的最小并行完成时间（以浮点运算单位计）的精确值是多少？请以精确的有理数形式提供答案，不带单位。不要四舍五入。",
            "solution": "问题要求在给定特定节点排序和简化并行性能模型的情况下，计算特定稀疏矩阵 Cholesky 分解的最小并行完成时间。求解过程需要对稀疏分解过程进行分步分析。\n\n**步骤 1：构建刚度矩阵的图**\n\n问题陈述，对称刚度矩阵 $A$ 的稀疏模式连接了任何一对共同出现在至少一个四面体中的节点。总节点集为 $V = \\{1, 2, 3, 4, 5\\}$。\n- 四面体 $T_1 = \\{1, 2, 3, 4\\}$ 在其顶点上形成一个团 $K_4$。其边为 $(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)$。\n- 四面体 $T_2 = \\{1, 2, 3, 5\\}$ 在其顶点上形成一个团 $K_4$。其边为 $(1,2), (1,3), (1,5), (2,3), (2,5), (3,5)$。\n\n矩阵的图 $G(A)$ 的顶点为 $V$，边由两个团的边的并集构成。每个节点 $i$ 的邻居集合（邻接表），表示为 $\\mathrm{Adj}_G(i)$，如下：\n- $\\mathrm{Adj}_G(1) = \\{2, 3, 4, 5\\}$\n- $\\mathrm{Adj}_G(2) = \\{1, 3, 4, 5\\}$\n- $\\mathrm{Adj}_G(3) = \\{1, 2, 4, 5\\}$\n- $\\mathrm{Adj}_G(4) = \\{1, 2, 3\\}$\n- $\\mathrm{Adj}_G(5) = \\{1, 2, 3\\}$\n\n**步骤 2：确定给定排序下的填充图**\n\n置换 $P$ 指定了节点的消去顺序：$\\{4, 5, 1, 2, 3\\}$。为清晰起见，我们用撇号表示新索引：$1' \\to 4$, $2' \\to 5$, $3' \\to 1$, $4' \\to 2$, $5' \\to 3$。我们需要找到通过对置换矩阵 $A_P = PAP^T$ 进行符号分解得到的填充图 $G^+$。\n\n填充图 $G^+$ 包含 $G(A_P)$ 的原始边加上“填充”边。如果在消去节点 $k$ 之前，$(k, i)$ 和 $(k, j)$ 是图中的边，但 $(i, j)$ 不是，则在消去节点 $k$ 的过程中会添加一条填充边 $(i, j)$。这等价于陈述一个被消去节点的所有编号更大的邻居形成一个团。\n\n让我们按照新顺序模拟消去过程：\n1.  **消去节点 $1'$（原节点 $4$）：** 节点 $4$ 的邻居是 $\\{1, 2, 3\\}$，对应于新索引 $\\{3', 4', 5'\\}$。在原始图 $G$ 中，这三个节点形成一个团（它们都同时在 $T_1$ 和 $T_2$ 中）。因此，没有添加新边。\n2.  **消去节点 $2'$（原节点 $5$）：** 节点 $5$ 的邻居是 $\\{1, 2, 3\\}$，对应于新索引 $\\{3', 4', 5'\\}$。和之前一样，这些节点已经形成一个团。没有发生填充。\n3.  **消去节点 $3'$（原节点 $1$）：** 在此阶段，剩余的图由节点 $\\{1, 2, 3\\}$（新索引 $\\{3', 4', 5'\\}$）上的团构成。$3'$ 的更高索引邻居是 $\\{4', 5'\\}$。它们已经连接。没有发生填充。\n4.  **消去节点 $4'$（原节点 $2$）：** 唯一剩余的更高索引邻居是 $5'$，因此无法形成新边。\n\n由于在任何步骤都没有添加边，填充图 $G^+$ 与原始图 $G(A)$（根据置换重新标记节点后）相同。$G^+ = G(A)$。\n\n**步骤 3：构建消去树**\n\n消去树 $T$ 是在新排序 $\\{1', 2', 3', 4', 5'\\}$ 的节点上定义的。节点 $j$ 的父节点是填充图 $G^+$ 中 $j$ 的邻居中索引大于 $j$ 且最小的那个。\n$$ \\mathrm{parent}(j) = \\min \\{ k \\mid k > j \\text{ and } (j, k) \\text{ is an edge in } G^+ \\} $$\n\n使用新索引和 $G^+$ 中的邻接关系：\n-   **节点 $1'$（旧 4）：** 邻居是 $\\{3', 4', 5'\\}$。它们的索引都大于 $1'$。\n    $\\mathrm{parent}(1') = \\min\\{3', 4', 5'\\} = 3'$。\n-   **节点 $2'$（旧 5）：** 邻居是 $\\{3', 4', 5'\\}$。它们的索引都大于 $2'$。\n    $\\mathrm{parent}(2') = \\min\\{3', 4', 5'\\} = 3'$。\n-   **节点 $3'$（旧 1）：** 更高索引的邻居是 $\\{4', 5'\\}$。\n    $\\mathrm{parent}(3') = \\min\\{4', 5'\\} = 4'$。\n-   **节点 $4'$（旧 2）：** 唯一更高索引的邻居是 $\\{5'\\}$。\n    $\\mathrm{parent}(4') = 5'$。\n-   **节点 $5'$（旧 3）：** 这是索引最高的节点，因此它是树的根，没有父节点。\n\n消去树的结构是：节点 $1'$ 和 $2'$ 是 $3'$ 的子节点；$3'$ 是 $4'$ 的子节点；$4'$ 是 $5'$ 的子节点。\n\n**步骤 4：计算每个节点的计算功**\n\n消去第 $j$ 列的计算功（成本）由 $W_j = \\frac{1}{3} f_j^3$ 给出，其中 $f_j = 1 + d_j$。量 $d_j$ 是 $G^+$ 中节点 $j$ 的索引大于 $j$ 的邻居数量。\n\n-   **节点 $j=1'$：** $G^+$ 中更高索引的邻居是 $\\{3', 4', 5'\\}$。\n    $d_{1'} = 3$，因此 $f_{1'} = 1+3=4$。\n    $W_{1'} = \\frac{1}{3} (4^3) = \\frac{64}{3}$。\n-   **节点 $j=2'$：** $G^+$ 中更高索引的邻居是 $\\{3', 4', 5'\\}$。\n    $d_{2'} = 3$，因此 $f_{2'} = 1+3=4$。\n    $W_{2'} = \\frac{1}{3} (4^3) = \\frac{64}{3}$。\n-   **节点 $j=3'$：** $G^+$ 中更高索引的邻居是 $\\{4', 5'\\}$。\n    $d_{3'} = 2$，因此 $f_{3'} = 1+2=3$。\n    $W_{3'} = \\frac{1}{3} (3^3) = \\frac{27}{3} = 9$。\n-   **节点 $j=4'$：** $G^+$ 中更高索引的邻居是 $\\{5'\\}$。\n    $d_{4'} = 1$，因此 $f_{4'} = 1+1=2$。\n    $W_{4'} = \\frac{1}{3} (2^3) = \\frac{8}{3}$。\n-   **节点 $j=5'$：** 没有更高索引的邻居。\n    $d_{5'} = 0$，因此 $f_{5'} = 1+0=1$。\n    $W_{5'} = \\frac{1}{3} (1^3) = \\frac{1}{3}$。\n\n**步骤 5：确定关键路径和最小并行时间**\n\n在处理器无限的情况下，一个节点上的工作只有在其消去树中所有子节点的工作都完成后才能开始。最小并行完成时间是沿关键路径的计算功成本 $W_j$ 的总和，关键路径是从任何叶节点到树根的、由成本 $W_j$ 加权的最长路径。\n\n消去树有两个叶节点，$1'$ 和 $2'$。这给出了两条到根节点 $5'$ 的路径：\n1.  路径 A: $1' \\to 3' \\to 4' \\to 5'$\n2.  路径 B: $2' \\to 3' \\to 4' \\to 5'$\n\n让我们计算每条路径的总加权长度：\n-   路径 A 的长度 = $W_{1'} + W_{3'} + W_{4'} + W_{5'}$\n    $= \\frac{64}{3} + 9 + \\frac{8}{3} + \\frac{1}{3}$\n    $= \\frac{64}{3} + \\frac{27}{3} + \\frac{8}{3} + \\frac{1}{3}$\n    $= \\frac{64 + 27 + 8 + 1}{3} = \\frac{100}{3}$。\n-   路径 B 的长度 = $W_{2'} + W_{3'} + W_{4'} + W_{5'}$\n    $= \\frac{64}{3} + 9 + \\frac{8}{3} + \\frac{1}{3}$\n    $= \\frac{100}{3}$。\n\n两条路径的长度相同。关键路径长度，即最小并行完成时间，是 $\\frac{100}{3}$。",
            "answer": "$$\\boxed{\\frac{100}{3}}$$"
        },
        {
            "introduction": "在现代科学计算中，平衡计算速度与数值精度是一个核心挑战。本练习将向你介绍一种前沿技术——混合精度迭代精化法（mixed-precision iterative refinement），它巧妙地结合了直接法与迭代法的优点。你将通过一个实际的编码任务，学习如何利用快速的低精度直接分解作为预条件子，来加速高精度的迭代求解过程，最终为真实的电磁散射问题构建出兼具高效率与高精度的求解方案。",
            "id": "3299108",
            "problem": "考虑二维空间中，半径为 $a$ 的光滑完美导电圆柱体对横磁场的经典频域散射问题。在时谐依赖关系 $e^{\\mathrm{i} \\omega t}$ 下，Maxwell方程组简化为关于平面外电场的标量Helmholtz方程，其在圆柱边界上的边界积分表示导出一个稠密线性系统。使用周期性梯形Nyström离散化方法，在圆上取 $N$ 个均匀分布的节点，权重为 $w = 2 \\pi a / N$，一个带有稳定项的简单单层离散化方法产生以下复线性系统\n$$\nA x = b,\n$$\n其中 $A \\in \\mathbb{C}^{N \\times N}$ 的元素为\n$$\nA_{ij} = \n\\begin{cases}\nw \\, G\\!\\left(\\left\\| r_i - r_j \\right\\|\\right),  i \\neq j, \\\\\nw \\, G\\!\\left(s_{\\mathrm{avg}}\\right) + \\beta,  i = j,\n\\end{cases}\n$$\n其中 $r_j = \\left(a \\cos \\theta_j, a \\sin \\theta_j\\right)$，$\\theta_j = 2 \\pi j / N$，$s_{\\mathrm{avg}} = 2 \\pi a / N$，以及二维自由空间Green函数\n$$\nG(\\rho) = \\frac{\\mathrm{i}}{4} H_0^{(1)}\\!\\left(k_c \\rho\\right), \\quad k_c = k \\left(1 + \\mathrm{i} \\alpha\\right),\n$$\n其中 $H_0^{(1)}$ 是第一类零阶Hankel函数，$k$ 是以 $\\mathrm{m}^{-1}$ 为单位的实波数，$\\alpha \\ge 0$ 是一个小的无量纲吸收参数，用于避免离散对角线中出现非物理的奇异行为。右端项表示在边界上计算的入射平面波，\n$$\nb_i = \\exp\\!\\left(\\mathrm{i} \\, k_c \\, d_x \\, x_i\\right),\n$$\n其中 $x_i$ 是 $r_i$ 的x坐标，$d_x = 1$ 是单位传播方向的x分量。稳定参数 $\\beta  0$ 是一个加到对角线上的小的无量纲实数，用于模拟组合场效应并抑制近零空间分量。\n\n你需要实现混合精度迭代求精来求解双精度的 $A x = b$，使用 $A$ 的单精度复数LU分解作为右预条件子。具体来说，令 $\\epsilon_{32}$ 表示单精度的机器精度，$\\epsilon_{64}$ 表示双精度的机器精度。该算法必须：\n- 以双精度（64位复数）构造 $A$ 和 $b$。\n- 计算 $A$ 的单精度（32位复数）带部分主元分解的LU分解，并将其用作预条件子。\n- 将 $x^{(0)}$ 初始化为双精度零向量。\n- 对于迭代 $m = 0, 1, 2, \\dots$，计算双精度残差\n$$\nr^{(m)} = b - A x^{(m)}.\n$$\n- 将 $r^{(m)}$ 转换为单精度，使用单精度LU因子求解单精度修正量 $\\Delta x^{(m)}$，\n$$\nA \\, \\Delta x^{(m)} \\approx r^{(m)},\n$$\n然后将 $\\Delta x^{(m)}$ 转换回双精度。\n- 以双精度更新 $x^{(m+1)} = x^{(m)} + \\Delta x^{(m)}$。\n- 当双精度相对残差\n$$\n\\eta^{(m)} = \\frac{\\left\\| r^{(m)} \\right\\|_2}{\\left\\| b \\right\\|_2}\n$$\n低于目标容差 $\\tau$ 或达到最大迭代次数 $M$ 时终止。目标容差为 $\\tau = 10^{-11}$，最大迭代次数为 $M = 50$。\n\n从频域Maxwell方程、标量Helmholtz方程以及Green函数 $G(\\rho)$ 的定义等基本原理出发，推导上述离散系统结构和混合精度迭代求精过程。然后，实现一个完整的、可运行的程序，该程序根据指定的参数构造 $A$ 和 $b$，执行迭代求精，并为每个测试用例返回最终达到的相对残差范数 $\\eta^{(m_\\star)}$，其中 $m_\\star$ 是该用例的最终迭代索引。\n\n所有物理参数必须使用指定的单位：圆柱半径 $a$ 的单位是 $\\mathrm{m}$，波数 $k$ 的单位是 $\\mathrm{m}^{-1}$。最终的相对残差范数是无量纲的。角度以弧度为单位。你的算法必须使用向量 $2$-范数。\n\n设计一个包含以下参数集 $(N, k, \\alpha, \\beta, a)$ 的测试套件：\n- 用例1（顺利路径）：$(64, 20.0, 0.010, 0.10, 1.0)$。\n- 用例2（低频边缘情况）：$(16, 0.50, 0.020, 0.20, 1.0)$。\n- 用例3（更高频率，更大N）：$(128, 40.0, 0.005, 0.05, 1.0)$。\n- 用例4（温和稳定化压力）：$(64, 10.0, 0.005, 0.02, 1.0)$。\n\n对于每个用例，计算混合精度迭代求精所达到的最终相对残差范数 $\\eta^{(m_\\star)}$。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个浮点数都以恰好 $8$ 位有效数字的科学记数法格式化，并按照上述用例的顺序排列，例如 $\\left[\\text{res}_1,\\text{res}_2,\\text{res}_3,\\text{res}_4\\right]$。",
            "solution": "基本原理始于角频率为 $\\omega$ 的时谐场的Maxwell方程组，在二维空间中的横磁极化条件下，该方程组简化为标量Helmholtz方程\n$$\n\\left(\\nabla^2 + k^2\\right) u(\\mathbf{r}) = 0,\n$$\n在散射体外部，其中 $k = \\omega / c$ 是以 $\\mathrm{m}^{-1}$ 为单位的自由空间波数，$u$ 是平面外的电场分量。对于完美导电散射体，$u$ 在散射体边界 $\\Gamma$ 上满足适当的边界条件，散射场可以通过使用二维Helmholtz算子的自由空间Green函数 $G(\\rho)$ 的边界积分公式来表示。散射场的单层势为\n$$\nu^{\\mathrm{scat}}(\\mathbf{r}) = \\int_{\\Gamma} G\\!\\left(\\left\\| \\mathbf{r} - \\mathbf{r}' \\right\\|\\right) \\sigma(\\mathbf{r}') \\, \\mathrm{d}s(\\mathbf{r}'),\n$$\n其中 $\\sigma$ 是未知的表面密度。自由空间Green函数是\n$$\nG(\\rho) = \\frac{\\mathrm{i}}{4} H_0^{(1)}(k \\rho),\n$$\n其中 $H_0^{(1)}$ 是零阶第一类Hankel函数。为避免非物理奇异性并模拟材料损耗，可以通过将 $k$ 替换为复波数 $k_c = k \\left(1 + \\mathrm{i} \\alpha\\right)$ (其中 $\\alpha \\ge 0$ 为无量纲) 来引入一个小的吸收。在边界上，将积分表示与一个稳定化的对角项（模拟组合场效应）进行配置，得到离散的稠密系统\n$$\nA x = b,\n$$\n其中未知向量 $x$ 近似为边界节点上 $\\sigma$ 的采样值，$b$ 编码了入射场的边界条件。对于半径为 $a$ 的圆形边界，其参数化为 $r(\\theta) = \\left(a \\cos \\theta, a \\sin \\theta\\right)$，其中 $\\theta \\in [0, 2\\pi)$，使用具有 $N$ 个均匀节点 $\\theta_j = 2 \\pi j / N$、权重 $w = 2 \\pi a / N$ 和稳定化参数 $\\beta  0$ 的周期性梯形Nyström离散化方法，可得到\n$$\nA_{ij} = \n\\begin{cases}\nw \\, \\dfrac{\\mathrm{i}}{4} H_0^{(1)}\\!\\left(k_c \\left\\| r_i - r_j \\right\\|\\right),  i \\neq j, \\\\\nw \\, \\dfrac{\\mathrm{i}}{4} H_0^{(1)}\\!\\left(k_c s_{\\mathrm{avg}}\\right) + \\beta,  i = j,\n\\end{cases}\n$$\n其中 $s_{\\mathrm{avg}} = 2 \\pi a / N$。这种对角线建模用一个面板长度上的局部平均值替换了弱奇异的自相互作用，并增加了 $\\beta$ 以改善条件数。对于沿x轴入射的平面波，右端项为 $b_i = \\exp\\!\\left(\\mathrm{i} \\, k_c \\, x_i\\right)$，其中 $x_i = a \\cos \\theta_i$。\n\n我们现在推导混合精度迭代求精算法。目标是在仅以单精度计算分解的情况下，获得满足严格容差 $\\tau$ 的双精度解。设 $A \\in \\mathbb{C}^{N \\times N}$ 和 $b \\in \\mathbb{C}^N$ 以双精度形式构成。计算带部分主元分解的单精度LU分解：\n$$\nP A = L U,\n$$\n其中排列矩阵 $P$、下三角矩阵 $L$ 和上三角矩阵 $U$ 由标准例程隐式存储，全部采用单精度算术。初始化双精度迭代向量 $x^{(0)} = 0$。求精迭代步骤为\n$$\nr^{(m)} = b - A x^{(m)}, \\quad \\Delta x^{(m)} \\approx A^{-1} r^{(m)},\n$$\n其中 $A^{-1} r^{(m)}$ 的近似是通过使用单精度LU因子求解三角系统 $U y = L^{-1} P r^{(m)}$ 来实现的。具体地，将 $r^{(m)}$ 从双精度转换为单精度，以单精度进行前向和后向代换，然后将得到的 $\\Delta x^{(m)}$ 转换回双精度。更新\n$$\nx^{(m+1)} = x^{(m)} + \\Delta x^{(m)}.\n$$\n每次更新后，计算双精度相对残差范数\n$$\n\\eta^{(m)} = \\frac{\\left\\| r^{(m)} \\right\\|_2}{\\left\\| b \\right\\|_2}.\n$$\n当 $\\eta^{(m)} \\le \\tau$ 或 $m$ 达到最大值 $M$ 时停止。\n\n迭代求精的基本原理是后向误差校正：残差 $r^{(m)}$ 编码了在双精度下测量的 $x^{(m)}$ 中的累积误差。使用低精度预条件子求解 $\\Delta x^{(m)}$ 可以减小前向误差，前提是条件数 $\\kappa_2(A)$ 和单精度机器ε $\\epsilon_{32}$ 近似满足 $\\kappa_2(A) \\epsilon_{32}  1$；这确保了单精度三角求解能产生足够精确的修正量，从而使双精度残差几何级数般减小，直到遇到双精度的舍入极限。吸收参数 $\\alpha$ 和稳定化参数 $\\beta$ 减小了 $\\kappa_2(A)$，从而提高了迭代求精收敛到严格容差的可能性。\n\n算法设计细节：\n- 构造 $r_j = \\left(a \\cos \\theta_j, a \\sin \\theta_j\\right)$，其中 $\\theta_j = 2 \\pi j / N$。圆上成对距离 $\\left\\| r_i - r_j \\right\\|$ 为 $\\sqrt{a^2 + a^2 - 2 a^2 \\cos(\\theta_i - \\theta_j)} = a \\sqrt{2 - 2 \\cos(\\theta_i - \\theta_j)} = 2 a \\left| \\sin\\!\\left(\\frac{\\theta_i - \\theta_j}{2}\\right) \\right|$，为保证鲁棒性，我们进行数值计算。\n- 使用 $G(\\rho) = \\dfrac{\\mathrm{i}}{4} H_0^{(1)}\\!\\left(k_c \\rho\\right)$ (其中 $k_c = k \\left(1 + \\mathrm{i} \\alpha\\right)$)以双精度形式构造 $A$，并用 $w \\, G(s_{\\mathrm{avg}}) + \\beta$ 设置对角线元素。\n- 用 $b_i = \\exp\\!\\left(\\mathrm{i} \\, k_c \\, x_i\\right)$ (其中 $x_i = a \\cos \\theta_i$) 构造 $b$。\n- 通过标准例程计算单精度LU因子 $(L, U, P)$，并在所有求精步骤中重复使用它们。\n- 迭代直至 $\\eta^{(m)} \\le \\tau$ 或 $m = M$，并记录最终的 $\\eta^{(m_\\star)}$。\n\n测试套件探索了不同的情况：\n- 用例1使用中等的 $N$ 和 $k$，以及小的吸收和稳定化参数，代表了一个良态情景。\n- 用例2探测小 $N$ 的低频情况，可能测试由 $\\alpha$ 和 $\\beta$ 缓解的近奇异行为。\n- 用例3使用更高频率和更大的 $N$，对条件数和稠密组装的计算成本都构成压力。\n- 用例4减少了稳定化参数，挑战了求精过程的鲁棒性。\n\n程序将构建这些用例，执行迭代求精，并以单行输出最终的相对残差范数，结果为方括号内由逗号分隔的科学记数法浮点数，每个浮点数有恰好8位有效数字，按用例顺序排列。结果是无量纲的，所有角度都以弧度为单位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import hankel1\nfrom scipy.linalg import lu_factor, lu_solve\n\ndef assemble_system(N, k, alpha, beta, a):\n    \"\"\"\n    Assemble the dense boundary integral system matrix A and RHS b\n    for a circular cylinder of radius a in 2D using a stabilized\n    single-layer discretization with periodic trapezoidal rule.\n\n    Parameters:\n        N (int): number of boundary nodes\n        k (float): real wavenumber (1/m)\n        alpha (float): absorption parameter (dimensionless)\n        beta (float): diagonal stabilization parameter (dimensionless)\n        a (float): cylinder radius (m)\n\n    Returns:\n        A64 (np.ndarray): complex128 system matrix (N x N)\n        b64 (np.ndarray): complex128 right-hand side (N,)\n    \"\"\"\n    # Discretization points on the circle\n    j = np.arange(N, dtype=np.float64)\n    theta = 2.0 * np.pi * j / float(N)\n    # Boundary points r_j = (a cos theta_j, a sin theta_j)\n    x = a * np.cos(theta)\n    y = a * np.sin(theta)\n\n    # Complex wavenumber with small absorption\n    kc = complex(k, k * alpha)  # k * (1 + i*alpha) == k + i*k*alpha\n\n    # Pairwise distances on a circle: robust computation\n    # Using broadcasting to compute all pairwise differences\n    theta_i = theta.reshape(-1, 1)\n    theta_j = theta.reshape(1, -1)\n    dtheta = theta_i - theta_j\n    # rho_ij = 2 a |sin((theta_i - theta_j)/2)|\n    rho = 2.0 * a * np.abs(np.sin(0.5 * dtheta))\n\n    # Weight for trapezoidal rule\n    w = 2.0 * np.pi * a / float(N)\n    # Average panel length for diagonal replacement\n    s_avg = w\n\n    # Assemble A in complex128\n    A64 = np.empty((N, N), dtype=np.complex128)\n    # Off-diagonal: w * G(rho_ij)\n    # Green's function G(rho) = i/4 * H0^(1)(kc * rho)\n    # Compute hankel1 for all entries; we will fix diagonal separately\n    # Note: hankel1 expects real argument, but kc*rho may be complex.\n    # We compute H0^(1) over complex arguments via series: not available.\n    # Instead, use that for small absorption alpha, kc is complex, so hankel1\n    # with complex argument is handled by SciPy for complex input.\n    # Prepare complex argument\n    z = kc * rho\n    # Compute Hankel of order 0, first kind\n    H0 = hankel1(0, z)\n    G = 1j * 0.25 * H0\n    A64[:] = w * G\n\n    # Diagonal: replace with w * G(s_avg) + beta\n    H0_diag = hankel1(0, kc * s_avg)\n    G_diag = 1j * 0.25 * H0_diag\n    np.fill_diagonal(A64, w * G_diag + beta)\n\n    # Right-hand side: incident plane wave along +x: b_i = exp(i * kc * x_i)\n    b64 = np.exp(1j * kc * x)\n\n    return A64, b64\n\ndef mixed_precision_iterative_refinement(A64, b64, max_iters=50, tol=1e-11):\n    \"\"\"\n    Perform mixed-precision iterative refinement using single-precision\n    LU factorization as a preconditioner to solve A x = b in double precision.\n\n    Parameters:\n        A64 (np.ndarray): complex128 system matrix\n        b64 (np.ndarray): complex128 right-hand side\n        max_iters (int): maximum number of refinement iterations\n        tol (float): target relative residual tolerance\n\n    Returns:\n        rel_res (float): final achieved relative residual norm\n    \"\"\"\n    # Single-precision copy and LU factorization\n    A32 = A64.astype(np.complex64)\n    try:\n        lu32, piv = lu_factor(A32)\n    except Exception:\n        # In case factorization fails due to precision issues, upcast to float64 (but this violates mixed precision).\n        # To adhere to the problem, we keep single-precision and propagate failure via large residual.\n        return float(\"inf\")\n\n    # Initialize x in double precision\n    x64 = np.zeros_like(b64, dtype=np.complex128)\n\n    # Precompute norm of b\n    norm_b = np.linalg.norm(b64)\n    if norm_b == 0.0:\n        return 0.0\n\n    # Iterate\n    rel_res = np.inf\n    for _ in range(max_iters):\n        # Residual in double precision\n        r64 = b64 - A64 @ x64\n        norm_r = np.linalg.norm(r64)\n        rel_res = norm_r / norm_b\n\n        if rel_res = tol:\n            break\n\n        # Solve for correction in single precision using LU\n        r32 = r64.astype(np.complex64)\n        dx32 = lu_solve((lu32, piv), r32)\n        dx64 = dx32.astype(np.complex128)\n\n        # Update\n        x64 += dx64\n\n    # Return final double-precision relative residual\n    # Recompute final residual to be consistent\n    r64 = b64 - A64 @ x64\n    rel_res = np.linalg.norm(r64) / norm_b\n    return float(rel_res.real)  # residual norm is real\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, k, alpha, beta, a)\n    test_cases = [\n        (64, 20.0, 0.010, 0.10, 1.0),  # Case 1\n        (16, 0.50, 0.020, 0.20, 1.0),  # Case 2\n        (128, 40.0, 0.005, 0.05, 1.0), # Case 3\n        (64, 10.0, 0.005, 0.02, 1.0),  # Case 4\n    ]\n\n    results = []\n    for (N, k, alpha, beta, a) in test_cases:\n        A64, b64 = assemble_system(N, k, alpha, beta, a)\n        rel_res = mixed_precision_iterative_refinement(A64, b64, max_iters=50, tol=1e-11)\n        results.append(rel_res)\n\n    # Format floats in scientific notation with exactly 8 significant digits.\n    formatted = [f\"{val:.8e}\" for val in results]\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}