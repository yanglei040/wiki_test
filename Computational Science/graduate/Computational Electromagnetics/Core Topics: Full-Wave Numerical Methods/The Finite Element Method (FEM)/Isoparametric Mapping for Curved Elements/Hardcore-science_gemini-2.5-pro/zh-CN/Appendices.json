{
    "hands_on_practices": [
        {
            "introduction": "使用曲边单元的基础是等参映射。第一个练习提供了一个直接的、动手的计算，将参考四面体中的一个点映射到其物理对应点。通过执行这个基本的变换，您将对形函数和节点坐标如何协同定义复杂几何形状有一个具体的理解。",
            "id": "3320941",
            "problem": "考虑一个在计算电磁学中，用于求解光滑导电边界附近的麦克斯韦方程组的弯曲二次等参四面体单元，该单元在有限元法（FEM）中使用。从具有局部坐标 $(\\xi,\\eta,\\zeta)$ 的参考四面体到物理空间的等参映射由使用节点形函数的 Lagrange 插值定义。设重心坐标为 $L_1 = \\xi$、$L_2 = \\eta$、$L_3 = \\zeta$ 和 $L_4 = 1 - \\xi - \\eta - \\zeta$，二次四面体形函数为标准的 $10$ 节点 Lagrange 多项式：\n$$\nN_1 = L_1(2L_1 - 1),\\quad\nN_2 = L_2(2L_2 - 1),\\quad\nN_3 = L_3(2L_3 - 1),\\quad\nN_4 = L_4(2L_4 - 1),\n$$\n$$\nN_5 = 4L_1L_2,\\quad\nN_6 = 4L_2L_3,\\quad\nN_7 = 4L_3L_1,\\quad\nN_8 = 4L_1L_4,\\quad\nN_9 = 4L_2L_4,\\quad\nN_{10} = 4L_3L_4.\n$$\n物理坐标映射为\n$$\n\\mathbf{x}(\\xi,\\eta,\\zeta) = \\sum_{i=1}^{10} N_i(\\xi,\\eta,\\zeta)\\,\\mathbf{x}_i,\n$$\n其中 $\\{\\mathbf{x}_i\\}_{i=1}^{10}$ 是弯曲单元的物理节点坐标。顶点为\n$$\n\\mathbf{x}_1 = (0,0,0)\\,\\text{m},\\quad\n\\mathbf{x}_2 = (1,0,0)\\,\\text{m},\\quad\n\\mathbf{x}_3 = (0,1,0)\\,\\text{m},\\quad\n\\mathbf{x}_4 = (0,0,1)\\,\\text{m},\n$$\n边中节点为\n$$\n\\mathbf{x}_5 = \\left(\\frac{1}{2},0,\\frac{1}{8}\\right)\\,\\text{m},\\quad\n\\mathbf{x}_6 = \\left(\\frac{1}{2},\\frac{1}{2},\\frac{1}{8}\\right)\\,\\text{m},\\quad\n\\mathbf{x}_7 = \\left(0,\\frac{1}{2},\\frac{1}{8}\\right)\\,\\text{m},\n$$\n$$\n\\mathbf{x}_8 = \\left(0,0,\\frac{1}{2}\\right)\\,\\text{m},\\quad\n\\mathbf{x}_9 = \\left(\\frac{1}{2},0,\\frac{1}{2}\\right)\\,\\text{m},\\quad\n\\mathbf{x}_{10} = \\left(0,\\frac{1}{2},\\frac{1}{2}\\right)\\,\\text{m}.\n$$\n这些位于面 $1$-$2$-$3$ 上的边中节点位置代表了一个光滑的向外凸起（弯曲边界），而连接到节点 $4$ 的边则保持为直线。\n\n计算在参数点 $(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$ 处的物理坐标向量 $\\mathbf{x}$。将 $\\mathbf{x}$ 的三个分量以米为单位表示。使用精确值，无需四舍五入。然后，根据边界曲率保真度来解释结果，并与在相同参数点使用线性（$4$ 节点）四面体映射所得到的结果进行定性比较。",
            "solution": "该问题要求在一个二次等参四面体单元内，计算特定局部参数点 $(\\xi,\\eta,\\zeta)$ 处的物理坐标 $\\mathbf{x} = (x,y,z)$，并随后进行定性分析，将结果与线性单元近似进行比较。\n\n### 步骤 1：问题验证\n问题陈述为等参映射计算提供了一套完整且一致的给定条件。\n- **给定条件**：\n    - 局部坐标：$(\\xi, \\eta, \\zeta)$。\n    - 重心坐标：$L_1 = \\xi$，$L_2 = \\eta$，$L_3 = \\zeta$，$L_4 = 1 - \\xi - \\eta - \\zeta$。\n    - 二次形函数 $N_i$，其中 $i=1, \\dots, 10$。\n    - 等参映射公式：$\\mathbf{x}(\\xi,\\eta,\\zeta) = \\sum_{i=1}^{10} N_i(\\xi,\\eta,\\zeta)\\,\\mathbf{x}_i$。\n    - 节点坐标 $\\{\\mathbf{x}_i\\}_{i=1}^{10}$。\n    - 用于求值的参数点：$(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$。\n- **验证**：\n    - 该问题在有限元法（FEM）中有**科学依据**，这是一种在计算科学与工程中标准且成熟的数值技术。\n    - 所提供的形函数是用于二次四面体的标准 10 节点 Lagrange 多项式。\n    - 节点坐标定义明确，构成了一个特定的弯曲几何形状。对于面 $1-2-3$（位于平面 $z=0$ 上），其边中节点位于 $z = 1/8  0$ 处，将其描述为“向外凸起”略有误述；它描述的是一个向四面体体积内部的*向内*凸起（假设内部是 $L_4  0$ 的区域）。然而，这种轻微的描述不准确性不影响该设定的数学有效性，因为节点坐标明确地定义了该几何形状。\n    - 该问题是**适定的**：所有必要信息均已提供，且任务导向一个唯一、有意义的解。\n    - 语言是**客观**且精确的。\n\n- **结论**：该问题是有效的。\n\n### 步骤 2：物理坐标计算\n\n第一步是计算在给定参数点 $(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$ 处的重心坐标 $L_i$。\n$$\nL_1 = \\xi = \\frac{1}{4}\n$$\n$$\nL_2 = \\eta = \\frac{1}{4}\n$$\n$$\nL_3 = \\zeta = \\frac{1}{4}\n$$\n$$\nL_4 = 1 - \\xi - \\eta - \\zeta = 1 - \\frac{1}{4} - \\frac{1}{4} - \\frac{1}{4} = \\frac{1}{4}\n$$\n该求值点是参考四面体的重心。\n\n接下来，我们在此点计算 10 个二次形函数 $N_i$ 的值。\n对于顶点节点（$i=1,2,3,4$）：\n$$\nN_i = L_i(2L_i - 1) = \\frac{1}{4}\\left(2\\left(\\frac{1}{4}\\right) - 1\\right) = \\frac{1}{4}\\left(\\frac{1}{2} - 1\\right) = \\frac{1}{4}\\left(-\\frac{1}{2}\\right) = -\\frac{1}{8}\n$$\n所以，$N_1 = N_2 = N_3 = N_4 = -\\frac{1}{8}$。\n\n对于边中节点（$i=5, \\dots, 10$）：\n一般形式为 $N_{ij} = 4L_iL_j$。\n$$\nN_5 = 4L_1L_2 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_6 = 4L_2L_3 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_7 = 4L_3L_1 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_8 = 4L_1L_4 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_9 = 4L_2L_4 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_{10} = 4L_3L_4 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n作为一致性检验，形函数之和必须为 1：$\\sum_{i=1}^{10} N_i = 4\\left(-\\frac{1}{8}\\right) + 6\\left(\\frac{1}{4}\\right) = -\\frac{1}{2} + \\frac{3}{2} = 1$。这些值是正确的。\n\n最后，我们计算物理坐标向量 $\\mathbf{x} = \\sum_{i=1}^{10} N_i \\mathbf{x}_i$。设 $\\mathbf{x} = (x,y,z)$。我们分别计算每个分量。\n节点坐标为：\n$\\mathbf{x}_1 = (0,0,0)$, $\\mathbf{x}_2 = (1,0,0)$, $\\mathbf{x}_3 = (0,1,0)$, $\\mathbf{x}_4 = (0,0,1)$。\n$\\mathbf{x}_5 = (\\frac{1}{2},0,\\frac{1}{8})$, $\\mathbf{x}_6 = (\\frac{1}{2},\\frac{1}{2},\\frac{1}{8})$, $\\mathbf{x}_7 = (0,\\frac{1}{2},\\frac{1}{8})$。\n$\\mathbf{x}_8 = (0,0,\\frac{1}{2})$, $\\mathbf{x}_9 = (\\frac{1}{2},0,\\frac{1}{2})$, $\\mathbf{x}_{10} = (0,\\frac{1}{2},\\frac{1}{2})$。\n\n对于 $x$ 分量：\n$$\nx = \\sum_{i=1}^{10} N_i x_i = N_2 x_2 + N_5 x_5 + N_6 x_6 + N_9 x_9\n$$\n$$\nx = \\left(-\\frac{1}{8}\\right)(1) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right)\n$$\n$$\nx = -\\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} = \\frac{2}{8} = \\frac{1}{4}\n$$\n\n对于 $y$ 分量：\n$$\ny = \\sum_{i=1}^{10} N_i y_i = N_3 y_3 + N_6 y_6 + N_7 y_7 + N_{10} y_{10}\n$$\n$$\ny = \\left(-\\frac{1}{8}\\right)(1) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right)\n$$\n$$\ny = -\\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} = \\frac{2}{8} = \\frac{1}{4}\n$$\n\n对于 $z$ 分量：\n$$\nz = \\sum_{i=1}^{10} N_i z_i = N_4 z_4 + N_5 z_5 + N_6 z_6 + N_7 z_7 + N_8 z_8 + N_9 z_9 + N_{10} z_{10}\n$$\n$$\nz = \\left(-\\frac{1}{8}\\right)(1) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{8}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{8}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{8}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right)\n$$\n$$\nz = -\\frac{1}{8} + 3\\left(\\frac{1}{32}\\right) + 3\\left(\\frac{1}{8}\\right) = -\\frac{1}{8} + \\frac{3}{32} + \\frac{3}{8}\n$$\n$$\nz = \\frac{-4 + 3 + 12}{32} = \\frac{11}{32}\n$$\n物理坐标向量为 $\\mathbf{x} = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{11}{32}\\right)$ 米。\n\n### 步骤 3：定性解释\n\n为了解释此结果，我们将其与从线性（$4$ 节点）四面体映射获得的坐标进行比较。对于线性单元，映射仅由顶点定义：\n$$\n\\mathbf{x}_{\\text{lin}}(\\xi,\\eta,\\zeta) = \\sum_{i=1}^{4} L_i(\\xi,\\eta,\\zeta)\\,\\mathbf{x}_i\n$$\n在相同的参数点 $(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$ 处，其中 $L_1 = L_2 = L_3 = L_4 = \\frac{1}{4}$：\n$$\n\\mathbf{x}_{\\text{lin}} = \\frac{1}{4}\\mathbf{x}_1 + \\frac{1}{4}\\mathbf{x}_2 + \\frac{1}{4}\\mathbf{x}_3 + \\frac{1}{4}\\mathbf{x}_4\n$$\n$$\n\\mathbf{x}_{\\text{lin}} = \\frac{1}{4}\\left[(0,0,0) + (1,0,0) + (0,1,0) + (0,0,1)\\right] = \\frac{1}{4}(1,1,1) = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{1}{4}\\right)\n$$\n线性映射简单地得出了四个顶点的物理重心。\n\n**比较与保真度**：\n-   **线性单元**：线性单元生成具有直边和平坦面的物理单元。它将参考四面体的重心映射到顶点的物理重心，即 $\\mathbf{x}_{\\text{lin}} = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{8}{32}\\right)$。这构成了几何形状的一阶或分段线性近似。如果实际边界是弯曲的，线性单元只能将其表示为平坦小面的集合，导致引入几何误差的“阶梯式”近似。\n\n-   **二次单元**：二次单元使用边中节点来定义更高阶的弯曲几何。得到的坐标是 $\\mathbf{x}_{\\text{quad}} = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{11}{32}\\right)$。$x$ 和 $y$ 分量与线性情况相同，但 $z$ 分量不同：$z_{\\text{quad}} = \\frac{11}{32}$ 对比 $z_{\\text{lin}} = \\frac{8}{32}$。位移 $\\Delta z = \\frac{3}{32}$ 是边中节点从其直边位置偏移的直接结果。具体来说，位于面 $z=0$ 上的边中节点 $\\mathbf{x}_5, \\mathbf{x}_6, \\mathbf{x}_7$ 被赋予了 $\\frac{1}{8}$ 的正 $z$ 分量，从而创建了一个凸入单元体积的曲面。\n\n-   **结论**：二次等参单元提供了更高的边界曲率保真度。它允许有限元网格平滑且精确地贴合弯曲边界，这对于计算电磁学问题至关重要，因为在这些问题中，导电表面上的边界条件必须被精确施加。线性单元的几何不准确性可能导致计算出的场、表面电流和散射参数出现显著误差，而二次单元模拟曲率的能力极大地提高了求解的精度。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{4}  \\frac{1}{4}  \\frac{11}{32}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "虽然等参映射使我们能够模拟弯曲边界，但生成的单元质量对仿真精度至关重要。这个计算练习深入探讨了如何通过偏斜度、纵横比和雅可比行列式等度量来量化单元质量。您将通过编程方式研究几何畸变与场插值和数值积分精度下降之间的直接关系。",
            "id": "3320978",
            "problem": "考虑一个二维等参二次四边形单元，该单元有九个节点，定义在坐标为 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ 的参考正方形上。从参考正方形到物理单元的等参映射是使用在三节点集合 $\\{\\xi=-1,0,1\\}\\times\\{\\eta=-1,0,1\\}$ 上的张量积二次 Lagrange 基构建的，并且每个测试用例都给定了物理节点坐标 $\\{\\mathbf{x}_i\\}_{i=1}^{9}$。映射的雅可比矩阵 $\\mathbf{J}(\\xi,\\eta)$ 由物理坐标相对于 $(\\xi,\\eta)$ 的偏导数定义，其行列式为 $\\det \\mathbf{J}(\\xi,\\eta)$。设解析标量场为 $f(x,y)=\\sin(\\pi x)\\cos(\\pi y)$，视为无量纲。\n\n从等参映射、度量张量和高斯求积法则的基本定义出发，实现一个程序，为每个测试用例计算以下畸变度量和精度度量：\n\n1. 平均偏斜度 $\\overline{s}$：对于每个采样点 $(\\xi,\\eta)$，令 $\\mathbf{a}=\\partial\\mathbf{x}/\\partial\\xi$ 和 $\\mathbf{b}=\\partial\\mathbf{x}/\\partial\\eta$ 为 $\\mathbf{J}$ 的列向量。将局部偏斜度定义为 $s=\\left|\\frac{\\mathbf{a}\\cdot\\mathbf{b}}{\\|\\mathbf{a}\\|\\|\\mathbf{b}\\|}\\right|$。将 $\\overline{s}$ 计算为在一个 $n_s\\times n_s$ 点的内部采样网格上 $s$ 的算术平均值，其中 $n_s$ 设为 $7$。角度通过余弦函数隐式地以弧度度量。\n\n2. 平均纵横比 $\\overline{r}$：在每个采样点，计算 $\\mathbf{J}$ 的奇异值 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$，并定义 $r=\\sigma_{\\max}/\\sigma_{\\min}$。将 $\\overline{r}$ 计算为在同一样本网格上 $r$ 的算术平均值。\n\n3. 最小雅可比行列式 $\\min_{\\text{samples}} \\det \\mathbf{J}$：在采样网格上评估 $\\det \\mathbf{J}$ 并报告其在采样点上的最小值（不取绝对值）。\n\n4. 场插值 $L^2$-误差：使用与几何映射相同的二次 Lagrange 基，形成等参插值 $f_h(\\xi,\\eta)=\\sum_{i=1}^{9}N_i(\\xi,\\eta) f(\\mathbf{x}_i)$，其中 $N_i$ 是形函数，$\\mathbf{x}_i$ 是物理节点坐标。计算插值误差在物理单元上的 $L^2$-范数，\n$$\n\\|f-f_h\\|_{L^2(\\Omega_e)}=\\left(\\int_{\\Omega_e} (f-f_h)^2 \\, d\\Omega\\right)^{1/2},\n$$\n通过变换到参考域并使用 $q_h=7$ 阶的张量积高斯求积来近似积分，其中使用绝对值 $\\left|\\det \\mathbf{J}\\right|$作为映射下的测度因子。\n\n5. 积分精度：使用 $q_\\ell=3$ 阶的张量积高斯求积计算积分 $I=\\int_{\\Omega_e} f \\, d\\Omega$，并使用 $q_h=7$ 阶计算参考值 $I_{\\text{ref}}$，两者都使用绝对值 $\\left|\\det \\mathbf{J}\\right|$。报告绝对积分误差 $|I-I_{\\text{ref}}|$。\n\n通过在每个轴上的 $(-1,1)$ 区间内均匀放置 $n_s$ 个点，其位置为 $\\xi_i=-1+\\frac{2i}{n_s+1}$ 和 $\\eta_j=-1+\\frac{2j}{n_s+1}$ (对于 $i,j\\in\\{1,\\dots,n_s\\}$)，来使用不包括边界的采样点。\n\n通过计算所有量并将每个测试用例的数值返回，来关联畸变度量与精度度量。较大的偏斜度和纵横比通常表示较高的畸变，并预期与较大的插值和积分误差相关。\n\n测试套件（每个测试用例提供九个物理节点，按行主序对应于 $(\\xi,\\eta)\\in\\{(-1,-1),(0,-1),(1,-1),(-1,0),(0,0),(1,0),(-1,1),(0,1),(1,1)\\}$）：\n\n- 测试用例 1（轻度弯曲，近乎矩形）：\n$\\left[\n(0.0,0.0),\\,\n(1.0,-0.03),\\,\n(2.0,0.05),\\,\n(-0.02,0.5),\\,\n(1.02,0.52),\\,\n(2.03,0.5),\\,\n(0.0,1.0),\\,\n(1.0,1.03),\\,\n(2.0,1.05)\n\\right]$。\n\n- 测试用例 2（偏斜且中度弯曲）：\n$\\left[\n(0.0,0.0),\\,\n(1.0,0.10),\\,\n(2.0,0.3),\\,\n(0.03,0.42),\\,\n(1.07,0.57),\\,\n(2.08,0.68),\\,\n(0.1,0.8),\\,\n(1.12,0.97),\\,\n(2.1,1.1)\n\\right]$。\n\n- 测试用例 3（细长且显著弯曲）：\n$\\left[\n(0.0,0.0),\\,\n(1.5,0.06),\\,\n(3.0,0.2),\\,\n(0.2,0.22),\\,\n(1.62,0.27),\\,\n(3.15,0.33),\\,\n(0.5,0.4),\\,\n(1.9,0.47),\\,\n(3.2,0.5)\n\\right]$。\n\n您的程序应生成单行输出，其中包含三个测试用例的结果，形式为方括号括起来的逗号分隔列表，其中每个测试用例的结果本身是一个包含五个浮点数的列表，顺序为 $\\left[\\overline{s},\\overline{r},\\min \\det \\mathbf{J},\\|f-f_h\\|_{L^2(\\Omega_e)},|I-I_{\\text{ref}}|\\right]$。例如，输出格式为 $\\left[ [a_1,a_2,a_3,a_4,a_5], [b_1,b_2,b_3,b_4,b_5], [c_1,c_2,c_3,c_4,c_5] \\right]$，所有条目均以十进制数表示。",
            "solution": "该问题要求计算一个二维九节点等参二次四边形单元的若干畸变度量和精度度量。分析过程涉及有限元方法的概念，包括等参映射、使用高斯求积的数值积分以及误差估计。详细步骤如下所述，从基本定义开始。\n\n### 1. 等参格式\n\n该方法的核心是等参映射，它使用同一组基函数（形函数）来定义单元的几何形状并对单元上的场进行插值。\n\n#### 1.1. 参考单元与形函数\n参考单元是计算域中的一个正方形，定义为 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$。对于一个九节点二次单元，节点位于每个轴上点集 $\\{-1, 0, 1\\}$ 的张量积处。\n\n首先，我们为变量 $\\zeta \\in [-1, 1]$ 定义一维二次 Lagrange 基函数 $L_k(\\zeta)$，节点位于 $\\zeta \\in \\{-1, 0, 1\\}$。\n设节点位置为 $\\zeta_1 = -1$、$\\zeta_2 = 0$ 和 $\\zeta_3 = 1$。基函数为：\n- $L_1(\\zeta) = \\frac{(\\zeta - \\zeta_2)(\\zeta - \\zeta_3)}{(\\zeta_1 - \\zeta_2)(\\zeta_1 - \\zeta_3)} = \\frac{\\zeta(\\zeta - 1)}{(-1)(-2)} = \\frac{1}{2}\\zeta(\\zeta - 1)$\n- $L_2(\\zeta) = \\frac{(\\zeta - \\zeta_1)(\\zeta - \\zeta_3)}{(\\zeta_2 - \\zeta_1)(\\zeta_2 - \\zeta_3)} = \\frac{(\\zeta + 1)(\\zeta - 1)}{(1)(-1)} = 1 - \\zeta^2$\n- $L_3(\\zeta) = \\frac{(\\zeta - \\zeta_1)(\\zeta - \\zeta_2)}{(\\zeta_3 - \\zeta_1)(\\zeta_3 - \\zeta_2)} = \\frac{(\\zeta + 1)\\zeta}{(2)(1)} = \\frac{1}{2}\\zeta(\\zeta + 1)$\n\n九个节点的二维形函数 $N_i(\\xi, \\eta)$ 是由这些一维函数通过张量积构成的。给定指定的行主序节点排序，如果我们有 $\\xi$ 和 $\\eta$ 方向的节点索引 $j,k \\in \\{1,2,3\\}$，则全局节点索引 $i$（从1到9）和相应的形函数由 $N_i(\\xi, \\eta) = L_j(\\xi) L_k(\\eta)$ 给出。例如，对于在 $(\\xi, \\eta)=(0,0)$ 的节点 $i=5$，其形函数为 $N_5(\\xi, \\eta) = L_2(\\xi)L_2(\\eta) = (1-\\xi^2)(1-\\eta^2)$。\n\n#### 1.2. 几何映射与场插值\n从参考坐标 $(\\xi, \\eta)$ 到物理坐标 $\\mathbf{x} = (x, y)$ 的等参映射由下式给出：\n$$ \\mathbf{x}(\\xi, \\eta) = \\sum_{i=1}^{9} N_i(\\xi, \\eta) \\mathbf{x}_i $$\n其中 $\\mathbf{x}_i = (x_i, y_i)$ 是第 $i$ 个物理节点的坐标。\n\n类似地，标量场 $f(x, y)$ 使用相同的形函数在单元上插值：\n$$ f_h(\\xi, \\eta) = \\sum_{i=1}^{9} N_i(\\xi, \\eta) f(\\mathbf{x}_i) $$\n其中 $f_h$ 是 $f$ 的近似，而 $f(\\mathbf{x}_i)$ 是真值场在物理节点 $i$ 处的值。\n\n### 2. 雅可比矩阵与畸变度量\n\n映射的局部畸变由雅可比矩阵 $\\mathbf{J}$ 表征，它关联了参考坐标中的无穷小变化与物理坐标中的无穷小变化。\n\n#### 2.1. 雅可比矩阵\n雅可比矩阵定义为：\n$$ \\mathbf{J}(\\xi, \\eta) = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} $$\n偏导数通过对映射方程求导得出：\n$$ \\frac{\\partial \\mathbf{x}}{\\partial \\xi} = \\sum_{i=1}^{9} \\frac{\\partial N_i}{\\partial \\xi} \\mathbf{x}_i \\quad \\text{and} \\quad \\frac{\\partial \\mathbf{x}}{\\partial \\eta} = \\sum_{i=1}^{9} \\frac{\\partial N_i}{\\partial \\eta} \\mathbf{x}_i $$\n这需要形函数的导数，例如 $\\frac{\\partial N_i}{\\partial \\xi} = \\frac{d L_j(\\xi)}{d \\xi} L_k(\\eta)$。\n\n#### 2.2. 畸变度量\n问题要求在内部的 $n_s \\times n_s$ 采样网格上（其中 $n_s=7$）评估三个度量。\n1.  **平均偏斜度 $\\overline{s}$**：$\\mathbf{J}$ 的列向量 $\\mathbf{a} = \\frac{\\partial \\mathbf{x}}{\\partial \\xi}$ 和 $\\mathbf{b} = \\frac{\\partial \\mathbf{x}}{\\partial \\eta}$ 代表映射后的基向量。偏斜度度量了与正交性的偏差。局部偏斜度 $s$ 是它们之间夹角的余弦绝对值：\n    $$ s(\\xi, \\eta) = \\left| \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{\\|\\mathbf{a}\\| \\|\\mathbf{b}\\|} \\right| $$\n    平均偏斜度 $\\overline{s}$ 是 $s$ 在采样网格上的算术平均值。值为 $0$ 是理想的（正交的），而接近 $1$ 的值表示严重畸变。\n\n2.  **平均纵横比 $\\overline{r}$**：该度量衡量单元的拉伸。它定义为雅可比矩阵的最大奇异值 $\\sigma_{\\max}$ 与最小奇异值 $\\sigma_{\\min}$ 之比：\n    $$ r(\\xi, \\eta) = \\frac{\\sigma_{\\max}(\\mathbf{J})}{\\sigma_{\\min}(\\mathbf{J})} $$\n    平均纵横比 $\\overline{r}$ 是 $r$ 在采样网格上的算术平均值。理想单元的纵横比为 $1$。\n\n3.  **最小雅可比行列式 $\\min \\det \\mathbf{J}$**：雅可比行列式 $\\det \\mathbf{J}$ 是物理域中面积与参考域中面积的局部比率。非正的行列式表示局部无效（折叠）的映射。我们找出 $\\det \\mathbf{J}$ 在采样网格上的最小值。\n\n### 3. 精度度量\n\n畸变会影响场插值和数值积分的精度。\n\n#### 3.1. 场插值的 $L^2$-误差\n用 $f_h$ 近似场 $f$ 的误差通过它们差的 $L^2$-范数在物理单元 $\\Omega_e$ 上度量：\n$$ \\|f - f_h\\|_{L^2(\\Omega_e)} = \\left( \\int_{\\Omega_e} (f(\\mathbf{x}) - f_h(\\mathbf{x}))^2 \\, d\\Omega \\right)^{1/2} $$\n为了计算这个值，我们将积分变换到参考单元上：\n$$ \\int_{\\Omega_e} g(\\mathbf{x}) \\, d\\Omega = \\int_{-1}^{1} \\int_{-1}^{1} g(\\mathbf{x}(\\xi, \\eta)) |\\det \\mathbf{J}(\\xi, \\eta)| \\, d\\xi \\, d\\eta $$\n将此应用于 $g = (f-f_h)^2$，误差范数变为：\n$$ \\|f - f_h\\|_{L^2(\\Omega_e)} = \\left( \\int_{-1}^{1} \\int_{-1}^{1} (f(\\mathbf{x}(\\xi, \\eta)) - f_h(\\xi, \\eta))^2 |\\det \\mathbf{J}(\\xi, \\eta)| \\, d\\xi \\, d\\eta \\right)^{1/2} $$\n该积分使用 $q_h \\times q_h$ 阶张量积高斯求积法则来近似，其中 $q_h=7$。二维高斯求积的公式为：\n$$ \\int_{-1}^{1}\\int_{-1}^{1} G(\\xi, \\eta) \\, d\\xi \\, d\\eta \\approx \\sum_{j=1}^{q} \\sum_{k=1}^{q} w_j w_k G(\\xi_j, \\eta_k) $$\n其中 $(\\xi_j, \\eta_k)$ 是求积点，$(w_j, w_k)$ 是对应的求积权重。\n\n#### 3.2. 积分精度\n我们通过比较用两种不同求积阶数计算的场 $f$ 的积分来评估单元畸变如何影响数值积分的精度。积分为：\n$$ I = \\int_{\\Omega_e} f(\\mathbf{x}) \\, d\\Omega = \\int_{-1}^{1} \\int_{-1}^{1} f(\\mathbf{x}(\\xi, \\eta)) |\\det \\mathbf{J}(\\xi, \\eta)| \\, d\\xi \\, d\\eta $$\n- 一个低精度积分 $I$ 使用低阶求积法则（$q_\\ell=3$）计算。\n- 一个高精度参考积分 $I_{\\text{ref}}$ 使用高阶法则（$q_h=7$）计算。\n绝对积分误差即为 $|I - I_{\\text{ref}}|$。\n\n### 4. 计算算法\n对于每个测试用例（一组9个物理节点坐标 $\\mathbf{x}_i$）：\n1.  定义 $n_s \\times n_s = 7 \\times 7$ 的内部采样网格。\n2.  为平均偏斜度、平均纵横比初始化累加器，并为最小雅可比行列式初始化一个变量。\n3.  遍历采样网格中的每个点 $(\\xi, \\eta)$：\n    a. 计算雅可比矩阵 $\\mathbf{J}(\\xi, \\eta)$。\n    b. 计算局部偏斜度 $s$、纵横比 $r$ 和 $\\det \\mathbf{J}$。\n    c. 更新累加器和最小行列式。\n4.  计算最终的平均值 $\\overline{s}$ 和 $\\overline{r}$。\n5.  设置 $q_h=7$ 点高斯求积法则。\n6.  在9个物理节点中的每一个节点上计算解析场 $f(\\mathbf{x}_i)$ 的值。\n7.  通过在每个求积点上累加贡献来计算 $L^2$ 插值误差积分。对结果取平方根。\n8.  使用 $q_h=7$ 求积法则计算参考积分 $I_{\\text{ref}}$。\n9.  设置 $q_\\ell=3$ 点高斯求积法则。\n10. 使用 $q_\\ell=3$ 法则计算低阶积分 $I$。\n11. 计算绝对积分误差 $|I - I_{\\text{ref}}|$。\n12. 收集五个计算值：$\\overline{s}$、$\\overline{r}$、$\\min \\det \\mathbf{J}$、$\\|f-f_h\\|_{L^2(\\Omega_e)}$ 和 $|I-I_{\\text{ref}}|$。\n\n对每个测试用例重复此过程，得出所要求的数值结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef one_d_basis(z: float) - np.ndarray:\n    \"\"\"Computes the 1D quadratic Lagrange basis functions at a point z.\"\"\"\n    l1 = 0.5 * z * (z - 1.0)\n    l2 = 1.0 - z**2\n    l3 = 0.5 * z * (z + 1.0)\n    return np.array([l1, l2, l3])\n\ndef one_d_basis_deriv(z: float) - np.ndarray:\n    \"\"\"Computes the derivatives of the 1D quadratic Lagrange basis functions.\"\"\"\n    dl1 = z - 0.5\n    dl2 = -2.0 * z\n    dl3 = z + 0.5\n    return np.array([dl1, dl2, dl3])\n\ndef shape_functions(xi: float, eta: float) - np.ndarray:\n    \"\"\"Computes the 9-node quadratic shape functions at (xi, eta).\"\"\"\n    l_xi = one_d_basis(xi)\n    l_eta = one_d_basis(eta)\n    n_vec = np.zeros(9)\n    for i in range(3):  # eta node index\n        for j in range(3):  # xi node index\n            n_vec[i * 3 + j] = l_xi[j] * l_eta[i]\n    return n_vec\n\ndef shape_derivatives(xi: float, eta: float) - tuple[np.ndarray, np.ndarray]:\n    \"\"\"Computes derivatives of shape functions w.r.t. xi and eta.\"\"\"\n    l_xi = one_d_basis(xi)\n    dl_xi = one_d_basis_deriv(xi)\n    l_eta = one_d_basis(eta)\n    dl_eta = one_d_basis_deriv(eta)\n    \n    dn_dxi = np.zeros(9)\n    dn_deta = np.zeros(9)\n    \n    for i in range(3):\n        for j in range(3):\n            k = i * 3 + j\n            dn_dxi[k] = dl_xi[j] * l_eta[i]\n            dn_deta[k] = l_xi[j] * dl_eta[i]\n            \n    return dn_dxi, dn_deta\n\ndef jacobian(xi: float, eta: float, physical_nodes: np.ndarray) - np.ndarray:\n    \"\"\"Computes the Jacobian matrix of the mapping at (xi, eta).\"\"\"\n    dn_dxi, dn_deta = shape_derivatives(xi, eta)\n    \n    # J is a 2x2 matrix\n    # J[0,0] = dN_dxi . x_coords, J[1,0] = dN_dxi . y_coords\n    # J[0,1] = dN_deta . x_coords, J[1,1] = dN_deta . y_coords\n    \n    j_matrix = np.zeros((2, 2))\n    j_matrix[:, 0] = np.dot(dn_dxi, physical_nodes)   # d(x,y)/dxi\n    j_matrix[:, 1] = np.dot(dn_deta, physical_nodes) # d(x,y)/deta\n    \n    return j_matrix\n\ndef f_analytic(x: float, y: float) - float:\n    \"\"\"The analytic scalar field.\"\"\"\n    return np.sin(np.pi * x) * np.cos(np.pi * y)\n\ndef calculate_all_metrics(physical_nodes: np.ndarray) - list[float]:\n    \"\"\"\n    Computes all requiredd distortion and accuracy metrics for a given element.\n    \"\"\"\n    n_s = 7\n    q_h = 7\n    q_l = 3\n\n    # 1. Compute distortion metrics\n    s_vals, r_vals, det_j_vals = [], [], []\n    sample_points_1d = -1.0 + 2.0 * (np.arange(n_s) + 1.0) / (n_s + 1.0)\n\n    for eta_s in sample_points_1d:\n        for xi_s in sample_points_1d:\n            j_mat = jacobian(xi_s, eta_s, physical_nodes)\n            a, b = j_mat[:, 0], j_mat[:, 1]\n\n            # Skewness\n            norm_a = np.linalg.norm(a)\n            norm_b = np.linalg.norm(b)\n            if norm_a  1e-12 and norm_b  1e-12:\n                cos_theta = np.dot(a, b) / (norm_a * norm_b)\n                s_vals.append(np.abs(cos_theta))\n            else: # Should not happen for valid elements\n                s_vals.append(0.0)\n\n            # Aspect ratio from singular values\n            _, s_svd, _ = np.linalg.svd(j_mat)\n            if s_svd.min()  1e-12:\n                r_vals.append(s_svd.max() / s_svd.min())\n            else: # Folded element\n                r_vals.append(np.inf)\n\n            # Jacobian determinant\n            det_j_vals.append(np.linalg.det(j_mat))\n\n    s_mean = np.mean(s_vals)\n    r_mean = np.mean(r_vals)\n    min_det_j = np.min(det_j_vals)\n    \n    # 2. Compute L^2 interpolation error\n    xi_h, w_h = np.polynomial.legendre.leggauss(q_h)\n    f_at_nodes = f_analytic(physical_nodes[:, 0], physical_nodes[:, 1])\n\n    error_integral_sum = 0.0\n    for w_eta, eta_q in zip(w_h, xi_h):\n        for w_xi, xi_q in zip(w_h, xi_h):\n            n_vec = shape_functions(xi_q, eta_q)\n            f_h = np.dot(n_vec, f_at_nodes)\n            \n            x_mapped, y_mapped = np.dot(n_vec, physical_nodes)\n            f_true = f_analytic(x_mapped, y_mapped)\n            \n            det_j = np.linalg.det(jacobian(xi_q, eta_q, physical_nodes))\n            \n            error_integral_sum += (f_true - f_h)**2 * np.abs(det_j) * w_xi * w_eta\n    \n    l2_error = np.sqrt(error_integral_sum)\n    \n    # 3. Compute integration accuracy\n    # I_ref (high order, q_h=7)\n    i_ref = 0.0\n    for w_eta, eta_q in zip(w_h, xi_h):\n        for w_xi, xi_q in zip(w_h, xi_h):\n            n_vec = shape_functions(xi_q, eta_q)\n            x_mapped, y_mapped = np.dot(n_vec, physical_nodes)\n            f_true = f_analytic(x_mapped, y_mapped)\n            det_j = np.linalg.det(jacobian(xi_q, eta_q, physical_nodes))\n            i_ref += f_true * np.abs(det_j) * w_xi * w_eta\n\n    # I (low order, q_l=3)\n    xi_l, w_l = np.polynomial.legendre.leggauss(q_l)\n    i_low = 0.0\n    for w_eta, eta_q in zip(w_l, xi_l):\n        for w_xi, xi_q in zip(w_l, xi_l):\n            n_vec = shape_functions(xi_q, eta_q)\n            x_mapped, y_mapped = np.dot(n_vec, physical_nodes)\n            f_true = f_analytic(x_mapped, y_mapped)\n            det_j = np.linalg.det(jacobian(xi_q, eta_q, physical_nodes))\n            i_low += f_true * np.abs(det_j) * w_xi * w_eta\n            \n    int_error = np.abs(i_low - i_ref)\n    \n    return [s_mean, r_mean, min_det_j, l2_error, int_error]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        [(0.0, 0.0), (1.0, -0.03), (2.0, 0.05),\n         (-0.02, 0.5), (1.02, 0.52), (2.03, 0.5),\n         (0.0, 1.0), (1.0, 1.03), (2.0, 1.05)],\n        # Test Case 2\n        [(0.0, 0.0), (1.0, 0.10), (2.0, 0.3),\n         (0.03, 0.42), (1.07, 0.57), (2.08, 0.68),\n         (0.1, 0.8), (1.12, 0.97), (2.1, 1.1)],\n        # Test Case 3\n        [(0.0, 0.0), (1.5, 0.06), (3.0, 0.2),\n         (0.2, 0.22), (1.62, 0.27), (3.15, 0.33),\n         (0.5, 0.4), (1.9, 0.47), (3.2, 0.5)]\n    ]\n\n    all_results = []\n    for case_nodes in test_cases:\n        physical_nodes_arr = np.array(case_nodes)\n        metrics = calculate_all_metrics(physical_nodes_arr)\n        all_results.append(metrics)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在计算电磁学中，几何映射必须与用于表示诸如 $\\mathbf{E}$ 场和 $\\mathbf{H}$ 场等矢量场的基函数的正确变换相辅相成。这个高级练习将指导您实现 Nédélec 基函数的协变 Piola 变换，这对于满足麦克斯韦方程组至关重要。通过验证跨共享曲面的切向连续性，您将证实 $\\mathbf{H}(\\mathrm{curl})$ 协调单元的一个基本属性。",
            "id": "3320946",
            "problem": "您得到的任务是在计算电磁学中，在一个弯曲的四面体单元上构建映射的 Nédélec 第一类边基函数，并验证它们在两个二次等参四面体之间共享的弯曲面上切向连续性。分析必须从约束函数空间的基础电磁学定律开始：麦克斯韦-法拉第电磁感应定律。其积分形式表明，对于任何具有边界曲线的足够光滑的曲面，\n$$\n\\oint_{\\partial S} \\mathbf{E} \\cdot \\mathbf{t}\\, ds \\;=\\; -\\frac{d}{dt}\\iint_S \\mathbf{B} \\cdot \\mathbf{n}\\, dS,\n$$\n其中 $\\mathbf{E}$ 是电场，$\\mathbf{B}$ 是磁通量密度，$\\mathbf{t}$ 是沿曲线的单位切向量，$\\mathbf{n}$ 是曲面的单位法向量。在电磁场的有限元方法中，为了保持电场沿边的切向线积分，需要使用符合特定函数空间的基函数。这个空间是具有平方可积旋度的平方可积向量场构成的 Sobolev 空间，记为 $\\mathbf{H}(\\mathrm{curl})$。弯曲单元的构建基于等参映射，该映射使用高阶几何表示将参考单元转换为物理弯曲单元。\n\n您的任务是在一个完整的、可运行的程序中实现以下内容：\n\n1. 使用重心坐标在参考四面体上定义 Nédélec 第一类最低阶边基函数。设参考四面体的顶点位于 $(0,0,0)$、$(1,0,0)$、$(0,1,0)$、$(0,0,1)$，其重心坐标为 $\\lambda_1 = 1 - r - s - t$、$\\lambda_2 = r$、$\\lambda_3 = s$、$\\lambda_4 = t$，常数梯度为 $\\nabla \\lambda_1 = (-1,-1,-1)$、$\\nabla \\lambda_2 = (1,0,0)$、$\\nabla \\lambda_3 = (0,1,0)$、$\\nabla \\lambda_4 = (0,0,1)$。参考单元上的六个边基函数与边 $(1,2)$、$(1,3)$、$(1,4)$、$(2,3)$、$(2,4)$、$(3,4)$ 相关联，并且必须用重心坐标及其梯度表示，与参考边上的边积分自由度保持一致。\n\n2. 对四面体使用二次等参映射。从坐标为 $(r,s,t)$ 的参考四面体到物理四面体的映射由具有 $10$ 个节点的二次四面体 Lagrange 形函数定义：$4$ 个顶点节点和 $6$ 个边中点节点。设二次形函数由重心坐标定义如下：\n   - 顶点形函数：\n     $$\n     N_1 = \\lambda_1(2\\lambda_1 - 1),\\quad N_2 = \\lambda_2(2\\lambda_2 - 1),\\quad N_3 = \\lambda_3(2\\lambda_3 - 1),\\quad N_4 = \\lambda_4(2\\lambda_4 - 1).\n     $$\n   - 边形函数（对于边 $(i,j)$）：\n     $$\n     N_{ij} = 4\\lambda_i \\lambda_j.\n     $$\n   映射 $\\mathbf{F}$ 由下式给出\n   $$\n   \\mathbf{x}(r,s,t) \\;=\\; \\sum_{a=1}^{10} N_a(r,s,t)\\, \\mathbf{X}_a,\n   $$\n   其中 $\\mathbf{X}_a \\in \\mathbb{R}^3$ 是 $10$ 个几何节点的物理坐标，排序为 $[1,2,3,4,12,13,14,23,24,34]$。雅可比矩阵 $\\mathbf{J} = D\\mathbf{F}$ 必须使用以下公式计算\n   $$\n   \\mathbf{J}(r,s,t) \\;=\\; \\sum_{a=1}^{10} \\mathbf{X}_a \\otimes \\nabla N_a(r,s,t),\n   $$\n   使其列分别为偏导数 $\\partial \\mathbf{x}/\\partial r$、$\\partial \\mathbf{x}/\\partial s$ 和 $\\partial \\mathbf{x}/\\partial t$。\n\n3. 使用适用于 $\\mathbf{H}(\\mathrm{curl})$ 协调单元的协变 Piola 变换，在每个物理四面体上构建映射后的 Nédélec 第一类基函数，并使用从等参映射中获得的切向量计算它们沿共享曲面的切向分量。共享面是顶点 $4$ 的对面（即由顶点 $1$、$2$ 和 $3$ 构成的面），所有比较都必须在参考坐标中 $t = 0$ 的点上进行。\n\n4. 通过在共享弯曲面上采样多个点，验证两个四面体之间在该面上的切向连续性。连续性验证必须通过计算来自两个四面体的相应映射基函数的切向分量之差，并汇总所有采样点上的最大绝对差来执行。\n\n5. 对两个四面体使用以下几何定义，它们共享由节点 $1$、$2$、$3$ 和边中点节点 $12$、$13$、$23$ 形成的弯曲面。所有坐标单位均为米：\n   - 共享面（两个四面体共用）：\n     $$\n     \\mathbf{X}_1 = (0,0,0),\\quad \\mathbf{X}_2 = (1,0,0),\\quad \\mathbf{X}_3 = (0,1,0),\n     $$\n     $$\n     \\mathbf{X}_{12} = (0.5,\\, 0.0,\\, 0.05),\\quad \\mathbf{X}_{13} = (0.0,\\, 0.5,\\, -0.04),\\quad \\mathbf{X}_{23} = (0.5,\\, 0.5,\\, 0.03).\n     $$\n   - 四面体 A 内部节点：\n     $$\n     \\mathbf{X}_4^{(A)} = (0.2,\\, 0.2,\\, 0.4),\n     $$\n     $$\n     \\mathbf{X}_{14}^{(A)} = (0.12,\\, 0.09,\\, 0.2),\\quad \\mathbf{X}_{24}^{(A)} = (0.6,\\, 0.12,\\, 0.21),\\quad \\mathbf{X}_{34}^{(A)} = (0.09,\\, 0.6,\\, 0.18).\n     $$\n   - 四面体 B 内部节点：\n     $$\n     \\mathbf{X}_4^{(B)} = (0.3,\\, 0.2,\\, -0.35),\n     $$\n     $$\n     \\mathbf{X}_{14}^{(B)} = (0.13,\\, 0.10,\\, -0.165),\\quad \\mathbf{X}_{24}^{(B)} = (0.66,\\, 0.09,\\, -0.175),\\quad \\mathbf{X}_{34}^{(B)} = (0.15,\\, 0.62,\\, -0.18).\n     $$\n\n6. 使用以下参考面采样点集（所有点均满足 $t = 0$）：\n   $$\n   (r,s,t) \\in \\{(0.2,\\, 0.3,\\, 0),\\; (0.5,\\, 0.0,\\, 0),\\; (0.0,\\, 0.5,\\, 0),\\; (0.5,\\, 0.5,\\, 0),\\; (0.0,\\, 0.0,\\, 0),\\; (1.0,\\, 0.0,\\, 0),\\; (0.0,\\, 1.0,\\, 0)\\}.\n   $$\n\n7. 定义四个测试用例以验证不同方面：\n   - 测试用例 1（一般内部连续性）：在采样点处，比较与边 $(1,2)$ 关联的映射基函数沿对应于 $\\partial\\mathbf{x}/\\partial r$ 的切向量的切向分量，并报告所有点上的最大绝对差。\n   - 测试用例 2（备用方向连续性）：在采样点处，比较与边 $(1,3)$ 关联的映射基函数沿对应于 $\\partial\\mathbf{x}/\\partial s$ 的切向量的切向分量，并报告最大绝对差。\n   - 测试用例 3（方向不匹配边界情况）：重复测试用例 1，但通过使用切向量的负值来有意反转第二个四面体的切线方向；报告最大绝对差，以说明不一致的方向处理所带来的影响。\n   - 测试用例 4（任意切向方向）：比较与边 $(2,3)$ 关联的映射基函数沿通过归一化 $\\partial\\mathbf{x}/\\partial r + 0.3\\, \\partial\\mathbf{x}/\\partial s$ 形成的单位切线方向的切向分量；报告最大绝对差。\n\n8. 最终输出格式：您的程序应生成单行输出，其中包含四个测试用例的结果，格式为方括号内以逗号分隔的列表，例如：\n$$\n[\\text{result1},\\text{result2},\\text{result3},\\text{result4}],\n$$\n其中每个结果都是一个以米为单位的浮点数（因为切向分量是与位置导数（单位为米）的点积），以普通十进制或科学记数法打印。\n\n您的程序必须是自包含的，必须构建等参映射、参考 Nédélec 基函数，应用用于 $\\mathbf{H}(\\mathrm{curl})$ 的协变 Piola 变换，并仅使用指定的数值库计算指定的切向连续性检查。该实现不得需要任何外部输入，并且必须严格遵守输出格式要求。",
            "solution": "该问题要求在弯曲的二次等参四面体上实现并验证 Nédélec 第一类最低阶边基函数的切向连续性。这是计算电磁学中有限元方法 (FEM) 的一个基础步骤。在进行数值实现之前，必须阐明其基本原理。\n\n**1. H(curl) 协调单元的理论基础**\n\n时谐麦克斯韦方程组控制着电磁现象。麦克斯韦-法拉第定律 $\\nabla \\times \\mathbf{E} = -j\\omega\\mathbf{B}$ 将电场 $\\mathbf{E}$ 的旋度与磁通量密度 $\\mathbf{B}$ 联系起来。在构建有限元解时，电场被近似为向量基函数的加权和，即 $\\mathbf{E}(\\mathbf{x}) \\approx \\sum_{i} e_i \\mathbf{W}_i(\\mathbf{x})$。为了使旋度算子在弱形式下有良好定义，这些基函数必须属于 Sobolev 空间 $\\mathbf{H}(\\mathrm{curl})$，该空间由其旋度也为平方可积的平方可积向量场组成。$\\mathbf{H}(\\mathrm{curl})$ 空间中场的一个关键特性是其切向分量在单元间边界上的连续性。这确保了不会出现虚假的、非物理的解，并保证了场的线积分是良好定义的。Nédélec 基函数是专门为强制实现这种切向连续性而设计的。\n\n**2. 参考单元上的基函数**\n\n构建始于一个简单的参考单元，即一个顶点位于 $\\hat{\\mathbf{v}}_1=(0,0,0)$、$\\hat{\\mathbf{v}}_2=(1,0,0)$、$\\hat{\\mathbf{v}}_3=(0,1,0)$ 和 $\\hat{\\mathbf{v}}_4=(0,0,1)$ 的四面体 $\\hat{K}$。$\\hat{K}$ 内的任何点 $\\hat{\\mathbf{x}}=(r,s,t)$ 都可以用重心坐标表示：\n$$\n\\lambda_1 = 1 - r - s - t, \\quad \\lambda_2 = r, \\quad \\lambda_3 = s, \\quad \\lambda_4 = t.\n$$\n这些坐标相对于参考坐标系 $(r,s,t)$ 的梯度是常向量：\n$$\n\\nabla \\lambda_1 = \\begin{pmatrix}-1\\\\-1\\\\-1\\end{pmatrix}, \\quad \\nabla \\lambda_2 = \\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix}, \\quad \\nabla \\lambda_3 = \\begin{pmatrix}0\\\\1\\\\0\\end{pmatrix}, \\quad \\nabla \\lambda_4 = \\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix}.\n$$\n与连接顶点 $i$ 和顶点 $j$ 的边相关联的 Nédélec 第一类最低阶边基函数 $\\hat{\\mathbf{W}}_{ij}$ 定义为：\n$$\n\\hat{\\mathbf{W}}_{ij}(\\hat{\\mathbf{x}}) = \\lambda_i(\\hat{\\mathbf{x}}) \\nabla \\lambda_j - \\lambda_j(\\hat{\\mathbf{x}}) \\nabla \\lambda_i.\n$$\n该定义确保了 $\\hat{\\mathbf{W}}_{ij}$ 沿任意边 $\\hat{e}_{kl}$ 的线积分为 $\\int_{\\hat{e}_{kl}} \\hat{\\mathbf{W}}_{ij} \\cdot d\\mathbf{l} = \\delta_{ij,kl}$，其中 $\\delta$ 是克罗内克 δ。此属性定义了这些单元的自由度。对应于四面体的六条边，共有六个这样的基函数。\n\n**3. 二次等参映射**\n\n为了模拟弯曲的几何形状，我们采用一个等参映射 $\\mathbf{F}$，它将参考单元 $\\hat{K}$ 转换为物理的、弯曲的单元 $K$。物理域中的位置向量 $\\mathbf{x}$ 表示为参考坐标 $\\hat{\\mathbf{x}}=(r,s,t)$ 的函数：\n$$\n\\mathbf{x}(\\hat{\\mathbf{x}}) = \\mathbf{F}(\\hat{\\mathbf{x}}) = \\sum_{a=1}^{10} N_a(\\hat{\\mathbf{x}}) \\mathbf{X}_a.\n$$\n在这里，$\\mathbf{X}_a$ 是二次四面体 $10$ 个物理节点的坐标，而 $N_a$ 是相应的二次 Lagrange 形函数。形函数由重心坐标定义：\n- 顶点节点 $(i=1,2,3,4)$: $N_i = \\lambda_i(2\\lambda_i - 1)$\n- 边中点节点（在边 $(i,j)$ 上）: $N_{ij} = 4\\lambda_i \\lambda_j$\n\n变换的局部行为由雅可比矩阵 $\\mathbf{J}$ 描述，其元素是物理坐标相对于参考坐标的偏导数，$J_{mn} = \\partial x_m / \\partial \\hat{x}_n$。其计算公式如下：\n$$\n\\mathbf{J}(\\hat{\\mathbf{x}}) = D\\mathbf{F} = \\sum_{a=1}^{10} \\mathbf{X}_a \\otimes \\nabla N_a(\\hat{\\mathbf{x}}),\n$$\n其中 $\\otimes$ 表示外积，$\\nabla N_a$ 是形函数相对于 $(r,s,t)$ 的梯度。\n\n**4. 协变 Piola 变换**\n\n来自参考单元的向量基函数不能简单地转移到物理单元上；它们必须经过变换以保持其特定属性，例如切向连续性。对于 $\\mathbf{H}(\\mathrm{curl})$ 协调单元，这是通过协变 Piola 变换实现的。一个参考基函数 $\\hat{\\mathbf{W}}(\\hat{\\mathbf{x}})$ 按照以下方式映射到物理基函数 $\\mathbf{W}(\\mathbf{x})$：\n$$\n\\mathbf{W}(\\mathbf{x}(\\hat{\\mathbf{x}})) = \\left[\\mathbf{J}(\\hat{\\mathbf{x}})^{-1}\\right]^T \\hat{\\mathbf{W}}(\\hat{\\mathbf{x}}).\n$$\n这种变换确保了向量场的切向分量在映射过程中得以保持，这是 $\\mathbf{H}(\\mathrm{curl})$ 协调性的基本要求。\n\n**5. 切向连续性验证**\n\n任务的核心是验证这种构造确实能产生切向连续的基函数。我们考虑两个相邻的四面体 $K_A$ 和 $K_B$，它们共享一个公共的弯曲面 $f$。面 $f$ 由一组公共节点定义。与位于该共享面上的边 $e$ 相关联的基函数 $\\mathbf{W}_e$ 在从任一四面体进行求值时，应具有相同的切向分量。\n这意味着，对于在点 $\\mathbf{x} \\in f$ 处与面 $f$ 相切的任何向量 $\\mathbf{t}$，以下等式必须成立：\n$$\n\\mathbf{W}_{e, A}(\\mathbf{x}) \\cdot \\mathbf{t}(\\mathbf{x}) = \\mathbf{W}_{e, B}(\\mathbf{x}) \\cdot \\mathbf{t}(\\mathbf{x}).\n$$\n在实现中，我们将在共享面上采样几个点。在每个点上，我们使用各自的雅可比矩阵 $\\mathbf{J}_A$ 和 $\\mathbf{J}_B$ 计算映射后的基函数 $\\mathbf{W}_{A}$ 和 $\\mathbf{W}_{B}$。我们还计算一个切向量 $\\mathbf{t}$。由于面上的映射仅由共享节点定义，因此切平面以及从映射导出的任何切向量（例如 $\\partial\\mathbf{x}/\\partial r$、$\\partial\\mathbf{x}/\\partial s$）对于两个四面体将是相同的。然后我们计算点积及其差值。对于与共享面上的边相关联的基函数，该差值应在数值精度范围内为零。这些测试用例旨在确认不同条件下的此属性，并说明不一致的切向量方向所带来的后果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and verifies tangential continuity of Nédélec basis functions on curved tetrahedra.\n    \"\"\"\n\n    class QuadraticTet:\n        \"\"\"Represents a quadratic isoparametric tetrahedron.\"\"\"\n        \n        def __init__(self, node_coords_dict):\n            \"\"\"\n            Initializes the tetrahedron with coordinates for its 10 nodes.\n            Args:\n                node_coords_dict: A dictionary mapping node keys (e.g., 1, 2, 12, 34) \n                                  to their 3D coordinates.\n            \"\"\"\n            # Order: 1, 2, 3, 4, 12, 13, 14, 23, 24, 34\n            self.nodes_X = np.array([\n                node_coords_dict[1], node_coords_dict[2], node_coords_dict[3], node_coords_dict[4],\n                node_coords_dict[12], node_coords_dict[13], node_coords_dict[14],\n                node_coords_dict[23], node_coords_dict[24], node_coords_dict[34]\n            ])\n            # Constant gradients of barycentric coordinates\n            self.grad_lambda = np.array([\n                [-1, -1, -1],  # grad(lambda_1)\n                [ 1,  0,  0],  # grad(lambda_2)\n                [ 0,  1,  0],  # grad(lambda_3)\n                [ 0,  0,  1]   # grad(lambda_4)\n            ])\n\n        def get_barycentric_coords(self, r, s, t):\n            \"\"\"Computes barycentric coordinates for a point (r,s,t).\"\"\"\n            return np.array([1 - r - s - t, r, s, t])\n\n        def get_shape_function_grads(self, r, s, t):\n            \"\"\"Computes gradients of the 10 quadratic Lagrange shape functions.\"\"\"\n            l = self.get_barycentric_coords(r, s, t)\n            grads = np.zeros((10, 3))\n            \n            # Vertex shape function gradients: grad(Ni) = (4*li - 1)*grad(li)\n            for i in range(4):\n                grads[i, :] = (4 * l[i] - 1) * self.grad_lambda[i]\n\n            # Edge shape function gradients: grad(Nij) = 4 * (lj*grad(li) + li*grad(lj))\n            edge_pairs = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n            for idx, (i, j) in enumerate(edge_pairs):\n                grads[4 + idx, :] = 4 * (l[j] * self.grad_lambda[i] + l[i] * self.grad_lambda[j])\n            \n            return grads\n\n        def get_jacobian(self, r, s, t):\n            \"\"\"Computes the Jacobian matrix of the isoparametric mapping.\"\"\"\n            shape_grads = self.get_shape_function_grads(r, s, t)\n            # J = sum(X_a outer grad(N_a))\n            J = np.zeros((3, 3))\n            for i in range(10):\n                J += np.outer(self.nodes_X[i], shape_grads[i])\n            return J\n\n    def get_ref_nedelec_basis(edge_pair, r, s, t):\n        \"\"\"\n        Computes the lowest-order Nédélec basis function on the reference element.\n        Args:\n            edge_pair: A tuple (i, j) of 0-indexed vertex numbers.\n            r, s, t: Coordinates on the reference element.\n        Returns:\n            The 3D vector value of the basis function.\n        \"\"\"\n        i, j = edge_pair\n        l = np.array([1 - r - s - t, r, s, t])\n        grad_lambda = np.array([\n            [-1, -1, -1], [1, 0, 0], [0, 1, 0], [0, 0, 1]\n        ])\n        \n        # W_ij = li * grad(lj) - lj * grad(li)\n        return l[i] * grad_lambda[j] - l[j] * grad_lambda[i]\n\n    # --- Problem Setup ---\n    # Shared nodes for both tetrahedra\n    shared_nodes = {\n        1: np.array([0.0, 0.0, 0.0]), 2: np.array([1.0, 0.0, 0.0]), 3: np.array([0.0, 1.0, 0.0]),\n        12: np.array([0.5, 0.0, 0.05]), 13: np.array([0.0, 0.5, -0.04]), 23: np.array([0.5, 0.5, 0.03])\n    }\n\n    # Nodes for Tetrahedron A\n    nodes_A = shared_nodes.copy()\n    nodes_A.update({\n        4: np.array([0.2, 0.2, 0.4]), 14: np.array([0.12, 0.09, 0.2]),\n        24: np.array([0.6, 0.12, 0.21]), 34: np.array([0.09, 0.6, 0.18])\n    })\n\n    # Nodes for Tetrahedron B\n    nodes_B = shared_nodes.copy()\n    nodes_B.update({\n        4: np.array([0.3, 0.2, -0.35]), 14: np.array([0.13, 0.10, -0.165]),\n        24: np.array([0.66, 0.09, -0.175]), 34: np.array([0.15, 0.62, -0.18])\n    })\n\n    tet_A = QuadraticTet(nodes_A)\n    tet_B = QuadraticTet(nodes_B)\n\n    # Sample points on the reference face (t=0)\n    sample_points = [\n        (0.2, 0.3, 0.0), (0.5, 0.0, 0.0), (0.0, 0.5, 0.0), (0.5, 0.5, 0.0),\n        (0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0)\n    ]\n    \n    # 0-indexed reference edges for Nédélec functions\n    edge_map = {\n        (1, 2): (0, 1), (1, 3): (0, 2), (1, 4): (0, 3),\n        (2, 3): (1, 2), (2, 4): (1, 3), (3, 4): (2, 3)\n    }\n\n    test_cases_params = [\n        {'edge': (1, 2), 'case': 1},\n        {'edge': (1, 3), 'case': 2},\n        {'edge': (1, 2), 'case': 3},\n        {'edge': (2, 3), 'case': 4},\n    ]\n\n    final_results = []\n\n    for params in test_cases_params:\n        edge_key = params['edge']\n        case_num = params['case']\n        ref_edge_indices = edge_map[edge_key]\n        \n        max_abs_diff = 0.0\n\n        for r_p, s_p, t_p in sample_points:\n            # 1. Get reference Nédélec basis function\n            W_ref = get_ref_nedelec_basis(ref_edge_indices, r_p, s_p, t_p)\n\n            # 2. Compute Jacobians for both tetrahedra\n            J_A = tet_A.get_jacobian(r_p, s_p, t_p)\n            J_B = tet_B.get_jacobian(r_p, s_p, t_p)\n\n            # 3. Apply Covariant Piola Transform: W_phys = (J^-T) @ W_ref\n            J_A_inv_T = np.linalg.inv(J_A).T\n            J_B_inv_T = np.linalg.inv(J_B).T\n            \n            W_A = J_A_inv_T @ W_ref\n            W_B = J_B_inv_T @ W_ref\n\n            # 4. Define tangent vector for the test case\n            # Tangent vectors on the face are identical for both tets as nodes are shared\n            tangent_r = J_A[:, 0]  # d(x)/dr\n            tangent_s = J_A[:, 1]  # d(x)/ds\n\n            if case_num == 1 or case_num == 3:\n                t_A = tangent_r\n                t_B = -tangent_r if case_num == 3 else tangent_r\n            elif case_num == 2:\n                t_A = tangent_s\n                t_B = tangent_s\n            elif case_num == 4:\n                t_vec = tangent_r + 0.3 * tangent_s\n                t_norm = np.linalg.norm(t_vec)\n                t_A = t_vec / t_norm if t_norm  1e-15 else np.zeros(3)\n                t_B = t_A\n            \n            # 5. Compute tangential components and their difference\n            tangential_comp_A = np.dot(W_A, t_A)\n            tangential_comp_B = np.dot(W_B, t_B)\n            \n            diff = np.abs(tangential_comp_A - tangential_comp_B)\n            if diff  max_abs_diff:\n                max_abs_diff = diff\n\n        final_results.append(max_abs_diff)\n\n    print(f\"[{','.join(f'{r:.15e}' for r in final_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}