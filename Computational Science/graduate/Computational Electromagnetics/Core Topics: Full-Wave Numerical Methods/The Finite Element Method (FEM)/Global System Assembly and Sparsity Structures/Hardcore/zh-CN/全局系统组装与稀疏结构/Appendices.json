{
    "hands_on_practices": [
        {
            "introduction": "本章节提供了一系列动手实践，旨在巩固您对计算电磁学中局部网格拓扑如何决定全局矩阵结构的理解。这些练习将从纯粹的拓扑推理开始，逐步过渡到实际的计算实现。\n第一个练习是一个基础性的思想实验。我们将探讨在Yee网格（时域有限差分法FDTD和有限积分技术FIT的基石）上的情况。通过仅分析其局部几何结构，我们就能精确确定系统矩阵每一行中的非零元素数量，从而揭示源自均匀结构化网格的矩阵所具有的高度规则化稀疏特性。",
            "id": "3312206",
            "problem": "在具有周期性边界条件的交错立方Yee网格上对麦克斯韦方程组进行三维离散化，考虑与旋度-旋度算子相关的全局矩阵的拓扑组装。设网格包含 $N_x \\times N_y \\times N_z$ 个单元。假设采用标准的Yee布局，其中电场积分未知量与有向边相关联，离散旋度算子通过一个带符号的关联矩阵将基于边的场映射到基于面的环流。\n\n令 $C \\in \\mathbb{R}^{N_f \\times N_e}$ 表示带符号的面-边关联（离散旋度）矩阵，其中 $N_e$ 是有向边的数量，$N_f$ 是有向面的数量。考虑在构建无材料权重的矢量亥姆霍兹方程的全局系统时产生的对称半正定矩阵 $K = C^{T} C \\in \\mathbb{R}^{N_e \\times N_e}$。忽略度量缩放和材料非均匀性；仅关注组合关联关系。\n\n仅使用Yee网格的基本拓扑结构和定义 $C$ 的离散形式的斯托克斯定理，在所有三个方向均为周期性边界条件的假设下，确定 $K$ 每行的非零元的确切数量。通过确定与单个边相关联的面有多少，以及在这些关联面上有多少其他边与该边共现，来证明您的计数，并验证在同一对不同边之间，不存在由多个共享面创建的重复耦合。您的最终答案必须是一个单个整数。无需四舍五入，也无需单位。",
            "solution": "该问题要求计算矩阵 $K = C^{T} C$ 每行的非零元数量。矩阵元素 $K_{ij} = \\sum_{k} C_{ki} C_{kj}$。此和是 $C$ 的第 $i$ 列和第 $j$ 列的点积。该值非零当且仅当存在至少一个面 $k$，使得边 $e_i$ 和边 $e_j$ 都是该面的边界。因此，第 $i$ 行的非零元数量等于与边 $e_i$ 共享同一个面的边的总数（包括 $e_i$ 本身）。\n\n由于网格是均匀的立方Yee网格且具有周期性边界条件，我们可以通过分析任意一条边（称之为中心边 $e_c$）的局部拓扑来确定这个数量。\n\n1.  **与 $e_c$ 自身耦合**：对角元 $K_{cc}$ 总是非零的，因为 $e_c$ 属于多个面的边界。这贡献了 **1** 个非零元。\n\n2.  **与邻边耦合**：我们需要计算与 $e_c$ 共享一个面的所有其他边的数量。\n    *   在三维立方网格中，任何一条内部边都由 **4** 个面共享，这些面像书页一样围绕着它。\n    *   每个面都是一个正方形，由 4 条边组成。\n    *   让我们以一条沿 $z$ 轴的中心边 $e_c$ 为例。它的两个端点分别位于 $z=z_0$ 和 $z=z_1$。\n    *   在底部端点（$z=z_0$），有 4 条与之相连的正交边（2条 $x$ 方向，2条 $y$ 方向）。\n    *   在顶部端点（$z=z_1$），同样有 4 条与之相连的正交边。\n    这 8 条正交边都与 $e_c$ 共享一个面，并且它们彼此不同。\n    *   此外，还有 4 条与 $e_c$ 平行的 $z$ 轴方向的边，它们分别构成了包含 $e_c$ 的四个面的“对边”。这 4 条平行边也都与 $e_c$ 共享一个面。\n    *   总共有 $8$ 条正交邻边和 $4$ 条平行邻边，共计 **12** 条不同的邻边。\n\n综上所述，矩阵 $K$ 的每行非零元的总数为中心边本身（1）加上其所有唯一的邻边（12），总计为 $1 + 12 = 13$。",
            "answer": "$$\\boxed{13}$$"
        },
        {
            "introduction": "最后的这项实践将理论与计算相结合，要求您编程实现离散旋度-旋度算子的组装。通过模拟移除网格单元（面），您将直接观察到拓扑结构的改变如何影响矩阵的稀疏模式、图的连通性，以及至关重要的——算子的零空间。这项练习展示了网格完整性与最终线性系统代数性质之间的深刻联系，并突出了实际问题，例如非平凡核（null space）的出现会使标准求解方法变得复杂甚至失效。",
            "id": "3312144",
            "problem": "考虑一个二维周期性矩形晶格，它为一个在计算电磁学 (CEM) 中使用的域的环形离散化建模。该晶格在水平方向上有 $N_x$ 个单元，在垂直方向上有 $N_y$ 个单元，且在两个方向上都具有周期性边界条件。该网格由一个包含节点、有向边和有向面的胞腔复形表示。有向边分为两类：与 $x$ 方向对齐的水平边和与 $y$ 方向对齐的垂直边。设总边数为 $E = 2 N_x N_y$，总面数为 $F = N_x N_y$。通过移除一部分面来引入缺陷模式，以模拟缺失的单元。这是全局系统集成中的一种标准抽象，其中全局算子的条目源于与网格实体相关的局部贡献；缺失的面会移除局部贡献，从而改变稀疏性和拓扑连通性。\n\n从麦克斯韦旋度方程和微分算子定义出发，可以在边空间上定义一个离散旋度算子。离散旋度通过对每个面边界周围的有向边值求和，将边的自由度映射到面的环流。面-边关联矩阵 $C \\in \\mathbb{R}^{F \\times E}$ 编码了这些有向和，而单位霍奇权重下边上的离散旋度-旋度算子为 $A = C^\\top C \\in \\mathbb{R}^{E \\times E}$。当面被移除时，$C$ 中对应的行也被移除，这会引起 $A$ 的变化，例如稀疏性和连通性的改变。$A$ 的核等于 $C$ 的核，其维度为 $E - \\operatorname{rank}(C)$。\n\n目标是为周期性但有缺陷的连通性（存在缺失的面）组装 $A$，并研究由 $A$ 导出的边邻接图变为不连通时的逾渗阈值。在此阈值下，$A$ 的核维度增加，使预处理复杂化。邻接图定义在边的集合上，如果 $A$ 中对应的非对角线元素非零，则两个不同的边是邻接的。该图的连通分量数量化了其不连通性。这里的逾渗阈值定义为，使得邻接图具有多于一个连通分量所需移除面的最小比例 $p \\in [0,1]$。\n\n您的程序必须为每个测试用例实现以下步骤：\n1. 构建具有给定 $N_x$ 和 $N_y$ 的周期性晶格，并枚举水平和垂直的有向边和面。\n2. 组装面-边关联矩阵 $C$，通过分配方向使得每个面的行等于其四个边界边按逆时针顺序的代数和，并带有适当的符号以保证方向一致性。\n3. 初始时没有缺失的面，然后以随机顺序（使用指定的随机种子以保证可复现性）逐个移除面，每次移除后重新计算 $C$ 和 $A = C^\\top C$。\n4. 每次移除后，计算：\n   - 由 $A$ 的非对角线非零模式导出的边邻接图中的连通分量数量。\n   - 核维度 $E - \\operatorname{rank}(C)$，使用数值稳定的奇异值分解，并将奇异值小于阈值 $t = 10^{-10}$ 的视为零。\n5. 当图变得不连通（连通分量数严格大于1）时停止，报告不连通时的最小移除比例 $p$，并报告该阈值下的连通分量数和核维度。\n\n您必须从以下基本概念出发：\n- 麦克斯韦方程组和旋度算子的定义。\n- 胞腔复形中有向关联的定义。\n- 全局算子由与网格实体相关的局部贡献求和形成的离散算子组装原理。\n\n程序必须生成单行输出，包含所有测试用例的聚合结果，格式为一个逗号分隔的列表，并用方括号括起来，其中每个测试结果本身是一个 $[p,\\text{components},\\text{nullity}]$ 形式的列表，$p$ 是浮点数，其他条目是整数。本问题不涉及物理单位。\n\n使用以下测试套件：\n- 测试用例 1：$N_x = 3$， $N_y = 3$，随机种子 $s = 7$。\n- 边界测试用例 2：$N_x = 1$， $N_y = 1$，随机种子 $s = 42$。\n- 测试用例 3：$N_x = 5$， $N_y = 3$，随机种子 $s = 0$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[[p_1,c_1,n_1],[p_2,c_2,n_2],[p_3,c_3,n_3]]$，其中每个 $p_k$ 为十进制形式，每个 $c_k$ 和 $n_k$ 为整数。",
            "solution": "所提出的问题是计算电磁学中一个有效且定义明确的练习，其基础是离散外微分 (DEC) 的原理。它涉及在周期性晶格上组装离散算子，并分析当域发生改变时它们的代数和拓扑性质。我们将以严谨、分步的方式进行求解。\n\n这个问题的基础是在一个胞腔复形上对麦克斯韦旋度方程进行离散化，此处的胞腔复形是一个二维环形矩形晶格。该复形的几何实体是一组 $0$-胞腔 (节点或顶点)、$1$-胞腔 (有向边) 和 $2$-胞腔 (有向面)。物理自由度，例如电场的某个分量，与这些实体相关联。\n\n设晶格在水平方向上有 $N_x$ 个单元，在垂直方向上有 $N_y$ 个单元。由于周期性边界条件，该晶格在拓扑上是一个环面。面 (或 $2$-胞腔) 的数量为 $F = N_x N_y$，顶点 (或 $0$-胞腔) 的数量为 $V = N_x N_y$。边 (或 $1$-胞腔) 分为两类：$N_x N_y$ 条水平边和 $N_x N_y$ 条垂直边，总边数为 $E = 2 N_x N_y$。\n\n这些实体之间的关系由边界算子捕获。离散旋度算子由面-边关联矩阵表示，记为 $C \\in \\mathbb{R}^{F \\times E}$。该矩阵是连续旋度算子的离散表示，它将矢量场 (由边上的值表示，即 $1$-形式) 映射到标量场 (由面上的环流表示，即 $2$-形式)。\n\n$C$ 的组装遵循面边界的定义。我们建立了一套一致的枚举和方向规则。\n设面的索引为 $k \\in \\{0, \\dots, F-1\\}$，边的索引为 $m \\in \\{0, \\dots, E-1\\}$。仅当边 $m$ 是面 $k$ 边界的一部分时，条目 $C_{km}$ 才非零。具体来说，对于一个具有逆时针方向的面 $f_k$，其边界 $\\partial f_k$ 是其四个边界边的形式和。如果边 $m$ 是 $\\partial f_k$ 的一部分且其方向与逆时针遍历方向匹配，则 $C_{km}$ 的值为 $+1$；如果方向相反，则为 $-1$。\n\n为实现此目的，我们定义一个坐标系 $(i, j)$，其中 $i \\in \\{0, \\dots, N_x-1\\}$ 且 $j \\in \\{0, \\dots, N_y-1\\}$。\n- 位于 $(i,j)$ 的面索引为 $k = j \\cdot N_x + i$。\n- 从节点 $(i,j)$ 开始的水平边索引为 $m = j \\cdot N_x + i$，其中 $m \\in \\{0, \\dots, F-1\\}$。\n- 从节点 $(i,j)$ 开始的垂直边索引为 $m = F + j \\cdot N_x + i$，其中 $m \\in \\{F, \\dots, E-1\\}$。\n所有空间索引 $i$ 和 $j$ 分别对 $N_x$ 和 $N_y$ 取模，以强制实现周期性。\n\n面 $(i,j)$ 的四个有向边界边为：\n1. 底边：位于 $(i,j)$ 的水平边，符号 $+1$。\n2. 右边：位于 $(i+1, j)$ 的垂直边，符号 $+1$。\n3. 顶边：位于 $(i, j+1)$ 的水平边，符号 $-1$（因为逆时针遍历方向为从右到左，与边的方向相反）。\n4. 左边：位于 $(i, j)$ 的垂直边，符号 $-1$（因为逆时针遍历方向为从上到下，与边的方向相反）。\n这些规则定义了 $C$ 的每一行的非零条目。\n\n由 $C$，我们构造离散旋度-旋度算子 $A = C^\\top C$，这是一个 $E \\times E$ 矩阵。一个非对角线元素 $A_{uv} = (C^\\top C)_{uv} = \\sum_k C_{ku} C_{kv}$ 非零，当且仅当边 $u$ 和 $v$ 共享至少一个公共面。因此，矩阵 $A$ 可以被解释为一个图的邻接矩阵（不考虑其对角线），该图的节点是晶格的边。\n\n该问题研究了移除面的影响，这模拟了材料或域中的缺陷。移除一个面 $f_k$ 等同于从矩阵 $C$ 中移除第 $k$ 行。这会改变 $A = C^\\top C$，从而破坏边邻接图中的连接。主要目标是找到逾渗阈值：使得该图不连通所需随机移除面的最小比例 $p$。\n\n算法流程如下：\n1. 对于给定的 $N_x$、$N_y$ 和随机种子 $s$，我们首先为完整的环形晶格组装完整的关联矩阵 $C$。\n2. 使用种子 $s$ 生成面索引 $\\{0, \\dots, F-1\\}$ 的一个随机排列，以确保可复现性。\n3. 我们进行迭代，从移除 $k=0$ 个面（初始状态）开始，直到 $k=F$。在每一步中，我们通过保留未被移除的面所对应的行来构建简化的关联矩阵 $C_k$。\n4. 对于每个 $C_k$，我们计算旋度-旋度矩阵 $A_k = C_k^\\top C_k$。\n5. 然后，我们确定由 $A_k$ 表示的图的连通分量数量。这可以通过标准的图遍历算法完成，例如 `scipy.sparse.csgraph.connected_components` 中提供的算法。\n6. 一旦连通分量数量严格大于 $1$，迭代就停止。\n7. 在此停止点，我们报告三个量：\n    a. 移除面的比例，$p = k/F$。\n    b. 连通分量的数量。\n    c. 算子 $A_k$ 的零度（核维度）。由于 $\\ker(A_k) = \\ker(C_k)$，零度由 $\\dim(\\ker(C_k)) = E - \\operatorname{rank}(C_k)$ 给出。秩是通过 $C_k$ 的奇异值分解 (SVD) 进行数值计算的，计算的是超过阈值 $t = 10^{-10}$ 的奇异值数量。\n\n对于非退化网格（其中 $N_x > 1$ 且 $N_y > 1$），初始图是完全连通的。对于退化的“环面”（其中 $N_x=1$ 或 $N_y=1$），初始图已经是不连通的，算法会正确地将逾渗阈值识别为 $p=0$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.csgraph import connected_components\n\ndef run_simulation(Nx, Ny, seed):\n    \"\"\"\n    Simulates face percolation on a toroidal grid and finds the disconnection threshold.\n\n    Args:\n        Nx (int): Number of cells in the x-direction.\n        Ny (int): Number of cells in the y-direction.\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        list: [p, components, nullity] at the percolation threshold.\n    \"\"\"\n    F = Nx * Ny\n    E = 2 * F\n\n    if F == 0:\n        return [0.0, 0, 0]\n\n    # Step 1: Enumerate entities\n    def h_edge_idx(i, j):\n        return j * Nx + i\n\n    def v_edge_idx(i, j):\n        return F + (j * Nx + i)\n\n    # Step 2: Assemble the full face-edge incidence matrix C\n    # Using LIL format for efficient incremental construction\n    C_lil = lil_matrix((F, E), dtype=np.int8)\n    for j in range(Ny):\n        for i in range(Nx):\n            face_idx = j * Nx + i\n            \n            # Boundary edges in CCW order with signs\n            # Bottom edge: h(i, j), sign +1\n            C_lil[face_idx, h_edge_idx(i, j)] += 1\n            \n            # Right edge: v(i+1, j), sign +1\n            C_lil[face_idx, v_edge_idx((i + 1) % Nx, j)] += 1\n            \n            # Top edge: h(i, j+1), sign -1\n            C_lil[face_idx, h_edge_idx(i, (j + 1) % Ny)] -= 1\n            \n            # Left edge: v(i, j), sign -1\n            C_lil[face_idx, v_edge_idx(i, j)] -= 1\n            \n    full_C = C_lil.tocsr()\n    \n    # Step 3: Prepare for iterative removal\n    rng = np.random.default_rng(seed)\n    face_permutation = rng.permutation(F)\n\n    # Loop through number of removed faces, k, from 0 to F.\n    for k in range(F + 1):\n        p = k / F\n        \n        if k == F:\n            # All faces removed, C is empty\n            C_current = csr_matrix((0, E), dtype=np.int8)\n        else:\n            # Get indices of faces that are kept\n            kept_indices = face_permutation[k:]\n            C_current = full_C[kept_indices, :]\n\n        # Step 4: Compute A and graph components\n        A_k = C_current.transpose().dot(C_current)\n        \n        num_comps, _ = connected_components(\n            csgraph=A_k, directed=False, connection='weak'\n        )\n        \n        # Step 5: Check for disconnection and report\n        if num_comps > 1:\n            # Calculate rank and nullity\n            if C_current.shape[0] == 0:\n                rank = 0\n            else:\n                # SVD is reliable for rank of small-to-medium matrices\n                s = np.linalg.svd(C_current.toarray(), compute_uv=False)\n                rank = np.sum(s > 1e-10)\n            \n            nullity = E - int(rank)\n            \n            return [p, num_comps, nullity]\n\n    # This fallback should not be reached for E > 0, as a zero matrix A\n    # (when all faces are removed) results in E components.\n    return [1.0, E, E]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (3, 3, 7),   # Test case 1\n        (1, 1, 42),  # Boundary test case 2\n        (5, 3, 0),   # Test case 3\n    ]\n\n    results = []\n    for Nx, Ny, seed in test_cases:\n        result = run_simulation(Nx, Ny, seed)\n        results.append(result)\n        \n    # Format the final output string exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}