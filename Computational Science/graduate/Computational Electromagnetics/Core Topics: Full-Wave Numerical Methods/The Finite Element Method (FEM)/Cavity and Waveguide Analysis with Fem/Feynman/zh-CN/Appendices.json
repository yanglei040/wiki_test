{
    "hands_on_practices": [
        {
            "introduction": "要使用有限元方法分析波导，我们必须首先将麦克斯韦方程组转化为适合离散化的二维标量本征值问题。本练习是理论联系实践的第一步，它将引导您从第一性原理出发，为TE模式推导出其控制方程和相应的伽辽金弱形式。掌握这一过程是理解和开发电磁有限元求解器的基础。",
            "id": "3291519",
            "problem": "考虑一个沿 $\\,\\hat{z}\\,$ 轴不变的均匀、无源、无损、各向同性的电磁波导，其横截面 $\\,\\Omega \\subset \\mathbb{R}^{2}\\,$ 为有界单连通区域，边界 $\\,\\partial\\Omega\\,$ 为理想电导体 (PEC)。介质具有恒定的介电常数 $\\,\\varepsilon\\,$ 和磁导率 $\\,\\mu\\,$，时间依赖关系为谐波形式 $\\,\\exp(j\\omega t)\\,$，所有场分量对 $\\,z\\,$ 的依赖关系为 $\\,\\exp(-j\\beta z)\\,$，其中 $\\,\\beta\\,$ 是待求的传播常数。根据纵向场分量 $\\,E_{z}\\,$ 和 $\\,H_{z}\\,$ 定义横电 (TE)、横磁 (TM) 和横电磁 (TEM) 模式族。然后，仅从宏观 Maxwell 方程组和 $\\,\\partial\\Omega\\,$ 上的 PEC 边界条件 $\\,\\hat{n}\\times\\mathbf{E}= \\mathbf{0}\\,$ 出发，推导 TE 标量纵向场 $\\,H_{z}(\\mathbf{r}_{t})\\,$（其中 $\\,\\mathbf{r}_{t}=(x,y)\\in\\Omega\\,$）的二维横截面强形式偏微分方程，以及由 PEC 壁决定的在 $\\,\\partial\\Omega\\,$ 上的相关边界条件。接下来，使用有限元法 (FEM)，根据 $\\,\\Omega\\,$ 上适当的试探函数和检验函数空间，构建关于传播常数 $\\,\\beta\\,$ 的相应 Galerkin 弱形式本征问题。最后，用电磁波数 $\\,k=\\omega\\sqrt{\\mu\\varepsilon}\\,$ 和所得横向拉普拉斯本征问题的本征值 $\\,\\lambda\\,$ 来明确表示传播常数 $\\,\\beta\\,$。你的最终答案必须是包含 $\\,\\beta\\,$、$\\,k\\,$ 和 $\\,\\lambda\\,$ 的单个闭式解析表达式。不要将中间方程作为最终答案。",
            "solution": "问题陈述是有效的，因为它科学上基于 Maxwell 电磁理论，是适定的，并且是客观构建的。它代表了计算电磁学中一个标准且非平凡的问题。因此，我们可以继续进行求解。\n\n分析始于均匀、各向同性介质（介电常数为 $\\varepsilon$，磁导率为 $\\mu$）中的时谐、无源 Maxwell 方程组：\n$$\n\\begin{align*}\n\\nabla \\times \\mathbf{E} = -j\\omega\\mu\\mathbf{H} \\\\\n\\nabla \\times \\mathbf{H} = j\\omega\\varepsilon\\mathbf{E} \\\\\n\\nabla \\cdot \\mathbf{E} = 0 \\\\\n\\nabla \\cdot \\mathbf{H} = 0\n\\end{align*}\n$$\n其中假设时间依赖关系为 $\\exp(j\\omega t)$。鉴于波导沿 $\\hat{z}$ 轴是均匀的，场被假设具有 $\\mathbf{F}(\\mathbf{r}_t, z) = \\mathbf{F}(\\mathbf{r}_t) \\exp(-j\\beta z)$ 的空间依赖形式，其中 $\\mathbf{F}$ 为 $\\mathbf{E}$ 或 $\\mathbf{H}$，$\\mathbf{r}_t = (x,y)$ 是横向位置矢量，$\\beta$ 是传播常数。在此假设下，del 算子可以分解为 $\\nabla = \\nabla_t - j\\beta\\hat{z}$，其中 $\\nabla_t = \\hat{x}\\frac{\\partial}{\\partial x} + \\hat{y}\\frac{\\partial}{\\partial y}$ 是横向 del 算子。\n\n电磁场可以分解为横向 ($\\mathbf{E}_t$, $\\mathbf{H}_t$) 和纵向 ($E_z$, $H_z$) 分量：$\\mathbf{E} = \\mathbf{E}_t + E_z\\hat{z}$ 和 $\\mathbf{H} = \\mathbf{H}_t + H_z\\hat{z}$。\n\n模式族根据纵向场分量的存在来定义：\n1.  **横电 (TE) 模式**：电场完全垂直于传播方向。其定义为对所有 $(x,y,z)$ 都有 $E_z=0$，且存在非平凡的 $H_z \\neq 0$。\n2.  **横磁 (TM) 模式**：磁场完全垂直于传播方向。其定义为对所有 $(x,y,z)$ 都有 $H_z=0$，且存在非平凡的 $E_z \\neq 0$。\n3.  **横电磁 (TEM) 模式**：电场和磁场都完全垂直于传播方向。其定义为 $E_z=0$ 和 $H_z=0$。要存在非平凡的 TEM 模式，截止波数 $k_c$ 必须为零，这意味着对于电势 $\\Phi$，有 $\\nabla_t^2 \\Phi = 0$。对于由单个理想电导体 (PEC) 界定的单连通域 $\\Omega$，边界条件要求 $\\Phi$ 在 $\\partial\\Omega$ 上为常数。根据拉普拉斯方程的极值原理，$\\Phi$ 必须在整个 $\\Omega$ 上为常数，这导致了平凡零场。因此，TEM 模式在这种结构中不能存在。\n\n我们现在专注于推导 TE 模式的控制方程。通过对 Maxwell 第一个旋度方程取旋度，可以推导出一个普遍的波动方程：\n$$ \\nabla \\times (\\nabla \\times \\mathbf{E}) = \\nabla(\\nabla\\cdot\\mathbf{E}) - \\nabla^2\\mathbf{E} = -j\\omega\\mu(\\nabla \\times \\mathbf{H}) $$\n由于介质无源，$\\nabla\\cdot\\mathbf{E}=0$。代入第二个旋度方程得到：\n$$ -\\nabla^2\\mathbf{E} = -j\\omega\\mu(j\\omega\\varepsilon\\mathbf{E}) = \\omega^2\\mu\\varepsilon\\mathbf{E} $$\n定义电磁波数为 $k=\\omega\\sqrt{\\mu\\varepsilon}$，我们得到矢量亥姆霍兹方程：\n$$ \\nabla^2\\mathbf{E} + k^2\\mathbf{E} = \\mathbf{0} $$\n类似的推导可得出磁场的相同方程，$(\\nabla^2 + k^2)\\mathbf{H} = \\mathbf{0}$。我们感兴趣的是 TE 模式的纵向分量 $H_z$。此矢量方程的 $\\hat{z}$ 分量为：\n$$ (\\nabla^2 + k^2)H_z = 0 $$\n使用分解 $\\nabla^2 = \\nabla_t^2 + \\frac{\\partial^2}{\\partial z^2}$ 并代入 $\\frac{\\partial}{\\partial z} \\to -j\\beta$，我们发现 $\\frac{\\partial^2}{\\partial z^2} \\to (-j\\beta)^2 = -\\beta^2$。标量场 $H_z(\\mathbf{r}_t)$ 的方程变为：\n$$ (\\nabla_t^2 - \\beta^2 + k^2)H_z = 0 $$\n这通常写成一个标准的二维亥姆霍兹方程：\n$$ \\nabla_t^2 H_z + k_c^2 H_z = 0 $$\n其中 $k_c^2 = k^2 - \\beta^2$ 是截止波数的平方。这就是所要求的 TE 纵向场分量 $H_z$ 的强形式偏微分方程 (PDE)。\n\n接下来，我们推导在 PEC 边界 $\\partial\\Omega$ 上 $H_z$ 的边界条件。PEC 条件是电场 $\\mathbf{E}$ 的切向分量在导体表面必须为零：在 $\\partial\\Omega$ 上 $\\hat{n} \\times \\mathbf{E} = \\mathbf{0}$。这意味着 $\\mathbf{E}$ 的任何切向分量都为零。在波导的柱面上，法向量 $\\hat{n}$ 是纯横向的，因此存在两个正交的切向方向：一个沿轴向 $\\hat{z}$，另一个在横向平面内，$\\hat{t} = \\hat{z} \\times \\hat{n}$。\n该条件要求在 $\\partial\\Omega$ 上 $E_z=0$ 和 $\\mathbf{E}_t \\cdot \\hat{t} = 0$。对于 TE 模式，$E_z=0$ 在任何地方都满足。我们必须施加第二个条件。横向场可以用纵向场来表示。对于 TE 模式（$E_z=0$），横向电场由下式给出：\n$$ \\mathbf{E}_t = \\frac{-j\\omega\\mu}{k_c^2}(\\hat{z} \\times \\nabla_t H_z) $$\n应用边界条件 $\\mathbf{E}_t \\cdot \\hat{t} = 0$：\n$$ \\frac{-j\\omega\\mu}{k_c^2}(\\hat{z} \\times \\nabla_t H_z) \\cdot \\hat{t} = 0 $$\n使用标量三重积恒等式 $\\mathbf{a} \\cdot (\\mathbf{b} \\times \\mathbf{c}) = \\mathbf{b} \\cdot (\\mathbf{c} \\times \\mathbf{a})$：\n$$ (\\nabla_t H_z) \\cdot (\\hat{t} \\times \\hat{z}) = 0 $$\n由于 $\\hat{n} = \\hat{t} \\times \\hat{z}$ 是横向平面中边界曲线 $\\partial\\Omega$ 的外向单位法向量，该条件变为：\n$$ (\\nabla_t H_z) \\cdot \\hat{n} = 0 \\quad \\text{on } \\partial\\Omega $$\n这是法向导数，通常写作 $\\frac{\\partial H_z}{\\partial n} = 0$。这是 $H_z$ 的齐次 Neumann 边界条件。\n\n问题现在被转化为横向拉普拉斯算子的一个本征值问题：寻找满足以下条件的本征值 $\\lambda = k_c^2$ 和相应的本征函数 $H_z$：\n$$ -\\nabla_t^2 H_z = \\lambda H_z \\quad \\text{in } \\Omega, \\qquad \\frac{\\partial H_z}{\\partial n} = 0 \\quad \\text{on } \\partial\\Omega $$\n\n为了构建 Galerkin 弱形式，我们从一个合适的函数空间中引入一个检验函数 $v$，对于 Neumann 问题，这个空间是 Sobolev 空间 $V = H^1(\\Omega)$。我们将 PDE 乘以 $v$ 并在横截面域 $\\Omega$ 上积分：\n$$ \\int_{\\Omega} v (-\\nabla_t^2 H_z) \\, dA = \\lambda \\int_{\\Omega} v H_z \\, dA $$\n我们将格林第一恒等式（多维分部积分）应用于左侧：\n$$ \\int_{\\Omega} (\\nabla_t v) \\cdot (\\nabla_t H_z) \\, dA - \\oint_{\\partial\\Omega} v ((\\nabla_t H_z) \\cdot \\hat{n}) \\, ds = \\lambda \\int_{\\Omega} v H_z \\, dA $$\n边界积分消失，因为在 $\\partial\\Omega$ 上 $(\\nabla_t H_z) \\cdot \\hat{n} = \\frac{\\partial H_z}{\\partial n} = 0$。这留下了弱形式本征问题：寻找一个非平凡的试探函数 $H_z \\in V$ 和一个本征值 $\\lambda \\in \\mathbb{R}$，使得对于每个检验函数 $v \\in V$：\n$$ \\int_{\\Omega} (\\nabla_t v) \\cdot (\\nabla_t H_z) \\, dA = \\lambda \\int_{\\Omega} v H_z \\, dA $$\n这就是所求的 Galerkin 弱形式。\n\n最后，我们用 $k$ 和 $\\lambda$ 来表示传播常数 $\\beta$。弱形式表述的本征值 $\\lambda$ 对应于算子 $-\\nabla_t^2$ 的本征值。如前所述，该本征值是截止波数的平方，即 $\\lambda = k_c^2$。波导模式的基本色散关系将介质波数 $k$、传播常数 $\\beta$ 和截止波数 $k_c$ 联系起来：\n$$ k^2 = \\beta^2 + k_c^2 $$\n用 $\\lambda$ 代替 $k_c^2$，我们得到关联这三个量的最终表达式：\n$$ k^2 = \\beta^2 + \\lambda $$\n这个方程可以重新整理，以用 $k$ 和 $\\lambda$ 明确表示 $\\beta^2$。这种形式是无歧义的，因为它避免了为求解 $\\beta$ 而取平方根时所涉及的符号和支割选择。",
            "answer": "$$ \\boxed{\\beta^{2} = k^{2} - \\lambda} $$"
        },
        {
            "introduction": "然而，当使用简单的节点基函数求解矢量场问题时，标准的有限元方法会产生被称为“伪模式”的非物理数值伪影。本练习将介绍一种主动解决该问题的关键技术：在弱形式中引入“grad-div”稳定项以惩罚非物理的解。您将通过编码实现该方法，并比较稳定化前后本征谱的变化，从而直观地验证其对伪模式的抑制效果。",
            "id": "3291444",
            "problem": "考虑一个填充有均匀各向同性介质的二维矩形腔中的时谐麦克斯韦特征问题，其边界为理想电导体（PEC），并采用有限元法（FEM）进行离散化。令 $\\mathbf{E}$ 表示平面内的电场。该理想电导体腔内电场的特征问题的强形式是，求解非平凡的 $\\mathbf{E}$ 和 $\\omega^2$，使得\n$$\\nabla \\times (\\nabla \\times \\mathbf{E}) = \\omega^2 \\mathbf{E} \\quad \\text{in } \\Omega,$$\n并在边界 $\\partial \\Omega$ 上满足理想电导体边界条件 $\\mathbf{E} = \\mathbf{0}$。为了暴露在使用节点（Lagrange）基函数表示矢量场时出现的伪梯度模式，我们考虑一种弱形式，它在旋度-旋度双线性形式的基础上增广了一个梯度-散度稳定项。在无量纲单位下，设 $\\epsilon = 1$ 和 $\\mu = 1$，稳定化的弱形式为：求解非平凡的 $\\mathbf{E}_h$ 和 $\\lambda$，使得\n$$\\int_{\\Omega} \\left(\\nabla \\times \\mathbf{E}_h\\right)\\left(\\nabla \\times \\mathbf{v}_h\\right)\\, d\\Omega + \\eta \\int_{\\Omega} \\left(\\nabla \\cdot \\mathbf{E}_h\\right)\\left(\\nabla \\cdot \\mathbf{v}_h\\right)\\, d\\Omega = \\lambda \\int_{\\Omega} \\mathbf{E}_h \\cdot \\mathbf{v}_h \\, d\\Omega,$$\n对于所有在 $\\partial \\Omega$ 上为零的测试函数 $\\mathbf{v}_h$ 成立，其中 $\\eta \\ge 0$ 是一个标量稳定化参数。当 $\\eta = 0$ 时，节点有限元法会产生具有近零特征值的伪梯度模式（因为这些模式的旋度为零但散度非零），而当 $\\eta > 0$ 时，稳定项会惩罚散度，通过将其特征值推离零点来抑制这些模式。\n\n从麦克斯韦方程组和能量原理出发，在 $\\Omega = [0,1] \\times [0,1]$ 上实现一个二维有限元法，对矢量场 $\\mathbf{E} = (E_x, E_y)$ 使用三角形网格上的线性 Lagrange 基函数。在 $\\partial \\Omega$ 上施加齐次狄利克雷边界条件 $E_x = 0$ 和 $E_y = 0$。组装以下矩阵：\n- 由双线性形式 $\\int_{\\Omega} (\\nabla \\times \\mathbf{E}_h)(\\nabla \\times \\mathbf{v}_h)\\, d\\Omega$ 定义的旋度-旋度刚度矩阵 $K_{\\mathrm{curl}}$。\n- 由双线性形式 $\\int_{\\Omega} (\\nabla \\cdot \\mathbf{E}_h)(\\nabla \\cdot \\mathbf{v}_h)\\, d\\Omega$ 定义的梯度-散度刚度矩阵 $K_{\\mathrm{div}}$。\n- 由双线性形式 $\\int_{\\Omega} \\mathbf{E}_h \\cdot \\mathbf{v}_h \\, d\\Omega$ 定义的质量矩阵 $M$。\n\n建立广义特征值问题\n$$\\left(K_{\\mathrm{curl}} + \\eta K_{\\mathrm{div}}\\right)\\mathbf{u} = \\lambda M \\mathbf{u},$$\n并使用移位-求逆策略求解 $\\lambda = 0$ 附近的最小模特征值，以暴露伪模式。\n\n您的程序必须：\n- 在 $x$ 和 $y$ 方向上分别使用 $(n_x, n_y)$ 个均匀细分，生成 $\\Omega$ 的结构化三角形网格。每个矩形单元被分割成两个三角形。\n- 为 $K_{\\mathrm{curl}}$、$K_{\\mathrm{div}}$ 和 $M$ 组装稀疏全局矩阵，并通过移除边界自由度来施加两个分量的齐次狄利克雷边界条件。\n- 对每个测试用例，计算广义特征值问题中最接近 $\\lambda = 0$ 的 $k$ 个特征值，并统计其中满足 $|\\lambda| < \\tau$ 的特征值数量，其中 $\\tau$ 是一个预设阈值。该计数可作为零点附近伪模式存在的定量度量。\n\n使用无量纲单位，$\\epsilon = 1$ 和 $\\mu = 1$，因此不需要进行物理单位转换。计算中不涉及角度。所有输出均为纯数。\n\n测试套件：\n- 情况A（正常路径，未稳定）：$(n_x, n_y, \\eta, k, \\tau) = (8, 8, 0.0, 30, 10^{-10})$。\n- 情况B（正常路径，稳定）：$(n_x, n_y, \\eta, k, \\tau) = (8, 8, 10^{-2}, 30, 10^{-10})$。\n- 情况C（网格细化，未稳定）：$(n_x, n_y, \\eta, k, \\tau) = (12, 12, 0.0, 30, 10^{-10})$。\n- 情况D（网格细化，稳定）：$(n_x, n_y, \\eta, k, \\tau) = (12, 12, 10^{-2}, 30, 10^{-10})$。\n- 情况E（边界情况，强稳定）：$(n_x, n_y, \\eta, k, \\tau) = (8, 8, 1.0, 30, 10^{-10})$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，“[resultA,resultB,resultC,resultD,resultE]”）。每个结果必须是对应测试用例中满足 $|\\lambda| < \\tau$ 的特征值计数的整数。",
            "solution": "用户要求实现有限元法（FEM）来求解二维矩形腔中的麦克斯韦特征问题。主要目标是展示梯度-散度稳定项对使用节点（Lagrange）矢量基函数时产生的伪非物理模式的影响。\n\n该问题是有效的，因为它在科学上基于计算电磁学原理，所有必要的参数和条件都已定义，问题是适定的，并且其表述是客观的。我们将基于用户提供的弱形式进行求解。\n\n电场 $\\mathbf{E}_h$ 的弱形式是求解特征对 $(\\lambda, \\mathbf{E}_h)$，使得对于所有容许的测试函数 $\\mathbf{v}_h$：\n$$\na(\\mathbf{E}_h, \\mathbf{v}_h) = \\lambda m(\\mathbf{E}_h, \\mathbf{v}_h)\n$$\n其中 $\\lambda = \\omega^2$ 是特征值，双线性形式由下式给出：\n$$\na(\\mathbf{E}_h, \\mathbf{v}_h) = \\int_{\\Omega} (\\nabla \\times \\mathbf{E}_h)(\\nabla \\times \\mathbf{v}_h)\\, d\\Omega + \\eta \\int_{\\Omega} (\\nabla \\cdot \\mathbf{E}_h)(\\nabla \\cdot \\mathbf{v}_h)\\, d\\Omega\n$$\n$$\nm(\\mathbf{E}_h, \\mathbf{v}_h) = \\int_{\\Omega} \\mathbf{E}_h \\cdot \\mathbf{v}_h \\, d\\Omega\n$$\n域为单位正方形 $\\Omega = [0,1] \\times [0,1]$，稳定化参数为 $\\eta \\ge 0$。边界条件为在边界 $\\partial\\Omega$ 上 $\\mathbf{E}_h = \\mathbf{0}$。\n\n该求解方案通过有限元法实现，在结构化三角形网格上使用线性 Lagrange 基函数。\n\n1.  **离散化与基函数**\n    将域 $\\Omega$ 剖分成三角形单元。在每个单元内，使用线性基函数来近似矢量电场 $\\mathbf{E}_h = (E_x, E_y)$。在网格的每个节点 $i$ 上，我们关联两个自由度（DOF），对应于电场的 $x$ 和 $y$ 分量，即 $(u_{ix}, u_{iy})$。因此，场的近似表示为：\n    $$\n    \\mathbf{E}_h(x,y) = \\sum_{i=1}^{N_{nodes}} \\left( u_{ix} N_i(x,y) \\hat{x} + u_{iy} N_i(x,y) \\hat{y} \\right) = \\sum_{i=1}^{N_{nodes}} \\left( u_{ix} \\mathbf{N}_{ix} + u_{iy} \\mathbf{N}_{iy} \\right)\n    $$\n    其中 $N_i$ 是标量线性（P1）Lagrange 基函数，而 $\\mathbf{N}_{ix} = N_i \\hat{x}$ 和 $\\mathbf{N}_{iy} = N_i \\hat{y}$ 是矢量基函数。\n\n2.  **单元矩阵公式**\n    将 $\\mathbf{E}_h$ 的展开式代入，并使用来自同一基函数空间的 $\\mathbf{v}_h$，我们得到一个广义矩阵特征值问题 $(K_{\\mathrm{curl}} + \\eta K_{\\mathrm{div}})\\mathbf{u} = \\lambda M \\mathbf{u}$。全局矩阵由单元贡献组装而成。对于具有节点 $i, j, k \\in \\{1, 2, 3\\}$ 的单个三角形单元 $\\Omega_e$，计算 $6 \\times 6$ 的单元矩阵。基函数 $N_i$ 在该单元上具有常梯度。\n\n    *   **单元质量矩阵 ($M^e$)**：表示基函数的内积。\n        $$\n        M^e_{(i\\alpha)(j\\beta)} = \\int_{\\Omega_e} \\mathbf{N}_{i\\alpha} \\cdot \\mathbf{N}_{j\\beta} \\, d\\Omega_e = \\delta_{\\alpha\\beta} \\int_{\\Omega_e} N_i N_j \\, d\\Omega_e\n        $$\n        其中 $\\alpha, \\beta \\in \\{x, y\\}$。这会得到一个块对角矩阵，其块是标量质量矩阵。对于线性三角形，$\\int_{\\Omega_e} N_i N_j \\, d\\Omega_e = \\frac{A_e}{12}(1+\\delta_{ij})$，其中 $A_e$ 是单元面积。\n\n    *   **单元旋度-旋度刚度矩阵 ($K^e_{\\mathrm{curl}}$)**：对于二维平面内场，$\\nabla \\times \\mathbf{N}_{ix} = -\\frac{\\partial N_i}{\\partial y}\\hat{z}$ 和 $\\nabla \\times \\mathbf{N}_{iy} = \\frac{\\partial N_i}{\\partial x}\\hat{z}$。\n        $$\n        K^e_{\\mathrm{curl}, (i\\alpha)(j\\beta)} = \\int_{\\Omega_e} (\\nabla \\times \\mathbf{N}_{i\\alpha}) \\cdot (\\nabla \\times \\mathbf{N}_{j\\beta}) \\, d\\Omega_e\n        $$\n        该矩阵的 $(i,j)$ 块是 $A_e \\begin{pmatrix} \\frac{\\partial N_i}{\\partial y}\\frac{\\partial N_j}{\\partial y}  -\\frac{\\partial N_i}{\\partial y}\\frac{\\partial N_j}{\\partial x} \\\\ -\\frac{\\partial N_i}{\\partial x}\\frac{\\partial N_j}{\\partial y}  \\frac{\\partial N_i}{\\partial x}\\frac{\\partial N_j}{\\partial x} \\end{pmatrix}$。\n\n    *   **单元梯度-散度刚度矩阵 ($K^e_{\\mathrm{div}}$)**：散度为 $\\nabla \\cdot \\mathbf{N}_{ix} = \\frac{\\partial N_i}{\\partial x}$ 和 $\\nabla \\cdot \\mathbf{N}_{iy} = \\frac{\\partial N_i}{\\partial y}$。\n        $$\n        K^e_{\\mathrm{div}, (i\\alpha)(j\\beta)} = \\int_{\\Omega_e} (\\nabla \\cdot \\mathbf{N}_{i\\alpha}) (\\nabla \\cdot \\mathbf{N}_{j\\beta}) \\, d\\Omega_e\n        $$\n        该矩阵的 $(i,j)$ 块是 $A_e \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x}\\frac{\\partial N_j}{\\partial x}  \\frac{\\partial N_i}{\\partial x}\\frac{\\partial N_j}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y}\\frac{\\partial N_j}{\\partial x}  \\frac{\\partial N_i}{\\partial y}\\frac{\\partial N_j}{\\partial y} \\end{pmatrix}$。\n\n3.  **组装与边界条件**\n    生成一个具有 $(n_x, n_y)$ 个细分的结构化网格。每个矩形单元被分割成两个三角形。为每个三角形计算单元矩阵，并组装成全局稀疏矩阵。通过从最终的线性系统中消除与边界节点相关的所有自由度，来施加齐次狄利克雷边界条件 $E_x=0$ 和 $E_y=0$ on $\\partial\\Omega$。这会得到一个仅包含内部自由度的降阶方程组。\n\n4.  **特征值求解**\n    待求解的系统是 $(K_{red} + \\eta K_{\\mathrm{div},red})\\mathbf{u}_{int} = \\lambda M_{red}\\mathbf{u}_{int}$，其中下标 'red' 表示已缩减到内部自由度集合的矩阵。为了找到最接近零的特征值 $\\lambda$，采用了移位-求逆谱变换。问题被改写为求解 $(K_{sys} - \\sigma M)^{-1} M$ 的最大模特征值，其中 $K_{sys} = K_{red} + \\eta K_{\\mathrm{div},red}$，$\\sigma$ 是一个小的位移（例如 $\\sigma = 10^{-8}$）。这个问题可以使用 `scipy.sparse.linalg.eigsh` 中实现的 Lanczos 算法高效求解。\n\n5.  **伪模式分析**\n    对于未稳定化的情况（$\\eta = 0$），旋度-旋度算子的核包含无旋的梯度场（$\\mathbf{E} = \\nabla \\phi$）。节点单元支持这种非物理模式，其表现为数值上接近零的特征值。这些伪模式的数量与内部节点的数量有关。当施加稳定化（$\\eta > 0$）时，梯度-散度项会惩罚这些模式，因为它们通常具有非零的散度。这将它们对应的特征值推离零点，从而有效地“清理”了低频频谱。程序通过计算模小于阈值 $\\tau=10^{-10}$ 的特征值数量，来量化这些伪模式的存在。\n\n该实现对问题陈述中提供的每个测试用例都遵循以上步骤。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import eigsh\nfrom scipy.linalg import LinAlgError\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (nx, ny, eta, k, tau)\n        (8, 8, 0.0, 30, 1e-10),       # Case A\n        (8, 8, 1e-2, 30, 1e-10),      # Case B\n        (12, 12, 0.0, 30, 1e-10),     # Case C\n        (12, 12, 1e-2, 30, 1e-10),    # Case D\n        (8, 8, 1.0, 30, 1e-10),       # Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        nx, ny, eta, k, tau = case\n        count = run_fem_simulation(nx, ny, eta, k, tau)\n        results.append(count)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_fem_simulation(nx, ny, eta, k, tau):\n    \"\"\"\n    Performs the FEM simulation for a single test case.\n    \"\"\"\n    # 1. Mesh Generation\n    num_nodes_x = nx + 1\n    num_nodes_y = ny + 1\n    total_nodes = num_nodes_x * num_nodes_y\n    \n    nodes = np.array([[i / nx, j / ny] for i in range(num_nodes_x) for j in range(num_nodes_y)])\n\n    elements = []\n    for i in range(nx):\n        for j in range(ny):\n            p1 = i * num_nodes_y + j\n            p2 = (i + 1) * num_nodes_y + j\n            p3 = (i + 1) * num_nodes_y + (j + 1)\n            p4 = i * num_nodes_y + (j + 1)\n            elements.append([p1, p2, p3])\n            elements.append([p1, p3, p4])\n    elements = np.array(elements, dtype=int)\n\n    # 2. DOF mapping and Boundary Conditions\n    total_dofs = 2 * total_nodes\n    is_internal_dof = np.ones(total_dofs, dtype=bool)\n    \n    for i in range(num_nodes_x):\n        for j in range(num_nodes_y):\n            if i == 0 or i == nx or j == 0 or j == ny:\n                node_idx = i * num_nodes_y + j\n                is_internal_dof[2 * node_idx] = False\n                is_internal_dof[2 * node_idx + 1] = False\n    \n    num_internal_dofs = np.sum(is_internal_dof)\n    internal_dofs_map = -np.ones(total_dofs, dtype=int)\n    internal_dofs_map[is_internal_dof] = np.arange(num_internal_dofs)\n\n    # 3. Matrix Assembly\n    K_curl = lil_matrix((num_internal_dofs, num_internal_dofs), dtype=np.float64)\n    K_div = lil_matrix((num_internal_dofs, num_internal_dofs), dtype=np.float64)\n    M = lil_matrix((num_internal_dofs, num_internal_dofs), dtype=np.float64)\n\n    Me_scalar_template = (1.0 / 12.0) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n\n    for el_nodes in elements:\n        p1, p2, p3 = nodes[el_nodes]\n        area = 0.5 * np.abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n        \n        b = np.array([p2[1]-p3[1], p3[1]-p1[1], p1[1]-p2[1]])\n        c = np.array([p3[0]-p2[0], p1[0]-p3[0], p2[0]-p1[0]])\n        grad_N = (1.0 / (2.0 * area)) * np.vstack((c, b)).T\n        \n        Ke_curl = np.zeros((6, 6))\n        Ke_div = np.zeros((6, 6))\n        \n        for i in range(3):\n            for j in range(3):\n                Ke_curl[2*i, 2*j]     = grad_N[i, 1] * grad_N[j, 1]\n                Ke_curl[2*i, 2*j+1]   = -grad_N[i, 1] * grad_N[j, 0]\n                Ke_curl[2*i+1, 2*j]   = -grad_N[i, 0] * grad_N[j, 1]\n                Ke_curl[2*i+1, 2*j+1] = grad_N[i, 0] * grad_N[j, 0]\n                \n                Ke_div[2*i, 2*j]     = grad_N[i, 0] * grad_N[j, 0]\n                Ke_div[2*i, 2*j+1]   = grad_N[i, 0] * grad_N[j, 1]\n                Ke_div[2*i+1, 2*j]   = grad_N[i, 1] * grad_N[j, 0]\n                Ke_div[2*i+1, 2*j+1] = grad_N[i, 1] * grad_N[j, 1]\n\n        Ke_curl *= area\n        Ke_div *= area\n        Me_scalar = Me_scalar_template * area\n\n        for i in range(3):\n            dof_map_i = [internal_dofs_map[2 * el_nodes[i]], internal_dofs_map[2 * el_nodes[i] + 1]]\n            for j in range(3):\n                dof_map_j = [internal_dofs_map[2 * el_nodes[j]], internal_dofs_map[2 * el_nodes[j] + 1]]\n                \n                if dof_map_i[0] != -1 and dof_map_j[0] != -1: # Kxx, Mxx\n                    K_curl[dof_map_i[0], dof_map_j[0]] += Ke_curl[2*i, 2*j]\n                    K_div[dof_map_i[0], dof_map_j[0]] += Ke_div[2*i, 2*j]\n                    M[dof_map_i[0], dof_map_j[0]] += Me_scalar[i, j]\n                if dof_map_i[0] != -1 and dof_map_j[1] != -1: # Kxy\n                    K_curl[dof_map_i[0], dof_map_j[1]] += Ke_curl[2*i, 2*j+1]\n                    K_div[dof_map_i[0], dof_map_j[1]] += Ke_div[2*i, 2*j+1]\n                if dof_map_i[1] != -1 and dof_map_j[0] != -1: # Kyx\n                    K_curl[dof_map_i[1], dof_map_j[0]] += Ke_curl[2*i+1, 2*j]\n                    K_div[dof_map_i[1], dof_map_j[0]] += Ke_div[2*i+1, 2*j]\n                if dof_map_i[1] != -1 and dof_map_j[1] != -1: # Kyy, Myy\n                    K_curl[dof_map_i[1], dof_map_j[1]] += Ke_curl[2*i+1, 2*j+1]\n                    K_div[dof_map_i[1], dof_map_j[1]] += Ke_div[2*i+1, 2*j+1]\n                    M[dof_map_i[1], dof_map_j[1]] += Me_scalar[i, j]\n\n    # 4. Solve Eigenproblem\n    K_curl = K_curl.tocsc()\n    K_div = K_div.tocsc()\n    M = M.tocsc()\n    \n    K_sys = K_curl + eta * K_div\n    \n    try:\n        eigenvalues, _ = eigsh(K_sys, k=k, M=M, sigma=1e-8, which='LM', tol=1e-9)\n    except LinAlgError:\n        # Fallback for rare singularity cases, e.g. with eta=0 and unlucky shift\n        eigenvalues, _ = eigsh(K_sys, k=k, M=M, sigma=-1e-8, which='LM', tol=1e-9)\n\n    # 5. Count spurious modes\n    return np.sum(np.abs(eigenvalues)  tau)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "除了在求解过程中抑制伪模式，另一种同样重要的方法是在求解后对其进行识别和过滤。本练习将教授您如何基于高斯定律 $\\nabla \\cdot (\\epsilon \\mathbf{E}) = 0$ 这一物理约束，构建一个后处理诊断工具。通过计算每个本征模的散度范数，您将能够量化其物理真实性，并自动筛除那些不满足无散条件的伪模式解。",
            "id": "3291510",
            "problem": "您的任务是设计并实现一种数值诊断方法，用以在使用有限元方法 (FEM) 进行腔体和波导分析时识别伪本征模。该诊断方法必须为离散电磁本征向量计算 $$\\left\\lVert \\nabla \\cdot \\left(\\epsilon \\mathbf{E}_h \\right)\\right\\rVert_{L^2(\\Omega)}$$ 这一量，并且必须输出一个布尔分类，以指明每个模式是否为伪模式。\n\n您的推导必须从频域中无源、理想电导体腔体的麦克斯韦方程组出发：$$\\nabla \\times \\left(\\mu^{-1} \\nabla \\times \\mathbf{E} \\right) = \\omega^2 \\epsilon \\mathbf{E}, \\quad \\nabla \\cdot \\left(\\epsilon \\mathbf{E} \\right) = 0 \\quad \\text{in } \\Omega,$$，边界 $\\partial \\Omega$ 上具有均匀边界条件。第二个关系是高斯电场定律，它强制要求在没有自由电荷的情况下，物理腔体本征模满足 $\\nabla \\cdot \\left(\\epsilon \\mathbf{E}\\right) = 0$。不恰当的离散化或混合边界处理可能会产生不满足此条件的非物理解，从而导致伪模式。您的诊断方法旨在检测这些非物理模式。\n\n您将使用区域三角剖分上的连续分片线性矢量近似来逼近矢量场，并计算该区域上 $L^2$ 范数下的散度残差。为使此测试自成体系且可普遍实现，我们为您提供以下精确的计算设置。\n\n- 域和网格：\n  - 计算域为 $\\Omega = [0,1] \\times [0,1]$。\n  - 使用结构化三角网格，该网格通过将 $\\Omega$ 细分为 $N_x \\times N_y$ 个矩形单元，并沿每个矩形从左下角到右上角的对角线将其分割成两个三角形而生成。\n  - 对于此任务，请使用 $N_x = N_y = 40$。\n  - 令 $h$ 表示网格中所有三角形的最大边长。\n\n- 材料模型：\n  - 考虑两种介电常数模型：\n    1. 均匀介电常数：$\\epsilon(x,y) = 1$。\n    2. 平滑变化的介电常数：$$\\epsilon(x,y) = 1 + 0.5 \\sin\\left(2\\pi x\\right)\\sin\\left(2\\pi y\\right),$$ 其梯度为 $$\\nabla \\epsilon(x,y) = \\pi \\begin{bmatrix} \\cos\\left(2\\pi x\\right)\\sin\\left(2\\pi y\\right) \\\\ \\sin\\left(2\\pi x\\right)\\cos\\left(2\\pi y\\right) \\end{bmatrix}.$$\n  - 在所有情况下，使用上确界范数 $\\lVert \\epsilon \\rVert_{L^\\infty(\\Omega)}$ 来归一化诊断。您必须通过在所有网格节点上采样 $\\epsilon$ 并取其最大值来数值计算 $\\lVert \\epsilon \\rVert_{L^\\infty(\\Omega)}$。\n\n- 离散场表示：\n  - 每个测试矢量场都以解析形式提供，然后在网格节点处进行采样，从而得到节点值，形成分片线性矢量场 $\\mathbf{E}_h = \\left[E_{x,h}, E_{y,h}\\right]^T$。\n  - 对于一个具有顶点 $\\{\\mathbf{x}_i\\}_{i=1}^3$ 和局部分片线性基函数 $\\{\\varphi_i\\}_{i=1}^3$ 的三角形，离散分量为 $E_{x,h}(\\mathbf{x}) = \\sum_{i=1}^3 E_{x,i}\\,\\varphi_i(\\mathbf{x})$ 和 $E_{y,h}(\\mathbf{x}) = \\sum_{i=1}^3 E_{y,i}\\,\\varphi_i(\\mathbf{x})$。\n  - 在每个三角形 $K$ 上，$\\epsilon \\mathbf{E}_h$ 的散度使用以下公式计算：$$\\nabla \\cdot \\left(\\epsilon \\mathbf{E}_h\\right)\\big|_K \\approx \\epsilon(\\mathbf{x}_K)\\left(\\frac{\\partial E_{x,h}}{\\partial x} + \\frac{\\partial E_{y,h}}{\\partial y}\\right)\\Bigg|_K + \\nabla \\epsilon(\\mathbf{x}_K)\\cdot \\mathbf{E}_h(\\mathbf{x}_K),$$ 其中 $\\mathbf{x}_K$ 是 $K$ 的形心，梯度 $\\frac{\\partial E_{x,h}}{\\partial x}$ 和 $\\frac{\\partial E_{y,h}}{\\partial y}$ 在 $K$ 上是常数（根据线性形函数），而 $\\mathbf{E}_h(\\mathbf{x}_K)$ 是通过对 $K$ 上的节点值取平均得到的。\n\n- 范数与诊断：\n  - 使用形心求积来近似 $L^2$ 范数：\n    $$\\left\\lVert \\nabla \\cdot \\left(\\epsilon \\mathbf{E}_h\\right) \\right\\rVert_{L^2(\\Omega)} \\approx \\left( \\sum_{K} \\left|\\nabla \\cdot \\left(\\epsilon \\mathbf{E}_h\\right)\\big|_K\\right|^2\\,|K| \\right)^{1/2}, \\quad \\left\\lVert \\mathbf{E}_h \\right\\rVert_{L^2(\\Omega)} \\approx \\left( \\sum_K \\left\\lVert \\mathbf{E}_h(\\mathbf{x}_K)\\right\\rVert_2^2\\,|K| \\right)^{1/2},$$ 其中 $|K|$ 是三角形 $K$ 的面积。\n  - 定义无量纲散度诊断 $$D = \\frac{\\left\\lVert \\nabla \\cdot \\left(\\epsilon \\mathbf{E}_h\\right)\\right\\rVert_{L^2(\\Omega)}}{\\lVert \\epsilon \\rVert_{L^\\infty(\\Omega)}\\,\\left\\lVert \\mathbf{E}_h \\right\\rVert_{L^2(\\Omega)} + \\delta},$$ 其中 $\\delta = 10^{-14}$ 作为防止除以零的保护措施。\n  - 伪模式滤波器阈值：受高斯定律和有限元插值误差估计的启发，采用形式为 $$\\Theta(h) = c_0\\,h,$$ 的定量阈值，并在此任务中设置 $c_0 = 50$。当且仅当 $D \\ge \\Theta(h)$ 时，将模式分类为伪模式。\n\n- 测试套件：\n  - 程序必须对以下 $5$ 个测试场进行诊断评估和分类。在所有情况下，角度均以弧度为单位。\n    1. 均匀介电常数 $\\epsilon(x,y) = 1$；无散场 $$\\mathbf{E}(x,y) = \\begin{bmatrix} \\sin\\left(\\pi x\\right)\\cos\\left(\\pi y\\right) \\\\ -\\cos\\left(\\pi x\\right)\\sin\\left(\\pi y\\right) \\end{bmatrix}.$$\n    2. 均匀介电常数 $\\epsilon(x,y) = 1$；无旋场（势模）$$\\mathbf{E}(x,y) = \\nabla \\left[\\sin\\left(\\pi x\\right)\\sin\\left(\\pi y\\right)\\right] = \\pi \\begin{bmatrix}\\cos\\left(\\pi x\\right)\\sin\\left(\\pi y\\right) \\\\ \\sin\\left(\\pi x\\right)\\cos\\left(\\pi y\\right) \\end{bmatrix}.$$\n    3. 平滑介电常数 $\\epsilon(x,y) = 1 + 0.5 \\sin\\left(2\\pi x\\right)\\sin\\left(2\\pi y\\right)$；无散位移场构造 $$\\mathbf{E}(x,y) = \\frac{1}{\\epsilon(x,y)}\\begin{bmatrix} -\\frac{\\partial \\psi}{\\partial y}(x,y) \\\\ \\frac{\\partial \\psi}{\\partial x}(x,y) \\end{bmatrix}, \\quad \\psi(x,y) = \\sin\\left(\\pi x\\right)\\sin\\left(\\pi y\\right),$$ 该场解析地满足 $\\nabla \\cdot \\left(\\epsilon \\mathbf{E}\\right) = 0$。\n    4. 均匀介电常数 $\\epsilon(x,y) = 1$；零场 $$\\mathbf{E}(x,y) = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}.$$\n    5. 均匀介电常数 $\\epsilon(x,y) = 1$；结合了无旋和螺线管部分的混合场 $$\\mathbf{E}(x,y) = 0.5\\,\\nabla \\left[\\sin\\left(\\pi x\\right)\\sin\\left(\\pi y\\right)\\right] + 0.05\\,\\begin{bmatrix} \\sin\\left(\\pi x\\right)\\cos\\left(\\pi y\\right) \\\\ -\\cos\\left(\\pi x\\right)\\sin\\left(\\pi y\\right) \\end{bmatrix}.$$\n\n- 所需输出：\n  - 对 $5$ 个测试场中的每一个，计算诊断值 $D$，计算 $\\Theta(h)$，并根据规则 $D \\ge \\Theta(h)$ 输出一个布尔分类，如果模式是伪模式则为 $\\text{True}$，否则为 $\\text{False}$。\n  - 无需报告物理单位，因为诊断值 $D$ 是无量纲的，且输出是布尔值。\n  - 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按上述 $5$ 个测试案例的顺序排列，例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$。",
            "solution": "问题陈述提出了一个在计算电磁学中明确定义的任务：开发并应用一种数值诊断方法，用于识别电磁腔体有限元 (FE) 模拟中的伪非物理解。该问题在科学上基于麦克斯韦方程组，特别是对电位移场的散度约束 $\\nabla \\cdot (\\epsilon \\mathbf{E}) = 0$。它为实现提供了完整且明确的指令集，包括域、网格结构、材料模型、解析测试场以及计算诊断指标的精确算法。所有参数都已明确定义，使得问题自成体系且适定。验证标准已满足，该问题被认为是有效的。\n\n解决方案将通过遵循规定的算法步骤来实现，为五个指定的测试案例中的每一个计算无量纲散度诊断值 $D$。如果一个模式的诊断值 $D$ 超过了随网格尺寸 $h$ 变化的阈值 $\\Theta(h)$，则该模式被分类为伪模式。\n\n算法的核心涉及在域 $\\Omega = [0,1] \\times [0,1]$ 上对两个 $L^2$ 范数进行数值近似。该域使用一个由 $N_x \\times N_y = 40 \\times 40$ 个矩形单元组成的结构化网格进行离散化，其中每个单元被细分为两个三角形。最大网格边长为 $h = \\sqrt{(1/N_x)^2 + (1/N_y)^2} = \\sqrt{2}/40$。\n\n对于每个测试案例，算法按以下步骤进行：\n\n1.  **场与材料定义**：为特定测试案例定义电场 $\\mathbf{E}(x,y)$、介电常数 $\\epsilon(x,y)$ 及其梯度 $\\nabla\\epsilon(x,y)$ 的解析函数。\n\n2.  **介电常数的 $L^\\infty$ 范数**：通过创建一个 $(N_x+1) \\times (N_y+1)$ 的节点网格，并找到在这些节点上计算的 $\\epsilon(x,y)$ 的最大值，来数值近似上确界范数 $\\lVert \\epsilon \\rVert_{L^\\infty(\\Omega)}$。\n\n3.  **在三角形上的数值积分**：一个循环遍历网格中的每个三角形 $K$。对于每个三角形，使用形心求积法则计算以下量：\n    *   **节点值**：在三角形的三个顶点上对解析矢量场 $\\mathbf{E}(x,y)$ 进行采样，得到节点值 $\\{\\mathbf{E}_1, \\mathbf{E}_2, \\mathbf{E}_3\\}$，这些值定义了在 $K$ 上的分片线性 FE 近似 $\\mathbf{E}_h$。\n    *   **$\\mathbf{E}_h$ 的散度**：分片线性函数的梯度在三角形上是常数。对于一个分量 $E_{j,h} = \\sum_{i=1}^3 E_{j,i} \\varphi_i$，其中 $\\varphi_i$ 是线性基函数，其在顶点为 $\\{\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3\\}$ 的 $K$ 上的空间导数通过以下方式计算：\n        $$ \\frac{\\partial E_{j,h}}{\\partial x} = \\frac{1}{2|K|} \\sum_{i=1}^3 E_{j,i} (y_{i+1}-y_{i-1}) \\quad (\\text{循环索引 } i \\in \\{1,2,3\\}) $$\n        以及一个用于 $\\frac{\\partial E_{j,h}}{\\partial y}$ 的类似表达式。三角形上的散度则为 $\\nabla \\cdot \\mathbf{E}_h|_K = \\frac{\\partial E_{x,h}}{\\partial x} + \\frac{\\partial E_{y,h}}{\\partial y}$。\n    *   **形心求值**：计算三角形的形心 $\\mathbf{x}_K$。计算 $\\epsilon(\\mathbf{x}_K)$、$\\nabla\\epsilon(\\mathbf{x}_K)$ 和 $\\mathbf{E}_h(\\mathbf{x}_K)$ 的值。按照规定，$\\mathbf{E}_h(\\mathbf{x}_K)$ 是 $K$ 上节点值的平均值。\n    *   **$\\epsilon \\mathbf{E}_h$ 的散度**：加权场在三角形上的散度近似为：\n        $$ \\nabla \\cdot (\\epsilon \\mathbf{E}_h)|_K = \\epsilon(\\mathbf{x}_K) (\\nabla \\cdot \\mathbf{E}_h|_K) + \\nabla\\epsilon(\\mathbf{x}_K) \\cdot \\mathbf{E}_h(\\mathbf{x}_K) $$\n    *   **$L^2$ 范数的贡献**：三角形 $K$ 对 $L^2$ 范数平方的贡献计算为 $|\\nabla \\cdot (\\epsilon \\mathbf{E}_h)|_K|^2 |K|$ 和 $\\lVert \\mathbf{E}_h(\\mathbf{x}_K) \\rVert_2^2|K|$，其中 $|K|$ 是三角形的面积。这些贡献将在所有三角形上求和。\n\n4.  **诊断计算与分类**：遍历所有三角形后，通过对累积和取平方根来获得最终的范数：\n    $$ D = \\frac{\\left( \\sum_{K} |\\nabla \\cdot (\\epsilon \\mathbf{E}_h)|_K|^2 |K| \\right)^{1/2}}{\\lVert \\epsilon \\rVert_{L^\\infty(\\Omega)} \\left( \\sum_K \\lVert \\mathbf{E}_h(\\mathbf{x}_K) \\rVert_2^2|K| \\right)^{1/2} + \\delta} $$\n    其中 $\\delta = 10^{-14}$ 是一个正则化参数。然后将诊断值 $D$ 与阈值 $\\Theta(h) = c_0 h = 50 h$ 进行比较。如果 $D \\ge \\Theta(h)$，则模式被分类为伪模式 (True)，否则为非伪模式 (False)。\n\n该过程将应用于所有五个测试案例，从而得出一系列布尔分类。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a spurious mode diagnostic for several test electromagnetic fields.\n    \"\"\"\n\n    # Test cases defined as a list of dictionaries.\n    # Each dictionary holds the functions for E, epsilon, and gradient of epsilon.\n    test_cases_defs = [\n        # Case 1: Uniform epsilon, solenoidal (divergence-free) E\n        {\n            \"E_func\": lambda x, y: np.array([np.sin(np.pi * x) * np.cos(np.pi * y),\n                                            -np.cos(np.pi * x) * np.sin(np.pi * y)]),\n            \"eps_func\": lambda x, y: 1.0 + 0*x, # Ensure it works with array inputs\n            \"grad_eps_func\": lambda x, y: np.array([0.0, 0.0])\n        },\n        # Case 2: Uniform epsilon, irrotational (gradient) E\n        {\n            \"E_func\": lambda x, y: np.array([np.pi * np.cos(np.pi * x) * np.sin(np.pi * y),\n                                            np.pi * np.sin(np.pi * x) * np.cos(np.pi * y)]),\n            \"eps_func\": lambda x, y: 1.0 + 0*x,\n            \"grad_eps_func\": lambda x, y: np.array([0.0, 0.0])\n        },\n        # Case 3: Smooth epsilon, solenoidal D=epsilon*E\n        {\n            \"E_func\": lambda x, y: np.array([\n                -np.pi * np.sin(np.pi * x) * np.cos(np.pi * y),\n                 np.pi * np.cos(np.pi * x) * np.sin(np.pi * y)\n            ]) / (1.0 + 0.5 * np.sin(2.0 * np.pi * x) * np.sin(2.0 * np.pi * y)),\n            \"eps_func\": lambda x, y: 1.0 + 0.5 * np.sin(2.0 * np.pi * x) * np.sin(2.0 * np.pi * y),\n            \"grad_eps_func\": lambda x, y: np.array([\n                np.pi * np.cos(2.0 * np.pi * x) * np.sin(2.0 * np.pi * y),\n                np.pi * np.sin(2.0 * np.pi * x) * np.cos(2.0 * np.pi * y)\n            ])\n        },\n        # Case 4: Uniform epsilon, zero E\n        {\n            \"E_func\": lambda x, y: np.array([0.0, 0.0]),\n            \"eps_func\": lambda x, y: 1.0 + 0*x,\n            \"grad_eps_func\": lambda x, y: np.array([0.0, 0.0])\n        },\n        # Case 5: Uniform epsilon, mixed solenoidal and irrotational E\n        {\n            \"E_func\": lambda x, y: 0.5 * np.array([np.pi * np.cos(np.pi * x) * np.sin(np.pi * y),\n                                                  np.pi * np.sin(np.pi * x) * np.cos(np.pi * y)]) + \\\n                                   0.05 * np.array([np.sin(np.pi * x) * np.cos(np.pi * y),\n                                                   -np.cos(np.pi * x) * np.sin(np.pi * y)]),\n            \"eps_func\": lambda x, y: 1.0 + 0*x,\n            \"grad_eps_func\": lambda x, y: np.array([0.0, 0.0])\n        }\n    ]\n\n    results = []\n    \n    # Common problem parameters\n    Nx, Ny = 40, 40\n    c0 = 50.0\n    delta = 1e-14\n    delta_x = 1.0 / Nx\n    delta_y = 1.0 / Ny\n    h = np.sqrt(delta_x**2 + delta_y**2)\n    threshold = c0 * h\n    triangle_area = 0.5 * delta_x * delta_y\n\n    # Node coordinates for epsilon_inf calculation\n    x_nodes = np.linspace(0, 1, Nx + 1)\n    y_nodes = np.linspace(0, 1, Ny + 1)\n    xx, yy = np.meshgrid(x_nodes, y_nodes)\n\n    for case in test_cases_defs:\n        E_func = case[\"E_func\"]\n        eps_func = case[\"eps_func\"]\n        grad_eps_func = case[\"grad_eps_func\"]\n\n        # Compute L_infinity norm of epsilon over the mesh nodes\n        eps_on_nodes = eps_func(xx, yy)\n        eps_inf = np.max(eps_on_nodes)\n\n        div_norm_sq_sum = 0.0\n        E_norm_sq_sum = 0.0\n\n        for i in range(Nx):\n            for j in range(Ny):\n                # Vertices of the rectangle\n                p_bl = (i * delta_x, j * delta_y)\n                p_br = ((i + 1) * delta_x, j * delta_y)\n                p_tl = (i * delta_x, (j + 1) * delta_y)\n                p_tr = ((i + 1) * delta_x, (j + 1) * delta_y)\n\n                # Two triangles per rectangle\n                triangles = [\n                    (p_bl, p_br, p_tr),\n                    (p_bl, p_tr, p_tl)\n                ]\n\n                for tri_verts in triangles:\n                    (x1, y1), (x2, y2), (x3, y3) = tri_verts\n\n                    # Nodal field values for the current triangle\n                    E_vals_at_nodes = [E_func(x1, y1), E_func(x2, y2), E_func(x3, y3)]\n                    Ex1, Ey1 = E_vals_at_nodes[0]\n                    Ex2, Ey2 = E_vals_at_nodes[1]\n                    Ex3, Ey3 = E_vals_at_nodes[2]\n\n                    # Gradients of piecewise linear field components\n                    inv_2_area = 1.0 / (2.0 * triangle_area)\n                    dEx_dx = inv_2_area * ((y2 - y3) * Ex1 + (y3 - y1) * Ex2 + (y1 - y2) * Ex3)\n                    dEy_dy = inv_2_area * ((x3 - x2) * Ey1 + (x1 - x3) * Ey2 + (x2 - x1) * Ey3)\n                    div_Eh_K = dEx_dx + dEy_dy\n\n                    # Centroid of the triangle\n                    xc, yc = (x1 + x2 + x3) / 3.0, (y1 + y2 + y3) / 3.0\n\n                    # E_h at centroid (average of nodal values)\n                    E_at_centroid = (E_vals_at_nodes[0] + E_vals_at_nodes[1] + E_vals_at_nodes[2]) / 3.0\n\n                    # Material properties at centroid\n                    eps_K = eps_func(xc, yc)\n                    grad_eps_K = grad_eps_func(xc, yc)\n\n                    # Divergence of (epsilon * E_h) on the triangle\n                    div_term = eps_K * div_Eh_K + np.dot(grad_eps_K, E_at_centroid)\n                    \n                    # Accumulate for L2 norm of the divergence term\n                    div_norm_sq_sum += div_term**2 * triangle_area\n\n                    # Accumulate for L2 norm of E_h\n                    E_norm_sq_K = np.dot(E_at_centroid, E_at_centroid)\n                    E_norm_sq_sum += E_norm_sq_K * triangle_area\n\n        # Compute final L2 norms\n        norm_div_eps_E = np.sqrt(div_norm_sq_sum)\n        norm_E = np.sqrt(E_norm_sq_sum)\n\n        # Calculate the diagnostic D\n        denominator = eps_inf * norm_E + delta\n        D = 0.0 if denominator == 0 else norm_div_eps_E / denominator\n        \n        # Classify the mode\n        is_spurious = D >= threshold\n        results.append(is_spurious)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}