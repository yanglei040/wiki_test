{
    "hands_on_practices": [
        {
            "introduction": "在选择网格类型时，一个首要的考量是计算成本，这通常由求解问题的未知数或自由度（DoFs）的数量来衡量。本练习将通过一个简单的立方体区域，从第一性原理出发，定量比较结构化六面体网格与非结构化四面体网格在相似特征尺寸下的自由度数量，揭示为何非结构化网格通常需要更密集的剖分。",
            "id": "3351211",
            "problem": "考虑一个边长为 $L$ 的立方腔域 $\\Omega = [0,L]^{3}$ 中的时谐麦克斯韦旋度-旋度公式。假设电场使用一阶旋度协调Nédélec边元（第一类）进行离散化，使得每条唯一的网格边都恰好承载一个标量自由度。忽略边界条件约束；也就是说，将每条网格边都计为一个独立的未知量。\n\n考虑 $\\Omega$ 的两种网格，两者都通过关系式 $h = L/n$ 由一个正整数 $n$ 参数化：\n\n- 一种结构化六面体网格：立方体沿每个坐标轴被剖分为 $n$ 个等距区间，从而产生 $n^{3}$ 个边长为 $h$ 的全等六面体单元。\n\n- 一种四面体网格，其平均边长为 $\\Theta(h)$，通过使用一致的Freudenthal型对角化方法将结构化网格中的每个六面体单元细分为6个四面体而得到：在每个六面体中，插入长的空间对角线，并为每个四边形面选择一条对角线，对角线的选择在相邻单元间保持一致，以使共享面具有相同的对角线。\n\n仅使用以下基本事实：(i) 一阶Nédélec边元为每条唯一的网格边关联一个自由度，以及 (ii) 六面体网格的节点、边、面和单元的数量可以作为 $n$ 的函数通过组合计数法计算，完成以下任务：\n\n- 推导结构化六面体网格上边未知量的精确总数 $N_{\\mathrm{hex}}(n)$，用 $n$ 表示。\n\n- 推导如上构造的四面体网格上边未知量的精确总数 $N_{\\mathrm{tet}}(n)$，用 $n$ 表示。\n\n- 根据这些表达式，确定每种网格随 $h$ 变化的主阶标度关系，然后计算渐近比率\n$$\n\\lim_{h \\to 0^{+}} \\frac{N_{\\mathrm{tet}}(h)}{N_{\\mathrm{hex}}(h)} \\, ,\n$$\n该比率纯粹表示为常数的函数（即，与 $h$ 和 $L$ 无关）。此处，$N_{\\mathrm{hex}}(h)$ 和 $N_{\\mathrm{tet}}(h)$ 表示通过 $n=L/h$ 用 $h$ 表示的计数。\n\n将最终的渐近比率报告为单个简化的有理数。无需四舍五入。答案是无量纲的；不要包含单位。",
            "solution": "问题要求推导立方腔域 $\\Omega = [0,L]^3$ 的两种不同网格离散化方案的自由度（DoF）数量。由于使用了一阶Nédélec元，自由度数量对应于唯一网格边的数量。分析必须针对结构化六面体网格和派生的四面体网格进行。最后，必须计算当网格尺寸 $h$ 趋近于零时，两种网格的边数之比的渐近值。\n\n首先，我们推导结构化六面体网格的边未知量精确数量 $N_{\\mathrm{hex}}(n)$。该网格是通过沿三个坐标轴各将立方体剖分为 $n$ 个区间而形成的。这会创建一个包含 $(n+1) \\times (n+1) \\times (n+1)$ 个顶点的网格，这些顶点可以用 $(i,j,k)$ 进行索引，其中 $i, j, k \\in \\{0, 1, \\dots, n\\}$。该网格的边是连接相邻顶点的线段。我们可以通过按边的方向分类来对它们进行计数。\n\n1.  平行于 $x$ 轴的边：这些边连接形如 $(i, j, k)$ 和 $(i+1, j, k)$ 的顶点。索引 $i$ 的范围可以从 $0$ 到 $n-1$（总共 $n$ 种选择），而索引 $j$ 和 $k$ 的范围都可以从 $0$ 到 $n$（各总共 $n+1$ 种选择）。因此，平行于 $x$ 轴的边数为 $n \\times (n+1) \\times (n+1)$。\n\n2.  平行于 $y$ 轴的边：类似地，这些边连接顶点 $(i, j, k)$ 和 $(i, j+1, k)$。索引 $j$ 从 $0$ 到 $n-1$，而 $i$ 和 $k$ 从 $0$ 到 $n$。此类边的数量为 $(n+1) \\times n \\times (n+1)$。\n\n3.  平行于 $z$ 轴的边：这些边连接顶点 $(i, j, k)$ 和 $(i, j, k+1)$。索引 $k$ 从 $0$ 到 $n-1$，而 $i$ 和 $j$ 从 $0$ 到 $n$。数量为 $(n+1) \\times (n+1) \\times n$。\n\n边的总数 $N_{\\mathrm{hex}}(n)$ 是这三项计数的总和。根据对称性，这三项计数是相同的。\n$$\nN_{\\mathrm{hex}}(n) = 3 \\times n \\times (n+1)^2\n$$\n展开此表达式可得多项式形式：\n$$\nN_{\\mathrm{hex}}(n) = 3n(n^2 + 2n + 1) = 3n^3 + 6n^2 + 3n\n$$\n接下来，我们推导四面体网格的边未知量精确数量 $N_{\\mathrm{tet}}(n)$。该网格是通过细分原始网格中的每一个 $n^3$ 六面体单元来构造的。问题指明，该细分过程会向网格中添加新的边：在每个六面体内部插入一条长的空间对角线，并为每个四边形面选择一条对角线。面对角线的选择在共享面上保持一致。\n\n因此，四面体网格中边的全集是三个不相交的边集的并集：\n1.  六面体网格的原始边。这些边的数量为 $N_{\\mathrm{hex}}(n) = 3n(n+1)^2$。\n2.  新创建的空间对角线。$n^3$ 个六面体单元中的每一个都在其内部添加了一条空间对角线。由于这些对角线位于单元内部，它们不被共享。因此，这恰好增加了 $n^3$ 条新边。\n3.  新创建的面对角线。问题指出，为六面体网格的每个面引入一条对角线。这意味着新面对角线的数量等于六面体网格中的面总数。我们可以按方向对面进行计数：\n    -   平行于 $xy$ 平面的面：在 $n+1$ 个水平顶点层中的每一层，都有 $n \\times n$ 个这样的面。总计：$n^2(n+1)$。\n    -   平行于 $yz$ 平面的面：在 $n+1$ 个矢状面中的每一个面，都有 $n \\times n$ 个这样的面。总计：$n^2(n+1)$。\n    -   平行于 $xz$ 平面的面：在 $n+1$ 个冠状面中的每一个面，都有 $n \\times n$ 个这样的面。总计：$n^2(n+1)$。\n    面的总数是这些数量之和，即 $3n^2(n+1)$。因此，由面对角线产生了 $3n^2(n+1)$ 条新边。\n\n四面体网格中的总边数 $N_{\\mathrm{tet}}(n)$ 是来自这三个来源的计数之和：\n$$\nN_{\\mathrm{tet}}(n) = N_{\\mathrm{hex}}(n) + (\\text{新空间对角线的数量}) + (\\text{新面对角线的数量})\n$$\n$$\nN_{\\mathrm{tet}}(n) = [3n(n+1)^2] + [n^3] + [3n^2(n+1)]\n$$\n我们展开每一项并求和：\n$$\nN_{\\mathrm{tet}}(n) = (3n^3 + 6n^2 + 3n) + n^3 + (3n^3 + 3n^2)\n$$\n$$\nN_{\\mathrm{tet}}(n) = (3+1+3)n^3 + (6+3)n^2 + 3n\n$$\n$$\nN_{\\mathrm{tet}}(n) = 7n^3 + 9n^2 + 3n\n$$\n最后，我们计算渐近比率 $\\lim_{h \\to 0^{+}} \\frac{N_{\\mathrm{tet}}(h)}{N_{\\mathrm{hex}}(h)}$。网格参数 $n$ 和网格尺寸 $h$ 之间的关系由 $h = L/n$ 给出。当 $h \\to 0^+$ 时，对于固定的域大小 $L$，整数 $n$ 必须趋于无穷大（$n \\to \\infty$）。因此，该极限可以关于 $n$ 进行计算：\n$$\n\\lim_{h \\to 0^{+}} \\frac{N_{\\mathrm{tet}}(h)}{N_{\\mathrm{hex}}(h)} = \\lim_{n \\to \\infty} \\frac{N_{\\mathrm{tet}}(n)}{N_{\\mathrm{hex}}(n)}\n$$\n我们代入推导出的 $N_{\\mathrm{tet}}(n)$ 和 $N_{\\mathrm{hex}}(n)$ 的多项式表达式：\n$$\n\\lim_{n \\to \\infty} \\frac{7n^3 + 9n^2 + 3n}{3n^3 + 6n^2 + 3n}\n$$\n对于变量趋于无穷大时多项式有理函数的极限，其极限值是分子和分母中最高次项系数之比。最高次幂是 $n^3$。\n$$\n\\lim_{n \\to \\infty} \\frac{n^3(7 + \\frac{9}{n} + \\frac{3}{n^2})}{n^3(3 + \\frac{6}{n} + \\frac{3}{n^2})} = \\lim_{n \\to \\infty} \\frac{7 + \\frac{9}{n} + \\frac{3}{n^2}}{3 + \\frac{6}{n} + \\frac{3}{n^2}}\n$$\n当 $n \\to \\infty$ 时，诸如 $\\frac{9}{n}$、$\\frac{3}{n^2}$ 和 $\\frac{6}{n}$ 等项趋近于 $0$。\n$$\n\\frac{7 + 0 + 0}{3 + 0 + 0} = \\frac{7}{3}\n$$\n$N_{\\mathrm{hex}}$ 和 $N_{\\mathrm{tet}}$ 的主阶标度关系均为 $O(n^3)$，这对应于 $O(h^{-3})$。渐近比率是主阶系数之比，即 $7/3$。",
            "answer": "$$\n\\boxed{\\frac{7}{3}}\n$$"
        },
        {
            "introduction": "除了自由度的数量，网格单元的质量，尤其是在非结构化网格中，对数值求解器的稳定性和性能有着至关重要的影响。本实践采用一个基于物理原理的模型，演示形状恶劣的“薄片”四面体单元如何急剧增大系统矩阵的条件数，并探讨一种概念性的修复策略。",
            "id": "3351151",
            "problem": "考虑在一个单连通有界三维域中的时谐麦克斯韦方程组，其边界为理想导体。在无源情况下，电场满足包含旋度-旋度算子的弱形式。设离散逼近在四面体网格上使用 Jean-Claude Nédélec 一阶棱元。离散刚度矩阵由旋度-旋度算子的双线性形式定义的单元贡献组装而成。提供了同一区域的两个网格：一个基准网格和一个包含一组狭长四面体的扰动网格。要求您使用从单元映射推导出的、基于形状质量的谱等价论证，来估计由于狭长单元的存在而导致的全局旋度-旋度刚度矩阵条件数的预期增长，然后提出一种针对狭长单元的修复性加密策略并对其效果进行建模。\n\n推导和计算中使用的基本依据和定义：\n- 在具有恒定材料属性的无源介质中，时谐麦克斯韦方程组简化为旋度-旋度算子的特征值问题。在域 $\\Omega$ 上，对于电场 $\\mathbf{E}$ 和 $\\mathbf{H}(\\mathrm{curl},\\Omega)$ 空间中的测试函数 $\\mathbf{v}$，其弱形式由下式给出\n$$\na(\\mathbf{E},\\mathbf{v}) = \\int_{\\Omega} \\mu^{-1} \\, (\\nabla \\times \\mathbf{E}) \\cdot (\\nabla \\times \\mathbf{v}) \\, \\mathrm{d}x,\n$$\n其中 $\\mu$ 是磁导率，刚度矩阵的元素为 $A_{ij} = a(\\mathbf{N}_i,\\mathbf{N}_j)$，$\\mathbf{N}_i$ 是 Nédélec 基函数。\n- 每个物理四面体单元 $K$ 都是通过仿射映射 $F_K(\\boldsymbol{\\xi}) = \\mathbf{x}_0 + \\mathbf{J}_K \\boldsymbol{\\xi}$ 从一个参考四面体获得的，其中 $\\mathbf{J}_K$ 是 $K$ 上的雅可比矩阵。在该映射下，旋度变换产生一个度量张量 $\\mathbf{G}_K = \\mathbf{J}_K^{-T} \\mathbf{J}_K^{-1}$，该张量在拉回后进入单元双线性形式。单元对刚度的贡献在谱上等价于由 $\\mathbf{G}_K$ 的特征值缩放的参考单元贡献。\n- 设 $\\mathbf{J}_K$ 的奇异值为 $\\sigma_1(K) \\ge \\sigma_2(K) \\ge \\sigma_3(K) > 0$。定义单元形状正则性因子 $\\kappa(K) = \\sigma_1(K)/\\sigma_3(K)$。狭长四面体由于其 $\\sigma_3(K)$ 相对于 $\\sigma_1(K)$ 非常小，因而具有很大的 $\\kappa(K)$。\n- 对于一个网格 $\\mathcal{T}$，定义 $h_{\\min}(\\mathcal{T})$ 为所有单元中的最小特征尺寸，$\\kappa_{\\max}(\\mathcal{T}) = \\max_{K\\in \\mathcal{T}} \\kappa(K)$。用 $H$ 表示域直径。在没有材料差异且网格为准均匀的情况下，一个广泛使用的对旋度-旋度算子全局刚度矩阵离散条件数的估计是\n$$\n\\operatorname{cond}(A(\\mathcal{T})) \\lesssim C \\, \\left(\\frac{H}{h_{\\min}(\\mathcal{T})}\\right)^2 \\, \\kappa_{\\max}(\\mathcal{T})^2,\n$$\n其中 $C$ 是一个与网格无关的常数，这反映了差的单元形状和大的尺寸比会恶化条件数。当比较同一域的两个网格时，它们的条件数之比满足\n$$\nR(\\mathcal{T}_B \\Vert \\mathcal{T}_A) \\approx \\left(\\frac{h_{\\min}(\\mathcal{T}_A)}{h_{\\min}(\\mathcal{T}_B)}\\right)^2 \\left(\\frac{\\kappa_{\\max}(\\mathcal{T}_B)}{\\kappa_{\\max}(\\mathcal{T}_A)}\\right)^2,\n$$\n因此常数和 $H$ 在比率中被消掉。该比率为无量纲，因此所有答案必须是无量纲的实数。\n\n修复性加密模型：\n- 通过阈值 $\\tau$ 识别狭长单元：如果一个单元 $K$ 满足 $\\kappa(K) \\ge \\tau$，则将其分类为狭长单元。\n- 应用一种局部加密和平滑策略，其概念上类似于在狭长区域内进行最长边对分后进行顶点平滑。在谱模型中，这对狭长单元将雅可比矩阵的最小奇异值增加一个因子 $\\eta > 1$，同时保持最大奇异值不变，即 $\\sigma_3'(K) = \\min\\{\\eta \\, \\sigma_3(K), \\sigma_1(K)\\}$，而对于其他单元则有 $\\sigma_3'(K) = \\sigma_3(K)$。这使得狭长单元的 $\\kappa(K)$ 大约减小一个因子 $\\eta$。假设在这些测试案例中，$h_{\\min}$ 在此修复下不会恶化，因为该策略旨在改善形状而不减小尺寸。\n- 那么加密后网格的条件数比率为\n$$\nR'(\\mathcal{T}_B \\Vert \\mathcal{T}_A) \\approx \\left(\\frac{h_{\\min}(\\mathcal{T}_A)}{h_{\\min}(\\mathcal{T}_B)}\\right)^2 \\left(\\frac{\\kappa_{\\max}'(\\mathcal{T}_B)}{\\kappa_{\\max}(\\mathcal{T}_A)}\\right)^2,\n$$\n其中 $\\kappa_{\\max}'(\\mathcal{T}_B)$ 是根据 $\\sigma_1(K)$ 和 $\\sigma_3'(K)$ 计算得出的。\n\n您的任务：\n- 对于每个测试案例，使用上述公式计算估计的条件数增量 $R(\\mathcal{T}_B \\Vert \\mathcal{T}_A)$，以及在应用修复性加密模型后的加密后比率 $R'(\\mathcal{T}_B \\Vert \\mathcal{T}_A)$。\n- 以浮点数形式报告结果。\n\n测试套件和数据：\n- 每个网格由一个四面体单元列表指定，每个单元由其雅可比奇异值元组 $(\\sigma_1,\\sigma_2,\\sigma_3)$ 和一个特征尺寸 $h_K$ 指定。对于每个网格，使用其所有 $h_K$ 值中的最小值为 $h_{\\min}$。对于每个测试案例，还指定用于修复性加密的狭长单元阈值 $\\tau$ 和改进因子 $\\eta$。所有数值均在下方给出。\n\n- 测试案例 1 (理想情况，结构化基准网格与含狭长单元的非结构化网格对比)：\n  基准网格 $\\mathcal{T}_A$ 单元：\n  $[(1.00,0.95,0.90,0.25),(1.00,0.96,0.88,0.25),(1.00,0.94,0.89,0.25),(1.00,0.97,0.91,0.25),(1.00,0.95,0.92,0.25),(1.00,0.96,0.93,0.25),(1.00,0.94,0.92,0.25),(1.00,0.97,0.93,0.25)]$。\n  扰动网格 $\\mathcal{T}_B$ 单元：\n  $[(1.00,0.99,0.02,0.25),(1.00,0.98,0.03,0.25),(1.00,0.97,0.04,0.25),(1.00,0.95,0.92,0.25),(1.00,0.96,0.93,0.25),(1.00,0.94,0.90,0.25),(1.00,0.95,0.91,0.25),(1.00,0.96,0.92,0.25)]$。\n  参数：$\\tau = 10$，$\\eta = 5$。\n\n- 测试案例 2 (边界情况，两个网格都接近结构化，狭长单元极少)：\n  基准网格 $\\mathcal{T}_A$ 单元：\n  $[(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10)]$。\n  扰动网格 $\\mathcal{T}_B$ 单元：\n  $[(0.55,0.50,0.45,0.10),(0.60,0.50,0.40,0.10),(0.52,0.50,0.48,0.10),(0.52,0.50,0.48,0.10),(0.52,0.50,0.48,0.10),(0.52,0.50,0.48,0.10),(0.52,0.50,0.48,0.10),(0.52,0.50,0.48,0.10),(0.52,0.50,0.48,0.10),(0.52,0.50,0.48,0.10)]$。\n  参数：$\\tau = 10$，$\\eta = 5$。\n\n- 测试案例 3 (极端情况，非结构化网格中的极端狭长单元)：\n  基准网格 $\\mathcal{T}_A$ 单元：\n  $[(1.00,0.80,0.40,0.30),(1.00,0.85,0.45,0.30),(1.00,0.82,0.42,0.30),(1.00,0.83,0.43,0.30),(1.00,0.84,0.44,0.30)]$。\n  扰动网格 $\\mathcal{T}_B$ 单元：\n  $[(1.00,0.999,0.001,0.30),(1.00,0.995,0.002,0.30),(1.00,0.90,0.60,0.30),(1.00,0.85,0.50,0.30),(1.00,0.88,0.55,0.30)]$。\n  参数：$\\tau = 10$，$\\eta = 20$。\n\n输出规格：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试案例，输出一个二元列表 $[R,R']$，其中 $R$ 是估计的条件数比率，$R'$ 是加密后的比率。将三个测试案例的结果聚合到一个列表中，例如，$[[R_1,R_1'],[R_2,R_2'],[R_3,R_3']]$。由于比率是无量纲的，因此不需要物理单位。",
            "solution": "出发点是在一个具有理想导电边界的域中，无源、均匀介质内的时谐麦克斯韦方程组。其弱形式使用旋度-旋度算子，当使用一阶 Nédélec 棱元进行离散化时，会产生一个全局刚度矩阵，该矩阵由双线性形式的单元贡献组装而成\n$$\na(\\mathbf{E},\\mathbf{v}) = \\int_{\\Omega} \\mu^{-1} \\, (\\nabla \\times \\mathbf{E}) \\cdot (\\nabla \\times \\mathbf{v}) \\, \\mathrm{d}x.\n$$\n组装过程通过雅可比矩阵为 $\\mathbf{J}_K$ 的仿射映射 $F_K(\\boldsymbol{\\xi}) = \\mathbf{x}_0 + \\mathbf{J}_K \\boldsymbol{\\xi}$，将每个物理四面体 $K$ 从参考单元映射而来。旋度的变换方式为 $\\nabla_{\\mathbf{x}} \\times \\mathbf{E}(\\mathbf{x}) = (\\det \\mathbf{J}_K)^{-1} \\mathbf{J}_K \\, (\\nabla_{\\boldsymbol{\\xi}} \\times \\hat{\\mathbf{E}}(\\boldsymbol{\\xi}))$，其中帽子符号表示参考单元上的量。因此，单元双线性形式在拉回后获得了度量张量\n$$\n\\mathbf{G}_K = \\mathbf{J}_K^{-T} \\mathbf{J}_K^{-1},\n$$ \n其意义在于参考单元的贡献通过因子 $\\int_{\\hat{K}} (\\nabla_{\\boldsymbol{\\xi}} \\times \\hat{\\mathbf{N}}_i) \\cdot \\mathbf{G}_K \\, (\\nabla_{\\boldsymbol{\\xi}} \\times \\hat{\\mathbf{N}}_j) \\, \\mathrm{d}\\boldsymbol{\\xi}$ 由 $\\mathbf{G}_K$ 进行缩放。$\\mathbf{G}_K$ 的特征值为 $\\lambda_i(\\mathbf{G}_K) = \\sigma_i(\\mathbf{J}_K)^{-2}$，其中 $\\sigma_i(\\mathbf{J}_K)$ 是 $\\mathbf{J}_K$ 的奇异值。因此，$\\mathbf{G}_K$ 的谱条件由比率\n$$\n\\frac{\\lambda_{\\max}(\\mathbf{G}_K)}{\\lambda_{\\min}(\\mathbf{G}_K)} = \\left(\\frac{\\sigma_1(K)}{\\sigma_3(K)}\\right)^2 = \\kappa(K)^2,\n$$\n决定，其中 $\\kappa(K) = \\sigma_1(K)/\\sigma_3(K)$ 作为形状正则性因子。狭长四面体的 $\\sigma_3(K)$ 远小于 $\\sigma_1(K)$，导致 $\\kappa(K)$ 很大，从而产生变化剧烈的大局部刚度贡献，这在组装时会导致全局条件数变差。\n\n对于一个网格 $\\mathcal{T}$，全局刚度矩阵的条件数同时与网格尺寸比和单元形状质量有关。在合理的准均匀性假设下，对于协调有限元的一个标准估计是\n$$\n\\operatorname{cond}(A(\\mathcal{T})) \\lesssim C \\, \\left(\\frac{H}{h_{\\min}(\\mathcal{T})}\\right)^2 \\, \\kappa_{\\max}(\\mathcal{T})^2,\n$$\n其中 $H$ 是域直径，$h_{\\min}(\\mathcal{T})$ 是最小单元尺寸，$\\kappa_{\\max}(\\mathcal{T}) = \\max_{K\\in \\mathcal{T}} \\kappa(K)$ 是最差形状因子，$C$ 是一个与网格无关但依赖于多项式阶数的常数，在比率中会被消掉。对于同一域的两个网格 $\\mathcal{T}_A$ 和 $\\mathcal{T}_B$，它们的条件数之比满足\n$$\nR(\\mathcal{T}_B \\Vert \\mathcal{T}_A) \\approx \\left(\\frac{h_{\\min}(\\mathcal{T}_A)}{h_{\\min}(\\mathcal{T}_B)}\\right)^2 \\left(\\frac{\\kappa_{\\max}(\\mathcal{T}_B)}{\\kappa_{\\max}(\\mathcal{T}_A)}\\right)^2,\n$$\n因为 $H$ 相同且 $C$ 被消掉了。这提供了一个基于映射和 $\\mathbf{H}(\\mathrm{curl})$ 单元理论的、以物理和几何为基础的估计。\n\n为了对一个专注于狭长单元的修复性加密策略进行建模，我们考虑一个阈值 $\\tau$ 和一个改进因子 $\\eta$。通过 $\\kappa(K) \\ge \\tau$ 来识别狭长单元。诸如最长边对分与顶点平滑相结合的局部加密方法，可以增加狭长单元的最小奇异值，同时基本保持最大奇异值不变，从而改善形状质量。在谱的意义上，\n$$\n\\sigma_3'(K) = \\min\\{\\eta \\, \\sigma_3(K), \\sigma_1(K)\\}, \\quad \\sigma_1'(K) = \\sigma_1(K),\n$$\n而对于非狭长单元，$\\sigma_3'(K)=\\sigma_3(K)$。加密后的形状因子变为\n$$\n\\kappa'(K) = \\frac{\\sigma_1'(K)}{\\sigma_3'(K)} = \\frac{\\sigma_1(K)}{\\min\\{\\eta \\, \\sigma_3(K), \\sigma_1(K)\\}},\n$$\n当 $\\eta \\, \\sigma_3(K) \\le \\sigma_1(K)$ 时，其值约等于 $\\kappa(K)/\\eta$。加密后的最差情况因子为 $\\kappa_{\\max}'(\\mathcal{T}_B) = \\max_{K\\in \\mathcal{T}_B} \\kappa'(K)$。假设在测试场景中，加密的目标是形状质量而不减小最小单元尺寸，那么 $h_{\\min}(\\mathcal{T}_B)$ 保持不变，加密后的比率为\n$$\nR'(\\mathcal{T}_B \\Vert \\mathcal{T}_A) \\approx \\left(\\frac{h_{\\min}(\\mathcal{T}_A)}{h_{\\min}(\\mathcal{T}_B)}\\right)^2 \\left(\\frac{\\kappa_{\\max}'(\\mathcal{T}_B)}{\\kappa_{\\max}(\\mathcal{T}_A)}\\right)^2.\n$$\n\n程序为每个测试案例实现的算法步骤：\n- 计算 $\\mathcal{T}_A$ 和 $\\mathcal{T}_B$ 中每个单元的 $\\kappa(K) = \\sigma_1(K)/\\sigma_3(K)$。\n- 确定 $\\kappa_{\\max}(\\mathcal{T}_A)$ 和 $\\kappa_{\\max}(\\mathcal{T}_B)$。\n- 从单元尺寸计算 $h_{\\min}(\\mathcal{T}_A)$ 和 $h_{\\min}(\\mathcal{T}_B)$。\n- 评估\n$$\nR = \\left(\\frac{h_{\\min}(\\mathcal{T}_A)}{h_{\\min}(\\mathcal{T}_B)}\\right)^2 \\left(\\frac{\\kappa_{\\max}(\\mathcal{T}_B)}{\\kappa_{\\max}(\\mathcal{T}_A)}\\right)^2.\n$$\n- 将修复性加密模型应用于 $\\mathcal{T}_B$ 中的所有狭长单元：对于每个满足 $\\kappa(K) \\ge \\tau$ 的单元 $K$，设置 $\\sigma_3'(K) = \\min\\{\\eta \\, \\sigma_3(K), \\sigma_1(K)\\}$ 并重新计算 $\\kappa'(K)$；否则，保持 $\\sigma_3'(K)=\\sigma_3(K)$。然后找到 $\\kappa_{\\max}'(\\mathcal{T}_B)$ 并计算\n$$\nR' = \\left(\\frac{h_{\\min}(\\mathcal{T}_A)}{h_{\\min}(\\mathcal{T}_B)}\\right)^2 \\left(\\frac{\\kappa_{\\max}'(\\mathcal{T}_B)}{\\kappa_{\\max}(\\mathcal{T}_A)}\\right)^2.\n$$\n\n关于计算电磁学中结构化网格与非结构化网格的解读：结构化网格通常保持有界的 $\\kappa(K)$ 和均匀的 $h_K$，从而产生较小的条件数。非结构化网格可能包含具有大 $\\kappa(K)$ 的狭长单元，从而严重恶化条件数。所提出的定向加密通过改善狭长单元的形状来降低 $\\kappa_{\\max}$，同时不会过度改变 $h_{\\min}$，从而将条件数恢复到更接近基准结构化网格的水平。\n\n程序为提供的测试套件精确地实现了这些计算，并输出一行包含 $[[R_1,R_1'],[R_2,R_2'],[R_3,R_3']]$ 的结果，其中每个 $R_i$ 和 $R_i'$ 都表示为浮点数。这些比率是无量纲的，因此不需要物理单位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef kappa_max(elements):\n    # elements: list of tuples (s1, s2, s3, h)\n    kappas = []\n    for (s1, s2, s3, h) in elements:\n        # Avoid division by zero; s3 > 0 by construction in test suite\n        kappas.append(s1 / s3)\n    return max(kappas)\n\ndef h_min(elements):\n    return min(h for (_, _, _, h) in elements)\n\ndef refine_elements(elements, tau, eta):\n    # Return new list of elements with refined s3 for slivers\n    refined = []\n    for (s1, s2, s3, h) in elements:\n        kappa = s1 / s3\n        if kappa >= tau:\n            s3_new = min(eta * s3, s1)  # increase smallest singular value, cap at s1\n            refined.append((s1, s2, s3_new, h))\n        else:\n            refined.append((s1, s2, s3, h))\n    return refined\n\ndef cond_ratio(meshA, meshB):\n    kA = kappa_max(meshA)\n    kB = kappa_max(meshB)\n    hA = h_min(meshA)\n    hB = h_min(meshB)\n    return (hA / hB) ** 2 * (kB / kA) ** 2\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"meshA\": [\n                (1.00, 0.95, 0.90, 0.25),\n                (1.00, 0.96, 0.88, 0.25),\n                (1.00, 0.94, 0.89, 0.25),\n                (1.00, 0.97, 0.91, 0.25),\n                (1.00, 0.95, 0.92, 0.25),\n                (1.00, 0.96, 0.93, 0.25),\n                (1.00, 0.94, 0.92, 0.25),\n                (1.00, 0.97, 0.93, 0.25),\n            ],\n            \"meshB\": [\n                (1.00, 0.99, 0.02, 0.25),\n                (1.00, 0.98, 0.03, 0.25),\n                (1.00, 0.97, 0.04, 0.25),\n                (1.00, 0.95, 0.92, 0.25),\n                (1.00, 0.96, 0.93, 0.25),\n                (1.00, 0.94, 0.90, 0.25),\n                (1.00, 0.95, 0.91, 0.25),\n                (1.00, 0.96, 0.92, 0.25),\n            ],\n            \"tau\": 10.0,\n            \"eta\": 5.0,\n        },\n        # Test case 2\n        {\n            \"meshA\": [\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n            ],\n            \"meshB\": [\n                (0.55, 0.50, 0.45, 0.10),\n                (0.60, 0.50, 0.40, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n            ],\n            \"tau\": 10.0,\n            \"eta\": 5.0,\n        },\n        # Test case 3\n        {\n            \"meshA\": [\n                (1.00, 0.80, 0.40, 0.30),\n                (1.00, 0.85, 0.45, 0.30),\n                (1.00, 0.82, 0.42, 0.30),\n                (1.00, 0.83, 0.43, 0.30),\n                (1.00, 0.84, 0.44, 0.30),\n            ],\n            \"meshB\": [\n                (1.00, 0.999, 0.001, 0.30),\n                (1.00, 0.995, 0.002, 0.30),\n                (1.00, 0.90, 0.60, 0.30),\n                (1.00, 0.85, 0.50, 0.30),\n                (1.00, 0.88, 0.55, 0.30),\n            ],\n            \"tau\": 10.0,\n            \"eta\": 20.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        meshA = case[\"meshA\"]\n        meshB = case[\"meshB\"]\n        tau = case[\"tau\"]\n        eta = case[\"eta\"]\n\n        R = cond_ratio(meshA, meshB)\n        meshB_refined = refine_elements(meshB, tau, eta)\n        R_refined = cond_ratio(meshA, meshB_refined)\n\n        # Round moderately for cleaner output\n        results.append([float(f\"{R:.6f}\"), float(f\"{R_refined:.6f}\")])\n\n    # Final print statement in the exact required format.\n    # Single line, comma-separated list enclosed in square brackets.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "网格剖分的最终目的是精确地描述物理过程。本练习对比了结构化曲线网格与不同阶次的非结构化网格如何拟合曲线几何边界。通过分析由此产生的数值相速度误差，本练习揭示了几何近似对波传播仿真精度的直接影响。",
            "id": "3351225",
            "problem": "考虑在自由空间中的电磁波传播，该过程由麦克斯韦方程组控制，并使用交错的有限差分时域方案进行离散化。该方案将电场和磁场分量放置在交错的空间位置上，并通过显式更新在时间上推进。目标是研究在表示光滑弯曲路径时，几何拟合策略对数值色散和相位精度的影响。您将比较两种几何拟合策略：逻辑结构化网格上的曲线映射和非结构化单元的弯曲。您还将明确量化雅可比行列式和度量尺度因子的近似如何影响离散色散关系。\n\n从基本出发点开始：自由空间中的麦克斯韦方程组，\n$$\n\\nabla \\times \\mathbf{E} = -\\mu_0 \\frac{\\partial \\mathbf{H}}{\\partial t}, \\quad \\nabla \\times \\mathbf{H} = \\varepsilon_0 \\frac{\\partial \\mathbf{E}}{\\partial t},\n$$\n其中波速为 $c = \\frac{1}{\\sqrt{\\mu_0 \\varepsilon_0}}$。考虑一个二维横电（transverse-electric）配置，其中电场为平面外分量，磁场为平面内分量，传播方向与半径为 $R$（中心线）的圆弧相切，该圆弧由角度坐标参数化。在结构化情况下，采用与圆对齐的正交曲线映射，使得切向坐标的度量尺度因子为 $h_\\xi$，法向坐标的度量尺度因子为 $h_\\eta$，且映射的雅可比行列式满足 $J = h_\\xi h_\\eta$。在非结构化情况下，考虑弯曲单元上的等参边：端点之间的线性边（一条直弦）和由二次拉格朗日形函数定义的二次边，该函数对放置在圆形边界上的三个节点进行插值；导出的雅可比和度量项由单元映射近似。您需要通过推导沿切向传播的离散色散关系来分析数值色散，其中要考虑空间步长的度量缩放和显式时间步长，并计算由此产生的相位速度误差。\n\n您的程序必须实现以下步骤：\n\n1. 建立中心线半径为 $R$、每个单元角跨度为 $\\Delta \\theta$（以弧度为单位）的圆弧几何模型。定义沿切向的三个有效空间步长：\n   - 结构化曲线映射：使用与中心线上具有精确度量尺度因子 $h_\\xi$ 的映射对齐的精确弧长 $s_{\\text{arc}} = R \\Delta \\theta$。\n   - 非结构化线性边：使用弦长 $s_{\\text{chord}} = 2 R \\sin\\left(\\frac{\\Delta \\theta}{2}\\right)$ 作为沿切向的有效单元尺寸，这反映了直边对雅可比和度量的近似。\n   - 非结构化二次弯曲边：通过对角度为 $0$ 和 $\\Delta \\theta$ 的端点以及角度为 $\\frac{\\Delta \\theta}{2}$ 的边中点进行二次拉格朗日插值，构造一个二次等参边；计算有效边长\n     $$\n     s_{\\text{quad}} = \\int_{-1}^{1} \\sqrt{\\left(\\frac{dx}{dt}\\right)^2 + \\left(\\frac{dy}{dt}\\right)^2}\\, dt,\n     $$\n     其中 $(x(t),y(t))$ 是通过使用标准二次拉格朗日形函数对参数 $t \\in [-1,1]$ 中的节点坐标进行二次插值得到的。当雅可比矩阵由二次等参映射近似时，该积分表示由度量引起的长度。\n\n2. 从自由空间平面波关系 $k = \\frac{2\\pi}{\\lambda}$（波长为 $\\lambda$，单位为米）和角频率 $\\omega = c k$ 出发，使用沿切向的一维交错有限差分时域色散关系（空间步长为 $\\Delta s$，时间步长为 $\\Delta t$），为每个有效步长求得离散数值角频率 $\\omega_{\\text{num}}$。该关系必须从正交曲线坐标系中的麦克斯韦方程组推导得出；它应通过有效步长大小隐式地考虑度量尺度因子，并生成 $\\omega_{\\text{num}}$ 作为 $k$、$\\Delta s$ 和 $\\Delta t$ 的函数，而不使用简化公式。\n\n3. 对于每种情况，计算数值相速度 $v_{\\text{num}} = \\frac{\\omega_{\\text{num}}}{k}$ 和相对相速度误差\n   $$\n   e = \\frac{v_{\\text{num}} - c}{c},\n   $$\n   该误差是无量纲的，必须以小数值报告（不带百分号）。\n\n4. 使用由库朗因子 $\\sigma \\in (0,1)$ 确定的显式时间步长，其定义为\n   $$\n   \\Delta t = \\sigma \\frac{\\min\\{s_{\\text{arc}}, s_{\\text{chord}}, s_{\\text{quad}}\\}}{c},\n   $$\n   这确保了在给定情况下三种策略的稳定性。\n\n角度单位必须是弧度。所有长度单位必须是米。光速必须为 $c = 299792458\\,\\mathrm{m/s}$。最终输出必须是表示相对相速度误差的无量纲小数值。\n\n测试套件：\n实现您的程序以评估以下四个测试用例，每个用例提供 $(R, \\Delta \\theta, \\lambda, \\sigma)$：\n\n- 用例 1 (正常路径): $R = 1.0\\,\\mathrm{m}$, $\\Delta \\theta = 0.2$ (弧度), $\\lambda = 0.5\\,\\mathrm{m}$, $\\sigma = 0.95$。\n- 用例 2 (精细角分辨率): $R = 1.0\\,\\mathrm{m}$, $\\Delta \\theta = 0.01$ (弧度), $\\lambda = 0.5\\,\\mathrm{m}$, $\\sigma = 0.95$。\n- 用例 3 (强曲率): $R = 0.3\\,\\mathrm{m}$, $\\Delta \\theta = 0.5$ (弧度), $\\lambda = 0.25\\,\\mathrm{m}$, $\\sigma = 0.90$。\n- 用例 4 (接近稳定性极限): $R = 0.2\\,\\mathrm{m}$, $\\Delta \\theta = 0.3$ (弧度), $\\lambda = 0.10\\,\\mathrm{m}$, $\\sigma = 0.99$。\n\n对于每个测试用例，您的程序必须按结构化曲线弧、非结构化线性弦和非结构化二次弯曲边的顺序计算并返回三个数字。因此，对于四个用例，您的程序必须生成单行输出，其中包含十二个用方括号括起来的逗号分隔小数值，顺序如下：\n$$\n[e_{1,\\text{arc}}, e_{1,\\text{chord}}, e_{1,\\text{quad}}, e_{2,\\text{arc}}, e_{2,\\text{chord}}, e_{2,\\text{quad}}, e_{3,\\text{arc}}, e_{3,\\text{chord}}, e_{3,\\text{quad}}, e_{4,\\text{arc}}, e_{4,\\text{chord}}, e_{4,\\text{quad}}].\n$$\n不得打印任何额外文本。",
            "solution": "该问题被认为是有效的，因为它在科学上基于麦克斯韦理论和计算电磁学，问题设定良好，有明确的目标和足够的数据，并且没有矛盾或含糊之处。\n\n求解过程首先确定三种不同几何建模策略的有效切向空间步长。其次，从麦克斯韦方程组推导出一维有限差分时域（FDTD）数值色散关系。第三，使用此关系计算每种策略的数值相速度及其相对误差。最后，根据确保所有三种情况下都稳定的库朗条件确定时间步长。\n\n### 步骤 1：几何近似与有效步长\n\n我们考虑一个半径为 $R$ 的圆弧，并计算对应于角跨度 $\\Delta \\theta$ 的单个离散段的长度。\n\n1.  **结构化曲线映射 ($s_{\\text{arc}}$)**：在与圆形几何完全对齐的结构化曲线网格中，沿切向的单元边遵循弧线本身。此弧段的精确长度为：\n    $$\n    s_{\\text{arc}} = R \\Delta \\theta\n    $$\n\n2.  **非结构化线性边 ($s_{\\text{chord}}$)**：当非结构化网格使用直边单元（例如，线性三角形）来近似曲线时，该段是连接弧上两个端点的直线。这就是弦长。对于从角度 $0$ 开始到角度 $\\Delta \\theta$ 结束的弧段，端点可以放在 $(R, 0)$ 和 $(R \\cos \\Delta \\theta, R \\sin \\Delta \\theta)$。弦长是它们之间的距离，可简化为：\n    $$\n    s_{\\text{chord}} = \\sqrt{(R \\cos \\Delta \\theta - R)^2 + (R \\sin \\Delta \\theta - 0)^2} = R \\sqrt{\\cos^2 \\Delta \\theta - 2 \\cos \\Delta \\theta + 1 + \\sin^2 \\Delta \\theta} = R \\sqrt{2 - 2 \\cos \\Delta \\theta}\n    $$\n    使用半角恒等式 $1 - \\cos \\Delta \\theta = 2 \\sin^2(\\frac{\\Delta \\theta}{2})$，上式变为：\n    $$\n    s_{\\text{chord}} = R \\sqrt{4 \\sin^2\\left(\\frac{\\Delta \\theta}{2}\\right)} = 2 R \\sin\\left(\\frac{\\Delta \\theta}{2}\\right)\n    $$\n\n3.  **非结构化二次弯曲边 ($s_{\\text{quad}}$)**：更高阶的近似使用弯曲单元。我们使用二次等参映射来建模该段。三个节点放置在弧上：分别在角度 $0$、$\\frac{\\Delta\\theta}{2}$ 和 $\\Delta\\theta$ 处。在局部坐标系 $t \\in [-1, 1]$ 中，这些节点的位置使用二次拉格朗日形函数进行插值：\n    $$\n    N_{-1}(t) = \\frac{t(t-1)}{2}, \\quad N_{0}(t) = 1-t^2, \\quad N_{1}(t) = \\frac{t(t+1)}{2}\n    $$\n    $t=-1$ 处的节点对应于角度 $0$，$t=0$ 对应于角度 $\\frac{\\Delta\\theta}{2}$，而 $t=1$ 对应于角度 $\\Delta\\theta$。物理坐标 $(x(t), y(t))$ 由下式给出：\n    $$\n    \\mathbf{r}(t) = \\mathbf{r}_{-1} N_{-1}(t) + \\mathbf{r}_{0} N_{0}(t) + \\mathbf{r}_{1} N_{1}(t)\n    $$\n    其中 $\\mathbf{r}_{-1}=(R,0)$，$\\mathbf{r}_{0}=(R\\cos(\\frac{\\Delta\\theta}{2}), R\\sin(\\frac{\\Delta\\theta}{2}))$，以及 $\\mathbf{r}_{1}=(R\\cos(\\Delta\\theta), R\\sin(\\Delta\\theta))$。此弯曲边的有效长度是其微分弧长的积分：\n    $$\n    s_{\\text{quad}} = \\int_{-1}^{1} \\left\\| \\frac{d\\mathbf{r}}{dt} \\right\\| dt = \\int_{-1}^{1} \\sqrt{\\left(\\frac{dx}{dt}\\right)^2 + \\left(\\frac{dy}{dt}\\right)^2} dt\n    $$\n    导数是 $t$ 的线性函数：$\\frac{dx}{dt} = A_x t + B_x$ 和 $\\frac{dy}{dt} = A_y t + B_y$，其中系数为：\n    $$\n    A_x = R\\left(1 + \\cos(\\Delta\\theta) - 2\\cos\\left(\\frac{\\Delta\\theta}{2}\\right)\\right), \\quad B_x = \\frac{R}{2}(\\cos(\\Delta\\theta)-1)\n    $$\n    $$\n    A_y = R\\left(\\sin(\\Delta\\theta) - 2\\sin\\left(\\frac{\\Delta\\theta}{2}\\right)\\right), \\quad B_y = \\frac{R}{2}\\sin(\\Delta\\theta)\n    $$\n    该积分使用数值积分计算。\n\n### 步骤 2：FDTD 色散关系\n\n对于一个沿正交曲线坐标 $\\xi$ 定义的路径纯切向传播的二维横电波 ($E_z, H_x, H_y$)，麦克斯韦方程组简化为一维系统。假设在法向方向上是均匀的（$\\frac{\\partial}{\\partial \\eta}=0$），相关方程为：\n$$\n\\frac{1}{h_\\xi} \\frac{\\partial E_z}{\\partial \\xi} = \\mu_0 \\frac{\\partial H_\\eta}{\\partial t}, \\quad \\frac{1}{h_\\xi} \\frac{\\partial H_\\eta}{\\partial \\xi} = \\varepsilon_0 \\frac{\\partial E_z}{\\partial t}\n$$\n其中 $h_\\xi$ 是度量尺度因子。通过定义物理路径长度变量 $s$ 使得 $ds = h_\\xi d\\xi$，以及一个有效空间步长 $\\Delta s$，这些方程呈现为标准的一维笛卡尔坐标系下的麦克斯韦方程组形式：\n$$\n\\frac{\\partial E_z}{\\partial s} = \\mu_0 \\frac{\\partial H_y}{\\partial t}, \\quad \\frac{\\partial H_y}{\\partial s} = \\varepsilon_0 \\frac{\\partial E_z}{\\partial t}\n$$\n使用交错蛙跳 FDTD 格式对这些方程进行离散化，得到：\n$$\n\\frac{E_z|_i^{n+1/2} - E_z|_i^{n-1/2}}{\\Delta t} = \\frac{1}{\\varepsilon_0} \\frac{H_y|_{i+1/2}^n - H_y|_{i-1/2}^n}{\\Delta s}\n$$\n$$\n\\frac{H_y|_{i+1/2}^{n+1} - H_y|_{i+1/2}^n}{\\Delta t} = \\frac{1}{\\mu_0} \\frac{E_z|_{i+1}^{n+1/2} - E_z|_i^{n+1/2}}{\\Delta s}\n$$\n假设一个形式为 $e^{j(k s - \\omega_{\\text{num}} t)}$ 的谐波平面波解，其中 $k$ 是解析波数，$\\omega_{\\text{num}}$ 是数值角频率，将其代入有限差分方程，得到数值色散关系：\n$$\n\\sin\\left(\\frac{\\omega_{\\text{num}} \\Delta t}{2}\\right) = \\frac{c \\Delta t}{\\Delta s} \\sin\\left(\\frac{k \\Delta s}{2}\\right)\n$$\n其中 $c = 1/\\sqrt{\\mu_0 \\varepsilon_0}$ 是真空中的光速。由此，我们解出 $\\omega_{\\text{num}}$：\n$$\n\\omega_{\\text{num}} = \\frac{2}{\\Delta t} \\arcsin\\left(\\frac{c \\Delta t}{\\Delta s} \\sin\\left(\\frac{k \\Delta s}{2}\\right)\\right)\n$$\n对于给定的波长 $\\lambda$，解析波数为 $k = \\frac{2\\pi}{\\lambda}$。这个关系对三种有效步长 $\\Delta s \\in \\{s_{\\text{arc}}, s_{\\text{chord}}, s_{\\text{quad}}\\}$ 中的每一种都成立。\n\n### 步骤 3：相速度误差\n\n数值相速度定义为 $v_{\\text{num}} = \\frac{\\omega_{\\text{num}}}{k}$。理想相速度为 $c$。因此，相对误差 $e$ 为：\n$$\ne = \\frac{v_{\\text{num}} - c}{c} = \\frac{v_{\\text{num}}}{c} - 1\n$$\n代入 $\\omega_{\\text{num}}$ 的表达式，得到误差的最终公式：\n$$\ne = \\frac{2}{c k \\Delta t} \\arcsin\\left(\\frac{c \\Delta t}{\\Delta s} \\sin\\left(\\frac{k \\Delta s}{2}\\right)\\right) - 1\n$$\n\n### 步骤 4：时间步长计算\n\n为了确保显式时间推进格式在所有三种几何近似下使用单个时间步长时的数值稳定性，$\\Delta t$ 是基于给定库朗因子 $\\sigma$ 的最严格（最小）空间步长来选择的：\n$$\n\\Delta t = \\sigma \\frac{\\min\\{s_{\\text{arc}}, s_{\\text{chord}}, s_{\\text{quad}}\\}}{c}\n$$\n在一维情况下，为了保证稳定性，库朗因子 $\\sigma$ 必须小于 $1$。$\\Delta t$ 的这种选择保证了色散关系中 $\\arcsin$ 函数的参数小于 $1$，从而防止不稳定。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes the numerical phase velocity error for three different FDTD\n    geometry-fitting strategies on a circular arc.\n    \"\"\"\n\n    # Speed of light in vacuum (m/s)\n    c_light = 299792458.0\n\n    # Test cases: (R, delta_theta, lambda, sigma)\n    test_cases = [\n        (1.0, 0.2, 0.5, 0.95),   # Case 1: happy path\n        (1.0, 0.01, 0.5, 0.95),  # Case 2: fine angular resolution\n        (0.3, 0.5, 0.25, 0.90),  # Case 3: strong curvature\n        (0.2, 0.3, 0.10, 0.99),  # Case 4: near stability limit\n    ]\n\n    results = []\n\n    def calculate_s_quad(R, dtheta):\n        \"\"\"\n        Calculates the length of a quadratic isoparametric edge.\n        \"\"\"\n        if dtheta == 0.0:\n            return 0.0\n\n        # Define node positions corresponding to angles 0, dtheta/2, dtheta\n        # Mapped to local coordinates t = -1, 0, 1\n        r_m1 = np.array([R, 0.0])\n        r_0 = np.array([R * np.cos(dtheta / 2.0), R * np.sin(dtheta / 2.0)])\n        r_1 = np.array([R * np.cos(dtheta), R * np.sin(dtheta)])\n        \n        # Coefficients for dr/dt = A*t + B\n        # from r(t) = r_m1*N_m1(t) + r_0*N_0(t) + r_1*N_1(t)\n        # where N_m1, N_0, N_1 are standard quadratic Lagrange shape functions.\n        # This gives dr/dt = ((r_1-r_m1)/2) + (r_m1+r_1-2*r_0)*t\n        A = r_m1 + r_1 - 2 * r_0\n        B = (r_1 - r_m1) / 2.0\n        \n        Ax, Ay = A\n        Bx, By = B\n\n        # Integrand for arc length: sqrt((dx/dt)^2 + (dy/dt)^2)\n        def integrand(t):\n            dxdt = Ax * t + Bx\n            dydt = Ay * t + By\n            return np.sqrt(dxdt**2 + dydt**2)\n\n        # Numerical integration over t in [-1, 1]\n        s_quad_val, _ = quad(integrand, -1.0, 1.0)\n        return s_quad_val\n\n    def calculate_error(ds, dt, k, c):\n        \"\"\"\n        Calculates the relative phase velocity error.\n        \"\"\"\n        if ds == 0.0:\n            return 0.0 # Avoid division by zero, error is zero for zero step size\n\n        # Argument for the arcsin in the dispersion relation\n        courant_local = c * dt / ds\n        arg = courant_local * np.sin(k * ds / 2.0)\n        \n        # The choice of dt ensures abs(arg) = sigma  1\n        # so no complex numbers should arise.\n        if abs(arg) > 1.0:\n            # This case should not be reached with the problem's setup\n            arg = np.sign(arg)\n\n        omega_num = (2.0 / dt) * np.arcsin(arg)\n        v_num = omega_num / k\n        error = v_num / c - 1.0\n        return error\n\n    for R, dtheta, lambda_w, sigma in test_cases:\n        # Analytical wavenumber\n        k = 2.0 * np.pi / lambda_w\n\n        # Step 1: Calculate effective step sizes\n        s_arc = R * dtheta\n        s_chord = 2.0 * R * np.sin(dtheta / 2.0)\n        s_quad = calculate_s_quad(R, dtheta)\n\n        # Step 2: Calculate time step based on Courant condition\n        s_min = min(s_arc, s_chord, s_quad)\n        dt = sigma * s_min / c_light\n\n        # Step 3: Calculate errors for each geometry\n        error_arc = calculate_error(s_arc, dt, k, c_light)\n        error_chord = calculate_error(s_chord, dt, k, c_light)\n        error_quad = calculate_error(s_quad, dt, k, c_light)\n        \n        results.extend([error_arc, error_chord, error_quad])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}