{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of computational science is the ability to verify code against known analytical benchmarks. This practice focuses on the canonical problem of electromagnetic scattering from a sphere, a scenario for which a complete analytical solution, known as Mie theory, exists. You will implement the full Mie series solution and compare its results for the Radar Cross Section (RCS) against the much simpler Rayleigh scattering approximation, which is valid only for electrically small spheres . This exercise provides invaluable hands-on experience in understanding different scattering regimes and validating numerical implementations.",
            "id": "3343785",
            "problem": "You are tasked with writing a complete and runnable program that computes and compares the backscattered Radar Cross Section (RCS) of electrically small spheres using two approaches that both originate from the boundary-value solution of Maxwell’s equations for a sphere: (i) a full multipole expansion (commonly called “Mie scattering”) truncated at a numerically justified finite order, and (ii) the Rayleigh approximation obtained by retaining only the lowest-order multipole contribution. The physical setting is a time-harmonic plane wave of angular frequency $\\,\\omega\\,$ incident on a homogeneous, isotropic sphere of radius $\\,a\\,$ embedded in free space. The ambient medium is free space with relative permeability $\\,\\mu_r = 1\\,$ and relative permittivity $\\,\\epsilon_{r,\\text{med}} = 1\\,$; the Speed of Light in vacuum is $\\,c = 2.99792458\\times 10^8\\,\\mathrm{m/s}\\,$. The spherical target is characterized by relative permittivity $\\,\\epsilon_r\\,$ (possibly complex for a lossy dielectric); the Perfect Electric Conductor (PEC) case is also included. The incident polarization is arbitrary due to spherical symmetry; the monostatic backscattering direction is $\\,\\theta = \\pi\\,$ in radians.\n\nYour program must implement the following logic from first principles:\n- Begin from the macroscopic Maxwell equations in the frequency domain, $\\,\\nabla\\times \\mathbf{E} = i\\omega\\mu\\mathbf{H}\\,$ and $\\,\\nabla\\times \\mathbf{H} = -\\,i\\omega\\epsilon\\mathbf{E}\\,$ with $\\,\\nabla\\cdot(\\epsilon\\mathbf{E}) = 0\\,$ and $\\,\\nabla\\cdot(\\mu\\mathbf{H}) = 0\\,$ away from sources. Use separation of variables in spherical coordinates to expand the fields into vector spherical harmonics. Impose the standard transmission boundary conditions on the tangential components of $\\,\\mathbf{E}\\,$ and $\\,\\mathbf{H}\\,$ at the sphere surface to determine the expansion coefficients (the multipole scattering coefficients). The external wavenumber is $\\,k = \\dfrac{2\\pi f}{c}\\,$, the size parameter is $\\,x = k a\\,$, and the relative refractive index of the sphere is $\\,m = \\sqrt{\\epsilon_r}\\,$ for the nonmagnetic case.\n- Compute the backscatter far-field amplitude by summing the multipole contributions over orders $\\,n \\ge 1\\,$ at $\\,\\theta = \\pi\\,$. The series must be truncated at a finite order $\\,n_{\\max}\\,$ chosen as a function of $\\,x\\,$ to ensure numerical convergence for electrically small spheres. A commonly used choice is $\\,n_{\\max} = \\left\\lfloor x + 4 x^{1/3} + 2 \\right\\rfloor\\,$.\n- Define the monostatic backscattered Radar Cross Section (RCS) used in this problem as the dimensionless differential cross section at $\\,\\theta = \\pi\\,$ normalized by $\\,k^2\\,$, i.e., $\\,\\sigma_{\\mathrm{back}} = \\dfrac{1}{k^2}\\left|S_{\\mathrm{back}}\\right|^2\\,$, where $\\,S_{\\mathrm{back}}\\,$ is the backscatter amplitude obtained from the multipole expansion. Express $\\,\\sigma_{\\mathrm{back}}\\,$ in $\\mathrm{m}^2$.\n- Implement two computations of $\\,\\sigma_{\\mathrm{back}}\\,$:\n  1. The “Mie” result: use the full multipole series truncated at $\\,n_{\\max}\\,$ as above.\n  2. The “Rayleigh” result: retain only the dipole term $\\,n = 1\\,$ in the same multipole framework (this is the Rayleigh approximation for electrically small spheres).\n- For the Perfect Electric Conductor (PEC) case, use the boundary condition $\\,\\mathbf{E}_t = 0\\,$ at the sphere surface, which yields PEC-specific scattering coefficients consistent with the same multipole structure.\n\nYour outputs must be dimensionless decimals corresponding to the relative error between the two RCS computations, defined for each test case as $\\,\\left|\\sigma_{\\mathrm{Mie}} - \\sigma_{\\mathrm{Rayleigh}}\\right| / \\sigma_{\\mathrm{Mie}}\\,$.\n\nImplement your program to process the following test suite. The ambient medium is free space in all cases. Angle unit is radians; the monostatic backscatter direction is $\\,\\theta = \\pi\\,$. When $\\,\\epsilon_r\\,$ is complex, interpret $\\,m = \\sqrt{\\epsilon_r}\\,$ as the principal-branch complex square root.\n\n- Test Case $\\,1\\,$ (happy path, moderately small size parameter): $\\,a = 1.0\\times 10^{-2}\\,\\mathrm{m}\\,$, $\\,f = 3.0\\times 10^{9}\\,\\mathrm{Hz}\\,$, $\\,\\epsilon_r = 4.0\\,$.\n- Test Case $\\,2\\,$ (Rayleigh regime target size parameter): choose $\\,a\\,$ such that $\\,x = 0.1\\,$ at $\\,f = 1.0\\times 10^{10}\\,\\mathrm{Hz}\\,$; use $\\,\\epsilon_r = 2.5\\,$. Numerically, this corresponds to $\\,a \\approx \\dfrac{0.1}{2\\pi f / c} \\approx 4.77465\\times 10^{-4}\\,\\mathrm{m}\\,$.\n- Test Case $\\,3\\,$ (lossy dielectric): $\\,a = 5.0\\times 10^{-3}\\,\\mathrm{m}\\,$, $\\,f = 5.0\\times 10^{9}\\,\\mathrm{Hz}\\,$, $\\,\\epsilon_r = 2.5 - i\\,1.0\\times 10^{-1}\\,$.\n- Test Case $\\,4\\,$ (Perfect Electric Conductor, PEC): $\\,a = 1.0\\times 10^{-3}\\,\\mathrm{m}\\,$, $\\,f = 5.0\\times 10^{9}\\,\\mathrm{Hz}\\,$, PEC boundary condition.\n- Test Case $\\,5\\,$ (extremely small size parameter): choose $\\,a\\,$ such that $\\,x = 0.01\\,$ at $\\,f = 5.0\\times 10^{9}\\,\\mathrm{Hz}\\,$; use $\\,\\epsilon_r = 4.0\\,$. Numerically, this corresponds to $\\,a \\approx \\dfrac{0.01}{2\\pi f / c} \\approx 9.54930\\times 10^{-5}\\,\\mathrm{m}\\,$.\n\nRequired final output format: your program must produce a single line containing a comma-separated list enclosed in square brackets of the five relative-error values for the test cases in the order listed above, for example $\\left[r_1,r_2,r_3,r_4,r_5\\right]$, where each $\\,r_j\\,$ is a decimal number. The outputs are dimensionless decimals and must not include any physical unit symbols.",
            "solution": "The problem requires the computation of the monostatic backscattered Radar Cross Section (RCS) of an electrically small sphere and the comparison between a full multipole expansion solution (Mie theory) and its lowest-order approximation (Rayleigh theory). The solution is grounded in the classical theory of electromagnetic scattering from a sphere, which is derived from Maxwell's equations.\n\n**1. Theoretical Framework: Maxwell's Equations and Wave Expansion**\n\nWe begin with the time-harmonic Maxwell's equations in a source-free, homogeneous, and isotropic medium, assuming an $e^{-i\\omega t}$ time dependence:\n$$ \\nabla \\times \\mathbf{E} = i\\omega\\mu \\mathbf{H} $$\n$$ \\nabla \\times \\mathbf{H} = -i\\omega\\epsilon \\mathbf{E} $$\nHere, $\\mathbf{E}$ and $\\mathbf{H}$ are the complex vector fields for electric and magnetic fields, $\\omega$ is the angular frequency, and $\\epsilon$ and $\\mu$ are the permittivity and permeability of the medium, respectively. These equations can be combined to yield the vector Helmholtz equation:\n$$ \\nabla^2 \\mathbf{F} + k^2 \\mathbf{F} = 0 $$\nwhere $\\mathbf{F}$ can be either $\\mathbf{E}$ or $\\mathbf{H}$, and $k = \\omega\\sqrt{\\epsilon\\mu}$ is the wavenumber.\n\nFor a scattering problem involving a sphere, it is natural to use a spherical coordinate system $(r, \\theta, \\phi)$. The solutions to the vector Helmholtz equation in this system are the vector spherical harmonics, $\\mathbf{M}_{nm}$ and $\\mathbf{N}_{nm}$. Any electromagnetic field can be expanded as a series of these functions.\n\nAn incident plane wave, assumed to be propagating along the $\\hat{z}$-axis and polarized in the $\\hat{x}$-direction, can be expanded in vector spherical harmonics involving spherical Bessel functions of the first kind, $j_n(kr)$. The scattered field outside the sphere is expanded using functions that represent outgoing waves, which involves spherical Hankel functions of the first kind, $h_n^{(1)}(kr) = j_n(kr) + i y_n(kr)$, where $y_n(kr)$ are spherical Bessel functions of the second kind. The field transmitted inside the sphere is expanded using functions that are regular at the origin, i.e., $j_n(k_1 r)$, where $k_1$ is the wavenumber inside the sphere.\n\n**2. Boundary Conditions and Scattering Coefficients**\n\nThe unknown expansion coefficients for the scattered field ($a_n$ and $b_n$, often called Mie coefficients) are determined by imposing boundary conditions at the surface of the sphere ($r=a$). The tangential components of the electric field $\\mathbf{E}$ and magnetic field $\\mathbf{H}$ must be continuous across the boundary. For a non-magnetic sphere (relative permeability $\\mu_r=1$), with relative permittivity $\\epsilon_r$ placed in free space ($\\epsilon_{r,\\text{med}}=1, \\mu_r=1$), this procedure yields the following expressions for the coefficients.\n\nLet $x=ka$ be the size parameter, where $k=2\\pi f/c$ is the free-space wavenumber. Let $m=\\sqrt{\\epsilon_r}$ be the refractive index of the sphere, and $y=m x$. The coefficients $a_n$ (for TM modes) and $b_n$ (for TE modes) are given by:\n$$ a_n = \\frac{m \\psi_n(y) \\psi_n'(x) - \\psi_n(x) \\psi_n'(y)}{m \\psi_n(y) \\zeta_n'(x) - \\zeta_n(x) \\psi_n'(y)} $$\n$$ b_n = \\frac{\\psi_n(y) \\psi_n'(x) - m \\psi_n(x) \\psi_n'(y)}{\\psi_n(y) \\zeta_n'(x) - m \\zeta_n(x) \\psi_n'(y)} $$\nHere, $\\psi_n(z)=z j_n(z)$ and $\\zeta_n(z)=z h_n^{(1)}(z)$ are the Riccati-Bessel functions, and the prime denotes differentiation with respect to the argument.\n\nFor a Perfect Electric Conductor (PEC) sphere, the boundary condition simplifies to the vanishing of the tangential electric field on the surface ($\\mathbf{E}_t(r=a) = 0$). This leads to simpler expressions for the coefficients:\n$$ a_n^{\\text{PEC}} = -\\frac{\\psi_n'(x)}{\\zeta_n'(x)} $$\n$$ b_n^{\\text{PEC}} = -\\frac{\\psi_n(x)}{\\zeta_n(x)} $$\n\n**3. Backscattered RCS and Approximations**\n\nThe far-field backscattered amplitude, $S_{\\text{back}}$, at an observation angle of $\\theta=\\pi$, is obtained by summing the contributions from each multipole order $n$:\n$$ S_{\\text{back}} = \\sum_{n=1}^{n_{\\max}} (2n+1)(-1)^n (b_n - a_n) $$\nThe series must be truncated at an order $n_{\\max}$ sufficient for numerical convergence. The problem specifies the truncation criterion $n_{\\max} = \\lfloor x + 4x^{1/3} + 2 \\rfloor$.\n\nThe monostatic backscattered Radar Cross Section (RCS), $\\sigma_{\\text{back}}$, is defined in the problem as:\n$$ \\sigma_{\\text{back}} = \\frac{1}{k^2} |S_{\\text{back}}|^2 $$\n\nThe problem requires a comparison of two computational approaches:\n1.  **Mie Solution**: The RCS, $\\sigma_{\\text{Mie}}$, is computed using the full truncated series for $S_{\\text{back}}$ as given above.\n2.  **Rayleigh Approximation**: For electrically small spheres ($x \\ll 1$), the scattering is dominated by the lowest-order term, the electric dipole ($n=1$). The Rayleigh approximation, $\\sigma_{\\text{Rayleigh}}$, is computed by retaining only the $n=1$ term in the series for $S_{\\text{back}}$.\n\nThe final output is the relative error between these two results for each test case:\n$$ \\text{Relative Error} = \\frac{|\\sigma_{\\text{Mie}} - \\sigma_{\\text{Rayleigh}}|}{\\sigma_{\\text{Mie}}} $$\n\n**4. Algorithmic Implementation**\n\nThe core of the implementation involves the numerical evaluation of the Riccati-Bessel functions and their derivatives. The `scipy.special` library provides functions `spherical_jn` and `spherical_yn` for the spherical Bessel functions. The Riccati-Bessel functions $\\psi_n(z)$ and $\\zeta_n(z)$ are constructed from these. Their derivatives can be efficiently computed using the relation $(z f_n(z))' = f_n(z) + z f_n'(z)$, where `scipy` can also provide the derivatives $f_n'(z)$.\n\nThe algorithm proceeds as follows for each test case:\n1.  Calculate the free-space wavenumber $k$ and the size parameter $x$.\n2.  Determine the truncation order $n_{\\max}$.\n3.  Pre-compute the values of $\\psi_n(x)$, $\\psi_n'(x)$, $\\zeta_n(x)$, and $\\zeta_n'(x)$ for $n$ from $1$ to $n_{\\max}$. If the sphere is dielectric, also compute $\\psi_n(y)$ and $\\psi_n'(y)$.\n4.  Iterate from $n=1$ to $n_{\\max}$, calculating the coefficients $a_n$ and $b_n$ using the appropriate formulas for a dielectric or PEC sphere.\n5.  Sum the terms to find the total backscatter amplitude $S_{\\text{back, Mie}}$. The $n=1$ term gives $S_{\\text{back, Rayleigh}}$.\n6.  Calculate $\\sigma_{\\text{Mie}}$ and $\\sigma_{\\text{Rayleigh}}$ from the respective amplitudes.\n7.  Compute the final relative error.\n\nThis procedure is systematically applied to all specified test cases to generate the required output.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import spherical_jn, spherical_yn\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    C_LIGHT = 2.99792458e8  # Speed of light in vacuum, m/s\n\n    def riccati_bessel(n_max, z):\n        \"\"\"\n        Computes Riccati-Bessel functions psi_n(z), zeta_n(z) and their derivatives.\n        psi_n(z) = z * j_n(z)\n        zeta_n(z) = z * h_n^(1)(z) = z * (j_n(z) + i*y_n(z))\n        Derivatives are computed using scipy's derivative flag for robustness.\n        \"\"\"\n        orders = np.arange(n_max + 1)\n        z_c = complex(z)\n\n        # Handle z=0 case, although not expected in test cases\n        if z_c == 0:\n            # psi_n(0) is 0 for n>=0\n            # zeta_n(0) is divergent\n            psi = np.zeros(n_max + 1, dtype=np.complex128)\n            zeta = np.full(n_max + 1, np.inf, dtype=np.complex128)\n            psi_prime = np.zeros(n_max + 1, dtype=np.complex128)\n            zeta_prime = np.full(n_max + 1, np.inf, dtype=np.complex128)\n            if n_max >= 0:\n                psi[0] = 0.0 # sin(0)\n                psi_prime[0] = 1.0 # cos(0)\n            return psi, psi_prime, zeta, zeta_prime\n\n        # Spherical Bessel functions j_n(z) and y_n(z) and their derivatives\n        jn = spherical_jn(orders, z_c)\n        yn = spherical_yn(orders, z_c)\n        jn_d = spherical_jn(orders, z_c, derivative=True)\n        yn_d = spherical_yn(orders, z_c, derivative=True)\n\n        # Riccati-Bessel functions\n        # psi_n(z) = z * j_n(z)\n        psi = z_c * jn\n        # zeta_n(z) = z * h_n^(1)(z)\n        zeta = z_c * (jn + 1j * yn)\n\n        # Derivatives\n        # [z*f_n(z)]' = f_n(z) + z*f'_n(z)\n        psi_prime = jn + z_c * jn_d\n        zeta_prime = (jn + z_c * jn_d) + 1j * (yn + z_c * yn_d)\n\n        return psi, psi_prime, zeta, zeta_prime\n\n    def compute_rcs(a, f, material):\n        \"\"\"\n        Computes Mie and Rayleigh RCS for a given sphere.\n        'material' is either a complex number for epsilon_r or the string 'PEC'.\n        \"\"\"\n        k = 2 * np.pi * f / C_LIGHT\n        x = k * a\n\n        # Truncation order for the Mie series\n        # Add a small epsilon to x for the x=0 case to avoid cbrt(0) issues.\n        x_eff = x if x > 0 else 1e-12\n        n_max = int(np.floor(x_eff + 4 * np.cbrt(x_eff) + 2))\n        if n_max  1: n_max = 1\n\n        # Pre-compute Riccati-Bessel functions for argument x\n        psi_x, psi_prime_x, zeta_x, zeta_prime_x = riccati_bessel(n_max, x)\n\n        # Pre-compute for argument y if dielectric\n        if material != 'PEC':\n            epsilon_r = material\n            m = np.sqrt(epsilon_r)\n            y = m * x\n            psi_y, psi_prime_y, _, _ = riccati_bessel(n_max, y)\n\n        s_mie = 0.0 + 0.0j\n        s_rayleigh = 0.0 + 0.0j\n\n        # Sum the multipole series\n        for n in range(1, n_max + 1):\n            p_x, pp_x = psi_x[n], psi_prime_x[n]\n            z_x, zp_x = zeta_x[n], zeta_prime_x[n]\n\n            if material == 'PEC':\n                # PEC sphere coefficients\n                an = -pp_x / zp_x if zp_x != 0 else np.inf\n                bn = -p_x / z_x if z_x != 0 else np.inf\n            else:\n                # Dielectric sphere coefficients\n                p_y, pp_y = psi_y[n], psi_prime_y[n]\n                \n                num_a = m * p_y * pp_x - p_x * pp_y\n                den_a = m * p_y * zp_x - z_x * pp_y\n                an = num_a / den_a if den_a != 0 else np.inf\n\n                num_b = p_y * pp_x - m * p_x * pp_y\n                den_b = p_y * zp_x - m * z_x * pp_y\n                bn = num_b / den_b if den_b != 0 else np.inf\n            \n            term = (2 * n + 1) * ((-1)**n) * (bn - an)\n            s_mie += term\n            \n            if n == 1:\n                s_rayleigh = term\n        \n        sigma_mie = np.abs(s_mie)**2 / k**2\n        sigma_rayleigh = np.abs(s_rayleigh)**2 / k**2\n        \n        return sigma_mie, sigma_rayleigh\n\n    # Define the test cases from the problem statement\n    test_cases_params = [\n        {'a': 1.0e-2, 'f': 3.0e9, 'material': 4.0},\n        {'x': 0.1,   'f': 1.0e10, 'material': 2.5},\n        {'a': 5.0e-3, 'f': 5.0e9, 'material': 2.5 - 0.1j},\n        {'a': 1.0e-3, 'f': 5.0e9, 'material': 'PEC'},\n        {'x': 0.01,  'f': 5.0e9, 'material': 4.0},\n    ]\n\n    results = []\n    for params in test_cases_params:\n        f = params['f']\n        material = params['material']\n\n        if 'a' in params:\n            a = params['a']\n        else: # Calculate 'a' from 'x'\n            x = params['x']\n            k = 2 * np.pi * f / C_LIGHT\n            a = x / k\n\n        sigma_mie, sigma_rayleigh = compute_rcs(a, f, material)\n\n        if sigma_mie == 0:\n            # This case is unlikely and implies zero scattering\n            relative_error = 0.0 if sigma_rayleigh == 0 else 1.0\n        else:\n            relative_error = np.abs(sigma_mie - sigma_rayleigh) / sigma_mie\n        \n        results.append(relative_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While analytical solutions are limited to simple geometries, complex real-world objects are typically analyzed using numerical methods like the Finite-Difference Time-Domain (FDTD) method, which computes fields and currents within a finite \"near-zone\" domain. A critical step in the simulation pipeline is to transform this near-zone data into far-field quantities like RCS. This practice guides you through the implementation of a near-to-far-field transformation (NTFF), tackling practical challenges such as handling wideband signals from time-domain simulations and mitigating artifacts through appropriate windowing functions . This skill is essential for extracting meaningful RCS data from modern electromagnetic solvers.",
            "id": "3343797",
            "problem": "You are given a near-zone current-density signal typical of Finite-Difference Time-Domain (FDTD) simulations and asked to validate a frequency-domain near-to-far transform that recovers the Radar Cross Section (RCS) from the current data. The specific scenario is an electrically small dielectric sphere (Rayleigh regime) illuminated by a wideband, Gaussian-modulated plane wave. The near-zone data consist of the polarization current density within the sphere. You must derive, implement, and validate the frequency-domain near-to-far transform using only fundamental laws and core definitions.\n\nThe fundamental basis to use is as follows:\n- Maxwell’s equations in the frequency domain with time-harmonic convention $e^{j \\omega t}$.\n- The radiation integral for the electric field produced by a source current density in the frequency domain:\n$$\n\\mathbf{E}(\\mathbf{r},\\omega) = j \\omega \\mu_0 \\int_V \\mathbf{G}(\\mathbf{r}-\\mathbf{r}',\\omega)\\,\\mathbf{J}(\\mathbf{r}',\\omega)\\, dV',\n$$\nwhere $\\mathbf{G}$ is the dyadic Green’s function of free space, and in the far zone this reduces to the scalar Green’s function with the usual far-field approximation.\n- The far-zone approximation of the scalar Green’s function for $|\\mathbf{r}| \\to \\infty$:\n$$\nG(\\mathbf{r}-\\mathbf{r}',\\omega) \\approx \\frac{e^{-j k r}}{4\\pi r}e^{j k \\hat{\\mathbf{r}}\\cdot \\mathbf{r}'}, \\quad k = \\frac{\\omega}{c}.\n$$\n- The definition of RCS:\n$$\n\\sigma(\\theta,\\phi;\\omega) = \\frac{4\\pi r^2 \\left\\lvert \\mathbf{E}_{\\text{scat}}(\\mathbf{r},\\omega)\\right\\rvert^2}{\\left\\lvert \\mathbf{E}_{\\text{inc}}(\\omega)\\right\\rvert^2},\n$$\nwhere $\\mathbf{r}$ is in the far zone and $\\mathbf{E}_{\\text{inc}}(\\omega)$ is the phasor amplitude of the incident field at the scatterer location.\n\nSetup. A dielectric sphere of radius $a = 0.01\\,\\text{m}$, with relative permittivity $\\varepsilon_r = 3.0$, is illuminated by a plane wave with electric field\n$$\nE_{\\text{inc}}(t) = E_0 \\exp\\!\\left(-\\frac{(t-t_0)^2}{2\\sigma_t^2}\\right)\\cos\\!\\left(2\\pi f_c (t-t_0)\\right),\n$$\nwith $E_0 = 1\\,\\text{V/m}$, $f_c = 0.5\\,\\text{GHz}$, and $\\sigma_t = 0.5\\,\\text{ns}$. The time axis is discretized uniformly over $N$ samples with sampling interval $\\Delta t$, giving a total time $T = N \\Delta t$. Use $N = 4096$, $\\Delta t = 0.02\\,\\text{ns}$, and $t_0 = T/2$. The polarization current density inside the sphere is uniform in space and given by\n$$\n\\mathbf{J}(\\mathbf{r},t) = \\varepsilon_0 \\Gamma \\frac{\\partial E_{\\text{inc}}(t)}{\\partial t}\\,\\hat{\\mathbf{e}}_p, \\quad \\Gamma = \\frac{3(\\varepsilon_r - 1)}{\\varepsilon_r + 2},\n$$\nfor $\\lvert \\mathbf{r} \\rvert \\le a$, and $\\mathbf{J}(\\mathbf{r},t) = \\mathbf{0}$ outside the sphere. Here $\\hat{\\mathbf{e}}_p$ is a fixed polarization unit vector (take it as the $z$-axis). The observation point is in the far zone at range $r = 1000\\,\\text{m}$ and direction $(\\theta,\\phi)$ in spherical coordinates, with $\\theta$ measured from the $z$-axis. Use the International System of Units (SI) consistently. Angles must be in degrees where specified.\n\nNear-to-far transform. Starting from the above base, derive that in the far zone the scattered field in the frequency domain can be written as\n$$\n\\mathbf{E}_{\\text{scat}}(\\mathbf{r},\\omega) \\approx \\frac{j\\omega \\mu_0 e^{-j k r}}{4\\pi r}\\,\\hat{\\mathbf{r}} \\times \\left(\\hat{\\mathbf{r}} \\times \\int_V \\mathbf{J}(\\mathbf{r}',\\omega)\\,e^{j k \\hat{\\mathbf{r}}\\cdot \\mathbf{r}'}\\,dV' \\right).\n$$\nUnder the electrically small condition $k a \\ll 1$, simplify the integral by neglecting $e^{j k \\hat{\\mathbf{r}}\\cdot \\mathbf{r}'}$ variation over the sphere. Use the relation between the polarization current density and polarization vector in frequency domain for linear dielectrics to connect $\\int_V \\mathbf{J}(\\mathbf{r}',\\omega)\\,dV'$ with the electric dipole moment. From this, obtain a computable expression for $\\mathbf{E}_{\\text{scat}}(\\mathbf{r},\\omega)$ in terms of the time Fourier transform of the given time-domain current density.\n\nRCS evaluation. Implement a discrete algorithm that:\n1. Constructs $E_{\\text{inc}}(t)$ and its time derivative $\\partial E_{\\text{inc}}(t)/\\partial t$ analytically over the given time axis.\n2. Forms the uniform polarization current density $\\mathbf{J}(\\mathbf{r},t)$ inside the sphere (constant in space, time-dependent) using the given formula; then constructs the total current $\\mathbf{J}_{\\text{tot}}(t) = \\int_V \\mathbf{J}(\\mathbf{r},t)dV$, where $V = \\frac{4}{3}\\pi a^3$ is the sphere volume.\n3. Applies a time-domain window $w(t)$ to $\\mathbf{J}_{\\text{tot}}(t)$ only (representing different FDTD time-gating/windowing strategies). Do not apply any window to $E_{\\text{inc}}(t)$.\n4. Computes the discrete-time Fourier transforms of the windowed $\\mathbf{J}_{\\text{tot}}(t)$ and of $E_{\\text{inc}}(t)$ using the Fast Fourier Transform (FFT). Treat the FFT output as samples of the continuous-time Fourier transform up to a common scaling, so that ratios of spectra are meaningful.\n5. Uses the far-zone near-to-far expression to compute the magnitude of $\\mathbf{E}_{\\text{scat}}(\\mathbf{r},\\omega)$ from the spectrum of $\\mathbf{J}_{\\text{tot}}(t)$ for a given polar angle $\\theta$ (assume azimuthal symmetry for a $z$-polarized dipole), and then computes the frequency-dependent RCS $\\sigma(\\theta,\\omega)$ from its definition. Express $\\sigma$ in square meters, but the requested outputs below are dimensionless relative errors.\n6. Derives the theoretical Rayleigh-sphere differential RCS as a function of frequency and $\\theta$ from the same fundamental base, and uses it as the reference to quantify the error of the near-to-far result.\n\nAssessment of time-windowing. Investigate the effect of different time windows $w(t)$ applied to $\\mathbf{J}_{\\text{tot}}(t)$ for a wideband signal by computing the mean relative error over a small set of frequencies. Define the frequency set\n$$\n\\mathcal{F} = \\{0.3\\,\\text{GHz},\\,0.5\\,\\text{GHz},\\,0.7\\,\\text{GHz}\\},\n$$\nand interpret these as radians per second via $\\omega = 2\\pi f$. Use linear interpolation on the FFT frequency axis to evaluate spectra at these frequencies.\n\nTest suite. Compute the mean relative error, defined as the arithmetic mean of $\\left\\lvert \\sigma_{\\text{est}}(\\theta,f) - \\sigma_{\\text{ref}}(\\theta,f)\\right\\rvert / \\sigma_{\\text{ref}}(\\theta,f)$ over $f \\in \\mathcal{F}$, for the following three cases:\n- Case A (happy path): Full-record Hann window applied to $\\mathbf{J}_{\\text{tot}}(t)$, observation at $\\theta = 90^\\circ$.\n- Case B (edge case): Rectangular time gate of half-width $0.5\\,\\sigma_t$ centered at $t_0$ applied to $\\mathbf{J}_{\\text{tot}}(t)$, observation at $\\theta = 90^\\circ$.\n- Case C (intermediate): Tukey window with parameter $\\alpha = 0.5$ applied within a rectangular gate of half-width $1.5\\,\\sigma_t$ centered at $t_0$ (zero elsewhere), observation at $\\theta = 45^\\circ$.\n\nAngle unit: degrees. RCS unit: square meters. Errors must be reported as pure decimals (dimensionless), not percentages.\n\nFinal output format. Your program should produce a single line of output containing the three mean relative errors, in the order [Case A, Case B, Case C], as a comma-separated list enclosed in square brackets (e.g., \"[0.001234,0.567890,0.012345]\"). Each float must be rounded to six decimal places.",
            "solution": "The problem requires the derivation, implementation, and validation of a frequency-domain near-to-far transform (NTFF) for calculating the Radar Cross Section (RCS) of an electrically small dielectric sphere. The validation is performed by comparing the results of the NTFF algorithm against the analytical solution for Rayleigh scattering.\n\nThe fundamental starting point is the frequency-domain radiation integral for the scattered electric field $\\mathbf{E}_{\\text{scat}}$ produced by a source current density $\\mathbf{J}$. A direct approach in the far-zone begins with the vector potential $\\mathbf{A}(\\mathbf{r},\\omega)$, defined as:\n$$\n\\mathbf{A}(\\mathbf{r},\\omega) = \\mu_0 \\int_V G(\\mathbf{r}-\\mathbf{r}',\\omega)\\,\\mathbf{J}(\\mathbf{r}',\\omega)\\, dV'\n$$\nHere, $\\mathbf{J}(\\mathbf{r}',\\omega)$ is the Fourier transform of the time-dependent current density, $\\mu_0$ is the permeability of free space, and $G(\\mathbf{r}-\\mathbf{r}',\\omega)$ is the scalar Green's function for free space. In the far zone, where the distance to the observation point $r = |\\mathbf{r}|$ is much larger than the dimensions of the source region $|\\mathbf{r}'|$, we employ the far-field approximation for the Green's function:\n$$\nG(\\mathbf{r}-\\mathbf{r}',\\omega) \\approx \\frac{e^{-j k r}}{4\\pi r}e^{j k \\hat{\\mathbf{r}}\\cdot \\mathbf{r}'}\n$$\nwhere $k = \\omega/c$ is the wavenumber, $c$ is the speed of light, and $\\hat{\\mathbf{r}}$ is the unit vector pointing from the origin to the observation point.\n\nSubstituting this into the expression for $\\mathbf{A}$ yields the far-zone vector potential:\n$$\n\\mathbf{A}(\\mathbf{r},\\omega) \\approx \\frac{\\mu_0 e^{-j k r}}{4\\pi r} \\int_V \\mathbf{J}(\\mathbf{r}',\\omega)\\,e^{j k \\hat{\\mathbf{r}}\\cdot \\mathbf{r}'}\\,dV'\n$$\nIn the far zone, the scattered fields are transverse electromagnetic (TEM) waves, and the electric field is related to the vector potential by $\\mathbf{E}_{\\text{scat}} \\approx -j\\omega \\mathbf{A}_{\\perp}$, where $\\mathbf{A}_{\\perp}$ is the component of $\\mathbf{A}$ perpendicular to $\\hat{\\mathbf{r}}$. This transverse projection can be written as $\\mathbf{A}_{\\perp} = -\\hat{\\mathbf{r}}\\times(\\hat{\\mathbf{r}}\\times\\mathbf{A})$. Thus,\n$$\n\\mathbf{E}_{\\text{scat}}(\\mathbf{r},\\omega) \\approx j\\omega [\\hat{\\mathbf{r}} \\times (\\hat{\\mathbf{r}} \\times \\mathbf{A}(\\mathbf{r},\\omega))]\n$$\nSubstituting the far-zone expression for $\\mathbf{A}$:\n$$\n\\mathbf{E}_{\\text{scat}}(\\mathbf{r},\\omega) \\approx \\frac{j\\omega \\mu_0 e^{-j k r}}{4\\pi r} \\left[ \\hat{\\mathbf{r}} \\times \\left(\\hat{\\mathbf{r}} \\times \\int_V \\mathbf{J}(\\mathbf{r}',\\omega)\\,e^{j k \\hat{\\mathbf{r}}\\cdot \\mathbf{r}'}\\,dV' \\right) \\right]\n$$\nThis completes the derivation of the required far-zone field expression.\n\nFor an electrically small scatterer, where the product of the maximum wavenumber $k$ and the scatterer's characteristic size $a$ is much less than one ($ka \\ll 1$), the phase term $e^{j k \\hat{\\mathbf{r}}\\cdot \\mathbf{r}'}$ in the integral varies negligibly over the volume $V$ of the scatterer (since $|\\mathbf{r}'| \\le a$). We can therefore approximate it by its value at the origin, $e^{j0} = 1$. The integral simplifies to:\n$$\n\\int_V \\mathbf{J}(\\mathbf{r}',\\omega)\\,e^{j k \\hat{\\mathbf{r}}\\cdot \\mathbf{r}'}\\,dV' \\approx \\int_V \\mathbf{J}(\\mathbf{r}',\\omega)\\,dV'\n$$\nThe problem states that the polarization current density $\\mathbf{J}(\\mathbf{r},t)$ is spatially uniform within the sphere. Thus, its Fourier transform $\\mathbf{J}(\\mathbf{r},\\omega)$ is also spatially uniform. The integral becomes the product of the current density spectrum and the sphere's volume $V_{\\text{sphere}} = \\frac{4}{3}\\pi a^3$. Let us define the total current spectrum as $\\mathbf{J}_{\\text{tot}}(\\omega) = \\int_V \\mathbf{J}(\\mathbf{r}',\\omega) dV'$. The scattered field is then:\n$$\n\\mathbf{E}_{\\text{scat}}(\\mathbf{r},\\omega) \\approx \\frac{j\\omega \\mu_0 e^{-j k r}}{4\\pi r} \\left[ \\hat{\\mathbf{r}} \\times \\left(\\hat{\\mathbf{r}} \\times \\mathbf{J}_{\\text{tot}}(\\omega) \\right) \\right]\n$$\nThe problem specifies a $z$-polarized source, $\\mathbf{J}_{\\text{tot}}(\\omega) = J_{\\text{tot}}(\\omega) \\hat{\\mathbf{z}}$. Using the vector identity $\\mathbf{A} \\times (\\mathbf{B} \\times \\mathbf{C}) = \\mathbf{B}(\\mathbf{A}\\cdot\\mathbf{C}) - \\mathbf{C}(\\mathbf{A}\\cdot\\mathbf{B})$, the cross product term becomes:\n$$\n\\hat{\\mathbf{r}} \\times (\\hat{\\mathbf{r}} \\times J_{\\text{tot}}(\\omega)\\hat{\\mathbf{z}}) = J_{\\text{tot}}(\\omega)[\\hat{\\mathbf{r}}(\\hat{\\mathbf{r}}\\cdot\\hat{\\mathbf{z}}) - \\hat{\\mathbf{z}}(\\hat{\\mathbf{r}}\\cdot\\hat{\\mathbf{r}})] = J_{\\text{tot}}(\\omega)[\\cos\\theta\\hat{\\mathbf{r}} - \\hat{\\mathbf{z}}]\n$$\nIn spherical coordinates, $\\hat{\\mathbf{z}} = \\cos\\theta\\hat{\\mathbf{r}} - \\sin\\theta\\hat{\\mathbf{\\theta}}$, so the term simplifies to $-J_{\\text{tot}}(\\omega) \\sin\\theta \\hat{\\mathbf{\\theta}}$. The magnitude of the scattered field is:\n$$\n|\\mathbf{E}_{\\text{scat}}(\\mathbf{r},\\omega)| \\approx \\frac{\\omega \\mu_0}{4\\pi r} |J_{\\text{tot}}(\\omega)| \\sin\\theta\n$$\nThe RCS, $\\sigma$, is defined as $\\sigma(\\theta,\\omega) = 4\\pi r^2 \\frac{|\\mathbf{E}_{\\text{scat}}(\\mathbf{r},\\omega)|^2}{|\\mathbf{E}_{\\text{inc}}(\\omega)|^2}$. Substituting the expression for $|\\mathbf{E}_{\\text{scat}}|$, we obtain the estimated RCS:\n$$\n\\sigma_{\\text{est}}(\\theta,\\omega) = 4\\pi r^2 \\frac{\\omega^2 \\mu_0^2}{16\\pi^2 r^2} \\frac{|J_{\\text{tot}}(\\omega)|^2}{|E_{\\text{inc}}(\\omega)|^2} \\sin^2\\theta = \\frac{\\omega^2 \\mu_0^2}{4\\pi} \\frac{|J_{\\text{tot}}(\\omega)|^2}{|E_{\\text{inc}}(\\omega)|^2} \\sin^2\\theta\n$$\nThe numerical algorithm will compute $|J_{\\text{tot}}(\\omega)|$ and $|E_{\\text{inc}}(\\omega)|$ using the Fast Fourier Transform (FFT) of the corresponding time-domain signals. Specifically, $J_{\\text{tot}}(t)$ is constructed from the analytical derivative of the incident field and then multiplied by a time-domain window function $w(t)$ before the FFT. The spectra at the required frequencies are found by linear interpolation of the FFT results.\n\nFor validation, we need a reference RCS, $\\sigma_{\\text{ref}}$. This is the analytical Rayleigh scattering cross-section. The polarization current density is $\\mathbf{J} = \\partial\\mathbf{P}/\\partial t$, where the polarization vector is $\\mathbf{P} \\approx \\varepsilon_0(\\varepsilon_r-1)\\mathbf{E}_{\\text{int}}$. For a small dielectric sphere, the internal field $\\mathbf{E}_{\\text{int}}$ is uniform and related to the incident field $\\mathbf{E}_{\\text{inc}}$ by $\\mathbf{E}_{\\text{int}} = \\frac{3}{\\varepsilon_r+2}\\mathbf{E}_{\\text{inc}}$. Thus, $\\mathbf{J}(t) = \\varepsilon_0 (\\varepsilon_r-1)\\frac{3}{\\varepsilon_r+2} \\frac{\\partial \\mathbf{E}_{\\text{inc}}(t)}{\\partial t} = \\varepsilon_0 \\Gamma \\frac{\\partial \\mathbf{E}_{\\text{inc}}(t)}{\\partial t}$, which matches the problem's definition with $\\Gamma = \\frac{3(\\varepsilon_r-1)}{\\varepsilon_r+2}$.\nThe induced electric dipole moment is $\\mathbf{p}(t) = V_{\\text{sphere}} \\mathbf{P}(t)$, so in the frequency domain $\\mathbf{p}(\\omega) = V_{\\text{sphere}}\\varepsilon_0 \\Gamma \\mathbf{E}_{\\text{inc}}(\\omega)$.\nThe well-known formula for the RCS of an electric dipole $\\mathbf{p}$ is $\\sigma = \\frac{k^4 Z_0^2}{4\\pi} \\frac{|\\hat{\\mathbf{r}} \\times (\\hat{\\mathbf{r}} \\times \\mathbf{p})|^2}{|\\mathbf{E}_{\\text{inc}}|^2}$. For $\\mathbf{p}$ along the $z$-axis, this becomes:\n$$\n\\sigma_{\\text{ref}}(\\theta,\\omega) = \\frac{k^4 Z_0^2}{4\\pi} \\frac{|p(\\omega)|^2 \\sin^2\\theta}{|E_{\\text{inc}}(\\omega)|^2} = \\frac{k^4 Z_0^2}{4\\pi} (V_{\\text{sphere}}\\varepsilon_0 \\Gamma)^2 \\sin^2\\theta\n$$\nUsing $Z_0^2 = \\mu_0/\\varepsilon_0$ and $V_{\\text{sphere}} = \\frac{4}{3}\\pi a^3$:\n$$\n\\sigma_{\\text{ref}}(\\theta,\\omega) = \\frac{k^4 \\mu_0}{4\\pi\\varepsilon_0} \\left(\\frac{4}{3}\\pi a^3 \\varepsilon_0 \\Gamma\\right)^2 \\sin^2\\theta = \\frac{4\\pi}{9} k^4 a^6 \\Gamma^2 \\sin^2\\theta = 4\\pi k^4 a^6 \\left(\\frac{\\varepsilon_r - 1}{\\varepsilon_r + 2}\\right)^2 \\sin^2\\theta\n$$\nThis is the reference formula. We compute $\\sigma_{\\text{est}}$ and $\\sigma_{\\text{ref}}$ at frequencies $f \\in \\mathcal{F} = \\{0.3, 0.5, 0.7\\}\\,\\text{GHz}$ for each test case and find the mean relative error, $\\text{mean}(|\\sigma_{\\text{est}} - \\sigma_{\\text{ref}}| / \\sigma_{\\text{ref}})$. Different time windows applied to the current signal $J_{\\text{tot}}(t)$ will affect its spectrum $J_{\\text{tot}}(\\omega)$ due to spectral leakage and time-gating effects, leading to different errors. A full-record smooth window (Hann) is expected to perform best, while a sharp, narrow rectangular gate is expected to perform worst due to strong spectral convolution artifacts.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal.windows import hann, tukey\n\ndef solve():\n    \"\"\"\n    Solves the radar cross section validation problem.\n    \"\"\"\n    # Define physical constants\n    c0 = 299792458.0  # Speed of light in vacuum (m/s)\n    mu0 = 4 * np.pi * 1e-7  # Permeability of free space (H/m)\n    eps0 = 1 / (mu0 * c0**2)  # Permittivity of free space (F/m)\n\n    # Define problem parameters\n    a = 0.01  # Sphere radius (m)\n    eps_r = 3.0  # Relative permittivity\n    E0 = 1.0  # Incident field amplitude (V/m)\n    f_c = 0.5e9  # Carrier frequency (Hz)\n    sigma_t = 0.5e-9  # Gaussian pulse width (s)\n    N = 4096  # Number of time samples\n    dt = 0.02e-9  # Time step (s)\n    # r_obs = 1000.0 is not needed for the final RCS formula as it cancels out.\n    \n    T = N * dt\n    t0 = T / 2.0\n\n    # Define test cases\n    test_cases = [\n        {'type': 'hann', 'theta_deg': 90.0, 'label': 'A'},\n        {'type': 'rect', 'half_width_sigma': 0.5, 'theta_deg': 90.0, 'label': 'B'},\n        {'type': 'tukey', 'alpha': 0.5, 'half_width_sigma': 1.5, 'theta_deg': 45.0, 'label': 'C'}\n    ]\n\n    # Define target evaluation frequencies\n    freq_targets = np.array([0.3e9, 0.5e9, 0.7e9])\n\n    # Time and frequency axes\n    t = np.arange(N) * dt\n    tau = t - t0\n    freqs = np.fft.fftfreq(N, d=dt)\n\n    # --- Step 1: Construct incident field and its derivative ---\n    omega_c = 2 * np.pi * f_c\n    gauss = np.exp(-tau**2 / (2 * sigma_t**2))\n    E_inc_t = E0 * gauss * np.cos(omega_c * tau)\n    dE_inc_dt = -E0 * gauss * ((tau / sigma_t**2) * np.cos(omega_c * tau) + omega_c * np.sin(omega_c * tau))\n\n    # --- Step 2: Construct total current ---\n    Gamma = 3.0 * (eps_r - 1.0) / (eps_r + 2.0)\n    V_sphere = (4.0 / 3.0) * np.pi * a**3\n    J_tot_t = eps0 * Gamma * V_sphere * dE_inc_dt\n\n    # --- Step 4 (Part 1): FFT of incident field ---\n    E_inc_w_raw = np.fft.fft(E_inc_t)\n    \n    # Shift FFT results for interpolation\n    shifted_freqs = np.fft.fftshift(freqs)\n    shifted_E_inc_mag = np.fft.fftshift(np.abs(E_inc_w_raw))\n    \n    # Interpolate incident field magnitude spectrum at target frequencies\n    E_mag_interp = np.interp(freq_targets, shifted_freqs, shifted_E_inc_mag)\n\n    # --- Step 6: Define reference RCS formula ---\n    def get_sigma_ref(f, theta_deg):\n        omega_val = 2 * np.pi * f\n        k = omega_val / c0\n        theta_rad = np.deg2rad(theta_deg)\n        \n        # Using the standard Rayleigh formula\n        term1 = 4.0 * np.pi * k**4 * a**6\n        term2 = ((eps_r - 1.0) / (eps_r + 2.0))**2\n        term3 = np.sin(theta_rad)**2\n        return term1 * term2 * term3\n\n    # --- Step 5: Define estimated RCS formula ---\n    def get_sigma_est(f_array, theta_deg, J_mag_interp, E_mag_interp_local):\n        omega_vals = 2 * np.pi * f_array\n        theta_rad = np.deg2rad(theta_deg)\n        \n        # Handle potential division by zero\n        ratio_sq = np.zeros_like(E_mag_interp_local)\n        valid_indices = E_mag_interp_local != 0\n        ratio_sq[valid_indices] = (J_mag_interp[valid_indices] / E_mag_interp_local[valid_indices])**2\n        \n        term1 = (omega_vals**2 * mu0**2) / (4 * np.pi)\n        term2 = np.sin(theta_rad)**2\n        return term1 * ratio_sq * term2\n\n    results = []\n    # Loop over test cases\n    for case in test_cases:\n        # --- Step 3: Apply window to current ---\n        w = np.zeros(N)\n        if case['type'] == 'hann':\n            w = hann(N, sym=True)\n        elif case['type'] == 'rect':\n            hw = case['half_width_sigma'] * sigma_t\n            indices = (t >= t0 - hw)  (t = t0 + hw)\n            w[indices] = 1.0\n        elif case['type'] == 'tukey':\n            hw = case['half_width_sigma'] * sigma_t\n            indices = np.where((t >= t0 - hw)  (t = t0 + hw))[0]\n            if len(indices) > 0:\n                w[indices] = tukey(len(indices), alpha=case['alpha'], sym=True)\n\n        J_windowed_t = J_tot_t * w\n\n        # --- Step 4 (Part 2): FFT of windowed current ---\n        J_tot_w_raw = np.fft.fft(J_windowed_t)\n        shifted_J_tot_mag = np.fft.fftshift(np.abs(J_tot_w_raw))\n        J_mag_interp = np.interp(freq_targets, shifted_freqs, shifted_J_tot_mag)\n        \n        # --- Compute RCS and Error ---\n        sigma_est_vals = get_sigma_est(freq_targets, case['theta_deg'], J_mag_interp, E_mag_interp)\n        sigma_ref_vals = get_sigma_ref(freq_targets, case['theta_deg'])\n        \n        # Compute mean relative error\n        rel_errors = np.zeros_like(sigma_ref_vals)\n        valid_indices = sigma_ref_vals != 0\n        rel_errors[valid_indices] = np.abs(sigma_est_vals[valid_indices] - sigma_ref_vals[valid_indices]) / sigma_ref_vals[valid_indices]\n        mean_rel_error = np.mean(rel_errors)\n        \n        results.append(mean_rel_error)\n\n    # Format output as requested, rounding to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In many engineering design and optimization scenarios, the RCS must be evaluated for a wide range of material properties or geometric parameters. Running a full, high-fidelity simulation for each parameter is often computationally prohibitive. This advanced practice introduces a powerful solution: model order reduction (MOR), which creates a fast and accurate \"surrogate\" model from a few full-simulation \"snapshots\" . You will use Proper Orthogonal Decomposition (POD) to construct a parametric RCS model and, crucially, derive and implement a rigorous a posteriori error bound to certify the accuracy of your reduced model's predictions.",
            "id": "3343790",
            "problem": "Consider a frequency-domain scattering surrogate in which the dependence of the Radar Cross Section (RCS) on the observation angles and material distribution is modeled by a linear discretization of a Helmholtz-type operator with parametric relative permittivity. Let $\\boldsymbol{\\mu} \\in \\mathbb{R}^2$ parameterize the spatial distribution of the relative permittivity $\\varepsilon_r(\\mathbf{r};\\boldsymbol{\\mu})$ over a uniform two-dimensional grid of interior points. Let $\\mathbf{u}(\\boldsymbol{\\mu}) \\in \\mathbb{C}^N$ denote the discrete state vector, defined as the unique solution of a non-singular linear system $\\mathbf{M}(\\boldsymbol{\\mu}) \\mathbf{u}(\\boldsymbol{\\mu}) = \\mathbf{b}$, where $\\mathbf{M}(\\boldsymbol{\\mu}) \\in \\mathbb{R}^{N \\times N}$ is a symmetric positive definite matrix arising from the finite-difference discretization of a Helmholtz-type operator with Dirichlet boundary conditions, and $\\mathbf{b} \\in \\mathbb{C}^N$ encodes an incident plane wave. For an observation direction specified by polar and azimuthal angles $(\\theta,\\phi)$, with angles given in radians, define the far-field linear functional $\\mathbf{c}(\\theta,\\phi) \\in \\mathbb{C}^N$ such that the complex scattering amplitude is $y(\\theta,\\phi;\\boldsymbol{\\mu}) = \\mathbf{c}(\\theta,\\phi)^\\ast \\mathbf{u}(\\boldsymbol{\\mu})$. Define the Radar Cross Section as $\\sigma(\\theta,\\phi;\\boldsymbol{\\mu}) = 4\\pi \\, |y(\\theta,\\phi;\\boldsymbol{\\mu})|^2$, which is dimensionless in this surrogate model.\n\nYou are to construct a reduced-order model for $\\sigma(\\theta,\\phi;\\boldsymbol{\\mu})$ using Proper Orthogonal Decomposition (POD) and to derive and implement a rigorous a posteriori error bound on the RCS that uses the residual norm of the reduced solution. The full workflow must be derived from the following fundamental base: the linearity of the frequency-domain Maxwell equations leading to a Helmholtz-type discretization, the definition of the Euclidean norm and singular values for linear operators, and the definition of the RCS as a quadratic functional of a linear observation of the state.\n\nUse the following self-consistent discrete setting, which is to be treated as the mathematical definition of the computational model:\n\n- The computational domain is a square of side length $L = 0.5$ meters, discretized by a uniform grid of interior points of size $N_x \\times N_y$ with $N_x = 12$ and $N_y = 12$, so the total number of unknowns is $N = N_x N_y$. Let the grid spacing be $h = L/(N_x+1)$, and let the interior grid points be at coordinates $\\mathbf{r}_{ij} = (x_i,y_j)$ with $x_i = i h$ and $y_j = j h$ for $i \\in \\{1,\\dots,N_x\\}$ and $j \\in \\{1,\\dots,N_y\\}$.\n\n- The background permittivity is $\\varepsilon_{\\text{bg}} = 1$. The parametric relative permittivity is\n$$\n\\varepsilon_r(\\mathbf{r};\\boldsymbol{\\mu}) = \\varepsilon_{\\text{bg}} + \\mu_1 \\chi_{D_1}(\\mathbf{r}) + \\mu_2 \\chi_{D_2}(\\mathbf{r}),\n$$\nwhere $\\chi_{D}$ denotes the indicator function of a set $D$, and $D_1$ and $D_2$ are rectangles defined by\n$$\nD_1 = \\{(x,y) \\mid 0.20 \\le x \\le 0.30,\\ 0.20 \\le y \\le 0.30\\}, \\quad\nD_2 = \\{(x,y) \\mid 0.35 \\le x \\le 0.45,\\ 0.05 \\le y \\le 0.15\\}.\n$$\n\n- The free-space speed of light is $c_0 = 2.99792458 \\times 10^8\\ \\text{m/s}$. Fix the frequency at $f = 1.0 \\times 10^9\\ \\text{Hz}$, so the free-space wavenumber is $k_0 = 2\\pi f/c_0$.\n\n- Define the discrete operator with Dirichlet boundary conditions as\n$$\n\\mathbf{M}(\\boldsymbol{\\mu}) = \\mathbf{L}_h + k_0^2 \\operatorname{diag}(\\boldsymbol{\\varepsilon}_r(\\boldsymbol{\\mu})),\n$$\nwhere $\\mathbf{L}_h$ is the standard five-point finite-difference discretization of $- \\Delta$ on the interior grid (with stencil central value $4/h^2$ and nearest-neighbor couplings $-1/h^2$ in the coordinate directions), and $\\boldsymbol{\\varepsilon}_r(\\boldsymbol{\\mu}) \\in \\mathbb{R}^N$ is the vector of pointwise values of $\\varepsilon_r(\\mathbf{r};\\boldsymbol{\\mu})$ at the interior grid points.\n\n- The right-hand side is a unit-amplitude incident plane wave,\n$$\n\\mathbf{b} = \\left[\\exp\\left(\\mathrm{i} k_0 \\, \\hat{\\mathbf{k}}_{\\text{inc}} \\cdot \\mathbf{r}_\\ell\\right)\\right]_{\\ell=1}^N,\n$$\nwith incidence direction $\\hat{\\mathbf{k}}_{\\text{inc}}$ given by $(\\theta_{\\text{inc}},\\phi_{\\text{inc}}) = (\\pi/2, 0)$.\n\n- The observation vector for direction $(\\theta,\\phi)$ is\n$$\n\\mathbf{c}(\\theta,\\phi) = \\left[\\exp\\left(-\\mathrm{i} k_0 \\, \\hat{\\mathbf{k}}(\\theta,\\phi) \\cdot \\mathbf{r}_\\ell\\right)\\right]_{\\ell=1}^N,\n$$\nwhere $\\hat{\\mathbf{k}}(\\theta,\\phi) = [\\sin\\theta \\cos\\phi, \\sin\\theta \\sin\\phi, \\cos\\theta]^\\top$ and the grid points are embedded in the plane $z=0$.\n\nGiven training parameter samples $\\mathcal{P}_{\\text{train}} = \\{(\\mu_1,\\mu_2)\\}$, assemble the snapshot matrix from the corresponding full-order solutions $\\mathbf{u}(\\boldsymbol{\\mu})$ and compute a Proper Orthogonal Decomposition basis by singular value decomposition. Select the reduced basis dimension $r$ as the smallest integer such that the cumulative captured energy is at least $\\eta$, where $\\eta = 0.999$. Project the operator and right-hand side onto this basis to obtain a reduced solution $\\widetilde{\\mathbf{u}}(\\boldsymbol{\\mu})$.\n\nUsing only the fundamental facts that for any non-singular matrix $\\mathbf{M}$ the smallest singular value $\\alpha(\\boldsymbol{\\mu})$ satisfies $\\|\\mathbf{M}^{-1}\\|_2 = 1/\\alpha(\\boldsymbol{\\mu})$, that the state-space residual is $\\mathbf{r}(\\boldsymbol{\\mu}) = \\mathbf{b} - \\mathbf{M}(\\boldsymbol{\\mu}) \\widetilde{\\mathbf{u}}(\\boldsymbol{\\mu})$, and that the far-field map is linear, derive a computable a posteriori bound for the absolute RCS error $|\\sigma(\\theta,\\phi;\\boldsymbol{\\mu}) - \\widetilde{\\sigma}(\\theta,\\phi;\\boldsymbol{\\mu})|$ expressed in terms of the residual norm $\\|\\mathbf{r}(\\boldsymbol{\\mu})\\|_2$, the smallest singular value $\\alpha(\\boldsymbol{\\mu})$, the observation norm $\\|\\mathbf{c}(\\theta,\\phi)\\|_2$, and the reduced far-field amplitude $|\\widetilde{y}(\\theta,\\phi;\\boldsymbol{\\mu})|$. The bound must be valid for every $(\\theta,\\phi)$ and must not depend on any unknown quantity that is not computable from $\\mathbf{M}(\\boldsymbol{\\mu})$, $\\mathbf{b}$, $\\mathbf{c}(\\theta,\\phi)$, and $\\widetilde{\\mathbf{u}}(\\boldsymbol{\\mu})$.\n\nThen, implement the following numerical experiment:\n\n- Use the training set $\\mathcal{P}_{\\text{train}} = \\{(\\mu_1,\\mu_2)\\}$ with\n$$\n(\\mu_1,\\mu_2) \\in \\{(0.5,0.2),\\ (1.0,0.5),\\ (1.5,1.0)\\}.\n$$\n- Use the test set $\\mathcal{P}_{\\text{test}} = \\{(\\mu_1,\\mu_2)\\}$ with\n$$\n(\\mu_1,\\mu_2) \\in \\{(0.2,0.1),\\ (1.2,0.8),\\ (1.8,1.2)\\}.\n$$\n- Use the observation angles\n$$\n\\theta = \\pi/2,\\quad \\phi \\in \\{0,\\ \\pi/4,\\ \\pi/2,\\ \\pi\\},\n$$\nwith all angles in radians.\n\nFor each test parameter pair and each observation angle, compute:\n- the full-order solution $\\mathbf{u}(\\boldsymbol{\\mu})$,\n- the reduced-order approximation $\\widetilde{\\mathbf{u}}(\\boldsymbol{\\mu})$ built from the POD basis trained as above,\n- the true RCS $\\sigma(\\theta,\\phi;\\boldsymbol{\\mu})$ and the reduced RCS $\\widetilde{\\sigma}(\\theta,\\phi;\\boldsymbol{\\mu})$,\n- the derived a posteriori bound for the absolute RCS error.\n\nFor each test parameter pair, report the maximum over the specified set of angles of the ratio\n$$\n\\rho(\\boldsymbol{\\mu}) = \\max_{(\\theta,\\phi)} \\frac{\\left|\\sigma(\\theta,\\phi;\\boldsymbol{\\mu}) - \\widetilde{\\sigma}(\\theta,\\phi;\\boldsymbol{\\mu})\\right|}{\\text{bound}(\\theta,\\phi;\\boldsymbol{\\mu})},\n$$\nwhich is dimensionless.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test set given above, for example, $[\\rho_1,\\rho_2,\\rho_3]$. All angles in your computations must be in radians. No external input must be required; all constants, parameters, and sets must be defined in the program. The numerical values of the ratios must be printed as floating-point numbers.",
            "solution": "The problem requires the derivation of a rigorous a posteriori error bound for the Radar Cross Section (RCS) computed from a Proper Orthogonal Decomposition (POD) reduced-order model (ROM).\n\n### 1. Preliminaries and Definitions\n\nLet's establish the key quantities and relationships. The parameter is $\\boldsymbol{\\mu} \\in \\mathbb{R}^2$. For brevity, we will drop the explicit dependence on $\\boldsymbol{\\mu}$, $\\theta$, and $\\phi$ where the context is clear.\n\n-   **Full-Order Model (FOM):**\n    -   State equation: $\\mathbf{M}\\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u} \\in \\mathbb{C}^N$ is the full-order state vector.\n    -   Complex scattering amplitude (output): $y = \\mathbf{c}^*\\mathbf{u}$.\n    -   RCS: $\\sigma = 4\\pi |y|^2$.\n\n-   **Reduced-Order Model (ROM):**\n    -   The reduced basis is $\\mathbf{V} \\in \\mathbb{C}^{N \\times r}$, where the columns are orthonormal.\n    -   The reduced state approximation is $\\widetilde{\\mathbf{u}} = \\mathbf{V}\\mathbf{u}_r$, where $\\mathbf{u}_r \\in \\mathbb{C}^r$ are the reduced state coefficients. These are found by solving the Galerkin-projected system: $\\mathbf{M}_r \\mathbf{u}_r = \\mathbf{b}_r$, where $\\mathbf{M}_r = \\mathbf{V}^*\\mathbf{M}\\mathbf{V}$ and $\\mathbf{b}_r = \\mathbf{V}^*\\mathbf{b}$.\n    -   Reduced complex scattering amplitude: $\\widetilde{y} = \\mathbf{c}^*\\widetilde{\\mathbf{u}}$.\n    -   Reduced RCS: $\\widetilde{\\sigma} = 4\\pi |\\widetilde{y}|^2$.\n\n-   **Error and Residual:**\n    -   State error: $\\mathbf{e} = \\mathbf{u} - \\widetilde{\\mathbf{u}}$.\n    -   Output error: $e_y = y - \\widetilde{y} = \\mathbf{c}^*\\mathbf{e}$.\n    -   State residual: $\\mathbf{r} = \\mathbf{b} - \\mathbf{M}\\widetilde{\\mathbf{u}}$. This is a key computable quantity.\n\n### 2. Derivation of the Error Bound\n\nThe derivation proceeds in three steps: bounding the state error, then the output error, and finally the RCS error.\n\n**Step 2a: State Error Bound**\nWe relate the state error $\\mathbf{e}$ to the residual $\\mathbf{r}$.\nBy subtracting $\\mathbf{M}\\widetilde{\\mathbf{u}} = \\mathbf{b} - \\mathbf{r}$ from the FOM equation $\\mathbf{M}\\mathbf{u} = \\mathbf{b}$, we obtain the error equation:\n$$ \\mathbf{M}\\mathbf{u} - \\mathbf{M}\\widetilde{\\mathbf{u}} = \\mathbf{b} - (\\mathbf{b} - \\mathbf{r}) \\implies \\mathbf{M}(\\mathbf{u} - \\widetilde{\\mathbf{u}}) = \\mathbf{r} \\implies \\mathbf{M}\\mathbf{e} = \\mathbf{r} $$\nSince $\\mathbf{M}$ is non-singular, we can write $\\mathbf{e} = \\mathbf{M}^{-1}\\mathbf{r}$. Taking the Euclidean norm (2-norm) of both sides:\n$$ \\|\\mathbf{e}\\|_2 = \\|\\mathbf{M}^{-1}\\mathbf{r}\\|_2 \\le \\|\\mathbf{M}^{-1}\\|_2 \\|\\mathbf{r}\\|_2 $$\nThe problem states that $\\|\\mathbf{M}^{-1}\\|_2 = 1/\\alpha(\\boldsymbol{\\mu})$, where $\\alpha(\\boldsymbol{\\mu})$ is the smallest singular value of $\\mathbf{M}$. (Since $\\mathbf{M}$ is given as symmetric positive definite, $\\alpha(\\boldsymbol{\\mu})$ is its smallest eigenvalue). This gives the state error bound:\n$$ \\|\\mathbf{e}\\|_2 \\le \\frac{\\|\\mathbf{r}\\|_2}{\\alpha(\\boldsymbol{\\mu})} $$\n\n**Step 2b: Output Error Bound**\nThe magnitude of the error in the complex scattering amplitude, $|e_y|$, is bounded using the Cauchy-Schwarz inequality and the state error bound:\n$$ |e_y| = |y - \\widetilde{y}| = |\\mathbf{c}^*\\mathbf{e}| \\le \\|\\mathbf{c}\\|_2 \\|\\mathbf{e}\\|_2 $$\nSubstituting the bound for $\\|\\mathbf{e}\\|_2$:\n$$ |e_y| \\le \\frac{\\|\\mathbf{c}\\|_2 \\|\\mathbf{r}\\|_2}{\\alpha(\\boldsymbol{\\mu})} $$\nLet's define this computable upper bound on the output error magnitude as $\\Delta_y$:\n$$ \\Delta_y \\equiv \\frac{\\|\\mathbf{c}\\|_2 \\|\\mathbf{r}\\|_2}{\\alpha(\\boldsymbol{\\mu})} $$\nAll quantities on the right-hand side are computable from the ROM solution and the FOM operator.\n\n**Step 2c: RCS Error Bound**\nThe goal is to bound the absolute RCS error, $|\\sigma - \\widetilde{\\sigma}|$.\n$$ |\\sigma - \\widetilde{\\sigma}| = \\left| 4\\pi|y|^2 - 4\\pi|\\widetilde{y}|^2 \\right| = 4\\pi \\left| |y|^2 - |\\widetilde{y}|^2 \\right| $$\nWe relate $y$ to $\\widetilde{y}$ using the error $e_y$: $y = \\widetilde{y} + e_y$.\n$$ |y|^2 = (\\widetilde{y} + e_y)(\\overline{\\widetilde{y}} + \\overline{e_y}) = |\\widetilde{y}|^2 + \\widetilde{y}\\overline{e_y} + \\overline{\\widetilde{y}}e_y + |e_y|^2 = |\\widetilde{y}|^2 + 2\\operatorname{Re}(\\overline{\\widetilde{y}}e_y) + |e_y|^2 $$\nThe difference is $|y|^2 - |\\widetilde{y}|^2 = 2\\operatorname{Re}(\\overline{\\widetilde{y}}e_y) + |e_y|^2$. Using the triangle inequality:\n$$ \\left| |y|^2 - |\\widetilde{y}|^2 \\right| \\le \\left| 2\\operatorname{Re}(\\overline{\\widetilde{y}}e_y) \\right| + |e_y|^2 \\le 2|\\overline{\\widetilde{y}}e_y| + |e_y|^2 = 2|\\widetilde{y}||e_y| + |e_y|^2 $$\nThis expression is a monotonically increasing function of $|e_y|$ for non-negative $|e_y|$. We can therefore substitute the upper bound $\\Delta_y$ for $|e_y|$ to get a bound on the overall expression:\n$$ \\left| |y|^2 - |\\widetilde{y}|^2 \\right| \\le 2|\\widetilde{y}|\\Delta_y + \\Delta_y^2 $$\nFinally, multiplying by $4\\pi$ gives the desired a posteriori bound for the absolute RCS error:\n$$ \\text{bound}(\\theta,\\phi;\\boldsymbol{\\mu}) = |\\sigma - \\widetilde{\\sigma}| \\le 4\\pi \\left( 2|\\widetilde{y}|\\Delta_y + \\Delta_y^2 \\right) $$\nThis bound is computable, as it depends only on the reduced output $\\widetilde{y}$, the observation vector norm $\\|\\mathbf{c}\\|_2$, the residual norm $\\|\\mathbf{r}\\|_2$, and the operator's smallest eigenvalue $\\alpha(\\boldsymbol{\\mu})$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a POD-based reduced-order model for an RCS surrogate problem,\n    derives and implements an a posteriori error bound, and evaluates its \n    effectiveness on a set of test parameters.\n    \"\"\"\n    # 1. Define constants and parameters\n    L = 0.5  # m\n    NX, NY = 12, 12\n    N = NX * NY\n    H = L / (NX + 1)\n    \n    C0 = 2.99792458e8  # m/s\n    FREQ = 1.0e9  # Hz\n    K0 = 2 * np.pi * FREQ / C0\n    \n    EPS_BG = 1.0\n    ETA = 0.999  # POD energy capture threshold\n\n    # 2. Define geometry and model sets\n    D1_BOUNDS = ((0.20, 0.30), (0.20, 0.30))  # (x_bounds, y_bounds)\n    D2_BOUNDS = ((0.35, 0.45), (0.05, 0.15))\n    \n    P_TRAIN = [(0.5, 0.2), (1.0, 0.5), (1.5, 1.0)]\n    P_TEST = [(0.2, 0.1), (1.2, 0.8), (1.8, 1.2)]\n    \n    THETA_OBS = np.pi / 2\n    PHI_OBS_LIST = [0., np.pi/4, np.pi/2, np.pi]\n\n    # 3. Helper functions\n    def build_laplacian(nx, ny, h):\n        n_pts = nx * ny\n        Lh = np.zeros((n_pts, n_pts), dtype=float)\n        h2 = h * h\n        for j in range(ny):\n            for i in range(nx):\n                k = j * nx + i\n                Lh[k, k] = 4.0 / h2\n                if i > 0:   # Left neighbor\n                    Lh[k, j * nx + (i - 1)] = -1.0 / h2\n                if i  nx - 1: # Right neighbor\n                    Lh[k, j * nx + (i + 1)] = -1.0 / h2\n                if j > 0:   # Bottom neighbor\n                    Lh[k, (j - 1) * nx + i] = -1.0 / h2\n                if j  ny - 1: # Top neighbor\n                    Lh[k, (j + 1) * nx + i] = -1.0 / h2\n        return Lh\n\n    def get_epsilon_r_vector(mu, grid, d1_b, d2_b, eps_bg):\n        mu1, mu2 = mu\n        eps_r = np.full(grid.shape[0], eps_bg, dtype=float)\n        x, y = grid[:, 0], grid[:, 1]\n        \n        in_d1 = (x >= d1_b[0][0])  (x = d1_b[0][1])  \\\n                (y >= d1_b[1][0])  (y = d1_b[1][1])\n        in_d2 = (x >= d2_b[0][0])  (x = d2_b[0][1])  \\\n                (y >= d2_b[1][0])  (y = d2_b[1][1])\n\n        eps_r[in_d1] += mu1\n        eps_r[in_d2] += mu2\n        return eps_r\n\n    def get_c_vector(theta, phi, grid, k0):\n        # z=0 plane\n        kx = np.sin(theta) * np.cos(phi)\n        ky = np.sin(theta) * np.sin(phi)\n        k_dot_r = grid[:, 0] * kx + grid[:, 1] * ky\n        return np.exp(-1j * k0 * k_dot_r)\n\n    # 4. Generate grid coordinates\n    grid = np.zeros((N, 2))\n    for j in range(NY):\n        for i in range(NX):\n            k = j * NX + i\n            grid[k, 0] = (i + 1) * H  # x-coordinate\n            grid[k, 1] = (j + 1) * H  # y-coordinate\n\n    # 5. Pre-compute constant parts\n    Lh = build_laplacian(NX, NY, H)\n    # Incident wave vector b, from direction (theta=pi/2, phi=0) -> k_inc = (1,0,0)\n    b = np.exp(1j * K0 * grid[:, 0])\n\n    # --- TRAINING ---\n    # 6. Generate snapshots\n    snapshots = []\n    for mu_train in P_TRAIN:\n        eps_r = get_epsilon_r_vector(mu_train, grid, D1_BOUNDS, D2_BOUNDS, EPS_BG)\n        M = Lh + (K0**2) * np.diag(eps_r)\n        u = np.linalg.solve(M, b)\n        snapshots.append(u)\n    \n    S = np.array(snapshots).T  # Shape (N, num_snapshots)\n\n    # 7. Perform SVD and determine reduced basis V\n    U, s, _ = np.linalg.svd(S, full_matrices=False)\n    \n    # Calculate cumulative energy and find reduced dimension r\n    cumulative_energy = np.cumsum(s**2) / np.sum(s**2)\n    r = np.searchsorted(cumulative_energy, ETA, side='right') + 1\n\n    V = U[:, :r] # POD basis\n\n    # --- TESTING ---\n    final_ratios = []\n    for mu_test in P_TEST:\n        # a. Construct M(mu)\n        eps_r_test = get_epsilon_r_vector(mu_test, grid, D1_BOUNDS, D2_BOUNDS, EPS_BG)\n        M_test = Lh + (K0**2) * np.diag(eps_r_test)\n\n        # b. Solve for full solution u\n        u_full = np.linalg.solve(M_test, b)\n\n        # c. Build and solve reduced system for u_tilde\n        M_r = V.conj().T @ M_test @ V\n        b_r = V.conj().T @ b\n        u_r = np.linalg.solve(M_r, b_r)\n        u_reduced = V @ u_r\n\n        # d. Calculate residual r and its norm\n        residual = b - M_test @ u_reduced\n        residual_norm = np.linalg.norm(residual)\n\n        # e. Calculate smallest eigenvalue alpha of M\n        # M is real symmetric, use eigvalsh for efficiency\n        eigenvalues = np.linalg.eigvalsh(M_test)\n        alpha = eigenvalues[0]\n\n        # f. Loop over observation angles\n        ratios_for_current_mu = []\n        for phi_obs in PHI_OBS_LIST:\n            c_vec = get_c_vector(THETA_OBS, phi_obs, grid, K0)\n            c_norm = np.linalg.norm(c_vec)\n            \n            # Full and reduced outputs\n            y_full = c_vec.conj() @ u_full\n            sigma_full = 4 * np.pi * np.abs(y_full)**2\n            \n            y_reduced = c_vec.conj() @ u_reduced\n            sigma_reduced = 4 * np.pi * np.abs(y_reduced)**2\n            \n            # A posteriori error bound calculation\n            delta_y = (c_norm * residual_norm) / alpha\n            bound = 4 * np.pi * (2 * np.abs(y_reduced) * delta_y + delta_y**2)\n\n            abs_err = np.abs(sigma_full - sigma_reduced)\n            \n            # Handle the case where bound is zero (implies error is zero)\n            if bound > 1e-15:\n                ratio = abs_err / bound\n            else:\n                # If bound is zero, error must also be zero. The bound is perfectly sharp.\n                ratio = 1.0 if abs_err  1e-15 else np.inf \n            ratios_for_current_mu.append(ratio)\n        \n        # g. Find max ratio for this mu\n        max_ratio = np.max(ratios_for_current_mu)\n        final_ratios.append(max_ratio)\n        \n    print(f\"[{','.join(map(str, final_ratios))}]\")\n\nsolve()\n```"
        }
    ]
}