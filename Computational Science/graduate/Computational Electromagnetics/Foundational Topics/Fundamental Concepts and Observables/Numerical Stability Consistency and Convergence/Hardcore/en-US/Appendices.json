{
    "hands_on_practices": [
        {
            "introduction": "The Lax-Richtmyer equivalence theorem is a cornerstone of numerical analysis, stating that for a well-posed linear problem, a numerical scheme is convergent if and only if it is both stable and consistent. This exercise provides a sharp and insightful demonstration of the theorem by constructing a scheme that is deliberately made inconsistent while remaining stable . By analyzing why this stable scheme fails to converge to the correct solution, you will gain a profound understanding of why consistency is an indispensable requirement and not merely a desirable property.",
            "id": "3394996",
            "problem": "Consider the periodic linear advection initial value problem $u_{t} + a\\,u_{x} = 0$ for $x \\in [0,2\\pi]$ and $t \\ge 0$, with periodic boundary conditions and zero initial data $u(x,0) = 0$. This problem is well-posed in the sense that for any admissible initial data in a suitable normed space, there exists a unique solution that depends continuously on the initial data. In the context of spectral methods and Discontinuous Galerkin (DG) methods, a linear scheme is called stable if its homogeneous part generates a bounded evolution in the chosen norm and is called consistent if the discrete operator applied to sufficiently smooth exact solutions yields a residual that tends to zero under refinement.\n\nConstruct the following Fourier spectral semi-discrete scheme with $N$ modes (labeled by integers $k$ with $|k| \\le K$ where $N = 2K+1$): expand $u_{N}(x,t) = \\sum_{|k| \\le K} \\hat{u}_{k}(t)\\,\\exp(i k x)$ and evolve the modal coefficients according to\n$$\n\\frac{d}{dt}\\,\\hat{u}_{k}(t) \\;=\\; -\\,i\\,a\\,k\\,\\hat{u}_{k}(t) \\;+\\; \\gamma\\,\\delta_{k,0},\n$$\nwith parameter $a = 1$, forcing amplitude $\\gamma = 1$, and Kronecker delta $\\delta_{k,0}$. Assume exact time integration of this semi-discrete system. This scheme is linear and its homogeneous part corresponds to the standard Fourier spectral discretization of the skew-adjoint advection operator, which is norm-preserving in the $L^{2}$ norm. However, the added zero-mode forcing makes the scheme inconsistent with the original homogeneous problem.\n\nUsing first-principles reasoning starting from the definitions above and the exact evolution of the semi-discrete system, show that the scheme is stable (in the sense that the homogeneous evolution preserves the $L^{2}$ norm) yet inconsistent, and explain why it does not converge to the exact solution $u \\equiv 0$. Then, compute the limit of the $L^{2}$ error at time $t = 1$ as the number of modes $N \\to \\infty$:\n$$\n\\lim_{N \\to \\infty} \\,\\left\\| u_{N}(\\cdot,1) - 0 \\right\\|_{L^{2}(0,2\\pi)}.\n$$\nProvide your final answer as a single closed-form analytic expression. No rounding is required. Angles, if any, must be expressed in radians.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\nThe givens are:\n1.  The partial differential equation (PDE) is the linear advection equation: $u_{t} + a\\,u_{x} = 0$.\n2.  The spatial domain is $x \\in [0,2\\pi]$ with periodic boundary conditions.\n3.  The temporal domain is $t \\ge 0$.\n4.  The initial condition is $u(x,0) = 0$.\n5.  A Fourier spectral semi-discrete scheme is proposed for a numerical solution $u_{N}(x,t) = \\sum_{|k| \\le K} \\hat{u}_{k}(t)\\,\\exp(i k x)$, where $N = 2K+1$.\n6.  The evolution of the modal coefficients $\\hat{u}_{k}(t)$ is given by the ordinary differential equation (ODE) system: $\\frac{d}{dt}\\,\\hat{u}_{k}(t) \\;=\\; -\\,i\\,a\\,k\\,\\hat{u}_{k}(t) \\;+\\; \\gamma\\,\\delta_{k,0}$.\n7.  The initial conditions for the scheme are consistent with $u(x,0)=0$, which implies $\\hat{u}_{k}(0)=0$ for all $k$.\n8.  The parameters are specified as $a = 1$ and $\\gamma = 1$.\n9.  The exact solution to the initial value problem is $u(x,t) = 0$ for all $x$ and $t$.\n10. The task is to show the scheme is stable but inconsistent, explain the resulting non-convergence, and compute the limit of the $L^{2}$ error at $t=1$ as $N \\to \\infty$.\n\nThe problem is mathematically well-defined, internally consistent, and directly pertains to the analysis of numerical methods for PDEs, specifically the interplay of stability, consistency, and convergence as described by the Lax equivalence theorem. The constructed scheme is a textbook example used to illustrate the importance of consistency. The problem is therefore valid.\n\nWe proceed with the solution, which consists of three parts: analysis of stability and consistency, explanation of non-convergence, and computation of the error.\n\nFirst, we analyze the stability of the scheme. According to the problem statement, stability is determined by the behavior of the homogeneous part of the scheme. The given semi-discrete scheme is:\n$$\n\\frac{d}{dt}\\,\\hat{u}_{k}(t) \\;=\\; -\\,i\\,a\\,k\\,\\hat{u}_{k}(t) \\;+\\; \\gamma\\,\\delta_{k,0}\n$$\nThe homogeneous part is obtained by removing the forcing term $\\gamma\\,\\delta_{k,0}$:\n$$\n\\frac{d}{dt}\\,\\hat{u}_{k}^{h}(t) \\;=\\; -\\,i\\,a\\,k\\,\\hat{u}_{k}^{h}(t)\n$$\nwhere $\\hat{u}_{k}^{h}(t)$ denotes the coefficients of the homogeneous evolution. The solution to this linear ODE is $\\hat{u}_{k}^{h}(t) = \\hat{u}_{k}^{h}(0) \\exp(-iakt)$. The $L^{2}$ norm of the numerical solution $u_{N}(x,t)$ is related to its Fourier coefficients by Parseval's theorem:\n$$\n\\left\\| u_{N}(\\cdot, t) \\right\\|_{L^{2}(0,2\\pi)}^{2} = \\int_{0}^{2\\pi} |u_{N}(x,t)|^{2} dx = 2\\pi \\sum_{|k| \\le K} |\\hat{u}_{k}(t)|^{2}\n$$\nFor the homogeneous evolution, we examine the squared magnitude of the coefficients:\n$$\n|\\hat{u}_{k}^{h}(t)|^{2} = \\left| \\hat{u}_{k}^{h}(0) \\exp(-iakt) \\right|^{2} = |\\hat{u}_{k}^{h}(0)|^{2} |\\exp(-iakt)|^{2} = |\\hat{u}_{k}^{h}(0)|^{2}\n$$\nsince $|\\exp(i\\theta)|=1$ for any real $\\theta$. Summing over all modes, we find:\n$$\n\\sum_{|k| \\le K} |\\hat{u}_{k}^{h}(t)|^{2} = \\sum_{|k| \\le K} |\\hat{u}_{k}^{h}(0)|^{2}\n$$\nThis implies that $\\left\\| u_{N}^{h}(\\cdot, t) \\right\\|_{L^{2}}^{2} = \\left\\| u_{N}^{h}(\\cdot, 0) \\right\\|_{L^{2}}^{2}$. The $L^{2}$ norm of the solution to the homogeneous scheme is conserved for all time. An evolution that preserves the norm is bounded (with an operator norm of $1$). Therefore, by the definition provided, the scheme is stable.\n\nSecond, we analyze the consistency. A scheme is consistent with a PDE if the truncation error—the residual obtained by substituting the exact solution of the PDE into the numerical scheme—tends to zero as the discretization is refined ($N \\to \\infty$). The exact solution to $u_{t} + a u_{x} = 0$ with $u(x,0)=0$ is $u(x,t) = 0$ for all $t \\ge 0$. The Fourier coefficients of the exact solution are $\\hat{u}_{k,exact}(t) = 0$ for all $k$ and $t$.\nWe substitute these exact solution coefficients into the full numerical scheme to find the residual for each mode, $\\tau_k(t)$:\n$$\n\\tau_k(t) = \\frac{d}{dt}\\hat{u}_{k,exact}(t) - \\left( -iak\\,\\hat{u}_{k,exact}(t) + \\gamma\\,\\delta_{k,0} \\right)\n$$\nPlugging in $\\hat{u}_{k,exact}(t) = 0$ and its time-derivative $\\frac{d}{dt}(0)=0$:\n$$\n\\tau_k(t) = 0 - \\left( -iak \\cdot 0 + \\gamma\\,\\delta_{k,0} \\right) = -\\gamma\\,\\delta_{k,0}\n$$\nWith $\\gamma=1$, the residual is $\\tau_k(t) = -\\delta_{k,0}$. For the mode $k=0$, the residual is $\\tau_0 = -1$, while for all other modes $k \\neq 0$, the residual is $\\tau_k = 0$. The residual for the zeroth mode is a constant nonzero value. It does not depend on the number of modes $N$ and thus does not tend to zero as $N \\to \\infty$. Therefore, the scheme is inconsistent with the homogeneous PDE $u_t + a u_x = 0$.\n\nThe failure to converge is a direct consequence of this inconsistency, as explained by the Lax-Richtmyer equivalence theorem. The theorem states that for a well-posed linear initial value problem, a consistent linear finite-difference scheme is convergent if and only if it is stable. Here, the scheme is stable but not consistent. The conditions of the theorem for convergence are not met. The scheme is actually a consistent discretization of a different PDE: $u_t + a u_x = F(x)$, where $F(x)$ is a function whose Fourier coefficients are $\\gamma\\,\\delta_{k,0}$. This corresponds to a spatially constant forcing term $F(x) = \\gamma=1$. The numerical scheme is solving the wrong problem, so its solution does not converge to the solution of the intended problem. The source term $\\gamma\\,\\delta_{k,0}$ continuously injects a non-physical signal into the zeroth mode, causing the numerical solution to diverge from the true solution $u=0$.\n\nFinally, we compute the limit of the $L^{2}$ error at $t=1$. We must find the exact solution to the semi-discrete system with the specified parameters $a=1$, $\\gamma=1$ and initial conditions $\\hat{u}_k(0)=0$. The system of ODEs is:\n$$\n\\frac{d}{dt}\\hat{u}_{k}(t) = -ik\\hat{u}_{k}(t) + \\delta_{k,0}\n$$\nWe solve this for two cases.\nCase 1: $k \\neq 0$. The equation is $\\frac{d}{dt}\\hat{u}_{k}(t) = -ik\\hat{u}_{k}(t)$. With the initial condition $\\hat{u}_k(0)=0$, the unique solution is $\\hat{u}_{k}(t)=0$ for all $t$.\nCase 2: $k=0$. The equation is $\\frac{d}{dt}\\hat{u}_{0}(t) = -i(0)\\hat{u}_{0}(t) + 1$, which simplifies to $\\frac{d}{dt}\\hat{u}_{0}(t) = 1$. Integrating from $0$ to $t$ gives $\\hat{u}_{0}(t) - \\hat{u}_{0}(0) = \\int_0^t 1 ds = t$. Since $\\hat{u}_{0}(0)=0$, we have $\\hat{u}_{0}(t)=t$.\n\nThe coefficients of the numerical solution are thus $\\hat{u}_{k}(t) = t\\,\\delta_{k,0}$. The numerical solution in physical space is:\n$$\nu_{N}(x,t) = \\sum_{|k| \\le K} \\hat{u}_{k}(t)\\,\\exp(ikx) = \\hat{u}_{0}(t)\\exp(i \\cdot 0 \\cdot x) = t\n$$\nThe solution $u_{N}(x,t)=t$ is a spatially constant function that grows linearly in time. This solution is valid for any $N \\ge 1$ (i.e., $K \\ge 0$).\n\nThe error is $e_{N}(x,t) = u_{N}(x,t) - u(x,t) = t - 0 = t$.\nWe are asked to compute the $L^{2}$ norm of the error at time $t=1$. The error at this time is $e_N(x,1) = 1$.\nThe squared $L^{2}$ norm of the error is:\n$$\n\\left\\| e_{N}(\\cdot,1) \\right\\|_{L^{2}(0,2\\pi)}^{2} = \\int_{0}^{2\\pi} |e_{N}(x,1)|^{2} dx = \\int_{0}^{2\\pi} |1|^{2} dx = \\int_{0}^{2\\pi} 1 dx = 2\\pi\n$$\nThus, the $L^{2}$ norm of the error at $t=1$ is $\\left\\| e_{N}(\\cdot,1) \\right\\|_{L^{2}(0,2\\pi)} = \\sqrt{2\\pi}$.\n\nThis result is independent of $N$. Therefore, the limit as $N \\to \\infty$ is the same value:\n$$\n\\lim_{N \\to \\infty} \\,\\left\\| u_{N}(\\cdot,1) - 0 \\right\\|_{L^{2}(0,2\\pi)} = \\sqrt{2\\pi}\n$$\nThis nonzero limit confirms that the scheme does not converge to the exact solution.",
            "answer": "$$\n\\boxed{\\sqrt{2\\pi}}\n$$"
        },
        {
            "introduction": "Theoretical stability analyses often yield conditions that depend on mesh parameters, but applying these conditions in practice can be fraught with subtlety. This exercise moves from theory to a practical coding scenario, exploring how the stability of an explicit scheme for the heat equation behaves on a non-uniform grid . You will investigate a common pitfall where an intuitive but incorrect choice for the time step, based on the average mesh size rather than the minimum, leads to catastrophic instability, thereby demonstrating why stability constraints are dictated by the most challenging local conditions in the computational domain.",
            "id": "3217060",
            "problem": "Consider the one-dimensional heat equation $u_t = u_{xx}$ on the spatial interval $x \\in (0,1)$ with homogeneous Dirichlet boundary conditions $u(0,t) = 0$ and $u(1,t) = 0$, and the smooth initial condition $u(x,0) = \\sin(\\pi x)$. The goal is to examine the interaction of consistency, stability, and convergence for an explicit time-stepping scheme on nonuniform grids, and to test the Lax equivalence theorem in practice.\n\nStarting from core definitions:\n- Consistency: the local truncation error tends to zero as the spatial steps $h_i$ and the time step $\\Delta t$ tend to zero.\n- Stability: the discrete solution operator is bounded with respect to perturbations in input data or roundoff, typically characterized by a bound on the amplification factor.\n- Convergence: the numerical solution approaches the exact solution of the original continuous model in a chosen norm (here the square-integrable norm).\n\nConstruct the explicit forward Euler method of lines scheme using a nonuniform second-derivative finite difference at interior nodes $x_i$ as\n$$u^{n+1}_i = u^n_i + \\Delta t \\, D^{(2)}u^n_i,$$\nwhere $D^{(2)}$ is the three-point second derivative approximation derived by Taylor expansions on a nonuniform mesh with spacings $h_{i-1} = x_i - x_{i-1}$ and $h_{i} = x_{i+1} - x_i$,\n$$D^{(2)}u_i \\approx 2\\left(\\frac{u_{i-1}}{h_{i-1}(h_{i-1}+h_i)} - \\frac{u_i}{h_{i-1}h_i} + \\frac{u_{i+1}}{h_i(h_{i-1}+h_i)}\\right).$$\nImpose the boundary conditions by setting $u^n_0 = 0$ and $u^n_{N+1} = 0$.\n\nDefine the discrete spatial operator $L$ as the matrix representation of $D^{(2)}$ acting on the vector of interior nodal values $\\mathbf{u}^n = (u^n_1,\\dots,u^n_N)^\\top$, so that the method can be written as $\\mathbf{u}^{n+1} = \\left(I + \\Delta t\\, L\\right)\\mathbf{u}^n$. For the exact solution with the given initial condition, one has $u(x,t) = e^{-\\pi^2 t}\\sin(\\pi x)$.\n\nYou must:\n1. Implement the nonuniform grid second-derivative operator $L$ on a strictly increasing grid $\\{x_i\\}_{i=0}^{N+1}$ with $x_0 = 0$ and $x_{N+1} = 1$.\n2. For each test case, compute:\n   - The maximum one-step amplification factor $a_{\\max} = \\max_{\\lambda \\in \\mathrm{spec}(L)} |1 + \\Delta t\\, \\lambda|$, where $\\mathrm{spec}(L)$ denotes the spectrum (set of eigenvalues) of $L$.\n   - The discrete square-integrable norm (the $L^2$ norm) of the one-step error compared to $u(x,\\Delta t)$, using quadrature weights $w_i = \\tfrac{h_{i-1} + h_i}{2}$ for interior nodes and defining the norm $\\|\\mathbf{v}\\|_{L^2} = \\left(\\sum_{i=1}^N w_i v_i^2\\right)^{1/2}$.\n   - The refinement error ratio $r = E_{2N} / E_{N}$, where $E_{N}$ is the one-step discrete $L^2$ error on a grid with $N$ interior points and $E_{2N}$ is the analogous error on the grid with $2N$ interior points, both using the same step-selection policy as described below.\n   - The stability boolean defined by $a_{\\max} \\le 1$.\n3. Explain, via the computed values, how the scheme can be pointwise consistent (local truncation error goes to zero as $N \\to \\infty$ and $\\Delta t \\to 0$) yet unstable and therefore nonconvergent in the $L^2$ norm if the time step is not scaled with the smallest mesh size. Specifically, show that when the grid is strongly nonuniform, scaling $\\Delta t$ with the average step size squared can yield $a_{\\max} > 1$, violating stability and preventing convergence by the Lax equivalence theorem.\n\nUse the following test suite. For each case, build the grid and choose the time step according to the specified policy:\n- Case A (happy path, uniform and stable): $N = 64$, uniform grid $x_i = i/(N+1)$, choose $\\Delta t = 0.45\\, h_{\\min}^2$ where $h_{\\min} = \\min_i (x_{i+1} - x_i)$.\n- Case B (edge case, nonuniform and unstable by average scaling): $N = 64$, graded grid $x_i = \\left(\\frac{i}{N+1}\\right)^p$ with $p = 2$, choose $\\Delta t = 0.45\\, \\bar{h}^2$ where $\\bar{h} = \\frac{1}{N+1}\\sum_{i=0}^N (x_{i+1} - x_i)$.\n- Case C (nonuniform but stable by minimum scaling): $N = 64$, graded grid $x_i = \\left(\\frac{i}{N+1}\\right)^p$ with $p = 2$, choose $\\Delta t = 0.45\\, h_{\\min}^2$.\n\nFor each case, compute $a_{\\max}$, the stability boolean, and the refinement error ratio $r$ by comparing $E_N$ to $E_{2N}$ under the same policy. All quantities are dimensionless.\n\nYour program should produce a single line of output containing the results, formatted as a comma-separated list enclosed in square brackets with no spaces, where each case contributes a sublist of the form $[$stable\\_boolean$,a_{\\max},r]$. For example, an output with three cases should look like $[[\\mathrm{True},0.9,0.5],[\\mathrm{False},3.1,1.8],[\\mathrm{True},0.8,0.6]]$ with no spaces anywhere in the line.",
            "solution": "The problem as stated is a well-posed and scientifically sound exercise in numerical analysis, designed to investigate the interdependence of consistency, stability, and convergence for a numerical scheme solving the one-dimensional heat equation. All provided equations, conditions, and definitions are standard and correct. The problem is valid.\n\nThe core of this problem lies in the Lax Equivalence Theorem, which states that for a consistent linear finite difference scheme, stability is the necessary and sufficient condition for convergence. We will demonstrate this principle by applying an explicit forward-in-time, centered-in-space (FTCS) scheme to the heat equation $u_t = u_{xx}$ on nonuniform grids.\n\nThe numerical method is defined by the update rule $\\mathbf{u}^{n+1} = \\left(I + \\Delta t\\, L\\right)\\mathbf{u}^n$, where $\\mathbf{u}^n$ is the vector of numerical solutions at the interior grid points at time step $n$, $I$ is the identity matrix, $\\Delta t$ is the time step, and $L$ is the matrix representation of the second-derivative operator $D^{(2)}$ given by\n$$D^{(2)}u_i = 2\\left(\\frac{u_{i-1}}{h_{i-1}(h_{i-1}+h_i)} - \\frac{u_i}{h_{i-1}h_i} + \\frac{u_{i+1}}{h_i(h_{i-1}+h_i)}\\right)$$\nfor a grid with spacings $h_{i-1} = x_i - x_{i-1}$ and $h_i = x_{i+1} - x_i$. This operator is consistent with the continuous second derivative $u_{xx}$; its local truncation error tends to zero as mesh spacings tend to zero.\n\nThe stability of this explicit scheme is governed by the spectral radius of the amplification matrix $G = I + \\Delta t\\, L$. Stability requires that the one-step amplification factor, $a_{\\max} = \\rho(G) = \\max_{\\lambda \\in \\mathrm{spec}(L)} |1 + \\Delta t\\, \\lambda|$, must not exceed $1$. The eigenvalues $\\lambda$ of the discrete Laplacian operator $L$ are real and non-positive. Let $\\lambda_{\\min}$ be the most negative eigenvalue of $L$. The stability condition simplifies to $1 + \\Delta t\\, \\lambda_{\\min} \\ge -1$, which yields the constraint:\n$$\\Delta t \\le \\frac{-2}{\\lambda_{\\min}}$$\nFor a nonuniform grid, the magnitude of $\\lambda_{\\min}$ is dictated by the smallest grid spacing, $h_{\\min}$. It can be shown that $|\\lambda_{\\min}|$ scales as $1/h_{\\min}^2$. This leads to the well-known stability requirement for explicit schemes:\n$$\\Delta t \\le C \\cdot h_{\\min}^2$$\nfor some constant $C$ (for the uniform grid case, $C=1/2$). A crucial insight is that stability depends on the *minimum* spacing, $h_{\\min}$, not the average spacing, $\\bar{h}$. The problem's test cases are designed to illustrate this point.\n\nFor each case, we will compute the maximum amplification factor $a_{\\max}$, determine stability via the condition $a_{\\max} \\le 1$, and assess convergence behavior through the one-step error refinement ratio $r = E_{2N} / E_N$. A ratio $r < 1$ indicates convergence, while $r \\ge 1$ suggests divergence.\n\n**Case A: Uniform Grid, Stable Time Step**\nThe grid is uniform, meaning $h_i = h = \\bar{h} = h_{\\min}$ for all $i$. The time step is chosen as $\\Delta t = 0.45\\, h_{\\min}^2 = 0.45\\, h^2$. This satisfies the stability condition $\\Delta t \\le 0.5\\, h^2$. Consequently, we expect the scheme to be stable, with $a_{\\max} \\le 1$. Since the scheme is consistent and stable, the Lax Equivalence Theorem guarantees convergence. This should be reflected by a refinement ratio $r < 1$.\n\n**Case B: Nonuniform Grid, Unstable Time Step**\nA graded mesh $x_i = (i/(N+1))^2$ is employed, which concentrates points near $x=0$, resulting in a very small $h_{\\min}$ compared to the average spacing $\\bar{h}$. The time step is set to $\\Delta t = 0.45\\, \\bar{h}^2$. Since $\\bar{h} \\gg h_{\\min}$, this choice of $\\Delta t$ will be far larger than what is permitted by the stability condition based on $h_{\\min}^2$.\n$$\\Delta t = 0.45\\, \\bar{h}^2 = 0.45 \\left(\\frac{\\bar{h}}{h_{\\min}}\\right)^2 h_{\\min}^2 \\gg h_{\\min}^2$$\nWe therefore predict that the scheme will be unstable, with $a_{\\max} > 1$. Despite being a consistent scheme, this instability will lead to non-convergence, which should be demonstrated by an error ratio $r \\ge 1$.\n\n**Case C: Nonuniform Grid, Stable Time Step**\nThis case uses the same graded mesh as Case B but corrects the flaw in the time-stepping policy. The time step is chosen as $\\Delta t = 0.45\\, h_{\\min}^2$. This choice respects the constraint imposed by the smallest mesh cells and is designed to satisfy the stability condition. We expect to find $a_{\\max} \\le 1$. With both consistency and stability re-established, the scheme should again be convergent, yielding a refinement ratio $r < 1$.\n\nThe implementation will construct the matrix $L$, compute its eigenvalues to find $a_{\\max}$, and calculate the one-step $L^2$ error against the exact solution $u(x,t) = e^{-\\pi^2 t}\\sin(\\pi x)$ to determine the refinement ratio $r$. The results will provide a practical demonstration of the Lax Equivalence Theorem and the critical importance of selecting a time step based on the most restrictive local grid spacing.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_case_metrics(N, p, dt_policy):\n    \"\"\"\n    Computes stability and error metrics for a given grid and time step policy.\n\n    Args:\n        N (int): Number of interior grid points.\n        p (float): Power for graded grid generation. p=1 gives a uniform grid.\n        dt_policy (str): Time step policy, either 'min' or 'avg'.\n\n    Returns:\n        tuple: A tuple containing:\n            - l2_error (float): The discrete L2 norm of the one-step error.\n            - a_max (float): The maximum one-step amplification factor.\n            - is_stable (bool): True if the scheme is stable, False otherwise.\n    \"\"\"\n    # 1. Grid Generation\n    i_vals = np.arange(N + 2, dtype=float)\n    x = (i_vals / (N + 1))**p\n    h = np.diff(x)  # h has length N+1, h_i = x_{i+1} - x_i\n\n    # 2. Time Step Calculation\n    h_min = np.min(h)\n    # The problem defines h_bar as the sum over N+1 spacings divided by N+1\n    h_bar = np.mean(h)\n    \n    if dt_policy == 'min':\n        dt = 0.45 * h_min**2\n    elif dt_policy == 'avg':\n        dt = 0.45 * h_bar**2\n    else:\n        raise ValueError(\"Invalid dt_policy specified.\")\n\n    # 3. Construct the discrete operator matrix L\n    L = np.zeros((N, N))\n    # Loop over interior nodes i = 1, ..., N\n    # Matrix row j = i - 1 corresponds to node i\n    for j in range(N):\n        h_im1 = h[j]      # This is h_{i-1}\n        h_i   = h[j + 1]  # This is h_i\n        \n        # Diagonal term (coefficient of u_i)\n        L[j, j] = 2.0 * (-1.0 / (h_im1 * h_i))\n        \n        # Sub-diagonal term (coefficient of u_{i-1})\n        if j > 0:\n            L[j, j - 1] = 2.0 / (h_im1 * (h_im1 + h_i))\n        \n        # Super-diagonal term (coefficient of u_{i+1})\n        if j  N - 1:\n            L[j, j + 1] = 2.0 / (h_i * (h_im1 + h_i))\n\n    # 4. Compute stability metrics\n    eigenvalues = np.linalg.eigvals(L)\n    a_max = np.max(np.abs(1.0 + dt * eigenvalues))\n    is_stable = a_max = 1.0\n\n    # 5. Compute one-step L2 error\n    x_interior = x[1:N + 1]\n    \n    # Initial condition at interior nodes\n    u0 = np.sin(np.pi * x_interior)\n    \n    # Numerical solution at t = dt\n    u1_num = u0 + dt * (L @ u0)\n    \n    # Exact solution at t = dt\n    u1_exact = np.exp(-np.pi**2 * dt) * np.sin(np.pi * x_interior)\n    \n    # Error vector\n    error_vec = u1_num - u1_exact\n    \n    # Quadrature weights for L2 norm\n    # w_i = (h_{i-1} + h_i)/2. For interior nodes i=1..N, these are h_0..h_{N-1} + h_1..h_N\n    weights = 0.5 * (h[0:N] + h[1:N + 1])\n    \n    l2_error = np.sqrt(np.sum(weights * error_vec**2))\n    \n    return l2_error, a_max, is_stable\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # (N_base, p, dt_policy) for each case\n    # p=1 represents a uniform grid as (i/(N+1))^1.\n    test_cases_params = [\n        (64, 1.0, 'min'),  # Case A: Uniform grid, stable by h_min\n        (64, 2.0, 'avg'),  # Case B: Graded grid, unstable by h_bar\n        (64, 2.0, 'min'),  # Case C: Graded grid, stable by h_min\n    ]\n\n    final_results = []\n    for N_base, p, policy in test_cases_params:\n        # Calculate metrics for the base grid N\n        E_N, a_max, is_stable = compute_case_metrics(N_base, p, policy)\n        \n        # Calculate error for the refined grid 2N to find the ratio\n        E_2N, _, _ = compute_case_metrics(2 * N_base, p, policy)\n        \n        # Refinement error ratio\n        r = E_2N / E_N\n        \n        final_results.append([is_stable, a_max, r])\n    \n    # Format the output string exactly as specified: [[val,val,val],[val,val,val],...]\n    case_strings = []\n    for s_bool, a_val, r_val in final_results:\n        # Python's bool __str__ is 'True' or 'False'\n        case_strings.append(f\"[{str(s_bool)},{a_val},{r_val}]\")\n    \n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Modern numerical methods increasingly focus on creating \"structure-preserving\" discretizations that inherit fundamental properties of the continuous equations. This exercise introduces a powerful graph-based approach, equivalent to discrete exterior calculus, to build a solver for Maxwell's equations from first principles . You will construct discrete operators and verify their consistency through the topological nilpotency property, then implement a leapfrog scheme whose stability is directly linked to the conservation of discrete energy, providing a clear window into how mimicking physical laws can lead to robust and reliable numerical schemes.",
            "id": "3335818",
            "problem": "Given the source-free Maxwell equations in integral form and the discrete topological identities on a two-dimensional rectangular primal grid, construct a graph-based semi-discrete formulation using incidence matrices. Consider a uniform rectangular mesh of $N_x \\times N_y$ primal faces with $(N_x+1)\\times(N_y+1)$ primal nodes, $N_x(N_y+1)$ horizontal primal edges oriented in the $+x$ direction, and $(N_x+1)N_y$ vertical primal edges oriented in the $+y$ direction. Define the node-to-edge incidence matrix $\\mathbf{G}$ by assigning $-1$ at the tail node and $+1$ at the head node for each oriented edge, and define the edge-to-face incidence (discrete curl) matrix $\\mathbf{C}$ by assembling each face’s counterclockwise boundary with signs $+1$ when an edge orientation aligns with the face boundary orientation and $-1$ otherwise.\n\nUsing this setup:\n- The discrete gradient is represented by $\\mathbf{G}$ and the discrete curl by $\\mathbf{C}$.\n- The discrete nilpotency condition requires $\\mathbf{C}\\mathbf{G}=\\mathbf{0}$, corresponding to the boundary-of-a-boundary identity.\n- In the Transverse Magnetic in $z$ (TM$_z$) polarization, place the electric field components $E_x$ and $E_y$ on primal edges and the magnetic flux density $B_z$ on primal faces. For uniform permittivity $\\varepsilon$ and permeability $\\mu$, define the semi-discrete, lossless, source-free Maxwell system in the form\n$$\n\\frac{d}{dt}\\mathbf{B} = - \\mathbf{C}\\,\\mathbf{E}, \\qquad\n\\frac{d}{dt}\\mathbf{E} = \\frac{1}{\\varepsilon\\mu}\\mathbf{C}^\\top \\mathbf{B},\n$$\nwith energy functional\n$$\n\\mathcal{H}(t) = \\frac{1}{2}\\,\\varepsilon\\,\\mathbf{E}(t)^\\top \\mathbf{E}(t) + \\frac{1}{2}\\,\\frac{1}{\\mu}\\,\\mathbf{B}(t)^\\top \\mathbf{B}(t).\n$$\n\nYour program must:\n1. Construct $\\mathbf{G}$ and $\\mathbf{C}$ for specified $(N_x,N_y)$.\n2. Verify discrete nilpotency by computing the Frobenius norm of $\\mathbf{C}\\mathbf{G}$ and reporting a boolean indicating whether $\\lVert \\mathbf{C}\\mathbf{G}\\rVert_F \\leq \\tau$ with tolerance $\\tau=10^{-12}$.\n3. Implement an explicit leapfrog time discretization for the above semi-discrete system, with magnetic flux density $\\mathbf{B}$ stored at half time steps $t = (n+\\tfrac{1}{2})\\Delta t$ and electric field $\\mathbf{E}$ at integer time steps $t=n\\Delta t$:\n   - Initialize $\\mathbf{E}^0$ with deterministic pseudo-random values (seeded) and $\\mathbf{B}^{-1/2}=\\mathbf{0}$.\n   - Update $\\mathbf{B}^{n+1/2} = \\mathbf{B}^{n-1/2} - \\Delta t\\,\\mathbf{C}\\,\\mathbf{E}^n$ and then $\\mathbf{E}^{n+1} = \\mathbf{E}^n + \\Delta t\\,\\frac{1}{\\varepsilon\\mu}\\,\\mathbf{C}^\\top \\mathbf{B}^{n+1/2}$.\n   - At each integer time $n$, compute the discrete energy\n     $$\n     \\mathcal{H}^n = \\frac{1}{2}\\,\\varepsilon\\,\\left(\\mathbf{E}^n\\right)^\\top \\mathbf{E}^n + \\frac{1}{2}\\,\\frac{1}{\\mu}\\,\\left(\\mathbf{B}^{n+1/2}\\right)^\\top \\mathbf{B}^{n+1/2}.\n     $$\n4. Determine the largest discrete angular frequency $\\omega_{\\max}$ for the semi-discrete system via the spectral norm of $\\mathbf{C}$, using\n   $$\n   \\omega_{\\max} = \\sqrt{\\frac{1}{\\varepsilon\\mu}}\\,\\sigma_{\\max}(\\mathbf{C}),\n   $$\n   where $\\sigma_{\\max}(\\mathbf{C})$ is the largest singular value of $\\mathbf{C}$.\n5. For three different time steps $\\Delta t$ defined as\n   $$\n   \\Delta t_{\\text{small}} = \\frac{1.9}{\\omega_{\\max}}, \\quad \\Delta t_{\\text{critical}} = \\frac{2.0}{\\omega_{\\max}}, \\quad \\Delta t_{\\text{large}} = \\frac{2.1}{\\omega_{\\max}},\n   $$\n   run the leapfrog scheme for $N_{\\text{steps}}$ iterations and compute the energy ratio $r = \\max_n \\mathcal{H}^n / \\mathcal{H}^0$. Report booleans indicating bounded energy growth according to the following criteria:\n   - For $\\Delta t_{\\text{small}}$: bounded if $r \\leq 1.05$.\n   - For $\\Delta t_{\\text{critical}}$: bounded if $r \\leq 1.20$.\n   - For $\\Delta t_{\\text{large}}$: bounded if $r \\leq 1.50$.\n\nUse $\\varepsilon=1$ and $\\mu=1$, and treat all quantities as dimensionless for the purpose of this exercise.\n\nTest Suite:\n- Nilpotency test on $(N_x,N_y)=(2,2)$ with tolerance $\\tau=10^{-12}$.\n- Nilpotency test on $(N_x,N_y)=(3,4)$ with tolerance $\\tau=10^{-12}$.\n- Energy boundedness tests on $(N_x,N_y)=(10,8)$ with $\\varepsilon=1$, $\\mu=1$, seeded initialization, and $N_{\\text{steps}}=1000$ for each of the three time steps $\\Delta t_{\\text{small}}, \\Delta t_{\\text{critical}}, \\Delta t_{\\text{large}}$ as defined above.\n\nFinal Output Format:\nYour program should produce a single line of output containing five booleans in a comma-separated list enclosed in square brackets, ordered as\n$$\n[\\text{nilpotency}_{2\\times 2},\\ \\text{nilpotency}_{3\\times 4},\\ \\text{bounded}_{\\Delta t_{\\text{small}}},\\ \\text{bounded}_{\\Delta t_{\\text{critical}}},\\ \\text{bounded}_{\\Delta t_{\\text{large}}}],\n$$\nfor example, $[\\text{True},\\text{True},\\text{True},\\text{True},\\text{False}]$.",
            "solution": "The problem is valid. It presents a well-posed and scientifically grounded task in computational electromagnetics, specifically concerning the construction and analysis of a numerical scheme based on discrete exterior calculus, also known as the Finite Integration Technique (FIT). The problem is self-contained, with all necessary definitions, equations, and parameters provided for a unique and verifiable solution.\n\nThe core of the problem lies in translating the source-free Maxwell's equations from their continuous, differential form into a discrete, algebraic form suitable for computation. This is achieved by discretizing the spatial domain and representing physical fields and differential operators in a way that preserves fundamental topological and physical laws.\n\nFirst, we establish a two-dimensional rectangular grid. This grid has a hierarchical structure of geometric elements: nodes ($0$-cells), edges ($1$-cells), and faces ($2$-cells). The number of these elements for a grid of $N_x \\times N_y$ faces is:\n-   Number of nodes: $N_n = (N_x+1)(N_y+1)$\n-   Number of horizontal edges: $N_{ex} = N_x(N_y+1)$\n-   Number of vertical edges: $N_{ey} = (N_x+1)N_y$\n-   Total number of edges: $N_e = N_{ex} + N_{ey}$\n-   Number of faces: $N_f = N_x N_y$\n\nThe relationships between these grid elements are captured by incidence matrices. These matrices are discrete analogues of differential operators.\n-   The node-to-edge incidence matrix, $\\mathbf{G}$, represents the discrete gradient operator. It has dimensions $N_e \\times N_n$. Each row corresponds to an edge and has two non-zero entries: a $-1$ at the column of the tail node and a $+1$ at the column of the head node. This represents the difference in a scalar potential (a field on nodes) across an edge.\n-   The edge-to-face incidence matrix, $\\mathbf{C}$, represents the discrete curl operator. It has dimensions $N_f \\times N_e$. Each row corresponds to a face and has four non-zero entries representing the four edges forming its boundary. The signs ($+1$ or $-1$) depend on whether the edge's intrinsic orientation aligns with the counter-clockwise traversal of the face boundary. This represents the circulation of a vector field (a field on edges) around a face.\n\nA fundamental property of these discrete operators, mirroring the continuous vector calculus identity $\\nabla \\times (\\nabla \\phi) = \\mathbf{0}$, is discrete nilpotency: $\\mathbf{C}\\mathbf{G} = \\mathbf{0}$. This means the boundary of a boundary is null. We will verify this property by computing the Frobenius norm of the product $\\mathbf{C}\\mathbf{G}$, which should be zero up to machine precision.\n\nFor the Transverse Magnetic (TM$_z$) polarization, the electric field components ($E_x, E_y$) are naturally associated with primal edges, and the magnetic flux density ($B_z$) with primal faces. The continuous Maxwell's equations, Faraday's law ($\\nabla \\times \\mathbf{E} = -\\frac{\\partial \\mathbf{B}}{\\partial t}$) and Ampère's law ($\\nabla \\times \\mathbf{H} = \\frac{\\partial \\mathbf{D}}{\\partial t}$), become a system of ordinary differential equations in time when discretized in space:\n$$\n\\frac{d}{dt}\\mathbf{B} = - \\mathbf{C}\\,\\mathbf{E}\n$$\n$$\n\\frac{d}{dt}\\mathbf{E} = \\frac{1}{\\varepsilon\\mu}\\mathbf{C}^\\top \\mathbf{B}\n$$\nHere, $\\mathbf{E}$ is a vector of electric field values on all $N_e$ edges, and $\\mathbf{B}$ is a vector of magnetic flux density values on all $N_f$ faces. The matrix $\\mathbf{C}^\\top$ is the transpose of the discrete curl, which acts as the curl operator on the dual grid and correctly connects the magnetic flux on faces back to the electric field on edges.\n\nTo solve this system numerically, we employ an explicit leapfrog time-stepping scheme. This method is second-order accurate and, crucially, energy-conserving for stable time steps. The scheme staggers the electric and magnetic fields in time: $\\mathbf{E}$ is evaluated at integer time steps $n\\Delta t$, while $\\mathbf{B}$ is evaluated at half time steps $(n+\\frac{1}{2})\\Delta t$. The update rules are:\n1.  Update magnetic flux density: $\\mathbf{B}^{n+1/2} = \\mathbf{B}^{n-1/2} - \\Delta t\\,\\mathbf{C}\\,\\mathbf{E}^n$\n2.  Update electric field: $\\mathbf{E}^{n+1} = \\mathbf{E}^n + \\Delta t\\,\\frac{1}{\\varepsilon\\mu}\\,\\mathbf{C}^\\top \\mathbf{B}^{n+1/2}$\n\nThe stability of this scheme is governed by the Courant-Friedrichs-Lewy (CFL) condition. For this system, the stability limit is determined by the maximum angular frequency, $\\omega_{\\max}$, of the discrete system's modes. This frequency is related to the largest singular value, $\\sigma_{\\max}(\\mathbf{C})$, of the discrete curl matrix:\n$$\n\\omega_{\\max} = \\frac{1}{\\sqrt{\\varepsilon\\mu}}\\,\\sigma_{\\max}(\\mathbf{C})\n$$\nThe leapfrog scheme is stable if and only if $\\omega_{\\max} \\Delta t \\le 2$. The problem requires testing three time steps: one stable ($\\Delta t_{\\text{small}}$ with $\\omega_{\\max}\\Delta t = 1.9$), one at the stability limit ($\\Delta t_{\\text{critical}}$ with $\\omega_{\\max}\\Delta t = 2.0$), and one unstable ($\\Delta t_{\\text{large}}$ with $\\omega_{\\max}\\Delta t = 2.1$).\n\nWe will monitor the system's stability by tracking a discrete energy functional, $\\mathcal{H}^n$, defined at each time step $n$:\n$$\n\\mathcal{H}^n = \\frac{1}{2}\\,\\varepsilon\\,\\left(\\mathbf{E}^n\\right)^\\top \\mathbf{E}^n + \\frac{1}{2}\\,\\frac{1}{\\mu}\\,\\left(\\mathbf{B}^{n+1/2}\\right)^\\top \\mathbf{B}^{n+1/2}\n$$\nIn a stable simulation, this energy should remain bounded and close to its initial value, $\\mathcal{H}^0$. In an unstable simulation, the energy will grow exponentially. We will compute the ratio $r = \\max_n \\mathcal{H}^n / \\mathcal{H}^0$ over $N_{\\text{steps}}=1000$ iterations and use the specified thresholds to classify the energy growth as bounded or not.\n\nThe implementation will construct the sparse matrices $\\mathbf{G}$ and $\\mathbf{C}$ based on a consistent indexing of nodes, edges, and faces. The largest singular value of $\\mathbf{C}$ will be found using the `svds` function from SciPy's sparse linear algebra module. Finally, the leapfrog simulation will be run for the three specified time steps, and the results of the nilpotency and energy boundedness tests will be compiled into the required output format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.linalg import svds\n\ndef construct_matrices(Nx, Ny):\n    \"\"\"\n    Constructs the discrete gradient (G) and curl (C) matrices.\n    \n    Args:\n        Nx (int): Number of primal faces in the x-direction.\n        Ny (int): Number of primal faces in the y-direction.\n        \n    Returns:\n        tuple: A tuple containing the sparse matrices (G, C).\n               G: Node-to-edge incidence matrix (discrete gradient).\n               C: Edge-to-face incidence matrix (discrete curl).\n    \"\"\"\n    Nnx = Nx + 1\n    Nny = Ny + 1\n    \n    Nn = Nnx * Nny\n    Nex = Nx * Nny\n    Ney = Nnx * Ny\n    Ne = Nex + Ney\n    Nf = Nx * Ny\n\n    # Use LIL format for efficient construction\n    G = lil_matrix((Ne, Nn), dtype=np.float64)\n    C = lil_matrix((Nf, Ne), dtype=np.float64)\n\n    # Construct G (Node-to-edge incidence)\n    # Horizontal edges\n    for i in range(Nx):\n        for j in range(Nny):\n            edge_idx = i * Nny + j\n            node1_idx = i * Nny + j\n            node2_idx = (i + 1) * Nny + j\n            G[edge_idx, node1_idx] = -1.0\n            G[edge_idx, node2_idx] = 1.0\n\n    # Vertical edges\n    for i in range(Nnx):\n        for j in range(Ny):\n            edge_idx = Nex + i * Ny + j\n            node1_idx = i * Nny + j\n            node2_idx = i * Nny + (j + 1)\n            G[edge_idx, node1_idx] = -1.0\n            G[edge_idx, node2_idx] = 1.0\n\n    # Construct C (Edge-to-face incidence, discrete curl)\n    for i in range(Nx):\n        for j in range(Ny):\n            face_idx = i * Ny + j\n            \n            # Bottom edge (orientation +x, traversal +x -> +1)\n            bottom_edge_idx = i * Nny + j\n            C[face_idx, bottom_edge_idx] = 1.0\n\n            # Right edge (orientation +y, traversal +y -> +1)\n            right_edge_idx = Nex + (i + 1) * Ny + j\n            C[face_idx, right_edge_idx] = 1.0\n\n            # Top edge (orientation +x, traversal -x -> -1)\n            top_edge_idx = i * Nny + (j + 1)\n            C[face_idx, top_edge_idx] = -1.0\n\n            # Left edge (orientation +y, traversal -y -> -1)\n            left_edge_idx = Nex + i * Ny + j\n            C[face_idx, left_edge_idx] = -1.0\n            \n    # Convert to CSR for efficient matrix operations\n    return G.tocsr(), C.tocsr()\n\ndef run_simulation(C_matrix, eps, mu, N_steps, dt, rng_seed):\n    \"\"\"\n    Runs the leapfrog simulation and computes the energy ratio.\n    \"\"\"\n    Ne = C_matrix.shape[1]\n    Nf = C_matrix.shape[0]\n    \n    # Seeded random number generator for reproducible initial conditions\n    rng = np.random.default_rng(rng_seed)\n    \n    # Initialize fields\n    E_n = rng.random(Ne)\n    B_half = np.zeros(Nf)\n    Ct = C_matrix.transpose().tocsr()\n\n    # Energy calculation\n    H0 = 0.5 * eps * np.dot(E_n, E_n) + 0.5 / mu * np.dot(B_half, B_half)\n    if H0 == 0: return 1.0 # Avoid division by zero if initial energy is zero\n    \n    max_H = H0\n    \n    # Leapfrog loop\n    for _ in range(N_steps):\n        # Update B at n+1/2 from E at n\n        B_half = B_half - dt * (C_matrix @ E_n)\n        \n        # Calculate energy H^n using E^n and B^{n+1/2}\n        H_n = 0.5 * eps * np.dot(E_n, E_n) + 0.5 / mu * np.dot(B_half, B_half)\n        if H_n > max_H:\n            max_H = H_n\n\n        # Update E at n+1 from B at n+1/2\n        E_n = E_n + (dt / (eps * mu)) * (Ct @ B_half)\n\n    return max_H / H0\n\ndef solve():\n    test_cases = [\n        {'type': 'nilpotency', 'Nx': 2, 'Ny': 2, 'tol': 1e-12},\n        {'type': 'nilpotency', 'Nx': 3, 'Ny': 4, 'tol': 1e-12},\n        {'type': 'energy', 'Nx': 10, 'Ny': 8, 'eps': 1.0, 'mu': 1.0, 'N_steps': 1000}\n    ]\n\n    results = []\n    \n    # Nilpotency tests\n    for case in filter(lambda c: c['type'] == 'nilpotency', test_cases):\n        G, C = construct_matrices(case['Nx'], case['Ny'])\n        CG = C @ G\n        frob_norm = np.linalg.norm(CG.toarray(), 'fro')\n        results.append(frob_norm = case['tol'])\n\n    # Energy boundedness tests\n    energy_case = next(filter(lambda c: c['type'] == 'energy', test_cases))\n    Nx = energy_case['Nx']\n    Ny = energy_case['Ny']\n    eps = energy_case['eps']\n    mu = energy_case['mu']\n    N_steps = energy_case['N_steps']\n\n    _, C = construct_matrices(Nx, Ny)\n    \n    # Calculate max singular value of C to find w_max\n    # k=1 and which='LM' finds the largest magnitude singular value\n    sigma_max = svds(C, k=1, which='LM', return_singular_vectors=False)[0]\n    w_max = (1.0 / np.sqrt(eps * mu)) * sigma_max\n\n    # Define the three time steps\n    dt_small = 1.9 / w_max\n    dt_critical = 2.0 / w_max\n    dt_large = 2.1 / w_max\n    \n    # Use a fixed seed for reproducibility across the three runs\n    rng_seed = 42\n\n    # Run for dt_small\n    r_small = run_simulation(C, eps, mu, N_steps, dt_small, rng_seed)\n    results.append(r_small = 1.05)\n    \n    # Run for dt_critical\n    r_critical = run_simulation(C, eps, mu, N_steps, dt_critical, rng_seed)\n    results.append(r_critical = 1.20)\n    \n    # Run for dt_large\n    r_large = run_simulation(C, eps, mu, N_steps, dt_large, rng_seed)\n    results.append(r_large = 1.50)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}