{
    "hands_on_practices": [
        {
            "introduction": "在微波仿真和测量中，我们关心的待测器件（DUT）通常被封装在馈电结构或启动器之间。本练习将演示一种名为“去嵌入”的关键技术，它通过将 $S$ 参数转换为适合级联网络的 $T$ 矩阵（传输矩阵），从而精确地分离出待测器件本身的特性。这项实践加强了对网络参数之间关系的理解，并提供了处理原始仿真数据的实用技能。",
            "id": "3346692",
            "problem": "一个全波数值求解器中的二端口测量结构由两侧各一个相同的馈源和一个互易的待测器件（DUT）组成，在单一频率下进行分析。所有端口均以实特征阻抗 $Z_{0} = 50\\,\\Omega$ 为参考。求解器返回整个三块级联结构（左馈源、DUT、右馈源）的散射矩阵 $S$。你的任务是通过构建传输（链）矩阵并代数上移除馈源的贡献，来去嵌馈源以恢复 DUT 的散射矩阵。\n\n基于基本原理进行推导：定义端口 $n$ 处的复功率波变量 $a_{n}$ 和 $b_{n}$，陈述散射矩阵关系 $b = S\\,a$，并根据端口电压和电流定义传输（链）矩阵（$A$–$B$–$C$–$D$ 矩阵）。仅使用这些定义和线性代数，从 $S$ 推导出 $A$–$B$–$C$–$D$ 矩阵。利用两侧馈源相同这一事实，通过适当的矩阵求逆和级联来进行去嵌。\n\n在工作频率下，单个馈源的散射参数为\n$$\nS_{11}^{(\\mathrm{feed})} = \\frac{1}{10},\\quad S_{22}^{(\\mathrm{feed})} = \\frac{1}{10},\\quad S_{21}^{(\\mathrm{feed})} = \\frac{19}{20},\\quad S_{12}^{(\\mathrm{feed})} = \\frac{19}{20},\n$$\n而仿真的三块级联结构（馈源–DUT–馈源）的散射参数为\n$$\nS_{11}^{(\\mathrm{tot})} = S_{22}^{(\\mathrm{tot})} = \\frac{491}{3105},\\quad S_{21}^{(\\mathrm{tot})} = S_{12}^{(\\mathrm{tot})} = \\frac{1805}{2484}.\n$$\n\n使用 $Z_{0}$ 构建电压-电流链形式 $(A,B;C,D)$ 的传输矩阵 $T^{(\\mathrm{feed})}$ 和 $T^{(\\mathrm{tot})}$，然后通过代数方法移除两侧的馈源，以恢复 DUT 的传输矩阵。使用你推导的关系，将得到的 DUT 传输矩阵转换回 $S^{(\\mathrm{DUT})}$。\n\n在此频率下，DUT 的正向传输系数 $S_{21}^{(\\mathrm{DUT})}$ 的值是多少？将最终答案表示为实数，并四舍五入到四位有效数字。",
            "solution": "我们从实参考阻抗 $Z_{0}$ 端口的功率波定义开始：对于端口 $n$，入射波 $a_{n}$ 和反射波 $b_{n}$ 与端口电压 $V_{n}$ 和电流 $I_{n}$ 的关系如下：\n$$\na_{n} = \\frac{V_{n} + Z_{0} I_{n}}{2\\sqrt{Z_{0}}},\\qquad b_{n} = \\frac{V_{n} - Z_{0} I_{n}}{2\\sqrt{Z_{0}}}.\n$$\n二端口散射关系为\n$$\n\\begin{pmatrix} b_{1} \\\\ b_{2} \\end{pmatrix}\n=\n\\begin{pmatrix}\nS_{11} & S_{12} \\\\\nS_{21} & S_{22}\n\\end{pmatrix}\n\\begin{pmatrix} a_{1} \\\\ a_{2} \\end{pmatrix}.\n$$\n对于级联，方便的表示是电压-电流传输（链）矩阵，通常表示为 $(A,B;C,D)$（即 $A$–$B$–$C$–$D$ 矩阵），定义如下：\n$$\n\\begin{pmatrix} V_{1} \\\\ I_{1} \\end{pmatrix}\n=\n\\begin{pmatrix}\nA & B \\\\\nC & D\n\\end{pmatrix}\n\\begin{pmatrix} V_{2} \\\\ I_{2} \\end{pmatrix}.\n$$\n我们的基本基础是在 $Z_{0}$ 归一化功率波框架下的线性网络理论，该理论确保了 $S$ 和 $(A,B;C,D)$ 通过底层的 $(V,I)$ 变量线性相关。\n\n为了从 $S$ 推导出 $(A,B;C,D)$，我们使用定义将 $(V,I)$ 用 $(a,b)$ 表示：\n$$\nV_{n} = \\sqrt{Z_{0}}(a_{n} + b_{n}),\\qquad I_{n} = \\frac{1}{\\sqrt{Z_{0}}}(a_{n} - b_{n}),\n$$\n并与 $b = S\\,a$ 结合。将 $a_{2}$ 和 $b_{2}$ 消去，换成 $(V_{2}, I_{2})$，同样地将 $(V_{1}, I_{1})$ 用 $(a_{1}, b_{1})$ 表示，经过代数整理后得到：\n$$\nA = \\frac{(1+S_{11})(1-S_{22}) + S_{12} S_{21}}{2 S_{21}},\\quad\nB = Z_{0}\\,\\frac{(1+S_{11})(1+S_{22}) - S_{12} S_{21}}{2 S_{21}},\n$$\n$$\nC = \\frac{1}{Z_{0}}\\,\\frac{(1-S_{11})(1-S_{22}) - S_{12} S_{21}}{2 S_{21}},\\quad\nD = \\frac{(1-S_{11})(1+S_{22}) + S_{12} S_{21}}{2 S_{21}}.\n$$\n这些关系直接源于 $(a,b)$ 和 $(V,I)$ 之间的线性变换以及链矩阵的定义。\n\n反之，在实数 $Z_{0}$ 下，从 $(A,B;C,D)$ 转换回 $S$ 是通过解决带有 $(V,I)$ 波的端口匹配问题得到的：\n$$\n\\Delta \\equiv A + \\frac{B}{Z_{0}} + C Z_{0} + D,\n$$\n$$\nS_{21} = \\frac{2}{\\Delta},\\quad\nS_{11} = \\frac{A + \\frac{B}{Z_{0}} - C Z_{0} - D}{\\Delta},\\quad\nS_{22} = \\frac{-A + \\frac{B}{Z_{0}} - C Z_{0} + D}{\\Delta},\\quad\nS_{12} = \\frac{2(AD - BC)}{\\Delta}.\n$$\n\n我们现在根据给定的 $S^{(\\mathrm{feed})}$ 和 $Z_{0} = 50$ 计算馈源的 $(A,B;C,D)^{(\\mathrm{feed})}$：\n$$\nS_{11}^{(\\mathrm{feed})} = \\frac{1}{10},\\quad S_{22}^{(\\mathrm{feed})} = \\frac{1}{10},\\quad S_{21}^{(\\mathrm{feed})} = S_{12}^{(\\mathrm{feed})} = \\frac{19}{20}.\n$$\n计算所需的乘积：\n$$\n(1+S_{11})(1-S_{22}) = \\left(1 + \\frac{1}{10}\\right)\\left(1 - \\frac{1}{10}\\right) = \\frac{11}{10}\\cdot\\frac{9}{10} = \\frac{99}{100},\n$$\n$$\nS_{12} S_{21} = \\left(\\frac{19}{20}\\right)^{2} = \\frac{361}{400}.\n$$\n因此\n$$\nA^{(\\mathrm{feed})} = \\frac{\\frac{99}{100} + \\frac{361}{400}}{2\\cdot \\frac{19}{20}}\n= \\frac{\\frac{396}{400} + \\frac{361}{400}}{\\frac{38}{20}}\n= \\frac{\\frac{757}{400}}{\\frac{38}{20}}\n= \\frac{757}{400}\\cdot\\frac{20}{38}\n= \\frac{757}{760},\n$$\n$$\n(1+S_{11})(1+S_{22}) = \\frac{11}{10}\\cdot\\frac{11}{10} = \\frac{121}{100},\\quad\n(1-S_{11})(1-S_{22}) = \\frac{9}{10}\\cdot\\frac{9}{10} = \\frac{81}{100}.\n$$\n因此\n$$\nB^{(\\mathrm{feed})} = 50\\cdot\\frac{\\frac{121}{100} - \\frac{361}{400}}{2\\cdot \\frac{19}{20}}\n= 50\\cdot\\frac{\\frac{484}{400} - \\frac{361}{400}}{\\frac{38}{20}}\n= 50\\cdot\\frac{\\frac{123}{400}}{\\frac{38}{20}}\n= 50\\cdot\\frac{123}{400}\\cdot\\frac{20}{38}\n= \\frac{615}{76},\n$$\n$$\nC^{(\\mathrm{feed})} = \\frac{1}{50}\\cdot\\frac{\\frac{81}{100} - \\frac{361}{400}}{2\\cdot \\frac{19}{20}}\n= \\frac{1}{50}\\cdot\\frac{\\frac{324}{400} - \\frac{361}{400}}{\\frac{38}{20}}\n= \\frac{1}{50}\\cdot\\frac{-\\frac{37}{400}}{\\frac{38}{20}}\n= \\frac{1}{50}\\cdot\\left(-\\frac{37}{400}\\cdot\\frac{20}{38}\\right)\n= -\\frac{37}{38000},\n$$\n$$\nD^{(\\mathrm{feed})} = \\frac{\\frac{99}{100} + \\frac{361}{400}}{2\\cdot \\frac{19}{20}} = \\frac{757}{760}.\n$$\n所以，\n$$\nT^{(\\mathrm{feed})} \\equiv\n\\begin{pmatrix}\nA^{(\\mathrm{feed})} & B^{(\\mathrm{feed})} \\\\\nC^{(\\mathrm{feed})} & D^{(\\mathrm{feed})}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{757}{760} & \\frac{615}{76} \\\\\n-\\frac{37}{38000} & \\frac{757}{760}\n\\end{pmatrix}.\n$$\n\n接下来，使用相同的公式从 $S^{(\\mathrm{tot})}$ 计算总级联的链矩阵 $T^{(\\mathrm{tot})}$。给定的值为\n$$\nS_{11}^{(\\mathrm{tot})} = S_{22}^{(\\mathrm{tot})} = \\frac{491}{3105},\\qquad\nS_{21}^{(\\mathrm{tot})} = S_{12}^{(\\mathrm{tot})} = \\frac{1805}{2484}.\n$$\n我们构建\n$$\nA^{(\\mathrm{tot})} = \\frac{\\left(1 + \\frac{491}{3105}\\right)\\left(1 - \\frac{491}{3105}\\right) + \\left(\\frac{1805}{2484}\\right)^{2}}{2\\cdot \\frac{1805}{2484}},\n$$\n$$\nB^{(\\mathrm{tot})} = 50\\,\\frac{\\left(1 + \\frac{491}{3105}\\right)\\left(1 + \\frac{491}{3105}\\right) - \\left(\\frac{1805}{2484}\\right)^{2}}{2\\cdot \\frac{1805}{2484}},\n$$\n$$\nC^{(\\mathrm{tot})} = \\frac{1}{50}\\,\\frac{\\left(1 - \\frac{491}{3105}\\right)\\left(1 - \\frac{491}{3105}\\right) - \\left(\\frac{1805}{2484}\\right)^{2}}{2\\cdot \\frac{1805}{2484}},\n$$\n$$\nD^{(\\mathrm{tot})} = \\frac{\\left(1 - \\frac{491}{3105}\\right)\\left(1 + \\frac{491}{3105}\\right) + \\left(\\frac{1805}{2484}\\right)^{2}}{2\\cdot \\frac{1805}{2484}}.\n$$\n进行算术运算（保持精确的分数形式以避免数值误差）得到\n$$\nT^{(\\mathrm{tot})}\n=\n\\begin{pmatrix}\n\\frac{757}{722} & \\frac{404022}{14440} \\\\\n-\\frac{89782}{36100000} & \\frac{757}{722}\n\\end{pmatrix}.\n$$\n我们现在从总传输矩阵中去嵌相同的馈源。对于一个左-DUT-右的级联结构，且馈源相同，链矩阵满足\n$$\nT^{(\\mathrm{tot})} = T^{(\\mathrm{feed})}\\,T^{(\\mathrm{DUT})}\\,T^{(\\mathrm{feed})}.\n$$\n求解 DUT 矩阵，\n$$\nT^{(\\mathrm{DUT})} = \\left(T^{(\\mathrm{feed})}\\right)^{-1}\\,T^{(\\mathrm{tot})}\\,\\left(T^{(\\mathrm{feed})}\\right)^{-1}.\n$$\n计算 $\\left(T^{(\\mathrm{feed})}\\right)^{-1}$。对于一个 $2\\times 2$ 矩阵，\n$$\n\\left(T^{(\\mathrm{feed})}\\right)^{-1}\n=\n\\frac{1}{A^{(\\mathrm{feed})}D^{(\\mathrm{feed})} - B^{(\\mathrm{feed})}C^{(\\mathrm{feed})}}\n\\begin{pmatrix}\nD^{(\\mathrm{feed})} & -B^{(\\mathrm{feed})} \\\\\n- C^{(\\mathrm{feed})} & A^{(\\mathrm{feed})}\n\\end{pmatrix}.\n$$\n对于互易网络，$AD - BC = S_{12}/S_{21}$，这里为1，因此行列式为1。\n$$\n\\left(T^{(\\mathrm{feed})}\\right)^{-1}\n=\n\\begin{pmatrix}\n\\frac{757}{760} & -\\frac{615}{76} \\\\\n\\frac{37}{38000} & \\frac{757}{760}\n\\end{pmatrix}.\n$$\n执行矩阵乘法\n$$\nT^{(\\mathrm{DUT})} = \\begin{pmatrix}\n\\frac{757}{760} & -\\frac{615}{76} \\\\\n\\frac{37}{38000} & \\frac{757}{760}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\frac{757}{722} & \\frac{404022}{14440} \\\\\n-\\frac{89782}{36100000} & \\frac{757}{722}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\frac{757}{760} & -\\frac{615}{76} \\\\\n\\frac{37}{38000} & \\frac{757}{760}\n\\end{pmatrix}\n$$\n经过精确有理化简后得到，\n$$\nT^{(\\mathrm{DUT})} =\n\\begin{pmatrix}\n\\frac{41}{40} & \\frac{45}{4} \\\\\n\\frac{9}{2000} & \\frac{41}{40}\n\\end{pmatrix}.\n$$\n该链矩阵对应一个匹配的互易衰减器。将 $T^{(\\mathrm{DUT})}$ 转换回 $S^{(\\mathrm{DUT})}$，\n$$\n\\Delta_{\\mathrm{DUT}} = A^{(\\mathrm{DUT})} + \\frac{B^{(\\mathrm{DUT})}}{Z_{0}} + C^{(\\mathrm{DUT})} Z_{0} + D^{(\\mathrm{DUT})}\n= \\frac{41}{40} + \\frac{45/4}{50} + \\left(\\frac{9}{2000}\\right) \\cdot 50 + \\frac{41}{40}\n= \\frac{41}{40} + \\frac{9}{40} + \\frac{9}{40} + \\frac{41}{40}\n= \\frac{100}{40}\n= \\frac{5}{2}.\n$$\n因此，\n$$\nS_{21}^{(\\mathrm{DUT})} = \\frac{2}{\\Delta_{\\mathrm{DUT}}} = \\frac{2}{5/2} = \\frac{4}{5} = 0.8,\n$$\n并且，一致地，\n$$\nS_{11}^{(\\mathrm{DUT})} = \\frac{A + \\frac{B}{Z_{0}} - C Z_{0} - D}{\\Delta} = 0,\\qquad\nS_{22}^{(\\mathrm{DUT})} = 0,\\qquad\nS_{12}^{(\\mathrm{DUT})} = \\frac{2(AD - BC)}{\\Delta} = \\frac{2\\cdot 1}{5/2} = \\frac{4}{5} = 0.8,\n$$\n证实了其为互易匹配衰减器。\n\n因此，去嵌后的待测器件正向传输系数为\n$$\nS_{21}^{(\\mathrm{DUT})} = 0.8.\n$$\n四舍五入到四位有效数字，所求值为 $0.8000$。",
            "answer": "$$\\boxed{0.8000}$$"
        },
        {
            "introduction": "数值求解器通过离散化来近似连续的物理现实，但这种近似可能引入违反互易性等物理定律的误差。本练习探讨了一种简单的离散化方案如何导致非对称的 $S$ 矩阵，并要求您通过数值方法验证随着网格加密，该误差如何收敛。这项实践有助于深入理解数值方法对物理守恒律的影响，培养对计算结果的批判性分析能力。",
            "id": "3346695",
            "problem": "考虑一个频域中的一维横电磁波传输问题，该问题由麦克斯韦方程组为均匀、互易、无损耗介质导出的电报员方程建模，其单位长度电感为 $L'$，电容为 $C'$：\n$$\\frac{dV}{dx} = -Z' I,\\quad \\frac{dI}{dx} = -Y' V,$$\n其中，对于角频率 $\\omega = 2\\pi f$，$Z' = i \\omega L'$ 且 $Y' = i \\omega C'$。对于任何具有对称本构关系和相等端口参考阻抗的互易介质，其双端口散射矩阵 $\\mathbf{S}$ 是对称的，即 $S_{12} = S_{21}$。\n\n在计算电磁学中，空间导数的离散化会引入不对称性，在有限网格尺寸下破坏互易性，这种不对称性应在网格细化过程中消失。在本问题中，您将演示并量化应用于电报员方程的一阶单边空间离散化（空间上的前向欧拉步进）如何破坏散射矩阵的对称性，以及当空间步长 $h \\to 0$ 时，这种不对称性如何收敛于零。\n\n使用以下构造。在长度为 $L$ 的线段上，将其离散为 $N$ 个大小为 $h = L/N$ 的均匀单元，应用前向欧拉更新\n$$\\begin{bmatrix}V_{n+1} \\\\ I_{n+1}\\end{bmatrix} = \\mathbf{T}_h \\begin{bmatrix}V_{n} \\\\ I_{n}\\end{bmatrix},\\quad \\mathbf{T}_h = \\begin{bmatrix}1 & -h Z' \\\\ -h Y' & 1\\end{bmatrix}.$$\n该线段的总链式（ABCD）矩阵为\n$$\\mathbf{M}(h) = \\left(\\mathbf{T}_h\\right)^N = \\begin{bmatrix}A & B \\\\ C & D\\end{bmatrix}.$$\n对于两端口相等的参考阻抗 $Z_0$，通过链式矩阵定义散射参数如下：\n$$\\Delta = A + \\frac{B}{Z_0} + C Z_0 + D,$$\n$$S_{11} = \\frac{A + \\frac{B}{Z_0} - C Z_0 - D}{\\Delta},\\quad S_{21} = \\frac{2}{\\Delta},\\quad S_{12} = \\frac{2\\det(\\mathbf{M})}{\\Delta},\\quad S_{22} = \\frac{-A + \\frac{B}{Z_0} - C Z_0 + D}{\\Delta},$$\n其中 $\\det(\\mathbf{M}) = AD - BC$。对于一个真正的互易系统，$\\det(\\mathbf{M}) = 1$，这意味着 $S_{12} = S_{21}$；对于所述的离散化方法，在有限的 $h$ 下 $\\det(\\mathbf{M}) \\neq 1$，而 $|S_{12} - S_{21}|$ 量化了破坏互易性的误差。\n\n您的任务是：\n- 实现上述离散化的双端口模型。\n- 对于固定的物理配置和网格细化路径 $h_k = L/N_k$（其中 $N_k$ 以 2 的幂次增加），计算序列 $E(h_k) = |S_{12}(h_k) - S_{21}(h_k)|$。\n- 通过对数-对数数据 $\\{\\log h_k, \\log E(h_k)\\}$ 进行最小二乘拟合，估计由模型 $E(h) \\approx C h^p$（当 $h \\to 0$ 时）定义的收敛速率 $p$。\n\n使用以下测试套件，每个套件由 $(L, f, L', C', Z_0)$（国际单位制单位）以及每个测试指定的细化路径 $N_k \\in \\{N_0, 2N_0, 4N_0, 8N_0\\}$ 指定。所有物理量必须以其标准国际单位制单位进行解释。任何内部三角计算的角度均以弧度为单位。估计的收敛速率是无量纲的，应作为实数输出。\n\n- 测试 1（正常路径，匹配线）：$(L, f, L', C', Z_0) = (\\,0.5\\,\\mathrm{m},\\, 1.0\\times 10^9\\,\\mathrm{Hz},\\, 250\\times 10^{-9}\\,\\mathrm{H/m},\\, 100\\times 10^{-12}\\,\\mathrm{F/m},\\, 50\\,\\Omega\\,)$，其中 $N_k \\in \\{\\,128,\\,256,\\,512,\\,1024\\,\\}$。\n- 测试 2（失配，中等电长度）：$(L, f, L', C', Z_0) = (\\,0.3\\,\\mathrm{m},\\, 0.5\\times 10^9\\,\\mathrm{Hz},\\, 400\\times 10^{-9}\\,\\mathrm{H/m},\\, 100\\times 10^{-12}\\,\\mathrm{F/m},\\, 50\\,\\Omega\\,)$，其中 $N_k \\in \\{\\,64,\\,128,\\,256,\\,512\\,\\}$。\n- 测试 3（边界情况，小互易性误差）：$(L, f, L', C', Z_0) = (\\,0.2\\,\\mathrm{m},\\, 2.0\\times 10^9\\,\\mathrm{Hz},\\, 250\\times 10^{-9}\\,\\mathrm{H/m},\\, 50\\times 10^{-12}\\,\\mathrm{F/m},\\, 50\\,\\Omega\\,)$，其中 $N_k \\in \\{\\,64,\\,128,\\,256,\\,512\\,\\}$。\n\n您的程序应计算上述三个测试中每个测试的估计收敛速率 $p$，并生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，$[p_1,p_2,p_3]$）。这三个值必须与上面列出的三个测试的顺序相同。程序必须是自包含的，并且不需要任何输入。",
            "solution": "该问题被认为是有效的，因为它在科学上基于电磁波传播和数值分析的原理，是自包含且适定的。所提供的参数在物理上是现实的，并且该任务是计算科学中的一个标准练习，具体是量化数值误差的收敛速率。\n\n目标是确定由一维电报员方程的一阶前向欧拉空间离散化引入的破坏互易性误差的收敛速率。一个由其散射矩阵 $\\mathbf{S}$ 描述的双端口网络，如果 $S_{12} = S_{21}$，则其互易性得到保证。连续的物理系统是互易的，但数值离散化在有限的空间步长下违反了这一性质。我们的任务是在误差模型 $E(h) \\approx C h^p$ 中估计收敛阶 $p$，其中 $E(h) = |S_{12}(h) - S_{21}(h)|$，$h$ 是空间步长。\n\n对于每个测试案例，分析过程如下。\n\n首先，我们从给定的输入 $(L, f, L', C', Z_0)$ 定义物理和电气参数。角频率为 $\\omega = 2\\pi f$。对于无损耗传输线，单位长度串联阻抗 $Z'$ 和并联导纳 $Y'$ 是纯虚数：\n$$Z' = i \\omega L'$$\n$$Y' = i \\omega C'$$\n其中 $i$ 是虚数单位。对于固定的频率 $f$，这些是复数值常数。\n\n接下来，我们实现指定的数值格式。总长度为 $L$ 的传输线被离散为 $N$ 个均匀单元，每个单元的长度为 $h = L/N$。由 $n$ 索引的相邻节点处的电压 $V$ 和电流 $I$ 通过一阶前向欧拉更新规则相关联：\n$$\n\\begin{bmatrix}\nV_{n+1} \\\\\nI_{n+1}\n\\end{bmatrix}\n=\n\\mathbf{T}_h\n\\begin{bmatrix}\nV_{n} \\\\\nI_{n}\n\\end{bmatrix}\n$$\n其中 $\\mathbf{T}_h$ 是长度为 $h$ 的单个单元的局部传输矩阵：\n$$\n\\mathbf{T}_h =\n\\begin{bmatrix}\n1 & -h Z' \\\\\n-h Y' & 1\n\\end{bmatrix}\n$$\n总链式矩阵，也称为 ABCD 矩阵 $\\mathbf{M}(h)$，将输入端（端口 1，$x=0$）的量与输出端（端口 2，$x=L$）的量联系起来。它是通过组合所有 $N$ 个单元的局部传输矩阵得到的：\n$$\n\\mathbf{M}(h) = (\\mathbf{T}_h)^N =\n\\begin{bmatrix}\nA & B \\\\\nC & D\n\\end{bmatrix}\n$$\n对于测试序列中的每个离散化水平 $N_k$，此矩阵幂通过数值计算得出。\n\n此数值模型中互易性误差的来源在于传输矩阵的行列式。对于一个真正的互易双端口网络，其 ABCD 矩阵的行列式必须为 1。对于我们的数值格式，局部矩阵的行列式为：\n$$ \\det(\\mathbf{T}_h) = (1)(1) - (-h Z')(-h Y') = 1 - h^2 Z' Y' = 1 + h^2 \\omega^2 L' C' $$\n由于对于任何 $h > 0$，$\\det(\\mathbf{T}_h) \\neq 1$，总矩阵 $\\mathbf{M}(h)$ 的行列式也非单位行列式：\n$$ \\det(\\mathbf{M}(h)) = (\\det(\\mathbf{T}_h))^N = (1 + h^2 \\omega^2 L' C')^N $$\n这种与 1 的偏差直接导致 S 矩阵的不对称性。\n\n散射参数由 $\\mathbf{M}(h)$ 的元素和参考阻抗 $Z_0$ 计算得出，使用提供的公式：\n$$ \\Delta = A + \\frac{B}{Z_0} + C Z_0 + D $$\n$$ S_{12} = \\frac{2\\det(\\mathbf{M})}{\\Delta} \\quad \\text{和} \\quad S_{21} = \\frac{2}{\\Delta} $$\n破坏互易性的误差定义为 $E(h) = |S_{12}(h) - S_{21}(h)|$。代入 $S_{12}$ 和 $S_{21}$ 的表达式：\n$$ E(h) = \\left| \\frac{2\\det(\\mathbf{M})}{\\Delta} - \\frac{2}{\\Delta} \\right| = \\frac{2}{|\\Delta|} |\\det(\\mathbf{M}) - 1| $$\n为了理解当 $h \\to 0$ 时的收敛行为，我们分析项 $|\\det(\\mathbf{M}) - 1|$。由于 $N = L/h$，我们有 $\\det(\\mathbf{M}) = (1 + h^2 \\omega^2 L' C')^{L/h}$。对于小的 $x$，使用二项式近似 $(1 + x)^n \\approx 1 + nx$，其中 $x = h^2 \\omega^2 L' C'$ 对于小的 $h$ 来说很小：\n$$ \\det(\\mathbf{M}) \\approx 1 + N(h^2 \\omega^2 L' C') = 1 + \\frac{L}{h}(h^2 \\omega^2 L' C') = 1 + (L \\omega^2 L' C')h $$\n因此，$|\\det(\\mathbf{M})-1|$ 是 $O(h)$ 阶的。当 $h \\to 0$ 时，项 $\\Delta$ 收敛到一个对应于连续系统的有限非零常数。因此，误差 $E(h)$ 预计为 $O(h)$ 阶，这意味着理论收敛速率为 $p=1$。\n\n为了数值估计 $p$，我们使用模型 $E(h) \\approx C h^p$。对两边取自然对数可以使关系线性化：\n$$ \\ln(E(h)) \\approx \\ln(C) + p \\ln(h) $$\n此方程的形式为 $y = c + mx$，其中 $y = \\ln(E)$，$x = \\ln(h)$，斜率即为收敛速率 $m=p$。对于每个测试案例，我们为给定细化路径中的每个步长 $h_k = L/N_k$ 计算误差 $E(h_k)$。然后，我们对数据点集 $\\{\\ln(h_k), \\ln(E_k)\\}$ 执行线性最小二乘回归。最佳拟合线的斜率提供了收敛速率 $p$ 的数值估计。对所有三个测试案例重复此过程。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    \n    # Test cases defined as tuples:\n    # (L, f, L', C', Z0, N_values)\n    # L: length in meters\n    # f: frequency in Hertz\n    # L': per-unit-length inductance in Henrys/meter\n    # C': per-unit-length capacitance in Farads/meter\n    # Z0: reference impedance in Ohms\n    # N_values: list of discretization counts\n    test_cases = [\n        (0.5, 1.0e9, 250e-9, 100e-12, 50.0, [128, 256, 512, 1024]),\n        (0.3, 0.5e9, 400e-9, 100e-12, 50.0, [64, 128, 256, 512]),\n        (0.2, 2.0e9, 250e-9, 50e-12, 50.0, [64, 128, 256, 512]),\n    ]\n\n    results = []\n    for params in test_cases:\n        p = calculate_convergence_rate(*params)\n        results.append(p)\n\n    # Format the output as a comma-separated list in square brackets.\n    # The problem example shows integers, but results are floats.\n    # Default string conversion is used as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_convergence_rate(L, f, L_prime, C_prime, Z0, N_values):\n    \"\"\"\n    Calculates the convergence rate p for a single test case.\n\n    Args:\n        L (float): Length of the transmission line in meters.\n        f (float): Frequency in Hertz.\n        L_prime (float): Per-unit-length inductance in H/m.\n        C_prime (float): Per-unit-length capacitance in F/m.\n        Z0 (float): Reference impedance in Ohms.\n        N_values (list): A list of integers for the number of cells N.\n\n    Returns:\n        float: The estimated convergence rate p.\n    \"\"\"\n    \n    omega = 2 * math.pi * f\n    Z_prime = 1j * omega * L_prime\n    Y_prime = 1j * omega * C_prime\n\n    h_values = []\n    E_values = []\n\n    for N in N_values:\n        h = L / N\n        \n        # Construct the local transfer matrix T_h\n        T_h = np.array([[1, -h * Z_prime],\n                        [-h * Y_prime, 1]], dtype=np.complex128)\n        \n        # Calculate the total ABCD matrix M = (T_h)^N\n        M = np.linalg.matrix_power(T_h, N)\n        A, B = M[0, 0], M[0, 1]\n        C, D = M[1, 0], M[1, 1]\n        \n        # Calculate the S-parameters from the ABCD matrix\n        # Note: np.linalg.det() can be less accurate than manual calculation\n        # for a 2x2 matrix. A*D - B*C is more stable.\n        det_M = A * D - B * C\n        delta = A + B/Z0 + C*Z0 + D\n        \n        S12 = (2 * det_M) / delta\n        S21 = 2 / delta\n        \n        # Calculate the reciprocity error E(h)\n        E = abs(S12 - S21)\n        \n        h_values.append(h)\n        E_values.append(E)\n\n    # Convert lists to numpy arrays for vectorized operations\n    h_values = np.array(h_values)\n    E_values = np.array(E_values)\n\n    # Take the natural logarithm for log-log regression\n    log_h = np.log(h_values)\n    log_E = np.log(E_values)\n    \n    # Perform a linear least-squares fit on the log-log data.\n    # np.polyfit with degree 1 returns [slope, intercept].\n    # The slope is the convergence rate p.\n    p, _ = np.polyfit(log_h, log_E, 1)\n    \n    return p\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在离散频点上定义的原始 $S$ 参数数据通常不适用于时域系统仿真。本练习介绍了一种关键技术——宏建模（macromodeling），即如何从离散数据创建一个连续、紧凑的有理函数模型，同时强制执行如互易性等物理约束。这项技能对于在系统级仿真器中准确表示高频组件至关重要。",
            "id": "3346664",
            "problem": "给定一个双端口、线性时不变（LTI）网络的离散频域散射参数数据。您的任务是构建并实现一种针对散射矩阵的约束有理拟合程序，该程序在最小化频率加权误差的同时，强制施加互易性和几何对称性。拟合必须针对一个有理模型进行，该模型具有在矩阵各项之间共享的固定稳定极点。解决方案必须是一个完整的、可运行的程序，该程序为指定的测试套件计算所要求的指标，并以本提示末尾描述的精确格式打印最终结果。\n\n散射矩阵是复频率的复值函数，表示为 $\\;S(s)\\in\\mathbb{C}^{2\\times 2}\\;$，其中 $s=\\mathrm{j}2\\pi f$，f 的单位是赫兹。对于一个互易且几何对称的双端口网络，互易性和对称性意味着对于所有感兴趣的复频率 $\\;s\\;$，都有 $\\;S_{12}(s)=S_{21}(s)\\;$ 和 $\\;S_{11}(s)=S_{22}(s)\\;$。您将使用一个带有预设极点的有理模型来近似真实数据，该模型也强制执行这些约束：\n$$\n\\hat S(s)=\n\\begin{bmatrix}\n\\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{d})}_k}{s-a_k}+d^{(\\mathrm{d})} & \\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{o})}_k}{s-a_k}+d^{(\\mathrm{o})} \\\\\n\\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{o})}_k}{s-a_k}+d^{(\\mathrm{o})} & \\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{d})}_k}{s-a_k}+d^{(\\mathrm{d})}\n\\end{bmatrix},\n$$\n其中 $\\;a_k\\in\\mathbb{C}\\;$ 是固定的稳定极点，对于所有 $\\;k\\in\\{1,\\dots,K\\}\\;$，都有 $\\;\\Re\\{a_k\\} < 0\\;$；$\\;r^{(\\mathrm{d})}_k\\in\\mathbb{C}\\;$ 和 $\\;r^{(\\mathrm{o})}_k\\in\\mathbb{C}\\;$ 分别是对角和非对角留数；$\\;d^{(\\mathrm{d})},d^{(\\mathrm{o})}\\in\\mathbb{C}\\;$ 是常数项。该模型通过构造强制执行了 $\\;\\hat S_{12}(s)=\\hat S_{21}(s)\\;$ 和 $\\;\\hat S_{11}(s)=\\hat S_{22}(s)\\;$。\n\n您将获得一个离散频率网格 $\\;\\{f_i\\}_{i=1}^N\\;$ 和相应的复矩阵 $\\;S(f_i)\\;$，其中 $s_i=\\mathrm{j}2\\pi f_i$。令 $\\;W_i\\ge 0\\;$ 表示非负实频率权重。将网格上的频率加权误差目标定义为加权弗罗贝尼乌斯范数\n$$\nJ=\\sum_{i=1}^{N} W_i \\left\\| \\hat S(s_i)-S(s_i) \\right\\|_{F}^{2}.\n$$\n您的任务是计算最小化 $\\;J\\;$ 的最小二乘解，该解针对未知数 $\\;\\{r^{(\\mathrm{d})}_k\\}_{k=1}^{K},\\{r^{(\\mathrm{o})}_k\\}_{k=1}^{K},d^{(\\mathrm{d})},d^{(\\mathrm{o})}\\;$，并使用固定的极点 $\\;\\{a_k\\}_{k=1}^{K}\\;$，然后报告归一化加权均方根（RMS）误差\n$$\n\\varepsilon_{\\mathrm{wRMS}}=\\sqrt{\\frac{\\sum_{i=1}^{N} W_i \\left\\|\\hat S(s_i)-S(s_i)\\right\\|_{F}^{2}}{\\sum_{i=1}^{N} W_i}}.\n$$\n对于所有计算，使用单位为赫兹的 f 和 $s=\\mathrm{j}2\\pi f$。最终的误差值是无量纲的。\n\n您必须将拟合实现为一个复值、频率加权的线性最小二乘问题。必须通过上述有理模型中所示的参数共享来强制执行互易性和对称性约束。不要对极点进行正则化或修改。通过使用提供的稳定实数极点来确保数值稳定性。\n\n使用以下数据，这些数据定义了一个涵盖多种情况的测试套件。下面所有的符号和数字都必须严格按照所述使用。\n\n基本设置和通用定义：\n1. 极点数：$\\;K=3$。\n2. 固定极点（单位：弧度/秒）：\n$$\na_1=-2\\pi\\cdot 0.5\\times 10^{9},\\quad\na_2=-2\\pi\\cdot 2.0\\times 10^{9},\\quad\na_3=-2\\pi\\cdot 8.0\\times 10^{9}.\n$$\n3. 频率网格 $\\;\\{f_i\\}_{i=1}^{N}\\;$，其中 $\\;N=9\\;$，单位为赫兹：\n$$\n\\left[f_1,\\dots,f_9\\right]=\\left[0.5,\\,1.0,\\,2.0,\\,3.5,\\,5.0,\\,7.5,\\,10.0,\\,15.0,\\,20.0\\right]\\times 10^{9}.\n$$\n4. 对于任何复频率 $\\;s_i=\\mathrm{j}2\\pi f_i\\;$，定义基函数\n$$\n\\phi_k(s_i)=\\frac{1}{s_i-a_k},\\quad k\\in\\{1,2,3\\}.\n$$\n\n测试用例定义：\n- 测试用例 $\\;1\\;$（理想的对称互易数据）：\n  使用具有以下精确实系数的有理模型：\n  $$\n  \\left[r^{(\\mathrm{d})}_1,r^{(\\mathrm{d})}_2,r^{(\\mathrm{d})}_3\\right]=\\left[0.08,\\,-0.03,\\,0.015\\right],\n  $$\n  $$\n  \\left[r^{(\\mathrm{o})}_1,r^{(\\mathrm{o})}_2,r^{(\\mathrm{o})}_3\\right]=\\left[0.20,\\,0.09,\\,-0.05\\right],\n  $$\n  $$\n  d^{(\\mathrm{d})}=0.01,\\quad d^{(\\mathrm{o})}=-0.005.\n  $$\n  对于每个 $\\;i\\in\\{1,\\dots,9\\}\\;$，定义 $\\;S_{11}(f_i)=S_{22}(f_i)=\\sum_{k=1}^{3} r^{(\\mathrm{d})}_k \\phi_k(s_i)+d^{(\\mathrm{d})}\\;$ 和 $\\;S_{12}(f_i)=S_{21}(f_i)=\\sum_{k=1}^{3} r^{(\\mathrm{o})}_k \\phi_k(s_i)+d^{(\\mathrm{o})}\\;$。频率权重为\n  $$\n  W_i=\\frac{1}{1+\\left(\\frac{f_i}{10^{10}}\\right)^{2}},\\quad i\\in\\{1,\\dots,9\\}.\n  $$\n\n- 测试用例 $\\;2\\;$（非对角项的非对称扰动）：\n  从测试用例 $\\;1\\;$ 的相同 $\\;S(f_i)\\;$ 出发，并对非对角项添加一个反对称的实数扰动：\n  $$\n  \\delta=0.02,\\quad f_{\\mathrm{d}}=5.0\\times 10^{9},\n  $$\n  $$\n  \\tau_i=\\exp\\!\\left(-\\frac{f_i}{f_{\\mathrm{d}}}\\right),\n  $$\n  $$\n  S_{12}(f_i)\\leftarrow S_{12}(f_i)+\\delta\\,\\tau_i,\\quad S_{21}(f_i)\\leftarrow S_{21}(f_i)-\\delta\\,\\tau_i,\n  $$\n  同时保持 $\\;S_{11}(f_i)\\;$ 和 $\\;S_{22}(f_i)\\;$ 不变。使用与测试用例 $\\;1\\;$ 中相同的权重 $\\;W_i\\;$。\n\n- 测试用例 $\\;3\\;$（在权重为零的单个频率点存在离群值）：\n  从测试用例 $\\;1\\;$ 的相同 $\\;S(f_i)\\;$ 出发，然后在对应于 $\\;f=15.0\\times 10^{9}\\;$ 赫兹的单个频率索引处，向所有四个项添加一个大的实数离群值：\n  $$\n  \\Delta=0.5,\\quad S_{pq}(15.0\\times 10^{9})\\leftarrow S_{pq}(15.0\\times 10^{9})+\\Delta\\quad \\text{for all}\\;p,q\\in\\{1,2\\}.\n  $$\n  使用与测试用例 $\\;1\\;$ 中相同的权重 $\\;W_i\\;$，但将 $\\;f=15.0\\times 10^{9}\\;$ 赫兹处的权重设置为零：\n  $$\n  W_i\\leftarrow 0\\quad \\text{if}\\;f_i=15.0\\times 10^{9}.\n  $$\n\n您的程序必须为三个测试用例中的每一个执行以下步骤：\n1. 建立复值加权线性系统，该系统强制执行有理模型以及互易性加对称性约束，其未知数为 $\\;\\{r^{(\\mathrm{d})}_k\\}_{k=1}^{3},\\{r^{(\\mathrm{o})}_k\\}_{k=1}^{3},d^{(\\mathrm{d})},d^{(\\mathrm{o})}\\;$。\n2. 求解最小化 $\\;J\\;$ 的频率加权复数最小二乘问题。\n3. 在网格上重建 $\\;\\hat S(s_i)\\;$ 并计算如上定义的归一化加权 RMS 误差 $\\;\\varepsilon_{\\mathrm{wRMS}}\\;$。\n\n角度的使用已隐含在复数运算中，不需要指定单位。所有频率 $\\;f\\;$ 必须以赫兹为单位处理，所有极点 $\\;a_k\\;$ 必须以弧度/秒为单位处理。最终的数值答案是无量纲的。\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，包含三个浮点数，按测试用例 $\\;1,2,3\\;$ 的顺序排列，例如 $\\;[x_1,x_2,x_3]\\;$，不含空格。",
            "solution": "问题是确定一个双端口散射矩阵 $\\;S(s)\\;$ 的约束有理模型的最佳系数，使得频率加权的误差度量最小化。该模型必须强制执行互易性 $\\;\\hat S_{12}(s) = \\hat S_{21}(s)\\;$ 和几何对称性 $\\;\\hat S_{11}(s) = \\hat S_{22}(s)\\;$。这是通过为相应的对角和非对角元素使用一组共享系数来实现的。该问题是一个线性最小二乘拟合问题，因为模型在未知系数（留数和常数项）上是线性的，并且极点是固定的。\n\n散射矩阵的有理模型 $\\;\\hat S(s)\\;$ 由下式给出：\n$$\n\\hat S(s)=\n\\begin{bmatrix}\n\\hat S_{11}(s) & \\hat S_{12}(s) \\\\\n\\hat S_{21}(s) & \\hat S_{22}(s)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{d})}_k}{s-a_k}+d^{(\\mathrm{d})} & \\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{o})}_k}{s-a_k}+d^{(\\mathrm{o})} \\\\\n\\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{o})}_k}{s-a_k}+d^{(\\mathrm{o})} & \\displaystyle \\sum_{k=1}^{K}\\frac{r^{(\\mathrm{d})}_k}{s-a_k}+d^{(\\mathrm{d})}\n\\end{bmatrix}\n$$\n未知系数是复值留数 $\\;\\{r^{(\\mathrm{d})}_k\\}_{k=1}^{K}, \\{r^{(\\mathrm{o})}_k\\}_{k=1}^{K}\\;$ 和复值常数项 $\\;d^{(\\mathrm{d})}, d^{(\\mathrm{o})}\\;$。极点 $\\;\\{a_k\\}_{k=1}^{K}\\;$ 是固定的。\n\n目标是在一组离散的 $\\;N\\;$ 个频率 $\\;\\{f_i\\}_{i=1}^N\\;$（其中 $\\;s_i = \\mathrm{j}2\\pi f_i\\;$）上最小化频率加权误差 $\\;J\\;$：\n$$\nJ=\\sum_{i=1}^{N} W_i \\left\\| \\hat S(s_i)-S(s_i) \\right\\|_{F}^{2}\n$$\n其中 $\\;S(s_i)\\;$ 是给定数据，$\\;W_i \\ge 0\\;$ 是权重，$\\;\\| \\cdot \\|_F\\;$ 是弗罗贝尼乌斯范数。展开弗罗贝尼乌斯范数，目标函数为：\n$$\nJ=\\sum_{i=1}^{N} W_i \\left( |\\hat S_{11}(s_i)-S_{11}(s_i)|^2 + |\\hat S_{12}(s_i)-S_{12}(s_i)|^2 + |\\hat S_{21}(s_i)-S_{21}(s_i)|^2 + |\\hat S_{22}(s_i)-S_{22}(s_i)|^2 \\right)\n$$\n通过代入模型的约束条件 $\\;\\hat S_{11}(s) = \\hat S_{22}(s)\\;$ 和 $\\;\\hat S_{12}(s) = \\hat S_{21}(s)\\;$，我们得到：\n$$\nJ=\\sum_{i=1}^{N} W_i \\left( |\\hat S_{11}(s_i)-S_{11}(s_i)|^2 + |\\hat S_{12}(s_i)-S_{12}(s_i)|^2 + |\\hat S_{12}(s_i)-S_{21}(s_i)|^2 + |\\hat S_{11}(s_i)-S_{22}(s_i)|^2 \\right)\n$$\n该表达式可以解耦为两个独立的最小化问题，一个用于对角系数，一个用于非对角系数：\n$$\nJ = J_{\\mathrm{diag}} + J_{\\mathrm{offdiag}}\n$$\n其中\n$$\nJ_{\\mathrm{diag}} = \\sum_{i=1}^{N} W_i \\left( |\\hat S_{11}(s_i)-S_{11}(s_i)|^2 + |\\hat S_{11}(s_i)-S_{22}(s_i)|^2 \\right)\n$$\n$$\nJ_{\\mathrm{offdiag}} = \\sum_{i=1}^{N} W_i \\left( |\\hat S_{12}(s_i)-S_{12}(s_i)|^2 + |\\hat S_{12}(s_i)-S_{21}(s_i)|^2 \\right)\n$$\n用于 $\\;J_{\\mathrm{diag}}\\;$ 的未知系数集与用于 $\\;J_{\\mathrm{offdiag}}\\;$ 的未知系数集不相交。因此，我们可以独立求解它们。\n\n让我们为对角元素构建线性系统。未知数被收集在一个向量 $\\;\\mathbf{x}_\\mathrm{d} \\in \\mathbb{C}^{K+1}\\;$ 中：\n$$\n\\mathbf{x}_\\mathrm{d} = [r^{(\\mathrm{d})}_1, r^{(\\mathrm{d})}_2, \\dots, r^{(\\mathrm{d})}_K, d^{(\\mathrm{d})}]^T\n$$\n$\\;\\hat S_{11}(s_i)\\;$ 的模型在这些系数上是线性的：\n$$\n\\hat S_{11}(s_i) = \\left( \\sum_{k=1}^{K} r^{(\\mathrm{d})}_k \\phi_k(s_i) \\right) + d^{(\\mathrm{d})} = \\mathbf{\\Phi}_i^T \\mathbf{x}_\\mathrm{d}\n$$\n其中 $\\;\\phi_k(s_i) = \\frac{1}{s_i-a_k}\\;$ 是基函数，且 $\\;\\mathbf{\\Phi}_i = [\\phi_1(s_i), \\dots, \\phi_K(s_i), 1]^T\\;$。最小化 $\\;J_{\\mathrm{diag}}\\;$ 等价于求解加权线性最小二乘问题 $\\;A_\\mathrm{d} \\mathbf{x}_\\mathrm{d} \\approx \\mathbf{b}_\\mathrm{d}\\;$，即最小化 $\\;\\|A_\\mathrm{d} \\mathbf{x}_\\mathrm{d} - \\mathbf{b}_\\mathrm{d}\\|_2^2\\;$。系统矩阵 $\\;A_\\mathrm{d} \\in \\mathbb{C}^{2N \\times (K+1)}\\;$ 和向量 $\\;\\mathbf{b}_\\mathrm{d} \\in \\mathbb{C}^{2N}\\;$ 的构造如下：\n$$\nA_\\mathrm{d} = \\begin{bmatrix}\n\\sqrt{W_1} \\mathbf{\\Phi}_1^T \\\\\n\\vdots \\\\\n\\sqrt{W_N} \\mathbf{\\Phi}_N^T \\\\\n\\sqrt{W_1} \\mathbf{\\Phi}_1^T \\\\\n\\vdots \\\\\n\\sqrt{W_N} \\mathbf{\\Phi}_N^T\n\\end{bmatrix},\n\\quad\n\\mathbf{b}_\\mathrm{d} = \\begin{bmatrix}\n\\sqrt{W_1} S_{11}(s_1) \\\\\n\\vdots \\\\\n\\sqrt{W_N} S_{11}(s_N) \\\\\n\\sqrt{W_1} S_{22}(s_1) \\\\\n\\vdots \\\\\n\\sqrt{W_N} S_{22}(s_N)\n\\end{bmatrix}\n$$\n非对角元素的问题可以类似地构建。未知数向量是 $\\;\\mathbf{x}_\\mathrm{o} = [r^{(\\mathrm{o})}_1, r^{(\\mathrm{o})}_2, \\dots, r^{(\\mathrm{o})}_K, d^{(\\mathrm{o})}]^T\\;$。系统是 $\\;A_\\mathrm{o} \\mathbf{x}_\\mathrm{o} \\approx \\mathbf{b}_\\mathrm{o}\\;$，其中系统矩阵 $\\;A_\\mathrm{o}\\;$ 与 $\\;A_\\mathrmd\\;$ 相同，而右侧向量 $\\;\\mathbf{b}_\\mathrm{o}\\;$ 由非对角数据构造：\n$$\n\\mathbf{b}_\\mathrm{o} = \\begin{bmatrix}\n\\sqrt{W_1} S_{12}(s_1) \\\\\n\\vdots \\\\\n\\sqrt{W_N} S_{12}(s_N) \\\\\n\\sqrt{W_1} S_{21}(s_1) \\\\\n\\vdots \\\\\n\\sqrt{W_N} S_{21}(s_N)\n\\end{bmatrix}\n$$\n这些复值超定系统使用标准的线性最小二乘求解器来求解 $\\;\\mathbf{x}_\\mathrm{d}\\;$ 和 $\\;\\mathbf{x}_\\mathrm{o}\\;$。对于给定的测试用例，算法如下：\n1.  生成数据矩阵 $\\;S(f_i)\\;$ 和权重 $\\;W_i\\;$。\n2.  计算 $\\;s_i = \\mathrm{j}2\\pi f_i\\;$ 并构建系统矩阵 $\\;A = A_\\mathrmd = A_\\mathrmo\\;$。\n3.  构建右侧向量 $\\;\\mathbf{b}_\\mathrm{d}\\;$ 和 $\\;\\mathbf{b}_\\mathrm{o}\\;$。\n4.  求解两个线性最小二乘问题，找到最优系数向量 $\\;\\mathbf{x}_\\mathrm{d}\\;$ 和 $\\;\\mathbf{x}_\\mathrm{o}\\;$。\n5.  使用拟合的系数重建所有 $\\;i\\;$ 的模型矩阵 $\\;\\hat S(s_i)\\;$。\n6.  使用以下公式计算归一化加权 RMS 误差 $\\;\\varepsilon_{\\mathrm{wRMS}}\\;$：\n    $$\n    \\varepsilon_{\\mathrm{wRMS}}=\\sqrt{\\frac{\\sum_{i=1}^{N} W_i \\left\\|\\hat S(s_i)-S(s_i)\\right\\|_{F}^{2}}{\\sum_{i=1}^{N} W_i}}\n    $$\n此过程应用于指定的三个测试用例中的每一个。",
            "answer": "```python\nimport numpy as np\n\ndef perform_fit_and_get_error(S_data, W, freqs, poles):\n    \"\"\"\n    Performs the constrained rational fit and computes the weighted RMS error.\n\n    Args:\n        S_data (np.ndarray): Array of measured S-matrices, shape (N, 2, 2).\n        W (np.ndarray): Array of frequency weights, shape (N,).\n        freqs (np.ndarray): Array of frequencies in Hz, shape (N,).\n        poles (np.ndarray): Array of fixed poles in rad/s, shape (K,).\n\n    Returns:\n        float: The normalized weighted RMS error (epsilon_wRMS).\n    \"\"\"\n    N = len(freqs)\n    K = len(poles)\n\n    s = 1j * 2 * np.pi * freqs\n\n    # Construct the basis function matrix Phi, shape (N, K+1)\n    # The last column is for the constant term d.\n    phi_matrix = np.zeros((N, K + 1), dtype=np.complex128)\n    for i in range(N):\n        for k in range(K):\n            phi_matrix[i, k] = 1.0 / (s[i] - poles[k])\n        phi_matrix[i, K] = 1.0\n\n    # Weight the basis matrix rows by sqrt(W_i)\n    sqrt_W = np.sqrt(W)\n    weighted_phi = sqrt_W[:, np.newaxis] * phi_matrix\n\n    # The system matrix A is the same for both diagonal and off-diagonal fits.\n    # It has shape (2N, K+1), stacking the weighted basis for Sij and Sji.\n    A = np.vstack([weighted_phi, weighted_phi])\n\n    # ---- Diagonal Fit (for S11 and S22) ----\n    S11_data = S_data[:, 0, 0]\n    S22_data = S_data[:, 1, 1]\n    \n    # Construct the right-hand-side vector b_d, shape (2N,)\n    b_d = np.concatenate([sqrt_W * S11_data, sqrt_W * S22_data])\n    \n    # Solve the least-squares problem for diagonal coefficients x_d\n    x_d, _, _, _ = np.linalg.lstsq(A, b_d, rcond=None)\n\n    # ---- Off-diagonal Fit (for S12 and S21) ----\n    S12_data = S_data[:, 0, 1]\n    S21_data = S_data[:, 1, 0]\n\n    # Construct the right-hand-side vector b_o, shape (2N,)\n    b_o = np.concatenate([sqrt_W * S12_data, sqrt_W * S21_data])\n\n    # Solve the least-squares problem for off-diagonal coefficients x_o\n    x_o, _, _, _ = np.linalg.lstsq(A, b_o, rcond=None)\n\n    # ---- Reconstruct the model and Calculate Error ----\n    # Reconstructed S-parameter entries from the fit\n    S11_fit = phi_matrix @ x_d\n    S12_fit = phi_matrix @ x_o\n\n    # Assemble the full fitted S-matrix S_hat\n    S_hat = np.zeros((N, 2, 2), dtype=np.complex128)\n    S_hat[:, 0, 0] = S11_fit\n    S_hat[:, 1, 1] = S11_fit  # Enforce S11 = S22\n    S_hat[:, 0, 1] = S12_fit\n    S_hat[:, 1, 0] = S12_fit  # Enforce S12 = S21\n\n    # Calculate the squared Frobenius norm of the error matrix (S_hat - S_data) at each frequency\n    error_matrix = S_hat - S_data\n    frob_norm_sq_per_freq = np.sum(np.abs(error_matrix)**2, axis=(1, 2))\n\n    # Calculate the total weighted sum of squared errors (the objective function cost, J)\n    J = np.sum(W * frob_norm_sq_per_freq)\n\n    # Sum of weights for normalization\n    W_sum = np.sum(W)\n    \n    if W_sum == 0:\n        # If all weights are zero, the error is definitionally zero.\n        return 0.0\n\n    # Calculate the final normalized weighted RMS error\n    epsilon_wRMS = np.sqrt(J / W_sum)\n    \n    return epsilon_wRMS\n\n\ndef solve():\n    # ---- Common Setup and Definitions ----\n    K = 3\n    poles = -2 * np.pi * np.array([0.5e9, 2.0e9, 8.0e9])\n    freqs = np.array([0.5, 1.0, 2.0, 3.5, 5.0, 7.5, 10.0, 15.0, 20.0]) * 1e9\n    N = len(freqs)\n    \n    results = []\n\n    # ---- Test Case 1: Ideal Symmetric Reciprocal Data ----\n    r_d_ideal = np.array([0.08, -0.03, 0.015])\n    d_d_ideal = 0.01\n    r_o_ideal = np.array([0.20, 0.09, -0.05])\n    d_o_ideal = -0.005\n    \n    s = 1j * 2 * np.pi * freqs\n    phi_matrix_gen = np.zeros((N, K), dtype=np.complex128)\n    for i in range(N):\n        for k in range(K):\n            phi_matrix_gen[i, k] = 1.0 / (s[i] - poles[k])\n\n    S11_ideal = phi_matrix_gen @ r_d_ideal + d_d_ideal\n    S12_ideal = phi_matrix_gen @ r_o_ideal + d_o_ideal\n\n    S_case1 = np.zeros((N, 2, 2), dtype=np.complex128)\n    S_case1[:, 0, 0] = S11_ideal\n    S_case1[:, 1, 1] = S11_ideal\n    S_case1[:, 0, 1] = S12_ideal\n    S_case1[:, 1, 0] = S12_ideal\n\n    W_case1 = 1.0 / (1.0 + (freqs / 1e10)**2)\n    \n    err1 = perform_fit_and_get_error(S_case1, W_case1, freqs, poles)\n    results.append(err1)\n\n    # ---- Test Case 2: Asymmetric Perturbation ----\n    S_case2 = np.copy(S_case1)\n    delta = 0.02\n    f_d = 5.0e9\n    tau = np.exp(-freqs / f_d)\n    S_case2[:, 0, 1] += delta * tau\n    S_case2[:, 1, 0] -= delta * tau\n    \n    W_case2 = W_case1  # Weights are the same as Case 1\n\n    err2 = perform_fit_and_get_error(S_case2, W_case2, freqs, poles)\n    results.append(err2)\n\n    # ---- Test Case 3: Outlier with Zero Weight ----\n    S_case3 = np.copy(S_case1)\n    Delta = 0.5\n    outlier_idx = np.where(freqs == 15.0e9)[0][0]\n    S_case3[outlier_idx, :, :] += Delta\n\n    W_case3 = np.copy(W_case1)\n    W_case3[outlier_idx] = 0.0\n    \n    err3 = perform_fit_and_get_error(S_case3, W_case3, freqs, poles)\n    results.append(err3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}