{
    "hands_on_practices": [
        {
            "introduction": "This first exercise addresses the time-dependent wave equation using the Finite-Difference Time-Domain (FDTD) method, a cornerstone of computational electromagnetics. While conceptually straightforward, discretizing space and time introduces numerical artifacts that alter wave propagation. This practice will guide you through deriving the numerical dispersion relation for the 2D Yee scheme, allowing you to quantify the resulting phase velocity error and understand its dependence on grid parameters and propagation direction .",
            "id": "3354598",
            "problem": "Consider a two-dimensional homogeneous, isotropic, source-free medium characterized by permittivity $\\epsilon$ and permeability $\\mu$. Starting from Maxwell's equations and the constitutive relations, a wave equation for electromagnetic fields can be obtained. In a uniform Cartesian grid, the standard Yee scheme uses staggered spatial sampling with grid steps $\\Delta x$ and $\\Delta y$ and a staggered time step $\\Delta t$ under the Courant-Friedrichs-Lewy (CFL) stability limit. For a plane wave propagating at an oblique angle in the $x$-$y$ plane, the numerical dispersion relation of the Yee scheme links the angular frequency $\\omega$ and the wavenumber components $k_x$ and $k_y$.\n\nYour tasks are:\n- Derive, from first principles, the numerical dispersion relation of the Yee scheme by applying a plane-wave ansatz to the discrete update equations for a homogeneous medium. Then, for a given propagation angle, define $k_x$ and $k_y$ in terms of the wavenumber magnitude $k$ and angle, and use the dispersion relation to compute $\\omega$.\n- Use the dispersion relation to compute the numerical phase velocity $v_{\\mathrm{p,num}}=\\omega/k$, where $k=\\sqrt{k_x^2+k_y^2}$, and compare it to the exact phase velocity $c=1/\\sqrt{\\mu\\epsilon}$ of a continuous plane wave in the same medium. Report the absolute phase velocity error $e=v_{\\mathrm{p,num}}-c$ in $\\mathrm{m/s}$, expressed as a decimal number (not a percentage).\n- Implement a program that, for each test case below, computes the absolute phase velocity error $e$ using $\\omega$ obtained from the Yee numerical dispersion relation in two dimensions. Use degree units for angles.\n\nUse the following test suite. Each case is specified by $(\\Delta x,\\Delta y,\\Delta t,\\phi,\\lambda,\\mu,\\epsilon)$ with units $(\\mathrm{m},\\mathrm{m},\\mathrm{s},\\text{degrees},\\mathrm{m},\\mathrm{H/m},\\mathrm{F/m})$:\n1. $\\Delta x=1\\times 10^{-3}$, $\\Delta y=1\\times 10^{-3}$, $\\Delta t=0.98\\cdot \\dfrac{\\Delta x}{\\sqrt{2}c_0}$, $\\phi=30^\\circ$, $\\lambda=1\\times 10^{-2}$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$, where $\\mu_0=4\\pi\\times 10^{-7}$ and $\\epsilon_0=8.854187817\\times 10^{-12}$, and $c_0=1/\\sqrt{\\mu_0\\epsilon_0}$.\n2. $\\Delta x=5\\times 10^{-4}$, $\\Delta y=1\\times 10^{-3}$, $\\Delta t=0.85\\cdot \\left(\\dfrac{1}{c_0\\sqrt{\\dfrac{1}{\\Delta x^2}+\\dfrac{1}{\\Delta y^2}}}\\right)$, $\\phi=60^\\circ$, $\\lambda=5\\times 10^{-3}$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$.\n3. $\\Delta x=1\\times 10^{-3}$, $\\Delta y=1\\times 10^{-3}$, $\\Delta t=0.5\\cdot \\dfrac{\\Delta x}{\\sqrt{2}c_0}$, $\\phi=0^\\circ$, $\\lambda=2.5\\times \\Delta x$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$.\n4. $\\Delta x=2\\times 10^{-3}$, $\\Delta y=2\\times 10^{-3}$, $\\Delta t=0.5\\cdot \\dfrac{\\Delta x}{\\sqrt{2}c_0}$, $\\phi=45^\\circ$, $\\lambda=4\\times \\Delta x$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$.\n5. $\\Delta x=1.5\\times 10^{-3}$, $\\Delta y=7.5\\times 10^{-4}$, $\\Delta t=0.9\\cdot \\left(\\dfrac{1}{c^\\star\\sqrt{\\dfrac{1}{\\Delta x^2}+\\dfrac{1}{\\Delta y^2}}}\\right)$, $\\phi=20^\\circ$, $\\lambda=6\\times 10^{-3}$, $\\mu=\\mu_0$, $\\epsilon=4\\epsilon_0$, and $c^\\star=1/\\sqrt{\\mu\\epsilon}$ for this medium.\n\nFor each case:\n- Compute the exact phase velocity $c=1/\\sqrt{\\mu\\epsilon}$.\n- Compute the wavenumber magnitude $k=2\\pi/\\lambda$ and components $k_x=k\\cos(\\phi)$ and $k_y=k\\sin(\\phi)$ with $\\phi$ in degrees.\n- Solve the Yee numerical dispersion relation in two dimensions for $\\omega$ and evaluate $v_{\\mathrm{p,num}}=\\omega/k$.\n- Report the absolute phase velocity error $e=v_{\\mathrm{p,num}}-c$ in $\\mathrm{m/s}$.\n\nYour program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$, where each $\\text{result}_i$ is the computed error $e$ for the $i$-th case in $\\mathrm{m/s}$.",
            "solution": "The problem requires the derivation of the numerical dispersion relation for the two-dimensional Yee Finite-Difference Time-Domain (FDTD) scheme and its application to compute the numerical phase velocity error for several test cases.\n\nLet us begin from first principles. The propagation of electromagnetic waves in a homogeneous, isotropic, and source-free medium is governed by Maxwell's curl equations:\n$$ \\nabla \\times \\mathbf{E} = -\\frac{\\partial \\mathbf{B}}{\\partial t} $$\n$$ \\nabla \\times \\mathbf{H} = \\frac{\\partial \\mathbf{D}}{\\partial t} $$\nWith the linear constitutive relations $\\mathbf{D} = \\epsilon \\mathbf{E}$ and $\\mathbf{B} = \\mu \\mathbf{H}$, where $\\epsilon$ is the permittivity and $\\mu$ is the permeability of the medium, the equations become:\n$$ \\nabla \\times \\mathbf{E} = -\\mu \\frac{\\partial \\mathbf{H}}{\\partial t} \\quad (1) $$\n$$ \\nabla \\times \\mathbf{H} = \\epsilon \\frac{\\partial \\mathbf{E}}{\\partial t} \\quad (2) $$\nFor a two-dimensional problem in the $x$-$y$ plane, we can consider the Transverse Magnetic ($TM_z$) mode, for which the only non-zero field components are $E_z$, $H_x$, and $H_y$. The vector equations $(1)$ and $(2)$ decompose into a set of three scalar equations:\n$$ \\frac{\\partial E_z}{\\partial y} = -\\mu \\frac{\\partial H_x}{\\partial t} \\quad (3) $$\n$$ \\frac{\\partial E_z}{\\partial x} = \\mu \\frac{\\partial H_y}{\\partial t} \\quad (4) $$\n$$ \\frac{\\partial H_y}{\\partial x} - \\frac{\\partial H_x}{\\partial y} = \\epsilon \\frac{\\partial E_z}{\\partial t} \\quad (5) $$\n\nThe Yee FDTD scheme discretizes these equations on a staggered grid. A field component $F(x,y,t)$ is represented as $F^n(i,j) = F(i\\Delta x, j\\Delta y, n\\Delta t)$. The spatial and temporal staggering of the $TM_z$ components is as follows:\n- $E_z$ is evaluated at grid points $(i\\Delta x, j\\Delta y)$ and time steps $n\\Delta t$.\n- $H_x$ is evaluated at $(i\\Delta x, (j+1/2)\\Delta y)$ and time steps $(n+1/2)\\Delta t$.\n- $H_y$ is evaluated at $((i+1/2)\\Delta x, j\\Delta y)$ and time steps $(n+1/2)\\Delta t$.\n\nApplying central finite differences to equations $(3)-(5)$ yields the Yee update equations:\n$$ \\frac{E_z^n(i, j+1) - E_z^n(i, j)}{\\Delta y} = -\\mu \\frac{H_x^{n+1/2}(i, j+1/2) - H_x^{n-1/2}(i, j+1/2)}{\\Delta t} \\quad (6) $$\n$$ \\frac{E_z^n(i+1, j) - E_z^n(i, j)}{\\Delta x} = \\mu \\frac{H_y^{n+1/2}(i+1/2, j) - H_y^{n-1/2}(i+1/2, j)}{\\Delta t} \\quad (7) $$\n$$ \\frac{H_y^{n+1/2}(i+1/2, j) - H_y^{n+1/2}(i-1/2, j)}{\\Delta x} - \\frac{H_x^{n+1/2}(i, j+1/2) - H_x^{n+1/2}(i, j-1/2)}{\\Delta y} = \\epsilon \\frac{E_z^{n+1}(i, j) - E_z^n(i, j)}{\\Delta t} \\quad (8) $$\n\nTo find the numerical dispersion relation, we postulate a plane-wave solution (ansatz) on the discrete grid. For a wave with angular frequency $\\omega$ and wavevector components $k_x$ and $k_y$, the fields are:\n$$ E_z^n(i,j) = E_{z0} e^{\\mathrm{j}(k_x i\\Delta x + k_y j\\Delta y - \\omega n\\Delta t)} $$\n$$ H_x^{n+1/2}(i,j+1/2) = H_{x0} e^{\\mathrm{j}(k_x i\\Delta x + k_y (j+1/2)\\Delta y - \\omega (n+1/2)\\Delta t)} $$\n$$ H_y^{n+1/2}(i+1/2,j) = H_{y0} e^{\\mathrm{j}(k_x (i+1/2)\\Delta x + k_y j\\Delta y - \\omega (n+1/2)\\Delta t)} $$\nwhere $E_{z0}$, $H_{x0}$, and $H_{y0}$ are complex amplitudes. Substituting these into the update equations allows us to solve for the relationship between $\\omega$, $k_x$, and $k_y$.\n\nFrom equation $(6)$:\n$$ E_{z0} \\frac{e^{\\mathrm{j}k_y\\Delta y} - 1}{\\Delta y} = -\\mu H_{x0} e^{\\mathrm{j}k_y\\Delta y/2} \\frac{e^{-\\mathrm{j}\\omega\\Delta t/2} - e^{\\mathrm{j}\\omega\\Delta t/2}}{\\Delta t} $$\nUsing the identity $e^{\\mathrm{j}\\theta}-1=e^{\\mathrm{j}\\theta/2}(2\\mathrm{j}\\sin(\\theta/2))$, the equation simplifies to:\n$$ \\frac{E_{z0}}{\\Delta y} e^{\\mathrm{j}k_y\\Delta y/2} (2\\mathrm{j}\\sin(k_y\\Delta y/2)) = \\mu \\frac{H_{x0}}{\\Delta t} e^{\\mathrm{j}k_y\\Delta y/2} (2\\mathrm{j}\\sin(\\omega\\Delta t/2)) $$\n$$ H_{x0} = \\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta y} \\frac{\\sin(k_y\\Delta y/2)}{\\sin(\\omega\\Delta t/2)} \\quad (9) $$\n\nFrom equation $(7)$:\n$$ E_{z0} \\frac{e^{\\mathrm{j}k_x\\Delta x} - 1}{\\Delta x} = \\mu H_{y0} e^{\\mathrm{j}k_x\\Delta x/2} \\frac{e^{-\\mathrm{j}\\omega\\Delta t/2} - e^{\\mathrm{j}\\omega\\Delta t/2}}{\\Delta t} $$\n$$ \\frac{E_{z0}}{\\Delta x} e^{\\mathrm{j}k_x\\Delta x/2} (2\\mathrm{j}\\sin(k_x\\Delta x/2)) = -\\mu \\frac{H_{y0}}{\\Delta t} e^{\\mathrm{j}k_x\\Delta x/2} (2\\mathrm{j}\\sin(\\omega\\Delta t/2)) $$\n$$ H_{y0} = -\\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta x} \\frac{\\sin(k_x\\Delta x/2)}{\\sin(\\omega\\Delta t/2)} \\quad (10) $$\n\nFinally, substituting the ansatz into equation $(8)$:\n$$ \\frac{H_{y0}}{\\Delta x} (2\\mathrm{j}\\sin(k_x\\Delta x/2)) - \\frac{H_{x0}}{\\Delta y} (2\\mathrm{j}\\sin(k_y\\Delta y/2)) = \\epsilon \\frac{E_{z0}}{\\Delta t} (-2\\mathrm{j}\\sin(\\omega\\Delta t/2)) $$\nNow, substitute expressions for $H_{x0}$ and $H_{y0}$ from $(9)$ and $(10)$:\n$$ \\frac{1}{\\Delta x} \\left(-\\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta x} \\frac{\\sin(k_x\\Delta x/2)}{\\sin(\\omega\\Delta t/2)}\\right)\\sin(k_x\\Delta x/2) - \\frac{1}{\\Delta y}\\left(\\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta y} \\frac{\\sin(k_y\\Delta y/2)}{\\sin(\\omega\\Delta t/2)}\\right)\\sin(k_y\\Delta y/2) = -\\frac{\\epsilon E_{z0}}{\\Delta t}\\sin(\\omega\\Delta t/2) $$\nDividing by $-E_{z0}$ and rearranging gives:\n$$ \\frac{\\Delta t}{\\mu \\sin(\\omega\\Delta t/2)}\\left(\\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_y\\Delta y/2)}{\\Delta y^2}\\right) = \\frac{\\epsilon}{\\Delta t}\\sin(\\omega\\Delta t/2) $$\nMultiplying terms and using the relation for the speed of light in the medium, $c=1/\\sqrt{\\mu\\epsilon}$, we arrive at the numerical dispersion relation for the 2D Yee scheme:\n$$ \\left(\\frac{1}{\\Delta x}\\sin\\left(\\frac{k_x\\Delta x}{2}\\right)\\right)^2 + \\left(\\frac{1}{\\Delta y}\\sin\\left(\\frac{k_y\\Delta y}{2}\\right)\\right)^2 = \\left(\\frac{1}{c\\Delta t}\\sin\\left(\\frac{\\omega\\Delta t}{2}\\right)\\right)^2 $$\n\nTo compute the numerical phase velocity, we first solve for the numerical angular frequency $\\omega$:\n$$ \\sin\\left(\\frac{\\omega\\Delta t}{2}\\right) = c\\Delta t \\sqrt{\\left(\\frac{\\sin(k_x\\Delta x/2)}{\\Delta x}\\right)^2 + \\left(\\frac{\\sin(k_y\\Delta y/2)}{\\Delta y}\\right)^2} $$\n$$ \\omega = \\frac{2}{\\Delta t}\\arcsin\\left(c\\Delta t \\sqrt{\\left(\\frac{\\sin(k_x\\Delta x/2)}{\\Delta x}\\right)^2 + \\left(\\frac{\\sin(k_y\\Delta y/2)}{\\Delta y}\\right)^2}\\right) $$\nThe numerical phase velocity $v_{\\mathrm{p,num}}$ is defined as the ratio of this numerical angular frequency $\\omega$ to the magnitude of the continuous-space wavenumber $k=\\sqrt{k_x^2+k_y^2}$:\n$$ v_{\\mathrm{p,num}} = \\frac{\\omega}{k} $$\nThe absolute phase velocity error $e$ is the difference between the numerical phase velocity and the exact phase velocity $c$ in the continuous medium:\n$$ e = v_{\\mathrm{p,num}} - c $$\n\nFor each test case, the following procedure is implemented:\n1.  Define the constants $\\mu_0=4\\pi\\times 10^{-7} \\, \\mathrm{H/m}$ and $\\epsilon_0=8.854187817\\times 10^{-12} \\, \\mathrm{F/m}$.\n2.  For a given test case $(\\Delta x, \\Delta y, \\Delta t, \\phi, \\lambda, \\mu, \\epsilon)$:\n    a. Compute the exact phase velocity $c=1/\\sqrt{\\mu\\epsilon}$.\n    b. Compute the wavenumber magnitude $k = 2\\pi/\\lambda$.\n    c. Convert the propagation angle $\\phi$ from degrees to radians.\n    d. Compute the wavenumber components $k_x=k\\cos(\\phi)$ and $k_y=k\\sin(\\phi)$.\n    e. Substitute all values into the derived equation for $\\omega$.\n    f. Compute the numerical phase velocity $v_{\\mathrm{p,num}}=\\omega/k$.\n    g. Calculate the absolute error $e = v_{\\mathrm{p,num}} - c$.\nThis procedure is repeated for all five test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerical phase velocity error for the 2D Yee FDTD scheme\n    for a set of test cases.\n    \"\"\"\n    \n    # Define physical constants from the problem statement\n    mu_0 = 4 * np.pi * 1e-7  # H/m\n    epsilon_0 = 8.854187817e-12  # F/m\n    c_0 = 1 / np.sqrt(mu_0 * epsilon_0)\n\n    # Test cases: (dx, dy, dt_spec, phi_deg, lam_spec, mu_r, eps_r)\n    # dt_spec = (factor, type, c_ref_str)\n    #   type: 'iso' for dx=dy, 'aniso' for dx!=dy\n    #   c_ref_str: 'c0' for vacuum speed, 'c_medium' for material speed\n    # lam_spec = (type, value) where type can be 'abs' or 'rel' to dx\n    test_cases = [\n        (1e-3, 1e-3, (0.98, 'iso', 'c0'), 30, ('abs', 1e-2), 1.0, 1.0),\n        (5e-4, 1e-3, (0.85, 'aniso', 'c0'), 60, ('abs', 5e-3), 1.0, 1.0),\n        (1e-3, 1e-3, (0.5, 'iso', 'c0'), 0, ('rel', 2.5), 1.0, 1.0),\n        (2e-3, 2e-3, (0.5, 'iso', 'c0'), 45, ('rel', 4.0), 1.0, 1.0),\n        (1.5e-3, 7.5e-4, (0.9, 'aniso', 'c_medium'), 20, ('abs', 6e-3), 1.0, 4.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        dx, dy, dt_spec, phi_deg, lam_spec, mu_r, eps_r = case\n        \n        # Unpack specifications\n        dt_factor, dt_type, c_ref_str = dt_spec\n        lam_type, lam_val = lam_spec\n\n        # 1. Calculate medium properties and exact phase velocity\n        mu = mu_r * mu_0\n        epsilon = eps_r * epsilon_0\n        c = 1 / np.sqrt(mu * epsilon)\n        \n        # 2. Calculate time step dt\n        if c_ref_str == 'c0':\n            c_ref_for_dt = c_0\n        else: # 'c_medium'\n            c_ref_for_dt = c\n\n        if dt_type == 'iso':\n            dt = dt_factor * dx / (np.sqrt(2) * c_ref_for_dt)\n        else: # 'aniso'\n            dt = dt_factor / (c_ref_for_dt * np.sqrt(1/dx**2 + 1/dy**2))\n\n        # 3. Calculate wavelength and wavenumber\n        if lam_type == 'rel':\n            lam = lam_val * dx\n        else: # 'abs'\n            lam = lam_val\n\n        k = 2 * np.pi / lam\n        phi_rad = np.deg2rad(phi_deg)\n        kx = k * np.cos(phi_rad)\n        ky = k * np.sin(phi_rad)\n\n        # 4. Solve numerical dispersion relation for omega\n        term_x = (np.sin(kx * dx / 2) / dx)**2\n        term_y = (np.sin(ky * dy / 2) / dy)**2\n        \n        arcsin_arg = c * dt * np.sqrt(term_x + term_y)\n        \n        # The argument must be = 1 for a stable scheme\n        if arcsin_arg  1.0 and not np.isclose(arcsin_arg, 1.0):\n             # This should not happen for the given stable test cases\n             raise ValueError(f\"FDTD scheme is unstable. arcsin argument  1: {arcsin_arg}\")\n        if arcsin_arg  1.0: # Clamp for floating point inaccuracies\n             arcsin_arg = 1.0\n        \n        omega = (2 / dt) * np.arcsin(arcsin_arg)\n\n        # 5. Compute numerical phase velocity and error\n        v_p_num = omega / k\n        error = v_p_num - c\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "We now shift our focus to the frequency domain and the Helmholtz equation, which is fundamental for analyzing time-harmonic phenomena like scattering. Boundary Integral Equation (BIE) methods are a powerful tool for these problems, but they can suffer from a critical flaw: ill-conditioning at frequencies corresponding to interior resonances of the scatterer. This practice uses a spherical scatterer, where the integral operators have known analytical eigenvalues, to investigate the conditioning of different formulations and reveal why the Combined Field Integral Equation (CFIE) is essential for robust solutions .",
            "id": "3354579",
            "problem": "Consider the homogeneous Helmholtz equation for time-harmonic fields in three dimensions, written for a complex-valued scalar field as $$\\nabla^2 u(\\mathbf{x}) + k^2 u(\\mathbf{x}) = 0,$$ where $k$ is the wavenumber. The free-space Helmholtz Green’s function is $$G(\\mathbf{x},\\mathbf{y}) = \\frac{e^{ik|\\mathbf{x}-\\mathbf{y}|}}{4\\pi |\\mathbf{x}-\\mathbf{y}|}.$$ On a smooth closed surface $\\Gamma$, the classical boundary integral operators are the single-layer operator $$\\mathcal{S}[\\rho](\\mathbf{x}) = \\int_{\\Gamma} G(\\mathbf{x},\\mathbf{y}) \\rho(\\mathbf{y}) \\,\\mathrm{d}S_{\\mathbf{y}},$$ and the double-layer operator $$\\mathcal{K}[\\rho](\\mathbf{x}) = \\int_{\\Gamma} \\frac{\\partial G(\\mathbf{x},\\mathbf{y})}{\\partial n_{\\mathbf{y}}} \\rho(\\mathbf{y}) \\,\\mathrm{d}S_{\\mathbf{y}},$$ where $\\partial/\\partial n_{\\mathbf{y}}$ denotes the derivative with respect to the outward normal at $\\mathbf{y} \\in \\Gamma$. The exterior limit of the double-layer potential on $\\Gamma$ exhibits the jump relation and is commonly written as $\\left(-\\frac{1}{2}\\mathcal{I} + \\mathcal{K}\\right)[\\rho]$ where $\\mathcal{I}$ denotes the identity operator. In computational electromagnetics for perfectly electrically conducting scatterers, the Electric Field Integral Equation (EFIE), the Magnetic Field Integral Equation (MFIE), and the Combined Field Integral Equation (CFIE) are used to enforce the boundary conditions. In scalar Helmholtz analogs suitable for conditioning analysis, EFIE corresponds to the single-layer equation, MFIE to the second-kind double-layer equation, and CFIE to a linear combination of the two.\n\nLet $\\Gamma$ be the sphere of radius $a$ centered at the origin. Using spherical harmonics, the operators $\\mathcal{S}$ and $\\mathcal{K}$ are diagonalized by the spherical harmonics $Y_{\\ell m}(\\hat{\\mathbf{x}})$ on the sphere, where $\\ell \\in \\mathbb{N}_0$ and $-\\ell \\le m \\le \\ell$. Let $x = ka$ be the dimensionless size parameter. Define the spherical Bessel function of the first kind $j_{\\ell}(x)$ and the spherical Hankel function of the first kind $h_{\\ell}^{(1)}(x) = j_{\\ell}(x) + i y_{\\ell}(x)$, where $y_{\\ell}(x)$ is the spherical Bessel function of the second kind. Denote by $h_{\\ell}^{(1)\\prime}(x)$ the derivative of $h_{\\ell}^{(1)}(x)$ with respect to its argument $x$.\n\nWhen the density is a spherical harmonic $Y_{\\ell m}$, the single-layer operator acts as $$\\mathcal{S}[Y_{\\ell m}] = \\lambda_{\\ell}^{\\mathcal{S}} \\, Y_{\\ell m}, \\quad \\lambda_{\\ell}^{\\mathcal{S}} = \\frac{a x}{i} \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x).$$ The principal value double-layer operator contributes $$\\mathcal{K}[Y_{\\ell m}] = \\lambda_{\\ell}^{\\mathcal{K}} \\, Y_{\\ell m}, \\quad \\lambda_{\\ell}^{\\mathcal{K}} = \\frac{x^2}{i} \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)\\prime}(x),$$ and the MFIE operator has eigenvalues $$\\mu_{\\ell}^{\\text{MFIE}} = -\\frac{1}{2} + \\lambda_{\\ell}^{\\mathcal{K}}.$$ A dimensionless CFIE operator can be formed by $$\\nu_{\\ell}^{\\text{CFIE}} = \\alpha \\, \\mu_{\\ell}^{\\text{MFIE}} + \\eta \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x),$$ where $\\alpha \\in (0,1)$ and $\\eta  0$ are coupling parameters. For a truncated spherical harmonic expansion up to degree $\\ell_{\\max}$, define the conditioning (condition number) of each operator as $$\\kappa(\\mathcal{O}) = \\frac{\\max_{0 \\le \\ell \\le \\ell_{\\max}} |\\lambda_{\\ell}(\\mathcal{O})|}{\\min_{0 \\le \\ell \\le \\ell_{\\max}} |\\lambda_{\\ell}(\\mathcal{O})|},$$ where $\\lambda_{\\ell}(\\mathcal{O})$ is the eigenvalue of the operator $\\mathcal{O}$ acting on $Y_{\\ell m}$, and the minimum is taken over strictly positive magnitudes to avoid division by zero if any eigenvalue vanishes numerically. This $\\kappa$ provides a proxy for conditioning of the truncated discrete system.\n\nTask. Implement a program that:\n- Computes the eigenvalues $\\lambda_{\\ell}^{\\mathcal{S}}$, $\\mu_{\\ell}^{\\text{MFIE}}$, and $\\nu_{\\ell}^{\\text{CFIE}}$ for $\\ell = 0,1,\\dots,\\ell_{\\max}$ with $\\ell_{\\max} = \\lceil x \\rceil + 8$, for a given sphere radius $a$ and size parameter $x = k a$.\n- Computes the condition numbers $\\kappa(\\mathcal{S})$, $\\kappa(\\text{MFIE})$, and $\\kappa(\\text{CFIE})$ by taking the ratio of the largest to the smallest nonzero absolute eigenvalues among $\\ell = 0,\\dots,\\ell_{\\max}$.\n- Uses the following test suite of parameter sets, which span small $x$, moderate $x$, near-resonant $x$, and large $x$:\n    1. $a = 1$ meter, $x = 0.1$, $\\alpha = 0.5$, $\\eta = 0.7$.\n    2. $a = 1$ meter, $x = 1.0$, $\\alpha = 0.5$, $\\eta = 0.7$.\n    3. $a = 1$ meter, $x = 3.1415926535$, $\\alpha = 0.5$, $\\eta = 0.7$.\n    4. $a = 1$ meter, $x = 6.0$, $\\alpha = 0.5$, $\\eta = 0.7$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The result for each test case must be a list of three floating-point numbers in the order $[\\kappa(\\mathcal{S}), \\kappa(\\text{MFIE}), \\kappa(\\text{CFIE})]$. Therefore, the final output format must be a single line like: [[kS1,kM1,kC1],[kS2,kM2,kC2],[kS3,kM3,kC3],[kS4,kM4,kC4]]. No physical units are required in the output; all condition numbers are dimensionless.",
            "solution": "The problem is assessed to be valid. It is scientifically sound, well-posed, and provides a complete and consistent set of definitions and data required for a unique solution. The problem statement is based on established principles of computational electromagnetics and the theory of boundary integral equations for the Helmholtz equation. The task is to perform a numerical analysis of the conditioning of three common integral equation formulations on a sphere, which is a standard and insightful exercise in the field.\n\nThe core of this problem is to analyze the spectral properties of boundary integral operators associated with the Helmholtz equation on a sphere. The operators are diagonalized by the spherical harmonics $Y_{\\ell m}$, reducing the problem of analyzing the operator to analyzing its eigenvalues $\\lambda_{\\ell}$. The condition number, defined as the ratio of the maximum to the minimum non-zero eigenvalue magnitudes, serves as a proxy for the numerical stability of a discretized system based on these operators. A large condition number indicates that the corresponding linear system is ill-conditioned and sensitive to small perturbations, which can lead to large errors in numerical solutions.\n\nThe overall procedure to solve the problem for each given test case $(a, x, \\alpha, \\eta)$ is as follows:\n\n1.  **Determine the Truncation Degree**: The spherical harmonic expansion must be truncated at a sufficiently high degree to capture the oscillatory nature of the solution. The problem provides the rule of thumb $\\ell_{\\max} = \\lceil x \\rceil + 8$, where $x = ka$ is the dimensionless size parameter. The calculations will be performed for integer degrees $\\ell$ from $0$ to $\\ell_{\\max}$.\n\n2.  **Evaluate Special Functions**: The eigenvalue expressions depend on the spherical Bessel function of the first kind, $j_{\\ell}(x)$, the spherical Hankel function of the first kind, $h_{\\ell}^{(1)}(x)$, and the derivative of the Hankel function, $h_{\\ell}^{(1)\\prime}(x)$. The Hankel function is defined as $h_{\\ell}^{(1)}(x) = j_{\\ell}(x) + i y_{\\ell}(x)$, where $y_{\\ell}(x)$ is the spherical Bessel function of the second kind and $i$ is the imaginary unit. These functions are computed for the given $x$ and for each required degree $\\ell \\in \\{0, 1, \\dots, \\ell_{\\max}\\}$. The derivatives, such as $h_{\\ell}^{(1)\\prime}(x)$, are taken with respect to the argument $x$. These computations are efficiently and accurately performed using a standard scientific library, such as `scipy.special` in Python, which provides routines for these functions and their derivatives.\n\n3.  **Compute Eigenvalues**: With the special functions evaluated, the eigenvalues for each operator are calculated for each $\\ell \\in \\{0, 1, \\dots, \\ell_{\\max}\\}$.\n    -   **Single-Layer (EFIE analog)**: The eigenvalues are given by the formula $\\lambda_{\\ell}^{\\mathcal{S}} = \\frac{a x}{i} \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x) = -i a x \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x)$. The conditioning of this operator is known to be poor when $x$ is near a zero of any $j_{\\ell}(x)$, which corresponds to an interior Dirichlet resonance of the sphere.\n    -   **MFIE analog**: The eigenvalues of the second-kind double-layer operator are $\\mu_{\\ell}^{\\text{MFIE}} = -\\frac{1}{2} + \\lambda_{\\ell}^{\\mathcal{K}}$, where $\\lambda_{\\ell}^{\\mathcal{K}} = \\frac{x^2}{i} \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)\\prime}(x) = -i x^2 \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)\\prime}(x)$. This formulation also suffers from ill-conditioning, albeit at a different set of resonant frequencies (corresponding to interior Neumann resonances). When $j_{\\ell}(x) = 0$, the eigenvalue $\\mu_{\\ell}^{\\text{MFIE}}$ becomes exactly $-1/2$ and does not vanish, which is an advantage over the EFIE.\n    -   **CFIE analog**: The eigenvalues for the combined field formulation are given by $\\nu_{\\ell}^{\\text{CFIE}} = \\alpha \\, \\mu_{\\ell}^{\\text{MFIE}} + \\eta \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x)$. This linear combination is constructed to circumvent the resonance problem. When a resonance causes a term in one operator to become problematic (e.g., $j_{\\ell}(x) \\approx 0$ ), the other term in the combination remains well-behaved, ensuring that the resulting eigenvalue $\\nu_{\\ell}^{\\text{CFIE}}$ does not vanish. For example, if $j_{\\ell}(x) = 0$, then $\\mu_{\\ell}^{\\text{MFIE}} = -1/2$ and the term $\\eta \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x)$ vanishes, resulting in $\\nu_{\\ell}^{\\text{CFIE}} = -\\alpha/2$. Since $\\alpha \\in (0,1)$, this eigenvalue is non-zero, demonstrating the formulation's robustness against this particular resonance.\n\n4.  **Calculate Condition Numbers**: For each of the three operators $\\mathcal{O} \\in \\{\\mathcal{S}, \\text{MFIE}, \\text{CFIE}\\}$, a set of eigenvalues $\\{\\lambda_0(\\mathcal{O}), \\dots, \\lambda_{\\ell_{\\max}}(\\mathcal{O})\\}$ is obtained. The condition number is then computed according to the formula:\n    $$ \\kappa(\\mathcal{O}) = \\frac{\\max_{0 \\le \\ell \\le \\ell_{\\max}} |\\lambda_{\\ell}(\\mathcal{O})|}{\\min_{0 \\le \\ell \\le \\ell_{\\max}, |\\lambda_{\\ell}(\\mathcal{O})|0} |\\lambda_{\\ell}(\\mathcal{O})|} $$\n    This involves taking the absolute values of all computed eigenvalues, filtering out any that are zero, and then finding the ratio of the maximum to the minimum of the remaining positive magnitudes.\n\nThis entire procedure is implemented and repeated for each of the four specified test cases. The results will quantitatively demonstrate the superior conditioning of the CFIE formulation compared to the EFIE and MFIE, particularly for the test case where $x \\approx \\pi$, which is close to a zero of $j_1(x)$, a known resonance for the sphere. The parameter $a=1$ is used as specified, although the resulting condition numbers for the dimensionless operators are independent of this choice.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn, spherical_yn\n\ndef solve():\n    \"\"\"\n    Computes and compares the condition numbers of scalar EFIE, MFIE, and CFIE\n    analogs for scattering from a sphere.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, x, alpha, eta)\n        (1.0, 0.1, 0.5, 0.7),\n        (1.0, 1.0, 0.5, 0.7),\n        (1.0, 3.1415926535, 0.5, 0.7),\n        (1.0, 6.0, 0.5, 0.7),\n    ]\n\n    results = []\n    for a, x, alpha, eta in test_cases:\n        # Step 1: Determine the truncation degree l_max\n        l_max = int(np.ceil(x)) + 8\n        l_range = np.arange(0, l_max + 1)\n\n        # Step 2: Evaluate special functions j_l(x), y_l(x), and their derivatives\n        # h_l^(1)(x) = j_l(x) + i * y_l(x)\n        # scipy.special functions are vectorized, so they compute for all l in l_range at once.\n        jl_x = spherical_jn(l_range, x)\n        yl_x = spherical_yn(l_range, x)\n        \n        # Derivatives with respect to the argument x\n        jl_x_prime = spherical_jn(l_range, x, derivative=True)\n        yl_x_prime = spherical_yn(l_range, x, derivative=True)\n\n        h1l_x = jl_x + 1j * yl_x\n        h1l_x_prime = jl_x_prime + 1j * yl_x_prime\n\n        # Step 3: Compute eigenvalues for each operator\n        \n        # Eigenvalues for single-layer operator (S)\n        # lambda_l^S = (a*x/i) * j_l(x) * h_l^(1)(x) = -i*a*x*j_l*h_l\n        lambda_S = -1j * a * x * jl_x * h1l_x\n        \n        # Eigenvalues for double-layer operator (K)\n        # lambda_l^K = (x^2/i) * j_l(x) * h_l^(1)'(x) = -i*x^2*j_l*h_l'\n        lambda_K = -1j * x**2 * jl_x * h1l_x_prime\n        \n        # Eigenvalues for MFIE operator\n        # mu_l^MFIE = -1/2 + lambda_l^K\n        mu_MFIE = -0.5 + lambda_K\n        \n        # Eigenvalues for CFIE operator\n        # nu_l^CFIE = alpha * mu_l^MFIE + eta * j_l(x) * h_l^(1)(x)\n        nu_CFIE = alpha * mu_MFIE + eta * jl_x * h1l_x\n\n        # Step 4: Calculate condition numbers\n        \n        def calculate_condition_number(eigenvalues):\n            \"\"\"\n            Computes condition number as max(|lambda|)/min(|lambda| > 0).\n            \"\"\"\n            abs_vals = np.abs(eigenvalues)\n            # Filter out any zero or near-zero magnitudes to avoid division by zero\n            # and adhere to the problem's \"strictly positive magnitudes\" rule.\n            non_zero_abs_vals = abs_vals[abs_vals  1e-18] # Use a small tolerance\n            \n            if non_zero_abs_vals.size == 0:\n                # This case implies all eigenvalues are zero, condition number is ill-defined.\n                # Could be 1.0 (for a zero operator) or inf.\n                # Assuming it does not occur for the given test cases.\n                return 1.0 \n                \n            max_abs = np.max(non_zero_abs_vals)\n            min_abs = np.min(non_zero_abs_vals)\n            \n            return max_abs / min_abs\n\n        kappa_S = calculate_condition_number(lambda_S)\n        kappa_MFIE = calculate_condition_number(mu_MFIE)\n        kappa_CFIE = calculate_condition_number(nu_CFIE)\n        \n        results.append([kappa_S, kappa_MFIE, kappa_CFIE])\n\n    # Final print statement in the exact required format.\n    # The string representation of a list is '[item1, item2, ...]'\n    # Joining these with commas and enclosing in brackets gives the desired output.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Although the CFIE from the previous practice provides a robust formulation, standard Boundary Element Methods (BEM) lead to dense matrix systems, making large-scale simulations computationally prohibitive. This final exercise introduces you to the principles of modern fast solvers by exploring hierarchical matrix techniques and Adaptive Cross Approximation (ACA). By implementing a system that identifies and compresses low-rank far-field interaction blocks, you will gain hands-on experience with the core concepts that enable the efficient solution of large-scale Helmholtz problems .",
            "id": "3354552",
            "problem": "You are to design and implement a program that studies the low-rank structure of far-field interaction blocks of the three-dimensional exterior scalar Helmholtz kernel commonly appearing in computational electromagnetics. The goal is to examine how the numerical rank of admissible far-field blocks depends on the wavenumber and on a tunable compression threshold, using Adaptive Cross Approximation (ACA) to compress the blocks and to control the approximation error.\n\nStart from the source-free time-harmonic Maxwell equations under a single frequency phasor ansatz, where fields vary as $\\mathrm{e}^{- \\mathrm{i} \\omega t}$. In a homogeneous, isotropic, source-free region, this leads to the vector Helmholtz equation for the electric field $\\nabla \\times \\nabla \\times \\mathbf{E} - k^{2}\\mathbf{E} = \\mathbf{0}$, with $k = \\omega \\sqrt{\\mu \\epsilon}$ the wavenumber. For the purpose of studying low-rank structure independent of vector intricacies, reduce to the scalar Helmholtz equation $\\nabla^{2} u + k^{2} u = 0$ outside a bounded scatterer, and consider the free-space fundamental solution $G(\\mathbf{x}, \\mathbf{y}) = \\dfrac{\\mathrm{e}^{\\mathrm{i} k \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}}{4 \\pi \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}$.\n\nDiscretize the boundary of a sphere of radius $a = 1\\,\\mathrm{m}$ by a set of $N$ points $\\{\\mathbf{x}_{i}\\}_{i=1}^{N}$ distributed quasi-uniformly on the sphere. Define the dense matrix $K \\in \\mathbb{C}^{N \\times N}$ with entries $K_{ij} = G(\\mathbf{x}_{i}, \\mathbf{x}_{j})$ for $i \\neq j$ and $K_{ii} = 0$ to avoid the singular self-term. Build a binary spatial clustering (a $k$-d tree) of the point set by recursively splitting the longest spatial extent until each leaf cluster contains at most $s$ points. For two leaf clusters $I$ and $J$ with centers $\\mathbf{c}_{I}$, $\\mathbf{c}_{J}$ and radii $r_{I}$, $r_{J}$ (half the diagonal of the bounding box of the cluster), define the cluster distance $d(I,J) = \\max\\left(0, \\lVert \\mathbf{c}_{I} - \\mathbf{c}_{J} \\rVert - (r_{I} + r_{J})\\right)$. A pair $(I,J)$ is admissible (a far-field block) if $\\max(r_{I}, r_{J}) \\le \\eta \\, d(I,J)$ for a fixed admissibility parameter $\\eta \\in (0,1)$. For each admissible pair $(I,J)$, consider the submatrix $K_{IJ}$ formed by rows in $I$ and columns in $J$.\n\nImplement Adaptive Cross Approximation (ACA) to build a rank-$r$ factorization $K_{IJ} \\approx U V^{\\top}$ such that the relative Frobenius norm error $\\lVert K_{IJ} - U V^{\\top} \\rVert_{F} / \\lVert K_{IJ} \\rVert_{F} \\le \\varepsilon$, where $\\varepsilon$ is a user-specified threshold. Your ACA must adaptively select pivots and terminate when the target relative blockwise error is met, or when the rank reaches $\\min(|I|,|J|)$. For each admissible block, report the achieved rank $r$ and the exact relative Frobenius error computed against the full $K_{IJ}$. For numerical robustness, you may treat a block with $\\lVert K_{IJ} \\rVert_{F} = 0$ as having rank $0$ and error $0$.\n\nUse the following fixed geometric and algorithmic parameters for reproducibility:\n- Sphere radius $a = 1\\,\\mathrm{m}$.\n- Number of points $N = 192$, placed on the sphere by a Fibonacci lattice.\n- Leaf size $s = 24$.\n- Admissibility parameter $\\eta = 0.5$.\n- Distance in meters and wavenumber in radians per meter. The Green’s function uses the same units, but all requested outputs are dimensionless.\n\nFor each test case specified below, construct the geometry and the clustering once, enumerate all admissible far-field blocks $(I,J)$ with $I \\ne J$, and for each block apply ACA with the given threshold $\\varepsilon$. Then, aggregate the far-field block statistics as follows:\n- Compute the average numerical rank $\\bar{r}$ across all admissible blocks, and round it to the nearest integer.\n- Compute the maximum relative Frobenius error $E_{\\max}$ across all admissible blocks.\n\nDesign a program that produces a single line of output containing, for each test case and in the order listed, the rounded average rank followed by the maximum error, all in one flat list. Precisely, if there are $M$ test cases, the output must be a list with $2M$ entries in the form $[r_{1},E_{1},r_{2},E_{2},\\dots,r_{M},E_{M}]$, where each $r_{m}$ is an integer and each $E_{m}$ is a decimal (a floating-point number). The list must be printed in a single line, as a comma-separated list enclosed in square brackets, with no extra text.\n\nTest suite:\n- Case $1$: $k = 2\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-2}$.\n- Case $2$: $k = 2\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-4}$.\n- Case $3$: $k = 8\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-2}$.\n- Case $4$: $k = 8\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-4}$.\n- Case $5$: $k = 16\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-2}$.\n- Case $6$: $k = 16\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-4}$.\n\nAll outputs are dimensionless. Angles, if any, are in radians.\n\nYour program must be complete and runnable, and must require no user input. It must implement the ACA compression and the admissibility-based block selection as described, and it must compute the required aggregated metrics for the specified test suite. The final print statement must produce only the single required line in the format described above.",
            "solution": "The user-provided problem has been analyzed and validated.\n\n### Step 1: Extract Givens\n- **Governing Equation**: Scalar Helmholtz equation, $\\nabla^{2} u + k^{2} u = 0$.\n- **Fundamental Solution**: $G(\\mathbf{x}, \\mathbf{y}) = \\dfrac{\\mathrm{e}^{\\mathrm{i} k \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}}{4 \\pi \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}$.\n- **Matrix Definition**: $K_{ij} = G(\\mathbf{x}_{i}, \\mathbf{x}_{j})$ for $i \\neq j$, and $K_{ii} = 0$.\n- **Geometry**: Sphere with radius $a = 1\\,\\mathrm{m}$.\n- **Discretization**: $N = 192$ points on the sphere via a Fibonacci lattice.\n- **Clustering**: $k$-d tree with recursive splitting of the longest spatial extent.\n- **Leaf Size**: Maximum of $s = 24$ points per leaf cluster.\n- **Cluster Geometry**: Center $\\mathbf{c}_{I}$, radius $r_{I}$ (half the bounding box diagonal).\n- **Cluster Distance**: $d(I,J) = \\max\\left(0, \\lVert \\mathbf{c}_{I} - \\mathbf{c}_{J} \\rVert - (r_{I} + r_{J})\\right)$.\n- **Admissibility**: A pair of clusters $(I,J)$ is admissible if $\\max(r_{I}, r_{J}) \\le \\eta \\, d(I,J)$, with $\\eta = 0.5$.\n- **Compression**: Adaptive Cross Approximation (ACA) to find $K_{IJ} \\approx U V^{\\top}$.\n- **ACA Termination**: Relative Frobenius norm error $\\lVert K_{IJ} - U V^{\\top} \\rVert_{F} / \\lVert K_{IJ} \\rVert_{F} \\le \\varepsilon$ or rank reaches maximum possible.\n- **Robustness**: If $\\lVert K_{IJ} \\rVert_{F} = 0$, rank is $0$ and error is $0$.\n- **Metrics**: For each test case, compute the average rank $\\bar{r}$ (rounded to the nearest integer) and maximum relative Frobenius error $E_{\\max}$ over all admissible blocks $(I,J)$ where $I \\ne J$.\n- **Test Cases ($k$, $\\varepsilon$):**\n    1. ($2\\,\\mathrm{rad/m}$, $10^{-2}$)\n    2. ($2\\,\\mathrm{rad/m}$, $10^{-4}$)\n    3. ($8\\,\\mathrm{rad/m}$, $10^{-2}$)\n    4. ($8\\,\\mathrm{rad/m}$, $10^{-4}$)\n    5. ($16\\,\\mathrm{rad/m}$, $10^{-2}$)\n    6. ($16\\,\\mathrm{rad/m}$, $10^{-4}$)\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is well-grounded in computational electromagnetics and numerical analysis. The Helmholtz equation, Green's functions, hierarchical data structures ($k$-d trees), admissibility conditions, and low-rank approximation methods like ACA are standard tools in fast boundary element methods and H-matrix theory.\n- **Well-Posedness**: The problem is well-posed. All required parameters ($a, N, s, \\eta$), algorithms (Fibonacci lattice, $k$-d tree splitting rule), and objective functions (average rank, maximum error) are specified, ensuring a unique, computable solution. The redundant phrase \"Adaptive Cross Approximation (ACA), meaning Adaptive Cross Approximation (ACA)\" does not introduce ambiguity or contradiction.\n- **Objectivity**: The problem is stated in precise, objective, and quantitative terms, free from subjective or ambiguous language.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It presents a standard, albeit small-scale, numerical experiment in a well-established scientific domain. All components are clearly defined, scientifically correct, and computationally feasible. The solution process can proceed.\n\n### Principle-Based Design\nThe solution is a systematic implementation of the methods used in fast hierarchical solvers for boundary element methods. The core idea is that for two well-separated clusters of points, the interaction matrix block is numerically low-rank. This property is exploited to compress the matrix, reducing memory and computational costs.\n\n**1. Geometric Discretization**\nFirst, the surface of the scatterer—a sphere of radius $a=1\\,\\mathrm{m}$—is discretized into a set of $N=192$ points. To ensure a quasi-uniform distribution, a Fibonacci lattice is employed. For a point index $i \\in [0, N-1]$, the coordinates $(x_i, y_i, z_i)$ on a unit sphere are generated using the golden ratio $\\phi = (1 + \\sqrt{5})/2$. The final coordinates are scaled by the radius $a$.\n\n**2. Hierarchical Spatial Clustering**\nTo efficiently identify well-separated point clusters, the set of $N$ points is hierarchically partitioned using a $k$-d tree. The construction is recursive:\n- A cluster of points is represented by a node in the tree containing the indices of its points.\n- If the number of points in a cluster exceeds the leaf size $s=24$, the cluster is split into two sub-clusters.\n- The split is performed along the dimension of the cluster's axis-aligned bounding box that has the largest extent. Points are partitioned by sorting them along this dimension and dividing them into two equal halves.\n- The recursion terminates when a cluster's point count is less than or equal to $s$, at which point the node becomes a leaf.\nFor each leaf node, we compute and store its bounding box, center $\\mathbf{c}$, and radius $r$ (half the bounding box diagonal).\n\n**3. Admissibility Condition and Far-Field Block Identification**\nThe low-rank property holds for \"far-field\" interactions. The admissibility condition formalizes this separation. For any two leaf clusters, $I$ and $J$, we compute their bounding box radii $r_I, r_J$ and the distance between their bounding boxes, $d(I,J) = \\max\\left(0, \\lVert \\mathbf{c}_{I} - \\mathbf{c}_{J} \\rVert - (r_{I} + r_{J})\\right)$. A pair of clusters $(I,J)$ is deemed admissible (in the far-field) if the size of the larger cluster is small compared to the distance between them: $\\max(r_I, r_J) \\le \\eta \\cdot d(I,J)$. Here, $\\eta=0.5$ is the admissibility parameter. We enumerate all pairs of distinct leaf clusters $(I,J)$ with $I \\neq J$ and collect those that satisfy this condition.\n\n**4. Low-Rank Compression via Adaptive Cross Approximation (ACA)**\nFor each admissible block $K_{IJ}$, we must find a low-rank approximation $K_{IJ} \\approx U V^T$. The problem requires the process to terminate when the exact relative Frobenius norm error, $\\varepsilon_{rel} = \\lVert K_{IJ} - U V^{\\top} \\rVert_{F} / \\lVert K_{IJ} \\rVert_{F}$, falls below a threshold $\\varepsilon$.\n\nGiven that the maximum block size is small ($s \\times s = 24 \\times 24$), an explicit, full-pivoting version of cross approximation is both robust and computationally feasible. This method directly implements the specified error control. The algorithm proceeds as follows for a given block $K_{IJ}$:\n\n1.  Explicitly form the matrix block $K_{IJ}$, where $(K_{IJ})_{pq} = G(\\mathbf{x}_p, \\mathbf{x}_q)$ for $p \\in I, q \\in J$.\n2.  Compute its Frobenius norm, $\\lVert K_{IJ} \\rVert_{F}$. If this norm is zero, the rank is $0$ and the process terminates.\n3.  Initialize an empty approximation ($U$ and $V$ are empty) and a residual matrix $R = K_{IJ}$.\n4.  Iteratively build the rank-$r$ approximation:\n    a. In iteration $r$ (starting at $r=1$), find the entry $(i_r, j_r)$ with the largest absolute value in the current residual matrix $R$. This is the pivot.\n    b. If the pivot value is numerically zero, the residual is effectively zero, and the process stops.\n    c. Define the new column of $U$ as the $j_r$-th column of $R$, and the new row of $V^T$ as the $i_r$-th row of $R$ divided by the pivot value.\n    d. Update the residual by subtracting the rank-1 outer product: $R \\leftarrow R - u_r v_r^T$.\n    e. Construct the current rank-$r$ approximation $A_r = U V^T$.\n    f. Compute the exact relative error $\\lVert K_{IJ} - A_r \\rVert_{F} / \\lVert K_{IJ} \\rVert_{F}$.\n    g. If this error is less than or equal to the threshold $\\varepsilon$, the algorithm terminates.\n5.  The final rank is the number of iterations performed, $r$. The final error is the one computed in the last step.\n\n**5. Aggregation of Results**\nThe procedure is executed for each test case defined by a wavenumber $k$ and a compression threshold $\\varepsilon$. For a given case, we iterate through all previously identified admissible blocks. For each block, we run the ACA compression to determine its numerical rank and the final approximation error. The ranks and errors from all blocks are collected. Finally, we compute the average of all ranks (rounded to the nearest integer) and the maximum of all errors. These two values constitute the result for one test case. The results from all test cases are aggregated into a single list for the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and produce the final output.\n    \"\"\"\n\n    class Node:\n        \"\"\"A node in the k-d tree.\"\"\"\n        def __init__(self, indices, points):\n            self.indices = np.array(indices, dtype=int)\n            self.children = []\n            self.is_leaf = False\n            \n            if not self.indices.size:\n                self.bbox = np.array([0,0,0,0,0,0])\n                self.center = np.zeros(3)\n                self.radius = 0.0\n                return\n\n            node_points = points[self.indices]\n            mins = np.min(node_points, axis=0)\n            maxs = np.max(node_points, axis=0)\n            self.bbox = np.array([mins[0], maxs[0], mins[1], maxs[1], mins[2], maxs[2]])\n            self.center = (mins + maxs) / 2.0\n            \n            diag_vec = maxs - mins\n            self.radius = 0.5 * np.linalg.norm(diag_vec)\n\n    def build_kdtree(points, indices, leaf_size_s):\n        \"\"\"Recursively builds the k-d tree.\"\"\"\n        node = Node(indices, points)\n\n        if len(indices) = leaf_size_s:\n            node.is_leaf = True\n            return node\n\n        dims = node.bbox[1::2] - node.bbox[0::2]\n        split_dim = np.argmax(dims)\n        \n        node_points = points[indices]\n        sorted_indices_map = np.argsort(node_points[:, split_dim])\n        sorted_indices = indices[sorted_indices_map]\n        \n        mid = len(indices) // 2\n        \n        child1_indices = sorted_indices[:mid]\n        child2_indices = sorted_indices[mid:]\n        \n        node.children.append(build_kdtree(points, child1_indices, leaf_size_s))\n        node.children.append(build_kdtree(points, child2_indices, leaf_size_s))\n        \n        return node\n    \n    def get_leaves(node):\n        \"\"\"Traverses the tree to collect all leaf nodes.\"\"\"\n        if node.is_leaf:\n            return [node]\n        leaves = []\n        for child in node.children:\n            leaves.extend(get_leaves(child))\n        return leaves\n\n    def generate_fibonacci_sphere(n_points, radius):\n        \"\"\"Generates points on a sphere using the Fibonacci lattice.\"\"\"\n        points = np.zeros((n_points, 3))\n        phi = (1 + np.sqrt(5)) / 2.  # Golden ratio\n        \n        for i in range(n_points):\n            y = 1 - (2 * i + 1) / n_points\n            r_at_y = np.sqrt(1 - y * y)\n            theta = 2 * np.pi * i / phi\n            \n            x = np.cos(theta) * r_at_y\n            z = np.sin(theta) * r_at_y\n            \n            points[i] = [x, y, z]\n            \n        return points * radius\n\n    def green_function(x, y, k):\n        \"\"\"Computes the scalar Helmholtz Green's function.\"\"\"\n        dist = np.linalg.norm(x - y)\n        if dist  1e-12: # Avoid division by zero, though not expected for i != j\n            return 0.0j\n        return np.exp(1j * k * dist) / (4 * np.pi * dist)\n\n    def aca_compress_and_get_stats(row_indices, col_indices, points, k, epsilon):\n        \"\"\"\n        Performs ACA with full pivoting on an explicit matrix to find rank \n        and computes the exact relative Frobenius error.\n        \"\"\"\n        m, n = len(row_indices), len(col_indices)\n        \n        K_block = np.zeros((m, n), dtype=np.complex128)\n        for i, r_idx in enumerate(row_indices):\n            for j, c_idx in enumerate(col_indices):\n                K_block[i, j] = green_function(points[r_idx], points[c_idx], k)\n\n        norm_K_fro = np.linalg.norm(K_block, 'fro')\n        \n        if norm_K_fro == 0:\n            return 0, 0.0\n\n        R = K_block.copy()\n        U_list, V_list = [], []\n        \n        max_rank = min(m, n)\n        for r in range(max_rank):\n            # Full pivoting: find max element in residual\n            i_p, j_p = np.unravel_index(np.argmax(np.abs(R)), R.shape)\n            pivot = R[i_p, j_p]\n            \n            if abs(pivot)  1e-16 * norm_K_fro:\n                break\n            \n            u_r = R[:, j_p]\n            v_r = R[i_p, :] / pivot\n\n            U_list.append(u_r)\n            V_list.append(v_r)\n            \n            R -= np.outer(u_r, v_r)\n            \n            # Form approximation and check error\n            A_r = np.array(U_list).T @ np.array(V_list)\n            current_error = np.linalg.norm(K_block - A_r, 'fro') / norm_K_fro\n\n            if current_error = epsilon:\n                return r + 1, current_error\n        \n        # If loop finished, calculate final error\n        if U_list:\n            A_final = np.array(U_list).T @ np.array(V_list)\n            final_error = np.linalg.norm(K_block - A_final, 'fro') / norm_K_fro\n            return len(U_list), final_error\n        else:\n            return 0, 1.0\n\n\n    # Fixed geometric and algorithmic parameters\n    a = 1.0  # Sphere radius in meters\n    N = 192  # Number of points\n    s = 24   # Leaf size\n    eta = 0.5 # Admissibility parameter\n    \n    # Test suite\n    test_cases = [\n        (2.0, 1e-2),\n        (2.0, 1e-4),\n        (8.0, 1e-2),\n        (8.0, 1e-4),\n        (16.0, 1e-2),\n        (16.0, 1e-4),\n    ]\n\n    # --- Step 1: Geometry and Clustering (done once) ---\n    points = generate_fibonacci_sphere(N, a)\n    root = build_kdtree(points, np.arange(N), s)\n    leaves = get_leaves(root)\n    \n    # --- Step 2: Enumerate Admissible Blocks (done once) ---\n    admissible_pairs = []\n    for i in range(len(leaves)):\n        for j in range(len(leaves)):\n            if i == j:\n                continue\n            \n            node_I, node_J = leaves[i], leaves[j]\n            \n            dist_centers = np.linalg.norm(node_I.center - node_J.center)\n            dist_boxes = max(0, dist_centers - (node_I.radius + node_J.radius))\n            \n            if max(node_I.radius, node_J.radius) = eta * dist_boxes:\n                admissible_pairs.append((node_I.indices, node_J.indices))\n\n    # --- Step 3: Run test suite ---\n    final_results = []\n    for k, epsilon in test_cases:\n        ranks = []\n        errors = []\n        \n        if not admissible_pairs: # Should not happen for these params\n             final_results.extend([0, 0.0])\n             continue\n\n        for row_indices, col_indices in admissible_pairs:\n            rank, error = aca_compress_and_get_stats(row_indices, col_indices, points, k, epsilon)\n            ranks.append(rank)\n            errors.append(error)\n        \n        avg_rank = np.mean(ranks) if ranks else 0\n        max_error = np.max(errors) if errors else 0.0\n        \n        # Round average rank to the nearest integer\n        rounded_avg_rank = int(round(avg_rank))\n        \n        final_results.extend([rounded_avg_rank, max_error])\n        \n    # --- Final Print ---\n    # Formatting the output to match the required single-line list format.\n    formatted_results = []\n    for i, res in enumerate(final_results):\n        if i % 2 == 0:  # Rank is an integer\n            formatted_results.append(str(res))\n        else:  # Error is a float\n            formatted_results.append(f\"{res:.15g}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}