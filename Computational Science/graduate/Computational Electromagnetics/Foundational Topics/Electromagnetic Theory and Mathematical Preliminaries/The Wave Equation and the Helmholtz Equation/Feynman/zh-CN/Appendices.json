{
    "hands_on_practices": [
        {
            "introduction": "时域有限差分（FDTD）法是直接在时间和空间上求解麦克斯韦方程组的强大工具。然而，将连续的时空离散化会引入数值误差，其中最关键的一种是数值色散。本练习将引导您深入探讨这一现象，即在离散网格中，波的相速度会依赖于其频率、传播方向和网格分辨率。通过从第一性原理推导并计算数值相速度误差，您将掌握评估和控制FDTD仿真精度的核心技能。",
            "id": "3354598",
            "problem": "考虑一个二维均匀、各向同性的无源介质，其特性由介电常数 $\\epsilon$ 和磁导率 $\\mu$ 描述。从麦克斯韦方程组和本构关系出发，可以得到电磁场的波动方程。在均匀笛卡尔网格中，标准 Yee 格式在 Courant-Friedrichs-Lewy (CFL) 稳定性极限下，使用具有网格步长 $\\Delta x$ 和 $\\Delta y$ 的交错空间采样以及交错时间步长 $\\Delta t$。对于在 $x$-$y$ 平面内以斜角传播的平面波，Yee 格式的数值色散关系将角频率 $\\omega$ 与波数分量 $k_x$ 和 $k_y$ 联系起来。\n\n您的任务是：\n- 从第一性原理出发，通过将平面波拟设应用于均匀介质的离散更新方程，推导出 Yee 格式的数值色散关系。然后，对于给定的传播角，用波数大小 $k$ 和角度来定义 $k_x$ 和 $k_y$，并利用色散关系计算 $\\omega$。\n- 使用色散关系计算数值相速度 $v_{\\mathrm{p,num}}=\\omega/k$，其中 $k=\\sqrt{k_x^2+k_y^2}$，并将其与同一介质中连续平面波的精确相速度 $c=1/\\sqrt{\\mu\\epsilon}$ 进行比较。以 $\\mathrm{m/s}$ 为单位，报告绝对相速度误差 $e=v_{\\mathrm{p,num}}-c$，并表示为小数（而非百分比）。\n- 实现一个程序，对下面的每个测试用例，使用从二维 Yee 数值色散关系得到的 $\\omega$ 来计算绝对相速度误差 $e$。角度使用度作为单位。\n\n使用以下测试套件。每个用例由 $(\\Delta x,\\Delta y,\\Delta t,\\phi,\\lambda,\\mu,\\epsilon)$ 指定，单位为 $(\\mathrm{m},\\mathrm{m},\\mathrm{s},\\text{度},\\mathrm{m},\\mathrm{H/m},\\mathrm{F/m})$：\n1. $\\Delta x=1\\times 10^{-3}$, $\\Delta y=1\\times 10^{-3}$, $\\Delta t=0.98\\cdot \\dfrac{\\Delta x}{\\sqrt{2}c_0}$, $\\phi=30^\\circ$, $ \\lambda=1\\times 10^{-2}$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$，其中 $\\mu_0=4\\pi\\times 10^{-7}$ 且 $\\epsilon_0=8.854187817\\times 10^{-12}$，以及 $c_0=1/\\sqrt{\\mu_0\\epsilon_0}$。\n2. $\\Delta x=5\\times 10^{-4}$, $\\Delta y=1\\times 10^{-3}$, $\\Delta t=0.85\\cdot \\left(\\dfrac{1}{c_0\\sqrt{\\dfrac{1}{\\Delta x^2}+\\dfrac{1}{\\Delta y^2}}}\\right)$, $\\phi=60^\\circ$, $ \\lambda=5\\times 10^{-3}$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$。\n3. $\\Delta x=1\\times 10^{-3}$, $\\Delta y=1\\times 10^{-3}$, $\\Delta t=0.5\\cdot \\dfrac{\\Delta x}{\\sqrt{2}c_0}$, $\\phi=0^\\circ$, $ \\lambda=2.5\\times \\Delta x$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$。\n4. $\\Delta x=2\\times 10^{-3}$, $\\Delta y=2\\times 10^{-3}$, $\\Delta t=0.5\\cdot \\dfrac{\\Delta x}{\\sqrt{2}c_0}$, $\\phi=45^\\circ$, $ \\lambda=4\\times \\Delta x$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$。\n5. $\\Delta x=1.5\\times 10^{-3}$, $\\Delta y=7.5\\times 10^{-4}$, $\\Delta t=0.9\\cdot \\left(\\dfrac{1}{c^\\star\\sqrt{\\dfrac{1}{\\Delta x^2}+\\dfrac{1}{\\Delta y^2}}}\\right)$, $\\phi=20^\\circ$, $ \\lambda=6\\times 10^{-3}$, $\\mu=\\mu_0$, $\\epsilon=4\\epsilon_0$，以及该介质的 $c^\\star=1/\\sqrt{\\mu\\epsilon}$。\n\n对每个用例：\n- 计算精确相速度 $c=1/\\sqrt{\\mu\\epsilon}$。\n- 计算波数大小 $k=2\\pi/\\lambda$ 和分量 $k_x=k\\cos(\\phi)$ 和 $k_y=k\\sin(\\phi)$，其中 $\\phi$ 以度为单位。\n- 求解二维 Yee 数值色散关系以得到 $\\omega$，并计算 $v_{\\mathrm{p,num}}=\\omega/k$。\n- 报告以 $\\mathrm{m/s}$ 为单位的绝对相速度误差 $e=v_{\\mathrm{p,num}}-c$。\n\n您的程序应生成单行输出，其中包含五个测试用例的结果，形式为方括号括起来的逗号分隔列表，例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$，其中每个 $\\text{result}_i$ 是第 $i$ 个用例计算出的误差 $e$，单位为 $\\mathrm{m/s}$。",
            "solution": "该问题要求推导二维 Yee 时域有限差分 (FDTD) 格式的数值色散关系，并应用该关系计算几个测试用例的数值相速度误差。\n\n让我们从第一性原理开始。在均匀、各向同性、无源介质中，电磁波的传播由麦克斯韦旋度方程组决定：\n$$ \\nabla \\times \\mathbf{E} = -\\frac{\\partial \\mathbf{B}}{\\partial t} $$\n$$ \\nabla \\times \\mathbf{H} = \\frac{\\partial \\mathbf{D}}{\\partial t} $$\n结合线性本构关系 $\\mathbf{D} = \\epsilon \\mathbf{E}$ 和 $\\mathbf{B} = \\mu \\mathbf{H}$，其中 $\\epsilon$ 是介质的介电常数，$\\mu$ 是介质的磁导率，方程组变为：\n$$ \\nabla \\times \\mathbf{E} = -\\mu \\frac{\\partial \\mathbf{H}}{\\partial t} \\quad (1) $$\n$$ \\nabla \\times \\mathbf{H} = \\epsilon \\frac{\\partial \\mathbf{E}}{\\partial t} \\quad (2) $$\n对于 $x$-$y$ 平面中的二维问题，我们可以考虑横磁 ($TM_z$) 模，其唯一的非零场分量是 $E_z$、$H_x$ 和 $H_y$。矢量方程 $(1)$ 和 $(2)$ 分解为以下三个标量方程组：\n$$ \\frac{\\partial E_z}{\\partial y} = -\\mu \\frac{\\partial H_x}{\\partial t} \\quad (3) $$\n$$ -\\frac{\\partial E_z}{\\partial x} = \\mu \\frac{\\partial H_y}{\\partial t} \\quad (4) $$\n$$ \\frac{\\partial H_y}{\\partial x} - \\frac{\\partial H_x}{\\partial y} = \\epsilon \\frac{\\partial E_z}{\\partial t} \\quad (5) $$\n\nYee FDTD 格式在交错网格上对这些方程进行离散化。场分量 $F(x,y,t)$ 表示为 $F^n(i,j) = F(i\\Delta x, j\\Delta y, n\\Delta t)$。$TM_z$ 模各分量在空间和时间上的交错配置如下：\n- $E_z$ 在网格点 $(i\\Delta x, j\\Delta y)$ 和时间步 $n\\Delta t$ 上计算。\n- $H_x$ 在 $(i\\Delta x, (j+1/2)\\Delta y)$ 和时间步 $(n+1/2)\\Delta t$ 上计算。\n- $H_y$ 在 $((i+1/2)\\Delta x, j\\Delta y)$ 和时间步 $(n+1/2)\\Delta t$ 上计算。\n\n对方程 $(3)-(5)$ 应用中心有限差分，得到 Yee 更新方程：\n$$ \\frac{E_z^n(i, j+1) - E_z^n(i, j)}{\\Delta y} = -\\mu \\frac{H_x^{n+1/2}(i, j+1/2) - H_x^{n-1/2}(i, j+1/2)}{\\Delta t} \\quad (6) $$\n$$ \\frac{E_z^n(i+1, j) - E_z^n(i, j)}{\\Delta x} = \\mu \\frac{H_y^{n+1/2}(i+1/2, j) - H_y^{n-1/2}(i+1/2, j)}{\\Delta t} \\quad (7) $$\n$$ \\frac{H_y^{n+1/2}(i+1/2, j) - H_y^{n+1/2}(i-1/2, j)}{\\Delta x} - \\frac{H_x^{n+1/2}(i, j+1/2) - H_x^{n+1/2}(i, j-1/2)}{\\Delta y} = \\epsilon \\frac{E_z^{n+1}(i, j) - E_z^n(i, j)}{\\Delta t} \\quad (8) $$\n\n为了找到数值色散关系，我们在离散网格上假设一个平面波解（拟设）。对于角频率为 $\\omega$、波矢分量为 $k_x$ 和 $k_y$ 的波，其场分量为：\n$$ E_z^n(i,j) = E_{z0} e^{\\mathrm{j}(k_x i\\Delta x + k_y j\\Delta y - \\omega n\\Delta t)} $$\n$$ H_x^{n+1/2}(i,j+1/2) = H_{x0} e^{\\mathrm{j}(k_x i\\Delta x + k_y (j+1/2)\\Delta y - \\omega (n+1/2)\\Delta t)} $$\n$$ H_y^{n+1/2}(i+1/2,j) = H_{y0} e^{\\mathrm{j}(k_x (i+1/2)\\Delta x + k_y j\\Delta y - \\omega (n+1/2)\\Delta t)} $$\n其中 $E_{z0}$、$H_{x0}$ 和 $H_{y0}$ 是复振幅。将这些表达式代入更新方程，可以求解 $\\omega$、$k_x$ 和 $k_y$ 之间的关系。\n\n根据方程 $(6)$：\n$$ E_{z0} \\frac{e^{\\mathrm{j}k_y\\Delta y} - 1}{\\Delta y} = -\\mu H_{x0} e^{\\mathrm{j}k_y\\Delta y/2} \\frac{e^{-\\mathrm{j}\\omega\\Delta t/2} - e^{\\mathrm{j}\\omega\\Delta t/2}}{\\Delta t} $$\n使用恒等式 $e^{\\mathrm{j}\\theta}-1=e^{\\mathrm{j}\\theta/2}(2\\mathrm{j}\\sin(\\theta/2))$，方程简化为：\n$$ \\frac{E_{z0}}{\\Delta y} e^{\\mathrm{j}k_y\\Delta y/2} (2\\mathrm{j}\\sin(k_y\\Delta y/2)) = \\mu \\frac{H_{x0}}{\\Delta t} e^{\\mathrm{j}k_y\\Delta y/2} (2\\mathrm{j}\\sin(\\omega\\Delta t/2)) $$\n$$ H_{x0} = \\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta y} \\frac{\\sin(k_y\\Delta y/2)}{\\sin(\\omega\\Delta t/2)} \\quad (9) $$\n\n根据方程 $(7)$：\n$$ E_{z0} \\frac{e^{\\mathrm{j}k_x\\Delta x} - 1}{\\Delta x} = \\mu H_{y0} e^{\\mathrm{j}k_x\\Delta x/2} \\frac{e^{-\\mathrm{j}\\omega\\Delta t/2} - e^{\\mathrm{j}\\omega\\Delta t/2}}{\\Delta t} $$\n$$ \\frac{E_{z0}}{\\Delta x} e^{\\mathrm{j}k_x\\Delta x/2} (2\\mathrm{j}\\sin(k_x\\Delta x/2)) = -\\mu \\frac{H_{y0}}{\\Delta t} e^{\\mathrm{j}k_x\\Delta x/2} (2\\mathrm{j}\\sin(\\omega\\Delta t/2)) $$\n$$ H_{y0} = -\\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta x} \\frac{\\sin(k_x\\Delta x/2)}{\\sin(\\omega\\Delta t/2)} \\quad (10) $$\n\n最后，将拟设代入方程 $(8)$：\n$$ \\frac{H_{y0}}{\\Delta x} (2\\mathrm{j}\\sin(k_x\\Delta x/2)) - \\frac{H_{x0}}{\\Delta y} (2\\mathrm{j}\\sin(k_y\\Delta y/2)) = \\epsilon \\frac{E_{z0}}{\\Delta t} (-2\\mathrm{j}\\sin(\\omega\\Delta t/2)) $$\n现在，代入由 $(9)$ 和 $(10)$ 给出的 $H_{x0}$ 和 $H_{y0}$ 的表达式：\n$$ \\frac{1}{\\Delta x} \\left(-\\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta x} \\frac{\\sin(k_x\\Delta x/2)}{\\sin(\\omega\\Delta t/2)}\\right)\\sin(k_x\\Delta x/2) - \\frac{1}{\\Delta y}\\left(\\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta y} \\frac{\\sin(k_y\\Delta y/2)}{\\sin(\\omega\\Delta t/2)}\\right)\\sin(k_y\\Delta y/2) = -\\frac{\\epsilon E_{z0}}{\\Delta t}\\sin(\\omega\\Delta t/2) $$\n两边同除以 $-E_{z0}$ 并重新整理可得：\n$$ \\frac{\\Delta t}{\\mu \\sin(\\omega\\Delta t/2)}\\left(\\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_y\\Delta y/2)}{\\Delta y^2}\\right) = \\frac{\\epsilon}{\\Delta t}\\sin(\\omega\\Delta t/2) $$\n将各项相乘并使用介质中光速的关系式 $c=1/\\sqrt{\\mu\\epsilon}$，我们便得到二维 Yee 格式的数值色散关系：\n$$ \\left(\\frac{1}{\\Delta x}\\sin\\left(\\frac{k_x\\Delta x}{2}\\right)\\right)^2 + \\left(\\frac{1}{\\Delta y}\\sin\\left(\\frac{k_y\\Delta y}{2}\\right)\\right)^2 = \\left(\\frac{1}{c\\Delta t}\\sin\\left(\\frac{\\omega\\Delta t}{2}\\right)\\right)^2 $$\n\n为计算数值相速度，我们首先求解数值角频率 $\\omega$：\n$$ \\sin\\left(\\frac{\\omega\\Delta t}{2}\\right) = c\\Delta t \\sqrt{\\left(\\frac{\\sin(k_x\\Delta x/2)}{\\Delta x}\\right)^2 + \\left(\\frac{\\sin(k_y\\Delta y/2)}{\\Delta y}\\right)^2} $$\n$$ \\omega = \\frac{2}{\\Delta t}\\arcsin\\left(c\\Delta t \\sqrt{\\left(\\frac{\\sin(k_x\\Delta x/2)}{\\Delta x}\\right)^2 + \\left(\\frac{\\sin(k_y\\Delta y/2)}{\\Delta y}\\right)^2}\\right) $$\n数值相速度 $v_{\\mathrm{p,num}}$ 定义为该数值角频率 $\\omega$ 与连续空间波数大小 $k=\\sqrt{k_x^2+k_y^2}$ 的比值：\n$$ v_{\\mathrm{p,num}} = \\frac{\\omega}{k} $$\n绝对相速度误差 $e$ 是数值相速度与连续介质中精确相速度 $c$ 之间的差值：\n$$ e = v_{\\mathrm{p,num}} - c $$\n\n对每个测试用例，执行以下步骤：\n1. 定义常数 $\\mu_0=4\\pi\\times 10^{-7} \\, \\mathrm{H/m}$ 和 $\\epsilon_0=8.854187817\\times 10^{-12} \\, \\mathrm{F/m}$。\n2. 对于给定的测试用例 $(\\Delta x, \\Delta y, \\Delta t, \\phi, \\lambda, \\mu, \\epsilon)$:\n    a. 计算精确相速度 $c=1/\\sqrt{\\mu\\epsilon}$。\n    b. 计算波数大小 $k = 2\\pi/\\lambda$。\n    c. 将传播角 $\\phi$ 从度转换为弧度。\n    d. 计算波数分量 $k_x=k\\cos(\\phi)$ 和 $k_y=k\\sin(\\phi)$。\n    e. 将所有值代入推导出的 $\\omega$ 方程中。\n    f. 计算数值相速度 $v_{\\mathrm{p,num}}=\\omega/k$。\n    g. 计算绝对误差 $e = v_{\\mathrm{p,num}} - c$。\n对所有五个给定的测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerical phase velocity error for the 2D Yee FDTD scheme\n    for a set of test cases.\n    \"\"\"\n    \n    # Define physical constants from the problem statement\n    mu_0 = 4 * np.pi * 1e-7  # H/m\n    epsilon_0 = 8.854187817e-12  # F/m\n    c_0 = 1 / np.sqrt(mu_0 * epsilon_0)\n\n    # Test cases: (dx, dy, dt_spec, phi_deg, lam_spec, mu_r, eps_r)\n    # dt_spec = (factor, type, c_ref_str)\n    #   type: 'iso' for dx=dy, 'aniso' for dx!=dy\n    #   c_ref_str: 'c0' for vacuum speed, 'c_medium' for material speed\n    # lam_spec = (type, value) where type can be 'abs' or 'rel' to dx\n    test_cases = [\n        (1e-3, 1e-3, (0.98, 'iso', 'c0'), 30, ('abs', 1e-2), 1.0, 1.0),\n        (5e-4, 1e-3, (0.85, 'aniso', 'c0'), 60, ('abs', 5e-3), 1.0, 1.0),\n        (1e-3, 1e-3, (0.5, 'iso', 'c0'), 0, ('rel', 2.5), 1.0, 1.0),\n        (2e-3, 2e-3, (0.5, 'iso', 'c0'), 45, ('rel', 4.0), 1.0, 1.0),\n        (1.5e-3, 7.5e-4, (0.9, 'aniso', 'c_medium'), 20, ('abs', 6e-3), 1.0, 4.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        dx, dy, dt_spec, phi_deg, lam_spec, mu_r, eps_r = case\n        \n        # Unpack specifications\n        dt_factor, dt_type, c_ref_str = dt_spec\n        lam_type, lam_val = lam_spec\n\n        # 1. Calculate medium properties and exact phase velocity\n        mu = mu_r * mu_0\n        epsilon = eps_r * epsilon_0\n        c = 1 / np.sqrt(mu * epsilon)\n        \n        # 2. Calculate time step dt\n        if c_ref_str == 'c0':\n            c_ref_for_dt = c_0\n        else: # 'c_medium'\n            c_ref_for_dt = c\n\n        if dt_type == 'iso':\n            dt = dt_factor * dx / (np.sqrt(2) * c_ref_for_dt)\n        else: # 'aniso'\n            dt = dt_factor / (c_ref_for_dt * np.sqrt(1/dx**2 + 1/dy**2))\n\n        # 3. Calculate wavelength and wavenumber\n        if lam_type == 'rel':\n            lam = lam_val * dx\n        else: # 'abs'\n            lam = lam_val\n\n        k = 2 * np.pi / lam\n        phi_rad = np.deg2rad(phi_deg)\n        kx = k * np.cos(phi_rad)\n        ky = k * np.sin(phi_rad)\n\n        # 4. Solve numerical dispersion relation for omega\n        term_x = (np.sin(kx * dx / 2) / dx)**2\n        term_y = (np.sin(ky * dy / 2) / dy)**2\n        \n        arcsin_arg = c * dt * np.sqrt(term_x + term_y)\n        \n        # The argument must be = 1 for a stable scheme\n        if arcsin_arg  1.0 and not np.isclose(arcsin_arg, 1.0):\n             # This should not happen for the given stable test cases\n             raise ValueError(f\"FDTD scheme is unstable. arcsin argument  1: {arcsin_arg}\")\n        if arcsin_arg  1.0: # Clamp for floating point inaccuracies\n             arcsin_arg = 1.0\n        \n        omega = (2 / dt) * np.arcsin(arcsin_arg)\n\n        # 5. Compute numerical phase velocity and error\n        v_p_num = omega / k\n        error = v_p_num - c\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "转换到频域，边界积分方程（BIE）方法为求解开放区域中的辐射和散射问题提供了极高的效率，因为它仅需在物体表面进行离散。尽管这种方法非常简洁，但它存在一个被称为“内部共振”的严重问题，即在特定频率下数值公式会失效。本练习将通过一个经典的球体散射案例，让您分析不同积分方程形式（EFIE、MFIE和CFIE）的谱特性和条件数。您将亲手验证为何组合场积分方程（CFIE）能够克服共振问题，从而成为稳健计算的关键。",
            "id": "3354579",
            "problem": "考虑三维空间中时谐场的齐次亥姆霍兹方程，对于一个复值标量场，其形式为 $$\\nabla^2 u(\\mathbf{x}) + k^2 u(\\mathbf{x}) = 0,$$ 其中 $k$ 是波数。自由空间亥姆霍兹格林函数为 $$G(\\mathbf{x},\\mathbf{y}) = \\frac{e^{ik|\\mathbf{x}-\\mathbf{y}|}}{4\\pi |\\mathbf{x}-\\mathbf{y}|}。$$ 在一个光滑闭合曲面 $\\Gamma$ 上，经典的边界积分算子包括单层算子 $$\\mathcal{S}[\\rho](\\mathbf{x}) = \\int_{\\Gamma} G(\\mathbf{x},\\mathbf{y}) \\rho(\\mathbf{y}) \\,\\mathrm{d}S_{\\mathbf{y}},$$ 和双层算子 $$\\mathcal{K}[\\rho](\\mathbf{x}) = \\int_{\\Gamma} \\frac{\\partial G(\\mathbf{x},\\mathbf{y})}{\\partial n_{\\mathbf{y}}} \\rho(\\mathbf{y}) \\,\\mathrm{d}S_{\\mathbf{y}},$$ 其中 $\\partial/\\partial n_{\\mathbf{y}}$ 表示在点 $\\mathbf{y} \\in \\Gamma$ 处沿外法线方向的导数。双层势在 $\\Gamma$ 上的外极限存在跳跃关系，通常写作 $\\left(-\\frac{1}{2}\\mathcal{I} + \\mathcal{K}\\right)[\\rho]$，其中 $\\mathcal{I}$ 表示单位算子。在计算电磁学中，对于完美电导体散射体，通常使用电场积分方程（EFIE）、磁场积分方程（MFIE）和组合场积分方程（CFIE）来施加边界条件。在适用于条件数分析的标量亥姆霍兹类似问题中，EFIE 对应于单层方程，MFIE 对应于第二类双层方程，而 CFIE 对应于两者的线性组合。\n\n设 $\\Gamma$ 是一个以原点为中心、半径为 $a$ 的球面。利用球谐函数，算子 $\\mathcal{S}$ 和 $\\mathcal{K}$ 可被球面上的球谐函数 $Y_{\\ell m}(\\hat{\\mathbf{x}})$ 对角化，其中 $\\ell \\in \\mathbb{N}_0$ 且 $-\\ell \\le m \\le \\ell$。令 $x = ka$ 为无量纲尺寸参数。定义第一类球贝塞尔函数 $j_{\\ell}(x)$ 和第一类球汉克尔函数 $h_{\\ell}^{(1)}(x) = j_{\\ell}(x) + i y_{\\ell}(x)$，其中 $y_{\\ell}(x)$ 是第二类球贝塞尔函数。记 $h_{\\ell}^{(1)\\prime}(x)$ 为 $h_{\\ell}^{(1)}(x)$ 对其自变量 $x$ 的导数。\n\n当密度为球谐函数 $Y_{\\ell m}$ 时，单层算子的作用为 $$\\mathcal{S}[Y_{\\ell m}] = \\lambda_{\\ell}^{\\mathcal{S}} \\, Y_{\\ell m}, \\quad \\lambda_{\\ell}^{\\mathcal{S}} = \\frac{a x}{i} \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x)。$$ 主值双层算子的贡献为 $$\\mathcal{K}[Y_{\\ell m}] = \\lambda_{\\ell}^{\\mathcal{K}} \\, Y_{\\ell m}, \\quad \\lambda_{\\ell}^{\\mathcal{K}} = \\frac{x^2}{i} \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)\\prime}(x),$$ 而 MFIE 算子的特征值为 $$\\mu_{\\ell}^{\\text{MFIE}} = -\\frac{1}{2} + \\lambda_{\\ell}^{\\mathcal{K}}。$$ 一个无量纲 CFIE 算子可以构造成 $$\\nu_{\\ell}^{\\text{CFIE}} = \\alpha \\, \\mu_{\\ell}^{\\text{MFIE}} + \\eta \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x),$$ 其中 $\\alpha \\in (0,1)$ 和 $\\eta  0$ 是耦合参数。对于一个截断到 $\\ell_{\\max}$ 阶的球谐函数展开，定义每个算子的条件（条件数）为 $$\\kappa(\\mathcal{O}) = \\frac{\\max_{0 \\le \\ell \\le \\ell_{\\max}} |\\lambda_{\\ell}(\\mathcal{O})|}{\\min_{0 \\le \\ell \\le \\ell_{\\max}} |\\lambda_{\\ell}(\\mathcal{O})|},$$ 其中 $\\lambda_{\\ell}(\\mathcal{O})$ 是算子 $\\mathcal{O}$ 作用于 $Y_{\\ell m}$ 上的特征值，且最小值是在所有严格为正的模值上取得，以避免在任何特征值数值上为零时出现除以零的情况。这个 $\\kappa$ 为截断离散系统的条件数提供了一个代理指标。\n\n任务：实现一个程序，该程序：\n- 对于给定的球半径 $a$ 和尺寸参数 $x = k a$，计算 $\\ell = 0,1,\\dots,\\ell_{\\max}$（其中 $\\ell_{\\max} = \\lceil x \\rceil + 8$）对应的特征值 $\\lambda_{\\ell}^{\\mathcal{S}}$、$\\mu_{\\ell}^{\\text{MFIE}}$ 和 $\\nu_{\\ell}^{\\text{CFIE}}$。\n- 通过取 $\\ell = 0,\\dots,\\ell_{\\max}$ 范围内最大与最小非零绝对特征值之比，计算条件数 $\\kappa(\\mathcal{S})$、$\\kappa(\\text{MFIE})$ 和 $\\kappa(\\text{CFIE})$。\n- 使用以下参数集测试套件，其涵盖了小 $x$、中等 $x$、近谐振 $x$ 和大 $x$ 的情况：\n    1. $a = 1$ 米, $x = 0.1$, $\\alpha = 0.5$, $\\eta = 0.7$。\n    2. $a = 1$ 米, $x = 1.0$, $\\alpha = 0.5$, $\\eta = 0.7$。\n    3. $a = 1$ 米, $x = 3.1415926535$, $\\alpha = 0.5$, $\\eta = 0.7$。\n    4. $a = 1$ 米, $x = 6.0$, $\\alpha = 0.5$, $\\eta = 0.7$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是按 $[\\kappa(\\mathcal{S}), \\kappa(\\text{MFIE}), \\kappa(\\text{CFIE})]$ 顺序排列的三个浮点数列表。因此，最终输出格式必须是类似 `[[kS1,kM1,kC1],[kS2,kM2,kC2],[kS3,kM3,kC3],[kS4,kM4,kC4]]` 的单行。输出中不需要物理单位；所有条件数都是无量纲的。",
            "solution": "该问题经评估有效。它在科学上是合理的，提法恰当，并为获得唯一解提供了完整且一致的定义和数据。问题陈述基于计算电磁学的既定原理以及亥姆霍兹方程的边界积分方程理论。任务是对三种常见积分方程公式在球面上的条件数进行数值分析，这是该领域一个标准且富有洞察力的练习。\n\n这个问题的核心是分析与球面上亥姆霍兹方程相关的边界积分算子的谱特性。这些算子可被球谐函数 $Y_{\\ell m}$ 对角化，从而将分析算子的问题简化为分析其特征值 $\\lambda_{\\ell}$。条件数定义为最大与最小非零特征值模值之比，可作为基于这些算子的离散化系统数值稳定性的一个代理指标。大的条件数表明相应的线性系统是病态的，对微小扰动敏感，这可能导致数值解出现较大误差。\n\n对于每个给定的测试用例 $(a, x, \\alpha, \\eta)$，解决问题的总体步骤如下：\n\n1.  **确定截断阶数**：球谐函数展开必须在足够高的阶数处截断，以捕捉解的振荡特性。问题给出了经验法则 $\\ell_{\\max} = \\lceil x \\rceil + 8$，其中 $x = ka$ 是无量纲尺寸参数。计算将针对从 $0$ 到 $\\ell_{\\max}$ 的整数阶 $\\ell$ 进行。\n\n2.  **计算特殊函数**：特征值表达式依赖于第一类球贝塞尔函数 $j_{\\ell}(x)$、第一类球汉克尔函数 $h_{\\ell}^{(1)}(x)$ 及其导数 $h_{\\ell}^{(1)\\prime}(x)$。汉克尔函数定义为 $h_{\\ell}^{(1)}(x) = j_{\\ell}(x) + i y_{\\ell}(x)$，其中 $y_{\\ell}(x)$ 是第二类球贝塞尔函数，$i$ 是虚数单位。对于给定的 $x$ 和每个所需的阶数 $\\ell \\in \\{0, 1, \\dots, \\ell_{\\max}\\}$，计算这些函数的值。导数（如 $h_{\\ell}^{(1)\\prime}(x)$）是关于自变量 $x$ 的导数。这些计算可以通过标准的科学计算库（如 Python 中的 `scipy.special`）高效而准确地完成，该库为这些函数及其导数提供了例程。\n\n3.  **计算特征值**：在计算出特殊函数后，为每个算子和每个 $\\ell \\in \\{0, 1, \\dots, \\ell_{\\max}\\}$ 计算特征值。\n    -   **单层（EFIE 类似物）**：特征值由公式 $\\lambda_{\\ell}^{\\mathcal{S}} = \\frac{a x}{i} \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x) = -i a x \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x)$ 给出。已知当 $x$ 接近任意 $j_{\\ell}(x)$ 的零点时，该算子的条件数很差，这对应于球体的内部 Dirichlet 谐振。\n    -   **MFIE 类似物**：第二类双层算子的特征值为 $\\mu_{\\ell}^{\\text{MFIE}} = -\\frac{1}{2} + \\lambda_{\\ell}^{\\mathcal{K}}$，其中 $\\lambda_{\\ell}^{\\mathcal{K}} = \\frac{x^2}{i} \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)\\prime}(x) = -i x^2 \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)\\prime}(x)$。该公式同样会遇到病态条件问题，尽管是在一组不同的谐振频率上（对应于内部 Neumann 谐振）。当 $j_{\\ell}(x) = 0$ 时，特征值 $\\mu_{\\ell}^{\\text{MFIE}}$ 恰好变为 $-1/2$ 而不会消失，这是相对于 EFIE 的一个优点。\n    -   **CFIE 类似物**：组合场公式的特征值为 $\\nu_{\\ell}^{\\text{CFIE}} = \\alpha \\, \\mu_{\\ell}^{\\text{MFIE}} + \\eta \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x)$。构建这种线性组合是为了规避谐振问题。当谐振导致一个算子中的项出现问题时（例如 $j_{\\ell}(x) \\approx 0$），组合中的另一项仍然表现良好，确保最终的特征值 $\\nu_{\\ell}^{\\text{CFIE}}$ 不会消失。例如，如果 $j_{\\ell}(x) = 0$，则 $\\mu_{\\ell}^{\\text{MFIE}} = -1/2$，而项 $\\eta \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x)$ 消失，导致 $\\nu_{\\ell}^{\\text{CFIE}} = -\\alpha/2$。由于 $\\alpha \\in (0,1)$，此特征值为非零，证明了该公式对这种特定谐振的鲁棒性。\n\n4.  **计算条件数**：对于三个算子 $\\mathcal{O} \\in \\{\\mathcal{S}, \\text{MFIE}, \\text{CFIE}\\}$ 中的每一个，都得到一组特征值 $\\{\\lambda_0(\\mathcal{O}), \\dots, \\lambda_{\\ell_{\\max}}(\\mathcal{O})\\}$。然后根据以下公式计算条件数：\n    $$ \\kappa(\\mathcal{O}) = \\frac{\\max_{0 \\le \\ell \\le \\ell_{\\max}} |\\lambda_{\\ell}(\\mathcal{O})|}{\\min_{0 \\le \\ell \\le \\ell_{\\max}, |\\lambda_{\\ell}(\\mathcal{O})|0} |\\lambda_{\\ell}(\\mathcal{O})|} $$\n    这包括取所有计算出的特征值的绝对值，滤除任何为零的值，然后计算剩余正模值的最大值与最小值之比。\n\n对四个指定的测试用例中的每一个都重复执行此完整过程。结果将定量地展示 CFIE 公式相比于 EFIE 和 MFIE 的优越条件数，尤其是在 $x \\approx \\pi$ 的测试用例中，该值接近 $j_1(x)$ 的一个零点，这是球体的一个已知谐振点。尽管所用的参数为 $a=1$，但对于无量纲算子，最终的条件数与该选择无关。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn, spherical_yn\n\ndef solve():\n    \"\"\"\n    Computes and compares the condition numbers of scalar EFIE, MFIE, and CFIE\n    analogs for scattering from a sphere.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, x, alpha, eta)\n        (1.0, 0.1, 0.5, 0.7),\n        (1.0, 1.0, 0.5, 0.7),\n        (1.0, 3.1415926535, 0.5, 0.7),\n        (1.0, 6.0, 0.5, 0.7),\n    ]\n\n    results = []\n    for a, x, alpha, eta in test_cases:\n        # Step 1: Determine the truncation degree l_max\n        l_max = int(np.ceil(x)) + 8\n        l_range = np.arange(0, l_max + 1)\n\n        # Step 2: Evaluate special functions j_l(x), y_l(x), and their derivatives\n        # h_l^(1)(x) = j_l(x) + i * y_l(x)\n        # scipy.special functions are vectorized, so they compute for all l in l_range at once.\n        jl_x = spherical_jn(l_range, x)\n        yl_x = spherical_yn(l_range, x)\n        \n        # Derivatives with respect to the argument x\n        jl_x_prime = spherical_jn(l_range, x, derivative=True)\n        yl_x_prime = spherical_yn(l_range, x, derivative=True)\n\n        h1l_x = jl_x + 1j * yl_x\n        h1l_x_prime = jl_x_prime + 1j * yl_x_prime\n\n        # Step 3: Compute eigenvalues for each operator\n        \n        # Eigenvalues for single-layer operator (S)\n        # lambda_l^S = (a*x/i) * j_l(x) * h_l^(1)(x) = -i*a*x*j_l*h_l\n        lambda_S = -1j * a * x * jl_x * h1l_x\n        \n        # Eigenvalues for double-layer operator (K)\n        # lambda_l^K = (x^2/i) * j_l(x) * h_l^(1)'(x) = -i*x^2*j_l*h_l'\n        lambda_K = -1j * x**2 * jl_x * h1l_x_prime\n        \n        # Eigenvalues for MFIE operator\n        # mu_l^MFIE = -1/2 + lambda_l^K\n        mu_MFIE = -0.5 + lambda_K\n        \n        # Eigenvalues for CFIE operator\n        # nu_l^CFIE = alpha * mu_l^MFIE + eta * j_l(x) * h_l^(1)(x)\n        nu_CFIE = alpha * mu_MFIE + eta * jl_x * h1l_x\n\n        # Step 4: Calculate condition numbers\n        \n        def calculate_condition_number(eigenvalues):\n            \"\"\"\n            Computes condition number as max(|lambda|)/min(|lambda|  0).\n            \"\"\"\n            abs_vals = np.abs(eigenvalues)\n            # Filter out any zero or near-zero magnitudes to avoid division by zero\n            # and adhere to the problem's \"strictly positive magnitudes\" rule.\n            non_zero_abs_vals = abs_vals[abs_vals  0]\n            \n            if non_zero_abs_vals.size == 0:\n                # This case implies all eigenvalues are zero, condition number is ill-defined.\n                # Could be 1.0 (for a zero operator) or inf.\n                # Assuming it does not occur for the given test cases.\n                return 1.0 \n                \n            max_abs = np.max(non_zero_abs_vals)\n            min_abs = np.min(non_zero_abs_vals)\n            \n            return max_abs / min_abs\n\n        kappa_S = calculate_condition_number(lambda_S)\n        kappa_MFIE = calculate_condition_number(mu_MFIE)\n        kappa_CFIE = calculate_condition_number(nu_CFIE)\n        \n        results.append([kappa_S, kappa_MFIE, kappa_CFIE])\n\n    # Final print statement in the exact required format.\n    # The string representation of a list is '[item1, item2, ...]'\n    # Joining these with commas and enclosing in brackets gives the desired output.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在解决了共振问题之后，边界元方法面临的另一个主要挑战是其高昂的计算成本，因为它会产生密集的矩阵系统。本练习将带您探索一种现代解决方案：分层矩阵（Hierarchical Matrices）和自适应交叉近似（ACA）等代数压缩技术。您将通过实践验证一个基本原理：物理上分离良好的两组源点之间的相互作用在数值上是低秩的，这使得系统矩阵可以被高效压缩，从而为大规模电磁仿真铺平了道路。",
            "id": "3354552",
            "problem": "您需要设计并实现一个程序，研究在计算电磁学中常见的三维外部标量亥姆霍兹核的远场交互块的低秩结构。目标是使用自适应交叉近似（ACA）来压缩块并控制近似误差，以检验可接纳远场块的数值秩如何依赖于波数和可调压缩阈值。\n\n从无源时谐 Maxwell 方程组在单频相量假设下开始，其中场以 $e^{-i\\omega t}$ 的形式变化。在一个均匀、各向同性、无源的区域中，这导出了电场的矢量亥姆霍兹方程 $\\nabla \\times \\nabla \\times \\mathbf{E} - k^{2}\\mathbf{E} = \\mathbf{0}$，其中 $k = \\omega \\sqrt{\\mu \\epsilon}$ 是波数。为了研究独立于矢量复杂性的低秩结构，我们简化为有界散射体外部的标量亥姆霍兹方程 $\\nabla^{2} u + k^{2} u = 0$，并考虑自由空间基本解 $G(\\mathbf{x}, \\mathbf{y}) = \\dfrac{\\mathrm{e}^{\\mathrm{i} k \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}}{4 \\pi \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}$。\n\n将半径为 $a = 1\\,\\mathrm{m}$ 的球体边界离散化为一组在球面上准均匀分布的 $N$ 个点 $\\{\\mathbf{x}_{i}\\}_{i=1}^{N}$。定义稠密矩阵 $K \\in \\mathbb{C}^{N \\times N}$，其元素为 $K_{ij} = G(\\mathbf{x}_{i}, \\mathbf{x}_{j})$（当 $i \\neq j$ 时）和 $K_{ii} = 0$（以避免奇异的自作用项）。通过递归地分割最长空间范围，直到每个叶簇最多包含 $s$ 个点，来构建点集的二元空间聚类（一个 $k$-d 树）。对于两个叶簇 $I$ 和 $J$，其中心为 $\\mathbf{c}_{I}$、$\\mathbf{c}_{J}$，半径为 $r_{I}$、$r_{J}$（簇的边界框对角线的一半），定义簇间距离 $d(I,J) = \\max\\left(0, \\lVert \\mathbf{c}_{I} - \\mathbf{c}_{J} \\rVert - (r_{I} + r_{J})\\right)$。如果一对 $(I,J)$ 满足 $\\max(r_{I}, r_{J}) \\le \\eta \\, d(I,J)$（其中 $\\eta \\in (0,1)$ 是一个固定的可接纳性参数），则该对是可接纳的（一个远场块）。对于每个可接纳对 $(I,J)$，考虑由 $I$ 中的行和 $J$ 中的列构成的子矩阵 $K_{IJ}$。\n\n实现自适应交叉近似（ACA），即 Adaptive Cross Approximation (ACA)，以构建一个秩-$r$ 分解 $K_{IJ} \\approx U V^{\\top}$，使得相对 Frobenius 范数误差 $\\lVert K_{IJ} - U V^{\\top} \\rVert_{F} / \\lVert K_{IJ} \\rVert_{F} \\le \\varepsilon$，其中 $\\varepsilon$ 是用户指定的阈值。您的 ACA 必须自适应地选择主元，并在达到目标相对块误差时，或当秩达到 $\\min(|I|,|J|)$ 时终止。对于每个可接纳块，报告达到的秩 $r$ 和与完整 $K_{IJ}$ 计算的精确相对 Frobenius 误差。为保证数值稳健性，您可以将 $\\lVert K_{IJ} \\rVert_{F} = 0$ 的块视为秩为 $0$ 且误差为 $0$。\n\n为了可复现性，请使用以下固定的几何和算法参数：\n- 球体半径 $a = 1\\,\\mathrm{m}$。\n- 点数 $N = 192$，通过斐波那契格点放置在球面上。\n- 叶节点大小 $s = 24$。\n- 可接纳性参数 $\\eta = 0.5$。\n- 距离单位为米，波数单位为弧度/米。格林函数使用相同的单位，但所有要求的输出都是无量纲的。\n\n对于下文指定的每个测试用例，构建一次几何结构和聚类，枚举所有 $I \\ne J$ 的可接纳远场块 $(I,J)$，并对每个块应用具有给定阈值 $\\varepsilon$ 的 ACA。然后，如下汇总远场块的统计数据：\n- 计算所有可接纳块的平均数值秩 $\\bar{r}$，并将其四舍五入到最近的整数。\n- 计算所有可接纳块的最大相对 Frobenius 误差 $E_{\\max}$。\n\n设计一个程序，为每个测试用例生成一行输出，按所列顺序包含四舍五入后的平均秩和最大误差，所有这些都在一个扁平列表中。确切地说，如果有 $M$ 个测试用例，输出必须是一个包含 $2M$ 个条目的列表，形式为 $[r_{1},E_{1},r_{2},E_{2},\\dots,r_{M},E_{M}]$，其中每个 $r_{m}$ 是一个整数，每个 $E_{m}$ 是一个小数（浮点数）。该列表必须打印在单行中，以逗号分隔并用方括号括起来，不含任何额外文本。\n\n测试套件：\n- 用例 1：$k = 2\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-2}$。\n- 用例 2：$k = 2\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-4}$。\n- 用例 3：$k = 8\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-2}$。\n- 用例 4：$k = 8\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-4}$。\n- 用例 5：$k = 16\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-2}$。\n- 用例 6：$k = 16\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-4}$。\n\n所有输出均为无量纲。角度（如有）以弧度为单位。\n\n您的程序必须是完整且可运行的，并且不需要任何用户输入。它必须实现所描述的 ACA 压缩和基于可接纳性的块选择，并且必须为指定的测试套件计算所需的聚合度量。最终的打印语句必须仅生成上述格式的单行必需输出。",
            "solution": "已对用户提供的问题进行了分析和验证。\n\n### 第一步：提取已知条件\n- **控制方程**：标量亥姆霍兹方程, $\\nabla^{2} u + k^{2} u = 0$。\n- **基本解**：$G(\\mathbf{x}, \\mathbf{y}) = \\dfrac{\\mathrm{e}^{\\mathrm{i} k \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}}{4 \\pi \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}$。\n- **矩阵定义**：当 $i \\neq j$ 时，$K_{ij} = G(\\mathbf{x}_{i}, \\mathbf{x}_{j})$，且 $K_{ii} = 0$。\n- **几何结构**：半径为 $a = 1\\,\\mathrm{m}$ 的球体。\n- **离散化**：通过斐波那契格点在球面上分布 $N = 192$ 个点。\n- **聚类**：$k$-d 树，递归分割最长空间范围。\n- **叶节点大小**：每个叶簇最多 $s = 24$ 个点。\n- **簇几何**：中心 $\\mathbf{c}_{I}$，半径 $r_{I}$（边界框对角线的一半）。\n- **簇间距离**：$d(I,J) = \\max\\left(0, \\lVert \\mathbf{c}_{I} - \\mathbf{c}_{J} \\rVert - (r_{I} + r_{J})\\right)$。\n- **可接纳性**：如果 $\\max(r_{I}, r_{J}) \\le \\eta \\, d(I,J)$ 成立，一对簇 $(I,J)$ 是可接纳的，其中 $\\eta = 0.5$。\n- **压缩**：自适应交叉近似（ACA）以找到 $K_{IJ} \\approx U V^{\\top}$。\n- **ACA 终止条件**：相对 Frobenius 范数误差 $\\lVert K_{IJ} - U V^{\\top} \\rVert_{F} / \\lVert K_{IJ} \\rVert_{F} \\le \\varepsilon$ 或秩达到最大可能值。\n- **稳健性**：如果 $\\lVert K_{IJ} \\rVert_{F} = 0$，则秩为 $0$，误差为 $0$。\n- **度量指标**：对于每个测试用例，计算所有 $I \\ne J$ 的可接纳块的平均秩 $\\bar{r}$（四舍五入到最近的整数）和最大相对 Frobenius 误差 $E_{\\max}$。\n- **测试用例 ($k$, $\\varepsilon$):**\n    1. ($2\\,\\mathrm{rad/m}$, $10^{-2}$)\n    2. ($2\\,\\mathrm{rad/m}$, $10^{-4}$)\n    3. ($8\\,\\mathrm{rad/m}$, $10^{-2}$)\n    4. ($8\\,\\mathrm{rad/m}$, $10^{-4}$)\n    5. ($16\\,\\mathrm{rad/m}$, $10^{-2}$)\n    6. ($16\\,\\mathrm{rad/m}$, $10^{-4}$)\n\n### 第二步：使用提取的已知条件进行验证\n- **科学依据**：该问题在计算电磁学和数值分析领域有坚实的理论基础。亥姆霍兹方程、格林函数、层次化数据结构（$k$-d 树）、可接纳性条件以及像 ACA 这样的低秩近似方法是快速边界元方法和 H-矩阵理论中的标准工具。\n- **适定性**：该问题是适定的。所有必需的参数（$a, N, s, \\eta$）、算法（斐波那契格点、$k$-d 树分割规则）和目标函数（平均秩、最大误差）都已明确指定，确保了唯一且可计算的解。冗余短语“Adaptive Cross Approximation (ACA), meaning Adaptive Cross Approximation (ACA)”并未引入歧义或矛盾。\n- **客观性**：问题以精确、客观和定量的术语陈述，没有主观或含糊的语言。\n\n### 第三步：结论与行动\n问题是**有效的**。它呈现了一个在一个成熟科学领域内的标准（尽管规模较小）的数值实验。所有组成部分都定义清晰，科学上正确，并且计算上可行。可以开始求解过程。\n\n### 基于原理的设计\n该解决方案是对用于边界元方法的快速分层求解器中所用方法的系统性实现。其核心思想是，对于两个分离良好的点簇，它们之间的交互矩阵块在数值上是低秩的。利用这一特性可以压缩矩阵，从而减少内存和计算成本。\n\n**1. 几何离散化**\n首先，将散射体（半径为 $a=1\\,\\mathrm{m}$ 的球体）的表面离散化为 $N=192$ 个点的集合。为确保准均匀分布，采用了斐波那契格点。对于点索引 $i \\in [0, N-1]$，使用黄金比例 $\\phi = (1 + \\sqrt{5})/2$ 在单位球面上生成坐标 $(x_i, y_i, z_i)$。最终坐标按半径 $a$进行缩放。\n\n**2. 层次化空间聚类**\n为了高效地识别分离良好的点簇，使用 $k$-d 树对这 $N$ 个点进行层次化划分。构造过程是递归的：\n- 一个点簇由树中的一个节点表示，该节点包含其点的索引。\n- 如果一个簇中的点数超过叶节点大小 $s=24$，则该簇被分割成两个子簇。\n- 分割是沿着簇的轴对齐边界框中范围最大的维度进行的。通过沿该维度对点进行排序，并将其分成相等的两半来划分点。\n- 当一个簇的点数小于或等于 $s$ 时，递归终止，此时该节点成为叶节点。\n对于每个叶节点，我们计算并存储其边界框、中心 $\\mathbf{c}$ 和半径 $r$（边界框对角线的一半）。\n\n**3. 可接纳性条件与远场块识别**\n低秩属性适用于“远场”交互。可接纳性条件将这种分离形式化。对于任意两个叶簇 $I$ 和 $J$，我们计算它们的边界框半径 $r_I, r_J$ 以及它们边界框之间的距离 $d(I,J) = \\max\\left(0, \\lVert \\mathbf{c}_{I} - \\mathbf{c}_{J} \\rVert - (r_{I} + r_{J})\\right)$。如果较大簇的大小与它们之间的距离相比足够小，即 $\\max(r_I, r_J) \\le \\eta \\cdot d(I,J)$，则一对簇 $(I,J)$ 被认为是可接纳的（在远场中）。这里，$\\eta=0.5$ 是可接纳性参数。我们枚举所有不同的叶簇对 $(I,J)$（其中 $I \\neq J$），并收集满足此条件的对。\n\n**4. 通过自适应交叉近似（ACA）进行低秩压缩**\n对于每个可接纳块 $K_{IJ}$，我们必须找到一个低秩近似 $K_{IJ} \\approx U V^T$。问题要求当精确的相对 Frobenius 范数误差 $\\varepsilon_{rel} = \\lVert K_{IJ} - U V^{\\top} \\rVert_{F} / \\lVert K_{IJ} \\rVert_{F}$ 低于阈值 $\\varepsilon$ 时，该过程终止。\n\n鉴于最大块尺寸很小（$s \\times s = 24 \\times 24$），显式的、完全主元选择的交叉近似版本既稳健又计算可行。该方法直接实现了指定的误差控制。对于给定的块 $K_{IJ}$，算法按以下步骤进行：\n\n1. 显式地构建矩阵块 $K_{IJ}$，其中 $(K_{IJ})_{pq} = G(\\mathbf{x}_p, \\mathbf{x}_q)$，对于 $p \\in I, q \\in J$。\n2. 计算其 Frobenius 范数 $\\lVert K_{IJ} \\rVert_{F}$。如果此范数为零，则秩为 $0$，过程终止。\n3. 初始化一个空近似（$U$ 和 $V$ 为空）和一个残差矩阵 $R = K_{IJ}$。\n4. 迭代构建秩-$r$ 近似：\n    a. 在第 $r$ 次迭代（从 $r=1$ 开始），在当前残差矩阵 $R$ 中找到绝对值最大的元素 $(i_r, j_r)$。此即为主元。\n    b. 如果主元值在数值上为零，则残差实际上为零，过程停止。\n    c. 将 $U$ 的新列定义为 $R$ 的第 $j_r$ 列，将 $V^T$ 的新行定义为 $R$ 的第 $i_r$ 行除以主元值。\n    d. 通过减去秩-1 外积来更新残差：$R \\leftarrow R - u_r v_r^T$。\n    e. 构建当前的秩-$r$ 近似 $A_r = U V^T$。\n    f. 计算精确的相对误差 $\\lVert K_{IJ} - A_r \\rVert_{F} / \\lVert K_{IJ} \\rVert_{F}$。\n    g. 如果此误差小于或等于阈值 $\\varepsilon$，算法终止。\n5. 最终的秩是执行的迭代次数 $r$。最终的误差是在最后一步计算出的误差。\n\n**5. 结果汇总**\n对每个由波数 $k$ 和压缩阈值 $\\varepsilon$ 定义的测试用例执行该过程。对于一个给定的用例，我们遍历所有先前识别的可接纳块。对每个块运行 ACA 压缩以确定其数值秩和最终的近似误差。收集所有块的秩和误差。最后，我们计算所有秩的平均值（四舍五入到最近的整数）和所有误差的最大值。这两个值构成一个测试用例的结果。所有测试用例的结果汇总成一个列表，用于最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and produce the final output.\n    \"\"\"\n\n    class Node:\n        \"\"\"A node in the k-d tree.\"\"\"\n        def __init__(self, indices, points):\n            self.indices = np.array(indices, dtype=int)\n            self.children = []\n            self.is_leaf = False\n            \n            if not self.indices.size:\n                self.bbox = np.array([0,0,0,0,0,0])\n                self.center = np.zeros(3)\n                self.radius = 0.0\n                return\n\n            node_points = points[self.indices]\n            mins = np.min(node_points, axis=0)\n            maxs = np.max(node_points, axis=0)\n            self.bbox = np.array([mins[0], maxs[0], mins[1], maxs[1], mins[2], maxs[2]])\n            self.center = (mins + maxs) / 2.0\n            \n            diag_vec = maxs - mins\n            self.radius = 0.5 * np.linalg.norm(diag_vec)\n\n    def build_kdtree(points, indices, leaf_size_s):\n        \"\"\"Recursively builds the k-d tree.\"\"\"\n        node = Node(indices, points)\n\n        if len(indices) = leaf_size_s:\n            node.is_leaf = True\n            return node\n\n        dims = node.bbox[1::2] - node.bbox[0::2]\n        split_dim = np.argmax(dims)\n        \n        node_points = points[indices]\n        sorted_indices_map = np.argsort(node_points[:, split_dim])\n        sorted_indices = indices[sorted_indices_map]\n        \n        mid = len(indices) // 2\n        \n        child1_indices = sorted_indices[:mid]\n        child2_indices = sorted_indices[mid:]\n        \n        node.children.append(build_kdtree(points, child1_indices, leaf_size_s))\n        node.children.append(build_kdtree(points, child2_indices, leaf_size_s))\n        \n        return node\n    \n    def get_leaves(node):\n        \"\"\"Traverses the tree to collect all leaf nodes.\"\"\"\n        if node.is_leaf:\n            return [node]\n        leaves = []\n        for child in node.children:\n            leaves.extend(get_leaves(child))\n        return leaves\n\n    def generate_fibonacci_sphere(n_points, radius):\n        \"\"\"Generates points on a sphere using the Fibonacci lattice.\"\"\"\n        points = np.zeros((n_points, 3))\n        phi = (1 + np.sqrt(5)) / 2.  # Golden ratio\n        \n        for i in range(n_points):\n            y = 1 - (2 * i + 1) / n_points\n            r_at_y = np.sqrt(1 - y * y)\n            theta = 2 * np.pi * i / phi\n            \n            x = np.cos(theta) * r_at_y\n            z = np.sin(theta) * r_at_y\n            \n            points[i] = [x, y, z]\n            \n        return points * radius\n\n    def green_function(x, y, k):\n        \"\"\"Computes the scalar Helmholtz Green's function.\"\"\"\n        dist = np.linalg.norm(x - y)\n        if dist  1e-12: # Avoid division by zero, though not expected for i != j\n            return 0.0j\n        return np.exp(1j * k * dist) / (4 * np.pi * dist)\n\n    def aca_compress_and_get_stats(row_indices, col_indices, points, k, epsilon):\n        \"\"\"\n        Performs ACA with full pivoting on an explicit matrix to find rank \n        and computes the exact relative Frobenius error.\n        \"\"\"\n        m, n = len(row_indices), len(col_indices)\n        \n        K_block = np.zeros((m, n), dtype=np.complex128)\n        for i, r_idx in enumerate(row_indices):\n            for j, c_idx in enumerate(col_indices):\n                K_block[i, j] = green_function(points[r_idx], points[c_idx], k)\n\n        norm_K_fro = np.linalg.norm(K_block, 'fro')\n        \n        if norm_K_fro == 0:\n            return 0, 0.0\n\n        R = K_block.copy()\n        U_list, V_list = [], []\n        \n        max_rank = min(m, n)\n        for r in range(max_rank):\n            # Full pivoting: find max element in residual\n            i_p, j_p = np.unravel_index(np.argmax(np.abs(R)), R.shape)\n            pivot = R[i_p, j_p]\n            \n            if abs(pivot)  1e-16 * norm_K_fro:\n                break\n            \n            u_r = R[:, j_p]\n            v_r = R[i_p, :] / pivot\n\n            U_list.append(u_r)\n            V_list.append(v_r)\n            \n            R -= np.outer(u_r, v_r)\n            \n            # Form approximation and check error\n            A_r = np.array(U_list).T @ np.array(V_list)\n            current_error = np.linalg.norm(K_block - A_r, 'fro') / norm_K_fro\n\n            if current_error = epsilon:\n                return r + 1, current_error\n        \n        # If loop finished, calculate final error\n        if U_list:\n            A_final = np.array(U_list).T @ np.array(V_list)\n            final_error = np.linalg.norm(K_block - A_final, 'fro') / norm_K_fro\n            return len(U_list), final_error\n        else:\n            return 0, 1.0\n\n\n    # Fixed geometric and algorithmic parameters\n    a = 1.0  # Sphere radius in meters\n    N = 192  # Number of points\n    s = 24   # Leaf size\n    eta = 0.5 # Admissibility parameter\n    \n    # Test suite\n    test_cases = [\n        (2.0, 1e-2),\n        (2.0, 1e-4),\n        (8.0, 1e-2),\n        (8.0, 1e-4),\n        (16.0, 1e-2),\n        (16.0, 1e-4),\n    ]\n\n    # --- Step 1: Geometry and Clustering (done once) ---\n    points = generate_fibonacci_sphere(N, a)\n    root = build_kdtree(points, np.arange(N), s)\n    leaves = get_leaves(root)\n    \n    # --- Step 2: Enumerate Admissible Blocks (done once) ---\n    admissible_pairs = []\n    for i in range(len(leaves)):\n        for j in range(len(leaves)):\n            if i == j:\n                continue\n            \n            node_I, node_J = leaves[i], leaves[j]\n            \n            dist_centers = np.linalg.norm(node_I.center - node_J.center)\n            dist_boxes = max(0, dist_centers - (node_I.radius + node_J.radius))\n            \n            if max(node_I.radius, node_J.radius) = eta * dist_boxes:\n                admissible_pairs.append((node_I.indices, node_J.indices))\n\n    # --- Step 3: Run test suite ---\n    final_results = []\n    for k, epsilon in test_cases:\n        ranks = []\n        errors = []\n        \n        if not admissible_pairs: # Should not happen for these params\n             final_results.extend([0, 0.0])\n             continue\n\n        for row_indices, col_indices in admissible_pairs:\n            rank, error = aca_compress_and_get_stats(row_indices, col_indices, points, k, epsilon)\n            ranks.append(rank)\n            errors.append(error)\n        \n        avg_rank = np.mean(ranks) if ranks else 0\n        max_error = np.max(errors) if errors else 0.0\n        \n        # Round average rank to the nearest integer\n        rounded_avg_rank = int(round(avg_rank))\n        \n        final_results.extend([rounded_avg_rank, max_error])\n        \n    # --- Final Print ---\n    # Formatting the output to match the required single-line list format.\n    formatted_results = []\n    for i, res in enumerate(final_results):\n        if i % 2 == 0:  # Rank is an integer\n            formatted_results.append(str(res))\n        else:  # Error is a float\n            formatted_results.append(f\"{res:.15g}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}