{
    "hands_on_practices": [
        {
            "introduction": "The choice between the Lorenz and Coulomb gauges is not merely a theoretical preference; it has profound consequences for the efficiency of numerical simulations. This exercise explores the fundamental structural difference between the hyperbolic wave equations derived under the Lorenz gauge and the coupled elliptic-hyperbolic system resulting from the Coulomb gauge. By constructing a specific source and performing a comparative cost analysis , you will gain a concrete, quantitative understanding of why the Lorenz gauge is often favored in time-domain solvers, solidifying the link between mathematical structure and computational tractability.",
            "id": "3325847",
            "problem": "Consider vacuum Maxwell equations with charge density $\\rho(\\mathbf{r},t)$ and current density $\\mathbf{J}(\\mathbf{r},t)$, material parameters permittivity $\\epsilon_0$ and permeability $\\mu_0$, and electromagnetic fields $\\mathbf{E}(\\mathbf{r},t)$ and $\\mathbf{B}(\\mathbf{r},t)$. Introduce electromagnetic potentials via $\\mathbf{B} = \\nabla \\times \\mathbf{A}$ and $\\mathbf{E} = -\\nabla \\phi - \\partial_t \\mathbf{A}$. Two distinct gauge conditions are commonly used: the Lorenz gauge, $\\nabla \\cdot \\mathbf{A} + \\mu_0 \\epsilon_0 \\partial_t \\phi = 0$, and the Coulomb gauge, $\\nabla \\cdot \\mathbf{A} = 0$.\n\nConstruct an explicit source that has nontrivial charge density and current density coupled by the continuity equation, and then compare the computational structure that results from enforcing the Lorenz gauge versus the Coulomb gauge in a finite-difference time-domain discretization. Specifically, let\n$$\n\\psi(\\mathbf{r}) = \\exp\\!\\left(-\\frac{|\\mathbf{r}|^2}{2\\sigma^2}\\right), \\quad g(t) = \\sin(\\omega_0 t)\\,\\exp(-\\alpha t),\n$$\nand define\n$$\n\\rho(\\mathbf{r},t) = q_0\\,\\nabla^2 \\psi(\\mathbf{r})\\,g(t), \\quad \\mathbf{J}(\\mathbf{r},t) = -q_0\\,\\nabla \\psi(\\mathbf{r})\\,\\partial_t g(t),\n$$\nwhere $q_0$, $\\sigma$, $\\omega_0$, and $\\alpha$ are finite positive constants. Verify that these sources satisfy the continuity equation $\\nabla \\cdot \\mathbf{J} + \\partial_t \\rho = 0$.\n\nStarting from Maxwell’s equations and the above potential definitions, derive the governing equations for the potentials under the Lorenz gauge and under the Coulomb gauge. Explain why, for the constructed source, enforcing the Lorenz gauge eliminates nonlocal constraints and yields a uniform wave operator for both $\\phi$ and $\\mathbf{A}$, while the Coulomb gauge imposes a nonlocal elliptic constraint on $\\phi$ and a divergence-free condition on $\\mathbf{A}$ that introduces coupling.\n\nAssume a uniform cubic spatial grid with $N$ degrees of freedom per scalar field, and use a standard explicit second-order Finite-Difference Time-Domain (FDTD) update for wave-like equations. Model the per-timestep floating-point operation counts as follows:\n\n- For any explicit wave update of a scalar or vector component using a $7$-point Laplacian, the cost per degree of freedom is $c_s = 11$ operations.\n- For any Poisson solve (elliptic problem), a geometric multigrid $V$-cycle costs $c_m = 50$ operations per degree of freedom per cycle, and each Poisson solve uses $n_v = 2$ cycles per timestep to reach the required residual tolerance.\n- Computing the discrete divergence of a vector field $\\mathbf{A}$ requires $c_d = 5$ operations per degree of freedom.\n- Computing the gradient of a scalar field $\\psi$ and subtracting it from $\\mathbf{A}$ (Helmholtz projection step $\\mathbf{A} \\leftarrow \\mathbf{A} - \\nabla \\psi$) requires $c_g = 6$ operations per degree of freedom.\n\nUnder the Lorenz gauge, potentials $\\phi$ and $\\mathbf{A}$ can be advanced by explicit wave updates alone. Under the Coulomb gauge, at each timestep, compute $\\phi$ via a Poisson solve from $\\rho$, advance $\\mathbf{A}$ via an explicit wave update, and then enforce $\\nabla \\cdot \\mathbf{A} = 0$ by a Helmholtz projection that consists of computing $d = \\nabla \\cdot \\mathbf{A}$, solving the Poisson equation $\\nabla^2 \\psi = d$, and updating $\\mathbf{A} \\leftarrow \\mathbf{A} - \\nabla \\psi$.\n\nUsing the above cost model, derive a closed-form expression for the ratio $R$ of Coulomb-gauge cost to Lorenz-gauge cost per timestep, and evaluate $R$ numerically. Round your final numerical answer to three significant figures. Express your answer as a dimensionless number.",
            "solution": "The problem statement is scientifically grounded, well-posed, objective, and complete. It presents a standard comparison between the Lorenz and Coulomb gauges in the context of computational electromagnetics, providing all necessary definitions, constants, and a clear computational cost model. The problem is therefore deemed valid and a full solution is provided below.\n\nFirst, we verify that the given source terms,\n$$\n\\rho(\\mathbf{r},t) = q_0\\,\\nabla^2 \\psi(\\mathbf{r})\\,g(t)\n$$\n$$\n\\mathbf{J}(\\mathbf{r},t) = -q_0\\,\\nabla \\psi(\\mathbf{r})\\,\\partial_t g(t)\n$$\nsatisfy the continuity equation, $\\nabla \\cdot \\mathbf{J} + \\partial_t \\rho = 0$.\n\nTaking the time derivative of the charge density $\\rho$, we get:\n$$\n\\partial_t \\rho = \\partial_t \\left[ q_0\\,\\nabla^2 \\psi(\\mathbf{r})\\,g(t) \\right] = q_0\\,\\nabla^2 \\psi(\\mathbf{r})\\,\\partial_t g(t)\n$$\nsince $\\psi(\\mathbf{r})$ is independent of time $t$.\n\nNext, taking the divergence of the current density $\\mathbf{J}$:\n$$\n\\nabla \\cdot \\mathbf{J} = \\nabla \\cdot \\left[ -q_0\\,\\nabla \\psi(\\mathbf{r})\\,\\partial_t g(t) \\right]\n$$\nSince $\\partial_t g(t)$ is a scalar function of time only and does not depend on position $\\mathbf{r}$, we can factor it out of the spatial divergence operator:\n$$\n\\nabla \\cdot \\mathbf{J} = -q_0\\,\\partial_t g(t)\\,\\nabla \\cdot (\\nabla \\psi(\\mathbf{r})) = -q_0\\,\\partial_t g(t)\\,\\nabla^2 \\psi(\\mathbf{r})\n$$\nAdding the two results:\n$$\n\\nabla \\cdot \\mathbf{J} + \\partial_t \\rho = -q_0\\,\\nabla^2 \\psi(\\mathbf{r})\\,\\partial_t g(t) + q_0\\,\\nabla^2 \\psi(\\mathbf{r})\\,\\partial_t g(t) = 0\n$$\nThe continuity equation is satisfied.\n\nNext, we derive the governing equations for the potentials $\\phi$ and $\\mathbf{A}$ starting from the inhomogeneous Maxwell's equations and the potential definitions $\\mathbf{B} = \\nabla \\times \\mathbf{A}$ and $\\mathbf{E} = -\\nabla \\phi - \\partial_t \\mathbf{A}$. The relevant Maxwell's equations are Gauss's law and the Ampere-Maxwell law:\n$$\n\\nabla \\cdot \\mathbf{E} = \\frac{\\rho}{\\epsilon_0}\n$$\n$$\n\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J} + \\mu_0 \\epsilon_0 \\partial_t \\mathbf{E}\n$$\nSubstituting the potential definitions into Gauss's law:\n$$\n\\nabla \\cdot (-\\nabla \\phi - \\partial_t \\mathbf{A}) = \\frac{\\rho}{\\epsilon_0} \\implies \\nabla^2 \\phi + \\partial_t(\\nabla \\cdot \\mathbf{A}) = -\\frac{\\rho}{\\epsilon_0}\n$$\n(Equation 1)\n\nSubstituting the potential definitions into the Ampere-Maxwell law and using the vector identity $\\nabla \\times (\\nabla \\times \\mathbf{A}) = \\nabla(\\nabla \\cdot \\mathbf{A}) - \\nabla^2 \\mathbf{A}$:\n$$\n\\nabla \\times (\\nabla \\times \\mathbf{A}) = \\mu_0 \\mathbf{J} + \\mu_0 \\epsilon_0 \\partial_t(-\\nabla \\phi - \\partial_t \\mathbf{A})\n$$\n$$\n\\nabla(\\nabla \\cdot \\mathbf{A}) - \\nabla^2 \\mathbf{A} = \\mu_0 \\mathbf{J} - \\mu_0 \\epsilon_0 \\nabla(\\partial_t \\phi) - \\mu_0 \\epsilon_0 \\partial_t^2 \\mathbf{A}\n$$\nRearranging and defining the d'Alembert operator $\\Box = \\nabla^2 - \\mu_0 \\epsilon_0 \\partial_t^2$:\n$$\n\\Box \\mathbf{A} - \\nabla(\\nabla \\cdot \\mathbf{A} + \\mu_0 \\epsilon_0 \\partial_t \\phi) = -\\mu_0 \\mathbf{J}\n$$\n(Equation 2)\n\nNow we apply the two gauge conditions.\n\nCase 1: Lorenz Gauge\nThe Lorenz gauge condition is $\\nabla \\cdot \\mathbf{A} + \\mu_0 \\epsilon_0 \\partial_t \\phi = 0$.\nApplying this to Equation 2, the second term on the left-hand side vanishes:\n$$\n\\Box \\mathbf{A} = -\\mu_0 \\mathbf{J} \\implies (\\nabla^2 - \\mu_0 \\epsilon_0 \\partial_t^2) \\mathbf{A} = -\\mu_0 \\mathbf{J}\n$$\nThis is a set of three uncoupled wave equations for the components of $\\mathbf{A}$.\nNext, we use the Lorenz condition to simplify Equation 1. We have $\\partial_t(\\nabla \\cdot \\mathbf{A}) = \\partial_t(-\\mu_0 \\epsilon_0 \\partial_t \\phi) = -\\mu_0 \\epsilon_0 \\partial_t^2 \\phi$. Substituting this into Equation 1:\n$$\n\\nabla^2 \\phi - \\mu_0 \\epsilon_0 \\partial_t^2 \\phi = -\\frac{\\rho}{\\epsilon_0} \\implies \\Box \\phi = -\\frac{\\rho}{\\epsilon_0}\n$$\nThis is a wave equation for $\\phi$.\nIn the Lorenz gauge, both the scalar potential $\\phi$ and the vector potential $\\mathbf{A}$ are governed by the same hyperbolic wave operator, $\\Box$. The equations are driven by the local sources $\\rho$ and $\\mathbf{J}$, respectively. Computationally, this is highly advantageous for a time-domain method like FDTD. An explicit update scheme can advance both $\\phi$ and $\\mathbf{A}$ in time based only on their values at previous timesteps in a local spatial neighborhood. This locality eliminates the need for solving large, coupled systems of equations at each timestep.\n\nCase 2: Coulomb Gauge\nThe Coulomb gauge condition is $\\nabla \\cdot \\mathbf{A} = 0$.\nApplying this to Equation 1, the second term on the left-hand side vanishes:\n$$\n\\nabla^2 \\phi = -\\frac{\\rho}{\\epsilon_0}\n$$\nThis is Poisson's equation. Unlike the wave equation, it has no time derivative. This means that at any given instant $t$, the potential $\\phi(\\mathbf{r}, t)$ throughout all of space is determined instantaneously by the global charge distribution $\\rho(\\mathbf{r}', t)$. This is an elliptic partial differential equation, which imposes a nonlocal constraint. Numerically, it requires the solution of a large linear system at every timestep, which is computationally expensive.\nApplying the Coulomb condition to Equation 2, we get:\n$$\n(\\nabla^2 - \\mu_0 \\epsilon_0 \\partial_t^2)\\mathbf{A} - \\nabla(\\mu_0 \\epsilon_0 \\partial_t \\phi) = -\\mu_0 \\mathbf{J}\n$$\n$$\n(\\nabla^2 - \\mu_0 \\epsilon_0 \\partial_t^2)\\mathbf{A} = -\\mu_0 \\mathbf{J} + \\mu_0 \\epsilon_0 \\nabla(\\partial_t \\phi)\n$$\nThis is a wave equation for $\\mathbf{A}$, but its source term now depends on the gradient of the time derivative of the scalar potential, $\\nabla(\\partial_t \\phi)$. This couples the equation for $\\mathbf{A}$ to $\\phi$. Furthermore, even if $\\nabla \\cdot \\mathbf{A} = 0$ is satisfied at time $t$, a numerical wave update for $\\mathbf{A}$ to time $t+\\Delta t$ will generally introduce numerical error such that $\\nabla \\cdot \\mathbf{A} \\neq 0$. To enforce the gauge condition strictly at each step, a correction or projection step is required. This involves solving another Poisson equation to project $\\mathbf{A}$ back onto the space of divergence-free fields. This additional elliptic solve further increases the computational cost.\n\nIn summary, the Lorenz gauge leads to a set of four uncoupled, local wave equations, which are well-suited for efficient explicit time-stepping schemes. The Coulomb gauge leads to a nonlocal elliptic equation for $\\phi$ and a coupled wave equation for $\\mathbf{A}$ that requires an additional nonlocal projection step, making it computationally far more intensive per timestep.\n\nFinally, we calculate the ratio $R$ of the computational cost per timestep for the Coulomb gauge to that of the Lorenz gauge, using the provided cost model. Let $N$ be the number of degrees of freedom (grid points) for a scalar field. A vector field has $3N$ degrees of freedom.\n\nCost of Lorenz Gauge ($C_L$):\nThe algorithm involves explicit wave updates for one scalar field ($\\phi$) and one vector field ($\\mathbf{A}$).\n- Cost for updating $\\phi$ ($N$ DOFs): $N \\times c_s$.\n- Cost for updating $\\mathbf{A}$ ($3N$ DOFs): $3N \\times c_s$.\n- Total cost: $C_L = N c_s + 3N c_s = 4N c_s$.\n\nCost of Coulomb Gauge ($C_C$):\nThe algorithm is given as a sequence of steps per timestep:\n1.  Solve Poisson equation for $\\phi$ from $\\rho$. This is an elliptic solve for one scalar field.\n    Cost: $N \\times c_m \\times n_v$.\n2.  Advance $\\mathbf{A}$ with an explicit wave update. This is for one vector field.\n    Cost: $3N \\times c_s$.\n3.  Enforce $\\nabla \\cdot \\mathbf{A} = 0$ via Helmholtz projection.\n    a. Compute $d = \\nabla \\cdot \\mathbf{A}$. Cost is given as $c_d$ per DOF/grid point.\n       Cost: $N \\times c_d$.\n    b. Solve Poisson equation $\\nabla^2 \\psi = d$. This is an elliptic solve for one scalar field.\n       Cost: $N \\times c_m \\times n_v$.\n    c. Update $\\mathbf{A} \\leftarrow \\mathbf{A} - \\nabla \\psi$. Cost is given as $c_g$ per DOF/grid point.\n       Cost: $N \\times c_g$.\n- Total cost: $C_C = (N c_m n_v) + (3N c_s) + (N c_d + N c_m n_v + N c_g)$.\n- $C_C = N (2 c_m n_v + 3 c_s + c_d + c_g)$.\n\nThe ratio $R$ is:\n$$\nR = \\frac{C_C}{C_L} = \\frac{N (2 c_m n_v + 3 c_s + c_d + c_g)}{4N c_s} = \\frac{2 c_m n_v + 3 c_s + c_d + c_g}{4 c_s}\n$$\nNow, substitute the given numerical values: $c_s = 11$, $c_m = 50$, $n_v = 2$, $c_d = 5$, $c_g = 6$.\n$$\nR = \\frac{2(50)(2) + 3(11) + 5 + 6}{4(11)} = \\frac{200 + 33 + 5 + 6}{44} = \\frac{244}{44} = \\frac{61}{11}\n$$\nNumerically, this is:\n$$\nR = \\frac{61}{11} \\approx 5.545454...\n$$\nRounding to three significant figures, we get $R = 5.55$.",
            "answer": "$$\n\\boxed{5.55}\n$$"
        },
        {
            "introduction": "While the Coulomb gauge can be computationally demanding, it is indispensable for certain problems, particularly in magnetostatics. Implementing this constraint correctly within a Finite Element Method (FEM) framework requires a deep understanding of mixed formulations and compatible function spaces. This practice  guides you through enforcing the divergence-free condition $\\nabla \\cdot \\mathbf{A} = 0$ using two standard techniques: the penalty method and the Lagrange multiplier method, both within a structure-preserving discrete exterior calculus framework. By building and solving the resulting linear systems, you will directly experience the practical trade-offs between these enforcement strategies and learn to numerically verify the effectiveness of your gauge implementation.",
            "id": "3325811",
            "problem": "You are to derive, discretize, and implement a mixed Finite Element Method (FEM) formulation for a vector potential in magnetostatics that enforces the Coulomb gauge using appropriate $H(\\mathrm{curl})$ and $H(\\mathrm{div})$-compatible discrete spaces, with constraint enforcement via both a penalty approach and Lagrange multipliers. Begin from the fundamental base of Maxwell's equations in magnetostatics with a vector potential and the Coulomb gauge, derive a consistent weak formulation, and then construct a computationally realizable discrete system on a structured mesh. Implement both enforcement strategies and compare their effectiveness numerically by reporting the discrete divergence of the computed vector potential. All quantities are non-dimensional.\n\nStart from the magnetostatic vector potential formulation on a unit square domain $\\Omega = [0,1]\\times[0,1]$ with constant permeability and a linear stabilization term:\nfind a vector potential $\\mathbf{A}$ such that\n$$\n\\nabla \\times (\\nabla \\times \\mathbf{A}) + \\alpha \\mathbf{A} = \\mathbf{J} \\quad \\text{in } \\Omega\n$$\ntogether with the Coulomb gauge\n$$\n\\nabla \\cdot \\mathbf{A} = 0 \\quad \\text{in } \\Omega,\n$$\nwhere $\\alpha > 0$ is a positive constant and $\\mathbf{J}$ is a given source field. Assume free tangential boundary conditions sufficient for a well-posed weak formulation.\n\nDerive a weak mixed formulation by selecting the appropriate Sobolev spaces and augmenting the magnetostatic equation with a constraint via either a penalty or a scalar Lagrange multiplier. Use the following context-appropriate fundamental base:\n- Maxwell's magnetostatic equations and the definition of the vector potential.\n- The Coulomb gauge condition.\n- The standard $H(\\mathrm{curl})$ and $H(\\mathrm{div})$ space definitions and the de Rham complex relationships.\n- Integration by parts identities for curl and divergence.\n\nIn your derivation, you must:\n- Select the trial and test spaces for $\\mathbf{A}$ and the multiplier so that the discrete spaces respect the $H(\\mathrm{curl})$ and $H(\\mathrm{div})$ conformities and the topological identities on the mesh.\n- Clearly write the weak forms for both the penalty formulation and the Lagrange multiplier formulation starting from the continuous equations.\n\nThen, for computational realization, use a structured rectangular mesh with $N_x$ cells in the $x$-direction and $N_y$ cells in the $y$-direction, with $N_x,N_y \\in \\mathbb{N}$. Construct the following discrete operators on this mesh that mimic $H(\\mathrm{curl})$ and $H(\\mathrm{div})$-compatible spaces:\n- Edge-based unknowns for $\\mathbf{A}$ represent a discrete $H(\\mathrm{curl})$ space, with edge orientations set as $+x$ for horizontal edges and $+y$ for vertical edges. Let the edge mass matrix be a diagonal matrix $M_e$ whose entries equal the edge lengths ($\\Delta x$ for horizontal edges and $\\Delta y$ for vertical edges).\n- The incidence matrix $G$ from nodes to edges approximates the discrete gradient, with entries $-1$ at the tail node and $+1$ at the head node for each edge.\n- The incidence matrix $C$ from edges to faces approximates the discrete curl, with oriented coefficients $(+1,+1,-1,-1)$ for the bottom, right, top, and left edges of each face, respectively, consistent with counter-clockwise orientation. Let the face mass matrix be a diagonal matrix $M_f$ whose entries equal the cell areas $\\Delta x \\Delta y$.\n\nUsing these, define the discrete operators that enter the linear systems:\n- The discrete curl-curl operator $K = C^\\top M_f C + \\alpha M_e$ acting on edge unknowns.\n- The discrete divergence of the edge field as $D \\mathbf{a} = G^\\top M_e \\mathbf{a}$ on nodes, consistent with the weak form $(\\nabla \\cdot \\mathbf{A}, \\eta) = -(\\mathbf{A}, \\nabla \\eta)$.\n\nApproximate the source term by sampling a smooth divergence-free field $\\mathbf{J}(x,y)$ at edge midpoints and projecting onto edge tangents, scaled by edge lengths. Use the divergence-free field\n$$\n\\mathbf{J}(x,y) = \\begin{bmatrix}\n\\sin(\\pi x)\\cos(\\pi y) \\\\\n-\\cos(\\pi x)\\sin(\\pi y)\n\\end{bmatrix}.\n$$\n\nImplement two enforcement strategies:\n- Penalty method: Solve for the edge coefficients $\\mathbf{a}$ using the system\n$$\n\\left(K + \\beta\\, M_e G G^\\top M_e\\right)\\mathbf{a} = \\mathbf{j},\n$$\nwhere $\\beta > 0$ is the penalty parameter and $\\mathbf{j}$ is the edge load vector obtained from projecting $\\mathbf{J}$ onto edge tangents.\n- Lagrange multiplier method: Solve the saddle-point system for $(\\mathbf{a}, \\boldsymbol{\\lambda})$\n$$\n\\begin{bmatrix}\nK & -M_e G \\\\\nG^\\top M_e & -\\tau I\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{a} \\\\\n\\boldsymbol{\\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{j} \\\\\n\\mathbf{0}\n\\end{bmatrix},\n$$\nwhere $\\tau > 0$ is a small stabilization parameter ensuring uniqueness of the multiplier by removing the constant null space. The constraint $G^\\top M_e \\mathbf{a} = \\mathbf{0}$ enforces the Coulomb gauge in the discrete sense.\n\nYou must produce numerical evidence of Coulomb gauge enforcement by reporting the Euclidean norm of the discrete divergence at nodes, computed as\n$$\n\\|D\\mathbf{a}\\|_2 = \\sqrt{(D\\mathbf{a})^\\top (D\\mathbf{a})},\n$$\nfor each test case.\n\nYour program should implement the mesh construction, operator assembly, source projection, and linear solves using only the Python Standard Library, NumPy, and SciPy. All quantities are non-dimensional, and no physical units are required. Angles, if any, must be in radians, but none are required here.\n\nTest Suite:\nProvide the results for the following five test cases, which together probe general behavior and edge cases:\n- Case $1$: $N_x = 4$, $N_y = 4$, $\\alpha = 1$, penalty enforcement with $\\beta = 0$ (no gauge penalty).\n- Case $2$: $N_x = 4$, $N_y = 4$, $\\alpha = 1$, penalty enforcement with $\\beta = 1$ (moderate penalty).\n- Case $3$: $N_x = 4$, $N_y = 4$, $\\alpha = 1$, penalty enforcement with $\\beta = 10^6$ (very strong penalty).\n- Case $4$: $N_x = 4$, $N_y = 4$, $\\alpha = 1$, Lagrange multiplier enforcement with $\\tau = 10^{-8}$.\n- Case $5$: Boundary case with $N_x = 1$, $N_y = 1$, $\\alpha = 1$, Lagrange multiplier enforcement with $\\tau = 10^{-8}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the Euclidean norms of the discrete divergence for the five cases as a comma-separated list enclosed in square brackets, for example,\n$$\n[\\rho_1,\\rho_2,\\rho_3,\\rho_4,\\rho_5],\n$$\nwhere each $\\rho_k$ is a floating-point number. The output must contain no spaces.",
            "solution": "The problem requires the derivation and implementation of a mixed finite element method for the magnetostatic vector potential formulation, with the Coulomb gauge enforced by two distinct methods: a penalty approach and a Lagrange multiplier approach. The solution will proceed by first establishing the continuous weak formulation from the governing partial differential equations, then describing the discrete systems provided in the problem statement in the context of this weak formulation, and finally detailing the numerical implementation.\n\nWe begin with the governing partial differential equations on a domain $\\Omega = [0,1]^2$:\n$$\n\\nabla \\times (\\nabla \\times \\mathbf{A}) + \\alpha \\mathbf{A} = \\mathbf{J} \\quad \\text{in } \\Omega\n$$\n$$\n\\nabla \\cdot \\mathbf{A} = 0 \\quad \\text{in } \\Omega\n$$\nHere, $\\mathbf{A}$ is the magnetic vector potential, $\\mathbf{J}$ is the prescribed current density, and $\\alpha > 0$ is a scalar constant. The first equation is a statement of Ampere's law combined with a constitutive relation and a mass-like stabilization term, while the second is the Coulomb gauge condition.\n\nTo derive a weak formulation, we select appropriate function spaces for the trial function $\\mathbf{A}$ and test functions. The natural space for vector fields whose curl is square-integrable is $H(\\mathrm{curl}; \\Omega)$, defined as $\\mathbf{V} = \\{\\mathbf{u} \\in (L^2(\\Omega))^2 \\mid \\nabla \\times \\mathbf{u} \\in L^2(\\Omega)\\}$. We multiply the primary PDE by an arbitrary test function $\\mathbf{v} \\in \\mathbf{V}$ and integrate over the domain $\\Omega$:\n$$\n\\int_{\\Omega} (\\nabla \\times (\\nabla \\times \\mathbf{A})) \\cdot \\mathbf{v} \\, d\\Omega + \\int_{\\Omega} \\alpha \\mathbf{A} \\cdot \\mathbf{v} \\, d\\Omega = \\int_{\\Omega} \\mathbf{J} \\cdot \\mathbf{v} \\, d\\Omega\n$$\nUsing the vector calculus identity for integration by parts, $\\int_{\\Omega} (\\nabla \\times \\mathbf{F}) \\cdot \\mathbf{G} \\, d\\Omega = \\int_{\\Omega} \\mathbf{F} \\cdot (\\nabla \\times \\mathbf{G}) \\, d\\Omega - \\oint_{\\partial\\Omega} (\\mathbf{n} \\times \\mathbf{F}) \\cdot \\mathbf{G} \\, dS$, we can rewrite the first term:\n$$\n\\int_{\\Omega} (\\nabla \\times (\\nabla \\times \\mathbf{A})) \\cdot \\mathbf{v} \\, d\\Omega = \\int_{\\Omega} (\\nabla \\times \\mathbf{A}) \\cdot (\\nabla \\times \\mathbf{v}) \\, d\\Omega - \\oint_{\\partial\\Omega} (\\mathbf{n} \\times (\\nabla \\times \\mathbf{A})) \\cdot \\mathbf{v} \\, dS\n$$\nThe problem specifies \"free tangential boundary conditions,\" which are natural boundary conditions. This implies the boundary integral term vanishes. This leads to the weak formulation for the ungauged problem: find $\\mathbf{A} \\in \\mathbf{V}$ such that for all $\\mathbf{v} \\in \\mathbf{V}$,\n$$\n(\\nabla \\times \\mathbf{A}, \\nabla \\times \\mathbf{v})_{L^2} + \\alpha (\\mathbf{A}, \\mathbf{v})_{L^2} = (\\mathbf{J}, \\mathbf{v})_{L^2}\n$$\nwhere $(\\cdot, \\cdot)_{L^2}$ denotes the $L^2$ inner product over $\\Omega$.\n\nNow, we incorporate the Coulomb gauge constraint, $\\nabla \\cdot \\mathbf{A} = 0$.\n\n**1. Penalty Method**\nThe penalty method augments the weak formulation with a term that penalizes deviations from the constraint. The problem specifies a particular discrete form of the penalty. The discrete system to be solved is given as:\n$$\n(K + \\beta M_e G G^\\top M_e)\\mathbf{a} = \\mathbf{j}\n$$\nHere, $\\mathbf{a}$ and $\\mathbf{j}$ are the vectors of coefficients for the discrete potential and source, respectively. The matrix $K = C^\\top M_f C + \\alpha M_e$ represents the discretization of the left-hand side of the ungauged weak form. The term $G^\\top M_e$ is the discrete divergence operator $D$, and $M_e G G^\\top M_e$ is a matrix representation of the penalty. The corresponding discrete weak form is:\n$$\n\\mathbf{v}^\\top K \\mathbf{a} + \\beta (G^\\top M_e \\mathbf{v})^\\top (G^\\top M_e \\mathbf{a}) = \\mathbf{v}^\\top \\mathbf{j}\n$$\nThis form penalizes the squared Euclidean norm of the discrete divergence vector $D\\mathbf{a} = G^\\top M_e \\mathbf{a}$, with $\\beta > 0$ as the penalty parameter. As $\\beta \\to \\infty$, the solution $\\mathbf{a}$ is driven towards satisfying $D\\mathbf{a} = 0$.\n\n**2. Lagrange Multiplier Method**\nThis method introduces a Lagrange multiplier field, $p$, to enforce the constraint exactly. The natural function space for this multiplier is $Q = H^1(\\Omega)$. We seek a saddle point $(\\mathbf{A}, p) \\in \\mathbf{V} \\times Q$ of a Lagrangian functional. This leads to a mixed weak formulation. The problem specifies a discrete system:\n$$\n\\begin{bmatrix}\nK & -M_e G \\\\\nG^\\top M_e & -\\tau I\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{a} \\\\\n\\boldsymbol{\\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{j} \\\\\n\\mathbf{0}\n\\end{bmatrix}\n$$\nThis system is the discrete representation of the following mixed weak formulation: Find $(\\mathbf{A}, p) \\in \\mathbf{V} \\times Q$ such that for all test functions $(\\mathbf{v}, q) \\in \\mathbf{V} \\times Q$:\n$$\n(\\nabla \\times \\mathbf{A}, \\nabla \\times \\mathbf{v}) + \\alpha(\\mathbf{A}, \\mathbf{v}) - (\\mathbf{v}, \\nabla p) = (\\mathbf{J}, \\mathbf{v})\n$$\n$$\n(\\nabla \\cdot \\mathbf{A}, q) - \\tau(p, q) = 0\n$$\nThe choice of sign for the coupling term $(\\mathbf{v}, \\nabla p)$ is a convention; the negative sign given here leads to the $-M_e G$ block in the system matrix. This term discretizes to $\\mathbf{v}^\\top M_e G \\boldsymbol{\\lambda}$ if the multiplier variables are $\\boldsymbol{\\lambda}$. The second equation enforces the Coulomb gauge weakly, as $(\\nabla \\cdot \\mathbf{A}, q) = -(\\mathbf{A}, \\nabla q)$, which discretizes to $\\boldsymbol{q}^\\top G^\\top M_e \\mathbf{a}$. The small parameter $\\tau > 0$ introduces a stabilization term $-\\tau (p,q)$ which ensures the full system matrix is invertible by removing the constant null-space of the multiplier $p$.\n\n**Discretization on a Structured Mesh**\nThe problem prescribes a discretization based on a structured rectangular mesh and concepts from finite element exterior calculus. The vector potential $\\mathbf{A}$ is approximated using Nédélec edge elements, where degrees of freedom are the tangential components of $\\mathbf{A}$ along each edge of the mesh. The Lagrange multiplier $p$ is approximated using standard nodal elements.\n- The matrix $G$ is the discrete gradient operator, mapping nodal values to edge values.\n- The matrix $C$ is the discrete curl operator, mapping edge values to face values.\n- $M_e$ and $M_f$ are mass matrices that account for the geometric size of edges and faces, turning sums into discrete integral approximations.\nThe composite operator $C^\\top M_f C$ is the discrete representation of the vector Laplacian operator $\\nabla \\times \\nabla \\times$. The operator $G^\\top M_e$ is the discrete divergence. This framework ensures that fundamental identities like $\\nabla \\times (\\nabla \\phi) = 0$ hold exactly at the discrete level as $C G = 0$. The implementation will construct these discrete operators and solve the specified linear systems for each test case, finally reporting the Euclidean norm of the discrete divergence vector $D\\mathbf{a} = G^\\top M_e \\mathbf{a}$ as a measure of gauge enforcement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef source_field_J(x, y):\n    \"\"\"Computes the source vector field J at a given point (x, y).\"\"\"\n    Jx = np.sin(np.pi * x) * np.cos(np.pi * y)\n    Jy = -np.cos(np.pi * x) * np.sin(np.pi * y)\n    return np.array([Jx, Jy])\n\ndef build_operators(Nx, Ny):\n    \"\"\"\n    Constructs the discrete operators G, C and mass matrices Me, Mf\n    for a structured rectangular mesh of size Nx by Ny.\n    \"\"\"\n    dx, dy = 1.0 / Nx, 1.0 / Ny\n    \n    # --- Indexing ---\n    num_nodes = (Nx + 1) * (Ny + 1)\n    num_h_edges = Nx * (Ny + 1)\n    num_v_edges = (Nx + 1) * Ny\n    num_edges = num_h_edges + num_v_edges\n    num_faces = Nx * Ny\n    \n    # Helper functions for indexing\n    def node_idx(i, j): return j * (Nx + 1) + i\n    def h_edge_idx(i, j): return j * Nx + i\n    def v_edge_idx(i, j): return num_h_edges + i * Ny + j\n    def face_idx(i, j): return j * Nx + i\n\n    # --- Gradient Operator G (nodes to edges) ---\n    G = sparse.lil_matrix((num_edges, num_nodes), dtype=np.float64)\n    # Horizontal edges\n    for j in range(Ny + 1):\n        for i in range(Nx):\n            edge = h_edge_idx(i, j)\n            node_tail = node_idx(i, j)\n            node_head = node_idx(i + 1, j)\n            G[edge, node_tail] = -1\n            G[edge, node_head] = 1\n    # Vertical edges\n    for i in range(Nx + 1):\n        for j in range(Ny):\n            edge = v_edge_idx(i, j)\n            node_tail = node_idx(i, j)\n            node_head = node_idx(i, j + 1)\n            G[edge, node_tail] = -1\n            G[edge, node_head] = 1\n\n    # --- Curl Operator C (edges to faces) ---\n    C = sparse.lil_matrix((num_faces, num_edges), dtype=np.float64)\n    for j in range(Ny):\n        for i in range(Nx):\n            face = face_idx(i, j)\n            # Bottom, Right, Top, Left edges\n            edge_b = h_edge_idx(i, j)\n            edge_r = v_edge_idx(i + 1, j)\n            edge_t = h_edge_idx(i, j + 1)\n            edge_l = v_edge_idx(i, j)\n            # CCW orientation: +1, +1, -1, -1\n            C[face, edge_b] = 1\n            C[face, edge_r] = 1\n            C[face, edge_t] = -1\n            C[face, edge_l] = -1\n\n    # --- Mass Matrices ---\n    # Edge mass matrix Me\n    me_diag = np.concatenate([np.full(num_h_edges, dx), np.full(num_v_edges, dy)])\n    Me = sparse.diags(me_diag, format='csr')\n    # Face mass matrix Mf\n    mf_diag = np.full(num_faces, dx * dy)\n    Mf = sparse.diags(mf_diag, format='csr')\n    \n    return G.tocsr(), C.tocsr(), Me, Mf\n\ndef assemble_source_vector(Nx, Ny):\n    \"\"\"Assembles the source vector j by projecting J onto edge tangents.\"\"\"\n    dx, dy = 1.0 / Nx, 1.0 / Ny\n    num_h_edges = Nx * (Ny + 1)\n    num_v_edges = (Nx + 1) * Ny\n    num_edges = num_h_edges + num_v_edges\n\n    j_vec = np.zeros(num_edges)\n\n    # Horizontal edges\n    for j_idx in range(Ny + 1):\n        for i_idx in range(Nx):\n            mid_x = (i_idx + 0.5) * dx\n            mid_y = j_idx * dy\n            Jx, _ = source_field_J(mid_x, mid_y)\n            edge_idx = j_idx * Nx + i_idx\n            j_vec[edge_idx] = Jx * dx\n\n    # Vertical edges\n    for i_idx in range(Nx + 1):\n        for j_idx in range(Ny):\n            mid_x = i_idx * dx\n            mid_y = (j_idx + 0.5) * dy\n            _, Jy = source_field_J(mid_x, mid_y)\n            edge_idx = num_h_edges + i_idx * Ny + j_idx\n            j_vec[edge_idx] = Jy * dy\n            \n    return j_vec\n\ndef solve():\n    \"\"\"\n    Solves the magnetostatic problem for the specified test cases and\n    prints the norms of the discrete divergence.\n    \"\"\"\n    test_cases = [\n        {'Nx': 4, 'Ny': 4, 'alpha': 1.0, 'method': 'penalty', 'param': 0.0},\n        {'Nx': 4, 'Ny': 4, 'alpha': 1.0, 'method': 'penalty', 'param': 1.0},\n        {'Nx': 4, 'Ny': 4, 'alpha': 1.0, 'method': 'penalty', 'param': 1e6},\n        {'Nx': 4, 'Ny': 4, 'alpha': 1.0, 'method': 'lagrange', 'param': 1e-8},\n        {'Nx': 1, 'Ny': 1, 'alpha': 1.0, 'method': 'lagrange', 'param': 1e-8},\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny = case['Nx'], case['Ny']\n        alpha = case['alpha']\n        method = case['method']\n        param = case['param']\n\n        G, C, Me, Mf = build_operators(Nx, Ny)\n        j = assemble_source_vector(Nx, Ny)\n\n        K = C.transpose() @ Mf @ C + alpha * Me\n\n        if method == 'penalty':\n            beta = param\n            # System: (K + beta * Me @ G @ G.T @ Me) a = j\n            A_pen = K + beta * Me @ G @ G.transpose() @ Me\n            a = spsolve(A_pen, j)\n        \n        elif method == 'lagrange':\n            tau = param\n            num_edges = K.shape[0]\n            num_nodes = G.shape[1]\n            \n            # System matrix A_lag\n            A_lag = sparse.bmat([\n                [K, - Me @ G],\n                [G.transpose() @ Me, sparse.diags([-tau] * num_nodes, format='csr')]\n            ], format='csc')\n            \n            # RHS vector b_lag\n            b_lag = np.concatenate([j, np.zeros(num_nodes)])\n            \n            sol = spsolve(A_lag, b_lag)\n            a = sol[:num_edges]\n            \n        # Compute discrete divergence and its norm\n        div_a = G.transpose() @ Me @ a\n        norm_div_a = np.linalg.norm(div_a)\n        results.append(norm_div_a)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In spectral methods, which operate in Fourier space, gauge conditions are enforced through projection operators whose theoretical elegance can mask significant numerical challenges. This exercise delves into the Helmholtz-Hodge decomposition, which separates a vector field into its longitudinal (curl-free) and transverse (divergence-free) parts—a process essential for enforcing the Coulomb gauge. By implementing the transverse projector and confronting the inherent singularity at the $\\mathbf{k}=\\mathbf{0}$ wavevector , you will quantify the errors introduced by numerical regularization and develop a crucial appreciation for the subtleties of algorithm design in spectral solvers.",
            "id": "3325815",
            "problem": "Consider a three-dimensional periodic domain of side length $L$ discretized uniformly into $N \\times N \\times N$ grid points. Let $\\mathbf{J}(\\mathbf{x})$ be a vector field representing a current density sampled on this grid. In computational electromagnetics, algorithms that enforce the Coulomb gauge condition ($\\nabla \\cdot \\mathbf{A} = 0$ for the vector potential $\\mathbf{A}$) and separate longitudinal and transverse components of $\\mathbf{J}$ rely on spectral (Fourier-space) Helmholtz decomposition. The continuity equation $\\nabla \\cdot \\mathbf{J} + \\partial_t \\rho = 0$ and Maxwell's equations motivate the separation of $\\mathbf{J}$ into a divergence-free (transverse) part and a curl-free (longitudinal) part. In a spectral solver, this is achieved by applying a projection operator in wavevector space to isolate the transverse component. However, implementing this projection numerically requires careful treatment of the $\\mathbf{k} = \\mathbf{0}$ mode and small $|\\mathbf{k}|$, where the operator becomes ill-conditioned.\n\nYour task is to:\n- Derive, from the Fourier-space statement of the Helmholtz decomposition and the properties of the divergence and curl, the form of the transverse projection operator that maps any $\\mathbf{J}$ to a divergence-free component in wavevector space.\n- Implement this projection in a spectral solver and quantify numerical errors introduced by regularizing the operator near $\\mathbf{k} = \\mathbf{0}$. Use a regularized denominator controlled by a parameter $\\varepsilon > 0$ in your implementation.\n- Construct a synthetic $\\mathbf{J}(\\mathbf{x})$ that contains both longitudinal and transverse components, as well as a nonzero spatially uniform (direct current) component, so that all relevant behaviors of the projection are exercised. Use smooth trigonometric fields with fundamental wavenumber $k_1 = 2\\pi/L$ for the construction.\n\nFundamental base to start from:\n- Maxwell's equations in differential form and the continuity equation $\\nabla \\cdot \\mathbf{J} + \\partial_t \\rho = 0$.\n- Helmholtz decomposition: every suitably smooth vector field on a periodic domain can be uniquely decomposed into a divergence-free component and a curl-free component.\n- Fourier transform properties of spatial derivatives: for a function $f(\\mathbf{x})$ with Fourier transform $\\hat{f}(\\mathbf{k})$, $\\nabla f \\leftrightarrow i\\mathbf{k}\\hat{f}$ and $\\nabla \\cdot \\mathbf{v} \\leftrightarrow i\\mathbf{k} \\cdot \\hat{\\mathbf{v}}$ for a vector field $\\mathbf{v}$.\n\nImplementation details:\n- Use a periodic cubic domain with $L = 64\\pi$ and $N = 32$. Let $k_1 = 2\\pi / L$. Define the scalar potential $\\phi(\\mathbf{x}) = a \\cos(k_1 x) + b \\cos(k_1 y) + c \\cos(k_1 z)$ with constants $a=1.1$, $b=0.9$, and $c=1.3$. Define the vector potential $\\mathbf{W}(\\mathbf{x}) = \\big(A \\sin(k_1 y) + A_2 \\sin(2k_1 y),\\; B \\sin(k_1 z),\\; C \\sin(k_1 x)\\big)$ with constants $A=0.7$, $A_2=0.2$, $B=0.5$, and $C=0.8$. Construct the current field as\n$$\n\\mathbf{J}(\\mathbf{x}) = \\nabla \\phi(\\mathbf{x}) + \\nabla \\times \\mathbf{W}(\\mathbf{x}) + \\mathbf{d},\n$$\nwhere $\\mathbf{d} = (0.05, -0.03, 0.02)$ is a constant vector. Compute $\\nabla \\phi$ and $\\nabla \\times \\mathbf{W}$ analytically at the grid points.\n- Implement the spectral projection by transforming $\\mathbf{J}$ to Fourier space, applying a regularized transverse projection with parameter $\\varepsilon$, and transforming back. For the exact reference, implement the non-regularized projection with exact handling at $\\mathbf{k}=\\mathbf{0}$ consistent with the periodic Helmholtz decomposition.\n- Quantify the following errors entirely in Fourier space using Parseval's theorem (no physical units are required):\n    1. The normalized divergence residual of the projected field,\n    $$\n    D(\\varepsilon) = \\frac{\\left\\|\\mathbf{k} \\cdot \\widehat{\\mathbf{J}_\\perp^{(\\varepsilon)}}\\right\\|_2}{\\left\\|\\widehat{\\mathbf{J}}\\right\\|_2},\n    $$\n    where $\\widehat{\\mathbf{J}_\\perp^{(\\varepsilon)}}$ is the Fourier transform of the regularized projected field, and $\\|\\cdot\\|_2$ denotes the Euclidean norm over all discrete wavevectors.\n    2. The relative difference to the exact transverse projection,\n    $$\n    E(\\varepsilon) = \\frac{\\left\\|\\widehat{\\mathbf{J}_\\perp^{(\\varepsilon)}} - \\widehat{\\mathbf{J}_\\perp^{\\text{exact}}}\\right\\|_2}{\\left\\|\\widehat{\\mathbf{J}_\\perp^{\\text{exact}}}\\right\\|_2},\n    $$\n    where $\\widehat{\\mathbf{J}_\\perp^{\\text{exact}}}$ is the Fourier transform of the exact (non-regularized) transverse projection with appropriate treatment of $\\mathbf{k}=\\mathbf{0}$.\n    3. The idempotence error of the regularized projection (deviation from applying the projection twice being the same as once),\n    $$\n    I(\\varepsilon) = \\frac{\\left\\|\\widehat{P_\\varepsilon\\left(P_\\varepsilon \\mathbf{J}\\right)} - \\widehat{P_\\varepsilon \\mathbf{J}}\\right\\|_2}{\\left\\|\\widehat{P_\\varepsilon \\mathbf{J}}\\right\\|_2},\n    $$\n    where $\\widehat{P_\\varepsilon \\mathbf{J}}$ denotes the regularized projected field in Fourier space.\n\nTest suite:\n- Use three values of the regularization parameter $\\varepsilon$ to probe different regimes relative to the smallest nonzero wavenumber $k_{\\min} = 2\\pi/L$:\n    1. $\\varepsilon_1 = 10^{-18} k_{\\min}$ (negligible regularization).\n    2. $\\varepsilon_2 = k_{\\min}$ (regularization comparable to the smallest nonzero wavenumber).\n    3. $\\varepsilon_3 = 5 k_{\\min}$ (strong regularization).\n- For each $\\varepsilon$ in the test suite, compute and report the triple $\\big(D(\\varepsilon), E(\\varepsilon), I(\\varepsilon)\\big)$ as floating-point values.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case result itself being a comma-separated list of the three floating-point numbers enclosed in square brackets. For example, the output should have the form\n$$\n[ [D(\\varepsilon_1),E(\\varepsilon_1),I(\\varepsilon_1)], [D(\\varepsilon_2),E(\\varepsilon_2),I(\\varepsilon_2)], [D(\\varepsilon_3),E(\\varepsilon_3),I(\\varepsilon_3)] ].\n$$\nAngles are not used, and there are no physical units; all quantities are dimensionless.",
            "solution": "The problem is valid as it is scientifically grounded in Maxwell's theory and vector calculus, is well-posed with all necessary data provided, and is stated in objective, formal language. We will proceed with a solution.\n\nThe core of the problem is the Helmholtz-Hodge decomposition of a vector field $\\mathbf{J}$ on a periodic domain into a curl-free (longitudinal) component $\\mathbf{J}_L$ and a divergence-free (transverse) component $\\mathbf{J}_T$:\n$$\n\\mathbf{J} = \\mathbf{J}_L + \\mathbf{J}_T\n$$\nwhere $\\nabla \\times \\mathbf{J}_L = \\mathbf{0}$ and $\\nabla \\cdot \\mathbf{J}_T = \\mathbf{0}$. The decomposition also includes a harmonic component, which for a periodic domain is simply a constant vector. The problem statement's construction $\\mathbf{J}(\\mathbf{x}) = \\nabla \\phi(\\mathbf{x}) + \\nabla \\times \\mathbf{W}(\\mathbf{x}) + \\mathbf{d}$ explicitly separates the field into its longitudinal part $\\mathbf{J}_L = \\nabla \\phi$, its transverse part $\\mathbf{J}_T' = \\nabla \\times \\mathbf{W}$, and a constant (DC) component $\\mathbf{d}$. A constant vector is both curl-free and divergence-free. By convention in periodic systems, the longitudinal field is required to have zero spatial average. This implies that the constant part $\\mathbf{d}$ is assigned to the transverse component, making the full transverse field $\\mathbf{J}_T = \\nabla \\times \\mathbf{W} + \\mathbf{d}$.\n\nThe separation is most conveniently performed in Fourier space. Let $\\hat{\\mathbf{J}}(\\mathbf{k})$ be the Fourier transform of $\\mathbf{J}(\\mathbf{x})$. The differential operators for divergence and curl become algebraic operations in Fourier space:\n$$\n\\nabla \\cdot \\mathbf{J} \\quad \\xrightarrow{\\mathcal{F}} \\quad i\\mathbf{k} \\cdot \\hat{\\mathbf{J}}(\\mathbf{k})\n$$\n$$\n\\nabla \\times \\mathbf{J} \\quad \\xrightarrow{\\mathcal{F}} \\quad i\\mathbf{k} \\times \\hat{\\mathbf{J}}(\\mathbf{k})\n$$\nThe conditions on the longitudinal and transverse components in Fourier space are:\n$$\n\\mathbf{k} \\times \\hat{\\mathbf{J}}_L(\\mathbf{k}) = \\mathbf{0}\n$$\n$$\n\\mathbf{k} \\cdot \\hat{\\mathbf{J}}_T(\\mathbf{k}) = \\mathbf{0}\n$$\nFor any non-zero wavevector $\\mathbf{k}$, the condition $\\mathbf{k} \\times \\hat{\\mathbf{J}}_L = \\mathbf{0}$ implies that $\\hat{\\mathbf{J}}_L$ must be parallel to $\\mathbf{k}$. The condition $\\mathbf{k} \\cdot \\hat{\\mathbf{J}}_T = \\mathbf{0}$ implies that $\\hat{\\mathbf{J}}_T$ must be perpendicular to $\\mathbf{k}$.\n\nTo find the longitudinal component $\\hat{\\mathbf{J}}_L$, we project the total field $\\hat{\\mathbf{J}}$ onto the direction of the wavevector $\\mathbf{k}$. The projection of a vector $\\mathbf{A}$ onto a vector $\\mathbf{B}$ is given by $\\frac{\\mathbf{A} \\cdot \\mathbf{B}}{|\\mathbf{B}|^2}\\mathbf{B}$. Thus, for $\\mathbf{k} \\neq \\mathbf{0}$:\n$$\n\\hat{\\mathbf{J}}_L(\\mathbf{k}) = \\frac{\\hat{\\mathbf{J}}(\\mathbf{k}) \\cdot \\mathbf{k}}{|\\mathbf{k}|^2}\\mathbf{k}\n$$\nThis can be expressed using a projection operator. In dyadic notation, the longitudinal projection operator is $\\hat{P}_L(\\mathbf{k}) = \\frac{\\mathbf{k} \\otimes \\mathbf{k}}{|\\mathbf{k}|^2}$. In Cartesian index notation, this is $(\\hat{P}_L)_{ij} = \\frac{k_i k_j}{|\\mathbf{k}|^2}$.\n\nThe transverse component is then found by subtracting the longitudinal component from the total field:\n$$\n\\hat{\\mathbf{J}}_T(\\mathbf{k}) = \\hat{\\mathbf{J}}(\\mathbf{k}) - \\hat{\\mathbf{J}}_L(\\mathbf{k}) = \\hat{\\mathbf{J}}(\\mathbf{k}) - \\frac{(\\hat{\\mathbf{J}}(\\mathbf{k}) \\cdot \\mathbf{k})}{|\\mathbf{k}|^2}\\mathbf{k}\n$$\nThe transverse projection operator $\\hat{P}_T$ is therefore $\\hat{P}_T = I - \\hat{P}_L$, where $I$ is the identity operator. Its explicit form is:\n$$\n(\\hat{P}_T)_{ij} = \\delta_{ij} - \\frac{k_i k_j}{|\\mathbf{k}|^2}\n$$\nwhere $\\delta_{ij}$ is the Kronecker delta.\n\nA critical issue arises at $\\mathbf{k} = \\mathbf{0}$, where the denominator $|\\mathbf{k}|^2$ is zero, making the operator singular. The $\\mathbf{k} = \\mathbf{0}$ mode represents the spatially uniform (DC) component of the field, which is the spatial average. As previously noted, a constant vector is both divergence-free and curl-free. The unique decomposition on a periodic domain requires the longitudinal component to have zero mean, i.e., $\\hat{\\mathbf{J}}_L(\\mathbf{k}=\\mathbf{0}) = \\mathbf{0}$. Consequently, the entire DC component of $\\mathbf{J}$ must be attributed to the transverse part:\n$$\n\\hat{\\mathbf{J}}_T(\\mathbf{k}=\\mathbf{0}) = \\hat{\\mathbf{J}}(\\mathbf{k}=\\mathbf{0})\n$$\nThis defines the \"exact\" projection numerically: one formula for $\\mathbf{k} \\neq \\mathbf{0}$ and a special case for $\\mathbf{k} = \\mathbf{0}$.\n\nA common numerical technique to handle this singularity is regularization. The denominator $|\\mathbf{k}|^2$ is replaced by a regularized version, $|\\mathbf{k}|^2 + \\varepsilon^2$, where $\\varepsilon$ is a small positive parameter. The regularized transverse projection of $\\hat{\\mathbf{J}}$ is:\n$$\n\\widehat{\\mathbf{J}_\\perp^{(\\varepsilon)}}(\\mathbf{k}) = \\hat{\\mathbf{J}}(\\mathbf{k}) - \\frac{(\\hat{\\mathbf{J}}(\\mathbf{k}) \\cdot \\mathbf{k})}{|\\mathbf{k}|^2 + \\varepsilon^2}\\mathbf{k}\n$$\nThis formulation has the advantage of being non-singular for all $\\mathbf{k}$. At $\\mathbf{k}=\\mathbf{0}$, the numerator $(\\hat{\\mathbf{J}} \\cdot \\mathbf{k})\\mathbf{k}$ is $\\mathbf{0}$, and the denominator is $\\varepsilon^2 \\neq 0$. Thus, the subtractive term vanishes, and we correctly obtain $\\widehat{\\mathbf{J}_\\perp^{(\\varepsilon)}}(\\mathbf{k}=\\mathbf{0}) = \\hat{\\mathbf{J}}(\\mathbf{k}=\\mathbf{0})$, consistent with the exact treatment. However, for $\\mathbf{k} \\neq \\mathbf{0}$, this operator is only an approximation of the true transverse projection. The parameter $\\varepsilon$ controls the trade-off: a smaller $\\varepsilon$ gives a better approximation for large $|\\mathbf{k}|$ but can lead to floating-point issues for very small non-zero $|\\mathbf{k}|$. The purpose of this exercise is to quantify this approximation error.\n\nThe algorithm to be implemented is as follows:\n1.  Define the computational domain with $L=64\\pi$ and $N=32$ points per dimension.\n2.  Construct the spatial grid and the corresponding wavevector grid using `fftfreq`. The smallest non-zero wavenumber magnitude is $k_{\\min} = 2\\pi/L$.\n3.  Analytically compute the components of the current density $\\mathbf{J}(\\mathbf{x}) = \\nabla \\phi(\\mathbf{x}) + \\nabla \\times \\mathbf{W}(\\mathbf{x}) + \\mathbf{d}$ on the spatial grid.\n4.  Compute the 3D discrete Fourier transform of each component of $\\mathbf{J}$ to obtain $\\hat{J}_x, \\hat{J}_y, \\hat{J}_z$.\n5.  Calculate the norm of $\\hat{\\mathbf{J}}$, $\\left\\|\\widehat{\\mathbf{J}}\\right\\|_2$, for use in normalization.\n6.  Implement the exact projection $\\widehat{\\mathbf{J}_\\perp^{\\text{exact}}}$ by applying the projection operator with a specific check to handle the $\\mathbf{k}=\\mathbf{0}$ mode as described.\n7.  For each given value of the regularization parameter $\\varepsilon$, implement the regularized projection $\\widehat{\\mathbf{J}_\\perp^{(\\varepsilon)}}$.\n8.  Calculate the error metrics $D(\\varepsilon)$, $E(\\varepsilon)$, and $I(\\varepsilon)$ by computing the required dot products and norms entirely in Fourier space. For the idempotence error $I(\\varepsilon)$, the regularized projection operator is applied a second time to the already projected field. All norms are standard Euclidean norms over the complex-valued grid functions in k-space.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational electromagnetics problem of spectral projection.\n    \"\"\"\n    # 1. Define parameters and construct grids\n    L = 64.0 * np.pi\n    N = 32\n    a, b, c = 1.1, 0.9, 1.3\n    A, A2, B, C = 0.7, 0.2, 0.5, 0.8\n    d = np.array([0.05, -0.03, 0.02])\n    \n    k1 = 2.0 * np.pi / L\n    k_min = k1\n\n    # Spatial grid\n    grid_1d = np.linspace(0, L, N, endpoint=False)\n    x, y, z = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n    # 2. Construct the synthetic current density J(x)\n    # J_L = grad(phi)\n    J_L_x = -a * k1 * np.sin(k1 * x)\n    J_L_y = -b * k1 * np.sin(k1 * y)\n    J_L_z = -c * k1 * np.sin(k1 * z)\n    \n    # J_T' = curl(W)\n    J_T_prime_x = -B * k1 * np.cos(k1 * z)\n    J_T_prime_y = -C * k1 * np.cos(k1 * x)\n    J_T_prime_z = -(A * k1 * np.cos(k1 * y) + 2.0 * A2 * k1 * np.cos(2.0 * k1 * y))\n    \n    # Total J = J_L + J_T' + d\n    Jx = J_L_x + J_T_prime_x + d[0]\n    Jy = J_L_y + J_T_prime_y + d[1]\n    Jz = J_L_z + J_T_prime_z + d[2]\n\n    # 3. Transform to Fourier space\n    J_hat_x = np.fft.fftn(Jx)\n    J_hat_y = np.fft.fftn(Jy)\n    J_hat_z = np.fft.fftn(Jz)\n\n    # 4. Construct wavevector grid\n    k_vec = 2.0 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_vec, k_vec, k_vec, indexing='ij')\n\n    k_sq = kx**2 + ky**2 + kz**2\n\n    # 5. Compute total norm of J_hat\n    norm_J_hat = np.sqrt(np.sum(np.abs(J_hat_x)**2 + np.abs(J_hat_y)**2 + np.abs(J_hat_z)**2))\n\n    # Dot product J_hat . k\n    J_hat_dot_k = J_hat_x * kx + J_hat_y * ky + J_hat_z * kz\n\n    # 6. Implement exact transverse projection\n    k_sq_safe = np.copy(k_sq)\n    k_sq_safe[0, 0, 0] = 1.0  # Avoid division by zero, will be corrected\n    \n    J_L_factor = J_hat_dot_k / k_sq_safe\n    J_L_hat_x = J_L_factor * kx\n    J_L_hat_y = J_L_factor * ky\n    J_L_hat_z = J_L_factor * kz\n    \n    # Enforce zero mean for longitudinal part\n    J_L_hat_x[0, 0, 0] = 0.0\n    J_L_hat_y[0, 0, 0] = 0.0\n    J_L_hat_z[0, 0, 0] = 0.0\n    \n    J_T_exact_hat_x = J_hat_x - J_L_hat_x\n    J_T_exact_hat_y = J_hat_y - J_L_hat_y\n    J_T_exact_hat_z = J_hat_z - J_L_hat_z\n    \n    norm_J_T_exact_hat = np.sqrt(np.sum(np.abs(J_T_exact_hat_x)**2 + np.abs(J_T_exact_hat_y)**2 + np.abs(J_T_exact_hat_z)**2))\n\n    # 7. Test suite\n    eps_values = [1e-18 * k_min, k_min, 5.0 * k_min]\n    results = []\n    \n    for eps in eps_values:\n        # a. Regularized projection\n        k_sq_reg = k_sq + eps**2\n        J_L_reg_factor = J_hat_dot_k / k_sq_reg\n        \n        J_L_reg_hat_x = J_L_reg_factor * kx\n        J_L_reg_hat_y = J_L_reg_factor * ky\n        J_L_reg_hat_z = J_L_reg_factor * kz\n\n        J_T_reg_hat_x = J_hat_x - J_L_reg_hat_x\n        J_T_reg_hat_y = J_hat_y - J_L_reg_hat_y\n        J_T_reg_hat_z = J_hat_z - J_L_reg_hat_z\n        \n        # b. Calculate divergence residual D(eps)\n        div_J_T_reg = kx * J_T_reg_hat_x + ky * J_T_reg_hat_y + kz * J_T_reg_hat_z\n        norm_div_J_T_reg = np.sqrt(np.sum(np.abs(div_J_T_reg)**2))\n        D_eps = norm_div_J_T_reg / norm_J_hat\n\n        # c. Calculate relative difference E(eps)\n        diff_E_x = J_T_reg_hat_x - J_T_exact_hat_x\n        diff_E_y = J_T_reg_hat_y - J_T_exact_hat_y\n        diff_E_z = J_T_reg_hat_z - J_T_exact_hat_z\n        norm_diff_E = np.sqrt(np.sum(np.abs(diff_E_x)**2 + np.abs(diff_E_y)**2 + np.abs(diff_E_z)**2))\n        E_eps = norm_diff_E / norm_J_T_exact_hat\n\n        # d. Calculate idempotence error I(eps)\n        # Project J_T_reg again\n        J_T_reg_hat_dot_k = J_T_reg_hat_x * kx + J_T_reg_hat_y * ky + J_T_reg_hat_z * kz\n        J_L_of_J_T_reg_factor = J_T_reg_hat_dot_k / k_sq_reg\n        \n        J_L_of_J_T_reg_x = J_L_of_J_T_reg_factor * kx\n        J_L_of_J_T_reg_y = J_L_of_J_T_reg_factor * ky\n        J_L_of_J_T_reg_z = J_L_of_J_T_reg_factor * kz\n\n        # P_eps(P_eps(J)) = P_eps(J) - P_L_eps(P_eps(J))\n        # The difference P_eps(P_eps(J)) - P_eps(J) is simply -P_L_eps(P_eps(J))\n        diff_I_x = -J_L_of_J_T_reg_x\n        diff_I_y = -J_L_of_J_T_reg_y\n        diff_I_z = -J_L_of_J_T_reg_z\n\n        norm_diff_I = np.sqrt(np.sum(np.abs(diff_I_x)**2 + np.abs(diff_I_y)**2 + np.abs(diff_I_z)**2))\n        norm_J_T_reg_hat = np.sqrt(np.sum(np.abs(J_T_reg_hat_x)**2 + np.abs(J_T_reg_hat_y)**2 + np.abs(J_T_reg_hat_z)**2))\n        I_eps = norm_diff_I / norm_J_T_reg_hat\n        \n        results.append([D_eps, E_eps, I_eps])\n\n    # 8. Format and print the final result\n    # Convert the list of lists to the specified string format\n    result_str = \"[\" + \", \".join([f\"[{d},{e},{i}]\" for d, e, i in results]) + \"]\"\n    print(result_str.replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}