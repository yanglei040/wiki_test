{
    "hands_on_practices": [
        {
            "introduction": "The foundation of the finite element method (FEM) lies in approximating solutions on small, simple geometric domains called elements. This first practice takes you to the heart of this process, where you will derive the local system matrices on a single canonical element from first principles. By explicitly computing the \"mass\" and \"stiffness\" matrices for Whitney forms on a tetrahedron, you will gain a concrete understanding of how the choice of basis functions and the underlying physics of Maxwell's equations give rise to fundamental matrix properties like symmetry and rank-deficiency .",
            "id": "3324064",
            "problem": "Consider the canonical reference tetrahedron with vertices at $\\mathbf{v}_{0}=(0,0,0)$, $\\mathbf{v}_{1}=(1,0,0)$, $\\mathbf{v}_{2}=(0,1,0)$, and $\\mathbf{v}_{3}=(0,0,1)$. Let the barycentric coordinates be $\\lambda_{0}=1-x-y-z$, $\\lambda_{1}=x$, $\\lambda_{2}=y$, and $\\lambda_{3}=z$. In computational electromagnetics, the edge (Whitney $1$-form) basis functions on a tetrahedron are defined for an oriented edge $(i,j)$ by\n$$\n\\mathbf{N}_{ij}=\\lambda_{i}\\nabla\\lambda_{j}-\\lambda_{j}\\nabla\\lambda_{i}.\n$$\nAssume constant, positive material parameters: electrical permittivity $\\epsilon0$ and magnetic permeability $\\mu0$. The local mass matrix $\\mathbf{M}$ (from the $L^{2}$ inner product of the edge basis functions) and the local curl-curl stiffness matrix $\\mathbf{K}$ (from the $\\mathbf{H}(\\mathrm{curl})$ bilinear form) are defined by\n$$\nM_{(ij),(kl)}=\\int_{T}\\epsilon\\,\\mathbf{N}_{ij}\\cdot\\mathbf{N}_{kl}\\,dV,\\qquad\nK_{(ij),(kl)}=\\int_{T}\\mu^{-1}\\left(\\nabla\\times\\mathbf{N}_{ij}\\right)\\cdot\\left(\\nabla\\times\\mathbf{N}_{kl}\\right)\\,dV,\n$$\nwhere $T$ denotes the tetrahedral domain. Using only fundamental laws and core definitions (variational formulation of Maxwell’s equations, vector calculus identities, and properties of barycentric coordinates) and without invoking any shortcut formulas, carry out the following on the single tetrahedral element $T$:\n\n1. Derive the gradients $\\nabla\\lambda_{i}$ for $i\\in\\{0,1,2,3\\}$ and use them to construct the six Whitney $1$-forms associated with the oriented edges $(0,1)$, $(0,2)$, $(0,3)$, $(1,2)$, $(1,3)$, and $(2,3)$.\n2. Compute explicitly all entries of the local mass matrix $\\mathbf{M}$ in the above edge ordering.\n3. Compute explicitly all entries of the local curl-curl stiffness matrix $\\mathbf{K}$ in the above edge ordering.\n4. From first principles, verify the symmetry of both $\\mathbf{M}$ and $\\mathbf{K}$ and determine their ranks on this element.\n\nReport the ranks of $\\mathbf{M}$ and $\\mathbf{K}$ as the final answer, as a row matrix in the form $\\begin{pmatrix}\\mathrm{rank}(\\mathbf{M})  \\mathrm{rank}(\\mathbf{K})\\end{pmatrix}$. No rounding is required. No units should be included in the final answer. The remainder of your work should be fully justified from the stated definitions and well-tested facts, and all mathematical entities must be expressed in LaTeX.",
            "solution": "The problem is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n-   **Vertices of the reference tetrahedron $T$**: $\\mathbf{v}_{0}=(0,0,0)$, $\\mathbf{v}_{1}=(1,0,0)$, $\\mathbf{v}_{2}=(0,1,0)$, and $\\mathbf{v}_{3}=(0,0,1)$.\n-   **Barycentric coordinates**: $\\lambda_{0}=1-x-y-z$, $\\lambda_{1}=x$, $\\lambda_{2}=y$, and $\\lambda_{3}=z$.\n-   **Edge basis function definition (Whitney $1$-form)** for an oriented edge $(i,j)$: $\\mathbf{N}_{ij}=\\lambda_{i}\\nabla\\lambda_{j}-\\lambda_{j}\\nabla\\lambda_{i}$.\n-   **Material parameters**: Constant, positive electrical permittivity $\\epsilon0$ and magnetic permeability $\\mu0$.\n-   **Local mass matrix definition**: $M_{(ij),(kl)}=\\int_{T}\\epsilon\\,\\mathbf{N}_{ij}\\cdot\\mathbf{N}_{kl}\\,dV$.\n-   **Local curl-curl stiffness matrix definition**: $K_{(ij),(kl)}=\\int_{T}\\mu^{-1}\\left(\\nabla\\times\\mathbf{N}_{ij}\\right)\\cdot\\left(\\nabla\\times\\mathbf{N}_{kl}\\right)\\,dV$.\n-   **Tasks**:\n    1.  Derive gradients $\\nabla\\lambda_{i}$ and construct the six Whitney $1$-forms for edges $(0,1)$, $(0,2)$, $(0,3)$, $(1,2)$, $(1,3)$, and $(2,3)$.\n    2.  Compute all entries of the local mass matrix $\\mathbf{M}$.\n    3.  Compute all entries of the local curl-curl stiffness matrix $\\mathbf{K}$.\n    4.  Verify symmetry and determine the ranks of $\\mathbf{M}$ and $\\mathbf{K}$.\n-   **Required final answer**: A row matrix $\\begin{pmatrix}\\mathrm{rank}(\\mathbf{M})  \\mathrm{rank}(\\mathbf{K})\\end{pmatrix}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is analyzed against the validation criteria.\n-   **Scientifically Grounded**: The problem is a standard exercise in the finite element method (FEM) for computational electromagnetics. The definitions of the reference tetrahedron, barycentric coordinates, Whitney forms, and the associated mass and stiffness matrices are fundamental concepts in this field. All definitions and principles are scientifically sound.\n-   **Well-Posed**: The problem is well-posed. The domain and all functions are explicitly defined. The tasks are specific and lead to a unique, meaningful solution based on direct computation.\n-   **Objective**: The problem is stated using precise, unambiguous mathematical and engineering terminology. It is free of subjective or opinion-based content.\n\nThe problem does not exhibit any flaws such as scientific unsoundness, incompleteness, contradiction, or ambiguity. It is a formalizable and substantive problem in its specified domain.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete, reasoned solution will be provided.\n\n### Solution\n\n#### 1. Gradients and Whitney 1-forms\n\nFirst, we compute the gradients of the barycentric coordinates $\\lambda_i$. Let $\\mathbf{g}_i = \\nabla\\lambda_i$.\n$$ \\lambda_0 = 1-x-y-z \\implies \\mathbf{g}_0 = \\nabla\\lambda_0 = -\\mathbf{\\hat{x}} - \\mathbf{\\hat{y}} - \\mathbf{\\hat{z}} = \\begin{pmatrix} -1 \\\\ -1 \\\\ -1 \\end{pmatrix} $$\n$$ \\lambda_1 = x \\implies \\mathbf{g}_1 = \\nabla\\lambda_1 = \\mathbf{\\hat{x}} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\n$$ \\lambda_2 = y \\implies \\mathbf{g}_2 = \\nabla\\lambda_2 = \\mathbf{\\hat{y}} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} $$\n$$ \\lambda_3 = z \\implies \\mathbf{g}_3 = \\nabla\\lambda_3 = \\mathbf{\\hat{z}} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} $$\nNote that $\\sum_{i=0}^{3} \\mathbf{g}_i = \\mathbf{0}$, consistent with $\\sum_{i=0}^{3} \\lambda_i = 1$.\n\nThe six Whitney $1$-forms for the specified edges are constructed using the definition $\\mathbf{N}_{ij} = \\lambda_i \\mathbf{g}_j - \\lambda_j \\mathbf{g}_i$:\n-   $\\mathbf{N}_{01} = \\lambda_0 \\mathbf{g}_1 - \\lambda_1 \\mathbf{g}_0 = (1-x-y-z)\\mathbf{\\hat{x}} - x(-\\mathbf{\\hat{x}}-\\mathbf{\\hat{y}}-\\mathbf{\\hat{z}}) = (1-y-z)\\mathbf{\\hat{x}} + x\\mathbf{\\hat{y}} + x\\mathbf{\\hat{z}}$\n-   $\\mathbf{N}_{02} = \\lambda_0 \\mathbf{g}_2 - \\lambda_2 \\mathbf{g}_0 = (1-x-y-z)\\mathbf{\\hat{y}} - y(-\\mathbf{\\hat{x}}-\\mathbf{\\hat{y}}-\\mathbf{\\hat{z}}) = y\\mathbf{\\hat{x}} + (1-x-z)\\mathbf{\\hat{y}} + y\\mathbf{\\hat{z}}$\n-   $\\mathbf{N}_{03} = \\lambda_0 \\mathbf{g}_3 - \\lambda_3 \\mathbf{g}_0 = (1-x-y-z)\\mathbf{\\hat{z}} - z(-\\mathbf{\\hat{x}}-\\mathbf{\\hat{y}}-\\mathbf{\\hat{z}}) = z\\mathbf{\\hat{x}} + z\\mathbf{\\hat{y}} + (1-x-y)\\mathbf{\\hat{z}}$\n-   $\\mathbf{N}_{12} = \\lambda_1 \\mathbf{g}_2 - \\lambda_2 \\mathbf{g}_1 = x\\mathbf{\\hat{y}} - y\\mathbf{\\hat{x}}$\n-   $\\mathbf{N}_{13} = \\lambda_1 \\mathbf{g}_3 - \\lambda_3 \\mathbf{g}_1 = x\\mathbf{\\hat{z}} - z\\mathbf{\\hat{x}}$\n-   $\\mathbf{N}_{23} = \\lambda_2 \\mathbf{g}_3 - \\lambda_3 \\mathbf{g}_2 = y\\mathbf{\\hat{z}} - z\\mathbf{\\hat{y}}$\n\n#### 2. Local Mass Matrix $\\mathbf{M}$\n\nThe entry $M_{(ij),(kl)}$ is given by $M_{(ij),(kl)} = \\epsilon \\int_T \\mathbf{N}_{ij} \\cdot \\mathbf{N}_{kl} dV$. Substituting the definitions:\n$$ M_{(ij),(kl)} = \\epsilon \\int_T (\\lambda_i \\mathbf{g}_j - \\lambda_j \\mathbf{g}_i) \\cdot (\\lambda_k \\mathbf{g}_l - \\lambda_l \\mathbf{g}_k) dV $$\n$$ M_{(ij),(kl)} = \\epsilon \\left[ (\\mathbf{g}_j \\cdot \\mathbf{g}_l) \\int_T \\lambda_i \\lambda_k dV - (\\mathbf{g}_j \\cdot \\mathbf{g}_k) \\int_T \\lambda_i \\lambda_l dV - (\\mathbf{g}_i \\cdot \\mathbf{g}_l) \\int_T \\lambda_j \\lambda_k dV + (\\mathbf{g}_i \\cdot \\mathbf{g}_k) \\int_T \\lambda_j \\lambda_l dV \\right] $$\nWe use the standard integral formula for barycentric coordinates over a tetrahedron of volume $V_T$: $\\int_T \\lambda_0^a \\lambda_1^b \\lambda_2^c \\lambda_3^d dV = \\frac{a!b!c!d!}{(a+b+c+d+n)!} n! V_T$, where $n=3$ is the dimension. The volume of our reference tetrahedron is $V_T=1/6$. So, $n! V_T = 6 \\times (1/6) = 1$. The formula simplifies to $\\int_T \\lambda_0^a \\lambda_1^b \\lambda_2^c \\lambda_3^d dV = \\frac{a!b!c!d!}{(a+b+c+d+3)!}$.\nThe specific integrals we need are:\n-   $\\int_T \\lambda_i^2 dV = \\frac{2!}{(2+3)!} = \\frac{2}{120} = \\frac{1}{60}$\n-   $\\int_T \\lambda_i \\lambda_j dV = \\frac{1!1!}{(1+1+3)!} = \\frac{1}{120}$ for $i \\neq j$.\n\nWe also need the dot products of the gradients:\n$\\mathbf{g}_0 \\cdot \\mathbf{g}_0=3$, $\\mathbf{g}_1 \\cdot \\mathbf{g}_1=1$, $\\mathbf{g}_2 \\cdot \\mathbf{g}_2=1$, $\\mathbf{g}_3 \\cdot \\mathbf{g}_3=1$.\n$\\mathbf{g}_0 \\cdot \\mathbf{g}_1=-1$, $\\mathbf{g}_0 \\cdot \\mathbf{g}_2=-1$, $\\mathbf{g}_0 \\cdot \\mathbf{g}_3=-1$.\n$\\mathbf{g}_1 \\cdot \\mathbf{g}_2=0$, $\\mathbf{g}_1 \\cdot \\mathbf{g}_3=0$, $\\mathbf{g}_2 \\cdot \\mathbf{g}_3=0$.\n\nLet's compute some representative entries:\n-   $M_{(01),(01)} = \\epsilon \\left[ (\\mathbf{g}_1 \\cdot \\mathbf{g}_1)\\int_T\\lambda_0^2dV - 2(\\mathbf{g}_0 \\cdot \\mathbf{g}_1)\\int_T\\lambda_0\\lambda_1dV + (\\mathbf{g}_0 \\cdot \\mathbf{g}_0)\\int_T\\lambda_1^2dV \\right] = \\epsilon \\left[ (1)\\frac{1}{60} - 2(-1)\\frac{1}{120} + (3)\\frac{1}{60} \\right] = \\epsilon \\left( \\frac{1}{60} + \\frac{2}{120} + \\frac{3}{60} \\right) = \\frac{8\\epsilon}{120} = \\frac{\\epsilon}{15}$. Wait, my previous scratchpad calculation was wrong. Let me recompute. $(1/60) + (2/120) + (3/60) = 1/60 + 1/60 + 3/60 = 5/60 = \\epsilon/12$. My scratchpad was right the first time. The text is correct.\n-   $M_{(12),(12)} = \\epsilon \\left[ (\\mathbf{g}_2 \\cdot \\mathbf{g}_2)\\int_T\\lambda_1^2dV - 2(\\mathbf{g}_1 \\cdot \\mathbf{g}_2)\\int_T\\lambda_1\\lambda_2dV + (\\mathbf{g}_1 \\cdot \\mathbf{g}_1)\\int_T\\lambda_2^2dV \\right] = \\epsilon \\left[ (1)\\frac{1}{60} - 2(0)\\frac{1}{120} + (1)\\frac{1}{60} \\right] = \\frac{2\\epsilon}{60} = \\frac{\\epsilon}{30}$. Correct.\n-   $M_{(01),(02)} = \\epsilon \\left[ (\\mathbf{g}_1 \\cdot \\mathbf{g}_2)\\int_T\\lambda_0^2dV - (\\mathbf{g}_1 \\cdot \\mathbf{g}_0)\\int_T\\lambda_0\\lambda_2dV - (\\mathbf{g}_0 \\cdot \\mathbf{g}_2)\\int_T\\lambda_1\\lambda_0dV + (\\mathbf{g}_0 \\cdot \\mathbf{g}_0)\\int_T\\lambda_1\\lambda_2dV \\right] = \\epsilon \\left[ 0 - (-1)\\frac{1}{120} - (-1)\\frac{1}{120} + 3\\frac{1}{120} \\right] = \\frac{5\\epsilon}{120} = \\frac{\\epsilon}{24}$. Correct.\n-   $M_{(12),(13)} = \\epsilon \\left[ (\\mathbf{g}_2 \\cdot \\mathbf{g}_3)\\int_T\\lambda_1^2dV - (\\mathbf{g}_2 \\cdot \\mathbf{g}_1)\\int_T\\lambda_1\\lambda_3dV - (\\mathbf{g}_1 \\cdot \\mathbf{g}_3)\\int_T\\lambda_2\\lambda_1dV + (\\mathbf{g}_1 \\cdot \\mathbf{g}_1)\\int_T\\lambda_2\\lambda_3dV \\right] = \\epsilon \\left[ 0 - 0 - 0 + (1)\\frac{1}{120} \\right] = \\frac{\\epsilon}{120}$. Correct.\n-   $M_{(01),(12)} = \\epsilon \\left[ (\\mathbf{g}_1 \\cdot \\mathbf{g}_2)\\int_T\\lambda_0\\lambda_1dV - (\\mathbf{g}_1 \\cdot \\mathbf{g}_1)\\int_T\\lambda_0\\lambda_2dV - (\\mathbf{g}_0 \\cdot \\mathbf{g}_2)\\int_T\\lambda_1^2dV + (\\mathbf{g}_0 \\cdot \\mathbf{g}_1)\\int_T\\lambda_1\\lambda_2dV \\right] = \\epsilon \\left[ 0 - (1)\\frac{1}{120} - (-1)\\frac{1}{60} + (-1)\\frac{1}{120} \\right] = \\epsilon \\left( -\\frac{1}{120} + \\frac{2}{120} - \\frac{1}{120} \\right) = 0$. Correct.\n\nSystematic calculation reveals a block-diagonal structure for the specified edge ordering. The set of edges can be partitioned into $E_0 = \\{(0,1), (0,2), (0,3)\\}$ and $E_f = \\{(1,2), (1,3), (2,3)\\}$. The matrix has the form $\\mathbf{M} = \\begin{pmatrix} \\mathbf{M}_0  \\mathbf{0} \\\\ \\mathbf{0}  \\mathbf{M}_f \\end{pmatrix}$.\n$$ \\mathbf{M}_0 = \\frac{\\epsilon}{24} \\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix}, \\quad \\mathbf{M}_f = \\frac{\\epsilon}{120} \\begin{pmatrix} 4  1  -1 \\\\ 1  4  1 \\\\ -1  1  4 \\end{pmatrix} $$\nThe full $6 \\times 6$ matrix is:\n$$ \\mathbf{M} = \\frac{\\epsilon}{120} \\begin{pmatrix} 10  5  5  0  0  0 \\\\ 5  10  5  0  0  0 \\\\ 5  5  10  0  0  0 \\\\ 0  0  0  4  1  -1 \\\\ 0  0  0  1  4  1 \\\\ 0  0  0  -1  1  4 \\end{pmatrix} $$\n\n#### 3. Local Curl-Curl Stiffness Matrix $\\mathbf{K}$\n\nFirst, we compute the curl of a basis function $\\mathbf{N}_{ij}$. Using the vector identity $\\nabla \\times (f\\mathbf{A}) = f(\\nabla \\times \\mathbf{A}) + \\nabla f \\times \\mathbf{A}$ and noting that gradients $\\mathbf{g}_j=\\nabla\\lambda_j$ are constant vectors, their curls are zero ($\\nabla \\times \\mathbf{g}_j = \\mathbf{0}$).\n$$ \\nabla \\times \\mathbf{N}_{ij} = \\nabla \\times (\\lambda_i \\mathbf{g}_j - \\lambda_j \\mathbf{g}_i) = (\\nabla \\lambda_i \\times \\mathbf{g}_j) - (\\nabla \\lambda_j \\times \\mathbf{g}_i) = (\\mathbf{g}_i \\times \\mathbf{g}_j) - (\\mathbf{g}_j \\times \\mathbf{g}_i) = 2(\\mathbf{g}_i \\times \\mathbf{g}_j) $$\nThe curl of each basis function is a constant vector. Let $\\mathbf{c}_{ij} = \\mathbf{g}_i \\times \\mathbf{g}_j$.\nThe stiffness matrix entry is:\n$$ K_{(ij),(kl)} = \\frac{1}{\\mu} \\int_T (2\\mathbf{c}_{ij}) \\cdot (2\\mathbf{c}_{kl}) dV = \\frac{4}{\\mu} (\\mathbf{c}_{ij} \\cdot \\mathbf{c}_{kl}) \\int_T dV = \\frac{4 V_T}{\\mu} (\\mathbf{c}_{ij} \\cdot \\mathbf{c}_{kl}) $$\nSince $V_T=1/6$, $K_{(ij),(kl)} = \\frac{2}{3\\mu}(\\mathbf{c}_{ij} \\cdot \\mathbf{c}_{kl})$.\nThe required cross products are:\n-   $\\mathbf{c}_{01} = \\mathbf{g}_0 \\times \\mathbf{g}_1 = \\begin{pmatrix} 0 \\\\ -1 \\\\ 1 \\end{pmatrix}$\n-   $\\mathbf{c}_{02} = \\mathbf{g}_0 \\times \\mathbf{g}_2 = \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}$\n-   $\\mathbf{c}_{03} = \\mathbf{g}_0 \\times \\mathbf{g}_3 = \\begin{pmatrix} -1 \\\\ 1 \\\\ 0 \\end{pmatrix}$\n-   $\\mathbf{c}_{12} = \\mathbf{g}_1 \\times \\mathbf{g}_2 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}$\n-   $\\mathbf{c}_{13} = \\mathbf{g}_1 \\times \\mathbf{g}_3 = \\begin{pmatrix} 0 \\\\ -1 \\\\ 0 \\end{pmatrix}$\n-   $\\mathbf{c}_{23} = \\mathbf{g}_2 \\times \\mathbf{g}_3 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$\n\nWe compute the dot products $\\mathbf{c}_{ij} \\cdot \\mathbf{c}_{kl}$ and assemble the matrix. For example:\n-   $K_{(01),(01)} = \\frac{2}{3\\mu} \\mathbf{c}_{01} \\cdot \\mathbf{c}_{01} = \\frac{2}{3\\mu} (0^2 + (-1)^2 + 1^2) = \\frac{4}{3\\mu}$.\n-   $K_{(01),(02)} = \\frac{2}{3\\mu} \\mathbf{c}_{01} \\cdot \\mathbf{c}_{02} = \\frac{2}{3\\mu} ((0)(1) + (-1)(0) + (1)(-1)) = -\\frac{2}{3\\mu}$.\n-   $K_{(01),(12)} = \\frac{2}{3\\mu} \\mathbf{c}_{01} \\cdot \\mathbf{c}_{12} = \\frac{2}{3\\mu} ((0)(0) + (-1)(0) + (1)(1)) = \\frac{2}{3\\mu}$.\n\nFollowing this procedure for all pairs, we obtain the matrix $\\mathbf{K}$:\n$$ \\mathbf{K} = \\frac{2}{3\\mu} \\begin{pmatrix}\n 2  -1  -1   1   1   0 \\\\\n-1   2  -1  -1   0   1 \\\\\n-1  -1   2   0  -1  -1 \\\\\n 1  -1   0   1   0   0 \\\\\n 1   0  -1   0   1   0 \\\\\n 0   1  -1   0   0   1\n\\end{pmatrix} $$\n\n#### 4. Symmetry and Rank Verification\n\n**Symmetry**:\n-   For the mass matrix, $M_{(ij),(kl)} = \\epsilon \\int_T \\mathbf{N}_{ij} \\cdot \\mathbf{N}_{kl} dV$. Since the scalar product is commutative, $\\mathbf{N}_{ij} \\cdot \\mathbf{N}_{kl} = \\mathbf{N}_{kl} \\cdot \\mathbf{N}_{ij}$, it follows that $M_{(ij),(kl)} = M_{(kl),(ij)}$. Thus, $\\mathbf{M}$ is symmetric. Our computed matrix is indeed symmetric.\n-   For the stiffness matrix, $K_{(ij),(kl)} = \\frac{2}{3\\mu} (\\mathbf{g}_i \\times \\mathbf{g}_j) \\cdot (\\mathbf{g}_k \\times \\mathbf{g}_l)$. The commutativity of the scalar product implies $K_{(ij),(kl)} = K_{(kl),(ij)}$, so $\\mathbf{K}$ is also symmetric. Our computed matrix is symmetric.\n\n**Rank of $\\mathbf{M}$**:\nThe matrix $\\mathbf{M}$ is block diagonal. Its rank is the sum of the ranks of its diagonal blocks.\n-   For $\\mathbf{M}_0 = \\frac{\\epsilon}{24} \\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix}$, the determinant is proportional to $2(4-1) - 1(2-1) + 1(1-2) = 6-1-1 = 4 \\neq 0$. Thus, $\\mathrm{rank}(\\mathbf{M}_0)=3$.\n-   For $\\mathbf{M}_f = \\frac{\\epsilon}{120} \\begin{pmatrix} 4  1  -1 \\\\ 1  4  1 \\\\ -1  1  4 \\end{pmatrix}$, the determinant is proportional to $4(16-1) - 1(4-(-1)) - 1(1-(-4)) = 60-5-5=50 \\neq 0$. Thus, $\\mathrm{rank}(\\mathbf{M}_f)=3$.\nThe total rank is $\\mathrm{rank}(\\mathbf{M}) = \\mathrm{rank}(\\mathbf{M}_0) + \\mathrm{rank}(\\mathbf{M}_f) = 3+3=6$. The mass matrix is full rank, which is expected as the six basis functions $\\mathbf{N}_{ij}$ are linearly independent over the domain $T$.\n\n**Rank of $\\mathbf{K}$**:\nThe rank of $\\mathbf{K}$ is the dimension of the space spanned by the constant curl vectors $\\{2\\mathbf{c}_{ij}\\}$. This is equivalent to the rank of the set of vectors $\\{\\mathbf{c}_{ij}\\}_{ij \\in E}$, where $E$ is the set of six edges. The vectors are:\n$\\mathbf{c}_{12} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}$, $\\mathbf{c}_{13} = \\begin{pmatrix} 0 \\\\ -1 \\\\ 0 \\end{pmatrix}$, $\\mathbf{c}_{23} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$.\nThese three vectors correspond to edges on the face opposite to the origin and form an orthogonal basis for $\\mathbb{R}^3$. The remaining three vectors can be expressed as linear combinations of these, using the relation $\\mathbf{g}_0 = -\\mathbf{g}_1 - \\mathbf{g}_2 - \\mathbf{g}_3$:\n-   $\\mathbf{c}_{01} = \\mathbf{g}_0 \\times \\mathbf{g}_1 = (-\\mathbf{g}_2 - \\mathbf{g}_3) \\times \\mathbf{g}_1 = \\mathbf{g}_1 \\times \\mathbf{g}_2 + \\mathbf{g}_1 \\times \\mathbf{g}_3 = \\mathbf{c}_{12} + \\mathbf{c}_{13}$.\n-   $\\mathbf{c}_{02} = \\mathbf{g}_0 \\times \\mathbf{g}_2 = (-\\mathbf{g}_1 - \\mathbf{g}_3) \\times \\mathbf{g}_2 = \\mathbf{g}_2 \\times \\mathbf{g}_1 + \\mathbf{g}_2 \\times \\mathbf{g}_3 = -\\mathbf{c}_{12} + \\mathbf{c}_{23}$.\n-   $\\mathbf{c}_{03} = \\mathbf{g}_0 \\times \\mathbf{g}_3 = (-\\mathbf{g}_1 - \\mathbf{g}_2) \\times \\mathbf{g}_3 = \\mathbf{g}_3 \\times \\mathbf{g}_1 + \\mathbf{g}_3 \\times \\mathbf{g}_2 = -\\mathbf{c}_{13} - \\mathbf{c}_{23}$.\nSince all six vectors $\\{\\mathbf{c}_{ij}\\}$ can be written as linear combinations of the three linearly independent vectors $\\{\\mathbf{c}_{12}, \\mathbf{c}_{13}, \\mathbf{c}_{23}\\}$, the dimension of the space spanned by the set of all six vectors is $3$.\nThe rank of the Gram matrix $\\mathbf{K}$ is equal to the dimension of the vector space spanned by the generating vectors. Therefore, $\\mathrm{rank}(\\mathbf{K})=3$.\nThe null space of $\\mathbf{K}$ has dimension $6 - 3 = 3$. This corresponds to the fact that there are $4-1=3$ irrotational (gradient) fields associated with the nodes of the tetrahedron, which are annihilated by the curl operator.\n\nThe ranks of the matrices are $\\mathrm{rank}(\\mathbf{M})=6$ and $\\mathrm{rank}(\\mathbf{K})=3$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6  3\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "From the local element, we scale up to the global mesh, where the interactions between thousands or millions of elements are described by large, sparse linear systems. This exercise demonstrates that the structure of these global matrices is not random; it encodes profound information about the topology of the computational domain. By computationally assembling discrete gradient ($G$) and curl ($C$) operators for meshes with and without holes, you will verify key theorems from algebraic topology and discover how abstract concepts like Betti numbers are directly mirrored in the ranks and nullities of the matrices we use in practice .",
            "id": "3324142",
            "problem": "Consider a square domain discretized for computational electromagnetics using a conforming triangulation generated from an $\\left(N_x \\times N_x\\right)$ Cartesian grid of points on $\\left[0,1\\right] \\times \\left[0,1\\right]$ with straight edges. Each quadrilateral cell is subdivided into $2$ triangles by the diagonal from the lower-left corner to the upper-right corner. The orientation of each triangle is counterclockwise. Construct the discrete chain complex using the combinatorial incidence relations between nodes, edges, and faces, and define the following linear operators on cochains:\n- The discrete gradient matrix $G \\in \\mathbb{R}^{n_1 \\times n_0}$, defined as the transpose of the node-to-edge incidence matrix. For an oriented edge from node $i$ to node $j$, set $G_{e,i} = -1$ and $G_{e,j} = +1$, with all other entries in row $e$ equal to $0$.\n- The discrete curl matrix $C \\in \\mathbb{R}^{n_2 \\times n_1}$, defined as the transpose of the edge-to-face incidence matrix. For a face $f$ with cyclic boundary consisting of oriented edges, set $C_{f,e} = +1$ if edge $e$ is traversed in the same orientation as the global orientation of $e$, $C_{f,e} = -1$ if traversed in the opposite orientation, and $0$ otherwise.\n\nThese operators form the cochain sequence $\\mathbb{R}^{n_0} \\xrightarrow{G} \\mathbb{R}^{n_1} \\xrightarrow{C} \\mathbb{R}^{n_2}$, which is the discrete counterpart of the gradient and curl operators appearing in Maxwell’s equations and the Stokes theorem. Here, $n_0$ is the number of nodes, $n_1$ is the number of edges, and $n_2$ is the number of triangular faces.\n\nYou must assemble $G$ and $C$ for the following triangulated meshes and compute their ranks and nullities. Then, relate these algebraic quantities to the Betti numbers $b_0$, $b_1$, and $b_2$ of the resulting $2$-dimensional cell complex. The Betti numbers are to be interpreted as follows: $b_0$ is the number of connected components, $b_1$ is the number of independent global cycles (holes), and $b_2$ is the number of enclosed voids. For this planar complex with boundary in $\\mathbb{R}^2$, take $b_2 = 0$. The first Betti number $b_1$ must be computed via the Euler characteristic relation $b_0 - b_1 + b_2 = n_0 - n_1 + n_2$.\n\nTo probe the topological and algebraic interplay, consider the following test suite of meshes:\n- Test case $1$: $N_x = 1$, no hole removed.\n- Test case $2$: $N_x = 2$, no hole removed.\n- Test case $3$: $N_x = 3$, no hole removed.\n- Test case $4$: $N_x = 3$, remove the two triangles that belong to the central square cell (i.e., the cell with index $\\left(\\left\\lfloor \\frac{N_x}{2} \\right\\rfloor, \\left\\lfloor \\frac{N_x}{2} \\right\\rfloor\\right)$), which creates a single interior hole in the mesh. In constructing the incidence, only edges that appear in at least one triangle’s boundary are included; hence the interior diagonal edge of the removed cell does not appear in the complex.\n\nFor each test case, assemble $G$ and $C$ and compute:\n- $n_0$, $n_1$, $n_2$,\n- $\\operatorname{rank}(G)$, $\\operatorname{nullity}(G)$,\n- $\\operatorname{rank}(C)$, $\\operatorname{nullity}(C)$,\n- $b_0$, $b_1$, $b_2$,\n- The following boolean checks that encode the theoretical relations expected for linear algebra systems in electromagnetics on such complexes:\n  1. $\\operatorname{rank}(G) = n_0 - b_0$,\n  2. $\\operatorname{nullity}(G) = b_0$,\n  3. $\\operatorname{rank}(C) = n_2 - b_2$,\n  4. $\\operatorname{nullity}(C) - \\operatorname{rank}(G) = b_1$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s result is a list in the following order:\n$\\left[n_0, n_1, n_2, \\operatorname{rank}(G), \\operatorname{nullity}(G), \\operatorname{rank}(C), \\operatorname{nullity}(C), b_0, b_1, b_2, \\text{eq\\_rankG}, \\text{eq\\_nullG}, \\text{eq\\_rankC}, \\text{eq\\_cohom}\\right]$,\nwith $\\text{eq\\_rankG}$, $\\text{eq\\_nullG}$, $\\text{eq\\_rankC}$, and $\\text{eq\\_cohom}$ being the booleans for the four checks above. For example, the overall output format must be $\\left[\\text{case1},\\text{case2},\\text{case3},\\text{case4}\\right]$ as a single printed line, where each $\\text{casek}$ is the list for test case $k$ as specified.",
            "solution": "The problem requires the construction and analysis of a discrete cochain complex on a triangulated square domain. This involves generating the mesh, assembling discrete differential operators, and verifying fundamental relationships from algebraic topology that are central to computational electromagnetics and discrete exterior calculus.\n\nThe foundation of this problem lies in representing a continuous physical domain and differential operators in a discrete, combinatorial form. The triangulated mesh forms a $2$-dimensional simplicial complex, which we denote as $K$. This complex is composed of simplices of different dimensions: $0$-simplices (nodes or vertices), $1$-simplices (edges), and $2$-simplices (triangular faces). The number of these simplices are denoted by $n_0$, $n_1$, and $n_2$, respectively.\n\nOn this complex, we can define spaces of cochains. A $k$-cochain is a function that assigns a real value to each oriented $k$-simplex. The spaces of $0$-cochains, $1$-cochains, and $2$-cochains are isomorphic to $\\mathbb{R}^{n_0}$, $\\mathbb{R}^{n_1}$, and $\\mathbb{R}^{n_2}$. The discrete operators $G$ and $C$ are matrix representations of the coboundary operators, $d^0$ and $d^1$, which map between these cochain spaces:\n$$ \\mathbb{R}^{n_0} \\xrightarrow{d^0 \\equiv G} \\mathbb{R}^{n_1} \\xrightarrow{d^1 \\equiv C} \\mathbb{R}^{n_2} $$\nThe operator $G \\in \\mathbb{R}^{n_1 \\times n_0}$ is the discrete gradient, mapping scalar potentials on nodes ($0$-cochains) to vector fields on edges ($1$-cochains). The operator $C \\in \\mathbb{R}^{n_2 \\times n_1}$ is the discrete curl, mapping vector fields on edges ($1$-cochains) to scalar fields on faces ($2$-cochains).\n\nA fundamental property of these operators is that the composition of any two consecutive operators is zero. In this case, this means $C \\circ G = 0$. This is the discrete analogue of the vector calculus identity $\\nabla \\times (\\nabla f) = 0$. This property implies that the image of $G$ is a subspace of the kernel of $C$, i.e., $\\operatorname{im}(G) \\subseteq \\operatorname{ker}(C)$.\n\nThe Betti numbers ($b_0$, $b_1$, $b_2$) are topological invariants of the complex $K$. They are formally defined as the dimensions of its cohomology groups, $H^k(K) = \\operatorname{ker}(d^k) / \\operatorname{im}(d^{k-1})$. The problem provides their intuitive interpretations: $b_0$ is the number of connected components, $b_1$ is the number of independent cycles or \"holes,\" and $b_2$ is the number of enclosed voids. For the planar complexes considered, all are connected, so $b_0=1$. The complex is embedded in $\\mathbb{R}^2$, so it cannot enclose any voids, hence $b_2=0$ as specified. The first Betti number $b_1$ can be computed using the Euler-Poincaré formula, which relates the Betti numbers to the counts of simplices:\n$$ \\chi(K) = n_0 - n_1 + n_2 = b_0 - b_1 + b_2 $$\nGiven $b_0=1$ and $b_2=0$, we can calculate $b_1 = 1 - (n_0 - n_1 + n_2)$.\n\nThe problem further requires verifying four relations that connect the algebraic properties of the discrete operators (their ranks and nullities) to the topological Betti numbers. These relations are a direct consequence of the rank-nullity theorem and the definition of cohomology, sometimes summarized by the \"rank formula\" from homological algebra: $\\operatorname{rank}(d^{k-1}) + \\dim(H^k) + \\operatorname{rank}(d^k) = n_k$.\n1.  For $k=0$, with $d^{-1}=0$ and $d^0 = G$: $\\operatorname{rank}(G) + b_0 = n_0$. This is equivalent to $\\operatorname{rank}(G) = n_0 - b_0$ (Check 1) and, by the rank-nullity theorem ($\\operatorname{rank}(G) + \\operatorname{nullity}(G) = n_0$), also to $\\operatorname{nullity}(G) = b_0$ (Check 2).\n2.  For $k=2$, with $d^1 = C$ and $d^2=0$ (since the complex is $2$-dimensional): $\\operatorname{rank}(C) + b_2 = n_2$, or $\\operatorname{rank}(C) = n_2 - b_2$ (Check 3).\n3.  The dimension of the first cohomology group is $b_1 = \\dim H^1(K) = \\dim(\\operatorname{ker}(C)) - \\dim(\\operatorname{im}(G)) = \\operatorname{nullity}(C) - \\operatorname{rank}(G)$ (Check 4).\n\nThe algorithmic procedure to solve the problem for each test case is as follows:\nFirst, we generate the mesh. For a given grid size $N_x$, we define a set of faces (triangles) based on the problem's subdivision rule, skipping faces corresponding to any specified holes. From this list of faces, we derive the set of unique edges and nodes that constitute the complex. This \"bottom-up\" construction from faces ensures that only simplices that are part of the final complex are included, correctly handling the removal of interior edges and isolated nodes as dictated by the removal of faces. We create integer indices for each node, edge, and face.\n\nSecond, we assemble the matrices $G$ and $C$.\n- The matrix $G$ of size $n_1 \\times n_0$ is populated by iterating through each indexed edge. For an edge from node $u$ to node $v$, we set the corresponding row entries to $-1$ at column $u$ and $+1$ at column $v$. The global orientation of each edge is consistently chosen, for instance, from the node with the smaller index to the one with the larger index.\n- The matrix $C$ of size $n_2 \\times n_1$ is populated by iterating through each indexed face. For a face with a counterclockwise boundary traversal, we identify its constituent edges. For each boundary edge, we determine if its orientation matches or opposes the global orientation assigned during the construction of $G$. We then place a $+1$ or $-1$ respectively in the corresponding entry of $C$.\n\nThird, we perform the required calculations. Using `numpy`, we compute the ranks of $G$ and $C$. The nullities are then found using the rank-nullity theorem: $\\operatorname{nullity}(G) = n_0 - \\operatorname{rank}(G)$ and $\\operatorname{nullity}(C) = n_1 - \\operatorname{rank}(C)$. The Betti number $b_1$ is computed via the Euler characteristic.\n\nFinally, we verify the four boolean checks by substituting the computed algebraic and topological quantities into the theoretical relations. This process is repeated for all four test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    \n    def assemble_and_analyze(Nx, remove_hole):\n        \"\"\"\n        Generates the mesh, assembles operators G and C, and computes all required quantities for a single test case.\n        \n        Args:\n            Nx (int): The number of divisions along each axis of the Cartesian grid.\n            remove_hole (bool): If True, a central hole is introduced in the mesh.\n            \n        Returns:\n            list: A list containing the computed results for the test case.\n        \"\"\"\n        \n        # --- 1. Mesh Generation ---\n        \n        def get_node_id(r, c, nx):\n            return r * (nx + 1) + c\n\n        hole_cell = (Nx // 2, Nx // 2) if remove_hole else None\n        \n        faces_nodes_orig = []\n        for i in range(Nx):  # cell row\n            for j in range(Nx):  # cell col\n                if (i, j) == hole_cell:\n                    continue\n                \n                # Nodes of the cell in original global indexing\n                n_ll = get_node_id(i, j, Nx)\n                n_lr = get_node_id(i, j + 1, Nx)\n                n_ul = get_node_id(i + 1, j, Nx)\n                n_ur = get_node_id(i + 1, j + 1, Nx)\n                \n                # Add the two triangles for this cell (counter-clockwise orientation)\n                # Lower triangle: (LL, LR, UR)\n                faces_nodes_orig.append((n_ll, n_lr, n_ur))\n                # Upper triangle: (LL, UR, UL)\n                faces_nodes_orig.append((n_ll, n_ur, n_ul))\n\n        # Derive the sets of edges and nodes from the face list\n        edges_map_orig = {}\n        nodes_set_orig = set()\n        \n        for v0, v1, v2 in faces_nodes_orig:\n            nodes_set_orig.update([v0, v1, v2])\n            \n            # Edges are stored as sorted tuples of original node IDs to ensure uniqueness\n            edge_tuples = [tuple(sorted((v0, v1))), tuple(sorted((v1, v2))), tuple(sorted((v2, v0)))]\n            \n            for edge_tuple in edge_tuples:\n                if edge_tuple not in edges_map_orig:\n                    edges_map_orig[edge_tuple] = len(edges_map_orig)\n        \n        # Create compact, 0-indexed lists and maps for the simplices in the complex\n        node_list_orig = sorted(list(nodes_set_orig))\n        node_map_compact = {old_id: new_id for new_id, old_id in enumerate(node_list_orig)}\n\n        n_0 = len(node_map_compact)\n        n_1 = len(edges_map_orig)\n        n_2 = len(faces_nodes_orig)\n\n        # --- 2. Assemble G and C matrices ---\n        \n        G = np.zeros((n_1, n_0), dtype=np.int8)\n        # Global orientation of an edge (u, v) is defined as u -> v, where u  v.\n        for edge_tuple_orig, edge_idx in edges_map_orig.items():\n            u_orig, v_orig = edge_tuple_orig  # u_orig  v_orig by construction\n            u_compact, v_compact = node_map_compact[u_orig], node_map_compact[v_orig]\n            G[edge_idx, u_compact] = -1\n            G[edge_idx, v_compact] = 1\n\n        C = np.zeros((n_2, n_1), dtype=np.int8)\n        for face_idx, face_nodes_orig in enumerate(faces_nodes_orig):\n            # Boundary edges in CCW orientation\n            v0, v1, v2 = face_nodes_orig\n            boundary_edges = [(v0, v1), (v1, v2), (v2, v0)]\n            \n            for u_orig, v_orig in boundary_edges:\n                edge_tuple_sorted = tuple(sorted((u_orig, v_orig)))\n                edge_idx = edges_map_orig[edge_tuple_sorted]\n                \n                # Check if boundary orientation matches global orientation (smaller to larger index)\n                sign = 1 if u_orig  v_orig else -1\n                C[face_idx, edge_idx] = sign\n        \n        # --- 3. Compute Ranks and Nullities ---\n        \n        rank_G = np.linalg.matrix_rank(G) if G.size > 0 else 0\n        nullity_G = n_0 - rank_G\n        \n        rank_C = np.linalg.matrix_rank(C) if C.size > 0 else 0\n        nullity_C = n_1 - rank_C\n        \n        # --- 4. Compute Betti Numbers ---\n        \n        b_0 = 1  # All test cases result in a single connected component\n        b_2 = 0  # For a 2D planar complex\n        euler_char = n_0 - n_1 + n_2\n        b_1 = b_0 + b_2 - euler_char\n        \n        # --- 5. Perform Boolean Checks ---\n        \n        # rank(G) = n0 - b0\n        eq_rankG = (rank_G == n_0 - b_0)\n        \n        # nullity(G) = b0\n        eq_nullG = (nullity_G == b_0)\n        \n        # rank(C) = n2 - b2\n        eq_rankC = (rank_C == n_2 - b_2)\n        \n        # nullity(C) - rank(G) = b1\n        eq_cohom = ((nullity_C - rank_G) == b_1)\n        \n        return [\n            n_0, n_1, n_2,\n            int(rank_G), int(nullity_G),\n            int(rank_C), int(nullity_C),\n            b_0, b_1, b_2,\n            eq_rankG, eq_nullG, eq_rankC, eq_cohom\n        ]\n\n    # Define and run the test cases from the problem statement.\n    test_cases = [\n        (1, False),  # Test case 1\n        (2, False),  # Test case 2\n        (3, False),  # Test case 3\n        (3, True),   # Test case 4\n    ]\n\n    results = []\n    for nx_val, has_hole_val in test_cases:\n        case_result = assemble_and_analyze(nx_val, has_hole_val)\n        results.append(str(case_result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Our previous analysis revealed that topological holes in a domain create a non-trivial \"harmonic\" nullspace in the resulting system matrix, making it singular. This final practice transitions from diagnosis to treatment, offering a powerful method to overcome this challenge. You will implement a discrete Hodge decomposition to construct an explicit basis for this problematic nullspace and then build a projection operator to remove, or \"deflate,\" these components from the system, transforming an ill-posed problem into a solvable one . This technique is not merely an academic exercise; it is a crucial tool for solving static and quasi-static electromagnetic problems in complex, multiply-connected geometries.",
            "id": "3324090",
            "problem": "Consider a discrete setting for computational electromagnetics on a two-dimensional structured grid, in which edge-based fields approximate the electric field and node-based scalars approximate potentials. Let the edge space be a finite-dimensional real vector space denoted by $\\mathcal{E} = \\mathbb{R}^m$, the node space by $\\mathbb{R}^n$, and the face space by $\\mathbb{R}^f$. Define the incidence matrices $\\,\\mathbf{G} \\in \\mathbb{R}^{m \\times n}\\,$ and $\\,\\mathbf{C} \\in \\mathbb{R}^{f \\times m}\\,$ such that $\\,\\mathbf{G}\\,$ maps node-based scalars to edge-based gradients (discrete gradient), and $\\,\\mathbf{C}\\,$ maps edge-based fields to face-based circulations (discrete curl). For this problem, use the Euclidean inner product so that the discrete divergence operator is $\\,\\mathbf{D} = \\mathbf{G}^\\top \\in \\mathbb{R}^{n \\times m}\\,$. The fundamental vector calculus identities $\\,\\nabla \\times \\nabla \\phi = \\mathbf{0}\\,$ and $\\,\\nabla \\cdot (\\nabla \\times \\mathbf{A}) = 0\\,$ are represented discretely by $\\,\\mathbf{C}\\mathbf{G} = \\mathbf{0}\\,$ and $\\,\\mathbf{D}\\mathbf{C}^\\top = \\mathbf{0}\\,$. In multiply-connected geometries, the edge space admits a discrete Hodge decomposition\n$$\n\\mathcal{E} = \\mathrm{range}(\\mathbf{G}) \\oplus \\mathrm{range}(\\mathbf{C}^\\top) \\oplus \\mathcal{H},\n$$\nwhere the harmonic subspace $\\,\\mathcal{H}\\,$ satisfies $\\,\\mathcal{H} = \\ker(\\mathbf{C}) \\cap \\ker(\\mathbf{D})\\,$ and its dimension equals the number of topological holes (the first Betti number).\n\nConsider the symmetric positive semidefinite matrix\n$$\n\\mathbf{A} = \\mathbf{C}^\\top \\mathbf{C} + \\gamma\\, \\mathbf{G}\\mathbf{G}^\\top \\in \\mathbb{R}^{m \\times m},\n$$\nwith $\\,\\gamma  0\\,$ a real parameter. This discrete operator is analogous to a vector Laplacian acting on edge fields, where $\\,\\mathbf{C}^\\top \\mathbf{C}\\,$ penalizes solenoidal components and $\\,\\gamma\\,\\mathbf{G}\\mathbf{G}^\\top\\,$ penalizes coexact components. The harmonic subspace $\\,\\mathcal{H}\\,$ lies in the nullspace of $\\,\\mathbf{A}\\,$ because $\\,\\mathbf{C}\\mathbf{h} = \\mathbf{0}\\,$ and $\\,\\mathbf{G}^\\top \\mathbf{h} = \\mathbf{0}\\,$ for all $\\,\\mathbf{h} \\in \\mathcal{H}\\,$.\n\nYour task is to design a preconditioner that explicitly removes the harmonic subspace by projecting out $\\,\\mathcal{H}\\,$ and to study the effect of this projection on the spectrum of $\\,\\mathbf{A}\\,$. Specifically, you must:\n\n- Construct $\\,\\mathbf{G}\\,$ and $\\,\\mathbf{C}\\,$ for structured grids of size $\\,n_x \\times n_y\\,$ faces, possibly with interior holes (faces deliberately removed), using consistent orientations: edges oriented in the positive coordinate directions and faces oriented counterclockwise. Let $\\,\\mathbf{D} = \\mathbf{G}^\\top\\,$.\n- Compute an orthonormal basis $\\,\\mathbf{H}\\,$ for the harmonic subspace $\\,\\mathcal{H} = \\ker(\\mathbf{C}) \\cap \\ker(\\mathbf{D})\\,$ by finding the nullspace of the block matrix\n$$\n\\mathbf{B} = \\begin{bmatrix} \\mathbf{C} \\\\ \\mathbf{D} \\end{bmatrix}.\n$$\n- Form the orthogonal projector onto the harmonic subspace $\\,\\Pi_{\\mathcal{H}} = \\mathbf{H}\\mathbf{H}^\\top\\,$ and the complementary projector $\\,\\mathbf{R} = \\mathbf{I}_m - \\Pi_{\\mathcal{H}}\\,$ that removes the harmonic components.\n- Study the spectral effect of removing $\\,\\mathcal{H}\\,$ by computing the eigenvalues of $\\,\\mathbf{A}\\,$ and of the restriction of $\\,\\mathbf{A}\\,$ to $\\,\\mathrm{range}(\\mathbf{R})\\,$. To obtain the restricted spectrum, build an orthonormal basis $\\,\\mathbf{Q}\\,$ for $\\,\\mathrm{range}(\\mathbf{R})\\,$ and compute the eigenvalues of $\\,\\mathbf{Q}^\\top \\mathbf{A}\\mathbf{Q}\\,$. Quantify:\n  1. The dimension of $\\,\\mathcal{H}\\,$.\n  2. The count of numerically zero eigenvalues of $\\,\\mathbf{A}\\,$ (within a tolerance).\n  3. The smallest positive eigenvalue of $\\,\\mathbf{A}\\,$.\n  4. The smallest eigenvalue of the restricted operator $\\,\\mathbf{Q}^\\top \\mathbf{A}\\mathbf{Q}\\,$.\n  5. The condition number of the restricted operator, defined as the ratio of largest to smallest eigenvalue.\n  6. A boolean verifying the discrete Hodge decomposition dimension identity\n     $$ m = \\mathrm{rank}(\\mathbf{G}) + \\mathrm{rank}(\\mathbf{C}^\\top) + \\dim(\\mathcal{H}). $$\n\nUse the following test suite of geometries and parameter values to cover different connectivity regimes:\n\n- Case 1 (simply-connected): $\\,n_x = 2,\\, n_y = 2\\,$, no holes, $\\,\\gamma = 1.0\\,$.\n- Case 2 (one hole): $\\,n_x = 3,\\, n_y = 3\\,$, remove the interior face at index $\\, (i,j) = (1,1)\\,$ (zero-based indexing), $\\,\\gamma = 1.0\\,$.\n- Case 3 (two holes): $\\,n_x = 4,\\, n_y = 4\\,$, remove the two interior faces at indices $\\, (i,j) = (1,1)\\,$ and $\\, (2,2)\\,$, $\\,\\gamma = 1.0\\,$.\n\nYour program must compute the quantities listed above for each case. Angles do not appear and no physical units are required; treat all quantities as dimensionless. Use a numerical tolerance of $\\,10^{-10}\\,$ to decide whether an eigenvalue is numerically zero.\n\nFinal output specification: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list in the order\n$$\n[\\dim(\\mathcal{H}),\\ \\text{zero\\_count}(\\mathbf{A}),\\ \\lambda_{\\min}^+(\\mathbf{A}),\\ \\lambda_{\\min}(\\mathbf{Q}^\\top \\mathbf{A}\\mathbf{Q}),\\ \\kappa(\\mathbf{Q}^\\top \\mathbf{A}\\mathbf{Q}),\\ \\text{decomp\\_valid}],\n$$\nwith $\\,\\lambda_{\\min}^+(\\mathbf{A})\\,$ the smallest positive eigenvalue of $\\,\\mathbf{A}\\,$ and $\\,\\kappa(\\cdot)\\,$ the condition number of the restricted operator. For example, the single output line must look like\n$$\n[[\\cdots],[\\cdots],[\\cdots]].\n$$",
            "solution": "The user-provided problem is valid. It is scientifically grounded in the principles of discrete exterior calculus (or mimetic finite differences) as applied to computational electromagnetics. All terms are mathematically well-defined, the objectives are clear and quantifiable, and the problem is self-contained. There are no contradictions, ambiguities, or pseudo-scientific claims. We can proceed with a formal solution.\n\nThe core task is to analyze the spectral properties of a discrete vector Laplacian operator, $\\mathbf{A}$, and understand how its singularity, which arises from the non-trivial topology of the domain (holes), can be removed by projection. The harmonic subspace $\\mathcal{H}$, whose dimension equals the number of holes, forms the nullspace of $\\mathbf{A}$. By projecting out this subspace, we obtain a restricted operator that is positive definite and thus invertible, which is a crucial step in solving linear systems of the form $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$.\n\nOur methodology proceeds as follows:\n1.  **Discretization and Operator Construction**: We model the two-dimensional domain on a structured grid. The fundamental entities are nodes (0-cells), edges (1-cells), and faces (2-cells). We establish a consistent row-major numbering scheme for each entity type.\n    -   A grid with $n_y \\times n_x$ faces has $(n_y+1) \\times (n_x+1)$ nodes, $m_h = (n_y+1) n_x$ horizontal edges, and $m_v = n_y (n_x+1)$ vertical edges, for a total of $m = m_h + m_v$ edges.\n    -   The discrete gradient operator, $\\mathbf{G} \\in \\mathbb{R}^{m \\times n}$, is constructed as the incidence matrix mapping nodes to edges. Each row, corresponding to an edge, has entries $+1$ and $-1$ at the columns corresponding to its head and tail nodes, respectively, reflecting the potential difference.\n    -   The discrete curl operator, $\\mathbf{C} \\in \\mathbb{R}^{f \\times m}$, is constructed as the incidence matrix mapping edges to faces. Each row, corresponding to a face, has four non-zero entries $(\\pm 1)$ representing the oriented sum (circulation) of fields on its four bounding edges. A counter-clockwise orientation is used.\n    -   Holes are incorporated by simply omitting the corresponding rows from the $\\mathbf{C}$ matrix, reducing the total number of faces $f$.\n    -   The discrete divergence operator is defined as the transpose of the gradient, $\\mathbf{D} = \\mathbf{G}^\\top$.\n\n2.  **Harmonic Subspace Basis**: The harmonic subspace $\\mathcal{H}$ consists of edge fields that are both curl-free and divergence-free, i.e., $\\mathcal{H} = \\ker(\\mathbf{C}) \\cap \\ker(\\mathbf{D})$. We find an orthonormal basis $\\mathbf{H}$ for this subspace by computing the nullspace of the combined matrix $\\mathbf{B} = \\begin{bmatrix} \\mathbf{C} \\\\ \\mathbf{D} \\end{bmatrix}$. The dimension of $\\mathcal{H}$, denoted $\\dim(\\mathcal{H})$, is simply the number of basis vectors (columns) in $\\mathbf{H}$. This is the first quantity to be computed.\n\n3.  **Spectral Analysis of $\\mathbf{A}$**: The operator $\\mathbf{A} = \\mathbf{C}^\\top \\mathbf{C} + \\gamma\\, \\mathbf{G}\\mathbf{G}^\\top$ is a symmetric positive semidefinite matrix. Its nullspace is precisely the harmonic subspace $\\mathcal{H}$. We compute the eigenvalues of $\\mathbf{A}$ using a standard eigensolver for symmetric matrices.\n    -   The number of numerically zero eigenvalues, determined using a tolerance of $10^{-10}$, should equal $\\dim(\\mathcal{H})$. This is the second quantity.\n    -   The smallest strictly positive eigenvalue, $\\lambda_{\\min}^+(\\mathbf{A})$, is found by filtering out the zero eigenvalues and taking the minimum of the remaining set. This is the third quantity.\n\n4.  **Projection and Restricted Operator**: To remove the nullspace, we define an orthogonal projector $\\mathbf{R} = \\mathbf{I}_m - \\mathbf{H}\\mathbf{H}^\\top$, where $\\mathbf{I}_m$ is the identity matrix of size $m \\times m$. This operator projects any vector in the edge space $\\mathcal{E}$ onto the orthogonal complement of $\\mathcal{H}$. The range of $\\mathbf{R}$ is the space $\\mathrm{range}(\\mathbf{G}) \\oplus \\mathrm{range}(\\mathbf{C}^\\top)$.\n    -   We construct an orthonormal basis $\\mathbf{Q}$ for the range of $\\mathbf{R}$. A robust numerical method for this is to compute the singular value decomposition (SVD) of $\\mathbf{R}$ and take a basis for its range space.\n    -   The action of $\\mathbf{A}$ is then restricted to this subspace by forming the matrix $\\mathbf{Q}^\\top \\mathbf{A} \\mathbf{Q}$. This restricted operator is symmetric and, by construction, positive definite.\n    -   We compute the eigenvalues of the restricted operator. Its smallest eigenvalue, $\\lambda_{\\min}(\\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q})$, should theoretically be equal to $\\lambda_{\\min}^+(\\mathbf{A})$. This is the fourth quantity.\n    -   The condition number of the restricted operator, $\\kappa(\\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q})$, is calculated as the ratio of its largest to its smallest eigenvalue. This is the fifth quantity.\n\n5.  **Decomposition Verification**: As a final sanity check, we verify the discrete Hodge decomposition identity, $m = \\mathrm{rank}(\\mathbf{G}) + \\mathrm{rank}(\\mathbf{C}^\\top) + \\dim(\\mathcal{H})$. The ranks of the matrices are computed numerically. This boolean result is the sixth and final quantity for each test case.\n\nThe following Python code implements this procedure for the specified test cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Computes spectral properties of a discrete vector Laplacian on 2D grids\n    with and without topological holes, demonstrating the effect of projecting\n    out the harmonic subspace.\n    \"\"\"\n\n    def _compute_case(nx, ny, holes, gamma, tol=1e-10):\n        \"\"\"\n        Performs all computations for a single test case configuration.\n        \n        Args:\n            nx (int): Number of faces in the x-direction.\n            ny (int): Number of faces in the y-direction.\n            holes (list): A list of (row, col) tuples for removed faces.\n            gamma (float): The penalty parameter for the gradient term.\n            tol (float): Numerical tolerance for zero-checking.\n\n        Returns:\n            list: A list containing the six required analysis quantities.\n        \"\"\"\n        # 1. Grid dimensions and numbering schemes\n        # We consistently use (row, col) indexing.\n        n_nodes_y, n_nodes_x = ny + 1, nx + 1\n        n_nodes = n_nodes_y * n_nodes_x\n        \n        num_h_edges = (ny + 1) * nx\n        num_v_edges = ny * (nx + 1)\n        m = num_h_edges + num_v_edges\n        \n        def node_idx(r, c):   return r * n_nodes_x + c\n        def hedge_idx(r, c):  return r * nx + c\n        def vedge_idx(r, c):  return num_h_edges + r * (nx + 1) + c\n\n        # 2. Construct G (discrete gradient) matrix\n        G = np.zeros((m, n_nodes))\n        for r in range(ny + 1):\n            for c in range(nx):\n                G[hedge_idx(r, c), node_idx(r, c)] = -1\n                G[hedge_idx(r, c), node_idx(r, c + 1)] = 1\n        for r in range(ny):\n            for c in range(nx + 1):\n                G[vedge_idx(r, c), node_idx(r, c)] = -1\n                G[vedge_idx(r, c), node_idx(r + 1, c)] = 1\n\n        # 3. Construct C (discrete curl) matrix, accounting for holes\n        face_map = { (r, c): i for i, (r, c) in enumerate(\n            (r, c) for r in range(ny) for c in range(nx) if (r, c) not in holes\n        )}\n        f = len(face_map)\n        C = np.zeros((f, m))\n        \n        for (r_face, c_face), row_idx in face_map.items():\n            C[row_idx, hedge_idx(r_face, c_face)] = 1      # bottom\n            C[row_idx, vedge_idx(r_face, c_face + 1)] = 1  # right\n            C[row_idx, hedge_idx(r_face + 1, c_face)] = -1 # top\n            C[row_idx, vedge_idx(r_face, c_face)] = -1     # left\n    \n        # 4. Construct B and find orthonormal basis H for the harmonic subspace\n        D = G.T\n        B = np.vstack([C, D]) if C.size > 0 else D\n        H = null_space(B, rcond=tol)\n        dim_H = H.shape[1]\n\n        # 5. Construct A and compute its spectrum\n        A = C.T @ C + gamma * G @ G.T\n        eivals_A = np.linalg.eigh(A)[0]\n        \n        is_zero = np.abs(eivals_A)  tol\n        eivals_A[is_zero] = 0.0\n        \n        zero_count_A = np.sum(is_zero)\n        pos_eivals_A = eivals_A[eivals_A > 0.0]\n        lambda_min_pos_A = np.min(pos_eivals_A) if pos_eivals_A.size > 0 else np.nan\n        \n        # 6. Project out the harmonic subspace and analyze the restricted operator\n        R = np.eye(m) - H @ H.T\n        \n        U, s, _ = np.linalg.svd(R)\n        rank_R = np.sum(s > tol)\n        Q = U[:, :rank_R]\n        \n        A_res = Q.T @ A @ Q\n        # The eigenvalues should be real due to symmetry\n        eivals_res = np.linalg.eigh(A_res)[0]\n        \n        lambda_min_res = np.min(eivals_res) if eivals_res.size > 0 else np.nan\n        lambda_max_res = np.max(eivals_res) if eivals_res.size > 0 else np.nan\n        \n        if lambda_min_res > tol:\n            kappa_res = lambda_max_res / lambda_min_res\n        elif eivals_res.size > 0:\n            kappa_res = np.inf\n        else: \n            kappa_res = np.nan\n\n        # 7. Verify Hodge decomposition dimension identity\n        rank_G = np.linalg.matrix_rank(G, tol=tol)\n        rank_C_T = np.linalg.matrix_rank(C.T, tol=tol)\n        decomp_valid = (m == rank_G + rank_C_T + dim_H)\n\n        # Return the 6 required quantities\n        return [dim_H, zero_count_A, lambda_min_pos_A, lambda_min_res, kappa_res, decomp_valid]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (nx, ny, holes, gamma)\n        (2, 2, [], 1.0),\n        # Case 2: Remove face at (row=1, col=1)\n        (3, 3, [(1, 1)], 1.0),\n        # Case 3: Remove faces at (row=1, col=1) and (row=2, col=2)\n        (4, 4, [(1, 1), (2, 2)], 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        nx, ny, holes, gamma = case\n        result = _compute_case(nx, ny, holes, gamma)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}