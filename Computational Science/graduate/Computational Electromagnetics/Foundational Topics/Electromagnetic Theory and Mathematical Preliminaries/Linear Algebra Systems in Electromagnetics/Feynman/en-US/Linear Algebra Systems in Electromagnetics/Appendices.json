{
    "hands_on_practices": [
        {
            "introduction": "The first step in moving from continuous physics to computational simulation is discretization. This process transforms differential operators like gradient and curl into sparse matrices. This exercise provides a hands-on introduction to constructing the fundamental discrete gradient ($G$) and curl ($C$) matrices for a simple 2D mesh . By building these operators and analyzing their algebraic properties, you will discover the profound connection between linear algebra and the underlying topology of the domain, laying the groundwork for understanding how physical laws are encoded in discrete systems.",
            "id": "3324142",
            "problem": "Consider a square domain discretized for computational electromagnetics using a conforming triangulation generated from an $\\left(N_x \\times N_x\\right)$ Cartesian grid of points on $\\left[0,1\\right] \\times \\left[0,1\\right]$ with straight edges. Each quadrilateral cell is subdivided into $2$ triangles by the diagonal from the lower-left corner to the upper-right corner. The orientation of each triangle is counterclockwise. Construct the discrete chain complex using the combinatorial incidence relations between nodes, edges, and faces, and define the following linear operators on cochains:\n- The discrete gradient matrix $G \\in \\mathbb{R}^{n_1 \\times n_0}$, defined as the transpose of the node-to-edge incidence matrix. For an oriented edge from node $i$ to node $j$, set $G_{e,i} = -1$ and $G_{e,j} = +1$, with all other entries in row $e$ equal to $0$.\n- The discrete curl matrix $C \\in \\mathbb{R}^{n_2 \\times n_1}$, defined as the transpose of the edge-to-face incidence matrix. For a face $f$ with cyclic boundary consisting of oriented edges, set $C_{f,e} = +1$ if edge $e$ is traversed in the same orientation as the global orientation of $e$, $C_{f,e} = -1$ if traversed in the opposite orientation, and $0$ otherwise.\n\nThese operators form the cochain sequence $\\mathbb{R}^{n_0} \\xrightarrow{G} \\mathbb{R}^{n_1} \\xrightarrow{C} \\mathbb{R}^{n_2}$, which is the discrete counterpart of the gradient and curl operators appearing in Maxwell’s equations and the Stokes theorem. Here, $n_0$ is the number of nodes, $n_1$ is the number of edges, and $n_2$ is the number of triangular faces.\n\nYou must assemble $G$ and $C$ for the following triangulated meshes and compute their ranks and nullities. Then, relate these algebraic quantities to the Betti numbers $b_0$, $b_1$, and $b_2$ of the resulting $2$-dimensional cell complex. The Betti numbers are to be interpreted as follows: $b_0$ is the number of connected components, $b_1$ is the number of independent global cycles (holes), and $b_2$ is the number of enclosed voids. For this planar complex with boundary in $\\mathbb{R}^2$, take $b_2 = 0$. The first Betti number $b_1$ must be computed via the Euler characteristic relation $b_0 - b_1 + b_2 = n_0 - n_1 + n_2$.\n\nTo probe the topological and algebraic interplay, consider the following test suite of meshes:\n- Test case $1$: $N_x = 1$, no hole removed.\n- Test case $2$: $N_x = 2$, no hole removed.\n- Test case $3$: $N_x = 3$, no hole removed.\n- Test case $4$: $N_x = 3$, remove the two triangles that belong to the central square cell (i.e., the cell with index $\\left(\\left\\lfloor \\frac{N_x}{2} \\right\\rfloor, \\left\\lfloor \\frac{N_x}{2} \\right\\rfloor\\right)$), which creates a single interior hole in the mesh. In constructing the incidence, only edges that appear in at least one triangle’s boundary are included; hence the interior diagonal edge of the removed cell does not appear in the complex.\n\nFor each test case, assemble $G$ and $C$ and compute:\n- $n_0$, $n_1$, $n_2$,\n- $\\operatorname{rank}(G)$, $\\operatorname{nullity}(G)$,\n- $\\operatorname{rank}(C)$, $\\operatorname{nullity}(C)$,\n- $b_0$, $b_1$, $b_2$,\n- The following boolean checks that encode the theoretical relations expected for linear algebra systems in electromagnetics on such complexes:\n  1. $\\operatorname{rank}(G) = n_0 - b_0$,\n  2. $\\operatorname{nullity}(G) = b_0$,\n  3. $\\operatorname{rank}(C) = n_2 - b_2$,\n  4. $\\operatorname{nullity}(C) - \\operatorname{rank}(G) = b_1$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s result is a list in the following order:\n$\\left[n_0, n_1, n_2, \\operatorname{rank}(G), \\operatorname{nullity}(G), \\operatorname{rank}(C), \\operatorname{nullity}(C), b_0, b_1, b_2, \\text{eq\\_rankG}, \\text{eq\\_nullG}, \\text{eq\\_rankC}, \\text{eq\\_cohom}\\right]$,\nwith $\\text{eq\\_rankG}$, $\\text{eq\\_nullG}$, $\\text{eq\\_rankC}$, and $\\text{eq\\_cohom}$ being the booleans for the four checks above. For example, the overall output format must be $\\left[\\text{case1},\\text{case2},\\text{case3},\\text{case4}\\right]$ as a single printed line, where each $\\text{casek}$ is the list for test case $k$ as specified.",
            "solution": "The problem requires the construction and analysis of a discrete cochain complex on a triangulated square domain. This involves generating the mesh, assembling discrete differential operators, and verifying fundamental relationships from algebraic topology that are central to computational electromagnetics and discrete exterior calculus.\n\nThe foundation of this problem lies in representing a continuous physical domain and differential operators in a discrete, combinatorial form. The triangulated mesh forms a $2$-dimensional simplicial complex, which we denote as $K$. This complex is composed of simplices of different dimensions: $0$-simplices (nodes or vertices), $1$-simplices (edges), and $2$-simplices (triangular faces). The number of these simplices are denoted by $n_0$, $n_1$, and $n_2$, respectively.\n\nOn this complex, we can define spaces of cochains. A $k$-cochain is a function that assigns a real value to each oriented $k$-simplex. The spaces of $0$-cochains, $1$-cochains, and $2$-cochains are isomorphic to $\\mathbb{R}^{n_0}$, $\\mathbb{R}^{n_1}$, and $\\mathbb{R}^{n_2}$. The discrete operators $G$ and $C$ are matrix representations of the coboundary operators, $d^0$ and $d^1$, which map between these cochain spaces:\n$$ \\mathbb{R}^{n_0} \\xrightarrow{d^0 \\equiv G} \\mathbb{R}^{n_1} \\xrightarrow{d^1 \\equiv C} \\mathbb{R}^{n_2} $$\nThe operator $G \\in \\mathbb{R}^{n_1 \\times n_0}$ is the discrete gradient, mapping scalar potentials on nodes ($0$-cochains) to vector fields on edges ($1$-cochains). The operator $C \\in \\mathbb{R}^{n_2 \\times n_1}$ is the discrete curl, mapping vector fields on edges ($1$-cochains) to scalar fields on faces ($2$-cochains).\n\nA fundamental property of these operators is that the composition of any two consecutive operators is zero. In this case, this means $C \\circ G = 0$. This is the discrete analogue of the vector calculus identity $\\nabla \\times (\\nabla f) = 0$. This property implies that the image of $G$ is a subspace of the kernel of $C$, i.e., $\\operatorname{im}(G) \\subseteq \\operatorname{ker}(C)$.\n\nThe Betti numbers ($b_0$, $b_1$, $b_2$) are topological invariants of the complex $K$. They are formally defined as the dimensions of its cohomology groups, $H^k(K) = \\operatorname{ker}(d^k) / \\operatorname{im}(d^{k-1})$. The problem provides their intuitive interpretations: $b_0$ is the number of connected components, $b_1$ is the number of independent cycles or \"holes,\" and $b_2$ is the number of enclosed voids. For the planar complexes considered, all are connected, so $b_0=1$. The complex is embedded in $\\mathbb{R}^2$, so it cannot enclose any voids, hence $b_2=0$ as specified. The first Betti number $b_1$ can be computed using the Euler-Poincaré formula, which relates the Betti numbers to the counts of simplices:\n$$ \\chi(K) = n_0 - n_1 + n_2 = b_0 - b_1 + b_2 $$\nGiven $b_0=1$ and $b_2=0$, we can calculate $b_1 = 1 - (n_0 - n_1 + n_2)$.\n\nThe problem further requires verifying four relations that connect the algebraic properties of the discrete operators (their ranks and nullities) to the topological Betti numbers. These relations are a direct consequence of the rank-nullity theorem and the definition of cohomology, sometimes summarized by the \"rank formula\" from homological algebra: $\\operatorname{rank}(d^{k-1}) + \\dim(H^k) + \\operatorname{rank}(d^k) = n_k$.\n1.  For $k=0$, with $d^{-1}=0$ and $d^0 = G$: $\\operatorname{rank}(G) + b_0 = n_0$. This is equivalent to $\\operatorname{rank}(G) = n_0 - b_0$ (Check 1) and, by the rank-nullity theorem ($\\operatorname{rank}(G) + \\operatorname{nullity}(G) = n_0$), also to $\\operatorname{nullity}(G) = b_0$ (Check 2).\n2.  For $k=2$, with $d^1 = C$ and $d^2=0$ (since the complex is $2$-dimensional): $\\operatorname{rank}(C) + b_2 = n_2$, or $\\operatorname{rank}(C) = n_2 - b_2$ (Check 3).\n3.  The dimension of the first cohomology group is $b_1 = \\dim H^1(K) = \\dim(\\operatorname{ker}(C)) - \\dim(\\operatorname{im}(G)) = \\operatorname{nullity}(C) - \\operatorname{rank}(G)$ (Check 4).\n\nThe algorithmic procedure to solve the problem for each test case is as follows:\nFirst, we generate the mesh. For a given grid size $N_x$, we define a set of faces (triangles) based on the problem's subdivision rule, skipping faces corresponding to any specified holes. From this list of faces, we derive the set of unique edges and nodes that constitute the complex. This \"bottom-up\" construction from faces ensures that only simplices that are part of the final complex are included, correctly handling the removal of interior edges and isolated nodes as dictated by the removal of faces. We create integer indices for each node, edge, and face.\n\nSecond, we assemble the matrices $G$ and $C$.\n- The matrix $G$ of size $n_1 \\times n_0$ is populated by iterating through each indexed edge. For an edge from node $u$ to node $v$, we set the corresponding row entries to $-1$ at column $u$ and $+1$ at column $v$. The global orientation of each edge is consistently chosen, for instance, from the node with the smaller index to the one with the larger index.\n- The matrix $C$ of size $n_2 \\times n_1$ is populated by iterating through each indexed face. For a face with a counterclockwise boundary traversal, we identify its constituent edges. For each boundary edge, we determine if its orientation matches or opposes the global orientation assigned during the construction of $G$. We then place a $+1$ or $-1$ respectively in the corresponding entry of $C$.\n\nThird, we perform the required calculations. Using `numpy`, we compute the ranks of $G$ and $C$. The nullities are then found using the rank-nullity theorem: $\\operatorname{nullity}(G) = n_0 - \\operatorname{rank}(G)$ and $\\operatorname{nullity}(C) = n_1 - \\operatorname{rank}(C)$. The Betti number $b_1$ is computed via the Euler characteristic.\n\nFinally, we verify the four boolean checks by substituting the computed algebraic and topological quantities into the theoretical relations. This process is repeated for all four test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    \n    def assemble_and_analyze(Nx, remove_hole):\n        \"\"\"\n        Generates the mesh, assembles operators G and C, and computes all required quantities for a single test case.\n        \n        Args:\n            Nx (int): The number of divisions along each axis of the Cartesian grid.\n            remove_hole (bool): If True, a central hole is introduced in the mesh.\n            \n        Returns:\n            list: A list containing the computed results for the test case.\n        \"\"\"\n        \n        # --- 1. Mesh Generation ---\n        \n        def get_node_id(r, c, nx):\n            return r * (nx + 1) + c\n\n        hole_cell = (Nx // 2, Nx // 2) if remove_hole else None\n        \n        faces_nodes_orig = []\n        for i in range(Nx):  # cell row\n            for j in range(Nx):  # cell col\n                if (i, j) == hole_cell:\n                    continue\n                \n                # Nodes of the cell in original global indexing\n                n_ll = get_node_id(i, j, Nx)\n                n_lr = get_node_id(i, j + 1, Nx)\n                n_ul = get_node_id(i + 1, j, Nx)\n                n_ur = get_node_id(i + 1, j + 1, Nx)\n                \n                # Add the two triangles for this cell (counter-clockwise orientation)\n                # Lower triangle: (LL, LR, UR)\n                faces_nodes_orig.append((n_ll, n_lr, n_ur))\n                # Upper triangle: (LL, UR, UL)\n                faces_nodes_orig.append((n_ll, n_ur, n_ul))\n\n        # Derive the sets of edges and nodes from the face list\n        edges_map_orig = {}\n        nodes_set_orig = set()\n        \n        for v0, v1, v2 in faces_nodes_orig:\n            nodes_set_orig.update([v0, v1, v2])\n            \n            # Edges are stored as sorted tuples of original node IDs to ensure uniqueness\n            edge_tuples = [tuple(sorted((v0, v1))), tuple(sorted((v1, v2))), tuple(sorted((v2, v0)))]\n            \n            for edge_tuple in edge_tuples:\n                if edge_tuple not in edges_map_orig:\n                    edges_map_orig[edge_tuple] = len(edges_map_orig)\n        \n        # Create compact, 0-indexed lists and maps for the simplices in the complex\n        node_list_orig = sorted(list(nodes_set_orig))\n        node_map_compact = {old_id: new_id for new_id, old_id in enumerate(node_list_orig)}\n\n        n_0 = len(node_map_compact)\n        n_1 = len(edges_map_orig)\n        n_2 = len(faces_nodes_orig)\n\n        # --- 2. Assemble G and C matrices ---\n        \n        G = np.zeros((n_1, n_0), dtype=np.int8)\n        # Global orientation of an edge (u, v) is defined as u -> v, where u < v.\n        for edge_tuple_orig, edge_idx in edges_map_orig.items():\n            u_orig, v_orig = edge_tuple_orig  # u_orig < v_orig by construction\n            u_compact, v_compact = node_map_compact[u_orig], node_map_compact[v_orig]\n            G[edge_idx, u_compact] = -1\n            G[edge_idx, v_compact] = 1\n\n        C = np.zeros((n_2, n_1), dtype=np.int8)\n        for face_idx, face_nodes_orig in enumerate(faces_nodes_orig):\n            # Boundary edges in CCW orientation\n            v0, v1, v2 = face_nodes_orig\n            boundary_edges = [(v0, v1), (v1, v2), (v2, v0)]\n            \n            for u_orig, v_orig in boundary_edges:\n                edge_tuple_sorted = tuple(sorted((u_orig, v_orig)))\n                edge_idx = edges_map_orig[edge_tuple_sorted]\n                \n                # Check if boundary orientation matches global orientation (smaller to larger index)\n                sign = 1 if u_orig < v_orig else -1\n                C[face_idx, edge_idx] = sign\n        \n        # --- 3. Compute Ranks and Nullities ---\n        \n        rank_G = np.linalg.matrix_rank(G) if G.size > 0 else 0\n        nullity_G = n_0 - rank_G\n        \n        rank_C = np.linalg.matrix_rank(C) if C.size > 0 else 0\n        nullity_C = n_1 - rank_C\n        \n        # --- 4. Compute Betti Numbers ---\n        \n        b_0 = 1  # All test cases result in a single connected component\n        b_2 = 0  # For a 2D planar complex\n        euler_char = n_0 - n_1 + n_2\n        b_1 = b_0 + b_2 - euler_char\n        \n        # --- 5. Perform Boolean Checks ---\n        \n        # rank(G) = n0 - b0\n        eq_rankG = (rank_G == n_0 - b_0)\n        \n        # nullity(G) = b0\n        eq_nullG = (nullity_G == b_0)\n        \n        # rank(C) = n2 - b2\n        eq_rankC = (rank_C == n_2 - b_2)\n        \n        # nullity(C) - rank(G) = b1\n        eq_cohom = ((nullity_C - rank_G) == b_1)\n        \n        return [\n            n_0, n_1, n_2,\n            int(rank_G), int(nullity_G),\n            int(rank_C), int(nullity_C),\n            b_0, b_1, b_2,\n            eq_rankG, eq_nullG, eq_rankC, eq_cohom\n        ]\n\n    # Define and run the test cases from the problem statement.\n    test_cases = [\n        (1, False),  # Test case 1\n        (2, False),  # Test case 2\n        (3, False),  # Test case 3\n        (3, True),   # Test case 4\n    ]\n\n    results = []\n    for nx_val, has_hole_val in test_cases:\n        case_result = assemble_and_analyze(nx_val, has_hole_val)\n        results.append(str(case_result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A robust numerical method should not only approximate the solution but also preserve the fundamental physical laws of the system it models. This practice explores how the algebraic structure of the semi-discrete Maxwell's equations directly reflects the principle of energy conservation as described by Poynting's theorem . You will derive the conditions for discrete energy conservation from first principles and numerically verify how specific matrix properties, such as symmetry and skew-symmetry, enforce this law, providing deep insight into the structure of time-domain simulation schemes.",
            "id": "3324091",
            "problem": "Consider the semi-discrete, source-free first-order Maxwell system written in block form as a linear, time-invariant ordinary differential equation in mixed variables $\\,\\mathbf{u}(t)\\in\\mathbb{R}^{n}\\,$:\n$$\n\\mathbf{M}\\,\\dot{\\mathbf{u}}(t)=\\mathbf{K}\\,\\mathbf{u}(t),\n$$\nwhere $\\,\\mathbf{M}\\in\\mathbb{R}^{n\\times n}\\,$ is the discrete mass operator and $\\,\\mathbf{K}\\in\\mathbb{R}^{n\\times n}\\,$ is the discrete curl-coupling operator. In a compatible finite element or finite difference time-domain setting for first-order Maxwell equations, the block structure is commonly of the form\n$$\n\\mathbf{u}=\\begin{bmatrix}\\mathbf{e}\\\\ \\mathbf{h}\\end{bmatrix},\\quad \n\\mathbf{M}=\\begin{bmatrix}\\mathbf{M}_{e}&\\mathbf{0}\\\\ \\mathbf{0}&\\mathbf{M}_{h}\\end{bmatrix},\\quad\n\\mathbf{K}=\\begin{bmatrix}\\mathbf{0}&\\mathbf{C}\\\\ -\\mathbf{C}^{\\top}&\\mathbf{0}\\end{bmatrix},\n$$\nwith $\\,\\mathbf{M}_{e},\\mathbf{M}_{h}\\in\\mathbb{R}^{m\\times m}\\,$ and $\\,\\mathbf{C}\\in\\mathbb{R}^{m\\times m}\\,$ for $\\,n=2m\\,$. Assume a periodic, uniform, one-dimensional lattice of length $\\,L>0\\,$ with $\\,N\\in\\mathbb{N}\\,$ degrees of freedom per field, and choose a consistent, symmetric positive definite discrete mass operator for each field that corresponds to linear finite elements on a periodic ring. Specifically, let the grid spacing be $\\,h=L/N\\,$, and define the consistent one-dimensional mass matrix $\\,\\mathbf{M}_{\\mathrm{fe}}\\in\\mathbb{R}^{N\\times N}\\,$ by\n$$\n\\left(\\mathbf{M}_{\\mathrm{fe}}\\right)_{ii}=\\tfrac{2h}{3},\\quad\n\\left(\\mathbf{M}_{\\mathrm{fe}}\\right)_{i,i\\pm 1}=\\tfrac{h}{6}\\quad\\text{with periodic wrap-around,}\n$$\nand zeros elsewhere. Set $\\,\\mathbf{M}_{e}=\\mathbf{M}_{h}=\\mathbf{M}_{\\mathrm{fe}}\\,$. Define the discrete first-difference operator $\\,\\mathbf{D}\\in\\mathbb{R}^{N\\times N}\\,$ by\n$$\n\\left(\\mathbf{D}\\right)_{ii}=-1,\\quad \\left(\\mathbf{D}\\right)_{i,i-1}=1\\quad\\text{with periodic wrap-around,}\n$$\nand zeros elsewhere, and let $\\,\\mathbf{C}=\\frac{1}{h}\\mathbf{D}\\,$. Thus $\\,\\mathbf{M}\\,$ and $\\,\\mathbf{K}\\,$ are determined by $\\,\\mathbf{M}_{\\mathrm{fe}}\\,$ and $\\,\\mathbf{C}\\,$ as above.\n\nStarting from the fundamental laws of electromagnetics (Maxwell’s equations) and their energy balance (Poynting’s theorem), as well as the fundamental properties of real matrices under an inner product, you must:\n\n1. Derive the algebraic constraints on $\\,\\mathbf{M}\\,$ and $\\,\\mathbf{K}\\,$ under which the discrete electromagnetic energy, defined by the quadratic form induced by $\\,\\mathbf{M}\\,$, is conserved in time for the source-free semi-discrete system $\\,\\mathbf{M}\\dot{\\mathbf{u}}=\\mathbf{K}\\mathbf{u}\\,$. Your derivation should begin from the definition of discrete energy as an inner-product-based quadratic functional and proceed by direct differentiation and algebraic manipulation using only linear algebra and properties of real matrices.\n\n2. In the presence of a dissipative mechanism representing ohmic losses acting only on the electric field, model the losses by adding a symmetric positive semidefinite block operator $\\,\\mathbf{R}_{e}=\\sigma\\,\\mathbf{M}_{e}\\,$ with $\\,\\sigma>0\\,$ to the electric equation, yielding the modified system\n$$\n\\mathbf{M}\\,\\dot{\\mathbf{u}}=\\left(\\mathbf{K}-\\mathbf{R}\\right)\\mathbf{u},\\qquad\n\\mathbf{R}=\\begin{bmatrix}\\mathbf{R}_{e}&\\mathbf{0}\\\\ \\mathbf{0}&\\mathbf{0}\\end{bmatrix}.\n$$\nDerive the discrete energy balance inequality for this system and state the algebraic condition that guarantees non-increasing energy.\n\n3. Investigate the effect of diagonal mass lumping on the spectral properties by replacing the consistent mass $\\,\\mathbf{M}\\,$ with a lumped diagonal approximation $\\,\\widetilde{\\mathbf{M}}\\,$ whose diagonal entries are the row-sums of $\\,\\mathbf{M}\\,$. Compare the spectra of the generalized eigenproblems\n$$\n\\mathbf{K}\\mathbf{v}=\\lambda\\,\\mathbf{M}\\mathbf{v}\\quad\\text{and}\\quad \\mathbf{K}\\mathbf{v}=\\lambda\\,\\widetilde{\\mathbf{M}}\\mathbf{v},\n$$\nin terms of their purely imaginary nature and the relative shift of the modal frequencies.\n\nYou must implement a program that constructs the above matrices and numerically verifies the derived properties on the following test suite of parameter values:\n\n- Test case A (lossless, energy conservation and imaginary spectrum):\n  - $\\,N=8\\,$, $\\,L=1.0\\,$.\n  - Build $\\,\\mathbf{M}\\,$ and $\\,\\mathbf{K}\\,$ as specified.\n  - Verify energy-conservation constraints derived in item $\\,1\\,$ by checking both the required symmetries and that all generalized eigenvalues $\\,\\lambda\\,$ of $\\,\\mathbf{K}\\mathbf{v}=\\lambda\\,\\mathbf{M}\\mathbf{v}\\,$ have real parts numerically equal to zero within a tolerance of $\\,10^{-9}\\,$.\n  - Also verify that the instantaneous discrete energy production rate evaluated as a quadratic form $\\,\\mathbf{u}^{\\top}\\mathbf{K}\\mathbf{u}\\,$ is numerically zero (within $\\,10^{-9}\\,$) for several random nonzero $\\,\\mathbf{u}\\,$.\n\n- Test case B (mass lumping spectral shift):\n  - Use the same $\\,N\\,$ and $\\,L\\,$.\n  - Form the lumped mass $\\,\\widetilde{\\mathbf{M}}\\,$ by diagonal row-sum lumping of $\\,\\mathbf{M}\\,$.\n  - Compute the nonzero modal frequencies $\\,\\omega=\\lvert\\operatorname{Im}(\\lambda)\\rvert\\,$ from both generalized eigenproblems, discard frequencies smaller than $\\,10^{-8}\\,$ as numerically zero, sort them increasingly, and report the maximum absolute relative deviation between frequency sets matched by index:\n  $$\n  \\max_{j}\\frac{\\lvert \\omega_{j}^{\\text{lumped}}-\\omega_{j}^{\\text{consistent}}\\rvert}{\\max\\{\\omega_{j}^{\\text{consistent}},\\,10^{-12}\\}}.\n  $$\n\n- Test case C (dissipative case with ohmic loss):\n  - Use the same $\\,N\\,$ and $\\,L\\,$, and set $\\,\\sigma=0.2\\,$.\n  - Form $\\,\\mathbf{R}_{e}=\\sigma\\,\\mathbf{M}_{e}\\,$ and $\\,\\mathbf{R}\\,$ as above, and define $\\,\\mathbf{K}_{\\text{loss}}=\\mathbf{K}-\\mathbf{R}\\,$.\n  - Verify the non-increasing energy condition from item $\\,2\\,$ by checking that $\\,\\mathbf{u}^{\\top}\\mathbf{K}_{\\text{loss}}\\mathbf{u}\\le 10^{-10}\\,$ for several random nonzero $\\,\\mathbf{u}\\,$.\n  - Compute the generalized eigenvalues of $\\,\\mathbf{K}_{\\text{loss}}\\mathbf{v}=\\lambda\\,\\mathbf{M}\\mathbf{v}\\,$ and report the maximum real part.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order and types:\n- First entry (boolean): result of Test case A overall pass, where all required symmetry and spectral checks and instantaneous energy production checks hold simultaneously.\n- Second entry (float): the maximum absolute relative deviation of frequencies from Test case B as defined above.\n- Third entry (boolean): result of the non-increasing energy verification in Test case C.\n- Fourth entry (float): the maximum real part of the generalized eigenvalues in Test case C.\n\nThe program must use no input and no files, and it must execute deterministically. Angles do not appear, and no physical units are required in the output. Your program should produce exactly one line in the format, for example, $[\\text{True},0.0123,\\text{True},-0.0456]$.",
            "solution": "The problem statement is analyzed to be valid. It is scientifically grounded in the principles of computational electromagnetics, specifically the finite element or finite difference time-domain methods for Maxwell's equations. The problem is well-posed, objective, and contains all necessary information to derive the required theoretical results and perform the numerical verifications.\n\nThe solution is presented in three parts, corresponding to the items in the problem description.\n\n### 1. Derivation of the Discrete Energy Conservation Condition\n\nThe discrete electromagnetic energy, $E(t)$, is defined by the quadratic form induced by the discrete mass operator $\\mathbf{M}$. For a physical interpretation, we define it as:\n$$\nE(t) = \\frac{1}{2} \\mathbf{u}(t)^{\\top} \\mathbf{M} \\mathbf{u}(t)\n$$\nHere, $\\mathbf{u}(t)$ is the state vector of degrees of freedom for the electric and magnetic fields. For this energy functional to be a valid measure of energy, it must be positive for any non-trivial state, meaning the matrix $\\mathbf{M}$ must be symmetric positive definite (SPD). The problem specifies $\\mathbf{M}_{e}=\\mathbf{M}_{h}=\\mathbf{M}_{\\mathrm{fe}}$, where $\\mathbf{M}_{\\mathrm{fe}}$ is the consistent mass matrix for linear finite elements. This matrix is known to be SPD, and thus the block-diagonal matrix $\\mathbf{M}$ is also SPD.\n\nTo derive the condition for energy conservation, we compute the time derivative of $E(t)$:\n$$\n\\frac{dE}{dt} = \\frac{d}{dt} \\left( \\frac{1}{2} \\mathbf{u}^{\\top} \\mathbf{M} \\mathbf{u} \\right)\n$$\nUsing the product rule for differentiation and noting that $\\mathbf{u}$ is a function of time $t$:\n$$\n\\frac{dE}{dt} = \\frac{1}{2} \\left( \\dot{\\mathbf{u}}^{\\top} \\mathbf{M} \\mathbf{u} + \\mathbf{u}^{\\top} \\mathbf{M} \\dot{\\mathbf{u}} \\right)\n$$\nSince $\\mathbf{M}$ is a real symmetric matrix ($\\mathbf{M} = \\mathbf{M}^{\\top}$), the two terms in the parenthesis are equal scalars: $\\dot{\\mathbf{u}}^{\\top} \\mathbf{M} \\mathbf{u} = (\\mathbf{u}^{\\top} \\mathbf{M}^{\\top} \\dot{\\mathbf{u}})^{\\top} = (\\mathbf{u}^{\\top} \\mathbf{M} \\dot{\\mathbf{u}})$. Thus, the expression simplifies to:\n$$\n\\frac{dE}{dt} = \\mathbf{u}^{\\top} \\mathbf{M} \\dot{\\mathbf{u}}\n$$\nWe now substitute the governing semi-discrete Maxwell system, $\\mathbf{M}\\dot{\\mathbf{u}}=\\mathbf{K}\\mathbf{u}$:\n$$\n\\frac{dE}{dt} = \\mathbf{u}^{\\top} (\\mathbf{K} \\mathbf{u}) = \\mathbf{u}^{\\top} \\mathbf{K} \\mathbf{u}\n$$\nEnergy is conserved if its time derivative is zero for any possible state $\\mathbf{u}(t)$. This requires the quadratic form $\\mathbf{u}^{\\top} \\mathbf{K} \\mathbf{u}$ to be identically zero for all vectors $\\mathbf{u} \\in \\mathbb{R}^{n}$. A fundamental result in linear algebra states that for a real matrix $\\mathbf{A}$, the quadratic form $\\mathbf{x}^{\\top}\\mathbf{A}\\mathbf{x} = 0$ for all real vectors $\\mathbf{x}$ if and only if $\\mathbf{A}$ is skew-symmetric, i.e., $\\mathbf{A}^{\\top} = -\\mathbf{A}$.\n\nTherefore, the algebraic constraint on $\\mathbf{K}$ for discrete energy conservation is that $\\mathbf{K}$ must be a skew-symmetric matrix. The problem defines $\\mathbf{K}=\\begin{bsmallmatrix}\\mathbf{0}&\\mathbf{C}\\\\ -\\mathbf{C}^{\\top}&\\mathbf{0}\\end{bsmallmatrix}$, for which the transpose is $\\mathbf{K}^{\\top}=\\begin{bsmallmatrix}\\mathbf{0}&-\\mathbf{C}\\\\ \\mathbf{C}^{\\top}&\\mathbf{0}\\end{bsmallmatrix} = -\\mathbf{K}$. This structure, inherent to compatible discretizations of Maxwell's equations, mathematically guarantees discrete energy conservation.\n\nIn summary, the algebraic constraints are:\n1.  $\\mathbf{M}$ must be symmetric positive definite.\n2.  $\\mathbf{K}$ must be skew-symmetric ($\\mathbf{K}^{\\top} = -\\mathbf{K}$).\n\n### 2. Discrete Energy Balance with Ohmic Losses\n\nIn the presence of ohmic losses, the system is modified to $\\mathbf{M}\\,\\dot{\\mathbf{u}}=\\left(\\mathbf{K}-\\mathbf{R}\\right)\\mathbf{u}$. The energy definition $E(t) = \\frac{1}{2} \\mathbf{u}^{\\top} \\mathbf{M} \\mathbf{u}$ remains unchanged, as it represents the energy stored in the fields. The rate of change of energy is found by following the same procedure as in Part 1, but substituting the modified system equation:\n$$\n\\frac{dE}{dt} = \\mathbf{u}^{\\top} \\mathbf{M} \\dot{\\mathbf{u}} = \\mathbf{u}^{\\top} \\left(\\mathbf{K}-\\mathbf{R}\\right) \\mathbf{u} = \\mathbf{u}^{\\top}\\mathbf{K}\\mathbf{u} - \\mathbf{u}^{\\top}\\mathbf{R}\\mathbf{u}\n$$\nFrom Part 1, we know that for an energy-conserving discretization, $\\mathbf{u}^{\\top}\\mathbf{K}\\mathbf{u} = 0$. This leaves us with the discrete energy balance equation (a semi-discrete Poynting's theorem):\n$$\n\\frac{dE}{dt} = -\\mathbf{u}^{\\top}\\mathbf{R}\\mathbf{u}\n$$\nThis equation states that the rate of change of stored energy is equal to the negative of the power dissipated, which is represented by the quadratic form $\\mathbf{u}^{\\top}\\mathbf{R}\\mathbf{u}$.\n\nFor the total energy to be non-increasing, we must have $\\frac{dE}{dt} \\le 0$ for any state $\\mathbf{u}$. This implies:\n$$\n-\\mathbf{u}^{\\top}\\mathbf{R}\\mathbf{u} \\le 0 \\quad \\implies \\quad \\mathbf{u}^{\\top}\\mathbf{R}\\mathbf{u} \\ge 0\n$$\nThe algebraic condition for a quadratic form $\\mathbf{x}^{\\top}\\mathbf{A}\\mathbf{x}$ to be non-negative for all real vectors $\\mathbf{x}$ is that the matrix $\\mathbf{A}$ must be symmetric positive semidefinite (SPSD).\n\nThe problem specifies $\\mathbf{R}=\\begin{bsmallmatrix}\\mathbf{R}_{e}&\\mathbf{0}\\\\ \\mathbf{0}&\\mathbf{0}\\end{bsmallmatrix}$ with $\\mathbf{R}_{e}=\\sigma\\,\\mathbf{M}_{e}$, where $\\sigma>0$ and $\\mathbf{M}_{e}=\\mathbf{M}_{\\mathrm{fe}}$ is SPD. Since $\\sigma$ is a positive scalar, $\\mathbf{R}_{e}$ is also SPD. The matrix $\\mathbf{R}$ is symmetric. The corresponding quadratic form is $\\mathbf{u}^{\\top}\\mathbf{R}\\mathbf{u} = \\mathbf{e}^{\\top}\\mathbf{R}_{e}\\mathbf{e} + \\mathbf{h}^{\\top}\\mathbf{0}\\mathbf{h} = \\mathbf{e}^{\\top}\\mathbf{R}_{e}\\mathbf{e}$. Since $\\mathbf{R}_{e}$ is SPD, $\\mathbf{e}^{\\top}\\mathbf{R}_{e}\\mathbf{e} \\ge 0$, with equality only if $\\mathbf{e}=\\mathbf{0}$. Thus, $\\mathbf{R}$ is symmetric positive semidefinite, and the condition for non-increasing energy is satisfied by its construction.\n\n### 3. Spectral Properties and Mass Lumping\n\nWe analyze the generalized eigenproblem $\\mathbf{K}\\mathbf{v}=\\lambda\\,\\mathbf{M}\\mathbf{v}$, which governs the modal behavior of the lossless system. Let $(\\lambda, \\mathbf{v})$ be an eigenpair, where $\\lambda \\in \\mathbb{C}$ and $\\mathbf{v} \\in \\mathbb{C}^{n}$ is a non-zero eigenvector.\nLeft-multiplying by the conjugate transpose of the eigenvector, $\\mathbf{v}^{\\dagger}$, gives:\n$$\n\\mathbf{v}^{\\dagger}\\mathbf{K}\\mathbf{v} = \\lambda\\,\\mathbf{v}^{\\dagger}\\mathbf{M}\\mathbf{v}\n$$\nTaking the conjugate transpose of this entire equation yields:\n$$\n(\\mathbf{v}^{\\dagger}\\mathbf{K}\\mathbf{v})^{\\dagger} = (\\lambda\\,\\mathbf{v}^{\\dagger}\\mathbf{M}\\mathbf{v})^{\\dagger} \\implies \\mathbf{v}^{\\dagger}\\mathbf{K}^{\\dagger}\\mathbf{v} = \\lambda^{*}\\,\\mathbf{v}^{\\dagger}\\mathbf{M}^{\\dagger}\\mathbf{v}\n$$\nSince $\\mathbf{K}$ and $\\mathbf{M}$ are real matrices, $\\mathbf{K}^{\\dagger}=\\mathbf{K}^{\\top}$ and $\\mathbf{M}^{\\dagger}=\\mathbf{M}^{\\top}$. Using the established properties that $\\mathbf{M}$ is symmetric ($\\mathbf{M}^{\\top}=\\mathbf{M}$) and $\\mathbf{K}$ is skew-symmetric ($\\mathbf{K}^{\\top}=-\\mathbf{K}$), this becomes:\n$$\n-\\mathbf{v}^{\\dagger}\\mathbf{K}\\mathbf{v} = \\lambda^{*}\\,\\mathbf{v}^{\\dagger}\\mathbf{M}\\mathbf{v}\n$$\nSubstituting $\\mathbf{v}^{\\dagger}\\mathbf{K}\\mathbf{v}$ from the first equation:\n$$\n-\\lambda\\,\\mathbf{v}^{\\dagger}\\mathbf{M}\\mathbf{v} = \\lambda^{*}\\,\\mathbf{v}^{\\dagger}\\mathbf{M}\\mathbf{v} \\implies (\\lambda + \\lambda^{*})\\,\\mathbf{v}^{\\dagger}\\mathbf{M}\\mathbf{v} = 0\n$$\nSince $\\mathbf{M}$ is SPD and $\\mathbf{v}$ is an eigenvector, the term $\\mathbf{v}^{\\dagger}\\mathbf{M}\\mathbf{v}$ is a positive real number. Therefore, we must have $\\lambda + \\lambda^{*} = 0$, which is equivalent to $2\\operatorname{Re}(\\lambda) = 0$. This proves that all eigenvalues $\\lambda$ of the lossless system are purely imaginary.\n\nThe same derivation applies to the mass-lumped system $\\mathbf{K}\\mathbf{v}=\\lambda\\,\\widetilde{\\mathbf{M}}\\mathbf{v}$. The lumped mass matrix $\\widetilde{\\mathbf{M}}$ is obtained by summing the rows of $\\mathbf{M}$ and placing the sums on the diagonal. Since $\\mathbf{M}$ has positive entries and its row sums are positive ($h$), $\\widetilde{\\mathbf{M}}$ is a diagonal matrix with positive entries, making it symmetric positive definite. As the argument for purely imaginary eigenvalues only requires the mass matrix to be SPD and $\\mathbf{K}$ to be skew-symmetric, the spectrum of the mass-lumped system is also purely imaginary.\n\nMass lumping alters the mass distribution, which in turn affects the modal frequencies $\\omega = |\\operatorname{Im}(\\lambda)|$. Mass lumping is known to affect higher-frequency modes more significantly and typically leads to an overestimation of the natural frequencies compared to the consistent mass formulation. The numerical test in Part B will quantify this spectral shift.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eig, block_diag\n\ndef solve():\n    \"\"\"\n    Constructs matrices for a 1D periodic semi-discrete Maxwell system and\n    verifies properties related to energy conservation, dissipation, and\n    mass lumping, as specified in the problem statement.\n    \"\"\"\n    # Define problem parameters for the test suite\n    N = 8\n    L = 1.0\n    sigma = 0.2\n    h = L / N\n    \n    # --- Matrix Construction Functions---\n    def create_M_fe(n, cell_size):\n        \"\"\"Creates the consistent finite element mass matrix for a 1D periodic domain.\"\"\"\n        mat = np.zeros((n, n))\n        for i in range(n):\n            mat[i, i] = 2.0 * cell_size / 3.0\n            mat[i, (i + 1) % n] = cell_size / 6.0\n            mat[i, (i - 1 + n) % n] = cell_size / 6.0\n        return mat\n\n    def create_D(n):\n        \"\"\"Creates the first-difference matrix with periodic boundary conditions.\"\"\"\n        mat = np.zeros((n, n))\n        for i in range(n):\n            mat[i, i] = -1.0\n            mat[i, (i - 1 + n) % n] = 1.0\n        return mat\n\n    # --- Build Core Matrices ---\n    M_fe = create_M_fe(N, h)\n    D = create_D(N)\n    C = (1.0 / h) * D\n    \n    M_e = M_fe\n    M_h = M_fe\n    \n    M = block_diag(M_e, M_h)\n    \n    Z = np.zeros((N, N))\n    K = np.block([[Z, C], [-C.T, Z]])\n\n    # Use a fixed seed for reproducible random vectors\n    rng = np.random.default_rng(0)\n    \n    # --- Test Case A: Lossless System Verification ---\n    # 1. Verify matrix symmetries\n    check1_M_symmetry = np.allclose(M, M.T, atol=1e-12, rtol=1e-12)\n    check2_K_skew_symmetry = np.allclose(K, -K.T, atol=1e-12, rtol=1e-12)\n    \n    # 2. Verify eigenvalues are purely imaginary\n    lambdas_A, _ = eig(K, M)\n    check3_imaginary_spectrum = np.all(np.abs(np.real(lambdas_A)) < 1e-9)\n    \n    # 3. Verify instantaneous energy production rate is zero\n    check4_energy_production = True\n    for _ in range(5):\n        u = rng.random(2 * N)\n        energy_prod_rate = u.T @ K @ u\n        if abs(energy_prod_rate) > 1e-9:\n            check4_energy_production = False\n            break\n            \n    result_A = all([check1_M_symmetry, check2_K_skew_symmetry, check3_imaginary_spectrum, check4_energy_production])\n\n    # --- Test Case B: Mass Lumping Spectral Shift ---\n    M_lump = np.diag(M.sum(axis=1))\n    \n    lambdas_consistent, _ = eig(K, M)\n    lambdas_lumped, _ = eig(K, M_lump)\n    \n    omega_consistent = np.abs(np.imag(lambdas_consistent))\n    omega_lumped = np.abs(np.imag(lambdas_lumped))\n    \n    # Filter out near-zero frequencies\n    freq_threshold = 1e-8\n    omega_consistent_nz = omega_consistent[omega_consistent > freq_threshold]\n    omega_lumped_nz = omega_lumped[omega_lumped > freq_threshold]\n    \n    # Sort frequencies to match modes by magnitude\n    omega_consistent_nz.sort()\n    omega_lumped_nz.sort()\n    \n    if len(omega_consistent_nz) == len(omega_lumped_nz) and len(omega_consistent_nz) > 0:\n        rel_devs = np.abs(omega_lumped_nz - omega_consistent_nz) / np.maximum(omega_consistent_nz, 1e-12)\n        result_B = np.max(rel_devs)\n    else:\n        # This case should not be reached for a valid problem setup\n        result_B = np.nan\n\n    # --- Test Case C: Dissipative System Verification ---\n    R_e = sigma * M_e\n    R = block_diag(R_e, np.zeros((N, N)))\n    K_loss = K - R\n    \n    # 1. Verify non-increasing energy condition\n    check5_non_increasing_energy = True\n    for _ in range(5):\n        u = rng.random(2 * N)\n        dissipation_rate = u.T @ K_loss @ u\n        # Check that energy does not increase (within numerical tolerance)\n        if dissipation_rate > 1e-10:\n            check5_non_increasing_energy = False\n            break\n\n    result_C = check5_non_increasing_energy\n    \n    # 2. Compute the maximum real part of the eigenvalues\n    lambdas_C, _ = eig(K_loss, M)\n    result_D = np.max(np.real(lambdas_C))\n    \n    # --- Final Output ---\n    final_results = [result_A, result_B, result_C, result_D]\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Solving static or low-frequency electromagnetic problems in domains with complex topology, such as those containing holes, often leads to singular linear systems. This advanced practice tackles this challenge by introducing the discrete Hodge decomposition, which elegantly separates the vector space of fields into distinct physical components . You will learn to compute the basis for the problematic 'harmonic' subspace responsible for the singularity and construct a projection-based preconditioner to remove it, transforming an ill-posed problem into a well-posed one and demonstrating a powerful technique used in state-of-the-art solvers.",
            "id": "3324090",
            "problem": "Consider a discrete setting for computational electromagnetics on a two-dimensional structured grid, in which edge-based fields approximate the electric field and node-based scalars approximate potentials. Let the edge space be a finite-dimensional real vector space denoted by $\\mathcal{E} = \\mathbb{R}^m$, the node space by $\\mathbb{R}^n$, and the face space by $\\mathbb{R}^f$. Define the incidence matrices $\\,\\mathbf{G} \\in \\mathbb{R}^{m \\times n}\\,$ and $\\,\\mathbf{C} \\in \\mathbb{R}^{f \\times m}\\,$ such that $\\,\\mathbf{G}\\,$ maps node-based scalars to edge-based gradients (discrete gradient), and $\\,\\mathbf{C}\\,$ maps edge-based fields to face-based circulations (discrete curl). For this problem, use the Euclidean inner product so that the discrete divergence operator is $\\,\\mathbf{D} = \\mathbf{G}^\\top \\in \\mathbb{R}^{n \\times m}\\,$. The fundamental vector calculus identities $\\,\\nabla \\times \\nabla \\phi = \\mathbf{0}\\,$ and $\\,\\nabla \\cdot (\\nabla \\times \\mathbf{A}) = 0\\,$ are represented discretely by $\\,\\mathbf{C}\\mathbf{G} = \\mathbf{0}\\,$ and $\\,\\mathbf{D}\\mathbf{C}^\\top = \\mathbf{0}\\,$. In multiply-connected geometries, the edge space admits a discrete Hodge decomposition\n$$\n\\mathcal{E} = \\mathrm{range}(\\mathbf{G}) \\oplus \\mathrm{range}(\\mathbf{C}^\\top) \\oplus \\mathcal{H},\n$$\nwhere the harmonic subspace $\\,\\mathcal{H}\\,$ satisfies $\\,\\mathcal{H} = \\ker(\\mathbf{C}) \\cap \\ker(\\mathbf{D})\\,$ and its dimension equals the number of topological holes (the first Betti number).\n\nConsider the symmetric positive semidefinite matrix\n$$\n\\mathbf{A} = \\mathbf{C}^\\top \\mathbf{C} + \\gamma\\, \\mathbf{G}\\mathbf{G}^\\top \\in \\mathbb{R}^{m \\times m},\n$$\nwith $\\,\\gamma > 0\\,$ a real parameter. This discrete operator is analogous to a vector Laplacian acting on edge fields, where $\\,\\mathbf{C}^\\top \\mathbf{C}\\,$ penalizes solenoidal components and $\\,\\gamma\\,\\mathbf{G}\\mathbf{G}^\\top\\,$ penalizes coexact components. The harmonic subspace $\\,\\mathcal{H}\\,$ lies in the nullspace of $\\,\\mathbf{A}\\,$ because $\\,\\mathbf{C}\\mathbf{h} = \\mathbf{0}\\,$ and $\\,\\mathbf{G}^\\top \\mathbf{h} = \\mathbf{0}\\,$ for all $\\,\\mathbf{h} \\in \\mathcal{H}\\,$.\n\nYour task is to design a preconditioner that explicitly removes the harmonic subspace by projecting out $\\,\\mathcal{H}\\,$ and to study the effect of this projection on the spectrum of $\\,\\mathbf{A}\\,$. Specifically, you must:\n\n- Construct $\\,\\mathbf{G}\\,$ and $\\,\\mathbf{C}\\,$ for structured grids of size $\\,n_x \\times n_y\\,$ faces, possibly with interior holes (faces deliberately removed), using consistent orientations: edges oriented in the positive coordinate directions and faces oriented counterclockwise. Let $\\,\\mathbf{D} = \\mathbf{G}^\\top\\,$.\n- Compute an orthonormal basis $\\,\\mathbf{H}\\,$ for the harmonic subspace $\\,\\mathcal{H} = \\ker(\\mathbf{C}) \\cap \\ker(\\mathbf{D})\\,$ by finding the nullspace of the block matrix\n$$\n\\mathbf{B} = \\begin{bmatrix} \\mathbf{C} \\\\ \\mathbf{D} \\end{bmatrix}.\n$$\n- Form the orthogonal projector onto the harmonic subspace $\\,\\Pi_{\\mathcal{H}} = \\mathbf{H}\\mathbf{H}^\\top\\,$ and the complementary projector $\\,\\mathbf{R} = \\mathbf{I}_m - \\Pi_{\\mathcal{H}}\\,$ that removes the harmonic components.\n- Study the spectral effect of removing $\\,\\mathcal{H}\\,$ by computing the eigenvalues of $\\,\\mathbf{A}\\,$ and of the restriction of $\\,\\mathbf{A}\\,$ to $\\,\\mathrm{range}(\\mathbf{R})\\,$. To obtain the restricted spectrum, build an orthonormal basis $\\,\\mathbf{Q}\\,$ for $\\,\\mathrm{range}(\\mathbf{R})\\,$ and compute the eigenvalues of $\\,\\mathbf{Q}^\\top \\mathbf{A}\\mathbf{Q}\\,$. Quantify:\n  1. The dimension of $\\,\\mathcal{H}\\,$.\n  2. The count of numerically zero eigenvalues of $\\,\\mathbf{A}\\,$ (within a tolerance).\n  3. The smallest positive eigenvalue of $\\,\\mathbf{A}\\,$.\n  4. The smallest eigenvalue of the restricted operator $\\,\\mathbf{Q}^\\top \\mathbf{A}\\mathbf{Q}\\,$.\n  5. The condition number of the restricted operator, defined as the ratio of largest to smallest eigenvalue.\n  6. A boolean verifying the discrete Hodge decomposition dimension identity\n     $$ m = \\mathrm{rank}(\\mathbf{G}) + \\mathrm{rank}(\\mathbf{C}^\\top) + \\dim(\\mathcal{H}). $$\n\nUse the following test suite of geometries and parameter values to cover different connectivity regimes:\n\n- Case 1 (simply-connected): $\\,n_x = 2,\\, n_y = 2\\,$, no holes, $\\,\\gamma = 1.0\\,$.\n- Case 2 (one hole): $\\,n_x = 3,\\, n_y = 3\\,$, remove the interior face at index $\\, (i,j) = (1,1)\\,$ (zero-based indexing), $\\,\\gamma = 1.0\\,$.\n- Case 3 (two holes): $\\,n_x = 4,\\, n_y = 4\\,$, remove the two interior faces at indices $\\, (i,j) = (1,1)\\,$ and $\\, (2,2)\\,$, $\\,\\gamma = 1.0\\,$.\n\nYour program must compute the quantities listed above for each case. Angles do not appear and no physical units are required; treat all quantities as dimensionless. Use a numerical tolerance of $\\,10^{-10}\\,$ to decide whether an eigenvalue is numerically zero.\n\nFinal output specification: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list in the order\n$$\n[\\dim(\\mathcal{H}),\\ \\text{zero\\_count}(\\mathbf{A}),\\ \\lambda_{\\min}^+(\\mathbf{A}),\\ \\lambda_{\\min}(\\mathbf{Q}^\\top \\mathbf{A}\\mathbf{Q}),\\ \\kappa(\\mathbf{Q}^\\top \\mathbf{A}\\mathbf{Q}),\\ \\text{decomp\\_valid}],\n$$\nwith $\\,\\lambda_{\\min}^+(\\mathbf{A})\\,$ the smallest positive eigenvalue of $\\,\\mathbf{A}\\,$ and $\\,\\kappa(\\cdot)\\,$ the condition number of the restricted operator. For example, the single output line must look like\n$$\n[[\\cdots],[\\cdots],[\\cdots]].\n$$",
            "solution": "The user-provided problem is valid. It is scientifically grounded in the principles of discrete exterior calculus (or mimetic finite differences) as applied to computational electromagnetics. All terms are mathematically well-defined, the objectives are clear and quantifiable, and the problem is self-contained. There are no contradictions, ambiguities, or pseudo-scientific claims. We can proceed with a formal solution.\n\nThe core task is to analyze the spectral properties of a discrete vector Laplacian operator, $\\mathbf{A}$, and understand how its singularity, which arises from the non-trivial topology of the domain (holes), can be removed by projection. The harmonic subspace $\\mathcal{H}$, whose dimension equals the number of holes, forms the nullspace of $\\mathbf{A}$. By projecting out this subspace, we obtain a restricted operator that is positive definite and thus invertible, which is a crucial step in solving linear systems of the form $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$.\n\nOur methodology proceeds as follows:\n1.  **Discretization and Operator Construction**: We model the two-dimensional domain on a structured grid. The fundamental entities are nodes (0-cells), edges (1-cells), and faces (2-cells). We establish a consistent row-major numbering scheme for each entity type.\n    -   A grid with $n_y \\times n_x$ faces has $(n_y+1) \\times (n_x+1)$ nodes, $m_h = (n_y+1) n_x$ horizontal edges, and $m_v = n_y (n_x+1)$ vertical edges, for a total of $m = m_h + m_v$ edges.\n    -   The discrete gradient operator, $\\mathbf{G} \\in \\mathbb{R}^{m \\times n}$, is constructed as the incidence matrix mapping nodes to edges. Each row, corresponding to an edge, has entries $+1$ and $-1$ at the columns corresponding to its head and tail nodes, respectively, reflecting the potential difference.\n    -   The discrete curl operator, $\\mathbf{C} \\in \\mathbb{R}^{f \\times m}$, is constructed as the incidence matrix mapping edges to faces. Each row, corresponding to a face, has four non-zero entries $(\\pm 1)$ representing the oriented sum (circulation) of fields on its four bounding edges. A counter-clockwise orientation is used.\n    -   Holes are incorporated by simply omitting the corresponding rows from the $\\mathbf{C}$ matrix, reducing the total number of faces $f$.\n    -   The discrete divergence operator is defined as the transpose of the gradient, $\\mathbf{D} = \\mathbf{G}^\\top$.\n\n2.  **Harmonic Subspace Basis**: The harmonic subspace $\\mathcal{H}$ consists of edge fields that are both curl-free and divergence-free, i.e., $\\mathcal{H} = \\ker(\\mathbf{C}) \\cap \\ker(\\mathbf{D})$. We find an orthonormal basis $\\mathbf{H}$ for this subspace by computing the nullspace of the combined matrix $\\mathbf{B} = \\begin{bmatrix} \\mathbf{C} \\\\ \\mathbf{D} \\end{bmatrix}$. The dimension of $\\mathcal{H}$, denoted $\\dim(\\mathcal{H})$, is simply the number of basis vectors (columns) in $\\mathbf{H}$. This is the first quantity to be computed.\n\n3.  **Spectral Analysis of $\\mathbf{A}$**: The operator $\\mathbf{A} = \\mathbf{C}^\\top \\mathbf{C} + \\gamma\\, \\mathbf{G}\\mathbf{G}^\\top$ is a symmetric positive semidefinite matrix. Its nullspace is precisely the harmonic subspace $\\mathcal{H}$. We compute the eigenvalues of $\\mathbf{A}$ using a standard eigensolver for symmetric matrices.\n    -   The number of numerically zero eigenvalues, determined using a tolerance of $10^{-10}$, should equal $\\dim(\\mathcal{H})$. This is the second quantity.\n    -   The smallest strictly positive eigenvalue, $\\lambda_{\\min}^+(\\mathbf{A})$, is found by filtering out the zero eigenvalues and taking the minimum of the remaining set. This is the third quantity.\n\n4.  **Projection and Restricted Operator**: To remove the nullspace, we define an orthogonal projector $\\mathbf{R} = \\mathbf{I}_m - \\mathbf{H}\\mathbf{H}^\\top$, where $\\mathbf{I}_m$ is the identity matrix of size $m \\times m$. This operator projects any vector in the edge space $\\mathcal{E}$ onto the orthogonal complement of $\\mathcal{H}$. The range of $\\mathbf{R}$ is the space $\\mathrm{range}(\\mathbf{G}) \\oplus \\mathrm{range}(\\mathbf{C}^\\top)$.\n    -   We construct an orthonormal basis $\\mathbf{Q}$ for the range of $\\mathbf{R}$. A robust numerical method for this is to compute the singular value decomposition (SVD) of $\\mathbf{R}$ and take the a basis for its range space.\n    -   The action of $\\mathbf{A}$ is then restricted to this subspace by forming the matrix $\\mathbf{Q}^\\top \\mathbf{A} \\mathbf{Q}$. This restricted operator is symmetric and, by construction, positive definite.\n    -   We compute the eigenvalues of the restricted operator. Its smallest eigenvalue, $\\lambda_{\\min}(\\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q})$, should theoretically be equal to $\\lambda_{\\min}^+(\\mathbf{A})$. This is the fourth quantity.\n    -   The condition number of the restricted operator, $\\kappa(\\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q})$, is calculated as the ratio of its largest to its smallest eigenvalue. This is the fifth quantity.\n\n5.  **Decomposition Verification**: As a final sanity check, we verify the discrete Hodge decomposition identity, $m = \\mathrm{rank}(\\mathbf{G}) + \\mathrm{rank}(\\mathbf{C}^\\top) + \\dim(\\mathcal{H})$. The ranks of the matrices are computed numerically. This boolean result is the sixth and final quantity for each test case.\n\nThe following Python code implements this procedure for the specified test cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Computes spectral properties of a discrete vector Laplacian on 2D grids\n    with and without topological holes, demonstrating the effect of projecting\n    out the harmonic subspace.\n    \"\"\"\n\n    def _compute_case(nx, ny, holes, gamma, tol=1e-10):\n        \"\"\"\n        Performs all computations for a single test case configuration.\n        \n        Args:\n            nx (int): Number of faces in the x-direction.\n            ny (int): Number of faces in the y-direction.\n            holes (list): A list of (row, col) tuples for removed faces.\n            gamma (float): The penalty parameter for the gradient term.\n            tol (float): Numerical tolerance for zero-checking.\n\n        Returns:\n            list: A list containing the six required analysis quantities.\n        \"\"\"\n        # 1. Grid dimensions and numbering schemes\n        # We consistently use (row, col) indexing.\n        n_nodes_y, n_nodes_x = ny + 1, nx + 1\n        n_nodes = n_nodes_y * n_nodes_x\n        \n        num_h_edges = (ny + 1) * nx\n        num_v_edges = ny * (nx + 1)\n        m = num_h_edges + num_v_edges\n        \n        def node_idx(r, c):   return r * n_nodes_x + c\n        def hedge_idx(r, c):  return r * nx + c\n        def vedge_idx(r, c):  return num_h_edges + r * (nx + 1) + c\n\n        # 2. Construct G (discrete gradient) matrix\n        G = np.zeros((m, n_nodes))\n        for r in range(ny + 1):\n            for c in range(nx):\n                G[hedge_idx(r, c), node_idx(r, c)] = -1\n                G[hedge_idx(r, c), node_idx(r, c + 1)] = 1\n        for r in range(ny):\n            for c in range(nx + 1):\n                G[vedge_idx(r, c), node_idx(r, c)] = -1\n                G[vedge_idx(r, c), node_idx(r + 1, c)] = 1\n\n        # 3. Construct C (discrete curl) matrix, accounting for holes\n        face_map = { (r, c): i for i, (r, c) in enumerate(\n            (r, c) for r in range(ny) for c in range(nx) if (r, c) not in holes\n        )}\n        f = len(face_map)\n        C = np.zeros((f, m))\n        \n        for (r_face, c_face), row_idx in face_map.items():\n            C[row_idx, hedge_idx(r_face, c_face)] = 1      # bottom\n            C[row_idx, vedge_idx(r_face, c_face + 1)] = 1  # right\n            C[row_idx, hedge_idx(r_face + 1, c_face)] = -1 # top\n            C[row_idx, vedge_idx(r_face, c_face)] = -1     # left\n    \n        # 4. Construct B and find orthonormal basis H for the harmonic subspace\n        D = G.T\n        B = np.vstack([C, D]) if C.size > 0 else D\n        H = null_space(B, rcond=tol)\n        dim_H = H.shape[1]\n\n        # 5. Construct A and compute its spectrum\n        A = C.T @ C + gamma * G @ G.T\n        eivals_A = np.linalg.eigh(A)[0]\n        \n        is_zero = np.abs(eivals_A) < tol\n        eivals_A[is_zero] = 0.0\n        \n        zero_count_A = np.sum(is_zero)\n        pos_eivals_A = eivals_A[eivals_A > 0.0]\n        lambda_min_pos_A = np.min(pos_eivals_A) if pos_eivals_A.size > 0 else np.nan\n        \n        # 6. Project out the harmonic subspace and analyze the restricted operator\n        R = np.eye(m) - H @ H.T\n        \n        U, s, _ = np.linalg.svd(R)\n        rank_R = np.sum(s > tol)\n        Q = U[:, :rank_R]\n        \n        A_res = Q.T @ A @ Q\n        # The eigenvalues should be real due to symmetry\n        eivals_res = np.linalg.eigh(A_res)[0]\n        \n        lambda_min_res = np.min(eivals_res) if eivals_res.size > 0 else np.nan\n        lambda_max_res = np.max(eivals_res) if eivals_res.size > 0 else np.nan\n        \n        if lambda_min_res > tol:\n            kappa_res = lambda_max_res / lambda_min_res\n        elif eivals_res.size > 0:\n            kappa_res = np.inf\n        else: \n            kappa_res = np.nan\n\n        # 7. Verify Hodge decomposition dimension identity\n        rank_G = np.linalg.matrix_rank(G, tol=tol)\n        rank_C_T = np.linalg.matrix_rank(C.T, tol=tol)\n        decomp_valid = (m == rank_G + rank_C_T + dim_H)\n\n        # Return the 6 required quantities\n        return [dim_H, zero_count_A, lambda_min_pos_A, lambda_min_res, kappa_res, decomp_valid]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (nx, ny, holes, gamma)\n        (2, 2, [], 1.0),\n        # Case 2: Remove face at (row=1, col=1)\n        (3, 3, [(1, 1)], 1.0),\n        # Case 3: Remove faces at (row=1, col=1) and (row=2, col=2)\n        (4, 4, [(1, 1), (2, 2)], 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        nx, ny, holes, gamma = case\n        result = _compute_case(nx, ny, holes, gamma)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}