{
    "hands_on_practices": [
        {
            "introduction": "理论学习的核心是将抽象的数学定理转化为具体的物理洞察力。高斯定律的积分形式和微分形式之间的等价性由高斯散度定理保证，这是矢量微积分的基石。本实践  旨在通过编写程序，在任意凸多面体这种复杂几何结构上，数值验证散度定理的精确性，从而加深对这一基本定理在计算科学中应用的理解。",
            "id": "3310393",
            "problem": "设计并实现一个程序，用于在高度扭曲的凸多面体控制体上，数值验证电位移高斯定律的积分形式与微分形式之间的等价性。该验证必须通过计算每个控制体 $K$ 穿过其边界的电位移场外向通量与其内部自由电荷密度的体积分之间的绝对差值来执行，即以下量\n$$\n\\left|\\sum_{f \\subset \\partial K} \\int_{f} \\mathbf{D}\\cdot \\mathbf{n}_{f}\\, dA \\;-\\; \\int_{K} \\rho\\, dV \\right|.\n$$\n程序必须仅使用具有指定精度属性的数值积分方法，在一组给定的扭曲多面体单元上计算此差值。所有物理量必须使用国际单位制（SI）表示。最终输出必须是以库仑（C）为单位的绝对差值，每个测试用例一个。\n\n使用的基本原理：\n- 计算电磁学中应用的散度矢量微积分定义和散度定理。\n- 电位移场的本构高斯定律的微分形式指出，电位移场的散度等于自由电荷密度，其积分形式则将 $\\mathbf{D}$ 的外向通量等同于所包含的自由电荷。除下文规定外，您不得假定任何边界条件或材料关系。\n- 在单纯形上具有可证明多项式精确性的数值积分法则：三角形上的2阶对称三点积分法和四面体上的形心法则。\n\n场设定：\n- 通过二次多项式分量定义电位移场 $\\mathbf{D}:\\mathbb{R}^3\\to\\mathbb{R}^3$\n$$\nD_x(x,y,z) = a\\,x^2 + b\\,y z + c\\,x + d,\\quad\nD_y(x,y,z) = e\\,y^2 + f\\,z x + g\\,y + h,\\quad\nD_z(x,y,z) = i\\,z^2 + j\\,x y + k\\,z + l,\n$$\n其中常数为\n$$\na=0.7,\\; b=-1.3,\\; c=0.25,\\; d=-0.5,\\quad\ne=-0.4,\\; f=1.1,\\; g=0.35,\\; h=0.2,\\quad\ni=0.6,\\; j=-0.9,\\; k=-0.45,\\; l=0.1.\n$$\n根据散度的定义，自由电荷密度为\n$$\n\\rho(x,y,z) = \\frac{\\partial D_x}{\\partial x} + \\frac{\\partial D_y}{\\partial y} + \\frac{\\partial D_z}{\\partial z}\n= 2 a\\,x + 2 e\\,y + 2 i\\,z + c + g + k\n= 1.4\\,x - 0.8\\,y + 1.2\\,z + 0.15.\n$$\n将 $\\mathbf{D}$ 的单位解释为库仑/平方米 (C/m$^2$)，$\\rho$ 的单位解释为库仑/立方米 (C/m$^3$)。\n\n几何与数值设置：\n- 对于每个多面体控制体 $K$，外向通量 $\\sum_{f \\subset \\partial K} \\int_{f} \\mathbf{D}\\cdot \\mathbf{n}_{f}\\, dA$ 的计算必须通过以下步骤完成：将每个平面多边形面 $f$ 围绕一个顶点进行扇形三角剖分，分解为多个三角形 $(\\mathbf{a},\\mathbf{b},\\mathbf{c})$；在该面上取外向单位法向量 $\\mathbf{n}_f$ 为常数；并在每个三角形上应用2阶对称三点积分法：\n  - 使用重心坐标积分点 $(\\lambda_1,\\lambda_2,\\lambda_3) \\in \\{(2/3,1/6,1/6),(1/6,2/3,1/6),(1/6,1/6,2/3)\\}$，权重相等，为 $w=1/3$。\n  - 将每个重心坐标元组映射到一个物理点 $\\mathbf{p}=\\lambda_1 \\mathbf{a}+\\lambda_2 \\mathbf{b}+\\lambda_3 \\mathbf{c}$，并对该面的所有积分点和所有三角形累加 $\\sum w\\, (\\mathbf{D}(\\mathbf{p})\\cdot \\mathbf{n}_f)\\, \\text{area}(\\triangle \\mathbf{a}\\mathbf{b}\\mathbf{c})$。\n- 体积分 $\\int_{K} \\rho\\, dV$ 的计算必须通过以下步骤完成：将凸多面体分解为多个四面体，这些四面体由严格位于 $K$ 内部的一个参考点 $\\mathbf{r}$ 和每个面的三角扇构成；并在每个四面体上应用形心法则：\n  - 对于每个顶点为 $(\\mathbf{r},\\mathbf{a},\\mathbf{b},\\mathbf{c})$ 的四面体，使用其形心 $\\mathbf{m}=(\\mathbf{r}+\\mathbf{a}+\\mathbf{b}+\\mathbf{c})/4$ 和精确体积 $V_{\\text{tet}} = \\left|\\det(\\mathbf{a}-\\mathbf{r},\\mathbf{b}-\\mathbf{r},\\mathbf{c}-\\mathbf{r})\\right|/6$，并累加 $\\rho(\\mathbf{m})\\, V_{\\text{tet}}$。\n  - 您必须使用等于 $K$ 所有顶点算术平均值的点 $\\mathbf{r}$，对于此处提供的所有凸测试单元，该点都位于 $K$ 内部。\n\n测试套件（所有坐标单位均为米）：\n- 测试用例1（扭曲四面体）。顶点：$(0,0,0)$, $(3.0,0.1,0.0)$, $(0.2,2.5,0.05)$, $(0.1,0.05,0.8)$。面（以顶点环路表示）：$[0,1,2]$, $[0,3,1]$, $[1,3,2]$, $[2,3,0]$。\n- 测试用例2（高度扭曲、近退化的四面体）。顶点：$(0,0,0)$, $(10.0,0.01,0.02)$, $(0.02,9.0,0.03)$, $(0.01,0.02,0.001)$。面：$[0,1,2]$, $[0,3,1]$, $[1,3,2]$, $[2,3,0]$。\n- 测试用例3（仿射扭曲六面体）。从索引为0到7的单位立方体顶点开始：$(0,0,0)$, $(1,0,0)$, $(1,1,0)$, $(0,1,0)$, $(0,0,1)$, $(1,0,1)$, $(1,1,1)$, $(0,1,1)$。应用仿射变换 $(x',y',z') = (x + 0.8 y + 0.6 z,\\; 1.2 y + 0.1 z,\\; 0.2 y + 0.9 z)$。面（以变换后列表中的索引环路表示）：$[0,1,2,3]$, $[4,5,6,7]$, $[0,3,7,4]$, $[1,5,6,2]$, $[0,1,5,4]$, $[3,2,6,7]$。\n- 测试用例4（剪切五角棱柱）。底面五边形位于 $z=0$ 平面，顶点（索引0到4）为：$(0.0,0.0,0.0)$, $(2.0,0.2,0.0)$, $(2.5,1.5,0.0)$, $(1.2,2.6,0.0)$, $(-0.1,1.3,0.0)$。顶面五边形通过剪切和提升获得：对于每个底面点 $(x,y,0)$，定义顶面点 $(x+1.5,\\; y-0.4,\\; 0.3)$。顶面顶点的索引为5到9，对应于底面索引0到4。面：底面 $[0,1,2,3,4]$，顶面 $[5,6,7,8,9]$，以及五个侧面 $[0,1,6,5]$, $[1,2,7,6]$, $[2,3,8,7]$, $[3,4,9,8]$, $[4,0,5,9]$。\n\n实现要求：\n- 对于每个面，确保其顶点环路方向产生外向法线。您必须通过计算一个临时面法线来强制实现外向定向，如果法线指向多面体形心而不是背离它，则翻转环路。\n- 对于每个测试用例，计算以库仑（C）为单位的绝对差值 $\\left|\\sum_{f} \\int_{f} \\mathbf{D}\\cdot \\mathbf{n}_{f}\\, dA - \\int_{K} \\rho\\, dV \\right|$。\n- 角度单位不适用。所有输出值必须以库仑（C）为单位。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[r1,r2,r3,r4]”）。每个条目必须是一个浮点数。\n\n预期的行为是，对于这些积分选择，即使在高度扭曲的单元上，差值也应在数值舍入误差的量级上，因为二次场 $\\mathbf{D}$ 的面积分和线性场 $\\rho$ 的体积分，通过指定的积分法则在单纯形子单元上可以被精确积分。",
            "solution": "目标是在若干凸多面体控制体 $K$ 上，对给定的电位移场 $\\mathbf{D}$，数值验证高斯定律的积分形式与微分形式之间的等价性。此等价性由散度定理阐明，该定理指出，矢量场穿过闭合曲面的外向通量等于该矢量场在曲面所围体积内的散度的体积分：\n$$\n\\sum_{f \\subset \\partial K} \\int_{f} \\mathbf{D}\\cdot \\mathbf{n}_{f}\\, dA = \\int_{K} (\\nabla \\cdot \\mathbf{D})\\, dV\n$$\n在此背景下，$\\nabla \\cdot \\mathbf{D} = \\rho$，其中 $\\rho$ 是自由电荷密度。任务简化为计算左侧（总通量）和右侧（总围含电荷）之间的绝对差值。\n\n电位移场 $\\mathbf{D}(x,y,z)$ 是一个具有二次多项式分量的矢量场：\n$$\n\\begin{aligned}\nD_x(x,y,z) = 0.7\\,x^2 - 1.3\\,y z + 0.25\\,x - 0.5 \\\\\nD_y(x,y,z) = -0.4\\,y^2 + 1.1\\,z x + 0.35\\,y + 0.2 \\\\\nD_z(x,y,z) = 0.6\\,z^2 - 0.9\\,x y - 0.45\\,z + 0.1\n\\end{aligned}\n$$\n自由电荷密度 $\\rho(x,y,z)$ 是 $\\mathbf{D}$ 的散度：\n$$\n\\rho(x,y,z) = \\frac{\\partial D_x}{\\partial x} + \\frac{\\partial D_y}{\\partial y} + \\frac{\\partial D_z}{\\partial z}\n= 1.4\\,x - 0.8\\,y + 1.2\\,z + 0.15\n$$\n值得注意的是，$\\mathbf{D}$ 是一个二次多项式场，其散度 $\\rho$ 是一个线性多项式场。\n\n数值策略取决于针对这些被积函数所选择的、具有精确性属性的特定积分法则。\n\n**1. 通量积分 $\\int_{\\partial K} \\mathbf{D}\\cdot \\mathbf{n}\\,dA$ 的计算**\n\n总通量是穿过多面体 $K$ 的每个平面 $f$ 的通量之和。对于每个面，单位法向量 $\\mathbf{n}_f$ 是恒定的。被积函数 $\\mathbf{D}(x,y,z) \\cdot \\mathbf{n}_f$ 是空间坐标 $(x,y,z)$ 的一个二次多项式。为计算多边形面上的积分，首先将该面分解为一组扇形三角形，其定义环路的第一个顶点作为公共顶点。\n\n对于每个三角形 $(\\mathbf{a},\\mathbf{b},\\mathbf{c})$，使用指定的2阶对称三点积分法则计算积分。该法则对最高为2次的多项式是精确的。积分点 $\\mathbf{p}_k$ 通过重心坐标 $(\\lambda_1, \\lambda_2, \\lambda_3)$ 定义为 $\\mathbf{p}_k = \\lambda_1^{(k)}\\mathbf{a} + \\lambda_2^{(k)}\\mathbf{b} + \\lambda_3^{(k)}\\mathbf{c}$。指定的点为 $\\{(2/3, 1/6, 1/6), (1/6, 2/3, 1/6), (1/6, 1/6, 2/3)\\}$，每个点的权重为 $w_k=1/3$。\n因此，单个三角形上的积分可以精确计算为：\n$$\n\\int_{\\triangle} \\mathbf{D} \\cdot \\mathbf{n}_f \\,dA = \\text{Area}(\\triangle) \\sum_{k=1}^3 w_k \\, (\\mathbf{D}(\\mathbf{p}_k) \\cdot \\mathbf{n}_f)\n$$\n总通量是构成边界 $\\partial K$ 的所有三角形上的这些值的总和。\n\n**2. 电荷积分 $\\int_K \\rho\\,dV$ 的计算**\n\n总电荷通过将多面体 $K$ 分解为一组四面体来计算。这种分解是通过在多面体内部选择一个参考点 $\\mathbf{r}$（取为其顶点的算术平均值），并为边界曲面上的每个三角形构建一个四面体来实现的。因此，一个四面体由顶点 $(\\mathbf{r}, \\mathbf{a}, \\mathbf{b}, \\mathbf{c})$ 定义，其中 $(\\mathbf{a}, \\mathbf{b}, \\mathbf{c})$ 是来自某个面扇形三角剖分的一个三角形的顶点。该方法确保了对凸体 $K$ 的完全剖分。\n\n被积函数 $\\rho(x,y,z)$ 是一个线性多项式。每个四面体上的积分使用形心法则计算，即在四面体的形心 $\\mathbf{m} = (\\mathbf{r}+\\mathbf{a}+\\mathbf{b}+\\mathbf{c})/4$ 处求被积函数的值。这个单点法则对线性多项式是精确的。\n因此，单个四面体上的积分可以精确计算为：\n$$\n\\int_{\\text{tet}} \\rho\\, dV = V_{\\text{tet}} \\cdot \\rho(\\mathbf{m})\n$$\n其中体积由 $V_{\\text{tet}} = \\frac{1}{6} |\\det(\\mathbf{a}-\\mathbf{r}, \\mathbf{b}-\\mathbf{r}, \\mathbf{c}-\\mathbf{r})|$ 给出。总电荷是分解中所有四面体上这些值的总和。\n\n**3. 算法实现**\n\n对于每个测试用例，算法的核心流程如下：\n1.  **预处理**：建立多面体 $K$ 的顶点和面环路列表。计算多面体形心 $\\mathbf{r}$，即所有顶点坐标的算术平均值。\n2.  **面迭代**：算法遍历由顶点索引环路定义的每个面。\n3.  **法线定向**：对于每个面，根据其环路中的前三个顶点计算一个临时法线。检查该法线与从多面体形心 $\\mathbf{r}$ 指向面上一点（例如第一个顶点）的向量的点积。如果点积为负，则法线指向内部，此时反转该面的顶点环路以确保其为外向定向。然后计算最终的、正确定向的单位法向量 $\\mathbf{n}_f$。\n4.  **单纯形分解与积分**：将每个（现已正确定向的）面分解为一组扇形三角形。对于每个三角形：\n    a.  使用三点积分法则计算通量贡献，并将其累加到总通量中。\n    b.  与多面体形心 $\\mathbf{r}$ 构成一个四面体。使用形心法则计算电荷贡献，并将其累加到总电荷中。\n5.  **最终计算**：处理完所有面后，计算累计总通量与累计总电荷之间的绝对差值。\n\n由于两种积分法则对于各自的多项式被积函数（三角形上的二次多项式，四面体上的线性多项式）都是精确的，因此计算出的通量和电荷应在浮点精度范围内相等。所以，最终的差值预计将是一个接近机器精度的小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants for the electric displacement field components\n_A, _B, _C, _D = 0.7, -1.3, 0.25, -0.5\n_E, _F, _G, _H = -0.4, 1.1, 0.35, 0.2\n_I, _J, _K, _L = 0.6, -0.9, -0.45, 0.1\n\ndef D_field(p: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the electric displacement vector D at a point p.\n    The field D is quadratic in coordinates.\n    p: A numpy array [x, y, z].\n    \"\"\"\n    x, y, z = p[0], p[1], p[2]\n    Dx = _A * x**2 + _B * y * z + _C * x + _D\n    Dy = _E * y**2 + _F * z * x + _G * y + _H\n    Dz = _I * z**2 + _J * x * y + _K * z + _L\n    return np.array([Dx, Dy, Dz])\n\ndef rho_density(p: np.ndarray) -> float:\n    \"\"\"\n    Computes the free charge density rho = div(D) at a point p.\n    The density rho is linear in coordinates.\n    p: A numpy array [x, y, z].\n    \"\"\"\n    x, y, z = p[0], p[1], p[2]\n    # rho = 2*A*x + 2*E*y + 2*I*z + C + G + K\n    return 2 * _A * x + 2 * _E * y + 2 * _I * z + _C + _G + _K\n\ndef compute_divergence_theorem_error(vertices: list, faces: list) -> float:\n    \"\"\"\n    Computes the absolute difference between the flux integral (surface) and\n    the charge integral (volume) for a given polyhedral control volume.\n\n    Args:\n        vertices: A list of [x, y, z] coordinate tuples/lists for the polyhedron.\n        faces: A list of lists, where each inner list contains the vertex indices\n               defining a face loop.\n\n    Returns:\n        The absolute difference |flux - charge| in coulombs.\n    \"\"\"\n    vertices = np.array(vertices, dtype=float)\n    poly_centroid = np.mean(vertices, axis=0)\n    \n    total_flux = 0.0\n    total_charge = 0.0\n\n    # Quadrature points for triangles (barycentric) and their equal weights\n    bary_coords = np.array([[2/3, 1/6, 1/6], [1/6, 2/3, 1/6], [1/6, 1/6, 2/3]])\n    quad_weight = 1/3\n\n    # Reference point for tetrahedral decomposition of the volume\n    r_center = poly_centroid\n\n    for face_indices in faces:\n        # 1. Ensure face has an outward-pointing normal\n        v_indices = list(face_indices)\n        v0, v1, v2 = vertices[v_indices[0]], vertices[v_indices[1]], vertices[v_indices[2]]\n        \n        provisional_normal = np.cross(v1 - v0, v2 - v0)\n        vec_to_face = v0 - poly_centroid\n\n        if np.dot(provisional_normal, vec_to_face)  0:\n            v_indices.reverse() # Flip loop if normal points inward\n\n        face_verts = vertices[v_indices]\n        \n        # 2. Compute the constant unit normal for the planar face\n        v0, v1, v2 = face_verts[0], face_verts[1], face_verts[2]\n        face_normal_vec = np.cross(v1 - v0, v2 - v0)\n        norm_of_normal = np.linalg.norm(face_normal_vec)\n        if norm_of_normal  1e-12: # Avoid division by zero for degenerate faces\n            continue\n        face_unit_normal = face_normal_vec / norm_of_normal\n\n        # 3. Decompose the polygonal face into a fan of triangles (v0 is the hub)\n        for i in range(1, len(face_verts) - 1):\n            a, b, c = face_verts[0], face_verts[i], face_verts[i+1]\n\n            # --- Surface Integral (Flux) Calculation for the triangle (a,b,c) ---\n            # The 3-point rule is exact for the quadratic integrand D.n\n            tri_area = 0.5 * np.linalg.norm(np.cross(b - a, c - a))\n            \n            # Map barycentric quadrature coordinates to physical space\n            quad_points_physical = bary_coords @ np.array([a, b, c])\n            \n            flux_contribution = 0.0\n            for p_q in quad_points_physical:\n                D_at_p = D_field(p_q)\n                integrand_val = np.dot(D_at_p, face_unit_normal)\n                flux_contribution += quad_weight * integrand_val\n            \n            total_flux += flux_contribution * tri_area\n            \n            # --- Volume Integral (Charge) Calculation for tetrahedron (r,a,b,c) ---\n            # The centroid rule is exact for the linear integrand rho\n            tet_volume = np.abs(np.dot(a - r_center, np.cross(b - r_center, c - r_center))) / 6.0\n            \n            tet_centroid = (r_center + a + b + c) / 4.0\n            rho_at_centroid = rho_density(tet_centroid)\n            total_charge += rho_at_centroid * tet_volume\n\n    return np.abs(total_flux - total_charge)\n\n\ndef solve():\n    \"\"\"\n    Defines the test cases, computes the results, and prints them\n    in the specified format.\n    \"\"\"\n    test_cases_data = []\n\n    # Test Case 1: Skewed tetrahedron\n    verts1 = [(0,0,0), (3.0,0.1,0.0), (0.2,2.5,0.05), (0.1,0.05,0.8)]\n    faces1 = [[0,1,2], [0,3,1], [1,3,2], [2,3,0]]\n    test_cases_data.append({'vertices': verts1, 'faces': faces1})\n\n    # Test Case 2: Highly skewed, near-degenerate tetrahedron\n    verts2 = [(0,0,0), (10.0,0.01,0.02), (0.02,9.0,0.03), (0.01,0.02,0.001)]\n    faces2 = [[0,1,2], [0,3,1], [1,3,2], [2,3,0]]\n    test_cases_data.append({'vertices': verts2, 'faces': faces2})\n\n    # Test Case 3: Affinely skewed hexahedron\n    unit_cube_verts = [\n        (0,0,0), (1,0,0), (1,1,0), (0,1,0),\n        (0,0,1), (1,0,1), (1,1,1), (0,1,1)\n    ]\n    def affine_map(v):\n        x, y, z = v\n        xp = x + 0.8 * y + 0.6 * z\n        yp = 1.2 * y + 0.1 * z\n        zp = 0.2 * y + 0.9 * z\n        return (xp, yp, zp)\n    verts3 = [affine_map(v) for v in unit_cube_verts]\n    faces3 = [\n        [0,1,2,3], [4,5,6,7], [0,3,7,4], [1,5,6,2], [0,1,5,4], [3,2,6,7]\n    ]\n    test_cases_data.append({'vertices': verts3, 'faces': faces3})\n\n    # Test Case 4: Sheared pentagonal prism\n    base_verts = [\n        (0.0,0.0,0.0), (2.0,0.2,0.0), (2.5,1.5,0.0), \n        (1.2,2.6,0.0), (-0.1,1.3,0.0)\n    ]\n    def shear_lift_map(v):\n        x, y, z = v\n        return (x + 1.5, y - 0.4, 0.3)\n    top_verts = [shear_lift_map(v) for v in base_verts]\n    verts4 = base_verts + top_verts\n    faces4 = [\n        [0,1,2,3,4], [5,6,7,8,9], \n        [0,1,6,5], [1,2,7,6], [2,3,8,7], [3,4,9,8], [4,0,5,9]\n    ]\n    test_cases_data.append({'vertices': verts4, 'faces': faces4})\n\n    results = []\n    for case in test_cases_data:\n        diff = compute_divergence_theorem_error(case['vertices'], case['faces'])\n        results.append(diff)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在电磁学中，高斯磁定律 ($\\nabla \\cdot \\mathbf{B} = 0$) 是一个绝对的约束，它表明磁单极子不存在。然而，在计算世界中，离散化误差可能会无意中破坏这一基本物理定律，从而产生虚假的“数值磁单极子”。本实践  将指导您量化这种离散误差，并比较不同离散格式（并置网格与交错网格）在保持磁场无散性方面的表现，揭示结构保持算法的重要性。",
            "id": "3310372",
            "problem": "考虑准静态形式下的麦克斯韦方程组，并重点关注磁高斯定律，该定律指出磁通量密度满足 $\\nabla \\cdot \\mathbf{B} = 0$。在数值计算中，离散化误差会产生非零的有效磁单极子密度 $\\rho_m = \\nabla \\cdot \\mathbf{B}$。您的任务是量化由离散化引起的 $\\rho_m$，并研究在三维周期性域上，对于不同的离散化方法，它随网格细化和近似阶数（此处解释为多项式次数）的标度变化关系。\n\n您必须实现一个程序来执行以下任务，从麦克斯韦方程组、矢量微积分恒等式以及均匀网格上离散导数的定义这些基本概念出发：\n\n- 在一个立方周期性域 $\\Omega = [0,2\\pi]^3$ 上进行计算，其中所有坐标角度都必须以弧度处理。\n- 通过给定一个连续可微的矢量势 $\\mathbf{A}(\\mathbf{x})$，并解析地计算 $\\mathbf{B} = \\nabla \\times \\mathbf{A}$，来定义一个光滑、无散的磁场 $\\mathbf{B}(\\mathbf{x})$。使用以下特定选择\n$$\n\\mathbf{A}(\\mathbf{x}) = \\begin{bmatrix}\n\\sin(y+z)\\\\\n\\sin(z+x)\\\\\n\\sin(x+y)\n\\end{bmatrix}, \\qquad \\mathbf{x} = (x,y,z),\n$$\n因此\n$$\n\\mathbf{B}(\\mathbf{x}) = \\nabla \\times \\mathbf{A}(\\mathbf{x}) = \\begin{bmatrix}\n\\cos(x+y) - \\cos(x+z)\\\\\n\\cos(y+z) - \\cos(x+y)\\\\\n\\cos(x+z) - \\cos(y+z)\n\\end{bmatrix},\n$$\n所以 $\\nabla \\cdot \\mathbf{B}(\\mathbf{x}) = 0$ 精确成立。\n\n- 实现两种离散化方法来近似 $\\rho_m$：\n    1. 在具有周期性边界条件的均匀 $N\\times N\\times N$ 网格上，采用并置节点的有限差分格式。通过对沿各轴使用阶数 $q \\in \\{2,4\\}$ 的周期性中心差分模板计算的方向导数求和，来近似散度 $\\nabla \\cdot \\mathbf{B}$。将模板阶数 $q$ 解释为离散近似的多项式次数。您必须在节点网格上计算 $\\rho_m$，其值为采样后的 $\\mathbf{B}$ 分量的三个方向导数之和。\n    2. 在相同的周期性网格上，采用交错的 Yee 型离散化，将 $\\mathbf{A}$ 的分量置于网格棱上，通过使用周期性前向差分的离散旋度在面上计算 $\\mathbf{B}$，然后通过对面通量差分求和来在单元中心计算离散散度。该格式应满足离散的“旋度之散度”恒等式，因此产生的 $\\rho_m$ 在机器精度范围内应为零。\n\n- 对于每个计算出的 $\\rho_m$ 场，通过其在网格上的均方根 (RMS) 值来量化误差，\n$$\n\\mathrm{RMS}(\\rho_m) = \\left( \\frac{1}{N^3} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\sum_{k=0}^{N-1} \\rho_m(i,j,k)^2 \\right)^{1/2}.\n$$\n将此 RMS 值视为一个无量纲的浮点数。\n\n- 通过评估一个覆盖多个 $N$ 和 $q$ 值的测试套件，研究其随网格细化和多项式次数的标度变化关系：\n    - 并置节点有限差分，q=2: $N \\in \\{16, 32, 64\\}$。\n    - 并置节点有限差分，q=4: $N \\in \\{16, 32, 64\\}$。\n    - 交错 Yee 型离散旋度-散度: $N \\in \\{16, 32, 64\\}$。\n\n- 您的程序必须按所列顺序计算上述九种情况的 $\\rho_m$ 的 RMS 值。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[\\text{result}_1,\\text{result}_2,\\ldots,\\text{result}_9]$）。每个元素必须是浮点数。所有角度量必须以弧度为单位，RMS 值必须是无量纲的浮点数。不允许用户输入；所有参数均按规定固定。\n\n所有数学处理必须一致且切合实际。离散化必须在 $\\Omega$ 上使用周期性边界条件和均匀间距 $h_x = h_y = h_z = 2\\pi/N$。确保数值实现是自洽的，并遵循上述描述。目标是经验性地检验 $\\mathrm{RMS}(\\rho_m)$ 如何随网格细化和离散化阶数而变化，并将其与交错 Yee 型格式的保散度特性进行对比。",
            "solution": "问题陈述是有效的。它在科学上基于麦克斯韦方程组和计算电磁学，定义了所有必要的参数和方法，问题阐述清晰，并且客观陈述。\n\n该问题要求对一个给定的解析磁场 $\\mathbf{B}$，定量比较由两种不同离散化格式产生的数值磁单极子密度 $\\rho_m = \\nabla \\cdot \\mathbf{B}$。该解析场由矢量势 $\\mathbf{A}$ 导出，确保其无散，即 $\\nabla \\cdot \\mathbf{B} = 0$。\n\n矢量势由下式给出\n$$\n\\mathbf{A}(\\mathbf{x}) = \\begin{bmatrix}\n\\sin(y+z)\\\\\n\\sin(z+x)\\\\\n\\sin(x+y)\n\\end{bmatrix}, \\quad \\text{其中 } \\mathbf{x} = (x,y,z)\n$$\n相应的磁场通过解析计算 $\\mathbf{B} = \\nabla \\times \\mathbf{A}$ 得出：\n$$\n\\mathbf{B}(\\mathbf{x}) = \\begin{bmatrix}\n\\frac{\\partial A_z}{\\partial y} - \\frac{\\partial A_y}{\\partial z} \\\\\n\\frac{\\partial A_x}{\\partial z} - \\frac{\\partial A_z}{\\partial x} \\\\\n\\frac{\\partial A_y}{\\partial x} - \\frac{\\partial A_x}{\\partial y}\n\\end{bmatrix} = \\begin{bmatrix}\n\\cos(x+y) - \\cos(x+z)\\\\\n\\cos(y+z) - \\cos(x+y)\\\\\n\\cos(x+z) - \\cos(y+z)\n\\end{bmatrix}\n$$\n矢量微积分恒等式 $\\nabla \\cdot (\\nabla \\times \\mathbf{A}) = 0$ 保证了这个解析场是精确无散的。然而，在网格上离散化时，这个性质不一定能保持。数值散度 $\\tilde{\\nabla} \\cdot \\tilde{\\mathbf{B}}$（我们记为 $\\rho_m$）可能因截断误差而为非零。我们将使用在周期性域 $[0, 2\\pi]^3$ 上的 $N \\times N \\times N$ 网格上的均方根 (RMS) 值来量化此误差。网格间距为 $h = 2\\pi/N$。\n\nRMS 误差定义为：\n$$\n\\mathrm{RMS}(\\rho_m) = \\left( \\frac{1}{N^3} \\sum_{i,j,k=0}^{N-1} |\\rho_m(i,j,k)|^2 \\right)^{1/2}\n$$\n\n我们将实现并比较两种离散化格式。\n\n1. 并置节点有限差分格式。\n在这种方法中，矢量场 $\\mathbf{B}$ 的所有分量（$B_x, B_y, B_z$）都在相同的网格点（节点）$(x_i, y_j, z_k) = (ih, jh, kh)$ 上求值。散度 $\\rho_m = \\nabla \\cdot \\mathbf{B}$ 通过对每个节点上的数值偏导数求和来近似：\n$$\n\\rho_m(i,j,k) = \\left. \\frac{\\partial B_x}{\\partial x} \\right|_{(i,j,k)} + \\left. \\frac{\\partial B_y}{\\partial y} \\right|_{(i,j,k)} + \\left. \\frac{\\partial B_z}{\\partial z} \\right|_{(i,j,k)}\n$$\n偏导数使用阶数为 $q$ 的周期性中心差分模板计算。\n对于阶数 $q=2$，模板为：\n$$\n\\frac{\\partial f}{\\partial x}\\bigg|_i \\approx \\frac{f_{i+1} - f_{i-1}}{2h}\n$$\n对于阶数 $q=4$，模板为：\n$$\n\\frac{\\partial f}{\\partial x}\\bigg|_i \\approx \\frac{-f_{i+2} + 8f_{i+1} - 8f_{i-1} + f_{i-2}}{12h}\n$$\n周期性通过环绕网格的索引来处理（例如，$f_{N} = f_0$，$f_{-1} = f_{N-1}$）。该格式的截断误差预计与 $h^q$ 成正比，因此我们预期 $\\mathrm{RMS}(\\rho_m)$ 会随着 $N$ 的增加和 $q$ 的增加而减小。\n\n2. 交错 Yee 型格式。\n这种格式是时域有限差分 (FDTD) 方法的基础，它将不同的场分量放置在网格单元内的不同位置。这种交错排列旨在在离散层面上保持某些矢量微积分恒等式。\n根据问题描述，我们首先在网格棱上对矢量势 $\\mathbf{A}$ 进行采样，使用离散旋度在面上计算 $\\mathbf{B}$，然后使用离散散度在单元中心计算 $\\rho_m$。一个具体的实现如下：\n- 在周期性网格上定义离散差分算子。对于网格函数 $F_{i,j,k}$，令 $D_x$、$D_y$、$D_z$ 为后向差分算子，例如，$D_x F_{i,j,k} = (F_{i,j,k} - F_{i-1,j,k})/h$。\n- 在适当的交错网格上对 $\\mathbf{A}$ 的分量进行采样。我们可以通过存储数组 `Ax`、`Ay`、`Az` 来表示，其中每个数组对应于不同物理位置的值。\n- 计算 $\\mathbf{A}$ 的离散旋度以获得 $\\mathbf{B}$ 的分量。我们将离散旋度算子 $\\tilde{\\nabla} \\times$ 定义为：\n$$\n\\tilde{\\mathbf{B}} = \\tilde{\\nabla} \\times \\mathbf{A} = \\begin{bmatrix}\nD_y A_z - D_z A_y \\\\\nD_z A_x - D_x A_z \\\\\nD_x A_y - D_y A_x\n\\end{bmatrix}\n$$\n- 计算 $\\tilde{\\mathbf{B}}$ 的离散散度以求得 $\\rho_m$。离散散度算子 $\\tilde{\\nabla} \\cdot$ 为：\n$$\n\\rho_m = \\tilde{\\nabla} \\cdot \\tilde{\\mathbf{B}} = D_x \\tilde{B}_x + D_y \\tilde{B}_y + D_z \\tilde{B}_z\n$$\n- 将 $\\tilde{\\mathbf{B}}$ 的表达式代入散度方程，得到：\n$$\n\\rho_m = D_x(D_y A_z - D_z A_y) + D_y(D_z A_x - D_x A_z) + D_z(D_x A_y - D_y A_x)\n$$\n- 由于离散差分算子是可交换的（例如，$D_x D_y = D_y D_x$），各项成对抵消：\n$$\n\\rho_m = (D_x D_y A_z - D_y D_x A_z) + (D_y D_z A_x - D_z D_y A_x) + (D_z D_x A_y - D_x D_z A_y) = 0\n$$\n这证明了离散恒等式 $\\tilde{\\nabla} \\cdot (\\tilde{\\nabla} \\times \\mathbf{A}) \\equiv 0$ 成立。因此，计算出的 $\\rho_m$ 应该在机器浮点精度范围内为零，而与网格分辨率 $N$ 无关。\n\n程序将实现这两种格式，为九个指定的测试用例计算 $\\rho_m$ 的 RMS 值，并报告结果。我们预计并置格式的误差会随着 $N$ 和 $q$ 的增加而减小，而 Yee 格式的误差应保持在机器零附近。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_collocated(N, q):\n    \"\"\"\n    Calculates RMS of numerical divergence using a collocated finite-difference scheme.\n\n    Args:\n        N (int): Number of grid points along each dimension.\n        q (int): Order of the central difference stencil (2 or 4).\n\n    Returns:\n        float: The RMS value of the numerical magnetic monopole density.\n    \"\"\"\n    h = 2.0 * np.pi / N\n    coords = np.arange(N) * h\n    \n    # Create a nodal grid (all components at the same points)\n    # Use 'ij' indexing for intuitive axis mapping: axis 0 -> z, axis 1 -> y, axis 2 -> x\n    z_coords, y_coords, x_coords = np.meshgrid(coords, coords, coords, indexing='ij')\n\n    # Sample the analytical B field on the nodal grid\n    B_x = np.cos(x_coords + y_coords) - np.cos(x_coords + z_coords)\n    B_y = np.cos(y_coords + z_coords) - np.cos(x_coords + y_coords)\n    B_z = np.cos(x_coords + z_coords) - np.cos(y_coords + z_coords)\n\n    def central_diff(F, h_val, order, axis):\n        if order == 2:\n            # 2nd-order central difference\n            return (np.roll(F, -1, axis=axis) - np.roll(F, 1, axis=axis)) / (2 * h_val)\n        elif order == 4:\n            # 4th-order central difference\n            return (-np.roll(F, -2, axis=axis) + 8 * np.roll(F, -1, axis=axis) -\n                    8 * np.roll(F, 1, axis=axis) + np.roll(F, 2, axis=axis)) / (12 * h_val)\n        else:\n            raise ValueError(\"Unsupported order q. Must be 2 or 4.\")\n\n    # Compute numerical derivatives\n    # Axis 2 corresponds to x, 1 to y, 0 to z\n    dBx_dx = central_diff(B_x, h, q, axis=2)\n    dBy_dy = central_diff(B_y, h, q, axis=1)\n    dBz_dz = central_diff(B_z, h, q, axis=0)\n\n    # Calculate numerical magnetic monopole density\n    rho_m = dBx_dx + dBy_dy + dBz_dz\n\n    # Calculate RMS error\n    rms_error = np.sqrt(np.mean(rho_m**2))\n    return rms_error\n\ndef calculate_yee(N):\n    \"\"\"\n    Calculates RMS of numerical divergence using a staggered Yee-type scheme.\n\n    Returns:\n        float: The RMS value of the numerical magnetic monopole density.\n    \"\"\"\n    h = 2.0 * np.pi / N\n    \n    # Primal grid nodes (p) and dual grid nodes (d)\n    # The staggered grid points are midpoints between primal nodes.\n    p_coords = np.arange(N) * h\n    d_coords = (np.arange(N) + 0.5) * h\n    \n    # Grid indexing: axis 0 -> z, axis 1 -> y, axis 2 -> x\n\n    # Sample A components on edge-centered grids\n    # Ax is on (p, d, d) grid: (x_i, y_{j+1/2}, z_{k+1/2})\n    Z_d, Y_d, X_p = np.meshgrid(d_coords, d_coords, p_coords, indexing='ij')\n    A_x = np.sin(Y_d + Z_d)\n    \n    # Ay is on (d, p, d) grid: (x_{i+1/2}, y_j, z_{k+1/2})\n    Z_d, Y_p, X_d = np.meshgrid(d_coords, p_coords, d_coords, indexing='ij')\n    A_y = np.sin(Z_d + X_d)\n    \n    # Az is on (d, d, p) grid: (x_{i+1/2}, y_{j+1/2}, z_k)\n    Z_p, Y_d, X_d = np.meshgrid(p_coords, d_coords, d_coords, indexing='ij')\n    A_z = np.sin(X_d + Y_d)\n\n    # Define backward difference operators using np.roll\n    # Dx(F_i) = (F_i - F_{i-1}) / h\n    def D_x(F): return (F - np.roll(F, 1, axis=2)) / h\n    def D_y(F): return (F - np.roll(F, 1, axis=1)) / h\n    def D_z(F): return (F - np.roll(F, 1, axis=0)) / h\n\n    # Discrete curl: B = curl(A)\n    # This maps edge-centered A to face-centered B\n    B_x = D_y(A_z) - D_z(A_y)\n    B_y = D_z(A_x) - D_x(A_z)\n    B_z = D_x(A_y) - D_y(A_x)\n    \n    # Discrete divergence: rho_m = div(B)\n    # This maps face-centered B to cell-centered rho_m\n    rho_m = D_x(B_x) + D_y(B_y) + D_z(B_z)\n\n    # Calculate RMS error. This should be close to machine precision.\n    rms_error = np.sqrt(np.mean(rho_m**2))\n    return rms_error\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    N_vals = [16, 32, 64]\n    results = []\n\n    # Case 1: Collocated, q=2\n    for N in N_vals:\n        results.append(calculate_collocated(N, q=2))\n\n    # Case 2: Collocated, q=4\n    for N in N_vals:\n        results.append(calculate_collocated(N, q=4))\n\n    # Case 3: Staggered Yee-type\n    for N in N_vals:\n        results.append(calculate_yee(N))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从静态场到动态场，高斯定律的约束力延伸到了电荷守恒定律。在时域有限差分（FDTD）等动态仿真中，未能精确满足离散的电荷守恒方程会导致高斯电场定律的系统性违背，并随时间累积，最终破坏仿真的物理真实性。本实践  将通过理论推导和数值实验，研究非守恒电流源如何导致高斯定律残差的增长，并验证其误差与时间步长和网格尺寸的标度关系。",
            "id": "3310387",
            "problem": "考虑一个二维横向电场 ($\\mathrm{TE}_z$) 时域有限差分 (FDTD) 格式，该格式建立在具有方形单元的均匀 Yee 网格上，单元边长为 $\\Delta x = \\Delta y$。电场分量 $E_x$ 和 $E_y$ 交错分布在单元边缘，磁场分量 $H_z$ 交错分布在单元中心。设离散场存储在索引 $i \\in \\{0,1,\\ldots,N_x-1\\}$ 和 $j \\in \\{0,1,\\ldots,N_y-1\\}$ 上，并在两个方向上都采用周期性边界条件。假设真空介电常数为 $\\varepsilon_0$，真空磁导率为 $\\mu_0$，并定义光速 $c = 1/\\sqrt{\\varepsilon_0 \\mu_0}$。\n\n将时间步 $n$ 的离散更新方程（显式蛙跳时间步进）定义如下，其中所有离散数学算子均为标准 Yee 网格差分算子，所有量（包括索引和常数）均用 $\\LaTeX$ 表示：\n\n- 安培-麦克斯韦方程对电场分量的更新（从时间 $t^{n-1/2}$ 到 $t^{n+1/2}$）：\n$$\nE_x^{n+1/2}(i,j) = E_x^{n-1/2}(i,j) + \\frac{\\Delta t}{\\varepsilon_0} \\left( \\frac{H_z^n(i,j) - H_z^n(i,j-1)}{\\Delta y} - J_x^n(i,j) \\right),\n$$\n$$\nE_y^{n+1/2}(i,j) = E_y^{n-1/2}(i,j) + \\frac{\\Delta t}{\\varepsilon_0} \\left( - \\frac{H_z^n(i,j) - H_z^n(i-1,j)}{\\Delta x} - J_y^n(i,j) \\right),\n$$\n索引 $i-1$ 和 $j-1$ 采用周期性回绕。\n\n- 法拉第定律对磁场的更新（从时间 $t^{n}$ 到 $t^{n+1}$）：\n$$\nH_z^{n+1}(i,j) = H_z^n(i,j) + \\frac{\\Delta t}{\\mu_0} \\left( \\frac{E_y^{n+1/2}(i+1,j) - E_y^{n+1/2}(i,j)}{\\Delta x} - \\frac{E_x^{n+1/2}(i,j+1) - E_x^{n+1/2}(i,j)}{\\Delta y} \\right),\n$$\n索引 $i+1$ 和 $j+1$ 采用周期性回绕。\n\n定义作用于交错电场上的离散散度算子，以在单元中心计算高斯定律：\n$$\n(\\nabla_d \\cdot \\mathbf{E})^n(i,j) = \\frac{E_x^n(i,j) - E_x^n(i-1,j)}{\\Delta x} + \\frac{E_y^n(i,j) - E_y^n(i,j-1)}{\\Delta y}.\n$$\n设电荷密度恒等于零，即对于所有 $n$、$i$ 和 $j$，$\\rho^n(i,j) = 0$。则在时间 $t^n$ 的离散高斯定律残差为\n$$\ng^n(i,j) = (\\nabla_d \\cdot \\mathbf{E})^n(i,j) - \\frac{\\rho^n(i,j)}{\\varepsilon_0} = (\\nabla_d \\cdot \\mathbf{E})^n(i,j).\n$$\n\n假设电流沉积是非电荷守恒的：离散连续性方程\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot \\mathbf{J} = 0\n$$\n未以其离散形式强制执行。具体而言，设电流仅施加于单个 $E_x$ 边上，作为幅值为 $J_0$（单位 $\\mathrm{A/m^2}$）的不随时间变化的源，并且没有对 $\\rho$ 进行相应的更新。形式上，对于选定的索引 $(i_0,j_0)$，\n$$\nJ_x^n(i,j) = \\begin{cases}\nJ_0,  \\text{if } i=i_0, j=j_0, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n\\quad\nJ_y^n(i,j) = 0,\n$$\n对所有时间步 $n$ 成立。这种电流沉积方式违反了离散连续性方程，产生了非零的 $\\mathbf{J}$ 的离散散度。\n\n从麦克斯韦方程组和 Yee 网格恒等式出发，推导离散高斯定律残差 $g^n(i,j)$ 的时间演化，并在以下测量方案下，以率或指数的形式得出其对时间步长 $\\Delta t$ 和网格尺寸 $\\Delta x$ 的依赖关系：\n\n1. 固定步数方案：保持时间步数 $N$ 不变，改变时间步长 $\\Delta t$，网格尺寸 $\\Delta x$ 固定。\n2. 固定物理时间方案：保持物理时间 $T=N \\Delta t$ 不变，改变时间步长 $\\Delta t$，网格尺寸 $\\Delta x$ 固定。\n3. 空间细化方案：保持物理时间 $T$ 不变，改变网格尺寸 $\\Delta x$，同时固定 $\\Delta t$ 使其足够小以满足所有考虑的网格的稳定性。\n4. 恒定 Courant–Friedrichs–Lewy (CFL) 方案：保持 CFL 数不变，即对于固定的 $\\sigma \\in (0,1)$ 选择 $\\Delta t = \\sigma \\Delta x / (c \\sqrt{2})$，并保持步数 $N$ 不变，同时改变 $\\Delta x$。\n\n预测缩放指数 $p$ 和 $q$，使得在每个方案中，最终时间的最大范数残差\n$$\nG = \\max_{i,j} |g^n(i,j)|,\n$$\n的行为符合 $G \\propto (\\Delta t)^p (\\Delta x)^q$，其中 $p$ 和 $q$ 根据上述指定的方案而变化。\n\n然后，实现所述的 FDTD 格式，并通过计算下面测试套件中成对参数集的两点对数-对数斜率来数值验证预测的率，从而得到测量的指数。使用以下常数和单位：\n- $\\varepsilon_0 = 8.854187817 \\times 10^{-12} \\, \\mathrm{F/m}$，$\\mu_0 = 4\\pi \\times 10^{-7} \\, \\mathrm{H/m}$，$c = 1/\\sqrt{\\varepsilon_0 \\mu_0}$。\n- $\\Delta x$ 的单位为 $\\mathrm{m}$，$\\Delta t$ 的单位为 $\\mathrm{s}$，$J_0$ 的单位为 $\\mathrm{A/m^2}$。\n- 以 $\\mathrm{C/m^3}$ 为单位报告最大范数残差 $G$，但最终输出必须是十进制浮点数形式的无量纲指数。\n\n测试套件参数集如下：\n\n- 测试案例 1（固定步数）：$N_x = N_y = 64$，$\\Delta x = 1.0 \\times 10^{-3} \\, \\mathrm{m}$，$J_0 = 10 \\, \\mathrm{A/m^2}$，$N = 200$。使用两个时间步长 $\\Delta t_1 = 0.2 \\, \\Delta x / (c \\sqrt{2})$ 和 $\\Delta t_2 = 0.1 \\, \\Delta x / (c \\sqrt{2})$。计算 $G_1$ 和 $G_2$，以及测量指数 $p_{N\\text{ fixed}} = \\frac{\\log(G_2/G_1)}{\\log(\\Delta t_2/\\Delta t_1)}$。\n\n- 测试案例 2（固定物理时间）：$N_x$、$N_y$、$\\Delta x$ 和 $J_0$ 相同。使用与上面相同的 $\\Delta t_1$ 和 $\\Delta t_2$，但选择 $N_1 = 200$ 和 $N_2 = 400$，使得 $T_1 = N_1 \\Delta t_1 = T_2 = N_2 \\Delta t_2$。计算 $G_1$ 和 $G_2$，以及测量指数 $p_{T\\text{ fixed}} = \\frac{\\log(G_2/G_1)}{\\log(\\Delta t_2/\\Delta t_1)}$。\n\n- 测试案例 3（固定物理时间下的空间细化）：两个网格，分别为 $(N_x,N_y,\\Delta x_1) = (64,64, 1.0 \\times 10^{-3}\\, \\mathrm{m})$ 和 $(N_x,N_y,\\Delta x_2) = (128,128, 0.5 \\times 10^{-3}\\, \\mathrm{m})$。选择一个单一时间步长 $\\Delta t = 0.05 \\, \\Delta x_2/(c \\sqrt{2})$，它对两个网格都满足稳定性条件，并且两个网格都使用 $N=400$ 步，因此物理时间 $T=N\\Delta t$ 是固定的。对每个网格，在相应的中心边上施加 $J_0 = 10 \\, \\mathrm{A/m^2}$，计算 $G_1$ 和 $G_2$，以及测量指数 $q_{T\\text{ fixed}} = \\frac{\\log(G_2/G_1)}{\\log(\\Delta x_2/\\Delta x_1)}$。\n\n- 测试案例 4（恒定 CFL 和固定步数）：两个网格，分别为 $(N_x,N_y,\\Delta x_1) = (64,64, 1.0 \\times 10^{-3}\\, \\mathrm{m})$ 和 $(N_x,N_y,\\Delta x_2) = (128,128, 0.5 \\times 10^{-3}\\, \\mathrm{m})$。选择 $\\sigma = 0.1$ 并对 $k \\in \\{1,2\\}$ 设置 $\\Delta t_k = \\sigma \\Delta x_k/(c \\sqrt{2})$。两个网格都使用 $N=200$ 步。对每个网格，在相应的中心边上施加 $J_0 = 10 \\, \\mathrm{A/m^2}$，计算 $G_1$ 和 $G_2$，以及测量指数 $q_{\\mathrm{CFL}, N\\text{ fixed}} = \\frac{\\log(G_2/G_1)}{\\log(\\Delta x_2/\\Delta x_1)}$。\n\n您的程序应实现上述内容，并生成单行输出，其中包含四个测量指数，格式为用方括号括起来的逗号分隔列表（例如，$[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$）。输出必须是十进制浮点数。不涉及角度，因此不需要角度单位。通过遵守 Courant–Friedrichs–Lewy (CFL) 条件来确保数值稳定性。最终答案必须是代码，并且程序必须是完整的，无需任何用户输入即可运行。",
            "solution": "用户希望在电流源不满足离散连续性方程的情况下，分析二维 TEz 时域有限差分 (FDTD) 模拟中高斯定律残差的行为。\n\n### 问题验证\n\n根据指定标准对问题进行审查。\n\n- **给定条件**：问题提供了二维 TEz 网格的全套 FDTD 更新方程、离散散度算子的定义、高斯定律残差 $g^n(i,j)$ 的定义、一个特定的非电荷守恒电流源 $J_x(i,j) = J_0 \\delta_{i,i_0}\\delta_{j,j_0}$，以及用于数值实验的四个明确方案，并附有所有必要的参数（$N_x, N_y, \\Delta x, \\Delta t, N, J_0$）。物理常数 $\\varepsilon_0$ 和 $\\mu_0$ 已给出。\n- **科学依据**：该问题基于标准的 Yee FDTD 算法，这是计算电磁学中一个成熟的方法。核心问题——分析由非电荷守恒源引起的高斯定律违背——是该领域一个基础且实际的课题，被称为“散度清理”或“电荷守恒”分析。问题的前提和方程在科学上和数学上都是合理的。\n- **适定性**：问题是明确且自洽的。给定源和边界条件的 FDTD 格式具有唯一的稳定解（前提是满足 CFL 条件，测试案例参数已隐式处理了这一点）。所提问题是精确的，并有确定的、可推导的答案。\n- **客观性**：问题以精确、客观的数学和物理语言陈述，没有主观论断。\n\n**结论**：问题是**有效的**。这是一个计算电磁学领域内公式严谨的问题，既需要理论推导也需要数值验证。\n\n### 缩放指数的理论推导\n\n主要目标是推导离散高斯定律残差 $g^n(i,j)$ 的时间演化。给定时间的残差定义为电场的离散散度。在蛙跳格式中，电场定义在半整数时间步（$t^{n-1/2}, t^{n+1/2}, \\ldots$）。我们将时间 $t^{n+1/2}$ 的残差定义为 $g^{n+1/2}(i,j) = (\\nabla_d \\cdot \\mathbf{E})^{n+1/2}(i,j)$。这是避免对电场进行时间平均的最直接方法。通过对安培定律取离散散度，可以找到该量的演化规律。\n\n让我们用 $\\nabla_d \\cdot$ 表示离散散度算子，用 $\\nabla_d \\times$ 表示 FDTD 更新中使用的离散旋度算子。电场的安培-麦克斯韦更新方程为：\n$$\n\\frac{\\mathbf{E}^{n+1/2} - \\mathbf{E}^{n-1/2}}{\\Delta t} = \\frac{1}{\\varepsilon_0} (\\nabla_d \\times \\mathbf{H}^n - \\mathbf{J}^n)\n$$\n对此方程取离散散度，得到：\n$$\n\\nabla_d \\cdot \\left( \\frac{\\mathbf{E}^{n+1/2} - \\mathbf{E}^{n-1/2}}{\\Delta t} \\right) = \\frac{1}{\\varepsilon_0} \\nabla_d \\cdot (\\nabla_d \\times \\mathbf{H}^n - \\mathbf{J}^n)\n$$\n由于散度算子和时间差分算子可交换，左侧变为：\n$$\n\\frac{(\\nabla_d \\cdot \\mathbf{E})^{n+1/2} - (\\nabla_d \\cdot \\mathbf{E})^{n-1/2}}{\\Delta t} = \\frac{g^{n+1/2} - g^{n-1/2}}{\\Delta t}\n$$\n右侧变为：\n$$\n\\frac{1}{\\varepsilon_0} (\\nabla_d \\cdot (\\nabla_d \\times \\mathbf{H}^n) - \\nabla_d \\cdot \\mathbf{J}^n)\n$$\nYee FDTD 格式的一个关键特性是，其离散算子的构造满足矢量恒等式 $\\nabla \\cdot (\\nabla \\times \\mathbf{A}) = 0$ 的离散形式，即 $\\nabla_d \\cdot (\\nabla_d \\times \\mathbf{A}) = 0$。这可以通过显式写出嵌套的有限差分算子来证实，它们会完全抵消。\n因此，残差的演化方程简化为：\n$$\n\\frac{g^{n+1/2} - g^{n-1/2}}{\\Delta t} = - \\frac{1}{\\varepsilon_0} (\\nabla_d \\cdot \\mathbf{J}^n)\n$$\n这可以写成一个递推关系：\n$$\ng^{n+1/2}(i,j) = g^{n-1/2}(i,j) - \\frac{\\Delta t}{\\varepsilon_0} (\\nabla_d \\cdot \\mathbf{J}^n)(i,j)\n$$\n假设模拟从零场开始，则初始残差 $g^{-1/2}(i,j) = 0$。给定的电流源不随时间变化，因此 $(\\nabla_d \\cdot \\mathbf{J}^n)$ 与时间步索引 $n$ 无关。我们将其表示为 $(\\nabla_d \\cdot \\mathbf{J})$。将递推关系展开 $N$ 个时间步，在最终时间 $t^{N-1/2}$ 的残差为：\n$$\ng^{N-1/2}(i,j) = \\sum_{n=0}^{N-1} (g^{n+1/2} - g^{n-1/2}) = -\\sum_{n=0}^{N-1} \\frac{\\Delta t}{\\varepsilon_0} (\\nabla_d \\cdot \\mathbf{J})(i,j) = - \\frac{N \\Delta t}{\\varepsilon_0} (\\nabla_d \\cdot \\mathbf{J})(i,j)\n$$\n接下来，我们计算指定电流源的离散散度。该源在单个位置 $(i_0, j_0)$ 处为 $J_x(i,j) = J_0$，在其他位置为零，且 $J_y=0$。\n$$\n(\\nabla_d \\cdot \\mathbf{J})(i,j) = \\frac{J_x(i,j) - J_x(i-1,j)}{\\Delta x} + \\frac{J_y(i,j) - J_y(i,j-1)}{\\Delta y}\n$$\n这仅在两个位置非零：\n- 在 $(i,j)=(i_0, j_0)$ 处： $(\\nabla_d \\cdot \\mathbf{J}) = \\frac{J_0 - 0}{\\Delta x} = \\frac{J_0}{\\Delta x}$\n- 在 $(i,j)=(i_0+1, j_0)$ 处： $(\\nabla_d \\cdot \\mathbf{J}) = \\frac{0 - J_0}{\\Delta x} = -\\frac{J_0}{\\Delta x}$\n电流散度的最大绝对值为 $\\max_{i,j}|(\\nabla_d \\cdot \\mathbf{J})(i,j)| = \\frac{J_0}{\\Delta x}$。\n\n我们关心的量是最终时间的最大范数残差，$G = \\max_{i,j} |g^{N-1/2}(i,j)|$。\n$$\nG = \\max_{i,j} \\left| - \\frac{N \\Delta t}{\\varepsilon_0} (\\nabla_d \\cdot \\mathbf{J})(i,j) \\right| = \\frac{N \\Delta t}{\\varepsilon_0} \\max_{i,j} |(\\nabla_d \\cdot \\mathbf{J})(i,j)| = \\frac{N \\Delta t J_0}{\\varepsilon_0 \\Delta x}\n$$\n这个单一表达式 $G \\propto N \\Delta t (\\Delta x)^{-1}$ 让我们能够为每个方案预测缩放指数 $p$ 和 $q$（在 $G \\propto (\\Delta t)^p (\\Delta x)^q$ 中）。\n\n1.  **固定步数方案**：$N$ 和 $\\Delta x$ 固定。$G \\propto \\Delta t$。因此，指数为 $p = 1$。\n2.  **固定物理时间方案**：总物理时间 $T=N \\Delta t$ 固定，$\\Delta x$ 固定。将 $N=T/\\Delta t$ 代入 $G$ 的表达式，我们得到 $G = \\frac{(T/\\Delta t) \\Delta t J_0}{\\varepsilon_0 \\Delta x} = \\frac{T J_0}{\\varepsilon_0 \\Delta x}$。这与 $\\Delta t$ 无关。因此，指数为 $p = 0$。\n3.  **空间细化方案**：物理时间 $T=N \\Delta t$ 固定。我们改变网格尺寸 $\\Delta x$。$G = \\frac{T J_0}{\\varepsilon_0 \\Delta x} \\propto (\\Delta x)^{-1}$。因此，指数为 $q = -1$。\n4.  **恒定 CFL 方案**：CFL 数 $\\sigma$ 固定，因此 $\\Delta t = \\frac{\\sigma \\Delta x}{c \\sqrt{2}} \\propto \\Delta x$。步数 $N$ 固定。我们改变 $\\Delta x$。将 $\\Delta t$ 代入 $G$ 的表达式：$G = \\frac{N (\\sigma \\Delta x / (c\\sqrt{2})) J_0}{\\varepsilon_0 \\Delta x} = \\frac{N \\sigma J_0}{\\varepsilon_0 c \\sqrt{2}}$。此表达式与 $\\Delta x$ 无关。因此，指数为 $q = 0$。\n\n预测的指数为：$p_{N\\text{ fixed}} = 1$，$p_{T\\text{ fixed}} = 0$，$q_{T\\text{ fixed}} = -1$，以及 $q_{\\mathrm{CFL}, N\\text{ fixed}} = 0$。\n以下 Python 代码实现了 FDTD 模拟，以数值方式验证这些预测。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and compute scaling exponents.\n    \"\"\"\n    # Define physical constants as provided\n    EPS0 = 8.854187817e-12  # F/m\n    MU0 = 4 * np.pi * 1e-7  # H/m\n    C0 = 1 / np.sqrt(EPS0 * MU0) # Speed of light in vacuum (m/s)\n\n    def run_simulation(Nx, Ny, dx, dt, N_steps, J0):\n        \"\"\"\n        Performs a 2D TEz FDTD simulation based on the problem statement.\n        \n        Args:\n            Nx (int): Number of grid cells in x.\n            Ny (int): Number of grid cells in y.\n            dx (float): Grid spacing in x (and y).\n            dt (float): Time step size.\n            N_steps (int): Total number of time steps.\n            J0 (float): Amplitude of the current source.\n\n        Returns:\n            float: The maximum-norm of the Gauss's law residual at the final time.\n        \"\"\"\n        dy = dx  # Square cells\n\n        # Initialize field arrays\n        Ex = np.zeros((Nx, Ny))\n        Ey = np.zeros((Nx, Ny))\n        Hz = np.zeros((Nx, Ny))\n\n        # Setup the current source Jx at the grid center\n        i0, j0 = Nx // 2, Ny // 2\n        Jx = np.zeros((Nx, Ny))\n        Jx[i0, j0] = J0\n        Jy = np.zeros((Nx, Ny))  # Jy is zero everywhere\n\n        # FDTD update coefficients\n        c_e = dt / EPS0\n        c_h = dt / MU0\n\n        # Main FDTD time-stepping loop\n        for _ in range(N_steps):\n            # Update Electric fields E (from t^n-1/2 to t^n+1/2)\n            # using H at t^n\n            dHz_dy = (Hz - np.roll(Hz, 1, axis=1)) / dy\n            dHz_dx = (Hz - np.roll(Hz, 1, axis=0)) / dx\n            \n            Ex += c_e * (dHz_dy - Jx)\n            Ey += c_e * (-dHz_dx - Jy)\n\n            # Update Magnetic field H (from t^n to t^n+1)\n            # using E at t^n+1/2\n            dEy_dx = (np.roll(Ey, -1, axis=0) - Ey) / dx\n            dEx_dy = (np.roll(Ex, -1, axis=1) - Ex) / dy\n            \n            Hz += c_h * (dEy_dx - dEx_dy)\n\n        # After the loop, Ex and Ey are at the final time t^(N-1/2).\n        # Calculate the discrete divergence residual g^N = div(E^(N-1/2)).\n        # g = (Ex(i,j) - Ex(i-1,j))/dx + (Ey(i,j) - Ey(i,j-1))/dy\n        dEx_dx = (Ex - np.roll(Ex, 1, axis=0)) / dx\n        dEy_dy = (Ey - np.roll(Ey, 1, axis=1)) / dy\n        g = dEx_dx + dEy_dy\n\n        # The residual G is the maximum-norm of g.\n        G = np.max(np.abs(g))\n        \n        return G\n\n    # List to store the four computed exponents\n    results = []\n    \n    # --- Test Case 1: Fixed number of steps ---\n    Nx, Ny = 64, 64\n    dx = 1.0e-3\n    J0 = 10.0\n    N = 200\n    dt_base = dx / (C0 * np.sqrt(2))\n    \n    dt1_case1 = 0.2 * dt_base\n    dt2_case1 = 0.1 * dt_base\n    \n    G1 = run_simulation(Nx, Ny, dx, dt1_case1, N, J0)\n    G2 = run_simulation(Nx, Ny, dx, dt2_case1, N, J0)\n    \n    p_N_fixed = np.log(G2 / G1) / np.log(dt2_case1 / dt1_case1)\n    results.append(p_N_fixed)\n\n    # --- Test Case 2: Fixed physical time ---\n    N1_case2 = 200\n    dt1_case2 = 0.2 * dt_base\n    N2_case2 = 400\n    dt2_case2 = 0.1 * dt_base\n    # Verification: T1 = N1*dt1, T2 = N2*dt2. N2/N1 = 2, dt1/dt2 = 2. So T1=T2.\n    \n    G1 = run_simulation(Nx, Ny, dx, dt1_case2, N1_case2, J0)\n    G2 = run_simulation(Nx, Ny, dx, dt2_case2, N2_case2, J0)\n    \n    p_T_fixed = np.log(G2 / G1) / np.log(dt2_case2 / dt1_case2)\n    results.append(p_T_fixed)\n\n    # --- Test Case 3: Spatial refinement at fixed physical time ---\n    N_case3 = 400\n    # Mesh 1\n    Nx1, Ny1, dx1 = 64, 64, 1.0e-3\n    # Mesh 2\n    Nx2, Ny2, dx2 = 128, 128, 0.5e-3\n    dt_case3 = 0.05 * dx2 / (C0 * np.sqrt(2))\n\n    G1 = run_simulation(Nx1, Ny1, dx1, dt_case3, N_case3, J0)\n    G2 = run_simulation(Nx2, Ny2, dx2, dt_case3, N_case3, J0)\n\n    q_T_fixed = np.log(G2 / G1) / np.log(dx2 / dx1)\n    results.append(q_T_fixed)\n\n    # --- Test Case 4: Constant CFL and fixed number of steps ---\n    N_case4 = 200\n    sigma = 0.1\n    cfl_factor = sigma / (C0 * np.sqrt(2))\n\n    # Mesh 1\n    Nx1, Ny1, dx1 = 64, 64, 1.0e-3\n    dt1 = dx1 * cfl_factor\n    # Mesh 2\n    Nx2, Ny2, dx2 = 128, 128, 0.5e-3\n    dt2 = dx2 * cfl_factor\n    \n    G1 = run_simulation(Nx1, Ny1, dx1, dt1, N_case4, J0)\n    G2 = run_simulation(Nx2, Ny2, dx2, dt2, N_case4, J0)\n\n    q_CFL_N_fixed = np.log(G2 / G1) / np.log(dx2 / dx1)\n    results.append(q_CFL_N_fixed)\n\n    # Print the final list of exponents in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}