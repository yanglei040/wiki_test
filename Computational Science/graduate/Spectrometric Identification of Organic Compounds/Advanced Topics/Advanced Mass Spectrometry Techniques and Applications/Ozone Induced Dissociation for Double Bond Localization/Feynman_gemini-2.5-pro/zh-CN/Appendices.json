{
    "hands_on_practices": [
        {
            "introduction": "掌握任何质谱技术的第一步都是理解其产生的离子的质量。这项练习将引导您从基本原理出发，推导臭氧诱导解离（OzID）产生的标志性醛和克里奇（Criegee）中间体碎片的精确质量表达式。通过这项实践，您将巩固对 OzID 反应化学计量及其在质谱图上表现形式的理解。",
            "id": "3717469",
            "problem": "一个源自不饱和有机分子的阳离子经历臭氧诱导解离 (OzID)，其形式可表示为 $R_{1}\\text{-}CH=CH\\text{-}R_{2}^{+} \\xrightarrow{O_{3}} R_{1}\\text{-}CHO + R_{2}\\text{-}CHOO^{+}$。将 $R_{1}$ 和 $R_{2}$ 视为取代基部分，其中不包括两个 $\\text{sp}^{2}$ 双键碳原子及其氢原子；也就是说，在 $R_{1}$ 和 $R_{2}$ 中计数的原子不包括直接参与 $C=C$ 功能基团的 $CH$ 单元。假设元素组成仅限于碳、氢、氧，以及（如果作为加合物阳离子存在）钠。\n\n根据质谱学中的定义，单同位素精确质量是构成原子的单同位素原子质量之和，并且 $C=C$ 键的臭氧分解会裂解该键，产生一个醛（$R_{1}\\text{-}CHO$）和一个Criegee型离子（$R_{2}\\text{-}CHOO^{+}$）。请基于此推导出这两个产物碎片的元素组成（用 $R_{1}$ 和 $R_{2}$ 的原子数表示），然后以符号形式表示它们的精确单同位素质量。设 $n_{\\text{C}}(R_{i})$、$n_{\\text{H}}(R_{i})$ 和 $n_{\\text{O}}(R_{i})$ 分别表示 $R_{i}$（$i \\in \\{1,2\\}$）中碳、氢、氧原子的数量。设 $\\sigma \\in \\{0,1\\}$ 为Criegee碎片上钠加合的指示符（如果一个钠原子加合到 $R_{2}\\text{-}CHOO^{+}$ 上，则 $\\sigma=1$，否则 $\\sigma=0$）。使用以下单同位素质量：$m(\\text{C})=12.000000$，$m(\\text{H})=1.007825$，$m(\\text{O})=15.994915$ 和 $m(\\text{Na})=22.989770$。\n\n请以统一原子质量单位 (u) 表示两种碎片的质量，并以一对闭式解析表达式的形式给出最终结果。无需进行数值舍入。",
            "solution": "该问题要求推导不饱和有机阳离子经臭氧诱导解离（OzID）后产生的两种产物碎片的单同位素精确质量的解析表达式。该过程由反应 $R_{1}\\text{-}CH=CH\\text{-}R_{2}^{+} \\xrightarrow{O_{3}} R_{1}\\text{-}CHO + R_{2}\\text{-}CHOO^{+}$ 定义。一个化学物种的质量是其构成原子的单同位素质量之和。电子的质量被认为可以忽略不计，因此离子的质量与其相应的中性自由基的质量相等。\n\n首先，我们确定醛碎片 $R_{1}\\text{-}CHO$ 的元素组成。\n问题陈述 $R_{1}$ 是一个取代基部分，其元素组成由碳原子数 $n_{\\text{C}}(R_{1})$、氢原子数 $n_{\\text{H}}(R_{1})$ 和氧原子数 $n_{\\text{O}}(R_{1})$ 定义。从前体形成醛碎片 $R_{1}\\text{-}CHO$ 的过程涉及到 $R_{1}$ 部分和原始乙烯基之一的 $CH$ 基团，后者与臭氧分子中的一个氧原子结合。因此，该碎片中每种元素的总原子数是 $R_{1}$ 中的原子与 $-CHO$ 基团中的原子之和。\n$-CHO$ 基团提供一个碳原子、一个氢原子和一个氧原子。\n因此，碎片 $R_{1}\\text{-}CHO$ 的元素组成为：\n碳原子数：$n_{\\text{C, frag1}} = n_{\\text{C}}(R_{1}) + 1$\n氢原子数：$n_{\\text{H, frag1}} = n_{\\text{H}}(R_{1}) + 1$\n氧原子数：$n_{\\text{O, frag1}} = n_{\\text{O}}(R_{1}) + 1$\n\n醛碎片的单同位素质量，记为 $m(R_{1}\\text{-}CHO)$，是其构成原子的质量之和。使用所提供的符号质量 $m(\\text{C})$、$m(\\text{H})$ 和 $m(\\text{O})$：\n$m(R_{1}\\text{-}CHO) = (n_{\\text{C}}(R_{1}) + 1) m(\\text{C}) + (n_{\\text{H}}(R_{1}) + 1) m(\\text{H}) + (n_{\\text{O}}(R_{1}) + 1) m(\\text{O})$\n代入给定的单同位素质量数值：\n$m(\\text{C}) = 12.000000$ u\n$m(\\text{H}) = 1.007825$ u\n$m(\\text{O}) = 15.994915$ u\n第一个碎片的质量表达式为：\n$m(R_{1}\\text{-}CHO) = (n_{\\text{C}}(R_{1}) + 1) \\cdot 12.000000 + (n_{\\text{H}}(R_{1}) + 1) \\cdot 1.007825 + (n_{\\text{O}}(R_{1}) + 1) \\cdot 15.994915$\n\n接下来，我们确定Criegee型离子碎片 $R_{2}\\text{-}CHOO^{+}$ 的元素组成。\n该碎片由 $R_{2}$ 部分、另一个乙烯基 $CH$ 基团以及来自臭氧分子的剩余两个氧原子组成。其元素组成由 $R_{2}$ 部分的原子数 $n_{\\text{C}}(R_{2})$、$n_{\\text{H}}(R_{2})$ 和 $n_{\\text{O}}(R_{2})$ 加上来自 $-CHOO$ 基团的原子定义。\n$-CHOO$ 基团提供一个碳原子、一个氢原子和两个氧原子。\n此外，问题指出该碎片可能与一个钠原子发生加合，由变量 $\\sigma \\in \\{0,1\\}$ 表示，其中 $\\sigma=1$ 表示存在一个钠原子，$\\sigma=0$ 表示不存在。\n因此，碎片 $R_{2}\\text-CHOO^{+}$（可能已钠化）的元素组成为：\n碳原子数：$n_{\\text{C, frag2}} = n_{\\text{C}}(R_{2}) + 1$\n氢原子数：$n_{\\text{H, frag2}} = n_{\\text{H}}(R_{2}) + 1$\n氧原子数：$n_{\\text{O, frag2}} = n_{\\text{O}}(R_{2}) + 2$\n钠原子数：$n_{\\text{Na, frag2}} = \\sigma$\n\n这个Criegee型离子的单同位素质量，记为 $m(R_{2}\\text{-}CHOO^{+})$，是其构成原子的质量之和，如果存在鈉，则包括鈉的质量。使用符号质量 $m(\\text{C})$、$m(\\text{H})$、$m(\\text{O})$ 和 $m(\\text{Na})$：\n$m(R_{2}\\text{-}CHOO^{+}) = (n_{\\text{C}}(R_{2}) + 1) m(\\text{C}) + (n_{\\text{H}}(R_{2}) + 1) m(\\text{H}) + (n_{\\text{O}}(R_{2}) + 2) m(\\text{O}) + \\sigma \\cdot m(\\text{Na})$\n代入给定的单同位素质量数值，包括 $m(\\text{Na}) = 22.989770$ u：\n第二个碎片的质量表达式为：\n$m(R_{2}\\text{-}CHOO^{+}) = (n_{\\text{C}}(R_{2}) + 1) \\cdot 12.000000 + (n_{\\text{H}}(R_{2}) + 1) \\cdot 1.007825 + (n_{\\text{O}}(R_{2}) + 2) \\cdot 15.994915 + \\sigma \\cdot 22.989770$\n\n这两个推导出的表达式代表了两种产物碎片的精确单同位素质量的闭式解析公式。",
            "answer": "$$\\boxed{\\begin{pmatrix} (n_{\\text{C}}(R_{1}) + 1) \\cdot 12.000000 + (n_{\\text{H}}(R_{1}) + 1) \\cdot 1.007825 + (n_{\\text{O}}(R_{1}) + 1) \\cdot 15.994915 \\\\ (n_{\\text{C}}(R_{2}) + 1) \\cdot 12.000000 + (n_{\\text{H}}(R_{2}) + 1) \\cdot 1.007825 + (n_{\\text{O}}(R_{2}) + 2) \\cdot 15.994915 + \\sigma \\cdot 22.989770 \\end{pmatrix}}$$"
        },
        {
            "introduction": "将理论应用于实践的最终体现是实现分析过程的自动化。本练习要求您设计并实现一个算法，该算法能系统地评估长链分子中所有可能的双键位置，并根据实验质谱数据进行评分，最终确定最可能的结构。这项综合性练习将理论知识与计算思维相结合，模拟了现代分析化学中解决问题的真实流程。",
            "id": "3717389",
            "problem": "你的任务是设计并实现一个计算程序。该程序基于单质子化的单不饱和烃链的臭氧诱导解离，为每个候选双键位置枚举所有可能的诊断产物离子对，并根据一组观测到的质荷比值对这些位置的合理性进行排序。该程序应使用一个定义明确的评分函数，为每个测试用例选择最合理的双键位置。\n\n使用的基本依据是以下一组被广泛接受并经过充分检验的定义和事实：\n- 在高分辨率质谱法中，质荷比的计算方法是单同位素中性质量加上电荷载体质量，再除以电荷数。对于单质子化离子，这实际上就是中性质量加上一个质子的质量。\n- 烯烃的臭氧诱导解离会切断双键，产生对双键定位具有诊断意义的互补碎片。对于在两个碳原子之间有一个双键的单不饱和烃链，裂解的每一侧都可以产生一个醛碎片和一个羰基氧化物碎片（称为Criegee中间体）。对于一侧相同碳原子数的这两种离子，它们形成一个诊断对，质量相差一个氧原子。\n- 包含 $s$ 个碳原子的线性饱和烃链片段的化学计量式为 $C_s H_{2s+2}$，相应的饱和醛为 $C_s H_{2s} O$。对于源自 $s$ 个碳原子的烷基链片段的羰基氧化物（Criegee），其中性化学计量式为 $C_s H_{2s} O_2$。对于单质子化离子，需将质子质量加到中性质量上。\n- 使用以下单同位素质量（单位：道尔顿）：碳 $m_C = 12.000000$，氢 $m_H = 1.007825$，氧 $m_O = 15.994915$，质子 $m_{H^+} = 1.007276$。\n- 来自裂解一侧的预期诊断对的质量差为一个氧原子的质量，即约 $m_O$。\n\n模型和计算要求：\n1. 考虑一个具有 $N$ 个碳原子的线性单不饱和烃链。候选双键位置用整数 $p \\in \\{1,2,\\dots,N-1\\}$ 索引，表示在第 $p$ 个和第 $(p+1)$ 个碳原子之间发生裂解。对于每个 $p$，定义两个侧链长度 $s_1 = p$ 和 $s_2 = N-p$。\n2. 对于一个侧链长度 $s$，计算该侧链产生的单质子化醛和Criegee产物离子的预期质荷比值（单位：道尔顿/基本电荷）。醛离子对应中性分子式 $C_s H_{2s} O$，Criegee离子对应 $C_s H_{2s} O_2$。作为单质子化离子，它们的 $m/z$ 值分别是各自的中性质量加上 $m_{H^+}$。\n3. 对于给定的 $p$，预期的诊断离子集是来自 $s_1$ 和 $s_2$ 的两对离子的并集。如果 $s_1 = s_2$，则只使用唯一的质量值以避免重复计数。\n4. 评分和排序：给定观测到的峰 $\\{y_i\\}$ 和一个非负质量容差 $\\tau$（单位：道尔顿），为每个预期的 $m/z$ 值 $x$ 定义最小绝对偏差 $\\delta = \\min_i |y_i - x|$。如果 $\\delta \\le \\tau$，则该预期离子对分数的贡献为 $w = \\max(0, 1 - \\delta/\\tau)$，否则 $w = 0$。位置 $p$ 的分数是该位置所有预期离子的 $w$ 值的平均值（即贡献总和除以预期离子数）。按分数降序对所有 $p$ 进行排序，若分数相同，则选择最小的 $p$。如果最高分等于 $0$，则返回 $-1$，表示在容差范围内观测数据不支持任何合理的位置。\n5. 单位：所有 $m/z$ 值和容差的单位均为道尔顿。不涉及角度。不使用百分比。\n6. 实现：你的程序必须实现此模型和评分方法，为每个测试用例选择最合理的双键位置，结果为一个整数（如果无法确定则为 $-1$）。\n\n测试套件：\n使用以下测试用例，每个用例由 $(N, \\tau, \\text{观测到的峰})$ 指定，其中观测到的峰是 $m/z$ 值（单位：道尔顿）的列表：\n- 案例 1 (中心双键，对称离子对):\n  - $N = 18$\n  - $\\tau = 0.01$\n  - 观测到的峰: $\\left[143.146541,\\;159.133956,\\;100.000000,\\;200.500000\\right]$\n- 案例 2 (不对称情况，一对离子信号强烈):\n  - $N = 20$\n  - $\\tau = 0.01$\n  - 观测到的峰: $\\left[213.227291,\\;229.214206,\\;150.000000\\right]$\n- 案例 3 (接近末端位置的边界情况):\n  - $N = 16$\n  - $\\tau = 0.02$\n  - 观测到的峰: $\\left[31.022841,\\;47.020756,\\;80.000000,\\;200.000000\\right]$\n- 案例 4 (没有观测到峰的边缘情况):\n  - $N = 22$\n  - $\\tau = 0.01$\n  - 观测到的峰: $\\left[\\;\\right]$ (空列表)\n\n最终输出规范：\n你的程序应生成单行输出，其中包含所有四个测试用例选出的最合理位置，形式为方括号括起来的逗号分隔列表，顺序与上述测试用例一致。例如，如果选定的位置是 $p_1$, $p_2$, $p_3$ 和 $p_4$，程序必须精确打印 $\\left[\\text{p}_1,\\text{p}_2,\\text{p}_3,\\text{p}_4\\right]$。",
            "solution": "该问题要求开发一种计算方法，以识别单不饱和线性烃链中双键的位置。这是通过模拟臭氧诱导解离（OzID）产生的碎片的质谱分析，并根据一组观测到的质荷比（$m/z$）值对潜在的双键位置进行评分来实现的。解决方案必须基于所提供的化学原理，并遵循特定的计算模型。\n\n逻辑步骤如下：\n1.  **系统地生成假设**：对于一个具有 $N$ 个碳原子的线性烃链，双键可以存在于碳 $p$ 和碳 $p+1$ 之间，其中位置 $p$ 的范围可以从 $1$ 到 $N-1$。每个 $p$ 的整数值代表一个关于双键位置的独立假设。\n\n2.  **预测可观测信号**：根据臭氧诱导解离的原理，位于位置 $p$ 的双键将分子裂解成两个碎片。包含碳 $1$ 到 $p$ 的碎片长度为 $s_1 = p$，互补碎片的长度为 $s_2 = N-p$。对于每个长度为 $s$ 的碎片，预计会形成两种诊断产物离子：一个单质子化醛和一个单质子化Criegee中间体（羰基氧化物）。\n    中性醛碎片的单同位素质量，其化学计量式为 $C_s H_{2s} O$，计算如下：\n    $$M_{ald}(s) = s \\cdot m_C + 2s \\cdot m_H + 1 \\cdot m_O$$\n    中性Criegee碎片的单同位素质量，其化学计量式为 $C_s H_{2s} O_2$，计算如下：\n    $$M_{cri}(s) = s \\cdot m_C + 2s \\cdot m_H + 2 \\cdot m_O$$\n    其中 $m_C = 12.000000$ Da, $m_H = 1.007825$ Da, 和 $m_O = 15.994915$ Da 分别是碳、氢和氧的单同位素质量。\n    由于问题指定的是单质子化离子（$z=1$），它们的质荷比是通过将质子质量 $m_{H^+} = 1.007276$ Da 加到中性质量上计算得出的：\n    $$ m/z_{ald}(s) = M_{ald}(s) + m_{H^+} $$\n    $$ m/z_{cri}(s) = M_{cri}(s) + m_{H^+} $$\n    对于给定的双键位置 $p$，预期的诊断 $m/z$ 值集合 $E_p$ 是来自两个碎片的离子对的并集：\n    $$ E_p = \\{m/z_{ald}(s_1), m/z_{cri}(s_1)\\} \\cup \\{m/z_{ald}(s_2), m/z_{cri}(s_2)\\} $$\n    如果裂解是对称的（$s_1 = s_2$），这个集合包含两个唯一的 $m/z$ 值；否则，它包含四个。\n\n3.  **假设的量化评估**：通过将每个假设 $p$ 的预期 $m/z$ 值集合 $E_p$ 与实验观测到的 $m/z$ 值列表 $\\{y_i\\}$ 进行比较来评估该假设。定义一个评分函数来量化“拟合优度”。对于每个预期的 $m/z$ 值 $x \\in E_p$，我们找到它与观测峰的最小绝对偏差：\n    $$ \\delta(x) = \\min_{i} |y_i - x| $$\n    根据此偏差相对于给定质量容差 $\\tau$ 的大小，分配一个权重 $w(x)$。该权重使用线性评分函数计算：\n    $$ w(x) = \\begin{cases} 1 - \\frac{\\delta(x)}{\\tau}  \\text{if } \\delta(x) \\le \\tau \\\\ 0  \\text{if } \\delta(x) > \\tau \\end{cases} $$\n    此函数为完美匹配（$\\delta=0$）分配权重 1，随着偏差接近容差 $\\tau$，权重线性减小至 0。任何在容差窗口内没有观测到对应峰的预期峰，其权重为 0。\n    假设 $p$ 的总分 $S(p)$ 是其集合 $E_p$ 中所有预期离子的权重的算术平均值：\n    $$ S(p) = \\frac{1}{|E_p|} \\sum_{x \\in E_p} w(x) $$\n\n4.  **选择最合理的假设**：在计算完所有可能位置 $p \\in \\{1, \\dots, N-1\\}$ 的分数 $S(p)$ 后，按分数降序对这些位置进行排序。分数上的任何平局都通过选择较小的 $p$ 值来解决。排名最高的位置被选为最合理的双键位置。规定了一个特殊条件：如果在所有位置中获得的最高分是 $0$，则意味着在给定的容差内，实验数据不支持任何假设。在这种情况下，返回 $-1$ 以表示不存在合理的解决方案。\n\n5.  **算法实现**：该逻辑被实现为一个 Python 程序。函数 `calculate_fragment_mz(s)` 计算大小为 $s$ 的碎片的两个预期 $m/z$ 值。第二个函数 `solve_case` 遍历所有可能的位置 $p$，计算预期离子集 $E_p$，并使用定义的评分规则与观测到的峰进行比较来计算分数 $S(p)$。这个主函数会跟踪迄今为止找到的最佳分数和相应的位置，并遵守平局打破规则。最后，它检查最佳分数是否为零，以在必要时返回 $-1$。该程序处理提供的每个测试用例，并将最终结果格式化为单个逗号分隔的列表。利用 Numpy 进行高效的数值计算，特别是用于找到最小偏差 $\\delta$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results according to the problem specification.\n    \"\"\"\n    \n    # Define the monoisotopic masses and proton mass as global constants.\n    M_C = 12.000000  # Daltons\n    M_H = 1.007825  # Daltons\n    M_O = 15.994915  # Daltons\n    M_H_PLUS = 1.007276  # Daltons\n\n    def calculate_fragment_mz(s: int):\n        \"\"\"\n        Calculates the m/z values for the singly protonated aldehyde and \n        Criegee intermediate for a fragment of size s.\n\n        Args:\n            s (int): The number of carbon atoms in the fragment.\n\n        Returns:\n            tuple[float, float]: A tuple containing the m/z of the aldehyde and Criegee ions.\n        \"\"\"\n        # Calculate neutral mass for C_s H_{2s} O (aldehyde)\n        neutral_mass_aldehyde = s * M_C + 2 * s * M_H + M_O\n        # Calculate neutral mass for C_s H_{2s} O_2 (Criegee)\n        neutral_mass_criegee = s * M_C + 2 * s * M_H + 2 * M_O\n        \n        # Add proton mass for singly protonated ions\n        mz_aldehyde = neutral_mass_aldehyde + M_H_PLUS\n        mz_criegee = neutral_mass_criegee + M_H_PLUS\n        \n        return mz_aldehyde, mz_criegee\n\n    def solve_case(N: int, tau: float, observed_peaks: list[float]):\n        \"\"\"\n        Solves for the most plausible double bond position for a single test case.\n\n        Args:\n            N (int): Total number of carbon atoms in the chain.\n            tau (float): Non-negative mass tolerance in Daltons.\n            observed_peaks (list[float]): A list of observed m/z values.\n\n        Returns:\n            int: The most plausible double bond position p, or -1 if no plausible position is found.\n        \"\"\"\n        best_p = -1\n        best_score = -1.0 # Initialize with a value lower than any possible score\n\n        # Convert observed_peaks to a numpy array for efficient computation.\n        # If the list is empty, handle it to avoid errors.\n        if observed_peaks:\n            observed_peaks_np = np.array(observed_peaks)\n        else:\n            observed_peaks_np = np.array([])\n            \n        # Iterate through all possible double bond positions p\n        for p in range(1, N):\n            s1 = p\n            s2 = N - p\n            \n            # Generate the set of expected m/z values to handle symmetric cases automatically.\n            mz_ald1, mz_cri1 = calculate_fragment_mz(s1)\n            mz_ald2, mz_cri2 = calculate_fragment_mz(s2)\n            expected_mzs = sorted(list(set([mz_ald1, mz_cri1, mz_ald2, mz_cri2])))\n            \n            total_weight = 0.0\n            \n            # If no peaks are observed, score is 0.\n            if observed_peaks_np.size > 0:\n                for x in expected_mzs:\n                    # Calculate the minimal absolute deviation delta\n                    delta = np.min(np.abs(observed_peaks_np - x))\n                    \n                    # Calculate weight if deviation is within tolerance\n                    if delta = tau:\n                        weight = 1.0 - delta / tau\n                        total_weight += weight\n            \n            # The score for position p is the average of the weights.\n            current_score = total_weight / len(expected_mzs)\n\n            # Update best score and position.\n            # The tie-breaking rule (smallest p) is handled by iterating p\n            # in ascending order and only updating on strictly greater scores.\n            if current_score > best_score:\n                best_score = current_score\n                best_p = p\n\n        # If the highest score is 0, return -1.\n        # Use np.isclose for robust floating point comparison.\n        if np.isclose(best_score, 0.0):\n            return -1\n        else:\n            return best_p\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (18, 0.01, [143.146541, 159.133956, 100.000000, 200.500000]),\n        (20, 0.01, [213.227291, 229.214206, 150.000000]),\n        (16, 0.02, [31.022841, 47.020756, 80.000000, 200.000000]),\n        (22, 0.01, [])\n    ]\n\n    results = []\n    for N, tau, observed_peaks in test_cases:\n        result = solve_case(N, tau, observed_peaks)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}