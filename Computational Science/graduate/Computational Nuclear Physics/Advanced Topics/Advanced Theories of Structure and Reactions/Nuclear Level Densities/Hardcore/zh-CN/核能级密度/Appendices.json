{
    "hands_on_practices": [
        {
            "introduction": "理解核能级密度最基本的方法是直接对量子态进行计数。本练习将指导你基于独立粒子模型，通过实现一个组合方法来完成这项任务 ()。你将从给定的质子和中子单粒子能谱出发，通过计算粒子-空穴激发组态，逐步构建出总的能级密度，从而深刻理解微观的单粒子结构如何决定宏观的统计性质——能级密度。",
            "id": "3575162",
            "problem": "给定质子和中子的有限独立单粒子谱，由它们各自相对于费米能的能量距离和能级简并度指定。在独立粒子模型（IPM）和费米-狄拉克统计下，微正则核能级密度定义为在固定激发能下不同多体构型的数量。形式上，激发能为 $U$ 处的核能级密度是能量比基态高 $U$ 的多体态的数量，可以写成一个微正则求和，该求和遍历了分别保持质子和中子粒子数守恒的构型。在此设定中，激发是粒子-空穴重排：对于每种粒子（质子或中子），您从费米能以下的能级中移除 $k$ 个已占据的单粒子态（产生 $k$ 个空穴），并将 $k$ 个粒子添加到费米能以上的能级中（产生 $k$ 个粒子），从而保持该种粒子的总数不变。由特定种类粒子贡献的激发能是所选粒子在费米能以上的能量之和，加上所选空穴在费米能以下的能量大小之和；总激发能是所有粒子种类的贡献之和。\n\n令 $s \\in \\{p,n\\}$ 表示粒子种类（质子 $p$ 或中子 $n$）。对于每种粒子，令 $\\{\\epsilon_{k}^{(s,+)}\\}$ 为费米能以上单粒子能级的正能量距离集合（单位为兆电子伏特），其简并度为 $\\{g_{k}^{(s,+)}\\}$；令 $\\{\\epsilon_{k}^{(s,-)}\\}$ 为费米能以下单粒子能级的正能量大小集合（单位为兆电子伏特），其简并度为 $\\{g_{k}^{(s,-)}\\}$。每个简并度 $g$ 代表该能级上不同量子子态的数量，并强制执行泡利不相容原理，因此在该能级上最多可以放置 $g$ 个粒子（或空穴）。\n\n定义粒子种类-能级生成多项式\n$$\nP_s(x,q) = \\prod_{k} \\left( \\sum_{m=0}^{g_{k}^{(s,+)}} \\binom{g_{k}^{(s,+)}}{m} x^{m} q^{m \\epsilon_{k}^{(s,+)}} \\right),\n\\quad\nH_s(x,q) = \\prod_{k} \\left( \\sum_{m=0}^{g_{k}^{(s,-)}} \\binom{g_{k}^{(s,-)}}{m} x^{m} q^{m \\epsilon_{k}^{(s,-)}} \\right),\n$$\n其中 $x$ 追踪所选子态的数量，$q$ 追踪能量。通过匹配 $P_s$ 和 $H_s$ 中 $x$ 的幂次来强制执行等量粒子-空穴约束以保证粒子数固定。微正则粒子种类激发分布是通过对匹配的 $k$ 进行求和并对能量贡献进行卷积得到的。对于不同种类的粒子，总激发是质子和中子种类分布的卷积。微正则核能级密度 $\\rho(U)$ 是其总激发能位于以 $U$ 为中心、宽度为 $\\Delta U$ 的能量箱内的不同多体构型的数量。也就是说，如果总能量 $E$ 满足 $|E - U| \\le \\Delta U/2$，则该状态被计数。\n\n您的任务是编写一个完整的、可运行的程序，对于提供的测试套件，通过使用递归配分函数（对能级和简并度进行动态规划）进行显式组合计数来计算 $\\rho(U)$，对每种粒子强制执行粒子-空穴相等，并对不同种类的粒子进行卷积。所有能量必须以兆电子伏特（MeV）为单位处理。对能量和使用精确算术，以便相对于区间 $[U - \\Delta U/2, U + \\Delta U/2]$（单位为 MeV）进行分箱。\n\n要求：\n1. 实现组合计数：\n   - 对于每种粒子 $s$，使用关于能级和简并度的递归以及用于从简并度为 $g$ 的能级中选择 $m$ 个子态的二项式因子 $\\binom{g}{m}$，构建作为所选子态数量 $k$ 的函数的粒子激发能分布和空穴激发能分布。\n   - 通过为每种粒子匹配粒子和空穴的数量（$k$）并对其能量贡献进行卷积，分别对质子和中子强制执行粒子数守恒。\n   - 对质子和中子的能量分布进行卷积，以获得总激发能分布。\n   - 统计总激发能位于以 $U$ 为中心、宽度为 $\\Delta U$ 的指定能量箱内的构型，即满足 $|E - U| \\le \\Delta U/2$。\n\n2. 物理单位：所有能量均以兆电子伏特（MeV）为单位。能量箱宽度 $\\Delta U$ 以 MeV 为单位。激发能 $U$ 以 MeV 为单位。\n\n3. 输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”），其中每个结果是相应测试用例的整数计数。\n\n4. 角度单位不适用于此问题。\n\n测试套件：\n计算以下四种情况的 $\\rho(U)$，每种情况的能量以 MeV 表示，简并度为整数。在每种情况下，输入包括：\n- 费米能以下的质子能级：一个 $(\\epsilon^{(p,-)}, g^{(p,-)})$ 对的列表，其中 $\\epsilon^{(p,-)} > 0$，单位为 MeV。\n- 费米能以上的质子能级：一个 $(\\epsilon^{(p,+)}, g^{(p,+)})$ 对的列表，其中 $\\epsilon^{(p,+)} > 0$，单位为 MeV。\n- 费米能以下的中子能级：一个 $(\\epsilon^{(n,-)}, g^{(n,-)})$ 对的列表，其中 $\\epsilon^{(n,-)} > 0$，单位为 MeV。\n- 费米能以上的中子能级：一个 $(\\epsilon^{(n,+)}, g^{(n,+)})$ 对的列表，其中 $\\epsilon^{(n,+)} > 0$，单位为 MeV。\n- 能量箱宽度 $\\Delta U$，单位为 MeV。\n- 目标激发能 $U$，单位为 MeV。\n\n情况1（一般性混合谱）：\n- 质子（费米能以下）：(0.8, 2), (0.5, 2)。\n- 质子（费米能以上）：(0.4, 2), (0.9, 1)。\n- 中子（费米能以下）：(0.7, 2)。\n- 中子（费米能以上）：(0.6, 1), (1.1, 1)。\n- $\\Delta U = 0.1$。\n- $U = 1.0$。\n\n情况2（零激发能边界条件）：\n- 质子（费米能以下）：(0.8, 2), (0.5, 2)。\n- 质子（费米能以上）：(0.4, 2), (0.9, 1)。\n- 中子（费米能以下）：(0.7, 2)。\n- 中子（费米能以上）：(0.6, 1), (1.1, 1)。\n- $\\Delta U = 0.1$。\n- $U = 0.0$。\n\n情况3（具有舍入敏感性的单能级对称性）：\n- 质子（费米能以下）：(0.5, 3)。\n- 质子（费米能以上）：(0.5, 3)。\n- 中子（费米能以下）：（无）。\n- 中子（费米能以上）：（无）。\n- $\\Delta U = 0.2$。\n- $U = 1.0$。\n\n情况4（更高的组合复杂度）：\n- 质子（费米能以下）：(0.3, 4), (0.7, 2)。\n- 质子（费米能以上）：(0.2, 3), (0.9, 1)。\n- 中子（费米能以下）：(0.4, 3)。\n- 中子（费米能以上）：(0.1, 5), (0.8, 1)。\n- $\\Delta U = 0.05$。\n- $U = 1.0$。\n\n您的程序必须计算这四种情况的整数计数 $\\rho(U)$，并在一行上以确切要求的格式打印它们。",
            "solution": "用户提供的问题是一个在计算核物理领域中有效且适定的问题。它科学地基于独立粒子模型（IPM），并利用统计力学中的标准组合技术来计算核能级密度。问题陈述是完整的，为测试用例提供了所有必需的单粒子谱、简并度和参数。目标定义明确且计算上是可行的。\n\n该解决方案通过实现多体粒子-空穴构型的组合枚举来进行。该方法的核心是一种动态规划算法，用于计算形成给定能量的激发的方式数量，这在数学上等同于展开问题描述中提供的生成函数。\n\n### 方法原理\n\n核能级密度 $\\rho(U)$ 是在窄能量区间 $[U - \\Delta U/2, U + \\Delta U/2]$ 内不同量子态的数量。在IPM中，这些态是相对于基态构建的粒子-空穴激发。一个 $k$-粒子-$k$-空穴（$k$p-$k$h）激发涉及将 $k$ 个核子从费米能以下的已占据轨道提升到其上的未占据轨道。总激发能 $E$ 是所产生的粒子能量（相对于费米能）与所产生的空穴绝对能量之和。\n\n计算分三个主要阶段进行：\n1.  **每种粒子的激子能量分布：** 对于每种粒子 $s \\in \\{p, n\\}$（质子、中子），并分别对粒子和空穴，我们计算产生 $k$ 个激子的能量分布。令 $D_s^{(+)}(k_p, E_p)$ 为将 $k_p$ 个粒子以总粒子能量 $E_p$ 放置在费米能以上能级的方法数。类似地，令 $D_s^{(-)}(k_h, E_h)$ 为在费米能以下能级中以总空穴能量 $E_h$ 产生 $k_h$ 个空穴的方法数。\n2.  **粒子种类能量分布：** 通过要求粒子数等于空穴数（即 $k_p = k_h = k$）来强制执行每种粒子的粒子数守恒。种类 $s$ 的总激发能为 $E_s = E_p + E_h$。$E_s$ 的分布是通过对每个 $k$ 的粒子和空穴能量分布进行卷积，然后对所有可能的 $k$ 求和得到的。\n3.  **总核能分布：** 总核激发能为 $E = E_p + E_n$，其中 $E_p$ 和 $E_n$ 分别是质子和中子系统的总激发能。总能量 $E$ 的最终分布是通过对特定种类的能量分布进行卷积得到的。\n\n### 算法实现\n\n采用动态规划方法计算激子分布。为避免求和中的浮点数不精确性，所有能量都乘以一个因子 $1000$ 并作为整数处理。情况4中分箱所需的精度，即 $|E - 1.0| \\le 0.05/2$，需要三位小数，这使得 $1000$ 的缩放比例是合适的。\n\n#### 1. 计算粒子/空穴分布\n\n对于给定的能级集合（例如，质子粒子能级） $\\{(\\epsilon_i, g_i)\\}$，我们计算一个映射 $D(k, E)$，它存储了形成一个具有总标度化能量 $E$ 的 $k$-激子态的方法数。我们用基态（0个激子，0能量，1种方式）来初始化分布：$D(0, 0) = 1$。然后我们遍历每个能级 $(\\epsilon_i, g_i)$ 并更新分布。对于每个能级，我们考虑在其中放置 $m$ 个激子，其中 $1 \\le m \\le g_i$。这可以通过 $\\binom{g_i}{m}$ 种方式完成，并向能量中增加 $m \\cdot \\epsilon_i$。此步骤等效于将当前的分布多项式乘以特定于能级的多项式 $\\sum_{m=0}^{g_i} \\binom{g_i}{m} x^m q^{m\\epsilon_i}$。对所有能级重复此过程，从而得到该能级集合的最终分布。此操作分别对质子粒子、质子空穴、中子粒子和中子空穴进行。\n\n#### 2. 强制守恒与卷积\n\n对于每种粒子 $s$，构建一个新的分布 $S_s(E_s)$。对于 $k=0$ 的基态，它被初始化为 $S_s(0) = 1$。然后，对于每对粒子-空穴数 $k \\ge 1$，我们对 $k$-粒子能量分布与 $k$-空穴能量分布进行卷积。每个总种类能量 $E_s = E_p + E_h$ 的结果计数被加到 $S_s(E_s)$ 中。\n\n$$ S_s(E_s) = \\sum_{k} \\sum_{E_p+E_h=E_s} D_s^{(+)}(k, E_p) \\cdot D_s^{(-)}(k, E_h) $$\n\n接下来，总核能分布 $D_{total}(E)$ 是通过对质子和中子种类分布 $S_p$ 和 $S_n$ 进行卷积得到的：\n\n$$ D_{total}(E) = \\sum_{E_p+E_n=E} S_p(E_p) \\cdot S_n(E_n) $$\n\n所有分布都实现为将标度化能量映射到整数计数的字典，这有效地处理了能谱的稀疏性。\n\n#### 3. 最终分箱\n\n最后一步是将在 $D_{total}(E)$ 中所有状态的计数相加，这些状态的未标度化能量 $E_{MeV} = E_{scaled} / 1000$ 落在目标能量箱 $[U - \\Delta U/2, U + \\Delta U/2]$ 内。结果是整数能级密度 $\\rho(U)$。",
            "answer": "```python\nimport math\nfrom collections import defaultdict\n\ndef get_ph_distribution(levels, scale):\n    \"\"\"\n    Computes the distribution of energies for creating k particles or k holes\n    using dynamic programming. This is equivalent to expanding the generating\n    polynomial for a set of single-particle levels.\n\n    Args:\n        levels (list): A list of tuples (energy_MeV, degeneracy).\n        scale (int): The factor to scale energies into integers for exact arithmetic.\n\n    Returns:\n        A dictionary dp[k][scaled_E] = count, representing the number of ways (count)\n        to create k excitons with a total scaled energy of scaled_E.\n    \"\"\"\n    dp = defaultdict(lambda: defaultdict(int))\n    dp[0][0] = 1\n\n    for energy, g in levels:\n        scaled_energy = int(round(energy * scale))\n        \n        # We iterate over k in reverse to update dp in-place. This is a standard\n        # knapsack-style DP optimization to ensure that contributions from the\n        # current level are correctly partitioned and not re-used.\n        k_max = max(dp.keys()) if dp else 0\n        \n        for k_prev in range(k_max, -1, -1):\n            if k_prev in dp:\n                energy_map_prev = dp[k_prev]\n                for m in range(1, g + 1):\n                    comb = math.comb(g, m)\n                    energy_contrib = m * scaled_energy\n                    k_new = k_prev + m\n                    for E_prev, count_prev in energy_map_prev.items():\n                        E_new = E_prev + energy_contrib\n                        count_new = count_prev * comb\n                        dp[k_new][E_new] += count_new\n    return dp\n\ndef get_species_distribution(hole_levels, particle_levels, scale):\n    \"\"\"\n    Computes the total excitation energy distribution for a single species\n    (e.g., protons), enforcing the constraint that the number of particles\n    equals the number of holes (k_p = k_h).\n\n    Args:\n        hole_levels (list): Single-particle levels below the Fermi energy.\n        particle_levels (list): Single-particle levels above the Fermi energy.\n        scale (int): Energy scaling factor.\n\n    Returns:\n        A dictionary species_dist[scaled_E] = count for the species.\n    \"\"\"\n    h_dist = get_ph_distribution(hole_levels, scale)\n    p_dist = get_ph_distribution(particle_levels, scale)\n\n    species_dist = defaultdict(int)\n    species_dist[0] = 1 # k=0 ground state\n\n    max_k_h = max(h_dist.keys()) if h_dist else 0\n    max_k_p = max(p_dist.keys()) if p_dist else 0\n    max_k_pairs = min(max_k_h, max_k_p)\n    \n    for k in range(1, max_k_pairs + 1):\n        if k in h_dist and k in p_dist:\n            energy_map_h = h_dist[k]\n            energy_map_p = p_dist[k]\n            \n            # Convolve the energy distributions for this k\n            for E_h, count_h in energy_map_h.items():\n                for E_p, count_p in energy_map_p.items():\n                    E_total_species = E_h + E_p\n                    count_total_species = count_h * count_p\n                    species_dist[E_total_species] += count_total_species\n    \n    return species_dist\n\ndef calculate_rho(case_data):\n    \"\"\"\n    Calculates the nuclear level density rho(U) for a given test case.\n    \"\"\"\n    p_below, p_above, n_below, n_above, dU, U = case_data\n    # A scale of 1000 is chosen to handle up to 3 decimal places,\n    # necessary for the binning in Case 4.\n    scale = 1000\n\n    p_dist = get_species_distribution(p_below, p_above, scale)\n    n_dist = get_species_distribution(n_below, n_above, scale)\n\n    # Convolve proton and neutron distributions to get the total nuclear distribution\n    total_dist = defaultdict(int)\n    for E_p, count_p in p_dist.items():\n        for E_n, count_n in n_dist.items():\n            E_total = E_p + E_n\n            count = count_p * count_n\n            total_dist[E_total] += count\n\n    # Perform binning to get the final count\n    lower_bound = U - dU / 2.0\n    upper_bound = U + dU / 2.0\n    \n    total_count = 0\n    for scaled_E, count in total_dist.items():\n        E_mev = scaled_E / scale\n        if lower_bound = E_mev = upper_bound:\n            total_count += count\n            \n    return total_count\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general, mixed spectrum)\n        (\n            [(0.8, 2), (0.5, 2)],  # Protons below\n            [(0.4, 2), (0.9, 1)],  # Protons above\n            [(0.7, 2)],            # Neutrons below\n            [(0.6, 1), (1.1, 1)],  # Neutrons above\n            0.1, 1.0               # dU, U\n        ),\n        # Case 2 (boundary condition at zero excitation)\n        (\n            [(0.8, 2), (0.5, 2)],\n            [(0.4, 2), (0.9, 1)],\n            [(0.7, 2)],\n            [(0.6, 1), (1.1, 1)],\n            0.1, 0.0\n        ),\n        # Case 3 (single-level symmetry)\n        (\n            [(0.5, 3)],\n            [(0.5, 3)],\n            [],\n            [],\n            0.2, 1.0\n        ),\n        # Case 4 (higher combinatorial complexity)\n        (\n            [(0.3, 4), (0.7, 2)],\n            [(0.2, 3), (0.9, 1)],\n            [(0.4, 3)],\n            [(0.1, 5), (0.8, 1)],\n            0.05, 1.0\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_rho(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在基础组合方法之上，本练习引入了现代核结构理论中更为真实的物理特性 ()。我们将使用Hartree-Fock-Bogoliubov (HFB) 理论中的准粒子激发来取代简单的粒子-空穴图像，这种方法能更恰当地处理对关联效应。通过这个实践，你还将学习如何将计算结果投影到好量子数（如自旋和宇称）上，这对于与实验数据进行比较以及在反应计算中应用至关重要。",
            "id": "3575182",
            "problem": "编写一个完整且可运行的程序，针对下面指定的每个测试用例，从 Hartree–Fock–Bogoliubov (HFB) 准粒子输入构建组合核能级密度，并将其与两种唯象模型进行比较。您的程序必须从基本定义出发，实现以下内容。\n\n- 采用能级密度的微正则定义，即在激发能为 $E$、自旋为 $J$、宇称为 $\\pi$ 的多体态的计数：能级密度是能量上的态密度，而宇称分辨密度 $\\rho(E,\\pi)$ 只计算宇称为 $\\pi$ 的那些态。对于指定的箱宽 $\\Delta E$，通过在均匀网格上进行分箱，并将计数结果除以 $\\Delta E$ 来近似计数中的狄拉克δ函数，从而获得单位为 $\\text{MeV}^{-1}$ 的密度。\n\n- 使用独立准粒子近似。给定一组由 $i=1,\\dots,N$ 索引的 $N$ 个准粒子，每个准粒子都具有激发能 $\\varepsilon_i$、宇称 $\\pi_i \\in \\{+1,-1\\}$ 和 HFB 占据几率 $v_i^2$（因此 $u_i^2 = 1-v_i^2$），定义一个组态 $S \\subseteq \\{1,\\dots,N\\}$，其激发能为 $E_S = \\sum_{i \\in S} \\varepsilon_i$，宇称为 $\\pi_S = \\prod_{i \\in S} \\pi_i$。包括能量为 $E_{\\varnothing} = 0$ 且宇称为 $\\pi_{\\varnothing}=+1$ 的真空组态 $S=\\varnothing$。\n\n- 引入 HFB 占据振幅，通过为每个准粒子 $i$ 分配一个对破缺权重 $w_i = 4 u_i^2 v_i^2$，并定义组态权重 $W_S = \\prod_{i \\in S} w_i$（且 $W_{\\varnothing}=1$）。将 $W_S$ 解释为调制组态 $S$ 对能级密度贡献的统计权重。\n\n- 在箱宽为 $\\Delta E = 0.2\\,\\text{MeV}$ 的均匀网格上，构建最高能量为 $E_{\\max} = 20\\,\\text{MeV}$ 的宇称投影、分箱的组合密度。使用最近邻分箱分配：只要 $E_S \\le E_{\\max}$，来自 $E_S$ 的贡献 $W_S$ 就被加到其中心最接近 $E_S$ 的箱中。在对所有组态求和后，将每个箱的计数除以 $\\Delta E$，以获得单位为 $\\text{MeV}^{-1}$ 的 $\\rho(E,\\pi)$。\n\n- 使用自旋截断模型进行自旋投影。对于中心能量为 $E_b$ 的箱，定义内禀激发能 $U = E_b - \\delta$（对于要求 $U>0$ 的模型，如果 $U \\le 0$，则将密度设为零）。自旋截断参数为\n$$\n\\sigma^2(E_b) = \\alpha\\, A^{2/3}\\, \\sqrt{a\\, U},\n$$\n其中 $\\alpha$ 按每个测试用例指定，$A$ 是质量数，$a$ 是能级密度参数（单位为 $\\text{MeV}^{-1}$）。对于整数 $J \\in \\{0,1,\\dots,J_{\\max}\\}$ 的离散自旋分布为\n$$\nP(J \\mid \\sigma) \\propto (2J+1)\\, \\exp\\!\\left(-\\frac{J(J+1)}{2\\,\\sigma^2}\\right),\n$$\n归一化条件为 $\\sum_{J=0}^{J_{\\max}} P(J \\mid \\sigma) = 1$。对于 $\\sigma=0$，取 $P(0 \\mid \\sigma)=1$ 且 $P(J>0 \\mid \\sigma)=0$。将自旋投影密度构造为 $\\rho(E_b,J,\\pi) = \\rho(E_b,\\pi)\\, P(J \\mid \\sigma(E_b))$，总密度为 $\\rho(E_b) = \\sum_{\\pi} \\rho(E_b,\\pi)$。\n\n- 将 $\\rho(E)$ 与两种唯象模型进行比较（能量单位为 $\\text{MeV}$，密度单位为 $\\text{MeV}^{-1}$）：\n  - 恒温模型：$\\rho_{\\mathrm{CT}}(E) = \\frac{1}{T}\\, \\exp\\!\\left(\\frac{E - E_0}{T}\\right)$，其中 $T$ 和 $E_0$ 是给定的。\n  - 背移费米气体（BSFG）模型：具有背移 $\\delta$，内禀能量 $U = E - \\delta$，对于 $U \\le 0$，设置 $\\rho_{\\mathrm{BSFG}}(E)=0$。对于 $U>0$，\n  $$\n  \\rho_{\\mathrm{BSFG}}(E) = \\frac{\\sqrt{\\pi}}{12}\\, \\frac{\\exp\\!\\left(2\\sqrt{a\\,U}\\right)}{a^{1/4}\\, U^{5/4}}。\n  $$\n\n您的程序必须为每个测试用例计算以下四个标量诊断量，使用分箱后的密度，并通过最近邻箱索引将能量箱中心匹配到 $E=8\\,\\text{MeV}$ 和 $E=10\\,\\text{MeV}$：\n\n1. 比率 $r_{\\mathrm{CT}}(10) = \\rho(10)/\\rho_{\\mathrm{CT}}(10)$。\n2. 比率 $r_{\\mathrm{BSFG}}(10) = \\rho(10)/\\rho_{\\mathrm{BSFG}}(10)$，将 $0/0$ 解释为 $0$。\n3. 在 $E=8\\,\\text{MeV}$ 处的宇称不对称性，\n$$\n\\mathcal{A}_\\pi(8) = \\frac{\\rho(8,+) - \\rho(8,-)}{\\rho(8,+) + \\rho(8,-)},\n$$\n约定如果分母为零，则 $\\mathcal{A}_\\pi(8)=0$。\n4. 在 $E=10\\,\\text{MeV}$ 处的自旋投影概率 $P(J=0 \\mid \\sigma(10))$，使用在 $J \\in \\{0,1,\\dots,J_{\\max}\\}$ 上的离散归一化。\n\n物理和数值单位及约定：\n\n- 所有能量 $\\varepsilon_i$、$E$、$E_0$、$\\delta$、$T$ 的单位都是 $\\text{MeV}$。能级密度参数 $a$ 的单位是 $\\text{MeV}^{-1}$。输出密度的单位是 $\\text{MeV}^{-1}$。比率和概率是无量纲的。\n- 本问题不涉及角度。\n- 程序必须实现箱宽 $\\Delta E = 0.2\\,\\text{MeV}$、最大能量 $E_{\\max}=20\\,\\text{MeV}$ 的分箱，以及 $J_{\\max}=12$ 的自旋投影。\n- 按前述方式处理真空组态 $S=\\varnothing$，并忽略任何能量 $E_S > E_{\\max}$ 的组态。\n\n测试套件：\n\n- 全局参数：$\\Delta E = 0.2\\,\\text{MeV}$，$E_{\\max} = 20\\,\\text{MeV}$，$J_{\\max} = 12$，$\\alpha = 0.146$。\n\n- 测试用例 1：\n  - $A=56$，$a=7.0\\,\\text{MeV}^{-1}$，$\\delta=1.5\\,\\text{MeV}$，$T=0.9\\,\\text{MeV}$，$E_0=-0.5\\,\\text{MeV}$。\n  - $\\{\\varepsilon_i\\} = \\{0.8, 1.0, 1.3, 1.7, 2.0, 2.6, 3.1, 3.8, 4.2, 4.9, 5.6, 6.3\\}\\,\\text{MeV}$。\n  - $\\{v_i^2\\} = \\{0.95, 0.85, 0.70, 0.55, 0.50, 0.50, 0.45, 0.35, 0.30, 0.25, 0.20, 0.15\\}$。\n  - $\\{\\pi_i\\} = \\{+1, +1, -1, -1, +1, -1, +1, -1, +1, +1, -1, -1\\}$。\n\n- 测试用例 2：\n  - $A=98$，$a=12.25\\,\\text{MeV}^{-1}$，$\\delta=1.0\\,\\text{MeV}$，$T=0.8\\,\\text{MeV}$，$E_0=-0.6\\,\\text{MeV}$。\n  - $\\{\\varepsilon_i\\} = \\{0.5, 0.7, 0.9, 1.1, 1.4, 1.8, 2.2, 2.7, 3.3, 3.9, 4.6, 5.4, 6.3\\}\\,\\text{MeV}$。\n  - $\\{v_i^2\\} = \\{0.90, 0.85, 0.80, 0.70, 0.60, 0.55, 0.50, 0.45, 0.40, 0.35, 0.30, 0.25, 0.20\\}$。\n  - $\\{\\pi_i\\} = \\{+1, -1, +1, -1, +1, -1, +1, -1, +1, -1, +1, -1, +1\\}$。\n\n- 测试用例 3：\n  - $A=162$，$a=20.25\\,\\text{MeV}^{-1}$，$\\delta=0.8\\,\\text{MeV}$，$T=0.6\\,\\text{MeV}$，$E_0=-0.8\\,\\text{MeV}$。\n  - $\\{\\varepsilon_i\\} = \\{0.4, 0.6, 0.8, 1.0, 1.3, 1.6, 2.0, 2.5, 3.0, 3.6, 4.3\\}\\,\\text{MeV}$。\n  - $\\{v_i^2\\} = \\{0.80, 0.75, 0.70, 0.65, 0.60, 0.55, 0.50, 0.45, 0.40, 0.35, 0.30\\}$。\n  - $\\{\\pi_i\\} = \\{-1, -1, +1, +1, -1, +1, -1, +1, -1, +1, -1\\}$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个含三个列表的列表（每个测试用例一个）。对于每个测试用例，按顺序 $[r_{\\mathrm{CT}}(10), r_{\\mathrm{BSFG}}(10), \\mathcal{A}_\\pi(8), P(J{=}0 \\mid \\sigma(10))]$ 将四个诊断量输出为一个列表。这三个列表必须聚合到一个顶层列表中，并打印在同一行上，例如：\n\"[ [x11,x12,x13,x14], [x21,x22,x23,x24], [x31,x32,x33,x34] ]\"\n其中每个 $x_{ij}$ 都是一个浮点数。",
            "solution": "该问题要求实现一个基于 Hartree–Fock–Bogoliubov (HFB) 准粒子输入的组合模型，用于计算核能级密度。然后将得到的能级密度与标准的唯象模型进行比较，并计算几个诊断量。解决方案首先构建加权的、宇称投影的组合能级密度，然后利用此结果计算指定的诊断量。\n\n### 1. 组合能级密度计算\n\n计算的基础是独立准粒子近似。一个原子核由一组 $N$ 个准粒子描述，每个准粒子由索引 $i \\in \\{1, \\dots, N\\}$ 标记。每个准粒子的特征是其激发能 $\\varepsilon_i$、宇称 $\\pi_i \\in \\{+1, -1\\}$ 和 HFB 占据几率 $v_i^2$。\n\n一个多体组态，用集合 $S \\subseteq \\{1, \\dots, N\\}$ 表示，对应于 $S$ 中准粒子的同时激发。这样一个组态的总激发能 $E_S$ 和宇称 $\\pi_S$ 分别定义为各个准粒子属性的和与积：\n$$\nE_S = \\sum_{i \\in S} \\varepsilon_i\n$$\n$$\n\\pi_S = \\prod_{i \\in S} \\pi_i\n$$\n所有可能的组态集合包括真空态 $S=\\varnothing$，其能量为 $E_{\\varnothing} = 0$，宇称为 $\\pi_{\\varnothing} = +1$。\n\n在 HFB 框架内，准粒子激发的创建对应于库珀对的破缺。准粒子态 $i$ 被占据的概率由 $v_i^2$ 给出，而其为空的概率是 $u_i^2 = 1 - v_i^2$。为产生第 i 个准粒子激发而破坏对的统计权重由对破缺权重 $w_i$ 给出：\n$$\nw_i = 4 u_i^2 v_i^2 = 4 (1 - v_i^2) v_i^2\n$$\n一个组态 $S$ 的统计权重 $W_S$ 是其构成准粒子权重的乘积：\n$$\nW_S = \\prod_{i \\in S} w_i\n$$\n对于真空态，权重为 $W_{\\varnothing} = 1$。这个权重 $W_S$ 调制了组态 $S$ 对总能级密度的贡献。\n\n该算法的核心是遍历所有 $2^N$ 种可能的组态。对于每个组态 $S$，我们计算其能量 $E_S$、宇称 $\\pi_S$ 和权重 $W_S$。\n\n### 2. 离散化与密度公式\n\n核能级密度 $\\rho(E)$ 在形式上是单位能量的态密度。为了从离散的组态集合中计算它，我们采用分箱程序。我们定义一个均匀的能量网格，箱宽为 $\\Delta E = 0.2\\,\\text{MeV}$，最大能量为 $E_{\\max} = 20\\,\\text{MeV}$。设箱中心为 $E_b = k \\cdot \\Delta E$，其中 k 为非负整数。\n\n对于每个能量 $E_S \\le E_{\\max}$ 的组态 $S$，其权重 $W_S$ 被加到中心最接近 $E_S$ 的箱的内容中。该箱的索引通过 $k = \\text{round}(E_S / \\Delta E)$ 找到。贡献被分别收集到正宇称态和负宇称态中，产生两个分箱求和数组 $C_+(E_b)$ 和 $C_-(E_b)$。\n\n然后通过将这些和除以箱宽 $\\Delta E$ 来获得宇称投影能级密度 $\\rho(E_b, +)$ 和 $\\rho(E_b, -)$：\n$$\n\\rho(E_b, +) = \\frac{C_+(E_b)}{\\Delta E}\n$$\n$$\n\\rho(E_b, -) = \\frac{C_-(E_b)}{\\Delta E}\n$$\n箱中心 $E_b$ 处的总能级密度是宇称投影密度的和：\n$$\n\\rho(E_b) = \\rho(E_b, +) + \\rho(E_b, -)\n$$\n\n### 3. 与唯象模型的比较\n\n计算出的组合密度 $\\rho(E)$ 与两种广泛使用的唯象模型在特定能量下进行比较。\n\n**恒温（CT）模型：** 该模型假设核温度 $T$ 在一定能量范围内是恒定的。能级密度由下式给出：\n$$\n\\rho_{\\mathrm{CT}}(E) = \\frac{1}{T} \\exp\\left(\\frac{E - E_0}{T}\\right)\n$$\n其中 $T$ 是核温度，$E_0$ 是一个能量位移参数。\n\n**背移费米气体（BSFG）模型：** 该模型基于原子核的费米气体模型，并通过背移参数 $\\delta$ 对配对效应进行了修正。能级密度是为内禀激发能 $U = E - \\delta$ 定义的。对于 $U > 0$，公式为：\n$$\n\\rho_{\\mathrm{BSFG}}(E) = \\frac{\\sqrt{\\pi}}{12} \\frac{\\exp\\left(2\\sqrt{aU}\\right)}{a^{1/4} U^{5/4}}\n$$\n其中 $a$ 是能级密度参数。对于 $U \\le 0$，密度为 $\\rho_{\\mathrm{BSFG}}(E) = 0$。\n\n### 4. 自旋投影与诊断量\n\n计算出的能级密度 $\\rho(E_b, \\pi)$ 是一个内禀密度，意味着它是在所有自旋投影 $J_z$ 上求和得到的。为了获得与自旋相关的密度，我们使用自旋截断模型。\n\n假定给定激发能下的自旋分布由自旋截断参数 $\\sigma(E_b)$ 控制。对于中心为 $E_b$ 的箱，内禀能量是 $U = E_b - \\delta$，自旋截断参数的平方是：\n$$\n\\sigma^2(E_b) = \\alpha A^{2/3} \\sqrt{aU}\n$$\n其中 $A$ 是质量数，$\\alpha$ 是一个给定的常数。如果 $U \\le 0$，则不使用此公式；通常，自旋分布被视为在 $J=0$ 处的狄拉克δ函数。\n\n一个态具有特定整数自旋 $J$ 的概率由一个归一化的分布给出：\n$$\nP(J \\mid \\sigma) = \\mathcal{N} (2J+1) \\exp\\left(-\\frac{J(J+1)}{2\\sigma^2}\\right)\n$$\n归一化因子 $\\mathcal{N}$ 是通过要求在所有考虑的自旋上求和为 1 来确定的：$\\sum_{J=0}^{J_{\\max}} P(J \\mid \\sigma) = 1$。对于边缘情况 $\\sigma = 0$，分布为 $P(0 \\mid \\sigma) = 1$ 且 $P(J>0 \\mid \\sigma) = 0$。\n\n该问题要求为每个测试用例计算四个特定的诊断量，使用在能量 $E=8\\,\\text{MeV}$ 和 $E=10\\,\\text{MeV}$ 处的分箱组合密度和上述模型。\n\n1.  **与 CT 模型在 $E=10\\,\\text{MeV}$ 处的比率**：$r_{\\mathrm{CT}}(10) = \\rho(10) / \\rho_{\\mathrm{CT}}(10)$。\n2.  **与 BSFG 模型在 $E=10\\,\\text{MeV}$ 处的比率**：$r_{\\mathrm{BSFG}}(10) = \\rho(10) / \\rho_{\\mathrm{BSFG}}(10)$，约定 $0/0$ 的计算结果为 $0$。\n3.  **在 $E=8\\,\\text{MeV}$ 处的宇称不对称性**：$\\mathcal{A}_\\pi(8) = \\frac{\\rho(8,+) - \\rho(8,-)}{\\rho(8,+) + \\rho(8,-)}$。如果分母为零，则 $\\mathcal{A}_\\pi(8)=0$。\n4.  **在 $E=10\\,\\text{MeV}$ 处的自旋-0 概率**：$P(J=0 \\mid \\sigma(10))$，使用在 $J \\in \\{0, \\dots, J_{\\max}\\}$ 上的离散归一化计算。\n\n这些诊断量是通过确定适当的能量箱（其中心位于 $8.0\\,\\text{MeV}$ 和 $10.0\\,\\text{MeV}$）并应用各自的公式来计算的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the nuclear level density problem for the specified test cases.\n    \"\"\"\n\n    # Global parameters\n    DELTA_E = 0.2  # MeV\n    E_MAX = 20.0   # MeV\n    J_MAX = 12\n    ALPHA = 0.146\n\n    test_cases = [\n        {\n            # Test case 1\n            \"A\": 56, \"a\": 7.0, \"delta\": 1.5, \"T\": 0.9, \"E0\": -0.5,\n            \"eps\": [0.8, 1.0, 1.3, 1.7, 2.0, 2.6, 3.1, 3.8, 4.2, 4.9, 5.6, 6.3],\n            \"v2\": [0.95, 0.85, 0.70, 0.55, 0.50, 0.50, 0.45, 0.35, 0.30, 0.25, 0.20, 0.15],\n            \"pi\": [+1, +1, -1, -1, +1, -1, +1, -1, +1, +1, -1, -1],\n        },\n        {\n            # Test case 2\n            \"A\": 98, \"a\": 12.25, \"delta\": 1.0, \"T\": 0.8, \"E0\": -0.6,\n            \"eps\": [0.5, 0.7, 0.9, 1.1, 1.4, 1.8, 2.2, 2.7, 3.3, 3.9, 4.6, 5.4, 6.3],\n            \"v2\": [0.90, 0.85, 0.80, 0.70, 0.60, 0.55, 0.50, 0.45, 0.40, 0.35, 0.30, 0.25, 0.20],\n            \"pi\": [+1, -1, +1, -1, +1, -1, +1, -1, +1, -1, +1, -1, +1],\n        },\n        {\n            # Test case 3\n            \"A\": 162, \"a\": 20.25, \"delta\": 0.8, \"T\": 0.6, \"E0\": -0.8,\n            \"eps\": [0.4, 0.6, 0.8, 1.0, 1.3, 1.6, 2.0, 2.5, 3.0, 3.6, 4.3],\n            \"v2\": [0.80, 0.75, 0.70, 0.65, 0.60, 0.55, 0.50, 0.45, 0.40, 0.35, 0.30],\n            \"pi\": [-1, -1, +1, +1, -1, +1, -1, +1, -1, +1, -1],\n        }\n    ]\n\n    results = []\n\n    num_bins = int(E_MAX / DELTA_E) + 1\n\n    for case in test_cases:\n        N = len(case[\"eps\"])\n        eps = np.array(case[\"eps\"])\n        v2 = np.array(case[\"v2\"])\n        pi = np.array(case[\"pi\"])\n        u2 = 1.0 - v2\n        w = 4.0 * u2 * v2\n        \n        # Initialize binned counts for positive and negative parity\n        counts_pos = np.zeros(num_bins)\n        counts_neg = np.zeros(num_bins)\n        \n        # Initialize with vacuum configuration (S=empty set)\n        counts_pos[0] += 1.0\n        \n        # Iterate through all 2^N configurations\n        for i in range(1, 1  N):\n            E_S = 0.0\n            pi_S = 1\n            W_S = 1.0\n            \n            for j in range(N):\n                if (i >> j)  1:\n                    E_S += eps[j]\n                    pi_S *= pi[j]\n                    W_S *= w[j]\n            \n            if E_S = E_MAX:\n                bin_idx = int(round(E_S / DELTA_E))\n                if bin_idx  num_bins:\n                    if pi_S == 1:\n                        counts_pos[bin_idx] += W_S\n                    else:\n                        counts_neg[bin_idx] += W_S\n\n        # Convert counts to densities\n        rho_pos = counts_pos / DELTA_E\n        rho_neg = counts_neg / DELTA_E\n\n        # --- Calculate Diagnostics ---\n        \n        E_diag_1 = 8.0\n        E_diag_2 = 10.0\n        \n        # Find bin indices for diagnostic energies\n        idx_8 = int(round(E_diag_1 / DELTA_E))\n        idx_10 = int(round(E_diag_2 / DELTA_E))\n        \n        # Get combinatorial densities at diagnostic energies\n        rho_pos_8 = rho_pos[idx_8]\n        rho_neg_8 = rho_neg[idx_8]\n        rho_total_8 = rho_pos_8 + rho_neg_8\n        \n        rho_pos_10 = rho_pos[idx_10]\n        rho_neg_10 = rho_neg[idx_10]\n        rho_total_10 = rho_pos_10 + rho_neg_10\n\n        # 1. Ratio r_CT(10)\n        rho_ct_10 = (1.0 / case[\"T\"]) * np.exp((E_diag_2 - case[\"E0\"]) / case[\"T\"])\n        r_ct_10 = rho_total_10 / rho_ct_10 if rho_ct_10 != 0 else 0.0\n\n        # 2. Ratio r_BSFG(10)\n        U_10 = E_diag_2 - case[\"delta\"]\n        if U_10 = 0:\n            rho_bsfg_10 = 0.0\n        else:\n            a_val = case[\"a\"]\n            rho_bsfg_10 = (np.sqrt(np.pi) / 12.0) * \\\n                        np.exp(2.0 * np.sqrt(a_val * U_10)) / \\\n                        (a_val**0.25 * U_10**1.25)\n        \n        if rho_bsfg_10 == 0:\n            r_bsfg_10 = 0.0 if rho_total_10 == 0 else np.inf\n        else:\n            r_bsfg_10 = rho_total_10 / rho_bsfg_10\n\n        # 3. Parity asymmetry A_pi(8)\n        if rho_total_8 == 0:\n            A_pi_8 = 0.0\n        else:\n            A_pi_8 = (rho_pos_8 - rho_neg_8) / rho_total_8\n            \n        # 4. Spin-0 probability P(J=0 | sigma(10))\n        E_b_10 = idx_10 * DELTA_E\n        U_spin = E_b_10 - case[\"delta\"]\n        p_j0_10 = 0.0\n        \n        if U_spin = 0:\n             p_j0_10 = 1.0 # sigma = 0 case\n        else:\n            sigma2 = ALPHA * (case[\"A\"]**(2.0/3.0)) * np.sqrt(case[\"a\"] * U_spin)\n            if sigma2 == 0:\n                p_j0_10 = 1.0\n            else:\n                j_vals = np.arange(0, J_MAX + 1)\n                p_unnorm = (2 * j_vals + 1) * np.exp(-j_vals * (j_vals + 1) / (2 * sigma2))\n                \n                # P(J=0) unnormalized is always 1 * exp(0) = 1\n                p_j0_unnorm = 1.0\n                norm_sum = np.sum(p_unnorm)\n                \n                p_j0_10 = p_j0_unnorm / norm_sum if norm_sum > 0 else 0.0\n\n        case_results = [r_ct_10, r_bsfg_10, A_pi_8, p_j0_10]\n        results.append(case_results)\n\n    # Format the final output string precisely\n    final_output_str = \"[\"\n    for i, res_list in enumerate(results):\n        inner_str = '[' + ','.join(map(str, res_list)) + ']'\n        final_output_str += inner_str\n        if i  len(results) - 1:\n            final_output_str += \",\"\n    final_output_str += \"]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "无论一个能级密度模型是源自第一性原理计算，还是一个唯象公式，它都必须遵循热力学的基本定律。本练习为你提供了一个计算框架，用于检验任何给定的能级密度函数 $\\rho(E)$ 的物理有效性 ()。你将通过编程实现对核心物理量（如正温度和非负热容）的检验，学会如何在理论模型应用于更复杂的计算（如核反应截面）之前，识别并排除那些不符合物理规律的模型。",
            "id": "3575214",
            "problem": "给定一个关于有限原子核的核能级密度函数 $\\rho(E)$，该函数是激发能 $E$ 的函数。在微正则系综中，熵 $S(E)$、温度 $T(E)$ 和热容 $C(E)$ 必须满足基本的热力学自洽性条件。你的任务是实现一个程序，该程序针对一组给定的 $\\rho(E)$ 模型，在一个离散的能量网格上计算 $S(E)$、$T(E)$ 和 $C(E)$，并通过检查以下条件来验证其自洽性：(i) $\\rho(E)$ 的正性，(ii) $S(E)$ 作为 $E$ 的函数单调不减，(iii) $T(E)$ 的正性，以及 (iv) 在指定的能量区间内不存在负热容。能量单位必须为兆电子伏特（MeV），温度也必须以 MeV 表示（假设玻尔兹曼常数 $k_{\\mathrm{B}} = 1$，因此温度具有能量单位），而热容 $C(E)$ 是无量纲的，因为它是以单位温度的能量来度量的。程序必须生成单行输出，其中包含所有测试用例的结果，结果为用逗号分隔并包含在方括号内的列表。\n\n基本原理和定义：\n- 微正则熵定义为 $S(E) = \\ln \\rho(E) + \\text{constant}$，其中加法常数不影响导数。\n- 微正则温度定义为 $\\frac{1}{T(E)} = \\frac{dS}{dE}$，因此，在 $\\frac{dS}{dE} > 0$ 的条件下，$T(E) = \\left(\\frac{dS}{dE}\\right)^{-1}$。\n- 微正则热容定义为 $C(E) = \\frac{dE}{dT} = \\left(\\frac{dT}{dE}\\right)^{-1}$，因此 $C(E)  0$ 当且仅当 $\\frac{dT}{dE}  0$。\n\n算法要求：\n- 使用均匀的能量网格 $E \\in [E_{\\min}, E_{\\max}]$，步长为 $\\Delta E$，所有单位均为 $\\mathrm{MeV}$。\n- 在所有 $\\rho(E) > 0$ 的网格点上计算 $S(E) = \\ln \\rho(E)$。\n- 使用与离散均匀网格一致的方法，例如中心差分或考虑了间距 $\\Delta E$ 的数值梯度，通过有限差分来近似导数。\n- 在同一网格上计算 $T(E) = \\left(\\frac{dS}{dE}\\right)^{-1}$ 和 $\\frac{dT}{dE}$。\n- 应用自洽性检查：\n  1. 对所有网格点，$\\rho(E) > 0$。\n  2. $S(E)$ 是单调不减的，即对于所有连续的网格点 $E_i$ 和 $E_{i+1}$，$S(E_{i+1}) - S(E_i) \\ge 0$，允许一个小的数值容差以考虑有限差分误差。\n  3. 对所有网格点，$T(E) > 0$。\n  4. 在每个测试用例的指定区间内（由 $E \\ge E_{\\mathrm{check}}$ 定义），不存在负热容；等价地，在该区间内 $\\frac{dT}{dE} \\ge 0$，允许一个小的数值容差。\n\n测试套件：\n- 测试用例 $1$ (受背移费米气体模型启发的能级密度)：$\\rho(E) = A \\frac{\\exp\\!\\left(2 \\sqrt{a (E - \\Delta)}\\right)}{(E - \\Delta)^{5/4}}$ 对于 $E > \\Delta$，参数为 $A = 10^{-9}$，$a = 6.0 \\, \\mathrm{MeV}^{-1}$，$\\Delta = 0.5 \\, \\mathrm{MeV}$；能量网格 $E \\in [1.0 \\, \\mathrm{MeV}, 30.0 \\, \\mathrm{MeV}]$，步长 $\\Delta E = 0.05 \\, \\mathrm{MeV}$；检查区间阈值 $E_{\\mathrm{check}} = 1.5 \\, \\mathrm{MeV}$。\n- 测试用例 $2$ (常温模型)：$\\rho(E) = \\frac{1}{T_0} \\exp\\!\\left(\\frac{E - E_0}{T_0}\\right)$，参数为 $T_0 = 1.2 \\, \\mathrm{MeV}$，$E_0 = 0.0 \\, \\mathrm{MeV}$；能量网格 $E \\in [0.0 \\, \\mathrm{MeV}, 30.0 \\, \\mathrm{MeV}]$，步长 $\\Delta E = 0.05 \\, \\mathrm{MeV}$；检查区间阈值 $E_{\\mathrm{check}} = 0.0 \\, \\mathrm{MeV}$。\n- 测试用例 $3$ (振荡调制的指数函数，旨在展示病态特征)：$\\rho(E) = \\exp(\\alpha E)\\left[1 + \\epsilon \\sin(k E)\\right]$，参数为 $\\alpha = 0.3 \\, \\mathrm{MeV}^{-1}$，$\\epsilon = 0.9$，$k = 1.0 \\, \\mathrm{MeV}^{-1}$；能量网格 $E \\in [1.0 \\, \\mathrm{MeV}, 30.0 \\, \\mathrm{MeV}]$，步长 $\\Delta E = 0.05 \\, \\mathrm{MeV}$；检查区间阈值 $E_{\\mathrm{check}} = 1.0 \\, \\mathrm{MeV}$。\n- 测试用例 $4$ (阈值以上的幂律增长)：$\\rho(E) = (E - E_c)^p$ 对于 $E > E_c$，参数为 $p = 3.0$，$E_c = 0.5 \\, \\mathrm{MeV}$；能量网格 $E \\in [0.6 \\, \\mathrm{MeV}, 20.0 \\, \\mathrm{MeV}]$，步长 $\\Delta E = 0.05 \\, \\mathrm{MeV}$；检查区间阈值 $E_{\\mathrm{check}} = 0.6 \\, \\mathrm{MeV}$。\n\n验证输出：\n- 对于每个测试用例，如果所有四个检查都满足，则生成一个布尔值 $ \\text{True} $，否则生成 $ \\text{False} $。在评估有限差分的单调性和非负性条件时，使用数值容差 $ \\tau = 10^{-8} $ 来考虑数值微分误差。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用逗号分隔并用方括号括起来的结果列表，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$，其中每个 $\\text{result}_i$ 是上述测试用例 $i$ 的布尔值。",
            "solution": "该问题陈述已经过验证，并被认定为有效。它在科学上基于应用于核物理的统计力学原理，问题定义明确，所有必要的参数和条件都已指定，并且其表述是客观的。任务是基于一组清晰、形式化的标准，通过计算来验证四个提议的核能级密度模型 $\\rho(E)$ 的热力学自洽性。\n\n问题的核心在于能级密度 $\\rho(E)$ 与微正则熵 $S(E)$、温度 $T(E)$ 和热容 $C(E)$ 之间的关系。这些关系源于基本的统计力学。\n熵定义为 $S(E) = \\ln \\rho(E)$，忽略了一个无关的加法常数。\n温度是熵随能量变化率的倒数：$T(E) = \\left(\\frac{dS}{dE}\\right)^{-1}$。\n热容是温度随能量变化率的倒数：$C(E) = \\left(\\frac{dT}{dE}\\right)^{-1}$。\n\n对于一个热力学自洽的系统，必须满足以下条件：\n1.  态密度必须为正：$\\rho(E) > 0$。\n2.  熵必须是能量的非递减函数：$\\frac{dS}{dE} \\ge 0$。\n3.  温度必须为正：$T(E) > 0$。这意味着对熵有更严格的条件，即 $\\frac{dS}{dE} > 0$，因为如果 $\\frac{dS}{dE}=0$，$T(E)$ 将无定义或为无穷大。\n4.  在典型的热平衡区间内，热容不能为负。负热容 $C(E)  0$ 对应于系统在增加能量时反而冷却的情况，这是不稳定性或相变的标志。此条件等价于 $\\frac{dT}{dE} \\ge 0$。\n\n将为每个测试用例按如下方式实现算法过程：\n- 从 $E_{\\min}$ 到 $E_{\\max}$ 构建能量网格 $E$，步长为 $\\Delta E$。\n- 在每个网格点 $E_i$ 上计算能级密度 $\\rho(E_i)$。\n- 然后计算熵 $S(E_i) = \\ln \\rho(E_i)$。\n- 使用二阶中心有限差分法对导数 $\\frac{dS}{dE}$ 和 $\\frac{dT}{dE}$进行数值近似，正如在 `numpy.gradient` 中实现的那样，这适用于均匀网格。\n- 然后依次应用四个自洽性检查。如果任何一个检查失败，则该模型被认为是不自洽的。对于涉及不等式的检查，使用 $\\tau = 10^{-8}$ 的数值容差来考虑浮点不精确性。\n\n让我们分析每个测试用例。\n\n**测试用例 1：背移费米气体 (BSFG) 模型**\n- 能级密度：$\\rho(E) = A \\frac{\\exp\\!\\left(2 \\sqrt{a (E - \\Delta)}\\right)}{(E - \\Delta)^{5/4}}$ 对于 $E > \\Delta$。\n- 参数：$A = 10^{-9}$，$a = 6.0 \\, \\mathrm{MeV}^{-1}$，$\\Delta = 0.5 \\, \\mathrm{MeV}$。\n- 网格：$E \\in [1.0, 30.0] \\, \\mathrm{MeV}$，$\\Delta E = 0.05 \\, \\mathrm{MeV}$。\n- 检查区间：$E \\ge E_{\\mathrm{check}} = 1.5 \\, \\mathrm{MeV}$。\n\n1.  **检查 $\\rho(E) > 0$**：能量网格从 $E=1.0 \\, \\mathrm{MeV}$ 开始，大于 $\\Delta = 0.5 \\, \\mathrm{MeV}$。$\\rho(E)$ 表达式中的所有项均为正，因此该检查将通过。\n2.  **检查 $S(E)$ 单调性 ($\\frac{dS}{dE} \\ge 0$)**：熵为 $S(E) = \\ln A + 2\\sqrt{a(E-\\Delta)} - \\frac{5}{4}\\ln(E-\\Delta)$。其导数为 $\\frac{dS}{dE} = \\frac{\\sqrt{a}}{\\sqrt{E-\\Delta}} - \\frac{5}{4(E-\\Delta)}$。为使此值为正，我们需要 $\\sqrt{a(E-\\Delta)} > \\frac{5}{4}$，或 $E-\\Delta > \\frac{25}{16a} = \\frac{25}{16 \\times 6} \\approx 0.26 \\, \\mathrm{MeV}$。由于网格在 $E-\\Delta = 0.5 \\, \\mathrm{MeV}$ 处开始，此条件对所有网格点均成立。\n3.  **检查 $T(E) > 0$**：这等价于 $\\frac{dS}{dE} > 0$，刚才已经证明。此检查将通过。\n4.  **检查 $C(E) \\ge 0$ ($\\frac{dT}{dE} \\ge 0$) 对于 $E \\ge 1.5 \\, \\mathrm{MeV}$**：温度是 $T(E) = (\\frac{dS}{dE})^{-1} = \\frac{E-\\Delta}{\\sqrt{a(E-\\Delta)} - 5/4}$。其导数 $\\frac{dT}{dE}$ 的符号由商规则中的分子决定，该分子与 $\\frac{1}{2}\\sqrt{a(E-\\Delta)} - \\frac{5}{4}$ 成正比。为使 $\\frac{dT}{dE} \\ge 0$，我们需要 $\\sqrt{a(E-\\Delta)} \\ge \\frac{5}{2}$，这意味着 $E-\\Delta \\ge \\frac{25}{4a} = \\frac{25}{24} \\approx 1.0417 \\, \\mathrm{MeV}$，即 $E \\ge 1.5417 \\, \\mathrm{MeV}$。检查区间从 $E_{\\mathrm{check}} = 1.5 \\, \\mathrm{MeV}$ 开始。在检查区间的一部分，从 $E=1.5 \\, \\mathrm{MeV}$ 到约 $E=1.54 \\, \\mathrm{MeV}$，我们预期 $\\frac{dT}{dE}  0$。这对应于一个负热容区域，这是费米气体模型微正则处理的一个已知特征。因此，预期此检查将失败。\n测试用例 1 的预期结果是 **False**。\n\n**测试用例 2：常温模型**\n- 能级密度：$\\rho(E) = \\frac{1}{T_0} \\exp\\!\\left(\\frac{E - E_0}{T_0}\\right)$。\n- 参数：$T_0 = 1.2 \\, \\mathrm{MeV}$，$E_0 = 0.0 \\, \\mathrm{MeV}$。\n- 网格：$E \\in [0.0, 30.0] \\, \\mathrm{MeV}$，$\\Delta E = 0.05 \\, \\mathrm{MeV}$。\n- 检查区间：$E \\ge E_{\\mathrm{check}} = 0.0 \\, \\mathrm{MeV}$。\n\n1.  **检查 $\\rho(E) > 0$**：指数函数始终为正，$\\frac{1}{T_0}$ 也为正。此检查通过。\n2.  **检查 $S(E)$ 单调性**：$S(E) = \\frac{E-E_0}{T_0} - \\ln T_0$。导数为 $\\frac{dS}{dE} = \\frac{1}{T_0}$。因为 $T_0=1.2 > 0$，$\\frac{dS}{dE}$ 是一个正常数。此检查通过。\n3.  **检查 $T(E) > 0$**：$T(E) = (\\frac{dS}{dE})^{-1} = T_0 = 1.2 \\, \\mathrm{MeV}$。这是正的，所以检查通过。\n4.  **检查 $C(E) \\ge 0$ ($\\frac{dT}{dE} \\ge 0$)**：由于 $T(E)$ 是一个常数，其导数 $\\frac{dT}{dE} = 0$。这满足条件 $\\frac{dT}{dE} \\ge 0$。此检查通过。\n测试用例 2 的预期结果是 **True**。\n\n**测试用例 3：振荡调制的指数模型**\n- 能级密度：$\\rho(E) = \\exp(\\alpha E)\\left[1 + \\epsilon \\sin(k E)\\right]$。\n- 参数：$\\alpha = 0.3 \\, \\mathrm{MeV}^{-1}$，$\\epsilon = 0.9$，$k = 1.0 \\, \\mathrm{MeV}^{-1}$。\n- 网格：$E \\in [1.0, 30.0] \\, \\mathrm{MeV}$，$\\Delta E = 0.05 \\, \\mathrm{MeV}$。\n- 检查区间：$E \\ge E_{\\mathrm{check}} = 1.0 \\, \\mathrm{MeV}$。\n\n1.  **检查 $\\rho(E) > 0$**：我们需要 $1 + \\epsilon \\sin(k E) > 0$。当 $\\epsilon = 0.9$ 时，$1 + 0.9 \\sin(k E)$ 这一项总是在 $1 - 0.9 = 0.1$ 和 $1 + 0.9 = 1.9$ 之间，因此始终为正。此检查通过。\n2.  **检查 $S(E)$ 单调性 ($\\frac{dS}{dE} \\ge 0$)**：$S(E) = \\alpha E + \\ln(1 + \\epsilon \\sin(k E))$。导数为 $\\frac{dS}{dE} = \\alpha + \\frac{\\epsilon k \\cos(k E)}{1 + \\epsilon \\sin(k E)}$。为使此值非负，我们需要 $\\alpha \\ge -\\frac{\\epsilon k \\cos(k E)}{1 + \\epsilon \\sin(k E)}$。当分数项取最负值时，该表达式达到最小值。$\\frac{\\cos(x)}{1+\\epsilon\\sin(x)}$ 的最小值为 $-\\frac{1}{\\sqrt{1-\\epsilon^2}}$。因此我们需要 $\\alpha \\ge \\frac{\\epsilon k}{\\sqrt{1-\\epsilon^2}}$。代入数值：$\\alpha = 0.3$ 而 $\\frac{0.9 \\times 1.0}{\\sqrt{1-0.9^2}} \\approx 2.06$。条件 $0.3 \\ge 2.06$ 是错误的。将存在 $\\frac{dS}{dE}  0$ 的区域。此检查将失败。因此，检查 3 ($T(E) > 0$) 在这些区域也将失败。\n测试用例 3 的预期结果是 **False**。\n\n**测试用例 4：幂律模型**\n- 能级密度：$\\rho(E) = (E - E_c)^p$ 对于 $E > E_c$。\n- 参数：$p = 3.0$，$E_c = 0.5 \\, \\mathrm{MeV}$。\n- 网格：$E \\in [0.6, 20.0] \\, \\mathrm{MeV}$，$\\Delta E = 0.05 \\, \\mathrm{MeV}$。\n- 检查区间：$E \\ge E_{\\mathrm{check}} = 0.6 \\, \\mathrm{MeV}$。\n\n1.  **检查 $\\rho(E) > 0$**：网格从 $E = 0.6 \\, \\mathrm{MeV}$ 开始，大于 $E_c = 0.5 \\, \\mathrm{MeV}$。所以 $(E - E_c)$ 始终为正，$\\rho(E)$ 也为正。此检查通过。\n2.  **检查 $S(E)$ 单调性**：$S(E) = p \\ln(E - E_c)$。导数为 $\\frac{dS}{dE} = \\frac{p}{E-E_c}$。给定 $p=3.0>0$ 且 $E>E_c$，$\\frac{dS}{dE}$ 始终为正。此检查通过。\n3.  **检查 $T(E) > 0$**：由于 $\\frac{dS}{dE} > 0$，$T(E) = (\\frac{dS}{dE})^{-1} = \\frac{E-E_c}{p}$ 在网格上始终为正。此检查通过。\n4.  **检查 $C(E) \\ge 0$ ($\\frac{dT}{dE} \\ge 0$)**：温度的导数是 $\\frac{dT}{dE} = \\frac{1}{p}$。当 $p=3.0$ 时，这是一个正常数 $\\frac{1}{3}$。这满足条件，所以检查通过。\n测试用例 4 的预期结果是 **True**。\n\n最终的实现将把此逻辑编码，并生成总结性的布尔值列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of validating thermodynamic consistency for\n    several nuclear level density models.\n    \"\"\"\n    \n    # Numerical tolerance for inequality checks.\n    tolerance = 1e-8\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Back-shifted Fermi-gas\",\n            \"rho_func\": lambda E, A, a, delta: A * np.exp(2 * np.sqrt(a * (E - delta))) / (E - delta)**(5/4),\n            \"params\": {\"A\": 1e-9, \"a\": 6.0, \"delta\": 0.5},\n            \"E_min\": 1.0, \"E_max\": 30.0, \"dE\": 0.05,\n            \"E_check\": 1.5,\n        },\n        {\n            \"name\": \"Constant-temperature\",\n            \"rho_func\": lambda E, T0, E0: (1/T0) * np.exp((E - E0) / T0),\n            \"params\": {\"T0\": 1.2, \"E0\": 0.0},\n            \"E_min\": 0.0, \"E_max\": 30.0, \"dE\": 0.05,\n            \"E_check\": 0.0,\n        },\n        {\n            \"name\": \"Oscillatory-modulated exponential\",\n            \"rho_func\": lambda E, alpha, epsilon, k: np.exp(alpha * E) * (1 + epsilon * np.sin(k * E)),\n            \"params\": {\"alpha\": 0.3, \"epsilon\": 0.9, \"k\": 1.0},\n            \"E_min\": 1.0, \"E_max\": 30.0, \"dE\": 0.05,\n            \"E_check\": 1.0,\n        },\n        {\n            \"name\": \"Power-law\",\n            \"rho_func\": lambda E, p, Ec: (E - Ec)**p,\n            \"params\": {\"p\": 3.0, \"Ec\": 0.5},\n            \"E_min\": 0.6, \"E_max\": 20.0, \"dE\": 0.05,\n            \"E_check\": 0.6,\n        },\n    ]\n\n    def check_consistency(case_data):\n        \"\"\"\n        Performs the four consistency checks for a given level density model.\n        Returns True if all checks pass, False otherwise.\n        \"\"\"\n        E_min, E_max, dE = case_data[\"E_min\"], case_data[\"E_max\"], case_data[\"dE\"]\n        num_points = int(round((E_max - E_min) / dE)) + 1\n        E_grid = np.linspace(E_min, E_max, num_points)\n\n        # Calculate rho(E) on the grid\n        try:\n            # Use np.errstate to handle potential warnings from log/sqrt of small numbers\n            with np.errstate(all='raise'):\n                 rho_vals = case_data[\"rho_func\"](E_grid, **case_data[\"params\"])\n        except (FloatingPointError, ValueError):\n            # A numerical error here (e.g., sqrt of negative) implies a domain violation.\n            return False\n\n        # Check 1: rho(E) > 0\n        if not np.all(rho_vals > 0):\n            return False\n            \n        # Calculate S(E) = ln(rho(E))\n        # This is safe because we just checked rho > 0\n        S_vals = np.log(rho_vals)\n        \n        # Calculate dS/dE\n        dS_dE = np.gradient(S_vals, dE)\n\n        # Check 2: S(E) is monotonically non-decreasing (dS/dE >= 0)\n        if not np.all(dS_dE >= -tolerance):\n            return False\n            \n        # Check 3: T(E) > 0. This implies dS/dE > 0.\n        # If dS/dE is zero or negative, T is ill-defined or negative.\n        # A small positive threshold is used to avoid division by zero.\n        if not np.all(dS_dE > tolerance): # Using tolerance as strict lower bound\n            return False\n\n        # Calculate T(E) = (dS/dE)^-1\n        T_vals = 1.0 / dS_dE\n\n        # Calculate dT/dE\n        dT_dE = np.gradient(T_vals, dE)\n\n        # Check 4: No negative heat capacity in the check regime (dT/dE >= 0)\n        check_regime_mask = E_grid >= case_data[\"E_check\"]\n        if not np.all(dT_dE[check_regime_mask] >= -tolerance):\n            return False\n\n        # If all checks pass\n        return True\n\n    results = []\n    for case in test_cases:\n        is_consistent = check_consistency(case)\n        results.append(is_consistent)\n\n    # Final print statement in the exact required format.\n    print(f\"[{'True' if results[0] else 'False'},{'True' if results[1] else 'False'},{'True' if results[2] else 'False'},{'True' if results[3] else 'False'}]\".replace(\"'\", \"\"))\n\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}