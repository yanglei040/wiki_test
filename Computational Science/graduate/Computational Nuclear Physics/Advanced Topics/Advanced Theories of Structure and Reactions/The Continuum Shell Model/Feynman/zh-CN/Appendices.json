{
    "hands_on_practices": [
        {
            "introduction": "在进行任何壳模型计算之前，首要任务是明确定义计算所用的希尔伯特空间。在连续谱壳模型 (CSM) 中，这个空间由 Berggren 基构成，它独到地包含了束缚态、共振态和连续散射态。这项练习 () 是一个基础的组合学问题，它将 Berggren 基的理论概念与确定多体模型空间维度的实际需求联系起来，而后者是任何数值计算的关键前提。",
            "id": "3597504",
            "problem": "考虑一个惰性核芯外的价中子数为 $2$ 的系统，采用连续谱壳模型 (CSM)，也称为伽莫夫壳模型 (GSM)。假设平均场是球对称的，因此单粒子态由轨道角动量 $l$、总角动量 $j$ 及其投影 $m$ 标记。单粒子基是在 Berggren 系综中构建的，其单粒子能量截断为 $E_{\\max}$，包含以下分波中所有低于 $E_{\\max}$ 的极点态（束缚态或共振态）：$s_{1/2}$、$p_{1/2}$、$p_{3/2}$、$d_{3/2}$ 和 $d_{5/2}$。具体来说，在此截断范围内，有 $1$ 个 $s_{1/2}$ 束缚极点、$1$ 个 $d_{5/2}$ 束缚极点和 $1$ 个 $p_{3/2}$ 共振极点；在所列出的通道中，没有其他低于 $E_{\\max}$ 的极点。对于每个列出的分波，非共振散射连续谱沿着一条围线被离散化为恰好 $N_c$ 个径向散射态，每个分波的径向散射态数量相同。在 $(l,j)$ 通道中的每个径向态都具有其完整的磁简并度 $(2j+1)$。\n\n忽略质心考虑以及对双中子系统的总角动量或宇称的任何限制。使用上述空间中的所有单粒子态，为这 $2$ 个中子构建由反对称化 Slater 行列式组成的 M-方案多体基。从泡利不相容原理和单粒子磁子态的初等计数出发，推导总基矢维度 $D(N_c)$ 作为 $N_c$ 函数的闭式表达式。你的最终答案必须是单一的解析表达式。不要进行任何数值近似或四舍五入；不需要单位。",
            "solution": "该问题要求在连续谱壳模型框架内定义的一个特定单粒子空间下，推导双中子多体 M-方案基的总维度的闭式表达式。\n\n验证问题陈述的有效性是必须的第一步。\n\n### 步骤 1：提取给定条件\n- 系统：惰性核芯外的 $2$ 个价中子。\n- 模型：连续谱壳模型 (CSM) / 伽莫夫壳模型 (GSM)。\n- 平均场：球对称。\n- 单粒子态由 $(l, j, m)$ 标记。\n- 单粒子基：Berggren 系综，能量截断上限为 $E_{\\max}$。\n- 包含的分波：$s_{1/2}$、$p_{1/2}$、$p_{3/2}$、$d_{3/2}$ 和 $d_{5/2}$。\n- 低于 $E_{\\max}$ 的极点态：\n  - $1$ 个 $s_{1/2}$ 束缚极点。\n  - $1$ 个 $d_{5/2}$ 束缚极点。\n  - $1$ 个 $p_{3/2}$ 共振极点。\n- 非共振连续谱态：\n  - 对于每个列出的分波，离散化为恰好 $N_c$ 个径向散射态。\n- 简并度：在 $(l,j)$ 通道中的每个径向态具有 $(2j+1)$ 的磁简并度。\n- 多体基：针对 $2$ 个中子的反对称化 Slater 行列式（M-方案）。\n- 需忽略的约束：质心考虑、对总角动量的限制以及对宇称的限制。\n- 目标：推导总基矢维度 $D(N_c)$ 的闭式表达式。\n\n### 步骤 2：使用提取的给定条件进行验证\n根据既定标准对问题进行评估。\n- **科学依据**：该问题设定在连续谱壳模型（或伽莫夫壳模型）的标准理论框架内，这是一种在计算核物理中描述弱束缚和非束缚核的成熟方法。Berggren 系综、单粒子态、极点态（束缚和共振）、离散化连续谱、M-方案基和 Slater 行列式等概念都是基础且科学合理的。\n- **问题明确**：问题定义清晰。它指定了粒子数（$2$ 个中子），构建多体基所依据的完整单粒子空间，以及构建基的方法（M-方案）。目标是找到总维度，这是一个唯一定义的量。所有必要信息均已提供。\n- **客观性**：问题使用核物理领域通用的精确技术语言陈述。没有主观或含糊不清的术语。\n\n该问题不存在科学不合理、不完整、矛盾或含糊不清等任何缺陷。它代表了核结构理论中一个标准的、尽管是简化了的组合问题。\n\n### 步骤 3：结论与行动\n问题有效。将提供一个合理的解答。\n\n问题要求计算一个由 $N=2$ 个相同费米子（中子）组成的系统的 M-方案基的总维度。多体基是由一组跨越特定模型空间的单粒子态构建的。在 M-方案中，一个基矢态是通过占据一组唯一的单粒子态而形成的 Slater 行列式。这种态的总数，即多体空间的维度，等于从可用的单粒子态总数 $N_{sp}$ 中选择 $N$ 个不同单粒子态的方法数。\n\n这是一个经典的组合问题，维度 $D$ 由二项式系数给出：\n$$\nD = \\binom{N_{sp}}{N}\n$$\n鉴于我们有 $N=2$ 个中子，维度为：\n$$\nD(N_c) = \\binom{N_{sp}}{2} = \\frac{N_{sp}(N_{sp}-1)}{2}\n$$\n核心任务是确定单粒子态的总数 $N_{sp}$，作为 $N_c$ 的函数。单粒子空间由极点态和离散化的连续谱态组成。每个态都由其量子数表征，包括磁投影量子数 $m$，对于总角动量为 $j$ 的态， $m$ 可以取 $2j+1$ 个值。\n\n首先，我们计算由极点态贡献的磁子态数量。\n- $1$ 个 $s_{1/2}$ 束缚极点：对于此态，$j=1/2$。磁子态的数量为 $2j+1 = 2(1/2) + 1 = 2$。\n- $1$ 个 $d_{5/2}$ 束缚极点：对于此态，$j=5/2$。磁子态的数量为 $2j+1 = 2(5/2) + 1 = 6$。\n- $1$ 个 $p_{3/2}$ 共振极点：对于此态，$j=3/2$。磁子态的数量为 $2j+1 = 2(3/2) + 1 = 4$。\n\n来自极点态的单粒子态总数 $N_{\\text{poles}}$ 是这些简并度的总和：\n$$\nN_{\\text{poles}} = 2 + 6 + 4 = 12\n$$\n接下来，我们计算由离散化的非共振连续谱贡献的磁子态数量。问题陈述中指出，对于每个指定的分波，有 $N_c$ 个径向散射态。我们必须对所有这些分波的贡献求和。\n- $s_{1/2}$ 连续谱：$j=1/2$，因此每个径向态的简并度为 $2j+1=2$。总态数：$N_c \\times 2 = 2N_c$。\n- $p_{1/2}$ 连续谱：$j=1/2$，因此每个径向态的简并度为 $2j+1=2$。总态数：$N_c \\times 2 = 2N_c$。\n- $p_{3/2}$ 连续谱：$j=3/2$，因此每个径向态的简并度为 $2j+1=4$。总态数：$N_c \\times 4 = 4N_c$。\n- $d_{3/2}$ 连续谱：$j=3/2$，因此每个径向态的简并度为 $2j+1=4$。总态数：$N_c \\times 4 = 4N_c$。\n- $d_{5/2}$ 连续谱：$j=5/2$，因此每个径向态的简并度为 $2j+1=6$。总态数：$N_c \\times 6 = 6N_c$。\n\n来自连续谱的单粒子态总数 $N_{\\text{cont}}$ 是这些贡献的总和：\n$$\nN_{\\text{cont}} = 2N_c + 2N_c + 4N_c + 4N_c + 6N_c = (2+2+4+4+6)N_c = 18N_c\n$$\n单粒子态的总数 $N_{sp}$ 是极点态和连续谱态贡献的总和：\n$$\nN_{sp} = N_{\\text{poles}} + N_{\\text{cont}} = 12 + 18N_c\n$$\n现在我们可以将 $N_{sp}$ 的这个表达式代入双粒子维度 $D(N_c)$ 的公式中：\n$$\nD(N_c) = \\frac{N_{sp}(N_{sp}-1)}{2} = \\frac{(12 + 18N_c)((12 + 18N_c) - 1)}{2}\n$$\n$$\nD(N_c) = \\frac{(12 + 18N_c)(11 + 18N_c)}{2}\n$$\n我们可以从分子中的第一项中分解出因子 $2$：\n$$\nD(N_c) = \\frac{2(6 + 9N_c)(11 + 18N_c)}{2} = (6 + 9N_c)(11 + 18N_c)\n$$\n展开这个乘积，得到维度的最终多项式表达式：\n$$\nD(N_c) = 6 \\cdot 11 + 6 \\cdot (18N_c) + (9N_c) \\cdot 11 + (9N_c) \\cdot (18N_c)\n$$\n$$\nD(N_c) = 66 + 108N_c + 99N_c + 162N_c^2\n$$\n合并同类项并按 $N_c$ 的幂次排序，我们得到闭式表达式：\n$$\nD(N_c) = 162N_c^2 + 207N_c + 66\n$$\n这个表达式表示了可以从给定的单粒子 Berggren 基构建的双中子 Slater 行列式的总数，它是每个分波的离散化连续谱态数 $N_c$ 的函数。",
            "answer": "$$\n\\boxed{162N_c^2 + 207N_c + 66}\n$$"
        },
        {
            "introduction": "定义了基矢之后，我们必须在其中进行计算，但处理连续谱部分带来了独特的挑战。Berggren 组合基通过将积分路径变形到复动量平面来巧妙地处理连续谱。这项编程练习 () 将引导您亲手实践连续谱壳模型的核心数值技术，通过实现复动量围道的离散化并观察其收敛性，您将深刻理解连续谱态是如何被实际地整合到量子计算中的。",
            "id": "3597500",
            "problem": "考虑一个在连续壳模型框架下的单体哈密顿量，该哈密顿量在动量表象中表述，并采用 $\\hbar^2/(2\\mu) = 1$ 的单位约定，针对单个分波（s波）。动能算符为 $T$，其本征值为 $k^2$；相互作用为一阶可分势 $V(k,k') = -\\lambda\\, g(k)\\, g(k')$，其中 $g(k) = \\frac{1}{k^2 + \\beta^2}$，$\\lambda > 0$ 和 $\\beta > 0$ 是固定参数。在Gamow壳模型（GSM）中，连续谱通过Berggren系综处理，其中散射态沿着复k平面中的一条复动量围道 $L^+$进行积分。\n\n通过求解齐次动量空间薛定谔方程，可以构建一个能量为 $E < 0$ 的束缚态解。假设一个与势结构兼容的可分拟设，并使用s波的Berggren度规（即复对称积或c-积，不进行复共轭），束缚态能量条件简化为一个关于衰变常数 $\\kappa > 0$ 的自洽方程，该常数由 $E = -\\kappa^2$ 定义。该自洽方程涉及围道积分\n$$\nJ(\\kappa) = \\int_{L^+} \\mathrm{d}k\\, \\frac{k^2}{\\left(k^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k^2\\right)}.\n$$\n$1 - \\lambda J(\\kappa) = 0$ 的一个解 $\\kappa$ 会产生一个能量为 $E = -\\kappa^2$ 的束缚态。相应的（未归一化的）动量空间波函数正比于\n$$\n\\phi(k) \\propto \\frac{g(k)}{E - k^2} = -\\frac{1}{\\left(k^2 + \\beta^2\\right)\\left(\\kappa^2 + k^2\\right)}.\n$$\n在Berggren度规中，这个未归一化态的模方为\n$$\nS(\\kappa) = \\int_{L^+} \\mathrm{d}k\\, \\frac{k^2}{\\left(k^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k^2\\right)^2},\n$$\n这是一个无量纲量。数值计算通过离散化 $L^+$ 并用求积法近似积分来进行。\n\n您的任务是编写一个完整的、可运行的程序，该程序：\n1. 在复动量平面中构建一个两段式的Berggren围道 $L^+$：\n   - 第一段：沿实轴从 $k = 0$到 $k = k_{\\mathrm{peak}}$。\n   - 第二段：从 $k = k_{\\mathrm{peak}}$ 到 $k = k_{\\max}$，沿着一条向下半平面旋转角度 $\\theta$（以度为单位指定）的直线，即在该段的末端，$k = k_{\\mathrm{peak}} + (k_{\\max} - k_{\\mathrm{peak}}) e^{-i\\theta}$。\n2. 使用高斯-勒让德求积法离散化每个线段，并包含每个线段参数化的雅可比行列式 $\\mathrm{d}k/\\mathrm{d}s$。\n3. 对于给定的参数集，在一个实数区间上使用求根算法求解 $\\kappa$，使得 $1 - \\lambda J(\\kappa) = 0$ 成立，其中 $J(\\kappa)$ 使用离散化方法沿 $L^+$ 计算。\n4. 使用相同的围道离散化方法计算束缚态能量 $E = -\\kappa^2$ 和未归一化的Berggren模方 $S(\\kappa)$。\n5. 为指定的测试套件生成单行输出，包含结果列表，其中每个结果都是一个由浮点数组成的二元列表 $[E, S]$。\n\n基本出发点：\n- 动量空间薛定谔方程 $(E - k^2) \\phi(k) = \\int \\mathrm{d}k' \\, k'^2 \\, V(k,k') \\, \\phi(k')$，其中s波动能为 $k^2$。\n- 一阶可分势 $V(k,k') = -\\lambda g(k) g(k')$，其中 $g(k) = \\frac{1}{k^2 + \\beta^2}$。\n- s波的Berggren系综完备性与c-积，这使得使用复围道 $L^+$ 积分处理散射贡献和Gamow态是合法的。\n\n角度单位说明：旋转角 $\\theta$ 必须以度为单位解释。\n\n单位：\n- 所有动量 $k$、衰变常数 $\\kappa$ 以及参数 $\\beta$、$k_{\\mathrm{peak}}$、$k_{\\max}$ 都采用与 $\\hbar^2/(2\\mu) = 1$ 一致的逆长度单位。\n- 能量 $E$ 必须以这些相同的自然单位表示，并且输出应将能量值呈现为浮点数。\n- 模方 $S$ 是无量纲的，应呈现为浮点数。\n\n测试套件：\n在所有测试中，对相互作用和围道形状使用以下固定参数：\n- $\\lambda = 10.0$ (无量纲耦合强度)。\n- $\\beta = 1.0$ (逆长度)。\n- $k_{\\mathrm{peak}} = 2.0$ (逆长度)。\n- $\\theta = 30$ (度)。\n\n通过改变离散化密度和 $k_{\\max}$ 来展示收敛性：\n- 测试用例 A：总共 $N = 40$ 个求积点，$k_{\\max} = 4.0$。\n- 测试用例 B：总共 $N = 80$ 个求积点，$k_{\\max} = 8.0$。\n- 测试用例 C：总共 $N = 160$ 个求积点，$k_{\\max} = 12.0$。\n- 测试用例 D：总共 $N = 160$ 个求积点，$k_{\\max} = 8.0$。\n- 测试用例 E：总共 $N = 80$ 个求积点，$k_{\\max} = 12.0$。\n\n算法要求：\n- 高斯-勒让德节点 $s_i \\in [-1,1]$ 和权重 $w_i$ 必须通过 $k(s) = \\frac{z_1 + z_0}{2} + \\frac{z_1 - z_0}{2} s$ 映射到每个围道线段，并使用复雅可比行列式 $\\frac{\\mathrm{d}k}{\\mathrm{d}s} = \\frac{z_1 - z_0}{2}$，其中 $z_0$ 和 $z_1$ 是线段的复数端点。\n- 沿 $L^+$ 的积分通过对所有线段求和 $\\sum_i w_i \\frac{\\mathrm{d}k}{\\mathrm{d}s} f(k(s_i))$ 来近似，并保留复数权重。为确保得到实值能量解，在构建 $J(\\kappa)$ 和 $S(\\kappa)$ 时，应取计算出的积分的实部，以消除由离散化引起的微小数值虚部。\n\n最终输出：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例一个条目，每个条目本身是一个二元列表 $[E, S]$。例如：\n\"[[E_A,S_A],[E_B,S_B],[E_C,S_C],[E_D,S_D],[E_E,S_E]]\"\n其中每个 $E$ 是计算出的以自然单位表示的束缚态能量，每个 $S$ 是无量纲的未归一化Berggren模方。\n\n程序必须是自包含的，并且不得读取任何输入；它必须使用上面提供的参数，计算五个测试用例的结果，并严格按照指定格式打印最终列表。",
            "solution": "我们从单个s波分量的动量空间薛定谔方程开始，单位制为 $\\hbar^2/(2\\mu) = 1$：\n$$\n(E - k^2) \\phi(k) = \\int_0^\\infty \\mathrm{d}k'\\, k'^2 \\, V(k,k') \\, \\phi(k').\n$$\n我们使用一阶可分势 $V(k,k') = -\\lambda g(k) g(k')$，其中 $g(k) = \\frac{1}{k^2 + \\beta^2}$，$\\lambda>0$ 和 $\\beta>0$ 是固定参数。对于一个束缚态 $E0$，采用与势兼容的可分拟设，\n$$\n\\phi(k) = A \\frac{g(k)}{E - k^2},\n$$\n代入齐次方程得到\n$$\nA = -\\lambda A \\int_0^\\infty \\mathrm{d}k' \\, k'^2 \\, \\frac{g^2(k')}{E - k'^2}.\n$$\n假设 $A \\neq 0$，能量条件为\n$$\n1 = -\\lambda \\int_0^\\infty \\mathrm{d}k'\\, k'^2 \\frac{g^2(k')}{E - k'^2}.\n$$\n对于束缚态，令 $E = -\\kappa^2$，其中 $\\kappa0$。则 $E - k'^2 = -(\\kappa^2 + k'^2)$，积分变为\n$$\n\\int_0^\\infty \\mathrm{d}k' \\, k'^2 \\frac{g^2(k')}{E - k'^2} = -\\int_0^\\infty \\mathrm{d}k' \\, \\frac{k'^2}{(k'^2 + \\beta^2)^2 (\\kappa^2 + k'^2)}.\n$$\n因此，束缚态条件是\n$$\n1 = \\lambda \\int_0^\\infty \\mathrm{d}k \\, \\frac{k^2}{(k^2 + \\beta^2)^2 (\\kappa^2 + k^2)} \\equiv \\lambda J(\\kappa),\n$$\n这里我们定义了\n$$\nJ(\\kappa) = \\int_0^\\infty \\mathrm{d}k \\, \\frac{k^2}{(k^2 + \\beta^2)^2 (\\kappa^2 + k^2)}.\n$$\n在Gamow壳模型（GSM）中，散射态和Gamow态使用Berggren系综进行处理，将实轴积分替换为复k平面中的一条围道 $L^+$。该围道包含一段沿实轴延伸至 $k_{\\mathrm{peak}}$ 的线段，然后是一段旋转进入复平面的直线段，其端点为 $k_{\\mathrm{peak}} + (k_{\\max} - k_{\\mathrm{peak}}) e^{-i\\theta}$（其中 $\\theta > 0$）。使用c-积（复对称内积），因此在计算模方或矩阵元时，积分中不应用复共轭。在解析性和衰减条件下，沿 $L^+$ 的积分等于原始的实轴积分，但在数值上我们通过离散化 $L^+$ 来近似这些量：\n$$\nJ(\\kappa) \\approx \\sum_{i} w_i \\frac{\\mathrm{d}k}{\\mathrm{d}s}\\Big|_{s=s_i} \\frac{k(s_i)^2}{\\left(k(s_i)^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k(s_i)^2\\right)},\n$$\n其中每个线段由 $k(s) = \\frac{z_1 + z_0}{2} + \\frac{z_1 - z_0}{2} s$ 参数化，其中 $s \\in [-1,1]$，端点为 $z_0$ 和 $z_1$，节点和权重为高斯-勒让德节点 $s_i$ 和权重 $w_i$。雅可比因子 $\\frac{\\mathrm{d}k}{\\mathrm{d}s} = \\frac{z_1 - z_0}{2}$ 对于旋转线段是复数。尽管对于 $\\kappa0$ 精确积分是实数，但沿复数围道的离散化会引入一个微小的虚部；取求积和的实部可以得到一个适合求根的实值近似：\n$$\n\\operatorname{Re}\\, J(\\kappa) \\approx \\operatorname{Re}\\left( \\sum_{i} w_i \\frac{\\mathrm{d}k}{\\mathrm{d}s}\\Big|_{s=s_i} \\frac{k(s_i)^2}{\\left(k(s_i)^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k(s_i)^2\\right)} \\right).\n$$\n我们通过求解标量非线性方程来找到 $\\kappa$\n$$\nf(\\kappa) \\equiv 1 - \\lambda\\, \\operatorname{Re}\\, J(\\kappa) = 0,\n$$\n求解区间为 $[\\kappa_{\\min}, \\kappa_{\\max}]$，其中 $\\kappa_{\\min} \\ll 1$ 且 $\\kappa_{\\max}$ 足够大（例如，与 $k_{\\max}$ 同阶）。被积函数在 $k=0$ 处表现良好，并在 $k$ 很大时以 $k^{-4}$ 的速度衰减，确保了收敛性。\n\n一旦求得 $\\kappa$，束缚态能量即为 $E = -\\kappa^2$。为了评估态归一化的收敛性，我们计算未归一化的Berggren模方\n$$\nS(\\kappa) \\equiv \\int_{L^+} \\mathrm{d}k\\, \\frac{k^2}{\\left(k^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k^2\\right)^2} \\approx \\operatorname{Re}\\left( \\sum_{i} w_i \\frac{\\mathrm{d}k}{\\mathrm{d}s}\\Big|_{s=s_i} \\frac{k(s_i)^2}{\\left(k(s_i)^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k(s_i)^2\\right)^2} \\right),\n$$\n这是一个无量纲量。如果通过选择一个前置因子 $A$ 使得在c-积中 $\\int_{L^+} \\mathrm{d}k\\, k^2\\, \\phi(k)^2 = 1$ 来归一化该态，则 $A = 1/\\sqrt{S(\\kappa)}$。然而，这里我们直接报告 $S(\\kappa)$ 的值，以展示数值收敛行为。\n\n算法步骤：\n1. 构建具有两段的围道 $L^+$：\n   - 第一段：$z_0^{(1)} = 0$, $z_1^{(1)} = k_{\\mathrm{peak}}$ (均为实数)。\n   - 第二段：$z_0^{(2)} = k_{\\mathrm{peak}}$, $z_1^{(2)} = k_{\\mathrm{peak}} + (k_{\\max} - k_{\\mathrm{peak}}) e^{-i\\theta}$，其中 $\\theta$ 以度为单位，需转换为弧度。\n2. 对于给定的总求积点数 $N$，将其分为第一段上的 $N_1 = \\lfloor N/2 \\rfloor$ 个点和第二段上的 $N_2 = N - N_1$ 个点。对每个线段，获取高斯-勒让德节点和权重 $\\{s_i,w_i\\}$，并将其映射到复动量 $k_i$ 和复权重 $W_i = w_i\\, \\frac{z_1 - z_0}{2}$。\n3. 将函数 $J(\\kappa)$ 和 $S(\\kappa)$ 定义为相应被积函数的复加权和，并取其实部。\n4. 在一个区间如 $[\\kappa_{\\min}, \\kappa_{\\max}] = [10^{-6}, k_{\\max}]$ 上对 $f(\\kappa) = 1 - \\lambda \\operatorname{Re} J(\\kappa)$ 使用稳健的区间求根方法；确保 $f(\\kappa_{\\min})  0$ 和 $f(\\kappa_{\\max}) > 0$（对于足够大的 $\\lambda$ 的吸引势，如所提供的测试参数，此条件成立）。\n5. 计算 $E = -\\kappa^2$，并评估 $S(\\kappa)$。\n6. 对每个具有不同 $N$ 和 $k_{\\max}$ 的测试用例重复步骤2-5，以展示当离散化密度和 $k_{\\max}$ 变化时 $E$ 和 $S$ 的收敛性。\n\n解析参考：\n对于所选的可分势形式，沿实轴的积分 $J(\\kappa)$ 可以通过部分分式法得到一个闭合形式的表达式：\n$$\nJ(\\kappa) = \\int_0^\\infty \\mathrm{d}k \\, \\frac{k^2}{(k^2 + \\beta^2)^2 (\\kappa^2 + k^2)}\n= \\frac{\\pi}{2\\beta} \\frac{\\kappa^2}{(\\kappa^2 - \\beta^2)^2} - \\frac{\\pi}{4\\beta} \\frac{1}{\\kappa^2 - \\beta^2} - \\frac{\\pi}{2} \\frac{\\kappa}{(\\kappa^2 - \\beta^2)^2},\n$$\n这可以用来通过在实轴上求解 $1 = \\lambda J(\\kappa)$ 来验证数值解。在实践中，随着点数和 $k_{\\max}$ 的增加，这里使用的复围道离散化方法会再现这个结果。\n\n输出：\n对于每个测试用例A-E，程序输出一对 $[E,S]$，其中 $E$ 是以自然单位表示的束缚态能量， $S$ 是无量纲的未归一化Berggren模方。最终输出为单行：\n\"[[E_A,S_A],[E_B,S_B],[E_C,S_C],[E_D,S_D],[E_E,S_E]]\"。\n\n此设计将基础的薛定谔方程与Berggren系综离散化相结合，以展示在连续壳模型框架下的收敛行为。",
            "answer": "```python\n# Python 3.12\n# Libraries: numpy 1.23.5, scipy 1.11.4\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\nfrom scipy.optimize import root_scalar\n\ndef build_contour(k_peak, k_max, theta_deg, N_total):\n    \"\"\"\n    Construct L^+ with two segments:\n      Segment 1: 0 - k_peak (real axis)\n      Segment 2: k_peak - k_peak + (k_max - k_peak) * exp(-i * theta)\n    Returns arrays of complex k points and complex quadrature weights W_i.\n    \"\"\"\n    # Convert angle to radians\n    theta = np.deg2rad(theta_deg)\n\n    # Segment endpoints\n    z0_1 = 0.0 + 0.0j\n    z1_1 = complex(k_peak, 0.0)\n    z0_2 = complex(k_peak, 0.0)\n    z1_2 = complex(k_peak, 0.0) + (k_max - k_peak) * np.exp(-1j * theta)\n\n    # Split total points between segments\n    N1 = N_total // 2\n    N2 = N_total - N1\n    if N1  2:  # minimal points per segment to avoid pathological quadrature\n        N1 = 2\n        N2 = max(2, N_total - N1)\n\n    # Gauss-Legendre nodes and weights on [-1,1]\n    s1, w1 = leggauss(N1)\n    s2, w2 = leggauss(N2)\n\n    # Map nodes to segment 1\n    dkds_1 = (z1_1 - z0_1) / 2.0\n    k1 = (z1_1 + z0_1) / 2.0 + dkds_1 * s1\n    W1 = w1 * dkds_1\n\n    # Map nodes to segment 2\n    dkds_2 = (z1_2 - z0_2) / 2.0\n    k2 = (z1_2 + z0_2) / 2.0 + dkds_2 * s2\n    W2 = w2 * dkds_2\n\n    # Concatenate\n    k_points = np.concatenate([k1, k2])\n    weights = np.concatenate([W1, W2])\n\n    return k_points, weights\n\ndef J_discrete(kappa, beta, k_points, weights):\n    \"\"\"\n    Compute J(kappa) = ∫_{L+} dk k^2/[(k^2+beta^2)^2 (kappa^2 + k^2)]\n    using complex quadrature along L^+.\n    Returns the real part of the quadrature sum to mitigate small numerical Im parts.\n    \"\"\"\n    k = k_points\n    W = weights\n    k2 = k * k\n    denom1 = (k2 + beta**2)\n    integrand = (k2) / (denom1 * denom1 * (kappa**2 + k2))\n    val = np.sum(W * integrand)\n    return float(np.real(val))\n\ndef S_discrete(kappa, beta, k_points, weights):\n    \"\"\"\n    Compute S(kappa) = ∫_{L+} dk k^2/[(k^2+beta^2)^2 (kappa^2 + k^2)^2]\n    using complex quadrature along L^+.\n    Returns the real part of the quadrature sum.\n    \"\"\"\n    k = k_points\n    W = weights\n    k2 = k * k\n    denom1 = (k2 + beta**2)\n    integrand = (k2) / (denom1 * denom1 * (kappa**2 + k2) * (kappa**2 + k2))\n    val = np.sum(W * integrand)\n    return float(np.real(val))\n\ndef solve_case(N_total, k_max, lambda_cpl, beta, k_peak, theta_deg):\n    \"\"\"\n    For given discretization and contour parameters, solve for kappa via\n    1 - lambda * J(kappa) = 0, then compute energy E = -kappa^2 and norm S(kappa).\n    \"\"\"\n    # Build contour points and weights\n    k_points, weights = build_contour(k_peak, k_max, theta_deg, N_total)\n\n    # Define objective function f(kappa) = 1 - lambda * J(kappa)\n    def f(kappa):\n        return 1.0 - lambda_cpl * J_discrete(kappa, beta, k_points, weights)\n\n    # Choose a bracket [kappa_min, kappa_max] with f(kappa_min)  0 and f(kappa_max) > 0\n    # For attractive potential and sufficient strength, this holds with small kappa_min and larger kappa_max.\n    kappa_min = 1e-6\n    kappa_max_bracket = max(2.0 * beta, k_max)  # ensure upper bound reasonably large\n    # Ensure bracket signs; if not, expand kappa_max_bracket multiplicatively\n    fmin = f(kappa_min)\n    fmax = f(kappa_max_bracket)\n    expand_factor = 2.0\n    attempts = 0\n    while fmin >= 0.0 and attempts  10:\n        # If f(kappa_min) is not negative, reduce it further\n        kappa_min *= 0.1\n        fmin = f(kappa_min)\n        attempts += 1\n    attempts = 0\n    while fmax = 0.0 and attempts  10:\n        kappa_max_bracket *= expand_factor\n        fmax = f(kappa_max_bracket)\n        attempts += 1\n\n    # Root finding\n    root = root_scalar(f, bracket=[kappa_min, kappa_max_bracket], method='brentq')\n    if not root.converged:\n        # Fallback: try different bracket if needed\n        kappa_guess = beta\n        root = root_scalar(f, x0=kappa_guess, x1=kappa_guess*1.5, method='secant')\n\n    kappa = float(root.root)\n    E = -kappa**2\n\n    # Compute unnormalized Berggren norm S(kappa)\n    S_val = S_discrete(kappa, beta, k_points, weights)\n\n    return E, S_val\n\ndef solve():\n    # Fixed interaction and contour parameters across test cases\n    lambda_cpl = 10.0\n    beta = 1.0\n    k_peak = 2.0\n    theta_deg = 30.0\n\n    # Test suite: (N_total, k_max)\n    test_cases = [\n        (40, 4.0),    # A: coarse N, small k_max\n        (80, 8.0),    # B: medium N, medium k_max\n        (160, 12.0),  # C: fine N, large k_max\n        (160, 8.0),   # D: fine N, medium k_max\n        (80, 12.0),   # E: medium N, large k_max\n    ]\n\n    results = []\n    for N_total, k_max in test_cases:\n        E, S_val = solve_case(N_total, k_max, lambda_cpl, beta, k_peak, theta_deg)\n        # Append as [E, S] floats\n        results.append([E, S_val])\n\n    # Print as a single line in the exact required format\n    # Ensure default float string representation\n    formatted = \"[\" + \",\".join(f\"[{r[0]},{r[1]}]\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "连续谱壳模型的哈密顿量是非厄米性的，这导致了复数本征值和独特的物理现象。其中一个标志性特征是复能量平面上能级的“避免交叉”现象，这是开放量子系统中组态混合的典型表现。通过这个练习 ()，您将构建并分析一个能够捕捉这一核心物理的简化玩具模型，这项实践有助于揭示复数本征值及其行为的物理意义，从而在抽象的非厄米形式与弱束缚或非束缚核的可观测性质之间建立起一座具体的桥梁。",
            "id": "3597518",
            "problem": "要求您设计并实现一个完整的、可运行的程序，该程序使用一个双能级非厄米玩具模型来模拟连续谱壳模型中粒子发射阈附近的通道耦合和组态混合。此项任务的重点在于推导非厄米性为何以及如何因与粒子连续谱的耦合而产生，它如何在复能量平面中生成避开交叉，以及如何将一个简单模型拟合到代表Gamow壳模型（GSM）的合成复能量数据。\n\n从Feshbach投影形式理论出发，该理论在内禀（闭合）空间中产生一个依赖于能量的有效非厄米哈密顿量。其标准形式如下：\n$$\nH_{\\text{eff}}(E) \\equiv H_{PP} + V_{PQ} \\frac{1}{E^+ - H_{QQ}} V_{QP},\n$$\n其中 $H_{PP}$ 作用于内禀空间，$H_{QQ}$ 作用于连续谱（散射）空间，$V_{PQ}$ 将两者耦合。虚部描述了向连续谱的不可逆衰变，并且在发射阈以下为零。在单粒子阈附近，耗散宽度可由线性化阈值定律近似，主值色散位移可由局部线性斜率近似，从而得到以下针对控制参数 $\\lambda$ 的双能级、窗口内不依赖于能量的参数化模型：\n$$\nH(\\lambda) = \n\\begin{pmatrix}\nE_1 + \\Delta_1(\\lambda) - \\dfrac{i}{2}\\Gamma_1(\\lambda)   V_{12} \\\\\nV_{12}  E_2 + \\Delta_2(\\lambda) - \\dfrac{i}{2}\\Gamma_2(\\lambda)\n\\end{pmatrix},\n$$\n其中\n$$\n\\Gamma_i(\\lambda) = \\gamma_i \\max(\\lambda - \\lambda_{\\text{th},i}, 0), \\qquad \n\\Delta_i(\\lambda) = \\alpha_i \\left(\\lambda - \\lambda_{\\text{th},i}\\right),\n$$\n以及一个复的、不依赖于 $\\lambda$ 的非对角耦合\n$$\nV_{12} \\equiv v_r + i v_i.\n$$\n假设一个复对称有效哈密顿量，使得 $H_{12} = H_{21} = V_{12}$，这是对时间反演不变的开放量子系统的标准近似。可观测的本征值是 $H(\\lambda)$ 的复极点 $z_\\pm(\\lambda)$，写作 $z \\equiv E - \\dfrac{i}{2}\\Gamma$，其中 $E$ 是能量，单位为兆电子伏（MeV），$\\Gamma$ 是衰变宽度，单位为兆电子伏（MeV）。\n\n您的程序必须：\n- 实现上述模型，并通过跟踪分支来计算两个作为 $\\lambda$ 的连续函数的复本征值分支，以避免在复平面上的避开交叉处发生错误标记。应通过沿递增的 $\\lambda$ 逐点匹配本征值来强制实现连续性，以最小化相邻参数点之间的总复数距离。\n- 通过对指定“真实”参数集和控制参数网格的模型进行对角化，生成合成的“类GSM”数据集。数据不包含测量噪声。\n- 对每个数据集，仅通过非线性最小二乘法拟合复数非对角耦合 $V_{12} = v_r + i v_i$，以最小化模型预测分支与合成数据分支之间的复数残差平方和。所有其他参数均为已知且固定的。每个 $\\lambda$ 点的复数残差必须通过堆叠两个分支的实部和虚部来构成。\n- 对每个数据集，报告拟合得到的模 $\\lvert V_{12} \\rvert = \\sqrt{v_r^2 + v_i^2}$，单位为兆电子伏（MeV），以浮点数形式表示。您的最终输出应以MeV为单位。\n\n使用以下三个数据集（每个数据集定义了一个完整的测试用例）。在所有数据集中，控制参数 $\\lambda$ 是无量纲的，所有能量单位均为兆电子伏（MeV）。\n\n数据集A（一个阈值上方有清晰的避开交叉）：\n- 固定参数：\n  - $E_1 = 0.00$, $E_2 = 0.35$\n  - $\\lambda_{\\text{th},1} = 0.05$, $\\lambda_{\\text{th},2} = 0.25$\n  - $\\alpha_1 = 0.20$, $\\alpha_2 = 0.15$\n  - $\\gamma_1 = 0.40$, $\\gamma_2 = 0.70$\n- 真实耦合：\n  - $V_{12}^{(\\text{true})} = 0.045 - i\\,0.008$\n- 控制网格：\n  - $\\lambda \\in \\{-0.05, 0.00, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45\\}$\n\n数据集B（混合消失的边界情况）：\n- 固定参数：\n  - $E_1 = 0.10$, $E_2 = 0.30$\n  - $\\lambda_{\\text{th},1} = 0.05$, $\\lambda_{\\text{th},2} = 0.15$\n  - $\\alpha_1 = 0.10$, $\\alpha_2 = 0.10$\n  - $\\gamma_1 = 0.30$, $\\gamma_2 = 0.30$\n- 真实耦合：\n  - $V_{12}^{(\\text{true})} = 0.000 + i\\,0.000$\n- 控制网格：\n  - $\\lambda \\in \\{0.00, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40\\}$\n\n数据集C（阈值附近的近简并情况，具有较大宽度）：\n- 固定参数：\n  - $E_1 = 0.12$, $E_2 = 0.14$\n  - $\\lambda_{\\text{th},1} = 0.11$, $\\lambda_{\\text{th},2} = 0.09$\n  - $\\alpha_1 = 0.25$, $\\alpha_2 = 0.20$\n  - $\\gamma_1 = 0.90$, $\\gamma_2 = 0.60$\n- 真实耦合：\n  - $V_{12}^{(\\text{true})} = 0.030 - i\\,0.020$\n- 控制网格：\n  - $\\lambda \\in \\{0.06, 0.08, 0.10, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22\\}$\n\n数值与输出要求：\n- 不涉及角度。所有能量都必须以兆电子伏（MeV）为单位进行处理和报告。\n- 通过堆叠实部和虚部，使用适用于复数残差的最小二乘法程序。\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。具体来说，它必须打印 \n  $[\\lvert V_{12}^{(A)}\\rvert,\\lvert V_{12}^{(B)}\\rvert,\\lvert V_{12}^{(C)}\\rvert]$ \n  每个值都以MeV为单位，表示为四舍五入到六位小数的十进制浮点数，例如 \n  $[0.123456,0.000000,0.036789]$。\n\n测试套件和覆盖范围基本原理：\n- 数据集A是一个通用情况，当 $\\lambda$ 超过一个阈值时，在复平面上有一个可见的避开交叉，用于测试分支跟踪的鲁棒性和对非零复耦合的敏感性。\n- 数据集B是一个无混合的边界条件，确保拟合器能正确返回接近零的耦合模。\n- 数据集C是一个边缘情况，在阈值附近具有近简并能级和更强的宽度，用于测试拟合的稳定性以及解释由连续谱耦合主导的复杂避开交叉的能力。\n\n您的最终程序必须是完整的、自包含的、无需输入，并且必须完全按照上述规定实现模型、数据生成、拟合和最终报告。唯一允许的外部库是 Numerical Python (NumPy) 和 Scientific Python (SciPy)。最终输出必须是包含上述列表的单行，其值以MeV为单位，并四舍五入到六位小数。",
            "solution": "所提出的问题是计算核物理领域一个有效的练习，具体涉及开放量子系统在衰变阈附近的建模。它在科学上基于Feshbach投影形式理论以及由此产生的非厄米有效哈密顿量，这些是描述共振态和连续谱耦合的标准理论工具。该问题是适定的，为实现、数据生成和参数拟合提供了全套参数和明确的目标。它是客观的、可数学形式化的，并且在计算上是可行的。因此，有必要提供一个完整的解决方案。\n\n该问题的理论基础是描述一组离散的量子态，即内禀或模型空间 $P$，与一个散射态连续谱，即空间 $Q$ 相耦合。在形式上消除了 $Q$ 空间后，支配 $P$ 空间内动力学的有效哈密顿量变得非厄米且依赖于能量。其通用形式为：\n$$\nH_{\\text{eff}}(E) = H_{PP} + V_{PQ} \\frac{1}{E^+ - H_{QQ}} V_{QP}\n$$\n在这里，$H_{PP}$ 是孤立内禀态的哈密顿量，$H_{QQ}$ 描述连续谱，$V_{PQ}$ 代表两个空间之间的耦合。项 $E^+ = E + i\\epsilon$ (其中 $\\epsilon \\to 0^+$) 确保了正确的因果边界条件。第二项，即自能 $\\Sigma(E) = V_{PQ} (E^+ - H_{QQ})^{-1} V_{QP}$，是复数。其反厄米部分 $-i\\text{Im}(\\Sigma(E))$ 产生衰变宽度，代表从 $P$ 空间到 $Q$ 空间的不可逆通量损失。\n\n该问题为这个有效哈密顿量提供了一个简化的、在控制参数 $\\lambda$ 周围的小能量窗口内有效的、不依赖于能量的参数化模型。我们考虑一个双能级系统（$P$ 空间维度为2），得到一个 $2 \\times 2$ 矩阵：\n$$\nH(\\lambda) = \n\\begin{pmatrix}\nE_1 + \\Delta_1(\\lambda) - \\dfrac{i}{2}\\Gamma_1(\\lambda)   V_{12} \\\\\nV_{12}  E_2 + \\Delta_2(\\lambda) - \\dfrac{i}{2}\\Gamma_2(\\lambda)\n\\end{pmatrix}\n$$\n对角元 $H_{ii}(\\lambda) = E_i + \\Delta_i(\\lambda) - \\frac{i}{2}\\Gamma_i(\\lambda)$ 是未耦合“非绝热”态的复能量。$E_i$ 是基准能量。项 $\\Delta_i(\\lambda)$ 和 $\\Gamma_i(\\lambda)$ 分别是由自能产生的依赖于能量的色散位移和衰变宽度。它们对控制参数 $\\lambda$ 的依赖性在粒子发射阈 $\\lambda_{\\text{th},i}$ 附近被线性建模为：\n$$\n\\Gamma_i(\\lambda) = \\gamma_i \\max(\\lambda - \\lambda_{\\text{th},i}, 0)\n$$\n$$\n\\Delta_i(\\lambda) = \\alpha_i \\left(\\lambda - \\lambda_{\\text{th},i}\\right)\n$$\n宽度 $\\Gamma_i$ 仅在阈值以上（$\\lambda  \\lambda_{\\text{th},i}$）才非零，这反映了衰变只有在能量上允许时才可能发生。非对角元 $V_{12} = v_r + i v_i$ 代表两个态之间的有效耦合，由于通过连续谱的“间接”耦合，它本身可以是复数。复对称矩阵（$H_{12}=H_{21}$）的假设对于具有时间反演不变性的系统是标准的。\n\n物理可观测量是 $H(\\lambda)$ 的复本征值，它们对应于S矩阵的极点。我们将其表示为 $z(\\lambda) = E_{\\text{res}} - \\frac{i}{2}\\Gamma_{\\text{width}}$。一个通用复对称 $2 \\times 2$ 矩阵的本征值 $z_\\pm$ 由标准二次公式给出：\n$$\nz_\\pm(\\lambda) = \\frac{H_{11}(\\lambda) + H_{22}(\\lambda)}{2} \\pm \\frac{1}{2}\\sqrt{(H_{11}(\\lambda) - H_{22}(\\lambda))^2 + 4V_{12}^2}\n$$\n随着 $\\lambda$ 的变化，这两个本征值在复能量平面上描绘出连续的分支。当非绝热能量 $H_{11}(\\lambda)$ 和 $H_{22}(\\lambda)$ 相互接近时，本征值表现出“避开交叉”。此时分支间的最小间距由耦合 $V_{12}$ 决定。\n\n计算任务的第一部分是对于给定的参数集和 $\\lambda$ 值网格，计算这些本征值分支。在每个 $\\lambda$ 点使用数值对角化程序（如 `numpy.linalg.eigvals`）会产生一对本征值。然而，它们的默认排序是任意的。为了构建连续的分支，我们必须在每一步 $\\lambda_k$ 对本征值进行排序，以匹配前一步 $\\lambda_{k-1}$ 的顺序。这是通过最小化连续步骤之间本征值的复数距离之和来实现的。给定分支 $z_1(\\lambda_{k-1})$ 和 $z_2(\\lambda_{k-1})$，以及在 $\\lambda_k$ 新计算出的无序本征值 $z'_a$ 和 $z'_b$，我们比较两种可能的分配：\n1. $d_1 = |z_1(\\lambda_{k-1}) - z'_a| + |z_2(\\lambda_{k-1}) - z'_b|$\n2. $d_2 = |z_1(\\lambda_{k-1}) - z'_b| + |z_2(\\lambda_{k-1}) - z'_a|$\n如果 $d_1  d_2$，则分配为 $z_1(\\lambda_k)=z'_a$ 和 $z_2(\\lambda_k)=z'_b$。否则，分配交换。这个过程确保了在任何避开交叉点都能正确跟踪状态。\n\n任务的第二部分是执行参数拟合。我们首先使用已知的“真实”参数集（包括真实的耦合 $V_{12}^{(\\text{true})}$）计算本征值分支，从而生成一个合成的“实验”数据集。然后，假设除了 $V_{12}$ 之外的所有参数都是已知的，我们必须通过将我们的模型拟合到这个合成数据来确定 $V_{12}$。待确定的参数是耦合的实部和虚部，$v_r$ 和 $v_i$。\n\n这是一个非线性最小二乘问题。我们定义一个残差函数，它量化了模型预测（对于一组试验参数 $p = [v_r, v_i]$）与合成数据之间的差异。对于一个试验耦合 $V_{12} = v_r+iv_i$，模型预测是一组本征值分支 $\\{z_{1}^{\\text{model}}(\\lambda_j; p), z_{2}^{\\text{model}}(\\lambda_j; p)\\}$。复数残差是：\n$$\n\\delta_k(\\lambda_j; p) = z_{k}^{\\text{model}}(\\lambda_j; p) - z_{k}^{\\text{data}}(\\lambda_j), \\quad k \\in \\{1, 2\\}\n$$\n对于控制网格中的每个点 $\\lambda_j$。为了使用像 `scipy.optimize.least_squares` 这样对实值向量进行操作的标准优化器，我们通过堆叠所有复数残差的实部和虚部来构造一个单一的残差向量：\n$$\n\\vec{R}(p) = [ \\dots, \\text{Re}(\\delta_1(\\lambda_j)), \\text{Im}(\\delta_1(\\lambda_j)), \\text{Re}(\\delta_2(\\lambda_j)), \\text{Im}(\\delta_2(\\lambda_j)), \\dots ]\n$$\n优化器随后找到参数 $p = [v_r, v_i]$，以最小化该向量元素的平方和 $\\sum_k R_k^2$，这等同于最小化总复数误差平方和 $\\sum_{j,k} |\\delta_k(\\lambda_j; p)|^2$。一旦找到最优的 $v_r$ 和 $v_i$，所需的输出就是模 $|V_{12}| = \\sqrt{v_r^2 + v_i^2}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all datasets.\n    \"\"\"\n\n    # Dataset A (clear avoided crossing above one threshold)\n    case_A = {\n        \"fixed_params\": {\n            \"E1\": 0.00, \"E2\": 0.35,\n            \"lambda_th1\": 0.05, \"lambda_th2\": 0.25,\n            \"alpha1\": 0.20, \"alpha2\": 0.15,\n            \"gamma1\": 0.40, \"gamma2\": 0.70,\n        },\n        \"true_V12\": 0.045 - 0.008j,\n        \"lambda_mesh\": np.array([-0.05, 0.00, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45]),\n    }\n\n    # Dataset B (boundary case with vanishing mixing)\n    case_B = {\n         \"fixed_params\": {\n            \"E1\": 0.10, \"E2\": 0.30,\n            \"lambda_th1\": 0.05, \"lambda_th2\": 0.15,\n            \"alpha1\": 0.10, \"alpha2\": 0.10,\n            \"gamma1\": 0.30, \"gamma2\": 0.30,\n        },\n        \"true_V12\": 0.000 + 0.000j,\n        \"lambda_mesh\": np.array([0.00, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40]),\n    }\n\n    # Dataset C (near-degeneracy near threshold with larger widths)\n    case_C = {\n        \"fixed_params\": {\n            \"E1\": 0.12, \"E2\": 0.14,\n            \"lambda_th1\": 0.11, \"lambda_th2\": 0.09,\n            \"alpha1\": 0.25, \"alpha2\": 0.20,\n            \"gamma1\": 0.90, \"gamma2\": 0.60,\n        },\n        \"true_V12\": 0.030 - 0.020j,\n        \"lambda_mesh\": np.array([0.06, 0.08, 0.10, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22]),\n    }\n\n    test_cases = [case_A, case_B, case_C]\n    results = []\n\n    for case in test_cases:\n        # Generate synthetic data using the true parameters\n        data_branches = calculate_branches(case[\"lambda_mesh\"], case[\"fixed_params\"], case[\"true_V12\"])\n        \n        # Define the residual function for the least-squares fit\n        def residuals(p, lambda_mesh, fixed_params, data_b1, data_b2):\n            \"\"\"\n            Calculates the residual vector for the least-squares fit.\n            p: array [v_r, v_i] of parameters to fit.\n            \"\"\"\n            v_r, v_i = p\n            trial_V12 = v_r + 1j * v_i\n            \n            model_b1, model_b2 = calculate_branches(lambda_mesh, fixed_params, trial_V12)\n            \n            # Calculate complex differences\n            diff1 = model_b1 - data_b1\n            diff2 = model_b2 - data_b2\n\n            # Stack real and imaginary parts into a 1D array\n            return np.concatenate([diff1.real, diff1.imag, diff2.real, diff2.imag])\n\n        # Initial guess for the fit\n        p0 = [0.0, 0.0]\n        \n        # Perform the non-linear least-squares fit\n        fit_result = least_squares(\n            residuals,\n            p0,\n            args=(case[\"lambda_mesh\"], case[\"fixed_params\"], data_branches[0], data_branches[1]),\n            method='lm' # Levenberg-Marquardt is robust for this type of problem\n        )\n        \n        # Extract fitted parameters\n        v_r_fit, v_i_fit = fit_result.x\n        \n        # Calculate the magnitude of the fitted V12\n        v12_magnitude = np.sqrt(v_r_fit**2 + v_i_fit**2)\n        results.append(v12_magnitude)\n\n    # Format and print the final output\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\ndef calculate_branches(lambda_mesh, fixed_params, V12):\n    \"\"\"\n    Calculates the two complex eigenvalue branches for a given lambda mesh.\n    Enforces continuity by minimizing complex distance between points.\n    \"\"\"\n    fp = fixed_params\n    num_lambda = len(lambda_mesh)\n    branch1 = np.zeros(num_lambda, dtype=complex)\n    branch2 = np.zeros(num_lambda, dtype=complex)\n    \n    H = np.zeros((2, 2), dtype=complex)\n    \n    for i, lam in enumerate(lambda_mesh):\n        # Calculate diagonal elements of the Hamiltonian H(lambda)\n        delta1 = fp[\"alpha1\"] * (lam - fp[\"lambda_th1\"])\n        gamma1 = fp[\"gamma1\"] * max(lam - fp[\"lambda_th1\"], 0.0)\n        H[0, 0] = fp[\"E1\"] + delta1 - 0.5j * gamma1\n        \n        delta2 = fp[\"alpha2\"] * (lam - fp[\"lambda_th2\"])\n        gamma2 = fp[\"gamma2\"] * max(lam - fp[\"lambda_th2\"], 0.0)\n        H[1, 1] = fp[\"E2\"] + delta2 - 0.5j * gamma2\n        \n        # Set off-diagonal elements\n        H[0, 1] = H[1, 0] = V12\n        \n        # Get eigenvalues\n        eigvals = np.linalg.eigvals(H)\n        \n        if i == 0:\n            # For the first point, sort by real part as an initial condition\n            if eigvals[0].real  eigvals[1].real:\n                branch1[i] = eigvals[0]\n                branch2[i] = eigvals[1]\n            else:\n                branch1[i] = eigvals[1]\n                branch2[i] = eigvals[0]\n        else:\n            # For subsequent points, sort to maintain continuity\n            prev_b1 = branch1[i-1]\n            prev_b2 = branch2[i-1]\n            \n            # Two possible assignments for the new eigenvalues\n            e1, e2 = eigvals[0], eigvals[1]\n            \n            # Calculate sum of squared distances for both assignments\n            dist_noswap = abs(e1 - prev_b1) + abs(e2 - prev_b2)\n            dist_swap = abs(e2 - prev_b1) + abs(e1 - prev_b2)\n            \n            if dist_noswap  dist_swap:\n                branch1[i] = e1\n                branch2[i] = e2\n            else:\n                branch1[i] = e2\n                branch2[i] = e1\n                \n    return branch1, branch2\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}