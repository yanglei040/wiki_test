{
    "hands_on_practices": [
        {
            "introduction": "The time-dependent Hartree-Fock (TDHF) theory describes the dynamics of a quantum many-body system through the evolution of its one-body density matrix. Before tackling the dynamics, it is crucial to master the foundational concept of how this density matrix is constructed. This exercise  guides you through the fundamental derivation of the one-body density matrix and the local particle density from the system's underlying many-body wavefunction, which in the Hartree-Fock approximation is modeled as a single Slater determinant.",
            "id": "3609611",
            "problem": "Consider a system of $A$ nucleons described in time-dependent Hartree-Fock (TDHF) theory, where the many-body state at a given time is approximated by a single Slater determinant built from $A$ orthonormal spin-isospin orbitals $\\{\\phi_{i}(\\mathbf{r}\\sigma\\tau)\\}_{i=1}^{A}$. Here $\\mathbf{r} \\in \\mathbb{R}^{3}$ is the spatial coordinate, $\\sigma \\in \\{\\uparrow,\\downarrow\\}$ is the spin projection, and $\\tau \\in \\{p,n\\}$ is the isospin label (proton or neutron). The orbitals satisfy the orthonormality condition\n$$\n\\sum_{\\sigma,\\tau}\\int d^{3}r\\, \\phi_{i}^{*}(\\mathbf{r}\\sigma\\tau)\\,\\phi_{j}(\\mathbf{r}\\sigma\\tau) \\;=\\; \\delta_{ij}.\n$$\n  \nStarting from the antisymmetrization postulate for identical fermions and the definition of a Slater determinant in first quantization, construct the normalized $A$-body wavefunction $\\Psi(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{A})$ where $\\mathbf{x}\\equiv(\\mathbf{r},\\sigma,\\tau)$. Using the fundamental definition of the one-body density matrix in first quantization,\n$$\n\\rho(\\mathbf{x},\\mathbf{x}') \\;=\\; A \\sum_{\\sigma_{2},\\tau_{2}}\\cdots \\sum_{\\sigma_{A},\\tau_{A}} \\int d^{3}r_{2}\\cdots d^{3}r_{A}\\;\\Psi(\\mathbf{x},\\mathbf{x}_{2},\\ldots,\\mathbf{x}_{A})\\,\\Psi^{*}(\\mathbf{x}',\\mathbf{x}_{2},\\ldots,\\mathbf{x}_{A}),\n$$\nderive a closed-form expression for the one-body density matrix $\\rho(\\mathbf{r}\\sigma\\tau,\\mathbf{r}'\\sigma'\\tau')$ in terms of the occupied orbitals $\\{\\phi_{i}\\}$. Then obtain the local particle density\n$$\nn(\\mathbf{r}) \\;=\\; \\sum_{\\sigma,\\tau}\\,\\rho(\\mathbf{r}\\sigma\\tau,\\mathbf{r}\\sigma\\tau),\n$$\nas a closed-form expression in terms of $\\{\\phi_{i}\\}$. Express both results as analytic expressions; no numerical evaluation is required. The final answer must be given as analytic expressions and does not require units.",
            "solution": "The problem statement is a well-posed and standard derivation within the framework of many-body quantum mechanics, specifically non-relativistic nuclear structure theory using the Hartree-Fock approximation. All givens are scientifically sound, C, and mutually consistent. The concepts, such as the Slater determinant, one-body density matrix, and particle density, are fundamental to the field. No flaws are identified. Therefore, the problem is valid and I will proceed with a full derivation.\n\nThe problem asks for the derivation of the one-body density matrix, $\\rho$, and the local particle density, $n(\\mathbf{r})$, for a system of $A$ nucleons. The system's wavefunction is approximated by a single Slater determinant constructed from a set of $A$ orthonormal single-particle orbitals, $\\{\\phi_{i}(\\mathbf{x})\\}_{i=1}^{A}$. The composite coordinate $\\mathbf{x}$ is defined as $\\mathbf{x} \\equiv (\\mathbf{r},\\sigma,\\tau)$, where $\\mathbf{r}$ is the spatial position, $\\sigma$ is the spin projection, and $\\tau$ is the isospin projection.\n\nLet us define the integration over this composite coordinate as $\\int d\\mathbf{x} \\equiv \\sum_{\\sigma,\\tau}\\int d^{3}r$. The orthonormality condition for the orbitals can then be written compactly as:\n$$\n\\int \\phi_{i}^{*}(\\mathbf{x})\\phi_{j}(\\mathbf{x}) \\, d\\mathbf{x} = \\delta_{ij}\n$$\n\nThe first step is to construct the properly antisymmetrized and normalized $A$-body wavefunction $\\Psi(\\mathbf{x}_{1}, \\ldots, \\mathbf{x}_{A})$. In first quantization, this is given by the Slater determinant of the occupied single-particle orbitals:\n$$\n\\Psi(\\mathbf{x}_{1}, \\ldots, \\mathbf{x}_{A}) = \\frac{1}{\\sqrt{A!}}\n\\begin{vmatrix}\n\\phi_{1}(\\mathbf{x}_{1})  \\phi_{2}(\\mathbf{x}_{1})  \\cdots  \\phi_{A}(\\mathbf{x}_{1}) \\\\\n\\phi_{1}(\\mathbf{x}_{2})  \\phi_{2}(\\mathbf{x}_{2})  \\cdots  \\phi_{A}(\\mathbf{x}_{2}) \\\\\n\\vdots  \\vdots  \\ddots  \\vdots \\\\\n\\phi_{1}(\\mathbf{x}_{A})  \\phi_{2}(\\mathbf{x}_{A})  \\cdots  \\phi_{A}(\\mathbf{x}_{A})\n\\end{vmatrix}\n$$\nThe factor $1/\\sqrt{A!}$ ensures that the wavefunction is normalized to unity, $\\int |\\Psi(\\mathbf{x}_{1}, \\ldots, \\mathbf{x}_{A})|^2 d\\mathbf{x}_{1}\\cdots d\\mathbf{x}_{A} = 1$, which is a direct consequence of the orthonormality of the orbitals $\\{\\phi_i\\}$. The determinant can be expressed using the sum over all permutations $P$ in the symmetric group $S_A$:\n$$\n\\Psi(\\mathbf{x}_{1}, \\ldots, \\mathbf{x}_{A}) = \\frac{1}{\\sqrt{A!}} \\sum_{P \\in S_A} \\text{sgn}(P) \\prod_{i=1}^{A} \\phi_{P(i)}(\\mathbf{x}_{i})\n$$\nwhere $\\text{sgn}(P)$ is the sign of the permutation $P$.\n\nNext, we derive the one-body density matrix $\\rho(\\mathbf{x}, \\mathbf{x}')$. The definition provided is:\n$$\n\\rho(\\mathbf{x}, \\mathbf{x}') = A \\int \\Psi(\\mathbf{x}, \\mathbf{x}_{2}, \\ldots, \\mathbf{x}_{A}) \\Psi^{*}(\\mathbf{x}', \\mathbf{x}_{2}, \\ldots, \\mathbf{x}_{A}) \\, d\\mathbf{x}_{2} \\cdots d\\mathbf{x}_{A}\n$$\nWe substitute the Slater determinant expression for $\\Psi$ and $\\Psi^*$. Note that the arguments of $\\Psi$ are $(\\mathbf{x}, \\mathbf{x}_2, \\ldots, \\mathbf{x}_A)$ and for $\\Psi^*$ they are $(\\mathbf{x}', \\mathbf{x}_2, \\ldots, \\mathbf{x}_A)$.\n$$\n\\Psi(\\mathbf{x}, \\mathbf{x}_{2}, \\ldots, \\mathbf{x}_{A}) = \\frac{1}{\\sqrt{A!}} \\sum_{P \\in S_A} \\text{sgn}(P) \\, \\phi_{P(1)}(\\mathbf{x}) \\prod_{i=2}^{A} \\phi_{P(i)}(\\mathbf{x}_{i})\n$$\n$$\n\\Psi^{*}(\\mathbf{x}', \\mathbf{x}_{2}, \\ldots, \\mathbf{x}_{A}) = \\frac{1}{\\sqrt{A!}} \\sum_{Q \\in S_A} \\text{sgn}(Q) \\, \\phi_{Q(1)}^{*}(\\mathbf{x}') \\prod_{j=2}^{A} \\phi_{Q(j)}^{*}(\\mathbf{x}_{j})\n$$\nSubstituting these into the definition of $\\rho(\\mathbf{x}, \\mathbf{x}')$:\n$$\n\\rho(\\mathbf{x}, \\mathbf{x}') = \\frac{A}{A!} \\sum_{P, Q \\in S_A} \\text{sgn}(P)\\text{sgn}(Q) \\, \\phi_{P(1)}(\\mathbf{x}) \\phi_{Q(1)}^{*}(\\mathbf{x}') \\int \\left( \\prod_{i=2}^{A} \\phi_{P(i)}(\\mathbf{x}_{i}) \\right) \\left( \\prod_{j=2}^{A} \\phi_{Q(j)}^{*}(\\mathbf{x}_{j}) \\right) d\\mathbf{x}_{2} \\cdots d\\mathbf{x}_{A}\n$$\nThe integral can be separated for each particle coordinate:\n$$\n\\int \\cdots d\\mathbf{x}_{2} \\cdots d\\mathbf{x}_{A} = \\int \\phi_{P(2)}(\\mathbf{x}_{2})\\phi_{Q(2)}^{*}(\\mathbf{x}_{2}) d\\mathbf{x}_{2} \\cdots \\int \\phi_{P(A)}(\\mathbf{x}_{A})\\phi_{Q(A)}^{*}(\\mathbf{x}_{A}) d\\mathbf{x}_{A}\n$$\nUsing the orthonormality of the orbitals, $\\int \\phi_{k}^{*}(\\mathbf{z})\\phi_{l}(\\mathbf{z}) d\\mathbf{z} = \\delta_{kl}$, this product of integrals becomes:\n$$\n\\delta_{P(2), Q(2)} \\delta_{P(3), Q(3)} \\cdots \\delta_{P(A), Q(A)} = \\prod_{k=2}^{A} \\delta_{P(k), Q(k)}\n$$\nThis product is non-zero (equal to $1$) only if the sequence of orbital indices $(P(2), P(3), \\ldots, P(A))$ is identical to the sequence $(Q(2), Q(3), \\ldots, Q(A))$. Since both $P$ and $Q$ are permutations of the set $\\{1, 2, \\ldots, A\\}$, this condition implies that the remaining indices must also be equal, i.e., $P(1) = Q(1)$. Therefore, the double summation over $P$ and $Q$ reduces to a single summation where $P = Q$. When $P = Q$, we also have $\\text{sgn}(P) = \\text{sgn}(Q)$, and thus $\\text{sgn}(P)\\text{sgn}(Q) = (\\text{sgn}(P))^2 = 1$.\n\nThe expression for the density matrix simplifies to:\n$$\n\\rho(\\mathbf{x}, \\mathbf{x}') = \\frac{A}{A!} \\sum_{P \\in S_A} \\phi_{P(1)}(\\mathbf{x}) \\phi_{P(1)}^{*}(\\mathbf{x}')\n$$\nThe summation is over all $A!$ permutations $P$. We can re-organize this sum by first summing over the possible values for the index $k = P(1)$, which can be any integer from $1$ to $A$, and then summing over all permutations that have this specific first element. For any fixed choice $k \\in \\{1, \\ldots, A\\}$, there are $(A-1)!$ permutations $P$ for which $P(1) = k$. For all these $(A-1)!$ permutations, the term $\\phi_{P(1)}(\\mathbf{x}) \\phi_{P(1)}^{*}(\\mathbf{x}')$ is the same, namely $\\phi_{k}(\\mathbf{x}) \\phi_{k}^{*}(\\mathbf{x}')$.\nSo we can write:\n$$\n\\sum_{P \\in S_A} \\phi_{P(1)}(\\mathbf{x}) \\phi_{P(1)}^{*}(\\mathbf{x}') = \\sum_{k=1}^{A} \\sum_{\\substack{P \\in S_A \\\\ P(1)=k}} \\phi_{k}(\\mathbf{x}) \\phi_{k}^{*}(\\mathbf{x}') = \\sum_{k=1}^{A} (A-1)! \\, \\phi_{k}(\\mathbf{x}) \\phi_{k}^{*}(\\mathbf{x}')\n$$\nSubstituting this back into the expression for $\\rho(\\mathbf{x}, \\mathbf{x}')$:\n$$\n\\rho(\\mathbf{x}, \\mathbf{x}') = \\frac{A}{A!} (A-1)! \\sum_{k=1}^{A} \\phi_{k}(\\mathbf{x}) \\phi_{k}^{*}(\\mathbf{x}')\n$$\nSince $A! = A \\times (A-1)!$, the pre-factor is $\\frac{A(A-1)!}{A!} = 1$. The final expression for the one-body density matrix is:\n$$\n\\rho(\\mathbf{r}\\sigma\\tau, \\mathbf{r}'\\sigma'\\tau') = \\sum_{i=1}^{A} \\phi_{i}(\\mathbf{r}\\sigma\\tau) \\phi_{i}^{*}(\\mathbf{r}'\\sigma'\\tau')\n$$\n\nFinally, we compute the local particle density $n(\\mathbf{r})$, defined as:\n$$\nn(\\mathbf{r}) = \\sum_{\\sigma,\\tau} \\rho(\\mathbf{r}\\sigma\\tau, \\mathbf{r}\\sigma\\tau)\n$$\nThis requires setting the coordinates in $\\rho$ to be equal, $\\mathbf{r}'=\\mathbf{r}$, $\\sigma'=\\sigma$, $\\tau'=\\tau$, and summing over the spin and isospin degrees of freedom.\n$$\n\\rho(\\mathbf{r}\\sigma\\tau, \\mathbf{r}\\sigma\\tau) = \\sum_{i=1}^{A} \\phi_{i}(\\mathbf{r}\\sigma\\tau) \\phi_{i}^{*}(\\mathbf{r}\\sigma\\tau) = \\sum_{i=1}^{A} |\\phi_{i}(\\mathbf{r}\\sigma\\tau)|^2\n$$\nSubstituting this into the definition of $n(\\mathbf{r})$:\n$$\nn(\\mathbf{r}) = \\sum_{\\sigma,\\tau} \\left( \\sum_{i=1}^{A} |\\phi_{i}(\\mathbf{r}\\sigma\\tau)|^2 \\right)\n$$\nBy swapping the order of the finite summations, we obtain the final expression for the local particle density:\n$$\nn(\\mathbf{r}) = \\sum_{i=1}^{A} \\sum_{\\sigma,\\tau} |\\phi_{i}(\\mathbf{r}\\sigma\\tau)|^2\n$$\nThis result signifies that the total particle density at a point $\\mathbf{r}$ is the incoherent sum of the probability densities of all occupied orbitals at that point, summed over all possible spin and isospin states.\n\nThe two requested results are the analytic expressions for the one-body density matrix and the local particle density.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\sum_{i=1}^{A} \\phi_{i}(\\mathbf{r}\\sigma\\tau) \\phi_{i}^{*}(\\mathbf{r}'\\sigma'\\tau')  \\sum_{i=1}^{A} \\sum_{\\sigma, \\tau} |\\phi_{i}(\\mathbf{r}\\sigma\\tau)|^2 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Real-world TDHF simulations are often used to study nuclear reactions, where particles may be ejected from the nucleus and travel outwards. A finite computational grid, however, can cause these outgoing particles to unphysically reflect at the boundary and re-interfere with the system. This hands-on coding practice  addresses this critical issue by having you implement a Complex Absorbing Potential (CAP), a widely used technique to create absorbing boundary conditions that effectively mimic an open, infinite space.",
            "id": "3609650",
            "problem": "Implement and verify an absorbing boundary condition for a one-dimensional outgoing single-particle wave packet, as it appears in the single-particle equations of Time-Dependent Hartree-Fock (TDHF) theory. In the independent-particle limit, each occupied single-particle orbital evolves according to the time-dependent Schrödinger-like equation with a self-consistent mean-field Hamiltonian. In this problem, you will consider one orbital propagating in free space, and implement absorbing boundary conditions by adding a Complex Absorbing Potential (CAP), expressed as a purely imaginary potential that damps the wave in a layer near the spatial boundaries.\n\nBegin from the fundamental base: the time-dependent Schrödinger equation for a single orbital in one spatial dimension,\n$$\ni \\hbar \\frac{\\partial \\psi(x,t)}{\\partial t} = \\left[ -\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} + V(x) \\right] \\psi(x,t),\n$$\nwhere $m$ is the particle mass and $V(x)$ is a potential. In the independent-particle limit of Time-Dependent Hartree-Fock (TDHF) theory, each occupied single-particle orbital obeys this equation with a mean-field Hamiltonian. For the purposes of this computational test, take a free mean-field so that the real part of $V(x)$ is zero and implement the absorbing boundary condition through a Complex Absorbing Potential $V_{\\mathrm{CAP}}(x) = -i \\eta(x)$, where $\\eta(x) \\ge 0$ is nonzero only in a boundary layer.\n\nWork in natural units with $\\hbar = 1$ and $m = 1$. Discretize space on a uniform grid $x \\in [-L,L]$ with $N$ points and Dirichlet boundary values enforced at the endpoints. Discretize time with a uniform time step $\\Delta t$. Propagate the wave function using an unconditionally stable, norm-preserving in the absence of absorption, time-stepping scheme derived from first principles (for example, the Crank–Nicolson scheme applied to the Hamiltonian operator). The spatial second derivative must be represented by the standard centered finite-difference stencil on the uniform grid. The Complex Absorbing Potential must be implemented as a purely imaginary potential that turns on smoothly over a layer of width $w$ near each boundary:\n$$\n\\eta(x) = \\begin{cases}\n\\eta_0 \\left(\\dfrac{|x| - (L - w)}{w}\\right)^m,  \\text{if } |x|  L - w, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\nwith parameters $\\eta_0 \\ge 0$, $w \\ge 0$, and a smoothness exponent $m \\in \\{1,2,3,\\dots\\}$. If $w = 0$ then set $\\eta(x) \\equiv 0$.\n\nInitialize a normalized right-moving Gaussian wave packet with a prescribed kinetic energy $E_0$:\n$$\n\\psi(x,0) \\propto \\exp\\!\\left(-\\frac{(x-x_0)^2}{4\\sigma^2} + i p_0 x \\right), \\quad p_0 = \\sqrt{2 E_0},\n$$\nwith mean position $x_0$ strictly inside the domain, width $\\sigma$, and positive mean momentum $p_0$. Choose parameters so that the packet propagates to the right, interacts with the absorbing layer at the right boundary, and any reflected component can travel back toward its initial location within the simulation time window. Use Dirichlet conditions at the endpoints.\n\nDefine a monitor window centered at $x_0$ of half-width $\\delta$ and use the following quantitative diagnostic to measure reflection:\n$$\nR \\equiv \\frac{\\displaystyle \\int_{x_0 - \\delta}^{x_0 + \\delta} |\\psi(x,T)|^2 \\, dx}{\\displaystyle \\int_{x_0 - \\delta}^{x_0 + \\delta} |\\psi(x,0)|^2 \\, dx},\n$$\nwhere $T$ is a final time chosen sufficiently large that any significant reflection from the right boundary has had time to return near $x_0$. The quantity $R$ is dimensionless.\n\nImplement the algorithm and produce numerical values of $R$ for the following test suite of absorbing-layer parameters, all at the same wave-packet energy:\n- Spatial domain half-length $L = 4$, number of points $N = 512$, time step $\\Delta t = 0.002$, total time $T = 10.0$.\n- Initial packet parameters: $x_0 = -1.0$, $\\sigma = 0.3$, $E_0 = 0.5$ (so $p_0 = \\sqrt{2 E_0}$), monitor half-width $\\delta = 0.25$.\n- Absorber parameter sets $(\\eta_0, w, m)$:\n    1. $(0.0, 0.0, 2)$,\n    2. $(0.5, 1.0, 2)$,\n    3. $(2.0, 1.5, 3)$,\n    4. $(10.0, 0.25, 1)$.\n\nYour program must:\n- Discretize and propagate the wave packet from $t=0$ to $t=T$ using a first-principles derivation of the Crank–Nicolson update applied to the free Hamiltonian with the Complex Absorbing Potential.\n- For each absorber parameter set, compute $R$ as defined above.\n- Produce a single line of output containing the values $[R_1,R_2,R_3,R_4]$ as decimal floats with six digits after the decimal point, in the exact order of the test suite.\n\nThe final output format must be exactly one line with a Python-style list literal of four comma-separated floats, e.g., \"[0.123456,0.234567,0.345678,0.456789]\".",
            "solution": "We start from the time-dependent Schrödinger equation in one dimension,\n$$\ni \\hbar \\frac{\\partial \\psi(x,t)}{\\partial t} = \\left[-\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} + V(x) \\right]\\psi(x,t),\n$$\nand we work in natural units with $\\hbar = 1$ and $m = 1$. In the independent-particle picture of Time-Dependent Hartree-Fock (TDHF) theory, each occupied single-particle orbital obeys an equation of this form with a self-consistent mean-field potential. Here, to isolate the boundary treatment, we set the real part of the mean-field potential to zero and implement the absorbing boundary as a Complex Absorbing Potential (CAP), $V_{\\mathrm{CAP}}(x) = -i \\eta(x)$ with $\\eta(x) \\ge 0$ supported only near the domain boundaries.\n\nWe choose a uniform grid $x_j = -L + j \\Delta x$ for $j=0,1,\\dots,N-1$, where $\\Delta x = 2L/(N-1)$, and impose Dirichlet boundary conditions $\\psi(x_0,t) = \\psi(x_{N-1},t) = 0$. The spatial second derivative is approximated by the second-order centered difference for interior points,\n$$\n\\frac{\\partial^2 \\psi}{\\partial x^2}(x_j,t) \\approx \\frac{\\psi_{j+1}(t) - 2 \\psi_j(t) + \\psi_{j-1}(t)}{(\\Delta x)^2}, \\quad j = 1,2,\\dots,N-2.\n$$\nThe Hamiltonian acting on interior values can then be written as a tridiagonal operator,\n$$\n(H \\psi)_j = -\\frac{1}{2}\\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{(\\Delta x)^2} + V_j \\psi_j, \\quad V_j = -i \\eta(x_j),\n$$\nwith fixed zero boundary values $\\psi_0 = \\psi_{N-1} = 0$.\n\nFor time evolution, we employ the Crank–Nicolson scheme, which follows from the trapezoidal rule in time applied to the Schrödinger equation:\n$$\n\\left(I + \\frac{i \\Delta t}{2} H \\right)\\psi^{n+1} = \\left(I - \\frac{i \\Delta t}{2} H \\right)\\psi^n,\n$$\nwhere $\\psi^n$ is the wave function at time $t_n = n \\Delta t$. This scheme is unconditionally stable and exactly norm-preserving in the absence of an imaginary potential; with the Complex Absorbing Potential, it will decrease the norm in the absorbing regions.\n\nLet us express the action of $H$ on interior nodes in terms of a tridiagonal matrix. Using $m = 1$ and $\\hbar = 1$, the kinetic energy operator provides the neighbor couplings with coefficient $-1/(2 (\\Delta x)^2)$, and the diagonal kinetic contribution $+1/(\\Delta x)^2$ arises from the $-2\\psi_j$ term. Therefore, for interior indices $j=1,\\dots,N-2$,\n- The off-diagonal kinetic term contributes $\\pm \\left(-\\frac{1}{2(\\Delta x)^2}\\right) \\psi_{j\\pm 1}$,\n- The diagonal kinetic term contributes $+\\left(\\frac{1}{(\\Delta x)^2}\\right)\\psi_j$,\n- The diagonal potential term contributes $+ V_j \\psi_j$,\nso the diagonal entry of $H$ is $H_{jj} = \\frac{1}{(\\Delta x)^2} + V_j$ and the off-diagonals are $H_{j,j\\pm 1} = -\\frac{1}{2(\\Delta x)^2}$.\n\nSubstituting this tridiagonal structure into the Crank–Nicolson update, we obtain two tridiagonal matrices:\n$$\nA \\equiv I + \\frac{i \\Delta t}{2} H, \\quad B \\equiv I - \\frac{i \\Delta t}{2} H,\n$$\nand the update is $A \\psi^{n+1} = B \\psi^n$. Explicitly, for interior points,\n- For $A$, the diagonal entries are\n$$\nA_{jj} = 1 + \\frac{i \\Delta t}{2}\\left(\\frac{1}{(\\Delta x)^2} + V_j\\right),\n$$\nand the off-diagonal entries are\n$$\nA_{j,j\\pm 1} = \\frac{i \\Delta t}{2}\\left(-\\frac{1}{2(\\Delta x)^2}\\right) = - i \\frac{\\Delta t}{4 (\\Delta x)^2}.\n$$\n- For $B$, the diagonal entries are\n$$\nB_{jj} = 1 - \\frac{i \\Delta t}{2}\\left(\\frac{1}{(\\Delta x)^2} + V_j\\right),\n$$\nand the off-diagonal entries are\n$$\nB_{j,j\\pm 1} = -\\frac{i \\Delta t}{2}\\left(-\\frac{1}{2(\\Delta x)^2}\\right) = + i \\frac{\\Delta t}{4 (\\Delta x)^2}.\n$$\n\nSince $\\psi_0 = \\psi_{N-1} = 0$, the update equation couples only the interior vector $\\mathbf{\\psi}_{\\mathrm{int}}^n = (\\psi_1^n,\\dots,\\psi_{N-2}^n)^\\top$. Let $n_{\\mathrm{int}} = N - 2$. In vector form, we compute each step by forming $\\mathbf{d}^n = B \\mathbf{\\psi}^n_{\\mathrm{int}}$ and then solving the tridiagonal linear system $A \\mathbf{\\psi}^{n+1}_{\\mathrm{int}} = \\mathbf{d}^n$. Because $A$ is time-independent for fixed $\\eta(x)$, this system can be efficiently solved at each time step using the Thomas algorithm with a precomputed forward-elimination factorization.\n\nThe Complex Absorbing Potential is set as\n$$\n\\eta(x) = \\begin{cases}\n\\eta_0 \\left(\\dfrac{|x| - (L - w)}{w}\\right)^m,  \\text{if } |x|  L - w, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\nwhich turns on smoothly from zero at the inner edge $|x| = L - w$ to a maximum at the boundary $|x| = L$. The smoothness exponent $m$ controls how gently the potential grows; larger $m$ reduces spurious reflections by matching derivatives more smoothly, at the expense of requiring a wider layer to achieve the same attenuation.\n\nWe initialize a right-moving Gaussian wave packet with kinetic energy $E_0$ and mean momentum $p_0 = \\sqrt{2 E_0}$,\n$$\n\\psi(x,0) = \\mathcal{N} \\exp\\!\\left(-\\frac{(x-x_0)^2}{4 \\sigma^2} + i p_0 x \\right),\n$$\nwhere $\\mathcal{N}$ is a normalization constant determined numerically to ensure $\\int |\\psi(x,0)|^2 dx = 1$. With $x_0$ strictly inside the domain and $p_0  0$, the packet propagates to the right with group velocity $v = p_0/m = p_0$ in our units, reaches the right boundary layer, and is either absorbed or partially reflected depending on the CAP parameters.\n\nTo quantify the quality of absorption, we define a monitor window centered at $x_0$ of half-width $\\delta$ and measure the reflection ratio\n$$\nR = \\frac{\\displaystyle \\int_{x_0 - \\delta}^{x_0 + \\delta} |\\psi(x,T)|^2 \\, dx}{\\displaystyle \\int_{x_0 - \\delta}^{x_0 + \\delta} |\\psi(x,0)|^2 \\, dx}.\n$$\nThe final time $T$ is chosen so that, without absorption, the reflected wave would have time to return from the right boundary to the initial region; with good absorption, $R$ will be small. The integral is computed numerically using the discrete sum $\\int f(x)\\,dx \\approx \\Delta x \\sum_j f(x_j)$ over grid points in the monitor window.\n\nAlgorithmic steps:\n1. Set physical and numerical parameters: $L$, $N$, $\\Delta t$, $T$, $x_0$, $\\sigma$, $E_0$, $\\delta$.\n2. Construct the grid $x_j$ and initialize $\\psi(x,0)$, then normalize it.\n3. For each CAP parameter set $(\\eta_0,w,m)$:\n   - Build $\\eta(x)$ on the grid.\n   - Construct $V_j = -i \\eta(x_j)$ and form the tridiagonal matrices $A$ and $B$ for interior points.\n   - Precompute the forward-elimination coefficients for the Thomas algorithm associated with $A$.\n   - Time step from $t=0$ to $t=T$ by repeatedly computing $\\mathbf{d}^n = B \\mathbf{\\psi}^n_{\\mathrm{int}}$ and solving $A \\mathbf{\\psi}^{n+1}_{\\mathrm{int}} = \\mathbf{d}^n$.\n   - Compute $R$ using the monitor region at $t=0$ and $t=T$.\n4. Output the reflection ratios $[R_1,R_2,R_3,R_4]$ for the specified test suite in a single line.\n\nExpected qualitative behavior across the test suite:\n- For $(\\eta_0,w,m) = (0,0,2)$, no absorption is present and the Dirichlet boundary acts like a hard wall; the reflected wave returns with a large $R$.\n- For a weak but finite absorber $(\\eta_0,w,m) = (0.5,1.0,2)$, some attenuation occurs but reflections remain noticeable; $R$ is reduced relative to no absorber.\n- For a smooth and sufficiently strong absorber $(\\eta_0,w,m) = (2.0,1.5,3)$, reflections are strongly suppressed and $R$ is small.\n- For an overly strong and very thin absorber $(\\eta_0,w,m) = (10.0,0.25,1)$, the abrupt onset causes significant spurious reflections; $R$ increases again.\n\nAll quantities here are dimensionless due to the choice $\\hbar = 1$ and $m = 1$. The final program computes the four values of $R$ and prints them in the required single-line list format with six digits after the decimal point.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef thomas_precompute(a, b, c):\n    \"\"\"\n    Precompute coefficients for the Thomas algorithm (tridiagonal solver).\n    a: lower diagonal (length n-1), entries a[i] corresponds to row i+1\n    b: main diagonal (length n)\n    c: upper diagonal (length n-1), entries c[i] corresponds to row i\n    Returns:\n        cp: modified upper diagonal coefficients (length n-1)\n        inv_denom: inverse of the modified main diagonal (length n)\n    \"\"\"\n    n = b.size\n    cp = np.zeros(n - 1, dtype=np.complex128)\n    inv_denom = np.zeros(n, dtype=np.complex128)\n\n    inv_denom[0] = 1.0 / b[0]\n    if n - 1  0:\n        cp[0] = c[0] * inv_denom[0]\n    for i in range(1, n - 1):\n        denom = b[i] - a[i - 1] * cp[i - 1]\n        inv_denom[i] = 1.0 / denom\n        cp[i] = c[i] * inv_denom[i]\n    if n  1:\n        denom_last = b[-1] - a[-1] * cp[-1]\n        inv_denom[-1] = 1.0 / denom_last\n    return cp, inv_denom\n\ndef thomas_solve(a, b, c, cp, inv_denom, d):\n    \"\"\"\n    Solve A x = d for tridiagonal A with precomputed cp and inv_denom.\n    a: lower diagonal (length n-1)\n    b: main diagonal (length n) (not used directly here, but kept for signature consistency)\n    c: upper diagonal (length n-1)\n    cp: precomputed modified upper diagonal (length n-1)\n    inv_denom: precomputed inverse denominators (length n)\n    d: right-hand side (length n)\n    Returns:\n        x: solution vector (length n)\n    \"\"\"\n    n = d.size\n    dp = np.empty(n, dtype=np.complex128)\n    # Forward substitution using precomputed inv_denom\n    dp[0] = d[0] * inv_denom[0]\n    for i in range(1, n):\n        dp[i] = (d[i] - a[i - 1] * dp[i - 1]) * inv_denom[i]\n    # Back substitution using cp\n    x = np.empty(n, dtype=np.complex128)\n    x[-1] = dp[-1]\n    for i in range(n - 2, -1, -1):\n        x[i] = dp[i] - cp[i] * x[i + 1]\n    return x\n\ndef build_cap(x, L, eta0, w, m_order):\n    \"\"\"\n    Build the complex absorbing potential strength eta(x) over the grid x.\n    If w = 0 or eta0 == 0, returns zeros.\n    \"\"\"\n    eta = np.zeros_like(x, dtype=np.float64)\n    if eta0 = 0.0 or w = 0.0:\n        return eta\n    # Distance beyond inner edge of absorber\n    inner_edge = L - w\n    dist = np.abs(x) - inner_edge\n    dist = np.where(dist  0.0, dist, 0.0)\n    s = dist / w\n    # Avoid numerical issues exactly at boundary\n    s = np.clip(s, 0.0, 1.0)\n    eta = eta0 * (s ** m_order)\n    return eta\n\ndef run_case(eta0, w, m_order, params):\n    \"\"\"\n    Run one simulation case and return reflection ratio R.\n    params: dict with keys L, N, dt, T, x0, sigma, E0, delta\n    \"\"\"\n    L = params[\"L\"]\n    N = params[\"N\"]\n    dt = params[\"dt\"]\n    T = params[\"T\"]\n    x0 = params[\"x0\"]\n    sigma = params[\"sigma\"]\n    E0 = params[\"E0\"]\n    delta = params[\"delta\"]\n\n    # Grid\n    x = np.linspace(-L, L, N, endpoint=True)\n    dx = x[1] - x[0]\n\n    # Initial Gaussian wave packet\n    p0 = np.sqrt(2.0 * E0)\n    psi = np.exp(-((x - x0) ** 2) / (4.0 * sigma ** 2) + 1j * p0 * x).astype(np.complex128)\n    # Enforce Dirichlet at the endpoints\n    psi[0] = 0.0 + 0.0j\n    psi[-1] = 0.0 + 0.0j\n    # Normalize\n    norm0 = np.sqrt(np.sum(np.abs(psi) ** 2) * dx)\n    psi /= norm0\n\n    # Build CAP and potential\n    eta = build_cap(x, L, eta0, w, m_order)\n    V = -1j * eta  # purely imaginary potential\n\n    # Crank–Nicolson matrices for interior points\n    n_int = N - 2\n    # Constants\n    inv_dx2 = 1.0 / (dx * dx)\n    off_fac = dt / (4.0 * dx * dx)\n    # Diagonals for A and B (interior)\n    V_int = V[1:-1]\n    # A = I + i dt/2 H\n    bA = (1.0 + 1j * (dt / 2.0) * (inv_dx2 + V_int)).astype(np.complex128)\n    aA = (-1j * off_fac) * np.ones(n_int - 1, dtype=np.complex128)\n    cA = (-1j * off_fac) * np.ones(n_int - 1, dtype=np.complex128)\n    # B = I - i dt/2 H\n    bB = (1.0 - 1j * (dt / 2.0) * (inv_dx2 + V_int)).astype(np.complex128)\n    aB = (1j * off_fac) * np.ones(n_int - 1, dtype=np.complex128)\n    cB = (1j * off_fac) * np.ones(n_int - 1, dtype=np.complex128)\n\n    # Precompute Thomas algorithm coefficients for A\n    cp, inv_denom = thomas_precompute(aA, bA, cA)\n\n    # Prepare time stepping\n    steps = int(np.round(T / dt))\n    # Monitor region mask\n    mask = (x = (x0 - delta))  (x = (x0 + delta))\n    # Initial monitor probability\n    P_init = np.sum((np.abs(psi) ** 2) * mask) * dx\n\n    # Time propagation\n    psi_int = psi[1:-1].copy()\n    for _ in range(steps):\n        # Compute d = B * psi_int (tri-diagonal multiplication)\n        d = bB * psi_int\n        # Lower diagonal contribution (from j-1): rows 1..n_int-1\n        d[1:] += aB * psi_int[:-1]\n        # Upper diagonal contribution (from j+1): rows 0..n_int-2\n        d[:-1] += cB * psi_int[1:]\n        # Solve A * psi_next_int = d\n        psi_int = thomas_solve(aA, bA, cA, cp, inv_denom, d)\n\n    # Assemble full psi at final time\n    psi_final = np.zeros_like(psi)\n    psi_final[0] = 0.0 + 0.0j\n    psi_final[-1] = 0.0 + 0.0j\n    psi_final[1:-1] = psi_int\n\n    P_final = np.sum((np.abs(psi_final) ** 2) * mask) * dx\n    # Reflection ratio\n    R = P_final / P_init if P_init  0 else 0.0\n    return float(np.real_if_close(R))\n\ndef solve():\n    # Define global parameters and test suite as specified in the problem statement.\n    params = {\n        \"L\": 4.0,       # half-length of the spatial domain\n        \"N\": 512,       # number of grid points\n        \"dt\": 0.002,    # time step\n        \"T\": 10.0,      # total propagation time\n        \"x0\": -1.0,     # initial center position\n        \"sigma\": 0.3,   # initial packet width\n        \"E0\": 0.5,      # kinetic energy of the packet\n        \"delta\": 0.25,  # monitor half-width\n    }\n\n    # Test suite: (eta0, w, m_order)\n    test_cases = [\n        (0.0, 0.0, 2),     # No absorber: expect large reflection\n        (0.5, 1.0, 2),     # Weak absorber: partial reflection\n        (2.0, 1.5, 3),     # Smooth, strong absorber: low reflection\n        (10.0, 0.25, 1),   # Very strong, thin absorber: spurious reflections\n    ]\n\n    results = []\n    for eta0, w, m_order in test_cases:\n        R = run_case(eta0, w, m_order, params)\n        results.append(R)\n\n    # Final print statement in the exact required format with six decimals.\n    print(\"[\" + \",\".join(f\"{r:.6f}\" for r in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Having established the core concepts and essential numerical techniques, this final practice challenges you to build a functional, albeit simplified, TDHF solver. You will implement the full time-evolution loop, grappling with the central feature of TDHF: the self-consistent, non-linear coupling between the single-particle orbitals and the mean field they collectively generate. This capstone exercise  provides invaluable experience by requiring you to implement and compare two distinct propagation schemes, illustrating the practical trade-offs between computational cost, accuracy, and stability in modern TDHF codes.",
            "id": "3609662",
            "problem": "Implement and compare two real-time propagation schemes for Time-Dependent Hartree-Fock (TDHF) dynamics using a simplified Skyrme energy density functional in one spatial dimension, under periodic boundary conditions. Work in units where Planck’s constant is $\\hbar = 1$ and the nucleon mass is $m = 1$. Consider a spin-saturated system so that spin density and spin-current vanish, and reduce the Skyrme Energy Density Functional (EDF) to the minimal form that depends only on the particle density and kinetic density. Let the total energy functional be\n$$\nE[\\rho,\\tau] \\;=\\; \\int_{0}^{L} dx \\,\\left[ \\frac{1}{2m}\\,\\tau(x,t) \\;+\\; \\frac{t_0}{2}\\,\\rho(x,t)^2 \\right],\n$$\nwhere the particle density is $\\rho(x,t) = \\sum_{i=1}^{N_{\\text{orb}}} |\\varphi_i(x,t)|^2$, and the kinetic density is $\\tau(x,t) = \\sum_{i=1}^{N_{\\text{orb}}} |\\partial_x \\varphi_i(x,t)|^2$. From the variational principle for a Slater determinant, each occupied single-particle orbital $\\varphi_i(x,t)$ evolves according to the time-dependent Hartree-Fock equation\n$$\ni\\,\\partial_t \\varphi_i(x,t) \\;=\\; h[\\rho]\\,\\varphi_i(x,t),\n$$\nwith the mean-field Hamiltonian\n$$\nh[\\rho] \\;=\\; -\\frac{1}{2m}\\,\\partial_x^2 \\;+\\; U[\\rho](x,t),\n\\qquad\nU[\\rho](x,t) \\;=\\; t_0\\,\\rho(x,t).\n$$\nEnsure that the occupied orbitals remain orthonormal at all times with the periodic inner product $\\langle \\phi,\\psi\\rangle = \\int_{0}^{L} \\phi(x)^{*}\\psi(x)\\,dx$.\n\nYour task is to write a complete, runnable program that:\n- Discretizes the interval $[0,L)$ on a uniform periodic grid with $N$ points and spacing $\\Delta x = L/N$.\n- Initializes $N_{\\text{orb}} = 2$ occupied orbitals as two normalized Gaussians of width $\\sigma$ centered at $x_1 = L/4$ and $x_2 = 3L/4$, each with a small plane-wave phase factor $\\exp(\\pm i k_0 x)$ with $k_0 = 2\\pi/L$. Orthonormalize the orbitals using a numerically stable procedure.\n- Propagates the orbitals in real time from $t=0$ to $t=T$ with time step $\\Delta t$, using two different schemes at the same $(\\Delta t,\\Delta x)$:\n  1. A Crank–Nicolson (CN) scheme for the time-dependent mean-field problem implemented with a predictor–corrector for the Hamiltonian. Use the finite-difference periodic Laplacian for the kinetic operator. One acceptable approach is:\n     - Predictor: build $H[\\rho^n]$ from $\\rho^n$, compute a first-order explicit predictor $\\varphi_i^{\\text{pred}} = \\varphi_i^n - i\\,\\Delta t\\,H[\\rho^n]\\varphi_i^n$, form $\\rho^{\\text{pred}}$, and define $H^{\\text{avg}} = \\frac{1}{2}\\left(H[\\rho^n] + H[\\rho^{\\text{pred}}]\\right)$.\n     - Corrector: solve for each orbital\n       $$\n       \\left(I + \\frac{i\\Delta t}{2}H^{\\text{avg}}\\right)\\varphi_i^{n+1} \\;=\\; \\left(I - \\frac{i\\Delta t}{2}H^{\\text{avg}}\\right)\\varphi_i^{n}.\n       $$\n     - Re-orthonormalize the set $\\{\\varphi_i^{n+1}\\}$.\n  2. A split-operator (second-order Strang) scheme using the exact kinetic propagator in momentum space under periodic boundary conditions:\n     - Apply a half-step local potential kick with $U[\\rho^n](x)$.\n     - Apply a full-step kinetic propagator in momentum space, $e^{-i\\Delta t\\,k^2/(2m)}$, where $k = 2\\pi n/L$ for integer $n$ consistent with the discrete Fourier transform.\n     - Recompute the density and apply another half-step potential kick, using the updated density for improved self-consistency.\n     - Re-orthonormalize the set of orbitals after each full step.\n- Uses the same energy functional to compute the instantaneous total energy at $t=0$ and at $t=T$,\n  $$\n  E(t) \\;=\\; \\sum_{i=1}^{N_{\\text{orb}}} \\int_{0}^{L} dx \\,\\frac{1}{2m}\\,|\\partial_x \\varphi_i(x,t)|^2 \\;+\\; \\int_{0}^{L} dx \\,\\frac{t_0}{2}\\,\\rho(x,t)^2,\n  $$\n  evaluated with accurate periodic differentiation for $\\partial_x$ (for example, spectral differentiation in Fourier space).\n- Reports the absolute energy drift $\\Delta E(T) = |E(T) - E(0)|$ for each propagator and each test case.\n\nScientific and numerical constraints:\n- Work in strictly periodic boundary conditions on $[0,L)$.\n- Use $\\hbar = 1$, $m = 1$, and a purely local Skyrme term with coupling $t_0$ as specified above. Do not include spin-orbit or current terms; set gradient terms to zero.\n- Maintain orbital orthonormality after every time step.\n- The answer is unitless; report energy drifts as unitless floats.\n\nTest suite:\nFor each parameter set below, initialize with Gaussian width $\\sigma = L/20$ and the $N_{\\text{orb}} = 2$ orbitals as described. For each case, compute booleans indicating whether the Crank–Nicolson scheme yields less than or equal energy drift than the split-operator scheme at the same $(\\Delta t,\\Delta x)$:\n- Case A (happy path): $(L, N, \\Delta t, T, t_0) = (\\,20.0,\\,128,\\,0.02,\\,1.0,\\,1.0\\,)$.\n- Case B (smaller time step): $(L, N, \\Delta t, T, t_0) = (\\,20.0,\\,128,\\,0.01,\\,1.0,\\,1.0\\,)$.\n- Case C (coarser grid): $(L, N, \\Delta t, T, t_0) = (\\,20.0,\\,64,\\,0.02,\\,1.0,\\,1.0\\,)$.\n- Case D (larger time step, shorter evolution): $(L, N, \\Delta t, T, t_0) = (\\,20.0,\\,64,\\,0.04,\\,0.8,\\,1.0\\,)$.\n\nRequired final output:\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list of booleans enclosed in square brackets, for example, \"[True,False,True,True]\".\n- For each case, output True if $\\Delta E_{\\text{CN}}(T) \\le \\Delta E_{\\text{Split}}(T)$, otherwise output False.\n\nAngle units are not used. All reported quantities are unitless floats or booleans. No user input is required; your program must run to completion using only the given test suite and print the single required line.",
            "solution": "The user has provided a well-defined computational physics problem that requires the implementation and comparison of two numerical methods for solving the Time-Dependent Hartree-Fock (TDHF) equations.\n\n### Step 1: Extract Givens\n- **System**: A one-dimensional, spin-saturated nuclear system under periodic boundary conditions on the interval $[0, L)$.\n- **Constants**: Planck's constant $\\hbar = 1$, nucleon mass $m = 1$.\n- **Energy Density Functional (EDF)**: $E[\\rho,\\tau] = \\int_{0}^{L} dx \\,\\left[ \\frac{1}{2m}\\,\\tau(x,t) + \\frac{t_0}{2}\\,\\rho(x,t)^2 \\right]$.\n- **Density Definitions**:\n    - Particle density: $\\rho(x,t) = \\sum_{i=1}^{N_{\\text{orb}}} |\\varphi_i(x,t)|^2$.\n    - Kinetic density: $\\tau(x,t) = \\sum_{i=1}^{N_{\\text{orb}}} |\\partial_x \\varphi_i(x,t)|^2$.\n- **TDHF Equation**: $i\\,\\partial_t \\varphi_i(x,t) = h[\\rho]\\,\\varphi_i(x,t)$.\n- **Mean-Field Hamiltonian**: $h[\\rho] = -\\frac{1}{2m}\\,\\partial_x^2 + U[\\rho](x,t)$, with potential $U[\\rho](x,t) = t_0\\,\\rho(x,t)$.\n- **Initial Conditions**:\n    - Number of orbitals: $N_{\\text{orb}} = 2$.\n    - Orbital shape: Normalized Gaussians of width $\\sigma = L/20$.\n    - Orbital centers: $x_1 = L/4$, $x_2 = 3L/4$.\n    - Initial momentum: A plane-wave phase factor $\\exp(\\pm i k_0 x)$ with $k_0 = 2\\pi/L$.\n    - The initial set of orbitals must be orthonormalized.\n- **Numerical Propagators**:\n    1.  **Crank-Nicolson (CN)**: A predictor-corrector scheme using a finite-difference Laplacian.\n        - Predictor: $\\varphi_i^{\\text{pred}} = \\varphi_i^n - i\\,\\Delta t\\,H[\\rho^n]\\varphi_i^n$, using $H[\\rho^n]$.\n        - Averaged Hamiltonian: $H^{\\text{avg}} = \\frac{1}{2}\\left(H[\\rho^n] + H[\\rho^{\\text{pred}}]\\right)$.\n        - Corrector: Implicit solve of $\\left(I + \\frac{i\\Delta t}{2}H^{\\text{avg}}\\right)\\varphi_i^{n+1} = \\left(I - \\frac{i\\Delta t}{2}H^{\\text{avg}}\\right)\\varphi_i^{n}$.\n    2.  **Split-Operator (SO)**: A second-order Strang splitting using a Fast Fourier Transform (FFT) for the kinetic part.\n        - Half potential step with $U[\\rho^n]$.\n        - Full kinetic step $e^{-i\\Delta t\\,T}$.\n        - Half potential step using a self-consistently updated density.\n- **Constraint**: Orbitals must be re-orthonormalized after each time step for both methods.\n- **Analysis**:\n    - Calculate the total energy $E(t)$ at $t=0$ and $t=T$ using spectral differentiation for the kinetic term.\n    - Report the absolute energy drift $\\Delta E(T) = |E(T) - E(0)|$.\n- **Test Cases**:\n    - Case A: $(L, N, \\Delta t, T, t_0) = (20.0, 128, 0.02, 1.0, 1.0)$.\n    - Case B: $(L, N, \\Delta t, T, t_0) = (20.0, 128, 0.01, 1.0, 1.0)$.\n    - Case C: $(L, N, \\Delta t, T, t_0) = (20.0, 64, 0.02, 1.0, 1.0)$.\n    - Case D: $(L, N, \\Delta t, T, t_0) = (20.0, 64, 0.04, 0.8, 1.0)$.\n- **Required Output**: For each case, a boolean value indicating if $\\Delta E_{\\text{CN}}(T) \\le \\Delta E_{\\text{Split}}(T)$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on the Time-Dependent Hartree-Fock theory, a standard mean-field approximation in quantum many-body physics. The simplified Skyrme functional is a valid and common starting point for such calculations.\n- **Well-Posed**: The problem is well-posed. It provides all necessary physical constants, initial conditions, model equations, and a complete description of the numerical algorithms and test parameters required to find a unique solution.\n- **Objective**: The language is precise, quantitative, and free of subjectivity. The task is a standard numerical experiment.\n\nAll validity criteria are met. The problem does not exhibit any of the specified flaws.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Principle-Based Design\nThe solution will be implemented in Python using the `numpy` library for numerical operations. The logic is encapsulated within a `solve` function that iterates through the provided test cases.\n\n**1. Discretization and Grids**\nThe one-dimensional spatial domain $[0, L)$ is discretized into a uniform grid of $N$ points with spacing $\\Delta x = L/N$. The corresponding momentum-space grid, required for Fourier transforms, is generated using `numpy.fft.fftfreq`. This ensures correct handling of periodic boundary conditions.\n\n**2. Initial State Preparation**\nThe two initial orbitals are constructed as Gaussian wave packets, each multiplied by a plane-wave phase factor to impart an initial velocity, causing them to move towards each other. While the individual Gaussians can be normalized, they are not mutually orthogonal due to their spatial overlap. To satisfy the Pauli principle for fermions, the set of orbitals must be orthonormal. This is achieved using the Löwdin orthonormalization procedure, which is numerically stable for nearly linearly dependent vectors. This method involves constructing the overlap matrix $S_{ij} = \\langle \\varphi_i | \\varphi_j \\rangle$, computing its inverse square root $S^{-1/2}$, and transforming the original orbitals via $\\varphi'_k = \\sum_j (S^{-1/2})_{kj} \\varphi_j$. The inner product integral is computed as a discrete sum weighted by $\\Delta x$.\n\n**3. Energy Calculation**\nA function is designed to compute the total energy $E(t)$ according to the given functional. The potential energy term is calculated by squaring the total density $\\rho(x,t)$ and integrating. To achieve high accuracy as specified, the kinetic energy density $\\tau(x,t)$ is computed using spectral differentiation. For each orbital $\\varphi_i$, its derivative $\\partial_x \\varphi_i$ is found by Fourier transforming the orbital, multiplying by $ik$ in momentum space (where $k$ are the discrete momentum-space frequencies), and then inverse Fourier transforming back to position space. The total energy is the sum of the integrated kinetic and potential energy densities.\n\n**4. Crank-Nicolson (CN) Implementation**\nThis propagator is implemented following the specified predictor-corrector scheme to handle the non-linearity of the mean-field potential.\n- **Kinetic Operator**: The kinetic operator $-\\frac{1}{2m}\\partial_x^2$ is represented as a matrix using a second-order, three-point finite-difference stencil on the periodic grid. This results in a circulant matrix.\n- **Predictor-Corrector Cycle**:\n    1.  At time $t_n$, the Hamiltonian $H[\\rho^n]$ is built using the current density $\\rho^n$.\n    2.  A predictor state $\\varphi_i^{\\text{pred}}$ is computed using a single forward Euler step.\n    3.  A new density $\\rho^{\\text{pred}}$ is formed from these predictor states, and a predictor Hamiltonian $H[\\rho^{\\text{pred}}]$ is constructed.\n    4.  The Hamiltonian for the step is taken as the average, $H^{\\text{avg}} = \\frac{1}{2}(H[\\rho^n] + H[\\rho^{\\text{pred}}])$.\n    5.  The corrector step solves the implicit Crank-Nicolson equation, which is a linear system of the form $A\\varphi_i^{n+1} = B\\varphi_i^n$, using `numpy.linalg.solve`.\n- **Orthonormalization**: After each time step, the set of new orbitals $\\{\\varphi_i^{n+1}\\}$ is re-orthonormalized using the Löwdin procedure.\n\n**5. Split-Operator (SO) Implementation**\nThis propagator uses Strang splitting to approximate the time-evolution operator $e^{-i\\Delta t H} \\approx e^{-i\\Delta t U/2}e^{-i\\Delta t T}e^{-i\\Delta t U/2}$.\n- **Potential Step**: The action of $e^{-i\\Delta t U/2}$ is a simple phase multiplication in position space, where the phase depends on the local potential $U(x)$.\n- **Kinetic Step**: The kinetic evolution $e^{-i\\Delta t T}$ is most accurately and efficiently performed in momentum space. The orbitals are transformed using an FFT, multiplied by the phase factor $e^{-i\\Delta t k^2/(2m)}$, and transformed back using an inverse FFT.\n- **Self-Consistency**: As specified, the scheme incorporates a self-consistency improvement. The density is recalculated after the kinetic step, and this updated density is used to compute the potential for the second half potential-step propagator.\n- **Orthonormalization**: As with the CN method, the orbitals are re-orthonormalized via Löwdin's method after each complete time step.\n\n**6. Comparison and Output**\nFor each test case, the program first computes the initial energy $E(0)$. It then runs both propagation schemes from $t=0$ to $t=T$. The final energy $E(T)$ is computed for each scheme, and the absolute energy drift $\\Delta E = |E(T) - E(0)|$ is found. The boolean result of the comparison $\\Delta E_{\\text{CN}} \\le \\Delta E_{\\text{Split}}$ is stored. Finally, all boolean results are formatted into the required string format `[True,False,...]` and printed.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares Crank-Nicolson and Split-Operator propagators for\n    1D Time-Dependent Hartree-Fock (TDHF) dynamics.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, N, dt, T, t0)\n        (20.0, 128, 0.02, 1.0, 1.0),  # Case A\n        (20.0, 128, 0.01, 1.0, 1.0),  # Case B\n        (20.0, 64, 0.02, 1.0, 1.0),   # Case C\n        (20.0, 64, 0.04, 0.8, 1.0),   # Case D\n    ]\n\n    # --- Helper Functions ---\n\n    def lowdin_orthonormalize(orbitals, dx):\n        \"\"\"\n        Orthonormalizes a set of orbitals using the Löwdin method.\n        \"\"\"\n        num_orbitals = len(orbitals)\n        if num_orbitals  2:\n            return orbitals\n\n        S = np.zeros((num_orbitals, num_orbitals), dtype=np.complex128)\n        for i in range(num_orbitals):\n            for j in range(i, num_orbitals):\n                overlap = np.sum(np.conj(orbitals[i]) * orbitals[j]) * dx\n                S[i, j] = overlap\n                S[j, i] = np.conj(overlap)\n        \n        eigvals, eigvecs = np.linalg.eigh(S)\n        S_inv_sqrt = eigvecs @ np.diag(1.0 / np.sqrt(eigvals)) @ eigvecs.T.conj()\n\n        old_orbitals_matrix = np.array(orbitals)\n        new_orbitals_matrix = S_inv_sqrt @ old_orbitals_matrix\n        return list(new_orbitals_matrix)\n\n    def create_initial_orbitals(L, N, sigma, k0, dx):\n        \"\"\"\n        Creates and orthonormalizes the initial Gaussian orbitals.\n        \"\"\"\n        x = np.linspace(0, L, N, endpoint=False)\n        x1, x2 = L / 4.0, 3.0 * L / 4.0\n\n        psi1_un = np.exp(-(x - x1)**2 / (2 * sigma**2)) * np.exp(1j * k0 * x)\n        psi2_un = np.exp(-(x - x2)**2 / (2 * sigma**2)) * np.exp(-1j * k0 * x)\n        \n        psi1 = psi1_un / np.sqrt(np.sum(np.abs(psi1_un)**2) * dx)\n        psi2 = psi2_un / np.sqrt(np.sum(np.abs(psi2_un)**2) * dx)\n\n        return lowdin_orthonormalize([psi1, psi2], dx)\n\n    def calculate_energy(orbitals, t0, L, N, dx, k_vec):\n        \"\"\"\n        Calculates the total energy using spectral differentiation for the kinetic term.\n        \"\"\"\n        rho = np.sum([np.abs(phi)**2 for phi in orbitals], axis=0)\n        \n        tau = np.zeros_like(rho, dtype=np.float64)\n        for phi in orbitals:\n            phi_k = np.fft.fft(phi)\n            d_phi_k = 1j * k_vec * phi_k\n            d_phi = np.fft.ifft(d_phi_k)\n            tau += np.abs(d_phi)**2\n            \n        E_kin = (1.0 / 2.0) * np.sum(tau) * dx\n        E_pot = (t0 / 2.0) * np.sum(rho**2) * dx\n        return E_kin + E_pot\n\n    def run_cn_propagation(params, initial_orbitals, dx, k_vec):\n        \"\"\"\n        Propagates orbitals using the Crank-Nicolson predictor-corrector method.\n        \"\"\"\n        L, N, dt, T, t0 = params\n        n_steps = int(round(T / dt))\n        orbitals = [o.copy() for o in initial_orbitals]\n\n        # Kinetic operator (finite difference)\n        D2 = np.zeros((N, N), dtype=np.float64)\n        diag_val = -2.0 / dx**2\n        offdiag_val = 1.0 / dx**2\n        np.fill_diagonal(D2, diag_val)\n        np.fill_diagonal(D2[1:], offdiag_val)\n        np.fill_diagonal(D2[:, 1:], offdiag_val)\n        D2[0, -1] = offdiag_val\n        D2[-1, 0] = offdiag_val\n        T_op = -0.5 * D2\n\n        for _ in range(n_steps):\n            # Predictor\n            rho_n = np.sum([np.abs(o)**2 for o in orbitals], axis=0)\n            H_n = T_op + np.diag(t0 * rho_n)\n            \n            pred_orbitals = [phi - 1j * dt * (H_n @ phi) for phi in orbitals]\n            \n            rho_pred = np.sum([np.abs(o)**2 for o in pred_orbitals], axis=0)\n            H_pred = T_op + np.diag(t0 * rho_pred)\n            \n            H_avg = 0.5 * (H_n + H_pred)\n            \n            # Corrector\n            A = np.eye(N) + (0.5j * dt) * H_avg\n            B = np.eye(N) - (0.5j * dt) * H_avg\n            \n            next_orbitals_unorth = [np.linalg.solve(A, B @ phi) for phi in orbitals]\n            \n            orbitals = lowdin_orthonormalize(next_orbitals_unorth, dx)\n            \n        return orbitals\n\n    def run_split_op_propagation(params, initial_orbitals, dx, k_vec):\n        \"\"\"\n        Propagates orbitals using the Split-Operator (Strang) method.\n        \"\"\"\n        L, N, dt, T, t0 = params\n        n_steps = int(round(T / dt))\n        orbitals = [o.copy() for o in initial_orbitals]\n        \n        kin_propagator = np.exp(-0.5j * dt * k_vec**2)\n\n        for _ in range(n_steps):\n            # First half potential step\n            rho_n = np.sum([np.abs(o)**2 for o in orbitals], axis=0)\n            U_n = t0 * rho_n\n            pot_prop_half_1 = np.exp(-0.5j * dt * U_n)\n            temp_orbitals_1 = [pot_prop_half_1 * phi for phi in orbitals]\n            \n            # Full kinetic step\n            temp_orbitals_2 = []\n            for phi in temp_orbitals_1:\n                phi_k = np.fft.fft(phi)\n                phi_k_prop = kin_propagator * phi_k\n                temp_orbitals_2.append(np.fft.ifft(phi_k_prop))\n            \n            # Second half potential step (with updated density)\n            rho_mid = np.sum([np.abs(o)**2 for o in temp_orbitals_2], axis=0)\n            U_mid = t0 * rho_mid\n            pot_prop_half_2 = np.exp(-0.5j * dt * U_mid)\n            next_orbitals_unorth = [pot_prop_half_2 * phi for phi in temp_orbitals_2]\n            \n            orbitals = lowdin_orthonormalize(next_orbitals_unorth, dx)\n            \n        return orbitals\n\n    results = []\n    for case in test_cases:\n        L, N, dt, T, t0 = case\n        dx = L / N\n        sigma = L / 20.0\n        k0 = 2 * np.pi / L\n        k_vec = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n        # Generate initial state and compute initial energy\n        initial_orbitals = create_initial_orbitals(L, N, sigma, k0, dx)\n        E0 = calculate_energy(initial_orbitals, t0, L, N, dx, k_vec)\n\n        # Run Crank-Nicolson\n        final_orbitals_cn = run_cn_propagation(case, initial_orbitals, dx, k_vec)\n        E_final_cn = calculate_energy(final_orbitals_cn, t0, L, N, dx, k_vec)\n        delta_E_cn = np.abs(E_final_cn - E0)\n\n        # Run Split-Operator\n        final_orbitals_split = run_split_op_propagation(case, initial_orbitals, dx, k_vec)\n        E_final_split = calculate_energy(final_orbitals_split, t0, L, N, dx, k_vec)\n        delta_E_split = np.abs(E_final_split - E0)\n        \n        results.append(delta_E_cn = delta_E_split)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}