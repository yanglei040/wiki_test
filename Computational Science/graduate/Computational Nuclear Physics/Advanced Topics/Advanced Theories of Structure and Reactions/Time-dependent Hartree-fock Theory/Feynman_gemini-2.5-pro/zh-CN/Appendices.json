{
    "hands_on_practices": [
        {
            "introduction": "在编写复杂的模拟代码之前，至关重要的是要理解我们所使用的数值算符的基本属性。本练习旨在为构建时间相关哈特里-福克（TDHF）求解器奠定基础，通过分析一种常见的空间离散化方案，来研究其如何影响基本守恒定律。通过推导一个被加速的核在自由演化过程中由离散化引起的伪中心质量加速度 ，您将深入了解周期性边界条件下中心差分拉普拉斯算子的一个关键性质，并理解数值方法如何能够（或不能够）精确地保持连续物理学中的伽利略不变性。",
            "id": "3609608",
            "problem": "考虑一个有限的、自束缚的原子核的一维含时 Hartree-Fock (TDHF) 动力学，该原子核被建模为一个由 $A$ 个质量为 $m$ 的相同核子组成的 Slater 行列式。在没有外部势场的情况下，平均场哈密顿量简化为动能算符，因此每个被占据的单粒子轨道都遵循自由粒子方程 $i \\hbar \\partial_{t} \\varphi_{i}(x,t) = - \\frac{\\hbar^{2}}{2 m} \\partial_{x}^{2} \\varphi_{i}(x,t)$，其中 $i=1,\\dots,A$。系统在一个长度为 $L$、包含 $N$ 个点、间距为 $a = L/N$ 的均匀空间网格上表示，并采用周期性边界条件。空间拉普拉斯算子使用标准的二阶中心差分进行近似，\n$$\n(\\Delta_{a} \\psi)_{j} \\equiv \\frac{\\psi_{j+1} - 2 \\psi_{j} + \\psi_{j-1}}{a^{2}} ,\n$$\n并在边界处进行周期性环绕处理。\n\n在时间 $t=0$ 时，准备一个由轨道 $\\{\\varphi_{i}^{(0)}(x)\\}$ 描述的静止局域化原子核，其密度 $\\rho_{0}(x) = \\sum_{i=1}^{A} |\\varphi_{i}^{(0)}(x)|^{2}$ 的紧支撑集完全位于盒子内部。通过为每个轨道乘以一个共同的平面波相位来施加一个质心 (COM) 助推，使得初始条件为\n$$\n\\varphi_{i}(x,0) = \\exp(i k_{0} x)\\, \\varphi_{i}^{(0)}(x) ,\n$$\n其中波数 $k_{0}$ 从与周期性兼容的离散集合中选取，$k_{0} = \\frac{2 \\pi \\ell}{L}$，$\\ell$ 为某个整数。假设时间演化是使用一个对离散化哈密顿量完全幺正的积分器进行的（没有时间离散化误差），因此只有空间离散化和边界条件会产生人为误差。\n\n从第一性原理和上述定义出发，执行以下步骤：\n\n1) 对于周期性网格上的离散拉普拉斯算子 $\\Delta_{a}$，推导数值色散关系 $\\omega_{a}(k)$，使得离散傅里叶模式 $\\psi_{j} \\propto \\exp(i k x_{j})$ (其中 $x_{j} = j a$) 在离散化的自由演化下满足 $i \\hbar \\partial_{t} \\psi_{j} = \\hbar \\omega_{a}(k) \\psi_{j}$。\n\n2) 从 $\\omega_{a}(k)$ 得到离散群速度 $v_{a}(k) \\equiv \\frac{d \\omega_{a}}{d k}$。\n\n3) 利用助推后的 Slater 行列式结构和周期性边界条件，确定在网格上自由演化期间的质心轨迹 $X_{\\mathrm{cm}}(t) \\equiv \\frac{1}{A} \\sum_{i=1}^{A} \\int_{0}^{L} x\\, |\\varphi_{i}(x,t)|^{2}\\, dx$，此过程处于密度保持局域化且不与其周期性镜像相互作用的区域。\n\n4) 将赝质心加速度定义为 $a_{\\mathrm{spurious}} \\equiv \\frac{d^{2} X_{\\mathrm{cm}}(t)}{d t^{2}}$，该加速度纯粹是由所选的空间离散化和自由演化中的周期性边界条件组合引起的。提供一个关于 $k_{0}$ 和 $a$ 的 $a_{\\mathrm{spurious}}$ 的单一、闭式解析表达式。\n\n只需报告 $a_{\\mathrm{spurious}}(k_{0},a)$ 的最终解析表达式作为你的答案。不要代入数值。如果选择使用角度表示，请以弧度为单位。最终答案必须是一个单一的符号表达式。",
            "solution": "用户想要找到一个由 $A$ 个自由核子组成的系统在一维周期性网格上演化时的赝质心加速度。\n\n### 步骤 1：问题验证\n\n首先对问题进行严格验证。\n\n1.  **提取已知条件**：\n    -   系统：一维空间中 $A$ 个质量为 $m$ 的相同核子。\n    -   框架：含时 Hartree-Fock (TDHF)，简化为自由粒子演化。\n    -   单粒子方程：$i \\hbar \\partial_{t} \\varphi_{i}(x,t) = - \\frac{\\hbar^{2}}{2 m} \\partial_{x}^{2} \\varphi_{i}(x,t)$ 对于 $i=1,\\dots,A$。\n    -   空间域：长度为 $L$、有 $N$ 个点、间距为 $a = L/N$ 的均匀网格，采用周期性边界条件。\n    -   离散拉普拉斯算子：$(\\Delta_{a} \\psi)_{j} \\equiv \\frac{\\psi_{j+1} - 2 \\psi_{j} + \\psi_{j-1}}{a^{2}}$。\n    -   初始条件：$\\varphi_{i}(x,0) = \\exp(i k_{0} x)\\, \\varphi_{i}^{(0)}(x)$，其中 $\\{\\varphi_{i}^{(0)}(x)\\}$ 描述一个静止的原子核，且 $k_{0} = \\frac{2 \\pi \\ell}{L}$。\n    -   时间积分：对离散化哈密顿量完全幺正。\n    -   质心 (COM) 定义：$X_{\\mathrm{cm}}(t) \\equiv \\frac{1}{A} \\sum_{i=1}^{A} \\int_{0}^{L} x\\, |\\varphi_{i}(x,t)|^{2}\\, dx$。\n    -   赝加速度定义：$a_{\\mathrm{spurious}} \\equiv \\frac{d^{2} X_{\\mathrm{cm}}(t)}{d t^{2}}$。\n\n2.  **使用提取的已知条件进行验证**：\n    -   **科学依据**：该问题在计算量子力学的标准框架中有充分的依据，涉及薛定谔方程离散化产生的数值误差。数值色散、周期性边界条件和中心差分近似等概念都是标准的。\n    -   **适定性和客观性**：该问题在数学上是适定的，提供了所有必要的算符、初始条件和定义。语言精确、客观。\n    -   **完整性和一致性**：问题是自洽的。所提供的定义彼此一致。\n    -   **可行性**：这是一个理论练习，可以从第一性原理出发解决。\n    -   **不适定性/平凡性**：问题设置导致一个特定的、可能与直觉相反的结果，但并非不适定。推导过程需要在离散格点上仔细应用算符代数。虽然看起来复杂，但最终结果可能很简单，但这并不会使问题无效，反而考验了解题者的严谨性。\n\n3.  **结论与行动**：问题被判定为**有效**。我们继续进行求解。如果存在通往最终答案的更直接路径，则问题的结构不要求解出所要求的中间步骤（如色散关系、群速度等）。我们将寻求最直接、最严谨的路径。\n\n### 步骤 2：赝加速度的推导\n\n赝加速度被定义为质心位置期望值的二阶时间导数。根据 Ehrenfest 定理，对于一个不含时的哈密顿量 $H_{\\mathrm{total}}$，质心的加速度由算符 $\\hat{a}_{\\mathrm{cm}} = -\\frac{1}{\\hbar^2} [[\\hat{X}_{\\mathrm{cm}}, H_{\\mathrm{total}}], H_{\\mathrm{total}}]$ 的期望值给出。\n\n总哈密顿量 $H_{\\mathrm{total}}$ 是单粒子哈密顿量的总和，$H_{\\mathrm{total}} = \\sum_{j=1}^{A} H_a^{(j)}$，其中 $H_a^{(j)}$ 是第 $j$ 个粒子的离散化动能算符。质心算符为 $\\hat{X}_{\\mathrm{cm}} = \\frac{1}{A} \\sum_{i=1}^{A} \\hat{x}_i$。\n\n由于不同粒子的算符相互对易（例如，当 $i \\neq j$ 时 $[\\hat{x}_i, H_a^{(j)}] = 0$），双对易子简化为：\n$$\n[[\\hat{X}_{\\mathrm{cm}}, H_{\\mathrm{total}}], H_{\\mathrm{total}}] = \\frac{1}{A} \\sum_{i=1}^{A} [[\\hat{x}_i, H_a^{(i)}], H_a^{(i)}]\n$$\n因此，质心加速度是单粒子加速度的平均值：\n$$\na_{\\mathrm{spurious}}(t) = \\langle \\hat{a}_{\\mathrm{cm}} \\rangle(t) = \\frac{1}{A} \\sum_{i=1}^{A} \\langle \\hat{a}_i \\rangle_{\\varphi_i(t)}\n$$\n其中单粒子加速度算符为 $\\hat{a} = -\\frac{1}{\\hbar^2} [[\\hat{x}, H_a], H_a]$。我们必须确定这个算符是否为零。\n\n网格上单个粒子的离散化哈密顿量为：\n$$\nH_a = -\\frac{\\hbar^2}{2m} \\Delta_a = -\\frac{\\hbar^2}{2m a^2} (\\psi_{j+1} - 2\\psi_j + \\psi_{j-1})\n$$\n为了分析对易子，我们引入网格平移算符 $\\hat{T}$，定义为 $(\\hat{T}\\psi)_j = \\psi_{j+1}$。其逆算符为 $(\\hat{T}^{-1}\\psi)_j = \\psi_{j-1}$。离散拉普拉斯算符可以写成 $\\Delta_a = \\frac{1}{a^2}(\\hat{T} + \\hat{T}^{-1} - 2\\hat{I})$，其中 $\\hat{I}$ 是单位算符。\n\n网格上的位置算符 $\\hat{x}$ 的作用是乘以坐标 $x_j = ja$：$(\\hat{x}\\psi)_j = j a \\psi_j$。\n\n首先，我们计算内层对易子 $[\\hat{x}, H_a]$：\n$$\n[\\hat{x}, H_a] = \\left[\\hat{x}, -\\frac{\\hbar^2}{2m a^2}(\\hat{T} + \\hat{T}^{-1} - 2\\hat{I})\\right] = -\\frac{\\hbar^2}{2m a^2} ([\\hat{x}, \\hat{T}] + [\\hat{x}, \\hat{T}^{-1}])\n$$\n让我们计算 $\\hat{x}$ 与 $\\hat{T}$ 的对易子。将其作用于一个态 $\\psi$：\n$$\n([\\hat{x}, \\hat{T}]\\psi)_j = (\\hat{x}\\hat{T}\\psi)_j - (\\hat{T}\\hat{x}\\psi)_j = x_j (\\hat{T}\\psi)_j - \\hat{T}(x_j \\psi_j) = (ja) \\psi_{j+1} - x_{j+1} \\psi_{j+1} = ja \\psi_{j+1} - (j+1)a \\psi_{j+1} = -a \\psi_{j+1} = -a (\\hat{T}\\psi)_j\n$$\n这给出了算符关系 $[\\hat{x}, \\hat{T}] = -a \\hat{T}$。类似地，$[\\hat{x}, \\hat{T}^{-1}] = a \\hat{T}^{-1}$。\n将这些代入 $[\\hat{x}, H_a]$ 的表达式中：\n$$\n[\\hat{x}, H_a] = -\\frac{\\hbar^2}{2m a^2} (-a \\hat{T} + a \\hat{T}^{-1}) = \\frac{\\hbar^2}{2m a} (\\hat{T} - \\hat{T}^{-1})\n$$\n现在，我们计算外层对易子 $[[\\hat{x}, H_a], H_a]$：\n$$\n[[\\hat{x}, H_a], H_a] = \\left[\\frac{\\hbar^2}{2m a} (\\hat{T} - \\hat{T}^{-1}), -\\frac{\\hbar^2}{2m a^2}(\\hat{T} + \\hat{T}^{-1} - 2\\hat{I})\\right] = -\\frac{\\hbar^4}{4m^2 a^3} [\\hat{T} - \\hat{T}^{-1}, \\hat{T} + \\hat{T}^{-1} - 2\\hat{I}]\n$$\n平移算符 $\\hat{T}$ 及其逆算符 $\\hat{T}^{-1}$ 对易，即 $[\\hat{T}, \\hat{T}^{-1}] = \\hat{T}\\hat{T}^{-1} - \\hat{T}^{-1}\\hat{T} = \\hat{I} - \\hat{I} = 0$。由于 $\\hat{T}$ 和 $\\hat{T}^{-1}$ 与自身以及单位算符 $\\hat{I}$ 对易，它们与任何是 $\\hat{T}$、$\\hat{T}^{-1}$ 和 $\\hat{I}$ 的函数的算符都对易。\n因此，我们计算对易子：\n$$\n[\\hat{T} - \\hat{T}^{-1}, \\hat{T} + \\hat{T}^{-1} - 2\\hat{I}] = [\\hat{T}, \\hat{T}] + [\\hat{T}, \\hat{T}^{-1}] - 2[\\hat{T}, \\hat{I}] - [\\hat{T}^{-1}, \\hat{T}] - [\\hat{T}^{-1}, \\hat{T}^{-1}] + 2[\\hat{T}^{-1}, \\hat{I}]\n$$\n这个和中的所有单个对易子都为零。例如，$[\\hat{T}, \\hat{T}] = 0$ 和 $[\\hat{T}, \\hat{T}^{-1}] = 0$。\n因此，$[\\hat{T} - \\hat{T}^{-1}, \\hat{T} + \\hat{T}^{-1} - 2\\hat{I}] = 0$。\n\n这直接意味着双对易子为零：\n$$\n[[\\hat{x}, H_a], H_a] = 0\n$$\n单粒子加速度算符 $\\hat{a}$ 是恒等于零的算符。因此，总加速度算符 $\\hat{a}_{\\mathrm{cm}}$ 也是零算符。\n\n零算符的期望值对于任何态 $\\Psi(t)$ 总是零。\n$$\na_{\\mathrm{spurious}} = \\langle \\hat{a}_{\\mathrm{cm}} \\rangle = 0\n$$\n由拉普拉斯算子的二阶中心差分和周期性边界条件的特定组合所产生的赝质心加速度恰好为零。问题的框架可能暗示存在一个复杂的、非零的人为误差，但基于所提供定义的严格代数评估表明，对于这种特定的离散化方案，自由粒子的伽利略不变性的离散等价性以一种阻止质心加速的方式被保留了。\n\n最终答案：赝加速度恒等于零。",
            "answer": "$$ \\boxed{0} $$"
        },
        {
            "introduction": "TDHF 理论是研究核反应动力学（如聚变或粒子发射）的有力工具。由于模拟空间网格是有限的，我们必须实现一个机制来吸收离开相互作用区域的粒子，以防止它们在网格边界发生非物理反射。本练习提供了一个实现该功能的实用方法，即使用复吸收势（CAP），这是一个在现代核理论计算中无处不在的技术。通过为一个出射波包实现和测试吸收边界条件，您将获得处理开放量子系统和确保模拟保真度的第一手经验。",
            "id": "3609650",
            "problem": "为一维出射单粒子波包实现并验证一个吸收边界条件，该问题出现在含时Hartree-Fock (TDHF) 理论的单粒子方程中。在独立粒子极限下，每个被占据的单粒子轨道根据带有自洽平均场哈密顿量的类含时薛定谔方程演化。在本问题中，您将考虑一个在自由空间中传播的轨道，并通过添加一个复吸收势 (CAP) 来实现吸收边界条件。该势表示为一个纯虚势，在靠近空间边界的薄层中对波进行衰减。\n\n从基本出发点开始：一维空间中单个轨道的含时薛定谔方程，\n$$\ni \\hbar \\frac{\\partial \\psi(x,t)}{\\partial t} = \\left[ -\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} + V(x) \\right] \\psi(x,t),\n$$\n其中 $m$ 是粒子质量，$V(x)$ 是一个势。在含时Hartree-Fock (TDHF) 理论的独立粒子极限下，每个被占据的单粒子轨道都遵循这个带有平均场哈密顿量的方程。为了本次计算测试的目的，采用自由平均场，使 $V(x)$ 的实部为零，并通过复吸收势 $V_{\\mathrm{CAP}}(x) = -i \\eta(x)$ 来实现吸收边界条件，其中 $\\eta(x) \\ge 0$ 仅在边界层内非零。\n\n在自然单位制（$\\hbar = 1$ 和 $m = 1$）下进行计算。在具有 $N$ 个点的均匀网格 $x \\in [-L,L]$ 上对空间进行离散化，并在端点处强制施加狄利克雷边界值。使用均匀时间步长 $\\Delta t$ 对时间进行离散化。使用一种从第一性原理推导出的时间步进格式来传播波函数，该格式在没有吸收的情况下是无条件稳定且保范的（例如，应用于哈密顿算符的Crank-Nicolson格式）。空间二阶导数必须由均匀网格上的标准中心有限差分格式表示。复吸收势必须实现为一个纯虚势，在靠近每个边界的宽度为 $w$ 的层上平滑地开启：\n$$\n\\eta(x) = \\begin{cases}\n\\eta_0 \\left(\\dfrac{|x| - (L - w)}{w}\\right)^m,  \\text{if } |x| > L - w, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其参数为 $\\eta_0 \\ge 0$、$w \\ge 0$ 以及平滑指数 $m \\in \\{1,2,3,\\dots\\}$。如果 $w = 0$，则设 $\\eta(x) \\equiv 0$。\n\n用指定的动能 $E_0$ 初始化一个归一化的向右移动的高斯波包：\n$$\n\\psi(x,0) \\propto \\exp\\!\\left(-\\frac{(x-x_0)^2}{4\\sigma^2} + i p_0 x \\right), \\quad p_0 = \\sqrt{2 E_0},\n$$\n其平均位置 $x_0$ 严格位于域内，宽度为 $\\sigma$，平均动量 $p_0$ 为正。选择参数，使波包向右传播，与右边界的吸收层相互作用，并且任何反射分量都可以在模拟时间窗口内返回其初始位置附近。在端点使用狄利克雷条件。\n\n定义一个以 $x_0$ 为中心、半宽为 $\\delta$ 的监测窗口，并使用以下定量诊断来测量反射：\n$$\nR \\equiv \\frac{\\displaystyle \\int_{x_0 - \\delta}^{x_0 + \\delta} |\\psi(x,T)|^2 \\, dx}{\\displaystyle \\int_{x_0 - \\delta}^{x_0 + \\delta} |\\psi(x,0)|^2 \\, dx},\n$$\n其中 $T$ 是一个足够大的最终时间，使得任何来自右边界的显著反射都有时间返回到 $x_0$ 附近。量 $R$ 是无量纲的。\n\n实现该算法，并为以下吸收层参数测试套件生成 $R$ 的数值，所有测试都在相同的波包能量下进行：\n- 空间域半长 $L = 4$，点数 $N = 512$，时间步长 $\\Delta t = 0.002$，总时间 $T = 10.0$。\n- 初始波包参数：$x_0 = -1.0$，$\\sigma = 0.3$，$E_0 = 0.5$（所以 $p_0 = \\sqrt{2 E_0}$），监测半宽 $\\delta = 0.25$。\n- 吸收体参数集 $(\\eta_0, w, m)$:\n    1. $(0.0, 0.0, 2)$,\n    2. $(0.5, 1.0, 2)$,\n    3. $(2.0, 1.5, 3)$,\n    4. $(10.0, 0.25, 1)$。\n\n您的程序必须：\n- 使用应用于带有复吸收势的自由哈密顿量的Crank-Nicolson更新方案的第一性原理推导，对波包从 $t=0$ 到 $t=T$ 进行离散化和传播。\n- 对于每个吸收体参数集，计算如上定义的 $R$。\n- 生成单行输出，其中包含值 $[R_1,R_2,R_3,R_4]$，为小数点后六位的十进制浮点数，并严格按照测试套件的顺序排列。\n\n最终输出格式必须是严格的一行，包含一个由四个逗号分隔的浮点数组成的Python风格列表字面量，例如，\"[0.123456,0.234567,0.345678,0.456789]\"。",
            "solution": "我们从一维含时薛定谔方程开始，\n$$\ni \\hbar \\frac{\\partial \\psi(x,t)}{\\partial t} = \\left[-\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} + V(x) \\right]\\psi(x,t),\n$$\n并在自然单位制（$\\hbar = 1$ 和 $m = 1$）下进行计算。在含时Hartree-Fock (TDHF) 理论的独立粒子图像中，每个被占据的单粒子轨道都遵循这种形式的方程，其中包含一个自洽平均场势。在这里，为了独立处理边界问题，我们将平均场势的实部设为零，并将吸收边界实现为复吸收势 (CAP)，即 $V_{\\mathrm{CAP}}(x) = -i \\eta(x)$，其中 $\\eta(x) \\ge 0$ 仅在域边界附近有支撑。\n\n我们选择一个均匀网格 $x_j = -L + j \\Delta x$，其中 $j=0,1,\\dots,N-1$，$\\Delta x = 2L/(N-1)$，并施加狄利克雷边界条件 $\\psi(x_0,t) = \\psi(x_{N-1},t) = 0$。对于内部点，空间二阶导数由二阶中心差分近似，\n$$\n\\frac{\\partial^2 \\psi}{\\partial x^2}(x_j,t) \\approx \\frac{\\psi_{j+1}(t) - 2 \\psi_j(t) + \\psi_{j-1}(t)}{(\\Delta x)^2}, \\quad j = 1,2,\\dots,N-2.\n$$\n作用于内部值的哈密顿量可以写成一个三对角算符，\n$$\n(H \\psi)_j = -\\frac{1}{2}\\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{(\\Delta x)^2} + V_j \\psi_j, \\quad V_j = -i \\eta(x_j),\n$$\n固定边界值为零 $\\psi_0 = \\psi_{N-1} = 0$。\n\n对于时间演化，我们采用Crank-Nicolson格式，它源于将梯形法则应用于薛定谔方程：\n$$\n\\left(I + \\frac{i \\Delta t}{2} H \\right)\\psi^{n+1} = \\left(I - \\frac{i \\Delta t}{2} H \\right)\\psi^n,\n$$\n其中 $\\psi^n$ 是在时间 $t_n = n \\Delta t$ 时的波函数。在没有虚势的情况下，该格式是无条件稳定且严格保范的；在有复吸收势的情况下，它将在吸收区域内使范数减小。\n\n让我们用一个三对角矩阵来表示 $H$ 对内部节点的作用。使用 $m=1$ 和 $\\hbar=1$，动能算符提供了系数为 $-1/(2 (\\Delta x)^2)$ 的邻近耦合项，而对角线上的动能贡献 $+1/(\\Delta x)^2$ 来自于 $-2\\psi_j$ 项。因此，对于内部索引 $j=1,\\dots,N-2$，\n- 非对角动能项贡献 $\\pm \\left(-\\frac{1}{2(\\Delta x)^2}\\right) \\psi_{j\\pm 1}$，\n- 对角动能项贡献 $+\\left(\\frac{1}{(\\Delta x)^2}\\right)\\psi_j$，\n- 对角势能项贡献 $+ V_j \\psi_j$，\n所以 $H$ 的对角元为 $H_{jj} = \\frac{1}{(\\Delta x)^2} + V_j$，非对角元为 $H_{j,j\\pm 1} = -\\frac{1}{2(\\Delta x)^2}$。\n\n将此三对角结构代入Crank-Nicolson更新公式，我们得到两个三对角矩阵：\n$$\nA \\equiv I + \\frac{i \\Delta t}{2} H, \\quad B \\equiv I - \\frac{i \\Delta t}{2} H,\n$$\n更新步骤为 $A \\psi^{n+1} = B \\psi^n$。具体来说，对于内部点，\n- 对于 $A$，对角元为\n$$\nA_{jj} = 1 + \\frac{i \\Delta t}{2}\\left(\\frac{1}{(\\Delta x)^2} + V_j\\right),\n$$\n非对角元为\n$$\nA_{j,j\\pm 1} = \\frac{i \\Delta t}{2}\\left(-\\frac{1}{2(\\Delta x)^2}\\right) = - i \\frac{\\Delta t}{4 (\\Delta x)^2}.\n$$\n- 对于 $B$，对角元为\n$$\nB_{jj} = 1 - \\frac{i \\Delta t}{2}\\left(\\frac{1}{(\\Delta x)^2} + V_j\\right),\n$$\n非对角元为\n$$\nB_{j,j\\pm 1} = -\\frac{i \\Delta t}{2}\\left(-\\frac{1}{2(\\Delta x)^2}\\right) = + i \\frac{\\Delta t}{4 (\\Delta x)^2}.\n$$\n\n由于 $\\psi_0 = \\psi_{N-1} = 0$，更新方程仅耦合内部向量 $\\mathbf{\\psi}_{\\mathrm{int}}^n = (\\psi_1^n,\\dots,\\psi_{N-2}^n)^\\top$。设 $n_{\\mathrm{int}} = N - 2$。在向量形式中，我们通过构建 $\\mathbf{d}^n = B \\mathbf{\\psi}^n_{\\mathrm{int}}$ 然后求解三对角线性系统 $A \\mathbf{\\psi}^{n+1}_{\\mathrm{int}} = \\mathbf{d}^n$ 来计算每一步。因为对于固定的 $\\eta(x)$，$A$ 是不随时间变化的，所以这个系统可以在每个时间步使用Thomas算法和预先计算的前向消元分解来高效求解。\n\n复吸收势设置为\n$$\n\\eta(x) = \\begin{cases}\n\\eta_0 \\left(\\dfrac{|x| - (L - w)}{w}\\right)^m,  \\text{if } |x| > L - w, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n它从内边缘 $|x| = L - w$ 处的零平滑地增加到边界 $|x| = L$ 处的最大值。平滑指数 $m$ 控制势增长的平缓程度；较大的 $m$ 通过更平滑地匹配导数来减少伪反射，但代价是需要更宽的层才能达到相同的衰减效果。\n\n我们初始化一个动能为 $E_0$、平均动量为 $p_0 = \\sqrt{2 E_0}$ 的向右移动的高斯波包，\n$$\n\\psi(x,0) = \\mathcal{N} \\exp\\!\\left(-\\frac{(x-x_0)^2}{4 \\sigma^2} + i p_0 x \\right),\n$$\n其中 $\\mathcal{N}$ 是一个归一化常数，通过数值方法确定以确保 $\\int |\\psi(x,0)|^2 dx = 1$。在 $x_0$ 严格位于域内且 $p_0 > 0$ 的情况下，波包以群速度 $v = p_0/m = p_0$（在我们的单位制中）向右传播，到达右边界层，并根据CAP参数被吸收或部分反射。\n\n为了量化吸收质量，我们定义一个以 $x_0$ 为中心、半宽为 $\\delta$ 的监测窗口，并测量反射比\n$$\nR = \\frac{\\displaystyle \\int_{x_0 - \\delta}^{x_0 + \\delta} |\\psi(x,T)|^2 \\, dx}{\\displaystyle \\int_{x_0 - \\delta}^{x_0 + \\delta} |\\psi(x,0)|^2 \\, dx}.\n$$\n选择最终时间 $T$ 以确保在没有吸收的情况下，反射波有时间从右边界返回到初始区域；若吸收良好，$R$ 将会很小。积分通过在监测窗口内的网格点上使用离散求和 $\\int f(x)\\,dx \\approx \\Delta x \\sum_j f(x_j)$ 进行数值计算。\n\n算法步骤：\n1. 设置物理和数值参数：$L$、$N$、$\\Delta t$、$T$、$x_0$、$\\sigma$、$E_0$、$\\delta$。\n2. 构建网格 $x_j$ 并初始化 $\\psi(x,0)$，然后对其进行归一化。\n3. 对每个CAP参数集 $(\\eta_0,w,m)$：\n   - 在网格上构建 $\\eta(x)$。\n   - 构建 $V_j = -i \\eta(x_j)$ 并为内部点构建三对角矩阵 $A$ 和 $B$。\n   - 为与 $A$ 相关的Thomas算法预计算前向消元系数。\n   - 通过重复计算 $\\mathbf{d}^n = B \\mathbf{\\psi}^n_{\\mathrm{int}}$ 和求解 $A \\mathbf{\\psi}^{n+1}_{\\mathrm{int}} = \\mathbf{d}^n$ 进行从 $t=0$到 $t=T$ 的时间步进。\n   - 在 $t=0$ 和 $t=T$ 时使用监测区域计算 $R$。\n4. 按指定测试套件的顺序，单行输出反射比 $[R_1,R_2,R_3,R_4]$。\n\n测试套件的预期定性行为：\n- 对于 $(\\eta_0,w,m) = (0,0,2)$，没有吸收存在，狄利克雷边界就像一堵硬墙；反射波返回，导致 $R$ 值很大。\n- 对于一个弱但有限的吸收体 $(\\eta_0,w,m) = (0.5,1.0,2)$，会发生一些衰减，但反射仍然很明显；$R$ 相对于没有吸收体的情况有所减小。\n- 对于一个平滑且足够强的吸收体 $(\\eta_0,w,m) = (2.0,1.5,3)$，反射被强烈抑制，$R$ 值很小。\n- 对于一个过强且非常薄的吸收体 $(\\eta_0,w,m) = (10.0,0.25,1)$，突兀的开启会导致显著的伪反射；$R$ 值再次增加。\n\n由于选择了 $\\hbar = 1$ 和 $m = 1$，这里所有的量都是无量纲的。最终程序计算出四个 $R$ 值，并以要求的小数点后六位的单行列表格式打印它们。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef thomas_precompute(a, b, c):\n    \"\"\"\n    Precompute coefficients for the Thomas algorithm (tridiagonal solver).\n    a: lower diagonal (length n-1), entries a[i] corresponds to row i+1\n    b: main diagonal (length n)\n    c: upper diagonal (length n-1), entries c[i] corresponds to row i\n    Returns:\n        cp: modified upper diagonal coefficients (length n-1)\n        inv_denom: inverse of the modified main diagonal (length n)\n    \"\"\"\n    n = b.size\n    cp = np.zeros(n - 1, dtype=np.complex128)\n    inv_denom = np.zeros(n, dtype=np.complex128)\n\n    inv_denom[0] = 1.0 / b[0]\n    if n - 1 > 0:\n        cp[0] = c[0] * inv_denom[0]\n    for i in range(1, n - 1):\n        denom = b[i] - a[i - 1] * cp[i - 1]\n        inv_denom[i] = 1.0 / denom\n        cp[i] = c[i] * inv_denom[i]\n    if n > 1:\n        denom_last = b[-1] - a[-1] * cp[-1]\n        inv_denom[-1] = 1.0 / denom_last\n    return cp, inv_denom\n\ndef thomas_solve(a, b, c, cp, inv_denom, d):\n    \"\"\"\n    Solve A x = d for tridiagonal A with precomputed cp and inv_denom.\n    a: lower diagonal (length n-1)\n    b: main diagonal (length n) (not used directly here, but kept for signature consistency)\n    c: upper diagonal (length n-1)\n    cp: precomputed modified upper diagonal (length n-1)\n    inv_denom: precomputed inverse denominators (length n)\n    d: right-hand side (length n)\n    Returns:\n        x: solution vector (length n)\n    \"\"\"\n    n = d.size\n    dp = np.empty(n, dtype=np.complex128)\n    # Forward substitution using precomputed inv_denom\n    dp[0] = d[0] * inv_denom[0]\n    for i in range(1, n):\n        dp[i] = (d[i] - a[i - 1] * dp[i - 1]) * inv_denom[i]\n    # Back substitution using cp\n    x = np.empty(n, dtype=np.complex128)\n    x[-1] = dp[-1]\n    for i in range(n - 2, -1, -1):\n        x[i] = dp[i] - cp[i] * x[i + 1]\n    return x\n\ndef build_cap(x, L, eta0, w, m_order):\n    \"\"\"\n    Build the complex absorbing potential strength eta(x) over the grid x.\n    If w = 0 or eta0 == 0, returns zeros.\n    \"\"\"\n    eta = np.zeros_like(x, dtype=np.float64)\n    if eta0 == 0.0 or w == 0.0:\n        return eta\n    # Distance beyond inner edge of absorber\n    inner_edge = L - w\n    dist = np.abs(x) - inner_edge\n    dist = np.where(dist > 0.0, dist, 0.0)\n    s = dist / w\n    # Avoid numerical issues exactly at boundary\n    s = np.clip(s, 0.0, 1.0)\n    eta = eta0 * (s ** m_order)\n    return eta\n\ndef run_case(eta0, w, m_order, params):\n    \"\"\"\n    Run one simulation case and return reflection ratio R.\n    params: dict with keys L, N, dt, T, x0, sigma, E0, delta\n    \"\"\"\n    L = params[\"L\"]\n    N = params[\"N\"]\n    dt = params[\"dt\"]\n    T = params[\"T\"]\n    x0 = params[\"x0\"]\n    sigma = params[\"sigma\"]\n    E0 = params[\"E0\"]\n    delta = params[\"delta\"]\n\n    # Grid\n    x = np.linspace(-L, L, N, endpoint=True)\n    dx = x[1] - x[0]\n\n    # Initial Gaussian wave packet\n    p0 = np.sqrt(2.0 * E0)\n    psi = np.exp(-((x - x0) ** 2) / (4.0 * sigma ** 2) + 1j * p0 * x).astype(np.complex128)\n    # Enforce Dirichlet at the endpoints\n    psi[0] = 0.0 + 0.0j\n    psi[-1] = 0.0 + 0.0j\n    # Normalize\n    norm0 = np.sqrt(np.sum(np.abs(psi) ** 2) * dx)\n    psi /= norm0\n\n    # Build CAP and potential\n    eta = build_cap(x, L, eta0, w, m_order)\n    V = -1j * eta  # purely imaginary potential\n\n    # Crank–Nicolson matrices for interior points\n    n_int = N - 2\n    # Constants\n    inv_dx2 = 1.0 / (dx * dx)\n    off_fac = dt / (4.0 * dx * dx)\n    # Diagonals for A and B (interior)\n    V_int = V[1:-1]\n    # A = I + i dt/2 H\n    bA = (1.0 + 1j * (dt / 2.0) * (inv_dx2 + V_int)).astype(np.complex128)\n    aA = (-1j * off_fac) * np.ones(n_int - 1, dtype=np.complex128)\n    cA = (-1j * off_fac) * np.ones(n_int - 1, dtype=np.complex128)\n    # B = I - i dt/2 H\n    bB = (1.0 - 1j * (dt / 2.0) * (inv_dx2 + V_int)).astype(np.complex128)\n    aB = (1j * off_fac) * np.ones(n_int - 1, dtype=np.complex128)\n    cB = (1j * off_fac) * np.ones(n_int - 1, dtype=np.complex128)\n\n    # Precompute Thomas algorithm coefficients for A\n    cp, inv_denom = thomas_precompute(aA, bA, cA)\n\n    # Prepare time stepping\n    steps = int(np.round(T / dt))\n    # Monitor region mask\n    mask = (x >= (x0 - delta))  (x = (x0 + delta))\n    # Initial monitor probability\n    P_init = np.sum((np.abs(psi) ** 2) * mask) * dx\n\n    # Time propagation\n    psi_int = psi[1:-1].copy()\n    for _ in range(steps):\n        # Compute d = B * psi_int (tri-diagonal multiplication)\n        d = bB * psi_int\n        # Lower diagonal contribution (from j-1): rows 1..n_int-1\n        d[1:] += aB * psi_int[:-1]\n        # Upper diagonal contribution (from j+1): rows 0..n_int-2\n        d[:-1] += cB * psi_int[1:]\n        # Solve A * psi_next_int = d\n        psi_int = thomas_solve(aA, bA, cA, cp, inv_denom, d)\n\n    # Assemble full psi at final time\n    psi_final = np.zeros_like(psi)\n    psi_final[0] = 0.0 + 0.0j\n    psi_final[-1] = 0.0 + 0.0j\n    psi_final[1:-1] = psi_int\n\n    P_final = np.sum((np.abs(psi_final) ** 2) * mask) * dx\n    # Reflection ratio\n    R = P_final / P_init if P_init > 0 else 0.0\n    return float(np.real_if_close(R))\n\ndef solve():\n    # Define global parameters and test suite as specified in the problem statement.\n    params = {\n        \"L\": 4.0,       # half-length of the spatial domain\n        \"N\": 512,       # number of grid points\n        \"dt\": 0.002,    # time step\n        \"T\": 10.0,      # total propagation time\n        \"x0\": -1.0,     # initial center position\n        \"sigma\": 0.3,   # initial packet width\n        \"E0\": 0.5,      # kinetic energy of the packet\n        \"delta\": 0.25,  # monitor half-width\n    }\n\n    # Test suite: (eta0, w, m_order)\n    test_cases = [\n        (0.0, 0.0, 2),     # No absorber: expect large reflection\n        (0.5, 1.0, 2),     # Weak absorber: partial reflection\n        (2.0, 1.5, 3),     # Smooth, strong absorber: low reflection\n        (10.0, 0.25, 1),   # Very strong, thin absorber: spurious reflections\n    ]\n\n    results = []\n    for eta0, w, m_order in test_cases:\n        R = run_case(eta0, w, m_order, params)\n        results.append(R)\n\n    # Final print statement in the exact required format with six decimals.\n    print(\"[\" + \",\".join(f\"{r:.6f}\" for r in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "这项综合练习将之前练习中的概念整合在一起，要求您构建一个简化的、但功能齐全的一维 TDHF 求解器。TDHF 理论的核心在于轨道的自洽演化，其中每个轨道都在由所有轨道共同产生的平均场中运动，这个过程具有固有的非线性。本练习  直接解决了在时间演化中处理这种非线性相互作用的挑战，并要求您实现并比较两种广泛使用的传播算法：Crank-Nicolson 格式和分裂算符法。通过比较它们在能量守恒方面的表现，您将对实际 TDHF 计算中精度、稳定性和计算效率之间的权衡有宝贵的见解。",
            "id": "3609662",
            "problem": "实现并比较两种在周期性边界条件下，使用一维空间中简化的 Skyrme 能量密度泛函进行时变 Hartree-Fock (TDHF) 动力学的实时传播方案。在普朗克常数 $\\hbar = 1$ 且核子质量 $m = 1$ 的单位制下进行计算。考虑一个自旋饱和系统，使得自旋密度和自旋流为零，并将 Skyrme 能量密度泛函 (EDF) 简化为仅依赖于粒子密度和动能密度的最小形式。令总能量泛函为\n$$\nE[\\rho,\\tau] \\;=\\; \\int_{0}^{L} dx \\,\\left[ \\frac{1}{2m}\\,\\tau(x,t) \\;+\\; \\frac{t_0}{2}\\,\\rho(x,t)^2 \\right],\n$$\n其中粒子密度为 $\\rho(x,t) = \\sum_{i=1}^{N_{\\text{orb}}} |\\varphi_i(x,t)|^2$，动能密度为 $\\tau(x,t) = \\sum_{i=1}^{N_{\\text{orb}}} |\\partial_x \\varphi_i(x,t)|^2$。根据斯莱特行列式的变分原理，每个占据的单粒子轨道 $\\varphi_i(x,t)$ 根据时变 Hartree-Fock 方程演化\n$$\ni\\,\\partial_t \\varphi_i(x,t) \\;=\\; h[\\rho]\\,\\varphi_i(x,t),\n$$\n其中平均场哈密顿量为\n$$\nh[\\rho] \\;=\\; -\\frac{1}{2m}\\,\\partial_x^2 \\;+\\; U[\\rho](x,t),\n\\qquad\nU[\\rho](x,t) \\;=\\; t_0\\,\\rho(x,t).\n$$\n确保占据的轨道在任何时候都相对于周期性内积 $\\langle \\phi,\\psi\\rangle = \\int_{0}^{L} \\phi(x)^{*}\\psi(x)\\,dx$ 保持正交归一。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 将区间 $[0,L)$ 离散化为一个包含 $N$ 个点、间距为 $\\Delta x = L/N$ 的均匀周期性网格。\n- 初始化 $N_{\\text{orb}} = 2$ 个占据轨道，为两个宽度为 $\\sigma$、中心分别位于 $x_1 = L/4$ 和 $x_2 = 3L/4$ 的归一化高斯波包，每个波包带有一个小的平面波相位因子 $\\exp(\\pm i k_0 x)$，其中 $k_0 = 2\\pi/L$。使用数值稳定的方法对轨道进行正交归一化。\n- 使用相同的 $(\\Delta t,\\Delta x)$，通过两种不同的方案将轨道从 $t=0$ 演化到 $t=T$，时间步长为 $\\Delta t$：\n  1. 一种针对时变平均场问题的 Crank–Nicolson (CN) 方案，该方案通过对哈密顿量的预估-校正方法实现。对动能算符使用有限差分周期性拉普拉斯算子。一种可接受的方法是：\n     - 预估步：从 $\\rho^n$ 构建 $H[\\rho^n]$，计算一阶显式预估值 $\\varphi_i^{\\text{pred}} = \\varphi_i^n - i\\,\\Delta t\\,H[\\rho^n]\\varphi_i^n$，形成 $\\rho^{\\text{pred}}$，并定义 $H^{\\text{avg}} = \\frac{1}{2}\\left(H[\\rho^n] + H[\\rho^{\\text{pred}}]\\right)$。\n     - 校正步：对每个轨道求解\n       $$\n       \\left(I + \\frac{i\\Delta t}{2}H^{\\text{avg}}\\right)\\varphi_i^{n+1} \\;=\\; \\left(I - \\frac{i\\Delta t}{2}H^{\\text{avg}}\\right)\\varphi_i^{n}.\n       $$\n     - 对轨道集 $\\{\\varphi_i^{n+1}\\}$ 进行重新正交归一化。\n  2. 一种分裂算符（二阶 Strang）方案，该方案在周期性边界条件下使用动量空间中的精确动能传播子：\n     - 使用 $U[\\rho^n](x)$ 施加半步的局域势能作用。\n     - 在动量空间中施加全步的动能传播子 $e^{-i\\Delta t\\,k^2/(2m)}$，其中 $k = 2\\pi n/L$，$n$ 为与离散傅里叶变换一致的整数。\n     - 重新计算密度，并使用更新后的密度施加另一次半步势能作用，以提高自洽性。\n     - 在每个完整步长后对轨道集进行重新正交归一化。\n- 使用相同的能量泛函计算 $t=0$ 和 $t=T$ 时的瞬时总能量，\n  $$\n  E(t) \\;=\\; \\sum_{i=1}^{N_{\\text{orb}}} \\int_{0}^{L} dx \\,\\frac{1}{2m}\\,|\\partial_x \\varphi_i(x,t)|^2 \\;+\\; \\int_{0}^{L} dx \\,\\frac{t_0}{2}\\,\\rho(x,t)^2,\n  $$\n  使用精确的周期性微分方法（例如，傅里叶空间中的谱微分）计算 $\\partial_x$。\n- 报告每种传播方案和每个测试用例的绝对能量漂移 $\\Delta E(T) = |E(T) - E(0)|$。\n\n科学和数值约束：\n- 在 $[0,L)$ 上严格遵守周期性边界条件。\n- 使用 $\\hbar = 1$，$m = 1$，以及如上所述的具有耦合常数 $t_0$ 的纯局域 Skyrme 项。不包括自旋轨道项或流项；将梯度项设置为零。\n- 在每个时间步后保持轨道的正交归一性。\n- 答案是无量纲的；将能量漂移报告为无量纲浮点数。\n\n测试套件：\n对于下面的每组参数，使用高斯宽度 $\\sigma = L/20$ 和所述的 $N_{\\text{orb}} = 2$ 个轨道进行初始化。对于每个案例，计算一个布尔值，指示在相同的 $(\\Delta t,\\Delta x)$下，Crank–Nicolson 方案是否产生小于或等于分裂算符方案的能量漂移：\n- 案例 A（理想情况）：$(L, N, \\Delta t, T, t_0) = (\\,20.0,\\,128,\\,0.02,\\,1.0,\\,1.0\\,)$。\n- 案例 B（更小的时间步长）：$(L, N, \\Delta t, T, t_0) = (\\,20.0,\\,128,\\,0.01,\\,1.0,\\,1.0\\,)$。\n- 案例 C（更粗的网格）：$(L, N, \\Delta t, T, t_0) = (\\,20.0,\\,64,\\,0.02,\\,1.0,\\,1.0\\,)$。\n- 案例 D（更大的时间步长，更短的演化时间）：$(L, N, \\Delta t, T, t_0) = (\\,20.0,\\,64,\\,0.04,\\,0.8,\\,1.0\\,)$。\n\n最终输出要求：\n- 您的程序应生成单行输出，其中包含四个案例的结果，格式为方括号内以逗号分隔的布尔值列表，例如 `[True,False,True,True]`。\n- 对每个案例，如果 $\\Delta E_{\\text{CN}}(T) \\le \\Delta E_{\\text{Split}}(T)$，则输出 True，否则输出 False。\n\n不使用角度单位。所有报告的量均为无量纲浮点数或布尔值。无需用户输入；您的程序必须仅使用给定的测试套件运行至完成，并打印所需的单行输出。",
            "solution": "用户提供了一个定义明确的计算物理问题，该问题要求实现并比较两种用于求解时变 Hartree-Fock (TDHF) 方程的数值方法。\n\n### 第1步：提取给定信息\n- **系统**：在区间 $[0, L)$ 上，处于周期性边界条件下的一个一维自旋饱和核系统。\n- **常数**：普朗克常数 $\\hbar = 1$，核子质量 $m = 1$。\n- **能量密度泛函 (EDF)**: $E[\\rho,\\tau] = \\int_{0}^{L} dx \\,\\left[ \\frac{1}{2m}\\,\\tau(x,t) + \\frac{t_0}{2}\\,\\rho(x,t)^2 \\right]$。\n- **密度定义**：\n    - 粒子密度: $\\rho(x,t) = \\sum_{i=1}^{N_{\\text{orb}}} |\\varphi_i(x,t)|^2$。\n    - 动能密度: $\\tau(x,t) = \\sum_{i=1}^{N_{\\text{orb}}} |\\partial_x \\varphi_i(x,t)|^2$。\n- **TDHF 方程**: $i\\,\\partial_t \\varphi_i(x,t) = h[\\rho]\\,\\varphi_i(x,t)$。\n- **平均场哈密顿量**: $h[\\rho] = -\\frac{1}{2m}\\,\\partial_x^2 + U[\\rho](x,t)$，其中势为 $U[\\rho](x,t) = t_0\\,\\rho(x,t)$。\n- **初始条件**：\n    - 轨道数: $N_{\\text{orb}} = 2$。\n    - 轨道形状: 宽度为 $\\sigma = L/20$ 的归一化高斯波包。\n    - 轨道中心: $x_1 = L/4$, $x_2 = 3L/4$。\n    - 初始动量: 一个平面波相位因子 $\\exp(\\pm i k_0 x)$，其中 $k_0 = 2\\pi/L$。\n    - 初始轨道集必须是正交归一化的。\n- **数值传播方案**：\n    1.  **Crank-Nicolson (CN)**：一种使用有限差分拉普拉斯算子的预估-校正方案。\n        - 预估步: $\\varphi_i^{\\text{pred}} = \\varphi_i^n - i\\,\\Delta t\\,H[\\rho^n]\\varphi_i^n$，使用 $H[\\rho^n]$。\n        - 平均哈密顿量: $H^{\\text{avg}} = \\frac{1}{2}\\left(H[\\rho^n] + H[\\rho^{\\text{pred}}]\\right)$。\n        - 校正步: 对 $\\left(I + \\frac{i\\Delta t}{2}H^{\\text{avg}}\\right)\\varphi_i^{n+1} = \\left(I - \\frac{i\\Delta t}{2}H^{\\text{avg}}\\right)\\varphi_i^{n}$ 进行隐式求解。\n    2.  **分裂算符 (SO)**：一种二阶 Strang 分裂，对动能部分使用快速傅里叶变换 (FFT)。\n        - 使用 $U[\\rho^n]$ 的半步势能演化。\n        - 全步动能演化 $e^{-i\\Delta t\\,T}$。\n        - 使用自洽更新的密度进行半步势能演化。\n- **约束**：两种方法都必须在每个时间步后对轨道进行重新正交归一化。\n- **分析**：\n    - 使用谱微分方法计算动能项，从而计算在 $t=0$ 和 $t=T$ 时的总能量 $E(t)$。\n    - 报告绝对能量漂移 $\\Delta E(T) = |E(T) - E(0)|$。\n- **测试用例**：\n    - 案例 A: $(L, N, \\Delta t, T, t_0) = (20.0, 128, 0.02, 1.0, 1.0)$。\n    - 案例 B: $(L, N, \\Delta t, T, t_0) = (20.0, 128, 0.01, 1.0, 1.0)$。\n    - 案例 C: $(L, N, \\Delta t, T, t_0) = (20.0, 64, 0.02, 1.0, 1.0)$。\n    - 案例 D: $(L, N, \\Delta t, T, t_0) = (20.0, 64, 0.04, 0.8, 1.0)$。\n- **要求输出**：对每个案例，输出一个布尔值，指示是否 $\\Delta E_{\\text{CN}}(T) \\le \\Delta E_{\\text{Split}}(T)$。\n\n### 第2步：使用提取的给定信息进行验证\n- **科学基础**：该问题基于时变 Hartree-Fock 理论，这是量子多体物理学中一种标准的平均场近似。简化的 Skyrme 泛函是此类计算的一个有效且常见的起点。\n- **适定性**：该问题是适定的。它提供了所有必需的物理常数、初始条件、模型方程，以及求解唯一解所需的数值算法和测试参数的完整描述。\n- **客观性**：语言精确、量化，且不含主观性。该任务是一个标准的数值实验。\n\n所有有效性标准均已满足。该问题没有表现出任何指定的缺陷。\n\n### 第3步：结论与行动\n该问题是**有效的**。将提供一个解决方案。\n\n### 基于原则的设计\n解决方案将使用 Python 和 `numpy` 库进行数值运算来实现。逻辑被封装在一个 `solve` 函数中，该函数会遍历所提供的测试用例。\n\n**1. 离散化和网格**\n一维空间域 $[0, L)$ 被离散化为包含 $N$ 个点、间距为 $\\Delta x = L/N$ 的均匀网格。傅里叶变换所需的相应动量空间网格使用 `numpy.fft.fftfreq` 生成。这确保了对周期性边界条件的正确处理。\n\n**2. 初始状态准备**\n两个初始轨道被构建为高斯波包，每个波包乘以一个平面波相位因子以赋予初始速度，使它们相互移动。虽然单个高斯波包可以被归一化，但由于它们的空间重叠，它们并非相互正交。为了满足费米子的泡利不相容原理，轨道集必须是正交归一的。这通过使用 Löwdin 正交归一化过程来实现，该过程对于近线性相关的向量是数值稳定的。该方法包括构建重叠矩阵 $S_{ij} = \\langle \\varphi_i | \\varphi_j \\rangle$，计算其逆平方根 $S^{-1/2}$，并通过 $\\varphi'_k = \\sum_j (S^{-1/2})_{kj} \\varphi_j$ 变换原始轨道。内积积分通过加权 $\\Delta x$ 的离散和来计算。\n\n**3. 能量计算**\n设计一个函数根据给定的泛函计算总能量 $E(t)$。势能项通过对总密度 $\\rho(x,t)$ 求平方并积分来计算。为了达到指定的高精度，动能密度 $\\tau(x,t)$ 使用谱微分法计算。对于每个轨道 $\\varphi_i$，其导数 $\\partial_x \\varphi_i$ 通过以下方式求得：对轨道进行傅里叶变换，在动量空间中乘以 $ik$（其中 $k$ 是离散的动量空间频率），然后进行逆傅里叶变换回到位置空间。总能量是积分后的动能密度和势能密度之和。\n\n**4. Crank-Nicolson (CN) 实现**\n该传播方案遵循指定的预估-校正方案来实现，以处理平均场势的非线性。\n- **动能算符**：动能算符 $-\\frac{1}{2m}\\partial_x^2$ 在周期性网格上使用二阶三点有限差分格式表示为一个矩阵。这会产生一个循环矩阵。\n- **预估-校正循环**：\n    1.  在时间 $t_n$，使用当前密度 $\\rho^n$ 构建哈密顿量 $H[\\rho^n]$。\n    2.  使用单步前向欧拉法计算预估状态 $\\varphi_i^{\\text{pred}}$。\n    3.  从这些预估状态形成新的密度 $\\rho^{\\text{pred}}$，并构建预估哈密顿量 $H[\\rho^{\\text{pred}}]$。\n    4.  该步的哈密顿量取为平均值，$H^{\\text{avg}} = \\frac{1}{2}(H[\\rho^n] + H[\\rho^{\\text{pred}}])$。\n    5.  校正步求解隐式 Crank-Nicolson 方程，这是一个形式为 $A\\varphi_i^{n+1} = B\\varphi_i^n$ 的线性系统，使用 `numpy.linalg.solve` 求解。\n- **正交归一化**：在每个时间步之后，使用 Löwdin 程序对新的轨道集 $\\{\\varphi_i^{n+1}\\}$ 进行重新正交归一化。\n\n**5. 分裂算符 (SO) 实现**\n该传播方案使用 Strang 分裂来近似时间演化算符 $e^{-i\\Delta t H} \\approx e^{-i\\Delta t U/2}e^{-i\\Delta t T}e^{-i\\Delta t U/2}$。\n- **势能步**：$e^{-i\\Delta t U/2}$ 的作用是在位置空间中进行简单的相位乘法，其相位取决于局域势 $U(x)$。\n- **动能步**：动能演化 $e^{-i\\Delta t T}$ 在动量空间中执行最为准确和高效。轨道通过 FFT 进行变换，乘以相位因子 $e^{-i\\Delta t k^2/(2m)}$，然后通过逆 FFT 变换回来。\n- **自洽性**：按照规定，该方案包含了一个自洽性改进。在动能步之后重新计算密度，并使用这个更新后的密度来计算第二个半步势能传播子的势。\n- **正交归一化**：与 CN 方法一样，在每个完整的时间步之后，通过 Löwdin 方法对轨道进行重新正交归一化。\n\n**6. 比较和输出**\n对于每个测试用例，程序首先计算初始能量 $E(0)$。然后，它从 $t=0$ 到 $t=T$ 运行两种传播方案。计算每种方案的最终能量 $E(T)$，并求出绝对能量漂移 $\\Delta E = |E(T) - E(0)|$。比较 $\\Delta E_{\\text{CN}} \\le \\Delta E_{\\text{Split}}$ 的布尔结果被存储起来。最后，所有布尔结果被格式化为所需的字符串格式 `[True,False,...]` 并打印出来。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares Crank-Nicolson and Split-Operator propagators for\n    1D Time-Dependent Hartree-Fock (TDHF) dynamics.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, N, dt, T, t0)\n        (20.0, 128, 0.02, 1.0, 1.0),  # Case A\n        (20.0, 128, 0.01, 1.0, 1.0),  # Case B\n        (20.0, 64, 0.02, 1.0, 1.0),   # Case C\n        (20.0, 64, 0.04, 0.8, 1.0),   # Case D\n    ]\n\n    # --- Helper Functions ---\n\n    def lowdin_orthonormalize(orbitals, dx):\n        \"\"\"\n        Orthonormalizes a set of orbitals using the Löwdin method.\n        \"\"\"\n        num_orbitals = len(orbitals)\n        if num_orbitals  2:\n            return orbitals\n\n        S = np.zeros((num_orbitals, num_orbitals), dtype=np.complex128)\n        for i in range(num_orbitals):\n            for j in range(i, num_orbitals):\n                overlap = np.sum(np.conj(orbitals[i]) * orbitals[j]) * dx\n                S[i, j] = overlap\n                S[j, i] = np.conj(overlap)\n        \n        eigvals, eigvecs = np.linalg.eigh(S)\n        S_inv_sqrt = eigvecs @ np.diag(1.0 / np.sqrt(eigvals)) @ eigvecs.T.conj()\n\n        old_orbitals_matrix = np.array(orbitals)\n        new_orbitals_matrix = S_inv_sqrt @ old_orbitals_matrix\n        return list(new_orbitals_matrix)\n\n    def create_initial_orbitals(L, N, sigma, k0, dx):\n        \"\"\"\n        Creates and orthonormalizes the initial Gaussian orbitals.\n        \"\"\"\n        x = np.linspace(0, L, N, endpoint=False)\n        x1, x2 = L / 4.0, 3.0 * L / 4.0\n\n        psi1_un = np.exp(-(x - x1)**2 / (2 * sigma**2)) * np.exp(1j * k0 * x)\n        psi2_un = np.exp(-(x - x2)**2 / (2 * sigma**2)) * np.exp(-1j * k0 * x)\n        \n        psi1 = psi1_un / np.sqrt(np.sum(np.abs(psi1_un)**2) * dx)\n        psi2 = psi2_un / np.sqrt(np.sum(np.abs(psi2_un)**2) * dx)\n\n        return lowdin_orthonormalize([psi1, psi2], dx)\n\n    def calculate_energy(orbitals, t0, L, N, dx, k_vec):\n        \"\"\"\n        Calculates the total energy using spectral differentiation for the kinetic term.\n        \"\"\"\n        rho = np.sum([np.abs(phi)**2 for phi in orbitals], axis=0)\n        \n        tau = np.zeros_like(rho, dtype=np.float64)\n        for phi in orbitals:\n            phi_k = np.fft.fft(phi)\n            d_phi_k = 1j * k_vec * phi_k\n            d_phi = np.fft.ifft(d_phi_k)\n            tau += np.abs(d_phi)**2\n            \n        E_kin = (1.0 / 2.0) * np.sum(tau) * dx\n        E_pot = (t0 / 2.0) * np.sum(rho**2) * dx\n        return E_kin + E_pot\n\n    def run_cn_propagation(params, initial_orbitals, dx, k_vec):\n        \"\"\"\n        Propagates orbitals using the Crank-Nicolson predictor-corrector method.\n        \"\"\"\n        L, N, dt, T, t0 = params\n        n_steps = int(round(T / dt))\n        orbitals = [o.copy() for o in initial_orbitals]\n\n        # Kinetic operator (finite difference)\n        D2 = np.zeros((N, N), dtype=np.float64)\n        diag_val = -2.0 / dx**2\n        offdiag_val = 1.0 / dx**2\n        np.fill_diagonal(D2, diag_val)\n        np.fill_diagonal(D2[1:], offdiag_val)\n        np.fill_diagonal(D2[:, 1:], offdiag_val)\n        D2[0, -1] = offdiag_val\n        D2[-1, 0] = offdiag_val\n        T_op = -0.5 * D2\n\n        for _ in range(n_steps):\n            # Predictor\n            rho_n = np.sum([np.abs(o)**2 for o in orbitals], axis=0)\n            H_n = T_op + np.diag(t0 * rho_n)\n            \n            pred_orbitals = [phi - 1j * dt * (H_n @ phi) for phi in orbitals]\n            \n            rho_pred = np.sum([np.abs(o)**2 for o in pred_orbitals], axis=0)\n            H_pred = T_op + np.diag(t0 * rho_pred)\n            \n            H_avg = 0.5 * (H_n + H_pred)\n            \n            # Corrector\n            A = np.eye(N) + (0.5j * dt) * H_avg\n            B = np.eye(N) - (0.5j * dt) * H_avg\n            \n            next_orbitals_unorth = [np.linalg.solve(A, B @ phi) for phi in orbitals]\n            \n            orbitals = lowdin_orthonormalize(next_orbitals_unorth, dx)\n            \n        return orbitals\n\n    def run_split_op_propagation(params, initial_orbitals, dx, k_vec):\n        \"\"\"\n        Propagates orbitals using the Split-Operator (Strang) method.\n        \"\"\"\n        L, N, dt, T, t0 = params\n        n_steps = int(round(T / dt))\n        orbitals = [o.copy() for o in initial_orbitals]\n        \n        kin_propagator = np.exp(-0.5j * dt * k_vec**2)\n\n        for _ in range(n_steps):\n            # First half potential step\n            rho_n = np.sum([np.abs(o)**2 for o in orbitals], axis=0)\n            U_n = t0 * rho_n\n            pot_prop_half_1 = np.exp(-0.5j * dt * U_n)\n            temp_orbitals_1 = [pot_prop_half_1 * phi for phi in orbitals]\n            \n            # Full kinetic step\n            temp_orbitals_2 = []\n            for phi in temp_orbitals_1:\n                phi_k = np.fft.fft(phi)\n                phi_k_prop = kin_propagator * phi_k\n                temp_orbitals_2.append(np.fft.ifft(phi_k_prop))\n            \n            # Second half potential step (with updated density)\n            rho_mid = np.sum([np.abs(o)**2 for o in temp_orbitals_2], axis=0)\n            U_mid = t0 * rho_mid\n            pot_prop_half_2 = np.exp(-0.5j * dt * U_mid)\n            next_orbitals_unorth = [pot_prop_half_2 * phi for phi in temp_orbitals_2]\n            \n            orbitals = lowdin_orthonormalize(next_orbitals_unorth, dx)\n            \n        return orbitals\n\n    results = []\n    for case in test_cases:\n        L, N, dt, T, t0 = case\n        dx = L / N\n        sigma = L / 20.0\n        k0 = 2 * np.pi / L\n        k_vec = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n        # Generate initial state and compute initial energy\n        initial_orbitals = create_initial_orbitals(L, N, sigma, k0, dx)\n        E0 = calculate_energy(initial_orbitals, t0, L, N, dx, k_vec)\n\n        # Run Crank-Nicolson\n        final_orbitals_cn = run_cn_propagation(case, initial_orbitals, dx, k_vec)\n        E_final_cn = calculate_energy(final_orbitals_cn, t0, L, N, dx, k_vec)\n        delta_E_cn = np.abs(E_final_cn - E0)\n\n        # Run Split-Operator\n        final_orbitals_split = run_split_op_propagation(case, initial_orbitals, dx, k_vec)\n        E_final_split = calculate_energy(final_orbitals_split, t0, L, N, dx, k_vec)\n        delta_E_split = np.abs(E_final_split - E0)\n        \n        results.append(delta_E_cn = delta_E_split)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}