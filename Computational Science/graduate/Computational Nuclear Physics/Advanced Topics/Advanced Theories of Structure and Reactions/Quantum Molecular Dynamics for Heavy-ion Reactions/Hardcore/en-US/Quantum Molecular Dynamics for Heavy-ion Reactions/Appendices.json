{
    "hands_on_practices": [
        {
            "introduction": "The evolution of nucleons in Quantum Molecular Dynamics (QMD) is driven by forces derived from the nuclear mean field. This field is not fundamental but arises from an effective interaction, often described by an energy density functional like the Skyrme model. This exercise guides you through the essential process of deriving the mean-field force from such a functional, a crucial step in understanding how the complex dynamics in QMD are rooted in the underlying properties of the nuclear equation of state .",
            "id": "3584132",
            "problem": "In a Quantum Molecular Dynamics (QMD) description of heavy-ion reactions, the single-particle mean-field potential arises from an effective Skyrme-like energy density functional that depends on the local nucleon density and its gradients. Consider symmetric nuclear matter with a one-dimensional density profile along the $x$ direction, uniform in the transverse directions, given by\n$$\\rho(x) = \\rho_{0}\\left[1 + \\delta \\tanh\\!\\left(\\frac{x}{a}\\right)\\right],$$\nwhere $\\rho_{0}$ is the saturation density, $\\delta$ is a small dimensionless amplitude, and $a$ is a characteristic diffuseness length.\n\nAssume the interaction energy density is the sum of a local Skyrme-like part and a surface-gradient term,\n$$\\varepsilon(\\rho,\\nabla \\rho) = \\frac{\\alpha}{2}\\,\\frac{\\rho^{2}}{\\rho_{0}} + \\frac{\\beta}{\\gamma + 1}\\,\\frac{\\rho^{\\gamma + 1}}{\\rho_{0}^{\\gamma}} + \\frac{C_{s}}{2}\\,|\\nabla \\rho|^{2},$$\nwith constant parameters $\\alpha$, $\\beta$, $\\gamma$, and $C_{s}$. The single-particle mean-field potential is defined as the functional derivative of the total interaction energy with respect to $\\rho$, which for a local functional with gradients reduces to\n$$U(x) = \\frac{\\partial \\varepsilon}{\\partial \\rho}\\bigg|_{\\rho=\\rho(x)} - \\nabla \\cdot \\left(\\frac{\\partial \\varepsilon}{\\partial (\\nabla \\rho)}\\bigg|_{\\nabla \\rho=\\nabla \\rho(x)}\\right).$$\nThe mean-field force on a nucleon is $-\\nabla U(x)$. Neglect all momentum-dependent contributions and any time dependence.\n\nUsing only these definitions and the chain rule, derive a closed-form expression for the $x$-component of the mean-field force, $F_{x} = -\\partial U/\\partial x$, evaluated at $x=0$, in terms of $\\alpha$, $\\beta$, $\\gamma$, $C_{s}$, $\\rho_{0}$, $\\delta$, and $a$, for the profile $\\rho(x)$ given above. Then, evaluate $F_{x}$ numerically at $x=0$ for the parameters\n- $\\alpha = -356$ MeV,\n- $\\beta = 303$ MeV,\n- $\\gamma = \\frac{7}{6}$,\n- $C_{s} = 30$ MeV fm$^{5}$,\n- $\\rho_{0} = 0.16$ fm$^{-3}$,\n- $\\delta = 0.3$,\n- $a = 2.0$ fm.\n\nExpress your final result for $F_{x}$ in MeV/fm and round your answer to three significant figures.",
            "solution": "We start from the given interaction energy density,\n$$\\varepsilon(\\rho,\\nabla \\rho) = \\frac{\\alpha}{2}\\,\\frac{\\rho^{2}}{\\rho_{0}} + \\frac{\\beta}{\\gamma + 1}\\,\\frac{\\rho^{\\gamma + 1}}{\\rho_{0}^{\\gamma}} + \\frac{C_{s}}{2}\\,|\\nabla \\rho|^{2}.$$\nFor a local functional with gradients, the single-particle mean-field potential is given by the standard Eulerâ€“Lagrange functional derivative,\n$$U(x) = \\frac{\\partial \\varepsilon}{\\partial \\rho} - \\nabla \\cdot \\left(\\frac{\\partial \\varepsilon}{\\partial (\\nabla \\rho)}\\right).$$\nWe compute the partial derivatives:\n- The local part yields\n$$\\frac{\\partial \\varepsilon}{\\partial \\rho} = \\alpha \\frac{\\rho}{\\rho_{0}} + \\beta \\frac{\\rho^{\\gamma}}{\\rho_{0}^{\\gamma}} = \\alpha \\left(\\frac{\\rho}{\\rho_{0}}\\right) + \\beta \\left(\\frac{\\rho}{\\rho_{0}}\\right)^{\\gamma}.$$\n- The gradient term gives\n$$\\frac{\\partial \\varepsilon}{\\partial (\\nabla \\rho)} = C_{s}\\,\\nabla \\rho,$$\nso that\n$$\\nabla \\cdot \\left(\\frac{\\partial \\varepsilon}{\\partial (\\nabla \\rho)}\\right) = C_{s}\\,\\nabla \\cdot (\\nabla \\rho) = C_{s}\\,\\nabla^{2} \\rho.$$\nTherefore,\n$$U(x) = \\alpha \\left(\\frac{\\rho(x)}{\\rho_{0}}\\right) + \\beta \\left(\\frac{\\rho(x)}{\\rho_{0}}\\right)^{\\gamma} - C_{s}\\,\\nabla^{2} \\rho(x).$$\nIn one dimension ($x$ dependence only), $\\nabla \\to \\partial/\\partial x$ and $\\nabla^{2} \\to \\partial^{2}/\\partial x^{2}$, so\n$$U(x) = \\alpha \\left(\\frac{\\rho(x)}{\\rho_{0}}\\right) + \\beta \\left(\\frac{\\rho(x)}{\\rho_{0}}\\right)^{\\gamma} - C_{s}\\,\\frac{\\partial^{2} \\rho(x)}{\\partial x^{2}}.$$\nThe force is $-\\nabla U(x)$, and in one dimension the $x$-component is\n$$F_{x}(x) = -\\frac{\\partial U}{\\partial x} = -\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left[\\alpha \\left(\\frac{\\rho}{\\rho_{0}}\\right) + \\beta \\left(\\frac{\\rho}{\\rho_{0}}\\right)^{\\gamma}\\right] + C_{s}\\,\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\frac{\\partial^{2} \\rho}{\\partial x^{2}}\\right).$$\nBy the chain rule,\n$$\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left[\\alpha \\left(\\frac{\\rho}{\\rho_{0}}\\right) + \\beta \\left(\\frac{\\rho}{\\rho_{0}}\\right)^{\\gamma}\\right] = \\left[\\frac{\\alpha}{\\rho_{0}} + \\frac{\\beta \\gamma}{\\rho_{0}}\\left(\\frac{\\rho}{\\rho_{0}}\\right)^{\\gamma - 1}\\right]\\frac{\\mathrm{d}\\rho}{\\mathrm{d}x}.$$\nThe last term is the third derivative,\n$$\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\frac{\\partial^{2} \\rho}{\\partial x^{2}}\\right) = \\frac{\\partial^{3} \\rho}{\\partial x^{3}}.$$\nHence,\n$$F_{x}(x) = -\\left[\\frac{\\alpha}{\\rho_{0}} + \\frac{\\beta \\gamma}{\\rho_{0}}\\left(\\frac{\\rho(x)}{\\rho_{0}}\\right)^{\\gamma - 1}\\right]\\frac{\\mathrm{d}\\rho(x)}{\\mathrm{d}x} + C_{s}\\,\\frac{\\partial^{3} \\rho(x)}{\\partial x^{3}}.$$\n\nWe now evaluate at $x=0$ for the given profile,\n$$\\rho(x) = \\rho_{0}\\left[1 + \\delta \\tanh\\!\\left(\\frac{x}{a}\\right)\\right], \\quad u \\equiv \\frac{x}{a}.$$\nThe needed derivatives are\n$$\\frac{\\mathrm{d}\\rho}{\\mathrm{d}x} = \\rho_{0}\\,\\delta\\,\\frac{1}{a}\\,\\mathrm{sech}^{2}(u),$$\n$$\\frac{\\mathrm{d}^{2}\\rho}{\\mathrm{d}x^{2}} = \\rho_{0}\\,\\delta\\,\\frac{1}{a}\\,\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left[\\mathrm{sech}^{2}(u)\\right] = -2\\,\\rho_{0}\\,\\delta\\,\\frac{1}{a^{2}}\\,\\mathrm{sech}^{2}(u)\\,\\tanh(u),$$\n$$\\frac{\\mathrm{d}^{3}\\rho}{\\mathrm{d}x^{3}} = -2\\,\\rho_{0}\\,\\delta\\,\\frac{1}{a^{2}}\\,\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left[\\mathrm{sech}^{2}(u)\\,\\tanh(u)\\right] = -2\\,\\rho_{0}\\,\\delta\\,\\frac{1}{a^{3}}\\left[-2\\,\\mathrm{sech}^{2}(u)\\,\\tanh^{2}(u) + \\mathrm{sech}^{4}(u)\\right].$$\nAt $x=0$ we have $u=0$, $\\tanh(0)=0$, and $\\mathrm{sech}(0)=1$, so\n$$\\rho(0) = \\rho_{0}, \\quad \\frac{\\mathrm{d}\\rho}{\\mathrm{d}x}\\bigg|_{x=0} = \\rho_{0}\\,\\delta\\,\\frac{1}{a}, \\quad \\frac{\\mathrm{d}^{3}\\rho}{\\mathrm{d}x^{3}}\\bigg|_{x=0} = -2\\,\\rho_{0}\\,\\delta\\,\\frac{1}{a^{3}}.$$\nAlso,\n$$\\left(\\frac{\\rho(0)}{\\rho_{0}}\\right)^{\\gamma - 1} = 1^{\\gamma - 1} = 1.$$\nTherefore,\n$$F_{x}(0) = -\\left[\\frac{\\alpha}{\\rho_{0}} + \\frac{\\beta \\gamma}{\\rho_{0}}\\cdot 1\\right]\\left(\\rho_{0}\\,\\delta\\,\\frac{1}{a}\\right) + C_{s}\\left(-2\\,\\rho_{0}\\,\\delta\\,\\frac{1}{a^{3}}\\right).$$\nSimplifying,\n$$F_{x}(0) = -\\left[\\alpha + \\beta \\gamma\\right]\\frac{\\delta}{a} - 2\\,C_{s}\\,\\rho_{0}\\,\\frac{\\delta}{a^{3}}.$$\n\nThis is the requested closed-form expression. Now insert the numerical values:\n- $\\alpha = -356$ MeV,\n- $\\beta = 303$ MeV,\n- $\\gamma = \\frac{7}{6}$, so $\\beta \\gamma = 303 \\times \\frac{7}{6} = 353.5$ MeV,\n- Thus, $\\alpha + \\beta \\gamma = -356 + 353.5 = -2.5$ MeV.\n- $\\delta = 0.3$,\n- $a = 2.0$ fm, so $a^{3} = 8.0$ fm$^{3}$,\n- $C_{s} = 30$ MeV fm$^{5}$,\n- $\\rho_{0} = 0.16$ fm$^{-3}$.\n\nCompute the two contributions:\n$$-\\left[\\alpha + \\beta \\gamma\\right]\\frac{\\delta}{a} = -\\left[-2.5\\right]\\frac{0.3}{2.0} = 2.5 \\times 0.15 = 0.375 \\text{ MeV/fm},$$\n$$- 2\\,C_{s}\\,\\rho_{0}\\,\\frac{\\delta}{a^{3}} = -2 \\times 30 \\times 0.16 \\times \\frac{0.3}{8.0} = -\\frac{2.88}{8.0} = -0.36 \\text{ MeV/fm}.$$\nSumming,\n$$F_{x}(0) = 0.375 - 0.36 = 0.015 \\text{ MeV/fm}.$$\n\nRounded to three significant figures and expressed in MeV/fm, the result is $0.0150$ MeV/fm.",
            "answer": "$$\\boxed{0.0150}$$"
        },
        {
            "introduction": "Beyond the smooth evolution in the mean field, QMD simulations incorporate the crucial effects of short-range correlations through a stochastic collision term. The probability of these binary nucleon-nucleon collisions is governed by an in-medium cross-section, which differs from its free-space counterpart. This practice explores a common phenomenological model for how the free-space cross-section is modified within the dense nuclear medium, connecting it to the physically intuitive concept of the mean free path .",
            "id": "3584140",
            "problem": "In Quantum Molecular Dynamics (QMD) transport for heavy-ion reactions, stochastic binary collisions between nucleons are modeled using in-medium effective cross-sections. Consider the model where the in-medium nucleon-nucleon cross-section scales with density as a function $\\sigma(\\rho)$ based on a specified free-space value $\\sigma_{\\mathrm{free}}(E_{\\mathrm{lab}})$ at a laboratory kinetic energy $E_{\\mathrm{lab}}$. The mean free path $\\lambda$ is defined by kinetic theory in terms of the local number density $\\rho$ and the total cross-section $\\sigma(\\rho)$.\n\nAssume the following foundational inputs are given and to be used as the base of your derivation and implementation:\n- The in-medium scaling of the total cross-section is a function $\\sigma(\\rho)$ of density $\\rho$ and parameter $\\eta$, where $\\eta$ is dimensionless, and the scaling is such that the cross-section reduces with increasing density for positive $\\eta$.\n- The mean free path is defined as the inverse of the collision rate per unit speed in a uniform medium, expressed as a function of $\\rho$ and $\\sigma(\\rho)$.\n- The nuclear saturation density is $\\rho_0 = 0.16\\,\\mathrm{fm}^{-3}$.\n- For proton-proton scattering at $E_{\\mathrm{lab}} = 100\\,\\mathrm{MeV}$, a well-tested representative free-space total cross-section is $\\sigma_{\\mathrm{free}} = 40\\,\\mathrm{mb}$.\n- The required unit conversions are: $1\\,\\mathrm{b} = 10^{-28}\\,\\mathrm{m}^2$, $1\\,\\mathrm{mb} = 10^{-3}\\,\\mathrm{b} = 10^{-31}\\,\\mathrm{m}^2$, and $1\\,\\mathrm{fm}^2 = 10^{-30}\\,\\mathrm{m}^2$. Hence, $1\\,\\mathrm{mb} = 0.1\\,\\mathrm{fm}^2$.\n\nTask:\n- Starting from the definitions above, implement the in-medium cross-section scaling model and compute the mean free path at $\\rho=\\rho_0$ for protons at $E_{\\mathrm{lab}}=100\\,\\mathrm{MeV}$.\n- Use the physically valid domain condition that the denominator of the scaling must remain positive, i.e., ensure $1+\\eta\\,\\rho/\\rho_0 > 0$.\n- Express the final mean free path values in femtometers.\n\nYour program must:\n- Convert $\\sigma_{\\mathrm{free}}$ from millibarns to $\\mathrm{fm}^2$ using the unit relations above.\n- Evaluate the mean free path at $\\rho=\\rho_0$ for a test suite of parameter values of the dimensionless in-medium parameter $\\eta$.\n- Output the results as a single line containing a comma-separated list enclosed in square brackets, with each entry rounded to six decimal places, in femtometers.\n\nTest suite:\n- Use the following list of $\\eta$ values: $[-0.5, 0.0, 0.5, 1.0, 9.0, -0.99]$.\n- These cases cover: enhanced cross-section ($\\eta<0$), free-space limit ($\\eta=0$), moderate reduction ($\\eta=0.5$), strong reduction ($\\eta=1.0$), extreme reduction ($\\eta=9.0$), and near-singular behavior approaching the physical boundary from above ($\\eta=-0.99]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[x_1,x_2,\\dots]$, where each $x_i$ is the mean free path in $\\mathrm{fm}$ rounded to six decimal places.",
            "solution": "The user-provided problem has been rigorously validated and is deemed valid. It is scientifically grounded in the principles of nuclear transport theory, specifically Quantum Molecular Dynamics (QMD), and is well-posed. Although the explicit functional form for the in-medium cross-section scaling $\\sigma(\\rho)$ is not provided, its properties and the associated domain condition are described with sufficient clarity to uniquely identify the standard parametrization used in this context. The problem is objective, self-contained, and all provided constants and conditions are physically and mathematically consistent.\n\nThe solution proceeds by first establishing the theoretical framework and then applying it to the specific parameters provided.\n\n**1. Theoretical Foundation**\n\nThe core of the problem lies in two fundamental concepts from kinetic theory and nuclear physics: the mean free path and the in-medium modification of nucleon-nucleon cross-sections.\n\n**Principle 1: Mean Free Path**\nThe mean free path, $\\lambda$, of a particle in a medium is the average distance it travels between successive collisions. In kinetic theory, it is defined as the inverse of the product of the number density of target particles, $\\rho$, and the total collision cross-section, $\\sigma$.\n$$\n\\lambda = \\frac{1}{\\rho \\sigma}\n$$\nIn this problem, the cross-section $\\sigma$ is not a constant but depends on the local nucleon density $\\rho$, so we write $\\sigma(\\rho)$ and consequently $\\lambda(\\rho)$.\n\n**Principle 2: In-Medium Cross-Section Scaling**\nIn free space, the nucleon-nucleon cross-section $\\sigma_{\\mathrm{free}}$ depends on the collision energy. Inside the dense nuclear medium, this cross-section is modified due to effects like Pauli blocking and changes in nucleon effective mass. The problem describes a phenomenological model for this scaling:\n- The in-medium cross-section $\\sigma(\\rho)$ is a function of the local density $\\rho$ and a dimensionless parameter $\\eta$.\n- For $\\eta > 0$, $\\sigma(\\rho)$ decreases as $\\rho$ increases.\n- The model's domain is constrained by the condition $1+\\eta(\\rho/\\rho_0) > 0$, where $\\rho_0$ is the nuclear saturation density.\n\nThe simplest and most common functional form that satisfies these conditions is:\n$$\n\\sigma(\\rho) = \\frac{\\sigma_{\\mathrm{free}}}{1 + \\eta \\frac{\\rho}{\\rho_0}}\n$$\nThis form is standard in many QMD and transport models. The denominator term, $1 + \\eta (\\rho/\\rho_0)$, directly implements the specified scaling behavior and the domain constraint. We will proceed using this established formula.\n\n**2. Derivation for the Specific Case**\n\nThe task is to compute the mean free path $\\lambda$ at nuclear saturation density, i.e., at $\\rho = \\rho_0$.\n\nFirst, we substitute the scaling model for $\\sigma(\\rho)$ into the definition of $\\lambda(\\rho)$:\n$$\n\\lambda(\\rho) = \\frac{1}{\\rho \\sigma(\\rho)} = \\frac{1}{\\rho \\left( \\frac{\\sigma_{\\mathrm{free}}}{1 + \\eta \\frac{\\rho}{\\rho_0}} \\right)} = \\frac{1 + \\eta \\frac{\\rho}{\\rho_0}}{\\rho \\sigma_{\\mathrm{free}}}\n$$\nNext, we evaluate this expression at $\\rho = \\rho_0$. This simplifies the ratio $\\rho/\\rho_0$ to $1$:\n$$\n\\lambda(\\rho_0) = \\frac{1 + \\eta \\frac{\\rho_0}{\\rho_0}}{\\rho_0 \\sigma_{\\mathrm{free}}} = \\frac{1 + \\eta}{\\rho_0 \\sigma_{\\mathrm{free}}}\n$$\nThis is the final analytical expression used for the calculation.\n\n**3. Numerical Evaluation**\n\nWe are given the following values:\n- Nuclear saturation density: $\\rho_0 = 0.16\\,\\mathrm{fm}^{-3}$\n- Free-space p-p cross-section: $\\sigma_{\\mathrm{free}} = 40\\,\\mathrm{mb}$ at $E_{\\mathrm{lab}}=100\\,\\mathrm{MeV}$.\n\nThe first step is to ensure consistent units. The desired unit for the final result is femtometers ($\\mathrm{fm}$). Therefore, we must convert $\\sigma_{\\mathrm{free}}$ from millibarns ($\\mathrm{mb}$) to square femtometers ($\\mathrm{fm}^2$). The problem provides the necessary conversion: $1\\,\\mathrm{mb} = 0.1\\,\\mathrm{fm}^2$.\n$$\n\\sigma_{\\mathrm{free}} = 40\\,\\mathrm{mb} \\times \\frac{0.1\\,\\mathrm{fm}^2}{1\\,\\mathrm{mb}} = 4.0\\,\\mathrm{fm}^2\n$$\nNow, we can compute the denominator of our expression for $\\lambda(\\rho_0)$:\n$$\n\\rho_0 \\sigma_{\\mathrm{free}} = (0.16\\,\\mathrm{fm}^{-3}) \\times (4.0\\,\\mathrm{fm}^2) = 0.64\\,\\mathrm{fm}^{-1}\n$$\nThe expression for the mean free path simplifies to:\n$$\n\\lambda(\\rho_0) = \\frac{1 + \\eta}{0.64}\\,\\mathrm{fm}\n$$\nWe apply this formula to each value of $\\eta$ in the test suite $[-0.5, 0.0, 0.5, 1.0, 9.0, -0.99]$.\n\n- For $\\eta = -0.5$: $\\lambda(\\rho_0) = \\frac{1 - 0.5}{0.64} = \\frac{0.5}{0.64} = 0.78125\\,\\mathrm{fm}$\n- For $\\eta = 0.0$: $\\lambda(\\rho_0) = \\frac{1 + 0.0}{0.64} = \\frac{1.0}{0.64} = 1.5625\\,\\mathrm{fm}$ (This is the free-space mean free path in a medium of density $\\rho_0$).\n- For $\\eta = 0.5$: $\\lambda(\\rho_0) = \\frac{1 + 0.5}{0.64} = \\frac{1.5}{0.64} = 2.34375\\,\\mathrm{fm}$\n- For $\\eta = 1.0$: $\\lambda(\\rho_0) = \\frac{1 + 1.0}{0.64} = \\frac{2.0}{0.64} = 3.125\\,\\mathrm{fm}$\n- For $\\eta = 9.0$: $\\lambda(\\rho_0) = \\frac{1 + 9.0}{0.64} = \\frac{10.0}{0.64} = 15.625\\,\\mathrm{fm}$\n- For $\\eta = -0.99$: $\\lambda(\\rho_0) = \\frac{1 - 0.99}{0.64} = \\frac{0.01}{0.64} = 0.015625\\,\\mathrm{fm}$\n\nThese results, rounded to six decimal places, are then formatted into the required output string. The physical interpretation is that a positive $\\eta$ reduces the in-medium cross-section, leading to a longer mean free path, while a negative $\\eta$ enhances the cross-section, shortening the mean free path. The value $\\eta=-0.99$ brings the system close to a singularity with a very large cross-section and thus a very short mean free path.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the nucleon mean free path in nuclear matter at saturation density\n    based on a QMD-inspired in-medium cross-section scaling model.\n    \"\"\"\n\n    # Define the foundational inputs from the problem statement.\n    \n    # Nuclear saturation density in fm^-3\n    RHO_0 = 0.16\n    \n    # Free-space proton-proton total cross-section in millibarns (mb)\n    SIGMA_FREE_MB = 40.0\n    \n    # Conversion factor from millibarns (mb) to square femtometers (fm^2)\n    # 1 mb = 10^-31 m^2; 1 fm^2 = 10^-30 m^2 => 1 mb = 0.1 fm^2\n    MB_TO_FM2 = 0.1\n    \n    # The test suite of dimensionless in-medium parameter eta\n    test_cases = [-0.5, 0.0, 0.5, 1.0, 9.0, -0.99]\n    eta_values = np.array(test_cases)\n    \n    # --- Step 1: Convert units ---\n    # Convert the free-space cross-section to fm^2 to have consistent units.\n    sigma_free_fm2 = SIGMA_FREE_MB * MB_TO_FM2\n    \n    # --- Step 2: Implement the mean free path formula ---\n    # The mean free path is given by lambda = 1 / (rho * sigma_in_medium).\n    # The in-medium cross-section is sigma_in_medium = sigma_free / (1 + eta * (rho/rho_0)).\n    # At rho = rho_0, this simplifies to:\n    # lambda(rho_0) = 1 / (rho_0 * (sigma_free / (1 + eta))) = (1 + eta) / (rho_0 * sigma_free)\n    \n    # Pre-calculate the denominator product for efficiency\n    product_rho_sigma = RHO_0 * sigma_free_fm2\n    \n    # --- Step 3: Compute results for the test suite ---\n    # Use numpy's vectorized capabilities to compute all results at once.\n    # The condition 1 + eta > 0 is met for all test cases.\n    lambda_values = (1 + eta_values) / product_rho_sigma\n    \n    # --- Step 4: Format the output ---\n    # Round each result to six decimal places and format as a string.\n    results_str = [f\"{val:.6f}\" for val in lambda_values]\n    \n    # Final print statement in the exact required format: [x1,x2,...]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "At the conclusion of a QMD simulation, the system consists of individual nucleons scattered throughout phase space. To connect these theoretical results with experimental observables, one must first identify the bound fragments (protons, alpha particles, heavier nuclei) from this final distribution. This hands-on exercise introduces a practical, phase-space-based algorithm for cluster recognition, a standard and vital technique in the analysis of transport model simulations, allowing you to translate raw microscopic output into a meaningful fragment distribution .",
            "id": "3584083",
            "problem": "You are asked to implement, from first principles, a phase-space clusterization procedure commonly used in Quantum Molecular Dynamics (QMD) simulations of heavy-ion reactions. In this procedure, often referred to as the Minimum Spanning Tree (MST) method in the QMD community, nucleons are grouped into fragments using pairwise cuts in coordinate and momentum space. Your task is to implement this procedure for a synthetic data set resembling a late-time snapshot from a central gold-on-gold collision and to compute the fragment charge distribution.\n\nFundamental definitions:\n- In Quantum Molecular Dynamics (QMD), each nucleon is represented by a centroid position vector $\\mathbf{r}_i$ in $\\mathrm{fm}$ and a centroid momentum vector $\\mathbf{p}_i$ in $\\mathrm{MeV}/c$.\n- Define the Euclidean spatial separation between nucleons $i$ and $j$ as $d_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert_2$ in $\\mathrm{fm}$.\n- Define the Euclidean momentum separation between nucleons $i$ and $j$ as $\\Delta p_{ij} = \\lVert \\mathbf{p}_i - \\mathbf{p}_j \\rVert_2$ in $\\mathrm{MeV}/c$.\n- Given cutoffs $R_c$ and $P_c$, an undirected edge is drawn between $i$ and $j$ if and only if $d_{ij} \\le R_c$ and $\\Delta p_{ij} \\le P_c$.\n- Clusters (fragments) are the connected components of this undirected graph.\n- Each nucleon has a type $t_i \\in \\{\\text{p}, \\text{n}\\}$, denoting proton ($\\text{p}$) or neutron ($\\text{n}$). The charge number of a fragment $C$ is $Z(C) = \\sum_{i \\in C} \\mathbb{1}[t_i = \\text{p}]$.\n- The charge distribution $P(Z)$ over charged fragments is defined as $P(Z) = N_Z / N_{\\text{frag}}$, where $N_Z$ is the number of fragments with charge $Z \\ge 1$ and $N_{\\text{frag}}$ is the total number of fragments with $Z \\ge 1$. Fragments with $Z=0$ (neutron-only clusters) are excluded from $P(Z)$. If no charged fragments exist in a test case, return an empty list.\n\nUse the following parameters for all test cases:\n- Spatial cutoff $R_c = 3\\,\\mathrm{fm}$.\n- Momentum cutoff $P_c = 250\\,\\mathrm{MeV}/c$.\n- The boundary is inclusive: pairs with $d_{ij} = R_c$ and $\\Delta p_{ij} = P_c$ are considered connected.\n\nImplement the above using only graph connectivity; do not use any energy minimization or additional physics beyond what is defined here.\n\nCompute $P(Z)$ for each of the following synthetic test cases. Each test case provides a list of nucleon types, positions (in $\\mathrm{fm}$), and momenta (in $\\mathrm{MeV}/c$). The positions and momenta are given as ordered triples. Your implementation must treat these lists as the complete set of nucleons in the event, and must not introduce any additional particles.\n\nTest Suite:\n- Test Case A (two well-separated fragments and a free neutron):\n  - Types $[t_i]$: $[\\text{p}, \\text{p}, \\text{p}, \\text{n}, \\text{n}, \\text{n}, \\text{p}, \\text{p}, \\text{n}, \\text{n}, \\text{n}]$.\n  - Positions $\\mathbf{r}_i$ in $\\mathrm{fm}$:\n    - Cluster $1$: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(1.0, 0.5, 0.0\\right)$, $\\left(-0.8, -0.2, 0.3\\right)$, $\\left(0.5, -0.7, 0.2\\right)$, $\\left(-1.2, 0.6, -0.4\\right)$, $\\left(0.2, 1.0, -0.5\\right)$.\n    - Cluster $2$: $\\left(10.0, 0.0, 0.0\\right)$, $\\left(10.5, -0.3, 0.7\\right)$, $\\left(9.2, 0.4, -0.6\\right)$, $\\left(11.0, 0.8, 0.1\\right)$.\n    - Free neutron: $\\left(30.0, 30.0, 0.0\\right)$.\n  - Momenta $\\mathbf{p}_i$ in $\\mathrm{MeV}/c$:\n    - Cluster $1$: $\\left(100.0, 5.0, -10.0\\right)$, $\\left(95.0, -10.0, 0.0\\right)$, $\\left(110.0, 0.0, 15.0\\right)$, $\\left(105.0, 5.0, 0.0\\right)$, $\\left(90.0, -5.0, -5.0\\right)$, $\\left(100.0, 10.0, 5.0\\right)$.\n    - Cluster $2$: $\\left(-50.0, 50.0, 0.0\\right)$, $\\left(-55.0, 45.0, 10.0\\right)$, $\\left(-60.0, 55.0, -5.0\\right)$, $\\left(-45.0, 40.0, 5.0\\right)$.\n    - Free neutron: $\\left(300.0, -200.0, 100.0\\right)$.\n- Test Case B (spatially compact set, momentum-separated nucleons; every pair violates the momentum cut):\n  - Types $[t_i]$: $[\\text{p}, \\text{p}, \\text{n}, \\text{n}]$.\n  - Positions $\\mathbf{r}_i$ in $\\mathrm{fm}$: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(0.5, 0.5, 0.0\\right)$, $\\left(-0.4, 0.2, -0.1\\right)$, $\\left(0.3, -0.6, 0.2\\right)$.\n  - Momenta $\\mathbf{p}_i$ in $\\mathrm{MeV}/c$: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(500.0, 0.0, 0.0\\right)$, $\\left(0.0, 800.0, 0.0\\right)$, $\\left(0.0, 0.0, 1000.0\\right)$.\n- Test Case C (boundary connectivity with exactly $R_c$ and $P_c$; tests inclusive thresholds and transitivity):\n  - Types $[t_i]$: $[\\text{p}, \\text{n}, \\text{p}]$.\n  - Positions $\\mathbf{r}_i$ in $\\mathrm{fm}$: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(3.0, 0.0, 0.0\\right)$, $\\left(6.0, 0.0, 0.0\\right)$.\n  - Momenta $\\mathbf{p}_i$ in $\\mathrm{MeV}/c$: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(250.0, 0.0, 0.0\\right)$, $\\left(500.0, 0.0, 0.0\\right)$.\n- Test Case D (chain connectivity; endpoints far beyond cutoffs yet connected via intermediates):\n  - Types $[t_i]$: $[\\text{p}, \\text{n}, \\text{p}, \\text{n}, \\text{p}]$.\n  - Positions $\\mathbf{r}_i$ in $\\mathrm{fm}$: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(2.5, 0.0, 0.0\\right)$, $\\left(5.0, 0.0, 0.0\\right)$, $\\left(7.5, 0.0, 0.0\\right)$, $\\left(10.0, 0.0, 0.0\\right)$.\n  - Momenta $\\mathbf{p}_i$ in $\\mathrm{MeV}/c$: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(200.0, 0.0, 0.0\\right)$, $\\left(400.0, 0.0, 0.0\\right)$, $\\left(600.0, 0.0, 0.0\\right)$, $\\left(800.0, 0.0, 0.0\\right)$.\n\nRequirements for computation and output:\n- Implement the graph according to the definitions, with $R_c = 3\\,\\mathrm{fm}$ and $P_c = 250\\,\\mathrm{MeV}/c$, using inclusive inequalities.\n- For each test case, compute the list $[P(1), P(2), \\dots, P(Z_{\\max})]$, where $Z_{\\max}$ is the maximum observed fragment charge for $Z \\ge 1$. Express probabilities as decimals rounded to six places after the decimal point.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself the bracketed, comma-separated list for one test case, in the same order as above. For example, a valid output format is $\\left[\\left[a,b\\right],\\left[c\\right],\\left[d,e\\right]\\right]$ with each symbol replaced by a decimal to six places.\n\nNo input should be read; all data must be defined within the program. Ensure all distances are in $\\mathrm{fm}$ and all momenta in $\\mathrm{MeV}/c$. Angles are not used. Probabilities must be printed as decimals, not fractions. Ensure scientific realism by adhering strictly to the above thresholds and definitions.",
            "solution": "The problem requires implementing a phase-space clusterization algorithm to identify nuclear fragments from a list of nucleons. The solution involves translating the physical definition of a fragment into a graph theory problem.\n\n**1. Theoretical Framework**\nThe core principle is that nucleons belonging to the same fragment are close in both coordinate space and momentum space. This is formalized by constructing an undirected graph where each nucleon is a vertex. An edge is drawn between two vertices (nucleons) $i$ and $j$ if and only if their spatial separation $d_{ij}$ and momentum separation $\\Delta p_{ij}$ are both within specified cutoffs:\n- $d_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert_2 \\le R_c$\n- $\\Delta p_{ij} = \\lVert \\mathbf{p}_i - \\mathbf{p}_j \\rVert_2 \\le P_c$\n\nA fragment is then defined as a **connected component** of this graph.\n\n**2. Algorithmic Implementation**\nThe algorithm proceeds in these steps:\n1.  **Build Adjacency List:** Iterate through all unique pairs of nucleons. For each pair, calculate $d_{ij}$ and $\\Delta p_{ij}$. If both conditions are met, add an edge connecting them in an adjacency list representation of the graph.\n2.  **Find Connected Components:** Use a graph traversal algorithm, such as Breadth-First Search (BFS) or Depth-First Search (DFS), to find all connected components. This involves keeping track of visited nucleons to ensure each is assigned to exactly one fragment.\n3.  **Calculate Fragment Charges:** For each identified fragment (cluster), count the number of protons to determine its charge, $Z$.\n4.  **Compute Charge Distribution:**\n    a. Filter out all fragments with $Z=0$ (neutron-only clusters).\n    b. Count the total number of remaining charged fragments, $N_{\\text{frag}}$.\n    c. For each charge value $Z \\ge 1$, count the number of fragments $N_Z$ with that charge.\n    d. The probability is $P(Z) = N_Z / N_{\\text{frag}}$.\n    e. Assemble the results into a list $[P(1), P(2), \\dots, P(Z_{\\max})]$.\n\n**3. Example Walkthrough (Test Case C)**\nLet's apply this to Test Case C with $R_c = 3\\,\\mathrm{fm}$ and $P_c = 250\\,\\mathrm{MeV}/c$.\n- **Nucleons:** 0(p), 1(n), 2(p).\n- **Positions:** $\\mathbf{r}_0=(0,0,0)$, $\\mathbf{r}_1=(3,0,0)$, $\\mathbf{r}_2=(6,0,0)$.\n- **Momenta:** $\\mathbf{p}_0=(0,0,0)$, $\\mathbf{p}_1=(250,0,0)$, $\\mathbf{p}_2=(500,0,0)$.\n\n- **Pair (0, 1):**\n  - $d_{01} = \\lVert (3,0,0) - (0,0,0) \\rVert = 3.0\\,\\mathrm{fm}$. This meets the $d_{01} \\le R_c$ condition.\n  - $\\Delta p_{01} = \\lVert (250,0,0) - (0,0,0) \\rVert = 250.0\\,\\mathrm{MeV}/c$. This meets the $\\Delta p_{01} \\le P_c$ condition.\n  - **Result:** Nucleons 0 and 1 are connected.\n\n- **Pair (1, 2):**\n  - $d_{12} = \\lVert (6,0,0) - (3,0,0) \\rVert = 3.0\\,\\mathrm{fm}$. This meets the $d_{12} \\le R_c$ condition.\n  - $\\Delta p_{12} = \\lVert (500,0,0) - (250,0,0) \\rVert = 250.0\\,\\mathrm{MeV}/c$. This meets the $\\Delta p_{12} \\le P_c$ condition.\n  - **Result:** Nucleons 1 and 2 are connected.\n\n- **Pair (0, 2):**\n  - $d_{02} = \\lVert (6,0,0) - (0,0,0) \\rVert = 6.0\\,\\mathrm{fm}$. This violates $d_{02} \\le R_c$. They are not directly connected.\n\n- **Conclusion:** Due to transitivity (0 is connected to 1, and 1 is connected to 2), all three nucleons {0, 1, 2} form a single fragment. The charge of this fragment is $Z=2$ (from proton 0 and proton 2). There is one charged fragment in total ($N_{\\text{frag}}=1$). The distribution is $P(1)=0$ and $P(2)=1/1=1$. The final list is `[0.0, 1.0]`. The full code implements this logic for all test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a phase-space clusterization procedure for nucleons and\n    computes the fragment charge distribution for several test cases.\n    \"\"\"\n\n    # Define the global parameters from the problem statement.\n    R_c = 3.0  # Spatial cutoff in fm\n    P_c = 250.0 # Momentum cutoff in MeV/c\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"types\": ['p', 'p', 'p', 'n', 'n', 'n', 'p', 'p', 'n', 'n', 'n'],\n            \"positions\": np.array([\n                (0.0, 0.0, 0.0), (1.0, 0.5, 0.0), (-0.8, -0.2, 0.3),\n                (0.5, -0.7, 0.2), (-1.2, 0.6, -0.4), (0.2, 1.0, -0.5),\n                (10.0, 0.0, 0.0), (10.5, -0.3, 0.7), (9.2, 0.4, -0.6),\n                (11.0, 0.8, 0.1), (30.0, 30.0, 0.0)\n            ]),\n            \"momenta\": np.array([\n                (100.0, 5.0, -10.0), (95.0, -10.0, 0.0), (110.0, 0.0, 15.0),\n                (105.0, 5.0, 0.0), (90.0, -5.0, -5.0), (100.0, 10.0, 5.0),\n                (-50.0, 50.0, 0.0), (-55.0, 45.0, 10.0), (-60.0, 55.0, -5.0),\n                (-45.0, 40.0, 5.0), (300.0, -200.0, 100.0)\n            ])\n        },\n        # Test Case B\n        {\n            \"types\": ['p', 'p', 'n', 'n'],\n            \"positions\": np.array([\n                (0.0, 0.0, 0.0), (0.5, 0.5, 0.0), \n                (-0.4, 0.2, -0.1), (0.3, -0.6, 0.2)\n            ]),\n            \"momenta\": np.array([\n                (0.0, 0.0, 0.0), (500.0, 0.0, 0.0),\n                (0.0, 800.0, 0.0), (0.0, 0.0, 1000.0)\n            ])\n        },\n        # Test Case C\n        {\n            \"types\": ['p', 'n', 'p'],\n            \"positions\": np.array([\n                (0.0, 0.0, 0.0), (3.0, 0.0, 0.0), (6.0, 0.0, 0.0)\n            ]),\n            \"momenta\": np.array([\n                (0.0, 0.0, 0.0), (250.0, 0.0, 0.0), (500.0, 0.0, 0.0)\n            ])\n        },\n        # Test Case D\n        {\n            \"types\": ['p', 'n', 'p', 'n', 'p'],\n            \"positions\": np.array([\n                (0.0, 0.0, 0.0), (2.5, 0.0, 0.0), (5.0, 0.0, 0.0), \n                (7.5, 0.0, 0.0), (10.0, 0.0, 0.0)\n            ]),\n            \"momenta\": np.array([\n                (0.0, 0.0, 0.0), (200.0, 0.0, 0.0), (400.0, 0.0, 0.0), \n                (600.0, 0.0, 0.0), (800.0, 0.0, 0.0)\n            ])\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        types = case[\"types\"]\n        positions = case[\"positions\"]\n        momenta = case[\"momenta\"]\n        num_nucleons = len(types)\n        \n        # 1. Graph Construction: Build adjacency list\n        adj = {i: [] for i in range(num_nucleons)}\n        for i in range(num_nucleons):\n            for j in range(i + 1, num_nucleons):\n                d_ij = np.linalg.norm(positions[i] - positions[j])\n                dp_ij = np.linalg.norm(momenta[i] - momenta[j])\n                \n                # Check connectivity conditions (inclusive)\n                if d_ij <= R_c and dp_ij <= P_c:\n                    adj[i].append(j)\n                    adj[j].append(i)\n\n        # 2. Cluster Identification: Find connected components using DFS\n        clusters = []\n        visited = [False] * num_nucleons\n        for i in range(num_nucleons):\n            if not visited[i]:\n                current_cluster = []\n                stack = [i]\n                visited[i] = True\n                while stack:\n                    u = stack.pop()\n                    current_cluster.append(u)\n                    for v in adj[u]:\n                        if not visited[v]:\n                            visited[v] = True\n                            stack.append(v)\n                clusters.append(sorted(current_cluster))\n        \n        # 3. Fragment Charge Calculation\n        cluster_charges = []\n        for cluster in clusters:\n            charge = sum(1 for nucleon_idx in cluster if types[nucleon_idx] == 'p')\n            cluster_charges.append(charge)\n            \n        # 4. Charge Distribution Analysis\n        charged_fragment_charges = [z for z in cluster_charges if z > 0]\n        \n        if not charged_fragment_charges:\n            all_results.append([])\n            continue\n            \n        n_frag = len(charged_fragment_charges)\n        z_max = max(charged_fragment_charges)\n        \n        charge_counts = {}\n        for z in charged_fragment_charges:\n            charge_counts[z] = charge_counts.get(z, 0) + 1\n            \n        p_z = [0.0] * z_max\n        for z, count in charge_counts.items():\n            if z > 0:\n                p_z[z - 1] = count / n_frag\n        \n        all_results.append(p_z)\n\n    # Format the final output string as specified\n    formatted_results = []\n    for res_list in all_results:\n        formatted_list = [f\"{x:.6f}\" for x in res_list]\n        formatted_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}