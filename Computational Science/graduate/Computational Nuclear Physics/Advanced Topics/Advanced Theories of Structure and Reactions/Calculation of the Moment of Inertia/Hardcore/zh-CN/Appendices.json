{
    "hands_on_practices": [
        {
            "introduction": "在转动模型中，运动学转动惯量 $J^{(1)}$ 和动力学转动惯量 $J^{(2)}$ 是描述原子核转动响应的两个核心观测量。根据 Feynman-Hellmann 定理，这两者之间存在一个精确的数学关系。这个练习旨在通过一个简化的单粒子模型，让你动手构建转动（cranking）哈密顿量并进行数值求解，从而亲手验证 $J^{(1)}$ 和 $J^{(2)}$ 之间深刻的内在一致性 。",
            "id": "3548296",
            "problem": "考虑一个转动单粒子模型，其中单个核子占据一个截断的角动量子空间，总角动量为 $j=\\frac{3}{2}$，磁亚能级为 $m\\in\\left\\{-\\frac{3}{2},-\\frac{1}{2},\\frac{1}{2},\\frac{3}{2}\\right\\}$。在自然单位制（其中 $\\hbar=1$）下进行计算。设非转动的哈密顿量是一个对角矩阵 $H_0$，其能级能量为 $E_m$，这些能量唯象地模拟一个静态平均场（例如，由四极形变引起的）。通过 Routhian（劳斯函数）$R(\\omega)=H_0-\\omega \\hat{J}_x$ 定义绕 $x$ 轴的转动，其中 $\\omega$ 是转动频率。本问题中使用的物理类能泛函定义为 $E(\\omega)\\equiv -\\langle R(\\omega)\\rangle$，它在固定 $\\omega$ 时，于 $R(\\omega)$ 的最低能量本征态中求值。\n\n您必须：\n- 使用升降算符 $\\hat{J}_\\pm$ 及其矩阵元 $ \\langle j,m'|\\hat{J}_\\pm|j,m\\rangle = \\sqrt{j(j+1)-m(m\\pm 1)}\\,\\delta_{m',m\\pm 1}$ 和 $\\hat{J}_x=\\frac{1}{2}\\left(\\hat{J}_+ + \\hat{J}_-\\right)$（其中 $\\hbar=1$），在 $j=\\frac{3}{2}$ 子空间中构建角动量算符 $\\hat{J}_x$。\n- 使用对角哈密顿量 $H_0=\\mathrm{diag}(E_{-3/2},E_{-1/2},E_{1/2},E_{3/2})$ 及 $E_{-3/2}=0.00~\\mathrm{MeV}$、$E_{-1/2}=0.85~\\mathrm{MeV}$、$E_{1/2}=1.70~\\mathrm{MeV}$ 和 $E_{3/2}=2.80~\\mathrm{MeV}$。\n- 对于任何给定的 $\\omega$（单位为 $\\mathrm{MeV}$），计算 $R(\\omega)$ 的基态本征对 $\\left(\\lambda_{\\min}(\\omega),|\\psi(\\omega)\\rangle\\right)$，然后求出期望值 $\\langle \\hat{J}_x\\rangle(\\omega)=\\langle \\psi(\\omega)|\\hat{J}_x|\\psi(\\omega)\\rangle$ 和类能泛函 $E(\\omega)=-\\lambda_{\\min}(\\omega)$。\n- 使用步长为 $h$ 的对称有限差分来近似 $\\frac{\\partial \\langle \\hat{J}_x\\rangle}{\\partial \\omega}$：\n$$\n\\frac{\\partial \\langle \\hat{J}_x\\rangle}{\\partial \\omega}\\bigg|_{\\omega}\\approx \\frac{\\langle \\hat{J}_x\\rangle(\\omega+h)-\\langle \\hat{J}_x\\rangle(\\omega-h)}{2h},\n$$\n并通过以下方式近似 Hessian 矩阵 $\\frac{\\partial^2 E}{\\partial \\omega^2}$：\n$$\n\\frac{\\partial^2 E}{\\partial \\omega^2}\\bigg|_{\\omega}\\approx \\frac{E(\\omega+h)-2E(\\omega)+E(\\omega-h)}{h^2}.\n$$\n- 通过比较两种有限差分估计值，数值上验证指定测试集的一致性关系 $J^{(2)}(\\omega)=\\frac{\\partial \\langle \\hat{J}_x\\rangle}{\\partial \\omega}=\\frac{\\partial^2 E}{\\partial \\omega^2}$。\n\n使用以下 $(\\omega,h)$ 对的测试集（单位均为 $\\mathrm{MeV}$）：\n- $(\\omega,h)=\\left(0.00,10^{-3}\\right)$,\n- $(\\omega,h)=\\left(0.20,5\\times 10^{-3}\\right)$,\n- $(\\omega,h)=\\left(0.80,2\\times 10^{-3}\\right)$,\n- $(\\omega,h)=\\left(1.50,5\\times 10^{-3}\\right)$,\n- $(\\omega,h)=\\left(2.50,10^{-2}\\right)$.\n\n此外，包括两个边缘情况以探测数值稳定性：\n- $(\\omega,h)=\\left(0.00,10^{-6}\\right)$,\n- $(\\omega,h)=\\left(2.00,5\\times 10^{-4}\\right)$.\n\n所有能量和频率都必须以 $\\mathrm{MeV}$ 为单位处理，而由于 $\\hbar=1$，所有角动量期望值都是无量纲的。对于每个测试用例，计算绝对差\n$$\n\\Delta(\\omega,h)=\\left|\\frac{\\partial \\langle \\hat{J}_x\\rangle}{\\partial \\omega}\\bigg|_{\\omega}-\\frac{\\partial^2 E}{\\partial \\omega^2}\\bigg|_{\\omega}\\right|\n$$\n并以容差 $\\varepsilon=10^{-6}$ 评估是否满足 $\\Delta(\\omega,h)  \\varepsilon$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个布尔值按上述顺序对应一个测试用例（例如，$[\\mathrm{True},\\mathrm{False},\\dots]$）。",
            "solution": "目标是在转动单粒子模型的框架内，数值上验证动态转动惯量的一致性关系 $J^{(2)}(\\omega) = \\frac{\\partial \\langle \\hat{J}_x \\rangle}{\\partial \\omega} = \\frac{\\partial^2 E}{\\partial \\omega^2}$。此验证将针对一个处于总角动量为 $j=\\frac{3}{2}$ 的截断角动量子空间中的单个核子进行。该过程包括将相关的量子力学算符构建为矩阵，求解 Routhian 的本征值问题，然后使用有限差分来近似导数。\n\n首先，我们建立物理系统的数学表示。单粒子态为 $|j, m\\rangle$，其中总角动量固定为 $j=\\frac{3}{2}$，磁量子数 $m$ 在集合 $\\left\\{-\\frac{3}{2}, -\\frac{1}{2}, \\frac{1}{2}, \\frac{3}{2}\\right\\}$ 中取值。这定义了一个 4 维希尔伯特空间。我们建立一个与 $m$ 递增相对应的有序基：\n$$\n|1\\rangle \\equiv |\\frac{3}{2}, -\\frac{3}{2}\\rangle, \\quad |2\\rangle \\equiv |\\frac{3}{2}, -\\frac{1}{2}\\rangle, \\quad |3\\rangle \\equiv |\\frac{3}{2}, \\frac{1}{2}\\rangle, \\quad |4\\rangle \\equiv |\\frac{3}{2}, \\frac{3}{2}\\rangle\n$$\n在此基中，非转动哈密顿量 $H_0$ 是一个对角矩阵，其元素为给定的单粒子能量 $E_m$：\n$$\nH_0 = \\mathrm{diag}(E_{-3/2}, E_{-1/2}, E_{1/2}, E_{3/2}) = \\begin{pmatrix} 0.00  0  0  0 \\\\ 0  0.85  0  0 \\\\ 0  0  1.70  0 \\\\ 0  0  0  2.80 \\end{pmatrix} \\, \\mathrm{MeV}\n$$\n\n接下来，我们构建角动量算符 $\\hat{J}_x$ 的矩阵。这是通过升降算符 $\\hat{J}_+$ 和 $\\hat{J}_-$ 完成的，即 $\\hat{J}_x = \\frac{1}{2}(\\hat{J}_+ + \\hat{J}_-)$。$|j,m\\rangle$ 基中 $\\hat{J}_\\pm$ 的矩阵元由以下公式给出（$\\hbar=1$）：\n$$\n\\langle j,m'|\\hat{J}_\\pm|j,m\\rangle = \\sqrt{j(j+1)-m(m\\pm 1)}\\,\\delta_{m',m\\pm 1}\n$$\n对于 $j=\\frac{3}{2}$，项 $j(j+1) = \\frac{15}{4}$。$\\hat{J}_+$ 的非零矩阵元为：\n- $\\langle \\frac{3}{2}, -\\frac{1}{2} | \\hat{J}_+ | \\frac{3}{2}, -\\frac{3}{2} \\rangle = \\sqrt{\\frac{15}{4} - (-\\frac{3}{2})(-\\frac{1}{2})} = \\sqrt{3}$\n- $\\langle \\frac{3}{2}, \\frac{1}{2} | \\hat{J}_+ | \\frac{3}{2}, -\\frac{1}{2} \\rangle = \\sqrt{\\frac{15}{4} - (-\\frac{1}{2})(\\frac{1}{2})} = 2$\n- $\\langle \\frac{3}{2}, \\frac{3}{2} | \\hat{J}_+ | \\frac{3}{2}, \\frac{1}{2} \\rangle = \\sqrt{\\frac{15}{4} - (\\frac{1}{2})(\\frac{3}{2})} = \\sqrt{3}$\n\n这给出了 $\\hat{J}_+$ 在我们有序基中的矩阵表示。算符 $\\hat{J}_-$ 是其厄米共轭，$\\hat{J}_- = (\\hat{J}_+)^\\dagger$。\n$$\nJ_+ = \\begin{pmatrix} 0  0  0  0 \\\\ \\sqrt{3}  0  0  0 \\\\ 0  2  0  0 \\\\ 0  0  \\sqrt{3}  0 \\end{pmatrix}, \\quad J_- = \\begin{pmatrix} 0  \\sqrt{3}  0  0 \\\\ 0  0  2  0 \\\\ 0  0  0  \\sqrt{3} \\\\ 0  0  0  0 \\end{pmatrix}\n$$\n那么 $\\hat{J}_x$ 的矩阵为：\n$$\nJ_x = \\frac{1}{2}(J_+ + J_-) = \\frac{1}{2} \\begin{pmatrix}\n0  \\sqrt{3}  0  0 \\\\\n\\sqrt{3}  0  2  0 \\\\\n0  2  0  \\sqrt{3} \\\\\n0  0  \\sqrt{3}  0\n\\end{pmatrix}\n$$\n系统在转动下的动力学由 Routhian $R(\\omega) = H_0 - \\omega \\hat{J}_x$ 描述。对于给定的转动频率 $\\omega$，我们求解 Routhian 的定态薛定谔方程，$R(\\omega)|\\psi(\\omega)\\rangle = \\lambda(\\omega)|\\psi(\\omega)\\rangle$。我们关心的是基态，它对应于最低本征值 $\\lambda_{\\min}(\\omega)$ 及其相关的本征矢量 $|\\psi(\\omega)\\rangle$。\n\n物理类能泛函为 $E(\\omega) = -\\langle R(\\omega) \\rangle$。对于本征态，这简化为 $E(\\omega) = -\\lambda(\\omega)$。因此，对于基态，$E(\\omega) = -\\lambda_{\\min}(\\omega)$。角动量的期望值为 $\\langle \\hat{J}_x \\rangle (\\omega) = \\langle \\psi(\\omega) | \\hat{J}_x | \\psi(\\omega) \\rangle$。\n\n待验证的关系 $\\frac{\\partial \\langle \\hat{J}_x \\rangle}{\\partial \\omega} = \\frac{\\partial^2 E}{\\partial \\omega^2}$ 是 Feynman-Hellmann 定理的一个推论。将该定理应用于关于参数 $\\omega$ 的 Routhian 本征值 $\\lambda_{\\min}(\\omega)$ 可得 $\\frac{\\partial \\lambda_{\\min}}{\\partial \\omega} = \\langle \\psi(\\omega) | \\frac{\\partial R}{\\partial \\omega} | \\psi(\\omega) \\rangle = \\langle \\psi(\\omega) | (-\\hat{J}_x) | \\psi(\\omega) \\rangle = -\\langle \\hat{J}_x \\rangle(\\omega)$。由于 $E(\\omega) = -\\lambda_{\\min}(\\omega)$，我们有 $\\frac{\\partial E}{\\partial \\omega} = \\langle \\hat{J}_x \\rangle(\\omega)$。对 $\\omega$ 再求一次导数即可得到所需恒等式。\n\n对于测试集中的每个 $(\\omega,h)$ 对，数值算法按以下步骤进行：\n1.  定义一个函数，对于任意输入频率 $\\omega'$，构建 $4 \\times 4$ 实对称矩阵 $R(\\omega') = H_0 - \\omega' J_x$。\n2.  数值对角化 $R(\\omega')$ 以获得其本征值和本征矢量。标准数值库为此提供了稳健的方法。我们找出最低本征值 $\\lambda_{\\min}(\\omega')$ 和对应的本征矢量 $|\\psi(\\omega')\\rangle$。\n3.  计算两个我们关心的量：$E(\\omega') = -\\lambda_{\\min}(\\omega')$ 和 $\\langle \\hat{J}_x \\rangle (\\omega') = \\langle \\psi(\\omega') | J_x | \\psi(\\omega') \\rangle$。\n4.  对三个所需的频率点 $\\omega$、$\\omega+h$ 和 $\\omega-h$ 应用此函数。\n5.  使用计算出的值来计算两种有限差分近似：\n    $$\n    \\frac{\\partial \\langle \\hat{J}_x\\rangle}{\\partial \\omega}\\bigg|_{\\omega}\\approx \\frac{\\langle \\hat{J}_x\\rangle(\\omega+h)-\\langle \\hat{J}_x\\rangle(\\omega-h)}{2h}\n    $$\n    $$\n    \\frac{\\partial^2 E}{\\partial \\omega^2}\\bigg|_{\\omega}\\approx \\frac{E(\\omega+h)-2E(\\omega)+E(\\omega-h)}{h^2}\n    $$\n6.  计算这两种近似之间的绝对差 $\\Delta(\\omega,h)$。\n7.  将 $\\Delta(\\omega,h)$ 与容差 $\\varepsilon = 10^{-6}$ 进行比较，以确定该关系在数值上是否成立。结果是一个布尔值。\n\n将此过程系统地应用于所有测试用例，得到的布尔值列表构成最终答案。使用双精度浮点数对于达到所需精度至关重要，特别是对于较小的步长 $h$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cranked single-particle model problem by numerically verifying\n    the consistency relation J^(2)(omega) = d"
        },
        {
            "introduction": "真实原子核并非总是孤立的束缚态系统，特别是对于弱束缚的奇特核，与连续态的耦合变得至关重要。本练习将我们的模型从标准的厄米量子力学推广到包含开放通道效应的非厄米框架，通过引入具有复数能量的Gamow态来描述共振和衰变。你将探索这种连续态耦合如何改变原子核的转动响应，这是一个连接核结构与核反应理论的前沿课题 。",
            "id": "3548279",
            "problem": "要求您设计并实现一个计算实验，以分离连续谱和共振（Gamow）贡献如何改变弱束缚核系统中的转动响应，并因此影响转动惯量的计算。\n\n使用的出发点和建模假设：\n- 有限基矢中的不含时薛定谔方程写作 $H(\\omega)\\,| \\psi(\\omega) \\rangle = \\lambda(\\omega)\\,| \\psi(\\omega) \\rangle$，其中 $H(\\omega)$ 是微观哈密顿量的有限维矩阵表示，| \\psi(\\omega) \\rangle$ 是右本征矢量，而 $\\lambda(\\omega)$ 是对应的本征值。\n- 接近粒子发射阈的弱束缚核由一组有限的离散态建模。束缚态被赋予实数能量，而共振则由具有复数能量 $E = E_r - i \\Gamma/2$ 的 Gamow 态表示，当使用向外行波边界条件时，产生一个复对称哈密顿量。这捕捉了连续谱耦合和粒子衰变宽度。\n- 转动通过一个摇摆场引入，该摇摆场与角动量投影算符 $\\hat{J}_x$ 线性耦合，产生一个哈密顿量族 $H(\\omega)$，它线性地依赖于一个具有能量单位的小摇摆频率参数 $\\omega$，这与 $\\hbar = 1$ 的自然核单位一致。\n\n非厄米（复对称）设置中的期望值：\n- 对于复对称矩阵，合适的双正交内积是复对称 $c$-积。如果 $H$ 是复对称的，左本征矢量可以取为右本征矢量的转置。对于任意算符 $\\hat{O}$ 和态 $| \\psi \\rangle$，期望值计算为 $\\langle \\hat{O} \\rangle = \\dfrac{\\langle \\psi| \\hat{O} | \\psi \\rangle_c}{\\langle \\psi | \\psi \\rangle_c}$，其中 $c$-积为 $\\langle \\phi | \\psi \\rangle_c \\equiv \\phi^{\\mathsf{T}} \\psi$。\n\n您的任务：\n1. 考虑 $H(\\omega) = D - \\omega J_x$，其中 $D = \\mathrm{diag}(E_1,E_2,\\dots,E_N)$ 是态能量的对角矩阵，而 $J_x$ 是在所选基中 $\\hat{J}_x$ 的实对称矩阵表示。\n2. 对于下面的每个测试用例，计算 $H(\\omega)$ 在两个小值 $\\omega = +\\delta$ 和 $\\omega = -\\delta$（其中 $\\delta = 1\\times 10^{-3} \\, \\mathrm{MeV}$）时的类基态（其本征值的实部最小的本征态）。\n3. 对于这两个 $\\omega$ 值中的每一个，使用适用于 Gamow 基的复对称 $c$-积来评估期望值 $\\langle \\hat{J}_x \\rangle_{\\omega}$。\n4. 通过对称有限差分法，数值推断在 $\\omega=0$ 处的线性转动响应系数 $C$，$C$ 定义为在零摇摆频率下 $\\langle \\hat{J}_x \\rangle_{\\omega}$ 实部的斜率。从 $\\omega=\\pm \\delta$ 显式计算 $C$。\n5. 对一个基准情况重复步骤 2-4，其中所有能量都被其真实部分替换（即所有宽度都设置为零，从而移除了连续谱衰变效应），产生 $C_{\\mathrm{real\\_only}}$。\n6. 通过为每个测试用例计算 $\\Delta C = C_{\\mathrm{complex}} - C_{\\mathrm{real\\_only}}$ 来量化由复数能量贡献引起的变化。报告实数值 $\\Delta C$。\n7. 以 $\\mathrm{MeV}^{-1}$ 为单位表示最终结果，四舍五入到六位小数。\n\n测试套件（所有能量单位均为 $\\mathrm{MeV}$；矩阵维度与态的数量匹配）：\n- 案例 A（仅束缚态基准）：\n  - 能量：$E = \\left[ -2.0,\\,-1.0 \\right]$。\n  - 算符：$J_x = \\begin{pmatrix} 0.0  0.5 \\\\ 0.5  0.0 \\end{pmatrix}$。\n- 案例 B（一个窄共振）：\n  - 能量：$E = \\left[ -2.0,\\,-1.0,\\,1.5 - i\\,0.1 \\right]$。\n  - 算符：$J_x = \\begin{pmatrix} 0.0  0.5  0.3 \\\\ 0.5  0.0  0.2 \\\\ 0.3  0.2  0.0 \\end{pmatrix}$。\n- 案例 C（一个宽共振）：\n  - 能量：$E = \\left[ -2.0,\\,-1.5,\\,4.0 - i\\,0.8 \\right]$。\n  - 算符：$J_x = \\begin{pmatrix} 0.0  0.4  0.25 \\\\ 0.4  0.0  0.35 \\\\ 0.25  0.35  0.0 \\end{pmatrix}$。\n- 案例 D（近阈弱束缚态和多重共振）：\n  - 能量：$E = \\left[ -0.05,\\,0.7 - i\\,0.05,\\,2.0 - i\\,0.5 \\right]$。\n  - 算符：$J_x = \\begin{pmatrix} 0.0  0.6  0.2 \\\\ 0.6  0.0  0.4 \\\\ 0.2  0.4  0.0 \\end{pmatrix}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按 A、B、C、D 测试用例顺序排列的结果，形式为方括号内以逗号分隔的列表。每个条目必须是实数值 $\\Delta C$，单位为 $\\mathrm{MeV}^{-1}$，并四舍五入到六位小数。例如，输出应如下所示：$\\left[0.000123,0.001234,0.000987,0.000456\\right]$（这只是一个示例；请根据上述模型计算实际值）。",
            "solution": "该问题要求设计并执行一个计算实验，以量化由复数 Gamow 态能量表示的连续谱耦合对弱束缚核系统转动响应的影响。转动响应由线性响应系数 $C$ 表征，该系数与转动惯量有关。目标是计算使用复数能量计算的响应系数（$C_{\\mathrm{complex}}$）与仅使用这些能量的实部计算的基准响应系数（$C_{\\mathrm{real\\_only}}$）之间的差异 $\\Delta C$。\n\n理论框架是在一个有限的、非厄米（复对称）基中描述的转动系统的不含时薛定谔方程。转动效应通过摇摆模型引入。\n\n系统的哈密顿量是摇摆频率 $\\omega$ 的函数：\n$$\nH(\\omega) = D - \\omega J_x\n$$\n在这里，$D$ 是一个对角矩阵，$D = \\mathrm{diag}(E_1, E_2, \\dots, E_N)$，其元素 $E_k$ 是基态的能量。对于束缚态，这些能量可以是实数；对于共振（Gamow）态，能量是复数，其中复数能量 $E_k = E_{r,k} - i\\Gamma_k/2$ 代表一个能量为 $E_{r,k}$、衰变宽度为 $\\Gamma_k$ 的共振。矩阵 $J_x$ 是角动量投影算符 $\\hat{J}_x$ 的实对称表示。参数 $\\omega$ 是一个具有能量单位的小实数。由于 $D$ 可以是复数而 $J_x$ 是实对称的，总哈密顿量 $H(\\omega)$ 是一个复对称矩阵，即 $H(\\omega) = H(\\omega)^{\\mathsf{T}}$。\n\n计算的核心涉及求解该哈密顿量在两个小的、对称的摇摆频率 $\\omega = +\\delta$ 和 $\\omega = -\\delta$（其中 $\\delta = 1 \\times 10^{-3} \\, \\mathrm{MeV}$）下的本征值问题：\n$$\nH(\\omega) \\, | \\psi_j(\\omega) \\rangle = \\lambda_j(\\omega) \\, | \\psi_j(\\omega) \\rangle\n$$\n这将产生一组本征值 $\\lambda_j(\\omega)$ 和相应的右本征矢量 $|\\psi_j(\\omega)\\rangle$。我们关心的是“类基态”，它被定义为其本征值 $\\lambda(\\omega)$ 具有最小实部的本征态。这个态是非转动系统基态的绝热延续。\n\n对于复对称哈密顿量，标准的厄米内积不适用。相反，我们使用双正交或复对称（$c$-）积。一个算符 $\\hat{O}$ 在态 $|\\psi\\rangle$ 下的期望值由以下公式给出：\n$$\n\\langle \\hat{O} \\rangle = \\frac{\\langle \\psi | \\hat{O} | \\psi \\rangle_c}{\\langle \\psi | \\psi \\rangle_c}\n$$\n其中 $c$-积定义为 $\\langle \\phi | \\psi \\rangle_c \\equiv \\phi^{\\mathsf{T}} \\psi$。这里，$\\phi^{\\mathsf{T}}$ 是列向量 $\\phi$ 的转置。在计算上，如果 $\\psi$ 是一个列向量，这可转换为 $\\psi^{\\mathsf{T}} O \\psi / (\\psi^{\\mathsf{T}} \\psi)$。\n\n使用类基态的本征矢量，我们计算在 $\\omega = +\\delta$ 和 $\\omega = -\\delta$ 时的角动量期望值 $\\langle J_x \\rangle_{\\omega}$。\n\n线性转动响应系数 $C$ 定义为角动量期望值的实部相对于摇摆频率的变化率，在 $\\omega=0$ 处求值：\n$$\nC = \\left. \\frac{d}{d\\omega} \\mathrm{Re} \\left( \\langle J_x \\rangle_{\\omega} \\right) \\right|_{\\omega=0}\n$$\n我们使用对称有限差分格式对该导数进行数值近似，该格式提供了二阶精确的近似值：\n$$\nC \\approx \\frac{\\mathrm{Re}(\\langle J_x \\rangle_{+\\delta}) - \\mathrm{Re}(\\langle J_x \\rangle_{-\\delta})}{(+\\delta) - (-\\delta)} = \\frac{\\mathrm{Re}(\\langle J_x \\rangle_{+\\delta}) - \\mathrm{Re}(\\langle J_x \\rangle_{-\\delta})}{2\\delta}\n$$\n\n为了分离连续谱的影响，我们对每个测试用例执行两次此计算：\n1.  **复数计算**：我们使用全套复数能量 $E_k$ 来构造 $D$，得到一个复对称的 $H(\\omega)$。上述过程得出系数 $C_{\\mathrm{complex}}$。\n2.  **纯实数基准**：我们通过将所有衰变宽度 $\\Gamma_k$ 设置为零来创建一个基准哈密顿量。这是通过仅取能量的实部 $E_{k,\\mathrm{real}} = \\mathrm{Re}(E_k)$ 来构造一个实对角矩阵 $D_{\\mathrm{real}}$ 实现的。得到的哈密顿量 $H_{\\mathrm{real\\_only}}(\\omega) = D_{\\mathrm{real}} - \\omega J_x$ 是实对称的。同样的过程得出系数 $C_{\\mathrm{real\\_only}}$。\n\n最终我们关心的量是这两个系数之间的差异，它量化了仅由衰变宽度的存在引起的转动响应变化：\n$$\n\\Delta C = C_{\\mathrm{complex}} - C_{\\mathrm{real\\_only}}\n$$\n\n每个测试用例的算法如下：\n1.  定义能量列表 $E$ 和矩阵 $J_x$。\n2.  定义 $\\delta = 1 \\times 10^{-3}$。\n3.  计算 $C_{\\mathrm{complex}}$：\n    a. 构造 $D = \\mathrm{diag}(E)$。\n    b. 求解 $H(+\\delta) = D - \\delta J_x$ 和 $H(-\\delta) = D + \\delta J_x$ 的本征问题。\n    c. 对每个问题，找到对应于具有最小实部本征值的本征矢量。\n    d. 使用 c-积计算 $\\langle J_x \\rangle_{+\\delta}$ 和 $\\langle J_x \\rangle_{-\\delta}$。\n    e. 使用有限差分公式计算 $C_{\\mathrm{complex}}$。\n4.  计算 $C_{\\mathrm{real\\_only}}$：\n    a. 构造 $E_{\\mathrm{real}} = \\mathrm{Re}(E)$。\n    b. 使用 $E_{\\mathrm{real}}$ 重复步骤 3 以找到 $C_{\\mathrm{real\\_only}}$。\n5.  计算 $\\Delta C = C_{\\mathrm{complex}} - C_{\\mathrm{real\\_only}}$。\n6.  每个测试用例的最终结果是 $\\Delta C$，以 $\\mathrm{MeV}^{-1}$ 为单位报告，并四舍五入到六位小数。\n\n该过程将为所提供的四个测试用例中的每一个实施。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the computational nuclear physics problem.\n    It iterates through the test cases, calculates the change in the\n    rotational response coefficient (Delta C), and prints the results.\n    \"\"\"\n\n    def calculate_response_coefficient(energies, Jx, delta):\n        \"\"\"\n        Calculates the linear rotational response coefficient C.\n\n        Args:\n            energies (list or np.ndarray): A list of state energies (can be complex).\n            Jx (np.ndarray): The matrix representation of the Jx operator.\n            delta (float): The small cranking frequency value.\n\n        Returns:\n            float: The calculated response coefficient C.\n        \"\"\"\n        # Ensure energies are of complex type for consistent calculations.\n        D = np.diag(np.asarray(energies, dtype=complex))\n\n        # --- Calculation for omega = +delta ---\n        H_plus = D - delta * Jx\n        # Solve the eigenvalue problem for the complex-symmetric Hamiltonian.\n        eigvals_p, eigvecs_p = np.linalg.eig(H_plus)\n        # Identify the ground-like state (minimum real part of eigenvalue).\n        idx_p = np.argmin(np.real(eigvals_p))\n        psi_p = eigvecs_p[:, idx_p]\n        # Compute the expectation value using the c-product.\n        # psi_p is a 1D array, so @ is dot product.\n        j_exp_p = (psi_p @ Jx @ psi_p) / (psi_p @ psi_p)\n\n        # --- Calculation for omega = -delta ---\n        H_minus = D + delta * Jx\n        eigvals_m, eigvecs_m = np.linalg.eig(H_minus)\n        idx_m = np.argmin(np.real(eigvals_m))\n        psi_m = eigvecs_m[:, idx_m]\n        j_exp_m = (psi_m @ Jx @ psi_m) / (psi_m @ psi_m)\n\n        # Compute C using a symmetric finite difference formula.\n        C = (np.real(j_exp_p) - np.real(j_exp_m)) / (2.0 * delta)\n        return C\n\n    # Define the cranking frequency delta.\n    delta = 1.0e-3  # in MeV\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (bound-only baseline)\n        {\n            \"E\": [-2.0, -1.0],\n            \"Jx\": np.array([[0.0, 0.5], [0.5, 0.0]])\n        },\n        # Case B (one narrow resonance)\n        {\n            \"E\": [-2.0, -1.0, 1.5 - 0.1j],\n            \"Jx\": np.array([[0.0, 0.5, 0.3], [0.5, 0.0, 0.2], [0.3, 0.2, 0.0]])\n        },\n        # Case C (one broad resonance)\n        {\n            \"E\": [-2.0, -1.5, 4.0 - 0.8j],\n            \"Jx\": np.array([[0.0, 0.4, 0.25], [0.4, 0.0, 0.35], [0.25, 0.35, 0.0]])\n        },\n        # Case D (near-threshold weakly bound state and multiple resonances)\n        {\n            \"E\": [-0.05, 0.7 - 0.05j, 2.0 - 0.5j],\n            \"Jx\": np.array([[0.0, 0.6, 0.2], [0.6, 0.0, 0.4], [0.2, 0.4, 0.0]])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        E = case[\"E\"]\n        Jx = case[\"Jx\"]\n\n        # 1. Calculate the response coefficient with complex energies.\n        C_complex = calculate_response_coefficient(E, Jx, delta)\n\n        # 2. Calculate the baseline response coefficient with real-only energies.\n        E_real_only = np.real(np.asarray(E))\n        C_real_only = calculate_response_coefficient(E_real_only, Jx, delta)\n\n        # 3. Compute the difference to isolate the continuum contribution.\n        delta_C = C_complex - C_real_only\n        results.append(delta_C)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理解核物理模型（如能量密度泛函）中的可观测量对其参数的敏感度，是检验和改进理论的关键一步。本练习介绍了一种高效的计算技术——伴随方法（adjoint method），用于执行灵敏度分析，而无需进行昂贵的蛮力式参数扫描。通过一个抽象但具有代表性的模型，你将学习如何推导并实现伴随方程，以确定转动惯量对不同张量耦合参数的依赖程度 。",
            "id": "3548292",
            "problem": "给定一个简化的有限维模型，该模型抽象了在Skyrme型框架中，核转动惯量对能量密度泛函（EDF）张量耦合的敏感度。目标是使用伴随方法计算转动惯量相对于同位旋标量和同位旋矢量张量耦合的敏感度导数，然后确定哪种耦合对转动惯量的控制作用更强。所有量都已无量纲化；所有计算出的导数均以无量纲数报告。本问题不涉及角度。\n\n基本原理：该模型建立在以下原理之上，您必须使用这些原理来推导算法和程序：\n- 在转动频率趋于零（$\\omega \\to 0$）的摇转计算中，广义局域密度（统称为向量 $x$）的平衡构型由能量泛函的驻点条件得到，这导出了欧拉-拉格朗日方程。在二次近似下，这产生一个形如\n$$\nF(x, C) = A(C)\\,x - b = 0,\n$$\n的线性系统，其中 $A(C)$ 是一个对称正定矩阵，它线性地依赖于一组EDF参数 $C$，而 $b$ 是一个常数源向量。\n- Thouless–Valatin转动惯量（以无量纲单位计）由一个二次型近似\n$$\nJ(x) = x^\\top W\\,x,\n$$\n其中 $W$ 是一个对称矩阵，它在小振幅极限下编码了惯量核。\n- J相对于参数C的敏感度导数，其中状态x满足驻点条件，必须通过对约束问题进行微分来计算。伴随方法提供了一种原则性的方法来获得此导数，而无需显式地对x关于参数进行微分。从上述定义出发，推导伴随方程和敏感度 $\\partial J/\\partial C$ 的表达式。\n\n在这个问题中，EDF张量耦合被限制为两个参数：同位旋标量耦合 $C_0^{J}$ 和同位旋矢量耦合 $C_1^{J}$。依赖于参数的刚度矩阵是\n$$\nA(C_0^{J}, C_1^{J}) = A_0 + C_0^{J}\\,M_0 + C_1^{J}\\,M_1,\n$$\n其中\n$$\nA_0 =\n\\begin{bmatrix}\n10.0  0.3  0.0  0.0 \\\\\n0.3  9.0  0.25  0.0 \\\\\n0.0  0.25  8.0  0.2 \\\\\n0.0  0.0  0.2  7.0\n\\end{bmatrix},\\quad\nM_0 =\n\\begin{bmatrix}\n0.40  0.05  0.00  0.00 \\\\\n0.05  0.35  0.05  0.00 \\\\\n0.00  0.05  0.30  0.05 \\\\\n0.00  0.00  0.05  0.25\n\\end{bmatrix},\n$$\n$$\nM_1 =\n\\begin{bmatrix}\n0.30  0.04  0.00  0.00 \\\\\n0.04  0.28  0.04  0.00 \\\\\n0.00  0.04  0.26  0.04 \\\\\n0.00  0.00  0.04  0.22\n\\end{bmatrix},\\quad\nb =\n\\begin{bmatrix}\n1.2 \\\\ -0.8 \\\\ 0.5 \\\\ 0.7\n\\end{bmatrix},\n$$\n以及\n$$\nW =\n\\begin{bmatrix}\n0.60  0.00  0.05  0.00 \\\\\n0.00  0.50  0.00  0.04 \\\\\n0.05  0.00  0.40  0.00 \\\\\n0.00  0.04  0.00  0.30\n\\end{bmatrix}.\n$$\n对于任何给定的 $(C_0^{J}, C_1^{J})$，平衡状态 $x$ 通过求解\n$$\nA(C_0^{J}, C_1^{J})\\,x = b.\n$$\n来定义。然后计算 $J(x) = x^\\top W x$。\n\n任务：\n1. 从驻点条件和 $J(x)$ 的定义出发，推导伴随方程以及敏感度导数 $\\partial J/\\partial C_0^{J}$ 和 $\\partial J/\\partial C_1^{J}$ 的最终表达式，用 $x$, $A$, $W$, $M_0$, 和 $M_1$ 表示。推导必须从所述的基本原理出发，不得假定任何快捷公式。\n2. 实现一个程序，该程序：\n   - 对于每个测试案例，构建 $A(C_0^{J}, C_1^{J})$，求解x，计算 $J(x)$，求解伴随系统，并评估敏感度 $\\partial J/\\partial C_0^{J}$ 和 $\\partial J/\\partial C_1^{J}$。\n   - 使用小微扰 $\\varepsilon = 10^{-6}$，通过中心有限差分验证伴随敏感度：\n     $$\n     \\frac{\\partial J}{\\partial C_t^{J}} \\approx \\frac{J(C_t^{J} + \\varepsilon) - J(C_t^{J} - \\varepsilon)}{2\\varepsilon},\\quad t\\in\\{0,1\\}.\n     $$\n     使用 $10^{-5}$ 的相对误差容差，相对误差定义为\n     $$\n     \\text{rel\\_err} = \\frac{\\left|\\text{adjoint} - \\text{finite\\_difference}\\right|}{\\left|\\text{finite\\_difference}\\right| + 10^{-12}}.\n     $$\n   - 在每个测试案例中，将具有最大绝对敏感度的耦合的索引 $t\\in\\{0,1\\}$ 识别为主导参数，控制着 $J$。\n3. 输出格式：您的程序应产生单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果。每个测试案例的结果必须是一个包含四个条目的列表：两个敏感度导数（四舍五入到八位小数），主导耦合的整数索引，以及一个布尔值，指示两个伴随导数是否都通过了验证容差。因此，最终输出必须如下所示：\n$$\n[\\,[d_0, d_1, t_{\\max}, \\text{bool}],\\,[\\dots],\\,[\\dots]\\,],\n$$\n其中数值条目表示为普通数字。所有导数都是无量纲的。\n\n测试套件：\n- 案例 1：$(C_0^{J}, C_1^{J}) = (0.12, -0.08)$。\n- 案例 2（边界情况）：$(C_0^{J}, C_1^{J}) = (0.0, 0.0)$。\n- 案例 3（在保持正定性的前提下的强耦合情况）：$(C_0^{J}, C_1^{J}) = (0.25, 0.18)$。\n\n你的程序必须实现伴随方法；不要通过显式微分x来计算 $\\partial J/\\partial C_t^{J}$。所有报告的导数都是无量纲数，并且你必须在最终输出中将导数四舍五入到八位小数。",
            "solution": "### 基于原理的设计：推导与算法\n\n这个问题的核心是计算一个可观测量（转动惯量 $J$）对模型参数 $C_t^J$ 的敏感度，其中系统状态 $x$ 通过一个约束方程 $F(x, C) = 0$ 隐式地依赖于这些参数。伴随方法为计算此类导数提供了一种高效的方式。\n\n#### 1. 伴随方法的理论推导\n\n设参数由向量 $C$ 表示，在我们的例子中是 $(C_0^J, C_1^J)$。该系统由两个方程控制：\n状态方程，源自欧拉-拉格朗日方程，定义了平衡状态向量 $x$：\n$$F(x, C) = A(C)x - b = 0 \\quad (*)$$\n可观测量，即Thouless-Valatin转动惯量 $J$：\n$$J(x) = x^\\top W x \\quad (**)$$\n其中 $A(C) = A_0 + C_0^{J}M_0 + C_1^{J}M_1$。矩阵 $A_0$、$M_0$、$M_1$ 和 $W$ 都是对称的。\n\n我们寻求计算 $J$ 相对于参数 $C_t$（其中 $t \\in \\{0, 1\\}$ 分别对应 $C_0^J$ 和 $C_1^J$）的全导数。由于 $x$ 是 $C$ 的函数，我们必须使用链式法则：\n$$\\frac{\\mathrm{d}J}{\\mathrm{d}C_t} = \\frac{\\partial J}{\\partial x}^\\top \\frac{\\mathrm{d}x}{\\mathrm{d}C_t}$$\n直接计算 $\\frac{\\mathrm{d}x}{\\mathrm{d}C_t}$ 项需要对状态方程 $(*)$ 微分并为每个参数求解一个线性系统，这是低效的。伴随方法避免了这个问题。\n\n我们引入一个增广泛函，即拉格朗日量 $\\mathcal{L}$，使用一个任意的拉格朗日乘子向量 $\\lambda$，也称为伴随状态向量：\n$$\\mathcal{L}(x, \\lambda, C) = J(x) + \\lambda^\\top F(x, C) = x^\\top W x + \\lambda^\\top(A(C)x - b)$$\n由于状态 $x$ 必须满足约束 $F(x,C)=0$，对于任意选择的 $\\lambda$，$\\mathcal{L}$ 的值都与 $J$ 相同。因此，它们关于 $C_t$ 的全导数也相等：\n$$\\frac{\\mathrm{d}J}{\\mathrm{d}C_t} = \\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}C_t}$$\n对 $\\mathcal{L}$ 应用多变量链式法则：\n$$\\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}C_t} = \\frac{\\partial \\mathcal{L}}{\\partial C_t} + \\left(\\frac{\\partial \\mathcal{L}}{\\partial x}\\right)^\\top \\frac{\\mathrm{d}x}{\\mathrm{d}C_t} + \\left(\\frac{\\partial \\mathcal{L}}{\\partial \\lambda}\\right)^\\top \\frac{\\mathrm{d}\\lambda}{\\mathrm{d}C_t}$$\n通过选择 $\\lambda$ 使其系数为零，可以消除包含未知项 $\\frac{\\mathrm{d}x}{\\mathrm{d}C_t}$ 的项。这就得到了**伴随方程**：\n$$\\frac{\\partial \\mathcal{L}}{\\partial x} = 0$$\n使用矩阵微积分中二次型和线性型对向量 $x$ 的导数法则（$\\nabla_x (x^\\top M x) = (M+M^\\top)x$ 和 $\\nabla_x(\\lambda^\\top M x) = M^\\top \\lambda$），我们得到：\n$$\\frac{\\partial \\mathcal{L}}{\\partial x} = \\frac{\\partial}{\\partial x}(x^\\top W x) + \\frac{\\partial}{\\partial x}(\\lambda^\\top A(C)x) = (W+W^\\top)x + A(C)^\\top \\lambda = 0$$\n由于 $W$ 是对称的，$W+W^\\top = 2W$。这就产生了关于 $\\lambda$ 的伴随方程：\n$$A(C)^\\top \\lambda = -2Wx$$\n由于刚度矩阵 $A(C)$ 也是对称的（$A_0, M_0, M_1$ 是对称的），我们有 $A(C)^\\top = A(C)$，伴随方程简化为：\n$$A(C)\\lambda = -2Wx \\quad (\\dagger)$$\n对于 $\\lambda$ 的这一特定选择，$\\mathcal{L}$ 导数中带有 $\\frac{\\mathrm{d}x}{\\mathrm{d}C_t}$ 的项消失了。此外，$\\mathcal{L}$ 关于 $\\lambda$ 的偏导数是：\n$$\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} = F(x, C) = A(C)x - b$$\n由于状态 $x$ 满足原始状态方程 $(*)$，该项为零。因此，带有 $\\frac{\\mathrm{d}\\lambda}{\\mathrm{d}C_t}$ 的项也消失了。\n\n敏感度导数的表达式急剧简化为：\n$$\\frac{\\mathrm{d}J}{\\mathrm{d}C_t} = \\frac{\\partial \\mathcal{L}}{\\partial C_t} = \\frac{\\partial}{\\partial C_t} \\left( x^\\top W x + \\lambda^\\top(A(C)x - b) \\right)$$\n由于 $x$、$W$ 和 $b$ 不显式依赖于 $C_t$（它们的依赖性是通过 $x(C)$ 体现的，而这已经被处理），导数是：\n$$\\frac{\\mathrm{d}J}{\\mathrm{d}C_t} = \\lambda^\\top \\left( \\frac{\\partial A(C)}{\\partial C_t} x \\right)$$\n对于我们的特定参数，$A(C)$ 的导数是：\n$$\\frac{\\partial A}{\\partial C_0^J} = M_0 \\quad \\text{和} \\quad \\frac{\\partial A}{\\partial C_1^J} = M_1$$\n将这些代入一般表达式，得到敏感度的最终公式：\n$$\\frac{\\partial J}{\\partial C_0^J} = \\lambda^\\top M_0 x$$\n$$\\frac{\\partial J}{\\partial C_1^J} = \\lambda^\\top M_1 x$$\n\n#### 2. 算法步骤\n\n上述推导定义了一个计算算法。对于每个给定的参数对 $(C_0^J, C_1^J)$：\n\n1.  **构建矩阵**：定义常数矩阵 $A_0, M_0, M_1, W$ 和向量 $b$。\n2.  **正向求解**：构建完整的刚度矩阵 $A = A_0 + C_0^J M_0 + C_1^J M_1$。求解线性方程组 $Ax = b$ 以找到状态向量 $x$。这是“正向”问题。\n3.  **伴随求解**：计算伴随方程的右侧项 $v = -2Wx$。求解线性系统 $A\\lambda = v$ 以找到伴随向量 $\\lambda$。这是“伴随”问题。请注意，正向和伴随求解都使用相同的矩阵 $A$，这是该方法的一个关键效率所在。\n4.  **计算敏感度**：使用推导出的表达式评估两个所需的敏感度：$dJ_0 = \\lambda^\\top M_0 x$ 和 $dJ_1 = \\lambda^\\top M_1 x$。\n5.  **验证敏感度**：对于每个参数 $C_t^J$，使用中心有限差分公式和小微扰 $\\varepsilon = 10^{-6}$ 计算数值导数：\n    $$ \\frac{\\partial J}{\\partial C_t^{J}} \\approx \\frac{J(C_t^{J} + \\varepsilon) - J(C_t^{J} - \\varepsilon)}{2\\varepsilon} $$\n    其中计算 $J(C_t^J \\pm \\varepsilon)$ 需要重新求解正向问题 $A(C \\pm \\delta C)x_{\\pm} = b$ 以得到 $x_{\\pm}$，然后评估 $J_{\\pm} = x_{\\pm}^\\top W x_{\\pm}$。使用指定的相对误差公式和 $10^{-5}$ 的容差，将伴随结果与有限差分结果进行比较。\n6.  **识别主导耦合**：确定与具有最大绝对敏感度的参数相对应的索引 $t \\in \\{0,1\\}$，即 $\\arg\\max_t |\\partial J/\\partial C_t^J|$。\n7.  **格式化输出**：对于每个测试案例，收集结果：两个四舍五入的敏感度导数，主导耦合的索引，以及一个指示验证是否成功的布尔值。\n\n此过程将在Python程序中实现，以解决所提供测试案例的问题。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes sensitivity derivatives of a model moment of inertia with respect\n    to EDF couplings using the adjoint method, validates the results against\n    finite differences, and formats the output as specified.\n    \"\"\"\n    # Define constant matrices and vector from the problem statement.\n    A0 = np.array([\n        [10.0, 0.3, 0.0, 0.0],\n        [0.3, 9.0, 0.25, 0.0],\n        [0.0, 0.25, 8.0, 0.2],\n        [0.0, 0.0, 0.2, 7.0]\n    ])\n    M0 = np.array([\n        [0.40, 0.05, 0.00, 0.00],\n        [0.05, 0.35, 0.05, 0.00],\n        [0.00, 0.05, 0.30, 0.05],\n        [0.00, 0.00, 0.05, 0.25]\n    ])\n    M1 = np.array([\n        [0.30, 0.04, 0.00, 0.00],\n        [0.04, 0.28, 0.04, 0.00],\n        [0.00, 0.04, 0.26, 0.04],\n        [0.00, 0.00, 0.04, 0.22]\n    ])\n    b = np.array([1.2, -0.8, 0.5, 0.7])\n    W = np.array([\n        [0.60, 0.00, 0.05, 0.00],\n        [0.00, 0.50, 0.00, 0.04],\n        [0.05, 0.00, 0.40, 0.00],\n        [0.00, 0.04, 0.00, 0.30]\n    ])\n\n    # Test cases\n    test_cases = [\n        (0.12, -0.08),\n        (0.0, 0.0),\n        (0.25, 0.18)\n    ]\n\n    all_results = []\n\n    for c0, c1 in test_cases:\n        # --- Adjoint Method Calculation ---\n\n        # 1. Forward solve: A(C)x = b\n        A = A0 + c0 * M0 + c1 * M1\n        x = np.linalg.solve(A, b)\n\n        # 2. Adjoint solve: A(C)λ = -2Wx\n        adjoint_rhs = -2 * (W @ x)\n        lambda_vec = np.linalg.solve(A, adjoint_rhs)\n\n        # 3. Compute sensitivities: dJ/dC = λ^T * (dA/dC) * x\n        dJ_dc0_adj = lambda_vec.T @ M0 @ x\n        dJ_dc1_adj = lambda_vec.T @ M1 @ x\n\n        # --- Validation with Finite Differences ---\n        eps = 1e-6\n        validation_passed = True\n\n        def calculate_J(c0_val, c1_val):\n            \"\"\"Helper function to compute J for given couplings.\"\"\"\n            A_val = A0 + c0_val * M0 + c1_val * M1\n            x_val = np.linalg.solve(A_val, b)\n            return x_val.T @ W @ x_val\n\n        # Validate dJ/dC0\n        J_plus_0 = calculate_J(c0 + eps, c1)\n        J_minus_0 = calculate_J(c0 - eps, c1)\n        dJ_dc0_fd = (J_plus_0 - J_minus_0) / (2 * eps)\n\n        # Validate dJ/dC1\n        J_plus_1 = calculate_J(c0, c1 + eps)\n        J_minus_1 = calculate_J(c0, c1 - eps)\n        dJ_dc1_fd = (J_plus_1 - J_minus_1) / (2 * eps)\n        \n        # Calculate relative errors\n        rel_tol = 1e-5\n        abs_tol_denom = 1e-12\n        rel_err_0 = abs(dJ_dc0_adj - dJ_dc0_fd) / (abs(dJ_dc0_fd) + abs_tol_denom)\n        rel_err_1 = abs(dJ_dc1_adj - dJ_dc1_fd) / (abs(dJ_dc1_fd) + abs_tol_denom)\n\n        if not (rel_err_0  rel_tol and rel_err_1  rel_tol):\n            validation_passed = False\n\n        # --- Identify Dominant Parameter ---\n        dominant_t = 0 if abs(dJ_dc0_adj) > abs(dJ_dc1_adj) else 1\n\n        # --- Store results ---\n        # Round derivatives to 8 decimal places as required for final output\n        d0_rounded = round(dJ_dc0_adj, 8)\n        d1_rounded = round(dJ_dc1_adj, 8)\n        \n        all_results.append([d0_rounded, d1_rounded, dominant_t, validation_passed])\n\n    # --- Format final output string ---\n    # Manually construct string to match [[d0,d1,t,B],[...]] without spaces\n    inner_parts = []\n    for res in all_results:\n        # str(bool) gives 'True' or 'False' as required\n        part = f\"[{res[0]},{res[1]},{res[2]},{str(res[3])}]\"\n        inner_parts.append(part)\n    final_output = f\"[{','.join(inner_parts)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}