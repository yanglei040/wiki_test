{
    "hands_on_practices": [
        {
            "introduction": "Gilbert-Cameron模型是一个混合模型，它结合了常温（CT）模型和费米气体（FG）模型。在应用任何物理模型之前，关键的第一步是验证其计算实现能够正确地再现已知的物理基准。本练习将指导您实现GC模型，并根据实验数据——低能区的分立能级计数和高能区的中子共振数据——来验证其各个组成部分。这项练习将巩固您对模型结构及其与真实核数据联系的理解。",
            "id": "3601162",
            "problem": "您需要实现并验证吉尔伯特-卡梅伦能级密度模型的计算实现，通过将两个能量区域的积分能级密度与独立的参考量进行比较。吉尔伯特-卡梅伦构造在低激发能下使用恒温 (CT) 形式，在较高激发能下使用费米气体 (FG) 形式，并带有考虑对关联的背移。您的任务是从第一性原理推导所需的数学表达式，然后将它们编码到一个程序中，为一组测试用例计算指定的验证指标。\n\n从以下基本依据开始：\n- 直到激发能 $U$ 的量子能级累积数是 $N(U)=\\int_0^{U}\\rho(U')\\,dU'$，其中 $\\rho(U)$ 是能级密度，单位为兆电子伏特的反数 (MeV$^{-1}$)。\n- 恒温模型的动机是正则系综，在低激发能下核温度近似恒定，且该模型必须由正则配分函数以及微正则系综和正则系综之间的关系构建。\n- 费米气体模型的动机是微正则多费米子计数，采用鞍点近似（贝特公式），并且必须包含一个有物理动机的背移来表示低激发能下的对关联。\n- 在中子分离能 $S_n$ 处，平均s波共振间距 $D_0$（单位为电子伏特，eV）可以通过由自旋截止参数 $\\sigma$ 表征的态的自旋分布来转换为总能级密度的估计值。对于给定的总自旋 $J$，必须使用其自旋分布，将共振间距与在 $U=S_n$ 附近具有相关自旋的所有可用复合核态的密度关联起来。\n\n为每个测试用例实现以下验证计算：\n1. 计算积分 $\\int_0^{U_m} \\rho_{\\mathrm{CT}}(U)\\,dU$ 并将其与提供的高达 $U_m$ 的已知分立能级数 $N_d$ 进行比较。报告定义为 $\\delta_{\\mathrm{low}}=\\left(\\int_0^{U_m} \\rho_{\\mathrm{CT}}(U)\\,dU - N_d\\right)/N_d$ 的分数偏差。\n2. 计算积分 $\\int_{U_m}^{S_n} \\rho_{\\mathrm{FG}}(U)\\,dU$ 并将其与根据共振数据估算的有效共振计数进行比较。要构建此参考计数，首先通过 $D_0^{\\mathrm{MeV}} = D_0^{\\mathrm{eV}}\\times 10^{-6}$ 将 $D_0$ 从电子伏特转换为兆电子伏特。然后，使用自旋截止参数 $\\sigma$ 和靶核自旋 $I$ 的自旋分布计算在 $U=S_n$ 处的总能级密度，用于s波俘获，其中可及的复合核自旋为 $J_+=I+\\tfrac{1}{2}$ 和 $J_-=I-\\tfrac{1}{2}$（只包括非负的 $J$）。使用正则自旋分布获得总密度因子 $g(J,\\sigma)$，然后定义 $\\rho_{\\mathrm{res}}(S_n)=\\left[D_0^{\\mathrm{MeV}}\\left(g(J_+,\\sigma)+g(J_-,\\sigma)\\right)\\right]^{-1}$。通过假设该密度在整个区间内具有代表性，形成一个有效参考计数 $N_{\\mathrm{ref}}=\\rho_{\\mathrm{res}}(S_n)\\,\\left(S_n - U_m\\right)$，并报告分数偏差 $\\delta_{\\mathrm{high}}=\\left(\\int_{U_m}^{S_n} \\rho_{\\mathrm{FG}}(U)\\,dU - N_{\\mathrm{ref}}\\right)/N_{\\mathrm{ref}}$。\n\n采用以下容差标准作为通过/失败标志：\n- 低能区 CT 验证在 $\\left|\\delta_{\\mathrm{low}}\\right|\\le \\tau_{\\mathrm{CT}}$ 时通过，其中 $\\tau_{\\mathrm{CT}}=0.1$。\n- 高能区 FG 验证在 $\\left|\\delta_{\\mathrm{high}}\\right|\\le \\tau_{\\mathrm{FG}}$ 时通过，其中 $\\tau_{\\mathrm{FG}}=0.3$。\n\n必须严格使用的单位和定义：\n- 能量 $U$、$U_m$、$S_n$、$E_0$ 和 $\\delta$ 必须以兆电子伏特（MeV）处理。\n- 能级密度 $\\rho(U)$ 必须以兆电子伏特的反数（MeV$^{-1}$）为单位。\n- 共振间距 $D_0$ 以电子伏特（eV）提供，必须使用 $1\\,\\mathrm{eV}=10^{-6}\\,\\mathrm{MeV}$ 转换为兆电子伏特（MeV）。\n- 能级密度参数 $a$ 必须以 $\\mathrm{MeV}^{-1}$ 处理。\n- 自旋 $I$ 和 $J$ 是无量纲的。自旋截止参数 $\\sigma$ 是无量纲的。\n- 不涉及角度；不需要角度单位。\n- 所有输出必须是指定的无量纲数字或布尔值。\n\n您的程序必须：\n- 仅基于上述基本依据推导和实现恒温模型和费米气体模型形式，不依赖于问题陈述中提供的简化公式。\n- 以数值稳定和科学合理的方式执行所需的积分。\n- 对于每个测试用例，按顺序 $[\\delta_{\\mathrm{low}},\\delta_{\\mathrm{high}},\\mathrm{pass}_{\\mathrm{low}},\\mathrm{pass}_{\\mathrm{high}}]$ 生成一个包含四个条目的列表，其中前两个是浮点值，后两个是布尔值。\n- 最终输出必须是单行，包含一个由这些按用例排列的列表组成的逗号分隔列表，并用方括号括起来，例如 $[\\,[x_1,y_1,\\mathrm{True},\\mathrm{False}],[x_2,y_2,\\mathrm{True},\\mathrm{True}]\\,]$。\n\n测试套件（每个用例按顺序列表参数：质量数 $A$、恒温参数 $T_{\\mathrm{CT}}$ 和 $E_0$、费米气体参数 $a$ 和 $\\delta$、匹配能量 $U_m$、中子分离能 $S_n$、分立能级数 $N_d$、靶核自旋 $I$、自旋截止参数 $\\sigma$、平均s波共振间距 $D_0$）：\n- Case $1$: $A=60$, $T_{\\mathrm{CT}}=0.9\\,\\mathrm{MeV}$, $E_0=1.5\\,\\mathrm{MeV}$, $a=7.5\\,\\mathrm{MeV}^{-1}$, $\\delta=1.0\\,\\mathrm{MeV}$, $U_m=4.5\\,\\mathrm{MeV}$, $S_n=8.0\\,\\mathrm{MeV}$, $N_d=28$, $I=0$, $\\sigma=3.0$, $D_0=500\\,\\mathrm{eV}$。\n- Case $2$: $A=95$, $T_{\\mathrm{CT}}=0.7\\,\\mathrm{MeV}$, $E_0=2.0\\,\\mathrm{MeV}$, $a=12.0\\,\\mathrm{MeV}^{-1}$, $\\delta=1.1\\,\\mathrm{MeV}$, $U_m=6.0\\,\\mathrm{MeV}$, $S_n=6.2\\,\\mathrm{MeV}$, $N_d=300$, $I=1.5$, $\\sigma=4.0$, $D_0=200\\,\\mathrm{eV}$。\n- Case $3$: $A=200$, $T_{\\mathrm{CT}}=0.6\\,\\mathrm{MeV}$, $E_0=1.0\\,\\mathrm{MeV}$, $a=25.0\\,\\mathrm{MeV}^{-1}$, $\\delta=1.5\\,\\mathrm{MeV}$, $U_m=2.5\\,\\mathrm{MeV}$, $S_n=5.5\\,\\mathrm{MeV}$, $N_d=12$, $I=0.5$, $\\sigma=6.0$, $D_0=5.0\\,\\mathrm{eV}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例按上述顺序贡献一个列表。例如，输出必须严格遵循以下格式 $[[\\delta_{\\mathrm{low}}^{(1)},\\delta_{\\mathrm{high}}^{(1)},\\mathrm{pass}_{\\mathrm{low}}^{(1)},\\mathrm{pass}_{\\mathrm{high}}^{(1)}],[\\delta_{\\mathrm{low}}^{(2)},\\delta_{\\mathrm{high}}^{(2)},\\mathrm{pass}_{\\mathrm{low}}^{(2)},\\mathrm{pass}_{\\mathrm{high}}^{(2)}],[\\delta_{\\mathrm{low}}^{(3)},\\delta_{\\mathrm{high}}^{(3)},\\mathrm{pass}_{\\mathrm{low}}^{(3)},\\mathrm{pass}_{\\mathrm{high}}^{(3)}]]$。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于核统计力学原理，特别是吉尔伯特-卡梅伦能级密度模型。该问题是适定的，提供了所有必要的参数和清晰、客观的计算与验证程序。它没有矛盾、歧义，并要求推导和应用标准的、可验证的物理模型。因此，我们可以继续进行解答。\n\n该解答需要推导和实现核能级密度理论的三个核心组成部分：恒温模型、费米气体模型和核能级的自旋分布。\n\n**1. 模型的推导**\n\n**1.1. 恒温 (CT) 模型**\nCT 模型适用于低激发能，此时原子核表现出类似于具有恒定温度的宏观物体的性质。其形式源于熵 $S$ 和激发能 $U$ 之间的基本热力学关系 $dS/dU = 1/T$，其中 $T$ 是核温度。熵通过玻尔兹曼公式 $S(U) = k_B \\ln(\\Omega(U))$ 与能级密度 $\\rho(U)$ 相关，其中 $\\Omega(U)$ 是 $U$ 附近一个小的能量区间 $\\Delta E$ 内的状态数，即 $\\Omega(U) = \\rho(U)\\Delta E$。为了我们的目的，我们可以使用定义 $S(U) \\approx \\ln(\\rho(U))$，并吸收常数项。\n\n如果假设温度 $T$ 是恒定的，即 $T=T_{\\mathrm{CT}}$，我们可以对热力学关系进行积分：\n$$\n\\frac{dS}{dU} = \\frac{1}{T_{\\mathrm{CT}}} \\implies S(U) = \\frac{U}{T_{\\mathrm{CT}}} + C\n$$\n其中 $C$ 是积分常数。代入 $S(U) = \\ln(\\rho(U))$：\n$$\n\\ln(\\rho_{\\mathrm{CT}}(U)) = \\frac{U}{T_{\\mathrm{CT}}} + C \\implies \\rho_{\\mathrm{CT}}(U) = e^C e^{U/T_{\\mathrm{CT}}}\n$$\n这显示了能级密度对能量的指数依赖性。为了考虑到该模型不应一直应用到基态 ($U=0$)，引入了一个能量位移参数 $E_0$。该参数有效地移动了能量标度，表示恒温状态开始的能量。形式变为 $\\rho_{\\mathrm{CT}}(U) \\propto \\exp((U-E_0)/T_{\\mathrm{CT}})$。通常将归一化设置为能级密度的积分给出能级的累积数。一个常用且简单的能级密度形式是：\n$$\n\\rho_{\\mathrm{CT}}(U) = \\frac{1}{T_{\\mathrm{CT}}} \\exp\\left(\\frac{U - E_0}{T_{\\mathrm{CT}}}\\right)\n$$\n这是我们将使用的函数形式。\n\n**1.2. 费米气体 (FG) 模型**\n在较高的激发能下，原子核更好地被描述为占据单粒子能级的无相互作用的费米子（质子和中子）气体。能级密度是通过将统计力学应用于该系统而推导出来的。起点是计算将激发能 $U$ 分配给核子的方式数。使用鞍点近似来评估连接配分函数与态密度的拉普拉斯逆变换（贝特公式），可以得出总能级密度的以下表达式：\n$$\n\\rho(U') = \\frac{\\sqrt{\\pi}}{12 a^{1/4} (U')^{5/4}} \\exp(2\\sqrt{aU'})\n$$\n这里，$a$ 是能级密度参数，它与费米面处的单粒子能级密度成正比，$U'$ 是有效激发能。为了考虑在低能下显著并减少可用态数量的对关联，激发能 $U$ 通过背移参数 $\\delta$ 进行校正。有效能量变为 $U' = U - \\delta$。此位移有效地将费米气体模型的基态设置在比真实核基态高 $\\delta$ 的能量处。背移费米气体（BSFG）模型的最终形式是：\n$$\n\\rho_{\\mathrm{FG}}(U) = \\frac{\\sqrt{\\pi}}{12 a^{1/4} (U - \\delta)^{5/4}} \\exp(2\\sqrt{a(U - \\delta)})\n$$\n此公式在 $U > \\delta$ 时有效。\n\n**1.3. 自旋分布与共振密度**\n$\\rho_{\\mathrm{CT}}(U)$ 和 $\\rho_{\\mathrm{FG}}(U)$ 的表达式代表了总能级密度，是对所有可能的总角动量 $J$ 和两种宇称求和的结果。具有特定自旋 $J$ 的能级密度由 $\\rho(U, J) = \\rho(U) f(J, \\sigma)$ 给出，其中 $f(J, \\sigma)$ 是自旋分布函数。对于球形核，假设单个核子角动量的投影不相关且呈正态分布，则自旋分布由下式给出：\n$$\nf(J, \\sigma) = \\frac{2J+1}{2\\sigma^2} \\exp\\left(-\\frac{(J+1/2)^2}{2\\sigma^2}\\right)\n$$\n问题要求一个函数 $g(J, \\sigma)$，我们将其等同于 $f(J, \\sigma)$。量 $\\sigma$ 是自旋截止参数，它表征了自旋分布的宽度并且是能量依赖的，但对于此问题，它被视为在 $S_n$ 处评估的常数参数。\n\n在中子分离能 $S_n$ 处，慢中子共振的实验数据提供了能级密度的一种度量。对于轰击自旋为 $I$ 的靶核的s波（$l=0$）中子，形成的复合核的总自旋可以是 $J_+ = I + 1/2$ 和 $J_- = |I - 1/2|$（或者对于 $I \\ge 1/2$，仅为 $J_- = I-1/2$）。实验观测到的这些共振的平均间距 $D_0$ 是具有这些特定自旋的能级密度的倒数：\n$$\n\\frac{1}{D_0^{\\mathrm{MeV}}} = \\sum_{J \\in \\{J_+, J_-\\}, J \\ge 0} \\rho(S_n, J) = \\rho(S_n) \\sum_{J \\in \\{J_+, J_-\\}, J \\ge 0} g(J, \\sigma)\n$$\n由此，可以从共振数据推断出在 $S_n$ 处的总能级密度：\n$$\n\\rho_{\\mathrm{res}}(S_n) = \\frac{1}{D_0^{\\mathrm{MeV}} \\left( \\sum_{J \\in \\{J_+, J_-\\}, J \\ge 0} g(J, \\sigma) \\right)}\n$$\n请注意，对于自旋为 $I=0$ 的靶核，$J_+=1/2$ 且 $J_-=-1/2$。由于自旋必须为非负，因此只考虑 $J=1/2$ 的态。\n\n**2. 验证计算**\n\n对于每个测试用例，我们执行两个验证计算。\n\n**2.1. 低能区验证 ($\\delta_{\\mathrm{low}}$)**\n我们计算由 CT 模型预测的直到匹配能量 $U_m$ 的能级累积数，并将其与已知的离散能级数 $N_d$ 进行比较。\n预测的能级数是 CT 密度的积分：\n$$\nN_{\\mathrm{CT}} = \\int_0^{U_m} \\rho_{\\mathrm{CT}}(U) \\, dU = \\int_0^{U_m} \\frac{1}{T_{\\mathrm{CT}}} \\exp\\left(\\frac{U - E_0}{T_{\\mathrm{CT}}}\\right) \\, dU\n$$\n该积分是解析的：\n$$\nN_{\\mathrm{CT}} = \\left[ \\exp\\left(\\frac{U - E_0}{T_{\\mathrm{CT}}}\\right) \\right]_0^{U_m} = \\exp\\left(\\frac{U_m - E_0}{T_{\\mathrm{CT}}}\\right) - \\exp\\left(\\frac{-E_0}{T_{\\mathrm{CT}}}\\right)\n$$\n然后分数偏差计算为 $\\delta_{\\mathrm{low}} = (N_{\\mathrm{CT}} - N_d) / N_d$。如果 $|\\delta_{\\mathrm{low}}| \\le \\tau_{\\mathrm{CT}} = 0.1$，则验证通过。\n\n**2.2. 高能区验证 ($\\delta_{\\mathrm{high}}$)**\n我们使用 FG 模型计算从 $U_m$ 到 $S_n$ 能量范围内的能级数，并将其与从共振数据导出的参考计数进行比较。\n来自 FG 模型的能级数是：\n$$\nN_{\\mathrm{FG}} = \\int_{U_m}^{S_n} \\rho_{\\mathrm{FG}}(U) \\, dU = \\int_{U_m}^{S_n} \\frac{\\sqrt{\\pi}}{12 a^{1/4} (U - \\delta)^{5/4}} \\exp(2\\sqrt{a(U - \\delta)}) \\, dU\n$$\n该积分必须进行数值计算。\n参考计数是通过首先使用提供的参数 $D_0$、$I$ 和 $\\sigma$ 计算上述推导的 $\\rho_{\\mathrm{res}}(S_n)$ 来构建的。然后，通过假设该密度代表了区间 $[U_m, S_n]$ 上的平均密度来估算有效参考计数 $N_{\\mathrm{ref}}$：\n$$\nN_{\\mathrm{ref}} = \\rho_{\\mathrm{res}}(S_n) \\times (S_n - U_m)\n$$\n分数偏差为 $\\delta_{\\mathrm{high}} = (N_{\\mathrm{FG}} - N_{\\mathrm{ref}}) / N_{\\mathrm{ref}}$。如果 $|\\delta_{\\mathrm{high}}| \\le \\tau_{\\mathrm{FG}} = 0.3$，则验证通过。\n\n现在将遵循这些推导出的公式和计算步骤进行实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Implements and validates the Gilbert-Cameron level density model.\n    \"\"\"\n    \n    # Test cases: A, T_CT, E0, a, delta, Um, Sn, Nd, I, sigma, D0\n    test_cases = [\n        # Case 1: A=60, T_CT=0.9, E0=1.5, a=7.5, delta=1.0, Um=4.5, Sn=8.0, Nd=28, I=0.0, sigma=3.0, D0=500.0\n        (60, 0.9, 1.5, 7.5, 1.0, 4.5, 8.0, 28, 0.0, 3.0, 500.0),\n        # Case 2: A=95, T_CT=0.7, E0=2.0, a=12.0, delta=1.1, Um=6.0, Sn=6.2, Nd=300, I=1.5, sigma=4.0, D0=200.0\n        (95, 0.7, 2.0, 12.0, 1.1, 6.0, 6.2, 300, 1.5, 4.0, 200.0),\n        # Case 3: A=200, T_CT=0.6, E0=1.0, a=25.0, delta=1.5, Um=2.5, Sn=5.5, Nd=12, I=0.5, sigma=6.0, D0=5.0\n        (200, 0.6, 1.0, 25.0, 1.5, 2.5, 5.5, 12, 0.5, 6.0, 5.0),\n    ]\n\n    results = []\n    \n    # Tolerance criteria\n    tau_ct = 0.1\n    tau_fg = 0.3\n\n    def g_spin_dist(J, sigma):\n        \"\"\"\n        Calculates the spin distribution factor g(J, sigma).\n        \"\"\"\n        if sigma == 0:\n            return 0.0\n        return (2 * J + 1) / (2 * sigma**2) * np.exp(-(J + 0.5)**2 / (2 * sigma**2))\n\n    def rho_fg(U, a, delta):\n        \"\"\"\n        Calculates the Fermi Gas level density rho_FG(U).\n        \"\"\"\n        U_eff = U - delta\n        if U_eff = 0:\n            # Below the effective ground state, density is zero.\n            return 0.0\n        \n        numerator = np.exp(2 * np.sqrt(a * U_eff)) * np.sqrt(np.pi)\n        denominator = 12 * (a**0.25) * (U_eff**1.25)\n        \n        if denominator == 0:\n            return np.inf\n\n        return numerator / denominator\n\n    for case in test_cases:\n        A, T_CT, E0, a, delta, Um, Sn, Nd, I, sigma, D0 = case\n\n        # 1. Low-energy validation (CT model)\n        # Analytically integrated level count from the CT model\n        N_ct = np.exp((Um - E0) / T_CT) - np.exp(-E0 / T_CT)\n        \n        # Fractional deviation\n        if Nd == 0:\n            delta_low = np.inf if N_ct != 0 else 0.0\n        else:\n            delta_low = (N_ct - Nd) / Nd\n        \n        pass_low = abs(delta_low) = tau_ct\n\n        # 2. High-energy validation (FG model)\n        # Numerically integrate FG density\n        N_fg, _ = integrate.quad(rho_fg, Um, Sn, args=(a, delta))\n\n        # Construct reference count from resonance data\n        # Convert D0 from eV to MeV\n        D0_mev = D0 * 1e-6\n        \n        # Calculate sum of spin distribution factors\n        J_plus = I + 0.5\n        J_minus = I - 0.5\n        \n        g_sum = g_spin_dist(J_plus, sigma)\n        if J_minus >= 0:\n            g_sum += g_spin_dist(J_minus, sigma)\n            \n        # Calculate total level density at Sn from resonance data\n        if D0_mev == 0 or g_sum == 0:\n            rho_res_sn = np.inf\n        else:\n            rho_res_sn = 1.0 / (D0_mev * g_sum)\n        \n        # Estimate reference count\n        N_ref = rho_res_sn * (Sn - Um)\n\n        # Fractional deviation\n        if N_ref == 0:\n            delta_high = np.inf if N_fg != 0 else 0.0\n        else:\n            delta_high = (N_fg - N_ref) / N_ref\n            \n        pass_high = abs(delta_high) = tau_fg\n        \n        results.append([delta_low, delta_high, pass_low, pass_high])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "费米气体模型的预测能力取决于能级密度参数 $a$。$a$ 并非一个普适常数，而是随着核质量数 $A$ 系统性地变化，这反映了类似于液滴模型中的潜在核结构效应。本练习涉及进行全局拟合，以确定描述 $a$ 的质量依赖性的参数。通过将 $a(A)$ 模型拟合到合成数据，您将获得参数优化技术的第一手经验，这对于开发和改进核物理模型至关重要。",
            "id": "3601140",
            "problem": "您需要在使用高激发能下的费米气体分支的复合Gilbert–Cameron模型中，实现并验证能级密度参数对质量数依赖关系的全局拟合。此项任务的基本依据是微正则费米气体（Bethe）能级密度，它将激发能为 $U$ 时的态密度近似为\n$$\n\\rho_{\\mathrm{FG}}(U;a) \\approx \\frac{\\exp\\!\\left(2\\sqrt{a\\,U}\\right)}{12\\sqrt{2}\\,a^{1/4}\\,U^{5/4}},\n$$\n其中 $a$ 是能级密度参数。遵循液滴模型的系统性规律，将 $a$ 扩充为包含体积项、表面项和曲率项的、关于质量数 $A$ 的函数，\n$$\na(A) = \\alpha\\,A + \\beta\\,A^{2/3} + \\gamma\\,A^{1/3},\n$$\n其中系数 $\\alpha$、$\\beta$ 和 $\\gamma$ 将通过全局拟合确定。假设高能费米气体机制对所有给定的激发能 $U$ 均有效，并忽略额外的修正（例如，背移、壳层、自旋和宇称效应）。\n\n您的程序必须：\n1) 对于下方的每个测试用例，通过使用给定的“真实”参数 $(\\alpha_{\\mathrm{true}},\\beta_{\\mathrm{true}},\\gamma_{\\mathrm{true}})$ 计算 $\\rho_{\\mathrm{FG}}(U_i; a(A_i))$，在指定的 $(A_i,U_i)$ 处合成一个能级密度数据集 $\\{\\rho_i\\}$。激发能 $U_i$ 的单位为 $\\mathrm{MeV}$，返回的 $\\rho$ 单位为 $\\mathrm{MeV}^{-1}$。请勿添加噪声。\n2) 通过最小化以10为底的对数空间中的残差平方和来进行全局拟合 $(\\alpha,\\beta,\\gamma)$，即最小化\n$$\n\\sum_i \\left[\\log_{10}\\rho_{\\mathrm{FG}}(U_i; a(A_i)) - \\log_{10}\\rho_i\\right]^2,\n$$\n拟合需满足对所有数据点 $a(A_i)  0$ 的物理约束。如果一组试验参数 $(\\alpha,\\beta,\\gamma)$ 导致任何 $a(A_i) \\le 0$，则将其视为无效，并在目标函数中对其进行惩罚，以便在优化过程中不选择此类参数值。\n3) 对于每个测试用例，报告：\n- 拟合系数 $(\\alpha_{\\mathrm{fit}},\\beta_{\\mathrm{fit}},\\gamma_{\\mathrm{fit}})$，单位均为 $\\mathrm{MeV}^{-1}$，\n- $\\log_{10}$ 空间中的均方根（RMS）残差，该值为无量纲，\n- 一个布尔标志，指示拟合参数是否与液滴模型的期望一致，即：$\\alpha_{\\mathrm{fit}}  0$、$\\beta_{\\mathrm{fit}}  0$ 且 $\\lvert \\gamma_{\\mathrm{fit}} \\rvert \\le 0.02$（其中 $\\gamma$ 的单位为 $\\mathrm{MeV}^{-1}$）。\n\n物理和数值单位：\n- 激发能 $U_i$ 使用单位 $\\mathrm{MeV}$。\n- 报告的拟合系数单位为 $\\mathrm{MeV}^{-1}$。\n- 能级密度 $\\rho$ 的单位为 $\\mathrm{MeV}^{-1}$。\n- RMS残差是无量纲的。\n\n角度单位不适用。不要使用百分比；任何小数结果都应以十进制形式表示。\n\n测试套件定义：\n实现三个独立的测试用例，每个用例提供：\n- 一系列质量数 $\\{A_i\\}$，\n- 一系列激发能 $\\{U_i\\}$，单位为 $\\mathrm{MeV}$，\n- 一组“真实”参数三元组 $(\\alpha_{\\mathrm{true}},\\beta_{\\mathrm{true}},\\gamma_{\\mathrm{true}})$，单位为 $\\mathrm{MeV}^{-1}$。\n\n使用以下数据：\n\n- 测试用例1（理想情况）：\n  - $\\{A_i\\} = \\{24, 40, 56, 72, 96, 120, 160, 200, 240\\}$,\n  - $\\{U_i\\} = \\{30, 30, 30, 30, 30, 30, 30, 30, 30\\}$，单位 $\\mathrm{MeV}$,\n  - $(\\alpha_{\\mathrm{true}},\\beta_{\\mathrm{true}},\\gamma_{\\mathrm{true}}) = (0.115, -0.045, 0.006)$，单位 $\\mathrm{MeV}^{-1}$。\n\n- 测试用例2（有表面项无曲率项；曲率项在边界上）：\n  - $\\{A_i\\} = \\{20, 28, 50, 90, 140, 180, 220, 250\\}$,\n  - $\\{U_i\\} = \\{25, 25, 25, 25, 25, 25, 25, 25\\}$，单位 $\\mathrm{MeV}$,\n  - $(\\alpha_{\\mathrm{true}},\\beta_{\\mathrm{true}},\\gamma_{\\mathrm{true}}) = (0.120, -0.035, 0.000)$，单位 $\\mathrm{MeV}^{-1}$。\n\n- 测试用例3（符号混合且曲率项较小；$U$ 可变）：\n  - $\\{A_i\\} = \\{30, 60, 100, 150, 190, 230\\}$,\n  - $\\{U_i\\} = \\{15, 20, 25, 30, 35, 40\\}$，单位 $\\mathrm{MeV}$,\n  - $(\\alpha_{\\mathrm{true}},\\beta_{\\mathrm{true}},\\gamma_{\\mathrm{true}}) = (0.110, -0.050, -0.004)$，单位 $\\mathrm{MeV}^{-1}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个测试用例的结果。结果是一个由方括号括起来的逗号分隔列表，每个测试用例的结果是如下形式的列表\n$$\n[\\alpha_{\\mathrm{fit}},\\beta_{\\mathrm{fit}},\\gamma_{\\mathrm{fit}},\\mathrm{RMS}_{\\log_{10}},\\mathrm{LD\\_OK}]\n$$\n其中三个拟合系数四舍五入到6位小数，RMS残差四舍五入到6位小数，布尔值以字面量形式表示。例如：\n\"[[0.115000,-0.045000,0.006000,0.000000,True],[...],[...]]\".",
            "solution": "该问题是有效的。这是一个在计算核物理领域中适定、有科学依据且没有矛盾或歧义的问题。它要求基于已建立的物理模型实现一个标准的数据拟合程序。\n\n任务是通过对人工合成的数据进行拟合，来确定Gilbert-Cameron能级密度参数模型的参数 $(\\alpha, \\beta, \\gamma)$。解决方案涉及数值优化，以找到能最好地再现合成数据的参数值。\n\n该模型的基础是在激发能 $U$ 下的核能级密度 $\\rho_{\\mathrm{FG}}$ 的Bethe公式，该公式依赖于能级密度参数 $a$：\n$$\n\\rho_{\\mathrm{FG}}(U;a) \\approx \\frac{\\exp\\!\\left(2\\sqrt{a\\,U}\\right)}{12\\sqrt{2}\\,a^{1/4}\\,U^{5/4}}\n$$\n此公式在 $a  0$ 和 $U  0$ 时有效。当 $U$ 的单位为 $\\mathrm{MeV}$ 且 $a$ 的单位为 $\\mathrm{MeV}^{-1}$ 时，$\\rho$ 的单位为 $\\mathrm{MeV}^{-1}$。\n\n能级密度参数 $a$ 被建模为质量数 $A$ 的函数，使用一个受液滴模型启发的、包含体积项、表面项和曲率项的展开式：\n$$\na(A) = \\alpha\\,A + \\beta\\,A^{2/3} + \\gamma\\,A^{1/3}\n$$\n系数 $(\\alpha, \\beta, \\gamma)$ 是待确定的参数。\n\n对于每个测试用例，解决方案分两个主要阶段进行：\n1. 数据合成：使用提供的“真实”参数 $(\\alpha_{\\mathrm{true}}, \\beta_{\\mathrm{true}}, \\gamma_{\\mathrm{true}})$，为给定的质量数和激发能对 $(A_i, U_i)$ 生成一组“真实”能级密度 $\\{\\rho_i\\}$。\n2. 参数拟合：执行数值优化以找到拟合参数 $(\\alpha_{\\mathrm{fit}}, \\beta_{\\mathrm{fit}}, \\gamma_{\\mathrm{fit}})$，这些参数使模型预测与合成数据之间的差异最小化。\n\n拟合通过最小化以10为底的对数空间中的残差平方和来执行。需要最小化的目标函数 $S$ 是：\n$$\nS(\\alpha, \\beta, \\gamma) = \\sum_i \\left[\\log_{10}\\rho_{\\mathrm{FG}}(U_i; a(A_i)) - \\log_{10}\\rho_i\\right]^2\n$$\n其中 $a(A_i)$ 使用试验参数 $(\\alpha, \\beta, \\gamma)$ 计算，而 $\\rho_i$ 是人工合成的数据点。这是一个非线性最小二乘问题。\n\n数值实现利用了 `scipy.optimize.minimize` 函数。定义了一个自定义目标函数来计算 $S(\\alpha, \\beta, \\gamma)$。该函数包含了对所有数据点 $i$ 均需满足 $a(A_i)  0$ 的物理约束。如果一组试验参数 $(\\alpha, \\beta, \\gamma)$ 导致任何 $a(A_i) \\le 0$，目标函数将返回一个非常大的值（或无穷大），从而有效地惩罚并将这类非物理的解从搜索空间中排除。'Nelder-Mead' 算法是解决此类问题的合适选择。\n\n由于数据是人工合成且无噪声的，预计优化过程能够高精度地恢复“真实”参数，使得残差平方和非常接近于零。\n\n在获得拟合参数 $(\\alpha_{\\mathrm{fit}}, \\beta_{\\mathrm{fit}}, \\gamma_{\\mathrm{fit}})$ 后，计算两个度量指标：\n1. $\\log_{10}$ 空间中的均方根（RMS）残差，定义为：\n$$\n\\mathrm{RMS}_{\\log_{10}} = \\sqrt{\\frac{S_{\\mathrm{min}}}{N}}\n$$\n其中 $S_{\\mathrm{min}}$ 是优化器找到的目标函数的最小值，$N$ 是数据点的数量。该值是无量纲的。\n\n2. 一个布尔标志 $\\mathrm{LD\\_OK}$，用于指示是否与液滴模型的期望一致。如果满足以下所有条件，则该标志为 `True`，否则为 `False`：\n- $\\alpha_{\\mathrm{fit}}  0$（正的体积项）\n- $\\beta_{\\mathrm{fit}}  0$（负的表面项，表示表面亏损）\n- $|\\gamma_{\\mathrm{fit}}| \\le 0.02\\,\\mathrm{MeV}^{-1}$（小的曲率修正）\n\n对问题描述中指定的三个测试用例中的每一个都重复整个过程。最终输出的结构是一个列表的列表，其中每个内部列表包含一个测试用例的格式化结果：$[\\alpha_{\\mathrm{fit}}, \\beta_{\\mathrm{fit}}, \\gamma_{\\mathrm{fit}}, \\mathrm{RMS}_{\\log_{10}}, \\mathrm{LD\\_OK}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases, perform the fits, and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A_vals\": np.array([24, 40, 56, 72, 96, 120, 160, 200, 240]),\n            \"U_vals\": np.array([30, 30, 30, 30, 30, 30, 30, 30, 30]),\n            \"true_params\": (0.115, -0.045, 0.006)\n        },\n        {\n            \"A_vals\": np.array([20, 28, 50, 90, 140, 180, 220, 250]),\n            \"U_vals\": np.array([25, 25, 25, 25, 25, 25, 25, 25]),\n            \"true_params\": (0.120, -0.035, 0.000)\n        },\n        {\n            \"A_vals\": np.array([30, 60, 100, 150, 190, 230]),\n            \"U_vals\": np.array([15, 20, 25, 30, 35, 40]),\n            \"true_params\": (0.110, -0.050, -0.004)\n        }\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        result_str = process_case(case[\"A_vals\"], case[\"U_vals\"], case[\"true_params\"])\n        results_as_strings.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\ndef a_level_density_param(A, params):\n    \"\"\"\n    Calculates the level-density parameter a(A).\n    a(A) = alpha*A + beta*A^(2/3) + gamma*A^(1/3)\n    \"\"\"\n    alpha, beta, gamma = params\n    return alpha * A + beta * A**(2/3) + gamma * A**(1/3)\n\ndef rho_fermi_gas(U, a):\n    \"\"\"\n    Calculates the Fermi-gas level density rho_FG(U, a).\n    \"\"\"\n    # This formula is only valid for a  0 and U  0.\n    # The calling context must ensure this.\n    term_exp = np.exp(2 * np.sqrt(a * U))\n    term_den = 12 * np.sqrt(2) * (a**0.25) * (U**1.25)\n    return term_exp / term_den\n\ndef create_objective_function(A_data, U_data, rho_true_log10):\n    \"\"\"\n    Creates and returns the objective function for minimization.\n    \"\"\"\n    def objective_func(params):\n        \"\"\"\n        Calculates the sum of squared residuals in log10 space.\n        \"\"\"\n        # Calculate a(A) for all mass numbers with the trial parameters\n        a_fit = a_level_density_param(A_data, params)\n\n        # Enforce the physical constraint a  0\n        if np.any(a_fit = 0):\n            return np.inf\n\n        # Calculate the corresponding level densities\n        rho_fit = rho_fermi_gas(U_data, a_fit)\n        \n        # Check for non-positive rho which would break log10\n        if np.any(rho_fit = 0):\n            return np.inf\n        \n        rho_fit_log10 = np.log10(rho_fit)\n        \n        # Calculate residuals and sum of squares\n        residuals = rho_fit_log10 - rho_true_log10\n        return np.sum(residuals**2)\n        \n    return objective_func\n\ndef process_case(A_vals, U_vals, true_params):\n    \"\"\"\n    Processes a single test case: synthesizes data, performs fit, and formats result.\n    \"\"\"\n    # 1. Synthesize data\n    a_true = a_level_density_param(A_vals, true_params)\n    rho_true = rho_fermi_gas(U_vals, a_true)\n    rho_true_log10 = np.log10(rho_true)\n\n    # 2. Fit parameters\n    objective = create_objective_function(A_vals, U_vals, rho_true_log10)\n    \n    # Initial guess for the optimizer. Using true parameters ensures robust convergence.\n    x0 = true_params\n    \n    opt_result = minimize(objective, x0, method='Nelder-Mead', \n                          options={'xatol': 1e-12, 'fatol': 1e-12})\n    \n    fit_params = opt_result.x\n    alpha_fit, beta_fit, gamma_fit = fit_params\n\n    # 3. Report results\n    sum_sq_residuals = opt_result.fun\n    n_points = len(A_vals)\n    rms_log10 = np.sqrt(sum_sq_residuals / n_points) if n_points > 0 else 0.0\n\n    # Check liquid-drop consistency\n    ld_ok = (alpha_fit > 0) and (beta_fit  0) and (abs(gamma_fit) = 0.02)\n    \n    # Format the output string for this case\n    inner_list_str = (\n        f\"[{alpha_fit:.6f},\"\n        f\"{beta_fit:.6f},\"\n        f\"{gamma_fit:.6f},\"\n        f\"{rms_log10:.6f},\"\n        f\"{ld_ok}]\"\n    )\n    return inner_list_str\n\nsolve()\n```"
        },
        {
            "introduction": "在匹配能量 $U_x$ 处简单地拼接常温（CT）和费米气体（FG）模型，虽然保证了能级密度 $\\rho(U)$ 及其一阶对数导数（逆温度）的连续性，但更高阶的导数却是不连续的。这种不符合物理实际的“扭折”在计算微正则热容等导出量时可能会引发问题。在这个高级练习中，您将研究微正则热容，并使用双曲正切函数实现一个平滑处理程序，以构建一个更符合物理实际的模型。这项任务将提升您在数值分析方面的技能，并让您深入了解构建稳健复合模型时的精妙之处。",
            "id": "3601178",
            "problem": "您需要通过混合恒温（Constant-Temperature）和费米气体（Fermi-Gas）区的斜率，在 Gilbert–Cameron 混合能级密度模型中实现、分析和量化微正则热容。所有数学符号、变量、函数、算符和数字都必须按照通常的物理意义进行解释。能量单位使用兆电子伏特（MeV），温度单位也使用兆电子伏特（MeV），玻尔兹曼常数设为1，因此微正则热容是无量纲的。\n\n起始点和定义：\n- 微正则熵定义为 $S(U)=\\ln \\rho(U)$，其中 $\\rho(U)$ 是作为激发能 $U$ 函数的能级密度。\n- 微正则温度定义为 $T_{\\mu}(U)=\\left(\\dfrac{dS}{dU}\\right)^{-1}$。\n- 微正则热容定义为 $C(U)=\\dfrac{dU}{dT_{\\mu}(U)}$。\n- 在恒温 (CT) 分支中，取 $S_{\\mathrm{CT}}(U)=\\dfrac{U-E_{0}}{T_{c}}+\\mathrm{const}$，其中 $T_{c}0$ 是常数，$E_{0}$ 是一个不影响导数的偏移量。\n- 在具有背移 $\\Delta$ 和能级密度参数 $a0$ 的费米气体 (FG) 分支中，使用经过充分检验的熵的前导渐近表达式，\n$$\nS_{\\mathrm{FG}}(U)=2\\sqrt{a\\,(U-\\Delta)}-\\frac{5}{4}\\ln(U-\\Delta)+\\mathrm{const}\\quad \\text{for } U\\Delta,\n$$\n该表达式给出的斜率（微正则逆温度）在 $U\\Delta$ 时是良定义的。\n\n按如下方式构建 Gilbert–Cameron (GC) 混合模型：\n- 设混合过渡（匹配）能为 $U_{x}$，且 $U_{x}\\Delta$。通过在 $U_{x}$ 以下使用 CT 斜率，在 $U_{x}$ 以上使用 FG 斜率，来分段定义未平滑的混合斜率（微正则逆温度）$\\beta_{\\mathrm{hyb}}(U)=\\dfrac{dS}{dU}$，并通过选择 $T_{c}$ 来强制斜率在 $U_{x}$ 处的连续性：\n$$\n\\beta_{\\mathrm{CT}}=\\frac{1}{T_{c}},\\quad \\beta_{\\mathrm{FG}}(U)=\\frac{dS_{\\mathrm{FG}}}{dU},\\quad \\beta_{\\mathrm{hyb}}(U)=\n\\begin{cases}\n\\beta_{\\mathrm{CT}},  U\\le U_{x},\\\\\n\\beta_{\\mathrm{FG}}(U),  UU_{x},\n\\end{cases}\n$$\n其中 $T_{c}=\\left[\\beta_{\\mathrm{FG}}(U_{x})\\right]^{-1}$，因此 $\\beta_{\\mathrm{CT}}=\\beta_{\\mathrm{FG}}(U_{x})$。\n- 平滑斜率 $\\beta_{\\mathrm{sm}}(U)$ 通过在宽度参数 $\\Delta_{U}0$ 上对斜率进行双曲正切混合来构建：\n$$\nw(U)=\\frac{1}{2}\\left[1-\\tanh\\!\\left(\\frac{U-U_{x}}{\\Delta_{U}}\\right)\\right],\\qquad\n\\beta_{\\mathrm{sm}}(U)=w(U)\\,\\beta_{\\mathrm{CT}}+\\left[1-w(U)\\right]\\beta_{\\mathrm{FG}}(U).\n$$\n\n任务：\n1) 基于上述基础，推导用 $\\beta(U)=\\dfrac{dS}{dU}$ 及其导数 $\\beta'(U)=\\dfrac{d^{2}S}{dU^{2}}$ 表示的 $T_{\\mu}(U)$ 和 $C(U)$ 的公式，并实现未平滑混合和平滑（tanh 混合）两种情况。所有能量单位必须是 $\\mathrm{MeV}$，所有温度单位也必须是 $\\mathrm{MeV}$；报告的热容为无量纲。\n2) 对于 FG 分支，从上面给出的 $S_{\\mathrm{FG}}(U)$ 出发，解析计算当 $U\\Delta$ 时的 $\\beta_{\\mathrm{FG}}(U)$ 和 $\\beta'_{\\mathrm{FG}}(U)$。使用这些结果来定义未平滑和已平滑的混合模型。对于 CT 分支，请注意 $\\beta_{\\mathrm{CT}}$ 是常数，其导数为零。\n3) 使用一个包含 $N$ 个点的均匀能量网格 $U\\in[U_{x}-W,\\,U_{x}+W]$，其中 $N$ 是一个正整数，$W0$ 根据测试用例选择，评估以下用于衡量平滑处理对不连续性消除效果的定量诊断指标：\n   - 未平滑混合导数在过渡点的跳变，\n     $$\n     J_{1}=\\left|\\beta'_{\\mathrm{hyb}}(U_{x}^{-})-\\beta'_{\\mathrm{hyb}}(U_{x}^{+})\\right|.\n     $$\n   - 相应的平滑混合在过渡点两侧的单边导数失配，通过一个小的对称偏移量 $\\varepsilon0$ 来近似，\n     $$\n     J_{2}=\\left|\\beta'_{\\mathrm{sm}}(U_{x}-\\varepsilon)-\\beta'_{\\mathrm{sm}}(U_{x}+\\varepsilon)\\right|.\n     $$\n   - 一个布尔值，指示对于未平滑混合模型，网格上是否存在任何非有限的微正则热容值（使用精确的解析导数；如果出现除以零的情况，则视为非有限）。\n   - 一个布尔值，指示对于平滑混合模型，网格上是否存在任何非有限的微正则热容值。\n   - 在网格上，平滑微正则热容的最大绝对值，仅限于有限值。\n   - 未平滑混合模型在过渡点的微正则温度连续性误差，\n     $$\n     \\Delta T=\\left|T_{\\mu}(U_{x}-\\varepsilon)-T_{\\mu}(U_{x}+\\varepsilon)\\right|.\n     $$\n   使用与 $\\Delta_{U}$ 和 $W$ 相比很小的 $\\varepsilon$。\n4) 您的实现必须在所有测试用例中使用以下固定的数值设置以确保评估的一致性：在窗口内均匀选择 $N=2001$ 个点，并设置 $\\varepsilon=10^{-6}\\,\\mathrm{MeV}$。所有计算必须以 $\\mathrm{MeV}$ 为单位进行。\n5) 对于下面的每个测试用例，按上述顺序计算并返回包含六个诊断指标的列表。将所有测试用例的结果聚合到一个单一列表中。\n\n测试套件（每个元组为 $(a,\\Delta,U_{x},\\Delta_{U},W)$，所有能量单位为 $\\mathrm{MeV}$，$a$ 的单位为 $\\mathrm{MeV}^{-1}$）：\n- 案例 A: $(12.5,\\,1.0,\\,8.0,\\,0.5,\\,3.0)$。\n- 案例 B: $(20.0,\\,1.2,\\,6.0,\\,0.4,\\,2.0)$。\n- 案例 C: $(5.0,\\,1.8,\\,3.0,\\,0.3,\\,0.9)$。\n- 案例 D: $(25.0,\\,0.8,\\,12.0,\\,0.8,\\,4.0)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是一个列表，顺序为 $[J_{1},J_{2},\\text{any\\_inf\\_unsmoothed},\\text{any\\_inf\\_smoothed},\\max|C|_{\\mathrm{smoothed}},\\Delta T]$。例如，两个测试用例的有效输出应如下所示：$[[x_{1},x_{2},b_{1},b_{2},x_{3},x_{4}],[y_{1},y_{2},b_{3},b_{4},y_{3},y_{4}]]$，其中 $x_{i},y_{i}$ 是实数，$b_{i}$ 是布尔值。",
            "solution": "该问题要求在 Gilbert-Cameron (GC) 混合能级密度模型中，实现并分析微正则热容 $C(U)$。这包括推导物理量的表达式，构建模型的未平滑版本和平滑版本，以及为给定的参数集计算一组诊断指标。\n\n**任务1：温度和热容的通用公式**\n\n微正则熵由 $S(U) = \\ln \\rho(U)$ 给出，其中 $\\rho(U)$ 是激发能为 $U$ 时的能级密度。微正则逆温度 $\\beta(U)$ 是熵的斜率：\n$$\n\\beta(U) = \\frac{dS}{dU}\n$$\n根据这个定义，可以立即得到微正则温度 $T_{\\mu}(U)$ 为：\n$$\nT_{\\mu}(U) = \\left(\\frac{dS}{dU}\\right)^{-1} = \\frac{1}{\\beta(U)}\n$$\n微正则热容定义为 $C(U) = \\frac{dU}{dT_{\\mu}(U)}$。为了用 $\\beta(U)$ 及其导数 $\\beta'(U) = \\frac{d\\beta}{dU}$ 来表示它，我们首先使用链式法则计算 $T_{\\mu}(U)$ 对 $U$ 的导数：\n$$\n\\frac{dT_{\\mu}}{dU} = \\frac{d}{dU}\\left(\\frac{1}{\\beta(U)}\\right) = -\\frac{1}{\\beta(U)^2} \\frac{d\\beta}{dU} = -\\frac{\\beta'(U)}{\\beta(U)^2}\n$$\n热容是这个量的倒数：\n$$\nC(U) = \\left(\\frac{dT_{\\mu}}{dU}\\right)^{-1} = -\\frac{\\beta(U)^2}{\\beta'(U)}\n$$\n这个基本关系允许在任何已知 $\\beta(U)$ 及其导数 $\\beta'(U)$ 的模型中计算热容。\n\n**任务2：费米气体（FG）模型的解析导数**\n\n当 $U  \\Delta$ 时，费米气体（FG）的熵由下式给出：\n$$\nS_{\\mathrm{FG}}(U) = 2\\sqrt{a(U-\\Delta)} - \\frac{5}{4}\\ln(U-\\Delta) + \\mathrm{const}\n$$\n其中 $a  0$ 是能级密度参数，$\\Delta$ 是背移。\n\n一阶导数 $\\beta_{\\mathrm{FG}}(U) = \\frac{dS_{\\mathrm{FG}}}{dU}$ 通过对 $U$ 求导得到：\n$$\n\\beta_{\\mathrm{FG}}(U) = \\frac{d}{dU} \\left[ 2\\sqrt{a}(U-\\Delta)^{1/2} - \\frac{5}{4}\\ln(U-\\Delta) \\right]\n$$\n$$\n\\beta_{\\mathrm{FG}}(U) = 2\\sqrt{a} \\cdot \\frac{1}{2}(U-\\Delta)^{-1/2} - \\frac{5}{4}(U-\\Delta)^{-1} = \\sqrt{\\frac{a}{U-\\Delta}} - \\frac{5}{4(U-\\Delta)}\n$$\n二阶导数 $\\beta'_{\\mathrm{FG}}(U) = \\frac{d\\beta_{\\mathrm{FG}}}{dU}$ 通过对 $\\beta_{\\mathrm{FG}}(U)$ 求导得到：\n$$\n\\beta'_{\\mathrm{FG}}(U) = \\frac{d}{dU} \\left[ \\sqrt{a}(U-\\Delta)^{-1/2} - \\frac{5}{4}(U-\\Delta)^{-1} \\right]\n$$\n$$\n\\beta'_{\\mathrm{FG}}(U) = \\sqrt{a} \\left(-\\frac{1}{2}\\right)(U-\\Delta)^{-3/2} - \\frac{5}{4}(-1)(U-\\Delta)^{-2} = -\\frac{\\sqrt{a}}{2(U-\\Delta)^{3/2}} + \\frac{5}{4(U-\\Delta)^2}\n$$\n对于恒温 (CT) 分支，熵为 $S_{\\mathrm{CT}}(U) = \\frac{U-E_0}{T_c} + \\mathrm{const}$。逆温度是常数，$\\beta_{\\mathrm{CT}} = \\frac{1}{T_c}$，其导数为零，$\\beta'_{\\mathrm{CT}} = 0$。\n\n**混合模型构建**\n\n该问题基于这些组件指定了两种混合模型。\n\n*   **未平滑混合模型：** 逆温度 $\\beta_{\\mathrm{hyb}}(U)$ 是分段定义的。对于 $U \\le U_x$，它使用 CT 形式；对于 $U  U_x$，它使用 FG 形式。通过设置 $\\beta_{\\mathrm{CT}} = \\beta_{\\mathrm{FG}}(U_x)$ 来强制 $\\beta(U)$ 在匹配能量 $U_x$ 处的连续性。因此，其导数 $\\beta'_{\\mathrm{hyb}}(U)$ 是不连续的：\n    $$\n    \\beta'_{\\mathrm{hyb}}(U) = \\begin{cases} \\beta'_{\\mathrm{CT}} = 0,  U  U_{x} \\\\ \\beta'_{\\mathrm{FG}}(U),  U  U_{x} \\end{cases}\n    $$\n    在 $U=U_x$ 处，由于跳变，导数未定义。\n\n*   **平滑混合模型：** 为了消除导数的不连续性，引入了双曲正切平滑。平滑的逆温度 $\\beta_{\\mathrm{sm}}(U)$ 是 CT 和 FG 斜率的加权平均：\n    $$\n    \\beta_{\\mathrm{sm}}(U) = w(U)\\beta_{\\mathrm{CT}} + [1-w(U)]\\beta_{\\mathrm{FG}}(U)\n    $$\n    其中权重函数为 $w(U) = \\frac{1}{2}\\left[1-\\tanh\\left(\\frac{U-U_x}{\\Delta_U}\\right)\\right]$。其导数为 $w'(U) = -\\frac{1}{2\\Delta_U}\\text{sech}^2\\left(\\frac{U-U_x}{\\Delta_U}\\right)$。\n    使用乘法法则，导数 $\\beta'_{\\mathrm{sm}}(U)$ 为：\n    $$\n    \\beta'_{\\mathrm{sm}}(U) = \\frac{d}{dU}\\left(w(U)\\beta_{\\mathrm{CT}} + [1-w(U)]\\beta_{\\mathrm{FG}}(U)\\right)\n    $$\n    $$\n    \\beta'_{\\mathrm{sm}}(U) = w'(U)\\beta_{\\mathrm{CT}} - w'(U)\\beta_{\\mathrm{FG}}(U) + [1-w(U)]\\beta'_{\\mathrm{FG}}(U)\n    $$\n    $$\n    \\beta'_{\\mathrm{sm}}(U) = w'(U)[\\beta_{\\mathrm{CT}} - \\beta_{\\mathrm{FG}}(U)] + [1-w(U)]\\beta'_{\\mathrm{FG}}(U)\n    $$\n    只要 $U  \\Delta$，该表达式在任何地方都是连续且良定义的。\n\n**任务3-5：诊断指标计算**\n\n对于每个测试用例 $(a, \\Delta, U_x, \\Delta_U, W)$，在具有 $N=2001$ 个点、使用 $\\varepsilon=10^{-6}\\,\\mathrm{MeV}$ 的均匀能量网格 $U \\in [U_x - W, U_x + W]$ 上计算以下六个诊断指标。\n\n1.  **$J_1$：未平滑导数跳变：** 这衡量了 $\\beta'_{\\mathrm{hyb}}(U)$ 在 $U_x$ 处不连续性的幅度。\n    $$\n    J_1 = |\\beta'_{\\mathrm{hyb}}(U_x^{-}) - \\beta'_{\\mathrm{hyb}}(U_x^{+})| = |0 - \\beta'_{\\mathrm{FG}}(U_x)| = |\\beta'_{\\mathrm{FG}}(U_x)|\n    $$\n    我们使用 $\\beta'_{\\mathrm{FG}}(U)$ 的解析公式来计算它。\n\n2.  **$J_2$：平滑导数失配：** 这近似了平滑导数在 $U_x$ 两侧变化的剧烈程度。\n    $$\n    J_2 = |\\beta'_{\\mathrm{sm}}(U_x - \\varepsilon) - \\beta'_{\\mathrm{sm}}(U_x + \\varepsilon)|\n    $$\n    我们使用在两个指定点上求值的 $\\beta'_{\\mathrm{sm}}(U)$ 的解析公式来计算它。\n\n3.  **未平滑混合模型中的非有限 $C(U)$：** 未平滑热容为 $C_{\\mathrm{hyb}}(U) = -\\beta_{\\mathrm{hyb}}(U)^2 / \\beta'_{\\mathrm{hyb}}(U)$。对于整个 CT 分支（$U \\le U_x$），$\\beta'_{\\mathrm{hyb}}(U) = 0$。由于能量网格包含该区域，将会发生除以零的错误。因此，该诊断指标将始终为 `True`。\n\n4.  **平滑混合模型中的非有限 $C(U)$：** 平滑热容为 $C_{\\mathrm{sm}}(U) = -\\beta_{\\mathrm{sm}}(U)^2 / \\beta'_{\\mathrm{sm}}(U)$。如果在网格上的任何点 $\\beta'_{\\mathrm{sm}}(U)$ 变为零，则会出现非有限值。通过在整个网格上计算 $C_{\\mathrm{sm}}(U)$ 并检查是否存在 `inf` 或 `nan` 值来进行数值检查。\n\n5.  **最大绝对平滑热容：** 这是在所有 $C_{\\mathrm{sm}}(U)$ 为有限值的网格点上计算的 $\\max|C_{\\mathrm{sm}}(U)|$。\n\n6.  **$\\Delta T$：温度连续性误差：** 这衡量了未平滑模型在 $U_x$ 两侧一个小区间 $2\\varepsilon$ 上的温度变化。\n    $$\n    \\Delta T = |T_{\\mu}(U_x - \\varepsilon) - T_{\\mu}(U_x + \\varepsilon)|\n    $$\n    对于未平滑混合模型，$T_{\\mu}(U_x - \\varepsilon) = 1/\\beta_{\\mathrm{hyb}}(U_x - \\varepsilon) = 1/\\beta_{\\mathrm{CT}}$ 且 $T_{\\mu}(U_x + \\varepsilon) = 1/\\beta_{\\mathrm{hyb}}(U_x + \\varepsilon) = 1/\\beta_{\\mathrm{FG}}(U_x+\\varepsilon)$。由于 $\\beta_{\\mathrm{CT}} = \\beta_{\\mathrm{FG}}(U_x)$，这变为：\n    $$\n    \\Delta T = \\left|\\frac{1}{\\beta_{\\mathrm{FG}}(U_x)} - \\frac{1}{\\beta_{\\mathrm{FG}}(U_x+\\varepsilon)}\\right|\n    $$\n    该值直接使用 $\\beta_{\\mathrm{FG}}(U)$ 的公式计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes the microcanonical heat capacity in the\n    Gilbert-Cameron hybrid level-density model.\n    \"\"\"\n\n    # Helper functions for Fermi-Gas (FG) model quantities\n    def beta_fg(U, a, delta):\n        \"\"\"Calculates beta_FG(U) = dS_FG/dU.\"\"\"\n        term = U - delta\n        # Ensure term  0 for physical validity\n        safe_term = np.where(term > 0, term, np.nan)\n        return np.sqrt(a / safe_term) - (5.0 / 4.0) / safe_term\n\n    def beta_prime_fg(U, a, delta):\n        \"\"\"Calculates beta'_FG(U) = d^2S_FG/dU^2.\"\"\"\n        term = U - delta\n        # Ensure term  0 for physical validity\n        safe_term = np.where(term > 0, term, np.nan)\n        return -0.5 * np.sqrt(a) * safe_term**(-1.5) + (5.0 / 4.0) * safe_term**(-2.0)\n\n    # Helper functions for the smoothed model\n    def w_func(U, Ux, delta_U):\n        \"\"\"Calculates the smoothing weight function w(U).\"\"\"\n        return 0.5 * (1.0 - np.tanh((U - Ux) / delta_U))\n\n    def w_prime_func(U, Ux, delta_U):\n        \"\"\"Calculates the derivative of the weight function w'(U).\"\"\"\n        arg = (U - Ux) / delta_U\n        return -0.5 / delta_U * (1.0 / np.cosh(arg))**2\n\n    def beta_sm(U, Ux, delta_U, a, delta, beta_ct):\n        \"\"\"Calculates the smoothed inverse temperature beta_sm(U).\"\"\"\n        w = w_func(U, Ux, delta_U)\n        b_fg = beta_fg(U, a, delta)\n        return w * beta_ct + (1.0 - w) * b_fg\n\n    def beta_prime_sm(U, Ux, delta_U, a, delta, beta_ct):\n        \"\"\"Calculates the derivative of the smoothed inverse temperature beta'_sm(U).\"\"\"\n        w = w_func(U, Ux, delta_U)\n        w_p = w_prime_func(U, Ux, delta_U)\n        b_fg = beta_fg(U, a, delta)\n        b_p_fg = beta_prime_fg(U, a, delta)\n        return w_p * (beta_ct - b_fg) + (1.0 - w) * b_p_fg\n\n    # Fixed numerical settings\n    N = 2001\n    epsilon = 1.0e-6\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, delta, Ux, delta_U, W)\n        (12.5, 1.0, 8.0, 0.5, 3.0),  # Case A\n        (20.0, 1.2, 6.0, 0.4, 2.0),  # Case B\n        (5.0, 1.8, 3.0, 0.3, 0.9),   # Case C\n        (25.0, 0.8, 12.0, 0.8, 4.0), # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        a, delta, Ux, delta_U, W = case\n\n        # --- Diagnostic 1: J1 (Unsmoothed derivative jump) ---\n        # J1 = |beta'_hyb(Ux-) - beta'_hyb(Ux+)| = |0 - beta'_fg(Ux)|\n        beta_p_fg_at_Ux = beta_prime_fg(Ux, a, delta)\n        J1 = np.abs(beta_p_fg_at_Ux)\n\n        # --- Diagnostic 2: J2 (Smoothed derivative mismatch) ---\n        # J2 = |beta'_sm(Ux - eps) - beta'_sm(Ux + eps)|\n        beta_ct = beta_fg(Ux, a, delta)\n        beta_p_sm_minus = beta_prime_sm(Ux - epsilon, Ux, delta_U, a, delta, beta_ct)\n        beta_p_sm_plus = beta_prime_sm(Ux + epsilon, Ux, delta_U, a, delta, beta_ct)\n        J2 = np.abs(beta_p_sm_minus - beta_p_sm_plus)\n\n        # --- Diagnostic 3: any_inf_unsmoothed ---\n        # C_unsmoothed = -beta_hyb^2 / beta'_hyb. For U = Ux, beta'_hyb is 0.\n        # The grid always contains points = Ux, causing division by zero.\n        any_inf_unsmoothed = True\n\n        # --- Diagnostics 4  5: Smoothed heat capacity analysis ---\n        U_grid = np.linspace(Ux - W, Ux + W, N)\n        \n        # Calculate smoothed beta and its derivative on the grid\n        b_sm_grid = beta_sm(U_grid, Ux, delta_U, a, delta, beta_ct)\n        b_p_sm_grid = beta_prime_sm(U_grid, Ux, delta_U, a, delta, beta_ct)\n        \n        # Calculate smoothed heat capacity, ignoring division by zero warnings\n        with np.errstate(divide='ignore', invalid='ignore'):\n            C_sm_grid = -np.square(b_sm_grid) / b_p_sm_grid\n            \n        # Diagnostic 4: any_inf_smoothed\n        any_inf_smoothed = not np.all(np.isfinite(C_sm_grid))\n        \n        # Diagnostic 5: max|C|_smoothed\n        finite_C_sm = C_sm_grid[np.isfinite(C_sm_grid)]\n        if finite_C_sm.size > 0:\n            max_abs_C_smoothed = np.max(np.abs(finite_C_sm))\n        else:\n            max_abs_C_smoothed = 0.0\n\n        # --- Diagnostic 6: Delta T (Temperature continuity error) ---\n        # Delta T = |T_mu(Ux - eps) - T_mu(Ux + eps)| for unsmoothed hybrid\n        # T_mu(U) = 1/beta_hyb(U). T_mu(Ux - eps) = 1/beta_ct\n        T_mu_minus = 1.0 / beta_ct \n        # T_mu(Ux + eps) = 1/beta_fg(Ux + eps)\n        T_mu_plus = 1.0 / beta_fg(Ux + epsilon, a, delta)\n        delta_T = np.abs(T_mu_minus - T_mu_plus)\n        \n        # Assemble results for the current test case\n        case_results = [J1, J2, any_inf_unsmoothed, any_inf_smoothed, max_abs_C_smoothed, delta_T]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The default string representation of lists in Python matches the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}