{
    "hands_on_practices": [
        {
            "introduction": "在模拟核碰撞时，一个至关重要的首要步骤是精确设置核的初始状态。这个练习将演示如何运用经典力学原理，如能量和角动量守恒，来确定实现特定碰撞几何（由最近距离定义）所需的精确初始位置和速度。掌握这项技能对于控制和解读模拟结果至关重要 。",
            "id": "3577473",
            "problem": "在重离子碰撞的含时哈特里-福克（TDHF）模拟中，标准的做法是使用经典运动学来初始化两个分离良好的原子核，使得在发生任何核重叠之前，它们在纯库仑相互作用下的经典最近距离等于一个预设值。考虑两个电荷分别为 $Z_{1}$ 和 $Z_{2}$、质量分别为 $m_{1}$ 和 $m_{2}$ 的原子核，在排斥性库仑势 $V(r)=\\frac{Z_{1}Z_{2}e^{2}}{4\\pi\\varepsilon_{0}r}$ 的作用下，在 $x$–$y$ 平面内做非相对论性运动。设方形笛卡尔网格的边长为 $L$ 且具有硬边界。为避免边界伪影，施加一个等于目标最近距离的保守填充，即要求在 $t=0$ 时，每个原子核中心距离每个边界至少为 $R_{\\min}$，并且初始碰撞参数 $b$ 满足 $0\\leq b  R_{\\min}$。",
            "solution": "对问题陈述的严格验证如下：\n\n- **科学依据**：该问题基于带库仑势的经典二体问题，这是物理学中一个基础且成熟的概念。它正确地运用了中心势中的能量守恒和角动量守恒原理，并使用了质心和约化质量的标准定义。将此计算应用于初始化含时哈特里-福克（TDHF）模拟是其在计算核物理中的一个现实且标准的应用。\n- **适定性**：该问题提供了一套充分的约束条件（初始质心位置、初始相对方位和速度方向、边界填充以及预设的最近距离），足以唯一确定八个未知的标量（两个粒子的初始位置和速度分量）。目标陈述清晰。\n- **客观性**：该问题使用精确、无歧义的科学和数学语言表述，不含任何主观或推测性内容。\n- **完备性与一致性**：所提供的信息是自洽的，且各约束条件相互一致。“轨迹近似平行于 $x$ 轴”这一条件被更精确的“初始相对运动沿 $x$ 方向”的条件所明确，后者是可形式化的。使用“允许的最大初始 $x$ 方向分离距离”的指令为最终确定初始位置提供了明确的标准。\n\n该问题被认为是有效的，因为它科学上合理、适定、客观，并且其约束条件一致且足以得到唯一解。\n\n解答的构建首先通过在质心（CM）参考系中分析该系统，这将二体问题简化为关于相对坐标的等效单体问题。\n\n设 $\\vec{r}_1$ 和 $\\vec{r}_2$ 是质量分别为 $m_1$ 和 $m_2$ 的两个原子核的位置矢量。总质量为 $M = m_1 + m_2$。质心位置矢量为 $\\vec{R}_{CM} = \\frac{m_1\\vec{r}_1 + m_2\\vec{r}_2}{M}$，相对位置矢量为 $\\vec{r} = \\vec{r}_1 - \\vec{r}_2$。各个原子核的位置可以表示为：\n$$ \\vec{r}_1 = \\vec{R}_{CM} + \\frac{m_2}{M}\\vec{r} $$\n$$ \\vec{r}_2 = \\vec{R}_{CM} - \\frac{m_1}{M}\\vec{r} $$\n类似地，对于速度 $\\vec{v}_1$、$\\vec{v}_2$、$\\vec{V}_{CM}$ 和 $\\vec{v} = \\vec{v}_1 - \\vec{v}_2$：\n$$ \\vec{v}_1 = \\vec{V}_{CM} + \\frac{m_2}{M}\\vec{v} $$\n$$ \\vec{v}_2 = \\vec{V}_{CM} - \\frac{m_1}{M}\\vec{v} $$\n\n问题规定在 $t=0$ 时质心位于原点，因此 $\\vec{R}_{CM}^{(0)} = \\vec{0}$。由于我们在质心参考系中，质心速度也为零，$\\vec{V}_{CM} = \\vec{0}$。问题指出，初始相对运动沿 $x$ 轴，横向分离距离为 $b$。我们可以如下设置初始相对位置和速度矢量。设沿 $x$ 轴的初始分离距离为 $d_0$。为得到入射轨迹，我们可以将粒子1置于 $x0$ 处，粒子2置于 $x>0$ 处。它们的相对 $x$ 坐标为负。我们将初始相对位置定义为 $\\vec{r}^{(0)} = (-d_0, b)$。初始相对速度纯粹沿 $x$ 轴方向，$\\vec{v}^{(0)} = (v_0, 0)$，其中 $v_0>0$ 是初始相对速率。\n\n相对坐标 $\\vec{r}$ 的运动等效于一个质量为约化质量 $\\mu = \\frac{m_1 m_2}{M}$ 的粒子在中心势 $V(r) = \\frac{C}{r}$ 中的运动，其中 $r = |\\vec{r}|$ 且 $C = \\frac{Z_1 Z_2 e^2}{4\\pi\\varepsilon_0}$。相对运动的总能量 $E$ 和角动量大小 $L_{rel}$ 是守恒的。\n\n在 $t=0$ 时：\n初始相对距离为 $r^{(0)} = |\\vec{r}^{(0)}| = \\sqrt{d_0^2 + b^2}$。\n初始相对速率为 $v^{(0)} = |\\vec{v}^{(0)}| = v_0$。\n初始能量为：\n$$ E = \\frac{1}{2}\\mu (v_0)^2 + V(r^{(0)}) = \\frac{1}{2}\\mu v_0^2 + \\frac{C}{\\sqrt{d_0^2 + b^2}} $$\n初始相对角动量的大小为：\n$$ L_{rel} = |\\mu (\\vec{r}^{(0)} \\times \\vec{v}^{(0)})| = \\left|\\mu \\det\\begin{pmatrix} \\hat{i}  \\hat{j} \\\\ -d_0  b \\end{pmatrix} \\det \\begin{pmatrix} v_0 \\\\ 0 \\end{pmatrix}\\right| = \\mu b v_0 $$\n（我们假设 $b \\ge 0$ 且 $v_0>0$）。\n\n在最近点处，相对距离为 $r=R_{\\min}$，且相对速度的径向分量为零。此点的能量守恒给出：\n$$ E = \\frac{L_{rel}^2}{2\\mu R_{\\min}^2} + \\frac{C}{R_{\\min}} $$\n代入 $E$ 和 $L_{rel}$ 的表达式：\n$$ \\frac{1}{2}\\mu v_0^2 + \\frac{C}{\\sqrt{d_0^2 + b^2}} = \\frac{(\\mu b v_0)^2}{2\\mu R_{\\min}^2} + \\frac{C}{R_{\\min}} $$\n$$ \\frac{1}{2}\\mu v_0^2 \\left(1 - \\frac{b^2}{R_{\\min}^2}\\right) = C\\left(\\frac{1}{R_{\\min}} - \\frac{1}{\\sqrt{d_0^2 + b^2}}\\right) $$\n解出 $v_0^2$：\n$$ v_0^2 = \\frac{2C}{\\mu} \\frac{R_{\\min}^2}{R_{\\min}^2 - b^2} \\left(\\frac{\\sqrt{d_0^2 + b^2} - R_{\\min}}{R_{\\min}\\sqrt{d_0^2 + b^2}}\\right) = \\frac{2C}{\\mu} \\frac{R_{\\min}}{R_{\\min}^2 - b^2} \\left(1 - \\frac{R_{\\min}}{\\sqrt{d_0^2 + b^2}}\\right) $$\n为使 $v_0$ 为实数，必须有 $1 - \\frac{R_{\\min}}{\\sqrt{d_0^2 + b^2}} \\ge 0$，这意味着辅助条件 $d_0^2 + b^2 \\ge R_{\\min}^2$。\n\n接下来，我们根据边界条件确定 $d_0$。原子核中心必须距离边长为 $L$ 的方形网格的边界至少为 $R_{\\min}$。质心位于原点，则边界在 $x=\\pm L/2$ 和 $y=\\pm L/2$。\n初始位置为：\n$x_1^{(0)} = \\frac{m_2}{M}x^{(0)} = -\\frac{m_2}{M}d_0$, $y_1^{(0)} = \\frac{m_2}{M}y^{(0)} = \\frac{m_2}{M}b$。\n$x_2^{(0)} = -\\frac{m_1}{M}x^{(0)} = \\frac{m_1}{M}d_0$, $y_2^{(0)} = -\\frac{m_1}{M}y^{(0)} = -\\frac{m_1}{M}b$。\n\n填充约束为：\n$|x_1^{(0)}| \\le L/2 - R_{\\min} \\implies \\frac{m_2}{M}d_0 \\le L/2 - R_{\\min} \\implies d_0 \\le \\frac{M}{m_2}(L/2 - R_{\\min})$。\n$|x_2^{(0)}| \\le L/2 - R_{\\min} \\implies \\frac{m_1}{M}d_0 \\le L/2 - R_{\\min} \\implies d_0 \\le \\frac{M}{m_1}(L/2 - R_{\\min})$。\n$|y_1^{(0)}| \\le L/2 - R_{\\min} \\implies \\frac{m_2}{M}b \\le L/2 - R_{\\min}$。\n$|y_2^{(0)}| \\le L/2 - R_{\\min} \\implies \\frac{m_1}{M}b \\le L/2 - R_{\\min}$。\n这些 y-约束可以合并为 $b \\le \\frac{M}{\\max(m_1,m_2)}(L/2-R_{\\min})$。\n\n为了同时满足对 $d_0$ 的两个约束，我们必须有 $d_0 \\le \\min\\left(\\frac{M}{m_1}(L/2 - R_{\\min}), \\frac{M}{m_2}(L/2 - R_{\\min})\\right)$。这可以简化为 $d_0 \\le \\frac{M}{\\max(m_1, m_2)}(L/2 - R_{\\min})$。\n问题要求允许的最大初始 $x$ 方向分离距离，因此我们取等号：\n$$ d_0 = \\frac{m_1+m_2}{\\max(m_1, m_2)}\\left(\\frac{L}{2} - R_{\\min}\\right) $$\n为使设置有效，必须满足几个不等式：$0 \\le b  R_{\\min}  L/2$，以及推导出的条件 $b \\le \\frac{m_1+m_2}{\\max(m_1,m_2)}\\left(\\frac{L}{2}-R_{\\min}\\right)$ 和 $(d_0)^2+b^2  (R_{\\min})^2$。\n\n各个粒子的初始速度为：\n$\\vec{v}_1^{(0)} = \\frac{m_2}{M}\\vec{v}^{(0)} = (\\frac{m_2}{M}v_0, 0)$。\n$\\vec{v}_2^{(0)} = -\\frac{m_1}{M}\\vec{v}^{(0)} = (-\\frac{m_1}{M}v_0, 0)$。\n\n现在我们可以组装最终的8分量矢量。让我们将 $v_{mag}$ 定义为初始相对速度的大小。\n$$ v_{mag} = \\sqrt{\\frac{2 Z_1 Z_2 e^2 (m_1+m_2)}{4\\pi\\varepsilon_0 m_1 m_2} \\frac{R_{\\min}}{R_{\\min}^2 - b^2} \\left(1 - \\frac{R_{\\min}}{\\sqrt{\\left(\\frac{m_1+m_2}{\\max(m_1, m_2)}\\left(\\frac{L}{2} - R_{\\min}\\right)\\right)^2 + b^2}}\\right)} $$\n初始状态矢量的分量是：\n- $x_1^{(0)} = -\\frac{m_2}{m_1+m_2} d_0 = -\\frac{m_2}{\\max(m_1, m_2)}\\left(\\frac{L}{2} - R_{\\min}\\right)$\n- $y_1^{(0)} = \\frac{m_2}{m_1+m_2}b$\n- $v_{1x}^{(0)} = \\frac{m_2}{m_1+m_2}v_{mag}$\n- $v_{1y}^{(0)} = 0$\n- $x_2^{(0)} = \\frac{m_1}{m_1+m_2} d_0 = \\frac{m_1}{\\max(m_1, m_2)}\\left(\\frac{L}{2} - R_{\\min}\\right)$\n- $y_2^{(0)} = -\\frac{m_1}{m_1+m_2}b$\n- $v_{2x}^{(0)} = -\\frac{m_1}{m_1+m_2}v_{mag}$\n- $v_{2y}^{(0)} = 0$\n\n让我们将这些组合成最终的矩阵形式。为了使最终矩阵简洁，我们定义一个辅助速度大小 $v_0$：\n$$ v_0 = \\sqrt{\\frac{Z_1 Z_2 e^2 (m_1+m_2)}{2\\pi\\varepsilon_0 m_1 m_2} \\frac{R_{\\min}}{R_{\\min}^2 - b^2} \\left(1 - \\frac{R_{\\min}}{\\sqrt{\\left(\\frac{m_1+m_2}{\\max(m_1, m_2)}\\left(\\frac{L}{2} - R_{\\min}\\right)\\right)^2 + b^2}}\\right)} $$\n然后用这个项来表示各分量。\n\n$x_1^{(0)} = -\\frac{m_2}{\\max(m_1, m_2)}\\left(\\frac{L}{2} - R_{\\min}\\right)$\n$y_1^{(0)} = \\frac{m_2}{m_1+m_2}b$\n$v_{1x}^{(0)} = \\frac{m_2}{m_1+m_2}v_0$\n$v_{1y}^{(0)} = 0$\n$x_2^{(0)} = \\frac{m_1}{\\max(m_1, m_2)}\\left(\\frac{L}{2} - R_{\\min}\\right)$\n$y_2^{(0)} = -\\frac{m_1}{m_1+m_2}b$\n$v_{2x}^{(0)} = -\\frac{m_1}{m_1+m_2}v_0$\n$v_{2y}^{(0)} = 0$\n\n这些表达式构成了完整的解答。它们将按要求格式化为单行矩阵。",
            "answer": "$$ \\boxed{\\begin{pmatrix} -\\frac{m_2}{\\max(m_1, m_2)}\\left(\\frac{L}{2} - R_{\\min}\\right)  \\frac{m_2 b}{m_1+m_2}  \\frac{m_2}{m_1+m_2} V  0  \\frac{m_1}{\\max(m_1, m_2)}\\left(\\frac{L}{2} - R_{\\min}\\right)  -\\frac{m_1 b}{m_1+m_2}  -\\frac{m_1}{m_1+m_2} V  0 \\end{pmatrix}} $$\n其中 $V$ 由下式给出\n$$ V = \\sqrt{\\frac{Z_1 Z_2 e^2 (m_1+m_2)}{2\\pi\\varepsilon_0 m_1 m_2} \\frac{R_{\\min}}{R_{\\min}^2 - b^2} \\left(1 - \\frac{R_{\\min}}{\\sqrt{\\left(\\frac{m_1+m_2}{\\max(m_1, m_2)}\\left(\\frac{L}{2} - R_{\\min}\\right)\\right)^2 + b^2}}\\right)} $$"
        },
        {
            "introduction": "在模拟开始运行后，我们必须验证其物理正确性。本练习将指导您实现一个一维量子动力学模拟，并验证其是否遵循埃伦费斯特定理（Ehrenfest's theorem），该定理将期望值的量子演化与经典运动方程联系起来。这是对任何量子模拟代码的基本检验 。",
            "id": "3577445",
            "problem": "你的任务是设计并实现一个单占据轨道在一维空间中的数值传播。该计算采用含时Hartree-Fock (TDHF) 近似，并特化到单粒子极限，此时动力学在一个静态、局域的平均场势中简化为含时薛定谔方程。你的目标是在传播过程中，对经过伽利略变换的情况，数值验证埃伦费斯特关系（Ehrenfest relations）：\n1) $\\frac{d}{dt}\\langle \\hat{x} \\rangle = \\left\\langle \\frac{\\hat{p}}{m} \\right\\rangle$,\n2) $\\frac{d}{dt}\\langle \\hat{p} \\rangle = \\langle -\\partial_x U(x) \\rangle$,\n你需要对三种代表性的平均场势进行验证。\n\n理论基础：\n- 在给定的平均场中，单轨道的含时Hartree-Fock (TDHF) 方程简化为含时薛定谔方程：\n$$\ni \\hbar \\frac{\\partial}{\\partial t}\\psi(x,t) = \\left[-\\frac{\\hbar^2}{2m}\\partial_x^2 + U(x)\\right]\\psi(x,t),\n$$\n其中 $\\psi$ 归一化为1。计算在无量纲单位下进行，$\\hbar=1$，因此所有量均为无量纲，你的最终答案也必须是无量纲浮点数。\n- 对任意算符 $\\hat{A}$，其期望值定义为 $\\langle \\hat{A} \\rangle(t)=\\int \\psi^*(x,t) \\hat{A} \\psi(x,t)\\,dx$。\n- 动量为 $p_0$ 的伽利略变换通过一个相位因子 $\\exp(i p_0 x)$ 乘以空间波包来实现，作用于初始态上。\n\n算法要求：\n- 使用一个与哈密顿量时间演化一致的保范二阶时间积分器（例如，通过快速傅里叶变换（FFT）实现的动能和势能部分的对称Trotter分裂）。动能算符为 $\\hat{T}=\\hat{p}^2/(2m)$，其中 $\\hat{p}=-i\\partial_x$，势能算符为 $\\hat{V}=U(x)$。\n- 在长度为 $L$、由 $N$ 个格点离散化的空间区间上，使用由FFT所隐含的周期性边界条件。选择的 $L$ 和模拟时间要足够短，以确保在每次运行中波包始终保持在区域内部。\n- 为避免有限差分色散，计算动量期望值所需的波函数空间导数可以通过谱方法计算，使用从FFT频率格点获得的波数格点 $k$。在这些单位中，$\\hat{p}=-i\\partial_x$。\n- 在传播过程中计算以下时间序列：$\\langle x \\rangle(t)$、$\\langle p \\rangle(t)$ 和 $\\langle -\\partial_x U \\rangle(t)$。时间导数采用二阶精度的有限差分进行近似：内部点使用中心差分，端点使用二阶单边格式。\n\n经过变换的初始态：\n- 使用一个归一化的高斯波包，\n$$\n\\psi(x,0) = \\left(\\frac{1}{\\pi \\sigma^2}\\right)^{1/4} \\exp\\left(-\\frac{(x-x_0)^2}{2\\sigma^2}\\right)\\,\\exp(i p_0 x).\n$$\n\n待测试的势：\n- 自由粒子：$U(x)=0$，因此 $\\partial_x U(x)=0$。\n- 谐振子：$U(x)=\\tfrac{1}{2} m \\omega^2 x^2$，因此 $\\partial_x U(x)= m\\omega^2 x$。\n- 高斯势阱：$U(x)=-U_0 \\exp\\left(-\\frac{x^2}{2a^2}\\right)$，因此 $\\partial_x U(x)= U_0 \\frac{x}{a^2} \\exp\\left(-\\frac{x^2}{2a^2}\\right)$。\n\n数值验证：\n- 对每个测试案例，模拟时间演化，并评估在整个模拟时间窗口内以下两项的最大绝对偏差：\n(a) $\\left|\\frac{d}{dt}\\langle x \\rangle - \\frac{\\langle p \\rangle}{m}\\right|$，\n(b) $\\left|\\frac{d}{dt}\\langle p \\rangle - \\langle -\\partial_x U \\rangle\\right|$。\n- 针对每个测试案例，以无量纲浮点数的形式报告这两个最大偏差。\n\n测试套件：\n使用以下三个测试案例。所有量均为无量纲。对于每个案例，在 $[-L/2,L/2)$ 上用 $N$ 个点均匀离散化空间，时间步长为 $\\Delta t$，共 $N_t$ 步。使用FFT频率格点定义波数 $k$ 和谱动能相位。在所有案例中，设置 $m=1$。\n1) 经过变换的自由粒子：\n- $U(x)=0$,\n- $L=200$, $N=1024$,\n- $\\Delta t=0.02$, $N_t=400$,\n- $\\sigma=2.0$, $x_0=-30.0$, $p_0=2.0$.\n2) 经过变换的谐振子：\n- $U(x)=\\tfrac{1}{2} \\omega^2 x^2$，其中 $\\omega=0.15$,\n- $L=200$, $N=1024$,\n- $\\Delta t=0.02$, $N_t=600$,\n- $\\sigma=1/\\sqrt{\\omega}$, $x_0=15.0$, $p_0=1.0$.\n3) 经过变换的高斯势阱：\n- $U(x)=-U_0 \\exp\\left(-\\frac{x^2}{2a^2}\\right)$，其中 $U_0=6.0$, $a=3.0$,\n- $L=200$, $N=1024$,\n- $\\Delta t=0.01$, $N_t=800$,\n- $\\sigma=2.0$, $x_0=-20.0$, $p_0=2.0$.\n\n要求的最终输出格式：\n- 你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应于上述顺序的一个测试案例，其本身是一个包含两个最大偏差值的双元素列表：\n$$\n\\big[\\,[e_{x,1},e_{p,1}],[e_{x,2},e_{p,2}],[e_{x,3},e_{p,3}]\\,\\big].\n$$\n- 所有输出均为无量纲浮点数。打印的行不得包含空格（例如：\"[[0.00012,0.00034],[...],[...]]\"）。",
            "solution": "用户提供了一个在计算量子力学领域中有效且适定的问题。任务是数值求解单粒子的一维含时薛定谔方程，并验证埃伦费斯特关系（Ehrenfest relations）。\n\n解决方案分三个阶段进行：建立理论和数值框架，为每个指定案例实现模拟，最后量化与精确埃伦费斯特关系的偏差。所有数学表达式均按要求以 LaTeX 格式呈现。\n\n### 1. 理论框架\n\n控制系统的基本方程是单粒子波函数 $\\psi(x,t)$ 在静态势 $U(x)$ 中的含时薛定谔方程（TDSE）。在约化普朗克常数 $\\hbar=1$ 的无量纲单位下，该方程为：\n$$\ni \\frac{\\partial}{\\partial t}\\psi(x,t) = \\hat{H}\\psi(x,t) = \\left[-\\frac{1}{2m}\\frac{\\partial^2}{\\partial x^2} + U(x)\\right]\\psi(x,t)\n$$\n这里，$\\hat{H}$ 是哈密顿算符，由动能算符 $\\hat{T} = -\\frac{1}{2m}\\frac{\\partial^2}{\\partial x^2}$ 和势能算符 $\\hat{V} = U(x)$ 组成。波函数是归一化的，满足 $\\int |\\psi(x,t)|^2 dx = 1$。\n\nEhrenfest 定理将量子力学期望值与经典力学联系起来。对于质量为 $m$ 的粒子，待验证的两个关系是：\n1.  位置期望值 $\\langle \\hat{x} \\rangle$ 的时间演化：\n    $$ \\frac{d}{dt}\\langle \\hat{x} \\rangle = \\frac{\\langle \\hat{p} \\rangle}{m} $$\n2.  动量期望值 $\\langle \\hat{p} \\rangle$ 的时间演化：\n    $$ \\frac{d}{dt}\\langle \\hat{p} \\rangle = \\langle -\\frac{\\partial U}{\\partial x} \\rangle $$\n其中 $\\hat{x}=x$ 是位置算符，$\\hat{p}=-i\\frac{\\partial}{\\partial x}$ 是动量算符（在 $\\hbar=1$ 的单位下）。算符 $\\hat{A}$ 的期望值由 $\\langle \\hat{A} \\rangle(t) = \\int \\psi^*(x,t) \\hat{A} \\psi(x,t) dx$ 给出。\n\n### 2. 数值实现\n\n含时薛定谔方程在离散的时空格点上进行数值求解。\n\n**2.1. 离散化与初始态**\n\n空间域是区间 $[-L/2, L/2)$，被离散化为 $N$ 个点 $x_j = -L/2 + j \\Delta x$（$j=0, \\dots, N-1$），格点间距为 $\\Delta x = L/N$。时间被离散化为步长为 $\\Delta t$ 的步。\n\n在 $t=0$ 时的初始态是一个中心位于 $x_0$、标准差为 $\\sigma$ 的高斯波包，并经过动量为 $p_0$ 的伽利略变换：\n$$\n\\psi(x,0) = C \\exp\\left(-\\frac{(x-x_0)^2}{2\\sigma^2}\\right)\\,\\exp(i p_0 x)\n$$\n常数 $C$ 的选择是为了在离散格点上归一化波函数，即 $\\sum_{j=0}^{N-1} |\\psi(x_j,0)|^2 \\Delta x = 1$。\n\n**2.2. 时间传播：分裂算符 FFT 方法**\n\n在一个小时间步长 $\\Delta t$ 内，含时薛定谔方程的形式解为 $\\psi(t+\\Delta t) = \\exp(-i\\hat{H}\\Delta t)\\psi(t)$。由于动能算符 ($\\hat{T}$) 和势能算符 ($\\hat{V}$) 不对易，我们使用时间演化算符的二阶对称 Trotter-Suzuki 分解：\n$$\ne^{-i(\\hat{T}+\\hat{V})\\Delta t} \\approx e^{-i\\hat{V}\\Delta t/2} \\, e^{-i\\hat{T}\\Delta t} \\, e^{-i\\hat{V}\\Delta t/2}\n$$\n该方案是幺正的（保范的），并且单步精度为 $O(\\Delta t^3)$。一个时间步的传播算法如下：\n1.  **势能半步：** 在坐标空间中演化，将势能算符作用 $\\Delta t/2$ 的时间。这相当于将波函数乘以一个相位因子：$\\psi(x) \\rightarrow \\psi(x) \\exp(-i U(x) \\Delta t / 2)$。\n2.  **动能整步：** 在动量空间中演化，将动能算符作用一个完整步长 $\\Delta t$ 的时间。这通过以下步骤实现：\n    a.  使用快速傅里叶变换（FFT）将 $\\psi(x)$ 变换到其动量空间表示 $\\tilde{\\psi}(k)$。\n    b.  将 $\\tilde{\\psi}(k)$ 乘以动能相位因子 $\\exp(-i k^2 \\Delta t / (2m))$，其中 $k$ 是对应于动量格点的波数。\n    c.  使用逆 FFT 将其变换回坐标空间。\n3.  **势能半步：** 如同步骤1，再次将势能算符作用第二个半步长 $\\Delta t/2$。\n\n波数格点 $k$ 是由 FFT 频率构造的，$k_n = 2\\pi f_n$，其中 $f_n$ 是由 `numpy.fft.fftfreq(N, d=dx)` 提供的频率。\n\n**2.3. 可观测量计算**\n\n在每个时间步，我们使用格点上的数值积分来计算所需的期望值：\n-   位置：$\\langle \\hat{x} \\rangle(t) \\approx \\sum_j |\\psi(x_j, t)|^2 x_j \\Delta x$。\n-   力：$\\langle -\\partial_x U \\rangle(t) \\approx \\sum_j |\\psi(x_j, t)|^2 \\left(-\\frac{\\partial U}{\\partial x}\\Big|_{x_j}\\right) \\Delta x$。这里使用给定势的解析导数。\n-   动量：$\\langle \\hat{p} \\rangle(t) = \\int \\psi^*(x,t)(-i\\partial_x)\\psi(x,t)dx$。为获得高精度，导数 $\\partial_x \\psi$ 通过谱方法计算。算符 $\\hat{p}\\psi = -i\\partial_x\\psi$ 被计算为 $\\mathcal{F}^{-1}(k \\mathcal{F}(\\psi))$，其中 $\\mathcal{F}$ 和 $\\mathcal{F}^{-1}$ 分别表示 FFT 及其逆变换。然后通过求和 $\\sum_j \\psi_j^*(t) (\\hat{p}\\psi)_j(t) \\Delta x$ 计算期望值。\n\n### 3. 验证过程\n\n模拟结束后，我们得到 $\\langle \\hat{x} \\rangle(t_i)$、$\\langle \\hat{p} \\rangle(t_i)$ 和 $\\langle -\\partial_x U \\rangle(t_i)$ 的时间序列。\n\n**3.1. 数值微分**\n\n时间导数 $\\frac{d}{dt}\\langle \\hat{x} \\rangle$ 和 $\\frac{d}{dt}\\langle \\hat{p} \\rangle$ 从它们的时间序列（我们将其一般地称为 $f(t_i)$）中计算出来，采用二阶精度的有限差分格式：\n-   对于内部点（$i=1, \\dots, N_t-1$）：使用中心差分。\n    $$ \\frac{df}{dt}\\Big|_{t_i} \\approx \\frac{f(t_{i+1}) - f(t_{i-1})}{2\\Delta t} $$\n-   对于端点（$i=0$ 和 $i=N_t$）：使用二阶单边格式。\n    $$ \\frac{df}{dt}\\Big|_{t_0} \\approx \\frac{-3f(t_0) + 4f(t_1) - f(t_2)}{2\\Delta t} $$\n    $$ \\frac{df}{dt}\\Big|_{t_{N_t}} \\approx \\frac{3f(t_{N_t}) - 4f(t_{N_t-1}) + f(t_{N_t-2})}{2\\Delta t} $$\n\n**3.2. 误差计算**\n\n最后，通过计算每个关系在整个模拟时间内的最大绝对偏差来检验埃伦费斯特关系的数值有效性：\n-   位置关系中的误差：$e_{x} = \\max_{t_i} \\left| \\frac{d}{dt}\\langle \\hat{x} \\rangle(t_i) - \\frac{\\langle \\hat{p} \\rangle(t_i)}{m} \\right|$\n-   动量关系中的误差：$e_{p} = \\max_{t_i} \\left| \\frac{d}{dt}\\langle \\hat{p} \\rangle(t_i) - \\langle -\\partial_x U \\rangle(t_i) \\right|$\n\n这两个值 $e_x$ 和 $e_p$ 会对三种势能情景中的每一种进行计算，从而为模拟的准确性及其对基本量子原理的遵循程度提供一个定量的度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a 1D TDSE simulation for a given set of parameters\n    and verifies Ehrenfest's theorem.\n    \"\"\"\n    # Unpack parameters\n    potential_type = params['potential_type']\n    L = params['L']\n    N = params['N']\n    dt = params['dt']\n    Nt = params['Nt']\n    sigma = params['sigma']\n    x0 = params['x0']\n    p0 = params['p0']\n    m = params.get('m', 1.0)\n    omega = params.get('omega', 0)\n    U0 = params.get('U0', 0)\n    a = params.get('a', 1)\n\n    # Spatial grid\n    dx = L / N\n    x = np.arange(-L / 2, L / 2, dx)\n\n    # Momentum grid (wave number)\n    k = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # Time grid\n    # Total number of time points where observables are stored is Nt+1\n    # from t=0 to t=Nt*dt inclusive\n    num_time_points = Nt + 1\n\n    # Define potentials and their derivatives\n    if potential_type == 'free':\n        V = np.zeros_like(x)\n        neg_dVdx = np.zeros_like(x)\n    elif potential_type == 'harmonic':\n        V = 0.5 * m * omega**2 * x**2\n        neg_dVdx = -m * omega**2 * x\n    elif potential_type == 'gaussian':\n        V = -U0 * np.exp(-x**2 / (2 * a**2))\n        neg_dVdx = -U0 * (x / a**2) * np.exp(-x**2 / (2 * a**2))\n    else:\n        raise ValueError(\"Unknown potential type\")\n\n    # Initial wave function (normalized)\n    psi = (1 / (np.pi * sigma**2))**(1/4) * \\\n          np.exp(-(x - x0)**2 / (2 * sigma**2)) * \\\n          np.exp(1j * p0 * x)\n    norm = np.sqrt(np.sum(np.abs(psi)**2) * dx)\n    psi /= norm\n\n    # Time evolution operators\n    exp_V_half = np.exp(-1j * V * dt / 2)\n    exp_T = np.exp(-1j * k**2 * dt / (2 * m))\n\n    # Arrays to store expectation values\n    x_exp_t = np.zeros(num_time_points)\n    p_exp_t = np.zeros(num_time_points)\n    force_exp_t = np.zeros(num_time_points)\n\n    # Main time-evolution loop\n    for i in range(num_time_points):\n        # Calculate and store observables at current time\n        x_exp_t[i] = np.sum(np.conj(psi) * x * psi).real * dx\n        \n        psi_k = np.fft.fft(psi)\n        p_psi = np.fft.ifft(k * psi_k)\n        p_exp_t[i] = np.sum(np.conj(psi) * p_psi).real * dx\n        \n        force_exp_t[i] = np.sum(np.abs(psi)**2 * neg_dVdx).real * dx\n\n        # Propagate for the next step (if not the last step)\n        if i  Nt:\n            # First half potential step\n            psi = exp_V_half * psi\n            # Full kinetic step in momentum space\n            psi_k = np.fft.fft(psi)\n            psi_k = exp_T * psi_k\n            psi = np.fft.ifft(psi_k)\n            # Second half potential step\n            psi = exp_V_half * psi\n\n    # Calculate time derivatives of expectation values\n    def second_order_derivative(f, h):\n        dfdt = np.zeros_like(f)\n        # Central difference for interior\n        dfdt[1:-1] = (f[2:] - f[:-2]) / (2 * h)\n        # Second-order forward difference for the start\n        if len(f) > 2:\n            dfdt[0] = (-3*f[0] + 4*f[1] - f[2]) / (2 * h)\n        # Second-order backward difference for the end\n        if len(f) > 2:\n            dfdt[-1] = (3*f[-1] - 4*f[-2] + f[-3]) / (2 * h)\n        return dfdt\n\n    d_x_exp_dt = second_order_derivative(x_exp_t, dt)\n    d_p_exp_dt = second_order_derivative(p_exp_t, dt)\n\n    # Calculate deviations from Ehrenfest relations\n    err_x = np.abs(d_x_exp_dt - p_exp_t / m)\n    err_p = np.abs(d_p_exp_dt - force_exp_t)\n\n    max_err_x = np.max(err_x)\n    max_err_p = np.max(err_p)\n\n    return [max_err_x, max_err_p]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        { # 1) Free particle\n            'potential_type': 'free',\n            'L': 200.0, 'N': 1024,\n            'dt': 0.02, 'Nt': 400,\n            'sigma': 2.0, 'x0': -30.0, 'p0': 2.0,\n            'm': 1.0\n        },\n        { # 2) Harmonic oscillator\n            'potential_type': 'harmonic',\n            'L': 200.0, 'N': 1024,\n            'dt': 0.02, 'Nt': 600,\n            'omega': 0.15,\n            'sigma': 1.0 / np.sqrt(0.15), 'x0': 15.0, 'p0': 1.0,\n            'm': 1.0\n        },\n        { # 3) Gaussian well\n            'potential_type': 'gaussian',\n            'L': 200.0, 'N': 1024,\n            'dt': 0.01, 'Nt': 800,\n            'U0': 6.0, 'a': 3.0,\n            'sigma': 2.0, 'x0': -20.0, 'p0': 2.0,\n            'm': 1.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[0.00012,0.00034],[...],[...]]\n    output_str = f\"[{','.join([f'[{r[0]},{r[1]}]' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "标准的数值方法有时会破坏基本的物理对称性，如伽利略不变性，从而导致非物理性的结果。这个高级实践探讨了如何诊断由空间离散化引起的此类人为效应，并实施修正方案以恢复内在属性的物理不变性。这是构建高保真度模拟工具的关键一步 。",
            "id": "3577472",
            "problem": "设计并实现一个独立的数值实验，在一个简化的含时哈特里-福克 (TDHF) 框架下，通过对一个孤立的束缚系统进行助推，来评估伽利略不变性，并量化由梯度的有限差分格式离散化所导致的不变性破坏。在一维空间中进行计算，使用由两个正交归一的单粒子轨道构建的斯莱特行列式来近似一个紧凑的原子核。使用无量纲自然单位制，其中普朗克常数设为 $\\,\\hbar = 1\\,$，核子质量设为 $\\,m = 1\\,$；因此所有量都是无量纲的。目标是展示不变性要求什么，为什么可以从第一性原理预见它，有限差分梯度如何破坏它，以及如何构建和测试恢复内禀可观测量不变性的修正方案。\n\n构建以下场景和计算：\n\n- 几何与网格：\n  - 使用一个均匀周期性网格，包含 $\\,N = 512\\,$ 个点，分布在以 $\\,x = 0\\,$ 为中心、长度为 $\\,L = 64\\,$ 的区间上。网格间距为 $\\,a = L/N\\,$，点坐标为 $\\,x_n = a \\left(n - N/2\\right)\\,$，其中整数 $\\,n \\in \\{0,1,\\dots,N-1\\}$。\n- 束缚系统与轨道：\n  - 使用两个正交归一的单粒子轨道 $\\,\\psi_0(x)\\,$ 和 $\\,\\psi_1(x)\\,$，它们在连续谱中被建模为宽度参数 $\\,b = 2.0\\,$ 的前两个谐振子本征函数：\n    - $\\,\\psi_0(x) \\propto \\exp\\!\\left(-\\frac{x^2}{2 b^2}\\right)\\,$，\n    - $\\,\\psi_1(x) \\propto \\frac{x}{b} \\exp\\!\\left(-\\frac{x^2}{2 b^2}\\right)\\,$，\n    以上定义不包含总的归一化常数。将这些函数在网格上离散化，并使用权重为 $\\,a\\,$ 的离散内积重新归一化。将该系统视为一个具有 $\\,A = 2\\,$ 个占据轨道的斯莱特行列式。\n- 均匀助推：\n  - 对于给定的速度 $\\,v\\,$，通过乘以相位因子 $\\,\\mathrm{e}^{\\mathrm{i} k_0 x}\\,$ 对每个轨道进行伽利略助推，其中 $\\,k_0 = m v\\,$ 且在此单位制中 $\\,m = 1\\,$。因此，助推后的轨道为 $\\,\\psi_i^{(v)}(x) = \\mathrm{e}^{\\mathrm{i} k_0 x} \\psi_i(x)\\,$，其中 $\\,i \\in \\{0,1\\}$。\n- 离散算符：\n  - 使用具有周期性边界条件的二阶中心有限差分来定义作用在网格函数 $\\,\\phi\\,$ 上的离散拉普拉斯算符 $\\,\\Delta\\,$ 和动量算符 $\\,\\hat{p}\\,$：\n    - $\\,(\\Delta \\phi)_n = \\dfrac{\\phi_{n+1} - 2 \\phi_n + \\phi_{n-1}}{a^2}\\,$，\n    - $\\,(\\hat{p}\\, \\phi)_n = -\\mathrm{i}\\,\\dfrac{\\phi_{n+1} - \\phi_{n-1}}{2 a}\\,$。\n  - 将离散动能定义为 $\\,T[\\{\\psi_i\\}] = \\dfrac{1}{2 m} \\sum_{i=0}^{A-1} \\sum_{n=0}^{N-1} \\psi_i^*(x_n)\\,(-\\Delta \\psi_i)(x_n)\\, a\\,$，总动量定义为 $\\,P[\\{\\psi_i\\}] = \\sum_{i=0}^{A-1} \\sum_{n=0}^{N-1} \\psi_i^*(x_n)\\,(\\hat{p}\\, \\psi_i)(x_n)\\, a\\,$。在此单位制中，取 $\\,m = 1\\,$。\n  - 将朴素内禀动能定义为 $\\,T_{\\mathrm{int}}^{\\mathrm{naive}} = T - \\dfrac{P^2}{2 A m}\\,$，其中 $\\,A = 2\\,$ 且 $\\,m = 1\\,$。\n- 内禀几何：\n  - 定义单体密度 $\\,\\rho(x) = \\sum_{i=0}^{A-1} |\\psi_i(x)|^2\\,$。定义质心位置 $\\,X_{\\mathrm{cm}} = \\dfrac{1}{A} \\sum_n x_n \\rho(x_n) a\\,$ 和内禀均方半径 $\\,\\langle r^2 \\rangle_{\\mathrm{int}} = \\dfrac{1}{A} \\sum_n (x_n - X_{\\mathrm{cm}})^2 \\rho(x_n) a\\,$。\n- 格点色散修正：\n  - 对于周期性网格上的二阶拉普拉斯算符，平面波的动能色散关系为 $\\,\\varepsilon_{\\mathrm{lat}}(k) = \\dfrac{2 - 2 \\cos(k a)}{2 m a^2}\\,$。通过从助推后的总动能中减去 $\\,A \\,\\varepsilon_{\\mathrm{lat}}(k_0)\\,$，提出一种针对均匀助推的基于色散的修正。定义 $\\,\\Delta T_{\\mathrm{int}}^{\\mathrm{disp}}(v) = \\left[T(\\{\\psi_i^{(v)}\\}) - A\\,\\varepsilon_{\\mathrm{lat}}(k_0)\\right] - T(\\{\\psi_i^{(0)}\\})\\,$。\n- 规范链接 (Peierls) 修正：\n  - 通过引入链接因子 $\\,U = \\mathrm{e}^{-\\mathrm{i} k_0 a}\\,$ 并定义作用在助推轨道 $\\,\\phi\\,$ 上的经链接修正的拉普拉斯算符，提出一个与均匀助推一致的规范协变动能算符：\n    $$ (\\Delta_U \\phi)_n = \\dfrac{U\\,\\phi_{n+1} - 2 \\phi_n + U^* \\,\\phi_{n-1}}{a^2}. $$\n    相应的经链接修正的助推后动能为 $\\,T_U[\\{\\psi_i^{(v)}\\}] = \\dfrac{1}{2 m} \\sum_i \\sum_n \\psi_i^{(v)*}(x_n)\\, \\big(-\\Delta_U \\psi_i^{(v)}\\big)(x_n)\\, a\\,$。定义 $\\,\\Delta T_{\\mathrm{int}}^{U}(v) = T_U(\\{\\psi_i^{(v)}\\}) - T(\\{\\psi_i^{(0)}\\})\\,$。\n- 对每个测试速度 $\\,v\\,$ 需要计算的不变性度量：\n  - 内禀均方半径的绝对变化 $\\,|\\Delta \\langle r^2 \\rangle_{\\mathrm{int}}(v)| = \\left| \\langle r^2 \\rangle_{\\mathrm{int}}^{(v)} - \\langle r^2 \\rangle_{\\mathrm{int}}^{(0)} \\right|\\,$。\n  - 使用朴素减法计算的虚假内禀动能变化 $\\,\\Delta T_{\\mathrm{int}}^{\\mathrm{naive}}(v) = T_{\\mathrm{int}}^{\\mathrm{naive}}(\\{\\psi_i^{(v)}\\}) - T_{\\mathrm{int}}^{\\mathrm{naive}}(\\{\\psi_i^{(0)}\\})\\,$。\n  - 上文定义的经色散修正的内禀变化 $\\,\\Delta T_{\\mathrm{int}}^{\\mathrm{disp}}(v)\\,$。\n  - 上文定义的经规范链接修正的内禀变化 $\\,\\Delta T_{\\mathrm{int}}^{U}(v)\\,$。\n- 测试组：\n  - 使用速度 $\\,v \\in \\{0.0, 2.0, 8.0, 24.0\\}\\,$。这些速度涵盖了基准情况、中等助推、更强助推，以及考虑到 $\\,a = 0.125\\,$ 时奈奎斯特波数为 $\\,\\pi/a \\approx 25.1327\\,$ 的接近奈奎斯特的助推。\n- 输出规格：\n  - 你的程序必须为每个测试速度 $\\,v\\,$（按上述顺序列出）计算浮点数四元组\n    $$ \\left[\\,\\left|\\Delta \\langle r^2 \\rangle_{\\mathrm{int}}(v)\\right|,\\; \\Delta T_{\\mathrm{int}}^{\\mathrm{naive}}(v),\\; \\Delta T_{\\mathrm{int}}^{\\mathrm{disp}}(v),\\; \\Delta T_{\\mathrm{int}}^{U}(v)\\,\\right]. $$\n  - 将所有结果按相同顺序汇总到一个长度为 $\\,4 \\times 4 = 16\\,$ 的扁平列表中，并打印且仅打印一行，其中包含这个用方括号括起来、用逗号分隔值的扁平列表，例如 $\\,\\left[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_{16}\\right]\\,$。\n- 所有返回值必须是这些无量纲单位下的浮点数。\n\n你的实现必须是一个完整的、可运行的程序，无需任何外部输入即可执行所有步骤，并严格遵守上述输出格式要求。",
            "solution": "该问题要求设计并实现一个数值实验，以研究由有限差分格式离散化导致的伽利略不变性破坏。这是计算多体物理学中的一个关键课题，尤其是在含时哈特里-福克 (TDHF) 框架内。伽利略不变性规定，物理定律在所有惯性参考系中都应相同。对于像原子核这样的孤立自束缚系统，这意味着其内禀属性（如尺寸、结合能）必须与其整体的质心速度无关。虽然这种不变性对于连续的薛定谔方程成立，但在空间格点上的标准数值离散化会破坏它，从而引入依赖于系统速度的人为误差。本实验量化了这些破坏，并测试了两种常见的修正方案。\n\n我们将在一个空间维度 ($x$) 中进行计算，使用无量纲自然单位制，其中 $\\hbar=1$ 且核子质量为 $m=1$。\n\n首先，我们建立计算环境。系统定义在一个均匀周期性网格上，该网格包含 $N=512$ 个点，跨度为 $L=64$。因此，网格间距为 $a = L/N = 64/512 = 0.125$。网格点坐标为 $x_n = a(n - N/2)$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。\n\n束缚系统由一个 $A=2$ 个核子占据两个正交归一单粒子轨道 $\\psi_0(x)$ 和 $\\psi_1(x)$ 的斯莱特行列式建模。这两个轨道取为谐振子势的基态和第一激发态，宽度参数为 $b=2.0$：\n$$ \\psi_0(x) \\propto \\exp\\left(-\\frac{x^2}{2 b^2}\\right) $$\n$$ \\psi_1(x) \\propto \\frac{x}{b} \\exp\\left(-\\frac{x^2}{2 b^2}\\right) $$\n这些连续函数在网格上进行离散化，得到数组 $\\psi_{i,n} = \\psi_i(x_n)$。然后相对于离散内积进行数值正交归一化，对于两个网格函数 $\\phi_A$ 和 $\\phi_B$，离散内积定义为 $\\langle \\phi_A | \\phi_B \\rangle = \\sum_{n=0}^{N-1} \\phi_A^*(x_n) \\phi_B(x_n) a$。\n\n通过将每个定态轨道 $\\psi_i(x)$ 乘以一个相位因子，将其转换为运动轨道 $\\psi_i^{(v)}(x)$，从而施加一个速度为 $v$ 的伽利略助推：\n$$ \\psi_i^{(v)}(x) = e^{i k_0 x} \\psi_i(x) $$\n其中 $k_0 = m v = v$ 是助推的动量。\n\n关键的物理可观测量是使用离散算符计算的。动量算符 $\\hat{p}$ 和拉普拉斯算符 $\\Delta$ 使用带有周期性边界条件的二阶中心有限差分进行近似：\n$$ (\\hat{p} \\phi)_n = -i \\frac{\\phi_{n+1} - \\phi_{n-1}}{2a} $$\n$$ (\\Delta \\phi)_n = \\frac{\\phi_{n+1} - 2\\phi_n + \\phi_{n-1}}{a^2} $$\n其中 $\\phi_{N} = \\phi_0$ 且 $\\phi_{-1} = \\phi_{N-1}$。对于 $A$ 个轨道 $\\{\\psi_i\\}$ 的系统，总动能 $T$ 和总动量 $P$ 为：\n$$ T[\\{\\psi_i\\}] = \\sum_{i=0}^{A-1} \\left\\langle \\psi_i \\middle| \\frac{-\\Delta}{2m} \\middle| \\psi_i \\right\\rangle = \\frac{1}{2m} \\sum_{i=0}^{A-1} \\sum_{n=0}^{N-1} \\psi_i^*(x_n) (-\\Delta \\psi_i)(x_n) a $$\n$$ P[\\{\\psi_i\\}] = \\sum_{i=0}^{A-1} \\langle \\psi_i | \\hat{p} | \\psi_i \\rangle = \\sum_{i=0}^{A-1} \\sum_{n=0}^{N-1} \\psi_i^*(x_n) (\\hat{p} \\psi_i)(x_n) a $$\n其中 $m=1$ 且 $A=2$。“朴素”内禀动能通过减去质心动能得到：\n$$ T_{\\mathrm{int}}^{\\mathrm{naive}} = T - \\frac{P^2}{2Am} $$\n在连续谱中，$T_{\\mathrm{int}}$ 在伽利略助推下是不变的。我们的目标是在格点上检验这一点。\n\n内禀几何属性由单体密度 $\\rho(x)$ 导出：\n$$ \\rho(x) = \\sum_{i=0}^{A-1} |\\psi_i(x)|^2 $$\n质心位置 $X_{\\mathrm{cm}}$ 和内禀均方半径 $\\langle r^2 \\rangle_{\\mathrm{int}}$ 为：\n$$ X_{\\mathrm{cm}} = \\frac{1}{A} \\sum_{n=0}^{N-1} x_n \\rho(x_n) a $$\n$$ \\langle r^2 \\rangle_{\\mathrm{int}} = \\frac{1}{A} \\sum_{n=0}^{N-1} (x_n - X_{\\mathrm{cm}})^2 \\rho(x_n) a $$\n一个关键的观察是，助推操作不改变密度：$\\rho^{(v)}(x) = \\sum_i |e^{ik_0x}\\psi_i(x)|^2 = \\sum_i |\\psi_i(x)|^2 = \\rho^{(0)}(x)$。因此，任何仅依赖于密度的可观测量，如 $X_{\\mathrm{cm}}$ 和 $\\langle r^2 \\rangle_{\\mathrm{int}}$，都必须是精确不变的。这提供了一个合理性检查。因此，第一个度量 $|\\Delta \\langle r^2 \\rangle_{\\mathrm{int}}(v)| = | \\langle r^2 \\rangle_{\\mathrm{int}}^{(v)} - \\langle r^2 \\rangle_{\\mathrm{int}}^{(0)} |$ 必须为零。\n\n伽利略不变性的破坏出现在动能项中。我们测试两种修正方案。\n\n1.  **格点色散修正**：在我们的格点上，平面波 $e^{ikx}$ 的动能不是连续谱下的 $k^2/(2m)$，而是 $\\varepsilon_{\\mathrm{lat}}(k) = \\frac{2 - 2\\cos(ka)}{2ma^2}$。该修正方案假设，虚假能量来自于对助推能量本身的错误计算。它定义了一个修正后的内禀能量变化：\n    $$ \\Delta T_{\\mathrm{int}}^{\\mathrm{disp}}(v) = \\left[T(\\{\\psi_i^{(v)}\\}) - A\\,\\varepsilon_{\\mathrm{lat}}(k_0)\\right] - T(\\{\\psi_i^{(0)}\\}) $$\n\n2.  **规范链接 (Peierls) 修正**：这是一种更基本的修正方法，它修改动能算符，使其相对于助推操作具有“规范协变性”。一个链接因子 $U = e^{-ik_0a}$ 被引入到有限差分模板中。经链接修正的拉普拉斯算符 $\\Delta_U$ 作用于一个助推后的轨道 $\\phi = \\psi_i^{(v)}$ 时，定义如下：\n    $$ (\\Delta_U \\phi)_n = \\frac{U \\phi_{n+1} - 2\\phi_n + U^* \\phi_{n-1}}{a^2} $$\n    通过代入可以证明，该算符满足协变关系 $(\\Delta_U \\psi_i^{(v)})(x_n) = e^{ik_0x_n}(\\Delta \\psi_i)(x_n)$。经链接修正的动能为 $T_U[\\{\\psi_i^{(v)}\\}] = \\sum_i \\langle \\psi_i^{(v)} | -\\Delta_U/(2m) | \\psi_i^{(v)} \\rangle$。相位因子的抵消导致 $T_U[\\{\\psi_i^{(v)}\\}] = T[\\{\\psi_i^{(0)}\\}]$。因此，相应的变化量 $\\Delta T_{\\mathrm{int}}^{U}(v) = T_U(\\{\\psi_i^{(v)}\\}) - T(\\{\\psi_i^{(0)}\\})$ 在理论上应为零，误差仅限于浮点精度。\n\n计算流程如下：\n1.  初始化网格参数并定义两个初始轨道，然后将它们离散化并进行数值正交归一化。\n2.  计算参考值（$v=0$ 时）：$\\langle r^2 \\rangle_{\\mathrm{int}}^{(0)}$ 和 $T_{\\mathrm{int}}^{\\mathrm{naive},(0)} = T^{(0)}$。注意，对于对称的初始态，$P^{(0)}=0$。\n3.  遍历测试速度 $v \\in \\{0.0, 2.0, 8.0, 24.0\\}$。\n4.  对于每个非零的 $v$，创建助推后的轨道 $\\psi_i^{(v)}$。\n5.  计算四个指定的度量：\n    a. $|\\Delta \\langle r^2 \\rangle_{\\mathrm{int}}(v)|$：内禀尺寸的变化。预期为 $0$。\n    b. $\\Delta T_{\\mathrm{int}}^{\\mathrm{naive}}(v) = (T^{(v)} - (P^{(v)})^2/(2A)) - T^{(0)}$：来自朴素算符的虚假能量。\n    c. $\\Delta T_{\\mathrm{int}}^{\\mathrm{disp}}(v) = T^{(v)} - A\\,\\varepsilon_{\\mathrm{lat}}(k_0) - T^{(0)}$：经色散修正后的残余能量。\n    d. $\\Delta T_{\\mathrm{int}}^{U}(v) = T_U(\\{\\psi_i^{(v)}\\}) - T^{(0)}$：经规范链接修正后的残余能量。预期为 $0$。\n6.  将 4 个速度下各自的 4 个值收集到一个包含 16 个数字的扁平列表中作为最终输出。结果将展示朴素算符的失效之处，并比较两种修正方案的有效性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a numerical experiment to assess Galilean invariance\n    in a simplified TDHF setting.\n    \"\"\"\n    # 1. Setup Geometry and Grid\n    N = 512\n    L = 64.0\n    a = L / N\n    x = a * (np.arange(N) - N / 2)\n\n    # 2. Setup Bound System and Orbitals\n    b = 2.0\n    A = 2\n    m = 1.0\n\n    # Define unnormalized orbitals on the grid\n    psi0_unnormalized = np.exp(-x**2 / (2 * b**2))\n    psi1_unnormalized = (x / b) * np.exp(-x**2 / (2 * b**2))\n\n    # Normalize orbitals using the discrete inner product\n    norm0 = np.sqrt(a * np.sum(np.abs(psi0_unnormalized)**2))\n    psi0 = psi0_unnormalized / norm0\n    \n    norm1 = np.sqrt(a * np.sum(np.abs(psi1_unnormalized)**2))\n    psi1 = psi1_unnormalized / norm1\n    \n    # The set of stationary (unboosted) orbitals\n    psis_0 = [psi0, psi1]\n\n    # 3. Setup Discrete Operators\n    def laplacian(phi, grid_spacing):\n        phi_p1 = np.roll(phi, -1)\n        phi_m1 = np.roll(phi, 1)\n        return (phi_p1 - 2 * phi + phi_m1) / grid_spacing**2\n\n    def momentum_op(phi, grid_spacing):\n        phi_p1 = np.roll(phi, -1)\n        phi_m1 = np.roll(phi, 1)\n        return -1j * (phi_p1 - phi_m1) / (2 * grid_spacing)\n\n    def laplacian_U(phi, grid_spacing, U):\n        phi_p1 = np.roll(phi, -1)\n        phi_m1 = np.roll(phi, 1)\n        U_conj = np.conj(U)\n        return (U * phi_p1 - 2 * phi + U_conj * phi_m1) / grid_spacing**2\n        \n    # 4. Setup Observable Calculations\n    def calculate_T(psis, grid_spacing, mass):\n        ke = 0.0\n        for psi in psis:\n            ke += a * np.sum(np.conj(psi) * (-laplacian(psi, grid_spacing)))\n        return ke / (2 * mass)\n\n    def calculate_P(psis, grid_spacing):\n        mom = 0.0\n        for psi in psis:\n            mom += a * np.sum(np.conj(psi) * momentum_op(psi, grid_spacing))\n        return mom.real # Should be real for Hermitian op expectation\n\n    def calculate_density(psis):\n        rho = np.zeros(N, dtype=float)\n        for psi in psis:\n            rho += np.abs(psi)**2\n        return rho\n\n    def calculate_Xcm(rho, x_grid, grid_spacing, num_particles):\n        return (1.0 / num_particles) * grid_spacing * np.sum(x_grid * rho)\n\n    def calculate_r2_int(rho, x_grid, grid_spacing, num_particles, x_cm):\n        return (1.0 / num_particles) * grid_spacing * np.sum((x_grid - x_cm)**2 * rho)\n\n    def calculate_T_U(psis_v, grid_spacing, mass, k0):\n        ke_U = 0.0\n        U = np.exp(-1j * k0 * grid_spacing)\n        for psi_v in psis_v:\n             # The operator is applied directly as per the problem statement\n             ke_U += a * np.sum(np.conj(psi_v) * (-laplacian_U(psi_v, grid_spacing, U)))\n        return ke_U / (2 * mass)\n\n    # Calculate reference values for v=0\n    T_0 = calculate_T(psis_0, a, m)\n    P_0 = calculate_P(psis_0, a) # Should be ~0 due to symmetry\n    T_int_naive_0 = T_0 - P_0**2 / (2 * A * m)\n\n    rho_0 = calculate_density(psis_0)\n    Xcm_0 = calculate_Xcm(rho_0, x, a, A) # Should be ~0\n    r2_int_0 = calculate_r2_int(rho_0, x, a, A, Xcm_0)\n\n    # 5. Main Loop over Test Velocities\n    test_velocities = [0.0, 2.0, 8.0, 24.0]\n    all_results = []\n\n    for v in test_velocities:\n        if v == 0.0:\n            all_results.extend([0.0, 0.0, 0.0, 0.0])\n            continue\n\n        k0 = m * v\n        \n        # Create boosted orbitals\n        boost_phase = np.exp(1j * k0 * x)\n        psis_v = [psi * boost_phase for psi in psis_0]\n\n        # --- Metric 1: Change in intrinsic mean-square radius ---\n        rho_v = calculate_density(psis_v)\n        Xcm_v = calculate_Xcm(rho_v, x, a, A)\n        r2_int_v = calculate_r2_int(rho_v, x, a, A, Xcm_v)\n        delta_r2_int = np.abs(r2_int_v - r2_int_0)\n\n        # --- Metric 2: Naive intrinsic kinetic energy change ---\n        T_v = calculate_T(psis_v, a, m)\n        P_v = calculate_P(psis_v, a)\n        T_int_naive_v = T_v - P_v**2 / (2 * A * m)\n        delta_T_int_naive = T_int_naive_v - T_int_naive_0\n\n        # --- Metric 3: Dispersion-corrected intrinsic change ---\n        eps_lat_k0 = (2.0 - 2.0 * np.cos(k0 * a)) / (2 * m * a**2)\n        delta_T_int_disp = (T_v - A * eps_lat_k0) - T_0\n\n        # --- Metric 4: Gauge-link corrected intrinsic change ---\n        T_U_v = calculate_T_U(psis_v, a, m, k0)\n        delta_T_int_U = T_U_v - T_0\n        \n        # Real part is taken as energy values should be real.\n        # Small imaginary parts can arise from float precision errors\n        quadruple = [\n            delta_r2_int,\n            delta_T_int_naive.real,\n            delta_T_int_disp.real,\n            delta_T_int_U.real,\n        ]\n        all_results.extend(quadruple)\n    \n    # 6. Final Output\n    # The format must be a flat list of floats.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}