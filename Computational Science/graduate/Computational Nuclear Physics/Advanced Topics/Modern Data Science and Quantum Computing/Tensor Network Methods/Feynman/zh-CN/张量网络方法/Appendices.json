{
    "hands_on_practices": [
        {
            "introduction": "基于矩阵乘积态 (MPS) 的算法（如密度矩阵重整化群 DMRG）的核心依赖于高效操控和规范化量子态的能力。混合规范形式的 MPS 使得二分纠缠谱可以直接在“正交中心”处获得。此练习将通过实践，让您掌握 MPS 规范化中的基本数值步骤（QR 和 SVD 分解），并验证这一关键的理论联系，从而加深对 MPS 如何编码纠缠的理解 ()。",
            "id": "3593660",
            "problem": "构建一个完整、可运行的程序，为一条由 $L=8$ 个单粒子轨道组成的一维链生成一个随机矩阵乘积态 (MPS; Matrix Product State)。每个轨道具有局域希尔伯特空间维度 $d=4$，内部键维度上限为 $D=50$。在计算核物理中，壳模型组态空间可以表示为张量网络，其中每个轨道具有有限的局域维度，多体态可以高效地编码为 MPS。该程序必须实现一个正则化扫描，将 MPS 转换为以位点 $i$ 和位点 $i+1$ 之间指定二分为中心的混合正则形式。此二分处的正交中心应编码该量子态在该切点上的施密特系数。\n\n从必须在 MPS 正则形式中成立的基本定义和性质开始。使用以下基础知识：\n\n- 施密特分解：对于一个写成左右两部分二分形式的纯态 $\\lvert\\Psi\\rangle$，存在一个正交归一分解 $\\lvert\\Psi\\rangle=\\sum_{\\alpha}\\lambda_{\\alpha}\\lvert\\alpha\\rangle_{\\text{left}}\\otimes\\lvert\\alpha\\rangle_{\\text{right}}$，其中 $\\lambda_{\\alpha}$ 是非负系数，称为施密特系数。\n- 奇异值分解 (SVD; Singular Value Decomposition)：对于任意矩阵 $M$，存在因子分解 $M=U\\Sigma V^{\\dagger}$，其中 $U$ 和 $V$ 是幺正矩阵，$\\Sigma$ 是具有非负元素的对角矩阵。非负的对角元素等于 $M$ 的奇异值。\n- MPS 正则形式：一个左正则张量 $A^{[s]}$ 满足 $\\sum_{p,\\alpha}A^{[s]}_{\\beta p \\alpha}A^{[s]}_{\\beta' p \\alpha}=\\delta_{\\beta\\beta'}$，一个右正则张量满足 $\\sum_{p,\\beta}A^{[s]}_{\\beta p \\alpha}A^{[s]}_{\\beta p \\alpha'}=\\delta_{\\alpha\\alpha'}$。在围绕位点 $i$ 和 $i+1$ 之间切点的混合正则形式中，位点 $i$ 左侧的张量是左正则的，位点 $i+1$ 右侧的张量是右正则的，它们之间的正交中心包含施密特系数。\n\n您的程序必须：\n\n1. 为具有 $L=8$ 个位点和局域维度 $d=4$ 的系统生成一个随机 MPS。使用开放边界条件，左键维度为 $D_{0}=1$，右键维度为 $D_{L}=1$，内部键维度上限为 $D=50$。用独立的标准正态分布项初始化每个 MPS 张量 $A^{[s]}$。\n2. 实现一个正则化扫描，将 MPS 转换为以位点 $i$ 和位点 $i+1$ 之间的指定切点为正交中心的混合正则形式。通过以下方式实现：\n   - 使用对重塑后张量的约化 $QR$ 分解，从位点 $0$ 到位点 $i$ 执行左正交归一化扫描，以强制执行左正则条件。\n   - 使用对适当转置矩阵的约化 $QR$ 分解，从位点 $L-1$ 向下到位点 $i+1$ 执行右正交归一化扫描，以强制执行右正则条件。\n   - 在位点 $i$ 和 $i+1$ 之间的键上执行局部 SVD，方法是将两个中心张量收缩成一个形状为 $(D_{i}^{\\text{left}}d) \\times (dD_{i+1}^{\\text{right}})$ 的矩阵 $M$，并计算 $M=U\\Sigma V^{\\dagger}$。将 $U$ 和 $V^{\\dagger}$ 插回到中心位点张量中，并将奇异值 $\\Sigma$ 记录为正交中心的施密特系数。\n3. 通过从 MPS 重构长度为 $d^{L}$ 的完整状态矢量 $\\psi$，并将其重塑为形状为 $d^{i+1}\\times d^{L-(i+1)}$ 的矩阵，然后执行 SVD 以获得奇异值，从而独立计算相同二分下的精确施密特系数。不要对状态进行归一化；比较未归一化的奇异值，以使两种方法保持一致。\n4. 通过报告针对选定二分，从正交中心获得的施密特谱与从完整状态获得的精确奇异值之间的最大绝对差，来验证两者是否匹配。\n\n设计一个包含三个确定性案例的测试套件，以测试不同的二分位置和随机初始化：\n\n- 案例 1：随机种子 $7$，切点在 $i=0$。\n- 案例 2：随机种子 $12345$，切点在 $i=3$。\n- 案例 3：随机种子 $9876$，切点在 $i=6$。\n\n对于每个案例，计算从正交中心提取的施密特系数与在相同二分下从精确的全状态 SVD 获得的施密特系数之间的最大绝对差。这些差异必须以浮点数形式报告。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[\\Delta_{1},\\Delta_{2},\\Delta_{3}]$，其中每个 $\\Delta_{k}$ 是案例 $k$ 的最大绝对差，表示为浮点数。此计算不涉及物理单位，也不需要角度或百分比。",
            "solution": "用户要求编写一个程序来验证矩阵乘积态 (MPS) 理论的一个核心原理：量子态在某个二分下的施密特系数可以通过对相应正则形式 MPS 的“正交中心”执行奇异值分解 (SVD) 来找到。该程序将生成一个随机 MPS，将其转换为特定的正则形式，并将从 MPS 过程中获得的奇异值与在完整、重构的状态矢量上进行精确 SVD 所得的奇异值进行比较。\n\n### 1. 矩阵乘积态 (MPS) 表示法\n\n一个一维链上 $L$ 个位点的纯量子态 $\\lvert\\Psi\\rangle$（其中每个位点具有局域基矢 $\\{\\lvert p_s \\rangle\\}_{p_s=0}^{d-1}$）可以写为：\n$$\n\\lvert\\Psi\\rangle = \\sum_{p_0, p_1, \\dots, p_{L-1}} C_{p_0 p_1 \\dots p_{L-1}} \\lvert p_0 p_1 \\dots p_{L-1} \\rangle\n$$\nMPS 拟设将系数张量 $C$ 近似为一系列更小的张量（矩阵）的乘积：\n$$\nC_{p_0 p_1 \\dots p_{L-1}} = \\sum_{\\alpha_0, \\dots, \\alpha_{L-1}} A^{[0]}_{\\alpha_0 p_0 \\alpha_1} A^{[1]}_{\\alpha_1 p_1 \\alpha_2} \\cdots A^{[L-1]}_{\\alpha_{L-1} p_L \\alpha_L}\n$$\n对于具有开放边界条件 (OBC) 的链，虚键索引 $\\alpha_0$ 和 $\\alpha_L$ 是平凡的（维度为 1），因此表达式简化为矩阵乘积：\n$$\nC_{p_0 p_1 \\dots p_{L-1}} = A^{[0]p_0} A^{[1]p_1} \\cdots A^{[L-1]p_{L-1}}\n$$\n这里，对于每个物理态 $p_s$，$A^{[s]p_s}$ 是一个矩阵。位点 $s$ 处的张量 $A^{[s]}$ 有三个索引：一个维度为 $d$ 的物理索引 $p_s$，一个维度为 $D_{s-1}$ 的左虚键索引 $\\alpha_{s-1}$，以及一个维度为 $D_s$ 的右虚键索引 $\\alpha_s$。虚键的维度由键维度 $D$ 上限所限制。\n\n### 2. 随机 MPS 生成\n\n我们将首先为一个具有 $L=8$ 个位点、局域维度 $d=4$ 和最大键维度 $D=50$ 的系统构建一个随机 MPS。连接位点 $s$ 和 $s+1$ 的键 $\\alpha_s$ 的维度选择为 $D_s = \\min(D, d^{s+1}, d^{L-(s+1)})$，这是一个泛型态在该切分下可能的最大秩，并以 $D$ 为上限。张量 $A^{[s]}$ 的元素从标准正态分布中抽取来进行初始化。\n\n### 3. 正则形式与施密特分解\n\nMPS 表示法具有一种“规范自由度”。我们可以在任意两个张量之间插入一个可逆矩阵 $G$ 及其逆矩阵 $G^{-1}$，$A^{[s]} \\to A^{[s]}G$ 和 $A^{[s+1]} \\to G^{-1}A^{[s+1]}$，而不会改变整体的物理态。这种自由度被用来将 MPS 转换为正则形式，从而简化计算并揭示物理性质。\n\n一个关键的洞见是 MPS 与施密特分解之间的联系。对于链的任意二分，即分为左部（位点 $0$ 到 $i$）和右部（位点 $i+1$ 到 $L-1$），该状态可以写为：\n$$\n\\lvert\\Psi\\rangle = \\sum_{\\alpha=1}^{k} \\lambda_{\\alpha} \\lvert \\phi_{\\alpha} \\rangle_{L} \\otimes \\lvert \\psi_{\\alpha} \\rangle_{R}\n$$\n其中 $\\{\\lvert \\phi_{\\alpha} \\rangle_{L}\\}$ 和 $\\{\\lvert \\psi_{\\alpha} \\rangle_{R}\\}$ 分别是左、右分区的正交归一态集。非负值 $\\lambda_{\\alpha}$ 是施密特系数，它们的数量 $k$ 是施密特秩。\n\n一个 MPS 可以被转换为关于切点 $(i, i+1)$ 的混合正则形式。在这种形式下：\n- 对于 $s \\le i$，张量 $A^{[s]}$ 是左正则的。\n- 对于 $s > i$，张量 $A^{[s]}$ 是右正则的。\n\n如果一个张量 $A^{[s]}$ 在重塑为矩阵 $M_{\\beta, (p \\alpha)} = A^{[s]}_{\\beta p \\alpha}$ 后满足 $M M^\\dagger = I$，那么它是左正则的。这等价于：\n$$\n\\sum_{p_s, \\alpha_s} (A^{[s]}_{\\alpha_{s-1} p_s \\alpha_s})^* A^{[s]}_{\\alpha'_{s-1} p_s \\alpha_s} = \\delta_{\\alpha_{s-1} \\alpha'_{s-1}}\n$$\n如果一个张量 $A^{[s]}$ 在重塑为矩阵 $M_{(\\beta p), \\alpha} = A^{[s]}_{\\beta p \\alpha}$ 后满足 $M^\\dagger M = I$，那么它是右正则的。这等价于：\n$$\n\\sum_{\\alpha_{s-1}, p_s} (A^{[s]}_{\\alpha_{s-1} p_s \\alpha_s})^* A^{[s]}_{\\alpha_{s-1} p_s \\alpha'_s} = \\delta_{\\alpha_s \\alpha'_s}\n$$\n当一个 MPS 处于以键 $(i, i+1)$ 为正交中心的混合正则形式时，施密特系数 $\\lambda_\\alpha$ 正是连接链的左正则和右正则两部分的矩阵 $\\Lambda$ 的奇异值。\n\n### 4. 算法步骤\n\n程序的核心是验证这种对应关系。\n\n**步骤 1：正则化与 MPS 施密特谱**\n我们遵循问题中指定的步骤，将随机 MPS 转换为以切点 $(i, i+1)$ 为中心的混合正则形式。\n\n1.  **左正交归一化扫描**：对从 $0$ 到 $i-1$ 的每个位点 $s$，我们将其张量 $A^{[s]}$ 重塑为形状为 $(D_{s-1}d, D_s)$ 的矩阵 $M$。然后我们执行约化 QR 分解，$M = QR$。新的张量 $A'^{[s]}$ 通过重塑 $Q$ 形成，使其成为左正则的。矩阵 $R$ 被收缩到下一个张量中，$A^{[s+1]} \\to R A^{[s+1]}$，从而将规范变换向右传播。此扫描后，张量 $A'^{[0]}, ..., A'^{[i-1]}$ 是左正则的，所有来自左部的剩余规范自由度都存储在 $A^{[i]}$ 中。\n\n2.  **右正交归一化扫描**：对称地，对于从 $L-1$ 向下到 $i+2$ 的每个位点 $s$，我们将 $A^{[s]}$ 重塑为形状为 $(D_{s-1}, dD_s)$ 的矩阵 $M$。我们对其转置矩阵进行 QR 分解，$M^T=QR$。新的张量 $A'^{[s]}$ 通过重塑 $Q^T$ 形成，使其成为右正则的。矩阵 $L=R^T$ 被收缩到前一个张量中，$A^{[s-1]} \\to A^{[s-1]}L$，从而将规范变换向左传播。此后，张量 $A'^{[L-1]}, ..., A'^{[i+2]}$ 是右正则的，来自右部的规范自由度存储在 $A^{[i+1]}$ 中。\n\n3.  **中心 SVD**：现在，该状态由直到位点 $i-1$ 的左正则张量、从位点 $i+2$ 开始的右正则张量，以及位于中心的两个张量 $A^{[i]}$ 和 $A^{[i+1]}$ 表示。我们将这两个中心张量在其共享的维度为 $D_i$ 的键上收缩。得到的张量 $\\Theta = A^{[i]}A^{[i+1]}$ 被重塑为大小为 $(D_{i-1}d \\times dD_{i+1})$ 的矩阵 $M_{\\text{center}}$。对此矩阵进行奇异值分解 (SVD)，$M_{\\text{center}} = U\\Sigma V^\\dagger$，得到的 $\\Sigma$ 对角线上的奇异值，即为 MPS 捕获的该切点上的施密特系数。\n\n**步骤 2：从完整状态矢量计算精确施密特谱**\n为了验证这一点，我们从第一性原理计算施密特谱。\n\n1.  **重构状态矢量**：我们收缩所有原始 MPS 张量 $A^{[0]}, \\dots, A^{[L-1]}$，以重构形状为 $(d, d, \\dots, d)$ 的完整状态张量 $C_{p_0 \\dots p_{L-1}}$。\n\n2.  **重塑与 SVD**：我们将此张量重塑为大小为 $(d^{i+1} \\times d^{L-(i+1)})$ 的矩阵 $M_{\\text{full}}$，该矩阵表示跨越二分 $(i, i+1)$ 的状态。然后我们计算 $M_{\\text{full}}$ 的 SVD。得到的奇异值是该状态的精确施密特系数。\n\n**步骤 3：比较**\n由于正则化过程是一个精确的规范变换，它不会改变物理状态。因此，从 MPS 正则形式获得的施密特系数必须与从完整状态矢量获得的施密特系数相同，直到数值浮点精度。我们计算两组奇异值之间的最大绝对差来验证这一点。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef get_sv_from_canonical_mps(mps_in, L, d, cut_i):\n    \"\"\"\n    Brings an MPS to mixed-canonical form with the center at cut (i, i+1)\n    and returns the Schmidt coefficients at that cut.\n    \"\"\"\n    mps = [t.copy() for t in mps_in]\n\n    # 1. Left-orthonormalization sweep from site 0 up to i-1.\n    # This makes tensors 0 to i-1 left-canonical.\n    for s in range(cut_i):\n        d_left, _, d_right = mps[s].shape\n        # Reshape to a matrix: (d_left * d) x d_right\n        M = mps[s].reshape(d_left * d, d_right)\n\n        # Reduced QR decomposition\n        Q, R = linalg.qr(M, mode='economic')\n\n        # Replace tensor with Q part, update next tensor with R part\n        new_d_right = Q.shape[1]\n        mps[s] = Q.reshape(d_left, d, new_d_right)\n        mps[s+1] = np.tensordot(R, mps[s+1], axes=([1], [0]))\n\n    # 2. Right-orthonormalization sweep from site L-1 down to i+1.\n    # This makes tensors L-1 down to i+1 right-canonical.\n    for s in range(L - 1, cut_i, -1):\n        d_left, _, d_right = mps[s].shape\n        # Reshape to a matrix: d_left x (d * d_right)\n        M = mps[s].reshape(d_left, d * d_right)\n\n        # QR on the transpose to enforce right-canonicality\n        M_T = M.T\n        Q, R = linalg.qr(M_T, mode='economic')\n\n        # New tensor is Q.T\n        new_d_left = Q.shape[1]\n        A_new_T = Q.T\n        mps[s] = A_new_T.reshape(new_d_left, d, d_right)\n\n        # Update previous tensor with L = R.T\n        L_mat = R.T\n        mps[s-1] = np.tensordot(mps[s-1], L_mat, axes=([2], [0]))\n\n    # 3. SVD at the center cut (i, i+1)\n    A_i = mps[cut_i]\n    A_i_plus_1 = mps[cut_i + 1]\n\n    # Contract the two center tensors\n    center_tensor = np.tensordot(A_i, A_i_plus_1, axes=([2], [0]))\n\n    # Reshape into a matrix for SVD\n    dl_i, _, d_phys_ip1, dr_ip1 = center_tensor.shape\n    center_matrix = center_tensor.reshape(dl_i * d, d_phys_ip1 * dr_ip1)\n\n    # Calculate singular values\n    _, svals, _ = linalg.svd(center_matrix, full_matrices=False)\n    \n    return svals\n\ndef get_sv_from_full_state(mps, L, d, cut_i):\n    \"\"\"\n    Reconstructs the full state vector from an MPS and computes the exact\n    Schmidt coefficients across a given cut.\n    \"\"\"\n    # 1. Reconstruct the full state tensor by contracting the MPS tensors\n    psi_tensor = mps[0]\n    for s in range(1, L):\n        psi_tensor = np.tensordot(psi_tensor, mps[s], axes=([-1], [0]))\n    \n    # Remove trivial bond dimensions at the boundaries\n    psi_tensor = psi_tensor.squeeze()\n    \n    # 2. Reshape the state tensor into a matrix representing the bipartition\n    psi_matrix = psi_tensor.reshape((d**(cut_i + 1), d**(L - (cut_i + 1))))\n    \n    # 3. Calculate singular values, which are the exact Schmidt coefficients\n    _, svals, _ = linalg.svd(psi_matrix, full_matrices=False)\n    \n    return svals\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    # System parameters\n    L = 8\n    d = 4\n    D_max = 50\n\n    # Test cases: (random_seed, cut_position_i)\n    # cut_position_i defines the cut between site i and i+1\n    test_cases = [\n        (7, 0),\n        (12345, 3),\n        (9876, 6)\n    ]\n\n    results = []\n\n    for seed, cut_i in test_cases:\n        # Set random seed for reproducibility\n        np.random.seed(seed)\n\n        # 1. Generate a random MPS\n        bond_dims = [1] * (L + 1)\n        for s in range(L - 1):\n            # The bond dimension s is between site s and s+1\n            # Maximum possible rank, capped by D_max\n            dim = min(D_max, d**(s + 1), d**(L - (s + 1)))\n            bond_dims[s+1] = dim\n        \n        mps = []\n        for s in range(L):\n            # A[s] has shape (D_{s-1}, d, D_s)\n            shape = (bond_dims[s], d, bond_dims[s+1])\n            mps.append(np.random.randn(*shape))\n\n        # 2. Get Schmidt values from the MPS canonicalization method\n        s_mps = get_sv_from_canonical_mps(mps, L, d, cut_i)\n        \n        # 3. Get exact Schmidt values from the full state vector\n        s_exact = get_sv_from_full_state(mps, L, d, cut_i)\n        \n        # 4. Compare the two sets of singular values\n        len_mps = len(s_mps)\n        len_exact = len(s_exact)\n        max_len = max(len_mps, len_exact)\n        \n        # Pad the shorter list with zeros for comparison\n        s_mps_padded = np.zeros(max_len)\n        s_exact_padded = np.zeros(max_len)\n        \n        s_mps_padded[:len_mps] = s_mps\n        s_exact_padded[:len_exact] = s_exact\n        \n        # Calculate the maximum absolute difference\n        max_abs_diff = np.max(np.abs(s_mps_padded - s_exact_padded))\n        results.append(max_abs_diff)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将张量网络应用于原子核等费米子体系，需要谨慎处理费米子的反对易关系。Jordan-Wigner 变换可以将费米算符映射为自旋算符，但代价是引入了非定域的“宇称弦”。本练习将指导您实现并验证处理费米子统计的核心工具，例如费米交换门和 Jordan-Wigner 弦，并揭示不同的轨道排序如何改变矩阵乘积算符 (MPO) 中的非定域符号结构，这是高效表示哈密顿量的关键考量 ()。",
            "id": "3593647",
            "problem": "考虑一个由 $L$ 个核位点组成的一维晶格，每个位点承载两种费米子，即质子和中子。每个位点的局域 Fock 空间有四个基态：$\\lvert 0 \\rangle$、$\\lvert p \\rangle$、$\\lvert n \\rangle$ 和 $\\lvert pn \\rangle$。费米子产生和湮灭算符遵循正则反对易关系\n$$\n\\{ \\hat{c}_{s,i}, \\hat{c}_{s',j}^\\dagger \\} = \\delta_{s,s'} \\delta_{ij}, \\quad \\{ \\hat{c}_{s,i}, \\hat{c}_{s',j} \\} = \\{ \\hat{c}_{s,i}^\\dagger, \\hat{c}_{s',j}^\\dagger \\} = 0,\n$$\n其中 $s \\in \\{p,n\\}$ 标记种类，$i,j \\in \\{1,\\dots,L\\}$ 标记晶格位点。某个模式上的宇称算符的本征值为 $(-1)^{\\hat{n}}$，其中 $\\hat{n}$ 是粒子数算符。\n\n为将费米子算符表示为自旋算符，可使用 Jordan–Wigner (JW) 变换。在任何固定的费米子模式全序中，JW 变换将每个费米子算符 $\\hat{c}_{m}$ 映射到其位置上的自旋下降算符，再乘以一个跨越所选排序中所有先于 $m$ 的模式的宇称算符串。对于双种类系统，两种常用的排序方式是：\n- 交错排序：$\\left[ p_1, n_1, p_2, n_2, \\dots, p_L, n_L \\right]$。\n- 分块排序：$\\left[ p_1, p_2, \\dots, p_L, n_1, n_2, \\dots, n_L \\right]$。\n\n在诸如矩阵乘积算符（MPO）之类的张量网络构造中，费米子统计由分级张量收缩处理。一个关键的构造单元是费米子交换张量，它置换两个费米子模式，并在交换宇称为 $\\vert a \\vert, \\vert b \\vert \\in \\{0,1\\}$ 的态 $a$ 和 $b$ 时引入一个符号 $(-1)^{\\vert a \\vert \\vert b \\vert}$。\n\n您的任务是实现一个程序，该程序：\n1. 通过检查费米子交换张量在占据数基 $\\{ \\lvert 00 \\rangle, \\lvert 01 \\rangle, \\lvert 10 \\rangle, \\lvert 11 \\rangle \\}$ 上的作用，来验证该张量对于两个无自旋费米子模式的有效性，其中 $\\lvert 0 \\rangle$ 表示空，$\\lvert 1 \\rangle$ 表示占据。验证应使用分级交换作用的定义\n$$\n\\hat{S} \\lvert 00 \\rangle = \\lvert 00 \\rangle, \\quad\n\\hat{S} \\lvert 01 \\rangle = \\lvert 10 \\rangle, \\quad\n\\hat{S} \\lvert 10 \\rangle = \\lvert 01 \\rangle, \\quad\n\\hat{S} \\lvert 11 \\rangle = - \\lvert 11 \\rangle.\n$$\n返回一个布尔值，表示所有四个作用是否均成立。\n\n2. 对于种类 $s \\in \\{p,n\\}$ 和位点 $i \\neq j$ 的类跃迁双线性费米子算符 $\\hat{O}_{s;i \\rightarrow j} = \\hat{c}_{s,i}^\\dagger \\hat{c}_{s,j}$，计算在交错排序和分块排序下的 JW 宇称串符号。对于由质子占据数 $\\mathbf{n}^{(p)} = (n^{(p)}_1,\\dots,n^{(p)}_L)$ 和中子占据数 $\\mathbf{n}^{(n)} = (n^{(n)}_1,\\dots,n^{(n)}_L)$ 指定的固定占据组态，将给定排序下的 JW 串符号因子定义为\n$$\n\\mathrm{JW\\_sign} = (-1)^{\\sum_{k \\in \\text{between}(i,j)} \\left( n_{k}^{(\\text{mode})} \\right)},\n$$\n其中求和遍及在所选排序中严格位于 $\\hat{c}_{s,i}^\\dagger$ 和 $\\hat{c}_{s,j}$ 位置之间的所有费米子模式，$n_{k}^{(\\text{mode})}$ 是占据数（根据排序可以是质子模式或中子模式）。\n\n3. 通过比较交错排序和分块排序之间的 JW 符号，并将其差异与算符未作用的种类联系起来，来量化长程 MPO 中由排序引起的相位抵消。具体来说，计算严格位于晶格位点 $i$ 和 $j$ 之间的“另一类”粒子占据数的奇偶性，记为\n$$\n\\Delta_{s;i,j} = \\sum_{k=\\min(i,j)+1}^{\\max(i,j)-1} n_k^{(\\bar{s})} \\quad \\text{mod } 2,\n$$\n其中 $\\bar{s}$ 表示与 $s$ 相对的种类。返回整数 $\\Delta_{s;i,j} \\in \\{0,1\\}$。然后，通过返回一个布尔值来检验在交错排序和分块排序下获得的宇称串符号是否与这些跨种类交叉所暗示的抵消一致，当且仅当等式\n$$\n\\mathrm{JW\\_sign}^{(\\text{interleaved})} = \\mathrm{JW\\_sign}^{(\\text{block})} \\times (-1)^{\\Delta_{s;i,j}}\n$$\n成立时，该布尔值为真。\n\n使用以下测试套件。所有索引 $i,j$ 都是基于 1 的晶格索引，所有占据数 $n^{(p)}_\\ell, n^{(n)}_\\ell$ 都是 $\\{0,1\\}$ 中的整数。\n\n- 测试用例 1（长程质子跃迁，奇数次跨种类交叉）：\n    - $L = 4$，$s = p$，$i = 1$，$j = 4$。\n    - 质子占据数：$\\mathbf{n}^{(p)} = (0,1,0,1)$。\n    - 中子占据数：$\\mathbf{n}^{(n)} = (0,1,0,0)$。\n- 测试用例 2（长程中子跃迁，偶数次跨种类交叉）：\n    - $L = 4$，$s = n$，$i = 2$，$j = 4$。\n    - 质子占据数：$\\mathbf{n}^{(p)} = (1,0,0,1)$。\n    - 中子占据数：$\\mathbf{n}^{(n)} = (1,0,1,0)$。\n- 测试用例 3（逆序质子跃迁，奇数次跨种类交叉）：\n    - $L = 4$，$s = p$，$i = 3$，$j = 1$。\n    - 质子占据数：$\\mathbf{n}^{(p)} = (0,0,1,0)$。\n    - 中子占据数：$\\mathbf{n}^{(n)} = (0,1,1,0)$。\n- 测试用例 4（最近邻质子跃迁，零次跨种类交叉）：\n    - $L = 4$，$s = p$，$i = 2$，$j = 3$。\n    - 质子占据数：$\\mathbf{n}^{(p)} = (1,0,1,0)$。\n    - 中子占据数：$\\mathbf{n}^{(n)} = (0,0,1,1)$。\n\n您的程序应生成单行输出，其中包含以下九个结果，形式为用方括号括起来的逗号分隔列表：\n\n- 费米子交换张量作用的布尔验证结果。\n- 四个布尔值，每个测试用例一个，表示在由“另一类”粒子交叉的奇偶性 $\\Delta_{s;i,j}$ 补偿后，交错排序和分块排序之间的 JW 符号等式是否成立。\n- 四个整数 $\\Delta_{s;i,j}$，对应于各测试用例，顺序与相应的布尔值相同。\n\n例如，最终输出格式必须为：\n$[b_{\\text{swap}}, b_1, b_2, b_3, b_4, d_1, d_2, d_3, d_4]$,\n其中每个 $b$ 是一个布尔值，每个 $d$ 是 $\\{0,1\\}$ 中的一个整数。",
            "solution": "用户提供了一个计算核物理领域的多部分问题，具体涉及张量网络框架内费米子算符的表示。我将首先验证问题陈述，如果有效，则提供一个完整的解决方案。\n\n### 第 1 步：提取给定信息\n-   **系统**：一个由 $L$ 个核位点组成的一维晶格。\n-   **局域希尔伯特空间**：每个位点承载两种费米子（质子 $p$，中子 $n$），局域 Fock 空间有四个状态：$\\lvert 0 \\rangle$、$\\lvert p \\rangle$、$\\lvert n \\rangle$、$\\lvert pn \\rangle$。\n-   **费米子算符**：位于位点 $i \\in \\{1,\\dots,L\\}$ 的种类 $s \\in \\{p,n\\}$ 的产生 ($\\hat{c}_{s,i}^\\dagger$) 和湮灭 ($\\hat{c}_{s,i}$) 算符。\n-   **正则反对易关系 (CAR)**：$\\{ \\hat{c}_{s,i}, \\hat{c}_{s',j}^\\dagger \\} = \\delta_{s,s'} \\delta_{ij}$ 且 $\\{ \\hat{c}_{s,i}, \\hat{c}_{s',j} \\} = \\{ \\hat{c}_{s,i}^\\dagger, \\hat{c}_{s',j}^\\dagger \\} = 0$。\n-   **宇称**：某个模式上的宇称算符的本征值为 $(-1)^{\\hat{n}}$，其中 $\\hat{n}$ 是粒子数算符。\n-   **Jordan-Wigner (JW) 排序**：\n    -   交错排序：费米子模式排序为 $\\left[ p_1, n_1, p_2, n_2, \\dots, p_L, n_L \\right]$。\n    -   分块排序：模式排序为 $\\left[ p_1, p_2, \\dots, p_L, n_1, n_2, \\dots, n_L \\right]$。\n-   **费米子交换张量 ($\\hat{S}$) 的作用**：对于两个无自旋费米子模式，其在占据数基 $\\{\\lvert 00 \\rangle, \\lvert 01 \\rangle, \\lvert 10 \\rangle, \\lvert 11 \\rangle\\}$ 上的作用定义为：\n    -   $\\hat{S} \\lvert 00 \\rangle = \\lvert 00 \\rangle$\n    -   $\\hat{S} \\lvert 01 \\rangle = \\lvert 10 \\rangle$\n    -   $\\hat{S} \\lvert 10 \\rangle = \\lvert 01 \\rangle$\n    -   $\\hat{S} \\lvert 11 \\rangle = - \\lvert 11 \\rangle$\n-   **跃迁算符**：对于 $i \\neq j$ 的 $\\hat{O}_{s;i \\rightarrow j} = \\hat{c}_{s,i}^\\dagger \\hat{c}_{s,j}$。\n-   **JW 符号定义**：符号由 $\\mathrm{JW\\_sign} = (-1)^{\\sum_{k \\in \\text{between}(i,j)} n_{k}^{(\\text{mode})}}$ 给出，其中求和包含在指定的 JW 排序中，严格位于与 $\\hat{c}_{s,i}^\\dagger$ 和 $\\hat{c}_{s,j}$ 对应的模式之间的所有费米子模式的占据数。\n-   **另一类粒子交叉奇偶性**：该量定义为 $\\Delta_{s;i,j} = \\left(\\sum_{k=\\min(i,j)+1}^{\\max(i,j)-1} n_k^{(\\bar{s})}\\right) \\pmod 2$，其中 $\\bar{s}$ 是 $s$ 以外的种类。\n-   **一致性关系**：待检验的等式是 $\\mathrm{JW\\_sign}^{(\\text{interleaved})} = \\mathrm{JW\\_sign}^{(\\text{block})} \\times (-1)^{\\Delta_{s;i,j}}$。\n-   **测试用例**：提供了四个具体用例，包含参数 $L, s, i, j$ 和占据数向量 $\\mathbf{n}^{(p)}, \\mathbf{n}^{(n)}$。\n\n### 第 2 步：使用提取的给定信息进行验证\n-   **科学基础**：该问题基于量子力学（费米子统计）的公认原理以及计算多体物理（Jordan-Wigner 变换、张量网络）中的标准技术。定义和概念在该领域是标准的。该问题在科学上是合理的。\n-   **适定性**：问题结构清晰，分为三个不同的任务。对于每个任务，都提供了所有必需的定义、公式和输入数据。计算是确定性的，确保了唯一解。目标陈述明确：验证交换张量矩阵，计算 JW 符号，计算 $\\Delta$，并检验给定的等式。问题是适定的。\n-   **客观性**：问题使用精确、客观和数学化的语言陈述。没有主观或含糊的术语。\n-   **完整性和一致性**：给出了测试用例的所有必要参数。排序、JW 符号和 $\\Delta$ 的定义是自洽的，足以用于实现。对这些定义的仔细分析表明，就所需计算而言，它们是内部一致的。\n\n### 第 3 步：结论和行动\n问题被判定为**有效**。这是一个适定的、有科学依据的问题，可以根据所提供的信息通过算法解决。我现在将开始提供解决方案。\n\n### 基于原理的设计\n解决方案分三部分实现，对应于问题陈述中指定的任务。\n\n**第 1 部分：费米子交换张量验证**\n线性算符 $\\hat{S}$ 在双模式系统的四个基态 $\\{\\lvert 00 \\rangle, \\lvert 01 \\rangle, \\lvert 10 \\rangle, \\lvert 11 \\rangle\\}$ 上的作用是给定的。我们可以将这些基态表示为 $\\mathbb{C}^4$ 中的标准正交向量，例如，使用计算基：$\\lvert 00 \\rangle \\to [1, 0, 0, 0]^T$，$\\lvert 01 \\rangle \\to [0, 1, 0, 0]^T$ 等。$\\hat{S}$ 的矩阵表示可以根据其在该基上的定义作用来构造。矩阵的列是基向量的像。\n-   $\\hat{S}\\lvert 00 \\rangle = \\lvert 00 \\rangle \\implies \\text{第1列} = [1, 0, 0, 0]^T$\n-   $\\hat{S}\\lvert 01 \\rangle = \\lvert 10 \\rangle \\implies \\text{第2列} = [0, 0, 1, 0]^T$\n-   $\\hat{S}\\lvert 10 \\rangle = \\lvert 01 \\rangle \\implies \\text{第3列} = [0, 1, 0, 0]^T$\n-   $\\hat{S}\\lvert 11 \\rangle = -\\lvert 11 \\rangle \\implies \\text{第4列} = [0, 0, 0, -1]^T$\n这给出了交换算符的矩阵表示：\n$$\nS = \\begin{pmatrix} 1  0  0  0 \\\\ 0  0  1  0 \\\\ 0  1  0  0 \\\\ 0  0  0  -1 \\end{pmatrix}\n$$\n验证过程包括将此矩阵 $S$ 应用于四个基向量中的每一个，并核实结果是否与定义的变换相匹配。当且仅当所有四个变换都正确再现时，返回布尔值 `True`。\n\n**第 2 部分：Jordan-Wigner 符号计算**\n算符 $\\hat{c}_{s,i}^\\dagger \\hat{c}_{s,j}$ 的 JW 符号取决于在所选的一维排序中，位于模式 $(s,i)$ 和 $(s,j)$ 位置之间的已占据费米子模式总数的奇偶性。此任务的核心是：\n1.  为‘交错’和‘分块’两种排序构建所有 $2L$ 个费米子模式的有序列表。\n2.  对于给定的算符 $\\hat{c}_{s,i}^\\dagger \\hat{c}_{s,j}$，识别出特定的模式 $(s,i)$ 和 $(s,j)$。\n3.  在有序列表中找到这两个模式的索引（位置）。\n4.  遍历索引严格位于这两个位置之间的所有模式。\n5.  对这些中间模式的占据数求和。占据数在测试用例数据中提供。\n6.  JW 符号是 $(-1)$ 的这个总和次方。\n\n此过程在一个函数中实现，该函数接受系统参数和排序类型作为输入，并返回计算出的 JW 符号（$+1$ 或 $-1$）。\n\n**第 3 部分：另一类粒子交叉奇偶性与一致性检查**\n这部分涉及两项计算：\n1.  **计算 $\\Delta_{s;i,j}$**：这是严格位于晶格位点 $i$ 和 $j$ 之间的“另一”种类 $\\bar{s}$ 的已占据位点数的奇偶性。求和遍及位点索引 $k$，使得 $\\min(i,j)  k  \\max(i,j)$。结果是一个整数，$0$ 或 $1$。\n2.  **检验等式**：问题假定了来自两种不同排序的 JW 符号之间存在一个关系：$\\mathrm{JW\\_sign}^{(\\text{interleaved})} = \\mathrm{JW\\_sign}^{(\\text{block})} \\times (-1)^{\\Delta_{s;i,j}}$。在计算出两个 JW 符号和 $\\Delta_{s;i,j}$ 后，检验此等式。如果等式成立，则返回布尔值 `True`，否则返回 `False`。\n\n主程序对提供的四个测试用例中的每一个执行这些步骤，收集交换张量验证的布尔结果、一致性检查的四个布尔结果以及 $\\Delta_{s;i,j}$ 的四个整数值。然后将这九个值格式化为所需的输出字符串。实现中使用基于 0 的数组索引，并小心地从问题陈述中用于晶格位点的基于 1 的索引进行转换。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, validate the swap tensor,\n    and process all test cases for JW sign analysis.\n    \"\"\"\n\n    def validate_swap_tensor():\n        \"\"\"\n        Validates the fermionic swap tensor S by checking its action on the 4 basis states.\n        \"\"\"\n        # Basis states |00, |01, |10, |11 in the computational basis\n        basis = [\n            np.array([1, 0, 0, 0]),  # |00\n            np.array([0, 1, 0, 0]),  # |01\n            np.array([0, 0, 1, 0]),  # |10\n            np.array([0, 0, 0, 1])   # |11\n        ]\n        \n        # Expected outcomes S|00=|00, S|01=|10, S|10=|01, S|11=-|11\n        expected_outcomes = [\n            basis[0],       # |00\n            basis[2],       # |10\n            basis[1],       # |01\n            -1 * basis[3]   # -|11\n        ]\n\n        # The fermionic swap tensor S as a matrix\n        S = np.array([\n            [1, 0, 0, 0],\n            [0, 0, 1, 0],\n            [0, 1, 0, 0],\n            [0, 0, 0, -1]\n        ])\n\n        for i in range(4):\n            v_in = basis[i]\n            v_out_actual = S @ v_in\n            v_out_expected = expected_outcomes[i]\n            if not np.allclose(v_out_actual, v_out_expected):\n                return False\n                \n        return True\n\n    def get_jw_sign(L, s, op_i, op_j, np_occ, nn_occ, ordering):\n        \"\"\"\n        Computes the Jordan-Wigner string sign for a given operator and ordering.\n        \"\"\"\n        # Problem uses 1-based site indices, convert to 0-based for arrays\n        site_i, site_j = op_i - 1, op_j - 1\n        \n        # Create the ordered list of all 2L fermionic modes\n        modes = []\n        if ordering == 'interleaved':\n            for k in range(L):\n                modes.append(('p', k))\n                modes.append(('n', k))\n        elif ordering == 'block':\n            for k in range(L):\n                modes.append(('p', k))\n            for k in range(L):\n                modes.append(('n', k))\n        \n        # Create a mapping from mode to occupation number for easy lookup\n        occupations = {}\n        for k in range(L):\n            occupations[('p', k)] = np_occ[k]\n            occupations[('n', k)] = nn_occ[k]\n            \n        # Find the positions of the operator's modes in the ordered list\n        mode_i = (s, site_i)\n        mode_j = (s, site_j)\n        pos_i = modes.index(mode_i)\n        pos_j = modes.index(mode_j)\n        \n        start_idx = min(pos_i, pos_j) + 1\n        end_idx = max(pos_i, pos_j)\n        \n        # Sum occupations of all modes strictly between the two operator modes\n        occupation_sum = 0\n        for k in range(start_idx, end_idx):\n            mode_k = modes[k]\n            occupation_sum += occupations[mode_k]\n            \n        return (-1)**occupation_sum\n\n    def get_delta(s, op_i, op_j, np_occ, nn_occ):\n        \"\"\"\n        Computes the parity of the count of the \"other species\" occupations.\n        \"\"\"\n        s_bar = 'n' if s == 'p' else 'p'\n        occ_bar = nn_occ if s_bar == 'n' else np_occ\n        \n        # Sum occupations of the other species strictly between sites i and j.\n        # The problem statement uses 1-based indices for the sum range.\n        start_site_1based = min(op_i, op_j) + 1\n        end_site_1based = max(op_i, op_j)\n        \n        delta_sum = 0\n        # Convert 1-based site indices to 0-based array indices for slicing\n        for k_1based in range(start_site_1based, end_site_1based):\n            delta_sum += occ_bar[k_1based - 1]\n        \n        return delta_sum % 2\n\n    # Part 1: Validate the swap tensor\n    b_swap = validate_swap_tensor()\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'L': 4, 's': 'p', 'i': 1, 'j': 4, 'np': (0, 1, 0, 1), 'nn': (0, 1, 0, 0)},\n        {'L': 4, 's': 'n', 'i': 2, 'j': 4, 'np': (1, 0, 0, 1), 'nn': (1, 0, 1, 0)},\n        {'L': 4, 's': 'p', 'i': 3, 'j': 1, 'np': (0, 0, 1, 0), 'nn': (0, 1, 1, 0)},\n        {'L': 4, 's': 'p', 'i': 2, 'j': 3, 'np': (1, 0, 1, 0), 'nn': (0, 0, 1, 1)},\n    ]\n\n    bool_results = []\n    delta_results = []\n\n    # Parts 2  3: Process each test case\n    for case in test_cases:\n        L, s, i, j, np_occ, nn_occ = case['L'], case['s'], case['i'], case['j'], case['np'], case['nn']\n        \n        jw_sign_interleaved = get_jw_sign(L, s, i, j, np_occ, nn_occ, 'interleaved')\n        jw_sign_block = get_jw_sign(L, s, i, j, np_occ, nn_occ, 'block')\n        \n        delta = get_delta(s, i, j, np_occ, nn_occ)\n        delta_results.append(delta)\n        \n        # Test the equality relation\n        # sign_from_delta = (-1)**delta\n        # relation_holds = (jw_sign_interleaved == jw_sign_block * sign_from_delta)\n        # Using np.isclose for robust comparison\n        relation_holds = np.isclose(jw_sign_interleaved, jw_sign_block * ((-1)**delta))\n        bool_results.append(bool(relation_holds))\n\n    # Combine all results into a single list for printing\n    all_results = [b_swap] + bool_results + delta_results\n\n    # Final print statement in the exact required format.\n    # str() of a Python bool is 'True' or 'False'\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实践中，DMRG 算法的收敛速度对轨道的一维排列顺序高度敏感。一个好的排序策略能够最小化 MPS 各键上的纠缠（通过互信息来量化），从而控制所需的键维数。通过一个实际（尽管是简化的）原子核模型，本练习让您能够计算探索并比较不同的轨道排序策略。您将学习如何量化纠缠代价并预测其对算法性能的影响，这是进行大规模实际模拟的一项至关重要的技能 ()。",
            "id": "3593587",
            "problem": "考虑一个原子核壳模型问题，其中的单粒子轨道被划分为质子轨道和中子轨道。多体态由矩阵乘积态 (MPS) 表示，优化过程使用密度矩阵重整化群 (DMRG) 方法进行。轨道排序对 DMRG 收敛性的影响，是由跨越 MPS 键的双体纠缠所介导的，这种纠缠通过轨道间的互信息来量化。您的任务是实现并比较多种排序策略，这些策略通过交错排列质子和中子轨道来最小化跨同位旋的互信息，并量化其对 DMRG 扫描次数的预测影响。\n\n使用以下基本定义和近似：\n\n- 具有密度算符 $\\hat{\\rho}$ 的子系统的约化密度矩阵，其冯·诺伊曼熵为 $S = -\\mathrm{Tr}\\left(\\hat{\\rho}\\ln \\hat{\\rho}\\right)$。\n- 对于两个子系统 $A$ 和 $B$，互信息为 $I(A:B) = S(A) + S(B) - S(AB)$。\n- 在单轨道占据数的高斯涨落近似下，轨道 $i$ 和 $j$ 之间的成对互信息通过相关系数 $\\rho_{ij}$ 建模为\n$$\nI(i:j) = -\\frac{1}{2}\\ln\\left(1 - \\rho_{ij}^{2}\\right),\n$$\n其中 $\\rho_{ij}$ 取为\n$$\n\\rho_{ij} = \\Lambda \\exp\\!\\left(-\\frac{|E_i - E_j|}{\\Delta}\\right)\\times\n\\begin{cases}\ns,  \\text{若 } \\tau_i = \\tau_j,\\\\\nc,  \\text{若 } \\tau_i \\neq \\tau_j,\n\\end{cases}\n$$\n其中 $E_i$ 是轨道 $i$ 的单粒子能量（单位：兆电子伏特），$\\tau_i \\in \\{\\text{质子}, \\text{中子}\\}$ 是其同位旋类型，$\\Lambda$ 是无量纲的相互作用尺度，$\\Delta$ 是能量尺度（单位：兆电子伏特），$s$ 和 $c$ 分别是无量纲的同类同位旋和交叉同位旋相关因子。所有互信息值 $I(i:j)$ 均为无量纲。\n\n对于 $N$ 个轨道的一个序列（排序）$\\mathcal{O} = (o_1,o_2,\\dots,o_N)$，定义以下依赖于排序的量：\n\n- 交叉同位旋相邻互信息代价\n$$\nC(\\mathcal{O}) = \\sum_{k=1}^{N-1} \\mathbf{1}_{\\tau_{o_k} \\neq \\tau_{o_{k+1}}}\\; I(o_k:o_{k+1}),\n$$\n其中，如果条件 $X$ 为真，则 $\\mathbf{1}_{X}$ 等于 $1$，否则等于 $0$。\n\n- 最大相邻互信息\n$$\nM(\\mathcal{O}) = \\max_{1 \\le k \\le N-1} I(o_k:o_{k+1})。\n$$\n\n使用以下启发式模型来预测在给定排序 $\\mathcal{O}$ 下，达到固定截断误差目标所需的 DMRG 扫描次数：\n$$\nS(\\mathcal{O}) = \\left\\lceil S_0 + \\alpha\\, M(\\mathcal{O}) + \\beta\\, C(\\mathcal{O}) \\right\\rceil,\n$$\n其中 $S_0$ 是一个基准（无量纲）扫描计数，$\\alpha$ 和 $\\beta$ 是无量纲的正系数。最终预测的扫描次数 $S(\\mathcal{O})$ 是一个无量纲整数。\n\n在同一组轨道上实现并比较以下排序策略：\n- 按同位旋分组排序：首先放置所有质子轨道（按能量升序），然后放置所有中子轨道（按能量升序）。\n- 严格交错排序：根据输入索引顺序交替排列质子和中子轨道，即当数量允许精确交替时，形式为 $(p_1,n_1,p_2,n_2,\\dots)$。\n- 优化排序：在所有轨道排列中，选择使 $C(\\mathcal{O})$ 最小化的排序 $\\mathcal{O}^{\\star}$，并使用进一步最小化 $M(\\mathcal{O})$ 作为决胜规则。\n\n对于下方的每个测试用例，计算：\n- 分组排序、交错排序和优化排序的 $C$ 值。\n- 分组排序、交错排序和优化排序的 $S$ 值。\n\n所有能量均以兆电子伏特 (MeV) 表示。所有互信息量必须使用自然对数计算，并且是无量纲的。不使用角度单位。最终的扫描次数是无量纲的，并且必须是整数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个条目是针对一个测试用例的列表，形式为 $[C_{\\mathrm{grp}},C_{\\mathrm{int}},C_{\\mathrm{opt}},S_{\\mathrm{grp}},S_{\\mathrm{int}},S_{\\mathrm{opt}}]$。对 $C$ 使用浮点数，对 $S$ 使用整数。\n\n对所有测试用例使用以下参数：\n- 基准和系数：$S_0 = 2$，$\\alpha = 10$，$\\beta = 6$。\n\n测试套件：\n- 测试用例 1 (正常路径)：\n    - 质子能量 (MeV)：$[-8.0,-6.5,-5.0,-3.5]$。\n    - 中子能量 (MeV)：$[-8.2,-6.8,-5.1,-3.6]$。\n    - 参数：$\\Lambda = 0.4$，$\\Delta = 2.0$ (MeV)，$s = 1.0$，$c = 0.3$。\n- 测试用例 2 (边界情况，交叉同位旋相关性消失)：\n    - 质子能量 (MeV)：$[-7.9,-6.7,-5.3,-3.8]$。\n    - 中子能量 (MeV)：$[-8.1,-6.9,-5.2,-3.7]$。\n    - 参数：$\\Lambda = 0.6$，$\\Delta = 1.5$ (MeV)，$s = 1.0$，$c = 0.0$。\n- 测试用例 3 (边缘情况，轨道较少且交叉同位旋相关性强)：\n    - 质子能量 (MeV)：$[-9.0,-8.8,-8.6]$。\n    - 中子能量 (MeV)：$[-9.1,-8.9,-8.7]$。\n    - 参数：$\\Lambda = 0.7$，$\\Delta = 3.0$ (MeV)，$s = 0.8$，$c = 0.7$。\n\n您的程序必须计算三种排序策略所需的量，并将所有测试用例的结果打印在单行中，格式为一个用方括号括起来的逗号分隔列表，例如 $[[\\dots],[\\dots],[\\dots]]$。所有 $C$ 值必须报告为四舍五入到六位小数的浮点数，所有 $S$ 值必须为整数。不得打印任何额外文本。",
            "solution": "用户提供的问题已经过分析，并被认为是有效的。这是一个在原子核物理学领域内定义明确的计算问题，提供了所有必要的参数、模型和定义。其前提对于一个建模练习来说在科学上是合理的，并且计算任务是可行的。\n\n以下是推理得出的解决方案：\n\n该问题要求我们评估三种不同的策略，用于在原子核壳模型计算中对质子和中子单粒子轨道进行排序，目标是改善密度矩阵重整化群 (DMRG) 算法的收敛性。\n\n排序的有效性通过一个启发式模型来量化，该模型根据序列中相邻轨道之间的互信息来预测所需的 DMRG 扫描次数。\n\n首先，我们对所提供的物理和数学模型进行形式化处理。轨道由其单粒子能量 $E_i$ 和同位旋类型 $\\tau_i \\in \\{\\text{质子}, \\text{中子}\\}$ 来表征。任意两个轨道 $i$ 和 $j$ 之间的纠缠由互信息 $I(i:j)$ 近似表示，该互信息源自高斯涨落模型：\n$$\nI(i:j) = -\\frac{1}{2}\\ln\\left(1 - \\rho_{ij}^{2}\\right)\n$$\n相关系数 $\\rho_{ij}$ 取决于轨道的能量间隔和同位旋类型：\n$$\n\\rho_{ij} = \\Lambda \\exp\\!\\left(-\\frac{|E_i - E_j|}{\\Delta}\\right)\\times\n\\begin{cases}\ns,  \\text{若 } \\tau_i = \\tau_j \\\\\nc,  \\text{若 } \\tau_i \\neq \\tau_j\n\\end{cases}\n$$\n这里，$\\Lambda$ 是相互作用尺度，$\\Delta$ 是能量尺度，$s$ 是同类同位旋相关因子，$c$ 是交叉同位旋相关因子。为了使对数有明确定义，我们必须有 $|\\rho_{ij}|  1$。所提供的参数在所有测试用例中都满足此条件。\n\n对于所有 $N$ 个轨道的一个给定排序 $\\mathcal{O} = (o_1, o_2, \\dots, o_N)$，我们定义两个代价指标：\n1.  **交叉同位旋相邻互信息代价**，$C(\\mathcal{O})$，它仅对具有不同同位旋的相邻轨道对的互信息求和。这个量衡量了沿着一维 MPS 链在质子和中子子系统之间切换的总纠缠代价。\n    $$\n    C(\\mathcal{O}) = \\sum_{k=1}^{N-1} \\mathbf{1}_{\\tau_{o_k} \\neq \\tau_{o_{k+1}}}\\; I(o_k, o_{k+1})\n    $$\n2.  **最大相邻互信息**，$M(\\mathcal{O})$，它是排序中任何单个“键”（相邻对）上的最大互信息。这个量是 MPS 所需的最大键维度的代理，是 DMRG 性能的一个关键决定因素。\n    $$\n    M(\\mathcal{O}) = \\max_{1 \\le k \\le N-1} I(o_k, o_{k+1})\n    $$\n\n预测的 DMRG 扫描次数 $S(\\mathcal{O})$ 由以下启发式公式给出：\n$$\nS(\\mathcal{O}) = \\left\\lceil S_0 + \\alpha M(\\mathcal{O}) + \\beta C(\\mathcal{O}) \\right\\rceil\n$$\n其中 $S_0$、$\\alpha$ 和 $\\beta$ 是给定的正常数。向上取整函数 $\\lceil \\cdot \\rceil$ 确保结果是整数次扫描。\n\n我们的中心任务是实现并评估三种排序策略：\n\n1.  **按同位旋分组排序 ($\\mathcal{O}_{\\mathrm{grp}}$)**：此策略首先放置所有质子轨道，按能量升序排序，然后放置所有中子轨道，也按能量升序排序。这种排序将同位旋转换的次数最小化（仅在质子-中子边界处有一次），通常会导致非常低的 $C(\\mathcal{O})$。然而，这可能会在两个区块之间产生一个单一的、高度纠缠的“壁垒”，可能导致较大的 $M(\\mathcal{O})$。\n\n2.  **严格交错排序 ($\\mathcal{O}_{\\mathrm{int}}$)**：此策略在质子和中子轨道之间交替，按其能量升序排列。对于 $N_p$ 个质子和 $N_n$ 个中子（在测试用例中 $N_p=N_n$），排序为 $(p_1, n_1, p_2, n_2, \\dots, p_{N_p}, n_{N_p})$。这会最大化同位旋转换的次数，将交叉同位旋纠缠分布在许多键上。这可能会增加 $C(\\mathcal{O})$，但可以减少最大纠缠 $M(\\mathcal{O})$。\n\n3.  **优化排序 ($\\mathcal{O}_{\\mathrm{opt}}$)**：此策略寻求轨道的全局最优排列，以最小化 $C(\\mathcal{O})$ 为主要目标，以最小化 $M(\\mathcal{O})$ 为次要的决胜目标。对于测试用例中少量轨道（$N=8$ 和 $N=6$），通过对所有 $N!$ 个排列进行穷举搜索，这种优化在计算上是可行的。\n\n每个测试用例的算法步骤如下：\n1.  首先，我们汇集一个包含所有轨道的统一列表，存储它们的能量 $E_i$、同位旋 $\\tau_i$ 和一个唯一的整数索引 $i \\in \\{0, \\dots, N-1\\}$。\n2.  为了避免冗余计算，我们预先计算一个完整的 $N \\times N$ 矩阵，其中条目 $(i,j)$ 是成对互信息 $I(i,j)$。\n3.  我们根据定义将“分组”和“交错”排序构建为轨道索引的列表。\n4.  我们通过使用 `itertools.permutations` 函数遍历轨道索引的所有排列来找到“优化”排序。对于每个排列，我们计算其 $C$ 和 $M$ 代价，并记录下能够按字典序最小化对 $(C, M)$ 的排列。\n5.  最后，对于三个得到的排序（$\\mathcal{O}_{\\mathrm{grp}}$, $\\mathcal{O}_{\\mathrm{int}}$, $\\mathcal{O}_{\\mathrm{opt}}$）中的每一个，我们计算它们各自的代价 $C$ 和 $M$，然后使用启发式公式计算预测的扫描次数 $S$。最终结果按规定进行四舍五入和格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\nimport math\n\n# Global parameters from the problem statement for the heuristic model\nS0 = 2.0\nalpha = 10.0\nbeta = 6.0\n\ndef calculate_mutual_information(E1, tau1, E2, tau2, Lambda, Delta, s, c):\n    \"\"\"\n    Calculates the pairwise mutual information between two orbitals.\n    \"\"\"\n    delta_E = abs(E1 - E2)\n    corr_factor = s if tau1 == tau2 else c\n    rho_sq = (Lambda * np.exp(-delta_E / Delta) * corr_factor)**2\n    # The problem constraints ensure 1 - rho_sq > 0, so no log(0) or log(-ve) issues.\n    if 1.0 - rho_sq = 0:\n        return float('inf') # Should not happen with given parameters\n    return -0.5 * np.log(1.0 - rho_sq)\n\ndef calculate_costs(ordering, orbitals, I_matrix):\n    \"\"\"\n    Calculates the C and M costs for a given orbital ordering.\n    \"\"\"\n    cost_C = 0.0\n    cost_M = 0.0\n    for k in range(len(ordering) - 1):\n        id1 = ordering[k]\n        id2 = ordering[k+1]\n        I_val = I_matrix[id1, id2]\n        if orbitals[id1]['tau'] != orbitals[id2]['tau']:\n            cost_C += I_val\n        if I_val > cost_M:\n            cost_M = I_val\n    return cost_C, cost_M\n\ndef calculate_sweeps(C, M):\n    \"\"\"\n    Calculates the predicted number of DMRG sweeps.\n    \"\"\"\n    raw_sweeps = S0 + alpha * M + beta * C\n    return math.ceil(raw_sweeps)\n\ndef solve_case(p_energies, n_energies, Lambda, Delta, s, c):\n    \"\"\"\n    Processes a single test case to find C and S for all three orderings.\n    \"\"\"\n    # 1. Create a unified list of orbitals with their properties.\n    # The index in this list serves as the unique ID for each orbital.\n    orbitals = []\n    # Proton orbitals are sorted by energy as per problem description\n    for E in sorted(p_energies):\n        orbitals.append({'E': E, 'tau': 'p'})\n    # Neutron orbitals are sorted by energy as per problem description\n    for E in sorted(n_energies):\n        orbitals.append({'E': E, 'tau': 'n'})\n    \n    num_protons = len(p_energies)\n    num_orbitals = len(orbitals)\n\n    # 2. Pre-compute the full pairwise mutual information matrix.\n    I_matrix = np.zeros((num_orbitals, num_orbitals))\n    for i in range(num_orbitals):\n        for j in range(i, num_orbitals):\n            val = calculate_mutual_information(\n                orbitals[i]['E'], orbitals[i]['tau'],\n                orbitals[j]['E'], orbitals[j]['tau'],\n                Lambda, Delta, s, c\n            )\n            I_matrix[i, j] = val\n            I_matrix[j, i] = val\n\n    # 3. Construct the orderings (as lists of orbital indices).\n    p_indices = list(range(num_protons))\n    n_indices = list(range(num_protons, num_orbitals))\n\n    # Grouped ordering: (p1, p2, ..., n1, n2, ...)\n    O_grp = p_indices + n_indices\n\n    # Interleaved ordering: (p1, n1, p2, n2, ...)\n    O_int = []\n    for p_idx, n_idx in zip(p_indices, n_indices):\n        O_int.extend([p_idx, n_idx])\n\n    # Optimized ordering: Exhaustive search over all permutations.\n    min_C = float('inf')\n    min_M_for_min_C = float('inf')\n    O_opt = []\n    \n    all_indices = list(range(num_orbitals))\n    for p in itertools.permutations(all_indices):\n        current_C, current_M = calculate_costs(p, orbitals, I_matrix)\n        \n        # Primary criterion: minimize C. Secondary: minimize M.\n        if current_C  min_C - 1e-9: # Use tolerance for float comparison\n            min_C = current_C\n            min_M_for_min_C = current_M\n            O_opt = list(p)\n        elif abs(current_C - min_C)  1e-9 and current_M  min_M_for_min_C - 1e-9:\n            min_M_for_min_C = current_M\n            O_opt = list(p)\n\n    # 4. Calculate costs and sweeps for each ordering.\n    C_grp, M_grp = calculate_costs(O_grp, orbitals, I_matrix)\n    S_grp = calculate_sweeps(C_grp, M_grp)\n    \n    C_int, M_int = calculate_costs(O_int, orbitals, I_matrix)\n    S_int = calculate_sweeps(C_int, M_int)\n    \n    # For the optimized ordering, costs were found during the search.\n    C_opt, M_opt = min_C, min_M_for_min_C\n    S_opt = calculate_sweeps(C_opt, M_opt)\n\n    return [\n        round(C_grp, 6), round(C_int, 6), round(C_opt, 6),\n        S_grp, S_int, S_opt\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"p_energies\": [-8.0, -6.5, -5.0, -3.5],\n            \"n_energies\": [-8.2, -6.8, -5.1, -3.6],\n            \"params\": {\"Lambda\": 0.4, \"Delta\": 2.0, \"s\": 1.0, \"c\": 0.3}\n        },\n        # Test Case 2\n        {\n            \"p_energies\": [-7.9, -6.7, -5.3, -3.8],\n            \"n_energies\": [-8.1, -6.9, -5.2, -3.7],\n            \"params\": {\"Lambda\": 0.6, \"Delta\": 1.5, \"s\": 1.0, \"c\": 0.0}\n        },\n        # Test Case 3\n        {\n            \"p_energies\": [-9.0, -8.8, -8.6],\n            \"n_energies\": [-9.1, -8.9, -8.7],\n            \"params\": {\"Lambda\": 0.7, \"Delta\": 3.0, \"s\": 0.8, \"c\": 0.7}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(\n            case[\"p_energies\"],\n            case[\"n_energies\"],\n            **case[\"params\"]\n        )\n        results.append(result)\n\n    # Format the final output string as specified.\n    # The format [[...],[...],[...]] is achieved by `str(results)` and then removing spaces.\n    # A more robust way is to build the string manually.\n    outer_list = []\n    for res_list in results:\n        inner_list_parts = []\n        for i, item in enumerate(res_list):\n            if i  3: # C values are floats\n                inner_list_parts.append(f\"{item:.6f}\")\n            else: # S values are ints\n                inner_list_parts.append(str(item))\n        outer_list.append(f\"[{','.join(inner_list_parts)}]\")\n    \n    print(f\"[{','.join(outer_list)}]\")\n\nsolve()\n```"
        }
    ]
}