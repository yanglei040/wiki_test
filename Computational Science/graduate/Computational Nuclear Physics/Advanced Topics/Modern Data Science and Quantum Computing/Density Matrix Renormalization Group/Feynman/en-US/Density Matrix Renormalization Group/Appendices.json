{
    "hands_on_practices": [
        {
            "introduction": "The Density Matrix Renormalization Group (DMRG) algorithm's remarkable efficiency is intrinsically tied to the one-dimensional topology of the Matrix Product State ansatz. This exercise addresses the practical challenge of applying DMRG to higher-dimensional systems, like atomic nuclei, by exploring how to optimally map 3D orbitals onto a 1D chain. By quantifying the locality of interactions for different orderings, you will develop a crucial skill in setting up DMRG calculations for realistic physical problems, directly influencing the convergence and accuracy of your simulations .",
            "id": "3554798",
            "problem": "Consider a mapping of three-dimensional harmonic oscillator single-particle orbitals used in nuclear shell-model calculations onto a one-dimensional chain for a Density Matrix Renormalization Group (DMRG) algorithm. The goal is to design an ordering that minimizes effective coupling range along the chain by exploiting spatial locality. Starting from core definitions of the harmonic oscillator basis and a physically motivated short-range interaction, construct a program that quantifies how coupling magnitudes decay with chain distance for two distinct orderings: a spatially local ordering and an energy-ordered chain. Use the following specifications.\n\nFundamental base and definitions:\n- The three-dimensional harmonic oscillator has single-particle orbitals labeled by radial quantum number $n \\in \\{0,1,2,\\dots\\}$ and orbital angular momentum $l \\in \\{0,1,2,\\dots\\}$, with magnetic projection $m \\in \\{-l,-l+1,\\dots,l\\}$. The major shell quantum number is $N=2n+l$.\n- The harmonic oscillator energy is $E_{nl} = \\hbar \\omega \\left(2n + l + \\tfrac{3}{2}\\right)$, which is equivalently $E_{N} = \\hbar \\omega \\left(N + \\tfrac{3}{2}\\right)$.\n- The harmonic oscillator length parameter is $b$ (in femtometers), and the root-mean-square radius for a state in shell $N$ is approximated as $\\sqrt{\\langle r^{2}\\rangle_{N}} = b \\sqrt{N + \\tfrac{3}{2}}$.\n- Truncate the basis to $N \\leq N_{\\max}$ with the parity constraint that $n$ must be integer, i.e., $n = (N-l)/2$ must satisfy $N-l$ even.\n- The coupling between two orbitals $(n,l,m)$ and $(n',l',m')$ is modeled by a short-range central interaction of finite range $s$ (in femtometers), with an additional angular mismatch suppression. Define the centroid radii $R = b \\sqrt{N + \\tfrac{3}{2}}$ and $R' = b \\sqrt{N' + \\tfrac{3}{2}}$. The effective pairwise coupling weight is\n$$\nw_{ij} = \\exp\\!\\left(-\\frac{(R - R')^{2}}{2 s^{2}}\\right) \\exp\\!\\left(-\\alpha \\, |l - l'|\\right) \\exp\\!\\left(-\\beta \\, |m - m'|\\right),\n$$\nwhere $\\alpha$ and $\\beta$ are nonnegative dimensionless parameters that penalize angular momentum and magnetic projection mismatch, respectively. This form captures the physically motivated decay of overlap for finite-range interactions and reduced coupling for large angular mismatches.\n\nOrdering and chain distance:\n- Define a one-dimensional chain by assigning each orbital a position index according to an ordering rule.\n- The spatially local ordering sorts orbitals by ascending centroid radius $R$, then by ascending $l$, then by ascending $m$.\n- The energy ordering sorts orbitals by ascending energy $E_{N}$, then by descending $m$, then by descending $l$.\n- The chain distance between orbitals $i$ and $j$ in an ordering is $d_{ij} = |p(i) - p(j)|$, where $p(i)$ is the position index of orbital $i$ in the chain.\n\nQuantities to compute for each ordering:\n- The total coupling weight $W_{\\mathrm{tot}} = \\sum_{i<j} w_{ij}$ over unordered distinct pairs.\n- The weighted effective coupling range\n$$\n\\overline{d} = \\frac{\\sum_{i<j} w_{ij} \\, d_{ij}}{\\sum_{i<j} w_{ij}}.\n$$\n- The nearest-neighbor coupling fraction\n$$\nf_{\\mathrm{NN}} = \\frac{\\sum_{i<j,\\, d_{ij} \\leq 1} w_{ij}}{\\sum_{i<j} w_{ij}}.\n$$\n- The Pearson correlation coefficient between coupling magnitude and chain distance, defined as\n$$\n\\rho = \\frac{\\operatorname{Cov}(d,w)}{\\sigma_{d} \\sigma_{w}},\n$$\nwhere $\\operatorname{Cov}(d,w)$ is the covariance of $\\{d_{ij}\\}$ and $\\{w_{ij}\\}$, and $\\sigma_{d}$ and $\\sigma_{w}$ are their standard deviations. If either variance vanishes, define $\\rho = 0$.\n\nComparison metrics for each test case:\n- The improvement ratio in weighted coupling range $I_{\\mathrm{range}} = \\overline{d}_{\\mathrm{spatial}} / \\overline{d}_{\\mathrm{energy}}$.\n- The correlation improvement $\\Delta \\rho = \\rho_{\\mathrm{spatial}} - \\rho_{\\mathrm{energy}}$.\n- The nearest-neighbor gain $G_{\\mathrm{NN}} = f_{\\mathrm{NN,\\, spatial}} / f_{\\mathrm{NN,\\, energy}}$.\n\nUnits and constants:\n- Use $b$ and $s$ in femtometers. The outputs are dimensionless floats. You may set $\\hbar \\omega = 1$ (arbitrary units) for the purpose of energy ordering.\n\nTest suite:\nImplement your program to evaluate the three metrics $(I_{\\mathrm{range}}, \\Delta \\rho, G_{\\mathrm{NN}})$ for the following parameter sets:\n- Case $1$: $N_{\\max} = 4$, $b = 1.7$ fm, $s = 1.7$ fm, $\\alpha = 0.6$, $\\beta = 0.2$.\n- Case $2$: $N_{\\max} = 2$, $b = 1.7$ fm, $s = 0.6$ fm, $\\alpha = 0.8$, $\\beta = 0.3$.\n- Case $3$: $N_{\\max} = 6$, $b = 1.7$ fm, $s = 3.4$ fm, $\\alpha = 0.5$, $\\beta = 0.1$.\n- Case $4$ (edge case coverage): $N_{\\max} = 1$, $b = 1.7$ fm, $s = 0.4$ fm, $\\alpha = 0.7$, $\\beta = 0.2$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, output the three floats in the order $(I_{\\mathrm{range}}, \\Delta \\rho, G_{\\mathrm{NN}})$, and aggregate them for all four cases into a flat list. For example, the final output should be of the form $[I_{1}, \\Delta \\rho_{1}, G_{\\mathrm{NN},1}, I_{2}, \\Delta \\rho_{2}, G_{\\mathrm{NN},2}, I_{3}, \\Delta \\rho_{3}, G_{\\mathrm{NN},3}, I_{4}, \\Delta \\rho_{4}, G_{\\mathrm{NN},4}]$.",
            "solution": "The design of a Density Matrix Renormalization Group (DMRG) mapping for nuclear shell-model orbitals onto a one-dimensional chain should begin from fundamental properties of the single-particle basis and the physics of inter-orbital couplings. The three-dimensional harmonic oscillator is the standard basis for nuclear mean-field calculations, characterized by discrete major shells indexed by $N = 2n + l$, where $n$ is the radial quantum number and $l$ is the orbital angular momentum. The harmonic oscillator energy spacings are given by $E_{nl} = \\hbar \\omega (2n + l + \\tfrac{3}{2})$, and the spatial extent of orbitals increases with $N$ through the root-mean-square (rms) radius $\\sqrt{\\langle r^{2}\\rangle_{N}} = b \\sqrt{N + \\tfrac{3}{2}}$, where $b$ is the oscillator length.\n\nThe Density Matrix Renormalization Group works most efficiently when the Hamiltonian couplings are short range along the chain index because truncation errors are reduced with locality, leading to lower entanglement across cuts. In a nuclear context, realistic residual interactions are finite range; a widely used approximation is to model them as central finite-range potentials, for which coupling magnitudes between two orbitals are governed by spatial overlap. For harmonic oscillator orbitals, whose densities can be approximated by Gaussians spread over a characteristic radius tied to $b$ and $N$, the overlap of two such localized distributions decays as a Gaussian in the separation of their centroids. Therefore, an idealized effective coupling weight between orbitals $(n,l,m)$ and $(n',l',m')$ can be modeled as\n$$\nw_{ij} = \\exp\\!\\left(-\\frac{(R - R')^{2}}{2 s^{2}}\\right),\n$$\nwhere $R = b \\sqrt{N + \\tfrac{3}{2}}$ and $R' = b \\sqrt{N' + \\tfrac{3}{2}}$ approximate the rms spatial extents, and $s$ is a finite interaction range parameter. This captures the fundamental physical principle that finite-range forces preferentially couple states with similar spatial extent.\n\nA more refined coupling should also account for angular momentum mismatches. The spherical central interactions tend to conserve orbital angular momentum in dominant channels, implying reduced coupling when $|l - l'|$ is large. Additionally, tensor and spin-orbit components introduce dependence on angular projections, which we crudely encode via a penalty on $|m - m'|$. A simple, dimensionless suppression is\n$$\nw_{ij} \\leftarrow w_{ij} \\times \\exp\\!\\left(-\\alpha\\,|l-l'|\\right) \\times \\exp\\!\\left(-\\beta\\,|m-m'|\\right),\n$$\nwith $\\alpha \\geq 0$ and $\\beta \\geq 0$. This parametric form enforces that states with similar $l$ and $m$ couple more strongly, consistent with physically motivated selection patterns, while maintaining the primary finite-range character via the Gaussian factor.\n\nTo evaluate the impact of ordering on DMRG locality, we map the set of orbitals to a one-dimensional chain by assigning positions $p(i)$ according to an ordering rule. Two reasonable orderings are:\n- Spatially local ordering: sort by ascending $R$, then by ascending $l$, then by ascending $m$. This seeks local adjacency in real space and in angular quantum numbers.\n- Energy ordering: sort by ascending $E_{N}$, then by descending $m$, then by descending $l$. This represents a conventional energy-first fill, but the tie-breaking intentionally disrupts spatial locality, creating a useful contrast.\n\nFor a given ordering, define the chain distance\n$$\nd_{ij} = |p(i) - p(j)|.\n$$\nWith pair weights $w_{ij}$, define the total weight\n$$\nW_{\\mathrm{tot}} = \\sum_{i<j} w_{ij}.\n$$\nThree quantitative indicators of locality are computed:\n1. The weighted effective coupling range\n$$\n\\overline{d} = \\frac{\\sum_{i<j} w_{ij} \\, d_{ij}}{\\sum_{i<j} w_{ij}},\n$$\nwhich penalizes long-range couplings and is minimized by local orderings.\n2. The nearest-neighbor fraction\n$$\nf_{\\mathrm{NN}} = \\frac{\\sum_{i<j,\\, d_{ij} \\leq 1} w_{ij}}{\\sum_{i<j} w_{ij}},\n$$\nwhich emphasizes how much of the interaction weight is captured by adjacent orbitals.\n3. The coupling-distance Pearson correlation coefficient\n$$\n\\rho = \\frac{\\operatorname{Cov}(d,w)}{\\sigma_{d} \\sigma_{w}},\n$$\nwhere $\\operatorname{Cov}(d,w)$ is the covariance of the sample $\\{(d_{ij}, w_{ij})\\}$ and $\\sigma_{d}$, $\\sigma_{w}$ are their standard deviations. A more negative $\\rho$ indicates that larger distances are more strongly associated with smaller couplings, which is desired.\n\nFor comparison between the spatially local and energy orderings, we compute:\n- The improvement ratio in effective range $I_{\\mathrm{range}} = \\overline{d}_{\\mathrm{spatial}} / \\overline{d}_{\\mathrm{energy}}$, with $I_{\\mathrm{range}} < 1$ showing that spatial ordering reduces coupling range.\n- The correlation improvement $\\Delta \\rho = \\rho_{\\mathrm{spatial}} - \\rho_{\\mathrm{energy}}$, which should be negative when spatial ordering enhances locality (stronger negative correlation).\n- The nearest-neighbor gain $G_{\\mathrm{NN}} = f_{\\mathrm{NN,\\, spatial}} / f_{\\mathrm{NN,\\, energy}}$, with $G_{\\mathrm{NN}} > 1$ indicating that more weight lies in nearest-neighbor couplings for the spatial chain.\n\nAlgorithmic design steps for implementation:\n- Generate all orbitals with $N \\leq N_{\\max}$ obeying $n = (N-l)/2 \\in \\mathbb{Z}$, and include all $m \\in \\{-l,\\dots,l\\}$ to capture magnetic degeneracy. For each orbital, compute $R = b \\sqrt{N + \\tfrac{3}{2}}$ and $E_{N} = (N + \\tfrac{3}{2})$ after setting $\\hbar \\omega = 1$.\n- Create two orderings as specified. Map each orbital to its position $p(i)$ in the chain for each ordering.\n- For each unordered pair $(i,j)$ with $i<j$, compute $w_{ij}$ using the defined formula with the given $b$, $s$, $\\alpha$, and $\\beta$. Compute $d_{ij}$ per ordering.\n- Accumulate $\\sum w_{ij}$, $\\sum w_{ij} d_{ij}$, $\\sum_{d_{ij} \\leq 1} w_{ij}$, and the sample vectors of $d_{ij}$ and $w_{ij}$ for correlation evaluation. If $\\sigma_{d} = 0$ or $\\sigma_{w} = 0$, set $\\rho = 0$ to avoid undefined behavior.\n- For each ordering, compute $\\overline{d}$, $f_{\\mathrm{NN}}$, and $\\rho$. Then compute the three comparison metrics $(I_{\\mathrm{range}}, \\Delta \\rho, G_{\\mathrm{NN}})$.\n- Repeat for the specified test suite.\n\nThe outputs are dimensionless floats. Finally, aggregate the results into a single flat list ordered by test case and metric and print a single line in the exact required format $[I_{1}, \\Delta \\rho_{1}, G_{\\mathrm{NN},1}, I_{2}, \\Delta \\rho_{2}, G_{\\mathrm{NN},2}, I_{3}, \\Delta \\rho_{3}, G_{\\mathrm{NN},3}, I_{4}, \\Delta \\rho_{4}, G_{\\mathrm{NN},4}]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_orbitals(Nmax: int, b: float):\n    \"\"\"\n    Generate all 3D harmonic oscillator orbitals up to Nmax with parity constraint,\n    including magnetic degeneracy m in [-l, ..., l].\n    Each orbital is represented as a dict with keys: n, l, m, N, R, E.\n    \"\"\"\n    orbitals = []\n    for N in range(Nmax + 1):\n        # l can be 0..N, with the constraint that n = (N - l)/2 must be integer >= 0\n        for l in range(N + 1):\n            if (N - l) % 2 != 0:\n                continue\n            n = (N - l) // 2\n            if n < 0:\n                continue\n            # magnetic degeneracy\n            for m in range(-l, l + 1):\n                R = b * np.sqrt(N + 1.5)  # rms radius\n                E = (N + 1.5)            # set ħω = 1 for ordering\n                orbitals.append({\"n\": n, \"l\": l, \"m\": m, \"N\": N, \"R\": R, \"E\": E})\n    return orbitals\n\ndef order_orbitals(orbitals, mode: str):\n    \"\"\"\n    Return an ordering mapping: orbital index -> position in chain.\n    mode: 'spatial' or 'energy'\n    spatial: sort by R asc, l asc, m asc\n    energy: sort by E asc, m desc, l desc\n    \"\"\"\n    indices = list(range(len(orbitals)))\n    if mode == \"spatial\":\n        sorted_idx = sorted(indices, key=lambda i: (orbitals[i][\"R\"], orbitals[i][\"l\"], orbitals[i][\"m\"]))\n    elif mode == \"energy\":\n        sorted_idx = sorted(indices, key=lambda i: (orbitals[i][\"E\"], -orbitals[i][\"m\"], -orbitals[i][\"l\"]))\n    else:\n        raise ValueError(\"Unknown mode\")\n    pos = {idx: p for p, idx in enumerate(sorted_idx)}\n    return pos\n\ndef pair_weight(o_i, o_j, s: float, alpha: float, beta: float):\n    \"\"\"\n    Compute the coupling weight between two orbitals based on Gaussian spatial decay and\n    exponential penalties for angular mismatches.\n    \"\"\"\n    dR = abs(o_i[\"R\"] - o_j[\"R\"])\n    # Gaussian in centroid separation with width s\n    w = np.exp(-(dR ** 2) / (2.0 * s ** 2))\n    # Angular momentum mismatch penalty\n    w *= np.exp(-alpha * abs(o_i[\"l\"] - o_j[\"l\"]))\n    # Magnetic projection mismatch penalty\n    w *= np.exp(-beta * abs(o_i[\"m\"] - o_j[\"m\"]))\n    return w\n\ndef compute_metrics(orbitals, pos_map, s: float, alpha: float, beta: float):\n    \"\"\"\n    Compute total weight, weighted effective coupling range, nearest-neighbor fraction,\n    and Pearson correlation between chain distance and weight for a given ordering.\n    \"\"\"\n    L = len(orbitals)\n    if L < 2:\n        # No pairs; define zero metrics\n        return 0.0, 0.0, 0.0\n\n    w_tot = 0.0\n    w_d_sum = 0.0\n    w_nn = 0.0\n    d_list = []\n    w_list = []\n\n    for i in range(L):\n        for j in range(i + 1, L):\n            w = pair_weight(orbitals[i], orbitals[j], s, alpha, beta)\n            d = abs(pos_map[i] - pos_map[j])\n            w_tot += w\n            w_d_sum += w * d\n            if d <= 1:\n                w_nn += w\n            d_list.append(float(d))\n            w_list.append(float(w))\n\n    if w_tot == 0.0:\n        # Avoid division by zero; define neutral metrics\n        avg_range = 0.0\n        nn_frac = 0.0\n    else:\n        avg_range = w_d_sum / w_tot\n        nn_frac = w_nn / w_tot\n\n    # Pearson correlation between d and w\n    d_arr = np.array(d_list)\n    w_arr = np.array(w_list)\n    sd_d = np.std(d_arr)\n    sd_w = np.std(w_arr)\n    if sd_d > 0 and sd_w > 0:\n        cov = float(np.mean((d_arr - np.mean(d_arr)) * (w_arr - np.mean(w_arr))))\n        rho = cov / (sd_d * sd_w)\n    else:\n        rho = 0.0\n\n    return avg_range, nn_frac, rho\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (Nmax, b [fm], s [fm], alpha, beta)\n    test_cases = [\n        (4, 1.7, 1.7, 0.6, 0.2),  # Case 1\n        (2, 1.7, 0.6, 0.8, 0.3),  # Case 2\n        (6, 1.7, 3.4, 0.5, 0.1),  # Case 3\n        (1, 1.7, 0.4, 0.7, 0.2),  # Case 4 (edge coverage)\n    ]\n\n    results = []\n    for Nmax, b, s, alpha, beta in test_cases:\n        orbitals = generate_orbitals(Nmax, b)\n        pos_spatial = order_orbitals(orbitals, mode=\"spatial\")\n        pos_energy = order_orbitals(orbitals, mode=\"energy\")\n\n        avg_range_sp, nn_frac_sp, rho_sp = compute_metrics(orbitals, pos_spatial, s, alpha, beta)\n        avg_range_en, nn_frac_en, rho_en = compute_metrics(orbitals, pos_energy, s, alpha, beta)\n\n        # Improvement ratio in weighted effective coupling range\n        if avg_range_en != 0.0:\n            I_range = avg_range_sp / avg_range_en\n        else:\n            # If energy range is zero (degenerate), set neutral comparison\n            I_range = 1.0\n\n        # Correlation improvement\n        delta_rho = rho_sp - rho_en\n\n        # Nearest-neighbor gain\n        if nn_frac_en != 0.0:\n            G_nn = nn_frac_sp / nn_frac_en\n        else:\n            # If energy NN fraction is zero, define gain as 1 if both zero else large; choose neutral 1.0\n            G_nn = 1.0\n\n        results.extend([I_range, delta_rho, G_nn])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "At the heart of DMRG lies a powerful data compression step: truncating the Hilbert space while preserving the most important quantum information encoded in the ground state. This practice illuminates this core mechanism by connecting the abstract entanglement spectrum, obtained from the Schmidt decomposition, to the concrete choice of the MPS bond dimension, $m$. You will learn to control the accuracy of a DMRG simulation by calculating the minimal bond dimension needed to satisfy a desired error tolerance, defined by the discarded weight $\\epsilon_{\\text{disc}}$ .",
            "id": "3554768",
            "problem": "Consider a one-dimensional orbital ordering for a valence-space nuclear shell-model Hamiltonian, where the ground state is approximated using the Matrix Product State (MPS) ansatz within the Density Matrix Renormalization Group (DMRG). At a given bipartition (bond) along the chain, the bipartite entanglement spectrum is the set of eigenvalues of the reduced density matrix obtained from the Schmidt decomposition of the many-body state. Let the entanglement spectrum be ordered nonincreasingly as $\\{\\lambda_{\\alpha}\\}_{\\alpha=1}^{\\chi}$ with $\\sum_{\\alpha=1}^{\\chi} \\lambda_{\\alpha} = 1$ and $\\lambda_{1} \\ge \\lambda_{2} \\ge \\cdots \\ge \\lambda_{\\chi} \\ge 0$. The truncation at bond dimension $m$ retains the $m$ largest eigenvalues and discards the rest. The discarded weight is defined as $\\epsilon_{\\text{disc}}(m) = \\sum_{\\alpha=m+1}^{\\chi} \\lambda_{\\alpha}$.\n\nIn a two-site DMRG sweep, one aims to choose the smallest bond dimension $m$ at each bond such that the local truncation error is controlled by a target tolerance $\\varepsilon$. Starting from the foundational definition of the Schmidt decomposition and reduced density matrix for a pure state bipartition, use the entanglement spectrum\n$$\n\\{\\lambda_{\\alpha}\\}_{\\alpha=1}^{10} = \\{0.36,\\;0.24,\\;0.12,\\;0.08,\\;0.06,\\;0.05,\\;0.04,\\;0.025,\\;0.015,\\;0.01\\}\n$$\nand the tolerance $\\varepsilon = 2 \\times 10^{-2}$ to determine the minimal integer $m$ such that $\\epsilon_{\\text{disc}}(m) \\le \\varepsilon$. Then, based on the same foundational principles, explain how this criterion informs adaptive bond-dimension control during DMRG sweeps in computational nuclear physics, particularly in terms of computational efficiency and error control for strongly and weakly entangled cuts.\n\nProvide the final $m$ as a single integer. No rounding is required.",
            "solution": "The problem requires us to determine the minimal bond dimension $m$ required to satisfy a given truncation error tolerance and to explain the role of this criterion in adaptive Density Matrix Renormalization Group (DMRG) calculations.\n\nFirst, we calculate the minimal integer $m$ such that the discarded weight $\\epsilon_{\\text{disc}}(m)$ is less than or equal to the tolerance $\\varepsilon = 0.02$. The discarded weight is the sum of all eigenvalues of the reduced density matrix that are thrown away: $\\epsilon_{\\text{disc}}(m) = \\sum_{\\alpha=m+1}^{\\chi} \\lambda_{\\alpha}$. Since the eigenvalues sum to one, this is equivalent to $1 - \\sum_{\\alpha=1}^{m} \\lambda_{\\alpha}$.\nThe given eigenvalues are: $\\{\\lambda_{\\alpha}\\} = \\{0.36, 0.24, 0.12, 0.08, 0.06, 0.05, 0.04, 0.025, 0.015, 0.01\\}$.\n\nWe can calculate the discarded weight for increasing values of $m$:\n- For $m=1, \\epsilon_{\\text{disc}}(1) = 1 - 0.36 = 0.64 > 0.02$\n- For $m=2, \\epsilon_{\\text{disc}}(2) = 1 - (0.36 + 0.24) = 0.40 > 0.02$\n- For $m=3, \\epsilon_{\\text{disc}}(3) = 1 - (0.36 + 0.24 + 0.12) = 0.28 > 0.02$\n- For $m=4, \\epsilon_{\\text{disc}}(4) = 1 - (0.36 + 0.24 + 0.12 + 0.08) = 0.20 > 0.02$\n- For $m=5, \\epsilon_{\\text{disc}}(5) = 1 - (0.36 + 0.24 + 0.12 + 0.08 + 0.06) = 0.14 > 0.02$\n- For $m=6, \\epsilon_{\\text{disc}}(6) = 1 - (0.36 + 0.24 + 0.12 + 0.08 + 0.06 + 0.05) = 0.09 > 0.02$\n- For $m=7, \\epsilon_{\\text{disc}}(7) = 1 - (0.36 + 0.24 + 0.12 + 0.08 + 0.06 + 0.05 + 0.04) = 0.05 > 0.02$\n- For $m=8, \\epsilon_{\\text{disc}}(8) = \\lambda_9 + \\lambda_{10} = 0.015 + 0.01 = 0.025 > 0.02$\n- For $m=9, \\epsilon_{\\text{disc}}(9) = \\lambda_{10} = 0.01 \\le 0.02$\n\nThe condition is met for $m=9$. Therefore, the minimal integer bond dimension required is 9.\n\nThis criterion is the basis for adaptive bond-dimension control in DMRG. The Schmidt decomposition theorem guarantees that for a given bipartition of a pure state $|\\Psi\\rangle$, the optimal approximation of rank $m$ is obtained by keeping the $m$ Schmidt states corresponding to the $m$ largest Schmidt coefficients. The discarded weight $\\epsilon_{\\text{disc}}(m)$ is the squared error of this approximation.\n\nIn a practical DMRG sweep, this principle is implemented at each bond of the 1D chain. After optimizing a local tensor (e.g., a two-site tensor), a Singular Value Decomposition (SVD) is performed, which is equivalent to a Schmidt decomposition. The squared normalized singular values are the eigenvalues $\\{\\lambda_{\\alpha}\\}$ of the reduced density matrix.\n\nInstead of using a fixed bond dimension $m$ for the entire chain, the algorithm is given a target tolerance $\\varepsilon$. At each bond, it calculates the entanglement spectrum and determines the smallest $m$ needed to satisfy $\\epsilon_{\\text{disc}}(m) \\le \\varepsilon$. This bond dimension is then used for the newly created MPS tensor at that location.\n\nThis adaptive scheme is crucial for computational efficiency and accuracy:\n1.  **Weakly Entangled Cuts:** If a bond separates two weakly entangled parts of the system (e.g., across a large nuclear shell gap), the entanglement spectrum decays very rapidly. Only a few eigenvalues will be significant. The algorithm will automatically choose a small $m$ for this bond, drastically reducing the size of the MPS tensors and the computational cost of subsequent contractions, which scales as a polynomial (typically $m^3$) of the bond dimension.\n2.  **Strongly Entangled Cuts:** If a bond is in a region of high entanglement (e.g., near the Fermi surface where orbitals are strongly mixed), the spectrum decays slowly. To meet the tolerance $\\varepsilon$, a much larger $m$ is required. The adaptive algorithm allocates more resources by increasing $m$ at these \"difficult\" bonds, ensuring that the crucial quantum correlations are captured with the desired accuracy.\n\nThus, adaptive bond-dimension control allows the DMRG algorithm to dynamically distribute computational resources where they are most needed, making it a highly efficient and powerful method for tackling complex many-body problems in nuclear physics and other fields. It maintains a user-defined accuracy across the entire system while minimizing the overall computational cost.",
            "answer": "$$\n\\boxed{9}\n$$"
        },
        {
            "introduction": "Beyond understanding how an algorithm works, a computational physicist must also analyze its performance and cost in terms of time and memory. This exercise provides a first-principles look at the computational complexity of the DMRG algorithm by dissecting the tensor contractions that form its computational kernel. By deriving the fundamental scaling laws for a DMRG sweep, you will gain insight into how to budget resources for large-scale simulations and explore strategies for parallelization, a key aspect of modern high-performance computing .",
            "id": "3554825",
            "problem": "Consider a valence-space nuclear shell-model Hamiltonian encoded as a Matrix Product Operator (MPO) acting on a Matrix Product State (MPS) within a one-dimensional orbital ordering of length $L$. Each orbital has local Hilbert-space dimension $d$ (e.g., occupation-number and spin-isospin degrees of freedom consistent with fermionic antisymmetry), and the MPS is kept at a uniform bond dimension $m$ along the chain by the Density Matrix Renormalization Group (DMRG). The Hamiltonian MPO has a uniform bond dimension $w$ arising from the finite range and operator structure of the nuclear interactions.\n\nAdopt the single-site variational DMRG update with an iterative Krylov eigensolver (e.g., Davidson), where the dominant kernel in each local update is the application of the effective Hamiltonian to the local state vector. Use the following canonical tensor shapes:\n- The site MPS tensor $A^{[i]}$ has indices $(\\alpha, s, \\beta)$ with $\\alpha \\in \\{1,\\dots,m\\}$, $s \\in \\{1,\\dots,d\\}$, and $\\beta \\in \\{1,\\dots,m\\}$, so its storage per site scales as $m^{2} d$.\n- The site MPO tensor $W^{[i]}$ has indices $(\\ell, r, s', s)$ with $\\ell \\in \\{1,\\dots,w\\}$, $r \\in \\{1,\\dots,w\\}$, and $s', s \\in \\{1,\\dots,d\\}$, so its storage per site scales as $w^{2} d^{2}$.\n- The left and right environments $E_{L}^{[i]}$ and $E_{R}^{[i]}$ entering the effective Hamiltonian application have indices $(\\alpha', \\alpha, \\ell)$ and $(\\beta, \\beta', r)$, respectively, so each environment per site scales as $m^{2} w$ in storage.\n\nFor a single-site local optimization, represent the local vector $x$ as a rank-$3$ tensor $x_{\\alpha s \\beta}$ of dimension $m \\times d \\times m$, which has flattened length $m^{2} d$. The effective Hamiltonian application yielding $y_{\\alpha' s' \\beta'}$ can be written schematically as the contraction\n$$\ny_{\\alpha' s' \\beta'} \\;=\\; \\sum_{\\alpha, s, \\beta} \\sum_{\\ell, r} \\; E_{L,\\alpha' \\alpha \\ell} \\; W_{\\ell r s' s} \\; E_{R,\\beta \\beta' r} \\; x_{\\alpha s \\beta}.\n$$\nDerive, from first principles of tensor contractions and index counting without using any shortcut formulas, the leading-order memory footprint over the full chain when both left and right environments are cached for all sites simultaneously during a bidirectional sweep, and the leading-order total time-complexity for one full sweep when counting one effective-Hamiltonian application per site and ignoring constant iteration counts in the Krylov method. Express both quantities as closed-form analytic expressions in terms of $m$, $w$, $L$, and $d$.\n\nAdditionally, based on the block structure induced by conserved quantum numbers (e.g., particle number $U(1)$ and total angular momentum $SU(2)$) and on the MPO bond index structure, propose a scientifically sound parallelization strategy that partitions work either across symmetry sectors or across MPO bonds. Your proposal should explain how the contraction above factorizes, how partial results are accumulated, and what the expected scaling of computation and communication would be, but your final numerical expressions for memory and time-complexity must remain functions only of $m$, $w$, $L$, and $d$.\n\nYour final answer must be a single row matrix containing the memory and time-complexity expressions in that order. No units are required. Do not include big-$\\mathcal{O}$ notation in the final expressions; provide the leading-order closed forms.",
            "solution": "### 1. Derivation of Memory Footprint\n\nThe total memory footprint is the sum of the storage required for all tensors that must be kept in memory for a full bidirectional sweep, as specified. These are the Matrix Product State (MPS) tensors, the Matrix Product Operator (MPO) tensors, and the cached left and right environment tensors for all $L$ sites.\n\n1.  **MPS Tensors:** There are $L$ sites. Each site tensor $A^{[i]}$ has dimensions $(m, d, m)$.\n    Total MPS storage = $L \\times m \\times d \\times m = L m^2 d$.\n2.  **MPO Tensors:** There are $L$ sites. Each MPO tensor $W^{[i]}$ has dimensions $(w, w, d, d)$.\n    Total MPO storage = $L \\times w \\times w \\times d \\times d = L w^2 d^2$.\n3.  **Left Environments:** We cache one environment tensor $E_L^{[i]}$ for each of the $L$ sites. Each has dimensions $(m, m, w)$.\n    Total Left Env. storage = $L \\times m \\times m \\times w = L m^2 w$.\n4.  **Right Environments:** Similarly, we cache one right environment tensor $E_R^{[i]}$ for each site, each with dimensions $(m, m, w)$.\n    Total Right Env. storage = $L \\times m \\times m \\times w = L m^2 w$.\n\nThe total leading-order memory footprint is the sum of these contributions:\n$$ \\text{Memory} = L m^2 d + L w^2 d^2 + L m^2 w + L m^2 w = L m^2 d + 2 L m^2 w + L w^2 d^2 $$\nFactoring out $L$ gives $L (m^2 d + 2 m^2 w + w^2 d^2)$.\n\n### 2. Derivation of Time Complexity\n\nThe total time complexity for one full sweep is $L$ times the cost of a single effective Hamiltonian application. We need to find the most efficient contraction order for the expression:\n$$ y_{\\alpha' s' \\beta'} \\;=\\; \\sum_{\\alpha, s, \\beta, \\ell, r} E_{L,\\alpha' \\alpha \\ell} \\; W_{\\ell r s' s} \\; E_{R,\\beta \\beta' r} \\; x_{\\alpha s \\beta} $$\nThe computational cost of a tensor contraction is the product of the dimensions of all indices involved (both summed and unsummed). An optimal path minimizes the size of intermediate tensors. We proceed with a right-to-left contraction order.\n\n**Step 1:** Contract the local vector $x$ with the right environment $E_R$.\nLet $T_1(\\alpha, s, \\beta', r) = \\sum_{\\beta} x_{\\alpha s \\beta} E_{R,\\beta \\beta' r}$.\nThe cost is the product of the dimensions of the indices $(\\alpha, s, \\beta, \\beta', r)$, which are $(m, d, m, m, w)$.\nCost of Step 1 = $m \\times d \\times m \\times m \\times w = m^3 d w$.\nThe resulting intermediate tensor $T_1$ has indices $(\\alpha, s, \\beta', r)$ and dimensions $(m, d, m, w)$.\n\n**Step 2:** Contract the intermediate tensor $T_1$ with the MPO tensor $W$.\nLet $T_2(\\alpha, \\beta', \\ell, s') = \\sum_{s, r} T_1(\\alpha, s, \\beta', r) W_{\\ell r s' s}$.\nThe cost is the product of the dimensions of the indices $(\\alpha, s, \\beta', r, \\ell, s')$, which are $(m, d, m, w, w, d)$.\nCost of Step 2 = $m \\times d \\times m \\times w \\times w \\times d = m^2 d^2 w^2$.\nThe resulting intermediate tensor $T_2$ has indices $(\\alpha, \\beta', \\ell, s')$ and dimensions $(m, m, w, d)$.\n\n**Step 3:** Contract the intermediate tensor $T_2$ with the left environment $E_L$.\nThis gives the final result $y_{\\alpha' s' \\beta'} = \\sum_{\\alpha, \\ell} E_{L, \\alpha' \\alpha \\ell} T_2(\\alpha, \\beta', \\ell, s')$.\nThe cost is the product of the dimensions of the indices $(\\alpha', \\alpha, \\ell, \\beta', s')$, which are $(m, m, w, m, d)$.\nCost of Step 3 = $m \\times m \\times w \\times m \\times d = m^3 d w$.\n\nThe total cost for a single site is the sum of the costs of these steps:\n$$ \\text{Cost per site} = m^3 d w + m^2 d^2 w^2 + m^3 d w = 2 m^3 d w + m^2 d^2 w^2 $$\nThe total time complexity for one full sweep of $L$ sites is:\n$$ \\text{Time} = L (2 m^3 d w + m^2 d^2 w^2) $$\n\n### 3. Parallelization Strategy\n\nThe structure of the effective Hamiltonian contraction is a sum over the MPO bond indices $\\ell$ and $r$. This allows for a natural parallelization.\nThe contraction can be written as a sum over $w^2$ independent terms:\n$$ y = \\sum_{\\ell=1}^{w} \\sum_{r=1}^{w} y^{(\\ell, r)} $$\nwhere each partial result $y^{(\\ell, r)}$ is computed from tensors corresponding to a single pair of MPO virtual indices:\n$$ y^{(\\ell, r)}_{\\alpha' s' \\beta'} = \\sum_{\\alpha, s, \\beta} E_{L,\\alpha' \\alpha \\ell} \\; W_{\\ell r s' s} \\; E_{R,\\beta \\beta' r} \\; x_{\\alpha s \\beta} $$\n**Partitioning and Accumulation:** The $w^2$ tasks of computing $y^{(\\ell, r)}$ can be distributed among a pool of processors. Each processor calculates a subset of these partial results and sums them locally. For this to work, the tensors $x$, $E_L$, and $E_R$ must be broadcast to all processors, while slices of the MPO tensor $W$ can be sent to the relevant processor. After all partial sums are computed, a final reduction (summation) operation is performed across all processors to obtain the final result $y$.\n\n**Scaling:**\n*   **Computation:** The total work is divided among the processors. With $N_p$ processors and ideal load balancing, the computational time is reduced by a factor of $N_p$ (up to $N_p \\approx w^2$).\n*   **Communication:** The main communication cost is the initial broadcast of the environment and local tensors and the final reduction of the result tensor. The reduction cost typically scales as $O(m^2 d \\log N_p)$, which is often negligible compared to the computational savings for large $m$ and $w$. This makes the strategy highly effective for modern DMRG implementations. A similar parallelization can be done over symmetry sectors if the tensors are block-sparse, where contractions for each symmetry block are independent.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix} L (m^{2} d + 2 m^{2} w + w^{2} d^{2}) & L(2 m^{3} d w + m^{2} d^{2} w^{2}) \\end{pmatrix}\n}\n$$"
        }
    ]
}