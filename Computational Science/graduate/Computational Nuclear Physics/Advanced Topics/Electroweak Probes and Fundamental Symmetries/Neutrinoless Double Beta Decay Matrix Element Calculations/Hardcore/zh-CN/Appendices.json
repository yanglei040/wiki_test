{
    "hands_on_practices": [
        {
            "introduction": "在着手计算复杂的核矩阵单元之前，深刻理解其核心组成部分——中微子交换势——的性质至关重要。本练习将引导你通过解析推导，探究中微子势在极短程 ($r \\to 0$) 和极长程 ($r \\to \\infty$) 的极限行为 。这个过程不仅能让你熟悉势函数的数学结构，更能揭示有限核子尺寸 (Finite Nucleon Size, FNS) 和短程关联 (Short-Range Correlations, SRC) 等物理效应是如何抑制点状核子模型中出现的发散，从而确保计算的物理实在性。",
            "id": "3572946",
            "problem": "考虑一个用于无中微子双贝塔衰变中轻马约拉纳（Majorana）粒子交换的简化单通道中微子势，该势是在闭合近似下，通过对无质量中微子传播子和偶极核子形状因子的傅里叶变换构建的。令核半径表示为 $R$，闭合能量为 $\\bar{E} > 0$，偶极截断为 $\\Lambda > 0$。定义无关联的坐标空间中微子势\n$$\nH_{K}(r) = \\frac{2 R}{\\pi} \\int_{0}^{\\infty} \\mathrm{d}q \\,\\frac{q}{q + \\bar{E}} \\, j_{0}(q r) \\left(\\frac{\\Lambda^{2}}{\\Lambda^{2} + q^{2}}\\right)^{2},\n$$\n其中 $j_{0}(x)$ 是零阶球贝塞尔函数，偶极因子模拟了有限核子尺寸（FNS）。通过一个在原点处正则且满足 $0 \\leq f_{J}(0) \\leq 1$ 和 $\\lim_{r \\to \\infty} f_{J}(r) = 1$ 的乘性 Jastrow 因子 $f_{J}(r)$ 来包含短程关联（SRC）。因此，正则化后的势为 $H_{K}^{\\mathrm{reg}}(r) = f_{J}(r) H_{K}(r)$。\n\n从无质量中微子传播子和偶极核子形状因子的动量空间结构出发，推导 $H_{K}^{\\mathrm{reg}}(r)$ 在 $r \\to 0^{+}$ 和 $r \\to \\infty$ 时的极限行为。你的推导必须从上述积分表示开始，并从第一性原理出发，仅使用闭合近似以及傅里叶变换和球贝塞尔函数的标准性质。清楚地解释 FNS 和 SRC 如何正则化 $r \\to 0$ 的行为，并计算 $\\lim_{r \\to 0^{+}} H_{K}^{\\mathrm{reg}}(r)$ 的精确闭合形式，用 $\\bar{E}$、$\\Lambda$、$R$ 和 $f_{J}(0)$ 表示。同时以闭合形式表示极限值 $\\lim_{r \\to \\infty} H_{K}^{\\mathrm{reg}}(r)$。\n\n将你的最终答案表示为一个双元素行矩阵，其元素为 $\\lim_{r \\to 0^{+}} H_{K}^{\\mathrm{reg}}(r)$ 和 $\\lim_{r \\to \\infty} H_{K}^{\\mathrm{reg}}(r)$。无需进行数值近似或四舍五入，最终答案中不应包含单位。",
            "solution": "问题要求解正则化的中微子势 $H_{K}^{\\mathrm{reg}}(r) = f_{J}(r) H_{K}(r)$ 在 $r \\to 0^{+}$ 和 $r \\to \\infty$ 时的极限行为。\n\n势 $H_K(r)$ 由以下积分给出：\n$$ H_{K}(r) = \\frac{2 R}{\\pi} \\int_{0}^{\\infty} \\mathrm{d}q \\,\\frac{q}{q + \\bar{E}} \\, j_{0}(q r) \\left(\\frac{\\Lambda^{2}}{\\Lambda^{2} + q^{2}}\\right)^{2} $$\n其中 $j_0(x) = \\frac{\\sin(x)}{x}$ 是零阶球贝塞尔函数。Jastrow 因子 $f_J(r)$ 在原点处是正则的，并满足 $\\lim_{r\\to 0^+} f_J(r) = f_J(0)$ 和 $\\lim_{r\\to\\infty} f_J(r) = 1$。\n\n### 第1部分：$r \\to 0^{+}$ 时的极限\n\n我们要计算 $\\lim_{r \\to 0^{+}} H_{K}^{\\mathrm{reg}}(r) = \\lim_{r \\to 0^{+}} \\left( f_{J}(r) H_{K}(r) \\right)$。由于两个极限都存在，我们可以将其写为：\n$$ \\lim_{r \\to 0^{+}} H_{K}^{\\mathrm{reg}}(r) = \\left(\\lim_{r \\to 0^{+}} f_{J}(r)\\right) \\left(\\lim_{r \\to 0^{+}} H_{K}(r)\\right) = f_{J}(0) \\lim_{r \\to 0^{+}} H_{K}(r) $$\n为了求 $H_K(r)$ 的极限，我们分析该积分。我们知道 $\\lim_{x\\to 0} j_0(x) = 1$。根据控制收敛定理，我们可以将极限移到积分号内部。被积函数的绝对值由 $g(q) = \\frac{q}{q+\\bar{E}} (\\frac{\\Lambda^2}{\\Lambda^2+q^2})^2$ 界定，该函数在 $q \\in [0, \\infty)$ 上是绝对可积的，因为当 $q \\to \\infty$ 时，$g(q) \\sim \\Lambda^4/q^4$。\n\n因此，极限为：\n$$ \\lim_{r \\to 0^{+}} H_{K}(r) = \\frac{2 R}{\\pi} \\int_{0}^{\\infty} \\mathrm{d}q \\,\\frac{q}{q + \\bar{E}} \\, \\left(\\lim_{r \\to 0^{+}} j_{0}(q r)\\right) \\left(\\frac{\\Lambda^{2}}{\\Lambda^{2} + q^{2}}\\right)^{2} = \\frac{2 R \\Lambda^4}{\\pi} \\int_{0}^{\\infty} \\frac{q}{(q + \\bar{E})(\\Lambda^{2} + q^{2})^{2}} \\mathrm{d}q $$\n该积分是有限的。如果没有偶极形状因子（即 $\\Lambda \\to \\infty$），积分将是 $\\int_0^\\infty \\frac{q}{q+\\bar{E}} \\mathrm{d}q$，这个积分是发散的。这说明了有限核子尺寸（FNS）因子的作用：它充当高动量截断，正则化了在原点处的势，否则对于点状核子，该势会发散。短程关联（SRC）因子 $f_J(r)$ 通过乘性常数 $f_J(0) \\leq 1$ 进一步抑制了 $r=0$ 处的势。\n\n为了计算该积分，我们将其记为 $I$：\n$$ I = \\int_{0}^{\\infty} \\frac{q}{(q + \\bar{E})(q^{2} + \\Lambda^{2})^{2}} \\mathrm{d}q $$\n我们对被积函数使用部分分式分解。首先，我们分解 $\\frac{q}{q+\\bar{E}} = 1 - \\frac{\\bar{E}}{q+\\bar{E}}$。\n$$ I = \\int_{0}^{\\infty} \\left(1 - \\frac{\\bar{E}}{q+\\bar{E}}\\right) \\frac{1}{(q^2+\\Lambda^2)^2} \\mathrm{d}q = \\int_{0}^{\\infty} \\frac{\\mathrm{d}q}{(q^2+\\Lambda^2)^2} - \\bar{E} \\int_{0}^{\\infty} \\frac{\\mathrm{d}q}{(q+\\bar{E})(q^2+\\Lambda^2)^2} $$\n我们称这些积分为 $I_1$ 和 $I_2$，所以 $I = I_1 - \\bar{E} I_2$。\n第一个积分 $I_1$ 可以通过三角代换（$q = \\Lambda \\tan\\theta$）求解：\n$$ I_1 = \\int_{0}^{\\infty} \\frac{\\mathrm{d}q}{(q^2+\\Lambda^2)^2} = \\frac{\\pi}{4\\Lambda^3} $$\n对于第二个积分 $I_2$，我们对其被积函数使用部分分式：\n$$ \\frac{1}{(q+\\bar{E})(q^2+\\Lambda^2)^2} = \\frac{A}{q+\\bar{E}} + \\frac{Bq+C}{q^2+\\Lambda^2} + \\frac{Dq+F}{(q^2+\\Lambda^2)^2} $$\n系数求得为：\n$A = \\frac{1}{(\\bar{E}^2+\\Lambda^2)^2}$\n$B = -A = -\\frac{1}{(\\bar{E}^2+\\Lambda^2)^2}$\n$C = \\frac{\\bar{E}}{(\\bar{E}^2+\\Lambda^2)^2}$\n$D = -\\frac{1}{\\bar{E}^2+\\Lambda^2}$\n$F = \\frac{\\bar{E}}{\\bar{E}^2+\\Lambda^2}$\n\n现在我们对 $I_2$ 中的每一项进行积分：\n$$ I_2 = \\int_0^\\infty \\left[ A\\left(\\frac{1}{q+\\bar{E}} - \\frac{q}{q^2+\\Lambda^2}\\right) + \\frac{C}{q^2+\\Lambda^2} + \\frac{Dq}{(q^2+\\Lambda^2)^2} + \\frac{F}{(q^2+\\Lambda^2)^2} \\right] \\mathrm{d}q $$\n各个积分为：\n$\\int_0^\\infty \\left(\\frac{1}{q+\\bar{E}} - \\frac{q}{q^2+\\Lambda^2}\\right) \\mathrm{d}q = \\left[\\ln(q+\\bar{E}) - \\frac{1}{2}\\ln(q^2+\\Lambda^2)\\right]_0^\\infty = \\left[\\frac{1}{2}\\ln\\frac{(q+\\bar{E})^2}{q^2+\\Lambda^2}\\right]_0^\\infty = 0 - \\frac{1}{2}\\ln\\frac{\\bar{E}^2}{\\Lambda^2} = \\ln(\\frac{\\Lambda}{\\bar{E}})$。\n$\\int_0^\\infty \\frac{\\mathrm{d}q}{q^2+\\Lambda^2} = \\frac{\\pi}{2\\Lambda}$。\n$\\int_0^\\infty \\frac{q}{(q^2+\\Lambda^2)^2} \\mathrm{d}q = \\left[-\\frac{1}{2(q^2+\\Lambda^2)}\\right]_0^\\infty = \\frac{1}{2\\Lambda^2}$。\n$\\int_0^\\infty \\frac{\\mathrm{d}q}{(q^2+\\Lambda^2)^2} = I_1 = \\frac{\\pi}{4\\Lambda^3}$。\n\n代入系数和这些结果：\n$$ I_2 = A\\ln(\\frac{\\Lambda}{\\bar{E}}) + C\\frac{\\pi}{2\\Lambda} + D\\frac{1}{2\\Lambda^2} + F\\frac{\\pi}{4\\Lambda^3} $$\n$$ I_2 = \\frac{\\ln(\\Lambda/\\bar{E})}{(\\bar{E}^2+\\Lambda^2)^2} + \\frac{\\bar{E}}{(\\bar{E}^2+\\Lambda^2)^2}\\frac{\\pi}{2\\Lambda} - \\frac{1}{\\bar{E}^2+\\Lambda^2}\\frac{1}{2\\Lambda^2} + \\frac{\\bar{E}}{\\bar{E}^2+\\Lambda^2}\\frac{\\pi}{4\\Lambda^3} $$\n我们要求的积分是 $I = I_1 - \\bar{E}I_2$：\n$$ I = \\frac{\\pi}{4\\Lambda^3} - \\bar{E}\\left[ \\frac{\\ln(\\Lambda/\\bar{E})}{(\\bar{E}^2+\\Lambda^2)^2} + \\frac{\\pi\\bar{E}}{2\\Lambda(\\bar{E}^2+\\Lambda^2)^2} - \\frac{1}{2\\Lambda^2(\\bar{E}^2+\\Lambda^2)} + \\frac{\\pi\\bar{E}}{4\\Lambda^3(\\bar{E}^2+\\Lambda^2)} \\right] $$\n将各项合并到公分母 $(\\bar{E}^2+\\Lambda^2)^2$ 上：\n$$ I = \\frac{1}{(\\bar{E}^2+\\Lambda^2)^2} \\left[ \\frac{\\pi(\\bar{E}^2+\\Lambda^2)^2}{4\\Lambda^3} - \\bar{E}\\ln(\\frac{\\Lambda}{\\bar{E}}) - \\frac{\\pi\\bar{E}^2}{2\\Lambda} + \\frac{\\bar{E}(\\bar{E}^2+\\Lambda^2)}{2\\Lambda^2} - \\frac{\\pi\\bar{E}^2(\\bar{E}^2+\\Lambda^2)}{4\\Lambda^3} \\right] $$\n含有 $\\pi$ 的项简化为：$\\frac{\\pi}{4\\Lambda^3}[(\\bar{E}^2+\\Lambda^2)^2 - 2\\bar{E}^2\\Lambda^2 - \\bar{E}^2(\\bar{E}^2+\\Lambda^2)] = \\frac{\\pi}{4\\Lambda^3}[\\Lambda^4-\\bar{E}^2\\Lambda^2] = \\frac{\\pi\\Lambda(\\Lambda^2-\\bar{E}^2)}{4}$。\n所以，\n$$ I = \\frac{1}{(\\bar{E}^2+\\Lambda^2)^2} \\left[ \\frac{\\pi\\Lambda(\\Lambda^2-\\bar{E}^2)}{4} + \\frac{\\bar{E}(\\bar{E}^2+\\Lambda^2)}{2\\Lambda^2} - \\bar{E}\\ln(\\frac{\\Lambda}{\\bar{E}}) \\right] $$\n这是积分值除以 $\\Lambda^4$ 的结果。总积分为 $\\Lambda^4 I$。\n总积分是 $\\Lambda^4$ 乘以 $I_1-\\bar{E}I_2$ 的结果。\n所以，$\\int_0^\\infty \\dots dq = \\Lambda^4 I_1 - \\bar{E}\\Lambda^4 I_2$。\n$$ \\Lambda^4 I_1 = \\frac{\\pi\\Lambda}{4} $$\n$$ \\bar{E}\\Lambda^4 I_2 = \\frac{\\bar{E}\\Lambda^4\\ln(\\Lambda/\\bar{E})}{(\\bar{E}^2+\\Lambda^2)^2} + \\frac{\\pi\\bar{E}^2\\Lambda^3}{2(\\bar{E}^2+\\Lambda^2)^2} - \\frac{\\bar{E}\\Lambda^2(\\bar{E}^2+\\Lambda^2)}{2(\\bar{E}^2+\\Lambda^2)^2} + \\frac{\\pi\\bar{E}^2\\Lambda(\\bar{E}^2+\\Lambda^2)}{4(\\bar{E}^2+\\Lambda^2)^2} $$\n将 $\\Lambda^4(I_1-\\bar{E}I_2)$ 合并到公分母 $4(\\bar{E}^2+\\Lambda^2)^2$ 上：\n分子 = $\\pi\\Lambda(\\bar{E}^2+\\Lambda^2)^2 - 4\\bar{E}\\Lambda^4\\ln(\\frac{\\Lambda}{\\bar{E}}) - 2\\pi\\bar{E}^2\\Lambda^3 + 2\\bar{E}\\Lambda^2(\\bar{E}^2+\\Lambda^2) - \\pi\\bar{E}^2\\Lambda(\\bar{E}^2+\\Lambda^2)$。\n$\\pi$ 项：$\\pi\\Lambda[(\\bar{E}^2+\\Lambda^2)^2 - 2\\bar{E}^2\\Lambda^2 - \\bar{E}^2(\\bar{E}^2+\\Lambda^2)] = \\pi\\Lambda[\\Lambda^4-\\bar{E}^2\\Lambda^2] = \\pi\\Lambda^3(\\Lambda^2-\\bar{E}^2)$。\n总积分为：$\\frac{1}{4(\\bar{E}^2+\\Lambda^2)^2} [ \\pi\\Lambda^3(\\Lambda^2-\\bar{E}^2) - 4\\bar{E}\\Lambda^4\\ln(\\frac{\\Lambda}{\\bar{E}}) + 2\\bar{E}\\Lambda^2(\\bar{E}^2+\\Lambda^2) ]$。\n那么 $\\lim_{r\\to 0^+} H_K(r) = \\frac{2R\\Lambda^4}{\\pi} \\times (\\text{积分})$。\n$$ \\lim_{r \\to 0^{+}} H_{K}(r) = \\frac{2R\\Lambda^4}{\\pi} \\frac{\\pi\\Lambda^3(\\Lambda^2-\\bar{E}^2) - 4\\bar{E}\\Lambda^4\\ln(\\Lambda/\\bar{E}) + 2\\bar{E}\\Lambda^2(\\bar{E}^2+\\Lambda^2)}{4(\\bar{E}^2+\\Lambda^2)^2} $$\n$$ \\lim_{r \\to 0^{+}} H_{K}(r) = \\frac{R\\Lambda^2}{2\\pi(\\bar{E}^2+\\Lambda^2)^2} \\left[ \\pi\\Lambda(\\Lambda^2-\\bar{E}^2) - 4\\bar{E}\\Lambda^2\\ln(\\frac{\\Lambda}{\\bar{E}}) + 2\\bar{E}(\\bar{E}^2+\\Lambda^2) \\right] $$\n因式分解并乘以 $f_J(0)$：\n$$ \\lim_{r \\to 0^{+}} H_{K}^{\\mathrm{reg}}(r) = f_J(0) \\frac{R\\Lambda^2}{(\\bar{E}^2+\\Lambda^2)^2} \\left[ \\frac{\\Lambda(\\Lambda^2-\\bar{E}^2)}{2} + \\frac{\\bar{E}(\\bar{E}^2+\\Lambda^2)}{\\pi} - \\frac{2\\bar{E}\\Lambda^2}{\\pi}\\ln(\\frac{\\Lambda}{\\bar{E}}) \\right] $$\n\n### 第2部分：$r \\to \\infty$ 时的极限\n\n我们要计算 $\\lim_{r \\to \\infty} H_{K}^{\\mathrm{reg}}(r) = (\\lim_{r \\to \\infty} f_J(r)) (\\lim_{r \\to \\infty} H_K(r))$。因为 $\\lim_{r \\to \\infty} f_J(r) = 1$，我们只需要求 $H_K(r)$ 的极限。\n$$ \\lim_{r \\to \\infty} H_{K}(r) = \\lim_{r \\to \\infty} \\frac{2 R}{\\pi} \\int_{0}^{\\infty} \\mathrm{d}q \\,\\frac{q}{q + \\bar{E}} \\left(\\frac{\\Lambda^{2}}{\\Lambda^{2} + q^{2}}\\right)^{2} j_{0}(q r) $$\n该积分为傅里叶型积分。我们可以写出 $j_0(qr) = \\frac{\\sin(qr)}{qr}$。\n$$ H_{K}(r) = \\frac{1}{r} \\left[ \\frac{2 R}{\\pi} \\int_0^\\infty \\mathrm{d}q \\, \\frac{1}{q+\\bar{E}}\\left(\\frac{\\Lambda^2}{\\Lambda^2+q^2}\\right)^2 \\sin(qr) \\right] $$\n令 $h(q) = \\frac{1}{q+\\bar{E}}\\left(\\frac{\\Lambda^2}{\\Lambda^2+q^2}\\right)^2$。对于 $q \\geq 0$，$h(q)$ 是正且连续的。\n当 $q \\to \\infty$ 时，$h(q) \\sim \\Lambda^4/q^5$。积分 $\\int_0^\\infty |h(q)| \\mathrm{d}q$ 是有限的，所以 $h(q)$ 属于 $L^1[0,\\infty)$。\n根据黎曼-勒贝格引理，$L^1$ 函数的傅里叶正弦变换在无穷远处趋于零：\n$$ \\lim_{r \\to \\infty} \\int_0^\\infty h(q) \\sin(qr) \\mathrm{d}q = 0 $$\n因此，势的极限为：\n$$ \\lim_{r \\to \\infty} H_{K}(r) = \\lim_{r \\to \\infty} \\frac{1}{r} \\times 0 = 0 $$\n那么正则化后的势的极限为：\n$$ \\lim_{r \\to \\infty} H_{K}^{\\mathrm{reg}}(r) = 1 \\cdot 0 = 0 $$\n\n因此，这两个极限是上面推导出的 $\\lim_{r \\to 0^{+}} H_{K}^{\\mathrm{reg}}(r)$ 和 $0$。\n$r \\to 0^+$ 极限的最终表达式：\n$L_0 = f_J(0) \\frac{R\\Lambda^2}{(\\bar{E}^2+\\Lambda^2)^2} \\left[ \\frac{\\Lambda(\\Lambda^2-\\bar{E}^2)}{2} + \\frac{\\bar{E}(\\bar{E}^2+\\Lambda^2)}{\\pi} - \\frac{2\\bar{E}\\Lambda^2}{\\pi}\\ln(\\frac{\\Lambda}{\\bar{E}}) \\right]$。\n$r \\to \\infty$ 极限的最终表达式：\n$L_\\infty = 0$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nf_J(0) \\frac{R\\Lambda^2}{(\\bar{E}^2+\\Lambda^2)^2} \\left[ \\frac{\\Lambda(\\Lambda^2-\\bar{E}^2)}{2} + \\frac{\\bar{E}(\\bar{E}^2+\\Lambda^2)}{\\pi} - \\frac{2\\bar{E}\\Lambda^2}{\\pi}\\ln\\left(\\frac{\\Lambda}{\\bar{E}}\\right) \\right] \\quad 0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "闭合近似 (closure approximation) 是无中微子双贝塔衰变矩阵单元计算中一种广泛使用的简化方法，它将对无限多个中间核态的复杂求和替换为一个平均能量分母。本练习旨在构建一个简化的、但物理意义明确的模型，用以定量地比较完整的非闭合方案计算结果与其闭合近似的差异 。通过这项实践，你将能深入理解闭合近似的物理本质、适用条件及其对最终矩阵单元计算结果的潜在影响。",
            "id": "3572951",
            "problem": "考虑一个简化的但科学上可靠的无中微子双贝塔衰变（NDBD）核矩阵元计算模型，该模型在一个非闭合方案中分离出总角动量和宇称为 $J^\\pi = 0^+$ 和 $J^\\pi = 1^+$ 的中间态的贡献，并将其与闭合近似进行比较。目标是设计并实现一个程序，该程序基于第一性原理计算和比较这些贡献：振幅的线性、对中间态的可加性，以及通过能量分母对中间态激发能的依赖性。\n\n基本基础和模型设置：\n- 在二阶弱过程中，对中间态的求和源于时间排序微扰理论，而能量分母编码了虚态的传播。在非闭合方案中，每个具有激发能的中间态都以其自身的能量分母贡献。在闭合近似（CA）中，能量分母被近似为一个单一的有效闭合能量，这消除了对单个中间态能量的显式依赖，同时保留了对各态的可加性。\n- 我们将多体结构分解为约化的无量纲强度 $s_k^{(J)}$，这些强度编码了到多极矩 $J$ 的中间态 $k$ 的径向和自旋-同位旋交叠。动量转移的依赖性通过一个中微子势积分来编码，此处以无量纲形式近似，以消除单位依赖，同时保留对能量分母的定性函数依赖关系。\n\n定义：\n- 令 $x$ 表示一个无量纲动量变量，令 $d$ 表示一个无量纲能量分母。两者都通过一个共同的正尺度 $\\Lambda$ 对物理动量 $q$ 和能量分母 $\\Delta$进行缩放来定义，即 $x = q/\\Lambda$ 和 $d = \\Delta/\\Lambda$。上限 $x_{\\max} = q_{\\max}/\\Lambda$ 控制了积分的数值范围。\n- 定义一个类偶极调节子 $F(x) = \\left(1 + x^2\\right)^{-2}$ 来模拟有限尺寸和形状因子效应。定义无量纲中微子势积分\n$$\nI(d) = \\int_{0}^{x_{\\max}} \\frac{x^2}{x + d}\\,F(x)\\,dx = \\int_{0}^{x_{\\max}} \\frac{x^2}{(x+d)\\left(1+x^2\\right)^2}\\,dx,\n$$\n其中 $d > 0$ 且 $x_{\\max} > 0$。对于任何正的 $d$ 和 $x_{\\max}$，该积分是有限的。\n- 两种多极矩的约化非闭合贡献定义为\n$$\nM_{0^+}^{\\mathrm{non}} = g_V^2 \\sum_{k=1}^{N_{0^+}} s_k^{(0^+)}\\,I\\!\\left(d_k^{(0^+)}\\right),\\quad\nM_{1^+}^{\\mathrm{non}} = g_A^2 \\sum_{k=1}^{N_{1^+}} s_k^{(1^+)}\\,I\\!\\left(d_k^{(1^+)}\\right),\n$$\n其中 $g_V$ 和 $g_A$ 分别是矢量和轴矢量耦合常数，$d_k^{(J)}$ 是对应于多极矩 $J$ 中第 $k$ 个中间态的无量纲分母。\n- 在闭合近似中，\n$$\nM_{0^+}^{\\mathrm{cl}} = g_V^2\\left(\\sum_{k=1}^{N_{0^+}} s_k^{(0^+)}\\right) I\\!\\left(\\bar{d}_{0^+}\\right),\\quad\nM_{1^+}^{\\mathrm{cl}} = g_A^2\\left(\\sum_{k=1}^{N_{1^+}} s_k^{(1^+)}\\right) I\\!\\left(\\bar{d}_{1^+}\\right),\n$$\n其中 $\\bar{d}_{J}$ 是为多极矩 $J$ 选择的有效闭合分母。\n\n分母的构造：\n- 对于多极矩 $J$ 的每个中间态 $k$，通过 $d_k^{(J)} = \\left(E_0 + \\epsilon_k^{(J)}\\right)/\\Lambda$ 定义无量纲分母，其中 $E_0$ 是一个考虑了平均运动学的偏移量，$\\epsilon_k^{(J)}$ 是中间态的激发能。闭合分母定义为 $\\bar{d}_{J} = \\bar{E}_J/\\Lambda$。\n\n任务：\n- 实现一个程序，该程序能数值计算 $I(d)$，并为下面列出的每个测试用例计算 $M_{0^+}^{\\mathrm{non}}$、$M_{1^+}^{\\mathrm{non}}$、$M_{0^+}^{\\mathrm{cl}}$ 和 $M_{1^+}^{\\mathrm{cl}}$。\n- 对于每个测试用例，生成三个浮点数：\n  - $\\Delta M_{0^+} = M_{0^+}^{\\mathrm{non}} - M_{0^+}^{\\mathrm{cl}}$，\n  - $\\Delta M_{1^+} = M_{1^+}^{\\mathrm{non}} - M_{1^+}^{\\mathrm{cl}}$，\n  - $\\Delta M_{\\mathrm{tot}} = \\left(M_{0^+}^{\\mathrm{non}} + M_{1^+}^{\\mathrm{non}}\\right) - \\left(M_{0^+}^{\\mathrm{cl}} + M_{1^+}^{\\mathrm{cl}}\\right)$。\n- 所有输出都应报告为无量纲数。\n\n数值积分要求：\n- 使用可靠的数值积分方法为每个需要的 $d > 0$ 计算 $I(d)$，至少达到适度的绝对容差。由于 $d > 0$ 且 $x \\in [0,x_{\\max}]$（其中 $x_{\\max} > 0$），被积函数在积分区间上没有奇点。\n\n所有测试中使用的常量：\n- 矢量耦合 $g_V = 1.0$ (无量纲)。\n- 轴矢量耦合 $g_A = 1.27$ (无量纲)。\n- 尺度 $\\Lambda = 850.0$ (单位与能量相同)。\n- 最大动量 $q_{\\max} = 2000.0$ (单位与能量相同)，因此 $x_{\\max} = q_{\\max}/\\Lambda$。\n- 输出是无量纲的。\n\n测试套件：\n- 测试用例 1 (具有混合符号和非简并分母的一般情况)：\n  - 偏移量 $E_0 = 10.0$。\n  - 对于 $J^\\pi = 0^+$：三个态，强度 $s^{(0^+)} = \\{0.6,\\,0.3,\\,-0.1\\}$，激发能 $\\epsilon^{(0^+)} = \\{2.0,\\,5.0,\\,8.0\\}$。闭合能量 $\\bar{E}_{0^+} = 12.0$。\n  - 对于 $J^\\pi = 1^+$：四个态，强度 $s^{(1^+)} = \\{0.5,\\,-0.2,\\,0.4,\\,0.1\\}$，激发能 $\\epsilon^{(1^+)} = \\{1.0,\\,3.0,\\,6.0,\\,9.0\\}$。闭合能量 $\\bar{E}_{1^+} = 13.0$。\n- 测试用例 2 (如果使用相同的闭合能量，简并分母会产生精确的闭合等效性)：\n  - 偏移量 $E_0 = 10.0$。\n  - 对于 $J^\\pi = 0^+$：四个态，强度 $s^{(0^+)} = \\{0.3,\\,0.4,\\,-0.1,\\,0.2\\}$，激发能 $\\epsilon^{(0^+)} = \\{4.0,\\,4.0,\\,4.0,\\,4.0\\}$。闭合能量 $\\bar{E}_{0^+} = 14.0$。\n  - 对于 $J^\\pi = 1^+$：五个态，强度 $s^{(1^+)} = \\{0.5,\\,-0.2,\\,0.2,\\,0.1,\\,0.3\\}$，激发能 $\\epsilon^{(1^+)} = \\{4.0,\\,4.0,\\,4.0,\\,4.0,\\,4.0\\}$。闭合能量 $\\bar{E}_{1^+} = 14.0$。\n- 测试用例 3 (强度和为零使得闭合值消失，但非闭合值通常不为零)：\n  - 偏移量 $E_0 = 10.0$。\n  - 对于 $J^\\pi = 0^+$：两个态，强度 $s^{(0^+)} = \\{1.0,\\,-1.0\\}$，激发能 $\\epsilon^{(0^+)} = \\{2.0,\\,10.0\\}$。闭合能量 $\\bar{E}_{0^+} = 12.0$。\n  - 对于 $J^\\pi = 1^+$：四个态，强度 $s^{(1^+)} = \\{0.8,\\,-0.8,\\,0.5,\\,-0.5\\}$，激发能 $\\epsilon^{(1^+)} = \\{1.0,\\,4.0,\\,7.0,\\,10.0\\}$。闭合能量 $\\bar{E}_{1^+} = 11.0$。\n\n角度单位不适用，并且由于模型被构造成无量纲的，输出中不报告任何物理单位。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含测试套件的所有结果，格式为单个逗号分隔的列表，并用方括号括起来。顺序如下：\n  - 第一个测试用例：$\\Delta M_{0^+}$，$\\Delta M_{1^+}$，$\\Delta M_{\\mathrm{tot}}$，\n  - 第二个测试用例：$\\Delta M_{0^+}$，$\\Delta M_{1^+}$，$\\Delta M_{\\mathrm{tot}}$，\n  - 第三个测试用例：$\\Delta M_{0^+}$，$\\Delta M_{1^+}$，$\\Delta M_{\\mathrm{tot}}$。\n- 例如，程序必须打印一行形式为 $[\\text{v}_1,\\text{v}_2,\\text{v}_3,\\text{v}_4,\\text{v}_5,\\text{v}_6,\\text{v}_7,\\text{v}_8,\\text{v}_9]$ 的内容，其中每个 $\\text{v}_i$ 是一个浮点数。",
            "solution": "问题陈述已经过验证，被认为是科学上合理、提法恰当且自洽的。它提出了一个简化的但可靠的计算模型，用于评估和比较基于非闭合方案和闭合近似的无中微子双贝塔衰变核矩阵元。所有参数和定义均已提供，任务是一个清晰、可形式化的计算过程。\n\n解决方案首先实现核心数学对象，然后将它们组装成一个完整的算法来处理指定的测试用例。\n\n基本的计算核心是无量纲中微子势积分，定义为：\n$$\nI(d) = \\int_{0}^{x_{\\max}} \\frac{x^2}{(x+d)\\left(1+x^2\\right)^2}\\,dx\n$$\n其中 $d > 0$ 是无量纲能量分母，$x_{\\max} > 0$ 是无量纲动量截断。对于 $x \\in [0, x_{\\max}]$ 和 $d > 0$，被积函数是一个光滑、非奇异的有理函数。该积分将使用稳健的求积算法进行数值计算。`scipy.integrate.quad` 函数实现了一种自适应求积方案，是此任务的绝佳选择，可提供高精度。定义积分范围的常数是 $q_{\\max} = 2000.0$ 和 $\\Lambda = 850.0$，得出积分上限为 $x_{\\max} = q_{\\max}/\\Lambda \\approx 2.3529$。\n\n整体算法的结构是处理每个测试用例，通过计算 $J^\\pi=0^+$ 和 $J^\\pi=1^+$ 多极矩所需的矩阵元。对于一个通用的多极矩 $J$，非闭合矩阵元 $M_J^{\\mathrm{non}}$ 是通过对每个中间态 $k$ 的贡献求和来计算的：\n$$\nM_{J}^{\\mathrm{non}} = g_J^2 \\sum_{k=1}^{N_J} s_k^{(J)}\\,I\\!\\left(d_k^{(J)}\\right)\n$$\n此处，$g_J$ 是耦合常数（对于 $J=0^+$，$g_V=1.0$；对于 $J=1^+$，$g_A=1.27$），$s_k^{(J)}$ 是第 $k$ 个态的约化强度，$d_k^{(J)}$ 是其无量纲能量分母。每个态的分母由给定的偏移量 $E_0$ 和激发能 $\\epsilon_k^{(J)}$ 计算得出：\n$$\nd_k^{(J)} = \\frac{E_0 + \\epsilon_k^{(J)}}{\\Lambda}\n$$\n计算过程涉及遍历给定多极矩的中间态列表，为每个态计算 $d_k^{(J)}$，数值计算 $I(d_k^{(J)})$，乘以相应的强度 $s_k^{(J)}$，并累加总和。然后将此总和乘以相应耦合常数的平方。\n\n相应的闭合近似矩阵元 $M_J^{\\mathrm{cl}}$ 是通过先将所有强度求和，然后乘以在单个有效闭合分母 $\\bar{d}_J$ 处求值的势积分来计算的：\n$$\nM_{J}^{\\mathrm{cl}} = g_J^2\\left(\\sum_{k=1}^{N_J} s_k^{(J)}\\right) I\\!\\left(\\bar{d}_{J}\\right)\n$$\n闭合分母 $\\bar{d}_J$ 由给定的有效闭合能量 $\\bar{E}_J$ 确定为：\n$$\n\\bar{d}_{J} = \\frac{\\bar{E}_J}{\\Lambda}\n$$\n实现将首先计算总强度和 $\\sum_k s_k^{(J)}$。如果此和不为零，它将计算 $\\bar{d}_J$，求值 $I(\\bar{d}_J)$，然后计算 $M_J^{\\mathrm{cl}}$。如果强度和为零，则 $M_J^{\\mathrm{cl}}$ 必然为零。\n\n对于每个测试用例和每个多极矩（$J=0^+, 1^+$），我们计算差值 $\\Delta M_J = M_J^{\\mathrm{non}} - M_J^{\\mathrm{cl}}$。最后，总差值计算为各个差值之和：$\\Delta M_{\\mathrm{tot}} = \\Delta M_{0^+} + \\Delta M_{1^+}$。\n\n程序将被构造成处理一系列测试用例，每个测试用例包含参数（$E_0$，强度列表 $s_k$ 和激发能列表 $\\epsilon_k$，以及闭合能量 $\\bar{E}_J$）。对于每个用例，它将执行上述逻辑以找到 $(\\Delta M_{0^+}, \\Delta M_{1^+}, \\Delta M_{\\mathrm{tot}})$，并将所有测试用例的这些三元组收集到一个扁平列表中。该列表将被格式化为所需的字符串输出。该实现将使用 `NumPy` 进行高效的数组操作，使用 `SciPy` 进行数值积分，并遵循指定的执行环境。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to solve the neutrinoless double beta decay matrix element problem.\n    \"\"\"\n    # Define global constants given in the problem statement.\n    G_V = 1.0\n    G_A = 1.27\n    LAMBDA = 850.0\n    Q_MAX = 2000.0\n    X_MAX = Q_MAX / LAMBDA\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            # Test case 1 (general case)\n            \"E0\": 10.0,\n            \"0+\": {\n                \"s\": [0.6, 0.3, -0.1],\n                \"eps\": [2.0, 5.0, 8.0],\n                \"E_bar\": 12.0\n            },\n            \"1+\": {\n                \"s\": [0.5, -0.2, 0.4, 0.1],\n                \"eps\": [1.0, 3.0, 6.0, 9.0],\n                \"E_bar\": 13.0\n            }\n        },\n        {\n            # Test case 2 (degenerate denominators)\n            \"E0\": 10.0,\n            \"0+\": {\n                \"s\": [0.3, 0.4, -0.1, 0.2],\n                \"eps\": [4.0, 4.0, 4.0, 4.0],\n                \"E_bar\": 14.0\n            },\n            \"1+\": {\n                \"s\": [0.5, -0.2, 0.2, 0.1, 0.3],\n                \"eps\": [4.0, 4.0, 4.0, 4.0, 4.0],\n                \"E_bar\": 14.0\n            }\n        },\n        {\n            # Test case 3 (zero-sum strengths)\n            \"E0\": 10.0,\n            \"0+\": {\n                \"s\": [1.0, -1.0],\n                \"eps\": [2.0, 10.0],\n                \"E_bar\": 12.0\n            },\n            \"1+\": {\n                \"s\": [0.8, -0.8, 0.5, -0.5],\n                \"eps\": [1.0, 4.0, 7.0, 10.0],\n                \"E_bar\": 11.0\n            }\n        }\n    ]\n\n    # Memoization cache for the integral function to avoid re-computation.\n    integral_cache = {}\n\n    def integrand(x, d):\n        \"\"\"The integrand for the neutrino potential integral I(d).\"\"\"\n        return (x**2) / ((x + d) * (1 + x**2)**2)\n\n    def I(d):\n        \"\"\"Numerically evaluates the neutrino potential integral I(d).\"\"\"\n        if d in integral_cache:\n            return integral_cache[d]\n        \n        # Using quad for high-precision numerical integration.\n        # The absolute error tolerance ensures sufficient accuracy.\n        result, _ = quad(integrand, 0, X_MAX, args=(d,), epsabs=1e-12)\n        integral_cache[d] = result\n        return result\n\n    def calculate_matrix_elements(E0, multipole_data, g_coupling):\n        \"\"\"\n        Calculates non-closure and closure matrix elements for a single multipole.\n        \"\"\"\n        strengths = np.array(multipole_data[\"s\"])\n        excitations = np.array(multipole_data[\"eps\"])\n        closure_energy = multipole_data[\"E_bar\"]\n\n        # Non-closure calculation\n        m_non = 0.0\n        for s_k, eps_k in zip(strengths, excitations):\n            d_k = (E0 + eps_k) / LAMBDA\n            m_non += s_k * I(d_k)\n        \n        m_non *= g_coupling**2\n\n        # Closure calculation\n        sum_s = np.sum(strengths)\n        d_bar = closure_energy / LAMBDA\n        m_cl = sum_s * I(d_bar)\n        m_cl *= g_coupling**2\n        \n        return m_non, m_cl\n\n    results = []\n    for case in test_cases:\n        # Process J^pi = 0+ multipole\n        m_non_0, m_cl_0 = calculate_matrix_elements(case[\"E0\"], case[\"0+\"], G_V)\n        delta_m_0 = m_non_0 - m_cl_0\n        \n        # Process J^pi = 1+ multipole\n        m_non_1, m_cl_1 = calculate_matrix_elements(case[\"E0\"], case[\"1+\"], G_A)\n        delta_m_1 = m_non_1 - m_cl_1\n        \n        # Total difference\n        delta_m_tot = delta_m_0 + delta_m_1\n        \n        results.extend([delta_m_0, delta_m_1, delta_m_tot])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}