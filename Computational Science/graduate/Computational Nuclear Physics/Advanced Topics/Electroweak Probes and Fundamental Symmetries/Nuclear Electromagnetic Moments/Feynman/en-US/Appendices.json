{
    "hands_on_practices": [
        {
            "introduction": "In many-body quantum systems, calculating observables directly from a complex state vector $| \\Psi \\rangle$ can be computationally prohibitive. The one-body density matrix, $\\rho$, provides a far more efficient framework by encoding all the information needed to evaluate any one-body operator. This fundamental exercise  guides you through deriving and implementing the core formula $\\langle \\hat{O} \\rangle = \\mathrm{Tr}(O \\rho)$, a cornerstone of computational many-body physics, and verifies its essential invariance under basis transformations.",
            "id": "3574860",
            "problem": "You are tasked with implementing the evaluation of nuclear electromagnetic moments from one-body density matrices for a finite-dimensional single-particle basis. Your program must compute expectation values for a set of fixed test cases and produce a single line of output, as specified below.\n\nThe fundamental starting point is the following. In second-quantized form, an arbitrary one-body operator acts on a many-body state through matrix elements in a chosen single-particle basis. The one-body density matrix encodes the expectation values of bilinear fermionic operators in that basis. Use only the linearity of expectation values, the canonical anticommutation relations for fermions, and the definition of a one-body operator in second quantization. From these, derive the correct contraction between the matrix of a one-body operator and the one-body density matrix that yields the observable’s expectation value. Then, implement a computational routine that:\n- accepts Hermitian operator matrices and Hermitian one-body density matrices in a common orthonormal single-particle basis,\n- correctly handles complex-valued matrices,\n- and respects invariance of the expectation value under unitary changes of the single-particle basis.\n\nAll physical results in this problem represent electric quadrupole moments for a fixed nucleus and must be expressed in units of $e \\cdot \\mathrm{fm}^{2}$. Your program must output the results rounded to eight decimal places. Angles, when present, are given in radians.\n\nTest Suite. Implement the following four test cases. For each, compute the expectation value of the electromagnetic moment as a float in $e \\cdot \\mathrm{fm}^{2}$:\n\n- Case 1 (basic real matrices):\n  - Dimension $d = 2$.\n  - Operator matrix $O_{(1)}$ in $e \\cdot \\mathrm{fm}^{2}$:\n    $$\n    O_{(1)} = \\begin{bmatrix}\n    1.0  0.2 \\\\\n    0.2  -0.5\n    \\end{bmatrix}.\n    $$\n  - One-body density matrix $\\rho_{(1)}$ (dimensionless):\n    $$\n    \\rho_{(1)} = \\begin{bmatrix}\n    1.0  0.3 \\\\\n    0.3  1.0\n    \\end{bmatrix}.\n    $$\n  - Compute the expectation value in $e \\cdot \\mathrm{fm}^{2}$.\n\n- Case 2 (complex Hermitian matrices):\n  - Dimension $d = 3$.\n  - Operator matrix $O_{(2)}$ in $e \\cdot \\mathrm{fm}^{2}$:\n    $$\n    O_{(2)} =\n    \\begin{bmatrix}\n    0.5  0.1 + 0.2 i  0.0 \\\\\n    0.1 - 0.2 i  -0.3  0.05 \\\\\n    0.0  0.05  0.2\n    \\end{bmatrix}.\n    $$\n  - One-body density matrix $\\rho_{(2)}$ (dimensionless):\n    $$\n    \\rho_{(2)} =\n    \\begin{bmatrix}\n    1.0  0.2 - 0.1 i  0.0 \\\\\n    0.2 + 0.1 i  0.6  0.3 \\\\\n    0.0  0.3  0.2\n    \\end{bmatrix}.\n    $$\n  - Compute the expectation value in $e \\cdot \\mathrm{fm}^{2}$.\n\n- Case 3 (unitary-basis invariance check):\n  - Use the same $O_{(2)}$ and $\\rho_{(2)}$ as in Case 2.\n  - Define a unitary transformation $U$ as the product $U = R \\, D$, where:\n    - $R$ is a rotation in the $0$–$1$ subspace by angle $t = 0.7$ (radians):\n      $$\n      R = \\begin{bmatrix}\n      \\cos t  \\sin t  0 \\\\\n      -\\sin t  \\cos t  0 \\\\\n      0  0  1\n      \\end{bmatrix}.\n      $$\n    - $D$ is a diagonal phase matrix with phases $\\alpha = 0.2$ and $\\beta = -0.5$:\n      $$\n      D = \\mathrm{diag}\\!\\left(1, e^{i \\alpha}, e^{i \\beta}\\right).\n      $$\n  - Transform the inputs to the rotated basis via $O' = U^{\\dagger} O_{(2)} U$ and $\\rho' = U^{\\dagger} \\rho_{(2)} U$.\n  - Compute the expectation value using the rotated matrices $O'$ and $\\rho'$ in $e \\cdot \\mathrm{fm}^{2}$.\n\n- Case 4 (rank-one density from a normalized state vector):\n  - Dimension $d = 3$.\n  - Operator matrix $O_{(4)}$ in $e \\cdot \\mathrm{fm}^{2}$ is diagonal:\n    $$\n    O_{(4)} = \\mathrm{diag}\\!\\left(2.0, -1.0, 0.5\\right).\n    $$\n  - Define a normalized state vector $v$ with a nontrivial phase:\n    $$\n    v = \\begin{bmatrix}\n    \\sqrt{0.7} \\\\\n    e^{i \\cdot 0.3} \\sqrt{0.3} \\\\\n    0\n    \\end{bmatrix}.\n    $$\n  - Construct the one-body density matrix as $\\rho_{(4)} = v \\, v^{\\dagger}$ (dimensionless).\n  - Compute the expectation value in $e \\cdot \\mathrm{fm}^{2}$.\n\nAlgorithmic and numerical requirements:\n- Your implementation must be based on the foundational definitions described and must work for complex-valued inputs.\n- For all cases, ensure you use the same single-particle basis for the operator and density matrices when contracting.\n- For Case 3, perform the specified unitary similarity transformations before computing the expectation value and rely on the invariance under such transformations.\n- Round each final result to eight decimal places.\n- The program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces, for example, $[r_{1},r_{2},r_{3},r_{4}]$, where each $r_{k}$ is a float in $e \\cdot \\mathrm{fm}^{2}$ rounded to eight decimal places.\n\nYour output must be a single line with the format described above. No additional text should be printed.",
            "solution": "The problem requires the computation of the expectation value of a one-body observable, represented by a matrix $O$, in a many-body quantum state described by a one-body density matrix $\\rho$. The derivation of the computational formula from first principles provides the necessary theoretical grounding for the implementation.\n\nLet us consider a finite-dimensional single-particle Hilbert space spanned by an orthonormal basis $\\{|k\\rangle\\}_{k=1}^d$. In second quantization, an arbitrary one-body operator $\\hat{O}$ can be expressed in terms of fermionic creation ($a_k^\\dagger$) and annihilation ($a_k$) operators corresponding to this basis:\n$$\n\\hat{O} = \\sum_{i,j=1}^d O_{ij} a_i^\\dagger a_j\n$$\nwhere $O_{ij} = \\langle i | \\hat{O}_{\\mathrm{op}} | j \\rangle$ are the matrix elements of the first-quantized operator $\\hat{O}_{\\mathrm{op}}$ in the chosen basis. The matrix $O$ with elements $O_{ij}$ is Hermitian since physical observables correspond to Hermitian operators.\n\nThe state of the many-body system is described by a state vector $|\\Psi\\rangle$. All information about one-body observables is encoded in the one-body density matrix, $\\rho$. The elements of the density matrix are defined as the expectation values of bilinear products of creation and annihilation operators:\n$$\n\\rho_{ji} = \\langle \\Psi | a_i^\\dagger a_j | \\Psi \\rangle\n$$\nHere, the indices are ordered by a common convention in nuclear physics. The matrix $\\rho$ with elements $\\rho_{ij}$ is also Hermitian, which can be seen by taking the complex conjugate: $(\\rho_{ji})^* = \\langle \\Psi | a_i^\\dagger a_j | \\Psi \\rangle^* = \\langle \\Psi | (a_i^\\dagger a_j)^\\dagger | \\Psi \\rangle = \\langle \\Psi | a_j^\\dagger a_i | \\Psi \\rangle = \\rho_{ij}$.\n\nThe expectation value of the operator $\\hat{O}$ in the state $|\\Psi\\rangle$ is given by $\\langle \\hat{O} \\rangle = \\langle \\Psi | \\hat{O} | \\Psi \\rangle$. Substituting the second-quantized form of $\\hat{O}$ and using the linearity of the expectation value, we get:\n$$\n\\langle \\hat{O} \\rangle = \\left\\langle \\Psi \\left| \\sum_{i,j=1}^d O_{ij} a_i^\\dagger a_j \\right| \\Psi \\right\\rangle = \\sum_{i,j=1}^d O_{ij} \\langle \\Psi | a_i^\\dagger a_j | \\Psi \\rangle\n$$\nRecognizing the definition of the density matrix elements $\\rho_{ji}$, the expression becomes:\n$$\n\\langle \\hat{O} \\rangle = \\sum_{i,j=1}^d O_{ij} \\rho_{ji}\n$$\nThis sum is precisely the definition of the trace of the matrix product $O\\rho$. The $i$-th diagonal element of the product matrix $O\\rho$ is $(O\\rho)_{ii} = \\sum_{j=1}^d O_{ij} \\rho_{ji}$. Summing over $i$ gives the trace:\n$$\n\\mathrm{Tr}(O\\rho) = \\sum_{i=1}^d (O\\rho)_{ii} = \\sum_{i,j=1}^d O_{ij} \\rho_{ji}\n$$\nThus, the fundamental formula for the expectation value of a one-body operator is:\n$$\n\\langle \\hat{O} \\rangle = \\mathrm{Tr}(O \\rho)\n$$\nSince $O$ and $\\rho$ are Hermitian matrices ($O=O^\\dagger$, $\\rho=\\rho^\\dagger$), the expectation value must be a real number. This is confirmed by noting that $\\mathrm{Tr}(O\\rho)^* = \\mathrm{Tr}((O\\rho)^\\dagger) = \\mathrm{Tr}(\\rho^\\dagger O^\\dagger) = \\mathrm{Tr}(\\rho O)$. Using the cyclic property of the trace, $\\mathrm{Tr}(\\rho O) = \\mathrm{Tr}(O \\rho)$, we see that $\\mathrm{Tr}(O\\rho)^* = \\mathrm{Tr}(O \\rho)$, which proves the result is real.\n\nThis expectation value is a physical observable and must be independent of the choice of the single-particle basis. A change of basis from $\\{|k\\rangle\\}$ to a new orthonormal basis $\\{|k'\\rangle\\}$ is represented by a unitary matrix $U$. The operator and density matrices in the new basis are given by the similarity transformations $O' = U^\\dagger O U$ and $\\rho' = U^\\dagger \\rho U$. The expectation value computed in the new basis is:\n$$\n\\langle \\hat{O} \\rangle' = \\mathrm{Tr}(O'\\rho') = \\mathrm{Tr}\\left( (U^\\dagger O U) (U^\\dagger \\rho U) \\right)\n$$\nUsing $U U^\\dagger = I$ (where $I$ is the identity matrix) and the cyclic property of the trace:\n$$\n\\mathrm{Tr}(O'\\rho') = \\mathrm{Tr}(U^\\dagger O (U U^\\dagger) \\rho U) = \\mathrm{Tr}(U^\\dagger O \\rho U) = \\mathrm{Tr}((O \\rho) U U^\\dagger) = \\mathrm{Tr}(O\\rho)\n$$\nThis confirms the invariance of the expectation value under unitary transformations, a key principle tested in Case $3$.\n\nThe implementation directly applies these principles. The expectation value for each test case is computed by taking the trace of the product of the given operator and density matrices.\n\n- For Case $1$ and Case $2$, we compute $\\mathrm{Tr}(O\\rho)$ directly using the provided real and complex Hermitian matrices. The calculation for Case $2$ involves complex arithmetic, but the final result is guaranteed to be real.\n\n- For Case $3$, we first construct the unitary transformation matrix $U = R D$, where $R$ is a rotation and $D$ is a diagonal phase matrix. We then transform the operator and density matrices from Case $2$ to the new basis: $O' = U^\\dagger O_{(2)} U$ and $\\rho' = U^\\dagger \\rho_{(2)} U$. The expectation value is computed as $\\mathrm{Tr}(O'\\rho')$. The result must be identical to that of Case $2$, providing a numerical check of the basis invariance.\n\n- For Case $4$, the density matrix corresponds to a pure state represented by a normalized vector $v$. The density matrix is constructed as the projector $\\rho_{(4)} = v v^\\dagger$. The expectation value is then calculated as $\\mathrm{Tr}(O_{(4)} \\rho_{(4)})$. This is equivalent to the more familiar formula for pure states, $\\langle v | \\hat{O} | v \\rangle = v^\\dagger O_{(4)} v$, as can be shown with the trace's cyclic property: $\\mathrm{Tr}(O_{(4)} v v^\\dagger) = \\mathrm{Tr}(v^\\dagger O_{(4)} v)$. Since $v^\\dagger O_{(4)} v$ is a $1 \\times 1$ matrix (a scalar), its trace is the scalar itself.\n\nAll computations are performed using numerical matrix algebra, and the final results are rounded to eight decimal places as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the expectation value of electromagnetic moments for four test cases\n    based on the formula O = Tr(O * rho).\n    \"\"\"\n\n    results = []\n\n    # Case 1: Basic real matrices\n    O1 = np.array([\n        [1.0, 0.2],\n        [0.2, -0.5]\n    ], dtype=float)\n    rho1 = np.array([\n        [1.0, 0.3],\n        [0.3, 1.0]\n    ], dtype=float)\n    result1 = np.trace(O1 @ rho1)\n    results.append(result1)\n\n    # Case 2: Complex Hermitian matrices\n    O2 = np.array([\n        [0.5, 0.1 + 0.2j, 0.0],\n        [0.1 - 0.2j, -0.3, 0.05],\n        [0.0, 0.05, 0.2]\n    ], dtype=complex)\n    rho2 = np.array([\n        [1.0, 0.2 - 0.1j, 0.0],\n        [0.2 + 0.1j, 0.6, 0.3],\n        [0.0, 0.3, 0.2]\n    ], dtype=complex)\n    result2 = np.trace(O2 @ rho2)\n    results.append(np.real(result2))\n\n    # Case 3: Unitary-basis invariance check\n    t = 0.7\n    alpha = 0.2\n    beta = -0.5\n    \n    # Rotation matrix R\n    R = np.array([\n        [np.cos(t), np.sin(t), 0],\n        [-np.sin(t), np.cos(t), 0],\n        [0, 0, 1]\n    ], dtype=float)\n    \n    # Diagonal phase matrix D\n    D = np.diag([1, np.exp(1j * alpha), np.exp(1j * beta)])\n    \n    # Unitary transformation U\n    U = R @ D\n    U_dagger = U.conj().T\n    \n    # Transform matrices to the new basis\n    O_prime = U_dagger @ O2 @ U\n    rho_prime = U_dagger @ rho2 @ U\n    \n    result3 = np.trace(O_prime @ rho_prime)\n    results.append(np.real(result3))\n\n    # Case 4: Rank-one density from a normalized state vector\n    O4 = np.diag([2.0, -1.0, 0.5])\n    \n    # Normalized state vector v\n    v = np.array([\n        [np.sqrt(0.7)],\n        [np.exp(1j * 0.3) * np.sqrt(0.3)],\n        [0.0]\n    ], dtype=complex)\n    \n    # Construct the density matrix rho = v * v_dagger\n    rho4 = v @ v.conj().T\n    \n    result4 = np.trace(O4 @ rho4)\n    results.append(np.real(result4))\n\n    # Format the results to eight decimal places and print\n    formatted_results = map(lambda x: f\"{x:.8f}\", results)\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A central challenge in nuclear structure calculations is the use of finite basis sets, such as the harmonic oscillator basis, which inevitably breaks the translational invariance of the underlying Hamiltonian. This introduces spurious center-of-mass motion that can contaminate calculated observables like the electric quadrupole moment. In this essential practice , you will derive and implement the correction required to disentangle the physical intrinsic quadrupole moment from the unphysical center-of-mass contribution, a crucial step for obtaining meaningful results from basis-expansion methods.",
            "id": "3574822",
            "problem": "Consider a many-body nuclear state represented in a finite Harmonic Oscillator (HO) basis, where the finite truncation generally breaks exact translational invariance. The electric quadrupole moment operator must act on intrinsic coordinates to be physically meaningful. The spectroscopic quadrupole moment is defined as the laboratory-frame expectation value of the quadrupole operator in a stretched angular-momentum state. However, due to basis truncation, the Center of Mass (COM) does not exactly factorize, and one must correct the laboratory-frame quadrupole operator by subtracting the COM coordinate.\n\nStarting from the fundamental definitions of the electric quadrupole operator for protons and the COM coordinate for the full nucleus, derive, from first principles, the COM-corrected expression for the spectroscopic quadrupole moment in terms of laboratory-frame Cartesian coordinate moments. Use only the following base:\n- The electric quadrupole operator for protons in Cartesian form is defined by the one-body operator that, for each proton, contains terms proportional to $2 z^2 - x^2 - y^2$ and is additive over protons.\n- The Center of Mass (COM) coordinate of the full $A$-nucleon system is defined by $X_{\\mathrm{cm}} = \\frac{1}{A} \\sum_{i=1}^{A} x_i$, $Y_{\\mathrm{cm}} = \\frac{1}{A} \\sum_{i=1}^{A} y_i$, $Z_{\\mathrm{cm}} = \\frac{1}{A} \\sum_{i=1}^{A} z_i$.\n- Physical operators acting on intrinsic coordinates are obtained by replacing $x \\to x - X_{\\mathrm{cm}}$, $y \\to y - Y_{\\mathrm{cm}}$, $z \\to z - Z_{\\mathrm{cm}}$ before taking expectation values.\n\nDo not use any specialized nuclear-structure model formula that assumes rotational symmetry or relates intrinsic and laboratory quadrupole moments. Work directly with the additive one-body operator, the COM coordinates, and linearity of expectation values.\n\nYour program must implement the derived expressions in a numerically testable form that operates on a supplied test suite of aggregate expectation values. Specifically, for each test case, you are given:\n- $A$: total nucleon number (dimensionless).\n- $Z$: proton number (dimensionless).\n- $S^{(p)}_{x^2}$, $S^{(p)}_{y^2}$, $S^{(p)}_{z^2}$: laboratory-frame expectation values of $\\sum_{p=1}^{Z} x_p^2$, $\\sum_{p=1}^{Z} y_p^2$, $\\sum_{p=1}^{Z} z_p^2$ over protons (in $\\mathrm{fm}^2$).\n- $S^{(\\mathrm{all})}_{xx}$, $S^{(\\mathrm{all})}_{yy}$, $S^{(\\mathrm{all})}_{zz}$: laboratory-frame expectation values of $\\left(\\sum_{i=1}^{A} x_i\\right)^2$, $\\left(\\sum_{i=1}^{A} y_i\\right)^2$, $\\left(\\sum_{i=1}^{A} z_i\\right)^2$ over all nucleons (in $\\mathrm{fm}^2$).\n- $T_x$, $T_y$, $T_z$: laboratory-frame mixed second moments $T_x = \\left\\langle \\left(\\sum_{i=1}^{A} x_i\\right)\\left(\\sum_{p=1}^{Z} x_p\\right) \\right\\rangle$, $T_y = \\left\\langle \\left(\\sum_{i=1}^{A} y_i\\right)\\left(\\sum_{p=1}^{Z} y_p\\right) \\right\\rangle$, $T_z = \\left\\langle \\left(\\sum_{i=1}^{A} z_i\\right)\\left(\\sum_{p=1}^{Z} z_p\\right) \\right\\rangle$ (in $\\mathrm{fm}^2$).\n\nFrom the base above, derive an algorithm that computes, for each test case:\n1. The uncorrected laboratory-frame spectroscopic quadrupole moment,\n   $$Q_s^{\\mathrm{lab}} = e \\left( 2 S^{(p)}_{z^2} - S^{(p)}_{x^2} - S^{(p)}_{y^2} \\right),$$\n   expressed in $e\\,\\mathrm{fm}^2$.\n2. The COM correction term $\\Delta Q_s$ that must be added to $Q_s^{\\mathrm{lab}}$ to obtain the intrinsic, COM-corrected spectroscopic quadrupole moment,\n   $$Q_s^{\\mathrm{intr}} = Q_s^{\\mathrm{lab}} + \\Delta Q_s,$$\n   expressed in $e\\,\\mathrm{fm}^2$.\n3. The fractional change\n   $$\\delta = \\frac{Q_s^{\\mathrm{intr}} - Q_s^{\\mathrm{lab}}}{Q_s^{\\mathrm{lab}}},$$\n   expressed as a pure decimal number without a percent sign. If $Q_s^{\\mathrm{lab}} = 0$, define $\\delta = 0$ by convention.\n\nAll outputs for $Q_s^{\\mathrm{lab}}$ and $Q_s^{\\mathrm{intr}}$ must be reported in $e\\,\\mathrm{fm}^2$, rounded to six decimal places. All outputs for $\\delta$ must be rounded to six decimal places.\n\nTest Suite:\nProvide results for the following five test cases. Each tuple lists $\\left(A, Z, S^{(p)}_{x^2}, S^{(p)}_{y^2}, S^{(p)}_{z^2}, S^{(\\mathrm{all})}_{xx}, S^{(\\mathrm{all})}_{yy}, S^{(\\mathrm{all})}_{zz}, T_x, T_y, T_z\\right)$, with all second-moment quantities in $\\mathrm{fm}^2$:\n- Case $1$: $\\left(1, 1, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5\\right)$.\n- Case $2$: $\\left(4, 2, 1.42, 1.42, 1.42, 2.84, 2.84, 2.84, 1.42, 1.42, 1.42\\right)$.\n- Case $3$: $\\left(20, 10, 8.4, 8.4, 9.8, 16.8, 16.8, 20.0, 8.4, 8.4, 9.8\\right)$.\n- Case $4$: $\\left(24, 12, 9.6, 8.8, 12.0, 21.6, 19.2, 26.4, 9.6, 8.8, 12.0\\right)$.\n- Case $5$: $\\left(100, 40, 36.0, 36.0, 44.0, 90.0, 90.0, 110.0, 36.0, 36.0, 44.0\\right)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is a three-element list $[Q_s^{\\mathrm{lab}}, Q_s^{\\mathrm{intr}}, \\delta]$. For example, the overall output format must be\n\"[[q1_lab,q1_intr,d1],[q2_lab,q2_intr,d2],...]\" on a single line, with all numeric entries rounded to six decimals. Use $e = 1$ so that outputs are directly in $e\\,\\mathrm{fm}^2$.",
            "solution": "The problem requires the derivation of a correction to the spectroscopic electric quadrupole moment, which arises from the need to express the operator in intrinsic coordinates relative to the center of mass (COM) of the nucleus. This is particularly important in truncated basis calculations, such as those using a finite harmonic oscillator basis, where translational invariance is not exactly preserved. We will derive this correction from first principles.\n\nLet the elementary charge be $e$. As per the problem instructions, we will set $e=1$ for computational purposes, so all quadrupole moments are expressed in units of $e\\,\\mathrm{fm}^2$. The spectroscopic quadrupole moment operator is defined with respect to the laboratory reference frame's $z$-axis. It is a one-body operator, summed over all $Z$ protons in a nucleus of mass number $A$:\n$$\n\\hat{Q}_{\\mathrm{lab}} = \\sum_{p=1}^{Z} (2 z_p^2 - x_p^2 - y_p^2)\n$$\nThe uncorrected spectroscopic quadrupole moment, $Q_s^{\\mathrm{lab}}$, is the expectation value of this operator for the nuclear state in question:\n$$\nQ_s^{\\mathrm{lab}} = \\left\\langle \\hat{Q}_{\\mathrm{lab}} \\right\\rangle = \\left\\langle \\sum_{p=1}^{Z} (2 z_p^2 - x_p^2 - y_p^2) \\right\\rangle\n$$\nBy linearity of expectation values, this becomes:\n$$\nQ_s^{\\mathrm{lab}} = 2 \\left\\langle \\sum_{p=1}^{Z} z_p^2 \\right\\rangle - \\left\\langle \\sum_{p=1}^{Z} x_p^2 \\right\\rangle - \\left\\langle \\sum_{p=1}^{Z} y_p^2 \\right\\rangle\n$$\nUsing the provided definitions of the laboratory-frame expectation values $S^{(p)}_{k^2} = \\left\\langle \\sum_{p=1}^{Z} k_p^2 \\right\\rangle$ for $k \\in \\{x, y, z\\}$, we find:\n$$\nQ_s^{\\mathrm{lab}} = 2 S^{(p)}_{z^2} - S^{(p)}_{x^2} - S^{(p)}_{y^2}\n$$\nThis expression matches the one given in the problem statement for the first required calculation.\n\nThe physically meaningful quadrupole moment is defined in the intrinsic frame of the nucleus, which moves with the center of mass. The intrinsic operator, $\\hat{Q}_{\\mathrm{intr}}$, is obtained by replacing the laboratory coordinates of each proton, $(x_p, y_p, z_p)$, with its intrinsic coordinates, $(x'_p, y'_p, z'_p)$, defined relative to the COM coordinates $(X_{\\mathrm{cm}}, Y_{\\mathrm{cm}}, Z_{\\mathrm{cm}})$:\n$$\nx'_p = x_p - X_{\\mathrm{cm}}, \\quad y'_p = y_p - Y_{\\mathrm{cm}}, \\quad z'_p = z_p - Z_{\\mathrm{cm}}\n$$\nThe COM coordinates are defined as a sum over all $A$ nucleons (protons and neutrons):\n$$\nX_{\\mathrm{cm}} = \\frac{1}{A} \\sum_{i=1}^{A} x_i, \\quad Y_{\\mathrm{cm}} = \\frac{1}{A} \\sum_{i=1}^{A} y_i, \\quad Z_{\\mathrm{cm}} = \\frac{1}{A} \\sum_{i=1}^{A} z_i\n$$\nThe intrinsic quadrupole operator is therefore:\n$$\n\\hat{Q}_{\\mathrm{intr}} = \\sum_{p=1}^{Z} (2 (z'_p)^2 - (x'_p)^2 - (y'_p)^2) = \\sum_{p=1}^{Z} \\left[ 2(z_p - Z_{\\mathrm{cm}})^2 - (x_p - X_{\\mathrm{cm}})^2 - (y_p - Y_{\\mathrm{cm}})^2 \\right]\n$$\nWe expand the squared terms. For a generic coordinate $k \\in \\{x, y, z\\}$:\n$$\n\\sum_{p=1}^{Z} (k_p - K_{\\mathrm{cm}})^2 = \\sum_{p=1}^{Z} (k_p^2 - 2 k_p K_{\\mathrm{cm}} + K_{\\mathrm{cm}}^2) = \\left( \\sum_{p=1}^{Z} k_p^2 \\right) - 2 K_{\\mathrm{cm}} \\left( \\sum_{p=1}^{Z} k_p \\right) + Z K_{\\mathrm{cm}}^2\n$$\nApplying this expansion to the expression for $\\hat{Q}_{\\mathrm{intr}}$ yields:\n$$\n\\hat{Q}_{\\mathrm{intr}} = \\sum_{p=1}^{Z} \\left[ (2z_p^2 - x_p^2 - y_p^2) + (-4z_p Z_{\\mathrm{cm}} + 2x_p X_{\\mathrm{cm}} + 2y_p Y_{\\mathrm{cm}}) + (2Z_{\\mathrm{cm}}^2 - X_{\\mathrm{cm}}^2 - Y_{\\mathrm{cm}}^2) \\right]\n$$\nWe can group these terms:\n$$\n\\hat{Q}_{\\mathrm{intr}} = \\underbrace{\\left( \\sum_{p=1}^{Z} (2z_p^2 - x_p^2 - y_p^2) \\right)}_{\\hat{Q}_{\\mathrm{lab}}} + \\underbrace{\\left( 2 X_{\\mathrm{cm}} \\sum_{p=1}^{Z} x_p + 2 Y_{\\mathrm{cm}} \\sum_{p=1}^{Z} y_p - 4 Z_{\\mathrm{cm}} \\sum_{p=1}^{Z} z_p \\right)}_{\\Delta\\hat{Q}_{\\mathrm{cross}}} + \\underbrace{Z (2Z_{\\mathrm{cm}}^2 - X_{\\mathrm{cm}}^2 - Y_{\\mathrm{cm}}^2)}_{\\Delta\\hat{Q}_{\\mathrm{COM}}}\n$$\nThe intrinsic operator is the sum of the lab-frame operator and a correction term, $\\Delta\\hat{Q} = \\Delta\\hat{Q}_{\\mathrm{cross}} + \\Delta\\hat{Q}_{\\mathrm{COM}}$. To find the correction to the quadrupole moment, $\\Delta Q_s$, we take the expectation value of $\\Delta\\hatQ$.\n\nFirst, substitute the definitions of the COM coordinates into $\\Delta\\hat{Q}_{\\mathrm{cross}}$ and $\\Delta\\hat{Q}_{\\mathrm{COM}}$:\n$$\n\\Delta\\hat{Q}_{\\mathrm{cross}} = \\frac{2}{A} \\left( \\sum_{i=1}^{A} x_i \\right) \\left( \\sum_{p=1}^{Z} x_p \\right) + \\frac{2}{A} \\left( \\sum_{i=1}^{A} y_i \\right) \\left( \\sum_{p=1}^{Z} y_p \\right) - \\frac{4}{A} \\left( \\sum_{i=1}^{A} z_i \\right) \\left( \\sum_{p=1}^{Z} z_p \\right)\n$$\n$$\n\\Delta\\hat{Q}_{\\mathrm{COM}} = \\frac{Z}{A^2} \\left[ 2\\left( \\sum_{i=1}^{A} z_i \\right)^2 - \\left( \\sum_{i=1}^{A} x_i \\right)^2 - \\left( \\sum_{i=1}^{A} y_i \\right)^2 \\right]\n$$\nThe total correction $\\Delta Q_s$ is the expectation value $\\langle \\Delta\\hat{Q} \\rangle = \\langle \\Delta\\hat{Q}_{\\mathrm{cross}} \\rangle + \\langle \\Delta\\hat{Q}_{\\mathrm{COM}} \\rangle$. Using the expectation values provided in the problem statement:\n-   $T_k = \\left\\langle \\left(\\sum_{i=1}^{A} k_i\\right)\\left(\\sum_{p=1}^{Z} k_p\\right) \\right\\rangle$\n-   $S^{(\\mathrm{all})}_{kk} = \\left\\langle \\left(\\sum_{i=1}^{A} k_i\\right)^2 \\right\\rangle$\n\nThe expectation value of the cross term is:\n$$\n\\langle \\Delta\\hat{Q}_{\\mathrm{cross}} \\rangle = \\frac{2}{A} T_x + \\frac{2}{A} T_y - \\frac{4}{A} T_z = \\frac{2}{A} (T_x + T_y - 2 T_z)\n$$\nThe expectation value of the COM term is:\n$$\n\\langle \\Delta\\hat{Q}_{\\mathrm{COM}} \\rangle = \\frac{Z}{A^2} \\left[ 2 \\left\\langle \\left( \\sum_{i=1}^{A} z_i \\right)^2 \\right\\rangle - \\left\\langle \\left( \\sum_{i=1}^{A} x_i \\right)^2 \\right\\rangle - \\left\\langle \\left( \\sum_{i=1}^{A} y_i \\right)^2 \\right\\rangle \\right]\n$$\n$$\n\\langle \\Delta\\hat{Q}_{\\mathrm{COM}} \\rangle = \\frac{Z}{A^2} (2 S^{(\\mathrm{all})}_{zz} - S^{(\\mathrm{all})}_{xx} - S^{(\\mathrm{all})}_{yy})\n$$\nCombining these gives the final expression for the COM correction to the spectroscopic quadrupole moment:\n$$\n\\Delta Q_s = \\frac{2}{A} (T_x + T_y - 2 T_z) + \\frac{Z}{A^2} (2 S^{(\\mathrm{all})}_{zz} - S^{(\\mathrm{all})}_{xx} - S^{(\\mathrm{all})}_{yy})\n$$\nThe intrinsic, COM-corrected quadrupole moment is then $Q_s^{\\mathrm{intr}} = Q_s^{\\mathrm{lab}} + \\Delta Q_s$. The fractional change is $\\delta = \\Delta Q_s / Q_s^{\\mathrm{lab}}$, with the special case $\\delta = 0$ if $Q_s^{\\mathrm{lab}} = 0$.\n\nThe algorithm to be implemented is as follows for each test case:\n1.  Read the input parameters: $A, Z, S^{(p)}_{x^2}, S^{(p)}_{y^2}, S^{(p)}_{z^2}, S^{(\\mathrm{all})}_{xx}, S^{(\\mathrm{all})}_{yy}, S^{(\\mathrm{all})}_{zz}, T_x, T_y, T_z$.\n2.  Calculate the uncorrected lab-frame moment: $Q_s^{\\mathrm{lab}} = 2 S^{(p)}_{z^2} - S^{(p)}_{x^2} - S^{(p)}_{y^2}$.\n3.  Calculate the COM correction term: $\\Delta Q_s = \\frac{2}{A} (T_x + T_y - 2 T_z) + \\frac{Z}{A^2} (2 S^{(\\mathrm{all})}_{zz} - S^{(\\mathrm{all})}_{xx} - S^{(\\mathrm{all})}_{yy})$.\n4.  Calculate the intrinsic moment: $Q_s^{\\mathrm{intr}} = Q_s^{\\mathrm{lab}} + \\Delta Q_s$.\n5.  Calculate the fractional change $\\delta$. If $Q_s^{\\mathrm{lab}}$ is non-zero, $\\delta = \\Delta Q_s / Q_s^{\\mathrm{lab}}$. Otherwise, $\\delta = 0$.\n6.  Round each of $Q_s^{\\mathrm{lab}}$, $Q_s^{\\mathrm{intr}}$, and $\\delta$ to six decimal places.\n7.  Format the results as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the COM-corrected spectroscopic quadrupole moment based on\n    a set of aggregate expectation values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains:\n    # (A, Z, S_p_x2, S_p_y2, S_p_z2, S_all_xx, S_all_yy, S_all_zz, T_x, T_y, T_z)\n    test_cases = [\n        (1, 1, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5),\n        (4, 2, 1.42, 1.42, 1.42, 2.84, 2.84, 2.84, 1.42, 1.42, 1.42),\n        (20, 10, 8.4, 8.4, 9.8, 16.8, 16.8, 20.0, 8.4, 8.4, 9.8),\n        (24, 12, 9.6, 8.8, 12.0, 21.6, 19.2, 26.4, 9.6, 8.8, 12.0),\n        (100, 40, 36.0, 36.0, 44.0, 90.0, 90.0, 110.0, 36.0, 36.0, 44.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, Z, Sp_x2, Sp_y2, Sp_z2, Sall_xx, Sall_yy, Sall_zz, Tx, Ty, Tz = case\n        \n        # 1. Calculate the uncorrected laboratory-frame spectroscopic quadrupole moment (e=1)\n        q_lab = 2 * Sp_z2 - Sp_x2 - Sp_y2\n\n        # 2. Calculate the COM correction term\n        # The derivation yields:\n        # delta_q = (2/A)*(Tx + Ty - 2*Tz) + (Z/A^2)*(2*Sall_zz - Sall_xx - Sall_yy)\n        term_T = (2.0 / A) * (Tx + Ty - 2.0 * Tz)\n        term_S_all = (float(Z) / (A**2)) * (2.0 * Sall_zz - Sall_xx - Sall_yy)\n        delta_q = term_T + term_S_all\n\n        # 3. Calculate the COM-corrected intrinsic quadrupole moment\n        q_intr = q_lab + delta_q\n\n        # 4. Calculate the fractional change\n        if q_lab == 0:\n            delta = 0.0\n        else:\n            delta = delta_q / q_lab\n            \n        # 5. Round all results to six decimal places\n        q_lab_rounded = round(q_lab, 6)\n        q_intr_rounded = round(q_intr, 6)\n        delta_rounded = round(delta, 6)\n        \n        results.append([q_lab_rounded, q_intr_rounded, delta_rounded])\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists, with no spaces.\n    # Ex: [[q1_lab,q1_intr,d1],[q2_lab,q2_intr,d2]]\n    formatted_cases = []\n    for res in results:\n        # Convert each rounded number to string representation. str() handles \n        # dropping unnecessary trailing zeros (e.g., 16.0 instead of 16.000000).\n        case_str = f\"[{str(res[0])},{str(res[1])},{str(res[2])}]\"\n        formatted_cases.append(case_str)\n    \n    print(f\"[{','.join(formatted_cases)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A primary goal of nuclear theory is to connect with experimental measurements. Shell-model calculations, performed in a truncated model space, rely on effective operators to account for excluded configurations; a key example is the use of effective charges ($e_p^{\\mathrm{eff}}$, $e_n^{\\mathrm{eff}}$) for electromagnetic moments. This advanced practice  demonstrates how to determine these crucial parameters by framing the task as a linear inverse problem, using experimental data to constrain the model and providing a robust numerical solution applicable even when the data is limited or noisy.",
            "id": "3574819",
            "problem": "You are given a computational task concerning nuclear electromagnetic moments in the nuclear shell model. The objective is to analyze the sensitivity of the spectroscopic quadrupole moment to proton and neutron effective charges and to determine effective charges that reproduce experimental spectroscopic quadrupole moments. Your derivation and algorithm must start from fundamental definitions of the electromagnetic quadrupole tensor and standard angular-momentum algebra without using target shortcuts.\n\nUse the following fundamental base:\n- The electric quadrupole tensor operator for a nucleus is built from the nucleus’ charge distribution and position operators, entering the spherical tensor of rank $2$.\n- In the shell model, the total electric quadrupole operator is the sum of proton and neutron contributions, where neutrons contribute effectively through core polarization via an effective charge assignment.\n- The matrix elements of spherical tensor operators between angular-momentum eigenstates factorize via the Wigner–Eckart theorem, which separates angular dependence from the reduced matrix elements.\n- The spectroscopic quadrupole moment of a state of total angular momentum $J$ is defined as the laboratory-frame expectation value of the $M=J$ projection of the quadrupole tensor.\n\nFrom this base, derive a linear model that relates the spectroscopic quadrupole moment of a state to a combination of a proton contribution and a neutron contribution, each scaled by an effective charge. Show how the sensitivity of the spectroscopic quadrupole moment to each effective charge is determined by the appropriate structural coefficient for that state. Then, derive a well-posed computational method to infer the effective charges from one or more measured spectroscopic quadrupole moments by solving a linear inverse problem. Your method must handle the cases of an exact system, an overdetermined system, and an underdetermined system using a stable approach justified from first principles.\n\nImplement a program that:\n- Constructs the linear system across one or more states using arrays of state-dependent structural coefficients for protons and for neutrons, and the corresponding experimental spectroscopic quadrupole moments.\n- Solves for the proton and neutron effective charges by minimizing the squared misfit with optional Tikhonov (ridge) regularization, which guarantees a unique minimum-norm solution in underdetermined or ill-conditioned cases.\n- Computes the local sensitivity of the spectroscopic quadrupole moment to each effective charge for each state by differentiating the derived linear model. The sensitivities do not need to be printed, but they must guide the algorithmic design.\n\nNumerical and physical setup for the test suite:\n- For each test case below, you are given arrays of bare structural coefficients corresponding to states with angular momentum $J$. These coefficients are the spectroscopic contributions of the bare proton and bare neutron quadrupole operators for the corresponding state, expressed in $\\mathrm{fm}^2$. The measured spectroscopic quadrupole moments are given in $e \\,\\mathrm{fm}^2$. Effective charges are dimensionless and should be reported without units. Each test case also specifies a nonnegative regularization strength $\\lambda$; use $\\lambda=0$ to recover the Moore–Penrose minimum-norm solution and $\\lambda0$ for Tikhonov regularization.\n- Let the design matrix be constructed from rows that combine the bare proton and bare neutron spectroscopic coefficients for each state, and let the data vector collect the measured spectroscopic quadrupole moments of those states. Solve the linear inverse problem by minimizing the squared residual plus the regularization penalty of strength $\\lambda$.\n\nTest suite (three cases):\n- Case A (happy path, exactly determined):\n  - Number of states: $N=\\{2\\}$ with $J=\\{2,2\\}$.\n  - Bare proton coefficients in $\\mathrm{fm}^2$: $q_p = [\\,12.0,\\,-8.0\\,]$.\n  - Bare neutron coefficients in $\\mathrm{fm}^2$: $q_n = [\\,3.5,\\,2.0\\,]$.\n  - Experimental spectroscopic quadrupole moments in $e\\,\\mathrm{fm}^2$: $Q_s^{(\\mathrm{exp})} = [\\,17.35,\\,-9.4\\,]$.\n  - Regularization strength: $\\lambda = 0.0$.\n- Case B (underdetermined, one equation, two unknowns; recover minimum-norm solution):\n  - Number of states: $N=\\{1\\}$ with $J=\\{2\\}$.\n  - Bare proton coefficient in $\\mathrm{fm}^2$: $q_p = [\\,10.0\\,]$.\n  - Bare neutron coefficient in $\\mathrm{fm}^2$: $q_n = [\\,4.0\\,]$.\n  - Experimental spectroscopic quadrupole moment in $e\\,\\mathrm{fm}^2$: $Q_s^{(\\mathrm{exp})} = [\\,18.0\\,]$.\n  - Regularization strength: $\\lambda = 0.0$.\n- Case C (overdetermined with near-collinearity to test stability and sensitivity):\n  - Number of states: $N=\\{3\\}$ with $J=\\{2,2,2\\}$.\n  - Bare proton coefficients in $\\mathrm{fm}^2$: $q_p = [\\,5.0,\\,15.0,\\,-7.0\\,]$.\n  - Bare neutron coefficients in $\\mathrm{fm}^2$: $q_n = [\\,2.0,\\,6.0,\\,3.0\\,]$.\n  - Experimental spectroscopic quadrupole moments in $e\\,\\mathrm{fm}^2$: $Q_s^{(\\mathrm{exp})} = [\\,8.2,\\,24.6,\\,-8.0\\,]$.\n  - Regularization strength: $\\lambda = 0.0$.\n\nProgramming requirements:\n- Build, for each case, the design matrix of size $N\\times 2$ by stacking rows formed from the corresponding bare coefficients.\n- Solve for the two-component vector of effective charges by minimizing the regularized least squares objective with regularization strength $\\lambda$. Use a numerically stable method. If $\\lambda=0$, this reduces to the Moore–Penrose pseudoinverse (minimum-norm) solution. If $\\lambda0$, this corresponds to Tikhonov regularization.\n- The program must compute the solution for each test case and output only the proton and neutron effective charges per case in the specified final format.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each item must be a sublist $[e_p^{\\mathrm{eff}},e_n^{\\mathrm{eff}}]$ with both values rounded to six decimal places, for the corresponding test case in the order A, B, C. For example: $[[e_{p,A},e_{n,A}],[e_{p,B},e_{n,B}],[e_{p,C},e_{n,C}]]$.\n- All outputs are dimensionless numbers. No physical units should be printed.",
            "solution": "We begin from the electromagnetic quadrupole tensor operator for a finite nucleus. The electric quadrupole tensor in spherical components is defined by\n$$\n\\hat{Q}_{2\\mu} = \\sum_{i=1}^{A} \\hat{q}_i \\, r_i^2 \\, Y_{2\\mu}(\\hat{\\mathbf{r}}_i),\n$$\nwhere $A$ is the nucleon number, $\\hat{q}_i$ is the charge operator acting on the $i$-th nucleon, $r_i$ is its radial coordinate, and $Y_{2\\mu}$ is a spherical harmonic. In a shell-model description, neutrons contribute to electromagnetic observables through polarization of the core, which is accounted for by introducing proton and neutron effective charges, denoted $e_p^{\\mathrm{eff}}$ and $e_n^{\\mathrm{eff}}$, as dimensionless scaling factors multiplies the corresponding bare proton and bare neutron quadrupole operators.\n\nLet $\\lvert J M \\rangle$ denote a nuclear eigenstate with total angular momentum $J$ and projection $M$. The spectroscopic quadrupole moment $Q_s$ is defined as the laboratory expectation value of the $\\mu=0$ component in the stretched projection $M=J$,\n$$\nQ_s(J) \\equiv \\langle J J \\lvert \\hat{Q}_{20} \\rvert J J \\rangle.\n$$\nBy the Wigner–Eckart theorem, the reduced matrix elements of $\\hat{Q}_{2\\mu}$ factorize angular momentum dependence, so that $Q_s(J)$ is proportional to the corresponding reduced matrix element $\\langle J \\lVert \\hat{Q}_2 \\rVert J \\rangle$ multiplied by a known angular factor. In the shell model, the operator decomposes as a sum of a proton part and a neutron part. Introducing effective charges yields a linear scaling of the bare proton and bare neutron contributions to $Q_s(J)$:\n$$\nQ_s(J) = e_p^{\\mathrm{eff}}\\; q_p(J) + e_n^{\\mathrm{eff}}\\; q_n(J),\n$$\nwhere $q_p(J)$ and $q_n(J)$ are the spectroscopic contributions (with units $\\mathrm{fm}^2$) obtained from the bare proton and bare neutron quadrupole operators, respectively, for the state of spin $J$. This linearity follows directly from the linearity of expectation values and the decomposition of the operator into proton and neutron parts multiplied by scalar effective charges.\n\nSensitivity. Differentiating the linear model with respect to $e_p^{\\mathrm{eff}}$ and $e_n^{\\mathrm{eff}}$ immediately gives the sensitivities for a given state:\n$$\n\\frac{\\partial Q_s(J)}{\\partial e_p^{\\mathrm{eff}}} = q_p(J), \\qquad\n\\frac{\\partial Q_s(J)}{\\partial e_n^{\\mathrm{eff}}} = q_n(J).\n$$\nHence, the structural coefficients $q_p(J)$ and $q_n(J)$ completely determine how a small change in each effective charge impacts $Q_s(J)$.\n\nInverse problem across multiple states. For $N$ measured states, we gather the linear relations in matrix form. Let\n$$\n\\mathbf{A} = \n\\begin{bmatrix}\nq_p(J_1)  q_n(J_1) \\\\\n\\vdots  \\vdots \\\\\nq_p(J_N)  q_n(J_N)\n\\end{bmatrix}\n\\in \\mathbb{R}^{N\\times 2}, \\quad\n\\mathbf{e} =\n\\begin{bmatrix}\ne_p^{\\mathrm{eff}} \\\\ e_n^{\\mathrm{eff}}\n\\end{bmatrix} \\in \\mathbb{R}^{2}, \\quad\n\\mathbf{b} =\n\\begin{bmatrix}\nQ_s^{(\\mathrm{exp})}(J_1) \\\\ \\vdots \\\\ Q_s^{(\\mathrm{exp})}(J_N)\n\\end{bmatrix}\\in \\mathbb{R}^{N}.\n$$\nThe forward model is $\\mathbf{A}\\mathbf{e}=\\mathbf{b}$. To infer $\\mathbf{e}$ robustly for arbitrary $N$, we pose the regularized least-squares problem\n$$\n\\min_{\\mathbf{e}\\in\\mathbb{R}^2}\\; \\lVert \\mathbf{A}\\mathbf{e}-\\mathbf{b}\\rVert_2^2 + \\lambda^2 \\lVert \\mathbf{e}\\rVert_2^2,\n$$\nwith regularization strength $\\lambda \\ge 0$. This has the unique solution\n$$\n\\mathbf{e}_\\lambda = (\\mathbf{A}^\\mathsf{T}\\mathbf{A} + \\lambda^2 \\mathbf{I})^{-1}\\mathbf{A}^\\mathsf{T}\\mathbf{b}.\n$$\nEquivalently, in terms of the singular value decomposition $\\mathbf{A}=\\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\mathsf{T}$ with singular values $\\{\\sigma_k\\}$, the solution is\n$$\n\\mathbf{e}_\\lambda = \\mathbf{V}\\,\\mathrm{diag}\\!\\left(\\frac{\\sigma_k}{\\sigma_k^2+\\lambda^2}\\right)\\mathbf{U}^\\mathsf{T}\\mathbf{b},\n$$\nwhich reduces to the Moore–Penrose minimum-norm pseudoinverse solution when $\\lambda=0$. This SVD-based form is numerically stable and reveals sensitivity to small singular values (ill-conditioning) controlled by $\\lambda$.\n\nAlgorithmic design for the program:\n- For each test case, build $\\mathbf{A}$ from the given $q_p(J_i)$ and $q_n(J_i)$ and form $\\mathbf{b}$ from $Q_s^{(\\mathrm{exp})}(J_i)$.\n- Compute $\\mathbf{e}_\\lambda$ using the SVD-based formula above with the specified $\\lambda$.\n- Although the sensitivities $\\partial Q_s/\\partial e_p^{\\mathrm{eff}}=q_p(J_i)$ and $\\partial Q_s/\\partial e_n^{\\mathrm{eff}}=q_n(J_i)$ are not printed, they directly inform the Jacobian used by the solver (the matrix $\\mathbf{A}$ is precisely the Jacobian).\n- Round each component of $\\mathbf{e}_\\lambda$ to six decimal places and output per the required format.\n\nAnalytical checks for the provided test suite:\n- Case A:\n  - Data: $q_p=[\\,12.0,\\,-8.0\\,]$, $q_n=[\\,3.5,\\,2.0\\,]$, $Q_s^{(\\mathrm{exp})}=[\\,17.35,\\,-9.4\\,]$, $\\lambda=0.0$.\n  - The linear system is\n    $12.0\\,e_p^{\\mathrm{eff}} + 3.5\\,e_n^{\\mathrm{eff}} = 17.35$ and $-8.0\\,e_p^{\\mathrm{eff}} + 2.0\\,e_n^{\\mathrm{eff}} = -9.4$,\n    yielding exactly $e_p^{\\mathrm{eff}}=1.3$ and $e_n^{\\mathrm{eff}}=0.5$.\n- Case B:\n  - Data: $q_p=[\\,10.0\\,]$, $q_n=[\\,4.0\\,]$, $Q_s^{(\\mathrm{exp})}=[\\,18.0\\,]$, $\\lambda=0.0$.\n  - With one equation and two unknowns, the Moore–Penrose minimum-norm solution aligns with the row of $\\mathbf{A}$:\n    $\\mathbf{e}_0 = \\mathbf{A}^\\mathsf{T}(\\mathbf{A}\\mathbf{A}^\\mathsf{T})^{-1}\\mathbf{b}\n    = \\dfrac{18.0}{10.0^2+4.0^2}\\begin{bmatrix}10.0\\\\4.0\\end{bmatrix}\n    = \\begin{bmatrix}1.551724\\ldots\\\\0.620689\\ldots\\end{bmatrix}$.\n- Case C:\n  - Data: $q_p=[\\,5.0,\\,15.0,\\,-7.0\\,]$, $q_n=[\\,2.0,\\,6.0,\\,3.0\\,]$, $Q_s^{(\\mathrm{exp})}=[\\,8.2,\\,24.6,\\,-8.0\\,]$, $\\lambda=0.0$.\n  - The data are exactly consistent with $e_p^{\\mathrm{eff}}=1.4$ and $e_n^{\\mathrm{eff}}=0.6$, hence the least-squares solution recovers these values exactly.\n\nTherefore, the program must compute for the three cases the vectors\n$[\\,e_p^{\\mathrm{eff}},e_n^{\\mathrm{eff}}\\,]$ and print a single line of the form\n$[[e_{p,A},e_{n,A}],[e_{p,B},e_{n,B}],[e_{p,C},e_{n,C}]]$ with each number rounded to six decimal places. All outputs are dimensionless, so no physical units appear in the printed line.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef tikhonov_solution(A: np.ndarray, b: np.ndarray, lam: float) - np.ndarray:\n    \"\"\"\n    Compute the 2-parameter Tikhonov-regularized solution e to minimize\n    ||A e - b||_2^2 + lam^2 ||e||_2^2 using an SVD-based filter.\n    For lam=0, this reduces to the Moore-Penrose minimum-norm solution.\n    \"\"\"\n    # SVD of A\n    U, s, VT = np.linalg.svd(A, full_matrices=False)\n    # Build filter factors sigma / (sigma^2 + lam^2)\n    if lam  0:\n        raise ValueError(\"Regularization parameter lam must be nonnegative.\")\n    if lam == 0.0:\n        # Avoid division by zero: only invert nonzero singular values\n        tol = np.finfo(float).eps * max(A.shape) * (s[0] if s.size  0 else 1.0)\n        inv_s = np.array([1/si if si  tol else 0.0 for si in s])\n        e = VT.T @ (inv_s * (U.T @ b))\n    else:\n        filt = s / (s**2 + lam**2)\n        e = VT.T @ (filt * (U.T @ b))\n    return e\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case A: exactly determined (2 states)\n    qp_A = np.array([12.0, -8.0], dtype=float)   # fm^2\n    qn_A = np.array([3.5,  2.0], dtype=float)    # fm^2\n    Qexp_A = np.array([17.35, -9.4], dtype=float)  # e fm^2\n    lam_A = 0.0\n\n    # Case B: underdetermined (1 state), minimum-norm solution\n    qp_B = np.array([10.0], dtype=float)  # fm^2\n    qn_B = np.array([4.0], dtype=float)   # fm^2\n    Qexp_B = np.array([18.0], dtype=float)  # e fm^2\n    lam_B = 0.0\n\n    # Case C: overdetermined with near-collinearity\n    qp_C = np.array([5.0, 15.0, -7.0], dtype=float)  # fm^2\n    qn_C = np.array([2.0, 6.0, 3.0], dtype=float)    # fm^2\n    Qexp_C = np.array([8.2, 24.6, -8.0], dtype=float)  # e fm^2\n    lam_C = 0.0\n\n    test_cases = [\n        (qp_A, qn_A, Qexp_A, lam_A),\n        (qp_B, qn_B, Qexp_B, lam_B),\n        (qp_C, qn_C, Qexp_C, lam_C),\n    ]\n\n    results = []\n    for qp, qn, Qexp, lam in test_cases:\n        # Construct A and b\n        A = np.column_stack([qp, qn])  # shape (N, 2)\n        b = Qexp\n\n        # Solve for effective charges using Tikhonov/pseudoinverse\n        e_eff = tikhonov_solution(A, b, lam)  # [e_p_eff, e_n_eff]\n\n        # Round to six decimals for final output\n        ep = float(f\"{e_eff[0]:.6f}\")\n        en = float(f\"{e_eff[1]:.6f}\")\n        results.append([ep, en])\n\n    # Final print statement in the exact required format.\n    # Produce e.g., [[epA,enA],[epB,enB],[epC,enC]]\n    formatted = \"[\" + \",\".join(f\"[{pair[0]},{pair[1]}]\" for pair in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        }
    ]
}