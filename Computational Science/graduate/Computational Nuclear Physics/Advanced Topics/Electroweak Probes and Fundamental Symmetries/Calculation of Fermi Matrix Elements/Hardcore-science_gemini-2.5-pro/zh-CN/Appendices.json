{
    "hands_on_practices": [
        {
            "introduction": "在计算物理可观测量之前，至关重要的是要理解我们计算框架内的数学工具的行为。本练习  旨在探究作为 $SU(2)$ 李代数基础的同位旋算符基本对易关系，是如何受到模型空间截断这一必要操作影响的。通过数值计算对易子，您将直接观察到这个基本代数的破缺，并评估一种恢复它的方法，这是发展有效算符理论中的一个关键概念。",
            "id": "3546702",
            "problem": "考虑作用于同位旋空间上的二阶特殊酉群 ($SU(2)$)，该空间由总同位旋 $T$ 表征，其基态为 $\\lvert T,m\\rangle$，其中 $m \\in \\{-T,-T+1,\\dots,T\\}$。与费米 $\\beta$ 衰变相关的费米跃迁算符是同位旋升降算符 $ \\hat{T}_\\pm $，同量异位素类比态之间的费米矩阵元 $M_F$ 是跃迁振幅 $ \\langle T,m_f \\lvert \\hat{T}_\\pm \\rvert T,m_i \\rangle $，其中 $m_f = m_i \\pm 1$。在具有截断模型空间的计算环境中，引入有效算符以在截断空间内作用；然而，截断会改变算符代数。\n\n从以下基本出发：在 $\\lvert T,m\\rangle$ 基中，$SU(2)$ 李代数表示由阶梯作用 $ \\hat{T}_\\pm \\lvert T,m\\rangle = \\sqrt{T(T+1)-m(m\\pm 1)} \\, \\lvert T,m\\pm 1\\rangle $ 和对角作用 $ \\hat{T}_z \\lvert T,m\\rangle = m \\lvert T,m\\rangle $ 定义。两个算符 $ \\hat{A} $ 和 $ \\hat{B} $ 的对易子为 $ [\\hat{A},\\hat{B}] = \\hat{A}\\hat{B} - \\hat{B}\\hat{A} $。矩阵 $ \\hat{X} $ 的弗罗贝尼乌斯范数为 $ \\lVert \\hat{X} \\rVert_F = \\sqrt{\\sum_{i,j} \\lvert X_{ij} \\rvert^2} $。\n\n你必须实现一个程序，该程序为给定的 $T$ 构建精确的 $SU(2)$ 算符 $ \\hat{T}_+ $、$ \\hat{T}_- $ 和 $ \\hat{T}_z $，然后将它们投影到由 $m$ 值的子集张成的指定截断子空间中。在截断空间内定义两组算符：\n\n1. 投影算符：$ \\hat{T}_\\pm^{(P)} = P \\hat{T}_\\pm P $ 和 $ \\hat{T}_z^{(P)} = P \\hat{T}_z P $，其中 $P$ 是到截断子空间的投影算符。\n2. 代数恢复的有效算符：$ \\hat{T}_\\pm^{(\\mathrm{eff})} = \\hat{T}_\\pm^{(P)} $ 和 $ \\hat{T}_z^{(\\mathrm{eff})} = \\tfrac{1}{2} \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] $。\n\n对于下方的每个测试用例，计算三个量：\n\n- 投影算符集中的代数破坏：$ D_P = \\left\\lVert \\left[ \\hat{T}_+^{(P)}, \\hat{T}_-^{(P)} \\right] - 2 \\hat{T}_z^{(P)} \\right\\rVert_F $。\n- 代数恢复的有效算符集中的代数破坏：$ D_{\\mathrm{eff}} = \\left\\lVert \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] - 2 \\hat{T}_z^{(\\mathrm{eff})} \\right\\rVert_F $。\n- 对于指定的跃迁 $ m_i \\to m_f $，使用 $ \\hat{T}_\\pm^{(\\mathrm{eff})} $ 在截断空间内计算的费米矩阵元相对于使用 $ \\hat{T}_\\pm $ 在全空间中计算的精确矩阵元的绝对误差：$ E_F = \\left\\lvert \\langle T,m_f \\lvert \\hat{T}_\\pm^{(\\mathrm{eff})} \\rvert T,m_i \\rangle_{\\text{trunc}} - \\langle T,m_f \\lvert \\hat{T}_\\pm \\rvert T,m_i \\rangle_{\\text{full}} \\right\\rvert $。如果 $m_i$ 或 $m_f$ 不在截断子空间中，则定义截断矩阵元为 $0$。\n\n使用以下测试套件，它涵盖了完整空间、连续截断以及包含允许和不允许的跃迁的非连续截断：\n\n- 测试用例 1：$ T = 2 $，截断的 $ m $ 集为 $ \\{-2,-1,0,1,2\\} $，算符为 $ \\hat{T}_+ $，初始 $ m_i = 0 $（因此 $ m_f = 1 $）。\n- 测试用例 2：$ T = 2 $，截断的 $ m $ 集为 $ \\{-2,-1,0,1\\} $，算符为 $ \\hat{T}_+ $，初始 $ m_i = 1 $（因此 $ m_f = 2 $）。\n- 测试用例 3：$ T = \\tfrac{3}{2} $，截断的 $ m $ 集为 $ \\{-\\tfrac{3}{2},-\\tfrac{1}{2},\\tfrac{1}{2}\\} $，算符为 $ \\hat{T}_+ $，初始 $ m_i = -\\tfrac{1}{2} $（因此 $ m_f = \\tfrac{1}{2} $）。\n- 测试用例 4：$ T = \\tfrac{3}{2} $，截断的 $ m $ 集为 $ \\{-\\tfrac{3}{2},\\tfrac{1}{2},\\tfrac{3}{2}\\} $，算符为 $ \\hat{T}_- $，初始 $ m_i = \\tfrac{1}{2} $（因此 $ m_f = -\\tfrac{1}{2} $）。\n- 测试用例 5：$ T = \\tfrac{5}{2} $，截断的 $ m $ 集为 $ \\{-\\tfrac{5}{2},-\\tfrac{3}{2},-\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{3}{2}\\} $，算符为 $ \\hat{T}_+ $，初始 $ m_i = \\tfrac{3}{2} $（因此 $ m_f = \\tfrac{5}{2} $）。\n\n你的程序应生成单行输出，其中包含一个逗号分隔的列表的列表，每个内部列表按测试用例的顺序排列为 $[D_P, D_{\\mathrm{eff}}, E_F]$，并用方括号括起来。例如，输出格式必须与 $[[d_1,d_2,e_1],[d_3,d_4,e_2],\\dots]$ 完全一样，其中包含数值。",
            "solution": "该问题具有科学依据，提法明确且客观。它提出了一个清晰定义的计算任务，该任务植根于量子力学的标准原理，特别是应用于原子核同位旋的 $SU(2)$ 李群表示论。模型空间截断、有效算符以及对由此产生的算符代数破坏的定量分析，都是计算多体物理学中的标准课题。所有必要的定义、常数和测试用例都已提供，不存在内部矛盾或含糊之处。因此，该问题是有效的，可以构建解决方案。\n\n解决方案将通过以下主要步骤来开发：\n1.  对于给定的总同位旋 $T$，将同位旋算符 $\\hat{T}_+、\\hat{T}_-$ 和 $\\hat{T}_z$ 表示为全希尔伯特空间中的矩阵。\n2.  定义截断的模型空间并构建投影算符 $P$。\n3.  应用投影算符以获得在截断空间内作用的投影算符 $\\hat{T}_\\pm^{(P)}$ 和 $\\hat{T}_z^{(P)}$。\n4.  根据其定义构建代数恢复的有效算符 $\\hat{T}_\\pm^{(\\mathrm{eff})}$ 和 $\\hat{T}_z^{(\\mathrm{eff})}$。\n5.  计算所需的量：投影算符的代数破坏 $D_P$、有效算符的代数破坏 $D_\\mathrm{eff}$ 和费米矩阵元的误差 $E_F$。\n\n**步骤 1：全空间矩阵表示**\n\n对于给定的总同位旋 $T$，希尔伯特空间由 $d = 2T+1$ 个基态 $\\lvert T, m \\rangle$ 张成，其中 $m \\in \\{T, T-1, \\dots, -T\\}$。我们通过按磁量子数 $m$ 的降序对这些态进行排序来建立一个有序基。在此基中，一个态 $\\lvert T, m \\rangle$ 是一个列向量，在其 $m$ 值对应的位置上为 $1$，其余位置为零。基矢量的索引 $j$（从 $0$ 到 $d-1$）对应于量子数 $m_j = T-j$。\n\n在此基中，算符 $\\hat{T}_z、\\hat{T}_+$ 和 $\\hat{T}_-$ 的矩阵元由以下公式给出：\n-   $\\langle T, m' \\lvert \\hat{T}_z \\rvert T, m \\rangle = m \\, \\delta_{m',m}$。这产生一个对角矩阵 $(\\hat{T}_z)_{ij} = (T-i) \\delta_{ij}$。\n-   $\\langle T, m' \\lvert \\hat{T}_+ \\rvert T, m \\rangle = \\sqrt{T(T+1)-m(m+1)} \\, \\delta_{m',m+1}$。这是一个上对角矩阵。\n-   $\\langle T, m' \\lvert \\hat{T}_- \\rvert T, m \\rangle = \\sqrt{T(T+1)-m(m-1)} \\, \\delta_{m',m-1}$。这是一个下对角矩阵，且 $\\hat{T}_- = (\\hat{T}_+)^\\dagger$。\n\n**步骤 2：投影到截断空间**\n\n截断的模型空间由全套 $m$ 值的子集定义。投影算符 $P$ 将此子空间分离出来。如果截断基的维度为 $d_{\\text{trunc}}$，则投影算符是 $d_{\\text{trunc}} \\times d_{\\text{trunc}}$ 矩阵。在算法上，这是通过首先识别全空间中属于截断空间的基态的索引来实现的。然后，通过从全空间算符矩阵中仅选择与这些索引相对应的行和列来构建投影算符矩阵。\n\n**步骤 3：投影算符和代数恢复的有效算符**\n\n根据问题定义，我们在截断空间中构建两组算符。\n\n1.  **投影算符**：这些是通过直接投影全空间算符得到的。\n    $$ \\hat{T}_\\pm^{(P)} = P \\hat{T}_\\pm P $$\n    $$ \\hat{T}_z^{(P)} = P \\hat{T}_z P $$\n    在我们的矩阵实现中，这些对应于步骤 2 中描述的子矩阵。\n\n2.  **代数恢复的有效算符**：构建此集合是为了通过定义强制执行其中一个 $SU(2)$ 对易关系。\n    $$ \\hat{T}_\\pm^{(\\mathrm{eff})} = \\hat{T}_\\pm^{(P)} $$\n    $$ \\hat{T}_z^{(\\mathrm{eff})} = \\frac{1}{2} \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] = \\frac{1}{2} \\left( \\hat{T}_+^{(P)} \\hat{T}_-^{(P)} - \\hat{T}_-^{(P)} \\hat{T}_+^{(P)} \\right) $$\n\n**步骤 4：可观测量计算**\n\n定义了算符矩阵后，我们就可以计算所要求的三个量。\n\n-   **投影代数破坏, $D_P$**：基本的 $SU(2)$ 对易关系是 $[\\hat{T}_+, \\hat{T}_-] = 2\\hat{T}_z$。截断通常会破坏此关系。其破坏程度由残差矩阵的弗罗贝尼乌斯范数来量化：\n    $$ D_P = \\left\\lVert \\left[ \\hat{T}_+^{(P)}, \\hat{T}_-^{(P)} \\right] - 2 \\hat{T}_z^{(P)} \\right\\rVert_F $$\n    其中弗罗贝尼乌斯范数为 $\\lVert \\hat{X} \\rVert_F = \\sqrt{\\sum_{i,j} |X_{ij}|^2}$。这是通过矩阵乘法和减法，然后进行范数计算来得到的。\n\n-   **有效代数破坏, $D_{\\mathrm{eff}}$**：我们为代数恢复的集合计算相同的量。\n    $$ D_{\\mathrm{eff}} = \\left\\lVert \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] - 2 \\hat{T}_z^{(\\mathrm{eff})} \\right\\rVert_F $$\n    通过代入 $\\hat{T}_z^{(\\mathrm{eff})}$ 的定义，我们看到：\n    $$ D_{\\mathrm{eff}} = \\left\\lVert \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] - 2 \\left( \\frac{1}{2} \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] \\right) \\right\\rVert_F = \\lVert 0 \\rVert_F = 0 $$\n    根据构造，这个量恒为零，这可以作为对逻辑的验证。\n\n-   **费米矩阵元误差, $E_F$**：这衡量了由于使用有效算符而导致的特定跃迁振幅的误差。\n    $$ E_F = \\left\\lvert M_F^{(\\mathrm{eff})} - M_F^{(\\mathrm{exact})} \\right\\rvert $$\n    精确矩阵元 $M_F^{(\\mathrm{exact})} = \\langle T, m_f \\lvert \\hat{T}_\\pm \\rvert T, m_i \\rangle$ 就是值 $\\sqrt{T(T+1)-m_i(m_i \\pm 1)}$。有效矩阵元 $M_F^{(\\mathrm{eff})} = \\langle T, m_f \\lvert \\hat{T}_\\pm^{(\\mathrm{eff})} \\rvert T, m_i \\rangle_{\\text{trunc}}$ 是从矩阵 $\\hat{T}_\\pm^{(\\mathrm{eff})}$ 中提取的。如果初态 $\\lvert T, m_i \\rangle$ 或末态 $\\lvert T, m_f \\rangle$ 不在截断子空间内，则 $M_F^{(\\mathrm{eff})}$ 定义为 $0$。否则，它是连接对应于 $m_i$ 和 $m_f$ 的基矢量的 $\\hat{T}_\\pm^{(\\mathrm{eff})}$ 矩阵的元素。绝对差值给出了误差 $E_F$。\n\n将此过程系统地应用于每个测试用例以生成最终结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve_case(T, truncated_m_set, op_str, m_i):\n    \"\"\"\n    Solves a single test case for the SU(2) operator truncation problem.\n\n    Args:\n        T (float): Total isospin.\n        truncated_m_set (set): A set of m-values defining the truncated subspace.\n        op_str (str): The operator to use for E_F, either 'T+' or 'T-'.\n        m_i (float): The initial m-value for the transition.\n\n    Returns:\n        list: A list containing [D_p, D_eff, E_f].\n    \"\"\"\n    # 1. Define full space\n    # The dimension of the full SU(2) representation for isospin T\n    dim_full = int(2 * T + 1)\n    # Create the list of m-values, sorted in descending order, for the basis\n    full_m_list = np.arange(T, -T - 1, -1)\n    m_to_full_idx = {m: i for i, m in enumerate(full_m_list)}\n\n    # 2. Construct full-space operators\n    T_plus_full = np.zeros((dim_full, dim_full), dtype=float)\n    T_minus_full = np.zeros((dim_full, dim_full), dtype=float)\n    T_z_full = np.diag(full_m_list)\n\n    for i, m in enumerate(full_m_list):\n        # T+ acting on |T, m> gives ...|T, m+1>\n        if m  T:\n            # Map state |T, m> (col i) to state |T, m+1> (row i-1)\n            val = np.sqrt(T * (T + 1) - m * (m + 1))\n            T_plus_full[i - 1, i] = val\n        # T- acting on |T, m> gives ...|T, m-1>\n        if m > -T:\n            # Map state |T, m> (col i) to state |T, m-1> (row i+1)\n            val = np.sqrt(T * (T + 1) - m * (m - 1))\n            T_minus_full[i + 1, i] = val\n\n    # 3. Define truncated space and build projected operators\n    # Sort the truncated m-set descendingly to match the full basis ordering\n    trunc_m_list = sorted(list(truncated_m_set), reverse=True)\n    m_to_trunc_idx = {m: i for i, m in enumerate(trunc_m_list)}\n\n    # Get the indices in the full space that correspond to the truncated space\n    trunc_full_indices = [m_to_full_idx[m] for m in trunc_m_list]\n\n    # Build projected operators by taking submatrices\n    T_plus_p = T_plus_full[np.ix_(trunc_full_indices, trunc_full_indices)]\n    T_minus_p = T_minus_full[np.ix_(trunc_full_indices, trunc_full_indices)]\n    T_z_p = T_z_full[np.ix_(trunc_full_indices, trunc_full_indices)]\n\n    # 4. Calculate D_P (algebra violation in projected set)\n    commutator_p = T_plus_p @ T_minus_p - T_minus_p @ T_plus_p\n    violation_matrix_p = commutator_p - 2 * T_z_p\n    D_p = np.linalg.norm(violation_matrix_p, 'fro')\n\n    # 5. Calculate D_eff (algebra violation in algebra-restored set)\n    T_plus_eff = T_plus_p\n    T_minus_eff = T_minus_p\n    # T_z_eff is defined to restore the algebra\n    commutator_eff = T_plus_eff @ T_minus_eff - T_minus_eff @ T_plus_eff\n    T_z_eff = 0.5 * commutator_eff\n    \n    violation_matrix_eff = commutator_eff - 2 * T_z_eff\n    D_eff = np.linalg.norm(violation_matrix_eff, 'fro') # This will be zero by construction\n\n    # 6. Calculate E_F (error in Fermi matrix element)\n    if op_str == 'T+':\n        op_eff = T_plus_eff\n        m_f = m_i + 1\n        exact_me = np.sqrt(T*(T+1) - m_i*(m_i+1)) if m_i  T else 0\n    else:  # op_str == 'T-'\n        op_eff = T_minus_eff\n        m_f = m_i - 1\n        exact_me = np.sqrt(T*(T+1) - m_i*(m_i-1)) if m_i > -T else 0\n    \n    # Check if the transition occurs within the truncated space\n    if m_i in truncated_m_set and m_f in truncated_m_set:\n        idx_i_trunc = m_to_trunc_idx[m_i]\n        idx_f_trunc = m_to_trunc_idx[m_f]\n        trunc_me = op_eff[idx_f_trunc, idx_i_trunc]\n    else:\n        # If initial or final state is outside the truncated space, the matrix element is 0\n        trunc_me = 0.0\n\n    E_f = np.abs(trunc_me - exact_me)\n    \n    # Return results rounded to high precision to avoid floating point noise\n    return [round(D_p, 8), round(D_eff, 8), round(E_f, 8)]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (T, truncated_m_set, operator_str, m_i)\n        (2.0, {-2.0, -1.0, 0.0, 1.0, 2.0}, 'T+', 0.0),\n        (2.0, {-2.0, -1.0, 0.0, 1.0}, 'T+', 1.0),\n        (1.5, {-1.5, -0.5, 0.5}, 'T+', -0.5),\n        (1.5, {-1.5, 0.5, 1.5}, 'T-', 0.5),\n        (2.5, {-2.5, -1.5, -0.5, 0.5, 1.5}, 'T+', 1.5),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        T, truncated_m_set, op_str, m_i = case\n        result = solve_case(T, truncated_m_set, op_str, m_i)\n        all_results.append(result)\n\n    # Format the final output string to match the problem specification\n    # e.g., [[d_1,d_2,e_1],[d_3,d_4,e_2],...] with no spaces\n    results_str_list = []\n    for res in all_results:\n        # res is a list like [1.0, 2.0, 3.0]\n        # format it to \"[1.0,2.0,3.0]\"\n        formatted_res_str = f\"[{res[0]},{res[1]},{res[2]}]\"\n        results_str_list.append(formatted_res_str)\n    \n    final_output = f\"[{','.join(results_str_list)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "尽管理想的费米矩阵元由同位旋对称性固定，但真实原子核会经历同位旋破缺相互作用，其中最显著的是库仑力。本练习  提供了一个简化但功能强大的二能级模型，用以模拟这类相互作用如何导致不同同位旋态之间的混合。您将实现一个模型来量化这种混合，并确定线性响应理论的适用范围，从而深入理解物理上的对称性破缺效应是如何修正理想跃迁强度的。",
            "id": "3546691",
            "problem": "您的任务是开发一个计算模型，用于在一个最小但物理上一致的多体同位旋框架中，量化同位旋破缺单体势如何修改费米矩阵元。考虑一个具有同位旋对称动力学的原子核，在没有同位旋破缺的情况下，该原子核具有一个定义明确的同位旋类比态（IAS），其总同位旋为 $T = 1$ 且投影为 $T_z$。令费米跃迁算符为 $\\hat{T}^+ = \\sum_i \\tau_i^+$，其中 $\\tau_i^+$ 提升核子 $i$ 的同位旋。引入一个形式为 $\\Delta V = \\sum_{i=1}^N v_i \\tau_i^z$ 的同位旋破缺单体势，其中 $v_i$ 是具有能量单位的强度。假设哈密顿量的强相互作用部分是同位旋对称的，并且在 $T_z=0$ 子空间中产生两个相关状态：一个能量为 $E_1$ 的 $T=1, T_z=0$ 态和一个能量为 $E_0$ 的邻近 $T=0, T_z=0$ 态。势 $\\Delta V$ 通过同位旋矢量耦合将这两个态连接起来。\n\n从标准的同位旋代数和多体量子力学出发，在 $\\{\\,|T=1,T_z=0\\rangle,\\,|T=0,T_z=0\\rangle\\,\\}$ 基中推导一个简化的两能级哈密顿量描述，其非对角耦合与组合强度 $G = \\sum_i w_i v_i$ 呈线性关系，其中 $w_i$ 是已知的无量纲结构系数，编码了与同位旋矢量耦合相关的单粒子密度交叠。令非对角耦合与 $G$ 成正比，比例常数为无量纲的 $\\kappa$，并定义能量间距 $\\Delta E = E_0 - E_1  0$。通过对角化这个两能级哈密顿量，推导出混合角 $\\theta(G)$，它量化了 $|T=0,T_z=0\\rangle$ 在物理末态 $|f\\rangle$（对于 $T_z=0$）中的混合程度。然后，利用费米跃迁算符的定义，并使用标准的同位旋角动量耦合规则，将从初始纯IAS态 $|i\\rangle = |T = 1, T_z = -1\\rangle$ 到混合末态 $|f\\rangle$ 的跃迁的费米矩阵元 $M_F(G) = \\langle f|\\hat{T}^+|i\\rangle$ 用混合角表示出来。\n\n将混合角的线性响应近似 $\\theta_{\\mathrm{lin}}(G)$ 定义为从同位旋破缺耦合的一级微扰理论中得到的结果。您的计算任务是实现一个程序，对于一系列标度的同位旋破缺强度 $v_i(s) = s\\,u_i$（其中 $u_i$ 是一个无量纲方向向量），扫描幅度 $s$ 并根据以下判据，找出精确混合角与其线性近似的偏差首次超过指定相对容差 $\\varepsilon$ 时的边界幅度 $s_c$（单位为 $\\mathrm{MeV}$）：\n$$\n\\left|\\frac{\\theta\\big(G(s)\\big)}{\\theta_{\\mathrm{lin}}\\big(G(s)\\big)} - 1\\right| \\ge \\varepsilon,\n$$\n需要理解的是，如果对所有 $s$ 都有 $G(s) = 0$，则不会发生混合，边界幅度应报告为 $0.0$ $\\mathrm{MeV}$。角度必须以弧度处理。\n\n将上述内容实现为一个完整的、可运行的程序，该程序：\n- 不接受任何输入，并使用下面的测试套件。\n- 对于每个测试用例，计算 $G(s) = \\sum_i w_i v_i(s) = s \\sum_i w_i u_i$，然后在区间 $[0, s_{\\max}]$ 内扫描 $s$，找出满足判据的最小 $s$ 作为 $s_c$。如果在 $[0, s_{\\max}]$ 内任何地方都不满足该判据，则报告 $s_c = s_{\\max}$。如果 $G(s)$ 恒等于零，则报告 $s_c = 0.0$。\n- 生成一行输出，其中包含所有测试用例的边界幅度，形式为方括号内的逗号分隔列表。将每个幅度以 $\\mathrm{MeV}$ 为单位表示，并四舍五入到六位小数。\n\n使用以下测试套件：\n- 情况A（一般情况）：$N=4$，$\\Delta E = 2.0\\,\\mathrm{MeV}$，$\\kappa = 0.8$， $w_i = [1.0, 0.8, 1.2, 0.9]$， $u_i = [1.0, 1.0, 1.0, 1.0]$，$s_{\\max} = 2.0\\,\\mathrm{MeV}$，$\\varepsilon = 0.05$。\n- 情况B（近简并态）：$N=4$，$\\Delta E = 0.2\\,\\mathrm{MeV}$，$\\kappa = 0.5$， $w_i = [1.0, 0.8, 1.2, 0.9]$， $u_i = [1.0, 1.0, 1.0, 1.0]$，$s_{\\max} = 2.0\\,\\mathrm{MeV}$，$\\varepsilon = 0.05$。\n- 情况C（平衡耦合，净同位旋矢量强度为零）：$N=4$，$\\Delta E = 3.0\\,\\mathrm{MeV}$，$\\kappa = 0.6$， $w_i = [1.0, 1.0, -1.0, -1.0]$， $u_i = [1.0, 1.0, 1.0, 1.0]$，$s_{\\max} = 2.0\\,\\mathrm{MeV}$，$\\varepsilon = 0.05$。\n- 情况D（混合符号结构）：$N=4$，$\\Delta E = 5.0\\,\\mathrm{MeV}$，$\\kappa = 1.0$， $w_i = [1.0, -0.4, 0.3, 0.1]$， $u_i = [2.0, 0.5, -1.0, 1.5]$，$s_{\\max} = 5.0\\,\\mathrm{MeV}$，$\\varepsilon = 0.05$。\n\n您的程序应生成一行输出，其中包含结果，形式为方括号内的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_k$ 是相应测试用例的边界幅度 $s_c$，单位为 $\\mathrm{MeV}$，并四舍五入到六位小数。",
            "solution": "已对用户提供的问题进行分析，并确定其是**有效的**。这是一个在计算核物理领域中自洽、有科学依据且定义良好的问题，可以使用标准的量子力学原理来解决。\n\n### 理论推导\n\n该问题要求我们分析一个受混合相互作用影响的两能级量子系统。该系统在 $T_z=0$ 子空间的两个同位旋态基矢中进行描述：$|1\\rangle \\equiv |T=1, T_z=0\\rangle$ 和 $|0\\rangle \\equiv |T=0, T_z=0\\rangle$。\n\n**1. 两能级哈密顿量**\n\n总哈密顿量为 $H = H_0 + \\Delta V$。同位旋对称部分 $H_0$ 在所选基矢中是对角的，对于 $|1\\rangle$ 的本征值为 $E_1$，对于 $|0\\rangle$ 的本征值为 $E_0$。同位旋破缺势为 $\\Delta V = \\sum_i v_i \\tau_i^z$。由于 $\\tau^z$ 算符的性质（特别是对于秩-1张量算符的Wigner-Eckart定理），其在 $T_z=0$ 子空间中的对角矩阵元为零：$\\langle 1|\\Delta V|1\\rangle = \\langle 0|\\Delta V|0\\rangle = 0$。\n\n非对角矩阵元由 $\\langle 0|\\Delta V|1\\rangle = \\kappa G$ 给出，其中 $G = \\sum_i w_i v_i$ 是同位旋破缺势的组合强度。由于 $\\Delta V$ 是厄米的，$\\langle 1|\\Delta V|0\\rangle = (\\kappa G)^*$。假设所有参数都是实数，则此项也为 $\\kappa G$。\n\n在 $\\{|1\\rangle, |0\\rangle\\}$ 基中的哈密顿量为：\n$$\nH = \\begin{pmatrix} E_1  \\kappa G \\\\ \\kappa G  E_0 \\end{pmatrix}\n$$\n为方便起见，将能量零点平移至平均能量 $(E_1+E_0)/2$，并使用能量间距 $\\Delta E = E_0 - E_1  0$。有效哈密顿量变为：\n$$\nH = \\begin{pmatrix} -\\Delta E/2  \\kappa G \\\\ \\kappa G  \\Delta E/2 \\end{pmatrix}\n$$\n\n**2. 精确混合角 $\\theta(G)$**\n\n我们对角化这个哈密顿量以找到混合的本征态。物理末态 $|f\\rangle$ 是从未微扰态 $|1\\rangle$ 演化而来的态，后者是这对态中能量较低的那个。$H$ 的能量较低的本征态可以写成：\n$$\n|f\\rangle = \\cos\\theta |1\\rangle + \\sin\\theta |0\\rangle\n$$\n混合角 $\\theta$ 的正切是系数之比，可以从本征向量方程中求得。对于两能级系统，一个标准结果给出：\n$$\n\\tan(\\theta) = \\frac{\\lambda_- - H_{11}}{H_{12}} = \\frac{-\\sqrt{(\\Delta E/2)^2 + (\\kappa G)^2} - (-\\Delta E/2)}{\\kappa G} = \\frac{\\Delta E/2 - \\sqrt{(\\Delta E/2)^2 + (\\kappa G)^2}}{\\kappa G}\n$$\n这个表达式对于小的 $G$ 是数值不稳定的。将分子和分母同乘以分子的共轭，得到一个稳定形式：\n$$\n\\tan(\\theta) = \\frac{(\\kappa G)^2}{(\\kappa G) \\left( \\Delta E/2 + \\sqrt{(\\Delta E/2)^2 + (\\kappa G)^2} \\right)} = \\frac{\\kappa G}{\\Delta E/2 + \\sqrt{(\\Delta E/2)^2 + (\\kappa G)^2}}\n$$\n混合角 $\\theta$ 以弧度明确表示为：\n$$\n\\theta(G) = \\arctan\\left( \\frac{\\kappa G}{\\Delta E/2 + \\sqrt{(\\Delta E/2)^2 + (\\kappa G)^2}} \\right)\n$$\n\n**3. 线性响应近似 $\\theta_{\\mathrm{lin}}(G)$**\n\n线性响应近似从一级微扰理论获得。微扰后的态为：\n$$\n|f\\rangle \\approx |1\\rangle + \\frac{\\langle 0 | \\Delta V | 1 \\rangle}{E_1 - E_0} |0\\rangle = |1\\rangle + \\frac{\\kappa G}{-\\Delta E} |0\\rangle\n$$\n在小角度近似中， $|f\\rangle \\approx |1\\rangle + \\theta |0\\rangle$。比较这些形式，我们将混合角的线性近似确定为混合系数：\n$$\n\\theta_{\\mathrm{lin}}(G) = -\\frac{\\kappa G}{\\Delta E}\n$$\n问题要求基于一个比率来计算偏差，因此精确角度和线性近似角度定义之间的符号差异并不重要，因为判据使用的是绝对值。然而，为保持一致性，我们定义我们的角度具有相同的符号。从 $\\tan(\\theta)$ 的表达式可以看出，对于小的 $G$，$\\tan(\\theta) \\approx \\frac{\\kappa G}{\\Delta E/2 + \\Delta E/2} = \\frac{\\kappa G}{\\Delta E}$。由于对于小角度 $\\theta \\approx \\tan(\\theta)$，这自然导出 $\\theta_{\\mathrm{lin}}(G) = \\frac{\\kappa G}{\\Delta E}$。我们将采用这种形式。\n\n**4. 计算任务**\n\n目标是找到最小幅度 $s_c  0$（对于标度势 $v_i(s) = s u_i$），在该幅度下满足以下判据：\n$$\n\\left|\\frac{\\theta\\big(G(s)\\big)}{\\theta_{\\mathrm{lin}}\\big(G(s)\\big)} - 1\\right| \\ge \\varepsilon\n$$\n这里，$G(s) = s \\sum_i w_i u_i$。令 $C_G = \\sum_i w_i u_i$。\n\n描述相对偏差的函数是：\n$$\nD(s) = \\left| \\frac{\\arctan\\left( \\frac{\\kappa s C_G}{\\Delta E/2 + \\sqrt{(\\Delta E/2)^2 + (\\kappa s C_G)^2}} \\right)}{\\kappa s C_G / \\Delta E} - 1 \\right|\n$$\n该函数 $D(s)$ 对于 $s \\ge 0$ 是单调递增的。我们必须找到值 $s_c \\in [0, s_{\\max}]$，使得 $D(s_c) = \\varepsilon$。这是一个关于函数 $f(s) = D(s) - \\varepsilon = 0$ 的求根问题。\n\n**5. 数值算法**\n\n鉴于 $D(s)$ 的单调性，二分法是寻找 $s_c$ 的一种高效且鲁棒的算法。\n1.  对于每个测试用例，计算结构常数 $C_G = \\sum_i w_i u_i$。\n2.  如果 $C_G = 0$，则对所有 $s$ 都有 $G(s)=0$。不发生混合。偏差始终为 $0$。根据规定，$s_c=0.0$。\n3.  在最大幅度 $s_{\\max}$ 处评估偏差 $D(s_{\\max})$。如果 $D(s_{\\max})  \\varepsilon$，则在该区间内永远不满足判据，因此我们报告 $s_c = s_{\\max}$。\n4.  否则，在 $(0, s_{\\max})$ 中存在一个唯一的根 $s_c$。我们对区间 $[0, s_{\\max}]$ 使用二分搜索来找到使 $D(s)=\\varepsilon$ 的 $s$ 值。搜索通过重复缩小区间 $[L, R]$ 直到其宽度低于所需精度来进行，从而得出 $s_c$ 的值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the boundary amplitude s_c for a set of test cases based on a \n    two-level quantum mechanical model of isospin mixing.\n    \"\"\"\n\n    class TestCase:\n        \"\"\"A helper class to hold test case parameters for clarity.\"\"\"\n        def __init__(self, N, Delta_E, kappa, w, u, s_max, epsilon):\n            self.N = N\n            self.Delta_E = Delta_E  # MeV\n            self.kappa = kappa\n            self.w = np.array(w)\n            self.u = np.array(u)\n            self.s_max = s_max      # MeV\n            self.epsilon = epsilon\n            # C_G is the combined dimensionless structure factor\n            self.C_G = np.sum(self.w * self.u)\n\n    def calculate_deviation(s, case):\n        \"\"\"\n        Calculates the relative deviation of the exact mixing angle from its\n        linear approximation for a given amplitude s.\n        \n        The deviation is defined as |theta_exact/theta_lin - 1|.\n        \"\"\"\n        # If amplitude is zero, G is zero, and there is no mixing/deviation.\n        if s == 0.0:\n            return 0.0\n\n        # The combined isospin-breaking strength G(s)\n        G = s * case.C_G\n        \n        # If G is zero (due to C_G being zero), there is no mixing.\n        if G == 0.0:\n            return 0.0\n\n        # Linear-response approximation for the mixing angle (in radians)\n        theta_lin = case.kappa * G / case.Delta_E\n\n        # Exact mixing angle (in radians) derived from diagonalizing the 2x2 Hamiltonian.\n        # tan(theta) = (kappa*G) / (sqrt((DeltaE/2)^2 + (kappa*G)^2) + DeltaE/2)\n        # This form is numerically stable for small G.\n        kappa_G = case.kappa * G\n        arg_tan = kappa_G / (np.sqrt((case.Delta_E / 2.0)**2 + kappa_G**2) + case.Delta_E / 2.0)\n        theta_exact = np.arctan(arg_tan)\n\n        # For G != 0, theta_lin is also non-zero, so the division is safe.\n        deviation = np.abs(theta_exact / theta_lin - 1.0)\n        \n        return deviation\n\n    def find_boundary_amplitude(case):\n        \"\"\"\n        Finds the boundary amplitude s_c for a given test case using bisection search.\n        \"\"\"\n        # Special case: If the net isovector strength G(s) is identically zero,\n        # there is no isospin mixing, and s_c is defined as 0.0.\n        if case.C_G == 0.0:\n            return 0.0\n\n        # Check if the criterion is met at the maximum amplitude s_max.\n        # If not, the boundary is s_max itself.\n        dev_at_s_max = calculate_deviation(case.s_max, case)\n        if dev_at_s_max  case.epsilon:\n            return case.s_max\n\n        # Use bisection method to find s_c where deviation(s_c) = epsilon.\n        # We are finding the root of f(s) = calculate_deviation(s) - epsilon.\n        low = 0.0\n        high = case.s_max\n        \n        # 100 iterations are more than sufficient for double precision convergence.\n        for _ in range(100):\n            mid = (low + high) / 2.0\n            # If the interval is too small to bisect further, stop.\n            if mid == low or mid == high:\n                break\n            \n            # The deviation function is monotonic, so we can guide the search.\n            if calculate_deviation(mid, case)  case.epsilon:\n                # The deviation is still too small, so s_c must be larger.\n                low = mid\n            else:\n                # The deviation has exceeded epsilon, s_c is at or below mid.\n                high = mid\n                \n        # The root is at `high` (or `low`, they are very close).\n        return high\n\n    # Define the test cases from the problem statement.\n    test_cases_data = [\n        # Case A: General regime\n        {'N': 4, 'Delta_E': 2.0, 'kappa': 0.8, 'w': [1.0, 0.8, 1.2, 0.9], 'u': [1.0, 1.0, 1.0, 1.0], 's_max': 2.0, 'epsilon': 0.05},\n        # Case B: Near-degenerate states\n        {'N': 4, 'Delta_E': 0.2, 'kappa': 0.5, 'w': [1.0, 0.8, 1.2, 0.9], 'u': [1.0, 1.0, 1.0, 1.0], 's_max': 2.0, 'epsilon': 0.05},\n        # Case C: Balanced couplings, zero net isovector strength\n        {'N': 4, 'Delta_E': 3.0, 'kappa': 0.6, 'w': [1.0, 1.0, -1.0, -1.0], 'u': [1.0, 1.0, 1.0, 1.0], 's_max': 2.0, 'epsilon': 0.05},\n        # Case D: Mixed-sign structure\n        {'N': 4, 'Delta_E': 5.0, 'kappa': 1.0, 'w': [1.0, -0.4, 0.3, 0.1], 'u': [2.0, 0.5, -1.0, 1.5], 's_max': 5.0, 'epsilon': 0.05},\n    ]\n\n    test_cases = [TestCase(**data) for data in test_cases_data]\n    \n    results = []\n    for case in test_cases:\n        s_c = find_boundary_amplitude(case)\n        # Format the result to six decimal places.\n        results.append(f\"{s_c:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在诸如无核芯壳模型（No-Core Shell Model）的多体计算中，使用有限的单粒子基矢会人为地破坏系统的平移不变性，导致内部运动与质心运动之间产生伪混合。本练习  演示了这种计算赝象如何污染费米矩阵元，并探讨了抑制这些非物理效应的常用技术，例如引入劳森项（Lawson term）。这项实践对于确保大规模核结构计算的可靠性至关重要。",
            "id": "3546717",
            "problem": "要求您推导、实现并测试一个计算模型，该模型用于量化在无核芯壳模型 (NCSM) 中，质心因子分解的破坏如何影响费米矩阵元，并评估基于质心哈密顿量约束和 Lawson 项惩罚的补救措施的有效性。目标是计算由质心污染引起的费米矩阵元偏差，并展示不同的补救措施如何恢复其期望值。\n\n从以下基础和定义开始：\n\n- 在一个双核子等质量系统的谐振子表象中，当平移不变性成立时，总哈密顿量可以分离为内禀部分和质心部分。设 $x_1$ 和 $x_2$ 表示一维空间中的粒子坐标，质心坐标为 $X = \\frac{x_1 + x_2}{2}$，相对坐标为 $x = x_1 - x_2$。对于相等的质量 $m$ 和角频率 $\\omega$，质心质量为 $M = 2m$，约化质量为 $\\mu = \\frac{m}{2}$。\n- 质心哈密顿量为 $H_{\\mathrm{cm}} = \\frac{P^2}{2M} + \\frac{1}{2} M \\omega^2 X^2$，内禀哈密顿量为 $H_{\\mathrm{int}} = \\frac{p^2}{2\\mu} + \\frac{1}{2} \\mu \\omega^2 x^2$，其中 $P$ 和 $p$ 分别是对应的共轭动量。\n- 费米矩阵元 $M_F$ 由作用在所有核子上的同位旋升算符之和 $F = \\sum_{i=1}^A \\tau_i^+$ 定义，它连接了同位旋类比态。对于一个处于纯同位旋三重态 $T=1$ 且投影变化为 $\\Delta M_T = +1$ 的双核子系统，如果初态和末态的空间部分相同且质心因子分解成立，则理想值为 $M_F = \\sqrt{2}$。\n- 质心因子分解的破坏可以通过在哈密顿量中添加一个 $X$ 和 $x$ 之间的弱耦合来建模，这会使质心运动和内禀运动产生关联。引入一个耦合项 $H_{\\mathrm{coup}} = \\alpha X x$，其中 $\\alpha$ 是一个小的实数参数。需要对角化的总哈密顿量为 $H = H_{\\mathrm{cm}} + H_{\\mathrm{int}} + H_{\\mathrm{coup}}$。\n- 补救措施包括将质心状态约束在 $n_{\\mathrm{cm}} = 0$ 子空间（一种模拟 $H_{\\mathrm{cm}}$ 最小化的硬约束），或添加一个 Lawson 项，该项通过 $H \\mapsto H + \\beta H_{\\mathrm{cm}}$（其中 $\\beta  0$）来惩罚质心激发。\n\n表象与计算设置：\n\n- 在 $\\hbar = 1$、$m = 1$ 和 $\\omega = 1$ 的单位制下工作。因此，能量的单位是 $\\hbar\\omega$。\n- 使用质心和相对运动的谐振子本征态的乘积基 $\\{|N\\rangle_{\\mathrm{cm}} \\otimes |n\\rangle_{\\mathrm{rel}}\\}$，其中 $N = 0,\\dots,N_{\\mathrm{cm}}^{\\max}$ 且 $n = 0,\\dots,N_{\\mathrm{rel}}^{\\max}$。非耦合哈密顿量的本征值为 $E_{N,n} = \\omega \\left(N + \\tfrac{1}{2}\\right) + \\omega \\left(n + \\tfrac{1}{2}\\right)$。\n- 一维空间中的位置算符在谐振子基下的矩阵元由 $X = x_{\\mathrm{cm}} \\left(\\sqrt{N+1} |N\\rangle \\langle N+1| + \\sqrt{N} |N\\rangle \\langle N-1|\\right)$ 和 $x = x_{\\mathrm{rel}} \\left(\\sqrt{n+1} |n\\rangle \\langle n+1| + \\sqrt{n} |n\\rangle \\langle n-1|\\right)$ 给出，其中 $x_{\\mathrm{cm}} = \\sqrt{\\frac{1}{2 M \\omega}}$ 且 $x_{\\mathrm{rel}} = \\sqrt{\\frac{1}{2 \\mu \\omega}}$。在当前单位制下，$M = 2$，$\\mu = \\tfrac{1}{2}$，因此 $x_{\\mathrm{cm}} = \\tfrac{1}{2}$ 且 $x_{\\mathrm{rel}} = 1$。\n- 因此，耦合项 $H_{\\mathrm{coup}} = \\alpha X x$ 连接了 $(N,n) \\to (N\\pm 1, n \\pm 1)$ 的态。\n\n同位旋结构与 $M_F$ 的评估：\n\n- 考虑由与 $|pp\\rangle$、$|pn\\rangle$ 和 $|np\\rangle$ 相关联的空间态标记的三个同位旋分区。构造初始的同位旋对称态 $|i\\rangle = \\frac{1}{\\sqrt{2}}\\left(|pn\\rangle + |np\\rangle\\right)$，其对应的空间部分为 $\\phi_{pn}(X,x)$ 和 $\\phi_{np}(X,x)$，以及末态 $|f\\rangle = |pp\\rangle$，其空间部分为 $\\phi_{pp}(X,x)$。\n- 费米算符 $F$ 仅作用于同位旋部分，将 $|pn\\rangle \\mapsto |pp\\rangle$ 和 $|np\\rangle \\mapsto |pp\\rangle$。因此，约化费米矩阵元变为\n$$\nM_F = \\frac{1}{\\sqrt{2}} \\left( \\langle \\phi_{pp} | \\phi_{pn} \\rangle + \\langle \\phi_{pp} | \\phi_{np} \\rangle \\right),\n$$\n其中每个内积都是在质心和相对运动谐振子态的乘积基上计算的。\n- 质心污染由每个分区基态中 $\\langle H_{\\mathrm{cm}} \\rangle$ 的期望值来量化；在理想的因子分解情况下，该值在当前单位制下等于 $\\tfrac{1}{2}$。\n\n计算任务：\n\n1. 对于每个同位旋分区（$pp$, $pn$, $np$），使用指定的 $(\\alpha,\\beta)$、特定于分区的质心截断 $N_{\\mathrm{cm}}^{\\max}$ 和一个共同的相对截断 $N_{\\mathrm{rel}}^{\\max}$ 来构建 $H = H_{\\mathrm{cm}} + H_{\\mathrm{int}} + H_{\\mathrm{coup}} + \\beta H_{\\mathrm{cm}}$。\n2. 对角化 $H$ 以获得该分区乘积基中的归一化基态空间矢量 $\\phi_{\\mathrm{sector}}$。通过对缺失的分量进行补零，将每个分区的基态嵌入到一个由 $N_{\\mathrm{cm}}^{\\sup} = \\max\\{N_{\\mathrm{cm},pp}^{\\max}, N_{\\mathrm{cm},pn}^{\\max}, N_{\\mathrm{cm},np}^{\\max}\\}$ 和共同的 $N_{\\mathrm{rel}}^{\\max}$ 决定的共同“超空间”基中。\n3. 使用嵌入后的态，通过上述公式计算 $M_F$，并计算定义为 $pp$、$pn$ 和 $np$ 分区中 $\\langle H_{\\mathrm{cm}} \\rangle$ 的算术平均值的平均质心污染。\n4. 能量以 $\\hbar\\omega$ 为单位表示，费米矩阵元表示为无量纲数。\n\n测试套件：\n\n实现以下五个测试用例，每个用例由元组 $\\{N_{\\mathrm{cm},pp}^{\\max}, N_{\\mathrm{cm},pn}^{\\max}, N_{\\mathrm{cm},np}^{\\max}, N_{\\mathrm{rel}}^{\\max}, \\alpha, \\beta\\}$ 指定：\n\n- 用例 1 (理想因子分解基准): $\\{3,3,3,6,0.0,0.0\\}$。\n- 用例 2 (通过耦合和不匹配的截断破坏因子分解): $\\{1,1,2,6,0.2,0.0\\}$。\n- 用例 3 (硬 $H_{\\mathrm{cm}}$ 约束补救，质心冻结): $\\{0,0,0,6,0.2,0.0\\}$。\n- 用例 4 (Lawson项补救): $\\{3,3,3,6,0.2,5.0\\}$。\n- 用例 5 (强耦合，不匹配的截断): $\\{1,2,3,6,0.5,0.0\\}$。\n\n要求的输出与格式：\n\n- 对于每个用例，计算两个浮点数：费米矩阵元 $M_F$ 和三个分区的平均质心能量 $\\overline{\\langle H_{\\mathrm{cm}} \\rangle}$，两者均使用上述指定单位。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序如下：\n$$\n[M_F^{(1)}, \\overline{\\langle H_{\\mathrm{cm}} \\rangle}^{(1)}, M_F^{(2)}, \\overline{\\langle H_{\\mathrm{cm}} \\rangle}^{(2)}, \\dots, M_F^{(5)}, \\overline{\\langle H_{\\mathrm{cm}} \\rangle}^{(5)}].\n$$\n\n本问题不使用角度。不使用百分比；所有计算均在指定单位下进行，输出为十进制浮点数。",
            "solution": "该问题要求对一个简化的双核子系统中质心 (CM) 因子分解的破坏以及常用补救措施的有效性进行计算分析。这是无核芯壳模型 (NCSM) 中的一个典型问题，在该模型中，波函数是在谐振子 (HO) 态的基上构建的。除非谨慎处理，否则该基的有限截断会破坏核哈密顿量的平移不变性，导致核子内禀运动与其质心运动发生伪混合。这种污染会影响可观测量（包括应受同位旋对称性保护的 β 衰变的费米矩阵元 $M_F$）的计算。我们将构建该系统的哈密顿矩阵，通过对角化找到基态波函数，然后计算费米矩阵元 $M_F$ 和质心哈密顿量的期望值 $\\langle H_{\\mathrm{cm}} \\rangle$，以量化污染程度和补救措施的成功与否。\n\n**1. 理论框架：哈密顿量与基态**\n\n我们使用谐振子基来模拟一维空间中的双核子系统。单位设置为 $\\hbar = 1$，核子质量 $m = 1$，振子频率 $\\omega = 1$。因此，质心质量为 $M = 2m = 2$，约化质量为 $\\mu = m/2 = 1/2$。\n\n总哈密顿量 $H$ 是四个分量的和：内禀哈密顿量 $H_{\\mathrm{int}}$、质心哈密顿量 $H_{\\mathrm{cm}}$、模拟因子分解破坏的耦合项 $H_{\\mathrm{coup}}$，以及用作补救措施的 Lawson 惩罚项 $H_{\\mathrm{Lawson}}$。\n$$\nH = H_{\\mathrm{int}} + H_{\\mathrm{cm}} + H_{\\mathrm{coup}} + H_{\\mathrm{Lawson}}\n$$\n代入给定的定义，这变为：\n$$\nH = H_{\\mathrm{int}} + (1+\\beta) H_{\\mathrm{cm}} + \\alpha X x\n$$\n其中 $\\alpha$ 是耦合强度参数，$\\beta$ 是 Lawson 惩罚参数。\n\n该问题在相对运动 ($n$) 和质心运动 ($N$) 的谐振子本征态的截断乘积基 $\\{|N\\rangle_{\\mathrm{cm}} \\otimes |n\\rangle_{\\mathrm{rel}}\\}$（我们记为 $|N, n\\rangle$）内求解。该基在最大量子数 $N_{\\mathrm{cm}}^{\\max}$ 和 $N_{\\mathrm{rel}}^{\\max}$ 处被截断。\n\n**2. 哈密顿量的矩阵表示**\n\n我们在 $|N, n\\rangle$ 基中构建 $H$ 的矩阵表示。一对索引 $(N, n)$ 可以映射到单个矩阵索引 $k$。\n\n- **内禀和质心哈密顿量 ($H_{\\mathrm{int}}, H_{\\mathrm{cm}}$):** 这些算符在所选基中是对角的。在指定单位 ($\\omega=1$) 下，它们的本征值为 $E_{\\mathrm{int}} = n + \\frac{1}{2}$ 和 $E_{\\mathrm{cm}} = N + \\frac{1}{2}$。它们的矩阵元为：\n$$\n\\langle N', n' | H_{\\mathrm{int}} | N, n \\rangle = \\left(n + \\frac{1}{2}\\right) \\delta_{N'N} \\delta_{n'n}\n$$\n$$\n\\langle N', n' | (1+\\beta) H_{\\mathrm{cm}} | N, n \\rangle = (1+\\beta)\\left(N + \\frac{1}{2}\\right) \\delta_{N'N} \\delta_{n'n}\n$$\n\n- **耦合哈密顿量 ($H_{\\mathrm{coup}}$):** $H_{\\mathrm{coup}} = \\alpha X x$ 项是非对角的。位置算符 $X$ 和 $x$ 的矩阵元由下式给出：\n$$\n\\langle K' | \\hat{O} | K \\rangle = \\sqrt{\\frac{\\hbar}{2m_O\\omega}} \\left( \\sqrt{K+1} \\delta_{K', K+1} + \\sqrt{K} \\delta_{K', K-1} \\right)\n$$\n其中 $\\hat{O}$ 是位置算符，其关联质量为 $m_O$。对于质心算符 $X$，质量为 $M=2$；对于相对算符 $x$，质量为 $\\mu=1/2$。在我们的单位制中，这给出的前置因子为 $x_{\\mathrm{cm}} = \\sqrt{1/(2 \\cdot 2 \\cdot 1)} = 1/2$ 和 $x_{\\mathrm{rel}} = \\sqrt{1/(2 \\cdot 1/2 \\cdot 1)} = 1$。耦合项的矩阵元为：\n$$\n\\langle N', n' | H_{\\mathrm{coup}} | N, n \\rangle = \\alpha \\langle N' | X | N \\rangle \\langle n' | x | n \\rangle\n$$\n该矩阵元仅在 $N' = N \\pm 1$ 和 $n' = n \\pm 1$ 时非零。例如，具体值为：\n$$\n\\langle N+1, n+1 | H_{\\mathrm{coup}} | N, n \\rangle = \\frac{\\alpha}{2}\\sqrt{(N+1)(n+1)}\n$$\n连接 $|N,n\\rangle$ 到 $|N\\pm 1, n \\pm 1\\rangle$ 的其他非零元可以类似地推导。总哈密顿矩阵是这些分量矩阵的和。\n\n**3. 基态和可观测量的计算**\n\n对于每个同位旋分区（$pp$、$pn$、$np$），使用特定于该分区的截断 $N_{\\mathrm{cm, sector}}^{\\max}$ 和共同的 $N_{\\mathrm{rel}}^{\\max}$ 构建相应的哈密顿矩阵 $H_{\\mathrm{sector}}$。然后对该矩阵进行数值对角化，以找到其本征值和本征矢量。基态 $\\phi_{\\mathrm{sector}}$ 是对应于最低本征值的本征矢量。\n\n- **质心污染：** 一个态 $\\phi_{\\mathrm{sector}} = \\sum_{N,n} c_{N,n} |N,n\\rangle$ 中的质心污染程度由期望值 $\\langle H_{\\mathrm{cm}} \\rangle_{\\mathrm{sector}}$ 来量化。由于 $H_{\\mathrm{cm}}$ 算符在我们的基中是对角的，该计算很简单：\n$$\n\\langle H_{\\mathrm{cm}} \\rangle_{\\mathrm{sector}} = \\langle \\phi_{\\mathrm{sector}} | H_{\\mathrm{cm}} | \\phi_{\\mathrm{sector}} \\rangle = \\sum_{N,n} |c_{N,n}|^2 \\left(N + \\frac{1}{2}\\right)\n$$\n问题要求计算三个分区的算术平均值，$\\overline{\\langle H_{\\mathrm{cm}} \\rangle} = \\frac{1}{3} \\sum_{\\mathrm{sector} \\in \\{pp,pn,np\\}} \\langle H_{\\mathrm{cm}} \\rangle_{\\mathrm{sector}}$。在理想的非耦合情况下，基态为 $|0,0\\rangle$，此时 $\\langle H_{\\mathrm{cm}} \\rangle = 1/2$。偏离 $1/2$ 表明存在污染。\n\n- **费米矩阵元 ($M_F$):** 费米矩阵元由 $M_F = \\frac{1}{\\sqrt{2}} ( \\langle \\phi_{pp} | \\phi_{pn} \\rangle + \\langle \\phi_{pp} | \\phi_{np} \\rangle )$ 给出。出现了一个复杂情况，因为基态 $\\phi_{pp}$、$\\phi_{pn}$ 和 $\\phi_{np}$ 可能是在具有不同质心截断 ($N_{\\mathrm{cm, pp}}^{\\max}$、$N_{\\mathrm{cm, pn}}^{\\max}$、$N_{\\mathrm{cm, np}}^{\\max}$) 的基中计算的。为了计算所需的重叠，这些态矢量必须首先被嵌入到一个共同的、更大的基，即“超空间”中。该超空间由各分区质心截断的最大值 $N_{\\mathrm{cm}}^{\\sup} = \\max_{\\mathrm{sector}}\\{N_{\\mathrm{cm, sector}}^{\\max}\\}$ 和共同的相对截断 $N_{\\mathrm{rel}}^{\\max}$ 定义。来自较小基的态矢量通过为其在超空间中存在但在原始较小空间中不存在的基态填充零来进行嵌入。嵌入后，所有态矢量具有相同的维度，它们的重叠可以作为简单的矢量点积来计算。在理想情况下，所有态都只是 $|0,0\\rangle$，重叠均为 $1$，得到 $M_F = \\frac{1}{\\sqrt{2}}(1+1) = \\sqrt{2}$。偏离 $\\sqrt{2}$ 表明同位旋对称性丧失，这通常是由质心伪影引起的。\n\n**4. 计算工作流程**\n\n对于五个测试用例中的每一个，总体算法如下：\n1.  定义用例的参数：$\\{N_{\\mathrm{cm},pp}^{\\max}, N_{\\mathrm{cm},pn}^{\\max}, N_{\\mathrm{cm},np}^{\\max}, N_{\\mathrm{rel}}^{\\max}, \\alpha, \\beta\\}$。\n2.  确定共同超空间的维度：$N_{\\mathrm{cm}}^{\\sup} = \\max(N_{\\mathrm{cm},pp}^{\\max}, N_{\\mathrm{cm},pn}^{\\max}, N_{\\mathrm{cm},np}^{\\max})$。\n3.  对于每个同位旋分区（$pp$、$pn$、$np$）：\n    a. 使用上面推导的矩阵元，构建一个大小为 $(N_{\\mathrm{cm, sector}}^{\\max}+1)(N_{\\mathrm{rel}}^{\\max}+1) \\times (N_{\\mathrm{cm, sector}}^{\\max}+1)(N_{\\mathrm{rel}}^{\\max}+1)$ 的哈密顿矩阵 $H_{\\mathrm{sector}}$。\n    b. 对角化 $H_{\\mathrm{sector}}$ 以获得基态本征矢量 $\\phi_{\\mathrm{sector}}$ 及其对应的本征值。\n    c. 使用 $\\phi_{\\mathrm{sector}}$ 的分量计算 $\\langle H_{\\mathrm{cm}} \\rangle_{\\mathrm{sector}}$。\n    d. 通过补零将 $\\phi_{\\mathrm{sector}}$ 嵌入到超空间基中，得到 $\\phi_{\\mathrm{sector}}^{\\mathrm{sup}}$。\n4.  使用嵌入后的矢量计算费米矩阵元：$M_F = \\frac{1}{\\sqrt{2}} ( \\langle \\phi_{pp}^{\\mathrm{sup}} | \\phi_{pn}^{\\mathrm{sup}} \\rangle + \\langle \\phi_{pp}^{\\mathrm{sup}} | \\phi_{np}^{\\mathrm{sup}} \\rangle )$。\n5.  计算平均质心能量：$\\overline{\\langle H_{\\mathrm{cm}} \\rangle} = \\frac{1}{3}(\\langle H_{\\mathrm{cm}} \\rangle_{pp} + \\langle H_{\\mathrm{cm}} \\rangle_{pn} + \\langle H_{\\mathrm{cm}} \\rangle_{np})$。\n6.  存储当前测试用例的结果对 $(M_F, \\overline{\\langle H_{\\mathrm{cm}} \\rangle})$。\n对所有测试用例重复此过程，以生成最终的结果列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.linalg import eigh\n\ndef calculate_ground_state_properties(N_cm_max, N_rel_max, alpha, beta):\n    \"\"\"\n    Constructs and diagonalizes the Hamiltonian for a given sector.\n\n    Args:\n        N_cm_max (int): Maximum CM quantum number.\n        N_rel_max (int): Maximum relative quantum number.\n        alpha (float): Coupling strength.\n        beta (float): Lawson term parameter.\n\n    Returns:\n        tuple: A tuple containing:\n            - gs_vector (np.ndarray): The ground state eigenvector.\n            - h_cm_exp (float): The expectation value of H_cm in the ground state.\n    \"\"\"\n    dim_cm = N_cm_max + 1\n    dim_rel = N_rel_max + 1\n    dim = dim_cm * dim_rel\n    H = np.zeros((dim, dim))\n\n    # Define prefactors for position operators in specified units\n    x_cm = 0.5\n    x_rel = 1.0\n\n    # Build the Hamiltonian matrix\n    for N in range(dim_cm):\n        for n in range(dim_rel):\n            k = N * dim_rel + n\n\n            # Diagonal part: (1+beta)*H_cm + H_int\n            diag_val = (1.0 + beta) * (N + 0.5) + (n + 0.5)\n            H[k, k] = diag_val\n\n            # Off-diagonal part: alpha * X * x\n            if alpha != 0.0:\n                # Four possible connections: (N+/-1, n+/-1)\n                # Connection to (N+1, n+1)\n                if N + 1  dim_cm and n + 1  dim_rel:\n                    N_p, n_p = N + 1, n + 1\n                    k_p = N_p * dim_rel + n_p\n                    val = alpha * (x_cm * np.sqrt(N + 1)) * (x_rel * np.sqrt(n + 1))\n                    H[k, k_p] = val\n                    H[k_p, k] = val\n                \n                # Connection to (N+1, n-1)\n                if N + 1  dim_cm and n - 1 >= 0:\n                    N_p, n_p = N + 1, n - 1\n                    k_p = N_p * dim_rel + n_p\n                    val = alpha * (x_cm * np.sqrt(N + 1)) * (x_rel * np.sqrt(n))\n                    H[k, k_p] = val\n                    H[k_p, k] = val\n\n                # Connection to (N-1, n+1) - handled implicitly by symmetric filling\n                # Connection to (N-1, n-1) - handled implicitly by symmetric filling\n\n    # Diagonalize the Hermitian matrix\n    eigenvalues, eigenvectors = eigh(H)\n    \n    # Ground state is the eigenvector for the lowest eigenvalue\n    gs_vector = eigenvectors[:, 0]\n    \n    # Calculate expectation value of H_cm\n    h_cm_exp = 0.0\n    for N in range(dim_cm):\n        for n in range(dim_rel):\n            k = N * dim_rel + n\n            coeff_sq = gs_vector[k]**2\n            h_cm_exp += coeff_sq * (N + 0.5)\n            \n    return gs_vector, h_cm_exp\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and computes the required observables.\n    \"\"\"\n    test_cases = [\n        # (N_cm_pp_max, N_cm_pn_max, N_cm_np_max, N_rel_max, alpha, beta)\n        (3, 3, 3, 6, 0.0, 0.0),  # Case 1\n        (1, 1, 2, 6, 0.2, 0.0),  # Case 2\n        (0, 0, 0, 6, 0.2, 0.0),  # Case 3\n        (3, 3, 3, 6, 0.2, 5.0),  # Case 4\n        (1, 2, 3, 6, 0.5, 0.0),  # Case 5\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N_cm_pp_max, N_cm_pn_max, N_cm_np_max, N_rel_max, alpha, beta = case\n        \n        # Determine superspace dimensions\n        N_cm_sup = max(N_cm_pp_max, N_cm_pn_max, N_cm_np_max)\n        dim_rel_common = N_rel_max + 1\n        dim_sup = (N_cm_sup + 1) * dim_rel_common\n        \n        sector_params = {\n            'pp': N_cm_pp_max,\n            'pn': N_cm_pn_max,\n            'np': N_cm_np_max\n        }\n        \n        ground_states = {}\n        h_cm_expectations = {}\n        \n        for sector, N_cm_max in sector_params.items():\n            gs_vec, h_cm_exp = calculate_ground_state_properties(N_cm_max, N_rel_max, alpha, beta)\n            h_cm_expectations[sector] = h_cm_exp\n            \n            # Embed the ground state vector into the superspace\n            gs_sup = np.zeros(dim_sup)\n            dim_sec_cm = N_cm_max + 1\n            for N in range(dim_sec_cm):\n                start_idx_sec = N * dim_rel_common\n                end_idx_sec = start_idx_sec + dim_rel_common\n                \n                start_idx_sup = N * dim_rel_common\n                end_idx_sup = start_idx_sup + dim_rel_common\n                \n                gs_sup[start_idx_sup:end_idx_sup] = gs_vec[start_idx_sec:end_idx_sec]\n            \n            ground_states[sector] = gs_sup\n\n        # Calculate Fermi Matrix Element M_F\n        overlap_pp_pn = np.dot(ground_states['pp'], ground_states['pn'])\n        overlap_pp_np = np.dot(ground_states['pp'], ground_states['np'])\n        M_F = (1.0 / np.sqrt(2.0)) * (overlap_pp_pn + overlap_pp_np)\n        \n        # Calculate average H_cm expectation value\n        avg_h_cm = np.mean(list(h_cm_expectations.values()))\n\n        results.extend([M_F, avg_h_cm])\n\n    # Format the final output string as specified\n    output_str = f\"[{','.join(f'{x:.8f}' for x in results)}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}