{
    "hands_on_practices": [
        {
            "introduction": "计算$\\log ft$值的核心是精确求解相空间积分$f$。然而，在$Q$值很低的情况下，积分区间会变得极小，被积函数表现出数值“刚性”，给计算带来挑战。本练习  旨在通过变量替换等数值技巧，引导你开发一个即使在近阈值能量下也能保持稳健和精确的计算程序，这是任何可靠的$\\log ft$计算流程的基石。",
            "id": "3547408",
            "problem": "您的任务是实现一个计算程序，用于评估容许β负衰变的比较半衰期量，特别是计算统计速率函数与部分半衰期乘积的以10为底的对数（通常称为“log-ft”值）。您的程序必须解决在低端点能量衰变中出现的数值刚性问题，并且必须在多样化的测试套件中产生数值稳定的输出。\n\n从费米黄金定则和容许近似出发，衰变率可以表示为一个核结构因子和一个轻子相空间因子的乘积。比较半衰期将相空间分量分离出来。在使用电子静止能量进行缩放的无量纲电子能量单位中（即 $W \\equiv E_{e}/(m_{e} c^{2})$），定义端点 $W_{0}$ 为 $W_{0} = 1 + Q/(m_{e} c^{2})$，其中 $Q$ 是 $Q$值。对于一个容许跃迁（形状因子等于1），统计速率函数 $f$ 由轻子相空间积分给出：\n$$\nf(Z,Q) = \\int_{1}^{W_{0}} F(Z,W)\\, p\\, W\\, (W_{0} - W)^{2} \\, dW,\n$$\n其中 $p = \\sqrt{W^{2}-1}$ 是以 $m_{e} c$ 为单位的电子动量，而 $F(Z,W)$ 是从电荷为 $Z$ 的子核发生的β负发射的库仑校正（费米函数）。为模拟库仑畸变，使用经过充分检验的近似：\n$$\nF(Z,W) \\approx \\frac{2\\pi \\eta}{1 - e^{-2\\pi \\eta}}, \\quad \\eta \\equiv \\frac{\\alpha Z W}{p},\n$$\n其中 $\\alpha$ 是精细结构常数，而 $e$ 是自然对数的底。请以数值稳定的方式实现此表达式，特别是在小 $p$ 的情况下，通过直接计算组合 $p\\,F(Z,W)$ 来避免因相消导致的有效数字损失。使用电子静止能量 $m_{e} c^{2}$（单位：千电子伏特）为 $m_{e} c^{2} = 510.99895\\,\\text{keV}$，以及精细结构常数 $\\alpha = 1/137.035999084$。\n\n给定统计速率函数 $f$ 和半衰期 $t_{1/2}$，定义比较半衰期为 $f\\,t_{1/2}/b$，其中 $b$ 是跃迁的分支比，表示为0到1之间的纯小数。您的任务是计算\n$$\n\\log_{10}\\!\\left( f(Z,Q)\\,\\frac{t_{1/2}}{b} \\right).\n$$\n您必须设计计算过程，使其对于接近电子静止能量阈值的低 $Q$ 值是鲁棒的，此时积分域 $[1,W_{0}]$ 变得非常小，被积函数变得数值刚性。为此，您必须执行变量变换，将积分映射到一个固定区间，并解析地分离出小尺度因子，并且您必须使用一个代数上等价但数值上稳定的形式来计算 $p\\,F(Z,W)$，该形式在 $p \\to 0^{+}$ 时保持有限。\n\n请精确实现以下要求：\n- 使用变量替换 $W = 1 + (W_{0}-1)\\,x$，$x \\in [0,1]$，使得\n$$\nf(Z,Q) = (W_{0}-1)^{3}\\int_{0}^{1} \\left[ p(W)\\,F(Z,W) \\right]\\, W\\, (1-x)^{2}\\, dx,\n$$\n其中 $W = 1 + (W_{0}-1)\\,x$ 且 $p(W) = \\sqrt{W^{2}-1}$，从而将积分正则化到一个固定域上，并解析地捕捉 $(W_{0}-1)$ 的微小量级。\n- 使用以下公式计算 $p(W)\\,F(Z,W)$：\n$$\np(W)\\,F(Z,W) = \\frac{2\\pi\\,\\alpha\\,Z\\,W}{1 - \\exp\\!\\left(-2\\pi\\,\\alpha\\,Z\\,W/p(W)\\right)},\n$$\n并通过函数 $\\operatorname{expm1}$ 对分母进行数值稳定的实现，以处理小参数的情况。在 $Z=0$ 的特殊情况下，设 $F(Z,W)=1$，因此 $p(W)\\,F(Z,W)=p(W)$。\n- 将所有 $Q$值视为千电子伏特（keV）单位，所有半衰期视为秒单位，分支比视为无量纲小数。输出必须是 $\\log_{10}(f\\,t_{1/2}/b)$，无单位。\n- 使用双精度浮点算术。您的数值积分对于典型情况必须精确到至少约 $10^{-9}$ 的相对容限；对于近阈值情况，使用适当的绝对容限。\n\n测试套件。您的程序必须计算以下五个案例的输出：\n- 案例A（典型容许，中等 $Z$）：$Z = 20$，$Q = 3000.0\\,\\text{keV}$，$t_{1/2} = 10.0\\,\\text{s}$，$b = 1.0$。\n- 案例B（低 $Q$ 容许，类氚）：$Z = 1$，$Q = 18.6\\,\\text{keV}$，$t_{1/2} = 3.888\\times 10^{8}\\,\\text{s}$，$b = 1.0$。\n- 案例C（低 $Q$ 压力测试，玩具模型容许）：$Z = 30$，$Q = 100.0\\,\\text{keV}$，$t_{1/2} = 1.0\\times 10^{6}\\,\\text{s}$，$b = 1.0$。\n- 案例D（近阈值刚性，玩具模型容许）：$Z = 50$，$Q = 1.0\\,\\text{keV}$，$t_{1/2} = 1.0\\times 10^{12}\\,\\text{s}$，$b = 1.0$。\n- 案例E（高 $Z$ 库仑效应）：$Z = 82$，$Q = 1000.0\\,\\text{keV}$，$t_{1/2} = 1.0\\times 10^{4}\\,\\text{s}$，$b = 0.5$。\n\n最终输出规范：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与上述案例相同。每个值必须四舍五入到六位小数。例如，一个包含三个值的输出应如下所示：$[4.321000,5.432100,6.543210]$。",
            "solution": "该问题是有效的。它提出了一个在核物理领域定义良好、有科学依据的计算任务。所有必要的物理量、常数和计算约束都得到了清晰且自洽的定义。该问题解决了一个真实的数值挑战——β衰变相空间积分的计算，特别是在低能量区域——并指定了标准、适当的技术来确保解的稳定性和准确性。\n\n目标是计算比较半衰期的对数，即log-ft值，定义为 $\\log_{10}(f t_{1/2}/b)$。问题的核心是计算统计速率函数 $f(Z, Q)$，它表示发射的电子和反中微子可用的积分相空间，并受到电子与子核之间库仑相互作用的调制。\n\n容许β负衰变的统计速率函数由以下积分给出：\n$$\nf(Z,Q) = \\int_{1}^{W_{0}} F(Z,W)\\, p\\, W\\, (W_{0} - W)^{2} \\, dW\n$$\n在这里，所有与能量相关的量都通过电子静止能量 $m_e c^2 \\approx 510.99895\\,\\text{keV}$ 进行缩放，从而变得无量纲。电子的总能量是 $W$，其动量是 $p = \\sqrt{W^2 - 1}$，其最大可能能量（端点）是 $W_0 = 1 + Q/(m_e c^2)$，其中 $Q$ 是衰变能。函数 $F(Z,W)$ 是费米函数，用于校正电荷为 $Z$ 的子核对电子波函数的库仑畸变。一个常用且准确的 $F(Z,W)$ 近似式被使用：\n$$\nF(Z,W) \\approx \\frac{2\\pi \\eta}{1 - e^{-2\\pi \\eta}}, \\quad \\text{其中} \\quad \\eta = \\frac{\\alpha Z W}{p}\n$$\n并且 $\\alpha \\approx 1/137.035999084$ 是精细结构常数。\n\n在计算此积分时，出现了两个主要的数值挑战：\n1.  **收缩的积分域**：对于低 $Q$ 值，端点 $W_0$ 非常接近于 $1$，使得积分区间 $[1, W_0]$ 极其狭小。这可能导致标准数值积分程序的精度损失。为了缓解这个问题，采用了变量变换：$W = 1 + (W_0 - 1)x$。这将收缩的区间 $[1, W_0]$ 映射到新积分变量 $x$ 的固定区间 $[0, 1]$ 上。微分变为 $dW = (W_0 - 1)dx$，动能项变为 $(W_0 - W)^2 = (W_0 - 1)^2 (1 - x)^2$。相空间的微小量级随后通过一个 $(W_0 - 1)^3$ 的前置因子在解析上被捕捉，从而得到正则化积分：\n    $$\n    f(Z,Q) = (W_{0}-1)^{3}\\int_{0}^{1} \\left[ p(W)\\,F(Z,W) \\right]\\, W\\, (1-x)^{2}\\, dx\n    $$\n2.  **被积函数的数值稳定性**：项 $p F(Z,W)$ 的计算可能不稳定。当 $W \\to 1$（或 $x \\to 0$）时，动量 $p \\to 0$，导致费米函数中的项 $\\eta$ 发散。为了避免除零错误并保持精度，乘积 $p F(Z,W)$ 被代数上重排为一个稳定形式：\n    $$\n    p(W)\\,F(Z,W) = p(W) \\frac{2\\pi \\frac{\\alpha Z W}{p(W)}}{1 - \\exp\\left(-2\\pi \\frac{\\alpha Z W}{p(W)}\\right)} = \\frac{2\\pi\\alpha Z W}{1 - \\exp\\left(-2\\pi\\alpha Z W / p(W)\\right)}\n    $$\n    在极限 $p \\to 0$ 时，该表达式正确且稳定地趋近于有限值 $2\\pi\\alpha Z W$。此外，对于大 $p$，指数的参数 $y = 2\\pi\\alpha Z W / p$ 可能变得很小。直接计算 $1 - e^{-y}$ 可能会遭受灾难性相消。这个问题通过使用库函数 $\\operatorname{expm1}(x)$ 来解决，该函数能为小 $|x|$ 精确计算 $e^x - 1$。分母被计算为 $-(\\exp(-y) - 1) = -\\operatorname{expm1}(-y)$。\n\n计算过程如下：\n1.  定义物理常数 $m_e c^2$ 和 $\\alpha$。\n2.  对于每个测试案例 $(Z, Q, t_{1/2}, b)$，计算无量纲端点能量 $W_0$。\n3.  基于变换后的积分，定义一个关于变量 $x$ 的被积函数。此函数计算 $W(x)$、动量 $p(W)$ 以及项 $p(W)F(Z,W)$，使用上述数值稳定的方法。它正确处理 $Z=0$ 的特殊情况和 $x=0$（$p=0$）的极限。\n4.  使用高精度数值积分程序（`scipy.integrate.quad`）来计算该函数在区间 $[0, 1]$ 上的积分。设置适当的绝对和相对误差容限（$epsabs=10^{-15}$, $epsrel=10^{-10}$），以确保准确性，特别是对于积分值很小的近阈值情况。\n5.  将积分结果乘以 $(W_0 - 1)^3$，计算出最终的统计速率函数 $f(Z,Q)$。\n6.  将 $f(Z,Q)$ 与部分半衰期 $t_{1/2}/b$ 相乘，计算ft值。\n7.  取结果的以10为底的对数，$\\log_{10}(ft)$，并将其格式化为六位小数。\n\n此方法实现了所有要求，为一系列物理场景提供了鲁棒且准确的log-ft值计算。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import expm1\n\ndef solve():\n    \"\"\"\n    Calculates and prints log-ft values for a set of beta-minus decay test cases.\n    \"\"\"\n    # Define physical constants as specified in the problem statement.\n    M_E_C2_KEV = 510.99895\n    ALPHA = 1.0 / 137.035999084\n\n    def integrand_func(x, Z, W0):\n        \"\"\"\n        Computes the value of the integrand for the transformed phase-space integral.\n        The integration variable is x, which ranges from 0 to 1.\n        \n        Args:\n            x (float): The integration variable.\n            Z (int): The charge of the daughter nucleus.\n            W0 (float): The dimensionless endpoint energy.\n        \n        Returns:\n            float: The value of the integrand at x.\n        \"\"\"\n        # At the upper integration limit x=1, the (1-x)^2 term makes the integrand zero.\n        if x == 1.0:\n            return 0.0\n\n        # Apply the change of variables: W(x) = 1 + (W0 - 1) * x\n        delta_W = W0 - 1.0\n        W = 1.0 + delta_W * x\n\n        # Handle the lower integration limit x=0 where momentum p=0.\n        if x == 0.0:\n            if Z == 0:\n                # If there's no Coulomb interaction, the integrand is zero at p=0.\n                return 0.0\n            # The limiting value of p*F(Z,W) as p->0 is 2*pi*alpha*Z*W.\n            # At x=0, W=1.\n            pF_limit = 2.0 * np.pi * ALPHA * Z\n            # The full integrand is pF * W * (1-x)^2.\n            return pF_limit * 1.0 * (1.0)**2\n\n        # For x > 0:\n        # Calculate electron momentum p = sqrt(W^2 - 1) using a numerically stable form.\n        p_squared = (W - 1.0) * (W + 1.0)\n        p = np.sqrt(p_squared)\n\n        # Calculate the product p * F(Z, W) using the specified numerically stable expression.\n        if Z == 0:\n            p_times_F = p\n        else:\n            # For 1 - exp(-y), use -expm1(-y) to maintain precision when y is small.\n            # y = 2*pi*alpha*Z*W / p\n            numerator = 2.0 * np.pi * ALPHA * Z * W\n            arg_exp = -numerator / p\n            denominator = -expm1(arg_exp)\n            p_times_F = numerator / denominator\n        \n        # The full integrand expression is [p*F] * W * (1.0 - x)^2.\n        return p_times_F * W * (1.0 - x)**2\n\n    def calculate_log_ft(Z, Q, t_half, b):\n        \"\"\"\n        Calculates the log-ft value for a single beta decay case.\n        \"\"\"\n        # Beta decay is energetically forbidden if Q = 0.\n        if Q = 0:\n            return np.nan\n\n        # Dimensionless endpoint energy.\n        W0 = 1.0 + Q / M_E_C2_KEV\n        delta_W = W0 - 1.0\n        \n        # Numerically evaluate the transformed integral.\n        integral_val, _ = quad(\n            integrand_func,\n            0,\n            1,\n            args=(Z, W0),\n            epsabs=1e-15,  # Small absolute tolerance for near-threshold cases.\n            epsrel=1e-10   # High relative tolerance for accuracy.\n        )\n        \n        # Calculate the statistical rate function f(Z,Q) = (W0 - 1)^3 * Integral.\n        f_val = (delta_W**3) * integral_val\n        \n        # The branching fraction must be positive.\n        if b = 0:\n            return np.nan\n        \n        # The ft value is f * t_partial, where t_partial = t_half / b.\n        ft_value = f_val * (t_half / b)\n        \n        # The log is only defined for positive ft values.\n        if ft_value = 0:\n            return np.nan\n            \n        return np.log10(ft_value)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Z_daughter, Q_keV, t_half_s, branching_fraction)\n        (20, 3000.0, 10.0, 1.0),      # Case A\n        (1, 18.6, 3.888e8, 1.0),      # Case B\n        (30, 100.0, 1.0e6, 1.0),      # Case C\n        (50, 1.0, 1.0e12, 1.0),       # Case D\n        (82, 1000.0, 1.0e4, 0.5),     # Case E\n    ]\n    \n    results = []\n    for case in test_cases:\n        Z, Q, t_half, b = case\n        log_ft = calculate_log_ft(Z, Q, t_half, b)\n        results.append(f\"{log_ft:.6f}\")\n        \n    # Print the results in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在核物理中，并非所有的$\\beta$衰变都遵循最简单的“容许”跃迁规则，许多重要的衰变属于“禁戒”跃迁。这些跃迁的独特之处在于它们的谱形因子$C(W)$不为常数，从而改变了出射电子的能量谱。本练习  将带你探索超越容许近似的领域，通过为唯一禁戒跃迁实现相应的谱形因子，扩展你的计算工具，使其能处理更多样化、更复杂的衰变类型。",
            "id": "3547481",
            "problem": "你的任务是实现一个程序，用于计算β衰变跃迁的比较半衰期以10为底的对数（通常称为log-ft值）。在计算核物理中，这些跃迁被视为单禁戒跃迁。计算必须从Fermi β衰变理论出发，通过推导适用于单禁戒跃迁的无量纲相空间积分，然后将其与分支半衰期结合以获得最终量。所有数学实体必须用电子静止质量能量和精细结构常数一致地表示，并且程序必须在一系列具有科学意义的测试用例中产生数值稳定的结果。\n\n从以下基础知识开始。单位电子总能量$W$（以电子静止质量能量$m_e c^2$为单位）的β衰变谱率为：\n$$\n\\frac{d\\lambda}{dW} \\propto p \\, W \\, (W_0 - W)^2 \\, F(Z, W)\\, C(W),\n$$\n其中，$p$是电子动量（以$m_e c$为单位），$W$是电子总能量（以$m_e c^2$为单位），$W_0$是终点能量（也以$m_e c^2$为单位），$Z$是子核的原子序数，$F(Z,W)$是考虑出射电子波函数库仑畸变的Fermi函数，$C(W)$是由核跃迁类型决定的形状因子。电子动量为 $p = \\sqrt{W^2 - 1}$，对于近似无质量的反中微子，中微子动量取为 $q = W_0 - W$。终点能量为 $W_0 = 1 + Q/(m_e c^2)$，其中 $Q$ 是β衰变的$Q$值，单位为兆电子伏特。\n\n比较半衰期使用由积分定义的无量纲相空间因子$f$：\n$$\nf(Z, Q; \\text{type}) = \\int_{W=1}^{W_0} p \\, W \\, (W_0 - W)^2 \\, F(Z, W) \\, C(W; \\text{type}) \\, dW.\n$$\n那么，以10为底的log-ft值为：\n$$\n\\log_{10} f t = \\log_{10} \\left( f(Z, Q; \\text{type}) \\times t_p \\right),\n$$\n其中分支半衰期 $t_p$ 与总半衰期 $t_{1/2}$ 和分支比 $B$ 的关系为 $t_p = t_{1/2}/B$。量 $\\log_{10} f t$ 是无量纲的，但 $t_{1/2}$ 和 $t_p$ 必须以秒为单位提供，$Q$ 必须以兆电子伏特为单位提供。分支比 $B$ 必须以小数形式提供。\n\n对于Fermi函数，使用广泛采用的近似：\n$$\nF(Z, W) = \\frac{2\\pi \\eta}{1 - e^{-2\\pi \\eta}}, \\quad \\eta = \\alpha Z \\frac{W}{p},\n$$\n其中 $\\alpha$ 是精细结构常数。这个近似适用于忽略了有限尺寸和屏蔽修正的β-衰变，对于本次计算练习而言是可以接受的。\n\n处理以下跃迁类型和相关的形状因子：\n- 容许跃迁（$\\text{type} = \\text{U0}$），其形状因子为\n$$\nC(W; \\text{U0}) = 1.\n$$\n- 单一级禁戒跃迁（$\\text{type} = \\text{U1}$），其形状因子为\n$$\nC(W; \\text{U1}) = p^2 + q^2.\n$$\n- 单二级禁戒跃迁（$\\text{type} = \\text{U2}$），其形状因子为\n$$\nC(W; \\text{U2}) = p^4 + \\frac{10}{3} p^2 q^2 + q^4.\n$$\n\n使用稳健的求积法对 $f(Z, Q; \\text{type})$ 在 $W \\in [1, W_0]$ 上进行数值积分。确保在边界 $W = 1$（此时 $p \\to 0$）和 $W = W_0$（此时 $q \\to 0$）处的数值稳定性，并确保在 $p$ 很小时稳定地处理库仑因子。程序必须为一套具有科学合理性的测试用例计算 $\\log_{10} f t$ 并打印结果。\n\n使用的常数和单位：\n- 电子静止质量能量 $m_e c^2 = 0.51099895 \\, \\text{MeV}$。\n- 精细结构常数 $\\alpha = 1/137.035999084$。\n- 所有半衰期 $t_{1/2}$ 以秒为单位，所有分支比 $B$ 为小数形式，所有 $Q$ 值以兆电子伏特为单位。\n\n测试套件参数值：\n- 案例1（一般单一级禁戒跃迁，中等的Z和Q）：$Z = 26$, $A = 59$, $Q = 1.823 \\, \\text{MeV}$, $t_{1/2} = 44.5 \\, \\text{s}$, $B = 0.85$, $\\text{type} = \\text{U1}$。\n- 案例2（边界低Q值单一级禁戒跃迁，高Z）：$Z = 50$, $A = 115$, $Q = 0.120 \\, \\text{MeV}$, $t_{1/2} = 3.0 \\times 10^{7} \\, \\text{s}$, $B = 1.0$, $\\text{type} = \\text{U1}$。\n- 案例3（单二级禁戒跃迁，高Z）：$Z = 82$, $A = 214$, $Q = 2.000 \\, \\text{MeV}$, $t_{1/2} = 1.0 \\times 10^{5} \\, \\text{s}$, $B = 0.6$, $\\text{type} = \\text{U2}$。\n- 案例4（容许跃迁，用于比较，低Z）：$Z = 8$, $A = 14$, $Q = 3.000 \\, \\text{MeV}$, $t_{1/2} = 70.0 \\, \\text{s}$, $B = 1.0$, $\\text{type} = \\text{U0}$。\n\n你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是对应案例计算出的 $\\log_{10} f t$ 值，按上述顺序列出，并四舍五入到六位小数。例如，它应该打印一个形式为 $[\\ell_1,\\ell_2,\\ell_3,\\ell_4]$ 的字符串，其中每个 $\\ell_i$ 是一个小数点后有六位数位的浮点数。",
            "solution": "β衰变的比较半衰期的计算基于Fermi理论，其中微分衰变率 $\\frac{d\\lambda}{dW}$ 取决于可用的相空间以及被子核库仑场扭曲的轻子波函数。这个基本表达式\n$$\n\\frac{d\\lambda}{dW} \\propto p \\, W \\, (W_0 - W)^2 \\, F(Z, W)\\, C(W),\n$$\n源自Fermi黄金定则和对出射轻子的相对论处理。此处，$W$是电子总能量（以$m_e c^2$为单位），$p = \\sqrt{W^2 - 1}$是电子动量（以$m_e c$为单位），而在中微子质量可忽略的近似下，$q = W_0 - W$是中微子动量。终点能量 $W_0 = 1 + Q/(m_e c^2)$ 直接由能量守恒得出，其中 $Q$ 是β衰变能量，单位为兆电子伏特。\n\n无量纲相空间积分\n$$\nf(Z, Q; \\text{type}) = \\int_{1}^{W_0} p \\, W \\, (W_0 - W)^2 \\, F(Z, W)\\, C(W; \\text{type}) \\, dW\n$$\n集合了运动学效应、库仑效应以及由核跃迁算符引起的谱形畸变。Fermi函数 $F(Z, W)$ 体现了发射的电子与子核之间的库仑吸引力。虽然精确处理涉及带有有限尺寸修正的Dirac方程的解，但一个广泛使用且适用于计算的稳定近似是\n$$\nF(Z, W) = \\frac{2\\pi \\eta}{1 - e^{-2\\pi \\eta}}, \\quad \\eta = \\alpha Z \\frac{W}{p},\n$$\n其中 $\\alpha$ 是精细结构常数。在阈值 $W \\to 1$ 附近，$p \\to 0$，$\\eta$ 变得很大，使得 $F \\approx 2\\pi \\eta$；此时乘积 $p F \\approx 2\\pi \\alpha Z W$ 保持有限，确保了积分在数值上表现良好。\n\n谱形状因子 $C(W)$ 取决于核跃迁类型。对于容许跃迁，轻子对不携带轨道角动量，我们得到 $C(W; \\text{U0}) = 1$。对于单禁戒跃迁，一个阶数等于禁戒度的单一核算符决定了能谱；形状因子成为一个关于 $p^2$ 和 $q^2$ 的多项式，其系数由角动量耦合和相对论流结构确定。对于单一级禁戒跃迁，我们得到\n$$\nC(W; \\text{U1}) = p^2 + q^2,\n$$\n而对于单二级禁戒跃迁，形状因子为\n$$\nC(W; \\text{U2}) = p^4 + \\frac{10}{3} p^2 q^2 + q^4.\n$$\n这些表达式源于弱相互作用哈密顿量的多极展开，并要求轻子系统携带的轨道角动量与核算符的阶数相匹配，并与总自旋转移一致地耦合。\n\n比较半衰期是通过将运动学积分与分支半衰期 $t_p = t_{1/2}/B$ 相结合来构建的，其中 $t_{1/2}$ 是以秒为单位的总半衰期，$B$ 是以小数形式提供的分支比。常规量\n$$\n\\log_{10} f t = \\log_{10} \\left( f(Z, Q; \\text{type}) \\times t_p \\right)\n$$\n是无量纲的。尽管在完整理论中，$t_p$ 还依赖于核矩阵元的平方和耦合常数，但 $\\log_{10} f t$ 的定义有意地将运动学积分分离出来，以便于跨跃迁进行经验比较。\n\n算法设计：\n- 定义常数 $m_e c^2 = 0.51099895 \\, \\text{MeV}$ 和 $\\alpha = 1/137.035999084$。\n- 对于给定的 $Z$、$Q$ 和跃迁类型，计算 $W_0 = 1 + Q/(m_e c^2)$。\n- 实现被积函数 $I(W) = p \\, W \\, (W_0 - W)^2 \\, F(Z, W) \\, C(W; \\text{type})$，其中 $p = \\sqrt{W^2 - 1}$ 且 $q = W_0 - W$。\n- 将 $F(Z,W)$ 实现为 $F = \\frac{2\\pi \\eta}{1 - e^{-2\\pi \\eta}}$，其中 $\\eta = \\alpha Z \\frac{W}{p}$。为了避免在 $p$ 极小时出现除以零的情况，通过将其替换为 $p_\\epsilon = \\max(p, \\epsilon)$ 来限制 $p$ 的值，其中 $\\epsilon$ 是一个小的正数，例如 $\\epsilon = 10^{-12}$。这保留了正确的极限行为，因为 $p F$ 保持有限。\n- 使用具有适当绝对和相对容差的自适应求积法对 $I(W)$ 在 $W \\in [1, W_0]$ 上进行数值积分。被积函数在 $W = W_0$ 处由于 $(W_0 - W)^2$ 因子而为零；在 $W=1$ 附近，如上所述，被积函数保持有限。\n- 计算以秒为单位的 $t_p = t_{1/2}/B$，然后用以10为底的对数计算 $\\log_{10} f t$。\n- 对最终输出应用四舍五入到六位小数。\n\n测试套件注意事项：\n- 案例1测试具有中等Z和Q的常规单一级禁戒跃迁。\n- 案例2测试低Q值的边界情况，此时相空间受到严重限制，并检验在具有显著库仑畸变的短积分区间上的数值稳定性。\n- 案例3测试高Z下的单二级禁戒跃迁，以检验多项式形状因子和库仑增强效应。\n- 案例4提供一个容许跃迁用于比较，以验证当$C(W) = 1$时，代码能简化为典型的容许谱形状。\n\n程序将计算并以 $[\\ell_1,\\ell_2,\\ell_3,\\ell_4]$ 的格式单行打印结果，其中每个 $\\ell_i$ 是对应案例计算出的 $\\log_{10} f t$ 值，四舍五入到六位小数，以确保输出简洁且可测试。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\n# Constants\nME_MEV = 0.51099895  # electron rest mass energy in MeV\nALPHA = 1.0 / 137.035999084  # fine-structure constant\n\ndef fermi_function(Z: float, W: float, p: float) -> float:\n    \"\"\"\n    Coulomb Fermi function approximation:\n    F(Z, W) = 2*pi*eta / (1 - exp(-2*pi*eta)), eta = alpha*Z*W/p\n    Uses a small-clamp for p in eta to avoid division by zero at threshold.\n    \"\"\"\n    p_eff = max(p, 1e-12)\n    eta = ALPHA * Z * W / p_eff\n    # For large eta, exp(-2*pi*eta) underflows to 0, which is fine.\n    denom = 1.0 - np.exp(-2.0 * np.pi * eta)\n    # Avoid potential numerical issue if denom is 0 (should not happen for eta > 0)\n    if denom == 0.0:\n        return 2.0 * np.pi * eta\n    return (2.0 * np.pi * eta) / denom\n\ndef shape_factor(W: float, W0: float, p: float, transition_type: str) -> float:\n    \"\"\"\n    Shape factor C(W) for specified transition type:\n    - U0: Allowed, C = 1\n    - U1: Unique first-forbidden, C = p^2 + q^2\n    - U2: Unique second-forbidden, C = p^4 + (10/3) p^2 q^2 + q^4\n    \"\"\"\n    q = W0 - W\n    if transition_type == 'U0':\n        return 1.0\n    elif transition_type == 'U1':\n        return p**2 + q**2\n    elif transition_type == 'U2':\n        return p**4 + (10.0/3.0) * (p**2) * (q**2) + q**4\n    else:\n        raise ValueError(f\"Unsupported transition type: {transition_type}\")\n\ndef phase_space_integral(Z: float, Q_mev: float, transition_type: str) -> float:\n    \"\"\"\n    Compute the dimensionless phase-space factor f(Z, Q; type):\n    f = ∫_{W=1}^{W0} p W (W0 - W)^2 F(Z,W) C(W;type) dW\n    \"\"\"\n    W0 = 1.0 + Q_mev / ME_MEV\n\n    def integrand(W: float) -> float:\n        p = np.sqrt(max(W*W - 1.0, 0.0))\n        q = W0 - W\n        F = fermi_function(Z, W, p)\n        C = shape_factor(W, W0, p, transition_type)\n        return p * W * (q**2) * F * C\n\n    # Integrate with adaptive quadrature. Handle narrow ranges robustly.\n    result, err = quad(integrand, 1.0, W0, epsabs=1e-10, epsrel=1e-8, limit=200)\n    return result\n\ndef logft(Z: float, Q_mev: float, t_half_s: float, branch: float, transition_type: str) -> float:\n    \"\"\"\n    Compute log10(ft) = log10( f(Z,Q;type) * t_p ), t_p = t_half / branch\n    \"\"\"\n    f_val = phase_space_integral(Z, Q_mev, transition_type)\n    t_p = t_half_s / branch\n    # Avoid log of zero if somehow f_val is numerically zero (should not occur for Q>0).\n    ft = max(f_val * t_p, np.finfo(float).tiny)\n    return float(np.log10(ft))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (Z, A, Q [MeV], t_half [s], branch [decimal], transition_type)\n    test_cases = [\n        (26, 59, 1.823, 44.5, 0.85, 'U1'),     # Case 1\n        (50, 115, 0.120, 3.0e7, 1.0, 'U1'),    # Case 2\n        (82, 214, 2.000, 1.0e5, 0.6, 'U2'),    # Case 3\n        (8, 14, 3.000, 70.0, 1.0, 'U0'),       # Case 4\n    ]\n\n    results = []\n    for Z, A, Q_mev, t_half_s, branch, transition_type in test_cases:\n        val = logft(float(Z), float(Q_mev), float(t_half_s), float(branch), transition_type)\n        # Round to six decimal places\n        results.append(f\"{val:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在追求高精度的$\\log ft$值计算中，我们所使用的物理模型的准确性至关重要。标准的费米函数本身是一个非相对论近似，对于重核或要求极高精度的场景，其局限性便会显现。本练习  将引导你实现一个基于狄拉克方程的更精确的相对论库仑修正因子，并将其结果与传统近似进行定量比较，让你亲身体会精密物理模型对计算结果的深刻影响。",
            "id": "3547446",
            "problem": "实现一个完整且可运行的程序，以高数值精度计算核贝塔衰变的统计速率函数（也称为相空间因子），\n$$\nf = \\int_{1}^{W_0} p\\,W\\,(W_0 - W)^2\\,F(Z,W)\\,C(W)\\,dW,\n$$\n其中，$W$ 是带电轻子的总能量（以电子静止能量 $m_e c^2$ 为单位），$p=\\sqrt{W^2-1}$ 是带电轻子的动量（使用相同单位），$W_0$ 是端点总能量（以 $m_e c^2$ 为单位），$Z$ 是子核的电荷数，$F(Z,W)$ 是考虑了核场对轻子波函数畸变的库仑函数，而 $C(W)$ 是形状因子。假设为容许跃迁，因此 $C(W)=1$。目标是：\n- 使用从在核半径处求值的精确狄拉克波函数导出的相对论性库仑函数 $F(Z,W)$ 来计算 $f$（点核库仑-狄拉克解，在锐球半径处进行有限尺寸归一化）。\n- 使用教科书中的非相对论费米（伽莫夫）函数再次计算 $f$。\n- 通过报告 $\\Delta \\log ft = \\log_{10} f_{\\mathrm{Dirac}} - \\log_{10} f_{\\mathrm{Gamow}}$ 来量化对比较半衰期量 $\\log ft$ 的影响，其中部分半衰期 $t$ 在差值中被消去。\n\n必须使用的基础理论：\n- 从费米黄金定则处理贝塔衰变出发，并采用上述积分给出的统计速率函数 $f$ 的定义。\n- 使用在点库仑场中从狄拉克波函数获得的、并在核半径处求值的相对论性库仑函数。您必须实现由狄拉克-库仑解所蕴含的、以精细结构常数和伽马函数表示的精确闭合形式表达式，不得引入唯象拟合公式。\n- 使用教科书中的非相对论伽莫夫因子作为比较用的 $F(Z,W)$。\n\n需使用的定义、单位和常数：\n- 将 $W$ 和 $W_0$ 视为无量纲量，以 $m_e c^2$ 为单位。动量 $p=\\sqrt{W^2-1}$ 也是无量纲的。\n- 对于负贝塔衰变（$\\beta^-$），库仑参数为吸引符号；对于正贝塔衰变（$\\beta^+$），符号相反。在库仑因子中使用子核的电荷数 $Z$。\n- 使用精细结构常数 $\\alpha = 1/137.035999084$。\n- 使用锐球核半径模型 $R = r_0 A^{1/3}$，其中 $r_0 = 1.2\\,\\mathrm{fm}$。通过除以电子康普顿波长 $\\lambda_C \\approx 386.1592676\\,\\mathrm{fm}$，将 $R$ 转换为无量纲单位，以便在狄拉克-库仑因子中使用的 $R$ 是以电子康普顿波长为单位的。\n- 假设对于所有能量 $W$，$C(W)=1$。\n\n高精度数值要求：\n- 计算 $f$ 的积分时，绝对容差低于 $10^{-12}$，相对容差低于 $10^{-9}$。\n- 确保在阈值 $W \\to 1$ 附近以及对于大的 $Z$ 值时数值的稳定性。\n- 对于狄拉克情形和伽莫夫情形的函数 $F(Z,W)$，必须在整个积分域内以数值稳定的方式实现。\n\n需要实现和计算的测试套件：\n- 每个测试用例是一个元组 $(Z,A,W_0,\\mathrm{polarity})$，其中 $\\mathrm{polarity}$ 是 $\\beta^-$ 或 $\\beta^+$，并且 $C(W)=1$。\n- 使用以下科学上合理且多样化的案例：\n    1. $(Z,A,W_0,\\mathrm{polarity}) = (26,60,4.0,\\beta^-)$\n    2. $(Z,A,W_0,\\mathrm{polarity}) = (82,214,2.5,\\beta^-)$\n    3. $(Z,A,W_0,\\mathrm{polarity}) = (28,58,2.2,\\beta^+)$\n    4. $(Z,A,W_0,\\mathrm{polarity}) = (8,16,1.1,\\beta^-)$\n    5. $(Z,A,W_0,\\mathrm{polarity}) = (20,40,10.0,\\beta^-)$\n\n对每个测试用例，计算：\n- $f_{\\mathrm{Dirac}}$，使用从狄拉克波函数得到的相对论性库仑函数。\n- $f_{\\mathrm{Gamow}}$，使用教科书中的非相对论伽莫夫因子。\n- $\\Delta \\log ft = \\log_{10} f_{\\mathrm{Dirac}} - \\log_{10} f_{\\mathrm{Gamow}}$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的三元组列表，每个测试用例一个三元组，顺序与指定顺序相同。每个三元组本身也是一个用方括号括起来的、以逗号分隔的列表 $[f_{\\mathrm{Dirac}},f_{\\mathrm{Gamow}},\\Delta \\log ft]$。\n- 所有浮点数必须精确到小数点后八位。\n- 例如，您的输出必须类似于\n$$\n[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3],[x_4,y_4,z_4],[x_5,y_5,z_5]]\n$$\n不带有多余的空格或文本。\n\n科学真实性和约束条件：\n- 所有计算都必须使用上述定义执行。统计速率函数 $f$ 是无量纲的；报告的所有值都应为不带单位的纯数。\n- 程序必须是自包含的，不得读取任何输入，并且必须逐字使用提供的测试套件。",
            "solution": "该问题要求为一组测试用例计算核贝塔衰变的统计速率函数（或称相空间因子）$f$。此计算必须使用两种不同的库仑修正函数 $F(Z,W)$ 模型来执行：一种是基于狄拉克波函数的复杂相对论模型，另一种是更简单的非相对论伽莫夫因子。目标是量化这两种模型导致的比较半衰期 $\\log ft$ 的差异。\n\n统计速率函数 $f$ 由以下积分定义：\n$$\nf = \\int_{1}^{W_0} p\\,W\\,(W_0 - W)^2\\,F(Z,W)\\,C(W)\\,dW\n$$\n被积函数的各组成部分定义如下：\n- $W$ 是发射出的轻子（$\\beta^-$ 或 $\\beta^+$）的总能量，以电子静止质量能 $m_e c^2$ 为单位。\n- $W_0$ 是轻子可能的最大能量，也以 $m_e c^2$ 为单位。它由衰变的 $Q$ 值决定。\n- $p = \\sqrt{W^2-1}$ 是轻子的动量，以 $m_e c$ 为单位。\n- $Z$ 是子核的电荷数。\n- $F(Z,W)$ 是库仑函数（或费米函数），它修正了子核库仑场对轻子波函数的畸变。\n- $C(W)$ 是形状因子，它取决于核矩阵元。对于此处假设的容许跃迁，$C(W)=1$。\n\n$f$ 的积分范围从轻子可能的最小能量（$W=1$，对应于零动能）到最大能量（$W=W_0$）。将使用数值积分法进行计算。\n\n问题的核心在于实现 $F(Z,W)$ 的两种指定形式。\n\n**1. 非相对论伽莫夫因子, $F_{\\mathrm{Gamow}}(Z,W)$**\n\n这是库仑修正的教科书近似，在非相对论量子力学中导出。它由下式给出：\n$$\nF_{\\mathrm{Gamow}}(Z,W) = \\frac{2\\pi\\eta}{1 - e^{-2\\pi\\eta}}\n$$\n其中 $\\eta$ 是索末菲参数，定义为：\n$$\n\\eta = \\frac{Z_{\\mathrm{eff}}\\alpha W}{p} = \\frac{Z_{\\mathrm{eff}}\\alpha W}{\\sqrt{W^2-1}}\n$$\n- $\\alpha \\approx 1/137.036$ 是精细结构常数。\n- $Z_{\\mathrm{eff}}$ 是轻子感受到的有效电荷。对于 $\\beta^-$ 衰变（电子发射），库仑力是吸引力，因此我们使用子核电荷，$Z_{\\mathrm{eff}}=Z$。对于 $\\beta^+$ 衰变（正电子发射），力是排斥力，因此我们使用 $Z_{\\mathrm{eff}}=-Z$。\n\n一个关键的数值考虑是该函数的行为。当 $W \\to 1$ 时，$p \\to 0$，导致 $|\\eta| \\to \\infty$。\n- 对于 $\\beta^-$ 衰变（$Z_{\\mathrm{eff}}0$），$\\eta \\to +\\infty$。在此极限下，$e^{-2\\pi\\eta} \\to 0$ 且 $F_{\\mathrm{Gamow}} \\approx 2\\pi\\eta \\propto 1/p$。因此，被积函数项 $p \\cdot F_{\\mathrm{Gamow}}$ 趋于一个有限常数。\n- 对于 $\\beta^+$ 衰变（$Z_{\\mathrm{eff}}0$），$\\eta \\to -\\infty$。在此极限下，$F_{\\mathrm{Gamow}} \\approx -2\\pi\\eta \\, e^{2\\pi\\eta}$，该值迅速趋近于 $0$。在 $W=1$ 处，被积函数为零。\n对于 $\\eta \\to 0$（当 $Z=0$ 时会发生），泰勒展开显示 $F_{\\mathrm{Gamow}} \\to 1$。\n\n**2. 相对论狄拉克-库仑因子, $F_{\\mathrm{Dirac}}(Z,W)$**\n\n该方法通过使用库仑势中轻子的狄拉克方程解，提供了一个更精确的描述。问题指定了一种标准公式，该公式通过在核表面评估波函数解来包含对核有限尺寸的修正。其表达式为：\n$$\nF_{\\mathrm{Dirac}}(Z,W) = 2(1+\\gamma_1) (2pR')^{2(\\gamma_1-1)} \\frac{|\\Gamma(\\gamma_1 + i y)|^2}{(\\Gamma(2\\gamma_1 + 1))^2} e^{\\pi y}\n$$\n此公式中的参数为：\n- $y = \\eta = \\frac{Z_{\\mathrm{eff}}\\alpha W}{p}$。\n- $\\gamma_1 = \\sqrt{1 - (\\alpha Z)^2}$。这里，$Z$ 是子核电荷的绝对值。对于所有已知核素（$Z \\le 118$），此参数为实数。\n- $R'$ 是无量纲单位的核半径，通过将物理半径 $R$ 除以电子康普顿波长 $\\lambda_C \\approx 386.159\\,\\mathrm{fm}$ 得到。物理半径 $R$ 使用锐球模型计算：$R = r_0 A^{1/3}$，其中 $r_0 = 1.2\\,\\mathrm{fm}$，$A$ 是子核的质量数。\n- $\\Gamma(z)$ 是复伽马函数。项 $|\\Gamma(\\gamma_1 + i y)|^2$ 需要对复数参数求伽马函数的值。\n\n$F_{\\mathrm{Dirac}}$ 在 $W \\to 1$（$p \\to 0$）时的数值行为至关重要。由于 $\\gamma_1  1$，指数 $2(\\gamma_1-1)$ 为负。项 $(2pR')^{2(\\gamma_1-1)}$ 在 $p \\to 0$ 时发散。利用复伽马函数的渐近行为，对于大的 $|y|$，$|\\Gamma(x+iy)|^2 \\approx 2\\pi |y|^{2x-1}e^{-\\pi|y|}$，可以证明 $F_{\\mathrm{Dirac}} \\propto 1/p$。与伽莫夫情形类似，被积函数中的因子 $p$ 消除了这个奇点，导致在积分边界 $W=1$ 处得到一个有限值。这确保了积分是良态的，并且可以使用标准数值积分库（如 `scipy.integrate.quad`）精确计算。\n\n**3. 算法实现与计算**\n\n解决方案将使用 Python 的 `numpy` 和 `scipy` 库来实现。总体算法如下：\n1. 定义物理常数：$\\alpha$、$r_0$、$\\lambda_C$。\n2. 对于每个测试用例 $(Z, A, W_0, \\mathrm{polarity})$：\n   a. 根据衰变极性确定 $Z_{\\mathrm{eff}}$。\n   b. 定义两个被积函数，一个使用 $F_{\\mathrm{Gamow}}$，另一个使用 $F_{\\mathrm{Dirac}}$。这些函数以 $W$ 为积分变量，并以用例参数（$Z, A, W_0$ 等）为参数。\n   c. 使用 `scipy.integrate.quad` 计算从 $W=1$ 到 $W=W_0$ 的 $f_{\\mathrm{Gamow}}$ 积分。将使用指定的高精度容差（`epsabs=1e-12`, `epsrel=1e-9`）。\n   d. 类似地，计算 $f_{\\mathrm{Dirac}}$ 的积分。$F_{\\mathrm{Dirac}}$ 的实现需要 `scipy.special.gamma` 来处理复数参数。\n   e. 计算最终量 $\\Delta \\log ft = \\log_{10}(f_{\\mathrm{Dirac}}) - \\log_{10}(f_{\\mathrm{Gamow}})$。该量是相对论和有限尺寸效应对提取的 $ft$ 值影响的直接度量。\n3. 整理所有测试用例计算出的三元组 $[f_{\\mathrm{Dirac}}, f_{\\mathrm{Gamow}}, \\Delta \\log ft]$。\n4. 按照规定将最终结果格式化为单个字符串：一个三元组列表，每个数字格式化为八位小数，并将其打印到标准输出。\n这种结构化的方法确保满足了问题的所有物理和数值要求，从而产生精确且可验证的结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy import integrate\nfrom scipy import special\n\n# Set up constants based on the problem statement.\nALPHA = 1 / 137.035999084\nR0_FM = 1.2\nLAMBDA_C_FM = 386.1592676\n\ndef F_gamow(W, Z_eff):\n    \"\"\"\n    Computes the non-relativistic Gamow factor.\n    \"\"\"\n    # For Z_eff = 0, F should be 1.\n    if Z_eff == 0:\n        return 1.0\n\n    # The integrator p * F has a finite limit at W=1.\n    # We must avoid division by zero if W=1 is ever passed directly.\n    if W == 1.0:\n        return np.inf if Z_eff > 0 else 0.0\n\n    p_sq = W**2 - 1\n    if p_sq = 0:\n        return np.inf if Z_eff > 0 else 0.0\n    p = np.sqrt(p_sq)\n    \n    eta = Z_eff * ALPHA * W / p\n    x = 2 * np.pi * eta\n\n    # Use expm1 for numerical stability. 1-exp(-x) = -expm1(-x)\n    denominator = -special.expm1(-x)\n    if denominator == 0.0: # Handles case x=0\n        return 1.0\n    return x / denominator\n\ndef F_dirac(W, Z_daughter, Z_eff, A):\n    \"\"\"\n    Computes the relativistic Dirac-Coulomb factor.\n    \"\"\"\n    if Z_daughter == 0:\n        return 1.0\n\n    # The integrand p * F has a finite limit at W=1.\n    if W == 1.0:\n        return np.inf\n\n    p_sq = W**2 - 1\n    if p_sq = 0:\n        return np.inf\n    p = np.sqrt(p_sq)\n\n    # Dimensionless nuclear radius\n    R_prime = (R0_FM * A**(1/3)) / LAMBDA_C_FM\n    \n    az_sq = (ALPHA * Z_daughter)**2\n    # This check is for robustness; not expected for test cases.\n    if az_sq >= 1.0:\n      raise ValueError(\"Invalid Z: (alpha*Z)^2 >= 1\")\n    gamma1 = np.sqrt(1.0 - az_sq)\n    \n    # Sommerfeld-like parameter for the Dirac case\n    y = Z_eff * ALPHA * W / p\n\n    # Evaluate the components of the F_dirac formula\n    term1 = 2 * (1 + gamma1)\n    term2 = (2 * p * R_prime)**(2 * (gamma1 - 1))\n    \n    # Gamma function terms. scipy.special.gamma handles complex args.\n    g_complex_arg = gamma1 + 1j * y\n    g_complex = special.gamma(g_complex_arg)\n    abs_g_sq = np.real(g_complex)**2 + np.imag(g_complex)**2\n    \n    g_real_arg = 2 * gamma1 + 1\n    g_real = special.gamma(g_real_arg)\n    \n    term3 = abs_g_sq / (g_real**2)\n    term4 = np.exp(np.pi * y)\n    \n    return term1 * term2 * term3 * term4\n\ndef solve():\n    \"\"\"\n    Main solver function to compute and print results for all test cases.\n    \"\"\"\n    # Test suite as specified in the problem statement\n    test_cases = [\n        # (Z_daughter, A_daughter, W0, polarity)\n        (26, 60, 4.0, 'beta-'),\n        (82, 214, 2.5, 'beta-'),\n        (28, 58, 2.2, 'beta+'),\n        (8, 16, 1.1, 'beta-'),\n        (20, 40, 10.0, 'beta-'),\n    ]\n\n    results = []\n    \n    # Numerical integration tolerances\n    epsabs = 1e-12\n    epsrel = 1e-9\n\n    for case in test_cases:\n        Z_daughter, A, W0, polarity = case\n        Z_eff = Z_daughter if polarity == 'beta-' else -Z_daughter\n\n        # Integrand using the Gamow factor\n        def integrand_gamow(W, Z_eff, W0):\n            p_sq = W**2 - 1\n            if p_sq = 0: return 0.0\n            p = np.sqrt(p_sq)\n            F = F_gamow(W, Z_eff)\n            return p * W * (W0 - W)**2 * F\n        \n        # Integrand using the Dirac factor\n        def integrand_dirac(W, Z_daughter, Z_eff, A, W0):\n            p_sq = W**2 - 1\n            if p_sq = 0: return 0.0\n            p = np.sqrt(p_sq)\n            F = F_dirac(W, Z_daughter, Z_eff, A)\n            return p * W * (W0 - W)**2 * F\n\n        # Perform numerical integration for both models\n        f_gamow, _ = integrate.quad(integrand_gamow, 1, W0, args=(Z_eff, W0), epsabs=epsabs, epsrel=epsrel)\n        f_dirac, _ = integrate.quad(integrand_dirac, 1, W0, args=(Z_daughter, Z_eff, A, W0), epsabs=epsabs, epsrel=epsrel)\n        \n        # Calculate the difference in log(ft)\n        delta_log_ft = np.log10(f_dirac) - np.log10(f_gamow)\n        \n        results.append([f_dirac, f_gamow, delta_log_ft])\n        \n    # Format the output as per the problem specification\n    results_as_strings = [\n        f\"[{res[0]:.8f},{res[1]:.8f},{res[2]:.8f}]\" for res in results\n    ]\n    \n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        }
    ]
}