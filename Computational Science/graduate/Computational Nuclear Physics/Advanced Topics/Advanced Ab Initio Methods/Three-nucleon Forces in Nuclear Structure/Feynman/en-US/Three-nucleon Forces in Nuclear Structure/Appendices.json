{
    "hands_on_practices": [
        {
            "introduction": "Before employing any new interaction in large-scale nuclear structure calculations, it is imperative to verify that its implementation is correct. This foundational practice involves creating a suite of unit tests to confirm that the coded operator respects fundamental physical principles. This exercise will guide you through the process of verifying that a model three-nucleon force correctly satisfies permutation symmetry, Hermiticity, and Galilean invariance, which are non-negotiable properties of a valid nuclear Hamiltonian .",
            "id": "3609312",
            "problem": "You are given a class of three-nucleon interactions in coordinate space that are local, real, and depend only on relative coordinates. Consider three nucleons with position vectors $\\mathbf{r}_1$, $\\mathbf{r}_2$, and $\\mathbf{r}_3$ in three-dimensional Euclidean space, and define the pairwise relative vectors $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$. The three-nucleon potential operator is specified by\n$$\nV_3(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3; C, R, \\alpha)\n=\nC \\exp\\left( - \\frac{|\\mathbf{r}_{12}|^2 + |\\mathbf{r}_{23}|^2 + |\\mathbf{r}_{31}|^2}{2 R^2} \\right)\n\\left[ 1 + \\alpha \\frac{\\mathbf{r}_{12}\\cdot\\mathbf{r}_{23} + \\mathbf{r}_{23}\\cdot\\mathbf{r}_{31} + \\mathbf{r}_{31}\\cdot\\mathbf{r}_{12}}{R^2} \\right],\n$$\nwhere $C$ is a strength parameter (dimension energy), $R$ is a length-scale regulator parameter, and $\\alpha$ is a dimensionless parameter. This form is translationally invariant and symmetric under cyclic permutations by construction, and it is representative of local three-body forces employed in chiral effective field theory with local regulators.\n\nYour task is to write a complete, runnable program that constructs unit tests for three fundamental properties of the operator $V_3$: permutation symmetry, Hermiticity, and Galilean invariance. Use the following fundamental bases and definitions:\n\n- Permutation symmetry: If $\\hat{\\mathcal{P}}$ is any permutation of particle labels $\\{1,2,3\\}$, then the operator satisfies\n$$\nV_3(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3) = V_3(\\mathbf{r}_{\\mathcal{P}(1)},\\mathbf{r}_{\\mathcal{P}(2)},\\mathbf{r}_{\\mathcal{P}(3)}).\n$$\n\n- Hermiticity: For any square-integrable wavefunctions $\\psi$ and $\\phi$ in the position representation, the operator is Hermitian if\n$$\n\\langle \\psi | \\hat{V}_3 | \\phi \\rangle = \\left( \\langle \\phi | \\hat{V}_3 | \\psi \\rangle \\right)^*,\n$$\nwhere\n$$\n\\langle \\psi | \\hat{V}_3 | \\phi \\rangle = \\int_{\\mathbb{R}^9} \\psi^*(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3) \\, V_3(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3) \\, \\phi(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3) \\, d^3\\mathbf{r}_1\\, d^3\\mathbf{r}_2\\, d^3\\mathbf{r}_3.\n$$\n\n- Galilean invariance (translational invariance in operator form): Define the total momentum operator $\\hat{\\mathbf{P}}_{\\text{tot}} = - i \\hbar \\sum_{i=1}^3 \\nabla_{\\mathbf{r}_i}$ in coordinate representation. In units with $\\hbar = 1$, translational invariance requires\n$$\n[\\hat{V}_3, \\hat{\\mathbf{P}}_{\\text{tot}}] = \\hat{0},\n$$\nwhich is equivalent to the statement that\n$$\n\\sum_{i=1}^3 \\nabla_{\\mathbf{r}_i} V_3(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3) = \\mathbf{0}.\n$$\n\nThe program must numerically verify these properties with well-defined tests:\n\n1. Permutation symmetry test: For each specified parameter set $(C, R, \\alpha)$, evaluate $V_3$ at three distinct coordinate triples and compare with two nontrivial label permutations: the cyclic permutation $(1,2,3)\\to(2,3,1)$ and the transposition $(1 \\leftrightarrow 3)$. Report whether the maximum absolute difference across these checks is below a tolerance $\\varepsilon_{\\text{perm}} = 10^{-12}$.\n\n2. Hermiticity test: For each specified parameter set $(C, R, \\alpha)$, define two complex-valued wavefunctions\n$$\n\\psi(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3) = \\exp\\left( - a \\left( |\\mathbf{r}_1|^2 + |\\mathbf{r}_2|^2 + |\\mathbf{r}_3|^2 \\right) \\right) \\exp\\left( i \\, \\mathbf{k} \\cdot \\left( \\mathbf{r}_1 + 2\\mathbf{r}_2 - \\mathbf{r}_3 \\right) \\right),\n$$\n$$\n\\phi(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3) = \\exp\\left( - b \\left( |\\mathbf{r}_1 - \\mathbf{d}|^2 + |\\mathbf{r}_2 + \\mathbf{d}|^2 + |\\mathbf{r}_3|^2 \\right) \\right) \\exp\\left( i \\, \\mathbf{q} \\cdot \\left( 2\\mathbf{r}_1 - \\mathbf{r}_2 + \\mathbf{r}_3 \\right) \\right),\n$$\nwith $a = 0.25\\, \\text{fm}^{-2}$, $b = 0.3\\, \\text{fm}^{-2}$, $\\mathbf{k} = (0.7, -0.6, 0.5)\\, \\text{fm}^{-1}$, $\\mathbf{q} = (-0.4, 0.3, -0.2)\\, \\text{fm}^{-1}$, and $\\mathbf{d} = (0.2, -0.1, 0.0)\\, \\text{fm}$. Approximate the two matrix elements $\\langle \\psi | \\hat{V}_3 | \\phi \\rangle$ and $\\langle \\phi | \\hat{V}_3 | \\psi \\rangle$ via Monte Carlo sampling over $\\mathbb{R}^9$ using $N=20000$ independent samples from a three-particle factorized Gaussian with standard deviation $\\sigma = 2.0 \\, \\text{fm}$ for each coordinate component. Compute the relative discrepancy\n$$\n\\delta_{\\text{herm}} = \\frac{\\left| \\langle \\psi | \\hat{V}_3 | \\phi \\rangle - \\left( \\langle \\phi | \\hat{V}_3 | \\psi \\rangle \\right)^* \\right|}{\\max\\left( \\left| \\langle \\psi | \\hat{V}_3 | \\phi \\rangle \\right|, \\left| \\langle \\phi | \\hat{V}_3 | \\psi \\rangle \\right|, 10^{-12} \\right)},\n$$\nand report whether $\\delta_{\\text{herm}} < \\varepsilon_{\\text{herm}} = 10^{-12}$. Note: the numerical approximation must use the same set of random samples for both matrix elements and must not perform any importance weighting; the comparison is with respect to the Gaussian measure defined by the sampling distribution.\n\n3. Galilean invariance test: For each specified parameter set $(C, R, \\alpha)$ and for the same three coordinate triples as in the permutation test, compute the sum of gradients\n$$\n\\mathbf{G}(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3) = \\sum_{i=1}^3 \\nabla_{\\mathbf{r}_i} V_3(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3),\n$$\nand report whether the maximum Euclidean norm $\\max \\|\\mathbf{G}\\|$ across the three coordinate triples is below $\\varepsilon_{\\text{gal}} = 10^{-12}$.\n\nUse the following coordinate triples (in femtometers) for tests (they act as a fixed test suite spanning a typical case, a degenerate boundary, and a large-separation edge case):\n- Triple A: $\\mathbf{r}_1 = (0.1,-0.3,0.5)$, $\\mathbf{r}_2 = (1.0,0.2,-0.4)$, $\\mathbf{r}_3 = (-0.7,0.5,0.1)$.\n- Triple B: $\\mathbf{r}_1 = (0.0,0.0,0.0)$, $\\mathbf{r}_2 = (0.0,0.0,0.0)$, $\\mathbf{r}_3 = (0.0,0.0,0.0)$.\n- Triple C: $\\mathbf{r}_1 = (5.0,0.0,0.0)$, $\\mathbf{r}_2 = (-5.0,0.0,0.0)$, $\\mathbf{r}_3 = (0.0,0.0,0.0)$.\n\nThe parameter sets to test are:\n- Case 1: $(C, R, \\alpha) = (1.0, 1.8, 0.35)$.\n- Case 2: $(C, R, \\alpha) = (2.5, 0.8, -0.5)$.\n- Case 3: $(C, R, \\alpha) = (0.5, 3.0, 1.2)$.\n- Case 4: $(C, R, \\alpha) = (1.0, 1.0, 0.0)$.\n\nAll lengths must be treated in femtometers (fm), and all momenta in inverse femtometers ($\\text{fm}^{-1}$). The program’s outputs are booleans indicating whether each property holds within the specified tolerances for each case.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with entries ordered as\n$$\n[\\text{case1\\_perm}, \\text{case1\\_herm}, \\text{case1\\_gal}, \\text{case2\\_perm}, \\text{case2\\_herm}, \\text{case2\\_gal}, \\text{case3\\_perm}, \\text{case3\\_herm}, \\text{case3\\_gal}, \\text{case4\\_perm}, \\text{case4\\_herm}, \\text{case4\\_gal}],\n$$\nwhere each item is a boolean. No other text should be printed.",
            "solution": "We begin with foundational principles for operators in quantum mechanics in coordinate representation. Let $\\hat{V}_3$ be a local, real potential operator acting by multiplication with a scalar function $V_3(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3)$, and let $\\psi$ and $\\phi$ be wavefunctions in the Hilbert space $L^2(\\mathbb{R}^9)$.\n\nPermutation symmetry follows from the dependence of $V_3$ solely on the set of pairwise relative vectors $\\{\\mathbf{r}_{12}, \\mathbf{r}_{23}, \\mathbf{r}_{31}\\}$ and on scalar combinations that are symmetric under relabeling. Explicitly, the quantities $|\\mathbf{r}_{12}|^2 + |\\mathbf{r}_{23}|^2 + |\\mathbf{r}_{31}|^2$ and $\\mathbf{r}_{12}\\cdot\\mathbf{r}_{23} + \\mathbf{r}_{23}\\cdot\\mathbf{r}_{31} + \\mathbf{r}_{31}\\cdot\\mathbf{r}_{12}$ are invariant under any permutation of $\\{1,2,3\\}$ because permutations only relabel indices of the same symmetric sums. Therefore, by construction,\n$$\nV_3(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3) = V_3(\\mathbf{r}_{\\mathcal{P}(1)},\\mathbf{r}_{\\mathcal{P}(2)},\\mathbf{r}_{\\mathcal{P}(3)})\n$$\nfor any permutation $\\mathcal{P}$. The numerical test evaluates $V_3$ at given coordinate triples and compares it under nontrivial permutations, verifying that the absolute differences are below a tolerance $\\varepsilon_{\\text{perm}}$.\n\nHermiticity for a local real potential is established from first principles. The matrix element\n$$\n\\langle \\psi | \\hat{V}_3 | \\phi \\rangle = \\int \\psi^*(\\mathbf{r})\\, V_3(\\mathbf{r})\\, \\phi(\\mathbf{r}) \\, d^9\\mathbf{r}\n$$\nand its adjoint\n$$\n\\left( \\langle \\phi | \\hat{V}_3 | \\psi \\rangle \\right)^* = \\left( \\int \\phi^*(\\mathbf{r})\\, V_3(\\mathbf{r})\\, \\psi(\\mathbf{r}) \\, d^9\\mathbf{r} \\right)^* = \\int \\left( \\phi^*(\\mathbf{r})\\, V_3(\\mathbf{r})\\, \\psi(\\mathbf{r}) \\right)^* \\, d^9\\mathbf{r}.\n$$\nSince $V_3(\\mathbf{r})$ is real and multiplication is commutative, we have pointwise\n$$\n\\left( \\phi^*(\\mathbf{r})\\, V_3(\\mathbf{r})\\, \\psi(\\mathbf{r}) \\right)^* = \\phi(\\mathbf{r})\\, V_3(\\mathbf{r})\\, \\psi^*(\\mathbf{r}) = \\psi^*(\\mathbf{r})\\, V_3(\\mathbf{r})\\, \\phi(\\mathbf{r}),\n$$\nbecause both sides equal $V_3(\\mathbf{r}) \\psi^*(\\mathbf{r}) \\phi(\\mathbf{r})$. Thus\n$$\n\\langle \\psi | \\hat{V}_3 | \\phi \\rangle = \\left( \\langle \\phi | \\hat{V}_3 | \\psi \\rangle \\right)^*,\n$$\ndemonstrating Hermiticity. Numerically, we approximate these integrals via Monte Carlo sampling with respect to a Gaussian measure (the sampling distribution); the equality remains valid under any positive weight measure, and the same samples are used for both estimates to minimize stochastic discrepancy. We then compute the relative discrepancy $\\delta_{\\text{herm}}$ and assert it is below $\\varepsilon_{\\text{herm}}$.\n\nGalilean invariance is considered in the sense of translational invariance of the operator. With $\\hat{\\mathbf{P}}_{\\text{tot}} = - i \\hbar \\sum_{i=1}^3 \\nabla_{\\mathbf{r}_i}$ and $\\hbar = 1$, the commutator acting on a test function $\\Psi$ is\n$$\n[\\hat{V}_3, \\hat{\\mathbf{P}}_{\\text{tot}}]\\Psi = \\hat{V}_3 \\left( - i \\sum_{i=1}^3 \\nabla_{\\mathbf{r}_i} \\Psi \\right) - \\left( - i \\sum_{i=1}^3 \\nabla_{\\mathbf{r}_i} \\left( \\hat{V}_3 \\Psi \\right) \\right).\n$$\nExpanding the second term via the product rule gives\n$$\n= - i \\left[ \\hat{V}_3 \\sum_{i} \\nabla_{\\mathbf{r}_i} \\Psi - \\sum_{i} \\left( (\\nabla_{\\mathbf{r}_i} V_3) \\Psi + V_3 \\nabla_{\\mathbf{r}_i} \\Psi \\right) \\right] = i \\left( \\sum_{i=1}^3 \\nabla_{\\mathbf{r}_i} V_3 \\right) \\Psi.\n$$\nTherefore, $[\\hat{V}_3, \\hat{\\mathbf{P}}_{\\text{tot}}] = \\hat{0}$ if and only if $\\sum_{i=1}^3 \\nabla_{\\mathbf{r}_i} V_3 = \\mathbf{0}$. For the given $V_3$, we compute the gradients analytically. Define\n$$\nS = |\\mathbf{r}_{12}|^2 + |\\mathbf{r}_{23}|^2 + |\\mathbf{r}_{31}|^2, \\quad U = \\frac{\\mathbf{r}_{12}\\cdot\\mathbf{r}_{23} + \\mathbf{r}_{23}\\cdot\\mathbf{r}_{31} + \\mathbf{r}_{31}\\cdot\\mathbf{r}_{12}}{R^2},\n$$\nand write $V_3 = C e^{-S/(2R^2)} (1 + \\alpha U) \\equiv C A G$, where $A = e^{-S/(2R^2)}$ and $G = 1 + \\alpha U$. Using $\\nabla_{\\mathbf{r}_1} S = 2(\\mathbf{r}_{12} - \\mathbf{r}_{31})$, $\\nabla_{\\mathbf{r}_2} S = 2(\\mathbf{r}_{23} - \\mathbf{r}_{12})$, $\\nabla_{\\mathbf{r}_3} S = 2(\\mathbf{r}_{31} - \\mathbf{r}_{23})$, and\n$$\n\\nabla_{\\mathbf{r}_1} U = \\frac{-\\mathbf{r}_{12} + \\mathbf{r}_{31}}{R^2}, \\quad\n\\nabla_{\\mathbf{r}_2} U = \\frac{-\\mathbf{r}_{23} + \\mathbf{r}_{12}}{R^2}, \\quad\n\\nabla_{\\mathbf{r}_3} U = \\frac{-\\mathbf{r}_{31} + \\mathbf{r}_{23}}{R^2},\n$$\nwe obtain\n$$\n\\nabla_{\\mathbf{r}_i} V_3 = C A \\left( - \\frac{\\nabla_{\\mathbf{r}_i} S}{2R^2} G + \\alpha \\nabla_{\\mathbf{r}_i} U \\right).\n$$\nSubstituting the expressions yields the compact forms\n$$\n\\nabla_{\\mathbf{r}_1} V_3 = - C A \\frac{(\\mathbf{r}_{12} - \\mathbf{r}_{31})}{R^2} (G - \\alpha), \\quad\n\\nabla_{\\mathbf{r}_2} V_3 = - C A \\frac{(\\mathbf{r}_{23} - \\mathbf{r}_{12})}{R^2} (G - \\alpha), \\quad\n\\nabla_{\\mathbf{r}_3} V_3 = - C A \\frac{(\\mathbf{r}_{31} - \\mathbf{r}_{23})}{R^2} (G - \\alpha).\n$$\nSumming over $i=1,2,3$ gives\n$$\n\\sum_{i=1}^3 \\nabla_{\\mathbf{r}_i} V_3 = - C A \\frac{(G - \\alpha)}{R^2} \\left[ (\\mathbf{r}_{12} - \\mathbf{r}_{31}) + (\\mathbf{r}_{23} - \\mathbf{r}_{12}) + (\\mathbf{r}_{31} - \\mathbf{r}_{23}) \\right] = \\mathbf{0}.\n$$\nThis analytic identity demonstrates translational invariance. Numerically, we evaluate these gradients and compute the Euclidean norm of their sum for the given coordinate triples, asserting it is below a tolerance $\\varepsilon_{\\text{gal}}$.\n\nAlgorithmic design:\n- Implement a function for $V_3(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3; C, R, \\alpha)$ using the given formula, ensuring numerical stability and vectorization.\n- Implement analytic gradients $\\nabla_{\\mathbf{r}_i} V_3$ for $i=1,2,3$ using the derived expressions, then sum them to test Galilean invariance.\n- For permutation symmetry, evaluate $V_3$ at specified triples and at their permuted versions; compare absolute differences to $\\varepsilon_{\\text{perm}}$.\n- For Hermiticity, define $\\psi$ and $\\phi$ with the provided parameters, draw $N$ samples from the product Gaussian distribution for $(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3)$, compute Monte Carlo estimates of $\\langle \\psi | V_3 | \\phi \\rangle$ and $\\langle \\phi | V_3 | \\psi \\rangle$, and check $\\delta_{\\text{herm}} < \\varepsilon_{\\text{herm}}$.\n- Assemble results per case in the prescribed order and print a single line in the format specified.\n\nAll quantities involving lengths must use femtometers and momenta inverse femtometers. The program outputs booleans, which are unitless. The final print statement must contain only the list described, with no additional text.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Seed the random number generator for reproducibility\nnp.random.seed(42)\n\ndef three_body_potential(r1, r2, r3, C, R, alpha):\n    \"\"\"\n    Compute the local three-nucleon potential V3(r1, r2, r3; C, R, alpha).\n    r1, r2, r3 are arrays of shape (..., 3). Broadcasting is supported.\n    \"\"\"\n    r12 = r1 - r2\n    r23 = r2 - r3\n    r31 = r3 - r1\n    s = np.sum(r12 * r12, axis=-1) + np.sum(r23 * r23, axis=-1) + np.sum(r31 * r31, axis=-1)\n    dot_sum = np.sum(r12 * r23, axis=-1) + np.sum(r23 * r31, axis=-1) + np.sum(r31 * r12, axis=-1)\n    A = np.exp(- s / (2.0 * R * R))\n    G = 1.0 + alpha * (dot_sum / (R * R))\n    return C * A * G  # shape (...,)\n\ndef gradients_sum(r1, r2, r3, C, R, alpha):\n    \"\"\"\n    Compute the sum of gradients \\sum_i \\nabla_{r_i} V3 analytically for given coordinates.\n    Returns an array of shape (3,) representing the 3D vector.\n    \"\"\"\n    # Relative vectors\n    r12 = r1 - r2\n    r23 = r2 - r3\n    r31 = r3 - r1\n\n    # Scalar S and U\n    s = np.dot(r12, r12) + np.dot(r23, r23) + np.dot(r31, r31)\n    dot_sum = np.dot(r12, r23) + np.dot(r23, r31) + np.dot(r31, r12)\n    A = np.exp(- s / (2.0 * R * R))\n    G = 1.0 + alpha * (dot_sum / (R * R))\n\n    # Common prefactor\n    prefactor = - C * A * (G - alpha) / (R * R)\n\n    # Gradients\n    grad1 = prefactor * (r12 - r31)\n    grad2 = prefactor * (r23 - r12)\n    grad3 = prefactor * (r31 - r23)\n\n    return grad1 + grad2 + grad3  # shape (3,)\n\ndef psi_wavefunction(r1, r2, r3, a, k_vec):\n    \"\"\"\n    psi(r1,r2,r3) = exp(-a (|r1|^2+|r2|^2+|r3|^2)) * exp(i k · (r1 + 2 r2 - r3))\n    \"\"\"\n    norm_sq = np.sum(r1 * r1, axis=-1) + np.sum(r2 * r2, axis=-1) + np.sum(r3 * r3, axis=-1)\n    phase_arg = np.sum(k_vec * (r1 + 2.0 * r2 - r3), axis=-1)\n    return np.exp(-a * norm_sq) * np.exp(1j * phase_arg)\n\ndef phi_wavefunction(r1, r2, r3, b, q_vec, d_vec):\n    \"\"\"\n    phi(r1,r2,r3) = exp(-b (|r1-d|^2+|r2+d|^2+|r3|^2)) * exp(i q · (2 r1 - r2 + r3))\n    \"\"\"\n    r1_shift = r1 - d_vec\n    r2_shift = r2 + d_vec\n    norm_sq = np.sum(r1_shift * r1_shift, axis=-1) + np.sum(r2_shift * r2_shift, axis=-1) + np.sum(r3 * r3, axis=-1)\n    phase_arg = np.sum(q_vec * (2.0 * r1 - r2 + r3), axis=-1)\n    return np.exp(-b * norm_sq) * np.exp(1j * phase_arg)\n\ndef hermiticity_test(C, R, alpha, N_samples=20000, sigma=2.0):\n    \"\"\"\n    Monte Carlo test of Hermiticity: verify <psi|V|phi> == (<phi|V|psi>)* under the Gaussian sampling measure.\n    Returns True if relative discrepancy is below tolerance.\n    \"\"\"\n    # Parameters for psi and phi\n    a = 0.25  # fm^-2\n    b = 0.3   # fm^-2\n    k_vec = np.array([0.7, -0.6, 0.5])  # fm^-1\n    q_vec = np.array([-0.4, 0.3, -0.2]) # fm^-1\n    d_vec = np.array([0.2, -0.1, 0.0])  # fm\n\n    # Draw samples from factorized Gaussian for each particle coordinate\n    r1 = np.random.normal(loc=0.0, scale=sigma, size=(N_samples, 3))\n    r2 = np.random.normal(loc=0.0, scale=sigma, size=(N_samples, 3))\n    r3 = np.random.normal(loc=0.0, scale=sigma, size=(N_samples, 3))\n\n    # Evaluate wavefunctions and potential\n    psi_vals = psi_wavefunction(r1, r2, r3, a=a, k_vec=k_vec)\n    phi_vals = phi_wavefunction(r1, r2, r3, b=b, q_vec=q_vec, d_vec=d_vec)\n    V_vals = three_body_potential(r1, r2, r3, C=C, R=R, alpha=alpha)\n\n    # Monte Carlo estimates under the sampling measure (no importance weighting)\n    inner_psi_phi = np.mean(np.conjugate(psi_vals) * V_vals * phi_vals)\n    inner_phi_psi = np.mean(np.conjugate(phi_vals) * V_vals * psi_vals)\n\n    # Relative discrepancy\n    denom = max(abs(inner_psi_phi), abs(inner_phi_psi), 1e-12)\n    delta = abs(inner_psi_phi - np.conjugate(inner_phi_psi)) / denom\n\n    return delta < 1e-12\n\ndef permutation_symmetry_test(C, R, alpha, triples, tol=1e-12):\n    \"\"\"\n    Test permutation symmetry by comparing V3 evaluated at given triples and two nontrivial permutations:\n    cyclic (2,3,1) and transposition (3,2,1).\n    Returns True if all differences are below tol.\n    \"\"\"\n    def V_single(r1, r2, r3):\n        return float(three_body_potential(r1[np.newaxis, :], r2[np.newaxis, :], r3[np.newaxis, :], C, R, alpha)[0])\n\n    for (r1, r2, r3) in triples:\n        V_orig = V_single(r1, r2, r3)\n        # Cyclic permutation: (1,2,3) -> (2,3,1)\n        V_cyclic = V_single(r2, r3, r1)\n        # Transposition: (1 <-> 3): (3,2,1)\n        V_swap13 = V_single(r3, r2, r1)\n        if not (abs(V_orig - V_cyclic) < tol and abs(V_orig - V_swap13) < tol):\n            return False\n    return True\n\ndef galilean_invariance_test(C, R, alpha, triples, tol=1e-12):\n    \"\"\"\n    Test translational invariance via commutator [V3, P_tot] == 0, equivalent to sum of gradients == 0.\n    Returns True if max norm across triples is below tol.\n    \"\"\"\n    norms = []\n    for (r1, r2, r3) in triples:\n        G_sum = gradients_sum(r1, r2, r3, C, R, alpha)\n        norms.append(np.linalg.norm(G_sum))\n    return max(norms) < tol\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 1.8, 0.35),   # Case 1\n        (2.5, 0.8, -0.5),   # Case 2\n        (0.5, 3.0, 1.2),    # Case 3\n        (1.0, 1.0, 0.0),    # Case 4\n    ]\n\n    # Coordinate triples (in fm): A, B, C\n    triple_A = (np.array([0.1, -0.3, 0.5]), np.array([1.0, 0.2, -0.4]), np.array([-0.7, 0.5, 0.1]))\n    triple_B = (np.array([0.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.0]))\n    triple_C = (np.array([5.0, 0.0, 0.0]), np.array([-5.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.0]))\n    triples = [triple_A, triple_B, triple_C]\n\n    results = []\n    for (C, R, alpha) in test_cases:\n        perm_ok = permutation_symmetry_test(C, R, alpha, triples, tol=1e-12)\n        herm_ok = hermiticity_test(C, R, alpha, N_samples=20000, sigma=2.0)\n        gal_ok = galilean_invariance_test(C, R, alpha, triples, tol=1e-12)\n        results.extend([perm_ok, herm_ok, gal_ok])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While a complete three-nucleon force (3NF) is defined across a large space of partial waves, practical calculations often require truncating this space to remain computationally tractable. Understanding the consequences of such approximations is a critical skill for any nuclear theorist. Using a realistic surrogate model, this practice allows you to quantify the errors introduced by truncating the 3NF partial-wave basis and to identify the most crucial channels for accurately describing key nuclear observables like saturation properties and isotopic energy trends .",
            "id": "3609397",
            "problem": "A three-nucleon (3N) interaction in nuclear many-body theory can be organized in partial waves labeled by total angular momentum $J$, parity $\\pi$, and isospin $T$, collectively denoted as $J^{\\pi}T$ channels. At the Hartree–Fock (HF) level, the total energy at a fixed density can be approximated as an additive contribution from a two-nucleon (2N) baseline and channel-resolved 3N pieces whose density dependence is smooth. In this problem, you will quantify the errors induced by truncating the 3N partial-wave space by including only a subset of $J^{\\pi}T$ channels. Your goal is to identify minimal channel sets that reproduce, within a specified target accuracy, both infinite nuclear matter saturation properties and simple calcium isotope energy systematics, using a simplified surrogate model that is fully specified below.\n\nYou are given the following surrogate model for the energy per particle in symmetric infinite nuclear matter at zero temperature:\n- Let the density be $\\rho$ in $\\text{fm}^{-3}$, and define $r \\equiv \\rho/\\rho_{0}$ with reference density $\\rho_{0} = 0.16\\,\\text{fm}^{-3}$.\n- The 2N baseline contribution to the energy per particle (in $\\text{MeV}$) is\n$$\nE_{2\\text{N}}(r) = D + C\\,r^{2} + B\\, r^{4/3} - A\\, r + K\\, r^{2/3},\n$$\nwith constants $K=12.0\\,\\text{MeV}$, $A=28.0\\,\\text{MeV}$, $B=10.0\\,\\text{MeV}$, $C=0.5\\,\\text{MeV}$, and $D=-14.5\\,\\text{MeV}$.\n\n- The 3N contribution is a sum over channel functions,\n$$\nE_{3\\text{N}}(r;\\mathcal{S}) = \\sum_{c \\in \\mathcal{S}} w_{c}\\, r^{n_{c}},\n$$\nwhere $\\mathcal{S}$ is the set of included channels, $w_{c}$ are channel weights in $\\text{MeV}$, and $n_{c}$ are the density exponents. The eight available channels are indexed by $c \\in \\{0,1,2,3,4,5,6,7\\}$ and represent dominant $J^{\\pi}T$ sectors:\n- $c=0$: ($0^{+},1$) with $(w_{0},n_{0})=(0.7,1.0)$,\n- $c=1$: ($1^{+},0$) with $(w_{1},n_{1})=(0.6,4/3)$,\n- $c=2$: ($2^{+},1$) with $(w_{2},n_{2})=(0.9,5/3)$,\n- $c=3$: ($3^{+},0$) with $(w_{3},n_{3})=(0.8,2.0)$,\n- $c=4$: ($1^{-},1$) with $(w_{4},n_{4})=(0.4,7/3)$,\n- $c=5$: ($2^{-},0$) with $(w_{5},n_{5})=(0.3,8/3)$,\n- $c=6$: ($3^{-},1$) with $(w_{6},n_{6})=(0.2,3.0)$,\n- $c=7$: ($2^{+},0$) with $(w_{7},n_{7})=(0.1,2.5)$.\n\nThus, the total energy per particle for a chosen subset $\\mathcal{S}$ is\n$$\n\\frac{E}{A}(r;\\mathcal{S}) = E_{2\\text{N}}(r) + E_{3\\text{N}}(r;\\mathcal{S}).\n$$\n\nDefine the nuclear matter saturation point for a given subset $\\mathcal{S}$ as the density $\\rho_{\\text{sat}}(\\mathcal{S})$ that minimizes $\\frac{E}{A}(r;\\mathcal{S})$ over the interval $\\rho \\in [0.14, 0.18]\\,\\text{fm}^{-3}$, i.e., $r \\in [0.14/0.16, 0.18/0.16]$. The corresponding minimum energy per particle is $E_{\\text{min}}(\\mathcal{S}) = \\min_{r \\in [0.14/0.16, 0.18/0.16]} \\frac{E}{A}(r;\\mathcal{S})$. The “ground truth” reference is defined by the full-channel set $\\mathcal{F}=\\{0,1,2,3,4,5,6,7\\}$, producing $\\rho_{\\text{sat}}(\\mathcal{F})$ and $E_{\\text{min}}(\\mathcal{F})$.\n\nCalcium systematics are modeled as linear channel sums added to a 2N baseline for two nuclei, $^{40}\\text{Ca}$ and $^{48}\\text{Ca}$. The total ground-state energy (in $\\text{MeV}$) for a subset $\\mathcal{S}$ is\n$$\nE_{40}(\\mathcal{S}) = E^{(40)}_{2\\text{N}} + \\sum_{c\\in\\mathcal{S}} b^{(40)}_{c}, \\quad\nE_{48}(\\mathcal{S}) = E^{(48)}_{2\\text{N}} + \\sum_{c\\in\\mathcal{S}} b^{(48)}_{c}.\n$$\nThe 2N baselines are $E^{(40)}_{2\\text{N}}=-355.0\\,\\text{MeV}$ and $E^{(48)}_{2\\text{N}}=-434.0\\,\\text{MeV}$. The channel coefficients (in $\\text{MeV}$) are:\n- For $^{40}\\text{Ca}$: $\\big(b^{(40)}_{0},b^{(40)}_{1},b^{(40)}_{2},b^{(40)}_{3},b^{(40)}_{4},b^{(40)}_{5},b^{(40)}_{6},b^{(40)}_{7}\\big) = (2.5,2.0,3.0,2.5,1.0,1.0,0.5,0.5)$.\n- For $^{48}\\text{Ca}$: $\\big(b^{(48)}_{0},b^{(48)}_{1},b^{(48)}_{2},b^{(48)}_{3},b^{(48)}_{4},b^{(48)}_{5},b^{(48)}_{6},b^{(48)}_{7}\\big) = (3.0,2.5,3.5,3.0,2.0,1.5,1.0,1.5)$.\n\nThe “ground truth” calcium energies are defined by the full-channel set $\\mathcal{F}$.\n\nError metrics. For any subset $\\mathcal{S}$, define four absolute errors relative to the full-channel reference:\n- Nuclear matter minimum energy error (in $\\text{MeV}$):\n$$\n\\Delta E_{\\text{min}}(\\mathcal{S}) \\equiv \\left| E_{\\text{min}}(\\mathcal{S}) - E_{\\text{min}}(\\mathcal{F}) \\right|.\n$$\n- Nuclear matter saturation density error (in $\\text{fm}^{-3}$):\n$$\n\\Delta \\rho_{\\text{sat}}(\\mathcal{S}) \\equiv \\left| \\rho_{\\text{sat}}(\\mathcal{S}) - \\rho_{\\text{sat}}(\\mathcal{F}) \\right|.\n$$\n- Calcium energy errors (in $\\text{MeV}$):\n$$\n\\Delta E_{40}(\\mathcal{S}) \\equiv \\left| E_{40}(\\mathcal{S}) - E_{40}(\\mathcal{F}) \\right|, \\quad\n\\Delta E_{48}(\\mathcal{S}) \\equiv \\left| E_{48}(\\mathcal{S}) - E_{48}(\\mathcal{F}) \\right|.\n$$\n\nFeasibility and optimality criteria. A subset $\\mathcal{S}$ is feasible for a given tolerance quadruple $(\\varepsilon_{E}, \\varepsilon_{\\rho}, \\varepsilon_{40}, \\varepsilon_{48})$ if and only if\n$$\n\\Delta E_{\\text{min}}(\\mathcal{S}) \\le \\varepsilon_{E}, \\quad\n\\Delta \\rho_{\\text{sat}}(\\mathcal{S}) \\le \\varepsilon_{\\rho}, \\quad\n\\Delta E_{40}(\\mathcal{S}) \\le \\varepsilon_{40}, \\quad\n\\Delta E_{48}(\\mathcal{S}) \\le \\varepsilon_{48}.\n$$\nAmong all feasible subsets, select one with the smallest cardinality $|\\mathcal{S}|$. If multiple subsets have the same minimal cardinality, select the lexicographically smallest ordered list of indices. If no subset is feasible, return the singleton list `[-1]`.\n\nYour program must:\n- Use the model and constants exactly as specified above.\n- Determine the full-channel reference by numerical minimization of $\\frac{E}{A}(r;\\mathcal{F})$ over $\\rho \\in [0.14,0.18]\\,\\text{fm}^{-3}$.\n- For each candidate subset $\\mathcal{S} \\subseteq \\{0,1,2,3,4,5,6,7\\}$, compute all four errors and test feasibility.\n- For each tolerance quadruple in the test suite, return the minimal feasible channel set according to the rule above.\n\nNumerical details:\n- Perform the saturation search by sampling $\\rho$ uniformly on a grid over $[0.14,0.18]\\,\\text{fm}^{-3}$ with a step no larger than $0.0001\\,\\text{fm}^{-3}$. Report $\\rho_{\\text{sat}}$ as the grid point that minimizes $\\frac{E}{A}$.\n- All energies must be treated in $\\text{MeV}$ and densities in $\\text{fm}^{-3}$. The final returned channel indices are dimensionless integers.\n\nTest suite. Run your program for the following tolerance quadruples $(\\varepsilon_{E}, \\varepsilon_{\\rho}, \\varepsilon_{40}, \\varepsilon_{48})$:\n- Case $1$ (moderate): $(0.5, 0.004, 1.0, 1.5)$.\n- Case $2$ (tight): $(0.1, 0.001, 0.5, 0.5)$.\n- Case $3$ (loose): $(5.0, 0.02, 20.0, 25.0)$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list of lists, in which each inner list is the lexicographically ordered minimal feasible channel index set for the corresponding test case, for example, `[[0,1,2],[0,1,2,3],[]]`. If a case is infeasible, its position should contain `[-1]`. The output must be exactly one line with no extra text.",
            "solution": "The problem requires us to identify the smallest subsets of three-nucleon (3N) interaction channels that can reproduce key nuclear properties within specified error tolerances. These properties are the saturation energy and density of infinite symmetric nuclear matter, and the ground-state energies of the $^{40}\\text{Ca}$ and $^{48}\\text{Ca}$ isotopes. The problem provides a surrogate model for these quantities. Our task is to perform a systematic search for optimal channel subsets based on given feasibility and optimality criteria.\n\nFirst, we formalize the model. The energy per particle, $\\frac{E}{A}$, in symmetric nuclear matter is a function of the reduced density $r = \\rho/\\rho_{0}$, where $\\rho_{0} = 0.16\\,\\text{fm}^{-3}$. It is composed of a two-nucleon (2N) baseline and a 3N contribution:\n$$\n\\frac{E}{A}(r;\\mathcal{S}) = E_{2\\text{N}}(r) + E_{3\\text{N}}(r;\\mathcal{S})\n$$\nwhere $\\mathcal{S}$ is the chosen subset of 3N channels.\n\nThe 2N contribution is given by:\n$$\nE_{2\\text{N}}(r) = D + C\\,r^{2} + B\\, r^{4/3} - A\\, r + K\\, r^{2/3}\n$$\nThe constants are specified as $K=12.0\\,\\text{MeV}$, $A=28.0\\,\\text{MeV}$, $B=10.0\\,\\text{MeV}$, $C=0.5\\,\\text{MeV}$, and $D=-14.5\\,\\text{MeV}$.\n\nThe 3N contribution is a sum over the channels $c$ included in the subset $\\mathcal{S} \\subseteq \\{0,1,2,3,4,5,6,7\\}$:\n$$\nE_{3\\text{N}}(r;\\mathcal{S}) = \\sum_{c \\in \\mathcal{S}} w_{c}\\, r^{n_{c}}\n$$\nThe parameters for the eight channels are:\n- $c=0$: $(w_{0},n_{0})=(0.7,1.0)$\n- $c=1$: $(w_{1},n_{1})=(0.6,4/3)$\n- $c=2$: $(w_{2},n_{2})=(0.9,5/3)$\n- $c=3$: $(w_{3},n_{3})=(0.8,2.0)$\n- $c=4$: $(w_{4},n_{4})=(0.4,7/3)$\n- $c=5$: $(w_{5},n_{5})=(0.3,8/3)$\n- $c=6$: $(w_{6},n_{6})=(0.2,3.0)$\n- $c=7$: $(w_{7},n_{7})=(0.1,2.5)$\n\nThe ground-state energies for $^{40}\\text{Ca}$ and $^{48}\\text{Ca}$ are also sums over the channels in $\\mathcal{S}$:\n$$\nE_{40}(\\mathcal{S}) = E^{(40)}_{2\\text{N}} + \\sum_{c\\in\\mathcal{S}} b^{(40)}_{c}\n$$\n$$\nE_{48}(\\mathcal{S}) = E^{(48)}_{2\\text{N}} + \\sum_{c\\in\\mathcal{S}} b^{(48)}_{c}\n$$\nThe 2N baselines are $E^{(40)}_{2\\text{N}}=-355.0\\,\\text{MeV}$ and $E^{(48)}_{2\\text{N}}=-434.0\\,\\text{MeV}$. The channel coefficients are:\n- For $^{40}\\text{Ca}$: $\\vec{b}^{(40)} = (2.5,2.0,3.0,2.5,1.0,1.0,0.5,0.5)\\,\\text{MeV}$.\n- For $^{48}\\text{Ca}$: $\\vec{b}^{(48)} = (3.0,2.5,3.5,3.0,2.0,1.5,1.0,1.5)\\,\\text{MeV}$.\n\nThe core of the problem is to compare calculations using a truncated subset $\\mathcal{S}$ to a \"ground truth\" reference calculation using the full set of channels, $\\mathcal{F} = \\{0,1,2,3,4,5,6,7\\}$. The four error metrics are defined as absolute differences from the reference:\n$$\n\\Delta E_{\\text{min}}(\\mathcal{S}) \\equiv \\left| E_{\\text{min}}(\\mathcal{S}) - E_{\\text{min}}(\\mathcal{F}) \\right|\n$$\n$$\n\\Delta \\rho_{\\text{sat}}(\\mathcal{S}) \\equiv \\left| \\rho_{\\text{sat}}(\\mathcal{S}) - \\rho_{\\text{sat}}(\\mathcal{F}) \\right|\n$$\n$$\n\\Delta E_{40}(\\mathcal{S}) \\equiv \\left| E_{40}(\\mathcal{S}) - E_{40}(\\mathcal{F}) \\right|\n$$\n$$\n\\Delta E_{48}(\\mathcal{S}) \\equiv \\left| E_{48}(\\mathcal{S}) - E_{48}(\\mathcal{F}) \\right|\n$$\nThe nuclear matter properties, $E_{\\text{min}}(\\mathcal{S})$ and $\\rho_{\\text{sat}}(\\mathcal{S})$, are the minimum energy per particle and the density at which it occurs, found by minimizing $\\frac{E}{A}(r;\\mathcal{S})$ over the density range $\\rho \\in [0.14, 0.18]\\,\\text{fm}^{-3}$.\n\nThe calcium energy errors can be simplified. Let $\\mathcal{S}^c = \\mathcal{F} \\setminus \\mathcal{S}$ be the set of omitted channels. Then:\n$$\n\\Delta E_{40}(\\mathcal{S}) = \\left| \\left(E^{(40)}_{2\\text{N}} + \\sum_{c\\in\\mathcal{S}} b^{(40)}_{c}\\right) - \\left(E^{(40)}_{2\\text{N}} + \\sum_{c\\in\\mathcal{F}} b^{(40)}_{c}\\right) \\right| = \\left| -\\sum_{c\\in\\mathcal{S}^c} b^{(40)}_{c} \\right| = \\sum_{c\\in\\mathcal{S}^c} b^{(40)}_{c}\n$$\nsince all $b^{(40)}_{c} \\ge 0$. Similarly, $\\Delta E_{48}(\\mathcal{S}) = \\sum_{c\\in\\mathcal{S}^c} b^{(48)}_{c}$.\n\nThe algorithmic approach to find the optimal subset for each test case is a systematic, ordered search.\n1.  **Reference Calculation**: We first compute the reference values. The function $\\frac{E}{A}(r;\\mathcal{F})$ is evaluated on a uniform grid of densities $\\rho$ from $0.14\\,\\text{fm}^{-3}$ to $0.18\\,\\text{fm}^{-3}$ with a step size of $0.0001\\,\\text{fm}^{-3}$, as specified. The minimum value on this grid yields $E_{\\text{min}}(\\mathcal{F})$, and the corresponding density is $\\rho_{\\text{sat}}(\\mathcal{F})$. The reference calcium errors are zero by definition, but we pre-calculate the total sums $\\sum_{c \\in \\mathcal{F}} b_c$ to speed up subsequent error calculations.\n\n2.  **Systematic Subset Search**: The search for an optimal subset must traverse the power set of $\\mathcal{F}$, which contains $2^8 = 256$ subsets. To satisfy the optimality criteria (minimal cardinality, then lexicographically smallest), we iterate through all subsets $\\mathcal{S}$ ordered first by their size $|\\mathcal{S}|$ from $k=0$ to $k=8$, and for each size, in lexicographical order of their elements. For each of the three test cases, defined by a tolerance quadruple $(\\varepsilon_{E}, \\varepsilon_{\\rho}, \\varepsilon_{40}, \\varepsilon_{48})$, we seek the first subset in this sequence that is feasible.\n\n3.  **Feasibility Check**: For each subset $\\mathcal{S}$ in the ordered sequence, we perform the following:\n    a. We construct the function $\\frac{E}{A}(r;\\mathcal{S})$ and find its saturation point ($E_{\\text{min}}(\\mathcal{S}), \\rho_{\\text{sat}}(\\mathcal{S})$) using the same numerical grid search.\n    b. We compute the four errors $\\Delta E_{\\text{min}}(\\mathcal{S})$, $\\Delta \\rho_{\\text{sat}}(\\mathcal{S})$, $\\Delta E_{40}(\\mathcal{S})$, and $\\Delta E_{48}(\\mathcal{S})$.\n    c. For each test case not yet solved, we check if the subset is feasible by comparing the errors to the tolerances: $\\Delta E_{\\text{min}} \\le \\varepsilon_{E}$, $\\Delta \\rho_{\\text{sat}} \\le \\varepsilon_{\\rho}$, $\\Delta E_{40} \\le \\varepsilon_{40}$, and $\\Delta E_{48} \\le \\varepsilon_{48}$.\n    d. If a subset is found to be feasible for a given test case, it is immediately selected as the optimal solution for that case, and no further subsets need to be checked for it. This is guaranteed by the specific ordering of the search.\n\n4.  **Final Result Assembly**: If the search completes and no feasible subset has been found for a particular test case, the result for that case is the singleton list $[-1]$. The final output is an aggregation of the optimal subsets for all test cases.\n\nThis deterministic algorithm ensures that the returned subset for each case is indeed the one with the smallest number of elements, and among those, the lexicographically first.",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the nuclear channel truncation problem by systematically searching for\n    minimal feasible channel subsets.\n    \"\"\"\n    #\n    # --- Model Parameters ---\n    #\n    RHO0 = 0.16  # Reference density in fm^-3\n\n    # 2N constants (MeV)\n    K, A, B, C, D = 12.0, 28.0, 10.0, 0.5, -14.5\n\n    # 3N channel parameters (w_c in MeV, n_c is dimensionless)\n    CHANNELS = {\n        0: {'w': 0.7, 'n': 1.0},\n        1: {'w': 0.6, 'n': 4.0/3.0},\n        2: {'w': 0.9, 'n': 5.0/3.0},\n        3: {'w': 0.8, 'n': 2.0},\n        4: {'w': 0.4, 'n': 7.0/3.0},\n        5: {'w': 0.3, 'n': 8.0/3.0},\n        6: {'w': 0.2, 'n': 3.0},\n        7: {'w': 0.1, 'n': 2.5},\n    }\n    \n    # Calcium coefficients (MeV)\n    B40_C = np.array([2.5, 2.0, 3.0, 2.5, 1.0, 1.0, 0.5, 0.5])\n    B48_C = np.array([3.0, 2.5, 3.5, 3.0, 2.0, 1.5, 1.0, 1.5])\n    \n    # Test cases (tolerances)\n    test_cases = [\n        (0.5, 0.004, 1.0, 1.5),  # Case 1 (moderate)\n        (0.1, 0.001, 0.5, 0.5),  # Case 2 (tight)\n        (5.0, 0.02, 20.0, 25.0), # Case 3 (loose)\n    ]\n    \n    #\n    # --- Numerical Setup ---\n    #\n    RHO_MIN, RHO_MAX, RHO_STEP = 0.14, 0.18, 0.0001\n    rho_grid = np.arange(RHO_MIN, RHO_MAX + RHO_STEP, RHO_STEP)\n    r_grid = rho_grid / RHO0\n\n    #\n    # --- Helper Functions ---\n    #\n    def get_e_per_a(r_vals, subset):\n        \"\"\"Calculates E/A for a given subset of channels.\"\"\"\n        e_2n = D + C * r_vals**2 + B * r_vals**(4/3) - A * r_vals + K * r_vals**(2/3)\n        e_3n = np.zeros_like(r_vals)\n        for c in subset:\n            e_3n += CHANNELS[c]['w'] * r_vals**CHANNELS[c]['n']\n        return e_2n + e_3n\n\n    def get_saturation_point(e_per_a_vals, rho_vals):\n        \"\"\"Finds saturation energy and density from an E/A curve.\"\"\"\n        min_idx = np.argmin(e_per_a_vals)\n        e_min = e_per_a_vals[min_idx]\n        rho_sat = rho_vals[min_idx]\n        return e_min, rho_sat\n\n    #\n    # --- Main Calculation ---\n    #\n    # 1. Calculate reference values using the full channel set\n    full_set = list(range(8))\n    e_per_a_ref = get_e_per_a(r_grid, full_set)\n    e_min_ref, rho_sat_ref = get_saturation_point(e_per_a_ref, rho_grid)\n    \n    total_b40 = np.sum(B40_C)\n    total_b48 = np.sum(B48_C)\n\n    # 2. Iterate through subsets, ordered by cardinality then lexicographically\n    all_channels = list(range(8))\n    results = [None] * len(test_cases)\n    \n    for k in range(len(all_channels) + 1):\n        # If all cases have found a solution, we can stop\n        if all(res is not None for res in results):\n            break\n            \n        for subset_tuple in combinations(all_channels, k):\n            subset = list(subset_tuple)\n            \n            # --- For the current subset, calculate all properties and errors ---\n            \n            # Nuclear matter properties\n            e_per_a_subset = get_e_per_a(r_grid, subset)\n            e_min_subset, rho_sat_subset = get_saturation_point(e_per_a_subset, rho_grid)\n            \n            # Nuclear matter errors\n            delta_e_min = abs(e_min_subset - e_min_ref)\n            delta_rho_sat = abs(rho_sat_subset - rho_sat_ref)\n            \n            # Calcium errors (sum of omitted coefficients)\n            sum_b40_subset = np.sum(B40_C[subset])\n            sum_b48_subset = np.sum(B48_C[subset])\n            \n            delta_e40 = total_b40 - sum_b40_subset\n            delta_e48 = total_b48 - sum_b48_subset\n            \n            # --- Check feasibility for each test case ---\n            \n            for i, case in enumerate(test_cases):\n                # If we've already found a solution for this case, skip\n                if results[i] is not None:\n                    continue\n                \n                eps_E, eps_rho, eps_40, eps_48 = case\n                \n                is_feasible = (\n                    delta_e_min <= eps_E and\n                    delta_rho_sat <= eps_rho and\n                    delta_e40 <= eps_40 and\n                    delta_e48 <= eps_48\n                )\n                \n                if is_feasible:\n                    # Found the optimal solution for this case\n                    results[i] = subset if subset else [] # Handle empty set case\n\n    # 3. Finalize results: if any case is still unsolved, mark as infeasible\n    for i in range(len(results)):\n        if results[i] is None:\n            results[i] = [-1]\n\n    # Format the output exactly as specified\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str.replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "A central goal of chiral Effective Field Theory is to connect low-energy observables to the fundamental parameters of the theory, known as low-energy constants (LECs). Understanding how observables depend on these LECs is the first step toward calibrating the interaction against experimental data. This advanced exercise introduces the concept of sensitivity analysis by having you implement a simplified In-Medium Similarity Renormalization Group (IMSRG) framework to compute the derivatives of the ground-state energy with respect to the 3NF constants $c_D$ and $c_E$, providing a gateway to modern, gradient-based methods for Hamiltonian optimization .",
            "id": "3609341",
            "problem": "You are tasked with designing a minimal, yet scientifically consistent, numerical framework that captures the essence of how three-nucleon forces inform energy predictions in medium-mass nuclei through the In-Medium Similarity Renormalization Group (IMSRG). Your goal is to compute the energy sensitivities with respect to two chiral Effective Field Theory (EFT) low-energy constants, denoted by $c_D$ and $c_E$, in units of megaelectronvolts (MeV). The framework must be purely algorithmic and must be implementable as a complete, runnable program.\n\nThe fundamental starting point is as follows:\n- Begin from a normal-ordered Hamiltonian for a closed-shell reference, truncating at the two-body level, where the three-nucleon force contributions are approximated by density-dependent effective one-body and two-body terms. The parameters $c_D$ and $c_E$ enter only through these normal-ordered terms and are treated as dimensionless low-energy constants.\n- Employ the Similarity Renormalization Group (SRG) idea in the form of the In-Medium Similarity Renormalization Group (IMSRG), where an anti-Hermitian generator drives the Hamiltonian towards a block-diagonal form that decouples the reference state from excitations. Use the Wegner generator defined by $\\eta(s) = [H_d(s), H_{od}(s)]$, where $H_d(s)$ is the diagonal part of $H(s)$ and $H_{od}(s)$ is the off-diagonal part, and $s$ is the continuous flow parameter satisfying $s \\ge 0$. The flow equation is $dH(s)/ds = [\\eta(s), H(s)]$.\n- To ensure universal applicability and computational simplicity, restrict to a two-level model (one hole orbital and one particle orbital) with Hamiltonian\n$$\nH(s) = \\begin{pmatrix}\ne_h(s) & v(s) \\\\\nv(s) & e_p(s)\n\\end{pmatrix},\n$$\nwhere $e_h(s)$ and $e_p(s)$ are level energies and $v(s)$ is the off-diagonal coupling. All quantities are real and $H(s)$ is symmetric. The initial condition at $s=0$ encodes the normal-ordered dependence on $c_D$ and $c_E$ via\n$$\ne_h(0) = \\varepsilon_h + \\alpha_{hD} \\, \\rho \\, c_D + \\alpha_{hE} \\, \\rho^2 \\, c_E,\n$$\n$$\ne_p(0) = \\varepsilon_p + \\alpha_{pD} \\, \\rho \\, c_D + \\alpha_{pE} \\, \\rho^2 \\, c_E,\n$$\n$$\nv(0) = v_0 + \\beta_D \\, \\rho \\, c_D + \\beta_E \\, \\rho \\, c_E,\n$$\nwith known constants $\\varepsilon_h$, $\\varepsilon_p$, $v_0$, $\\alpha_{hD}$, $\\alpha_{hE}$, $\\alpha_{pD}$, $\\alpha_{pE}$, $\\beta_D$, $\\beta_E$, and the nuclear matter density $\\rho$ in $\\text{fm}^{-3}$. Treat $c_D$ and $c_E$ as variables.\n\nStarting from these definitions and the SRG flow, you must:\n1. Derive the flow for $H(s)$ using the Wegner generator in the two-level model. Use the commutator definition and the decomposition $H(s) = H_d(s) + H_{od}(s)$.\n2. Formulate and implement a forward-mode sensitivity propagation for $\\partial e_h(s)/\\partial c_D$, $\\partial e_p(s)/\\partial c_D$, $\\partial v(s)/\\partial c_D$ and analogous derivatives with respect to $c_E$, by differentiating the $H(s)$ flow with respect to the parameters and applying the chain rule to construct a tangent linear system. There is no explicit $c_D$ or $c_E$-dependence in the right-hand side of the flow equations beyond the initial conditions, so the parameter sensitivities evolve solely through the Jacobian of the flow with respect to the state.\n3. At a specified final flow parameter $s_{\\text{max}}$, compute the lowest eigenvalue $\\lambda_{\\min}(H(s_{\\text{max}}))$ and its associated normalized eigenvector. Use first-order perturbation theory to compute the sensitives of the lowest eigenvalue with respect to $c_D$ and $c_E$ as\n$$\n\\frac{\\partial \\lambda_{\\min}}{\\partial p} = \\mathbf{v}_{\\min}^\\top \\left( \\frac{\\partial H}{\\partial p} \\right) \\mathbf{v}_{\\min}, \\quad p \\in \\{c_D, c_E\\},\n$$\nwhere $\\mathbf{v}_{\\min}$ is the normalized eigenvector corresponding to $\\lambda_{\\min}$ and $\\frac{\\partial H}{\\partial p}$ at $s_{\\text{max}}$ is formed from the propagated sensitivities. Report these derivatives in $\\text{MeV}$.\n\nImplement this procedure and apply it to the following test suite. For each test case, use the provided values to define the initial conditions at $s=0$, integrate the IMSRG flow to the given $s_{\\text{max}}$, perform the sensitivity propagation, and output the two energy derivatives $\\left[\\frac{\\partial E}{\\partial c_D}, \\frac{\\partial E}{\\partial c_E}\\right]$, where $E = \\lambda_{\\min}(H(s_{\\text{max}}))$ and both derivatives are expressed in $\\text{MeV}$ as floating-point numbers.\n\nTest suite (each case lists $\\varepsilon_h$, $\\varepsilon_p$, $v_0$, $\\rho$, $\\alpha_{hD}$, $\\alpha_{hE}$, $\\alpha_{pD}$, $\\alpha_{pE}$, $\\beta_D$, $\\beta_E$, $c_D$, $c_E$, $s_{\\text{max}}$):\n- Case $1$ (medium-mass, typical couplings): $\\varepsilon_h = -12.0 \\, \\text{MeV}$, $\\varepsilon_p = 3.0 \\, \\text{MeV}$, $v_0 = 1.5 \\, \\text{MeV}$, $\\rho = 0.16 \\, \\text{fm}^{-3}$, $\\alpha_{hD} = 2.0$, $\\alpha_{hE} = 1.5$, $\\alpha_{pD} = 1.0$, $\\alpha_{pE} = 0.5$, $\\beta_D = 0.8$, $\\beta_E = 0.2$, $c_D = -0.2$, $c_E = -0.5$, $s_{\\text{max}} = 20.0$.\n- Case $2$ (boundary case with no coupling): $\\varepsilon_h = -10.0 \\, \\text{MeV}$, $\\varepsilon_p = 2.0 \\, \\text{MeV}$, $v_0 = 0.0 \\, \\text{MeV}$, $\\rho = 0.16 \\, \\text{fm}^{-3}$, $\\alpha_{hD} = 2.0$, $\\alpha_{hE} = 1.5$, $\\alpha_{pD} = 1.0$, $\\alpha_{pE} = 0.5$, $\\beta_D = 0.8$, $\\beta_E = 0.2$, $c_D = 0.0$, $c_E = 0.0$, $s_{\\text{max}} = 20.0$.\n- Case $3$ (near-degenerate levels): $\\varepsilon_h = -1.0 \\, \\text{MeV}$, $\\varepsilon_p = -0.8 \\, \\text{MeV}$, $v_0 = 0.05 \\, \\text{MeV}$, $\\rho = 0.14 \\, \\text{fm}^{-3}$, $\\alpha_{hD} = 2.0$, $\\alpha_{hE} = 1.5$, $\\alpha_{pD} = 1.0$, $\\alpha_{pE} = 0.5$, $\\beta_D = 0.8$, $\\beta_E = 0.2$, $c_D = 0.1$, $c_E = -0.1$, $s_{\\text{max}} = 50.0$.\n- Case $4$ (heavier medium-mass nucleus, stronger couplings): $\\varepsilon_h = -15.0 \\, \\text{MeV}$, $\\varepsilon_p = 4.0 \\, \\text{MeV}$, $v_0 = 2.5 \\, \\text{MeV}$, $\\rho = 0.17 \\, \\text{fm}^{-3}$, $\\alpha_{hD} = 2.5$, $\\alpha_{hE} = 1.7$, $\\alpha_{pD} = 1.3$, $\\alpha_{pE} = 0.8$, $\\beta_D = 1.0$, $\\beta_E = 0.4$, $c_D = 0.2$, $c_E = 0.3$, $s_{\\text{max}} = 25.0$.\n\nAll energy quantities and outputs must be expressed in $\\text{MeV}$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a two-element list of floating-point numbers in $\\text{MeV}$, ordered according to the test suite cases (for example, `[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]`).",
            "solution": "The solution proceeds in four stages:\n1.  Derivation of the flow equations for the two-level Hamiltonian based on the Wegner generator.\n2.  Formulation of the tangent linear system to propagate the sensitivities of the Hamiltonian components with respect to the parameters $c_D$ and $c_E$.\n3.  Specification of the numerical procedure for solving the coupled system of ordinary differential equations (ODEs).\n4.  Derivation of the final sensitivity expressions for the lowest eigenvalue using first-order perturbation theory.\n\n**1. Derivation of the IMSRG Flow Equations**\n\nThe Hamiltonian for the two-level system is given by a $2 \\times 2$ real symmetric matrix:\n$$\nH(s) = \\begin{pmatrix}\ne_h(s) & v(s) \\\\\nv(s) & e_p(s)\n\\end{pmatrix}\n$$\nThe IMSRG flow is designed to diagonalize this Hamiltonian. The decomposition into diagonal, $H_d(s)$, and off-diagonal, $H_{od}(s)$, parts is:\n$$\nH_d(s) = \\begin{pmatrix}\ne_h(s) & 0 \\\\\n0 & e_p(s)\n\\end{pmatrix}, \\quad H_{od}(s) = \\begin{pmatrix}\n0 & v(s) \\\\\nv(s) & 0\n\\end{pmatrix}\n$$\nThe Wegner generator, $\\eta(s)$, is defined as the commutator of these two parts:\n$$\n\\eta(s) = [H_d(s), H_{od}(s)] = H_d(s)H_{od}(s) - H_{od}(s)H_d(s)\n$$\nPerforming the matrix multiplication gives:\n$$\n\\eta(s) = \\begin{pmatrix}\ne_h & 0 \\\\\n0 & e_p\n\\end{pmatrix}\n\\begin{pmatrix}\n0 & v \\\\\nv & 0\n\\end{pmatrix} -\n\\begin{pmatrix}\n0 & v \\\\\nv & 0\n\\end{pmatrix}\n\\begin{pmatrix}\ne_h & 0 \\\\\n0 & e_p\n\\end{pmatrix}\n= \\begin{pmatrix}\n0 & e_h v \\\\\ne_p v & 0\n\\end{pmatrix} -\n\\begin{pmatrix}\n0 & v e_p \\\\\nv e_h & 0\n\\end{pmatrix}\n$$\n$$\n\\eta(s) = \\begin{pmatrix}\n0 & (e_h-e_p)v \\\\\n-(e_h-e_p)v & 0\n\\end{pmatrix} = (e_h(s) - e_p(s))v(s) \\begin{pmatrix}\n0 & 1 \\\\\n-1 & 0\n\\end{pmatrix}\n$$\nThe generator $\\eta(s)$ is correctly anti-Hermitian (and anti-symmetric for this real case). The Hamiltonian evolves according to the flow equation $dH(s)/ds = [\\eta(s), H(s)]$:\n$$\n\\frac{dH}{ds} = \\eta H - H \\eta = (e_h-e_p)v \\left[ \\begin{pmatrix}\n0 & 1 \\\\\n-1 & 0\n\\end{pmatrix}\n\\begin{pmatrix}\ne_h & v \\\\\nv & e_p\n\\end{pmatrix} -\n\\begin{pmatrix}\ne_h & v \\\\\nv & e_p\n\\end{pmatrix}\n\\begin{pmatrix}\n0 & 1 \\\\\n-1 & 0\n\\end{pmatrix} \\right]\n$$\n$$\n\\frac{dH}{ds} = (e_h-e_p)v \\left[ \\begin{pmatrix}\nv & e_p \\\\\n-e_h & -v\n\\end{pmatrix} -\n\\begin{pmatrix}\n-v & e_h \\\\\n-e_p & v\n\\end{pmatrix} \\right] = (e_h-e_p)v \\begin{pmatrix}\n2v & e_p-e_h \\\\\ne_p-e_h & -2v\n\\end{pmatrix}\n$$\nBy equating the components of $dH/ds$ with the matrix on the right, we obtain the system of coupled, first-order ODEs for the Hamiltonian elements:\n$$\n\\frac{d e_h}{ds} = 2 v^2 (e_h - e_p)\n$$\n$$\n\\frac{d e_p}{ds} = -2 v^2 (e_h - e_p)\n$$\n$$\n\\frac{d v}{ds} = -v (e_h - e_p)^2\n$$\nThe flow correctly conserves the trace, as $d(e_h+e_p)/ds = 0$. The goal of the flow is to drive the off-diagonal element $v(s)$ to zero, which occurs as long as $e_h \\neq e_p$.\n\n**2. Derivation of the Sensitivity Flow Equations**\n\nTo find the sensitivities $\\partial E / \\partial p$ for $p \\in \\{c_D, c_E\\}$, we employ forward-mode sensitivity propagation. Let the state vector be $y(s) = [e_h(s), e_p(s), v(s)]^T$. The flow equations can be written as $dy/ds = F(y(s))$. We wish to find the evolution of the sensitivities $y_p(s) = \\partial y(s) / \\partial p$. By applying the chain rule to the flow equation:\n$$\n\\frac{d y_p}{ds} = \\frac{d}{ds}\\left(\\frac{\\partial y}{\\partial p}\\right) = \\frac{\\partial}{\\partial p}\\left(\\frac{dy}{ds}\\right) = \\frac{\\partial F(y)}{\\partial p} = \\frac{\\partial F}{\\partial y} \\frac{\\partial y}{\\partial p} = J_F(y) y_p\n$$\nwhere $J_F(y)$ is the Jacobian matrix of the vector field $F$ with respect to the state $y$. The components of the Jacobian are $J_{ij} = \\partial F_i / \\partial y_j$.\nThe vector field is:\n$$\nF(y) = F(e_h, e_p, v) = \\begin{pmatrix}\n2 v^2 (e_h - e_p) \\\\\n-2 v^2 (e_h - e_p) \\\\\n-v (e_h - e_p)^2\n\\end{pmatrix}\n$$\nThe Jacobian matrix $J_F$ is:\n$$\nJ_F = \\begin{pmatrix}\n\\partial F_1/\\partial e_h & \\partial F_1/\\partial e_p & \\partial F_1/\\partial v \\\\\n\\partial F_2/\\partial e_h & \\partial F_2/\\partial e_p & \\partial F_2/\\partial v \\\\\n\\partial F_3/\\partial e_h & \\partial F_3/\\partial e_p & \\partial F_3/\\partial v\n\\end{pmatrix} = \\begin{pmatrix}\n2 v^2 & -2 v^2 & 4 v (e_h - e_p) \\\\\n-2 v^2 & 2 v^2 & -4 v (e_h - e_p) \\\\\n-2v (e_h - e_p) & 2v (e_h - e_p) & -(e_h - e_p)^2\n\\end{pmatrix}\n$$\nWe must solve a larger, coupled system of ODEs for the state and its sensitivities. For this problem, we have two parameters, $c_D$ and $c_E$. The full state vector for the integration is the $9$-component vector:\n$$\nY(s) = [e_h, e_p, v, \\partial e_h/\\partial c_D, \\partial e_p/\\partial c_D, \\partial v/\\partial c_D, \\partial e_h/\\partial c_E, \\partial e_p/\\partial c_E, \\partial v/\\partial c_E]^T\n$$\nThe system of ODEs for $Y(s)$ is constructed by augmenting the original system with the sensitivity equations for each parameter.\n\n**3. Numerical Integration Procedure**\n\nThe solution requires numerically integrating this $9$-component ODE system from $s=0$ to $s=s_{\\text{max}}$.\nThe initial conditions at $s=0$ are determined by the problem statement. For the Hamiltonian components:\n$$\ne_h(0) = \\varepsilon_h + \\alpha_{hD} \\, \\rho \\, c_D + \\alpha_{hE} \\, \\rho^2 \\, c_E\n$$\n$$\ne_p(0) = \\varepsilon_p + \\alpha_{pD} \\, \\rho \\, c_D + \\alpha_{pE} \\, \\rho^2 \\, c_E\n$$\n$$\nv(0) = v_0 + \\beta_D \\, \\rho \\, c_D + \\beta_E \\, \\rho \\, c_E\n$$\nThe initial conditions for the sensitivities are found by differentiating these expressions with respect to $c_D$ and $c_E$:\nFor $p = c_D$:\n$$\n\\frac{\\partial e_h(0)}{\\partial c_D} = \\alpha_{hD} \\, \\rho, \\quad \\frac{\\partial e_p(0)}{\\partial c_D} = \\alpha_{pD} \\, \\rho, \\quad \\frac{\\partial v(0)}{\\partial c_D} = \\beta_D \\, \\rho\n$$\nFor $p = c_E$:\n$$\n\\frac{\\partial e_h(0)}{\\partial c_E} = \\alpha_{hE} \\, \\rho^2, \\quad \\frac{\\partial e_p(0)}{\\partial c_E} = \\alpha_{pE} \\, \\rho^2, \\quad \\frac{\\partial v(0)}{\\partial c_E} = \\beta_E \\, \\rho\n$$\nWith these initial conditions, a numerical ODE solver (such as `scipy.integrate.solve_ivp`) is used to obtain the state vector $Y(s_{\\text{max}})$, which contains the values of $H(s_{\\text{max}})$ and $\\partial H(s_{\\text{max}})/\\partial p$.\n\n**4. Final Sensitivity Calculation**\n\nAt $s = s_{\\text{max}}$, the Hamiltonian is $H(s_{\\text{max}})$. Its eigenvalues are given by:\n$$\n\\lambda_{\\pm} = \\frac{e_h(s_{\\text{max}}) + e_p(s_{\\text{max}}) \\pm \\sqrt{(e_h(s_{\\text{max}}) - e_p(s_{\\text{max}}))^2 + 4v(s_{\\text{max}})^2}}{2}\n$$\nThe lowest eigenvalue is $E = \\lambda_{\\min} = \\lambda_{-}$. The corresponding normalized eigenvector, $\\mathbf{v}_{\\min}$, must be computed.\nThe sensitivity of the eigenvalue $E$ with respect to a parameter $p$ is given by first-order perturbation theory, also known as the Hellmann-Feynman theorem:\n$$\n\\frac{\\partial E}{\\partial p} = \\mathbf{v}_{\\min}^\\top \\left( \\frac{\\partial H(s_{\\text{max}})}{\\partial p} \\right) \\mathbf{v}_{\\min}\n$$\nLetting $\\mathbf{v}_{\\min} = [v_1, v_2]^T$ and $\\partial H/\\partial p = \\begin{pmatrix} \\partial e_h/\\partial p & \\partial v/\\partial p \\\\ \\partial v/\\partial p & \\partial e_p/\\partial p \\end{pmatrix}$, the expression becomes:\n$$\n\\frac{\\partial E}{\\partial p} = v_1^2 \\frac{\\partial e_h(s_{\\text{max}})}{\\partial p} + v_2^2 \\frac{\\partial e_p(s_{\\text{max}})}{\\partial p} + 2 v_1 v_2 \\frac{\\partial v(s_{\\text{max}})}{\\partial p}\n$$\nThis formula is applied for both $p=c_D$ and $p=c_E$, using the sensitivities obtained from the ODE integration, to yield the final desired results.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Test suite: (eps_h, eps_p, v0, rho, alpha_hD, alpha_hE, alpha_pD, \n    #              alpha_pE, beta_D, beta_E, c_D, c_E, s_max)\n    test_cases = [\n        (-12.0, 3.0, 1.5, 0.16, 2.0, 1.5, 1.0, 0.5, 0.8, 0.2, -0.2, -0.5, 20.0),\n        (-10.0, 2.0, 0.0, 0.16, 2.0, 1.5, 1.0, 0.5, 0.8, 0.2, 0.0, 0.0, 20.0),\n        (-1.0, -0.8, 0.05, 0.14, 2.0, 1.5, 1.0, 0.5, 0.8, 0.2, 0.1, -0.1, 50.0),\n        (-15.0, 4.0, 2.5, 0.17, 2.5, 1.7, 1.3, 0.8, 1.0, 0.4, 0.2, 0.3, 25.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_sensitivities(case)\n        results.append(result)\n    \n    # Format the output as a string representing a list of lists.\n    # str(list) automatically adds spaces, which is acceptable.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\ndef compute_sensitivities(params):\n    \"\"\"\n    Computes energy sensitivities for a single set of parameters.\n    \"\"\"\n    (eps_h, eps_p, v0, rho, alpha_hD, alpha_hE, alpha_pD, \n     alpha_pE, beta_D, beta_E, c_D, c_E, s_max) = params\n\n    # 1. Define the ODE system for the state and sensitivities\n    def ode_system(s, y):\n        \"\"\"\n        Defines the 9-component ODE system for the IMSRG flow and sensitivities.\n        y = [e_h, e_p, v, de_h/dcD, de_p/dcD, dv/dcD, de_h/dcE, de_p/dcE, dv/dcE]\n        \"\"\"\n        e_h, e_p, v, eh_d, ep_d, v_d, eh_e, ep_e, v_e = y\n        \n        # Flow equations for H(s)\n        e_diff = e_h - e_p\n        v_sq = v * v\n        \n        de_h_ds = 2.0 * v_sq * e_diff\n        de_p_ds = -2.0 * v_sq * e_diff\n        dv_ds = -v * e_diff * e_diff\n        \n        # Jacobian of the flow equations\n        J = np.zeros((3, 3))\n        J[0, 0] = 2.0 * v_sq\n        J[0, 1] = -2.0 * v_sq\n        J[0, 2] = 4.0 * v * e_diff\n        J[1, 0] = -2.0 * v_sq\n        J[1, 1] = 2.0 * v_sq\n        J[1, 2] = -4.0 * v * e_diff\n        J[2, 0] = -2.0 * v * e_diff\n        J[2, 1] = 2.0 * v * e_diff\n        J[2, 2] = -e_diff * e_diff\n        \n        # Sensitivity vectors\n        y_d = np.array([eh_d, ep_d, v_d])\n        y_e = np.array([eh_e, ep_e, v_e])\n        \n        # Flow equations for sensitivities\n        dy_d_ds = J @ y_d\n        dy_e_ds = J @ y_e\n        \n        dydt = np.concatenate(([de_h_ds, de_p_ds, dv_ds], dy_d_ds, dy_e_ds))\n        return dydt\n\n    # 2. Set up initial conditions at s=0\n    rho_sq = rho * rho\n    \n    e_h_0 = eps_h + alpha_hD * rho * c_D + alpha_hE * rho_sq * c_E\n    e_p_0 = eps_p + alpha_pD * rho * c_D + alpha_pE * rho_sq * c_E\n    v_0 = v0 + beta_D * rho * c_D + beta_E * rho * c_E\n    \n    # Initial sensitivities wrt c_D\n    deh_dcd_0 = alpha_hD * rho\n    dep_dcd_0 = alpha_pD * rho\n    dv_dcd_0 = beta_D * rho\n    \n    # Initial sensitivities wrt c_E\n    deh_dce_0 = alpha_hE * rho_sq\n    dep_dce_0 = alpha_pE * rho_sq\n    dv_dce_0 = beta_E * rho\n\n    y0 = np.array([\n        e_h_0, e_p_0, v_0,\n        deh_dcd_0, dep_dcd_0, dv_dcd_0,\n        deh_dce_0, dep_dce_0, dv_dce_0\n    ])\n\n    # 3. Integrate the ODE system\n    sol = solve_ivp(\n        ode_system, \n        [0, s_max], \n        y0, \n        method='RK45', \n        rtol=1e-8, \n        atol=1e-10\n    )\n    y_final = sol.y[:, -1]\n\n    # 4. Compute final energy sensitivities\n    e_h_f, e_p_f, v_f, eh_d_f, ep_d_f, v_d_f, eh_e_f, ep_e_f, v_e_f = y_final\n    \n    # Construct Hamiltonian at s_max\n    H_final = np.array([\n        [e_h_f, v_f],\n        [v_f,   e_p_f]\n    ])\n    \n    # Get lowest eigenvalue and corresponding eigenvector\n    # np.linalg.eigh returns eigenvalues in ascending order\n    evals, evecs = np.linalg.eigh(H_final)\n    lambda_min = evals[0]\n    v_min = evecs[:, 0]  # First column is eigenvector for lowest eigenvalue\n    v1, v2 = v_min\n    \n    # Apply Hellmann-Feynman theorem\n    # Sensitivity wrt c_D\n    dE_dcD = v1**2 * eh_d_f + v2**2 * ep_d_f + 2 * v1 * v2 * v_d_f\n    \n    # Sensitivity wrt c_E\n    dE_dcE = v1**2 * eh_e_f + v2**2 * ep_e_f + 2 * v1 * v2 * v_e_f\n    \n    return [dE_dcD, dE_dcE]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}