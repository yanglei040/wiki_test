{
    "hands_on_practices": [
        {
            "introduction": "在进行任何复杂的计算物理模拟之前，一个至关重要的步骤是理解问题的基本结构和规模。本练习聚焦于耦合簇双激发（CCD）方法的核心要素——双激发振幅 $t_{ij}^{ab}$，并演示了如何利用费米子反对称性等基本原理，将抽象的理论概念转化为大幅降低计算和内存成本的实用工具。通过这个练习，你将对耦合簇问题的维度建立起一个具体而坚实的理解。",
            "id": "3553374",
            "problem": "考虑应用于单粒子基中闭壳层原子核的耦合簇(CC)方法，其中簇算符仅包含双激发组分。双激发簇算符在二次量子化形式下写作\n$$\nT_{2} = \\frac{1}{4} \\sum_{i j a b} t_{i j}^{a b}\\, a_{a}^{\\dagger} a_{b}^{\\dagger} a_{j} a_{i},\n$$\n其中 $a_{p}^{\\dagger}$ 和 $a_{p}$ 是服从正则反对易关系的费米子产生和湮灭算符，而 $t_{i j}^{a b}$ 是连接已占据单粒子态 $(i,j)$ 与未占据（虚）单粒子态 $(a,b)$ 的双激发振幅。这些指标包含自旋和同位旋量子数，$i,j$ 从参考Slater行列式的已占据流形中选取，$a,b$ 从虚流形中选取。原子核哈密顿量守恒同位旋和宇称，粒子种类标签（中子或质子）用于将振幅张量分块为三个不重叠的通道：中子-中子、质子-质子和中子-质子。由于费米子反对称性，同种粒子通道中的振幅在交换已占据指标或虚指标时满足反对称性。相比之下，对于混合粒子通道，跨物种交换不会产生冗余，因为被交换的对象属于不同的块。\n\n一种实现通过利用这些反对称性和粒子种类块结构，仅存储独立的双激发振幅。具体来说：\n- 在中子-中子块中，仅存储已占据中子指标的无序对和虚中子指标的无序对。\n- 在质子-质子块中，仅存储已占据质子指标的无序对和虚质子指标的无序对。\n- 在中子-质子块中，存储一个已占据中子与一个已占据质子，以及一个虚中子与一个虚质子的所有组合，不再进一步简化。\n\n从费米子反对易关系和 $T_{2}$ 的算符结构出发，推导每个块中存储的独立双激发振幅数量的计数规则。然后，对于一个模型空间，其中有 $n_{o}^{n} = 10$ 个已占据中子，$n_{v}^{n} = 30$ 个虚中子，$n_{o}^{p} = 8$ 个已占据质子，以及 $n_{v}^{p} = 24$ 个虚质子，计算所有三个块中存储的双激发振幅的总数。\n\n将您的最终计数表示为一个没有单位的精确整数。",
            "solution": "该问题是有效的，因为它科学地基于多体量子力学原理和耦合簇理论，问题陈述清晰，目标明确，数据充分，并且没有任何科学或逻辑上的矛盾。因此，我们可以进行推导和计算。\n\n该问题要求计算在原子核的耦合簇计算中存储的独立双激发振幅 $t_{i j}^{a b}$ 的总数。存储方案利用了由费米子反对称性和基于粒子类型（中子或质子）的块结构产生的对称性。振幅总数是三个不同通道中独立振幅数量的总和：中子-中子 ($nn$)、质子-质子 ($pp$) 和中子-质子 ($np$)。\n\n双激发的簇算符 $T_2$ 由下式给出\n$$\nT_{2} = \\frac{1}{4} \\sum_{i j a b} t_{i j}^{a b}\\, a_{a}^{\\dagger} a_{b}^{\\dagger} a_{j} a_{i}\n$$\n其中指标 $i, j$ 遍历已占据单粒子态，而 $a, b$ 遍历虚（未占据）单粒子态。算符 $a^{\\dagger}$ 和 $a$ 是费米子产生和湮灭算符。由于反对易关系 $\\{a_p, a_q\\} = 0$ 和 $\\{a_p^{\\dagger}, a_q^{\\dagger}\\} = 0$，算符乘积 $a_{a}^{\\dagger} a_{b}^{\\dagger} a_{j} a_{i}$ 在交换 $i \\leftrightarrow j$ 和 $a \\leftrightarrow b$ 时是反对称的。为确保求和中每个不同的物理激发只被计算一次，振幅必须具有相同的反对称性：\n$$\nt_{ij}^{ab} = -t_{ji}^{ab} \\quad \\text{and} \\quad t_{ij}^{ab} = -t_{ij}^{ba}\n$$\n这意味着 $t_{ij}^{ab} = t_{ji}^{ba}$。这些关系是确定唯一振幅数量的基础。\n\n我们分别分析每个通道。\n\n**1. 中子-中子 ($nn$) 通道**\n在此通道中，所有四个指标 ($i, j, a, b$) 都对应中子态。设已占据中子态的数量为 $n_{o}^{n}$，虚中子态的数量为 $n_{v}^{n}$。振幅的形式为 $t_{i_n j_n}^{a_n b_n}$。\n由于反对称性 $t_{i_n j_n}^{a_n b_n} = -t_{j_n i_n}^{a_n b_n}$，我们必须有 $i_n \\neq j_n$。为了计算独立振幅的数量，我们可以采用一个约定，例如，只存储那些 $i_n  j_n$ 的振幅。不考虑顺序选择两个不同已占据中子指标的方式数由二项式系数 $\\binom{n_{o}^{n}}{2}$ 给出。\n同样地，由于反对称性 $t_{i_n j_n}^{a_n b_n} = -t_{i_n j_n}^{b_n a_n}$，我们必须有 $a_n \\neq b_n$。我们按照约定只存储 $a_n  b_n$ 的振幅。不考虑顺序选择两个不同虚中子指标的方式数是 $\\binom{n_{v}^{n}}{2}$。\n独立的中子-中子振幅总数 $N_{nn}$ 是唯一空穴对数量和唯一粒子对数量的乘积。\n$$\nN_{nn} = \\binom{n_{o}^{n}}{2} \\binom{n_{v}^{n}}{2}\n$$\n\n**2. 质子-质子 ($pp$) 通道**\n此通道的逻辑与中子-中子通道相同。所有四个指标都对应质子态。设已占据质子态的数量为 $n_{o}^{p}$，虚质子态的数量为 $n_{v}^{p}$。振幅的形式为 $t_{i_p j_p}^{a_p b_p}$。\n独立的质子-质子振幅数量 $N_{pp}$ 是：\n$$\nN_{pp} = \\binom{n_{o}^{p}}{2} \\binom{n_{v}^{p}}{2}\n$$\n\n**3. 中子-质子 ($np$) 通道**\n在此通道中，激发涉及一个中子和一个质子。振幅对应于将一个已占据的中子-质子对移动到一个虚的中子-质子对，例如 $t_{i_n j_p}^{a_n b_p}$。指标 $i_n, a_n$ 是中子态，$j_p, b_p$ 是质子态。\n因为中子和质子是可区分的粒子，交换一个中子指标和一个质子指标没有反对称性约束。例如，$t_{i_n j_p}^{a_n b_p}$ 和 $t_{j_p i_n}^{a_n b_p}$ 是完全不同的振幅，因为后者表示从一个已占据的质子-中子态对的激发。问题陈述正确地指出“跨物种交换不会产生冗余”。\n因此，要计算独立振幅的数量，我们只需计算来自以下四类中每类一个态的所有可能组合：\n- 已占据中子态 $i_n$ 的选择数：$n_{o}^{n}$\n- 已占据质子态 $j_p$ 的选择数：$n_{o}^{p}$\n- 虚中子态 $a_n$ 的选择数：$n_{v}^{n}$\n- 虚质子态 $b_p$ 的选择数：$n_{v}^{p}$\n独立的中子-质子振幅总数 $N_{np}$ 是这些计数的乘积：\n$$\nN_{np} = n_{o}^{n} \\cdot n_{o}^{p} \\cdot n_{v}^{n} \\cdot n_{v}^{p}\n$$\n\n**振幅总数**\n存储的双激发振幅总数 $N_{\\text{total}}$ 是这三个互斥块的计数之和：\n$$\nN_{\\text{total}} = N_{nn} + N_{pp} + N_{np}\n$$\n\n**计算**\n我们得到了模型空间的以下参数：\n- $n_{o}^{n} = 10$\n- $n_{v}^{n} = 30$\n- $n_{o}^{p} = 8$\n- $n_{v}^{p} = 24$\n\n现在，我们计算每个块的振幅数量。\n\n对于 $nn$ 块：\n$$\nN_{nn} = \\binom{10}{2} \\binom{30}{2} = \\left(\\frac{10 \\times 9}{2 \\times 1}\\right) \\left(\\frac{30 \\times 29}{2 \\times 1}\\right) = 45 \\times 435 = 19575\n$$\n\n对于 $pp$ 块：\n$$\nN_{pp} = \\binom{8}{2} \\binom{24}{2} = \\left(\\frac{8 \\times 7}{2 \\times 1}\\right) \\left(\\frac{24 \\times 23}{2 \\times 1}\\right) = 28 \\times 276 = 7728\n$$\n\n对于 $np$ 块：\n$$\nN_{np} = 10 \\times 8 \\times 30 \\times 24 = 80 \\times 720 = 57600\n$$\n\n最后，存储的振幅总数是这些值的和：\n$$\nN_{\\text{total}} = N_{nn} + N_{pp} + N_{np} = 19575 + 7728 + 57600 = 84903\n$$\n存储的双激发振幅总数为 $84903$。",
            "answer": "$$\\boxed{84903}$$"
        },
        {
            "introduction": "尽管迭代多体方法功能强大，但它们可能会遭遇数值不稳定性，特别是当系统的能谱具有某些特定结构时。本练习引入了“入侵态”的概念，这是耦合簇计算中常见的导致发散的根源，其关键在于审视理论中出现的能量分母 $D_{ij}^{ab}$。通过一个动手编程练习，你将学习如何通过雅可比矩阵的条件数来量化这种不稳定性，并探索实用的正则化技术，以确保获得稳健可靠的解。",
            "id": "3553397",
            "problem": "考虑计算核物理中的一个闭壳层参考态和一个用二次量子化形式写出的模型哈密顿量。耦合簇双激发 (CCD) 近似通过一个作用于参考态上的双激发算符的指数拟设来参数化关联基态。在迭代或类牛顿解法策略中，当能量分母变得很小且残差相对于双激发振幅的雅可比矩阵变得病态时，可能会在入侵态附近发生失效。在本问题中，您将需要形式化地定义并计算量化这种失效，并评估两种正则化策略。\n\n从以下基本要素开始：\n\n- 单粒子轨道能量 $\\epsilon_p$ 定义了一个平均场划分。索引 $i,j$ 表示占据轨道，索引 $a,b$ 表示未占（虚）轨道。双激发由满足 i",
            "solution": "用户的问题要求在一个耦合簇双激发 (CCD) 方法的简化模型中，对数值不稳定性进行定量分析，特别关注在所谓的“入侵态”附近雅可比矩阵的病态问题。解决方案涉及为三种不同的能量分母定义（原始、均匀平移和 Epstein–Nesbet 风格）构建此雅可比矩阵，然后计算表征不稳定性的指标。\n\n整体算法设计如下：\n首先，对于每个测试用例，我们必须定义问题空间。双激发空间由所有可能的从占据轨道到虚轨道的双粒子提升构成。给定由 $i, j$ 索引的 $n_{\\mathrm{occ}}$ 个占据轨道和由 $a, b$ 索引的 $n_{\\mathrm{vir}}$ 个虚轨道，我们形成所有满足 i",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the formatted results.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    # Structure: (n_occ, eps_occ, n_vir, eps_vir, alpha, s, seed)\n    test_cases = [\n        (2, [-10.0, -9.0], 3, [0.0, 1.0, 2.0], 0.2, 0.5, 42),\n        (2, [-10.0, -9.0], 3, [-10.0, -9.0, 0.5], 0.2, 0.5, 123),\n        (2, [-10.0, -9.0], 3, [-10.0 + 1e-6, -9.0, 1.0], 0.2, 0.5, 7),\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        results = process_case(*case_params)\n        all_results.append(results)\n\n    # Format the final output string as a list of lists, without spaces.\n    case_strings = []\n    for res_list in all_results:\n        case_strings.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    final_output_string = f\"[{','.join(case_strings)}]\"\n    print(final_output_string)\n\ndef process_case(n_occ, eps_occ, n_vir, eps_vir, alpha, s, seed):\n    \"\"\"\n    Computes the required metrics for a single test case.\n    \n    Args:\n        n_occ (int): Number of occupied orbitals.\n        eps_occ (list): List of occupied orbital energies.\n        n_vir (int): Number of virtual orbitals.\n        eps_vir (list): List of virtual orbital energies.\n        alpha (float): Coupling constant for the Jacobian.\n        s (float): Uniform denominator shift value.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        list: A list of six floating-point numbers representing the computed metrics.\n    \"\"\"\n    # 1. Initialize the deterministic random number generator.\n    rng = np.random.default_rng(seed)\n\n    # 2. Generate the doubles excitation space.\n    occ_pairs = list(itertools.combinations(range(n_occ), 2))\n    vir_pairs = list(itertools.combinations(range(n_vir), 2))\n    \n    num_occ_pairs = len(occ_pairs)\n    num_vir_pairs = len(vir_pairs)\n    num_doubles = num_occ_pairs * num_vir_pairs\n    \n    # Early exit if no doubles excitations are possible.\n    if num_doubles == 0:\n        return [np.nan] * 6\n\n    # Create a canonical mapping from an excitation index k to the orbital indices (i,j,a,b).\n    excitations = []\n    for i, j in occ_pairs:\n        for a, b in vir_pairs:\n            excitations.append({'occ': (i, j), 'vir': (a, b)})\n    \n    occ_pair_map = {pair: i for i, pair in enumerate(occ_pairs)}\n    vir_pair_map = {pair: i for i, pair in enumerate(vir_pairs)}\n\n    # 3. Generate interaction matrix elements in a fixed, deterministic order.\n    # v_ij^ab for all doubles excitations\n    v_vec = rng.normal(loc=0.0, scale=0.5, size=num_doubles)\n    \n    # W_ij^ij for all occupied pairs\n    w_occ_diag = rng.normal(loc=0.0, scale=0.5, size=num_occ_pairs)\n    \n    # W_ab^ab for all virtual pairs\n    w_vir_diag = rng.normal(loc=0.0, scale=0.5, size=num_vir_pairs)\n\n    # 4. Compute the three types of denominators.\n    D_raw = np.zeros(num_doubles)\n    D_en = np.zeros(num_doubles)\n    \n    for k, exc in enumerate(excitations):\n        i, j = exc['occ']\n        a, b = exc['vir']\n        \n        # Raw Møller-Plesset denominator\n        d_raw = eps_vir[a] + eps_vir[b] - eps_occ[i] - eps_occ[j]\n        D_raw[k] = d_raw\n        \n        # Epstein-Nesbet denominator\n        occ_pair_idx = occ_pair_map[(i, j)]\n        vir_pair_idx = vir_pair_map[(a, b)]\n        en_correction = w_vir_diag[vir_pair_idx] - w_occ_diag[occ_pair_idx]\n        D_en[k] = d_raw + en_correction\n\n    # Uniformly shifted denominator\n    D_shifted = D_raw + s\n\n    # 5. Compute minimal absolute denominators.\n    min_abs_D_raw = np.min(np.abs(D_raw))\n    min_abs_D_shifted = np.min(np.abs(D_shifted))\n    min_abs_D_en = np.min(np.abs(D_en))\n\n    # 6. Build Jacobians and compute condition numbers.\n    def get_kappa(D_vec, v_vec, alpha_val):\n        \"\"\"Helper to build Jacobian and compute its 2-norm condition number.\"\"\"\n        J = np.diag(D_vec) - alpha_val * np.outer(v_vec, v_vec)\n        return np.linalg.cond(J, p=2)\n\n    kappa_raw = get_kappa(D_raw, v_vec, alpha)\n    kappa_shifted = get_kappa(D_shifted, v_vec, alpha)\n    kappa_en = get_kappa(D_en, v_vec, alpha)\n    \n    # 7. Aggregate and return the six computed metrics.\n    return [\n        min_abs_D_raw, kappa_raw,\n        min_abs_D_shifted, kappa_shifted,\n        min_abs_D_en, kappa_en\n    ]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "高效求解非线性的耦合簇双激发（CCD）方程是一项重大挑战，通常需要超越简单定点迭代的复杂数值技术。本练习通过分析定点迭代映射的雅可比矩阵，深入探讨了振幅方程的局部收敛行为。通过计算雅可比矩阵的谱特性，你将洞悉迭代收敛或发散的原因，并学习如何利用这些信息来智能地调整如安德森加速（Anderson acceleration）这样的高级加速方案。",
            "id": "3553383",
            "problem": "给定一个针对闭壳层体系的耦合簇双激发 (CCD) 振幅方程的简化、自洽不动点公式。该公式在一个小的模型空间中构建，捕捉了本质的非线性结构，同时在计算上是可行的。未知量是一个双激发振幅向量 $\\mathbf{t} \\in \\mathbb{R}^{n}$，其中 $n$ 很小。该映射按分量定义为\n$$\nF_i(\\mathbf{t}) \\equiv \\frac{g_i + \\sum_{j=1}^{n} A_{ij}\\, t_j + \\sum_{j=1}^{n}\\sum_{k=1}^{n} Q_{ijk}\\, t_j t_k}{\\Delta_i}, \\quad i = 1, \\dots, n,\n$$\n其中 $\\boldsymbol{\\Delta} \\in \\mathbb{R}^n$ 是正能量分母，$\\mathbf{g} \\in \\mathbb{R}^n$ 是驱动向量，$\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$ 是一个对称的有效耦合矩阵，编码了（环图和梯图）线性化贡献，而 $\\mathbf{Q} \\in \\mathbb{R}^{n \\times n \\times n}$ 是一个对称的3阶张量，编码了二次贡献。CCD 不动点满足 $\\mathbf{t} = \\mathbf{F}(\\mathbf{t})$。关于点 $\\mathbf{t}_0$ 的局部线性化由 $\\mathbf{F}$ 的雅可比矩阵描述，即矩阵 $\\mathbf{J}(\\mathbf{t}_0)$，其元素为在 $\\mathbf{t}_0$ 处求值的 $J_{i\\ell}(\\mathbf{t}_0) = \\partial F_i/\\partial t_\\ell$。在雅可比矩阵的谱半径严格小于1的不动点附近，不动点迭代收敛。诸如安德森加速之类的实用加速器可以基于这种局部线性化的特征信息进行调整。\n\n您的任务是：\n\n- 根据 $\\mathbf{F}$ 的定义，推导雅可比矩阵元素 $J_{i\\ell}(\\mathbf{t})$ 关于 $\\boldsymbol{\\Delta}$、$\\mathbf{A}$、$\\mathbf{Q}$ 和 $\\mathbf{t}$ 的一般形式，然后将其应用于展开点 $\\mathbf{t}_0 = \\mathbf{0}$ 以获得 $\\mathbf{J}(\\mathbf{0})$。除了所述定义和标准微分法则外，不要假设任何特殊恒等式。\n\n- 计算 $\\mathbf{J}(\\mathbf{0})$ 的主特征对（特征值和相应的归一化特征向量），其中“主”指模最大的特征值。令谱半径为 $\\rho \\equiv \\max_i |\\lambda_i|$，谱隙为 $\\delta \\equiv \\rho - \\max_{i \\neq i_\\star} |\\lambda_i|$，其中 $i_\\star$ 是实现 $\\rho$ 的特征值的索引。\n\n- 基于估算的 $\\rho$ 和 $\\delta$，选择两个安德森加速参数：\n  - 历史长度 $m \\in \\mathbb{Z}$，其界限为 $m_{\\min} \\le m \\le m_{\\max}$，使用规则\n    $$\n    m_{\\mathrm{raw}} \\equiv 1 + \\alpha \\,\\frac{\\rho}{\\delta + \\varepsilon}, \\quad m \\equiv \\mathrm{round}\\!\\left(\\min\\!\\left(\\max\\!\\left(m_{\\mathrm{raw}}, m_{\\min}\\right), m_{\\max}\\right)\\right),\n    $$\n    其中调整常数 $\\alpha > 0$ 且 $\\varepsilon > 0$。\n  - 阻尼因子 $\\beta \\in \\mathbb{R}$，其界限为 $\\beta_{\\min} \\le \\beta \\le \\beta_{\\max}$，使用规则\n    $$\n    \\beta_{\\mathrm{raw}} \\equiv\n    \\begin{cases}\n      1 - \\frac{1}{2}\\,\\rho - \\frac{1}{4}\\,\\delta,   \\text{若 } \\rho  1,\\\\[4pt]\n      \\dfrac{1}{1+\\rho},   \\text{若 } \\rho \\ge 1,\n    \\end{cases}\n    \\quad \\beta \\equiv \\min\\!\\left(\\max\\!\\left(\\beta_{\\mathrm{raw}}, \\beta_{\\min}\\right), \\beta_{\\max}\\right).\n    $$\n\n- 实现一个程序，对于每个提供的测试用例，构造 $\\mathbf{J}(\\mathbf{0})$，计算主特征对，估算 $\\rho$ 和 $\\delta$，使用给定的规则和界限计算 $m$ 和 $\\beta$，并为每个用例返回列表 $[\\rho, \\delta, m, \\beta]$。\n\n使用以下测试套件。在每个用例中，令 $n = 4$。令正交矩阵 $\\mathbf{U} \\in \\mathbb{R}^{4 \\times 4}$ 为沃尔什-哈达玛矩阵乘以 $1/2$：\n$$\n\\mathbf{U} \\equiv \\frac{1}{2}\n\\begin{bmatrix}\n1   1   1   1\\\\\n1   1   -1   -1\\\\\n1   -1   1   -1\\\\\n1   -1   -1   1\n\\end{bmatrix}.\n$$\n令分母为 $\\boldsymbol{\\Delta} = [2.0, 2.5, 3.0, 3.5]$，单位为 $\\mathrm{MeV}$，并对所有用例设置 $\\mathbf{Q} = \\mathbf{0}$ 和 $\\mathbf{g} = \\mathbf{0}$（因此在 $\\mathbf{t}_0 = \\mathbf{0}$ 时雅可比矩阵仅依赖于 $\\boldsymbol{\\Delta}$ 和 $\\mathbf{A}$）。对于每个用例，定义目标特征值谱 $\\boldsymbol{\\lambda}$并通过以下方式构造 $\\mathbf{A}$：\n$$\n\\mathbf{A} \\equiv \\mathrm{diag}(\\boldsymbol{\\Delta}) \\, \\mathbf{U} \\, \\mathrm{diag}(\\boldsymbol{\\lambda}) \\, \\mathbf{U}^{\\top}.\n$$\n这确保了 $\\mathbf{J}(\\mathbf{0})$ 的特征值等于 $\\boldsymbol{\\lambda}$，特征向量由 $\\mathbf{U}$ 的列给出。\n\n- 用例1：\n  - $\\boldsymbol{\\lambda}^{(1)} = [0.2, 0.1, 0.05, 0.01]$。\n- 用例2：\n  - $\\boldsymbol{\\lambda}^{(2)} = [0.92, 0.90, 0.3, 0.1]$。\n- 用例3：\n  - $\\boldsymbol{\\lambda}^{(3)} = [1.05, 0.95, 0.4, 0.1]$。\n\n使用安德森调整常数和界限：\n- $\\alpha = 2.0$,\n- $\\varepsilon = 10^{-9}$,\n- $m_{\\min} = 2$, $m_{\\max} = 6$,\n- $\\beta_{\\min} = 0.05$, $\\beta_{\\max} = 1.0$。\n\n角度单位不适用。所有输出都是无量纲实数。你的程序应生成单行输出，包含一个逗号分隔的列表的列表形式的结果，不含空格，格式如下\n$$\n[\\,[\\rho_1,\\delta_1,m_1,\\beta_1],[\\rho_2,\\delta_2,m_2,\\beta_2],\\ldots\\,],\n$$\n其中索引按顺序对应测试用例。每个 $\\rho_k$ 和 $\\delta_k$ 必须打印小数点后恰好 $6$ 位数字。每个 $\\beta_k$ 必须打印小数点后恰好 $6$ 位数字。每个 $m_k$ 必须作为不带小数点的整数打印。输出必须是单行，且不包含其他字符或空格。",
            "solution": "问题要求基于一个简化的耦合簇双激发 (CCD) 不动点映射的雅可比矩阵的谱特性，来确定安德森加速的参数。这个过程包括三个主要步骤：第一，推导雅可比矩阵在原点处的解析形式；第二，根据问题的特定构造确定其特征值；第三，为给定的三个测试用例计算谱半径 $\\rho$、谱隙 $\\delta$ 以及相关的加速参数 $m$ 和 $\\beta$。\n\n### 步骤1：雅可比矩阵的推导\n\n不动点映射 $\\mathbf{F}(\\mathbf{t})$ 对于 $i=1, \\dots, n$ 的分量形式如下：\n$$\nF_i(\\mathbf{t}) = \\frac{g_i + \\sum_{j=1}^{n} A_{ij}\\, t_j + \\sum_{j=1}^{n}\\sum_{k=1}^{n} Q_{ijk}\\, t_j t_k}{\\Delta_i}\n$$\n雅可比矩阵 $\\mathbf{J}(\\mathbf{t})$ 由其元素 $J_{i\\ell}(\\mathbf{t}) = \\frac{\\partial F_i}{\\partial t_\\ell}$ 定义。我们计算这个偏导数：\n$$\nJ_{i\\ell}(\\mathbf{t}) = \\frac{\\partial}{\\partial t_\\ell} \\left[ \\frac{1}{\\Delta_i} \\left( g_i + \\sum_{j=1}^{n} A_{ij}\\, t_j + \\sum_{j,k=1}^{n} Q_{ijk}\\, t_j t_k \\right) \\right]\n$$\n项 $g_i$ 和 $\\Delta_i$ 相对于 $\\mathbf{t}$ 的分量是常数。应用微分法则，我们得到：\n$$\nJ_{i\\ell}(\\mathbf{t}) = \\frac{1}{\\Delta_i} \\left[ \\frac{\\partial}{\\partial t_\\ell}\\left(\\sum_{j=1}^{n} A_{ij}\\, t_j\\right) + \\frac{\\partial}{\\partial t_\\ell}\\left(\\sum_{j,k=1}^{n} Q_{ijk}\\, t_j t_k\\right) \\right]\n$$\n线性项的导数是：\n$$\n\\frac{\\partial}{\\partial t_\\ell}\\left(\\sum_{j=1}^{n} A_{ij}\\, t_j\\right) = \\sum_{j=1}^{n} A_{ij} \\frac{\\partial t_j}{\\partial t_\\ell} = \\sum_{j=1}^{n} A_{ij} \\delta_{j\\ell} = A_{i\\ell}\n$$\n其中 $\\delta_{j\\ell}$ 是克罗内克 delta。\n\n对于二次项，我们使用乘法法则，并注意到张量 $\\mathbf{Q}$ 对于其索引的交换是对称的：\n$$\n\\frac{\\partial}{\\partial t_\\ell}\\left(\\sum_{j,k=1}^{n} Q_{ijk}\\, t_j t_k\\right) = \\sum_{j,k=1}^{n} Q_{ijk} \\left( \\frac{\\partial t_j}{\\partial t_\\ell} t_k + t_j \\frac{\\partial t_k}{\\partial t_\\ell} \\right) = \\sum_{j,k=1}^{n} Q_{ijk} (\\delta_{j\\ell} t_k + t_j \\delta_{k\\ell})\n$$\n这可以简化为：\n$$\n\\sum_{k=1}^{n} Q_{i\\ell k} t_k + \\sum_{j=1}^{n} Q_{ij\\ell} t_j\n$$\n利用 $\\mathbf{Q}$ 的对称性（即 $Q_{i\\ell k} = Q_{ik\\ell}$）并将第二项中的求和索引从 $j$ 重命名为 $k$，我们合并这两项：\n$$\n\\sum_{k=1}^{n} Q_{i\\ell k} t_k + \\sum_{k=1}^{n} Q_{ik\\ell} t_k = \\sum_{k=1}^{n} (Q_{i\\ell k} + Q_{ik\\ell}) t_k = 2 \\sum_{k=1}^{n} Q_{i\\ell k} t_k\n$$\n结合线性和二次部分，雅可比矩阵元素的一般表达式是：\n$$\nJ_{i\\ell}(\\mathbf{t}) = \\frac{1}{\\Delta_i} \\left( A_{i\\ell} + 2 \\sum_{k=1}^{n} Q_{i\\ell k} t_k \\right)\n$$\n问题指定分析应在展开点 $\\mathbf{t}_0 = \\mathbf{0}$ 进行。我们还得知，对于所有测试用例，$\\mathbf{Q} = \\mathbf{0}$。即使 $\\mathbf{Q}$ 不为零，二次项在 $\\mathbf{t}=\\mathbf{0}$ 处也会消失。在 $\\mathbf{t}_0 = \\mathbf{0}$ 处求值：\n$$\nJ_{i\\ell}(\\mathbf{0}) = \\frac{1}{\\Delta_i} \\left( A_{i\\ell} + 2 \\sum_{k=1}^{n} Q_{i\\ell k} \\cdot 0 \\right) = \\frac{A_{i\\ell}}{\\Delta_i}\n$$\n用矩阵表示法，原点处的雅可比矩阵是：\n$$\n\\mathbf{J}(\\mathbf{0}) = \\mathrm{diag}(\\boldsymbol{\\Delta})^{-1} \\mathbf{A}\n$$\n其中 $\\mathrm{diag}(\\boldsymbol{\\Delta})^{-1}$ 是对角元素为 $1/\\Delta_i$ 的对角矩阵。\n\n### 步骤2：特征值和特征向量的确定\n\n问题为矩阵 $\\mathbf{A}$ 提供了一个特定的构造方法：\n$$\n\\mathbf{A} \\equiv \\mathrm{diag}(\\boldsymbol{\\Delta}) \\, \\mathbf{U} \\, \\mathrm{diag}(\\boldsymbol{\\lambda}) \\, \\mathbf{U}^{\\top}\n$$\n将此代入 $\\mathbf{J}(\\mathbf{0})$ 的表达式中：\n$$\n\\mathbf{J}(\\mathbf{0}) = \\mathrm{diag}(\\boldsymbol{\\Delta})^{-1} \\left( \\mathrm{diag}(\\boldsymbol{\\Delta}) \\, \\mathbf{U} \\, \\mathrm{diag}(\\boldsymbol{\\lambda}) \\, \\mathbf{U}^{\\top} \\right)\n$$\n矩阵乘法是结合的，并且 $\\mathrm{diag}(\\boldsymbol{\\Delta})^{-1} \\mathrm{diag}(\\boldsymbol{\\Delta}) = \\mathbf{I}$，即单位矩阵。因此，表达式简化为：\n$$\n\\mathbf{J}(\\mathbf{0}) = \\mathbf{U} \\, \\mathrm{diag}(\\boldsymbol{\\lambda}) \\, \\mathbf{U}^{\\top}\n$$\n这是一个可对角化矩阵的特征分解的标准形式。$\\mathbf{J}(\\mathbf{0})$ 的特征值是 $\\mathrm{diag}(\\boldsymbol{\\lambda})$ 的对角元素，这正是向量 $\\boldsymbol{\\lambda}$ 的分量。相应的归一化特征向量是正交矩阵 $\\mathbf{U}$ 的列。\n\n### 步骤3：测试用例的参数计算\n\n对于每个用例，我们计算谱半径 $\\rho = \\max_i |\\lambda_i|$ 和谱隙 $\\delta = \\rho - \\max_{i \\neq i_\\star} |\\lambda_i|$，其中 $|\\lambda_{i_\\star}|=\\rho$。然后我们使用提供的公式和常数计算参数 $m$ 和 $\\beta$：$\\alpha = 2.0$, $\\varepsilon = 10^{-9}$, $m_{\\min} = 2$, $m_{\\max} = 6$, $\\beta_{\\min} = 0.05$, $\\beta_{\\max} = 1.0$。\n\n**用例1：**\n- 特征值：$\\boldsymbol{\\lambda}^{(1)} = [0.2, 0.1, 0.05, 0.01]$。\n- 模：$[0.2, 0.1, 0.05, 0.01]$。\n- 谱半径：$\\rho_1 = 0.2$。\n- 谱隙：$\\delta_1 = 0.2 - 0.1 = 0.1$。\n- 历史长度 $m_1$：\n  $m_{\\mathrm{raw},1} = 1 + \\alpha \\frac{\\rho_1}{\\delta_1 + \\varepsilon} = 1 + 2.0 \\frac{0.2}{0.1 + 10^{-9}} \\approx 5.0$。\n  $m_1 = \\mathrm{round}(\\min(\\max(5.0, 2), 6)) = \\mathrm{round}(5.0) = 5$。\n- 阻尼因子 $\\beta_1$：因为 $\\rho_1 = 0.2  1$：\n  $\\beta_{\\mathrm{raw},1} = 1 - 0.5\\rho_1 - 0.25\\delta_1 = 1 - 0.5(0.2) - 0.25(0.1) = 1 - 0.1 - 0.025 = 0.875$。\n  $\\beta_1 = \\min(\\max(0.875, 0.05), 1.0) = 0.875$。\n- 结果1：$[\\rho_1, \\delta_1, m_1, \\beta_1] = [0.200000, 0.100000, 5, 0.875000]$。\n\n**用例2：**\n- 特征值：$\\boldsymbol{\\lambda}^{(2)} = [0.92, 0.90, 0.3, 0.1]$。\n- 模：$[0.92, 0.90, 0.3, 0.1]$。\n- 谱半径：$\\rho_2 = 0.92$。\n- 谱隙：$\\delta_2 = 0.92 - 0.90 = 0.02$。\n- 历史长度 $m_2$：\n  $m_{\\mathrm{raw},2} = 1 + \\alpha \\frac{\\rho_2}{\\delta_2 + \\varepsilon} = 1 + 2.0 \\frac{0.92}{0.02 + 10^{-9}} \\approx 93.0$。\n  $m_2 = \\mathrm{round}(\\min(\\max(93.0, 2), 6)) = \\mathrm{round}(6.0) = 6$。\n- 阻尼因子 $\\beta_2$：因为 $\\rho_2 = 0.92  1$：\n  $\\beta_{\\mathrm{raw},2} = 1 - 0.5\\rho_2 - 0.25\\delta_2 = 1 - 0.5(0.92) - 0.25(0.02) = 1 - 0.46 - 0.005 = 0.535$。\n  $\\beta_2 = \\min(\\max(0.535, 0.05), 1.0) = 0.535$。\n- 结果2：$[\\rho_2, \\delta_2, m_2, \\beta_2] = [0.920000, 0.020000, 6, 0.535000]$。\n\n**用例3：**\n- 特征值：$\\boldsymbol{\\lambda}^{(3)} = [1.05, 0.95, 0.4, 0.1]$。\n- 模：$[1.05, 0.95, 0.4, 0.1]$。\n- 谱半径：$\\rho_3 = 1.05$。\n- 谱隙：$\\delta_3 = 1.05 - 0.95 = 0.1$。\n- 历史长度 $m_3$：\n  $m_{\\mathrm{raw},3} = 1 + \\alpha \\frac{\\rho_3}{\\delta_3 + \\varepsilon} = 1 + 2.0 \\frac{1.05}{0.1 + 10^{-9}} \\approx 22.0$。\n  $m_3 = \\mathrm{round}(\\min(\\max(22.0, 2), 6)) = \\mathrm{round}(6.0) = 6$。\n- 阻尼因子 $\\beta_3$：因为 $\\rho_3 = 1.05 \\ge 1$：\n  $\\beta_{\\mathrm{raw},3} = \\frac{1}{1+\\rho_3} = \\frac{1}{1+1.05} = \\frac{1}{2.05} \\approx 0.487804878$。\n  $\\beta_3 = \\min(\\max(0.487804878, 0.05), 1.0) \\approx 0.487805$。\n- 结果3：$[\\rho_3, \\delta_3, m_3, \\beta_3] = [1.050000, 0.100000, 6, 0.487805]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Anderson acceleration parameters based on spectral properties of\n    a simplified Coupled-Cluster Doubles Jacobian.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Eigenvalue spectrum lambda^(1)\n        np.array([0.2, 0.1, 0.05, 0.01]),\n        # Case 2: Eigenvalue spectrum lambda^(2)\n        np.array([0.92, 0.90, 0.3, 0.1]),\n        # Case 3: Eigenvalue spectrum lambda^(3)\n        np.array([1.05, 0.95, 0.4, 0.1]),\n    ]\n\n    # Define Anderson tuning constants and bounds.\n    alpha = 2.0\n    epsilon = 1e-9\n    m_min = 2\n    m_max = 6\n    beta_min = 0.05\n    beta_max = 1.0\n\n    all_results = []\n    for case_lambdas in test_cases:\n        # Main logic to calculate the result for one case goes here.\n\n        # Step 1: Compute spectral radius (rho) and spectral gap (delta).\n        # The eigenvalues of J(0) are given directly by the case_lambdas vector.\n        abs_lambdas = np.abs(case_lambdas)\n        sorted_abs_lambdas = np.sort(abs_lambdas)[::-1]  # Sort in descending order\n\n        rho = sorted_abs_lambdas[0]\n        # The problem definition of delta assumes a unique maximum magnitude,\n        # which holds for all test cases.\n        delta = rho - sorted_abs_lambdas[1]\n\n        # Step 2: Compute the history length 'm'.\n        m_raw = 1 + alpha * rho / (delta + epsilon)\n        # Apply bounds [m_min, m_max].\n        m_bounded = np.minimum(np.maximum(m_raw, m_min), m_max)\n        # Round to the nearest integer.\n        m = int(np.round(m_bounded))\n\n        # Step 3: Compute the damping factor 'beta'.\n        if rho  1:\n            beta_raw = 1 - 0.5 * rho - 0.25 * delta\n        else:  # rho >= 1\n            beta_raw = 1 / (1 + rho)\n        # Apply bounds [beta_min, beta_max].\n        beta = np.minimum(np.maximum(beta_raw, beta_min), beta_max)\n\n        # Store the results for the current case.\n        result = [rho, delta, m, beta]\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output must be a single line containing a comma-separated list of lists.\n    # rho, delta, and beta must have exactly 6 digits after the decimal point.\n    # m must be an integer.\n    # No spaces are allowed in the final output string.\n    output_parts = []\n    for res in all_results:\n        rho_val, delta_val, m_val, beta_val = res\n        part = f\"[{rho_val:.6f},{delta_val:.6f},{m_val},{beta_val:.6f}]\"\n        output_parts.append(part)\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}