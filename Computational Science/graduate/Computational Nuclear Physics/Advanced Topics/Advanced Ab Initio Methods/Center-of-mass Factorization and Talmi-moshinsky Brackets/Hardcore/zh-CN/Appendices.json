{
    "hands_on_practices": [
        {
            "introduction": "本章的第一个实践旨在为我们打下坚实的基础。我们将为简单但重要的 $s$-波情形推导 Talmi-Moshinsky (TM) 变换系数，然后通过数值计算来验证其正交性。这项练习将加深我们对抽象算符代数与具体计算实现之间联系的理解。",
            "id": "3549194",
            "problem": "你的任务是，在两个等质量粒子处于各向同性谐振子中的特殊情况下，推导、实现并数值验证 Talmi-Moshinsky (TM) 变换矩阵的正交性和完备性关系，并限制在总轨道角动量为零的扇区（也称为 s 波扇区）。TM 变换将双粒子的单粒子基与相对运动和质心 (COM) 运动基联系起来。在 s 波扇区，该变换保持振子量子总数不变，并由量子数 $(n,l,N,L)$ 表征，满足约束条件 $2n + l + 2N + L = N_{\\text{tot}}$。\n\n从以下符合本文背景的基本出发点开始：\n- 具有相等质量和相同振子频率的双粒子各向同性谐振子哈密顿量 $H = H_1 + H_2$，在正交坐标变换 $\\boldsymbol{r} = (\\boldsymbol{r}_1 - \\boldsymbol{r}_2)/\\sqrt{2}$ 和 $\\boldsymbol{R} = (\\boldsymbol{r}_1 + \\boldsymbol{r}_2)/\\sqrt{2}$ 下，可分离为相对运动和质心运动部分，其相关的升降算符 $a_r = (a_1 - a_2)/\\sqrt{2}$ 和 $a_R = (a_1 + a_2)/\\sqrt{2}$ 也同样如此。\n- 在 s 波扇区（总轨道角动量为零），基态分别由相对运动和质心运动扇区的径向量子数 $n$ 和 $N$ 表征，且 $l=L=0$。能量量子数守恒条件变为 $2n + 2N = N_{\\text{tot}}$，因此在该扇区中 $N_{\\text{tot}}$ 必须为偶数。\n\n你的目标是：\n1. 在 s 波扇区，对于固定的 $N_{\\text{tot}} = 2n + 2N = 2n_1 + 2n_2$，从升降算符关系推导出单粒子数态基 $\\{|n_1, n_2\\rangle\\}$ 和相对/质心数态基 $\\{|n, N\\rangle\\}$ 之间的显式线性变换系数。证明这些系数源于正交变量变换，因此在固定 $N_{\\text{tot}}$ 的子空间上是幺正的。\n2. 实现一个数值程序，用于在给定的偶数 $N_{\\text{tot}}$ 下构建 s 波扇区的 TM 变换矩阵 $U$。枚举所有满足 $l=L=0$ 和 $2n + 2N = N_{\\text{tot}}$ 的允许组合 $(n,l,N,L)$，以及所有满足 $2n_1 + 2n_2 = N_{\\text{tot}}$ 的对应单粒子对 $(n_1, n_2)$。矩阵 $U$ 必须在固定的 $N_{\\text{tot}}$ 下将相对/质心基映射到单粒子基。\n3. 通过计算 $U^\\dagger U$ 并检查其在 $10^{-12}$ 的绝对容差范围内是否等于单位矩阵 $\\mathbb{1}$，从而数值验证其正交性和完备性。\n\n约束和规范：\n- 限制在 s 波扇区，即 $l = L = 0$，因此 $N_{\\text{tot}}$ 必须为偶数。枚举所有满足 $2n + 2N = N_{\\text{tot}}$ 的允许 $(n,N)$ 对。\n- 推导并使用一个由玻色子升降算符恒等式和二项式展开得出的变换系数公式。不要假定任何预先推导的 TM 括号表。\n- 最终的数值验证中不出现物理单位；所有计算都是谐振子代数下的纯无量纲重叠。\n- 测试套件包含以下 $N_{\\text{tot}}$ 的值：$0$、$2$、$4$ 和 $6$。对于每种情况，构建 $U$，计算 $U^\\dagger U$，并检查与单位矩阵的最大绝对偏差。每个测试用例的结果必须是一个布尔值，表示 $U^\\dagger U$ 是否在 $10^{-12}$ 的容差范围内等于 $\\mathbb{1}$。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），每个结果是一个布尔值，按 $N_{\\text{tot}} = 0, 2, 4, 6$ 的顺序对应一个测试用例。",
            "solution": "该问题要求推导、实现并验证 Talmi-Moshinsky (TM) 变换，针对一个特殊情况：两个等质量粒子处于各向同性谐振子中，并限制在总轨道角动量为零的 s 波扇区。\n\n该变换将单粒子 (SP) 基（表示为 $|n_1, l_1=0; n_2, l_2=0\\rangle$）与相对运动和质心 (COM) 基（表示为 $|n, l=0; N, L=0\\rangle$）联系起来。量子数 $n_1, n_2, n, N$ 是径向量子数。为简单起见，我们将这些态缩写为 $|n_1, n_2\\rangle$ 和 $|n, N\\rangle$。振子量子总数 $N_{\\text{tot}}$ 是一个守恒量。对于 s 波态，能量与 $2n_{rad} + 3/2$ 成正比，因此量子数为 $2n_{rad}$。守恒条件因此为 $N_{\\text{tot}} = 2n_1 + 2n_2 = 2n + 2N$，这意味着 $N_{\\text_tot}$ 必须为偶数。令 $M = N_{\\text{tot}}/2$。守恒定律简化为 $M = n_1 + n_2 = n + N$。这种数学结构与一维谐振子中的双粒子系统相同，其中 $M$ 是量子总数。因此，正如所提供的升降算符关系所建议的，推导将使用一维谐振子的形式体系进行。\n\n变换矩阵 $U$ 将一个正交归一基映射到另一个正交归一基，因此是幺正的。由于系数是实数，它是一个正交矩阵，满足 $U^\\dagger U = U^T U = \\mathbb{1}$。$U$ 的矩阵元是重叠积分，或称为 Talmi-Moshinsky 括号，$U_{ij} = \\langle \\text{sp}_i | \\text{rel-COM}_j \\rangle$。问题指明 $U$ 将相对-质心基映射到单粒子基，即 $|\\text{sp}_i\\rangle = \\sum_j U_{ij} |\\text{rel-COM}_j\\rangle$。这意味着 $U_{ij} = \\langle \\text{rel-COM}_j | \\text{sp}_i \\rangle$。我们让索引 $i$ 对应于 $n_1=i$（因此 $n_2=M-i$）的单粒子态，索引 $j$ 对应于 $n=j$（且 $N=M-j$）的相对-质心态，其中 $i,j \\in \\{0, 1, \\dots, M\\}$。\n\n推导从升降算符之间的关系开始。从单粒子坐标 $(\\boldsymbol{r}_1, \\boldsymbol{r}_2)$到相对/质心坐标 $(\\boldsymbol{r}, \\boldsymbol{R})$的变换是正交的。这导致了产生和湮灭算符的相应正交变换。对于一维情况：\n$$ a_r^\\dagger = \\frac{1}{\\sqrt{2}}(a_1^\\dagger - a_2^\\dagger) \\quad ; \\quad a_R^\\dagger = \\frac{1}{\\sqrt{2}}(a_1^\\dagger + a_2^\\dagger) $$\n逆变换为：\n$$ a_1^\\dagger = \\frac{1}{\\sqrt{2}}(a_R^\\dagger + a_r^\\dagger) \\quad ; \\quad a_2^\\dagger = \\frac{1}{\\sqrt{2}}(a_R^\\dagger - a_r^\\dagger) $$\nSP 基中的一个态是通过将这些产生算符作用于真空态 $|0,0\\rangle$ 来构造的：\n$$ |n_1, n_2\\rangle = \\frac{(a_1^\\dagger)^{n_1}}{\\sqrt{n_1!}} \\frac{(a_2^\\dagger)^{n_2}}{\\sqrt{n_2!}} |0,0\\rangle $$\n代入 $a_1^\\dagger$ 和 $a_2^\\dagger$ 的表达式：\n$$ |n_1, n_2\\rangle = \\frac{1}{\\sqrt{n_1!n_2!}} \\left( \\frac{a_R^\\dagger + a_r^\\dagger}{\\sqrt{2}} \\right)^{n_1} \\left( \\frac{a_R^\\dagger - a_r^\\dagger}{\\sqrt{2}} \\right)^{n_2} |0,0\\rangle $$\n由于相对运动和质心运动算符作用于独立的空间，因此 $[a_r^\\dagger, a_R^\\dagger] = 0$。我们可以使用二项式定理来展开这些项：\n$$ |n_1, n_2\\rangle = \\frac{1}{\\sqrt{n_1!n_2!}} \\frac{1}{2^{(n_1+n_2)/2}} \\left( \\sum_{k_1=0}^{n_1} \\binom{n_1}{k_1} (a_R^\\dagger)^{n_1-k_1} (a_r^\\dagger)^{k_1} \\right) \\left( \\sum_{k_2=0}^{n_2} \\binom{n_2}{k_2} (a_R^\\dagger)^{n_2-k_2} (-a_r^\\dagger)^{k_2} \\right) |0,0\\rangle $$\n合并求和并重新排列各项：\n$$ |n_1, n_2\\rangle = \\frac{1}{\\sqrt{n_1!n_2!}} \\frac{1}{2^{M/2}} \\sum_{k_1=0}^{n_1} \\sum_{k_2=0}^{n_2} \\binom{n_1}{k_1} \\binom{n_2}{k_2} (-1)^{k_2} (a_R^\\dagger)^{n_1+n_2-k_1-k_2} (a_r^\\dagger)^{k_1+k_2} |0,0\\rangle $$\n我们希望将其表示为相对-质心基态 $|n, N\\rangle = \\frac{(a_r^\\dagger)^n}{\\sqrt{n!}} \\frac{(a_R^\\dagger)^N}{\\sqrt{N!}}|0,0\\rangle$ 的叠加。这意味着我们识别出 $n = k_1+k_2$ 和 $N = n_1+n_2-k_1-k_2 = M-n$。未归一化的态是 $(a_R^\\dagger)^N (a_r^\\dagger)^n |0,0\\rangle = \\sqrt{n!N!} |n,N\\rangle$。\n$$ |n_1, n_2\\rangle = \\frac{1}{\\sqrt{n_1!n_2!}} \\frac{1}{2^{M/2}} \\sum_{n=0}^{M} \\left( \\sum_{\\substack{k_1+k_2=n \\\\ 0\\le k_1 \\le n_1 \\\\ 0\\le k_2 \\le n_2}} \\binom{n_1}{k_1} \\binom{n_2}{k_2} (-1)^{k_2} \\right) \\sqrt{n!(M-n)!} |n, M-n\\rangle $$\n此展开式中 $|n, N\\rangle$ 的系数是 TM 括号 $\\langle n, N | n_1, n_2 \\rangle$。设 $k_2 = n-k_1$，则求和是关于 $k_1$ 的。$k_1$ 的求和极限是 $\\max(0, n-n_2) \\le k_1 \\le \\min(n, n_1)$。\n$$ \\langle n, N | n_1, n_2 \\rangle = \\frac{\\sqrt{n!N!}}{\\sqrt{n_1!n_2!}} \\frac{1}{2^{M/2}} \\sum_{k_1=\\max(0,n-n_2)}^{\\min(n,n_1)} \\binom{n_1}{k_1} \\binom{n_2}{n-k_1} (-1)^{n-k_1} $$\n这就是变换系数的公式，其中 $n_1+n_2=n+N=M$。\n\n为了在数值上实现这一点，我们为给定的 $N_{\\text{tot}} = 2M$ 构建一个 $(M+1) \\times (M+1)$ 的矩阵 $U$。行由 $i=n_1 \\in \\{0, \\dots, M\\}$ 索引，列由 $j=n \\in \\{0, \\dots, M\\}$ 索引。\n矩阵元 $U_{ij} = \\langle n=j, N=M-j | n_1=i, n_2=M-i \\rangle$ 为：\n$$ U_{ij} = \\frac{\\sqrt{j!(M-j)!}}{\\sqrt{i!(M-i)!}} \\frac{1}{2^{M/2}} \\sum_{k=\\max(0,i+j-M)}^{\\min(i,j)} (-1)^{j-k} \\binom{i}{k} \\binom{M-i}{j-k} $$\n算法如下：\n1. 对于测试套件 $\\{0, 2, 4, 6\\}$ 中的每个 $N_{\\text{tot}}$，计算 $M=N_{\\text{tot}}/2$。\n2. 创建一个 $(M+1) \\times (M+1)$ 的矩阵 $U$。\n3. 对于每一行 $i \\in \\{0, \\dots, M\\}$ 和每一列 $j \\in \\{0, \\dots, M\\}$，使用推导出的公式计算矩阵元 $U_{ij}$。阶乘和二项式系数使用 `scipy.special` 计算。\n4. 构建 $U$ 后，计算乘积 $P = U^T U$。由于 $U$ 是实数矩阵，$U^\\dagger = U^T$。\n5. 计算 $P$ 与相同维度的单位矩阵 $\\mathbb{1}$ 之间的最大绝对差：$\\max(|\\mathbb{1} - P|)$。\n6. 如果此差值小于容差 $10^{-12}$，则该 $N_{\\text{tot}}$ 的验证成功 (True)，否则失败 (False)。\n7. 收集所有测试用例的布尔结果，并按规定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import factorial, binom\n\ndef calculate_tm_matrix(M: int) -> np.ndarray:\n    \"\"\"\n    Constructs the Talmi-Moshinsky transformation matrix for the s-wave sector.\n\n    Args:\n        M: The total number of oscillator quanta pairs, M = N_tot / 2.\n\n    Returns:\n        The (M+1)x(M+1) Talmi-Moshinsky transformation matrix U.\n        The element U_ij =\n```"
        },
        {
            "introduction": "掌握了 TM 变换这一工具后，我们现在将其应用于多体计算中的一个关键问题：伪质心运动。这项实践将演示不同的基截断方案如何无意中破坏内部运动与质心运动的因子化，以及 TM 变换括号如何让我们量化这种污染。",
            "id": "3549211",
            "problem": "你需要在一个由两个相同粒子组成的一维（$1$D）谐振子模型中，通过在不同的基截断下进行操作，来研究质心因子分解。使用 $1$D 设置是为了使 Talmi-Moshinsky 变换精确且计算轻量化，同时保留质心因子分解与截断赝象之间同样在三维中出现的基本逻辑。\n\n定义单粒子谐振子数态 $\\lvert n_1 \\rangle \\otimes \\lvert n_2 \\rangle$，其中 $n_1$ 和 $n_2$ 为非负整数，并定义相对与质心（c.m.）振子数态 $\\lvert n \\rangle_{\\text{rel}} \\otimes \\lvert N \\rangle_{\\text{cm}}$，其中 $n$ 和 $N$ 也为非负整数。在这种 $1$D 设置中，Talmi-Moshinsky 变换是由产生算符的线性模式旋转引起的幺正基变换，\n$$\na_{\\text{r}}^\\dagger = \\frac{a_1^\\dagger - a_2^\\dagger}{\\sqrt{2}}, \\quad\na_{\\text{c}}^\\dagger = \\frac{a_1^\\dagger + a_2^\\dagger}{\\sqrt{2}},\n$$\n它在双粒子单粒子基与相对/质心基之间进行映射。这些基之间的重叠（即 $1$D Talmi-Moshinsky 括号）为\n$$\n\\langle n, N \\vert n_1, n_2 \\rangle \\equiv U(n_1,n_2;n,N) =\n2^{-\\frac{n_1+n_2}{2}}\n\\sqrt{\\frac{n!\\,N!}{n_1!\\,n_2!}}\n\\sum_{k=k_{\\min}}^{k_{\\max}}\n\\binom{n_1}{k}\\binom{n_2}{n-k}(-1)^{n-k},\n$$\n受选择定则 $n+N=n_1+n_2$ 的约束，且 $k_{\\min}=\\max(0,n-n_2)$ 和 $k_{\\max}=\\min(n,n_1)$。所有阶乘和二项式系数都采用它们对非负整数的标准定义，该变换在无限空间中是正交归一的。\n\n考虑一个目标内禀（仅相对坐标）态，它与处于振子基态的质心精确因子分解，\n$$\n\\lvert \\Psi \\rangle = \\left(\\sum_{n=0}^{n_{\\max}} c_n \\,\\lvert n \\rangle_{\\text{rel}}\\right) \\otimes \\lvert 0 \\rangle_{\\text{cm}},\n$$\n其中 $c_n \\in \\mathbb{R}$ 且 $\\sum_{n=0}^{n_{\\max}} c_n^2 = 1$。在完整的、未截断的空间中，该态具有精确的质心因子分解，质心位于 $0s$ 子空间（$N=0$）。在单粒子基中，幅为\n$$\nA(n_1,n_2) = \\sum_{n=0}^{n_{\\max}} c_n \\, U(n_1,n_2;n,0),\n$$\n且无限空间变换保证质心坐标中的分布精确保持为 $N=0$。\n\n现在，在单粒子空间中施加基截断，并通过丢弃截断之外的基分量来形成截断态：\n- 单粒子截断 $e_{\\max}$：仅保留满足 $n_1 \\leq n_{\\max}^{\\text{sp}}$ 和 $n_2 \\leq n_{\\max}^{\\text{sp}}$ 的分量，其中 $n_{\\max}^{\\text{sp}}$ 是允许的最大单粒子振子量子数。这是一维中单粒子 $e_{\\max}$ 截断的类似物。\n- 总量子数截断 $N_{\\max}$：仅保留满足 $n_1 + n_2 \\leq N_{\\max}$ 的分量。这是一维中无核芯壳模型 $N_{\\max}$ 截断的类似物。\n\n设截断的、归一化的双粒子态为\n$$\n\\lvert \\Psi_{\\text{tr}} \\rangle = \\frac{1}{\\sqrt{\\mathcal{N}}} \\sum_{\\text{kept }(n_1,n_2)} A(n_1,n_2) \\, \\lvert n_1,n_2 \\rangle,\n\\quad \\text{其中} \\quad\n\\mathcal{N} = \\sum_{\\text{kept }(n_1,n_2)} \\left|A(n_1,n_2)\\right|^2.\n$$\n将此截断态投影回相对与质心基，以获得幅\n$$\nB(n,N) = \\sum_{\\text{kept }(n_1,n_2)} U(n_1,n_2;n,N)\\,\\frac{A(n_1,n_2)}{\\sqrt{\\mathcal{N}}},\n$$\n并将处于质心振子量子数 $N$ 的概率定义为\n$$\nP(N) = \\sum_{n=0}^{S_{\\max}} \\left| B(n,N) \\right|^2,\n$$\n其中 $S_{\\max}$ 是 $n+N$ 的任何整数上界，该上界至少与所保留的 $(n_1,n_2)$ 对中的最大 $n_1+n_2$ 一样大。最后，通过以下方式量化质心因子分解：\n- 质心量子数的期望值，\n$$\n\\langle N_{\\text{cm}} \\rangle = \\sum_{N=0}^{S_{\\max}} N \\, P(N),\n$$\n- 与 $0s$ 质心子空间的重叠，\n$$\n\\mathcal{O}_{0s} = P(0).\n$$\n\n你的任务是实现一个程序，精确地构造上述变换，应用指定的截断，并为每个测试用例计算 $\\langle N_{\\text{cm}} \\rangle$ 和 $\\mathcal{O}_{0s}$。所有量均为无量纲。不使用角度。不需要物理单位。\n\n实现以下测试套件。在所有情况下，输入的内禀态系数 $\\{c_n\\}$ 均已明确指定，并且在使用前必须重新归一化以满足 $\\sum_n c_n^2 = 1$。\n- 测试用例 1（基准 $N_{\\max}$ 因子分解）：截断类型 $N_{\\max}$，其中 $N_{\\max}=3$；对于 $n=0,1,2,3$，系数分别为 $[1.0,\\,0.7,\\,0.5,\\,0.2]$。\n- 测试用例 2（单粒子 $e_{\\max}$ 破坏）：截断类型为单粒子，其中 $n_{\\max}^{\\text{sp}}=1$；系数与测试用例 1 相同。\n- 测试用例 3（单粒子大 $e_{\\max}$ 恢复因子分解）：截断类型为单粒子，其中 $n_{\\max}^{\\text{sp}}=3$；系数与测试用例 1 相同。\n- 测试用例 4（小 $N_{\\max}$ 截断移除较高内禀分量但保持质心）：截断类型 $N_{\\max}$，其中 $N_{\\max}=1$；系数与测试用例 1 相同。\n- 测试用例 5（具有单个内禀激发的边缘情况）：截断类型为单粒子，其中 $n_{\\max}^{\\text{sp}}=1$；对于 $n=0,1,2$，系数分别为 $[0.0,\\,0.0,\\,1.0]$。\n\n你的程序必须：\n- 使用所述公式精确构造 $U(n_1,n_2;n,N)$。\n- 从内禀系数和 $U(n_1,n_2;n,0)$ 构建 $A(n_1,n_2)$。\n- 应用指定的截断。\n- 归一化并投影回去获得 $B(n,N)$，然后计算 $\\langle N_{\\text{cm}} \\rangle$ 和 $\\mathcal{O}_{0s}$。\n\n最终输出格式：你的程序应生成一行输出，其中包含所有测试用例的展平的实数列表，顺序为\n$$\n\\big[\\langle N_{\\text{cm}}\\rangle_1,\\ \\mathcal{O}_{0s,1},\\ \\langle N_{\\text{cm}}\\rangle_2,\\ \\mathcal{O}_{0s,2},\\ \\ldots,\\ \\langle N_{\\text{cm}}\\rangle_5,\\ \\mathcal{O}_{0s,5}\\big].\n$$\n例如，一个包含三个测试用例的结果将如下所示：$\\big[0.0,1.0,\\,0.375,0.8125,\\,0.0,1.0\\big]$。你的程序不能读取任何输入，也不能打印任何其他内容。",
            "solution": "用户提供的问题已经过严格验证，并被确定为 **有效**。它在科学上是合理的、适定的和客观的，提出了一个计算核物理中清晰且可形式化的任务。该问题探讨了基截断对两粒子系统质心（c.m.）和相对运动因子分解的后果，这是核结构理论中的一个基本概念。\n\n该解答从第一性原理出发，实现了所必需的变换和计算。\n\n**1. Talmi-Moshinsky 变换**\n\n问题定义在一个一维、双粒子谐振子系统中。双粒子态可以用两个等效的基来描述：单粒子（s.p.）基 $\\lvert n_1, n_2 \\rangle = \\lvert n_1 \\rangle \\otimes \\lvert n_2 \\rangle$，以及相对/质心基 $\\lvert n, N \\rangle = \\lvert n \\rangle_{\\text{rel}} \\otimes \\lvert N \\rangle_{\\text{cm}}$。这里，$n_1, n_2, n, N$ 是非负整数量子数。\n\n这些基之间的变换由 Talmi-Moshinsky 括号（TMB）给出，$U(n_1,n_2;n,N) = \\langle n, N \\vert n_1, n_2 \\rangle$。提供的公式为：\n$$\nU(n_1,n_2;n,N) = 2^{-\\frac{n_1+n_2}{2}} \\sqrt{\\frac{n!\\,N!}{n_1!\\,n_2!}} \\sum_{k=k_{\\min}}^{k_{\\max}} \\binom{n_1}{k}\\binom{n_2}{n-k}(-1)^{n-k}\n$$\n仅当总振子量子数守恒时，即满足选择定则 $n_1+n_2 = n+N$ 时，此变换才非零。求和极限为 $k_{\\min}=\\max(0,n-n_2)$ 和 $k_{\\max}=\\min(n,n_1)$。将实现一个函数来计算此括号，利用数值库精确计算阶乘和二项式系数。由于对相同参数的重复调用，此函数将进行记忆化处理以提高计算效率。\n\n**2. 态的构建与初始变换**\n\n目标态 $\\lvert \\Psi \\rangle$ 被定义为完美因子分解的，其质心处于基态（$N=0$）：\n$$\n\\lvert \\Psi \\rangle = \\left(\\sum_{n=0}^{n_{\\max}} c_n \\,\\lvert n \\rangle_{\\text{rel}}\\right) \\otimes \\lvert 0 \\rangle_{\\text{cm}}\n$$\n所提供的系数 $\\{c_n\\}$ 首先被归一化，使得 $\\sum_{n=0}^{n_{\\max}} c_n^2 = 1$。\n\n为了分析单粒子基中截断的效应，我们首先用此基表示 $\\lvert \\Psi \\rangle$。幅 $A(n_1,n_2) = \\langle n_1, n_2 \\vert \\Psi \\rangle$ 由下式给出：\n$$\nA(n_1,n_2) = \\sum_{n=0}^{n_{\\max}} c_n \\, \\langle n_1, n_2 \\vert n, 0 \\rangle = \\sum_{n=0}^{n_{\\max}} c_n \\, U(n_1,n_2;n,0)\n$$\n根据选择定则 $n_1+n_2=n+N$，仅当 $n = n_1+n_2$ 时，$U(n_1,n_2;n,0)$ 项才非零。这将求和简化为单项。如果 $n_1+n_2 \\le n_{\\max}$，则幅为：\n$$\nA(n_1,n_2) = c_{n_1+n_2} \\, U(n_1,n_2; n_1+n_2, 0)\n$$\n如果 $n_1+n_2 > n_{\\max}$，则 $A(n_1,n_2) = 0$。\n\n**3. 基截断与重新归一化**\n\n接下来，对单粒子基施加截断。考虑了两种方案：\n- **总量子数截断（$N_{\\max}$）**：仅保留满足 $n_1 + n_2 \\leq N_{\\max}$ 的基态 $\\lvert n_1, n_2 \\rangle$。\n- **单粒子截断（$e_{\\max}$）**：仅保留同时满足 $n_1 \\leq n_{\\max}^{\\text{sp}}$ 和 $n_2 \\leq n_{\\max}^{\\text{sp}}$ 的基态 $\\lvert n_1, n_2 \\rangle$。\n\n在丢弃截断窗口之外的基态后，得到的态不再是归一化的。截断态 $\\lvert \\Psi_{\\text{tr}} \\rangle$ 是通过对“保留的”对 $(n_1,n_2)$ 求和并重新归一化来构建的：\n$$\n\\lvert \\Psi_{\\text{tr}} \\rangle = \\frac{1}{\\sqrt{\\mathcal{N}}} \\sum_{\\text{kept }(n_1,n_2)} A(n_1,n_2) \\, \\lvert n_1,n_2 \\rangle\n$$\n其中归一化常数为 $\\mathcal{N} = \\sum_{\\text{kept }(n_1,n_2)} |A(n_1,n_2)|^2$。\n\n**4. 投影与可观测量计算**\n\n为了量化截断对质心因子分解的影响，将截断态 $\\lvert \\Psi_{\\text{tr}} \\rangle$ 投影回相对/质心基。新的幅 $B(n,N) = \\langle n,N \\vert \\Psi_{\\text{tr}} \\rangle$ 为：\n$$\nB(n,N) = \\frac{1}{\\sqrt{\\mathcal{N}}} \\sum_{\\text{kept }(n_1,n_2)} A(n_1,n_2) \\, \\langle n,N \\vert n_1, n_2 \\rangle = \\frac{1}{\\sqrt{\\mathcal{N}}} \\sum_{\\text{kept }(n_1,n_2)} U(n_1,n_2;n,N)A(n_1,n_2)\n$$\n系统具有 $N$ 个质心激发量子的概率是所有可能相对量子数 $n$ 的幅平方和：\n$$\nP(N) = \\sum_{n=0}^{S_{\\max}} \\left| B(n,N) \\right|^2\n$$\n这里，$S_{\\max}$ 被选为截断空间内 $n_1+n_2$ 的最大可能值，以确保所有有贡献的态都被包括在内。\n\n最后，计算两个关键的可观测量来衡量质心因子分解的程度：\n- 质心激发量子数的期望值：$\\langle N_{\\text{cm}} \\rangle = \\sum_{N=0}^{S_{\\max}} N \\, P(N)$。\n- 与质心基态（$0s$）子空间的重叠：$\\mathcal{O}_{0s} = P(0)$。\n\n对于一个没有质心激发的完美因子分解态，我们会发现 $\\langle N_{\\text{cm}} \\rangle = 0$ 且 $\\mathcal{O}_{0s} = 1$。与这些值的偏差表明基截断引入了赝质心激发。算法将遍历每个测试用例，执行这些计算以产生所需的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb, factorial\nfrom functools import lru_cache\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'type': 'N_max', 'limit': 3, 'coeffs': [1.0, 0.7, 0.5, 0.2]},\n        {'type': 'single-particle', 'limit': 1, 'coeffs': [1.0, 0.7, 0.5, 0.2]},\n        {'type': 'single-particle', 'limit': 3, 'coeffs': [1.0, 0.7, 0.5, 0.2]},\n        {'type': 'N_max', 'limit': 1, 'coeffs': [1.0, 0.7, 0.5, 0.2]},\n        {'type': 'single-particle', 'limit': 1, 'coeffs': [0.0, 0.0, 1.0]}\n    ]\n\n    results = []\n    for case in test_cases:\n        N_cm_exp, O_0s = compute_observables(\n            case['type'], case['limit'], case['coeffs']\n        )\n        results.extend([N_cm_exp, O_0s])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n@lru_cache(maxsize=None)\ndef talmi_moshinsky_bracket(n1, n2, n, N):\n    \"\"\"\n    Computes the 1D Talmi-Moshinsky bracket U(n1, n2; n, N).\n    Memoization is used to cache results for efficiency.\n    \"\"\"\n    if n1 + n2 != n + N:\n        return 0.0\n\n    # quantum numbers are small, direct computation is safe and exact.\n    # Check for impossible arguments for factorials.\n    if any(q  0 for q in [n1, n2, n, N]):\n        return 0.0\n\n    try:\n        # Pre-factor calculation\n        prefactor = (2.0**(-0.5 * (n1 + n2))) * np.sqrt(\n            factorial(n) * factorial(N) / (factorial(n1) * factorial(n2))\n        )\n    except (ValueError, ZeroDivisionError):\n        # Handles cases like factorial of negative or division by zero from factorial(negative)\n        return 0.0\n\n    # Summation part\n    k_min = max(0, n - n2)\n    k_max = min(n, n1)\n\n    sum_val = 0.0\n    for k in range(k_min, k_max + 1):\n        term = comb(n1, k, exact=False) * comb(n2, n - k, exact=False) * ((-1)**(n - k))\n        sum_val += term\n\n    return prefactor * sum_val\n\ndef compute_observables(trunc_type, trunc_limit, coeffs_raw):\n    \"\"\"\n    Performs the full calculation for a single test case.\n    \"\"\"\n    # 1. Normalize initial coefficients\n    coeffs_raw = np.array(coeffs_raw, dtype=float)\n    norm = np.linalg.norm(coeffs_raw)\n    coeffs = coeffs_raw / norm if norm  0 else coeffs_raw\n    n_max_coeffs = len(coeffs) - 1\n\n    # 2. Determine max quanta for this case's loops and generate \"kept\" (n1, n2) pairs\n    if trunc_type == 'N_max':\n        S_max = trunc_limit\n    else:  # single-particle\n        S_max = 2 * trunc_limit\n    \n    kept_pairs = []\n    for n1 in range(S_max + 1):\n        for n2 in range(S_max - n1 + 1):\n            is_kept = False\n            if trunc_type == 'N_max':\n                if n1 + n2 = trunc_limit:\n                    is_kept = True\n            else:  # single-particle\n                if n1 = trunc_limit and n2 = trunc_limit:\n                    is_kept = True\n            \n            if is_kept:\n                kept_pairs.append((n1, n2))\n    \n    # 3. Calculate amplitudes A(n1, n2) and normalization factor N\n    A = {}\n    norm_sq = 0.0\n    \n    for n1, n2 in kept_pairs:\n        total_quanta = n1 + n2\n        if total_quanta  n_max_coeffs:\n            A[(n1, n2)] = 0.0\n        else:\n            u_val = talmi_moshinsky_bracket(n1, n2, total_quanta, 0)\n            A[(n1, n2)] = coeffs[total_quanta] * u_val\n        \n        norm_sq += A[(n1, n2)]**2\n\n    if norm_sq  1e-15:\n        return 0.0, 0.0\n\n    norm_val = np.sqrt(norm_sq)\n\n    # 4. Project back to get B(n,N)\n    B = np.zeros((S_max + 1, S_max + 1), dtype=float)\n    for n_rel in range(S_max + 1):\n        for N_cm in range(S_max - n_rel + 1):\n            b_val = 0.0\n            for n1, n2 in kept_pairs:\n                if (n1, n2) in A:\n                    u_val = talmi_moshinsky_bracket(n1, n2, n_rel, N_cm)\n                    b_val += u_val * A[(n1, n2)]\n            \n            B[n_rel, N_cm] = b_val / norm_val\n\n    # 5. Calculate probabilities P(N)\n    P = np.zeros(S_max + 1, dtype=float)\n    for N_cm in range(S_max + 1):\n        P[N_cm] = np.sum(B[:, N_cm]**2)\n\n    # 6. Compute final observables\n    O_0s = P[0]\n    \n    N_vector = np.arange(S_max + 1)\n    N_cm_exp = np.sum(N_vector * P)\n        \n    return N_cm_exp, O_0s\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "我们最后的实践将此形式体系推广到不等质量粒子系统，例如超核。通过从厄米特多项式的生成函数出发推导 TM 变换括号，我们将能够处理粒子交换对称性被破坏的情形，并分析变换括号的值如何变化。这项练习突显了该方法的多功能性，并加深了我们对其数学基础的理解。",
            "id": "3549238",
            "problem": "考虑一个处于三维各向同性谐振子中的两体系统，其中单粒子坐标解耦为相对坐标和质心坐标。从单粒子坐标到相对坐标和质心坐标的变换，在每个笛卡尔方向上，可以表示为无量纲变量空间中的一次正交旋转。Talmi-Moshinsky (TM) 括号是该基变换的系数，此变换将单粒子谐振子态的乘积转换为相对坐标与质心坐标谐振子态的乘积。在等质量系统中，粒子交换对称性会产生特殊的选择定则，这意味着某些 TM 括号为零。在超核系统中，粒子质量通常不相等，这种不对称性破坏了等质量情况下的某些相消效应。\n\n从以下基本原理和定义出发：\n- 无量纲单粒子坐标定义为 $ \\xi_i = x_i / b_i $，其中 $ x_i $ 是粒子 $ i $ 的粒子坐标，$ b_i = \\sqrt{\\hbar / (m_i \\omega)} $ 是与质量 $ m_i $ 和频率 $ \\omega $ 相关的谐振子长度。\n- 在无量纲坐标的正交变换下，谐振子基中的高斯因子保持不变。\n- 到无量纲质心坐标和相对坐标的正交变换为 $ \\Xi = \\cos \\theta \\, \\xi_1 + \\sin \\theta \\, \\xi_2 $ 和 $ \\varrho = -\\sin \\theta \\, \\xi_1 + \\cos \\theta \\, \\xi_2 $，其中 $ \\cos \\theta = \\sqrt{m_1/(m_1+m_2)} $ 和 $ \\sin \\theta = \\sqrt{m_2/(m_1+m_2)} $，这是从保持正交归一性的质量加权组合中导出的。\n- 物理学家厄米多项式 $ H_n(\\xi) $ 满足生成函数 $ \\exp\\left(-t^2 + 2 t \\xi\\right) = \\sum_{n=0}^{\\infty} H_n(\\xi) \\, t^n / n! $。\n\n任务：\n1. 从厄米多项式的生成函数和上述定义的正交旋转出发，推导连接单粒子谐振子本征态乘積与质心和相对坐标本征态乘積的一维 TM 括号 $ \\mathcal{M}(N,n;n_1,n_2;\\theta) $。证明除非 $ N+n = n_1 + n_2 $，否则该括号为零，并提供一个用二项式和与阶乘表示的 $ \\mathcal{M}(N,n;n_1,n_2;\\theta) $ 的显式表达式。\n2. 将此括号推广到由质量比 $ \\alpha = m_1/m_2 $ 参数化的不等质量情况。用 $ \\alpha $ 明确表示 $ \\cos \\theta $ 和 $ \\sin \\theta $。\n3. 实现一个程序，用于计算给定整数量子数 $ n_1, n_2, N, n $ 和质量比 $ \\alpha $ 下的 $ \\mathcal{M}(N,n;n_1,n_2;\\alpha) $。对二项式系数和阶乘使用精确整数算术，并结合浮点算术计算 $ \\cos \\theta $ 和 $ \\sin \\theta $ 的幂。\n4. 通过将不等质量括号与 $ \\alpha = 1 $ 时对应的等质量值进行比较，量化其与等质量选择定则的偏差。特别地，对于因对称性而在 $ \\alpha = 1 $ 时为零的构型，计算绝对偏差 $ \\delta(\\alpha) = \\left|\\mathcal{M}(N,n;n_1,n_2;\\alpha) - \\mathcal{M}(N,n;n_1,n_2;1)\\right| = \\left|\\mathcal{M}(N,n;n_1,n_2;\\alpha)\\right| $。\n5. 对于固定的 $ n_1, n_2 $，通过检查 $ \\sum_{N=0}^{n_1+n_2} \\left[\\mathcal{M}\\left(N,n_1+n_2-N;n_1,n_2;\\alpha\\right)\\right]^2 = 1 $ 是否在数值容差范围内成立，来验证其正交归一性。这表示了两个基之间旋转的幺正性。\n\n使用以下测试套件来验证您的实现和分析。这些案例包括等质量对称性检查、超核的实际质量比、极端质量比以及一个违反选择定則的边界情况。对于每个测试用例，计算所述的括号 $ \\mathcal{M} $ 和偏差 $ \\delta $。\n\n- 测试用例 1 (等质量对称性相消，正常路径)：$ \\alpha = 1.0 $，$ n_1 = 1 $，$ n_2 = 1 $，$ N = 1 $，$ n = 1 $。报告 $ \\mathcal{M} $、$ \\delta $ 以及选择定则 $ N+n = n_1+n_2 $ 是否满足（布尔值）。\n- 测试用例 2 (实际超核质量比)：$ \\alpha = 1.19 $，$ n_1 = 1 $，$ n_2 = 1 $，$ N = 1 $，$ n = 1 $。报告 $ \\mathcal{M} $、$ \\delta $ 和选择定则布尔值。\n- 测试用例 3 (极端质量比)：$ \\alpha = 10.0 $，$ n_1 = 1 $，$ n_2 = 1 $，$ N = 1 $，$ n = 1 $。报告 $ \\mathcal{M} $、$ \\delta $ 和选择定则布尔值。\n- 测试用例 4 (另一个等质量对称性相消)：$ \\alpha = 1.0 $，$ n_1 = 2 $，$ n_2 = 2 $，$ N = 3 $，$ n = 1 $。报告 $ \\mathcal{M} $、$ \\delta $ 和选择定则布尔值。\n- 测试用例 5 (不等质量破坏相消)：$ \\alpha = 1.19 $，$ n_1 = 2 $，$ n_2 = 2 $，$ N = 3 $，$ n = 1 $。报告 $ \\mathcal{M} $、$ \\delta $ 和选择定则布尔值。\n- 测试用例 6 (违反选择定則的边界条件)：$ \\alpha = 2.5 $，$ n_1 = 0 $，$ n_2 = 1 $，$ N = 0 $，$ n = 0 $。报告 $ \\mathcal{M} $、相对于 $ \\alpha = 1.0 $ 计算的偏差，以及选择定则布尔值。\n- 测试用例 7 (正交归一性检查)：$ \\alpha = 1.19 $，$ n_1 = 1 $，$ n_2 = 1 $。计算 $ \\sum_{N=0}^{2} \\left[\\mathcal{M}\\left(N,2-N;1,1;\\alpha\\right)\\right]^2 $ 并报告其是否在 $ 10^{-12} $ 的容差内等于 $ 1 $（布尔值）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，并用方括号括起来（例如，“[result1,result2,...]”）。每个结果应为浮点数、布尔值或按每个测试用例指定顺序包含浮点数和布尔值的列表。不应打印任何附加文本。此问题中不需要物理单位，因为所有量在构造上都是无量纲的。",
            "solution": "该问题要求推导并实现谐振子势中两体系统的一维 Talmi-Moshinsky (TM) 括号，特别是针对质量不等的粒子。\n\n### 任务 1：Talmi-Moshinsky 括号的推导\n\n对于量子数为 $n_i$ 的粒子 $i$，其一维谐振子本征态由 $\\psi_{n_i}(\\xi_i) = \\mathcal{N}_{n_i} H_{n_i}(\\xi_i) \\exp(-\\xi_i^2/2)$ 给出，其中 $\\xi_i = x_i/b_i$ 是无量纲坐标，$H_{n_i}$ 是厄米多项式，$\\mathcal{N}_{n_i} = (2^{n_i} n_i! \\sqrt{\\pi})^{-1/2}$ 是归一化常数。两个此类单粒子态的乘积 $\\psi_{n_1}(\\xi_1)\\psi_{n_2}(\\xi_2)$ 可以在对应于质心坐标和相对坐标的态基 $\\Psi_N(\\Xi)\\Psi_n(\\varrho)$ 上展开。此展开的系数即为 Talmi-Moshinsky 括号，$\\mathcal{M}(N,n;n_1,n_2;\\theta) = \\langle N, n | n_1, n_2 \\rangle_\\theta$。\n$$\n\\psi_{n_1}(\\xi_1)\\psi_{n_2}(\\xi_2) = \\sum_{N,n} \\mathcal{M}(N,n;n_1,n_2;\\theta) \\Psi_N(\\Xi)\\Psi_n(\\varrho)\n$$\n到无量纲质心 ($\\Xi$) 和相对 ($\\varrho$) 坐标的变换是一次正交旋转：\n$$\n\\begin{pmatrix} \\Xi \\\\ \\varrho \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta \\end{pmatrix} \\begin{pmatrix} \\xi_1 \\\\ \\xi_2 \\end{pmatrix}\n$$\n逆变换为：\n$$\n\\begin{pmatrix} \\xi_1 \\\\ \\xi_2 \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix} \\begin{pmatrix} \\Xi \\\\ \\varrho \\end{pmatrix}\n$$\n由于此变换是正交的，平方和是不变的：$\\xi_1^2 + \\xi_2^2 = \\Xi^2 + \\varrho^2$。这意味着乘积态中的高斯因子 $\\exp(-(\\xi_1^2+\\xi_2^2)/2)$ 等于质心和相对坐标态的高斯因子 $\\exp(-(\\Xi^2+\\varrho^2)/2)$。因此，变换简化为波函数多项式部分之间的关系。\n\n物理学家厄米多项式 $H_k(z)$ 的生成函数为：\n$$\n\\exp(-t^2 + 2t z) = \\sum_{k=0}^{\\infty} H_k(z) \\frac{t^k}{k!}\n$$\n我们使用两个变量 $s$ 和 $t$ 来构造两个厄米多项式乘积 $H_{n_1}(\\xi_1)H_{n_2}(\\xi_2)$ 的生成函数：\n$$\n\\sum_{n_1=0}^{\\infty} \\sum_{n_2=0}^{\\infty} H_{n_1}(\\xi_1)H_{n_2}(\\xi_2) \\frac{s^{n_1}}{n_1!} \\frac{t^{n_2}}{n_2!} = \\exp(-s^2 + 2s\\xi_1) \\exp(-t^2 + 2t\\xi_2)\n$$\n将 $\\xi_1 = \\Xi\\cos\\theta - \\varrho\\sin\\theta$ 和 $\\xi_2 = \\Xi\\sin\\theta + \\varrho\\cos\\theta$ 代入指数中：\n$$\n2s\\xi_1 + 2t\\xi_2 = 2s(\\Xi\\cos\\theta - \\varrho\\sin\\theta) + 2t(\\Xi\\sin\\theta + \\varrho\\cos\\theta) = (2s\\cos\\theta + 2t\\sin\\theta)\\Xi + (-2s\\sin\\theta + 2t\\cos\\theta)\\varrho\n$$\n我们定义新的生成函数变量 $S = s\\cos\\theta + t\\sin\\theta$ 和 $T = -s\\sin\\theta + t\\cos\\theta$。指数变为 $2S\\Xi + 2T\\varrho$。指数的二次项 $-s^2-t^2$ 在此旋转下是不变的：$S^2+T^2 = (s\\cos\\theta + t\\sin\\theta)^2 + (-s\\sin\\theta + t\\cos\\theta)^2 = s^2+t^2$。\n因此，生成函数恒等式变为：\n$$\n\\exp(-s^2 - t^2 + 2s\\xi_1 + 2t\\xi_2) = \\exp(-S^2 - T^2 + 2S\\Xi + 2T\\varrho) = \\exp(-S^2+2S\\Xi)\\exp(-T^2+2T\\varrho)\n$$\n这是 $H_N(\\Xi)$ 和 $H_n(\\varrho)$ 的生成函数的乘积：\n$$\n\\sum_{n_1,n_2} \\frac{s^{n_1}t^{n_2}}{n_1!n_2!} H_{n_1}(\\xi_1)H_{n_2}(\\xi_2) = \\left( \\sum_N \\frac{S^N}{N!} H_N(\\Xi) \\right) \\left( \\sum_n \\frac{T^n}{n!} H_n(\\varrho) \\right) = \\sum_{N,n} \\frac{S^N T^n}{N!n!} H_N(\\Xi)H_n(\\varrho)\n$$\n归一化波函数之间的关系意味着由归一化因子缩放的厄米多项式之间也存在关系。当 $N+n=n_1+n_2$ 时，我们有：\n$$\n\\frac{H_{n_1}(\\xi_1)H_{n_2}(\\xi_2)}{\\sqrt{n_1!n_2!}} = \\sum_{N,n} \\mathcal{M}(N,n; n_1, n_2; \\theta) \\frac{H_N(\\Xi)H_n(\\varrho)}{\\sqrt{N!n!}}\n$$\n为了求出括号 $\\mathcal{M}$，我们在生成函数恒等式的右侧提取 $s^{n_1}t^{n_2} / (n_1!n_2!)$ 的系数。这需要使用二项式定理展开 $S^N T^n$：\n$$\nS^N T^n = (s\\cos\\theta + t\\sin\\theta)^N (-s\\sin\\theta + t\\cos\\theta)^n\n$$\n包含 $s^{n_1}t^{n_2}$ 的项对应于 $s$ 的总幂次为 $n_1$，$t$ 的总幂次为 $n_2$。$s$ 和 $t$ 的多项式总次数为 $N+n$。因此，必须有 $N+n = n_1+n_2$，这是振子量子数守恒的基本选择定则。如果不满足此条件，则括号为零。\n\n令 $[s^{n_1} t^{n_2}]P(s,t)$ 为多项式 $P(s,t)$ 中 $s^{n_1}t^{n_2}$ 项的系数。\n$$\n[s^{n_1} t^{n_2}] (S^N T^n) = [s^{n_1} t^{n_2}] \\left(\\sum_{k_1=0}^N \\binom{N}{k_1} (s c)^ {k_1} (t s)^{N-k_1}\\right) \\left(\\sum_{k_2=0}^n \\binom{n}{k_2} (-s s)^{k_2} (t c)^{n-k_2}\\right)\n$$\n其中 $c=\\cos\\theta, s=\\sin\\theta$。合并 $s$ 和 $t$ 的幂次：\n$$\n= [s^{n_1} t^{n_2}] \\sum_{k_1, k_2} \\binom{N}{k_1} \\binom{n}{k_2} (-1)^{k_2} s^{k_1+k_2} t^{N-k_1+n-k_2} c^{k_1+n-k_2} s^{N-k_1+k_2}\n$$\n我们需要 $k_1+k_2=n_1$ 和 $N-k_1+n-k_2=n_2$。将这两项相加得到 $N+n=n_1+n_2$。代入 $k_2=n_1-k_1$，我们可以对 $k_1$（现在我们称之为 $k$）求和：\n$$\nC(N,n,n_1) = \\sum_{k} (-1)^{n_1-k} \\binom{N}{k} \\binom{n}{n_1-k} (\\cos\\theta)^{k+n-(n_1-k)} (\\sin\\theta)^{N-k+(n_1-k)}\n$$\n$$\nC(N,n,n_1) = \\sum_{k=\\max(0, n_1-n)}^{\\min(N, n_1)} (-1)^{n_1-k} \\binom{N}{k} \\binom{n}{n_1-k} (\\cos\\theta)^{n-n_1+2k} (\\sin\\theta)^{N+n_1-2k}\n$$\n...\n$$\n\\mathcal{M}(N,n;n_1,n_2;\\theta) = \\delta_{N+n, n_1+n_2} \\sqrt{\\frac{n_1!n_2!}{N!n!}} \\sum_{k=\\max(0, n_1-n)}^{\\min(N, n_1)} (-1)^{n_1-k} \\binom{N}{k}\\binom{n}{n_1-k} (\\cos\\theta)^{n-n_1+2k} (\\sin\\theta)^{N+n_1-2k}\n$$\n\n### 任务 2：推广到不等质量情况\n角度 $\\theta$ 由 $\\cos\\theta = \\sqrt{m_1/(m_1+m_2)}$ 和 $\\sin\\theta = \\sqrt{m_2/(m_1+m_2)}$ 定义。使用质量比 $\\alpha = m_1/m_2$，我们可以将它们重新表示为：\n$$\n\\cos\\theta = \\sqrt{\\frac{m_1/m_2}{(m_1/m_2)+1}} = \\sqrt{\\frac{\\alpha}{\\alpha+1}}\n$$\n$$\n\\sin\\theta = \\sqrt{\\frac{1}{(m_1/m_2)+1}} = \\sqrt{\\frac{1}{\\alpha+1}}\n$$\n将这些表达式代入 $\\mathcal{M}$ 的公式中，即可得到作为质量比 $\\alpha$ 函数的括号。\n\n### 任务 3, 4, 5：实现与验证\n推导出的公式在一个 Python 函数中实现。该函数首先检查必要条件，即选择定则 $N+n=n_1+n_2$。如果不满足，括号值为 $0$。否则，它会计算关于索引 $k$ 的和。阶乘和二项式系数使用 `scipy.special.factorial` 和 `scipy.special.comb` 计算，以保证数值稳定性和精度，因为它们能很好地处理大数。$\\cos\\theta$ 和 $\\sin\\theta$ 的幂则使用浮点算术计算。\n偏差 $\\delta(\\alpha)$ 是通过计算给定 $\\alpha$ 下的括号值与等质量情况（$\\alpha=1$）下的值之间的绝对差来得到的。对于因对称性导致括号在 $\\alpha=1$ 时为零的情况，这简化为 $|\\mathcal{M}(\\alpha)|$。\n变换的正交归一性是其幺正性的结果，表示为 $\\sum_{N,n} |\\langle N,n|n_1,n_2 \\rangle|^2 = 1$，其中求和是对固定初始态的所有末态进行的。对于固定的总量子数 $E=n_1+n_2$，这变为 $\\sum_{N=0}^{E} [\\mathcal{M}(N, E-N; n_1, n_2; \\alpha)]^2 = 1$。实现过程会验证此和是否在很小的数值容差内等于 $1$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import comb, factorial\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the Talmi-Moshinsky bracket problem for the given test cases.\n    \"\"\"\n\n    memo_factorial = {}\n    def fact(k):\n        \"\"\"Memoized factorial for integer inputs.\"\"\"\n        if k not in memo_factorial:\n            memo_factorial[k] = factorial(k, exact=True)\n        return memo_factorial[k]\n\n    memo_comb = {}\n    def nCr_exact(n, r):\n        \"\"\"Memoized exact binomial coefficient.\"\"\"\n        if r  0 or r > n:\n            return 0\n        if (n, r) not in memo_comb:\n            memo_comb[(n, r)] = comb(n, r, exact=True)\n        return memo_comb[(n, r)]\n\n    def compute_m(N, n, n1, n2, alpha):\n        \"\"\"\n        Computes the one-dimensional Talmi-Moshinsky bracket M(N, n; n1, n2; alpha).\n        \n        Args:\n            N (int): Center-of-mass quantum number.\n            n (int): Relative motion quantum number.\n            n1 (int): Particle 1 quantum number.\n            n2 (int): Particle 2 quantum number.\n            alpha (float): Mass ratio m1/m2.\n        \n        Returns:\n            float: The value of the Talmi-Moshinsky bracket.\n        \"\"\"\n        # Task 1: Selection rule\n        if N + n != n1 + n2:\n            return 0.0\n\n        # Task 2: Parameterization with alpha\n        cos_theta = np.sqrt(alpha / (alpha + 1.0))\n        sin_theta = np.sqrt(1.0 / (alpha + 1.0))\n\n        # Task 1: Summation for the bracket formula\n        k_min = max(0, n1 - n)\n        k_max = min(N, n1)\n\n        total_sum = 0.0\n        for k in range(k_min, k_max + 1):\n            # Using integer arithmetic for binomials and signs\n            term_coeff = ((-1)**(n1 - k)) * nCr_exact(N, k) * nCr_exact(n, n1 - k)\n            \n            # Floating point for powers\n            term_powers = (cos_theta**(n - n1 + 2 * k)) * (sin_theta**(N + n1 - 2 * k))\n            \n            total_sum += float(term_coeff) * term_powers\n\n        # Prefactor\n        try:\n            prefactor_int = fact(n1) * fact(n2) / (fact(N) * fact(n))\n        except (ValueError, OverflowError):\n            # Fallback to log-gamma for large numbers if needed, though not for these test cases\n            log_prefactor = (math.lgamma(n1 + 1) + math.lgamma(n2 + 1) - \n                             math.lgamma(N + 1) - math.lgamma(n + 1))\n            prefactor = np.exp(0.5 * log_prefactor)\n        else:\n            prefactor = np.sqrt(float(prefactor_int))\n\n        return prefactor * total_sum\n\n    test_cases = [\n        # alpha, n1, n2, N, n\n        (1.0, 1, 1, 1, 1),\n        (1.19, 1, 1, 1, 1),\n        (10.0, 1, 1, 1, 1),\n        (1.0, 2, 2, 3, 1),\n        (1.19, 2, 2, 3, 1),\n        (2.5, 0, 1, 0, 0),\n    ]\n\n    results = []\n\n    # Process test cases 1-6\n    for i, case in enumerate(test_cases):\n        alpha, n1, n2, N, n = case\n        \n        # Task 3: Compute bracket M\n        m_val = compute_m(N, n, n1, n2, alpha)\n        \n        # Task 4: Compute deviation delta\n        m_val_equal_mass = compute_m(N, n, n1, n2, 1.0)\n        delta = abs(m_val - m_val_equal_mass)\n        \n        # Selection rule check\n        rule_satisfied = (N + n == n1 + n2)\n        \n        results.append([m_val, delta, rule_satisfied])\n\n    # Process test case 7 (Orthonormality)\n    alpha_ortho, n1_ortho, n2_ortho = 1.19, 1, 1\n    total_q = n1_ortho + n2_ortho\n    ortho_sum = 0.0\n    for N_loop in range(total_q + 1):\n        n_loop = total_q - N_loop\n        m_val = compute_m(N_loop, n_loop, n1_ortho, n2_ortho, alpha_ortho)\n        ortho_sum += m_val**2\n    \n    ortho_check = abs(ortho_sum - 1.0)  1e-12\n    results.append(ortho_check)\n\n    # Final output formatting\n    # The str() function on a list neatly formats it as '[item1, item2, ...]'\n    # and on a boolean as 'True' or 'False'. This matches the implied format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}