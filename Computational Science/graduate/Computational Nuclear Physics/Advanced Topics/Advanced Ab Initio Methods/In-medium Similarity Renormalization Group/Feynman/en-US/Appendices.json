{
    "hands_on_practices": [
        {
            "introduction": "The heart of the in-medium similarity renormalization group (IM-SRG) method is a continuous unitary transformation that drives the Hamiltonian towards a block-diagonal form. This is achieved by solving a differential flow equation, where a cleverly chosen anti-Hermitian generator, $\\eta(s)$, systematically suppresses the off-diagonal couplings. This exercise provides a hands-on implementation of this core mechanism. By constructing a toy Hamiltonian and the corresponding White generator, you will numerically integrate the flow equation and witness the decoupling process firsthand, solidifying your understanding of how the IM-SRG engine works .",
            "id": "3564791",
            "problem": "You are to construct and analyze a finite-dimensional, block-structured toy Hamiltonian representing one-particle–one-hole ($1p1h$) and two-particle–two-hole ($2p2h$) excitation sectors relative to a fixed reference Slater determinant in an in-medium formulation. The fundamental basis of this problem is the following:\n\n- A similarity transformation generated by a unitary operator $U(s)$ acting on a Hamiltonian $H(0)$ is defined by $H(s) = U(s)\\,H(0)\\,U^{\\dagger}(s)$, where $s$ is a real, dimensionless flow parameter and $U^{\\dagger}(s)$ is the Hermitian adjoint of $U(s)$.\n- A differentiable unitary $U(s)$ satisfies $U^{\\dagger}(s)\\,U(s) = I$, and its generator $\\eta(s)$ can be defined through $\\frac{dU}{ds}(s) = \\eta(s)\\,U(s)$ with $\\eta^{\\dagger}(s) = -\\eta(s)$ (anti-Hermitian).\n- The flow equation for the Hamiltonian $H(s)$ is $\\frac{dH}{ds}(s) = [\\eta(s),\\,H(s)]$, where $[A,\\,B] = A\\,B - B\\,A$ denotes the commutator.\n\nStarting from these principles, derive and implement a computational demonstration of the In-Medium Similarity Renormalization Group truncated to two-body operators (IM-SRG(2)) for a toy Hamiltonian. The Hamiltonian $H(s)$ is represented in a block matrix form corresponding to two excitation sectors:\n$$\nH(s) =\n\\begin{pmatrix}\nH_{11}(s) & H_{12}(s) \\\\\nH_{21}(s) & H_{22}(s)\n\\end{pmatrix},\n$$\nwhere $H_{11}(s)$ acts within the $1p1h$ sector of dimension $n_1$, $H_{22}(s)$ acts within the $2p2h$ sector of dimension $n_2$, and $H_{12}(s)$ with its Hermitian transpose $H_{21}(s) = H_{12}^{\\dagger}(s)$ couples the two sectors. The sectors are defined relative to a fixed, normalized reference Slater determinant, and normal ordering is understood with respect to this reference. The IM-SRG(2) truncation is reflected by working within these sectors and omitting higher-than-two-body induced operators by construction of the finite matrix model.\n\nYour task is to:\n1. Design initial Hamiltonians $H(0)$ using diagonal blocks $H_{11}(0)$ and $H_{22}(0)$ with specified energies, and specified off-diagonal couplings $H_{12}(0)$ that are real-valued. Assume $H(0)$ is Hermitian. The block diagonal entries represent normal-ordered zero-, one-, and two-body contributions restricted to their respective sectors. The units are arbitrary energy units and the flow parameter $s$ is dimensionless.\n2. Derive the White generator appropriate for driving the off-diagonal blocks $H_{12}(s)$ to zero as $s \\to \\infty$ under IM-SRG(2) truncation, from the stated fundamental basis, by requiring anti-Hermiticity and using instantaneous energy denominators inferred from the diagonal blocks. Resolve potential degeneracies by a regulator that does not break anti-Hermiticity.\n3. Implement the flow $\\frac{dH}{ds}(s) = [\\eta(s),\\,H(s)]$ numerically and demonstrate decoupling of the off-diagonal blocks as $s \\to \\infty$ by integrating to a sufficiently large final flow parameter $s_{\\text{end}}$ and computing the Frobenius norm $\\|H_{12}(s_{\\text{end}})\\|_{\\mathrm{F}}$.\n4. Use the following test suite of initial Hamiltonian specifications (each case defines $n_1$, $n_2$, diagonal energies, off-diagonal couplings, the regularization parameter, and the final flow parameter):\n   - Case $1$ (happy path): $n_1 = 2$, $n_2 = 2$. Diagonal energies in $H_{11}(0)$ are $[\\,0.5,\\,0.9\\,]$, and in $H_{22}(0)$ are $[\\,1.4,\\,2.1\\,]$. Off-diagonal block $H_{12}(0)$ is\n     $$\n     \\begin{pmatrix}\n     0.2 & -0.1 \\\\\n     0.05 & 0.3\n     \\end{pmatrix}.\n     $$\n     Use regulator $\\delta = 10^{-3}$ and final flow parameter $s_{\\text{end}} = 40$.\n   - Case $2$ (near-degeneracy): $n_1 = 1$, $n_2 = 1$. Diagonal energies $H_{11}(0) = [\\,1.0\\,]$, $H_{22}(0) = [\\,1.0001\\,]$, and $H_{12}(0) = [\\,0.05\\,]$ (a $1\\times 1$ block). Use regulator $\\delta = 10^{-4}$ and final flow parameter $s_{\\text{end}} = 80$.\n   - Case $3$ (zero coupling boundary): $n_1 = 3$, $n_2 = 2$. Diagonal energies in $H_{11}(0)$ are $[\\,0.3,\\,0.7,\\,1.1\\,]$, and in $H_{22}(0)$ are $[\\,1.6,\\,2.5\\,]$. Off-diagonal block $H_{12}(0)$ is the $3\\times 2$ zero matrix. Use regulator $\\delta = 10^{-3}$ and final flow parameter $s_{\\text{end}} = 20$.\n\nYour program must:\n- Construct each initial $H(0)$ from the specified blocks.\n- For each case, integrate the flow equation $\\frac{dH}{ds} = [\\eta(H),\\,H]$ from $s = 0$ to $s = s_{\\text{end}}$ using a stiff, stable method that preserves Hermiticity to within numerical tolerances.\n- At $s = s_{\\text{end}}$, compute the Frobenius norm $\\|H_{12}(s_{\\text{end}})\\|_{\\mathrm{F}}$ for each case.\n- Produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3]$, where each $r_i$ is the Frobenius norm expressed as a floating-point number. No units are required because $s$ is dimensionless and the toy energies are in arbitrary units.\n\nThe final program must be complete and runnable without any user input and must adhere to the specified execution environment. The outputs should be floats capturing the magnitude of off-diagonal decoupling for each test case.",
            "solution": "We start from the principle of unitary similarity transformations, where the Hamiltonian evolves as $H(s) = U(s)\\,H(0)\\,U^{\\dagger}(s)$. The dynamics are governed by a flow equation. By defining the anti-Hermitian generator $\\eta(s)$ via the relation $\\frac{dU}{ds}(s) = \\eta(s)\\,U(s)$, we can differentiate the expression for $H(s)$ using the product rule:\n$$ \\frac{dH}{ds}(s) = \\left(\\frac{dU}{ds}\\right)H(0)U^{\\dagger}(s) + U(s)H(0)\\left(\\frac{dU^{\\dagger}}{ds}\\right) $$\nUsing $\\frac{dU}{ds} = \\eta U$ and its adjoint $\\frac{dU^{\\dagger}}{ds} = U^{\\dagger}\\eta^{\\dagger} = -U^{\\dagger}\\eta$, and substituting $H(s) = U(s)H(0)U^{\\dagger}(s)$, we arrive at the standard flow equation:\n$$ \\frac{dH}{ds}(s) = \\eta(s) H(s) - H(s) \\eta(s) = [\\,\\eta(s),\\,H(s)\\,] $$\nThis is the flow equation that forms the foundation of the Similarity Renormalization Group.\n\nIn the in-medium setting, normal ordering is performed with respect to a fixed reference Slater determinant. The In-Medium Similarity Renormalization Group truncated at the two-body level (IM-SRG(2)) retains the normal-ordered zero-, one-, and two-body contributions while discarding higher induced terms. A common algorithmic approach to demonstrate decoupling is to restrict the operator representation to a finite block matrix spanning selected excitation sectors; in our toy model, we consider two sectors: the one-particle–one-hole ($1p1h$) sector of dimension $n_1$ and the two-particle–two-hole ($2p2h$) sector of dimension $n_2$. The Hamiltonian is then represented as\n$$\nH(s) =\n\\begin{pmatrix}\nH_{11}(s) & H_{12}(s) \\\\\nH_{21}(s) & H_{22}(s)\n\\end{pmatrix},\n$$\nwith $H_{21}(s) = H_{12}^{\\dagger}(s)$ to ensure Hermiticity.\n\nTo derive a White generator that drives decoupling, we begin with two requirements:\n- $\\eta(s)$ must be anti-Hermitian, i.e., $\\eta^{\\dagger}(s) = -\\eta(s)$.\n- The generator must be constructed such that the off-diagonal blocks $H_{12}(s)$ are suppressed as $s$ increases.\n\nConsider the instantaneous diagonal blocks $H_{11}(s)$ and $H_{22}(s)$ and define their diagonal entries as vectors of energies $\\mathbf{e}_1(s) = \\mathrm{diag}\\left(H_{11}(s)\\right)$ and $\\mathbf{e}_2(s) = \\mathrm{diag}\\left(H_{22}(s)\\right)$. For each pair $(i,\\alpha)$ with $i \\in \\{1,\\dots,n_1\\}$ and $\\alpha \\in \\{1,\\dots,n_2\\}$, define the energy denominator\n$$\n\\Delta_{i\\alpha}(s) = e_{2,\\alpha}(s) - e_{1,i}(s).\n$$\nTo handle near-degeneracies, we introduce a regulator $\\delta > 0$ and define a regularized denominator\n$$\n\\Delta^{\\mathrm{reg}}_{i\\alpha}(s) = \\mathrm{sign}\\!\\left(\\Delta_{i\\alpha}(s)\\right)\\,\\max\\!\\left(\\left|\\Delta_{i\\alpha}(s)\\right|,\\,\\delta\\right),\n$$\nwhich maintains the sign structure and avoids division by zero while preserving anti-Hermiticity when used consistently. The off-diagonal block $H_{12}(s)$ is an $n_1 \\times n_2$ matrix with elements $H_{12}(s)_{i\\alpha}$. We construct the White generator as a block anti-Hermitian matrix\n$$\n\\eta(s) =\n\\begin{pmatrix}\n0 & W(s) \\\\\n- W^{\\dagger}(s) & 0\n\\end{pmatrix},\n\\quad\nW(s)_{i\\alpha} = -\\frac{H_{12}(s)_{i\\alpha}}{\\Delta^{\\mathrm{reg}}_{i\\alpha}(s)}.\n$$\nThe minus sign is chosen so that, in the simplest $2\\times 2$ case with $H(s) = \\begin{pmatrix} e_1(s) & v(s) \\\\ v(s) & e_2(s) \\end{pmatrix}$, the flow of the off-diagonal element satisfies\n$$\n\\frac{dv}{ds}(s) = \\left[e_2(s) - e_1(s)\\right]\\,\\eta_{12}(s) = \\Delta(s)\\,\\left(-\\frac{v(s)}{\\Delta^{\\mathrm{reg}}(s)}\\right) \\approx -v(s)\n$$\nwhenever $\\Delta^{\\mathrm{reg}}(s)$ is close to $\\Delta(s)$ (e.g., away from degeneracy, or equal to $\\delta\\,\\mathrm{sign}(\\Delta)$ near degeneracy), thereby ensuring exponential suppression of $v(s)$ with $s$. This demonstrates that $H_{12}(s)$ is driven to zero as $s \\to \\infty$ and hence the sectors decouple under the IM-SRG flow. The general block case inherits this behavior element-wise, modified by the commutator algebra among all matrix elements.\n\nNumerically, we integrate the ordinary differential equation\n$$\n\\frac{dH}{ds}(s) = [\\,\\eta(H(s)),\\,H(s)\\,]\n$$\nwith $\\eta(H)$ as above. Because the flow can be stiff—especially for large energy separations or strong couplings—we use a stiff solver with tight tolerances to maintain Hermiticity to numerical precision. At each step, we:\n- Reshape the state vector into the matrix $H(s)$.\n- Extract $H_{11}(s)$, $H_{22}(s)$, and $H_{12}(s)$.\n- Compute the instantaneous diagonals $\\mathbf{e}_1(s)$ and $\\mathbf{e}_2(s)$.\n- Form the element-wise regularized denominators $\\Delta^{\\mathrm{reg}}_{i\\alpha}(s)$.\n- Construct $W(s)$ and hence the anti-Hermitian $\\eta(s)$.\n- Evaluate the commutator $[\\,\\eta(s),\\,H(s)\\,]$.\n\nWe then integrate up to a final $s_{\\text{end}}$. At $s = s_{\\text{end}}$, we compute the Frobenius norm\n$$\n\\|H_{12}(s_{\\text{end}})\\|_{\\mathrm{F}} = \\sqrt{\\sum_{i=1}^{n_1} \\sum_{\\alpha=1}^{n_2} \\left|H_{12}(s_{\\text{end}})_{i\\alpha}\\right|^2},\n$$\nwhich quantifies the residual coupling between sectors. For the specified test suite:\n- Case $1$ uses $n_1 = 2$, $n_2 = 2$, $H_{11}(0)$ diagonal entries $[\\,0.5,\\,0.9\\,]$, $H_{22}(0)$ diagonal entries $[\\,1.4,\\,2.1\\,]$, $H_{12}(0)$ as\n  $$\n  \\begin{pmatrix}\n  0.2 & -0.1 \\\\\n  0.05 & 0.3\n  \\end{pmatrix},\n  $$\n  regulator $\\delta = 10^{-3}$, and $s_{\\text{end}} = 40$.\n- Case $2$ uses $n_1 = 1$, $n_2 = 1$, diagonals $[\\,1.0\\,]$ and $[\\,1.0001\\,]$, $H_{12}(0) = [\\,0.05\\,]$, $\\delta = 10^{-4}$, and $s_{\\text{end}} = 80$.\n- Case $3$ uses $n_1 = 3$, $n_2 = 2$, diagonals $[\\,0.3,\\,0.7,\\,1.1\\,]$ and $[\\,1.6,\\,2.5\\,]$, $H_{12}(0) = 0$ matrix, $\\delta = 10^{-3}$, and $s_{\\text{end}} = 20$.\n\nWe expect the Frobenius norms $\\|H_{12}(s_{\\text{end}})\\|_{\\mathrm{F}}$ to be very small in Cases $1$ and $2$ due to successful decoupling (with Case $2$ potentially decoupling more slowly because of near degeneracy but still suppressed thanks to $\\delta$), and exactly zero in Case $3$ by construction because no coupling is present and the flow leaves the zero off-diagonal invariant.\n\nThe program will implement this logic, integrate the flow for each case using a stiff solver, and print a single line $[r_1,r_2,r_3]$ where $r_i$ are the Frobenius norms for Cases $1$, $2$, and $3$, respectively, as floating-point numbers.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef white_generator_eta(H, n1, n2, delta):\n    \"\"\"\n    Construct the anti-Hermitian White generator eta for a block Hamiltonian H.\n    Blocks:\n      H11: top-left (n1 x n1)\n      H12: top-right (n1 x n2)\n      H21: bottom-left (n2 x n1)\n      H22: bottom-right (n2 x n2)\n    White generator (real case):\n      eta = [[0, W], [-W^T, 0]]\n    with W_ij = - H12_ij / Delta_reg_ij, Delta_reg_ij = sign(Delta_ij) * max(|Delta_ij|, delta),\n    and Delta_ij = e2_j - e1_i using instantaneous diagonals e1, e2.\n    \"\"\"\n    # Extract blocks\n    H11 = H[:n1, :n1]\n    H12 = H[:n1, n1:]\n    H22 = H[n1:, n1:]\n\n    # Instantaneous diagonals\n    e1 = np.diag(H11)\n    e2 = np.diag(H22)\n\n    # Build denominators for each element of H12: Delta_{i,alpha} = e2_alpha - e1_i\n    # Shape: (n1, n2)\n    Delta = e2[np.newaxis, :] - e1[:, np.newaxis]\n    # Regularize denominators to avoid division by zero\n    sign = np.sign(Delta)\n    # For exactly zero, set sign to +1 to preserve anti-Hermitian structure\n    sign[sign == 0.0] = 1.0\n    Delta_reg = sign * np.maximum(np.abs(Delta), delta)\n\n    # Construct W with element-wise division\n    W = - H12 / Delta_reg\n\n    # Assemble eta\n    eta = np.zeros_like(H)\n    eta[:n1, n1:] = W\n    eta[n1:, :n1] = -W.T  # real case; for complex, use -W.conj().T\n\n    return eta\n\ndef imsrg_flow_rhs(s, y, n1, n2, delta):\n    \"\"\"\n    Right-hand side of the IM-SRG flow: dH/ds = [eta(H), H].\n    y is the flattened H matrix.\n    \"\"\"\n    dim = n1 + n2\n    H = y.reshape((dim, dim))\n\n    # Construct White generator\n    eta = white_generator_eta(H, n1, n2, delta)\n\n    # Compute commutator\n    dHds = eta @ H - H @ eta\n\n    return dHds.reshape(-1)\n\ndef integrate_flow(n1, n2, H11_diag, H22_diag, H12_init, s_end, delta):\n    \"\"\"\n    Integrate the IM-SRG flow for the specified toy Hamiltonian.\n    Returns the Frobenius norm of the off-diagonal block H12 at s_end.\n    \"\"\"\n    # Build initial H(0)\n    H11 = np.diag(np.array(H11_diag, dtype=float))\n    H22 = np.diag(np.array(H22_diag, dtype=float))\n    H12 = np.array(H12_init, dtype=float)\n\n    # Validate dimensions\n    assert H11.shape == (n1, n1)\n    assert H22.shape == (n2, n2)\n    assert H12.shape == (n1, n2)\n\n    # Assemble full H\n    dim = n1 + n2\n    H0 = np.zeros((dim, dim), dtype=float)\n    H0[:n1, :n1] = H11\n    H0[n1:, n1:] = H22\n    H0[:n1, n1:] = H12\n    H0[n1:, :n1] = H12.T\n\n    # Flatten\n    y0 = H0.reshape(-1)\n\n    # Integrate using a stiff solver\n    sol = solve_ivp(\n        fun=lambda s, y: imsrg_flow_rhs(s, y, n1, n2, delta),\n        t_span=(0.0, s_end),\n        y0=y0,\n        method='BDF',\n        rtol=1e-9,\n        atol=1e-12,\n        max_step=np.inf,\n    )\n\n    # Retrieve final H and re-symmetrize to mitigate numerical drift\n    Hf = sol.y[:, -1].reshape((dim, dim))\n    Hf = 0.5 * (Hf + Hf.T)  # enforce Hermiticity in real case\n\n    # Extract final off-diagonal block H12\n    H12_f = Hf[:n1, n1:]\n\n    # Frobenius norm\n    frob = np.linalg.norm(H12_f, ord='fro')\n    return frob\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: n1=2, n2=2\n        {\n            \"n1\": 2,\n            \"n2\": 2,\n            \"H11_diag\": [0.5, 0.9],\n            \"H22_diag\": [1.4, 2.1],\n            \"H12_init\": [[0.2, -0.1],\n                         [0.05, 0.3]],\n            \"s_end\": 40.0,\n            \"delta\": 1e-3,\n        },\n        # Case 2: near degeneracy, n1=1, n2=1\n        {\n            \"n1\": 1,\n            \"n2\": 1,\n            \"H11_diag\": [1.0],\n            \"H22_diag\": [1.0001],\n            \"H12_init\": [[0.05]],\n            \"s_end\": 80.0,\n            \"delta\": 1e-4,\n        },\n        # Case 3: zero coupling boundary, n1=3, n2=2\n        {\n            \"n1\": 3,\n            \"n2\": 2,\n            \"H11_diag\": [0.3, 0.7, 1.1],\n            \"H22_diag\": [1.6, 2.5],\n            \"H12_init\": [[0.0, 0.0],\n                         [0.0, 0.0],\n                         [0.0, 0.0]],\n            \"s_end\": 20.0,\n            \"delta\": 1e-3,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        frob = integrate_flow(\n            n1=case[\"n1\"],\n            n2=case[\"n2\"],\n            H11_diag=case[\"H11_diag\"],\n            H22_diag=case[\"H22_diag\"],\n            H12_init=case[\"H12_init\"],\n            s_end=case[\"s_end\"],\n            delta=case[\"delta\"],\n        )\n        # Append float result; format with full precision of Python's default str\n        results.append(frob)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The power of IM-SRG in tackling the nuclear many-body problem relies on a crucial approximation: truncating the operator expansion, typically at the two-body level (IM-SRG(2)). This truncation, while making calculations feasible, introduces a theoretical error by neglecting higher-body interactions, such as the residual normal-ordered three-body force. This practice offers a practical method to estimate the magnitude of this truncation error. By diagonalizing simplified Hamiltonians that represent IM-SRG(2) and a hypothetical IM-SRG(3), you will quantify the energy correction from the three-body term, a vital skill for assessing the accuracy of theoretical predictions .",
            "id": "3564801",
            "problem": "Consider a closed-shell reference Slater determinant $|\\Phi\\rangle$ of $A$ non-interacting fermions occupying the lowest-energy single-particle orbitals in a finite single-particle basis. In the In-Medium Similarity Renormalization Group (IM-SRG), one starts from the normal-ordered second-quantized Hamiltonian with respect to $|\\Phi\\rangle$,\n$$\n\\hat{H} \\equiv E_0 + \\sum_{ij} f_{ij} \\{ a_i^\\dagger a_j \\} + \\frac{1}{4} \\sum_{ijkl} \\Gamma_{ijkl} \\{ a_i^\\dagger a_j^\\dagger a_l a_k \\} + \\frac{1}{36} \\sum_{ijklmn} W_{ijklmn} \\{ a_i^\\dagger a_j^\\dagger a_k^\\dagger a_n a_m a_l \\},\n$$\nwhere curly braces denote normal ordering with respect to $|\\Phi\\rangle$, $E_0$ is the zero-body (scalar) contribution, $f_{ij}$ is the one-body tensor, $\\Gamma_{ijkl}$ is the normal-ordered two-body tensor, and $W_{ijklmn}$ is the residual normal-ordered three-body tensor. The IM-SRG($2$) truncation retains $E_0$, $f$, and $\\Gamma$, and neglects the residual three-body tensor $W$, while the IM-SRG($3$) truncation also retains $W$.\n\nIn a reduced model space that captures the leading correlations for a closed-shell system, consider the subspace spanned by three many-body basis states: the reference $|\\Phi\\rangle$, a representative two-particle–two-hole excitation $|2p2h\\rangle \\equiv a_{p_1}^\\dagger a_{p_2}^\\dagger a_{h_2} a_{h_1} |\\Phi\\rangle$, and a representative three-particle–three-hole excitation $|3p3h\\rangle \\equiv a_{p_1}^\\dagger a_{p_2}^\\dagger a_{p_3}^\\dagger a_{h_3} a_{h_2} a_{h_1} |\\Phi\\rangle$, where $\\{h_1,h_2,h_3\\}$ label occupied hole orbitals in $|\\Phi\\rangle$ and $\\{p_1,p_2,p_3\\}$ label unoccupied particle orbitals. Assume that:\n- The diagonal energies are approximated by\n$$\nE_0 = \\sum_{i \\in \\text{holes}} \\varepsilon_i + E_{\\text{hh}} + E_{\\text{occ}}^{(3)},\n$$\n$$\nE_{2} = E_0 + \\left( \\varepsilon_{p_1} + \\varepsilon_{p_2} - \\varepsilon_{h_1} - \\varepsilon_{h_2} \\right) + \\Delta_{2},\n$$\n$$\nE_{3} = E_0 + \\left( \\varepsilon_{p_1} + \\varepsilon_{p_2} + \\varepsilon_{p_3} - \\varepsilon_{h_1} - \\varepsilon_{h_2} - \\varepsilon_{h_3} \\right) + \\Delta_{3},\n$$\nwhere $\\varepsilon_i$ are single-particle energies, $E_{\\text{hh}}$ collects net two-body contributions among holes, $E_{\\text{occ}}^{(3)}$ collects normal-ordered zero-body contractions from the three-body interaction among occupied holes, and $\\Delta_{2}$, $\\Delta_{3}$ are diagonal interaction shifts within the respective excitation sectors.\n- The off-diagonal couplings are restricted to\n$$\n\\langle \\Phi | \\hat{H} | 2p2h \\rangle = g_{2}^{\\text{eff}} \\equiv g_{2}^{(0)} + c_{W},\n$$\n$$\n\\langle \\Phi | \\hat{H} | 3p3h \\rangle = g_{3},\n$$\nand all other couplings within this subspace are set to zero. Here $g_{2}^{(0)}$ is the direct two-body coupling amplitude, $c_{W}$ is an effective two-body contribution induced by normal-ordering of the three-body interaction (mapping part of $W$ into $\\Gamma$), and $g_{3}$ parameterizes the residual normal-ordered three-body coupling that is neglected in IM-SRG($2$) but retained in IM-SRG($3$).\n\nWithin this three-state subspace, define the IM-SRG($2$) Hamiltonian matrix as\n$$\nH^{(2)} =\n\\begin{pmatrix}\nE_0 & g_{2}^{\\text{eff}} \\\\\ng_{2}^{\\text{eff}} & E_{2}\n\\end{pmatrix},\n$$\nand the IM-SRG($3$) Hamiltonian matrix as\n$$\nH^{(3)} =\n\\begin{pmatrix}\nE_0 & g_{2}^{\\text{eff}} & g_{3} \\\\\ng_{2}^{\\text{eff}} & E_{2} & 0 \\\\\ng_{3} & 0 & E_{3}\n\\end{pmatrix}.\n$$\nDiagonalization of $H^{(2)}$ and $H^{(3)}$ yields ground-state energies $E_{\\text{gs}}^{(2)}$ and $E_{\\text{gs}}^{(3)}$, respectively. Because similarity renormalization group decoupling is based on a unitary transformation, the ground-state energy in a perfectly decoupled basis equals the smallest eigenvalue of the Hamiltonian in the chosen subspace. Therefore, a practical estimate of the error introduced by neglecting the residual normal-ordered three-body term is\n$$\n\\delta E \\equiv E_{\\text{gs}}^{(2)} - E_{\\text{gs}}^{(3)}.\n$$\n\nYour task is to write a program that, for each of the parameter sets given below, constructs $H^{(2)}$ and $H^{(3)}$, diagonalizes them, and outputs $\\delta E$ in mega-electron-volts (MeV) as a float rounded to six decimal places.\n\nUse the following test suite (each case specifies $\\{\\varepsilon_{h_1},\\varepsilon_{h_2},\\varepsilon_{h_3}\\}$, $\\{\\varepsilon_{p_1},\\varepsilon_{p_2},\\varepsilon_{p_3}\\}$, $E_{\\text{hh}}$, $E_{\\text{occ}}^{(3)}$, $g_{2}^{(0)}$, $c_{W}$, $g_{3}$, $\\Delta_{2}$, $\\Delta_{3}$), all energies in MeV:\n- Case $1$: holes $\\{-15.5,-14.2,-13.7\\}$, particles $\\{-1.8,0.7,2.2\\}$, $E_{\\text{hh}}=-12.0$, $E_{\\text{occ}}^{(3)}=-1.5$, $g_{2}^{(0)}=-2.0$, $c_{W}=-0.3$, $g_{3}=-0.5$, $\\Delta_{2}=0.9$, $\\Delta_{3}=0.4$.\n- Case $2$: holes $\\{-12.0,-11.5,-10.8\\}$, particles $\\{-2.0,0.0,1.0\\}$, $E_{\\text{hh}}=-10.0$, $E_{\\text{occ}}^{(3)}=-0.8$, $g_{2}^{(0)}=-1.5$, $c_{W}=-0.2$, $g_{3}=0.0$, $\\Delta_{2}=0.5$, $\\Delta_{3}=0.3$.\n- Case $3$: holes $\\{-16.0,-15.2,-14.1\\}$, particles $\\{-3.0,-1.0,0.5\\}$, $E_{\\text{hh}}=-13.0$, $E_{\\text{occ}}^{(3)}=-2.2$, $g_{2}^{(0)}=-1.0$, $c_{W}=-0.4$, $g_{3}=-4.0$, $\\Delta_{2}=0.7$, $\\Delta_{3}=0.9$.\n- Case $4$: holes $\\{-10.0,-9.5,-9.0\\}$, particles $\\{-9.0,-8.8,-8.5\\}$, $E_{\\text{hh}}=-8.0$, $E_{\\text{occ}}^{(3)}=-0.5$, $g_{2}^{(0)}=-3.0$, $c_{W}=-0.5$, $g_{3}=-1.0$, $\\Delta_{2}=-0.2$, $\\Delta_{3}=0.1$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[\\delta E_1,\\delta E_2,\\delta E_3,\\delta E_4]$, where each $\\delta E$ is rounded to six decimal places and expressed in MeV.",
            "solution": "The procedure to solve this problem for each given parameter set is as follows:\nFirst, we construct the diagonal and off-diagonal elements of the Hamiltonian matrices $H^{(2)}$ and $H^{(3)}$.\nThe reference energy, $E_0$, is the sum of the single-particle energies of the occupied hole states, plus contributions from two-body ($E_{\\text{hh}}$) and three-body ($E_{\\text{occ}}^{(3)}$) interactions among these holes.\n$$\nE_0 = \\sum_{i \\in \\text{holes}} \\varepsilon_i + E_{\\text{hh}} + E_{\\text{occ}}^{(3)}\n$$\nThe energy of the two-particle–two-hole ($2p2h$) state, $E_2$, is the reference energy plus the unperturbed excitation energy of creating two particles and two holes, corrected by a diagonal interaction shift $\\Delta_2$.\n$$\nE_{2} = E_0 + \\left( \\varepsilon_{p_1} + \\varepsilon_{p_2} - \\varepsilon_{h_1} - \\varepsilon_{h_2} \\right) + \\Delta_{2}\n$$\nSimilarly, the energy of the three-particle–three-hole ($3p3h$) state, $E_3$, is given by:\n$$\nE_{3} = E_0 + \\left( \\varepsilon_{p_1} + \\varepsilon_{p_2} + \\varepsilon_{p_3} - \\varepsilon_{h_1} - \\varepsilon_{h_2} - \\varepsilon_{h_3} \\right) + \\Delta_{3}\n$$\nThe off-diagonal coupling between the reference state $|\\Phi\\rangle$ and the $|2p2h\\rangle$ state is the effective two-body matrix element $g_{2}^{\\text{eff}}$, which includes the bare coupling $g_{2}^{(0)}$ and an induced term $c_W$ from the normal ordering of the three-body force.\n$$\ng_{2}^{\\text{eff}} = g_{2}^{(0)} + c_{W}\n$$\nThe coupling between $|\\Phi\\rangle$ and the $|3p3h\\rangle$ state is given by the residual normal-ordered three-body amplitude $g_3$.\n\nWith these elements, the IM-SRG($2$) Hamiltonian matrix is constructed in the $\\{|\\Phi\\rangle, |2p2h\\rangle\\}$ basis:\n$$\nH^{(2)} =\n\\begin{pmatrix}\nE_0 & g_{2}^{\\text{eff}} \\\\\ng_{2}^{\\text{eff}} & E_{2}\n\\end{pmatrix}\n$$\nThe IM-SRG($3$) Hamiltonian is constructed in the $\\{|\\Phi\\rangle, |2p2h\\rangle, |3p3h\\rangle\\}$ basis. The problem states that couplings other than those specified are zero, which implies $\\langle 2p2h|\\hat{H}|3p3h \\rangle = 0$.\n$$\nH^{(3)} =\n\\begin{pmatrix}\nE_0 & g_{2}^{\\text{eff}} & g_{3} \\\\\ng_{2}^{\\text{eff}} & E_{2} & 0 \\\\\ng_{3} & 0 & E_{3}\n\\end{pmatrix}\n$$\nThe ground-state energy within each truncation, $E_{\\text{gs}}^{(2)}$ and $E_{\\text{gs}}^{(3)}$, is the lowest eigenvalue of the respective Hamiltonian matrix. For the $2 \\times 2$ matrix $H^{(2)}$, the eigenvalues are given by the solution to the characteristic equation:\n$$\n\\lambda_{\\pm}^{(2)} = \\frac{1}{2} \\left( (E_0 + E_2) \\pm \\sqrt{(E_0 - E_2)^2 + 4 (g_{2}^{\\text{eff}})^2} \\right)\n$$\nThe ground-state energy is the smaller eigenvalue, $E_{\\text{gs}}^{(2)} = \\lambda_{-}^{(2)}$.\nFor the $3 \\times 3$ matrix $H^{(3)}$, the eigenvalues are the roots of a cubic characteristic polynomial. It is most straightforward to find them numerically. Since $H^{(2)}$ and $H^{(3)}$ are real and symmetric (Hermitian), their eigenvalues are real. We seek the minimum eigenvalue, $E_{\\text{gs}}^{(3)}$.\nFinally, the estimated error due to the neglect of the residual three-body term is computed as:\n$$\n\\delta E = E_{\\text{gs}}^{(2)} - E_{\\text{gs}}^{(3)}\n$$\nThis calculation is performed for each of the four parameter sets provided. The results are then rounded to six decimal places and presented in the required format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the error estimate δE by constructing and diagonalizing\n    IM-SRG(2) and IM-SRG(3) Hamiltonian matrices for a simplified 3-state system.\n    \"\"\"\n    \n    # Each tuple contains:\n    # (holes_eps, particles_eps, E_hh, E_occ3, g2_0, c_W, g3, Delta2, Delta3)\n    test_cases = [\n        # Case 1\n        (\n            np.array([-15.5, -14.2, -13.7]),\n            np.array([-1.8, 0.7, 2.2]),\n            -12.0, -1.5, -2.0, -0.3, -0.5, 0.9, 0.4\n        ),\n        # Case 2\n        (\n            np.array([-12.0, -11.5, -10.8]),\n            np.array([-2.0, 0.0, 1.0]),\n            -10.0, -0.8, -1.5, -0.2, 0.0, 0.5, 0.3\n        ),\n        # Case 3\n        (\n            np.array([-16.0, -15.2, -14.1]),\n            np.array([-3.0, -1.0, 0.5]),\n            -13.0, -2.2, -1.0, -0.4, -4.0, 0.7, 0.9\n        ),\n        # Case 4\n        (\n            np.array([-10.0, -9.5, -9.0]),\n            np.array([-9.0, -8.8, -8.5]),\n            -8.0, -0.5, -3.0, -0.5, -1.0, -0.2, 0.1\n        )\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        holes_eps, particles_eps, E_hh, E_occ3, g2_0, c_W, g3, Delta2, Delta3 = case\n        \n        # Unpack single-particle energies for clarity in formulas\n        eps_h1, eps_h2, eps_h3 = holes_eps\n        eps_p1, eps_p2, eps_p3 = particles_eps\n        \n        # Calculate matrix elements\n        # E_0: Reference state energy\n        E0 = np.sum(holes_eps) + E_hh + E_occ3\n        \n        # E_2: 2p2h state energy\n        E2 = E0 + (eps_p1 + eps_p2 - eps_h1 - eps_h2) + Delta2\n        \n        # E_3: 3p3h state energy\n        E3 = E0 + (eps_p1 + eps_p2 + eps_p3 - eps_h1 - eps_h2 - eps_h3) + Delta3\n        \n        # g2_eff: Effective 2-body coupling\n        g2_eff = g2_0 + c_W\n        \n        # Construct H(2) matrix (2x2)\n        H2 = np.array([\n            [E0, g2_eff],\n            [g2_eff, E2]\n        ])\n        \n        # Construct H(3) matrix (3x3)\n        H3 = np.array([\n            [E0, g2_eff, g3],\n            [g2_eff, E2, 0.0],\n            [g3, 0.0, E3]\n        ])\n        \n        # Diagonalize matrices to find the lowest eigenvalue (ground state energy)\n        # eigvalsh is used for Hermitian (real-symmetric) matrices.\n        E_gs_2 = np.min(np.linalg.eigvalsh(H2))\n        E_gs_3 = np.min(np.linalg.eigvalsh(H3))\n        \n        # Calculate the error estimate delta_E\n        delta_E = E_gs_2 - E_gs_3\n        \n        # Round to 6 decimal places and append to results\n        results.append(round(delta_E, 6))\n\n    # Format the final output string as specified\n    output_str = f\"[{','.join(f'{r:.6f}' for r in results)}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from pedagogical models to realistic nuclear systems requires confronting the computational cost of the IM-SRG, which can be formidable. The most computationally intensive steps involve tensor contractions within the commutator algebra, which naively scale polynomially with the basis size, such as $\\mathcal{O}(N^6)$. In this exercise, you will implement and compare a dense, high-scaling algorithm against a more efficient, factorized approach for a key tensor contraction, gaining direct insight into the algorithmic innovations that make large-scale IM-SRG calculations possible .",
            "id": "3564754",
            "problem": "You are tasked with implementing and analyzing the computational cost of a key tensor-contraction building block that appears in the In-Medium Similarity Renormalization Group (IM-SRG), truncated at the normal-ordered two-body level, known as IM-SRG(2). The target object is a commutator of two normal-ordered two-body operators, taken in a reduced form where the relevant contribution can be captured by a tensor contraction of the type\n$$\n\\mathcal{K}_{ijab} = \\sum_{cd} \\mathcal{A}_{ijcd} \\,\\mathcal{B}_{cdab} \\;-\\; \\sum_{cd} \\mathcal{B}_{ijcd} \\,\\mathcal{A}_{cdab},\n$$\nwhere $i,j$ denote hole indices and $a,b,c,d$ denote particle indices in a single-particle basis. The dimension of the basis is $N$, and you may assume $N$ is even with $n_h = N/2$ holes and $n_p = N/2$ particles. This contraction is representative of the two-body part of the commutator in IM-SRG(2) and is known to scale as $\\mathcal{O}(N^6)$ in a dense representation.\n\nYour program must implement two algorithms for computing $\\mathcal{K}_{ijab}$:\n\n1. A dense contraction method using explicit four-index tensors, which performs the two contractions directly. This should realize the naive scaling $\\mathcal{O}(N^6)$ for $n_h \\approx n_p \\approx N/2$.\n\n2. A low-rank factorized method that exploits a factorization of the four-index tensors. Construct a family of rank-$R$ factors with $R = \\lfloor N/2 \\rfloor$ and define\n$$\n\\mathcal{A}_{ijcd} = \\sum_{r=1}^{R} S^{(r)}_{ij} \\, U^{(r)}_{cd}, \\qquad\n\\mathcal{A}_{cdab} = \\sum_{r=1}^{R} U^{(r)}_{cd} \\, T^{(r)}_{ab},\n$$\n$$\n\\mathcal{B}_{ijcd} = \\sum_{r=1}^{R} \\tilde{S}^{(r)}_{ij} \\, U^{(r)}_{cd}, \\qquad\n\\mathcal{B}_{cdab} = \\sum_{r=1}^{R} U^{(r)}_{cd} \\, \\tilde{T}^{(r)}_{ab},\n$$\nwith shared particle-space factors $U^{(r)}_{cd}$ between the $(ijcd)$ and $(cdab)$ forms. Show that the commutator contribution can then be evaluated exactly (for these low-rank-constructed tensors) using the auxiliary $R \\times R$ Gram matrix\n$$\nM_{rs} = \\sum_{cd} U^{(r)}_{cd} \\, U^{(s)}_{cd},\n$$\nand matrix multiplications on reshaped factors. Use this to reduce the scaling to $\\mathcal{O}(N^5)$ when $R \\propto N$.\n\nBegin from the following fundamental basis:\n- The commutator definition $[ \\hat{A}, \\hat{B} ] \\equiv \\hat{A}\\hat{B} - \\hat{B}\\hat{A}$.\n- The identification of bilinear two-body operator contractions with index summations as written above.\n- The floating-point operation (FLOP) count for an $m \\times k$ times $k \\times n$ matrix product is $2 mkn$, and a dot product of two length-$k$ vectors is $2k$ FLOPs.\n\nTasks:\n- Implement both methods to compute $\\mathcal{K}_{ijab}$ for even $N$, using random but reproducible factors. Use a fixed seed to guarantee determinism. Verify numerical equivalence by computing the relative Frobenius norm error\n$$\n\\epsilon_{\\mathrm{rel}} = \\frac{\\| \\mathcal{K}^{\\mathrm{dense}} - \\mathcal{K}^{\\mathrm{fact}} \\|_F}{\\| \\mathcal{K}^{\\mathrm{dense}} \\|_F}.\n$$\n- Derive and implement analytic FLOP counts for both methods, as a function of $N$, $n_h$, $n_p$, and $R$:\n  - Dense method: model the cost as two contractions, each costing $2 \\, n_h^2 \\, n_p^4$ FLOPs; total $4 \\, n_h^2 \\, n_p^4$ FLOPs.\n  - Factorized method: compute the Gram matrix and two matrix-chain products. With $H = n_h^2$ and $P = n_p^2$, the total of $6 R^2 P + 4 H R P$ FLOPs.\n- For a set of increasing basis sizes $N \\in \\{4,6,8,10\\}$ (this is the test suite), set $n_h = n_p = N/2$ and $R = N/2$, and compute the FLOP counts for both methods. Fit the scaling exponent $\\alpha$ to the model $F(N) \\propto N^\\alpha$ by linear least squares on $\\log F(N)$ versus $\\log N$ for each method separately; report the exponent for the dense method and the factorized method. You must use natural logarithms or base-$10$ logarithms consistently.\n- Your program should produce a single line of output containing a Python-style list with three floats:\n  - The fitted exponent for the dense method,\n  - The fitted exponent for the factorized method,\n  - The maximum relative error $\\epsilon_{\\mathrm{rel}}$ across the test suite.\nNo physical units are involved; all outputs are dimensionless real numbers. The angles, if any, are not applicable.\n\nFinal output format:\n- Your program must produce exactly one line, in the format\n$$\n[\\alpha_{\\mathrm{dense}},\\alpha_{\\mathrm{fact}},\\epsilon_{\\max}]\n$$\nwith the exponents rounded to three decimal places and the error reported as a floating-point number. For example, a syntactically correct output would look like\n$$\n[6.000,5.000,1.2e-15].\n$$",
            "solution": "The problem requires implementing and comparing two methods for computing a key tensor contraction found in IM-SRG(2) commutators. We will analyze a dense, direct contraction method and a more efficient low-rank factorized method.\n\n**Method 1: Dense Contraction**\n\nThis method involves constructing the full four-index tensors $\\mathcal{A}$ and $\\mathcal{B}$ from their rank-$R$ factors and then performing the tensor contractions as specified. The two required forms of $\\mathcal{A}$ are $\\mathcal{A}_{ijcd}$ and $\\mathcal{A}_{cdab}$. Given the factorized definitions, these are constructed as:\n$$ \\mathcal{A}_{ijcd} = \\sum_{r=1}^{R} S^{(r)}_{ij} U^{(r)}_{cd} \\quad ; \\quad \\mathcal{A}_{cdab} = \\sum_{r=1}^{R} U^{(r)}_{cd} T^{(r)}_{ab} $$\nAnalogous expressions hold for $\\mathcal{B}$. Once the four tensors $\\mathcal{A}_{ijcd}$, $\\mathcal{B}_{cdab}$, $\\mathcal{B}_{ijcd}$, and $\\mathcal{A}_{cdab}$ are formed, the final tensor $\\mathcal{K}_{ijab}$ is computed by direct contraction:\n$$ \\mathcal{K}_{ijab} = \\sum_{c,d} \\mathcal{A}_{ijcd} \\mathcal{B}_{cdab} - \\sum_{c,d} \\mathcal{B}_{ijcd} \\mathcal{A}_{cdab} $$\nEach contraction sums over $n_p^2$ pairs of indices $(c,d)$. For each of the $n_h^2 n_p^2$ elements of the result, this requires approximately $2n_p^2$ floating-point operations (FLOPs). The total cost for the two contractions is thus $2 \\times (n_h^2 n_p^2 \\times 2n_p^2) = 4n_h^2 n_p^4$ FLOPs. With $n_h = n_p = N/2$, the cost scales as $\\mathcal{O}(N^6)$.\n\n**Method 2: Low-Rank Factorized Contraction**\n\nThis method avoids forming the large four-index tensors. Consider the first term in the commutator, $\\sum_{cd} \\mathcal{A}_{ijcd} \\mathcal{B}_{cdab}$. Substituting the factorized forms gives:\n$$ \\sum_{c,d} \\left( \\sum_{r=1}^{R} S^{(r)}_{ij} U^{(r)}_{cd} \\right) \\left( \\sum_{s=1}^{R} U^{(s)}_{cd} \\tilde{T}^{(s)}_{ab} \\right) = \\sum_{r,s=1}^{R} S^{(r)}_{ij} \\tilde{T}^{(s)}_{ab} \\left( \\sum_{c,d} U^{(r)}_{cd} U^{(s)}_{cd} \\right) $$\nThe inner summation is the Gram matrix $M_{rs} = \\sum_{c,d} U^{(r)}_{cd} U^{(s)}_{cd}$. The expression becomes $\\sum_{r,s=1}^{R} S^{(r)}_{ij} M_{rs} \\tilde{T}^{(s)}_{ab}$. This structure is best computed via matrix multiplications. By reshaping the factors into matrices (with dimensions $H=n_h^2$ and $P=n_p^2$)—$\\mathbf{S}$ ($H \\times R$), $\\tilde{\\mathbf{S}}$ ($H \\times R$), $\\mathbf{T}$ ($R \\times P$), $\\tilde{\\mathbf{T}}$ ($R \\times P$), and $\\mathbf{U}$ ($R \\times P$)—the computation proceeds as follows:\n1. Compute the Gram matrix $\\mathbf{M} = \\mathbf{U} \\mathbf{U}^T$. Cost: $2 R^2 P$ FLOPs.\n2. Compute the intermediate products $\\mathbf{Y}_{\\tilde{T}} = \\mathbf{M} \\tilde{\\mathbf{T}}$ and $\\mathbf{Y}_{T} = \\mathbf{M} \\mathbf{T}$. Cost: $2 \\times (2 R^2 P) = 4 R^2 P$ FLOPs.\n3. Compute the final products $\\mathbf{S} \\mathbf{Y}_{\\tilde{T}}$ and $\\tilde{\\mathbf{S}} \\mathbf{Y}_{T}$. Cost: $2 \\times (2 H R P) = 4 H R P$ FLOPs.\nThe total cost is the sum of these steps: $F_{\\text{fact}} = 6 R^2 P + 4 H R P$. With $n_h = n_p = R = N/2$, the dominant term scales as $\\mathcal{O}(N^5)$, a significant reduction.\n\n**Scaling Analysis**\n\nTo verify the theoretical scaling, we model the FLOP count $F$ as $F(N) = c N^\\alpha$. Taking the logarithm gives a linear relationship: $\\log(F(N)) = \\alpha \\log(N) + \\log(c)$. We compute the FLOP counts for $N \\in \\{4, 6, 8, 10\\}$ and use a linear least-squares regression on the $(\\log N, \\log F(N))$ data to find the slope $\\alpha$ for each method. Finally, numerical equivalence is checked by computing the relative Frobenius norm of the difference between $\\mathcal{K}^{\\mathrm{dense}}$ and $\\mathcal{K}^{\\mathrm{fact}}$, which should be close to machine precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Implements and analyzes two algorithms for a tensor contraction in IM-SRG(2),\n    verifies their numerical equivalence, and fits their computational scaling.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [4, 6, 8, 10]\n    \n    # Use a fixed seed for reproducible random factors.\n    np.random.seed(42)\n\n    all_relative_errors = []\n    flop_data = []\n\n    for N in test_cases:\n        # Define dimensions based on the problem statement\n        n_h = N // 2\n        n_p = N // 2\n        R = N // 2\n\n        # Generate random, reproducible tensors (factors)\n        # S_factors will have shape (R, n_h, n_h)\n        S_factors = np.random.randn(R, n_h, n_h)\n        S_tilde_factors = np.random.randn(R, n_h, n_h)\n        \n        # T_factors will have shape (R, n_p, n_p)\n        T_factors = np.random.randn(R, n_p, n_p)\n        T_tilde_factors = np.random.randn(R, n_p, n_p)\n\n        # U_factors are shared and have shape (R, n_p, n_p)\n        U_factors = np.random.randn(R, n_p, n_p)\n\n        # --- Method 1: Dense Contraction ---\n        # Construct full 4-index tensors from factors\n        # A_ijcd = sum_r S_rij * U_rcd\n        A_ijcd = np.einsum('rij,rcd->ijcd', S_factors, U_factors)\n        # A_cdab = sum_r U_rcd * T_rab\n        A_cdab = np.einsum('rcd,rab->cdab', U_factors, T_factors)\n        # B_ijcd = sum_r S_tilde_rij * U_rcd\n        B_ijcd = np.einsum('rij,rcd->ijcd', S_tilde_factors, U_factors)\n        # B_cdab = sum_r U_rcd * T_tilde_rab\n        B_cdab = np.einsum('rcd,rab->cdab', U_factors, T_tilde_factors)\n\n        # Perform the commutator contractions\n        # term1 = sum_cd A_ijcd * B_cdab\n        term1 = np.einsum('ijcd,cdab->ijab', A_ijcd, B_cdab)\n        # term2 = sum_cd B_ijcd * A_cdab\n        term2 = np.einsum('ijcd,cdab->ijab', B_ijcd, A_cdab)\n\n        K_dense = term1 - term2\n\n        # --- Method 2: Low-Rank Factorized Contraction ---\n        H = n_h**2\n        P = n_p**2\n\n        # Reshape factors into 2D matrices\n        # (R, n_h, n_h) -> (R, H) -> (H, R)\n        S_mat = S_factors.reshape(R, H).T\n        S_tilde_mat = S_tilde_factors.reshape(R, H).T\n        \n        # (R, n_p, n_p) -> (R, P)\n        T_mat = T_factors.reshape(R, P)\n        T_tilde_mat = T_tilde_factors.reshape(R, P)\n        U_mat = U_factors.reshape(R, P)\n\n        # 1. Compute the Gram matrix M = U U^T\n        # (R, P) @ (P, R) -> (R, R)\n        M = U_mat @ U_mat.T\n        \n        # 2. Compute first term: S (M T_tilde)\n        Y_tilde = M @ T_tilde_mat # (R, R) @ (R, P) -> (R, P)\n        term1_mat = S_mat @ Y_tilde # (H, R) @ (R, P) -> (H, P)\n\n        # 3. Compute second term: S_tilde (M T)\n        Y = M @ T_mat # (R, R) @ (R, P) -> (R, P)\n        term2_mat = S_tilde_mat @ Y # (H, R) @ (R, P) -> (H, P)\n\n        # 4. Combine and reshape back to a 4-index tensor\n        K_fact_mat = term1_mat - term2_mat\n        K_fact = K_fact_mat.reshape(n_h, n_h, n_p, n_p)\n\n        # --- Verification ---\n        norm_diff = np.linalg.norm(K_dense - K_fact)\n        norm_K_dense = np.linalg.norm(K_dense)\n        relative_error = norm_diff / norm_K_dense if norm_K_dense > 0 else 0.0\n        all_relative_errors.append(relative_error)\n\n        # --- FLOP Count Calculation ---\n        # Using formulas from the problem statement\n        flops_dense = 4 * (n_h**2) * (n_p**4)\n        flops_fact = 6 * (R**2) * P + 4 * H * R * P\n        flop_data.append((N, flops_dense, flops_fact))\n\n    # --- Scaling Analysis ---\n    log_N_vals = np.log([item[0] for item in flop_data])\n    log_flops_dense = np.log([item[1] for item in flop_data])\n    log_flops_fact = np.log([item[2] for item in flop_data])\n    \n    # Perform linear regression to find the slope (scaling exponent)\n    alpha_dense = linregress(log_N_vals, log_flops_dense).slope\n    alpha_fact = linregress(log_N_vals, log_flops_fact).slope\n    \n    # Find the maximum relative error across the test suite\n    epsilon_max = max(all_relative_errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{alpha_dense:.3f},{alpha_fact:.3f},{epsilon_max}]\")\n\nsolve()\n```"
        }
    ]
}