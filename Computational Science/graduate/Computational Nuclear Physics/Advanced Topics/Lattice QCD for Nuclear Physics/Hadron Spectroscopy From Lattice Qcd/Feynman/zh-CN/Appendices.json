{
    "hands_on_practices": [
        {
            "introduction": "在格点QCD计算中，我们得到的两点关联函数包含了所有具有正确量子数的能量本征态的信号，包括基态和一系列激发态。为了精确提取特定能态（尤其是基态）的质量，我们必须设计一个能够与目标态强耦合、而与其他态弱耦合的插值算符。这项实践练习  将指导你如何通过优化算符的“涂抹”轮廓（即调整其空间结构），来最大化其与目标强子态的“交叠”，从而获得更纯净、更可靠的信号。",
            "id": "3562967",
            "problem": "考虑从格点量子色动力学（Lattice Quantum Chromodynamics, QCD）中提取的用于强子谱学研究的欧几里得两点相关函数。对于一个具有涂抹半径参数 $\\sigma$ 的涂抹插值算符，零动量相关器的谱分解由下式给出\n$$\nC(t;\\sigma) = \\sum_{n=0}^{N-1} |Z_n(\\sigma)|^2 e^{-E_n t},\n$$\n其中 $E_n$ 是能级，$Z_n(\\sigma) = \\langle 0 | O(\\sigma) | n \\rangle$ 是依赖于算符涂抹分布的、与态相关的交叠因子。\n\n为了研究涂抹半径如何改变交叠因子并在激发态之间重新分配谱权重，我们采用以下具有物理动机的交叠连续谱模型。假设涂抹源的空间分布是一个归一化的三维高斯函数\n$$\nS(\\mathbf{r};\\sigma) = \\pi^{-3/4}\\,\\sigma^{-3/2} \\exp\\left(-\\frac{r^2}{2\\sigma^2}\\right),\n$$\n并且强子的 $s$ 波径向态可以由特征长度标度为 $a>0$ 的三维各向同性谐振子本征函数（它们在 $L^2(\\mathbb{R}^3)$ 中构成一个完备正交基）来定性近似。归一化的 $s$ 波径向本征函数为\n$$\n\\psi_n(\\mathbf{r};a) = C_n(a)\\,L_n^{(1/2)}\\!\\left(\\frac{r^2}{a^2}\\right)\\exp\\left(-\\frac{r^2}{2a^2}\\right),\n$$\n其中 $L_n^{(1/2)}(x)$ 是参数为 $1/2$ 的广义拉盖尔多项式，而 $C_n(a)$ 的选择使得 $\\int d^3r\\,|\\psi_n(\\mathbf{r};a)|^2 = 1$。利用广义拉盖尔多项式在适当权重下的正交性，可以得到\n$$\nC_n(a) = \\left(\\frac{n!}{2\\pi a^3\\,\\Gamma\\!\\left(n+\\frac{3}{2}\\right)}\\right)^{1/2}.\n$$\n交叠因子由以下空间积分定义\n$$\nZ_n(\\sigma) = \\int d^3r\\,\\psi_n(\\mathbf{r};a)\\,S(\\mathbf{r};\\sigma),\n$$\n谱权重（每个态在 $t=0$ 时对相关器振幅的分数贡献）为\n$$\nw_n(\\sigma) = \\frac{|Z_n(\\sigma)|^2}{\\sum_{m=0}^{N-1} |Z_m(\\sigma)|^2}.\n$$\n\n您的任务是：\n- 对于前三个 $s$ 波态 $n\\in\\{0,1,2\\}$，从第一性原理出发，推导出一个用 $a$、$\\sigma$ 和已知特殊函数表示的 $Z_n(\\sigma)$ 的显式可计算表达式。从上述定义开始，利用球对称性，将三维积分简化为径向形式。利用 $L_n^{(1/2)}(x)$ 是 $x$ 的多项式这一事实，使得积分可以简化为带有 $r^{2k}$ 的高斯矩。\n- 设计并实现一种基于梯度的优化方法（带有回溯线搜索的梯度上升法），以在有界区间 $\\sigma\\in[\\sigma_{\\min},\\sigma_{\\max}]$ 上相对于 $\\sigma$ 最大化交叠平方目标函数 $F_n(\\sigma) = |Z_n(\\sigma)|^2$。使用数值稳定的中心差分近似来计算梯度 $\\partial F_n/\\partial \\sigma$，并确保该方法能处理边界情况。确保收敛准则在梯度大小和步长方面有明确定义。\n- 通过计算每个目标态在优化后的 $\\sigma$ 处的 $w_n(\\sigma)$，并将其与固定的参考涂抹 $\\sigma_{\\mathrm{ref}}$ 进行比较，来量化涂抹半径如何在激发态之间重新分配谱权重。\n\n在测试套件中使用以下科学上一致的参数：\n- 谐振子长度标度 $a = 1.0$（无量纲单位；所有 $\\sigma$ 都以 $a$ 为单位表示，因此也是无量纲的）。\n- 态的数量 $N=3$，其中 $n\\in\\{0,1,2\\}$；所需输出不需要能量 $E_n$，因为所有要求的量都仅基于 $Z_n(\\sigma)$。\n- 参考涂抹 $\\sigma_{\\mathrm{ref}} = 1.0$。\n- 优化边界 $\\sigma_{\\min} = 0.05$，$\\sigma_{\\max} = 5.0$。\n- 五个测试用例的初始猜测值和目标态：\n    1. 目标 $n=0$，初始 $\\sigma_0=0.5$。\n    2. 目标 $n=1$，初始 $\\sigma_0=0.5$。\n    3. 目标 $n=2$，初始 $\\sigma_0=0.5$。\n    4. 目标 $n=1$，初始 $\\sigma_0=0.05$（边界起始）。\n    5. 目标 $n=0$，初始 $\\sigma_0=5.0$（边界起始）。\n\n对于每个测试用例，计算：\n- 优化后的涂抹半径 $\\sigma_{\\mathrm{opt}}$（无量纲，以 $a$ 为单位）。\n- 优化后的目标谱权重 $w_n(\\sigma_{\\mathrm{opt}})$（无量纲）。\n- 目标谱权重的变化量 $\\Delta w_n = w_n(\\sigma_{\\mathrm{opt}}) - w_n(\\sigma_{\\mathrm{ref}})$（无量纲）。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于上述五个测试用例，输出序列\n$$\n[\\sigma_{\\mathrm{opt}}^{(1)},\\, w_{n_1}(\\sigma_{\\mathrm{opt}}^{(1)}),\\, \\Delta w_{n_1}^{(1)},\\, \\sigma_{\\mathrm{opt}}^{(2)},\\, w_{n_2}(\\sigma_{\\mathrm{opt}}^{(2)}),\\, \\Delta w_{n_2}^{(2)},\\, \\dots,\\, \\sigma_{\\mathrm{opt}}^{(5)},\\, w_{n_5}(\\sigma_{\\mathrm{opt}}^{(5)}),\\, \\Delta w_{n_5}^{(5)}],\n$$\n其中 $n_j$ 是测试用例 $j$ 的目标态索引。所有量均为浮点数且无量纲。",
            "solution": "该问题经评估有效，因为它科学上基于量子力学和格点QCD建模的原理，在数学上是适定的、客观的且自洽的。唯一解所需的所有必要参数和定义均已提供。因此，我们可以着手求解。\n\n按照要求，解答分为三个部分：首先，推导交叠因子 $Z_n(\\sigma)$；其次，设计优化算法；第三，计算谱权重及其变化的方法。\n\n### 第1部分：交叠因子 $Z_n(\\sigma)$ 的推导\n\n交叠因子 $Z_n(\\sigma)$ 由以下空间积分定义：\n$$\nZ_n(\\sigma) = \\int d^3r\\,\\psi_n(\\mathbf{r};a)\\,S(\\mathbf{r};\\sigma)\n$$\n其中 $\\psi_n(\\mathbf{r};a)$ 是谐振子 s 波本征函数，$S(\\mathbf{r};\\sigma)$ 是高斯涂抹源。两个函数都是球对称的，仅依赖于径向坐标 $r = |\\mathbf{r}|$。因此，我们可以通过使用球坐标系将三维积分简化为一维径向积分，其中体积元为 $d^3r = 4\\pi r^2 dr$。\n\n这些函数的显式形式为：\n$$\nS(r;\\sigma) = \\pi^{-3/4}\\,\\sigma^{-3/2} \\exp\\left(-\\frac{r^2}{2\\sigma^2}\\right)\n$$\n$$\n\\psi_n(r;a) = C_n(a)\\,L_n^{(1/2)}\\!\\left(\\frac{r^2}{a^2}\\right)\\exp\\left(-\\frac{r^2}{2a^2}\\right)\n$$\n其中归一化常数为 $C_n(a) = \\left(\\frac{n!}{2\\pi a^3\\,\\Gamma(n+3/2)}\\right)^{1/2}$。\n\n将这些代入 $Z_n(\\sigma)$ 的积分中：\n$$\nZ_n(\\sigma) = 4\\pi \\int_0^\\infty r^2 dr \\left[ C_n(a)\\,L_n^{(1/2)}\\!\\left(\\frac{r^2}{a^2}\\right)\\exp\\left(-\\frac{r^2}{2a^2}\\right) \\right] \\left[ \\pi^{-3/4}\\,\\sigma^{-3/2} \\exp\\left(-\\frac{r^2}{2\\sigma^2}\\right) \\right]\n$$\n合并常数前因子和指数项，得到：\n$$\nZ_n(\\sigma) = 4\\pi^{1/4} C_n(a) \\sigma^{-3/2} \\int_0^\\infty dr\\, r^2 L_n^{(1/2)}\\!\\left(\\frac{r^2}{a^2}\\right) \\exp\\left(-\\frac{r^2}{2}\\left(\\frac{1}{a^2} + \\frac{1}{\\sigma^2}\\right)\\right)\n$$\n我们定义一个组合长度标度 $\\beta$，使得 $\\frac{1}{2\\beta^2} = \\frac{1}{2a^2} + \\frac{1}{2\\sigma^2}$，这给出 $\\beta^2 = \\frac{a^2\\sigma^2}{a^2+\\sigma^2}$。积分变为：\n$$\nZ_n(\\sigma) = 4\\pi^{1/4} C_n(a) \\sigma^{-3/2} \\int_0^\\infty dr\\, r^2 L_n^{(1/2)}\\!\\left(\\frac{r^2}{a^2}\\right) \\exp\\left(-\\frac{r^2}{2\\beta^2}\\right)\n$$\n$n \\in \\{0,1,2\\}$ 时的函数 $L_n^{(1/2)}(x)$ 是多项式：\n$L_0^{(1/2)}(x) = 1$\n$L_1^{(1/2)}(x) = -x + 3/2$\n$L_2^{(1/2)}(x) = \\frac{1}{2}x^2 - \\frac{5}{2}x + \\frac{15}{8}$\n\n由于 $L_n^{(1/2)}(r^2/a^2)$ 是 $r^2$ 的多项式，该积分可简化为一系列形式为 $I_{2k} = \\int_0^\\infty r^{2k} \\exp(-c r^2) dr$ 的高斯矩之和，其中 $c = 1/(2\\beta^2)$。这些矩的通用公式为 $\\int_0^\\infty x^{2m} e^{-\\gamma x^2} dx = \\frac{\\Gamma(m+1/2)}{2\\gamma^{m+1/2}}$。\n对于我们的情况，$m \\in \\{1, 2, 3\\}$（来自 $r^2, r^4, r^6$ 项）：\n$I_2 = \\int_0^\\infty r^2 e^{-r^2/(2\\beta^2)} dr = \\frac{\\Gamma(3/2)}{2(1/(2\\beta^2))^{3/2}} = \\frac{\\sqrt{2\\pi}\\beta^3}{2}$\n$I_4 = \\int_0^\\infty r^4 e^{-r^2/(2\\beta^2)} dr = \\frac{\\Gamma(5/2)}{2(1/(2\\beta^2))^{5/2}} = \\frac{3\\sqrt{2\\pi}\\beta^5}{2}$\n$I_6 = \\int_0^\\infty r^6 e^{-r^2/(2\\beta^2)} dr = \\frac{\\Gamma(7/2)}{2(1/(2\\beta^2))^{7/2}} = \\frac{15\\sqrt{2\\pi}\\beta^7}{2}$\n\n我们对每个 $n$ 计算积分部分，称之为 $J_n$：\n对于 $n=0$：$J_0 = I_2 = \\frac{\\sqrt{2\\pi}\\beta^3}{2}$。\n对于 $n=1$：$J_1 = \\int_0^\\infty r^2 (-\\frac{r^2}{a^2} + \\frac{3}{2}) e^{-r^2/(2\\beta^2)} dr = \\frac{3}{2}I_2 - \\frac{1}{a^2}I_4 = \\frac{3\\sqrt{2\\pi}\\beta^3}{4} - \\frac{3\\sqrt{2\\pi}\\beta^5}{2a^2} = \\frac{3\\sqrt{2\\pi}\\beta^3}{4} \\left(1-\\frac{2\\beta^2}{a^2}\\right)$。\n对于 $n=2$：$J_2 = \\int_0^\\infty r^2 (\\frac{r^4}{2a^4} - \\frac{5r^2}{2a^2} + \\frac{15}{8}) e^{-r^2/(2\\beta^2)} dr = \\frac{1}{2a^4}I_6 - \\frac{5}{2a^2}I_4 + \\frac{15}{8}I_2 = \\frac{15\\sqrt{2\\pi}\\beta^3}{16} \\left(\\frac{4\\beta^4}{a^4} - \\frac{4\\beta^2}{a^2} + 1\\right) = \\frac{15\\sqrt{2\\pi}\\beta^3}{16} \\left(1-\\frac{2\\beta^2}{a^2}\\right)^2$。\n\n归一化常数 $C_n(a)$ 为：\n$C_0(a) = \\pi^{-3/4}a^{-3/2}$\n$C_1(a) = \\sqrt{2/3}\\,\\pi^{-3/4}a^{-3/2}$\n$C_2(a) = \\sqrt{8/15}\\,\\pi^{-3/4}a^{-3/2}$\n\n将这些部分组合起来，得到 $Z_n(\\sigma)$ 的最终表达式。我们使用简化式 $1-\\frac{2\\beta^2}{a^2} = 1-\\frac{2\\sigma^2}{a^2+\\sigma^2} = \\frac{a^2-\\sigma^2}{a^2+\\sigma^2}$。\n\n对于 $n=0$：\n$Z_0(\\sigma) = 4\\pi^{1/4}(\\pi^{-3/4}a^{-3/2})\\sigma^{-3/2} \\frac{\\sqrt{2\\pi}\\beta^3}{2} = 2\\sqrt{2}a^{-3/2}\\sigma^{-3/2}\\beta^3 = 2\\sqrt{2}a^{-3/2}\\sigma^{-3/2}\\frac{a^3\\sigma^3}{(a^2+\\sigma^2)^{3/2}} = 2\\sqrt{2}\\left(\\frac{a\\sigma}{a^2+\\sigma^2}\\right)^{3/2}$。\n\n对于 $n=1$：\n$Z_1(\\sigma) = 4\\pi^{1/4}(\\sqrt{2/3}\\,\\pi^{-3/4}a^{-3/2})\\sigma^{-3/2} \\frac{3\\sqrt{2\\pi}\\beta^3}{4}(1-\\frac{2\\beta^2}{a^2}) = 2\\sqrt{3}a^{-3/2}\\sigma^{-3/2}\\beta^3\\left(\\frac{a^2-\\sigma^2}{a^2+\\sigma^2}\\right) = 2\\sqrt{3}\\left(\\frac{a\\sigma}{a^2+\\sigma^2}\\right)^{3/2}\\left(\\frac{a^2-\\sigma^2}{a^2+\\sigma^2}\\right)$。\n\n对于 $n=2$：\n$Z_2(\\sigma) = 4\\pi^{1/4}(\\sqrt{8/15}\\,\\pi^{-3/4}a^{-3/2})\\sigma^{-3/2} \\frac{15\\sqrt{2\\pi}\\beta^3}{16}(1-\\frac{2\\beta^2}{a^2})^2 = \\sqrt{15}a^{-3/2}\\sigma^{-3/2}\\beta^3\\left(\\frac{a^2-\\sigma^2}{a^2+\\sigma^2}\\right)^2 = \\sqrt{15}\\left(\\frac{a\\sigma}{a^2+\\sigma^2}\\right)^{3/2}\\left(\\frac{a^2-\\sigma^2}{a^2+\\sigma^2}\\right)^2$。\n\n按规定设 $a=1.0$，我们得到目标函数 $F_n(\\sigma) = |Z_n(\\sigma)|^2$：\n$$F_0(\\sigma) = 8 \\left(\\frac{\\sigma}{1+\\sigma^2}\\right)^3$$\n$$F_1(\\sigma) = 12 \\left(\\frac{\\sigma}{1+\\sigma^2}\\right)^3 \\left(\\frac{1-\\sigma^2}{1+\\sigma^2}\\right)^2$$\n$$F_2(\\sigma) = 15 \\left(\\frac{\\sigma}{1+\\sigma^2}\\right)^3 \\left(\\frac{1-\\sigma^2}{1+\\sigma^2}\\right)^4$$\n\n### 第2部分：优化算法\n\n我们的任务是，对于目标态 $n$，在区间 $[\\sigma_{\\min}, \\sigma_{\\max}]$ 内，相对于涂抹半径 $\\sigma$ 最大化目标函数 $F_n(\\sigma)$。我们将实现一个带有回溯线搜索的投影梯度上升算法。\n\n算法流程如下：\n1.  **初始化**：对于目标态 $n$，从一个初始猜测值 $\\sigma_0$ 开始。设置迭代计数器 $k=0$。\n2.  **梯度计算**：在每次迭代 $k$ 中，计算目标函数的梯度 $g_k = \\frac{dF_n}{d\\sigma}|_{\\sigma_k}$。使用一个数值稳定的中心差分近似：$g_k \\approx \\frac{F_n(\\sigma_k+h) - F_n(\\sigma_k-h)}{2h}$，其中 $h$ 是一个小步长。为遵循边界条件，如果 $\\sigma_k$ 离边界太近导致中心差分无效，则使用单边差分（前向或后向）。\n3.  **线搜索**：使用回溯法找到一个合适的步长 $\\alpha_k$。\n    a. 初始化一个试探步长，例如 $\\alpha = 1.0$。\n    b. 提出一个更新值：$\\sigma' = \\sigma_k + \\alpha g_k$。\n    c. 将提议值投影到有效区间上：$\\sigma_{k+1} = \\max(\\sigma_{\\min}, \\min(\\sigma_{\\max}, \\sigma'))$。\n    d. 使用类 Armijo 条件检查是否有充分的上升：$F_n(\\sigma_{k+1}) \\ge F_n(\\sigma_k) + c_1 \\alpha g_k (\\sigma_{k+1} - \\sigma_k)$，其中 $c_1$ 是一个小常数（例如，$10^{-4}$）。\n    e. 如果条件不满足，则减小步长 $\\alpha \\leftarrow \\tau \\alpha$，其中回溯因子 $\\tau \\in (0,1)$（例如，$0.5$），并从 3b 重复。\n4.  **更新**：设置 $\\sigma_k \\leftarrow \\sigma_{k+1}$。\n5.  **收敛**：迭代该过程，直到连续迭代之间 $\\sigma$ 的变化小于一个容差 $|\\sigma_{k+1} - \\sigma_k| < \\epsilon_{\\text{step}}$，或达到最大迭代次数。\n\n这个迭代过程将在指定边界内找到 $F_n(\\sigma)$ 的一个局部最大值。\n\n### 第3部分：谱权重计算\n\n谱权重 $w_n(\\sigma)$ 量化了每个态 $n$ 对欧几里得时间 $t=0$ 时总信号的贡献。它们的定义如下：\n$$\nw_n(\\sigma) = \\frac{|Z_n(\\sigma)|^2}{\\sum_{m=0}^{N-1} |Z_m(\\sigma)|^2} = \\frac{F_n(\\sigma)}{\\sum_{m=0}^{N-1} F_m(\\sigma)}\n$$\n其中分母中的求和遍及所考虑的态，这里 $N=3$ ($m \\in \\{0, 1, 2\\}$)。\n\n对于每个具有目标态 $n_j$ 的测试用例，在通过最大化 $F_{n_j}(\\sigma)$ 找到优化涂抹半径 $\\sigma_{\\mathrm{opt}}^{(j)}$ 后，我们计算以下量：\n1.  优化后的目标谱权重 $w_{n_j}(\\sigma_{\\mathrm{opt}}^{(j)})$。其计算方法是首先为所有 $m \\in \\{0, 1, 2\\}$ 计算 $F_m(\\sigma_{\\mathrm{opt}}^{(j)})$，然后应用 $w_{n_j}$ 的公式。\n2.  参考谱权重 $w_{n_j}(\\sigma_{\\mathrm{ref}})$，使用固定的参考涂抹 $\\sigma_{\\mathrm{ref}}=1.0$。\n3.  目标谱权重的变化量 $\\Delta w_{n_j} = w_{n_j}(\\sigma_{\\mathrm{opt}}^{(j)}) - w_{n_j}(\\sigma_{\\mathrm{ref}})$。这个量衡量了与参考涂抹分布相比，优化过程在增强目标态信号方面的有效性。\n\n下面的 Python 代码为给定的测试用例实现了这个完整的过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global parameters defined in the problem statement\nA_SCALE = 1.0  # Harmonic oscillator length scale\nSIGMA_REF = 1.0 # Reference smearing radius\nSIGMA_MIN = 0.05 # Minimum bound for optimization\nSIGMA_MAX = 5.0 # Maximum bound for optimization\nN_STATES = 3    # Number of states in the model\n\ndef get_F(n, sigma, a=A_SCALE):\n    \"\"\"\n    Computes the squared overlap F_n(sigma) = |Z_n(sigma)|^2 for a given state n.\n    The formulas are derived for and assume a=1.0.\n    \"\"\"\n    if a != 1.0:\n        raise ValueError(\"This implementation is specific to a=1.0.\")\n    if not (SIGMA_MIN = sigma = SIGMA_MAX):\n        # We handle this robustly, but avoid calls outside the domain.\n        return 0.0\n\n    # Common terms in the derived expressions for F_n\n    term1_base = sigma / (1.0 + sigma**2)\n    term2 = (1.0 - sigma**2) / (1.0 + sigma**2)\n    \n    # The term (sigma/(1+sigma^2))^3, which is prone to underflow for small sigma.\n    # However, Python's float64 is sufficient here.\n    term1_cubed = term1_base**3\n\n    if n == 0:\n        # F_0(sigma) = 8 * (sigma / (1+sigma^2))^3\n        val = 8.0 * term1_cubed\n    elif n == 1:\n        # F_1(sigma) = 12 * (sigma / (1+sigma^2))^3 * ((1-sigma^2)/(1+sigma^2))^2\n        val = 12.0 * term1_cubed * (term2**2)\n    elif n == 2:\n        # F_2(sigma) = 15 * (sigma / (1+sigma^2))^3 * ((1-sigma^2)/(1+sigma^2))^4\n        val = 15.0 * term1_cubed * (term2**4)\n    else:\n        raise ValueError(f\"State n={n} is not supported. Must be in [0, {N_STATES-1}]\")\n    \n    return val\n\ndef get_gradient(n, sigma, a=A_SCALE, h=1e-7):\n    \"\"\"\n    Computes the gradient of F_n with respect to sigma using a finite difference\n    method that respects the optimization bounds.\n    \"\"\"\n    if sigma - h  SIGMA_MIN and sigma + h > SIGMA_MAX: # sigma is the whole interval\n        return 0.0\n    elif sigma - h  SIGMA_MIN: # Near left boundary, use forward difference\n        return (get_F(n, sigma + h, a) - get_F(n, sigma, a)) / h\n    elif sigma + h > SIGMA_MAX: # Near right boundary, use backward difference\n        return (get_F(n, sigma, a) - get_F(n, sigma - h, a)) / h\n    else: # Central difference is safe\n        return (get_F(n, sigma + h, a) - get_F(n, sigma - h, a)) / (2 * h)\n\ndef optimize_sigma(target_n, sigma_0):\n    \"\"\"\n    Maximizes F_n(sigma) using projected gradient ascent with a backtracking line search.\n    \n    Args:\n        target_n (int): The index of the state to optimize for.\n        sigma_0 (float): The initial guess for the smearing radius sigma.\n        \n    Returns:\n        float: The optimized smearing radius sigma_opt.\n    \"\"\"\n    sigma = sigma_0\n    \n    # Optimization parameters\n    max_iter = 1000\n    step_tolerance = 1e-9\n    \n    # Backtracking line search parameters\n    initial_alpha = 1.0  # Initial step size for each iteration\n    c1 = 1e-4          # Sufficient ascent condition constant\n    tau = 0.5          # Step size reduction factor\n\n    for _ in range(max_iter):\n        grad = get_gradient(target_n, sigma)\n        \n        # If gradient is zero, we are at a stationary point\n        if np.abs(grad)  1e-15:\n            break\n\n        # Backtracking line search for step size alpha\n        alpha = initial_alpha\n        current_F = get_F(target_n, sigma)\n        \n        while True:\n            sigma_new_unproj = sigma + alpha * grad\n            sigma_new = np.clip(sigma_new_unproj, SIGMA_MIN, SIGMA_MAX)\n            \n            # Use Armijo-like condition for sufficient ascent\n            if get_F(target_n, sigma_new) >= current_F + c1 * alpha * grad * (sigma_new - sigma):\n                break\n            \n            alpha *= tau\n            if alpha  1e-12:  # Step size is too small, convergence likely\n                return sigma\n\n        sigma_prev = sigma\n        sigma = sigma_new\n        \n        # Check for convergence\n        if np.abs(sigma - sigma_prev)  step_tolerance:\n            break\n            \n    return sigma\n\ndef get_weights(sigma, a=A_SCALE, N=N_STATES):\n    \"\"\"\n    Computes the spectral weights w_n(sigma) for n=0..N-1.\n    \"\"\"\n    F_values = np.array([get_F(n, sigma, a) for n in range(N)])\n    F_sum = np.sum(F_values)\n    if F_sum  1e-15: # Avoid division by zero\n        return np.zeros(N)\n    return F_values / F_sum\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 0.5),   # Target n=0, initial sigma_0=0.5\n        (1, 0.5),   # Target n=1, initial sigma_0=0.5\n        (2, 0.5),   # Target n=2, initial sigma_0=0.5\n        (1, 0.05),  # Target n=1, initial sigma_0=0.05 (boundary start)\n        (0, 5.0),   # Target n=0, initial sigma_0=5.0 (boundary start)\n    ]\n\n    results = []\n    \n    for n_target, sigma_0 in test_cases:\n        # 1. Optimize sigma\n        sigma_opt = optimize_sigma(n_target, sigma_0)\n        \n        # 2. Compute optimized spectral weight\n        weights_opt = get_weights(sigma_opt)\n        w_n_opt = weights_opt[n_target]\n        \n        # 3. Compute change in spectral weight\n        weights_ref = get_weights(SIGMA_REF)\n        w_n_ref = weights_ref[n_target]\n        delta_w_n = w_n_opt - w_n_ref\n        \n        results.extend([sigma_opt, w_n_opt, delta_w_n])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从关联函数分析中提取出能量本征值后，一个基本问题随之而来：这些数值真的描述了一个相对论性粒子吗？一个关键的验证步骤是检查计算出的能量 $E$ 和动量 $p$ 是否遵循连续时空下的能量-动量色散关系。这项实践练习  让你亲手操作如何将格点数据拟合到关系式 $e^2 = m_0^2 + \\frac{1}{\\xi^2} q^2$ 中，从而提取出有效的“光速”并量化离散效应的大小，这是检验任何谱学计算内部自洽性的核心步骤。",
            "id": "3562992",
            "problem": "给定在有限、立方、可能各向异性的格子上计算出的重-轻介子的离散能量数据。目标是通过提取有效光速参数并仅使用所提供的数据评估色散关系的拟合优度，来检验其与连续谱相对论色散关系的一致性。本问题中的所有量均为无量纲的格点量，因此不需要进行物理单位转换。\n\n基本基础是自然单位制中的相对论能量-动量关系，其中光速设为1。该关系指出，对于一个质量为 $m$、空间动量大小为 $p$ 的单粒子态，\n$$\nE^2 = m^2 + p^2.\n$$\n在一个时间格距为 $a_t$、空间格距为 $a_s$ 的格子上，定义无量纲能量 $e \\equiv a_t E$、无量纲质量 $m_0 \\equiv a_t m$ 和无量纲空间动量 $q \\equiv a_s p$。设空间-时间各向异性为 $\\xi \\equiv a_s/a_t$。在一个线性尺度为 $L$（每个空间方向的格点数）的立方盒子中，空间动量的量子化意味着\n$$\nq(\\mathbf{n}) = \\frac{2\\pi}{L} \\left\\lVert \\mathbf{n} \\right\\rVert, \\quad \\mathbf{n} = (n_x,n_y,n_z), \\quad n_x,n_y,n_z \\in \\mathbb{Z}.\n$$\n综合这些，格点单位下的连续谱色散关系变为\n$$\ne^2 = m_0^2 + \\frac{1}{\\xi^2} \\, q^2.\n$$\n定义每个动量下的有效光速平方为\n$$\nc_{\\mathrm{eff}}^2(\\mathbf{n}) = \\xi^2 \\, \\frac{e(\\mathbf{n})^2 - m_0^2}{q(\\mathbf{n})^2},\n$$\n对于满足 $q(\\mathbf{n}) \\neq 0$ 的 $\\mathbf{n}$。在连续谱极限下，对于所有非零动量，$c_{\\mathrm{eff}}^2(\\mathbf{n}) \\to 1$。\n\n您必须为每个测试用例实现以下任务：\n- 给定 $L$、$\\xi$、$m_0$、动量矢量列表 $\\{\\mathbf{n}_i\\}$、相应的测量能量 $\\{e_i\\}$ 以及相应的能量不确定度 $\\{\\delta e_i\\}$，为每个动量条目计算 $q_i = \\frac{2\\pi}{L} \\|\\mathbf{n}_i\\|$。\n- 从任何除法或拟合过程中排除 $q_i = 0$ 的条目。\n- 对于每个非零动量，计算 $c_{\\mathrm{eff}}^2(\\mathbf{n}_i)$。\n- 执行形式为\n$$\ny_i = c_{\\mathrm{lat}}^2 \\, x_i,\n$$\n的加权最小二乘拟合，其中\n$$\ny_i = e_i^2 - m_0^2, \\quad x_i = \\frac{q_i^2}{\\xi^2},\n$$\n权重为\n$$\nw_i = \\frac{1}{\\sigma_{y_i}^2}, \\quad \\sigma_{y_i} \\approx 2\\, e_i \\, \\delta e_i,\n$$\n假设能量不确定度不相关且质量不确定度可忽略不计。通过原点的加权斜率 $c_{\\mathrm{lat}}^2$ 是与数据最佳匹配的格点有效光速平方的估计量。\n- 计算拟合的约化卡方值，\n$$\n\\chi^2_{\\mathrm{red}} = \\frac{1}{N - 1} \\sum_{i=1}^{N} w_i \\left( y_i - c_{\\mathrm{lat}}^2 x_i \\right)^2,\n$$\n其中 $N$ 是拟合中使用的非零动量数据点的数量。\n- 计算每个动量下的有效光速平方与1的最大绝对偏差，\n$$\n\\Delta_{\\max} = \\max_{i: q_i \\neq 0} \\left| c_{\\mathrm{eff}}^2(\\mathbf{n}_i) - 1 \\right|.\n$$\n- 根据以下标准确定一个通过/失败的布尔值\n$$\n\\left| c_{\\mathrm{lat}}^2 - 1 \\right| \\le 0.05 \\quad \\text{and} \\quad \\chi^2_{\\mathrm{red}} \\le 1.5.\n$$\n\n测试套件：\n为以下四个测试用例提供结果。每个测试用例由 $(L, \\xi, m_0, \\{\\mathbf{n}_i\\}, \\{e_i\\}, \\{\\delta e_i\\})$ 指定。\n\n- 用例1（各向同性格子，近连续谱能量）：\n  - $L = 32$, $\\xi = 1.0$, $m_0 = 0.85$。\n  - 动量和数据：\n    - $\\mathbf{n}_1 = (1,0,0)$, $e_1 = 0.87299$, $\\delta e_1 = 0.0012$。\n    - $\\mathbf{n}_2 = (1,1,0)$, $e_2 = 0.89530$, $\\delta e_2 = 0.0013$。\n    - $\\mathbf{n}_3 = (1,1,1)$, $e_3 = 0.91526$, $\\delta e_3 = 0.0012$。\n    - $\\mathbf{n}_4 = (0,0,0)$, $e_4 = 0.85080$, $\\delta e_4 = 0.0008$。\n\n- 用例2（各向异性格子，近连续谱能量）：\n  - $L = 24$, $\\xi = 3.5$, $m_0 = 0.65$。\n  - 动量和数据：\n    - $\\mathbf{n}_1 = (1,0,0)$, $e_1 = 0.65403$, $\\delta e_1 = 0.0012$。\n    - $\\mathbf{n}_2 = (1,1,0)$, $e_2 = 0.65895$, $\\delta e_2 = 0.0012$。\n    - $\\mathbf{n}_3 = (2,0,0)$, $e_3 = 0.667495$, $\\delta e_3 = 0.0012$。\n    - $\\mathbf{n}_4 = (0,0,0)$, $e_4 = 0.65080$, $\\delta e_4 = 0.0010$。\n\n- 用例3（各向同性格子，为模拟离散化效应而故意夸大了非零动量能量）：\n  - $L = 28$, $\\xi = 1.0$, $m_0 = 1.20$。\n  - 动量和数据：\n    - $\\mathbf{n}_1 = (1,0,0)$, $e_1 = 1.26979$, $\\delta e_1 = 0.0015$。\n    - $\\mathbf{n}_2 = (1,1,0)$, $e_2 = 1.29091$, $\\delta e_2 = 0.0015$。\n    - $\\mathbf{n}_3 = (2,0,0)$, $e_3 = 1.33231$, $\\delta e_3 = 0.0015$。\n    - $\\mathbf{n}_4 = (0,0,0)$, $e_4 = 1.20080$, $\\delta e_4 = 0.0010$。\n\n- 用例4（各向异性格子，包含零动量，不确定度较大）：\n  - $L = 16$, $\\xi = 2.0$, $m_0 = 0.90$。\n  - 动量和数据：\n    - $\\mathbf{n}_1 = (1,0,0)$, $e_1 = 0.92200$, $\\delta e_1 = 0.0050$。\n    - $\\mathbf{n}_2 = (2,0,0)$, $e_2 = 0.98250$, $\\delta e_2 = 0.0050$。\n    - $\\mathbf{n}_3 = (0,0,0)$, $e_3 = 0.90050$, $\\delta e_3 = 0.0030$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的结果，结果为方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是以下形式的列表：\n$$\n[c_{\\mathrm{lat}}^2, \\Delta_{\\max}, \\chi^2_{\\mathrm{red}}, \\text{pass}]\n$$\n其中 $c_{\\mathrm{lat}}^2$、$\\Delta_{\\max}$ 和 $\\chi^2_{\\mathrm{red}}$ 是四舍五入到六位小数的浮点数，而 $\\text{pass}$ 是一个布尔值。例如，总输出应如下所示：\n$$\n[[c_1,\\Delta_1,\\chi_1,\\text{pass}_1],[c_2,\\Delta_2,\\chi_2,\\text{pass}_2],[c_3,\\Delta_3,\\chi_3,\\text{pass}_3],[c_4,\\Delta_4,\\chi_4,\\text{pass}_4]].\n$$",
            "solution": "该问题是有效的。它在科学上基于狭义相对论和格点场论的原理，问题提法清晰，提供了所有必要信息，并且表述客观。\n\n目标是将从格点量子色动力学（QCD）模拟中获得的离散能量-动量数据与连续谱相对论色散关系进行验证。这是强子谱学中的一个标准程序，用于评估和控制由时空离散化引起的系统误差。该分析涉及从数据中提取有效光速参数并评估拟合优度。\n\n此分析的基础是质量为 $m$、动量为 $p$ 的粒子的相对论能量-动量关系：\n$$E^2 = p^2c^2 + m^2c^4$$\n在自然单位制（$c=1$）中，这简化为 $E^2 = p^2 + m^2$。在时空格子上，通过与格距进行缩放，物理量被无量纲化。设 $a_t$ 为时间格距，$a_s$ 为空间格距。无量纲能量为 $e \\equiv a_t E$，无量纲静止质量为 $m_0 \\equiv a_t m$，无量纲空间动量为 $q \\equiv a_s p$。比率 $\\xi \\equiv a_s/a_t$ 是格子各向异性。将这些代入连续谱关系，得到在格子上的目标形式：\n$$ (e/a_t)^2 = (q/a_s)^2 + (m_0/a_t)^2 $$\n$$ e^2/a_t^2 = q^2/a_s^2 + m_0^2/a_t^2 $$\n乘以 $a_t^2$ 得到：\n$$ e^2 = m_0^2 + (a_t/a_s)^2 q^2 = m_0^2 + \\frac{1}{\\xi^2} q^2 $$\n在一个线性尺寸为 $L$（以格点为单位）且具有周期性边界条件的有限立方格子上，允许的空间动量是量子化的。一个粒子的动量矢量为 $\\mathbf{p} = \\frac{2\\pi}{L a_s} \\mathbf{n}$，其中 $\\mathbf{n} = (n_x, n_y, n_z)$ 是一个整数矢量。因此，无量纲动量大小 $q$ 为：\n$$ q(\\mathbf{n}) = a_s |\\mathbf{p}| = a_s \\frac{2\\pi}{L a_s} \\|\\mathbf{n}\\| = \\frac{2\\pi}{L} \\|\\mathbf{n}\\| $$\n对每个测试用例，分析按以下步骤进行。\n\n1.  **数据准备**：对于每个提供的数据点，包括动量矢量 $\\mathbf{n}_i$、测量的能量 $e_i$ 及其不确定度 $\\delta e_i$，我们首先计算相应的无量纲动量大小 $q_i = \\frac{2\\pi}{L} \\sqrt{n_{ix}^2 + n_{iy}^2 + n_{iz}^2}$。对于 $\\mathbf{n}_i = (0,0,0)$，因此 $q_i=0$ 的数据点，用于确定静止质量，但被排除在色散拟合之外，因为关系式 $e^2 = m_0^2$ 不包含关于光速的任何信息。问题直接提供了 $m_0$，因此我们只需过滤掉这些零动量点。\n\n2.  **模型线性化**：为了从数据中确定有效光速，我们重新排列格点色散关系。如果光速不是1，而是某个格点有效值 $c_{\\mathrm{lat}}$，则关系式将为 $e^2 = m_0^2 + c_{\\mathrm{lat}}^2 \\frac{1}{\\xi^2} q^2$。通过定义以下变量，可以将其转换为 $y = a x$ 形式的线性模型（通过原点的回归）：\n    $$ y_i = e_i^2 - m_0^2 $$\n    $$ x_i = \\frac{q_i^2}{\\xi^2} $$\n    这条线的斜率是格点有效光速的平方，$c_{\\mathrm{lat}}^2$。\n\n3.  **加权最小二乘拟合**：由于能量 $e_i$ 的测量带有不确定度 $\\delta e_i$，因此适合使用加权最小二乘拟合，以便为更精确的数据点赋予更大的影响。$y_i$ 的不确定度，记为 $\\sigma_{y_i}$，通过标准误差传播找到。假设 $m_0$ 的不确定度可以忽略不计，则 $\\sigma_{y_i}^2 = (\\frac{\\partial y_i}{\\partial e_i})^2 (\\delta e_i)^2 = (2e_i)^2 (\\delta e_i)^2$。因此，$\\sigma_{y_i} = 2 e_i \\delta e_i$。每个数据点的权重是 $y_i$ 方差的倒数：\n    $$ w_i = \\frac{1}{\\sigma_{y_i}^2} = \\frac{1}{(2 e_i \\delta e_i)^2} $$\n    对于通过原点的线性模型 $y = a x$，斜率 $a$（在我们的例子中是 $c_{\\mathrm{lat}}^2$）的加权最小二乘估计由下式给出：\n    $$ c_{\\mathrm{lat}}^2 = \\frac{\\sum_i w_i x_i y_i}{\\sum_i w_i x_i^2} $$\n    求和遍及所有 $N$ 个具有非零动量的数据点。\n\n4.  **拟合优度**：拟合的质量由约化卡方值 $\\chi^2_{\\mathrm{red}}$ 来量化。它测量数据点与拟合模型之间的加权平均方差，并按自由度数进行归一化。对于一个有 $N$ 个点和1个自由参数（$c_{\\mathrm{lat}}^2$）的拟合，有 $N-1$ 个自由度。\n    $$ \\chi^2_{\\mathrm{red}} = \\frac{1}{N-1} \\sum_{i=1}^{N} w_i (y_i - c_{\\mathrm{lat}}^2 x_i)^2 $$\n    $\\chi^2_{\\mathrm{red}} \\approx 1$ 的值表明数据点围绕模型的散布与估计的不确定度是一致的。\n\n5.  **单个动量的有效光速**：该问题还要求计算单个动量下的光速度量，$c_{\\mathrm{eff}}^2(\\mathbf{n}_i)$。这是通过为每个非零动量数据点求解色散关系中的“光速”项来计算的：\n    $$ c_{\\mathrm{eff}}^2(\\mathbf{n}_i) = \\frac{e_i^2 - m_0^2}{q_i^2 / \\xi^2} = \\xi^2 \\frac{e_i^2 - m_0^2}{q_i^2} $$\n    这些值与预期的连续谱值1之间的最大绝对偏差提供了另一种衡量离散化效应的方法：\n    $$ \\Delta_{\\max} = \\max_{i: q_i \\neq 0} |c_{\\mathrm{eff}}^2(\\mathbf{n}_i) - 1| $$\n\n6.  **验证标准**：最后，根据两个条件确定一个布尔值 `pass` 标志，这两个条件测试数据是否在可接受的容差内与连续谱相对论色散关系一致：\n    -   $|c_{\\mathrm{lat}}^2 - 1| \\le 0.05$：总拟合光速必须在1的 $5\\%$ 范围内。\n    -   $\\chi^2_{\\mathrm{red}} \\le 1.5$：拟合在统计上必须是好的。\n\n将对每个测试用例应用此完整过程，以生成所需的结果。",
            "answer": "```python\nimport numpy as np\n\ndef analyze_dispersion(L, xi, m0, data):\n    \"\"\"\n    Analyzes discrete energy-momentum data from a lattice simulation.\n    \n    Args:\n        L (int): Linear extent of the cubic lattice.\n        xi (float): Spatial-to-temporal anisotropy (a_s/a_t).\n        m0 (float): Dimensionless rest mass (a_t * m).\n        data (list of tuples): Each tuple contains (n_vec, e, delta_e),\n                               where n_vec is a momentum vector (nx, ny, nz),\n                               e is the dimensionless energy, and delta_e is its uncertainty.\n\n    Returns:\n        list: A list containing [c_lat_sq, delta_max, chi2_red, pass_bool].\n    \"\"\"\n    \n    # Filter out zero-momentum points and prepare lists for fitting\n    fit_data = []\n    for n_vec, e, delta_e in data:\n        n_squared = np.sum(np.square(n_vec))\n        if n_squared == 0:\n            continue\n        \n        q = (2 * np.pi / L) * np.sqrt(n_squared)\n        fit_data.append({'q': q, 'e': e, 'delta_e': delta_e, 'n_vec': n_vec})\n\n    if not fit_data:\n        # Handle cases with no non-zero momentum points if necessary\n        # Though the test cases provided have them.\n        return [np.nan, np.nan, np.nan, False]\n\n    N = len(fit_data)\n    m0_sq = m0**2\n    xi_sq = xi**2\n\n    # Calculate quantities for the linear fit y = a*x\n    x_i = np.array([p['q']**2 / xi_sq for p in fit_data])\n    y_i = np.array([p['e']**2 - m0_sq for p in fit_data])\n    \n    # Calculate weights\n    e_i = np.array([p['e'] for p in fit_data])\n    delta_e_i = np.array([p['delta_e'] for p in fit_data])\n    sigma_y_i = 2 * e_i * delta_e_i\n    w_i = 1 / (sigma_y_i**2)\n\n    # --- 1. Calculate c_lat^2 (weighted least-squares slope) ---\n    numerator = np.sum(w_i * x_i * y_i)\n    denominator = np.sum(w_i * x_i**2)\n    c_lat_sq = numerator / denominator\n\n    # --- 2. Calculate reduced chi-square (chi^2_red) ---\n    residuals = y_i - c_lat_sq * x_i\n    chi_sq = np.sum(w_i * residuals**2)\n    degrees_of_freedom = N - 1\n    if degrees_of_freedom = 0:\n        chi2_red = np.inf # Or handle as an error\n    else:\n        chi2_red = chi_sq / degrees_of_freedom\n\n    # --- 3. Calculate Delta_max ---\n    q_sq = np.array([p['q']**2 for p in fit_data])\n    c_eff_sq_i = xi_sq * y_i / q_sq\n    delta_max = np.max(np.abs(c_eff_sq_i - 1))\n\n    # --- 4. Determine pass/fail status ---\n    pass_c_lat = np.abs(c_lat_sq - 1) = 0.05\n    pass_chi2 = chi2_red = 1.5\n    pass_bool = pass_c_lat and pass_chi2\n\n    return [c_lat_sq, delta_max, chi2_red, pass_bool]\n\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the dispersion relation analysis.\n    \"\"\"\n    test_cases = [\n        {\n            \"L\": 32, \"xi\": 1.0, \"m0\": 0.85,\n            \"data\": [\n                ((1, 0, 0), 0.87299, 0.0012),\n                ((1, 1, 0), 0.89530, 0.0013),\n                ((1, 1, 1), 0.91526, 0.0012),\n                ((0, 0, 0), 0.85080, 0.0008),\n            ]\n        },\n        {\n            \"L\": 24, \"xi\": 3.5, \"m0\": 0.65,\n            \"data\": [\n                ((1, 0, 0), 0.65403, 0.0012),\n                ((1, 1, 0), 0.65895, 0.0012),\n                ((2, 0, 0), 0.667495, 0.0012),\n                ((0, 0, 0), 0.65080, 0.0010),\n            ]\n        },\n        {\n            \"L\": 28, \"xi\": 1.0, \"m0\": 1.20,\n            \"data\": [\n                ((1, 0, 0), 1.26979, 0.0015),\n                ((1, 1, 0), 1.29091, 0.0015),\n                ((2, 0, 0), 1.33231, 0.0015),\n                ((0, 0, 0), 1.20080, 0.0010),\n            ]\n        },\n        {\n            \"L\": 16, \"xi\": 2.0, \"m0\": 0.90,\n            \"data\": [\n                ((1, 0, 0), 0.92200, 0.0050),\n                ((2, 0, 0), 0.98250, 0.0050),\n                ((0, 0, 0), 0.90050, 0.0030),\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_dispersion(case[\"L\"], case[\"xi\"], case[\"m0\"], case[\"data\"])\n        results.append(result)\n\n    def format_result(res):\n        c_lat_sq_str = f\"{res[0]:.6f}\"\n        delta_max_str = f\"{res[1]:.6f}\"\n        chi2_red_str = f\"{res[2]:.6f}\"\n        pass_str = \"True\" if res[3] else \"False\"\n        return f\"[{c_lat_sq_str},{delta_max_str},{chi2_red_str},{pass_str.lower()}]\"\n    \n    formatted_strings = [format_result(r) for r in results]\n    print(f\"[{','.join(formatted_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "格点计算是在离散时空中进行的，而物理世界是连续的。为了做出物理预测，我们必须通过在多个不同的格点间距 $a$ 上进行模拟，并取 $a \\to 0$ 的极限，来执行“连续极限外推”。这最后一项实践练习  介绍了一种强大的分析技术：对来自不同格点离散化方案的数据进行联合拟合。通过强制所有数据共享同一个连续极限终点，同时允许与方案相关的截断效应存在差异，该方法利用了“普适性”原理，从而得出一个更稳健、更可靠的物理结果。",
            "id": "3562999",
            "problem": "给定两种在格点量子色动力学 (LQCD) 中常用的夸克作用量离散化方案：$\\mathcal{O}(a)$ 改进的 Sheikholeslami–Wohlert (clover) 作用量和畴壁费米子 (DWF) 作用量。根据用于处理格点赝象的 Symanzik 有效理论，在格点间距 $a$ 下提取的强子质量可以展开为 $M(a)=M_0+c_1 a+c_2 a^2+\\mathcal{O}(a^3)$，其中 $M_0$ 是以吉电子伏特 (GeV) 为单位的连续极限，$a$ 以飞米 (fm) 为单位，而 $c_1$, $c_2$ 是依赖于离散化方案的系数。不同离散化方案的系数是方案依赖的，但连续极限 $M_0$ 是方案无关的。畴壁费米子 (DWF) 在非零格点间距下保持手征对称性，这使得 $c_1$ 自然很小或为零，而对于 $\\mathcal{O}(a)$ 改进的 clover 费米子，线性项通过改进被压低，但不能保证其精确为零。\n\n从以下基本依据出发：\n- 在 LQCD 中，欧几里得两点关联函数的谱分解意味着基态强子质量在连续极限 $a \\to 0$ 下是良定义的。\n- Symanzik 有效理论将离散化效应组织成 $a$ 的幂级数展开，因此对于足够小的 $a$ ，$M(a)$ 可以用一个关于 $a$ 的低阶多项式来描述，其系数依赖于所用的作用量。\n- 对于不相关测量，加权最小二乘法通过最小化 $\\chi^2=\\sum_i (y_i - f(x_i;\\theta))^2/\\sigma_i^2$ 来进行拟合，其中 $y_i$ 是标准差为 $\\sigma_i$ 的测量值，$x_i$ 是输入值，$\\theta$ 是模型参数。\n\n你的任务是使用加权线性最小二乘法，对 clover 和 DWF 离散化方案下的强子质量进行联合连续极限外推，模型为 $M(a)=M_0+c_1 a+c_2 a^2$，并满足以下要求：\n\n$1.$ 构建一个联合拟合，其中 clover 和 DWF 数据共享一个共同的 $M_0$，但具有独立的截断效应系数。即，拟合一个参数为 $\\{M_0, c_{1,\\mathrm{clover}}, c_{2,\\mathrm{clover}}, c_{1,\\mathrm{DWF}}, c_{2,\\mathrm{DWF}}\\}$ 的模型，其中 clover 数据行对设计矩阵的贡献为 $\\{1,a,a^2,0,0\\}$，DWF 数据行对设计矩阵的贡献为 $\\{1,0,0,a,a^2\\}$。对于指定的测试用例，你还必须能够施加由手征对称性启发的约束 $c_{1,\\mathrm{DWF}}=0$，此时 DWF 数据行变为 $\\{1,0,0,0,a^2\\}$，参数集也相应减少。\n\n$2.$ 除了联合拟合，还需对 clover 数据和 DWF 数据分别进行独立的加权二次拟合，形式均为 $M(a)=M_{0,\\mathrm{scheme}}+c_{1,\\mathrm{scheme}} a+c_{2,\\mathrm{scheme}} a^2$。\n\n$3.$ 通过两种方式量化“方案依赖性”：\n- 通过检验 $|M_{0,\\mathrm{clover}}-M_{0,\\mathrm{DWF}}|\\leq 2\\sqrt{\\sigma^2(M_{0,\\mathrm{clover}})+\\sigma^2(M_{0,\\mathrm{DWF}})}$ 是否成立，来测试独立方案的连续极限是否一致，其中 $\\sigma^2(\\cdot)$ 是来自独立拟合的方差。如果该不等式成立，则报告布尔值 $\\mathrm{True}$，否则报告 $\\mathrm{False}$。\n- 通过检验 $|c_{1,\\mathrm{DWF}}|\\leq 2\\,\\sigma(c_{1,\\mathrm{DWF}})$ 是否成立，来测试独立 DWF 拟合得到的 $c_{1,\\mathrm{DWF}}$ 在两个标准差水平上是否与零在统计上一致。报告一个布尔值。\n\n$4.$ 通过 $\\chi^2/\\mathrm{dof}$ 报告联合拟合的拟合优度，其中 $\\mathrm{dof}=N-p$，$N$ 是两种方案的数据点总数，$p$ 是联合拟合中的拟合参数数量。当测试用例不要求约束时，使用无约束的联合拟合；当要求约束时，使用有约束的版本。\n\n$5.$ 单位和四舍五入：\n- 所有质量必须以 GeV 为单位处理，所有格点间距以 fm 为单位处理。\n- 对每个测试用例，你的程序必须输出联合拟合估计的 $M_0$（单位 GeV），四舍五入到 $6$ 位小数。\n- 对每个测试用例，你的程序必须输出联合拟合的 $\\chi^2/\\mathrm{dof}$，四舍五入到 $3$ 位小数。\n\n$6.$ 测试套件：\n实现你的程序，为以下三个测试用例计算结果。在所有情况下，将引用的值视为中心值，其不相关高斯标准差如给定。数组给出了格点间距、测量的质量及其标准差。\n\n- 用例 $1$ (无约束联合拟合):\n  Clover:\n  $a_{\\mathrm{C}}=\\{0.12,0.09,0.06,0.045\\}\\,\\mathrm{fm}$,\n  $M_{\\mathrm{C}}=\\{0.9640,0.95765,0.9537,0.9499375\\}\\,\\mathrm{GeV}$,\n  $\\sigma_{\\mathrm{C}}=\\{0.0025,0.0020,0.0018,0.0016\\}\\,\\mathrm{GeV}$.\n  DWF:\n  $a_{\\mathrm{D}}=\\{0.12,0.09,0.06,0.045\\}\\,\\mathrm{fm}$,\n  $M_{\\mathrm{D}}=\\{0.94372,0.94333,0.94068,0.9408075\\}\\,\\mathrm{GeV}$,\n  $\\sigma_{\\mathrm{D}}=\\{0.0020,0.0018,0.0016,0.0015\\}\\,\\mathrm{GeV}$.\n\n- 用例 $2$ (有约束联合拟合，$c_{1,\\mathrm{DWF}}=0$):\n  Clover:\n  $a_{\\mathrm{C}}=\\{0.10,0.08,0.06\\}\\,\\mathrm{fm}$,\n  $M_{\\mathrm{C}}=\\{1.1925,1.19298,1.19492\\}\\,\\mathrm{GeV}$,\n  $\\sigma_{\\mathrm{C}}=\\{0.0015,0.0013,0.0012\\}\\,\\mathrm{GeV}$.\n  DWF:\n  $a_{\\mathrm{D}}=\\{0.12,0.09,0.07\\}\\,\\mathrm{fm}$,\n  $M_{\\mathrm{D}}=\\{1.20032,1.200605,1.200545\\}\\,\\mathrm{GeV}$,\n  $\\sigma_{\\mathrm{D}}=\\{0.0014,0.0013,0.0012\\}\\,\\mathrm{GeV}$.\n\n- 用例 $3$ (无约束联合拟合，更细的格点):\n  Clover:\n  $a_{\\mathrm{C}}=\\{0.08,0.06,0.04,0.03,0.02\\}\\,\\mathrm{fm}$,\n  $M_{\\mathrm{C}}=\\{0.5017,0.5011,0.50085,0.50052,0.50042\\}\\,\\mathrm{GeV}$,\n  $\\sigma_{\\mathrm{C}}=\\{0.0005,0.0004,0.00035,0.0003,0.00025\\}\\,\\mathrm{GeV}$.\n  DWF:\n  $a_{\\mathrm{D}}=\\{0.08,0.06,0.04,0.03,0.02\\}\\,\\mathrm{fm}$,\n  $M_{\\mathrm{D}}=\\{0.499812,0.499998,0.499948,0.500012,0.499982\\}\\,\\mathrm{GeV}$,\n  $\\sigma_{\\mathrm{D}}=\\{0.0005,0.0004,0.00035,0.0003,0.00025\\}\\,\\mathrm{GeV}$.\n\n$7.$ 最终输出格式：\n你的程序应生成单行输出，其中包含三个用例的汇总结果，格式为逗号分隔的 Python 风格列表。按顺序为每个用例输出以下四项：\n- 联合拟合估计的 $M_0$（单位 GeV），四舍五入到 $6$ 位小数，\n- 联合拟合的 $\\chi^2/\\mathrm{dof}$，四舍五入到 $3$ 位小数，\n- 用于判断 $M_{0,\\mathrm{clover}}$ 和 $M_{0,\\mathrm{DWF}}$ 在独立拟合的两个标准差内是否一致的布尔值，\n- 用于判断 $c_{1,\\mathrm{DWF}}$ 在独立 DWF 拟合的两个标准差内是否与零一致的布尔值。\n\n因此，你的程序必须打印一行格式如下的输出\n$[M0\\_1,\\chi2dof\\_1,\\mathrm{bool1},\\mathrm{bool2},M0\\_2,\\chi2dof\\_2,\\mathrm{bool3},\\mathrm{bool4},M0\\_3,\\chi2dof\\_3,\\mathrm{bool5},\\mathrm{bool6}]$,\n其中 $M0\\_k$ 以 $\\mathrm{GeV}$ 为单位，$\\chi2dof\\_k$ 无量纲。",
            "solution": "该问题要求对来自两种不同格点 QCD 离散化方案（Clover 和畴壁费米子 DWF）的强子质量数据进行联合连续极限外推，并将结果与独立外推进行比较。这是格点 QCD 中去除离散化赝象并确定连续极限 ($a \\to 0$) 下物理量的标准流程。该过程依赖于几个基本原理。\n\n首先，Symanzik 有效理论为外推模型提供了理论基础。它指出，对于改进到特定阶数的一种格点作用量，物理可观测量（如强子质量 $M(a)$）中的离散化误差可以表示为格点间距 $a$ 的幂级数。对于本问题所考虑的作用量，二次模型 $M(a) = M_0 + c_1 a + c_2 a^2$ 是在 $a$ 足够小时的一个合适的低阶截断。参数 $M_0$ 代表连续极限下的真实物理质量，它必须与正则化方案无关（即，对 Clover 和 DWF 都是相同的）。然而，系数 $c_1$ 和 $c_2$ 是方案依赖的。DWF 作用量具有近似的手征对称性，可以压低线性项，这表明 $c_{1,\\mathrm{DWF}}$ 应该很小且在统计上与零一致。\n\n其次，确定模型参数 $\\{M_0, c_1, c_2, \\dots\\}$ 的拟合过程基于加权最小二乘法。给定一组 $N$ 个具有不相关高斯不确定度 $\\sigma_i$ 的数据点 $(a_i, M_i)$，该方法找到使卡方函数 $\\chi^2$ 最小化的参数矢量 $\\hat{\\theta}$：\n\n$$\n\\chi^2 = \\sum_{i=1}^{N} \\frac{(M_i - M(a_i; \\theta))^2}{\\sigma_i^2}\n$$\n\n对于高斯分布的误差，最小化 $\\chi^2$ 等价于最大似然原理。对于形式为 $M(a; \\theta) = \\sum_j X_{ij} \\theta_j$ 的线性模型，其中 $X$ 是设计矩阵，解由正规方程给出：\n\n$$\n(X^T W X) \\hat{\\theta} = X^T W y\n$$\n\n在这里，$y$ 是测量质量 $M_i$ 的向量，$\\hat{\\theta}$ 是最佳拟合参数的向量，$W$ 是一个对角权重矩阵，其元素为 $W_{ii} = 1/\\sigma_i^2$。参数的解为 $\\hat{\\theta} = (X^T W X)^{-1} X^T W y$。拟合参数的统计不确定度从它们的协方差矩阵 $C = (X^T W X)^{-1}$ 导出。第 $j$ 个参数的方差为 $\\sigma^2(\\hat{\\theta}_j) = C_{jj}$。\n\n实现将通过定义一个通用函数来求解这些正规方程。该函数将以设计矩阵 $X$、数据向量 $y$ 和不确定度向量 $\\sigma$ 作为输入，并返回参数向量 $\\hat{\\theta}$ 和协方差矩阵 $C$。\n\n分析涉及三种类型的拟合：\n\n1.  **独立 Clover 拟合**：\n    模型为 $M(a) = M_{0,\\mathrm{clover}} + c_{1,\\mathrm{clover}} a + c_{2,\\mathrm{clover}} a^2$。参数向量为 $\\theta_C = [M_{0,C}, c_{1,C}, c_{2,C}]^T$。对于一组 $N_C$ 个 Clover 数据点，设计矩阵 $X_C$ 是一个 $N_C \\times 3$ 的矩阵，其中第 $i$ 行为 $[1, a_i, a_i^2]$。\n\n2.  **独立 DWF 拟合**：\n    类似地，模型为 $M(a) = M_{0,\\mathrm{DWF}} + c_{1,\\mathrm{DWF}} a + c_{2,\\mathrm{DWF}} a^2$。参数向量为 $\\theta_D = [M_{0,D}, c_{1,D}, c_{2,D}]^T$，而 $N_D \\times 3$ 的设计矩阵 $X_D$ 的行为 $[1, a_i, a_i^2]$。\n\n3.  **联合拟合**：\n    这里的关键物理原理是连续极限质量 $M_0$ 是普适的。因此，我们对所有 $N = N_C + N_D$ 个数据点进行组合拟合，使用单个 $M_0$ 但分开的、方案依赖的系数。\n    -   **无约束拟合**：参数向量为 $\\theta_J = [M_0, c_{1,C}, c_{2,C}, c_{1,D}, c_{2,D}]^T$。设计矩阵 $X_J$ 是一个 $N \\times 5$ 的矩阵。对于一个位于 $a_i$ 的 Clover 数据点，对应的行为 $[1, a_i, a_i^2, 0, 0]$。对于一个位于 $a_j$ 的 DWF 数据点，行为 $[1, 0, 0, a_j, a_j^2]$。\n    -   **有约束拟合**：在某些测试用例中，假定 DWF 的手征对称性足够精确，可以强制 $c_{1,D}=0$，此时该参数将从拟合中移除。参数向量变为 $\\theta_{J,c} = [M_0, c_{1,C}, c_{2,C}, c_{2,D}]^T$。设计矩阵 $X_{J,c}$ 是一个 $N \\times 4$ 的矩阵。Clover 点的行为 $[1, a_i, a_i^2, 0]$，而 DWF 点的行为 $[1, 0, 0, a_j^2]$。\n\n对于每个测试用例，算法将：\n-   对 Clover 和 DWF 数据进行独立拟合，以获得 $M_{0,C}$、$\\sigma^2(M_{0,C})$、$M_{0,D}$、$\\sigma^2(M_{0,D})$、$c_{1,D}$ 和 $\\sigma(c_{1,D})$。\n-   执行指定的联合拟合（有约束或无约束）以获得连续极限质量的主要结果 $M_0$。\n-   计算联合拟合的拟合优度 $\\chi^2/\\mathrm{dof}$。自由度为 $\\mathrm{dof} = N - p$，其中 $N$ 是数据点总数，$p$ 是联合拟合中的参数数量（无约束为 $p=5$，有约束为 $p=4$）。\n-   根据*独立拟合*的结果评估两个布尔条件：\n    1.  检验连续极限的一致性：$|M_{0,C}-M_{0,D}| \\leq 2\\sqrt{\\sigma^2(M_{0,C})+\\sigma^2(M_{0,D})}$。这检验了 $M_0$ 的两个独立测定值是否在其差值的两个标准差内一致。\n    2.  检验手征对称性行为：$|c_{1,D}| \\leq 2\\,\\sigma(c_{1,D})$。这检验了 DWF 的线性离散项在 $95\\%$ 置信水平上是否与零一致。\n\n最终，将联合拟合的 $M_0$、其 $\\chi^2/\\mathrm{dof}$ 以及来自独立拟合的两个布尔检验结果合并，针对所有测试用例，并按指定格式输出。所有数值计算将使用 `numpy` 库进行矩阵运算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the hadron spectroscopy continuum extrapolation problem.\n    It defines the test cases, processes each one, and prints the final combined result.\n    \"\"\"\n\n    def weighted_least_squares(X, y, sigma):\n        \"\"\"\n        Performs weighted linear least squares fitting.\n        \n        Args:\n            X (np.ndarray): The design matrix.\n            y (np.ndarray): The vector of observed values.\n            sigma (np.ndarray): The vector of standard deviations for the observations.\n\n        Returns:\n            tuple: A tuple containing:\n                - np.ndarray: The vector of best-fit parameters.\n                - np.ndarray: The covariance matrix of the parameters.\n        \"\"\"\n        w = 1.0 / sigma**2\n        # Numerically stable way to compute (X.T * W) @ X and (X.T * W) @ y\n        # where W is a diagonal matrix of weights.\n        XT_W = X.T * w\n        XTWX = XT_W @ X\n        XTWy = XT_W @ y\n        \n        # Solve the normal equations: (X.T W X) theta = X.T W y\n        parameters = np.linalg.solve(XTWX, XTWy)\n        \n        # The covariance matrix is the inverse of (X.T W X)\n        covariance_matrix = np.linalg.inv(XTWX)\n        \n        return parameters, covariance_matrix\n\n    def process_case(clover_data, dwf_data, constrained):\n        \"\"\"\n        Processes a single test case, performing separate and joint fits.\n        \n        Args:\n            clover_data (tuple): Contains a, M, sigma arrays for Clover.\n            dwf_data (tuple): Contains a, M, sigma arrays for DWF.\n            constrained (bool): True if the joint fit is constrained (c1_DWF=0).\n\n        Returns:\n            list: A list containing [M0_joint, chi2dof, bool_M0_agree, bool_c1_is_zero].\n        \"\"\"\n        a_c, M_c, s_c = clover_data\n        a_d, M_d, s_d = dwf_data\n\n        # 1. Separate Clover Fit\n        X_c = np.vstack([np.ones_like(a_c), a_c, a_c**2]).T\n        params_c, cov_c = weighted_least_squares(X_c, M_c, s_c)\n        M0_clover = params_c[0]\n        var_M0_clover = cov_c[0, 0]\n\n        # 2. Separate DWF Fit\n        X_d = np.vstack([np.ones_like(a_d), a_d, a_d**2]).T\n        params_d, cov_d = weighted_least_squares(X_d, M_d, s_d)\n        M0_dwf = params_d[0]\n        var_M0_dwf = cov_d[0, 0]\n        c1_dwf = params_d[1]\n        sigma_c1_dwf = np.sqrt(cov_d[1, 1])\n\n        # 3. Joint Fit (constrained or unconstrained)\n        y_joint = np.concatenate([M_c, M_d])\n        s_joint = np.concatenate([s_c, s_d])\n        n_c = len(a_c)\n        n_d = len(a_d)\n        N = n_c + n_d\n\n        if not constrained:\n            # Unconstrained joint fit: {M0, c1_C, c2_C, c1_D, c2_D}\n            p = 5\n            X_joint = np.zeros((N, p))\n            # Clover rows\n            X_joint[:n_c, 0] = 1\n            X_joint[:n_c, 1] = a_c\n            X_joint[:n_c, 2] = a_c**2\n            # DWF rows\n            X_joint[n_c:, 0] = 1\n            X_joint[n_c:, 3] = a_d\n            X_joint[n_c:, 4] = a_d**2\n        else:\n            # Constrained joint fit (c1_DWF = 0): {M0, c1_C, c2_C, c2_D}\n            p = 4\n            X_joint = np.zeros((N, p))\n            # Clover rows\n            X_joint[:n_c, 0] = 1\n            X_joint[:n_c, 1] = a_c\n            X_joint[:n_c, 2] = a_c**2\n            # DWF rows\n            X_joint[n_c:, 0] = 1\n            X_joint[n_c:, 3] = a_d**2\n\n        params_joint, _ = weighted_least_squares(X_joint, y_joint, s_joint)\n        M0_joint = params_joint[0]\n        \n        # 4. Goodness-of-fit for joint fit\n        residuals = y_joint - (X_joint @ params_joint)\n        chi2 = np.sum((residuals / s_joint)**2)\n        dof = N - p\n        chi2_dof = chi2 / dof if dof > 0 else 0.0\n\n        # 5. Scheme dependence tests from separate fits\n        # Test 1: Agreement of continuum limits\n        m0_diff = np.abs(M0_clover - M0_dwf)\n        m0_err_sum = np.sqrt(var_M0_clover + var_M0_dwf)\n        bool_M0_agree = m0_diff = 2 * m0_err_sum\n\n        # Test 2: Consistency of c1_DWF with zero\n        bool_c1_is_zero = np.abs(c1_dwf) = 2 * sigma_c1_dwf\n\n        return [\n            round(M0_joint, 6),\n            round(chi2_dof, 3),\n            bool_M0_agree,\n            bool_c1_is_zero\n        ]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (unconstrained)\n        {\n            \"clover_data\": (\n                np.array([0.12, 0.09, 0.06, 0.045]),\n                np.array([0.9640, 0.95765, 0.9537, 0.9499375]),\n                np.array([0.0025, 0.0020, 0.0018, 0.0016])\n            ),\n            \"dwf_data\": (\n                np.array([0.12, 0.09, 0.06, 0.045]),\n                np.array([0.94372, 0.94333, 0.94068, 0.9408075]),\n                np.array([0.0020, 0.0018, 0.0016, 0.0015])\n            ),\n            \"constrained\": False\n        },\n        # Case 2 (constrained)\n        {\n            \"clover_data\": (\n                np.array([0.10, 0.08, 0.06]),\n                np.array([1.1925, 1.19298, 1.19492]),\n                np.array([0.0015, 0.0013, 0.0012])\n            ),\n            \"dwf_data\": (\n                np.array([0.12, 0.09, 0.07]),\n                np.array([1.20032, 1.200605, 1.200545]),\n                np.array([0.0014, 0.0013, 0.0012])\n            ),\n            \"constrained\": True\n        },\n        # Case 3 (unconstrained)\n        {\n            \"clover_data\": (\n                np.array([0.08, 0.06, 0.04, 0.03, 0.02]),\n                np.array([0.5017, 0.5011, 0.50085, 0.50052, 0.50042]),\n                np.array([0.0005, 0.0004, 0.00035, 0.0003, 0.00025])\n            ),\n            \"dwf_data\": (\n                np.array([0.08, 0.06, 0.04, 0.03, 0.02]),\n                np.array([0.499812, 0.499998, 0.499948, 0.500012, 0.499982]),\n                np.array([0.0005, 0.0004, 0.00035, 0.0003, 0.00025])\n            ),\n            \"constrained\": False\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = process_case(case[\"clover_data\"], case[\"dwf_data\"], case[\"constrained\"])\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    # Convert booleans to lowercase strings as per Python's str(True) -> 'True'\n    formatted_results = [f\"{x}\".lower() if isinstance(x, bool) else str(x) for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}