{
    "hands_on_practices": [
        {
            "introduction": "这项实践将聚焦于任何Lüscher方法分析中的第一个关键步骤：将从有限体积计算中获得的离散能量本征值转换成相应的质心（CM）散射动量。这种相对论运动学关系是连接数值模拟语言（能量）与散射理论语言（动量）的基础桥梁。通过这项动手推导练习 ，您将巩固对这些基本物理量之间关系的理解。",
            "id": "3603739",
            "problem": "考虑两个静止质量分别为 $m_1$ 和 $m_2$ 的可分辨无自旋粒子，在周期性立方体积中发生弹性散射。这种情况在计算核物理中使用的有限体积谱学中会遇到。设总四动量为 $P^{\\mu}$，并定义洛伦兹不变量能量平方 $s \\equiv P^{\\mu}P_{\\mu}$。在质心 (CM) 系中，总能量为 $E^{\\ast}$，因此 $s = E^{\\ast 2}$，并且两个粒子具有大小相等、方向相反的三维动量，其大小为 $p^{\\ast}$。各个在壳质心能量满足 $E_1^{\\ast} = \\sqrt{m_1^2 + p^{\\ast 2}}$ 和 $E_2^{\\ast} = \\sqrt{m_2^2 + p^{\\ast 2}}$，其中 $E^{\\ast} = E_1^{\\ast} + E_2^{\\ast}$。从四动量守恒、洛伦兹不变性和相对论在壳条件出发，推导一个完全用 $E^{\\ast}$、$m_1$ 和 $m_2$ 表示的 $p^{\\ast 2}$ 的闭合形式表达式。你可以用 Källén 函数 $\\lambda(x,y,z)$ 来表示最终结果，其定义为 $\\lambda(x,y,z) = x^2 + y^2 + z^2 - 2xy - 2xz - 2yz$。然后，简要解释为什么在 Lüscher 方法中，这个从 $E^{\\ast}$ 到 $p^{\\ast}$ 的映射对于将离散的有限体积能量与无限体积弹性散射相移联系起来至关重要，以及它如何与有限体积量子化条件中使用的无量纲动量变量衔接。\n\n只需提供 $p^{\\ast 2}$ 的单一闭合形式解析表达式作为最终答案。不需要进行数值计算，也不需要单位。如果提到角度，应以弧度为单位，但最终答案不包含角度。",
            "solution": "经核验，该问题具有科学依据、提法恰当、客观且完整。它提出了相对论运动学中一个标准但基础的推导，这是计算核物理中 Lüscher 形式体系的一个关键组成部分。所有前提在事实上都是可靠的，并与狭义相对论的原理一致。因此，我们可以着手求解。\n\n该问题要求推导一个双粒子系统的质心 (CM) 动量平方 $p^{\\ast 2}$ 的表达式，该表达式用总质心能量 $E^{\\ast}$ 以及粒子静止质量 $m_1$ 和 $m_2$ 来表示。推导从质心系中能量的基本关系开始。总能量 $E^{\\ast}$ 是两个粒子各自在壳能量之和：\n$$\nE^{\\ast} = E_1^{\\ast} + E_2^{\\ast}\n$$\n其中，各个粒子的能量由相对论能量-动量关系给出：\n$$\nE_1^{\\ast} = \\sqrt{m_1^2 + p^{\\ast 2}}\n$$\n$$\nE_2^{\\ast} = \\sqrt{m_2^2 + p^{\\ast 2}}\n$$\n将这些代入总能量的表达式中，得到：\n$$\nE^{\\ast} = \\sqrt{m_1^2 + p^{\\ast 2}} + \\sqrt{m_2^2 + p^{\\ast 2}}\n$$\n为了解出 $p^{\\ast 2}$，我们必须通过代数变换将其分离出来。首先，我们分离其中一个平方根项：\n$$\nE^{\\ast} - \\sqrt{m_1^2 + p^{\\ast 2}} = \\sqrt{m_2^2 + p^{\\ast 2}}\n$$\n接下来，我们将方程两边平方以消去右侧的平方根：\n$$\n\\left( E^{\\ast} - \\sqrt{m_1^2 + p^{\\ast 2}} \\right)^2 = \\left( \\sqrt{m_2^2 + p^{\\ast 2}} \\right)^2\n$$\n$$\nE^{\\ast 2} - 2E^{\\ast}\\sqrt{m_1^2 + p^{\\ast 2}} + (m_1^2 + p^{\\ast 2}) = m_2^2 + p^{\\ast 2}\n$$\n$p^{\\ast 2}$ 项出现在等式两边，可以消去。然后我们可以整理方程，分离出剩余的平方根项：\n$$\nE^{\\ast 2} + m_1^2 - m_2^2 = 2E^{\\ast}\\sqrt{m_1^2 + p^{\\ast 2}}\n$$\n两边同时除以 $2E^{\\ast}$，得到：\n$$\n\\frac{E^{\\ast 2} + m_1^2 - m_2^2}{2E^{\\ast}} = \\sqrt{m_1^2 + p^{\\ast 2}}\n$$\n再次将两边平方，消去最后的平方根：\n$$\n\\left( \\frac{E^{\\ast 2} + m_1^2 - m_2^2}{2E^{\\ast}} \\right)^2 = m_1^2 + p^{\\ast 2}\n$$\n现在我们可以解出 $p^{\\ast 2}$：\n$$\np^{\\ast 2} = \\frac{(E^{\\ast 2} + m_1^2 - m_2^2)^2}{4E^{\\ast 2}} - m_1^2\n$$\n为了简化此表达式并将其与 Källén 函数联系起来，我们通分合并各项：\n$$\np^{\\ast 2} = \\frac{(E^{\\ast 2} + m_1^2 - m_2^2)^2 - 4E^{\\ast 2}m_1^2}{4E^{\\ast 2}}\n$$\n让我们展开分子。项 $(E^{\\ast 2} + m_1^2 - m_2^2)^2$ 展开为 $E^{\\ast 4} + m_1^4 + m_2^4 + 2E^{\\ast 2}m_1^2 - 2E^{\\ast 2}m_2^2 - 2m_1^2m_2^2$。将此代入分子，得到：\n$$\n\\text{Numerator} = (E^{\\ast 4} + m_1^4 + m_2^4 + 2E^{\\ast 2}m_1^2 - 2E^{\\ast 2}m_2^2 - 2m_1^2m_2^2) - 4E^{\\ast 2}m_1^2\n$$\n$$\n\\text{Numerator} = E^{\\ast 4} + m_1^4 + m_2^4 - 2E^{\\ast 2}m_1^2 - 2E^{\\ast 2}m_2^2 - 2m_1^2m_2^2\n$$\n这个表达式正是 Källén 三角函数 $\\lambda(x, y, z) = x^2 + y^2 + z^2 - 2xy - 2xz - 2yz$ 的定义，其中自变量为 $x = E^{\\ast 2}$，$y = m_1^2$ 和 $z = m_2^2$。因此，我们可以将分子写为 $\\lambda(E^{\\ast 2}, m_1^2, m_2^2)$。$p^{\\ast 2}$ 的最终表达式为：\n$$\np^{\\ast 2} = \\frac{\\lambda(E^{\\ast 2}, m_1^2, m_2^2)}{4E^{\\ast 2}}\n$$\n此推导给出了所要求的闭合形式表达式。\n\n以下是在 Lüscher 方法的背景下，关于此映射重要性的解释。\nLüscher 方法在被局限在有限体积内的双粒子系统的离散能量本征值（在像格点QCD这样的数值模拟中可以获取的量）与表征无限体积中粒子相互作用的连续散射相移（期望的物理可观测量）之间架起了一座桥梁。该方法的核心是一个量子化条件，它是一个关联这两组量的方程。\n\n从质心能量 $E^{\\ast}$ 到质心动量 $p^{\\ast}$ 的映射至关重要，主要有两个原因。首先，在有限体积模拟中直接计算的量是边长为 $L$ 的盒子中相互作用系统的离散能级 $E_n(L)$。这些能级对应于质心系中的总能量 $E^{\\ast}$。然而，像相移 $\\delta_l$ 这样的渐近散射数据自然是散射动量的函数，即 $\\delta_l(p^{\\ast})$。推导出的运动学关系 $p^{\\ast 2} = f(E^{\\ast}, m_1, m_2)$ 提供了从计算得到的可观测量 ($E^{\\ast}$) 到相移所依赖的运动学变量 ($p^{\\ast}$) 的关键且明确的一对一映射。没有这个关系，就不可能确定某个给定的能级是在哪个动量下探测散射相互作用。\n\n其次，Lüscher 量子化条件通常使用无量纲动量变量（通常表示为 $q$）来表述，其定义为 $q = \\frac{p^{\\ast}L}{2\\pi}$。例如，s-波 ($l=0$) 量子化条件通过一个形式为 $p^{\\ast} \\cot\\delta_0(p^{\\ast}) = \\frac{2}{L\\sqrt{\\pi}} \\mathcal{Z}_{00}(1; q^2)$ 的方程，将相移 $\\delta_0$ 与一个广义zeta函数 $\\mathcal{Z}_{00}(1; q^2)$ 联系起来。总体工作流程如下：\n1. 数值模拟得出一个离散的能量本征值 $E_n(L)$。这被视为 $E^{\\ast}$。\n2. 使用推导出的表达式计算相应的动量平方，$p^{\\ast 2} = \\lambda(E^{\\ast 2}, m_1^2, m_2^2)/(4E^{\\ast 2})$。\n3. 这个 $p^{\\ast 2}$ 的值被用来计算无量纲动量平方，$q^2 = (\\frac{L}{2\\pi})^2 p^{\\ast 2}$。\n4. 然后将 $q^2$ 的值作为输入代入量子化条件中已知的zeta函数，从而可以在该特定动量 $p^{\\ast}$ 处求解未知的相移 $\\cot\\delta_0(p^{\\ast})$。\n因此，$E^{\\ast} \\to p^{\\ast}$ 映射是将模拟的原始输出转换为 Lüscher 公式本身所需的正确运动学变量的不可或缺的第一步。",
            "answer": "$$\n\\boxed{\\frac{\\lambda(E^{\\ast 2}, m_1^2, m_2^2)}{4E^{\\ast 2}}}\n$$"
        },
        {
            "introduction": "一旦我们能够确定散射动量 $k$，Lüscher的量化条件就允许我们为每个能级提取 $k \\cot \\delta_0(k)$ 的值。这项实践  将引导您完成一个模拟的分析流程，您将使用合成数据来重构这个量。然后，您将利用有效程展开对结果进行拟合，以提取关键的散射参数，并通过定位一个虚态极点来进一步探索散射振幅的解析结构。",
            "id": "3603695",
            "problem": "考虑两个相同的无自旋粒子在一个边长为 $L$ 的立方周期性盒子内进行s波相互作用，我们使用 $\\hbar = c = 1$ 的单位制。在阈值附近，s波相移 $\\delta_0(k)$ 具有有效力程展开 $k \\cot \\delta_0(k) = -\\dfrac{1}{a_0} + \\dfrac{1}{2} r_0 k^2 + \\mathcal{O}(k^4)$，其中 $a_0$ 是散射长度，$r_0$ 是有效力程。在有限体积中，对于零总动量和立方周期性边界条件，Lüscher 方法通过 $k \\cot \\delta_0(k) = \\dfrac{1}{\\pi L} \\mathcal{S}(q^2)$（其中 $q^2 = \\left(\\dfrac{k L}{2 \\pi}\\right)^2$）将无穷体积量 $k \\cot \\delta_0(k)$ 与一个实的、有限体积的几何函数联系起来，其中 $\\mathcal{S}$ 编码了三维周期性，且与相互作用的细节无关。在无穷体积中，s波散射振幅为 $f_0(k) = \\dfrac{1}{k \\cot \\delta_0(k) - i k}$，其在虚动量 $k$ 轴上的极点通过解析延拓编码了近阈值态。一个虚态极点对应于分母在负虚轴上的一个零点，即在 $k = - i \\kappa$ 处，其中 $\\kappa > 0$。\n\n您的任务是实现一个测试框架，该框架能生成刚好在阈值之上的合成有限体积能谱，使用 Lüscher 关系从这些能谱中重构 $k \\cot \\delta_0(k)$，拟合有效力程展开系数，然后执行解析延拓以定位负虚轴上的虚态极点。程序必须基于以下基本原理进行：近阈值有效力程展开、将 $k \\cot \\delta_0(k)$ 映射到一个按 $1/(\\pi L)$ 缩放的纯几何函数的有限体积关系，以及s波散射振幅的解析结构。除了作为测试参数明确提供的数据外，不要使用任何特殊的预计算数据；相反，应对于近阈值动量，从有效力程展开本身一致地生成合成能谱，以确保正向和反向映射是自洽的。\n\n实现细节和要求：\n- 在无量纲自然单位制中工作。所有输入和输出都是不带物理单位的纯数。所有角度均以弧度为单位。\n- 对于每个测试用例，您必须：\n  1. 使用给定参数 $(a_0, r_0)$ 和提供的盒子尺寸列表 $\\{L_i\\}$ 及小的正质心动量列表 $\\{k_i\\}$，通过为每对 $(L_i, k_i)$ 定义一个合成几何函数值 $\\mathcal{S}(q_i^2) \\equiv \\pi L_i \\left(-\\dfrac{1}{a_0} + \\dfrac{1}{2} r_0 k_i^2\\right)$（其中 $q_i^2 = \\left(\\dfrac{k_i L_i}{2 \\pi}\\right)^2$），来生成与近阈值有效力程展开一致的合成有限体积数据。此步骤在保持有效力程展开有效的近阈值范围内，模拟了有限体积几何关系的输出。\n  2. 使用 $k \\cot \\delta_0(k_i) = \\dfrac{1}{\\pi L_i} \\mathcal{S}(q_i^2)$ 从合成有限体积数据中重构“测量”的 $k \\cot \\delta_0(k_i)$。\n  3. 将重构的数据 $\\{(k_i^2, k \\cot \\delta_0(k_i))\\}$ 拟合到线性模型 $y = c_0 + c_1 x$（其中 $y = k \\cot \\delta_0(k)$ 且 $x = k^2$）以提取 $c_0$ 和 $c_1$。从这些值中，通过 $c_0 = -\\dfrac{1}{a_0}$ 和 $c_1 = \\dfrac{1}{2} r_0$ 推断有效力程展开参数 $a_0$ 和 $r_0$。\n  4. 将拟合的 $k \\cot \\delta_0(k)$ 解析延拓至 $k = - i \\kappa$（其中 $\\kappa > 0$），并通过求解s波散射振幅分母在负虚轴上为零的条件来确定虚态极点。将得到的 $\\kappa$ 表示为一个正浮点数。\n- 设计您的代码以处理通用情况以及 $r_0$ 在数值精度上实际为零的特殊边界情况。\n\n测试套件：\n提供代码，为以下四个测试用例计算并输出估计的虚态极点位置 $\\kappa$。在每个用例中，精确使用所列出的 $(a_0, r_0)$ 对，以及指定的集合 $\\{L_i\\}$ 和 $\\{k_i\\}$：\n\n- 用例1（中等负散射长度，中等有效力程）：\n  - $(a_0, r_0) = (-1.5, 1.2)$\n  - $\\{L_i\\} = \\{20, 24, 28, 32\\}$\n  - $\\{k_i\\} = \\{0.06, 0.08, 0.10, 0.12\\}$\n\n- 用例2（小量值负散射长度，小正有效力程）：\n  - $(a_0, r_0) = (-0.3, 0.5)$\n  - $\\{L_i\\} = \\{18, 20, 22, 24\\}$\n  - $\\{k_i\\} = \\{0.05, 0.09, 0.13, 0.17\\}$\n\n- 用例3（大量值负散射长度，较大有效力程）：\n  - $(a_0, r_0) = (-5.0, 1.8)$\n  - $\\{L_i\\} = \\{22, 26, 30, 34\\}$\n  - $\\{k_i\\} = \\{0.04, 0.07, 0.10, 0.13\\}$\n\n- 用例4（有效力程为零的边界情况）：\n  - $(a_0, r_0) = (-1.25, 0.0)$\n  - $\\{L_i\\} = \\{16, 20, 24, 28\\}$\n  - $\\{k_i\\} = \\{0.05, 0.09, 0.12, 0.15\\}$\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含按上述用例顺序列出的四个推断出的 $\\kappa$ 值，每个值四舍五入到六位小数，并作为用方括号括起来的逗号分隔列表（例如，$[0.123456,0.234567,0.345678,0.456789]$）。",
            "solution": "用户提供了一个计算核物理领域的良构问题。任务是创建一个计算测试框架，以验证一个从模拟的有限体积数据中提取物理参数的程序。该程序涉及 Lüscher 方法，此方法将有限体积能谱与无穷体积散射相移联系起来。\n\n基于以下评估，该问题是有效的：\n- **科学基础**：该问题建立在量子散射理论的基本且公认的原理之上，包括有效力程展开 (ERE)、s波散射振幅和 Lüscher 形式体系。在此背景下，所有提供的方程都是标准且正确的。虚态作为散射振幅在负虚动量轴上的极点的概念是散射理论的一个标准特征。\n- **良构性**：该问题提供了一整套完整的指令、数据和边界条件。它概述了一个清晰的分步程序：（1）从已知模型生成合成数据，（2）使用拟合过程重构模型参数，以及（3）使用拟合后的模型计算一个派生的物理量（虚态极点位置）。这种“往返”设计确保了存在一个唯一且可验证的解。极点位置的数学推导证实了可以确定一个唯一的、物理上合理的解 $\\kappa > 0$。\n- **客观性**：该问题使用精确、无歧义的科学语言陈述。任务是计算性的，不含主观因素。\n\n该问题没有违反任何无效性标准。它在科学上是合理的、可形式化的、完整的并且在计算上是可行的。因此，将提供一个解决方案。\n\n解决方案的步骤如下：\n\n首先，我们为每个步骤建立理论基础。\n1.  **有效力程展开 (ERE)**：对于低能s波散射，相移 $\\delta_0(k)$ 通过以下展开式与质心动量 $k$ 相关：\n    $$k \\cot \\delta_0(k) = -\\frac{1}{a_0} + \\frac{1}{2} r_0 k^2 + \\mathcal{O}(k^4)$$\n    其中 $a_0$ 是散射长度，$r_0$ 是有效力程。该关系在阈值附近（$k \\approx 0$）对 $k^2$ 近似线性。\n\n2.  **合成数据生成**：问题要求生成模拟有限体积计算结果的合成数据点。根据 Lüscher 方法，对于给定的盒子尺寸 $L$，一个能级对应一个动量 $k$，它们通过 $k \\cot \\delta_0(k) = \\frac{1}{\\pi L} \\mathcal{S}(q^2)$ 与无穷体积相移相关，其中 $q^2 = (\\frac{kL}{2\\pi})^2$ 且 $\\mathcal{S}$ 是一个已知的几何函数。为创建与 ERE 一致的合成数据，我们使用给定参数 ($a_0$, $r_0$) 以及动量集合 $\\{k_i\\}$ 和盒子尺寸集合 $\\{L_i\\}$ 为每个数据点定义量 $k_i \\cot \\delta_0(k_i)$：\n    $$y_i = k_i \\cot \\delta_0(k_i) = -\\frac{1}{a_0} + \\frac{1}{2} r_0 k_i^2$$\n    这个过程模拟了在不同动量下对 $k \\cot \\delta_0$ 的完美的、无噪声的“测量”。\n\n3.  **参数拟合**：合成数据点的形式为 $(x_i, y_i) = (k_i^2, k_i \\cot \\delta_0(k_i))$。我们将这些点拟合到线性模型 $y = c_0 + c_1 x$。通过将其与 ERE 进行比较，我们可以识别拟合参数：\n    - 截距 $c_0$ 对应于 $-\\dfrac{1}{a_0}$。\n    - 斜率 $c_1$ 对应于 $\\dfrac{1}{2} r_0$。\n    由于数据是从精确的 ERE 形式生成的，线性最小二乘拟合应该能高精度地恢复参数 $c_0$ 和 $c_1$，使得 $c_0 \\approx -1/a_0$ 且 $c_1 \\approx r_0/2$。\n\n4.  **定位虚态极点**：虚态是s波散射振幅 $f_0(k) = \\dfrac{1}{k \\cot \\delta_0(k) - ik}$ 在负虚轴上的一个极点。我们在 $k = -i\\kappa$ 处寻找一个极点，其中 $\\kappa$ 是一个正实数。极点条件是分母为零：\n    $$k \\cot \\delta_0(k) - ik = 0$$\n    我们将此方程解析延拓到复平面。使用拟合的 ERE，$k \\cot \\delta_0(k) \\approx c_0 + c_1 k^2$，条件变为：\n    $$(c_0 + c_1 k^2) - ik = 0$$\n    代入 $k = -i\\kappa$：\n    $$c_0 + c_1 (-i\\kappa)^2 - i(-i\\kappa) = 0$$\n    $$c_0 + c_1(-\\kappa^2) - \\kappa = 0$$\n    $$c_0 - c_1 \\kappa^2 - \\kappa = 0$$\n    重新整理得到一个关于 $\\kappa$ 的二次方程：\n    $$c_1 \\kappa^2 + \\kappa - c_0 = 0$$\n    此方程用于求解 $\\kappa$。\n\n5.  **求解 $\\kappa$**：\n    - 如果 $c_1 \\neq 0$（即 $r_0 \\neq 0$），二次公式给出 $\\kappa$ 的两个解：\n      $$\\kappa = \\frac{-1 \\pm \\sqrt{1 - 4(c_1)(-c_0)}}{2c_1} = \\frac{-1 \\pm \\sqrt{1 + 4c_1c_0}}{2c_1}$$\n      对于指定的测试用例，$a_0  0$ 且 $r_0 \\ge 0$。这意味着 $c_0 = -1/a_0 > 0$ 且 $c_1 = r_0/2 \\ge 0$。因此判别式 $1+4c_1c_0$ 大于或等于1。物理上有意义的解必须满足 $\\kappa > 0$。分子 $-1 + \\sqrt{1+4c_1c_0}$ 是非负的，对于 $c_1 > 0$ 分母是正的，所以我们选择 ‘+’ 号。另一个根是负的。\n    - 如果 $c_1 = 0$（即 $r_0 = 0$），方程变为线性的：\n      $$\\kappa - c_0 = 0 \\implies \\kappa = c_0$$\n      这种情况需要单独处理以避免除以零。\n\n该实现将遍历每个测试用例，执行这些步骤，并存储得到的 $\\kappa$ 值。最终输出是这些值的格式化列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It orchestrates the data generation, fitting, and calculation of the\n    virtual-state pole for each scenario.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"params\": (-1.5, 1.2),\n            \"L_vals\": [20, 24, 28, 32],\n            \"k_vals\": [0.06, 0.08, 0.10, 0.12]\n        },\n        {\n            \"params\": (-0.3, 0.5),\n            \"L_vals\": [18, 20, 22, 24],\n            \"k_vals\": [0.05, 0.09, 0.13, 0.17]\n        },\n        {\n            \"params\": (-5.0, 1.8),\n            \"L_vals\": [22, 26, 30, 34],\n            \"k_vals\": [0.04, 0.07, 0.10, 0.13]\n        },\n        {\n            \"params\": (-1.25, 0.0),\n            \"L_vals\": [16, 20, 24, 28],\n            \"k_vals\": [0.05, 0.09, 0.12, 0.15]\n        }\n    ]\n\n    def process_case(a0, r0, L_vals, k_vals):\n        \"\"\"\n        Processes a single test case to find the virtual-state pole kappa.\n        \n        Args:\n            a0 (float): The s-wave scattering length.\n            r0 (float): The s-wave effective range.\n            L_vals (list): A list of box side lengths.\n            k_vals (list): A list of corresponding momenta.\n\n        Returns:\n            float: The calculated virtual-state pole location kappa.\n        \"\"\"\n        # Step 1  2: Generate synthetic data and reconstruct k*cot(delta0).\n        # The problem requires a round trip: generate synthetic S(q^2)\n        # and then \"reconstruct\" k*cot(delta0). Since this is an exact mapping,\n        # we can directly compute k*cot(delta0) from the true ERE parameters.\n        # x_data will be k^2, and y_data will be k*cot(delta0).\n        \n        k_squared_vals = [k**2 for k in k_vals]\n        k_cot_delta_vals = [-1.0/a0 + 0.5 * r0 * k2 for k2 in k_squared_vals]\n\n        x_data = np.array(k_squared_vals)\n        y_data = np.array(k_cot_delta_vals)\n\n        # Step 3: Fit the reconstructed data to the linear model y = c0 + c1*x.\n        # np.polyfit with deg=1 returns [c1, c0] corresponding to [slope, intercept].\n        coeffs = np.polyfit(x_data, y_data, 1)\n        c1_fit = coeffs[0]  # slope, theoretically equals 0.5 * r0\n        c0_fit = coeffs[1]  # intercept, theoretically equals -1.0 / a0\n\n        # Step 4: Find the virtual-state pole kappa by solving for the pole of\n        # the scattering amplitude using the fitted ERE.\n        # The condition k*cot(delta0) - i*k = 0 becomes the quadratic equation:\n        # c1_fit * kappa^2 + kappa - c0_fit = 0\n        \n        # We must handle the special case where r0 = 0, which implies c1_fit is zero.\n        # A small tolerance is used for floating-point comparison.\n        if abs(c1_fit)  1e-12:\n            # The equation simplifies to a linear one: kappa - c0_fit = 0\n            kappa = c0_fit\n        else:\n            # Solve the quadratic equation A*x^2 + B*x + C = 0 for kappa,\n            # where A = c1_fit, B = 1, C = -c0_fit.\n            A = c1_fit\n            B = 1.0\n            C = -c0_fit\n            \n            # The discriminant is B^2 - 4AC. We expect it to be non-negative.\n            discriminant = B**2 - 4 * A * C\n            \n            # For a virtual state, kappa must be positive.\n            # The test case parameters ensure c1_fit >= 0 and c0_fit > 0.\n            # The discriminant is >= 1. The physically meaningful solution\n            # requires taking the positive root in the numerator.\n            kappa = (-B + np.sqrt(discriminant)) / (2 * A)\n            \n        return kappa\n\n    results = []\n    for case in test_cases:\n        a0, r0 = case[\"params\"]\n        L_vals = case[\"L_vals\"]\n        k_vals = case[\"k_vals\"]\n        \n        kappa_result = process_case(a0, r0, L_vals, k_vals)\n        results.append(kappa_result)\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of kappa values, each rounded to\n    # six decimal places, enclosed in square brackets.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "有效程展开可以扩展以包含更高阶的项，例如形状参数，它能捕捉核相互作用中更精细的动力学细节。在实际应用中，一个关键问题是现有数据是否具有足够的精度和运动学覆盖范围，以从统计噪声中分辨出这些项。这项练习  提供了一个框架，用于从模拟的有限体积数据中统计检验形状参数的可辨识性，从而阐明统计不确定性、动量覆盖范围和模型复杂度之间的重要相互作用。",
            "id": "3603727",
            "problem": "您将编写一个完整、可运行的程序，使用受 Lüscher 方法启发的模拟有限体积谱来评估有效程展开 (ERE) 中 s-波形状参数的可辨识性。物理背景是边长为 $L$ 的立方周期性盒子中的双体弹性散射，其中分立的能级限制了可及的相对动量。关注的核心量是相移的 s-波 ERE，\n$$\nk \\cot \\delta_0(k) = -\\frac{1}{a} + \\frac{r}{2} k^2 + P\\, k^4,\n$$\n其中 $k$ 是相对动量，单位为 $\\text{fm}^{-1}$；$a$ 是散射长度，单位为 $\\text{fm}$；$r$ 是有效程，单位为 $\\text{fm}$；$P$ 是形状参数，单位为 $\\text{fm}^3$。可辨识性问题在于，在有限体积谱所允许的 $k$ 值覆盖范围内，曲率项 $P\\, k^4$ 是否能在统计上与零区分开来。\n\n数据生成的基本依据：在边长为 $L$ 的立方周期性体积中，最低的无相互作用相对动量标度由周期性边界条件设定，为 $k_{\\min}(L) \\approx \\frac{2\\pi}{L}$，这反映了离散格点动量的最低非零壳层。在给定的能量窗口内，可及的相对动量 $k$ 被限制在区间 $[k_{\\min}(L),\\,k_{\\max}]$ 内。为了生成用于测试 ERE 中曲率可辨识性的模拟谱，请在每个体积 $L$ 的允许区间内使用均匀间隔的 $k$ 采样点，并将 $k \\cot \\delta_0(k)$ 作为待拟合的观测量。这种方法无需数值求解完整的有限体积量子化条件，便能从可用的 $k$ 杠杆作用中分离出 $P$ 的统计可辨识性。\n\n统计模型：设观测模型为\n$$\ny_i = k_i \\cot \\delta_0(k_i) + \\varepsilon_i,\n$$\n其中 $y_i$ 单位为 $\\text{fm}^{-1}$，$k_i$ 单位为 $\\text{fm}^{-1}$，$\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$ 是单位为 $\\text{fm}^{-1}$ 的独立高斯噪声。拟合模型\n$$\ny_i = \\alpha_0 + \\alpha_2 k_i^2 + \\alpha_4 k_i^4,\n$$\n其中 $\\alpha_0 = -\\frac{1}{a}$，$\\alpha_2 = \\frac{r}{2}$，且 $\\alpha_4 = P$。如果估计值 $\\widehat{\\alpha}_4$ 满足 $|\\widehat{\\alpha}_4| \\geq 3 \\,\\sigma_{\\widehat{\\alpha}_4}$，则宣布 $P$ 具有可辨识性，其中 $\\sigma_{\\widehat{\\alpha}_4}$ 是从加权最小二乘协方差中获得的 $\\widehat{\\alpha}_4$ 的标准误差。\n\n单位与常数：使用自然单位制，令 $\\hbar=c=1$。$L$ 以 $\\text{fm}$ 表示，$k$ 以 $\\text{fm}^{-1}$ 表示，$y=k\\cot\\delta_0(k)$ 以 $\\text{fm}^{-1}$ 表示。相移仅通过 $k \\cot \\delta_0(k)$ 进入模型，因此无需表示角度。所有数值输出必须是无量纲的布尔值。\n\n实现要求：\n- 对于每个测试用例，通过在每个体积的 $[k_{\\min}(L),\\,k_{\\max}]$ 区间内采样 $N_L$ 个等间距的 $k$ 值，来汇集所有指定体积 $L$ 的数据。如果 $k_{\\min}(L) \\geq k_{\\max}$，则该体积没有可用的采样点。\n- 当区间非空时，每个体积使用 $N_L = 12$ 个采样点。\n- 使用固定的高斯噪声标准差 $\\sigma = 3\\times 10^{-3}$ in $\\text{fm}^{-1}$，并使用固定的伪随机种子以保证可复现性。\n- 使用权重 $w_i = 1/\\sigma^2$ 执行加权最小二乘法。\n- 使用上文定义的 $3\\sigma$ 准则，将 $P$ 的可辨识性确定为一个布尔值。\n\n测试套件：\n- 真实参数为 $a_{\\text{true}} = 5.0\\,\\text{fm}$，$r_{\\text{true}} = 1.7\\,\\text{fm}$ 和 $P_{\\text{true}} = 0.05\\,\\text{fm}^3$。\n- 使用以下三个测试用例，每个用例由体积集合和最大动量指定：\n  1. 用例 A：体积 $[8.0, 12.0]\\,\\text{fm}$，$k_{\\max} = 0.40\\,\\text{fm}^{-1}$。\n  2. 用例 B：体积 $[16.0, 20.0]\\,\\text{fm}$，$k_{\\max} = 0.60\\,\\text{fm}^{-1}$。\n  3. 用例 C：体积 $[10.0]\\,\\text{fm}$，$k_{\\max} = 0.25\\,\\text{fm}^{-1}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的结果，形式为逗号分隔的列表，并用方括号括起来，例如“[True,False,True]”。\n- 每个条目都是一个布尔值，指示在该测试用例指定的体积和 $k$ 覆盖范围下 $P$ 是否可辨识。",
            "solution": "所述问题是有效的。它在科学上基于量子散射理论和统计数据分析的原理，特别是在计算核物理和 Lüscher 方法的背景下。该问题是良定的，提供了所有必要的参数、常数以及一个清晰、客观的求解准则。它是自洽的，没有内部矛盾或歧义。因此，我们可以进行形式化的求解。\n\n目标是从模拟数据中确定 s-波有效程展开 (ERE) 中形状参数 $P$ 的统计可辨识性。ERE 由下式给出：\n$$\ny(k) = k \\cot \\delta_0(k) = -\\frac{1}{a} + \\frac{r}{2} k^2 + P\\, k^4\n$$\n其中 $k$ 是相对动量。分析的关键在于，从模拟有限周期性体积中测量得到的数据里，$k^4$ 项的系数 $P$ 能否以统计显著性被分辨出来。解决方案包括三个阶段：合成数据生成、通过最小二乘法进行统计模型拟合，以及参数不确定性评估。\n\n**1. 合成数据生成**\n\n问题提供了一个生成模拟数据的简化方案，该方案抓住了有限体积实验的基本运动学约束，而无需对 Lüscher 量子化条件进行完整的数值求解。对于边长为 $L$ 的立方体积，可及的相对动量 $k$ 的下界为 $k_{\\min}(L) = \\frac{2\\pi}{L}$。对于给定的测试场景（指定了一组体积 $\\{L_j\\}$ 和一个最大动量 $k_{\\max}$），我们按如下方式生成数据：\n\n对于每个体积 $L_j$：\n- 计算最小动量 $k_{\\min}(L_j) = \\frac{2\\pi}{L_j}$。\n- 如果运动学区间 $[k_{\\min}(L_j), k_{\\max}]$ 非空（即 $k_{\\min}(L_j)  k_{\\max}$），我们在此区间内生成 $N_L = 12$ 个均匀分布的动量点 $\\{k_i\\}$。\n- 对于每个 $k_i$，使用给定的真实参数（$a_{\\text{true}} = 5.0\\,\\text{fm}$，$r_{\\text{true}} = 1.7\\,\\text{fm}$ 和 $P_{\\text{true}} = 0.05\\,\\text{fm}^3$）通过 ERE 计算“真实”观测量 $y_{\\text{true}, i}$。\n- 然后通过添加高斯噪声生成带噪声的观测值 $y_i$：$y_i = y_{\\text{true}, i} + \\varepsilon_i$，其中 $\\varepsilon_i$ 从标准差固定为 $\\sigma = 3 \\times 10^{-3}\\,\\text{fm}^{-1}$ 的正态分布 $\\mathcal{N}(0, \\sigma^2)$ 中抽取。\n\n对于给定的测试用例，所有指定体积生成的所有数据点 $(k_i, y_i)$ 都被汇集到单个数据集中。如果在某个测试用例中，没有一个体积能产生有效的动量区间，则生成的数据集为空。\n\n**2. 线性回归模型**\n\nERE 是一个关于变量 $k^2$ 的多项式。这种结构允许我们将拟合问题转化为一个标准的多元线性回归问题。我们试图将模型\n$$\ny = \\alpha_0 \\cdot 1 + \\alpha_2 \\cdot k^2 + \\alpha_4 \\cdot k^4\n$$\n拟合到生成的数据点 $(k_i, y_i)$ 上。这可以用矩阵形式表示为 $Y = X\\beta + \\epsilon$，其中：\n- $Y$ 是 $N$ 个观测值的向量，$[y_1, y_2, \\dots, y_N]^T$。\n- $X$ 是 $N \\times 3$ 的设计矩阵，其中第 $i$ 行为 $[1, k_i^2, k_i^4]$。\n- $\\beta$ 是待估计的参数向量：$[\\alpha_0, \\alpha_2, \\alpha_4]^T$。\n- $\\epsilon$ 是噪声项向量，$[\\varepsilon_1, \\varepsilon_2, \\dots, \\varepsilon_N]^T$。\n\n**3. 参数估计与不确定性**\n\n问题指定使用权重为 $w_i = 1/\\sigma^2$ 的加权最小二乘法 (WLS)。由于所有数据点的噪声方差 $\\sigma^2$ 是恒定的，$\\beta$ 的 WLS 估计量简化为普通最小二乘 (OLS) 估计量：\n$$\n\\hat{\\beta} = (X^T X)^{-1} X^T Y\n$$\n这给出了最佳拟合估计值 $\\widehat{\\alpha}_0$、$\\widehat{\\alpha}_2$ 和 $\\widehat{\\alpha}_4$。\n\n这些估计的统计不确定性由其协方差矩阵捕获。对于 WLS，估计量 $\\hat{\\beta}$ 的协方差矩阵由下式给出：\n$$\n\\text{Cov}(\\hat{\\beta}) = (X^T W X)^{-1}\n$$\n其中 $W$ 是权重的对角矩阵。在我们的情况下，$W = \\frac{1}{\\sigma^2}I$，其中 $I$ 是单位矩阵。因此，协方差矩阵变为：\n$$\n\\text{Cov}(\\hat{\\beta}) = \\left(X^T \\left(\\frac{1}{\\sigma^2}I\\right) X\\right)^{-1} = \\sigma^2 (X^T X)^{-1}\n$$\n形状参数估计的方差 $\\text{Var}(\\widehat{\\alpha}_4)$ 是该矩阵的第三个对角元素，即 $(\\text{Cov}(\\hat{\\beta}))_{33}$。标准误差是其平方根：\n$$\n\\sigma_{\\widehat{\\alpha}_4} = \\sqrt{\\text{Var}(\\widehat{\\alpha}_4)} = \\sigma \\sqrt{((X^T X)^{-1})_{33}}\n$$\n\n**4. 可辨识性准则**\n\n如果一个参数的估计值相对于其估计不确定性而言与零有显著差异，则该参数在统计上是可辨识的。问题为此提供了一个精确的 $3\\sigma$ 准则：如果形状参数 $P$（由 $\\alpha_4$ 代表）的估计值 $\\widehat{\\alpha}_4$ 满足以下条件，则认为其是可辨识的：\n$$\n|\\widehat{\\alpha}_4| \\geq 3 \\,\\sigma_{\\widehat{\\alpha}_4}\n$$\n对每个测试用例都评估此条件。如果某个测试用例产生的数据点数量不足以约束三个模型参数（即少于 3 个点），则矩阵 $X^T X$ 会变得奇异，不确定性在形式上是无限的，因此根据定义，该参数是不可辨识的。\n\n以下程序实现了这整个过程，评估了三个指定测试用例中每一个的可辨识性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Assesses the identifiability of the s-wave shape parameter in the ERE\n    using mock finite-volume spectra, as specified in the problem statement.\n    \"\"\"\n    \n    # --- Problem Constants and Parameters ---\n    # True physical parameters for data generation\n    a_true = 5.0  # fm\n    r_true = 1.7  # fm\n    P_true = 0.05 # fm^3\n\n    # Derived ERE coefficients\n    alpha0_true = -1.0 / a_true\n    alpha2_true = r_true / 2.0\n    alpha4_true = P_true\n\n    # Statistical and sampling parameters\n    sigma = 3e-3     # fm^-1\n    N_L = 12         # Samples per volume\n    seed = 42        # Fixed seed for reproducibility\n    \n    # --- Test Cases ---\n    test_cases = [\n        {'name': 'A', 'volumes': [8.0, 12.0], 'k_max': 0.40},\n        {'name': 'B', 'volumes': [16.0, 20.0], 'k_max': 0.60},\n        {'name': 'C', 'volumes': [10.0], 'k_max': 0.25},\n    ]\n\n    results = []\n    rng = np.random.default_rng(seed)\n\n    for case in test_cases:\n        all_k = []\n        all_y = []\n\n        # 1. Data Generation\n        for L in case['volumes']:\n            k_min = 2.0 * np.pi / L\n            k_max = case['k_max']\n\n            if k_min  k_max:\n                # Generate N_L evenly spaced momentum samples\n                k_samples = np.linspace(k_min, k_max, N_L)\n                \n                # Calculate true y = k*cot(delta_0) values\n                y_true = (alpha0_true + \n                          alpha2_true * k_samples**2 + \n                          alpha4_true * k_samples**4)\n                \n                # Add Gaussian noise\n                noise = rng.normal(loc=0.0, scale=sigma, size=N_L)\n                y_samples = y_true + noise\n                \n                all_k.extend(k_samples)\n                all_y.extend(y_samples)\n        \n        k_data = np.array(all_k)\n        y_data = np.array(all_y)\n\n        # A fit requires at least as many points as parameters (3)\n        if k_data.shape[0]  3:\n            results.append(False)\n            continue\n\n        # 2. Linear Regression Setup\n        # Design matrix X with columns [1, k^2, k^4]\n        X = np.stack([np.ones_like(k_data), k_data**2, k_data**4], axis=1)\n\n        try:\n            # 3. Parameter Estimation and Uncertainty\n            # Calculate (X^T X)^-1, which is needed for the covariance matrix\n            XTX_inv = np.linalg.inv(X.T @ X)\n\n            # Estimate parameters beta_hat = (X^T X)^-1 X^T y\n            beta_hat = XTX_inv @ X.T @ y_data\n            \n            # The shape parameter estimate is the third coefficient\n            alpha4_hat = beta_hat[2]\n\n            # Calculate covariance matrix: Cov(beta) = sigma^2 * (X^T X)^-1\n            cov_beta = sigma**2 * XTX_inv\n            \n            # Variance of alpha4_hat is the (3,3) element\n            var_alpha4 = cov_beta[2, 2]\n            \n            # Standard error is the square root of the variance\n            std_err_alpha4 = np.sqrt(var_alpha4)\n\n            # 4. Apply Identifiability Criterion\n            is_identifiable = np.abs(alpha4_hat) >= 3.0 * std_err_alpha4\n            results.append(is_identifiable)\n\n        except np.linalg.LinAlgError:\n            # If X^T X is singular, parameters are not identifiable\n            results.append(False)\n\n    # Final output formatting\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}