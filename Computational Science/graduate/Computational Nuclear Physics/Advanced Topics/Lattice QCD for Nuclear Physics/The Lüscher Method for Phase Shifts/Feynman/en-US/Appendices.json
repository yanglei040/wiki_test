{
    "hands_on_practices": [
        {
            "introduction": "The Lüscher method connects discrete energy eigenvalues $E$ from a finite-volume simulation to infinite-volume scattering phase shifts $\\delta(k)$, which are functions of momentum $k$. This exercise establishes the crucial first step in this process: the relativistic kinematic transformation from the observable energy to the scattering momentum. Mastering this fundamental derivation  ensures you can correctly map the output of a simulation to the appropriate kinematic variable used in the quantization condition.",
            "id": "3603739",
            "problem": "Consider two distinguishable, spinless particles of rest masses $m_1$ and $m_2$ undergoing elastic scattering in a periodic cubic volume, as encountered in finite-volume spectroscopy used in computational nuclear physics. Let the total four-momentum be $P^{\\mu}$, and define the Lorentz-invariant squared energy $s \\equiv P^{\\mu}P_{\\mu}$. In the center-of-mass (CM) frame, the total energy is $E^{\\ast}$, so that $s = E^{\\ast 2}$, and the two particles have equal and opposite three-momenta of magnitude $p^{\\ast}$. The individual on-shell CM energies satisfy $E_1^{\\ast} = \\sqrt{m_1^2 + p^{\\ast 2}}$ and $E_2^{\\ast} = \\sqrt{m_2^2 + p^{\\ast 2}}$, with $E^{\\ast} = E_1^{\\ast} + E_2^{\\ast}$. Starting from four-momentum conservation, Lorentz invariance, and the relativistic on-shell conditions, derive a closed-form expression for $p^{\\ast 2}$ purely in terms of $E^{\\ast}$, $m_1$, and $m_2$. You may express your final result using the Källén function $\\lambda(x,y,z)$ defined by $\\lambda(x,y,z) = x^2 + y^2 + z^2 - 2xy - 2xz - 2yz$. Then, briefly explain why this mapping from $E^{\\ast}$ to $p^{\\ast}$ is essential for relating discrete finite-volume energies to infinite-volume elastic scattering phase shifts in Lüscher’s method, and how it interfaces with the dimensionless momentum variable used in the finite-volume quantization condition.\n\nProvide the final answer as a single closed-form analytic expression for $p^{\\ast 2}$ only. No numerical evaluation is required, and no units are needed. Angles, if mentioned, should be in radians, but the final answer contains no angles.",
            "solution": "The problem is validated as scientifically grounded, well-posed, objective, and complete. It presents a standard but fundamental derivation in relativistic kinematics, which is a critical component of the Lüscher formalism in computational nuclear physics. All premises are factually sound and consistent with the principles of special relativity. We may therefore proceed with the solution.\n\nThe problem requires the derivation of an expression for the squared center-of-mass (CM) momentum, $p^{\\ast 2}$, for a two-particle system in terms of the total CM energy, $E^{\\ast}$, and the rest masses of the particles, $m_1$ and $m_2$. The derivation begins with the fundamental relations for energy in the CM frame. The total energy $E^{\\ast}$ is the sum of the individual on-shell energies of the two particles:\n$$\nE^{\\ast} = E_1^{\\ast} + E_2^{\\ast}\n$$\nwhere the individual energies are given by the relativistic energy-momentum relation:\n$$\nE_1^{\\ast} = \\sqrt{m_1^2 + p^{\\ast 2}}\n$$\n$$\nE_2^{\\ast} = \\sqrt{m_2^2 + p^{\\ast 2}}\n$$\nSubstituting these into the expression for the total energy gives:\n$$\nE^{\\ast} = \\sqrt{m_1^2 + p^{\\ast 2}} + \\sqrt{m_2^2 + p^{\\ast 2}}\n$$\nTo solve for $p^{\\ast 2}$, we must isolate it through algebraic manipulation. First, we isolate one of the square root terms:\n$$\nE^{\\ast} - \\sqrt{m_1^2 + p^{\\ast 2}} = \\sqrt{m_2^2 + p^{\\ast 2}}\n$$\nNext, we square both sides of the equation to eliminate the square root on the right-hand side:\n$$\n\\left( E^{\\ast} - \\sqrt{m_1^2 + p^{\\ast 2}} \\right)^2 = \\left( \\sqrt{m_2^2 + p^{\\ast 2}} \\right)^2\n$$\n$$\nE^{\\ast 2} - 2E^{\\ast}\\sqrt{m_1^2 + p^{\\ast 2}} + (m_1^2 + p^{\\ast 2}) = m_2^2 + p^{\\ast 2}\n$$\nThe term $p^{\\ast 2}$ appears on both sides and cancels out. We can then rearrange the equation to isolate the remaining square root term:\n$$\nE^{\\ast 2} + m_1^2 - m_2^2 = 2E^{\\ast}\\sqrt{m_1^2 + p^{\\ast 2}}\n$$\nDividing by $2E^{\\ast}$ gives:\n$$\n\\frac{E^{\\ast 2} + m_1^2 - m_2^2}{2E^{\\ast}} = \\sqrt{m_1^2 + p^{\\ast 2}}\n$$\nSquaring both sides again eliminates the final square root:\n$$\n\\left( \\frac{E^{\\ast 2} + m_1^2 - m_2^2}{2E^{\\ast}} \\right)^2 = m_1^2 + p^{\\ast 2}\n$$\nNow we can solve for $p^{\\ast 2}$:\n$$\np^{\\ast 2} = \\frac{(E^{\\ast 2} + m_1^2 - m_2^2)^2}{4E^{\\ast 2}} - m_1^2\n$$\nTo simplify this expression and relate it to the Källén function, we combine the terms over a common denominator:\n$$\np^{\\ast 2} = \\frac{(E^{\\ast 2} + m_1^2 - m_2^2)^2 - 4E^{\\ast 2}m_1^2}{4E^{\\ast 2}}\n$$\nLet's expand the numerator. The term $(E^{\\ast 2} + m_1^2 - m_2^2)^2$ expands to $E^{\\ast 4} + m_1^4 + m_2^4 + 2E^{\\ast 2}m_1^2 - 2E^{\\ast 2}m_2^2 - 2m_1^2m_2^2$. Substituting this into the numerator gives:\n$$\n\\text{Numerator} = (E^{\\ast 4} + m_1^4 + m_2^4 + 2E^{\\ast 2}m_1^2 - 2E^{\\ast 2}m_2^2 - 2m_1^2m_2^2) - 4E^{\\ast 2}m_1^2\n$$\n$$\n\\text{Numerator} = E^{\\ast 4} + m_1^4 + m_2^4 - 2E^{\\ast 2}m_1^2 - 2E^{\\ast 2}m_2^2 - 2m_1^2m_2^2\n$$\nThis expression is precisely the definition of the Källén triangle function, $\\lambda(x, y, z) = x^2 + y^2 + z^2 - 2xy - 2xz - 2yz$, with the arguments $x = E^{\\ast 2}$, $y = m_1^2$, and $z = m_2^2$. Therefore, we can write the numerator as $\\lambda(E^{\\ast 2}, m_1^2, m_2^2)$. The final expression for $p^{\\ast 2}$ is:\n$$\np^{\\ast 2} = \\frac{\\lambda(E^{\\ast 2}, m_1^2, m_2^2)}{4E^{\\ast 2}}\n$$\nThis derivation provides the required closed-form expression.\n\nThe explanation for the importance of this mapping in the context of Lüscher's method follows.\nLüscher's method provides a bridge between the discrete energy eigenvalues of a two-particle system confined in a finite volume (quantities accessible in numerical simulations like lattice QCD) and the continuous scattering phase shifts that characterize particle interactions in infinite volume (the desired physical observables). The core of the method is a quantization condition, which is an equation that relates these two sets of quantities.\n\nThe mapping from the CM energy $E^{\\ast}$ to the CM momentum $p^{\\ast}$ is essential for two primary reasons. First, the quantities directly computed in a finite-volume simulation are the discrete energy levels, $E_n(L)$, of the interacting system in a box of side length $L$. These energy levels correspond to the total energy in the CM frame, $E^{\\ast}$. However, the aymptotic scattering data, such as the phase shift $\\delta_l$, are naturally functions of the scattering momentum, i.e., $\\delta_l(p^{\\ast})$. The derived kinematic relation $p^{\\ast 2} = f(E^{\\ast}, m_1, m_2)$ provides the critical, unambiguous one-to-one mapping from the computed observable ($E^{\\ast}$) to the kinematic variable ($p^{\\ast}$) on which the phase shift depends. Without this relation, it would be impossible to determine at which momentum a given energy level is probing the scattering interaction.\n\nSecond, the Lüscher quantization condition is typically formulated using a dimensionless momentum variable, commonly denoted as $q$, which is defined as $q = \\frac{p^{\\ast}L}{2\\pi}$. For example, the s-wave ($l=0$) quantization condition relates the phase shift $\\delta_0$ to a generalized zeta function $\\mathcal{Z}_{00}(1; q^2)$ via an equation of the form $p^{\\ast} \\cot\\delta_0(p^{\\ast}) = \\frac{2}{L\\sqrt{\\pi}} \\mathcal{Z}_{00}(1; q^2)$. The overall workflow is as follows:\n$1$. A numerical simulation yields a discrete energy eigenvalue $E_n(L)$. This is taken as $E^{\\ast}$.\n$2$. The derived expression is used to compute the corresponding momentum squared, $p^{\\ast 2} = \\lambda(E^{\\ast 2}, m_1^2, m_2^2)/(4E^{\\ast 2})$.\n$3$. This value of $p^{\\ast 2}$ is used to calculate the dimensionless momentum squared, $q^2 = (\\frac{L}{2\\pi})^2 p^{\\ast 2}$.\n$4$. The value of $q^2$ is then used as the input to the known zeta function in the quantization condition, allowing one to solve for the unknown phase shift $\\cot\\delta_0(p^{\\ast})$ at that specific momentum $p^{\\ast}$.\nThus, the $E^{\\ast} \\to p^{\\ast}$ mapping is the indispensable first step that converts the raw output of a simulation into the correct kinematic variable required by the Lüscher formula itself.",
            "answer": "$$\n\\boxed{\\frac{\\lambda(E^{\\ast 2}, m_1^2, m_2^2)}{4E^{\\ast 2}}}\n$$"
        },
        {
            "introduction": "With the energy-to-momentum mapping established, we can now apply the Lüscher formalism to extract physical scattering parameters. This practice  guides you through a complete analysis pipeline, from using synthetic finite-volume data to reconstructing the effective range expansion and locating a virtual-state pole. This exercise demonstrates how the abstract quantization condition is used in a concrete numerical analysis to uncover the analytic structure of the scattering amplitude.",
            "id": "3603695",
            "problem": "Consider two identical, spinless particles interacting in an s-wave inside a cubic periodic box of side length $L$ in units where $\\hbar = c = 1$. Near threshold, the s-wave phase shift $\\delta_0(k)$ admits the effective range expansion $k \\cot \\delta_0(k) = -\\dfrac{1}{a_0} + \\dfrac{1}{2} r_0 k^2 + \\mathcal{O}(k^4)$, where $a_0$ is the scattering length and $r_0$ is the effective range. In finite volume, for zero total momentum and cubic periodic boundary conditions, the Lüscher method relates the infinite-volume quantity $k \\cot \\delta_0(k)$ to a real, finite-volume geometric function via $k \\cot \\delta_0(k) = \\dfrac{1}{\\pi L} \\mathcal{S}(q^2)$ with $q^2 = \\left(\\dfrac{k L}{2 \\pi}\\right)^2$, where $\\mathcal{S}$ encodes the three-dimensional periodicity and is independent of the interaction details. In infinite volume, the s-wave scattering amplitude is $f_0(k) = \\dfrac{1}{k \\cot \\delta_0(k) - i k}$, and poles of $f_0(k)$ on the imaginary $k$ axis encode near-threshold states via analytic continuation. A virtual-state pole corresponds to a zero of the denominator on the negative imaginary axis, i.e., at $k = - i \\kappa$ with $\\kappa  0$.\n\nYour task is to implement a test harness that generates synthetic finite-volume spectra just above threshold, reconstructs $k \\cot \\delta_0(k)$ from those spectra using the Lüscher relation, fits the effective range expansion coefficients, and then performs the analytic continuation to locate the virtual-state pole on the negative imaginary axis. The program must proceed from the following fundamental bases: the effective range expansion near threshold, the finite-volume relation that maps $k \\cot \\delta_0(k)$ to a purely geometric function scaled by $1/(\\pi L)$, and the analytic structure of the s-wave scattering amplitude. Do not use any specialized precomputed data beyond what is explicitly provided as test parameters; instead, generate synthetic spectra consistently from the effective range expansion itself for momenta near threshold so that the forward and inverse mappings are self-consistent.\n\nImplementation details and requirements:\n- Work in dimensionless natural units. All inputs and outputs are pure numbers without physical units. All angles are in radians.\n- For each test case, you must:\n  1. Use the given parameters $(a_0, r_0)$ and the provided lists of box sizes $\\{L_i\\}$ and small, positive, center-of-mass momenta $\\{k_i\\}$ to generate synthetic finite-volume data that are consistent with the effective range expansion near threshold by defining a synthetic geometric function value $\\mathcal{S}(q_i^2)$ for each pair $(L_i, k_i)$ through $\\mathcal{S}(q_i^2) \\equiv \\pi L_i \\left(-\\dfrac{1}{a_0} + \\dfrac{1}{2} r_0 k_i^2\\right)$ with $q_i^2 = \\left(\\dfrac{k_i L_i}{2 \\pi}\\right)^2$. This step emulates the output of the finite-volume geometric relation while staying within the near-threshold regime where the effective range expansion is valid.\n  2. Reconstruct the “measured” $k \\cot \\delta_0(k_i)$ from the synthetic finite-volume data using $k \\cot \\delta_0(k_i) = \\dfrac{1}{\\pi L_i} \\mathcal{S}(q_i^2)$.\n  3. Fit the reconstructed data $\\{(k_i^2, k \\cot \\delta_0(k_i))\\}$ to the linear model $y = c_0 + c_1 x$ with $y = k \\cot \\delta_0(k)$ and $x = k^2$ to extract $c_0$ and $c_1$. From these, infer the effective range expansion parameters $a_0$ and $r_0$ via $c_0 = -\\dfrac{1}{a_0}$ and $c_1 = \\dfrac{1}{2} r_0$.\n  4. Analytically continue the fitted $k \\cot \\delta_0(k)$ to $k = - i \\kappa$ with $\\kappa  0$ and determine the virtual-state pole by solving the condition that the s-wave scattering amplitude denominator vanishes on the negative imaginary axis. Express the resulting $\\kappa$ as a positive float.\n- Design your code to handle the generic case and the special boundary case where $r_0$ is effectively zero to numerical precision.\n\nTest suite:\nProvide code that computes and outputs the estimated virtual-state pole location $\\kappa$ for the following four test cases. In each case, use exactly the listed $(a_0, r_0)$ pairs, along with the specified sets $\\{L_i\\}$ and $\\{k_i\\}$:\n\n- Case $1$ (moderate negative scattering length, moderate effective range):\n  - $(a_0, r_0) = (-1.5, 1.2)$\n  - $\\{L_i\\} = \\{20, 24, 28, 32\\}$\n  - $\\{k_i\\} = \\{0.06, 0.08, 0.10, 0.12\\}$\n\n- Case $2$ (small-magnitude negative scattering length, small positive effective range):\n  - $(a_0, r_0) = (-0.3, 0.5)$\n  - $\\{L_i\\} = \\{18, 20, 22, 24\\}$\n  - $\\{k_i\\} = \\{0.05, 0.09, 0.13, 0.17\\}$\n\n- Case $3$ (large-magnitude negative scattering length, larger effective range):\n  - $(a_0, r_0) = (-5.0, 1.8)$\n  - $\\{L_i\\} = \\{22, 26, 30, 34\\}$\n  - $\\{k_i\\} = \\{0.04, 0.07, 0.10, 0.13\\}$\n\n- Case $4$ (boundary case with vanishing effective range):\n  - $(a_0, r_0) = (-1.25, 0.0)$\n  - $\\{L_i\\} = \\{16, 20, 24, 28\\}$\n  - $\\{k_i\\} = \\{0.05, 0.09, 0.12, 0.15\\}$\n\nFinal output format:\n- Your program should produce a single line of output containing the four inferred $\\kappa$ values, in the order of the cases listed above, each rounded to six decimal places, as a comma-separated list enclosed in square brackets (for example, $[0.123456,0.234567,0.345678,0.456789]$).",
            "solution": "The user has provided a well-posed problem in computational nuclear physics. The task is to create a computational test harness to validate a procedure for extracting physical parameters from simulated finite-volume data. The procedure involves the Lüscher method, which connects finite-volume energy spectra to infinite-volume scattering phase shifts.\n\nThe problem is valid based on the following assessment:\n- **Scientific Grounding**: The problem is built upon fundamental and well-established principles of quantum scattering theory, including the effective range expansion (ERE), the s-wave scattering amplitude, and the Lüscher formalism. All provided equations are standard and correct within this context. The concept of a virtual state as a pole of the scattering amplitude on the negative imaginary momentum axis is a standard feature of scattering theory.\n- **Well-Posedness**: The problem provides a complete set of instructions, data, and boundary conditions. It outlines a clear, step-by-step procedure: (1) generate synthetic data from a known model, (2) use a fitting procedure to reconstruct the model parameters, and (3) use the fitted model to calculate a derived physical quantity (the virtual-state pole location). This \"round-trip\" design ensures that a unique and verifiable solution exists. The mathematical derivation of the pole location confirms that a unique, physically sensible solution, $\\kappa  0$, can be determined.\n- **Objectivity**: The problem is stated using precise, unambiguous scientific language. The task is computational and free of subjective elements.\n\nThe problem does not violate any of the invalidity criteria. It is scientifically sound, formalizable, complete, and computationally feasible. Therefore, a solution will be provided.\n\nThe solution proceeds as follows:\n\nFirst, we establish the theoretical basis for each step.\n1.  **Effective Range Expansion (ERE)**: For low-energy s-wave scattering, the phase shift $\\delta_0(k)$ is related to the center-of-mass momentum $k$ by the expansion:\n    $$k \\cot \\delta_0(k) = -\\frac{1}{a_0} + \\frac{1}{2} r_0 k^2 + \\mathcal{O}(k^4)$$\n    where $a_0$ is the scattering length and $r_0$ is the effective range. This relation is approximately linear in $k^2$ near threshold ($k \\approx 0$).\n\n2.  **Synthetic Data Generation**: The problem requires generating synthetic data points that mimic results from a finite-volume calculation. According to the Lüscher method, for a given box size $L$, an energy level corresponds to a momentum $k$, and these are related to the infinite-volume phase shift by $k \\cot \\delta_0(k) = \\frac{1}{\\pi L} \\mathcal{S}(q^2)$, where $q^2 = (\\frac{kL}{2\\pi})^2$ and $\\mathcal{S}$ is a known geometric function. To create synthetic data consistent with the ERE, we use the given parameters ($a_0$, $r_0$) and a set of momenta $\\{k_i\\}$ and box sizes $\\{L_i\\}$ to define the quantity $k_i \\cot \\delta_0(k_i)$ for each data point:\n    $$y_i = k_i \\cot \\delta_0(k_i) = -\\frac{1}{a_0} + \\frac{1}{2} r_0 k_i^2$$\n    This process simulates perfect, noise-free \"measurements\" of $k \\cot \\delta_0$ at various momenta.\n\n3.  **Parameter Fitting**: The synthetic data points are of the form $(x_i, y_i) = (k_i^2, k_i \\cot \\delta_0(k_i))$. We fit these points to a linear model $y = c_0 + c_1 x$. By comparing this to the ERE, we can identify the fit parameters:\n    - The intercept $c_0$ corresponds to $-\\dfrac{1}{a_0}$.\n    - The slope $c_1$ corresponds to $\\dfrac{1}{2} r_0$.\n    Since the data is generated from the exact ERE form, a linear least-squares fit should recover the parameters $c_0$ and $c_1$ with high precision, such that $c_0 \\approx -1/a_0$ and $c_1 \\approx r_0/2$.\n\n4.  **Locating the Virtual-State Pole**: A virtual state is a pole of the s-wave scattering amplitude $f_0(k) = \\dfrac{1}{k \\cot \\delta_0(k) - ik}$ on the negative imaginary axis. We seek a pole at $k = -i\\kappa$ where $\\kappa$ is a real, positive number. The pole condition is that the denominator vanishes:\n    $$k \\cot \\delta_0(k) - ik = 0$$\n    We analytically continue this equation to the complex plane. Using the fitted ERE, $k \\cot \\delta_0(k) \\approx c_0 + c_1 k^2$, the condition becomes:\n    $$(c_0 + c_1 k^2) - ik = 0$$\n    Substituting $k = -i\\kappa$:\n    $$c_0 + c_1 (-i\\kappa)^2 - i(-i\\kappa) = 0$$\n    $$c_0 + c_1(-\\kappa^2) - \\kappa = 0$$\n    $$c_0 - c_1 \\kappa^2 - \\kappa = 0$$\n    Rearranging this gives a quadratic equation for $\\kappa$:\n    $$c_1 \\kappa^2 + \\kappa - c_0 = 0$$\n    This equation is solved for $\\kappa$.\n\n5.  **Solving for $\\kappa$**:\n    - If $c_1 \\neq 0$ (i.e., $r_0 \\neq 0$), the quadratic formula yields two solutions for $\\kappa$:\n      $$\\kappa = \\frac{-1 \\pm \\sqrt{1 - 4(c_1)(-c_0)}}{2c_1} = \\frac{-1 \\pm \\sqrt{1 + 4c_1c_0}}{2c_1}$$\n      For the specified test cases, $a_0  0$ and $r_0 \\ge 0$. This implies $c_0 = -1/a_0  0$ and $c_1 = r_0/2 \\ge 0$. The discriminant $1+4c_1c_0$ is therefore greater than or equal to $1$. The physically meaningful solution must have $\\kappa  0$. The numerator $-1 + \\sqrt{1+4c_1c_0}$ is non-negative, and for $c_10$ the denominator is positive, so we choose the '+' sign. The other root is negative.\n    - If $c_1 = 0$ (i.e., $r_0 = 0$), the equation becomes linear:\n      $$\\kappa - c_0 = 0 \\implies \\kappa = c_0$$\n      This case is handled separately to avoid division by zero.\n\nThe implementation will loop through each test case, perform these steps, and store the resulting $\\kappa$ value. The final output is a formatted list of these values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It orchestrates the data generation, fitting, and calculation of the\n    virtual-state pole for each scenario.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"params\": (-1.5, 1.2),\n            \"L_vals\": [20, 24, 28, 32],\n            \"k_vals\": [0.06, 0.08, 0.10, 0.12]\n        },\n        {\n            \"params\": (-0.3, 0.5),\n            \"L_vals\": [18, 20, 22, 24],\n            \"k_vals\": [0.05, 0.09, 0.13, 0.17]\n        },\n        {\n            \"params\": (-5.0, 1.8),\n            \"L_vals\": [22, 26, 30, 34],\n            \"k_vals\": [0.04, 0.07, 0.10, 0.13]\n        },\n        {\n            \"params\": (-1.25, 0.0),\n            \"L_vals\": [16, 20, 24, 28],\n            \"k_vals\": [0.05, 0.09, 0.12, 0.15]\n        }\n    ]\n\n    def process_case(a0, r0, L_vals, k_vals):\n        \"\"\"\n        Processes a single test case to find the virtual-state pole kappa.\n        \n        Args:\n            a0 (float): The s-wave scattering length.\n            r0 (float): The s-wave effective range.\n            L_vals (list): A list of box side lengths.\n            k_vals (list): A list of corresponding momenta.\n\n        Returns:\n            float: The calculated virtual-state pole location kappa.\n        \"\"\"\n        # Step 1  2: Generate synthetic data and reconstruct k*cot(delta0).\n        # The problem requires a round trip: generate synthetic S(q^2)\n        # and then \"reconstruct\" k*cot(delta0). Since this is an exact mapping,\n        # we can directly compute k*cot(delta0) from the true ERE parameters.\n        # x_data will be k^2, and y_data will be k*cot(delta0).\n        \n        k_squared_vals = [k**2 for k in k_vals]\n        k_cot_delta_vals = [-1.0/a0 + 0.5 * r0 * k2 for k2 in k_squared_vals]\n\n        x_data = np.array(k_squared_vals)\n        y_data = np.array(k_cot_delta_vals)\n\n        # Step 3: Fit the reconstructed data to the linear model y = c0 + c1*x.\n        # np.polyfit with deg=1 returns [c1, c0] corresponding to [slope, intercept].\n        coeffs = np.polyfit(x_data, y_data, 1)\n        c1_fit = coeffs[0]  # slope, theoretically equals 0.5 * r0\n        c0_fit = coeffs[1]  # intercept, theoretically equals -1.0 / a0\n\n        # Step 4: Find the virtual-state pole kappa by solving for the pole of\n        # the scattering amplitude using the fitted ERE.\n        # The condition k*cot(delta0) - i*k = 0 becomes the quadratic equation:\n        # c1_fit * kappa^2 + kappa - c0_fit = 0\n        \n        # We must handle the special case where r0 = 0, which implies c1_fit is zero.\n        # A small tolerance is used for floating-point comparison.\n        if abs(c1_fit)  1e-12:\n            # The equation simplifies to a linear one: kappa - c0_fit = 0\n            kappa = c0_fit\n        else:\n            # Solve the quadratic equation A*x^2 + B*x + C = 0 for kappa,\n            # where A = c1_fit, B = 1, C = -c0_fit.\n            A = c1_fit\n            B = 1.0\n            C = -c0_fit\n            \n            # The discriminant is B^2 - 4AC. We expect it to be non-negative.\n            discriminant = B**2 - 4 * A * C\n            \n            # For a virtual state, kappa must be positive.\n            # The test case parameters ensure c1_fit = 0 and c0_fit  0.\n            # The discriminant is = 1. The physically meaningful solution\n            # requires taking the positive root in the numerator.\n            kappa = (-B + np.sqrt(discriminant)) / (2 * A)\n            \n        return kappa\n\n    results = []\n    for case in test_cases:\n        a0, r0 = case[\"params\"]\n        L_vals = case[\"L_vals\"]\n        k_vals = case[\"k_vals\"]\n        \n        kappa_result = process_case(a0, r0, L_vals, k_vals)\n        results.append(kappa_result)\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of kappa values, each rounded to\n    # six decimal places, enclosed in square brackets.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A key challenge in any data analysis is determining the statistical significance of model parameters, especially those corresponding to higher-order effects. This exercise  delves into the practical question of when the curvature of the effective range expansion, described by the shape parameter $P$, can be reliably extracted from finite-volume data. By simulating data with different kinematic coverages, you will develop an intuition for how experimental design impacts the ability to resolve subleading physics.",
            "id": "3603727",
            "problem": "You will write a complete, runnable program to assess the identifiability of the s-wave shape parameter in the Effective Range Expansion (ERE) using mock finite-volume spectra motivated by the Lüscher method. The physical setting is two-body elastic scattering in a cubic periodic box of side length $L$, where discrete energy levels restrict the accessible relative momenta. The core quantity of interest is the s-wave ERE for the phase shift,\n$$\nk \\cot \\delta_0(k) = -\\frac{1}{a} + \\frac{r}{2} k^2 + P\\, k^4,\n$$\nwhere $k$ is the relative momentum in $\\text{fm}^{-1}$, $a$ is the scattering length in $\\text{fm}$, $r$ is the effective range in $\\text{fm}$, and $P$ is the shape parameter in $\\text{fm}^3$. The identifiability question is whether the curvature term $P\\, k^4$ can be statistically distinguished from zero given the coverage of $k$ values that finite-volume spectra allow.\n\nFundamental base for data generation: In a cubic periodic volume of side $L$, the lowest noninteracting relative momentum scale is set by the periodic boundary conditions with $k_{\\min}(L) \\approx \\frac{2\\pi}{L}$, which reflects the lowest nonzero shell of discrete lattice momenta. Within a given energy window, accessible relative momenta $k$ are restricted to the interval $[k_{\\min}(L),\\,k_{\\max}]$. For the purpose of generating mock spectra that test curvature identifiability in the ERE, use uniformly spaced $k$ samples in the allowed interval for each volume $L$ and treat $k \\cot \\delta_0(k)$ as the observable to be fitted. This approach isolates the statistical identifiability of $P$ arising from the available $k$ leverage without requiring you to numerically solve the full finite-volume quantization condition.\n\nStatistical model: Let the observation model be\n$$\ny_i = k_i \\cot \\delta_0(k_i) + \\varepsilon_i,\n$$\nwith $y_i$ in $\\text{fm}^{-1}$, $k_i$ in $\\text{fm}^{-1}$, and independent Gaussian noise $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$ in $\\text{fm}^{-1}$. Fit the model\n$$\ny_i = \\alpha_0 + \\alpha_2 k_i^2 + \\alpha_4 k_i^4,\n$$\nwhere $\\alpha_0 = -\\frac{1}{a}$, $\\alpha_2 = \\frac{r}{2}$, and $\\alpha_4 = P$. Identifiability of $P$ is declared if the estimate $\\widehat{\\alpha}_4$ satisfies $|\\widehat{\\alpha}_4| \\geq 3 \\,\\sigma_{\\widehat{\\alpha}_4}$, where $\\sigma_{\\widehat{\\alpha}_4}$ is the standard error of $\\widehat{\\alpha}_4$ obtained from the weighted least squares covariance.\n\nUnits and constants: Use natural units with $\\hbar=c=1$. Express $L$ in $\\text{fm}$, $k$ in $\\text{fm}^{-1}$, and $y=k\\cot\\delta_0(k)$ in $\\text{fm}^{-1}$. Angles do not need to be expressed since the phase shift enters only through $k \\cot \\delta_0(k)$. All numerical outputs must be dimensionless booleans.\n\nImplementation requirements:\n- For each test case, pool data across the specified volumes $L$ by sampling $N_L$ evenly spaced $k$ values for each volume in $[k_{\\min}(L),\\,k_{\\max}]$. If $k_{\\min}(L) \\geq k_{\\max}$, no samples are available for that volume.\n- Use $N_L = 12$ samples per volume when the interval is nonempty.\n- Use a fixed Gaussian noise standard deviation $\\sigma = 3\\times 10^{-3}$ in $\\text{fm}^{-1}$, and use a fixed pseudorandom seed for reproducibility.\n- Perform weighted least squares with weights $w_i = 1/\\sigma^2$.\n- Determine identifiability of $P$ as a boolean using the $3\\sigma$ criterion defined above.\n\nTest suite:\n- True parameters are $a_{\\text{true}} = 5.0\\,\\text{fm}$, $r_{\\text{true}} = 1.7\\,\\text{fm}$, and $P_{\\text{true}} = 0.05\\,\\text{fm}^3$.\n- Use the following three test cases, each specified by the set of volumes and the maximum momentum:\n  1. Case A: volumes $[8.0, 12.0]\\,\\text{fm}$, $k_{\\max} = 0.40\\,\\text{fm}^{-1}$.\n  2. Case B: volumes $[16.0, 20.0]\\,\\text{fm}$, $k_{\\max} = 0.60\\,\\text{fm}^{-1}$.\n  3. Case C: volumes $[10.0]\\,\\text{fm}$, $k_{\\max} = 0.25\\,\\text{fm}^{-1}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results of the three test cases as a comma-separated list enclosed in square brackets, for example, \"[True,False,True]\".\n- Each entry is a boolean indicating whether $P$ is identifiable under the specified volumes and $k$ coverage for that test case.",
            "solution": "The problem as stated is valid. It is scientifically grounded in the principles of quantum scattering theory and statistical data analysis, specifically within the context of computational nuclear physics and the Lüscher method. The problem is well-posed, providing all necessary parameters, constants, and a clear, objective criterion for its resolution. It is self-contained and free from internal contradictions or ambiguities. We may therefore proceed with a formal solution.\n\nThe objective is to determine the statistical identifiability of the shape parameter $P$ in the s-wave Effective Range Expansion (ERE) from mock data. The ERE is given by\n$$\ny(k) = k \\cot \\delta_0(k) = -\\frac{1}{a} + \\frac{r}{2} k^2 + P\\, k^4\n$$\nwhere $k$ is the relative momentum. The analysis hinges on whether the coefficient $P$ of the $k^4$ term can be resolved with statistical significance from data that simulates measurements in finite periodic volumes. The solution involves a three-stage process: synthetic data generation, statistical model fitting via least squares, and an assessment of parameter uncertainty.\n\n**1. Synthetic Data Generation**\n\nThe problem provides a simplified prescription for generating mock data that captures the essential kinematic constraints of a finite-volume experiment without requiring the full numerical solution of the Lüscher quantization condition. For a cubic volume of side length $L$, the accessible relative momenta $k$ are bounded from below by $k_{\\min}(L) = \\frac{2\\pi}{L}$. For a given test scenario, which specifies a set of volumes $\\{L_j\\}$ and a maximum momentum $k_{\\max}$, we generate data as follows:\n\nFor each volume $L_j$:\n- Calculate the minimum momentum $k_{\\min}(L_j) = \\frac{2\\pi}{L_j}$.\n- If the kinematic interval $[k_{\\min}(L_j), k_{\\max}]$ is non-empty (i.e., $k_{\\min}(L_j)  k_{\\max}$), we generate $N_L = 12$ momentum points, $\\{k_i\\}$, uniformly spaced within this interval.\n- For each $k_i$, the \"true\" observable $y_{\\text{true}, i}$ is calculated using the ERE with the given true parameters: $a_{\\text{true}} = 5.0\\,\\text{fm}$, $r_{\\text{true}} = 1.7\\,\\text{fm}$, and $P_{\\text{true}} = 0.05\\,\\text{fm}^3$.\n- A noisy observation $y_i$ is then generated by adding Gaussian noise: $y_i = y_{\\text{true}, i} + \\varepsilon_i$, where $\\varepsilon_i$ is drawn from a normal distribution $\\mathcal{N}(0, \\sigma^2)$ with a fixed standard deviation $\\sigma = 3 \\times 10^{-3}\\,\\text{fm}^{-1}$.\n\nAll data points $(k_i, y_i)$ generated across all specified volumes for a given test case are pooled into a single dataset. If for a given test case no volume yields a valid momentum interval, the resulting dataset is empty.\n\n**2. Linear Regression Model**\n\nThe ERE is a polynomial in the variable $k^2$. This structure allows us to cast the fitting problem as a standard multiple linear regression. We seek to fit the model\n$$\ny = \\alpha_0 \\cdot 1 + \\alpha_2 \\cdot k^2 + \\alpha_4 \\cdot k^4\n$$\nto the generated data points $(k_i, y_i)$. This can be expressed in matrix form as $Y = X\\beta + \\epsilon$, where:\n- $Y$ is the vector of $N$ observations, $[y_1, y_2, \\dots, y_N]^T$.\n- $X$ is the $N \\times 3$ design matrix, where the $i$-th row is $[1, k_i^2, k_i^4]$.\n- $\\beta$ is the vector of parameters to be estimated: $[\\alpha_0, \\alpha_2, \\alpha_4]^T$.\n- $\\epsilon$ is the vector of noise terms, $[\\varepsilon_1, \\varepsilon_2, \\dots, \\varepsilon_N]^T$.\n\n**3. Parameter Estimation and Uncertainty**\n\nThe problem specifies using weighted least squares (WLS) with weights $w_i = 1/\\sigma^2$. Since the noise variance $\\sigma^2$ is constant for all data points, the WLS estimator for $\\beta$ simplifies to the ordinary least squares (OLS) estimator:\n$$\n\\hat{\\beta} = (X^T X)^{-1} X^T Y\n$$\nThis provides the best-fit estimates $\\widehat{\\alpha}_0$, $\\widehat{\\alpha}_2$, and $\\widehat{\\alpha}_4$.\n\nThe statistical uncertainty of these estimates is captured by their covariance matrix. For WLS, the covariance matrix of the estimator $\\hat{\\beta}$ is given by:\n$$\n\\text{Cov}(\\hat{\\beta}) = (X^T W X)^{-1}\n$$\nwhere $W$ is the diagonal matrix of weights. In our case, $W = \\frac{1}{\\sigma^2}I$, where $I$ is the identity matrix. The covariance matrix thus becomes:\n$$\n\\text{Cov}(\\hat{\\beta}) = \\left(X^T \\left(\\frac{1}{\\sigma^2}I\\right) X\\right)^{-1} = \\sigma^2 (X^T X)^{-1}\n$$\nThe variance of the estimate for the shape parameter, $\\text{Var}(\\widehat{\\alpha}_4)$, is the third diagonal element of this matrix, $(\\text{Cov}(\\hat{\\beta}))_{33}$. The standard error is its square root:\n$$\n\\sigma_{\\widehat{\\alpha}_4} = \\sqrt{\\text{Var}(\\widehat{\\alpha}_4)} = \\sigma \\sqrt{((X^T X)^{-1})_{33}}\n$$\n\n**4. The Identifiability Criterion**\n\nA parameter is statistically identifiable if its estimated value is significantly different from zero, relative to its estimation uncertainty. The problem provides a precise $3\\sigma$ criterion for this: the shape parameter $P$ (represented by $\\alpha_4$) is deemed identifiable if its estimate $\\widehat{\\alpha}_4$ satisfies the condition:\n$$\n|\\widehat{\\alpha}_4| \\geq 3 \\,\\sigma_{\\widehat{\\alpha}_4}\n$$\nThis condition is evaluated for each test case. If a test case yields an insufficient number of data points to constrain the three model parameters (i.e., fewer than $3$ points), the matrix $X^T X$ becomes singular, the uncertainties are formally infinite, and the parameter is, by definition, not identifiable.\n\nThe following program implements this entire procedure, evaluating the identifiability for each of the three specified test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Assesses the identifiability of the s-wave shape parameter in the ERE\n    using mock finite-volume spectra, as specified in the problem statement.\n    \"\"\"\n    \n    # --- Problem Constants and Parameters ---\n    # True physical parameters for data generation\n    a_true = 5.0  # fm\n    r_true = 1.7  # fm\n    P_true = 0.05 # fm^3\n\n    # Derived ERE coefficients\n    alpha0_true = -1.0 / a_true\n    alpha2_true = r_true / 2.0\n    alpha4_true = P_true\n\n    # Statistical and sampling parameters\n    sigma = 3e-3     # fm^-1\n    N_L = 12         # Samples per volume\n    seed = 42        # Fixed seed for reproducibility\n    \n    # --- Test Cases ---\n    test_cases = [\n        {'name': 'A', 'volumes': [8.0, 12.0], 'k_max': 0.40},\n        {'name': 'B', 'volumes': [16.0, 20.0], 'k_max': 0.60},\n        {'name': 'C', 'volumes': [10.0], 'k_max': 0.25},\n    ]\n\n    results = []\n    rng = np.random.default_rng(seed)\n\n    for case in test_cases:\n        all_k = []\n        all_y = []\n\n        # 1. Data Generation\n        for L in case['volumes']:\n            k_min = 2.0 * np.pi / L\n            k_max = case['k_max']\n\n            if k_min  k_max:\n                # Generate N_L evenly spaced momentum samples\n                k_samples = np.linspace(k_min, k_max, N_L)\n                \n                # Calculate true y = k*cot(delta_0) values\n                y_true = (alpha0_true + \n                          alpha2_true * k_samples**2 + \n                          alpha4_true * k_samples**4)\n                \n                # Add Gaussian noise\n                noise = rng.normal(loc=0.0, scale=sigma, size=N_L)\n                y_samples = y_true + noise\n                \n                all_k.extend(k_samples)\n                all_y.extend(y_samples)\n        \n        k_data = np.array(all_k)\n        y_data = np.array(all_y)\n\n        # A fit requires at least as many points as parameters (3)\n        if k_data.shape[0]  3:\n            results.append(False)\n            continue\n\n        # 2. Linear Regression Setup\n        # Design matrix X with columns [1, k^2, k^4]\n        X = np.stack([np.ones_like(k_data), k_data**2, k_data**4], axis=1)\n\n        try:\n            # 3. Parameter Estimation and Uncertainty\n            # Calculate (X^T X)^-1, which is needed for the covariance matrix\n            XTX_inv = np.linalg.inv(X.T @ X)\n\n            # Estimate parameters beta_hat = (X^T X)^-1 X^T y\n            beta_hat = XTX_inv @ X.T @ y_data\n            \n            # The shape parameter estimate is the third coefficient\n            alpha4_hat = beta_hat[2]\n\n            # Calculate covariance matrix: Cov(beta) = sigma^2 * (X^T X)^-1\n            cov_beta = sigma**2 * XTX_inv\n            \n            # Variance of alpha4_hat is the (3,3) element\n            var_alpha4 = cov_beta[2, 2]\n            \n            # Standard error is the square root of the variance\n            std_err_alpha4 = np.sqrt(var_alpha4)\n\n            # 4. Apply Identifiability Criterion\n            is_identifiable = np.abs(alpha4_hat) = 3.0 * std_err_alpha4\n            results.append(is_identifiable)\n\n        except np.linalg.LinAlgError:\n            # If X^T X is singular, parameters are not identifiable\n            results.append(False)\n\n    # Final output formatting\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}