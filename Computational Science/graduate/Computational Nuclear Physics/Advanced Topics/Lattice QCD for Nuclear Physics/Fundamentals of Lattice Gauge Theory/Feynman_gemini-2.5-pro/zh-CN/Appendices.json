{
    "hands_on_practices": [
        {
            "introduction": "在格点规范理论中，一项基本任务是从有限晶格间距 $a$ 下的模拟数据中提取物理预测。本练习将探讨如何利用Symanzik有效理论来指导外推函数的形式，从而将可观测量外推至连续极限（$a \\to 0$）。你将实现一个加权最小二乘拟合，这是处理带有统计不确定性的模拟数据的标准方法。",
            "id": "3560462",
            "problem": "给定在一个无量纲格点可观测量 $O(a)$ 在几个非零格点间距 $a$ 上的测量值，以及每次测量的独立标准差。受格点规范理论中用于处理截断效应的 Symanzik 有效理论的启发，我们假设离散化误差遵循以下模型：$$O(a) = O(0) + c_1 \\, a^2 + c_2 \\, a^4,$$ 其中 $O(0)$ 是待估计的连续极限值，$c_1$ 和 $c_2$ 是未知系数。假设在格点间距 $a_i$ 处的每个测量值 $y_i$ 满足 $$y_i = O(a_i) + \\varepsilon_i,$$ 其中 $\\varepsilon_i$ 是独立的、均值为零且方差为已知值 $\\sigma_i^2$ 的高斯随机变量。在所有量均为无量纲的单位制下进行计算。\n\n您的任务是使用高斯噪声模型下的最大似然估计（等价于上述模型的加权最小二乘拟合），为每个数据集估计 $O(0)$。\n\n请实现一个程序，对以下三个数据集分别执行 $O(0)$ 的加权最小二乘估计。每个数据集都提供了一系列格点间距 $a_i$、观测值 $y_i$ 和标准差 $\\sigma_i$。这三个数据集是：\n\n- 数据集 A（一般情况，多个间距，具有中等程度的离散化效应）：\n  - $a$: [$0.14$, $0.12$, $0.10$, $0.08$, $0.06$]\n  - $y$: [$0.52000792$, $0.51449632$, $0.50965$, $0.50627952$, $0.50399352$]\n  - $\\sigma$: [$0.0015$, $0.0012$, $0.0010$, $0.0010$, $0.0009$]\n\n- 数据集 B（覆盖从粗到细的间距，具有更强的 $a^4$ 效应）：\n  - $a$: [$0.20$, $0.16$, $0.12$, $0.08$, $0.04$]\n  - $y$: [$0.7279$, $0.73662304$, $0.74187104$, $0.74562144$, $0.74914384$]\n  - $\\sigma$: [$0.0020$, $0.0016$, $0.0013$, $0.0011$, $0.0010$]\n\n- 数据集 C（边界情况，使用最少的点数来确定所有三个参数）：\n  - $a$: [$0.18$, $0.10$, $0.05$]\n  - $y$: [$1.25139952$, $1.2505$, $1.2498125$]\n  - $\\sigma$: [$0.0012$, $0.0008$, $0.0006$]\n\n数学和算法要求：\n\n- 将参数矢量视为 $\\boldsymbol{\\beta} = \\big(O(0), c_1, c_2\\big)$，设计矩阵的行形式为 $\\big(1, a_i^2, a_i^4\\big)$。\n- 在独立高斯误差（方差为已知的 $\\sigma_i^2$）的假设下，使用加权最小二乘法。\n- 必须使用标准的线性代数程序，以数值稳定的方式求解正规方程来计算估计量。\n- 对于每个数据集，仅输出估计的 $O(0)$ 值，并四舍五入到 $6$ 位小数。\n\n最终输出要求：\n\n- 您的程序应生成单行输出，其中包含数据集 A、数据集 B 和数据集 C 的三个估计连续极限值 $O(0)$，按此顺序排列，形式为方括号内由逗号分隔的列表。例如，格式必须与此完全一样（以下数字仅为示例）：\n  - 示例格式：[$0.123456$, $0.234567$, $0.345678$]\n- 输出中的数字必须精确到 $6$ 位小数。\n\n测试套件覆盖范围说明：\n\n- 数据集 A 是一个通用的多点情况，用于测试在具有中等离散效应下的稳健估计。\n- 数据集 B 强调了更强的高阶效应和更宽的格点间距范围，以测试对 $a^4$ 项的敏感性。\n- 数据集 C 是一个恰好有三个点的边界情况，用于在模型恰定（just-determined）时强调可辨识性和矩阵条件数问题。\n\n您的解决方案应可在任何现代编程语言中通用实现，并且必须遵循上述加权最小二乘原理。由于所有量都是无量纲的，因此不需要物理单位。",
            "solution": "目标是通过将模型 $O(a) = O(0) + c_1 a^2 + c_2 a^4$ 拟合到具有相关不确定度 $\\sigma_i$ 的数据点 $(a_i, y_i)$，来找到可观测量的连续极限值 $O(0)$。这是一个线性回归问题，因为模型对其参数 $\\boldsymbol{\\beta} = \\big(O(0), c_1, c_2\\big)^T$ 是线性的。对于 $n$ 个数据点，该方程组可以表示为矩阵形式：\n$$ \\mathbf{y} = X\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon} $$\n其中 $\\mathbf{y}$ 是观测值的 $n \\times 1$ 向量，$X$ 是 $n \\times 3$ 的设计矩阵，$\\boldsymbol{\\beta}$ 是 $3 \\times 1$ 的参数向量，$\\boldsymbol{\\varepsilon}$ 是随机误差的 $n \\times 1$ 向量。\n\n设计矩阵 $X$ 的第 $i$ 行对应于第 $i$ 次测量，由 $\\big(1, a_i^2, a_i^4\\big)$ 给出。因此，\n$$\nX = \\begin{pmatrix}\n1 & a_1^2 & a_1^4 \\\\\n1 & a_2^2 & a_2^4 \\\\\n\\vdots & \\vdots & \\vdots \\\\\n1 & a_n^2 & a_n^4\n\\end{pmatrix}\n, \\quad\n\\boldsymbol{\\beta} = \\begin{pmatrix}\nO(0) \\\\ c_1 \\\\ c_2\n\\end{pmatrix}\n, \\quad\n\\mathbf{y} = \\begin{pmatrix}\ny_1 \\\\ y_2 \\\\ \\vdots \\\\ y_n\n\\end{pmatrix}\n$$\n问题指出，误差 $\\varepsilon_i$ 是独立的，并且服从均值为 $0$、方差为 $\\sigma_i^2$ 的正态分布。在给定参数 $\\boldsymbol{\\beta}$ 的条件下，最大化观测到数据 $\\mathbf{y}$ 的似然性，等价于最小化加权残差平方和，也称为卡方 $\\chi^2$：\n$$ \\chi^2(\\boldsymbol{\\beta}) = \\sum_{i=1}^{n} \\left( \\frac{y_i - (O(0) + c_1 a_i^2 + c_2 a_i^4)}{\\sigma_i} \\right)^2 $$\n这可以表示为矩阵形式：\n$$ \\chi^2(\\boldsymbol{\\beta}) = (\\mathbf{y} - X\\boldsymbol{\\beta})^T W (\\mathbf{y} - X\\boldsymbol{\\beta}) $$\n其中 $W$ 是权重矩阵，即误差协方差矩阵的逆。由于误差是独立的，$W$ 是一个对角矩阵，其元素为 $W_{ii} = 1/\\sigma_i^2$。\n\n最小化 $\\chi^2$ 的参数向量 $\\hat{\\boldsymbol{\\beta}}$ 通过求解加权最小二乘正规方程得到：\n$$ (X^T W X) \\hat{\\boldsymbol{\\beta}} = X^T W \\mathbf{y} $$\n其解的形式为：\n$$ \\hat{\\boldsymbol{\\beta}} = (X^T W X)^{-1} X^T W \\mathbf{y} $$\n为了数值稳定性，最好在不显式计算逆矩阵的情况下求解该系统。一种标准方法是将加权最小二乘（WLS）问题转换为普通最小二乘（OLS）问题。我们定义一个缩放后的向量 $\\mathbf{y}'$ 和一个缩放后的设计矩阵 $X'$：\n$$ \\mathbf{y}' = W^{1/2} \\mathbf{y} \\quad \\text{和} \\quad X' = W^{1/2} X $$\n其中 $W^{1/2}$ 是一个对角矩阵，其元素为 $(W^{1/2})_{ii} = 1/\\sigma_i$。这意味着 $X'$ 的第 $i$ 行是 $X$ 的第 $i$ 行除以 $\\sigma_i$，而 $\\mathbf{y}'$ 的第 $i$ 个元素是 $y_i/\\sigma_i$。$\\chi^2$ 表达式变为变换后变量的非加权平方和：\n$$ \\chi^2(\\boldsymbol{\\beta}) = (\\mathbf{y}' - X'\\boldsymbol{\\beta})^T (\\mathbf{y}' - X'\\boldsymbol{\\beta}) $$\n这是一个标准的 OLS 问题，其解 $\\hat{\\boldsymbol{\\beta}}$ 可以使用如 QR 分解等稳健的数值技术找到。像 `numpy.linalg.lstsq` 这样的标准库函数就实现了这个过程。\n\n每个数据集的算法如下：\n1. 从提供的 $y_i$ 值构建观测向量 $\\mathbf{y}$。\n2. 构建设计矩阵 $X$，其中第 $i$ 行为 $(1, a_i^2, a_i^4)$。\n3. 通过将 $X$ 的每一行 $i$ 除以对应的标准差 $\\sigma_i$ 来构建缩放矩阵 $X'$。\n4. 通过将每个元素 $y_i$ 除以 $\\sigma_i$ 来构建缩放向量 $\\mathbf{y}'$。\n5. 求解线性最小二乘系统 $X'\\boldsymbol{\\beta} \\approx \\mathbf{y}'$，以得到参数向量 $\\hat{\\boldsymbol{\\beta}} = \\big(\\hat{O}(0), \\hat{c}_1, \\hat{c}_2\\big)^T$。\n6. 所得向量的第一个元素 $\\hat{\\boldsymbol{\\beta}}_0$ 即为 $O(0)$ 的估计值。\n7. 按要求将估计值四舍五入到 $6$ 位小数。对所有三个数据集重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs weighted least squares estimation for continuum limit extrapolation\n    on three datasets as specified in the problem.\n    \"\"\"\n    \n    # Define the three datasets from the problem statement.\n    test_cases = [\n        # Dataset A (general case)\n        {\n            \"a\": [0.14, 0.12, 0.10, 0.08, 0.06],\n            \"y\": [0.52000792, 0.51449632, 0.50965, 0.50627952, 0.50399352],\n            \"sigma\": [0.0015, 0.0012, 0.0010, 0.0010, 0.0009]\n        },\n        # Dataset B (stronger a^4 effects)\n        {\n            \"a\": [0.20, 0.16, 0.12, 0.08, 0.04],\n            \"y\": [0.7279, 0.73662304, 0.74187104, 0.74562144, 0.74914384],\n            \"sigma\": [0.0020, 0.0016, 0.0013, 0.0011, 0.0010]\n        },\n        # Dataset C (minimal number of points)\n        {\n            \"a\": [0.18, 0.10, 0.05],\n            \"y\": [1.25139952, 1.2505, 1.2498125],\n            \"sigma\": [0.0012, 0.0008, 0.0006]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Extract data and convert to numpy arrays for calculation\n        a = np.array(case[\"a\"])\n        y = np.array(case[\"y\"])\n        sigma = np.array(case[\"sigma\"])\n        \n        # The model is O(a) = beta_0 + beta_1 * a^2 + beta_2 * a^4\n        # where beta_0 = O(0), beta_1 = c1, beta_2 = c2.\n        # This is a linear model. We perform a weighted least squares fit.\n        \n        # Construct the design matrix X.\n        # The columns are the basis functions: 1, a^2, a^4.\n        X = np.vstack([np.ones_like(a), a**2, a**4]).T\n        \n        # A weighted least squares problem with weights w_i = 1/sigma_i^2 is\n        # equivalent to an ordinary least squares problem on variables scaled\n        # by 1/sigma_i.\n        \n        # Scale the rows of the design matrix X by 1/sigma.\n        # The inv_sigma must be a column vector to broadcast correctly.\n        inv_sigma = 1.0 / sigma\n        X_prime = X * inv_sigma[:, np.newaxis]\n        \n        # Scale the measurement vector y by 1/sigma.\n        y_prime = y * inv_sigma\n        \n        # Solve the linear least squares system X_prime * beta = y_prime\n        # for the parameter vector beta = [O(0), c1, c2].\n        # np.linalg.lstsq is a robust solver, typically using QR decomposition.\n        beta_hat, _, _, _ = np.linalg.lstsq(X_prime, y_prime, rcond=None)\n        \n        # The first element of the solution vector is the estimate for O(0).\n        O0_estimate = beta_hat[0]\n        \n        results.append(O0_estimate)\n\n    # Format the results to exactly 6 decimal places and print in the required format.\n    results_formatted = [\"{:.6f}\".format(r) for r in results]\n    print(f\"[{','.join(results_formatted)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然许多模拟使用各向同性的晶格，但对于某些物理问题，在时间（$a_t$）和空间（$a_s$）间距之间引入各向异性可能非常有利。本练习演示了如何通过两个独立的物理可观测量——强子色散关系和威尔逊圈比率——来校准重整化的各向异性参数 $\\xi = a_s / a_t$。这项任务将基本理论原理与设置高级模拟的关键实践步骤联系起来。",
            "id": "3560441",
            "problem": "考虑欧几里得格点量子色动力学 (LQCD) 的各项异性离散化，其中空间格距为 $a_s$，时间格距为 $a_t$。重整化各向异性定义为 $\\xi = a_s / a_t$。在一个具有周期性边界条件的 $N_s$ 个格点的有限空间盒子中，允许的空间动量由整数 $n \\in \\{0,1,2,\\dots\\}$ 标记，并满足 $p_{\\ell}(n) = a_s p_{\\mathrm{phys}}(n) = \\frac{2\\pi n}{N_s}$，以无量纲格点单位表示。能量 $E_{\\ell}$ 也是无量纲的，满足 $E_{\\ell} = a_t E_{\\mathrm{phys}}$。\n\n从相对论能量-动量关系以及欧几里得关联函数和 Wilson 圈的定义出发，从两个独立的可观测量中推导出重整化各向异性 $\\xi$ 的有原则的估计量：\n- 单强子色散关系，使用在多个空间动量 $p_{\\ell}(n)$ 下测得的能量 $E_{\\ell}(n)$，以及\n- 矩形 Wilson 圈比值，使用时间方向的 Wilson 圈 $W(R,T)$ 和纯空间方向的 Wilson 圈 $W_s(R,S)$。\n\n你的程序必须实现这两种估计量，并为下面指定的每个测试用例返回它们。所有量都应以无量纲格点单位处理，所有角度都以弧度为单位。最终输出是无量纲数。\n\n推导的基本依据：\n- 自然单位制中的相对论能量-动量关系为 $E_{\\mathrm{phys}}^2 = m_{\\mathrm{phys}}^2 + \\vec{p}_{\\mathrm{phys}}^{\\,2}$。\n- 在欧几里得 LQCD 中，一个空间范围为 $R$、时间范围为 $T$ 的零温矩形 Wilson 圈 $W(R,T)$ 随时间范围近似呈指数衰减，由静态势决定；类似地，一个全空间的矩形圈 $W_s(R,S)$ 随其空间范围呈指数衰减。\n- 格点量满足 $E_{\\ell} = a_t E_{\\mathrm{phys}}$ 和 $p_{\\ell} = a_s p_{\\mathrm{phys}}$。\n\n估计量设计要求：\n1. 从强子色散关系：对在多个 $p_{\\ell}(n)$ 处测量的 $E_{\\ell}(n)$ 使用统计上一致的拟合程序，以估计编码 $\\xi$ 的系数，从而确定 $\\xi$。不要引入任何没有依据的简化公式；从基本关系出发，并将它们映射到格点变量来设计估计量。\n2. 从 Wilson 圈：对于时间圈，在固定的 $R$ 下，从比值 $W(R,T+1)/W(R,T)$ 构建有效指数；对于空间圈，在固定的 $R$ 下，从比值 $W_s(R,S+1)/W_s(R,S)$ 构建有效指数。当达到大 $T$ 和大 $S$ 行为时，使用这些有效指数形成一个在不同 $R$ 上都稳健的 $\\xi$ 估计量。\n\n测试套件规范：\n对于每个测试用例 $k \\in \\{1,2,3\\}$，给定：\n- 空间大小 $N_s^{(k)}$，一组动量指数 $n^{(k)}$，以及测量的无量纲强子能量 $E_{\\ell}^{(k)}(n)$。\n- 对于 Wilson 圈，三个空间范围 $R \\in \\{1,2,3\\}$，振幅列表 $A^{(k)}(R)$ 和 $B^{(k)}(R)$，时间指数 $E_t^{(k)}(R)$，空间指数 $E_s^{(k)}(R)$，以及范围集合 $T^{(k)}$ 和 $S^{(k)}$。时间 Wilson 圈由 $W^{(k)}(R,T) = A^{(k)}(R) \\exp(-E_t^{(k)}(R)\\, T)$ 定义（对于 $T \\in T^{(k)}$），空间 Wilson 圈由 $W_s^{(k)}(R,S) = B^{(k)}(R) \\exp(-E_s^{(k)}(R)\\, S)$ 定义（对于 $S \\in S^{(k)}$）。\n\n提供从强子色散关系得到的估计量 $\\xi_{\\mathrm{had}}^{(k)}$ 和从 Wilson 圈比值得到的估计量 $\\xi_{\\mathrm{W}}^{(k)}$。对于每个测试用例，还要报告一个布尔一致性标志，如果两个估计值之间的绝对差低于容差 $\\delta = 10^{-3}$，则该标志为真。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。\n- 每个元素对应一个测试用例，本身是一个形式为 $[\\xi_{\\mathrm{had}}^{(k)}, \\xi_{\\mathrm{W}}^{(k)}, \\mathrm{consistent}^{(k)}]$ 的子列表。\n- 示例形状（非实际值）：$[[x_1,y_1,\\mathrm{True}], [x_2,y_2,\\mathrm{False}], [x_3,y_3,\\mathrm{True}]]$。\n\n测试用例：\n- 测试用例 1 (理想情况，近各向同性)：\n  - $N_s^{(1)} = 32$\n  - $n^{(1)} = \\{0,1,2,3\\}$\n  - $E_{\\ell}^{(1)}(n)$ 以列表形式提供 $\\{0.600000,\\,0.631303,\\,0.717145,\\,0.841129\\}$\n  - 时间 Wilson 圈：\n    - $R = \\{1,2,3\\}$, $T^{(1)} = \\{1,2,3,4\\}$\n    - $A^{(1)}(R) = \\{0.900000,\\,0.850000,\\,0.800000\\}$\n    - $E_t^{(1)}(R) = \\{0.500000,\\,0.700000,\\,0.900000\\}$\n    - $W^{(1)}(R,T) = A^{(1)}(R) \\exp(-E_t^{(1)}(R)\\, T)$\n  - 空间 Wilson 圈：\n    - $S^{(1)} = \\{1,2,3,4\\}$\n    - $B^{(1)}(R) = \\{0.880000,\\,0.830000,\\,0.780000\\}$\n    - $E_s^{(1)}(R) = \\{0.500000,\\,0.700000,\\,0.900000\\}$\n    - $W_s^{(1)}(R,S) = B^{(1)}(R) \\exp(-E_s^{(1)}(R)\\, S)$\n- 测试用例 2 (各向异性, $\\xi > 1$)：\n  - $N_s^{(2)} = 24$\n  - $n^{(2)} = \\{0,1,2,3\\}$\n  - $E_{\\ell}^{(2)}(n)$ 以列表形式提供 $\\{0.500000,\\,0.513967,\\,0.553764,\\,0.614430\\}$\n  - 时间 Wilson 圈：\n    - $R = \\{1,2,3\\}$, $T^{(2)} = \\{1,2,3,4\\}$\n    - $A^{(2)}(R) = \\{0.920000,\\,0.870000,\\,0.830000\\}$\n    - $E_t^{(2)}(R) = \\{0.450000,\\,0.700000,\\,0.950000\\}$\n    - $W^{(2)}(R,T) = A^{(2)}(R) \\exp(-E_t^{(2)}(R)\\, T)$\n  - 空间 Wilson 圈：\n    - $S^{(2)} = \\{1,2,3,4\\}$\n    - $B^{(2)}(R) = \\{0.890000,\\,0.840000,\\,0.790000\\}$\n    - $E_s^{(2)}(R) = \\{0.990000,\\,1.540000,\\,2.090000\\}$\n    - $W_s^{(2)}(R,S) = B^{(2)}(R) \\exp(-E_s^{(2)}(R)\\, S)$\n- 测试用例 3 (各向异性, $\\xi  1$, 动量点较少的边缘情况)：\n  - $N_s^{(3)} = 16$\n  - $n^{(3)} = \\{0,1,2\\}$\n  - $E_{\\ell}^{(3)}(n)$ 以列表形式提供 $\\{0.300000,\\,0.575392,\\,1.026926\\}$\n  - 时间 Wilson 圈：\n    - $R = \\{1,2,3\\}$, $T^{(3)} = \\{1,2,3,4\\}$\n    - $A^{(3)}(R) = \\{0.930000,\\,0.880000,\\,0.830000\\}$\n    - $E_t^{(3)}(R) = \\{0.300000,\\,0.500000,\\,0.700000\\}$\n    - $W^{(3)}(R,T) = A^{(3)}(R) \\exp(-E_t^{(3)}(R)\\, T)$\n  - 空间 Wilson 圈：\n    - $S^{(3)} = \\{1,2,3,4\\}$\n    - $B^{(3)}(R) = \\{0.910000,\\,0.860000,\\,0.810000\\}$\n    - $E_s^{(3)}(R) = \\{0.240000,\\,0.400000,\\,0.560000\\}$\n    - $W_s^{(3)}(R,S) = B^{(3)}(R) \\exp(-E_s^{(3)}(R)\\, S)$\n\n算法目标：\n- 对每个测试用例，在提供的动量范围内，使用 $E_{\\ell}^2$ 对 $p_{\\ell}^2$ 实现一个基于强子的稳健线性估计量 $\\xi$。\n- 实现从圈比值中提取有效指数的方法，以及一个通过对 $R$ 聚合空间有效指数与时间有效指数之比来估计 $\\xi$ 的方法。\n- 以要求的格式返回最终结果，布尔一致性标志的容差为 $\\delta = 10^{-3}$，即如果 $|\\xi_{\\mathrm{had}} - \\xi_{\\mathrm{W}}| \\le \\delta$ 则报告 $\\mathrm{True}$，否则报告 $\\mathrm{False}$。\n\n你的程序应生成单行输出，包含用方括号括起来的逗号分隔列表，其确切形式为 $[[\\xi_{\\mathrm{had}}^{(1)},\\xi_{\\mathrm{W}}^{(1)},\\mathrm{consistent}^{(1)}],[\\xi_{\\mathrm{had}}^{(2)},\\xi_{\\mathrm{W}}^{(2)},\\mathrm{consistent}^{(2)}],[\\xi_{\\mathrm{had}}^{(3)},\\xi_{\\mathrm{W}}^{(3)},\\mathrm{consistent}^{(3)}]]$。",
            "solution": "所述问题具有科学依据，是客观且定义明确的。它提供了一套完整的数据和定义，用于在各向异性格点 QCD 的背景下推导和实现重整化各向异性 $\\xi$ 的估计量。该问题基于相对论色散关系和 Wilson 圈行为，这些是该领域的基础。提供的测试用例是简化的（Wilson 圈的理想化指数衰减），但定义明确，使该问题成为应用理论原理的一个有效且易于处理的练习。因此，我们可以着手推导估计量。\n\n分析基于两个独立的物理可观测量：强子色散关系和矩形 Wilson 圈的比值。\n\n**1. 从强子色散关系得到的估计量 ($\\xi_{\\mathrm{had}}$)**\n\n基本原理是连续统中的相对论能量-动量关系，以自然单位制 ($\\hbar=c=1$) 表示：\n$$\nE_{\\mathrm{phys}}^2 = m_{\\mathrm{phys}}^2 + \\vec{p}_{\\mathrm{phys}}^{\\,2}\n$$\n其中 $E_{\\mathrm{phys}}$ 是能量，$m_{\\mathrm{phys}}$ 是静止质量，$\\vec{p}_{\\mathrm{phys}}$ 是强子的动量。\n\n在各向异性格点离散化中，物理量通过空间和时间格距 $a_s$ 和 $a_t$ 分别与无量纲格点量相关。这些关系如下：\n$$\nE_{\\ell} = a_t E_{\\mathrm{phys}} \\implies E_{\\mathrm{phys}} = \\frac{E_{\\ell}}{a_t}\n$$\n$$\np_{\\ell} = a_s p_{\\mathrm{phys}} \\implies p_{\\mathrm{phys}} = \\frac{p_{\\ell}}{a_s}\n$$\n此处，$E_{\\ell}$ 和 $p_{\\ell}$ 是格点单位下的无量纲能量和动量。在具有周期性边界条件的 $N_s$ 个格点的有限格子上，动量是量子化的，对于整数 $n$，$p_{\\ell}(n) = \\frac{2\\pi n}{N_s}$。\n\n将格点单位表达式代入连续统能量-动量关系，得到：\n$$\n\\left(\\frac{E_{\\ell}}{a_t}\\right)^2 = m_{\\mathrm{phys}}^2 + \\left(\\frac{p_{\\ell}}{a_s}\\right)^2\n$$\n为了让重整化各向异性 $\\xi = a_s / a_t$ 出现，我们将整个方程乘以 $a_t^2$：\n$$\nE_{\\ell}^2 = (a_t m_{\\mathrm{phys}})^2 + \\frac{a_t^2}{a_s^2} p_{\\ell}^2\n$$\n认识到 $(a_t/a_s)^2 = (1/\\xi)^2$ 并将时间格点单位中的无量纲质量定义为 $m_{\\ell,t} = a_t m_{\\mathrm{phys}}$，我们得到格点色散关系：\n$$\nE_{\\ell}^2 = m_{\\ell,t}^2 + \\frac{1}{\\xi^2} p_{\\ell}^2\n$$\n这个方程建立了 $E_{\\ell}^2$ 和 $p_{\\ell}^2$ 之间的线性关系。如果我们考虑在不同动量 $p_{\\ell}(n)$ 下的一组强子能量测量值 $E_{\\ell}(n)$，我们可以将其建模为一个线性方程 $Y = C + M X$，其中：\n- $Y = E_{\\ell}^2$\n- $X = p_{\\ell}^2$\n- $C = m_{\\ell,t}^2$ 是截距，对应于时间格点单位中强子质量的平方。\n- $M = 1/\\xi^2$ 是斜率。\n\n为了确定 $\\xi$，我们可以对给定动量模式 $n$ 的数据点 $(p_{\\ell}(n)^2, E_{\\ell}(n)^2)$ 进行线性回归。最佳拟合线的斜率 $M$ 直接给出了各向异性的估计。从 $M = 1/\\xi^2$，我们可以解出 $\\xi$。由于 $\\xi$ 是正定格距的比值，我们取正根：\n$$\n\\xi_{\\mathrm{had}} = \\sqrt{\\frac{1}{M}} = \\frac{1}{\\sqrt{M}}\n$$\n这提供了一个基于测量的强子谱、有原则且统计上稳健的各向异性估计量。\n\n**2. 从 Wilson 圈比值得到的估计量 ($\\xi_{\\mathrm{W}}$)**\n\n第二个估计量是从矩形 Wilson 圈的行为中推导出来的。在像 QCD 这样的禁闭规范理论中，大 Wilson 圈的期望值表现出面积定律。对于矩形圈，这表现为指数衰减。\n\n对于一个时间方向的 Wilson 圈 $W(R,T)$，其空间范围为 $R$，时间范围为 $T$（以格点单位计），当 $T$ 很大时，其衰减由静态夸克-反夸克势 $V_{\\mathrm{phys}}$ 决定。物理面积是 $(R a_s) \\times (T a_t)$。然而，标准的表述是圈的期望值随时间演化，所以 $W(R,T) \\propto \\exp(-V_{\\mathrm{phys}}(r) \\cdot t)$，其中 $r = R a_s$ 是物理分离距离，$t = T a_t$ 是物理时间。这给出：\n$$\nW(R,T) \\sim \\exp(-V_{\\mathrm{phys}}(R a_s) \\cdot T a_t)\n$$\n问题提供了一个函数形式 $W(R,T) = A(R) \\exp(-E_t(R) T)$。比较指数，我们将无量纲时间指数 $E_t(R)$ 识别为：\n$$\nE_t(R) = a_t V_{\\mathrm{phys}}(R a_s)\n$$\n这个量是时间格点单位中的静态势。问题要求从比值构造有效指数，对于大 $T$，它定义为 $V_{t, \\text{eff}}(R) = -\\ln(W(R,T+1)/W(R,T))$。对于给定的理想指数形式，这个计算证实了对于所有 $T$ 都有 $V_{t, \\text{eff}}(R) = E_t(R)$。\n\n对于一个纯空间的 Wilson 圈 $W_s(R,S)$，其在空间平面内的范围为 $R$ 和 $S$，其底层物理受同样的静态势 $V_{\\mathrm{phys}}$ 支配，这是由欧几里得不变性决定的。物理长度是 $R_{phys} = R a_s$ 和 $S_{phys} = S a_s$。因此其行为是：\n$$\nW_s(R,S) \\sim \\exp(-V_{\\mathrm{phys}}(R a_s) \\cdot S a_s)\n$$\n问题提供了形式 $W_s(R,S) = B(R) \\exp(-E_s(R) S)$。比较指数，我们将无量纲空间指数 $E_s(R)$ 识别为：\n$$\nE_s(R) = a_s V_{\\mathrm{phys}}(R a_s)\n$$\n这是空间格点单位中的静态势。同样，从比值得到的有效指数 $V_{s, \\text{eff}}(R) = -\\ln(W_s(R,S+1)/W_s(R,S))$ 对所有 $S$ 来说显然就是 $E_s(R)$。\n\n我们现在对同一个物理量 $V_{\\mathrm{phys}}(R a_s)$ 有了两个用不同无量纲单位测量的表达式。这两个表达式的比值消除了未知的势 $V_{\\mathrm{phys}}$：\n$$\n\\frac{E_s(R)}{E_t(R)} = \\frac{a_s V_{\\mathrm{phys}}(R a_s)}{a_t V_{\\mathrm{phys}}(R a_s)} = \\frac{a_s}{a_t} = \\xi\n$$\n对于任何势描述有效的间距 $R$，这个关系都应该成立。为了获得一个单一的稳健估计量，我们可以对可用的 $R$ 值上的 $\\xi$ 测定值集合进行平均。对于每个测试用例，我们都给出了 $R \\in \\{1,2,3\\}$ 的指数。因此，估计量 $\\xi_{\\mathrm{W}}$ 是算术平均值：\n$$\n\\xi_{\\mathrm{W}} = \\frac{1}{N_R} \\sum_{R} \\frac{E_s(R)}{E_t(R)}\n$$\n其中求和是针对提供的 $R$ 值，而 $N_R$ 是这些值的数量。\n\n计算实现将对每个测试用例遵循这两个推导出的过程。通过将两个估计量 $\\xi_{\\mathrm{had}}$ 和 $\\xi_{\\mathrm{W}}$ 与给定的容差 $\\delta = 10^{-3}$ 进行比较来执行一致性检查。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the lattice QCD anisotropy problem by implementing two estimators\n    for the renormalized anisotropy xi and comparing them.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (happy path, near-isotropic)\n        {\n            \"Ns\": 32,\n            \"n\": [0, 1, 2, 3],\n            \"El\": [0.600000, 0.631303, 0.717145, 0.841129],\n            \"Et\": [0.500000, 0.700000, 0.900000],\n            \"Es\": [0.500000, 0.700000, 0.900000]\n        },\n        # Test case 2 (anisotropic, xi > 1)\n        {\n            \"Ns\": 24,\n            \"n\": [0, 1, 2, 3],\n            \"El\": [0.500000, 0.513967, 0.553764, 0.614430],\n            \"Et\": [0.450000, 0.700000, 0.950000],\n            \"Es\": [0.990000, 1.540000, 2.090000]\n        },\n        # Test case 3 (anisotropic, xi  1, edge case with fewer momenta)\n        {\n            \"Ns\": 16,\n            \"n\": [0, 1, 2],\n            \"El\": [0.300000, 0.575392, 1.026926],\n            \"Et\": [0.300000, 0.500000, 0.700000],\n            \"Es\": [0.240000, 0.400000, 0.560000]\n        }\n    ]\n    \n    delta = 1e-3\n    all_results = []\n\n    for case in test_cases:\n        # 1. Hadron Dispersion Estimator\n        Ns = case[\"Ns\"]\n        n_vals = np.array(case[\"n\"])\n        El_vals = np.array(case[\"El\"])\n\n        # Calculate squared momenta: p_l^2 = (2*pi*n/Ns)^2\n        pl_sq_vals = ((2 * np.pi * n_vals) / Ns)**2\n        \n        # Calculate squared energies: E_l^2\n        El_sq_vals = El_vals**2\n\n        # Perform a linear fit of E_l^2 vs p_l^2.\n        # E_l^2 = m_l^2 + (1/xi^2) * p_l^2\n        # The slope M of the fit is 1/xi^2.\n        slope, intercept = np.polyfit(pl_sq_vals, El_sq_vals, 1)\n        \n        # Avoid division by zero or negative slope, though not expected here.\n        if slope = 0:\n            xi_had = np.inf\n        else:\n            xi_had = np.sqrt(1.0 / slope)\n\n        # 2. Wilson Loop Estimator\n        Et_vals = np.array(case[\"Et\"])\n        Es_vals = np.array(case[\"Es\"])\n\n        # xi = Es(R) / Et(R) for each R.\n        # Average over all R values.\n        xi_ratios = Es_vals / Et_vals\n        xi_W = np.mean(xi_ratios)\n\n        # 3. Consistency Check\n        is_consistent = np.abs(xi_had - xi_W) = delta\n        \n        # Format the result for this case as a list\n        case_result = [xi_had, xi_W, is_consistent]\n        all_results.append(case_result)\n\n    # Format the final output string exactly as specified, without spaces\n    # in the sublists.\n    result_strings = []\n    for res in all_results:\n        # Convert boolean to a lowercase string if needed, but 'True'/'False' is fine.\n        res_str = f\"[{res[0]},{res[1]},{str(res[2])}]\"\n        result_strings.append(res_str)\n        \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "大规模格点规范理论模拟的计算成本极高，需要高效利用如图形处理器（GPU）等高性能计算资源。本练习介绍了一种强大的性能分析工具——roofline模型。你将把它应用于混合蒙特卡罗（HMC）算法的简化模型，以识别性能瓶颈，并量化如核心融合（kernel fusion）等优化技术所带来的益处。",
            "id": "3560466",
            "problem": "您的任务是实现一个完整的、可运行的程序，该程序对一个简化但科学上合理的、用于格点规范理论中三阶特殊酉群（$SU(3)$）的混合蒙特卡罗（HMC）积分器步骤模型，执行一次基于原则的roofline分析。目标是为几组参数集计算算术强度、roofline模型下的可达性能，以及在图形处理器（GPU）上融合规范力累积核函数和链更新核函数所预期的性能影响。该程序必须产生在计算上普遍适用的结果，并避免依赖于所提供的峰值计算和带宽参数之外的特定硬件微观细节。\n\n从以下基本基础开始：\n\n- 在强相互作用的格点规范理论中，规范场由存储在超立方格点边上的链变量 $U \\in SU(3)$ 表示。一个链是一个 $3 \\times 3$ 的特殊酉复矩阵。李代数元素（混合蒙特卡罗哈密顿动力学中的共轭动量）存在于$\\mathfrak{su}(3)$中，可以由对应于$SU(3)$八个生成元的$8$个实数参数表示。\n- 混合蒙特卡罗（HMC）算法使用哈密顿动力学演化 $(U,P)$，通过对从相邻链的局部U型链（staple）计算出的规范力进行积分。单个积分器子步骤的简化模型包括：\n  1. 一个规范力核函数，它读取相邻的$SU(3)$链矩阵以累积力的贡献，并更新动量$P$。\n  2. 一个链更新核函数，它从$P$构造一个指数表示，并将其乘入$U$。\n- roofline模型通过峰值计算能力与内存带宽和算术强度的乘积的最小值来限制可达浮点性能。如果内存带宽为$B$（单位为吉字节每秒），算术强度为$I$（单位为浮点运算每字节），那么可达性能为 $P_{\\mathrm{att}} = \\min\\{P_{\\mathrm{peak}}, B \\times I\\}$，其中$P_{\\mathrm{peak}}$是以吉咖浮点运算每秒为单位的峰值浮点吞吐量。\n- 对于一个稠密的复$3 \\times 3$矩阵-矩阵乘法，我们将其浮点运算成本建模为$F_M = 198$次实数浮点运算。对于一个逐元素的$3 \\times 3$复矩阵加法，我们将其浮点运算成本建模为$F_A = 18$次实数浮点运算。这些成本在格点量子色动力学（QCD）的性能建模中被广泛使用。\n- 内存大小遵循数据布局：\n  - 每个$SU(3)$链矩阵存储为$18$个实数；其大小为$S_U = 18 s$字节，其中$s$是每个实数的字节数（单精度为$s = 4$，双精度为$s = 8$）。\n  - 每个$\\mathfrak{su}(3)$动量存储为$8$个实数；其大小为$S_P = 8 s$字节。\n- 算术强度为 $I = \\dfrac{F}{M}$，其中$F$是总浮点运算次数，$M$是进出全局内存的总数据移动量（以字节为单位）。\n- 计算力并立即应用更新的核函数融合可以通过消除用于临时结果的中间全局内存流量来减少数据移动，从而提高$I$并因此提高$P_{\\mathrm{att}}$。\n\n您的任务是为每个测试用例计算以下量：\n\n1.  对于分离的规范力核函数：\n    - 浮点运算计数 $F_{\\mathrm{force}} = M_{\\mathrm{force}} F_M + A_{\\mathrm{force}} F_A + F_{\\mathrm{proj}}$，其中$M_{\\mathrm{force}}$是每个链的$SU(3)$矩阵-矩阵乘法次数，$A_{\\mathrm{force}}$是每个链的$SU(3)$矩阵加法次数，而$F_{\\mathrm{proj}}$模拟将计算对象投影到$\\mathfrak{su}(3)$中的任何额外浮点运算。\n    - 内存流量 $M_{\\mathrm{force}}^{\\mathrm{bytes}} = c_{\\mathrm{sep}} \\left(R_{\\mathrm{force},U} S_U + R_{\\mathrm{force},P} S_P + W_{\\mathrm{force}} S_P\\right)$，其中$R_{\\mathrm{force},U}$是$SU(3)$链读取次数，$R_{\\mathrm{force},P}$是动量读取次数，$W_{\\mathrm{force}}$是动量写入次数，$c_{\\mathrm{sep}} \\geq 1$模拟分离核函数的合并访问和缓存效率低下。\n    - 算术强度 $I_{\\mathrm{force}} = \\dfrac{F_{\\mathrm{force}}}{M_{\\mathrm{force}}^{\\mathrm{bytes}}}$。\n    - 可达性能 $P_{\\mathrm{force}} = \\min\\{P_{\\mathrm{peak}}, B I_{\\mathrm{force}}\\}$，单位为吉咖浮点运算每秒（GFLOP/s）。\n    - 内存受限布尔标志$b_{\\mathrm{force}}$，如果$B I_{\\mathrm{force}}  P_{\\mathrm{peak}}$则为真，否则为假。\n\n2.  对于分离的链更新核函数：\n    - 浮点运算计数 $F_{\\mathrm{update}} = M_{\\mathrm{update}} F_M + F_{\\mathrm{exp}}$，其中$M_{\\mathrm{update}}$是$SU(3)$矩阵-矩阵乘法次数，$F_{\\mathrm{exp}}$模拟从动量构造指数表示的浮点运算。\n    - 内存流量 $M_{\\mathrm{update}}^{\\mathrm{bytes}} = c_{\\mathrm{sep}} \\left(R_{\\mathrm{update},U} S_U + R_{\\mathrm{update},P} S_P + W_{\\mathrm{update},U} S_U\\right)$，其中$R_{\\mathrm{update},U}$是$SU(3)$链读取次数，$R_{\\mathrm{update},P}$是动量读取次数，$W_{\\mathrm{update},U}$是$SU(3)$链写入次数。\n    - 算术强度 $I_{\\mathrm{update}} = \\dfrac{F_{\\mathrm{update}}}{M_{\\mathrm{update}}^{\\mathrm{bytes}}}$。\n    - 可达性能 $P_{\\mathrm{update}} = \\min\\{P_{\\mathrm{peak}}, B I_{\\mathrm{update}}\\}$，单位为GFLOP/s。\n    - 内存受限布尔标志$b_{\\mathrm{update}}$，定义方式与$b_{\\mathrm{force}}$类似。\n\n3.  对于融合的规范力加更新核函数：\n    - 浮点运算计数 $F_{\\mathrm{fused}} = F_{\\mathrm{force}} + F_{\\mathrm{update}}$。\n    - 内存流量 $M_{\\mathrm{fused}}^{\\mathrm{bytes}} = c_{\\mathrm{fused}} \\left(R_{\\mathrm{force},U} S_U + R_{\\mathrm{force},P} S_P + W_{\\mathrm{update},U} S_U\\right)$，这移除了中间动量的写入及其后续读取，并且也移除了分离的冗余链读取，因为力核函数已经读取了所需的链矩阵。因子$c_{\\mathrm{fused}} \\geq 1$允许在融合下改善内存局部性，当$c_{\\mathrm{fused}}  c_{\\mathrm{sep}}$时。\n    - 算术强度 $I_{\\mathrm{fused}} = \\dfrac{F_{\\mathrm{fused}}}{M_{\\mathrm{fused}}^{\\mathrm{bytes}}}$。\n    - 可达性能 $P_{\\mathrm{fused}} = \\min\\{P_{\\mathrm{peak}}, B I_{\\mathrm{fused}}\\}$，单位为GFLOP/s。\n    - 内存受限布尔标志$b_{\\mathrm{fused}}$。\n\n4.  融合对单个链更新的端到端子步骤时间的预期性能影响。使用每个核函数的roofline预测性能，将每个核函数每个链的模型时间定义为 $T = \\dfrac{F}{P_{\\mathrm{att}}}$，其中$F$是浮点运算次数，$P_{\\mathrm{att}}$是以GFLOP/s为单位；共同的giga尺度因子在比率中被抵消。那么，分离核函数的时间是 $T_{\\mathrm{sep}} = \\dfrac{F_{\\mathrm{force}}}{P_{\\mathrm{force}}} + \\dfrac{F_{\\mathrm{update}}}{P_{\\mathrm{update}}}$，融合核函数的时间是 $T_{\\mathrm{fused}} = \\dfrac{F_{\\mathrm{fused}}}{P_{\\mathrm{fused}}}$。以浮点数形式报告加速比因子 $S = \\dfrac{T_{\\mathrm{sep}}}{T_{\\mathrm{fused}}}$，其中$S > 1$表示融合是有益的。\n\n单位和数值约定：\n\n- 将内存带宽$B$视为吉字节每秒（GB/s）。\n- 将峰值计算吞吐量$P_{\\mathrm{peak}}$视为吉咖浮点运算每秒（GFLOP/s）。\n- 算术强度$I$的单位是浮点运算每字节。\n- 可达性能$P_{\\mathrm{att}}$应以GFLOP/s报告。\n- 不涉及角度。输出中除了指定的单位外，不需要其他物理单位。\n- 所有输出都应以纯数字形式提供，不带单位符号。\n\n测试套件：\n\n实现您的程序，为以下四个参数集计算上述量。每个参数集由元组 $(s, B, P_{\\mathrm{peak}}, M_{\\mathrm{force}}, A_{\\mathrm{force}}, F_{\\mathrm{proj}}, M_{\\mathrm{update}}, F_{\\mathrm{exp}}, R_{\\mathrm{force},U}, R_{\\mathrm{force},P}, W_{\\mathrm{force}}, R_{\\mathrm{update},U}, R_{\\mathrm{update},P}, W_{\\mathrm{update},U}, c_{\\mathrm{sep}}, c_{\\mathrm{fused}})$ 定义，所有参数均按上文所述解释。\n\n- 案例1（单精度，典型高带宽GPU）：\n  - $s = 4$, $B = 900$, $P_{\\mathrm{peak}} = 19000$, $M_{\\mathrm{force}} = 8$, $A_{\\mathrm{force}} = 6$, $F_{\\mathrm{proj}} = 120$, $M_{\\mathrm{update}} = 1$, $F_{\\mathrm{exp}} = 300$, $R_{\\mathrm{force},U} = 12$, $R_{\\mathrm{force},P} = 1$, $W_{\\mathrm{force}} = 1$, $R_{\\mathrm{update},U} = 1$, $R_{\\mathrm{update},P} = 1$, $W_{\\mathrm{update},U} = 1$, $c_{\\mathrm{sep}} = 1.0$, $c_{\\mathrm{fused}} = 1.0$。\n\n- 案例2（同一GPU类别上的双精度）：\n  - $s = 8$, $B = 900$, $P_{\\mathrm{peak}} = 9700$, $M_{\\mathrm{force}} = 8$, $A_{\\mathrm{force}} = 6$, $F_{\\mathrm{proj}} = 200$, $M_{\\mathrm{update}} = 1$, $F_{\\mathrm{exp}} = 600$, $R_{\\mathrm{force},U} = 12$, $R_{\\mathrm{force},P} = 1$, $W_{\\mathrm{force}} = 1$, $R_{\\mathrm{update},U} = 1$, $R_{\\mathrm{update},P} = 1$, $W_{\\mathrm{update},U} = 1$, $c_{\\mathrm{sep}} = 1.0$, $c_{\\mathrm{fused}} = 1.0$。\n\n- 案例3（带宽受限环境，单精度）：\n  - $s = 4$, $B = 300$, $P_{\\mathrm{peak}} = 19000$, $M_{\\mathrm{force}} = 8$, $A_{\\mathrm{force}} = 6$, $F_{\\mathrm{proj}} = 120$, $M_{\\mathrm{update}} = 1$, $F_{\\mathrm{exp}} = 300$, $R_{\\mathrm{force},U} = 12$, $R_{\\mathrm{force},P} = 1$, $W_{\\mathrm{force}} = 1$, $R_{\\mathrm{update},U} = 1$, $R_{\\mathrm{update},P} = 1$, $W_{\\mathrm{update},U} = 1$, $c_{\\mathrm{sep}} = 1.0$, $c_{\\mathrm{fused}} = 1.0$。\n\n- 案例4（独立核函数中不完美的合并访问，融合下局部性改善，单精度）：\n  - $s = 4$, $B = 900$, $P_{\\mathrm{peak}} = 19000$, $M_{\\mathrm{force}} = 8$, $A_{\\mathrm{force}} = 6$, $F_{\\mathrm{proj}} = 120$, $M_{\\mathrm{update}} = 1$, $F_{\\mathrm{exp}} = 300$, $R_{\\mathrm{force},U} = 12$, $R_{\\mathrm{force},P} = 1$, $W_{\\mathrm{force}} = 1$, $R_{\\mathrm{update},U} = 1$, $R_{\\mathrm{update},P} = 1$, $W_{\\mathrm{update},U} = 1$, $c_{\\mathrm{sep}} = 1.3$, $c_{\\mathrm{fused}} = 1.05$。\n\n要求的最终输出格式：\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表的每个元素是每个案例的结果列表，不含嵌入的空格。对于每个案例，按此确切顺序输出列表\n$[I_{\\mathrm{force}}, I_{\\mathrm{update}}, I_{\\mathrm{fused}}, P_{\\mathrm{force}}, P_{\\mathrm{update}}, P_{\\mathrm{fused}}, b_{\\mathrm{force}}, b_{\\mathrm{update}}, b_{\\mathrm{fused}}, S]$\n。布尔值$b_{\\mathrm{force}}$、$b_{\\mathrm{update}}$和$b_{\\mathrm{fused}}$必须打印为$True$或$False$。例如，整体输出的格式为\n$[[r_{1,1},\\dots,r_{1,10}],[r_{2,1},\\dots,r_{2,10}],[r_{3,1},\\dots,r_{3,10}],[r_{4,1},\\dots,r_{4,10}]]$\n，且不含任何空格。",
            "solution": "用户提供了一个问题陈述，要求对格点规范理论中一个简化的混合蒙特卡罗（HMC）积分器步骤进行roofline分析。该分析需要对分离和融合的计算核函数进行。\n\n### 步骤1：提取已知条件\n\n问题陈述提供了以下数据、定义和常量：\n\n**常量和模型参数：**\n- $F_M$: 稠密复$3 \\times 3$矩阵-矩阵乘法的浮点运算成本，建模为$198$次实数浮点运算。\n- $F_A$: 逐元素复$3 \\times 3$矩阵加法的浮点运算成本，建模为$18$次实数浮点运算。\n- $s$: 每个实数的字节数（单精度为$4$，双精度为$8$）。\n- $S_U$: 一个$SU(3)$链矩阵的内存大小，定义为$18s$字节。\n- $S_P$: 一个$\\mathfrak{su}(3)$动量矩阵的内存大小，定义为$8s$字节。\n- $B$: 内存带宽，单位为吉字节每秒（GB/s）。\n- $P_{\\mathrm{peak}}$: 峰值浮点吞吐量，单位为吉咖浮点运算每秒（GFLOP/s）。\n- $c_{\\mathrm{sep}}$: 分离核函数的内存访问效率低下因子。\n- $c_{\\mathrm{fused}}$: 融合核函数的内存访问效率低下因子。\n\n**特定于核函数的参数（每个链）：**\n- $M_{\\mathrm{force}}$: 力核函数中$SU(3)$矩阵-矩阵乘法的次数。\n- $A_{\\mathrm{force}}$: 力核函数中$SU(3)$矩阵加法的次数。\n- $F_{\\mathrm{proj}}$: 力核函数中用于投影的额外浮点运算次数。\n- $R_{\\mathrm{force},U}$: 力核函数中$SU(3)$链读取的次数。\n- $R_{\\mathrm{force},P}$: 力核函数中动量读取的次数。\n- $W_{\\mathrm{force}}$: 力核函数中动量写入的次数。\n- $M_{\\mathrm{update}}$: 更新核函数中$SU(3)$矩阵-矩阵乘法的次数。\n- $F_{\\mathrm{exp}}$: 更新核函数中用于指数构造的额外浮点运算次数。\n- $R_{\\mathrm{update},U}$: 更新核函数中$SU(3)$链读取的次数。\n- $R_{\\mathrm{update},P}$: 更新核函数中动量读取的次数。\n- $W_{\\mathrm{update},U}$: 更新核函数中$SU(3)$链写入的次数。\n\n**公式：**\n- 算术强度：$I = \\dfrac{F}{M}$，其中$F$是总浮点运算次数，$M$是总内存流量（以字节为单位）。\n- 可达性能：$P_{\\mathrm{att}} = \\min\\{P_{\\mathrm{peak}}, B \\times I\\}$。\n- 内存受限标志，$b$：如果 $B \\times I  P_{\\mathrm{peak}}$ 则为真。\n- 力核函数浮点运算：$F_{\\mathrm{force}} = M_{\\mathrm{force}} F_M + A_{\\mathrm{force}} F_A + F_{\\mathrm{proj}}$。\n- 力核函数内存：$M_{\\mathrm{force}}^{\\mathrm{bytes}} = c_{\\mathrm{sep}} \\left(R_{\\mathrm{force},U} S_U + R_{\\mathrm{force},P} S_P + W_{\\mathrm{force}} S_P\\right)$。\n- 更新核函数浮点运算：$F_{\\mathrm{update}} = M_{\\mathrm{update}} F_M + F_{\\mathrm{exp}}$。\n- 更新核函数内存：$M_{\\mathrm{update}}^{\\mathrm{bytes}} = c_{\\mathrm{sep}} \\left(R_{\\mathrm{update},U} S_U + R_{\\mathrm{update},P} S_P + W_{\\mathrm{update},U} S_U\\right)$。\n- 融合核函数浮点运算：$F_{\\mathrm{fused}} = F_{\\mathrm{force}} + F_{\\mathrm{update}}$。\n- 融合核函数内存：$M_{\\mathrm{fused}}^{\\mathrm{bytes}} = c_{\\mathrm{fused}} \\left(R_{\\mathrm{force},U} S_U + R_{\\mathrm{force},P} S_P + W_{\\mathrm{update},U} S_U\\right)$。\n- 核函数时间：$T = \\dfrac{F}{P_{\\mathrm{att}}}$。\n- 分离核函数时间：$T_{\\mathrm{sep}} = \\dfrac{F_{\\mathrm{force}}}{P_{\\mathrm{force}}} + \\dfrac{F_{\\mathrm{update}}}{P_{\\mathrm{update}}}$。\n- 融合核函数时间：$T_{\\mathrm{fused}} = \\dfrac{F_{\\mathrm{fused}}}{P_{\\mathrm{fused}}}$。\n- 加速比：$S = \\dfrac{T_{\\mathrm{sep}}}{T_{\\mathrm{fused}}}$。\n\n**测试用例：**\n提供了四个测试用例，作为上述参数的元组。\n\n### 步骤2：使用提取的已知条件进行验证\n\n- **科学基础**：问题设定在计算格点规范理论的背景下，这是一个核物理和粒子物理学的子领域。所使用的概念——用于规范链的$SU(3)$矩阵、用于动量的$\\mathfrak{su}(3)$元素、混合蒙特卡罗、核函数融合和roofline性能模型——都是该领域的标准、有效和核心概念。$SU(3)$操作的浮点运算计数是性能建模中使用的标准近似值。问题是科学合理的。\n- **问题定义明确**：问题为四个必需的测试用例提供了全套确定性公式和全套输入参数。目标是计算一系列特定量。对于每组输入，公式都会产生唯一的、明确定义的数值结果。问题定义明确。\n- **客观性**：问题以精确、定量的术语陈述。所有变量都已定义，所有必需的计算都由明确的数学公式指定。问题没有主观语言或观点。\n- **无其他缺陷**：问题是可形式化的、完整的且内部一致的。提供的硬件参数（$B$，$P_{\\mathrm{peak}}$）对于现代GPU是现实的。所需的计算并非微不足道，代表了一项标准的性能分析练习。\n\n### 步骤3：结论与行动\n\n问题陈述是**有效的**。它科学合理、定义明确、客观且完整。将提供一个完整的、有理有据的解决方案。\n\n### 解决方案推导\n\n解决方案涉及将所提供的公式系统地应用于四个测试用例中的每一个。我们将通过首先定义基本常量，然后处理每个案例来计算所需的十个输出量：$I_{\\mathrm{force}}$、$I_{\\mathrm{update}}$、$I_{\\mathrm{fused}}$、$P_{\\mathrm{force}}$、$P_{\\mathrm{update}}$、$P_{\\mathrm{fused}}$、$b_{\\mathrm{force}}$、$b_{\\mathrm{update}}$、$b_{\\mathrm{fused}}$和$S$。\n\n让给定案例的输入参数为 $(s, B, P_{\\mathrm{peak}}, M_{\\mathrm{force}}, \\dots, c_{\\mathrm{fused}})$。计算过程如下：\n\n**1. 预备计算：**\n首先，我们定义矩阵运算的常量浮点运算计数：\n- $F_M = 198$\n- $F_A = 18$\n\n接下来，我们计算数据结构的字节大小，这取决于精度参数$s$：\n- $S_U = 18s$\n- $S_P = 8s$\n\n**2. 分离核函数分析：**\n\n**规范力核函数：**\n- 浮点运算的总次数计算如下：\n    $$F_{\\mathrm{force}} = M_{\\mathrm{force}} F_M + A_{\\mathrm{force}} F_A + F_{\\mathrm{proj}}$$\n- 总内存流量（以字节为单位），包括效率低下因子，是：\n    $$M_{\\mathrm{force}}^{\\mathrm{bytes}} = c_{\\mathrm{sep}} \\left(R_{\\mathrm{force},U} S_U + R_{\\mathrm{force},P} S_P + W_{\\mathrm{force}} S_P\\right)$$\n- 算术强度是浮点运算次数与字节数的比率：\n    $$I_{\\mathrm{force}} = \\frac{F_{\\mathrm{force}}}{M_{\\mathrm{force}}^{\\mathrm{bytes}}}$$\n- 可达性能由roofline模型确定：\n    $$P_{\\mathrm{force}} = \\min\\left(P_{\\mathrm{peak}}, B \\cdot I_{\\mathrm{force}}\\right)$$\n- 如果性能受内存上限限制，则核函数是内存受限的：\n    $$b_{\\mathrm{force}} = (B \\cdot I_{\\mathrm{force}}  P_{\\mathrm{peak}})$$\n\n**链更新核函数：**\n- 浮点运算的总次数是：\n    $$F_{\\mathrm{update}} = M_{\\mathrm{update}} F_M + F_{\\mathrm{exp}}$$\n- 总内存流量（以字节为单位）是：\n    $$M_{\\mathrm{update}}^{\\mathrm{bytes}} = c_{\\mathrm{sep}} \\left(R_{\\mathrm{update},U} S_U + R_{\\mathrm{update},P} S_P + W_{\\mathrm{update},U} S_U\\right)$$\n- 算术强度是：\n    $$I_{\\mathrm{update}} = \\frac{F_{\\mathrm{update}}}{M_{\\mathrm{update}}^{\\mathrm{bytes}}}$$\n- 可达性能是：\n    $$P_{\\mathrm{update}} = \\min\\left(P_{\\mathrm{peak}}, B \\cdot I_{\\mathrm{update}}\\right)$$\n- 内存受限状态是：\n    $$b_{\\mathrm{update}} = (B \\cdot I_{\\mathrm{update}}  P_{\\mathrm{peak}})$$\n\n**3. 融合核函数分析：**\n\n- 总浮点运算次数是单个核函数浮点运算次数的总和：\n    $$F_{\\mathrm{fused}} = F_{\\mathrm{force}} + F_{\\mathrm{update}}$$\n- 通过消除动量$P$的中间写入和读取以及被更新的链$U$的冗余读取，内存流量得以减少。提供的公式是：\n    $$M_{\\mathrm{fused}}^{\\mathrm{bytes}} = c_{\\mathrm{fused}} \\left(R_{\\mathrm{force},U} S_U + R_{\\mathrm{force},P} S_P + W_{\\mathrm{update},U} S_U\\right)$$\n- 融合核函数的算术强度是：\n    $$I_{\\mathrm{fused}} = \\frac{F_{\\mathrm{fused}}}{M_{\\mathrm{fused}}^{\\mathrm{bytes}}}$$\n- 可达性能是：\n    $$P_{\\mathrm{fused}} = \\min\\left(P_{\\mathrm{peak}}, B \\cdot I_{\\mathrm{fused}}\\right)$$\n- 内存受限状态是：\n    $$b_{\\mathrm{fused}} = (B \\cdot I_{\\mathrm{fused}}  P_{\\mathrm{peak}})$$\n\n**4. 加速比计算：**\n\n融合带来的性能提升通过加速比因子$S$来量化，即分离核函数的总时间与融合核函数时间的比率。\n\n- 分离核函数执行的时间是单个核函数时间的总和：\n    $$T_{\\mathrm{sep}} = \\frac{F_{\\mathrm{force}}}{P_{\\mathrm{force}}} + \\frac{F_{\\mathrm{update}}}{P_{\\mathrm{update}}}$$\n- 融合核函数执行的时间是：\n    $$T_{\\mathrm{fused}} = \\frac{F_{\\mathrm{fused}}}{P_{\\mathrm{fused}}}$$\n- 加速比是它们的比率：\n    $$S = \\frac{T_{\\mathrm{sep}}}{T_{\\mathrm{fused}}}$$\n$F$（GigaFLOP）和$P_{\\mathrm{att}}$（GFLOP/s）的单位导致时间$T$的单位是秒，但giga-前缀在比率中被抵消，简化了实现。\n\n这个完整的程序将在提供的Python环境中实现，以处理给定的四个测试用例，并以指定格式生成输出。代码将对每个案例精确地遵循这些步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries outside the Python standard library are permitted.\n\ndef solve():\n    \"\"\"\n    Performs a roofline analysis for a simplified HMC integrator step in lattice gauge theory.\n    Computes arithmetic intensity, attainable performance, and kernel fusion speedup\n    for several parameter sets.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains:\n    # (s, B, P_peak, M_force, A_force, F_proj, M_update, F_exp, R_force_U,\n    # R_force_P, W_force, R_update_U, R_update_P, W_update_U, c_sep, c_fused)\n    test_cases = [\n        # Case 1: single precision, typical high-bandwidth GPU\n        (4, 900, 19000, 8, 6, 120, 1, 300, 12, 1, 1, 1, 1, 1, 1.0, 1.0),\n        # Case 2: double precision on the same GPU class\n        (8, 900, 9700, 8, 6, 200, 1, 600, 12, 1, 1, 1, 1, 1, 1.0, 1.0),\n        # Case 3: bandwidth-limited environment, single precision\n        (4, 300, 19000, 8, 6, 120, 1, 300, 12, 1, 1, 1, 1, 1, 1.0, 1.0),\n        # Case 4: imperfect coalescing, single precision\n        (4, 900, 19000, 8, 6, 120, 1, 300, 12, 1, 1, 1, 1, 1, 1.3, 1.05),\n    ]\n\n    # Fundamental constants for FLOP counts\n    F_M = 198  # FLOPs for 3x3 complex matrix-matrix product\n    F_A = 18   # FLOPs for 3x3 complex matrix addition\n\n    all_results = []\n    \n    for case in test_cases:\n        (s, B, P_peak, M_force, A_force, F_proj, M_update, F_exp,\n         R_force_U, R_force_P, W_force, R_update_U, R_update_P, W_update_U,\n         c_sep, c_fused) = case\n\n        # --- 1. Preliminary Calculations ---\n        S_U = 18 * s  # Size of SU(3) matrix in bytes\n        S_P = 8 * s   # Size of su(3) matrix in bytes\n\n        # --- 2. Separate Gauge-Force Kernel Analysis ---\n        F_force = M_force * F_M + A_force * F_A + F_proj\n        M_force_bytes = c_sep * (R_force_U * S_U + R_force_P * S_P + W_force * S_P)\n        I_force = F_force / M_force_bytes\n        P_force_mem_ceil = B * I_force\n        P_force = min(P_peak, P_force_mem_ceil)\n        b_force = P_force_mem_ceil  P_peak\n\n        # --- 3. Separate Link-Update Kernel Analysis ---\n        F_update = M_update * F_M + F_exp\n        M_update_bytes = c_sep * (R_update_U * S_U + R_update_P * S_P + W_update_U * S_U)\n        I_update = F_update / M_update_bytes\n        P_update_mem_ceil = B * I_update\n        P_update = min(P_peak, P_update_mem_ceil)\n        b_update = P_update_mem_ceil  P_peak\n\n        # --- 4. Fused Kernel Analysis ---\n        F_fused = F_force + F_update\n        M_fused_bytes = c_fused * (R_force_U * S_U + R_force_P * S_P + W_update_U * S_U)\n        I_fused = F_fused / M_fused_bytes\n        P_fused_mem_ceil = B * I_fused\n        P_fused = min(P_peak, P_fused_mem_ceil)\n        b_fused = P_fused_mem_ceil  P_peak\n\n        # --- 5. Speedup Calculation ---\n        # Time T = F / P_att. Units are consistent, so giga- prefix cancels.\n        T_sep = (F_force / P_force) + (F_update / P_update)\n        T_fused = F_fused / P_fused\n        S = T_sep / T_fused if T_fused > 0 else float('inf')\n\n        # Store results for this case\n        case_results = [\n            I_force, I_update, I_fused,\n            P_force, P_update, P_fused,\n            b_force, b_update, b_fused,\n            S\n        ]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Produces a string like [[r1,r2,...],[s1,s2,...]] with no spaces.\n    inner_strings = []\n    for r_list in all_results:\n        # Convert each item in the list to its string representation\n        r_str_list = [str(item) for item in r_list]\n        # Join with commas and wrap in brackets\n        inner_strings.append(f\"[{','.join(r_str_list)}]\")\n    \n    # Join all case strings with commas and wrap in brackets\n    final_output_string = f\"[{','.join(inner_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}