{
    "hands_on_practices": [
        {
            "introduction": "这项练习是任何涉及威尔逊圈研究的基础起点。你将直接根据路径有序的规范链积的定义，来编程实现威尔逊圈 $W(R,T)$ 的计算。这项练习将巩固你对如何在格子上构建规范不变观测量，以及如何通过对理论的对称性进行平均来提高统计精度的理解。",
            "id": "3611747",
            "problem": "考虑量子色动力学（QCD）的一种四维欧几里得格点表述，其规范群为三阶特殊酉群（$SU(3)$）。一个规范组态为每个从格点 $x$ 出发、方向为 $\\mu \\in \\{0,1,2,3\\}$ 的有向链分配一个矩阵 $U_{\\mu}(x) \\in SU(3)$，该矩阵表示沿此链的平行输运算符。时间方向为 $\\mu=3$，空间方向为 $\\mu \\in \\{0,1,2\\}$，分别对应于 $x$、$y$ 和 $z$ 坐标轴。与固定空间方向上空间范围为 $R$、时间范围为 $T$ 的矩形相关联的威尔逊圈 $W(R,T)$，由相应时空平面内沿矩形轮廓的链变量的路径排序乘积定义。对色指标求迹后，需除以色数 $N_c=3$ 进行归一化，而物理上相关的可观测量是该归一化迹的实部。所有方向均施加周期性边界条件。\n\n从基本的格点规范理论定义出发，设计并实现一个算法。该算法针对给定的规范组态系综，计算系综平均的威尔逊圈 $W(R,T)$，并通过对以下几项进行平均以实现方差缩减：\n- 圈的空间角点的所有空间平移，\n- 所有的时间原点，\n- 所有的立方旋转，限制为选择沿三个笛卡尔轴（$x$, $y$, $z$）之一的空间边。\n\n你的算法必须显式地实现闭合圈乘积，具体步骤为：沿所选空间方向正向移动 $R$ 个链，沿时间方向正向移动 $T$ 个链，沿所选空间方向反向移动 $R$ 个链（这必须通过在适当平移的格点上乘以厄米共轭矩阵 $U_{\\mu}^{\\dagger}$ 来实现），以及沿时间方向反向移动 $T$ 个链（同样通过 $U_{\\mu}^{\\dagger}$ 实现）。所有格点索引都应在周期性边界条件下执行。最终每个圈的可观测量必须计算为 $\\frac{1}{N_c}\\operatorname{Re}\\operatorname{Tr}(\\mathcal{U}_{\\square})$，其中 $\\mathcal{U}_{\\square}$ 是沿矩形进行有序乘积得到的 $SU(3)$ 矩阵。\n\n你必须使用的基本假设：\n- $U_{\\mu}(x)$ 是 $SU(3)$ 的元素，因此 $U_{\\mu}^{\\dagger}(x)=U_{\\mu}^{-1}(x)$ 且 $\\det U_{\\mu}(x)=1$。\n- 在固定的 $R$ 和 $T$ 下，威尔逊圈可观测量在空间平移、时间平移和空间轴的立方旋转下保持不变；因此，对这些对称性进行平均可以减少统计误差，而不会使估计量产生偏差。\n- 周期性边界条件意味着坐标更新是在每个维度上对格点尺寸取模。\n\n你的程序必须构建三个确定性系综，并对指定的 $(R,T)$ 值评估可观测量。请使用以下测试套件，其中每个系综都由其显式的链分配规则和格点维度定义：\n\n- 测试用例 1（基准单位场）：\n  - 格点维度：$L_x=L_y=L_z=L_t=4$（即 $4\\times 4 \\times 4 \\times 4$）。\n  - 系综：单个组态，其中对于所有的 $x$ 和 $\\mu$，$U_{\\mu}(x)=\\mathbb{I}_{3}$。\n  - 参数：$R=2, T=3$。\n\n- 测试用例 2（单轴结构化时间链）：\n  - 格点维度：$L_x=8$, $L_y=8$, $L_z=8$, $L_t=6$。\n  - 系综：单个组态，其中对于沿 $x$ 轴、空间坐标为 $x$ 的所有格点 $x$，$U_{3}(x)=\\mathrm{diag}\\left(e^{i\\alpha x}, e^{-i\\alpha x}, 1\\right)$，而对于 $\\mu \\in \\{0,1,2\\}$，$U_{\\mu}(x)=\\mathbb{I}_{3}$。此处 $\\alpha=\\frac{2\\pi}{L_x}$，且相位中使用的整数 $x$ 坐标应理解为对 $L_x$ 取模。\n  - 参数：$R=3, T=2$。\n\n- 测试用例 3（对称坐标和时间链）：\n  - 格点维度：$L_x=6, L_y=6, L_z=6, L_t=4$。\n  - 系综：单个组态，其中 $U_{3}(x)=\\mathrm{diag}\\left(e^{i\\alpha s}, e^{-i\\alpha s}, 1\\right)$，这里 $s=(x+y+z)\\bmod L_x$，而对于 $\\mu \\in \\{0,1,2\\}$，$U_{\\mu}(x)=\\mathbb{I}_{3}$。此处 $\\alpha=\\frac{2\\pi}{L_x}$，$x$, $y$, $z$ 是空间坐标。\n  - 参数：$R=1, T=2$。\n\n- 测试用例 4（退化空间范围）：\n  - 格点维度：$L_x=L_y=L_z=L_t=4$（即 $4\\times 4 \\times 4 \\times 4$）。\n  - 系综：单个组态，其中对于所有的 $x$ 和 $\\mu$，$U_{\\mu}(x)=\\mathbb{I}_{3}$。\n  - 参数：$R=0, T=4$。\n\n对于每个测试用例，你的算法必须：\n- 遍历所有空间起始格点 $(x,y,z)$ 和所有时间原点 $t$，\n- 遍历三个空间方向，\n- 按所述方式构造闭合圈乘积，\n- 在每个实例中计算归一化的实部迹，\n- 对所有此类实例以及系综中的所有组态进行平均，以获得单个浮点数 $W(R,T)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[w_1,w_2,w_3,w_4]$），其中 $w_k$ 是为测试用例 $k$ 计算出的 $W(R,T)$，以无单位的十进制形式表示。",
            "solution": "用户提供的问题陈述已根据所需标准进行了仔细审查和验证。这是一个来自计算格点规范理论的、适定的、有科学依据的问题。其定义、参数和目标都以足够的清晰度和严谨性进行了规定，可以得出一个唯一的、可验证的解。因此，我们可以着手进行推导和实现。\n\n### 理论框架\n\n格点量子色动力学（QCD）是一种求解 QCD 的非微扰方法，它通过将时空离散化为一个四维超立方格点来实现。在此表述中，夸克定义在格点上，而作为强力传播子的胶子则由链变量表示。\n\n链变量 $U_{\\mu}(x)$ 是规范群（在此为 $SU(3)$）的一个元素，表示将一个色矢量从格点 $x$ 平行输运到方向 $\\mu$ 上的相邻格点 $x+\\hat{\\mu}$。它通过 $U_{\\mu}(x) \\approx \\exp(iga A_{\\mu}(x))$ 与连续规范场 $A_\\mu$ 相关联，其中 $g$ 是强耦合常数，$a$ 是格点间距。\n\n威尔逊圈 $W(R,T)$ 是一个基本的规范不变可观测量。它由沿空间范围为 $R$、时间范围为 $T$ 的闭合矩形圈 $\\mathcal{C}$ 的链变量的路径排序乘积构成。圈矩阵 $\\mathcal{U}_{\\square}$ 由下式给出：\n$$\n\\mathcal{U}_{\\square} = P \\prod_{l \\in \\mathcal{C}} U_l\n$$\n其中 $P$ 表示路径排序，$U_l$ 是沿圈的链变量。威尔逊圈可观测量是该矩阵归一化迹的实部，并在一个系综 $\\langle \\dots \\rangle$ 的所有规范组态上进行平均：\n$$\nW(R,T) = \\left\\langle \\frac{1}{N_c} \\operatorname{Re} \\operatorname{Tr}(\\mathcal{U}_{\\square}) \\right\\rangle\n$$\n对于大的时间范围 $T$，威尔逊圈期望值与相距空间距离 $R$ 的夸克和反夸克之间的静态势 $V(R)$ 相关：$\\langle W(R,T) \\rangle \\propto e^{-V(R)T}$。\n\n### 算法设计\n\n该算法的核心是为给定的确定性系综计算平均威尔逊圈值 $\\langle W(R,T) \\rangle$。为了减少统计方差（尽管所提供的系综是确定性的，但原理得到了展示），我们将可观测量在所有可能的平移和离散旋转上进行平均，因为这些是基础理论的对称性。\n\n算法流程如下：\n1.  **对称性平均：** 一组嵌套循环遍历威尔逊圈所有可能的起始位置及其空间取向。\n    - 一个外部循环遍历三个空间方向 $\\mu \\in \\{0,1,2\\}$，这定义了圈所在的平面（例如，$x-t$ 平面、$y-t$ 平面或 $z-t$ 平面）。\n    - 内部循环遍历 $L_x \\times L_y \\times L_z \\times L_t$ 格点上所有可能的起始格点 $(x_0, x_1, x_2, x_3)$。\n\n2.  **圈的构造：** 对于每个特定的圈实例（由其起始格点和取向定义），通过沿指定路径乘以链矩阵来构造 $SU(3)$ 矩阵 $\\mathcal{U}_{\\square}$。该路径包括四个部分：\n    1.  在所选空间方向 $s_{\\text{dir}}$ 上正向移动 $R$ 步。\n    2.  在时间方向 $t_{\\text{dir}}=3$ 上正向移动 $T$ 步。\n    3.  在空间方向上反向移动 $R$ 步。从格点 $x$ 到 $x-\\hat{\\mu}$ 的反向一步是通过乘以正向链的厄米共轭 $U_{\\mu}^{\\dagger}(x-\\hat{\\mu})$ 来完成的。\n    4.  在时间方向上反向移动 $T$ 步。\n    \n    路径排序乘积是通过从单位矩阵 $\\mathbb{I}_3$ 开始的顺序左乘来累积的。设 $U_i$ 为路径第 $i$ 步的链矩阵。经过 $N=2R+2T$ 步后的最终圈矩阵为 $\\mathcal{U}_{\\square} = U_N \\dots U_2 U_1$。所有坐标计算都包含通过模运算符实现的周期性边界条件。\n\n3.  **可观测量计算：** 对于每个计算出的 $\\mathcal{U}_{\\square}$，计算可观测量 $\\frac{1}{N_c} \\operatorname{Re}\\operatorname{Tr}(\\mathcal{U}_{\\square})$，其中 $N_c=3$。\n\n4.  **平均：** 将所有圈实例的可观测量值相加，然后除以实例总数，得到最终的平均值。\n\n### 测试用例的解析验证\n\n所提供的测试用例使用确定性系综，这允许通过解析计算来验证算法的正确性。\n\n-   **测试用例 1 ($U_{\\mu}(x)=\\mathbb{I}_3, R=2, T=3$)：** 任意数量的单位矩阵的乘积仍是单位矩阵，因此 $\\mathcal{U}_{\\square} = \\mathbb{I}_3$。迹为 $\\operatorname{Tr}(\\mathbb{I}_3) = 3$。可观测量为 $\\frac{1}{3}\\operatorname{Re}(3) = 1.0$。这对所有圈都成立，所以平均值为 $1.0$。\n\n-   **测试用例 4 ($U_{\\mu}(x)=\\mathbb{I}_3, R=0, T=4$)：** 这是一个空间范围为零的退化圈。路径包括在时间上前进 $T=4$ 步，然后再后退 $T=4$ 步。由于所有链都是 $\\mathbb{I}_3$，圈乘积再次为 $\\mathbb{I}_3$，最终结果是 $1.0$。\n\n-   **测试用例 2 ($L_x=8, R=3, T=2$)：** 空间链是 $\\mathbb{I}_3$。时间链 $U_3$ 取决于 $x$ 坐标 $c_0$。\n    -   如果圈在 $y-t$ 或 $z-t$ 平面（$s_{\\text{dir}}=1$ 或 $2$），则 $x$ 坐标在整个路径中保持不变。正向时间乘积 $(U_3(c_0))^T$ 被反向时间乘积 $(U_3(c_0)^\\dagger)^T$ 完全抵消，得出 $\\mathcal{U}_{\\square} = \\mathbb{I}_3$，可观测量为 $1.0$。\n    -   如果圈在 $x-t$ 平面（$s_{\\text{dir}}=0$），则正向时间路径位于 $c_0'=(c_0+R)\\%L_x$，反向时间路径位于 $c_0$。圈矩阵为 $\\mathcal{U}_{\\square} = \\text{diag}(e^{i\\alpha T (c_0' - c_0)}, e^{-i\\alpha T (c_0' - c_0)}, 1)$，其中 $\\alpha T = (\\frac{2\\pi}{8}) \\cdot 2 = \\frac{\\pi}{2}$。相位参数 $\\alpha T (c_0' - c_0)$ 的值根据 $c_0$ 的不同，为 $\\frac{3\\pi}{2}$ 或 $-\\frac{5\\pi}{2}$。在这两种情况下，余弦值都为 $0$。可观测量为 $\\frac{1}{3}(2\\cos(\\dots)+1) = \\frac{1}{3}$。\n    -   对三种取向进行平均，得到 $\\frac{1.0 + 1.0 + 1/3}{3} = \\frac{7/3}{3} = 7/9$。\n\n-   **测试用例 3 ($L_x=6, R=1, T=2$)：** 空间链是 $\\mathbb{I}_3$。时间链 $U_3$ 取决于 $s=(c_0+c_1+c_2)\\%L_x$。对于任何空间取向，沿该方向移动 $R=1$ 会使 $s$ 改变 $\\Delta s = 1$ 或 $\\Delta s=1-L_x=-5$。圈矩阵中的相位差为 $\\alpha T \\Delta s = (\\frac{2\\pi}{6}) \\cdot 2 \\cdot \\Delta s = \\frac{2\\pi}{3}\\Delta s$。当 $\\Delta s=1$ 时，相位为 $2\\pi/3$。当 $\\Delta s=-5$ 时，相位为 $-10\\pi/3 \\equiv 2\\pi/3 \\pmod{2\\pi}$。余弦值为 $\\cos(2\\pi/3)=-1/2$。可观测量总是 $\\frac{1}{3}(2(-\\frac{1}{2})+1) = 0.0$。因此，平均值为 $0.0$。\n\n实现将直接反映这一逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    It iterates through the test cases, computes the averaged Wilson loop for each,\n    and prints the results in the required format.\n    \"\"\"\n\n    def get_link_matrix(case_id, params, coords, mu):\n        \"\"\"\n        Generates the SU(3) link matrix U_mu(x) on-the-fly.\n        \n        Args:\n            case_id (int): The test case number (1-4).\n            params (dict): A dictionary containing case-specific parameters.\n            coords (tuple): A 4-tuple of integer coordinates (x, y, z, t).\n            mu (int): The direction index (0 for x, 1 for y, 2 for z, 3 for t).\n\n        Returns:\n            numpy.ndarray: The 3x3 SU(3) link matrix.\n        \"\"\"\n        if case_id in [1, 4]:\n            return np.identity(3, dtype=np.complex128)\n        \n        # For cases 2 and 3, spatial links are identity matrices.\n        if mu in [0, 1, 2]:\n            return np.identity(3, dtype=np.complex128)\n\n        # Temporal links (mu=3) for cases 2 and 3.\n        if case_id == 2:\n            x_coord = coords[0]\n            alpha = params['alpha']\n            phase = alpha * x_coord\n            return np.diag([np.exp(1j * phase), np.exp(-1j * phase), 1.0 + 0.0j])\n        \n        elif case_id == 3:\n            x, y, z = coords[0], coords[1], coords[2]\n            L_x = params['L'][0]\n            s = (x + y + z) % L_x\n            alpha = params['alpha']\n            phase = alpha * s\n            return np.diag([np.exp(1j * phase), np.exp(-1j * phase), 1.0 + 0.0j])\n        \n        # Fallback, should not be reached with valid inputs.\n        return np.identity(3, dtype=np.complex128)\n\n    def compute_average_wilson_loop(case_id, L, R, T):\n        \"\"\"\n        Computes the ensemble-averaged Wilson loop for a given deterministic ensemble.\n        \n        The averaging is performed over all spatial and temporal translations of the loop,\n        and over the three possible spatial orientations of the loop plane.\n        \n        Args:\n            case_id (int): The test case number.\n            L (tuple): Lattice dimensions (Lx, Ly, Lz, Lt).\n            R (int): Spatial extent of the Wilson loop.\n            T (int): Temporal extent of the Wilson loop.\n\n        Returns:\n            float: The computed average Wilson loop value W(R, T).\n        \"\"\"\n        params = {'L': L}\n        if case_id in [2, 3]:\n            params['alpha'] = 2 * np.pi / L[0]\n            \n        Nc = 3.0\n        total_observable_sum = 0.0\n        total_loop_count = 0\n\n        L_x, L_y, L_z, L_t = L\n        \n        # 1. Average over cubic rotations (orienting the spatial side of the loop)\n        for s_dir in range(3):\n            # 2. Average over all temporal origins\n            for t_start in range(L_t):\n                # 3. Average over all spatial origins\n                for z_start in range(L_z):\n                    for y_start in range(L_y):\n                        for x_start in range(L_x):\n                            start_coords = [x_start, y_start, z_start, t_start]\n                            current_coords = list(start_coords)\n                            \n                            loop_product = np.identity(3, dtype=np.complex128)\n\n                            # Path 1: Forward in spatial direction `s_dir` for R steps\n                            for _ in range(R):\n                                link = get_link_matrix(case_id, params, tuple(current_coords), s_dir)\n                                loop_product = link @ loop_product\n                                current_coords[s_dir] = (current_coords[s_dir] + 1) % L[s_dir]\n\n                            # Path 2: Forward in temporal direction `t_dir=3` for T steps\n                            t_dir = 3\n                            for _ in range(T):\n                                link = get_link_matrix(case_id, params, tuple(current_coords), t_dir)\n                                loop_product = link @ loop_product\n                                current_coords[t_dir] = (current_coords[t_dir] + 1) % L[t_dir]\n\n                            # Path 3: Backward in spatial direction `s_dir` for R steps\n                            for _ in range(R):\n                                current_coords[s_dir] = (current_coords[s_dir] - 1 + L[s_dir]) % L[s_dir]\n                                link = get_link_matrix(case_id, params, tuple(current_coords), s_dir)\n                                link_dagger = link.conj().T\n                                loop_product = link_dagger @ loop_product\n\n                            # Path 4: Backward in temporal direction `t_dir=3` for T steps\n                            for _ in range(T):\n                                current_coords[t_dir] = (current_coords[t_dir] - 1 + L[t_dir]) % L[t_dir]\n                                link = get_link_matrix(case_id, params, tuple(current_coords), t_dir)\n                                link_dagger = link.conj().T\n                                loop_product = link_dagger @ loop_product\n\n                            observable = (1.0 / Nc) * np.trace(loop_product).real\n                            total_observable_sum += observable\n                            total_loop_count += 1\n        \n        if total_loop_count == 0:\n            # This case occurs if the lattice volume is zero, not expected here.\n            return 0.0\n        \n        return total_observable_sum / total_loop_count\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'case_id': 1, 'L': (4, 4, 4, 4), 'R': 2, 'T': 3},\n        {'case_id': 2, 'L': (8, 8, 8, 6), 'R': 3, 'T': 2},\n        {'case_id': 3, 'L': (6, 6, 6, 4), 'R': 1, 'T': 2},\n        {'case_id': 4, 'L': (4, 4, 4, 4), 'R': 0, 'T': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_average_wilson_loop(case['case_id'], case['L'], case['R'], case['T'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从充满噪声的格点数据中提取纯净的基态信号是一项关键挑战。这项练习介绍了变分法，它通过求解一个广义本征值问题 (GEVP) 来系统性地压制来自激发态的污染。通过利用一组不同算符基矢构建关联矩阵，你将学习如何高精度地分离出静态夸克势 $V_0(R)$。",
            "id": "3611706",
            "problem": "你的任务是设计并实现一个完整的程序，该程序为威尔逊圈 $W(R,T)$ 中一组不同涂抹程度的空间线算符构建并求解一个变分问题，以分离出以格点单位表示的静态夸克势 $V_0(R)$。该问题必须从第一性原理出发进行构建，并通过广义本征值方法求解。该方法源于在欧几里得时间演化的转移矩阵诠释下，对一个合适的瑞利商进行最小化。其潜在的物理背景是格点量子色动力学（LQCD），但该问题完全以普遍可实现的数学术语进行规定。\n\n从以下基本基础开始：\n- 威尔逊圈 $W(R,T)$ 探测了一对静态夸克-反夸克对在空间距离为 $R$、欧几里得时间跨度为 $T$ 上的相互作用。\n- 转移矩阵形式主义意味着欧几里得相关函数允许按能量本征态进行谱分解。\n- 对于由分离距离为 $R$ 的威尔逊圈的不同涂抹程度的空间线所构建的一组包含 $N$ 个独立算符 $\\{\\mathcal{O}_i\\}$ 的基，其在欧几里得时间 $T$ 的相关矩阵是一个实对称正定矩阵，其矩阵元编码了这些算符与能量本征态的交叠以及它们的欧几里得时间传播。\n\n使用这些原理，按以下步骤进行：\n1. 为选定的算符基构建一个模型相关矩阵 $C_{ij}(T)$，该矩阵通过具有有限数量能量本征态和固定交叠的谱表示法来表达。具体来说，假设在分离距离 $R$ 处存在 $M$ 个能量本征态，其能量在格点单位下（无量纲）为 $E_n(R)$，并且算符 $\\mathcal{O}_i$ 到态 $n$ 上的交叠为 $Z_i^{(n)}$。相关矩阵元通过对能量本征态求和定义，并带有欧几里得时间依赖性。你的程序必须对每个欧几里得时间 $T$，根据给定的 $E_n$ 和 $Z_i^{(n)}$ 构建矩阵 $C(T)$。\n2. 从欧几里得时间演化下的变分原理出发，推导为在固定 $R$ 处最优地分离出基态所需的广义本征值问题。你必须建立并求解在两个欧几里得时间 $T$ 和 $T_0$ 处、使用相同算符基的相关矩阵之间的广义本征值问题，并确定主广义本征值 $\\lambda_0(T,T_0)$。\n3. 使用主广义本征值，通过连续时间的比值来估计以格点单位表示的静态夸克势 $V_0(R)$。具体来说，当格点间距设为 $a = 1$（无量纲格点单位）时，定义估计量\n$$\nV_0^{\\text{eff}}(R;T_{\\text{eval}},T_0) \\equiv -\\ln\\left(\\frac{\\lambda_0(T_{\\text{eval}},T_0)}{\\lambda_0(T_{\\text{eval}}-1,T_0)}\\right).\n$$\n你的程序必须为每个提供的测试用例计算此估计量。\n\n所有量都采用无量纲格点单位。能量必须以浮点数形式报告。不涉及角度。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表。每个条目必须是 $V_0^{\\text{eff}}(R;T_{\\text{eval}},T_0)$ 的值，四舍五入到六位小数，并按照下面测试用例的顺序排列。\n\n测试套件和参数说明：\n对于每个测试用例，都提供了算符基维度 $N$、态的数量 $M$、能量 $\\{E_n\\}$ 和形状为 $N \\times M$ 的交叠矩阵 $Z$，以及 $T_0$ 和 $T_{\\text{eval}}$（均以格点单位表示）。按照步骤1的说明为非负整数 $T$ 构建 $C(T)$，然后执行步骤2和3。\n\n- 测试用例1（理想情况）：\n  - $R = 3$\n  - $N = 3$, $M = 3$\n  - 能量： $\\{E_n\\} = \\{0.5, 0.8, 1.4\\}$\n  - 交叠：\n    $$\n    Z = \\begin{pmatrix}\n    1.0  0.3  0.1 \\\\\n    0.9  0.5  0.2 \\\\\n    0.7  0.2  0.4\n    \\end{pmatrix}\n    $$\n  - $T_0 = 1$, $T_{\\text{eval}} = 5$\n\n- 测试用例2（低能谱中的近简并）：\n  - $R = 5$\n  - $N = 3$, $M = 3$\n  - 能量： $\\{E_n\\} = \\{0.7, 0.71, 1.3\\}$\n  - 交叠：\n    $$\n    Z = \\begin{pmatrix}\n    1.0  0.2  0.1 \\\\\n    0.8  0.5  0.3 \\\\\n    0.6  0.4  0.2\n    \\end{pmatrix}\n    $$\n  - $T_0 = 2$, $T_{\\text{eval}} = 6$\n\n- 测试用例3（算符基小于态的数量）：\n  - $R = 2$\n  - $N = 2$, $M = 3$\n  - 能量： $\\{E_n\\} = \\{0.4, 0.9, 1.5\\}$\n  - 交叠：\n    $$\n    Z = \\begin{pmatrix}\n    1.0  0.4  0.2 \\\\\n    0.7  0.3  0.1\n    \\end{pmatrix}\n    $$\n  - $T_0 = 0$, $T_{\\text{eval}} = 7$\n\n程序要求：\n- 为整数 $T \\ge 0$，根据提供的 $\\{E_n\\}$ 和 $Z$ 实现 $C(T)$ 的构建。\n- 推导并求解 $C(T)$ 和 $C(T_0)$ 之间的相应广义本征值问题，以获得 $\\lambda_0(T,T_0)$。\n- 使用上面定义的比值计算 $V_0^{\\text{eff}}(R;T_{\\text{eval}},T_0)$。\n- 输出单行，其中包含三个测试用例的结果，格式为方括号内的逗号分隔浮点数列表，每个浮点数四舍五入到六位小数，例如 $[0.123456,0.234567,0.345678]$。\n\n不允许外部输入；必须完全按照规定硬编码测试套件参数。代码必须是完全自包含的，并能用现代编程语言运行。最终提取的能量必须以无量纲浮点数形式表示，使用格点单位，并四舍五入到六位小数。",
            "solution": "该问题要求实现一种变分方法，以提取静态夸克势，该势对应于静态夸克-反夸克系统的基态能量 $V_0(R) = E_0(R)$。该方法基于欧几里得时间中相关矩阵的谱特性，这是格点场论计算的基石。\n\n解决方案分为三个主要步骤：\n1.  构建相关矩阵 $C(T)$。\n2.  广义本征值问题（GEVP）的构建与求解。\n3.  从主本征值计算有效势 $V_0^{\\text{eff}}$。\n\n我们首先建立理论基础。\n\n**1. 相关矩阵**\n\n在欧几里得时空中构建的量子场论中，算符 $\\mathcal{O}$ 的两点相关函数可以通过谱分解来表示。通过插入哈密顿量 $\\hat{H}$ 的一组完备能量本征态 $|n\\rangle$（满足 $\\hat{H}|n\\rangle = E_n |n\\rangle$），相关函数变为：\n$$\n\\langle \\mathcal{O}(T) \\mathcal{O}(0) \\rangle = \\langle \\text{vac} | \\mathcal{O} e^{-\\hat{H}T} \\mathcal{O} | \\text{vac} \\rangle = \\sum_n \\langle \\text{vac} | \\mathcal{O} e^{-\\hat{H}T} | n \\rangle \\langle n | \\mathcal{O} | \\text{vac} \\rangle = \\sum_n |\\langle n | \\mathcal{O} | \\text{vac} \\rangle|^2 e^{-E_n T}\n$$\n其中 $T$ 是欧几里得时间间隔，能量 $E_n$ 是相对于真空能测量的，真空能设为零。\n\n该问题指定了一个由 $N$ 个算符组成的基 $\\{\\mathcal{O}_i\\}_{i=1...N}$，这些算符由威尔逊圈的涂抹空间线构建。互相关矩阵元 $C_{ij}(T)$ 由下式给出：\n$$\nC_{ij}(T) = \\langle \\mathcal{O}_i(T) \\mathcal{O}_j(0) \\rangle = \\sum_{n=0}^{M-1} \\langle \\text{vac} | \\mathcal{O}_i | n \\rangle \\langle n | \\mathcal{O}_j | \\text{vac} \\rangle e^{-E_n(R) T}\n$$\n其中 $M$ 是中间态的数量。问题提供了实数交叠系数 $Z_i^{(n)} = \\langle n | \\mathcal{O}_i | \\text{vac} \\rangle$。因此，相关矩阵为：\n$$\nC_{ij}(T) = \\sum_{n=0}^{M-1} Z_i^{(n)} Z_j^{(n)} e^{-E_n(R) T}\n$$\n在矩阵表示法中，$Z$ 是一个 $N \\times M$ 的交叠矩阵，其元素为 $Z_{in} = Z_i^{(n)}$，$D(T)$ 是一个 $M \\times M$ 的对角矩阵，其元素为 $D_{nn}(T) = e^{-E_n T}$。那么 $N \\times N$ 的相关矩阵为：\n$$\nC(T) = Z D(T) Z^T\n$$\n该矩阵是实对称的。对于 $T \\ge 0$，由于 $e^{-E_n T}  0$，它也是半正定的。如果 $Z$ 的列是线性无关的且 $N \\le M$，则 $C(T)$ 是正定的。\n\n**2. 广义本征值问题（GEVP）**\n\n变分法旨在寻找基算符的一个最优线性组合 $\\Phi = \\sum_i v_i \\mathcal{O}_i$，使其与特定的能量本征态（主要是基态 $|0\\rangle$）有最佳的交叠。系数向量为 $\\mathbf{v} = (v_1, v_2, \\dots, v_N)^T$。\n\n对于这个优化后的算符，其相关函数的期望值为 $\\langle \\Phi(T) \\Phi(0) \\rangle = \\mathbf{v}^T C(T) \\mathbf{v}$。为了分离出基态能量，我们考虑在两个不同时间 $T$ 和一个参考时间 $T_0  T$ 处的相关函数之比：\n$$\n\\lambda(\\mathbf{v}) = \\frac{\\langle \\Phi(T) \\Phi(0) \\rangle}{\\langle \\Phi(T_0) \\Phi(0) \\rangle} = \\frac{\\mathbf{v}^T C(T) \\mathbf{v}}{\\mathbf{v}^T C(T_0) \\mathbf{v}}\n$$\n这是一个瑞利商。对于大的时间间隔，基态项在谱求和中占主导地位，此比值趋近于 $e^{-E_0 (T-T_0)}$。\n\n为了找到能分离出单个能的最优向量 $\\mathbf{v}$，我们通过将 $\\lambda(\\mathbf{v})$ 相对于 $\\mathbf{v}$ 的梯度设为零来寻找其驻点。此过程导出了广义本征值问题：\n$$\nC(T) \\mathbf{v}_n = \\lambda_n(T, T_0) C(T_0) \\mathbf{v}_n\n$$\n这 $N$ 个实数本征值 $\\lambda_n(T, T_0)$ 近似了与算符基有非零交叠的 $N$ 个最低能态的指数衰减：\n$$\n\\lambda_n(T, T_0) \\approx e^{-E_n (T-T_0)}\n$$\n主本征值 $\\lambda_0(T, T_0)$ 是最大的本征值，对应于基态能量 $E_0$。\n\n**3. 有效势估计量**\n\n从主本征值，我们可以构建基态能量 $E_0(R)$（即静态势 $V_0(R)$）的估计量。可以提取出一个有效能量，在此即有效势。问题指定了一个由连续时间步长的主本征值之比构建的特定估计量：\n$$\nV_0^{\\text{eff}}(R; T_{\\text{eval}}, T_0) \\equiv -\\ln\\left(\\frac{\\lambda_0(T_{\\text{eval}}, T_0)}{\\lambda_0(T_{\\text{eval}}-1, T_0)}\\right)\n$$\n代入本征值的长时间行为，我们就能明白其原理：\n$$\n\\frac{\\lambda_0(T_{\\text{eval}}, T_0)}{\\lambda_0(T_{\\text{eval}}-1, T_0)} \\approx \\frac{e^{-E_0 (T_{\\text{eval}}-T_0)}}{e^{-E_0 (T_{\\text{eval}}-1-T_0)}} = e^{-E_0 (T_{\\text{eval}}-T_0 - (T_{\\text{eval}}-1-T_0))} = e^{-E_0}\n$$\n因此，$V_0^{\\text{eff}} \\approx - \\ln(e^{-E_0}) = E_0$。这种基于比值的估计量旨在消除来自高能态污染的领头阶系统误差，从而提供一个更稳定的基态能量估计。\n\n计算流程如下：\n对于每个具有参数 $N$, $M$, $\\{E_n\\}$, $Z$, $T_0$, 和 $T_{\\text{eval}}$ 的测试用例：\n1.  构建三个 $N \\times N$ 相关矩阵：$C(T_{\\text{eval}})$、$C(T_{\\text{eval}}-1)$ 和 $C(T_0)$。格点间距为 $a=1$。\n2.  求解两个独立的广义本征值问题（GEVP）：\n    a. $C(T_{\\text{eval}}) \\mathbf{v} = \\lambda C(T_0) \\mathbf{v}$\n    b. $C(T_{\\text{eval}}-1) \\mathbf{v} = \\lambda' C(T_0) \\mathbf{v}$\n3.  从每个解中，提取主（最大）本征值，我们分别记为 $\\lambda_0(T_{\\text{eval}}, T_0)$ 和 $\\lambda_0(T_{\\text{eval}}-1, T_0)$。由于用于对称GEVP的标准数值求解器返回的本征值是按升序排列的，主本征值将是返回数组中的最后一个元素。\n4.  使用提供的公式计算有效势。\n5.  将最终结果四舍五入到六位小数。\n\n此流程构成了对所述问题的完整而严谨的解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solving process for all test cases.\n    It hard-codes the test cases, iterates through them, computes the\n    static potential for each, and prints the formatted results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"R\": 3,\n            \"N\": 3, \"M\": 3,\n            \"energies\": np.array([0.5, 0.8, 1.4]),\n            \"overlaps\": np.array([\n                [1.0, 0.3, 0.1],\n                [0.9, 0.5, 0.2],\n                [0.7, 0.2, 0.4]\n            ]),\n            \"T0\": 1,\n            \"T_eval\": 5\n        },\n        {\n            \"R\": 5,\n            \"N\": 3, \"M\": 3,\n            \"energies\": np.array([0.7, 0.71, 1.3]),\n            \"overlaps\": np.array([\n                [1.0, 0.2, 0.1],\n                [0.8, 0.5, 0.3],\n                [0.6, 0.4, 0.2]\n            ]),\n            \"T0\": 2,\n            \"T_eval\": 6\n        },\n        {\n            \"R\": 2,\n            \"N\": 2, \"M\": 3,\n            \"energies\": np.array([0.4, 0.9, 1.5]),\n            \"overlaps\": np.array([\n                [1.0, 0.4, 0.2],\n                [0.7, 0.3, 0.1]\n            ]),\n            \"T0\": 0,\n            \"T_eval\": 7\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_static_potential(case)\n        results.append(result)\n\n    # Format and print the final results as specified.\n    # The rounding to 6 decimal places is done by the formatting string.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef build_correlation_matrix(T, energies, overlaps):\n    \"\"\"\n    Constructs the correlation matrix C(T) for a given Euclidean time T.\n    \n    The formula is C(T) = Z * D(T) * Z^T, where Z is the NxM overlap matrix\n    and D(T) is an MxM diagonal matrix with elements D_nn = exp(-E_n * T).\n\n    Args:\n        T (int): The Euclidean time separation.\n        energies (np.ndarray): A 1D array of M energy eigenvalues.\n        overlaps (np.ndarray): An NxM matrix of overlap coefficients Z.\n\n    Returns:\n        np.ndarray: The NxN correlation matrix C(T).\n    \"\"\"\n    # Create the diagonal matrix D(T)\n    diag_elements = np.exp(-energies * T)\n    D_T = np.diag(diag_elements)\n    \n    # Calculate C(T) = Z @ D(T) @ Z.T\n    C_T = overlaps @ D_T @ overlaps.T\n    return C_T\n\ndef get_principal_eigenvalue(C_T, C_T0):\n    \"\"\"\n    Solves the generalized eigenvalue problem C(T)v = lambda * C(T0)v and\n    returns the principal (largest) eigenvalue.\n\n    Args:\n        C_T (np.ndarray): The correlation matrix at time T.\n        C_T0 (np.ndarray): The correlation matrix at reference time T0.\n\n    Returns:\n        float: The principal generalized eigenvalue.\n    \"\"\"\n    # The matrices are real and symmetric, C_T0 is positive definite.\n    # scipy.linalg.eigh solves the GEVP for Hermitian matrices,\n    # returning eigenvalues sorted in ascending order.\n    eigenvalues = linalg.eigh(C_T, C_T0, eigvals_only=True)\n    \n    # The principal eigenvalue corresponds to the ground state and is the largest.\n    principal_eigenvalue = eigenvalues[-1]\n    return principal_eigenvalue\n\ndef calculate_static_potential(params):\n    \"\"\"\n    Calculates the effective static potential V_0^eff for a single test case.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the case.\n\n    Returns:\n        float: The calculated effective static potential.\n    \"\"\"\n    energies = params[\"energies\"]\n    overlaps = params[\"overlaps\"]\n    T0 = params[\"T0\"]\n    T_eval = params[\"T_eval\"]\n    \n    # 1. Construct the required correlation matrices\n    C_T_eval = build_correlation_matrix(T_eval, energies, overlaps)\n    C_T_eval_minus_1 = build_correlation_matrix(T_eval - 1, energies, overlaps)\n    C_T0 = build_correlation_matrix(T0, energies, overlaps)\n    \n    # 2. Solve the two GEVPs to find the principal eigenvalues\n    lambda_0_eval = get_principal_eigenvalue(C_T_eval, C_T0)\n    lambda_0_eval_minus_1 = get_principal_eigenvalue(C_T_eval_minus_1, C_T0)\n    \n    # 3. Compute the effective static potential estimator\n    # The formula is V_eff = -ln(lambda_0(T_eval) / lambda_0(T_eval - 1))\n    ratio = lambda_0_eval / lambda_0_eval_minus_1\n    V_eff = -np.log(ratio)\n    \n    return V_eff\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "格点计算产生的是无量纲的量，要将它们与物理现实联系起来，就必须设定一个物理标度。这项练习将指导你完成从静态夸克势 $V(R)$ 中确定 Sommer 标度 $r_0$ 的过程，这是 QCD 中的一个标准参考标度。你将应用稳健的数值技术，包括插值和求根，将你的格点计算结果转化为具有物理意义的陈述。",
            "id": "3611702",
            "problem": "考虑在格点量子色动力学 (QCD) 中，从矩形威尔逊圈中提取静态夸克势，其中格点单位下的静态夸克势是从大时间尺度的矩形圈中获得的。在此设定下，静态夸克势是空间间隔的函数，记为 $V(R)$，其中 $R$ 以格点间距为单位进行测量。Sommer 标度 $r_0$ 由条件 $r_0^2 F(r_0) = c$ 隐式定义，其中 $F(r) = \\frac{dV}{dr}$ 是夸克间力，且 $c = 1.65$。任务是根据在整数 $R$ 值处的 $V(R)$ 离散测量值，直接在格点单位下计算 $r_0/a$，其中 $a$ 是格点间距。\n\n仅从以下核心定义出发\n- 威尔逊圈与大时间尺度极限下静态夸克势之间的关系，\n- 力作为空间导数 $F(r) = \\frac{dV}{dr}$ 的定义，\n- 以及隐式 Sommer 标度条件 $r_0^2 F(r_0) = c$（$c = 1.65$），\n设计并实现一个稳定的数值程序，以从离散数据 $\\{(R_i, V_i)\\}$ 中估计 $r_0/a$。\n\n您的实现必须：\n1. 将 $R$ 和 $V(R)$ 视为无量纲的格点量，并计算 $r_0/a$ 作为一个无量纲数。\n2. 对离散的 $V(R)$ 数据建立一个保形插值，该插值应足够光滑以允许稳定的数值微分。使用一种能够避免伪振荡并在 $V(R)$ 存在单调性时保持其单调性的插值方法。然后，对插值函数进行微分，以获得在最小和最大观测间隔之间的开区间上对 $F(r)$ 的连续近似。\n3. 在定义域 $(R_{\\min}, R_{\\max})$ 内求解关于 $r$ 的非线性方程 $r^2 F(r) - c = 0$，其中 $R_{\\min}$ 和 $R_{\\max}$ 是最小和最大的采样间隔。使用区间包围策略以确保一个鲁棒的求根过程。如果由于轻微的数据不规则性而无法在插值域内定位符号变化，则使用基于物理动机的势能光滑拟合来正则化导数，并在拟合模型上重复求根过程。\n4. 返回结果，四舍五入到六位小数。\n\n测试套件：\n对于以下五个测试用例中的每一个，输入都包含一个间隔列表 $R$ 和一个相应的势能列表 $V(R)$，所有数值均以格点单位给出。对于每个用例，计算一个满足 $r_0^2 F(r_0) = 1.65$ 的浮点数 $r_0/a$。下面提供的所有数字都以格点单位给出，应被视为程序的精确输入。\n\n- 用例 A：\n  - $R = [1, 2, 3, 4, 5, 6, 7, 8]$\n  - $V = [0.38, 0.71, 0.94, 1.145, 1.34, 1.53, 1.7171428571, 1.9025]$\n- 用例 B：\n  - $R = [1, 2, 3, 4, 5, 6, 7, 8]$\n  - $V = [0.3785, 0.713, 0.9355, 1.151, 1.3325, 1.539, 1.7066428571, 1.9145]$\n- 用例 C：\n  - $R = [2, 3, 4, 5, 6]$\n  - $V = [0.715, 0.9766666667, 1.2175, 1.45, 1.6783333333]$\n- 用例 D：\n  - $R = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]$\n  - $V = [0.51, 0.72, 0.8966666667, 1.065, 1.23, 1.3933333333, 1.5557142857, 1.7175, 1.8788888889, 2.04]$\n- 用例 E：\n  - $R = [1, 2, 3, 4, 5, 6, 7]$\n  - $V = [0.54, 0.87, 1.1133333333, 1.345, 1.548, 1.7566666667, 1.9628571429]$\n\n对数值方法和输出的要求：\n- 使用适用于单调数据的保形方案对 $V(R)$ 进行插值，然后进行微分以近似 $r \\in (R_{\\min}, R_{\\max})$ 上的 $F(r)$。\n- 对 $g(r) = r^2 F(r) - 1.65$ 使用区间包围求根器。\n- 如果由于轻微的不规则性而找不到根所在的区间，则通过对 $V(R)$ 进行与短程吸引和长程线性增长一致的光滑三参数拟合来进行正则化，然后再次求解 $r$。\n- 输出单行，包含一个用逗号分隔的列表，用方括号括起且不含空格，该列表按 A, B, C, D, E 的顺序汇总了五个案例的 $r_0/a$ 值。每个值必须四舍五入到六位小数。例如，格式必须是 \"[x_A,x_B,x_C,x_D,x_E]\"，其中每个 $x$ 是一个四舍五入到六位小数的浮点数。",
            "solution": "该问题要求从格点量子色动力学 (QCD) 中静态夸克势 $V(R)$ 的离散数据计算 Sommer 标度，记为 $r_0$。这些量均以格点单位给出，因此空间间隔 $R$ 是格点间距 $a$ 的整数倍，而势 $V(R)$ 是无量纲的。目标是计算无量纲比率 $r_0/a$。\n\n### 步骤 1：问题形式化\nSommer 标度 $r_0$ 由以下方程隐式定义：\n$$\nr_0^2 F(r_0) = c\n$$\n其中 $F(r) = \\frac{dV}{dr}$ 是静态夸克之间的力，$c$ 是一个设定为 $1.65$ 的常数。由于所有量都以格点单位提供，我们求解的是 $r = r_0/a$。因此，问题简化为寻找非线性函数 $g(r)$ 的根：\n$$\ng(r) = r^2 F(r) - c = 0\n$$\n输入是一组离散数据点 $\\{(R_i, V_i)\\}$，其中 $R_i$ 是间隔，$V_i = V(R_i)$ 是相应的势值。为了解该方程，我们首先需要从离散的势数据 $V_i$ 中得到力的连续表示 $F(r)$。这必须在观测到的间隔的开区间 $(R_{\\min}, R_{\\max})$ 内完成。\n\n### 步骤 2：数值策略\n按照问题的规定，设计了一种双管齐下的数值策略以确保解的鲁棒性。首先尝试基于插值的主要方法。如果该方法因数据不规则性而失败，则采用基于物理模型拟合的后备方法。\n\n#### 主要方法：插值与求根\n该方法包括两个阶段：\n1.  **插值与微分**：对离散的势数据 $(R_i, V_i)$ 进行插值以获得连续函数 $V_{\\text{interp}}(r)$。问题指定了保形插值方案以避免伪振荡并尊重数据的单调性。分段三次 Hermite 插值多项式 (PCHIP) 是实现此目的的绝佳选择。它能确保在数据单调的任何区间上，插值函数也是单调的。`scipy.interpolate.PchipInterpolator` 提供了这样的功能。一旦构建了插值函数 $V_{\\text{interp}}(r)$，其导数 $F_{\\text{interp}}(r) = \\frac{dV_{\\text{interp}}}{dr}$ 就可以通过解析或数值方法计算。`PchipInterpolator` 对象方便地提供了一个方法来获得其导数的可调用函数，该导数是一个连续的分段二次多项式。\n\n2.  **求根**：利用连续的力函数 $F_{\\text{interp}}(r)$，我们可以定义 $g(r) = r^2 F_{\\text{interp}}(r) - c$。问题要求使用区间包围的求根算法。我们将使用 Brent-Dekker 方法，其实现为 `scipy.optimize.brentq`。该方法需要一个区间 $[r_a, r_b]$，使得 $g(r_a)$ 和 $g(r_b)$ 符号相反。通过遍历输入数据点定义的区间 $[R_i, R_{i+1}]$ 并检查符号变化（即 $g(R_i) \\cdot g(R_{i+1})  0$），来搜索这样的区间。如果找到一个区间，则使用 `brentq` 以高精度找到根 $r = r_0/a$。\n\n#### 后备方法：通过函数拟合进行正则化\n如果主要方法未能在任何区间 $[R_i, R_{i+1}]$ 上定位到符号变化的区间，这表明数据中的轻微不规则性或噪声产生的数值导数 $F_{\\text{interp}}(r)$，使得函数 $g(r)$ 不会以在格点 $R_i$ 处采样可检测到的方式穿过零点。在这种情况下，我们采取正则化程序。\n\n1.  **物理模型拟合**：静态夸克势可以很好地用 Cornell 势模型来描述，该模型包含了预期的短程吸引（类库仑）和长程线性禁闭的特征。其函数形式为：\n    $$\n    V_{\\text{fit}}(r) = -\\frac{\\alpha}{r} + \\sigma r + V_0\n    $$\n    参数 $(\\alpha, \\sigma, V_0)$ 通过对离散数据 $(R_i, V_i)$ 进行该模型的非线性最小二乘拟合来确定。这可通过使用 `scipy.optimize.curve_fit` 实现。这种拟合提供了一个光滑的、基于物理动机的势的表示，它对数据中的局部微小波动不那么敏感。\n\n2.  **解析解**：对于 Cornell 势，力由其导数给出：\n    $$\n    F_{\\text{fit}}(r) = \\frac{dV_{\\text{fit}}}{dr} = \\frac{\\alpha}{r^2} + \\sigma\n    $$\n    将此代入 Sommer 标度方程得到：\n    $$\n    r^2 \\left( \\frac{\\alpha}{r^2} + \\sigma \\right) - c = 0\n    $$\n    这简化为 $\\alpha + \\sigma r^2 - c = 0$，可以解析地求解出 $r = r_0/a$：\n    $$\n    r = \\sqrt{\\frac{c - \\alpha}{\\sigma}}\n    $$\n    这为 Sommer 标度提供了一个稳定的、正则化的估计，前提是拟合的参数是物理的（即 $\\sigma  0$ 且 $c  \\alpha$）。\n\n### 步骤 3：算法实现\n整个算法在一个 Python 函数中实现。对于每个测试用例：\n1.  一个 `try` 块尝试主要方法。它初始化 PCHIP 插值器及其导数。然后遍历数据区间 $[R_i, R_{i+1}]$，尝试使用 `brentq` 求解根。如果找到根，函数返回该值，四舍五入到六位小数。\n2.  如果所有 `brentq` 调用都失败，则会引发一个 `ValueError`，从而触发 `except` 块。\n3.  `except` 块实现后备方法。它使用 `curve_fit` 将 Cornell 势拟合到数据，提取参数 $\\alpha$ 和 $\\sigma$，并使用解析公式计算 $r_0/a$。然后返回结果，四舍五入到六位小数。\n这种结构化的方法能够鲁棒地处理干净数据（插值方法更优）和带有轻微不规则性的数据（拟合方法提供了必要的正则化）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\nfrom scipy.optimize import brentq, curve_fit\n\ndef solve():\n    \"\"\"\n    Main function to solve for the Sommer scale for all test cases.\n    \"\"\"\n    # The constant c in the Sommer scale definition r_0^2 F(r_0) = c.\n    C_SOMMER = 1.65\n\n    def solve_case(R, V):\n        \"\"\"\n        Computes the Sommer scale r_0/a for a single set of potential data.\n\n        This function implements a two-stage process:\n        1. Primary Method: Uses PCHIP interpolation to get a continuous Force F(r)\n           and finds the root of r^2*F(r) - c = 0 using a bracketing solver.\n        2. Fallback Method: If the primary method fails (due to data irregularities\n           preventing a bracket from being found), it fits the data to a Cornell\n           potential V(r) = -alpha/r + sigma*r + V0 and solves for r_0/a analytically.\n        \"\"\"\n        R_np = np.array(R, dtype=np.float64)\n        V_np = np.array(V, dtype=np.float64)\n\n        # === Primary Method: Interpolation and Root Finding ===\n        try:\n            # 1. Create a shape-preserving interpolator and its derivative (the force)\n            v_interp = PchipInterpolator(R_np, V_np)\n            f_interp = v_interp.derivative(nu=1)\n\n            # 2. Define the function g(r) whose root we need to find\n            def g(r):\n                # The Sommer scale equation: r^2 * F(r) - c = 0\n                return r**2 * f_interp(r) - C_SOMMER\n\n            # 3. Search for a bracket and solve using brentq\n            # Iterate over intervals defined by the data points.\n            for i in range(len(R_np) - 1):\n                r_a, r_b = R_np[i], R_np[i+1]\n                # Brentq will raise a ValueError if g(r_a) and g(r_b) do not have\n                # opposite signs. We catch this and continue to the next interval.\n                try:\n                    root = brentq(g, r_a, r_b)\n                    return round(root, 6)\n                except ValueError:\n                    continue\n            \n            # If the loop completes without finding a root, it means no bracket\n            # was found between adjacent data points. This triggers the fallback.\n            raise ValueError(\"No bracket found for root finding via interpolation.\")\n\n        # === Fallback Method: Regularization via Fit ===\n        except (ValueError, RuntimeError):\n            # 1. Define the Cornell potential model for fitting\n            def cornell_potential(r, alpha, sigma, v0):\n                return -alpha / r + sigma * r + v0\n\n            # 2. Fit the model to the data to get the parameters\n            # Initial guess for [alpha, sigma, v0] based on typical lattice QCD values.\n            p0 = [0.3, 0.2, 0.6]\n            \n            popt, _ = curve_fit(cornell_potential, R_np, V_np, p0=p0, maxfev=10000)\n            alpha, sigma = popt[0], popt[1]\n\n            # 3. Calculate r_0/a using the analytical formula for the Cornell potential\n            # Check for physical parameters to ensure the argument of sqrt is positive.\n            if sigma = 0 or (C_SOMMER - alpha)  0:\n                # Should not happen with the provided data, but is a necessary check.\n                raise RuntimeError(\"Fit resulted in unphysical parameters.\")\n            \n            r0_lat_sq = (C_SOMMER - alpha) / sigma\n            root = np.sqrt(r0_lat_sq)\n            \n            return round(root, 6)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        ([1, 2, 3, 4, 5, 6, 7, 8], [0.38, 0.71, 0.94, 1.145, 1.34, 1.53, 1.7171428571, 1.9025]),\n        # Case B\n        ([1, 2, 3, 4, 5, 6, 7, 8], [0.3785, 0.713, 0.9355, 1.151, 1.3325, 1.539, 1.7066428571, 1.9145]),\n        # Case C\n        ([2, 3, 4, 5, 6], [0.715, 0.9766666667, 1.2175, 1.45, 1.6783333333]),\n        # Case D\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [0.51, 0.72, 0.8966666667, 1.065, 1.23, 1.3933333333, 1.5557142857, 1.7175, 1.8788888889, 2.04]),\n        # Case E\n        ([1, 2, 3, 4, 5, 6, 7], [0.54, 0.87, 1.1133333333, 1.345, 1.548, 1.7566666667, 1.9628571429])\n    ]\n\n    results = []\n    for R_data, V_data in test_cases:\n        result = solve_case(R_data, V_data)\n        # Format to exactly six decimal places for the output string.\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}