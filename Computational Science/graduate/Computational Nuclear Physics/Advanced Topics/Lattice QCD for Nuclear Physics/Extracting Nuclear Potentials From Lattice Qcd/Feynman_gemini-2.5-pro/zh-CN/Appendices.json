{
    "hands_on_practices": [
        {
            "introduction": "此练习将深入探讨 HAL QCD 方法的核心，该方法通过重排薛定谔方程来定义核势。由于计算是在离散的晶格上进行的，我们必须使用数值方法来近似连续的拉普拉斯算符 $\\nabla^2$。本练习  将让您直接比较标准的 7 点差分格式和一种改进的 27 点差分格式，以揭示这种数值选择如何引入离散化误差，尤其是在短距离处。",
            "id": "3558798",
            "problem": "设计并实现一个完整的程序，用于量化在格点量子色动力学从强子到原子核 (Hadrons-to-Atomic-nuclei from Lattice Quantum Chromodynamics, HAL QCD) 方法中提取局域核势时的离散化效应。使用以下基础：相对坐标波函数的等时双体薛定谔方程，在局域中心势作用下，以物理单位表示，并明确包含普朗克常数和光速因子以确保单位一致性。该基础方程为\n$$\n-\\frac{\\hbar^2}{2\\mu}\\nabla^2 \\psi(\\mathbf{r}) + V(r)\\,\\psi(\\mathbf{r}) = E\\,\\psi(\\mathbf{r}),\n$$\n其中 $r = \\lVert \\mathbf{r} \\rVert$，$\\psi(\\mathbf{r})$ 是等时 Nambu–Bethe–Salpeter (NBS) 波函数，$V(r)$ 是待提取的局域势，$\\mu$ 是约化质量，$E$ 是弹性双体态的能量。您将比较立方格点上拉普拉斯算符的两种离散近似，格点间距为 $a$：标准的 $7$-点模板和改进的 $27$-点各向同性模板。\n\n您的程序必须：\n\n1. 构建一个边长为 $2R_{\\max}$ 的三维立方格点，格点间距为 $a$（单位为 $\\mathrm{fm}$），以原点为中心，因此格点坐标为 $(x_i,y_j,z_k)$，其中 $x_i,y_j,z_k \\in [-R_{\\max},R_{\\max}]$，并且沿各轴的间距均匀为 $a$。仅使用那些对于您实现的模板而言所有必需的相邻点都存在的点。\n\n2. 定义一个球对称的模拟等时 Nambu–Bethe–Salpeter (NBS) 波函数，该波函数具有平滑的短程行为，\n$$\n\\psi(r) = \\exp\\!\\big(-\\alpha\\, r^2\\big),\n$$\n其中 $\\alpha$ 的单位为 $\\mathrm{fm}^{-2}$。这种选择避免了节点，并确保比值 $\\nabla^2 \\psi(\\mathbf{r})/\\psi(\\mathbf{r})$ 在整个感兴趣的区域内都是良定义的。\n\n3. 使用以下方法在格点位置上离散化拉普拉斯算符 $\\nabla^2 \\psi$：\n   - 三维中的 $7$-点模板：\n     $$\n     \\nabla^2_{7}\\psi(i,j,k) = \\frac{1}{a^2}\\Big(\\psi_{i+1,j,k}+\\psi_{i-1,j,k}+\\psi_{i,j+1,k}+\\psi_{i,j-1,k}+\\psi_{i,j,k+1}+\\psi_{i,j,k-1}-6\\psi_{i,j,k}\\Big).\n     $$\n   - 改进的各向同性 $27$-点模板（有时称为布里渊型拉普拉斯算符），它结合了面、边和角的相邻格点，并选择权重以最小化旋转各向异性，同时保持二阶相容性：\n     $$\n     \\nabla^2_{27}\\psi(i,j,k) = \\frac{1}{a^2}\\Big(w_0\\,\\psi_{i,j,k} + w_1 \\sum_{\\text{faces}} \\psi + w_2 \\sum_{\\text{edges}} \\psi + w_3 \\sum_{\\text{corners}} \\psi \\Big),\n     $$\n     其中相邻格点集合为：\n     - 面：偏移量 $(\\pm1,0,0)$、$(0,\\pm1,0)$、$(0,0,\\pm1)$，共六个。\n     - 边：偏移量 $(\\pm1,\\pm1,0)$、$(\\pm1,0,\\pm1)$、$(0,\\pm1,\\pm1)$，共十二个。\n     - 角：偏移量 $(\\pm1,\\pm1,\\pm1)$，共八个。\n     权重为\n     $$\n     w_0 = -\\frac{64}{15},\\quad w_1 = \\frac{7}{15},\\quad w_2 = \\frac{1}{10},\\quad w_3 = \\frac{1}{30}.\n     $$\n     此模板经过归一化，使得 $\\nabla^2_{27}$ 能将常数场湮灭，并提供比标准 $7$-点模板改进的旋转不变性。\n\n4. 使用上述薛定谔方程作为 HAL QCD 局域势的基于原理的定义，通过比值 $\\nabla^2 \\psi(\\mathbf{r})/\\psi(\\mathbf{r})$ 在格点位置上计算用每种拉普拉斯模板提取的局域势 $V_{7}(r)$ 和 $V_{27}(r)$。通过使用 $(\\hbar c)^2$（其中 $\\hbar c = 197.3269804\\,\\mathrm{MeV}\\cdot\\mathrm{fm}$）、约化质量 $\\mu$（单位 $\\mathrm{MeV}$）、能量 $E$（单位 $\\mathrm{MeV}$）和长度（单位 $\\mathrm{fm}$）来确保单位一致性。势必须以 $\\mathrm{MeV}$ 表示。\n\n5. 通过计算最大绝对差来评估短距离处提取势的变化\n$$\n\\Delta V_{\\max} = \\max_{r \\le 0.5\\,\\mathrm{fm}} \\big|V_{27}(r)-V_{7}(r)\\big|\n$$\n该计算遍历所有满足 $r \\le 0.5\\,\\mathrm{fm}$ 且所有必需相邻点都存在的格点。为每个测试案例报告 $\\Delta V_{\\max}$（单位 $\\mathrm{MeV}$）。\n\n6. 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如 $[x_1,x_2,x_3]$），每个 $x_n$ 对应于相应测试案例的 $\\Delta V_{\\max}$（单位 $\\mathrm{MeV}$）。\n\n物理单位：所有距离以 $\\mathrm{fm}$ 表示，能量以 $\\mathrm{MeV}$ 表示，不使用角度。输出值必须是浮点数，单位为 $\\mathrm{MeV}$。\n\n为以下测试套件实现程序，每个元组提供 $(a,\\mu,E,\\alpha,R_{\\max})$，单位为 $(\\mathrm{fm},\\mathrm{MeV},\\mathrm{MeV},\\mathrm{fm}^{-2},\\mathrm{fm})$：\n\n- 测试案例 1：$(0.08, 469.5, 10.0, 2.0, 3.20)$，一个精细格点，代表核子约化质量和适度的结合能。\n- 测试案例 2：$(0.20, 469.5, 10.0, 2.0, 4.00)$，一个粗糙格点，用于探测短距离处的强离散化效应。\n- 测试案例 3：$(0.08, 469.5, 10.0, 8.0, 3.20)$，一个急剧变化的波函数，以放大对模板选择的敏感度。\n- 测试案例 4：$(0.12, 469.5, 0.0, 2.0, 3.60)$，零能量，以分离由拉普拉斯算符驱动的对势的贡献。\n\n您的程序应生成单行输出，其中包含这四个测试案例的 $\\Delta V_{\\max}$ 值，形式为用方括号括起来的逗号分隔列表，单位为 $\\mathrm{MeV}$。",
            "solution": "该问题已经过验证，被认为是合理的。它在科学上基于量子力学和数值分析的原理，问题设定良好，具有唯一且可计算的解，其表述也是客观的。所有必需的参数和定义均已提供。因此，我们可以着手解决。\n\n核心任务是量化在使用两种不同的拉普拉斯算符 $\\nabla^2$ 数值近似，从一个模拟波函数中提取局域势时产生的差异，这是在 HAL QCD 方法的背景下进行的。离散拉普拉斯算符的选择会引入一种系统性误差，称为离散化误差，它依赖于格点间距 $a$ 和底层波函数的性质。本练习比较了标准的 $7$-点模板和改进的 $27$-点模板，以评估在短距离处此误差的大小。\n\n该方法的基础是双体系统相对坐标波函数 $\\psi(\\mathbf{r})$ 的不含时薛定谔方程：\n$$\n-\\frac{\\hbar^2}{2\\mu}\\nabla^2 \\psi(\\mathbf{r}) + V(r)\\,\\psi(\\mathbf{r}) = E\\,\\psi(\\mathbf{r})\n$$\n这里，$\\mu$ 是约化质量，$E$ 是系统能量，$V(r)$ 是我们希望确定的局域中心势，其中 $r = \\lVert \\mathbf{r} \\rVert$。在 HAL QCD 方法中，$\\psi(\\mathbf{r})$ 对应于等时 Nambu–Bethe–Salpeter (NBS) 波函数，该波函数是通过格点 QCD 模拟计算得出的。通过重新整理薛定谔方程，我们可以将势 $V(r)$ 表示为：\n$$\nV(r) = E - \\frac{\\hbar^2}{2\\mu} \\frac{\\nabla^2 \\psi(\\mathbf{r})}{\\psi(\\mathbf{r})}\n$$\n为了使单位明确并便于计算，我们使用 $\\hbar c$ 以 $\\mathrm{MeV}\\cdot\\mathrm{fm}$ 为单位的值。势则由下式给出：\n$$\nV(r) = E + \\frac{(\\hbar c)^2}{2\\mu} \\frac{\\nabla^2 \\psi(\\mathbf{r})}{\\psi(\\mathbf{r})}\n$$\n其中 $E$ 和 $\\mu$ 的单位是 $\\mathrm{MeV}$，长度单位是 $\\mathrm{fm}$。\n\n对于此分析，提供了一个模拟 NBS 波函数：\n$$\n\\psi(r) = \\exp(-\\alpha r^2)\n$$\n这种高斯形式在解析上易于处理且行为良好，没有会导致比率 $\\nabla^2\\psi/\\psi$ 发散的节点。该函数的解析拉普拉斯算符为 $\\nabla^2\\psi(r) = (4\\alpha^2 r^2 - 6\\alpha) \\exp(-\\alpha r^2)$。因此，与该波函数对应的精确连续势为 $V_{\\text{true}}(r) = E + \\frac{(\\hbar c)^2}{2\\mu}(4\\alpha^2 r^2 - 6\\alpha)$，这是一个关于 $r^2$ 的简单二次函数。\n\n问题的核心在于将连续算符 $\\nabla^2$ 替换为间距为 $a$ 的三维立方格点上的离散近似。我们将实现并比较两种这样的近似。\n\n1.  **$7$-点模板**：这是三维拉普拉斯算符的标准二阶中心差分近似。在由 $(i,j,k)$ 索引的格点位置上，它定义为：\n    $$\n    \\nabla^2_{7}\\psi(i,j,k) = \\frac{1}{a^2}\\Big(\\psi_{i+1,j,k}+\\psi_{i-1,j,k}+\\psi_{i,j+1,k}+\\psi_{i,j-1,k}+\\psi_{i,j,k+1}+\\psi_{i,j,k-1}-6\\psi_{i,j,k}\\Big)\n    $$\n    该模板使用沿笛卡尔坐标轴的最近邻点。\n\n2.  **改进的 $27$-点模板**：该模板包含了围绕中心点 $(i,j,k)$ 的立方体的面、边和角上的相邻点，以构建具有更好旋转对称性的近似。其定义为：\n    $$\n    \\nabla^2_{27}\\psi(i,j,k) = \\frac{1}{a^2}\\Big(w_0\\,\\psi_{i,j,k} + w_1 \\sum_{\\text{faces}} \\psi + w_2 \\sum_{\\text{edges}} \\psi + w_3 \\sum_{\\text{corners}} \\psi \\Big)\n    $$\n    权重为 $w_0 = -64/15$，$w_1 = 7/15$，$w_2 = 1/10$ 和 $w_3 = 1/30$。求和分别是对 $6$ 个面邻点、$12$ 个边邻点和 $8$ 个角邻点进行的。选择这些权重是为了抵消模板泰勒展开中的领头阶旋转各向异性项。\n\n解决每个测试案例的算法步骤如下：\n\n-   **步骤 1：格点构建**。定义一个跨越立方体 $[-R_{\\max}, R_{\\max}]^3$ 的三维格点，具有均匀间距 $a$。这通过创建一维坐标数组并使用 `meshgrid` 函数生成三维坐标数组 $X, Y, Z$ 来实现。\n\n-   **步骤 2：波函数求值**。在格点上的每个点计算模拟波函数 $\\psi(r) = \\exp(-\\alpha r^2)$，其中 $r = \\sqrt{X^2+Y^2+Z^2}$。\n\n-   **步骤 3：拉普拉斯算符计算**。计算离散拉普拉斯算符 $\\nabla^2_{7}\\psi$ 和 $\\nabla^2_{27}\\psi$。此计算仅限于格点的内部点，对于这些点，所有必需的邻点（对于 $27$-点模板，直至角邻点）都存在于定义的网格内。这可以通过在 `numpy` 中使用数组切片来高效实现。\n\n-   **步骤 4：势提取**。使用步骤 3 的结果，在每个内部格点上使用公式 $V_i(r) = E + \\frac{(\\hbar c)^2}{2\\mu} (\\nabla^2_i \\psi / \\psi)$ 计算势的两个版本 $V_7(r)$ 和 $V_{27}(r)$。\n\n-   **步骤 5：差异量化**。计算绝对差 $|V_{27}(r) - V_{7}(r)|$。创建一个布尔掩码，以仅选择那些既位于内部计算体积内又满足距离约束 $r \\le 0.5\\,\\mathrm{fm}$ 的点。测试案例的最终结果 $\\Delta V_{\\max}$ 是此差在所选点上的最大值。\n\n对提供的四个测试案例中的每一个重复此过程，并收集得到的 $\\Delta V_{\\max}$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    \n    # Test cases: (a, mu, E, alpha, R_max)\n    # Units: (fm, MeV, MeV, fm^-2, fm)\n    test_cases = [\n        (0.08, 469.5, 10.0, 2.0, 3.20),\n        (0.20, 469.5, 10.0, 2.0, 4.00),\n        (0.08, 469.5, 10.0, 8.0, 3.20),\n        (0.12, 469.5, 0.0, 2.0, 3.60),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_v_max = calculate_delta_v_max(*case)\n        results.append(delta_v_max)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\ndef calculate_delta_v_max(a: float, mu: float, E: float, alpha: float, R_max: float) -> float:\n    \"\"\"\n    Calculates the maximum absolute difference between potentials extracted\n    using 7-point and 27-point Laplacian stencils.\n\n    Args:\n        a (float): Lattice spacing in fm.\n        mu (float): Reduced mass in MeV.\n        E (float): Energy in MeV.\n        alpha (float): Wavefunction parameter in fm^-2.\n        R_max (float): Half-side length of the cubic lattice in fm.\n\n    Returns:\n        float: The maximum absolute potential difference Delta V_max in MeV.\n    \"\"\"\n    # Physical and conversion constants\n    hbar_c = 197.3269804  # MeV*fm\n    v_factor = hbar_c**2 / (2 * mu)\n    r_cutoff_sq = 0.5**2 # fm^2\n\n    # 1. Construct the lattice\n    # Determine the number of points from the origin to the edge\n    N_half = int(np.round(R_max / a))\n    # Create a 1D coordinate array centered at the origin\n    coords_1d = np.linspace(-N_half * a, N_half * a, 2 * N_half + 1)\n    # Generate 3D coordinate grids\n    X, Y, Z = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n\n    # 2. Evaluate the mock wavefunction\n    R_sq = X**2 + Y**2 + Z**2\n    psi = np.exp(-alpha * R_sq)\n\n    # 3. Calculate discrete Laplacians on the interior of the grid\n    # The stencils require a 1-point border, so we compute on `psi[1:-1, 1:-1, 1:-1]`.\n    # Slicing the `psi` array allows efficient access to neighbor points.\n    \n    # The core region of psi where the Laplacians will be evaluated\n    interior_psi = psi[1:-1, 1:-1, 1:-1]\n\n    # 7-point stencil calculation\n    # Sum over the 6 face neighbors relative to the interior grid\n    sum_faces = (psi[2:, 1:-1, 1:-1] + psi[:-2, 1:-1, 1:-1] +\n                 psi[1:-1, 2:, 1:-1] + psi[1:-1, :-2, 1:-1] +\n                 psi[1:-1, 1:-1, 2:] + psi[1:-1, 1:-1, :-2])\n    \n    lap_7 = (sum_faces - 6 * interior_psi) / a**2\n\n    # 27-point stencil calculation\n    w0, w1, w2, w3 = -64/15., 7/15., 1/10., 1/30.\n    \n    # Term 0: Central point\n    term0 = w0 * interior_psi\n\n    # Term 1: Face neighbors (same sum as for the 7-point stencil)\n    term1 = w1 * sum_faces\n    \n    # Term 2: Edge neighbors (12 points)\n    sum_edges = (psi[:-2, :-2, 1:-1] + psi[:-2, 2:, 1:-1] +  # xy plane, z-1 shifted\n                 psi[2:, :-2, 1:-1] + psi[2:, 2:, 1:-1] +\n                 psi[:-2, 1:-1, :-2] + psi[:-2, 1:-1, 2:] +  # xz plane, y-1 shifted\n                 psi[2:, 1:-1, :-2] + psi[2:, 1:-1, 2:] +\n                 psi[1:-1, :-2, :-2] + psi[1:-1, :-2, 2:] +  # yz plane, x-1 shifted\n                 psi[1:-1, 2:, :-2] + psi[1:-1, 2:, 2:])\n    term2 = w2 * sum_edges\n    \n    # Term 3: Corner neighbors (8 points)\n    sum_corners = (psi[:-2, :-2, :-2] + psi[:-2, :-2, 2:] +\n                   psi[:-2, 2:, :-2] + psi[:-2, 2:, 2:] +\n                   psi[2:, :-2, :-2] + psi[2:, :-2, 2:] +\n                   psi[2:, 2:, :-2] + psi[2:, 2:, 2:])\n    term3 = w3 * sum_corners\n\n    lap_27 = (term0 + term1 + term2 + term3) / a**2\n    \n    # 4. Compute potentials V7 and V27\n    # The division by `interior_psi` is safe as the Gaussian is never zero.\n    V7 = E + v_factor * (lap_7 / interior_psi)\n    V27 = E + v_factor * (lap_27 / interior_psi)\n\n    # 5. Compute the absolute difference\n    delta_V = np.abs(V27 - V7)\n\n    # 6. Apply mask for r <= 0.5 fm and find the maximum difference\n    # We must use the coordinates corresponding to the interior grid\n    interior_R_sq = R_sq[1:-1, 1:-1, 1:-1]\n    mask = interior_R_sq <= r_cutoff_sq\n\n    # Ensure there are points within the cutoff radius before taking a max\n    if not np.any(mask):\n        return 0.0\n\n    delta_V_max = np.max(delta_V[mask])\n    \n    return delta_V_max\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "在获得连续极限下的核势后，一个关键步骤是验证其物理正确性。在长距离下，核势主要由交换最轻的介子——π介子所主导，这导致了其特有的汤川势形式。本练习  将指导您完成这一基本步骤，通过将来自多个晶格间距的核势数据拟合到一个包含主要误差项的模型中，这是任何精确格点计算的基石技术。",
            "id": "3558801",
            "problem": "考虑一个固定的重子间距 $r^{\\star}$，在该间距下，中心二重子势 $V_{C}(r^{\\star})$ 已通过在相同物理体积中、使用三个格点间距 $a_{1},a_{2},a_{3}$ 进行的格点量子色动力学（LQCD, Lattice Quantum Chromodynamics）计算得出。根据 Symanzik 有效理论，对于一个经过适当改进的作用量，领头离散化效应表现为格点间距的偶数次幂，因此在固定的 $r^{\\star}$ 下，很自然地可以用一个在 $a^{2}$ 上线性的拟设（ansatz）来建模其对格点间距的依赖性：\n$$\nV_{C}(a;r^{\\star}) \\;=\\; V_{0} \\;+\\; c\\,a^{2} \\;+\\; \\varepsilon,\n$$\n其中，$V_{0}$ 是在 $a\\to 0$ 时的连续极限值，$c$ 是描述领头离散化赝象的斜率，$\\varepsilon$ 表示统计涨落。假设在格点间距 $a_{i}$ 处的每次测量 $V_{i}$ 都具有一个独立的、标准差 $\\sigma_{i}$ 已知的高斯不确定度。在这些假设下，最大似然估计等价于对变量 $x_{i}=a_{i}^{2}$ 进行加权最小二乘线性拟合，权重为 $w_{i}=1/\\sigma_{i}^{2}$。从拟合中，提取：\n- 连续极限估计值 $V_{0}$，单位为兆电子伏特（MeV），\n- 斜率 $c$，单位为兆电子伏特每平方飞米（MeV/fm$^{2}$），\n- 一倍标准差不确定度 $\\sigma_{V_{0}}$ 和 $\\sigma_{c}$，\n- 由每个自由度的卡方值 $\\chi^{2}/\\nu$（其中 $\\nu = N-2$，$N$ 是数据点数量）量化的拟合优度，\n- 根据卡方分布计算出的 $p$ 值，\n并通过声明数据集“一致”当且仅当 $p \\geq 0.05$，来评估这三个输入在所选 $r^{\\star}$ 处是否与假设的 $a^{2}$ 标度行为在统计上一致。\n\n所有输入均使用物理标准单位。格点间距 $a_{i}$ 的单位为飞米（fm），势 $V_{i}$ 的单位为兆电子伏特（MeV），其一倍标准差不确定度 $\\sigma_{i}$ 的单位也为兆电子伏特（MeV）。您必须：\n- 对 $V_{i}$ 与 $x_{i}=a_{i}^{2}$ 进行加权线性回归，\n- 计算 $V_{0}$、$c$、$\\sigma_{V_{0}}$、$\\sigma_{c}$、$\\chi^{2}/\\nu$ 和 $p$ 值，\n- 按照上述规定判断一致性布尔值。\n\n测试套件。将您的程序应用于以下四个数据集，每个数据集都在相同的固定 $r^{\\star}$ 下，但测量质量不同。对于每个数据集，元组分别列出了 $(\\,a_{1},a_{2},a_{3}\\,)$（单位 fm）、$(\\,V_{1},V_{2},V_{3}\\,)$（单位 MeV）和 $(\\,\\sigma_{1},\\sigma_{2},\\sigma_{3}\\,)$（单位 MeV）：\n- 数据集 A（典型的一致情况）：(\\,0.12,\\,0.09,\\,0.06\\,)，(\\,-7.10,\\,-8.40,\\,-9.30\\,)，(\\,0.15,\\,0.15,\\,0.15\\,)。\n- 数据集 B（因离群值而不一致）：(\\,0.12,\\,0.09,\\,0.06\\,)，(\\,-7.10,\\,-9.10,\\,-9.30\\,)，(\\,0.15,\\,0.15,\\,0.15\\,)。\n- 数据集 C（不确定度大，大致一致）：(\\,0.12,\\,0.09,\\,0.06\\,)，(\\,-7.20,\\,-8.30,\\,-9.50\\,)，(\\,1.00,\\,1.00,\\,1.00\\,)。\n- 数据集 D（斜率接近零，精确且一致）：(\\,0.12,\\,0.09,\\,0.06\\,)，(\\,-5.02,\\,-4.98,\\,-5.01\\,)，(\\,0.05,\\,0.05,\\,0.05\\,)。\n\n输出规格。对于每个数据集，输出一个包含 7 个条目的列表，顺序完全如下：\n$[\\,V_{0}\\text{ (MeV)},\\,\\sigma_{V_{0}}\\text{ (MeV)},\\,c\\text{ (MeV/fm}^{2}\\text{)},\\,\\sigma_{c}\\text{ (MeV/fm}^{2}\\text{)},\\,\\chi^{2}/\\nu,\\,p\\text{-值},\\,\\text{一致性}\\,]$，\n其中所有浮点数必须四舍五入到三位小数，一致性是使用规则 $p \\geq 0.05$ 的布尔值。您的程序应生成单行输出，其中包含四个数据集的结果，形式为一个由四个数据集各自列表组成的逗号分隔列表，并用方括号括起来（例如，$[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$）。所有 $V_{0}$ 和 $\\sigma_{V_{0}}$ 值必须解释为 MeV，所有 $c$ 和 $\\sigma_{c}$ 值必须解释为 MeV/fm$^{2}$，而 $\\chi^{2}/\\nu$ 和 $p$ 值为无量纲。不要在打印输出中包含任何单位。所有计算在适用时必须以弧度进行；此任务不涉及角度。",
            "solution": "用户提供了一个来自计算核物理领域的问题，该问题需要执行加权线性回归，以从模拟的格点 QCD 数据中提取物理参数。在尝试解决之前，需要对问题进行验证。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n\n- **模型**：在固定间距 $r^{\\star}$ 下，中心势 $V_C$ 对格点间距的依赖性被建模为在 $a^2$ 上线性：$V_{C}(a;r^{\\star}) = V_{0} + c\\,a^{2} + \\varepsilon$。\n- **变量与参数**：\n    - $V_0$：$a \\to 0$ 时的连续极限势。\n    - $c$：描述领头离散化赝象的斜率。\n    - $a$：格点间距。\n    - $\\varepsilon$：统计涨落，假设为独立且呈高斯分布。\n- **每次测量的数据**：对于每次测量 $i=1, 2, 3$：\n    - 格点间距 $a_i$（单位 fm）。\n    - 测量的势 $V_i$（单位 MeV）。\n    - 势的标准差 $\\sigma_i$（单位 MeV）。\n- **方法**：最大似然估计，等价于对 $V_i$ 与 $x_i = a_i^2$ 进行加权最小二乘线性拟合，权重为 $w_i = 1/\\sigma_i^2$。\n- **需要提取的量**：\n    1.  连续极限估计值 $V_{0}$（单位 MeV）。\n    2.  斜率 $c$（单位 MeV/fm$^2$）。\n    3.  一倍标准差不确定度 $\\sigma_{V_{0}}$（单位 MeV）。\n    4.  一倍标准差不确定度 $\\sigma_{c}$（单位 MeV/fm$^2$）。\n    5.  每个自由度的卡方值 $\\chi^{2}/\\nu$，其中 $\\nu = N-2$ 且有 $N=3$ 个数据点。\n    6.  根据卡方分布计算出的 $p$ 值。\n    7.  关于统计一致性的布尔评估：“一致”当且仅当 $p \\geq 0.05$。\n- **测试数据集**：提供了四个数据集（A, B, C, D），每个都包含 $(\\,a_{1},a_{2},a_{3}\\,)$、$(\\,V_{1},V_{2},V_{3}\\,)$ 和 $(\\,\\sigma_{1},\\sigma_{2},\\sigma_{3}\\,)$ 的元组。\n- **输出格式**：单行输出，包含一个列表的列表，每个子列表对应一个数据集。每个内部列表必须包含 7 个提取的量，所有浮点数四舍五入到三位小数。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n- **科学依据**：该问题在格点场论方法论中有坚实的科学基础。使用 Symanzik 有效理论来表征离散化误差、对于改进作用量的领头 $a^2$ 依赖性，以及通过加权线性拟合进行连续极限外推，都是该领域的标准和基础技术。\n- **适定性**：该问题是适定的。它提供了一个清晰的数学模型和所有必要的输入数据（$a_i, V_i, \\sigma_i$）。加权线性回归的过程是一个确定性算法，对于给定的输入，能产生唯一的拟合参数及其不确定度的解。数据点数（$N=3$）超过模型参数数量（$k=2$），这使得自由度为 $\\nu = N-2 = 1$ 的拟合优度检验是明确定义的。\n- **客观性**：该问题以客观和精确的语言陈述。所有量都有明确定义，一致性的标准（$p \\ge 0.05$）也明确无歧义。\n\n该问题没有说明中列出的任何缺陷（例如，科学上不健全、不完整、模棱两可）。所有数据和单位在物理上都是一致的，并且在相关背景下是现实的。\n\n**第 3 步：结论与行动**\n\n此问题**有效**。将提供解决方案。\n\n### 解法推导\n\n任务是为模型 $y(x) = b + mx$ 执行加权线性回归。在此问题的背景下，我们按如下方式识别变量：\n- 因变量是势，$y_i = V_i$。\n- 自变量是格点间距的平方，$x_i = a_i^2$。\n- 截距是连续极限势，$b = V_0$。\n- 斜率是离散化系数，$m = c$。\n\n因此，模型为 $V_i = V_0 + c a_i^2$。鉴于每次测量 $V_i$ 都有一个高斯不确定度 $\\sigma_i$，最优参数 $V_0$ 和 $c$ 可通过最小化卡方函数 $\\chi^2$ 找到：\n$$\n\\chi^2(V_0, c) = \\sum_{i=1}^{N} \\left( \\frac{V_i - (V_0 + c x_i)}{\\sigma_i} \\right)^2 = \\sum_{i=1}^{N} w_i (V_i - V_0 - c x_i)^2\n$$\n其中 $N=3$ 是数据点的数量，而 $w_i = 1/\\sigma_i^2$ 是权重。\n\n为了找到最小值，我们将 $\\chi^2$ 对 $V_0$ 和 $c$ 的偏导数设为零：\n$$\n\\frac{\\partial \\chi^2}{\\partial V_0} = -2 \\sum_{i=1}^{N} w_i (V_i - V_0 - c x_i) = 0\n$$\n$$\n\\frac{\\partial \\chi^2}{\\partial c} = -2 \\sum_{i=1}^{N} w_i x_i (V_i - V_0 - c x_i) = 0\n$$\n这导出了一个关于两个未知数 $V_0$ 和 $c$ 的线性方程组，称为正规方程：\n$$\n\\begin{pmatrix}\n\\sum w_i & \\sum w_i x_i \\\\\n\\sum w_i x_i & \\sum w_i x_i^2\n\\end{pmatrix}\n\\begin{pmatrix}\nV_0 \\\\\nc\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\sum w_i V_i \\\\\n\\sum w_i x_i V_i\n\\end{pmatrix}\n$$\n为简化起见，我们定义以下加权和：\n- $S_w = \\sum w_i$\n- $S_{wx} = \\sum w_i x_i$\n- $S_{wy} = \\sum w_i V_i$\n- $S_{wxx} = \\sum w_i x_i^2$\n- $S_{wxy} = \\sum w_i x_i V_i$\n\n然后通过对 $2 \\times 2$ 矩阵求逆来求解该线性系统。该矩阵的行列式为 $\\Delta = S_w S_{wxx} - (S_{wx})^2$。$V_0$ 和 $c$ 的解为：\n$$\nV_0 = \\frac{S_{wxx} S_{wy} - S_{wx} S_{wxy}}{\\Delta}\n$$\n$$\nc = \\frac{S_w S_{wxy} - S_{wx} S_{wy}}{\\Delta}\n$$\n\n拟合参数的不确定度 $\\sigma_{V_0}$ 和 $\\sigma_c$ 从参数的协方差矩阵导出。协方差矩阵是 $\\frac{1}{2}\\chi^2$ 的海森矩阵的逆矩阵，而海森矩阵正是正规方程中的那个 $2 \\times 2$ 矩阵。\n$$\n\\text{Cov}(V_0, c) = \\begin{pmatrix} \\sigma_{V_0}^2 & \\text{cov}(V_0, c) \\\\ \\text{cov}(V_0, c) & \\sigma_c^2 \\end{pmatrix} = \\begin{pmatrix} S_w & S_{wx} \\\\ S_{wx} & S_{wxx} \\end{pmatrix}^{-1} = \\frac{1}{\\Delta} \\begin{pmatrix} S_{wxx} & -S_{wx} \\\\ -S_{wx} & S_w \\end{pmatrix}\n$$\n方差是该矩阵的对角元素：\n$$\n\\sigma_{V_0}^2 = \\frac{S_{wxx}}{\\Delta} \\quad \\implies \\quad \\sigma_{V_0} = \\sqrt{\\frac{S_{wxx}}{\\Delta}}\n$$\n$$\n\\sigma_c^2 = \\frac{S_w}{\\Delta} \\quad \\implies \\quad \\sigma_c = \\sqrt{\\frac{S_w}{\\Delta}}\n$$\n\n最后，我们评估拟合优度。$\\chi^2$ 的值是使用最佳拟合参数 $V_0$ 和 $c$ 计算的：\n$$\n\\chi^2_{\\text{fit}} = \\sum_{i=1}^{N} w_i (V_i - (V_0 + c x_i))^2\n$$\n自由度数量为 $\\nu = N - k$，其中 $N=3$ 是数据点数量，$k=2$ 是拟合参数数量。因此，$\\nu = 3-2=1$。每个自由度的卡方值为 $\\chi^2/\\nu = \\chi^2_{\\text{fit}}/1$。\n\n$p$ 值表示假设模型正确的情况下，获得一个大于或等于观测到的 $\\chi^2_{\\text{fit}}$ 值的概率。它是根据具有 $\\nu$ 个自由度的 $\\chi^2$ 分布的生存函数计算的：\n$$\np = P(\\chi^2_{\\nu} \\ge \\chi^2_{\\text{fit}})\n$$\n一个大的 $p$ 值（通常 $p \\ge 0.05$）表明，观测到的数据点围绕拟合线的散布与其不确定度在统计上是一致的，意味着该模型是一个好的拟合。该问题将“一致”定义为 $p \\ge 0.05$ 的情况。\n\n实现过程将把这些公式应用于提供的四个数据集中的每一个。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It processes each dataset, performs a weighted linear regression,\n    and formats the results according to the specification.\n    \"\"\"\n    test_cases = [\n        # Dataset A (typical consistent case)\n        ((0.12, 0.09, 0.06), (-7.10, -8.40, -9.30), (0.15, 0.15, 0.15)),\n        # Dataset B (inconsistent due to an outlier)\n        ((0.12, 0.09, 0.06), (-7.10, -9.10, -9.30), (0.15, 0.15, 0.15)),\n        # Dataset C (large uncertainties, broadly consistent)\n        ((0.12, 0.09, 0.06), (-7.20, -8.30, -9.50), (1.00, 1.00, 1.00)),\n        # Dataset D (near-zero slope, precise and consistent)\n        ((0.12, 0.09, 0.06), (-5.02, -4.98, -5.01), (0.05, 0.05, 0.05)),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = process_dataset(case)\n        all_results.append(result)\n\n    # Format the final output line as a list of lists.\n    # The str() on a list gives the desired '[...]' format.\n    results_as_strings = [str(res) for res in all_results]\n    print(f\"[{','.join(results_as_strings)}]\")\n\ndef process_dataset(dataset):\n    \"\"\"\n    Performs weighted linear regression for a single dataset.\n\n    Args:\n        dataset (tuple): A tuple containing three tuples/lists for\n                         (a_i, V_i, sigma_i).\n\n    Returns:\n        list: A list of 7 results: [V0, sigma_V0, c, sigma_c, chi2/nu, p_value, consistent].\n              Floats are rounded to three decimal places.\n    \"\"\"\n    a_vals, v_vals, sigma_vals = dataset\n    \n    # Convert inputs to numpy arrays for vectorized calculations\n    a = np.array(a_vals, dtype=np.float64)\n    V = np.array(v_vals, dtype=np.float64)\n    sigma = np.array(sigma_vals, dtype=np.float64)\n\n    # Independent variable x = a^2 and weights w = 1/sigma^2\n    x = a**2\n    w = 1.0 / sigma**2\n    N = len(a)\n\n    # Calculate the weighted sums required for the fit\n    S_w = np.sum(w)\n    S_wx = np.sum(w * x)\n    S_wy = np.sum(w * V)\n    S_wxx = np.sum(w * x**2)\n    S_wxy = np.sum(w * x * V)\n\n    # Calculate the determinant of the design matrix\n    delta = S_w * S_wxx - S_wx**2\n\n    # Calculate the best-fit parameters (V0: intercept, c: slope)\n    V0 = (S_wxx * S_wy - S_wx * S_wxy) / delta\n    c = (S_w * S_wxy - S_wx * S_wy) / delta\n\n    # Calculate the variances and uncertainties of the parameters\n    var_V0 = S_wxx / delta\n    var_c = S_w / delta\n    sigma_V0 = np.sqrt(var_V0)\n    sigma_c = np.sqrt(var_c)\n\n    # Calculate the goodness of fit\n    V_fit = V0 + c * x\n    chi_squared = np.sum(w * (V - V_fit)**2)\n    nu = N - 2  # Degrees of freedom (N=3 data points, 2 parameters)\n    \n    # Handle the case where nu=0, although not expected for N=3\n    if nu > 0:\n        chi_squared_per_dof = chi_squared / nu\n        p_value = chi2.sf(chi_squared, df=nu)\n    else: \n        # This branch is not hit for the given problem (N=3)\n        chi_squared_per_dof = np.inf if chi_squared > 0 else 0.0\n        p_value = 0.0 if chi_squared > 0 else 1.0\n\n\n    # Determine consistency based on the p-value\n    is_consistent = p_value >= 0.05\n\n    # Format the results into a list, rounding floats to 3 decimal places\n    result_list = [\n        round(V0, 3),\n        round(sigma_V0, 3),\n        round(c, 3),\n        round(sigma_c, 3),\n        round(chi_squared_per_dof, 3),\n        round(p_value, 3),\n        is_consistent\n    ]\n    \n    return result_list\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "在获得连续极限下的核势后，一个关键步骤是验证其物理正确性。在长距离下，核势主要由交换最轻的介子——π介子所主导，这导致了其特有的汤川势形式。本练习  将允许您检验核理论的这一基本预测，通过拟合一个模拟核势的长程部分，并检验其结果与π介子质量和核子轴向耦合常数的一致性。",
            "id": "3558776",
            "problem": "您的任务是检验从格点量子色动力学（Lattice Quantum Chromodynamics (LQCD)）中提取的长程中心核子-核子势在大分离距离下是否与单π介子交换模型一致。在足够大的分离距离下，由最轻的同位旋矢量激发主导的双核子交换的谱表示意味着一个汤川衰减。在将Bethe-Salpeter振幅非相对论性静态约化为局域中心势时，长程尾部被建模为汤川形式\n$$\nV_{\\mathrm{model}}(r) \\equiv -\\frac{A}{r}\\,e^{-\\mu\\, r},\n$$\n其中 $r$ 是以 $\\mathrm{fm}$ 为单位的分离距离，$A$ 是以 $\\mathrm{MeV}\\cdot\\mathrm{fm}$ 为单位的振幅，而 $\\mu$ 是以 $\\mathrm{fm}^{-1}$ 为单位的程参数，它通过以下公式与π介子质量 $m_\\pi$ 相关：\n$$\n\\mu_{\\mathrm{pred}} = \\frac{m_\\pi}{\\hbar c},\n$$\n其中 $\\hbar c = 197.3269804\\,\\mathrm{MeV}\\cdot\\mathrm{fm}$。在单π介子交换的图像中，当其他低能常数保持不变时，振幅 $A$ 与核子轴向耦合 $g_A$ 的平方成正比，即 $A \\propto g_A^2$。您将检验两个独立的一致性条件：\n- $m_\\pi$一致性：拟合得到的 $\\mu$ 是否与通过 $\\mu_{\\mathrm{pred}}$ 由独立提供的 $m_\\pi$ 在统计上一致。\n- $g_A$一致性：跨多个系综拟合得到的振幅 $A$ 是否与一个共同的 $g_A^2$ 正比关系一致（即，$A_i/g_{A,i}^2$ 对于不同的 $i$ 是否一致地为一个常数）。\n\n您的程序必须为 $r \\ge 1.2\\,\\mathrm{fm}$ 生成类似格点量子色动力学的合成数据（中心势值），并对这些数据进行 $V_{\\mathrm{model}}(r)$ 的加权非线性最小二乘拟合。数据生成必须遵循添加了高斯噪声的底层汤川模型。所有计算都必须使用所述的物理单位进行。此问题中不涉及角度。最终输出必须是单行布尔值结果，格式如下所述。\n\n使用以下基本依据：\n- 在长距离下，双体交换的谱表示由最轻的质量主导，这意味着在坐标空间中呈指数衰减 $\\propto e^{-m\\, r}$。\n- 当 $r$ 较大时，约化为静态中心势导致一个汤川尾部 $\\propto e^{-\\mu r}/r$，其中 $\\mu$ 由交换粒子（此处为 $m_\\pi$）的质量决定。\n- 在单介子交换图像中，除 $g_A$ 外的耦合固定时，振幅 $A$ 的标度关系为 $A \\propto g_A^2$。\n\n数据生成细节：\n- 对于每个测试用例 $i$，在指定区间内以间距 $\\Delta r_i$ 均匀抽取 $N_i$ 个半径 $r_{i,k}$（限制为 $r_{i,k} \\ge 1.2\\,\\mathrm{fm}$），并计算\n$$\nV^{\\mathrm{true}}_{i}(r) = -\\frac{A^{\\mathrm{true}}_i}{r}\\,e^{-\\mu^{\\mathrm{true}}_i r}, \\quad \\mu^{\\mathrm{true}}_i = \\frac{m_{\\pi,i}}{\\hbar c}, \\quad A^{\\mathrm{true}}_i = K \\, g_{A,i}^2,\n$$\n添加独立的高斯噪声 $\\epsilon_{i,k} \\sim \\mathcal{N}(0,\\sigma_i^2)$ 以获得观测值\n$$\nV^{\\mathrm{obs}}_{i,k} = V^{\\mathrm{true}}_{i}(r_{i,k}) + \\epsilon_{i,k},\n$$\n并指定观测不确定度为 $\\sigma_{i,k}=\\sigma_i$。\n- 对所有测试用例使用一个固定的常数 $K$（单位为 $\\mathrm{MeV}\\cdot\\mathrm{fm}$），并使用一个固定的随机种子以确保数据可复现。\n\n拟合与统计检验：\n- 对于每个用例，对数据 $\\{(r_{i,k}, V^{\\mathrm{obs}}_{i,k}, \\sigma_{i,k})\\}_{k}$ 进行 $V_{\\mathrm{model}}(r)$ 的加权非线性最小二乘拟合，其中参数 $(A_i,\\mu_i)$ 被约束为正值。从协方差矩阵中提取参数不确定度。\n- 为 $m_\\pi$一致性定义一个 $z$ 分数：\n$$\nz_i = \\frac{|\\mu_i - \\mu_{\\mathrm{pred},i}|}{\\sigma_{\\mu,i}},\n$$\n如果 $z_i \\le z_{\\mathrm{thr}}$（阈值 $z_{\\mathrm{thr}} = 3.0$），则判定 $m_\\pi$一致性成立。\n- 对于跨所有用例的 $g_A$一致性，构建 $K_i \\equiv A_i/g_{A,i}^2$（其不确定度为 $\\sigma_{K,i} \\equiv \\sigma_{A,i}/g_{A,i}^2$），计算逆方差加权平均值\n$$\n\\bar{K} = \\frac{\\sum_i K_i/\\sigma_{K,i}^2}{\\sum_i 1/\\sigma_{K,i}^2},\n$$\n卡方值\n$$\n\\chi^2 = \\sum_i \\frac{(K_i - \\bar{K})^2}{\\sigma_{K,i}^2},\n$$\n以及生存概率 $p = \\Pr(\\chi^2_{\\nu} \\ge \\chi^2)$，其中对于 $N$ 个用例，自由度为 $\\nu = N-1$。如果 $p > 0.05$，则判定 $g_A$一致性成立。\n\n测试套件：\n- 使用 $\\hbar c = 197.3269804\\,\\mathrm{MeV}\\cdot\\mathrm{fm}$。\n- 为伪随机数生成器使用固定种子 $s = 123456789$。\n- 使用共同的比例常数 $K = 30.0\\,\\mathrm{MeV}\\cdot\\mathrm{fm}$。\n- 提供三个测试用例，每个用例由 $(m_\\pi\\ \\mathrm{[MeV]}, g_A, r_{\\min}\\ \\mathrm{[fm]}, r_{\\max}\\ \\mathrm{[fm]}, \\Delta r\\ \\mathrm{[fm]}, \\sigma\\ \\mathrm{[MeV]})$ 指定：\n    1. 用例 A：$(140.0, 1.27, 1.2, 3.0, 0.1, 0.8)$。\n    2. 用例 B：$(200.0, 1.10, 1.2, 2.4, 0.1, 1.0)$。\n    3. 用例 C：$(300.0, 1.35, 1.2, 1.6, 0.05, 1.5)$。\n\n所需输出：\n- 对于每个用例 $i \\in \\{A,B,C\\}$，使用所述的 $z$ 检验（$z_{\\mathrm{thr}}=3.0$）输出一个指示 $m_\\pi$一致性的布尔值。\n- 处理完所有用例后，使用显著性水平为 $0.05$ 的卡方检验输出一个最终的布尔值，指示 $g_A$一致性是否成立。\n- 您的程序应生成单行输出，其中包含这四个布尔值，顺序为 $[A\\text{-}m_\\pi\\text{-}\\mathrm{consistency},B\\text{-}m_\\pi\\text{-}\\mathrm{consistency},C\\text{-}m_\\pi\\text{-}\\mathrm{consistency},g_A\\text{-}\\mathrm{consistency}]$，形式为用方括号括起来的逗号分隔列表，例如 $[{\\tt True},{\\tt True},{\\tt True},{\\tt True}]$。\n\n所有数值常数、输入和输出都必须使用上面明确指定的单位。输出是无单位的布尔值。程序必须完全自包含，使用指定的种子，并且除了打印所需的单行输出外，不执行任何其他输入或输出。",
            "solution": "目标是验证为模拟格点量子色动力学（LQCD）结果而合成生成的核子-核子势数据，是否与单π介子交换理论预测的长程行为一致。此验证涉及两个不同的统计检验：一个针对每个数据集的π介子质量依赖性（$m_\\pi$一致性），另一个针对所有数据集的核子轴向耦合依赖性（$g_A$一致性）。该过程涉及数据生成、非线性拟合和统计假设检验。\n\n首先，我们建立理论框架。大核子分离距离 $r$ 下的单π介子交换势由汤川势描述：\n$$\nV_{\\mathrm{model}}(r) = -\\frac{A}{r}\\,e^{-\\mu\\, r}\n$$\n此处，$A$ 是以 $\\mathrm{MeV}\\cdot\\mathrm{fm}$ 为单位的振幅，$\\mu$ 是以 $\\mathrm{fm}^{-1}$ 为单位的程参数。程参数通过基本常数 $\\hbar c = 197.3269804\\,\\mathrm{MeV}\\cdot\\mathrm{fm}$ 与交换的π介子质量 $m_\\pi$直接相关：\n$$\n\\mu_{\\mathrm{pred}} = \\frac{m_\\pi}{\\hbar c}\n$$\n振幅 $A$ 与核子轴向耦合的平方 $g_A^2$ 成正比。我们可以将此比例关系写为 $A = K g_A^2$，其中 $K$ 是一个比例常数，单位为 $\\mathrm{MeV}\\cdot\\mathrm{fm}$。\n\n该过程始于为三个不同的情景（用例 A, B, C）生成合成数据，每个情景由特定的π介子质量 $m_{\\pi,i}$、轴向耦合 $g_{A,i}$ 和数据采样参数定义。对于每个用例 $i$，生成一组径向分离点 $\\{r_{i,k}\\}$。使用汤川模型和真实参数 $A^{\\mathrm{true}}_i = K g_{A,i}^2$ 及 $\\mu^{\\mathrm{true}}_i = m_{\\pi,i} / (\\hbar c)$ 计算“真实”势值 $V^{\\mathrm{true}}_{i}(r_{i,k})$，其中公共常数 $K = 30.0\\,\\mathrm{MeV}\\cdot\\mathrm{fm}$。为了模拟实验或数值噪声，将独立同分布的高斯噪声 $\\epsilon_{i,k} \\sim \\mathcal{N}(0, \\sigma_i^2)$ 添加到真实值上，以产生“观测”数据：\n$$\nV^{\\mathrm{obs}}_{i,k} = V^{\\mathrm{true}}_{i}(r_{i,k}) + \\epsilon_{i,k}\n$$\n每个数据点的不确定度给定为 $\\sigma_{i,k} = \\sigma_i$。所有数据生成都使用固定的伪随机数生成器种子以保证可复现性。\n\n接下来，对于三个数据集 $\\{(r_{i,k}, V^{\\mathrm{obs}}_{i,k}, \\sigma_i)\\}$ 中的每一个，我们对模型 $V_{\\mathrm{model}}(r; A, \\mu)$ 进行加权非线性最小二乘拟合。此过程找到最优参数 $(A_i, \\mu_i)$，使卡方函数最小化：\n$$\n\\chi^2_{\\mathrm{fit}}(A_i, \\mu_i) = \\sum_{k} \\left( \\frac{V^{\\mathrm{obs}}_{i,k} - V_{\\mathrm{model}}(r_{i,k}; A_i, \\mu_i)}{\\sigma_i} \\right)^2\n$$\n拟合被约束为 $A_i > 0$ 和 $\\mu_i > 0$。通过 `scipy.optimize.curve_fit` 实现的拟合过程还会产生拟合参数的协方差矩阵。该矩阵对角线元素的平方根提供了拟合参数的标准不确定度 $\\sigma_{A,i}$ 和 $\\sigma_{\\mu,i}$。\n\n利用拟合的参数及其不确定度，我们执行两个指定的一致性检验。\n\n第一个检验是 $m_\\pi$一致性检验，对每个用例单独进行。它评估拟合的程参数 $\\mu_i$ 是否与从输入π介子质量预测的值 $\\mu_{\\mathrm{pred},i} = m_{\\pi,i} / (\\hbar c)$ 在统计上一致。我们使用 $z$ 分数来量化这一点：\n$$\nz_i = \\frac{|\\mu_i - \\mu_{\\mathrm{pred},i}|}{\\sigma_{\\mu,i}}\n$$\n如果一个用例的 $z$ 分数小于或等于阈值 $z_{\\mathrm{thr}} = 3.0$（对应于 $3\\sigma$ 容忍度），则认为该用例是一致的。\n\n第二个检验是 $g_A$一致性检验，对所有 $N=3$ 个用例进行。该检验验证拟合的振幅 $A_i$ 是否与理论标度关系 $A_i \\propto g_{A,i}^2$ 一致。如果此标度关系成立，则比率 $K_i = A_i/g_{A,i}^2$ 在所有用例中应为一个常数（在统计不确定度范围内）。为检验此假设，我们首先将 $A_i$ 上的不确定度传播到 $K_i$，得到 $\\sigma_{K,i} = \\sigma_{A,i}/g_{A,i}^2$。然后，我们计算 $K_i$ 值的逆方差加权平均值：\n$$\n\\bar{K} = \\frac{\\sum_{i=1}^N K_i/\\sigma_{K,i}^2}{\\sum_{i=1}^N 1/\\sigma_{K,i}^2}\n$$\n然后我们构建一个卡方统计量，它衡量各个 $K_i$ 值与加权平均值 $\\bar{K}$ 的偏差：\n$$\n\\chi^2 = \\sum_{i=1}^N \\frac{(K_i - \\bar{K})^2}{\\sigma_{K,i}^2}\n$$\n该统计量应遵循自由度为 $\\nu = N-1$ 的卡方分布。对于我们的 $N=3$ 个用例，$\\nu=2$。一致性通过计算 $p$ 值来评估，该值是在假设（所有 $K_i$ 都是同一基础常数的样本）为真的情况下，获得一个至少与观测到的 $\\chi^2$ 值一样大的 $\\chi^2$ 值的概率。这由 $\\chi^2$ 分布的生存函数给出，$p = \\Pr(\\chi^2_{\\nu} \\ge \\chi^2)$。如果此 $p$ 值大于 $0.05$ 的显著性水平，则声明该组结果是一致的。\n\n最终输出收集这四个检验的布尔结果：三个用于 $m_\\pi$一致性（每个用例一个），一个用于总体的 $g_A$一致性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Generates synthetic lattice QCD data, fits a Yukawa potential,\n    and performs consistency checks based on one-pion exchange theory.\n    \"\"\"\n    # Define physical constants and problem parameters\n    HBARC = 197.3269804  # MeV*fm\n    SEED = 123456789\n    K_TRUE = 30.0  # MeV*fm\n    Z_THRESHOLD = 3.0\n    P_VALUE_THRESHOLD = 0.05\n\n    # Set the seed for reproducibility\n    np.random.seed(SEED)\n\n    # Test cases: (m_pi [MeV], g_A, r_min [fm], r_max [fm], dr [fm], sigma [MeV])\n    test_cases = [\n        (140.0, 1.27, 1.2, 3.0, 0.1, 0.8),  # Case A\n        (200.0, 1.10, 1.2, 2.4, 0.1, 1.0),  # Case B\n        (300.0, 1.35, 1.2, 1.6, 0.05, 1.5), # Case C\n    ]\n\n    # Model function for the Yukawa potential\n    def yukawa_potential(r, A, mu):\n        return -A / r * np.exp(-mu * r)\n\n    mpi_consistency_results = []\n    fitted_params_for_gA_test = []\n\n    for case_params in test_cases:\n        m_pi, gA, r_min, r_max, dr, sigma_obs_val = case_params\n\n        # --- 1. Data Generation ---\n        # Generate radial separation points\n        # Use np.round to avoid float precision issues with the endpoint\n        num_points = int(np.round((r_max - r_min) / dr)) + 1\n        r_vals = np.linspace(r_min, r_max, num_points)\n        \n        # Calculate true model parameters\n        mu_true = m_pi / HBARC\n        A_true = K_TRUE * gA**2\n        \n        # Generate true potential values\n        V_true = yukawa_potential(r_vals, A_true, mu_true)\n        \n        # Add Gaussian noise to create observed data\n        noise = np.random.normal(loc=0.0, scale=sigma_obs_val, size=r_vals.shape)\n        V_obs = V_true + noise\n        \n        # Assign uncertainties for the fit\n        sigma_obs_arr = np.full_like(r_vals, sigma_obs_val)\n\n        # --- 2. Nonlinear Least-Squares Fit ---\n        # Initial guesses for the parameters\n        p0 = [A_true, mu_true]\n        \n        # Parameter bounds (A > 0, mu > 0)\n        bounds = ([0, 0], [np.inf, np.inf])\n\n        # Perform the weighted nonlinear least-squares fit\n        popt, pcov = curve_fit(\n            yukawa_potential,\n            r_vals,\n            V_obs,\n            p0=p0,\n            sigma=sigma_obs_arr,\n            bounds=bounds,\n            absolute_sigma=True  # Treat sigma as absolute standard deviations\n        )\n        \n        A_fit, mu_fit = popt\n        # Uncertainties are the square root of the diagonal of the covariance matrix\n        sigma_A_fit, sigma_mu_fit = np.sqrt(np.diag(pcov))\n\n        # --- 3. m_pi-Consistency Test ---\n        mu_pred = m_pi / HBARC\n        z_score = np.abs(mu_fit - mu_pred) / sigma_mu_fit\n        \n        is_mpi_consistent = (z_score <= Z_THRESHOLD)\n        mpi_consistency_results.append(is_mpi_consistent)\n        \n        # Store results for the gA-consistency test\n        fitted_params_for_gA_test.append({\n            'gA': gA,\n            'A_fit': A_fit,\n            'sigma_A_fit': sigma_A_fit\n        })\n\n    # --- 4. gA-Consistency Test ---\n    N_cases = len(test_cases)\n    K_vals = np.zeros(N_cases)\n    sigma_K_vals = np.zeros(N_cases)\n    \n    for i, params in enumerate(fitted_params_for_gA_test):\n        gA_i = params['gA']\n        A_i = params['A_fit']\n        sigma_A_i = params['sigma_A_fit']\n        \n        K_vals[i] = A_i / gA_i**2\n        sigma_K_vals[i] = sigma_A_i / gA_i**2\n\n    # Calculate inverse-variance weighted mean\n    weights = 1.0 / sigma_K_vals**2\n    K_bar = np.sum(K_vals * weights) / np.sum(weights)\n    \n    # Calculate the chi-square statistic\n    chi2_stat = np.sum(((K_vals - K_bar) / sigma_K_vals)**2)\n    \n    # Degrees of freedom is N-1\n    dof = N_cases - 1\n    \n    # Calculate the p-value (survival function)\n    p_value = chi2.sf(chi2_stat, dof)\n    \n    is_gA_consistent = (p_value > P_VALUE_THRESHOLD)\n\n    # --- 5. Final Output ---\n    final_results = mpi_consistency_results + [is_gA_consistent]\n    \n    # Format the final output as a string\n    output_str = f\"[{','.join(map(str, final_results))}]\"\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}