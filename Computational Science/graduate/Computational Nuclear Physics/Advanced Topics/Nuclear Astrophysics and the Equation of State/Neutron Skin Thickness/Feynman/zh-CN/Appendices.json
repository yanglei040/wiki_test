{
    "hands_on_practices": [
        {
            "introduction": "任何计算物理学的预测，在没有对其数值误差进行严格评估之前，都是没有意义的。这项实践  将指导你对 $^{208}\\mathrm{Pb}$ 原子核的中子皮厚度进行一项基础而关键的数值收敛性研究。通过系统地改变径向网格间距、计算空间半径和求解器公差，你将学会如何量化这些数值参数对最终物理结果的影响，为所有后续的科学计算工作奠定坚实的可靠性基础。",
            "id": "3573312",
            "problem": "您的任务是设计并实现一个完整的、可运行的数值程序，对球形核中的中子皮厚度（记为 $\\Delta r_{np}$）进行收敛性研究。所有相关的物理量都必须从连续分布和有限计算域上数值积分的基本原理推导得出，不得依赖任何简化公式。您的程序必须分析计算出的 $\\Delta r_{np}$ 如何依赖于三个数值参数：径向网格间距 $dr$、球形盒子半径 $R_{\\mathrm{box}}$，以及用于确定形状参数的迭代容差 $\\mathrm{tol}$。\n\n请从以下基本出发点开始：\n- 在三维空间中，一个球对称的粒子密度 $\\rho(r)$ 对总粒子数的贡献通过体积分给出，对于中子为 $N = \\int 4\\pi r^2 \\rho(r)\\,dr$，对于质子为 $Z = \\int 4\\pi r^2 \\rho(r)\\,dr$，其中积分遍及整个物理空间。\n- 对于具有球对称密度 $\\rho(r)$ 的粒子种类，其均方根半径定义为 $r_{\\mathrm{rms}} = \\sqrt{\\dfrac{\\int 4\\pi r^4 \\rho(r)\\,dr}{\\int 4\\pi r^2 \\rho(r)\\,dr}}$。\n- 中子皮厚度定义为 $\\Delta r_{np} = r_{\\mathrm{rms}}^{(n)} - r_{\\mathrm{rms}}^{(p)}$，其中 $r_{\\mathrm{rms}}^{(n)}$ 和 $r_{\\mathrm{rms}}^{(p)}$ 分别是中子和质子的均方根半径。\n\n使用具有球对称性的双参数费米分布（也称 Woods–Saxon 分布）来模拟中子和质子的密度：\n$$\n\\rho_{q}(r;c_q,a_q,\\rho_{0,q}) = \\frac{\\rho_{0,q}}{1 + \\exp\\!\\left(\\frac{r - c_q}{a_q}\\right)} \\quad \\text{for } q \\in \\{n,p\\},\n$$\n其中 $c_q$ 是半密度半径， $a_q$ 是表面弥散度，$\\rho_{0,q}$ 是中心密度标度。对于质量数为 $A$ 的铅核，使用以下物理上合理的固定参数：\n- 原子核：$^{208}\\mathrm{Pb}$，其 $A = 208$，中子数 $N = 126$，质子数 $Z = 82$。\n- 表面弥散度：$a_n = a_p = 0.55\\ \\mathrm{fm}$。\n- 饱和中心密度：$\\rho_{\\mathrm{sat}} = 0.16\\ \\mathrm{fm}^{-3}$。\n- 按同位旋分数划分的中心密度：$\\rho_{0,n} = \\rho_{\\mathrm{sat}}\\cdot \\dfrac{N}{A}$ 和 $\\rho_{0,p} = \\rho_{\\mathrm{sat}}\\cdot \\dfrac{Z}{A}$。\n\n关键在于，需要通过求解在有限数值域 $r \\in [0, R_{\\mathrm{box}}]$ 上的归一化条件来确定形状参数 $c_n$ 和 $c_p$：\n$$\n\\int_0^{R_{\\mathrm{box}}} 4\\pi r^2 \\rho_{n}(r;c_n,a_n,\\rho_{0,n})\\,dr = N, \\qquad\n\\int_0^{R_{\\mathrm{box}}} 4\\pi r^2 \\rho_{p}(r;c_p,a_p,\\rho_{0,p})\\,dr = Z,\n$$\n此过程应使用一个不假定存在闭式解的稳健一维求根程序。当归一化中的相对残差低于指定的 $\\mathrm{tol}$，或达到迭代次数上限时，迭代必须终止。您的算法必须为 $c_q$ 搜索一个有效区间（确保目标归一化值可以在 $[c_{\\mathrm{min}}, c_{\\mathrm{max}}]$ 内达到），并且必须能妥善处理 $R_{\\mathrm{box}}$ 过小以致无法实现精确归一化的情况（此时 $c_q$ 应被限制在区间内可行的最大值）。\n\n在一个径向网格 $r_k = k\\cdot dr$（其中整数 $k$ 满足 $0 \\le r_k \\le R_{\\mathrm{box}}$）上，使用一个在网格间距为 $dr$ 的网格上一致的复合数值积分方案来计算积分。中子皮厚度 $\\Delta r_{np}$ 必须以费米（fm）为单位进行评估。为了评估收敛性，定义一个在一个非常精细的网格、大盒子和严格容差下计算出的高精度参考值 $\\Delta r_{np}^{\\mathrm{ref}}$，并测量绝对偏差：\n$$\n\\varepsilon(dr, R_{\\mathrm{box}}, \\mathrm{tol}) = \\left|\\Delta r_{np}(dr, R_{\\mathrm{box}}, \\mathrm{tol}) - \\Delta r_{np}^{\\mathrm{ref}}\\right|\n$$\n单位为费米。目标精度判据为 $\\varepsilon \\le 0.005\\ \\mathrm{fm}$。\n\n实现程序以完成以下任务：\n1. 对于给定的 $dr$、$R_{\\mathrm{box}}$ 和 $\\mathrm{tol}$，通过在 $[0, R_{\\mathrm{box}}]$ 约束下的迭代归一化确定 $c_n$ 和 $c_p$，从而构建密度 $\\rho_n(r)$ 和 $\\rho_p(r)$。\n2. 对每种情况，计算 $r_{\\mathrm{rms}}^{(n)}$、$r_{\\mathrm{rms}}^{(p)}$，进而计算 $\\Delta r_{np}$。\n3. 使用 $dr_{\\mathrm{ref}} = 0.005\\ \\mathrm{fm}$、$R_{\\mathrm{box}}^{\\mathrm{ref}} = 25\\ \\mathrm{fm}$ 和 $\\mathrm{tol}_{\\mathrm{ref}} = 10^{-12}$ 计算 $\\Delta r_{np}^{\\mathrm{ref}}$。\n4. 对于每个测试案例 $\\{dr, R_{\\mathrm{box}}, \\mathrm{tol}\\}$，以布尔值的形式输出其是否满足目标精度阈值 $\\varepsilon \\le 0.005\\ \\mathrm{fm}$。\n\n测试套件：\n使用以下八组参数三元组来探究收敛性的不同方面，包括网格粗糙度、盒子截断和迭代紧密性：\n- 案例 1：$dr = 0.50\\ \\mathrm{fm}$，$R_{\\mathrm{box}} = 9.0\\ \\mathrm{fm}$，$\\mathrm{tol} = 10^{-2}$。\n- 案例 2：$dr = 0.10\\ \\mathrm{fm}$，$R_{\\mathrm{box}} = 9.0\\ \\mathrm{fm}$，$\\mathrm{tol} = 10^{-8}$。\n- 案例 3：$dr = 0.20\\ \\mathrm{fm}$，$R_{\\mathrm{box}} = 14.0\\ \\mathrm{fm}$，$\\mathrm{tol} = 10^{-6}$。\n- 案例 4：$dr = 0.10\\ \\mathrm{fm}$，$R_{\\mathrm{box}} = 20.0\\ \\mathrm{fm}$，$\\mathrm{tol} = 10^{-6}$。\n- 案例 5：$dr = 0.05\\ \\mathrm{fm}$，$R_{\\mathrm{box}} = 16.0\\ \\mathrm{fm}$，$\\mathrm{tol} = 10^{-4}$。\n- 案例 6：$dr = 0.05\\ \\mathrm{fm}$，$R_{\\mathrm{box}} = 25.0\\ \\mathrm{fm}$，$\\mathrm{tol} = 10^{-8}$。\n- 案例 7：$dr = 0.02\\ \\mathrm{fm}$，$R_{\\mathrm{box}} = 25.0\\ \\mathrm{fm}$，$\\mathrm{tol} = 10^{-10}$。\n- 案例 8：$dr = 0.01\\ \\mathrm{fm}$，$R_{\\mathrm{box}} = 12.0\\ \\mathrm{fm}$，$\\mathrm{tol} = 10^{-12}$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含上述八个测试案例的结果，形式为一个方括号内由逗号分隔的列表，列表项为布尔值，按给定顺序指示每个案例是否满足 $\\varepsilon \\le 0.005\\ \\mathrm{fm}$（例如，$\\left[\\mathrm{True},\\mathrm{False},\\ldots\\right]$）。不应打印任何其他文本。",
            "solution": "该问题要求对 $^{208}\\mathrm{Pb}$ 核的中子皮厚度 $\\Delta r_{np}$ 进行数值收敛性研究。解决方案涉及实现一个基于第一性原理的计算框架，采用数值积分和求根算法。此分析的基础在于，使用双参数费米密度分布来模拟中子和质子分布，然后通过数值方法求解确保粒子数归一化正确的参数。\n\n**1. 理论与数学框架**\n\n中子 ($q=n$) 和质子 ($q=p$) 的密度分布由球对称的双参数费米函数建模：\n$$\n\\rho_{q}(r; c_q, a_q, \\rho_{0,q}) = \\frac{\\rho_{0,q}}{1 + \\exp\\left(\\frac{r - c_q}{a_q}\\right)}\n$$\n其中 $r$ 是径向坐标，$c_q$ 是半密度半径，$a_q$ 是表面弥散度，$\\rho_{0,q}$ 是中心密度参数。对于 $^{208}\\mathrm{Pb}$ 核，给定 $A=208$，$N=126$ 和 $Z=82$。弥散度固定为 $a_n = a_p = 0.55\\ \\mathrm{fm}$。中心密度由饱和密度 $\\rho_{\\mathrm{sat}} = 0.16\\ \\mathrm{fm}^{-3}$ 导出，即 $\\rho_{0,n} = \\rho_{\\mathrm{sat}} \\cdot (N/A)$ 和 $\\rho_{0,p} = \\rho_{\\mathrm{sat}} \\cdot (Z/A)$。\n\n半密度半径 $c_n$ 和 $c_p$ 未给出，必须通过在半径为 $R_{\\mathrm{box}}$ 的有限球形体积内施加归一化条件来确定。该条件规定，数密度在体积上的积分必须等于该种类粒子的总数：\n$$\nN_q = \\int_0^{R_{\\mathrm{box}}} 4\\pi r^2 \\rho_q(r; c_q, a_q, \\rho_{0,q}) \\, dr\n$$\n其中 $N_n = N$ 且 $N_p = Z$。\n\n一旦获得正确归一化的密度，每种粒子种类的均方根 (rms) 半径计算如下：\n$$\nr_{\\mathrm{rms}}^{(q)} = \\sqrt{\\frac{\\int_0^{R_{\\mathrm{box}}} 4\\pi r^4 \\rho_q(r) \\, dr}{\\int_0^{R_{\\mathrm{box}}} 4\\pi r^2 \\rho_q(r) \\, dr}}\n$$\n此表达式中的分母恰好是粒子数 $N_q$。为保证数值一致性，至关重要的是使用在数值网格上计算出的积分值，而不是目标值 $N$ 或 $Z$。\n\n最后，中子皮厚度是中子和质子均方根半径之差：\n$$\n\\Delta r_{np} = r_{\\mathrm{rms}}^{(n)} - r_{\\mathrm{rms}}^{(p)}\n$$\n\n**2. 数值策略与算法设计**\n\n问题的核心是求解关于 $c_q$ 的归一化方程，然后使用数值积分计算均方根半径。\n\n**2.1. 数值积分**\n所有积分都在离散的径向网格上进行数值计算。该网格由间距为 $dr$ 定义在区间 $[0, R_{\\mathrm{box}}]$ 上，得到点 $r_k = k \\cdot dr$，其中 $k=0, 1, \\dots, \\lfloor R_{\\mathrm{box}}/dr \\rfloor$。对于所涉及的光滑函数积分，采用高阶复合求积法则是合适的。我们选择复合辛普森法则，它能提供出色的精度。`scipy.integrate.simpson` 函数提供了该方法的稳健实现，能正确处理具有偶数和奇数个区间的网格。\n\n**2.2. 半密度半径 $c_q$ 的求根**\n对于每种粒子 $q$，我们必须找到满足归一化条件的 $c_q$ 值。这是一个一维求根问题。我们定义一个残差函数：\n$$\nf(c_q) = \\left( \\int_0^{R_{\\mathrm{box}}} 4\\pi r^2 \\rho_q(r; c_q) \\, dr \\right) - N_q = 0\n$$\n积分项，我们可以记为 $I(c_q)$，是 $c_q$ 的一个单调递减函数。较大的 $c_q$ 会将密度分布向外推，因此对于固定的盒子半径 $R_{\\mathrm{box}}$，盒子内的积分粒子数会减少。这种单调性保证了如果在给定的搜索区间内存在 $c_q$ 的解，那么该解是唯一的。\n\n我们采用稳健的二分法来寻找根 $c_q$。搜索在物理区间 $[c_{\\mathrm{min}}, c_{\\mathrm{max}}] = [0, R_{\\mathrm{box}}]$ 内进行。二分算法流程如下：\n1.  建立搜索区间 $[c_{\\mathrm{min}}, c_{\\mathrm{max}}]$。\n2.  在开始搜索之前，检查目标值 $N_q$ 是否被区间端点处的积分值 $I(c_{\\mathrm{min}})$ 和 $I(c_{\\mathrm{max}})$ 所包围。\n    -   如果 $N_q > I(c_{\\mathrm{min}})$，意味着即使对于最紧凑的密度分布（$c_q = 0$），积分盒子也太小，无法包含 $N_q$ 个粒子。在这种情况下，$c_q$ 被设为 $c_{\\mathrm{min}} = 0$，这是使粒子数最大化的值。\n    -   如果 $N_q  I(c_{\\mathrm{max}})$，意味着即使对于区间内最弥散的分布（$c_q = R_{\\mathrm{box}}$），粒子数也总是大于 $N_q$。此时，$c_q$ 被设为 $c_{\\mathrm{max}} = R_{\\mathrm{box}}$，以使粒子数最小化。\n3.  如果根被区间包围，则通过重复对区间进行二分来进行迭代。在每一步 $i$，测试一个中点 $c_{\\mathrm{mid}, i}$。根据 $I(c_{\\mathrm{mid}, i})$ 是大于还是小于 $N_q$ 来更新下一步的区间。\n4.  当粒子数的相对残差小于指定的容差 $\\mathrm{tol}$，即 $|I(c_q) - N_q| / N_q  \\mathrm{tol}$，或达到固定的最大迭代次数时，迭代终止。\n\n**3. 实现与收敛性研究**\n\n整个程序的结构是为一系列测试案例执行计算，并将它们与一个高精度的参考案例进行比较。\n\n1.  **参考计算**：首先使用一个非常精细的网格（$dr_{\\mathrm{ref}} = 0.005\\ \\mathrm{fm}$）、一个大的盒子半径（$R_{\\mathrm{box}}^{\\mathrm{ref}} = 25\\ \\mathrm{fm}$）和一个严格的求根容差（$\\mathrm{tol}_{\\mathrm{ref}} = 10^{-12}$）来计算一个参考值 $\\Delta r_{np}^{\\mathrm{ref}}$。这提供了一个被认为非常接近真实收敛值的基准。\n\n2.  **测试案例评估**：程序随后遍历八个给定的测试案例，每个案例由一组参数 $\\{dr, R_{\\mathrm{box}}, \\mathrm{tol}\\}$ 定义。对于每个案例：\n    a. 使用上述二分法确定半密度半径 $c_n$ 和 $c_p$。\n    b. 使用辛普森法则计算均方根半径 $r_{\\mathrm{rms}}^{(n)}$ 和 $r_{\\mathrm{rms}}^{(p)}$。\n    c. 计算中子皮厚度 $\\Delta r_{np}$。\n    d. 计算与参考值的绝对偏差 $\\varepsilon = |\\Delta r_{np} - \\Delta r_{np}^{\\mathrm{ref}}|$。\n\n3.  **输出**：为每个案例确定一个布尔值，表示偏差 $\\varepsilon$ 是否满足精度判据 $\\varepsilon \\le 0.005\\ \\mathrm{fm}$。最终输出是这些布尔结果的列表。\n\n该实现被封装在一个 Python 程序中，利用 `numpy` 进行高效的数组操作，并使用 `scipy.integrate.simpson` 进行数值积分，同时遵循所有指定的约束。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Main function to perform the convergence study of the neutron skin thickness.\n    \"\"\"\n    \n    #\n    # --- Problem Constants ---\n    #\n    A = 208.0\n    N = 126.0\n    Z = 82.0\n    a_n = 0.55\n    a_p = 0.55\n    rho_sat = 0.16\n    \n    # Derived density parameters\n    rho_0_n = rho_sat * (N / A)\n    rho_0_p = rho_sat * (Z / A)\n\n    #\n    # --- Numerical Implementation ---\n    #\n\n    def find_c(dr, R_box, tol, N_target, a, rho_0):\n        \"\"\"\n        Determines the half-density radius 'c' using a bisection root-finding method.\n        \"\"\"\n        num_points = int(R_box / dr) + 1\n        r_grid = np.linspace(0.0, R_box, num_points)\n\n        def calculate_norm_at_c(c_val):\n            \"\"\"Helper function to compute the integrated particle number for a given c.\"\"\"\n            # Fermi-Dirac distribution\n            rho_vals = rho_0 / (1.0 + np.exp((r_grid - c_val) / a))\n            # Integrand for particle number\n            integrand = 4.0 * np.pi * r_grid**2 * rho_vals\n            # Numerical integration using Simpson's rule\n            return integrate.simpson(integrand, x=r_grid)\n\n        # Establish search bracket\n        c_min, c_max = 0.0, R_box\n        \n        # Calculate normalization at bracket boundaries\n        # Note: Integral is a monotonically decreasing function of c\n        norm_at_c_min = calculate_norm_at_c(c_min) # Max possible norm\n        norm_at_c_max = calculate_norm_at_c(c_max) # Min possible norm\n        \n        # Handle cases where the target cannot be bracketed\n        if N_target > norm_at_c_min:\n            # Box is too small to contain N_target particles.\n            # Return c_min to maximize the enclosed particle number.\n            return c_min\n        if N_target  norm_at_c_max:\n            # Integral is always larger than N_target.\n            # Return c_max to minimize the enclosed particle number.\n            return c_max\n\n        # Bisection search\n        max_iter = 100\n        for _ in range(max_iter):\n            c_mid = (c_min + c_max) / 2.0\n            \n            # Avoid infinite loops if float precision limit is reached\n            if c_mid == c_min or c_mid == c_max:\n                break\n            \n            norm_mid = calculate_norm_at_c(c_mid)\n            \n            # Check for convergence based on relative residual\n            if abs(norm_mid - N_target) / N_target  tol:\n                return c_mid\n            \n            # Update bracket\n            if norm_mid > N_target:\n                # I(c) too high, need to increase c to decrease I(c)\n                c_min = c_mid\n            else:\n                # I(c) too low, need to decrease c to increase I(c)\n                c_max = c_mid\n        \n        # Return best estimate if max iterations are reached\n        return (c_min + c_max) / 2.0\n\n    def calculate_rms_radius(c, dr, R_box, a, rho_0):\n        \"\"\"Computes the root-mean-square radius for a given density profile.\"\"\"\n        num_points = int(R_box / dr) + 1\n        r_grid = np.linspace(0.0, R_box, num_points)\n        \n        rho_vals = rho_0 / (1.0 + np.exp((r_grid - c) / a))\n        \n        # r^2 moment integrand\n        integrand_r2 = 4.0 * np.pi * r_grid**2 * rho_vals\n        # r^4 moment integrand\n        integrand_r4 = 4.0 * np.pi * r_grid**4 * rho_vals\n        \n        # Compute integrals\n        I_r2 = integrate.simpson(integrand_r2, x=r_grid)\n        I_r4 = integrate.simpson(integrand_r4, x=r_grid)\n        \n        if I_r2 = 0:\n            return 0.0\n            \n        return np.sqrt(I_r4 / I_r2)\n\n    def get_skin_thickness(dr, R_box, tol):\n        \"\"\"Orchestrates the calculation of the neutron skin thickness for one case.\"\"\"\n        c_n = find_c(dr, R_box, tol, N, a_n, rho_0_n)\n        c_p = find_c(dr, R_box, tol, Z, a_p, rho_0_p)\n        \n        r_rms_n = calculate_rms_radius(c_n, dr, R_box, a_n, rho_0_n)\n        r_rms_p = calculate_rms_radius(c_p, dr, R_box, a_p, rho_0_p)\n        \n        return r_rms_n - r_rms_p\n\n    #\n    # --- Convergence Study Execution ---\n    #\n\n    # Define reference case for high-accuracy benchmark\n    dr_ref = 0.005\n    R_box_ref = 25.0\n    tol_ref = 1.0e-12\n    delta_r_np_ref = get_skin_thickness(dr_ref, R_box_ref, tol_ref)\n\n    # Define the test suite\n    test_cases = [\n        # Case 1: dr, R_box, tol\n        (0.50, 9.0, 1.0e-2),\n        # Case 2\n        (0.10, 9.0, 1.0e-8),\n        # Case 3\n        (0.20, 14.0, 1.0e-6),\n        # Case 4\n        (0.10, 20.0, 1.0e-6),\n        # Case 5\n        (0.05, 16.0, 1.0e-4),\n        # Case 6\n        (0.05, 25.0, 1.0e-8),\n        # Case 7\n        (0.02, 25.0, 1.0e-10),\n        # Case 8\n        (0.01, 12.0, 1.0e-12),\n    ]\n\n    precision_threshold = 0.005  # fm\n    results = []\n    \n    for dr, R_box, tol in test_cases:\n        delta_r_np_case = get_skin_thickness(dr, R_box, tol)\n        deviation = abs(delta_r_np_case - delta_r_np_ref)\n        results.append(deviation = precision_threshold)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这项实践  将你带入现代核理论的前沿领域：基于第一性原理的不确定性量化。你将构建一个 $^{48}\\mathrm{Ca}$ 中子皮厚度的计算模拟器，该模拟器能够系统地处理源于手征有效场论（chiral Effective Field Theory）核力模型的不确定性。通过对模型参数（如低能常数）的概率分布进行蒙特卡洛抽样，你将学会如何不仅仅给出一个预测值，而是为物理观测量生成一个完整的后验概率分布，从而为理论预测提供可信度区间。",
            "id": "3573318",
            "problem": "你的任务是构建一个计算模拟器，在一个遵循有效场论（EFT）误差传播的有原则的不确定性框架内，量化一个中等质量原子核的中子皮厚度。可观测量是钙-48（$^{48}\\mathrm{Ca}$）的中子皮厚度，表示为$\\Delta r_{np}(^{48}\\mathrm{Ca})$，定义为中子和质子均方根半径之差，即$\\Delta r_{np} = \\sqrt{\\langle r_n^2 \\rangle} - \\sqrt{\\langle r_p^2 \\rangle}$。该模拟器必须嵌入尺度分离和手性有效场论（EFT）的逐阶组织，并模拟由价空间介质内相似性重整化群（VS-IMSRG）计算到已知阶的贡献，同时概率性地处理被忽略的更高阶项。你的任务是从第一性原理出发形式化此问题，并实现一个程序，以在指定场景下生成一个可复现的$\\Delta r_{np}$后验总结。\n\n基本基础、假设和结构：\n\n1. 采用手性有效场论（EFT）的组织原则：一个可观测量$X$允许在一个小参数$Q$上进行低动量展开，形式为$X(Q) = \\sum_{n=0}^{\\infty} c_n Q^n$，其中$Q = p/\\Lambda_b$，$p$是特征动量，$\\Lambda_b$是EFT破缺尺度。系数$c_n$是有量纲的，并且在适当缩放后被假定为“自然的”（在EFT归一化单位下为1的量级）。在实践中，该级数被截断，这会引入一个由被忽略的、阶数高于最大包含阶的项主导的截断误差。\n\n2. 将$^{48}\\mathrm{Ca}$的预测中子皮厚度模型化为\n$$\n\\Delta r_{np} = b_0 + b_L \\, L + b_{LL} \\, L^2 + \\sum_{n=0}^{N_{\\mathrm{avail}}} \\bar{c}_n \\, Q^n + \\sum_{n=N_{\\mathrm{avail}}+1}^{\\infty} c_n \\, Q^n,\n$$\n其中$L$是对称能斜率参数，单位为兆电子伏特（MeV），$b_0$、$b_L$和$b_{LL}$是模拟器系数，近似VS-IMSRG对同位旋矢量物理的基线敏感度，$\\bar{c}_n$是已知的包含阶贡献（模拟在已计算阶上的VS-IMSRG结果），而对于$n  N_{\\mathrm{avail}}$的$c_n$是未知的更高阶系数，进行概率性建模。这种分解强制了计算贡献与EFT截断不确定性之间的分离。所有贡献的单位都与$\\Delta r_{np}$的单位飞米（femtometers）保持一致。\n\n3. 通过一个最小线性化映射，将控制同位旋矢量物理的低能常数（LECs）映射到对称能斜率参数$L$。引入两个同位旋矢量LECs，$C_1$和$C_2$，它们具有独立的高斯先验：\n$$\nC_1 \\sim \\mathcal{N}(\\mu_1, \\sigma_1^2), \\quad C_2 \\sim \\mathcal{N}(\\mu_2, \\sigma_2^2).\n$$\n定义到$L$的线性映射为\n$$\nL = \\kappa_1 C_1 + \\kappa_2 C_2,\n$$\n其中$\\kappa_1$和$\\kappa_2$是单位为兆电子伏特的常数。该映射编码了对同位旋矢量耦合的一阶敏感度。\n\n4. 对未知的高阶系数使用经过充分检验的EFT自然性假设：\n$$\nc_n \\stackrel{\\mathrm{iid}}{\\sim} \\mathcal{N}(0, \\sigma_c^2),\n$$\n在$n$上独立，且与$(C_1, C_2)$独立。这会产生一个高斯截断尾部，其方差随$Q$的增加而增加，随包含阶数$N_{\\mathrm{avail}}$的增加而减少。将无限尾部实现为一个到较大阶数$N_{\\mathrm{tail}}$的有限和，以确保数值收敛。\n\n5. 为保证科学合理性与单位一致性，使用以下模拟器常数：\n- 模拟器敏感度系数，单位为飞米和混合单位：\n$$\nb_0 = 0.10 \\,\\mathrm{fm}, \\quad b_L = 0.0005 \\,\\mathrm{fm/MeV}, \\quad b_{LL} = 1.0 \\times 10^{-6} \\,\\mathrm{fm/MeV}^2.\n$$\n- 同位旋矢量LEC先验均值和标准差（无量纲）：\n$$\n\\mu_1 = 1.0, \\quad \\sigma_1 = 0.2; \\quad \\mu_2 = 0.0, \\quad \\sigma_2 = 0.3.\n$$\n- 线性映射系数：\n$$\n\\kappa_1 = 60.0 \\,\\mathrm{MeV}, \\quad \\kappa_2 = 20.0 \\,\\mathrm{MeV}.\n$$\n- 已包含阶的模拟器贡献（已知的类VS-IMSRG项，单位为飞米）：\n$$\n\\bar{c}_0 = 0.015 \\,\\mathrm{fm}, \\quad \\bar{c}_1 = -0.005 \\,\\mathrm{fm}, \\quad \\bar{c}_2 = 0.003 \\,\\mathrm{fm}, \\quad \\bar{c}_3 = 0.000 \\,\\mathrm{fm}, \\quad \\bar{c}_4 = -0.001 \\,\\mathrm{fm}.\n$$\n- 未知高阶系数的自然性尺度：\n$$\n\\sigma_c = 0.02 \\,\\mathrm{fm}.\n$$\n\n6. 算法要求：\n- 从它们的高斯先验中对$(C_1, C_2)$进行蒙特卡洛采样，并对$n \\in \\{N_{\\mathrm{avail}}+1, \\ldots, N_{\\mathrm{avail}} + N_{\\mathrm{tail}}\\}$的$c_n$从$\\mathcal{N}(0, \\sigma_c^2)$中进行采样。\n- 对于每个样本，计算$L$，计算基线VS-IMSRG模拟器$b_0 + b_L L + b_{LL} L^2$，加上已知的包含阶总和$\\sum_{n=0}^{N_{\\mathrm{avail}}} \\bar{c}_n Q^n$，并加上采样的截断尾部$\\sum_{n=N_{\\mathrm{avail}}+1}^{N_{\\mathrm{avail}}+N_{\\mathrm{tail}}} c_n Q^n$，以组装一个$\\Delta r_{np}$的样本。\n- 为保证可复现性，使用固定的随机种子。\n\n7. 统计总结与输出规范：\n- 对于每个测试案例，计算$\\Delta r_{np}$的后验均值和中心$68\\%$置信半宽度，定义为$\\frac{1}{2}(q_{0.84} - q_{0.16})$，其中$q_{p}$表示蒙特卡洛样本的$p$-分位数。\n- 所有结果以飞米表示，四舍五入到三位小数。\n\n测试套件：\n在以下场景下评估模拟器，每个场景由$(Q, N_{\\mathrm{avail}}, N_{\\mathrm{tail}}, N_{\\mathrm{samples}})$指定：\n- 案例1：$(Q = 0.35, \\, N_{\\mathrm{avail}} = 3, \\, N_{\\mathrm{tail}} = 50, \\, N_{\\mathrm{samples}} = 20000)$。\n- 案例2：$(Q = 0.50, \\, N_{\\mathrm{avail}} = 2, \\, N_{\\mathrm{tail}} = 50, \\, N_{\\mathrm{samples}} = 20000)$。\n- 案例3：$(Q = 0.25, \\, N_{\\mathrm{avail}} = 4, \\, N_{\\mathrm{tail}} = 50, \\, N_{\\mathrm{samples}} = 20000)$。\n- 案例4：$(Q = 0.55, \\, N_{\\mathrm{avail}} = 1, \\, N_{\\mathrm{tail}} = 50, \\, N_{\\mathrm{samples}} = 20000)$。\n\n最终输出格式：\n你的程序应生成一行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个测试案例由一个包含两个浮点数$[\\mathrm{mean}, \\mathrm{half\\_width}]$的列表表示，单位为飞米，每个浮点数四舍五入到三位小数。例如，输出必须看起来像\n$[[0.123,0.015],[0.120,0.018],[0.130,0.012],[0.135,0.020]]$。",
            "solution": "用户提供了一个在计算核物理领域中定义明确的问题，该问题涉及使用一个源自手性有效场论（EFT）的模型来模拟$^{48}\\mathrm{Ca}$的中子皮厚度。我将着手进行详细的、分步的解答。\n\n问题是计算四种不同场景下中子皮厚度$\\Delta r_{np}$的后验均值和$68\\%$中心置信半宽度。$\\Delta r_{np}$的模型是一个复合模型，它结合了一个依赖于核对称能斜率参数$L$的基线模型、一个来自EFT展开的已知贡献之和，以及一个代表EFT截断误差的概率项。\n\n模型由以下公式给出：\n$$\n\\Delta r_{np} = \\underbrace{b_0 + b_L \\, L + b_{LL} \\, L^2}_{\\text{基线 (来自 }L\\text{)}} + \\underbrace{\\sum_{n=0}^{N_{\\mathrm{avail}}} \\bar{c}_n \\, Q^n}_{\\text{已知EFT项}} + \\underbrace{\\sum_{n=N_{\\mathrm{avail}}+1}^{N_{\\mathrm{avail}}+N_{\\mathrm{tail}}} c_n \\, Q^n}_{\\text{EFT截断误差}}\n$$\n其中，截断误差的无限和被一个截断到足够高阶$N_{\\mathrm{avail}}+N_{\\mathrm{tail}}$的有限和所近似。该模型中的参数来源于不同的分布，反映了它们各自的不确定性。\n\n参数$L$，即对称能斜率，不是直接采样的。相反，它由两个底层的无量纲低能常数（LECs）$C_1$和$C_2$通过一个线性映射确定：\n$$\nL = \\kappa_1 C_1 + \\kappa_2 C_2\n$$\nLECs本身被视为从高斯先验中抽取的独立随机变量：\n$$\nC_1 \\sim \\mathcal{N}(\\mu_1, \\sigma_1^2), \\quad C_2 \\sim \\mathcal{N}(\\mu_2, \\sigma_2^2)\n$$\n问题指定了均值（$\\mu_1, \\mu_2$）、标准差（$\\sigma_1, \\sigma_2$）和线性映射系数（$\\kappa_1, \\kappa_2$）的值。\n\nEFT展开中未知高阶项（$n  N_{\\mathrm{avail}}$）的系数$c_n$被建模为独立同分布的随机变量，这与EFT的自然性假设一致。它们从一个零均值高斯分布中抽取：\n$$\nc_n \\stackrel{\\mathrm{iid}}{\\sim} \\mathcal{N}(0, \\sigma_c^2)\n$$\n给定了标准差$\\sigma_c$，它代表了这些系数在自然单位下的预期大小（此处以飞米为单位指定）。\n\n模型中的其余量对于任何给定的测试案例都是确定性常数：基线系数（$b_0, b_L, b_{LL}$）、展开参数$Q$、已知的EFT系数（$\\bar{c}_n$直到阶$N_{\\mathrm{avail}}$）以及截断阶数$N_{\\mathrm{avail}}$。\n\n计算策略是执行蒙特卡洛模拟。对于每个测试案例，我们将从$\\Delta r_{np}$的后验预测分布中生成大量样本（$N_{\\mathrm{samples}}$）。$\\Delta r_{np}$的单个样本构建如下：\n1. 从$\\mathcal{N}(\\mu_1, \\sigma_1^2)$中抽取一个$C_1$样本，从$\\mathcal{N}(\\mu_2, \\sigma_2^2)$中抽取一个$C_2$样本。\n2. 使用线性映射计算相应的$L$值。\n3. 计算基线贡献，$b_0 + b_L L + b_{LL} L^2$。\n4. 为未知系数$c_n$（对于$n = N_{\\mathrm{avail}}+1, \\dots, N_{\\mathrm{avail}}+N_{\\mathrm{tail}}$）抽取$N_{\\mathrm{tail}}$个样本，每个样本均来自$\\mathcal{N}(0, \\sigma_c^2)$。\n5. 通过将这些抽样系数与$Q$的适当次幂相乘并求和，计算截断误差贡献，即$\\sum_{n=N_{\\mathrm{avail}}+1}^{N_{\\mathrm{avail}}+N_{\\mathrm{tail}}} c_n Q^n$。\n6. 来自已知EFT阶的确定性部分$\\sum_{n=0}^{N_{\\mathrm{avail}}} \\bar{c}_n Q^n$，对每个测试案例只计算一次。\n7. 将这三个分量（基线、已知EFT、截断误差）相加，得到一个$\\Delta r_{np}$的样本。\n\n这个过程重复$N_{\\mathrm{samples}}$次。为提高效率，此过程将使用`numpy`进行向量化。我们可以一次性生成所有$N_{\\mathrm{samples}}$个$C_1$和$C_2$的样本，从而产生$L$值和基线贡献的数组。同样，我们可以生成一个$N_{\\mathrm{samples}} \\times N_{\\mathrm{tail}}$的$c_n$样本矩阵，并使用矩阵-向量积来同时计算所有样本的截断误差项。\n\n一旦生成了包含$N_{\\mathrm{samples}}$个$\\Delta r_{np}$样本的数组，我们计算两个汇总统计量：\n1. 后验均值，即样本的算术平均值：$\\langle \\Delta r_{np} \\rangle = \\frac{1}{N_{\\mathrm{samples}}} \\sum_{i=1}^{N_{\\mathrm{samples}}} (\\Delta r_{np})_i$。\n2. 中心$68\\%$置信半宽度。这需要找到样本分布的第$16$和第$84$百分位数，分别表示为$q_{0.16}$和$q_{0.84}$。半宽度则由$\\frac{1}{2}(q_{0.84} - q_{0.16})$给出。\n\n对指定的四个测试案例中的每一个都重复整个过程，这些案例在展开参数$Q$和包含的EFT阶数$N_{\\mathrm{avail}}$的值上有所不同。最终结果将四舍五入到三位小数，并以指定的列表格式呈现。将使用一个固定的随机种子来确保结果的数值可复现性。\n\n物理常数和模型参数如下：\n- $b_0 = 0.10$ fm\n- $b_L = 0.0005$ fm/MeV\n- $b_{LL} = 1.0 \\times 10^{-6}$ fm/MeV$^2$\n- $\\mu_1 = 1.0$, $\\sigma_1 = 0.2$\n- $\\mu_2 = 0.0$, $\\sigma_2 = 0.3$\n- $\\kappa_1 = 60.0$ MeV\n- $\\kappa_2 = 20.0$ MeV\n- $\\bar{c} = [0.015, -0.005, 0.003, 0.000, -0.001]$ fm\n- $\\sigma_c = 0.02$ fm\n\n这些将在实现中硬编码。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the posterior mean and 68% credible half-width for the neutron\n    skin thickness of 48Ca using an EFT-based emulator.\n    \"\"\"\n    # Set a fixed random seed for reproducibility.\n    np.random.seed(42)\n\n    # Define the constants from the problem statement.\n    # Emulator sensitivity coefficients\n    b0 = 0.10  # fm\n    bL = 0.0005  # fm/MeV\n    bLL = 1.0e-6  # fm/MeV^2\n\n    # Isovector LEC prior means and standard deviations (dimensionless)\n    mu1, sigma1 = 1.0, 0.2\n    mu2, sigma2 = 0.0, 0.3\n\n    # Linear map coefficients\n    kappa1 = 60.0  # MeV\n    kappa2 = 20.0  # MeV\n\n    # Included-order emulator contributions (fm)\n    c_bar = np.array([0.015, -0.005, 0.003, 0.000, -0.001])\n\n    # Naturalness scale for unknown higher-order coefficients\n    sigma_c = 0.02  # fm\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Q, N_avail, N_tail, N_samples)\n        (0.35, 3, 50, 20000),\n        (0.50, 2, 50, 20000),\n        (0.25, 4, 50, 20000),\n        (0.55, 1, 50, 20000),\n    ]\n\n    results = []\n    for Q, N_avail, N_tail, N_samples in test_cases:\n        # Perform Monte Carlo simulation for a single case.\n        \n        # 1. Sample LECs and compute L, the symmetry-energy slope.\n        C1_samples = np.random.normal(mu1, sigma1, N_samples)\n        C2_samples = np.random.normal(mu2, sigma2, N_samples)\n        L_samples = kappa1 * C1_samples + kappa2 * C2_samples\n        \n        # 2. Compute the baseline contribution to delta_r_np.\n        baseline_samples = b0 + bL * L_samples + bLL * L_samples**2\n        \n        # 3. Compute the deterministic contribution from known EFT orders.\n        # This is a scalar value for a given case.\n        known_orders = np.arange(0, N_avail + 1)\n        Q_powers_known = Q**known_orders\n        c_bar_known = c_bar[:N_avail + 1]\n        known_eft_term = np.dot(c_bar_known, Q_powers_known)\n        \n        # 4. Compute the probabilistic contribution from EFT truncation error.\n        # Orders for the truncation tail\n        trunc_orders = np.arange(N_avail + 1, N_avail + N_tail + 1)\n        Q_powers_trunc = Q**trunc_orders # Vector of shape (N_tail,)\n        \n        # Sample coefficients c_n ~ N(0, sigma_c^2)\n        c_n_samples = np.random.normal(0, sigma_c, size=(N_samples, N_tail))\n        \n        # Compute the sum for each Monte Carlo sample via matrix-vector product\n        trunc_error_samples = c_n_samples @ Q_powers_trunc\n        \n        # 5. Assemble the total delta_r_np for all samples.\n        dr_np_samples = baseline_samples + known_eft_term + trunc_error_samples\n        \n        # 6. Compute summary statistics.\n        # Posterior mean\n        mean_dr_np = np.mean(dr_np_samples)\n        \n        # Central 68% credible half-width\n        q16, q84 = np.quantile(dr_np_samples, [0.16, 0.84])\n        half_width = 0.5 * (q84 - q16)\n        \n        # Round results and append to the list.\n        results.append([round(mean_dr_np, 3), round(half_width, 3)])\n\n    # Format the final output string as specified.\n    # e.g., [[0.123, 0.015], [0.120, 0.018], ...]\n    result_str = \",\".join([f\"[{m},{w}]\" for m, w in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}