{
    "hands_on_practices": [
        {
            "introduction": "Before analyzing complex signals, we must grasp their physical origin. This foundational exercise guides you through the derivation of the famous quadrupole formula from the first principles of linearized General Relativity, revealing how accelerating mass distributions generate gravitational waves. You will then apply this formula to make a practical, order-of-magnitude estimate of the gravitational-wave strain from a typical binary neutron star, connecting abstract theory to a tangible observable .",
            "id": "3562196",
            "problem": "Consider an isolated, slowly moving, spatially compact source in linearized General Relativity (GR) under the Lorenz gauge condition. In the radiation (far) zone, the metric perturbation is treated in the transverse-traceless (TT) gauge. Starting from the retarded Green’s function solution of the linearized Einstein field equations and energy-momentum conservation for a nonrelativistic source, derive the leading-order far-zone expression connecting the TT metric perturbation to the second time derivative of the trace-free mass quadrupole moment evaluated at the retarded time. Clearly define the mass quadrupole moment and the TT projection used.\n\nThen specialize to a quasi-circular equal-mass neutron-star binary with component gravitational masses $m_{1}=m_{2}=1.4\\,M_{\\odot}$. Assume a circular orbit, negligible spin and tidal effects at the quoted frequency, and an optimally oriented source-detector geometry (face-on with respect to the orbital angular momentum). Let the observed gravitational-wave frequency be $f=100\\,\\mathrm{Hz}$, so that the orbital angular frequency satisfies $\\Omega=\\pi f$. Work in geometric units $G=c=1$ throughout. Express the leading-order gravitational-wave strain amplitude in terms of the chirp mass $M_{c}$, the frequency $f$, and the luminosity distance $D$, and then estimate the numerical value of the instantaneous dimensionless strain amplitude for a source at $D=100\\,\\mathrm{Mpc}$.\n\nUse the following numerical conversions consistent with $G=c=1$:\n- $M_{\\odot} = 4.92549095\\times 10^{-6}\\,\\mathrm{s}$,\n- $1\\,\\mathrm{Mpc} = 1.02927125\\times 10^{14}\\,\\mathrm{s}$.\n\nRound your final answer to three significant figures and express it as a dimensionless number (no units).",
            "solution": "### Part 1: Derivation of the Quadrupole Formula\n\nWe begin with the linearized Einstein Field Equations in the Lorenz gauge ($\\partial_\\mu \\bar{h}^{\\mu\\nu} = 0$), expressed in geometric units ($G=c=1$):\n$$ \\Box \\bar{h}_{\\mu\\nu} = -16\\pi T_{\\mu\\nu} $$\nwhere $\\Box = -\\partial_t^2 + \\nabla^2$ is the d'Alembert operator, $T_{\\mu\\nu}$ is the energy-momentum tensor of the source, and $\\bar{h}_{\\mu\\nu} = h_{\\mu\\nu} - \\frac{1}{2}\\eta_{\\mu\\nu}h$ is the trace-reversed metric perturbation.\n\nThe solution to this wave equation can be found using the retarded Green's function:\n$$ \\bar{h}_{\\mu\\nu}(t, \\mathbf{x}) = 4 \\int \\frac{T_{\\mu\\nu}(t - |\\mathbf{x}-\\mathbf{x'}|, \\mathbf{x'})}{|\\mathbf{x}-\\mathbf{x'}|} d^3x' $$\nWe consider a detector in the far zone, where its distance $r=|\\mathbf{x}|$ from the source is much larger than the source's size, $|\\mathbf{x'}|$. We can make the following approximations:\n1.  $|\\mathbf{x}-\\mathbf{x'}| \\approx r$ in the denominator.\n2.  $|\\mathbf{x}-\\mathbf{x'}| = \\sqrt{r^2 - 2\\mathbf{x}\\cdot\\mathbf{x'} + r'^2} \\approx r\\sqrt{1-2\\frac{\\mathbf{x}\\cdot\\mathbf{x'}}{r^2}} \\approx r - \\hat{n}\\cdot\\mathbf{x'}$ in the time argument, where $\\hat{n} = \\mathbf{x}/r$ is the direction of observation.\n3.  For a slowly moving source (velocities $v \\ll 1$), changes in the source occur over timescales much longer than the light-crossing time of the source. Thus, we can neglect the term $\\hat{n}\\cdot\\mathbf{x'}$ in the time argument, simplifying it to the retarded time $t_r = t - r$.\n\nWith these approximations, the spatial components of the metric perturbation become:\n$$ \\bar{h}_{ij}(t, \\mathbf{x}) \\approx \\frac{4}{r} \\int T_{ij}(t_r, \\mathbf{x'}) d^3x' $$\nWe need to relate the integral of the stress tensor $T_{ij}$ to the mass distribution. This is achieved using the conservation of energy-momentum, $\\partial_\\mu T^{\\mu\\nu} = 0$. For a non-relativistic source, we use the identity:\n$$ \\frac{d^2}{dt^2} \\int T^{00} x^i x^j d^3x' = 2 \\int T^{ij} d^3x' $$\nIn the non-relativistic limit, the energy density $T^{00}$ is dominated by the mass density $\\rho$. Let's define the second moment of the mass distribution (the mass quadrupole moment tensor) as:\n$$ I_{ij}(t) = \\int \\rho(t, \\mathbf{x'}) x'_i x'_j d^3x' $$\nThen, $\\int T_{ij}(t_r) d^3x' \\approx \\frac{1}{2} \\ddot{I}_{ij}(t_r)$, where the double dot denotes the second time derivative. Substituting this into the expression for $\\bar{h}_{ij}$ gives:\n$$ \\bar{h}_{ij}(t, \\mathbf{x}) \\approx \\frac{2}{r} \\ddot{I}_{ij}(t_r) $$\nThe physically observable gravitational wave strain is the transverse-traceless (TT) part of the metric perturbation, $h_{ij}^{TT}$. The TT projection is achieved using the operator $\\Lambda_{ij,kl}(\\hat{n}) = P_{ik}P_{jl} - \\frac{1}{2}P_{ij}P_{kl}$, where $P_{ij} = \\delta_{ij} - n_i n_j$ is the projector onto the plane transverse to the direction of propagation $\\hat{n}$. The TT part of any tensor is transverse ($n^i A_{ij}^{TT} = 0$) and traceless ($A_{ii}^{TT} = 0$).\n\nThe TT part of the metric perturbation is given by $h_{ij}^{TT} = \\Lambda_{ij,kl}(\\hat{n}) h_{kl}$. In the far zone radiation gauge, $h_{ij} = \\bar{h}_{ij}$ up to gauge transformations that do not affect the physical strain. Thus, we project $\\bar{h}_{ij}$:\n$$ h_{ij}^{TT}(t, \\mathbf{x}) = \\frac{2}{r} \\Lambda_{ij,kl}(\\hat{n})\\ddot{I}_{kl}(t_r) $$\nThe problem asks for the relationship with the *trace-free* mass quadrupole moment, defined as:\n$$ Q_{ij}(t) = \\int \\rho(t, \\mathbf{x'}) \\left(x'_i x'_j - \\frac{1}{3}\\delta_{ij}|\\mathbf{x'}|^2\\right) d^3x' = I_{ij} - \\frac{1}{3}\\delta_{ij}I_{kk} $$\nOne can show that $\\Lambda_{ij,kl}\\ddot{I}_{kl} = \\Lambda_{ij,kl}\\ddot{Q}_{kl}$, because the projector $\\Lambda_{ij,kl}$ annihilates any trace part. Therefore, the expression can be written in terms of $\\ddot{Q}_{kl}$. Adopting the luminosity distance $D$ for $r$, we arrive at the desired expression:\n$$ h_{ij}^{TT}(t, \\mathbf{x}) = \\frac{2}{D} \\Lambda_{ij,kl}(\\hat{n}) \\ddot{Q}_{kl}(t-D) $$\nThis expression connects the TT metric perturbation to the second time derivative of the trace-free mass quadrupole moment, evaluated at the retarded time.\n\n### Part 2: Application to a Binary Neutron Star System\n\nWe now specialize to the given binary system. For a quasi-circular orbit in the $x$-$y$ plane with orbital angular frequency $\\Omega$, the positions of the two equal masses $m_1=m_2=m=1.4\\,M_{\\odot}$ relative to the center of mass are $\\mathbf{x}_1 = (R/2)(\\cos(\\Omega t), \\sin(\\Omega t), 0)$ and $\\mathbf{x}_2 = -\\mathbf{x}_1$. The total separation is $R$.\nThe mass quadrupole moment is $I_{ij} = \\sum_a m_a x_{a,i} x_{a,j} = m(x_{1,i}x_{1,j} + x_{2,i}x_{2,j}) = 2m x_{1,i}x_{1,j}$.\nA more convenient form uses the reduced mass $\\mu = m_1 m_2 / (m_1+m_2) = m/2 = 0.7\\,M_{\\odot}$ and the relative separation vector $\\mathbf{R} = \\mathbf{x}_1 - \\mathbf{x}_2 = (R\\cos(\\Omega t), R\\sin(\\Omega t), 0)$. Then $I_{ij} = \\mu R_i R_j$.\n$$ I_{ij}(t) = \\mu R^2 \\begin{pmatrix} \\cos^2(\\Omega t) & \\cos(\\Omega t)\\sin(\\Omega t) & 0 \\\\ \\cos(\\Omega t)\\sin(\\Omega t) & \\sin^2(\\Omega t) & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} $$\nThe second time derivative is:\n$$ \\ddot{I}_{ij}(t) = 2\\mu R^2 \\Omega^2 \\begin{pmatrix} -\\cos(2\\Omega t) & -\\sin(2\\Omega t) \\\\ -\\sin(2\\Omega t) & \\cos(2\\Omega t) \\end{pmatrix} $$\nThis tensor is already trace-free, so $\\ddot{Q}_{ij} = \\ddot{I}_{ij}$.\nFor a face-on orientation, the observer is along the $z$-axis, so $\\hat{n}=(0,0,1)$. The projection tensor $P_{ij}$ is the identity on the $x-y$ plane. As $\\ddot{I}_{ij}$ is already transverse and traceless in this plane, the TT projection does not change it: $\\ddot{I}_{ij}^{TT} = \\ddot{I}_{ij}$.\nHence, $h_{ij}^{TT} = \\frac{2}{D}\\ddot{I}_{ij}$. The two gravitational wave polarizations are:\n$$ h_+(t_r) = h_{11}^{TT} = -\\frac{4\\mu R^2\\Omega^2}{D} \\cos(2\\Omega t_r) $$\n$$ h_\\times(t_r) = h_{12}^{TT} = -\\frac{4\\mu R^2\\Omega^2}{D} \\sin(2\\Omega t_r) $$\nThe instantaneous strain amplitude $h_0$ is the amplitude of these oscillations:\n$$ h_0 = \\frac{4\\mu R^2\\Omega^2}{D} $$\nWe use Kepler's third law in geometric units, $M = \\Omega^2 R^3$, where $M=m_1+m_2$ is the total mass. This gives $R^2 = (M/\\Omega^2)^{2/3}$.\n$$ h_0 = \\frac{4\\mu}{D} \\left(\\frac{M}{\\Omega^2}\\right)^{2/3} \\Omega^2 = \\frac{4\\mu M^{2/3}\\Omega^{2/3}}{D} $$\nThe gravitational wave frequency is $f=2f_{orb}$. The orbital angular frequency is $\\Omega=2\\pi f_{orb}$. Thus $\\Omega = \\pi f$, as given. We substitute this into the amplitude expression:\n$$ h_0 = \\frac{4\\mu M^{2/3}(\\pi f)^{2/3}}{D} $$\nTo express this in terms of the chirp mass $M_c = \\mu^{3/5}M^{2/5}$, we note that $\\mu M^{2/3} = (\\mu^{3/5}M^{2/5})^{5/3} = M_c^{5/3}$.\nSubstituting this gives the final expression for the strain amplitude:\n$$ h_0 = \\frac{4 M_c^{5/3}(\\pi f)^{2/3}}{D} = \\frac{4 M_c}{D}(\\pi f M_c)^{2/3} $$\n\n### Numerical Calculation\n\nWe are given:\n-   $m_1=m_2=1.4\\,M_{\\odot}$\n-   $f=100\\,\\mathrm{Hz} = 100\\,\\mathrm{s}^{-1}$\n-   $D=100\\,\\mathrm{Mpc}$\n-   $G=c=1$ conversions: $M_{\\odot} = 4.92549095\\times 10^{-6}\\,\\mathrm{s}$ and $1\\,\\mathrm{Mpc} = 1.02927125\\times 10^{14}\\,\\mathrm{s}$.\n\nFirst, calculate the chirp mass $M_c$:\nFor equal masses $m_1=m_2=m$, $M_c = \\frac{(m^2)^{3/5}}{(2m)^{1/5}} = m \\cdot 2^{-1/5}$.\n$ M_c = (1.4\\,M_\\odot) \\cdot 2^{-1/5} \\approx 1.21873\\,M_\\odot $\n\nConvert $M_c$ and $D$ to units of seconds:\n$ M_c = 1.21873 \\times (4.92549095\\times 10^{-6}\\,\\mathrm{s}) = 6.00280 \\times 10^{-6}\\,\\mathrm{s} $\n$ D = 100 \\times (1.02927125\\times 10^{14}\\,\\mathrm{s}) = 1.02927125 \\times 10^{16}\\,\\mathrm{s} $\n\nNow we calculate the dimensionless term $(\\pi f M_c)$:\n$ \\pi f M_c = \\pi \\times (100\\,\\mathrm{s}^{-1}) \\times (6.00280 \\times 10^{-6}\\,\\mathrm{s}) \\approx 0.00188584 $\n\nNext, we compute the strain amplitude $h_0$:\n$$ h_0 = \\frac{4 M_c}{D}(\\pi f M_c)^{2/3} $$\n$$ h_0 = \\frac{4 \\times (6.00280 \\times 10^{-6})}{1.02927125 \\times 10^{16}} \\times (0.00188584)^{2/3} $$\n$$ h_0 = (2.33281 \\times 10^{-21}) \\times (0.0152636) $$\n$$ h_0 = 3.5610 \\times 10^{-23} $$\nRounding to three significant figures, the instantaneous strain amplitude is $3.56 \\times 10^{-23}$.",
            "answer": "$$\\boxed{3.56 \\times 10^{-23}}$$"
        },
        {
            "introduction": "Extracting physical information from a signal buried in noise is a central challenge in gravitational-wave astronomy. This practice introduces the powerful framework of Bayesian inference to quantitatively answer a critical scientific question: is there evidence for tidal effects in the data? By comparing a simple point-particle model against one that includes the tidal deformability of neutron stars, you will learn to compute the Bayes factor and understand how we use it to probe the nuclear equation of state .",
            "id": "3562203",
            "problem": "Consider a simplified, first-principles model comparison for gravitational-wave inspiral data from a binary neutron star system, focusing on whether tidal effects are supported by the data. Work entirely in a whitened, two-dimensional sufficient-statistics space constructed from orthonormal templates. Let the data vector be $s = (x, y)$, where $x$ is the matched-filter projection onto a point-particle template and $y$ is the matched-filter projection onto a leading-order tidal correction template. Assume zero-mean Gaussian detector noise with unit variance per component, independent across $x$ and $y$. Under both models, the point-particle amplitude parameter $a$ enters linearly in the $x$-direction, and under the tidal model an additional tidal parameter $\\lambda$ enters linearly in the $y$-direction. Adopt zero-mean Gaussian priors $a \\sim \\mathcal{N}(0, \\sigma_a^2)$ and $\\lambda \\sim \\mathcal{N}(0, \\sigma_\\lambda^2)$ that reflect realistic astrophysical and nuclear equation-of-state uncertainties over the effective projections in this whitened basis. The point-particle model excludes the tidal parameter (equivalently, fixes $\\lambda$ to $0$ a priori). The tidal model includes both $a$ and $\\lambda$ with the specified priors. Assume that $x$ and $y$ are sufficient statistics so that likelihoods factorize over these components given the parameters. You must do the following: \n- Starting from the assumptions above, derive the Bayesian evidence for each model by integrating the Gaussian likelihood over the Gaussian priors, and construct the Bayes factor in favor of the tidal model over the point-particle model as a function of $y$ and $\\sigma_\\lambda$. \n- Define the signal-to-noise ratio (SNR) for the tidal effect as the absolute value of $y$ in this whitened basis, which is dimensionless. Using a decision threshold Bayes factor $B_0 = 100$ (interpreted as “decisive” support), derive an explicit expression for the minimal tidal SNR $y_\\star(\\sigma_\\lambda)$ required so that the Bayes factor in favor of the tidal model is at least $B_0$. Express $y_\\star$ as a positive real number without units. \n- Implement a program that, for a set of test cases, computes: \n    $1)$ the Bayes factor for given $(\\sigma_\\lambda, y)$, and \n    $2)$ the threshold tidal SNR $y_\\star$ for the same $\\sigma_\\lambda$ at $B_0 = 100$. \nUse the following test suite (each tuple is $(\\sigma_\\lambda, y)$): \n- Test $1$: $(1.0, 0.0)$, \n- Test $2$: $(1.5, 3.0)$, \n- Test $3$: $(3.0, 6.0)$. \nYour program must compute six floating-point outputs: the three Bayes factors for the tests above followed by the three corresponding SNR thresholds $y_\\star$ (one for each $\\sigma_\\lambda$ from the same list), in that order. All six outputs must be rounded to six decimal places and printed on a single line as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5,r_6]$. All quantities are dimensionless; do not include any physical units or percentage signs. Angles are not used and need not be reported in radians or degrees.",
            "solution": "The problem requires the derivation and computation of the Bayesian evidence for two competing models of a gravitational wave signal from a binary neutron star merger, the construction of the Bayes factor, and the determination of a detection threshold for tidal effects.\n\n### Model Definitions and Bayesian Framework\n\nLet the observed data vector in the whitened sufficient-statistics space be $s=(x, y)$. The detector noise is assumed to be zero-mean Gaussian with unit variance and independent in each component. We compare two models: the point-particle model ($\\mathcal{M}_P$) and the tidal model ($\\mathcal{M}_T$).\n\nThe likelihood, which is the probability of the data given the model parameters, follows from the noise model. If the true signal is $\\mu(\\theta)$, where $\\theta$ represents the model parameters, then the data $s = \\mu(\\theta) + n$, where $n \\sim \\mathcal{N}(0, I_2)$ is the noise vector and $I_2$ is the $2 \\times 2$ identity matrix. Thus, the likelihood is $p(s|\\theta, \\mathcal{M}) = \\mathcal{N}(s|\\mu(\\theta), I_2)$. Given the independence of the components, this factorizes into $p(x, y | \\theta, \\mathcal{M}) = p(x|\\theta, \\mathcal{M}) p(y|\\theta, \\mathcal{M})$.\n\n**Model 1: Point-Particle ($\\mathcal{M}_P$)**\nUnder this model, the signal has no tidal component, so the mean signal is $\\mu_P = (a, 0)$. The parameter is $a$, the point-particle amplitude. The likelihood is:\n$$p(x, y | a, \\mathcal{M}_P) = \\mathcal{N}(x|a, 1) \\mathcal{N}(y|0, 1) = \\frac{1}{2\\pi} \\exp\\left(-\\frac{(x-a)^2}{2} - \\frac{y^2}{2}\\right)$$\nThe prior on the parameter $a$ is given as a zero-mean Gaussian: $p(a|\\mathcal{M}_P) = \\mathcal{N}(a|0, \\sigma_a^2)$.\n\n**Model 2: Tidal ($\\mathcal{M}_T$)**\nUnder this model, a tidal component is present. The mean signal is $\\mu_T = (a, \\lambda)$, where $\\lambda$ is the tidal parameter. The parameters are $\\theta = \\{a, \\lambda\\}$. The likelihood is:\n$$p(x, y | a, \\lambda, \\mathcal{M}_T) = \\mathcal{N}(x|a, 1) \\mathcal{N}(y|\\lambda, 1) = \\frac{1}{2\\pi} \\exp\\left(-\\frac{(x-a)^2}{2} - \\frac{(y-\\lambda)^2}{2}\\right)$$\nThe priors on the parameters are independent zero-mean Gaussians: $p(a|\\mathcal{M}_T) = \\mathcal{N}(a|0, \\sigma_a^2)$ and $p(\\lambda|\\mathcal{M}_T) = \\mathcal{N}(\\lambda|0, \\sigma_\\lambda^2)$.\n\n### Derivation of the Bayesian Evidence\n\nThe Bayesian evidence for a model $\\mathcal{M}$, denoted $\\mathcal{Z}_{\\mathcal{M}}$, is the probability of the data given the model, integrated over all possible parameter values weighted by their prior probabilities:\n$$\\mathcal{Z}_{\\mathcal{M}} = p(s|\\mathcal{M}) = \\int p(s|\\theta, \\mathcal{M}) p(\\theta|\\mathcal{M}) d\\theta$$\n\n**Evidence for $\\mathcal{M}_P$:**\nThe evidence for the point-particle model, $\\mathcal{Z}_P$, is:\n$$\\mathcal{Z}_P = \\int_{-\\infty}^{\\infty} p(x, y | a, \\mathcal{M}_P) p(a|\\mathcal{M}_P) da$$\nSubstituting the expressions for the likelihood and prior:\n$$\\mathcal{Z}_P = \\int \\left(\\frac{1}{\\sqrt{2\\pi}} e^{-\\frac{(x-a)^2}{2}}\\right) \\left(\\frac{1}{\\sqrt{2\\pi}} e^{-\\frac{y^2}{2}}\\right) \\left(\\frac{1}{\\sqrt{2\\pi}\\sigma_a} e^{-\\frac{a^2}{2\\sigma_a^2}}\\right) da$$\nThe term involving $y$ is constant with respect to the integration variable $a$ and can be factored out:\n$$\\mathcal{Z}_P = \\left(\\frac{1}{\\sqrt{2\\pi}} e^{-\\frac{y^2}{2}}\\right) \\int \\left(\\frac{1}{\\sqrt{2\\pi}} e^{-\\frac{(x-a)^2}{2}}\\right) \\left(\\frac{1}{\\sqrt{2\\pi}\\sigma_a} e^{-\\frac{a^2}{2\\sigma_a^2}}\\right) da$$\nThe remaining integral is the marginal likelihood for $x$, $p(x|\\mathcal{M}_P)$. This is a standard result for a Gaussian likelihood integrated over a Gaussian prior. The integral of $\\mathcal{N}(x|a, \\sigma_L^2)$ with prior $\\mathcal{N}(a|\\mu_P, \\sigma_P^2)$ yields a marginal likelihood for $x$ of $\\mathcal{N}(x|\\mu_P, \\sigma_L^2+\\sigma_P^2)$. In our case, $\\sigma_L^2=1$, $\\mu_P=0$, and $\\sigma_P^2=\\sigma_a^2$. Thus, the integral evaluates to:\n$$p(x|\\mathcal{M}_P) = \\frac{1}{\\sqrt{2\\pi(1+\\sigma_a^2)}} \\exp\\left(-\\frac{x^2}{2(1+\\sigma_a^2)}\\right)$$\nCombining this with the factored-out $y$ term, the total evidence for $\\mathcal{M}_P$ is:\n$$\\mathcal{Z}_P = \\frac{1}{\\sqrt{2\\pi(1+\\sigma_a^2)}} \\exp\\left(-\\fracx^2}{2(1+\\sigma_a^2)}\\right) \\cdot \\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{y^2}{2}\\right)$$\n\n**Evidence for $\\mathcal{M}_T$:**\nThe evidence for the tidal model, $\\mathcal{Z}_T$, involves integrating over both $a$ and $\\lambda$:\n$$\\mathcal{Z}_T = \\iint p(x, y | a, \\lambda, \\mathcal{M}_T) p(a|\\mathcal{M}_T) p(\\lambda|\\mathcal{M}_T) da d\\lambda$$\nDue to the factorization of the likelihood and the independence of the priors, the integral separates:\n$$\\mathcal{Z}_T = \\left( \\int p(x|a) p(a) da \\right) \\left( \\int p(y|\\lambda) p(\\lambda) d\\lambda \\right)$$\nThe integral over $a$ is identical to the one computed for $\\mathcal{Z}_P$. The integral over $\\lambda$ is analogous: we have a likelihood $\\mathcal{N}(y|\\lambda, 1)$ and a prior $\\mathcal{N}(\\lambda|0, \\sigma_\\lambda^2)$. The result is:\n$$p(y|\\mathcal{M}_T) = \\frac{1}{\\sqrt{2\\pi(1+\\sigma_\\lambda^2)}} \\exp\\left(-\\frac{y^2}{2(1+\\sigma_\\lambda^2)}\\right)$$\nTherefore, the total evidence for $\\mathcal{M}_T$ is the product of the two marginal likelihoods:\n$$\\mathcal{Z}_T = \\frac{1}{\\sqrt{2\\pi(1+\\sigma_a^2)}} \\exp\\left(-\\frac{x^2}{2(1+\\sigma_a^2)}\\right) \\cdot \\frac{1}{\\sqrt{2\\pi(1+\\sigma_\\lambda^2)}} \\exp\\left(-\\frac{y^2}{2(1+\\sigma_\\lambda^2)}\\right)$$\n\n### Derivation of the Bayes Factor\n\nThe Bayes factor $B_{TP}$ in favor of the tidal model $\\mathcal{M}_T$ over the point-particle model $\\mathcal{M}_P$ is the ratio of their evidences:\n$$B_{TP} = \\frac{\\mathcal{Z}_T}{\\mathcal{Z}_P}$$\nSubstituting the expressions for $\\mathcal{Z}_T$ and $\\mathcal{Z}_P$:\n$$B_{TP} = \\frac{\\frac{1}{\\sqrt{2\\pi(1+\\sigma_a^2)}} e^{-\\frac{x^2}{2(1+\\sigma_a^2)}} \\cdot \\frac{1}{\\sqrt{2\\pi(1+\\sigma_\\lambda^2)}} e^{-\\frac{y^2}{2(1+\\sigma_\\lambda^2)}}}{\\frac{1}{\\sqrt{2\\pi(1+\\sigma_a^2)}} e^{-\\frac{x^2}{2(1+\\sigma_a^2)}} \\cdot \\frac{1}{\\sqrt{2\\pi}} e^{-\\frac{y^2}{2}}}$$\nThe terms involving $x$ and $\\sigma_a$ cancel completely, demonstrating that the evidence for or against the tidal parameter depends only on the data component $y$ and the prior width $\\sigma_\\lambda$.\n$$B_{TP} = \\frac{\\frac{1}{\\sqrt{1+\\sigma_\\lambda^2}} \\exp\\left(-\\frac{y^2}{2(1+\\sigma_\\lambda^2)}\\right)}{\\exp\\left(-\\frac{y^2}{2}\\right)}$$\nSimplifying the expression by combining the exponentials:\n$$B_{TP} = \\frac{1}{\\sqrt{1+\\sigma_\\lambda^2}} \\exp\\left(\\frac{y^2}{2} - \\frac{y^2}{2(1+\\sigma_\\lambda^2)}\\right)$$\n$$B_{TP} = \\frac{1}{\\sqrt{1+\\sigma_\\lambda^2}} \\exp\\left(\\frac{y^2}{2} \\left(1 - \\frac{1}{1+\\sigma_\\lambda^2}\\right)\\right)$$\n$$B_{TP} = \\frac{1}{\\sqrt{1+\\sigma_\\lambda^2}} \\exp\\left(\\frac{y^2}{2} \\left(\\frac{1+\\sigma_\\lambda^2 - 1}{1+\\sigma_\\lambda^2}\\right)\\right)$$\nThis yields the final expression for the Bayes factor as a function of $y$ and $\\sigma_\\lambda$:\n$$B_{TP}(y, \\sigma_\\lambda) = \\frac{1}{\\sqrt{1+\\sigma_\\lambda^2}} \\exp\\left( \\frac{y^2 \\sigma_\\lambda^2}{2(1+\\sigma_\\lambda^2)} \\right)$$\n\n### Derivation of the Threshold Tidal SNR $y_\\star$\n\nThe tidal signal-to-noise ratio (SNR) is defined as $|y|$. We need to find the minimal SNR, denoted $y_\\star$, for which the Bayes factor reaches a threshold of $B_0 = 100$. Since $B_{TP}$ depends on $y^2$, we can solve for $y_\\star > 0$.\nWe set $B_{TP}(y_\\star, \\sigma_\\lambda) = B_0$:\n$$100 = \\frac{1}{\\sqrt{1+\\sigma_\\lambda^2}} \\exp\\left( \\frac{y_\\star^2 \\sigma_\\lambda^2}{2(1+\\sigma_\\lambda^2)} \\right)$$\nTo solve for $y_\\star$, we first isolate the exponential term and then take the natural logarithm:\n$$100 \\sqrt{1+\\sigma_\\lambda^2} = \\exp\\left( \\frac{y_\\star^2 \\sigma_\\lambda^2}{2(1+\\sigma_\\lambda^2)} \\right)$$\n$$\\ln\\left(100 \\sqrt{1+\\sigma_\\lambda^2}\\right) = \\frac{y_\\star^2 \\sigma_\\lambda^2}{2(1+\\sigma_\\lambda^2)}$$\nNow, we solve for $y_\\star^2$:\n$$y_\\star^2 = \\frac{2(1+\\sigma_\\lambda^2)}{\\sigma_\\lambda^2} \\ln\\left(100 (1+\\sigma_\\lambda^2)^{1/2}\\right)$$\nThe expression can also be written using properties of logarithms:\n$$y_\\star^2 = \\frac{2(1+\\sigma_\\lambda^2)}{\\sigma_\\lambda^2} \\left[ \\ln(100) + \\frac{1}{2}\\ln(1+\\sigma_\\lambda^2) \\right]$$\nTaking the positive square root gives the final expression for the threshold SNR, $y_\\star$:\n$$y_\\star(\\sigma_\\lambda) = \\sqrt{\\frac{2(1+\\sigma_\\lambda^2)}{\\sigma_\\lambda^2} \\left[ \\ln(100) + \\frac{1}{2}\\ln(1+\\sigma_\\lambda^2) \\right]}$$\nThis expression and the one for the Bayes factor will be implemented to compute the required values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Bayes factor and threshold SNR for tidal effects in a\n    simplified gravitational wave data analysis problem.\n    \"\"\"\n    # Define the test cases from the problem statement as tuples of (sigma_lambda, y).\n    test_cases = [\n        (1.0, 0.0),\n        (1.5, 3.0),\n        (3.0, 6.0),\n    ]\n\n    B_0 = 100.0  # The decision threshold for the Bayes factor.\n    \n    bayes_factor_results = []\n    snr_threshold_results = []\n\n    # Calculate Bayes factors for each test case\n    for sigma_lambda, y in test_cases:\n        # The derived formula for the Bayes factor B_TP in favor of the tidal model\n        # B_TP = (1 / sqrt(1 + sigma_lambda^2)) * exp((y^2 * sigma_lambda^2) / (2 * (1 + sigma_lambda^2)))\n        \n        one_plus_sl_sq = 1.0 + sigma_lambda**2\n        ockham_factor = 1.0 / np.sqrt(one_plus_sl_sq)\n        \n        exponent = (y**2 * sigma_lambda**2) / (2.0 * one_plus_sl_sq)\n        \n        bayes_factor = ockham_factor * np.exp(exponent)\n        bayes_factor_results.append(bayes_factor)\n\n    # Calculate SNR thresholds for each unique sigma_lambda\n    # The unique values of sigma_lambda are the first elements of the test_cases tuples\n    sigma_lambda_values = [case[0] for case in test_cases]\n    \n    for sigma_lambda in sigma_lambda_values:\n        # The derived formula for the threshold SNR y_star\n        # y_star^2 = (2 * (1 + sigma_lambda^2) / sigma_lambda^2) * ln(B_0 * sqrt(1 + sigma_lambda^2))\n        \n        one_plus_sl_sq = 1.0 + sigma_lambda**2\n        \n        # log argument: B_0 * sqrt(1 + sigma_lambda^2)\n        log_arg = B_0 * np.sqrt(one_plus_sl_sq)\n        \n        # Prefactor: 2 * (1 + sigma_lambda^2) / sigma_lambda^2\n        prefactor = 2.0 * one_plus_sl_sq / (sigma_lambda**2)\n        \n        y_star_squared = prefactor * np.log(log_arg)\n        \n        y_star = np.sqrt(y_star_squared)\n        snr_threshold_results.append(y_star)\n\n    # Combine the results in the required order: [B1, B2, B3, y_star1, y_star2, y_star3]\n    all_results = bayes_factor_results + snr_threshold_results\n\n    # Format the final output as a comma-separated list of floats rounded to six decimal places,\n    # enclosed in square brackets.\n    output_str = f\"[{','.join(['{:.6f}'.format(r) for r in all_results])}]\"\n    \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Modern gravitational-wave data analysis requires comparing observational data to millions of theoretical waveform templates, a task that can be computationally prohibitive if using full physical models. This practice introduces surrogate modeling, a state-of-the-art technique for creating fast and accurate emulators of complex physical calculations. You will implement a greedy algorithm to build a reduced-order surrogate for the tidal phase contribution and evaluate its accuracy, developing a core skill for enabling large-scale parameter estimation and discovery in the era of gravitational-wave astronomy .",
            "id": "3562138",
            "problem": "You are asked to construct and test a reduced-order surrogate for the leading-order tidal contribution to the gravitational-wave phase accumulated across a frequency band for binary neutron star systems. The surrogate must approximate a reference phase function that depends on the chirp mass, the symmetric mass ratio, and the effective tidal deformability, and it must be built via greedy basis selection on a training set. You will then evaluate the surrogate’s interpolation error on a validation grid representative of binary neutron star systems. The output must be a single-line list of floating-point numbers, one per test case, giving the maximum absolute error on the validation grid in radians.\n\nBegin from well-tested physical formulas used in the stationary-phase approximation of binary inspirals under the Post-Newtonian (PN) framework. Let the binary’s total mass be $M$, individual component masses be $m_1$ and $m_2$, and define the chirp mass $\\mathcal{M}$ and symmetric mass ratio $\\eta$ by\n$$\n\\mathcal{M} = \\frac{(m_1 m_2)^{3/5}}{(m_1 + m_2)^{1/5}}, \\quad \\eta = \\frac{m_1 m_2}{(m_1 + m_2)^2}.\n$$\nThese imply $M = \\mathcal{M}\\,\\eta^{-3/5}$. Let the effective tidal deformability parameter be $\\tilde{\\Lambda}$, a dimensionless quantity depending on the neutron star equation of state.\n\nUnder the leading-order ($5$th PN) tidal phase correction, the tidal contribution to the gravitational-wave phase in the frequency domain at frequency $f$ can be modeled as\n$$\n\\delta \\psi_{\\text{tidal}}(f) = -\\frac{39}{2}\\,\\tilde{\\Lambda}\\,v^{10},\n$$\nwhere the PN velocity parameter $v$ is defined by\n$$\nv = \\left( \\pi \\frac{G M}{c^3} f \\right)^{1/3},\n$$\nwith gravitational constant $G$ and speed of light $c$. Over a frequency band from $f_{\\text{low}}$ to $f_{\\text{high}}$, a physically meaningful tidal phase shift metric is the difference\n$$\n\\Delta \\Psi_{\\text{tidal}}(\\mathcal{M},\\eta,\\tilde{\\Lambda}) = \\delta \\psi_{\\text{tidal}}(f_{\\text{high}}) - \\delta \\psi_{\\text{tidal}}(f_{\\text{low}}),\n$$\nexpressed in radians. All masses must be expressed in Solar masses, where conversion to seconds uses $G M_{\\odot} / c^3$, and all frequencies must be in Hertz. You must treat $\\Delta \\Psi_{\\text{tidal}}$ as the high-fidelity target function to be emulated by the surrogate.\n\nConstruct a surrogate function $\\widehat{\\Delta \\Psi}_{\\text{tidal}}(\\mathcal{M},\\eta,\\tilde{\\Lambda})$ by representing it as a sparse linear combination of candidate basis functions of the transformed parameters. Use a fixed candidate set consisting of all monomials up to total degree $3$ in the variables\n$$\nx = \\ln\\left(\\frac{\\mathcal{M}}{1.2}\\right), \\quad y = \\eta - 0.24, \\quad z = \\ln\\left(\\frac{\\tilde{\\Lambda}}{400}\\right),\n$$\nincluding cross terms. Specifically, include the following $20$ basis functions:\n$$\n\\{1,\\, x,\\, y,\\, z,\\, x^2,\\, y^2,\\, z^2,\\, xy,\\, xz,\\, yz,\\, x^3,\\, y^3,\\, z^3,\\, x^2 y,\\, x y^2,\\, x^2 z,\\, x z^2,\\, y^2 z,\\, y z^2,\\, xyz\\}.\n$$\nPerform greedy basis selection using Orthogonal Matching Pursuit (OMP) on a training set of parameter tuples to choose $K$ basis functions that best approximate the reference $\\Delta \\Psi_{\\text{tidal}}$ in the least-squares sense. Normalize each candidate basis column over the training set to unit norm during the selection and fitting, and compute coefficients by solving the least-squares problem restricted to the selected basis at each iteration.\n\nTraining set and validation grid:\n- Use the following training grid for parameters representative of binary neutron stars:\n  - $\\mathcal{M} \\in \\{1.00, 1.05, 1.10, 1.15, 1.20, 1.25, 1.30\\}$ Solar masses,\n  - $\\eta \\in \\{0.22, 0.23, 0.24, 0.25\\}$,\n  - $\\tilde{\\Lambda} \\in \\{100, 175, 250, 325, 400, 500, 600, 700, 800\\}$.\n- Use the following validation grid:\n  - $\\mathcal{M} \\in \\{1.00, 1.03, 1.06, 1.09, 1.12, 1.15, 1.18, 1.21, 1.24\\}$ Solar masses,\n  - $\\eta \\in \\{0.22, 0.225, 0.23, 0.235, 0.24, 0.245, 0.25\\}$,\n  - $\\tilde{\\Lambda} \\in \\{100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800\\}$.\n\nPhysical constants and units:\n- Use $G = 6.67430 \\times 10^{-11}$ in SI units, $c = 2.99792458 \\times 10^{8}$ in SI units, and $M_{\\odot} = 1.98847 \\times 10^{30}$ kilograms.\n- Convert Solar masses to time via $G M_{\\odot} / c^3$.\n- Use $f_{\\text{low}} = 20$ Hertz and $f_{\\text{high}} = 1000$ Hertz.\n- Express all phase quantities in radians.\n\nTest suite:\n- Test case $1$: $K = 3$ selected basis functions.\n- Test case $2$: $K = 6$ selected basis functions.\n- Test case $3$: $K = 10$ selected basis functions.\n\nFor each test case, construct the surrogate via greedy selection with the specified $K$, then evaluate its interpolation error on the validation grid by computing the maximum absolute error\n$$\nE_{\\max} = \\max_{\\text{validation grid}} \\left| \\widehat{\\Delta \\Psi}_{\\text{tidal}} - \\Delta \\Psi_{\\text{tidal}} \\right|.\n$$\nThe required program must produce a single line of output containing the three results for $E_{\\max}$, in radians, for the three test cases, as a comma-separated list enclosed in square brackets, for example, $[e_1,e_2,e_3]$, where $e_i$ are floating-point numbers in radians.\n\nYour solution must be a complete, runnable program that constructs the training and validation sets, performs greedy basis selection, builds the surrogate, and computes the requested errors for the test suite. No user input is allowed. The final outputs must be in radians with no unit symbol attached, and must be raw floating-point values without rounding instructions enforced by the program.",
            "solution": "The problem requires the construction and validation of a reduced-order surrogate model for the tidal contribution to the gravitational-wave phase of a binary neutron star inspiral. This is a common task in computational astrophysics, where fast and accurate emulators (surrogates) are needed to analyze gravitational-wave data in real-time. The solution involves three main stages: defining the high-fidelity physical model, constructing the surrogate using a greedy algorithm, and evaluating its accuracy.\n\n### 1. High-Fidelity Physical Model\n\nThe target of our surrogate is the tidal phase shift, $\\Delta \\Psi_{\\text{tidal}}$, accumulated over a frequency band. This quantity is derived from the Post-Newtonian (PN) expansion of the gravitational-wave phase. The tidal contribution to the phase at a given frequency $f$, at the leading (5th PN) order, is given by:\n$$\n\\delta \\psi_{\\text{tidal}}(f) = -\\frac{39}{2}\\,\\tilde{\\Lambda}\\,v^{10}\n$$\nHere, $\\tilde{\\Lambda}$ is the dimensionless effective tidal deformability parameter, which encodes information about the neutron stars' equation of state. The quantity $v$ is the PN velocity parameter, related to the orbital frequency of the binary:\n$$\nv = \\left( \\pi \\frac{G M}{c^3} f \\right)^{1/3}\n$$\nwhere $G$ is the gravitational constant, $c$ is the speed of light, and $M = m_1 + m_2$ is the total mass of the binary. It is computationally convenient to express mass in units of time. All masses provided in Solar masses, $M_{\\odot}$, are converted to seconds using the time-scale $T_{M_{\\odot}} = G M_{\\odot} / c^3$. The problem parameters are the chirp mass $\\mathcal{M}$ and the symmetric mass ratio $\\eta$, from which the total mass $M$ can be derived:\n$$\nM = \\mathcal{M}\\,\\eta^{-3/5}\n$$\nThe value of interest is the total phase accumulated between a lower frequency $f_{\\text{low}}$ and an upper frequency $f_{\\text{high}}$:\n$$\n\\Delta \\Psi_{\\text{tidal}}(\\mathcal{M},\\eta,\\tilde{\\Lambda}) = \\delta \\psi_{\\text{tidal}}(f_{\\text{high}}) - \\delta \\psi_{\\text{tidal}}(f_{\\text{low}})\n$$\nSubstituting the expressions for $v$ and $M$, we can express $\\Delta \\Psi_{\\text{tidal}}$ as a function of the input parameters $(\\mathcal{M}, \\eta, \\tilde{\\Lambda})$:\n$$\n\\Delta \\Psi_{\\text{tidal}} = -\\frac{39}{2}\\,\\tilde{\\Lambda}\\, \\left( \\pi \\frac{(\\mathcal{M} T_{M_{\\odot}}) \\eta^{-3/5}}{1} \\right)^{10/3} \\left( f_{\\text{high}}^{10/3} - f_{\\text{low}}^{10/3} \\right)\n$$\nwhere $\\mathcal{M}$ represents the numerical value in units of Solar masses. We can factor this equation to simplify computation:\n$$\n\\Delta \\Psi_{\\text{tidal}} = C \\cdot \\tilde{\\Lambda} \\cdot \\eta^{-2} \\cdot \\mathcal{M}^{10/3}\n$$\nwith the constant $C$ being:\n$$\nC = -\\frac{39}{2} (\\pi T_{M_{\\odot}})^{10/3} (f_{\\text{high}}^{10/3} - f_{\\text{low}}^{10/3})\n$$\nThis is our high-fidelity model, which we will use to generate training and validation data.\n\n### 2. Surrogate Model Construction\n\nThe surrogate, $\\widehat{\\Delta \\Psi}_{\\text{tidal}}$, is a mathematical function designed to approximate $\\Delta \\Psi_{\\text{tidal}}$ but with a much lower computational cost. We construct it as a linear combination of pre-defined basis functions.\n\n#### 2.1. Parameter Transformation and Basis Set\nThe physical parameters $(\\mathcal{M}, \\eta, \\tilde{\\Lambda})$ are first transformed into a new coordinate system $(x, y, z)$ to improve the numerical stability and performance of the model fitting. The transformation centers the parameters around typical values observed in binary neutron star systems:\n$$\nx = \\ln\\left(\\frac{\\mathcal{M}}{1.2}\\right), \\quad y = \\eta - 0.24, \\quad z = \\ln\\left(\\frac{\\tilde{\\Lambda}}{400}\\right)\n$$\nThe surrogate is then expressed as a linear combination of basis functions in these variables:\n$$\n\\widehat{\\Delta \\Psi}_{\\text{tidal}}(x, y, z) = \\sum_{i=1}^{K} c_i \\phi_i(x,y,z)\n$$\nwhere $\\{\\phi_i\\}_{i=1}^K$ is a subset of $K$ basis functions selected from a larger candidate set, and $\\{c_i\\}$ are the corresponding coefficients. The candidate set is specified as all $20$ monomials in $x, y, z$ up to total degree $3$.\n\n#### 2.2. Greedy Basis Selection via Orthogonal Matching Pursuit (OMP)\nThe core of the method is to select the most significant $K$ basis functions from the $20$ candidates. This is a feature selection problem, which we solve using Orthogonal Matching Pursuit (OMP). The procedure is as follows:\n\n1.  **Training Data Generation**: We evaluate the high-fidelity model $\\Delta \\Psi_{\\text{tidal}}$ at every point on the specified training parameter grid. This gives a set of parameter tuples $\\{(\\mathcal{M}_j, \\eta_j, \\tilde{\\Lambda}_j)\\}_{j=1}^{N}$ and a corresponding target vector $\\mathbf{b}$ where $b_j = \\Delta \\Psi_{\\text{tidal}}(\\mathcal{M}_j, \\eta_j, \\tilde{\\Lambda}_j)$.\n2.  **Design Matrix Construction**: We construct an $N \\times 20$ design matrix $\\mathbf{A}$, where each column corresponds to one of the $20$ candidate basis functions and each row corresponds to a point in the training set. An element $A_{ji}$ is the value of the $i$-th basis function evaluated at the $j$-th parameter tuple.\n3.  **Normalization**: To ensure a fair comparison between basis functions of different scales, each column of the design matrix $\\mathbf{A}$ is normalized to have a Euclidean norm of $1$. We denote this normalized matrix as $\\mathbf{A}_{\\text{norm}}$. The norms of the original columns are stored for later use.\n4.  **Iterative Selection**: The OMP algorithm iteratively builds a set of selected basis functions $\\mathcal{S}$.\n    *   Initialize the residual $\\mathbf{r} = \\mathbf{b}$ and the selected set $\\mathcal{S} = \\emptyset$.\n    *   For $k=1, \\dots, K$:\n        a. **Matching**: Find the basis function (column in $\\mathbf{A}_{\\text{norm}}$) not already in $\\mathcal{S}$ that has the largest absolute inner product with the current residual: $\\text{index}_k = \\arg\\max_{i \\notin \\mathcal{S}} |\\langle \\mathbf{A}_{\\text{norm}, i} | \\mathbf{r} \\rangle|$.\n        b. **Update**: Add the chosen index to the set: $\\mathcal{S} \\leftarrow \\mathcal{S} \\cup \\{\\text{index}_k\\}$.\n        c. **Solve & Update Residual**: Form a matrix $\\mathbf{A}_{\\mathcal{S}}$ from the columns of $\\mathbf{A}_{\\text{norm}}$ corresponding to indices in $\\mathcal{S}$. Solve the least-squares problem $\\mathbf{A}_{\\mathcal{S}}\\mathbf{c} = \\mathbf{b}$ for the coefficient vector $\\mathbf{c}$. The new residual is then calculated as $\\mathbf{r} = \\mathbf{b} - \\mathbf{A}_{\\mathcal{S}}\\mathbf{c}$. This step ensures the residual is orthogonal to the subspace spanned by the selected basis functions.\n5.  **Final Model**: After $K$ iterations, the process yields a set of $K$ selected basis functions and their corresponding coefficients $\\mathbf{c}$. These define the final surrogate model for a given $K$.\n\n### 3. Validation and Error Evaluation\n\nThe performance of the constructed surrogate is assessed on a separate, denser validation grid.\n\n1.  **Prediction**: For each point in the validation grid, we first compute the values of the $K$ selected basis functions. This forms a new design matrix for the validation set. Crucially, each column of this matrix is normalized using the norm of the corresponding column from the *training* set's design matrix. This ensures that the scaling applied to the validation data is consistent with the scaling learned during training. The surrogate's prediction is then calculated by taking the dot product of this normalized validation matrix and the fitted coefficient vector $\\mathbf{c}$.\n2.  **Error Calculation**: The accuracy is quantified by the maximum absolute error, $E_{\\max}$, between the surrogate's predictions and the true values from the high-fidelity model, computed across all points in the validation grid:\n    $$\n    E_{\\max} = \\max_{\\text{validation grid}} \\left| \\widehat{\\Delta \\Psi}_{\\text{tidal}} - \\Delta \\Psi_{\\text{tidal}} \\right|\n    $$\nThis process is repeated for each test case specified ($K=3, 6, 10$), producing an error value for each. The program will implement these steps, generate the training and validation data, run the OMP algorithm, and compute the final maximum errors.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and tests a reduced-order surrogate for gravitational-wave tidal phase.\n    \"\"\"\n    # Physical Constants and Fixed Parameters\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    C_LIGHT = 2.99792458e8  # m/s\n    M_SOLAR = 1.98847e30  # kg\n    T_MSUN = G * M_SOLAR / (C_LIGHT**3)  # Solar mass in seconds\n\n    F_LOW = 20.0  # Hz\n    F_HIGH = 1000.0  # Hz\n\n    # Test cases for the number of basis functions\n    K_VALUES = [3, 6, 10]\n\n    def delta_psi_tidal_model(m_chirp, eta, lambda_tilde):\n        \"\"\"\n        Calculates the high-fidelity tidal phase shift Delta_Psi_tidal.\n        \"\"\"\n        if eta == 0:\n            return 0\n        \n        # Pre-calculated constant factor for efficiency\n        # C = -39/2 * (pi * T_MSUN)^(10/3) * (F_HIGH^(10/3) - F_LOW^(10/3))\n        C_factor = (-19.5 * (np.pi * T_MSUN)**(10.0/3.0) * \n                    (F_HIGH**(10.0/3.0) - F_LOW**(10.0/3.0)))\n        \n        phase_shift = (C_factor * lambda_tilde * (eta**(-2.0)) * \n                       m_chirp**(10.0/3.0))\n        \n        return phase_shift\n\n    # Define the 20 basis functions\n    basis_functions = [\n        lambda x, y, z: 1.0,\n        lambda x, y, z: x,\n        lambda x, y, z: y,\n        lambda x, y, z: z,\n        lambda x, y, z: x**2,\n        lambda x, y, z: y**2,\n        lambda x, y, z: z**2,\n        lambda x, y, z: x * y,\n        lambda x, y, z: x * z,\n        lambda x, y, z: y * z,\n        lambda x, y, z: x**3,\n        lambda x, y, z: y**3,\n        lambda x, y, z: z**3,\n        lambda x, y, z: x**2 * y,\n        lambda x, y, z: x * y**2,\n        lambda x, y, z: x**2 * z,\n        lambda x, y, z: x * z**2,\n        lambda x, y, z: y**2 * z,\n        lambda x, y, z: y * z**2,\n        lambda x, y, z: x * y * z,\n    ]\n    \n    def transform_params(m_chirp, eta, lambda_tilde):\n        \"\"\"Transforms physical parameters to surrogate coordinates.\"\"\"\n        x = np.log(m_chirp / 1.2)\n        y = eta - 0.24\n        z = np.log(lambda_tilde / 400.0)\n        return x, y, z\n\n    def generate_design_matrix(params):\n        \"\"\"Generates the design matrix from a list of parameter tuples.\"\"\"\n        n_samples = len(params)\n        n_features = len(basis_functions)\n        A = np.zeros((n_samples, n_features))\n        for i, (m_c, n, l_t) in enumerate(params):\n            x, y, z = transform_params(m_c, n, l_t)\n            for j, func in enumerate(basis_functions):\n                A[i, j] = func(x, y, z)\n        return A\n\n    def orthogonal_matching_pursuit(A_norm, b, K):\n        \"\"\"\n        Performs Orthogonal Matching Pursuit to select K basis functions.\n        \"\"\"\n        n_samples, n_features = A_norm.shape\n        residual = np.copy(b)\n        selected_indices = []\n        \n        for _ in range(K):\n            correlations = np.abs(A_norm.T @ residual)\n            # Prevent re-selecting the same index\n            if selected_indices:\n                correlations[selected_indices] = -1.0\n            \n            best_idx = np.argmax(correlations)\n            selected_indices.append(best_idx)\n            \n            A_selected = A_norm[:, selected_indices]\n            coeffs, _, _, _ = np.linalg.lstsq(A_selected, b, rcond=None)\n            \n            b_approx = A_selected @ coeffs\n            residual = b - b_approx\n            \n        # The final coefficients are from the last iteration's lstsq solve\n        return selected_indices, coeffs\n\n    # Define training and validation grids\n    m_chirp_train = np.array([1.00, 1.05, 1.10, 1.15, 1.20, 1.25, 1.30])\n    eta_train = np.array([0.22, 0.23, 0.24, 0.25])\n    lambda_tilde_train = np.array([100, 175, 250, 325, 400, 500, 600, 700, 800])\n\n    m_chirp_val = np.array([1.00, 1.03, 1.06, 1.09, 1.12, 1.15, 1.18, 1.21, 1.24])\n    eta_val = np.array([0.22, 0.225, 0.23, 0.235, 0.24, 0.245, 0.25])\n    lambda_tilde_val = np.array([100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800])\n    \n    # Create parameter lists (Cartesian products)\n    train_params = [(m, e, l) for m in m_chirp_train for e in eta_train for l in lambda_tilde_train]\n    val_params = [(m, e, l) for m in m_chirp_val for e in eta_val for l in lambda_tilde_val]\n\n    # Generate training and validation data\n    y_train = np.array([delta_psi_tidal_model(*p) for p in train_params])\n    y_val = np.array([delta_psi_tidal_model(*p) for p in val_params])\n\n    # Construct and normalize the training design matrix\n    A_train = generate_design_matrix(train_params)\n    col_norms = np.linalg.norm(A_train, axis=0)\n    # Avoid division by zero for any unforeseen constant columns\n    col_norms[col_norms == 0] = 1.0\n    A_train_norm = A_train / col_norms\n    \n    # Construct validation design matrix\n    A_val = generate_design_matrix(val_params)\n\n    results = []\n    for K in K_VALUES:\n        selected_indices, coeffs = orthogonal_matching_pursuit(A_train_norm, y_train, K)\n        \n        # Make predictions on the validation set\n        A_val_selected = A_val[:, selected_indices]\n        # Normalize validation matrix columns with norms from the training set\n        A_val_selected_norm = A_val_selected / col_norms[selected_indices]\n        \n        y_pred = A_val_selected_norm @ coeffs\n        \n        # Calculate maximum absolute error\n        max_error = np.max(np.abs(y_pred - y_val))\n        results.append(max_error)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}