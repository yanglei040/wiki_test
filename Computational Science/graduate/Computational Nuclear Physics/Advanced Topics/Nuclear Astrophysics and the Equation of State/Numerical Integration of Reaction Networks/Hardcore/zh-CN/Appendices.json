{
    "hands_on_practices": [
        {
            "introduction": "掌握隐式方法的关键在于理解单个时间步的运作机制。本练习  将分解用于求解刚性系统的二阶向后差分公式 (BDF2)。通过为一个简单的双物种网络手动构建残差和雅可比矩阵，并使用牛顿法求解下一步的状态，你将对隐式求解器底层的工作原理获得具体而深刻的认识。",
            "id": "3576963",
            "problem": "考虑一个由物种 $Y_{P}$ 和 $Y_{D}$ 构成的双物种核反应子网络，其丰度（每重子的数量分数，无量纲）通过一个转换和衰变方案演化。母物种 $Y_{P}$ 以恒定速率 $k$ 转换为子物种 $Y_{D}$，并以恒定速率 $\\lambda_{P}$ 独立地衰变到一个汇。子物种 $Y_{D}$ 以恒定速率 $\\lambda_{D}$ 独立地衰变到一个汇。其确定性演化遵循常微分方程（ODE）系统\n$$\n\\frac{d}{dt}\\begin{pmatrix}Y_{P} \\\\ Y_{D}\\end{pmatrix} \\;=\\; \\begin{pmatrix} -(\\lambda_{P}+k)  0 \\\\ k  -\\lambda_{D} \\end{pmatrix}\\begin{pmatrix}Y_{P} \\\\ Y_{D}\\end{pmatrix},\n$$\n这是一个刚性线性反应网络。取速率常数为 $k=900\\,\\mathrm{s}^{-1}$，$\\lambda_{P}=40\\,\\mathrm{s}^{-1}$ 和 $\\lambda_{D}=5\\,\\mathrm{s}^{-1}$。\n\n假设时间步长是均匀的 $\\Delta t = 1.0\\times 10^{-3}\\,\\mathrm{s}$，且在 $t_{n-1}$ 和 $t_{n}$ 时刻的两个已计算状态由下式给出\n$$\n\\mathbf{Y}_{n-1}=\\begin{pmatrix}0.500 \\\\ 0.300\\end{pmatrix}, \\qquad \\mathbf{Y}_{n}=\\begin{pmatrix}0.195 \\\\ 0.700\\end{pmatrix}.\n$$\n\n使用完全隐式的二阶后向差分格式（BDF2），通过以下步骤将计算向前推进一个步长至 $t_{n+1}$：\n- 从该方法的定义出发，即它是通过对 $\\mathbf{Y}_{n-1}$、$\\mathbf{Y}_{n}$ 和在 $t_{n+1}$ 处求值的 $\\mathbf{Y}$ 进行二次插值，从而构造出的对 $t_{n+1}$ 处时间导数的两步隐式线性多步近似。\n- 构造在 $t_{n+1}$ 处的非线性离散残差 $\\mathbf{R}(\\mathbf{Y})$，以及它关于 $\\mathbf{Y}$ 的雅可比矩阵。\n- 使用初始猜测 $\\mathbf{Y}^{(0)}=\\mathbf{Y}_{n}$ 进行一次牛顿更新，对结果系统进行线性化并求解，从而得到更新后的 $\\mathbf{Y}_{n+1}$。\n\n对给定数据显式地执行这些步骤，并报告丰度向量 $\\mathbf{Y}_{n+1}=(Y_{P,n+1},\\,Y_{D,n+1})$，结果四舍五入至六位有效数字。最终答案以无量纲丰度表示。",
            "solution": "该控制系统是线性和刚性的：\n$$\n\\frac{d}{dt}\\mathbf{Y} \\;=\\; \\mathbf{f}(\\mathbf{Y}) \\;=\\; \\mathbf{M}\\,\\mathbf{Y}, \\qquad \\mathbf{M} \\;=\\; \\begin{pmatrix}-(\\lambda_{P}+k)  0 \\\\ k  -\\lambda_{D}\\end{pmatrix}.\n$$\n当 $k=900\\,\\mathrm{s}^{-1}$，$\\lambda_{P}=40\\,\\mathrm{s}^{-1}$ 和 $\\lambda_{D}=5\\,\\mathrm{s}^{-1}$ 时，我们有\n$$\n\\mathbf{M} \\;=\\; \\begin{pmatrix}-940  0 \\\\ 900  -5\\end{pmatrix}.\n$$\n\n我们使用二阶后向差分格式（BDF2），这是一种两步隐式线性多步法。为了从第一性原理推导其在 $t_{n+1}$ 处的离散时间导数，我们用一个唯一的二次多项式 $\\mathbf{p}(t)$ 来近似 $[t_{n-1},t_{n+1}]$ 上的 $\\mathbf{Y}(t)$，该多项式插值于 $t_{n-1}=t_{n}-\\Delta t$ 处的 $\\mathbf{Y}_{n-1}$、$t_{n}$ 处的 $\\mathbf{Y}_{n}$ 以及 $t_{n+1}=t_{n}+\\Delta t$ 处一个待定的 $\\mathbf{Y}$。在 $t_{n+1}$ 处的拉格朗日插值多项式的导数给出了时间导数的标准BDF2后向差分格式：\n$$\n\\left.\\frac{d\\mathbf{Y}}{dt}\\right|_{t_{n+1}} \\;\\approx\\; \\frac{3\\,\\mathbf{Y}_{n+1} - 4\\,\\mathbf{Y}_{n} + \\mathbf{Y}_{n-1}}{2\\,\\Delta t}.\n$$\n完全隐式的BDF2格式要求这个离散导数等于在 $t_{n+1}$ 处计算的右端项：\n$$\n\\frac{3\\,\\mathbf{Y}_{n+1} - 4\\,\\mathbf{Y}_{n} + \\mathbf{Y}_{n-1}}{2\\,\\Delta t} \\;=\\; \\mathbf{f}(\\mathbf{Y}_{n+1}).\n$$\n\n将在 $t_{n+1}$ 处的非线性残差定义为\n$$\n\\mathbf{R}(\\mathbf{Y}) \\;=\\; \\frac{3\\,\\mathbf{Y} - 4\\,\\mathbf{Y}_{n} + \\mathbf{Y}_{n-1}}{2\\,\\Delta t} \\;-\\; \\mathbf{f}(\\mathbf{Y}).\n$$\n从初始猜测 $\\mathbf{Y}^{(0)}$ 开始的一次牛顿更新满足\n$$\n\\left[\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{Y}}(\\mathbf{Y}^{(0)})\\right]\\delta \\;=\\; -\\,\\mathbf{R}(\\mathbf{Y}^{(0)}), \\qquad \\mathbf{Y}^{(1)} \\;=\\; \\mathbf{Y}^{(0)} + \\delta.\n$$\n因为 $\\mathbf{f}(\\mathbf{Y})=\\mathbf{M}\\mathbf{Y}$ 是线性的，所以雅可比矩阵 $\\mathbf{J}=\\partial \\mathbf{f}/\\partial \\mathbf{Y}$ 是常数且等于 $\\mathbf{M}$。因此\n$$\n\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{Y}} \\;=\\; \\frac{3}{2\\Delta t}\\,\\mathbf{I} \\;-\\; \\mathbf{J} \\;=\\; \\frac{3}{2\\Delta t}\\,\\mathbf{I} \\;-\\; \\mathbf{M}.\n$$\n当 $\\Delta t = 1.0\\times 10^{-3}\\,\\mathrm{s}$ 时，我们有\n$$\n\\alpha \\;=\\; \\frac{3}{2\\Delta t} \\;=\\; \\frac{3}{2\\times 10^{-3}} \\;=\\; 1500,\n$$\n因此\n$$\n\\mathbf{A} \\;=\\; \\alpha\\,\\mathbf{I} - \\mathbf{M} \\;=\\; \\begin{pmatrix}1500 - (-940)  0 - 0 \\\\ 0 - 900  1500 - (-5)\\end{pmatrix} \\;=\\; \\begin{pmatrix}2440  0 \\\\ -900  1505\\end{pmatrix}.\n$$\n\n选择牛顿法的初始猜测为 $\\mathbf{Y}^{(0)}=\\mathbf{Y}_{n}$。计算残差：\n$$\n\\mathbf{R}(\\mathbf{Y}_{n}) \\;=\\; \\frac{\\mathbf{Y}_{n-1} - \\mathbf{Y}_{n}}{2\\Delta t} \\;-\\; \\mathbf{f}(\\mathbf{Y}_{n}).\n$$\n计算每一项。首先，\n$$\n\\frac{\\mathbf{Y}_{n-1} - \\mathbf{Y}_{n}}{2\\Delta t} \\;=\\; \\frac{1}{2\\times 10^{-3}}\\begin{pmatrix}0.500 - 0.195 \\\\ 0.300 - 0.700\\end{pmatrix} \\;=\\; \\frac{1}{0.002}\\begin{pmatrix}0.305 \\\\ -0.400\\end{pmatrix} \\;=\\; \\begin{pmatrix}152.5 \\\\ -200.0\\end{pmatrix}.\n$$\n接下来，\n$$\n\\mathbf{f}(\\mathbf{Y}_{n}) \\;=\\; \\mathbf{M}\\,\\mathbf{Y}_{n} \\;=\\; \\begin{pmatrix}-940  0 \\\\ 900  -5\\end{pmatrix}\\begin{pmatrix}0.195 \\\\ 0.700\\end{pmatrix}.\n$$\n显式计算：\n$$\n\\mathbf{f}(\\mathbf{Y}_{n}) \\;=\\; \\begin{pmatrix}-940\\cdot 0.195 + 0\\cdot 0.700 \\\\ 900\\cdot 0.195 - 5\\cdot 0.700\\end{pmatrix} \\;=\\; \\begin{pmatrix}-183.3 \\\\ 175.5 - 3.5\\end{pmatrix} \\;=\\; \\begin{pmatrix}-183.3 \\\\ 172.0\\end{pmatrix}.\n$$\n因此，在初始猜测处的离散残差为\n$$\n\\mathbf{R}(\\mathbf{Y}_{n}) \\;=\\; \\begin{pmatrix}152.5 \\\\ -200.0\\end{pmatrix} \\;-\\; \\begin{pmatrix}-183.3 \\\\ 172.0\\end{pmatrix} \\;=\\; \\begin{pmatrix}335.8 \\\\ -372.0\\end{pmatrix}.\n$$\n\n求解牛顿系统\n$$\n\\mathbf{A}\\,\\delta \\;=\\; -\\,\\mathbf{R}(\\mathbf{Y}_{n}) \\;=\\; \\begin{pmatrix}-335.8 \\\\ 372.0\\end{pmatrix}.\n$$\n因为在这种情况下 $\\mathbf{A}$ 是下三角矩阵，所以逐分量求解。第一行给出\n$$\n2440\\,\\delta_{1} \\;=\\; -335.8 \\;\\;\\Rightarrow\\;\\; \\delta_{1} \\;=\\; -\\frac{335.8}{2440} \\;\\approx\\; -0.13762295.\n$$\n第二行给出\n$$\n-900\\,\\delta_{1} + 1505\\,\\delta_{2} \\;=\\; 372.0 \\;\\;\\Rightarrow\\;\\; 1505\\,\\delta_{2} \\;=\\; 372.0 + 900\\,\\delta_{1}.\n$$\n代入 $\\delta_{1}$，\n$$\n900\\,\\delta_{1} \\;\\approx\\; -123.860655 \\;\\;\\Rightarrow\\;\\; 1505\\,\\delta_{2} \\;\\approx\\; 248.139345 \\;\\;\\Rightarrow\\;\\; \\delta_{2} \\;\\approx\\; 0.1648776.\n$$\n更新以获得新状态：\n$$\n\\mathbf{Y}_{n+1} \\;=\\; \\mathbf{Y}_{n} + \\delta \\;=\\; \\begin{pmatrix}0.195 \\\\ 0.700\\end{pmatrix} + \\begin{pmatrix}-0.13762295 \\\\ 0.1648776\\end{pmatrix} \\;=\\; \\begin{pmatrix}0.05737705 \\\\ 0.8648776\\end{pmatrix}.\n$$\n\n对于线性系统 $\\mathbf{f}(\\mathbf{Y})=\\mathbf{M}\\mathbf{Y}$，这次单步牛顿更新即为精确的BDF2解，因为雅可比矩阵是常数，残差是仿射的。等价地，可以将BDF2步骤写成线性系统\n$$\n\\left(\\frac{3}{2\\Delta t}\\mathbf{I} - \\mathbf{M}\\right)\\mathbf{Y}_{n+1} \\;=\\; \\frac{4\\,\\mathbf{Y}_{n} - \\mathbf{Y}_{n-1}}{2\\Delta t},\n$$\n其中，$\\mathbf{A}$ 如上所述，右端项为\n$$\n\\frac{4\\,\\mathbf{Y}_{n} - \\mathbf{Y}_{n-1}}{2\\Delta t} \\;=\\; \\frac{1}{0.002}\\begin{pmatrix}4\\cdot 0.195 - 0.500 \\\\ 4\\cdot 0.700 - 0.300\\end{pmatrix} \\;=\\; \\frac{1}{0.002}\\begin{pmatrix}0.280 \\\\ 2.500\\end{pmatrix} \\;=\\; \\begin{pmatrix}140 \\\\ 1250\\end{pmatrix},\n$$\n得到相同的解。求解\n$$\n\\begin{pmatrix}2440  0 \\\\ -900  1505\\end{pmatrix}\\begin{pmatrix}Y_{P,n+1} \\\\ Y_{D,n+1}\\end{pmatrix} \\;=\\; \\begin{pmatrix}140 \\\\ 1250\\end{pmatrix}\n$$\n给出 $Y_{P,n+1} = 140/2440 = 7/122 \\approx 0.05737705$ 并且\n$$\nY_{D,n+1} \\;=\\; \\frac{1250 + 900\\,Y_{P,n+1}}{1505} \\;=\\; \\frac{1250 + 900\\cdot (7/122)}{1505} \\;=\\; \\frac{79400}{91805} \\;\\approx\\; 0.86487683,\n$$\n与牛顿更新的结果一致。将每个分量四舍五入到六位有效数字，得到所要求的结果：\n$$\n\\mathbf{Y}_{n+1} \\;\\approx\\; \\begin{pmatrix}0.0573770 \\\\ 0.864877\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}0.0573770  0.864877\\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了单个时间步的力学原理后，我们将转向物理建模的一个关键方面：守恒律的强制执行。本练习  演示了一种强大的技术，即使在极端刚性和病态条件下，也能保持重子数和电荷等物理量的机器精度守恒。通过在独立变量构成的降维空间中重新表述问题，求解器在分析上变得守恒，这对于长时标的天体物理模拟至关重要。",
            "id": "3576969",
            "problem": "考虑一个由四种核素组成的封闭核反应网络，核素由 $i \\in \\{0,1,2,3\\}$ 索引，其单位重子的摩尔丰度为 $Y_i(t)$，其中 $Y_i(t) \\ge 0$，$t$ 表示时间，单位为秒。这些核素对应一组理想化的同位素，其重子数 $A_i$ 和电荷数 $Z_i$ 分别由 $A = [1,1,2,3]$ 和 $Z = [0,1,1,2]$ 给出。正向和反向反应遵循质量作用定律，构建的网络在每次反应中都保持重子数和核电荷守恒。两个反应通道为：$n + p \\leftrightarrow d$ 和 $d + p \\leftrightarrow {}^3\\mathrm{He}$，有效速率系数为 $k_{1,\\mathrm{f}}$、$k_{1,\\mathrm{r}}$、$k_{2,\\mathrm{f}}$ 和 $k_{2,\\mathrm{r}}$，单位均为秒的倒数。单位重子的摩尔丰度 $Y_i$ 是无量纲的。\n\n控制该系统的常微分方程（ODE）组由质量作用下的通量守恒导出，具有通用形式 $dY/dt = F(Y)$，其中 $F(Y)$ 是所有核素的净生成速率矢量。在某些测试案例中，由于速率幅度跨越多个数量级，该网络表现出极端的刚性和病态特性。\n\n从质量作用动力学、化学计量守恒和连续时间演化 $dY/dt$ 的基本事实出发，设计并实现一个自洽的数值求解器，该求解器需满足以下条件：\n- 使用对极端刚性问题具有鲁棒性的时间离散化方法来积分该ODE系统。\n- 在每个时间步中，强制重子数 $\\sum_i A_i Y_i$ 和电荷数 $\\sum_i Z_i Y_i$ 的守恒达到机器精度（在双精度机器ε范围内），不受刚性和病态条件的影响。\n- 在整个积分过程中保持丰度的非负性 $Y_i \\ge 0$。\n\n您必须实现一个算法，该算法能够生成在指定数量的固定大小时间步 $\\Delta t$ 上的数值解 $Y(t)$，并通过报告在所有步骤中不变量 $\\sum_i A_i Y_i$ 和 $\\sum_i Z_i Y_i$ 与其初始值的最大绝对偏差来验证守恒性。双精度的机器ε约为 $2^{-53}$，您的求解器应达到此数量级的守恒误差。\n\n时间以秒为单位。所有速率以秒的倒数（s$^{-1}$）表示。丰度 $Y_i$ 是无量纲的。输出值为无量纲浮点数。\n\n使用以下参数集测试套件来检验刚性和病态的不同方面。对于每个测试用例，都指定了初始丰度 $Y(0)$、速率、时间步长 $\\Delta t$ 和步数 $N_{\\text{steps}}$。初始重子数 $B_0 = \\sum_i A_i Y_i(0)$ 和电荷数 $C_0 = \\sum_i Z_i Y_i(0)$ 由初始 $Y(0)$ 设定，且必须守恒。\n\n测试用例1（一般刚性但适中）：\n- $Y(0) = [0.38, 0.36, 0.10, 0.02]$\n- $k_{1,\\mathrm{f}} = 10^{2}$，$k_{1,\\mathrm{r}} = 10^{-2}$，$k_{2,\\mathrm{f}} = 3 \\times 10^{2}$，$k_{2,\\mathrm{r}} = 10^{-3}$\n- $\\Delta t = 10^{-3}$，$N_{\\text{steps}} = 300$\n\n测试用例2（极端刚性且速率非常病态）：\n- $Y(0) = [0.5, 0.5, 0.0, 0.0]$\n- $k_{1,\\mathrm{f}} = 10^{20}$，$k_{1,\\mathrm{r}} = 10^{-20}$，$k_{2,\\mathrm{f}} = 10^{15}$，$k_{2,\\mathrm{r}} = 10^{-25}$\n- $\\Delta t = 10^{-8}$，$N_{\\text{steps}} = 100$\n\n测试用例3（由相反通道引起的刻意病态）：\n- $Y(0) = [0.38, 0.36, 0.10, 0.02]$\n- $k_{1,\\mathrm{f}} = 10^{12}$，$k_{1,\\mathrm{r}} = 10^{-3}$，$k_{2,\\mathrm{f}} = 10^{-3}$，$k_{2,\\mathrm{r}} = 10^{12}$\n- $\\Delta t = 10^{-4}$，$N_{\\text{steps}} = 400$\n\n测试用例4（由于分量趋于零导致的近奇异雅可比矩阵）：\n- $Y(0) = [1 - 10^{-16}, 10^{-16}, 0.0, 0.0]$\n- $k_{1,\\mathrm{f}} = 10^{8}$，$k_{1,\\mathrm{r}} = 10^{-8}$，$k_{2,\\mathrm{f}} = 10^{8}$，$k_{2,\\mathrm{r}} = 10^{-8}$\n- $\\Delta t = 10^{-6}$，$N_{\\text{steps}} = 50$\n\n您的程序必须为每个测试用例输出两个浮点数：重子数守恒的最大绝对违背量 $\\max_{n} \\left| \\sum_i A_i Y_i^n - B_0 \\right|$ 和电荷数守恒的最大绝对违背量 $\\max_{n} \\left| \\sum_i Z_i Y_i^n - C_0 \\right|$，其中 $Y_i^n$ 表示第 $n$ 步结束时的丰度。求解器必须在每一步都以机器精度守恒为目标。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。首先是测试用例1的两个浮点数，然后是测试用例2的两个浮点数，依此类推，总共产生八个数字。例如，输出格式必须与 $[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8]$ 完全一致，其中每个 $r_k$ 是一个浮点数。",
            "solution": "该问题要求为描述核反应网络的常微分方程（ODE）组设计并实现一个数值求解器。该求解器必须能抵抗极端的数值刚性，并且至关重要的是，必须在每个时间步强制重子数和电荷数守恒到机器精度，同时还要保持核素丰度的非负性。\n\n首先，我们将ODE系统形式化。核素索引为0（中子，n）、1（质子，p）、2（氘核，d）和3（氦-3, ${}^3\\mathrm{He}$）。它们的丰度是 $Y_i(t)$。重子数为 $A=[1, 1, 2, 3]$，电荷数为 $Z=[0, 1, 1, 2]$。反应为 $n+p \\leftrightarrow d$（通道1）和 $d+p \\leftrightarrow {}^3\\mathrm{He}$（通道2）。\n\n根据质量作用定律，这些反应的净速率 $R_1$ 和 $R_2$ 为：\n$$R_1 = k_{1,\\mathrm{f}} Y_0 Y_1 - k_{1,\\mathrm{r}} Y_2$$\n$$R_2 = k_{2,\\mathrm{f}} Y_2 Y_1 - k_{2,\\mathrm{r}} Y_3$$\nODE系统 $dY/dt = F(Y)$ 是根据化学计量变化构建的：\n$$\\frac{dY_0}{dt} = -R_1 = -k_{1,\\mathrm{f}} Y_0 Y_1 + k_{1,\\mathrm{r}} Y_2$$\n$$\\frac{dY_1}{dt} = -R_1 - R_2 = (-k_{1,\\mathrm{f}} Y_0 Y_1 + k_{1,\\mathrm{r}} Y_2) - (k_{2,\\mathrm{f}} Y_2 Y_1 - k_{2,\\mathrm{r}} Y_3)$$\n$$\\frac{dY_2}{dt} = +R_1 - R_2 = (+k_{1,\\mathrm{f}} Y_0 Y_1 - k_{1,\\mathrm{r}} Y_2) - (k_{2,\\mathrm{f}} Y_2 Y_1 - k_{2,\\mathrm{r}} Y_3)$$\n$$\\frac{dY_3}{dt} = +R_2 = +k_{2,\\mathrm{f}} Y_2 Y_1 - k_{2,\\mathrm{r}} Y_3$$\n\n该问题的主要约束是总重子数 $B = \\sum_i A_i Y_i$ 和总电荷数 $C = \\sum_i Z_i Y_i$ 的精确守恒。解析的ODE系统内在地保持了这些量的守恒，因为 $\\frac{dB}{dt} = \\sum_i A_i \\frac{dY_i}{dt} = 0$ 和 $\\frac{dC}{dt} = \\sum_i Z_i \\frac{dY_i}{dt} = 0$。然而，标准的数值积分器会累积浮点误差，导致这些不变量随时间漂移。\n\n为了强制守恒达到机器精度，我们利用这两个线性守恒定律来降低系统的维数。这个4维系统受两个线性代数约束，意味着只有 $4-2=2$ 个独立的自由度。我们可以用另外两个丰度（比如 $Y_2$ 和 $Y_3$）以及初始（且恒定）的总重子数 $B_0$ 和总电荷数 $C_0$ 来表示其中的两个丰度（比如 $Y_0$ 和 $Y_1$）：\n$$B_0 = Y_0 + Y_1 + 2Y_2 + 3Y_3$$\n$$C_0 = Y_1 + Y_2 + 2Y_3$$\n解这个关于 $Y_0$ 和 $Y_1$ 的线性系统，得到：\n$$Y_1 = C_0 - Y_2 - 2Y_3$$\n$$Y_0 = B_0 - C_0 - Y_2 - Y_3$$\n通过将这些表达式代入 $Y_2$ 和 $Y_3$ 的ODE中，我们得到了一个降维的、自治的二维ODE系统，其向量为 $y=[Y_2, Y_3]^T$：\n$$\\frac{d}{dt}\\begin{pmatrix} Y_2 \\\\ Y_3 \\end{pmatrix} = g(Y_2, Y_3; B_0, C_0)$$\n这种表述保证了对于任何解 $(Y_2(t), Y_3(t))$，重构的完整向量 $Y(t)$ 将在解析上满足守恒定律。唯一的守恒误差来源将是最终求和检查中浮点运算的有限精度，这与“机器精度”的要求是一致的。\n\n问题的测试用例涉及极端刚性，需要使用隐式时间积分方案。后向欧拉法是适用于此问题的最简单的A-稳定方法。单步计算公式为：\n$$y^{n+1} = y^n + \\Delta t \\, g(y^{n+1})$$\n这是一个关于 $y^{n+1}$ 的非线性方程组，必须在每个时间步求解。我们采用牛顿-拉弗森（Newton-Raphson）方法。令 $H(y) = y - y^n - \\Delta t \\, g(y) = 0$。迭代更新为：\n$$J_H(y_k) \\Delta y_k = -H(y_k)$$\n$$y_{k+1} = y_k + \\alpha \\Delta y_k$$\n其中 $J_H(y) = I - \\Delta t J_g(y)$ 是 $H$ 的雅可比矩阵，$J_g$ 是降维后的右侧函数 $g(y)$ 的雅可比矩阵，$\\alpha \\in (0, 1]$ 是一个阻尼因子。雅可比矩阵 $J_g$ 是一个 $2 \\times 2$ 矩阵，其元素通过使用链式法则对 $g$ 关于 $Y_2$ 和 $Y_3$ 求导得出。\n\n最后的约束是保持非负性 $Y_i \\ge 0$。牛顿-拉弗森更新步长 $\\Delta y_k$ 本身不保证这一点。我们引入一个阻尼因子 $\\alpha$（也称为回溯线搜索），如果完整步长会导致任何 $Y_i  0$，就缩短牛顿步长。我们从 $\\alpha=1$ 开始，并连续将其减半，直到更新后的状态 $y_{k+1}$ 对应于所有 $Y_i \\ge 0$ 的物理有效点。\n\n每个时间步的整体算法如下：\n1. 从上一步的解 $Y^n$ 开始。降维后的状态是 $y^n = [Y^n_2, Y^n_3]$。\n2. 使用 $y^n$ 作为牛顿-拉弗森求解器的初始猜测值 $y_0$。\n3. 迭代：\n    a. 从 $y_k$ 和不变量 $B_0, C_0$ 重构完整的状态向量 $Y_k$。\n    b. 计算残差 $H(y_k)$ 及其雅可比矩阵 $J_H(y_k)$。\n    c. 求解线性系统 $J_H \\Delta y_k = -H(y_k)$ 以获得牛顿更新步长 $\\Delta y_k$。\n    d. 确定一个阻尼因子 $\\alpha \\in (0,1]$，以确保更新后的状态 $y_k + \\alpha \\Delta y_k$ 对所有四种丰度都保持非负性。\n    e. 应用带阻尼的更新：$y_{k+1} = y_k + \\alpha \\Delta y_k$。\n4. 一旦牛顿-拉弗森方法收敛，得到的 $y^{n+1}$ 用于重构完整的、物理上一致且守恒的状态 $Y^{n+1}$。\n这种方法是鲁棒、稳定的，并严格遵守问题的所有约束。",
            "answer": "```python\nimport numpy as np\n\n# These are physical constants of the system, defined as ndarrays for vectorized operations.\nA_BARYON = np.array([1.0, 1.0, 2.0, 3.0], dtype=np.float64)\nZ_CHARGE = np.array([0.0, 1.0, 1.0, 2.0], dtype=np.float64)\n\ndef _backward_euler_step(Y_n, rates, dt, B0, C0):\n    \"\"\"\n    Performs a single time step using the backward Euler method on the reduced system.\n    The nonlinear system is solved using a damped Newton-Raphson method.\n    \"\"\"\n    k1f, k1r, k2f, k2r = rates\n    \n    # The system is reduced to two independent variables, y = [Y2, Y3].\n    y_n = Y_n[2:4]\n    y_k = np.copy(y_n)  # Initial guess for Newton's method is the solution from the previous step.\n\n    # Newton-Raphson solver parameters\n    max_iterations = 25\n    tolerance = 1e-14\n\n    for _ in range(max_iterations):\n        # From the reduced state y_k=[Y2, Y3], reconstruct the full abundance vector.\n        Y2_k, Y3_k = y_k\n        Y1_k = C0 - Y2_k - 2 * Y3_k\n        Y0_k = B0 - C0 - Y2_k - Y3_k\n        \n        # Evaluate the right-hand-side (RHS) of the reduced ODE system, g(y_k).\n        R1_k = k1f * Y0_k * Y1_k - k1r * Y2_k\n        R2_k = k2f * Y1_k * Y2_k - k2r * Y3_k\n        g_k = np.array([R1_k - R2_k, R2_k])\n\n        # Evaluate the residual of the backward Euler implicit equation: H(y_k) = y_k - y_n - dt * g(y_k) = 0.\n        residual = y_k - y_n - dt * g_k\n        \n        if np.linalg.norm(residual)  tolerance:\n            break\n\n        # Analytically compute the Jacobian of the reduced RHS, J_g.\n        dR1dY2 = k1f * (-Y1_k - Y0_k) - k1r\n        dR1dY3 = k1f * (-Y1_k - 2 * Y0_k)\n        dR2dY2 = k2f * (Y1_k - Y2_k)\n        dR2dY3 = -2 * k2f * Y2_k - k2r\n\n        J_g = np.array([\n            [dR1dY2 - dR2dY2, dR1dY3 - dR2dY3],\n            [dR2dY2,          dR2dY3]\n        ])\n\n        # Form the Newton iteration matrix: J_H = I - dt * J_g.\n        J_H = np.identity(2) - dt * J_g\n        \n        # Solve the linear system J_H * dy = -residual for the Newton step dy.\n        try:\n            dy_k = np.linalg.solve(J_H, -residual)\n        except np.linalg.LinAlgError:\n            # If the Jacobian is singular, the Newton step fails.\n            # Use pseudo-inverse for robustness, e.g. in case of near-singular Jacobians.\n            dy_k = np.linalg.pinv(J_H) @ -residual\n\n        # --- Damping of the Newton step (backtracking line search) to enforce positivity ---\n        alpha = 1.0 # Start with a full Newton step.\n        for i in range(10): # Max 10 halving steps\n            y_next_test = y_k + alpha * dy_k\n            Y2_next, Y3_next = y_next_test\n            Y1_next = C0 - Y2_next - 2 * Y3_next\n            Y0_next = B0 - C0 - Y2_next - Y3_next\n            \n            if Y0_next >= 0 and Y1_next >= 0 and Y2_next >= 0 and Y3_next >= 0:\n                break\n            alpha /= 2.0\n        \n        y_k += alpha * dy_k\n    \n    # Reconstruct the full state vector from the converged reduced state.\n    Y_next = np.zeros(4, dtype=np.float64)\n    Y_next[2], Y_next[3] = y_k\n    Y_next[1] = C0 - Y_next[2] - 2 * Y_next[3]\n    Y_next[0] = B0 - C0 - Y_next[2] - Y_next[3]\n\n    # Clip any small-magnitude negative values that might arise from floating point inaccuracies.\n    Y_next[Y_next  0] = 0.0\n    \n    return Y_next\n\ndef run_integration_case(Y0, rates, dt, n_steps):\n    \"\"\"\n    Runs the integration for a single test case and returns conservation errors.\n    \"\"\"\n    Y_current = np.array(Y0, dtype=np.float64)\n\n    # The conserved quantities are determined by the initial conditions.\n    B0 = np.sum(A_BARYON * Y_current)\n    C0 = np.sum(Z_CHARGE * Y_current)\n\n    max_baryon_deviation = 0.0\n    max_charge_deviation = 0.0\n\n    # Main time-stepping loop\n    for _ in range(n_steps):\n        Y_current = _backward_euler_step(Y_current, rates, dt, B0, C0)\n        \n        # Verify conservation by re-calculating the sums.\n        # The deviation from the initial values should be on the order of machine epsilon\n        # due to floating-point summation error, as the method is analytically conservative.\n        current_baryon_sum = np.sum(A_BARYON * Y_current)\n        current_charge_sum = np.sum(Z_CHARGE * Y_current)\n        \n        baryon_dev = np.abs(current_baryon_sum - B0)\n        charge_dev = np.abs(current_charge_sum - C0)\n\n        if baryon_dev > max_baryon_deviation: max_baryon_deviation = baryon_dev\n        if charge_dev > max_charge_deviation: max_charge_deviation = charge_dev\n\n    return max_baryon_deviation, max_charge_deviation\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and report on the test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"Y0\": [0.38, 0.36, 0.10, 0.02],\n            \"rates\": [1e2, 1e-2, 3e2, 1e-3],\n            \"dt\": 1e-3,\n            \"n_steps\": 300,\n        },\n        {\n            \"Y0\": [0.5, 0.5, 0.0, 0.0],\n            \"rates\": [1e20, 1e-20, 1e15, 1e-25],\n            \"dt\": 1e-8,\n            \"n_steps\": 100,\n        },\n        {\n            \"Y0\": [0.38, 0.36, 0.10, 0.02],\n            \"rates\": [1e12, 1e-3, 1e-3, 1e12],\n            \"dt\": 1e-4,\n            \"n_steps\": 400,\n        },\n        {\n            \"Y0\": [1.0 - 1e-16, 1e-16, 0.0, 0.0],\n            \"rates\": [1e8, 1e-8, 1e8, 1e-8],\n            \"dt\": 1e-6,\n            \"n_steps\": 50,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        b_dev, c_dev = run_integration_case(\n            case[\"Y0\"], case[\"rates\"], case[\"dt\"], case[\"n_steps\"]\n        )\n        results.extend([b_dev, c_dev])\n\n    # Format the final output as a single-line string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "现在，我们将从求解孤立的反应网络，转向处理更现实的多物理场问题。本练习  介绍了 Strang 分裂法，这是一种用于耦合不同物理过程的二阶精度方法，此处用于耦合核反应与热演化。你将实现该方案，并通过与完全耦合的参考解进行比较来量化“分裂误差”，从而深入了解这种模块化方法的准确性。",
            "id": "3576961",
            "problem": "考虑一个质量密度恒定的单区反应介质，其被建模为一个含有一种反应物种的热演化系统。热力学状态由温度 $T$（单位为 $\\mathrm{GK}$，即 $10^9\\,\\mathrm{K}$）和燃料质量分数 $X$（无量纲）来表征。状态方程为类理想气体形式，具有恒定的定容比热，因此核能释放通过一个常数因子转化为温度升高。耦合控制方程为以下常微分方程（ODEs）组：\n$$\n\\frac{dX}{dt} = -k(T)\\,X,\\qquad \\frac{dT}{dt} = S_{\\mathrm{ext}}(T) + \\alpha\\,k(T)\\,X,\n$$\n其中 $t$ 是时间，单位为 $\\mathrm{s}$；$k(T)$ 是一个与温度相关的反应速率；$S_{\\mathrm{ext}}(T)$ 是一个不依赖于组分的外部热源项（例如，与环境温度之间的线性化辐射冷却）；$\\alpha$ 是一个常数，用于将单位燃料变化的核能释放转化为温度增量。您需要为此系统构建一个 Strang 分裂算法，在一个全局时间步长 $\\Delta t$ 上交替执行纯温度更新和反应求解。\n\n基本依据：\n- 与温度相关的反应速率采用类阿伦尼乌斯形式，\n$$\nk(T) = k_0\\,T^{\\nu}\\,\\exp\\!\\left(-\\frac{E_a}{T}\\right),\n$$\n其中 $T$ 的单位为 $\\mathrm{GK}$，$k_0$ 的单位为 $\\mathrm{s}^{-1}$，$\\nu$ 是一个无量纲指数，$E_a$ 是一个活化参数，单位为 $\\mathrm{GK}$。\n- 外部热源是向环境温度 $T_{\\mathrm{amb}}$ 的线性冷却，速率为 $\\Lambda$，\n$$\nS_{\\mathrm{ext}}(T) = -\\Lambda\\,(T - T_{\\mathrm{amb}}),\n$$\n其中 $\\Lambda$ 的单位为 $\\mathrm{s}^{-1}$，$T_{\\mathrm{amb}}$ 的单位为 $\\mathrm{GK}$。\n- 因子 $\\alpha$ 的单位为 $\\mathrm{GK}$，表示由于核能释放，每单位 $X$ 减少所引起的温度升高除以定容比热。\n\n算子分裂：\n- 定义算子 $\\mathcal{A}$ 为在 $X$ 保持恒定时，由 $S_{\\mathrm{ext}}(T)$ 引起的纯温度演化：\n$$\n\\mathcal{A}:\\quad \\frac{dT}{dt} = S_{\\mathrm{ext}}(T),\\quad \\frac{dX}{dt} = 0.\n$$\n- 定义算子 $\\mathcal{B}$ 为包含核加热且无外部源的反应演化：\n$$\n\\mathcal{B}:\\quad \\frac{dX}{dt} = -k(T)\\,X,\\quad \\frac{dT}{dt} = \\alpha\\,k(T)\\,X.\n$$\n\n在一个给定的 $\\Delta t$ 上实现一个 Strang 分裂步，具体如下：\n- 对 $\\Delta t/2$ 应用 $\\mathcal{A}$，\n- 对 $\\Delta t$ 应用 $\\mathcal{B}$，\n- 对 $\\Delta t/2$ 应用 $\\mathcal{A}$。\n\n对于算子 $\\mathcal{A}$，其演化是一个关于 $T$ 的标量线性常微分方程，可以在任何时间增量 $\\tau$ 上精确积分：\n$$\nT(t+\\tau) = T_{\\mathrm{amb}} + \\big(T(t) - T_{\\mathrm{amb}}\\big)\\,\\exp\\!\\big(-\\Lambda\\,\\tau\\big),\\qquad X\\ \\text{保持不变}.\n$$\n对于算子 $\\mathcal{B}$，由于速率与温度相关，该系统通常是刚性的；使用刚性常微分方程（ODE）求解器在所需区间上进行数值积分。假设密度恒定且状态方程在整个过程中保持有效。\n\n为估计一个全局步长的分裂误差，通过使用具有严格容差的刚性 ODE 方法对完整耦合系统（不进行分裂）在相同的 $\\Delta t$ 上积分，计算一个高精度参考解。将无量纲误差度量定义为 $X$ 的绝对差和相对温度差的均方根，即\n$$\n\\varepsilon = \\sqrt{\\frac{1}{2}\\left(\\big(X_{\\mathrm{split}} - X_{\\mathrm{ref}}\\big)^2 + \\left(\\frac{T_{\\mathrm{split}} - T_{\\mathrm{ref}}}{T_{\\mathrm{ref}}}\\right)^2\\right)}.\n$$\n您的任务是实现一个完整的、可运行的程序，该程序：\n- 编码上述模型，并为下面的每个测试用例执行一个 Strang 分裂步，\n- 计算相应 $\\Delta t$ 的高精度参考解，\n- 为每个测试用例输出分裂误差 $\\varepsilon$，形式为浮点十进制数。\n\n单位和数值报告要求：\n- 时间 $t$ 和 $\\Delta t$ 的单位必须是 $\\mathrm{s}$，温度 $T$ 的单位是 $\\mathrm{GK}$，$X$ 是无量纲的。\n- 输出的误差是无量纲的，必须以科学记数法打印，并精确到 $10$ 位有效数字。\n\n测试套件：\n使用以下参数集，每个参数集定义一个初值问题，初始条件在 $t=0$ 时为 $X(0)=X_0$ 和 $T(0)=T_0$：\n- 情况 $1$（中等耦合，小步长）：$k_0 = 10\\,\\mathrm{s}^{-1}$，$\\nu = 5$，$E_a = 0.3\\,\\mathrm{GK}$，$\\alpha = 0.1\\,\\mathrm{GK}$，$\\Lambda = 1.0\\,\\mathrm{s}^{-1}$，$T_{\\mathrm{amb}} = 0.5\\,\\mathrm{GK}$，$X_0=1.0$，$T_0=1.0\\,\\mathrm{GK}$，$\\Delta t = 1.0\\times 10^{-3}\\,\\mathrm{s}$。\n- 情况 $2$（中等耦合，较大步长）：$k_0 = 10\\,\\mathrm{s}^{-1}$，$\\nu = 5$，$E_a = 0.3\\,\\mathrm{GK}$，$\\alpha = 0.1\\,\\mathrm{GK}$，$\\Lambda = 1.0\\,\\mathrm{s}^{-1}$，$T_{\\mathrm{amb}} = 0.5\\,\\mathrm{GK}$，$X_0=1.0$，$T_0=1.0\\,\\mathrm{GK}$，$\\Delta t = 1.0\\times 10^{-2}\\,\\mathrm{s}$。\n- 情况 $3$（无外部源）：$k_0 = 10\\,\\mathrm{s}^{-1}$，$\\nu = 5$，$E_a = 0.3\\,\\mathrm{GK}$，$\\alpha = 0.1\\,\\mathrm{GK}$，$\\Lambda = 0.0\\,\\mathrm{s}^{-1}$，$T_{\\mathrm{amb}} = 0.5\\,\\mathrm{GK}$，$X_0=1.0$，$T_0=1.0\\,\\mathrm{GK}$，$\\Delta t = 1.0\\times 10^{-2}\\,\\mathrm{s}$。\n- 情况 $4$（更高活化能垒）：$k_0 = 10\\,\\mathrm{s}^{-1}$，$\\nu = 5$，$E_a = 0.6\\,\\mathrm{GK}$，$\\alpha = 0.1\\,\\mathrm{GK}$，$\\Lambda = 1.0\\,\\mathrm{s}^{-1}$，$T_{\\mathrm{amb}} = 0.5\\,\\mathrm{GK}$，$X_0=1.0$，$T_0=1.0\\,\\mathrm{GK}$，$\\Delta t = 1.0\\times 10^{-2}\\,\\mathrm{s}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含情况 $1$ 到 $4$ 的误差，按顺序排列，作为一个用方括号括起来的逗号分隔列表，每个数字均采用科学记数法，并精确到 $10$ 位有效数字（例如，$[1.2345678900e-03,2.3456789000e-04, \\ldots]$）。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它具有科学依据、良定、客观且完整。它提出了一个计算物理学中的标准问题：评估耦合常微分方程（ODEs）系统的算子分裂误差。因此，我们可以着手求解。\n\n该问题要求我们计算一个简化反应网络模型使用 Strang 分裂方案所引入的误差。系统的状态由向量 $\\mathbf{y} = [X, T]^\\top$ 描述，其中 $X$ 是燃料质量分数，$T$ 是温度。控制方程为：\n$$\n\\frac{d\\mathbf{y}}{dt} = \\frac{d}{dt}\\begin{pmatrix} X \\\\ T \\end{pmatrix} = \\begin{pmatrix} -k(T)\\,X \\\\ S_{\\mathrm{ext}}(T) + \\alpha\\,k(T)\\,X \\end{pmatrix}\n$$\n右侧可以分裂为两个算子，$\\mathcal{A}$ 和 $\\mathcal{B}$。算子 $\\mathcal{A}$ 代表外部热耦合（冷却），算子 $\\mathcal{B}$ 代表反应及相关的自加热。\n$$\n\\frac{d\\mathbf{y}}{dt} = \\underbrace{\\begin{pmatrix} 0 \\\\ S_{\\mathrm{ext}}(T) \\end{pmatrix}}_{\\mathcal{A}(\\mathbf{y})} + \\underbrace{\\begin{pmatrix} -k(T)\\,X \\\\ \\alpha\\,k(T)\\,X \\end{pmatrix}}_{\\mathcal{B}(\\mathbf{y})}\n$$\n其中反应速率 $k(T)$ 和外部源 $S_{\\mathrm{ext}}(T)$ 定义为：\n$$\nk(T) = k_0\\,T^{\\nu}\\,\\exp\\!\\left(-\\frac{E_a}{T}\\right)\n$$\n$$\nS_{\\mathrm{ext}}(T) = -\\Lambda\\,(T - T_{\\mathrm{amb}})\n$$\nStrang 分裂是一种二阶精度的算子分裂方法。对于一个时间步长 $\\Delta t$，在 $t=0$ 时的状态 $\\mathbf{y}_0$ 通过对称序列组合演化算子，演化到 $t=\\Delta t$ 时的状态 $\\mathbf{y}_{\\mathrm{split}}$：\n$$\n\\mathbf{y}_{\\mathrm{split}} = \\Phi_{\\mathcal{A}}(\\Delta t/2) \\circ \\Phi_{\\mathcal{B}}(\\Delta t) \\circ \\Phi_{\\mathcal{A}}(\\Delta t/2) (\\mathbf{y}_0)\n$$\n其中 $\\Phi_{\\mathcal{O}}(\\tau)$ 表示在算子 $\\mathcal{O}$ 下演化时间间隔 $\\tau$ 的精确或数值解。\n\n对于每个测试用例，求解过程将分为三个主要部分：\n$1$. 计算 Strang 分裂解 $\\mathbf{y}_{\\mathrm{split}}$。\n$2$. 计算高精度参考解 $\\mathbf{y}_{\\mathrm{ref}}$。\n$3$. 计算分裂误差 $\\varepsilon$。\n\n**1. Strang 分裂解, $\\mathbf{y}_{\\mathrm{split}} = [X_{\\mathrm{split}}, T_{\\mathrm{split}}]^\\top$**\n\n计算遵循规定的三个步骤，从初始状态 $\\mathbf{y}(0) = [X_0, T_0]^\\top$ 开始。\n\n*   **步骤 1：在 $\\mathcal{A}$ 下的第一个半步**\n    我们在 $\\frac{d\\mathbf{y}}{dt} = \\mathcal{A}(\\mathbf{y})$ 下演化系统，时长为 $\\tau = \\Delta t/2$。方程为 $\\frac{dX}{dt}=0$ 和 $\\frac{dT}{dt}=-\\Lambda(T-T_{\\mathrm{amb}})$。其解析解为：\n    $$\n    X_1 = X_0\n    $$\n    $$\n    T_1 = T_{\\mathrm{amb}} + (T_0 - T_{\\mathrm{amb}})\\,\\exp(-\\Lambda\\,\\Delta t/2)\n    $$\n    这产生一个中间状态 $\\mathbf{y}_1 = [X_1, T_1]^\\top$。\n\n*   **步骤 2：在 $\\mathcal{B}$ 下的完整步**\n    接下来，我们从 $\\mathbf{y}_1$ 开始，在 $\\frac{d\\mathbf{y}}{dt} = \\mathcal{B}(\\mathbf{y})$ 下演化系统，时长为 $\\tau = \\Delta t$。控制 ODEs 为：\n    $$\n    \\frac{dX}{dt} = -k(T)\\,X, \\qquad \\frac{dT}{dt} = \\alpha\\,k(T)\\,X\n    $$\n    这是一个非线性耦合系统，由于 $k(T)$ 的指数依赖性，它可能是刚性的。我们使用高质量的刚性 ODE 求解器进行数值积分。将使用 `scipy.integrate.solve_ivp` 函数及其 `Radau` 方法，这是一种适用于刚性问题的隐式龙格-库塔方法。积分在时间区间 $[0, \\Delta t]$ 上进行，初始条件为 $\\mathbf{y}_1$。结果是状态 $\\mathbf{y}_2 = [X_2, T_2]^\\top$。\n\n*   **步骤 3：在 $\\mathcal{A}$ 下的第二个半步**\n    最后，我们将状态 $\\mathbf{y}_2$ 在算子 $\\mathcal{A}$ 下再演化一个时长为 $\\tau = \\Delta t/2$。使用与步骤 1 相同的解析解：\n    $$\n    X_{\\mathrm{split}} = X_2\n    $$\n    $$\n    T_{\\mathrm{split}} = T_{\\mathrm{amb}} + (T_2 - T_{\\mathrm{amb}})\\,\\exp(-\\Lambda\\,\\Delta t/2)\n    $$\n    这给出经过一个 Strang 分裂步后的最终状态 $\\mathbf{y}_{\\mathrm{split}} = [X_{\\mathrm{split}}, T_{\\mathrm{split}}]^\\top$。\n\n**2. 高精度参考解, $\\mathbf{y}_{\\mathrm{ref}} = [X_{\\mathrm{ref}}, T_{\\mathrm{ref}}]^\\top$**\n\n为了量化分裂误差，需要一个高精度的参考解。这通过在相同的全局时间步长 $\\Delta t$ 上数值积分完整的、未分裂的 ODEs 系统来获得：\n$$\n\\frac{dX}{dt} = -k(T)\\,X\n$$\n$$\n\\frac{dT}{dt} = -\\Lambda\\,(T - T_{\\mathrm{amb}}) + \\alpha\\,k(T)\\,X\n$$\n我们使用相同的刚性 ODE 求解器，即 `scipy.integrate.solve_ivp` 和 `Radau` 方法，但采用非常严格的绝对和相对误差容限（例如，$10^{-13}$），以最小化数值积分误差，从而确保计算出的解能够忠实地代表真实解。积分在 $[0, \\Delta t]$ 上进行，初始条件为 $\\mathbf{y}_0 = [X_0, T_0]^\\top$。\n\n**3. 分裂误差计算, $\\varepsilon$**\n\n分裂误差 $\\varepsilon$ 使用指定的无量纲均方根度量来计算，比较分裂解和参考解的最终状态：\n$$\n\\varepsilon = \\sqrt{\\frac{1}{2}\\left(\\big(X_{\\mathrm{split}} - X_{\\mathrm{ref}}\\big)^2 + \\left(\\frac{T_{\\mathrm{split}} - T_{\\mathrm{ref}}}{T_{\\mathrm{ref}}}\\right)^2\\right)}\n$$\n对所提供的四个测试用例中的每一个重复此过程。实现将被封装在一个 Python 脚本中，该脚本系统地应用这些步骤，并按要求格式化所得误差。一个值得关注的特例是情况 3，其中 $\\Lambda=0$。在这种情况下，算子 $\\mathcal{A}$ 成为单位算子，完整系统与算子 $\\mathcal{B}$ 相同。因此，Strang 分裂过程和参考解的计算都简化为对 $\\mathcal{B}$ 系统的一次积分，理论误差 $\\varepsilon$ 应为零。这为实现提供了一个有价值的内部一致性检查。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the reactive medium ODE problem using Strang splitting and\n    computes the splitting error against a high-accuracy reference solution.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (k0, nu, Ea, alpha, Lambda, T_amb, X0, T0, dt)\n    test_cases = [\n        # Case 1 (moderate coupling, small step)\n        (10.0, 5.0, 0.3, 0.1, 1.0, 0.5, 1.0, 1.0, 1.0e-3),\n        # Case 2 (moderate coupling, larger step)\n        (10.0, 5.0, 0.3, 0.1, 1.0, 0.5, 1.0, 1.0, 1.0e-2),\n        # Case 3 (no external source)\n        (10.0, 5.0, 0.3, 0.1, 0.0, 0.5, 1.0, 1.0, 1.0e-2),\n        # Case 4 (higher activation barrier)\n        (10.0, 5.0, 0.6, 0.1, 1.0, 0.5, 1.0, 1.0, 1.0e-2),\n    ]\n\n    results = []\n    \n    # Set tight tolerances for the ODE solver to ensure high accuracy\n    # for both the reference solution and the operator B step.\n    TOL = 1e-13\n\n    for case in test_cases:\n        k0, nu, Ea, alpha, Lambda, T_amb, X0, T0, dt = case\n        \n        y0 = np.array([X0, T0])\n\n        # Define the reaction rate function k(T)\n        def k_rate(T):\n            if T = 0:\n                return 0.0\n            return k0 * T**nu * np.exp(-Ea / T)\n\n        # --- Strang Splitting Solution ---\n\n        # 1. Apply operator A for dt/2\n        # This is the analytical solution for the cooling term.\n        # X is unchanged. T evolves as T_new = T_amb + (T_old - T_amb) * exp(-Lambda * tau)\n        y1_X = y0[0]\n        y1_T = T_amb + (y0[1] - T_amb) * np.exp(-Lambda * dt / 2.0)\n        y1 = np.array([y1_X, y1_T])\n\n        # 2. Apply operator B for dt\n        # This is the numerical integration of the reaction part.\n        def B_rhs(t, y):\n            X, T = y\n            k_val = k_rate(T)\n            dX_dt = -k_val * X\n            dT_dt = alpha * k_val * X\n            return [dX_dt, dT_dt]\n        \n        sol_B = solve_ivp(B_rhs, [0, dt], y1, method='Radau', rtol=TOL, atol=TOL)\n        if not sol_B.success:\n            raise RuntimeError(f\"ODE integration for operator B failed for case {case}\")\n        y2 = sol_B.y[:, -1]\n\n        # 3. Apply operator A for dt/2 again\n        y_split_X = y2[0]\n        y_split_T = T_amb + (y2[1] - T_amb) * np.exp(-Lambda * dt / 2.0)\n        y_split = np.array([y_split_X, y_split_T])\n        X_split, T_split = y_split\n\n        # --- High-Accuracy Reference Solution ---\n        # Integrate the full coupled system without splitting.\n        def full_rhs(t, y):\n            X, T = y\n            k_val = k_rate(T)\n            S_ext = -Lambda * (T - T_amb)\n            dX_dt = -k_val * X\n            dT_dt = S_ext + alpha * k_val * X\n            return [dX_dt, dT_dt]\n\n        sol_ref = solve_ivp(full_rhs, [0, dt], y0, method='Radau', rtol=TOL, atol=TOL)\n        if not sol_ref.success:\n            raise RuntimeError(f\"ODE integration for reference solution failed for case {case}\")\n        y_ref = sol_ref.y[:, -1]\n        X_ref, T_ref = y_ref\n\n        # --- Error Calculation ---\n        # Calculate the dimensionless error measure epsilon.\n        err_X_sq = (X_split - X_ref)**2\n        err_T_sq = ((T_split - T_ref) / T_ref)**2\n        epsilon = np.sqrt(0.5 * (err_X_sq + err_T_sq))\n        results.append(epsilon)\n\n    # Final print statement in the exact required format.\n    # Format each result to scientific notation with 10 significant digits.\n    # The format specifier {:.9e} gives 1 digit before the decimal and 9 after.\n    formatted_results = [f\"{res:.9e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}