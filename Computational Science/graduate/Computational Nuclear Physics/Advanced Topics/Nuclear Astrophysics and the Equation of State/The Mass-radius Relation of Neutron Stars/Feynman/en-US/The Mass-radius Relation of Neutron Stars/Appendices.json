{
    "hands_on_practices": [
        {
            "introduction": "Before undertaking full-scale numerical simulations, it is crucial to build physical intuition about how the equation of state (EoS) determines the global properties of a neutron star. This foundational exercise uses the powerful technique of nondimensionalization to uncover the intrinsic scaling relationships within the Tolman-Oppenheimer-Volkoff (TOV) equations. By working with a simplified single-polytrope EoS, you will analytically derive how the maximum stellar mass, a key astrophysical observable, scales with the parameters that define the stiffness of dense matter .",
            "id": "3604301",
            "problem": "Consider a cold, spherically symmetric neutron star in hydrostatic equilibrium governed by General Relativity through the Tolman–Oppenheimer–Volkoff (TOV) equations (abbreviated on first appearance): \n$$\n\\frac{dp}{dr} \\;=\\; -\\frac{G\\left(\\epsilon + p\\right)\\left(m + 4\\pi r^{3}p\\right)}{r^{2}\\left(1 - \\frac{2Gm}{r}\\right)}\\,,\n\\qquad\n\\frac{dm}{dr} \\;=\\; 4\\pi r^{2}\\epsilon\\,,\n$$\nwhere $G$ is the gravitational constant, $r$ is the circumferential radius, $m(r)$ is the enclosed mass, $p(r)$ is the pressure, and $\\epsilon(r)$ is the total energy density. Throughout, set the speed of light to unity, $c=1$.\n\nAssume a single polytropic equation of state of the form $p = K\\rho^{\\Gamma}$, where $K0$ and $\\Gamma1$ are constants, and the energy density is given by $\\epsilon(\\rho) = \\rho + \\frac{p}{\\Gamma - 1}$ (cold barotropic matter). Let $p_{c}$ and $\\epsilon_{c}$ denote the central values of pressure and energy density, respectively, and define the dimensionless central compactness parameter $\\eta \\equiv \\frac{p_{c}}{\\epsilon_{c}}$.\n\nBy introducing appropriately scaled dimensionless variables for radius, mass, pressure, and energy density, nondimensionalize the TOV equations so that all explicit dependence on $K$ and dimensional scales is removed except for overall scale factors. Show that, for each fixed $\\Gamma$, the dimensionless mass becomes a one-parameter family indexed by $\\eta$, with a maximum attained at some $\\eta_{*}(\\Gamma)$, and that the corresponding dimensional maximum mass $M_{\\max}$ exhibits a power-law scaling with $K$.\n\nDerive the closed-form analytic expression for the $K$–$\\Gamma$ scaling of the maximum mass $M_{\\max}$ in terms of $G$, $K$, and a dimensionless coefficient that depends only on $\\Gamma$ (but not on $K$). Express your final result as a single analytic expression. No numerical evaluation or rounding is required. Do not include any units in your final answer.",
            "solution": "The problem requires the derivation of the scaling law for the maximum mass of a neutron star, $M_{\\max}$, as a function of the parameters $K$ and $\\Gamma$ from a polytropic equation of state, $p = K\\rho^{\\Gamma}$. This is accomplished by nondimensionalizing the Tolman–Oppenheimer–Volkoff (TOV) equations.\n\nThe TOV equations governing a static, spherically symmetric star in general relativity are given as:\n$$\n\\frac{dp}{dr} = -\\frac{G\\left(\\epsilon + p\\right)\\left(m + 4\\pi r^{3}p\\right)}{r^{2}\\left(1 - \\frac{2Gm}{r}\\right)}\n$$\n$$\n\\frac{dm}{dr} = 4\\pi r^{2}\\epsilon\n$$\nThe equation of state (EoS) is that of a cold barotropic fluid, where pressure $p$ is a function of rest-mass density $\\rho$, and the total energy density $\\epsilon$ is a function of $\\rho$:\n$$\np = K\\rho^{\\Gamma}\n$$\n$$\n\\epsilon = \\rho + \\frac{p}{\\Gamma - 1}\n$$\nHere, we have set the speed of light $c=1$.\n\nThe first step is to introduce a set of dimensionless variables, denoted with a bar. We define characteristic scales for radius ($L_0$), mass ($M_0$), energy density ($\\epsilon_0$), pressure ($P_0$), and rest-mass density ($\\rho_0$).\nLet:\n$$\nr = L_0 \\bar{r}, \\quad m = M_0 \\bar{m}, \\quad \\epsilon = \\epsilon_0 \\bar{\\epsilon}, \\quad p = P_0 \\bar{p}, \\quad \\rho = \\rho_0 \\bar{\\rho}\n$$\nGiven that $\\epsilon$, $p$, and $\\rho$ have the same physical dimensions in relativistic units (mass/volume, which becomes length/length$^3 = $ length$^{-2}$ since $c=1$ and $G$ is dimensionless), we can simplify by setting $\\epsilon_0 = P_0 = \\rho_0$.\n\nSubstituting these scaled variables into the mass-continuity equation:\n$$\n\\frac{d(M_0 \\bar{m})}{d(L_0 \\bar{r})} = 4\\pi (L_0 \\bar{r})^{2} (\\epsilon_0 \\bar{\\epsilon}) \\quad \\implies \\quad \\frac{M_0}{L_0} \\frac{d\\bar{m}}{d\\bar{r}} = 4\\pi L_0^2 \\epsilon_0 \\bar{r}^2 \\bar{\\epsilon}\n$$\n$$\n\\frac{d\\bar{m}}{d\\bar{r}} = \\frac{4\\pi \\epsilon_0 L_0^3}{M_0} \\bar{r}^2 \\bar{\\epsilon}\n$$\nTo obtain a clean dimensionless equation, we choose the mass scale $M_0$ to be naturally related to the length and density scales: $M_0 = \\epsilon_0 L_0^3$. This choice simplifies the dimensionless mass equation to:\n$$\n\\frac{d\\bar{m}}{d\\bar{r}} = 4\\pi \\bar{r}^2 \\bar{\\epsilon}\n$$\n\nNext, we substitute the scaled variables into the hydrostatic equilibrium (TOV) equation:\n$$\n\\frac{\\epsilon_0 d\\bar{p}}{L_0 d\\bar{r}} = -\\frac{G\\left(\\epsilon_0\\bar{\\epsilon} + \\epsilon_0\\bar{p}\\right)\\left(M_0\\bar{m} + 4\\pi (L_0\\bar{r})^{3}(\\epsilon_0\\bar{p})\\right)}{(L_0\\bar{r})^{2}\\left(1 - \\frac{2GM_0\\bar{m}}{L_0\\bar{r}}\\right)}\n$$\nFactoring out the scale constants and using $M_0 = \\epsilon_0 L_0^3$:\n$$\n\\frac{\\epsilon_0}{L_0} \\frac{d\\bar{p}}{d\\bar{r}} = -\\frac{G \\epsilon_0 (\\bar{\\epsilon} + \\bar{p}) (\\epsilon_0 L_0^3 \\bar{m} + 4\\pi L_0^3 \\epsilon_0 \\bar{p})}{L_0^2 \\bar{r}^2 (1 - \\frac{2G\\epsilon_0 L_0^3 \\bar{m}}{L_0\\bar{r}})}\n$$\n$$\n\\frac{d\\bar{p}}{d\\bar{r}} = - G \\epsilon_0 L_0^2 \\frac{(\\bar{\\epsilon} + \\bar{p})(\\bar{m} + 4\\pi \\bar{r}^3 \\bar{p})}{\\bar{r}^2 (1 - 2G\\epsilon_0 L_0^2 \\frac{\\bar{m}}{\\bar{r}})}\n$$\nTo eliminate all explicit dimensional constants from this equation, we must set the dimensionless combination $G\\epsilon_0 L_0^2$ to unity:\n$$\nG\\epsilon_0 L_0^2 = 1\n$$\nWith this choice, the dimensionless TOV equation becomes:\n$$\n\\frac{d\\bar{p}}{d\\bar{r}} = -\\frac{(\\bar{\\epsilon} + \\bar{p})(\\bar{m} + 4\\pi \\bar{r}^3 \\bar{p})}{\\bar{r}^2 (1 - 2\\frac{\\bar{m}}{\\bar{r}})}\n$$\n\nNow we incorporate the EoS. We transform both relations into dimensionless form:\n1. $p = K\\rho^{\\Gamma} \\quad \\implies \\quad \\epsilon_0 \\bar{p} = K (\\epsilon_0 \\bar{\\rho})^{\\Gamma} = K \\epsilon_0^{\\Gamma} \\bar{\\rho}^{\\Gamma}$\n$$ \\bar{p} = (K \\epsilon_0^{\\Gamma-1}) \\bar{\\rho}^{\\Gamma} $$\nTo make this equation independent of $K$, we set the coefficient to unity:\n$$ K \\epsilon_0^{\\Gamma-1} = 1 \\quad \\implies \\quad \\epsilon_0 = K^{-1/(\\Gamma-1)} $$\n2. $\\epsilon = \\rho + \\frac{p}{\\Gamma - 1} \\quad \\implies \\quad \\epsilon_0 \\bar{\\epsilon} = \\epsilon_0 \\bar{\\rho} + \\frac{\\epsilon_0 \\bar{p}}{\\Gamma-1}$\n$$ \\bar{\\epsilon} = \\bar{\\rho} + \\frac{\\bar{p}}{\\Gamma - 1} $$\nWith our choices, the dimensionless EoS becomes simply $\\bar{p} = \\bar{\\rho}^{\\Gamma}$. We can express $\\bar{\\epsilon}$ solely in terms of $\\bar{p}$:\n$$ \\bar{\\epsilon} = \\bar{p}^{1/\\Gamma} + \\frac{\\bar{p}}{\\Gamma-1} $$\n\nWe have now determined the scaling relations for $\\epsilon_0$ and $L_0$. We can solve for the scales explicitly in terms of the fundamental constants $G$ and $K$.\nThe energy density scale is $\\epsilon_0 = K^{-1/(\\Gamma-1)}$.\nFrom $G\\epsilon_0 L_0^2 = 1$, we find the length scale:\n$$ L_0 = (G\\epsilon_0)^{-1/2} = (G K^{-1/(\\Gamma-1)})^{-1/2} = G^{-1/2} K^{1/(2(\\Gamma-1))} $$\nFinally, we find the mass scale $M_0 = \\epsilon_0 L_0^3$:\n$$ M_0 = \\left(K^{-1/(\\Gamma-1)}\\right) \\left(G^{-1/2} K^{1/(2(\\Gamma-1))}\\right)^3 = K^{-1/(\\Gamma-1)} G^{-3/2} K^{3/(2(\\Gamma-1))} $$\n$$ M_0 = G^{-3/2} K^{\\frac{3 - 2}{2(\\Gamma-1)}} = G^{-3/2} K^{1/(2(\\Gamma-1))} $$\n\nThe full system of dimensionless equations depends only on the polytropic index $\\Gamma$. For a fixed $\\Gamma$, a unique stellar structure solution is obtained by integrating the two first-order ODEs from the center ($\\bar{r}=0$) outwards, subject to a single central condition, typically the central pressure $\\bar{p}_c$. The other central condition is $\\bar{m}(0)=0$. The integration proceeds until the surface, defined by $\\bar{p}(\\bar{R})=0$, where $\\bar{R}$ is the dimensionless stellar radius. The total dimensionless mass is $\\bar{M} = \\bar{m}(\\bar{R})$.\n\nThe problem defines the central compactness parameter $\\eta \\equiv p_c / \\epsilon_c$. In dimensionless variables, this is $\\eta = \\bar{p}_c / \\bar{\\epsilon}_c$. Since $\\bar{\\epsilon}_c$ is a function of $\\bar{p}_c$ and $\\Gamma$, specifying $\\bar{p}_c$ is equivalent to specifying $\\eta$. Thus, for a fixed $\\Gamma$, the dimensionless mass $\\bar{M}$ is a function of a single parameter, $\\eta$: $\\bar{M} = \\bar{M}(\\eta, \\Gamma)$.\n\nNumerical solutions to this system show that for any given $\\Gamma > 1$, the function $\\bar{M}(\\eta, \\Gamma)$ has a maximum value for some specific central compactness $\\eta_*(\\Gamma)$. Let us denote this maximum dimensionless mass as $\\mathcal{C}(\\Gamma) \\equiv \\max_{\\eta} \\bar{M}(\\eta, \\Gamma)$. This coefficient $\\mathcal{C}(\\Gamma)$ is a pure number that depends only on $\\Gamma$.\n\nThe dimensional mass of a star is given by $M = M_0 \\bar{M}$. The maximum possible mass for a star with a given $K, \\Gamma$ EoS is therefore:\n$$ M_{\\max} = M_0 \\mathcal{C}(\\Gamma) $$\nSubstituting the expression we derived for the mass scale $M_0$:\n$$ M_{\\max} = \\left(G^{-3/2} K^{1/(2(\\Gamma-1))}\\right) \\mathcal{C}(\\Gamma) $$\nThis expression represents the scaling of the maximum neutron star mass with the EoS parameters $K$ and $\\Gamma$. It is a power law in $K$, with an exponent that depends on $\\Gamma$. The final expression is the analytic relationship requested.",
            "answer": "$$\n\\boxed{\\mathcal{C}(\\Gamma) G^{-3/2} K^{\\frac{1}{2(\\Gamma-1)}}}\n$$"
        },
        {
            "introduction": "Realistic equations of state are typically generated as numerical tables, requiring interpolation to be used in stellar structure calculations. This hands-on coding exercise  demonstrates that the choice of interpolation scheme is critical for preserving physical reality. You will compare a standard cubic spline with a shape-preserving monotone method, and in doing so, discover how seemingly innocuous numerical choices can inadvertently introduce unphysical behavior such as violations of causality ($c_s^2 > 1$) or thermodynamic stability.",
            "id": "3604215",
            "problem": "You are given three discrete, thermodynamically stable and causal tabulations of the Equation of State (EoS) for cold neutron-star matter in the form of pressure versus energy density. In computational studies of the mass-radius relation, one must supply a differentiable mapping between pressure and energy density to integrate the Tolman-Oppenheimer-Volkoff equations. The physically motivated stability and causality constraints impose that the adiabatic sound speed squared satisfies $c_s^2 = \\frac{\\mathrm{d}p}{\\mathrm{d}\\epsilon} \\ge 0$ and, in units where the speed of light $c=1$, that $c_s^2 \\le 1$. From first principles, for a monotone EoS tabulated as $\\epsilon(p)$, the chain rule implies $c_s^2 = \\left(\\frac{\\mathrm{d}\\epsilon}{\\mathrm{d}p}\\right)^{-1}$. Shape-preserving monotone cubic Hermite interpolation is widely used for tabulated thermodynamic functions; your task is to design a programmatic demonstration that this interpolation, when applied to $\\epsilon(p)$, preserves $c_s^2 \\ge 0$ and avoids spurious superluminal segments $c_s^2 > 1$ on the tested grids, while a naive cubic spline applied to $p(\\epsilon)$ can introduce unphysical behavior.\n\nStarting base and core facts:\n- Thermodynamic stability requires $p(\\epsilon)$ to be nondecreasing so that $\\frac{\\mathrm{d}p}{\\mathrm{d}\\epsilon} \\ge 0$.\n- Causality in relativistic matter requires $c_s^2 = \\frac{\\mathrm{d}p}{\\mathrm{d}\\epsilon} \\le 1$ when using units with $c=1$.\n- If an EoS is tabulated as the monotone function $\\epsilon(p)$, then $c_s^2 = \\left(\\frac{\\mathrm{d}\\epsilon}{\\mathrm{d}p}\\right)^{-1}$.\n- Shape-preserving monotone cubic Hermite interpolation applied to a monotone tabulation $\\epsilon(p)$ yields an interpolant with nonnegative derivative everywhere between tabulated nodes.\n\nImplement the following computational experiment:\n- Method A: Interpolate $p(\\epsilon)$ using a cubic spline with default not-a-knot boundary conditions and compute $c_s^2 = \\frac{\\mathrm{d}p}{\\mathrm{d}\\epsilon}$ by differentiating the spline.\n- Method B: Interpolate $\\epsilon(p)$ using a monotone cubic Hermite method and compute $c_s^2$ via $c_s^2 = \\left(\\frac{\\mathrm{d}\\epsilon}{\\mathrm{d}p}\\right)^{-1}$ by differentiating the interpolant. Use a common dense grid of $p$ values covering the tabulated $p$-range to evaluate both methods consistently by mapping those $p$ to $\\epsilon$ through the Method B interpolant before evaluating Method A’s derivative.\n\nTest suite:\nProvide three EoS tables. All pressures $p$ and energy densities $\\epsilon$ must be treated in consistent physical units of megaelectronvolts per cubic femtometer (MeV fm$^{-3}$). The adiabatic sound speed squared $c_s^2$ is dimensionless. Use the following tabulations:\n- Case $1$ (smooth moderately stiff EoS):\n  - $p = [\\,0,\\ 5,\\ 10,\\ 20,\\ 40,\\ 80\\,]$\n  - $\\epsilon = [\\,150.000,\\ 160.000,\\ 169.091,\\ 185.758,\\ 218.016,\\ 279.554\\,]$\n- Case $2$ (sharp softening resembling a phase-transition-like segment):\n  - $p = [\\,0,\\ 5,\\ 10,\\ 12,\\ 14,\\ 20,\\ 40,\\ 80\\,]$\n  - $\\epsilon = [\\,150.000,\\ 158.333,\\ 166.667,\\ 366.667,\\ 566.667,\\ 576.667,\\ 610.001,\\ 676.669\\,]$\n- Case $3$ (near-stiff but causal EoS approaching $c_s^2 \\lesssim 1$):\n  - $p = [\\,0,\\ 10,\\ 20,\\ 40,\\ 80,\\ 120,\\ 160\\,]$\n  - $\\epsilon = [\\,150.000,\\ 162.500,\\ 174.695,\\ 198.225,\\ 245.285,\\ 294.065,\\ 344.065\\,]$\n\nComputational details to implement:\n- For each case, construct Method A and Method B interpolants as specified.\n- Define a uniform grid of $p$ values of length $N_\\mathrm{eval} = 1001$ spanning from the minimum to the maximum tabulated $p$ in the case. Evaluate the Method B interpolant at these $p$ values to obtain $\\epsilon$ values, and use those $\\epsilon$ values to evaluate the Method A derivative.\n- For both methods, compute $c_s^2$ over the grid. For Method A, $c_s^2(\\epsilon) = \\frac{\\mathrm{d}p}{\\mathrm{d}\\epsilon}$ directly from the derivative of its spline. For Method B, compute $\\mathrm{d}\\epsilon/\\mathrm{d}p$ from the derivative of its interpolant and then invert to obtain $c_s^2(p) = 1/\\left(\\frac{\\mathrm{d}\\epsilon}{\\mathrm{d}p}\\right)$.\n- For each case, report:\n  - The minimum and maximum of $c_s^2$ from Method B over the grid, rounded to $6$ decimal places.\n  - A boolean indicating whether Method B satisfies both $c_s^2 \\ge 0$ and $c_s^2 \\le 1$ everywhere on the evaluation grid (use a strict numerical tolerance $\\tau = 10^{-8}$ when checking inequalities).\n  - A boolean indicating whether Method A violates either $c_s^2 \\ge 0$ or $c_s^2 \\le 1$ anywhere on the evaluation grid (use the same tolerance $\\tau$).\n\nFinal output requirements:\n- Your program must produce a single line of output containing the results for the three cases as a comma-separated list enclosed in square brackets. The list must contain, for Case $1$ followed by Case $2$ and Case $3$, the following $4$ entries per case: $\\min c_{s,B}^2$, $\\max c_{s,B}^2$, $\\text{B\\_ok}$, $\\text{A\\_violates}$. For example, the overall structure must be $[\\,\\min_1,\\max_1,\\text{B\\_ok}_1,\\text{A\\_violates}_1,\\min_2,\\max_2,\\text{B\\_ok}_2,\\text{A\\_violates}_2,\\min_3,\\max_3,\\text{B\\_ok}_3,\\text{A\\_violates}_3\\,]$.\n- All floats must be rounded to exactly $6$ decimal places. All booleans must be exact Python boolean literals.\n- All pressures $p$ and energy densities $\\epsilon$ are to be interpreted in MeV fm$^{-3}$. The dimensionless values of $c_s^2$ do not carry units.",
            "solution": "The posed problem is an investigation into the numerical stability and physical fidelity of interpolation schemes for neutron star Equations of State (EoS). The objective is to demonstrate computationally that a shape-preserving monotone cubic Hermite interpolation of the energy density as a function of pressure, $\\epsilon(p)$, correctly preserves the physical constraints of thermodynamic stability and causality, whereas a naive cubic spline of pressure as a function of energy density, $p(\\epsilon)$, can introduce unphysical artifacts.\n\nThe fundamental physical principles governing the EoS of cold, catalyzed nuclear matter are thermodynamic stability and relativistic causality. Stability requires that pressure $p$ be a non-decreasing function of energy density $\\epsilon$, which implies that the square of the adiabatic sound speed, $c_s^2$, must be non-negative.\n$$\nc_s^2 = \\frac{\\mathrm{d}p}{\\mathrm{d}\\epsilon} \\ge 0\n$$\nRelativistic causality, in units where the speed of light $c=1$, imposes an upper bound on the sound speed, such that it cannot exceed the speed of light.\n$$\nc_s^2 = \\frac{\\mathrm{d}p}{\\mathrm{d}\\epsilon} \\le 1\n$$\nIn computational nuclear physics, EoS are often provided as discrete tables of data points $(\\epsilon_i, p_i)$. To solve the Tolman-Oppenheimer-Volkoff (TOV) equations for stellar structure, a continuous, differentiable function is required. This is achieved through interpolation. The choice of interpolation scheme is critical, as it must not introduce violations of the aforementioned physical constraints.\n\nThis problem contrasts two methods for generating the required interpolant. Let the discrete EoS data be given by $\\{ (p_i, \\epsilon_i) \\}_{i=1}^N$.\n\nMethod A involves a direct cubic spline interpolation of the function $p(\\epsilon)$. An interpolant $p_A(\\epsilon)$ is constructed to pass through the data points $( \\epsilon_i, p_i )$. The sound speed squared is then obtained by direct differentiation:\n$$\nc_{s,A}^2(\\epsilon) = \\frac{\\mathrm{d}p_A}{\\mathrm{d}\\epsilon}\n$$\nStandard cubic splines are optimized for smoothness (continuity of the second derivative) but do not inherently preserve monotonicity. This means that even if the discrete data $\\{ p_i \\}$ is a monotone function of $\\{ \\epsilon_i \\}$, the derivative of the interpolant $\\mathrm{d}p_A/\\mathrm{d}\\epsilon$ can become negative in regions between the nodes, a phenomenon known as \"overshoot\". This would correspond to an unphysical negative $c_s^2$. Similarly, overshoots can lead to $c_s^2 > 1$, violating causality.\n\nMethod B adopts a more physically motivated approach. Recognizing that pressure $p$ is the fundamental thermodynamic variable, we interpolate the inverse function, $\\epsilon(p)$. An interpolant $\\epsilon_B(p)$ is constructed to pass through the data points $(p_i, \\epsilon_i)$. The sound speed squared is then calculated using the inverse function theorem:\n$$\nc_{s,B}^2(p) = \\left( \\frac{\\mathrm{d}\\epsilon_B}{\\mathrm{d}p} \\right)^{-1}\n$$\nCrucially, Method B employs a shape-preserving monotone cubic Hermite interpolation, such as the Piecewise Cubic Hermite Interpolating Polynomial (PCHIP). This method is explicitly designed to preserve the monotonicity of the original data. Since the physical EoS dictates that $\\epsilon(p)$ is a monotone non-decreasing function, the PCHIP interpolant $\\epsilon_B(p)$ will have a non-negative first derivative everywhere: $\\frac{\\mathrm{d}\\epsilon_B}{\\mathrm{d}p} \\ge 0$. This directly guarantees that $c_{s,B}^2 = (\\mathrm{d}\\epsilon_B/\\mathrm{d}p)^{-1} \\ge 0$, thus ensuring thermodynamic stability is preserved by construction. The causality condition, $c_{s,B}^2 \\le 1$, translates to $\\frac{\\mathrm{d}\\epsilon_B}{\\mathrm{d}p} \\ge 1$. While not guaranteed by the interpolator itself, this formulation is far less susceptible to spurious superluminal ($c_s^2 > 1$) regions compared to Method A because it avoids the oscillatory behavior of standard splines.\n\nThe computational procedure is as follows for each test case:\n$1$. The tabulated data points $(p_i, \\epsilon_i)$ are used to construct the two interpolants. For Method A, a `CubicSpline` is fitted to $p(\\epsilon)$ with 'not-a-knot' boundary conditions. For Method B, a `PchipInterpolator` is fitted to $\\epsilon(p)$.\n$2$. A dense, uniform evaluation grid of $N_{\\mathrm{eval}} = 1001$ pressure points, $p_{\\mathrm{eval}}$, is created, spanning the tabulated pressure range $[\\min(p_i), \\max(p_i)]$.\n$3$. The Method B interpolant $\\epsilon_B(p)$ is evaluated on this grid to produce a corresponding grid of energy densities, $\\epsilon_{\\mathrm{eval}} = \\epsilon_B(p_{\\mathrm{eval}})$. This ensures that both methods are compared at consistent thermodynamic states.\n$4$. For Method A, the derivative of the $p_A(\\epsilon)$ spline is evaluated at the points $\\epsilon_{\\mathrm{eval}}$ to obtain $c_{s,A}^2$.\n$5$. For Method B, the derivative of the $\\epsilon_B(p)$ interpolant is evaluated at the points $p_{\\mathrm{eval}}$ to obtain $\\frac{\\mathrm{d}\\epsilon_B}{\\mathrm{d}p}$, and the result is inverted to yield $c_{s,B}^2$.\n$6$. The results are analyzed. For Method B, we find the minimum and maximum values of $c_{s,B}^2$ and verify that the physical bounds $0 \\le c_s^2 \\le 1$ are satisfied across the entire grid, within a numerical tolerance $\\tau = 10^{-8}$. For Method A, we check if either of these bounds is violated anywhere on the grid.\n\nThis numerical experiment will highlight the robustness of Method B and the potential for unphysical behavior in Method A, particularly for EoS with rapid changes in stiffness, which are characteristic of phase transitions in dense matter.",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import CubicSpline, PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing two interpolation methods for neutron star\n    Equations of State (EoS) and their effect on physical constraints.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"id\": 1,\n            \"p\": np.array([0., 5., 10., 20., 40., 80.]),\n            \"eps\": np.array([150.000, 160.000, 169.091, 185.758, 218.016, 279.554]),\n        },\n        {\n            \"id\": 2,\n            \"p\": np.array([0., 5., 10., 12., 14., 20., 40., 80.]),\n            \"eps\": np.array([150.000, 158.333, 166.667, 366.667, 566.667, 576.667, 610.001, 676.669]),\n        },\n        {\n            \"id\": 3,\n            \"p\": np.array([0., 10., 20., 40., 80., 120., 160.]),\n            \"eps\": np.array([150.000, 162.500, 174.695, 198.225, 245.285, 294.065, 344.065]),\n        },\n    ]\n\n    results = []\n    N_eval = 1001\n    tau = 1e-8\n\n    for case in test_cases:\n        p_data = case[\"p\"]\n        eps_data = case[\"eps\"]\n\n        # --- Method A: Naive Cubic Spline for p(eps) ---\n        # Note: CubicSpline requires monotonic x; our eps_data is monotonic.\n        spline_A = CubicSpline(eps_data, p_data, bc_type='not-a-knot')\n        \n        # --- Method B: Monotone Cubic Hermite for eps(p) ---\n        spline_B = PchipInterpolator(p_data, eps_data)\n\n        # --- Evaluation Grid ---\n        # Define a dense grid in pressure\n        p_eval = np.linspace(p_data[0], p_data[-1], N_eval)\n        \n        # For a consistent comparison, evaluate Method A at the epsilon values\n        # corresponding to the pressure grid from Method B.\n        # Pchip guarantees monotonicity, so eps_eval will be monotonic.\n        eps_eval = spline_B(p_eval)\n        \n        # --- Calculate Sound Speed Squared (c_s^2) ---\n        \n        # Method A: c_s^2 = dp/deps\n        # We use the derivative method of the spline object.\n        cs2_A = spline_A.derivative(1)(eps_eval)\n        \n        # Method B: c_s^2 = (d_eps/dp)^-1\n        # Get the derivative of the PCHIP interpolant\n        d_eps_d_p_B = spline_B.derivative(1)(p_eval)\n\n        # Inverse of the derivative. Add a small epsilon to avoid division by zero,\n        # although for this data it's not strictly necessary as d_eps/dp  0.\n        cs2_B = 1.0 / (d_eps_d_p_B + 1e-30)\n\n        # --- Analysis ---\n        \n        # For Method B\n        min_B = np.min(cs2_B)\n        max_B = np.max(cs2_B)\n        # Check if B satisfies stability (= 0) and causality (= 1)\n        B_ok = bool(np.all(cs2_B = -tau) and np.all(cs2_B = 1.0 + tau))\n        \n        # For Method A\n        # Check if A violates stability or causality\n        A_violates = bool(np.any(cs2_A  -tau) or np.any(cs2_A  1.0 + tau))\n        \n        # Append results for this case\n        results.extend([\n            round(min_B, 6),\n            round(max_B, 6),\n            B_ok,\n            A_violates\n        ])\n\n    # Format the final output string as specified\n    _print_str = \",\".join(map(str, results))\n    print(f\"[{_print_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This capstone practice integrates theory and computation to build a neutron star model from the ground up and use it for scientific exploration. You will implement a complete Tolman-Oppenheimer-Volkoff solver coupled with a realistic, multi-segment piecewise-polytropic equation of state. The central task  is to investigate how varying the stiffness in a key density region, by changing the adiabatic index $\\Gamma_i$, directly alters the shape of the mass-radius curve, particularly the predicted radii for stars around the canonical $1.4\\,M_{\\odot}$ mass.",
            "id": "3604233",
            "problem": "Implement a program that, starting from first principles relevant to compact star structure, constructs a three-segment piecewise-polytropic cold Equation of State (EoS) and integrates the general relativistic hydrostatic equilibrium equations to obtain the mass-radius relation of neutron stars. Then, for a set of specified adiabatic indices for the middle segment, quantify how the local slope and curvature of the mass-radius curve near a target mass are affected. Your program must produce numerical estimates of the slope and curvature near $1.4\\,M_{\\odot}$ and aggregate the results for all test cases into a single-line output as specified below.\n\nFundamental base and governing relations to use:\n- Hydrostatic equilibrium in General Relativity is governed by the Tolman–Oppenheimer–Volkoff equations derived from Einstein’s field equations and conservation of energy-momentum. In spherical symmetry for a static star, the coupled ordinary differential equations for pressure $P(r)$ and enclosed gravitational mass $m(r)$ are:\n  1. $\\,\\dfrac{dP}{dr} = -\\dfrac{G \\left(\\varepsilon + \\dfrac{P}{c^{2}}\\right) \\left(m + 4\\pi r^{3} \\dfrac{P}{c^{2}}\\right)}{r \\left(r - \\dfrac{2 G m}{c^{2}}\\right)}\\,$,\n  2. $\\,\\dfrac{dm}{dr} = 4\\pi r^{2} \\dfrac{\\varepsilon}{c^{2}}\\,$,\n  where $r$ is the Schwarzschild areal radius, $G$ is the gravitational constant, $c$ is the speed of light, $\\varepsilon$ is the total energy density, and $m(r)$ is the enclosed gravitational mass-energy expressed as mass via division by $c^{2}$.\n- A three-segment piecewise-polytropic cold EoS is defined by density breakpoints and segment adiabatic indices. In each segment $i$ with adiabatic index $\\Gamma_i$ and polytropic constant $K_i$, the pressure is $\\,P(\\rho) = K_i \\rho^{\\Gamma_i}\\,,$ where $\\rho$ is the rest-mass density. For cold matter, the total energy density satisfies the barotropic first-law relation and may be written in each segment in the thermodynamically consistent form $\\,\\varepsilon(\\rho) = \\left(1 + a_i\\right)\\rho c^{2} + \\dfrac{K_i}{\\Gamma_i-1} \\rho^{\\Gamma_i}\\,$ with segment-dependent constants $a_i$ chosen to ensure continuity of $\\varepsilon(\\rho)$ at the density breakpoints.\n\nSpecifications you must implement:\n1. Use cgs units internally: $G$ in $\\mathrm{cm^{3}\\,g^{-1}\\,s^{-2}}$, $c$ in $\\mathrm{cm\\,s^{-1}}$, pressures in $\\mathrm{dyne\\,cm^{-2}}$ (equivalently $\\mathrm{erg\\,cm^{-3}}$), densities in $\\mathrm{g\\,cm^{-3}}$, radii in $\\mathrm{cm}$, and masses in $\\mathrm{g}$. Convert the final outputs to the requested units.\n2. Define a three-segment piecewise-polytrope with break densities and fixed parameters for segment $1$ and segment $3$, and vary only the middle segment’s adiabatic index:\n   - Segment boundaries: $\\rho_{1} = 1.0\\times 10^{14}\\,\\mathrm{g\\,cm^{-3}}$, $\\rho_{2} = 3.0\\times 10^{14}\\,\\mathrm{g\\,cm^{-3}}$.\n   - Segment adiabatic indices: $\\Gamma_{1} = 1.3$, $\\Gamma_{2}$ is variable per test case, $\\Gamma_{3} = 3.0$.\n   - Fix the pressure at $\\rho_{1}$ to $P_{1} = 1.0\\times 10^{33}\\,\\mathrm{dyne\\,cm^{-2}}$ to set the crust normalization. Determine $K_{1}$ by $K_{1} = P_{1}/\\rho_{1}^{\\Gamma_{1}}$. For a given $\\Gamma_{2}$, enforce pressure continuity at $\\rho_{1}$ by setting $K_{2} = P_{1}/\\rho_{1}^{\\Gamma_{2}}$. Enforce pressure continuity at $\\rho_{2}$ by defining $K_{3}$ via $K_{3}\\rho_{2}^{\\Gamma_{3}} = K_{2}\\rho_{2}^{\\Gamma_{2}}$. Enforce thermodynamic continuity of $\\varepsilon(\\rho)$ at each breakpoint by choosing $a_{1} = 0$ and solving for $a_{2}$ and $a_{3}$ such that $\\varepsilon(\\rho)$ is continuous at both $\\rho_{1}$ and $\\rho_{2}$.\n3. Implement the Tolman–Oppenheimer–Volkoff integration from a small radius $r_{0}  0$ to the stellar surface, defined as the first radius where $P(r)$ drops to a surface pressure threshold $P_{\\mathrm{surf}} = 1.0\\times 10^{30}\\,\\mathrm{dyne\\,cm^{-2}}$. Start from a central density $\\rho_{c}$ and compute $P_{c}$ from the EoS. Initialize $m(r_{0}) \\approx \\dfrac{4\\pi}{3}r_{0}^{3}\\dfrac{\\varepsilon(\\rho_{c})}{c^{2}}$, $P(r_{0}) = P_{c}$. Use an adaptive ordinary differential equation integrator with an event to stop precisely at $P_{\\mathrm{surf}}$.\n4. For each EoS considered, generate a mass-radius locus by scanning central densities $\\rho_{c}$ over a logarithmic grid from $\\rho_{c,\\min} = 2.0\\times 10^{14}\\,\\mathrm{g\\,cm^{-3}}$ to $\\rho_{c,\\max} = 2.0\\times 10^{15}\\,\\mathrm{g\\,cm^{-3}}$ with $N = 80$ points. For each model, record the gravitational mass $M$ and radius $R$ at the surface. Convert $M$ to solar masses using $M_{\\odot} = 1.98847\\times 10^{33}\\,\\mathrm{g}$, and $R$ to kilometers using $1\\,\\mathrm{km} = 10^{5}\\,\\mathrm{cm}$.\n5. For each EoS, locate the model in the computed sequence with gravitational mass closest to the target $M_{\\star} = 1.4\\,M_{\\odot}$. Using that model and its nearest neighbors along the sequence (choose a symmetric stencil of five points whenever possible, otherwise use the closest available points), perform a local quadratic least-squares fit of $M(R)$ in the form $M(R) \\approx \\alpha + \\beta \\left(R - R_{0}\\right) + \\gamma \\left(R - R_{0}\\right)^{2}$, where $R_{0}$ is the radius of the closest-to-target model. Extract the local slope $\\left.\\dfrac{dM}{dR}\\right|_{R_{0}} = \\beta$ and curvature $\\left.\\dfrac{d^{2}M}{dR^{2}}\\right|_{R_{0}} = 2\\gamma$. Express $\\beta$ in units of $M_{\\odot}\\,\\mathrm{km^{-1}}$ and $2\\gamma$ in units of $M_{\\odot}\\,\\mathrm{km^{-2}}$.\n6. Angle units are not applicable here.\n7. Test suite: Use the following four values for the middle segment’s adiabatic index $\\,\\Gamma_{2}\\,$:\n   - Case A (soft middle segment): $\\Gamma_{2} = 2.0$,\n   - Case B (moderately soft): $\\Gamma_{2} = 2.4$,\n   - Case C (moderately stiff): $\\Gamma_{2} = 2.8$,\n   - Case D (stiff middle segment): $\\Gamma_{2} = 3.2$.\n8. Your program must output a single line containing a list of results, one per test case, where each result is a two-element list $[s, k]$ with $s$ the slope and $k$ the curvature as real numbers in the specified units. The line must be formatted exactly as a JSON-like list without spaces, for example: $[[s_{A},k_{A}],[s_{B},k_{B}],[s_{C},k_{C}],[s_{D},k_{D}]]$. Round each number to six digits after the decimal point.\n\nScientific realism constraints:\n- Ensure the EoS is causal in the explored regime and that pressure and energy density are continuous across segment boundaries as described.\n- Do not use any closed-form “shortcut” relations for the mass-radius curve; construct it by explicit numerical integration of the Tolman–Oppenheimer–Volkoff equations.\n- Use the specified physical constants: $G = 6.67430\\times 10^{-8}\\,\\mathrm{cm^{3}\\,g^{-1}\\,s^{-2}}$, $c = 2.99792458\\times 10^{10}\\,\\mathrm{cm\\,s^{-1}}$, and $M_{\\odot} = 1.98847\\times 10^{33}\\,\\mathrm{g}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the exact format $[[s_{A},k_{A}],[s_{B},k_{B}],[s_{C},k_{C}],[s_{D},k_{D}]]$ with all numbers rounded to six decimal places and with units implicitly understood as $M_{\\odot}\\,\\mathrm{km^{-1}}$ for slopes and $M_{\\odot}\\,\\mathrm{km^{-2}}$ for curvatures.",
            "solution": "We begin from general relativity’s description of hydrostatic equilibrium in a static, spherically symmetric star. The Tolman–Oppenheimer–Volkoff (TOV) equations are derived from Einstein’s field equations together with conservation of energy-momentum, yielding the coupled ordinary differential equations\n$$\n\\frac{dP}{dr} \\;=\\; -\\frac{G\\left(\\varepsilon + \\frac{P}{c^{2}}\\right)\\left(m + 4\\pi r^{3}\\frac{P}{c^{2}}\\right)}{r\\left(r - \\frac{2Gm}{c^{2}}\\right)}\\,,\\qquad\n\\frac{dm}{dr} \\;=\\; 4\\pi r^{2}\\frac{\\varepsilon}{c^{2}}\\,,\n$$\nwhere $r$ is the areal radius coordinate, $P(r)$ is the pressure, $\\varepsilon(r)$ is the total energy density, $m(r)$ is the enclosed gravitational mass-energy expressed as mass via division by $c^{2}$, $G$ is the gravitational constant, and $c$ is the speed of light. Given an Equation of State (EoS) $P(\\varepsilon)$ (or equivalently $P(\\rho)$ and $\\varepsilon(\\rho)$ with $\\rho$ the rest-mass density), these equations close and can be integrated outward from the center. The stellar surface is identified when the pressure reaches a small threshold $P_{\\mathrm{surf}}$ that effectively represents vanishing pressure relative to central values.\n\nTo probe how a single segment’s adiabatic index affects the local geometry of the mass-radius relation near a canonical mass, we adopt a three-segment piecewise-polytropic cold EoS. In each segment $i$, pressure is modeled as\n$$\nP(\\rho) = K_i\\,\\rho^{\\Gamma_i}\\,,\n$$\nwith $\\Gamma_i$ the adiabatic index in that segment and $K_i$ a normalization ensuring pressure continuity at segment interfaces. The cold EoS’s total energy density is obtained from the first-law relation for barotropic matter, $d\\varepsilon = (\\varepsilon + P)\\,d\\rho/\\rho$, whose solution for a polytrope is, in each segment,\n$$\n\\varepsilon(\\rho) = \\left(1 + a_i\\right)\\rho c^{2} + \\frac{K_i}{\\Gamma_i-1}\\,\\rho^{\\Gamma_i}\\,,\n$$\nwhere $a_i$ is an integration constant chosen to ensure continuity of $\\varepsilon(\\rho)$ at the density boundaries. We set $a_{1} = 0$ in the lowest-density segment and compute $a_{2}$ and $a_{3}$ by demanding continuity at $\\rho_{1}$ and $\\rho_{2}$, respectively. Pressure continuity is ensured by choosing $K_{2}$ and $K_{3}$ to match $P(\\rho)$ across interfaces.\n\nConcretely, we define the segment boundaries $\\rho_{1} = 1.0\\times 10^{14}\\,\\mathrm{g\\,cm^{-3}}$ and $\\rho_{2} = 3.0\\times 10^{14}\\,\\mathrm{g\\,cm^{-3}}$. We fix $\\Gamma_{1} = 1.3$, $\\Gamma_{3} = 3.0$, and set the middle segment $\\Gamma_{2}$ according to the test case. We specify a crust normalization $P_{1} = 1.0\\times 10^{33}\\,\\mathrm{dyne\\,cm^{-2}}$ at $\\rho_{1}$ and take $K_{1} = P_{1}/\\rho_{1}^{\\Gamma_{1}}$. Pressure continuity at $\\rho_{1}$ gives $K_{2} = P_{1}/\\rho_{1}^{\\Gamma_{2}}$. The pressure at $\\rho_{2}$ as approached from segment $2$ is $P_{2-} = K_{2}\\rho_{2}^{\\Gamma_{2}}$, which is enforced to equal the segment $3$ pressure at that boundary, $K_{3}\\rho_{2}^{\\Gamma_{3}}$, hence $K_{3} = P_{2-}/\\rho_{2}^{\\Gamma_{3}}$. Energy density continuity is achieved by solving\n$$\n\\varepsilon_{1}(\\rho_{1}) = \\varepsilon_{2}(\\rho_{1}) \\quad\\Rightarrow\\quad\n\\left(\\rho_{1} c^{2} + \\frac{K_{1}}{\\Gamma_{1}-1}\\rho_{1}^{\\Gamma_{1}}\\right) = \\left((1+a_{2})\\rho_{1} c^{2} + \\frac{K_{2}}{\\Gamma_{2}-1}\\rho_{1}^{\\Gamma_{2}}\\right)\\,,\n$$\nfor $a_{2}$, and\n$$\n\\varepsilon_{2}(\\rho_{2}) = \\varepsilon_{3}(\\rho_{2}) \\quad\\Rightarrow\\quad\n\\left((1+a_{2})\\rho_{2} c^{2} + \\frac{K_{2}}{\\Gamma_{2}-1}\\rho_{2}^{\\Gamma_{2}}\\right) = \\left((1+a_{3})\\rho_{2} c^{2} + \\frac{K_{3}}{\\Gamma_{3}-1}\\rho_{2}^{\\Gamma_{3}}\\right)\\,,\n$$\nfor $a_{3}$. Solving yields\n$$\na_{2} = \\frac{\\rho_{1} c^{2} + \\dfrac{K_{1}}{\\Gamma_{1}-1}\\rho_{1}^{\\Gamma_{1}} - \\left(\\rho_{1} c^{2} + \\dfrac{K_{2}}{\\Gamma_{2}-1}\\rho_{1}^{\\Gamma_{2}}\\right)}{\\rho_{1} c^{2}}\\,,\n\\qquad\na_{3} = \\frac{(1+a_{2})\\rho_{2} c^{2} + \\dfrac{K_{2}}{\\Gamma_{2}-1}\\rho_{2}^{\\Gamma_{2}} - \\left(\\rho_{2} c^{2} + \\dfrac{K_{3}}{\\Gamma_{3}-1}\\rho_{2}^{\\Gamma_{3}}\\right)}{\\rho_{2} c^{2}}\\,.\n$$\nGiven $P(\\rho)$, inversion to $\\rho(P)$ is analytic in each segment: $\\rho = (P/K_i)^{1/\\Gamma_i}$. The segment is identified by comparing $P$ to the boundary pressures $P(\\rho_{1})$ and $P(\\rho_{2})$, which are monotonic with $\\rho$ for $\\Gamma_{i}  1$.\n\nNumerical integration of the TOV system proceeds from a small radius $r_{0}$ to the surface at $P = P_{\\mathrm{surf}}$. We choose $r_{0}$ sufficiently small that the local series expansions hold and initialize\n$$\nm(r_{0}) \\approx \\frac{4\\pi}{3} r_{0}^{3}\\frac{\\varepsilon(\\rho_{c})}{c^{2}},\\qquad P(r_{0}) = P(\\rho_{c})\\,.\n$$\nThe denominator $r\\left(r - 2Gm/c^{2}\\right)$ remains positive throughout a neutron star model before the surface, ensuring regularity; adaptive step sizes handle stiffness near $r=0$. We scan over central densities $\\rho_{c}$ on a logarithmic grid from $\\rho_{c,\\min} = 2.0\\times 10^{14}\\,\\mathrm{g\\,cm^{-3}}$ to $\\rho_{c,\\max} = 2.0\\times 10^{15}\\,\\mathrm{g\\,cm^{-3}}$, computing $(M,R)$ for each model, with $M = m(R)$ converted to solar masses using $M_{\\odot} = 1.98847\\times 10^{33}\\,\\mathrm{g}$ and $R$ converted to kilometers using $1\\,\\mathrm{km} = 10^{5}\\,\\mathrm{cm}$.\n\nTo extract the slope and curvature of $M(R)$ near $1.4\\,M_{\\odot}$, we select the model whose mass $M$ is closest to $M_{\\star} = 1.4\\,M_{\\odot}$. Using that point with nearby neighbors from the sequence, we compute a local quadratic least-squares fit\n$$\nM(R) \\approx \\alpha + \\beta\\,(R - R_{0}) + \\gamma\\,(R - R_{0})^{2}\\,,\n$$\nwhere $R_{0}$ is the radius at the closest-to-target model. For a quadratic polynomial, the derivative and second derivative at $R_{0}$ are\n$$\n\\left.\\frac{dM}{dR}\\right|_{R_{0}} = \\beta,\\qquad \\left.\\frac{d^{2}M}{dR^{2}}\\right|_{R_{0}} = 2\\gamma\\,.\n$$\nWe report $\\beta$ in units of $M_{\\odot}\\,\\mathrm{km^{-1}}$ and $2\\gamma$ in units of $M_{\\odot}\\,\\mathrm{km^{-2}}$.\n\nAlgorithmic design:\n1. Construct the EoS objects for the specified $\\Gamma_{2}$ values. Precompute boundary pressures $P(\\rho_{1})$ and $P(\\rho_{2})$ to enable fast segment identification for $\\rho(P)$ inversion.\n2. For each EoS, loop over $N = 80$ central densities logarithmically spaced from $\\rho_{c,\\min}$ to $\\rho_{c,\\max}$. For each $\\rho_{c}$:\n   - Compute $P_{c} = P(\\rho_{c})$ and $\\varepsilon_{c} = \\varepsilon(\\rho_{c})$.\n   - Integrate the TOV system using an adaptive solver with an event to stop at $P_{\\mathrm{surf}} = 1.0\\times 10^{30}\\,\\mathrm{dyne\\,cm^{-2}}$, starting from $r_{0}$ with the series-based initialization for $m(r_{0})$ and $P(r_{0})$.\n   - Record $(M,R)$ after converting units.\n3. Identify the index whose $M$ is nearest to $1.4\\,M_{\\odot}$. Select up to two neighbors on each side to form a five-point stencil (or fewer if near sequence ends). Perform a least-squares fit of the quadratic model in the shifted variable $x = R - R_{0}$ to obtain $\\alpha,\\beta,\\gamma$.\n4. Append the pair $[\\beta,\\,2\\gamma]$ to the results for this EoS.\n5. After processing all test cases, print the single-line output in the exact format $[[s_{A},k_{A}],[s_{B},k_{B}],[s_{C},k_{C}],[s_{D},k_{D}]]$ with each number rounded to six digits after the decimal point.\n\nQualitative expectation: increasing the middle-segment $\\Gamma_{2}$ stiffens the EoS in the density range relevant to $\\sim 1.4\\,M_{\\odot}$, which increases radii at fixed mass and typically makes the local slope $\\left.\\dfrac{dM}{dR}\\right|_{1.4\\,M_{\\odot}}$ less negative in magnitude (i.e., the $M(R)$ curve flattens), while the curvature $\\left.\\dfrac{d^{2}M}{dR^{2}}\\right|_{1.4\\,M_{\\odot}}$ reflects how rapidly the stiffness changes with density around that mass scale. The program provides quantitative values consistent with this physical intuition.\n\nAll computations enforce pressure and energy density continuity, use $G = 6.67430\\times 10^{-8}\\,\\mathrm{cm^{3}\\,g^{-1}\\,s^{-2}}$, $c = 2.99792458\\times 10^{10}\\,\\mathrm{cm\\,s^{-1}}$, $M_{\\odot} = 1.98847\\times 10^{33}\\,\\mathrm{g}$, surface threshold $P_{\\mathrm{surf}} = 1.0\\times 10^{30}\\,\\mathrm{dyne\\,cm^{-2}}$, and report slopes in $M_{\\odot}\\,\\mathrm{km^{-1}}$ and curvatures in $M_{\\odot}\\,\\mathrm{km^{-2}}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Implements TOV integration for a three-segment piecewise-polytrope EOS\n# and computes local slope and curvature of M(R) near 1.4 Msun for various Gamma2.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Physical constants in cgs\nG = 6.67430e-8                 # cm^3 g^-1 s^-2\nc = 2.99792458e10              # cm s^-1\nM_sun = 1.98847e33             # g\nCM_PER_KM = 1.0e5              # cm per km\n\n# Surface pressure threshold (defines stellar surface)\nP_SURF = 1.0e30  # dyne/cm^2\n\n# EOS parameters (fixed except for Gamma2)\nRHO1 = 1.0e14  # g/cm^3\nRHO2 = 3.0e14  # g/cm^3\nGAMMA1 = 1.3\nGAMMA3 = 3.0\nP1_AT_RHO1 = 1.0e33  # dyne/cm^2\n\nclass PiecewisePolytrope:\n    \"\"\"\n    Three-segment piecewise-polytrope EOS with thermodynamically consistent energy density.\n    Segment i: P = K_i * rho^Gamma_i\n               eps = (1 + a_i) * rho * c^2 + K_i/(Gamma_i - 1) * rho^Gamma_i\n    \"\"\"\n    def __init__(self, gamma2: float):\n        self.gamma1 = GAMMA1\n        self.gamma2 = gamma2\n        self.gamma3 = GAMMA3\n        self.rho1 = RHO1\n        self.rho2 = RHO2\n\n        # Pressure continuity: set K1 by P1 at rho1; then K2 by continuity at rho1; K3 by continuity at rho2\n        self.K1 = P1_AT_RHO1 / (self.rho1 ** self.gamma1)\n        self.K2 = P1_AT_RHO1 / (self.rho1 ** self.gamma2)\n        P2_minus = self.K2 * (self.rho2 ** self.gamma2)\n        self.K3 = P2_minus / (self.rho2 ** self.gamma3)\n\n        # Energy density continuity: set a1 = 0, then compute a2, a3\n        self.a1 = 0.0\n        eps1_at_rho1 = (1.0 + self.a1) * self.rho1 * c**2 + self.K1 * (self.rho1 ** self.gamma1) / (self.gamma1 - 1.0)\n        # Solve for a2 at rho1\n        self.a2 = (eps1_at_rho1 - (self.rho1 * c**2 + self.K2 * (self.rho1 ** self.gamma2) / (self.gamma2 - 1.0))) / (self.rho1 * c**2)\n        # Solve for a3 at rho2\n        eps2_at_rho2 = (1.0 + self.a2) * self.rho2 * c**2 + self.K2 * (self.rho2 ** self.gamma2) / (self.gamma2 - 1.0)\n        self.a3 = (eps2_at_rho2 - (self.rho2 * c**2 + self.K3 * (self.rho2 ** self.gamma3) / (self.gamma3 - 1.0))) / (self.rho2 * c**2)\n\n        # Precompute boundary pressures for fast segment identification in rho(P)\n        self.P_rho1 = P1_AT_RHO1  # by construction\n        self.P_rho2 = P2_minus    # pressure at rho2 (same from seg2 or seg3)\n\n    def pressure_from_rho(self, rho: float) - float:\n        if rho  self.rho1:\n            return self.K1 * rho ** self.gamma1\n        elif rho  self.rho2:\n            return self.K2 * rho ** self.gamma2\n        else:\n            return self.K3 * rho ** self.gamma3\n\n    def epsilon_from_rho(self, rho: float) - float:\n        if rho  self.rho1:\n            return (1.0 + self.a1) * rho * c**2 + self.K1 * rho ** self.gamma1 / (self.gamma1 - 1.0)\n        elif rho  self.rho2:\n            return (1.0 + self.a2) * rho * c**2 + self.K2 * rho ** self.gamma2 / (self.gamma2 - 1.0)\n        else:\n            return (1.0 + self.a3) * rho * c**2 + self.K3 * rho ** self.gamma3 / (self.gamma3 - 1.0)\n\n    def rho_from_pressure(self, P: float) - float:\n        # Select segment by pressure thresholds P(rho1) and P(rho2) (monotonic in rho for Gamma1)\n        if P  self.P_rho1:\n            # Segment 1\n            rho = (P / self.K1) ** (1.0 / self.gamma1)\n        elif P  self.P_rho2:\n            # Segment 2\n            rho = (P / self.K2) ** (1.0 / self.gamma2)\n        else:\n            # Segment 3\n            rho = (P / self.K3) ** (1.0 / self.gamma3)\n        return rho\n\ndef tov_rhs(r, y, eos: PiecewisePolytrope):\n    m, P = y\n    # If already below surface threshold, derivatives are zero\n    if P = P_SURF or r = 0.0:\n        return [0.0, 0.0]\n    rho = eos.rho_from_pressure(P)\n    eps = eos.epsilon_from_rho(rho)\n    # Avoid singularity in denominator; if it occurs, derivatives will be large - integrator will backtrack\n    denom = r * (r - 2.0 * G * m / c**2)\n    if denom = 0.0:\n        # If denominator is zero or negative, set an extremely small step to drive event triggering or stop growth\n        denom = np.finfo(float).tiny\n    dPdr = -(G * (eps + P / c**2) * (m + 4.0 * np.pi * r**3 * P / c**2)) / denom\n    dmdr = 4.0 * np.pi * r**2 * eps / c**2\n    return [dmdr, dPdr]\n\ndef integrate_star(eos: PiecewisePolytrope, rho_c: float):\n    # Central conditions\n    P_c = eos.pressure_from_rho(rho_c)\n    eps_c = eos.epsilon_from_rho(rho_c)\n    # Start integration from small radius r0\n    r0 = 1.0  # cm\n    m0 = (4.0 / 3.0) * np.pi * r0**3 * eps_c / c**2\n    y0 = [m0, P_c]\n\n    # Event to stop at surface when pressure reaches P_SURF\n    def surface_event(r, y):\n        return y[1] - P_SURF\n    surface_event.terminal = True\n    surface_event.direction = -1.0\n\n    # Integrate up to a generous outer radius (e.g., 2e7 cm = 200 km)\n    r_max = 2.0e7\n    sol = solve_ivp(\n        fun=lambda rv, yv: tov_rhs(rv, yv, eos),\n        t_span=(r0, r_max),\n        y0=y0,\n        method='RK45',\n        rtol=1e-6,\n        atol=1e-10,\n        events=surface_event,\n        max_step=1.0e5  # cap step to resolve structure\n    )\n\n    if sol.status == 1 and sol.t_events[0].size  0:\n        R_surface = sol.t_events[0][0]\n        m_surface = sol.y_events[0][0][0]\n    else:\n        # Fallback: take last point if event did not trigger (should not happen for reasonable EOS)\n        R_surface = sol.t[-1]\n        m_surface = sol.y[0, -1]\n\n    M_grav = m_surface  # in grams\n    R_cm = R_surface    # in cm\n    return M_grav, R_cm\n\ndef build_mass_radius_curve(eos: PiecewisePolytrope, rho_min=2.0e14, rho_max=2.0e15, npts=80):\n    # Logarithmic sampling of central densities\n    rhos = np.logspace(np.log10(rho_min), np.log10(rho_max), npts)\n    Ms = []\n    Rs = []\n    for rho_c in rhos:\n        M_g, R_cm = integrate_star(eos, rho_c)\n        Ms.append(M_g / M_sun)        # convert to solar masses\n        Rs.append(R_cm / CM_PER_KM)   # convert to kilometers\n    return np.array(Rs), np.array(Ms)\n\ndef local_slope_and_curvature(R_km: np.ndarray, M_msun: np.ndarray, M_target=1.4):\n    # Find index closest to target mass\n    idx = int(np.argmin(np.abs(M_msun - M_target)))\n\n    # Choose a local stencil: ideally 5 points centered on idx\n    n = len(R_km)\n    # Determine bounds\n    left = max(0, idx - 2)\n    right = min(n - 1, idx + 2)\n    # If not enough points, expand as possible\n    while (right - left + 1)  5:\n        if left  0:\n            left -= 1\n        if (right - left + 1) = 5:\n            break\n        if right  n - 1:\n            right += 1\n        if left == 0 and right == n - 1:\n            break\n    # Extract local data\n    R0 = R_km[idx]\n    R_local = R_km[left:right+1]\n    M_local = M_msun[left:right+1]\n    x = R_local - R0\n    # Fit quadratic M = a + b x + c x^2 via least squares\n    A = np.vstack([np.ones_like(x), x, x**2]).T\n    coeffs, *_ = np.linalg.lstsq(A, M_local, rcond=None)\n    a, b, c2 = coeffs\n    slope = b                      # dM/dR at R0\n    curvature = 2.0 * c2           # d^2 M / dR^2 at R0\n    return slope, curvature\n\ndef analyze_gamma2_values(gamma2_list):\n    results = []\n    for g2 in gamma2_list:\n        eos = PiecewisePolytrope(gamma2=g2)\n        R_km, M_msun = build_mass_radius_curve(eos, rho_min=2.0e14, rho_max=2.0e15, npts=80)\n        slope, curvature = local_slope_and_curvature(R_km, M_msun, M_target=1.4)\n        results.append((slope, curvature))\n    return results\n\ndef solve():\n    # Define the test cases (Gamma2 values)\n    test_cases = [2.0, 2.4, 2.8, 3.2]\n\n    # Compute results for each case\n    results = analyze_gamma2_values(test_cases)\n\n    # Format results as JSON-like list of [slope, curvature] pairs with six decimals, no spaces\n    formatted = \"[\" + \",\".join([f\"[{s:.6f},{k:.6f}]\" for (s, k) in results]) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}