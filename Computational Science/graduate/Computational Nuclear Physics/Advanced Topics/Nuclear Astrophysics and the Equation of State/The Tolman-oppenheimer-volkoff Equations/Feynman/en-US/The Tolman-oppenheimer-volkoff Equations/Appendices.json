{
    "hands_on_practices": [
        {
            "introduction": "To begin our exploration of relativistic stellar structure, we must first build the essential tool: a numerical solver for the Tolman-Oppenheimer-Volkoff (TOV) equations. This foundational exercise guides you through deriving the equations for mass and pressure from the first principles of General Relativity and implementing a solver that can handle different forms of the equation of state (EoS). Mastering this practice  is the first crucial step toward understanding how the microscopic physics encoded in the EoS determines the macroscopic properties, like mass and radius, of a compact star.",
            "id": "3608213",
            "problem": "You are to derive and implement a solver for the static structure of a relativistic, spherically symmetric neutron star by integrating the equations that follow from Einstein’s field equations for a perfect fluid in hydrostatic equilibrium. Begin from the following fundamental bases: the Einstein field equations, the static spherically symmetric line element, the local conservation of stress-energy for a perfect fluid, and the definition of mass-energy density and pressure. Use these to obtain the governing ordinary differential equations for the radial mass accumulation and pressure gradient (the Tolman-Oppenheimer-Volkoff (TOV) equations), together with a closure provided by the Equation of State (EoS). Do not assume any shortcut formulas beyond these bases. Your solver must support both a single polytropic EoS and a two-segment piecewise polytropic EoS, and must be implemented as a complete, runnable program.\n\nAssumptions and units:\n- Work in geometrized units with $G=c=1$, which implies that $[\\text{energy density}]=[\\text{pressure}]=\\text{length}^{-2}$, $[\\text{mass}]=\\text{length}$, and $[\\text{radius}]=\\text{length}$.\n- Express radii in $\\mathrm{km}$ and gravitational mass in units of the Solar mass $M_\\odot$ by converting length to mass via $M_\\odot^{\\mathrm{geo}} = 1.47662504\\,\\mathrm{km}$. Report masses as dimensionless multiples of $M_\\odot$.\n- You must round every reported float to $3$ decimal places.\n\nModeling requirements:\n1. Perfect fluid and hydrostatic equilibrium: Use the conservation of stress-energy for a perfect fluid and spherical symmetry to derive the governing relations for $m(r)$ and $P(r)$ in terms of the mass-energy density $\\varepsilon(r)$.\n2. Single polytropic EoS: Implement $P = K\\,\\rho^\\Gamma$ and $\\varepsilon = \\rho + \\dfrac{P}{\\Gamma - 1}$ for rest-mass density $\\rho$, with $K>0$ and $\\Gamma>1$.\n3. Two-segment piecewise polytropic EoS: For segment $i$, use $P_i = K_i\\,\\rho^{\\Gamma_i}$ and $\\varepsilon_i = \\rho + \\dfrac{P_i}{\\Gamma_i - 1}$, with continuity of $P(\\rho)$ enforced at the segment boundary $\\rho=\\rho_1$, that is $K_2 = \\dfrac{K_1\\,\\rho_1^{\\Gamma_1}}{\\rho_1^{\\Gamma_2}}$. Inversion from $P$ to $\\rho$ must respect the segment domain: if the inferred $\\rho$ lies in $[0,\\rho_1]$, use segment $1$; otherwise use segment $2$.\n4. Central boundary conditions: Handle the regularity at the stellar center. Initialize at a small radius $r_0>0$ using a series expansion consistent with spherical symmetry to avoid division by zero, with the central pressure $P_c$ determining the central mass-energy density $\\varepsilon_c$ via the EoS.\n5. Integration stopping criteria: Integrate outward until the pressure first reaches zero, defining the stellar surface radius $R$ and gravitational mass $M=m(R)$. Also halt if a compactness singularity is approached, that is when $r-2m(r)\\rightarrow 0^+$.\n\nNumerical requirements:\n- Implement the integration with an adaptive step method suitable for non-linear stiff ordinary differential equations.\n- Use an event function to stop at the first zero crossing of $P(r)$ from above.\n\nTest suite and output specification:\nImplement a program that evaluates the following test cases. For each case, scan the central pressure $P_c$ over a logarithmically spaced grid and return the maximum mass and its corresponding radius.\n\n- Case $1$ (single polytrope, “happy path”): $K=0.02$, $\\Gamma=2.0$, $P_c\\in[10^{-4},\\,10^{-0}]$ sampled at $50$ logarithmically spaced points.\n- Case $2$ (single polytrope, “stiff”): $K=0.008$, $\\Gamma=2.5$, $P_c\\in[10^{-4},\\,10^{-0}]$ sampled at $50$ logarithmically spaced points.\n- Case $3$ (two-segment piecewise polytrope, edge case traversing the segment boundary): Segment $1$ parameters $K_1=0.02$, $\\Gamma_1=1.3$, boundary at $\\rho_1=0.1$; Segment $2$ parameters $\\Gamma_2=3.5$ and $K_2$ chosen by continuity at $\\rho_1$; scan $P_c\\in[10^{-3},\\,10^{-0}]$ sampled at $60$ logarithmically spaced points.\n\nFor each case, compute:\n- The maximum gravitational mass $M_{\\max}$ in $M_\\odot$.\n- The radius $R$ in $\\mathrm{km}$ at which $M_{\\max}$ occurs.\n\nRound each value to $3$ decimal places. Your program should produce a single line of output containing the results in the following format: a comma-separated list enclosed in square brackets, ordered as $[M_{\\max}^{(1)},R^{(1)},M_{\\max}^{(2)},R^{(2)},M_{\\max}^{(3)},R^{(3)}]$, where the superscript indicates the case number.",
            "solution": "The task is to derive the Tolman-Oppenheimer-Volkoff (TOV) equations for the structure of a static, spherically symmetric, relativistic star and to implement a numerical solver for these equations. The solver must accommodate both single and piecewise polytropic equations of state (EoS) and determine the maximum mass of a star for given EoS parameters.\n\n### Part 1: Derivation of the TOV Equations\n\nThe derivation begins from the fundamental principles of Einstein's General Relativity.\n\n**1. Metric and Geometry**\n\nFor a static and spherically symmetric spacetime, the geometry is described by the line element:\n$$\nds^2 = -e^{2\\Phi(r)} c^2 dt^2 + \\left(1 - \\frac{2Gm(r)}{c^2 r}\\right)^{-1} dr^2 + r^2 (d\\theta^2 + \\sin^2\\theta d\\phi^2)\n$$\nHere, $\\Phi(r)$ is the metric potential and $m(r)$ is the gravitational mass enclosed within a radius $r$. We adopt geometrized units where the gravitational constant $G$ and the speed of light $c$ are set to unity ($G=c=1$). The line element simplifies to:\n$$\nds^2 = -e^{2\\Phi(r)} dt^2 + \\left(1 - \\frac{2m(r)}{r}\\right)^{-1} dr^2 + r^2 d\\Omega^2\n$$\nwhere $d\\Omega^2 = d\\theta^2 + \\sin^2\\theta d\\phi^2$. The metric components are $g_{tt} = -e^{2\\Phi(r)}$ and $g_{rr} = (1 - 2m(r)/r)^{-1}$.\n\n**2. Stress-Energy Tensor**\n\nThe matter content of the star is modeled as a perfect fluid, which is isotropic in its rest frame. The stress-energy tensor for a perfect fluid is:\n$$\nT^{\\mu\\nu} = (\\varepsilon + P)u^\\mu u^\\nu + P g^{\\mu\\nu}\n$$\nwhere $\\varepsilon$ is the total mass-energy density, $P$ is the pressure, and $u^\\mu$ is the fluid's four-velocity. In a static configuration, the fluid is at rest with respect to the chosen coordinates, so $u^\\mu = (e^{-\\Phi(r)}, 0, 0, 0)$. The covariant components of the stress-energy tensor are diagonal:\n$$\nT_{\\mu\\nu} = \\text{diag}(\\varepsilon e^{2\\Phi(r)}, P(1-2m(r)/r)^{-1}, Pr^2, Pr^2\\sin^2\\theta)\n$$\n\n**3. Einstein's Field Equations**\n\nEinstein's field equations relate the geometry of spacetime (through the Einstein tensor $G_{\\mu\\nu}$) to the distribution of matter and energy (through the stress-energy tensor $T_{\\mu\\nu}$):\n$$\nG_{\\mu\\nu} = R_{\\mu\\nu} - \\frac{1}{2} R g_{\\mu\\nu} = 8\\pi T_{\\mu\\nu}\n$$\nCalculating the Einstein tensor for the given metric yields several components. The 'tt' (or '00') component is:\n$$\nG_{tt} = e^{2\\Phi}\\left(1-\\frac{2m}{r}\\right)\\left[\\frac{1}{r^2}\\frac{d}{dr}\\left(r\\left(1 - \\left(1-\\frac{2m}{r}\\right)\\right)\\right)\\right] = e^{2\\Phi}\\frac{2}{r^2}\\frac{dm}{dr}\n$$\nEquating this to $8\\pi T_{tt} = 8\\pi \\varepsilon e^{2\\Phi}$ gives:\n$$\ne^{2\\Phi}\\frac{2}{r^2}\\frac{dm}{dr} = 8\\pi \\varepsilon e^{2\\Phi} \\implies \\frac{dm}{dr} = 4\\pi r^2 \\varepsilon(r)\n$$\nThis is the first TOV equation. It describes how the enclosed mass $m(r)$ increases with radius as a function of the local mass-energy density $\\varepsilon(r)$.\n\n**4. Hydrostatic Equilibrium**\n\nThe second equation arises from the conservation of stress-energy, $\\nabla_\\nu T^{\\mu\\nu} = 0$, which expresses hydrostatic equilibrium. For a static fluid, the spatial components of this equation dictate the pressure gradient required to counteract gravity. The radial ($\\mu=r$) component of the conservation law is:\n$$\n\\frac{dP}{dr} = -(\\varepsilon + P) \\frac{d\\Phi}{dr}\n$$\nTo use this, we need an expression for $d\\Phi/dr$. This can be found by manipulating the field equations. The 'rr' component of the field equations is:\n$$\nG_{rr} = \\frac{2}{r}\\frac{d\\Phi}{dr}\\left(1-\\frac{2m}{r}\\right)^{-1} - \\frac{2m}{r^2}\\left(1-\\frac{2m}{r}\\right)^{-1} = 8\\pi T_{rr} = 8\\pi P \\left(1-\\frac{2m}{r}\\right)^{-1}\n$$\nMultiplying by $(1-2m/r)$ and rearranging gives:\n$$\n\\frac{2}{r}\\frac{d\\Phi}{dr} - \\frac{2m}{r^2} = 8\\pi P \\implies \\frac{d\\Phi}{dr} = \\frac{m(r) + 4\\pi r^3 P(r)}{r^2}\n$$\nThis expression is valid only if one assumes that $r-2m \\neq 0$. However, a more robust manipulation that does not make this assumption leads to:\n$$\n\\frac{d\\Phi}{dr} = \\frac{m(r) + 4\\pi r^3 P(r)}{r(r-2m(r))}\n$$\nSubstituting this into the hydrostatic equilibrium equation yields the second TOV equation:\n$$\n\\frac{dP}{dr} = - \\frac{(\\varepsilon(r) + P(r))(m(r) + 4\\pi r^3 P(r))}{r(r-2m(r))}\n$$\n\n**5. Equation of State (EoS)**\n\nThe two coupled ordinary differential equations (ODEs), for $m(r)$ and $P(r)$, involve three unknown functions: $m(r)$, $P(r)$, and $\\varepsilon(r)$. A third relation, the Equation of State (EoS), is required for closure. The EoS relates pressure and energy density, $\\varepsilon = \\varepsilon(P)$.\n\nFor a single polytropic EoS: $P = K\\rho^\\Gamma$. The mass-energy density $\\varepsilon$ is related to the rest-mass density $\\rho$ by $\\varepsilon = \\rho + u_{\\text{int}}$, where $u_{\\text{int}}$ is the internal energy density. From the first law of thermodynamics for an adiabatic process, $d(\\varepsilon/\\rho) = -P d(1/\\rho)$, one obtains $u_{\\text{int}} = P/(\\Gamma-1)$. Thus:\n$$\n\\varepsilon = \\rho + \\frac{P}{\\Gamma-1}\n$$\nTo express $\\varepsilon$ as a function of $P$, we first invert for $\\rho$: $\\rho = (P/K)^{1/\\Gamma}$. Then,\n$$\n\\varepsilon(P) = \\left(\\frac{P}{K}\\right)^{1/\\Gamma} + \\frac{P}{\\Gamma-1}\n$$\nFor a piecewise polytropic EoS, this relationship is defined segment-wise, ensuring continuity of $P(\\rho)$ at segment boundaries.\n\n### Part 2: Numerical Implementation\n\nThe TOV equations form an initial value problem. Given a central pressure $P_c = P(r=0)$, we can determine the star's structure by integrating outwards.\n\n**1. Initial Conditions**\n\nThe ODEs are singular at $r=0$. We start the integration at a small radius $r_0 \\ll 1$. The values $m(r_0)$ and $P(r_0)$ are found by Taylor expansion around $r=0$. Assuming $\\varepsilon(r)$ is approximately constant near the center ($\\varepsilon(r) \\approx \\varepsilon_c$), the mass equation integrates to:\n$$\nm(r_0) = \\int_0^{r_0} 4\\pi r^2 \\varepsilon_c dr = \\frac{4\\pi}{3} r_0^3 \\varepsilon_c\n$$\nSimilarly, the pressure equation can be approximated to first order, yielding $P(r_0) \\approx P_c$. The correction term is of order $r_0^2$ and negligible for sufficiently small $r_0$. The central energy density $\\varepsilon_c$ is determined from the central pressure $P_c$ via the EoS.\n\n**2. Integration**\n\nThe system of ODEs is integrated numerically using an adaptive-step-size solver suitable for potentially stiff equations, as provided by `scipy.integrate.solve_ivp`. The system to be solved is:\n$$\n\\frac{d\\mathbf{y}}{dr} = \\mathbf{f}(r, \\mathbf{y})\n\\quad \\text{where} \\quad\n\\mathbf{y} = \\begin{pmatrix} m \\\\ P \\end{pmatrix}\n\\quad \\text{and} \\quad\n\\mathbf{f}(r, \\mathbf{y}) = \\begin{pmatrix} 4\\pi r^2 \\varepsilon(P) \\\\ -\\frac{(\\varepsilon(P) + P)(m + 4\\pi r^3 P)}{r(r-2m)} \\end{pmatrix}\n$$\n\n**3. Termination Conditions**\n\nThe integration proceeds outwards from $r=r_0$ until a termination condition is met. These are implemented as \"events\" in the solver.\n- **Stellar Surface**: The surface of the star, $r=R$, is defined as the point where the pressure drops to zero. We detect the first root of $P(r)=0$. The mass at this radius is the star's total gravitational mass, $M=m(R)$.\n- **Singularity**: The integration must halt if the denominator term $r-2m(r)$ approaches zero, as this indicates the formation of an event horizon and the breakdown of the static assumption (i.e., gravitational collapse). We detect the first root of $r-2m(r)=0$.\n\n**4. Finding the Maximum Mass**\n\nTo find the maximum possible mass for a given EoS, the procedure is repeated for a range of central pressures $P_c$. This generates a mass-radius relation, $M(R)$, and a mass-central pressure relation, $M(P_c)$. The maximum mass, $M_{\\text{max}}$, is the peak of the $M(P_c)$ curve. The corresponding radius is the radius of that maximum-mass star.\n\nAll calculations are performed in geometrized units with length in km. Final masses are converted to solar masses using the given conversion factor $M_\\odot^{\\mathrm{geo}} = 1.47662504\\,\\mathrm{km}$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom typing import List, Tuple, Dict, Any, Callable\n\ndef solve():\n    \"\"\"\n    Main function to solve the TOV equations for the specified test cases\n    and print the results in the required format.\n    \"\"\"\n    \n    # Conversion factor for mass from km to Solar Masses\n    M_SUN_IN_KM = 1.47662504\n\n    # Define EoS classes\n    class SinglePolytropeEoS:\n        \"\"\"\n        Represents a single polytropic equation of state.\n        P = K * rho^Gamma\n        epsilon = rho + P/(Gamma - 1)\n        \"\"\"\n        def __init__(self, K: float, Gamma: float):\n            if Gamma = 1:\n                raise ValueError(\"Polytropic index Gamma must be > 1.\")\n            self.K = K\n            self.Gamma = Gamma\n            self.inv_Gamma = 1.0 / Gamma\n\n        def eps_from_P(self, P: np.ndarray) -> np.ndarray:\n            \"\"\"Calculates energy density from pressure.\"\"\"\n            P = np.maximum(0, P)\n            rho = (P / self.K)**self.inv_Gamma\n            eps = rho + P / (self.Gamma - 1)\n            return eps\n\n    class PiecewisePolytropeEoS:\n        \"\"\"\n        Represents a two-segment piecewise polytropic equation of state.\n        Continuity of pressure at the boundary rho1 is enforced.\n        \"\"\"\n        def __init__(self, K1: float, Gamma1: float, rho1: float, Gamma2: float):\n            if Gamma1 = 1 or Gamma2 = 1:\n                raise ValueError(\"Polytropic indices Gamma must be > 1.\")\n            self.K1 = K1\n            self.Gamma1 = Gamma1\n            self.rho1 = rho1\n            self.Gamma2 = Gamma2\n            \n            # Pressure at the boundary\n            self.P1 = self.K1 * self.rho1**self.Gamma1\n            # Continuity condition for K2\n            self.K2 = self.P1 / (self.rho1**self.Gamma2)\n\n            self.inv_Gamma1 = 1.0 / self.Gamma1\n            self.inv_Gamma2 = 1.0 / self.Gamma2\n\n        def eps_from_P(self, P: np.ndarray) -> np.ndarray:\n            \"\"\"Calculates energy density from pressure, handling segments.\"\"\"\n            P = np.maximum(0, P)\n            is_segment1 = P = self.P1\n            is_segment2 = ~is_segment1\n            \n            eps = np.zeros_like(P, dtype=float)\n            \n            # Segment 1: P = P1\n            P_seg1 = P[is_segment1]\n            rho_seg1 = (P_seg1 / self.K1)**self.inv_Gamma1\n            eps[is_segment1] = rho_seg1 + P_seg1 / (self.Gamma1 - 1)\n\n            # Segment 2: P > P1\n            P_seg2 = P[is_segment2]\n            rho_seg2 = (P_seg2 / self.K2)**self.inv_Gamma2\n            eps[is_segment2] = rho_seg2 + P_seg2 / (self.Gamma2 - 1)\n\n            return eps\n\n    # Define the TOV ODE system\n    def tov_rhs(r: float, y: List[float], eos: Any) -> List[float]:\n        \"\"\"\n        Right-hand side of the Tolman-Oppenheimer-Volkoff equations.\n        y = [m, P]\n        \"\"\"\n        m, P = y\n        \n        # Guard against unphysical values\n        if P  0 or r  1e-10:\n            return [0, 0]\n\n        eps = eos.eps_from_P(np.array([P]))[0]\n\n        # Compactness singularity check\n        if r = 2.0 * m:\n            return [0, 0]\n\n        dmdr = 4.0 * np.pi * r**2 * eps\n        \n        numerator = (eps + P) * (m + 4.0 * np.pi * r**3 * P)\n        denominator = r * (r - 2.0 * m)\n        dPdr = -numerator / denominator\n        \n        return [dmdr, dPdr]\n\n    # Define event functions for integration termination\n    def pressure_zero(r: float, y: List[float], eos: Any) -> float:\n        \"\"\"Event function to stop when pressure becomes zero.\"\"\"\n        return y[1] # Pressure\n    pressure_zero.terminal = True\n    pressure_zero.direction = -1 # Stop when P crosses zero from positive\n\n    def singularity(r: float, y: List[float], eos: Any) -> float:\n        \"\"\"Event function to stop when a singularity is approached.\"\"\"\n        return r - 2.0 * y[0]\n    singularity.terminal = True\n\n    # Define the main solver loop for a given EoS and pressure range\n    def find_max_mass_star(eos: Any, Pc_range: np.ndarray) -> Tuple[float, float]:\n        \"\"\"\n        Scans a range of central pressures to find the maximum mass star.\n        Returns (Max Mass in M_sun, Radius at Max Mass in km).\n        \"\"\"\n        masses = []\n        radii = []\n\n        r_start = 1e-6  # Small initial radius to avoid singularity at r=0\n        r_max = 50.0  # Maximum integration radius in km\n\n        for Pc in Pc_range:\n            eps_c = eos.eps_from_P(np.array([Pc]))[0]\n            \n            # Initial conditions at r_start\n            m_start = (4.0/3.0) * np.pi * r_start**3 * eps_c\n            P_start = Pc \n            y0 = [m_start, P_start]\n            \n            sol = solve_ivp(\n                tov_rhs,\n                (r_start, r_max),\n                y0,\n                method='RK45',\n                events=(pressure_zero, singularity),\n                args=(eos,),\n                dense_output=True,\n                atol=1e-8,\n                rtol=1e-8,\n            )\n            \n            # Check if integration stopped due to an event\n            if sol.status == 1:\n                # Check if the pressure_zero event was triggered\n                if sol.t_events[0].size > 0:\n                    R_star = sol.t_events[0][0]\n                    # Interpolate mass at the surface\n                    M_star = sol.sol(R_star)[0]\n                    masses.append(M_star)\n                    radii.append(R_star)\n        \n        if not masses:\n            return 0.0, 0.0\n\n        masses = np.array(masses)\n        radii = np.array(radii)\n\n        # Find the maximum mass and corresponding radius\n        if len(masses) > 0:\n            max_mass_idx = np.argmax(masses)\n            M_max_km = masses[max_mass_idx]\n            R_at_M_max_km = radii[max_mass_idx]\n            \n            M_max_solar = M_max_km / M_SUN_IN_KM\n            return M_max_solar, R_at_M_max_km\n        else:\n            return 0.0, 0.0\n\n    # Test cases setup and execution\n    test_cases = [\n        {\n            \"eos\": SinglePolytropeEoS(K=0.02, Gamma=2.0),\n            \"Pc_range\": np.logspace(-4, 0, 50)\n        },\n        {\n            \"eos\": SinglePolytropeEoS(K=0.008, Gamma=2.5),\n            \"Pc_range\": np.logspace(-4, 0, 50)\n        },\n        {\n            \"eos\": PiecewisePolytropeEoS(K1=0.02, Gamma1=1.3, rho1=0.1, Gamma2=3.5),\n            \"Pc_range\": np.logspace(-3, 0, 60)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        M_max, R = find_max_mass_star(case[\"eos\"], case[\"Pc_range\"])\n        results.append(round(M_max, 3))\n        results.append(round(R, 3))\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a working TOV solver, we can now probe deeper into the physical properties of a star beyond its simple mass and radius. This practice focuses on a crucial concept: the distinction between a star's gravitational mass ($M$) and its baryonic mass ($M_b$). You will extend your solver to integrate the baryon number density over the proper volume in curved spacetime, allowing you to calculate the star's total gravitational binding energy, $E_b = M_b - M$. This exercise  provides profound insight into the energetics and stability of compact objects, revealing how much of the matter's rest-mass energy is converted to binding energy by the extreme gravitational field.",
            "id": "3608210",
            "problem": "You are tasked with building a program that computes the gravitational binding energy of compact stars by numerically integrating the structure equations for a static, spherically symmetric perfect fluid star in general relativity. The objective is to evaluate, across a small suite of equations of state, the dimensionless gravitational binding energy fraction defined as $E_b/M = (M_b - M)/M$, where $M$ is the gravitational (total) mass and $M_b$ is the total baryonic mass. The program must implement the full pipeline: derive and solve the stellar structure equations from first principles, integrate the conserved baryon number to obtain $M_b$, and then report the resulting $E_b/M$ for a provided test suite of models.\n\nFundamental principles you must use:\n- A static, spherically symmetric spacetime with a perfect fluid is governed by the Einstein field equations with the stress-energy tensor $T^{\\mu\\nu} = (\\varepsilon + P) u^{\\mu} u^{\\nu} + P g^{\\mu\\nu}$, where $\\varepsilon$ is the total energy density, $P$ is the pressure, $u^{\\mu}$ is the four-velocity, and $g^{\\mu\\nu}$ is the metric.\n- The local conservation of stress-energy $\\nabla_{\\mu} T^{\\mu\\nu} = 0$ and the conservation of the baryon number current $j^{\\mu} = n_b u^{\\mu}$ with $\\nabla_{\\mu} j^{\\mu} = 0$.\n- A barotropic, cold matter equation of state (EOS) where, for a polytrope, the pressure satisfies $P = K \\rho_0^{\\Gamma}$ with rest-mass density $\\rho_0$, polytropic constant $K$, and adiabatic index $\\Gamma$. For such a barotrope, the total energy density is $\\varepsilon = \\rho_0 + P / (\\Gamma - 1)$, and the baryon number density is $n_b = \\rho_0 / m_b$, with $m_b$ the baryon rest mass.\n\nFrom these principles, you must derive the equations governing hydrostatic equilibrium and mass-energy accumulation for a star, and construct the necessary ordinary differential equations (ODEs) that evolve the mass, pressure, and baryonic mass with the radial coordinate. The star’s surface is defined where the pressure first vanishes. Your numerical method should integrate outward from a small inner radius (to regularize the origin) using initial conditions implied by the central density.\n\nAssumptions and units:\n- Use geometric units with $G = c = 1$. All computed quantities are therefore in these units. Treat the baryon rest mass per baryon as $m_b = 1$, so that $\\rho_0 = n_b$.\n- The final required outputs are dimensionless fractions $E_b/M$, so no physical unit conversion is required. Do not print any units.\n\nImplementation requirements:\n- Choose the state vector and ODEs based on the principles above. Your implementation must integrate the gravitational (total) mass and the baryonic mass consistently with the proper volume element implied by the static, spherically symmetric metric, and the hydrostatic equilibrium condition implied by stress-energy conservation.\n- Use a robust ODE integrator with adaptive step size. Start at a small radius $r_0$ with initial values implied by the central density. Stop integration at the first radius where the pressure vanishes.\n- If a breakdown of the static solution is encountered (for example, if the Schwarzschild factor $1 - 2 m(r)/r$ approaches zero before the pressure vanishes), the model should be treated as failed and the corresponding output should be `nan`.\n\nEquation of state family:\n- You must implement polytropic equations of state with $P = K \\rho_0^{\\Gamma}$ and $\\varepsilon = \\rho_0 + P/(\\Gamma - 1)$, and $m_b = 1$ so that $n_b = \\rho_0$.\n- For numerical integration of the ODEs, invert the relation to obtain $\\rho_0 = (P/K)^{1/\\Gamma}$ wherever $P > 0$.\n\nTest suite:\nRun your program for the following six test cases, each specified by a tuple $(\\Gamma, K, \\rho_{0,c})$ where $\\rho_{0,c}$ is the central rest-mass density:\n- Case $1$: $(\\Gamma = 2.0, K = 0.2, \\rho_{0,c} = 0.010)$\n- Case $2$: $(\\Gamma = 2.0, K = 0.2, \\rho_{0,c} = 0.020)$\n- Case $3$: $(\\Gamma = 2.5, K = 0.05, \\rho_{0,c} = 0.010)$\n- Case $4$: $(\\Gamma = 2.5, K = 0.05, \\rho_{0,c} = 0.020)$\n- Case $5$: $(\\Gamma = 3.0, K = 0.02, \\rho_{0,c} = 0.015)$\n- Edge Case $6$: $(\\Gamma = 2.0, K = 0.2, \\rho_{0,c} = 0.005)$\n\nRequired outputs:\n- For each case, compute the gravitational mass $M$, the baryonic mass $M_b$ obtained by integrating the conserved baryon number over proper volume, and then compute the scalar $E_b/M = (M_b - M)/M$.\n- Your program should produce a single line of output containing the six results, in the order of the cases above, as a comma-separated Python list of decimal numbers enclosed in square brackets. For example, print a line like $[\\$v_1\\$,\\$v_2\\$,\\$v_3\\$,\\$v_4\\$,\\$v_5\\$,\\$v_6\\$]$ where each $\\$v_i\\$ is the computed value for case $i$; if a model fails according to the rule above, output `nan` in that position. You must print decimal numbers; do not print any units. Round or format as you see fit, but ensure each entry is a valid Python float literal.\n\nScientific realism and coverage:\n- The selected parameters span softer and stiffer polytropes via increasing $\\Gamma$ and varying $K$, and central densities that probe different compactness regimes. The edge case uses a relatively low central density to test the small-mass limit.\n- Ensure your code handles the near-origin regularization, surface detection, and the possible onset of coordinate singularity if the Schwarzschild factor approaches zero before the surface is reached.",
            "solution": "The problem statement is assessed to be valid. It is a well-posed, scientifically grounded problem in computational astrophysics that requires the numerical integration of the Tolman-Oppenheimer-Volkoff (TOV) equations for stellar structure in general relativity. All necessary physical principles, equations of state, and numerical parameters are provided, allowing for a unique and meaningful solution.\n\nThe core of this problem is to determine the structure of a static, spherically symmetric star composed of a perfect fluid. The solution requires deriving and solving the differential equations that govern the star's properties.\n\n**1. Theoretical Framework and Metric**\nIn general relativity, the geometry of spacetime is described by the metric tensor $g_{\\mu\\nu}$. For a static and spherically symmetric mass distribution, the spacetime geometry is described by the following line element in Schwarzschild-like coordinates $(t, r, \\theta, \\phi)$:\n$$\nds^2 = -e^{2\\Phi(r)} dt^2 + \\left(1 - \\frac{2m(r)}{r}\\right)^{-1} dr^2 + r^2(d\\theta^2 + \\sin^2\\theta d\\phi^2)\n$$\nHere, $m(r)$ is the gravitational mass enclosed within a sphere of coordinate radius $r$, and $\\Phi(r)$ is the metric potential related to gravitational redshift. The units are geometric units, where the gravitational constant $G$ and the speed of light $c$ are set to $1$, i.e., $G=c=1$.\n\n**2. Derivation of the Stellar Structure Equations**\nThe structure is determined by the Einstein field equations, $G_{\\mu\\nu} = 8\\pi T_{\\mu\\nu}$, where $G_{\\mu\\nu}$ is the Einstein tensor and $T_{\\mu\\nu}$ is the stress-energy tensor. The problem specifies a perfect fluid, for which the stress-energy tensor is:\n$$\nT^{\\mu\\nu} = (\\varepsilon + P) u^{\\mu} u^{\\nu} + P g^{\\mu\\nu}\n$$\nwhere $\\varepsilon(r)$ is the total energy density, $P(r)$ is the pressure, and $u^{\\mu}$ is the fluid's four-velocity, which is purely time-like in the star's rest frame.\n\nFrom these principles, we derive a system of ordinary differential equations (ODEs).\n\n**Equation for Gravitational Mass:**\nThe $tt$-component of the Einstein equations, $G_{tt} = 8\\pi T_{tt}$, relates the rate of change of the enclosed mass $m(r)$ to the local energy density $\\varepsilon(r)$. This yields the first ODE:\n$$\n\\frac{dm}{dr} = 4\\pi r^2 \\varepsilon(r)\n$$\nThis equation describes how the total mass-energy accumulates with increasing radius.\n\n**Equation for Hydrostatic Equilibrium:**\nThe conservation of stress-energy, $\\nabla_\\mu T^{\\mu\\nu} = 0$, enforces hydrostatic equilibrium, balancing the inward pull of gravity with the outward push of the pressure gradient. The spatial component of this conservation law yields the Tolman-Oppenheimer-Volkoff (TOV) equation:\n$$\n\\frac{dP}{dr} = - \\frac{(\\varepsilon(r) + P(r))(m(r) + 4\\pi r^3 P(r))}{r(r - 2m(r))}\n$$\nThis is the second ODE, describing the pressure profile within the star. It is the relativistic generalization of the classical Newtonian equation for hydrostatic equilibrium.\n\n**Equation for Baryonic Mass:**\nThe problem requires computing the total baryonic mass $M_b$, which is distinct from the gravitational mass $M$. The total baryonic mass is the sum of the rest masses of all baryons in the star. Given the problem's assumption that the baryon rest mass $m_b = 1$, the baryonic mass $M_b$ is equivalent to the total number of baryons $N_b$. This is found by integrating the baryon number density $n_b(r)$ over the proper volume of the star. With the assumption $n_b = \\rho_0$ (where $\\rho_0$ is the rest-mass density), we have:\n$$\nM_b = \\int_0^R n_b(r) dV_{\\text{proper}}\n$$\nThe proper volume element $dV_{\\text{proper}}$ for a spatial slice at constant time is given by $\\sqrt{\\gamma} dr d\\theta d\\phi$, where $\\gamma$ is the determinant of the spatial part of the metric. This yields $dV_{\\text{proper}} = 4\\pi r^2 (1 - 2m(r)/r)^{-1/2} dr$. The equation for the accumulation of baryonic mass is thus:\n$$\n\\frac{dM_b}{dr} = 4\\pi r^2 \\rho_0(r) \\left(1 - \\frac{2m(r)}{r}\\right)^{-1/2}\n$$\nThis is our third ODE.\n\n**3. Equation of State (EOS)**\nTo solve this system, we need a relation between $P$, $\\varepsilon$, and $\\rho_0$. The problem provides a polytropic EOS:\n- $P = K \\rho_0^{\\Gamma}$\n- $\\varepsilon = \\rho_0 + \\frac{P}{\\Gamma - 1}$\n\nFor numerical integration where $P$ is an evolving variable, we invert these relations:\n- $\\rho_0(P) = \\left(\\frac{P}{K}\\right)^{1/\\Gamma}$ for $P > 0$\n- $\\varepsilon(P) = \\left(\\frac{P}{K}\\right)^{1/\\Gamma} + \\frac{P}{\\Gamma - 1}$ for $P > 0$\nIf $P \\le 0$, then $\\rho_0 = 0$ and $\\varepsilon = 0$.\n\n**4. Numerical Integration Strategy**\nWe solve the system of three coupled ODEs for the state vector $y(r) = [m(r), P(r), M_b(r)]$.\n\n**Initial Conditions:** The ODEs are singular at $r=0$. We start the integration at a small radius $r_0 > 0$. By assuming the central density is approximately constant for $r \\le r_0$, we can establish initial conditions at $r=r_0$:\n- The central pressure $P_c$ is determined by the central rest-mass density $\\rho_{0,c}$: $P_c = K \\rho_{0,c}^{\\Gamma}$. The initial pressure is $P(r_0) \\approx P_c$.\n- The central energy density is $\\varepsilon_c = \\rho_{0,c} + P_c/(\\Gamma - 1)$.\n- The initial mass is $m(r_0) = \\int_0^{r_0} 4\\pi r^2 \\varepsilon_c dr = \\frac{4\\pi}{3}\\varepsilon_c r_0^3$.\n- The initial baryonic mass is $M_b(r_0) = \\int_0^{r_0} 4\\pi r^2 \\rho_{0,c} dr = \\frac{4\\pi}{3}\\rho_{0,c} r_0^3$.\n\n**Integration and Termination:** We will use the `solve_ivp` function from the `scipy.integrate` library, which provides robust adaptive step-size ODE solvers. The integration proceeds outwards from $r=r_0$. Two termination conditions are crucial:\n1.  **Stellar Surface:** The surface of the star, $R$, is defined as the radius where the pressure drops to zero, i.e., $P(R) = 0$. This is implemented as a terminal event in the ODE solver. The values $M = m(R)$ and $M_b = M_b(R)$ at this point are the final total gravitational and baryonic masses.\n2.  **Gravitational Collapse:** For very compact models, the condition $r = 2m(r)$ may be met before the pressure vanishes. This signifies the formation of a black hole event horizon, and no static stellar surface exists. This is implemented as a second terminal event. If this event is triggered, the model is considered invalid, and the output is `nan`.\n\n**Final Calculation:**\nUpon successful integration to the stellar surface, the dimensionless gravitational binding energy fraction is computed as:\n$$\n\\frac{E_b}{M} = \\frac{M_b - M}{M}\n$$\nThis quantity represents the fraction of the total baryonic rest mass that has been converted into binding energy.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef compute_binding_energy_fraction(Gamma, K, rho0_c):\n    \"\"\"\n    Computes the gravitational binding energy fraction for a star model.\n\n    This function integrates the Tolman-Oppenheimer-Volkoff (TOV) equations for a\n    given polytropic equation of state and central density to find the total\n    gravitational mass (M) and baryonic mass (Mb) of a static, spherically\n    symmetric star. It then returns the dimensionless binding energy fraction.\n\n    Args:\n        Gamma (float): The adiabatic index of the polytropic EOS.\n        K (float): The polytropic constant.\n        rho0_c (float): The central rest-mass density.\n\n    Returns:\n        float: The binding energy fraction (Mb - M) / M, or np.nan if the\n               model is unphysical or collapses to a black hole.\n    \"\"\"\n    if rho0_c = 0:\n        return np.nan\n\n    # Calculate central pressure and energy density from the EOS\n    try:\n        P_c = K * rho0_c**Gamma\n    except (ValueError, OverflowError):\n        return np.nan\n\n    if P_c = 0 or Gamma = 1:\n        return np.nan\n        \n    epsilon_c = rho0_c + P_c / (Gamma - 1.0)\n    \n    # Set up initial conditions at a small radius r_0 to avoid singularity at r=0\n    r_0 = 1e-8\n    m_0 = (4.0 * np.pi / 3.0) * epsilon_c * r_0**3\n    P_0 = P_c  # Approximation P(r_0) ~ P_c\n    Mb_0 = (4.0 * np.pi / 3.0) * rho0_c * r_0**3\n    \n    y_0 = [m_0, P_0, Mb_0]\n\n    def tov_odes(r, y, Gamma, K):\n        \"\"\"The system of TOV ODEs.\"\"\"\n        m, P, _ = y\n\n        # Exit condition if pressure or radius become non-physical\n        if P = 0 or r = 0:\n            return [0, 0, 0]\n        \n        # EOS relations\n        try:\n            rho0 = (P / K)**(1.0 / Gamma)\n        except (ValueError, ZeroDivisionError):\n             # Handles P/K becoming negative or K being zero\n             return [0, 0, 0]\n        epsilon = rho0 + P / (Gamma - 1.0)\n\n        # Check for horizon formation to prevent division by zero in dP/dr and dMb/dr\n        schwarzschild_factor = 1.0 - 2.0 * m / r\n        if schwarzschild_factor = 0:\n            return [0, 0, 0]\n\n        # ODE for gravitational mass\n        dmdr = 4.0 * np.pi * r**2 * epsilon\n        \n        # ODE for pressure (TOV equation)\n        numer_dPdr = (epsilon + P) * (m + 4.0 * np.pi * r**3 * P)\n        denom_dPdr = r**2 * schwarzschild_factor\n        dPdr = -numer_dPdr / denom_dPdr\n\n        # ODE for baryonic mass\n        dMbdr = 4.0 * np.pi * r**2 * rho0 / np.sqrt(schwarzschild_factor)\n        \n        return [dmdr, dPdr, dMbdr]\n\n    # Event 1: Stellar surface (pressure becomes zero)\n    def surface(r, y, Gamma, K):\n        return y[1]  # Pressure P\n    surface.terminal = True\n    surface.direction = -1  # Detects zero crossing from positive to negative\n\n    # Event 2: Horizon formation (r = 2m)\n    def horizon(r, y, Gamma, K):\n        return r - 2.0 * y[0]\n    horizon.terminal = True\n\n    # Integrate the ODEs\n    r_span = [r_0, 100.0]  # Max radius of 100 should be sufficient\n    sol = solve_ivp(\n        tov_odes,\n        r_span,\n        y_0,\n        args=(Gamma, K),\n        method='RK45',\n        events=[surface, horizon],\n        rtol=1e-8,\n        atol=1e-10\n    )\n\n    # Analyze the integration result\n    if sol.status == 1:  # An event was triggered\n        if len(sol.t_events[0]) > 0:  # Surface event triggered\n            M_final, _, Mb_final = sol.y_events[0][0]\n            if M_final > 0:\n                binding_energy_fraction = (Mb_final - M_final) / M_final\n                return binding_energy_fraction\n            else:\n                return np.nan\n        elif len(sol.t_events[1]) > 0:  # Horizon event triggered\n            return np.nan\n    \n    # If no event was triggered or integration failed, return nan\n    return np.nan\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (2.0, 0.2, 0.010),\n        (2.0, 0.2, 0.020),\n        (2.5, 0.05, 0.010),\n        (2.5, 0.05, 0.020),\n        (3.0, 0.02, 0.015),\n        (2.0, 0.2, 0.005)\n    ]\n    \n    results = []\n    for case in test_cases:\n        Gamma, K, rho0_c = case\n        result = compute_binding_energy_fraction(Gamma, K, rho0_c)\n        results.append(result)\n    \n    # Format output as required, handling nan values\n    formatted_results = [f\"{r:.8f}\" if not np.isnan(r) else \"nan\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "This advanced practice applies our computational framework to a frontier topic in nuclear astrophysics: the search for quark matter inside neutron stars. You will construct hybrid equations of state that model a first-order phase transition from hadronic matter to quark matter, using both Maxwell and Gibbs constructions. The challenge  is not only to solve the TOV equations for these complex EOSs but also to analyze the resulting mass-radius curves for unique observational signatures, such as \"twin-star\" branches or regions of rapid radius change. This exercise demonstrates how macroscopic stellar models can be used to test fundamental theories of matter at the highest densities found in the universe.",
            "id": "3608267",
            "problem": "You are to implement a complete program that constructs hybrid neutron star Equations of State (EOS) combining a hadronic phase with a quark-matter phase modeled with a constant speed-of-sound, and then solves the Tolman–Oppenheimer–Volkoff equations (TOV; hydrostatic equilibrium in General Relativity). The program must compute mass–radius curves and identify two qualitative signatures: twin-star behavior and rapid-radius-change behavior. Your implementation must begin from valid physical principles and well-tested definitions. Do not use any pre-derived shortcut formulas for the target equations; derive them from fundamental principles. The program should be able to run entirely on the provided parameter sets without user input.\n\nFundamental principles and requirements:\n- Begin from local energy–momentum conservation and hydrostatic equilibrium in General Relativity, combined with spherical symmetry, and the notion that matter is described by a barotropic EOS $P(\\epsilon)$ linking pressure $P$ and energy density $\\epsilon$. Use only these foundations to derive the structure equations you implement.\n- Treat matter as cold and charge-neutral. Use isotropic, static, spherically symmetric configurations.\n- The hadronic phase is modeled as a relativistic polytrope with parameters $K$ and $\\Gamma$ as follows: introduce the mass density $\\rho$ and define $P = K \\rho^\\Gamma$ and $\\epsilon = \\rho c^2 + \\frac{P}{\\Gamma - 1}$.\n- The quark matter phase is modeled with a constant speed-of-sound EOS, namely $c_s^2(\\epsilon) = \\alpha$ (constant) and $P = \\alpha \\left(\\epsilon - B\\right)$, where $B$ is a vacuum energy density offset (often called a bag constant). Assume $0  \\alpha  1$.\n- Perform two types of phase constructions between hadronic and quark phases:\n  - Maxwell construction: a sharp interface at a specified transition pressure $P_t$; for $P  P_t$ use hadronic $\\epsilon(P)$, and for $P \\ge P_t$ use quark $\\epsilon(P) = \\frac{P}{\\alpha} + B$. This introduces a discontinuity in $\\epsilon$ at $P_t$ that models latent heat.\n  - Gibbs construction: a continuous mixed phase for $P \\in [P_t, P_t + \\Delta P]$ defined by linear interpolation of energy density, $\\epsilon_{\\mathrm{mix}}(P) = \\lambda(P) \\epsilon_H(P) + \\left(1 - \\lambda(P)\\right) \\epsilon_Q(P)$ with $\\lambda(P) = \\frac{P_t + \\Delta P - P}{\\Delta P}$, and $\\epsilon_H(P)$, $\\epsilon_Q(P)$ the hadronic and quark energy densities at the same pressure. Outside the mixed interval, use the pure hadronic ($P  P_t$) or pure quark ($P  P_t + \\Delta P$) expressions.\n- Use the speed of light $c$ and Newton’s constant $G$ explicitly; do not assume geometric units in the derivation. However, you may convert to desired output units at the end.\n\nAlgorithmic tasks:\n- For a given central pressure $P_c$, integrate the hydrostatic structure outward until the pressure reaches zero at the stellar surface radius $R$. Return the corresponding gravitational mass $M$ and radius $R$. Discard solutions where the integrator reaches an unphysical state (for example, compactness exceeding the black-hole limit).\n- Sweep a set of central pressures spanning below and above the transition, compute the mass–radius curve $\\{M(P_c), R(P_c)\\}$, and infer stability from the turning-point criterion in $\\frac{dM}{dP_c}$.\n- Identify “twin-star” behavior: existence of two distinct stable branches separated by an unstable region, with the two branches having comparable maximum masses and significantly different radii. In this problem, declare twin-star behavior to be present if there are at least two local maxima in $M(P_c)$ on stable segments, with the absolute mass difference between the two maxima less than or equal to $0.3$ in solar-mass units, and the absolute difference in radii at those maxima greater than or equal to $2$ in kilometers.\n- Identify “rapid-radius-change” behavior: compute the maximum absolute slope $\\left|\\frac{dR}{dM}\\right|$ along stable portions of the curve. Declare rapid-radius-change present if the maximum absolute slope is greater than or equal to $50$ kilometers per solar mass.\n\nUnits and conversions:\n- Central pressures $P_c$, transition pressures $P_t$, mixed-phase widths $\\Delta P$, and the bag constant $B$ are specified in $\\mathrm{MeV/fm^3}$ and must be converted to Pascals (SI) via $1\\,\\mathrm{MeV/fm^3} = 1.602176634 \\times 10^{32}\\,\\mathrm{Pa}$.\n- The final reported mass must be expressed in solar masses $M_\\odot$, where $M_\\odot = 1.988409870698051 \\times 10^{30}\\,\\mathrm{kg}$, and the final reported radius must be expressed in kilometers.\n- Any float that encodes the maximum absolute slope must be expressed in $\\mathrm{km}/M_\\odot$.\n- Angle units are not relevant in this problem.\n- When reporting floats, round to three decimal places.\n\nTest suite:\nUse the following three parameter sets. For each, run the program, sweeping central pressures $P_c$ over a logarithmic grid from $0.3 P_t$ to $6 P_t$ inclusive. The hadronic parameters are fixed to $K = 1.25 \\times 10^{-18}$ (in SI units $\\mathrm{Pa}\\,(\\mathrm{m^3/kg})^\\Gamma$) and $\\Gamma = 3.0$ for all cases.\n\n- Case $1$ (Maxwell):\n  - Construction: Maxwell\n  - $\\alpha = 0.8$\n  - $B = 90\\,\\mathrm{MeV/fm^3}$\n  - $P_t = 120\\,\\mathrm{MeV/fm^3}$\n- Case $2$ (Gibbs):\n  - Construction: Gibbs\n  - $\\alpha = 0.6$\n  - $B = 60\\,\\mathrm{MeV/fm^3}$\n  - $P_t = 120\\,\\mathrm{MeV/fm^3}$\n  - $\\Delta P = 40\\,\\mathrm{MeV/fm^3}$\n- Case $3$ (Maxwell, softer quark):\n  - Construction: Maxwell\n  - $\\alpha = 0.3$\n  - $B = 80\\,\\mathrm{MeV/fm^3}$\n  - $P_t = 100\\,\\mathrm{MeV/fm^3}$\n\nFinal output format:\n- For each case, output a list of three values: a boolean indicating whether twin-star behavior is detected, a boolean indicating whether rapid-radius-change behavior is detected, and a float equal to the maximum absolute slope $\\left|\\frac{dR}{dM}\\right|$ in $\\mathrm{km}/M_\\odot$, rounded to three decimal places.\n- Your program should produce a single line of output containing the results for the three cases as a comma-separated list enclosed in square brackets. The list elements themselves must be lists in the specified order. For example, a valid output could look like `[[True, False, 52.781], [False, False, 13.120], [False, True, 73.552]]` (this is just an example, not the required numeric answer).\n\nExpress all intermediate physical quantities internally in SI units and convert only the final reported quantities to the requested units. Ensure scientific realism by rejecting unphysical solutions automatically during integration if necessary.",
            "solution": "The problem requires the construction and analysis of mass-radius relations for hybrid neutron stars, which are composed of a hadronic matter outer region and a quark matter core. This involves solving the equations of hydrostatic equilibrium in General Relativity, known as the Tolman-Oppenheimer-Volkoff (TOV) equations, for a given equation of state (EOS). The solution is presented in three parts: first, the derivation of the TOV equations from fundamental principles; second, the specification of the hybrid EOS models; and third, the algorithmic design for numerical integration and analysis.\n\n**1. Derivation of the Tolman-Oppenheimer-Volkoff (TOV) Equations**\n\nWe begin from the Einstein Field Equations, $G_{\\mu\\nu} = \\frac{8\\pi G}{c^4} T_{\\mu\\nu}$, which relate the geometry of spacetime (Einstein tensor $G_{\\mu\\nu}$) to the distribution of energy and momentum (stress-energy tensor $T_{\\mu\\nu}$). For a static, spherically symmetric star, the spacetime metric can be written in Schwarzschild coordinates $(t, r, \\theta, \\phi)$ as:\n$$ds^2 = -e^{2\\Phi(r)}c^2 dt^2 + e^{2\\Lambda(r)} dr^2 + r^2(d\\theta^2 + \\sin^2\\theta d\\phi^2)$$\nwhere $\\Phi(r)$ and $\\Lambda(r)$ are metric functions that depend only on the radial coordinate $r$. The matter inside the star is modeled as a perfect fluid, whose stress-energy tensor is given by:\n$$T_{\\mu\\nu} = (\\epsilon + P) \\frac{u_\\mu u_\\nu}{c^2} + P g_{\\mu\\nu}$$\nwhere $\\epsilon$ is the total energy density, $P$ is the pressure, $u_\\mu$ is the fluid four-velocity, and $g_{\\mu\\nu}$ is the metric tensor. The problem assumes a barotropic EOS, where pressure is a function of energy density alone, $P = P(\\epsilon)$. For a static fluid, $u^\\mu = (e^{-\\Phi(r)}/c, 0, 0, 0)$.\n\nThe metric function $e^{2\\Lambda(r)}$ is related to the gravitational mass $m(r)$ enclosed within a radius $r$ by the definition:\n$$e^{-2\\Lambda(r)} = 1 - \\frac{2Gm(r)}{c^2 r}$$\n\nThe first TOV equation is derived from the $00$-component of the Einstein Field Equations. The calculation yields:\n$$\\frac{d}{dr}\\left(r\\left(1 - e^{-2\\Lambda(r)}\\right)\\right) = \\frac{8\\pi G}{c^2} r^2 \\frac{\\epsilon(r)}{c^2}$$\nSubstituting the expression for $e^{-2\\Lambda(r)}$ in terms of $m(r)$:\n$$\\frac{d}{dr}\\left(r\\left(\\frac{2Gm(r)}{c^2 r}\\right)\\right) = \\frac{8\\pi G}{c^2} r^2 \\frac{\\epsilon(r)}{c^2}$$\n$$\\frac{d}{dr}\\left(\\frac{2Gm(r)}{c^2}\\right) = \\frac{8\\pi G}{c^4} r^2 \\epsilon(r)$$\nThis simplifies to the equation for mass continuity:\n$$\\frac{dm}{dr} = \\frac{4\\pi r^2 \\epsilon(r)}{c^2}$$\n\nThe second TOV equation, which describes hydrostatic equilibrium, is derived from the conservation of the stress-energy tensor, $\\nabla_\\mu T^{\\mu\\nu} = 0$. The radial component ($\\nu=r$) of this equation, combined with the Einstein equations, yields the pressure gradient:\n$$\\frac{dP}{dr} = -\\frac{G(\\epsilon(r) + P(r))(m(r) + 4\\pi r^3 P(r)/c^2)}{c^2 r(r - 2Gm(r)/c^2)}$$\n\nThese two coupled, first-order ordinary differential equations form the TOV system. To solve them, one must provide an EOS $\\epsilon(P)$ and initial conditions at the center of the star ($r=0$). The initial conditions are a specified central pressure $P_c = P(r=0)$, which determines the central energy density $\\epsilon_c = \\epsilon(P_c)$, and the condition that the enclosed mass is zero, $m(0)=0$. The integration proceeds outward from $r=0$ until the pressure drops to zero, which defines the stellar surface at radius $R=r_{\\text{surf}}$. The mass of the star is then $M=m(R)$.\n\n**2. Hybrid Equation of State Models**\n\nThe problem specifies a hybrid EOS combining a hadronic phase at lower densities/pressures and a quark matter phase at higher densities/pressures.\n\nThe hadronic phase is a relativistic polytrope with parameters $K$ and $\\Gamma$:\n$$P = K \\rho^\\Gamma$$\n$$\\epsilon = \\rho c^2 + \\frac{P}{\\Gamma - 1}$$\nwhere $\\rho$ is the rest-mass density. To obtain the required form $\\epsilon(P)$, we invert the first equation to find $\\rho(P) = (P/K)^{1/\\Gamma}$ and substitute into the second:\n$$\\epsilon_H(P) = c^2 \\left(\\frac{P}{K}\\right)^{1/\\Gamma} + \\frac{P}{\\Gamma - 1}$$\n\nThe quark matter phase is described by a constant-speed-of-sound (CSS) model with parameters $\\alpha$ and $B$:\n$$P = \\alpha(\\epsilon - B)$$\nInverting for $\\epsilon(P)$ gives:\n$$\\epsilon_Q(P) = \\frac{P}{\\alpha} + B$$\n\nTwo phase-transition constructions are specified:\n\n- **Maxwell Construction**: This represents a first-order phase transition occurring at a single pressure $P_t$. There is a discontinuity (jump) in energy density at this pressure, $\\Delta\\epsilon = \\epsilon_Q(P_t) - \\epsilon_H(P_t)$, corresponding to a latent heat.\n  $$\\epsilon(P) = \\begin{cases} \\epsilon_H(P)  \\text{for } P  P_t \\\\ \\epsilon_Q(P)  \\text{for } P \\ge P_t \\end{cases}$$\n\n- **Gibbs Construction**: This models a mixed phase of hadronic and quark matter coexisting in equilibrium over a pressure range $[P_t, P_t + \\Delta P]$. The energy density in this region is a linear interpolation in pressure between the two phases:\n  $$\\epsilon(P) = \\begin{cases} \\epsilon_H(P)  \\text{for } P  P_t \\\\ \\lambda(P) \\epsilon_H(P) + (1-\\lambda(P))\\epsilon_Q(P)  \\text{for } P_t \\le P \\le P_t+\\Delta P \\\\ \\epsilon_Q(P)  \\text{for } P  P_t+\\Delta P \\end{cases}$$\n  where the mixing fraction $\\lambda(P) = \\frac{P_t + \\Delta P - P}{\\Delta P}$.\n\n**3. Algorithmic Design and Analysis**\n\nThe core of the program is to compute mass-radius curves $\\{M(P_c), R(P_c)\\}$ by solving the TOV equations for a range of central pressures $P_c$ and then analyze these curves for specific features.\n\n- **Numerical Integration**: The TOV equations are solved using a numerical ODE solver, such as a Runge-Kutta method. Since the equations are singular at $r=0$, the integration starts at a small radius $r_0 \\ll R$ with appropriate initial conditions: $P(r_0) \\approx P_c$ and $m(r_0) = \\frac{4\\pi r_0^3 \\epsilon(P_c)}{3c^2}$. The integration is stopped when an event is triggered. The primary termination event is the pressure dropping to zero, $P(r)=0$, which defines the stellar surface. An additional event must be configured to terminate integration if the configuration becomes unphysical, such as violating the black-hole limit $2Gm(r)/c^2 r > 1$.\n\n- **M-R Curve Generation**: A logarithmic grid of central pressures $P_c$ is generated, spanning the region of interest around the phase transition pressure $P_t$. For each valid $P_c$, the TOV system is solved to obtain a pair $(M, R)$. Failed integrations (e.g., those hitting the black-hole limit) are discarded. This process yields a sequence of points $(P_c, M, R)$ that constitute the mass-radius curve.\n\n- **Stability Analysis**: According to the turning-point criterion, a star is stable against radial perturbations if its mass increases with central pressure, i.e., $\\frac{dM}{dP_c} > 0$. Segments of the M-R curve corresponding to $\\frac{dM}{dP_c}  0$ represent unstable configurations.\n\n- **Twin-Star Detection**: This phenomenon is characterized by the existence of two stable star families with similar maximum masses but different radii. To detect this, we first identify the local maxima in the $M(P_c)$ curve, which correspond to the maximum-mass configurations of stable branches. Then, we check all pairs of these maxima $(M_i, R_i)$ and $(M_j, R_j)$ against the specified conditions: $|M_i - M_j| \\le 0.3 \\, M_\\odot$ and $|R_i - R_j| \\ge 2 \\, \\mathrm{km}$. If any pair satisfies both, twin-star behavior is confirmed.\n\n- **Rapid-Radius-Change Detection**: This feature is a steep segment on the M-R diagram. We compute the derivative $|\\frac{dR}{dM}|$ along the stable portions of the M-R curve. The stable sections are identified using the $\\frac{dM}{dP_c} > 0$ criterion. The derivative is computed numerically. The maximum absolute value of this derivative is then compared against the threshold of $50 \\, \\mathrm{km}/M_\\odot$.\n\nAll physical quantities are handled in SI units throughout the calculation, with conversions from the given units ($\\mathrm{MeV/fm^3}$) performed at the start and conversions to the required output units ($M_\\odot$, km) performed at the end of each TOV integration.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Define physical constants in SI units\nG = 6.67430e-11  # m^3 kg^-1 s^-2\nc = 299792458.0  # m/s\nM_sun = 1.988409870698051e30  # kg\nMeV_fm3_to_Pa = 1.602176634e32  # Conversion from MeV/fm^3 to Pa (J/m^3)\n\nclass HybridEOS:\n    \"\"\"\n    Implements the hybrid equation of state models (Maxwell and Gibbs).\n    The object is callable, returning energy density epsilon [J/m^3] for a given pressure P [Pa].\n    \"\"\"\n    def __init__(self, constr_type, K, Gamma, alpha, B_MeV_fm3, Pt_MeV_fm3, dP_MeV_fm3=0.0):\n        self.constr_type = constr_type\n        self.K = K\n        self.Gamma = Gamma\n        self.alpha = alpha\n        self.B = B_MeV_fm3 * MeV_fm3_to_Pa\n        self.Pt = Pt_MeV_fm3 * MeV_fm3_to_Pa\n        self.dP = dP_MeV_fm3 * MeV_fm3_to_Pa\n        self.Gm1 = Gamma - 1.0\n\n    def epsilon_h(self, P):\n        \"\"\"Hadronic EOS: P = K*rho^Gamma, epsilon = rho*c^2 + P/(Gamma-1)\"\"\"\n        P_eff = np.maximum(P, 0.0)\n        rho = (P_eff / self.K)**(1.0 / self.Gamma)\n        return rho * c**2 + P_eff / self.Gm1\n\n    def epsilon_q(self, P):\n        \"\"\"Quark EOS: P = alpha*(epsilon - B)\"\"\"\n        return P / self.alpha + self.B\n\n    def __call__(self, P):\n        if self.constr_type == \"Maxwell\":\n            if P  self.Pt:\n                return self.epsilon_h(P)\n            else:\n                return self.epsilon_q(P)\n        elif self.constr_type == \"Gibbs\":\n            P_end_mix = self.Pt + self.dP\n            if P  self.Pt:\n                return self.epsilon_h(P)\n            elif self.Pt = P = P_end_mix:\n                if self.dP == 0: return self.epsilon_q(P) # Avoid division by zero\n                lambda_p = (P_end_mix - P) / self.dP\n                return lambda_p * self.epsilon_h(P) + (1.0 - lambda_p) * self.epsilon_q(P)\n            else:  # P > P_end_mix\n                return self.epsilon_q(P)\n\ndef tov_odes(r, y, eos):\n    \"\"\"\n    Defines the Tolman-Oppenheimer-Volkoff (TOV) ODE system.\n    y = [m(r), P(r)]\n    \"\"\"\n    m, P = y\n    \n    if r == 0: return [0.0, 0.0]\n    if P = 0: return [0.0, 0.0]\n\n    epsilon = eos(P)\n    \n    # Pre-emptively stop if becoming a black hole to aid integrator\n    if 2.0 * G * m >= r * c**2:\n        return [0.0, 0.0]\n\n    dm_dr = 4.0 * np.pi * r**2 * epsilon / c**2\n    # Numerator of dP/dr\n    num = G * (epsilon + P) * (m + 4.0 * np.pi * r**3 * P / c**2)\n    # Denominator of dP/dr\n    den = c**2 * r * (r - 2.0 * G * m / c**2)\n    dP_dr = -num / den\n    \n    return [dm_dr, dP_dr]\n\ndef solve_tov_for_pc(Pc, eos):\n    \"\"\"\n    Integrates the TOV equations for a single central pressure Pc.\n    Returns (Mass [M_sun], Radius [km]) or (None, None) on failure.\n    \"\"\"\n    if Pc = 0: return None, None\n        \n    epsilon_c = eos(Pc)\n    \n    # Start integration at a small radius r_0 to avoid singularity at r=0\n    r_0 = 1e-4  # meters\n    m_0 = 4.0 / 3.0 * np.pi * r_0**3 * epsilon_c / c**2\n    y_0 = [m_0, Pc]\n    \n    r_span = [r_0, 3e4]  # Integrate up to 30 km\n\n    # Event to find the stellar surface (P=0)\n    def surface(_, y, __): return y[1]\n    surface.terminal = True\n    surface.direction = -1\n\n    # Event to stop if a black hole forms\n    def bh_limit(r, y, _): return r * c**2 - 2.0 * G * y[0]\n    bh_limit.terminal = True\n\n    sol = solve_ivp(\n        fun=tov_odes, t_span=r_span, y0=y_0, args=(eos,),\n        method='RK45', events=(surface, bh_limit), dense_output=True\n    )\n\n    if sol.status == 1 and sol.t_events[0].size > 0:\n        R_surface = sol.t_events[0][0]  # in meters\n        m_surface = sol.y_events[0][0][0]  # in kg\n        \n        return m_surface / M_sun, R_surface / 1000.0\n    else:\n        return None, None\n\ndef analyze_mr_curve(Pc_list, M_list, R_list):\n    \"\"\"\n    Analyzes the M-R curve to detect twin-star and rapid-radius-change behaviors.\n    \"\"\"\n    if len(Pc_list)  3: return False, False, 0.0\n\n    dM_dPc = np.gradient(M_list, Pc_list)\n    \n    # --- Twin-star detection ---\n    peak_indices = [i for i in range(1, len(dM_dPc)) if dM_dPc[i-1] > 0 and dM_dPc[i] = 0]\n    peaks_MR = [(M_list[i], R_list[i]) for i in peak_indices]\n    \n    is_twin = False\n    if len(peaks_MR) >= 2:\n        for i in range(len(peaks_MR)):\n            for j in range(i + 1, len(peaks_MR)):\n                mass_diff = abs(peaks_MR[i][0] - peaks_MR[j][0])\n                rad_diff = abs(peaks_MR[i][1] - peaks_MR[j][1])\n                if mass_diff = 0.3 and rad_diff >= 2.0:\n                    is_twin = True\n                    break\n            if is_twin: break\n\n    # --- Rapid-radius-change detection ---\n    stable_indices = np.where(dM_dPc >= 0)[0]\n    stable_segments = np.split(stable_indices, np.where(np.diff(stable_indices) != 1)[0] + 1)\n    \n    max_abs_slope = 0.0\n    for segment in stable_segments:\n        if len(segment) > 2:\n            M_seg = np.array([M_list[i] for i in segment])\n            R_seg = np.array([R_list[i] for i in segment])\n            \n            # Sort by M to handle potential non-monotonicity due to numerics\n            sort_indices = np.argsort(M_seg)\n            M_sorted, R_sorted = M_seg[sort_indices], R_seg[sort_indices]\n\n            # Remove duplicates in M before computing gradient\n            unique_M, unique_indices = np.unique(M_sorted, return_index=True)\n            if len(unique_M) > 2:\n                unique_R = R_sorted[unique_indices]\n                dR_dM = np.gradient(unique_R, unique_M)\n                max_abs_slope = max(max_abs_slope, np.max(np.abs(dR_dM)))\n                \n    is_rapid_change = max_abs_slope >= 50.0\n\n    return is_twin, is_rapid_change, max_abs_slope\n\ndef process_case(case_params):\n    \"\"\"\n    Runs the full simulation and analysis for a single parameter case.\n    \"\"\"\n    eos = HybridEOS(\n        constr_type=case_params[\"construction\"], K=case_params[\"K\"], Gamma=case_params[\"Gamma\"],\n        alpha=case_params[\"alpha\"], B_MeV_fm3=case_params[\"B\"], Pt_MeV_fm3=case_params[\"Pt\"],\n        dP_MeV_fm3=case_params.get(\"dP\", 0.0)\n    )\n    \n    Pt_si = case_params[\"Pt\"] * MeV_fm3_to_Pa\n    Pc_min, Pc_max = 0.3 * Pt_si, 6.0 * Pt_si\n    Pc_grid = np.logspace(np.log10(Pc_min), np.log10(Pc_max), 300)\n    \n    results = [solve_tov_for_pc(Pc, eos) for Pc in Pc_grid]\n    \n    valid_results = [(Pc_grid[i], m, r) for i, (m, r) in enumerate(results) if m is not None]\n    \n    if not valid_results: return [False, False, 0.0]\n        \n    Pc_list, M_list, R_list = zip(*valid_results)\n    \n    is_twin, is_rapid, max_slope = analyze_mr_curve(list(Pc_list), list(M_list), list(R_list))\n    \n    return [is_twin, is_rapid, round(max_slope, 3)]\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        # Case 1 (Maxwell)\n        {\"construction\": \"Maxwell\", \"K\": 1.25e-18, \"Gamma\": 3.0, \"alpha\": 0.8, \"B\": 90, \"Pt\": 120},\n        # Case 2 (Gibbs)\n        {\"construction\": \"Gibbs\", \"K\": 1.25e-18, \"Gamma\": 3.0, \"alpha\": 0.6, \"B\": 60, \"Pt\": 120, \"dP\": 40},\n        # Case 3 (Maxwell, softer quark)\n        {\"construction\": \"Maxwell\", \"K\": 1.25e-18, \"Gamma\": 3.0, \"alpha\": 0.3, \"B\": 80, \"Pt\": 100}\n    ]\n\n    final_results = [process_case(case) for case in test_cases]\n    \n    formatted_results = [f'[{str(t)},{str(r)},{s:.3f}]' for t, r, s in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}