{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握伽莫夫峰，第一步是从第一性原理出发，亲手推导出其能量位置。这个练习将引导你探究经典统计力学中的麦克斯韦-玻尔兹曼分布与量子力学中的隧道效应如何相互竞争，从而共同形成这一独特的能量窗口。完成这个推导  将为你后续的所有计算工作打下坚实的理论基石。",
            "id": "3725090",
            "problem": "考虑在温度为 $T$ 的热核等离子体中，有两个电荷分别为 $Z_1 e$ 和 $Z_2 e$、约化质量为 $\\mu$ 的全电离原子核。在非共振条件下，每对原子核的聚变反应率可以写成一个能量积分，其主要的能量依赖性源于两个基本因素：\n\n- Maxwell-Boltzmann 能量权重，对于能量 $E$，其贡献一个与 $\\exp\\!\\big(-E/(k_{B}T)\\big)$ 成正比的因子，其中 $k_{B}$ 是 Boltzmann 常数。\n- 穿过库仑势垒的量子力学隧穿概率，在半经典的 Wentzel-Kramers-Brillouin (WKB) 近似下，其贡献一个因子 $\\exp\\!\\big(-\\sqrt{\\varepsilon_{G}/E}\\big)$，其中 $\\varepsilon_{G}$ 是一个由库仑势垒参数和 $\\mu$ 决定的正常数（Gamow 能量）。\n\n假设 $E$ 的所有代数前置因子以及任何缓和的能量依赖性（例如来自截面结构函数的依赖性）在峰值附近变化缓慢，并且为了定位最大值可以被视为常数，那么需要对 $E$ 进行最大化的被积函数与上述两个指数因子的乘积成正比。该乘积达到其最大值时的能量称为 Gamow 峰能量 $\\varepsilon_{0}$。\n\n从这些基本输入（Maxwell-Boltzmann 统计和 WKB 隧穿因子）出发，推导最大值的条件，并得到 Gamow 峰能量 $\\varepsilon_{0}$ 关于 $T$ 和 $\\varepsilon_{G}$ 的闭合形式表达式。请将您的最终答案表示为包含 $k_{B}$、$T$ 和 $\\varepsilon_{G}$ 的符号表达式。最终表达式中不要包含单位。",
            "solution": "问题陈述清晰，具有科学依据，并包含足够的信息以获得唯一解。它描述了核天体物理学中的一个经典问题：确定热核聚变反应的最概然能量，即所谓的 Gamow 峰。该物理模型基于两种相互竞争的效应：等离子体中粒子能量的 Maxwell-Boltzmann 分布和穿过库仑势垒的量子力学隧穿概率。问题给出了这两个因素的正确函数形式，并要求在其他能量依赖项变化缓慢这一简化但标准的假设下，找到使其乘积最大化的能量。因此，该问题是有效的。\n\n我们的任务是找到能量 $\\varepsilon_{0}$，该能量使一个与 Maxwell-Boltzmann 因子和 WKB 隧穿因子之乘积成正比的函数最大化。设该函数为 $f(E)$。根据问题描述，我们有：\n$$\nf(E) \\propto \\exp\\left(-\\frac{E}{k_{B}T}\\right) \\exp\\left(-\\sqrt{\\frac{\\varepsilon_{G}}{E}}\\right)\n$$\n其中 $E$ 是质心能量，$k_{B}$ 是 Boltzmann 常数，$T$ 是温度，$\\varepsilon_{G}$ 是 Gamow 能量，一个常数。我们可以将此关系写为：\n$$\nf(E) = C \\exp\\left(-\\frac{E}{k_{B}T} - \\sqrt{\\frac{\\varepsilon_{G}}{E}}\\right)\n$$\n其中 $C$ 是一个比例常数，包含了所有能量的缓变因子，根据问题陈述，在本分析中这些因子被视为常数。\n\n为了找到 $f(E)$ 的最大值，从数学上讲，更方便的是找到其自然对数 $\\ln(f(E))$ 的最大值，因为对数是一个单调递增函数。最大化 $\\ln(f(E))$ 等价于最大化 $f(E)$ 本身。我们定义一个新函数 $g(E) = \\ln(f(E))$：\n$$\ng(E) = \\ln(C) - \\frac{E}{k_{B}T} - \\sqrt{\\frac{\\varepsilon_{G}}{E}}\n$$\n我们可以重写最后一项以便于求导：\n$$\ng(E) = \\ln(C) - \\frac{E}{k_{B}T} - \\sqrt{\\varepsilon_{G}} E^{-1/2}\n$$\n为了找到使 $g(E)$ 最大化的能量 $\\varepsilon_{0}$，我们必须求 $g(E)$ 对 $E$ 的导数，并将其设为零。\n$$\n\\frac{dg}{dE} = \\frac{d}{dE}\\left(\\ln(C) - \\frac{E}{k_{B}T} - \\sqrt{\\varepsilon_{G}} E^{-1/2}\\right)\n$$\n常数项 $\\ln(C)$ 的导数为零。其余项的导数为：\n$$\n\\frac{dg}{dE} = -\\frac{1}{k_{B}T} - \\sqrt{\\varepsilon_{G}} \\left(-\\frac{1}{2} E^{-3/2}\\right) = -\\frac{1}{k_{B}T} + \\frac{\\sqrt{\\varepsilon_{G}}}{2} E^{-3/2}\n$$\n在峰值能量 $E=\\varepsilon_{0}$ 处将导数设为零：\n$$\n\\frac{dg}{dE}\\bigg|_{E=\\varepsilon_{0}} = -\\frac{1}{k_{B}T} + \\frac{\\sqrt{\\varepsilon_{G}}}{2} \\varepsilon_{0}^{-3/2} = 0\n$$\n现在，我们求解这个方程以得到 $\\varepsilon_{0}$：\n$$\n\\frac{\\sqrt{\\varepsilon_{G}}}{2 \\varepsilon_{0}^{3/2}} = \\frac{1}{k_{B}T}\n$$\n整理各项以分离出 $\\varepsilon_{0}^{3/2}$：\n$$\n\\varepsilon_{0}^{3/2} = \\frac{\\sqrt{\\varepsilon_{G}} k_{B} T}{2}\n$$\n为了解出 $\\varepsilon_{0}$，我们将方程两边同时取 $2/3$ 次方：\n$$\n\\varepsilon_{0} = \\left(\\frac{\\sqrt{\\varepsilon_{G}} k_{B} T}{2}\\right)^{2/3}\n$$\n我们来简化这个表达式：\n$$\n\\varepsilon_{0} = \\frac{(\\varepsilon_{G}^{1/2})^{2/3} (k_{B}T)^{2/3}}{2^{2/3}} = \\frac{\\varepsilon_{G}^{1/3} (k_{B}T)^{2/3}}{2^{2/3}}\n$$\n这个表达式可以通过将所有项置于一个共同的根号下，写成更紧凑的形式：\n$$\n\\varepsilon_{0} = \\left(\\frac{\\varepsilon_{G} (k_{B}T)^{2}}{4}\\right)^{1/3}\n$$\n为了确认该能量对应于一个最大值，我们考察 $g(E)$ 的二阶导数：\n$$\n\\frac{d^{2}g}{dE^{2}} = \\frac{d}{dE}\\left(-\\frac{1}{k_{B}T} + \\frac{\\sqrt{\\varepsilon_{G}}}{2} E^{-3/2}\\right) = \\frac{\\sqrt{\\varepsilon_{G}}}{2} \\left(-\\frac{3}{2} E^{-5/2}\\right) = -\\frac{3\\sqrt{\\varepsilon_{G}}}{4 E^{5/2}}\n$$\n由于能量 $E$ 必须为正，且给定的 Gamow 能量 $\\varepsilon_{G}$ 是一个正常数，因此对于所有 $E>0$，二阶导数 $\\frac{d^{2}g}{dE^{2}}$ 始终为负。这证实了我们在 $E=\\varepsilon_{0}$ 处找到的极值确实是一个最大值。\n\n因此，Gamow 峰能量 $\\varepsilon_{0}$ 由所推导的关于温度 $T$、Boltzmann 常数 $k_{B}$ 和 Gamow 能量 $\\varepsilon_{G}$ 的表达式给出。",
            "answer": "$$\n\\boxed{\\left(\\frac{\\varepsilon_{G} (k_{B} T)^2}{4}\\right)^{1/3}}\n$$"
        },
        {
            "introduction": "在理想化的分析推导之后，我们必须转向更贴近现实的数值计算。在实际研究中，天体物理S因子 $S(E)$ 并非恒定，甚至可能存在共振结构，这使得伽莫夫峰的位置发生偏移。本练习  要求你开发一个稳健的数值算法来精确地定位这些复杂情况下的峰值能量，这是计算核物理学家的核心技能之一。",
            "id": "3600134",
            "problem": "考虑热核反应率对数被积函数 $\\phi(E)$ 最大化时的 Gamow 峰能量 $E_0$ 的数值定位。在计算核物理的背景下，从第一性原理出发推导您的方法。以下定义和要求精确地规定了该问题。\n\n从热分布和库仑势垒隧穿的基本原理开始。使用 Maxwell–Boltzmann 能量分布（玻尔兹曼常数为 $k_{\\mathrm{B}}$）和由 Gamow 因子表示的隧穿概率。将待最大化的函数定义为\n$$\n\\phi(E) = \\ln S(E) - \\frac{E}{k_{\\mathrm{B}} T} - \\sqrt{\\frac{E_{\\mathrm{G}}}{E}},\n$$\n其中 $E$ 是能量，$T$ 是温度，$S(E)$ 是天体物理 $S$ 因子，$E_{\\mathrm{G}}$ 是 Gamow 能量。Gamow 能量根据库仑物理学和运动学定义为\n$$\nE_{\\mathrm{G}} = 2 \\pi^2 (Z_1 Z_2 \\alpha)^2 \\mu c^2,\n$$\n其中 $Z_1$ 和 $Z_2$ 是反应物的整数核电荷数，$\\alpha$ 是精细结构常数，$\\mu$ 是折合质量，$c$ 是光速。折合质量为\n$$\n\\mu = \\frac{m_1 m_2}{m_1 + m_2},\n$$\n其中 $m_1$ 和 $m_2$ 是粒子质量。所有能量必须以 $\\mathrm{keV}$ 表示，所有质量以 $\\mathrm{keV}/c^2$ 表示，温度以 $\\mathrm{K}$ 表示。\n\n通过一个缓慢变化的基线乘以一个局域共振来模拟能量依赖的 $S$ 因子：\n$$\nS(E) = S_0 \\left(1 + a E\\right)\\left(1 + A\\,L(E)\\right),\n$$\n其中 $S_0$ 是一个无量纲标度，$a$ 是一个量纲为 $\\mathrm{keV}^{-1}$ 的小斜率参数，$A$ 是一个无量纲的共振振幅，$L(E)$ 是一个类洛伦兹共振线型\n$$\nL(E) = \\frac{(\\Gamma/2)^2}{(E - E_r)^2 + (\\Gamma/2)^2},\n$$\n其中共振能量 $E_r$ 和半峰全宽 $\\Gamma$ 的单位均为 $\\mathrm{keV}$。\n\n您的任务是实现一个稳健的 Newton–Raphson 算法来定位 $\\phi(E)$ 的最大值点 $E_0$，并遵循以下算法约束以确保在共振附近的稳健性：\n- 仅基于第一性原理实现一个初始猜测值（在初始估计中忽略 $S(E)$，并使用热与隧穿的平衡）。\n- 使用 Newton–Raphson 步，结合曲率信息 $\\phi''(E)$ 来求解 $\\phi'(E) = 0$。\n- 包含一个回溯线搜索，以保证每次迭代时 $\\phi(E)$ 单调增加，并遵守定义域约束 $E > 0$。\n- 包含曲率检查，以确保收敛点是局部最大值，即强制 $\\phi''(E_0) < 0$，并通过将 $\\phi(E_0)$ 与邻近点比较来验证其局部主导性。\n- 通过在 Newton–Raphson 失败时回退到对 $\\phi'(E)$ 进行有界根搜索，并通过拒绝 $\\phi''(E) \\ge 0$ 的伪驻点，来防止在共振附近发生错误定位。\n- 确保对于非常小的 $E$ 值的数值稳定性（例如，通过为 $E$ 设置一个远离 $0$ 的下界，并保护所有除法运算）。\n\n要使用的常数是光速 $c$、玻尔兹曼常数 $k_{\\mathrm{B}}$ 和精细结构常数 $\\alpha$。初始猜测值必须是一个有物理动机的值，仅基于 $T$ 和 $E_{\\mathrm{G}}$，从热抑制和库仑隧穿的平衡中导出。\n\n实现一个完整的、可运行的程序，为以下测试套件计算 $E_0$。对于每个案例，以浮点数形式输出最终的 $E_0$（单位为 $\\mathrm{keV}$）。\n\n测试套件参数集（每个案例是一个元组 $(Z_1, Z_2, m_1, m_2, T, S_0, a, A, E_r, \\Gamma)$）：\n- 案例 1（基线，无共振）：$(1, 1, 938272.0813, 938272.0813, 1.5\\times 10^7, 1.0, 0.0, 0.0, 0.0, 1.0)$。\n- 案例 2（经典峰附近的中等共振）：$(1, 6, 938272.0813, 11177412.0, 2.0\\times 10^8, 1.0, 1.0\\times 10^{-4}, 1.0, 450.0, 30.0)$。\n- 案例 3（强烈的离峰共振）：$(1, 6, 938272.0813, 11177412.0, 2.0\\times 10^8, 1.0, 2.0\\times 10^{-4}, 5.0, 800.0, 20.0)$。\n- 案例 4（低温下邻近的窄共振）：$(1, 1, 938272.0813, 938272.0813, 1.0\\times 10^6, 1.0, 0.0, 2.0, 5.0, 1.0)$。\n\n在所有案例中，常数必须为 $c = 2.99792458\\times 10^8\\,\\mathrm{m/s}$、$k_{\\mathrm{B}} = 8.617333262145\\times 10^{-8}\\,\\mathrm{keV/K}$ 和 $\\alpha = 7.2973525693\\times 10^{-3}$。\n\n您的程序必须生成单行输出，其中包含四个结果，以逗号分隔并用方括号括起来，例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$，其中每个 $\\text{result}_i$ 是计算出的 $E_0$（单位为 $\\mathrm{keV}$）的浮点数。不允许有其他额外输出。",
            "solution": "该问题已经过验证并被确定为有效。这是一个计算核天体物理学中的适定问题，基于已建立的物理原理。问题陈述是自洽的，为唯一的数值解提供了所有必要的定义、常数和参数。语言是客观的，要求是可形式化的。\n\n任务是找到使函数 $\\phi(E)$ 最大化的能量 $E_0$，该函数是热核反应率被积函数中关键项的对数。最大值点 $E_0$ 被称为 Gamow 峰能量。\n$$\n\\phi(E) = \\ln S(E) - \\frac{E}{k_{\\mathrm{B}} T} - \\sqrt{\\frac{E_{\\mathrm{G}}}{E}}\n$$\n$\\phi(E)$ 的最大值出现在能量 $E_0 > 0$ 处，该点的一阶导数为零，即 $\\phi'(E_0) = 0$，且二阶导数为负，即 $\\phi''(E_0) < 0$。\n\n解决方案的核心是 Newton-Raphson 方法的稳健实现，用于找到 $\\phi'(E)=0$ 的根。该方法需要 $\\phi(E)$ 的解析导数。\n\n$\\phi(E)$ 对 $E$ 的一阶导数是：\n$$\n\\phi'(E) = \\frac{d}{dE} \\left( \\ln S(E) - \\frac{E}{k_{\\mathrm{B}} T} - \\sqrt{E_{\\mathrm{G}}} E^{-1/2} \\right) = \\frac{S'(E)}{S(E)} - \\frac{1}{k_{\\mathrm{B}} T} + \\frac{1}{2}\\sqrt{E_{\\mathrm{G}}}E^{-3/2}\n$$\n二阶导数 $\\phi''(E)$ 是：\n$$\n\\phi''(E) = \\frac{d}{dE} \\left( \\frac{S'(E)}{S(E)} \\right) - \\frac{d}{dE} \\left( \\frac{1}{k_{\\mathrm{B}} T} \\right) + \\frac{d}{dE} \\left( \\frac{1}{2}\\sqrt{E_{\\mathrm{G}}}E^{-3/2} \\right) = \\frac{S''(E)S(E) - (S'(E))^2}{S(E)^2} - \\frac{3}{4} \\sqrt{E_{\\mathrm{G}}} E^{-5/2}\n$$\n为了计算这些导数，我们需要天体物理 $S$ 因子 $S(E)$ 的导数，其模型为：\n$$\nS(E) = S_0 \\left(1 + a E\\right)\\left(1 + A\\,L(E)\\right)\n$$\n为了计算方便，展开此式是有帮助的：\n$$\nS(E) = S_0 (1 + aE + A L(E) + aA E L(E))\n$$\n一阶和二阶导数 $S'(E)$ 和 $S''(E)$ 是：\n$$\nS'(E) = S_0 \\left[ a + a A L(E) + A(1 + aE)L'(E) \\right]\n$$\n$$\nS''(E) = S_0 \\left[ 2a A L'(E) + A(1+aE)L''(E) \\right]\n$$\n这些导数依赖于类洛伦兹函数 $L(E)$ 及其导数。令 $W = \\Gamma/2$。那么：\n$$\nL(E) = \\frac{W^2}{(E - E_r)^2 + W^2}\n$$\n$$\nL'(E) = \\frac{-2W^2(E - E_r)}{((E - E_r)^2 + W^2)^2}\n$$\n$$\nL''(E) = \\frac{2W^2 \\left( 3(E - E_r)^2 - W^2 \\right)}{((E - E_r)^2 + W^2)^3}\n$$\n\n数值算法根据问题中的规定为稳健性而设计。\n1.  **初始猜测值**：迭代的主要初始猜测值是通过在忽略 S 因子贡献（即假设 $S(E)$ 为常数）的情况下求 $\\phi(E)$ 的最大值来导出的。这平衡了 Maxwell-Boltzmann 分布的指数衰减和库仑势垒隧穿概率的指数上升。令 $\\frac{d}{dE}(-\\frac{E}{k_{\\mathrm{B}}T} - \\sqrt{\\frac{E_G}{E}}) = 0$ 可得到经典的 Gamow 峰能量：\n    $$\n    E_{\\text{guess}} = \\left( \\frac{(k_{\\mathrm{B}}T)^2 E_{\\mathrm{G}}}{4} \\right)^{1/3}\n    $$\n2.  **Newton-Raphson 方法**：求解器的核心是迭代方案：\n    $$\n    E_{k+1} = E_k - \\frac{\\phi'(E_k)}{\\phi''(E_k)}\n    $$\n3.  **稳健性增强**：\n    -   **曲率检查**：在每一步，我们验证 $\\phi''(E_k) < 0$。如果曲率非负，该点不是局部最大值，Newton-Raphson 步将无效。在这种情况下，算法必须进行调整。\n    -   **回溯线搜索**：为保证收敛和目标函数的单调增加，实现了一个回溯线搜索。完整的 Newton-Raphson 步长 $\\Delta E = -\\phi'/\\phi''$ 乘以一个因子 $\\lambda \\in (0, 1]$。我们从 $\\lambda=1$ 开始，并连续将其减半，直到满足条件 $E_{k+1} = E_k + \\lambda \\Delta E > 0$ 和 $\\phi(E_{k+1}) > \\phi(E_k)$。这可以防止过冲，并确保解保持在物理定义域 $E>0$ 内。\n    -   **处理共振**：共振的存在可以在共振能量 $E_r$ 附近产生 $\\phi(E)$ 的第二个局部最大值。仅从 $E_{\\text{guess}}$ 开始的搜索可能会收敛到非共振峰，即使共振峰是全局主导的。为了找到全局最大值，我们执行两次独立的搜索：一次从 $E_{\\text{guess}}$ 开始，另一次从共振能量 $E_r$ 开始（如果存在共振，即 $A>0$）。然后我们比较在找到的任何有效最大值点处的 $\\phi(E)$ 值，并选择对应最高值的能量。\n    -   **回退机制**：如果 Newton-Raphson 方法失败，问题要求回退到对 $\\phi'(E)$ 进行有界根搜索。尽管上述稳健实现被设计为不会失败，但如果未找到最大值（例如，由于线搜索失败或持续的不良曲率），可以采用像 `scipy.optimize.brentq` 这样的求根算法，在宽能量区间内找到 $\\phi'(E)$ 的根。然后必须通过曲率测试 $\\phi''(E_0) < 0$ 来验证所得的根是否为最大值点。然而，该策略次于主要的双重搜索 Newton-Raphson 方法。提供的解决方案优先考虑 N-R 方法，因为它收敛更快且能有效利用曲率信息。\n    -   **数值稳定性**：所有计算均以浮点算术执行。编写代码以防止除以零，并通过确保 $E$ 有一个远离零的下界来处理 $E^{-3/2}$ 和 $E^{-5/2}$ 项。使用了一个小的最小能量 `E_MIN`。\n\n该实现将这些原则封装到一个类结构中，该结构首先计算给定反应所需的物理常数（例如，折合质量 $\\mu$ 和 Gamow 能量 $E_G$），然后应用双重搜索最大化算法来定位主导的 Gamow 峰能量 $E_0$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\n# Per the problem specification, no other libraries are used.\n\ndef solve():\n    \"\"\"\n    Main solver function to compute Gamow peak energies for the given test cases.\n    \"\"\"\n    \n    # Constants as specified in the problem\n    C_LIGHT = 2.99792458e8  # m/s (not used as masses are in keV/c^2)\n    K_B = 8.617333262145e-8  # keV/K\n    ALPHA = 7.2973525693e-3  # Fine-structure constant\n    \n    # Small number to prevent division by zero and keep energy positive\n    E_MIN = 1e-9\n\n    class GamowPeakFinder:\n        \"\"\"\n        A class to find the Gamow peak energy E0 for a given set of nuclear\n        reaction parameters.\n        \"\"\"\n        def __init__(self, Z1, Z2, m1, m2, T, S0, a, A, Er, Gamma):\n            self.Z1 = Z1\n            self.Z2 = Z2\n            self.m1 = m1  # in keV/c^2\n            self.m2 = m2  # in keV/c^2\n            self.T = T    # in K\n            self.S0 = S0\n            self.a = a\n            self.A = A\n            self.Er = Er\n            self.Gamma = Gamma\n            \n            # Derived constants\n            self.W = self.Gamma / 2.0\n            \n            # Calculate reduced mass energy (mu * c^2) in keV\n            # m1 and m2 are given in keV/c^2, so they are effectively M1 and M2\n            if (self.m1 + self.m2) == 0:\n                self.mu_c2 = 0\n            else:\n                self.mu_c2 = (self.m1 * self.m2) / (self.m1 + self.m2)\n            \n            # Calculate Gamow Energy in keV\n            self.Eg = 2.0 * (np.pi**2) * ((self.Z1 * self.Z2 * ALPHA)**2) * self.mu_c2\n            \n            self.kBT = K_B * self.T\n\n        # --- Lorentzian and its derivatives ---\n        def _L(self, E):\n            if self.W == 0: return 0.0\n            denom = (E - self.Er)**2 + self.W**2\n            return self.W**2 / denom if denom > 0 else 0.0\n\n        def _L_prime(self, E):\n            if self.W == 0: return 0.0\n            denom = (E - self.Er)**2 + self.W**2\n            return -2.0 * self.W**2 * (E - self.Er) / (denom**2) if denom > 0 else 0.0\n\n        def _L_double_prime(self, E):\n            if self.W == 0: return 0.0\n            denom = (E - self.Er)**2 + self.W**2\n            num = 2.0 * self.W**2 * (3.0 * (E - self.Er)**2 - self.W**2)\n            return num / (denom**3) if denom > 0 else 0.0\n\n        # --- S-factor and its derivatives ---\n        def _S(self, E):\n            return self.S0 * (1.0 + self.a * E) * (1.0 + self.A * self._L(E))\n\n        def _S_prime(self, E):\n            L_val = self._L(E)\n            L_p_val = self._L_prime(E)\n            term1 = self.a\n            term2 = self.a * self.A * L_val\n            term3 = self.A * (1.0 + self.a * E) * L_p_val\n            return self.S0 * (term1 + term2 + term3)\n\n        def _S_double_prime(self, E):\n            L_p_val = self._L_prime(E)\n            L_pp_val = self._L_double_prime(E)\n            term1 = 2.0 * self.a * self.A * L_p_val\n            term2 = self.A * (1.0 + self.a * E) * L_pp_val\n            return self.S0 * (term1 + term2)\n        \n        # --- Objective function phi and its derivatives ---\n        def phi(self, E):\n            E = max(E, E_MIN)\n            S_val = self._S(E)\n            if S_val = 0 or self.Eg  0: return -np.inf\n            log_S = np.log(S_val)\n            boltzmann = E / self.kBT\n            gamow = np.sqrt(self.Eg / E)\n            return log_S - boltzmann - gamow\n\n        def phi_prime(self, E):\n            E = max(E, E_MIN)\n            S_val = self._S(E)\n            Sp_val = self._S_prime(E)\n            if S_val == 0 or self.kBT == 0 or self.Eg  0: return 0.0\n            d_log_S = Sp_val / S_val\n            d_boltzmann = 1.0 / self.kBT\n            d_gamow = -0.5 * np.sqrt(self.Eg) * E**(-1.5)\n            return d_log_S - d_boltzmann - d_gamow\n\n        def phi_double_prime(self, E):\n            E = max(E, E_MIN)\n            S_val = self._S(E)\n            Sp_val = self._S_prime(E)\n            Spp_val = self._S_double_prime(E)\n            \n            if S_val == 0 or self.Eg  0: return -np.inf\n            d2_log_S = (Spp_val * S_val - Sp_val**2) / S_val**2\n            d2_gamow = 0.75 * np.sqrt(self.Eg) * E**(-2.5)\n            return d2_log_S - d2_gamow\n\n        def _get_initial_guess(self):\n            if self.kBT == 0 or self.Eg == 0: return 1.0\n            return (self.Eg * (self.kBT)**2 / 4.0)**(1.0/3.0)\n\n        def _newton_raphson(self, E_guess, max_iter=100, tol=1e-8):\n            E = E_guess\n            for _ in range(max_iter):\n                phi_p = self.phi_prime(E)\n                phi_pp = self.phi_double_prime(E)\n\n                if phi_pp >= 0:\n                    return None # Invalid curvature for a maximum\n\n                delta_E = -phi_p / phi_pp\n\n                # Backtracking line search\n                lambda_k = 1.0\n                phi_E = self.phi(E)\n                for _ in range(10): # Max 10 backtracking steps\n                    E_new = E + lambda_k * delta_E\n                    if E_new > E_MIN and self.phi(E_new) > phi_E:\n                        break\n                    lambda_k /= 2.0\n                else:\n                    return None # Line search failed\n\n                E = E_new\n                \n                if abs(lambda_k * delta_E)  tol:\n                    # Final curvature check\n                    if self.phi_double_prime(E) >= 0:\n                        return None\n                    return E\n            return None # Did not converge\n\n        def find_peak(self):\n            candidates = []\n            \n            # --- Search from classical Gamow peak guess ---\n            E_c_guess = self._get_initial_guess()\n            if E_c_guess > E_MIN:\n                peak1 = self._newton_raphson(E_c_guess)\n                if peak1 is not None:\n                    candidates.append(peak1)\n\n            # --- Search from resonance energy, if present ---\n            if self.A > 0 and self.Er > E_MIN:\n                peak2 = self._newton_raphson(self.Er)\n                if peak2 is not None:\n                    candidates.append(peak2)\n            \n            if not candidates:\n                # Fallback to bracketed search for phi_prime root if N-R fails\n                # This could happen in complex cases.\n                # Find a bracket [a,b] where phi'(a) and phi'(b) have opposite signs\n                # phi'(E->0) -> +inf, phi'(E->inf) -> -1/kBT\n                try:\n                    # Define a search range for the bracket\n                    low_E = E_c_guess * 0.1\n                    high_E = E_c_guess * 10\n                    if self.A > 0 and self.Er > 0:\n                        high_E = max(high_E, self.Er * 2)\n\n                    # Brent's method to find a root of phi_prime\n                    fallback_peak = brentq(self.phi_prime, low_E, high_E, xtol=1e-9, maxiter=100)\n                    # Check if it's a maximum\n                    if self.phi_double_prime(fallback_peak)  0:\n                        candidates.append(fallback_peak)\n\n                except ValueError:\n                    # Brentq fails if no bracket is found or other issues\n                    return float('nan') # Could not find a peak\n            \n            if not candidates:\n                return float('nan') # No peak found\n\n            # Determine the best peak (global maximum among candidates)\n            best_E = -1\n            max_phi = -np.inf\n            for E_cand in set(candidates): # Use set to remove duplicate peaks\n                phi_val = self.phi(E_cand)\n                if phi_val > max_phi:\n                    max_phi = phi_val\n                    best_E = E_cand\n\n            return best_E\n\n    test_cases = [\n        # (Z1, Z2, m1, m2, T, S0, a, A, Er, Gamma)\n        (1, 1, 938272.0813, 938272.0813, 1.5e7, 1.0, 0.0, 0.0, 0.0, 1.0),\n        (1, 6, 938272.0813, 11177412.0, 2.0e8, 1.0, 1.0e-4, 1.0, 450.0, 30.0),\n        (1, 6, 938272.0813, 11177412.0, 2.0e8, 1.0, 2.0e-4, 5.0, 800.0, 20.0),\n        (1, 1, 938272.0813, 938272.0813, 1.0e6, 1.0, 0.0, 2.0, 5.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        finder = GamowPeakFinder(*case)\n        result = finder.find_peak()\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "找到了峰值位置只是完成了一半的工作，最终目标是计算总的反应率，这需要对伽莫夫峰进行积分。本练习  聚焦于一个关键的数值计算挑战：浮点数下溢问题。你将学习并实现“对数-和-指数”(log-sum-exp)技巧，以确保即使在极端的物理条件下，你的积分计算结果依然精确和稳定。",
            "id": "3600092",
            "problem": "考虑与伽莫夫峰相关的热核反应率被积函数，它由无量纲函数 $I(E,T) = \\exp\\!\\big(-g(E,T)\\big)$ 定义，其中能量为 $E$，温度为 $T$。函数 $g(E,T)$ 是两个经过充分检验的贡献之和：来自经典统计力学的麦克斯韦-玻尔兹曼因子，以及通过半经典 Wentzel–Kramers–Brillouin (WKB) 近似得到的量子隧穿伽莫夫因子。具体而言，设 $g(E,T) = \\dfrac{E}{k_{\\mathrm{B}} T} + \\sqrt{\\dfrac{E_{\\mathrm{G}}}{E}}$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$E_{\\mathrm{G}}$ 是伽莫夫能量。伽莫夫能量由 $E_{\\mathrm{G}} = 2 \\,\\mu c^{2} \\,(\\pi \\alpha Z_{1} Z_{2})^{2}$ 给出，其中 $\\mu$ 是两个反应核的约化质量，$c$ 是光速，$\\alpha$ 是精细结构常数，$Z_{1}$ 和 $Z_{2}$ 是原子核的整数电荷。使用 $\\alpha \\approx 1/137.035999$，并以原子质量单位表示 $\\mu$，以便通过质能等价关系使用 $1 \\,\\mathrm{amu} \\approx 931.49410242 \\,\\mathrm{MeV}$ 计算 $\\mu c^{2}$。\n\n定义无量纲的天体物理 $S$-因子 $S(E)$ 为常数，$S(E) = 1$，因此依赖于温度的积分\n$$\n\\mathcal{I}(T) = \\int_{0}^{\\infty} S(E)\\,\\exp\\!\\left(-\\frac{E}{k_{\\mathrm{B}} T} - \\sqrt{\\frac{E_{\\mathrm{G}}}{E}}\\right)\\, \\mathrm{d}E\n= \\int_{0}^{\\infty} \\exp\\!\\left(-\\frac{E}{k_{\\mathrm{B}} T} - \\sqrt{\\frac{E_{\\mathrm{G}}}{E}}\\right)\\, \\mathrm{d}E\n$$\n具有能量的单位。积分 $\\mathcal{I}(T)$ 主要由伽莫夫峰区域决定，在处理小 $T$ 或大 $Z_{1}Z_{2}$ 时，必须通过数值方法进行计算，并注意浮点下溢和上溢问题。\n\n您的任务是：\n1. 从上述基本定义出发，推导一个数值稳定的变换，以允许使用浮点算术在固定网格 $\\{E_{i}\\}$ 上通过数值积分来计算 $\\mathcal{I}(T)$。该变换应在计算指数级小项之和时避免下溢和上溢。证明如果用黎曼和 $\\mathcal{I}(T) \\approx \\sum_{i} w_{i}\\,\\exp\\!\\big(-g(E_{i},T)\\big)$ 来近似积分，其中积分权重 $w_{i}  0$，那么可以使用 log-sum-exp 变换来稳定地计算 $\\log \\mathcal{I}(T)$，进而计算 $\\mathcal{I}(T)$ 本身。\n2. 设计一个简单的算法来选择能够解析伽莫夫峰的能量网格，而无需事先知道峰值的确切位置。您的设计必须有理有据：基于对 $g(E,T)$ 及其导数的分析，并确保网格集中在峰值区域周围，同时覆盖其重要的尾部。未经第一性原理证明，不得使用临时的或手动调整的常数。\n3. 将该算法实现为一个完整的、可运行的程序，该程序使用朴素求积法（直接求和）和 log-sum-exp 稳定化求和两种方法计算 $\\mathcal{I}(T)$，并报告其值以及朴素计算是否在浮点算术中因下溢而变为零。\n\n物理单位和常数：\n- 使用 $E$ 单位为 $\\mathrm{keV}$，$T$ 单位为 $\\mathrm{K}$，$k_{\\mathrm{B}}$ 单位为 $\\mathrm{keV}/\\mathrm{K}$ 且 $k_{\\mathrm{B}} \\approx 8.617333262\\times 10^{-8} \\,\\mathrm{keV}/\\mathrm{K}$，$E_{\\mathrm{G}}$ 单位为 $\\mathrm{keV}$。\n- 最终积分值 $\\mathcal{I}(T)$ 以 $\\mathrm{keV}$ 为单位表示。\n\n测试套件：\n对以下参数集 $(Z_{1}, Z_{2}, \\mu, T)$ 评估程序，其中 $\\mu$ 以原子质量单位给出，$T$ 以开尔文给出：\n- 案例 A（理想情况，轻核，恒星核心）：$(1, 1, 0.5, 1.5\\times 10^{7})$。\n- 案例 B（重核，中等温度）：$(6, 6, 6.0, 5.0\\times 10^{8})$。\n- 案例 C（边缘情况，高势垒，低温度）：$(8, 8, 8.0, 5.0\\times 10^{6})$。\n- 案例 D（高温，轻核）：$(2, 2, 1.0, 1.0\\times 10^{9})$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。对于每个测试案例，输出一个包含三个条目的列表：稳定的积分值（浮点数，单位 $\\mathrm{keV}$）、朴素的积分值（浮点数，单位 $\\mathrm{keV}$）以及一个布尔值，指示朴素计算是否因下溢而变为零。因此，最终输出必须是一个列表的列表，例如 $[[x_{A},y_{A},b_{A}], [x_{B},y_{B},b_{B}], [x_{C},y_{C},b_{C}], [x_{D},y_{D},b_{D}]]$，其中所有的 $x$ 和 $y$ 都以 $\\mathrm{keV}$ 为单位。",
            "solution": "该问题要求对热核反应率积分进行数值计算，并特别关注数值稳定性和一种有理有据的求积网格生成方法。该问题在科学上基础扎实、内容自洽且定义明确。所呈现的物理模型，涉及由麦克斯韦-玻尔兹曼分布和量子隧穿概率的乘积产生的伽莫夫峰，是核天体物理学中一个标准且基本的概念。所有必要的参数和常数均已提供。因此，该问题是有效的，下面提供了解决方案。\n\n解决方案分为三部分，对应问题陈述中列出的任务。\n\n### 1. 数值稳定变换的推导\n\n需要计算的积分由下式给出：\n$$\n\\mathcal{I}(T) = \\int_{0}^{\\infty} \\exp\\big(-g(E,T)\\big)\\, \\mathrm{d}E\n$$\n其中指数为 $g(E,T) = \\frac{E}{k_{\\mathrm{B}} T} + \\sqrt{\\frac{E_{\\mathrm{G}}}{E}}$。对于某些物理参数（$Z_{1}, Z_{2}, T$），函数 $g(E,T)$ 可能达到很大的正值，导致被积函数 $\\exp(-g(E,T))$ 变得小于可表示的最小正浮点数（下溢）。\n\n数值求积法将积分近似为在离散能量网格 $\\{E_i\\}_{i=0}^N$ 上的加权和：\n$$\n\\mathcal{I}(T) \\approx \\sum_{i=0}^{N} w_i \\exp\\big(-g(E_i,T)\\big)\n$$\n其中 $w_i  0$ 是积分权重。例如，在间距为 $\\Delta E$ 的均匀网格上使用梯形法则，权重为 $w_0 = w_N = \\Delta E/2$ 和 $w_i = \\Delta E$（对于 $0  i  N$）。\n\n对这个和的朴素计算涉及计算每一项 $w_i \\exp(-g(E_i,T))$ 并将它们相加。如果所有的 $\\exp(-g(E_i,T))$ 项都下溢为 $0$，那么和将被错误地计算为 $0$。这在低温 $T$ 或高核电荷 $Z_1, Z_2$ 的情况下尤其可能发生，此时 $g(E,T)$ 的最小值很大。\n\n为避免此问题，我们采用一种基于 log-sum-exp 恒等式的稳定化技术。目标是首先以避免中间过程下溢的方式计算 $\\log \\mathcal{I}(T)$。设 $g_{\\min}$ 为 $g(E,T)$ 在网格相关能量范围内的最小值：\n$$\ng_{\\min} = \\min_{i} \\{g(E_i, T)\\}\n$$\n我们可以从和中提出因子 $\\exp(-g_{\\min})$：\n$$\n\\mathcal{I}(T) \\approx \\sum_{i=0}^{N} w_i \\exp(-g_{\\min}) \\exp\\big(-(g(E_i,T) - g_{\\min})\\big)\n$$\n$$\n\\mathcal{I}(T) \\approx \\exp(-g_{\\min}) \\left[ \\sum_{i=0}^{N} w_i \\exp\\big(-(g(E_i,T) - g_{\\min})\\big) \\right]\n$$\n对两边取自然对数，得到：\n$$\n\\log \\mathcal{I}(T) \\approx -g_{\\min} + \\log\\left( \\sum_{i=0}^{N} w_i \\exp\\big(-(g(E_i,T) - g_{\\min})\\big) \\right)\n$$\n这个形式是数值稳定的。指数的参数 $-(g(E_i,T) - g_{\\min})$ 总是小于或等于 $0$。对于使 $g(E_i,T)$ 最小的项，其指数为 $0$，得到 $\\exp(0)=1$。所有其他项都将更小。因此，对数内的和是量级合理的数（约为 $w_i$ 的量级）之和，这防止了上溢，并最小化了因单个项下溢而导致的精度损失。这个和本身将是一个正数，可以安全地传递给对数函数。\n\n最后，通过对结果取指数来恢复积分值：\n$$\n\\mathcal{I}(T) = \\exp\\big(\\log \\mathcal{I}(T)\\big)\n$$\n如果 $\\log \\mathcal{I}(T)$ 是一个非常大的负数，最后的指数运算仍可能导致结果为 $0$，但这现在正确地反映了积分的真实值小于机器精度，而不是求和过程中过早下溢造成的人为结果。\n\n### 2. 能量网格的有理有据设计\n\n被积函数主要由伽莫夫峰主导，该峰出现在使指数 $g(E,T)$ 最小化的能量 $E_0$ 处。一个有理有据的网格必须以 $E_0$ 为中心，并且足够宽以覆盖峰的重要部分。我们通过将 $g(E,T)$ 对 $E$ 的导数设为零来找到 $E_0$：\n$$\n\\frac{\\mathrm{d}g}{\\mathrm{d}E} = \\frac{\\mathrm{d}}{\\mathrm{d}E} \\left( \\frac{E}{k_{\\mathrm{B}} T} + E_{\\mathrm{G}}^{1/2} E^{-1/2} \\right) = \\frac{1}{k_{\\mathrm{B}} T} - \\frac{1}{2} E_{\\mathrm{G}}^{1/2} E^{-3/2} = 0\n$$\n解出峰值能量 $E_0$：\n$$\nE_0^{3/2} = \\frac{k_{\\mathrm{B}} T \\sqrt{E_{\\mathrm{G}}}}{2} \\implies E_0 = \\left( \\frac{(k_{\\mathrm{B}} T)^2 E_{\\mathrm{G}}}{4} \\right)^{1/3}\n$$\n峰的宽度可以通过 $g(E,T)$ 在 $E_0$ 附近的二阶泰勒展开来估计，这将峰近似为一个高斯函数：\n$$\ng(E,T) \\approx g(E_0,T) + \\frac{1}{2} g''(E_0,T) (E-E_0)^2\n$$\n被积函数则近似为 $\\exp(-g(E_0,T)) \\exp\\left(-\\frac{(E-E_0)^2}{2\\sigma_E^2}\\right)$，其中标准差 $\\sigma_E$ 由 $\\sigma_E = \\left(g''(E_0,T)\\right)^{-1/2}$ 给出。\n\n二阶导数为：\n$$\ng''(E,T) = \\frac{\\mathrm{d}}{\\mathrm{d}E} \\left( \\frac{1}{k_{\\mathrm{B}} T} - \\frac{1}{2} E_{\\mathrm{G}}^{1/2} E^{-3/2} \\right) = \\frac{3}{4} E_{\\mathrm{G}}^{1/2} E^{-5/2}\n$$\n在 $E=E_0$ 处求值并代入 $\\sqrt{E_{\\mathrm{G}}} = 2 E_0^{3/2} / (k_{\\mathrm{B}} T)$：\n$$\ng''(E_0,T) = \\frac{3}{4} \\left(\\frac{2 E_0^{3/2}}{k_{\\mathrm{B}} T}\\right) E_0^{-5/2} = \\frac{3}{2 E_0 k_{\\mathrm{B}} T}\n$$\n这给出了峰的特征宽度：\n$$\n\\sigma_E = \\sqrt{\\frac{2 E_0 k_{\\mathrm{B}} T}{3}}\n$$\n因此，一个有理有据的网格算法如下：\n1.  根据给定的物理参数 $Z_1, Z_2, \\mu, T$ 计算 $E_0$ 和 $\\sigma_E$。这确保了网格能适应问题，而不依赖于临时设定的范围。\n2.  定义积分区间为 $[E_{\\min}, E_{\\max}]$，以 $E_0$ 为中心，并向两侧延伸几个宽度（$\\sigma_E$）。一个范围为 $[E_0 - N_{\\sigma} \\sigma_E, E_0 + N_{\\sigma} \\sigma_E]$ 是合适的。选择 $N_{\\sigma}=20$ 可确保包含峰的尾部，在这些区域被积函数变得可以忽略不计。下界必须裁剪到一个小的正值以避免在 $E=0$ 处的奇点。\n3.  将此区间离散化为大量的点，$N_{\\text{points}}$，以确保梯形法则的准确性。$N_{\\text{points}}=20000$ 为所遇到的尖锐峰提供了足够的分辨率。这是一个数值精度参数，而不是任意的物理常数。\n\n### 3. 算法实现\n\n该算法使用 `numpy` 库在 Python 中实现。\n1.  **常数**：用指定的数值和单位定义物理常数。\n2.  **伽莫夫能量计算**：对于每个测试案例 $(Z_1, Z_2, \\mu, T)$，以 $\\mathrm{keV}$ 为单位计算伽莫夫能量 $E_{\\mathrm{G}}$。\n3.  **网格生成**：遵循第 2 部分的有理有据设计来构建能量网格。计算 $E_0$ 和 $\\sigma_E$，并在范围 $[\\max(0.1, E_0 - 20\\sigma_E), E_0 + 20\\sigma_E]$ 内创建一个包含 $20000$ 个点的均匀网格 `E_grid`。能量单位为 $\\mathrm{keV}$。\n4.  **指数计算**：在 `E_grid` 上的每个点计算指数 $g(E,T)$。\n5.  **朴素积分**：直接计算被积函数 $\\exp(-g(E,T))$，并使用 `numpy.trapz` 通过梯形法则进行积分。如果此结果下溢为 $0.0$，则设置一个布尔标志。\n6.  **稳定积分**：实现第 1 部分中的稳定 log-sum-exp 方法。\n    -   找到指数数组的最小值 $g_{\\min}$。\n    -   计算稳定的被加数 $\\exp(-(g(E,T) - g_{\\min}))$。\n    -   使用 `numpy.trapz` 对这个数值稳定的数组进行积分。\n    -   取该中间积分的对数，并加上 $-g_{\\min}$ 以获得最终的 $\\log\\mathcal{I}(T)$。\n    -   通过 `numpy.exp()` 恢复结果 $\\mathcal{I}(T)$。\n7.  **输出**：对于每个测试案例，生成一个包含稳定积分值、朴素积分值和下溢标志的列表，并按要求格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the thermonuclear reaction-rate integral for a series of test cases\n    using both a naive and a numerically stabilized method.\n    \"\"\"\n    # Physical and mathematical constants\n    FINE_STRUCTURE_CONST = 1.0 / 137.035999\n    AMU_TO_MEV = 931.49410242\n    MEV_TO_KEV = 1000.0\n    AMU_C2_KEV = AMU_TO_MEV * MEV_TO_KEV  # Mass-energy equivalence for 1 amu in keV\n    KB_KEV_K = 8.617333262e-8  # Boltzmann constant in keV/K\n\n    # Define the test cases as per the problem statement.\n    # Format: (Z1, Z2, mu_amu, T_K)\n    test_cases = [\n        (1, 1, 0.5, 1.5e7),\n        (6, 6, 6.0, 5.0e8),\n        (8, 8, 8.0, 5.0e6),\n        (2, 2, 1.0, 1.0e9),\n    ]\n\n    results = []\n\n    def compute_integral(Z1, Z2, mu_amu, T_K):\n        \"\"\"\n        Calculates the integral I(T) for a given set of physical parameters.\n\n        Args:\n            Z1 (int): Charge number of the first nucleus.\n            Z2 (int): Charge number of the second nucleus.\n            mu_amu (float): Reduced mass in atomic mass units (amu).\n            T_K (float): Temperature in Kelvin (K).\n\n        Returns:\n            tuple: A tuple containing:\n                - integral_stable (float): The integral value from the stabilized method.\n                - integral_naive (float): The integral value from the naive method.\n                - underflowed (bool): True if the naive method resulted in a zero value.\n        \"\"\"\n        # --- 1. Calculate parameters from givens ---\n        mu_c2_kev = mu_amu * AMU_C2_KEV\n        # Gamow Energy in keV\n        E_G_kev = 2.0 * mu_c2_kev * (np.pi * FINE_STRUCTURE_CONST * Z1 * Z2)**2\n        # Thermal energy in keV\n        k_B_T_kev = KB_KEV_K * T_K\n\n        # --- 2. Principled grid generation ---\n        # Peak energy (E0) in keV\n        E0 = ((k_B_T_kev**2 * E_G_kev) / 4.0)**(1.0 / 3.0)\n        \n        # Characteristic peak width (sigma_E) in keV\n        # g''(E0) = 3 / (2 * E0 * k_B_T)\n        # sigma_E = 1 / sqrt(g''(E0))\n        sigma_E = np.sqrt((2.0 * E0 * k_B_T_kev) / 3.0)\n\n        # Set up grid based on E0 and sigma_E\n        # N_sigma controls the width of integration range in multiples of sigma_E.\n        # This value is chosen to be large to ensure the full peak is captured.\n        N_sigma = 20.0\n        # N_points determines the resolution of the grid for numerical accuracy.\n        N_points = 20000\n\n        E_min = max(0.1, E0 - N_sigma * sigma_E)  # Clip to small positive energy\n        E_max = E0 + N_sigma * sigma_E\n        \n        E_grid = np.linspace(E_min, E_max, N_points)\n        \n        # --- 3. Evaluate the exponent on the grid ---\n        # The exponent g(E,T) = E/(k_B*T) + sqrt(E_G/E)\n        with np.errstate(divide='ignore'): # E=0 is avoided by E_min\n            g_vals = (E_grid / k_B_T_kev) + np.sqrt(E_G_kev / E_grid)\n\n        # --- 4. Naive quadrature ---\n        # This can underflow if g_vals are large.\n        integrand_naive = np.exp(-g_vals)\n        integral_naive = np.trapz(integrand_naive, E_grid)\n        \n        # Check if the naive sum underflowed to exactly zero\n        underflowed = (integral_naive == 0.0)\n\n        # --- 5. Stabilized (log-sum-exp) quadrature ---\n        g_min = np.min(g_vals)\n        \n        # This integrand is well-behaved: values are between exp(-C) and 1.\n        integrand_stable = np.exp(-(g_vals - g_min))\n        \n        # The integral of the stabilized integrand\n        sum_part = np.trapz(integrand_stable, E_grid)\n        \n        # Log of the integral, calculated stably\n        # Handle case where sum_part is zero (extreme underflow)\n        if sum_part > 0:\n            log_integral = -g_min + np.log(sum_part)\n            integral_stable = np.exp(log_integral)\n        else: # Should not happen unless even the stabilized form underflows\n            integral_stable = 0.0\n\n        return integral_stable, naive_val, underflowed\n\n    for case in test_cases:\n        Z1, Z2, mu, T = case\n        stable_val, naive_val, underflow_flag = compute_integral(Z1, Z2, mu, T)\n        results.append([stable_val, naive_val, underflow_flag])\n\n    # Final print statement in the exact required format.\n    # Manually construct the list-of-lists string representation.\n    # Using str() for bools gives 'True'/'False' which is valid Python syntax.\n    result_strings = []\n    for res in results:\n        # repr() is used for floats to maintain precision in the output string\n        result_strings.append(f\"[{repr(res[0])}, {repr(res[1])}, {str(res[2])}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}