{
    "hands_on_practices": [
        {
            "introduction": "第一个练习通过解决核“面食”相的核心物理机制——表面张力与库仑排斥之间的竞争，为理解这一概念奠定基础。你将实现一个简化但功能强大的维格纳-赛兹（Wigner-Seitz）胞模型，以确定在不同密度下能量上有利的几何形状——球形、柱形或板层状。这项实践将锻炼你使用有限差分法进行数值优化和求解边值问题的能力，这些都是计算物理学中的基本工具。",
            "id": "3579770",
            "problem": "要求您编写一个完整的、可运行的程序，通过比较三种候选几何构型——球状（$d=3$；“液滴”）、柱状（$d=2$；“管状”）和板状（$d=1$；“板状”）——的最小化自由能密度，来确定随着重子数密度的增加，最优的核“意面”几何构型。该比较必须在每个指定的重子数密度下进行，通过对每种几何构型的自由能密度中的表面能和库仑能贡献之和进行最小化来实现，并使用给定的表面张力、质子分数和线性电子屏蔽模型。\n\n需要实现的物理和数值模型如下。\n\n1. 几何构型与 Wigner–Seitz 原胞构建。对于每个几何维度 $d \\in \\{1,2,3\\}$，假设存在一个由相同团簇构成的周期性排列，每个团簇可用一个半径为 $R_{\\mathrm{c}}$ 的 Wigner–Seitz 原胞和一个内部团簇尺寸 $r_{\\mathrm{N}}$ 来描述。重子数密度为 $n$（单位为 $\\mathrm{fm}^{-3}$）。团簇内部的致密核相具有固定的重子数密度 $n_{\\mathrm{in}} = 0.16\\,\\mathrm{fm}^{-3}$。致密相所占的体积分数为\n$$\nu = \\frac{n}{n_{\\mathrm{in}}}, \\quad \\text{为保证数值稳定性，限制在 } 10^{-2} \\le u \\le 0.99 \\text{ 范围内}。\n$$\n团簇尺寸和原胞半径之间的 Wigner–Seitz 关系为\n$$\nu = \\left(\\frac{r_{\\mathrm{N}}}{R_{\\mathrm{c}}}\\right)^{d} \\quad \\Rightarrow \\quad R_{\\mathrm{c}} = \\frac{r_{\\mathrm{N}}}{u^{1/d}}。\n$$\n球状使用 $d=3$，柱状使用 $d=2$，板状使用 $d=1$。\n\n2. 质子分数和电子密度。质子分数由 $n$ 的函数给出：\n$$\nY_{p}(n) = 0.05 + 0.1 \\exp\\!\\left(-\\frac{n}{0.06\\,\\mathrm{fm}^{-3}}\\right)。\n$$\n致密相内部的质子数密度为 $n_{p,\\mathrm{in}}(n)=Y_{p}(n)\\,n_{\\mathrm{in}}$。电子保证全局电中性，并通过一个依赖于平均电子密度 $n_{e} = u\\,n_{p,\\mathrm{in}}$ 的屏蔽长度进行线性响应处理。\n\n3. 表面能密度。表面张力规定为\n$$\n\\sigma(n) = \\max\\!\\left(0.3, \\, 1.0 - 0.4\\,\\frac{n}{0.16\\,\\mathrm{fm}^{-3}}\\right)\\ \\mathrm{MeV/fm^{2}},\n$$\n对于给定的几何构型，其表面能密度为\n$$\n\\varepsilon_{S}(d,n,r_{\\mathrm{N}}) = \\frac{d\\,\\sigma(n)\\,u}{r_{\\mathrm{N}}}\\ \\mathrm{MeV/fm^{3}}。\n$$\n\n4. 电子屏蔽长度。使用一个依赖于平均电子密度 $n_{e}$ 的经验屏蔽长度来模拟超相对论性电子屏蔽：\n$$\n\\lambda_{e}(n) = 20\\,\\mathrm{fm}\\ \\left(\\frac{0.05\\,\\mathrm{fm}^{-3}}{n_{e}}\\right)^{1/3}。\n$$\n\n5. 通过有屏蔽的泊松问题计算库仑能密度。通过为每种几何构型求解一个散度形式的一维径向有屏蔽的泊松方程来处理库仑能：\n$$\n\\frac{1}{r^{d-1}} \\frac{d}{dr} \\!\\left(r^{d-1} \\frac{d\\phi}{dr}\\right) - \\frac{\\phi}{\\lambda_{e}^{2}} = - \\rho_{p}(r),\n$$\n边界条件为诺伊曼边界条件 $d\\phi/dr\\vert_{r=0} = 0$ 和 $d\\phi/dr\\vert_{r=R_{\\mathrm{c}}} = 0$。质子电荷密度在团簇内部被认为是均匀的，在外部为零，\n$$\n\\rho_{p}(r) = \\begin{cases}\nn_{p,\\mathrm{in}}(n),  0 \\le r  r_{\\mathrm{N}},\\\\\n0,  r_{\\mathrm{N}} \\le r \\le R_{\\mathrm{c}}。\n\\end{cases}\n$$\n您必须使用一种在 $r=0$ 处对 $d \\in \\{1,2,3\\}$ 保持数值稳定的、散度形式的守恒有限差分格式，在 $r \\in [0, R_{\\mathrm{c}}]$ 上对该方程进行离散化。库仑能密度计算如下\n$$\n\\varepsilon_{C}(d,n,r_{\\mathrm{N}}) = \\frac{1}{2 V_{\\mathrm{cell}}} \\int_{0}^{R_{\\mathrm{c}}} \\rho_{p}(r)\\,\\phi(r)\\, S_{d}\\, r^{d-1}\\, dr,\n$$\n其中 $S_{1}=2$，$S_{2}=2\\pi$，$S_{3}=4\\pi$，原胞体积为 $V_{\\mathrm{cell}} = S_{d} R_{\\mathrm{c}}^{d}/d$。总的电磁常数已被吸收到单位中，因此只需要在相同 $n$ 值下对不同几何构型进行相对比较；程序必须确保在不同几何构型之间内部标度的一致性。\n\n6. 总自由能密度与最小化。对于每种几何构型和每个密度 $n$，在一个物理上合理的域 $r_{\\mathrm{N}} \\in [0.5\\,\\mathrm{fm},\\,30\\,\\mathrm{fm}]$ 内，使用稳健的一维搜索方法，对\n$$\n\\varepsilon_{\\mathrm{tot}}(d,n,r_{\\mathrm{N}}) = \\varepsilon_{S}(d,n,r_{\\mathrm{N}}) + \\varepsilon_{C}(d,n,r_{\\mathrm{N}})\n$$\n关于 $r_{\\mathrm{N}}$ 进行最小化。最小化过程必须对每种几何构型独立进行。\n\n7. 相选择。对于每个密度 $n$，选择能产生最小的最小化 $\\varepsilon_{\\mathrm{tot}}(d,n)$ 的几何构型 $d$。\n\n8. 输出编码。将每个密度下所选的几何构型编码为一个整数：\n- $3$ 代表球状 ($d=3$)，\n- $2$ 代表柱状 ($d=2$)，\n- $1$ 代表板状 ($d=1$)。\n\n最终输出应为单行，其中包含整个测试集的结果，形式为用方括号括起来的逗号分隔列表。\n\n测试集。使用以下重子数密度（单位 $\\mathrm{fm}^{-3}$）作为输入：\n- 正常路径，液滴相和管状相竞争的中低密度：$n \\in \\{0.01,\\,0.03,\\,0.06\\}$。\n- 管状相和板状相竞争的过渡区域：$n \\in \\{0.09,\\,0.12\\}$。\n- 接近 $n_{\\mathrm{in}}$ 的高亚饱和密度，用于探测板状相的主导地位：$n = 0.15$。\n\n您的程序应生成单行输出，其中包含这些密度下整数编码的最优几何构型，顺序与输入相同，格式为用方括号括起来的逗号分隔列表（例如，“[3,3,2,1,1,1]”）。不允许有任何其他输出。由于输出是整数编码，最终答案行不需要物理单位。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它提出了一个植根于核天体物理学领域的、有科学依据的、良定的、客观的计算任务。该模型虽然经过简化，但基于研究“核意面”相的既定原理，即 Wigner-Seitz 原胞框架内表面能和库仑能之间的竞争。所有必需的方程、常数和数值参数均已提供，构成了一个自洽且一致的问题定义。我现在开始进行求解。\n\n核心任务是确定作为平均重子数密度 $n$ 的函数，热力学上最优的核几何构型——球状（$d=3$）、柱状（$d=2$）或板状（$d=1$）。最优几何构型是使总自由能密度 $\\varepsilon_{\\mathrm{tot}}$ 最小化的那一种，该能量是表面能贡献 $\\varepsilon_S$ 和库仑能贡献 $\\varepsilon_C$ 的总和。\n\n对于给定的几何维度 $d$ 和重子密度 $n$，总能量密度是致密核团簇尺寸 $r_{\\mathrm{N}}$ 的函数：\n$$\n\\varepsilon_{\\mathrm{tot}}(d, n, r_{\\mathrm{N}}) = \\varepsilon_{S}(d, n, r_{\\mathrm{N}}) + \\varepsilon_{C}(d, n, r_{\\mathrm{N}})\n$$\n我们的方法论对每个指定的密度 $n$ 包含两个主要步骤：\n1. 对每种几何构型 $d \\in \\{1, 2, 3\\}$，我们在指定的域 $r_{\\mathrm{N}} \\in [0.5\\,\\mathrm{fm},\\,30\\,\\mathrm{fm}]$ 上，对总能量密度 $\\varepsilon_{\\mathrm{tot}}(d, n, r_{\\mathrm{N}})$ 关于团簇尺寸 $r_{\\mathrm{N}}$ 进行最小化。这会为每种几何构型得到一个最小化的能量，$\\varepsilon_{\\mathrm{min}}(d, n) = \\min_{r_{\\mathrm{N}}} \\varepsilon_{\\mathrm{tot}}(d, n, r_{\\mathrm{N}})$。\n2. 我们比较这些最小化的能量，并选择能量最低的几何构型 $d^*$：对所有 $d \\in \\{1, 2, 3\\}$，均有 $\\varepsilon_{\\mathrm{min}}(d^*, n) \\le \\varepsilon_{\\mathrm{min}}(d, n)$。\n\n表面能密度 $\\varepsilon_S$ 由下式给出：\n$$\n\\varepsilon_{S}(d,n,r_{\\mathrm{N}}) = \\frac{d\\,\\sigma(n)\\,u}{r_{\\mathrm{N}}}\n$$\n其中 $\\sigma(n)$ 是给定的表面张力，$u = n/n_{\\mathrm{in}}$ 是致密相的体积分数。这一项倾向于形成更大的结构（增加 $r_{\\mathrm{N}}$）以最小化表面积与体积之比。\n\n库仑能密度 $\\varepsilon_C$ 源于团簇内质子的排斥作用，该作用被周围的电子气所屏蔽。它是通过求解静电势 $\\phi(r)$ 的一维径向有屏蔽的泊松方程来计算的：\n$$\n\\frac{1}{r^{d-1}} \\frac{d}{dr} \\!\\left(r^{d-1} \\frac{d\\phi}{dr}\\right) - \\frac{\\phi}{\\lambda_{e}^{2}} = - \\rho_{p}(r)\n$$\n方程满足零梯度（诺伊曼）边界条件 $\\phi'(0)=0$ 和 $\\phi'(R_c)=0$，其中 $R_c = r_{\\mathrm{N}}/u^{1/d}$ 是 Wigner-Seitz 原胞半径。这里，$\\lambda_e$ 是电子屏蔽长度，$\\rho_p(r)$ 是质子数密度，它在团簇内部（$r  r_{\\mathrm{N}}$）为常数，在外部为零。\n\n该方程可重写为：\n$$\n\\frac{d^2\\phi}{dr^2} + \\frac{d-1}{r}\\frac{d\\phi}{dr} - k^2\\phi = -\\rho_p(r)\n$$\n其中 $k = 1/\\lambda_e$。这是一个线性二阶边值问题。我们使用有限差分法，在从 $r=0$ 到 $r=R_c$ 的一个包含 $N_{\\text{grid}}=500$ 个点的均匀径向网格上对其进行数值求解。\n- 对于内部网格点，导数使用标准的二阶中心差分。\n- 在原点 $r=0$ 处，当 $d>1$ 时，项 $\\frac{d-1}{r}\\phi'$ 是奇异的。应用 L'Hôpital 法则和边界条件 $\\phi'(0)=0$，方程变为 $d\\cdot\\phi''(0) - k^2\\phi(0) = -\\rho_p(0)$。这一点通过使用从虚拟点法导出的 $\\phi''(0)$ 的前向差分进行离散化。\n- 在外边界 $r=R_c$ 处，条件 $\\phi'(R_c)=0$ 通过同样从虚拟点法导出的后向差分来实现。\n\n这种离散化将微分方程转换为一个三对角线性代数方程组，我们使用 `scipy.linalg.solve_banded` 在每个网格点上高效地求解电势 $\\phi$。\n\n一旦电势 $\\phi(r)$ 已知，库仑能密度通过使用梯形法则（`numpy.trapz`）对电荷分布进行数值积分来计算：\n$$\n\\varepsilon_{C}(d,n,r_{\\mathrm{N}}) = \\frac{d}{2 R_c^d} \\int_{0}^{r_{\\mathrm{N}}} n_{p,\\mathrm{in}} \\phi(r) r^{d-1} dr\n$$\n然后，使用稳健的 `scipy.optimize.minimize_scalar` 函数及其 'bounded' 方法，对总能量 $\\varepsilon_{\\mathrm{tot}}(r_{\\mathrm{N}})$ 关于 $r_{\\mathrm{N}}$ 进行最小化。\n\n对测试集中的每个密度重复整个过程，并将每个密度得到的最优几何构型编码为整数（1、2 或 3），以指定的输出格式呈现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\nfrom scipy.linalg import solve_banded\n\n# Define constants as per the problem statement.\nN_IN_DENSITY = 0.16  # fm^-3\nN_GRID_POINTS = 500  # Number of grid points for the finite-difference solver.\n\ndef _get_physical_params(n):\n    \"\"\"\n    Calculates density-dependent physical parameters.\n\n    Args:\n        n (float): Baryon number density in fm^-3.\n\n    Returns:\n        tuple: A tuple containing u, n_p_in, sigma_n, lambda_e.\n    \"\"\"\n    u = n / N_IN_DENSITY\n    u = np.clip(u, 1e-2, 0.99)\n    \n    yp_n = 0.05 + 0.1 * np.exp(-n / 0.06)\n    n_p_in = yp_n * N_IN_DENSITY\n    n_e = u * n_p_in\n    \n    sigma_n = max(0.3, 1.0 - 0.4 * n / N_IN_DENSITY)\n    \n    # Avoid division by zero if n_e is extremely small or zero.\n    if n_e = 1e-12:\n        lambda_e = np.inf\n    else:\n        lambda_e = 20.0 * (0.05 / n_e)**(1.0/3.0)\n        \n    return u, n_p_in, sigma_n, lambda_e\n\ndef _calculate_coulomb_energy(d, u, n_p_in, lambda_e, r_N):\n    \"\"\"\n    Solves the screened Poisson equation and computes the Coulomb energy density.\n    \n    Args:\n        d (int): Geometry dimension (1, 2, or 3).\n        u (float): Volume fraction.\n        n_p_in (float): Proton density inside the cluster.\n        lambda_e (float): Electron screening length.\n        r_N (float): Cluster radius.\n\n    Returns:\n        float: The calculated Coulomb energy density in MeV/fm^3 (with absorbed constants).\n    \"\"\"\n    if r_N == 0: return 0.0\n    R_c = r_N / (u**(1.0/d))\n    if R_c = r_N: return np.inf # Unphysical situation where u >= 1\n\n    # 1. Set up the grid and physical parameters for the solver.\n    r = np.linspace(0, R_c, N_GRID_POINTS)\n    dr = r[1] - r[0]\n    \n    k_sq = 1.0 / lambda_e**2 if np.isfinite(lambda_e) else 0.0\n    \n    # 2. Define the source term (proton charge density).\n    N_r_idx = np.searchsorted(r, r_N, side='left')\n    rho_p = np.zeros(N_GRID_POINTS)\n    rho_p[:N_r_idx] = n_p_in\n\n    # 3. Build and solve the tridiagonal system for the potential phi.\n    # The system is M*phi = b, where b = -rho_p.\n    # The matrix M is stored in banded format `ab`.\n    dr_sq = dr**2\n    main_diag = np.zeros(N_GRID_POINTS)\n    upper_diag = np.zeros(N_GRID_POINTS - 1)\n    lower_diag = np.zeros(N_GRID_POINTS - 1)\n\n    # Discretization for interior points: 1 = i = N_GRID_POINTS - 2\n    for i in range(1, N_GRID_POINTS - 1):\n        main_diag[i] = -2.0/dr_sq - k_sq\n        upper_diag[i] = 1.0/dr_sq + (d-1.0)/(2.0 * r[i] * dr)\n        lower_diag[i-1] = 1.0/dr_sq - (d-1.0)/(2.0 * r[i] * dr)\n    \n    # Boundary condition at r=0 (i=0)\n    main_diag[0] = -2.0*d/dr_sq - k_sq\n    upper_diag[0] = 2.0*d/dr_sq\n\n    # Boundary condition at r=R_c (i=N_GRID_POINTS-1)\n    main_diag[-1] = -2.0/dr_sq - k_sq\n    lower_diag[-1] = 2.0/dr_sq\n\n    ab = np.zeros((3, N_GRID_POINTS))\n    ab[1, :] = main_diag\n    ab[0, 1:] = upper_diag\n    ab[2, :-1] = lower_diag\n    \n    try:\n        phi = solve_banded((1, 1), ab, -rho_p, check_finite=False)\n    except np.linalg.LinAlgError:\n        return np.inf\n\n    # 4. Compute Coulomb energy density by numerical integration of (1/2) * rho * phi.\n    integrand = phi[:N_r_idx] * (r[:N_r_idx]**(d-1))\n    integral_val = np.trapz(integrand, x=r[:N_r_idx])\n    \n    if R_c == 0: return 0.0\n    \n    e_coul = (d * n_p_in / (2.0 * R_c**d)) * integral_val\n    return e_coul\n\ndef _get_preferred_geometry(n):\n    \"\"\"\n    Finds the pasta geometry with the minimum free energy at a given density n.\n    \n    Args:\n        n (float): Baryon number density in fm^-3.\n        \n    Returns:\n        int: The integer code (1, 2, or 3) for the preferred geometry.\n    \"\"\"\n    u, n_p_in, sigma_n, lambda_e = _get_physical_params(n)\n    \n    min_energies = {}\n    \n    # Iterate through geometries: 3=spheres, 2=cylinders, 1=slabs.\n    for d in [3, 2, 1]:\n        def total_energy(r_N):\n            e_surf = d * sigma_n * u / r_N\n            e_coul = _calculate_coulomb_energy(d, u, n_p_in, lambda_e, r_N)\n            return e_surf + e_coul\n            \n        res = minimize_scalar(\n            total_energy,\n            bounds=(0.5, 30.0),\n            method='bounded'\n        )\n        min_energies[d] = res.fun\n        \n    # Determine the geometry that yields the minimum total energy.\n    preferred_d = min(min_energies, key=min_energies.get)\n    return preferred_d\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite of densities.\n    The results are printed in the specified single-line format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0.01, 0.03, 0.06, 0.09, 0.12, 0.15]\n\n    results = []\n    for n in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        result = _get_preferred_geometry(n)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在基本能量竞争模型的基础上，本实践将介绍核能量密度泛函（Energy Density Functional, EDF）中特定项所扮演的关键角色。通过使用可压缩液滴模型，你将分析性地研究自旋-轨道相互作用和配对能的贡献如何影响板层状和柱状结构的相对稳定性。这项练习让你深入了解核力模型的细节如何改变不同“面食”相之间的能量平衡。",
            "id": "3579784",
            "problem": "你将使用可压缩液滴近似下的能量密度泛函（EDF）框架，对两种理想化的核“面食相”形态——板状（slabs）和棒状（rods）——进行计算比较。目标是在固定的重子密度和质子分数下，计算板状和棒状构型之间每重子的能量差，并评估包含自旋轨道项和对能项如何改变其稳定性。该问题必须从第一性原理出发求解，并使用数学和物理上一致的规则来表述。\n\n请使用以下物理和建模设置。\n\n1. 基本基础和物理背景：\n   - 考虑中子星内核中处于固定重子数密度 $n$ 和质子分数 $Y_p$ 的核物质两相混合物。一相是密度约等于饱和密度的密核物质，另一相是稀薄气体。\n   - 能量密度泛函（EDF）模型包括来自体核物质、梯度（表面）能、库仑能、自旋轨道能和对能的贡献。对于均匀相，自旋轨道和对能的贡献可以通过界面附近的有效修正来近似。\n\n2. 全局常数和固定条件：\n   - 使用固定的重子数密度 $n = 0.06\\,\\mathrm{fm}^{-3}$。\n   - 使用固定的质子分数 $Y_p = 0.05$。\n   - 核饱和密度 $n_0 = 0.16\\,\\mathrm{fm}^{-3}$。\n   - 核单位下的基本库仑常数：$e^2 = 1.44\\,\\mathrm{MeV\\,fm}$。\n   - 界面厚度（相干长度）$\\xi = 2\\,\\mathrm{fm}$。\n   - 梯度系数 $C_{\\mathrm{grad}} = 20\\,\\mathrm{MeV\\,fm}^5$。\n   - 基准自旋轨道系数 $C_{\\mathrm{so,0}} = 6\\,\\mathrm{MeV\\,fm}^5$。\n   - 每单位面积的基准对抑制尺度 $P_s = 1.0\\,\\mathrm{MeV\\,fm}^{-2}$。\n\n3. 几何与热力学设置：\n   - 假设密相的重子密度为 $n_{\\mathrm{in}} \\approx n_0$，稀相的重子密度为 $n_{\\mathrm{out}} \\approx 0$。密相所占的体积分数为 $u = n/n_0$，其中 $0  u  1$。为保证数值稳健性，必要时将 $u$ 严格限制在 $(0,1)$ 区间内。\n   - 两相之间的质子密度差为 $\\Delta n_p = Y_p\\,(n_{\\mathrm{in}} - n_{\\mathrm{out}}) \\approx Y_p\\,n_0$。\n   - 对于板状（平面）和棒状（圆柱）两种几何构型，用密域的单个特征尺寸 $l$（对于板状，是板厚度 $t$；对于棒状，是圆柱半径 $R$）来表示形态。在每个胞腔单个域的近似下，两种几何构型的单位体积界面面积可表示为 $S/V \\approx 2u/l$。\n   - 几何相关的库仑能密度与特征尺寸 $l$ 的平方成正比，并取决于一个无量纲形状因子 $f_d(u)$ 和一个几何相关的前置因子 $A_d$：\n     - 对于板状（维度 $d=1$），使用 $A_1 = \\pi$ 和 $f_1(u) = u\\,(1 - u)$。\n     - 对于棒状（维度 $d=2$），使用 $A_2 = \\pi/2$ 和 $f_2(u) = u\\,(1 - u/2)$。\n   - 梯度（表面）能密度通过一个与 $S/V$ 呈线性的项来近似：$E_{\\mathrm{surf}}/V \\approx \\sigma_{\\mathrm{surf}}\\,(S/V)$，其中 $\\sigma_{\\mathrm{surf}} = C_{\\mathrm{grad}}\\,\\Delta n^2/\\xi$ 且 $\\Delta n = n_{\\mathrm{in}} - n_{\\mathrm{out}} \\approx n_0$。\n   - 自旋轨道能密度的建模方式类似，也作为一个与界面呈线性的修正：$E_{\\mathrm{so}}/V \\approx \\sigma_{\\mathrm{so}}\\,(S/V)$，其中 $\\sigma_{\\mathrm{so}} = C_{\\mathrm{so}}\\,\\Delta n^2/\\xi$，$C_{\\mathrm{so}}$ 是一个可调系数，通过一个缩放因子从基准值 $C_{\\mathrm{so,0}}$ 派生而来。\n   - 对能密度在界面附近表现出抑制效应。将这种几何相关的抑制建模为 $E_{\\mathrm{pair}}/V \\approx \\sigma_{\\mathrm{pair}}\\,(S/V)$，其中 $\\sigma_{\\mathrm{pair}} = P_s\\,Y_p$，可能再乘以一个因子。在固定 $n$ 和 $Y_p$ 下比较不同几何构型时，均匀体对能的贡献会相互抵消，因此能量差只需要考虑与界面相关的抑制项。\n\n4. 优化原理：\n   - 对于给定的几何构型，能量密度的几何相关部分是特征尺寸 $l$ 的一个界面线性项和一个库仑二次项之和：\n     $$\\frac{E_{\\mathrm{geom}}}{V}(l) = \\underbrace{\\left(\\sigma_{\\mathrm{surf}} + \\sigma_{\\mathrm{so}} + \\sigma_{\\mathrm{pair}}\\right)\\frac{2u}{l}}_{\\text{界面线性项}} + \\underbrace{A_d\\,e^2\\,(\\Delta n_p)^2\\,u\\,f_d(u)\\,l^2}_{\\text{库仑二次项}}.$$\n   - 你必须对每种几何构型，关于 $l > 0$ 最小化 $\\frac{E_{\\mathrm{geom}}}{V}(l)$，以获得优化的几何相关能量密度。然后，通过除以 $n$ 将其转换为每重子能量。\n\n5. 交付成果：\n   - 实现一个程序，使用上述模型，为指定的固定 $n$ 和 $Y_p$ 计算板状和棒状构型的每重子能量，单位为每重子 $\\mathrm{MeV}$。\n   - 针对一系列测试用例，通过开关自旋轨道项和对能项并调整其强度，计算每重子能量差 $\\Delta E = E_{\\mathrm{slab}} - E_{\\mathrm{rod}}$，单位为 $\\mathrm{MeV}$。\n\n6. 单位和数值报告：\n   - 所有能量差以每重子 $\\mathrm{MeV}$ 表示，四舍五入到六位小数。\n   - 不使用角度；不需要角度单位。\n\n7. 测试套件：\n   - 在上述固定的 $n$ 和 $Y_p$ 值下，使用以下六个测试用例。每个用例设置了自旋轨道和对能的布尔开关，以及相对于基准值的缩放因子：\n     1. 自旋轨道开启，对能开启，自旋轨道尺度 1.0，对能尺度 1.0。\n     2. 自旋轨道关闭，对能关闭，自旋轨道尺度 1.0，对能尺度 1.0。\n     3. 自旋轨道开启，对能关闭，自旋轨道尺度 1.0，对能尺度 1.0。\n     4. 自旋轨道关闭，对能开启，自旋轨道尺度 1.0，对能尺度 1.0。\n     5. 自旋轨道开启，对能开启，自旋轨道尺度 2.0，对能尺度 1.0。\n     6. 自旋轨道开启，对能开启，自旋轨道尺度 1.0，对能尺度 2.0。\n   - 对于每个测试用例，输出两个量：每重子能量差 $\\Delta E$ 和一个布尔值，该布尔值指示在最优状态下板状构型是否比棒状构型更稳定（即 $\\Delta E \\le 0$ 是否成立）。\n\n8. 最终输出格式：\n   - 你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。该列表必须首先包含六个能量差（单位为每重子 $\\mathrm{MeV}$，每个值四舍五入到六位小数），然后是六个布尔值，顺序与测试用例相同。例如，一个有效的输出形式是\n     $$[\\Delta E_1,\\Delta E_2,\\Delta E_3,\\Delta E_4,\\Delta E_5,\\Delta E_6,\\mathrm{stable}_1,\\mathrm{stable}_2,\\mathrm{stable}_3,\\mathrm{stable}_4,\\mathrm{stable}_5,\\mathrm{stable}_6].$$\n\n你的实现必须是一个完整的、可运行的程序，遵守指定的运行时环境，并且只打印上述描述的单行内容。",
            "solution": "用户希望解决一个关于中子星中“面食相”的计算核物理问题。\n这个问题的目标是在能量密度泛函（EDF）框架下，使用可压缩液滴模型，比较两种理想化的核“面食相”形态——板状（slabs）和棒状（rods）——的能量稳定性。稳定性通过计算每种相的几何构型优化后，两者之间的每重子能量差 $\\Delta E = E_{\\mathrm{slab}} - E_{\\mathrm{rod}}$ 来评估。分析还将探讨自旋轨道和对能相互作用对该能量差的影响。\n\n模型的核心是能量密度的几何相关部分 $\\mathcal{E}_{\\mathrm{geom}}/V$，它是特征尺寸 $l$（板厚度或棒半径）的函数。对于由维度 $d$（$d=1$ 代表板状，$d=2$ 代表棒状）索引的给定几何构型，此能量密度由界面相关项和库仑项之和给出：\n$$\n\\frac{E_{\\mathrm{geom}}}{V}(l) \\equiv \\mathcal{E}_d(l) = \\frac{C_1}{l} + C_{2,d} l^2\n$$\n第一项解释了在密核相和稀核相之间创建界面所需的能量成本。系数 $C_1$ 与总表面张力 $\\sigma_{\\mathrm{total}}$ 和单位体积的界面面积成正比，后者近似为 $S/V \\approx 2u/l$。表面张力本身是核梯度能（$\\sigma_{\\mathrm{surf}}$）、自旋轨道相互作用（$\\sigma_{\\mathrm{so}}$）和对能（$\\sigma_{\\mathrm{pair}}$）贡献的总和。因此，该系数为：\n$$\nC_1 = (\\sigma_{\\mathrm{surf}} + \\sigma_{\\mathrm{so}} + \\sigma_{\\mathrm{pair}}) \\cdot 2u\n$$\n其中 $u=n/n_0$ 是密相的体积分数。各个表面张力项定义如下：\n- $\\sigma_{\\mathrm{surf}} = C_{\\mathrm{grad}}\\,\\Delta n^2/\\xi$\n- $\\sigma_{\\mathrm{so}} = C_{\\mathrm{so}}\\,\\Delta n^2/\\xi$\n- $\\sigma_{\\mathrm{pair}} = P_s\\,Y_p \\cdot (\\text{缩放因子})$\n这里，$\\Delta n \\approx n_0$ 是两相之间的重子密度差。自旋轨道项和对能项可以根据测试用例的规范开启、关闭和缩放。\n\n第二项 $C_{2,d} l^2$ 代表带电密结构内部的排斥性库仑能。系数 $C_{2,d}$ 取决于几何构型：\n$$\nC_{2,d} = A_d\\,e^2\\,(\\Delta n_p)^2\\,u\\,f_d(u)\n$$\n其中 $\\Delta n_p \\approx Y_p n_0$ 是质子密度差，$e^2$ 是库仑常数，$A_d$ 是一个几何相关的前置因子（板状为 $A_1=\\pi$，棒状为 $A_2=\\pi/2$），$f_d(u)$ 是一个无量纲形状因子（板状为 $f_1(u) = u(1 - u)$，棒状为 $f_2(u) = u(1-u/2)$）。\n\n对于每种形态，我们通过关于 $l > 0$ 最小化 $\\mathcal{E}_d(l)$ 来找到最佳特征尺寸 $l_{d,\\text{opt}}$。我们在能量密度导数为零的地方求解 $l$：\n$$\n\\frac{d\\mathcal{E}_d(l)}{dl} = -\\frac{C_1}{l^2} + 2 C_{2,d} l = 0\n$$\n这给出了最佳尺寸：\n$$\nl_{d,\\text{opt}} = \\left( \\frac{C_1}{2 C_{2,d}} \\right)^{1/3}\n$$\n将 $l_{d,\\text{opt}}$ 代回能量密度表达式，得到最小化的能量密度 $\\mathcal{E}_{d,\\text{min}}$：\n$$\n\\mathcal{E}_{d,\\text{min}} = \\mathcal{E}_d(l_{d,\\text{opt}}) = \\frac{C_1}{l_{d,\\text{opt}}} + C_{2,d} l_{d,\\text{opt}}^2\n$$\n使用关系式 $C_1 = 2 C_{2,d} l_{d,\\text{opt}}^3$，我们可以将其简化为：\n$$\n\\mathcal{E}_{d,\\text{min}} = 2 C_{2,d} l_{d,\\text{opt}}^2 + C_{2,d} l_{d,\\text{opt}}^2 = 3 C_{2,d} l_{d,\\text{opt}}^2 = 3 C_{2,d} \\left( \\frac{C_1}{2 C_{2,d}} \\right)^{2/3}\n$$\n这可以进一步简化为：\n$$\n\\mathcal{E}_{d,\\text{min}} = \\frac{3}{2^{2/3}} C_1^{2/3} C_{2,d}^{1/3}\n$$\n问题要求的是每重子能量 $E_{d, \\text{baryon}}$，它是通过将最小能量密度除以平均重子密度 $n$ 得到的：\n$$\nE_{d, \\text{baryon}} = \\frac{\\mathcal{E}_{d,\\text{min}}}{n} = \\frac{3}{n \\cdot 2^{2/3}} C_1^{2/3} C_{2,d}^{1/3}\n$$\n我们感兴趣的量是板状（$d=1$）和棒状（$d=2$）构型之间的每重子能量差：\n$$\n\\Delta E = E_{\\mathrm{slab}} - E_{\\mathrm{rod}} = E_{1, \\text{baryon}} - E_{2, \\text{baryon}}\n$$\n提出公因子，我们得到用于计算的最终表达式：\n$$\n\\Delta E = \\frac{3}{n \\cdot 2^{2/3}} C_1^{2/3} \\left( C_{2,1}^{1/3} - C_{2,2}^{1/3} \\right)\n$$\n如果 $\\Delta E \\le 0$，则板状构型比棒状构型更稳定。\n\n计算流程如下：\n1.  定义所有物理常数（$n, Y_p, n_0, e^2, \\xi, C_{\\mathrm{grad}}, C_{\\mathrm{so,0}}, P_s$）并预先计算派生常数（$u, \\Delta n, \\Delta n_p, \\sigma_{\\mathrm{surf}}$）。\n2.  预先计算几何相关的库仑系数 $C_{2,1}$ 和 $C_{2,2}$，因为它们在所有测试用例中都是不变的。\n3.  遍历六个测试用例。对于每个用例：\n    a. 根据布尔标志和缩放因子确定 $\\sigma_{\\mathrm{so}}$ 和 $\\sigma_{\\mathrm{pair}}$ 的值。\n    b. 计算总表面张力 $\\sigma_{\\mathrm{total}} = \\sigma_{\\mathrm{surf}} + \\sigma_{\\mathrm{so}} + \\sigma_{\\mathrm{pair}}$。\n    c. 计算界面系数 $C_1 = \\sigma_{\\mathrm{total}} \\cdot 2u$。\n    d. 使用最终推导的公式计算 $\\Delta E$。\n    e. 确定稳定性布尔值（$\\Delta E \\le 0$）。\n4.  收集结果并将其格式化为指定的单行输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the energy difference between slab and rod nuclear pasta phases.\n    \"\"\"\n    # 1. Fundamental base and physical context\n    # Fixed global constants and conditions\n    n = 0.06  # Baryon number density in fm^-3\n    Y_p = 0.05  # Proton fraction\n    n_0 = 0.16  # Nuclear saturation density in fm^-3\n    e2 = 1.44  # Elementary Coulomb constant in MeV fm\n    xi = 2.0  # Interface thickness in fm\n    C_grad = 20.0  # Gradient coefficient in MeV fm^5\n    C_so_0 = 6.0  # Baseline spin-orbit coefficient in MeV fm^5\n    P_s = 1.0  # Baseline pairing suppression scale in MeV fm^-2\n\n    # Derived constants from geometric and thermodynamic setup\n    u = n / n_0  # Volume fraction of dense phase\n    delta_n = n_0  # Baryon density contrast (n_in - n_out)\n    delta_np = Y_p * n_0  # Proton density contrast\n\n    # Interface tension contributions\n    sigma_surf = C_grad * (delta_n**2) / xi\n    \n    # Pre-calculate geometry-dependent Coulomb coefficients C_2,d\n    # These are constant across all test cases.\n    \n    # Common factor for C_2,d\n    c2_common_factor = e2 * (delta_np**2) * u\n    \n    # For slabs (d=1)\n    A1 = np.pi\n    f1_u = u * (1.0 - u)\n    C_2_1 = A1 * c2_common_factor * f1_u\n    \n    # For rods (d=2)\n    A2 = np.pi / 2.0\n    f2_u = u * (1.0 - u / 2.0)\n    C_2_2 = A2 * c2_common_factor * f2_u\n\n    # Test suite\n    test_cases = [\n        # (so_on, pairing_on, so_scale, pairing_scale)\n        (True, True, 1.0, 1.0),\n        (False, False, 1.0, 1.0),\n        (True, False, 1.0, 1.0),\n        (False, True, 1.0, 1.0),\n        (True, True, 2.0, 1.0),\n        (True, True, 1.0, 2.0),\n    ]\n\n    delta_e_results = []\n    stability_results = []\n\n    # Optimization and calculation loop\n    for so_on, pairing_on, so_scale, pairing_scale in test_cases:\n        # Calculate case-dependent interface tension terms\n        sigma_so = 0.0\n        if so_on:\n            C_so = C_so_0 * so_scale\n            sigma_so = C_so * (delta_n**2) / xi\n\n        sigma_pair = 0.0\n        if pairing_on:\n            scaled_P_s = P_s * pairing_scale\n            sigma_pair = scaled_P_s * Y_p\n\n        # Total interface tension for the case\n        sigma_total = sigma_surf + sigma_so + sigma_pair\n        \n        # Calculate interface coefficient C_1\n        C_1 = sigma_total * 2.0 * u\n        \n        # Calculate energy difference using the derived formula\n        # Delta_E = (3 / (n * 2^(2/3))) * C_1^(2/3) * (C_2_1^(1/3) - C_2_2^(1/3))\n        \n        const_factor = 3.0 / (n * np.cbrt(4.0))\n        c1_factor = np.cbrt(C_1**2)\n        c2_diff_factor = np.cbrt(C_2_1) - np.cbrt(C_2_2)\n        \n        delta_E = const_factor * c1_factor * c2_diff_factor\n        \n        # Determine stability (slab is more stable if Delta_E = 0)\n        is_slab_stable = delta_E = 0.0\n        \n        delta_e_results.append(delta_E)\n        stability_results.append(is_slab_stable)\n\n    # Format the final output string\n    # Round delta_E values to six decimal places\n    formatted_delta_e = [f\"{val:.6f}\" for val in delta_e_results]\n    \n    # Convert booleans to strings 'True' or 'False'\n    formatted_stability = [str(val) for val in stability_results]\n    \n    final_output = f\"[{','.join(formatted_delta_e)},{','.join(formatted_stability)}]\"\n\n    # Print the final output in the exact required format\n    print(final_output)\n\nsolve()\n\n```"
        },
        {
            "introduction": "最后的实践将带你进入研究前沿，探索超越简单形状的复杂、非平凡的“面食”几何构型。你将使用三角函数拟设（ansatz）和先进的数值技术，在三维网格上对类似螺旋二十四面体（gyroid）的复杂三重周期性结构进行建模。通过实现基于快速傅里叶变换（FFT）的谱方法泊松求解器，并使用水平集（level-set）方法计算表面积，你将获得研究奇异核物质的现代计算工具的实践经验。",
            "id": "3579768",
            "problem": "你的任务是构建一个完整、可运行的程序，该程序针对拓扑受限的核“面食”候选构型，计算螺旋二十四面体（gyroid）状构型相对于板状（slab）和棒状（rod）构型的无量纲能量差 $\\Delta E$，并评估其亚稳态窗口。计算设置必须是纯数学和自洽的，从与高密度物质中核“面食”微结构相关的已确立能量分量出发。\n\n从以下基本基础开始，这在受液滴模型启发的核“面食”建模中是标准的：总能量密度被建模为表面项和库仑相互作用项之和。系统占据一个周期性的立方体域，并接受由解析、三周期函数生成的候选形态；拓扑结构受所选解析形式的约束。所有量在构造上均为无量纲。\n\n设周期性立方体域为 $[0,1]^3$，具有周期性边界条件。设空间网格每轴有 $N$ 个点，均匀间距为 $dx = 1/N$，笛卡尔网格坐标为 $\\{x_i\\}$, $\\{y_j\\}$, $\\{z_k\\}$，其中 $i,j,k \\in \\{0,1,\\dots,N-1\\}$。\n\n对每个候选形态，通过一个三角函数拟设来定义一个基础标量场 $\\phi(\\mathbf{r})$，其整数波数为 $k \\in \\mathbb{Z}^{+}$，角频率为 $\\omega = 2\\pi k$，振幅固定为1。三个候选族是：\n- 板状（lamella，常被称为“lasagna”）：$\\phi_{\\mathrm{slab}}(x,y,z;k) = \\sin(\\omega x)$。\n- 棒状（圆柱阵列，在理想化的可分离代理中常被称为“spaghetti”）：$\\phi_{\\mathrm{rod}}(x,y,z;k) = \\sin(\\omega x) + \\sin(\\omega y)$。\n- 螺旋二十四面体状三周期最小曲面代理（节点螺旋二十四面体近似）：$\\phi_{\\mathrm{gyro}}(x,y,z;k) = \\sin(\\omega x)\\cos(\\omega y) + \\sin(\\omega y)\\cos(\\omega z) + \\sin(\\omega z)\\cos(\\omega x)$。\n\n对于给定的密相体积分数 $f \\in (0,1)$，隐式定义等值面阈值 $t$，使得密相是超水平集 $\\{\\mathbf{r} \\, | \\, \\phi(\\mathbf{r}) \\ge t\\}$，且该集合的体积分数等于 $f$。在数值上，这可以通过将 $t$ 设置为网格上 $\\phi$ 的离散样本的 $(1-f)$-分位数来实现。\n\n设相指示函数为 $h(\\mathbf{r}) = H(\\phi(\\mathbf{r}) - t)$，其中 $H$ 是 Heaviside 函数，$H(u) = 1$ 当 $u \\ge 0$ 时成立，否则 $H(u) = 0$。通过定义无量纲电荷密度 $\\rho(\\mathbf{r}) = h(\\mathbf{r}) - f$ 来强制电中性，当体积分数约束被精确满足时，该电荷密度的空间平均值根据构造为零。\n\n使用水平集表面积公式定义表面贡献。等值面 $\\phi(\\mathbf{r}) = t$ 的表面积由下式给出\n$$\nA = \\int_{[0,1]^3} \\delta(\\phi(\\mathbf{r}) - t)\\,\\lVert \\nabla \\phi(\\mathbf{r}) \\rVert \\, d^3\\mathbf{r},\n$$\n其中 $\\delta$ 是 Dirac delta 函数。数值上用宽度为 $\\varepsilon  0$ 的窄高斯函数来近似 $\\delta$\n$$\n\\delta_{\\varepsilon}(u) = \\frac{1}{\\sqrt{\\pi}\\,\\varepsilon} \\exp\\!\\left(-\\frac{u^2}{\\varepsilon^2}\\right),\n$$\n并用具有周期性边界条件的中心有限差分来近似梯度：\n$$\n\\partial_x \\phi \\approx \\frac{\\phi(x+dx,y,z) - \\phi(x-dx,y,z)}{2\\,dx}, \\quad \\text{对 } \\partial_y, \\partial_z \\text{ 也类似}。\n$$\n设表面能系数为 $a_s  0$。表面能密度贡献为 $E_{\\mathrm{surf}} = a_s\\,A$。\n\n通过求解带周期性边界条件的无量纲泊松方程的静电势 $\\varphi$ 来定义库仑贡献，\n$$\n-\\nabla^2 \\varphi(\\mathbf{r}) = 4\\pi\\,\\rho(\\mathbf{r}),\n$$\n并设 $a_c  0$ 为库仑耦合前因子。库仑能量密度贡献为\n$$\nE_{\\mathrm{C}} = \\frac{1}{2} a_c \\int_{[0,1]^3} \\rho(\\mathbf{r})\\,\\varphi(\\mathbf{r}) \\, d^3\\mathbf{r}.\n$$\n在数值上，使用快速傅里叶变换（FFT）谱求解器计算 $\\varphi$：如果 $\\widehat{\\rho}(\\mathbf{k})$ 是 $\\rho$ 的离散傅里叶变换，$\\mathbf{k}$ 是模平方为 $\\lVert \\mathbf{k} \\rVert^2$ 的波矢，则对于所有非零模式，\n$$\n\\widehat{\\varphi}(\\mathbf{k}) = \\frac{4\\pi \\widehat{\\rho}(\\mathbf{k})}{\\lVert \\mathbf{k} \\rVert^2},\n$$\n并将零模式设置为 0 以强制中性。通过逆 FFT 恢复 $\\varphi(\\mathbf{r})$，然后形成离散化积分。\n\n候选形状在波数 $k$ 处的总能量密度是各项之和\n$$\nE_{\\mathrm{tot}}(k; \\text{shape}, f, a_s, a_c, \\varepsilon) = E_{\\mathrm{surf}}(k) + E_{\\mathrm{C}}(k).\n$$\n\n拓扑受限最小化：对每个形状族，在整数波数 $k \\in \\{k_{\\min}, k_{\\min}+1, \\dots, k_{\\max}\\}$ 上最小化 $E_{\\mathrm{tot}}$，同时保持解析族不变（这强制了拓扑约束）。为每个形状确定最小化波数 $k_{\\star}$ 和最小能量 $E_{\\min}$。使用二阶有限差分\n$$\nE''(k_{\\star}) \\approx E_{\\mathrm{tot}}(k_{\\star}+1) - 2\\,E_{\\mathrm{tot}}(k_{\\star}) + E_{\\mathrm{tot}}(k_{\\star}-1),\n$$\n在离散极小值点评估局部曲率，以检查是否为局部最小值，前提是 $k_{\\star}$ 严格位于搜索区间内部。\n\n能量差与亚稳态：计算螺旋二十四面体的最小能量 $E_{\\min}^{\\mathrm{gyro}}$ 以及板状和棒状的最小能量 $E_{\\min}^{\\mathrm{slab}}$ 和 $E_{\\min}^{\\mathrm{rod}}$。定义能量差\n$$\n\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{s}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{slab}}, \\quad\n\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{r}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{rod}}.\n$$\n设基线能量为 $E_{\\min}^{\\mathrm{base}} = \\min\\!\\big(E_{\\min}^{\\mathrm{slab}}, E_{\\min}^{\\mathrm{rod}}\\big)$ 并定义 $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{base}}$。对于给定的非负窗口参数 $\\delta_{\\max}$，如果以下所有条件均成立，则宣布螺旋二十四面体为亚稳态：(i) $E''(k_{\\star}^{\\mathrm{gyro}})  0$ (内部局部最小值)，(ii) $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}}  0$，以及 (iii) $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}} \\le \\delta_{\\max}$。\n\n所有量均为无量纲。不使用角度。无需进行物理单位转换。\n\n使用以下测试套件实现所述计算。对每个案例，使用 $N = 32$, $k_{\\min} = 1$, $k_{\\max} = 6$（除非另有说明），并按下文描述的精确输出格式报告结果。\n- 案例 1: $f = 0.3$, $a_s = 1.0$, $a_c = 0.1$, $\\varepsilon = 0.03$, $\\delta_{\\max} = 0.05$.\n- 案例 2: $f = 0.5$, $a_s = 0.8$, $a_c = 0.2$, $\\varepsilon = 0.03$, $\\delta_{\\max} = 0.10$.\n- 案例 3: $f = 0.15$, $a_s = 1.2$, $a_c = 0.05$, $\\varepsilon = 0.03$, $\\delta_{\\max} = 0.05$.\n- 案例 4: $f = 0.85$, $a_s = 0.9$, $a_c = 0.25$, $\\varepsilon = 0.03$, $\\delta_{\\max} = 0.10$.\n\n你的程序必须：\n- 对每个案例，为螺旋二十四面体、板状和棒状族在 $k \\in \\{1,2,3,4,5,6\\}$ 上执行拓扑受限的最小化。\n- 计算如上定义的 $E_{\\min}^{\\mathrm{gyro}}$, $E_{\\min}^{\\mathrm{slab}}$, $E_{\\min}^{\\mathrm{rod}}$, $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{s}}$, $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{r}}$ 和亚稳态布尔值。\n- 生成单行输出，其中包含每个案例结果的列表，每个案例结果本身是一个格式为 $[E_{\\min}^{\\mathrm{gyro}}, E_{\\min}^{\\mathrm{slab}}, E_{\\min}^{\\mathrm{rod}}, \\Delta E_{\\mathrm{g}\\text{-}\\mathrm{s}}, \\Delta E_{\\mathrm{g}\\text{-}\\mathrm{r}}, \\text{metastable}]$ 的列表。能量是无量纲单位的浮点数；亚稳态标志是布尔值。\n\n最终的单行输出必须是这些按案例顺序排列的案例列表的顶层列表，以标准 Python 列表语法打印，例如 $[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$。",
            "solution": "所提供的问题是计算物理学中一个自洽且适定的练习，其科学基础是既定的核物质液滴模型。所有参数、方程和数值方法都已明确指定，不存在内部矛盾、歧义或事实错误。因此，该问题被认为是有效的，并按如下方式构建解决方案。\n\n任务的核心是计算三种核“面食”形态族——板状、棒状和螺旋二十四面体状结构——的总能量密度，并确定能量上更优的构型。总能量密度 $E_{\\mathrm{tot}}$ 是表面能贡献 $E_{\\mathrm{surf}}$ 和库仑能贡献 $E_{\\mathrm{C}}$ 的和。计算在一个离散化的周期性立方体域 $[0,1]^3$ 上进行。\n\n首先，我们建立计算网格。该域被离散化为一个 $N \\times N \\times N$ 个点的均匀网格。网格间距为 $dx=1/N$。我们使用带有 `'ij'` 索引的 `numpy.meshgrid` 生成三维坐标数组 $(x, y, z)$，使得数组索引直接对应于空间维度。\n\n对于每个形态族（板状、棒状、螺旋二十四面体），通过一个特定的三角函数拟设来定义一个标量场 $\\phi(\\mathbf{r})$。它们如下所示：\n- 板状: $\\phi_{\\mathrm{slab}}(x,y,z;k) = \\sin(\\omega x)$\n- 棒状: $\\phi_{\\mathrm{rod}}(x,y,z;k) = \\sin(\\omega x) + \\sin(\\omega y)$\n- 螺旋二十四面体状: $\\phi_{\\mathrm{gyro}}(x,y,z;k) = \\sin(\\omega x)\\cos(\\omega y) + \\sin(\\omega y)\\cos(\\omega z) + \\sin(\\omega z)\\cos(\\omega x)$\n这里，$k \\in \\mathbb{Z}^{+}$ 是一个整数波数，$\\omega = 2\\pi k$ 是对应的角频率。这些场在三维网格的每个点上进行求值。\n\n系统根据 $\\phi(\\mathbf{r})$ 的值被划分为密相和稀相。对于给定的密相体积分数 $f$，确定一个等值面阈值 $t$，使得 $\\phi(\\mathbf{r}) \\ge t$ 区域的体积等于 $f$。在数值上，通过找到网格上离散场 $\\phi$ 所有值的 $(1-f)$-分位数可以稳健地实现这一点。然后定义一个相指示场 $h(\\mathbf{r})$，对于密相（$\\phi(\\mathbf{r}) \\ge t$）$h(\\mathbf{r})=1$，对于稀相 $h(\\mathbf{r})=0$。这通过条件 `phi >= t` 来实现。为确保整体电中性，定义了无量纲电荷密度 $\\rho(\\mathbf{r}) = h(\\mathbf{r}) - f$。根据构造，$\\rho(\\mathbf{r})$ 在整个域上的空间平均值近似为零。\n\n表面能密度由 $E_{\\mathrm{surf}} = a_s A$ 给出，其中 $a_s$ 是给定系数，$A$ 是单位体积内两相界面的总表面积。面积由水平集积分计算得出：\n$$\nA = \\int_{[0,1]^3} \\delta(\\phi(\\mathbf{r}) - t)\\,\\lVert \\nabla \\phi(\\mathbf{r}) \\rVert \\, d^3\\mathbf{r}\n$$\n在数值上，该积分通过对网格单元的求和来近似。Dirac delta 函数 $\\delta(u)$ 使用具有小宽度 $\\varepsilon$ 的窄高斯函数 $\\delta_{\\varepsilon}(u) = (\\sqrt{\\pi}\\varepsilon)^{-1} \\exp(-u^2/\\varepsilon^2)$ 进行正则化。梯度向量 $\\nabla\\phi$ 在每个网格点使用二阶中心有限差分格式计算，这通过使用 `numpy.roll` 访问相邻网格点，为周期性域高效地实现。梯度范数 $\\lVert \\nabla \\phi \\rVert$ 则是其分量的标准欧几里得范数。该积分被近似为对所有网格点 $i$ 的离散和：$A \\approx \\sum_i \\delta_{\\varepsilon}(\\phi_i - t)\\,\\lVert \\nabla \\phi_i \\rVert \\, (dx)^3$。\n\n库仑能量密度 $E_{\\mathrm{C}}$ 是通过求解满足周期性边界条件的泊松方程 $-\\nabla^2 \\varphi(\\mathbf{r}) = 4\\pi\\,\\rho(\\mathbf{r})$ 的解来计算的。该方程使用基于快速傅里叶变换（FFT）的谱方法高效求解。\n1.  计算电荷密度的三维FFT，$\\widehat{\\rho}(\\mathbf{k}) = \\mathcal{F}[\\rho(\\mathbf{r})]$。\n2.  生成与离散傅里叶模式对应的波矢 $\\mathbf{k}$ 网格。对于大小为 $N$、间距为 $dx=1/N$ 的网格，波矢分量为 $k_i = 2\\pi m_i$，其中整数 $m_i$ 由 `numpy.fft.fftfreq(N)` 给出。\n3.  在傅里叶空间中，泊松方程变成一个代数方程：$\\lVert \\mathbf{k} \\rVert^2 \\widehat{\\varphi}(\\mathbf{k}) = 4\\pi \\widehat{\\rho}(\\mathbf{k})$。\n4.  傅里叶空间中的势则为 $\\widehat{\\varphi}(\\mathbf{k}) = 4\\pi \\widehat{\\rho}(\\mathbf{k}) / \\lVert \\mathbf{k} \\rVert^2$，适用于所有非零波矢 $\\mathbf{k} \\neq \\mathbf{0}$。对于零模式（$\\mathbf{k}=\\mathbf{0}$），我们设置 $\\widehat{\\varphi}(\\mathbf{0})=0$，这强制了电中性并将平均势设置为零。通过识别并单独处理零模式，避免了除以零的错误。\n5.  通过对 $\\widehat{\\varphi}(\\mathbf{k})$ 执行逆三维FFT，可以恢复实空间中的势 $\\varphi(\\mathbf{r})$。\n然后，通过将积分 $E_{\\mathrm{C}} = \\frac{1}{2} a_c \\int \\rho(\\mathbf{r})\\varphi(\\mathbf{r}) \\, d^3\\mathbf{r}$ 近似为网格上的离散和来计算库仑能量密度：$E_{\\mathrm{C}} \\approx \\frac{1}{2} a_c \\sum_i \\rho_i \\varphi_i \\, (dx)^3$。\n\n对每种形态以及指定范围 $\\{k_{\\min}, \\dots, k_{\\max}\\}$ 内的每个整数波数 $k$，计算总能量 $E_{\\mathrm{tot}} = E_{\\mathrm{surf}} + E_{\\mathrm{C}}$。对于每种形态，通过从计算出的能量中选择最小值来找到最小能量 $E_{\\min}$ 和相应的最优波数 $k_{\\star}$。\n\n最后，评估螺旋二十四面体相的亚稳态性。计算能量差 $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{s}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{slab}}$ 和 $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{r}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{rod}}$。建立一个基线能量 $E_{\\min}^{\\mathrm{base}} = \\min(E_{\\min}^{\\mathrm{slab}}, E_{\\min}^{\\mathrm{rod}})$，并计算螺旋二十四面体相对于此基线的能量差 $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{base}}$。如果同时满足三个条件，则宣布螺旋二十四面体为亚稳态：\n1.  该构型对应于关于 $k$ 的局部最小值。这通过用中心有限差分近似二阶导数 $E''(k_{\\star}^{\\mathrm{gyro}})$ 来检查。条件是 $E''(k_{\\star}^{\\mathrm{gyro}}) > 0$，这要求 $k_{\\star}^{\\mathrm{gyro}}$ 是搜索范围的内部点（即，$k_{\\min}  k_{\\star}^{\\mathrm{gyro}}  k_{\\max}$）。\n2.  螺旋二十四面体不是基态：$\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}} > 0$。\n3.  螺旋二十四面体的能量足够接近基态，即在给定的窗口内：$\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}} \\le \\delta_{\\max}$。\n\n整体算法遍历每个提供的测试案例，为三种形态执行这些计算，确定最小能量和亚稳态性，并将结果整理成指定的列表格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_total_energy(shape, k, f, a_s, a_c, epsilon, N):\n    \"\"\"\n    Computes the total energy density for a given morphology.\n    \"\"\"\n    # 1. Grid Setup\n    dx = 1.0 / N\n    coords_1d = np.linspace(0, 1.0, N, endpoint=False)\n    # 'ij' indexing: xx varies along axis 0, yy axis 1, zz axis 2\n    xx, yy, zz = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n\n    # 2. Scalar Field phi Calculation\n    omega = 2.0 * np.pi * k\n    if shape == 'slab':\n        phi = np.sin(omega * xx)\n    elif shape == 'rod':\n        phi = np.sin(omega * xx) + np.sin(omega * yy)\n    elif shape == 'gyro':\n        phi = (np.sin(omega * xx) * np.cos(omega * yy) +\n               np.sin(omega * yy) * np.cos(omega * zz) +\n               np.sin(omega * zz) * np.cos(omega * xx))\n    else:\n        raise ValueError(\"Unknown shape.\")\n\n    # 3. Isosurface Threshold t\n    t = np.quantile(phi, 1.0 - f)\n\n    # 4. Surface Energy E_surf\n    # Gradient of phi using centered differences with periodic boundaries\n    grad_x = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2.0 * dx)\n    grad_y = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * dx)\n    grad_z = (np.roll(phi, -1, axis=2) - np.roll(phi, 1, axis=2)) / (2.0 * dx)\n    \n    grad_phi_norm = np.sqrt(grad_x**2 + grad_y**2 + grad_z**2)\n    \n    # Regularized delta function\n    u_arg = (phi - t) / epsilon\n    delta_eps = (1.0 / (np.sqrt(np.pi) * epsilon)) * np.exp(-u_arg**2)\n    \n    # Surface area integral approximation\n    surface_area = np.sum(delta_eps * grad_phi_norm) * (dx**3)\n    E_surf = a_s * surface_area\n\n    # 5. Coulomb Energy E_C\n    # Phase indicator and charge density\n    h = (phi >= t).astype(float)\n    rho = h - f\n\n    # FFT-based Poisson solver\n    rho_hat = np.fft.fftn(rho)\n    \n    # Wavevector grid\n    k_freq = np.fft.fftfreq(N, d=dx)\n    kx, ky, kz = np.meshgrid(k_freq, k_freq, k_freq, indexing='ij')\n    # Physical wavevector, k = 2*pi*f\n    k_sq = (2 * np.pi)**2 * (kx**2 + ky**2 + kz**2)\n    \n    # Solve for potential in Fourier space\n    phi_potential_hat = np.zeros_like(rho_hat, dtype=complex)\n    # Avoid division by zero at k=0\n    nonzero_k = k_sq > 1e-9 # A small tolerance for floating point k_sq[0,0,0]\n    phi_potential_hat[nonzero_k] = 4 * np.pi * rho_hat[nonzero_k] / k_sq[nonzero_k]\n\n    # Inverse FFT to get potential in real space\n    phi_potential = np.fft.ifftn(phi_potential_hat).real\n    \n    # Coulomb energy integral approximation\n    E_c = 0.5 * a_c * np.sum(rho * phi_potential) * (dx**3)\n\n    return E_surf + E_c\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (f, a_s, a_c, epsilon, delta_max)\n        (0.3, 1.0, 0.1, 0.03, 0.05),\n        (0.5, 0.8, 0.2, 0.03, 0.10),\n        (0.15, 1.2, 0.05, 0.03, 0.05),\n        (0.85, 0.9, 0.25, 0.03, 0.10),\n    ]\n\n    # Shared parameters\n    N = 32\n    k_min = 1\n    k_max = 6\n    k_range = list(range(k_min, k_max + 1))\n    shapes = ['slab', 'rod', 'gyro']\n    \n    all_results = []\n\n    for case in test_cases:\n        f, a_s, a_c, epsilon, delta_max = case\n        \n        min_energies = {}\n        k_stars = {}\n        all_energies = {}\n\n        for shape in shapes:\n            energies_for_shape = [\n                calculate_total_energy(shape, k, f, a_s, a_c, epsilon, N)\n                for k in k_range\n            ]\n            all_energies[shape] = np.array(energies_for_shape)\n            min_idx = np.argmin(all_energies[shape])\n            min_energies[shape] = all_energies[shape][min_idx]\n            k_stars[shape] = k_range[min_idx]\n\n        E_min_gyro = min_energies['gyro']\n        E_min_slab = min_energies['slab']\n        E_min_rod = min_energies['rod']\n\n        # Energy differences\n        dE_gs = E_min_gyro - E_min_slab\n        dE_gr = E_min_gyro - E_min_rod\n\n        # Metastability check\n        is_metastable = False\n        k_star_gyro = k_stars['gyro']\n\n        # Condition (i): Local minimum (curvature check)\n        is_interior = k_min  k_star_gyro  k_max\n        curvature_check = False\n        if is_interior:\n            idx = k_range.index(k_star_gyro)\n            gyro_energies = all_energies['gyro']\n            E_double_prime = gyro_energies[idx + 1] - 2 * gyro_energies[idx] + gyro_energies[idx - 1]\n            if E_double_prime > 0:\n                curvature_check = True\n        \n        # Conditions (ii) and (iii): Energy hierarchy\n        E_min_base = min(E_min_slab, E_min_rod)\n        dE_g_base = E_min_gyro - E_min_base\n        \n        energy_diff_check_1 = dE_g_base > 0\n        energy_diff_check_2 = dE_g_base = delta_max\n        \n        if curvature_check and energy_diff_check_1 and energy_diff_check_2:\n            is_metastable = True\n\n        case_result = [\n            E_min_gyro, E_min_slab, E_min_rod,\n            dE_gs, dE_gr,\n            is_metastable\n        ]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    print(str(all_results))\n\nsolve()\n```"
        }
    ]
}