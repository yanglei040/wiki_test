{
    "hands_on_practices": [
        {
            "introduction": "The formation of nuclear pasta is governed by a delicate balance between the attractive strong force, which favors uniform nuclear matter, and the long-range Coulomb repulsion between protons, which favors small, separated clusters. This practice explores this competition using a simplified liquid-drop model within a Wigner-Seitz cell, a common and intuitive approximation. By minimizing the sum of surface and Coulomb energies for different idealized geometries—droplets (\"gnocchi\"), rods (\"spaghetti\"), and slabs (\"lasagna\")—you can predict which shape is most energetically favorable at a given density. This foundational exercise provides hands-on experience with the core mechanism of pasta formation and develops key computational skills in optimization and solving boundary-value problems .",
            "id": "3579770",
            "problem": "You are asked to write a complete, runnable program that determines the preferred nuclear pasta geometry as the baryon number density increases, by comparing minimized free-energy densities for three candidate geometries: spheres ($d=3$; \"droplets\"), cylinders ($d=2$; \"rods\"), and slabs ($d=1$; \"slabs\"). The comparison must be performed at each specified baryon number density by minimizing the sum of surface and Coulomb contributions to the free-energy density for each geometry, using the prescribed surface tension, proton fraction, and linear electron screening model.\n\nThe physical and numerical model to implement is as follows.\n\n1. Geometry and Wigner–Seitz construction. For each geometry dimension $d \\in \\{1,2,3\\}$, assume a periodic arrangement of identical clusters described by a Wigner–Seitz cell of radius $R_{\\mathrm{c}}$ and an inner cluster size $r_{\\mathrm{N}}$. The baryon number density is $n$ (in $\\mathrm{fm}^{-3}$). The dense nuclear phase inside the cluster has a fixed baryon number density $n_{\\mathrm{in}} = 0.16\\,\\mathrm{fm}^{-3}$. The volume fraction occupied by the dense phase is\n$$\nu = \\frac{n}{n_{\\mathrm{in}}}, \\quad \\text{clamped to } 10^{-2} \\le u \\le 0.99 \\text{ for numerical stability}.\n$$\nThe Wigner–Seitz relation between the cluster size and cell radius is\n$$\nu = \\left(\\frac{r_{\\mathrm{N}}}{R_{\\mathrm{c}}}\\right)^{d} \\quad \\Rightarrow \\quad R_{\\mathrm{c}} = \\frac{r_{\\mathrm{N}}}{u^{1/d}}.\n$$\nUse $d=3$ for spheres, $d=2$ for cylinders, and $d=1$ for slabs.\n\n2. Proton fraction and electron density. The proton fraction is prescribed as a function of $n$ by\n$$\nY_{p}(n) = 0.05 + 0.1 \\exp\\!\\left(-\\frac{n}{0.06\\,\\mathrm{fm}^{-3}}\\right).\n$$\nThe proton number density inside the dense phase is $n_{p,\\mathrm{in}}(n)=Y_{p}(n)\\,n_{\\mathrm{in}}$. Electrons provide global charge neutrality and are treated in linear response via a screening length that depends on the average electron density $n_{e} = u\\,n_{p,\\mathrm{in}}$.\n\n3. Surface energy density. The surface tension is prescribed as\n$$\n\\sigma(n) = \\max\\!\\left(0.3, \\, 1.0 - 0.4\\,\\frac{n}{0.16\\,\\mathrm{fm}^{-3}}\\right)\\ \\mathrm{MeV/fm^{2}},\n$$\nand the surface energy density for a given geometry is\n$$\n\\varepsilon_{S}(d,n,r_{\\mathrm{N}}) = \\frac{d\\,\\sigma(n)\\,u}{r_{\\mathrm{N}}}\\ \\mathrm{MeV/fm^{3}}.\n$$\n\n4. Electron screening length. Model ultra-relativistic electron screening with an empirical screening length that depends on the average electron density $n_{e}$:\n$$\n\\lambda_{e}(n) = 20\\,\\mathrm{fm}\\ \\left(\\frac{0.05\\,\\mathrm{fm}^{-3}}{n_{e}}\\right)^{1/3}.\n$$\n\n5. Coulomb energy density by screened Poisson problem. Treat the Coulomb energy by solving a one-dimensional radial screened Poisson equation in divergence form for each geometry:\n$$\n\\frac{1}{r^{d-1}} \\frac{d}{dr} \\!\\left(r^{d-1} \\frac{d\\phi}{dr}\\right) - \\frac{\\phi}{\\lambda_{e}^{2}} = - \\rho_{p}(r),\n$$\nwith Neumann boundary conditions $d\\phi/dr|_{r=0} = 0$ and $d\\phi/dr|_{r=R_{\\mathrm{c}}} = 0$. The proton charge density is taken as uniform inside the cluster and zero outside,\n$$\n\\rho_{p}(r) = \\begin{cases}\nn_{p,\\mathrm{in}}(n), & 0 \\le r < r_{\\mathrm{N}},\\\\\n0, & r_{\\mathrm{N}} \\le r \\le R_{\\mathrm{c}}.\n\\end{cases}\n$$\nYou must discretize the equation in $r \\in [0, R_{\\mathrm{c}}]$ using a conservative finite-difference scheme in divergence form that is numerically stable at $r=0$ for $d \\in \\{1,2,3\\}$. Compute the Coulomb energy density as\n$$\n\\varepsilon_{C}(d,n,r_{\\mathrm{N}}) = \\frac{1}{2 V_{\\mathrm{cell}}} \\int_{0}^{R_{\\mathrm{c}}} \\rho_{p}(r)\\,\\phi(r)\\, S_{d}\\, r^{d-1}\\, dr,\n$$\nwhere $S_{1}=2$, $S_{2}=2\\pi$, $S_{3}=4\\pi$, and the cell volume is $V_{\\mathrm{cell}} = S_{d} R_{\\mathrm{c}}^{d}/d$. The overall electromagnetic constant is absorbed into units so that only relative comparisons across geometries at the same $n$ are required; the program must ensure internally consistent scaling across geometries.\n\n6. Total free-energy density and minimization. For each geometry and each density $n$, minimize\n$$\n\\varepsilon_{\\mathrm{tot}}(d,n,r_{\\mathrm{N}}) = \\varepsilon_{S}(d,n,r_{\\mathrm{N}}) + \\varepsilon_{C}(d,n,r_{\\mathrm{N}})\n$$\nwith respect to $r_{\\mathrm{N}}$ over a physically reasonable domain $r_{\\mathrm{N}} \\in [0.5\\,\\mathrm{fm},\\,30\\,\\mathrm{fm}]$, using a robust one-dimensional search. The minimization must be performed independently for each geometry.\n\n7. Phase selection. For each density $n$, select the geometry $d$ that yields the smallest minimized $\\varepsilon_{\\mathrm{tot}}(d,n)$.\n\n8. Output encoding. Encode the selected geometry for each density as an integer:\n- $3$ for spheres ($d=3$),\n- $2$ for cylinders ($d=2$),\n- $1$ for slabs ($d=1$).\n\nThe final output should be a single line containing the results for the entire test suite as a comma-separated list enclosed in square brackets.\n\nTest suite. Use the following baryon number densities (in $\\mathrm{fm}^{-3}$) as inputs:\n- Happy-path, low to moderate densities where droplet and rod phases compete: $n \\in \\{0.01,\\,0.03,\\,0.06\\}$.\n- Crossover regime where rods and slabs compete: $n \\in \\{0.09,\\,0.12\\}$.\n- High sub-saturation density close to $n_{\\mathrm{in}}$ to probe slab dominance: $n = 0.15$.\n\nYour program should produce a single line of output containing the integer-encoded preferred geometries for these densities, in the same order, as a comma-separated list enclosed in square brackets (for example, \"[3,3,2,1,1,1]\"). No other output is permitted. Since the outputs are integer codes, no physical units are required for the final answer line.",
            "solution": "The problem statement has been critically validated and is deemed valid. It presents a scientifically grounded, well-posed, and objective computational task rooted in the field of nuclear astrophysics. The model, while simplified, is based on established principles for studying \"nuclear pasta\" phases, namely the competition between surface and Coulomb energies within a Wigner-Seitz cell framework. All necessary equations, constants, and numerical parameters are provided, forming a self-contained and consistent problem definition. I will now proceed with the solution.\n\nThe core task is to determine the thermodynamically preferred nuclear geometry—spheres ($d=3$), cylinders ($d=2$), or slabs ($d=1$)—as a function of the average baryon number density, $n$. The preferred geometry is that which minimizes the total free-energy density, $\\varepsilon_{\\mathrm{tot}}$, which is the sum of a surface contribution, $\\varepsilon_S$, and a Coulomb contribution, $\\varepsilon_C$.\n\nFor a given geometry dimension $d$ and baryon density $n$, the total energy density is a function of the size $r_{\\mathrm{N}}$ of the dense nuclear clusters:\n$$\n\\varepsilon_{\\mathrm{tot}}(d, n, r_{\\mathrm{N}}) = \\varepsilon_{S}(d, n, r_{\\mathrm{N}}) + \\varepsilon_{C}(d, n, r_{\\mathrm{N}})\n$$\nOur methodology involves two main steps for each specified density $n$:\n1. For each geometry $d \\in \\{1, 2, 3\\}$, we minimize $\\varepsilon_{\\mathrm{tot}}(d, n, r_{\\mathrm{N}})$ with respect to the cluster size $r_{\\mathrm{N}}$ over the specified domain $r_{\\mathrm{N}} \\in [0.5\\,\\mathrm{fm},\\,30\\,\\mathrm{fm}]$. This yields a minimized energy for each geometry, $\\varepsilon_{\\mathrm{min}}(d, n) = \\min_{r_{\\mathrm{N}}} \\varepsilon_{\\mathrm{tot}}(d, n, r_{\\mathrm{N}})$.\n2. We compare these minimized energies and select the geometry $d^*$ that has the lowest energy: $\\varepsilon_{\\mathrm{min}}(d^*, n) \\le \\varepsilon_{\\mathrm{min}}(d, n)$ for all $d \\in \\{1, 2, 3\\}$.\n\nThe surface energy density, $\\varepsilon_S$, is given by:\n$$\n\\varepsilon_{S}(d,n,r_{\\mathrm{N}}) = \\frac{d\\,\\sigma(n)\\,u}{r_{\\mathrm{N}}}\n$$\nwhere $\\sigma(n)$ is the prescribed surface tension and $u = n/n_{\\mathrm{in}}$ is the volume fraction of the dense phase. This term favors larger structures (increasing $r_{\\mathrm{N}}$) to minimize the surface-to-volume ratio.\n\nThe Coulomb energy density, $\\varepsilon_C$, arises from the repulsion of protons within the cluster, screened by a surrounding electron gas. It is calculated by solving the one-dimensional radial screened Poisson equation for the electrostatic potential $\\phi(r)$:\n$$\n\\frac{1}{r^{d-1}} \\frac{d}{dr} \\!\\left(r^{d-1} \\frac{d\\phi}{dr}\\right) - \\frac{\\phi}{\\lambda_{e}^{2}} = - \\rho_{p}(r)\n$$\nsubject to zero-gradient (Neumann) boundary conditions, $\\phi'(0)=0$ and $\\phi'(R_c)=0$, where $R_c = r_{\\mathrm{N}}/u^{1/d}$ is the Wigner-Seitz cell radius. Here, $\\lambda_e$ is the electron screening length and $\\rho_p(r)$ is the proton number density, which is constant inside the cluster ($r  r_{\\mathrm{N}}$) and zero outside.\n\nThis equation can be rewritten as:\n$$\n\\frac{d^2\\phi}{dr^2} + \\frac{d-1}{r}\\frac{d\\phi}{dr} - k^2\\phi = -\\rho_p(r)\n$$\nwhere $k = 1/\\lambda_e$. This is a linear, second-order boundary value problem. We solve it numerically using a finite-difference method on a uniform radial grid of $N_{\\text{grid}}=500$ points from $r=0$ to $r=R_c$.\n- For interior grid points, standard second-order central differences are used for the derivatives.\n- At the origin $r=0$, the term $\\frac{d-1}{r}\\phi'$ is singular for $d>1$. Applying L'Hôpital's rule and the boundary condition $\\phi'(0)=0$, the equation becomes $d\\cdot\\phi''(0) - k^2\\phi(0) = -\\rho_p(0)$. This is discretized using a forward difference for $\\phi''(0)$ derived from a ghost point method.\n- At the outer boundary $r=R_c$, the condition $\\phi'(R_c)=0$ is implemented using a backward difference also derived from a ghost point.\n\nThis discretization transforms the differential equation into a tridiagonal system of linear algebraic equations, which is solved efficiently for the potential $\\phi$ at each grid point using `scipy.linalg.solve_banded`.\n\nOnce the potential $\\phi(r)$ is known, the Coulomb energy density is computed by numerically integrating over the charge distribution using the trapezoidal rule (`numpy.trapz`):\n$$\n\\varepsilon_{C}(d,n,r_{\\mathrm{N}}) = \\frac{d}{2 R_c^d} \\int_{0}^{r_{\\mathrm{N}}} n_{p,\\mathrm{in}} \\phi(r) r^{d-1} dr\n$$\nThe total energy $\\varepsilon_{\\mathrm{tot}}(r_{\\mathrm{N}})$ is then minimized with respect to $r_{\\mathrm{N}}$ using the robust `scipy.optimize.minimize_scalar` function with the 'bounded' method.\n\nThe entire process is repeated for each density in the test suite, and the resulting preferred geometry for each density is encoded as an integer ($1, 2,$ or $3$) and presented in the specified output format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\nfrom scipy.linalg import solve_banded\n\n# Define constants as per the problem statement.\nN_IN_DENSITY = 0.16  # fm^-3\nN_GRID_POINTS = 500  # Number of grid points for the finite-difference solver.\n\ndef _get_physical_params(n):\n    \"\"\"\n    Calculates density-dependent physical parameters.\n\n    Args:\n        n (float): Baryon number density in fm^-3.\n\n    Returns:\n        tuple: A tuple containing u, n_p_in, sigma_n, lambda_e.\n    \"\"\"\n    u = n / N_IN_DENSITY\n    u = np.clip(u, 1e-2, 0.99)\n    \n    yp_n = 0.05 + 0.1 * np.exp(-n / 0.06)\n    n_p_in = yp_n * N_IN_DENSITY\n    n_e = u * n_p_in\n    \n    sigma_n = max(0.3, 1.0 - 0.4 * n / N_IN_DENSITY)\n    \n    # Avoid division by zero if n_e is extremely small or zero.\n    if n_e = 1e-12:\n        lambda_e = np.inf\n    else:\n        lambda_e = 20.0 * (0.05 / n_e)**(1.0/3.0)\n        \n    return u, n_p_in, sigma_n, lambda_e\n\ndef _calculate_coulomb_energy(d, u, n_p_in, lambda_e, r_N):\n    \"\"\"\n    Solves the screened Poisson equation and computes the Coulomb energy density.\n    \n    Args:\n        d (int): Geometry dimension (1, 2, or 3).\n        u (float): Volume fraction.\n        n_p_in (float): Proton density inside the cluster.\n        lambda_e (float): Electron screening length.\n        r_N (float): Cluster radius.\n\n    Returns:\n        float: The calculated Coulomb energy density in MeV/fm^3 (with absorbed constants).\n    \"\"\"\n    if r_N = 0: return 0.0\n    R_c = r_N / (u**(1.0/d))\n    if R_c = r_N: return np.inf # Unphysical situation where u = 1\n\n    # 1. Set up the grid and physical parameters for the solver.\n    r = np.linspace(0, R_c, N_GRID_POINTS)\n    dr = r[1] - r[0]\n    \n    k_sq = 1.0 / lambda_e**2 if np.isfinite(lambda_e) else 0.0\n    \n    # 2. Define the source term (proton charge density).\n    N_r_idx = np.searchsorted(r, r_N, side='left')\n    rho_p = np.zeros(N_GRID_POINTS)\n    rho_p[:N_r_idx] = n_p_in\n\n    # 3. Build and solve the tridiagonal system for the potential phi.\n    # The system is M*phi = b, where b = -rho_p.\n    # The matrix M is stored in banded format `ab`.\n    dr_sq = dr**2\n    main_diag = np.zeros(N_GRID_POINTS)\n    upper_diag = np.zeros(N_GRID_POINTS - 1)\n    lower_diag = np.zeros(N_GRID_POINTS - 1)\n\n    # Discretization for interior points: 1 = i = N_GRID_POINTS - 2\n    for i in range(1, N_GRID_POINTS - 1):\n        main_diag[i] = -2.0/dr_sq - k_sq\n        upper_diag[i] = 1.0/dr_sq + (d-1.0)/(2.0 * r[i] * dr)\n        lower_diag[i-1] = 1.0/dr_sq - (d-1.0)/(2.0 * r[i] * dr)\n    \n    # Boundary condition at r=0 (i=0)\n    main_diag[0] = -2.0*d/dr_sq - k_sq\n    upper_diag[0] = 2.0*d/dr_sq\n\n    # Boundary condition at r=R_c (i=N_GRID_POINTS-1)\n    main_diag[-1] = -2.0/dr_sq - k_sq\n    lower_diag[-1] = 2.0/dr_sq\n\n    ab = np.zeros((3, N_GRID_POINTS))\n    ab[1, :] = main_diag\n    ab[0, 1:] = upper_diag\n    ab[2, :-1] = lower_diag\n    \n    try:\n        phi = solve_banded((1, 1), ab, -rho_p, check_finite=False)\n    except np.linalg.LinAlgError:\n        return np.inf\n\n    # 4. Compute Coulomb energy density by numerical integration of (1/2) * rho * phi.\n    integrand = phi[:N_r_idx] * (r[:N_r_idx]**(d-1))\n    integral_val = np.trapz(integrand, x=r[:N_r_idx])\n    \n    if R_c == 0: return 0.0\n    \n    e_coul = (d * n_p_in / (2.0 * R_c**d)) * integral_val\n    return e_coul\n\ndef _get_preferred_geometry(n):\n    \"\"\"\n    Finds the pasta geometry with the minimum free energy at a given density n.\n    \n    Args:\n        n (float): Baryon number density in fm^-3.\n        \n    Returns:\n        int: The integer code (1, 2, or 3) for the preferred geometry.\n    \"\"\"\n    u, n_p_in, sigma_n, lambda_e = _get_physical_params(n)\n    \n    min_energies = {}\n    \n    # Iterate through geometries: 3=spheres, 2=cylinders, 1=slabs.\n    for d in [3, 2, 1]:\n        def total_energy(r_N):\n            e_surf = d * sigma_n * u / r_N\n            e_coul = _calculate_coulomb_energy(d, u, n_p_in, lambda_e, r_N)\n            return e_surf + e_coul\n            \n        res = minimize_scalar(\n            total_energy,\n            bounds=(0.5, 30.0),\n            method='bounded'\n        )\n        min_energies[d] = res.fun\n        \n    # Determine the geometry that yields the minimum total energy.\n    preferred_d = min(min_energies, key=min_energies.get)\n    return preferred_d\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite of densities.\n    The results are printed in the specified single-line format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0.01, 0.03, 0.06, 0.09, 0.12, 0.15]\n\n    results = []\n    for n in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        result = _get_preferred_geometry(n)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While simple shapes like spheres and rods provide a good first approximation, nuclear pasta can form far more intricate, triply-periodic structures, such as those resembling a gyroid. These complex topologies can have unique transport properties that are crucial for understanding neutron star phenomena like thermal conductivity and magnetic field evolution. This practice introduces a powerful level-set method to generate these complex shapes and a spectral Fast Fourier Transform (FFT) solver to efficiently calculate their Coulomb energy. You will not only compare the energy of these structures to simpler ones but also investigate the concept of metastability, where a higher-energy phase can persist because it is trapped in a local energy minimum .",
            "id": "3579768",
            "problem": "You are tasked with building a complete, runnable program that, for topology-constrained nuclear pasta candidates, computes a dimensionless energy difference $\\Delta E$ of gyroid-like configurations relative to slabs and rods, and assesses metastability windows. The computational setting must be purely mathematical and self-contained, starting from established energy components relevant to nuclear pasta microstructures in dense matter.\n\nBegin from the following fundamental base, which is standard in liquid-drop inspired modeling of nuclear pasta: the total energy density is modeled as a sum of a surface term and a Coulomb interaction term. The system occupies a periodic cubic domain and admits candidate morphologies generated by analytic, triply periodic functions; topology is constrained by the selected analytic form. All quantities are dimensionless by construction.\n\nLet the periodic cubic domain be $[0,1]^3$ with periodic boundary conditions. Let the spatial grid have $N$ points per axis, uniform spacing $dx = 1/N$, and Cartesian mesh coordinates $\\{x_i\\}$, $\\{y_j\\}$, $\\{z_k\\}$ for $i,j,k \\in \\{0,1,\\dots,N-1\\}$.\n\nFor each candidate morphology, define an underlying scalar field $\\phi(\\mathbf{r})$ via a trigonometric ansatz with integer wavenumber $k \\in \\mathbb{Z}^{+}$, angular frequency $\\omega = 2\\pi k$, and amplitude fixed to unity. The three candidate families are:\n- Slab (lamella, often called “lasagna”): $\\phi_{\\mathrm{slab}}(x,y,z;k) = \\sin(\\omega x)$.\n- Rod (cylindrical array, often called “spaghetti” in an idealized separable surrogate): $\\phi_{\\mathrm{rod}}(x,y,z;k) = \\sin(\\omega x) + \\sin(\\omega y)$.\n- Gyroid-like triply periodic minimal-surface surrogate (nodal gyroid approximation): $\\phi_{\\mathrm{gyro}}(x,y,z;k) = \\sin(\\omega x)\\cos(\\omega y) + \\sin(\\omega y)\\cos(\\omega z) + \\sin(\\omega z)\\cos(\\omega x)$.\n\nFor a specified dense-phase volume fraction $f \\in (0,1)$, define the isosurface threshold $t$ implicitly so that the dense phase is the superlevel set $\\{\\mathbf{r} \\, | \\, \\phi(\\mathbf{r}) \\ge t\\}$ and the volume fraction of this set equals $f$. Numerically, this can be enforced by setting $t$ equal to the $(1-f)$-quantile of the discrete samples of $\\phi$ on the grid.\n\nLet the phase indicator be $h(\\mathbf{r}) = H(\\phi(\\mathbf{r}) - t)$, where $H$ is the Heaviside function $H(u) = 1$ if $u \\ge 0$ and $H(u) = 0$ otherwise. Enforce charge neutrality by defining a dimensionless charge density $\\rho(\\mathbf{r}) = h(\\mathbf{r}) - f$, which has zero spatial mean by construction when the volume fraction constraint is exactly satisfied.\n\nDefine the surface contribution using the level-set surface area formula. The surface area of the isosurface $\\phi(\\mathbf{r}) = t$ is given by\n$$\nA = \\int_{[0,1]^3} \\delta(\\phi(\\mathbf{r}) - t)\\,\\lVert \\nabla \\phi(\\mathbf{r}) \\rVert \\, d^3\\mathbf{r},\n$$\nwhere $\\delta$ is the Dirac delta function. Numerically approximate $\\delta$ by a narrow Gaussian of width $\\varepsilon  0$,\n$$\n\\delta_{\\varepsilon}(u) = \\frac{1}{\\sqrt{\\pi}\\,\\varepsilon} \\exp\\!\\left(-\\frac{u^2}{\\varepsilon^2}\\right),\n$$\nand approximate the gradient by centered finite differences with periodic boundary conditions:\n$$\n\\partial_x \\phi \\approx \\frac{\\phi(x+dx,y,z) - \\phi(x-dx,y,z)}{2\\,dx}, \\quad \\text{and similarly for } \\partial_y, \\partial_z.\n$$\nLet the surface energy coefficient be $a_s  0$. The surface energy density contribution is $E_{\\mathrm{surf}} = a_s\\,A$.\n\nDefine the Coulomb contribution via the electrostatic potential $\\varphi$ that solves the dimensionless Poisson equation with periodic boundary conditions,\n$$\n-\\nabla^2 \\varphi(\\mathbf{r}) = 4\\pi\\,\\rho(\\mathbf{r}),\n$$\nand let $a_c  0$ be a Coulomb coupling prefactor. The Coulomb energy density contribution is\n$$\nE_{\\mathrm{C}} = \\frac{1}{2} a_c \\int_{[0,1]^3} \\rho(\\mathbf{r})\\,\\varphi(\\mathbf{r}) \\, d^3\\mathbf{r}.\n$$\nNumerically, compute $\\varphi$ using a Fast Fourier Transform (FFT) spectral solver: if $\\widehat{\\rho}(\\mathbf{k})$ is the discrete Fourier transform of $\\rho$ and $\\mathbf{k}$ is the wavevector with squared norm $\\lVert \\mathbf{k} \\rVert^2$, then for all nonzero modes,\n$$\n\\widehat{\\varphi}(\\mathbf{k}) = \\frac{4\\pi \\widehat{\\rho}(\\mathbf{k})}{\\lVert \\mathbf{k} \\rVert^2},\n$$\nand set the zero mode to $0$ to enforce neutrality. Recover $\\varphi(\\mathbf{r})$ by inverse FFT and then form the discretized integral.\n\nThe total energy density for a candidate shape at wavenumber $k$ is the sum\n$$\nE_{\\mathrm{tot}}(k; \\text{shape}, f, a_s, a_c, \\varepsilon) = E_{\\mathrm{surf}}(k) + E_{\\mathrm{C}}(k).\n$$\n\nTopology-constrained minimization: for each shape family, minimize $E_{\\mathrm{tot}}$ over the integer wavenumber $k \\in \\{k_{\\min}, k_{\\min}+1, \\dots, k_{\\max}\\}$, holding the analytic family fixed (this enforces the topology constraint). Identify the minimizing $k_{\\star}$ and the minimal energy $E_{\\min}$ for each shape. Assess local curvature at the discrete minimizer with the second finite difference\n$$\nE''(k_{\\star}) \\approx E_{\\mathrm{tot}}(k_{\\star}+1) - 2\\,E_{\\mathrm{tot}}(k_{\\star}) + E_{\\mathrm{tot}}(k_{\\star}-1),\n$$\nprovided $k_{\\star}$ is strictly interior to the search interval, to check for a local minimum.\n\nEnergy differences and metastability: compute the gyroid’s minimal energy $E_{\\min}^{\\mathrm{gyro}}$ and the slab and rod minimal energies $E_{\\min}^{\\mathrm{slab}}$ and $E_{\\min}^{\\mathrm{rod}}$. Define energy differences\n$$\n\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{s}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{slab}}, \\quad\n\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{r}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{rod}}.\n$$\nLet the baseline energy be $E_{\\min}^{\\mathrm{base}} = \\min\\!\\big(E_{\\min}^{\\mathrm{slab}}, E_{\\min}^{\\mathrm{rod}}\\big)$ and define $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{base}}$. For a given nonnegative window parameter $\\delta_{\\max}$, declare the gyroid metastable if all of the following hold: (i) $E''(k_{\\star}^{\\mathrm{gyro}})  0$ (interior local minimum), (ii) $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}}  0$, and (iii) $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}} \\le \\delta_{\\max}$.\n\nAll quantities are dimensionless. Angles are not used. No physical unit conversion is required.\n\nImplement the described computation with the following test suite. For each case, use $N = 32$, $k_{\\min} = 1$, $k_{\\max} = 6$ unless otherwise specified, and report results in the exact output format described below.\n- Case $1$: $f = 0.3$, $a_s = 1.0$, $a_c = 0.1$, $\\varepsilon = 0.03$, $\\delta_{\\max} = 0.05$.\n- Case $2$: $f = 0.5$, $a_s = 0.8$, $a_c = 0.2$, $\\varepsilon = 0.03$, $\\delta_{\\max} = 0.10$.\n- Case $3$: $f = 0.15$, $a_s = 1.2$, $a_c = 0.05$, $\\varepsilon = 0.03$, $\\delta_{\\max} = 0.05$.\n- Case $4$: $f = 0.85$, $a_s = 0.9$, $a_c = 0.25$, $\\varepsilon = 0.03$, $\\delta_{\\max} = 0.10$.\n\nYour program must:\n- For each case, perform topology-constrained minimizations over $k \\in \\{1,2,3,4,5,6\\}$ for the gyroid, slab, and rod families.\n- Compute $E_{\\min}^{\\mathrm{gyro}}$, $E_{\\min}^{\\mathrm{slab}}$, $E_{\\min}^{\\mathrm{rod}}$, $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{s}}$, $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{r}}$, and the metastability boolean as defined above.\n- Produce a single line of output containing a list of per-case results, where each per-case result is itself a list formatted as $[E_{\\min}^{\\mathrm{gyro}}, E_{\\min}^{\\mathrm{slab}}, E_{\\min}^{\\mathrm{rod}}, \\Delta E_{\\mathrm{g}\\text{-}\\mathrm{s}}, \\Delta E_{\\mathrm{g}\\text{-}\\mathrm{r}}, \\text{metastable}]$. Energies are floating-point numbers in dimensionless units; the metastability flag is a boolean.\n\nThe final single-line output must be the top-level list of these per-case lists, in case order, printed with standard Python list syntax, for example $[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$.",
            "solution": "The provided problem is a self-contained, well-posed exercise in computational physics that is scientifically grounded in the established liquid-drop model for nuclear matter. All parameters, equations, and numerical methods are clearly specified, and there are no internal contradictions, ambiguities, or factual errors. The problem is therefore deemed valid and a solution is constructed as follows.\n\nThe core of the task is to compute the total energy density for three families of nuclear pasta morphologies—slabs, rods, and a gyroid-like structure—and to identify the energetically preferred configurations. The total energy density $E_{\\mathrm{tot}}$ is the sum of a surface energy contribution $E_{\\mathrm{surf}}$ and a Coulomb energy contribution $E_{\\mathrm{C}}$. The calculations are performed on a discretized periodic cubic domain $[0,1]^3$.\n\nFirst, we establish the computational grid. The domain is discretized into a uniform mesh of $N \\times N \\times N$ points. The grid spacing is $dx=1/N$. We generate three-dimensional coordinate arrays $(x, y, z)$ using `numpy.meshgrid` with `'ij'` indexing, such that the array indices correspond directly to the spatial dimensions.\n\nFor each morphology family (slab, rod, gyroid), a scalar field $\\phi(\\mathbf{r})$ is defined by a specific trigonometric ansatz. These are given as:\n- Slab: $\\phi_{\\mathrm{slab}}(x,y,z;k) = \\sin(\\omega x)$\n- Rod: $\\phi_{\\mathrm{rod}}(x,y,z;k) = \\sin(\\omega x) + \\sin(\\omega y)$\n- Gyroid-like: $\\phi_{\\mathrm{gyro}}(x,y,z;k) = \\sin(\\omega x)\\cos(\\omega y) + \\sin(\\omega y)\\cos(\\omega z) + \\sin(\\omega z)\\cos(\\omega x)$\nHere, $k \\in \\mathbb{Z}^{+}$ is an integer wavenumber and $\\omega = 2\\pi k$ is the corresponding angular frequency. These fields are evaluated at every point on the 3D grid.\n\nThe system is partitioned into a dense phase and a dilute phase based on the value of $\\phi(\\mathbf{r})$. For a given dense-phase volume fraction $f$, an isosurface threshold $t$ is determined such that the volume of the region where $\\phi(\\mathbf{r}) \\ge t$ is equal to $f$. Numerically, this is robustly achieved by finding the $(1-f)$-quantile of all values of the discrete field $\\phi$ on the grid. A phase indicator field $h(\\mathbf{r})$ is then defined as $h(\\mathbf{r})=1$ for the dense phase ($\\phi(\\mathbf{r}) \\ge t$) and $h(\\mathbf{r})=0$ for the dilute phase. This is implemented using the condition `phi = t`. To ensure overall charge neutrality, a dimensionless charge density $\\rho(\\mathbf{r})$ is defined as $\\rho(\\mathbf{r}) = h(\\mathbf{r}) - f$. By construction, the spatial average of $\\rho(\\mathbf{r})$ over the domain is approximately zero.\n\nThe surface energy density is given by $E_{\\mathrm{surf}} = a_s A$, where $a_s$ is a given coefficient and $A$ is the total surface area of the interface between the two phases within the unit volume. The area is computed from the level-set integral:\n$$\nA = \\int_{[0,1]^3} \\delta(\\phi(\\mathbf{r}) - t)\\,\\lVert \\nabla \\phi(\\mathbf{r}) \\rVert \\, d^3\\mathbf{r}\n$$\nNumerically, this integral is approximated by a sum over the grid cells. The Dirac delta function $\\delta(u)$ is regularized using a narrow Gaussian function $\\delta_{\\varepsilon}(u) = (\\sqrt{\\pi}\\varepsilon)^{-1} \\exp(-u^2/\\varepsilon^2)$ with a small width $\\varepsilon$. The gradient vector $\\nabla\\phi$ is computed at each grid point using a second-order centered finite difference scheme, which is implemented efficiently for the periodic domain using `numpy.roll` to access neighboring grid points. The gradient norm $\\lVert \\nabla \\phi \\rVert$ is then the standard Euclidean norm of its components. The integral is approximated as a discrete sum over all grid points $i$: $A \\approx \\sum_i \\delta_{\\varepsilon}(\\phi_i - t)\\,\\lVert \\nabla \\phi_i \\rVert \\, (dx)^3$.\n\nThe Coulomb energy density $E_{\\mathrm{C}}$ is calculated from the solution of the Poisson equation, $-\\nabla^2 \\varphi(\\mathbf{r}) = 4\\pi\\,\\rho(\\mathbf{r})$, subject to periodic boundary conditions. This is solved efficiently using a spectral method based on the Fast Fourier Transform (FFT).\n1.  Compute the 3D FFT of the charge density, $\\widehat{\\rho}(\\mathbf{k}) = \\mathcal{F}[\\rho(\\mathbf{r})]$.\n2.  Generate the grid of wavevectors $\\mathbf{k}$ corresponding to the discrete Fourier modes. For a grid of size $N$ with spacing $dx=1/N$, the wavevector components are $k_i = 2\\pi m_i$, where the integers $m_i$ are given by `numpy.fft.fftfreq(N)`.\n3.  In Fourier space, the Poisson equation becomes an algebraic equation: $\\lVert \\mathbf{k} \\rVert^2 \\widehat{\\varphi}(\\mathbf{k}) = 4\\pi \\widehat{\\rho}(\\mathbf{k})$.\n4.  The potential in Fourier space is then $\\widehat{\\varphi}(\\mathbf{k}) = 4\\pi \\widehat{\\rho}(\\mathbf{k}) / \\lVert \\mathbf{k} \\rVert^2$ for all non-zero wavevectors $\\mathbf{k} \\neq \\mathbf{0}$. For the zero mode ($\\mathbf{k}=\\mathbf{0}$), we set $\\widehat{\\varphi}(\\mathbf{0})=0$, which enforces charge neutrality and sets the average potential to zero. The division-by-zero for the zero mode is avoided by identifying this mode and treating it separately.\n5.  The real-space potential $\\varphi(\\mathbf{r})$ is recovered by performing an inverse 3D FFT on $\\widehat{\\varphi}(\\mathbf{k})$.\nThe Coulomb energy density is then computed by approximating the integral $E_{\\mathrm{C}} = \\frac{1}{2} a_c \\int \\rho(\\mathbf{r})\\varphi(\\mathbf{r}) \\, d^3\\mathbf{r}$ as a discrete sum over the grid: $E_{\\mathrm{C}} \\approx \\frac{1}{2} a_c \\sum_i \\rho_i \\varphi_i \\, (dx)^3$.\n\nThe total energy $E_{\\mathrm{tot}} = E_{\\mathrm{surf}} + E_{\\mathrm{C}}$ is calculated for each morphology and for each integer wavenumber $k$ in the specified range $\\{k_{\\min}, \\dots, k_{\\max}\\}$. For each morphology, the minimum energy $E_{\\min}$ and the corresponding optimal wavenumber $k_{\\star}$ are found by selecting the minimum value from the computed energies.\n\nFinally, the metastability of the gyroid phase is assessed. The energy differences $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{s}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{slab}}$ and $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{r}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{rod}}$ are computed. A baseline energy $E_{\\min}^{\\mathrm{base}} = \\min(E_{\\min}^{\\mathrm{slab}}, E_{\\min}^{\\mathrm{rod}})$ is established, and the gyroid's energy relative to this baseline is calculated as $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}} = E_{\\min}^{\\mathrm{gyro}} - E_{\\min}^{\\mathrm{base}}$. The gyroid is declared metastable if three conditions are met simultaneously:\n1.  The configuration corresponds to a local minimum with respect to $k$. This is checked by approximating the second derivative $E''(k_{\\star}^{\\mathrm{gyro}})$ with a centered finite difference. The condition is $E''(k_{\\star}^{\\mathrm{gyro}})  0$, which requires that $k_{\\star}^{\\mathrm{gyro}}$ be an interior point of the search range (i.e., $k_{\\min}  k_{\\star}^{\\mathrm{gyro}}  k_{\\max}$).\n2.  The gyroid is not the ground state: $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}}  0$.\n3.  The gyroid's energy is close enough to the ground state, i.e., within a given window: $\\Delta E_{\\mathrm{g}\\text{-}\\mathrm{base}} \\le \\delta_{\\max}$.\n\nThe overall algorithm iterates through each provided test case, performs these calculations for the three morphologies, determines the minimal energies and metastability, and collates the results into the specified list format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_total_energy(shape, k, f, a_s, a_c, epsilon, N):\n    \"\"\"\n    Computes the total energy density for a given morphology.\n    \"\"\"\n    # 1. Grid Setup\n    dx = 1.0 / N\n    coords_1d = np.linspace(0, 1.0, N, endpoint=False)\n    # 'ij' indexing: xx varies along axis 0, yy axis 1, zz axis 2\n    xx, yy, zz = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n\n    # 2. Scalar Field phi Calculation\n    omega = 2.0 * np.pi * k\n    if shape == 'slab':\n        phi = np.sin(omega * xx)\n    elif shape == 'rod':\n        phi = np.sin(omega * xx) + np.sin(omega * yy)\n    elif shape == 'gyro':\n        phi = (np.sin(omega * xx) * np.cos(omega * yy) +\n               np.sin(omega * yy) * np.cos(omega * zz) +\n               np.sin(omega * zz) * np.cos(omega * xx))\n    else:\n        raise ValueError(\"Unknown shape.\")\n\n    # 3. Isosurface Threshold t\n    t = np.quantile(phi, 1.0 - f)\n\n    # 4. Surface Energy E_surf\n    # Gradient of phi using centered differences with periodic boundaries\n    grad_x = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2.0 * dx)\n    grad_y = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * dx)\n    grad_z = (np.roll(phi, -1, axis=2) - np.roll(phi, 1, axis=2)) / (2.0 * dx)\n    \n    grad_phi_norm = np.sqrt(grad_x**2 + grad_y**2 + grad_z**2)\n    \n    # Regularized delta function\n    u_arg = (phi - t) / epsilon\n    delta_eps = (1.0 / (np.sqrt(np.pi) * epsilon)) * np.exp(-u_arg**2)\n    \n    # Surface area integral approximation\n    surface_area = np.sum(delta_eps * grad_phi_norm) * (dx**3)\n    E_surf = a_s * surface_area\n\n    # 5. Coulomb Energy E_C\n    # Phase indicator and charge density\n    h = (phi = t).astype(float)\n    rho = h - f\n\n    # FFT-based Poisson solver\n    rho_hat = np.fft.fftn(rho)\n    \n    # Wavevector grid\n    k_freq = np.fft.fftfreq(N, d=dx)\n    kx, ky, kz = np.meshgrid(k_freq, k_freq, k_freq, indexing='ij')\n    # Physical wavevector, k = 2*pi*f\n    k_sq = (2 * np.pi)**2 * (kx**2 + ky**2 + kz**2)\n    \n    # Solve for potential in Fourier space\n    phi_potential_hat = np.zeros_like(rho_hat, dtype=complex)\n    # Avoid division by zero at k=0\n    nonzero_k = k_sq  1e-9 # A small tolerance for floating point k_sq[0,0,0]\n    phi_potential_hat[nonzero_k] = 4 * np.pi * rho_hat[nonzero_k] / k_sq[nonzero_k]\n\n    # Inverse FFT to get potential in real space\n    phi_potential = np.fft.ifftn(phi_potential_hat).real\n    \n    # Coulomb energy integral approximation\n    E_c = 0.5 * a_c * np.sum(rho * phi_potential) * (dx**3)\n\n    return E_surf + E_c\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (f, a_s, a_c, epsilon, delta_max)\n        (0.3, 1.0, 0.1, 0.03, 0.05),\n        (0.5, 0.8, 0.2, 0.03, 0.10),\n        (0.15, 1.2, 0.05, 0.03, 0.05),\n        (0.85, 0.9, 0.25, 0.03, 0.10),\n    ]\n\n    # Shared parameters\n    N = 32\n    k_min = 1\n    k_max = 6\n    k_range = list(range(k_min, k_max + 1))\n    shapes = ['slab', 'rod', 'gyro']\n    \n    all_results = []\n\n    for case in test_cases:\n        f, a_s, a_c, epsilon, delta_max = case\n        \n        min_energies = {}\n        k_stars = {}\n        all_energies = {}\n\n        for shape in shapes:\n            energies_for_shape = [\n                calculate_total_energy(shape, k, f, a_s, a_c, epsilon, N)\n                for k in k_range\n            ]\n            all_energies[shape] = np.array(energies_for_shape)\n            min_idx = np.argmin(all_energies[shape])\n            min_energies[shape] = all_energies[shape][min_idx]\n            k_stars[shape] = k_range[min_idx]\n\n        E_min_gyro = min_energies['gyro']\n        E_min_slab = min_energies['slab']\n        E_min_rod = min_energies['rod']\n\n        # Energy differences\n        dE_gs = E_min_gyro - E_min_slab\n        dE_gr = E_min_gyro - E_min_rod\n\n        # Metastability check\n        is_metastable = False\n        k_star_gyro = k_stars['gyro']\n\n        # Condition (i): Local minimum (curvature check)\n        is_interior = k_min  k_star_gyro  k_max\n        curvature_check = False\n        if is_interior:\n            idx = k_range.index(k_star_gyro)\n            gyro_energies = all_energies['gyro']\n            E_double_prime = gyro_energies[idx + 1] - 2 * gyro_energies[idx] + gyro_energies[idx - 1]\n            if E_double_prime  0:\n                curvature_check = True\n        \n        # Conditions (ii) and (iii): Energy hierarchy\n        E_min_base = min(E_min_slab, E_min_rod)\n        dE_g_base = E_min_gyro - E_min_base\n        \n        energy_diff_check_1 = dE_g_base  0\n        energy_diff_check_2 = dE_g_base = delta_max\n        \n        if curvature_check and energy_diff_check_1 and energy_diff_check_2:\n            is_metastable = True\n\n        case_result = [\n            E_min_gyro, E_min_slab, E_min_rod,\n            dE_gs, dE_gr,\n            is_metastable\n        ]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    print(str(all_results))\n\nsolve()\n```"
        },
        {
            "introduction": "In computational science, a result is only as reliable as the numerical methods used to obtain it. Before drawing physical conclusions from a simulation, one must demonstrate that the results are independent of unphysical numerical parameters like grid spacing or basis set size. This practice focuses on this crucial process of numerical verification. Using a simplified one-dimensional slab model and a pseudospectral method, you will perform systematic convergence studies to test how the calculated energy per baryon changes with grid resolution, the size of the Fourier basis, and the simulation cell size. This exercise instills the discipline of numerical rigor, teaching you to identify and control the primary sources of error to ensure the credibility of your findings .",
            "id": "3579775",
            "problem": "Consider a simplified one-dimensional planar (slab) model of nuclear pasta in a neutron star crust. The baryon number density is assumed to be spatially periodic along a single Cartesian axis with fundamental period, while the matter is uniform in the transverse directions. The model energy per baryon is built from three well-tested contributions: a bulk nuclear matter contribution, a gradient (surface) contribution, and an electrostatic (Coulomb) contribution with a uniform, charge-neutralizing electron background. You will design a numerical program that computes the energy per baryon for such a configuration using a pseudospectral method, and then performs convergence studies with respect to grid resolution, Fourier basis size, and supercell size. The program must determine, for several specified test configurations, whether the computed energy per baryon is numerically stable to a given tolerance. All energies must be expressed in mega-electron-volts per baryon (MeV), and all lengths in femtometers (fm).\n\nFundamental model ingredients to be used are:\n- Geometry and density ansatz: let the baryon density be periodic with fundamental period $L_{0}$ and given by\n$$\nn(x) \\equiv n_{0} + A_{1}\\cos\\!\\left(\\frac{2\\pi}{L_{0}}x\\right) + A_{2}\\cos\\!\\left(\\frac{4\\pi}{L_{0}}x\\right),\n$$\nwith average density $n_{0}$ and modulation amplitudes $A_{1}$ and $A_{2}$ chosen such that $n(x) \\ge 0$. The proton fraction is uniform and equal to $Y_{p} \\in [0,1]$, hence $n_{p}(x) = Y_{p}\\, n(x)$. The electron number density is taken uniform to ensure global charge neutrality over the fundamental period, $n_{e} = Y_{p}\\, \\langle n \\rangle$, where $\\langle \\cdot \\rangle$ denotes spatial averaging over the domain.\n- Bulk energy density: adopt a compressible liquid drop model quadratic around nuclear saturation,\n$$\n\\varepsilon_{\\text{bulk}}(x) = n(x)\\left[ E_{0} + \\frac{K}{18}\\left(\\frac{n(x) - n_{\\text{sat}}}{n_{\\text{sat}}}\\right)^{2} + S\\,\\left(1 - 2Y_{p}\\right)^{2} \\right],\n$$\nwith constants $E_{0} = -16\\,\\text{MeV}$, $K = 230\\,\\text{MeV}$, $n_{\\text{sat}} = 0.16\\,\\text{fm}^{-3}$, and $S = 30\\,\\text{MeV}$.\n- Gradient energy density: use a surface energy term quadratic in the density gradient,\n$$\n\\varepsilon_{\\nabla}(x) = C_{\\nabla}\\, \\left(\\partial_{x} n(x)\\right)^{2}, \\quad C_{\\nabla} = 50\\,\\text{MeV}\\,\\text{fm}^{5}.\n$$\n- Coulomb energy density: define the electrostatic potential energy per proton $V(x)$ by solving the three-dimensional Poisson equation for a field that depends only on $x$ through its Fourier representation. Using the Coulomb coupling $e^{2} = 1.439964\\,\\text{MeV}\\,\\text{fm}$, the Fourier coefficients of $V$ satisfy\n$$\nV_{k} = \\frac{4\\pi e^{2}}{k^{2}}\\,(n_{p} - n_{e})_{k}, \\quad \\text{for } k \\ne 0, \\quad V_{k=0} = 0,\n$$\nand the Coulomb energy density is\n$$\n\\varepsilon_{C}(x) = \\frac{1}{2}\\,\\big(n_{p}(x) - n_{e}\\big)\\, V(x).\n$$\n\nThe total energy density is $\\varepsilon_{\\text{tot}}(x) = \\varepsilon_{\\text{bulk}}(x) + \\varepsilon_{\\nabla}(x) + \\varepsilon_{C}(x)$. The energy per baryon (in MeV) is defined as\n$$\n\\frac{E}{A} = \\frac{\\langle \\varepsilon_{\\text{tot}} \\rangle}{\\langle n \\rangle}.\n$$\n\nNumerical method requirements:\n- Domain and supercell: compute on a supercell of length $L = m\\,L_{0}$ for positive integer $m$ to test invariance under supercell replication. Periodic boundary conditions must be used.\n- Spectral discretization and basis truncation: discretize the supercell uniformly with $N$ grid points and use the discrete Fourier transform to evaluate spatial derivatives and the Poisson equation. To model a finite Fourier basis, truncate the spectrum by zeroing all Fourier coefficients whose index magnitude exceeds a specified cutoff tied to the base period. Let $K$ denote the maximum number of retained harmonics of the base period $L_{0}$. On the supercell of length $mL_{0}$, this corresponds to retaining modes with discrete frequency index $|j| \\le K\\,m$.\n- Grid-resolution refinement: vary $N$ to test numerical convergence with respect to grid spacing at fixed $K$ and $m$.\n- Basis-size refinement: vary $K$ to test numerical convergence with respect to Fourier basis size at fixed $N$ and $m$.\n- Supercell-size invariance: vary $m$ while keeping the number of grid points per base period constant, that is, $N = m \\times N_{\\text{per-cell}}$, to test invariance of $\\frac{E}{A}$ under supercell replication at fixed $K$.\n\nConvergence criteria:\n- Given a tolerance $\\tau$ (in MeV), declare convergence with respect to grid resolution if the absolute difference between the last two successive $\\frac{E}{A}$ values computed at the two finest grids is less than or equal to $\\tau$ when $K$ and $m$ are fixed at their designated reference values.\n- Declare convergence with respect to basis size if the absolute difference between the last two successive $\\frac{E}{A}$ values computed at the two largest basis sizes is less than or equal to $\\tau$ when $N$ and $m$ are fixed at their designated reference values.\n- Declare supercell invariance if the maximum absolute deviation of $\\frac{E}{A}$ across the chosen supercells from the value at $m=1$ is less than or equal to $\\tau$ when $N$ per base cell and $K$ are held fixed.\n\nYour program must implement the above pseudospectral method and perform the following test suite. For each test case, compute three booleans indicating convergence with respect to $N$, $K$, and $m$, and aggregate them into a single boolean by logical conjunction. Report this single boolean per test case. The four test cases are:\n\n- Case 1 (typical sub-saturation, moderate modulation):\n    - Parameters: $n_{0} = 0.08\\,\\text{fm}^{-3}$, $Y_{p} = 0.3$, $A_{1} = 0.01\\,\\text{fm}^{-3}$, $A_{2} = 0.005\\,\\text{fm}^{-3}$, $L_{0} = 20.0\\,\\text{fm}$, $\\tau = 1\\times 10^{-4}\\,\\text{MeV}$.\n    - Sequences: $N \\in \\{256, 512, 1024\\}$ at fixed $K=8$, $m=1$; $K \\in \\{1, 2, 4, 8\\}$ at fixed $N=1024$, $m=1$; $m \\in \\{1, 2, 3, 4\\}$ at fixed $N_{\\text{per-cell}}=256$ and $K=8$.\n- Case 2 (lower density, weakly modulated):\n    - Parameters: $n_{0} = 0.03\\,\\text{fm}^{-3}$, $Y_{p} = 0.1$, $A_{1} = 0.006\\,\\text{fm}^{-3}$, $A_{2} = 0.0\\,\\text{fm}^{-3}$, $L_{0} = 30.0\\,\\text{fm}$, $\\tau = 5\\times 10^{-5}\\,\\text{MeV}$.\n    - Sequences: $N \\in \\{256, 512, 1024\\}$ at fixed $K=8$, $m=1$; $K \\in \\{1, 2, 4, 8\\}$ at fixed $N=1024$, $m=1$; $m \\in \\{1, 2, 4\\}$ at fixed $N_{\\text{per-cell}}=256$ and $K=8$.\n- Case 3 (stronger modulation, shorter wavelength):\n    - Parameters: $n_{0} = 0.10\\,\\text{fm}^{-3}$, $Y_{p} = 0.2$, $A_{1} = 0.03\\,\\text{fm}^{-3}$, $A_{2} = 0.015\\,\\text{fm}^{-3}$, $L_{0} = 12.0\\,\\text{fm}$, $\\tau = 2\\times 10^{-4}\\,\\text{MeV}$.\n    - Sequences: $N \\in \\{256, 512, 1024\\}$ at fixed $K=8$, $m=1$; $K \\in \\{1, 2, 4, 8\\}$ at fixed $N=1024$, $m=1$; $m \\in \\{1, 3\\}$ at fixed $N_{\\text{per-cell}}=256$ and $K=8$.\n- Case 4 (very low proton fraction):\n    - Parameters: $n_{0} = 0.06\\,\\text{fm}^{-3}$, $Y_{p} = 0.01$, $A_{1} = 0.008\\,\\text{fm}^{-3}$, $A_{2} = 0.004\\,\\text{fm}^{-3}$, $L_{0} = 25.0\\,\\text{fm}$, $\\tau = 1\\times 10^{-6}\\,\\text{MeV}$.\n    - Sequences: $N \\in \\{256, 512, 1024\\}$ at fixed $K=8$, $m=1$; $K \\in \\{1, 2, 4, 8\\}$ at fixed $N=1024$, $m=1$; $m \\in \\{1, 2, 3\\}$ at fixed $N_{\\text{per-cell}}=256$ and $K=8$.\n\nFinal output format:\n- Your program should produce a single line of output containing the four boolean results for Cases $1$ through $4$, in order, as a comma-separated list enclosed in square brackets with no spaces, for example, `[True,False,True,True]`.",
            "solution": "The user has provided a computational physics problem that requires the development of a numerical program to study the energetics of a one-dimensional model for nuclear pasta phases in neutron stars. The task is to validate the problem statement and, if valid, provide a complete numerical solution adhering to the specified format and constraints.\n\n### Step 1: Problem Validation\n\nI will begin by meticulously validating the problem statement.\n\n#### Extraction of Givens\n\n-   **Density Ansatz**: $n(x) = n_{0} + A_{1}\\cos(2\\pi x/L_{0}) + A_{2}\\cos(4\\pi x/L_{0})$, with $n(x) \\ge 0$.\n-   **Proton and Electron Densities**: $n_{p}(x) = Y_{p}n(x)$, $n_{e} = Y_{p}\\langle n \\rangle = Y_p n_0$.\n-   **Bulk Energy Density**: $\\varepsilon_{\\text{bulk}}(x) = n(x)\\left[ E_{0} + \\frac{K}{18}\\left(\\frac{n(x) - n_{\\text{sat}}}{n_{\\text{sat}}}\\right)^{2} + S(1 - 2Y_{p})^{2} \\right]$.\n-   **Gradient Energy Density**: $\\varepsilon_{\\nabla}(x) = C_{\\nabla}(\\partial_{x} n(x))^{2}$.\n-   **Coulomb Energy Density**: $\\varepsilon_{C}(x) = \\frac{1}{2}(n_{p}(x) - n_{e})V(x)$, where $V_k = \\frac{4\\pi e^{2}}{k^{2}}(n_{p} - n_{e})_{k}$ for $k \\ne 0$ and $V_{k=0}=0$.\n-   **Constants**: $E_{0} = -16\\,\\text{MeV}$, $K = 230\\,\\text{MeV}$, $n_{\\text{sat}} = 0.16\\,\\text{fm}^{-3}$, $S = 30\\,\\text{MeV}$, $C_{\\nabla} = 50\\,\\text{MeV}\\,\\text{fm}^{5}$, $e^{2} = 1.439964\\,\\text{MeV}\\,\\text{fm}$.\n-   **Total Energy per Baryon**: $E/A = \\langle \\varepsilon_{\\text{tot}} \\rangle / \\langle n \\rangle$, where $\\varepsilon_{\\text{tot}} = \\varepsilon_{\\text{bulk}} + \\varepsilon_{\\nabla} + \\varepsilon_{C}$.\n-   **Numerical Method**: Pseudospectral method on a supercell $L=mL_0$ with $N$ grid points and periodic boundary conditions.\n-   **Basis Truncation**: Fourier coefficients for modes with discrete frequency index $|j|  Km$ are zeroed, where $K$ is the number of harmonics of the base period $L_0$.\n-   **Convergence Tests**:\n    1.  **Grid Resolution ($N$ convergence)**: $|(E/A)_{N_{\\text{last}}} - (E/A)_{N_{\\text{prev}}}| \\le \\tau$.\n    2.  **Basis Size ($K$ convergence)**: $|(E/A)_{K_{\\text{last}}} - (E/A)_{K_{\\text{prev}}}| \\le \\tau$.\n    3.  **Supercell ($m$ invariance)**: $\\max_m |(E/A)_m - (E/A)_{m=1}| \\le \\tau$.\n-   **Test Suite**: Four specific cases with defined parameters ($n_0, Y_p, A_1, A_2, L_0, \\tau$) and sequences for convergence studies ($N, K, m$ values).\n\n#### Validation Assessment\n\n1.  **Scientifically Grounded**: The problem is grounded in computational nuclear astrophysics, specifically the study of neutron star crusts. The energy density functional is a standard simplified form (liquid-drop type), and the parameter values are physically realistic. The concept of \"nuclear pasta\" and its modeling via periodic structures is a well-established research topic. The problem is scientifically sound.\n2.  **Well-Posed**: All required equations, constants, parameters, and numerical procedures are explicitly defined. The tasks are specified without ambiguity. The condition $n(x) \\ge 0$ is satisfied for all test cases, ensuring physical validity of the density profile. The setup is self-contained and allows for a unique solution to be computed for each part of the test suite.\n3.  **Objective**: The problem is expressed in precise, mathematical language. The criteria for convergence and invariance are quantitative and objective, based on a specified tolerance $\\tau$. No subjective elements are present.\n4.  **No Other Flaws**: The problem does not exhibit any other flaws from the checklist such as being incomplete, contradictory, unrealistic, ill-posed, or trivial. It is a well-formulated, non-trivial problem in computational physics.\n\n#### Verdict\n\nThe problem is **valid**. I will proceed to construct a complete solution.\n\n### Principle-Based Design of the Solution\n\nThe core of the problem is to compute the energy per baryon, $E/A$, for a periodic one-dimensional system using a pseudospectral method. This method combines the efficiency of the Fast Fourier Transform (FFT) for calculating derivatives and solving Poisson's equation with the simplicity of computing non-linear terms in real space.\n\nThe total energy per baryon is the sum of three contributions (bulk, gradient, Coulomb), averaged over the spatial domain, and normalized by the average baryon density $n_0$.\n$$\n\\frac{E}{A} = \\frac{1}{n_{0}} \\left( \\langle\\varepsilon_{\\text{bulk}}\\rangle + \\langle\\varepsilon_{\\nabla}\\rangle + \\langle\\varepsilon_{C}\\rangle \\right)\n$$\n\nThe numerical algorithm for a given configuration ($N, K, m$) is as follows:\n\n1.  **Grid and Basis Setup**: A real-space grid of $N$ points is defined over the supercell of length $L = m L_0$. The corresponding wavevectors $k_q$ are determined. A Fourier-space mask is created to enforce the basis truncation, retaining only modes with a discrete frequency index $|j| \\le K m$.\n\n2.  **Density Representation**: The analytical baryon density $n(x)$ is evaluated on the grid. To work within the specified truncated Fourier basis, $n(x)$ is projected onto this basis. This is achieved by taking its FFT, multiplying by the truncation mask, and then taking the inverse FFT. This yields an effective density, $n_{\\text{eff}}(x)$, which is used for all subsequent calculations. This step correctly models the system as being represented by a finite set of Fourier harmonics, as required by the problem.\n    $$\n    n_{\\text{eff}}(x) = \\text{IFFT}\\left[ \\text{mask} \\times \\text{FFT}[n(x)] \\right]\n    $$\n\n3.  **Bulk Energy Calculation**: The bulk energy density, $\\varepsilon_{\\text{bulk}}$, is a non-linear function of the local density. This term is computed pointwise in real space using the effective density $n_{\\text{eff}}(x)$. The average, $\\langle\\varepsilon_{\\text{bulk}}\\rangle$, is then obtained by a simple numerical mean over the grid points.\n\n4.  **Gradient and Coulomb Energy Calculation**: The gradient and Coulomb energy contributions are quadratic in the density (or density gradient) and are most efficiently and accurately calculated in Fourier space using Parseval's theorem.\n    -   **Gradient Energy**: The average gradient energy is $\\langle\\varepsilon_{\\nabla}\\rangle = C_{\\nabla} \\langle (\\partial_x n_{\\text{eff}})^2 \\rangle$. Using Parseval's theorem, this average can be computed from the Fourier coefficients of $n_{\\text{eff}}(x)$, denoted $\\hat{n}_{\\text{eff}}(k_q)$. The derivative $\\partial_x$ becomes a multiplication by $ik_q$ in Fourier space.\n        $$\n        \\langle\\varepsilon_{\\nabla}\\rangle = \\frac{C_{\\nabla}}{N^2} \\sum_{q} |i k_q \\hat{n}_{\\text{eff}}(k_q)|^2 = \\frac{C_{\\nabla}}{N^2} \\sum_{q} k_q^2 |\\hat{n}_{\\text{eff}}(k_q)|^2\n        $$\n    -   **Coulomb Energy**: The average Coulomb energy is $\\langle\\varepsilon_C\\rangle = \\frac{1}{2} \\langle (n_{p,\\text{eff}}(x) - n_e) V(x) \\rangle$. The potential $V(x)$ is found by solving Poisson's equation, which in Fourier space becomes an algebraic relation: $\\hat{V}(k_q) = \\frac{4\\pi e^2}{k_q^2} (\\widehat{n_{p,\\text{eff}} - n_e})(k_q)$ for $k_q \\ne 0$. Again, using Parseval's theorem, the average energy can be computed directly in Fourier space. Let $\\widehat{\\delta n_{p,\\text{eff}}}$ be the FFT of $n_{p,\\text{eff}}(x) - n_e = Y_p(n_{\\text{eff}}(x) - n_0)$.\n        $$\n        \\langle\\varepsilon_{C}\\rangle = \\frac{1}{2 N^2} \\sum_{q} \\widehat{\\delta n_{p,\\text{eff}}}(k_q) \\cdot \\hat{V}^*(k_q) = \\frac{1}{2 N^2} \\sum_{k_q \\ne 0} \\frac{4\\pi e^2}{k_q^2} |\\widehat{\\delta n_{p,\\text{eff}}}(k_q)|^2\n        $$\n    This Fourier-space evaluation for quadratic terms is a hallmark of pseudospectral methods, avoiding aliasing errors that can arise from evaluating products in real space without sufficient grid resolution (or de-aliasing procedures).\n\n5.  **Convergence Analysis**: The above calculation is encapsulated in a function. This function is then called repeatedly according to the sequences defined for each of the four test cases. The boolean results from the three required checks (convergence in $N$, convergence in $K$, and invariance with $m$) are computed and combined via logical `AND` to produce a single boolean for each case.\n\nThis systematic approach ensures that all aspects of the problem statement are correctly implemented, providing a robust and accurate solution.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_E_per_A(params, N, K, m):\n    \"\"\"\n    Computes the energy per baryon for a given numerical configuration.\n    \"\"\"\n    # Unpack model parameters\n    n0, Yp, A1, A2, L0 = params['n0'], params['Yp'], params['A1'], params['A2'], params['L0']\n    \n    # Unpack physical constants\n    E0, K_const, n_sat, S = -16.0, 230.0, 0.16, 30.0\n    C_nabla, e2 = 50.0, 1.439964\n\n    # 1. Setup Grid and Wavevectors\n    L = m * L0\n    x = np.linspace(0, L, N, endpoint=False)\n    dx = L / N\n    k_wavevector = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # 2. Construct Analytical Density and Project to Truncated Basis\n    k0_L0 = 2 * np.pi / L0\n    n_x = n0 + A1 * np.cos(k0_L0 * x) + A2 * np.cos(2 * k0_L0 * x)\n    \n    n_hat = np.fft.fft(n_x)\n    \n    # Create Fourier basis truncation mask\n    j_indices = np.fft.fftfreq(N) * N\n    mask = np.abs(j_indices) = K * m\n    n_hat_trunc = n_hat * mask\n\n    # 3. Bulk Energy Calculation (in real space)\n    n_x_eff = np.fft.ifft(n_hat_trunc).real\n    \n    bulk_term_n2 = ((n_x_eff - n_sat) / n_sat)**2\n    bulk_term_isospin = S * (1 - 2 * Yp)**2\n    \n    epsilon_bulk_x = n_x_eff * (E0 + (K_const / 18) * bulk_term_n2 + bulk_term_isospin)\n    avg_epsilon_bulk = np.mean(epsilon_bulk_x)\n\n    # 4. Gradient Energy Calculation (in Fourier space via Parseval's theorem)\n    # (dn/dx)^2 = (1/N^2) * sum(k^2 * |n_hat_eff|^2)\n    avg_dn_dx_sq = np.sum(k_wavevector**2 * np.abs(n_hat_trunc)**2) / (N**2)\n    avg_epsilon_nabla = C_nabla * avg_dn_dx_sq\n\n    # 5. Coulomb Energy Calculation (in Fourier space via Parseval's theorem)\n    # The FFT of the effective charge density fluctuation delta_n_p = Yp*(n_eff - n0)\n    # is Yp * n_hat_trunc (for k!=0, as n_hat_trunc[0] corresponds to n0).\n    delta_n_p_hat_eff = Yp * n_hat_trunc\n    \n    avg_epsilon_coulomb = 0.0\n    nonzero_k_mask = k_wavevector != 0\n    k_sq = k_wavevector[nonzero_k_mask]**2\n    delta_n_p_hat_sq_abs = np.abs(delta_n_p_hat_eff[nonzero_k_mask])**2\n    \n    # sum (4*pi*e2/k^2) * |delta_n_p_hat_eff|^2\n    coulomb_sum = np.sum((4 * np.pi * e2 / k_sq) * delta_n_p_hat_sq_abs)\n    \n    # epsilon_C = 0.5 * (1/N^2) * sum\n    avg_epsilon_coulomb = 0.5 * coulomb_sum / (N**2)\n    \n    # 6. Total Energy per Baryon\n    avg_epsilon_total = avg_epsilon_bulk + avg_epsilon_nabla + avg_epsilon_coulomb\n    E_per_A = avg_epsilon_total / n0\n\n    return E_per_A\n\ndef solve():\n    test_cases = [\n        {\n            \"params\": {'n0': 0.08, 'Yp': 0.3, 'A1': 0.01, 'A2': 0.005, 'L0': 20.0},\n            \"tau\": 1e-4,\n            \"N_seq\": ( (256, 512, 1024), {'K': 8, 'm': 1} ),\n            \"K_seq\": ( (1, 2, 4, 8), {'N': 1024, 'm': 1} ),\n            \"m_seq\": ( (1, 2, 3, 4), {'N_per_cell': 256, 'K': 8} )\n        },\n        {\n            \"params\": {'n0': 0.03, 'Yp': 0.1, 'A1': 0.006, 'A2': 0.0, 'L0': 30.0},\n            \"tau\": 5e-5,\n            \"N_seq\": ( (256, 512, 1024), {'K': 8, 'm': 1} ),\n            \"K_seq\": ( (1, 2, 4, 8), {'N': 1024, 'm': 1} ),\n            \"m_seq\": ( (1, 2, 4), {'N_per_cell': 256, 'K': 8} )\n        },\n        {\n            \"params\": {'n0': 0.10, 'Yp': 0.2, 'A1': 0.03, 'A2': 0.015, 'L0': 12.0},\n            \"tau\": 2e-4,\n            \"N_seq\": ( (256, 512, 1024), {'K': 8, 'm': 1} ),\n            \"K_seq\": ( (1, 2, 4, 8), {'N': 1024, 'm': 1} ),\n            \"m_seq\": ( (1, 3), {'N_per_cell': 256, 'K': 8} )\n        },\n        {\n            \"params\": {'n0': 0.06, 'Yp': 0.01, 'A1': 0.008, 'A2': 0.004, 'L0': 25.0},\n            \"tau\": 1e-6,\n            \"N_seq\": ( (256, 512, 1024), {'K': 8, 'm': 1} ),\n            \"K_seq\": ( (1, 2, 4, 8), {'N': 1024, 'm': 1} ),\n            \"m_seq\": ( (1, 2, 3), {'N_per_cell': 256, 'K': 8} )\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        params, tau = case['params'], case['tau']\n        \n        # 1. Grid resolution convergence (N)\n        N_vals, fixed_params_N = case['N_seq']\n        K_fixed, m_fixed = fixed_params_N['K'], fixed_params_N['m']\n        energies_N = [calculate_E_per_A(params, N, K_fixed, m_fixed) for N in N_vals]\n        converged_N = abs(energies_N[-1] - energies_N[-2]) = tau\n\n        # 2. Basis size convergence (K)\n        K_vals, fixed_params_K = case['K_seq']\n        N_fixed, m_fixed = fixed_params_K['N'], fixed_params_K['m']\n        energies_K = [calculate_E_per_A(params, N_fixed, K, m_fixed) for K in K_vals]\n        converged_K = abs(energies_K[-1] - energies_K[-2]) = tau\n\n        # 3. Supercell size invariance (m)\n        m_vals, fixed_params_m = case['m_seq']\n        N_per_cell, K_fixed = fixed_params_m['N_per_cell'], fixed_params_m['K']\n        energies_m = []\n        for m in m_vals:\n            N = m * N_per_cell\n            energies_m.append(calculate_E_per_A(params, N, K_fixed, m))\n        \n        E_at_m1 = energies_m[0]\n        max_dev = 0.0\n        if len(energies_m)  1:\n            max_dev = max([abs(e - E_at_m1) for e in energies_m[1:]])\n        \n        invariant_m = max_dev = tau\n        \n        # Aggregate results\n        final_boolean = converged_N and converged_K and invariant_m\n        results.append(final_boolean)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}