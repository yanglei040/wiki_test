{
    "hands_on_practices": [
        {
            "introduction": "To build a solid foundation, our first practice tackles the BCS gap equation in its most direct form: a system with discrete single-particle energy levels. This is analogous to studying quantum mechanics in a finite basis before moving to a continuum. By setting up and solving the coupled, self-consistent equations for the chemical potential $\\mu$ and the pairing gap $\\Delta$, you will gain hands-on experience with the core machinery of BCS theory, specifically the interplay between number conservation and the emergence of a pairing condensate .",
            "id": "3594622",
            "problem": "You are given an even-even fermionic system at zero temperature modeled by a reduced pairing Hamiltonian with constant pairing strength $G$ acting within an energy window around a reference energy. The single-particle spectrum is discrete, equally spaced, and symmetric about the reference energy, with energies $ \\epsilon_n = n \\delta $ for integer $n$ satisfying $ |\\epsilon_n| \\leq E_c $, where $ \\delta $ is the level spacing and $ E_c $ is the pairing window cutoff. Each level carries a time-reversed (two-fold) degeneracy. The task is to determine the chemical potential $ \\mu $ and the pairing gap $ \\Delta $ that self-consistently describe the system in the zero-temperature mean-field approximation while conserving the specified total particle number $ N $ in the grand-canonical ensemble.\n\nStarting from the reduced pairing model and the zero-temperature mean-field framework for paired fermions, derive the necessary self-consistent conditions that determine the quasiparticle spectrum and occupation amplitudes. From these conditions, formulate the coupled nonlinear equations that determine $ \\mu $ and $ \\Delta $. Your derivation must ensure that the solution respects the constraint on the average particle number $ N $ for an even-even system.\n\nThen, implement a numerical solver for the coupled nonlinear equations for $ \\mu $ and $ \\Delta $ for a set of specified parameter values. You must ensure that the numerical method enforces $ \\Delta  0 $, handles discrete sums over the pairing window $ |\\epsilon_n| \\leq E_c $, and produces a solution even when the non-interacting Fermi level lies close to one of the discrete levels. Provide a robust initial guess and a fallback strategy if needed to ensure convergence.\n\nAll energies must be expressed in mega-electronvolts (MeV). The output values of $ \\mu $ and $ \\Delta $ must be reported in MeV, each rounded to six decimal places.\n\nUse the following test suite of parameter sets $ (\\delta, E_c, G, N) $ in MeV and particle count:\n- Test case 1 (general case): $ \\delta = 0.2 $, $ E_c = 5.0 $, $ G = 0.4 $, $ N = 40 $.\n- Test case 2 (near-empty filling): $ \\delta = 0.5 $, $ E_c = 4.0 $, $ G = 0.6 $, $ N = 2 $.\n- Test case 3 (high filling): $ \\delta = 0.1 $, $ E_c = 3.0 $, $ G = 0.25 $, $ N = 80 $.\n- Test case 4 (small model space, near full): $ \\delta = 0.5 $, $ E_c = 1.0 $, $ G = 0.8 $, $ N = 8 $.\n- Test case 5 (weak pairing): $ \\delta = 0.3 $, $ E_c = 3.0 $, $ G = 0.15 $, $ N = 20 $.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list $ [\\mu, \\Delta] $ with both entries rounded to six decimal places in MeV. For example: $ [[\\mu_1,\\Delta_1],[\\mu_2,\\Delta_2],\\dots] $.\n\nNote: All trigonometric or angular quantities, if any arise in your derivation or numerical method, must be handled in radians. The final numerical answers must be provided as floats in MeV with the specified rounding, and no units or additional text should appear in the output line other than the list structure.",
            "solution": "The user wants to solve for the chemical potential $\\mu$ and pairing gap $\\Delta$ in a simplified Bardeen-Cooper-Schrieffer (BCS) model at zero temperature for an even-even fermionic system. This requires the derivation of the coupled self-consistent BCS equations and their numerical solution.\n\n### Step 1: Theoretical Derivation of the BCS Equations\n\nThe system is described by a reduced pairing Hamiltonian within a specified model space. We work in the grand-canonical ensemble, introducing the chemical potential $\\mu$ to fix the average particle number $N$. The Hamiltonian is $K = H - \\mu N$.\n\nThe pairing Hamiltonian is given by:\n$$\nH = \\sum_{n, \\sigma} \\epsilon_n a_{n\\sigma}^\\dagger a_{n\\sigma} - G \\sum_{n, n'} a_{n\\uparrow}^\\dagger a_{\\bar{n}\\downarrow}^\\dagger a_{\\bar{n}'\\downarrow} a_{n' \\uparrow}\n$$\nwhere $a_{n\\sigma}^\\dagger$ creates a fermion in state $n$ with spin projection $\\sigma$. In the context of nuclei, these represent time-reversed states. Each level $n$ has energy $\\epsilon_n$ and a two-fold degeneracy corresponding to the state $|n\\rangle$ and its time-reversed partner $|\\bar{n}\\rangle$. $G$ is the constant pairing strength.\n\nIn the BCS mean-field approximation, the four-fermion interaction term is linearized. We define the pairing gap parameter $\\Delta$ as:\n$$\n\\Delta = G \\sum_{n'} \\langle a_{\\bar{n}'\\downarrow} a_{n'\\uparrow} \\rangle\n$$\nThe expectation value is taken with respect to the BCS ground state. By choosing a suitable phase, $\\Delta$ can be taken as a real, positive quantity, $\\Delta  0$. The mean-field grand-canonical Hamiltonian $K_{MF} = H_{MF} - \\mu N$ becomes:\n$$\nK_{MF} = \\sum_{n} (\\epsilon_n - \\mu) (a_{n\\uparrow}^\\dagger a_{n\\uparrow} + a_{\\bar{n}\\downarrow}^\\dagger a_{\\bar{n}\\downarrow}) - \\sum_n \\left( \\Delta a_{n\\uparrow}^\\dagger a_{\\bar{n}\\downarrow}^\\dagger + \\Delta a_{\\bar{n}\\downarrow} a_{n\\uparrow} \\right) + \\frac{\\Delta^2}{G}\n$$\nThis Hamiltonian is quadratic in fermion operators and can be diagonalized using the Bogoliubov transformation, which introduces quasiparticle operators $\\alpha$:\n$$\n\\alpha_{n\\uparrow} = u_n a_{n\\uparrow} - v_n a_{\\bar{n}\\downarrow}^\\dagger\n$$\n$$\n\\alpha_{\\bar{n}\\downarrow} = u_n a_{\\bar{n}\\downarrow} + v_n a_{n\\uparrow}^\\dagger\n$$\nThe coefficients $u_n$ and $v_n$ are real and satisfy the normalization condition $u_n^2 + v_n^2 = 1$. This transformation is canonical and diagonalizes $K_{MF}$ into the form:\n$$\nK_{MF} = E_0 + \\sum_n E_n (\\alpha_{n\\uparrow}^\\dagger \\alpha_{n\\uparrow} + \\alpha_{\\bar{n}\\downarrow}^\\dagger \\alpha_{\\bar{n}\\downarrow})\n$$\nwhere $E_0$ is the ground-state energy and $E_n$ is the quasiparticle energy for level $n$:\n$$\nE_n = \\sqrt{(\\epsilon_n - \\mu)^2 + \\Delta^2}\n$$\nThe BCS ground state $|\\Psi_{BCS}\\rangle$ is the vacuum of these quasiparticles, i.e., $\\alpha_{n\\sigma} |\\Psi_{BCS}\\rangle = 0$ for all $n, \\sigma$. The coefficients $u_n$ and $v_n$ are determined by the diagonalization procedure:\n$$\nu_n^2 = \\frac{1}{2} \\left( 1 + \\frac{\\epsilon_n - \\mu}{E_n} \\right)\n$$\n$$\nv_n^2 = \\frac{1}{2} \\left( 1 - \\frac{\\epsilon_n - \\mu}{E_n} \\right)\n$$\nThe coefficient $v_n^2$ represents the probability of the pair state $(n\\uparrow, \\bar{n}\\downarrow)$ being occupied in the ground state, while $u_n^2 = 1 - v_n^2$ is the probability of it being empty.\n\nTwo self-consistent equations are derived from this framework.\n\n**1. The Number Conservation Equation:**\nThe average number of particles $N$ in the ground state is fixed. Each level $n$ can hold two particles (a time-reversed pair). The total particle number is the sum of the occupation probabilities over all levels:\n$$\nN = \\sum_n \\langle a_{n\\uparrow}^\\dagger a_{n\\uparrow} + a_{\\bar{n}\\downarrow}^\\dagger a_{\\bar{n}\\downarrow} \\rangle = \\sum_n (v_n^2 + v_n^2) = \\sum_n 2 v_n^2\n$$\nSubstituting the expression for $v_n^2$:\n$$\nN = \\sum_n 2 \\cdot \\frac{1}{2} \\left( 1 - \\frac{\\epsilon_n - \\mu}{E_n} \\right) = \\sum_n \\left( 1 - \\frac{\\epsilon_n - \\mu}{\\sqrt{(\\epsilon_n - \\mu)^2 + \\Delta^2}} \\right)\n$$\nThis is the first equation, which relates $\\mu$ and $\\Delta$ to the total particle number $N$.\n\n**2. The Gap Equation:**\nThe second equation comes from the self-consistent definition of $\\Delta$. The expectation value $\\langle a_{\\bar{n}'\\downarrow} a_{n'\\uparrow} \\rangle$ can be calculated in the quasiparticle vacuum, yielding $u_{n'}v_{n'}$.\n$$\n\\Delta = G \\sum_{n'} u_{n'}v_{n'}\n$$\nWe can express $u_n v_n$ as:\n$$\nu_n v_n = \\sqrt{u_n^2 v_n^2} = \\sqrt{\\frac{1}{4} \\left( 1 - \\left(\\frac{\\epsilon_n - \\mu}{E_n}\\right)^2 \\right)} = \\sqrt{\\frac{1}{4} \\frac{E_n^2 - (\\epsilon_n - \\mu)^2}{E_n^2}} = \\sqrt{\\frac{\\Delta^2}{4E_n^2}} = \\frac{\\Delta}{2E_n}\n$$\nwhere we have used $\\Delta  0$. Substituting this back into the definition of $\\Delta$:\n$$\n\\Delta = G \\sum_n \\frac{\\Delta}{2E_n}\n$$\nFor a non-trivial pairing solution ($\\Delta  0$), we can divide by $\\Delta$ to obtain the gap equation:\n$$\n1 = \\frac{G}{2} \\sum_n \\frac{1}{E_n} \\implies \\frac{2}{G} = \\sum_n \\frac{1}{\\sqrt{(\\epsilon_n - \\mu)^2 + \\Delta^2}}\n$$\nThis is the second self-consistent equation.\n\nThe summations $\\sum_n$ are over the discrete set of single-particle levels within the pairing window. The levels are given by $\\epsilon_n = n \\delta$ for integer $n$ satisfying $|n\\delta| \\leq E_c$. This implies $n$ ranges from $n_{min} = -\\lfloor E_c/\\delta \\rfloor$ to $n_{max} = \\lfloor E_c/\\delta \\rfloor$.\n\n### Step 2: Numerical Implementation\n\nThe task is to solve the following coupled system of nonlinear equations for the variables $(\\mu, \\Delta)$:\n$$\nf_1(\\mu, \\Delta) = N - \\sum_{n=n_{min}}^{n_{max}} \\left( 1 - \\frac{n\\delta - \\mu}{\\sqrt{(n\\delta - \\mu)^2 + \\Delta^2}} \\right) = 0\n$$\n$$\nf_2(\\mu, \\Delta) = \\frac{2}{G} - \\sum_{n=n_{min}}^{n_{max}} \\frac{1}{\\sqrt{(n\\delta - \\mu)^2 + \\Delta^2}} = 0\n$$\nThis system will be solved using a numerical root-finding algorithm, specifically `scipy.optimize.root`.\n\n**Algorithm Design:**\n1.  **Model Space Definition**: For a given set of parameters $(\\delta, E_c, G, N)$, first determine the range of single-particle levels. The maximum integer index is $n_{max} = \\lfloor E_c/\\delta \\rfloor$. The set of levels is an array of energies $\\epsilon_n = n\\delta$ for $n \\in \\{-n_{max}, -n_{max}+1, \\dots, n_{max}\\}$.\n\n2.  **Equation System**: A Python function is defined that takes a vector `[mu, delta]` and returns the values `[f1(mu, delta), f2(mu, delta)]`. The sums are computed over the pre-calculated array of level energies. Note that the equations depend on $\\Delta^2$. Consequently, if $(\\mu, \\Delta)$ is a solution, so is $(\\mu, -\\Delta)$. The physical pairing gap is positive by convention, so we take the absolute value of the $\\Delta$ found by the solver.\n\n3.  **Initial Guess**: A good initial guess is crucial for the convergence and stability of the root-finding algorithm.\n    *   **For $\\mu$**: The chemical potential $\\mu$ in the paired system is typically close to the Fermi level $\\epsilon_F$ of the non-interacting system. For the given symmetric spectrum, we fill the lowest $N/2$ levels. The last occupied level has index $n_{occ} = N/2 - n_{max} - 1$ and the first unoccupied has index $n_{unocc} = N/2 - n_{max}$. The initial guess $\\mu_0$ is set to the midpoint: $\\mu_0 = (\\epsilon_{n_{occ}} + \\epsilon_{n_{unocc}})/2 = (N/2 - n_{max} - 0.5)\\delta$. This avoids placing $\\mu_0$ exactly on a level, improving robustness.\n    *   **For $\\Delta$**: The pairing strength $G$ itself provides a reasonable order-of-magnitude estimate for the gap $\\Delta$. Thus, we choose an initial guess $\\Delta_0 = G$.\n\n4.  **Solver Execution**: We employ the `scipy.optimize.root` function with the `hybr` method, a well-established and robust algorithm for systems of nonlinear equations. The solver is called with the equation function and the initial guess `[mu_0, delta_0]`. If the primary guess fails to converge, a fallback is implemented by trying a smaller initial guess for the gap, such as $\\Delta_0 = 0.1 G$, to handle cases of weaker pairing.\n\n5.  **Output Formatting**: The final solution vector `[mu, delta]` is extracted. The absolute value of `delta` is taken, and both values are rounded to six decimal places as required. This process is repeated for each test case, and the results are aggregated into the specified list format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Main function to solve the BCS equations for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (delta, Ec, G, N) in MeV and particle count.\n    test_cases = [\n        (0.2, 5.0, 0.4, 40),   # Test case 1 (general case)\n        (0.5, 4.0, 0.6, 2),    # Test case 2 (near-empty filling)\n        (0.1, 3.0, 0.25, 80),  # Test case 3 (high filling)\n        (0.5, 1.0, 0.8, 8),    # Test case 4 (small model space, near full)\n        (0.3, 3.0, 0.15, 20),  # Test case 5 (weak pairing)\n    ]\n\n    results = []\n    for case in test_cases:\n        mu_sol, delta_sol = solve_bcs(*case)\n        results.append([round(mu_sol, 6), round(delta_sol, 6)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_bcs(delta_e, Ec, G, N):\n    \"\"\"\n    Solves the coupled BCS equations for mu and delta for a single parameter set.\n\n    Args:\n        delta_e (float): Single-particle level spacing in MeV.\n        Ec (float): Pairing window cutoff energy in MeV.\n        G (float): Pairing strength in MeV.\n        N (int): Total even number of particles.\n\n    Returns:\n        tuple[float, float]: The solved chemical potential (mu) and pairing gap (delta).\n    \"\"\"\n\n    # 1. Define the model space\n    n_max = int(np.floor(Ec / delta_e))\n    eps_levels = np.arange(-n_max, n_max + 1) * delta_e\n\n    # 2. Define the system of equations for the root finder\n    def bcs_equations(variables):\n        mu, delta_gap = variables\n        \n        # Use delta_gap^2 in equations to handle potential negative values during iteration.\n        delta_gap_sq = delta_gap**2\n        \n        # Add a small epsilon to the denominator to prevent any potential sqrt(0) issues,\n        # though with floating point arithmetic it's highly unlikely.\n        quasiparticle_energies = np.sqrt((eps_levels - mu)**2 + delta_gap_sq)\n\n        # Equation 1: Number conservation\n        # N = sum_{n} (1 - (eps_n - mu) / E_n)\n        # We compute the residual: f1 = N - sum(...)\n        eq1 = N - np.sum(1.0 - (eps_levels - mu) / quasiparticle_energies)\n\n        # Equation 2: Gap equation\n        # 2/G = sum_{n} 1 / E_n\n        # We compute the residual: f2 = 2/G - sum(...)\n        # For G=0 this would be a problem, but G0 in all test cases.\n        eq2 = 2.0 / G - np.sum(1.0 / quasiparticle_energies)\n\n        return [eq1, eq2]\n\n    # 3. Determine a robust initial guess\n    # For mu: non-interacting Fermi level, placed between the last occupied\n    # and first unoccupied levels.\n    mu_0 = (N / 2.0 - n_max - 0.5) * delta_e\n    \n    # For delta: The pairing strength G is a reasonable order-of-magnitude estimate.\n    delta_0 = G\n\n    # 4. Call the solver\n    solution = root(bcs_equations, [mu_0, delta_0], method='hybr', tol=1e-9)\n    \n    # Optional: Implement fallback strategy as mentioned in the problem description.\n    # If the first attempt fails, try a smaller initial delta.\n    if not solution.success:\n        solution = root(bcs_equations, [mu_0, 0.1 * G], method='hybr', tol=1e-9)\n        # If it still fails, the problem might be ill-conditioned. For this problem set,\n        # we assume one of these initial guesses will lead to convergence.\n        if not solution.success:\n            # This indicates a failure to converge, return NaNs or raise an error.\n            # In this contest, the problem is well-posed, so this path is not expected.\n            return (np.nan, np.nan)\n\n    mu_sol, delta_sol = solution.x\n    \n    # 5. Finalize the result\n    # The physical pairing gap Delta is positive. Since the equations depend on Delta^2,\n    # the solver might converge to a negative value. We take the absolute value.\n    delta_sol = abs(delta_sol)\n    \n    # Handle the trivial solution case for weak pairing\n    # if the gap equation cannot be satisfied for any Delta  0.\n    # This can be checked by evaluating the gap equation at Delta=0.\n    # If 2/G  sum(1/|eps-mu|), then Delta=0 is the only solution.\n    # However, the problem formulation implies a paired solution (Delta0) exists.\n    # The numerical value of delta_sol will be very close to zero in this case.\n\n    return mu_sol, delta_sol\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "We now transition from a discrete model to the continuum of momentum space, which is essential for describing uniform nuclear matter. This practice explores how a physically motivated, separable form of the nuclear interaction dramatically simplifies the momentum-dependent gap equation. You will see how this simplification reduces the problem from solving an integral equation for a function $\\Delta(k)$ to solving a single algebraic equation for a scalar gap amplitude $\\Delta$, even yielding an elegant analytical solution in an idealized scenario .",
            "id": "3594578",
            "problem": "Consider homogeneous neutron matter modeled within the Bardeen–Cooper–Schrieffer (BCS) mean-field theory at zero temperature. Focus on spin-singlet $^{1}\\!S_{0}$ pairing in momentum space, where the pairing gap function is defined by the anomalous off-diagonal field through\n$$\n\\Delta(\\mathbf{k}) \\equiv -\\sum_{\\mathbf{k}'} V(\\mathbf{k},\\mathbf{k}') \\,\\langle c_{-\\mathbf{k}'\\downarrow} c_{\\mathbf{k}'\\uparrow} \\rangle,\n$$\nwith $V(\\mathbf{k},\\mathbf{k}')$ the two-body interaction in momentum space, and $c_{\\mathbf{k}\\sigma}$ the fermionic annihilation operator for spin projection $\\sigma$. Let the interaction be separable,\n$$\nV(\\mathbf{k},\\mathbf{k}') = -g\\, f(k)\\, f(k'),\n$$\nwith $g0$ and $f(k)$ a real, nonnegative form factor depending only on the magnitude $k=|\\mathbf{k}|$. Assume uniform matter with chemical potential $\\mu$, single-particle dispersion $\\epsilon_{k}$, and define $\\xi_{k} \\equiv \\epsilon_{k} - \\mu$. Within the BCS framework, diagonalization by a Bogoliubov transformation yields quasiparticle energies\n$$\nE_{k} = \\sqrt{\\xi_{k}^{2} + \\Delta(k)^{2}}.\n$$\n\nTask 1 (Derivation): Starting from the definition of $\\Delta(\\mathbf{k})$ above and the structure of the BCS quasiparticle vacuum, derive that for a separable interaction the gap can be written in the form $\\Delta(k) = \\Delta\\, f(k)$ with a single scalar amplitude $\\Delta$. Show that the corresponding self-consistency reduces to a single scalar nonlinearity for $\\Delta$ involving an integral over $\\xi$ weighted by $f(k)^{2}$ and $E_{k}$.\n\nTask 2 (Closed-form solution under a sharp cutoff): Specialize to a computationally convenient sharp-cutoff model with constant density of states $N(0)$ over a symmetric energy window $|\\xi| \\leq \\omega_{c}$ around the Fermi surface and zero outside, and choose the form factor\n$$\nf(k) = \\Theta\\!\\big(\\omega_{c} - |\\xi_{k}|\\big),\n$$\nwhere $\\Theta$ is the Heaviside step function and $\\omega_{c}0$ is an energy cutoff parameter. Under these assumptions at zero temperature, evaluate the scalar nonlinearity explicitly and obtain a closed-form analytic expression for the gap amplitude $\\Delta$ as a function of $g$, $N(0)$, and $\\omega_{c}$.\n\nTask 3 (Benchmark value): Using your closed-form expression, compute the numerical value of the gap for the parameter choice $g\\,N(0) = 0.30$ and $\\omega_{c} = 10\\,\\text{MeV}$. Round your answer to four significant figures. Express the final gap in MeV.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective, based on the standard framework of BCS theory applied to nuclear matter. The provided definitions and assumptions are consistent and sufficient for a complete solution.\n\n### Task 1 (Derivation)\nThe starting point is the self-consistency equation for the momentum-dependent gap function $\\Delta(\\mathbf{k})$ at zero temperature, given as:\n$$\n\\Delta(\\mathbf{k}) \\equiv -\\sum_{\\mathbf{k}'} V(\\mathbf{k},\\mathbf{k}') \\,\\langle c_{-\\mathbf{k}'\\downarrow} c_{\\mathbf{k}'\\uparrow} \\rangle\n$$\nIn the BCS ground state, the expectation value of the pair annihilation operators, known as the anomalous density or pair amplitude, is given by the product of the Bogoliubov coefficients $u_{k'}$ and $v_{k'}$ corresponding to the state $\\mathbf{k}'$. The standard result is:\n$$\n\\langle c_{-\\mathbf{k}'\\downarrow} c_{\\mathbf{k}'\\uparrow} \\rangle = u_{k'}v_{k'} = \\frac{\\Delta(k')}{2E_{k'}}\n$$\nwhere $E_{k'} = \\sqrt{\\xi_{k'}^{2} + \\Delta(k')^{2}}$ is the quasiparticle energy, and $\\xi_{k'} = \\epsilon_{k'} - \\mu$ is the single-particle energy relative to the chemical potential $\\mu$.\n\nWe substitute this expression and the given separable interaction $V(\\mathbf{k},\\mathbf{k}') = -g\\, f(k)\\, f(k')$ into the definition of $\\Delta(\\mathbf{k})$:\n$$\n\\Delta(\\mathbf{k}) = -\\sum_{\\mathbf{k}'} \\left(-g\\, f(k)\\, f(k')\\right) \\frac{\\Delta(k')}{2E_{k'}}\n$$\n$$\n\\Delta(\\mathbf{k}) = g\\, f(k) \\sum_{\\mathbf{k}'} \\frac{f(k') \\, \\Delta(k')}{2E_{k'}}\n$$\nThis equation has a structure where the right-hand side is the product of $f(k)$ and a term that results from a summation over all states $\\mathbf{k}'$, which is therefore independent of $\\mathbf{k}$. This functional form implies that any solution $\\Delta(\\mathbf{k})$ must be proportional to the form factor $f(k)$. We can therefore make the ansatz:\n$$\n\\Delta(k) = \\Delta \\, f(k)\n$$\nwhere $\\Delta$ is a scalar amplitude, constant with respect to momentum. Substituting this ansatz back into the gap equation:\n$$\n\\Delta \\, f(k) = g \\, f(k) \\sum_{\\mathbf{k}'} \\frac{f(k') \\, (\\Delta \\, f(k'))}{2 E_{k'}}\n$$\nThe quasiparticle energy $E_{k'}$ is now expressed in terms of the scalar amplitude $\\Delta$:\n$$\nE_{k'} = \\sqrt{\\xi_{k'}^{2} + \\Delta(k')^2} = \\sqrt{\\xi_{k'}^{2} + (\\Delta \\, f(k'))^2}\n$$\nSubstituting this into the equation yields:\n$$\n\\Delta \\, f(k) = g \\, f(k) \\sum_{\\mathbf{k}'} \\frac{\\Delta \\, f(k')^2}{2\\sqrt{\\xi_{k'}^{2} + \\Delta^2 f(k')^2}}\n$$\nFor a non-trivial pairing solution where $\\Delta \\neq 0$, and for momenta where $f(k) \\neq 0$, we can divide both sides by $\\Delta f(k)$. This results in a self-consistency equation for the scalar amplitude $\\Delta$:\n$$\n1 = g \\sum_{\\mathbf{k}'} \\frac{f(k')^2}{2\\sqrt{\\xi_{k'}^{2} + \\Delta^2 f(k')^2}}\n$$\nThis equation shows that the problem reduces to solving a single scalar nonlinearity for $\\Delta$. In the continuum limit for a large system, the sum over momentum states $\\mathbf{k}'$ is converted to an integral over energy $\\xi'$, weighted by the density of states (DOS) for a single spin projection, $N(\\xi')$. Assuming the DOS is approximately constant near the Fermi surface, $N(\\xi') \\approx N(0)$, the equation becomes:\n$$\n1 = g \\int d\\xi' \\, N(\\xi') \\, \\frac{f(k(\\xi'))^2}{2\\sqrt{\\xi'^2 + \\Delta^2 f(k(\\xi'))^2}} \\approx \\frac{g N(0)}{2} \\int \\frac{f(k(\\xi'))^2}{\\sqrt{\\xi'^2 + \\Delta^2 f(k(\\xi'))^2}} \\, d\\xi'\n$$\nThis is the desired result for Task 1, demonstrating the reduction to a scalar nonlinearity for $\\Delta$.\n\n### Task 2 (Closed-form solution)\nWe now specialize to the sharp-cutoff model. The assumptions are:\n1.  The density of states $N(0)$ is constant for $|\\xi| \\leq \\omega_{c}$ and zero otherwise.\n2.  The form factor is $f(k) = \\Theta(\\omega_{c} - |\\xi_{k}|)$, which means $f(k(\\xi)) = 1$ for $|\\xi| \\leq \\omega_c$ and $f(k(\\xi)) = 0$ otherwise.\n\nUnder these conditions, the integral in the gap equation is restricted to the interval $[-\\omega_c, \\omega_c]$, and within this interval, $f(k(\\xi))^2 = 1$. The gap equation simplifies to:\n$$\n1 = \\frac{g N(0)}{2} \\int_{-\\omega_c}^{\\omega_c} \\frac{1}{\\sqrt{\\xi^2 + \\Delta^2 \\cdot 1^2}} \\, d\\xi\n$$\nThe integrand is an even function of $\\xi$. We can therefore simplify the integral:\n$$\n1 = \\frac{g N(0)}{2} \\cdot 2 \\int_{0}^{\\omega_c} \\frac{d\\xi}{\\sqrt{\\xi^2 + \\Delta^2}} = g N(0) \\int_{0}^{\\omega_c} \\frac{d\\xi}{\\sqrt{\\xi^2 + \\Delta^2}}\n$$\nThis is a standard integral, whose value is:\n$$\n\\int \\frac{d\\xi}{\\sqrt{\\xi^2 + \\Delta^2}} = \\mathrm{arcsinh}\\left(\\frac{\\xi}{\\Delta}\\right) + C\n$$\nEvaluating the definite integral:\n$$\n\\int_{0}^{\\omega_c} \\frac{d\\xi}{\\sqrt{\\xi^2 + \\Delta^2}} = \\left[\\mathrm{arcsinh}\\left(\\frac{\\xi}{\\Delta}\\right)\\right]_{0}^{\\omega_c} = \\mathrm{arcsinh}\\left(\\frac{\\omega_c}{\\Delta}\\right) - \\mathrm{arcsinh}(0) = \\mathrm{arcsinh}\\left(\\frac{\\omega_c}{\\Delta}\\right)\n$$\nSubstituting this result back into the gap equation gives:\n$$\n1 = g N(0) \\, \\mathrm{arcsinh}\\left(\\frac{\\omega_c}{\\Delta}\\right)\n$$\nTo obtain a closed-form expression for $\\Delta$, we rearrange the equation:\n$$\n\\frac{1}{g N(0)} = \\mathrm{arcsinh}\\left(\\frac{\\omega_c}{\\Delta}\\right)\n$$\nApplying the hyperbolic sine function to both sides:\n$$\n\\sinh\\left(\\frac{1}{g N(0)}\\right) = \\frac{\\omega_c}{\\Delta}\n$$\nFinally, solving for $\\Delta$ yields the desired analytic expression:\n$$\n\\Delta = \\frac{\\omega_c}{\\sinh\\left(\\frac{1}{g N(0)}\\right)}\n$$\n\n### Task 3 (Benchmark value)\nWe use the closed-form expression from Task 2 with the given parameters: $g N(0) = 0.30$ and $\\omega_c = 10\\,\\text{MeV}$.\n$$\n\\Delta = \\frac{10\\,\\text{MeV}}{\\sinh\\left(\\frac{1}{0.30}\\right)} = \\frac{10\\,\\text{MeV}}{\\sinh\\left(\\frac{10}{3}\\right)}\n$$\nWe compute the numerical value:\n$$\n\\frac{1}{0.30} = \\frac{10}{3} \\approx 3.33333\n$$\n$$\n\\sinh\\left(\\frac{10}{3}\\right) \\approx 13.997965\n$$\n$$\n\\Delta \\approx \\frac{10}{13.997965} \\,\\text{MeV} \\approx 0.7143740\\,\\text{MeV}\n$$\nRounding the result to four significant figures, we get:\n$$\n\\Delta \\approx 0.7144\\,\\text{MeV}\n$$",
            "answer": "$$\\boxed{0.7144}$$"
        },
        {
            "introduction": "Our final practice addresses a deep and powerful concept from modern physics: renormalization. When using simplified effective interactions, such as a contact force, our calculations depend on an unphysical momentum cutoff, $\\Lambda$. This exercise guides you through the essential process of renormalization, where the 'bare' interaction strength is adjusted with the cutoff to keep a physical two-body observable, the scattering length, fixed. You will then verify a profound result: the calculated many-body pairing gap becomes independent of the unphysical cutoff, demonstrating how to make robust physical predictions from an effective theory .",
            "id": "3594665",
            "problem": "You are asked to implement and verify the renormalization of a three-dimensional zero-range (contact) interaction in the zero-temperature Bardeen–Cooper–Schrieffer (BCS) theory for a homogeneous Fermi system, using a momentum cutoff. Work exclusively in natural units where $\\hbar = 1$ and $2m = 1$, which implies $\\varepsilon_k = k^2$ and all quantities are dimensionless. In this setting, momenta are measured in inverse lengths, energies in squared momenta, and the $s$-wave scattering length $a_s$ has units of length. The core objective is to fit the bare coupling to a target scattering length and then demonstrate that the resulting BCS gap at the Fermi momentum is independent of the momentum cutoff.\n\nFundamental base and definitions:\n- The contact interaction is defined as $V = -g$, where $g$ is a positive constant to be determined by renormalization.\n- In the two-body sector, the zero-energy on-shell $T$-matrix relates to the scattering length $a_s$ and must be used to fit the cutoff-dependent bare coupling to the target $a_s$ when a sharp momentum cutoff $k \\leq \\Lambda$ is imposed. The derivation must start from the Lippmann–Schwinger equation and the zero-energy scattering amplitude definition; do not use any shortcut formulas.\n- In the many-body sector at zero temperature, the homogeneous isotropic $s$-wave Bardeen–Cooper–Schrieffer (BCS) gap satisfies a self-consistent integral equation over momentum with a sharp cutoff $k \\leq \\Lambda$. The quasiparticle energy is $E_k = \\sqrt{(\\varepsilon_k - \\mu)^2 + \\Delta^2}$ with $\\varepsilon_k = k^2$. The chemical potential $\\mu$ must be set equal to the free Fermi energy $\\varepsilon_F = k_F^2$, appropriate for weak-coupling Fermi systems. The gap parameter $\\Delta$ is momentum-independent for a contact interaction in the $s$-wave channel. The gap equation involves the density-of-states factor in three dimensions.\n\nTasks:\n1) Starting from the Lippmann–Schwinger equation for a zero-range interaction with a sharp momentum cutoff $k \\leq \\Lambda$ at zero energy, derive the relation that expresses the cutoff-dependent bare coupling $g(\\Lambda)$ in terms of the target scattering length $a_s$ in the chosen units.\n2) Using the zero-temperature Bardeen–Cooper–Schrieffer (BCS) gap equation specialized to a contact interaction with sharp cutoff $k \\leq \\Lambda$, implement a numerical solver for $\\Delta$ at fixed Fermi momentum $k_F$, using $\\mu = k_F^2$.\n3) For each test case below, compute the gap $\\Delta$ for each listed cutoff $\\Lambda$ using the $g(\\Lambda)$ obtained from step $1$, and then verify that the set of $\\Delta$ values is invariant with respect to $\\Lambda$ within the specified tolerance. Invariance here means that the maximum relative deviation from the mean gap, $\\max_i \\left|\\Delta_i - \\overline{\\Delta}\\right|/\\overline{\\Delta}$, is less than or equal to the given tolerance.\n\nNumerical and implementation requirements:\n- All calculations must be performed in the units specified above, which are dimensionless in this problem statement.\n- The momentum integral in the Bardeen–Cooper–Schrieffer (BCS) gap equation must be computed with sufficient numerical accuracy. Pay particular attention to the integrable peak in the integrand near $k = k_F$ when $\\Delta$ is small.\n- The root-finding for the gap must be robustly bracketed and converge to $\\Delta  0$.\n- No external input is allowed. All parameters are given below and must be hard-coded.\n\nTest suite:\nFor each test case, you are given $(k_F, a_s, [\\Lambda\\ \\text{values}], \\text{tolerance})$. Compute the gap $\\Delta$ for each $\\Lambda$ in the order listed, then compute the invariance boolean as described above using that tolerance.\n\n- Test case $1$ (happy path): $k_F = 1.0$, $a_s = -0.5$, $\\Lambda \\in \\{2.0, 3.0, 4.0\\}$, tolerance $= 0.05$.\n- Test case $2$ (boundary, low cutoffs): $k_F = 0.75$, $a_s = -1.0$, $\\Lambda \\in \\{1.5, 2.0, 3.0\\}$, tolerance $= 0.08$.\n- Test case $3$ (edge, large cutoffs and weak coupling): $k_F = 1.25$, $a_s = -0.3$, $\\Lambda \\in \\{3.0, 6.0, 9.0\\}$, tolerance $= 0.06$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must concatenate, in order, for each test case: the three computed gaps (as floating-point numbers) in the order of the provided $\\Lambda$ values, followed by a boolean indicating whether invariance holds within the provided tolerance. Therefore, the final output must contain exactly $12$ entries in the following order:\n$[\\Delta^{(1)}(\\Lambda_1), \\Delta^{(1)}(\\Lambda_2), \\Delta^{(1)}(\\Lambda_3), \\text{invariant}^{(1)}, \\Delta^{(2)}(\\Lambda_1), \\Delta^{(2)}(\\Lambda_2), \\Delta^{(2)}(\\Lambda_3), \\text{invariant}^{(2)}, \\Delta^{(3)}(\\Lambda_1), \\Delta^{(3)}(\\Lambda_2), \\Delta^{(3)}(\\Lambda_3), \\text{invariant}^{(3)}]$.",
            "solution": "The problem is assessed to be scientifically grounded, well-posed, objective, and internally consistent. It presents a standard, non-trivial task in computational many-body physics: the renormalization of a contact interaction and its application to the Bardeen–Cooper–Schrieffer (BCS) gap equation. The provided parameters and conditions are physically reasonable and mathematically sound. Therefore, a full solution is warranted.\n\nThe solution is presented in three parts: first, the derivation of the regularized coupling constant, $g(\\Lambda)$; second, the derivation of the BCS gap equation to be solved; and third, the numerical strategy for solving this equation and verifying the required cutoff independence.\n\n**1. Renormalization of the Coupling Constant**\n\nThe relationship between the bare coupling constant $g$ and the physical $s$-wave scattering length $a_s$ is established through the two-body scattering problem. We start with the Lippmann-Schwinger equation for the $T$-matrix in the center-of-mass frame:\n$$ T(E) = V + V G_0(E) T(E) $$\nwhere $V$ is the interaction potential and $G_0(E)$ is the free two-particle propagator. For a zero-range contact interaction, the potential matrix element is momentum-independent, $\\langle \\mathbf{k}' | V | \\mathbf{k} \\rangle = -g$, where $g0$ for an attractive potential. Consequently, the $T$-matrix is also momentum-independent, $T(E)$. The Lippmann-Schwinger equation becomes an algebraic equation for $T(E)$:\n$$ \\frac{1}{T(E)} = -\\frac{1}{g} - \\int \\frac{d^3 q}{(2\\pi)^3} \\frac{1}{E - 2\\varepsilon_q + i\\eta} $$\nIn the specified units where $2m=1$ and $\\hbar=1$, the single-particle energy is $\\varepsilon_q = q^2$. The integral is ultraviolet divergent and is regularized using a sharp momentum cutoff $\\Lambda$:\n$$ \\frac{1}{T(E)} = -\\frac{1}{g(\\Lambda)} - \\int_{q \\le \\Lambda} \\frac{d^3 q}{(2\\pi)^3} \\frac{1}{E - 2q^2 + i\\eta} $$\nThe scattering length $a_s$ is related to the zero-energy on-shell $T$-matrix. A standard convention in low-energy physics, consistent with an attractive potential ($a_s0$) not supporting a bound state, relates the on-shell $T$-matrix to $a_s$ via $T_{phys} = \\frac{4\\pi \\hbar^2 a_s}{m}$. In our units, this gives $T(E=0) = 8\\pi a_s$. Substituting $E=0$ into the equation for $T(E)$:\n$$ \\frac{1}{8\\pi a_s} = -\\frac{1}{g(\\Lambda)} - \\int_0^\\Lambda \\frac{4\\pi q^2 dq}{(2\\pi)^3} \\frac{1}{-2q^2} $$\nEvaluating the integral:\n$$ \\int_0^\\Lambda \\frac{4\\pi q^2 dq}{8\\pi^3} \\frac{1}{-2q^2} = -\\frac{1}{4\\pi^2} \\int_0^\\Lambda dq = -\\frac{\\Lambda}{4\\pi^2} $$\nSubstituting this result back gives:\n$$ \\frac{1}{8\\pi a_s} = -\\frac{1}{g(\\Lambda)} + \\frac{\\Lambda}{4\\pi^2} $$\nSolving for the cutoff-dependent bare coupling constant $1/g(\\Lambda)$:\n$$ \\frac{1}{g(\\Lambda)} = \\frac{\\Lambda}{4\\pi^2} - \\frac{1}{8\\pi a_s} $$\nFor the given test cases, $a_s  0$, which ensures $1/g(\\Lambda)  0$ and thus $g(\\Lambda)  0$, consistent with an attractive interaction required for BCS pairing.\n\n**2. The BCS Gap Equation**\n\nAt zero temperature, the self-consistent BCS gap equation for a momentum-independent gap $\\Delta$ arising from a contact interaction is:\n$$ 1 = g(\\Lambda) \\sum_{\\mathbf{k}}' \\frac{1}{2E_k} $$\nwhere the sum is over momentum states up to the cutoff $\\Lambda$, and $E_k = \\sqrt{(\\varepsilon_k - \\mu)^2 + \\Delta^2}$ is the quasiparticle energy. We are instructed to use the weak-coupling approximation for the chemical potential, $\\mu \\approx \\varepsilon_F = k_F^2$. The sum is converted to an integral:\n$$ \\sum_{\\mathbf{k}}' \\to \\int_{k \\le \\Lambda} \\frac{d^3 k}{(2\\pi)^3} = \\int_0^\\Lambda \\frac{4\\pi k^2 dk}{(2\\pi)^3} = \\frac{1}{2\\pi^2} \\int_0^\\Lambda k^2 dk $$\nThe gap equation becomes:\n$$ 1 = g(\\Lambda) \\frac{1}{2\\pi^2} \\int_0^\\Lambda \\frac{k^2 dk}{2\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\nSolving for $1/g(\\Lambda)$:\n$$ \\frac{1}{g(\\Lambda)} = \\frac{1}{4\\pi^2} \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\nBy equating the two expressions for $1/g(\\Lambda)$ from the two-body and many-body sectors, we obtain a single equation for the gap $\\Delta$:\n$$ \\frac{\\Lambda}{4\\pi^2} - \\frac{1}{8\\pi a_s} = \\frac{1}{4\\pi^2} \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\nMultiplying by $4\\pi^2$ yields the final equation to be solved for $\\Delta$:\n$$ \\Lambda - \\frac{\\pi}{2a_s} = \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\nThis equation relates the many-body observable $\\Delta$ to the two-body observable $a_s$ and the Fermi momentum $k_F$, regularized by the cutoff $\\Lambda$. The core of the problem is to show that the solution $\\Delta$ to this equation is approximately independent of $\\Lambda$ for $\\Lambda \\gg k_F$.\n\n**3. Numerical Strategy**\n\nThe problem of finding $\\Delta$ is now a root-finding problem. We define a function $H(\\Delta)$ such that its root gives the desired gap value:\n$$ H(\\Delta) = \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} - \\Lambda + \\frac{\\pi}{2a_s} $$\nWe need to find $\\Delta  0$ for which $H(\\Delta) = 0$.\nThe properties of $H(\\Delta)$ are analyzed to guide the numerical method:\n- **Monotonicity**: The derivative $\\frac{\\partial H}{\\partial \\Delta} = -\\Delta \\int_0^\\Lambda \\frac{k^2 dk}{[(k^2 - k_F^2)^2 + \\Delta^2]^{3/2}}$ is strictly negative for $\\Delta  0$. Thus, $H(\\Delta)$ is a monotonically decreasing function of $\\Delta$, which guarantees a unique root if one exists.\n- **Asymptotic Behavior**:\n  - As $\\Delta \\to 0^+$, the integral diverges logarithmically at $k=k_F$, so $H(\\Delta \\to 0^+) \\to +\\infty$.\n  - As $\\Delta \\to \\infty$, the integrand approaches $0$, so the integral tends to $0$. Thus, $H(\\Delta \\to \\infty) \\to -\\Lambda + \\frac{\\pi}{2a_s}$. Since $a_s  0$ in all test cases, this limit is always negative.\n\nSince $H(\\Delta)$ is continuous, monotonic, and changes sign from positive to negative over the domain $\\Delta \\in (0, \\infty)$, there must be a unique positive root $\\Delta$.\nThis structure is ideal for a bracketing root-finding algorithm like the Brent-Dekker method. The numerical implementation proceeds as follows:\n1. For each test case $(k_F, a_s, \\Lambda)$, define the function $H(\\Delta)$ as above.\n2. The integral within $H(\\Delta)$ is computed numerically using a robust quadrature routine, `scipy.integrate.quad`. The point $k=k_F$ is a region of rapid change in the integrand, so it is specified as a point of interest to the integrator to improve accuracy.\n3. The root of $H(\\Delta)=0$ is found using `scipy.optimize.root_scalar` with the `brentq` method, which is efficient and reliable for a bracketed, monotonic function. A suitable bracket is found based on the asymptotic analysis, for instance $[\\delta_{min}, \\delta_{max}]$ where $\\delta_{min}$ is a small positive number and $\\delta_{max}$ is on the order of $k_F^2$.\n4. This procedure is repeated for all $\\Lambda$ values within a test case to obtain a set of gap values $\\{\\Delta_i\\}$.\n5. The cutoff invariance is checked by computing the maximum relative deviation from the mean gap, $\\max_i |\\Delta_i - \\overline{\\Delta}| / |\\overline{\\Delta}|$, and comparing it to the specified tolerance.\nThe final program implements this strategy for each test case and formats the output as requested.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the BCS gap equation for a series of test cases and verifies\n    the cutoff independence of the gap parameter.\n    \"\"\"\n    test_cases = [\n        {'kF': 1.0, 'a_s': -0.5, 'Lambdas': [2.0, 3.0, 4.0], 'tolerance': 0.05},\n        {'kF': 0.75, 'a_s': -1.0, 'Lambdas': [1.5, 2.0, 3.0], 'tolerance': 0.08},\n        {'kF': 1.25, 'a_s': -0.3, 'Lambdas': [3.0, 6.0, 9.0], 'tolerance': 0.06},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        kF = case['kF']\n        a_s = case['a_s']\n        Lambdas = case['Lambdas']\n        tolerance = case['tolerance']\n\n        delta_values = []\n        for Lambda in Lambdas:\n            # -------------------------------------------------------------\n            # Define the function H(delta) whose root is the BCS gap.\n            # The equation to solve is H(delta) = 0, where:\n            # H(delta) = integral - (Lambda - pi / (2*a_s)) = 0\n            # -------------------------------------------------------------\n            target_integral_val = Lambda - np.pi / (2.0 * a_s)\n\n            def integrand(k, delta):\n                # The integrand of the gap equation.\n                denominator = np.sqrt((k**2 - kF**2)**2 + delta**2)\n                # Avoid division by zero if delta is exactly zero, although\n                # root finder will use small positive numbers.\n                if denominator == 0:\n                    return np.inf\n                return k**2 / denominator\n\n            def H(delta):\n                # The function to find the root of.\n                \n                # Specify points of interest for the integrator if they are\n                # inside the integration interval. The integrand is sharply\n                # peaked at k=kF.\n                integration_points = []\n                if 0  kF  Lambda:\n                    integration_points.append(kF)\n\n                # Use quad for numerical integration.\n                integral_val, _ = quad(\n                    integrand, 0, Lambda, args=(delta,), points=integration_points\n                )\n                \n                return integral_val - target_integral_val\n\n            # -------------------------------------------------------------\n            # Find the root of H(delta) using a bracketing method.\n            # -------------------------------------------------------------\n            # Based on asymptotic analysis, a root is guaranteed to exist\n            # for delta  0.\n            # Lower bound: a small positive number (delta - 0, H - +inf)\n            delta_min = 1e-8 * kF**2\n            # Upper bound: a value on the scale of the Fermi energy\n            # (delta - inf, H - -inf)\n            delta_max = 5.0 * kF**2\n\n            # Ensure the bracket is valid before calling the solver.\n            # This should not be an issue given the function's monotonic nature.\n            try:\n                if H(delta_max)  0:\n                    # The chosen upper bound is too small, increase it.\n                    # This is unlikely but handled for robustness.\n                    delta_max *= 10\n            except (ValueError, OverflowError):\n                 delta_max *= 10\n                 \n            # Find the root using Brent's method.\n            sol = root_scalar(H, bracket=[delta_min, delta_max], method='brentq')\n            delta_values.append(sol.root)\n        \n        # -------------------------------------------------------------\n        # Verify the invariance of the calculated gap values.\n        # -------------------------------------------------------------\n        mean_delta = np.mean(delta_values)\n        if mean_delta == 0:\n            # This case is unlikely, but if it happens, deviation is 0.\n            max_rel_dev = 0.0\n        else:\n            deviations = np.abs(np.array(delta_values) - mean_delta)\n            max_rel_dev = np.max(deviations) / np.abs(mean_delta)\n        \n        is_invariant = max_rel_dev = tolerance\n\n        # Append the results for this test case to the final list.\n        results.extend(delta_values)\n        results.append(is_invariant)\n\n    # Final print statement in the exact required format.\n    # Format: [d_11, d_12, d_13, inv_1, d_21, d_22, d_23, inv_2, ...]\n    formatted_results = []\n    for item in results:\n        if isinstance(item, bool):\n            formatted_results.append(str(item).lower())\n        else:\n            formatted_results.append(f\"{item:.10f}\") # Use sufficient precision\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}