{
    "hands_on_practices": [
        {
            "introduction": "对核旋转最简单的描述是刚性转子模型。这项练习将引导你从基础的经典力学出发，推导转动动能的张量表达式，并探讨为何此模型适用于具有稳定形变的原子核。通过连接经典图像与核物理背景，这项练习旨在巩固你对集体转动基本概念的理解。",
            "id": "3606569",
            "problem": "一个刚体由 $N$ 个质点 $m_{k}$ 组成，这些质点相对于一个固联系的坐标系具有固定的位置 $\\mathbf{r}_{k}$，该坐标系的轴由质量分布的主方向定义。该刚体以角速度矢量 $\\boldsymbol{\\omega}$（单位为弧度/秒）进行纯转动。从牛顿定律和质点系动能的定义出发，推导刚体转动动能的一般张量表达式，该表达式用 $\\boldsymbol{\\omega}$ 和由 $\\{m_{k}, \\mathbf{r}_{k}\\}$ 构建的惯性张量表示。\n\n然后，考虑一个具有稳定四极形变的偶偶核，它可以近似为一个刚性转子，其绕固联系主轴的转动惯量分别为 $I_{1} = 3.6 \\times 10^{-54} \\text{ kg}\\cdot\\text{m}^{2}$、$I_{2} = 4.0 \\times 10^{-54} \\text{ kg}\\cdot\\text{m}^{2}$ 和 $I_{3} = 4.4 \\times 10^{-54} \\text{ kg}\\cdot\\text{m}^{2}$。假设该原子核沿主轴转动的角速度分量为 $\\omega_{1} = 0.70 \\times 10^{20} \\text{ rad/s}$、$\\omega_{2} = 0.50 \\times 10^{20} \\text{ rad/s}$ 和 $\\omega_{3} = 0.60 \\times 10^{20} \\text{ rad/s}$。计算其转动动能，并用兆电子伏（MeV）表示最终能量。使用换算关系 $1 \\text{ MeV} = 1.602176634 \\times 10^{-13} \\text{ J}$。将答案四舍五入到四位有效数字。\n\n最后，通过诉诸第一性原理的考虑，如刚性所隐含的约束、时间尺度的分离以及多体系统中的集体运动，来证明为何刚性转子近似适用于具有稳定四极形变的原子核。你的论证应基于物理推理，而不引用特定模型的公式。",
            "solution": "问题包含三个部分：一个推导，一个计算和一个概念性论证。每个部分将按顺序进行阐述。\n\n**第一部分：转动动能张量表达式的推导**\n\n我们从由 $N$ 个质点 $m_k$（速度为 $\\mathbf{v}_k$）组成的系统的总动能 $T$ 的定义开始。\n$$T = \\sum_{k=1}^{N} \\frac{1}{2} m_k \\mathbf{v}_k^2 = \\sum_{k=1}^{N} \\frac{1}{2} m_k (\\mathbf{v}_k \\cdot \\mathbf{v}_k)$$\n对于一个绕某固定点（我们将其作为固联系坐标系的原点）以角速度 $\\boldsymbol{\\omega}$ 进行纯转动的刚体，位于位置 $\\mathbf{r}_k$ 的第 $k$ 个质点的速度 $\\mathbf{v}_k$ 由叉乘给出：\n$$\\mathbf{v}_k = \\boldsymbol{\\omega} \\times \\mathbf{r}_k$$\n将此代入动能表达式，得到：\n$$T = \\sum_{k=1}^{N} \\frac{1}{2} m_k (\\boldsymbol{\\omega} \\times \\mathbf{r}_k) \\cdot (\\boldsymbol{\\omega} \\times \\mathbf{r}_k)$$\n我们使用标量三重积的矢量恒等式，也称为 Lagrange 恒等式：$(\\mathbf{A} \\times \\mathbf{B}) \\cdot (\\mathbf{C} \\times \\mathbf{D}) = (\\mathbf{A} \\cdot \\mathbf{C})(\\mathbf{B} \\cdot \\mathbf{D}) - (\\mathbf{A} \\cdot \\mathbf{D})(\\mathbf{B} \\cdot \\mathbf{C})$。在我们的情况下，$\\mathbf{A} = \\mathbf{C} = \\boldsymbol{\\omega}$ 且 $\\mathbf{B} = \\mathbf{D} = \\mathbf{r}_k$。\n$$(\\boldsymbol{\\omega} \\times \\mathbf{r}_k) \\cdot (\\boldsymbol{\\omega} \\times \\mathbf{r}_k) = (\\boldsymbol{\\omega} \\cdot \\boldsymbol{\\omega})(\\mathbf{r}_k \\cdot \\mathbf{r}_k) - (\\boldsymbol{\\omega} \\cdot \\mathbf{r}_k)(\\boldsymbol{\\omega} \\cdot \\mathbf{r}_k) = \\omega^2 r_k^2 - (\\boldsymbol{\\omega} \\cdot \\mathbf{r}_k)^2$$\n这里，$\\omega = |\\boldsymbol{\\omega}|$ 且 $r_k = |\\mathbf{r}_k|$。动能变为：\n$$T = \\frac{1}{2} \\sum_{k=1}^{N} m_k \\left[ \\omega^2 r_k^2 - (\\boldsymbol{\\omega} \\cdot \\mathbf{r}_k)^2 \\right]$$\n为了得到张量形式，我们用笛卡尔分量来表示。设 $\\boldsymbol{\\omega} = (\\omega_1, \\omega_2, \\omega_3)$ 和 $\\mathbf{r}_k = (x_{k,1}, x_{k,2}, x_{k,3})$。\n则 $\\omega^2 = \\sum_{i=1}^{3} \\omega_i^2$，$r_k^2 = \\sum_{j=1}^{3} x_{k,j}^2$，以及 $\\boldsymbol{\\omega} \\cdot \\mathbf{r}_k = \\sum_{j=1}^{3} \\omega_j x_{k,j}$。\n求和号内的表达式为：\n$$m_k \\left[ \\left(\\sum_{i=1}^{3} \\omega_i^2 \\right) \\left(\\sum_{j=1}^{3} x_{k,j}^2 \\right) - \\left(\\sum_{i=1}^{3} \\omega_i x_{k,i} \\right) \\left(\\sum_{j=1}^{3} \\omega_j x_{k,j} \\right) \\right]$$\n使用克罗内克 δ 符号 $\\delta_{ij}$，我们可以写成 $\\sum_{i} \\omega_i^2 = \\sum_{i,j} \\omega_i \\omega_j \\delta_{ij}$。\n$$T = \\frac{1}{2} \\sum_{k=1}^{N} m_k \\left[ \\left(\\sum_{i,j} \\omega_i \\omega_j \\delta_{ij} \\right) \\left(\\sum_{l} x_{k,l}^2 \\right) - \\sum_{i,j} \\omega_i \\omega_j x_{k,i} x_{k,j} \\right]$$\n我们可以交换求和的顺序：\n$$T = \\frac{1}{2} \\sum_{i,j} \\left[ \\sum_{k=1}^{N} m_k \\left( \\delta_{ij} \\sum_{l=1}^{3} x_{k,l}^2 - x_{k,i} x_{k,j} \\right) \\right] \\omega_i \\omega_j$$\n方括号中的项是惯性张量 $\\mathbf{I}$ 的第 $(i,j)$ 个分量：\n$$I_{ij} = \\sum_{k=1}^{N} m_k (r_k^2 \\delta_{ij} - x_{k,i} x_{k,j})$$\n其中 $r_k^2 = x_{k,1}^2 + x_{k,2}^2 + x_{k,3}^2$。\n因此，转动动能的一般张量表达式为：\n$$T = \\frac{1}{2} \\sum_{i,j=1}^{3} I_{ij} \\omega_i \\omega_j$$\n在矩阵表示法中，这写作 $T = \\frac{1}{2} \\boldsymbol{\\omega}^T \\mathbf{I} \\boldsymbol{\\omega}$，其中 $\\boldsymbol{\\omega}$ 是角速度分量的列向量，$\\mathbf{I}$ 是 $3 \\times 3$ 的惯性张量矩阵。\n\n**第二部分：原子核动能的计算**\n\n问题指明，固联系坐标轴是质量分布的主轴。在主轴坐标系中，惯性张量 $\\mathbf{I}$ 是对角的。其分量为 $I_{ij} = I_i \\delta_{ij}$，其中 $I_1$、$I_2$ 和 $I_3$ 是主转动惯量。动能的一般表达式简化为：\n$$T = \\frac{1}{2} \\sum_{i,j=1}^{3} (I_i \\delta_{ij}) \\omega_i \\omega_j = \\frac{1}{2} \\sum_{i=1}^{3} I_i \\omega_i^2$$\n$$T = \\frac{1}{2} (I_1 \\omega_1^2 + I_2 \\omega_2^2 + I_3 \\omega_3^2)$$\n我们已知以下数值：\n$I_{1} = 3.6 \\times 10^{-54} \\text{ kg}\\cdot\\text{m}^{2}$\n$I_{2} = 4.0 \\times 10^{-54} \\text{ kg}\\cdot\\text{m}^{2}$\n$I_{3} = 4.4 \\times 10^{-54} \\text{ kg}\\cdot\\text{m}^{2}$\n$\\omega_{1} = 0.70 \\times 10^{20} \\text{ rad/s}$\n$\\omega_{2} = 0.50 \\times 10^{20} \\text{ rad/s}$\n$\\omega_{3} = 0.60 \\times 10^{20} \\text{ rad/s}$\n\n我们以国际单位制（焦耳）计算每一项：\n$I_1 \\omega_1^2 = (3.6 \\times 10^{-54}) (0.70 \\times 10^{20})^2 = (3.6 \\times 10^{-54}) (0.49 \\times 10^{40}) = 1.764 \\times 10^{-14} \\text{ J}$\n$I_2 \\omega_2^2 = (4.0 \\times 10^{-54}) (0.50 \\times 10^{20})^2 = (4.0 \\times 10^{-54}) (0.25 \\times 10^{40}) = 1.000 \\times 10^{-14} \\text{ J}$\n$I_3 \\omega_3^2 = (4.4 \\times 10^{-54}) (0.60 \\times 10^{20})^2 = (4.4 \\times 10^{-54}) (0.36 \\times 10^{40}) = 1.584 \\times 10^{-14} \\text{ J}$\n\n总和为：\n$\\sum_{i=1}^{3} I_i \\omega_i^2 = (1.764 + 1.000 + 1.584) \\times 10^{-14} = 4.348 \\times 10^{-14} \\text{ J}$\n\n动能为：\n$T = \\frac{1}{2} (4.348 \\times 10^{-14} \\text{ J}) = 2.174 \\times 10^{-14} \\text{ J}$\n\n最后，我们使用给定的换算因子 $1 \\text{ MeV} = 1.602176634 \\times 10^{-13} \\text{ J}$ 将能量转换为兆电子伏（MeV）。\n$$T_{\\text{MeV}} = \\frac{2.174 \\times 10^{-14} \\text{ J}}{1.602176634 \\times 10^{-13} \\text{ J/MeV}} \\approx 0.1356900 \\text{ MeV}$$\n按要求四舍五入到四位有效数字，我们得到：\n$T_{\\text{MeV}} = 0.1357 \\text{ MeV}$\n\n**第三部分：刚性转子近似的合理性论证**\n\n将刚性转子模型应用于像原子核这样的量子多体系统，特别是具有稳定四极形变的原子核，其适用性基于几个源于第一性原理考虑的关键物理原则。\n\n首先，**集体运动**的概念是核心。在原子核中，并非所有激发都涉及将单个核子提升到更高的能态（单粒子激发）。某些低能态是由许多核子的相干、同相运动产生的。对于非球对称的原子核，例如那些具有稳定长椭球或扁椭球四极形变的原子核，整个原子核可以作为一个整体旋转。这种形变核的集体转动产生了一系列的激发态能带，这正是刚性转子模型所要描述的现象。\n\n其次，**刚性**的概念源于核子间的强关联。经典的刚体其组分之间的距离是固定的。原子核并非严格的刚体；其组成核子在平均场势中不断运动。然而，对于一个具有稳定形变的原子核，强核力创造了一个具有明确平均形状的自束缚系统。改变这个形状（振动激发）或打破核子间配对关联所需的能量，显著高于形状自身缓慢转动相关的能量。这种在转动过程中抵抗形变和内部重排的“刚度”使得原子核可以被近似为一个刚体。\n\n第三，该模型的有效性关键取决于**时间尺度和能量尺度的分离**。对于不同类型的核运动，存在一个明确的特征时间层级。\n1.  **单粒子运动：** 核子在原子核内部快速运动。其时间尺度 $\\tau_{sp}$ 约为一个核子穿过原子核所需的时间。这对应于最高的能量尺度 $E_{sp}$。\n2.  **振动运动：** 核表面围绕其平衡形状的振荡发生在较慢的时间尺度 $\\tau_{vib}$ 上，对应于较低的能量尺度 $E_{vib}$。\n3.  **转动运动：** 形变核作为一个整体的集体转动是最慢的运动，发生的时间尺度为 $\\tau_{rot}$，并对应于最低的能量尺度 $E_{rot}$。\n\n这种 $E_{rot} \\ll E_{vib} \\ll E_{sp}$ 因而 $\\tau_{rot} \\gg \\tau_{vib} \\gg \\tau_{sp}$ 的层级关系至关重要。因为转动远慢于内部运动，原子核在一次转动期间可以经历多次内部重排和形状振动。从缓慢转动的角度来看，快速的内部动力学被平均掉了，呈现出一个具有明确转动惯量的有效稳定的形变体。这种绝热分离允许人们将转动自由度与内禀和振动自由度解耦，从而证明了对于最低的集体激发态，将原子核处理为简单的刚性转子是合理的。",
            "answer": "$$\\boxed{0.1357}$$"
        },
        {
            "introduction": "“回弯”(backbending)现象是原子核在转动下发生结构改变的关键标志。这项练习提供了一个计算实验，让你运用一个简化的双带混合模型来模拟这一现象，该模型基于曲柄Hartree–Fock–Bogoliubov (HFB) 框架。通过此实践，你将亲身体验如何使用曲柄模型研究粒子排列、带交叉，并理解运动学转动惯量 $\\mathcal{J}^{(1)}$ 和动力学转动惯量 $\\mathcal{J}^{(2)}$ 的物理意义。",
            "id": "3550162",
            "problem": "考虑一个简化的、用于描述形变核中集体转动运动的双带阻塞摇摆Hartree–Fock–Bogoliubov (HFB) 模型。目的是模拟特定Nilsson轨道在转动下的排列，并计算穿越带交叉区域时运动学转动惯量和动力学转动惯量的变化。\n\n您将基于摇摆方法和一个二能级混合哈密顿量，在转动参考系中实现一个最小化的自洽模型。该模型由以下要素定义：\n\n1. 摇摆方法引入了转动参考系哈密顿量 $H' = H - \\omega \\hat{J}$，其中 $\\omega$ 是以 $\\mathrm{MeV}/\\hbar$ 为单位的转动频率，$H$ 是实验室参考系哈密顿量，$\\hat{J}$ 是角动量算符。\n\n2. 核芯的转动能被建模为一个经典的刚性转子，其能量为 $E_{\\text{core}}(\\omega) = \\tfrac{1}{2} \\mathcal{J}\\,\\omega^2$，其中 $\\mathcal{J}$ 是以 $\\hbar^2/\\mathrm{MeV}$ 为单位的核芯转动惯量。在转动参考系中，相应的Routhian贡献为 $E_{\\text{core}}'(\\omega) = E_{\\text{core}}(\\omega) - \\omega J_{\\text{core}}(\\omega)$。对于刚性转子，使用 $J_{\\text{core}}(\\omega) = \\mathcal{J}\\,\\omega$，可得 $E_{\\text{core}}'(\\omega) = -\\tfrac{1}{2}\\,\\mathcal{J}\\,\\omega^2$。\n\n3. 具有排列角动量 $i_a$（以 $\\hbar$ 为单位）的特定Nilsson轨道的排列，被建模为对Routhian的额外贡献 $E_{\\text{align}}'(\\omega) = E_{\\text{align}} - \\omega\\,i_a$，其中 $E_{\\text{align}}$（以 $\\mathrm{MeV}$ 为单位）是与创建排列准粒子组态相关的内禀能量代价。\n\n4. 在Hartree–Fock–Bogoliubov (HFB) 中的阻塞（blocking）意味着一个准粒子被占据，这会减弱对关联并增加有效转动惯量。我们通过排列带核芯转动惯量的分数增加 $\\alpha \\ge 0$ 来参数化此效应。因此，未排列（A）带的核芯转动惯量为 $\\mathcal{J}_A = \\mathcal{J}_0$，而排列（B）带的为 $\\mathcal{J}_B = \\mathcal{J}_0\\,(1+\\alpha)$，其中 $\\mathcal{J}_0$ 以 $\\hbar^2/\\mathrm{MeV}$ 为单位。\n\n5. 双带转动参考系的Routhian为\n$$\nE_A'(\\omega) = -\\tfrac{1}{2}\\,\\mathcal{J}_0\\,\\omega^2,\n\\qquad\nE_B'(\\omega) = E_{\\text{align}} - \\omega\\,i_a - \\tfrac{1}{2}\\,\\mathcal{J}_0(1+\\alpha)\\,\\omega^2.\n$$\n\n6. 两种组态之间的相互作用由一个恒定的混合矩阵元 $V$（以 $\\mathrm{MeV}$ 为单位）建模。得到的 $2\\times 2$ 转动参考系哈密顿量为\n$$\nH'(\\omega) =\n\\begin{pmatrix}\nE_A'(\\omega) & V \\\\\nV & E_B'(\\omega)\n\\end{pmatrix}.\n$$\n基态Routhian $E'_-(\\omega)$ 是通过对角化 $H'(\\omega)$ 得到的较低本征值。\n\n7. 总角动量期望值作为转动频率的函数，可根据摇摆定义得出：\n$$\nI(\\omega) = -\\frac{dE'_-(\\omega)}{d\\omega}.\n$$\n\n8. 运动学转动惯量和动力学转动惯量定义为\n$$\n\\mathcal{J}^{(1)}(\\omega) = \\frac{I(\\omega)}{\\omega},\n\\qquad\n\\mathcal{J}^{(2)}(\\omega) = \\frac{dI(\\omega)}{d\\omega}.\n$$\n$\\mathcal{J}^{(1)}$ 和 $\\mathcal{J}^{(2)}$ 的单位均为 $\\hbar^2/\\mathrm{MeV}$。\n\n9. 绝热交叉频率（即两个未混合的带将要交叉的频率）通过求解 $E_A'(\\omega) = E_B'(\\omega)$ 关于 $\\omega$ 的方程来定义。这得到一个二次方程\n$$\n\\frac{1}{2}\\,\\mathcal{J}_0\\,\\alpha\\,\\omega^2 + i_a\\,\\omega - E_{\\text{align}} = 0,\n$$\n对于 $\\alpha > 0$，其物理相关的解为\n$$\n\\omega_c = \\frac{-i_a + \\sqrt{i_a^2 + 2\\,\\mathcal{J}_0\\,\\alpha\\,E_{\\text{align}}}}{\\mathcal{J}_0\\,\\alpha}.\n$$\n对于 $\\alpha = 0$，使用 $\\omega_c = E_{\\text{align}}/i_a$。\n\n10. 对于给定物理量 $Q(\\omega)$（$\\mathcal{J}^{(1)}$ 或 $\\mathcal{J}^{(2)}$），穿越交叉区域的变化定义为\n$$\n\\Delta Q = \\langle Q(\\omega)\\rangle_{\\text{post}} - \\langle Q(\\omega)\\rangle_{\\text{pre}},\n$$\n其中 $\\langle\\cdot\\rangle_{\\text{pre}}$ 是交叉点正下方一个频率窗口内的平均值，而 $\\langle\\cdot\\rangle_{\\text{post}}$ 是交叉点正上方一个窗口内的平均值。使用半宽为 $w$ 的对称窗口，并排除 $\\omega_c$ 周围一个大小为 $\\varepsilon$ 的小邻域，以避免直接的混合区域：\n$$\n\\text{pre-window}:\\ \\omega \\in [\\omega_c - w,\\ \\omega_c - \\varepsilon],\\quad\n\\text{post-window}:\\ \\omega \\in [\\omega_c + \\varepsilon,\\ \\omega_c + w].\n$$\n\n您的程序必须：\n\n- 使用上述模型，在均匀频率网格上构建 $H'(\\omega)$。\n- 在每个网格点上对角化 $H'(\\omega)$ 以获得 $E'_-(\\omega)$。\n- 使用有限差分法，通过对 $E'_-(\\omega)$ 关于 $\\omega$ 进行数值微分来计算 $I(\\omega)$。\n- 使用上述定义计算 $\\mathcal{J}^{(1)}(\\omega)$ 和 $\\mathcal{J}^{(2)}(\\omega)$。\n- 使用指定的窗口计算穿越交叉区域的变化量 $\\Delta \\mathcal{J}^{(1)}$ 和 $\\Delta \\mathcal{J}^{(2)}$。\n\n单位与约定：\n\n- $\\omega$ 以 $\\mathrm{MeV}/\\hbar$ 表示，能量以 $\\mathrm{MeV}$ 表示，角动量以 $\\hbar$ 表示，$\\mathcal{J}^{(1)}$、$\\mathcal{J}^{(2)}$ 以 $\\hbar^2/\\mathrm{MeV}$ 表示。\n- 对 $\\omega$ 求导时隐式使用弧度；无需指定角度单位。\n\n频率网格与窗口：\n\n- 使用频率网格 $\\omega \\in [\\omega_{\\min}, \\omega_{\\max}]$，步长为 $\\Delta\\omega$，其中 $\\omega_{\\min} > 0$ 以避免在计算 $\\mathcal{J}^{(1)}(\\omega)$ 时出现除以零的错误。\n- 使用上面定义的对称窗口，参数为 $w$ 和 $\\varepsilon$。\n\n测试套件：\n\n实现程序以评估以下参数集，每个参数集以元组 $(\\mathcal{J}_0, \\alpha, i_a, E_{\\text{align}}, V, \\omega_{\\min}, \\omega_{\\max}, \\Delta\\omega, w, \\varepsilon)$ 的形式给出：\n\n- 情况1（一般混合，中等阻塞，典型排列）：\n  $(30.0,\\ 0.12,\\ 6.0,\\ 1.20,\\ 0.05,\\ 0.02,\\ 0.80,\\ 0.002,\\ 0.06,\\ 0.01)$。\n- 情况2（无混合，尖锐交叉极限）：\n  $(30.0,\\ 0.12,\\ 6.0,\\ 1.20,\\ 0.00,\\ 0.02,\\ 0.80,\\ 0.002,\\ 0.06,\\ 0.01)$。\n- 情况3（强混合，规避交叉更明显）：\n  $(30.0,\\ 0.12,\\ 6.0,\\ 1.20,\\ 0.20,\\ 0.02,\\ 0.80,\\ 0.002,\\ 0.06,\\ 0.01)$。\n- 情况4（更强的排列，较弱的阻塞）：\n  $(28.0,\\ 0.05,\\ 10.0,\\ 1.50,\\ 0.08,\\ 0.02,\\ 0.80,\\ 0.002,\\ 0.06,\\ 0.01)$。\n\n输出规格：\n\n- 对于每个测试用例，您的程序必须输出一个包含两个浮点数的列表：$[\\Delta \\mathcal{J}^{(1)},\\ \\Delta \\mathcal{J}^{(2)}]$，单位为 $\\hbar^2/\\mathrm{MeV}$。\n- 将所有测试用例的结果按上述顺序汇总到一个列表中，并精确打印一行包含此汇总列表的内容，格式为用方括号括起来的逗号分隔列表。例如：`[[dJ1_case1,dJ2_case1],[dJ1_case2,dJ2_case2],[dJ1_case3,dJ2_case3],[dJ1_case4,dJ2_case4]]`。",
            "solution": "问题陈述已经过严格审查，并被认为是有效的。它在科学上基于原子核结构物理学的原理，特别是用于描述形变核中转动带的摇摆Hartree-Fock-Bogoliubov (HFB) 形式体系。该问题设定良好，包含所有必要的参数和明确的计算目标。语言客观，所提供的参数在物理上是现实的。因此，有必要提供一个解。\n\n这个问题的核心是在一个转动的原子核中为一个双带混合情景建模，并量化穿越带交叉区域时运动学和动力学转动惯量的变化。该解答通过逐步实现指定的模型来进行。\n\n首先，我们为一个二能级系统定义转动参考系（或Routhian）。未微扰的（或绝热的）组态是基态带（A带）和一个排列的双准粒子带（B带）。它们的Routhian，$E_A'(\\omega)$ 和 $E_B'(\\omega)$，是转动频率 $\\omega$ 的函数。按规定，它们是：\n$$\nE_A'(\\omega) = -\\frac{1}{2}\\,\\mathcal{J}_0\\,\\omega^2\n$$\n$$\nE_B'(\\omega) = E_{\\text{align}} - \\omega\\,i_a - \\frac{1}{2}\\,\\mathcal{J}_0(1+\\alpha)\\,\\omega^2\n$$\n这里，$\\mathcal{J}_0$ 是核芯的转动惯量，$E_{\\text{align}}$ 是在静止状态下创建排列组态的能量代价，$i_a$ 是由两个准粒子沿转动轴排列的角动量，$\\alpha$ 是一个考虑了对关联减弱（阻塞效应）的参数，这会增加排列带的转动惯量。\n\n这两个绝热带以强度 $V$ 相互作用。在这两个态的基底下，完整的Routhian算符是一个 $2 \\times 2$ 矩阵：\n$$\nH'(\\omega) =\n\\begin{pmatrix}\nE_A'(\\omega) & V \\\\\nV & E_B'(\\omega)\n\\end{pmatrix}\n$$\n可观测的态，被称为yrast带和yrare带，是这个矩阵的本征态。我们感兴趣的是yrast带，它对应于在每个频率 $\\omega$ 下 $H'(\\omega)$ 的较低本征值。一个通用的 $2\\times 2$ 矩阵 $\\begin{pmatrix} a & c \\\\ c & b \\end{pmatrix}$ 的本征值 $\\lambda$ 由 $\\lambda = \\frac{a+b \\pm \\sqrt{(a-b)^2 + 4c^2}}{2}$ 给出。因此，较低的本征值，我们表示为yrast Routhian $E'_-(\\omega)$，是：\n$$\nE'_-(\\omega) = \\frac{1}{2} \\left[ (E_A'(\\omega) + E_B'(\\omega)) - \\sqrt{(E_A'(\\omega) - E_B'(\\omega))^2 + 4V^2} \\right]\n$$\n这个表达式是在一个离散的转动频率网格 $\\omega_k$ 上计算的，该网格覆盖范围 $[\\omega_{\\min}, \\omega_{\\max}]$，步长为 $\\Delta\\omega$。\n\n从yrast Routhian $E'_-(\\omega)$，我们推导出总排列角动量 $I(\\omega)$。在摇摆模型中，这由类似热力学的关系式给出：\n$$\nI(\\omega) = -\\frac{dE'_-(\\omega)}{d\\omega}\n$$\n由于 $E'_-(\\omega)$ 仅在离散网格上已知，这个导数使用中心有限差分格式进行数值计算。\n\n在确定了角动量 $I(\\omega)$ 后，我们可以分别计算运动学和动力学转动惯量 $\\mathcal{J}^{(1)}(\\omega)$ 和 $\\mathcal{J}^{(2)}(\\omega)$。它们的定义是：\n$$\n\\mathcal{J}^{(1)}(\\omega) = \\frac{I(\\omega)}{\\omega}\n$$\n$$\n\\mathcal{J}^{(2)}(\\omega) = \\frac{dI(\\omega)}{d\\omega}\n$$\n运动学转动惯量 $\\mathcal{J}^{(1)}$ 是衡量在给定转动频率下产生多少角动量的指标。动力学转动惯量 $\\mathcal{J}^{(2)}$ 测量角动量随频率的变化率，对结构变化（如带交叉）特别敏感。$\\mathcal{J}^{(2)}$ 的导数也使用中心有限差分法计算。\n\n最后一步是分析 $\\mathcal{J}^{(1)}$ 和 $\\mathcal{J}^{(2)}$ 在带交叉区域的行为。交叉点由绝热交叉频率 $\\omega_c$ 表征，在该频率下，未微扰的Routhian相等，$E_A'(\\omega_c) = E_B'(\\omega_c)$。这导出了关于 $\\omega_c$ 的二次方程：\n$$\n\\frac{1}{2}\\,\\mathcal{J}_0\\,\\alpha\\,\\omega_c^2 + i_a\\,\\omega_c - E_{\\text{align}} = 0\n$$\n物理上相关的（正）解在问题陈述中已给出。对于 $\\alpha=0$ 的特殊情况，可得 $\\omega_c = E_{\\text{align}}/i_a$。\n\n为了量化穿越交叉区域的变化，我们在两个频率窗口上对 $\\mathcal{J}^{(1)}$ 和 $\\mathcal{J}^{(2)}$ 进行平均：一个交叉前窗口 $[\\omega_c - w, \\omega_c - \\varepsilon]$ 和一个交叉后窗口 $[\\omega_c + \\varepsilon, \\omega_c + w]$。参数 $w$ 和 $\\varepsilon$ 定义了窗口的宽度以及 $\\omega_c$ 周围一个排斥区域，在该区域混合相互作用最强。一个量 $Q(\\omega)$ 的变化随后被计算为平均值之间的差：\n$$\n\\Delta Q = \\langle Q(\\omega)\\rangle_{\\text{post}} - \\langle Q(\\omega)\\rangle_{\\text{pre}}\n$$\n算法流程如下：对于每个参数集，建立一个均匀的频率网格。然后，计算 $E_A'(\\omega)$ 和 $E_B'(\\omega)$ 的数组，接着计算 $E'_-(\\omega)$。通过 `numpy.gradient` 进行两次数值微分，以获得 $I(\\omega)$，然后获得 $\\mathcal{J}^{(2)}(\\omega)$。$\\mathcal{J}^{(1)}(\\omega)$ 通过除法得到。计算交叉频率 $\\omega_c$，并使用布尔掩码数组来识别交叉前和交叉后窗口内的网格点。最后，使用 `numpy.mean` 来计算这些窗口上的平均值，它们的差值即为最终结果。对每个提供的测试用例重复此整个过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # (J0, alpha, i_a, E_align, V, w_min, w_max, dw, w, eps)\n        (30.0, 0.12, 6.0, 1.20, 0.05, 0.02, 0.80, 0.002, 0.06, 0.01), # Case 1\n        (30.0, 0.12, 6.0, 1.20, 0.00, 0.02, 0.80, 0.002, 0.06, 0.01), # Case 2\n        (30.0, 0.12, 6.0, 1.20, 0.20, 0.02, 0.80, 0.002, 0.06, 0.01), # Case 3\n        (28.0, 0.05, 10.0, 1.50, 0.08, 0.02, 0.80, 0.002, 0.06, 0.01), # Case 4\n    ]\n\n    results = []\n    for params in test_cases:\n        result = calculate_crossing_changes(params)\n        results.append(result)\n\n    # Format the output string to be exactly [[dJ1_1,dJ2_1],[dJ1_2,dJ2_2],...]\n    # without any extra spaces, as per the example format.\n    inner_parts = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(inner_parts)}]\"\n    print(final_output)\n\ndef calculate_crossing_changes(params):\n    \"\"\"\n    Calculates the change in kinematic and dynamic moments of inertia\n    across a band crossing for a single set of parameters.\n    \n    Args:\n        params (tuple): A tuple containing all model and grid parameters.\n\n    Returns:\n        list: A list containing [delta_J1, delta_J2].\n    \"\"\"\n    J0, alpha, i_a, E_align, V, w_min, w_max, dw, w, eps = params\n\n    # 1. Construct the frequency grid.\n    omega = np.arange(w_min, w_max + dw, dw)\n\n    # 2. Calculate the diabatic Routhians for the two bands.\n    E_A_prime = -0.5 * J0 * omega**2\n    E_B_prime = E_align - omega * i_a - 0.5 * J0 * (1.0 + alpha) * omega**2\n\n    # 3. Calculate the yrast Routhian (lower eigenvalue of the 2x2 H' matrix).\n    sum_E = E_A_prime + E_B_prime\n    diff_E = E_A_prime - E_B_prime\n    E_minus_prime = 0.5 * (sum_E - np.sqrt(diff_E**2 + 4.0 * V**2))\n\n    # 4. Calculate the total aligned angular momentum I(omega) = -dE'/d(omega).\n    I = -np.gradient(E_minus_prime, dw)\n\n    # 5. Calculate the kinematic and dynamic moments of inertia.\n    # omega_min > 0 ensures no division by zero for J1.\n    J1 = I / omega      # Kinematic moment of inertia, J^(1)\n    J2 = np.gradient(I, dw)  # Dynamic moment of inertia, J^(2)\n\n    # 6. Calculate the diabatic crossing frequency omega_c.\n    if alpha == 0.0:\n        # If alpha is 0, the equation for omega_c is linear.\n        if i_a > 0.0:\n            omega_c = E_align / i_a\n        else:\n            # Physically, i_a must be positive for this simple model to make sense.\n            # Avoid division by zero, though test cases do not trigger this.\n            omega_c = np.nan\n    else:\n        # For alpha > 0, solve the quadratic equation for omega_c:\n        # 0.5*J0*alpha*w^2 + i_a*w - E_align = 0\n        a = 0.5 * J0 * alpha\n        b = i_a\n        c = -E_align\n        discriminant = b**2 - 4.0 * a * c\n        # The physically relevant solution corresponds to a positive frequency.\n        omega_c = (-b + np.sqrt(discriminant)) / (2.0 * a)\n\n    # 7. Define the pre- and post-crossing analysis windows.\n    pre_window_mask = (omega >= omega_c - w)  (omega = omega_c - eps)\n    post_window_mask = (omega >= omega_c + eps)  (omega = omega_c + w)\n    \n    # 8. Calculate the average values in the windows.\n    # Use np.mean, which correctly handles cases where a window might be empty\n    # (by returning NaN), although this is not expected with the given parameters.\n    avg_J1_pre = np.mean(J1[pre_window_mask])\n    avg_J1_post = np.mean(J1[post_window_mask])\n    \n    avg_J2_pre = np.mean(J2[pre_window_mask])\n    avg_J2_post = np.mean(J2[post_window_mask])\n\n    # 9. Compute the changes Delta J^(1) and Delta J^(2).\n    delta_J1 = avg_J1_post - avg_J1_pre\n    delta_J2 = avg_J2_post - avg_J2_pre\n\n    return [delta_J1, delta_J2]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "许多核结构理论从一个破坏了转动对称性的内禀态出发，因此恢复好角动量是至关重要的一步。这项练习聚焦于角动量投影中的核心数值挑战：在转动群上进行积分。通过为一个特定的、存在解析解的核函数实现并比较不同的数值积分方案，你将深入理解角动量投影的计算方法，并体会到选择高效数值技术的重要性。",
            "id": "3550190",
            "problem": "考虑一个由希尔伯特空间中的归一化矢量 $\\lvert \\Phi \\rangle$ 表示的内禀形变核态，以及由 Euler 角 $\\Omega = (\\alpha,\\beta,\\gamma)$（其中 $\\alpha \\in [0,2\\pi)$, $\\beta \\in [0,\\pi]$, $\\gamma \\in [0,2\\pi)$）参数化的转动算符 $\\hat{R}(\\Omega)$。转动群上的 Haar 测度为 $d\\Omega = d\\alpha \\, d\\beta \\, d\\gamma \\, \\sin\\beta$。在集体转动和角动量投影中，一个核心的量是模核交叠 $\\langle \\Phi \\lvert \\hat{R}(\\Omega) \\rvert \\Phi \\rangle$。对于总角动量为 $J$ 和轴对称（$K=0$）的情况，其角动量投影模是通过将此交叠与 Wigner 矩阵元 $D^J_{00}(\\Omega)$ 在整个转动群上积分得到的。\n\n对于轴对称内禀态，假设交叠核仅依赖于极角 $\\beta$ 并具有以下形式\n$$\n\\langle \\Phi \\lvert \\hat{R}(\\Omega) \\rvert \\Phi \\rangle = \\exp\\!\\big(\\kappa \\cos\\beta\\big),\n$$\n其中 $\\kappa \\ge 0$ 是一个无量纲的形变强度参数，角度 $\\beta$ 以弧度为单位。那么，对于角动量 $J$ 的投影模为：\n$$\nN_J = \\frac{2J+1}{8\\pi^2} \\int_0^{2\\pi} d\\alpha \\int_0^\\pi d\\beta \\, \\sin\\beta \\int_0^{2\\pi} d\\gamma \\, D^J_{00}(\\Omega) \\, \\exp\\!\\big(\\kappa \\cos\\beta\\big).\n$$\n所有角度都必须按弧度处理。\n\n你的任务是为该核函数实现两种数值积分方案来计算 $N_J$：\n\n1. 一种混合积分方案：对 $\\beta$ 积分使用 Gauss–Legendre 积分（在区间 $x \\in [-1,1]$ 上进行变量代换 $x=\\cos\\beta$ 之后），对 $[0,2\\pi)$ 上的 $\\alpha$ 和 $\\gamma$ 积分使用梯形（周期性）积分。\n\n2. 一种完全梯形积分方案：对 $[0,2\\pi)$ 上的 $\\alpha$ 和 $\\gamma$ 使用梯形（周期性）积分，并对 $[0,\\pi]$ 上的 $\\beta$ 使用梯形积分，其中显式地包含了正确的 $\\sin\\beta$ 测度因子。\n\n使用以下基本事实：$D^J_{00}(\\Omega) = d^J_{00}(\\beta)$ 和 $d^J_{00}(\\beta) = P_J(\\cos\\beta)$，其中 $P_J$ 是 $J$ 阶 Legendre 多项式。在问题陈述中，不应假设任何其他简化公式。\n\n设计你的程序，为下面测试套件中的参数集计算所有满足 $0 \\le J \\le 20$ 的整数 $J$ 所对应的 $N_J$。对于每个参数集，程序必须验证两种积分方案对于指定范围内的所有 $J$ 是否都达到了小于 $10^{-6}$ 的目标相对误差（与从第一性原理分析推导的参考值相比）。如果给定 $J$ 的精确参考值为零，则比较绝对误差与 $10^{-12}$ 的阈值，而不是相对误差。角度必须以弧度处理。所有计算值都是无量纲的。\n\n测试套件（每个元组 $(\\kappa, J_{\\text{max}}, N_{\\beta}^{\\text{GL}}, N_{\\beta}^{\\text{Trap}}, N_{\\alpha}, N_{\\gamma})$ 定义一个测试用例）：\n- $(0.0, 20, 64, 512, 16, 16)$\n- $(1.0, 20, 80, 4096, 32, 32)$\n- $(5.0, 20, 120, 8192, 64, 64)$\n- $(20.0, 20, 240, 16384, 128, 128)$\n\n你的程序必须：\n- 实现上述两种积分方案。\n- 根据上述定义和所选核函数，推导并使用 $N_J$ 的精确解析参考值，不依赖问题陈述中任何未指定的简化方法。\n- 对于每个测试用例，返回两个布尔结果：第一个针对混合 Gauss–Legendre 加梯形积分方案，第二个针对完全梯形积分方案。当且仅当对于 $\\{0,1,2,\\dots,J_{\\text{max}}\\}$ 中的所有 $J$，都同时满足指定的误差标准时，相应的布尔值为真。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。结果的排序与测试套件的顺序相同，并且对于每个测试用例，首先列出混合 Gauss–Legendre 加梯形积分方案的结果，然后是完全梯形积分方案的结果。例如，输出应具有以下形式：\n$$\n[\\text{case1\\_GL},\\text{case1\\_Trap},\\text{case2\\_GL},\\text{case2\\_Trap},\\text{case3\\_GL},\\text{case3\\_Trap},\\text{case4\\_GL},\\text{case4\\_Trap}],\n$$\n其中每个条目都是一个布尔字面量。",
            "solution": "该问题要求对一个轴对称形变核态的角动量投影模 $N_J$ 进行数值计算。计算必须使用两种不同的积分方案，并且其准确性需要与一个分析推导的参考值进行验证。\n\n角动量投影模由下式给出：\n$$\nN_J = \\frac{2J+1}{8\\pi^2} \\int_0^{2\\pi} d\\alpha \\int_0^\\pi d\\beta \\, \\sin\\beta \\int_0^{2\\pi} d\\gamma \\, D^J_{00}(\\Omega) \\, \\langle \\Phi \\lvert \\hat{R}(\\Omega) \\rvert \\Phi \\rangle\n$$\n问题指定了交叠核 $\\langle \\Phi \\lvert \\hat{R}(\\Omega) \\rvert \\Phi \\rangle = \\exp(\\kappa \\cos\\beta)$ 以及 Wigner D-矩阵元的恒等式 $D^J_{00}(\\Omega) = P_J(\\cos\\beta)$，其中 $P_J$ 是 $J$ 阶 Legendre 多项式。\n\n首先，我们推导 $N_J$ 的解析参考值。将给定的表达式代入 $N_J$ 的公式中：\n$$\nN_J = \\frac{2J+1}{8\\pi^2} \\int_0^{2\\pi} d\\alpha \\int_0^\\pi d\\beta \\, \\sin\\beta \\int_0^{2\\pi} d\\gamma \\, P_J(\\cos\\beta) \\, \\exp(\\kappa \\cos\\beta)\n$$\n被积函数与 Euler 角 $\\alpha$ 和 $\\gamma$ 无关。因此，对这两个变量的积分是平凡的：\n$$\n\\int_0^{2\\pi} d\\alpha = 2\\pi \\quad \\text{and} \\quad \\int_0^{2\\pi} d\\gamma = 2\\pi\n$$\n这将 $N_J$ 的表达式简化为：\n$$\nN_J = \\frac{2J+1}{8\\pi^2} (2\\pi)(2\\pi) \\int_0^\\pi P_J(\\cos\\beta) \\, \\exp(\\kappa \\cos\\beta) \\, \\sin\\beta \\, d\\beta\n$$\n$$\nN_J = \\frac{2J+1}{2} \\int_0^\\pi P_J(\\cos\\beta) \\, \\exp(\\kappa \\cos\\beta) \\, \\sin\\beta \\, d\\beta\n$$\n为了计算剩下对 $\\beta$ 的积分，我们进行变量代换，令 $x = \\cos\\beta$。这意味着 $dx = -\\sin\\beta \\, d\\beta$。积分限从 $\\beta \\in [0, \\pi]$ 变为 $x \\in [1, -1]$。\n$$\nN_J = \\frac{2J+1}{2} \\int_1^{-1} P_J(x) \\, e^{\\kappa x} \\, (-dx) = \\frac{2J+1}{2} \\int_{-1}^{1} P_J(x) \\, e^{\\kappa x} \\, dx\n$$\n右侧的积分有一个用第一类修正球贝塞尔函数 $i_J(z)$ 表示的标准形式，其定义为：\n$$\ni_J(z) = \\frac{1}{2} \\int_{-1}^{1} e^{zx} P_J(x) \\, dx\n$$\n通过将此定义与我们的表达式进行比较，我们可以确定 $z = \\kappa$，因此：\n$$\n\\int_{-1}^{1} P_J(x) \\, e^{\\kappa x} \\, dx = 2 i_J(\\kappa)\n$$\n将此结果代回 $N_J$ 的公式，得到精确的解析结果：\n$$\nN_J^{\\text{ref}} = \\frac{2J+1}{2} \\left[ 2 i_J(\\kappa) \\right] = (2J+1) i_J(\\kappa)\n$$\n这个解析公式将作为验证数值方案的参考。$i_J(\\kappa)$ 的值可以使用标准科学计算库进行计算。\n\n接下来，我们具体说明两种数值积分方案的实现。如前所述，对 $\\alpha$ 和 $\\gamma$ 的积分贡献了一个 $(2\\pi)^2$ 的乘法因子，该因子与分母相消。对于周期性梯形法则，这一点也成立，因为对于任意数量的点 $N > 0$，该法则在周期域上能精确地对常数函数积分。因此，两种数值方案都简化为计算对 $\\beta$ 的积分：\n$$\nI_\\beta = \\int_0^\\pi P_J(\\cos\\beta) \\, \\exp(\\kappa \\cos\\beta) \\, \\sin\\beta \\, d\\beta\n$$\n使得 $N_J \\approx \\frac{2J+1}{2} I_\\beta^{\\text{num}}$。\n\n1.  **混合 Gauss–Legendre 加梯形积分方案：**\n    此方案对 $\\beta$ 积分采用 Gauss-Legendre 积分。我们使用变量代换 $x=\\cos\\beta$ 将积分变换到标准区间 $[-1, 1]$ 上：\n    $$\n    I_\\beta = \\int_{-1}^{1} P_J(x) e^{\\kappa x} dx\n    $$\n    使用具有节点 $x_i$ 和权重 $w_i$ 的 $N_{\\beta}^{\\text{GL}}$ 点 Gauss-Legendre 积分，该积分近似为：\n    $$\n    I_\\beta^{\\text{GL}} \\approx \\sum_{i=1}^{N_{\\beta}^{\\text{GL}}} w_i P_J(x_i) e^{\\kappa x_i}\n    $$\n    相应的模为 $N_J^{\\text{GL}} = \\frac{2J+1}{2} I_\\beta^{\\text{GL}}$。这种方法预计会非常高效，因为 Gauss-Legendre 积分对于解析被积函数是指数收敛的。\n\n2.  **完全梯形积分方案：**\n    此方案直接在 $[0, \\pi]$ 上的 $\\beta$ 积分使用梯形法则。该区间被离散化为 $N_{\\beta}^{\\text{Trap}}$ 个宽度为 $h_\\beta = \\pi / N_{\\beta}^{\\text{Trap}}$ 的子区间，点为 $\\beta_j = j \\cdot h_\\beta$（$j=0, 1, \\dots, N_{\\beta}^{\\text{Trap}}$）。被积函数为 $f(\\beta) = P_J(\\cos\\beta) \\exp(\\kappa \\cos\\beta) \\sin\\beta$。梯形法则给出：\n    $$\n    I_\\beta^{\\text{Trap}} \\approx h_\\beta \\left[ \\frac{f(\\beta_0) + f(\\beta_{N_{\\beta}^{\\text{Trap}}})}{2} + \\sum_{j=1}^{N_{\\beta}^{\\text{Trap}}-1} f(\\beta_j) \\right]\n    $$\n    由于 $\\sin\\beta$ 因子，有 $f(0) = f(\\pi) = 0$，因此端点的贡献为零。近似式简化为：\n    $$\n    I_\\beta^{\\text{Trap}} \\approx \\sum_{j=1}^{N_{\\beta}^{\\text{Trap}}-1} \\frac{\\pi}{N_{\\beta}^{\\text{Trap}}} P_J(\\cos\\beta_j) \\exp(\\kappa \\cos\\beta_j) \\sin\\beta_j\n    $$\n    相应的模为 $N_J^{\\text{Trap}} = \\frac{2J+1}{2} I_\\beta^{\\text{Trap}}$。由于被积函数在端点的导数不全为零，预计该方法将表现出标准的代数收敛性（$O(h^2)$），为达到同等精度需要比 Gauss-Legendre 方案多得多的点数，特别是当 $\\kappa$ 很大时，被积函数会变得非常尖锐。\n\n对于每个测试用例和每种方案，将对 $J \\in \\{0, 1, \\dots, J_{\\text{max}}\\}$ 的数值计算结果 $N_J^{\\text{num}}$ 与解析参考值 $N_J^{\\text{ref}}$ 进行比较。如果对于所有的 $J$，相对误差 $\\left| (N_J^{\\text{num}} - N_J^{\\text{ref}}) / N_J^{\\text{ref}} \\right|$ 都小于 $10^{-6}$，则该方案被视为成功。如果 $|N_J^{\\text{ref}}|$ 接近于零（小于 $10^{-12}$），则改用绝对误差检查 $|N_J^{\\text{num}} - N_J^{\\text{ref}}|  10^{-12}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_in, eval_legendre\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Solves the nuclear physics problem of calculating and validating angular momentum projected norms.\n    \"\"\"\n\n    def calculate_analytical_nj(j_max, kappa):\n        \"\"\"\n        Calculates the analytical reference value N_J = (2J+1) * i_J(kappa).\n        \"\"\"\n        j_values = np.arange(j_max + 1)\n        # scipy.special.spherical_in(n, z) computes the modified spherical Bessel function i_n(z).\n        # It can take an array for the order n.\n        i_j_values = spherical_in(j_values, kappa)\n        return (2 * j_values + 1) * i_j_values\n\n    def calculate_nj_mixed_scheme(j_max, kappa, n_beta_gl):\n        \"\"\"\n        Calculates N_J using a mixed scheme: Gauss-Legendre for beta-integration.\n        \"\"\"\n        # Get Gauss-Legendre nodes (x) and weights (w) on the interval [-1, 1].\n        x_nodes, w_weights = leggauss(n_beta_gl)\n        \n        results = np.zeros(j_max + 1)\n        exp_values = np.exp(kappa * x_nodes)\n        \n        for j in range(j_max + 1):\n            # Integrand is P_J(x) * exp(kappa*x).\n            p_j_values = eval_legendre(j, x_nodes)\n            integrand_values = p_j_values * exp_values\n            \n            # Perform the quadrature sum: sum(w_i * f(x_i)).\n            integral_val = np.sum(w_weights * integrand_values)\n            \n            # The full expression for N_J from the simplified integral.\n            n_j = (2 * j + 1) / 2.0 * integral_val\n            results[j] = n_j\n            \n        return results\n\n    def calculate_nj_trapz_scheme(j_max, kappa, n_beta_trap):\n        \"\"\"\n        Calculates N_J using a fully trapezoidal scheme.\n        \"\"\"\n        # Grid for beta from 0 to pi with n_beta_trap intervals (n_beta_trap + 1 points).\n        beta_grid = np.linspace(0, np.pi, n_beta_trap + 1)\n        cos_beta = np.cos(beta_grid)\n        sin_beta = np.sin(beta_grid)\n        \n        results = np.zeros(j_max + 1)\n        exp_values = np.exp(kappa * cos_beta)\n        \n        for j in range(j_max + 1):\n            # Integrand is P_J(cos(beta)) * exp(kappa*cos(beta)) * sin(beta).\n            p_j_values = eval_legendre(j, cos_beta)\n            integrand_values = p_j_values * exp_values * sin_beta\n            \n            # Use numpy.trapz for numerical integration.\n            integral_val = np.trapz(integrand_values, x=beta_grid)\n            \n            # The full expression for N_J.\n            n_j = (2 * j + 1) / 2.0 * integral_val\n            results[j] = n_j\n            \n        return results\n\n    def verify_scheme(numerical_results, analytical_results, j_max):\n        \"\"\"\n        Verifies if a scheme meets the specified error criteria for all J.\n        \"\"\"\n        abs_tol = 1.0e-12\n        rel_tol = 1.0e-6\n        \n        is_valid = True\n        for j in range(j_max + 1):\n            num_val = numerical_results[j]\n            ana_val = analytical_results[j]\n            \n            if np.abs(ana_val)  abs_tol:\n                # Use absolute error for values close to zero.\n                if not (np.abs(num_val - ana_val)  abs_tol):\n                    is_valid = False\n                    break\n            else:\n                # Use relative error otherwise.\n                rel_error = np.abs((num_val - ana_val) / ana_val)\n                if not (rel_error  rel_tol):\n                    is_valid = False\n                    break\n        return is_valid\n\n    # Test suite from the problem statement.\n    test_cases = [\n        # (kappa, J_max, N_beta_GL, N_beta_Trap, N_alpha, N_gamma)\n        (0.0, 20, 64, 512, 16, 16),\n        (1.0, 20, 80, 4096, 32, 32),\n        (5.0, 20, 120, 8192, 64, 64),\n        (20.0, 20, 240, 16384, 128, 128)\n    ]\n\n    final_results = []\n    for case in test_cases:\n        kappa, j_max, n_beta_gl, n_beta_trap, n_alpha, n_gamma = case\n        \n        # Calculate reference values once per test case.\n        analytical_njs = calculate_analytical_nj(j_max, kappa)\n        \n        # Evaluate and verify Scheme 1: Mixed Gauss-Legendre.\n        gl_njs = calculate_nj_mixed_scheme(j_max, kappa, n_beta_gl)\n        gl_valid = verify_scheme(gl_njs, analytical_njs, j_max)\n        final_results.append(gl_valid)\n        \n        # Evaluate and verify Scheme 2: Full Trapezoidal.\n        trapz_njs = calculate_nj_trapz_scheme(j_max, kappa, n_beta_trap)\n        trapz_valid = verify_scheme(trapz_njs, analytical_njs, j_max)\n        final_results.append(trapz_valid)\n        \n    # Print the final results in the specified format.\n    # Convert boolean to lowercase string as per example format in problem description.\n    print(f\"[{','.join(str(b).lower() for b in final_results)}]\")\n\nsolve()\n```"
        }
    ]
}