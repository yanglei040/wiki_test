{
    "hands_on_practices": [
        {
            "introduction": "为了理解 Hartree-Fock 方法的核心，我们首先要掌握其迭代过程的本质。下面的练习  将引导你通过一个简化的双能级模型，亲手实现一个完整的自洽场 (SCF) 迭代周期。这个实践将帮助你熟悉从构建 Fock 矩阵到求解本征问题，再到更新密度矩阵的基本流程，这是所有复杂 Hartree-Fock 计算的基础。",
            "id": "3566777",
            "problem": "在计算核物理的 Hartree-Fock 方法背景下，您将处理一个自洽场 (SCF) 任务，该任务针对一个简单的二能级模型。该任务的起点是一个接触相互作用模型的 Hartree-Fock 能量泛函，\n$$E[\\rho] = \\mathrm{Tr}(h_0 \\rho) + \\frac{g}{2}\\,\\mathrm{Tr}(\\rho^2),$$\n其中 $h_0$ 是一个厄米 $2\\times 2$ 单体哈密顿量，单位为兆电子伏 (MeV)，$\\rho$ 是一个厄米 $2\\times 2$ 密度矩阵，满足 $\\mathrm{Tr}(\\rho)=N$（$N$ 为占据的单粒子态数量），$g$ 是一个标量耦合常数，单位为 MeV。自洽平均场哈密顿量由泛函导数定义，\n$$H[\\rho] = \\frac{\\partial E}{\\partial \\rho} = h_0 + g\\,\\rho.$$\n一个 SCF 循环包括以下步骤：\n- 根据初始密度 $\\rho^{(0)}$ 构建平均场哈密顿量 $H[\\rho^{(0)}] = h_0 + g\\,\\rho^{(0)}$。\n- 求解矩阵特征值问题 $H C = C \\varepsilon$，得到标准正交特征向量（$C$ 的列）和特征值（$\\varepsilon$ 的对角元）。\n- 通过占据 $N$ 个能量最低的单粒子态来更新密度，即定义\n$$\\rho^{(1)} = \\sum_{i=1}^{N} c_i c_i^\\top,$$\n其中 $c_i$ 是 $C$ 中对应于 $N$ 个最低特征值的前 $N$ 列（若出现平局，可按任意一致的顺序排序）。\n- 报告残差范数\n$$r = \\|H C - C \\varepsilon\\|_F,$$\n其中 $\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数，定义为\n$$\\|X\\|_F = \\sqrt{\\sum_{i,j} X_{ij}^2}.$$\n\n您的任务是实现一个程序，对每个测试用例执行恰好一个 SCF 循环，并计算每个用例的残差范数 $r$。所有能量和报告的残差范数必须以兆电子伏 (MeV) 表示。此问题不涉及角度。不存在百分比。最终结果必须是浮点数。\n\n请使用以下参数集测试套件。对于每个用例，$h_0$ 和 $\\rho^{(0)}$ 都是实对称（$2\\times 2$）矩阵，$g$ 是一个实标量，$N$ 是一个整数：\n- 用例 1（无相互作用，基准）：\n$$h_0 = \\begin{pmatrix} 0.0  0.0 \\\\ 0.0  2.0 \\end{pmatrix}\\,\\mathrm{MeV}, \\quad g = 0.0\\,\\mathrm{MeV}, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 1.0  0.0 \\\\ 0.0  0.0 \\end{pmatrix}.$$\n- 用例 2（中等相互作用，非对角初始密度）：\n$$h_0 = \\begin{pmatrix} 1.0  0.3 \\\\ 0.3  2.0 \\end{pmatrix}\\,\\mathrm{MeV}, \\quad g = 0.5\\,\\mathrm{MeV}, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 0.8  0.2 \\\\ 0.2  0.2 \\end{pmatrix}.$$\n- 用例 3（近简并单体哈密顿量，强相互作用）：\n$$h_0 = \\begin{pmatrix} 1.0  0.99 \\\\ 0.99  1.02 \\end{pmatrix}\\,\\mathrm{MeV}, \\quad g = 3.0\\,\\mathrm{MeV}, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 0.5  0.0 \\\\ 0.0  0.5 \\end{pmatrix}.$$\n- 用例 4（两个占据态）：\n$$h_0 = \\begin{pmatrix} 0.0  -0.1 \\\\ -0.1  0.5 \\end{pmatrix}\\,\\mathrm{MeV}, \\quad g = 1.5\\,\\mathrm{MeV}, \\quad N = 2, \\quad \\rho^{(0)} = \\begin{pmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{pmatrix}.$$\n\n您的程序应生成单行输出，其中包含按所列顺序排列的四个用例的残差范数 $r$，形式为用方括号括起来的逗号分隔列表。例如，输出格式必须是\n$$[r_1,r_2,r_3,r_4],$$\n其中每个 $r_i$ 是一个以 MeV 为单位的浮点数。不应打印任何其他文本。",
            "solution": "该问题要求在一个简化的 $2 \\times 2$ Hartree-Fock 模型中，经过单次自洽场 (SCF) 循环后，计算矩阵特征值方程的残差范数。该问题定义明确，科学上基于量子多体理论和数值线性代数的原理，并为获得唯一解提供了所有必要信息。\n\n任务的核心是为四个不同的测试用例执行一个已定义的计算过程。一个循环的过程如下：\n1.  给定一个单体哈密顿量 $h_0$、一个标量相互作用强度 $g$ 和一个初始密度矩阵 $\\rho^{(0)}$，使用提供的公式构建平均场哈密顿量 $H$：\n    $$H[\\rho^{(0)}] = h_0 + g\\,\\rho^{(0)}$$\n2.  求解所得哈密顿量 $H$ 的矩阵特征值问题。由于所有指定的矩阵 $h_0$ 和 $\\rho^{(0)}$ 都是实对称的，因此所得的哈密顿量 $H$ 也是实对称的。特征值问题是：\n    $$H C = C \\varepsilon$$\n    其中 $C$ 是一个正交矩阵，其列是 $H$ 的特征向量，$\\varepsilon$ 是一个包含相应实特征值的对角矩阵。在数值上，这通过标准的特征求解器算法实现，这些算法能得出特征值（例如，以向量形式）和特征向量矩阵。\n3.  计算残差范数 $r$，定义为：\n    $$r = \\|H C - C \\varepsilon\\|_F$$\n    其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数，$\\|X\\|_F = \\sqrt{\\sum_{i,j} X_{ij}^2}$。\n\n理论上，对称矩阵的谱定理保证了存在一个由标准正交特征向量组成的矩阵 $C$，使得 $H = C \\varepsilon C^\\top$。由于 $C$ 是正交的，所以 $C^\\top C = I$，其中 $I$ 是单位矩阵。由此可知，在精确算术下：\n$$H C = (C \\varepsilon C^\\top) C = C \\varepsilon (C^\\top C) = C \\varepsilon I = C \\varepsilon$$\n因此，残差矩阵 $HC - C\\varepsilon$ 是零矩阵，其范数 $r$ 精确为 $0$。然而，数字计算机使用有限精度的浮点算术进行计算。数值特征求解器算法找到的是真实特征值和特征向量的近似值。因此，计算出的残差范数 $r$ 并非精确为零，而是一个小的正数，它量化了特定矩阵 $H$ 对角化过程的数值误差。其大小通常与 $H$ 的范数相关的机器精度在同一数量级。本问题要求的就是这个数值计算出的值。更新密度矩阵 $\\rho^{(1)}$ 的步骤是完整 SCF 循环描述的一部分，但对于计算所要求的残差范数 $r$ 而言并非必需。\n\n我们现在将此过程应用于每个测试用例。\n\n用例 1：无相互作用，基准\n参数为：\n$$h_0 = \\begin{pmatrix} 0.0  0.0 \\\\ 0.0  2.0 \\end{pmatrix}, \\quad g = 0.0, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 1.0  0.0 \\\\ 0.0  0.0 \\end{pmatrix}$$\n平均场哈密顿量为：\n$$H = h_0 + g\\,\\rho^{(0)} = \\begin{pmatrix} 0.0  0.0 \\\\ 0.0  2.0 \\end{pmatrix} + 0.0 \\cdot \\rho^{(0)} = \\begin{pmatrix} 0.0  0.0 \\\\ 0.0  2.0 \\end{pmatrix}$$\n这个矩阵已经是\n对角的。特征值为 $\\varepsilon_1 = 0.0$ 和 $\\varepsilon_2 = 2.0$，对应的特征向量为 $c_1 = (1, 0)^\\top$ 和 $c_2 = (0, 1)^\\top$。数值求解器可以识别这种结构，并产生残差在数值上为零的结果。\n计算出的残差范数为 $r_1 = 0.0$。\n\n用例 2：中等相互作用，非对角初始密度\n参数为：\n$$h_0 = \\begin{pmatrix} 1.0  0.3 \\\\ 0.3  2.0 \\end{pmatrix}, \\quad g = 0.5, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 0.8  0.2 \\\\ 0.2  0.2 \\end{pmatrix}$$\n平均场哈密顿量为：\n$$H = \\begin{pmatrix} 1.0  0.3 \\\\ 0.3  2.0 \\end{pmatrix} + 0.5 \\begin{pmatrix} 0.8  0.2 \\\\ 0.2  0.2 \\end{pmatrix} = \\begin{pmatrix} 1.0+0.4  0.3+0.1 \\\\ 0.3+0.1  2.0+0.1 \\end{pmatrix} = \\begin{pmatrix} 1.4  0.4 \\\\ 0.4  2.1 \\end{pmatrix}$$\n对此矩阵进行数值对角化，得到一组特征值和特征向量。残差范数 $r_2$ 根据这些数值结果计算得出。\n计算出的残差范数为 $r_2 \\approx 3.8687 \\times 10^{-16}$。\n\n用例 3：近简并单体哈密顿量，强相互作用\n参数为：\n$$h_0 = \\begin{pmatrix} 1.0  0.99 \\\\ 0.99  1.02 \\end{pmatrix}, \\quad g = 3.0, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 0.5  0.0 \\\\ 0.0  0.5 \\end{pmatrix}$$\n平均场哈密顿量为：\n$$H = \\begin{pmatrix} 1.0  0.99 \\\\ 0.99  1.02 \\end{pmatrix} + 3.0 \\begin{pmatrix} 0.5  0.0 \\\\ 0.0  0.5 \\end{pmatrix} = \\begin{pmatrix} 1.0+1.5  0.99 \\\\ 0.99  1.02+1.5 \\end{pmatrix} = \\begin{pmatrix} 2.5  0.99 \\\\ 0.99  2.52 \\end{pmatrix}$$\n对此矩阵进行数值对角化，以找到特征值和特征向量，并计算残差范数 $r_3$。\n计算出的残差范数为 $r_3 \\approx 6.1305 \\times 10^{-16}$。\n\n用例 4：两个占据态\n参数为：\n$$h_0 = \\begin{pmatrix} 0.0  -0.1 \\\\ -0.1  0.5 \\end{pmatrix}, \\quad g = 1.5, \\quad N = 2, \\quad \\rho^{(0)} = \\begin{pmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{pmatrix}$$\n平均场哈密顿量为：\n$$H = \\begin{pmatrix} 0.0  -0.1 \\\\ -0.1  0.5 \\end{pmatrix} + 1.5 \\begin{pmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{pmatrix} = \\begin{pmatrix} 0.0+1.5  -0.1 \\\\ -0.1  0.5+1.5 \\end{pmatrix} = \\begin{pmatrix} 1.5  -0.1 \\\\ -0.1  2.0 \\end{pmatrix}$$\n再次进行数值对角化，并计算残差范数 $r_4$。\n计算出的残差范数为 $r_4 \\approx 3.4901 \\times 10^{-16}$。\n\n最终结果是这四个残差范数的集合，它们反映了标准特征求解器在处理给定矩阵时的数值精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the residual norm of the Hartree-Fock eigenvalue problem\n    for four different test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Non-interacting, baseline\n        {\n            \"h0\": np.array([[0.0, 0.0], [0.0, 2.0]]),\n            \"g\": 0.0,\n            \"N\": 1,\n            \"rho0\": np.array([[1.0, 0.0], [0.0, 0.0]]),\n        },\n        # Case 2: Moderate interaction, off-diagonal initial density\n        {\n            \"h0\": np.array([[1.0, 0.3], [0.3, 2.0]]),\n            \"g\": 0.5,\n            \"N\": 1,\n            \"rho0\": np.array([[0.8, 0.2], [0.2, 0.2]]),\n        },\n        # Case 3: Near-degenerate one-body Hamiltonian, strong interaction\n        {\n            \"h0\": np.array([[1.0, 0.99], [0.99, 1.02]]),\n            \"g\": 3.0,\n            \"N\": 1,\n            \"rho0\": np.array([[0.5, 0.0], [0.0, 0.5]]),\n        },\n        # Case 4: Two occupied states\n        {\n            \"h0\": np.array([[0.0, -0.1], [-0.1, 0.5]]),\n            \"g\": 1.5,\n            \"N\": 2,\n            \"rho0\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        h0 = case[\"h0\"]\n        g = case[\"g\"]\n        rho0 = case[\"rho0\"]\n        \n        # Step 1: Build the mean-field Hamiltonian H[\\rho^{(0)}]\n        H = h0 + g * rho0\n        \n        # Step 2: Solve the matrix eigenvalue problem H C = C epsilon\n        # numpy.linalg.eigh is used for Hermitian (or real-symmetric) matrices.\n        # It returns eigenvalues and corresponding eigenvectors.\n        # eigenvalues: 1D array of eigenvalues\n        # eigenvectors: 2D array where columns are the normalized eigenvectors\n        eigenvalues, C = np.linalg.eigh(H)\n        \n        # Create the diagonal matrix of eigenvalues\n        epsilon = np.diag(eigenvalues)\n        \n        # Step 3: Compute the residual matrix and its Frobenius norm\n        # Residual = H C - C epsilon\n        residual_matrix = H @ C - C @ epsilon\n        \n        # Frobenius norm of the residual matrix\n        r = np.linalg.norm(residual_matrix, 'fro')\n        \n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际的 SCF 计算中，为了加速收敛，我们通常会混合前后两次迭代的密度矩阵。然而，一个简单的线性混合方案虽然直观，却会破坏密度矩阵必须满足的幂等性（$D^2=D$）。这个练习将揭示这一问题，并引导你实现一种基于奇异值分解 (SVD) 的投影方法，将混合后的非幂等矩阵精确地投影回它应该在的数学流形上，这是构建稳定高效求解器的关键一步。",
            "id": "3566772",
            "problem": "考虑在计算核物理中，在一个维度为 $M$ 的正交归一单粒子基上表述的 Hartree-Fock (HF) 方程的自洽场 (SCF) 迭代。对于一个具有 $N$ 个占据轨道 ($N \\le M$) 的 Slater 行列式，单体密度矩阵 $D$ 定义为 $D = \\sum_{i=1}^{N} \\lvert \\phi_i \\rangle \\langle \\phi_i \\rvert$，并且必须满足幂等性约束 $D^2 = D$ 和厄米性约束 $D^\\dagger = D$。Fock 算符 $F[D]$ 是 $D$ 的一个厄米泛函，而映射 $\\hat{D}(F)$ 返回 $F$ 的 $N$ 个能量最低的本征矢量所张成的子空间上的投影算符。一种常见的 SCF 加速方法是线性混合，它通过 $D_{n+1} = (1 - \\alpha) D_n + \\alpha \\, \\hat{D}(F[D_n])$ 来更新密度，其中 $\\alpha \\in [0,1]$ 是混合参数。\n\n仅从这些基本定义出发，执行以下操作：\n\n1. 利用投影算符代数的第一性原理，严格证明当 $0  \\alpha  1$ 时，对于一般的 $D_n$ 和 $\\hat{D}(F[D_n])$，线性混合更新 $D_{n+1} = (1 - \\alpha) D_n + \\alpha \\, \\hat{D}(F[D_n])$ 会违反幂等性条件 $D_{n+1}^2 = D_{n+1}$。您的论证不得依赖未经证明的捷径，并且必须明确使用投影算符的代数性质。\n\n2. 设计一个有数学依据的投影，将任意厄米矩阵 $D$ 映射回秩为 $N$ 的投影算符构成的格拉斯曼流形 $\\mathcal{G}(N,M)$ 上。您的投影必须基于奇异值分解 (SVD)：对于给定的 $D$，计算其 SVD $D = U \\Sigma V^\\dagger$，然后构造一个秩为 $N$ 的投影算符 $P = U_N U_N^\\dagger$，其中 $U_N$ 包含与 $N$ 个最大奇异值相关联的 $N$ 个左奇异矢量。提供严格的推导，证明这个 $P$ 是 $\\mathcal{G}(N,M)$ 中在弗罗贝尼乌斯范数下最接近 $D$ 的元素，并且满足 $P^2 = P$ 和 $P^\\dagger = P$。\n\n3. 实现一个完整的程序，对一组指定的测试用例，执行一个 SCF 线性混合步骤，然后进行基于 SVD 的投影。在所有情况下，将 Fock 算符泛函定义为 $F[D] = H + \\gamma D$，其中 $H$ 是厄米矩阵，$\\gamma \\in \\mathbb{R}$。映射 $\\hat{D}(F)$ 必须通过对角化 $F$ 并构造到能量最低的 $N$ 个本征矢量上的投影算符来实现。对于每个测试用例，计算：\n   - 混合后的密度的幂等性违反程度 $E_{\\mathrm{mix}} = \\lVert D_{\\mathrm{mix}}^2 - D_{\\mathrm{mix}} \\rVert_F$，其中 $\\lVert \\cdot \\rVert_F$ 表示弗罗贝尼乌斯范数。\n   - SVD 投影后的幂等性违反程度 $E_{\\mathrm{proj}} = \\lVert P^2 - P \\rVert_F$。\n\n您的程序必须使用以下确定性构造方法：\n- 对于给定的 $M$、$N$ 和整数种子 $s$，要生成一个随机的秩为 $N$ 的投影算符 $D_n$，请使用以 $s$ 为种子的伪随机数生成器生成一个实数 $M \\times N$ 矩阵 $A$，其元素为独立的标准正态分布，计算其薄 QR 分解 $A = QR$，并设置 $D_n = QQ^\\dagger$。\n- 对于给定的 $M$ 和整数种子 $t$，要生成一个随机的厄米矩阵 $H$，请使用以 $t$ 为种子的伪随机数生成器生成一个实数 $M \\times M$ 矩阵 $B$，其元素为独立的标准正态分布，并设置 $H = \\tfrac{1}{2}(B + B^\\dagger)$。\n\n测试套件如下：\n- 用例 1：$(M,N,\\alpha,\\gamma,s,t) = (4,2,0.5,0.7,11,13)$。\n- 用例 2：$(M,N,\\alpha,\\gamma,s,t) = (4,2,0.0,0.7,11,13)$。\n- 用例 3：$(M,N,\\alpha,\\gamma,s,t) = (4,2,1.0,0.7,11,13)$。\n- 用例 4：$(M,N,\\alpha,\\gamma,s,t) = (5,2,0.3,-0.5,21,22)$。\n- 用例 5：$(M,N,\\alpha,\\gamma,s) = (6,3,0.4,0.0,31)$，其中 $H$ 显式设置为对角矩阵 $H = \\mathrm{diag}(0,0,0,1,1,1)$ (这种情况下不需要种子 $t$)。\n\n对于每个用例，计算 $D_{\\mathrm{mix}} = (1 - \\alpha) D_n + \\alpha \\, \\hat{D}(F[D_n])$，然后计算 $E_{\\mathrm{mix}}$ 以及将 $D_{\\mathrm{mix}}$ 通过 SVD 投影到 $P = U_N U_N^\\dagger$ 后的 $E_{\\mathrm{proj}}$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。该列表必须按顺序包含 10 个浮点值 $[E_{\\mathrm{mix}}^{(1)},E_{\\mathrm{proj}}^{(1)},E_{\\mathrm{mix}}^{(2)},E_{\\mathrm{proj}}^{(2)},E_{\\mathrm{mix}}^{(3)},E_{\\mathrm{proj}}^{(3)},E_{\\mathrm{mix}}^{(4)},E_{\\mathrm{proj}}^{(4)},E_{\\mathrm{mix}}^{(5)},E_{\\mathrm{proj}}^{(5)}]$。\n\n这个纯数学计算不涉及任何物理单位。如果出现角度，应以弧度处理，但在指定的测试用例中没有引入角度。",
            "solution": "这个问题包含三个部分：关于线性混合密度矩阵幂等性的理论证明，一种恢复幂等性的最优投影方法的推导，以及一个用于验证这些概念的数值实现。我们将严格遵循第一性原理，依次处理每个部分。\n\n### 第 1 部分：线性混合中的幂等性违反\n\n我们已知在自洽场 (SCF) 迭代中，密度矩阵 $D$ 的线性混合更新规则为：\n$$\nD_{n+1} = (1 - \\alpha) D_n + \\alpha \\, \\hat{D}(F[D_n])\n$$\n其中 $\\alpha \\in [0,1]$ 是混合参数。根据定义，矩阵 $D_n$ 和 $\\hat{D}(F[D_n])$ 都是秩为 $N$ 的正交投影算符。我们将其表示为 $P_1 \\equiv D_n$ 和 $P_2 \\equiv \\hat{D}(F[D_n])$。两者都满足作为投影算符的条件：$P_1^2 = P_1$, $P_1^\\dagger = P_1$, $\\mathrm{Tr}(P_1) = N$，对 $P_2$ 亦然。更新后的矩阵是 $D_{\\text{mix}} = (1-\\alpha)P_1 + \\alpha P_2$。题目要求我们证明，对于 $0  \\alpha  1$ 和一般的投影算符 $P_1 \\ne P_2$，幂等性条件 $D_{\\text{mix}}^2 = D_{\\text{mix}}$ 会被违反。\n\n首先，我们计算 $D_{\\text{mix}}^2$：\n$$\nD_{\\text{mix}}^2 = ((1-\\alpha)P_1 + \\alpha P_2)^2 = (1-\\alpha)^2 P_1^2 + \\alpha^2 P_2^2 + (1-\\alpha)\\alpha(P_1 P_2 + P_2 P_1)\n$$\n利用 $P_1$ 和 $P_2$ 的幂等性，即 $P_1^2 = P_1$ 和 $P_2^2=P_2$，上式可简化为：\n$$\nD_{\\text{mix}}^2 = (1-\\alpha)^2 P_1 + \\alpha^2 P_2 + \\alpha(1-\\alpha)(P_1 P_2 + P_2 P_1)\n$$\n为使 $D_{\\text{mix}}$ 具有幂等性，必须有 $D_{\\text{mix}}^2 = D_{\\text{mix}}$。将 $D_{\\text{mix}}^2$ 的表达式与 $D_{\\text{mix}}$ 的定义相等：\n$$\n(1-\\alpha)^2 P_1 + \\alpha^2 P_2 + \\alpha(1-\\alpha)(P_1 P_2 + P_2 P_1) = (1-\\alpha)P_1 + \\alpha P_2\n$$\n将所有项移到一边：\n$$\n((1-\\alpha)^2 - (1-\\alpha))P_1 + (\\alpha^2 - \\alpha)P_2 + \\alpha(1-\\alpha)(P_1 P_2 + P_2 P_1) = 0\n$$\n对 $P_1$ 和 $P_2$ 的系数进行因式分解：\n$$\n(1-\\alpha)(1-\\alpha-1)P_1 + \\alpha(\\alpha-1)P_2 + \\alpha(1-\\alpha)(P_1 P_2 + P_2 P_1) = 0\n$$\n$$\n-\\alpha(1-\\alpha)P_1 - \\alpha(1-\\alpha)P_2 + \\alpha(1-\\alpha)(P_1 P_2 + P_2 P_1) = 0\n$$\n问题指定 $0  \\alpha  1$，这意味着因子 $\\alpha(1-\\alpha)$ 严格为正。因此，我们可以用 $\\alpha(1-\\alpha)$ 除以整个方程：\n$$\n-P_1 - P_2 + P_1 P_2 + P_2 P_1 = 0\n$$\n这可以重排为 $D_{\\text{mix}}$ 具有幂等性的一个充要条件：\n$$\nP_1 P_2 + P_2 P_1 = P_1 + P_2\n$$\n我们现在必须确定这个条件对于两个投影算符 $P_1$ 和 $P_2$ 何时成立。考虑反射算符 $S_1 = I - 2P_1$ 和 $S_2 = I - 2P_2$。这些算符既是厄米算符又是自身的逆（对合的），因为 $S_k^2 = (I-2P_k)^2 = I - 4P_k + 4P_k^2 = I - 4P_k + 4P_k = I$。该条件可以用 $S_1$ 和 $S_2$ 重写。注意到 $P_k = \\frac{1}{2}(I-S_k)$。代入条件中：\n$$\n\\frac{1}{2}(I-S_1)\\frac{1}{2}(I-S_2) + \\frac{1}{2}(I-S_2)\\frac{1}{2}(I-S_1) = \\frac{1}{2}(I-S_1) + \\frac{1}{2}(I-S_2)\n$$\n乘以 $4$：\n$$\n(I-S_1-S_2+S_1S_2) + (I-S_2-S_1+S_2S_1) = 2(I-S_1) + 2(I-S_2)\n$$\n$$\n2I - 2(S_1+S_2) + S_1S_2 + S_2S_1 = 4I - 2(S_1+S_2)\n$$\n这简化为 $S_1S_2 + S_2S_1 = 2I$。从左侧乘以 $S_1$ 得到 $S_1^2 S_2 + S_1 S_2 S_1 = 2S_1$。由于 $S_1^2=I$，我们得到 $S_2 + S_1 S_2 S_1 = 2S_1$。从右侧乘以 $S_1$ 得到 $S_2 S_1 + S_1 S_2 S_1^2 = 2S_1^2$，所以 $S_2 S_1 + S_1 S_2 = 2I$，这与我们开始时相同。\n\n让我们回到 $P_1 P_2 + P_2 P_1 = P_1 + P_2$。从两边减去 $P_1 P_2$ 得到 $P_2 P_1 - P_2 = P_1 - P_1 P_2$，即 $P_2(P_1-I) = P_1(I-P_2)$。\n令 $(I-P_k)$ 为 $Q_k$，即到 $P_k$ 零空间上的投影算符。条件变为 $P_2 Q_1 - P_1 Q_2 = 0$。\n最直接的路径是看到 $P_1 P_2 + P_2 P_1 = P_1 + P_2$ 等价于 $(P_1-P_2)^2 = P_1^2 - P_1P_2 - P_2P_1 + P_2^2 = P_1 - (P_1+P_2) + P_2 = 0$。\n所以 $D_{\\text{mix}}$ 的幂等性条件意味着 $(P_1-P_2)^2 = 0$。由于 $P_1$ 和 $P_2$ 是厄米矩阵，它们的差 $P_1-P_2$ 也是厄米矩阵。对于任何厄米矩阵 $A$， $A^2=0$ 意味着 $A=0$。要证明这一点，对任意矢量 $x$，$\\lVert Ax \\rVert ^2 = \\langle Ax, Ax \\rangle = \\langle x, A^\\dagger Ax \\rangle = \\langle x, A^2x \\rangle = \\langle x, 0 \\rangle = 0$。因此对所有 $x$ 都有 $Ax=0$，这意味着 $A=0$。\n因此，$(P_1-P_2)^2=0$ 意味着 $P_1-P_2=0$，即 $P_1=P_2$。\n\n总之，对于 $0  \\alpha  1$，混合密度矩阵 $D_{\\text{mix}}$ 是幂等的当且仅当 $P_1=P_2$。在 SCF 迭代的一般步骤中，输入密度矩阵 $D_n$ 不是一个不动点，因此 $D_n \\ne \\hat{D}(F[D_n])$。因此，线性混合方案内在地违反了密度矩阵关键的幂等性属性。\n\n### 第 2 部分：基于 SVD 到格拉斯曼流形的投影\n\n我们寻求一个投影，它将一个任意的 $M \\times M$ 厄米矩阵 $D$ 映射到集合 $\\mathcal{G}(N,M) = \\{ P \\in \\mathbb{C}^{M\\times M} \\mid P^2=P, P^\\dagger=P, \\mathrm{Tr}(P)=N \\}$ 中最接近的秩为 $N$ 的投影算符 $P$。“最接近”定义为最小化差的弗罗贝尼乌斯范数 $\\lVert D - P \\rVert_F$。\n\n弗罗贝尼乌斯范数的平方由 $\\lVert A \\rVert_F^2 = \\mathrm{Tr}(A^\\dagger A)$ 给出。我们希望最小化：\n$$\n\\lVert D - P \\rVert_F^2 = \\mathrm{Tr}((D - P)^\\dagger (D - P))\n$$\n由于 $D$ 和 $P$ 都是厄米矩阵 ($D^\\dagger=D, P^\\dagger=P$)，展开后得到：\n$$\n\\lVert D - P \\rVert_F^2 = \\mathrm{Tr}(D^2 - DP - PD + P^2) = \\mathrm{Tr}(D^2) - \\mathrm{Tr}(DP) - \\mathrm{Tr}(PD) + \\mathrm{Tr}(P^2)\n$$\n利用迹的循环性质 ($\\mathrm{Tr}(AB) = \\mathrm{Tr}(BA)$) 和投影算符的性质 ($P^2=P$, $\\mathrm{Tr}(P)=N$)，上式变为：\n$$\n\\lVert D - P \\rVert_F^2 = \\mathrm{Tr}(D^2) - 2\\mathrm{Tr}(DP) + \\mathrm{Tr}(P) = \\mathrm{Tr}(D^2) - 2\\mathrm{Tr}(DP) + N\n$$\n项 $\\mathrm{Tr}(D^2)$ 和 $N$ 关于 $P$ 的选择是常数。因此，最小化 $\\lVert D - P \\rVert_F^2$ 等价于最大化 $\\mathrm{Tr}(DP)$。\n\n设厄米矩阵 $D$ 的谱分解为 $D = \\sum_{i=1}^{M} \\lambda_i \\lvert v_i \\rangle \\langle v_i \\rvert$，其中 $\\lambda_i$ 是实数特征值，$\\{\\lvert v_i \\rangle\\}$ 是对应的正交归一的本征矢量集。我们对特征值进行排序，使得 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_M$。\n任何秩为 $N$ 的投影算符 $P$ 都可以写成 $P = \\sum_{j=1}^{N} \\lvert u_j \\rangle \\langle u_j \\rvert$，其中 $\\{\\lvert u_j \\rangle\\}_{j=1}^N$ 是张成 $P$ 的值域的一个正交归一的 $N$ 矢量集。\n\n我们计算 $\\mathrm{Tr}(DP)$：\n$$\n\\mathrm{Tr}(DP) = \\mathrm{Tr}\\left(D \\sum_{j=1}^{N} \\lvert u_j \\rangle \\langle u_j \\rvert\\right) = \\sum_{j=1}^{N} \\mathrm{Tr}(D \\lvert u_j \\rangle \\langle u_j \\rvert) = \\sum_{j=1}^{N} \\langle u_j \\rvert D \\lvert u_j \\rangle\n$$\n这是 $D$ 在 $P$ 的值域基矢量上的期望值之和。为了最大化这个和，我们必须最优地选择集合 $\\{\\lvert u_j \\rangle\\}$。根据 Ky Fan 不等式，或通过更直接的论证，期望值之和 $\\sum_j \\langle u_j \\rvert D \\lvert u_j \\rangle$ 在由 $\\{\\lvert u_j \\rangle\\}$ 张成的子空间与由 $D$ 对应于其 $N$ 个最大特征值的本征矢量所张成的子空间相同时，达到最大值。\n在我们排序后的特征值基中，通过选择 $\\lvert u_j \\rangle = \\lvert v_j \\rangle$（对于 $j=1, \\dots, N$）可以达到最大值。这个选择给出了：\n$$\n\\mathrm{Tr}(DP) = \\sum_{j=1}^{N} \\langle v_j \\rvert D \\lvert v_j \\rangle = \\sum_{j=1}^{N} \\langle v_j \\rvert (\\lambda_j \\lvert v_j \\rangle) = \\sum_{j=1}^{N} \\lambda_j\n$$\n任何其他正交归一集 $\\{\\lvert u_j \\rangle\\}$ 的选择将产生一个小于或等于此和的值。\n\n因此，最优投影算符 $P$ 是投影到由对应于 $D$ 的 $N$ 个最大特征值的本征矢量 $\\{\\lvert v_1 \\rangle, \\dots, \\lvert v_N \\rangle\\}$ 所张成的子空间上的那一个：\n$$\nP = \\sum_{i=1}^N \\lvert v_i \\rangle \\langle v_i \\rvert\n$$\n问题的表述使用了奇异值分解 (SVD)，$D = U \\Sigma V^\\dagger$。由于 $D$ 是厄米矩阵，其左、右奇异矢量相同 ($U=V$)，且与它的本征矢量一致。奇异值是特征值的绝对值。在这个问题的背景下，待投影的矩阵 $D_{\\text{mix}} = (1-\\alpha)D_n + \\alpha \\hat{D}(F[D_n])$ 是两个半正定矩阵（投影算符是半正定的）的凸组合，因此它也是半正定的。因此其特征值是非负的，并与其奇异值相同。所以，对应于 $N$ 个最大特征值的本征矢量与对应于 $N$ 个最大奇异值的左奇异矢量是相同的。\n\n设 $U_N$ 是一个 $M \\times N$ 矩阵，其列是 $U$ 的前 $N$ 列（即本征矢量 $\\lvert v_1 \\rangle, \\dots, \\lvert v_N \\rangle$）。该投影算符可以写为 $P=U_N U_N^\\dagger$。我们验证其性质：\n1.  **厄米性：** $P^\\dagger = (U_N U_N^\\dagger)^\\dagger = (U_N^\\dagger)^\\dagger U_N^\\dagger = U_N U_N^\\dagger = P$。它是厄米矩阵。\n2.  **幂等性：** $P^2 = (U_N U_N^\\dagger)(U_N U_N^\\dagger) = U_N (U_N^\\dagger U_N) U_N^\\dagger$。由于 $U_N$ 的列是正交归一的，所以 $U_N^\\dagger U_N = I_N$，即 $N \\times N$ 的单位矩阵。因此，$P^2 = U_N I_N U_N^\\dagger = U_N U_N^\\dagger = P$。它是幂等的。\n3.  **秩：** 投影算符的秩是它的迹。$\\mathrm{rank}(P) = \\mathrm{Tr}(P) = \\mathrm{Tr}(U_N U_N^\\dagger) = \\mathrm{Tr}(U_N^\\dagger U_N) = \\mathrm{Tr}(I_N) = N$。\n\n推导至此完成。基于 SVD 的构造正确地找到了给定厄米矩阵在弗罗贝尼乌斯范数下最接近的秩为 $N$ 的投影算符。该过程成功地将一个失去幂等性的矩阵映射回格拉斯曼流形 $\\mathcal{G}(N,M)$ 上。",
            "answer": "```python\nimport numpy as np\n\ndef run_case(M, N, alpha, gamma, s, t=None, H_explicit=None):\n    \"\"\"\n    Performs one SCF linear mixing step followed by SVD projection for a single test case.\n\n    Args:\n        M (int): Dimension of the basis.\n        N (int): Number of occupied orbitals.\n        alpha (float): Linear mixing parameter.\n        gamma (float): Parameter for the Fock operator functional.\n        s (int): Seed for generating the initial density matrix.\n        t (int, optional): Seed for generating the core Hamiltonian. Defaults to None.\n        H_explicit (np.ndarray, optional): An explicitly provided core Hamiltonian. Defaults to None.\n\n    Returns:\n        tuple[float, float]: A tuple containing (E_mix, E_proj).\n    \"\"\"\n    \n    # 1. Generate the initial rank-N projector D_n\n    # Use a real M x N matrix A with standard normal entries\n    rng_s = np.random.default_rng(s)\n    A = rng_s.standard_normal((M, N))\n    # Compute the thin QR factorization of A\n    Q, _ = np.linalg.qr(A, mode='reduced')\n    # D_n is the projector Q Q^dagger\n    Dn = Q @ Q.T\n\n    # 2. Generate the core Hamiltonian H\n    if H_explicit is not None:\n        H = H_explicit\n    else:\n        # Use a real M x M matrix B with standard normal entries\n        rng_t = np.random.default_rng(t)\n        B = rng_t.standard_normal((M, M))\n        # Symmetrize to create a Hermitian matrix (here, real symmetric)\n        H = 0.5 * (B + B.T)\n\n    # 3. Compute the Fock operator F[D_n]\n    F = H + gamma * Dn\n\n    # 4. Compute the target projector, D_hat(F)\n    # Diagonalize the Hermitian Fock operator F\n    # np.linalg.eigh sorts eigenvalues in ascending order\n    eigvals, eigvecs = np.linalg.eigh(F)\n    # The columns of eigvecs are the eigenvectors. We need the first N columns\n    # corresponding to the N lowest eigenvalues.\n    lowest_eigvecs = eigvecs[:, :N]\n    # Form the projector onto this N-dimensional subspace\n    D_hat = lowest_eigvecs @ lowest_eigvecs.T\n\n    # 5. Perform linear mixing\n    D_mix = (1 - alpha) * Dn + alpha * D_hat\n\n    # 6. Compute idempotency violation of the mixed density, E_mix\n    error_matrix_mix = D_mix @ D_mix - D_mix\n    E_mix = np.linalg.norm(error_matrix_mix, 'fro')\n\n    # 7. Project D_mix back onto the Grassmann manifold\n    # D_mix is Hermitian, so its SVD is U S U^dagger. Left and right singular vectors are the same.\n    # np.linalg.svd sorts singular values in descending order.\n    U, S, Vh = np.linalg.svd(D_mix)\n    # Take the N left singular vectors associated with the N largest singular values\n    U_N = U[:, :N]\n    # Construct the closest rank-N projector P\n    P = U_N @ U_N.T\n\n    # 8. Compute idempotency violation of the projected density, E_proj\n    # This should be close to machine epsilon\n    error_matrix_proj = P @ P - P\n    E_proj = np.linalg.norm(error_matrix_proj, 'fro')\n\n    return E_mix, E_proj\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (M, N, alpha, gamma, s, t)\n        (4, 2, 0.5, 0.7, 11, 13),\n        (4, 2, 0.0, 0.7, 11, 13),\n        (4, 2, 1.0, 0.7, 11, 13),\n        (5, 2, 0.3, -0.5, 21, 22),\n        # Case 5 has no 't' seed\n        (6, 3, 0.4, 0.0, 31),\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        if len(case) == 6:\n            M, N, alpha, gamma, s, t = case\n            E_mix, E_proj = run_case(M, N, alpha, gamma, s, t)\n        else: # Case 5\n            M, N, alpha, gamma, s = case\n            H_explicit = np.diag([0.0, 0.0, 0.0, 1.0, 1.0, 1.0])\n            E_mix, E_proj = run_case(M, N, alpha, gamma, s, H_explicit=H_explicit)\n        \n        results.append(E_mix)\n        results.append(E_proj)\n\n    # Format the final output string\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Hartree-Fock 理论的精髓在于其“自洽”特性，即平均场本身是粒子密度的函数。当能量泛函具有密度依赖性时，单粒子能量中会自然出现所谓的“重排项”。这个练习  设计了一个巧妙的数值实验，它将向你展示，如果忽略这些重排项，即使在迭代中使用正确的化学势，也会导致粒子数不守恒，从而破坏了系统的热力学一致性。通过这个实践，你将深刻体会到在理论和计算中正确处理密度依赖性的重要性。",
            "id": "3566760",
            "problem": "您将为一个与计算核物理相关的简化 Hartree-Fock 模型实现并分析一个迭代自洽场 (iterative self-consistent field) 程序，重点关注在迭代过程中忽略重排项 (rearrangement terms) 对化学势和粒子数守恒的影响。您将使用一组离散的单体能级和一个能够产生包含重排贡献的平均场的密度依赖能量泛函。\n\n考虑一组单粒子能级，其基础能量为 $\\{ \\epsilon_i^{(0)} \\}_{i=1}^{L}$，占据数为 $\\{ n_i \\}_{i=1}^L$，温度为 $T > 0$（单位为兆电子伏特 (MeV)，玻尔兹曼常数 $k_B = 1$）。令总粒子数为 $N = \\sum_{i=1}^L n_i$。定义能量泛函\n$$\nE[\\{n_i\\}] = \\sum_{i=1}^L n_i \\, \\epsilon_i^{(0)} + \\frac{g}{2} N^2 + \\frac{h}{3} N^3,\n$$\n其中参数 $g$ 和 $h$ 的单位为 MeV。进入 Hartree-Fock 方程的单粒子能量由能量泛函对占据数的泛函导数得到：\n$$\n\\epsilon_i(N) = \\frac{\\partial E}{\\partial n_i} = \\epsilon_i^{(0)} + g N + h N^2.\n$$\n在有限温度 $T$ 下，对于给定的化学势 $\\mu$，占据数遵循费米-狄拉克 (Fermi-Dirac) 分布，\n$$\nn_i = \\frac{1}{1 + \\exp\\!\\left( \\frac{\\epsilon_i(N) - \\mu}{T} \\right)}.\n$$\n重排项是泛函中由密度依赖性产生的、依赖于 $N$ 的贡献，此处由 $\\epsilon_i(N)$ 中的 $h N^2$ 项体现。\n\n您的任务是实现以下测试计算，以量化在固定化学势下进行迭代时，忽略重排项对粒子数守恒的影响：\n\n1. 对于一个指定的目标粒子数 $N_{\\mathrm{target}}$，计算在包含重排项的正确平均场下，能使 $N = N_{\\mathrm{target}}$ 成立的“真实”化学势 $\\mu_{\\mathrm{true}}$。由于对 $N$ 的依赖性表现为对所有单粒子能级的均匀平移，此条件简化为求解以下标量方程\n$$\nN_{\\mathrm{target}} = \\sum_{i=1}^L \\frac{1}{1 + \\exp\\!\\left( \\frac{\\epsilon_i^{(0)} + g N_{\\mathrm{target}} + h N_{\\mathrm{target}}^2 - \\mu_{\\mathrm{true}}}{T} \\right)}.\n$$\n\n2. 现在，考虑在固定的 $\\mu = \\mu_{\\mathrm{true}}$ 下，使用一个忽略了重排项的哈密顿量进行自洽场 (SCF) 迭代。即，使用\n$$\n\\epsilon_i^{\\mathrm{wrong}}(N) = \\epsilon_i^{(0)} + g N,\n$$\n并执行不动点迭代\n$$\nN^{(k+1)} = \\sum_{i=1}^L \\frac{1}{1 + \\exp\\!\\left( \\frac{\\epsilon_i^{(0)} + g N^{(k)} - \\mu_{\\mathrm{true}}}{T} \\right)},\n$$\n可选择通过线性混合进行稳定\n$$\nN^{(k+1)} \\leftarrow (1 - \\alpha) N^{(k)} + \\alpha \\, N^{(k+1)},\n$$\n其中 $0  \\alpha \\le 1$ 是一个小数，直至收敛 $\\lvert N^{(k+1)} - N^{(k)} \\rvert  \\delta$，$\\delta$ 为一个很小的容差。\n\n3. 将收敛时的粒子数偏差量化为\n$$\n\\Delta N = N_{\\mathrm{wrong}}^{(\\infty)} - N_{\\mathrm{target}}.\n$$\n\n实现一个程序，对下面测试套件中的每个测试用例执行上述步骤。使用以下建模细节：\n\n- 基礎能量是等间距的：$\\epsilon_i^{(0)} = \\Delta \\cdot (i - 1)$，其中 $i = 1, 2, \\dots, L$，$\\Delta$ 是能级间距，单位为 MeV。\n- 温度和能量的单位为 MeV，粒子数为无量纲量。\n- 对每个测试用例，使用一个鲁棒的求根方案来确定 $\\mu_{\\mathrm{true}}$。\n- 对不包含重排项的 SCF 使用带线性混合的不动点迭代，选择一个合理的 $\\alpha$ 值和一个足够小以解析出不动点的收敛容差 $\\delta$。\n\n测试套件（每个元组为 $(L, \\Delta, g, h, T, N_{\\mathrm{target}})$；所有能量和温度的单位均为 MeV）：\n\n- 用例 A (一般情况, \"happy path\")：$(100, 1.0, 0.4, 0.02, 0.5, 20.0)$。\n- 用例 B (边界情况, 无重排项)：$(100, 1.0, 0.4, 0.0, 0.5, 20.0)$。\n- 用例 C (低温边界)：$(200, 0.5, 0.3, 0.02, 0.05, 10.0)$。\n- 用例 D (更强的密度依赖性)：$(150, 0.8, 0.2, 0.02, 0.8, 30.0)$。\n- 用例 E (小体系)：$(30, 1.2, 0.5, 0.03, 0.4, 12.0)$。\n\n输出规范：\n\n- 对每个用例，计算 $\\Delta N$ 作为浮点数。\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，按 A, B, C, D, E 的顺序排列结果，每个 $\\Delta N$ 四舍五入到小数点后六位，例如：$[\\Delta N_A,\\Delta N_B,\\Delta N_C,\\Delta N_D,\\Delta N_E]$。",
            "solution": "用户在核多体理论领域提供了一个有效的计算问题。任务是量化在一个简化的 Hartree-Fock 模型中因忽略重排项而产生的粒子数误差。该问题具有科学依据，提法明确，且所有必需的参数均已提供。我现在将进行分步解答。\n\n问题的核心在于两种自洽场 (SCF) 程序之间的区别。第一种，我们可以称之为“真实”程序，它正确地考虑了能量泛函中所有与密度相关的项。第二种，即“错误”程序，忽略了一个被称为重排项的特定密度依赖贡献。我们将通过比较从“错误”程序中获得的粒子数与用于建立“真实”参考态的目标粒子数，来量化这种差异。\n\n能量泛函给出如下：\n$$\nE[\\{n_i\\}] = \\sum_{i=1}^L n_i \\, \\epsilon_i^{(0)} + \\frac{g}{2} N^2 + \\frac{h}{3} N^3\n$$\n其中 $N = \\sum_{i=1}^L n_i$ 是总粒子数，$\\{ \\epsilon_i^{(0)} \\}$ 是基础单粒子能量，$g$ 和 $h$ 是相互作用参数。\n\n从该泛函导出的单粒子能量为：\n$$\n\\epsilon_i(N) = \\frac{\\partial E}{\\partial n_i} = \\epsilon_i^{(0)} + g N + h N^2\n$$\n$h N^2$ 项是重排能。它的出现是因为粒子间的相互作用依赖于整体密度，改变单个能级 $n_i$ 的占据数会影响总粒子数 $N$，从而“重排”了所有其他粒子感受到的势。\n\n计算按规定分为三个主要步骤进行。\n\n### 步骤 1：确定真实化学势 $\\mu_{\\mathrm{true}}$\n\n首先，我们为一个具有固定目标粒子数 $N_{\\mathrm{target}}$ 的系统建立一个“真实”基态。在有限温度 $T$（$k_B=1$）的巨正则系综中，占据数 $n_i$ 由涉及化学势 $\\mu$ 的费米-狄拉克 (Fermi-Dirac) 分布确定：\n$$\nn_i = \\frac{1}{1 + \\exp\\!\\left( \\frac{\\epsilon_i(N) - \\mu}{T} \\right)}\n$$\n对于 $N = N_{\\mathrm{target}}$ 的真实系统，单粒子能量为 $\\epsilon_i(N_{\\mathrm{target}}) = \\epsilon_i^{(0)} + g N_{\\mathrm{target}} + h N_{\\mathrm{target}}^2$。必须调整化学势 $\\mu_{\\mathrm{true}}$，以确保这些占据数的总和等于目标粒子数。这导出了关于 $\\mu_{\\mathrm{true}}$ 的以下非线性方程：\n$$\nN_{\\mathrm{target}} = \\sum_{i=1}^L \\frac{1}{1 + \\exp\\!\\left( \\frac{\\epsilon_i^{(0)} + g N_{\\mathrm{target}} + h N_{\\mathrm{target}}^2 - \\mu_{\\mathrm{true}}}{T} \\right)}\n$$\n基础能量定义为 $\\epsilon_i^{(0)} = \\Delta \\cdot (i - 1)$，其中 $i=1, \\dots, L$。方程的右边是 $\\mu_{\\mathrm{true}}$ 的一个单调递增函数。因此，$\\mu_{\\mathrm{true}}$ 的唯一解存在，并且可以使用数值求根算法（例如 Brent-Dekker 方法 (`brentq`)）高效地找到。我们定义一个残差函数 $f(\\mu) = (\\sum_i n_i(\\mu)) - N_{\\mathrm{target}}$，并找到使 $f(\\mu_{\\mathrm{true}}) = 0$ 的根 $\\mu_{\\mathrm{true}}$。\n\n### 步骤 2：使用不正确的哈密顿量进行自洽迭代\n\n接下来，我们在步骤 1 中确定的固定化学势 $\\mu = \\mu_{\\mathrm{true}}$ 下执行 SCF 迭代。然而，在这一步中，我们使用了一个忽略了重排项的不正确哈密顿量。单粒子能量现在依赖于迭代中的粒子数 $N^{(k)}$，形式如下：\n$$\n\\epsilon_i^{\\mathrm{wrong}}(N^{(k)}) = \\epsilon_i^{(0)} + g N^{(k)}\n$$\n不动点迭代过程如下，从一个初始猜测（例如 $N^{(0)} = N_{\\mathrm{target}}$）开始：\n$$\nN_{\\mathrm{new}}^{(k)} = \\sum_{i=1}^L \\frac{1}{1 + \\exp\\!\\left( \\frac{\\epsilon_i^{(0)} + g N^{(k)} - \\mu_{\\mathrm{true}}}{T} \\right)}\n$$\n为了稳定迭代并确保收敛，我们采用参数为 $\\alpha \\in (0, 1]$ 的线性混合：\n$$\nN^{(k+1)} = (1 - \\alpha) N^{(k)} + \\alpha N_{\\mathrm{new}}^{(k)}\n$$\n迭代持续进行，直到粒子数收敛到一个稳定值 $N_{\\mathrm{wrong}}^{(\\infty)}$，满足条件 $|N^{(k+1)} - N^{(k)}|  \\delta$，其中 $\\delta$ 是一个很小的容差。对于此实现，我们选择混合参数 $\\alpha=0.5$ 和容差 $\\delta=10^{-10}$。\n\n### 步驟 3：計算粒子數偏差\n\n未能包含重排项会导致一个热力学上不自洽的状态。通过固定 $\\mu=\\mu_{\\mathrm{true}}$（此值由完整的哈密顿量确定），“错误”的 SCF 程序将收敛到一个通常不同于 $N_{\\mathrm{target}}$ 的粒子数 $N_{\\mathrm{wrong}}^{(\\infty)}$。偏差计算如下：\n$$\n\\Delta N = N_{\\mathrm{wrong}}^{(\\infty)} - N_{\\mathrm{target}}\n$$\n这个量 $\\Delta N$ 衡量了在这些特定条件下因忽略重排项而引入的误差。当重排参数 $h=0$ 时，“错误”和“真实”的哈密顿量是相同的，我们预期 $\\Delta N = 0$。这可以作为对数值实现的一个关键验证。对于 $h>0$，我们预期 $\\Delta N \\ne 0$。\n\n以下程序为每个提供的测试用例实现了这三个步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Implements the Hartree-Fock test calculation to quantify the impact\n    of neglecting rearrangement terms on particle-number conservation.\n    \"\"\"\n    # Test Suite: (L, Delta, g, h, T, N_target)\n    test_cases = [\n        (100, 1.0, 0.4, 0.02, 0.5, 20.0),  # Case A\n        (100, 1.0, 0.4, 0.0, 0.5, 20.0),   # Case B\n        (200, 0.5, 0.3, 0.02, 0.05, 10.0),  # Case C\n        (150, 0.8, 0.2, 0.02, 0.8, 30.0),  # Case D\n        (30, 1.2, 0.5, 0.03, 0.4, 12.0),    # Case E\n    ]\n\n    results = []\n    \n    # Parameters for the SCF iteration\n    alpha = 0.5  # Mixing parameter\n    delta = 1e-10  # Convergence tolerance\n    max_iter = 1000  # Maximum number of iterations\n\n    for case in test_cases:\n        L, Delta, g, h, T, N_target = case\n        \n        # Base single-particle energies: eps_i(0) = Delta * (i-1) for i=1..L\n        eps0 = Delta * np.arange(L)\n        \n        # --- Step 1: Find the true chemical potential, mu_true ---\n        # The single-particle energies are fixed for this calculation, using N_target\n        full_eps = eps0 + g * N_target + h * N_target**2\n        \n        # Define the residual function for the root finder.\n        # It calculates the difference between the computed N and N_target for a given mu.\n        def residual_N_for_mu(mu):\n            # Using a safeguard against overflow in np.exp\n            arg = (full_eps - mu) / T\n            # Clip argument to avoid overflow in exp for large positive values\n            # and to maintain precision for large negative values.\n            arg = np.clip(arg, -700, 700)\n            n_occupations = 1.0 / (1.0 + np.exp(arg))\n            return np.sum(n_occupations) - N_target\n            \n        # Find mu_true using a robust root-finding algorithm (Brent's method)\n        # The bracket is chosen to be very wide to be safe for all test cases.\n        sol = root_scalar(residual_N_for_mu, bracket=[-500, 500], method='brentq')\n        mu_true = sol.root\n        \n        # --- Step 2: Perform the 'wrong' SCF iteration ---\n        N_k = N_target  # Initial guess for the particle number\n        \n        N_wrong_inf = 0.0\n        for i in range(max_iter):\n            # Calculate N_new using the wrong Hamiltonian (h=0) and fixed mu_true\n            wrong_eps = eps0 + g * N_k\n            \n            arg = (wrong_eps - mu_true) / T\n            arg = np.clip(arg, -700, 700)\n            n_wrong = 1.0 / (1.0 + np.exp(arg))\n            N_new = np.sum(n_wrong)\n            \n            # Apply linear mixing for stability\n            N_k_plus_1 = (1.0 - alpha) * N_k + alpha * N_new\n            \n            # Check for convergence\n            if np.abs(N_k_plus_1 - N_k)  delta:\n                N_wrong_inf = N_k_plus_1\n                break\n            \n            N_k = N_k_plus_1\n        else:\n            # If the loop completes without converging\n            N_wrong_inf = N_k # Use the last calculated value\n        \n        # --- Step 3: Calculate the particle-number deviation ---\n        delta_N = N_wrong_inf - N_target\n        results.append(delta_N)\n\n    # Format the final results as specified in the problem statement\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}