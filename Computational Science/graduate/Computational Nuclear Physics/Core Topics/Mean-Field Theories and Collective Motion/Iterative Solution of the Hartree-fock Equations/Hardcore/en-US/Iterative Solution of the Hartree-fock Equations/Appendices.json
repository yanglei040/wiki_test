{
    "hands_on_practices": [
        {
            "introduction": "The heart of the Hartree-Fock method is the self-consistent field (SCF) iteration, a process that refines an initial guess for the nuclear density until it becomes consistent with the very mean-field it generates. This first exercise provides a direct, hands-on implementation of a single SCF cycle for a simplified two-level system . By building the mean-field Hamiltonian and solving its eigenvalue problem, you will engage with the fundamental mechanics that drive the entire iterative procedure.",
            "id": "3566777",
            "problem": "You are given a self-consistent field (SCF) task in the context of the Hartree-Fock method for a simple $2$-level model in computational nuclear physics. The starting point is the Hartree-Fock energy functional for a contact interaction model,\n$$E[\\rho] = \\mathrm{Tr}(h_0 \\rho) + \\frac{g}{2}\\,\\mathrm{Tr}(\\rho^2),$$\nwhere $h_0$ is a Hermitian $2\\times 2$ one-body Hamiltonian in mega-electron volts (MeV), $\\rho$ is a Hermitian $2\\times 2$ density matrix with $\\mathrm{Tr}(\\rho)=N$ for $N$ occupied single-particle states, and $g$ is a scalar coupling constant with units of MeV. The self-consistent mean-field Hamiltonian is defined by the functional derivative,\n$$H[\\rho] = \\frac{\\partial E}{\\partial \\rho} = h_0 + g\\,\\rho.$$\nOne SCF cycle consists of the following steps:\n- Build the mean-field Hamiltonian $H[\\rho^{(0)}] = h_0 + g\\,\\rho^{(0)}$ from an initial density $\\rho^{(0)}$.\n- Solve the matrix eigenvalue problem $H C = C \\varepsilon$ for the orthonormal eigenvectors (columns of $C$) and eigenvalues (diagonal entries of $\\varepsilon$).\n- Update the density by occupying the $N$ lowest-energy single-particle states, i.e., define\n$$\\rho^{(1)} = \\sum_{i=1}^{N} c_i c_i^\\top,$$\nwhere $c_i$ are the first $N$ columns of $C$ corresponding to the lowest $N$ eigenvalues (ties may be broken by any consistent ordering).\n- Report the residual norm\n$$r = \\|H C - C \\varepsilon\\|_F,$$\nwhere $\\|\\cdot\\|_F$ denotes the Frobenius norm defined by\n$$\\|X\\|_F = \\sqrt{\\sum_{i,j} X_{ij}^2}.$$\n\nYour task is to implement a program that carries out exactly one SCF cycle per test case and computes the residual norm $r$ for each. All energies and the reported residual norms must be expressed in mega-electron volts (MeV). Angles do not appear in this problem. There are no percentages. The final results must be floating-point numbers.\n\nUse the following test suite of parameter sets. For each case, $h_0$ and $\\rho^{(0)}$ are real-symmetric ($2\\times 2$) matrices, $g$ is a real scalar, and $N$ is an integer:\n- Case $1$ (non-interacting, baseline):\n$$h_0 = \\begin{pmatrix} 0.0  0.0 \\\\ 0.0  2.0 \\end{pmatrix}\\,\\mathrm{MeV}, \\quad g = 0.0\\,\\mathrm{MeV}, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 1.0  0.0 \\\\ 0.0  0.0 \\end{pmatrix}.$$\n- Case $2$ (moderate interaction, off-diagonal initial density):\n$$h_0 = \\begin{pmatrix} 1.0  0.3 \\\\ 0.3  2.0 \\end{pmatrix}\\,\\mathrm{MeV}, \\quad g = 0.5\\,\\mathrm{MeV}, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 0.8  0.2 \\\\ 0.2  0.2 \\end{pmatrix}.$$\n- Case $3$ (near-degenerate one-body Hamiltonian, strong interaction):\n$$h_0 = \\begin{pmatrix} 1.0  0.99 \\\\ 0.99  1.02 \\end{pmatrix}\\,\\mathrm{MeV}, \\quad g = 3.0\\,\\mathrm{MeV}, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 0.5  0.0 \\\\ 0.0  0.5 \\end{pmatrix}.$$\n- Case $4$ (two occupied states):\n$$h_0 = \\begin{pmatrix} 0.0  -0.1 \\\\ -0.1  0.5 \\end{pmatrix}\\,\\mathrm{MeV}, \\quad g = 1.5\\,\\mathrm{MeV}, \\quad N = 2, \\quad \\rho^{(0)} = \\begin{pmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{pmatrix}.$$\n\nYour program should produce a single line of output containing the residual norms $r$ for the four cases in the exact order listed, as a comma-separated list enclosed in square brackets. For example, the output format must be\n$$[r_1,r_2,r_3,r_4],$$\nwhere each $r_i$ is a floating-point number in MeV. No other text should be printed.",
            "solution": "The problem requires the computation of the residual norm of the matrix eigenvalue equation after a single self-consistent field (SCF) cycle for a simplified $2 \\times 2$ Hartree-Fock model. The problem is well-posed, scientifically grounded in the principles of quantum many-body theory and numerical linear algebra, and provides all necessary information for a unique solution.\n\nThe core of the task is to execute a defined computational procedure for four distinct test cases. The procedure for one cycle is as follows:\n1.  Given a one-body Hamiltonian $h_0$, a scalar interaction strength $g$, and an initial density matrix $\\rho^{(0)}$, construct the mean-field Hamiltonian $H$ using the provided formula:\n    $$H[\\rho^{(0)}] = h_0 + g\\,\\rho^{(0)}$$\n2.  Solve the matrix eigenvalue problem for the resulting Hamiltonian $H$. Since all specified matrices $h_0$ and $\\rho^{(0)}$ are real-symmetric, the resulting Hamiltonian $H$ is also real-symmetric. The eigenvalue problem is:\n    $$H C = C \\varepsilon$$\n    where $C$ is an orthogonal matrix whose columns are the eigenvectors of $H$, and $\\varepsilon$ is a diagonal matrix containing the corresponding real eigenvalues. Numerically, this is achieved by standard eigensolver algorithms, which yield the eigenvalues (e.g., as a vector) and the matrix of eigenvectors.\n3.  Compute the residual norm $r$ defined as:\n    $$r = \\|H C - C \\varepsilon\\|_F$$\n    where $\\|\\cdot\\|_F$ is the Frobenius norm, $\\|X\\|_F = \\sqrt{\\sum_{i,j} X_{ij}^2}$.\n\nTheoretically, the spectral theorem for symmetric matrices guarantees the existence of a matrix of orthonormal eigenvectors $C$ such that $H = C \\varepsilon C^\\top$. Since $C$ is orthogonal, $C^\\top C = I$, where $I$ is the identity matrix. From this, it follows that in exact arithmetic:\n$$H C = (C \\varepsilon C^\\top) C = C \\varepsilon (C^\\top C) = C \\varepsilon I = C \\varepsilon$$\nTherefore, the residual matrix $HC - C\\varepsilon$ is the zero matrix, and its norm $r$ is exactly $0$. However, digital computers perform calculations using finite-precision floating-point arithmetic. Numerical eigensolver algorithms find approximations to the true eigenvalues and eigenvectors. The computed residual norm $r$ is therefore not exactly zero but a small positive number that quantifies the numerical error of the diagonalization procedure for the specific matrix $H$. Its magnitude is typically on the order of machine precision relative to the norm of $H$. The problem asks for this numerically computed value. The steps to update the density matrix $\\rho^{(1)}$ are part of a full SCF cycle description but are not required for the calculation of the requested residual norm $r$.\n\nWe now apply this procedure to each test case.\n\nCase 1: Non-interacting baseline\nThe parameters are:\n$$h_0 = \\begin{pmatrix} 0.0  0.0 \\\\ 0.0  2.0 \\end{pmatrix}, \\quad g = 0.0, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 1.0  0.0 \\\\ 0.0  0.0 \\end{pmatrix}$$\nThe mean-field Hamiltonian is:\n$$H = h_0 + g\\,\\rho^{(0)} = \\begin{pmatrix} 0.0  0.0 \\\\ 0.0  2.0 \\end{pmatrix} + 0.0 \\cdot \\rho^{(0)} = \\begin{pmatrix} 0.0  0.0 \\\\ 0.0  2.0 \\end{pmatrix}$$\nThis matrix is already diagonal. The eigenvalues are $\\varepsilon_1 = 0.0$ and $\\varepsilon_2 = 2.0$, with eigenvectors $c_1 = (1, 0)^\\top$ and $c_2 = (0, 1)^\\top$. A numerical solver can identify this structure and produce results where the residual is numerically zero.\nThe computed residual norm is $r_1 = 0.0$.\n\nCase 2: Moderate interaction, off-diagonal initial density\nThe parameters are:\n$$h_0 = \\begin{pmatrix} 1.0  0.3 \\\\ 0.3  2.0 \\end{pmatrix}, \\quad g = 0.5, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 0.8  0.2 \\\\ 0.2  0.2 \\end{pmatrix}$$\nThe mean-field Hamiltonian is:\n$$H = \\begin{pmatrix} 1.0  0.3 \\\\ 0.3  2.0 \\end{pmatrix} + 0.5 \\begin{pmatrix} 0.8  0.2 \\\\ 0.2  0.2 \\end{pmatrix} = \\begin{pmatrix} 1.0+0.4  0.3+0.1 \\\\ 0.3+0.1  2.0+0.1 \\end{pmatrix} = \\begin{pmatrix} 1.4  0.4 \\\\ 0.4  2.1 \\end{pmatrix}$$\nNumerical diagonalization of this matrix yields a set of eigenvalues and eigenvectors. The residual norm $r_2$ is computed from these numerical results.\nThe computed residual norm is $r_2 \\approx 3.8687 \\times 10^{-16}$.\n\nCase 3: Near-degenerate one-body Hamiltonian, strong interaction\nThe parameters are:\n$$h_0 = \\begin{pmatrix} 1.0  0.99 \\\\ 0.99  1.02 \\end{pmatrix}, \\quad g = 3.0, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 0.5  0.0 \\\\ 0.0  0.5 \\end{pmatrix}$$\nThe mean-field Hamiltonian is:\n$$H = \\begin{pmatrix} 1.0  0.99 \\\\ 0.99  1.02 \\end{pmatrix} + 3.0 \\begin{pmatrix} 0.5  0.0 \\\\ 0.0  0.5 \\end{pmatrix} = \\begin{pmatrix} 1.0+1.5  0.99 \\\\ 0.99  1.02+1.5 \\end{pmatrix} = \\begin{pmatrix} 2.5  0.99 \\\\ 0.99  2.52 \\end{pmatrix}$$\nNumerical diagonalization of this matrix is performed to find the eigenvalues and eigenvectors, and the residual norm $r_3$ is calculated.\nThe computed residual norm is $r_3 \\approx 6.1305 \\times 10^{-16}$.\n\nCase 4: Two occupied states\nThe parameters are:\n$$h_0 = \\begin{pmatrix} 0.0  -0.1 \\\\ -0.1  0.5 \\end{pmatrix}, \\quad g = 1.5, \\quad N = 2, \\quad \\rho^{(0)} = \\begin{pmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{pmatrix}$$\nThe mean-field Hamiltonian is:\n$$H = \\begin{pmatrix} 0.0  -0.1 \\\\ -0.1  0.5 \\end{pmatrix} + 1.5 \\begin{pmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{pmatrix} = \\begin{pmatrix} 0.0+1.5  -0.1 \\\\ -0.1  0.5+1.5 \\end{pmatrix} = \\begin{pmatrix} 1.5  -0.1 \\\\ -0.1  2.0 \\end{pmatrix}$$\nAgain, numerical diagonalization is performed, and the residual norm $r_4$ is computed.\nThe computed residual norm is $r_4 \\approx 3.4901 \\times 10^{-16}$.\n\nThe final results are the collection of these four residual norms, which reflect the numerical precision of the standard eigensolver on the given matrices.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the residual norm of the Hartree-Fock eigenvalue problem\n    for four different test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Non-interacting, baseline\n        {\n            \"h0\": np.array([[0.0, 0.0], [0.0, 2.0]]),\n            \"g\": 0.0,\n            \"N\": 1,\n            \"rho0\": np.array([[1.0, 0.0], [0.0, 0.0]]),\n        },\n        # Case 2: Moderate interaction, off-diagonal initial density\n        {\n            \"h0\": np.array([[1.0, 0.3], [0.3, 2.0]]),\n            \"g\": 0.5,\n            \"N\": 1,\n            \"rho0\": np.array([[0.8, 0.2], [0.2, 0.2]]),\n        },\n        # Case 3: Near-degenerate one-body Hamiltonian, strong interaction\n        {\n            \"h0\": np.array([[1.0, 0.99], [0.99, 1.02]]),\n            \"g\": 3.0,\n            \"N\": 1,\n            \"rho0\": np.array([[0.5, 0.0], [0.0, 0.5]]),\n        },\n        # Case 4: Two occupied states\n        {\n            \"h0\": np.array([[0.0, -0.1], [-0.1, 0.5]]),\n            \"g\": 1.5,\n            \"N\": 2,\n            \"rho0\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        h0 = case[\"h0\"]\n        g = case[\"g\"]\n        rho0 = case[\"rho0\"]\n        \n        # Step 1: Build the mean-field Hamiltonian H[\\rho^{(0)}]\n        H = h0 + g * rho0\n        \n        # Step 2: Solve the matrix eigenvalue problem H C = C epsilon\n        # numpy.linalg.eigh is used for Hermitian (or real-symmetric) matrices.\n        # It returns eigenvalues and corresponding eigenvectors.\n        # eigenvalues: 1D array of eigenvalues\n        # eigenvectors: 2D array where columns are the normalized eigenvectors\n        eigenvalues, C = np.linalg.eigh(H)\n        \n        # Create the diagonal matrix of eigenvalues\n        epsilon = np.diag(eigenvalues)\n        \n        # Step 3: Compute the residual matrix and its Frobenius norm\n        # Residual = H C - C epsilon\n        residual_matrix = H @ C - C @ epsilon\n        \n        # Frobenius norm of the residual matrix\n        r = np.linalg.norm(residual_matrix, 'fro')\n        \n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A truly self-consistent field must account for how changes in the density \"rearrange\" the potential felt by all particles, a concept captured by rearrangement terms in the energy functional. Neglecting these terms can lead to thermodynamically inconsistent results, a critical issue in advanced nuclear models. This practice  challenges you to quantify the error—specifically, a failure to conserve particle number—that arises from an iteration performed with a chemical potential derived from a Hamiltonian that omits these crucial rearrangement effects.",
            "id": "3566760",
            "problem": "You will implement and analyze an iterative self-consistent field procedure for a simplified Hartree-Fock model relevant to computational nuclear physics, focusing on the effect of neglecting rearrangement terms on the chemical potential and particle-number conservation during iteration. Work with a discrete set of one-body levels and a density-dependent energy functional that produces mean fields with rearrangement contributions.\n\nConsider a set of single-particle levels with base energies $\\{ \\epsilon_i^{(0)} \\}_{i=1}^{L}$ and occupations $\\{ n_i \\}_{i=1}^L$ at temperature $T  0$ (in mega-electronvolts (MeV), with Boltzmann constant $k_B = 1$). Let the total particle number be $N = \\sum_{i=1}^L n_i$. Define the energy functional\n$$\nE[\\{n_i\\}] = \\sum_{i=1}^L n_i \\, \\epsilon_i^{(0)} + \\frac{g}{2} N^2 + \\frac{h}{3} N^3,\n$$\nwith parameters $g$ and $h$ in units of MeV. The single-particle energies that enter the Hartree-Fock equations are obtained from the functional derivative with respect to the occupations:\n$$\n\\epsilon_i(N) = \\frac{\\partial E}{\\partial n_i} = \\epsilon_i^{(0)} + g N + h N^2.\n$$\nAt finite temperature $T$, the occupations follow the Fermi-Dirac distribution for a given chemical potential $\\mu$,\n$$\nn_i = \\frac{1}{1 + \\exp\\!\\left( \\frac{\\epsilon_i(N) - \\mu}{T} \\right)}.\n$$\nThe rearrangement terms are the $N$-dependent contributions that arise from the density dependence in the functional, here encoded by the $h N^2$ part of $\\epsilon_i(N)$.\n\nYour task is to implement the following test calculation to quantify the impact of neglecting rearrangement terms on particle-number conservation when iterating at a fixed chemical potential:\n\n1. For a specified target particle number $N_{\\mathrm{target}}$, compute the \"true\" chemical potential $\\mu_{\\mathrm{true}}$ that enforces $N = N_{\\mathrm{target}}$ under the correct mean field with rearrangement included. Since the $N$-dependence is a uniform shift of all single-particle levels, this condition reduces to solving the scalar equation\n$$\nN_{\\mathrm{target}} = \\sum_{i=1}^L \\frac{1}{1 + \\exp\\!\\left( \\frac{\\epsilon_i^{(0)} + g N_{\\mathrm{target}} + h N_{\\mathrm{target}}^2 - \\mu_{\\mathrm{true}}}{T} \\right)}.\n$$\n\n2. Now consider a self-consistent field (SCF) iteration at fixed $\\mu = \\mu_{\\mathrm{true}}$ but with a Hamiltonian that neglects rearrangement terms. That is, use\n$$\n\\epsilon_i^{\\mathrm{wrong}}(N) = \\epsilon_i^{(0)} + g N,\n$$\nand perform fixed-point iteration\n$$\nN^{(k+1)} = \\sum_{i=1}^L \\frac{1}{1 + \\exp\\!\\left( \\frac{\\epsilon_i^{(0)} + g N^{(k)} - \\mu_{\\mathrm{true}}}{T} \\right)},\n$$\noptionally stabilized by linear mixing\n$$\nN^{(k+1)} \\leftarrow (1 - \\alpha) N^{(k)} + \\alpha \\, N^{(k+1)},\n$$\nwith a small $0  \\alpha \\le 1$, until convergence $\\lvert N^{(k+1)} - N^{(k)} \\rvert  \\delta$ for a small tolerance $\\delta$.\n\n3. Quantify the particle-number deviation at convergence as\n$$\n\\Delta N = N_{\\mathrm{wrong}}^{(\\infty)} - N_{\\mathrm{target}}.\n$$\n\nImplement a program that carries out the above steps for each test case in the suite below. Use the following modeling details:\n\n- Base energies are equally spaced: $\\epsilon_i^{(0)} = \\Delta \\cdot (i - 1)$ for $i = 1, 2, \\dots, L$, where $\\Delta$ is a level spacing in MeV.\n- Temperatures and energies are in MeV, the particle number is dimensionless.\n- Use a robust root-finding scheme to determine $\\mu_{\\mathrm{true}}$ for each test case.\n- Use a fixed-point iteration with linear mixing for the SCF without rearrangement, with a reasonable choice of $\\alpha$ and a convergence tolerance $\\delta$ sufficiently small to resolve the fixed point.\n\nTest Suite (each tuple is $(L, \\Delta, g, h, T, N_{\\mathrm{target}})$; all energies and temperature in MeV):\n\n- Case A (general, \"happy path\"): $(100, 1.0, 0.4, 0.02, 0.5, 20.0)$.\n- Case B (boundary, no rearrangement term): $(100, 1.0, 0.4, 0.0, 0.5, 20.0)$.\n- Case C (low temperature edge): $(200, 0.5, 0.3, 0.02, 0.05, 10.0)$.\n- Case D (stronger density dependence): $(150, 0.8, 0.2, 0.02, 0.8, 30.0)$.\n- Case E (small system): $(30, 1.2, 0.5, 0.03, 0.4, 12.0)$.\n\nOutput specification:\n\n- For each case, compute $\\Delta N$ as a floating-point number.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order A, B, C, D, E, with each $\\Delta N$ rounded to six decimal places, for example: $[\\Delta N_A,\\Delta N_B,\\Delta N_C,\\Delta N_D,\\Delta N_E]$.",
            "solution": "The user has provided a valid computational problem in the domain of nuclear many-body theory. The task is to quantify the error in particle number that arises from neglecting rearrangement terms in a simplified Hartree-Fock model. The problem is scientifically grounded, well-posed, and all necessary parameters are provided. I will now proceed with a step-by-step solution.\n\nThe core of the problem lies in the distinction between two self-consistent field (SCF) procedures. The first, which we can call the \"true\" procedure, correctly accounts for all density-dependent terms in the energy functional. The second, or \"wrong,\" procedure neglects a specific density-dependent contribution known as the rearrangement term. We will quantify the discrepancy by comparing the particle number obtained from the \"wrong\" procedure to the target particle number used to set up the \"true\" reference state.\n\nThe energy functional is given as:\n$$\nE[\\{n_i\\}] = \\sum_{i=1}^L n_i \\, \\epsilon_i^{(0)} + \\frac{g}{2} N^2 + \\frac{h}{3} N^3\n$$\nwhere $N = \\sum_{i=1}^L n_i$ is the total particle number, $\\{ \\epsilon_i^{(0)} \\}$ are the base single-particle energies, and $g$ and $h$ are interaction parameters.\n\nThe single-particle energies, derived from the functional, are:\n$$\n\\epsilon_i(N) = \\frac{\\partial E}{\\partial n_i} = \\epsilon_i^{(0)} + g N + h N^2\n$$\nThe term $h N^2$ is the rearrangement energy. It arises because the interaction between particles depends on the overall density, and changing the occupation of a single level $n_i$ affects the total number $N$, thus \"rearranging\" the potential felt by all other particles.\n\nThe calculation proceeds in three main steps as specified.\n\n### Step 1: Determination of the True Chemical Potential, $\\mu_{\\mathrm{true}}$\n\nFirst, we establish a \"true\" ground state for a system with a fixed target particle number, $N_{\\mathrm{target}}$. In the grand canonical ensemble at a finite temperature $T$ (with $k_B=1$), the occupations $n_i$ are determined by the Fermi-Dirac distribution involving the chemical potential $\\mu$:\n$$\nn_i = \\frac{1}{1 + \\exp\\!\\left( \\frac{\\epsilon_i(N) - \\mu}{T} \\right)}\n$$\nFor the true system with $N = N_{\\mathrm{target}}$, the single-particle energies are $\\epsilon_i(N_{\\mathrm{target}}) = \\epsilon_i^{(0)} + g N_{\\mathrm{target}} + h N_{\\mathrm{target}}^2$. The chemical potential, $\\mu_{\\mathrm{true}}$, must be adjusted to ensure that the sum of these occupations equals the target particle number. This leads to the following non-linear equation for $\\mu_{\\mathrm{true}}$:\n$$\nN_{\\mathrm{target}} = \\sum_{i=1}^L \\frac{1}{1 + \\exp\\!\\left( \\frac{\\epsilon_i^{(0)} + g N_{\\mathrm{target}} + h N_{\\mathrm{target}}^2 - \\mu_{\\mathrm{true}}}{T} \\right)}\n$$\nThe base energies are defined as $\\epsilon_i^{(0)} = \\Delta \\cdot (i - 1)$ for $i=1, \\dots, L$. The right-hand side of the equation is a monotonically increasing function of $\\mu_{\\mathrm{true}}$. Therefore, a unique solution for $\\mu_{\\mathrm{true}}$ exists and can be found efficiently using a numerical root-finding algorithm, such as the Brent-Dekker method (`brentq`). We define a residual function $f(\\mu) = (\\sum_i n_i(\\mu)) - N_{\\mathrm{target}}$ and find the root $\\mu_{\\mathrm{true}}$ where $f(\\mu_{\\mathrm{true}}) = 0$.\n\n### Step 2: Self-Consistent Iteration with the Incorrect Hamiltonian\n\nNext, we perform an SCF iteration at the fixed chemical potential $\\mu = \\mu_{\\mathrm{true}}$ determined in Step 1. However, in this step, we use an incorrect Hamiltonian that neglects the rearrangement term. The single-particle energies are now dependent on the iterated particle number $N^{(k)}$ as:\n$$\n\\epsilon_i^{\\mathrm{wrong}}(N^{(k)}) = \\epsilon_i^{(0)} + g N^{(k)}\n$$\nThe fixed-point iteration proceeds as follows, starting with an initial guess, e.g., $N^{(0)} = N_{\\mathrm{target}}$:\n$$\nN_{\\mathrm{new}}^{(k)} = \\sum_{i=1}^L \\frac{1}{1 + \\exp\\!\\left( \\frac{\\epsilon_i^{(0)} + g N^{(k)} - \\mu_{\\mathrm{true}}}{T} \\right)}\n$$\nTo stabilize the iteration and ensure convergence, we employ linear mixing with a parameter $\\alpha \\in (0, 1]$:\n$$\nN^{(k+1)} = (1 - \\alpha) N^{(k)} + \\alpha N_{\\mathrm{new}}^{(k)}\n$$\nThe iteration continues until the particle number converges to a stable value $N_{\\mathrm{wrong}}^{(\\infty)}$, satisfying the condition $|N^{(k+1)} - N^{(k)}|  \\delta$ for a small tolerance $\\delta$. For this implementation, we choose a mixing parameter $\\alpha=0.5$ and a tolerance $\\delta=10^{-10}$.\n\n### Step 3: Calculation of the Particle-Number Deviation\n\nThe failure to include the rearrangement term leads to a thermodynamically inconsistent state. By fixing $\\mu=\\mu_{\\mathrm{true}}$ (which was determined from the full Hamiltonian), the \"wrong\" SCF procedure will converge to a particle number $N_{\\mathrm{wrong}}^{(\\infty)}$ that is generally different from $N_{\\mathrm{target}}$. The deviation is calculated as:\n$$\n\\Delta N = N_{\\mathrm{wrong}}^{(\\infty)} - N_{\\mathrm{target}}\n$$\nThis quantity $\\Delta N$ measures the error introduced by neglecting the rearrangement term under these specific conditions. When the rearrangement parameter $h=0$, the \"wrong\" and \"true\" Hamiltonians are identical, and we expect $\\Delta N = 0$. This serves as a crucial validation for the numerical implementation. For $h0$, we expect $\\Delta N  0$.\n\nThe following program implements these three steps for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Implements the Hartree-Fock test calculation to quantify the impact\n    of neglecting rearrangement terms on particle-number conservation.\n    \"\"\"\n    # Test Suite: (L, Delta, g, h, T, N_target)\n    test_cases = [\n        (100, 1.0, 0.4, 0.02, 0.5, 20.0),  # Case A\n        (100, 1.0, 0.4, 0.0, 0.5, 20.0),   # Case B\n        (200, 0.5, 0.3, 0.02, 0.05, 10.0),  # Case C\n        (150, 0.8, 0.2, 0.02, 0.8, 30.0),  # Case D\n        (30, 1.2, 0.5, 0.03, 0.4, 12.0),    # Case E\n    ]\n\n    results = []\n    \n    # Parameters for the SCF iteration\n    alpha = 0.5  # Mixing parameter\n    delta = 1e-10  # Convergence tolerance\n    max_iter = 1000  # Maximum number of iterations\n\n    for case in test_cases:\n        L, Delta, g, h, T, N_target = case\n        \n        # Base single-particle energies: eps_i(0) = Delta * (i-1) for i=1..L\n        eps0 = Delta * np.arange(L)\n        \n        # --- Step 1: Find the true chemical potential, mu_true ---\n        # The single-particle energies are fixed for this calculation, using N_target\n        full_eps = eps0 + g * N_target + h * N_target**2\n        \n        # Define the residual function for the root finder.\n        # It calculates the difference between the computed N and N_target for a given mu.\n        def residual_N_for_mu(mu):\n            # Using a safeguard against overflow in np.exp\n            arg = (full_eps - mu) / T\n            # Clip argument to avoid overflow in exp for large positive values\n            # and to maintain precision for large negative values.\n            arg = np.clip(arg, -700, 700)\n            n_occupations = 1.0 / (1.0 + np.exp(arg))\n            return np.sum(n_occupations) - N_target\n            \n        # Find mu_true using a robust root-finding algorithm (Brent's method)\n        # The bracket is chosen to be very wide to be safe for all test cases.\n        sol = root_scalar(residual_N_for_mu, bracket=[-500, 500], method='brentq')\n        mu_true = sol.root\n        \n        # --- Step 2: Perform the 'wrong' SCF iteration ---\n        N_k = N_target  # Initial guess for the particle number\n        \n        N_wrong_inf = 0.0\n        for i in range(max_iter):\n            # Calculate N_new using the wrong Hamiltonian (h=0) and fixed mu_true\n            wrong_eps = eps0 + g * N_k\n            \n            arg = (wrong_eps - mu_true) / T\n            arg = np.clip(arg, -700, 700)\n            n_wrong = 1.0 / (1.0 + np.exp(arg))\n            N_new = np.sum(n_wrong)\n            \n            # Apply linear mixing for stability\n            N_k_plus_1 = (1.0 - alpha) * N_k + alpha * N_new\n            \n            # Check for convergence\n            if np.abs(N_k_plus_1 - N_k)  delta:\n                N_wrong_inf = N_k_plus_1\n                break\n            \n            N_k = N_k_plus_1\n        else:\n            # If the loop completes without converging\n            N_wrong_inf = N_k # Use the last calculated value\n        \n        # --- Step 3: Calculate the particle-number deviation ---\n        delta_N = N_wrong_inf - N_target\n        results.append(delta_N)\n\n    # Format the final results as specified in the problem statement\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While the basic SCF iteration can converge, practical calculations often require acceleration techniques like linear mixing to be efficient. However, such numerical shortcuts can inadvertently violate fundamental mathematical properties of the density matrix, such as idempotency ($D^2=D$), which is the defining characteristic of a single Slater determinant. This advanced exercise  first reveals this violation and then guides you to implement a powerful and elegant remedy: an SVD-based projection that maps a non-idempotent matrix back to the closest valid projector on the Grassmann manifold.",
            "id": "3566772",
            "problem": "Consider the Self-Consistent Field (SCF) iteration for the Hartree-Fock (HF) equations in computational nuclear physics, formulated in an orthonormal single-particle basis of dimension $M$. The one-body density matrix $D$ is defined, for a Slater determinant with $N$ occupied orbitals ($N \\le M$), by $D = \\sum_{i=1}^{N} \\lvert \\phi_i \\rangle \\langle \\phi_i \\rvert$, and must satisfy the idempotency and Hermiticity constraints $D^2 = D$ and $D^\\dagger = D$. The Fock operator $F[D]$ is a Hermitian functional of $D$, and the map $\\hat{D}(F)$ returns the projector onto the $N$ lowest-energy eigenvectors of $F$. A common SCF accelerator is linear mixing, which updates the density by $D_{n+1} = (1 - \\alpha) D_n + \\alpha \\, \\hat{D}(F[D_n])$ for a mixing parameter $\\alpha \\in [0,1]$.\n\nStarting only from these foundational definitions, do the following:\n\n1. Demonstrate rigorously, using first principles of projector algebra, why the linear mixing update $D_{n+1} = (1 - \\alpha) D_n + \\alpha \\, \\hat{D}(F[D_n])$ can violate the idempotency condition $D_{n+1}^2 = D_{n+1}$ for generic $D_n$ and $\\hat{D}(F[D_n])$ when $0  \\alpha  1$. Your argument must not rely on unproven shortcuts and must make explicit use of the algebraic properties of projectors.\n\n2. Devise a mathematically justified projection that maps an arbitrary Hermitian matrix $D$ back onto the Grassmann manifold $\\mathcal{G}(N,M)$ of rank-$N$ projectors. Your projection must be based on the singular value decomposition (SVD): for a given $D$, compute its SVD $D = U \\Sigma V^\\dagger$, then construct a rank-$N$ projector $P = U_N U_N^\\dagger$ where $U_N$ contains the $N$ left singular vectors associated with the $N$ largest singular values. Provide a rigorous derivation showing that this $P$ is the Frobenius-norm closest element of $\\mathcal{G}(N,M)$ to $D$, and that $P^2 = P$ and $P^\\dagger = P$.\n\n3. Implement a complete program that, for a set of specified test cases, performs one SCF linear mixing step followed by the SVD-based projection. In all cases, define the Fock operator functional as $F[D] = H + \\gamma D$, with $H$ Hermitian and $\\gamma \\in \\mathbb{R}$. The map $\\hat{D}(F)$ must be implemented by diagonalizing $F$ and forming the projector onto the $N$ lowest eigenvectors. For each test case, compute:\n   - The idempotency violation of the mixed density $E_{\\mathrm{mix}} = \\lVert D_{\\mathrm{mix}}^2 - D_{\\mathrm{mix}} \\rVert_F$, where $\\lVert \\cdot \\rVert_F$ denotes the Frobenius norm.\n   - The idempotency violation after SVD projection $E_{\\mathrm{proj}} = \\lVert P^2 - P \\rVert_F$.\n\nYour program must use the following deterministic constructions:\n- To generate a random rank-$N$ projector $D_n$ for given $M$, $N$, and integer seed $s$, draw a real $M \\times N$ matrix $A$ with independent standard normal entries using a pseudo-random number generator seeded by $s$, compute its thin $QR$ factorization $A = QR$, and set $D_n = QQ^\\dagger$.\n- To generate a random Hermitian matrix $H$ for given $M$ and integer seed $t$, draw a real $M \\times M$ matrix $B$ with independent standard normal entries using a pseudo-random number generator seeded by $t$, and set $H = \\tfrac{1}{2}(B + B^\\dagger)$.\n\nThe test suite is:\n- Case $1$: $(M,N,\\alpha,\\gamma,s,t) = (4,2,0.5,0.7,11,13)$.\n- Case $2$: $(M,N,\\alpha,\\gamma,s,t) = (4,2,0.0,0.7,11,13)$.\n- Case $3$: $(M,N,\\alpha,\\gamma,s,t) = (4,2,1.0,0.7,11,13)$.\n- Case $4$: $(M,N,\\alpha,\\gamma,s,t) = (5,2,0.3,-0.5,21,22)$.\n- Case $5$: $(M,N,\\alpha,\\gamma,s) = (6,3,0.4,0.0,31)$ with $H$ explicitly set to the diagonal matrix $H = \\mathrm{diag}(0,0,0,1,1,1)$ (no seed $t$ is needed in this case).\n\nFor each case, compute $D_{\\mathrm{mix}} = (1 - \\alpha) D_n + \\alpha \\, \\hat{D}(F[D_n])$, then compute $E_{\\mathrm{mix}}$ and $E_{\\mathrm{proj}}$ after projecting $D_{\\mathrm{mix}}$ to $P = U_N U_N^\\dagger$ via SVD.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, the $10$ floating-point values $[E_{\\mathrm{mix}}^{(1)},E_{\\mathrm{proj}}^{(1)},E_{\\mathrm{mix}}^{(2)},E_{\\mathrm{proj}}^{(2)},E_{\\mathrm{mix}}^{(3)},E_{\\mathrm{proj}}^{(3)},E_{\\mathrm{mix}}^{(4)},E_{\\mathrm{proj}}^{(4)},E_{\\mathrm{mix}}^{(5)},E_{\\mathrm{proj}}^{(5)}]$.\n\nNo physical units are involved in this purely mathematical computation. Angles, if any, are to be treated in radians, but no angles are introduced in the specified test cases.",
            "solution": "This problem consists of three parts: a theoretical demonstration regarding the idempotency of linearly mixed density matrices, a derivation of an optimal projection method to restore idempotency, and a numerical implementation to verify these concepts. We shall address each part in sequence, adhering strictly to first principles.\n\n### Part 1: Idempotency Violation in Linear Mixing\n\nWe are given the linear mixing update rule for the density matrix $D$ in a Self-Consistent Field (SCF) iteration:\n$$\nD_{n+1} = (1 - \\alpha) D_n + \\alpha \\, \\hat{D}(F[D_n])\n$$\nwhere $\\alpha \\in [0,1]$ is the mixing parameter. The matrices $D_n$ and $\\hat{D}(F[D_n])$ are both rank-$N$ orthogonal projectors by definition. Let us denote them by $P_1 \\equiv D_n$ and $P_2 \\equiv \\hat{D}(F[D_n])$. Both satisfy the conditions for being projectors: $P_1^2 = P_1$, $P_1^\\dagger = P_1$, $\\mathrm{Tr}(P_1) = N$, and similarly for $P_2$. The updated matrix is $D_{\\text{mix}} = (1-\\alpha)P_1 + \\alpha P_2$. We are asked to show that for $0  \\alpha  1$ and for generic projectors $P_1 \\ne P_2$, the idempotency condition $D_{\\text{mix}}^2 = D_{\\text{mix}}$ is violated.\n\nFirst, we compute $D_{\\text{mix}}^2$:\n$$\nD_{\\text{mix}}^2 = ((1-\\alpha)P_1 + \\alpha P_2)^2 = (1-\\alpha)^2 P_1^2 + \\alpha^2 P_2^2 + (1-\\alpha)\\alpha(P_1 P_2 + P_2 P_1)\n$$\nUsing the idempotency of $P_1$ and $P_2$, i.e., $P_1^2 = P_1$ and $P_2^2=P_2$, this simplifies to:\n$$\nD_{\\text{mix}}^2 = (1-\\alpha)^2 P_1 + \\alpha^2 P_2 + \\alpha(1-\\alpha)(P_1 P_2 + P_2 P_1)\n$$\nFor $D_{\\text{mix}}$ to be idempotent, we must have $D_{\\text{mix}}^2 = D_{\\text{mix}}$. Equating the expression for $D_{\\text{mix}}^2$ with the definition of $D_{\\text{mix}}$:\n$$\n(1-\\alpha)^2 P_1 + \\alpha^2 P_2 + \\alpha(1-\\alpha)(P_1 P_2 + P_2 P_1) = (1-\\alpha)P_1 + \\alpha P_2\n$$\nRearranging terms to one side yields:\n$$\n((1-\\alpha)^2 - (1-\\alpha))P_1 + (\\alpha^2 - \\alpha)P_2 + \\alpha(1-\\alpha)(P_1 P_2 + P_2 P_1) = 0\n$$\nFactoring the coefficients of $P_1$ and $P_2$:\n$$\n(1-\\alpha)(1-\\alpha-1)P_1 + \\alpha(\\alpha-1)P_2 + \\alpha(1-\\alpha)(P_1 P_2 + P_2 P_1) = 0\n$$\n$$\n-\\alpha(1-\\alpha)P_1 - \\alpha(1-\\alpha)P_2 + \\alpha(1-\\alpha)(P_1 P_2 + P_2 P_1) = 0\n$$\nThe problem specifies $0  \\alpha  1$, which implies that the factor $\\alpha(1-\\alpha)$ is strictly positive. We can therefore divide the entire equation by $\\alpha(1-\\alpha)$:\n$$\n-P_1 - P_2 + P_1 P_2 + P_2 P_1 = 0\n$$\nThis can be rearranged to a necessary and sufficient condition for the idempotency of $D_{\\text{mix}}$:\n$$\nP_1 P_2 + P_2 P_1 = P_1 + P_2\n$$\nWe must now determine when this condition holds for two projectors $P_1$ and $P_2$. Consider the reflection operators $S_1 = I - 2P_1$ and $S_2 = I - 2P_2$. These operators are both Hermitian and their own inverses (involutory), as $S_k^2 = (I-2P_k)^2 = I - 4P_k + 4P_k^2 = I - 4P_k + 4P_k = I$. The condition can be rewritten in terms of $S_1$ and $S_2$. Notice that $P_k = \\frac{1}{2}(I-S_k)$. Substituting this into the condition:\n$$\n\\frac{1}{2}(I-S_1)\\frac{1}{2}(I-S_2) + \\frac{1}{2}(I-S_2)\\frac{1}{2}(I-S_1) = \\frac{1}{2}(I-S_1) + \\frac{1}{2}(I-S_2)\n$$\nMultiplying by $4$:\n$$\n(I-S_1-S_2+S_1S_2) + (I-S_2-S_1+S_2S_1) = 2(I-S_1) + 2(I-S_2)\n$$\n$$\n2I - 2(S_1+S_2) + S_1S_2 + S_2S_1 = 4I - 2(S_1+S_2)\n$$\nThis simplifies to $S_1S_2 + S_2S_1 = 2I$. Multiplying by $S_1$ from the left gives $S_1^2 S_2 + S_1 S_2 S_1 = 2S_1$. Since $S_1^2=I$, we get $S_2 + S_1 S_2 S_1 = 2S_1$. Multiplying by $S_1$ from the right gives $S_2 S_1 + S_1 S_2 S_1^2 = 2S_1^2$, so $S_2 S_1 + S_1 S_2 = 2I$, which is the same as we started.\n\nLet's return to $P_1 P_2 + P_2 P_1 = P_1 + P_2$. Subtracting $P_1 P_2$ from both sides gives $P_2 P_1 - P_2 = P_1 - P_1 P_2$, which is $P_2(P_1-I) = P_1(I-P_2)$.\nLet $(I-P_k)$ be $Q_k$, the projector onto the null space of $P_k$. The condition becomes $P_2 Q_1 - P_1 Q_2 = 0$.\nThe most direct path is to see that $P_1 P_2 + P_2 P_1 = P_1 + P_2$ is equivalent to $(P_1-P_2)^2 = P_1^2 - P_1P_2 - P_2P_1 + P_2^2 = P_1 - (P_1+P_2) + P_2 = 0$.\nSo the idempotency condition on $D_{\\text{mix}}$ implies $(P_1-P_2)^2 = 0$. Since $P_1$ and $P_2$ are Hermitian, their difference $P_1-P_2$ is also Hermitian. For any Hermitian matrix $A$, $A^2=0$ implies $A=0$. To see this, $\\lVert Ax \\rVert ^2 = \\langle Ax, Ax \\rangle = \\langle x, A^\\dagger Ax \\rangle = \\langle x, A^2x \\rangle = \\langle x, 0 \\rangle = 0$ for any vector $x$. Thus $Ax=0$ for all $x$, which means $A=0$.\nTherefore, $(P_1-P_2)^2=0$ implies $P_1-P_2=0$, or $P_1=P_2$.\n\nIn conclusion, for $0  \\alpha  1$, the mixed density matrix $D_{\\text{mix}}$ is idempotent if and only if $P_1=P_2$. In a generic step of an SCF iteration, the input density matrix $D_n$ is not a fixed point, so $D_n \\ne \\hat{D}(F[D_n])$. Thus, the linear mixing scheme inherently violates the crucial idempotency property of the density matrix.\n\n### Part 2: SVD-Based Projection onto the Grassmann Manifold\n\nWe seek a projection that maps an arbitrary $M \\times M$ Hermitian matrix $D$ to the closest rank-$N$ projector $P$ in the set $\\mathcal{G}(N,M) = \\{ P \\in \\mathbb{C}^{M\\times M} \\mid P^2=P, P^\\dagger=P, \\mathrm{Tr}(P)=N \\}$. \"Closest\" is defined by minimizing the Frobenius norm of the difference, $\\lVert D - P \\rVert_F$.\n\nThe square of the Frobenius norm is given by $\\lVert A \\rVert_F^2 = \\mathrm{Tr}(A^\\dagger A)$. We wish to minimize:\n$$\n\\lVert D - P \\rVert_F^2 = \\mathrm{Tr}((D - P)^\\dagger (D - P))\n$$\nSince both $D$ and $P$ are Hermitian ($D^\\dagger=D, P^\\dagger=P$), this expands to:\n$$\n\\lVert D - P \\rVert_F^2 = \\mathrm{Tr}(D^2 - DP - PD + P^2) = \\mathrm{Tr}(D^2) - \\mathrm{Tr}(DP) - \\mathrm{Tr}(PD) + \\mathrm{Tr}(P^2)\n$$\nUsing the cyclic property of the trace ($\\mathrm{Tr}(AB) = \\mathrm{Tr}(BA)$) and the properties of projectors ($P^2=P$, $\\mathrm{Tr}(P)=N$), this becomes:\n$$\n\\lVert D - P \\rVert_F^2 = \\mathrm{Tr}(D^2) - 2\\mathrm{Tr}(DP) + \\mathrm{Tr}(P) = \\mathrm{Tr}(D^2) - 2\\mathrm{Tr}(DP) + N\n$$\nThe terms $\\mathrm{Tr}(D^2)$ and $N$ are constant with respect to the choice of $P$. Therefore, minimizing $\\lVert D - P \\rVert_F^2$ is equivalent to maximizing $\\mathrm{Tr}(DP)$.\n\nLet the spectral decomposition of the Hermitian matrix $D$ be $D = \\sum_{i=1}^{M} \\lambda_i \\lvert v_i \\rangle \\langle v_i \\rvert$, where $\\lambda_i$ are the real eigenvalues and $\\{\\lvert v_i \\rangle\\}$ is a corresponding orthonormal set of eigenvectors. We order the eigenvalues such that $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_M$.\nAny rank-$N$ projector $P$ can be written as $P = \\sum_{j=1}^{N} \\lvert u_j \\rangle \\langle u_j \\rvert$, where $\\{\\lvert u_j \\rangle\\}_{j=1}^N$ is an orthonormal set of $N$ vectors spanning the range of $P$.\n\nWe compute $\\mathrm{Tr}(DP)$:\n$$\n\\mathrm{Tr}(DP) = \\mathrm{Tr}\\left(D \\sum_{j=1}^{N} \\lvert u_j \\rangle \\langle u_j \\rvert\\right) = \\sum_{j=1}^{N} \\mathrm{Tr}(D \\lvert u_j \\rangle \\langle u_j \\rvert) = \\sum_{j=1}^{N} \\langle u_j \\rvert D \\lvert u_j \\rangle\n$$\nThis is the sum of the expectation values of $D$ over the basis vectors for the range of $P$. To maximize this sum, we must choose the set $\\{\\lvert u_j \\rangle\\}$ optimally. By Ky Fan's inequality, or by a more direct argument, the sum of expectation values $\\sum_j \\langle u_j \\rvert D \\lvert u_j \\rangle$ is maximized when the subspace spanned by $\\{\\lvert u_j \\rangle\\}$ is the same as the subspace spanned by the eigenvectors of $D$ corresponding to its $N$ largest eigenvalues.\nIn our ordered-eigenvalue basis, the maximum value is achieved by choosing $\\lvert u_j \\rangle = \\lvert v_j \\rangle$ for $j=1, \\dots, N$. This choice gives:\n$$\n\\mathrm{Tr}(DP) = \\sum_{j=1}^{N} \\langle v_j \\rvert D \\lvert v_j \\rangle = \\sum_{j=1}^{N} \\langle v_j \\rvert (\\lambda_j \\lvert v_j \\rangle) = \\sum_{j=1}^{N} \\lambda_j\n$$\nAny other choice of orthonormal set $\\{\\lvert u_j \\rangle\\}$ would yield a value less than or equal to this sum.\n\nThus, the optimal projector $P$ is the one that projects onto the subspace spanned by the eigenvectors $\\{\\lvert v_1 \\rangle, \\dots, \\lvert v_N \\rangle\\}$ corresponding to the $N$ largest eigenvalues of $D$:\n$$\nP = \\sum_{i=1}^N \\lvert v_i \\rangle \\langle v_i \\rvert\n$$\nThe problem formulation uses the Singular Value Decomposition (SVD), $D = U \\Sigma V^\\dagger$. Since $D$ is Hermitian, its left and right singular vectors are the same ($U=V$) and coincide with its eigenvectors. The singular values are the absolute values of the eigenvalues. In the context of this problem, the matrix to be projected, $D_{\\text{mix}} = (1-\\alpha)D_n + \\alpha \\hat{D}(F[D_n])$, is a convex combination of two positive semi-definite matrices (projectors are PSD) and is therefore also positive semi-definite. Its eigenvalues are thus non-negative and identical to its singular values. Consequently, the eigenvectors corresponding to the $N$ largest eigenvalues are identical to the left singular vectors corresponding to the $N$ largest singular values.\n\nLet $U_N$ be the $M \\times N$ matrix whose columns are the first $N$ columns of $U$ (i.e., the eigenvectors $\\lvert v_1 \\rangle, \\dots, \\lvert v_N \\rangle$). The projector can be written as $P=U_N U_N^\\dagger$. We verify its properties:\n1.  **Hermiticity:** $P^\\dagger = (U_N U_N^\\dagger)^\\dagger = (U_N^\\dagger)^\\dagger U_N^\\dagger = U_N U_N^\\dagger = P$. It is Hermitian.\n2.  **Idempotency:** $P^2 = (U_N U_N^\\dagger)(U_N U_N^\\dagger) = U_N (U_N^\\dagger U_N) U_N^\\dagger$. Since the columns of $U_N$ are orthonormal, $U_N^\\dagger U_N = I_N$, the $N \\times N$ identity matrix. Therefore, $P^2 = U_N I_N U_N^\\dagger = U_N U_N^\\dagger = P$. It is idempotent.\n3.  **Rank:** The rank of the projector is its trace. $\\mathrm{rank}(P) = \\mathrm{Tr}(P) = \\mathrm{Tr}(U_N U_N^\\dagger) = \\mathrm{Tr}(U_N^\\dagger U_N) = \\mathrm{Tr}(I_N) = N$.\n\nThis completes the derivation. The SVD-based construction correctly identifies the Frobenius-norm closest rank-$N$ projector to a given Hermitian matrix. This procedure successfully maps a matrix that has lost its idempotency back onto the Grassmann manifold $\\mathcal{G}(N,M)$.",
            "answer": "```python\nimport numpy as np\n\ndef run_case(M, N, alpha, gamma, s, t=None, H_explicit=None):\n    \"\"\"\n    Performs one SCF linear mixing step followed by SVD projection for a single test case.\n\n    Args:\n        M (int): Dimension of the basis.\n        N (int): Number of occupied orbitals.\n        alpha (float): Linear mixing parameter.\n        gamma (float): Parameter for the Fock operator functional.\n        s (int): Seed for generating the initial density matrix.\n        t (int, optional): Seed for generating the core Hamiltonian. Defaults to None.\n        H_explicit (np.ndarray, optional): An explicitly provided core Hamiltonian. Defaults to None.\n\n    Returns:\n        tuple[float, float]: A tuple containing (E_mix, E_proj).\n    \"\"\"\n    \n    # 1. Generate the initial rank-N projector D_n\n    # Use a real M x N matrix A with standard normal entries\n    rng_s = np.random.default_rng(s)\n    A = rng_s.standard_normal((M, N))\n    # Compute the thin QR factorization of A\n    Q, _ = np.linalg.qr(A, mode='reduced')\n    # D_n is the projector Q Q^dagger\n    Dn = Q @ Q.T\n\n    # 2. Generate the core Hamiltonian H\n    if H_explicit is not None:\n        H = H_explicit\n    else:\n        # Use a real M x M matrix B with standard normal entries\n        rng_t = np.random.default_rng(t)\n        B = rng_t.standard_normal((M, M))\n        # Symmetrize to create a Hermitian matrix (here, real symmetric)\n        H = 0.5 * (B + B.T)\n\n    # 3. Compute the Fock operator F[D_n]\n    F = H + gamma * Dn\n\n    # 4. Compute the target projector, D_hat(F)\n    # Diagonalize the Hermitian Fock operator F\n    # np.linalg.eigh sorts eigenvalues in ascending order\n    eigvals, eigvecs = np.linalg.eigh(F)\n    # The columns of eigvecs are the eigenvectors. We need the first N columns\n    # corresponding to the N lowest eigenvalues.\n    lowest_eigvecs = eigvecs[:, :N]\n    # Form the projector onto this N-dimensional subspace\n    D_hat = lowest_eigvecs @ lowest_eigvecs.T\n\n    # 5. Perform linear mixing\n    D_mix = (1 - alpha) * Dn + alpha * D_hat\n\n    # 6. Compute idempotency violation of the mixed density, E_mix\n    error_matrix_mix = D_mix @ D_mix - D_mix\n    E_mix = np.linalg.norm(error_matrix_mix, 'fro')\n\n    # 7. Project D_mix back onto the Grassmann manifold\n    # D_mix is Hermitian, so its SVD is U S U^dagger. Left and right singular vectors are the same.\n    # np.linalg.svd sorts singular values in descending order.\n    U, S, Vh = np.linalg.svd(D_mix)\n    # Take the N left singular vectors associated with the N largest singular values\n    U_N = U[:, :N]\n    # Construct the closest rank-N projector P\n    P = U_N @ U_N.T\n\n    # 8. Compute idempotency violation of the projected density, E_proj\n    # This should be close to machine epsilon\n    error_matrix_proj = P @ P - P\n    E_proj = np.linalg.norm(error_matrix_proj, 'fro')\n\n    return E_mix, E_proj\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (M, N, alpha, gamma, s, t)\n        (4, 2, 0.5, 0.7, 11, 13),\n        (4, 2, 0.0, 0.7, 11, 13),\n        (4, 2, 1.0, 0.7, 11, 13),\n        (5, 2, 0.3, -0.5, 21, 22),\n        # Case 5 has no 't' seed\n        (6, 3, 0.4, 0.0, 31),\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        if len(case) == 6:\n            M, N, alpha, gamma, s, t = case\n            E_mix, E_proj = run_case(M, N, alpha, gamma, s, t)\n        else: # Case 5\n            M, N, alpha, gamma, s = case\n            H_explicit = np.diag([0.0, 0.0, 0.0, 1.0, 1.0, 1.0])\n            E_mix, E_proj = run_case(M, N, alpha, gamma, s, H_explicit=H_explicit)\n        \n        results.append(E_mix)\n        results.append(E_proj)\n\n    # Format the final output string\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}