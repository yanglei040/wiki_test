{
    "hands_on_practices": [
        {
            "introduction": "为真正掌握刚性转子模型，我们首先从其量子力学基础开始。第一个练习将引导你完成对经典球形转子进行量子化的过程，推导出其哈密顿量和能谱。通过理解能级 $E_I$ 及其简并度是如何从角动量的基本原理中产生的 ，你将为后续所有与该模型相关的工作奠定坚实的理论基础。",
            "id": "3606597",
            "problem": "球形偶偶核可以被建模为一个量子刚性转子，其取向由三维特殊正交群 ($\\mathrm{SO}(3)$) 中的旋转来描述。一个具有角速度矢量 $\\boldsymbol{\\omega}$ 和惯性张量 $\\mathbf{I}$ 的刚性转子，其经典动能由 $T=\\frac{1}{2}\\,\\boldsymbol{\\omega}\\cdot\\mathbf{I}\\cdot\\boldsymbol{\\omega}$ 给出。对于球形转子，惯性张量是各向同性的，可以写成 $\\mathbf{I}=\\mathcal{I}\\,\\mathbf{1}$ 的形式，其中 $\\mathcal{I}$ 是一个标量转动惯量参数。正则角动量为 $\\mathbf{L}=\\mathbf{I}\\cdot\\boldsymbol{\\omega}$，哈密顿量是在没有势能的情况下系统的总能量。\n\n从这些基本关系出发，利用角动量的正则量子化以及二阶特殊酉群 ($\\mathrm{SU(2)}$) 代数的对易关系 $[\\hat{L}_{i},\\hat{L}_{j}]=\\mathrm{i}\\hbar\\,\\epsilon_{ijk}\\hat{L}_{k}$，推导球形转子的量子哈密顿量，并得到其能谱，表示为总角动量量子数 $I$ 和转动惯量 $\\mathcal{I}$ 的函数。转子的物理构型空间是 $\\mathrm{SO(3)}$，因此要求转子的波函数在 $2\\pi$ 旋转下是单值的。\n\n然后，通过显式地计算对应于不同 $M$ 值的、不同的、归一化的本征态的数量，来验证每个能级相对于磁量子数 $M$ 的简并度。你的计数应基于 $\\hat{\\mathbf{L}}^{2}$ 和 $\\hat{L}_{z}$ 的共同本征基以及相应角向波函数的单值性条件。\n\n将你的最终答案以一个两元行矩阵的形式给出，第一个元素是能量 $E_{I}$，第二个元素是简并度 $g_{I}$，两者都以 $I$ 和 $\\mathcal{I}$ 的闭合形式函数表示。能量以焦耳为单位表示。无需进行数值计算，也无需四舍五入。",
            "solution": "该问题要求解一个量子刚性转子的能谱和简并度，该模型用于描述球形偶偶核。推导从经典动能表达式开始，通过正则量子化进行。\n\n刚性转子的经典动能 $T$ 由下列表达式给出：\n$$T=\\frac{1}{2}\\,\\boldsymbol{\\omega}\\cdot\\mathbf{I}\\cdot\\boldsymbol{\\omega}$$\n其中 $\\boldsymbol{\\omega}$ 是角速度矢量，$\\mathbf{I}$ 是惯性张量。对于球形转子，惯性张量是各向同性的，意味着它与单位张量 $\\mathbf{1}$ 成正比。它可以写成 $\\mathbf{I}=\\mathcal{I}\\,\\mathbf{1}$，其中 $\\mathcal{I}$ 是标量转动惯量。将此代入能量表达式得到：\n$$T = \\frac{1}{2}\\,\\boldsymbol{\\omega}\\cdot(\\mathcal{I}\\,\\mathbf{1})\\cdot\\boldsymbol{\\omega} = \\frac{1}{2}\\mathcal{I}\\,(\\boldsymbol{\\omega}\\cdot\\boldsymbol{\\omega}) = \\frac{1}{2}\\mathcal{I}\\omega^2$$\n正则角动量 $\\mathbf{L}$ 与角速度的关系为：\n$$\\mathbf{L} = \\mathbf{I}\\cdot\\boldsymbol{\\omega} = (\\mathcal{I}\\,\\mathbf{1})\\cdot\\boldsymbol{\\omega} = \\mathcal{I}\\boldsymbol{\\omega}$$\n根据这个关系，我们可以用角动量来表示角速度：\n$$\\boldsymbol{\\omega} = \\frac{\\mathbf{L}}{\\mathcal{I}}$$\n系统的哈密顿量 $H$ 是其总能量。由于问题指定没有势能，哈密顿量等于动能，$H=T$。我们可以通过代入 $\\boldsymbol{\\omega}$ 的表达式，用角动量来表示哈密顿量：\n$$H = T = \\frac{1}{2}\\mathcal{I}\\omega^2 = \\frac{1}{2}\\mathcal{I}\\left|\\frac{\\mathbf{L}}{\\mathcal{I}}\\right|^2 = \\frac{1}{2}\\mathcal{I}\\frac{L^2}{\\mathcal{I}^2} = \\frac{L^2}{2\\mathcal{I}}$$\n为了得到量子哈密顿量，我们使用正则量子化，即将经典可观测量提升为其对应的量子算符。经典量 $L^2$，即角动量矢量的大小平方，被量子算符 $\\hat{\\mathbf{L}}^2 = \\hat{L}_x^2 + \\hat{L}_y^2 + \\hat{L}_z^2$ 所取代。算符 $\\hat{L}_i$ 满足问题陈述中给出的 $\\mathrm{SU}(2)$ 李代数对易关系 $[\\hat{L}_{i},\\hat{L}_{j}]=\\mathrm{i}\\hbar\\,\\epsilon_{ijk}\\hat{L}_{k}$。因此，量子哈密顿算符 $\\hat{H}$ 为：\n$$\\hat{H} = \\frac{\\hat{\\mathbf{L}}^2}{2\\mathcal{I}}$$\n转子的能谱通过确定哈密顿算符 $\\hat{H}$ 的本征值得出。这通过求解定态薛定谔方程来完成：\n$$\\hat{H}|\\psi\\rangle = E|\\psi\\rangle$$\n哈密顿量的本征态 $|\\psi\\rangle$ 是对易算符 $\\hat{\\mathbf{L}}^2$ 和 $\\hat{L}_z$ 的共同本征态。这些态用 $|I, M\\rangle$ 表示，其中 $I$ 是总角动量量子数，$M$ 是磁量子数。$\\hat{\\mathbf{L}}^2$ 算符对这些态的作用是角动量量子理论中的一个标准结果：\n$$\\hat{\\mathbf{L}}^2 |I, M\\rangle = \\hbar^2 I(I+1) |I, M\\rangle$$\n将此代入薛定谔方程得到：\n$$\\hat{H}|I, M\\rangle = \\frac{\\hat{\\mathbf{L}}^2}{2\\mathcal{I}} |I, M\\rangle = \\frac{\\hbar^2 I(I+1)}{2\\mathcal{I}} |I, M\\rangle$$\n通过将其与 $\\hat{H}|I, M\\rangle = E_I |I, M\\rangle$ 比较，我们确定能量本征值 $E_I$ 为：\n$$E_I = \\frac{\\hbar^2 I(I+1)}{2\\mathcal{I}}$$\n能量 $E_I$ 仅取决于量子数 $I$，而与 $M$ 无关。问题指明物理构型空间是 $\\mathrm{SO(3)}$，这要求波函数在 $2\\pi$ 旋转下单值。在位置表象中，本征态与球谐函数成正比，$\\psi_{I,M}(\\theta, \\phi) \\propto Y_{I,M}(\\theta, \\phi)$。绕任意轴旋转 $2\\pi$ 角必须使波函数保持不变。对于绕 $z$ 轴旋转角度 $\\alpha$ 的情况，波函数变换为 $\\psi_{I,M}(\\theta, \\phi - \\alpha) = \\exp(-i M \\alpha) \\psi_{I,M}(\\theta, \\phi)$。对于 $2\\pi$ 旋转，$\\alpha=2\\pi$，单值性要求 $\\exp(-i M 2\\pi) = 1$。这意味着磁量子数 $M$ 必须是整数。由于标准的角动量理论要求 $M$ 在 $-I$ 到 $I$ 的范围内以整数步长取值，因此 $M$ 是整数的要求也迫使 $I$ 必须是整数：$I = 0, 1, 2, \\dots$。对于球形偶偶核这一特定的物理系统，额外的对称性考虑要求基态转动带由具有正宇称的态组成，这将允许的角动量限制为偶整数值，$I = 0, 2, 4, \\dots$。然而，$E_I$ 的公式对于任何允许的整数 $I$ 都是普适的。\n\n接下来，我们验证每个能级的简并度 $g_I$。能量 $E_I$ 完全由量子数 $I$ 决定。对于一个固定的 $I$ 值，磁量子数 $M$ 可以在以下范围内取任何整数值：\n$$M \\in \\{-I, -I+1, \\dots, I-1, I\\}$$\n$M$ 的每一个值都对应一个不同的、归一化的、正交的量子态 $|I, M\\rangle$。对于给定的 $I$，这种态的总数就是能级 $E_I$ 的简并度。$M$ 可以取的值的数量是：\n$$g_I = (I - (-I)) + 1 = 2I + 1$$\n因此，每个能级 $E_I$ 是 $(2I+1)$ 重简并的。\n\n最终答案要求能量 $E_I$ 和简并度 $g_I$ 都表示为 $I$ 和 $\\mathcal{I}$ 的函数。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{\\hbar^2 I(I+1)}{2\\mathcal{I}} & 2I+1 \\end{pmatrix}}$$"
        },
        {
            "introduction": "转子哈密顿量的解是用维格纳D函数来表示的，这些函数构成了遍及整个转动群的一个正交基。下一个练习是一个动手实践的计算挑战：你将通过编写数值积分程序来验证这些基本函数的正交性 。这个练习不仅能巩固模型的数学基础，还能提升你在科学计算方面的技能，尤其是在数值积分和处理特殊函数方面的能力。",
            "id": "3606621",
            "problem": "在计算核物理中，考虑刚性转子模型，其中体固坐标系和空间固定坐标系通过 Euler 角相关联。设 Euler 角表示为 $\\alpha$、$\\beta$ 和 $\\gamma$，其取值范围分别为 $\\alpha \\in [0,2\\pi)$、$\\beta \\in [0,\\pi]$ 和 $\\gamma \\in [0,2\\pi)$。角度必须以弧度处理。三维特殊正交群 (SO(3)) 也就是旋转群，其不可约酉表示由总角动量 $I \\in \\{0,1,2,\\dots\\}$ 以及磁量子数 $M$ 和 $K$（满足 $-I \\le M,K \\le I$）标记。Wigner 旋转矩阵元为 $D^{I}_{MK}(\\alpha,\\beta,\\gamma)$，在 Euler 角下 SO(3) 上的不变 Haar 测度为 $d\\Omega = d\\alpha\\, d\\beta\\, d\\gamma\\, \\sin\\beta$。\n\n根据表示论和旋转对称性，函数 $D^{I}_{MK}(\\alpha,\\beta,\\gamma)$ 在群流形上相对于 Haar 测度是正交的。您的任务是实现一个关于 Euler 角的数值积分来计算以下积分\n$$\n\\mathcal{I}(I,M,K; I',M',K') \\equiv \\int_{0}^{2\\pi}\\!\\! d\\alpha \\int_{0}^{\\pi}\\!\\! d\\beta \\int_{0}^{2\\pi}\\!\\! d\\gamma \\,\\sin\\beta \\; D^{I*}_{MK}(\\alpha,\\beta,\\gamma)\\, D^{I'}_{M'K'}(\\alpha,\\beta,\\gamma),\n$$\n然后根据 SO(3) 上群表示的性质得出的解析精确正交性结果，来检验您数值计算的准确性。\n\n推导和实现的基本依据必须包括：\n- 分解式 $D^{I}_{MK}(\\alpha,\\beta,\\gamma) = e^{-i M \\alpha}\\, d^{I}_{MK}(\\beta)\\, e^{-i K \\gamma)$，其中 $d^{I}_{MK}(\\beta)$ 是约化 Wigner 旋转矩阵元（通常称为 Wigner 小d函数）。\n- 在 Euler 角下 SO(3) 上的不变 Haar 测度 $d\\Omega$。\n- 紧群上的不可约表示相对于 Haar 测度的正交性会在量子数中产生 Kronecker-delta 结构这一事实。\n\n您必须设计一个完全自包含的数值算法，该算法能够：\n1. 对整数 $I$、$M$ 和 $K$ 实现 $d^{I}_{MK}(\\beta)$，使用从基本角动量理论推导出的数值稳定的有限和表示（不使用外部数据）。\n2. 对 $\\alpha$ 和 $\\gamma$ 使用适合 $2\\pi$ 周期复指数的周期性积分法。\n3. 对 $\\beta$ 使用高斯积分法，通过将带有 $\\sin\\beta$ 权重的 $\\beta$ 积分转换为对 $x=\\cos\\beta \\in [-1,1]$ 的积分。\n4. 汇总这三个积分，以产生单个数值 $\\mathcal{I}(I,M,K; I',M',K')$。\n\n数值单位和约定：\n- 所有角度必须使用弧度。\n- 最终积分 $\\mathcal{I}$ 是无量纲的。\n\n为使问题可测试，请使用以下参数元组 $(I,M,K; I',M',K')$ 的测试套件：\n- 测试用例1（正常情况）：$(2,\\,1,\\,-1;\\; 2,\\,1,\\,-1)$。\n- 测试用例2（不同总角动量）：$(2,\\,1,\\,-1;\\; 3,\\,1,\\,-1)$。\n- 测试用例3（不同空间固定投影）：$(3,\\,0,\\,3;\\; 3,\\,1,\\,3)$。\n- 测试用例4（不同体固投影）：$(3,\\,3,\\,-3;\\; 3,\\,3,\\,-2)$。\n- 测试用例5（边界情况 $I=0$）：$(0,\\,0,\\,0;\\; 0,\\,0,\\,0)$。\n- 测试用例6（附加非对角项）：$(4,\\,-1,\\,2;\\; 4,\\,-2,\\,2)$。\n- 测试用例7（更高自旋对角项）：$(4,\\,-2,\\,1;\\; 4,\\,-2,\\,1)$。\n\n对于每个测试用例，您必须计算：\n- 如果精确的解析正交值为非零，则报告定义为 $\\left|\\mathcal{I}_{\\text{num}} - \\mathcal{I}_{\\text{exact}}\\right| / \\left|\\mathcal{I}_{\\text{exact}}\\right|$ 的相对误差。\n- 如果精确的解析正交值为零，则报告绝对值 $\\left|\\mathcal{I}_{\\text{num}}\\right|$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4,r5,r6,r7]”），其中每个 $r_i$ 是一个浮点数，对应第 $i$ 个测试用例的指定度量。角度必须以弧度为单位，输出值为无量纲。请选择您的积分分辨率，以获得高精度的结果，从而有意义地测试正交性，包括非对角抑制和对角归一化，且不依赖任何外部输入。",
            "solution": "用户要求对 Wigner D 矩阵的正交性进行数值验证，这些矩阵构成了 SO(3) 旋转群不可约表示的基础。该问题设置在量子刚性转子模型的背景下。\n\n### 问题验证\n\n问题陈述已根据指定标准进行验证，并被认定为**有效**。\n1.  **科学基础扎实**：该问题基于量子力学、群论（特别是 SO(3) 的表示论）和刚性转子物理学的基本原理。Wigner D 矩阵的正交性是角动量理论中的一个基石性结果。\n2.  **定义明确**：该问题定义了一个明确的目标：数值计算一个特定积分，并将其与已知的解析结果进行比较。所有必要的组成部分，包括积分形式、函数定义、坐标系、积分测度以及所需的数值方法，都已提供。\n3.  **客观性**：该问题使用精确、标准的数学和物理术语进行陈述，没有主观解释的余地。测试用例和所需的输出格式都已明确定义。\n\n该问题是自包含的、计算上可行的，并且是计算物理学中一个标准的、非平凡的练习。\n\n### 数学公式与数值策略\n\n需要计算的积分是：\n$$\n\\mathcal{I}(I,M,K; I',M',K') = \\int_{0}^{2\\pi}\\!\\! d\\alpha \\int_{0}^{\\pi}\\!\\! d\\beta \\int_{0}^{2\\pi}\\!\\! d\\gamma \\,\\sin\\beta \\; D^{I*}_{MK}(\\alpha,\\beta,\\gamma)\\, D^{I'}_{M'K'}(\\alpha,\\beta,\\gamma)\n$$\n\nWigner D 矩阵 $D^{I}_{MK}(\\alpha,\\beta,\\gamma)$ 可以使用约化 Wigner d 矩阵 $d^{I}_{MK}(\\beta)$ 分解为：\n$$\nD^{I}_{MK}(\\alpha,\\beta,\\gamma) = e^{-i M \\alpha}\\, d^{I}_{MK}(\\beta)\\, e^{-i K \\gamma}\n$$\n其复共轭为 $D^{I*}_{MK}(\\alpha,\\beta,\\gamma) = e^{i M \\alpha}\\, d^{I*}_{MK}(\\beta)\\, e^{i K \\gamma}$。根据标准约定，约化 d 矩阵 $d^{I}_{MK}(\\beta)$ 是实值函数，因此 $d^{I*}_{MK}(\\beta) = d^{I}_{MK}(\\beta)$。\n\n将此分解代入积分表达式，被积函数变为：\n$$\n\\text{Integrand} = \\sin\\beta \\, \\left(e^{i M \\alpha} d^{I}_{MK}(\\beta) e^{i K \\gamma}\\right) \\left(e^{-i M' \\alpha} d^{I'}_{M'K'}(\\beta) e^{-i K' \\gamma}\\right) = \\sin\\beta \\, e^{i(M-M')\\alpha} e^{i(K-K')\\gamma} d^{I}_{MK}(\\beta) d^{I'}_{M'K'}(\\beta)\n$$\n由于被积函数的可分离性，三重积分可以表示为三个一维积分的乘积：\n$$\n\\mathcal{I} = \\left( \\int_{0}^{2\\pi} e^{i(M-M')\\alpha} d\\alpha \\right) \\left( \\int_{0}^{2\\pi} e^{i(K-K')\\gamma} d\\gamma \\right) \\left( \\int_{0}^{\\pi} \\sin\\beta \\, d^{I}_{MK}(\\beta) \\, d^{I'}_{M'K'}(\\beta) \\, d\\beta \\right)\n$$\n\n此积分的解析结果，即应用于 SO(3) 的大正交性定理，为：\n$$\n\\mathcal{I}_{\\text{exact}} = \\frac{8\\pi^2}{2I+1} \\delta_{II'} \\delta_{MM'} \\delta_{KK'}\n$$\n其中 $\\delta_{ij}$ 是 Kronecker delta。$8\\pi^2$ 项是在给定 Euler 角参数化下 SO(3) 群流形的体积（$ \\int_{0}^{2\\pi}d\\alpha \\int_{0}^{\\pi}d\\beta\\sin\\beta \\int_{0}^{2\\pi}d\\gamma = 8\\pi^2 $）。\n\n我们的数值方法将按照问题的规定，分别处理这三个积分。\n\n#### 1. 对 $\\alpha$ 和 $\\gamma$ 的积分\n对 $\\alpha$ 和 $\\gamma$ 的积分涉及在一个 $2\\pi$ 周期内的复指数。对于此类周期函数，梯形法则表现出谱精度。我们分别使用 $N_{\\alpha}$ 和 $N_{\\gamma}$ 个点来应用该法则。\n-   $\\int_{0}^{2\\pi} f(\\alpha) d\\alpha \\approx \\frac{2\\pi}{N_{\\alpha}} \\sum_{j=0}^{N_{\\alpha}-1} f(\\alpha_j)$，其中 $\\alpha_j = j \\frac{2\\pi}{N_{\\alpha}}$。对于 $f(\\alpha) = e^{i(M-M')\\alpha}$，如果 $M-M'$ 是一个非零整数且 $|M-M'| < N_\\alpha$，则该和精确为零。如果 $M=M'$，积分精确为 $2\\pi$。\n\n#### 2. 对 $\\beta$ 的积分\n对 $\\beta$ 的积分是 $\\int_{0}^{\\pi} \\sin\\beta \\, d^{I}_{MK}(\\beta) \\, d^{I'}_{M'K'}(\\beta) \\, d\\beta$。按照问题的指示，我们进行变量替换：$x = \\cos\\beta$。这得到 $dx = -\\sin\\beta\\,d\\beta$，积分限从 $[0, \\pi]$ 变为 $[1, -1]$。\n$$\n\\int_{0}^{\\pi} F(\\beta) \\sin\\beta \\, d\\beta = \\int_{1}^{-1} F(\\arccos x) (-dx) = \\int_{-1}^{1} F(\\arccos x) dx\n$$\n积分变为 $\\int_{-1}^{1} d^{I}_{MK}(\\arccos x) \\, d^{I'}_{M'K'}(\\arccos x) \\, dx$。这种形式非常适合高斯-勒让德积分法，该方法将 $\\int_{-1}^{1} g(x) dx$ 近似为 $\\sum_{i=1}^{N_p} w_i g(x_i)$，其中 $x_i$ 是 $N_p$ 阶 Legendre 多项式的根，$w_i$ 是对应的权重。我们将使用 `numpy.polynomial.legendre.leggauss` 来获取这些点和权重。\n\n#### 3. Wigner 小d函数的实现\n计算的核心是 $d^{I}_{MK}(\\beta)$ 的实现。我们使用标准的有限和公式：\n$$\nd^I_{MK}(\\beta) = \\sum_{s=\\max(0, M-K)}^{\\min(I+M, I-K)} (-1)^{s-K+M} \\frac{\\sqrt{(I+M)!(I-M)!(I+K)!(I-K)!}}{s!(I+M-s)!(I-K-s)!(s-M+K)!} (\\cos(\\beta/2))^{2I+M-K-2s} (\\sin(\\beta/2))^{K-M+2s}\n$$\n为了处理可能很大的数的阶乘而不发生溢出，我们使用对数伽马函数 (`scipy.special.gammaln`) 来计算系数的对数，其中 $\\ln(n!) = \\text{gammaln}(n+1)$。整体计算逻辑被封装在一个类中，该类会为给定的 $(I, M, K)$ 集合预先计算常数系数，从而在多个积分点上求值时提高效率。\n\n#### 最终度量计算\n对于每个测试用例，我们计算数值积分 $\\mathcal{I}_{\\text{num}}$ 并将其与 $\\mathcal{I}_{\\text{exact}}$ 进行比较。\n-   如果 $\\mathcal{I}_{\\text{exact}} \\neq 0$（对角情况），我们报告相对误差：$|\\mathcal{I}_{\\text{num}} - \\mathcal{I}_{\\text{exact}}| / |\\mathcal{I}_{\\text{exact}}|$。\n-   如果 $\\mathcal{I}_{\\text{exact}} = 0$（非对角情况），我们报告绝对值：$|\\mathcal{I}_{\\text{num}}|$。\n\n代码实现了此策略以生成所需的结果列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\n\nclass WignerDCalculator:\n    \"\"\"\n    A class to compute Wigner small-d matrix elements d^I_{MK}(beta).\n\n    It uses a numerically stable finite-sum representation derived from\n    angular momentum theory. To improve efficiency for quadrature, where the\n    function is evaluated at many points, constant coefficients for the sum\n    are pre-calculated during initialization.\n    \"\"\"\n    def __init__(self, I, M, K):\n        if not (isinstance(I, int) and I >= 0):\n            raise ValueError(\"I must be a non-negative integer.\")\n        if not (isinstance(M, int) and abs(M) <= I):\n            raise ValueError(f\"M must be an integer with |M| <= I, but got M={M}, I={I}\")\n        if not (isinstance(K, int) and abs(K) <= I):\n            raise ValueError(f\"K must be an integer with |K| <= I, but got K={K}, I={I}\")\n            \n        self.I, self.M, self.K = I, M, K\n        \n        # Determine the summation range for s\n        self.s_min = max(0, M - K)\n        self.s_max = min(I + M, I - K)\n\n        self.coeffs = []\n        # The sum is non-empty only if s_min <= s_max\n        if self.s_min <= self.s_max:\n            # Pre-calculate the log of the large constant factor involving factorials\n            log_prefactor = 0.5 * (gammaln(I + M + 1) + gammaln(I - M + 1) + \n                                   gammaln(I + K + 1) + gammaln(I - K + 1))\n            \n            for s in range(self.s_min, self.s_max + 1):\n                sign = 1.0 if (s - K + M) % 2 == 0 else -1.0\n                \n                log_denominator = (gammaln(s + 1) + \n                                   gammaln(I + M - s + 1) + \n                                   gammaln(I - K - s + 1) + \n                                   gammaln(s - M + K + 1))\n                \n                # Exponentiate to get the final coefficient\n                coeff = sign * np.exp(log_prefactor - log_denominator)\n                self.coeffs.append(coeff)\n\n    def d(self, beta):\n        \"\"\"\n        Evaluates the d-function for a given angle beta.\n        \"\"\"\n        # If the summation range is empty, the function is zero\n        if not self.coeffs:\n            return 0.0\n\n        term_sum = 0.0\n        c_half_beta = np.cos(beta / 2.0)\n        s_half_beta = np.sin(beta / 2.0)\n\n        for i, s in enumerate(range(self.s_min, self.s_max + 1)):\n            pow1 = 2 * self.I + self.M - self.K - 2 * s\n            pow2 = self.K - self.M + 2 * s\n            \n            # Use np.power for robust handling of 0^0 = 1\n            trig_term = np.power(c_half_beta, pow1) * np.power(s_half_beta, pow2)\n            \n            term_sum += self.coeffs[i] * trig_term\n        return term_sum\n\ndef compute_orthogonality_integral(params, N_alpha, N_gamma, N_beta):\n    \"\"\"\n    Computes the orthogonality integral for a given set of quantum numbers.\n    \"\"\"\n    I, M, K, I_p, M_p, K_p = params\n\n    # Determine the analytical exact value of the integral\n    exact_val = 0.0\n    if I == I_p and M == M_p and K == K_p:\n        # The denominator 2I+1 is always positive since I >= 0\n        exact_val = (8 * np.pi**2) / (2 * I + 1)\n\n    # --- Numerical Quadrature ---\n\n    # 1. Alpha integral (Periodic Trapezoidal Rule)\n    dM = M - M_p\n    alpha_pts = np.linspace(0, 2 * np.pi, N_alpha, endpoint=False)\n    integrand_alpha = np.exp(1j * dM * alpha_pts)\n    I_alpha = (2 * np.pi / N_alpha) * np.sum(integrand_alpha)\n    \n    # 2. Gamma integral (Periodic Trapezoidal Rule)\n    dK = K - K_p\n    gamma_pts = np.linspace(0, 2 * np.pi, N_gamma, endpoint=False)\n    integrand_gamma = np.exp(1j * dK * gamma_pts)\n    I_gamma = (2 * np.pi / N_gamma) * np.sum(integrand_gamma)\n    \n    # 3. Beta integral (Gauss-Legendre Quadrature)\n    # Transformation: x = cos(beta), so integral is over [-1, 1] with measure dx\n    x_pts, w_pts = np.polynomial.legendre.leggauss(N_beta)\n    beta_pts = np.arccos(x_pts)\n    \n    # Instantiate calculators for the two d-functions\n    d1_calc = WignerDCalculator(I, M, K)\n    d2_calc = WignerDCalculator(I_p, M_p, K_p)\n    \n    # Evaluate d-functions at all quadrature points\n    d1_vals = np.array([d1_calc.d(b) for b in beta_pts])\n    d2_vals = np.array([d2_calc.d(b) for b in beta_pts])\n    \n    # The integrand is a simple product since d_MK are real\n    integrand_beta = d1_vals * d2_vals\n    I_beta = np.sum(w_pts * integrand_beta)\n    \n    # Combine the three parts to get the final numerical value\n    num_val = I_alpha * I_gamma * I_beta\n    \n    # Calculate the required metric based on whether the exact value is zero\n    if exact_val != 0:\n        # For diagonal cases, compute relative error\n        metric = np.abs(num_val - exact_val) / np.abs(exact_val)\n    else:\n        # For off-diagonal cases, compute absolute value (suppression)\n        metric = np.abs(num_val)\n        \n    return metric\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, 1, -1, 2, 1, -1),   # Test case 1\n        (2, 1, -1, 3, 1, -1),   # Test case 2\n        (3, 0, 3, 3, 1, 3),    # Test case 3\n        (3, 3, -3, 3, 3, -2),  # Test case 4\n        (0, 0, 0, 0, 0, 0),    # Test case 5\n        (4, -1, 2, 4, -2, 2),  # Test case 6\n        (4, -2, 1, 4, -2, 1),  # Test case 7\n    ]\n    \n    # Set quadrature resolutions\n    N_ALPHA = 100\n    N_GAMMA = 100\n    N_BETA = 200\n\n    results = []\n    for case in test_cases:\n        result = compute_orthogonality_integral(case, N_ALPHA, N_GAMMA, N_BETA)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "尽管刚性转子模型非常强大，但它是一个理想化的模型。我们的最后一个练习将通过带终止现象，把它与微观的壳模型图像联系起来，从而探索其局限性 。你将计算在单-$j$ 壳层中的费米子系统所能产生的最大可能角动量，并将这个有限的极限与简单转子模型预测的无限转动带进行比较。这个练习能让你深入理解集体现象是如何从底层的单粒子结构中产生并受到其制约的。",
            "id": "3606646",
            "problem": "给定一个有限的组态空间，其中包含限制在原子核平均场中单个-$j$ 壳层上的全同费米子。此壳层中的每个单粒子态都有一个磁量子数 $m \\in \\{-j, -j+1, \\ldots, j-1, j\\}$，简并度为 $2j+1$。根据泡利不相容原理，每个 $m$ 态最多只能容纳一个费米子。刚性转子模型预测的转动能 $E(L)$ 依赖于总角动量 $L$，其关系式为 $E(L) = \\hbar^2 L(L+1) / (2 \\mathcal{I})$。在此计算任务中，使用自然单位制，其中 $\\hbar = 1$，因此 $E(L) = L(L+1)/(2 \\mathcal{I})$，$\\mathcal{I}$ 是转动惯量。所有能量必须以 $\\mathrm{MeV}$ 表示，所有角动量以 $\\hbar$ 为单位，角度则不需要。您的答案必须四舍五入到 $6$ 位小数。\n\n从角动量耦合和泡利不相容原理的第一性原理出发，采用以下基准：\n- 在单-$j$ 壳层中 $n$ 个全同费米子的固定组态内，可达到的最大总角动量 $L_{\\max}$ 出现在最高权重态，此时 $n$ 个最大的 $m$ 值被占据。这意味着在完全对齐时，只要 $n \\le 2j+1$，被占据的态集为 $\\{ j, j-1, \\ldots, j-(n-1)\\}$。最大投影为 $M_{\\max} = \\sum_{k=0}^{n-1} (j-k)$，并且根据构造，它等于此组态空间内可用的最大总角动量 $L_{\\max}$。\n- 刚性转子能量公式 $E(L) = L(L+1)/(2 \\mathcal{I})$ 适用，其中 $\\mathcal{I}$ 的单位是 $\\mathrm{MeV}^{-1}$，$E(L)$ 的单位是 $\\mathrm{MeV}$。\n- 连续的转子能级间距遵循 $E(L)-E(L-1) = L/\\mathcal{I}$ 和 $E(L+1)-E(L) = (L+1)/\\mathcal{I}$，对 $L \\ge 0$ 有效。\n\n对于每个测试用例，您的程序必须计算以下量：\n1. $n$ 个全同费米子在单-$j$ 壳层中的最大角动量 $L_{\\max}$，通过占据 $n$ 个最大的 $m$ 值从最高权重构造中获得。明确地，$L_{\\max} = \\sum_{k=0}^{n-1} (j-k) = n j - \\frac{n(n-1)}{2}$。\n2. 终止时的转子能量 $E(L_{\\max}) = L_{\\max}(L_{\\max}+1)/(2 \\mathcal{I})$，单位为 $\\mathrm{MeV}$。\n3. 紧邻 $L_{\\max}$ 上下的转子能级间距，即 $\\Delta_{-} = E(L_{\\max}) - E(L_{\\max}-1) = L_{\\max}/\\mathcal{I}$（对于 $L_{\\max} \\ge 1$；如果 $L_{\\max} = 0$，则设 $\\Delta_{-} = 0$）和 $\\Delta_{+} = E(L_{\\max}+1) - E(L_{\\max}) = (L_{\\max}+1)/\\mathcal{I}$。\n4. 给定以 $\\mathrm{MeV}$ 为单位的转子能量预算 $E_{\\mathrm{budget}}$，求满足 $E(L) \\le E_{\\mathrm{budget}}$ 且与组态具有相同量子化宇稱的最大转子角动量 $L_{\\mathrm{rot}}^{\\mathrm{budget}}$。允许的 $L$ 的宇称由 $n$ 决定：如果 $n$ 是偶数，允许的 $L$ 是整数；如果 $n$ 是奇数，允许的 $L$ 是半整数。程序必须找到符合此宇称约束的 $L_{\\mathrm{rot}}^{\\mathrm{budget}}$。\n5. 一个布尔指示符 $\\mathrm{terminated}$，如果 $L_{\\mathrm{rot}}^{\\mathrm{budget}} > L_{\\max}$ 则为 $\\mathrm{True}$（意味着在能量预算内，刚性转子模型会预测出比组态空间允许的更高的角动量，因此在给定预算内意味着带终止），否则为 $\\mathrm{False}$。\n6. 终止时被占据的 $m$ 值集合（对齐模式），即列表 $[j, j-1, \\ldots, j-(n-1)]$。\n\n关于数值单位：\n- 将 $\\mathcal{I}$视为以 $\\mathrm{MeV}^{-1}$ 为单位。\n- 报告 $E(L_{\\max})$、$\\Delta_{-}$ 和 $\\Delta_{+}$，单位为 $\\mathrm{MeV}$，四舍五入到 $6$ 位小数。\n- 报告 $L_{\\max}$ 和 $L_{\\mathrm{rot}}^{\\mathrm{budget}}$，单位为 $\\hbar$，四舍五入到 $6$ 位小数。\n- 被占据的 $m$ 值列表必须以 $\\hbar$ 为单位报告，并四舍五入到 $6$ 位小数。\n\n测试套件：\n- 情况 1：$j=\\frac{7}{2}$, $n=4$, $\\mathcal{I}=25\\,\\mathrm{MeV}^{-1}$, $E_{\\mathrm{budget}}=2.0\\,\\mathrm{MeV}$。\n- 情况 2：$j=\\frac{9}{2}$, $n=10$, $\\mathcal{I}=20\\,\\mathrm{MeV}^{-1}$, $E_{\\mathrm{budget}}=0.1\\,\\mathrm{MeV}$。\n- 情况 3：$j=\\frac{11}{2}$, $n=1$, $\\mathcal{I}=30\\,\\mathrm{MeV}^{-1}$, $E_{\\mathrm{budget}}=0.6\\,\\mathrm{MeV}$。\n- 情况 4：$j=\\frac{13}{2}$, $n=7$, $\\mathcal{I}=18\\,\\mathrm{MeV}^{-1}$, $E_{\\mathrm{budget}}=20.0\\,\\mathrm{MeV}$。\n- 情况 5：$j=\\frac{5}{2}$, $n=0$, $\\mathcal{I}=25\\,\\mathrm{MeV}^{-1}$, $E_{\\mathrm{budget}}=0.05\\,\\mathrm{MeV}$。\n\n最终输出格式：\n- 对于每个测试用例，按顺序 $[L_{\\max}, E(L_{\\max}), \\Delta_{-}, \\Delta_{+}, L_{\\mathrm{rot}}^{\\mathrm{budget}}, \\mathrm{terminated}, \\text{occupied\\_m\\_list}]$ 返回一个列表。\n- 将所有测试用例的结果按测试套件中给出的相同顺序汇总到一个列表中。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[ \\text{case1\\_result}, \\text{case2\\_result}, \\ldots ]$。",
            "solution": "所提出的问题是一项定义明确的计算任务，它基于核结构物理学的原理，特别是单粒子壳模型与集体刚性转子模型之间的相互作用。该问题在科学上是合理的、自洽的，并且所有参数和公式都已明确给出。测试用例符合物理约束，例如泡利不相容原理（$n \\le 2j+1$）。因此，该问题是有效的，我们可以着手进行系统性的求解。\n\n该求解算法涉及为每个测试用例计算六个不同的量，这些量是单粒子壳角动量 $j$、全同费米子数 $n$、转动惯量 $\\mathcal{I}$ 和指定的能量预算 $E_{\\mathrm{budget}}$ 的函数。我们将使用自然单位制，其中 $\\hbar=1$。\n\n**1. 最大角动量 ($L_{\\max}$) 和占据态**\n\n总角动量的最大可能投影 $M_{\\max}$ 是在 $n$ 个费米子占据具有最大可能磁量子数 $m$ 的单粒子态时获得的。根据泡利不相容原理，每个费米子必须占据一个唯一的 $m$ 态。一个壳层 $j$ 的可用 $m$ 态为 $m \\in \\{-j, -j+1, \\ldots, j-1, j\\}$。因此，$n$ 个最大的 $m$ 值为 $\\{j, j-1, \\ldots, j-(n-1)\\}$。\n\n最大 $M$-投影是这些值的总和：\n$$\nM_{\\max} = \\sum_{k=0}^{n-1} (j-k)\n$$\n这是一个等差级数，求和后可得到问题中提供的公式：\n$$\nM_{\\max} = n j - \\sum_{k=0}^{n-1} k = n j - \\frac{n(n-1)}{2}\n$$\n在这个最高权重态中，总角动量 $L$ 等于其最大投影 $M$。因此，$L_{\\max} = M_{\\max}$。如果 $n=0$，则壳层为空，$L_{\\max} = 0$。被占据的 $m$ 态列表就是 $[j, j-1, \\ldots, j-(n-1)]$。\n\n**2. 终止时的转子能量 ($E(L_{\\max})$)**\n\n问题使用刚性转子模型定义了角动量为 $L$ 的转动能态：\n$$\nE(L) = \\frac{L(L+1)}{2 \\mathcal{I}}\n$$\n带终止发生在 $L_{\\max}$处，这是 $n$ 个费米子的组态所能支持的最高角动量。在该终止点的能量是-将 $L=L_{\\max}$ 代入公式得到的：\n$$\nE(L_{\\max}) = \\frac{L_{\\max}(L_{\\max}+1)}{2 \\mathcal{I}}\n$$\n\n**3. 能级间距 ($\\Delta_{-}$ 和 $\\Delta_{+})$**\n\n与终止态相邻的能级间距定义为 $\\Delta_{-} = E(L_{\\max}) - E(L_{\\max}-1)$ 和 $\\Delta_{+} = E(L_{\\max}+1) - E(L_{\\max})$。使用能量公式，我们可以推导出问题中给出的表达式：\n$$\n\\Delta_{-} = \\frac{1}{2\\mathcal{I}} [L_{\\max}(L_{\\max}+1) - (L_{\\max}-1)L_{\\max}] = \\frac{L_{\\max}}{2\\mathcal{I}} [(L_{\\max}+1) - (L_{\\max}-1)] = \\frac{L_{\\max}}{\\mathcal{I}}\n$$\n这对 $L_{\\max} \\ge 1$ 有效。如果 $L_{\\max}=0$，$\\Delta_{-}$ 定义为 $0$。\n$$\n\\Delta_{+} = \\frac{1}{2\\mathcal{I}} [(L_{\\max}+1)(L_{\\max}+2) - L_{\\max}(L_{\\max}+1)] = \\frac{L_{\\max}+1}{2\\mathcal{I}} [(L_{\\max}+2) - L_{\\max}] = \\frac{L_{\\max}+1}{\\mathcal{I}}\n$$\n\n**4. 预算内的角动量 ($L_{\\mathrm{rot}}^{\\mathrm{budget}}$)**\n\n我们的任务是找到允许的最大转子角动量 $L_{\\mathrm{rot}}^{\\mathrm{budget}}$，使其能量 $E(L)$ 不超过 $E_{\\mathrm{budget}}$。这可以转化为以下不等式：\n$$\n\\frac{L(L+1)}{2 \\mathcal{I}} \\le E_{\\mathrm{budget}}\n$$\n整理后得到关于 $L$ 的二次不等式：\n$$\nL^2 + L - 2 \\mathcal{I} E_{\\mathrm{budget}} \\le 0\n$$\n相应等式 $L^2 + L - 2 \\mathcal{I} E_{\\mathrm{budget}} = 0$ 的正根给出了预算所允许的最大连续（非量子化）角动量 $L_{\\text{cont}, \\max}$：\n$$\nL_{\\text{cont}, \\max} = \\frac{-1 + \\sqrt{1 + 8 \\mathcal{I} E_{\\mathrm{budget}}}}{2}\n$$\n$L_{\\mathrm{rot}}^{\\mathrm{budget}}$ 的值必须是小于等于 $L_{\\text{cont}, \\max}$ 的最大允许量子化角动量 $L$。$L$ 的量子化规则取决于 $n$ 的宇称：\n- 如果 $n$ 是偶数，允许的 $L$ 值为整数（$0, 1, 2, \\ldots$）。小于等于 $L_{\\text{cont}, \\max}$ 的最大整数 $L$ 是 $L_{\\mathrm{rot}}^{\\mathrm{budget}} = \\lfloor L_{\\text{cont}, \\max} \\rfloor$。\n- 如果 $n$ 是奇数，允许的 $L$ 值为半整数（$0.5, 1.5, 2.5, \\ldots$）。设 $L = k + 0.5$，$k \\in \\{0, 1, 2, \\ldots\\}$。我们需要找到满足 $k+0.5 \\le L_{\\text{cont}, \\max}$ 的最大 $k$，这意味着 $k \\le L_{\\text{cont}, \\max} - 0.5$。最大的整数 $k$ 是 $k_{\\max} = \\lfloor L_{\\text{cont}, \\max} - 0.5 \\rfloor$。相应的角动量是 $L_{\\mathrm{rot}}^{\\mathrm{budget}} = k_{\\max} + 0.5$。\n\n**5. 终止指示符 ($\\mathrm{terminated}$)**\n\n这个布尔指示符用来表明，在给定的能量预算内，刚性转子模型是否预测了角动量高于微观模型所允许的态的存在。如果转子模型在预算内预测的最大角动量 $L_{\\mathrm{rot}}^{\\mathrm{budget}}$ 超过了费米子组态所支持的最大角动量 $L_{\\max}$，则意味着发生了带终止。\n$$\n\\mathrm{terminated} = (L_{\\mathrm{rot}}^{\\mathrm{budget}} > L_{\\max})\n$$\n\n这些步骤将为每个测试用例实现。所有数值结果均四舍五入到 $6$ 位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational nuclear physics problem for a given set of test cases.\n    \"\"\"\n    # Test suite as per the problem statement.\n    # Each case is a tuple: (j, n, I, E_budget)\n    test_cases = [\n        (7/2, 4, 25.0, 2.0),\n        (9/2, 10, 20.0, 0.1),\n        (11/2, 1, 30.0, 0.6),\n        (13/2, 7, 18.0, 20.0),\n        (5/2, 0, 25.0, 0.05)\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        j, n, I, E_budget = case\n        \n        # 1. Maximum angular momentum L_max and occupied m-list\n        if n == 0:\n            L_max = 0.0\n            occupied_m_list = []\n        else:\n            # Formula: L_max = n*j - n*(n-1)/2\n            L_max = float(n * j - n * (n - 1) / 2.0)\n            # Occupied m-states: [j, j-1, ..., j-(n-1)]\n            occupied_m_list = [j - k for k in range(n)]\n\n        # 2. Rotor energy at termination E(L_max)\n        E_L_max = L_max * (L_max + 1) / (2.0 * I)\n\n        # 3. Rotor energy spacings Delta- and Delta+\n        # Delta- = L_max / I for L_max >= 1, 0 otherwise.\n        # This condition is equivalent to L_max > 0 for non-integer steps.\n        # A threshold of 1 is safer for float comparisons.\n        Delta_minus = L_max / I if L_max >= 1.0 else 0.0\n        # Delta+ = (L_max + 1) / I\n        Delta_plus = (L_max + 1) / I\n\n        # 4. Budgeted angular momentum L_rot_budget\n        # Solve L(L+1)/(2*I) = E_budget => L^2 + L - 2*I*E_budget = 0\n        discriminant_arg = 1.0 + 8.0 * I * E_budget\n        if discriminant_arg < 0:\n            # Should not happen for physical inputs\n            L_cont_max = 0.0\n        else:\n            L_cont_max = (-1.0 + np.sqrt(discriminant_arg)) / 2.0\n        \n        # Apply parity constraint\n        if n % 2 == 0:  # n is even, L is integer\n            L_rot_budget = np.floor(L_cont_max)\n        else:  # n is odd, L is half-integer\n            # Find largest L = k + 0.5 <= L_cont_max\n            # k <= L_cont_max - 0.5\n            k_max = np.floor(L_cont_max - 0.5)\n            L_rot_budget = k_max + 0.5\n            # Ensure L is non-negative, though problem cases avoid this issue\n            if L_rot_budget < 0:\n                L_rot_budget = 0.0 # Or another indicator for \"no state\"\n\n        # 5. Termination indicator\n        terminated = L_rot_budget > L_max\n\n        # 6. Round all numerical results to 6 decimal places.\n        L_max_r = round(float(L_max), 6)\n        E_L_max_r = round(float(E_L_max), 6)\n        Delta_minus_r = round(float(Delta_minus), 6)\n        Delta_plus_r = round(float(Delta_plus), 6)\n        L_rot_budget_r = round(float(L_rot_budget), 6)\n        occupied_m_list_r = [round(float(m), 6) for m in occupied_m_list]\n\n        # Assemble the result list for the current case\n        case_result = [\n            L_max_r, \n            E_L_max_r, \n            Delta_minus_r, \n            Delta_plus_r, \n            L_rot_budget_r, \n            terminated, \n            occupied_m_list_r\n        ]\n        all_results.append(case_result)\n\n    # Print the final result in the exact format required.\n    # The default str() for a list creates spaces, e.g., \"[1, 2, 3]\".\n    # The template `f\"[{','.join(map(str, results))}]\"` handles this by converting\n    # each sublist to its string representation and joining them.\n    # The final output will look like \"[[item, ...], [item, ...]]\"\n    print(str(all_results).replace(\" \", \"\"))\n\n# An alternative, more explicit print to match the no-space example style\ndef solve_alt_print():\n    # ... (same calculation logic as above) ...\n    test_cases = [\n        (7/2, 4, 25.0, 2.0),\n        (9/2, 10, 20.0, 0.1),\n        (11/2, 1, 30.0, 0.6),\n        (13/2, 7, 18.0, 20.0),\n        (5/2, 0, 25.0, 0.05)\n    ]\n    all_results = []\n    for case in test_cases:\n        j, n, I, E_budget = case\n        L_max = float(n * j - n * (n - 1) / 2.0) if n > 0 else 0.0\n        occupied_m_list = [j - k for k in range(n)] if n > 0 else []\n        E_L_max = L_max * (L_max + 1) / (2.0 * I)\n        Delta_minus = L_max / I if L_max >= 1.0 else 0.0\n        Delta_plus = (L_max + 1) / I\n        discriminant_arg = 1.0 + 8.0 * I * E_budget\n        L_cont_max = (-1.0 + np.sqrt(discriminant_arg)) / 2.0 if discriminant_arg >= 0 else 0.0\n        if n % 2 == 0:\n            L_rot_budget = np.floor(L_cont_max)\n        else:\n            k_max = np.floor(L_cont_max - 0.5)\n            L_rot_budget = k_max + 0.5\n        terminated = L_rot_budget > L_max\n        L_max_r = round(float(L_max), 6)\n        E_L_max_r = round(float(E_L_max), 6)\n        Delta_minus_r = round(float(Delta_minus), 6)\n        Delta_plus_r = round(float(Delta_plus), 6)\n        L_rot_budget_r = round(float(L_rot_budget), 6)\n        occupied_m_list_r = [round(float(m), 6) for m in occupied_m_list]\n        case_result = [ L_max_r, E_L_max_r, Delta_minus_r, Delta_plus_r, L_rot_budget_r, terminated, occupied_m_list_r ]\n        all_results.append(case_result)\n\n    # Manual string construction to avoid spaces\n    def format_item(item):\n        if isinstance(item, bool):\n            return 'True' if item else 'False'\n        return str(item)\n\n    case_strings = []\n    for res in all_results:\n        # Format the inner list [item1,item2,...]\n        inner_list_str = f\"[{','.join(format_item(item) for item in res[:-1])},{str(res[-1]).replace(' ','')}]\"\n        case_strings.append(inner_list_str)\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve_alt_print()\n\n```"
        }
    ]
}