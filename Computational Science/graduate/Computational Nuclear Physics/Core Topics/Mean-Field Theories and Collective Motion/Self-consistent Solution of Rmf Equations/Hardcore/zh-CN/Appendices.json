{
    "hands_on_practices": [
        {
            "introduction": "在相对论平均场 (RMF) 理论中，介子场由非齐次克莱因-戈登方程描述。这个实践练习将指导你为这一关键方程开发一个高效的数值求解器。通过实现并对比两种基于傅里叶变换的方法——格林函数卷积法和谱方法——你将掌握在周期性网格上求解此类偏微分方程的核心技术，并学会处理格林函数在原点处的奇异性，这是所有基于坐标空间 RMF 计算的基石 。",
            "id": "3589493",
            "problem": "考虑在相对论平均场（RMF）理论中出现的三维空间中的线性椭圆场方程，即非齐次克莱因-戈登（Yukawa）方程\n$$\n\\left(-\\Delta + m^2\\right)\\,\\phi(\\mathbf{r}) = s(\\mathbf{r}),\n$$\n其中 $\\Delta$ 是拉普拉斯算子，$m$ 是一个正常数质量参数，$\\phi(\\mathbf{r})$ 是场，$s(\\mathbf{r})$ 是给定的源。该算符在无限空间中的基本解（格林函数）是 Yukawa 核\n$$\nG(\\mathbf{r}) = \\frac{e^{-m r}}{4\\pi r},\\quad r = \\|\\mathbf{r}\\|.\n$$\n通过格林函数表示，一个形式解是卷积\n$$\n\\phi(\\mathbf{r}) = \\int_{\\mathbb{R}^3} G(\\mathbf{r}-\\mathbf{r}')\\,s(\\mathbf{r}')\\,\\mathrm{d}^3\\mathbf{r}'.\n$$\n在计算环境中，通常会将边长为 $L$ 的周期性立方域离散化，每个维度有 $N$ 个点，从而得到均匀的网格间距 $a = L/N$ 和单元体积 $\\Delta V = a^3$。在具有周期性边界条件的此类网格上，离散卷积近似为\n$$\n\\phi_{i,j,k} \\approx \\Delta V \\sum_{i',j',k'} G^{\\mathrm{per}}_{(i-i'),(j-j'),(k-k')} \\, s_{i',j',k'},\n$$\n其中 $G^{\\mathrm{per}}$ 是 Yukawa 核在离散环面上的周期性实现，它是使用最小镜像约定为网格索引差异构建的，因此核函数依赖于折叠距离\n$$\nr_{i,j,k} = a\\,\\sqrt{(\\min(i,N-i))^2 + (\\min(j,N-j))^2 + (\\min(k,N-k))^2}.\n$$\nYukawa 核在 $r=0$ 处的值是奇异的。为了在网格上产生数值稳定的求积，原点处的核函数值应替换为 $G$ 在围绕原点的体素上的平均值。一个简单有效的近似是在一个半径为 $R$ 的球上进行球面平均，该球的半径 $R$ 的选择使其体积等于立方体的单元体积，\n$$\n\\frac{4}{3}\\pi R^3 = \\Delta V,\\quad R = \\left(\\frac{3\\Delta V}{4\\pi}\\right)^{1/3}.\n$$\n通过这种选择，原点处的体素平均核函数值变为\n$$\nG_0 = \\frac{1}{\\Delta V}\\int_{0}^{R} \\frac{e^{-m r}}{4\\pi r} \\, 4\\pi r^2 \\,\\mathrm{d}r = \\frac{1}{\\Delta V}\\int_{0}^{R} e^{-m r}\\, r \\,\\mathrm{d}r = \\frac{1}{m^2 \\Delta V}\\left[1 - \\left(1 + m R\\right)e^{-m R}\\right],\n$$\n当 $m \\to 0$ 时，其极限简化为 $G_0 = \\frac{R^2}{2\\,\\Delta V}$。\n\n另外，同一个周期性问题也允许通过离散傅里叶变换得到谱解，该方法利用了恒等式\n$$\n\\widehat{\\phi}(\\mathbf{k}) = \\frac{\\widehat{s}(\\mathbf{k})}{k^2 + m^2},\\quad k^2 = k_x^2 + k_y^2 + k_z^2,\n$$\n其中 $\\mathbf{k}$ 是与周期域相关的离散波数。这提供了一个一致的参考解，可以用来评估基于卷积的求积的准确性。\n\n您的任务是：\n- 从第一性原理出发，推导格林函数卷积表示和与最小镜像约定及原点体素平均校正一致的离散周期卷积。\n- 设计并实现一个求解器，通过对 $G^{\\mathrm{per}}$ 和 $s$ 使用离散傅里叶变换并进行适当的 $\\Delta V$ 求积缩放，以快速卷积的方式在网格上计算 $\\phi$。\n- 实现一个谱求解器，在同一网格上通过 $\\widehat{\\phi}(\\mathbf{k}) = \\widehat{s}(\\mathbf{k})/(k^2+m^2)$ 计算 $\\phi$，使用离散波数 $k_x = 2\\pi\\,\\mathrm{fftfreq}(N,a)$ 以及类似的 $k_y$ 和 $k_z$。\n- 构建物理上合理的离散源用于测试：一个点状源，使用位于原点、振幅为 $1/\\Delta V$ 的单个单元来近似 Dirac δ 函数；以及一个归一化的周期性高斯函数 $s(\\mathbf{r}) = A \\exp\\left(-r^2/(2\\sigma^2)\\right)$，其中 $A$ 的选择使离散积分 $\\sum s\\,\\Delta V$ 等于 $1$。\n\n本问题中所有量均为无量纲量。\n\n定义误差度量如下：\n- 对于点状源，沿着正 $x$ 轴，将卷积解与前 $M$ 个非零网格点（$i=1,\\dots,M$，其中 $r_i = i\\,a$）的 Yukawa 核解析值进行比较。报告平均绝对相对误差，\n$$\n\\varepsilon_{\\mathrm{pt}} = \\frac{1}{M}\\sum_{i=1}^{M} \\left|\\frac{\\phi_{i,0,0} - G(r_i)}{G(r_i)}\\right|.\n$$\n- 对于高斯源，报告卷积解与谱解在整个网格上的相对 $\\ell^2$ 误差，\n$$\n\\varepsilon_{\\mathrm{gauss}} = \\frac{\\left\\|\\phi_{\\mathrm{conv}} - \\phi_{\\mathrm{spec}}\\right\\|_2}{\\left\\|\\phi_{\\mathrm{spec}}\\right\\|_2},\n$$\n其中离散范数定义为\n$$\n\\left\\|f\\right\\|_2 = \\left(\\sum_{i,j,k} |f_{i,j,k}|^2\\,\\Delta V\\right)^{1/2}.\n$$\n\n测试套件规范：\n- 测试 $1$ (正常路径，点源): $N=48$, $L=24$, $m=1.0$, $M=12$.\n- 测试 $2$ (正常路径，高斯源): $N=48$, $L=24$, $m=1.0$, $\\sigma=1.5$.\n- 测试 $3$ (边界情况，长程): $N=48$, $L=24$, $m=0.1$, $\\sigma=2.0$.\n- 测试 $4$ (边界情况，短程): $N=48$, $L=24$, $m=5.0$, $\\sigma=0.5$.\n\n您的程序必须：\n- 构建具有体素平均原点值 $G_0$ 的周期性 Yukawa 核 $G^{\\mathrm{per}}$，并通过离散傅里叶变换以适当的 $\\Delta V$ 缩放执行快速卷积。\n- 通过离散波数构建谱解，并按规定进行比较。\n- 生成四个浮点数结果，对应于测试 1–4 的误差度量。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$\\left[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4\\right]$）。每个结果必须是浮点数。不应打印其他文本。",
            "solution": "该问题要求使用两种不同但相关的基于傅里叶变换的方法，对周期性立方域上的非齐次克莱因-戈登方程进行数值求解，并对它们的准确性进行定量比较。\n\n### 原理与推导\n\n#### 1. 格林函数与卷积解\n控制方程是线性椭圆偏微分方程（PDE）：\n$$\n\\left(-\\Delta + m^2\\right)\\,\\phi(\\mathbf{r}) = s(\\mathbf{r})\n$$\n其中 $\\Delta = \\nabla^2$ 是拉普拉斯算子，$m$ 是一个正常数质量，$\\phi(\\mathbf{r})$ 是要求解的场，$s(\\mathbf{r})$ 是一个指定的源项。\n\n算符 $L_{\\mathbf{r}} = -\\Delta_{\\mathbf{r}} + m^2$ 的基本解或格林函数 $G(\\mathbf{r}, \\mathbf{r}')$ 由以下方程定义：\n$$\nL_{\\mathbf{r}} G(\\mathbf{r}, \\mathbf{r}') = \\delta(\\mathbf{r} - \\mathbf{r}')\n$$\n其中 $\\delta(\\mathbf{r} - \\mathbf{r}')$ 是 Dirac δ 函数。对于无限的、平移不变的域，格林函数仅取决于位移矢量，即 $G(\\mathbf{r}, \\mathbf{r}') = G(\\mathbf{r}-\\mathbf{r}')$。在这种情况下，解是著名的 Yukawa 势：\n$$\nG(\\mathbf{r}) = \\frac{e^{-m r}}{4\\pi r}, \\quad r = \\|\\mathbf{r}\\|\n$$\n原始偏微分方程的解 $\\phi(\\mathbf{r})$ 可以使用格林函数形式化地表示。令 $L_{\\mathbf{r}'}$ 为作用于 $\\mathbf{r}'$ 坐标的算符。通过应用格林第二恒等式并假设场在无穷远处消失，可以证明：\n$$\n\\phi(\\mathbf{r}) = \\int_{\\mathbb{R}^3} G(\\mathbf{r}-\\mathbf{r}') \\left(L_{\\mathbf{r}'} \\phi(\\mathbf{r}')\\right) \\mathrm{d}^3\\mathbf{r}'\n$$\n代入 $L_{\\mathbf{r}'} \\phi(\\mathbf{r}') = s(\\mathbf{r}')$，我们得到解的卷积表示：\n$$\n\\phi(\\mathbf{r}) = \\int_{\\mathbb{R}^3} G(\\mathbf{r}-\\mathbf{r}')\\,s(\\mathbf{r}')\\,\\mathrm{d}^3\\mathbf{r}' = (G * s)(\\mathbf{r})\n$$\n\n#### 2. 周期性网格上的离散化\n为了进行数值求解，我们将边长为 $L$ 的立方域离散化为一个 $N \\times N \\times N$ 点的网格。网格间距为 $a = L/N$，单个网格单元（体素）的体积为 $\\Delta V = a^3$。连续场 $\\phi(\\mathbf{r})$ 和 $s(\\mathbf{r})$ 由其在网格点上的值 $\\phi_{i,j,k}$ 和 $s_{i,j,k}$ 表示。\n\n卷积积分由离散和近似：\n$$\n\\phi_{i,j,k} \\approx \\sum_{i',j',k'} G(\\mathbf{r}_{i,j,k}-\\mathbf{r}_{i',j',k'}) s_{i',j',k'} \\Delta V\n$$\n对于周期性边界条件，点之间的相互作用必须考虑到域的环绕特性。两点之间的距离应为离散环面上的最短路径。这可以通过使用**最小镜像约定**来实现。对于网格索引 $i \\in [0, N-1]$，一维折叠距离为 $\\min(i, N-i)$。扩展到三维，从原点 $(0,0,0)$ 到点 $(i,j,k)$ 的周期性距离为：\n$$\nr_{i,j,k} = a\\,\\sqrt{(\\min(i,N-i))^2 + (\\min(j,N-j))^2 + (\\min(k,N-k))^2}\n$$\n这定义了在离散周期卷积中使用的周期性核 $G^{\\mathrm{per}}$：\n$$\n\\phi_{i,j,k} = \\Delta V \\sum_{i',j',k'} G^{\\mathrm{per}}_{(i-i'),(j-j'),(k-k')} \\, s_{i',j',k'}\n$$\n其中索引对 $N$ 取模。\n\n#### 3. 原点处的奇异点正则化\nYukawa 核 $G(r) \\propto 1/r$ 在 $r=0$ 处是奇异的。在网格上的朴素计算将导致除以零。为了获得稳定而准确的数值求积，$G^{\\mathrm{per}}_{0,0,0}$ 的值被其在中心体素上的平均值所取代。我们将体积为 $\\Delta V$ 的立方体素近似为一个等体积的球，其半径为 $R = (3\\Delta V / 4\\pi)^{1/3}$。平均核函数值 $G_0$ 为：\n$$\nG_0 = \\frac{1}{\\Delta V} \\int_{\\|\\mathbf{r}\\| \\le R} G(\\mathbf{r}) \\,\\mathrm{d}^3\\mathbf{r} = \\frac{1}{\\Delta V} \\int_0^R \\frac{e^{-m r}}{4\\pi r} 4\\pi r^2 \\,\\mathrm{d}r = \\frac{1}{\\Delta V} \\int_0^R r e^{-m r} \\,\\mathrm{d}r\n$$\n通过分部积分法计算该积分，得到原点处的正则化值：\n$$\nG_0 = \\frac{1}{m^2 \\Delta V}\\left[1 - \\left(1 + m R\\right)e^{-m R}\\right]\n$$\n\n#### 4. 使用傅里叶变换的快速卷积\n直接计算离散卷积和的计算成本很高，对于一个 $N \\times N \\times N$ 的网格，需要 $O(N^6)$ 次操作。卷积定理提供了一条效率高得多的路径。该定理指出，两个函数卷积的傅里叶变换是它们各自傅里叶变换的逐元素乘积：\n$$\n\\mathcal{F}\\{f * g\\} = \\mathcal{F}\\{f\\} \\cdot \\mathcal{F}\\{g\\}\n$$\n将此应用于我们的离散周期卷积，解 $\\phi$ 可以通过以下方式计算：\n$$\n\\phi = \\Delta V \\cdot \\mathrm{IFFT}\\left( \\mathrm{FFT}(G^{\\mathrm{per}}) \\cdot \\mathrm{FFT}(s) \\right)\n$$\n其中 $\\mathrm{FFT}$ 和 $\\mathrm{IFFT}$ 表示快速傅里叶变换及其逆变换。这将计算复杂度降低到 $O(N^3 \\log N)$。\n\n#### 5. 谱解法\n另一种方法是在傅里叶空间中直接求解偏微分方程。对原始方程 $(-\\Delta + m^2)\\,\\phi = s$ 应用傅里叶变换，并利用傅里叶变换作用于拉普拉斯算子相当于乘以 $k^2 = \\|\\mathbf{k}\\|^2$ 的性质，我们得到：\n$$\n(k^2 + m^2)\\,\\widehat{\\phi}(\\mathbf{k}) = \\widehat{s}(\\mathbf{k})\n$$\n其中 $\\widehat{\\phi}$ 和 $\\widehat{s}$ 是 $\\phi$ 和 $s$ 的傅里叶变换，$\\mathbf{k}$ 是波矢。这给出了场傅里叶系数的代数解：\n$$\n\\widehat{\\phi}(\\mathbf{k}) = \\frac{\\widehat{s}(\\mathbf{k})}{k^2 + m^2}\n$$\n然后通过应用逆傅里叶变换找到实空间中的解：$\\phi = \\mathcal{F}^{-1}\\{\\widehat{\\phi}\\}$。在我们的离散网格上，波数 $\\mathbf{k} = (k_x, k_y, k_z)$ 由 $k_x = 2\\pi f_x$ 给出，其中 $f_x$ 是来自 `numpy.fft.fftfreq(N, a)` 的离散频率。由于 $m > 0$，分母 $k^2 + m^2$ 始终非零，确保了解是良定义的。这种谱方法在数学上等价于周期卷积，并可作为验证实现的可靠参考。\n\n#### 6. 源项和误差定义\n问题指定了两种用于测试的源类型：\n1.  **点源**：Dirac δ 函数的离散近似，$s_{i,j,k} = \\delta_{i0}\\delta_{j0}\\delta_{k0} / \\Delta V$。积分 $\\sum s \\Delta V = 1$。\n2.  **高斯源**：周期性高斯函数 $s(\\mathbf{r}) = A \\exp(-r^2/(2\\sigma^2))$，其中 $r$ 是周期性距离，A 是归一化常数，确保 $\\sum s \\Delta V = 1$。\n\n误差度量为：\n1.  $\\varepsilon_{\\mathrm{pt}}$：对于点源，解与沿一个轴的解析无限空间格林函数 $G(r)$进行比较。这测试了离散化的准确性以及周期性边界条件的影响。\n2.  $\\varepsilon_{\\mathrm{gauss}}$：对于高斯源，使用相对 $\\ell^2$ 范数将卷积解 $\\phi_{\\mathrm{conv}}$ 与谱解 $\\phi_{\\mathrm{spec}}$ 进行比较。这验证了两种实现的数值方法的一致性。\n\n下面的实现为指定的测试套件系统地执行了这些计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_error(source_type, N, L, m, M, sigma):\n    \"\"\"\n    Computes the solution to the Klein-Gordon equation and the specified error metric.\n    \n    Args:\n        source_type (str): 'point' or 'gauss'.\n        N (int): Number of grid points per dimension.\n        L (float): Side length of the cubic domain.\n        m (float): Mass parameter.\n        M (int): Number of points for point-source error calculation.\n        sigma (float): Width of the Gaussian source.\n\n    Returns:\n        float: The calculated error.\n    \"\"\"\n    # Grid parameters\n    a = L / N\n    dV = a**3\n\n    # Create grid indices and distances using minimal image convention\n    i, j, k = np.ogrid[0:N, 0:N, 0:N]\n    ix = np.minimum(i, N - i)\n    iy = np.minimum(j, N - j)\n    ik = np.minimum(k, N - k)\n    r_grid = a * np.sqrt(ix**2 + iy**2 + ik**2)\n    \n    # 1. Construct the periodic Yukawa kernel G_per\n    # Voxel-averaged value at the origin\n    R = (3 * dV / (4 * np.pi))**(1/3)\n    if m > 1e-9: # Avoid division by zero for m -> 0\n        G0 = (1 - (1 + m * R) * np.exp(-m * R)) / (m**2 * dV)\n    else: # Limit of G0 as m -> 0\n        G0 = R**2 / (2 * dV)\n    \n    # Kernel on the grid\n    G_per = np.divide(np.exp(-m * r_grid), 4 * np.pi * r_grid, where=(r_grid != 0))\n    G_per[0, 0, 0] = G0\n\n    # 2. Construct the source term s\n    s = np.zeros((N, N, N), dtype=float)\n    if source_type == 'point':\n        s[0, 0, 0] = 1.0 / dV\n    elif source_type == 'gauss':\n        s_unnormalized = np.exp(-r_grid**2 / (2 * sigma**2))\n        integral_s = np.sum(s_unnormalized) * dV\n        s = s_unnormalized / integral_s\n\n    # 3. Compute solution via fast convolution (Method 1)\n    s_hat = np.fft.fftn(s)\n    G_per_hat = np.fft.fftn(G_per)\n    \n    phi_conv = dV * np.fft.ifftn(G_per_hat * s_hat)\n    phi_conv = np.real(phi_conv)\n\n    # 4. Calculate error based on source type\n    if source_type == 'point':\n        # Compare with analytical Yukawa kernel on x-axis\n        r_vals = a * np.arange(1, M + 1)\n        G_analytical = np.exp(-m * r_vals) / (4 * np.pi * r_vals)\n        phi_on_axis = phi_conv[1:M+1, 0, 0]\n        \n        relative_errors = np.abs((phi_on_axis - G_analytical) / G_analytical)\n        error = np.mean(relative_errors)\n        return error\n        \n    elif source_type == 'gauss':\n        # Compare with spectral solution (Method 2)\n        # Wave numbers\n        k_vals = 2 * np.pi * np.fft.fftfreq(N, a)\n        kx, ky, kz = np.meshgrid(k_vals, k_vals, k_vals, indexing='ij')\n        k2 = kx**2 + ky**2 + kz**2\n\n        phi_spec_hat = np.divide(s_hat, k2 + m**2)\n        \n        phi_spec = np.fft.ifftn(phi_spec_hat)\n        phi_spec = np.real(phi_spec)\n\n        # Relative L2 error\n        norm_spec_sq = np.sum(phi_spec**2) * dV\n        norm_diff_sq = np.sum((phi_conv - phi_spec)**2) * dV\n        \n        if norm_spec_sq == 0:\n            return 0.0 if norm_diff_sq == 0 else 1.0\n\n        error = np.sqrt(norm_diff_sq / norm_spec_sq)\n        return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'type': 'point', 'N': 48, 'L': 24, 'm': 1.0, 'sigma': None,  'M': 12},\n        {'type': 'gauss', 'N': 48, 'L': 24, 'm': 1.0, 'sigma': 1.5,   'M': None},\n        {'type': 'gauss', 'N': 48, 'L': 24, 'm': 0.1, 'sigma': 2.0,   'M': None},\n        {'type': 'gauss', 'N': 48, 'L': 24, 'm': 5.0, 'sigma': 0.5,   'M': None},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_error(\n            source_type=case['type'],\n            N=case['N'],\n            L=case['L'],\n            m=case['m'],\n            M=case['M'],\n            sigma=case['sigma']\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了介子场求解器后，下一步是将其整合到一个完整的自洽循环中。这个练习构建了一个简化的 RMF 玩具模型，其中核子密度和矢量势通过迭代求解，直至达到自洽 。你将亲手实现这个迭代过程，并探索在非线性计算中一个重要的数值问题——混淆效应（aliasing），通过对比直接计算和采用“三分之二法则”去混淆的计算结果，你将深入理解在自洽场计算中保证数值精度的重要性。",
            "id": "3589504",
            "problem": "考虑一个立方周期性区域中的对称核物质的简化相对论平均场 (RMF) 模型，其中矢量介子场的类时分量被处理为与汤川核的卷积。使用自然单位制，即 $\\hbar = c = 1$，长度以飞米 (fm) 表示，动量以反飞米 (fm$^{-1}$) 表示。重子密度用 $\\rho(\\mathbf{r})$ 表示，核子静止质量用 $M$ 表示，矢量介子质量用 $m_\\omega$ 表示，矢量耦合用 $g_\\omega$ 表示。核子感受到的类时矢量势为 $V(\\mathbf{r})$，化学势 (一个常数) 为 $\\mu$。\n\n从静态极限下矢量介子的 RMF 场方程，即亥姆霍兹型方程\n$$\n\\left(-\\nabla^2 + m_\\omega^2\\right)\\,\\omega^0(\\mathbf{r}) = g_\\omega\\,\\rho(\\mathbf{r}),\n$$\n出发，定义玩具矢量势为 $V(\\mathbf{r}) = g_\\omega\\,\\omega^0(\\mathbf{r})$。证明 $V(\\mathbf{r})$ 可由与汤川核 $K(\\mathbf{r})$ 的卷积给出：\n$$\nV(\\mathbf{r}) = \\int \\mathrm{d}^3 r'\\,K(\\mathbf{r}-\\mathbf{r}')\\,\\rho(\\mathbf{r}'), \\quad K(\\mathbf{r}) = \\frac{g_\\omega^2}{4\\pi}\\frac{e^{-m_\\omega r}}{r},\n$$\n其在傅里叶空间中等效地表示为：\n$$\n\\tilde{V}(\\mathbf{k}) = \\tilde{K}(\\mathbf{k})\\,\\tilde{\\rho}(\\mathbf{k}), \\quad \\tilde{K}(\\mathbf{k}) = \\frac{g_\\omega^2}{\\mathbf{k}^2 + m_\\omega^2},\n$$\n其中波浪号表示傅里叶变换，$\\mathbf{k}$ 是波矢。\n\n假设核子单粒子能量由一个被 $V(\\mathbf{r})$ 平移的相对论色散关系给出：\n$$\nE(\\mathbf{k},\\mathbf{r}) = \\sqrt{\\mathbf{k}^2 + M^2} + V(\\mathbf{r}),\n$$\n并且化学势满足局域关系：\n$$\n\\mu = \\sqrt{k_F(\\mathbf{r})^2 + M^2} + V(\\mathbf{r}),\n$$\n因此局域费米动量 $k_F(\\mathbf{r})$ 等于：\n$$\nk_F(\\mathbf{r}) = \\sqrt{\\max\\left(0, \\left[\\mu - V(\\mathbf{r})\\right]^2 - M^2\\right)}.\n$$\n对于对称核物质，自旋-同位旋简并因子 $\\gamma = 4$，局域重子密度为：\n$$\n\\rho(\\mathbf{r}) = \\frac{\\gamma}{6\\pi^2}\\,k_F(\\mathbf{r})^3.\n$$\n\n您的任务是为一个边长为 $L$、具有 $N^3$ 个均匀网格点的周期性立方盒子实现一个自洽求解器。该求解器必须：\n\n1.  将密度初始化为一个均匀背景，该背景由 $\\mu$ 计算得出，并加上一个位于盒子中心的高斯凸起：\n    $$\n    \\rho_{\\mathrm{init}}(\\mathbf{r}) = \\rho_{\\mathrm{bg}} + A\\exp\\left(-\\frac{|\\mathbf{r}|^2}{2\\sigma^2}\\right), \\quad \\rho_{\\mathrm{bg}} = \\frac{\\gamma}{6\\pi^2}\\left[\\max\\left(0,\\sqrt{\\mu^2 - M^2}\\right)\\right]^3,\n    $$\n    其中 $A$ 是凸起的振幅，$\\sigma$ 是其宽度。\n\n2.  迭代自洽循环：\n    -   通过快速傅里叶变换 (FFT)，使用谱形式 $\\tilde{V}(\\mathbf{k}) = \\tilde{K}(\\mathbf{k})\\tilde{\\rho}(\\mathbf{k})$ 和周期性边界条件，由 $\\rho(\\mathbf{r})$ 计算 $V(\\mathbf{r})$。\n    -   使用上述局域费米动量表达式更新密度。\n    -   应用参数为 $\\alpha$ 的线性混合：\n        $$\n        \\rho^{(n+1)}(\\mathbf{r}) = (1 - \\alpha)\\,\\rho^{(n)}(\\mathbf{r}) + \\alpha\\,\\rho_{\\mathrm{new}}(\\mathbf{r}).\n        $$\n    -   当密度的最大绝对变化满足\n        $$\n        \\|\\rho_{\\mathrm{new}} - \\rho^{(n)}\\|_{\\infty}  \\varepsilon,\n        $$\n        或达到最大迭代次数时停止。\n\n3.  实现求解器的两个变体以研究混叠现象：\n    -   一个“直接”的基于 FFT 的求解器，不进行谱滤波。\n    -   一个“去混叠”的求解器，使用三分之二规则：在构建 $\\rho_{\\mathrm{new}}(\\mathbf{r})$ 后，将其变换到傅里叶空间，并将任何分量满足 $|k_i| > \\frac{2}{3}k_{\\mathrm{Ny}}$ 的所有模式设置为零，其中 $k_{\\mathrm{Ny}} = \\frac{\\pi N}{L}$ 是奈奎斯特波数，然后在混合前回变到实空间。\n\n使用动量网格间距\n$$\n\\Delta k = \\frac{2\\pi}{L},\n$$\n对于每个测试用例，必须以 fm$^{-1}$ 为单位报告该值。\n\n通过为每个测试用例计算以下内容来量化混叠效应和自洽性：\n-   $\\Delta k$ 的值，单位为 fm$^{-1}$。\n-   收敛后的直接矢量势和去混叠矢量势之间的相对差异：\n    $$\n    \\mathrm{err} = \\frac{\\|\\ V_{\\mathrm{direct}} - V_{\\mathrm{dealiased}}\\ \\|_2}{\\|\\ V_{\\mathrm{dealiased}}\\ \\|_2},\n    $$\n    其中 $\\|\\cdot\\|_2$ 是网格上的欧几里得范数。\n-   一个布尔值，指示直接求解器是否达到不动点容差；以及一个布尔值，指示去混叠求解器是否达到不动点容差。\n\n为以下测试套件实现程序（所有长度单位为 fm，所有动量单位为 fm$^{-1}$）：\n\n-   用例 1（理想情况，特征温和）：$N = 32$, $L = 30$, $\\sigma = 4$, $A = 0.05$, $M = 4.759$, $m_\\omega = 3.97$, $g_\\omega = 1.0$, $\\mu = 5.0$, $\\alpha = 0.4$, $\\varepsilon = 10^{-6}$, 最大迭代次数 $= 200$。\n-   用例 2（中等分辨率，更陡的凸起）：$N = 24$, $L = 18$, $\\sigma = 2$, $A = 0.08$, $M = 4.759$, $m_\\omega = 3.97$, $g_\\omega = 1.0$, $\\mu = 5.0$, $\\alpha = 0.4$, $\\varepsilon = 10^{-6}$, 最大迭代次数 $= 200$。\n-   用例 3（边界/边缘混叠，粗糙网格，陡峭凸起）：$N = 16$, $L = 10$, $\\sigma = 1$, $A = 0.10$, $M = 4.759$, $m_\\omega = 3.97$, $g_\\omega = 1.0$, $\\mu = 5.0$, $\\alpha = 0.4$, $\\varepsilon = 10^{-6}$, 最大迭代次数 $= 200$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个元素对应一个测试用例，本身是包含按上述顺序排列的四个条目的列表：\n$$\n\\left[\\left[\\Delta k_1, \\mathrm{err}_1, \\mathrm{success}_{\\mathrm{direct},1}, \\mathrm{success}_{\\mathrm{dealiased},1}\\right], \\left[\\Delta k_2, \\mathrm{err}_2, \\mathrm{success}_{\\mathrm{direct},2}, \\mathrm{success}_{\\mathrm{dealiased},2}\\right], \\left[\\Delta k_3, \\mathrm{err}_3, \\mathrm{success}_{\\mathrm{direct},3}, \\mathrm{success}_{\\mathrm{dealiased},3}\\right]\\right].\n$$\n所有报告的 $\\Delta k$ 必须以 fm$^{-1}$ 为单位，所有误差都是无单位的浮点数。布尔值必须是字面上的 true/false 值。不得打印任何其他文本。",
            "solution": "在静态极限下，矢量介子的 RMF 描述源于将欧拉-拉格朗日方程应用于 RMF 拉格朗日量密度的线性化矢量部分。在平均场没有时间依赖性的情况下，场方程简化为一个屏蔽泊松或亥姆霍兹型方程：\n$$\n\\left(-\\nabla^2 + m_\\omega^2\\right)\\,\\omega^0(\\mathbf{r}) = g_\\omega\\,\\rho(\\mathbf{r}),\n$$\n其中 $\\omega^0(\\mathbf{r})$ 是矢量场的类时分量，$m_\\omega$ 是矢量介子质量，$g_\\omega$ 是矢量耦合，$\\rho(\\mathbf{r})$ 是重子密度。在自由空间中的解是一个汤川卷积：\n$$\n\\omega^0(\\mathbf{r}) = \\int \\mathrm{d}^3 r'\\,\\frac{g_\\omega}{4\\pi}\\frac{e^{-m_\\omega |\\mathbf{r} - \\mathbf{r}'|}}{|\\mathbf{r} - \\mathbf{r}'|}\\,\\rho(\\mathbf{r}').\n$$\n由于核子矢量势为 $V(\\mathbf{r}) = g_\\omega \\omega^0(\\mathbf{r})$，它变为：\n$$\nV(\\mathbf{r}) = \\int \\mathrm{d}^3 r'\\,K(\\mathbf{r}-\\mathbf{r}')\\,\\rho(\\mathbf{r}'), \\quad K(\\mathbf{r}) = \\frac{g_\\omega^2}{4\\pi}\\frac{e^{-m_\\omega r}}{r}.\n$$\n在一个边长为 $L$、具有 $N^3$ 个均匀网格点的周期性区域中，卷积可以通过快速傅里叶变换 (FFT) 使用卷积定理高效计算。用波浪号表示傅里叶变换，\n$$\n\\tilde{V}(\\mathbf{k}) = \\tilde{K}(\\mathbf{k})\\,\\tilde{\\rho}(\\mathbf{k}), \\quad \\tilde{K}(\\mathbf{k}) = \\frac{g_\\omega^2}{\\mathbf{k}^2 + m_\\omega^2}.\n$$\n这里 $\\mathbf{k}$ 遍历与周期性边界条件一致的离散波矢，其分量为：\n$$\nk_i = \\frac{2\\pi}{L}\\,n_i, \\quad n_i \\in \\left\\{-\\frac{N}{2},\\ldots,\\frac{N}{2}-1\\right\\}.\n$$\n在浮点 FFT 实现中，这些值可以方便地从返回离散频率的函数中获得，再乘以 $2\\pi$ 将每单位长度的周期数转换为每单位长度的弧度。\n\n对于重子密度和自洽更新，我们使用相对论费米气体表达式，其中自旋-同位旋简并因子 $\\gamma = 4$ 适用于对称核物质。位置 $\\mathbf{r}$ 处的核子单粒子能量为：\n$$\nE(\\mathbf{k},\\mathbf{r}) = \\sqrt{\\mathbf{k}^2 + M^2} + V(\\mathbf{r}),\n$$\n其中 $M$ 是核子质量。通过化学势条件定义局域费米动量：\n$$\n\\mu = \\sqrt{k_F(\\mathbf{r})^2 + M^2} + V(\\mathbf{r}),\n$$\n我们得到：\n$$\nk_F(\\mathbf{r}) = \\sqrt{\\max\\left(0, \\left[\\mu - V(\\mathbf{r})\\right]^2 - M^2\\right)}.\n$$\n局域密度随之得出：\n$$\n\\rho(\\mathbf{r}) = \\frac{\\gamma}{6\\pi^2}\\,k_F(\\mathbf{r})^3.\n$$\n该映射 $\\rho(\\mathbf{r}) \\mapsto V(\\mathbf{r}) \\mapsto \\rho(\\mathbf{r})$ 定义了一个非线性不动点问题。我们通过带有线性混合的不动点迭代来解决它：\n$$\n\\rho^{(n+1)}(\\mathbf{r}) = (1 - \\alpha)\\,\\rho^{(n)}(\\mathbf{r}) + \\alpha\\,\\rho_{\\mathrm{new}}(\\mathbf{r}),\n$$\n其中 $\\rho_{\\mathrm{new}}$ 是通过局域费米动量关系从 $V$ 获得的密度，$\\alpha \\in (0,1)$ 控制稳定性，$n$ 是迭代索引。使用连续密度之间的无穷范数差异来监控收敛性：\n$$\n\\|\\rho_{\\mathrm{new}} - \\rho^{(n)}\\|_{\\infty}  \\varepsilon.\n$$\n\n当非线性操作产生超出奈奎斯特波数 $k_{\\mathrm{Ny}} = \\frac{\\pi N}{L}$ 的频谱内容，然后在离散表示中折返到较低模式时，就会出现混叠。动量间距为 $\\Delta k = \\frac{2\\pi}{L}$，更精细的分辨率（更小的 $\\Delta k$ 和更大的 $k_{\\mathrm{Ny}}$）可以减少混叠。为表征混叠对自洽性的影响，我们实现了两个求解器变体：一个没有谱滤波的“直接”求解器和一个对更新后的密度 $\\rho_{\\mathrm{new}}$ 应用三分之二规则的“去混叠”求解器。三分之二规则将任何分量满足以下条件的傅里叶模式设置为零：\n$$\n|k_i| > \\frac{2}{3}k_{\\mathrm{Ny}},\n$$\n从而在每个方向上移除最高三分之一的模式，减轻由高频分量的非线性生成引起的混叠。该滤波器在混合前应用于 $\\rho_{\\mathrm{new}}$，迭代的其余部分照常进行。\n\n我们通过计算收敛后的矢量势的相对差异来量化混叠：\n$$\n\\mathrm{err} = \\frac{\\|\\ V_{\\mathrm{direct}} - V_{\\mathrm{dealiased}}\\ \\|_2}{\\|\\ V_{\\mathrm{dealiased}}\\ \\|_2},\n$$\n其中较小的值表示混叠影响最小。我们还报告每个求解器是否在迭代预算内达到了不动点容差 $\\varepsilon$。初始密度由化学势 $\\mu$ 构建为一个均匀背景：\n$$\n\\rho_{\\mathrm{bg}} = \\frac{\\gamma}{6\\pi^2}\\left(\\max\\left[0,\\sqrt{\\mu^2 - M^2}\\right]\\right)^3,\n$$\n并加上一个位于盒子中心的振幅为 $A$、宽度为 $\\sigma$ 的高斯凸起：\n$$\n\\rho_{\\mathrm{init}}(\\mathbf{r}) = \\rho_{\\mathrm{bg}} + A\\exp\\left(-\\frac{|\\mathbf{r}|^2}{2\\sigma^2}\\right).\n$$\n\n每个测试用例的算法步骤如下：\n-   在 $[-L/2, L/2)$ 区间上构建每边有 $N$ 个点的均匀立方网格。\n-   使用 FFT 频率约定构建离散波矢分量，并计算 $\\tilde{K}(\\mathbf{k}) = \\frac{g_\\omega^2}{\\mathbf{k}^2 + m_\\omega^2}$。\n-   将 $\\rho$ 初始化为 $\\rho_{\\mathrm{init}}$。\n-   迭代：通过谱乘法计算 $V$；使用局域费米动量计算 $\\rho_{\\mathrm{new}}$；可选择地对 $\\rho_{\\mathrm{new}}$ 应用三分之二谱滤波器；混合以更新 $\\rho$；检查收敛性。\n-   收敛或达到最大迭代次数后，记录是否达到容差，并计算直接和去混叠收敛的 $V$ 场之间的相对差异。\n-   报告 $\\Delta k = \\frac{2\\pi}{L}$ 和各项指标。\n\n提供的测试套件涵盖了三个场景：一个分辨率良好的用例，一个具有更陡峭特征的中等分辨率用例，以及一个具有陡峭特征的粗糙网格用例以暴露混叠问题。最终程序输出一行，结果聚合为一个列表的列表：\n$$\n\\left[\\left[\\Delta k_1, \\mathrm{err}_1, \\mathrm{success}_{\\mathrm{direct},1}, \\mathrm{success}_{\\mathrm{dealiased},1}\\right], \\left[\\Delta k_2, \\mathrm{err}_2, \\mathrm{success}_{\\mathrm{direct},2}, \\mathrm{success}_{\\mathrm{dealiased},2}\\right], \\left[\\Delta k_3, \\mathrm{err}_3, \\mathrm{success}_{\\mathrm{direct},3}, \\mathrm{success}_{\\mathrm{dealiased},3}\\right]\\right].\n$$\n所有 $\\Delta k$ 值必须以 fm$^{-1}$ 为单位，而误差是无量纲的浮点数。布尔值是表示求解器收敛的字面 true/false 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef k_grid_components(N, L):\n    # FFT frequencies in cycles per unit length, convert to radians per unit length\n    freqs = np.fft.fftfreq(N, d=L/N) * 2.0 * np.pi\n    kx = freqs\n    ky = freqs\n    kz = freqs\n    return kx, ky, kz\n\ndef yukawa_kernel_k(kx, ky, kz, g_omega, m_omega):\n    # Construct k^2 on the 3D grid using broadcasting\n    KX, KY, KZ = np.meshgrid(kx, ky, kz, indexing='ij')\n    k2 = KX**2 + KY**2 + KZ**2\n    # Spectral Yukawa kernel: g^2 / (k^2 + m^2)\n    return (g_omega**2) / (k2 + m_omega**2)\n\ndef fft_convolution(rho, kernel_k):\n    # Convolution via FFT: V_k = K_k * rho_k, V = ifft(V_k)\n    rho_k = np.fft.fftn(rho)\n    V_k = kernel_k * rho_k\n    V = np.fft.ifftn(V_k).real\n    return V\n\ndef two_thirds_filter(field, kx, ky, kz):\n    # Apply 2/3 de-aliasing rule in Fourier space (per-component cutoff)\n    field_k = np.fft.fftn(field)\n    kx_abs = np.abs(kx)\n    ky_abs = np.abs(ky)\n    kz_abs = np.abs(kz)\n    kx_ny = np.max(kx_abs) if kx_abs.size > 0 else 0\n    ky_ny = np.max(ky_abs) if ky_abs.size > 0 else 0\n    kz_ny = np.max(kz_abs) if kz_abs.size > 0 else 0\n    kx_cut = (2.0/3.0) * kx_ny\n    ky_cut = (2.0/3.0) * ky_ny\n    kz_cut = (2.0/3.0) * kz_ny\n    \n    # Create masks for each dimension\n    mask_x = (kx_abs = kx_cut)\n    mask_y = (ky_abs = ky_cut)\n    mask_z = (kz_abs = kz_cut)\n    \n    # Combine masks using broadcasting\n    mask = (mask_x[:, None, None]  mask_y[None, :, None]  mask_z[None, None, :])\n    \n    field_k_filtered = field_k * mask\n    return np.fft.ifftn(field_k_filtered).real\n\ndef local_density_from_potential(V, mu, M, gamma=4.0):\n    # k_F(r) = sqrt( max(0, (mu - V)^2 - M^2) )\n    term = (mu - V)**2 - M**2\n    kF = np.sqrt(np.maximum(0.0, term))\n    rho_new = (gamma / (6.0 * np.pi**2)) * (kF**3)\n    return rho_new\n\ndef initialize_density(N, L, mu, M, A, sigma, gamma=4.0):\n    # Background density from uniform Fermi momentum\n    kF_bg = np.sqrt(max(0.0, mu**2 - M**2))\n    rho_bg = (gamma / (6.0 * np.pi**2)) * (kF_bg**3)\n    # Coordinates centered at 0\n    x = np.linspace(-L/2.0, L/2.0, N, endpoint=False)\n    y = np.linspace(-L/2.0, L/2.0, N, endpoint=False)\n    z = np.linspace(-L/2.0, L/2.0, N, endpoint=False)\n    X, Y, Z = np.meshgrid(x, y, z, indexing='ij')\n    r2 = X**2 + Y**2 + Z**2\n    bump = A * np.exp(-r2 / (2.0 * sigma**2))\n    rho_init = rho_bg + bump\n    return rho_init\n\ndef self_consistent_solver(N, L, sigma, A, M, m_omega, g_omega, mu, alpha, tol, max_iter, dealiased):\n    # Prepare k-space components and kernel\n    kx, ky, kz = k_grid_components(N, L)\n    kernel_k = yukawa_kernel_k(kx, ky, kz, g_omega, m_omega)\n    # Initialize density\n    rho = initialize_density(N, L, mu, M, A, sigma)\n    success = False\n    for _ in range(max_iter):\n        # Compute vector potential via FFT convolution\n        V = fft_convolution(rho, kernel_k)\n        # Local density update\n        rho_new = local_density_from_potential(V, mu, M)\n        # Optional de-aliasing filter on the updated density\n        if dealiased:\n            rho_new = two_thirds_filter(rho_new, kx, ky, kz)\n        # Convergence check\n        res = np.max(np.abs(rho_new - rho))\n        if res  tol:\n            success = True\n            rho = rho_new # Final update\n            break\n        # Mixing\n        rho = (1.0 - alpha) * rho + alpha * rho_new\n    \n    # Final potential from converged (or last iteration) density\n    V_final = fft_convolution(rho, kernel_k)\n    return rho, V_final, success\n\ndef run_case(N, L, sigma, A, M, m_omega, g_omega, mu, alpha, tol, max_iter):\n    # Direct solver\n    rho_d, V_d, succ_d = self_consistent_solver(N, L, sigma, A, M, m_omega, g_omega, mu, alpha, tol, max_iter, dealiased=False)\n    # Dealiased solver\n    rho_f, V_f, succ_f = self_consistent_solver(N, L, sigma, A, M, m_omega, g_omega, mu, alpha, tol, max_iter, dealiased=True)\n    # Relative error between direct and dealiased potentials\n    num = np.linalg.norm((V_d - V_f).ravel())\n    den = np.linalg.norm(V_f.ravel())\n    rel_err = float(num / den) if den != 0.0 else 0.0\n    # Delta k\n    dk = 2.0 * np.pi / L\n    return [dk, rel_err, bool(succ_d), bool(succ_f)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, sigma, A, M, m_omega, g_omega, mu, alpha, tol, max_iter)\n        (32, 30.0, 4.0, 0.05, 4.759, 3.97, 1.0, 5.0, 0.4, 1e-6, 200),\n        (24, 18.0, 2.0, 0.08, 4.759, 3.97, 1.0, 5.0, 0.4, 1e-6, 200),\n        (16, 10.0, 1.0, 0.10, 4.759, 3.97, 1.0, 5.0, 0.4, 1e-6, 200),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, sigma, A, M, m_omega, g_omega, mu, alpha, tol, max_iter = case\n        result = run_case(N, L, sigma, A, M, m_omega, g_omega, mu, alpha, tol, max_iter)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\"'\", \"\").lower())\n\nsolve()\n```"
        },
        {
            "introduction": "真实的 RMF 计算，尤其是在处理形变核时，其核心是求解复杂的狄拉克方程，这导致了高度非线性的自洽映射。本练习通过一个包含 $K$量子数耦合的简化模型，让你深入剖析自洽映射的数学结构，特别是其雅可比矩阵 。你将通过数值方法计算该雅可比矩阵，并分析其性质如何影响迭代收敛性，同时对比简单线性混合与更高级的块结构化准牛顿法，从而领会加速复杂自洽计算收敛的核心思想。",
            "id": "3589498",
            "problem": "考虑一个简化的有限维相对论平均场 (RMF) 模型，用于描述轴向形变的原子核。该模型允许受控地破坏轴向对称性，并允许总角动量在对称轴上的不同投影之间发生耦合。从包含局域洛伦兹标量场和类时洛伦兹矢量场的狄拉克方程，以及RMF标准的自洽定义出发：标量场等于标量密度乘以一个耦合常数，矢量场等于重子（类时）密度乘以另一个耦合常数。在本问题中，您将构建一个对应于两个$K$分量（$K=\\frac{1}{2}$ 和 $K=\\frac{3}{2}$）的双扇区模型，并研究这些$K$分量之间的耦合如何改变自洽场更新映射。您还将推导并实现一个基于场扇区结构的分块拟牛顿预条件子。\n\n模型假设与定义：\n\n- 态空间是两个$K$扇区的直和，每个扇区都具有双分量狄拉克结构（大分量和小分量）。最终的哈密顿量是一个作用于旋量 $\\psi=\\left(u_{1/2},\\ell_{1/2},u_{3/2},\\ell_{3/2}\\right)^{\\mathsf{T}}$ 上的 $4\\times 4$ 厄米矩阵。扇区$K$的自由动能狄拉克块由一个 $2\\times 2$ 矩阵近似，该矩阵具有恒定的有效非对角耦合和恒定的静止质量。将静止质量表示为 $m$，将 $K=\\frac{1}{2}$ 和 $K=\\frac{3}{2}$ 扇区中的动能耦合分别表示为 $p_{1/2}$ 和 $p_{3/2}$。\n\n- 一个洛伦兹标量场 $S_{K}$ 和一个类时洛伦兹矢量场 $V_{K}$ 在每个$K$扇区内起作用。块哈密顿量为\n$$\nH_{K}=\\begin{pmatrix}\nm+V_{K}  p_{K} \\\\\np_{K}  -m+S_{K}\n\\end{pmatrix},\n$$\n对于 $K\\in\\left\\{\\tfrac{1}{2},\\tfrac{3}{2}\\right\\}$。\n\n- 对称性破缺通过一个连接同类狄拉克分量的对角扇区间耦合块 $B$ 来耦合两个$K$扇区。令 $\\beta$ 表示无量纲的形变振幅，$\\eta$ 表示无量纲的对称性破缺强度。扇区间耦合块建模为\n$$\nB=\\eta\\,\\beta\\,\\begin{pmatrix}\nc_{uu}  0 \\\\\n0  c_{\\ell\\ell}\n\\end{pmatrix},\n$$\n其中 $c_{uu}$ 和 $c_{\\ell\\ell}$ 是固定的无量纲常数，表示在对称性破缺下，上分量和下分量在扇区间的耦合强度。完整的哈密顿量是 $4\\times 4$ 矩阵\n$$\nH=\\begin{pmatrix}\nH_{1/2}  B \\\\\nB  H_{3/2}\n\\end{pmatrix}.\n$$\n\n- 该模型使用标准的RMF自洽性：场由占据态旋量的密度决定。对于 $H$ 的一个归一化本征矢量 $\\psi$，将扇区分辨的重子（类时矢量）密度和标量密度定义为\n$$\nn_{v,K}=\\sum_{\\text{occ}}\\left(|u_{K}|^{2}+|\\ell_{K}|^{2}\\right),\\quad\nn_{s,K}=\\sum_{\\text{occ}}\\left(|u_{K}|^{2}-|\\ell_{K}|^{2}\\right),\n$$\n其中求和遍历所有占据的正能本征态。自洽方程为\n$$\nS_{K}=g_{s}\\,n_{s,K},\\quad V_{K}=g_{v}\\,n_{v,K},\n$$\n其中标量和矢量耦合常数分别为 $g_{s}$ 和 $g_{v}$。\n\n- 自洽场更新映射 $g:\\mathbb{R}^{4}\\to\\mathbb{R}^{4}$ 将一个场矢量 $x=\\left(S_{1/2},V_{1/2},S_{3/2},V_{3/2}\\right)$ 映射到一个新的矢量 $x_{\\text{new}}=g(x)$，其获取过程如下：\n  1. 从 $x$ 构建 $H$，\n  2. 对角化 $H$，\n  3. 选择能量最低的正能本征态，直到达到固定的占据数 $N_{\\text{occ}}$，\n  4. 计算 $n_{s,K}$ 和 $n_{v,K}$，\n  5. 设置 $S_{K}=g_{s}\\,n_{s,K}$ 和 $V_{K}=g_{v}\\,n_{v,K}$。\n\n- 用于自洽的不动点方程为 $x=g(x)$。定义残差 $F(x)=x-g(x)$；一个解满足 $F(x^{\\star})=0$。\n\n您的任务：\n\n1. 实现上述模型，参数为 $m$, $p_{1/2}$, $p_{3/2}$, $g_{s}$, $g_{v}$, $c_{uu}$, $c_{\\ell\\ell}$，形变 $\\beta$，对称性破缺强度 $\\eta$ 和占据数 $N_{\\text{occ}}$。使用无量纲公式，不引入任何物理单位。\n\n2. 对于给定的 $x$，通过对称有限差分数值计算 $g(x)$ 和雅可比矩阵 $\\mathrm{D}g(x)$。由此计算谱半径 $\\rho\\left(\\mathrm{D}g(x)\\right)$ 和弗罗贝尼乌斯范数比\n$$\nr_{\\text{off}}=\\frac{\\left\\|\\begin{pmatrix}0  J_{12}\\\\ J_{21}  0\\end{pmatrix}\\right\\|_{F}}{\\|J\\|_{F}},\n$$\n其中 $J=\\mathrm{D}g(x)$ 被划分为对应于变量 $\\left(S_{1/2},V_{1/2}\\right)$ 和 $\\left(S_{3/2},V_{3/2}\\right)$ 的 $2\\times 2$ 块 $J_{ij}$。这个 $r_{\\text{off}}$ 量化了 $K$ 分量的扇区间耦合如何进入自洽更新映射：较大的 $r_{\\text{off}}$ 表示更强的交叉耦合。\n\n3. 为 $F(x)=0$ 实现两个求解器：\n   - 一个线性混合不动点迭代 $x_{k+1}=x_{k}-\\alpha\\,F(x_{k})$，其中阻尼系数 $\\alpha\\in(0,1]$ 是固定的。\n   - 一个拟牛顿预条件迭代 $x_{k+1}=x_{k}-M(x_{k})\\,F(x_{k})$，其中 $M(x)$ 是一个分块结构的预条件子，通过仅反转 $\\mathrm{D}F(x)$ 的 $2\\times 2$ 对角块来近似 $\\left(\\mathrm{D}F(x)\\right)^{-1}$。这里，$\\mathrm{D}F(x)=I-\\mathrm{D}g(x)$，所以您的 $M(x)$ 是一个分块对角矩阵，其块为 $\\left(I-\\mathrm{D}g(x)\\big|_{\\text{sector }K}\\right)^{-1}$，需数值计算；如果需要，通过添加一个小的单位矩阵正倍数来正则化任何接近奇异的块，以确保可逆性。\n\n4. 对于每个测试用例，从 $x_{0}=0$ 开始，对每个求解器进行迭代，直到 $\\|F(x_{k})\\|_{2}\\varepsilon$ 或达到最大迭代次数。对两个求解器使用相同的停止准则，并记录每种方法所需的迭代次数。\n\n5. 在收敛解 $x^{\\star}$ 处（如果收敛失败，则在最后一次迭代处），计算如上定义的 $\\rho\\left(\\mathrm{D}g\\left(x^{\\star}\\right)\\right)$ 和 $r_{\\text{off}}\\left(x^{\\star}\\right)$。\n\n测试套件和所需常量：\n\n- 使用 $m=1.0$, $p_{1/2}=0.8$, $p_{3/2}=1.2$, $g_{s}=-0.6$, $g_{v}=0.7$, $c_{uu}=0.5$, $c_{\\ell\\ell}=0.3$, $N_{\\text{occ}}=2$, $\\alpha=0.2$, $\\varepsilon=1.0\\times 10^{-8}$, 以及 $\\text{max\\_iter}=500$。\n\n- 将以下四个测试用例定义为元组 $(\\beta,\\eta)$：\n  1. $(0.0,0.0)$,\n  2. $(0.2,0.05)$,\n  3. $(0.2,0.2)$,\n  4. $(0.2,0.4)$.\n\n最终输出规格：\n\n- 对于每个测试用例，您的程序必须生成一个包含四个条目的列表：谱半径 $\\rho\\left(\\mathrm{D}g\\left(x^{\\star}\\right)\\right)$（浮点数），非对角块比率 $r_{\\text{off}}\\left(x^{\\star}\\right)$（浮点数），线性混合求解器的迭代次数（整数），以及分块结构拟牛顿预条件求解器的迭代次数（整数）。\n\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由逗号分隔的四元素列表组成的列表，并用方括号括起来（例如，$[\\,[\\rho_{1},r_{1},n_{1}^{\\text{lin}},n_{1}^{\\text{qN}}],\\ldots,[\\rho_{4},r_{4},n_{4}^{\\text{lin}},n_{4}^{\\text{qN}}]\\,]$）。\n\n所有计算都是无量纲的；不要使用任何物理单位。不涉及角度。所有数字在内部均以双精度浮点数表示；最终输出是上述描述的列表结构。",
            "solution": "### 1. 理论与算法框架\n\n该问题要求为一个简化的相对论平均场 (RMF) 模型实现并分析一个自洽解。核心任务是找到一个迭代映射的不动点，该不动点代表了核系统的自洽状态。我们将开发必要的组件：自洽映射、其雅可比矩阵和两个迭代求解器，然后将它们应用于指定的测试用例。\n\n#### 1.1. 模型哈密顿量与态空间\n\n系统由一个作用于四分量旋量 $\\psi=\\left(u_{1/2},\\ell_{1/2},u_{3/2},\\ell_{3/2}\\right)^{\\mathsf{T}}$ 的 $4 \\times 4$ 哈密顿矩阵描述。态空间是两个扇区的直和，由量子数 $K$ 标识，其中 $K \\in \\left\\{\\frac{1}{2}, \\frac{3}{2}\\right\\}$。\n\n完整的哈密顿量 $H$ 由扇区内块 $H_K$ 和扇区间耦合块 $B$ 构建：\n$$\nH=\\begin{pmatrix}\nH_{1/2}  B \\\\\nB  H_{3/2}\n\\end{pmatrix}\n$$\n对于 $K \\in \\left\\{\\frac{1}{2}, \\frac{3}{2}\\right\\}$，扇区内块 $H_K$ 由下式给出：\n$$\nH_{K}=\\begin{pmatrix}\nm+V_{K}  p_{K} \\\\\np_{K}  -m+S_{K}\n\\end{pmatrix}\n$$\n其中 $m$ 是核子静止质量，$p_K$ 是扇区 $K$ 的有效动能耦合，$S_K$ 和 $V_K$ 分别是洛伦兹标量和类时矢量平均场。\n\n扇区间耦合块 $B$ 模拟对称性破缺效应：\n$$\nB=\\eta\\,\\beta\\,\\begin{pmatrix}\nc_{uu}  0 \\\\\n0  c_{\\ell\\ell}\n\\end{pmatrix}\n$$\n此处，$\\beta$ 是形变参数，$\\eta$ 是对称性破缺强度，$c_{uu}$ 和 $c_{\\ell\\ell}$ 是无量纲耦合常数。当 $\\eta=0$ 或 $\\beta=0$ 时，哈密顿量恢复为块对角形式，从而解耦 $K$ 扇区。\n\n#### 1.2. 自洽映射 $g(x)$\n\nRMF理论中的自洽性要求平均场由核子自身产生。这个反馈回路被表述为一个不动点问题。设场矢量为 $x = \\left(S_{1/2}, V_{1/2}, S_{3/2}, V_{3/2}\\right)^{\\mathsf{T}} \\in \\mathbb{R}^4$。自洽映射 $g:\\mathbb{R}^{4}\\to\\mathbb{R}^{4}$ 从一个输入矢量 $x$ 计算更新后的场矢量 $x_{\\text{new}} = g(x)$。计算 $g(x)$ 的算法如下：\n\n1.  **构建哈密顿量**：根据给定的输入场矢量 $x = (S_{1/2}, V_{1/2}, S_{3/2}, V_{3/2})$，使用上述定义组装 $4 \\times 4$ 实对称哈密顿矩阵 $H$。\n2.  **对角化哈密顿量**：求解 $H$ 的本征系统：$H\\psi_i = E_i\\psi_i$。由于 $H$ 是厄米矩阵（在我们的情况下是实对称的），其本征值 $E_i$ 是实数，本征矢量 $\\psi_i$ 可以选择为标准正交的。我们得到4个本征对。\n3.  **确定占据态**：物理基态是通过填充能量最低的单粒子态形成的。根据模型规范，我们选择具有最低正本征值的 $N_{\\text{occ}}$ 个本征态。\n4.  **计算密度**：根据占据本征矢量的集合 $\\{\\psi_{\\text{occ}}\\}$，我们计算扇区分辨的标量和矢量密度：\n    $$\n    n_{s,K}=\\sum_{\\text{occ}}\\left(|u_{K}|^{2}-|\\ell_{K}|^{2}\\right) \\quad \\text{and} \\quad n_{v,K}=\\sum_{\\text{occ}}\\left(|u_{K}|^{2}+|\\ell_{K}|^{2}\\right)\n    $$\n    其中 $u_K$ 和 $\\ell_K$ 是 $K$ 扇区内旋量的上分量和下分量。\n5.  **计算新场**：使用源方程计算新场矢量：\n    $$\n    S_{K,\\text{new}} = g_{s}\\,n_{s,K} \\quad \\text{and} \\quad V_{K,\\text{new}} = g_{v}\\,n_{v,K}\n    $$\n    其中 $g_s$ 和 $g_v$ 是给定的耦合常数。得到的矢量是 $x_{\\text{new}} = (S_{1/2,\\text{new}}, V_{1/2,\\text{new}}, S_{3/2,\\text{new}}, V_{3/2,\\text{new}})^{\\mathsf{T}}$。一个自洽解 $x^\\star$ 满足不动点条件 $x^\\star = g(x^\\star)$。\n\n#### 1.3. 迭代求解器\n\n寻找不动点 $x^\\star$ 等价于寻找残差函数 $F(x) = x - g(x) = 0$ 的根。我们实现两种迭代方法来求解此方程。\n\n##### a) 线性混合法\n这是一种带阻尼的不动点迭代。从初始猜测 $x_0$ 开始，通过以下方式生成迭代序列：\n$$\nx_{k+1} = (1-\\alpha)x_k + \\alpha g(x_k) = x_k - \\alpha (x_k - g(x_k)) = x_k - \\alpha F(x_k)\n$$\n其中 $\\alpha \\in (0, 1]$ 是一个固定的阻尼因子，有助于稳定迭代。如果迭代矩阵的谱半径 $\\rho(I - \\alpha \\mathrm{D}F) = \\rho((1-\\alpha)I + \\alpha \\mathrm{D}g)$ 小于1，通常可以实现收敛。对于简单混合（$\\alpha=1$），此条件为 $\\rho(\\mathrm{D}g(x^\\star))  1$。\n\n##### b) 分块结构拟牛顿法\n求解 $F(x)=0$ 的完整牛顿法是 $x_{k+1} = x_k - [\\mathrm{D}F(x_k)]^{-1} F(x_k)$，其中 $\\mathrm{D}F(x) = I - \\mathrm{D}g(x)$ 是残差的雅可比矩阵。该方法计算成本高，因为它需要在每一步计算并反转完整的 $4 \\times 4$ 雅可比矩阵。\n\n指定的拟牛顿法通过近似雅可比矩阵的逆来简化此过程。我们将雅可比矩阵 $\\mathrm{D}F(x)$ 划分为对应于两个 $K$ 扇区的 $2 \\times 2$ 块：\n$$\n\\mathrm{D}F(x) = \\begin{pmatrix} \\mathrm{D}F_{11}  \\mathrm{D}F_{12} \\\\ \\mathrm{D}F_{21}  \\mathrm{D}F_{22} \\end{pmatrix}\n$$\n预条件子 $M(x)$ 是通过只反转对角块而忽略非对角块来构建的，从而近似 $(\\mathrm{D}F)^{-1}$：\n$$\nM(x) = \\begin{pmatrix} (\\mathrm{D}F_{11})^{-1}  0 \\\\ 0  (\\mathrm{D}F_{22})^{-1} \\end{pmatrix}\n$$\n迭代过程则由下式给出：\n$$\nx_{k+1} = x_{k} - M(x_k) F(x_k)\n$$\n该方法在线性响应的层面上，有效地独立处理每个扇区内的自洽问题，而完整的非线性耦合则保留在 $F(x_k)$ 中。当扇区间耦合（$\\mathrm{D}g$ 的非对角块）较弱时，预计此方法比线性混合法更有效。为了处理对角块中潜在的奇异性，在求逆之前会添加一个小的正则化项 $\\epsilon I$。\n\n#### 1.4. 数值雅可比矩阵与分析指标\n\n映射的雅可比矩阵 $J(x) = \\mathrm{D}g(x)$ 对拟牛顿求解器和解的分析都至关重要。为了保证精度，我们使用对称有限差分格式进行数值计算：\n$$\n\\frac{\\partial g_i}{\\partial x_j}(x) \\approx \\frac{g_i(x + h e_j) - g_i(x - h e_j)}{2h}\n$$\n其中 $h$ 是一个小步长，$e_j$ 是第 $j$ 个标准基矢量。\n\n在收敛解 $x^\\star$ 处，计算两个量：\n1.  **谱半径 $\\rho(\\mathrm{D}g(x^\\star))$**：这是不动点处雅可比矩阵的最大绝对本征值。它决定了简单不动点迭代（$x_{k+1}=g(x_k)$）的局部收敛速率。如果 $\\rho  1$，迭代会局部收敛。\n2.  **非对角块比率 $r_{\\text{off}}(x^\\star)$**：该指标量化了系统线性响应中扇区间耦合的强度。它被定义为雅可比矩阵 $J = \\mathrm{D}g(x^\\star)$ 的非对角块的弗罗贝尼乌斯范数与整个雅可比矩阵的弗罗贝尼乌斯范数之比：\n    $$\n    r_{\\text{off}}=\\frac{\\left\\|\\begin{pmatrix}0  J_{12}\\\\ J_{21}  0\\end{pmatrix}\\right\\|_{F}}{\\|J\\|_{F}} = \\frac{\\sqrt{\\|J_{12}\\|_F^2 + \\|J_{21}\\|_F^2}}{\\|J\\|_F}\n    $$\n    $r_{\\text{off}}=0$ 的值表示在线性响应层面上扇区完全解耦，而较大的值表示扇区之间有更强的串扰，这会减慢简单混合方案的速度，并证明使用像拟牛顿法这样更复杂的求解器是合理的。\n\n### 2. 实现策略\n\n实现首先从定义映射 $g(x)$ 的函数开始。然后，在其上构建用于求解器和分析的包装函数。\n- 一个核心函数 `g_map` 实现 1.2 节中描述的五个步骤。\n- 一个函数 `get_jacobian_Dg` 使用有限差分计算 `g_map` 的雅可比矩阵。\n- 两个求解器函数 `linear_solver` 和 `qn_solver` 实现迭代方案。它们循环直到残差 $F(x)$ 的 $L_2$ 范数低于容差 $\\varepsilon$ 或达到最大迭代次数，然后返回最终解和迭代次数。\n- 一个 `analyze_solution` 函数根据收敛后的雅可比矩阵计算 $\\rho$ 和 $r_{\\text{off}}$。\n- 主脚本遍历由 $(\\beta, \\eta)$ 定义的四个测试用例，从 $x_0=0$ 开始为每个用例调用两个求解器，并收集所需的指标以进行最终格式化输出。使用更稳健的拟牛顿求解器得到的收敛解进行最终分析。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import block_diag\n\n# Set a fixed seed for reproducibility of numerical results\nnp.random.seed(42)\n\ndef g_map(x, beta, eta, params):\n    \"\"\"\n    Computes the self-consistent field update map x_new = g(x).\n\n    Args:\n        x (np.ndarray): Current field vector [S_1/2, V_1/2, S_3/2, V_3/2].\n        beta (float): Deformation amplitude.\n        eta (float): Symmetry-breaking strength.\n        params (dict): Dictionary of model parameters.\n\n    Returns:\n        np.ndarray: The new field vector x_new.\n    \"\"\"\n    # Unpack fields and parameters\n    S_12, V_12, S_32, V_32 = x\n    m, p_12, p_32 = params['m'], params['p_12'], params['p_32']\n    c_uu, c_ll = params['c_uu'], params['c_ll']\n    N_occ = params['N_occ']\n    gs, gv = params['g_s'], params['g_v']\n\n    # 1. Build Hamiltonian\n    H_12 = np.array([[m + V_12, p_12], [p_12, -m + S_12]])\n    H_32 = np.array([[m + V_32, p_32], [p_32, -m + S_32]])\n    B = eta * beta * np.array([[c_uu, 0.0], [0.0, c_ll]])\n    H = np.block([[H_12, B], [B, H_32]])\n\n    # 2. Diagonalize Hamiltonian\n    # H is real symmetric, eigh is efficient and returns sorted eigenvalues\n    eigvals, eigvecs = np.linalg.eigh(H)\n\n    # 3. Identify Occupied States\n    pos_eig_indices = np.where(eigvals > 0)[0]\n    \n    # Ensure there are enough positive energy states\n    if len(pos_eig_indices)  N_occ:\n        # This case should not happen for the given parameters but is good practice\n        # to handle. We return the input vector to indicate a failure in the map.\n        return x\n\n    occupied_indices = pos_eig_indices[:N_occ]\n    occupied_vecs = eigvecs[:, occupied_indices]\n\n    # 4. Compute Densities\n    # occupied_vecs is (4, N_occ).\n    u_12 = occupied_vecs[0, :]\n    l_12 = occupied_vecs[1, :]\n    u_32 = occupied_vecs[2, :]\n    l_32 = occupied_vecs[3, :]\n\n    n_v_12 = np.sum(np.abs(u_12)**2 + np.abs(l_12)**2)\n    n_s_12 = np.sum(np.abs(u_12)**2 - np.abs(l_12)**2)\n    n_v_32 = np.sum(np.abs(u_32)**2 + np.abs(l_32)**2)\n    n_s_32 = np.sum(np.abs(u_32)**2 - np.abs(l_32)**2)\n\n    # 5. Compute New Fields\n    S_12_new = gs * n_s_12\n    V_12_new = gv * n_v_12\n    S_32_new = gs * n_s_32\n    V_32_new = gv * n_v_32\n\n    return np.array([S_12_new, V_12_new, S_32_new, V_32_new])\n\ndef get_jacobian_Dg(x, beta, eta, params):\n    \"\"\"\n    Computes the Jacobian of the g_map numerically using symmetric finite differences.\n    \"\"\"\n    n_dim = len(x)\n    J = np.zeros((n_dim, n_dim))\n    h = params.get('h_fd', 1e-7)\n    \n    for j in range(n_dim):\n        dx = np.zeros(n_dim)\n        dx[j] = h\n        g_plus = g_map(x + dx, beta, eta, params)\n        g_minus = g_map(x - dx, beta, eta, params)\n        J[:, j] = (g_plus - g_minus) / (2 * h)\n        \n    return J\n\ndef linear_solver(x0, beta, eta, params):\n    \"\"\"\n    Solves the fixed-point equation using linear mixing.\n    \"\"\"\n    x = x0.copy()\n    alpha = params['alpha']\n    max_iter = params['max_iter']\n    epsilon = params['epsilon']\n    \n    for i in range(max_iter):\n        g_x = g_map(x, beta, eta, params)\n        F_x = x - g_x\n        if np.linalg.norm(F_x)  epsilon:\n            return x, i + 1\n        x -= alpha * F_x\n        \n    return x, max_iter\n\ndef qn_solver(x0, beta, eta, params):\n    \"\"\"\n    Solves the fixed-point equation using the block-structured quasi-Newton method.\n    \"\"\"\n    x = x0.copy()\n    max_iter = params['max_iter']\n    epsilon = params['epsilon']\n    reg = params.get('reg', 1e-12)\n\n    for i in range(max_iter):\n        g_x = g_map(x, beta, eta, params)\n        F_x = x - g_x\n        \n        if np.linalg.norm(F_x)  epsilon:\n            return x, i + 1\n            \n        J_g = get_jacobian_Dg(x, beta, eta, params)\n        DF = np.eye(4) - J_g\n        \n        DF11 = DF[0:2, 0:2]\n        DF22 = DF[2:4, 2:4]\n        \n        try:\n            DF11_inv = np.linalg.inv(DF11 + reg * np.eye(2))\n            DF22_inv = np.linalg.inv(DF22 + reg * np.eye(2))\n        except np.linalg.LinAlgError:\n            # If inversion fails, fall back to a simple mixing step for this iteration\n            x -= params['alpha'] * F_x\n            continue\n\n        M = block_diag(DF11_inv, DF22_inv)\n        step = M @ F_x\n        x -= step\n        \n    return x, max_iter\n\ndef analyze_solution(x_star, beta, eta, params):\n    \"\"\"\n    Computes spectral radius and off-block ratio at the solution.\n    \"\"\"\n    J = get_jacobian_Dg(x_star, beta, eta, params)\n    \n    # Spectral radius\n    eigvals = np.linalg.eigvals(J)\n    rho = np.max(np.abs(eigvals))\n    \n    # Off-block ratio\n    J12 = J[0:2, 2:4]\n    J21 = J[2:4, 0:2]\n    \n    norm_off = np.sqrt(np.linalg.norm(J12, 'fro')**2 + np.linalg.norm(J21, 'fro')**2)\n    norm_full = np.linalg.norm(J, 'fro')\n    \n    r_off = norm_off / norm_full if norm_full > 0 else 0.0\n    \n    return rho, r_off\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    params = {\n        'm': 1.0, 'p_12': 0.8, 'p_32': 1.2,\n        'g_s': -0.6, 'g_v': 0.7,\n        'c_uu': 0.5, 'c_ll': 0.3,\n        'N_occ': 2, 'alpha': 0.2,\n        'epsilon': 1.0e-8, 'max_iter': 500,\n    }\n    \n    test_cases = [\n        (0.0, 0.0),    # case 1\n        (0.2, 0.05),   # case 2\n        (0.2, 0.2),    # case 3\n        (0.2, 0.4),    # case 4\n    ]\n\n    all_results = []\n    \n    for beta, eta in test_cases:\n        x0 = np.zeros(4)\n        \n        # Run both solvers\n        x_lin, n_lin = linear_solver(x0, beta, eta, params)\n        x_qn, n_qN = qn_solver(x0, beta, eta, params)\n        \n        # Use the converged solution for analysis. If both converge, they should be\n        # effectively identical. If one fails, use the one that converged.\n        # Here we use the result from the QN solver as it's generally more robust.\n        x_star = x_qn\n        \n        rho, r_off = analyze_solution(x_star, beta, eta, params)\n        \n        all_results.append([rho, r_off, n_lin, n_qN])\n\n    # Format the output string as required\n    result_str = \",\".join([\n        f\"[{res[0]:.8f},{res[1]:.8f},{res[2]},{res[3]}]\" for res in all_results\n    ])\n    \n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}