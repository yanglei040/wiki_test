{
    "hands_on_practices": [
        {
            "introduction": "The intrinsic quadrupole moment $Q_0$ is a primary measure of nuclear deformation. While simple models often assume a sharp nuclear surface, realistic nuclei possess a diffuse surface, typically described by a Fermi distribution. This exercise explores how this surface diffuseness, parameterized by $a$, affects the fundamental relationship between the deformation parameter $\\beta_2$ and the observable $Q_0$. By performing an analytical calculation using the Sommerfeld expansion, a powerful tool for low-temperature systems, you will gain a deeper understanding of how microscopic density parameters translate into macroscopic observables and discover the order at which surface effects become important .",
            "id": "3574369",
            "problem": "Consider a proton density described by a deformed Fermi distribution,\n$$\\rho_{p}(r,\\theta)=\\frac{\\rho_{0}}{1+\\exp\\!\\left(\\frac{r-R(\\theta)}{a}\\right)},$$\nwhere $r$ is the radial coordinate, $\\theta$ is the polar angle, $a$ is the diffuseness parameter, $\\rho_{0}$ is a constant chosen to fix the proton number, and the deformed radius is\n$$R(\\theta)=R_{0}\\left[1+\\beta_{2}Y_{20}(\\theta)\\right],$$\nwith $R_{0}$ the spherical reference radius, $\\beta_{2}$ a small quadrupole deformation parameter, and $Y_{20}(\\theta)$ the spherical harmonic with $\\ell=2$ and $m=0$, normalized such that $\\int |Y_{\\ell m}(\\theta,\\phi)|^{2}\\,d\\Omega=1$. The intrinsic quadrupole moment is defined by\n$$Q_{0}=\\sqrt{\\frac{16\\pi}{5}}\\int r^{2}Y_{20}(\\hat{\\mathbf{r}})\\,\\rho_{p}(r,\\theta)\\,d^{3}\\mathbf{r},$$\nwhere $\\hat{\\mathbf{r}}$ denotes the angular direction and $d^{3}\\mathbf{r}=r^{2}\\sin\\theta\\,dr\\,d\\theta\\,d\\phi$.\n\nAssume $|\\beta_{2}|\\ll 1$ and $a/R_{0}\\ll 1$, and keep terms only to linear order in $\\beta_{2}$ and to first order in $a/R_{0}$ throughout. The constant $\\rho_{0}$ is to be determined implicitly by fixing the proton number $Z$ via $\\int \\rho_{p}(r,\\theta)\\,d^{3}\\mathbf{r}=Z$, but you should not explicitly solve for $\\rho_{0}$; instead, you may treat any dependence of $\\rho_{0}$ on $a$ consistently within the stated order in $a/R_{0}$.\n\nYour task is to determine the coefficient $c_{1}$ that quantifies the leading-order correction due to finite diffuseness in the $Q_{0}$–$\\beta_{2}$ relation, defined by the expansion\n$$Q_{0}=\\mathcal{K}\\,\\beta_{2}\\left[1+c_{1}\\,\\frac{a}{R_{0}}+\\mathcal{O}\\!\\left(\\left(\\frac{a}{R_{0}}\\right)^{2}\\right)\\right],$$\nwhere $\\mathcal{K}$ is a constant independent of $a$ that captures the sharp-surface limit. Compute the value of $c_{1}$. Your final answer must be a single real number with no units. No rounding is required.",
            "solution": "We start from the definition of the intrinsic quadrupole moment,\n$$Q_{0}=\\sqrt{\\frac{16\\pi}{5}}\\int r^{2}Y_{20}(\\hat{\\mathbf{r}})\\,\\rho_{p}(r,\\theta)\\,d^{3}\\mathbf{r}.$$\nWith the deformed Fermi density\n$$\\rho_{p}(r,\\theta)=\\frac{\\rho_{0}}{1+\\exp\\!\\left(\\frac{r-R(\\theta)}{a}\\right)},\\quad R(\\theta)=R_{0}\\left[1+\\beta_{2}Y_{20}(\\theta)\\right],$$\nwe treat $\\beta_{2}$ as small and expand $\\rho_{p}$ to first order in $\\beta_{2}$ around $R_{0}$. Define\n$$F(r;R)\\equiv \\frac{1}{1+\\exp\\!\\left(\\frac{r-R}{a}\\right)}.$$\nThen\n$$\\rho_{p}(r,\\theta)=\\rho_{0}F(r;R(\\theta))\\approx \\rho_{0}\\left[F(r;R_{0})+\\left(R(\\theta)-R_{0}\\right)\\frac{\\partial F(r;R)}{\\partial R}\\Big|_{R=R_{0}}\\right],$$\nand since $R(\\theta)-R_{0}=R_{0}\\beta_{2}Y_{20}(\\theta)$, this becomes\n$$\\rho_{p}(r,\\theta)\\approx \\rho_{0}\\left[F(r;R_{0})+R_{0}\\beta_{2}Y_{20}(\\theta)\\,\\frac{\\partial F(r;R)}{\\partial R}\\Big|_{R=R_{0}}\\right].$$\n\nSubstituting into the expression for $Q_{0}$ and keeping only terms linear in $\\beta_{2}$,\n\\begin{align*}\nQ_{0}&=\\sqrt{\\frac{16\\pi}{5}}\\int r^{2}Y_{20}(\\hat{\\mathbf{r}})\\,\\rho_{0}\\left[F(r;R_{0})+R_{0}\\beta_{2}Y_{20}(\\theta)\\,\\frac{\\partial F(r;R)}{\\partial R}\\Big|_{R=R_{0}}\\right]\\,d^{3}\\mathbf{r}+\\mathcal{O}(\\beta_{2}^{2})\\\\\n&=\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}\\int r^{2}Y_{20}(\\hat{\\mathbf{r}})F(r;R_{0})\\,d^{3}\\mathbf{r}+\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}\\beta_{2}\\int r^{2}Y_{20}^{2}(\\hat{\\mathbf{r}})\\,\\frac{\\partial F(r;R)}{\\partial R}\\Big|_{R=R_{0}}\\,d^{3}\\mathbf{r}.\n\\end{align*}\nThe first term vanishes because $\\int Y_{20}(\\hat{\\mathbf{r}})\\,d\\Omega=0$. Hence\n$$Q_{0}=\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}\\beta_{2}\\int r^{2}Y_{20}^{2}(\\hat{\\mathbf{r}})\\,\\frac{\\partial F(r;R)}{\\partial R}\\Big|_{R=R_{0}}\\,d^{3}\\mathbf{r}.$$\nUsing $d^{3}\\mathbf{r}=r^{2}\\,dr\\,d\\Omega$ and $\\int Y_{20}^{2}(\\hat{\\mathbf{r}})\\,d\\Omega=1$ by the standard normalization, we obtain\n$$Q_{0}=\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}\\beta_{2}\\int_{0}^{\\infty}r^{4}\\,\\frac{\\partial F(r;R)}{\\partial R}\\Big|_{R=R_{0}}\\,dr.$$\n\nNext, note that\n$$\\frac{\\partial F(r;R)}{\\partial R}=-\\frac{\\partial F(r;R)}{\\partial r},$$\nwhich follows directly from $F(r;R)=f(r-R)$ with $f(x)=1/(1+\\exp(x/a))$. Therefore,\n\\begin{align*}\nQ_{0}&=-\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}\\beta_{2}\\int_{0}^{\\infty}r^{4}\\,\\frac{\\partial F(r;R)}{\\partial r}\\Big|_{R=R_{0}}\\,dr\\\\\n&=-\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}\\beta_{2}\\left[\\left.r^{4}F(r;R_{0})\\right|_{0}^{\\infty}-\\int_{0}^{\\infty}4r^{3}F(r;R_{0})\\,dr\\right]\\\\\n&=\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}\\beta_{2}\\,4\\int_{0}^{\\infty}r^{3}F(r;R_{0})\\,dr,\n\\end{align*}\nsince $\\left.r^{4}F(r;R_{0})\\right|_{0}^{\\infty}=0$.\n\nWe are left with the radial Fermi-Dirac type integral\n$$I_{3}(R_{0},a)\\equiv \\int_{0}^{\\infty}r^{3}F(r;R_{0})\\,dr=\\int_{0}^{\\infty}\\frac{r^{3}}{1+\\exp\\!\\left(\\frac{r-R_{0}}{a}\\right)}\\,dr.$$\nFor small $a/R_{0}$, the well-known Sommerfeld expansion (the same method used for Fermi-Dirac integrals at low temperature) applies to smooth functions $f(r)$, yielding\n$$\\int_{0}^{\\infty}\\frac{f(r)}{1+\\exp\\!\\left(\\frac{r-R_{0}}{a}\\right)}\\,dr=\\int_{0}^{R_{0}}f(r)\\,dr+\\frac{\\pi^{2}}{6}a^{2}f'(R_{0})+\\mathcal{O}(a^{4}).$$\nCrucially, there is no term linear in $a$; the corrections appear as even powers of $a$ because the kernel $1/(1+\\exp((r-R_{0})/a))$ is an even function of $(r-R_{0})$ under a suitable shift and the expansion mirrors the standard low-temperature series in powers of temperature squared.\n\nApplying this with $f(r)=r^{3}$ gives\n$$I_{3}(R_{0},a)=\\int_{0}^{R_{0}}r^{3}\\,dr+\\frac{\\pi^{2}}{6}a^{2}\\left.\\frac{d}{dr}\\left(r^{3}\\right)\\right|_{r=R_{0}}+\\mathcal{O}(a^{4})=\\frac{R_{0}^{4}}{4}+\\frac{\\pi^{2}}{6}a^{2}\\cdot 3R_{0}^{2}+\\mathcal{O}(a^{4}).$$\nTherefore,\n$$Q_{0}=4\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}\\beta_{2}\\left[\\frac{R_{0}^{4}}{4}+\\mathcal{O}(a^{2})\\right]=\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}\\beta_{2}R_{0}^{5}+\\mathcal{O}(a^{2}).$$\n\nWe must also ensure the fixed proton number $Z$, which sets $\\rho_{0}$ by\n$$Z=\\int \\rho_{p}(r,\\theta)\\,d^{3}\\mathbf{r}=4\\pi\\rho_{0}\\int_{0}^{\\infty}r^{2}F(r;R_{0})\\,dr+\\mathcal{O}(\\beta_{2}^{2}).$$\nThe same Sommerfeld expansion with $f(r)=r^{2}$ gives\n$$\\int_{0}^{\\infty}r^{2}F(r;R_{0})\\,dr=\\frac{R_{0}^{3}}{3}+\\frac{\\pi^{2}}{6}a^{2}\\cdot 2R_{0}+\\mathcal{O}(a^{4}),$$\nso to keep $Z$ fixed, any $a$-dependence of $\\rho_{0}$ starts at order $a^{2}$, and there is no linear term in $a$. Consequently, within the requested accuracy (linear order in $a/R_{0}$), $\\rho_{0}$ can be taken as $a$-independent, and no linear-in-$a$ correction to $Q_{0}$ arises from the normalization.\n\nCombining these results, the $Q_{0}$–$\\beta_{2}$ relation has the form\n$$Q_{0}=\\mathcal{K}\\,\\beta_{2}\\left[1+\\mathcal{O}\\!\\left(\\left(\\frac{a}{R_{0}}\\right)^{2}\\right)\\right],$$\nwith\n$$\\mathcal{K}=\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}^{5},$$\nand the coefficient $c_{1}$ of the term linear in $a/R_{0}$ is\n$$c_{1}=0.$$\nThis conclusion is a direct consequence of the Sommerfeld expansion structure, which yields only even powers of $a$ for smooth test functions $f(r)$; hence, the first nonvanishing correction due to finite diffuseness is of order $(a/R_{0})^{2}$, and the linear term vanishes.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "Nuclear structure models often employ different conventions for parameterizing quadrupole deformation, such as the Nilsson parameters $(\\epsilon_2, \\gamma)$ tied to an anisotropic oscillator basis, and the Bohr-Mottelson parameters $(\\beta_2, \\gamma)$ describing the nuclear surface. This practice demonstrates how to create a \"translation key\" between these frameworks by equating their predicted mass quadrupole moments, $Q_{20}$ and $Q_{22}$. Implementing this mapping will provide you with a crucial practical skill for comparing results from different theoretical calculations and understanding the physical distinctions, such as spin-orbit polarization effects, that can lead to discrepancies between parameterizations .",
            "id": "3574409",
            "problem": "Consider two widely used nuclear deformation parameterizations for quadrupole shapes: (i) the Nilsson anisotropy parameters $(\\epsilon_2, \\gamma)$, traditionally linked to anisotropic harmonic oscillator basis shapes, and (ii) the self-consistent Bohr–Mottelson deformation parameters $(\\beta_2, \\gamma)$, which parameterize the nuclear surface in terms of spherical harmonics. The task is to quantify, for given parameter sets, the discrepancy between these parameterizations by equating their implied intrinsic quadrupole tensor moments and solving for an equivalent $(\\beta_2,\\gamma)$ that reproduces the Nilsson quadrupole moments.\n\nFoundational definitions and assumptions:\n- The mass quadrupole tensor moments are defined by $Q_{2\\mu} = \\int \\rho(\\vec r)\\, r^2\\, Y_{2\\mu}(\\hat r)\\, d^3 r$ for $\\mu \\in \\{0,2\\}$, where $Y_{2\\mu}$ are the spherical harmonics normalized on the unit sphere. \n- To first order in small quadrupole deformations that conserve volume, an axially symmetric reference radius $R_0$ is perturbed as $R(\\theta,\\phi) = R_0 \\left[ 1 + \\sum_{\\mu} \\alpha_{2\\mu} Y_{2\\mu}(\\theta,\\phi) \\right]$, and the resulting intrinsic quadrupole moments satisfy a linear relationship $Q_{2\\mu} = C\\, A\\, R_0^2\\, \\alpha_{2\\mu}$, where $C$ is a normalization constant and $A$ is the mass number. You must work in the small-deformation, first-order regime under volume conservation. Take $R_0 = r_0 A^{1/3}$ with $r_0 = 1.2\\,\\mathrm{fm}$ as a physically realistic nuclear radius constant.\n- In the self-consistent parameterization, use the standard quadrupole surface expansion coefficients $\\alpha_{20} = \\beta_2 \\cos \\gamma$ and $\\alpha_{22} = \\beta_2 \\sin \\gamma / \\sqrt{2}$.\n- For the Nilsson parameterization in the small-anisotropy limit, model the effective deformation entering the quadrupole moment as follows: the basis anisotropy contributes $\\alpha^{\\text{basis}}_{20} = k_{\\epsilon}\\, \\epsilon_2 \\cos \\gamma$ and $\\alpha^{\\text{basis}}_{22} = k_{\\epsilon}\\, \\epsilon_2 \\sin \\gamma / \\sqrt{2}$. A separate spin–orbit polarization contribution is modeled to be of the same angular form for $\\mu=0$ but with a relative anisotropy factor for $\\mu=2$, namely $\\alpha^{\\text{so}}_{20} = k_{\\epsilon}\\, \\epsilon_2 \\cos \\gamma$ and $\\alpha^{\\text{so}}_{22} = \\chi_{\\mathrm{so}}\\, k_{\\epsilon}\\, \\epsilon_2 \\sin \\gamma / \\sqrt{2}$. The total Nilsson-equivalent coefficients entering the quadrupole moments are then $\\alpha^{\\text{Nilsson}}_{20} = c_{\\mathrm{basis}} \\alpha^{\\text{basis}}_{20} + c_{\\mathrm{so}} \\alpha^{\\text{so}}_{20}$ and $\\alpha^{\\text{Nilsson}}_{22} = c_{\\mathrm{basis}} \\alpha^{\\text{basis}}_{22} + c_{\\mathrm{so}} \\alpha^{\\text{so}}_{22}$, where $c_{\\mathrm{basis}}$ and $c_{\\mathrm{so}}$ weight the basis and spin–orbit contributions, respectively.\n- Use $C = 3/(4\\pi)$ for the normalization constant linking $Q_{2\\mu}$ and $\\alpha_{2\\mu}$ under the stated assumptions.\n\nYour tasks:\n1. Starting from the above definitions, derive how to compute the intrinsic quadrupole moments $Q_{20}$ and $Q_{22}$ from $(\\epsilon_2,\\gamma)$ and the coefficients $(k_{\\epsilon}, c_{\\mathrm{basis}}, c_{\\mathrm{so}}, \\chi_{\\mathrm{so}})$ for both the basis-only case, where $c_{\\mathrm{so}} = 0$, and the combined case, where $c_{\\mathrm{so}}$ is as specified. All angles must be handled in radians.\n2. Given a pair $(Q_{20}, Q_{22})$, derive the inversion to obtain the equivalent $(\\beta_2,\\gamma)$ that would yield the same quadrupole moments under the self-consistent parameterization, using the same $C$, $A$, and $R_0$ as above. Explicitly treat the degenerate case where the fitted deformation amplitude vanishes, and define the fitted $\\gamma$ to be $0$ in that case.\n3. For each test case, compute two discrepancies: the basis-only discrepancies $\\Delta \\beta_{\\mathrm{basis}} = \\beta^{\\mathrm{fit}}_{\\mathrm{basis}} - \\beta^{\\mathrm{sc}}_2$ and $\\Delta \\gamma_{\\mathrm{basis}} = \\gamma^{\\mathrm{fit}}_{\\mathrm{basis}} - \\gamma^{\\mathrm{sc}}$, as well as the total (basis plus spin–orbit) discrepancies $\\Delta \\beta_{\\mathrm{total}} = \\beta^{\\mathrm{fit}}_{\\mathrm{total}} - \\beta^{\\mathrm{sc}}_2$ and $\\Delta \\gamma_{\\mathrm{total}} = \\gamma^{\\mathrm{fit}}_{\\mathrm{total}} - \\gamma^{\\mathrm{sc}}$. Angles must be expressed in radians, and all outputs are dimensionless numbers. The program should round each reported float to six decimal places.\n4. Implement your derivation as a complete, runnable program that produces the specified outputs for the following test suite of parameter values. Use $r_0 = 1.2\\,\\mathrm{fm}$ and $C = 3/(4\\pi)$ for all cases.\n\nTest suite (all $\\gamma$ values are provided in radians):\n- Case 1: $A = 164$, $\\epsilon_2 = 0.28$, $\\gamma = 0.34906585$, $\\beta^{\\mathrm{sc}}_2 = 0.25$, $\\gamma^{\\mathrm{sc}} = 0.35$, $k_{\\epsilon} = 1.0$, $c_{\\mathrm{basis}} = 1.0$, $c_{\\mathrm{so}} = 0.3$, $\\chi_{\\mathrm{so}} = 0.8$.\n- Case 2: $A = 76$, $\\epsilon_2 = 0.22$, $\\gamma = 1.04719755$, $\\beta^{\\mathrm{sc}}_2 = 0.19$, $\\gamma^{\\mathrm{sc}} = 1.04719755$, $k_{\\epsilon} = 1.0$, $c_{\\mathrm{basis}} = 0.9$, $c_{\\mathrm{so}} = 0.15$, $\\chi_{\\mathrm{so}} = 1.0$.\n- Case 3 (near-spherical edge case): $A = 208$, $\\epsilon_2 = 0.0$, $\\gamma = 0.0$, $\\beta^{\\mathrm{sc}}_2 = 0.0$, $\\gamma^{\\mathrm{sc}} = 0.0$, $k_{\\epsilon} = 1.0$, $c_{\\mathrm{basis}} = 1.0$, $c_{\\mathrm{so}} = 0.0$, $\\chi_{\\mathrm{so}} = 1.0$.\n- Case 4 (triaxial): $A = 100$, $\\epsilon_2 = 0.18$, $\\gamma = 0.52359878$, $\\beta^{\\mathrm{sc}}_2 = 0.16$, $\\gamma^{\\mathrm{sc}} = 0.50$, $k_{\\epsilon} = 0.95$, $c_{\\mathrm{basis}} = 1.1$, $c_{\\mathrm{so}} = 0.25$, $\\chi_{\\mathrm{so}} = 0.7$.\n\nFinal output format:\n- Your program should produce a single line of output containing the per-case results as a comma-separated list of four-element sublists, each sublist ordered as $[\\Delta\\beta_{\\mathrm{basis}}, \\Delta\\gamma_{\\mathrm{basis}}, \\Delta\\beta_{\\mathrm{total}}, \\Delta\\gamma_{\\mathrm{total}}]$, rounded to six decimal places, with all angles in radians. For example, the output should look like $[[x_1,y_1,z_1,w_1],[x_2,y_2,z_2,w_2],[x_3,y_3,z_3,w_3],[x_4,y_4,z_4,w_4]]$ where each $x_i,y_i,z_i,w_i$ is a float.",
            "solution": "The core task is to map from the Nilsson deformation parameters $(\\epsilon_2, \\gamma)$ to the equivalent Bohr-Mottelson parameters $(\\beta_2, \\gamma)$ by equating their respective predictions for the intrinsic quadrupole moments, $Q_{20}$ and $Q_{22}$.\n\nFirst, we derive the expressions for the intrinsic quadrupole moments, $Q_{2\\mu}$, from the Nilsson parameterization. The problem states that, to first order, the quadrupole moments are linearly related to the surface deformation coefficients $\\alpha_{2\\mu}$ via the formula:\n$$Q_{2\\mu} = C A R_0^2 \\alpha_{2\\mu}$$\nwhere $C=3/(4\\pi)$ is a normalization constant, $A$ is the mass number, and $R_0 = r_0 A^{1/3}$ is the nuclear radius with $r_0 = 1.2\\,\\mathrm{fm}$. This can be rewritten as:\n$$Q_{2\\mu} = C r_0^2 A^{5/3} \\alpha_{2\\mu}$$\nThe total Nilsson-equivalent deformation coefficients, $\\alpha^{\\text{Nilsson}}_{2\\mu}$, are a weighted sum of a basis contribution and a spin-orbit polarization contribution:\n$$\\alpha^{\\text{Nilsson}}_{2\\mu} = c_{\\mathrm{basis}} \\alpha^{\\text{basis}}_{2\\mu} + c_{\\mathrm{so}} \\alpha^{\\text{so}}_{2\\mu}$$\nSubstituting the given definitions for $\\alpha^{\\text{basis}}_{2\\mu}$ and $\\alpha^{\\text{so}}_{2\\mu}$:\nFor $\\mu=0$:\n$$\\alpha^{\\text{Nilsson}}_{20} = c_{\\mathrm{basis}} (k_{\\epsilon} \\epsilon_2 \\cos \\gamma) + c_{\\mathrm{so}} (k_{\\epsilon} \\epsilon_2 \\cos \\gamma) = (c_{\\mathrm{basis}} + c_{\\mathrm{so}}) k_{\\epsilon} \\epsilon_2 \\cos \\gamma$$\nFor $\\mu=2$:\n$$\\alpha^{\\text{Nilsson}}_{22} = c_{\\mathrm{basis}} (k_{\\epsilon} \\epsilon_2 \\sin \\gamma / \\sqrt{2}) + c_{\\mathrm{so}} (\\chi_{\\mathrm{so}} k_{\\epsilon} \\epsilon_2 \\sin \\gamma / \\sqrt{2}) = (c_{\\mathrm{basis}} + c_{\\mathrm{so}} \\chi_{\\mathrm{so}}) k_{\\epsilon} \\epsilon_2 \\frac{\\sin \\gamma}{\\sqrt{2}}$$\nThese expressions allow us to calculate the $\\alpha_{2\\mu}$ values corresponding to the \"total\" Nilsson model, which includes both basis and spin-orbit effects. The \"basis-only\" case is recovered by setting the spin-orbit weight $c_{\\mathrm{so}} = 0$, which yields:\n$$\\alpha^{\\text{basis-only}}_{20} = c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2 \\cos \\gamma$$\n$$\\alpha^{\\text{basis-only}}_{22} = c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2 \\frac{\\sin \\gamma}{\\sqrt{2}}$$\n\nSecond, we derive the inversion from a given set of deformation coefficients $(\\alpha_{20}, \\alpha_{22})$ to the equivalent Bohr-Mottelson parameters, which we denote $(\\beta^{\\text{fit}}_2, \\gamma^{\\text{fit}})$. The self-consistent Bohr-Mottelson parameterization defines the surface coefficients as:\n$$\\alpha_{20} = \\beta^{\\text{fit}}_2 \\cos \\gamma^{\\text{fit}}$$\n$$\\alpha_{22} = \\beta^{\\text{fit}}_2 \\frac{\\sin \\gamma^{\\text{fit}}}{\\sqrt{2}}$$\nWe must solve this system for $\\beta^{\\text{fit}}_2$ and $\\gamma^{\\text{fit}}$. From the second equation, we have $\\beta^{\\text{fit}}_2 \\sin \\gamma^{\\text{fit}} = \\sqrt{2} \\alpha_{22}$. We can now solve for $\\beta^{\\text{fit}}_2$ by squaring and summing the two equations:\n$$(\\beta^{\\text{fit}}_2 \\cos \\gamma^{\\text{fit}})^2 + (\\beta^{\\text{fit}}_2 \\sin \\gamma^{\\text{fit}})^2 = \\alpha_{20}^2 + (\\sqrt{2} \\alpha_{22})^2$$\n$$(\\beta^{\\text{fit}}_2)^2 (\\cos^2 \\gamma^{\\text{fit}} + \\sin^2 \\gamma^{\\text{fit}}) = \\alpha_{20}^2 + 2\\alpha_{22}^2$$\nSince $\\beta^{\\text{fit}}_2$ represents a magnitude and is non-negative, we find:\n$$\\beta^{\\text{fit}}_2 = \\sqrt{\\alpha_{20}^2 + 2\\alpha_{22}^2}$$\nTo find $\\gamma^{\\text{fit}}$, we take the ratio of the two equations, provided $\\beta^{\\text{fit}}_2 \\neq 0$:\n$$\\frac{\\beta^{\\text{fit}}_2 \\sin \\gamma^{\\text{fit}}}{\\beta^{\\text{fit}}_2 \\cos \\gamma^{\\text{fit}}} = \\tan \\gamma^{\\text{fit}} = \\frac{\\sqrt{2} \\alpha_{22}}{\\alpha_{20}}$$\nTo robustly determine the angle, we use the two-argument arctangent function:\n$$\\gamma^{\\text{fit}} = \\operatorname{arctan2}(\\sqrt{2} \\alpha_{22}, \\alpha_{20})$$\nIn the degenerate case where $\\alpha_{20} = 0$ and $\\alpha_{22} = 0$, it follows that $\\beta^{\\text{fit}}_2 = 0$. The angle $\\gamma^{\\text{fit}}$ becomes undefined; per the problem, we set $\\gamma^{\\text{fit}} = 0$ in this situation.\n\nWe note a significant simplification for the basis-only case. Substituting the expressions for $\\alpha^{\\text{basis-only}}_{20}$ and $\\alpha^{\\text{basis-only}}_{22}$ into the inversion formulas:\n$$\\beta^{\\text{fit}}_{\\text{basis}} = \\sqrt{(c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2 \\cos \\gamma)^2 + 2(c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2 \\frac{\\sin \\gamma}{\\sqrt{2}})^2}$$\n$$= \\sqrt{(c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2)^2 (\\cos^2 \\gamma + \\sin^2 \\gamma)} = c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2$$\n$$\\gamma^{\\text{fit}}_{\\text{basis}} = \\operatorname{arctan2}\\left(\\sqrt{2} \\left(c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2 \\frac{\\sin \\gamma}{\\sqrt{2}}\\right), c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2 \\cos \\gamma\\right) = \\operatorname{arctan2}(\\sin \\gamma, \\cos \\gamma) = \\gamma$$\nThus, for the basis-only contribution, the fitted Bohr-Mottelson parameters are simply $\\beta^{\\text{fit}}_{\\text{basis}} = c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2$ and $\\gamma^{\\text{fit}}_{\\text{basis}} = \\gamma$ (the input Nilsson $\\gamma$). A similar simplification for the total contribution occurs if $\\chi_{\\mathrm{so}} = 1$.\n\nThe final step is to compute the discrepancies for each test case.\nFor the basis-only case:\n1.  Calculate $\\beta^{\\text{fit}}_{\\mathrm{basis}} = c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2$ and $\\gamma^{\\text{fit}}_{\\mathrm{basis}} = \\gamma$.\n2.  Compute $\\Delta \\beta_{\\mathrm{basis}} = \\beta^{\\text{fit}}_{\\mathrm{basis}} - \\beta^{\\mathrm{sc}}_2$ and $\\Delta \\gamma_{\\mathrm{basis}} = \\gamma^{\\text{fit}}_{\\mathrm{basis}} - \\gamma^{\\mathrm{sc}}$.\n\nFor the total (basis plus spin-orbit) case:\n1.  Calculate $\\alpha^{\\text{Nilsson}}_{20}$ and $\\alpha^{\\text{Nilsson}}_{22}$ using the full expressions.\n2.  Calculate $\\beta^{\\text{fit}}_{\\mathrm{total}} = \\sqrt{(\\alpha^{\\text{Nilsson}}_{20})^2 + 2(\\alpha^{\\text{Nilsson}}_{22})^2}$.\n3.  Calculate $\\gamma^{\\text{fit}}_{\\mathrm{total}} = \\operatorname{arctan2}(\\sqrt{2} \\alpha^{\\text{Nilsson}}_{22}, \\alpha^{\\text{Nilsson}}_{20})$. Handle the $\\beta^{\\text{fit}}_{\\mathrm{total}}=0$ case by setting $\\gamma^{\\text{fit}}_{\\mathrm{total}}=0$.\n4.  Compute $\\Delta \\beta_{\\mathrm{total}} = \\beta^{\\text{fit}}_{\\mathrm{total}} - \\beta^{\\mathrm{sc}}_2$ and $\\Delta \\gamma_{\\mathrm{total}} = \\gamma^{\\text{fit}}_{\\mathrm{total}} - \\gamma^{\\mathrm{sc}}$.\n\nThese steps are implemented for each provided test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    # Test suite of parameter values.\n    # Each tuple contains:\n    # (A, eps2, gamma_nilsson, beta_sc, gamma_sc, k_eps, c_basis, c_so, chi_so)\n    test_cases = [\n        (164, 0.28, 0.34906585, 0.25, 0.35, 1.0, 1.0, 0.3, 0.8),\n        (76, 0.22, 1.04719755, 0.19, 1.04719755, 1.0, 0.9, 0.15, 1.0),\n        (208, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0),\n        (100, 0.18, 0.52359878, 0.16, 0.50, 0.95, 1.1, 0.25, 0.7)\n    ]\n\n    results = []\n    for case in test_cases:\n        discrepancies = calculate_discrepancies(case)\n        results.append(discrepancies)\n\n    # Format the results into the required string format.\n    formatted_cases = []\n    for case_result in results:\n        # Round each number to six decimal places\n        formatted_numbers = [f\"{num:.6f}\" for num in case_result]\n        formatted_cases.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output = f\"[{','.join(formatted_cases)}]\"\n    print(final_output)\n\ndef calculate_discrepancies(case_params):\n    \"\"\"\n    Calculates the four discrepancy values for a single test case.\n    \n    Args:\n        case_params (tuple): A tuple containing the parameters for one test case.\n        \n    Returns:\n        list: A list of four floats: [delta_beta_basis, delta_gamma_basis, delta_beta_total, delta_gamma_total].\n    \"\"\"\n    (A, eps2, gamma_nilsson, beta_sc, gamma_sc, \n     k_eps, c_basis, c_so, chi_so) = case_params\n\n    # --- Basis-only calculation ---\n    # As derived, the mapping simplifies for the basis-only case.\n    beta_fit_basis = c_basis * k_eps * eps2\n    gamma_fit_basis = gamma_nilsson\n\n    delta_beta_basis = beta_fit_basis - beta_sc\n    delta_gamma_basis = gamma_fit_basis - gamma_sc\n\n    # --- Total (Basis + Spin-Orbit) calculation ---\n    # Calculate Nilsson-equivalent alpha_2mu coefficients\n    cos_gamma_n = np.cos(gamma_nilsson)\n    sin_gamma_n = np.sin(gamma_nilsson)\n    \n    # alpha_20 component\n    alpha_20_total = (c_basis + c_so) * k_eps * eps2 * cos_gamma_n\n    \n    # alpha_22 component\n    alpha_22_total = (c_basis + c_so * chi_so) * k_eps * eps2 * sin_gamma_n / np.sqrt(2)\n    \n    # Invert to find equivalent Bohr-Mottelson parameters\n    # Calculate beta_fit_total\n    beta_fit_total_sq = alpha_20_total**2 + 2 * alpha_22_total**2\n    beta_fit_total = np.sqrt(beta_fit_total_sq)\n    \n    # Calculate gamma_fit_total\n    if beta_fit_total == 0.0:\n        gamma_fit_total = 0.0\n    else:\n        gamma_fit_total = np.arctan2(np.sqrt(2) * alpha_22_total, alpha_20_total)\n\n    # Compute discrepancies for the total case\n    delta_beta_total = beta_fit_total - beta_sc\n    delta_gamma_total = gamma_fit_total - gamma_sc\n    \n    return [delta_beta_basis, delta_gamma_basis, delta_beta_total, delta_gamma_total]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Mean-field theories describe deformed nuclei by breaking fundamental symmetries, such as the conservation of particle number. Advanced theories can restore these symmetries through projection techniques, which significantly alter the predicted potential energy surface. This exercise investigates the differences between two common approaches—particle-number projection before variation (PNP-BV) and after variation (PNP-AV)—using a model energy functional. By calculating and comparing potential energy paths, barrier heights, and local curvatures, you will gain tangible insight into how these sophisticated quantum corrections influence key nuclear phenomena like shape coexistence and fission pathways .",
            "id": "3574394",
            "problem": "Consider a simplified computational model of quadrupole and hexadecapole nuclear shape degrees of freedom where the mean-field energy depends on the axial quadrupole deformation parameter $\\beta_2$ and the axial hexadecapole parameter $\\beta_4$. The model aims to compare particle-number projection before variation (PNP-BV) versus particle-number projection after variation (PNP-AV) on the topology of the energy surface $E(\\beta_2)$ and on barrier heights between oblate and prolate minima. Differences are to be quantified using curvature matrices (Hessians) at the ground-state minima.\n\nFundamental base. Use the following physically motivated and widely accepted principles and modeling steps:\n- Nuclear shape degrees of freedom can be described by multipole parameters, including the dimensionless axial quadrupole parameter $\\beta_2$ and axial hexadecapole parameter $\\beta_4$, with the mean-field energy expandable in even powers of $\\beta_2$ and $\\beta_4$ due to symmetry.\n- Particle-number projection modifies the energy by a term proportional to fluctuations in particle number. The strength and functional dependence of these fluctuations on shape are larger near spherical shapes and weaker at larger deformations.\n\nModel definition. The mean-field energy is defined as\n$$\nE_{\\mathrm{mf}}(\\beta_2,\\beta_4) = a\\left(\\beta_2^2 - \\beta_{0}^2\\right)^2 + b\\,\\beta_2^6 + c\\,\\beta_4^2 + d\\,\\beta_2^2\\,\\beta_4^2 + e\\,\\beta_4^4,\n$$\nwhere $ a $, $ b $, $ c $, $ d $, $ e $ are positive constants and $ \\beta_{0} > 0 $ sets the location of the two symmetric minima.\n\nThe particle-number fluctuation proxy is modeled as\n$$\nS(\\beta_2,\\beta_4) = s_0\\,\\exp\\!\\left(-\\frac{\\beta_2^2}{\\sigma_2^2}\\right) + s_1\\,\\beta_4^2,\n$$\nwhere $ s_0 $, $ s_1 $, and $ \\sigma_2 > 0 $ are constants. The projected energy in the two schemes is\n$$\nE_{\\mathrm{AV}}(\\beta_2,\\beta_4) = E_{\\mathrm{mf}}(\\beta_2,\\beta_4) - k_{\\mathrm{AV}}\\,S(\\beta_2,\\beta_4),\n$$\n$$\nE_{\\mathrm{BV}}(\\beta_2,\\beta_4) = E_{\\mathrm{mf}}(\\beta_2,\\beta_4) - k_{\\mathrm{BV}}\\left(\\alpha\\,s_0\\,\\exp\\!\\left(-\\frac{\\beta_2^2}{\\sigma_2^2}\\right) + s_1\\,\\beta_4^2\\right),\n$$\nwith $ 0  \\alpha \\le 1 $ modeling the reduction of particle-number fluctuations when projection is performed before variation, and $ k_{\\mathrm{AV}} $, $ k_{\\mathrm{BV}} $ being scheme-dependent strengths.\n\nTask. For each scheme, define the one-dimensional path energy $E_{\\mathrm{path}}(\\beta_2)$ by minimizing $E(\\beta_2,\\beta_4)$ with respect to $\\beta_4$ at fixed $\\beta_2$:\n$$\nE_{\\mathrm{path}}(\\beta_2) = \\min_{\\beta_4} E(\\beta_2,\\beta_4).\n$$\nOn this path:\n- Identify the two lowest local minima in $\\beta_2$ (if fewer than two local minima exist in the scanned interval, take the barrier height as $ 0 $).\n- Compute the barrier height as the difference between the maximum of $E_{\\mathrm{path}}(\\beta_2)$ located between the two minima and the lower of the two minima.\n- Compute the curvature matrix (the Hessian with respect to $(\\beta_2,\\beta_4)$) at the ground-state minimum $(\\beta_2^\\star,\\beta_4^\\star)$ for each scheme, and then compute the Frobenius norm of the difference between the curvature matrices from the two schemes:\n$$\n\\|H_{\\mathrm{BV}} - H_{\\mathrm{AV}}\\|_F = \\sqrt{\\sum_{i,j} \\left(H_{\\mathrm{BV},ij} - H_{\\mathrm{AV},ij}\\right)^2}.\n$$\n\nScientific realism constraints:\n- Treat $\\beta_2$ and $\\beta_4$ as dimensionless parameters.\n- Express barrier heights in mega-electronvolts (MeV) as floating-point numbers without any unit symbols in the output.\n- The curvature matrices have entries in mega-electronvolts (MeV) because the parameters are dimensionless; express the Frobenius norm in mega-electronvolts (MeV) as a floating-point number without any unit symbols in the output.\n- Angles are not used in this model; no angle unit specification is required.\n\nAlgorithmic requirements:\n- Perform the $\\beta_4$ minimization analytically by noting that, at fixed $\\beta_2$, the $\\beta_4$-dependent part of the energy is a quartic polynomial of the form $A(\\beta_2)\\,\\beta_4^2 + e\\,\\beta_4^4$ plus terms independent of $\\beta_4$, with $A(\\beta_2)$ scheme-dependent.\n- Scan $\\beta_2$ on a uniform grid in the interval $[-0.6, 0.6]$ using a resolution of $0.001$ in $\\beta_2$ to evaluate $E_{\\mathrm{path}}(\\beta_2)$ in each scheme.\n- Identify local minima and maxima on the discrete path via sign changes of the finite-difference derivative in $\\beta_2$.\n\nCurvature matrices:\n- Compute the curvature matrix $H$ as the $2 \\times 2$ Hessian of the two-variable energy $E(\\beta_2,\\beta_4)$, evaluated at the ground-state minimum $(\\beta_2^\\star,\\beta_4^\\star)$ for each scheme.\n\nTest suite. Use the following three parameter sets, each given as the tuple $(a,b,\\beta_0,c,d,e,s_0,\\sigma_2,s_1,k_{\\mathrm{AV}},k_{\\mathrm{BV}},\\alpha)$, with all constants in mega-electronvolts (MeV) except $\\beta_0$, $\\sigma_2$, which are dimensionless:\n1. Case $1$: $(900.0, 1200.0, 0.30, 30.0, 10.0, 200.0, 3.0, 0.25, 2.0, 1.6, 1.2, 0.7)$.\n2. Case $2$: $(800.0, 500.0, 0.22, 25.0, 8.0, 150.0, 2.5, 0.28, 1.6, 1.4, 1.35, 0.95)$.\n3. Case $3$: $(1000.0, 1600.0, 0.32, 35.0, 12.0, 250.0, 3.2, 0.22, 2.2, 2.0, 1.0, 0.6)$.\n\nRequired outputs per test case:\n- The barrier height for PNP-AV as a float (MeV).\n- The barrier height for PNP-BV as a float (MeV).\n- The difference in barrier heights $H_{\\mathrm{BV}} - H_{\\mathrm{AV}}$ as a float (MeV).\n- The Frobenius norm of the curvature matrix difference at the ground-state minimum as a float (MeV).\n\nFinal output format. Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, in the order of the four values listed above for Case $1$, followed by the four values for Case $2$, followed by the four values for Case $3$. For example, the printed line must have the form\n$[\\text{case1\\_AV\\_barrier},\\text{case1\\_BV\\_barrier},\\text{case1\\_diff},\\text{case1\\_Frob},\\text{case2\\_AV\\_barrier},\\ldots,\\text{case3\\_Frob}]$.",
            "solution": "The solution requires comparing two theoretical schemes, Projection-After-Variation (PNP-AV) and Projection-Before-Variation (PNP-BV), by analyzing the potential energy surface $E(\\beta_2, \\beta_4)$. The core of the method involves determining a one-dimensional potential energy path $E_{\\mathrm{path}}(\\beta_2)$ and evaluating local properties (barriers and curvatures) along this path.\n\n**1. Analytical Minimization and Path Energy $E_{\\mathrm{path}}(\\beta_2)$**\n\nFor both AV and BV schemes, the total energy $E(\\beta_2, \\beta_4)$ can be expressed as a function of $\\beta_4^2$ for a fixed $\\beta_2$:\n$$ E(\\beta_2, \\beta_4) = C(\\beta_2) + A(\\beta_2)\\beta_4^2 + e\\beta_4^4 $$\nwhere $C(\\beta_2)$ contains all terms independent of $\\beta_4$, and $A(\\beta_2)$ collects the coefficients of the $\\beta_4^2$ term.\nFor a generic scheme with parameters $k_{\\mathrm{eff}}$ and $\\alpha_{\\mathrm{eff}}$ (where for AV, $k_{\\mathrm{eff}}=k_{\\mathrm{AV}}, \\alpha_{\\mathrm{eff}}=1$; and for BV, $k_{\\mathrm{eff}}=k_{\\mathrm{BV}}, \\alpha_{\\mathrm{eff}}=\\alpha$):\n$$ E(\\beta_2, \\beta_4) = \\left[a(\\beta_2^2 - \\beta_0^2)^2 + b\\beta_2^6 - k_{\\mathrm{eff}}\\alpha_{\\mathrm{eff}}s_0\\exp\\left(-\\frac{\\beta_2^2}{\\sigma_2^2}\\right)\\right] + (c + d\\beta_2^2 - k_{\\mathrm{eff}}s_1)\\beta_4^2 + e\\beta_4^4 $$\nThus, the coefficient $A(\\beta_2)$ is given by:\n$$ A(\\beta_2) = c + d\\beta_2^2 - k_{\\mathrm{eff}}s_1 $$\nTo find the minimum of $E$ with respect to $\\beta_4$, we compute the partial derivative and set it to zero:\n$$ \\frac{\\partial E}{\\partial\\beta_4} = 2A(\\beta_2)\\beta_4 + 4e\\beta_4^3 = 2\\beta_4 (A(\\beta_2) + 2e\\beta_4^2) = 0 $$\nThe solutions for the optimal $\\beta_4$ are $\\beta_4=0$ or $\\beta_4^2 = -A(\\beta_2)/(2e)$. The second solution is real only if $A(\\beta_2)  0$. We examine the second derivative, $\\frac{\\partial^2 E}{\\partial\\beta_4^2} = 2A(\\beta_2) + 12e\\beta_4^2$, to determine the nature of the extrema.\n- If $A(\\beta_2) \\ge 0$, the only real extremum is at $\\beta_4=0$. The second derivative is $2A(\\beta_2) \\ge 0$, indicating a minimum. The optimal value is $\\beta_4^*(\\beta_2) = 0$.\n- If $A(\\beta_2)  0$, we have a local maximum at $\\beta_4=0$ (since $2A(\\beta_2)0$) and two symmetric minima at $\\beta_4^2 = -A(\\beta_2)/(2e)$. The second derivative at these minima is $-4A(\\beta_2)  0$. The optimal value is $\\beta_4^{*2}(\\beta_2) = -A(\\beta_2)/(2e)$.\n\nThe path energy $E_{\\mathrm{path}}(\\beta_2) = E(\\beta_2, \\beta_4^*(\\beta_2))$ is therefore:\n$$\nE_{\\mathrm{path}}(\\beta_2) =\n\\begin{cases}\nE(\\beta_2, 0)  \\text{if } A(\\beta_2) \\ge 0 \\\\\nE(\\beta_2, 0) - \\frac{A(\\beta_2)^2}{4e}  \\text{if } A(\\beta_2)  0\n\\end{cases}\n$$\nwhere $E(\\beta_2, 0) = a(\\beta_2^2 - \\beta_0^2)^2 + b\\beta_2^6 - k_{\\mathrm{eff}}\\alpha_{\\mathrm{eff}}s_0\\exp\\left(-\\frac{\\beta_2^2}{\\sigma_2^2}\\right)$.\n\n**2. Numerical Path Analysis**\n\nThe algorithm evaluates $E_{\\mathrm{path}}(\\beta_2)$ over a discrete grid for $\\beta_2 \\in [-0.6, 0.6]$. Local minima and maxima are found by identifying sign changes in the numerical first derivative, computed using finite differences, $\\Delta E_i = E_{i+1} - E_i$. A minimum is located at index $i$ if $\\Delta E_{i-1}  0$ and $\\Delta E_{i} \\ge 0$.\nIf at least two local minima are found, they are sorted by energy. The ground-state energy $E_{gs}$ is the lower of the two minimum energies. The barrier height is the energy of the highest point on the path between the locations of these two minima, minus $E_{gs}$. If fewer than two minima exist, the barrier height is $0$.\n\n**3. Curvature Matrix (Hessian) Calculation**\n\nThe Hessian matrix $H$ is the matrix of second partial derivatives of $E(\\beta_2, \\beta_4)$, evaluated at the ground-state minimum $(\\beta_2^\\star, \\beta_4^\\star)$:\n$$\nH = \\begin{pmatrix} \\frac{\\partial^2 E}{\\partial \\beta_2^2}  \\frac{\\partial^2 E}{\\partial \\beta_2 \\partial \\beta_4} \\\\ \\frac{\\partial^2 E}{\\partial \\beta_4 \\partial \\beta_2}  \\frac{\\partial^2 E}{\\partial \\beta_4^2} \\end{pmatrix}_{(\\beta_2^\\star, \\beta_4^\\star)}\n$$\nThe ground state is expected to be a pair of degenerate minima at $(\\pm\\beta_2^\\star, \\beta_4^\\star)$. By convention, we select the prolate minimum ($\\beta_2^\\star > 0$) for the calculation. The corresponding $\\beta_4^\\star$ is determined from the minimization condition at $\\beta_2^\\star$.\n\nThe analytical expressions for the second derivatives are:\n$$\nH_{11} = \\frac{\\partial^2 E}{\\partial \\beta_2^2} = \\left[4a(3\\beta_2^2 - \\beta_0^2) + 30b\\beta_2^4 + 2d\\beta_4^2\\right] - k_{\\mathrm{eff}}\\alpha_{\\mathrm{eff}}s_0 e^{-\\beta_2^2/\\sigma_2^2} \\left(\\frac{4\\beta_2^2}{\\sigma_2^4} - \\frac{2}{\\sigma_2^2}\\right)\n$$\n$$\nH_{22} = \\frac{\\partial^2 E}{\\partial \\beta_4^2} = \\left[2c + 2d\\beta_2^2 + 12e\\beta_4^2\\right] - 2k_{\\mathrm{eff}}s_1\n$$\n$$\nH_{12} = H_{21} = \\frac{\\partial^2 E}{\\partial \\beta_2 \\partial \\beta_4} = 4d\\beta_2\\beta_4\n$$\nThese must be evaluated for each scheme (AV, BV) at their respective ground-state minima, which are generally different, $(\\beta_{2,\\mathrm{AV}}^\\star, \\beta_{4,\\mathrm{AV}}^\\star)$ and $(\\beta_{2,\\mathrm{BV}}^\\star, \\beta_{4,\\mathrm{BV}}^\\star)$.\n\n**4. Final Comparison**\n\nThe final step is to compute the requested quantities: the barrier heights for each scheme, their difference, and the Frobenius norm $\\|H_{\\mathrm{BV}} - H_{\\mathrm{AV}}\\|_F = \\sqrt{\\sum_{i,j}(H_{\\mathrm{BV},ij} - H_{\\mathrm{AV},ij})^2}$. These calculations are implemented for each parameter set provided in the test suite.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases for the nuclear deformation model.\n    It calculates barrier heights and Hessian matrix differences for AV and BV schemes.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: (a, b, β0, c, d, e, s0, σ2, s1, k_AV, k_BV, α)\n        (900.0, 1200.0, 0.30, 30.0, 10.0, 200.0, 3.0, 0.25, 2.0, 1.6, 1.2, 0.7),\n        # Case 2:\n        (800.0, 500.0, 0.22, 25.0, 8.0, 150.0, 2.5, 0.28, 1.6, 1.4, 1.35, 0.95),\n        # Case 3:\n        (1000.0, 1600.0, 0.32, 35.0, 12.0, 250.0, 3.2, 0.22, 2.2, 2.0, 1.0, 0.6),\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        barrier_av, H_av = analyze_scheme(params, 'AV')\n        barrier_bv, H_bv = analyze_scheme(params, 'BV')\n\n        barrier_diff = barrier_bv - barrier_av\n        H_diff = H_bv - H_av\n        frob_norm = np.linalg.norm(H_diff, 'fro')\n\n        all_results.extend([barrier_av, barrier_bv, barrier_diff, frob_norm])\n    \n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef analyze_scheme(params, scheme):\n    \"\"\"\n    Analyzes a single scheme (AV or BV) to calculate barrier height and Hessian matrix.\n\n    Args:\n        params (tuple): A tuple containing all model parameters.\n        scheme (str): The scheme to analyze, either 'AV' or 'BV'.\n\n    Returns:\n        tuple: A tuple containing the calculated barrier height (float) and the \n               Hessian matrix (2x2 numpy array).\n    \"\"\"\n    a, b, b0, c, d, e, s0, sigma2, s1, k_av, k_bv, alpha = params\n\n    if scheme == 'AV':\n        k_eff = k_av\n        alpha_eff = 1.0\n    else:  # BV\n        k_eff = k_bv\n        alpha_eff = alpha\n\n    b2_grid = np.arange(-0.6, 0.601, 0.001)\n\n    # Step 1: Calculate E_path(beta2) by analytically minimizing over beta4\n    A_b2 = c + d * b2_grid**2 - k_eff * s1\n    \n    E_mf_b4_zero = a * (b2_grid**2 - b0**2)**2 + b * b2_grid**6\n    E_corr_b4_zero = k_eff * alpha_eff * s0 * np.exp(-b2_grid**2 / sigma2**2)\n    E_path_b4_zero = E_mf_b4_zero - E_corr_b4_zero\n\n    correction = np.zeros_like(A_b2)\n    neg_A_mask = A_b2  0\n    if np.any(neg_A_mask):\n      correction[neg_A_mask] = -A_b2[neg_A_mask]**2 / (4 * e)\n    E_path = E_path_b4_zero + correction\n\n    # Step 2: Find minima and calculate barrier height\n    dE = np.diff(E_path)\n    min_indices = np.where((dE[:-1]  0)  (dE[1:] = 0))[0] + 1\n    \n    barrier = 0.0\n    \n    if len(min_indices) = 2:\n        min_energies = E_path[min_indices]\n        sorted_indices = np.argsort(min_energies)\n        idx_min1 = min_indices[sorted_indices[0]]\n        idx_min2 = min_indices[sorted_indices[1]]\n        \n        gs_min_energy = E_path[idx_min1]\n        b2_min1 = b2_grid[idx_min1]\n        b2_min2 = b2_grid[idx_min2]\n\n        start_idx = min(idx_min1, idx_min2)\n        end_idx = max(idx_min1, idx_min2)\n        if start_idx  end_idx:\n            barrier_top_energy = np.max(E_path[start_idx:end_idx + 1])\n            barrier = barrier_top_energy - gs_min_energy\n\n        gs_min_indices = min_indices[np.isclose(min_energies, gs_min_energy)]\n        prolate_gs_indices = gs_min_indices[b2_grid[gs_min_indices]  0]\n        if prolate_gs_indices.size  0:\n            gs_b2_star_idx = prolate_gs_indices[0]\n        else:\n             gs_b2_star_idx = np.max(gs_min_indices) if gs_min_indices.size  0 else np.argmin(E_path)\n        gs_b2_star = b2_grid[gs_b2_star_idx]\n\n    else:\n        gs_b2_star_idx = np.argmin(E_path)\n        gs_b2_star = b2_grid[gs_b2_star_idx]\n\n    # Step 3: Calculate Hessian at the ground-state minimum (b2_star, b4_star)\n    A_star = c + d * gs_b2_star**2 - k_eff * s1\n    b4_star_sq = 0.0\n    if A_star  0:\n        b4_star_sq = -A_star / (2 * e)\n    b4_star = np.sqrt(b4_star_sq)\n\n    kf = k_eff * alpha_eff * s0\n    kg = k_eff * s1\n    \n    sigma2_sq = sigma2**2\n    sigma2_p4 = sigma2**4\n    \n    h11 = (4*a*(3*gs_b2_star**2 - b0**2) + 30*b*gs_b2_star**4 + 2*d*b4_star**2) - \\\n          (kf * np.exp(-gs_b2_star**2 / sigma2_sq) * (4*gs_b2_star**2 / sigma2_p4 - 2 / sigma2_sq))\n    \n    h22 = (2*c + 2*d*gs_b2_star**2 + 12*e*b4_star**2) - (2 * kg)\n    \n    h12 = 4 * d * gs_b2_star * b4_star\n\n    H = np.array([[h11, h12], [h12, h22]])\n\n    return barrier, H\n\nsolve()\n```"
        }
    ]
}