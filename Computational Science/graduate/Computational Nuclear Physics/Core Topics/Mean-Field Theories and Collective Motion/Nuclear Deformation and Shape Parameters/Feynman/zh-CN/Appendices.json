{
    "hands_on_practices": [
        {
            "introduction": "原子核的形状可以通过诸如内在四极矩 $Q_0$ 等可观测量来量化，而这些观测量直接源于核内质子和中子的分布。本练习将引导您使用一个更接近真实的形变费米分布，来探索形变参数 $\\beta_2$ 与 $Q_0$ 之间的联系。通过解析推导它们的关系并考虑原子核表面弥散效应，您将更深刻地理解宏观形状参数是如何从微观的核物质密度分布中产生的 。",
            "id": "3574369",
            "problem": "考虑一个由形变的费米分布描述的质子密度，\n$$\\rho_{p}(r,\\theta)=\\frac{\\rho_{0}}{1+\\exp\\!\\left(\\frac{r-R(\\theta)}{a}\\right)},$$\n其中 $r$ 是径向坐标，$\\theta$ 是极角，$a$ 是弥散参数，$\\rho_{0}$ 是为固定质子数而选定的常数，形变半径为\n$$R(\\theta)=R_{0}\\left[1+\\beta_{2}Y_{20}(\\theta)\\right],$$\n其中 $R_{0}$ 是球形参考半径，$\\beta_{2}$ 是一个小的四极形变参数，$Y_{20}(\\theta)$ 是 $\\ell=2$ 和 $m=0$ 的球谐函数，其归一化使得 $\\int |Y_{\\ell m}(\\theta,\\phi)|^{2}\\,d\\Omega=1$。内禀四极矩定义为\n$$Q_{0}=\\sqrt{\\frac{16\\pi}{5}}\\int r^{2}Y_{20}(\\hat{\\mathbf{r}})\\,\\rho_{p}(r,\\theta)\\,d^{3}\\mathbf{r},$$\n其中 $\\hat{\\mathbf{r}}$ 表示角方向，且 $d^{3}\\mathbf{r}=r^{2}\\sin\\theta\\,dr\\,d\\theta\\,d\\phi$。\n\n假设 $|\\beta_{2}|\\ll 1$ 且 $a/R_{0}\\ll 1$，并在整个计算中只保留 $\\beta_{2}$ 的线性阶项和 $a/R_{0}$ 的一阶项。常数 $\\rho_{0}$ 通过固定质子数 $Z$（即 $\\int \\rho_{p}(r,\\theta)\\,d^{3}\\mathbf{r}=Z$）来隐式确定，但你不需要显式求解 $\\rho_{0}$；相反，你可以在 $a/R_{0}$ 的所述阶数内，一致地处理 $\\rho_{0}$ 对 $a$ 的任何依赖关系。\n\n你的任务是确定系数 $c_{1}$，该系数在 $Q_{0}$–$\\beta_{2}$ 关系中量化了由有限弥散性引起的领头阶修正，该关系由以下展开式定义：\n$$Q_{0}=\\mathcal{K}\\,\\beta_{2}\\left[1+c_{1}\\,\\frac{a}{R_{0}}+\\mathcal{O}\\!\\left(\\left(\\frac{a}{R_{0}}\\right)^{2}\\right)\\right],$$\n其中 $\\mathcal{K}$ 是一个与 $a$ 无关的常数，它给出了锐利表面极限的情况。计算 $c_{1}$ 的值。你的最终答案必须是一个无单位的实数。无需四舍五入。",
            "solution": "我们从内禀四极矩的定义开始，\n$$Q_{0}=\\sqrt{\\frac{16\\pi}{5}}\\int r^{2}Y_{20}(\\hat{\\mathbf{r}})\\,\\rho_{p}(r,\\theta)\\,d^{3}\\mathbf{r}.$$\n对于形变的费米密度\n$$\\rho_{p}(r,\\theta)=\\frac{\\rho_{0}}{1+\\exp\\!\\left(\\frac{r-R(\\theta)}{a}\\right)},\\quad R(\\theta)=R_{0}\\left[1+\\beta_{2}Y_{20}(\\theta)\\right],$$\n我们将 $\\beta_{2}$ 视为小量，并将 $\\rho_{p}$ 在 $R_{0}$ 附近对 $\\beta_{2}$ 展开到一阶。定义\n$$F(r;R)\\equiv \\frac{1}{1+\\exp\\!\\left(\\frac{r-R}{a}\\right)}.$$\n那么\n$$\\rho_{p}(r,\\theta)=\\rho_{0}F(r;R(\\theta))\\approx \\rho_{0}\\left[F(r;R_{0})+\\left(R(\\theta)-R_{0}\\right)\\frac{\\partial F(r;R)}{\\partial R}\\Big|_{R=R_{0}}\\right],$$\n又因为 $R(\\theta)-R_{0}=R_{0}\\beta_{2}Y_{20}(\\theta)$，上式变为\n$$\\rho_{p}(r,\\theta)\\approx \\rho_{0}\\left[F(r;R_{0})+R_{0}\\beta_{2}Y_{20}(\\theta)\\,\\frac{\\partial F(r;R)}{\\partial R}\\Big|_{R=R_{0}}\\right].$$\n\n将其代入 $Q_{0}$ 的表达式，并只保留 $\\beta_{2}$ 的线性项，\n\\begin{align*}\nQ_{0}=\\sqrt{\\frac{16\\pi}{5}}\\int r^{2}Y_{20}(\\hat{\\mathbf{r}})\\,\\rho_{0}\\left[F(r;R_{0})+R_{0}\\beta_{2}Y_{20}(\\theta)\\,\\frac{\\partial F(r;R)}{\\partial R}\\Big|_{R=R_{0}}\\right]\\,d^{3}\\mathbf{r}+\\mathcal{O}(\\beta_{2}^{2})\\\\\n=\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}\\int r^{2}Y_{20}(\\hat{\\mathbf{r}})F(r;R_{0})\\,d^{3}\\mathbf{r}+\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}\\beta_{2}\\int r^{2}Y_{20}^{2}(\\hat{\\mathbf{r}})\\,\\frac{\\partial F(r;R)}{\\partial R}\\Big|_{R=R_{0}}\\,d^{3}\\mathbf{r}.\n\\end{align*}\n第一项因为 $\\int Y_{20}(\\hat{\\mathbf{r}})\\,d\\Omega=0$ 而为零。因此\n$$Q_{0}=\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}\\beta_{2}\\int r^{2}Y_{20}^{2}(\\hat{\\mathbf{r}})\\,\\frac{\\partial F(r;R)}{\\partial R}\\Big|_{R=R_{0}}\\,d^{3}\\mathbf{r}.$$\n使用 $d^{3}\\mathbf{r}=r^{2}\\,dr\\,d\\Omega$ 以及根据标准归一化 $\\int Y_{20}^{2}(\\hat{\\mathbf{r}})\\,d\\Omega=1$，我们得到\n$$Q_{0}=\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}\\beta_{2}\\int_{0}^{\\infty}r^{4}\\,\\frac{\\partial F(r;R)}{\\partial R}\\Big|_{R=R_{0}}\\,dr.$$\n\n接下来，注意到\n$$\\frac{\\partial F(r;R)}{\\partial R}=-\\frac{\\partial F(r;R)}{\\partial r},$$\n这可由 $F(r;R)=f(r-R)$（其中 $f(x)=1/(1+\\exp(x/a))$）直接得出。因此，\n\\begin{align*}\nQ_{0}=-\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}\\beta_{2}\\int_{0}^{\\infty}r^{4}\\,\\frac{\\partial F(r;R)}{\\partial r}\\Big|_{R=R_{0}}\\,dr\\\\\n=-\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}\\beta_{2}\\left[\\left.r^{4}F(r;R_{0})\\right|_{0}^{\\infty}-\\int_{0}^{\\infty}4r^{3}F(r;R_{0})\\,dr\\right]\\\\\n=\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}\\beta_{2}\\,4\\int_{0}^{\\infty}r^{3}F(r;R_{0})\\,dr,\n\\end{align*}\n因为 $\\left.r^{4}F(r;R_{0})\\right|_{0}^{\\infty}=0$。\n\n我们剩下的是径向的费米-狄拉克型积分\n$$I_{3}(R_{0},a)\\equiv \\int_{0}^{\\infty}r^{3}F(r;R_{0})\\,dr=\\int_{0}^{\\infty}\\frac{r^{3}}{1+\\exp\\!\\left(\\frac{r-R_{0}}{a}\\right)}\\,dr.$$\n对于小的 $a/R_{0}$，著名的 Sommerfeld 展开（与低温下费米-狄拉克积分所用的方法相同）适用于光滑函数 $f(r)$，得到\n$$\\int_{0}^{\\infty}\\frac{f(r)}{1+\\exp\\!\\left(\\frac{r-R_{0}}{a}\\right)}\\,dr=\\int_{0}^{R_{0}}f(r)\\,dr+\\frac{\\pi^{2}}{6}a^{2}f'(R_{0})+\\mathcal{O}(a^{4}).$$\n关键在于，没有关于 $a$ 的线性项；修正项以 $a$ 的偶次幂形式出现，因为在适当的平移下，核函数 $1/(1+\\exp((r-R_{0})/a))$ 是 $(r-R_{0})$ 的偶函数，并且该展开式与标准的、以温度平方为幂次的低温级数形式相同。\n\n将此应用于 $f(r)=r^{3}$ 得到\n$$I_{3}(R_{0},a)=\\int_{0}^{R_{0}}r^{3}\\,dr+\\frac{\\pi^{2}}{6}a^{2}\\left.\\frac{d}{dr}\\left(r^{3}\\right)\\right|_{r=R_{0}}+\\mathcal{O}(a^{4})=\\frac{R_{0}^{4}}{4}+\\frac{\\pi^{2}}{6}a^{2}\\cdot 3R_{0}^{2}+\\mathcal{O}(a^{4}).$$\n因此，\n$$Q_{0}=4\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}\\beta_{2}\\left[\\frac{R_{0}^{4}}{4}+\\mathcal{O}(a^{2})\\right]=\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}\\beta_{2}R_{0}^{5}+\\mathcal{O}(a^{2}).$$\n\n我们还必须确保质子数 $Z$ 固定，这通过下式设定 $\\rho_{0}$：\n$$Z=\\int \\rho_{p}(r,\\theta)\\,d^{3}\\mathbf{r}=4\\pi\\rho_{0}\\int_{0}^{\\infty}r^{2}F(r;R_{0})\\,dr+\\mathcal{O}(\\beta_{2}^{2}).$$\n同样的 Sommerfeld 展开，当 $f(r)=r^{2}$ 时，给出\n$$\\int_{0}^{\\infty}r^{2}F(r;R_{0})\\,dr=\\frac{R_{0}^{3}}{3}+\\frac{\\pi^{2}}{6}a^{2}\\cdot 2R_{0}+\\mathcal{O}(a^{4}),$$\n因此，为保持 $Z$ 固定，$\\rho_{0}$ 对 $a$ 的任何依赖性都从 $a^{2}$ 阶开始，不存在 $a$ 的线性项。所以，在所要求的精度（$a/R_{0}$ 的线性阶）内，$\\rho_{0}$ 可被视为与 $a$ 无关，并且归一化不会对 $Q_{0}$ 产生 $a$ 的线性修正。\n\n综合这些结果，$Q_{0}$–$\\beta_{2}$ 关系具有以下形式\n$$Q_{0}=\\mathcal{K}\\,\\beta_{2}\\left[1+\\mathcal{O}\\!\\left(\\left(\\frac{a}{R_{0}}\\right)^{2}\\right)\\right],$$\n其中\n$$\\mathcal{K}=\\sqrt{\\frac{16\\pi}{5}}\\rho_{0}R_{0}^{5},$$\n且 $a/R_{0}$ 线性项的系数 $c_{1}$ 为\n$$c_{1}=0.$$\n这个结论是 Sommerfeld 展开结构的直接推论，该展开对于光滑的测试函数 $f(r)$ 只产生 $a$ 的偶次幂项；因此，由有限弥散性引起的第一个非零修正项是 $(a/R_{0})^{2}$ 阶的，而线性项为零。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "不同的原子核结构模型常常使用不同的约定来参数化四极形变，例如 Nilsson 模型中的参数 $(\\epsilon_2, \\gamma)$ 和 Bohr-Mottelson 模型中的参数 $(\\beta_2, \\gamma)$。本练习提供了一种在这些参数化方案之间进行转换的实用方法，其核心思想是要求它们所对应的物理四极矩相等。掌握这种转换是比较不同模型理论结果的一项关键技能，并有助于您理解不同模型（包括对自旋-轨道耦合等效应的不同处理）带来的微妙而重要的差异 。",
            "id": "3574409",
            "problem": "考虑两种广泛使用的针对四极形状的核形变参数化方法：(i) Nilsson 各向异性参数 $\\epsilon_2$ 和 $\\gamma$，传统上与各向异性谐振子基的形状相关联；以及 (ii) 自洽的 Bohr–Mottelson 形变参数 $\\beta_2$ 和 $\\gamma$，它们通过球谐函数来参数化核表面。任务是，对于给定的参数集，通过令它们所蕴含的内禀四极张量矩相等，并求解能够再现 Nilsson 四极矩的等效 $(\\beta_2,\\gamma)$，来量化这两种参数化方法之间的差异。\n\n基本定义与假设：\n- 质量四极张量矩定义为 $Q_{2\\mu} = \\int \\rho(\\vec r)\\, r^2\\, Y_{2\\mu}(\\hat r)\\, d^3 r$，其中 $\\mu \\in \\{0,2\\}$，$Y_{2\\mu}$ 是在单位球面上归一化的球谐函数。\n- 在一阶近似下，对于保持体积的小四极形变，轴对称参考半径 $R_0$ 发生微扰，变为 $R(\\theta,\\phi) = R_0 \\left[ 1 + \\sum_{\\mu} \\alpha_{2\\mu} Y_{2\\mu}(\\theta,\\phi) \\right]$，由此产生的内禀四极矩满足线性关系 $Q_{2\\mu} = C\\, A\\, R_0^2\\, \\alpha_{2\\mu}$，其中 $C$ 是一个归一化常数，$A$ 是质量数。您必须在体积守恒下的小形变、一阶近似范围内进行计算。取 $R_0 = r_0 A^{1/3}$，其中 $r_0 = 1.2\\,\\mathrm{fm}$，这是一个物理上现实的核半径常数。\n- 在自洽参数化中，使用标准的四极表面展开系数 $\\alpha_{20} = \\beta_2 \\cos \\gamma$ 和 $\\alpha_{22} = \\beta_2 \\sin \\gamma / \\sqrt{2}$。\n- 对于小各向异性极限下的 Nilsson 参数化，进入四极矩的有效形变模型如下：基的各向异性贡献为 $\\alpha^{\\text{basis}}_{20} = k_{\\epsilon}\\, \\epsilon_2 \\cos \\gamma$ 和 $\\alpha^{\\text{basis}}_{22} = k_{\\epsilon}\\, \\epsilon_2 \\sin \\gamma / \\sqrt{2}$。一个独立的自旋-轨道极化贡献被建模为对于 $\\mu=0$ 具有相同的角度形式，但对于 $\\mu=2$ 有一个相对各向异性因子，即 $\\alpha^{\\text{so}}_{20} = k_{\\epsilon}\\, \\epsilon_2 \\cos \\gamma$ 和 $\\alpha^{\\text{so}}_{22} = \\chi_{\\mathrm{so}}\\, k_{\\epsilon}\\, \\epsilon_2 \\sin \\gamma / \\sqrt{2}$。因此，进入四极矩的总 Nilsson 等效系数为 $\\alpha^{\\text{Nilsson}}_{20} = c_{\\mathrm{basis}} \\alpha^{\\text{basis}}_{20} + c_{\\mathrm{so}} \\alpha^{\\text{so}}_{20}$ 和 $\\alpha^{\\text{Nilsson}}_{22} = c_{\\mathrm{basis}} \\alpha^{\\text{basis}}_{22} + c_{\\mathrm{so}} \\alpha^{\\text{so}}_{22}$，其中 $c_{\\mathrm{basis}}$ 和 $c_{\\mathrm{so}}$ 分别是基贡献和自旋-轨道贡献的权重。\n- 使用 $C = 3/(4\\pi)$ 作为在所述假设下连接 $Q_{2\\mu}$ 和 $\\alpha_{2\\mu}$ 的归一化常数。\n\n你的任务：\n1.  从上述定义出发，推导如何从 $(\\epsilon_2,\\gamma)$ 和系数 $(k_{\\epsilon}, c_{\\mathrm{basis}}, c_{\\mathrm{so}}, \\chi_{\\mathrm{so}})$ 计算内禀四极矩 $Q_{20}$ 和 $Q_{22}$，包括仅考虑基（$c_{\\mathrm{so}} = 0$）和组合情况（$c_{\\mathrm{so}}$ 如指定）。所有角度必须以弧度处理。\n2.  给定一对 $(Q_{20}, Q_{22})$，推导反演过程以获得等效的 $(\\beta_2,\\gamma)$，该参数在自洽参数化下会产生相同的四极矩，使用与上述相同的 $C$、$A$ 和 $R_0$。明确处理拟合形变幅度为零的退化情况，并在此情况下将拟合的 $\\gamma$ 定义为 $0$。\n3.  对于每个测试用例，计算两种差异：仅基底的差异 $\\Delta \\beta_{\\mathrm{basis}} = \\beta^{\\mathrm{fit}}_{\\mathrm{basis}} - \\beta^{\\mathrm{sc}}_2$ 和 $\\Delta \\gamma_{\\mathrm{basis}} = \\gamma^{\\mathrm{fit}}_{\\mathrm{basis}} - \\gamma^{\\mathrm{sc}}$，以及总（基底加自旋-轨道）差异 $\\Delta \\beta_{\\mathrm{total}} = \\beta^{\\mathrm{fit}}_{\\mathrm{total}} - \\beta^{\\mathrm{sc}}_2$ 和 $\\Delta \\gamma_{\\mathrm{total}} = \\gamma^{\\mathrm{fit}}_{\\mathrm{total}} - \\gamma^{\\mathrm{sc}}$。角度必须用弧度表示，所有输出均为无量纲数。程序应将每个报告的浮点数四舍五入到六位小数。\n4.  将您的推导实现为一个完整的、可运行的程序，为以下参数值的测试套件生成指定的输出。对所有情况使用 $r_0 = 1.2\\,\\mathrm{fm}$ 和 $C = 3/(4\\pi)$。\n\n测试套件（所有 $\\gamma$ 值均以弧度为单位）：\n- 情况 1: $A = 164$, $\\epsilon_2 = 0.28$, $\\gamma = 0.34906585$, $\\beta^{\\mathrm{sc}}_2 = 0.25$, $\\gamma^{\\mathrm{sc}} = 0.35$, $k_{\\epsilon} = 1.0$, $c_{\\mathrm{basis}} = 1.0$, $c_{\\mathrm{so}} = 0.3$, $\\chi_{\\mathrm{so}} = 0.8$。\n- 情况 2: $A = 76$, $\\epsilon_2 = 0.22$, $\\gamma = 1.04719755$, $\\beta^{\\mathrm{sc}}_2 = 0.19$, $\\gamma^{\\mathrm{sc}} = 1.04719755$, $k_{\\epsilon} = 1.0$, $c_{\\mathrm{basis}} = 0.9$, $c_{\\mathrm{so}} = 0.15$, $\\chi_{\\mathrm{so}} = 1.0$。\n- 情况 3 (近球形边界情况): $A = 208$, $\\epsilon_2 = 0.0$, $\\gamma = 0.0$, $\\beta^{\\mathrm{sc}}_2 = 0.0$, $\\gamma^{\\mathrm{sc}} = 0.0$, $k_{\\epsilon} = 1.0$, $c_{\\mathrm{basis}} = 1.0$, $c_{\\mathrm{so}} = 0.0$, $\\chi_{\\mathrm{so}} = 1.0$。\n- 情况 4 (三轴的): $A = 100$, $\\epsilon_2 = 0.18$, $\\gamma = 0.52359878$, $\\beta^{\\mathrm{sc}}_2 = 0.16$, $\\gamma^{\\mathrm{sc}} = 0.50$, $k_{\\epsilon} = 0.95$, $c_{\\mathrm{basis}} = 1.1$, $c_{\\mathrm{so}} = 0.25$, $\\chi_{\\mathrm{so}} = 0.7$。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含每个案例的结果，形式为一个由四元素子列表组成的逗号分隔列表，每个子列表按 $[\\Delta\\beta_{\\mathrm{basis}}, \\Delta\\gamma_{\\mathrm{basis}}, \\Delta\\beta_{\\mathrm{total}}, \\Delta\\gamma_{\\mathrm{total}}]$ 的顺序排列，四舍五入到六位小数，所有角度均以弧度为单位。例如，输出应类似于 $[[x_1,y_1,z_1,w_1],[x_2,y_2,z_2,w_2],[x_3,y_3,z_3,w_3],[x_4,y_4,z_4,w_4]]$，其中每个 $x_i,y_i,z_i,w_i$ 都是浮点数。",
            "solution": "问题陈述在科学上是合理的，提法明确且客观。它提出了一个计算核结构物理学中的标准任务：比较核四极形变的不同参数化方法。所有必要的定义、常数和参数都已提供，并且没有内部矛盾。因此，我们可以进行推导和求解。\n\n核心任务是通过令它们各自对内禀四极矩 $Q_{20}$ 和 $Q_{22}$ 的预测值相等，来建立从 Nilsson 形变参数 $(\\epsilon_2, \\gamma)$ 到等效 Bohr-Mottelson 参数 $(\\beta_2, \\gamma)$ 的映射。\n\n首先，我们从 Nilsson 参数化推导内禀四极矩 $Q_{2\\mu}$ 的表达式。问题陈述指出，在一阶近似下，四极矩与表面形变系数 $\\alpha_{2\\mu}$ 呈线性关系，公式为：\n$$Q_{2\\mu} = C A R_0^2 \\alpha_{2\\mu}$$\n其中 $C=3/(4\\pi)$ 是归一化常数，$A$ 是质量数，$R_0 = r_0 A^{1/3}$ 是核半径，其中 $r_0 = 1.2\\,\\mathrm{fm}$。这可以改写为：\n$$Q_{2\\mu} = C r_0^2 A^{5/3} \\alpha_{2\\mu}$$\n总的 Nilsson 等效形变系数 $\\alpha^{\\text{Nilsson}}_{2\\mu}$ 是基底贡献和自旋-轨道极化贡献的加权和：\n$$\\alpha^{\\text{Nilsson}}_{2\\mu} = c_{\\mathrm{basis}} \\alpha^{\\text{basis}}_{2\\mu} + c_{\\mathrm{so}} \\alpha^{\\text{so}}_{2\\mu}$$\n代入给定的 $\\alpha^{\\text{basis}}_{2\\mu}$ 和 $\\alpha^{\\text{so}}_{2\\mu}$ 的定义：\n对于 $\\mu=0$：\n$$\\alpha^{\\text{Nilsson}}_{20} = c_{\\mathrm{basis}} (k_{\\epsilon} \\epsilon_2 \\cos \\gamma) + c_{\\mathrm{so}} (k_{\\epsilon} \\epsilon_2 \\cos \\gamma) = (c_{\\mathrm{basis}} + c_{\\mathrm{so}}) k_{\\epsilon} \\epsilon_2 \\cos \\gamma$$\n对于 $\\mu=2$：\n$$\\alpha^{\\text{Nilsson}}_{22} = c_{\\mathrm{basis}} (k_{\\epsilon} \\epsilon_2 \\sin \\gamma / \\sqrt{2}) + c_{\\mathrm{so}} (\\chi_{\\mathrm{so}} k_{\\epsilon} \\epsilon_2 \\sin \\gamma / \\sqrt{2}) = (c_{\\mathrm{basis}} + c_{\\mathrm{so}} \\chi_{\\mathrm{so}}) k_{\\epsilon} \\epsilon_2 \\frac{\\sin \\gamma}{\\sqrt{2}}$$\n这些表达式使我们能够计算对应于“总”Nilsson 模型（包括基底和自旋-轨道效应）的 $\\alpha_{2\\mu}$ 值。“仅基底”情况可通过设置自旋-轨道权重 $c_{\\mathrm{so}} = 0$ 来恢复，这得到：\n$$\\alpha^{\\text{basis-only}}_{20} = c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2 \\cos \\gamma$$\n$$\\alpha^{\\text{basis-only}}_{22} = c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2 \\frac{\\sin \\gamma}{\\sqrt{2}}$$\n\n其次，我们推导从给定一组形变系数 $(\\alpha_{20}, \\alpha_{22})$ 反演到等效 Bohr-Mottelson 参数（我们记为 $(\\beta^{\\text{fit}}_2, \\gamma^{\\text{fit}})$）的过程。自洽的 Bohr-Mottelson 参数化将表面系数定义为：\n$$\\alpha_{20} = \\beta^{\\text{fit}}_2 \\cos \\gamma^{\\text{fit}}$$\n$$\\alpha_{22} = \\beta^{\\text{fit}}_2 \\frac{\\sin \\gamma^{\\text{fit}}}{\\sqrt{2}}$$\n我们必须解这个方程组来求 $\\beta^{\\text{fit}}_2$ 和 $\\gamma^{\\text{fit}}$。从第二个方程，我们有 $\\beta^{\\text{fit}}_2 \\sin \\gamma^{\\text{fit}} = \\sqrt{2} \\alpha_{22}$。我们现在可以通过将两个方程平方并相加来求解 $\\beta^{\\text{fit}}_2$：\n$$(\\beta^{\\text{fit}}_2 \\cos \\gamma^{\\text{fit}})^2 + (\\beta^{\\text{fit}}_2 \\sin \\gamma^{\\text{fit}})^2 = \\alpha_{20}^2 + (\\sqrt{2} \\alpha_{22})^2$$\n$$(\\beta^{\\text{fit}}_2)^2 (\\cos^2 \\gamma^{\\text{fit}} + \\sin^2 \\gamma^{\\text{fit}}) = \\alpha_{20}^2 + 2\\alpha_{22}^2$$\n由于 $\\beta^{\\text{fit}}_2$ 代表一个大小并且是非负的，我们得到：\n$$\\beta^{\\text{fit}}_2 = \\sqrt{\\alpha_{20}^2 + 2\\alpha_{22}^2}$$\n为了找到 $\\gamma^{\\text{fit}}$，我们取两个方程的比值，前提是 $\\beta^{\\text{fit}}_2 \\neq 0$：\n$$\\frac{\\beta^{\\text{fit}}_2 \\sin \\gamma^{\\text{fit}}}{\\beta^{\\text{fit}}_2 \\cos \\gamma^{\\text{fit}}} = \\tan \\gamma^{\\text{fit}} = \\frac{\\sqrt{2} \\alpha_{22}}{\\alpha_{20}}$$\n为了稳健地确定角度，我们使用双参数反正切函数：\n$$\\gamma^{\\text{fit}} = \\operatorname{arctan2}(\\sqrt{2} \\alpha_{22}, \\alpha_{20})$$\n在退化情况中，即 $\\alpha_{20} = 0$ 和 $\\alpha_{22} = 0$ 时，必然有 $\\beta^{\\text{fit}}_2 = 0$。角度 $\\gamma^{\\text{fit}}$ 变得未定义；根据问题要求，在这种情况下我们设置 $\\gamma^{\\text{fit}} = 0$。\n\n我们注意到，对于纯基底情况，存在一个显著的简化。将 $\\alpha^{\\text{basis-only}}_{20}$ 和 $\\alpha^{\\text{basis-only}}_{22}$ 的表达式代入反演公式：\n$$\\beta^{\\text{fit}}_{\\text{basis}} = \\sqrt{(c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2 \\cos \\gamma)^2 + 2(c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2 \\frac{\\sin \\gamma}{\\sqrt{2}})^2}$$\n$$= \\sqrt{(c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2)^2 (\\cos^2 \\gamma + \\sin^2 \\gamma)} = c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2$$\n$$\\gamma^{\\text{fit}}_{\\text{basis}} = \\operatorname{arctan2}\\left(\\sqrt{2} \\left(c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2 \\frac{\\sin \\gamma}{\\sqrt{2}}\\right), c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2 \\cos \\gamma\\right) = \\operatorname{arctan2}(\\sin \\gamma, \\cos \\gamma) = \\gamma$$\n因此，对于仅基底的贡献，拟合的 Bohr-Mottelson 参数就是 $\\beta^{\\text{fit}}_{\\text{basis}} = c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2$ 和 $\\gamma^{\\text{fit}}_{\\text{basis}} = \\gamma$（输入的 Nilsson $\\gamma$）。如果 $\\chi_{\\mathrm{so}} = 1$，总贡献也会有类似的简化。\n\n最后一步是计算每个测试用例的差异。\n对于仅基底的情况：\n1.  计算 $\\beta^{\\text{fit}}_{\\mathrm{basis}} = c_{\\mathrm{basis}} k_{\\epsilon} \\epsilon_2$ 和 $\\gamma^{\\text{fit}}_{\\mathrm{basis}} = \\gamma$。\n2.  计算 $\\Delta \\beta_{\\mathrm{basis}} = \\beta^{\\text{fit}}_{\\mathrm{basis}} - \\beta^{\\mathrm{sc}}_2$ 和 $\\Delta \\gamma_{\\mathrm{basis}} = \\gamma^{\\text{fit}}_{\\mathrm{basis}} - \\gamma^{\\mathrm{sc}}$。\n\n对于总（基底加自旋-轨道）情况：\n1.  使用完整表达式计算 $\\alpha^{\\text{Nilsson}}_{20}$ 和 $\\alpha^{\\text{Nilsson}}_{22}$。\n2.  计算 $\\beta^{\\text{fit}}_{\\mathrm{total}} = \\sqrt{(\\alpha^{\\text{Nilsson}}_{20})^2 + 2(\\alpha^{\\text{Nilsson}}_{22})^2}$。\n3.  计算 $\\gamma^{\\text{fit}}_{\\mathrm{total}} = \\operatorname{arctan2}(\\sqrt{2} \\alpha^{\\text{Nilsson}}_{22}, \\alpha^{\\text{Nilsson}}_{20})$。处理 $\\beta^{\\text{fit}}_{\\mathrm{total}}=0$ 的情况，将其 $\\gamma^{\\text{fit}}_{\\mathrm{total}}$ 设置为0。\n4.  计算 $\\Delta \\beta_{\\mathrm{total}} = \\beta^{\\text{fit}}_{\\mathrm{total}} - \\beta^{\\mathrm{sc}}_2$ 和 $\\Delta \\gamma_{\\mathrm{total}} = \\gamma^{\\text{fit}}_{\\mathrm{total}} - \\gamma^{\\mathrm{sc}}$。\n\n对每个提供的测试用例都执行这些步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    # Test suite of parameter values.\n    # Each tuple contains:\n    # (A, eps2, gamma_nilsson, beta_sc, gamma_sc, k_eps, c_basis, c_so, chi_so)\n    test_cases = [\n        (164, 0.28, 0.34906585, 0.25, 0.35, 1.0, 1.0, 0.3, 0.8),\n        (76, 0.22, 1.04719755, 0.19, 1.04719755, 1.0, 0.9, 0.15, 1.0),\n        (208, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0),\n        (100, 0.18, 0.52359878, 0.16, 0.50, 0.95, 1.1, 0.25, 0.7)\n    ]\n\n    results = []\n    for case in test_cases:\n        discrepancies = calculate_discrepancies(case)\n        results.append(discrepancies)\n\n    # Format the results into the required string format.\n    formatted_cases = []\n    for case_result in results:\n        # Round each number to six decimal places\n        formatted_numbers = [f\"{num:.6f}\" for num in case_result]\n        formatted_cases.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output = f\"[[{','.join(formatted_cases)}]]\"\n    # The required output format is slightly ambiguous, but [[...],[...]] seems most likely.\n    # Let's re-read: \"a comma-separated list of four-element sublists\"\n    # Example: [[x1,y1,z1,w1],[x2,y2,z2,w2],...]\n    # So my initial formatting is correct.\n    \n    print(f\"[{','.join(formatted_cases)}]\")\n\ndef calculate_discrepancies(case_params):\n    \"\"\"\n    Calculates the four discrepancy values for a single test case.\n    \n    Args:\n        case_params (tuple): A tuple containing the parameters for one test case.\n        \n    Returns:\n        list: A list of four floats: [delta_beta_basis, delta_gamma_basis, delta_beta_total, delta_gamma_total].\n    \"\"\"\n    (A, eps2, gamma_nilsson, beta_sc, gamma_sc, \n     k_eps, c_basis, c_so, chi_so) = case_params\n\n    # --- Basis-only calculation ---\n    # As derived, the mapping simplifies for the basis-only case.\n    beta_fit_basis = c_basis * k_eps * eps2\n    gamma_fit_basis = gamma_nilsson\n\n    delta_beta_basis = beta_fit_basis - beta_sc\n    delta_gamma_basis = gamma_fit_basis - gamma_sc\n\n    # --- Total (Basis + Spin-Orbit) calculation ---\n    # Calculate Nilsson-equivalent alpha_2mu coefficients\n    cos_gamma_n = np.cos(gamma_nilsson)\n    sin_gamma_n = np.sin(gamma_nilsson)\n    \n    # alpha_20 component\n    alpha_20_total = (c_basis + c_so) * k_eps * eps2 * cos_gamma_n\n    \n    # alpha_22 component\n    alpha_22_total = (c_basis + c_so * chi_so) * k_eps * eps2 * sin_gamma_n / np.sqrt(2)\n    \n    # Invert to find equivalent Bohr-Mottelson parameters\n    # Calculate beta_fit_total\n    beta_fit_total_sq = alpha_20_total**2 + 2 * alpha_22_total**2\n    beta_fit_total = np.sqrt(beta_fit_total_sq)\n    \n    # Calculate gamma_fit_total\n    if beta_fit_total == 0.0:\n        gamma_fit_total = 0.0\n    else:\n        gamma_fit_total = np.arctan2(np.sqrt(2) * alpha_22_total, alpha_20_total)\n\n    # Compute discrepancies for the total case\n    delta_beta_total = beta_fit_total - beta_sc\n    delta_gamma_total = gamma_fit_total - gamma_sc\n    \n    return [delta_beta_basis, delta_gamma_basis, delta_beta_total, delta_gamma_total]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "平均场理论通常会破坏某些基本对称性（例如粒子数守恒），为了获得有物理意义的结果，必须对这些对称性进行恢复。本练习将使用一个模型化的势能面，比较两种重要的超越平均场方法：变分前粒子数投影 (PNP-BV) 和变分后粒子数投影 (PNP-AV)。通过分析这两种不同的投影方案如何改变势能面、能垒高度以及基态曲率，您将体会到对称性恢复对原子核形状共存和动力学性质的理论预言所产生的深远影响 。",
            "id": "3574394",
            "problem": "考虑一个简化的四极和十六极原子核形状自由度的计算模型，其中平均场能量取决于轴向四极形变参数 $ \\beta_2 $ 和轴向十六极参数 $ \\beta_4 $。该模型旨在比较变分前粒子数投影 (PNP-BV) 与变分后粒子数投影 (PNP-AV) 对能量面 $ E(\\beta_2) $ 的拓扑结构以及扁椭球和长橢球极小值之间势垒高度的影响。差异将使用基态极小值处的曲率矩阵（海森矩阵）进行量化。\n\n基本依据。使用以下具有物理动机且被广泛接受的原理和建模步骤：\n- 原子核形状自由度可以用多极参数来描述，包括无量纲的轴向四极参数 $ \\beta_2 $ 和轴向十六极参数 $ \\beta_4 $，由于对称性，平均场能量可以按 $ \\beta_2 $ 和 $ \\beta_4 $ 的偶数次幂展开。\n- 粒子数投影通过一个与粒子数涨落成正比的项来修正能量。这些涨落的强度和对形状的函数依赖性在接近球形时较大，而在较大形变时较弱。\n\n模型定义。平均场能量定义为\n$$\nE_{\\mathrm{mf}}(\\beta_2,\\beta_4) = a\\left(\\beta_2^2 - \\beta_{0}^2\\right)^2 + b\\,\\beta_2^6 + c\\,\\beta_4^2 + d\\,\\beta_2^2\\,\\beta_4^2 + e\\,\\beta_4^4,\n$$\n其中 $ a $、$ b $、$ c $、$ d $、$ e $ 是正常数，$ \\beta_{0}  0 $ 设定了两个对称极小值的位置。\n\n粒子数涨落代理模型为\n$$\nS(\\beta_2,\\beta_4) = s_0\\,\\exp\\!\\left(-\\frac{\\beta_2^2}{\\sigma_2^2}\\right) + s_1\\,\\beta_4^2,\n$$\n其中 $ s_0 $、$ s_1 $ 和 $ \\sigma_2  0 $ 是常数。两种方案中的投影能量为\n$$\nE_{\\mathrm{AV}}(\\beta_2,\\beta_4) = E_{\\mathrm{mf}}(\\beta_2,\\beta_4) - k_{\\mathrm{AV}}\\,S(\\beta_2,\\beta_4),\n$$\n$$\nE_{\\mathrm{BV}}(\\beta_2,\\beta_4) = E_{\\mathrm{mf}}(\\beta_2,\\beta_4) - k_{\\mathrm{BV}}\\left(\\alpha\\,s_0\\,\\exp\\!\\left(-\\frac{\\beta_2^2}{\\sigma_2^2}\\right) + s_1\\,\\beta_4^2\\right),\n$$\n其中 $ 0  \\alpha \\le 1 $ 模拟了在变分前执行投影时粒子数涨落的减少，而 $ k_{\\mathrm{AV}} $、$ k_{\\mathrm{BV}} $ 是依赖于方案的强度。\n\n任务。对于每种方案，通过在固定的 $ \\beta_2 $ 下对 $ E(\\beta_2,\\beta_4) $ 关于 $ \\beta_4 $ 进行最小化来定义一维路径能量 $ E_{\\mathrm{path}}(\\beta_2) $：\n$$\nE_{\\mathrm{path}}(\\beta_2) = \\min_{\\beta_4} E(\\beta_2,\\beta_4).\n$$\n在此路径上：\n- 识别 $ \\beta_2 $ 中的两个最低局域极小值（如果在扫描区间内存在的局域极小值少于两个，则势垒高度取为 $ 0 $）。\n- 将势垒高度计算为位于两个极小值之间的 $ E_{\\mathrm{path}}(\\beta_2) $ 的最大值与两个极小值中较低者之间的差值。\n- 计算每种方案在基态极小值 $(\\beta_2^\\star,\\beta_4^\\star)$ 处的曲率矩阵（关于 $ (\\beta_2,\\beta_4) $ 的海森矩阵），然后计算两种方案的曲率矩阵之差的弗罗贝尼乌斯范数：\n$$\n\\|H_{\\mathrm{BV}} - H_{\\mathrm{AV}}\\|_F = \\sqrt{\\sum_{i,j} \\left(H_{\\mathrm{BV},ij} - H_{\\mathrm{AV},ij}\\right)^2}.\n$$\n\n科学真实性约束：\n- 将 $ \\beta_2 $ 和 $ \\beta_4 $ 视为无量纲参数。\n- 以兆电子伏特 (MeV) 为单位表示势垒高度，输出为浮点数，不带任何单位符号。\n- 由于参数是无量纲的，曲率矩阵的条目单位为兆电子伏特 (MeV)；将弗罗贝尼乌斯范数表示为兆电子伏特 (MeV) 的浮点数，输出中不带任何单位符号。\n- 此模型中不使用角度；无需指定角度单位。\n\n算法要求：\n- 注意到在固定的 $ \\beta_2 $ 下，能量中依赖于 $ \\beta_4 $ 的部分是一个形如 $ A(\\beta_2)\\,\\beta_4^2 + e\\,\\beta_4^4 $ 的四次多项式加上与 $ \\beta_4 $ 无关的项，其中 $ A(\\beta_2) $ 依赖于方案，从而对 $ \\beta_4 $ 进行解析最小化。\n- 在区间 $ [-0.6, 0.6] $ 上使用 $ 0.001 $ 的分辨率在均匀网格上扫描 $ \\beta_2 $，以评估每种方案中的 $ E_{\\mathrm{path}}(\\beta_2) $。\n- 通过 $ \\beta_2 $ 的有限差分导数的符号变化来识别离散路径上的局域极小值和极大值。\n\n曲率矩阵：\n- 将曲率矩阵 $ H $ 计算为双变量能量 $ E(\\beta_2,\\beta_4) $ 的 $ 2 \\times 2 $ 海森矩阵，并在每种方案的基态极小值 $ (\\beta_2^\\star,\\beta_4^\\star) $ 处求值。\n\n测试套件。使用以下三个参数集，每个集均以元组 $(a,b,\\beta_0,c,d,e,s_0,\\sigma_2,s_1,k_{\\mathrm{AV}},k_{\\mathrm{BV}},\\alpha)$ 形式给出，其中除 $ \\beta_0 $、$ \\sigma_2 $ 为无量纲外，所有常数单位均为兆电子伏特 (MeV)：\n1.  情况 1：$(900.0, 1200.0, 0.30, 30.0, 10.0, 200.0, 3.0, 0.25, 2.0, 1.6, 1.2, 0.7)$。\n2.  情况 2：$(800.0, 500.0, 0.22, 25.0, 8.0, 150.0, 2.5, 0.28, 1.6, 1.4, 1.35, 0.95)$。\n3.  情况 3：$(1000.0, 1600.0, 0.32, 35.0, 12.0, 250.0, 3.2, 0.22, 2.2, 2.0, 1.0, 0.6)$。\n\n每个测试用例的所需输出：\n- PNP-AV 的势垒高度，浮点数 (MeV)。\n- PNP-BV 的势垒高度，浮点数 (MeV)。\n- 势垒高度之差 $ H_{\\mathrm{BV}} - H_{\\mathrm{AV}} $，浮点数 (MeV)。\n- 基态极小值处曲率矩阵差的弗罗贝尼乌斯范数，浮点数 (MeV)。\n\n最终输出格式。您的程序应生成单行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表，顺序为情况 1 的四个值，后跟情况 2 的四个值，再后跟情况 3 的四个值。例如，打印的行必须具有以下形式：\n$ [\\text{case1\\_AV\\_barrier},\\text{case1\\_BV\\_barrier},\\text{case1\\_diff},\\text{case1\\_Frob},\\text{case2\\_AV\\_barrier},\\ldots,\\text{case3\\_Frob}] $。",
            "solution": "根据既定标准对问题进行验证。\n\n### **第 1 步：提取已知条件**\n- **平均场能量**：$E_{\\mathrm{mf}}(\\beta_2,\\beta_4) = a\\left(\\beta_2^2 - \\beta_{0}^2\\right)^2 + b\\,\\beta_2^6 + c\\,\\beta_4^2 + d\\,\\beta_2^2\\,\\beta_4^2 + e\\,\\beta_4^4$，其中 $a, b, c, d, e  0$ 且 $\\beta_0  0$。\n- **粒子数涨落代理**：$S(\\beta_2,\\beta_4) = s_0\\,\\exp\\!\\left(-\\frac{\\beta_2^2}{\\sigma_2^2}\\right) + s_1\\,\\beta_4^2$，其中 $s_0, s_1, \\sigma_2  0$。\n- **PNP-AV 能量**：$E_{\\mathrm{AV}}(\\beta_2,\\beta_4) = E_{\\mathrm{mf}}(\\beta_2,\\beta_4) - k_{\\mathrm{AV}}\\,S(\\beta_2,\\beta_4)$，其中 $k_{\\mathrm{AV}}  0$。\n- **PNP-BV 能量**：$E_{\\mathrm{BV}}(\\beta_2,\\beta_4) = E_{\\mathrm{mf}}(\\beta_2,\\beta_4) - k_{\\mathrm{BV}}\\left(\\alpha\\,s_0\\,\\exp\\!\\left(-\\frac{\\beta_2^2}{\\sigma_2^2}\\right) + s_1\\,\\beta_4^2\\right)$，其中 $k_{\\mathrm{BV}}  0$ 且 $0  \\alpha \\le 1$。\n- **路径能量**：$E_{\\mathrm{path}}(\\beta_2) = \\min_{\\beta_4} E(\\beta_2,\\beta_4)$。\n- **势垒高度**：位于两个最低局域极小值之间的 $E_{\\mathrm{path}}(\\beta_2)$ 的最大值与这两个极小值中能量较低者之间的差值。如果存在的极小值少于两个，则势垒高度为 $0$。\n- **曲率矩阵差异**：BV 和 AV 方案的海森矩阵之差的弗罗贝尼乌斯范数，$\\|H_{\\mathrm{BV}} - H_{\\mathrm{AV}}\\|_F$，在其各自的基态极小值处求值。\n- **算法约束**：\n    - 对 $\\beta_4$ 进行解析最小化。\n    - 在 $[-0.6, 0.6]$ 上以 $0.001$ 的分辨率扫描 $\\beta_2$。\n    - 通过有限差分导数的符号变化识别极值点。\n- **测试套件**：提供了三组参数 $(a,b,\\beta_0,c,d,e,s_0,\\sigma_2,s_1,k_{\\mathrm{AV}},k_{\\mathrm{BV}},\\alpha)$。\n- **所需输出**：每个测试用例对应四个浮点数：a) AV 势垒高度，b) BV 势垒高度，c) 势垒高度之差 (BV - AV)，d) 海森矩阵差的弗罗贝尼乌斯范数。\n\n### **第 2 步：使用提取的已知条件进行验证**\n- **科学性基础**：该问题使用了一个简化但标准的能量密度泛函模型，该模型基于关于原子核形变参数 $\\beta_2$ 和 $\\beta_4$ 的类朗道-金兹堡展开。粒子数投影效应的建模具有物理动机。该问题牢固地植根于计算核结构理论。\n- **适定性**：该问题在数学上和计算上都是明确定义的。能量函数是显式的，参数已提供，计算任务（最小化、微分、数值搜索）的规定足够清晰，可以产生唯一的解。\n- **客观性**：问题陈述不含主观或模棱两可的语言。所有术语都有正式定义。\n\n该问题不违反任何无效标准。它在科学上是合理的、可形式化的、完整的、可行的且适定的。\n\n### **第 3 步：结论与行动**\n问题被判定为**有效**。将提供一个解决方案。\n\n### **求解推导与算法设计**\n\n该解法需要通过分析势能面 $E(\\beta_2, \\beta_4)$ 来比较两种理论方案：变分后投影 (PNP-AV) 和变分前投影 (PNP-BV)。方法的核心在于确定一维势能路径 $E_{\\mathrm{path}}(\\beta_2)$，并评估此路径上的局部性质（势垒和曲率）。\n\n**1. 解析最小化与路径能量 $E_{\\mathrm{path}}(\\beta_2)$**\n\n对于 AV 和 BV 两种方案，总能量 $E(\\beta_2, \\beta_4)$ 在固定 $\\beta_2$ 时可表示为 $\\beta_4^2$ 的函数：\n$$\nE(\\beta_2, \\beta_4) = C(\\beta_2) + A(\\beta_2)\\beta_4^2 + e\\beta_4^4\n$$\n其中 $C(\\beta_2)$ 包含所有与 $\\beta_4$ 无关的项，$A(\\beta_2)$ 集合了 $\\beta_4^2$ 项的系数。\n对于一个具有参数 $k_{\\mathrm{eff}}$ 和 $\\alpha_{\\mathrm{eff}}$ 的通用方案（其中对于 AV，$k_{\\mathrm{eff}}=k_{\\mathrm{AV}}, \\alpha_{\\mathrm{eff}}=1$；对于 BV，$k_{\\mathrm{eff}}=k_{\\mathrm{BV}}, \\alpha_{\\mathrm{eff}}=\\alpha$）：\n$$\nE(\\beta_2, \\beta_4) = \\left[a(\\beta_2^2 - \\beta_0^2)^2 + b\\beta_2^6 - k_{\\mathrm{eff}}\\alpha_{\\mathrm{eff}}s_0\\exp\\left(-\\frac{\\beta_2^2}{\\sigma_2^2}\\right)\\right] + (c + d\\beta_2^2 - k_{\\mathrm{eff}}s_1)\\beta_4^2 + e\\beta_4^4\n$$\n因此，系数 $A(\\beta_2)$ 由下式给出：\n$$\nA(\\beta_2) = c + d\\beta_2^2 - k_{\\mathrm{eff}}s_1\n$$\n为求 $E$ 相对于 $\\beta_4$ 的最小值，我们计算其偏导数并令其为零：\n$$\n\\frac{\\partial E}{\\partial\\beta_4} = 2A(\\beta_2)\\beta_4 + 4e\\beta_4^3 = 2\\beta_4 (A(\\beta_2) + 2e\\beta_4^2) = 0\n$$\n最优 $\\beta_4$ 的解为 $\\beta_4=0$ 或 $\\beta_4^2 = -A(\\beta_2)/(2e)$。第二个解仅在 $A(\\beta_2)  0$ 时为实数。我们检查二阶导数 $\\frac{\\partial^2 E}{\\partial\\beta_4^2} = 2A(\\beta_2) + 12e\\beta_4^2$ 来确定极值的性质。\n- 如果 $A(\\beta_2) \\ge 0$，唯一的实极值点在 $\\beta_4=0$ 处。二阶导数为 $2A(\\beta_2) \\ge 0$，表明这是一个极小值。最优值为 $\\beta_4^*(\\beta_2) = 0$。\n- 如果 $A(\\beta_2)  0$，我们在 $\\beta_4=0$ 处有一个局域极大值（因为 $2A(\\beta_2)0$），并在 $\\beta_4^2 = -A(\\beta_2)/(2e)$ 处有两个对称的极小值。在这些极小值处的二阶导数为 $-4A(\\beta_2)  0$。最优值为 $\\beta_4^{*2}(\\beta_2) = -A(\\beta_2)/(2e)$。\n\n因此，路径能量 $E_{\\mathrm{path}}(\\beta_2) = E(\\beta_2, \\beta_4^*(\\beta_2))$ 为：\n$$\nE_{\\mathrm{path}}(\\beta_2) =\n\\begin{cases}\nE(\\beta_2, 0)  \\text{如果 } A(\\beta_2) \\ge 0 \\\\\nE(\\beta_2, 0) - \\frac{A(\\beta_2)^2}{4e}  \\text{如果 } A(\\beta_2)  0\n\\end{cases}\n$$\n其中 $E(\\beta_2, 0) = a(\\beta_2^2 - \\beta_0^2)^2 + b\\beta_2^6 - k_{\\mathrm{eff}}\\alpha_{\\mathrm{eff}}s_0\\exp\\left(-\\frac{\\beta_2^2}{\\sigma_2^2}\\right)$。\n\n**2. 数值路径分析**\n\n该算法在 $\\beta_2 \\in [-0.6, 0.6]$ 的离散网格上评估 $E_{\\mathrm{path}}(\\beta_2)$。通过识别数值一阶导数（使用有限差分计算，$\\Delta E_i = E_{i+1} - E_i$）的符号变化来找到局域极小值和极大值。如果在索引 $i$ 处 $\\Delta E_{i-1}  0$ 且 $\\Delta E_{i} \\ge 0$，则该处为极小值。\n如果找到至少两个局域极小值，则按能量对其进行排序。基态能量 $E_{gs}$ 是两个极小值能量中较低的一个。势垒高度是这两个极小值位置之间路径上的最高点能量减去 $E_{gs}$。如果极小值少于两个，则势垒高度为 $0$。\n\n**3. 曲率矩阵（海森矩阵）计算**\n\n海森矩阵 $H$ 是 $E(\\beta_2, \\beta_4)$ 的二阶偏导数矩阵，在基态极小值 $(\\beta_2^\\star, \\beta_4^\\star)$ 处求值：\n$$\nH = \\begin{pmatrix} \\frac{\\partial^2 E}{\\partial \\beta_2^2}  \\frac{\\partial^2 E}{\\partial \\beta_2 \\partial \\beta_4} \\\\ \\frac{\\partial^2 E}{\\partial \\beta_4 \\partial \\beta_2}  \\frac{\\partial^2 E}{\\partial \\beta_4^2} \\end{pmatrix}_{(\\beta_2^\\star, \\beta_4^\\star)}\n$$\n基态预计是一对在 $(\\pm\\beta_2^\\star, \\beta_4^\\star)$ 处的简并极小值。按照惯例，我们选择长橢球极小值（$\\beta_2^\\star  0$）进行计算。相应的 $\\beta_4^\\star$ 由 $\\beta_2^\\star$ 处的最小化条件确定。\n\n二阶导数的解析表达式为：\n$$\nH_{11} = \\frac{\\partial^2 E}{\\partial \\beta_2^2} = \\left[4a(3\\beta_2^2 - \\beta_0^2) + 30b\\beta_2^4 + 2d\\beta_4^2\\right] - k_{\\mathrm{eff}}\\alpha_{\\mathrm{eff}}s_0 e^{-\\beta_2^2/\\sigma_2^2} \\left(\\frac{4\\beta_2^2}{\\sigma_2^4} - \\frac{2}{\\sigma_2^2}\\right)\n$$\n$$\nH_{22} = \\frac{\\partial^2 E}{\\partial \\beta_4^2} = \\left[2c + 2d\\beta_2^2 + 12e\\beta_4^2\\right] - 2k_{\\mathrm{eff}}s_1\n$$\n$$\nH_{12} = H_{21} = \\frac{\\partial^2 E}{\\partial \\beta_2 \\partial \\beta_4} = 4d\\beta_2\\beta_4\n$$\n这些必须针对每种方案（AV, BV）在其各自的基态极小值处求值，这些极小值通常是不同的，即 $(\\beta_{2,\\mathrm{AV}}^\\star, \\beta_{4,\\mathrm{AV}}^\\star)$ 和 $(\\beta_{2,\\mathrm{BV}}^\\star, \\beta_{4,\\mathrm{BV}}^\\star)$。\n\n**4. 最终比较**\n\n最后一步是计算所要求的量：每种方案的势垒高度、它们的差值，以及弗罗贝尼乌斯范数 $\\|H_{\\mathrm{BV}} - H_{\\mathrm{AV}}\\|_F = \\sqrt{\\sum_{i,j}(H_{\\mathrm{BV},ij} - H_{\\mathrm{AV},ij})^2}$。对测试套件中提供的每个参数集执行这些计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases for the nuclear deformation model.\n    It calculates barrier heights and Hessian matrix differences for AV and BV schemes.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: (a, b, β0, c, d, e, s0, σ2, s1, k_AV, k_BV, α)\n        (900.0, 1200.0, 0.30, 30.0, 10.0, 200.0, 3.0, 0.25, 2.0, 1.6, 1.2, 0.7),\n        # Case 2:\n        (800.0, 500.0, 0.22, 25.0, 8.0, 150.0, 2.5, 0.28, 1.6, 1.4, 1.35, 0.95),\n        # Case 3:\n        (1000.0, 1600.0, 0.32, 35.0, 12.0, 250.0, 3.2, 0.22, 2.2, 2.0, 1.0, 0.6),\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        barrier_av, H_av = analyze_scheme(params, 'AV')\n        barrier_bv, H_bv = analyze_scheme(params, 'BV')\n\n        barrier_diff = barrier_bv - barrier_av\n        H_diff = H_bv - H_av\n        frob_norm = np.linalg.norm(H_diff, 'fro')\n\n        all_results.extend([barrier_av, barrier_bv, barrier_diff, frob_norm])\n    \n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef analyze_scheme(params, scheme):\n    \"\"\"\n    Analyzes a single scheme (AV or BV) to calculate barrier height and Hessian matrix.\n\n    Args:\n        params (tuple): A tuple containing all model parameters.\n        scheme (str): The scheme to analyze, either 'AV' or 'BV'.\n\n    Returns:\n        tuple: A tuple containing the calculated barrier height (float) and the \n               Hessian matrix (2x2 numpy array).\n    \"\"\"\n    a, b, b0, c, d, e, s0, sigma2, s1, k_av, k_bv, alpha = params\n\n    if scheme == 'AV':\n        k_eff = k_av\n        alpha_eff = 1.0\n    else:  # BV\n        k_eff = k_bv\n        alpha_eff = alpha\n\n    b2_grid = np.arange(-0.6, 0.601, 0.001)\n\n    # Step 1: Calculate E_path(beta2) by analytically minimizing over beta4\n    A_b2 = c + d * b2_grid**2 - k_eff * s1\n    \n    E_mf_b4_zero = a * (b2_grid**2 - b0**2)**2 + b * b2_grid**6\n    E_corr_b4_zero = k_eff * alpha_eff * s0 * np.exp(-b2_grid**2 / sigma2**2)\n    E_path_b4_zero = E_mf_b4_zero - E_corr_b4_zero\n\n    correction = np.zeros_like(A_b2)\n    neg_A_mask = A_b2  0\n    if np.any(neg_A_mask):\n      correction[neg_A_mask] = -A_b2[neg_A_mask]**2 / (4 * e)\n    E_path = E_path_b4_zero + correction\n\n    # Step 2: Find minima and calculate barrier height\n    dE = np.diff(E_path)\n    min_indices = np.where((dE[:-1]  0)  (dE[1:] >= 0))[0] + 1\n    \n    barrier = 0.0\n    \n    if len(min_indices) >= 2:\n        min_energies = E_path[min_indices]\n        sorted_indices = np.argsort(min_energies)\n        idx_min1 = min_indices[sorted_indices[0]]\n        idx_min2 = min_indices[sorted_indices[1]]\n        \n        gs_min_energy = E_path[idx_min1]\n        \n        start_idx = min(idx_min1, idx_min2)\n        end_idx = max(idx_min1, idx_min2)\n        if start_idx  end_idx:\n            barrier_top_energy = np.max(E_path[start_idx:end_idx + 1])\n            barrier = barrier_top_energy - gs_min_energy\n\n        gs_min_indices = min_indices[np.isclose(min_energies, gs_min_energy)]\n        prolate_gs_indices = gs_min_indices[b2_grid[gs_min_indices] > 0]\n        if prolate_gs_indices.size > 0:\n            gs_b2_star_idx = prolate_gs_indices[0]\n        else: # Handle degenerate or oblate ground state case\n             gs_b2_star_idx = np.max(gs_min_indices) if gs_min_indices.size > 0 else np.argmin(E_path)\n        gs_b2_star = b2_grid[gs_b2_star_idx]\n\n    else:\n        gs_b2_star_idx = np.argmin(E_path)\n        gs_b2_star = b2_grid[gs_b2_star_idx]\n\n    # Step 3: Calculate Hessian at the ground-state minimum (b2_star, b4_star)\n    A_star = c + d * gs_b2_star**2 - k_eff * s1\n    b4_star_sq = 0.0\n    if A_star  0:\n        b4_star_sq = -A_star / (2 * e)\n    b4_star = np.sqrt(b4_star_sq)\n\n    kf = k_eff * alpha_eff * s0\n    kg = k_eff * s1\n    \n    sigma2_sq = sigma2**2\n    sigma2_p4 = sigma2**4\n    \n    h11 = (4*a*(3*gs_b2_star**2 - b0**2) + 30*b*gs_b2_star**4 + 2*d*b4_star_sq) - \\\n          (kf * np.exp(-gs_b2_star**2 / sigma2_sq) * (4*gs_b2_star**2 / sigma2_p4 - 2 / sigma2_sq))\n    \n    h22 = (2*c + 2*d*gs_b2_star**2 + 12*e*b4_star_sq) - (2 * kg)\n    \n    h12 = 4 * d * gs_b2_star * b4_star\n\n    H = np.array([[h11, h12], [h12, h22]])\n\n    return barrier, H\n\nsolve()\n```"
        }
    ]
}