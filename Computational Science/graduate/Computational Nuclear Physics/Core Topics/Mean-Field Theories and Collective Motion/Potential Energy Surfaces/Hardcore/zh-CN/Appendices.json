{
    "hands_on_practices": [
        {
            "introduction": "构建势能面是理解原子核形变和集体激发的第一步。这项练习将指导您基于唯象模型，在 $(\\beta, \\gamma)$ 形变空间中构建一个奇质量原子核的势能面。通过实践，您将学会如何将对关联（通过阻塞近似）和单粒子排列（通过摇摆模型）等物理效应对势能面拓扑结构的影响进行建模，这是理解不同核结构成分如何塑造势能面的基础。",
            "id": "3580482",
            "problem": "要求您构建并分析一个简化的、但具有物理动机的、针对奇质量原子核的势能面模型。该势能面在集体四极形变平面内，由形变大小 $ \\beta $ 和三轴性角 $ \\gamma $ 参数化。您的程序必须实现一个总能量泛函 $ E(\\beta,\\gamma) $，该泛函由集体偶偶基线、奇质量阻塞惩罚和准粒子排列（摇摆）贡献组成，所有这些都在下面指定。总能量必须在 $(\\beta,\\gamma)$ 平面的固定网格上进行评估，并且必须提取势能面的特定量化特征。\n\n定义和模型规范：\n- 集体偶偶基线能量是四极不变量的 Landau 型展开，\n  $$ E_{\\mathrm{coll}}(\\beta,\\gamma) = A\\,\\beta^{2} + B\\,\\beta^{3}\\cos(3\\gamma) + C\\,\\beta^{4} + D\\,\\beta^{6}, $$\n  其中 $ A $、$ B $、$ C $ 和 $ D $ 是实数参数，满足 $ A>0 $、$ C>0 $ 和 $ D\\ge 0 $ 以确保在大 $ \\beta $ 值下的稳定性。对 $ \\gamma $ 的依赖性通过标准不变量 $ \\cos(3\\gamma) $ 体现。\n- 奇质量阻塞惩罚被建模为由于配对关联减弱而导致的能量各向同性增加，\n  $$ \\delta E_{\\mathrm{block}}(\\beta) = P_{0} + P_{2}\\,\\beta^{2}, $$\n  其中 $ P_{0}\\ge 0 $ 和 $ P_{2}\\ge 0 $。\n- 准粒子排列（摇摆）贡献在 $ \\beta $ 的领头阶上被建模为\n  $$ E_{\\mathrm{align}}(\\beta,\\gamma) = -K\\,\\beta\\,\\cos\\!\\big(3(\\gamma-\\gamma_{0})\\big), $$\n  其中 $ K\\ge 0 $ 设定了排列强度，$ \\gamma_{0}\\in[0,\\pi/3] $ 是一个相位，用于选择 $(\\beta,\\gamma)$ 平面中的排列主轴。\n\n总能量为\n$$ E(\\beta,\\gamma) = E_{\\mathrm{coll}}(\\beta,\\gamma) + \\delta E_{\\mathrm{block}}(\\beta) + E_{\\mathrm{align}}(\\beta,\\gamma), $$\n该能量以兆电子伏特（MeV）为单位。形状变量满足 $ \\beta\\in[0,\\beta_{\\max}] $ 和 $ \\gamma\\in[0,\\pi/3] $。所有内部计算必须使用弧度制的 $ \\gamma $。最终答案中报告的任何角度都必须以度表示。\n\n网格、单位和数值任务：\n- 使用均匀的张量积网格，其中 $ \\beta $ 有 $ N_{\\beta} = 601 $ 个点，线性分布在 $ [0,\\beta_{\\max}] $ 上，且 $ \\beta_{\\max} = 0.6 $；$ \\gamma $ 有 $ N_{\\gamma} = 361 $ 个点，线性分布在 $ [0,\\pi/3] $ 上。网格上的角度以弧度为单位。\n- 对于测试套件中的每个参数集，计算：\n  $1.$ 整个网格上的全局最小能量 $ E_{\\min} $（单位 MeV）以及该最小值点对应的角度 $ \\gamma_{\\min} $（以度报告）。\n  $2.$ 轴对称长椭球势垒高度 $ B_{\\mathrm{prol}} $（单位 MeV），定义如下：限制在长椭球轴 $ \\gamma=0 $ 上，形成一维函数 $ E_{\\mathrm{prol}}(\\beta)=E(\\beta,0) $，确定 $ E_{\\mathrm{prol}}(\\beta) $ 在网格上达到其最小值的索引 $ i^{\\star} $，并将势垒定义为\n  $$ B_{\\mathrm{prol}} = \\max_{0\\le i\\le i^{\\star}} E_{\\mathrm{prol}}(\\beta_{i}) \\;-\\; E_{\\mathrm{prol}}(\\beta_{i^{\\star}}). $$\n  如果 $ i^{\\star}=0 $，则取 $ B_{\\mathrm{prol}} = 0 $。\n  $3.$ 在长椭球轴最小形变 $ \\beta_{i^{\\star}} $ 处的三轴各向异性振幅 $ \\mathcal{A} $（单位 MeV），定义为\n  $$ \\mathcal{A} = \\max_{\\gamma} E(\\beta_{i^{\\star}},\\gamma) \\;-\\; \\min_{\\gamma} E(\\beta_{i^{\\star}},\\gamma). $$\n\n测试套件：\n实现该模型并为以下三个参数集计算所要求的量。所有能量单位为 MeV，$\\gamma_0$ 的角度单位为弧度。\n- 情况 1（偶偶基线，无阻塞，无排列）：$ A=5.0 $，$ B=-12.0 $，$ C=20.0 $，$ D=50.0 $，$ P_{0}=0.0 $，$ P_{2}=0.0 $，$ K=0.0 $，$ \\gamma_{0}=0.0 $。\n- 情况 2（仅阻塞）：$ A=5.0 $，$ B=-12.0 $，$ C=20.0 $，$ D=50.0 $，$ P_{0}=0.8 $，$ P_{2}=2.5 $，$ K=0.0 $，$ \\gamma_{0}=0.0 $。\n- 情况 3（有阻塞和排列）：$ A=5.0 $，$ B=-12.0 $，$ C=20.0 $，$ D=50.0 $，$ P_{0}=0.8 $，$ P_{2}=2.5 $，$ K=2.0 $，$ \\gamma_{0}=0.17453292519943 $。\n\n最终输出规范：\n- 您的程序必须生成单行输出，其中包含三个测试用例的结果，格式为列表的列表：\n  对于每种情况，输出列表 $[E_{\\min}, \\gamma_{\\min}^{(\\mathrm{deg})}, B_{\\mathrm{prol}}, \\mathcal{A}]$，其中 $ E_{\\min} $、$ B_{\\mathrm{prol}} $ 和 $ \\mathcal{A} $ 是以 MeV 为单位的浮点数，$ \\gamma_{\\min}^{(\\mathrm{deg})} $ 是以度为单位的角度。每种情况下的所有四个数字都必须四舍五入到小数点后 $6$ 位。\n- 因此，最终输出行必须如下所示\n  $$ \\big[ [x_1,y_1,z_1,w_1], [x_2,y_2,z_2,w_2], [x_3,y_3,z_3,w_3] \\big], $$\n  其中每个 $x_k$、$y_k$、$z_k$、$w_k$ 是一个小数表示，小数点后有 $6$ 位，并且文本字符串中不含单位。角度以十进制度的形式表示，能量以十进制 MeV 的形式表示。",
            "solution": "用户提供了一个计算核物理领域中有效且适定(well-posed)的问题。我将继续提供完整的解决方案。\n\n该问题要求为奇质量原子核构建和分析一个势能面（PES），记为 $E(\\beta, \\gamma)$。该势能面定义在两个集体四极形变坐标的平面上：形变大小 $\\beta$ 和三轴性角 $\\gamma$。总能量泛函是三个分量的总和：偶偶核芯的集体势 $E_{\\mathrm{coll}}(\\beta, \\gamma)$；奇核子的阻塞惩罚 $\\delta E_{\\mathrm{block}}(\\beta)$；以及准粒子排列贡献 $E_{\\mathrm{align}}(\\beta, \\gamma)$。\n\n总能量由下式给出：\n$$ E(\\beta,\\gamma) = E_{\\mathrm{coll}}(\\beta,\\gamma) + \\delta E_{\\mathrm{block}}(\\beta) + E_{\\mathrm{align}}(\\beta,\\gamma) $$\n各分量具体为：\n\\begin{align*}\nE_{\\mathrm{coll}}(\\beta,\\gamma) = A\\,\\beta^{2} + B\\,\\beta^{3}\\cos(3\\gamma) + C\\,\\beta^{4} + D\\,\\beta^{6} \\\\\n\\delta E_{\\mathrm{block}}(\\beta) = P_{0} + P_{2}\\,\\beta^{2} \\\\\nE_{\\mathrm{align}}(\\beta,\\gamma) = -K\\,\\beta\\,\\cos\\!\\big(3(\\gamma-\\gamma_{0})\\big)\n\\end{align*}\n通过组合这些项，完整的能量泛函可以写成：\n$$ E(\\beta,\\gamma) = P_{0} -K\\,\\beta\\,\\cos\\!\\big(3(\\gamma-\\gamma_{0})\\big) + (A + P_{2})\\,\\beta^{2} + B\\,\\beta^{3}\\cos(3\\gamma) + C\\,\\beta^{4} + D\\,\\beta^{6} $$\n\n求解方法包括以下步骤：\n1.  **网格离散化**：将连续域 $(\\beta, \\gamma) \\in [0, 0.6] \\times [0, \\pi/3]$ 离散化为一个均匀的张量积网格。我们定义一个 $\\beta$ 值的向量 $\\boldsymbol{\\beta} = \\{\\beta_i\\}$，其中 $i=0, \\dots, N_{\\beta}-1$，以及一个 $\\gamma$ 值的向量 $\\boldsymbol{\\gamma} = \\{\\gamma_j\\}$，其中 $j=0, \\dots, N_{\\gamma}-1$。问题指定了 $N_{\\beta} = 601$ 和 $N_{\\gamma} = 361$。\n2.  **势能面计算**：对网格上的每个点 $(i,j)$ 计算总能量 $E(\\beta_i, \\gamma_j)$。通过为 $\\beta$ 和 $\\gamma$ 创建二维网格数组（我们记为 $\\mathbf{B}$ 和 $\\mathbf{\\Gamma}$），可以利用向量化数值库高效地完成此任务。然后逐元素计算能量 $E(\\mathbf{B}, \\mathbf{\\Gamma})$，得到一个二维数组 $\\mathbf{E}$，其中 $\\mathbf{E}_{ij} = E(\\beta_i, \\gamma_j)$。\n3.  **提取可观测量**：一旦为给定的参数集计算出离散的能量面 $\\mathbf{E}$，就提取所要求的物理量。\n\n    -   **全局最小值 ($E_{\\min}$, $\\gamma_{\\min}$)**：通过取整个二维数组 $\\mathbf{E}$ 中的最小值来找到全局最小能量 $E_{\\min}$。定位该最小元素的索引 $(i_{\\min}, j_{\\min})$。对应的三轴性角为 $\\gamma_{\\min} = \\gamma_{j_{\\min}}$，然后将其从弧度转换为度以进行报告。\n\n    -   **长椭球势垒高度 ($B_{\\mathrm{prol}}$)**：这个量是沿着长椭球轴定义的，其中 $\\gamma=0$。我们首先提取一维能量剖面 $E_{\\mathrm{prol}}(\\beta_i) = E(\\beta_i, 0)$，它对应于矩阵 $\\mathbf{E}$ 的第一列。然后我们找到该一维剖面达到其最小值 $E_{\\mathrm{prol}}(\\beta_{i^{\\star}})$ 时的索引 $i^{\\star}$。势垒高度是从 $\\beta=0$ 到 $\\beta=\\beta_{i^{\\star}}$ 路径上遇到的最大能量与在 $\\beta_{i^{\\star}}$ 处的最小能量之差。\n        $$ B_{\\mathrm{prol}} = \\left( \\max_{0 \\le i \\le i^{\\star}} E_{\\mathrm{prol}}(\\beta_i) \\right) - E_{\\mathrm{prol}}(\\beta_{i^{\\star}}) $$\n        一个特殊条件规定，如果最小值出现在 $\\beta=0$ 处（即 $i^{\\star}=0$），则势垒为零。\n\n    -   **三轴各向异性 ($\\mathcal{A}$)**：这个量测量在特定形变下沿 $\\gamma$ 方向的能量变化。所选的形变为 $\\beta_{i^{\\star}}$，即上一步中找到的长椭球最小值的形变。我们提取网格上所有 $\\gamma_j$ 的一维能量剖面 $E(\\beta_{i^{\\star}}, \\gamma_j)$。这对应于矩阵 $\\mathbf{E}$ 中索引为 $i^{\\star}$ 的行。各向异性 $\\mathcal{A}$ 是此一维切片中最大值和最小值之间的差。\n        $$ \\mathcal{A} = \\max_j E(\\beta_{i^{\\star}}, \\gamma_j) - \\min_j E(\\beta_{i^{\\star}}, \\gamma_j) $$\n\n该过程在一个程序中实现，该程序遍历三个指定的参数集，为每种情况计算并存储这四个可观测量。然后将最终输出格式化为列表的列表，所有数值按要求四舍五入到小数点后六位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_pes_observables(params, beta_grid, gamma_grid):\n    \"\"\"\n    Computes observables from the potential energy surface for a single parameter set.\n    \"\"\"\n    A, B, C, D, P0, P2, K, g0 = params\n    \n    # Create 2D meshgrid for vectorized computation.\n    # BETA[i, j] = beta_grid[i], GAMMA[i, j] = gamma_grid[j]\n    BETA, GAMMA = np.meshgrid(beta_grid, gamma_grid, indexing='ij')\n\n    # Calculate the three energy components\n    E_coll = (A * BETA**2 \n              + B * BETA**3 * np.cos(3 * GAMMA) \n              + C * BETA**4\n              + D * BETA**6)\n    \n    delta_E_block = P0 + P2 * BETA**2\n    \n    E_align = -K * BETA * np.cos(3 * (GAMMA - g0))\n    \n    # Total energy surface\n    E_surface = E_coll + delta_E_block + E_align\n\n    # 1. Find global minimum energy and corresponding gamma\n    E_min = np.min(E_surface)\n    min_idx_flat = np.argmin(E_surface)\n    i_min, j_min = np.unravel_index(min_idx_flat, E_surface.shape)\n    gamma_min_rad = gamma_grid[j_min]\n    gamma_min_deg = np.rad2deg(gamma_min_rad)\n\n    # 2. Calculate prolate barrier height B_prol\n    # E_prol is the slice at gamma = 0, which is the first column of E_surface\n    E_prol = E_surface[:, 0]\n    i_star = np.argmin(E_prol)\n    \n    B_prol = 0.0\n    if i_star > 0:\n        E_prol_min = E_prol[i_star]\n        # Barrier is max energy on the path from beta=0 to beta=beta_i_star\n        E_max_on_path = np.max(E_prol[:i_star + 1])\n        B_prol = E_max_on_path - E_prol_min\n\n    # 3. Calculate triaxial anisotropy amplitude A at beta_i_star\n    # E_at_beta_istar is the slice at beta = beta_i_star, which is a row of E_surface\n    E_at_beta_istar = E_surface[i_star, :]\n    A_anisotropy = np.max(E_at_beta_istar) - np.min(E_at_beta_istar)\n\n    return E_min, gamma_min_deg, B_prol, A_anisotropy\n\ndef solve():\n    \"\"\"\n    Main function to drive the computation for all test cases and print the final result.\n    \"\"\"\n    # Define the grid\n    beta_max = 0.6\n    N_beta = 601\n    N_gamma = 361\n    beta_grid = np.linspace(0, beta_max, N_beta)\n    gamma_grid = np.linspace(0, np.pi / 3, N_gamma)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (even-even baseline)\n        (5.0, -12.0, 20.0, 50.0, 0.0, 0.0, 0.0, 0.0),\n        # Case 2 (blocking only)\n        (5.0, -12.0, 20.0, 50.0, 0.8, 2.5, 0.0, 0.0),\n        # Case 3 (blocking with alignment)\n        (5.0, -12.0, 20.0, 50.0, 0.8, 2.5, 2.0, 0.17453292519943),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result_tuple = compute_pes_observables(params, beta_grid, gamma_grid)\n        all_results.append(list(result_tuple))\n\n    # Format the final output string as a list of lists with 6 decimal places.\n    formatted_cases = []\n    for case_results in all_results:\n        # Format each number in the list to a string with 6 decimal places\n        formatted_nums = [f\"{num:.6f}\" for num in case_results]\n        # Create the string representation of the inner list\n        formatted_cases.append(f\"[{','.join(formatted_nums)}]\")\n    \n    # Create the final string representation of the list of lists\n    final_output_string = f\"[{','.join(formatted_cases)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "在离散格点上计算出势能面后，我们通常需要对其进行进一步分析以提取物理信息。这项练习介绍处理势能面数据的几种关键技术：在格点之间进行插值、平滑势能面以去除噪音或关注大尺度结构，以及寻找最优路径。这些技术对于研究核裂变等动力学过程至关重要。",
            "id": "3580491",
            "problem": "您将在一个合成的二维核势能面（PES）上构建、分析和优化路径，以模拟计算核物理中涉及势能面插值、平滑和路径优化的任务。工作将基于无量纲集体坐标 $q_1$ 和 $q_2$ 进行，例如，它们可以代表四极伸长和三轴性。能量必须以兆电子伏（MeV）为单位表示。所有角度（如有）都是抽象的，不会出现在本问题中。您的程序必须是自包含的，不接受任何输入，并完全按照末尾指定的格式打印单行输出。\n\n从以下在域 $\\mathcal{D} = \\{(q_1,q_2) \\mid q_1 \\in [-1.0, 1.0], q_2 \\in [-0.6, 0.6]\\}$ 上的矩形网格上定义的、物理上合理的合成 PES 开始：\n$$\nV(q_1,q_2) = A\\,(q_1^2 - q_0^2)^2 + B\\,(1 + \\alpha\\,q_1)\\,q_2^2 + D_1 \\exp\\!\\left(-\\frac{(q_1 - s_1)^2}{2 w_x^2} - \\frac{q_2^2}{2 w_y^2}\\right) + D_2 \\exp\\!\\left(-\\frac{(q_1 - s_2)^2}{2 w_{2x}^2} - \\frac{(q_2 - y_2)^2}{2 w_{2y}^2}\\right),\n$$\n其中常数 $A=12.0$ (MeV)，$q_0=0.7$，$B=3.5$ (MeV)，$\\alpha=0.6$，$D_1=1.8$ (MeV)，$s_1=0.0$，$w_x=0.35$，$w_y=0.35$，$D_2=-0.5$ (MeV)，$s_2=0.1$，$y_2=0.25$，$w_{2x}=0.25$，$w_{2y}=0.15$。使用一个均匀网格，其中 $q_1$ 在 $-1.0$ 到 $1.0$ 之间采样 $41$ 个点，$q_2$ 在 $-0.6$ 到 $0.6$ 之间采样 $25$ 个点。在此网格上计算 $V$ 以获得以 MeV 为单位的离散 PES。\n\n在此 PES 上要实现的任务：\n\n1) 双三次插值：构建离散 PES 的双三次插值函数，并计算在点 $p_{\\mathrm{int}} = (q_1,q_2)=(0.0, 0.25)$ 处的插值能量。以 MeV 为单位报告此能量。\n\n2) 高斯平滑：定义平滑后的 PES $V_{\\sigma}$，它是离散 PES 与一个各向异性高斯核的卷积，该高斯核在 $q_1$ 和 $q_2$ 坐标方向上的标准差分别为 $(\\sigma_{q_1}, \\sigma_{q_2})$。高斯平滑必须直接应用于网格数据，标准差以 $q_1$ 和 $q_2$ 的物理坐标单位解释（在应用滤波器之前，使用网格间距将其转换为像素单位）。使用适合有限网格的反射或最近邻边界条件。\n\n3) 路径优化：设 $\\Gamma$ 为域 $\\mathcal{D}$ 中从起点 $q^{\\mathrm{start}} = (-q_0, 0.0)$ 到终点 $q^{\\mathrm{end}} = (q_0, 0.0)$ 的任意连续路径。定义非负成本密度\n$$\nC(q_1,q_2) = V_{\\sigma}(q_1,q_2) - \\min_{\\mathcal{D}} V_{\\sigma} + \\varepsilon,\n$$\n其中 $\\varepsilon = 10^{-12}$ (MeV) 以确保严格为正。最优路径 $\\Gamma^\\star$ 最小化线积分\n$$\n\\mathcal{J}[\\Gamma] = \\int_{\\Gamma} C(q_1,q_2)\\, \\mathrm{d}\\ell,\n$$\n其中 $\\mathrm{d}\\ell$ 是 $(q_1,q_2)$ 平面中的欧几里得线元。通过在给定网格上离散化域，并在具有 8-邻域连接的导出加权图上计算最小线积分路径来近似此最优路径。使用等于沿边的成本密度的梯形法则积分乘以物理 $(q_1,q_2)$ 度量下的欧几里得边长的边权重：\n$$\nw_{u\\to v} = \\frac{C(u) + C(v)}{2}\\,\\Delta \\ell_{uv},\n$$\n其中 $\\Delta \\ell_{uv}$ 是相邻网格点 $u$ 和 $v$ 之间网格步长的 $\\sqrt{(\\Delta q_1)^2 + (\\Delta q_2)^2}$。计算出最优离散路径后，报告：\n- 总几何路径长度 $L$（沿路径的欧几里得步长 $\\Delta \\ell_{uv}$ 的总和），以 $(q_1,q_2)$ 的坐标单位表示。\n- 势垒能量 $E_{\\max}$，定义为沿离散路径采样的未平滑 PES $V$ 的最大值，单位为 MeV。\n\n测试套件与输出：\n\n您必须评估三个测试用例，每个用例都具有不同的各向异性高斯平滑，指定为 $q_1$ 和 $q_2$ 坐标单位下的 $(\\sigma_{q_1}, \\sigma_{q_2})$：\n- 用例 1：$(\\sigma_{q_1}, \\sigma_{q_2}) = (0.00, 0.00)$。\n- 用例 2：$(\\sigma_{q_1}, \\sigma_{q_2}) = (0.08, 0.08)$。\n- 用例 3：$(\\sigma_{q_1}, \\sigma_{q_2}) = (0.15, 0.10)$。\n\n对于每个用例，计算并输出三元组 $[E_{\\mathrm{int}}, L, E_{\\max}]$，其中 $E_{\\mathrm{int}}$ 是在 $p_{\\mathrm{int}}$ 处的双三次插值能量，$L$ 是优化路径的长度，$E_{\\max}$ 是沿优化路径的势垒能量。能量必须以 MeV 为单位，长度以无量纲坐标单位表示。将每个浮点数四舍五入到六位小数。\n\n最终输出格式：\n\n您的程序应生成一行输出，其中包含按用例顺序排列的三个三元组的逗号分隔列表，并用方括号括起来，不含空格。例如：\n\"[[Eint1,L1,Emax1],[Eint2,L2,Emax2],[Eint3,L3,Emax3]]\"\n所有数值条目必须是四舍五入到六位小数的浮点数，并以上述适当单位表示。不允许有其他输出。",
            "solution": "该问题要求构建和分析一个合成的二维核势能面（PES），然后优化该势能面上两点之间的路径。解决方案涉及一系列数值任务：网格求值、插值、图像处理（平滑）和基于图的路径查找。整个过程针对三种不同的平滑场景执行。\n\n### 1. 势能面离散化\n\n先验的连续 PES，表示为 $V(q_1, q_2)$，是两个无量纲集体坐标 $q_1$ 和 $q_2$ 的函数。其解析形式为：\n$$\nV(q_1,q_2) = A\\,(q_1^2 - q_0^2)^2 + B\\,(1 + \\alpha\\,q_1)\\,q_2^2 + D_1 \\exp\\!\\left(-\\frac{(q_1 - s_1)^2}{2 w_x^2} - \\frac{q_2^2}{2 w_y^2}\\right) + D_2 \\exp\\!\\left(-\\frac{(q_1 - s_2)^2}{2 w_{2x}^2} - \\frac{(q_2 - y_2)^2}{2 w_{2y}^2}\\right)\n$$\n第一步是在指定域 $\\mathcal{D} = \\{(q_1,q_2) \\mid q_1 \\in [-1.0, 1.0], q_2 \\in [-0.6, 0.6]\\}$ 上离散化此函数。我们沿 $q_1$ 轴构建一个包含 $N_{q_1}=41$ 个点的均匀网格，沿 $q_2$ 轴构建一个包含 $N_{q_2}=25$ 个点的均匀网格。这会产生网格间距 $\\Delta q_1 = (1.0 - (-1.0))/(41-1) = 0.05$ 和 $\\Delta q_2 = (0.6 - (-0.6))/(25-1) = 0.05$。在网格上的每个点 $(q_1, q_2)$ 计算函数 $V(q_1, q_2)$，得到一个 $25 \\times 41$ 的能量值矩阵，我们将其表示为 $V_{\\mathrm{grid}}$。该矩阵作为所有后续任务的基础数据集。\n\n### 2. 任务1：双三次插值\n\n目标是估计一个不一定在网格上的点的势能。双三次插值是实现此目的的标准方法，它将一个分段三次多项式曲面拟合到网格数据，该曲面是连续的且具有连续的一阶偏导数。我们从离散 PES $V_{\\mathrm{grid}}$ 构建一个双三次插值函数。这是通过使用 `scipy.interpolate.RectBivariateSpline` 并设置样条次数 $k_x=3$ 和 $k_y=3$ 来完成的。然后，在指定的点 $p_{\\mathrm{int}} = (0.0, 0.25)$ 处对生成的插值函数求值，以找到能量 $E_{\\mathrm{int}}$。由于此任务与平滑参数无关，因此 $E_{\\mathrm{int}}$ 只计算一次，并用于所有三个测试用例。\n\n### 3. 任务2：各向异性高斯平滑\n\n为了研究势能面粗糙度对路径优化的影响，需要对离散 PES 进行平滑处理。平滑后的曲面 $V_{\\sigma}$ 是通过将 $V_{\\mathrm{grid}}$ 与一个各向异性的二维高斯核进行卷积得到的。对于每个测试用例，核的标准差 $(\\sigma_{q_1}, \\sigma_{q_2})$ 以物理坐标单位给出。在应用卷积之前，必须将这些值转换成像素（或网格索引）单位：\n$$\n\\sigma_{\\mathrm{pix}, q_1} = \\frac{\\sigma_{q_1}}{\\Delta q_1}, \\quad \\sigma_{\\mathrm{pix}, q_2} = \\frac{\\sigma_{q_2}}{\\Delta q_2}\n$$\n卷积使用 `scipy.ndimage.gaussian_filter` 执行，并带有 `mode='reflect'` 边界条件以适当处理有限网格的边缘。对三个测试用例中的每一个重复此过程，产生三个不同的平滑势能面。$(\\sigma_{q_1}, \\sigma_{q_2}) = (0.0, 0.0)$ 的情况对应于不进行平滑，此时 $V_{\\sigma} = V$。\n\n### 4. 任务3：路径优化\n\n核心任务是找到从起点 $q^{\\mathrm{start}} = (-0.7, 0.0)$ 到终点 $q^{\\mathrm{end}} = (0.7, 0.0)$ 的最优路径 $\\Gamma^\\star$。路径是“最优”的，其意义在于它最小化了成本密度的线积分 $\\mathcal{J}[\\Gamma] = \\int_{\\Gamma} C(q_1,q_2)\\, \\mathrm{d}\\ell$。\n\n**a. 成本函数：**\n成本密度 $C(q_1, q_2)$ 源自平滑后的势能 $V_{\\sigma}$。其定义为：\n$$\nC(q_1,q_2) = V_{\\sigma}(q_1,q_2) - \\min_{\\mathcal{D}} V_{\\sigma} + \\varepsilon\n$$\n这里，$\\min_{\\mathcal{D}} V_{\\sigma}$ 是平滑势能在域上的全局最小值，而 $\\varepsilon = 10^{-12}$ MeV 是一个小的正常数，以确保成本严格为正，这是许多最短路径算法的要求。\n\n**b. 图的构建与边权重：**\n连续优化问题被近似为离散图上的最短路径问题。图的节点对应于我们 $25 \\times 41$ 网格上的点。边将每个节点连接到其 8 个最近的邻居（摩尔邻域）。连接两个相邻节点 $u$ 和 $v$ 的边的权重由沿该线段的成本密度的线积分的梯形近似定义：\n$$\nw_{u\\to v} = \\frac{C(u) + C(v)}{2}\\,\\Delta \\ell_{uv}\n$$\n其中 $C(u)$ 和 $C(v)$ 是节点处的成本值，$\\Delta \\ell_{uv}$ 是它们在 $(q_1,q_2)$ 坐标平面中的欧几里得距离。对于轴向邻居，$\\Delta \\ell_{uv}$ 是 $\\Delta q_1$ 或 $\\Delta q_2$，而对于对角线邻居，它是 $\\sqrt{(\\Delta q_1)^2 + (\\Delta q_2)^2}$。\n\n**c. 路径查找：**\n构建加权图后，采用 Dijkstra 算法来查找从对应于 $q^{\\mathrm{start}}$ 的节点到对应于 $q^{\\mathrm{end}}$ 的节点的具有最小累积权重的路径。`scipy.sparse.csgraph.dijkstra` 函数非常适合此任务，它操作于图的稀疏矩阵表示以提高效率。\n\n**d. 路径分析：**\n该算法返回一个表示最优离散路径的节点序列。从此序列中，计算出两个关键指标：\n1.  **路径长度 ($L$)**：路径在 $(q_1, q_2)$ 平面中的总几何长度。这是构成路径的所有线段的欧几里得距离 $\\Delta \\ell_{uv}$ 的总和。\n2.  **势垒能量 ($E_{\\max}$)**：沿路径遇到的最大能量。关键的是，这是通过在计算路径的每个节点上采样*原始的、未平滑的*势能 $V_{\\mathrm{grid}}$ 并找到最大值来确定的。这代表了物理系统沿计算出的轨迹必须克服的真实能垒。\n\n从平滑到路径分析的整个序列，对三个指定的 $(\\sigma_{q_1}, \\sigma_{q_2})$ 对中的每一个都执行一遍。然后，每个用例的最终结果 $[E_{\\mathrm{int}}, L, E_{\\max}]$ 会被格式化并按要求打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import RectBivariateSpline\nfrom scipy.ndimage import gaussian_filter\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.csgraph import dijkstra\n\ndef solve():\n    \"\"\"\n    Constructs, analyzes, and optimizes paths on a synthetic 2D potential energy surface.\n    \"\"\"\n    # Define physical and model constants\n    A = 12.0\n    q0 = 0.7\n    B = 3.5\n    alpha = 0.6\n    D1 = 1.8\n    s1 = 0.0\n    wx = 0.35\n    wy = 0.35\n    D2 = -0.5\n    s2 = 0.1\n    y2 = 0.25\n    w2x = 0.25\n    w2y = 0.15\n    epsilon = 1e-12\n\n    # Define the grid\n    nq1, nq2 = 41, 25\n    q1_range = [-1.0, 1.0]\n    q2_range = [-0.6, 0.6]\n    \n    q1_coords = np.linspace(q1_range[0], q1_range[1], nq1, dtype=np.float64)\n    q2_coords = np.linspace(q2_range[0], q2_range[1], nq2, dtype=np.float64)\n    \n    dq1 = q1_coords[1] - q1_coords[0]\n    dq2 = q2_coords[1] - q2_coords[0]\n    \n    Q1, Q2 = np.meshgrid(q1_coords, q2_coords)\n\n    # Define the Potential Energy Surface (PES) function\n    def pes_func(q1, q2):\n        term1 = A * (q1**2 - q0**2)**2\n        term2 = B * (1 + alpha * q1) * q2**2\n        term3 = D1 * np.exp(-((q1 - s1)**2 / (2 * wx**2)) - (q2**2 / (2 * wy**2)))\n        term4 = D2 * np.exp(-((q1 - s2)**2 / (2 * w2x**2)) - ((q2 - y2)**2 / (2 * w2y**2)))\n        return term1 + term2 + term3 + term4\n\n    # Evaluate the discrete PES on the grid\n    V_grid = pes_func(Q1, Q2)\n\n    # Task 1: Bicubic Interpolation\n    # This is performed once on the original PES, as it's independent of smoothing.\n    interp_func = RectBivariateSpline(q2_coords, q1_coords, V_grid, kx=3, ky=3)\n    p_int = (0.0, 0.25)\n    _E_int_val = interp_func(p_int[1], p_int[0], grid=False)\n    E_int = _E_int_val.item()\n\n    # Define the test cases for smoothing parameters\n    test_cases = [\n        (0.00, 0.00),\n        (0.08, 0.08),\n        (0.15, 0.10),\n    ]\n\n    results = []\n\n    for sigma_q1, sigma_q2 in test_cases:\n        # Task 2: Gaussian Smoothing\n        if sigma_q1 == 0.0 and sigma_q2 == 0.0:\n            # No smoothing needed for sigma=0\n            V_sigma_grid = V_grid\n        else:\n            # Convert physical sigma to pixel units for the filter\n            sigma_pix_q1 = sigma_q1 / dq1\n            sigma_pix_q2 = sigma_q2 / dq2\n            # Apply Gaussian filter with reflective boundary conditions\n            V_sigma_grid = gaussian_filter(V_grid, sigma=[sigma_pix_q2, sigma_pix_q1], mode='reflect')\n\n        # Task 3: Path Optimization\n        # a. Define the cost function grid\n        V_sigma_min = np.min(V_sigma_grid)\n        C_grid = V_sigma_grid - V_sigma_min + epsilon\n\n        # b. Construct the weighted graph for pathfinding\n        N = nq1 * nq2\n        graph = lil_matrix((N, N))\n        \n        for i in range(nq2):\n            for j in range(nq1):\n                node_idx = i * nq1 + j\n                cost_node = C_grid[i, j]\n                \n                # Connect to 8 nearest neighbors\n                for di in [-1, 0, 1]:\n                    for dj in [-1, 0, 1]:\n                        if di == 0 and dj == 0:\n                            continue\n                        \n                        ni, nj = i + di, j + dj\n                        \n                        if 0 = ni  nq2 and 0 = nj  nq1:\n                            neighbor_idx = ni * nq1 + nj\n                            cost_neighbor = C_grid[ni, nj]\n                            \n                            # Calculate Euclidean distance and trapezoidal weight\n                            edge_len = np.sqrt((di * dq2)**2 + (dj * dq1)**2)\n                            weight = (cost_node + cost_neighbor) / 2.0 * edge_len\n                            graph[node_idx, neighbor_idx] = weight\n\n        # c. Find shortest path using Dijkstra's algorithm\n        q_start = (-q0, 0.0)\n        q_end = (q0, 0.0)\n        \n        j_start_idx = np.where(np.isclose(q1_coords, q_start[0]))[0][0]\n        i_start_end_idx = np.where(np.isclose(q2_coords, q_start[1]))[0][0]\n        j_end_idx = np.where(np.isclose(q1_coords, q_end[0]))[0][0]\n        \n        start_node = i_start_end_idx * nq1 + j_start_idx\n        end_node = i_start_end_idx * nq1 + j_end_idx\n\n        _, predecessors = dijkstra(csgraph=graph.tocsr(), indices=start_node, return_predecessors=True, directed=False)\n\n        # d. Reconstruct path and compute metrics\n        path_indices = []\n        curr = end_node\n        if predecessors[curr] == -9999 and curr != start_node:\n             raise RuntimeError(f\"No path found from {start_node} to {end_node}\")\n             \n        while curr != -9999:\n            path_indices.append(curr)\n            if curr == start_node: break\n            curr = predecessors[curr]\n        path_indices.reverse()\n\n        path_coords_ij = [np.unravel_index(p_idx, (nq2, nq1)) for p_idx in path_indices]\n\n        # Calculate total path length L\n        L = 0.0\n        for k in range(len(path_indices) - 1):\n            i_u, j_u = path_coords_ij[k]\n            i_v, j_v = path_coords_ij[k+1]\n            q1_u, q2_u = q1_coords[j_u], q2_coords[i_u]\n            q1_v, q2_v = q1_coords[j_v], q2_coords[i_v]\n            L += np.sqrt((q1_v - q1_u)**2 + (q2_v - q2_u)**2)\n\n        # Calculate barrier energy E_max from the original, unsmoothed PES\n        path_energies_V = [V_grid[i, j] for i, j in path_coords_ij]\n        E_max = np.max(path_energies_V)\n\n        results.append([E_int, L, E_max])\n\n    # Format the final output string as specified\n    output_str = \",\".join(f\"[{v[0]:.6f},{v[1]:.6f},{v[2]:.6f}]\" for v in results)\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "静态的势能面只是故事的一部分，原子核动力学涉及到原子核在势能面上的运动。本练习深入探讨了量子隧穿这一在裂变和团簇衰变中的关键过程，通过计算WKB隧穿作用量来实现。它强调了集体惯性张量的关键作用，该张量如同坐标空间中的度规，深刻影响着最小作用量路径的选择。",
            "id": "3580448",
            "problem": "考虑一个描述势能面（PES）上大振幅核运动的集体哈密顿量，其中集体坐标为轴对称质量四极和八极形变 $\\mathbf{q} \\equiv (q_{20}, q_{30})$，惯性由对称、正定的集体惯性张量 $B_{ij}(\\mathbf{q})$ 表征。在半经典隧穿机制中，穿越势垒的概率幅由一个作用量积分决定。从半经典Wentzel–Kramers–Brillouin（WKB）近似和欧几里得（虚时间）路径积分形式出发，推导沿参数化路径 $\\mathbf{q}(s)$ 穿过经典禁区时累积的隧穿作用量如何依赖于势能面 $E(\\mathbf{q})$、集体惯性张量 $B_{ij}(\\mathbf{q})$ 和路径导数 $\\mathrm{d}\\mathbf{q}/\\mathrm{d}s$。清晰地陈述此推导在该情境下有效所需的假设。\n\n然后，实现一个程序来数值计算沿分段线性路径的WKB作用量，并针对一个可分离的二次势垒PES，将结果与瞬子（欧几里得作用量的鞍点）计算进行验证。具体来说，考虑二维势能面\n$$\nE(\\mathbf{q}) = V_b - \\frac{1}{2} k_b \\, q_{20}^2 + \\frac{1}{2} k_t \\, q_{30}^2,\n$$\n具有常数、对角的集体惯性张量\n$$\nB_{ij}(\\mathbf{q}) = \\begin{pmatrix} B_{20}  0 \\\\ 0  B_{30} \\end{pmatrix},\n$$\n以及低于势垒顶部 $V_b$ 的参考能量 $E_0$。能量 $V_b$、$E_0$ 和刚度 $k_b$、$k_t$ 必须以兆电子伏（MeV）为单位处理，集体坐标 $(q_{20}, q_{30})$ 是无量纲形变，惯性分量的单位是 $\\mathrm{MeV}^{-1}$。隧穿作用量是无量纲的。\n\n您的程序必须：\n- 使用高斯求积法，数值计算沿给定分段线性路径 $\\mathbf{q}(s)$ 的WKB作用量，其中被积函数依赖于局部势垒高度 $E(\\mathbf{q}) - E_0$ 以及由 $B_{ij}(\\mathbf{q})$ 在 $\\mathrm{d}\\mathbf{q}$ 上诱导的二次型。路径应限制在经典禁区内，其端点为沿指定路径求解 $E(\\mathbf{q}) = E_0$ 所得的经典转折点。\n- 在相同假设下，解析地计算可分离二次势垒的瞬子作用量，并在适用时用作验证参考。\n- 为以下测试套件报告定量比较。\n\n测试套件（能量单位为MeV，惯性单位为$\\mathrm{MeV}^{-1}$，形变为无量纲）：\n1. 一般情况（沿 $q_{30}=0$ 的直线最小路径）：\n   - $V_b = 6$， $E_0 = 1$， $k_b = 4$， $k_t = 3$， $B_{20} = 10$， $B_{30} = 10$。\n   - 路径：$\\mathbf{q}(s)$ 是一条沿 $q_{30}=0$ 的直线，从由 $E(q_{20},0) = E_0$ 决定的内转折点到外转折点。\n   - 输出此路径的WKB作用量以及与解析瞬子作用量的绝对差。\n2. 各向异性惯性（沿 $q_{30}=0$ 的直线最小路径）：\n   - $V_b = 6$， $E_0 = 2$， $k_b = 5$， $k_t = 3$， $B_{20} = 4$， $B_{30} = 16$。\n   - 路径：$\\mathbf{q}(s)$ 沿 $q_{30}=0$，位于由 $E(q_{20},0) = E_0$ 给出的转折点之间。\n   - 输出WKB作用量以及与解析瞬子作用量的绝对差。\n3. 弯曲路径惩罚（在 $(q_{20}, q_{30})$ 平面内有斜率的非最小直线）：\n   - $V_b = 6$， $E_0 = 1$， $k_b = 4$， $k_t = 8$， $B_{20} = 10$， $B_{30} = 10$。\n   - 路径：斜率为 $\\beta = 0.5$ 的直线 $q_{30} = \\beta \\, q_{20}$，位于满足 $E(q_{20}, \\beta q_{20}) = E_0$ 的转折点之间。\n   - 输出一个布尔值，指示此弯曲路径上的WKB作用量是否超过在相同 $(V_b, E_0, k_b, B_{20})$ 参数下沿 $q_{30}=0$ 直线路径的解析瞬子作用量。\n4. 近势垒极限（沿 $q_{30}=0$ 的直线最小路径，其中 $E_0$ 非常接近 $V_b$）：\n   - $V_b = 10$， $E_0 = 9.999$， $k_b = 6$, $k_t = 3$， $B_{20} = 7$， $B_{30} = 7$。\n   - 路径：沿 $q_{30}=0$，位于由 $E(q_{20},0) = E_0$ 给出的转折点之间。\n   - 输出WKB作用量与解析瞬子作用量之间的绝对差。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,...]”）。列表条目必须按顺序为：\n- 测试1的WKB作用量，为浮点数，\n- 测试1与解析瞬子的绝对差，为浮点数，\n- 测试2的WKB作用量，为浮点数，\n- 测试2与解析瞬子的绝对差，为浮点数，\n- 测试3的比较布尔值，\n- 测试4与解析瞬子的绝对差，为浮点数。\n\n所有数值答案必须是无量纲的，并以原始十进制数报告（无百分号）。",
            "solution": "该问题要求推导一个粒子在由集体哈密顿量描述的多维势垒中隧穿的半经典Wentzel–Kramers–Brillouin（WKB）作用量。完成推导后，必须开发一个数值实现来计算特定路径和参数下的此作用量，并将结果与瞬子路径的解析解进行验证。\n\n### 1. 半经典隧穿作用量的推导\n\n起点是描述一个由集体坐标 $\\mathbf{q} \\equiv (q_i)$、依赖于坐标的惯性张量 $B_{ij}(\\mathbf{q})$ 和势能面（PES）$E(\\mathbf{q})$ 构成的系统的经典拉格朗日量。\n$$ L(\\mathbf{q}, \\dot{\\mathbf{q}}) = T - V = \\frac{1}{2} \\sum_{i,j} B_{ij}(\\mathbf{q}) \\dot{q}_i \\dot{q}_j - E(\\mathbf{q}) $$\n其中 $\\dot{q}_i = \\mathrm{d}q_i/\\mathrm{d}t$。\n\n隧穿是一个经典禁戒过程。通过进行到虚时间 $\\tau = it$ 的威克转动，可以在欧几里得时空中建立半经典描述。因此，时间导数变为 $\\mathrm{d}/\\mathrm{d}t = i\\,\\mathrm{d}/\\mathrm{d}\\tau$，于是 $\\dot{q}_i = i\\,\\mathrm{d}q_i/\\mathrm{d}\\tau$。动能项转换为：\n$$ T = \\frac{1}{2} \\sum_{i,j} B_{ij} (i\\,\\frac{\\mathrm{d}q_i}{\\mathrm{d}\\tau})(i\\,\\frac{\\mathrm{d}q_j}{\\mathrm{d}\\tau}) = -\\frac{1}{2} \\sum_{i,j} B_{ij} \\frac{\\mathrm{d}q_i}{\\mathrm{d}\\tau} \\frac{\\mathrm{d}q_j}{\\mathrm{d}\\tau} \\equiv -T_E $$\n作用量积分 $\\int L\\,\\mathrm{d}t$ 变为 $iS_E$，其中 $S_E$ 是欧几里得作用量：\n$$ S_E = \\int L_E \\,\\mathrm{d}\\tau = \\int \\left( T_E + E(\\mathbf{q}) \\right) \\mathrm{d}\\tau $$\n假设系统以恒定能量 $E_0$ 进行隧穿。相应的欧几里得运动方程描述了一个在反转势 $V_{inverted} = -E(\\mathbf{q})$ 中运动的经典粒子，其守恒总能量为 $-E_0$。欧几里得形式下的能量守恒表示为：\n$$ H_E = T_E - E(\\mathbf{q}) = -E_0 $$\n这导致了沿禁区内的经典轨迹有效的基本关系：\n$$ T_E = \\frac{1}{2} \\sum_{i,j} B_{ij}(\\mathbf{q}) \\frac{\\mathrm{d}q_i}{\\mathrm{d}\\tau} \\frac{\\mathrm{d}q_j}{\\mathrm{d}\\tau} = E(\\mathbf{q}) - E_0 $$\n该方程仅在 $E(\\mathbf{q}) > E_0$ 的经典禁区内有意义。\n\n出现在隧穿概率 $P \\propto e^{-2S/\\hbar}$ 指数中的WKB隧穿作用量，被认定为欧几里得作用量 $S_E$（对于无量纲作用量，取 $\\hbar = 1$）。我们可以将 $S_E$ 表示成与时间参数化无关的形式。使用沿路径的 $T_E = E(\\mathbf{q}) - E_0$，我们可以写出 $S_E = \\int (T_E + E(\\mathbf{q}))\\,\\mathrm{d}\\tau = \\int (E(\\mathbf{q}) - E_0 + E(\\mathbf{q}))\\,\\mathrm{d}\\tau$，但这并非最直接的途径。相反，利用欧几里得空间中的莫佩尔蒂原理，作用量由欧几里得动量沿路径的积分给出，$S_E = \\int \\mathbf{p}_E \\cdot \\mathrm{d}\\mathbf{q}$。通过用任意参数 $s$ 对路径 $\\mathbf{q}$ 进行重新参数化，使得 $\\mathbf{q} = \\mathbf{q}(s)$，可以获得一个更方便的形式。\n能量守恒方程给出：\n$$ \\frac{1}{2} \\left(\\frac{\\mathrm{d}s}{\\mathrm{d}\\tau}\\right)^2 \\sum_{i,j} B_{ij} \\frac{\\mathrm{d}q_i}{\\mathrm{d}s} \\frac{\\mathrm{d}q_j}{\\mathrm{d}s} = E(\\mathbf{q}(s)) - E_0 $$\n求解 $\\mathrm{d}\\tau$：\n$$ \\mathrm{d}\\tau = \\mathrm{d}s / \\frac{\\mathrm{d}s}{\\mathrm{d}\\tau} = \\sqrt{\\frac{\\frac{1}{2} \\sum_{i,j} B_{ij} \\frac{\\mathrm{d}q_i}{\\mathrm{d}s} \\frac{\\mathrm{d}q_j}{\\mathrm{d}s}}{E(\\mathbf{q}(s)) - E_0}} \\,\\mathrm{d}s $$\n作用量可以表示为 $S = \\int 2T_E \\,\\mathrm{d}\\tau$。代入 $T_E$ 和 $\\mathrm{d}\\tau$ 的表达式：\n$$ S[\\mathbf{q}(s)] = \\int_{s_{start}}^{s_{end}} 2 \\left( E(\\mathbf{q}(s)) - E_0 \\right) \\sqrt{\\frac{\\frac{1}{2} \\sum_{i,j} B_{ij} \\frac{\\mathrm{d}q_i}{\\mathrm{d}s} \\frac{\\mathrm{d}q_j}{\\mathrm{d}s}}{E(\\mathbf{q}(s)) - E_0}} \\,\\mathrm{d}s $$\n$$ S[\\mathbf{q}(s)] = \\int_{s_{start}}^{s_{end}} \\sqrt{2 \\left(E(\\mathbf{q}(s)) - E_0\\right) \\left(\\sum_{i,j} B_{ij}(\\mathbf{q}(s)) \\frac{\\mathrm{d}q_i}{\\mathrm{d}s} \\frac{\\mathrm{d}q_j}{\\mathrm{d}s}\\right)} \\,\\mathrm{d}s $$\n这是沿任意参数化路径 $\\mathbf{q}(s)$ 从起点 $s_{start}$ 到终点 $s_{end}$（通常是 $E(\\mathbf{q}) = E_0$ 的经典转折点）的WKB隧穿作用量的最终表达式。\n\n此推导的关键假设是：\n1.  **半经典近似**：与集体运动的局域德布罗意波长相比，势能 $E(\\mathbf{q})$ 是缓变的。\n2.  **绝热运动**：假定集体自由度 $\\mathbf{q}$ 与内禀核子激发解耦（无耗散）。\n3.  **集体模型的有效性**：核动力学能够被少数几个集体坐标很好地描述。\n4.  **虚时间形式**：隧穿振幅由虚时间中的单一经典路径（瞬子）主导。\n\n### 2. 可分离二次势垒的解析瞬子作用量\n\n瞬子是使作用量泛函 $S[\\mathbf{q}(s)]$ 最小化的路径。对于给定的势能面 $E(\\mathbf{q}) = V_b - \\frac{1}{2} k_b q_{20}^2 + \\frac{1}{2} k_t q_{30}^2$ 和对角惯性张量 $B_{ij}$，作用量为：\n$$ S = \\int \\sqrt{2 \\left(V_b - E_0 - \\frac{1}{2}k_b q_{20}^2 + \\frac{1}{2}k_t q_{30}^2\\right)\\left(B_{20}\\left(\\frac{\\mathrm{d}q_{20}}{\\mathrm{d}s}\\right)^2 + B_{30}\\left(\\frac{\\mathrm{d}q_{30}}{\\mathrm{d}s}\\right)^2\\right)} \\,\\mathrm{d}s $$\n为使作用量最小，路径必须通过尽可能低的势能区域。项 $\\frac{1}{2}k_t q_{30}^2$ 会随着 $|q_{30}|$ 的增加而增加势能。因此，最小作用量路径（瞬子）必须位于 $q_{30}=0$ 轴上。\n设 $q_{30}(s)=0$，作用量简化。我们可以用 $q_{20}$ 本身来参数化路径，即 $s=q_{20}$：\n$$ S_{inst} = \\int_{q_{20,a}}^{q_{20,b}} \\sqrt{2 \\left(V_b - E_0 - \\frac{1}{2}k_b q_{20}^2\\right) B_{20}} \\,\\mathrm{d}q_{20} $$\n经典转折点 $q_{20,a}$ 和 $q_{20,b}$ 通过将平方根内的参数设为零来找到：\n$$ V_b - E_0 - \\frac{1}{2}k_b q_{20}^2 = 0 \\implies q_{20} = \\pm \\sqrt{\\frac{2(V_b - E_0)}{k_b}} \\equiv \\pm q_{20,m} $$\n这是一个标准积分：\n$$ S_{inst} = \\sqrt{2 B_{20}} \\int_{-q_{20,m}}^{q_{20,m}} \\sqrt{(V_b - E_0) - \\frac{k_b}{2} q_{20}^2} \\,\\mathrm{d}q_{20} $$\n该积分的计算结果为 $\\frac{\\pi}{2} (V_b - E_0) \\sqrt{2/k_b}$。合并各项：\n$$ S_{inst} = \\pi (V_b - E_0) \\sqrt{\\frac{B_{20}}{k_b}} $$\n这是瞬子作用量的解析公式，它为数值计算提供了参考。\n\n### 3. 数值计算与测试用例\n\n对于两个转折点 $\\mathbf{q}_A$ 和 $\\mathbf{q}_B$ 之间的一条普通直线路径，我们使用参数化 $\\mathbf{q}(s) = \\mathbf{q}_A + s(\\mathbf{q}_B - \\mathbf{q}_A)$，其中 $s \\in [0, 1]$。路径导数 $\\mathrm{d}\\mathbf{q}/\\mathrm{d}s = \\mathbf{q}_B - \\mathbf{q}_A \\equiv \\Delta\\mathbf{q}$ 是恒定的。作用量积分变为：\n$$ S = \\sqrt{B_{20}(\\Delta q_{20})^2 + B_{30}(\\Delta q_{30})^2} \\int_0^1 \\sqrt{2\\left(E(\\mathbf{q}(s)) - E_0\\right)} \\,\\mathrm{d}s $$\n这个一维积分可以使用高斯求积法高效而准确地计算。\n\n**测试用例1、2和4：**指定的路径是沿 $q_{30}=0$。这就是瞬子路径。因此，数值WKB作用量的计算结果应在数值精度范围内与解析瞬子公式一致。其绝对差预计接近于零。\n\n**测试用例3：**指定的路径是 $q_{30} = 0.5 q_{20}$，这不是瞬子路径。根据最小作用量原理，沿任何非瞬子路径的作用量必须大于瞬子作用量。因此，我们预计沿这条“弯曲”路径（因 $q_{30} \\neq 0$ 而得名）的WKB作用量将大于使用相同势垒参数（$V_b, E_0, k_b, B_{20}$）计算的解析瞬子作用量。比较结果应为`True`。\n\n下面的程序实现了这些计算，使用`scipy.integrate.quad`进行数值积分。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef calculate_wkb_action(Vb, E0, kb, kt, B20, B30, path_type, beta=None):\n    \"\"\"\n    Numerically computes the WKB action along a specified straight-line path.\n\n    The path is parameterized by s in [0, 1] from turning point A to B.\n    \"\"\"\n    if Vb - E0  0:\n        return 0.0\n\n    if path_type == 'straight':\n        # Path along q30 = 0\n        if kb = 0: return np.inf\n        \n        q20_m = np.sqrt(2 * (Vb - E0) / kb)\n        qA = np.array([-q20_m, 0.0])\n        qB = np.array([q20_m, 0.0])\n\n    elif path_type == 'curved':\n        # Path along q30 = beta * q20\n        k_eff = kb - kt * beta**2\n        if k_eff = 0:\n            # No real turning points or path is not under a barrier\n            return np.inf\n        \n        q20_m = np.sqrt(2 * (Vb - E0) / k_eff)\n        qA = np.array([-q20_m, -beta * q20_m])\n        qB = np.array([q20_m, beta * q20_m])\n    else:\n        raise ValueError(\"Unknown path type\")\n\n    delta_q = qB - qA\n    B_metric_term = B20 * delta_q[0]**2 + B30 * delta_q[1]**2\n    if B_metric_term  0: return np.inf # Should not happen with positive B_ij\n    \n    # Define the integrand for the action integral\n    def integrand(s):\n        q20_s = qA[0] + s * delta_q[0]\n        q30_s = qA[1] + s * delta_q[1]\n        \n        potential_at_s = Vb - 0.5 * kb * q20_s**2 + 0.5 * kt * q30_s**2\n        energy_diff = potential_at_s - E0\n        \n        # Clamp to zero to handle potential floating-point inaccuracies\n        # at the endpoints where energy_diff should be exactly zero.\n        if energy_diff  0:\n            return 0.0\n            \n        return np.sqrt(2 * energy_diff)\n\n    integral_val, _ = quad(integrand, 0, 1)\n\n    action = np.sqrt(B_metric_term) * integral_val\n    return action\n\ndef calculate_instanton_action(Vb, E0, kb, B20):\n    \"\"\"\n    Analytically computes the instanton action for the separable quadratic barrier.\n    \"\"\"\n    if Vb - E0  0 or kb = 0 or B20  0:\n        return 0.0\n    return np.pi * (Vb - E0) * np.sqrt(B20 / kb)\n\ndef solve():\n    # Test suite: (Vb, E0, kb, kt, B20, B30)\n    test_cases = {\n        1: {'params': (6, 1, 4, 3, 10, 10), 'path': 'straight', 'beta': None},\n        2: {'params': (6, 2, 5, 3, 4, 16), 'path': 'straight', 'beta': None},\n        3: {'params': (6, 1, 4, 8, 10, 10), 'path': 'curved', 'beta': 0.5},\n        4: {'params': (10, 9.999, 6, 3, 7, 7), 'path': 'straight', 'beta': None},\n    }\n\n    results = []\n\n    # Test 1\n    case1 = test_cases[1]\n    Vb1, E01, kb1, _, B201, _ = case1['params']\n    wkb1 = calculate_wkb_action(*case1['params'], path_type=case1['path'])\n    inst1 = calculate_instanton_action(Vb1, E01, kb1, B201)\n    diff1 = np.abs(wkb1 - inst1)\n    results.extend([wkb1, diff1])\n\n    # Test 2\n    case2 = test_cases[2]\n    Vb2, E02, kb2, _, B202, _ = case2['params']\n    wkb2 = calculate_wkb_action(*case2['params'], path_type=case2['path'])\n    inst2 = calculate_instanton_action(Vb2, E02, kb2, B202)\n    diff2 = np.abs(wkb2 - inst2)\n    results.extend([wkb2, diff2])\n\n    # Test 3\n    case3 = test_cases[3]\n    Vb3, E03, kb3, _, B203, _ = case3['params']\n    wkb3_curved = calculate_wkb_action(*case3['params'], path_type=case3['path'], beta=case3['beta'])\n    inst3_straight = calculate_instanton_action(Vb3, E03, kb3, B203)\n    comp3 = wkb3_curved > inst3_straight\n    results.append(comp3)\n    \n    # Test 4\n    case4 = test_cases[4]\n    Vb4, E04, kb4, _, B204, _ = case4['params']\n    wkb4 = calculate_wkb_action(*case4['params'], path_type=case4['path'])\n    inst4 = calculate_instanton_action(Vb4, E04, kb4, B204)\n    diff4 = np.abs(wkb4 - inst4)\n    results.append(diff4)\n\n    # Format and print the final output\n    # Boolean must be 'True' or 'False' which str() handles correctly\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}