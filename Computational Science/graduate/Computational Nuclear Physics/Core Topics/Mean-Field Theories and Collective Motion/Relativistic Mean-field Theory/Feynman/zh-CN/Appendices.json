{
    "hands_on_practices": [
        {
            "introduction": "相对论平均场（RMF）理论建立在通过介子场描述核子相互作用的拉格朗日量之上。为了使该理论切合实际，一个关键步骤是引入对描述质子至关重要的电磁相互作用。此练习  将引导你走过通过局域规范不变性（现代物理学的基石原理）引入电磁相互作用的基本过程。通过从诺特定理推导守恒的电磁流，你将加深对对称性与守恒律之间深刻联系的理解。",
            "id": "3587761",
            "problem": "考虑一个核子同位旋二重态狄拉克场 $\\psi(x) = \\begin{pmatrix} \\psi_{p}(x) \\\\ \\psi_{n}(x) \\end{pmatrix}$，其中 $\\psi_{p}$ 和 $\\psi_{n}$ 分别是质子和中子分量。在相对论平均场（RMF）理论中，核子与经典介子平均场相互作用。忽略同位旋矢量介子，只包含一个同位旋标量标量场 $\\sigma(x)$ 和一个同位旋标量矢量场 $\\omega_{\\mu}(x)$，在没有电磁相互作用的情况下，拉格朗日量密度的核子部分为\n$$\n\\mathcal{L}_{\\text{N}} = \\bar{\\psi}\\left(i\\gamma^{\\mu}\\partial_{\\mu} - g_{\\omega}\\gamma^{\\mu}\\omega_{\\mu} - \\left(M - g_{\\sigma}\\sigma\\right)\\right)\\psi,\n$$\n其中 $\\gamma^{\\mu}$ 是狄拉克伽马矩阵，$M$ 是裸核子质量，$g_{\\sigma}$ 和 $g_{\\omega}$ 是介子-核子耦合常数。同位旋算符 $\\tau_{3}$ 作用于二重态分量，对质子的本征值为 $+1$，对中子的本征值为 $-1$。\n\n使用电磁 $U(1)$ 群下的局域规范不变性原理和在狄拉克拉格朗日量层面上的最小替换方案，引入电磁四维势 $A_{\\mu}(x)$，其耦合常数为 $e$，且只与质子分量耦合。在作用于核子二重态的电荷算符为 $Q = \\frac{1+\\tau_{3}}{2}$ 的约定下进行计算。从局域规范不变性、协变导数和连续对称性的 Noether 定理等基本定义出发，不使用任何预先推导的目标表达式，完成以下任务：\n\n1. 将由 $Q$ 生成的全局电磁相伴随性提升为局域对称性 $\\psi(x) \\to \\exp\\!\\left(i e \\alpha(x) Q\\right)\\psi(x)$，并通过在核子动能项中进行最小替换来引入电磁场。写出规范不变的核子-电磁拉格朗日量密度，保持介子平均场不变，并添加电磁场强度 $F_{\\mu\\nu} = \\partial_{\\mu}A_{\\nu} - \\partial_{\\nu}A_{\\mu}$ 的标准动能项。\n\n2. 通过将 Noether 定理应用于电磁对称性的全局形式，从第一性原理推导与质子分量相关的守恒电磁流，并明确地简化结果，使其仅用质子狄拉克场和伽马矩阵表示。你可以使用从你的规范不变拉格朗日量中推导出的核子运动方程来验证流守恒，但你关于流的最终表达式必须直接从对称性考虑中获得，而不是通过逆向工程运动方程得到。\n\n将守恒的质子电磁四维流密度的最终结果表示为单个闭合形式的解析表达式。不需要进行数值计算。答案必须是单个表达式，并且最终答案框内不得包含任何单位。",
            "solution": "我们从包含同位旋标量平均场的核子拉格朗日量开始，\n$$\n\\mathcal{L}_{\\text{N}} = \\bar{\\psi}\\left(i\\gamma^{\\mu}\\partial_{\\mu} - g_{\\omega}\\gamma^{\\mu}\\omega_{\\mu} - \\left(M - g_{\\sigma}\\sigma\\right)\\right)\\psi,\n$$\n其中 $\\psi$ 是同位旋二重态，与 $\\sigma$ 和 $\\omega_{\\mu}$ 的相互作用是同位旋标量的，即在同位旋空间中与单位算符成正比。引入电磁相互作用的基本依据是在电磁 $U(1)$ 群下的局域不变性要求，该群作用于核子二重态，其生成元为\n$$\nQ = \\frac{1+\\tau_{3}}{2}.\n$$\n这个算符投影到质子分量上：$Q\\psi = \\begin{pmatrix} \\psi_{p} \\\\ 0 \\end{pmatrix}$，因为 $\\tau_{3}\\psi_{p} = +\\psi_{p}$ 和 $\\tau_{3}\\psi_{n} = -\\psi_{n}$。\n\n对称性原理指出，在参数为 $\\alpha(x)$ 的局域 $U(1)$ 电磁变换下，核子场的变换方式如下\n$$\n\\psi(x) \\to \\psi'(x) = \\exp\\!\\left(i e \\alpha(x) Q\\right)\\psi(x),\n\\quad\n\\bar{\\psi}(x) \\to \\bar{\\psi}'(x) = \\bar{\\psi}(x)\\exp\\!\\left(-i e \\alpha(x) Q\\right),\n$$\n其中 $e$ 是基本电荷。为了在这种局域变换下保持动能项的不变性，我们通过引入协变导数来实现最小替换\n$$\nD_{\\mu} = \\partial_{\\mu} + i e A_{\\mu}(x) Q,\n$$\n并将核子动能项中的 $\\partial_{\\mu}$ 替换为 $D_{\\mu}$。规范场的变换方式为\n$$\nA_{\\mu}(x) \\to A'_{\\mu}(x) = A_{\\mu}(x) - \\partial_{\\mu}\\alpha(x),\n$$\n这确保了 $D_{\\mu}\\psi$ 的协变变换：$D_{\\mu}\\psi \\to \\exp\\!\\left(i e \\alpha Q\\right)D_{\\mu}\\psi$。\n\n因此，规范不变的核子-电磁拉格朗日量密度，加上电磁场强度的标准麦克斯韦项，为\n$$\n\\mathcal{L} = \\bar{\\psi}\\left(i\\gamma^{\\mu}D_{\\mu} - g_{\\omega}\\gamma^{\\mu}\\omega_{\\mu} - \\left(M - g_{\\sigma}\\sigma\\right)\\right)\\psi \\;-\\; \\frac{1}{4}F_{\\mu\\nu}F^{\\mu\\nu},\n$$\n其中\n$$\nD_{\\mu} = \\partial_{\\mu} + i e A_{\\mu} Q, \\quad Q = \\frac{1+\\tau_{3}}{2}.\n$$\n展开协变导数项，我们得到\n$$\n\\bar{\\psi}\\, i\\gamma^{\\mu}D_{\\mu}\\psi\n= \\bar{\\psi}\\, i\\gamma^{\\mu}\\partial_{\\mu}\\psi - e\\,\\bar{\\psi}\\,\\gamma^{\\mu} Q\\,\\psi\\, A_{\\mu}.\n$$\n于是，核子与电磁场之间的相互作用部分为\n$$\n\\mathcal{L}_{\\text{int, em}} = - e\\,\\bar{\\psi}\\,\\gamma^{\\mu} Q\\,\\psi\\, A_{\\mu}.\n$$\n\n为了从第一性原理推导守恒流，我们使用 Noether 定理处理电磁对称性的全局形式。考虑一个参数为常数 $\\epsilon$ 的全局变换，即\n$$\n\\delta\\psi = i e \\epsilon\\, Q\\,\\psi, \\qquad \\delta\\bar{\\psi} = - i e \\epsilon\\, \\bar{\\psi}\\, Q,\n$$\n并且 $A_{\\mu}$ 保持不变（对于全局对称性，规范场不发生变换）。与此内在对称性相关的 Noether 流由下式给出\n$$\nj^{\\mu} = \\frac{\\partial \\mathcal{L}}{\\partial\\left(\\partial_{\\mu}\\psi\\right)}\\,\\delta\\psi + \\delta\\bar{\\psi}\\,\\frac{\\partial \\mathcal{L}}{\\partial\\left(\\partial_{\\mu}\\bar{\\psi}\\right)}.\n$$\n在狄拉克型拉格朗日量中，$\\mathcal{L}$ 依赖于 $\\partial_{\\mu}\\psi$ 但不依赖于 $\\partial_{\\mu}\\bar{\\psi}$，因此 $\\frac{\\partial \\mathcal{L}}{\\partial\\left(\\partial_{\\mu}\\bar{\\psi}\\right)}=0$。使用\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial\\left(\\partial_{\\mu}\\psi\\right)} = i\\,\\bar{\\psi}\\,\\gamma^{\\mu},\n$$\n我们发现\n$$\nj^{\\mu} = i\\,\\bar{\\psi}\\,\\gamma^{\\mu}\\,(i e \\epsilon\\, Q)\\,\\psi = e \\epsilon\\, \\bar{\\psi}\\,\\gamma^{\\mu} Q\\,\\psi.\n$$\n去掉任意常数 $\\epsilon$（Noether 流的定义可以在一个由对称性参数决定的整体因子内任意调整），与核子二重态相关的电磁流密度为\n$$\nj_{\\text{em}}^{\\mu}(x) = e\\,\\bar{\\psi}(x)\\,\\gamma^{\\mu}\\,Q\\,\\psi(x).\n$$\n由于 $Q$ 投影到质子分量上，该表达式简化为质子流。明确写出质子场，$Q\\psi = \\begin{pmatrix}\\psi_{p}\\\\0\\end{pmatrix}$ 和 $\\bar{\\psi}Q = \\begin{pmatrix}\\bar{\\psi}_{p}  0\\end{pmatrix}$，我们得到\n$$\nj_{p}^{\\mu}(x) = e\\,\\bar{\\psi}_{p}(x)\\,\\gamma^{\\mu}\\,\\psi_{p}(x).\n$$\n\n使用运动方程来验证守恒性是很有启发性的。从 $\\mathcal{L}$ 推导出的质子分量的欧拉-拉格朗日方程为\n$$\n\\left(i\\gamma^{\\mu}D_{\\mu} - g_{\\omega}\\gamma^{\\mu}\\omega_{\\mu} - M^{\\ast}\\right)\\psi_{p} = 0, \\qquad M^{\\ast} \\equiv M - g_{\\sigma}\\sigma,\n$$\n其中 $D_{\\mu} = \\partial_{\\mu} + i e A_{\\mu}$ 作用于质子。其伴随方程为\n$$\n\\bar{\\psi}_{p}\\left(i\\overleftarrow{D}_{\\mu}\\gamma^{\\mu} + g_{\\omega}\\gamma^{\\mu}\\omega_{\\mu} + M^{\\ast}\\right) = 0,\n$$\n其中 $\\overleftarrow{D}_{\\mu} = \\overleftarrow{\\partial}_{\\mu} - i e A_{\\mu}$。取流的散度，\n$$\n\\partial_{\\mu} j_{p}^{\\mu} = e\\left[(\\partial_{\\mu}\\bar{\\psi}_{p})\\gamma^{\\mu}\\psi_{p} + \\bar{\\psi}_{p}\\gamma^{\\mu}(\\partial_{\\mu}\\psi_{p})\\right],\n$$\n并从运动方程代入 $\\partial_{\\mu}\\psi_{p}$ 和 $\\partial_{\\mu}\\bar{\\psi}_{p}$（分离协变部分，并使用 $\\gamma^{\\mu}$ 与数的反对易性质以及同位旋标量耦合的厄米性），各项两两相消，得到\n$$\n\\partial_{\\mu} j_{p}^{\\mu} = 0.\n$$\n因此，从 Noether 定理得到的质子电磁流是守恒的，这与规范不变性的要求一致。\n\n因此，在具有最小电磁耦合的 RMF 框架中，守恒的质子电磁四维流密度为\n$$\nj_{p}^{\\mu}(x) = e\\,\\bar{\\psi}_{p}(x)\\,\\gamma^{\\mu}\\,\\psi_{p}(x).\n$$\n这是一个以质子狄拉克场和伽马矩阵表示的闭合形式解析表达式，它是从局域 $U(1)$ 规范不变性和 Noether 定理的基本对称性原理推导出来的。",
            "answer": "$$\\boxed{e\\,\\bar{\\psi}_{p}\\,\\gamma^{\\mu}\\,\\psi_{p}}$$"
        },
        {
            "introduction": "求解RMF方程的自洽解可以为核系统提供一个可能的描述，但这并不能保证该解是物理稳定的。一个真正的基态必须对应于能量形貌中的一个局域极小值。这个计算练习  让你在准粒子随机相位近似（QRPA）框架内，实现对这种稳定性的直接检验，即Thouless稳定性条件。验证QRPA谱中没有非物理的不稳定性，是任何严肃的平均场计算中一个至关重要的验证步骤。",
            "id": "3587609",
            "problem": "要求您在协变相对论平均场 (RMF) 方法中，使用准粒子随机相近似 (QRPA) 对小振幅激发的 Thouless 稳定性条件进行数值验证。重点在于，通过检查 QRPA 谱中没有非物理不稳定性，并且只有预期的赝模式（与破缺的连续对称性相关的 Nambu–Goldstone 模式）出现在零激发能处，来确定一个给定的平均场解是否对应于一个（局域）极小值。您的程序必须是完全自洽的，且不能读取任何输入。\n\n背景与基本原理：\n- 在包含对关联的协变 RMF 理论的小振幅极限下，QRPA 方程可以在双准粒子基上写成一个带有辛度规的广义本征值问题的矩阵形式。令 $A$ 和 $B$ 为 QRPA 块。定义对称矩阵 $S \\equiv A - B$ 和 $P \\equiv A + B$。Thouless 稳定性定理指出，一个 Hartree(-Bogoliubov) 驻点是稳定的，当且仅当 $S$ 是半正定的，并且 $S$ 的零空间维度等于自发破缺的连续对称性的数量。在 $S$ 是正定的子空间上，激发能的平方是对此称乘积 $S^{1/2} P S^{1/2}$ 的本征值。实数且非负的能量平方值表明稳定性；负的本征值则表明不稳定性。\n- 在本练习中，为您提供了测试矩阵 $S$ 和 $P$，它们在一个示意性的粒子-空穴加对关联的组态空间中概括了 RMF+QRPA 的 Hessian 结构。您应当通过 $A = (S + P)/2$ 和 $B = (P - S)/2$ 来重构 $A$ 和 $B$，以强调与 QRPA 结构的一致性，但稳定性检查必须使用 $S$ 和 $P$ 来进行。\n\n您在每个测试案例中的任务：\n1. 给定 $S$ 和 $P$，使用 $A = (S + P)/2$ 和 $B = (P - S)/2$ 重构 $A$ 和 $B$（矩阵单位为 $\\mathrm{MeV}$）。\n2. 计算 $S$ 的本征值并验证 Thouless 条件：\n   - 统计 $S$ 的本征值中实际上为零（在数值容差范围内）的数量，这代表了零空间的维度，也就是与破缺对称性相关的赝模式的数量。\n   - 检查 $S$ 的所有本征值均没有小于负容差。\n3. 在 $S$ 严格为正的子空间上，计算对称乘积 $K \\equiv S^{1/2} P S^{1/2}$ 并求其本征值。这些值是激发能的平方 $\\,\\omega^2\\,$（单位为 $\\mathrm{MeV}^2$）。验证没有 $\\,\\omega^2\\,$ 值小于负容差。在容差范围内的零值 $\\,\\omega^2\\,$ 对应于零频率模式。\n4. 定义一个测试为通过，当且仅当：\n   - $S$ 的所有本征值均没有小于负容差。\n   - $K$ 的所有本征值均没有小于负容差。\n   - 零频率模式的总数（$S$ 的零度加上在 $S$ 为正的子空间上 $K$ 的零本征值数量之和）等于该案例预期的赝模式数量。\n5. 对所有案例统一使用以下数值容差：\n   - 零值容差：绝对值 $\\leq 10^{-10}$ 的数值被视为零。\n   - 负值容差：数值 $ -10^{-8}$ 被视为严格为负。\n\n测试套件（所有矩阵单位均为 $\\mathrm{MeV}$，排列为 $3 \\times 3$ 矩阵；未显示的元素均为零）：\n- 案例1（稳定，无对称性破缺）：\n  - $S_1 = \\mathrm{diag}([\\,10,\\,12,\\,14\\,]) = \\begin{bmatrix} 10  0  0 \\\\ 0  12  0 \\\\ 0  0  14 \\end{bmatrix}$。\n  - $P_1 = \\mathrm{diag}([\\,11,\\,13,\\,16\\,]) = \\begin{bmatrix} 11  0  0 \\\\ 0  13  0 \\\\ 0  0  16 \\end{bmatrix}$。\n  - 预期赝模式数量：$0$。\n- 案例2（一个破缺的连续对称性导致一个赝零模式）：\n  - $S_2 = \\mathrm{diag}([\\,0,\\,8,\\,12\\,]) = \\begin{bmatrix} 0  0  0 \\\\ 0  8  0 \\\\ 0  0  12 \\end{bmatrix}$。\n  - $P_2 = \\mathrm{diag}([\\,0,\\,9,\\,15\\,]) = \\begin{bmatrix} 0  0  0 \\\\ 0  9  0 \\\\ 0  0  15 \\end{bmatrix}$。\n  - 预期赝模式数量：$1$。\n- 案例3（由于一个负的频率平方模式导致的不稳定性）：\n  - $S_3 = \\mathrm{diag}([\\,8,\\,10,\\,12\\,]) = \\begin{bmatrix} 8  0  0 \\\\ 0  10  0 \\\\ 0  0  12 \\end{bmatrix}$。\n  - $P_3 = \\mathrm{diag}([\\, -1,\\,9,\\,14\\,]) = \\begin{bmatrix} -1  0  0 \\\\ 0  9  0 \\\\ 0  0  14 \\end{bmatrix}$。\n  - 预期赝模式数量：$0$。\n\n实现要求：\n- 不涉及角度。\n- 所有物理量根据情况以 $\\mathrm{MeV}$ 或 $\\mathrm{MeV}^2$ 为单位。\n- 您的程序应按顺序处理三个测试案例。对于每个案例，根据步骤4中的定义，以布尔值形式评估其通过/失败状态。\n- 最终输出格式：您的程序应生成单行输出，其中包含三个布尔结果，形式为用方括号括起来的逗号分隔列表，例如 $[\\,\\text{True},\\text{False},\\text{True}\\,]$。\n\n注意：\n- 您不得读取输入。所有数据必须如上所述进行硬编码。\n- 使用指定的容差确保数值稳健性。",
            "solution": "该问题要求对一组代表准粒子随机相近似 (QRPA) 框架内相对论平均场 (RMF) 基态的测试案例，进行 Thouless 稳定性条件的数值验证。平均场解的稳定性是通过分析两个关键矩阵 $S$ 和 $P$ 的谱特性来确定的，这两个矩阵封装了能量泛函的二阶变分。\n\n基本的理论基础是 Thouless 稳定性定理。在 RMF+QRPA 的背景下，小振幅振荡的 QRPA 方程可以被表述为一个广义本征值问题。底层的 Hartree-Bogoliubov 真空的稳定性得到保证，当且仅当矩阵 $S \\equiv A - B$ 是半正定的，其中 $A$ 和 $B$ 是标准的 QRPA 块。矩阵 $S$ 和 $P \\equiv A + B$ 是对称的，并包含有关稳定性的全部信息。问题提供了 $S$ 和 $P$，并要求我们验证稳定性。通过 $A = (S+P)/2$ 和 $B = (P-S)/2$ 重构 $A$ 和 $B$ 是为了与 QRPA 形式体系进行一致性检查，但对于稳定性分析本身而言并非直接必需。\n\n稳定性分析分两个主要步骤进行：\n\n1.  **分析矩阵 $S$**：根据 Thouless 定理，一个稳定或亚稳的平均场解要求 $S$ 是半正定的。这意味着它的所有本征值 $\\lambda_i$ 都必须是非负的（$\\lambda_i \\ge 0$）。\n    -   $S$ 的任何严格为负的本征值（即 $\\lambda_i  -10^{-8}$）都标志着 Hartree-Bogoliubov 真空存在基本不稳定性。\n    -   $S$ 的零空间维度，由在容差范围内为零的本征值 $\\lambda_i$ 的数量（$|\\lambda_i| \\le 10^{-10}$）给出，对应于由自发破缺的连续对称性产生的 Nambu-Goldstone (赝) 模式的数量。我们将此数量记为 $n_{\\text{null}}$。\n\n2.  **分析激发能**：对于 $S$ 是严格正定的子空间，激发能的平方 $\\omega^2$ 是对称矩阵乘积 $K \\equiv S^{1/2} P S^{1/2}$ 的本征值。\n    -   稳定性要求所有物理激发模式都具有实数能量，这意味着它们的平方 $\\omega^2$ 必须是非负的。$K$ 的任何严格为负的本征值（即 $\\omega^2  -10^{-8}$）都表明存在动力学不稳定性，此时系统将偏离平均场解进行演化。\n    -   $K$ 的零能本征值（$|\\omega^2| \\le 10^{-10}$）也可能对应于赝模式。设其数量为 $n_{\\text{zero},K}$。\n\n如果所有条件都满足，一个测试案例即被认为通过（即状态是稳定的）：$S$ 没有负本征值，$K$ 没有负本征值，并且零模式的总数 $n_{\\text{total}} = n_{\\text{null}} + n_{\\text{zero},K}$ 等于该特定案例中与破缺对称性相关的预期赝模式数量。\n\n验证每个案例的数值算法如下：\n1.  给定矩阵 $S$ 和 $P$（单位为 $\\mathrm{MeV}$）以及预期的赝模式数量。\n2.  计算对称矩阵 $S$ 的本征值 $\\lambda_i$。验证没有 $\\lambda_i  -10^{-8}$。\n3.  统计 $S$ 的零本征值数量 $n_{\\text{null}}$，其中 $|\\lambda_i| \\le 10^{-10}$。\n4.  确定由 $S$ 的严格正本征值（$\\lambda_i > 10^{-10}$）对应的本征向量所张成的子空间。\n5.  在这个正子空间上，我们计算 $K$ 的本征值。一个稳健的方法是首先将 $P$ 投影到 $S$ 的正本征向量基上，得到 $P_{\\text{proj}}$。在这个基中，$S$ 是对角的，其对角元为 $\\lambda_i > 0$。我们要求解的矩阵是 $K_{\\text{proj}} = \\Lambda_{\\text{pos}}^{1/2} P_{\\text{proj}} \\Lambda_{\\text{pos}}^{1/2}$，其中 $\\Lambda_{\\text{pos}}$ 是由 $S$ 的正本征值构成的对角矩阵。对于本问题中的特定对角矩阵，这可以简化为计算 $S$ 和 $P$ 相应对角元素的乘积。对于所有满足 $S_{jj} > 10^{-10}$ 的指标 $j$，$K$ 的本征值为 $\\omega^2_j = S_{jj} P_{jj}$。\n6.  验证没有本征值 $\\omega^2_j$ 小于 $-10^{-8}$。\n7.  统计 $K$ 的零本征值数量 $n_{\\text{zero},K}$，其中 $|\\omega^2_j| \\le 10^{-10}$。\n8.  如果所有负值检查都通过，并且 $n_{\\text{null}} + n_{\\text{zero},K}$ 等于预期的赝模式数量，则该案例通过。\n\n将此过程应用于测试案例：\n\n-   **案例1**：$S_1 = \\text{diag}([10, 12, 14])$, $P_1 = \\text{diag}([11, 13, 16])$, 预期模式数：$0$。\n    -   $S_1$ 的本征值为 $10, 12, 14$。均为正数。通过。\n    -   $n_{\\text{null}} = 0$。\n    -   正子空间是整个空间。$K_1$ 的本征值是 $S_{ii} P_{ii}$ 的乘积：$10 \\times 11 = 110$, $12 \\times 13 = 156$, $14 \\times 16 = 224$。均为正数。通过。\n    -   $n_{\\text{zero},K} = 0$。\n    -   总零模式数：$n_{\\text{null}} + n_{\\text{zero},K} = 0 + 0 = 0$。这与预期值 $0$ 相符。通过。\n    -   最终结果：True。\n\n-   **案例2**：$S_2 = \\text{diag}([0, 8, 12])$, $P_2 = \\text{diag}([0, 9, 15])$, 预期模式数：$1$。\n    -   $S_2$ 的本征值为 $0, 8, 12$。没有负值。通过。\n    -   由于存在零本征值，$n_{\\text{null}} = 1$。\n    -   正子空间由 $S_{ii} > 0$ 的基向量张成。$K_2$ 的本征值在此子空间上计算：$8 \\times 9 = 72$, $12 \\times 15 = 180$。两者均为正数。通过。\n    -   $n_{\\text{zero},K} = 0$。\n    -   总零模式数：$n_{\\text{null}} + n_{\\text{zero},K} = 1 + 0 = 1$。这与预期值 $1$ 相符。通过。\n    -   最终结果：True。\n\n-   **案例3**：$S_3 = \\text{diag}([8, 10, 12])$, $P_3 = \\text{diag}([-1, 9, 14])$, 预期模式数：$0$。\n    -   $S_3$ 的本征值为 $8, 10, 12$。均为正数。通过。\n    -   $n_{\\text{null}} = 0$。\n    -   正子空间是整个空间。$K_3$ 的本征值是 $S_{ii} P_{ii}$ 的乘积：$8 \\times (-1) = -8$, $10 \\times 9 = 90$, $12 \\times 14 = 168$。\n    -   一个本征值 $-8$ 小于负值容差 $-10^{-8}$。这标志着不稳定性。失败。\n    -   测试在这一点上失败，与模式计数无关。\n    -   最终结果：False。\n\n以下 Python 程序为对称矩阵实现了一个通用且稳健的算法，以系统地执行这些检查。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_stability(S, P, expected_modes):\n    \"\"\"\n    Checks the Thouless stability for a given RMF+QRPA configuration.\n\n    Args:\n        S (np.ndarray): The S matrix of the QRPA problem.\n        P (np.ndarray): The P matrix of the QRPA problem.\n        expected_modes (int): The expected number of spurious zero-energy modes.\n\n    Returns:\n        bool: True if the configuration is stable and passes all checks, False otherwise.\n    \"\"\"\n    ZERO_TOL = 1e-10\n    NEG_TOL = -1e-8\n\n    # Ensure matrices are numpy arrays of float type for calculations\n    S = np.array(S, dtype=float)\n    P = np.array(P, dtype=float)\n\n    # Step 1: Analyze the S matrix\n    # S is real and symmetric, use eigh for numerical stability\n    eig_s, vec_s = np.linalg.eigh(S)\n\n    # Step 1a: Check for negative eigenvalues in S (violates positive semi-definiteness)\n    if np.any(eig_s  NEG_TOL):\n        return False\n\n    # Step 1b: Count the dimension of the null space of S\n    nullity_s = np.sum(np.abs(eig_s) = ZERO_TOL)\n\n    # Step 2: Analyze the K matrix on the positive subspace of S\n    positive_indices = np.where(eig_s > ZERO_TOL)[0]\n\n    zero_modes_k = 0\n    # Proceed only if there is a non-trivial positive subspace\n    if len(positive_indices) > 0:\n        # Get eigenvalues and eigenvectors for the positive subspace of S\n        eig_s_pos = eig_s[positive_indices]\n        vec_s_pos = vec_s[:, positive_indices]\n\n        # Project P into the basis of S-positive eigenvectors\n        # P_proj = U_pos^T * P * U_pos, where U_pos columns are vec_s_pos\n        P_proj = vec_s_pos.T @ P @ vec_s_pos\n\n        # In this projected basis, S_proj^(1/2) is diagonal\n        S_sqrt_proj_diag = np.diag(np.sqrt(eig_s_pos))\n        \n        # Construct K_proj = S_proj^(1/2) * P_proj * S_proj^(1/2)\n        # This is more numerically stable than constructing full space matrices\n        K_proj = S_sqrt_proj_diag @ P_proj @ S_sqrt_proj_diag\n\n        # Eigenvalues of K_proj, which is symmetric\n        eig_k_proj = np.linalg.eigvalsh(K_proj)\n\n        # Step 2a: Check for negative eigenvalues in K (instability)\n        if np.any(eig_k_proj  NEG_TOL):\n            return False\n\n        # Step 2b: Count zero-energy modes from K\n        zero_modes_k = np.sum(np.abs(eig_k_proj) = ZERO_TOL)\n    \n    # Step 3: Final check on the total number of spurious modes\n    total_zero_modes = nullity_s + zero_modes_k\n    if total_zero_modes != expected_modes:\n        return False\n\n    # If all checks passed, the state is stable\n    return True\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the stability analysis.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"S\": [[10, 0, 0], [0, 12, 0], [0, 0, 14]],\n            \"P\": [[11, 0, 0], [0, 13, 0], [0, 0, 16]],\n            \"expected_modes\": 0\n        },\n        {\n            \"S\": [[0, 0, 0], [0, 8, 0], [0, 0, 12]],\n            \"P\": [[0, 0, 0], [0, 9, 0], [0, 0, 15]],\n            \"expected_modes\": 1\n        },\n        {\n            \"S\": [[8, 0, 0], [0, 10, 0], [0, 0, 12]],\n            \"P\": [[-1, 0, 0], [0, 9, 0], [0, 0, 14]],\n            \"expected_modes\": 0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = check_stability(case[\"S\"], case[\"P\"], case[\"expected_modes\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将像RMF这样复杂的理论模型与实验数据联系起来是核物理学的一个中心目标，但这通常涉及计算成本高昂的参数探索。这个高级实践  介绍了一种克服这一挑战的前沿技术：使用高斯过程构建统计模拟器。你将学习用一个快速而准确的模拟器来替代耗时的RMF计算，并用它来执行完整的贝叶斯推断，从而实现稳健的参数估计和有原则的不确定性量化。",
            "id": "3587641",
            "problem": "你的任务是为计算核物理中的相对论平均场（RMF）理论实现一个基于模拟器的端到端贝叶斯推断工作流。该模拟器必须是一个高斯过程（GP），它能够预测作为耦合参数向量函数的 RMF 可观测量，并量化预测不确定性。然后，使用该模拟器来加速贝叶斯推断，方法是用包含模拟器不确定性的 GP 预测分布替换似然函数中计算成本高昂的正向模型。\n\n仅从以下基本概念出发：多元正态分布的定义、贝叶斯法则以及协方差核的定义。除了贝叶斯法则外，不要假定任何预先推导好的高斯过程回归方程或贝叶斯公式。你在解决方案中使用的任何推导都必须源于这些基本概念。\n\n考虑一个双参数 RMF 模型，其参数向量为 $\\boldsymbol{\\theta} = (g_{\\sigma}, g_{\\omega})$，其中 $g_{\\sigma}$ 和 $g_{\\omega}$ 是无量纲的耦合常数。定义一个计算成本低但具有物理动机的 RMF 代理正向模型，该模型将 $\\boldsymbol{\\theta}$ 映射到两个可观测量：饱和点附近对称核物质的每核子结合能 $E$（单位为 $\\mathrm{MeV}$）和一个重原子核的电荷半径 $R$（单位为 $\\mathrm{fm}$）。该代理正向模型为\n$$\n\\begin{aligned}\nd(\\boldsymbol{\\theta}) = g_{\\sigma} - 0.85\\, g_{\\omega},\\\\\nE(\\boldsymbol{\\theta}) = -16.0 + 3.5\\,(d(\\boldsymbol{\\theta}) - 0.5) + 1.2\\,(d(\\boldsymbol{\\theta}) - 0.5)^2 - 0.15\\,(g_{\\sigma} - 10.0)\\,(g_{\\omega} - 11.0) \\\\\n\\quad + 0.02\\,(g_{\\sigma} - 10.0)^3 - 0.015\\,(g_{\\omega} - 11.0)^3,\\\\\nR(\\boldsymbol{\\theta}) = 5.5 + 0.03\\,(g_{\\omega} - 11.0) - 0.025\\,(g_{\\sigma} - 10.0) + 0.005\\,(g_{\\sigma} - 10.0)^2 + 0.004\\,(g_{\\omega} - 11.0)^2 \\\\\n\\quad - 0.006\\,(g_{\\sigma} - 10.0)\\,(g_{\\omega} - 11.0) + 0.0008\\,(g_{\\sigma} - 10.0)^3.\n\\end{aligned}\n$$\n你的 GP 模拟器必须对映射 $\\boldsymbol{\\theta} \\mapsto (E(\\boldsymbol{\\theta}), R(\\boldsymbol{\\theta}))$ 进行建模，并为任意查询点 $\\boldsymbol{\\theta}$ 的每个可观测量提供预测均值和预测方差。使用一个零均值 GP，其核函数为具有各向同性长度尺度的平方指数（径向基函数）核。通过其预测方差来量化模拟器的不确定性。为保证数值稳定性，在训练协方差矩阵的对角线上加入一个小的扰动项（nugget/jitter）。\n\n训练数据：\n- 使用以 $13$ 为种子的伪随机数生成器，从超矩形 $[8,12]\\times[8,12]$ 中均匀独立地抽取 $N = 80$ 个训练输入 $\\{\\boldsymbol{\\theta}_i\\}_{i=1}^{N}$。\n- 对每个 $\\boldsymbol{\\theta}_i$，计算无噪声的训练目标 $\\mathbf{y}_i = (E(\\boldsymbol{\\theta}_i), R(\\boldsymbol{\\theta}_i))$，单位分别为 $\\mathrm{MeV}$ 和 $\\mathrm{fm}$。\n\n模拟器规格与预处理：\n- 在拟合 GP 之前，对训练集中的每个可观测量进行标准化，使其均值为零，方差为一。在进行似然评估时，将预测结果反标准化回物理单位。\n- 在标准化输出空间中使用平方指数核 $k(\\mathbf{x},\\mathbf{x}') = \\sigma_f^2 \\exp\\!\\big(-\\tfrac{1}{2}\\|\\mathbf{x}-\\mathbf{x}'\\|^2/\\ell^2\\big)$，其信号方差 $\\sigma_f^2 = 1$，各向同性长度尺度 $\\ell = 1$。使用扰动项 $\\sigma_n^2 = 10^{-6}$。\n- 为每个可观测量训练一个独立的 GP。\n\n使用模拟器进行贝叶斯推断：\n- 对 $\\boldsymbol{\\theta}$ 使用高斯先验，其分量相互独立：$g_{\\sigma} \\sim \\mathcal{N}(10.0, 0.8^2)$ 和 $g_{\\omega} \\sim \\mathcal{N}(11.0, 0.8^2)$。\n- 对于一个观测值 $\\mathbf{y}^{\\mathrm{obs}} = (E^{\\mathrm{obs}}, R^{\\mathrm{obs}})$，其已知实验标准差为 $\\boldsymbol{\\sigma}^{\\mathrm{exp}} = (\\sigma_E, \\sigma_R)$，将 $\\boldsymbol{\\theta}$ 处的似然函数近似为两个独立正态密度的乘积，一个用于 $E$，一个用于 $R$。每个正态分布的方差等于实验方差与模拟器在 $\\boldsymbol{\\theta}$ 处的预测方差之和，即 $\\sigma_{\\mathrm{tot},j}^2(\\boldsymbol{\\theta}) = \\big(\\sigma^{\\mathrm{exp}}_j\\big)^2 + \\sigma^{2,\\mathrm{emu}}_j(\\boldsymbol{\\theta})$，其中 $j \\in \\{E,R\\}$。\n\n加速推断的测试套件：\n为了对三个不同的观测数据集近似后验分布，在一个均匀的参数网格上评估后验期望。使用一个覆盖 $[8,12]\\times[8,12]$（含边界）的 $81\\times 81$ 网格进行数值积分。这三个观测数据集通过选择三个参数点并从正向模型生成合成数据（不添加噪声）来定义，同时指定了实验不确定性：\n- 数据集 A（理想情况）：$\\boldsymbol{\\theta}_A = (10.2, 10.8)$，$\\mathbf{y}^{\\mathrm{obs}}_A = \\big(E(\\boldsymbol{\\theta}_A), R(\\boldsymbol{\\theta}_A)\\big)$，$\\boldsymbol{\\sigma}^{\\mathrm{exp}}_A = (0.4\\,\\mathrm{MeV}, 0.015\\,\\mathrm{fm})$。\n- 数据集 B（严苛数据）：$\\boldsymbol{\\theta}_B = (9.0, 11.8)$，$\\mathbf{y}^{\\mathrm{obs}}_B = \\big(E(\\boldsymbol{\\theta}_B), R(\\boldsymbol{\\theta}_B)\\big)$，$\\boldsymbol{\\sigma}^{\\mathrm{exp}}_B = (0.05\\,\\mathrm{MeV}, 0.003\\,\\mathrm{fm})$。\n- 数据集 C（边界情况）：$\\boldsymbol{\\theta}_C = (8.1, 12.0)$，$\\mathbf{y}^{\\mathrm{obs}}_C = \\big(E(\\boldsymbol{\\theta}_C), R(\\boldsymbol{\\theta}_C)\\big)$，$\\boldsymbol{\\sigma}^{\\mathrm{exp}}_C = (0.4\\,\\mathrm{MeV}, 0.020\\,\\mathrm{fm})$。\n\n对于每个数据集，在网格上使用先验和基于模拟器的似然函数来近似 $\\boldsymbol{\\theta}$ 的后验分布，并计算 $g_{\\sigma}$ 的后验均值：\n$$\n\\mathbb{E}[g_{\\sigma} \\mid \\mathbf{y}^{\\mathrm{obs}}] \\approx \\frac{\\sum_{k} g_{\\sigma}^{(k)} \\, w^{(k)}}{\\sum_{k} w^{(k)}},\n$$\n其中 $w^{(k)}$ 是网格点 $\\boldsymbol{\\theta}^{(k)}$ 处的未归一化后验权重，求和遍及整个网格。\n\n要求的最终输出格式：\n- 你的程序必须生成一行包含 Python 风格的列表，内含三个浮点数，分别对应后验均值 $\\big[\\mathbb{E}[g_{\\sigma}\\mid \\mathbf{y}^{\\mathrm{obs}}_A], \\mathbb{E}[g_{\\sigma}\\mid \\mathbf{y}^{\\mathrm{obs}}_B], \\mathbb{E}[g_{\\sigma}\\mid \\mathbf{y}^{\\mathrm{obs}}_C]\\big]$，每个数值四舍五入到 $6$ 位小数。由于 $g_{\\sigma}$ 是无量纲的，输出中不需要单位。\n- 示例格式：$\\big[\\text{float}_1,\\text{float}_2,\\text{float}_3\\big]$。\n\n角度单位不适用。问题中指定的物理单位在内部使用：$E$ 的单位是 $\\mathrm{MeV}$，$R$ 的单位是 $\\mathrm{fm}$。\n\n你的实现必须是自包含的，并且必须严格按照所述的训练协议、模拟器规格和测试套件进行。代码不得要求任何外部输入。",
            "solution": "任务是为双参数相对论平均场（RMF）模型构建并使用一个高斯过程（GP）模拟器，以加速贝叶斯推断。该解决方案按要求从第一性原理出发进行开发：多元正态分布的定义、贝叶斯法则以及协方差核的定义。\n\n首先，我们为 GP 模拟器建立理论基础。一个高斯过程定义了函数上的一个分布，由一个均值函数 $m(\\boldsymbol{\\theta})$ 和一个协方差函数（或称核函数）$k(\\boldsymbol{\\theta}, \\boldsymbol{\\theta}')$ 指定。根据定义，任何有限的函数值集合都服从联合多元正态分布。对于本问题，我们使用零均值 GP，因此 $m(\\boldsymbol{\\theta}) = 0$。核函数是平方指数函数 $k(\\boldsymbol{\\theta}, \\boldsymbol{\\theta}') = \\sigma_f^2 \\exp(-\\frac{1}{2}\\|\\boldsymbol{\\theta}-\\boldsymbol{\\theta}'\\|^2/\\ell^2)$，其指定的超参数为 $\\sigma_f^2=1$ 和 $\\ell=1$。\n\n令训练数据由 $N$ 个输入-输出对 $\\mathcal{D} = \\{(\\boldsymbol{\\theta}_i, y_i)\\}_{i=1}^N$ 组成，其中 $\\boldsymbol{\\Theta} = \\{\\boldsymbol{\\theta}_i\\}_{i=1}^N$ 是训练输入集，$\\mathbf{y}$ 是相应输出的向量。我们希望预测新测试点 $\\boldsymbol{\\theta}_*$ 处的函数值 $y_*$。GP 回归的核心思想是利用训练输出 $\\mathbf{y}$ 和测试输出 $y_*$ 的联合多元正态分布。为了保证数值稳定性，在训练协方差矩阵的对角线上增加了一个小的扰动项 $\\sigma_n^2$。这可以解释为假设训练观测值上存在少量独立同分布的高斯噪声，使得 $\\mathbf{y} \\sim \\mathcal{N}(\\mathbf{f}, \\sigma_n^2 I)$，其中 $\\mathbf{f}$ 是真实的函数值。观测到的训练输出 $\\mathbf{y}$ 和在 $\\boldsymbol{\\theta}_*$ 处的潜函数值 $f_*$ 的联合分布是：\n$$\n\\begin{pmatrix} \\mathbf{y} \\\\ f_* \\end{pmatrix} \\sim \\mathcal{N}\\left(\n\\mathbf{0},\n\\begin{pmatrix}\nK(\\boldsymbol{\\Theta}, \\boldsymbol{\\Theta}) + \\sigma_n^2 I  K(\\boldsymbol{\\Theta}, \\boldsymbol{\\theta}_*) \\\\\nK(\\boldsymbol{\\theta}_*, \\boldsymbol{\\Theta})  k(\\boldsymbol{\\theta}_*, \\boldsymbol{\\theta}_*)\n\\end{pmatrix}\n\\right)\n$$\n其中 $[K(\\boldsymbol{\\Theta}, \\boldsymbol{\\Theta})]_{ij} = k(\\boldsymbol{\\theta}_i, \\boldsymbol{\\theta}_j)$，而 $K(\\boldsymbol{\\Theta}, \\boldsymbol{\\theta}_*)$ 是一个列向量，其元素为 $k(\\boldsymbol{\\theta}_i, \\boldsymbol{\\theta}_*)$。\n\n预测分布 $p(f_*|\\mathcal{D}, \\boldsymbol{\\theta}_*)$ 是在给定 $\\mathbf{y}$ 的条件下 $f_*$ 的条件分布。使用多元正态分布的条件分布公式，其中 $\\begin{pmatrix} \\mathbf{x}_1 \\\\ \\mathbf{x}_2 \\end{pmatrix} \\sim \\mathcal{N}\\left( \\begin{pmatrix} \\boldsymbol{\\mu}_1 \\\\ \\boldsymbol{\\mu}_2 \\end{pmatrix}, \\begin{pmatrix} \\Sigma_{11}  \\Sigma_{12} \\\\ \\Sigma_{21}  \\Sigma_{22} \\end{pmatrix} \\right)$ 会导出 $\\mathbf{x}_1 | \\mathbf{x}_2 \\sim \\mathcal{N}(\\boldsymbol{\\mu}_1 + \\Sigma_{12}\\Sigma_{22}^{-1}(\\mathbf{x}_2 - \\boldsymbol{\\mu}_2), \\Sigma_{11} - \\Sigma_{12}\\Sigma_{22}^{-1}\\Sigma_{21})$。我们识别出 $\\mathbf{x}_1 \\to f_*$，$\\mathbf{x}_2 \\to \\mathbf{y}$ 以及各自的均值和协方差块。由于先验均值为零， $f_*$ 的预测均值 $\\mu_*$ 和方差 $\\sigma_*^2$ 为：\n$$\n\\mu_*(\\boldsymbol{\\theta}_*) = K(\\boldsymbol{\\theta}_*, \\boldsymbol{\\Theta}) [K(\\boldsymbol{\\Theta}, \\boldsymbol{\\Theta}) + \\sigma_n^2 I]^{-1} \\mathbf{y}\n$$\n$$\n\\sigma_*^2(\\boldsymbol{\\theta}_*) = k(\\boldsymbol{\\theta}_*, \\boldsymbol{\\theta}_*) - K(\\boldsymbol{\\theta}_*, \\boldsymbol{\\Theta}) [K(\\boldsymbol{\\Theta}, \\boldsymbol{\\Theta}) + \\sigma_n^2 I]^{-1} K(\\boldsymbol{\\Theta}, \\boldsymbol{\\theta}_*)\n$$\n这个 $\\sigma_*^2(\\boldsymbol{\\theta}_*)$ 就是模拟器的预测方差 $\\sigma^{2,\\text{emu}}(\\boldsymbol{\\theta}_*)$，它量化了模拟器的不确定性。\n\n问题要求为两个可观测量 $E$ 和 $R$ 训练独立的 GP。在拟合之前，每个可观量的训练数据都经过标准化，以使其均值为零，标准差为一。设原始训练输出为 $\\{y_i\\}$，其样本均值为 $\\mu_y$，样本标准差为 $\\sigma_y$。标准化后的输出为 $y_i^{\\text{std}} = (y_i - \\mu_y) / \\sigma_y$。GP 在这些标准化的值上进行训练。在 $\\boldsymbol{\\theta}_*$ 处的预测会产生一个标准化的均值 $\\mu_*^{\\text{std}}$ 和方差 $(\\sigma_*^{\\text{std}})^2$。这些值需要反标准化回物理单位：\n$$\n\\mu_*^{\\text{phys}}(\\boldsymbol{\\theta}_*) = \\mu_*^{\\text{std}}(\\boldsymbol{\\theta}_*) \\cdot \\sigma_y + \\mu_y\n$$\n$$\n\\sigma^{2,\\text{emu}}(\\boldsymbol{\\theta}_*) = (\\sigma_*^{\\text{std}}(\\boldsymbol{\\theta}_*))^2 \\cdot \\sigma_y^2\n$$\n\n接下来，我们构建贝叶斯推断。目标是在给定观测值 $\\mathbf{y}^{\\mathrm{obs}} = (E^{\\mathrm{obs}}, R^{\\mathrm{obs}})$ 的情况下，估计参数 $\\boldsymbol{\\theta}$ 的后验分布。根据贝叶斯法则：\n$$\np(\\boldsymbol{\\theta} | \\mathbf{y}^{\\mathrm{obs}}) \\propto p(\\mathbf{y}^{\\mathrm{obs}} | \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta})\n$$\n先验 $p(\\boldsymbol{\\theta})$ 已给出，是关于 $g_{\\sigma}$ 和 $g_{\\omega}$ 的独立正态分布的乘积。似然函数 $p(\\mathbf{y}^{\\mathrm{obs}} | \\boldsymbol{\\theta})$ 是使用 GP 模拟器的地方。模拟器为参数点 $\\boldsymbol{\\theta}$ 处的可观测量 $y_j$ 的真实值提供了一个预测分布，即 $\\mathcal{N}(y_j | \\mu_{j,*}^{\\text{phys}}(\\boldsymbol{\\theta}), \\sigma_{j,\\text{emu}}^{2}(\\boldsymbol{\\theta}))$。观测值 $y_j^{\\mathrm{obs}}$ 具有实验不确定性，建模为 $y_j^{\\mathrm{obs}} \\sim \\mathcal{N}(y_j, (\\sigma_j^{\\text{exp}})^2)$。在 $\\boldsymbol{\\theta}$ 处，观测值 $y_j^{\\mathrm{obs}}$ 的边际似然是这两个高斯分布的卷积，结果是另一个高斯分布，其均值和方差相加：\n$$\np(y_j^{\\mathrm{obs}} | \\boldsymbol{\\theta}) = \\mathcal{N}\\left( y_j^{\\mathrm{obs}} \\mid \\mu_{j,*}^{\\text{phys}}(\\boldsymbol{\\theta}), \\left( \\sigma_j^{\\mathrm{exp}} \\right)^2 + \\sigma_{j,\\text{emu}}^{2}(\\boldsymbol{\\theta}) \\right)\n$$\n假设可观测量 $E$ 和 $R$ 是独立的，总似然函数是它们的乘积：\n$$\np(\\mathbf{y}^{\\mathrm{obs}} | \\boldsymbol{\\theta}) = p(E^{\\mathrm{obs}} | \\boldsymbol{\\theta}) \\cdot p(R^{\\mathrm{obs}} | \\boldsymbol{\\theta})\n$$\n后验分布在一个离散的 $\\boldsymbol{\\theta}^{(k)}$ 点网格上进行近似。在每个点上，我们计算未归一化的后验权重 $w^{(k)} = p(\\mathbf{y}^{\\mathrm{obs}} | \\boldsymbol{\\theta}^{(k)}) p(\\boldsymbol{\\theta}^{(k)})$。然后，$g_{\\sigma}$ 的后验期望通过网格上的加权和来近似：\n$$\n\\mathbb{E}[g_{\\sigma} \\mid \\mathbf{y}^{\\mathrm{obs}}] \\approx \\frac{\\sum_{k} g_{\\sigma}^{(k)} \\, w^{(k)}}{\\sum_{k} w^{(k)}}\n$$\n\n实现过程如下：\n1.  定义 RMF 代理正向模型的函数 $E(\\boldsymbol{\\theta})$ 和 $R(\\boldsymbol{\\theta})$。\n2.  使用指定的随机种子，从 $[8, 12] \\times [8, 12]$ 的均匀分布中生成 $N=80$ 个训练点 $\\{\\boldsymbol{\\theta}_i\\}$。\n3.  计算相应的训练输出 $\\mathbf{y}_i = (E(\\boldsymbol{\\theta}_i), R(\\boldsymbol{\\theta}_i))$。\n4.  对每个可观测量（$E$ 和 $R$）：\n    a. 标准化训练输出。\n    b. 构建 GP 核矩阵 $K(\\boldsymbol{\\Theta}, \\boldsymbol{\\Theta})$ 并加上扰动项 $\\sigma_n^2 I$。\n    c. 预先计算矩阵向量积 $[K(\\boldsymbol{\\Theta}, \\boldsymbol{\\Theta}) + \\sigma_n^2 I]^{-1} \\mathbf{y}^{\\text{std}}$ 以实现高效的均值预测。\n5.  定义测试用例（数据集 A、B、C），并生成合成观测值 $\\mathbf{y}^{\\mathrm{obs}}$ 及其相关的实验不确定性 $\\boldsymbol{\\sigma}^{\\text{exp}}$。\n6.  创建一个覆盖 $[8,12]\\times[8,12]$ 的 $81 \\times 81$ 的 $\\boldsymbol{\\theta}$ 值网格。\n7.  对于每个数据集：\n    a. 在每个网格点上评估先验概率密度。\n    b. 对每个网格点，使用训练好的 GP 预测 $E$ 和 $R$ 的均值和方差。将这些预测反标准化。\n    c. 使用实验方差和模拟器方差之和，在每个网格点上计算基于模拟器的似然。\n    d. 将先验和似然相乘以获得未归一化的后验权重。\n    e. 使用加权求和公式计算 $g_{\\sigma}$ 的后验均值。\n8.  收集并格式化三个数据集的结果。\n\n这个分步过程提供了一个完整、合理且数值稳定的算法，以解决所述问题。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.spatial.distance import cdist\n\n# --- 1. Problem Definition ---\n\ndef rmf_proxy_model(theta):\n    \"\"\"\n    Computes the RMF proxy model observables E and R.\n    \n    Args:\n        theta (np.ndarray): Array of shape (n, 2) or (2,) with parameters (g_sigma, g_omega).\n        \n    Returns:\n        np.ndarray: Array of shape (n, 2) or (2,) with observables (E, R).\n    \"\"\"\n    if theta.ndim == 1:\n        theta = theta.reshape(1, -1)\n    \n    g_sigma = theta[:, 0]\n    g_omega = theta[:, 1]\n    \n    d = g_sigma - 0.85 * g_omega\n    \n    E = -16.0 + 3.5 * (d - 0.5) + 1.2 * (d - 0.5)**2 \\\n        - 0.15 * (g_sigma - 10.0) * (g_omega - 11.0) \\\n        + 0.02 * (g_sigma - 10.0)**3 - 0.015 * (g_omega - 11.0)**3\n        \n    R = 5.5 + 0.03 * (g_omega - 11.0) - 0.025 * (g_sigma - 10.0) \\\n        + 0.005 * (g_sigma - 10.0)**2 + 0.004 * (g_omega - 11.0)**2 \\\n        - 0.006 * (g_sigma - 10.0) * (g_omega - 11.0) \\\n        + 0.0008 * (g_sigma - 10.0)**3\n        \n    return np.vstack((E, R)).T.squeeze()\n\n# --- 2. Gaussian Process Emulator ---\n\ndef squared_exponential_kernel(x1, x2, length_scale, signal_var):\n    \"\"\"Squared-exponential kernel.\"\"\"\n    sqdist = cdist(x1, x2, 'sqeuclidean')\n    return signal_var * np.exp(-0.5 * sqdist / length_scale**2)\n\nclass GPEmulator:\n    \"\"\"\n    A Gaussian Process emulator with a squared-exponential kernel.\n    Follows the derivation from first principles.\n    \"\"\"\n    def __init__(self, length_scale, signal_var, noise_var):\n        self.ell = length_scale\n        self.sigma_f2 = signal_var\n        self.sigma_n2 = noise_var\n        self.X_train = None\n        self.y_train_std = None\n        self.y_mean = 0.0\n        self.y_std = 1.0\n        self.alpha = None\n        self.K_inv = None\n\n    def fit(self, X_train, y_train):\n        \"\"\"\n        Trains the GP emulator.\n        \n        Args:\n            X_train (np.ndarray): Training inputs of shape (N, D).\n            y_train (np.ndarray): Training outputs of shape (N,).\n        \"\"\"\n        self.X_train = X_train\n        \n        # Standardize training data\n        self.y_mean = np.mean(y_train)\n        self.y_std = np.std(y_train)\n        if self.y_std == 0: self.y_std = 1.0 # Avoid division by zero\n        self.y_train_std = (y_train - self.y_mean) / self.y_std\n        \n        # Pre-compute matrices for prediction\n        K = squared_exponential_kernel(self.X_train, self.X_train, self.ell, self.sigma_f2)\n        K_nn = K + self.sigma_n2 * np.eye(len(self.X_train))\n        \n        # Solve (K + sigma_n^2*I) * alpha = y_train_std\n        # This is more numerically stable than inverting K_nn directly.\n        self.alpha = np.linalg.solve(K_nn, self.y_train_std)\n        self.K_inv = np.linalg.inv(K_nn) # Needed for variance calculation\n\n    def predict(self, X_test):\n        \"\"\"\n        Makes predictions at test points.\n        \n        Args:\n            X_test (np.ndarray): Test inputs of shape (M, D).\n            \n        Returns:\n            tuple: (mean, variance) of predictions, in physical units.\n        \"\"\"\n        if self.X_train is None:\n            raise RuntimeError(\"GP must be fitted before prediction.\")\n\n        k_star = squared_exponential_kernel(self.X_train, X_test, self.ell, self.sigma_f2)\n        \n        # Predictive mean (standardized)\n        mu_star_std = k_star.T @ self.alpha\n        \n        # Predictive variance (standardized)\n        k_star_star = self.sigma_f2 # Diagonal of k(X_test, X_test) is sigma_f^2 = 1\n        # The equation is k_** - k_*^T K_inv k_*. We compute (K_inv @ k_*) first.\n        v = self.K_inv @ k_star\n        var_star_std = k_star_star - np.einsum('ij,ij->j', k_star, v)\n        \n        # De-standardize\n        mu_star_phys = mu_star_std * self.y_std + self.y_mean\n        var_star_phys = var_star_std * self.y_std**2\n        \n        return mu_star_phys, var_star_phys\n\n# --- 3. Main Bayesian Inference Workflow ---\n\ndef solve():\n    \"\"\"\n    Main function to run the entire emulator-based Bayesian inference.\n    \"\"\"\n    # --- Configuration ---\n    N_TRAIN = 80\n    RANDOM_SEED = 13\n    GRID_SIZE = 81\n    \n    # GP Hyperparameters\n    L_SCALE = 1.0\n    SIG_VAR = 1.0\n    NOISE_VAR = 1e-6\n    \n    # Prior definition\n    PRIOR_MEAN = np.array([10.0, 11.0])\n    PRIOR_STD = np.array([0.8, 0.8])\n    \n    # Inference grid\n    param_range = [8.0, 12.0]\n    g_sigma_grid = np.linspace(param_range[0], param_range[1], GRID_SIZE)\n    g_omega_grid = np.linspace(param_range[0], param_range[1], GRID_SIZE)\n    theta_grid_mesh = np.meshgrid(g_sigma_grid, g_omega_grid)\n    theta_grid = np.vstack([theta_grid_mesh[0].ravel(), theta_grid_mesh[1].ravel()]).T\n\n    # --- Training Data Generation ---\n    rng = np.random.default_rng(RANDOM_SEED)\n    theta_train = rng.uniform(param_range[0], param_range[1], size=(N_TRAIN, 2))\n    y_train_raw = rmf_proxy_model(theta_train)\n    \n    # --- Emulator Training ---\n    # Train separate GPs for E and R\n    gp_E = GPEmulator(length_scale=L_SCALE, signal_var=SIG_VAR, noise_var=NOISE_VAR)\n    gp_E.fit(theta_train, y_train_raw[:, 0])\n\n    gp_R = GPEmulator(length_scale=L_SCALE, signal_var=SIG_VAR, noise_var=NOISE_VAR)\n    gp_R.fit(theta_train, y_train_raw[:, 1])\n\n    # --- Test Cases and Inference ---\n    test_cases = [\n        # Dataset A\n        {'theta_obs': np.array([10.2, 10.8]), 'sigma_exp': np.array([0.4, 0.015])},\n        # Dataset B\n        {'theta_obs': np.array([9.0, 11.8]), 'sigma_exp': np.array([0.05, 0.003])},\n        # Dataset C\n        {'theta_obs': np.array([8.1, 12.0]), 'sigma_exp': np.array([0.4, 0.020])},\n    ]\n\n    results = []\n\n    # --- Calculations on the Grid (do once) ---\n    # Emulator predictions\n    mu_E_grid, var_E_emu_grid = gp_E.predict(theta_grid)\n    mu_R_grid, var_R_emu_grid = gp_R.predict(theta_grid)\n    # Prior\n    prior_vals = norm.pdf(theta_grid[:, 0], loc=PRIOR_MEAN[0], scale=PRIOR_STD[0]) * \\\n                 norm.pdf(theta_grid[:, 1], loc=PRIOR_MEAN[1], scale=PRIOR_STD[1])\n\n    for case in test_cases:\n        y_obs = rmf_proxy_model(case['theta_obs'])\n        sigma_exp = case['sigma_exp']\n\n        # Likelihood calculation on the grid\n        total_var_E = sigma_exp[0]**2 + var_E_emu_grid\n        total_var_R = sigma_exp[1]**2 + var_R_emu_grid\n\n        # Ensure variances are non-negative\n        total_var_E[total_var_E  0] = 0\n        total_var_R[total_var_R  0] = 0\n\n        like_E = norm.pdf(y_obs[0], loc=mu_E_grid, scale=np.sqrt(total_var_E))\n        like_R = norm.pdf(y_obs[1], loc=mu_R_grid, scale=np.sqrt(total_var_R))\n        likelihood_vals = like_E * like_R\n\n        # Posterior calculation\n        posterior_weights = likelihood_vals * prior_vals\n        \n        # Numerical integration for expectation\n        # Grid spacing is constant, so it cancels in the ratio\n        numerator = np.sum(theta_grid[:, 0] * posterior_weights)\n        denominator = np.sum(posterior_weights)\n        \n        if denominator == 0:\n            # This can happen if likelihood or prior is zero everywhere on the grid\n            post_mean_g_sigma = np.nan\n        else:\n            post_mean_g_sigma = numerator / denominator\n        \n        results.append(post_mean_g_sigma)\n\n    # --- Final Output Formatting ---\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}