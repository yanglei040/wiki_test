{
    "hands_on_practices": [
        {
            "introduction": "The first step in any large-scale nuclear shell-model calculation is to define the Hilbert space and determine its size. This practice addresses this fundamental task by focusing on the M-scheme basis, where states are defined by the occupation of single-particle orbitals with definite magnetic quantum numbers. By applying basic combinatorial principles, you will derive the dimension of the many-body space for a given number of protons and neutrons, providing a direct and sobering insight into the \"curse of dimensionality\" that defines the challenge of computational nuclear physics .",
            "id": "3575523",
            "problem": "In computational nuclear physics, many-body basis states for shell-model calculations are commonly constructed as Slater determinants in the magnetic quantum number scheme (M-scheme), which enumerates occupation-number configurations of fermions consistent with particle-number conservation. Consider a model space that contains $\\Omega_{p}$ distinct single-proton orbitals and $\\Omega_{n}$ distinct single-neutron orbitals. The many-body Hilbert space is spanned by antisymmetrized products of occupied single-particle states for each species. Assume proton and neutron sectors are independent and that only particle-number constraints are imposed, with $N_p$ protons and $N_n$ neutrons occupying available orbitals. Do not impose any additional symmetry constraints beyond these particle numbers. \n\nStarting from the principles of fermionic antisymmetry and combinatorial occupancy counting, derive a closed-form analytic expression for the dimension $D(\\Omega_{p}, \\Omega_{n}, N_p, N_n)$ of the many-body Hilbert space spanned by such Slater determinants. Then, assume a dense state vector representation in which each basis amplitude is stored as a double precision complex number of $16$ bytes. For the specific case $\\Omega_{p} = 20$, $\\Omega_{n} = 20$, $N_p = 14$, and $N_n = 16$, compute the total memory required to store one normalized state vector in decimal gigabytes, where $1$ gigabyte (GB) $=$ $10^{9}$ bytes. Round your final numeric answer to four significant figures. Express the final answer in gigabytes.",
            "solution": "The total Hilbert space is a tensor product of the independent proton and neutron spaces, so the total dimension $D$ is the product of the dimensions of the proton sector ($D_p$) and the neutron sector ($D_n$).\n\n$$\nD(\\Omega_p, \\Omega_n, N_p, N_n) = D_p \\times D_n\n$$\n\nFor a given species of fermion (e.g., protons), the number of ways to construct an antisymmetric Slater determinant is equivalent to the number of ways to choose which single-particle orbitals are occupied. This is a combinatorial problem. The number of ways to choose $N_p$ orbitals to occupy from a set of $\\Omega_p$ available single-proton orbitals is given by the binomial coefficient $\\binom{\\Omega_p}{N_p}$.\n\n$$\nD_p = \\binom{\\Omega_p}{N_p}\n$$\n\nSimilarly, the dimension of the neutron space is the number of ways to choose $N_n$ orbitals to occupy from a set of $\\Omega_n$ available single-neutron orbitals.\n\n$$\nD_n = \\binom{\\Omega_n}{N_n}\n$$\n\nCombining these gives the final analytic expression for the total dimension of the many-body Hilbert space:\n\n$$\nD(\\Omega_p, \\Omega_n, N_p, N_n) = \\binom{\\Omega_p}{N_p} \\times \\binom{\\Omega_n}{N_n}\n$$\n\nNow, we substitute the given numerical values: $\\Omega_p = 20$, $\\Omega_n = 20$, $N_p = 14$, and $N_n = 16$.\n\nThe dimension of the proton space is:\n$$\nD_p = \\binom{20}{14} = \\frac{20!}{14!(20-14)!} = \\frac{20 \\times 19 \\times 18 \\times 17 \\times 16 \\times 15}{6 \\times 5 \\times 4 \\times 3 \\times 2 \\times 1} = 38,760\n$$\n\nThe dimension of the neutron space is:\n$$\nD_n = \\binom{20}{16} = \\frac{20!}{16!(20-16)!} = \\frac{20 \\times 19 \\times 18 \\times 17}{4 \\times 3 \\times 2 \\times 1} = 4,845\n$$\n\nThe total dimension of the Hilbert space is:\n$$\nD = D_p \\times D_n = 38,760 \\times 4,845 = 187,792,200\n$$\n\nEach basis state's amplitude is stored as a double precision complex number, which requires $16$ bytes. The total memory required to store one state vector is:\n$$\n\\text{Memory (bytes)} = D \\times 16 \\, \\text{bytes} = 187,792,200 \\times 16 = 3,004,675,200 \\, \\text{bytes}\n$$\n\nTo convert this to gigabytes (GB), where $1 \\, \\text{GB} = 10^9 \\, \\text{bytes}$:\n$$\n\\text{Memory (GB)} = \\frac{3,004,675,200}{10^9} = 3.0046752 \\, \\text{GB}\n$$\n\nRounding to four significant figures gives $3.005$ GB.",
            "answer": "$$ \\boxed{3.005} $$"
        },
        {
            "introduction": "Once the scale of the Hilbert space is understood, the next critical task is to implement an efficient scheme for representing and addressing each many-body basis state within a computer program. This computational exercise guides you through designing a bijective, order-preserving mapping from the bitstring representation of a Slater determinant to a unique integer index . Mastering this \"ranking\" and \"unranking\" process is essential for the practical construction of the Hamiltonian matrix and the implementation of fast lookup algorithms.",
            "id": "3575545",
            "problem": "You are modeling a nuclear shell-model many-body basis in which the many-body Hilbert space is constructed from Slater determinants of protons and neutrons occupying fixed single-particle orbitals. Each Slater determinant is represented by two occupancy bitstrings: one for protons and one for neutrons. By Fermi-Dirac antisymmetry, each single-particle orbital can be either unoccupied or occupied, so an occupancy bitstring is a sequence of bits of length equal to the number of single-particle orbitals, with exactly a fixed number of ones equal to the number of particles of that species.\n\nFormally, let the proton space have $\\Omega_p$ single-particle orbitals and the neutron space have $\\Omega_n$ single-particle orbitals. Let $N_p$ be the proton number and $N_n$ be the neutron number, with $0 \\le N_p \\le \\Omega_p$ and $0 \\le N_n \\le \\Omega_n$. A proton basis state is an occupancy bitstring $b^p \\in \\{0,1\\}^{\\Omega_p}$ having exactly $N_p$ ones, and a neutron basis state is $b^n \\in \\{0,1\\}^{\\Omega_n}$ having exactly $N_n$ ones. A full many-body basis state is the ordered pair $(b^p,b^n)$.\n\nDefine the lexicographic order on bitstrings by reading from the leftmost bit to the rightmost bit and comparing at the first position where they differ, with $0 < 1$. Define the lexicographic order on pairs $(b^p,b^n)$ by first comparing the proton bitstrings $b^p$ in lexicographic order, and if they are equal, comparing the neutron bitstrings $b^n$ in lexicographic order.\n\nYour task is to design and implement a bijective mapping from pairs $(b^p,b^n)$ to contiguous integer indices that preserves this lexicographic order and enables fast lookup for Hamiltonian application. The mapping must satisfy all of the following:\n\n- It maps every valid pair $(b^p,b^n)$ to a unique integer index in $\\{0,1,2,\\dots,D-1\\}$, where $D$ is the total number of basis states for the given $\\Omega_p$, $\\Omega_n$, $N_p$, and $N_n$.\n- It preserves the lexicographic order on $(b^p,b^n)$: if $(b^p_1,b^n_1)$ precedes $(b^p_2,b^n_2)$ in the lexicographic order, then the mapped index of $(b^p_1,b^n_1)$ is strictly less than the mapped index of $(b^p_2,b^n_2)$.\n- It provides an inverse mapping from index back to $(b^p,b^n)$.\n- It enables fast lookup suitable for Hamiltonian application, meaning that the time to compute the index or inverse index for a single state scales linearly with the bitstring lengths, i.e., $\\mathcal{O}(\\Omega_p + \\Omega_n)$, using only integer arithmetic and precomputed constants.\n\nFundamental base facts you may use include: fermionic occupation numbers are $0$ or $1$, the number of distinct occupancy configurations of length $\\Omega$ with exactly $K$ ones is given by the binomial coefficient $\\binom{\\Omega}{K}$, and lexicographic order can be characterized by counting prefixes.\n\nYou must produce a complete, runnable program that implements this mapping and its inverse, and then evaluates the following test suite. All bitstrings are given as explicit lists of bits, with the leftmost list element corresponding to the leftmost bit. The required output for each test is a boolean indicating whether the stated condition holds true. No physical units or angles are involved in this problem.\n\nTest suite:\n\n- Test $1$ (happy path, lexicographic order preservation): $\\Omega_p = 6$, $N_p = 3$, $\\Omega_n = 5$, $N_n = 2$. Let $A^p = [0,0,1,1,1,0]$, $A^n = [0,1,0,1,0]$, $B^p = [0,1,0,1,1,0]$, $B^n = [0,0,1,1,0]$. Compute indices for $(A^p,A^n)$ and $(B^p,B^n)$. Output true if and only if the index of $(A^p,A^n)$ is strictly less than the index of $(B^p,B^n)$.\n\n- Test $2$ (round-trip bijection): $\\Omega_p = 6$, $N_p = 3$, $\\Omega_n = 5$, $N_n = 2$. Let $C^p = [1,0,1,0,1,0]$, $C^n = [0,1,1,0,0]$. Map $(C^p,C^n)$ to an index and then map that index back to a pair. Output true if and only if the recovered pair equals the original pair.\n\n- Test $3$ (boundary case with zero particles): $\\Omega_p = 4$, $N_p = 0$, $\\Omega_n = 3$, $N_n = 0$. Let $Z^p = [0,0,0,0]$, $Z^n = [0,0,0]$. Map $(Z^p,Z^n)$ to an index. Output true if and only if the index equals $0$.\n\n- Test $4$ (boundary case with full occupancy): $\\Omega_p = 5$, $N_p = 5$, $\\Omega_n = 4$, $N_n = 4$. Let $F^p = [1,1,1,1,1]$, $F^n = [1,1,1,1]$. Let $D$ be the total number of basis states for these parameters. Map $(F^p,F^n)$ to an index. Output true if and only if the index equals $D - 1$.\n\n- Test $5$ (fast lookup under a one-body move for Hamiltonian application): $\\Omega_p = 6$, $N_p = 3$, $\\Omega_n = 5$, $N_n = 2$. Let $D^p = [0,1,0,1,0,1]$, $D^n = [1,0,0,1,0]$. Apply a proton one-body move that takes the occupied orbital at position $i=1$ to the unoccupied orbital at position $j=2$, producing $D^{p'} = [0,0,1,1,0,1]$ while leaving $D^n$ unchanged. Compute the index of $(D^p,D^n)$ and of $(D^{p'},D^n)$ using your mapping. Also construct a hash mapping from the integer-packed representation of the bitstrings to indices, and use it to retrieve the index of $(D^{p'},D^n)$. Output true if and only if both methods yield the same index for $(D^{p'},D^n)$.\n\n- Test $6$ (adjacent neutron configurations within a fixed proton configuration): $\\Omega_p = 5$, $N_p = 2$, $\\Omega_n = 5$, $N_n = 3$. Let the proton configuration be fixed as $P^p = [0,1,0,0,1]$. Let $A^n = [0,0,1,1,1]$ and $B^n = [0,1,0,1,1]$. Compute indices for $(P^p,A^n)$ and $(P^p,B^n)$. Output true if and only if the index of $(P^p,B^n)$ equals the index of $(P^p,A^n)$ plus $1$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[true,true,true,true,true,true]\"). All boolean values must be printed using the programming language's native boolean literals.",
            "solution": "The user-provided problem statement has been analyzed and is determined to be **valid**. It is scientifically sound, well-posed, and objective, presenting a standard problem in computational many-body physics. The task is to create a bijective, order-preserving mapping from a basis of nuclear shell-model states to a contiguous set of integers, along with its inverse.\n\n### Principle-Based Design\n\nThe core of the problem is constructing a mapping, often called a \"ranking\" function, for combinations that preserves lexicographical order. The many-body basis states are ordered pairs of bitstrings $(b^p, b^n)$, and their overall lexicographical ordering suggests a row-major indexing scheme. The total index can be expressed as a function of the individual indices of the proton and neutron bitstrings.\n\n#### 1. Mapping a Single Bitstring to an Index (Ranking)\n\nLet's first consider the mapping for a single species, for instance, mapping a proton bitstring $b^p$ of length $\\Omega_p$ with $N_p$ ones to an integer index. The total number of such distinct bitstrings is $D_p = \\binom{\\Omega_p}{N_p}$. The goal is to find a function $\\mathcal{M}_{\\text{lex}}(b^p) \\to \\{0, 1, \\dots, D_p-1\\}$ that is bijective and preserves lexicographical order.\n\nThe index of a bitstring $b$ in lexicographical order is precisely the count of valid bitstrings that are lexicographically smaller than $b$. We can determine this count by iterating through the bitstring from left to right.\n\nLet the bitstring be $b = (b_0, b_1, \\dots, b_{\\Omega-1})$ of length $\\Omega$ with $K$ ones. The rank is built by summing the number of combinations that are \"skipped over\" at each position. The number of combinations is given by binomial coefficients, $\\binom{n}{k}$, which we can precompute and store in a lookup table for efficiency.\n\nThe mapping algorithm proceeds as follows:\nInitialize the rank to $0$, the number of ones to place to $k=K$, and the number of available positions to $\\omega=\\Omega$. Iterate from left to right (position $i=0$ to $\\Omega-1$):\n1. Decrement the number of available positions, $\\omega \\leftarrow \\omega - 1$.\n2. Examine the bit $b_i$.\n   - If $b_i=0$: The string falls within the block of combinations that start with the current prefix followed by a $0$. These are all lexicographically smaller than combinations starting with a $1$ at this position. We do not add to the rank and continue to the next bit. The number of ones yet to be placed, $k$, remains unchanged.\n   - If $b_i=1$: The string is lexicographically larger than all valid combinations that have a $0$ at position $i$ (given the same prefix). The number of such smaller combinations must be added to our rank. If we were to place a $0$ at position $i$, we would need to place the remaining $k$ ones in the remaining $\\omega$ positions. The number of ways to do this is $\\binom{\\omega}{k}$. We add this value to the rank. Since we have now placed a $1$, we decrement the number of ones remaining to be placed, $k \\leftarrow k - 1$.\n\nThis process uniquely determines the lexicographical rank of any given bitstring. For a bitstring $b = (b_i)_{i=0}^{\\Omega-1}$ with $K$ ones, the index is:\n$$\n\\text{Index}(b) = \\sum_{i=0}^{\\Omega-1} b_i \\cdot \\binom{\\Omega-1-i}{K - \\sum_{j=0}^{i-1} b_j}\n$$\nThis iterative formulation is efficient and relies only on integer arithmetic and the precomputed table of binomial coefficients, achieving the required $\\mathcal{O}(\\Omega)$ complexity.\n\n#### 2. Mapping an Index to a Bitstring (Unranking)\n\nThe inverse mapping, or unranking, reconstructs the bitstring from its lexicographical index. Given a rank $I \\in \\{0, 1, \\dots, \\binom{\\Omega}{K}-1\\}$, we determine the bits of the string $b$ one by one from left to right.\n\nAt each position $i=0, \\dots, \\Omega-1$:\n1. We determine whether $b_i$ should be $0$ or $1$.\n2. Consider a hypothetical bit $b_i=0$. The number of possible valid completions of the bitstring (placing the remaining $k$ ones in the remaining $\\omega$ positions) is $\\binom{\\omega}{k}$.\n3. Compare the current rank $I$ with this count.\n   - If $I < \\binom{\\omega}{k}$: The target bitstring lies within this block of combinations. Therefore, $b_i$ must be $0$. We set $b_i=0$ and proceed to the next position. The rank $I$ and remaining ones $k$ are unchanged.\n   - If $I \\ge \\binom{\\omega}{k}$: The target bitstring is lexicographically larger than all combinations with a $0$ at this position. Therefore, $b_i$ must be $1$. We set $b_i=1$, subtract $\\binom{\\omega}{k}$ from the rank ($I \\leftarrow I - \\binom{\\omega}{k}$), and decrement the count of ones to be placed ($k \\leftarrow k-1$).\n4. We repeat this for all positions to construct the full bitstring. This is also an $\\mathcal{O}(\\Omega)$ process.\n\n#### 3. Combining Proton and Neutron Spaces\n\nThe basis states are ordered pairs $(b^p, b^n)$. The lexicographical order on these pairs is defined by first comparing $b^p$, and only if they are identical, comparing $b^n$. This corresponds to a row-major layout of a 2D matrix where rows are indexed by proton states and columns by neutron states.\n\nLet $\\mathcal{M}_p(b^p)$ be the rank of the proton state $b^p$ in its space of size $D_p = \\binom{\\Omega_p}{N_p}$, and $\\mathcal{M}_n(b^n)$ be the rank of the neutron state $b^n$ in its space of size $D_n = \\binom{\\Omega_n}{N_n}$. The total index $I$ for the pair $(b^p, b^n)$ is given by:\n$$\nI(b^p, b^n) = \\mathcal{M}_p(b^p) \\cdot D_n + \\mathcal{M}_n(b^n)\n$$\nThe total dimension of the basis is $D = D_p \\cdot D_n$.\n\nThe inverse mapping from a total index $I$ to a pair $(b^p, b^n)$ is found using integer division and modulo operations:\n$$\n\\mathcal{M}_p = I \\ // \\ D_n\n$$\n$$\n\\mathcal{M}_n = I \\ \\% \\ D_n\n$$\nThe individual bitstrings $b^p$ and $b^n$ are then reconstructed from their respective ranks, $\\mathcal{M}_p$ and $\\mathcal{M}_n$, using the single-species unranking algorithm described above. Both the forward and inverse mappings for the combined system have a time complexity of $\\mathcal{O}(\\Omega_p + \\Omega_n)$, satisfying all problem requirements.",
            "answer": "```python\nimport numpy as np\n\nclass NuclearBasisMapper:\n    \"\"\"\n    Manages the mapping between nuclear many-body basis states (represented by\n    proton and neutron occupancy bitstrings) and unique integer indices.\n\n    The mapping preserves lexicographical order and is designed for fast\n    computation, suitable for constructing and applying Hamiltonians in\n    shell-model calculations.\n    \"\"\"\n    _C = None\n    _MAX_OMEGA = 0\n\n    def __init__(self, omega_p, n_p, omega_n, n_n):\n        \"\"\"\n        Initializes the mapper for a given nuclear system.\n\n        Args:\n            omega_p (int): Number of single-particle orbitals for protons.\n            n_p (int): Number of protons.\n            omega_n (int): Number of single-particle orbitals for neutrons.\n            n_n (int): Number of neutrons.\n        \"\"\"\n        self.omega_p = omega_p\n        self.n_p = n_p\n        self.omega_n = omega_n\n        self.n_n = n_n\n\n        max_omega_needed = max(omega_p, omega_n, 0)\n        self._precompute_binom(max_omega_needed)\n        \n        # Guard against invalid parameters (e.g., more particles than orbitals)\n        if not (0 = self.n_p = self.omega_p and 0 = self.n_n = self.omega_n):\n             self.dim_p = 0\n             self.dim_n = 0\n        else:\n             self.dim_p = self._C[self.omega_p, self.n_p]\n             self.dim_n = self._C[self.omega_n, self.n_n]\n\n        self.total_dim = self.dim_p * self.dim_n\n\n    @classmethod\n    def _precompute_binom(cls, max_val):\n        \"\"\"Precomputes binomial coefficients up to max_val.\"\"\"\n        if max_val = cls._MAX_OMEGA:\n            return\n        \n        cls._MAX_OMEGA = max_val\n        c = np.zeros((max_val + 1, max_val + 1), dtype=np.int64)\n        for i in range(max_val + 1):\n            c[i, 0] = 1\n            for j in range(1, i + 1):\n                c[i, j] = c[i - 1, j - 1] + c[i - 1, j]\n        cls._C = c\n\n    def _get_rank_lex(self, b_list, omega, k):\n        \"\"\"Calculates the lexicographical rank of a single bitstring.\"\"\"\n        if k  0 or k > omega:\n            raise ValueError(f\"Number of particles {k} must be in [0, {omega}]\")\n\n        rank = 0\n        rem_k = k\n        rem_omega = omega\n        for bit in b_list:\n            rem_omega -= 1\n            if rem_k == 0:\n                break\n            \n            if bit == 1:\n                # This bit is 1, so we skip all combinations where this bit is 0.\n                # The number of such combinations is the number of ways to place\n                # the remaining rem_k particles in the remaining rem_omega slots.\n                if rem_omega >= rem_k:\n                    rank += self._C[rem_omega, rem_k]\n                rem_k -= 1\n        return rank\n\n    def _get_state_from_lex_rank(self, rank, omega, k):\n        \"\"\"Reconstructs a bitstring from its lexicographical rank.\"\"\"\n        if k  0 or k > omega:\n            raise ValueError(f\"Number of particles {k} must be in [0, {omega}]\")\n\n        b = []\n        rem_k = k\n        current_rank = rank\n        \n        for i in range(omega):\n            rem_omega_suffix = omega - 1 - i\n            \n            # Optimization: if all remaining must be 1s or 0s\n            if rem_k == rem_omega_suffix + 1:\n                b.extend([1] * rem_k)\n                break\n            if rem_k == 0:\n                b.extend([0] * (rem_omega_suffix + 1))\n                break\n\n            # Number of combinations if we choose 0 at this position\n            comb_with_zero = self._C[rem_omega_suffix, rem_k]\n            \n            if current_rank  comb_with_zero:\n                b.append(0)\n            else:\n                b.append(1)\n                current_rank -= comb_with_zero\n                rem_k -= 1\n        return b\n\n    def get_index(self, b_p, b_n):\n        \"\"\"Computes the total index for a given proton-neutron state pair.\"\"\"\n        idx_p = self._get_rank_lex(b_p, self.omega_p, self.n_p)\n        idx_n = self._get_rank_lex(b_n, self.omega_n, self.n_n)\n        return idx_p * self.dim_n + idx_n\n\n    def get_state(self, total_idx):\n        \"\"\"Recovers the proton-neutron state pair from a total index.\"\"\"\n        if total_idx >= self.total_dim:\n            raise ValueError(\"Total index is out of bounds.\")\n            \n        idx_p = total_idx // self.dim_n\n        idx_n = total_idx % self.dim_n\n        \n        b_p = self._get_state_from_lex_rank(idx_p, self.omega_p, self.n_p)\n        b_n = self._get_state_from_lex_rank(idx_n, self.omega_n, self.n_n)\n        return (b_p, b_n)\n\ndef solve():\n    \"\"\"Runs the test suite specified in the problem statement.\"\"\"\n    \n    test_cases_params = [\n        (6, 3, 5, 2),  # Test 1\n        (6, 3, 5, 2),  # Test 2\n        (4, 0, 3, 0),  # Test 3\n        (5, 5, 4, 4),  # Test 4\n        (6, 3, 5, 2),  # Test 5\n        (5, 2, 5, 3),  # Test 6\n    ]\n\n    results = []\n\n    # Test 1: Lexicographic order preservation\n    omega_p, n_p, omega_n, n_n = test_cases_params[0]\n    mapper1 = NuclearBasisMapper(omega_p, n_p, omega_n, n_n)\n    a_p, a_n = [0,0,1,1,1,0], [0,1,0,1,0]\n    b_p, b_n = [0,1,0,1,1,0], [0,0,1,1,0]\n    idx_A = mapper1.get_index(a_p, a_n)\n    idx_B = mapper1.get_index(b_p, b_n)\n    results.append(idx_A  idx_B)\n\n    # Test 2: Round-trip bijection\n    omega_p, n_p, omega_n, n_n = test_cases_params[1]\n    mapper2 = NuclearBasisMapper(omega_p, n_p, omega_n, n_n)\n    c_p, c_n = [1,0,1,0,1,0], [0,1,1,0,0]\n    idx_C = mapper2.get_index(c_p, c_n)\n    rec_p, rec_n = mapper2.get_state(idx_C)\n    results.append(c_p == rec_p and c_n == rec_n)\n\n    # Test 3: Boundary case with zero particles\n    omega_p, n_p, omega_n, n_n = test_cases_params[2]\n    mapper3 = NuclearBasisMapper(omega_p, n_p, omega_n, n_n)\n    z_p, z_n = [0,0,0,0], [0,0,0]\n    idx_Z = mapper3.get_index(z_p, z_n)\n    results.append(idx_Z == 0)\n\n    # Test 4: Boundary case with full occupancy\n    omega_p, n_p, omega_n, n_n = test_cases_params[3]\n    mapper4 = NuclearBasisMapper(omega_p, n_p, omega_n, n_n)\n    f_p, f_n = [1,1,1,1,1], [1,1,1,1]\n    idx_F = mapper4.get_index(f_p, f_n)\n    D = mapper4.total_dim\n    results.append(idx_F == D - 1)\n\n    # Test 5: Fast lookup under a one-body move\n    omega_p, n_p, omega_n, n_n = test_cases_params[4]\n    mapper5 = NuclearBasisMapper(omega_p, n_p, omega_n, n_n)\n    d_p, d_n = [0,1,0,1,0,1], [1,0,0,1,0]\n    d_p_prime = [0,0,1,1,0,1]\n    idx1 = mapper5.get_index(d_p_prime, d_n)\n    \n    # Simulate a hash map lookup as described\n    int_p_prime = int(\"\".join(map(str, d_p_prime)), 2)\n    int_n = int(\"\".join(map(str, d_n)), 2)\n    key = (int_p_prime, int_n)\n    hash_map = {key: idx1}\n    idx2 = hash_map[key]\n    results.append(idx1 == idx2)\n\n    # Test 6: Adjacent neutron configurations\n    omega_p, n_p, omega_n, n_n = test_cases_params[5]\n    mapper6 = NuclearBasisMapper(omega_p, n_p, omega_n, n_n)\n    p_p = [0,1,0,0,1]\n    a_n, b_n = [0,0,1,1,1], [0,1,0,1,1] # These are adjacent in lex order\n    idx_A_pair = mapper6.get_index(p_p, a_n)\n    idx_B_pair = mapper6.get_index(p_p, b_n)\n    results.append(idx_B_pair == idx_A_pair + 1)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Advanced nuclear models often begin with a mean-field approach that may break fundamental symmetries of the nucleus, such as rotational invariance or reflection symmetry (parity). This practice delves into the crucial technique of symmetry restoration, specifically for parity, which is vital for describing reflection-asymmetric or \"pear-shaped\" nuclei . Starting from a mixed-parity single-particle basis, you will use projection operators to construct many-body states with good parity, a powerful method that bridges the gap between simplified mean-field descriptions and physically observable states.",
            "id": "3575598",
            "problem": "In a reflection-asymmetric mean-field description of a nucleus, the parity operator $\\Pi$ does not commute with the mean-field Hamiltonian, and single-particle eigenstates are mixtures of opposite-parity components. Let $\\{|u_{i}^{+}\\rangle\\}_{i=1}^{M}$ and $\\{|v_{i}^{-}\\rangle\\}_{i=1}^{M}$ denote two orthonormal sets of single-particle states with definite parity, satisfying $\\Pi|u_{i}^{+}\\rangle=+|u_{i}^{+}\\rangle$ and $\\Pi|v_{i}^{-}\\rangle=-|v_{i}^{-}\\rangle$, and $\\langle u_{i}^{+}|u_{j}^{+}\\rangle=\\delta_{ij}$, $\\langle v_{i}^{-}|v_{j}^{-}\\rangle=\\delta_{ij}$, and $\\langle u_{i}^{+}|v_{j}^{-}\\rangle=0$. A deformed mean-field single-particle state is then parameterized as\n$$\n|\\phi_{i}\\rangle=\\cos\\theta_{i}\\,|u_{i}^{+}\\rangle+\\sin\\theta_{i}\\,|v_{i}^{-}\\rangle,\n$$\nwith $0\\leq\\theta_{i}\\leq\\frac{\\pi}{2}$.\n\nUsing the fundamental properties of the parity operator $\\Pi$ and the projection operators $P_{\\pm}=\\frac{1\\pm\\Pi}{2}$, construct a parity-projected single-particle basis from $\\{|\\phi_{i}\\rangle\\}$. Then, within Second Quantization (SQ), let $c_{u_{i}^{+}}^{\\dagger}$ and $c_{v_{i}^{-}}^{\\dagger}$ denote creation operators for $|u_{i}^{+}\\rangle$ and $|v_{i}^{-}\\rangle$, respectively, and define the mixed-parity creation operator\n$$\na_{i}^{\\dagger}=\\cos\\theta_{i}\\,c_{u_{i}^{+}}^{\\dagger}+\\sin\\theta_{i}\\,c_{v_{i}^{-}}^{\\dagger},\n$$\nacting on the particle vacuum $|0\\rangle$. Consider the two-fermion antisymmetric Slater state\n$$\n|\\Phi_{12}\\rangle=a_{1}^{\\dagger}a_{2}^{\\dagger}|0\\rangle,\n$$\nand the two-body parity operator $\\Pi^{(2)}=\\Pi_{1}\\Pi_{2}$ acting multiplicatively on the two-particle sector. Form the positive-parity projected two-body state $|\\Phi_{12}^{(+)}\\rangle=P_{+}^{(2)}|\\Phi_{12}\\rangle$ with $P_{+}^{(2)}=\\frac{1+\\Pi^{(2)}}{2}$, and derive its explicit expansion in the orthonormal Slater basis generated by $\\{c_{u_{i}^{+}}^{\\dagger},c_{v_{i}^{-}}^{\\dagger}\\}$.\n\nFinally, determine the normalization factor $N_{+}$ such that the normalized positive-parity two-body state $|\\Psi_{12}^{(+)}\\rangle=N_{+}|\\Phi_{12}^{(+)}\\rangle$ satisfies $\\langle\\Psi_{12}^{(+)}|\\Psi_{12}^{(+)}\\rangle=1$. Express your final answer for $N_{+}$ as a closed-form analytic expression in terms of $\\theta_{1}$ and $\\theta_{2}$. No numerical evaluation is required, and no units are involved.",
            "solution": "The problem requires the construction of a parity-projected two-body state from a reflection-asymmetric mean-field description and the determination of its normalization constant.\n\nFirst, we derive the expansion of the positive-parity projected two-body state $|\\Phi_{12}^{(+)}\\rangle$. We begin by expanding the unprojected state $|\\Phi_{12}\\rangle=a_{1}^{\\dagger}a_{2}^{\\dagger}|0\\rangle$.\nThe mixed-parity creation operators are:\n$$a_{1}^{\\dagger} = \\cos\\theta_{1}\\,c_{u_{1}^{+}}^{\\dagger}+\\sin\\theta_{1}\\,c_{v_{1}^{-}}^{\\dagger}$$\n$$a_{2}^{\\dagger} = \\cos\\theta_{2}\\,c_{u_{2}^{+}}^{\\dagger}+\\sin\\theta_{2}\\,c_{v_{2}^{-}}^{\\dagger}$$\nSince the operators correspond to four distinct, orthogonal single-particle states ($i=1,2$), they anticommute. The unprojected two-body state is:\n$$|\\Phi_{12}\\rangle = (\\cos\\theta_{1}\\,c_{u_{1}^{+}}^{\\dagger}+\\sin\\theta_{1}\\,c_{v_{1}^{-}}^{\\dagger})(\\cos\\theta_{2}\\,c_{u_{2}^{+}}^{\\dagger}+\\sin\\theta_{2}\\,c_{v_{2}^{-}}^{\\dagger})|0\\rangle$$\nExpanding this product gives four terms:\n$$|\\Phi_{12}\\rangle = (\\cos\\theta_{1}\\cos\\theta_{2}\\,c_{u_{1}^{+}}^{\\dagger}c_{u_{2}^{+}}^{\\dagger} + \\cos\\theta_{1}\\sin\\theta_{2}\\,c_{u_{1}^{+}}^{\\dagger}c_{v_{2}^{-}}^{\\dagger} + \\sin\\theta_{1}\\cos\\theta_{2}\\,c_{v_{1}^{-}}^{\\dagger}c_{u_{2}^{+}}^{\\dagger} + \\sin\\theta_{1}\\sin\\theta_{2}\\,c_{v_{1}^{-}}^{\\dagger}c_{v_{2}^{-}}^{\\dagger})|0\\rangle$$\nLet us denote the orthonormal two-body Slater basis states as $|k_{1}k_{2}\\rangle = c_{k_{1}}^{\\dagger}c_{k_{2}}^{\\dagger}|0\\rangle$. The expansion is:\n$$|\\Phi_{12}\\rangle = \\cos\\theta_{1}\\cos\\theta_{2}\\,|u_{1}^{+}u_{2}^{+}\\rangle + \\cos\\theta_{1}\\sin\\theta_{2}\\,|u_{1}^{+}v_{2}^{-}\\rangle + \\sin\\theta_{1}\\cos\\theta_{2}\\,|v_{1}^{-}u_{2}^{+}\\rangle + \\sin\\theta_{1}\\sin\\theta_{2}\\,|v_{1}^{-}v_{2}^{-}\\rangle$$\nThe two-body parity operator $\\Pi^{(2)}$ acts on these basis states according to the product of the parities of the constituent single-particle states. A state $|k_{1}k_{2}\\rangle$ with constituent parities $p_1$ and $p_2$ has total parity $p_{1}p_{2}$.\n- $\\Pi^{(2)}|u_{1}^{+}u_{2}^{+}\\rangle = (+1)(+1)|u_{1}^{+}u_{2}^{+}\\rangle = +|u_{1}^{+}u_{2}^{+}\\rangle$ (positive parity)\n- $\\Pi^{(2)}|u_{1}^{+}v_{2}^{-}\\rangle = (+1)(-1)|u_{1}^{+}v_{2}^{-}\\rangle = -|u_{1}^{+}v_{2}^{-}\\rangle$ (negative parity)\n- $\\Pi^{(2)}|v_{1}^{-}u_{2}^{+}\\rangle = (-1)(+1)|v_{1}^{-}u_{2}^{+}\\rangle = -|v_{1}^{-}u_{2}^{+}\\rangle$ (negative parity)\n- $\\Pi^{(2)}|v_{1}^{-}v_{2}^{-}\\rangle = (-1)(-1)|v_{1}^{-}v_{2}^{-}\\rangle = +|v_{1}^{-}v_{2}^{-}\\rangle$ (positive parity)\n\nNow, we apply the positive-parity projector $P_{+}^{(2)}=\\frac{1+\\Pi^{(2)}}{2}$. The projector annihilates the negative-parity components and acts as the identity on the positive-parity components.\n$$P_{+}^{(2)}|u_{1}^{+}v_{2}^{-}\\rangle = \\frac{1-1}{2}|u_{1}^{+}v_{2}^{-}\\rangle = 0$$\n$$P_{+}^{(2)}|u_{1}^{+}u_{2}^{+}\\rangle = \\frac{1+1}{2}|u_{1}^{+}u_{2}^{+}\\rangle = |u_{1}^{+}u_{2}^{+}\\rangle$$\nApplying the projector to the full state $|\\Phi_{12}\\rangle$ filters out the terms with negative parity:\n$$|\\Phi_{12}^{(+)}\\rangle = P_{+}^{(2)}|\\Phi_{12}\\rangle = \\cos\\theta_{1}\\cos\\theta_{2}\\,|u_{1}^{+}u_{2}^{+}\\rangle + \\sin\\theta_{1}\\sin\\theta_{2}\\,|v_{1}^{-}v_{2}^{-}\\rangle$$\nThis is the explicit expansion of the unnormalized projected state.\n\nFinally, we determine the normalization factor $N_{+}$ from the condition $\\langle\\Psi_{12}^{(+)}|\\Psi_{12}^{(+)}\\rangle=1$, which implies $N_{+}^{-2} = \\langle\\Phi_{12}^{(+)}|\\Phi_{12}^{(+)}\\rangle$. We compute the norm-squared of $|\\Phi_{12}^{(+)}\\rangle$:\n$$\\langle\\Phi_{12}^{(+)}|\\Phi_{12}^{(+)}\\rangle = \\langle(\\cos\\theta_{1}\\cos\\theta_{2}\\,\\langle u_{1}^{+}u_{2}^{+}| + \\sin\\theta_{1}\\sin\\theta_{2}\\,\\langle v_{1}^{-}v_{2}^{-}|) | (\\cos\\theta_{1}\\cos\\theta_{2}\\,|u_{1}^{+}u_{2}^{+}\\rangle + \\sin\\theta_{1}\\sin\\theta_{2}\\,|v_{1}^{-}v_{2}^{-}\\rangle)\\rangle$$\nThe basis states $|u_{1}^{+}u_{2}^{+}\\rangle$ and $|v_{1}^{-}v_{2}^{-}\\rangle$ are orthonormal because they are constructed from four distinct orthonormal single-particle states. Therefore, $\\langle u_{1}^{+}u_{2}^{+}|u_{1}^{+}u_{2}^{+}\\rangle=1$, $\\langle v_{1}^{-}v_{2}^{-}|v_{1}^{-}v_{2}^{-}\\rangle=1$, and the cross-term $\\langle u_{1}^{+}u_{2}^{+}|v_{1}^{-}v_{2}^{-}\\rangle=0$. The inner product simplifies to:\n$$\\langle\\Phi_{12}^{(+)}|\\Phi_{12}^{(+)}\\rangle = (\\cos\\theta_{1}\\cos\\theta_{2})^{2}\\langle u_{1}^{+}u_{2}^{+}|u_{1}^{+}u_{2}^{+}\\rangle + (\\sin\\theta_{1}\\sin\\theta_{2})^{2}\\langle v_{1}^{-}v_{2}^{-}|v_{1}^{-}v_{2}^{-}\\rangle$$\n$$\\langle\\Phi_{12}^{(+)}|\\Phi_{12}^{(+)}\\rangle = \\cos^{2}\\theta_{1}\\cos^{2}\\theta_{2} + \\sin^{2}\\theta_{1}\\sin^{2}\\theta_{2}$$\nThe normalization factor $N_{+}$ is the reciprocal of the square root of this quantity (assuming $N_{+}$ is real and positive):\n$$N_{+} = \\frac{1}{\\sqrt{\\cos^{2}\\theta_{1}\\cos^{2}\\theta_{2} + \\sin^{2}\\theta_{1}\\sin^{2}\\theta_{2}}}$$\nThis is the required closed-form analytic result for the normalization factor.",
            "answer": "$$\n\\boxed{\\frac{1}{\\sqrt{\\cos^{2}\\theta_{1}\\cos^{2}\\theta_{2} + \\sin^{2}\\theta_{1}\\sin^{2}\\theta_{2}}}}\n$$"
        }
    ]
}