{
    "hands_on_practices": [
        {
            "introduction": "这个练习将带你深入J方案表示的核心。通过从单粒子态构建多体态，你将亲手实践如何将粒子对耦合到确定的总角动量$J$。这个过程将凸显反对称化在处理相同费米子时的关键作用，并自然地引出角动量重耦合系数（如维格纳9j符号）的使用。完成这个练习将加深你对J方案基矢构建及其底层数学结构的理解。",
            "id": "3602884",
            "problem": "考虑四个相同的核子，它们被限制在总单粒子角动量为 $j \\geq \\frac{5}{2}$ 的单个轨道上，因此总角动量 $J=0$ 的子空间维数为二（seniority数 $v=0$ 和 $v=4$）。在总角动量耦合表象（$J$方案）中进行计算。定义归一化的双费米子对产生算符\n$$\nA^{\\dagger}_{J M} \\equiv \\frac{1}{\\sqrt{2}} \\sum_{m_{1},m_{2}} \\langle j m_{1}\\, j m_{2} \\mid J M \\rangle\\, a^{\\dagger}_{j m_{1}} a^{\\dagger}_{j m_{2}},\n$$\n并通过将两个相同的对耦合到总 $J=0$ 来构建反对称化的四费米子态，\n$$\n\\lvert \\Phi_{J_{p}} \\rangle \\equiv \\bigl[ A^{\\dagger}_{J_{p}} \\times A^{\\dagger}_{J_{p}} \\bigr]_{00} \\lvert 0 \\rangle,\n$$\n其中对角动量为偶数 $J_{p} \\in \\{0,2\\}$，$[\\,\\cdot \\times \\cdot\\,]_{00}$ 表示耦合到总 $J=0, M=0$，而 $\\lvert 0 \\rangle$ 是粒子真空。\n\n(a) 从角动量耦合代数和费米子反对易关系出发，推导交叠矩阵元 $\\langle \\Phi_{J_{p}'} \\mid \\Phi_{J_{p}} \\rangle$ 的一般表达式，用一个重耦合系数表示，并通过一个依赖于 $j$、$J_{p}$、$J_{p}'$ 和总 $J=0$ 的 Wigner $9j$ 符号来表示交换（非正交性）贡献。\n\n(b) 使用(a)部分的结果论证两个态 $\\{ \\lvert \\Phi_{0} \\rangle, \\lvert \\Phi_{2} \\rangle \\}$ 张成 $J=0$ 的四粒子子空间（在此扇区内是完备的），并且可以通过一个 $2\\times 2$ 的 Gram-Schmidt 变换进行正交归一化。提供保证 Gram 矩阵正定性的交叠显式条件。\n\n(c) 提供非对角交叠元 $\\langle \\Phi_{0} \\mid \\Phi_{2} \\rangle$ 作为 $j$ 的函数的闭合形式解析表达式，用单个 Wigner $9j$ 符号表示。你的最终答案必须是单个闭合形式的解析表达式。不需要进行数值计算，也不需要进行舍入。",
            "solution": "该问题要求分析单 $j$ 壳层中的四粒子态，这些态是通过耦合相同的核子对来构建的。我们必须首先验证问题陈述。\n\n### 第1步：提取已知条件\n- **系统**：四个相同的核子位于单粒子角动量为 $j$ 的单个轨道中。\n- **约束**：$j \\geq \\frac{5}{2}$。\n- **子空间**：总角动量 $J=0$ 的子空间是二维的，由seniority数 $v=0$ 和 $v=4$ 的态张成。\n- **对产生算符**：$A^{\\dagger}_{J M} \\equiv \\frac{1}{\\sqrt{2}} \\sum_{m_{1},m_{2}} \\langle j m_{1}\\, j m_{2} \\mid J M \\rangle\\, a^{\\dagger}_{j m_{1}} a^{\\dagger}_{j m_{2}}$。对于相同的费米子，这仅对偶数 $J$ 非零。\n- **四粒子态**：$\\lvert \\Phi_{J_{p}} \\rangle \\equiv \\bigl[ A^{\\dagger}_{J_{p}} \\times A^{\\dagger}_{J_{p}} \\bigr]_{00} \\lvert 0 \\rangle$，其中 $J_{p} \\in \\{0,2\\}$ 是相同对的角动量。符号 $[\\,\\cdot \\times \\cdot\\,]_{00}$ 表示耦合到总角动量 $J=0, M=0$。\n- **真空**：$\\lvert 0 \\rangle$ 是粒子真空。\n- **(a)部分**：推导交叠 $\\langle \\Phi_{J_{p}'} \\mid \\Phi_{J_{p}} \\rangle$ 的一般表达式，其中交换贡献通过 Wigner $9j$ 符号表示。\n- **(b)部分**：论证 $\\{\\lvert \\Phi_{0} \\rangle, \\lvert \\Phi_{2} \\rangle\\}$ 张成 $J=0$ 子空间并且可以被正交归一化，并提供此条件的判据。\n- **(c)部分**：提供 $\\langle \\Phi_{0} \\mid \\Phi_{2} \\rangle$ 的闭合形式表达式，用单个 Wigner $9j$ 符号表示。\n\n### 第2步：使用提取的已知条件进行验证\n该问题在科学上基于原子核壳模型和量子力学中的角动量理论。算符和态的定义在该领域是标准的。约束 $j \\geq \\frac{5}{2}$ 是合适的，因为对于更小的 $j$ 值，四粒子 $J=0$ 空间的结构是不同的（例如，对于 $j=3/2$，只有一个 $J=0$ 态）。该问题是适定的、客观的，并包含足够的信息以获得严谨的解。不存在科学缺陷、矛盾或歧义。\n\n### 第3步：结论与行动\n问题有效。将提供完整的解答。\n\n### (a) 交叠矩阵元的推导\n\n态 $\\lvert \\Phi_{J_p} \\rangle$ 是通过将两个相同的费米子对（每个对的角动量为 $J_p$）耦合到总角动量 $J=0$ 来构建的。具体来说，\n$$\n\\lvert \\Phi_{J_p} \\rangle = \\sum_{M_p} \\langle J_p M_p J_p (-M_p) \\mid 00 \\rangle A^{\\dagger}_{J_p M_p} A^{\\dagger}_{J_p, -M_p} \\lvert 0 \\rangle = \\frac{1}{\\sqrt{2J_p+1}} \\sum_{M_p} (-1)^{J_p-M_p} A^{\\dagger}_{J_p M_p} A^{\\dagger}_{J_p, -M_p} \\lvert 0 \\rangle.\n$$\n这些态是未归一化的。交叠矩阵元为 $\\langle \\Phi_{J_p'} \\mid \\Phi_{J_p} \\rangle$。这些态表示四粒子态，但表达式没有显式地体现不同对中粒子之间的完全反对称性。一个完整的计算涉及考虑对之间的粒子交换，这在“直接”项之外引入了一个“重耦合”项。直接项源于将对算符当作玻色子处理，而交换项则校正了它们的费米子子结构。\n\n对于这些未归一化的态，完全交叠是壳模型理论中的一个标准结果。它可以通过将对算符展开为单粒子算符并使用反对易关系来推导，或者更优雅地通过重耦合代数来推导。结果由下式给出：\n$$\n\\langle \\Phi_{J_p'} \\mid \\Phi_{J_p} \\rangle = 2\\delta_{J_p, J_p'} + 4\\sqrt{(2J_p+1)(2J_p'+1)} \\begin{Bmatrix} j  j  J_p \\\\ j  j  J_p' \\\\ J_p  J_p'  0 \\end{Bmatrix}.\n$$\n此处，$\\begin{Bmatrix} \\cdot  \\cdot  \\cdot \\\\ \\cdot  \\cdot  \\cdot \\\\ \\cdot  \\cdot  \\cdot \\end{Bmatrix}$ 是 Wigner $9j$ 符号。\n\n第一项，$2\\delta_{J_p, J_p'}$，是直接项。它来自于将算符当作简单玻色子来收缩的两种方式：$\\langle 0 \\rvert A_{J_p'} A_{J_p'} A^{\\dagger}_{J_p} A^{\\dagger}_{J_p} \\lvert 0 \\rangle \\to \\langle A' A^{\\dagger} \\rangle \\langle A' A^{\\dagger} \\rangle + \\langle A' A^{\\dagger} \\rangle \\langle A' A^{\\dagger} \\rangle$。\n第二项是交换贡献，源于作用在属于不同对的费米子之间的泡利不相容原理。该项涉及将四个粒子的角动量从一个 $( (12)J_p', (34)J_p' )0$ 方案重耦合到一个 $( (12)J_p, (34)J_p )0$ 方案，但在一次粒子置换（例如 $P_{13}$）之后。从像 $((12), (34))$ 这样的划分到 $((13), (24))$ 的重耦合由 $9j$ 符号决定。公式中特定的 $9j$ 符号捕捉了我们正在考虑的总角动量 $J=0$ 情况下这种重耦合的几何结构。\n\n### (b) 张成子空间与正交归一化\n\n问题陈述，对于 $j \\geq \\frac{5}{2}$，四粒子 $J=0$ 子空间的维数为二。这些态按seniority数 $v$ 分类， $v$ 是未耦合到角动量为零的对中的粒子数。两个基态是seniority数 $v=0$ 的态和seniority数 $v=4$ 的态。\n1.  **态 $\\lvert \\Phi_0 \\rangle$**：该态由 $J_p=0$ 的对构成。算符 $A^{\\dagger}_{00}$ 产生一个总角动量为0的粒子对。态 $\\lvert \\Phi_0 \\rangle \\propto (A^{\\dagger}_{00})^2 \\lvert 0 \\rangle$ 根据定义是seniority数 $v=0$ 的态。\n2.  **态 $\\lvert \\Phi_2 \\rangle$**：该态由 $J_p=2$ 的对构成。因为它不是完全由 $J_p=0$ 的对构建的，所以它不是一个纯seniority数 $v=0$ 的态。可以证明，这个态是seniority数 $v=0$ 和 $v=4$ 基态的线性组合。\n\n由于 $\\lvert \\Phi_0 \\rangle$ 是纯 $v=0$ 态，而 $\\lvert \\Phi_2 \\rangle$ 同时具有 $v=0$ 和 $v=4$ 的分量，所以这两个态是线性无关的。因为我们在一个二维空间中有两个线性无关的态，它们构成一个基，因此张成该空间。\n\n对于任何一组线性无关的矢量，它们都可以通过像 Gram-Schmidt 过程这样的程序进行正交归一化。这当且仅当内积的 Gram 矩阵 $G$ 是正定的时才可能。Gram 矩阵为\n$$\nG = \\begin{pmatrix} \\langle \\Phi_0 \\mid \\Phi_0 \\rangle  \\langle \\Phi_0 \\mid \\Phi_2 \\rangle \\\\ \\langle \\Phi_2 \\mid \\Phi_0 \\rangle  \\langle \\Phi_2 \\mid \\Phi_2 \\rangle \\end{pmatrix}.\n$$\n正定性要求对角元为正（$G_{ii} > 0$）且行列式为正（$\\det(G) > 0$）。\n由于任何非零态矢的模方都是正的，$\\langle \\Phi_{J_p} \\mid \\Phi_{J_p} \\rangle > 0$。因此，可以进行正交归一化的条件简化为要求行列式为正：\n$$\n\\det(G) = \\langle \\Phi_0 \\mid \\Phi_0 \\rangle \\langle \\Phi_2 \\mid \\Phi_2 \\rangle - |\\langle \\Phi_0 \\mid \\Phi_2 \\rangle|^2 > 0.\n$$\n这是严格形式的 Cauchy-Schwarz 不等式，它当且仅当矢量 $\\lvert \\Phi_0 \\rangle$ 和 $\\lvert \\Phi_2 \\rangle$ 线性无关时成立。正如我们从seniority数角度论证的，它们是线性无关的，所以条件满足。\n\n### (c) $\\langle \\Phi_{0} \\mid \\Phi_{2} \\rangle$ 的闭合形式表达式\n\n我们使用在(a)部分为特定非对角情况 $J_p' = 0$ 和 $J_p = 2$ 推导的一般公式。\n$$\n\\langle \\Phi_{0} \\mid \\Phi_{2} \\rangle = 2\\delta_{0, 2} + 4\\sqrt{(2(0)+1)(2(2)+1)} \\begin{Bmatrix} j  j  0 \\\\ j  j  2 \\\\ 0  2  0 \\end{Bmatrix}.\n$$\nKronecker delta $\\delta_{0,2}$ 为 $0$。平方根下的项是 $(1)(5)=5$。\n因此，交叠为：\n$$\n\\langle \\Phi_{0} \\mid \\Phi_{2} \\rangle = 4\\sqrt{5} \\begin{Bmatrix} j  j  0 \\\\ j  j  2 \\\\ 0  2  0 \\end{Bmatrix}.\n$$\n问题要求用单个 Wigner $9j$ 符号表示答案。此表达式满足该要求。不需要对 $9j$ 符号做进一步简化。",
            "answer": "$$\n\\boxed{4\\sqrt{5} \\begin{Bmatrix} j  j  0 \\\\ j  j  2 \\\\ 0  2  0 \\end{Bmatrix}}\n$$"
        },
        {
            "introduction": "在实际的壳模型计算中，保证哈密顿量矩阵的旋转不变性至关重要，这是J方案表示的基石。此练习提供了一个关键的质量控制工具，让你能够通过计算交换子 $[H, \\hat{J}^2]$ 来检验一个给定的哈密顿量是否真正保持了角动量守恒。你将学习如何量化对称性破缺的程度，并追溯到引起问题的具体矩阵元，这对于调试复杂的计算代码是一项非常实用的技能。",
            "id": "3602898",
            "problem": "考虑一个旋转不变的核多体哈密顿量 $\\hat{H}$ 中的总角动量算符 $\\hat{J}$。在总角动量耦合表象（$J$-方案表示）中，精确的旋转不变性意味着 $[\\hat{H},\\hat{J}^2]=\\hat{0}$。在一个由总角动量量子数 $\\{J_i\\}_{i=0}^{N-1}$ 标记的基中（其中 $i$ 为基态的索引），$\\hat{J}^2$ 的矩阵是对角的，其对角元为 $J_i(J_i+1)$。假设给定一个实对称矩阵 $H \\in \\mathbb{R}^{N \\times N}$，它代表了在使用 Wigner $6j$ 符号进行重耦合后，由单体和双体矩阵元组装而成的哈密顿量，同时还给定了每个基态的总角动量标记 $J_i$ 的列表。数值上的不一致性（例如，来自不正确或不一致的 Wigner $6j$ 系数）会引入非物理的总角动量混合，这表现为非零的对易子 $[H,\\hat{J}^2]$。\n\n你的任务是实现一个诊断程序，对于每个给定的测试用例，从第一性原理出发执行以下操作：\n- 构建对角矩阵 $D \\in \\mathbb{R}^{N \\times N}$，其对角元为 $D_{ii} = J_i(J_i+1)$。\n- 使用矩阵乘法的定义和对易子 $[A,B] = AB - BA$ 的定义，构成对易子矩阵 $C = [H,D] = HD - DH$。\n- 计算 Frobenius 范数 $\\|C\\|_F = \\sqrt{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} |C_{ij}|^2}$。\n- 判断哈密顿量是否表现出非物理的总角动量混合，此处定义为对于给定的阈值 $\\varepsilon_{\\text{norm}}$，有 $\\|C\\|_F > \\varepsilon_{\\text{norm}}$。\n- 通过将违背归因于特定的非对角元素对 $(i,j)$（其中 $i  j$）来精确定位根本原因。",
            "solution": "该问题要求实现一个数值诊断程序，以验证给定核哈密顿矩阵 $H$ 的旋转不变性。该诊断的基础在于量子力学的一项基本原理：在一个具有旋转对称性的系统中，哈密顿算符 $\\hat{H}$ 必须与总角动量平方算符 $\\hat{J}^2$ 对易。在数学上，这表示为对易子为零：\n$$\n[\\hat{H}, \\hat{J}^2] = \\hat{H}\\hat{J}^2 - \\hat{J}^2\\hat{H} = \\hat{0}\n$$\n该问题是在所谓的 $J$-方案表示中表述的。这是一个由 $\\hat{J}^2$ 的本征态 $\\{|i\\rangle\\}_{i=0}^{N-1}$ 构成的基。每个基态 $|i\\rangle$ 都与一个总角动量量子数 $J_i$ 相关联。在此基中，算符 $\\hat{J}^2$ 由一个对角矩阵表示，我们记为 $D$。该矩阵的对角元是 $\\hat{J}^2$ 的本征值，由著名公式给出：\n$$\nD_{ij} = \\langle i | \\hat{J}^2 | j \\rangle = \\delta_{ij} J_i(J_i+1)\n$$\n其中 $\\delta_{ij}$ 是克罗内克 δ。给定的哈密顿矩阵 $H$ 的元素为 $H_{ij} = \\langle i | \\hat{H} | j \\rangle$。\n\n我们的任务是检查对易子的矩阵表示是否为零，即 $[H, D] = 0$ 是否成立。矩阵 $C = [H, D]$ 中偏离零的元素表明，所提供的哈密顿矩阵 $H$ 未能完美地遵守旋转对称性，这种情况可能源于其构建过程中的数值误差，例如，在涉及 Wigner $6j$ 符号的复杂角动量重耦合计算中。\n\n算法流程如下：\n\n1.  **构建对易子矩阵 $C$**：题目要求我们从第一性原理推导该过程。对易子定义为 $C = HD - DH$。矩阵乘积 $HD$ 的 $(i,j)$ 元素由下式给出：\n    $$\n    (HD)_{ij} = \\sum_{k=0}^{N-1} H_{ik} D_{kj}\n    $$\n    由于 $D$ 是对角矩阵，其对角元为 $D_{kj} = \\delta_{kj} J_j(J_j+1)$，求和可简化为：\n    $$\n    (HD)_{ij} = \\sum_{k=0}^{N-1} H_{ik} \\delta_{kj} J_j(J_j+1) = H_{ij} J_j(J_j+1)\n    $$\n    类似地，对于乘积 $DH$：\n    $$\n    (DH)_{ij} = \\sum_{k=0}^{N-1} D_{ik} H_{kj} = \\sum_{k=0}^{N-1} \\delta_{ik} J_i(J_i+1) H_{kj} = J_i(J_i+1) H_{ij}\n    $$\n    结合这些结果，对易子矩阵的元素 $C_{ij}$ 为：\n    $$\n    C_{ij} = (HD)_{ij} - (DH)_{ij} = H_{ij} J_j(J_j+1) - J_i(J_i+1) H_{ij} = H_{ij} \\left( J_j(J_j+1) - J_i(J_i+1) \\right)\n    $$\n    这个公式是我们算法的核心。它表明，一个元素 $C_{ij}$ 非零的充要条件是对应的哈密顿元素 $H_{ij}$ 非零 *且* 耦合态的角动量不同 ($J_i \\neq J_j$)。在恒定 $J$ 的子块内的耦合（即 $H_{ij}$ 满足 $J_i=J_j$）对对易子没有贡献，这在物理上是正确的。\n\n2.  **量化违背程度**：为了衡量对称性破坏的总“大小”，我们计算对易子矩阵 $C$ 的 Frobenius 范数。Frobenius 范数定义为其元素绝对值平方和的平方根：\n    $$\n    \\|C\\|_F = \\sqrt{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} |C_{ij}|^2}\n    $$\n    一个完全对称的哈密顿量会产生 $\\|C\\|_F = 0$。一个小的非零范数可能归因于浮点计算的不精确性，而一个大的范数则表明存在显著的、非物理的违背。问题将违背定义为当 $\\|C\\|_F  \\varepsilon_{\\text{norm}}$ 时发生，其中 $\\varepsilon_{\\text{norm}}$ 是给定的容差阈值。\n\n3.  **识别和排序违背项**：为了帮助调试哈密顿量，我们必须精确定位出 $H$ 中导致违背的主要来源的特定元素。从 $C_{ij}$ 的表达式可知，对于给定的态对 $(i,j)$ 且 $J_i \\neq J_j$，其大小 $|C_{ij}|$ 与 $|H_{ij}|$ 成正比。因此，对范数的最大贡献来自最大的 $|C_{ij}|$ 值，而这些值又指向了最有问题的 $H_{ij}$ 耦合。\n    回溯过程包括：\n    - 遍历所有唯一的非对角索引对 $(i,j)$，其中 $i",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the processing of all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"N\": 5,\n            \"J\": [0, 0, 1, 1, 2],\n            \"H\": np.array([\n                [1.0, 0.05, 0, 0, 0],\n                [0.05, 1.2, 0, 0, 0],\n                [0, 0, 0.8, -0.03, 0],\n                [0, 0, -0.03, 1.1, 0],\n                [0, 0, 0, 0, 2.0]\n            ]),\n            \"eps_norm\": 1e-10,\n            \"eps_elem\": 1e-10,\n            \"K\": 3\n        },\n        # Test case 2\n        {\n            \"N\": 5,\n            \"J\": [0, 0, 1, 1, 2],\n            \"H\": np.array([\n                [1.0, 0.05, 0.001, 0, 0],\n                [0.05, 1.2, 0, 0, 0],\n                [0.001, 0, 0.8, -0.03, 0],\n                [0, 0, -0.03, 1.1, 0],\n                [0, 0, 0, 0, 2.0]\n            ]),\n            \"eps_norm\": 1e-5,\n            \"eps_elem\": 1e-4,\n            \"K\": 2\n        },\n        # Test case 3\n        {\n            \"N\": 4,\n            \"J\": [1, 1, 1, 2],\n            \"H\": np.array([\n                [0.9, 0.02, 0.01, 3e-8],\n                [0.02, 1.0, 0.015, -2e-8],\n                [0.01, 0.015, 1.1, 1e-8],\n                [3e-8, -2e-8, 1e-8, 1.5]\n            ]),\n            \"eps_norm\": 1e-6,\n            \"eps_elem\": 1e-7,\n            \"K\": 3\n        },\n        # Test case 4\n        {\n            \"N\": 6,\n            \"J\": [0, 1, 1, 2, 2, 3],\n            \"H\": np.array([\n                [1.0, 0, 0, 0.1, 0, 0],\n                [0, 1.2, 0.04, 0, 0, 0.02],\n                [0, 0.04, 1.15, 0, -0.03, 0],\n                [0.1, 0, 0, 2.0, 0.05, 0],\n                [0, 0, -0.03, 0.05, 2.1, 0],\n                [0, 0.02, 0, 0, 0, 2.5]\n            ]),\n            \"eps_norm\": 1e-3,\n            \"eps_elem\": 1e-2,\n            \"K\": 2\n        }\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        norm_F, is_mixing, offending_pairs = diagnose_hamiltonian(\n            case[\"N\"], case[\"J\"], case[\"H\"], case[\"eps_norm\"], case[\"eps_elem\"], case[\"K\"]\n        )\n        \n        # Format the result list into the exact string representation required.\n        # The float must be formatted to 6 decimal places.\n        # Python's default str() for lists and booleans is sufficient.\n        norm_F_str = f\"{norm_F:.6f}\"\n        result_str = f\"[{norm_F_str}, {is_mixing}, {offending_pairs}]\"\n        results_as_strings.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\ndef diagnose_hamiltonian(N, J_list, H, eps_norm, eps_elem, K):\n    \"\"\"\n    Performs the diagnostic check for a single Hamiltonian matrix.\n\n    Args:\n        N (int): Dimension of the matrix.\n        J_list (list): List of total angular momentum quantum numbers.\n        H (np.ndarray): The Hamiltonian matrix.\n        eps_norm (float): Threshold for the Frobenius norm.\n        eps_elem (float): Threshold for individual commutator elements.\n        K (int): Maximum number of offending pairs to return.\n\n    Returns:\n        tuple: A tuple containing:\n            - float: The Frobenius norm of the commutator, ||[H, D]||_F.\n            - bool: True if the norm exceeds eps_norm, False otherwise.\n            - list: A list of up to K offending (i,j) pairs.\n    \"\"\"\n    # 1. Construct the diagonal of the J^2 operator matrix D.\n    # D_ii = J_i * (J_i + 1)\n    d_diag = np.array([j * (j + 1) for j in J_list])\n\n    # 2. Form the commutator matrix C = [H, D] using the derived formula\n    # C_ij = H_ij * (D_jj - D_ii)\n    C = np.zeros_like(H)\n    for i in range(N):\n        for j in range(N):\n            C[i, j] = H[i, j] * (d_diag[j] - d_diag[i])\n\n    # 3. Compute the Frobenius norm of C\n    norm_F = np.linalg.norm(C, 'fro')\n\n    # 4. Decide whether unphysical mixing is present\n    is_mixing = norm_F > eps_norm\n\n    # 5. Backtrace the dominant contributions\n    offending_pairs_with_mag = []\n    for i in range(N):\n        for j in range(i + 1, N): # Iterate over upper triangle (i  j)\n            if J_list[i] != J_list[j]:\n                abs_Cij = np.abs(C[i, j])\n                if abs_Cij >= eps_elem:\n                    offending_pairs_with_mag.append((abs_Cij, (i, j)))\n    \n    # Sort pairs by descending magnitude of C_ij\n    offending_pairs_with_mag.sort(key=lambda x: x[0], reverse=True)\n\n    # Extract the index pairs and limit to K\n    final_pairs = [pair for mag, pair in offending_pairs_with_mag[:K]]\n\n    return norm_F, is_mixing, final_pairs\n\nsolve()\n```"
        },
        {
            "introduction": "使用谐振子基的壳模型计算面临的一个普遍挑战是，物理态会与非物理的质心激发态（伪态）混合。本练习将通过一个简化的模型，让你动手实现劳森方法（Lawson method），这是一种在J方案框架内有效分离和抑制这些伪态的标准技术。通过调节惩罚项参数 $\\beta$ 并观察能谱的变化，你将直观地理解如何“净化”计算结果，确保得到的低能谱是物理可靠的。",
            "id": "3602888",
            "problem": "考虑一个在$J$-方案（基态由总角动量$J$标记）中表述的旋转不变原子核壳模型哈密顿量。在谐振子单粒子基中，质心（COM）自由度可以通过一个计算质心量子的数算符$N_{\\text{COM}}$来表示。为了在不影响内禀（物理）谱的情况下抑制伪质心激发，添加了一个Lawson项：$H_{\\text{Lawson}} = \\beta N_{\\text{COM}}$，其中$\\beta$是一个无量纲的惩罚参数。在$\\beta$值较大时，伪质心激发的能量被推高，而物理态则不受影响。\n\n从第一性原理出发，使用以下基本事实：\n- 旋转不变性意味着哈密顿量可以块对角化为具有确定总角动量$J$的扇区，因此$H = \\bigoplus_J H^{(J)}$。\n- 质心数算符$N_{\\text{COM}}$在一个将内禀分量与伪分量分开的基中是对角的，对于物理分量，$N_{\\text{COM}}=0$；对于伪分量，$N_{\\text{COM}}0$。\n- 添加$H_{\\text{Lawson}}=\\beta N_{\\text{COM}}$会使每个态的能量移动$\\beta$乘以该态中$N_{\\text{COM}}$的期望值，同时保持$J$不变。\n\n在本问题中，您将以自然谐振子单位（其中$\\hbar\\omega=1$，无量纲）构建明确的玩具$J$-方案哈密顿量$H^{(J)}(\\beta)$，将其对角化，并量化当$\\beta$变化时伪态如何移动，同时通过监测$N_{\\text{COM}}$期望值来证明物理$J$-耦合谱在大的$\\beta$值下不受影响。\n\n对于每个$J\\in\\{0,2,4\\}$，定义一个由物理态和一个伪质心（COM）态组成的基。每个扇区中的哈密顿量为\n$$\nH^{(J)}(\\beta) \\;=\\; H_0^{(J)} \\;+\\; V_{\\text{mix}}^{(J)} \\;+\\; \\beta\\, N_{\\text{COM}}^{(J)}\\,,\n$$\n其中：\n- $H_0^{(J)}$是对角矩阵，其对角元等于物理态和伪态的未微扰能量。\n- $V_{\\text{mix}}^{(J)}$在同一$J$值内（保持$J$守恒）耦合伪基态和物理基态。\n- $N_{\\text{COM}}^{(J)}$是对角矩阵，物理基态对应的对角元为$0$，伪基态对应的对角元为$1$。\n\n使用以下扇区定义（所有能量均以自然谐振子单位表示，无量纲）：\n- $J=0$扇区：\n  - 物理能量：$E_{\\text{phys}}^{(0)} = [1.20,\\,2.00]$。\n  - 伪能量：$E_{\\text{spur}}^{(0)} = [1.35]$。\n  - 与伪态的混合耦合：$\\epsilon^{(0)} = [0.08,\\,0.04]$，意味着伪基态与两个物理基态之间的非对角元分别为$0.08$和$0.04$。\n  - $N_{\\text{COM}}^{(0)}=\\mathrm{diag}(0,0,1)$。\n- $J=2$扇区：\n  - 物理能量：$E_{\\text{phys}}^{(2)} = [2.30,\\,3.10]$。\n  - 伪能量：$E_{\\text{spur}}^{(2)} = [2.00]$。\n  - 混合耦合：$\\epsilon^{(2)} = [0.05,\\,0.03]$。\n  - $N_{\\text{COM}}^{(2)}=\\mathrm{diag}(0,0,1)$。\n- $J=4$扇区：\n  - 物理能量：$E_{\\text{phys}}^{(4)} = [3.80]$。\n  - 伪能量：$E_{\\text{spur}}^{(4)} = [3.70]$。\n  - 混合耦合：$\\epsilon^{(4)} = [0.00]$。\n  - $N_{\\text{COM}}^{(4)}=\\mathrm{diag}(0,1)$。\n\n对于每个扇区，$H_0^{(J)}$是由物理能量后跟单个伪能量拼接而成的对角矩阵。混合矩阵$V_{\\text{mix}}^{(J)}$在伪基矢和每个物理基矢之间具有对称的非对角元，由$\\epsilon^{(J)}$的相应条目设定，其他元素为零。算符$N_{\\text{COM}}^{(J)}$是对角的，物理条目上的对角元为零，伪条目上的对角元为一。\n\n对于通过对角化$H^{(J)}(\\beta)$获得的本征对$\\{E_k^{(J)}(\\beta),\\,|\\psi_k^{(J)}(\\beta)\\rangle\\}$，定义质心期望值\n$$\nn_k^{(J)}(\\beta) = \\langle \\psi_k^{(J)}(\\beta) |\\, N_{\\text{COM}}^{(J)} \\,| \\psi_k^{(J)}(\\beta) \\rangle,\n$$\n由于$N_{\\text{COM}}^{(J)}$是对角的，物理分量上为零，伪分量上为一，该值可简化为在伪分量上的概率总和。\n\n对于测试套件中的每个$\\beta$，执行以下计算：\n1. 对于每个扇区$J\\in\\{0,2,4\\}$，构建$H^{(J)}(\\beta)$，将其对角化以获得本征值$E_k^{(J)}(\\beta)$和归一化本征矢量$|\\psi_k^{(J)}(\\beta)\\rangle$，并计算所有$k$的$n_k^{(J)}(\\beta)$。\n2. 将$J$扇区中最大化$n_k^{(J)}(\\beta)$的本征态识别为伪本征态。设其能量为$E_{\\text{spur}}^{(J)}(\\beta)$。使用在$\\beta=0$时通过对角化相同扇区一致计算得到的相应值$E_{\\text{spur}}^{(J)}(0)$，定义伪能量移动\n$$\nS^{(J)}(\\beta) = E_{\\text{spur}}^{(J)}(\\beta) - E_{\\text{spur}}^{(J)}(0).\n$$\n3. 将$J$扇区中满足$n_k^{(J)}(\\beta)  \\tau$（阈值$\\tau = 0.5$）的本征态识别为物理本征态。将其能量升序排序，并与该扇区的基准物理能量$E_{\\text{phys}}^{(J)}$进行比较。定义所有扇区和物理态中的最大绝对漂移为\n$$\nD(\\beta) = \\max_{J}\\,\\max_{i} \\left| \\tilde{E}_{i}^{(J)}(\\beta) - E_{\\text{phys},i}^{(J)} \\right|,\n$$\n其中$\\tilde{E}_{i}^{(J)}(\\beta)$是$J$扇区中已识别物理本征态的排序后能量。\n4. 对于每个扇区$J$，取能量最低的两个本征态（如果少于两个，则取所有态）并计算它们的$n_k^{(J)}(\\beta)$。定义\n$$\nM(\\beta) = \\max_{J}\\,\\max_{k\\in\\text{lowest two of sector }J} \\, n_k^{(J)}(\\beta)\\,.\n$$\n5. 定义一个布尔值\n$$\nU(\\beta) = \\begin{cases}\n\\text{True},  \\text{if } D(\\beta) \\leq 10^{-3} \\text{ and } M(\\beta) \\leq 10^{-3},\\\\\n\\text{False},  \\text{otherwise}.\n\\end{cases}\n$$\n这量化了在大的$\\beta$极限下，物理$J$-耦合谱不受影响，且低位本征态的质心污染可忽略不计。\n6. 定义跨扇区的平均伪能量移动\n$$\n\\bar{S}(\\beta) = \\frac{1}{3} \\sum_{J\\in\\{0,2,4\\}} S^{(J)}(\\beta)\\,.\n$$\n\n测试套件：\n- 使用$\\beta$值$\\{0.0,\\,0.5,\\,5.0,\\,50.0\\}$。\n- 能量以自然谐振子单位表示，$\\hbar\\omega=1$（无量纲数）。\n\n程序输出规格：\n- 对于测试套件中的每个$\\beta$，计算并输出一个包含以下五个量的条目\n$$\n\\left[ \\beta,\\; \\bar{S}(\\beta),\\; D(\\beta),\\; M(\\beta),\\; U(\\beta) \\right].\n$$\n- 您的程序应生成单行输出，包含一个由这些条目组成的逗号分隔列表，每个条目都用方括号括起来。例如：\"[[beta1,meanShift1,maxDrift1,maxLowNcom1,unaffected1],[beta2,meanShift2,maxDrift2,maxLowNcom2,unaffected2],...]\"。",
            "solution": "该问题被验证为科学上合理、设定良好且客观。它提出了一个Lawson方法的简化但概念正确的玩具模型，该方法是原子核壳模型计算中用于抑制伪质心运动的标准技术。所有参数、定义和计算步骤都已明确提供，从而可以得到唯一且可验证的解。该问题与计算核物理领域直接相关，并按规定使用了$J$-方案表示。\n\n该问题要求我们分析将Lawson项$H_{\\text{Lawson}} = \\beta N_{\\text{COM}}$添加到原子核壳模型哈密顿量中的效果。目标是证明对于足够大的惩罚参数$\\beta$，该项能有效地将对应于原子核质心（COM）运动的“伪”本征态与描述原子核内部结构的“物理”本征态分离开来。这种分离是通过显著提高伪态的能量而不影响物理能谱来实现的。\n\n对于具有固定总角动量$J$的扇区，总哈密顿量由下式给出\n$$\nH^{(J)}(\\beta) = H_0^{(J)} + V_{\\text{mix}}^{(J)} + \\beta N_{\\text{COM}}^{(J)}\n$$\n该哈密顿量在一个包含物理态和单个伪质心激发态的基中构建。对于给定的扇区$J$，基可以写为$\\{|p_1^{(J)}\\rangle, \\dots, |p_{N_p}^{(J)}\\rangle, |s^{(J)}\\rangle\\}$，其中$|p_i^{(J)}\\rangle$是$N_p$个物理基态，而$|s^{(J)}\\rangle$是伪基态。\n\n哈密顿量的分量定义如下：\n1.  $H_0^{(J)}$是未微扰能量的对角矩阵。基态的排序方式是物理态在前，伪态在后。\n    $$\n    H_0^{(J)} = \\mathrm{diag}\\left(E_{\\text{phys},1}^{(J)}, \\dots, E_{\\text{phys},N_p}^{(J)}, E_{\\text{spur}}^{(J)}\\right)\n    $$\n2.  $V_{\\text{mix}}^{(J)}$是一个对称的非对角矩阵，它引入了物理态和伪态之间的耦合。其唯一的非零元素位于最后一行和最后一列，以强度$\\epsilon_i^{(J)}$耦合每个物理基态$|p_i^{(J)}\\rangle$与伪基态$|s^{(J)}\\rangle$。\n3.  $N_{\\text{COM}}^{(J)}$是此基中的质心数算符。它是对角的，对于物理基态，其本征值为$0$；对于伪基态，其本征值为$1$。这是因为物理态对应于质心处于其基态（$N_{\\text{COM}}=0$），而伪态代表一个质心激发量子（$N_{\\text{COM}}=1$）。\n    $$\n    N_{\\text{COM}}^{(J)} = \\mathrm{diag}(0, \\dots, 0, 1)\n    $$\n\n对于每个扇区$J \\in \\{0, 2, 4\\}$以及测试套件中的每个$\\beta$值，执行以下计算过程：\n首先，我们根据该扇区提供的能量和耦合构建$H^{(J)}(\\beta)$的数值矩阵。\n\n对于$J=0$扇区，基的维度是$3$（$2$个物理态，$1$个伪态）。哈密顿矩阵是：\n$$\nH^{(0)}(\\beta) = \\begin{pmatrix} 1.20  0  0.08 \\\\ 0  2.00  0.04 \\\\ 0.08  0.04  1.35 + \\beta \\end{pmatrix}\n$$\n对于$J=2$扇区，基的维度是$3$（$2$个物理态，$1$个伪态）：\n$$\nH^{(2)}(\\beta) = \\begin{pmatrix} 2.30  0  0.05 \\\\ 0  3.10  0.03 \\\\ 0.05  0.03  2.00 + \\beta \\end{pmatrix}\n$$\n对于$J=4$扇区，基的维度是$2$（$1$个物理态，$1$个伪态）：\n$$\nH^{(4)}(\\beta) = \\begin{pmatrix} 3.80  0.00 \\\\ 0.00  3.70 + \\beta \\end{pmatrix}\n$$\n请注意，对于$J=4$，混合耦合为$0$，这意味着物理空间和伪空间已经解耦。\n\n接下来，我们求解每个矩阵的定态薛定谔方程，这是一个标准的本征值问题：\n$$\nH^{(J)}(\\beta) |\\psi_k^{(J)}(\\beta)\\rangle = E_k^{(J)}(\\beta) |\\psi_k^{(J)}(\\beta)\\rangle\n$$\n这是通过数值对角化完成的，得到本征值（能量）$E_k^{(J)}(\\beta)$和相应的本征矢量$|\\psi_k^{(J)}(\\beta)\\rangle$。由于哈密顿矩阵是实对称的，本征值将是实数，本征矢量将构成一个正交归一基。\n\n每个本征态的特性（即它有多“伪”）由$N_{\\text{COM}}$算符的期望值来量化：\n$$\nn_k^{(J)}(\\beta) = \\langle \\psi_k^{(J)}(\\beta) | N_{\\text{COM}}^{(J)} | \\psi_k^{(J)}(\\beta) \\rangle\n$$\n如果一个本征矢量表示为$|\\psi_k^{(J)}(\\beta)\\rangle = \\sum_i c_i |p_i^{(J)}\\rangle + c_s |s^{(J)}\\rangle$，那么$n_k^{(J)}(\\beta) = |c_s|^2$。这个值范围从$0$到$1$，表示系统处于伪基态的概率。如果一个本征态的$n_k^{(J)}(\\beta)$是最大的（且大于阈值$\\tau=0.5$），则它被识别为“伪”态，否则为“物理”态。\n\n然后，算法对每个$\\beta$继续进行以下计算：\n1.  **伪能量移动$S^{(J)}(\\beta)$**：我们首先通过对角化$H^{(J)}(0)$来找到$\\beta=0$时伪本征态的能量，记为$E_{\\text{spur}}^{(J)}(0)$。然后，对于每个$\\beta  0$，我们找到具有最大$n_k^{(J)}(\\beta)$的态的能量，记为$E_{\\text{spur}}^{(J)}(\\beta)$。移动量是$S^{(J)}(\\beta) = E_{\\text{spur}}^{(J)}(\\beta) - E_{\\text{spur}}^{(J)}(0)$。平均移动量$\\bar{S}(\\beta)$是$S^{(J)}(\\beta)$在$J \\in \\{0,2,4\\}$上的平均值。随着$\\beta$的增加，我们期望$S^{(J)}(\\beta) \\approx \\beta$。\n2.  **物理谱漂移$D(\\beta)$**：我们识别物理本征态（那些$n_k^{(J)}(\\beta)  0.5$的态），对其能量$\\tilde{E}_{i}^{(J)}(\\beta)$进行排序，并计算这些能量与基准未微扰物理能量$E_{\\text{phys},i}^{(J)}$之间的最大绝对差。这衡量了物理谱因混合和Lawson过程而产生的扭曲程度。在大的$\\beta$极限下，此漂移应趋近于零。\n3.  **低位质心污染$M(\\beta)$**：我们计算每个扇区中两个能量最低的本征态中的最大$n_k^{(J)}(\\beta)$值。对于大的$\\beta$，此量也应趋近于零，表明作为主要物理研究对象的低能谱没有伪质心污染。\n4.  **未受影响谱标志$U(\\beta)$**：一个布尔标志，如果$D(\\beta)$和$M(\\beta)$都低于一个小的容差（$10^{-3}$），则设置为True，这确认了对于给定的$\\beta$，Lawson方法是成功的。\n\n通过对一系列$\\beta$值执行这些计算，我们可以定量地观察到物理自由度与伪自由度的逐渐解耦，这是进行现实核结构计算的基石。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the nuclear shell-model problem with a Lawson term.\n    \n    This function constructs and diagonalizes Hamiltonians for different angular\n    momentum sectors (J=0, 2, 4) and for various values of the Lawson penalty\n    parameter beta. It then calculates several metrics to quantify the \n    separation of spurious center-of-mass states from the physical spectrum.\n    \"\"\"\n\n    # --- Problem Givens ---\n    sector_data = {\n        0: {'E_phys': [1.20, 2.00], 'E_spur': [1.35], 'epsilon': [0.08, 0.04]},\n        2: {'E_phys': [2.30, 3.10], 'E_spur': [2.00], 'epsilon': [0.05, 0.03]},\n        4: {'E_phys': [3.80], 'E_spur': [3.70], 'epsilon': [0.00]}\n    }\n    beta_values = [0.0, 0.5, 5.0, 50.0]\n    j_sectors = [0, 2, 4]\n    n_com_threshold = 0.5\n    unaffected_threshold = 1e-3\n\n    # --- Pre-calculate spurious energies at beta=0 for the shift calculation ---\n    e_spur_j_at_beta0 = {}\n    for j in j_sectors:\n        data = sector_data[j]\n        e_phys = data['E_phys']\n        e_spur = data['E_spur']\n        epsilon = data['epsilon']\n        beta = 0.0\n\n        num_phys = len(e_phys)\n        dim = num_phys + 1\n\n        h0 = np.diag(e_phys + e_spur)\n        v_mix = np.zeros((dim, dim))\n        if num_phys > 0:\n            v_mix[-1, :num_phys] = epsilon\n            v_mix[:num_phys, -1] = epsilon\n        n_com_op = np.diag([0] * num_phys + [1])\n        \n        hamiltonian = h0 + v_mix + beta * n_com_op\n        \n        evals, evecs = np.linalg.eigh(hamiltonian)\n        \n        # n_k is the probability of the spurious component, i.e., |c_spur|^2\n        n_k = evecs[-1, :]**2\n        \n        spur_idx = np.argmax(n_k)\n        e_spur_j_at_beta0[j] = evals[spur_idx]\n\n    # --- Main Calculation Loop ---\n    all_results = []\n    for beta in beta_values:\n        total_s_j = 0.0\n        max_drift_d = 0.0\n        max_low_n_com_m = 0.0\n\n        for j in j_sectors:\n            data = sector_data[j]\n            e_phys = data['E_phys']\n            e_spur = data['E_spur']\n            epsilon = data['epsilon']\n\n            num_phys = len(e_phys)\n            dim = num_phys + 1\n\n            # 1. Construct Hamiltonian H(J)(beta)\n            h0 = np.diag(e_phys + e_spur)\n            v_mix = np.zeros((dim, dim))\n            if num_phys > 0:\n                v_mix[-1, :num_phys] = epsilon\n                v_mix[:num_phys, -1] = epsilon\n            n_com_op = np.diag([0] * num_phys + [1])\n            \n            hamiltonian = h0 + v_mix + beta * n_com_op\n            \n            # Diagonalize to get eigenvalues and eigenvectors\n            evals, evecs = np.linalg.eigh(hamiltonian)\n            \n            # Compute COM expectation values n_k\n            n_k = evecs[-1, :]**2\n\n            # 2. Spurious energy shift S(J)(beta)\n            spur_idx = np.argmax(n_k)\n            e_spur_j_at_beta = evals[spur_idx]\n            s_j = e_spur_j_at_beta - e_spur_j_at_beta0[j]\n            total_s_j += s_j\n\n            # 3. Maximum absolute drift D(beta)\n            phys_indices = np.where(n_k  n_com_threshold)[0]\n            if len(phys_indices) > 0:\n                phys_energies_beta = np.sort(evals[phys_indices])\n                baseline_phys_energies = np.sort(e_phys)\n                \n                # Check for matching dimensions before comparison\n                if len(phys_energies_beta) == len(baseline_phys_energies):\n                    drift_j = np.max(np.abs(phys_energies_beta - baseline_phys_energies))\n                    max_drift_d = max(max_drift_d, drift_j)\n\n            # 4. Max COM contamination of low-lying states M(beta)\n            # Eigenvalues from eigh are already sorted\n            num_lowest = min(2, dim)\n            n_com_lowest_two = n_k[:num_lowest]\n            max_low_n_com_m = max(max_low_n_com_m, np.max(n_com_lowest_two))\n\n        # 6. Average spurious energy shift\n        avg_s = total_s_j / len(j_sectors)\n\n        # 5. Unaffected spectrum boolean U(beta)\n        unaffected_u = (max_drift_d = unaffected_threshold) and (max_low_n_com_m = unaffected_threshold)\n        \n        # Store results for this beta\n        result_entry = [beta, avg_s, max_drift_d, max_low_n_com_m, unaffected_u]\n        all_results.append(result_entry)\n\n    # --- Final Output Formatting ---\n    # Manually format the string to avoid spaces and match the example format\n    output_parts = []\n    for res in all_results:\n        # res is [beta, avg_s, max_drift_d, max_low_n_com_m, unaffected_u]\n        formatted_entry = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]}]\"\n        output_parts.append(formatted_entry)\n        \n    final_output_string = f\"[{','.join(output_parts)}]\"\n\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}