{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的数值实现之前，通过一个简化的、可解析求解的模型来理解相似性重整化群（SRG）的核心机制是极其宝贵的。这个练习旨在揭示为什么使用动能算符作为生成元的SRG能够抑制非对角耦合，它通过推导一个简化的分离势在SRG演化下的解析解，为我们提供了一幅清晰的物理图像。完成这个推导将为你后续的数值编程工作奠定坚实的理论基础 。",
            "id": "3589989",
            "problem": "考虑在相对动量基中一个两体哈密顿量的相似性重整化群 (SRG) 流，其中在流动参数 $s$ 处的哈密顿量为 $H_{s} = T + V_{s}$。在约化质量满足 $2\\mu = 1$ 的单位制下进行计算，因此动能算符是对角的，其值为 $T(p) = p^{2}$，矩阵元为 $\\langle p | T | p' \\rangle = p^{2} \\delta(p - p')$。使用生成元 $\\eta_{s} = [T, H_{s}]$，其中 $[\\cdot,\\cdot]$ 表示对易子，这是标准的 SRG 生成元选择。SRG 流方程为 $dH_{s}/ds = [\\eta_{s}, H_{s}]$，我们只关注两体部分，忽略诱导的多体项。假设在 $s=0$ 时的初始相互作用是一个一阶可分离势 $V_{0}(p, p') = g f(p) f(p')$，其中 $g$ 是耦合常数，$f(p)$ 是一个在 $p$ 很大时衰减的光滑形状因子。\n\n在 $g$ 很小的弱耦合区域，处理 SRG 流至 $g$ 的领头阶（即通过忽略相互作用的二次项来线性化流动）。从 SRG 的定义和动量表象中对易子的基本性质出发，推导当 $p \\neq p'$ 时非对角相互作用矩阵元 $V_{s}(p, p')$ 的领头阶 SRG 演化方程。精确求解这个领头阶流，以获得 $V_{s}(p, p')$ 关于 $g$、$f(p)$、$f(p')$、$p$、$p'$ 和 $s$ 的闭式解析表达式。\n\n你的最终答案必须是 $V_{s}(p, p')$ 作为这些变量的函数的单个闭式解析表达式。无需进行数值计算。",
            "solution": "问题陈述经核实具有科学依据、是良定的、客观且自洽的。所有提供的信息在理论核物理中相似性重整化群 (SRG) 的框架内都是标准的。因此，该问题被认为是有效的。\n\n我们从哈密顿量 $H_s$ 的 SRG 流方程开始，其形式如下：\n$$\n\\frac{dH_s}{ds} = [\\eta_s, H_s]\n$$\n生成元 $\\eta_s$ 定义为动能算符 $T$ 和全哈密顿量 $H_s = T + V_s$ 的对易子：\n$$\n\\eta_s = [T, H_s] = [T, T + V_s] = [T, T] + [T, V_s] = 0 + [T, V_s] = [T, V_s]\n$$\n将这个生成元的表达式代入流方程中，得到：\n$$\n\\frac{dH_s}{ds} = [[T, V_s], H_s]\n$$\n现在我们使用 $H_s = T + V_s$ 展开右侧：\n$$\n\\frac{dH_s}{ds} = [[T, V_s], T + V_s] = [[T, V_s], T] + [[T, V_s], V_s]\n$$\n问题指定我们应该在耦合常数 $g$ 的领头阶下进行计算，这等价于对相互作用势 $V_s$ 的流进行线性化。第一项 $[[T, V_s], T]$ 关于 $V_s$（因此也关于 $g$）是线性的。第二项 $[[T, V_s], V_s]$ 包含两个 $V_s$，因此是相互作用的二次项（$g^2$ 阶）。根据问题的指示，我们必须忽略这个二次项。因此，线性化的流方程为：\n$$\n\\frac{dH_s}{ds} \\approx [[T, V_s], T]\n$$\n由于哈密顿量是 $H_s = T + V_s$ 且动能算符 $T$ 与流动参数 $s$ 无关（即 $dT/ds = 0$），所以势 $V_s$ 的流方程为：\n$$\n\\frac{dV_s}{ds} = \\frac{d(H_s - T)}{ds} = \\frac{dH_s}{ds} - \\frac{dT}{ds} = [[T, V_s], T]\n$$\n为了解这个算符方程，我们将其投影到连续的相对动量基 $|\\Psi_p\\rangle$ 上，我们简记为 $|p\\rangle$。我们寻求矩阵元 $V_s(p, p') = \\langle p | V_s | p' \\rangle$ 的演化。矩阵元的方程变为：\n$$\n\\frac{d V_s(p, p')}{ds} = \\langle p | [[T, V_s], T] | p' \\rangle\n$$\n我们展开双重对易子：\n$$\n[[T, V_s], T] = (TV_s - V_sT)T - T(TV_s - V_sT) = TV_sT - V_sT^2 - T^2V_s + TV_sT = 2TV_sT - T^2V_s - V_sT^2\n$$\n现在我们计算每一项的矩阵元。动能算符 $T$ 在动量基中是对角的，本征值为 $p^2$。它在基矢上的作用为 $T|p'\\rangle = p'^2|p'\\rangle$ 和 $\\langle p|T = p^2\\langle p|$。\n矩阵元为：\n$$\n\\langle p | T^2V_s | p' \\rangle = p^4 \\langle p | V_s | p' \\rangle = p^4 V_s(p, p')\n$$\n$$\n\\langle p | V_sT^2 | p' \\rangle = p'^4 \\langle p | V_s | p' \\rangle = p'^4 V_s(p, p')\n$$\n$$\n\\langle p | TV_sT | p' \\rangle = p^2 p'^2 \\langle p | V_s | p' \\rangle = p^2 p'^2 V_s(p, p')\n$$\n将这些表达式代回 $dV_s(p, p')/ds$ 的方程中：\n$$\n\\frac{d V_s(p, p')}{ds} = 2(p^2 p'^2)V_s(p, p') - p^4 V_s(p, p') - p'^4 V_s(p, p')\n$$\n提出公因子 $V_s(p, p')$ 并重新整理各项，得到：\n$$\n\\frac{d V_s(p, p')}{ds} = -(p^4 - 2p^2 p'^2 + p'^4) V_s(p, p')\n$$\n括号中的项是一个完全平方：\n$$\n\\frac{d V_s(p, p')}{ds} = -(p^2 - p'^2)^2 V_s(p, p')\n$$\n对于函数 $V_s(p, p')$ 而言，这是一个关于流动参数 $s$ 的一阶线性常微分方程。对于任意给定的动量对 $(p, p')$，系数 $-(p^2 - p'^2)^2$ 是一个常数。形如 $dy/ds = k y$ 的方程的通解是 $y(s) = y(0) \\exp(ks)$。\n将此应用于我们的方程，我们得到：\n$$\nV_s(p, p') = V_0(p, p') \\exp\\left(-(p^2 - p'^2)^2 s\\right)\n$$\n问题提供了在 $s=0$ 时的势的初始条件：一个一阶可分离势 $V_0(p, p') = g f(p) f(p')$。将此初始条件代入我们的解中，得到演化后势矩阵元的最终闭式表达式：\n$$\nV_s(p, p') = g f(p) f(p') \\exp\\left(-(p^2 - p'^2)^2 s\\right)\n$$\n此结果对非对角元（其中 $p \\neq p'$）有效。指数因子表明，随着流动参数 $s$ 的增加，势的非对角矩阵元被压低，驱使哈密顿量矩阵趋向于对角（或带对角）形式，这是使用此生成元进行 SRG 演化的典型特征。",
            "answer": "$$\n\\boxed{g f(p) f(p') \\exp\\left(-\\left(p^2 - p'^2\\right)^2 s\\right)}\n$$"
        },
        {
            "introduction": "掌握了SRG解耦机制的解析形式后，下一步是将其转化为实际的计算程序。本实践将引导你从解析理论走向数值计算，你将为一个在动量空间中离散化的简单势能实现SRG演化，并求解相应的矩阵常微分方程。我们特别强调验证的重要性：由于SRG是一种幺正变换，诸如本征值和相移之类的物理可观测量必须在演化过程中保持不变，检查这些不变量是你代码正确性的关键测试 。",
            "id": "3589984",
            "problem": "考虑一个双体哈密顿量在动量空间、分波、三维、无自旋、$s$波通道中的相似性重整化群 (SRG) 演化，并采用自然单位制，其中 $\\hbar = 1$ 且约化质量被选择为 $2\\mu = 1$。在此单位制下，动能为 $T(k) = k^2$。在连续动量表象下进行计算，采用适用于三维 $s$ 波散射的径向测度，其中积分测度为 $k^2 \\, \\mathrm{d}k/(2\\pi^2)$。使用映射到 $k \\in [0,k_{\\max}]$ 的高斯-勒让德求积法，在具有节点 $\\{k_i\\}_{i=1}^N$ 和权重 $\\{w_i\\}_{i=1}^N$ 的有限网格上离散化连续谱。\n\n定义一个秩一可分势 $V(k,k') = -\\lambda \\, g(k) \\, g(k')$，其中 $g(k) = 1/(k^2 + \\beta^2)$，且 $\\lambda > 0, \\beta > 0$ 为常数参数。完整的哈密顿量核为 $H(k,k') = T(k) \\, \\delta(k-k') + V(k,k')$。使用动能生成元 $G = T$ 引入 SRG 流，因此 SRG 方程为\n$$\n\\frac{\\mathrm{d}H_s}{\\mathrm{d}s} = [\\eta_s, H_s], \\quad \\eta_s = [G,H_s],\n$$\n其中 $[\\cdot,\\cdot]$ 表示对易子。SRG 参数 $s \\ge 0$ 是一个控制解耦的流参数。\n\n为了在离散化的连续谱中实现数值稳定的算符代数，使用加权正交归一化表示法，该表示法由对角缩放矩阵 $S = \\mathrm{diag}\\left(\\sqrt{w_i \\, m_i}\\right)$ 定义，其中 $m_i = k_i^2/(2\\pi^2)$。通过 $\\tilde{O} = S \\, O \\, S$ 将任意核 $O(k,k')$ 映射到其正交归一化矩阵表示 $\\tilde{O}$。在此正交归一化表示中，动能算符是对角的，$\\tilde{T}_{ij} = k_i^2 \\, \\delta_{ij}$，且标准矩阵乘法对应于连续谱算符的复合。\n\n对于散射问题，考虑在能量 $E = k_0^2$ 处的反应 (K) 矩阵，其中外部在壳动量 $k_0$ 等于网格点之一 $k_{i_0}$。在该表示下，主值分解算符是对角的，定义为\n$$\n\\tilde{G}_0^{\\mathrm{P}}(E)_{jj} = \\begin{cases}\n\\frac{1}{E - k_j^2},  \\text{if } j \\ne i_0,\\\\\n0,  \\text{if } j = i_0,\n\\end{cases}\n$$\n这在奇异点处强制执行了柯西主值。正交归一化表示下的 K 矩阵满足\n$$\n\\tilde{K} = \\tilde{V} + \\tilde{V} \\, \\tilde{G}_0^{\\mathrm{P}} \\, \\tilde{K},\n$$\n并且可以通过求解线性系统 $(I - \\tilde{V} \\, \\tilde{G}_0^{\\mathrm{P}}) \\, \\tilde{K} = \\tilde{V}$ 得到。通过撤销缩放可以恢复物理的在壳核函数值：\n$$\nK(k_{i_0}, k_{i_0}; E) = \\frac{\\tilde{K}_{i_0 i_0}}{w_{i_0} \\, m_{i_0}}.\n$$\n在所选的归一化和单位制下，$s$ 波相移 $\\delta(k_0)$（以弧度为单位）通过以下关系与在壳 K 矩阵相关联：\n$$\n\\tan \\delta(k_0) = - \\mu \\, k_0 \\, K(k_0,k_0; E),\n$$\n其中 $\\mu = \\tfrac{1}{2}$。\n\n任务：\n1. 使用高斯-勒让德求积法在 $[0,k_{\\max}]$ 上离散化动量网格，使用 $N$ 个点。构建缩放矩阵 $S$、正交归一化动能矩阵 $\\tilde{T}$ 以及对应于可分势 $V(k,k')$ 的正交归一化势能矩阵 $\\tilde{V}$。\n2. 使用动能生成元，实现从 $s=0$ 到目标 $s=s_{\\mathrm{target}}$ 的 SRG 演化，对\n$$\n\\frac{\\mathrm{d}\\tilde{H}_s}{\\mathrm{d}s} = [[\\tilde{T}, \\tilde{H}_s], \\tilde{H}_s],\n$$\n进行积分，从 $\\tilde{H}_0 = \\tilde{T} + \\tilde{V}$ 开始。确保数值积分在数值容差范围内保持厄米性。\n3. 通过检查不变量和收敛性来验证数值实现：\n   - 本征值不变性：$\\tilde{H}_s$ 的谱必须在幺正 SRG 演化下保持不变。量化 $\\tilde{H}_{s=0}$ 和 $\\tilde{H}_{s=s_{\\mathrm{target}}}$ 的排序后本征值之间的最大绝对差。\n   - 相移不变性：使用定义的 K 矩阵方法和主值，计算在 $s=0$ 和 $s=s_{\\mathrm{target}}$ 时 $s$ 波相移 $\\delta(k_0)$（以弧度为单位），并量化绝对差 $|\\delta_{s=0} - \\delta_{s=s_{\\mathrm{target}}}|$。\n   - 网格分辨率收敛性：比较这两种误差度量在一个粗糙分辨率 $N_{\\mathrm{coarse}}$ 和一个更精细分辨率 $N_{\\mathrm{fine}}$ 下的表现，以测试误差是否随 $N$ 增加而减小；报告布尔值，指示更精细的网格是否产生更小的误差。\n\n在自然单位制下使用以下固定的物理和数值参数：\n- $\\lambda = 5.0$, $\\beta = 1.0$。\n- $k_{\\max} = 8.0$。\n- 选择 $s_{\\mathrm{target}} = 0.02$。\n- 使用 $N_{\\mathrm{coarse}} = 32$ 和 $N_{\\mathrm{fine}} = 64$。\n- 对于相移，选择在壳动量为索引为 $i_0 = \\lfloor N/4 \\rfloor$ 的网格节点。相移必须以弧度表示。\n\n您的程序应为指定的测试套件计算以下内容：\n- 测试用例 1 (标准情况)：在 $N = N_{\\mathrm{fine}}$ 的情况下，计算 $s=0$ 和 $s=s_{\\mathrm{target}}$ 之间的最大绝对本征值差。\n- 测试用例 2 (标准情况)：在 $N = N_{\\mathrm{fine}}$ 的情况下，计算在 $k_0 = k_{i_0}$ 处 $s=0$ 和 $s=s_{\\mathrm{target}}$ 之间的绝对相移差（以弧度为单位）。\n- 测试用例 3 (本征值收敛性检查)：计算 $N = N_{\\mathrm{coarse}}$ 和 $N = N_{\\mathrm{fine}}$ 时的最大绝对本征值差；返回一个布尔值，指示在 $N = N_{\\mathrm{fine}}$ 时误差是否更小。\n- 测试用例 4 (相移收敛性检查)：计算 $N = N_{\\mathrm{coarse}}$ 和 $N = N_{\\mathrm{fine}}$ 时的绝对相移差；返回一个布尔值，指示在 $N = N_{\\mathrm{fine}}$ 时误差是否更小。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述顺序包含四个测试用例的结果：\n$$\n[\\Delta E_{\\max}, \\Delta \\delta, \\mathrm{eig\\_conv}, \\mathrm{phase\\_conv}],\n$$\n其中 $\\Delta E_{\\max}$ 和 $\\Delta \\delta$ 是浮点数，$\\mathrm{eig\\_conv}$ 和 $\\mathrm{phase\\_conv}$ 是布尔值。",
            "solution": "该问题要求在一个离散化的动量空间中，实现并验证一个双体哈密顿量的相似性重整化群 (SRG) 演化。验证过程涉及检查在 SRG 流下本征值和散射相移的不变性。解决方案分四个阶段进行：(1) 连续谱哈密顿量的离散化，(2) SRG 流方程的数值积分，(3) 物理可观测量（本征值和相移）的计算，以及 (4) 数值收敛性分析。\n\n### 第 1 步：离散化与矩阵表示\n\n为了便于数值计算，必须将连续动量空间哈密顿量表示为有限维矩阵。这通过使用高斯-勒让德求积法来离散化动量积分来实现。\n\n动量变量 $k \\in [0, k_{\\max}]$ 被离散化到 $N$ 个点 $\\{k_i\\}_{i=1}^N$ 的网格上。我们使用定义在区间 $[-1, 1]$ 上的 $N$ 点高斯-勒让德求积法则，其节点为 $\\{x_j'\\}_{j=1}^N$，权重为 $\\{w_j'\\}_{j=1}^N$。这些点通过变换 $k(x) = \\frac{k_{\\max}}{2}(x+1)$ 映射到区间 $[0, k_{\\max}]$。求积节点 $k_i$ 和权重 $w_i$ 于是为：\n$$\nk_i = \\frac{k_{\\max}}{2}(x_i' + 1)\n$$\n$$\nw_i = w_i' \\frac{k_{\\max}}{2}\n$$\n函数 $f(k)$ 的积分近似为 $\\int_0^{k_{\\max}} f(k) \\, \\mathrm{d}k \\approx \\sum_{i=1}^N w_i f(k_i)$。\n\n问题指定了一种正交归一化表示，其中矩阵乘法对应于连续谱算符的复合。$s$ 波散射的积分测度为 $m(k) \\mathrm{d}k = \\frac{k^2}{2\\pi^2} \\mathrm{d}k$。我们定义一个对角缩放矩阵 $S$，其元素为 $S_{ii} = \\sqrt{w_i m_i}$，其中 $m_i = m(k_i) = k_i^2/(2\\pi^2)$。\n\n算符 $\\hat{O}$ 的正交归一化矩阵表示 $\\tilde{O}$ 由其在一组正交归一化函数基中的矩阵元给出。对于本问题中的算符，这导致了以下矩阵形式：\n\n1.  **动能算符：** 动能 $\\hat{T}$ 是一个局域算符，其核为 $T(k, k') = k^2 \\delta(k-k')$。其在正交归一化基中的矩阵表示是对角的：\n    $$\n    \\tilde{T}_{ij} = k_i^2 \\delta_{ij}\n    $$\n    该矩阵记为 $\\tilde{T}$。\n\n2.  **势能算符：** 势是一个非局域、秩一可分算符，其核为 $V(k,k') = -\\lambda g(k) g(k')$，其中 $g(k) = 1/(k^2 + \\beta^2)$。其矩阵表示是通过首先构建矩阵 $V_{ij} = V(k_i, k_j)$，然后应用缩放变换：$\\tilde{V} = SVS$ 来构造的。\n    设 $\\mathbf{g}$ 是一个列向量，其元素为 $g_i = g(k_i) = 1/(k_i^2+\\beta^2)$。则矩阵 $V$ 为 $V = -\\lambda \\mathbf{g} \\mathbf{g}^T$。\n    正交归一化的势能矩阵 $\\tilde{V}$ 变为：\n    $$\n    \\tilde{V} = S (-\\lambda \\mathbf{g} \\mathbf{g}^T) S = -\\lambda (S\\mathbf{g})(S\\mathbf{g})^T\n    $$\n    令 $\\tilde{\\mathbf{g}} = S\\mathbf{g}$，其元素为 $\\tilde{g}_i = S_{ii} g_i = \\sqrt{w_i k_i^2/(2\\pi^2)} g_i$，则势能矩阵为 $\\tilde{V} = -\\lambda \\tilde{\\mathbf{g}} \\tilde{\\mathbf{g}}^T$。\n\n流参数 $s=0$ 处的初始哈密顿量为 $\\tilde{H}_0 = \\tilde{T} + \\tilde{V}$。由于 $\\tilde{T}$ 是对角的，$\\tilde{V}$ 是实对称的，因此 $\\tilde{H}_0$ 是一个实对称（因此是厄米）矩阵。\n\n### 第 2 步：SRG 演化\n\n哈密顿量矩阵 $\\tilde{H}_s$ 的 SRG 演化由以下常微分方程 (ODE) 控制：\n$$\n\\frac{\\mathrm{d}\\tilde{H}_s}{\\mathrm{d}s} = [[\\tilde{T}, \\tilde{H}_s], \\tilde{H}_s]\n$$\n与对角矩阵 $\\tilde{T}$ 的对易子可以高效计算：$([\\tilde{T}, \\tilde{H}_s])_{ij} = (\\tilde{T}_{ii} - \\tilde{T}_{jj})(\\tilde{H}_s)_{ij} = (k_i^2 - k_j^2)(\\tilde{H}_s)_{ij}$。令 $\\eta_s = [\\tilde{T}, \\tilde{H}_s]$。则 ODE 为 $\\frac{\\mathrm{d}\\tilde{H}_s}{\\mathrm{d}s} = [\\eta_s, \\tilde{H}_s]$。\n\n这个矩阵 ODE 从 $s=0$ 到 $s=s_{\\mathrm{target}}$ 进行数值积分，初始条件为 $\\tilde{H}_0$。我们采用一个标准的自适应步长 ODE 求解器，例如 `scipy.integrate.solve_ivp` 中可用的 `RK45`。由于生成元 $\\tilde{T}$ 是厄米的，流是幺正的并保持 $\\tilde{H}_s$ 的谱不变。算符 $\\eta_s$ 是反厄米的，这确保了导数 $\\frac{\\mathrm{d}\\tilde{H}_s}{\\mathrm{d}s}$ 是厄米的，因此 $\\tilde{H}_s$ 的厄米性在整个演化过程中得以保持。破坏矩阵对称性的微小数值误差可以通过取最终矩阵的对称部分来校正：$\\tilde{H}_{s_{\\mathrm{target}}} \\leftarrow \\frac{1}{2}(\\tilde{H}_{s_{\\mathrm{target}}} + \\tilde{H}_{s_{\\mathrm{target}}}^T)$。\n\n### 第 3 步：不变量的计算\n\n为了验证实现，我们检查 SRG 流的两个不变量：哈密顿量的本征值和在壳散射可观测量（相移）。\n\n1.  **本征值不变性：** $\\tilde{H}_s$ 的本征值必须不依赖于流参数 $s$。我们使用对称矩阵的数值本征求解器计算初始哈密顿量 $\\tilde{H}_0$ 和最终演化后的哈密顿量 $\\tilde{H}_{s_{\\mathrm{target}}}$ 的本征值。比较排序后的本征值列表，并将最大绝对差作为误差度量：\n    $$\n    \\Delta E_{\\max} = \\max_i |\\lambda_i(s=0) - \\lambda_i(s=s_{\\mathrm{target}})|\n    $$\n\n2.  **相移不变性：** 作为物理可观测量，散射相移也必须是不变的。在壳动量 $k_0$ （对应能量 $E=k_0^2$）处的相移 $\\delta(k_0)$ 使用 K 矩阵形式计算。\n    首先，从演化后的哈密顿量中提取演化后的势能矩阵：$\\tilde{V}_s = \\tilde{H}_s - \\tilde{T}$。\n    K 矩阵 $\\tilde{K}_s$ 通过求解 Lippmann-Schwinger 型方程 $(I - \\tilde{V}_s \\tilde{G}_0^{\\mathrm{P}}) \\tilde{K}_s = \\tilde{V}_s$ 得到，其中 $\\tilde{G}_0^{\\mathrm{P}}$ 是对角的主值分解算符矩阵。对于一个选定的在壳动量 $k_0 = k_{i_0}$ （其中 $i_0 = \\lfloor N/4 \\rfloor$ 是网格索引），其元素为：\n    $$\n    (\\tilde{G}_0^{\\mathrm{P}}(E))_{jj} = \\begin{cases}\n    \\frac{1}{E - k_j^2},  \\text{if } j \\ne i_0 \\\\\n    0,  \\text{if } j = i_0\n    \\end{cases}\n    $$\n    其中 $E = k_{i_0}^2$。这是一个关于矩阵 $\\tilde{K}_s$ 的线性方程组，可以进行数值求解。\n    通过撤销基底缩放来恢复物理的在壳 K 矩阵元素：\n    $$\n    K_s(k_{i_0}, k_{i_0}; E) = \\frac{(\\tilde{K}_s)_{i_0 i_0}}{w_{i_0} m_{i_0}} = \\frac{(\\tilde{K}_s)_{i_0 i_0}}{w_{i_0} k_{i_0}^2 / (2\\pi^2)}\n    $$\n    然后，$s$ 波相移 $\\delta_s(k_0)$ 由以下关系给出：\n    $$\n    \\delta_s(k_0) = \\arctan(-\\mu k_0 K_s(k_0, k_0; E))\n    $$\n    其中 $\\mu = 1/2$。此计算分别在 $s=0$（使用 $\\tilde{H}_0$）和 $s=s_{\\mathrm{target}}$（使用 $\\tilde{H}_{s_{\\mathrm{target}}}$）时进行，并计算绝对差 $\\Delta \\delta = |\\delta_0 - \\delta_{s_{\\mathrm{target}}}|$。\n\n### 第 4 步：数值流程与收敛性分析\n\n整个过程被封装在一个以网格大小 $N$ 为输入的函数中。该函数执行离散化、SRG 演化以及两个误差度量 $\\Delta E_{\\max}$ 和 $\\Delta \\delta$ 的计算。\n\n为完成所需任务：\n- 对 $N=N_{\\mathrm{fine}}=64$ 调用该函数。得到的 $\\Delta E_{\\max}$ 和 $\\Delta \\delta$ 是前两个要求的输出。\n- 也对 $N=N_{\\mathrm{coarse}}=32$ 调用该函数。设其误差为 $\\Delta E_{\\max}^{(\\mathrm{coarse})}$ 和 $\\Delta\\delta^{(\\mathrm{coarse})}$，精细网格的误差为 $\\Delta E_{\\max}^{(\\mathrm{fine})}$ 和 $\\Delta\\delta^{(\\mathrm{fine})}$。\n- 收敛性检查是如下定义的布尔值：\n    - $\\mathrm{eig\\_conv} = (\\Delta E_{\\max}^{(\\mathrm{fine})}  \\Delta E_{\\max}^{(\\mathrm{coarse})})$\n    - $\\mathrm{phase\\_conv} = (\\Delta\\delta^{(\\mathrm{fine})}  \\Delta\\delta^{(\\mathrm{coarse})})$\n这四个值构成了最终输出。随着网格离散化更精细，误差减小，表明数值误差（来自求积、ODE 积分和线性代数）是受控的，并如预期那样收敛到零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the SRG calculations and produce the final output.\n    \"\"\"\n\n    # Fixed physical and numerical parameters\n    LAMBDA = 5.0\n    BETA = 1.0\n    K_MAX = 8.0\n    S_TARGET = 0.02\n    MU = 0.5\n    N_COARSE = 32\n    N_FINE = 64\n\n    def run_srg_calculation(N: int):\n        \"\"\"\n        Performs the full SRG calculation for a given grid size N.\n\n        Args:\n            N (int): Number of momentum grid points.\n\n        Returns:\n            tuple: A tuple containing:\n                - delta_E_max (float): Maximum absolute eigenvalue difference.\n                - delta_phase_shift (float): Absolute phase shift difference.\n        \"\"\"\n        # --- 1. Discretization and Matrix Construction ---\n        \n        # Get Gauss-Legendre quadrature nodes and weights for [-1, 1]\n        x_nodes, x_weights = roots_legendre(N)\n        \n        # Map nodes and weights to [0, K_MAX]\n        k_nodes = K_MAX / 2.0 * (x_nodes + 1.0)\n        k_weights = K_MAX / 2.0 * x_weights\n\n        # Construct measure factor and scaling matrix S\n        m_i = k_nodes**2 / (2.0 * np.pi**2)\n        s_diag = np.sqrt(k_weights * m_i)\n        \n        # Kinetic energy matrix (diagonal)\n        t_tilde = np.diag(k_nodes**2)\n\n        # Potential energy matrix (rank-one separable)\n        g_vec = 1.0 / (k_nodes**2 + BETA**2)\n        g_tilde_vec = s_diag * g_vec\n        v_tilde = -LAMBDA * np.outer(g_tilde_vec, g_tilde_vec)\n        \n        # Initial Hamiltonian at s=0\n        h0_tilde = t_tilde + v_tilde\n\n        # --- 2. SRG Evolution ---\n        \n        def srg_ode(s, h_flat, t_diag_sq):\n            \"\"\"RHS of the SRG ODE for the ODE solver.\"\"\"\n            h_s = h_flat.reshape((N, N))\n            # Commutator [T, H] = T H - H T\n            # Since T is diagonal, (k_i^2 - k_j^2) H_ij\n            diff_t_sq = t_diag_sq[:, None] - t_diag_sq[None, :]\n            eta = diff_t_sq * h_s\n            # Commutator [eta, H]\n            dh_ds = eta @ h_s - h_s @ eta\n            return dh_ds.flatten()\n        \n        # Integrate the ODE\n        t_diag_sq = np.diag(t_tilde)\n        sol = solve_ivp(\n            srg_ode,\n            [0, S_TARGET],\n            h0_tilde.flatten(),\n            args=(t_diag_sq,),\n            method='RK45', \n            rtol=1e-8, \n            atol=1e-8\n        )\n        \n        # Evolved Hamiltonian at s=S_TARGET\n        hs_tilde_flat = sol.y[:, -1]\n        hs_tilde = hs_tilde_flat.reshape((N, N))\n        \n        # Enforce symmetry to remove numerical noise\n        hs_tilde = 0.5 * (hs_tilde + hs_tilde.T)\n\n        # --- 3. Invariant Checks ---\n        \n        # Eigenvalue invariance\n        evals0 = np.linalg.eigvalsh(h0_tilde)\n        evals_s = np.linalg.eigvalsh(hs_tilde)\n        delta_E_max = np.max(np.abs(evals0 - evals_s))\n        \n        def calculate_phase_shift(h_matrix):\n            \"\"\"Calculates the s-wave phase shift from a given Hamiltonian matrix.\"\"\"\n            v_matrix = h_matrix - t_tilde\n            i0 = N // 4  # On-shell index\n            k0 = k_nodes[i0]\n            E = k0**2\n            \n            # Principal value resolvent\n            g0p_diag = np.zeros(N)\n            for j in range(N):\n                if j != i0:\n                    g0p_diag[j] = 1.0 / (E - k_nodes[j]**2)\n            g0p = np.diag(g0p_diag)\n            \n            # Solve linear system for K-matrix: (I - V G0P) K = V\n            A = np.eye(N) - v_matrix @ g0p\n            try:\n                k_matrix = np.linalg.solve(A, v_matrix)\n            except np.linalg.LinAlgError:\n                return np.nan # In case of singularity\n            \n            # On-shell K-matrix element\n            k_onshell_tilde = k_matrix[i0, i0]\n            \n            # Rescale to physical value\n            w_i0 = k_weights[i0]\n            m_i0 = k0**2 / (2 * np.pi**2)\n            if w_i0 * m_i0 == 0: return np.nan\n            k_onshell_phys = k_onshell_tilde / (w_i0 * m_i0)\n            \n            # Calculate phase shift\n            tan_delta = -MU * k0 * k_onshell_phys\n            delta = np.arctan(tan_delta)\n            return delta\n        \n        # Phase shift invariance\n        delta_0 = calculate_phase_shift(h0_tilde)\n        delta_s = calculate_phase_shift(hs_tilde)\n        delta_phase_shift = np.abs(delta_0 - delta_s)\n        \n        return delta_E_max, delta_phase_shift\n\n    # --- 4. Run calculations and collect results ---\n    \n    # Run for coarse and fine grids\n    err_E_coarse, err_d_coarse = run_srg_calculation(N_COARSE)\n    err_E_fine, err_d_fine = run_srg_calculation(N_FINE)\n\n    # Prepare final results for output\n    # Test case 1: ΔE_max for N_fine\n    delta_E_max_fine = err_E_fine\n    # Test case 2: Δδ for N_fine\n    delta_phase_shift_fine = err_d_fine\n    # Test case 3: Eigenvalue error convergence\n    eig_conv = err_E_fine  err_E_coarse\n    # Test case 4: Phase shift error convergence\n    phase_conv = err_d_fine  err_d_coarse\n\n    results = [delta_E_max_fine, delta_phase_shift_fine, eig_conv, phase_conv]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "构建并验证了一个计算工具后，专业的科学研究还需要理解其预测结果的局限性和不确定性。这个练习代表了科学研究的最后一步：量化结果的可靠性。它将指导你构建一个全面的误差预算，剖析来自不同来源的误差贡献，包括理论截断（如省略了诱导的多体力）、数值近似（如常微分方程求解器的精度）和基组空间的限制。通过这个实践，你将掌握评估计算结果置信度的关键技能 。",
            "id": "3589919",
            "problem": "您的任务是为相似重整化群 (SRG) 演化的束缚能代理 $E_A(\\lambda)$ 构建一个全面的数值误差预算，其中 $A$ 表示核子数，$\\lambda$ 是 SRG 分辨率标度。计算设置必须是自洽且纯数学的，但要与计算核物理中使用的核心思想保持一致。请使用以下模型和定义。\n\n基本定义：\n- 相似重整化群 (SRG) 流根据微分方程\n$$\\frac{dH_s}{ds} = [\\eta_s, H_s],$$\n演化一个哈密顿量 $H_s$，其中流参数为 $s$。\n其中 $[\\cdot,\\cdot]$ 表示对易子，$\\eta_s$ 是一个生成元。在本任务中，请使用动能生成元 $\\eta_s = [T, H_s]$，其中 $T$ 是一个对角化的动能代理。\n- 通过 $s = \\lambda^{-4}$ 将 SRG 分辨率标度 $\\lambda$ 与流参数关联起来。在本问题中，将 $\\lambda$ 视为无量纲，并将能量单位视为兆电子伏 (MeV)。\n- 初始哈密顿量定义为 $H_0 = T + V$，其中 $T$ 是一个对角矩阵，$V$ 是一个秩为 1 的吸引型可分离相互作用 $V = -g \\, \\mathbf{u}\\mathbf{u}^\\top$，$g$ 是一个正常数耦合常数，$\\mathbf{u}$ 是一个固定的形状向量，其分量为 $u_i = \\exp\\!\\big(-\\frac{(i-1)^2}{2\\sigma^2}\\big)$，其中 $i = 1,2,\\dots,N$，$N$ 是基底维度。对角矩阵 $T$ 的分量为 $T_{ii} = E_0 + (i-1)\\Delta$，其中 $E_0$ 和 $\\Delta$ 是固定的正常数（所有能量单位均为 MeV）。\n- 分辨率为 $\\lambda$ 时的 SRG 演化哈密顿量 $H_\\lambda$ 是通过将流从 $s=0$ 积分到 $s=\\lambda^{-4}$ 得到的。\n\n束缚能代理：\n- 对于二体系统 ($A=2$)，将束缚能代理定义为 $H_\\lambda$ 的最低本征值：\n$$E_2(\\lambda) = \\min \\mathrm{eig}(H_\\lambda).$$\n- 对于三体系统 ($A=3$)，使用代理\n$$E_3(\\lambda) = c_3 \\, E_2(\\lambda) + \\beta \\, \\|O(H_\\lambda)\\|_F,$$\n其中 $c_3$ 和 $\\beta$ 是固定的正常数，$O(H_\\lambda)$ 表示 $H_\\lambda$ 的非对角部分（即将对角线元素置零的矩阵），$\\|\\cdot\\|_F$ 表示 Frobenius 范数。这种构造捕捉了一个定性特征：被忽略的诱导三体力与非对角耦合强度相关，而 SRG 演化会减小该耦合强度。\n\n误差预算组成部分：\n- 诱导多体截断 ($A2$) 误差估计：\n  保持严格的数值公差和大的基底。通过在两个相近的标度 $\\lambda_{\\mathrm{low}}$ 和 $\\lambda_{\\mathrm{high}}$ 处计算 $E_A(\\lambda)$ 来测量其对 $\\lambda$ 的敏感性；定义\n  $$\\varepsilon_{\\mathrm{trunc}} = \\frac{1}{2}\\left|E_A(\\lambda_{\\mathrm{high}}) - E_A(\\lambda_{\\mathrm{low}})\\right|.$$\n- 常微分方程 (ODE) 积分误差估计：\n  在固定的 $\\lambda^\\star$、基底 $N_{\\mathrm{ref}}$ 和指定的生成元选择下，分别使用严格公差和宽松公差计算 $E_A(\\lambda^\\star)$，并定义\n  $$\\varepsilon_{\\mathrm{ode}} = \\left|E_A^{\\mathrm{loose}}(\\lambda^\\star) - E_A^{\\mathrm{tight}}(\\lambda^\\star)\\right|.$$\n- 基底截断误差估计：\n  在固定的 $\\lambda^\\star$ 和严格公差下，比较目标基底维度 $N_{\\mathrm{max}}$ 和一个更大的参考基底 $N_{\\mathrm{ref}}$ 的结果，并定义\n  $$\\varepsilon_{\\mathrm{basis}} = \\left|E_A^{N_{\\mathrm{max}}}(\\lambda^\\star) - E_A^{N_{\\mathrm{ref}}}(\\lambda^\\star)\\right|.$$\n- 将各误差分量以正交和的方式组合得到总误差：\n  $$\\varepsilon_{\\mathrm{tot}} = \\sqrt{\\varepsilon_{\\mathrm{trunc}}^2 + \\varepsilon_{\\mathrm{ode}}^2 + \\varepsilon_{\\mathrm{basis}}^2}.$$\n\n数值和物理约定：\n- 所有能量必须以兆电子伏 (MeV) 表示。\n- 所有计算均使用以下固定的模型参数：$E_0 = 1.0$, $\\Delta = 2.0$, $g = 6.0$, $\\sigma = 5.0$, $c_3 = 1.5$, $\\beta = 0.05$。\n- 使用严格和宽松的 ODE 积分公差，分别为 $(\\mathrm{rtol}, \\mathrm{atol})_{\\mathrm{tight}} = (10^{-10}, 10^{-12})$ 和 $(\\mathrm{rtol}, \\mathrm{atol})_{\\mathrm{loose}} = (10^{-6}, 10^{-8})$。\n- 对于截断误差估计，使用一个固定窗口 $\\delta\\lambda = 0.5$，即 $\\lambda_{\\mathrm{low}} = \\lambda^\\star - \\delta\\lambda$ 和 $\\lambda_{\\mathrm{high}} = \\lambda^\\star + \\delta\\lambda$，并需注意 $\\lambda_{\\mathrm{low}}$ 必须为严格正数。\n- 对于基底截断比较，使用 $N_{\\mathrm{ref}} = 32$，并根据每个测试用例指定 $N_{\\mathrm{max}}$。\n\n测试套件：\n为以下参数集计算误差预算，每个参数集指定为 $(A, \\lambda^\\star, N_{\\mathrm{max}})$：\n- 案例 1：$(3, 2.0, 16)$\n- 案例 2：$(3, 1.5, 8)$\n- 案例 3：$(2, 2.5, 16)$\n- 案例 4：$(3, 3.0, 24)$\n\n对于每个案例，您必须输出列表 $[\\varepsilon_{\\mathrm{tot}}, \\varepsilon_{\\mathrm{trunc}}, \\varepsilon_{\\mathrm{ode}}, \\varepsilon_{\\mathrm{basis}}]$，单位为 MeV，并四舍五入到六位小数。\n\n最终输出规范：\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个测试用例贡献一个与上述格式和顺序相同的子列表。例如，最终输出必须如下所示：\n$$[\\,[x_1,x_2,x_3,x_4],\\,[y_1,y_2,y_3,y_4],\\,[z_1,z_2,z_3,z_4],\\,[w_1,w_2,w_3,w_4]\\,],$$\n其中每个 $x_i$、$y_i$、$z_i$ 和 $w_i$ 均为浮点数，单位为 MeV，保留六位小数。",
            "solution": "用户提供了一个有效且定义明确的问题，要求为相似重整化群 (SRG) 演化的束缚能代理构建数值误差预算。该问题在科学上植根于计算核物理的方法，提供了一个自洽的模型哈密顿量和一套清晰的待计算量定义。任务是数值化地实现 SRG 演化，计算指定的能量代理，并组合它们以估计各种数值误差来源。\n\n解决方案将遵循基于原理的设计，从基本物理和数学出发，然后详细说明计算算法。\n\n**1. 基本原理：相似重整化群**\n\n问题的核心在于量子力学哈密顿量 $H$ 的相似重整化群 (SRG) 演化。该演化由一个关于哈密顿量 $H_s$（作为流参数 $s \\ge 0$ 的函数）的微分方程描述：\n$$\n\\frac{dH_s}{ds} = [\\eta_s, H_s]\n$$\n其中 $[\\cdot, \\cdot]$ 是对易子，$\\eta_s$ 是流的生成元。初始条件是裸哈密顿量 $H_{s=0} = H_0$。此流构成一个幺正变换 $H_s = U_s H_0 U_s^\\dagger$，它保持哈密顿量的本征谱不变。\n\n生成元的选择是为了实现一个特定目标。在本问题中，生成元是 $\\eta_s = [T, H_s]$，其中 $T$ 是动能算符。这个被称为 Wegner 生成元的特定选择，会驱动哈密顿量在 $T$ 的本征基中趋向于带对角形式。低能（低动量）态和高能（高动量）态的解耦是 SRG 在此背景下的主要目的。\n\n流参数 $s$ 通过 $s = \\lambda^{-4}$ 与 SRG 分辨率标度 $\\lambda$ 相关联。因此，从 $s=0$ 演化到有限的 $s_{\\mathrm{final}}$ 等价于演化到一个有限的分辨率标度 $\\lambda = s_{\\mathrm{final}}^{-1/4}$。$s$ 的单位是 能量$^{-2}$，所以 $\\lambda$ 的单位是能量。问题陈述中指定将 $\\lambda$ 视为无量纲，这意味着所有能量标度都是相对于一个选定的单位来测量的，这里是兆电子伏 (MeV)。\n\n**2. 模型哈密顿量**\n\n我们在一个维度为 $N$ 的有限维希尔伯特空间中工作。初始哈密顿量是 $H_0 = T + V$。\n- 动能 $T$ 是一个对角矩阵，其分量为 $T_{ii} = E_0 + (i-1)\\Delta$，其中 $i=1, \\dots, N$。这代表了具有起始能量 $E_0$ 和恒定间距 $\\Delta$ 的离散化动能能级。\n- 势能 $V$ 是一个秩为 1 的吸引型可分离相互作用，由 $V = -g \\, \\mathbf{u}\\mathbf{u}^\\top$ 给出，其中 $g  0$ 是一个耦合常数。向量 $\\mathbf{u}$ 定义了势的形状因子，其分量为 $u_i = \\exp\\left(-\\frac{(i-1)^2}{2\\sigma^2}\\right)$。这种高斯形状因子抑制了指数差异大的态之间的耦合，模拟了在动量空间中局域的势。\n\n由于 $H_0$ 是一个实对称矩阵，并且如果 $H_s$ 是对称的，生成元 $\\eta_s = [T, H_s]$ 就是反对称的，因此演化后的哈密顿量 $H_s$ 对所有 $s$ 都保持实对称。\n\n**3. SRG 流方程的数值积分**\n\nSRG 流方程是关于 $H_s$ 矩阵元素的一阶常微分方程 (ODE) 组。为了数值求解，我们可以将 $N \\times N$ 矩阵 $H_s$ 展平为一个大小为 $N^2$ 的状态向量。ODE 的右侧 $\\frac{dH_s}{ds}$ 可以用矩阵代数计算：\n$$\n\\frac{dH_s}{ds} = [[T, H_s], H_s] = (T H_s - H_s T)H_s - H_s(T H_s - H_s T)\n$$\n我们使用数值 ODE 求解器（例如 `scipy.integrate` 库中的 `solve_ivp` 函数）将该系统从 $s=0$ 积分到 $s_{\\mathrm{final}} = \\lambda^{-4}$。积分的精度由相对和绝对公差 $(\\mathrm{rtol}, \\mathrm{atol})$ 控制。\n\n**4. 束缚能代理和误差估计**\n\n一旦获得演化后的哈密顿量 $H_\\lambda$，我们就计算束缚能代理。\n- 对于二体系统 ($A=2$)，代理是基态能量：$E_2(\\lambda) = \\min \\mathrm{eig}(H_\\lambda)$。由于 $H_\\lambda$ 是对称的，其本征值是实数，我们寻找最小的一个。\n- 对于三体系统 ($A=3$)，定义了一个玩具模型代理 $E_3(\\lambda) = c_3 \\, E_2(\\lambda) + \\beta \\, \\|O(H_\\lambda)\\|_F$。这里，$O(H_\\lambda)$ 是 $H_\\lambda$ 的非对角部分，$\\|\\cdot\\|_F$ 是 Frobenius 范数。这个代理模拟了这样一种思想：SRG 演化通过抑制非对角耦合，也抑制了对显式三体力的需求，而 $\\|O(H_\\lambda)\\|_F$ 的大小可作为这种抑制的诊断指标。\n\n该问题要求一个由三个分量组成的误差预算：\n- **多体截断误差 ($\\varepsilon_{\\mathrm{trunc}}$)**：$\\varepsilon_{\\mathrm{trunc}} = \\frac{1}{2}\\left|E_A(\\lambda_{\\mathrm{high}}) - E_A(\\lambda_{\\mathrm{low}})\\right|$。这衡量了结果对 SRG 分辨率标度 $\\lambda$ 的敏感性，$\\lambda$ 是因忽略模型中未明确包含的诱导多体力而产生误差的代理。对 $\\lambda$ 的更大依赖性表明更大的截断误差。\n- **ODE 积分误差 ($\\varepsilon_{\\mathrm{ode}}$)**：$\\varepsilon_{\\mathrm{ode}} = \\left|E_A^{\\mathrm{loose}}(\\lambda^\\star) - E_A^{\\mathrm{tight}}(\\lambda^\\star)\\right|$。这通过比较使用宽松和严格积分公差获得的结果来量化 ODE 求解器的数值误差。\n- **基底截断误差 ($\\varepsilon_{\\mathrm{basis}}$)**：$\\varepsilon_{\\mathrm{basis}} = \\left|E_A^{N_{\\mathrm{max}}}(\\lambda^\\star) - E_A^{N_{\\mathrm{ref}}}(\\lambda^\\star)\\right|$。这通过比较目标基底大小 $N_{\\mathrm{max}}$ 和一个更大的、更收敛的参考基底 $N_{\\mathrm{ref}}$ 的结果来估计由模型空间的有限维度引起的误差。\n\n总估计误差是这些分量的正交和：$\\varepsilon_{\\mathrm{tot}} = \\sqrt{\\varepsilon_{\\mathrm{trunc}}^2 + \\varepsilon_{\\mathrm{ode}}^2 + \\varepsilon_{\\mathrm{basis}}^2}$。\n\n**5. 算法实现策略**\n\n对于每个测试用例 $(A, \\lambda^\\star, N_{\\mathrm{max}})$，总体算法如下：\n1. 定义一个核心函数 `calculate_E_A_evolved(A, lambda_val, N, tol)`，它封装了给定参数集的整个计算过程：\n    a. 为给定的基底大小 $N$ 构建初始哈密顿量 $H_0$ 和动能矩阵 $T$。\n    b. 计算最终流参数 $s_{\\mathrm{final}} = \\lambda_{\\mathrm{val}}^{-4}$。\n    c. 使用 `scipy.integrate.solve_ivp` 以指定的公差将 SRG 流 ODE 从 $s=0$ 积分到 $s_{\\mathrm{final}}$。\n    d. 从得到的演化哈密顿量 $H_\\lambda$ 计算相应的束缚能代理 $E_A(\\lambda)$。\n2. 为了提高效率，`calculate_E_A_evolved` 的结果被记忆化（缓存）。这可以防止冗余计算，因为几个误差分量需要使用相同的参数进行计算（例如，$E_A^{N_{\\mathrm{ref}}, \\mathrm{tight}}(\\lambda^\\star)$ 同时用于 $\\varepsilon_{\\mathrm{ode}}$ 和 $\\varepsilon_{\\mathrm{basis}}$）。\n3. 对于每个测试用例，通过使用误差分量定义中指定的适当 $\\lambda$、$N$ 和公差参数调用记忆化的核心函数，来计算所需的能量代理。\n4. 从计算出的能量值计算 $\\varepsilon_{\\mathrm{trunc}}$、$\\varepsilon_{\\mathrm{ode}}$ 和 $\\varepsilon_{\\mathrm{basis}}$。\n5. 将它们进行正交和以求得 $\\varepsilon_{\\mathrm{tot}}$。\n6. 存储当前测试用例的四个误差分量，四舍五入到六位小数。\n7. 处理完所有测试用例后，将收集到的结果格式化为指定的最终输出字符串。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom math import sqrt\nfrom functools import lru_cache\n\n# Define global constants and parameters from the problem statement.\nE0 = 1.0  # MeV\nDELTA = 2.0  # MeV\nG = 6.0  # MeV\nSIGMA = 5.0\nC3 = 1.5\nBETA = 0.05\nTOL_TIGHT = (1e-10, 1e-12)\nTOL_LOOSE = (1e-6, 1e-8)\nDELTA_LAMBDA = 0.5\nN_REF = 32\n\n@lru_cache(maxsize=None)\ndef get_constants_for_N(N):\n    \"\"\"Pre-calculates and caches T and H0 for a given N.\"\"\"\n    i_indices = np.arange(N)\n    T_diag = E0 + i_indices * DELTA\n    T = np.diag(T_diag)\n    u_vec = np.exp(-(i_indices**2) / (2 * SIGMA**2))\n    V = -G * np.outer(u_vec, u_vec)\n    H0 = T + V\n    return T, H0\n\ndef srg_flow(s, H_flat, N, T):\n    \"\"\"\n    Defines the right-hand side of the SRG flow ODE.\n    dH/ds = [[T, H], H]\n    \"\"\"\n    H = H_flat.reshape((N, N))\n    eta = T @ H - H @ T\n    dHds = eta @ H - H @ eta\n    return dHds.flatten()\n\ndef get_E_A(H, A):\n    \"\"\"\n    Calculates the binding-energy proxy E_A from a given Hamiltonian H.\n    \"\"\"\n    # E_2(lambda) is the lowest eigenvalue of H_lambda.\n    # The Hamiltonian remains real-symmetric, so we can use eigh.\n    eigenvalues = np.linalg.eigh(H)[0]\n    E2 = np.min(eigenvalues)\n\n    if A == 2:\n        return E2\n    elif A == 3:\n        # E_3(lambda) = c_3 * E_2(lambda) + beta * ||O(H_lambda)||_F\n        O_H = H - np.diag(np.diag(H))\n        norm_O_H = np.linalg.norm(O_H, 'fro')\n        E3 = C3 * E2 + BETA * norm_O_H\n        return E3\n    else:\n        raise ValueError(\"Nucleon number A must be 2 or 3.\")\n\n@lru_cache(maxsize=None)\ndef calculate_E_A_evolved(A, lambda_val, N, tol):\n    \"\"\"\n    Calculates the SRG-evolved energy proxy E_A(lambda) for a given\n    nucleon number A, resolution scale lambda, basis size N, and ODE tolerance.\n    \"\"\"\n    T, H0 = get_constants_for_N(N)\n    \n    # s = lambda^{-4}\n    if lambda_val == 0:\n        raise ValueError(\"Lambda must be positive.\")\n    s_final = lambda_val**-4\n\n    sol = solve_ivp(\n        srg_flow,\n        [0, s_final],\n        H0.flatten(),\n        method='RK45',\n        args=(N, T),\n        rtol=tol[0],\n        atol=tol[1]\n    )\n\n    H_final = sol.y[:, -1].reshape((N, N))\n    return get_E_A(H_final, A)\n\ndef solve():\n    \"\"\"\n    Main function to execute the error budget calculation for all test cases.\n    \"\"\"\n    test_cases = [\n        # (A, lambda_star, N_max)\n        (3, 2.0, 16),\n        (3, 1.5, 8),\n        (2, 2.5, 16),\n        (3, 3.0, 24),\n    ]\n\n    all_results = []\n    for A, lambda_star, N_max in test_cases:\n        # Define lambda values for truncation error calculation\n        lambda_low = lambda_star - DELTA_LAMBDA\n        lambda_high = lambda_star + DELTA_LAMBDA\n\n        # 1. Calculate induced many-body truncation error (eps_trunc)\n        # Use large basis N_ref and tight tolerances.\n        E_high = calculate_E_A_evolved(A, lambda_high, N_REF, TOL_TIGHT)\n        E_low = calculate_E_A_evolved(A, lambda_low, N_REF, TOL_TIGHT)\n        eps_trunc = 0.5 * abs(E_high - E_low)\n\n        # 2. Calculate ODE integration error (eps_ode)\n        # Fix lambda and basis (N_ref), vary tolerance.\n        E_tight_ref = calculate_E_A_evolved(A, lambda_star, N_REF, TOL_TIGHT)\n        E_loose_ref = calculate_E_A_evolved(A, lambda_star, N_REF, TOL_LOOSE)\n        eps_ode = abs(E_loose_ref - E_tight_ref)\n\n        # 3. Calculate basis truncation error (eps_basis)\n        # Fix lambda and tolerance, vary basis size.\n        E_tight_max = calculate_E_A_evolved(A, lambda_star, N_max, TOL_TIGHT)\n        # E_tight_ref is already cached from the eps_ode calculation.\n        eps_basis = abs(E_tight_max - E_tight_ref)\n\n        # 4. Calculate total error (eps_tot)\n        eps_tot = sqrt(eps_trunc**2 + eps_ode**2 + eps_basis**2)\n\n        case_results = [eps_tot, eps_trunc, eps_ode, eps_basis]\n        all_results.append(case_results)\n\n    # Format output string as a list of lists with numbers rounded to 6 decimal places.\n    sublist_strs = []\n    for res in all_results:\n        num_strs = [f\"{v:.6f}\" for v in res]\n        sublist_strs.append(f\"[{','.join(num_strs)}]\")\n    final_output = f\"[{','.join(sublist_strs)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}