{
    "hands_on_practices": [
        {
            "introduction": "Before tackling the full complexity of numerical Similarity Renormalization Group (SRG) evolution, it is insightful to understand its fundamental mechanism in a simplified, analytically tractable setting. This practice guides you through the derivation of the SRG-evolved potential at leading order, revealing how a generator like $[T, H_s]$ leads to an exponential decay of off-diagonal matrix elements . Mastering this derivation provides a clear, foundational picture of how the SRG achieves decoupling.",
            "id": "3589989",
            "problem": "Consider the Similarity Renormalization Group (SRG) flow of a two-body Hamiltonian in the relative momentum basis, where the Hamiltonian at flow parameter $s$ is $H_{s} = T + V_{s}$. Work in units where the reduced mass satisfies $2\\mu = 1$, so that the kinetic energy operator is diagonal with $T(p) = p^{2}$ and has matrix elements $\\langle p | T | p' \\rangle = p^{2} \\delta(p - p')$. Use the generator $\\eta_{s} = [T, H_{s}]$, where $[\\cdot,\\cdot]$ denotes the commutator, which is the standard SRG generator choice. The SRG flow equation is $dH_{s}/ds = [\\eta_{s}, H_{s}]$, and we restrict attention to the two-body sector, neglecting induced many-body terms. Assume the initial interaction at $s=0$ is a rank-one separable potential $V_{0}(p, p') = g f(p) f(p')$, with coupling $g$ and smooth form factor $f(p)$ that decays for large $p$.\n\nIn the weak-coupling regime where $g$ is small, treat the SRG flow to leading order in $g$ (i.e., linearize the flow by neglecting terms that are quadratic in the interaction). Starting from the SRG definition and basic properties of commutators in the momentum representation, derive the leading-order SRG evolution equation for the off-diagonal interaction matrix elements $V_{s}(p, p')$ with $p \\neq p'$. Solve this leading-order flow exactly to obtain the closed-form analytic expression for $V_{s}(p, p')$ in terms of $g$, $f(p)$, $f(p')$, $p$, $p'$, and $s$.\n\nYour final answer must be a single closed-form analytic expression for $V_{s}(p, p')$ as a function of these variables. No numerical evaluation is required.",
            "solution": "The problem statement is validated as scientifically grounded, well-posed, objective, and self-contained. All provided information is standard within the framework of the Similarity Renormalization Group (SRG) in theoretical nuclear physics. The problem is thus deemed valid.\n\nWe begin with the SRG flow equation for the Hamiltonian $H_s$, given by:\n$$\n\\frac{dH_s}{ds} = [\\eta_s, H_s]\n$$\nThe generator $\\eta_s$ is defined as the commutator of the kinetic energy operator $T$ and the full Hamiltonian $H_s = T + V_s$:\n$$\n\\eta_s = [T, H_s] = [T, T + V_s] = [T, T] + [T, V_s] = 0 + [T, V_s] = [T, V_s]\n$$\nSubstituting this expression for the generator back into the flow equation yields:\n$$\n\\frac{dH_s}{ds} = [[T, V_s], H_s]\n$$\nWe now expand the right-hand side using $H_s = T + V_s$:\n$$\n\\frac{dH_s}{ds} = [[T, V_s], T + V_s] = [[T, V_s], T] + [[T, V_s], V_s]\n$$\nThe problem specifies that we should work to leading order in the coupling constant $g$, which is equivalent to linearizing the flow in the interaction potential $V_s$. The first term, $[[T, V_s], T]$, is linear in $V_s$ (and thus in $g$). The second term, $[[T, V_s], V_s]$, involves two instances of $V_s$ and is therefore quadratic in the interaction (of order $g^2$). According to the problem's directive, we must neglect this quadratic term. The linearized flow equation is thus:\n$$\n\\frac{dH_s}{ds} \\approx [[T, V_s], T]\n$$\nSince the Hamiltonian is $H_s = T + V_s$ and the kinetic energy operator $T$ is independent of the flow parameter $s$ (i.e., $dT/ds = 0$), the flow equation for the potential $V_s$ is:\n$$\n\\frac{dV_s}{ds} = \\frac{d(H_s - T)}{ds} = \\frac{dH_s}{ds} - \\frac{dT}{ds} = [[T, V_s], T]\n$$\nTo solve this operator equation, we project it onto the continuous relative momentum basis $|\\Psi_p\\rangle$, which we denote simply as $|p\\rangle$. We seek the evolution of the matrix elements $V_s(p, p') = \\langle p | V_s | p' \\rangle$. The equation for the matrix elements becomes:\n$$\n\\frac{d V_s(p, p')}{ds} = \\langle p | [[T, V_s], T] | p' \\rangle\n$$\nWe expand the double commutator:\n$$\n[[T, V_s], T] = (TV_s - V_sT)T - T(TV_s - V_sT) = TV_sT - V_sT^2 - T^2V_s + TV_sT = 2TV_sT - T^2V_s - V_sT^2\n$$\nNow we evaluate the matrix elements of each term. The kinetic energy operator $T$ is diagonal in the momentum basis, with eigenvalues $p^2$. Its action on the basis states is $T|p'\\rangle = p'^2|p'\\rangle$ and $\\langle p|T = p^2\\langle p|$.\nThe matrix elements are:\n$$\n\\langle p | T^2V_s | p' \\rangle = p^4 \\langle p | V_s | p' \\rangle = p^4 V_s(p, p')\n$$\n$$\n\\langle p | V_sT^2 | p' \\rangle = p'^4 \\langle p | V_s | p' \\rangle = p'^4 V_s(p, p')\n$$\n$$\n\\langle p | TV_sT | p' \\rangle = p^2 p'^2 \\langle p | V_s | p' \\rangle = p^2 p'^2 V_s(p, p')\n$$\nSubstituting these expressions back into the equation for $dV_s(p, p')/ds$:\n$$\n\\frac{d V_s(p, p')}{ds} = 2(p^2 p'^2)V_s(p, p') - p^4 V_s(p, p') - p'^4 V_s(p, p')\n$$\nFactoring out $V_s(p, p')$ and rearranging the terms gives:\n$$\n\\frac{d V_s(p, p')}{ds} = -(p^4 - 2p^2 p'^2 + p'^4) V_s(p, p')\n$$\nThe term in the parenthesis is a perfect square:\n$$\n\\frac{d V_s(p, p')}{ds} = -(p^2 - p'^2)^2 V_s(p, p')\n$$\nThis is a first-order linear ordinary differential equation in the flow parameter $s$ for the function $V_s(p, p')$. For any given pair of momenta $(p, p')$, the coefficient $-(p^2 - p'^2)^2$ is a constant. The general solution to an equation of the form $dy/ds = k y$ is $y(s) = y(0) \\exp(ks)$.\nApplying this to our equation, we get:\n$$\nV_s(p, p') = V_0(p, p') \\exp\\left(-(p^2 - p'^2)^2 s\\right)\n$$\nThe problem provides the initial condition for the potential at $s=0$: a rank-one separable potential $V_0(p, p') = g f(p) f(p')$. Substituting this initial condition into our solution yields the final closed-form expression for the evolved potential matrix elements:\n$$\nV_s(p, p') = g f(p) f(p') \\exp\\left(-(p^2 - p'^2)^2 s\\right)\n$$\nThis result is valid for off-diagonal elements where $p \\neq p'$. The exponential factor shows that as the flow parameter $s$ increases, the off-diagonal matrix elements of the potential are suppressed, driving the Hamiltonian matrix towards a diagonal (or band-diagonal) form, which is the characteristic feature of the SRG evolution with this generator.",
            "answer": "$$\n\\boxed{g f(p) f(p') \\exp\\left(-\\left(p^2 - p'^2\\right)^2 s\\right)}\n$$"
        },
        {
            "introduction": "With a theoretical understanding in place, this exercise transitions to the practical implementation of the SRG flow for a two-body Hamiltonian in momentum space. Your task is to discretize the Hamiltonian, numerically integrate the flow equation, and perform crucial validation checks . By confirming the invariance of eigenvalues and scattering phase shifts, you will not only build a working SRG code but also verify that your numerical implementation correctly preserves the underlying unitary nature of the transformation.",
            "id": "3589984",
            "problem": "Consider the Similarity Renormalization Group (SRG) evolution for a two-body Hamiltonian in a momentum-space, partial-wave, three-dimensional, spinless, $s$-wave channel under natural units where $\\hbar = 1$ and the reduced mass is chosen such that $2\\mu = 1$. In these units, the kinetic energy is $T(k) = k^2$. Work in the continuum momentum representation with the radial measure appropriate for three-dimensional $s$-wave scattering, where integrals have measure $k^2 \\, \\mathrm{d}k/(2\\pi^2)$. Discretize the continuum on a finite grid using Gaussian-Legendre quadrature mapped to $k \\in [0,k_{\\max}]$ with nodes $\\{k_i\\}_{i=1}^N$ and weights $\\{w_i\\}_{i=1}^N$.\n\nDefine a rank-one separable potential $V(k,k') = -\\lambda \\, g(k) \\, g(k')$ with $g(k) = 1/(k^2 + \\beta^2)$ and $\\lambda > 0$, $\\beta > 0$ constant parameters. The full Hamiltonian kernel is $H(k,k') = T(k) \\, \\delta(k-k') + V(k,k')$. Introduce the SRG flow using the kinetic-energy generator $G = T$ so that the SRG equation is\n$$\n\\frac{\\mathrm{d}H_s}{\\mathrm{d}s} = [\\eta_s, H_s], \\quad \\eta_s = [G,H_s],\n$$\nwhere $[\\cdot,\\cdot]$ denotes the commutator. The SRG parameter $s \\ge 0$ is a flow parameter controlling the decoupling.\n\nTo implement numerically stable operator algebra in the discretized continuum, use the weighted-orthonormal representation defined by the diagonal scaling matrix $S = \\mathrm{diag}\\left(\\sqrt{w_i \\, m_i}\\right)$ with $m_i = k_i^2/(2\\pi^2)$. Map any kernel $O(k,k')$ to its orthonormal matrix representation $\\tilde{O}$ by $\\tilde{O} = S \\, O \\, S$. In this orthonormal representation, the kinetic operator is diagonal, $\\tilde{T}_{ij} = k_i^2 \\, \\delta_{ij}$, and standard matrix multiplication corresponds to continuum operator composition.\n\nFor scattering, consider the reactance (K) matrix at energy $E = k_0^2$ for an external on-shell momentum $k_0$ equal to one of the grid points $k_{i_0}$. The principal value resolvent is diagonal in this representation and defined by\n$$\n\\tilde{G}_0^{\\mathrm{P}}(E)_{jj} = \\begin{cases}\n\\frac{1}{E - k_j^2}, & \\text{if } j \\ne i_0,\\\\\n0, & \\text{if } j = i_0,\n\\end{cases}\n$$\nwhich enforces the Cauchy principal value at the singular point. The K-matrix in the orthonormal representation satisfies\n$$\n\\tilde{K} = \\tilde{V} + \\tilde{V} \\, \\tilde{G}_0^{\\mathrm{P}} \\, \\tilde{K},\n$$\nand can be obtained by solving the linear system $(I - \\tilde{V} \\, \\tilde{G}_0^{\\mathrm{P}}) \\, \\tilde{K} = \\tilde{V}$. The physical on-shell kernel value is recovered by undoing the scaling:\n$$\nK(k_{i_0}, k_{i_0}; E) = \\frac{\\tilde{K}_{i_0 i_0}}{w_{i_0} \\, m_{i_0}}.\n$$\nWith the chosen normalization and units, the $s$-wave phase shift $\\delta(k_0)$ in radians is related to the on-shell K-matrix by\n$$\n\\tan \\delta(k_0) = - \\mu \\, k_0 \\, K(k_0,k_0; E),\n$$\nwith $\\mu = \\tfrac{1}{2}$.\n\nTasks:\n1. Discretize the momentum grid on $[0,k_{\\max}]$ using Gaussian-Legendre quadrature with $N$ points. Construct the scaling matrix $S$, the orthonormal kinetic-energy matrix $\\tilde{T}$, and the orthonormal potential matrix $\\tilde{V}$ corresponding to the separable form $V(k,k')$.\n2. Implement SRG evolution from $s=0$ to a target $s=s_{\\mathrm{target}}$ using the kinetic generator, integrating\n$$\n\\frac{\\mathrm{d}\\tilde{H}_s}{\\mathrm{d}s} = [[\\tilde{T}, \\tilde{H}_s], \\tilde{H}_s],\n$$\nstarting from $\\tilde{H}_0 = \\tilde{T} + \\tilde{V}$. Ensure numerical integration preserves Hermiticity to numerical tolerance.\n3. Validate the numerical implementation by checking invariants and convergence:\n   - Eigenvalue invariance: The spectrum of $\\tilde{H}_s$ must be invariant under unitary SRG evolution. Quantify the maximum absolute difference between sorted eigenvalues of $\\tilde{H}_{s=0}$ and $\\tilde{H}_{s=s_{\\mathrm{target}}}$.\n   - Phase-shift invariance: Using the K-matrix method with principal value as defined, compute the $s$-wave phase shift $\\delta(k_0)$ in radians at $s=0$ and $s=s_{\\mathrm{target}}$, and quantify the absolute difference $|\\delta_{s=0} - \\delta_{s=s_{\\mathrm{target}}}|$.\n   - Convergence with grid resolution: Compare these two error measures at a coarse resolution $N_{\\mathrm{coarse}}$ and a finer resolution $N_{\\mathrm{fine}}$ to test whether errors decrease with increasing $N$; report boolean values indicating whether the finer grid yields smaller errors.\n\nUse the following fixed physical and numerical parameters in natural units:\n- $\\lambda = 5.0$, $\\beta = 1.0$.\n- $k_{\\max} = 8.0$.\n- Choose $s_{\\mathrm{target}} = 0.02$.\n- Use $N_{\\mathrm{coarse}} = 32$ and $N_{\\mathrm{fine}} = 64$.\n- For the phase shift, choose the on-shell momentum as the grid node with index $i_0 = \\lfloor N/4 \\rfloor$. The phase shift must be expressed in radians.\n\nYour program should compute the following for the specified test suite:\n- Test case 1 (happy path): With $N = N_{\\mathrm{fine}}$, compute the maximum absolute eigenvalue difference between $s=0$ and $s=s_{\\mathrm{target}}$.\n- Test case 2 (happy path): With $N = N_{\\mathrm{fine}}$, compute the absolute phase-shift difference at $k_0 = k_{i_0}$ in radians between $s=0$ and $s=s_{\\mathrm{target}}$.\n- Test case 3 (convergence check for eigenvalues): Compute the maximum absolute eigenvalue difference for $N = N_{\\mathrm{coarse}}$ and $N = N_{\\mathrm{fine}}$; return a boolean indicating whether the error is smaller at $N = N_{\\mathrm{fine}}$.\n- Test case 4 (convergence check for phase shifts): Compute the absolute phase-shift difference for $N = N_{\\mathrm{coarse}}$ and $N = N_{\\mathrm{fine}}$; return a boolean indicating whether the error is smaller at $N = N_{\\mathrm{fine}}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order described above, for the four test cases:\n$$\n[\\Delta E_{\\max}, \\Delta \\delta, \\mathrm{eig\\_conv}, \\mathrm{phase\\_conv}],\n$$\nwhere $\\Delta E_{\\max}$ and $\\Delta \\delta$ are floating-point numbers, and $\\mathrm{eig\\_conv}$ and $\\mathrm{phase\\_conv}$ are boolean values.",
            "solution": "The problem requires the implementation and validation of the Similarity Renormalization Group (SRG) evolution for a two-body Hamiltonian in a discretized momentum space. The validation involves checking the invariance of eigenvalues and scattering phase shifts under the SRG flow. The solution proceeds in four stages: (1) discretization of the continuum Hamiltonian, (2) numerical integration of the SRG flow equation, (3) calculation of physical observables (eigenvalues and phase shifts), and (4) analysis of numerical convergence.\n\n### Step 1: Discretization and Matrix Representation\n\nThe continuous momentum-space Hamiltonian must be represented as a finite-dimensional matrix to facilitate numerical computation. This is achieved using Gaussian-Legendre quadrature to discretize the momentum integral.\n\nThe momentum variable $k \\in [0, k_{\\max}]$ is discretized onto a grid of $N$ points $\\{k_i\\}_{i=1}^N$. We use an $N$-point Gaussian-Legendre quadrature rule defined on the interval $[-1, 1]$ with nodes $\\{x_j'\\}_{j=1}^N$ and weights $\\{w_j'\\}_{j=1}^N$. These are mapped to the interval $[0, k_{\\max}]$ via the transformation $k(x) = \\frac{k_{\\max}}{2}(x+1)$. The quadrature nodes $k_i$ and weights $w_i$ are then:\n$$\nk_i = \\frac{k_{\\max}}{2}(x_i' + 1)\n$$\n$$\nw_i = w_i' \\frac{k_{\\max}}{2}\n$$\nThe integral of a function $f(k)$ is approximated as $\\int_0^{k_{\\max}} f(k) \\, \\mathrm{d}k \\approx \\sum_{i=1}^N w_i f(k_i)$.\n\nThe problem specifies an orthonormal representation where matrix multiplication corresponds to continuum operator composition. The integral measure for $s$-wave scattering is $m(k) \\mathrm{d}k = \\frac{k^2}{2\\pi^2} \\mathrm{d}k$. We define a diagonal scaling matrix $S$ with elements $S_{ii} = \\sqrt{w_i m_i}$, where $m_i = m(k_i) = k_i^2/(2\\pi^2)$.\n\nThe orthonormal matrix representation $\\tilde{O}$ of an operator $\\hat{O}$ is given by its matrix elements in a basis of orthonormal functions. For the operators in this problem, this leads to the following matrix forms:\n\n1.  **Kinetic Energy Operator:** The kinetic energy $\\hat{T}$ is a local operator, with kernel $T(k, k') = k^2 \\delta(k-k')$. Its matrix representation in the orthonormal basis is diagonal:\n    $$\n    \\tilde{T}_{ij} = k_i^2 \\delta_{ij}\n    $$\n    This matrix is denoted $\\tilde{T}$.\n\n2.  **Potential Energy Operator:** The potential is a non-local, rank-one separable operator with kernel $V(k,k') = -\\lambda g(k) g(k')$, where $g(k) = 1/(k^2 + \\beta^2)$. Its matrix representation is constructed by first forming the matrix $V_{ij} = V(k_i, k_j)$ and then applying the scaling transformation: $\\tilde{V} = SVS$.\n    Let $\\mathbf{g}$ be a column vector with elements $g_i = g(k_i) = 1/(k_i^2+\\beta^2)$. The matrix $V$ is then $V = -\\lambda \\mathbf{g} \\mathbf{g}^T$.\n    The orthonormal potential matrix $\\tilde{V}$ becomes:\n    $$\n    \\tilde{V} = S (-\\lambda \\mathbf{g} \\mathbf{g}^T) S = -\\lambda (S\\mathbf{g})(S\\mathbf{g})^T\n    $$\n    Letting $\\tilde{\\mathbf{g}} = S\\mathbf{g}$, whose elements are $\\tilde{g}_i = S_{ii} g_i = \\sqrt{w_i k_i^2/(2\\pi^2)} g_i$, the potential matrix is $\\tilde{V} = -\\lambda \\tilde{\\mathbf{g}} \\tilde{\\mathbf{g}}^T$.\n\nThe initial Hamiltonian at flow parameter $s=0$ is $\\tilde{H}_0 = \\tilde{T} + \\tilde{V}$. Since $\\tilde{T}$ is diagonal and $\\tilde{V}$ is real and symmetric, $\\tilde{H}_0$ is a real, symmetric (and thus Hermitian) matrix.\n\n### Step 2: SRG Evolution\n\nThe SRG evolution of the Hamiltonian matrix $\\tilde{H}_s$ is governed by the ordinary differential equation (ODE):\n$$\n\\frac{\\mathrm{d}\\tilde{H}_s}{\\mathrm{d}s} = [[\\tilde{T}, \\tilde{H}_s], \\tilde{H}_s]\n$$\nThe commutator with the diagonal matrix $\\tilde{T}$ is efficiently computed as $([\\tilde{T}, \\tilde{H}_s])_{ij} = (\\tilde{T}_{ii} - \\tilde{T}_{jj})(\\tilde{H}_s)_{ij} = (k_i^2 - k_j^2)(\\tilde{H}_s)_{ij}$. Let $\\eta_s = [\\tilde{T}, \\tilde{H}_s]$. The ODE is then $\\frac{\\mathrm{d}\\tilde{H}_s}{\\mathrm{d}s} = [\\eta_s, \\tilde{H}_s]$.\n\nThis matrix ODE is integrated numerically from $s=0$ to $s=s_{\\mathrm{target}}$ starting with the initial condition $\\tilde{H}_0$. We employ a standard adaptive step-size ODE solver, such as `RK45`, available in `scipy.integrate.solve_ivp`. Since the generator $\\tilde{T}$ is Hermitian, the flow is unitary and preserves the spectrum of $\\tilde{H}_s$. The operator $\\eta_s$ is anti-Hermitian, which ensures that the derivative $\\frac{\\mathrm{d}\\tilde{H}_s}{\\mathrm{d}s}$ is Hermitian, and thus the Hermiticity of $\\tilde{H}_s$ is preserved throughout the evolution. Small numerical errors that break the symmetry of the matrix can be corrected by taking the symmetric part of the final matrix: $\\tilde{H}_{s_{\\mathrm{target}}} \\leftarrow \\frac{1}{2}(\\tilde{H}_{s_{\\mathrm{target}}} + \\tilde{H}_{s_{\\mathrm{target}}}^T)$.\n\n### Step 3: Calculation of Invariants\n\nTo validate the implementation, we check two invariants of the SRG flow: the eigenvalues of the Hamiltonian and the on-shell scattering observables (phase shifts).\n\n1.  **Eigenvalue Invariance:** The eigenvalues of $\\tilde{H}_s$ must be independent of the flow parameter $s$. We compute the eigenvalues of the initial Hamiltonian $\\tilde{H}_0$ and the final evolved Hamiltonian $\\tilde{H}_{s_{\\mathrm{target}}}$ using a numerical eigensolver for symmetric matrices. The sorted lists of eigenvalues are compared, and the maximum absolute difference is calculated as the error measure:\n    $$\n    \\Delta E_{\\max} = \\max_i |\\lambda_i(s=0) - \\lambda_i(s=s_{\\mathrm{target}})|\n    $$\n\n2.  **Phase-Shift Invariance:** The scattering phase shifts, being physical observables, must also be invariant. The phase shift $\\delta(k_0)$ at on-shell momentum $k_0$ (corresponding to energy $E=k_0^2$) is calculated using the K-matrix formalism.\n    First, the evolved potential matrix is extracted from the evolved Hamiltonian: $\\tilde{V}_s = \\tilde{H}_s - \\tilde{T}$.\n    The K-matrix $\\tilde{K}_s$ is obtained by solving the Lippmann-Schwinger-type equation $(I - \\tilde{V}_s \\tilde{G}_0^{\\mathrm{P}}) \\tilde{K}_s = \\tilde{V}_s$, where $\\tilde{G}_0^{\\mathrm{P}}$ is the diagonal principal-value resolvent matrix. For a chosen on-shell momentum $k_0 = k_{i_0}$ (where $i_0 = \\lfloor N/4 \\rfloor$ is the grid index), its elements are:\n    $$\n    (\\tilde{G}_0^{\\mathrm{P}}(E))_{jj} = \\begin{cases}\n    \\frac{1}{E - k_j^2}, & \\text{if } j \\ne i_0 \\\\\n    0, & \\text{if } j = i_0\n    \\end{cases}\n    $$\n    with $E = k_{i_0}^2$. This is a system of linear equations for the matrix $\\tilde{K}_s$, which can be solved numerically.\n    The physical on-shell K-matrix element is recovered by undoing the basis scaling:\n    $$\n    K_s(k_{i_0}, k_{i_0}; E) = \\frac{(\\tilde{K}_s)_{i_0 i_0}}{w_{i_0} m_{i_0}} = \\frac{(\\tilde{K}_s)_{i_0 i_0}}{w_{i_0} k_{i_0}^2 / (2\\pi^2)}\n    $$\n    The $s$-wave phase shift $\\delta_s(k_0)$ is then given by the relation:\n    $$\n    \\delta_s(k_0) = \\arctan(-\\mu k_0 K_s(k_0, k_0; E))\n    $$\n    where $\\mu = 1/2$. This calculation is performed for $s=0$ (using $\\tilde{H}_0$) and $s=s_{\\mathrm{target}}$ (using $\\tilde{H}_{s_{\\mathrm{target}}}$), and the absolute difference $\\Delta \\delta = |\\delta_0 - \\delta_{s_{\\mathrm{target}}}|$ is computed.\n\n### Step 4: Numerical Procedure and Convergence Analysis\n\nThe entire procedure is encapsulated in a function that takes the grid size $N$ as input. This function performs the discretization, SRG evolution, and calculation of the two error metrics, $\\Delta E_{\\max}$ and $\\Delta \\delta$.\n\nTo complete the required tasks:\n- The function is called for $N=N_{\\mathrm{fine}}=64$. The resulting $\\Delta E_{\\max}$ and $\\Delta \\delta$ are the first two required outputs.\n- The function is also called for $N=N_{\\mathrm{coarse}}=32$. Let the errors be $\\Delta E_{\\max}^{(\\mathrm{coarse})}$ and $\\Delta\\delta^{(\\mathrm{coarse})}$, and those for the fine grid be $\\Delta E_{\\max}^{(\\mathrm{fine})}$ and $\\Delta\\delta^{(\\mathrm{fine})}$.\n- The convergence checks are boolean values defined as:\n    - $\\mathrm{eig\\_conv} = (\\Delta E_{\\max}^{(\\mathrm{fine})} < \\Delta E_{\\max}^{(\\mathrm{coarse})})$\n    - $\\mathrm{phase\\_conv} = (\\Delta\\delta^{(\\mathrm{fine})} < \\Delta\\delta^{(\\mathrm{coarse})})$\nThese four values constitute the final output. Decreasing errors with a finer grid discretization indicate that the numerical errors (from quadrature, ODE integration, and linear algebra) are controlled and converge towards zero as expected.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the SRG calculations and produce the final output.\n    \"\"\"\n\n    # Fixed physical and numerical parameters\n    LAMBDA = 5.0\n    BETA = 1.0\n    K_MAX = 8.0\n    S_TARGET = 0.02\n    MU = 0.5\n    N_COARSE = 32\n    N_FINE = 64\n\n    def run_srg_calculation(N: int):\n        \"\"\"\n        Performs the full SRG calculation for a given grid size N.\n\n        Args:\n            N (int): Number of momentum grid points.\n\n        Returns:\n            tuple: A tuple containing:\n                - delta_E_max (float): Maximum absolute eigenvalue difference.\n                - delta_phase_shift (float): Absolute phase shift difference.\n        \"\"\"\n        # --- 1. Discretization and Matrix Construction ---\n        \n        # Get Gauss-Legendre quadrature nodes and weights for [-1, 1]\n        x_nodes, x_weights = roots_legendre(N)\n        \n        # Map nodes and weights to [0, K_MAX]\n        k_nodes = K_MAX / 2.0 * (x_nodes + 1.0)\n        k_weights = K_MAX / 2.0 * x_weights\n\n        # Construct measure factor and scaling matrix S\n        m_i = k_nodes**2 / (2.0 * np.pi**2)\n        s_diag = np.sqrt(k_weights * m_i)\n        \n        # Kinetic energy matrix (diagonal)\n        t_tilde = np.diag(k_nodes**2)\n\n        # Potential energy matrix (rank-one separable)\n        g_vec = 1.0 / (k_nodes**2 + BETA**2)\n        g_tilde_vec = s_diag * g_vec\n        v_tilde = -LAMBDA * np.outer(g_tilde_vec, g_tilde_vec)\n        \n        # Initial Hamiltonian at s=0\n        h0_tilde = t_tilde + v_tilde\n\n        # --- 2. SRG Evolution ---\n        \n        def srg_ode(s, h_flat, t_diag_sq):\n            \"\"\"RHS of the SRG ODE for the ODE solver.\"\"\"\n            h_s = h_flat.reshape((N, N))\n            # Commutator [T, H] = T H - H T\n            # Since T is diagonal, (k_i^2 - k_j^2) H_ij\n            diff_t_sq = t_diag_sq[:, None] - t_diag_sq[None, :]\n            eta = diff_t_sq * h_s\n            # Commutator [eta, H]\n            dh_ds = eta @ h_s - h_s @ eta\n            return dh_ds.flatten()\n        \n        # Integrate the ODE\n        t_diag_sq = np.diag(t_tilde)\n        sol = solve_ivp(\n            srg_ode,\n            [0, S_TARGET],\n            h0_tilde.flatten(),\n            args=(t_diag_sq,),\n            method='RK45', \n            rtol=1e-8, \n            atol=1e-8\n        )\n        \n        # Evolved Hamiltonian at s=S_TARGET\n        hs_tilde_flat = sol.y[:, -1]\n        hs_tilde = hs_tilde_flat.reshape((N, N))\n        \n        # Enforce symmetry to remove numerical noise\n        hs_tilde = 0.5 * (hs_tilde + hs_tilde.T)\n\n        # --- 3. Invariant Checks ---\n        \n        # Eigenvalue invariance\n        evals0 = np.linalg.eigvalsh(h0_tilde)\n        evals_s = np.linalg.eigvalsh(hs_tilde)\n        delta_E_max = np.max(np.abs(evals0 - evals_s))\n        \n        def calculate_phase_shift(h_matrix):\n            \"\"\"Calculates the s-wave phase shift from a given Hamiltonian matrix.\"\"\"\n            v_matrix = h_matrix - t_tilde\n            i0 = N // 4  # On-shell index\n            k0 = k_nodes[i0]\n            E = k0**2\n            \n            # Principal value resolvent\n            g0p_diag = np.zeros(N)\n            for j in range(N):\n                if j != i0:\n                    g0p_diag[j] = 1.0 / (E - k_nodes[j]**2)\n            g0p = np.diag(g0p_diag)\n            \n            # Solve linear system for K-matrix: (I - V G0P) K = V\n            A = np.eye(N) - v_matrix @ g0p\n            try:\n                k_matrix = np.linalg.solve(A, v_matrix)\n            except np.linalg.LinAlgError:\n                return np.nan # In case of singularity\n            \n            # On-shell K-matrix element\n            k_onshell_tilde = k_matrix[i0, i0]\n            \n            # Rescale to physical value\n            w_i0 = k_weights[i0]\n            m_i0 = k0**2 / (2 * np.pi**2)\n            if w_i0 * m_i0 == 0: return np.nan\n            k_onshell_phys = k_onshell_tilde / (w_i0 * m_i0)\n            \n            # Calculate phase shift\n            tan_delta = -MU * k0 * k_onshell_phys\n            delta = np.arctan(tan_delta)\n            return delta\n        \n        # Phase shift invariance\n        delta_0 = calculate_phase_shift(h0_tilde)\n        delta_s = calculate_phase_shift(hs_tilde)\n        delta_phase_shift = np.abs(delta_0 - delta_s)\n        \n        return delta_E_max, delta_phase_shift\n\n    # --- 4. Run calculations and collect results ---\n    \n    # Run for coarse and fine grids\n    err_E_coarse, err_d_coarse = run_srg_calculation(N_COARSE)\n    err_E_fine, err_d_fine = run_srg_calculation(N_FINE)\n\n    # Prepare final results for output\n    # Test case 1: ΔE_max for N_fine\n    delta_E_max_fine = err_E_fine\n    # Test case 2: Δδ for N_fine\n    delta_phase_shift_fine = err_d_fine\n    # Test case 3: Eigenvalue error convergence\n    eig_conv = err_E_fine < err_E_coarse\n    # Test case 4: Phase shift error convergence\n    phase_conv = err_d_fine < err_d_coarse\n\n    results = [delta_E_max_fine, delta_phase_shift_fine, eig_conv, phase_conv]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The final stage of a computational physics project is often the quantification of uncertainties. This capstone practice challenges you to construct a comprehensive error budget for an SRG-evolved observable, using a simplified model for a many-body system . You will learn to systematically disentangle and estimate the distinct error contributions from basis truncation, ODE integration, and the approximation of omitted induced many-body forces, a critical skill for producing reliable scientific results.",
            "id": "3589919",
            "problem": "You are tasked with constructing a comprehensive numerical error budget for Similarity Renormalization Group (SRG)-evolved binding-energy proxies $E_A(\\lambda)$, where $A$ denotes the nucleon number and $\\lambda$ is the SRG resolution scale. The computational setting must be self-contained and purely mathematical, yet consistent with the core ideas used in computational nuclear physics. Use the following model and definitions.\n\nFoundational definitions:\n- The Similarity Renormalization Group (SRG) flow evolves a Hamiltonian $H_s$ with flow parameter $s$ according to the differential equation\n$$\\frac{dH_s}{ds} = [\\eta_s, H_s],$$\nwhere $[\\cdot,\\cdot]$ denotes a commutator and $\\eta_s$ is a generator. In this task, use the kinetic-energy generator $\\eta_s = [T, H_s]$, with $T$ a diagonal kinetic-energy proxy.\n- Relate the SRG resolution scale $\\lambda$ to the flow parameter via $s = \\lambda^{-4}$. Treat $\\lambda$ as dimensionless in this problem and treat energies in megaelectronvolts (MeV).\n- The initial Hamiltonian is defined as $H_0 = T + V$, with $T$ a diagonal matrix and $V$ a rank-one, attractive separable interaction $V = -g \\, \\mathbf{u}\\mathbf{u}^\\top$, where $g$ is a positive coupling constant and $\\mathbf{u}$ is a fixed shape vector with entries $u_i = \\exp\\!\\big(-\\frac{(i-1)^2}{2\\sigma^2}\\big)$ for $i = 1,2,\\dots,N$, $N$ being the basis dimension. The diagonal $T$ has entries $T_{ii} = E_0 + (i-1)\\Delta$, with $E_0$ and $\\Delta$ fixed positive constants (all energies in MeV).\n- The SRG-evolved Hamiltonian at resolution $\\lambda$ is obtained by integrating the flow from $s=0$ to $s=\\lambda^{-4}$, yielding $H_\\lambda$.\n\nBinding-energy proxies:\n- For the two-body system ($A=2$), define the binding-energy proxy as the lowest eigenvalue of $H_\\lambda$:\n$$E_2(\\lambda) = \\min \\mathrm{eig}(H_\\lambda).$$\n- For the three-body system ($A=3$), use the proxy\n$$E_3(\\lambda) = c_3 \\, E_2(\\lambda) + \\beta \\, \\|O(H_\\lambda)\\|_F,$$\nwhere $c_3$ and $\\beta$ are fixed positive constants, $O(H_\\lambda)$ denotes the off-diagonal part of $H_\\lambda$ (i.e., the matrix with the diagonal entries set to zero), and $\\|\\cdot\\|_F$ denotes the Frobenius norm. This construction captures the qualitative feature that omitted induced three-body forces are correlated with off-diagonal coupling strength, which is reduced under SRG evolution.\n\nError budget components:\n- Induced many-body truncation ($A>2$) error estimate:\n  Hold numerical tolerances tight and the basis large. Measure the $\\lambda$-sensitivity by evaluating $E_A(\\lambda)$ at two nearby scales $\\lambda_{\\mathrm{low}}$ and $\\lambda_{\\mathrm{high}}$; define\n  $$\\varepsilon_{\\mathrm{trunc}} = \\frac{1}{2}\\left|E_A(\\lambda_{\\mathrm{high}}) - E_A(\\lambda_{\\mathrm{low}})\\right|.$$\n- Ordinary Differential Equation (ODE) integration error estimate:\n  At fixed $\\lambda^\\star$, basis $N_{\\mathrm{ref}}$, and generator choice as specified, compute $E_A(\\lambda^\\star)$ with a tight tolerance and a loose tolerance, and define\n  $$\\varepsilon_{\\mathrm{ode}} = \\left|E_A^{\\mathrm{loose}}(\\lambda^\\star) - E_A^{\\mathrm{tight}}(\\lambda^\\star)\\right|.$$\n- Basis truncation error estimate:\n  At fixed $\\lambda^\\star$ and tight tolerances, compare results at a target basis dimension $N_{\\mathrm{max}}$ and a larger reference basis $N_{\\mathrm{ref}}$, and define\n  $$\\varepsilon_{\\mathrm{basis}} = \\left|E_A^{N_{\\mathrm{max}}}(\\lambda^\\star) - E_A^{N_{\\mathrm{ref}}}(\\lambda^\\star)\\right|.$$\n- Combine error components in quadrature to obtain the total error:\n  $$\\varepsilon_{\\mathrm{tot}} = \\sqrt{\\varepsilon_{\\mathrm{trunc}}^2 + \\varepsilon_{\\mathrm{ode}}^2 + \\varepsilon_{\\mathrm{basis}}^2}.$$\n\nNumerical and physical conventions:\n- All energies must be expressed in megaelectronvolts (MeV).\n- Use the following fixed model parameters for all computations: $E_0 = 1.0$, $\\Delta = 2.0$, $g = 6.0$, $\\sigma = 5.0$, $c_3 = 1.5$, $\\beta = 0.05$.\n- Use tight and loose ODE integration tolerances given by $(\\mathrm{rtol}, \\mathrm{atol})_{\\mathrm{tight}} = (10^{-10}, 10^{-12})$ and $(\\mathrm{rtol}, \\mathrm{atol})_{\\mathrm{loose}} = (10^{-6}, 10^{-8})$.\n- For the truncation error estimate, use a fixed window $\\delta\\lambda = 0.5$, i.e., $\\lambda_{\\mathrm{low}} = \\lambda^\\star - \\delta\\lambda$ and $\\lambda_{\\mathrm{high}} = \\lambda^\\star + \\delta\\lambda$, with the understanding that $\\lambda_{\\mathrm{low}}$ must be strictly positive.\n- For the basis truncation comparison, use $N_{\\mathrm{ref}} = 32$ and $N_{\\mathrm{max}}$ as specified per test case.\n\nTest suite:\nCompute the error budgets for the following parameter sets, each specified as $(A, \\lambda^\\star, N_{\\mathrm{max}})$:\n- Case $1$: $(3, 2.0, 16)$\n- Case $2$: $(3, 1.5, 8)$\n- Case $3$: $(2, 2.5, 16)$\n- Case $4$: $(3, 3.0, 24)$\n\nFor each case, you must output the list $[\\varepsilon_{\\mathrm{tot}}, \\varepsilon_{\\mathrm{trunc}}, \\varepsilon_{\\mathrm{ode}}, \\varepsilon_{\\mathrm{basis}}]$ in MeV, rounded to six decimal places.\n\nFinal output specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist in the same format and order as above. For example, the final output must look like\n$$[\\,[x_1,x_2,x_3,x_4],\\,[y_1,y_2,y_3,y_4],\\,[z_1,z_2,z_3,z_4],\\,[w_1,w_2,w_3,w_4]\\,],$$\nwith each $x_i$, $y_i$, $z_i$, and $w_i$ being floating-point numbers in MeV with six decimal places.",
            "solution": "The user has provided a valid, well-posed problem that requires the construction of a numerical error budget for Similarity Renormalization Group (SRG)-evolved binding-energy proxies. The problem is scientifically grounded in the methods of computational nuclear physics, providing a self-contained model Hamiltonian and a clear set of definitions for the quantities to be calculated. The task is to implement the SRG evolution numerically, compute the specified energy proxies, and combine them to estimate various sources of numerical error.\n\nThe solution will be developed following a principle-based design, starting from the fundamental physics and mathematics, and then detailing the algorithm for computation.\n\n**1. Foundational Principles: The Similarity Renormalization Group**\n\nThe core of the problem lies in the Similarity Renormalization Group (SRG) evolution of a quantum mechanical Hamiltonian, $H$. The evolution is described by a differential equation for the Hamiltonian $H_s$ as a function of the flow parameter $s \\ge 0$:\n$$\n\\frac{dH_s}{ds} = [\\eta_s, H_s]\n$$\nwhere $[\\cdot, \\cdot]$ is the commutator and $\\eta_s$ is the generator of the flow. The initial condition is the bare Hamiltonian $H_{s=0} = H_0$. This flow constitutes a unitary transformation, $H_s = U_s H_0 U_s^\\dagger$, which preserves the eigenspectrum of the Hamiltonian.\n\nThe generator is chosen to achieve a specific goal. In this problem, the generator is $\\eta_s = [T, H_s]$, where $T$ is the kinetic energy operator. This specific choice, known as the Wegner generator, drives the Hamiltonian towards a band-diagonal form in the eigenbasis of $T$. This decoupling of low-energy (low-momentum) and high-energy (high-momentum) states is the primary purpose of the SRG in this context.\n\nThe flow parameter $s$ is related to the SRG resolution scale $\\lambda$ by $s = \\lambda^{-4}$. Thus, evolving from $s=0$ to a finite $s_{\\mathrm{final}}$ is equivalent to evolving to a finite resolution scale $\\lambda = s_{\\mathrm{final}}^{-1/4}$. The units of $s$ are energy$^{-2}$, so $\\lambda$ has units of energy. The problem statement specifies to treat $\\lambda$ as dimensionless, which implies that all energy scales are measured relative to a chosen unit, here megaelectronvolts (MeV).\n\n**2. The Model Hamiltonian**\n\nWe work in a finite-dimensional Hilbert space of dimension $N$. The initial Hamiltonian is $H_0 = T + V$.\n- The kinetic energy $T$ is a diagonal matrix with entries $T_{ii} = E_0 + (i-1)\\Delta$ for $i=1, \\dots, N$. This represents discretized kinetic energy levels with a starting energy $E_0$ and a constant spacing $\\Delta$.\n- The potential energy $V$ is a rank-one, attractive, separable interaction given by $V = -g \\, \\mathbf{u}\\mathbf{u}^\\top$, where $g > 0$ is a coupling constant. The vector $\\mathbf{u}$ defines the form factor of the potential, with entries $u_i = \\exp\\left(-\\frac{(i-1)^2}{2\\sigma^2}\\right)$. This Gaussian form factor suppresses coupling between states with large index differences, mimicking a potential that is local in momentum space.\n\nSince $H_0$ is a real symmetric matrix, and the generator $\\eta_s = [T, H_s]$ is anti-symmetric if $H_s$ is symmetric, the evolved Hamiltonian $H_s$ remains real and symmetric for all $s$.\n\n**3. Numerical Integration of the SRG Flow Equation**\n\nThe SRG flow equation is a system of first-order ordinary differential equations (ODEs) for the matrix elements of $H_s$. To solve it numerically, we can flatten the $N \\times N$ matrix $H_s$ into a state vector of size $N^2$. The right-hand side of the ODE, $\\frac{dH_s}{ds}$, can be computed using matrix algebra:\n$$\n\\frac{dH_s}{ds} = [[T, H_s], H_s] = (T H_s - H_s T)H_s - H_s(T H_s - H_s T)\n$$\nWe integrate this system from $s=0$ to $s_{\\mathrm{final}} = \\lambda^{-4}$ using a numerical ODE solver, such as the `solve_ivp` function from the `scipy.integrate` library. The accuracy of the integration is controlled by relative and absolute tolerances, $(\\mathrm{rtol}, \\mathrm{atol})$.\n\n**4. Binding-Energy Proxies and Error Estimation**\n\nOnce the evolved Hamiltonian $H_\\lambda$ is obtained, we compute the binding-energy proxies.\n- For a two-body system ($A=2$), the proxy is the ground-state energy: $E_2(\\lambda) = \\min \\mathrm{eig}(H_\\lambda)$. Since $H_\\lambda$ is symmetric, its eigenvalues are real, and we seek the smallest one.\n- For a three-body system ($A=3$), a toy model proxy is defined as $E_3(\\lambda) = c_3 \\, E_2(\\lambda) + \\beta \\, \\|O(H_\\lambda)\\|_F$. Here, $O(H_\\lambda)$ is the off-diagonal part of $H_\\lambda$, and $\\|\\cdot\\|_F$ is the Frobenius norm. This proxy models the idea that the SRG evolution, by suppressing off-diagonal couplings, also suppresses the need for explicit three-body forces, and the magnitude of $\\|O(H_\\lambda)\\|_F$ serves as a diagnostic for this suppression.\n\nThe problem requires an error budget composed of three components:\n- **Many-body truncation error ($\\varepsilon_{\\mathrm{trunc}}$)**: $\\varepsilon_{\\mathrm{trunc}} = \\frac{1}{2}\\left|E_A(\\lambda_{\\mathrm{high}}) - E_A(\\lambda_{\\mathrm{low}})\\right|$. This measures the sensitivity of the result to the SRG resolution scale $\\lambda$, which is a proxy for the error incurred by omitting induced many-body forces that are not explicitly included in the model. A larger dependence on $\\lambda$ suggests a larger truncation error.\n- **ODE integration error ($\\varepsilon_{\\mathrm{ode}}$)**: $\\varepsilon_{\\mathrm{ode}} = \\left|E_A^{\\mathrm{loose}}(\\lambda^\\star) - E_A^{\\mathrm{tight}}(\\lambda^\\star)\\right|$. This quantifies the numerical error from the ODE solver by comparing results obtained with loose and tight integration tolerances.\n- **Basis truncation error ($\\varepsilon_{\\mathrm{basis}}$)**: $\\varepsilon_{\\mathrm{basis}} = \\left|E_A^{N_{\\mathrm{max}}}(\\lambda^\\star) - E_A^{N_{\\mathrm{ref}}}(\\lambda^\\star)\\right|$. This estimates the error due to the finite dimension of the model space by comparing results from a target basis size $N_{\\mathrm{max}}$ and a larger, more converged reference basis $N_{\\mathrm{ref}}$.\n\nThe total estimated error is the quadrature sum of these components: $\\varepsilon_{\\mathrm{tot}} = \\sqrt{\\varepsilon_{\\mathrm{trunc}}^2 + \\varepsilon_{\\mathrm{ode}}^2 + \\varepsilon_{\\mathrm{basis}}^2}$.\n\n**5. Algorithmic Implementation Strategy**\n\nThe overall algorithm proceeds as follows for each test case $(A, \\lambda^\\star, N_{\\mathrm{max}})$:\n1. Define a core function, `calculate_E_A_evolved(A, lambda_val, N, tol)`, that encapsulates the entire calculation for a given set of parameters:\n    a. Construct the initial Hamiltonian $H_0$ and the kinetic energy matrix $T$ for the given basis size $N$.\n    b. Calculate the final flow parameter $s_{\\mathrm{final}} = \\lambda_{\\mathrm{val}}^{-4}$.\n    c. Use `scipy.integrate.solve_ivp` to integrate the SRG flow ODE from $s=0$ to $s_{\\mathrm{final}}$ with the specified tolerances.\n    d. From the resulting evolved Hamiltonian $H_\\lambda$, compute the appropriate binding-energy proxy $E_A(\\lambda)$.\n2. To improve efficiency, the results of `calculate_E_A_evolved` are memoized (cached). This prevents redundant computations, as several error components require calculations with the same parameters (e.g., $E_A^{N_{\\mathrm{ref}}, \\mathrm{tight}}(\\lambda^\\star)$ is used for both $\\varepsilon_{\\mathrm{ode}}$ and $\\varepsilon_{\\mathrm{basis}}$).\n3. For each test case, calculate the required energy proxies by calling the memoized core function with the appropriate parameters for $\\lambda$, $N$, and tolerances, as specified by the definitions of the error components.\n4. Compute $\\varepsilon_{\\mathrm{trunc}}$, $\\varepsilon_{\\mathrm{ode}}$, and $\\varepsilon_{\\mathrm{basis}}$ from the calculated energy values.\n5. Combine them in quadrature to find $\\varepsilon_{\\mathrm{tot}}$.\n6. Store the four error components, rounded to six decimal places, for the current test case.\n7. After processing all test cases, format the collected results into the specified final output string.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom math import sqrt\nfrom functools import lru_cache\n\n# Define global constants and parameters from the problem statement.\nE0 = 1.0  # MeV\nDELTA = 2.0  # MeV\nG = 6.0  # MeV\nSIGMA = 5.0\nC3 = 1.5\nBETA = 0.05\nTOL_TIGHT = (1e-10, 1e-12)\nTOL_LOOSE = (1e-6, 1e-8)\nDELTA_LAMBDA = 0.5\nN_REF = 32\n\n@lru_cache(maxsize=None)\ndef get_constants_for_N(N):\n    \"\"\"Pre-calculates and caches T and H0 for a given N.\"\"\"\n    i_indices = np.arange(N)\n    T_diag = E0 + i_indices * DELTA\n    T = np.diag(T_diag)\n    u_vec = np.exp(-(i_indices**2) / (2 * SIGMA**2))\n    V = -G * np.outer(u_vec, u_vec)\n    H0 = T + V\n    return T, H0\n\ndef srg_flow(s, H_flat, N, T):\n    \"\"\"\n    Defines the right-hand side of the SRG flow ODE.\n    dH/ds = [[T, H], H]\n    \"\"\"\n    H = H_flat.reshape((N, N))\n    eta = T @ H - H @ T\n    dHds = eta @ H - H @ eta\n    return dHds.flatten()\n\ndef get_E_A(H, A):\n    \"\"\"\n    Calculates the binding-energy proxy E_A from a given Hamiltonian H.\n    \"\"\"\n    # E_2(lambda) is the lowest eigenvalue of H_lambda.\n    # The Hamiltonian remains real-symmetric, so we can use eigh.\n    eigenvalues = np.linalg.eigh(H)[0]\n    E2 = np.min(eigenvalues)\n\n    if A == 2:\n        return E2\n    elif A == 3:\n        # E_3(lambda) = c_3 * E_2(lambda) + beta * ||O(H_lambda)||_F\n        O_H = H - np.diag(np.diag(H))\n        norm_O_H = np.linalg.norm(O_H, 'fro')\n        E3 = C3 * E2 + BETA * norm_O_H\n        return E3\n    else:\n        raise ValueError(\"Nucleon number A must be 2 or 3.\")\n\n@lru_cache(maxsize=None)\ndef calculate_E_A_evolved(A, lambda_val, N, tol):\n    \"\"\"\n    Calculates the SRG-evolved energy proxy E_A(lambda) for a given\n    nucleon number A, resolution scale lambda, basis size N, and ODE tolerance.\n    \"\"\"\n    T, H0 = get_constants_for_N(N)\n    \n    # s = lambda^{-4}\n    if lambda_val <= 0:\n        raise ValueError(\"Lambda must be positive.\")\n    s_final = lambda_val**-4\n\n    sol = solve_ivp(\n        srg_flow,\n        [0, s_final],\n        H0.flatten(),\n        method='RK45',\n        args=(N, T),\n        rtol=tol[0],\n        atol=tol[1]\n    )\n\n    H_final = sol.y[:, -1].reshape((N, N))\n    return get_E_A(H_final, A)\n\ndef solve():\n    \"\"\"\n    Main function to execute the error budget calculation for all test cases.\n    \"\"\"\n    test_cases = [\n        # (A, lambda_star, N_max)\n        (3, 2.0, 16),\n        (3, 1.5, 8),\n        (2, 2.5, 16),\n        (3, 3.0, 24),\n    ]\n\n    all_results = []\n    for A, lambda_star, N_max in test_cases:\n        # Define lambda values for truncation error calculation\n        lambda_low = lambda_star - DELTA_LAMBDA\n        lambda_high = lambda_star + DELTA_LAMBDA\n\n        # 1. Calculate induced many-body truncation error (eps_trunc)\n        # Use large basis N_ref and tight tolerances.\n        E_high = calculate_E_A_evolved(A, lambda_high, N_REF, TOL_TIGHT)\n        E_low = calculate_E_A_evolved(A, lambda_low, N_REF, TOL_TIGHT)\n        eps_trunc = 0.5 * abs(E_high - E_low)\n\n        # 2. Calculate ODE integration error (eps_ode)\n        # Fix lambda and basis (N_ref), vary tolerance.\n        E_tight_ref = calculate_E_A_evolved(A, lambda_star, N_REF, TOL_TIGHT)\n        E_loose_ref = calculate_E_A_evolved(A, lambda_star, N_REF, TOL_LOOSE)\n        eps_ode = abs(E_loose_ref - E_tight_ref)\n\n        # 3. Calculate basis truncation error (eps_basis)\n        # Fix lambda and tolerance, vary basis size.\n        E_tight_max = calculate_E_A_evolved(A, lambda_star, N_max, TOL_TIGHT)\n        # E_tight_ref is already cached from the eps_ode calculation.\n        eps_basis = abs(E_tight_max - E_tight_ref)\n\n        # 4. Calculate total error (eps_tot)\n        eps_tot = sqrt(eps_trunc**2 + eps_ode**2 + eps_basis**2)\n\n        case_results = [eps_tot, eps_trunc, eps_ode, eps_basis]\n        all_results.append(case_results)\n\n    # Format output string as a list of lists with numbers rounded to 6 decimal places.\n    sublist_strs = []\n    for res in all_results:\n        num_strs = [f\"{v:.6f}\" for v in res]\n        sublist_strs.append(f\"[{','.join(num_strs)}]\")\n    final_output = f\"[{','.join(sublist_strs)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}