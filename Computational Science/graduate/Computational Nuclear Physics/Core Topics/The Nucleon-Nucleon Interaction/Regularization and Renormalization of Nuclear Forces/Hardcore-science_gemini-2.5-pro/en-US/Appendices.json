{
    "hands_on_practices": [
        {
            "introduction": "This first practice introduces the core procedure of nonperturbative renormalization in a clear and accessible context. We will tackle the Lippmann-Schwinger equation for a simple contact interaction, which requires regularization to be solved numerically. By implementing a renormalization condition to reproduce a physical observable, you will see firsthand how a \"running\" coupling constant absorbs cutoff dependence, a foundational skill for any work in effective field theory .",
            "id": "3586306",
            "problem": "You are asked to design, implement, and test a momentum-space discretization of the two-body $s$-wave Lippmann–Schwinger (LS) equation that preserves renormalization with a sharp ultraviolet momentum cutoff $\\Lambda$ and a regulated contact interaction. Your program must compute a renormalized low-energy observable and analyze numerical convergence as both the grid size $N$ and the quadrature family and order are varied.\n\nThe starting point is the momentum-space $s$-wave LS equation for the half-off-shell transition matrix $T(k',k;E)$ with a sharp cutoff $\\Lambda$:\n$$\nT(k',k;E) = V(k',k) + \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, V(k',q) \\, G_{0}(E,q) \\, T(q,k;E),\n$$\nwhere $k$ and $k'$ are relative momenta, $E$ is the center-of-mass energy, and $G_{0}(E,q) = (E - q^{2}/(2\\mu) + i0)^{-1}$ is the free resolvent for reduced mass $\\mu$. Use units in which $\\hbar = 1$ so that energies and momenta are dimensionally consistent; all outputs requested below are dimensionless numbers (no physical units are required).\n\nConsider a regulated, separable, contact interaction,\n$$\nV(k',k) = C(\\Lambda)\\, g(k')\\,g(k),\\quad g(k) = \\exp\\big(- (k/\\Lambda)^{2} \\big),\n$$\nwhere $C(\\Lambda)$ is a cutoff-dependent low-energy constant adjusted by renormalization. Because the interaction is separable, the LS equation admits the separable form $T(k',k;E) = g(k')\\, \\tau(E)\\, g(k)$, where the reduced amplitude $\\tau(E)$ satisfies\n$$\n\\tau(E) = \\frac{1}{C(\\Lambda)^{-1} - I(E,\\Lambda)},\n\\quad\nI(E,\\Lambda) = \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, g(q)^{2} \\, G_{0}(E,q).\n$$\n\nAt zero energy $E=0$, impose the standard threshold relation between the $s$-wave on-shell transition matrix and the scattering length $a_{0}$ for the chosen LS normalization,\n$$\nT(0,0;0) = -\\frac{2\\pi}{\\mu} a_{0}.\n$$\nWith the separable ansatz $T(0,0;0) = \\tau(0)$, this fixes $\\tau(0)$. The renormalization condition then yields a running coupling $C(\\Lambda)$ such that the low-energy observable $a_{0}$ is exactly reproduced in the continuum limit.\n\nYour tasks:\n\n1) From the LS equation and the separable ansatz, derive the discrete approximation of $I(0,\\Lambda)$ on a momentum grid $\\{q_{i}, w_{i}\\}_{i=1}^{N}$ designed to approximate $\\int_{0}^{\\Lambda} dq\\, f(q)$ by $\\sum_{i=1}^{N} w_{i} f(q_{i})$. Show explicitly that for $E=0$ the free resolvent simplifies the integrand so that\n$$\nI(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\int_{0}^{\\Lambda} dq\\, g(q)^{2},\n\\quad\nI_{N}(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\sum_{i=1}^{N} w_{i}\\, g(q_{i})^{2}.\n$$\nThen, express the discrete reduced amplitude as\n$$\n\\tau_{N}(0) = \\frac{1}{C(\\Lambda)^{-1} - I_{N}(0,\\Lambda)}.\n$$\n\n2) Using the threshold relation $T(0,0;0) = - 2\\pi a_{0}/\\mu$ and the separable form, determine $\\tau(0)$ at threshold and use it to construct the renormalization condition for $C(\\Lambda)$,\n$$\n\\frac{1}{\\tau(0)} = C(\\Lambda)^{-1} - I(0,\\Lambda).\n$$\nFor the regulator $g(k)=\\exp\\big(- (k/\\Lambda)^{2} \\big)$, evaluate $I(0,\\Lambda)$ analytically as a function of $\\mu$ and $\\Lambda$. Use this analytic result to obtain $C(\\Lambda)$ that reproduces the target $a_{0}$ in the continuum. This $C(\\Lambda)$ must then be used in the discretized scheme to test whether the discretization preserves renormalization as $N$ and quadrature choices vary.\n\n3) Implement two quadrature families for the momentum integral over $q\\in[0,\\Lambda]$:\n- A uniform grid with trapezoidal rule (denote by TRAP) with $N$ points including endpoints.\n- A Gauss–Legendre (GL) quadrature of order $N$ mapped from $[-1,1]$ to $[0,\\Lambda]$.\n\nFor a given $(\\mu, a_{0}, \\Lambda, N, \\text{family})$, compute the discrete estimate of the scattering length,\n$$\n\\hat{a}_{0}^{(N,\\text{family})} = -\\frac{\\mu}{2\\pi} \\tau_{N}(0),\n$$\nand the absolute relative error $\\varepsilon = \\lvert (\\hat{a}_{0}^{(N,\\text{family})} - a_{0})/a_{0} \\rvert$.\n\n4) Design your program to produce a single line of output collecting the results for the test suite given below as a comma-separated list enclosed in square brackets. For all computations use $\\mu = 1.0$ (dimensionless), $\\hbar = 1$ (dimensionless), and $g(k)$ as specified. All outputs are pure numbers without units.\n\nTest suite:\n- Case $1$ (happy path, accuracy of GL): $a_{0} = 5.0$, $\\Lambda = 6.0$, GL quadrature, $N = 16$. Output the absolute relative error $\\varepsilon$ as a float.\n- Case $2$ (same parameters, TRAP vs GL comparison): $a_{0} = 5.0$, $\\Lambda = 6.0$, TRAP quadrature, $N = 16$. Output $\\varepsilon$.\n- Case $3$ (small cutoff, modest $N$): $a_{0} = 5.0$, $\\Lambda = 2.0$, GL quadrature, $N = 8$. Output $\\varepsilon$.\n- Case $4$ (small cutoff, TRAP): $a_{0} = 5.0$, $\\Lambda = 2.0$, TRAP quadrature, $N = 8$. Output $\\varepsilon$.\n- Case $5$ (renormalization invariance across cutoffs): $a_{0} = 5.0$, GL quadrature, $N = 24$, compare results at $\\Lambda_{1} = 3.0$ and $\\Lambda_{2} = 9.0$. Output the absolute difference $\\Delta = \\lvert \\hat{a}_{0}^{(N,\\text{GL})}(\\Lambda_{1}) - \\hat{a}_{0}^{(N,\\text{GL})}(\\Lambda_{2}) \\rvert$ as a float.\n- Case $6$ (edge case, large cutoff, smaller scattering length): $a_{0} = 0.5$, $\\Lambda = 20.0$, GL quadrature, $N = 64$. Output $\\varepsilon$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4,r5,r6]\"), where each $r_{i}$ is the float specified by the corresponding case above. No additional text should be printed.",
            "solution": "### 1. Derivation of the Discrete Lippmann-Schwinger Equation at Threshold\n\nThe starting point is the $s$-wave Lippmann-Schwinger (LS) equation for the half-off-shell transition matrix $T(k',k;E)$ with an ultraviolet momentum cutoff $\\Lambda$:\n$$\nT(k',k;E) = V(k',k) + \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, V(k',q) \\, G_{0}(E,q) \\, T(q,k;E)\n$$\nThe potential $V(k',k)$ is a regulated, separable, contact interaction of the form $V(k',k) = C(\\Lambda) g(k') g(k)$, where $g(k) = \\exp(-(k/\\Lambda)^2)$. This separable form for the potential implies a separable solution for the T-matrix, $T(k',k;E) = g(k') \\tau(E) g(k)$. Substituting the separable forms for $V$ and $T$ into the LS equation yields:\n$$\ng(k') \\tau(E) g(k) = C(\\Lambda) g(k') g(k) + \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} [C(\\Lambda) g(k') g(q)] G_{0}(E,q) [g(q) \\tau(E) g(k)]\n$$\nWe can cancel the common factor of $g(k')g(k)$ from all terms (assuming they are non-zero), resulting in an algebraic equation for the reduced amplitude $\\tau(E)$:\n$$\n\\tau(E) = C(\\Lambda) + C(\\Lambda) \\tau(E) \\left[ \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, g(q)^{2} \\, G_{0}(E,q) \\right]\n$$\nDefining the loop integral $I(E,\\Lambda)$ as\n$$\nI(E,\\Lambda) = \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, g(q)^{2} \\, G_{0}(E,q),\n$$\nthe equation for $\\tau(E)$ becomes $\\tau(E) = C(\\Lambda) + C(\\Lambda) \\tau(E) I(E,\\Lambda)$. Solving for $\\tau(E)$:\n$$\n\\tau(E) (1 - C(\\Lambda)I(E,\\Lambda)) = C(\\Lambda) \\implies \\tau(E) = \\frac{C(\\Lambda)}{1 - C(\\Lambda)I(E,\\Lambda)} = \\frac{1}{C(\\Lambda)^{-1} - I(E,\\Lambda)}\n$$\nThis is the expression provided in the problem statement.\n\nFor Task 1, we must evaluate this at zero energy, $E=0$. The free resolvent $G_{0}(E,q) = (E - q^2/(2\\mu) + i0)^{-1}$ simplifies to:\n$$\nG_{0}(0,q) = \\left( -\\frac{q^2}{2\\mu} \\right)^{-1} = -\\frac{2\\mu}{q^2}\n$$\nSubstituting this into the expression for the loop integral $I(E, \\Lambda)$ at $E=0$:\n$$\nI(0,\\Lambda) = \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, g(q)^{2} \\left(-\\frac{2\\mu}{q^2}\\right) = -\\frac{4\\mu}{\\pi} \\int_{0}^{\\Lambda} dq\\, g(q)^{2}\n$$\nThis confirms the required expression for $I(0,\\Lambda)$.\n\nTo discretize this integral, we employ a numerical quadrature scheme defined by a set of momentum grid points $\\{q_i\\}_{i=1}^N$ and corresponding weights $\\{w_i\\}_{i=1}^N$. The integral is approximated by a weighted sum:\n$$\n\\int_{0}^{\\Lambda} dq\\, f(q) \\approx \\sum_{i=1}^{N} w_{i} f(q_{i})\n$$\nApplying this to our expression for $I(0,\\Lambda)$, we obtain its discrete approximation $I_{N}(0,\\Lambda)$:\n$$\nI_{N}(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\sum_{i=1}^{N} w_{i}\\, g(q_{i})^{2}\n$$\nThe corresponding discrete reduced amplitude $\\tau_N(0)$ is found by replacing the continuum integral $I(0,\\Lambda)$ with its discrete counterpart $I_N(0,\\Lambda)$ in the formula for $\\tau(E)$:\n$$\n\\tau_{N}(0) = \\frac{1}{C(\\Lambda)^{-1} - I_{N}(0,\\Lambda)}\n$$\n\n### 2. Renormalization Condition and Analytic Evaluation\n\nTask 2 requires us to determine the cutoff-dependent coupling constant $C(\\Lambda)$ by enforcing a physical condition. We anchor the theory to reproduce a known low-energy observable, the $s$-wave scattering length $a_0$. The relationship between the on-shell T-matrix at zero energy and $a_0$ is given as:\n$$\nT(0,0;0) = -\\frac{2\\pi}{\\mu} a_0\n$$\nUsing our separable T-matrix ansatz, $T(k',k;E) = g(k')\\tau(E)g(k)$, at $k=k'=E=0$, we have:\n$$\nT(0,0;0) = g(0) \\tau(0) g(0)\n$$\nWith the regulator $g(k) = \\exp(-(k/\\Lambda)^2)$, we have $g(0)=\\exp(0)=1$. Therefore, $T(0,0;0) = \\tau(0)$. Equating the two expressions for the on-shell T-matrix gives the physical value of the reduced amplitude at threshold:\n$$\n\\tau(0) = -\\frac{2\\pi a_0}{\\mu}\n$$\nThis serves as our renormalization condition. We demand that our continuum theory reproduces this exact value for $\\tau(0)$. By inverting the expression for $\\tau(0)$, we obtain the condition on the running coupling $C(\\Lambda)$:\n$$\n\\frac{1}{\\tau(0)} = C(\\Lambda)^{-1} - I(0,\\Lambda) \\implies C(\\Lambda)^{-1} = \\frac{1}{\\tau(0)} + I(0,\\Lambda)\n$$\nSubstituting $\\tau(0) = -2\\pi a_0/\\mu$, we get:\n$$\nC(\\Lambda)^{-1} = -\\frac{\\mu}{2\\pi a_0} + I(0,\\Lambda)\n$$\nTo obtain a fully analytic expression for $C(\\Lambda)$, we must evaluate the integral $I(0,\\Lambda)$ for the specific regulator $g(q)^2 = \\exp(-2(q/\\Lambda)^2)$:\n$$\nI(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\int_{0}^{\\Lambda} dq\\, e^{-2(q/\\Lambda)^2}\n$$\nWe perform a change of variables. Let $u = \\sqrt{2} q/\\Lambda$, which implies $dq = (\\Lambda/\\sqrt{2}) du$. The integration limits change from $[0, \\Lambda]$ to $[0, \\sqrt{2}]$.\n$$\nI(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\int_{0}^{\\sqrt{2}} e^{-u^2} \\frac{\\Lambda}{\\sqrt{2}} du = -\\frac{4\\mu\\Lambda}{\\pi\\sqrt{2}} \\int_{0}^{\\sqrt{2}} e^{-u^2} du\n$$\nThe integral is related to the error function, $\\mathrm{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{-t^2} dt$, so $\\int_0^x e^{-t^2} dt = \\frac{\\sqrt{\\pi}}{2}\\mathrm{erf}(x)$.\n$$\nI(0,\\Lambda) = -\\frac{4\\mu\\Lambda}{\\pi\\sqrt{2}} \\left( \\frac{\\sqrt{\\pi}}{2} \\mathrm{erf}(\\sqrt{2}) \\right) = -\\frac{2\\mu\\Lambda}{\\sqrt{2\\pi}} \\mathrm{erf}(\\sqrt{2}) = -\\mu\\Lambda\\sqrt{\\frac{2}{\\pi}} \\mathrm{erf}(\\sqrt{2})\n$$\nFinally, substituting this analytic result back into the expression for $C(\\Lambda)^{-1}$:\n$$\nC(\\Lambda)^{-1} = -\\frac{\\mu}{2\\pi a_0} - \\mu\\Lambda\\sqrt{\\frac{2}{\\pi}} \\mathrm{erf}(\\sqrt{2})\n$$\nThis expression defines the value of the coupling $C(\\Lambda)$ required at any cutoff $\\Lambda$ to exactly reproduce the scattering length $a_0$ in the continuum theory. This is the coupling that must be used in our discrete calculation to test whether the discretization preserves this property.\n\n### 3. Numerical Implementation and Quadrature Schemes\n\nThe goal is to compute a numerical estimate of the scattering length, $\\hat{a}_{0}^{(N,\\text{family})}$, and compare it to the target value $a_0$. The estimated scattering length is obtained from the discrete reduced amplitude $\\tau_N(0)$:\n$$\n\\hat{a}_{0}^{(N,\\text{family})} = -\\frac{\\mu}{2\\pi} \\tau_{N}(0) = -\\frac{\\mu}{2\\pi} \\left( \\frac{1}{C(\\Lambda)^{-1} - I_{N}(0,\\Lambda)} \\right)\n$$\nThe core of the numerical task is the computation of the discrete loop integral $I_{N}(0, \\Lambda)$ for two different quadrature families.\n\n- **Trapezoidal Rule (TRAP) on a Uniform Grid:**\nFor a grid of $N$ points including the endpoints $0$ and $\\Lambda$, the step size is $h = \\Lambda/(N-1)$. The grid points are $q_i = (i-1)h$ for $i=1, ..., N$. The trapezoidal rule approximates the integral as a sum with weights $w_1 = h/2$, $w_N = h/2$, and $w_i = h$ for $i=2, ..., N-1$.\n\n- **Gauss–Legendre (GL) Quadrature:**\nThis method is typically defined on the interval $[-1, 1]$. We use a linear transformation to map the standard GL nodes $x_i \\in [-1, 1]$ and weights $w_i^{\\text{GL}}$ to the momentum interval $q \\in [0, \\Lambda]$.\nThe transformation is $q(x) = \\frac{\\Lambda}{2}(x+1)$, with differential $dq = \\frac{\\Lambda}{2}dx$. The integral becomes:\n$$\n\\int_0^\\Lambda f(q) dq = \\int_{-1}^1 f\\left( \\frac{\\Lambda}{2}(x+1) \\right) \\frac{\\Lambda}{2} dx \\approx \\sum_{i=1}^N \\frac{\\Lambda}{2} w_i^{\\text{GL}} f\\left( \\frac{\\Lambda}{2}(x_i+1) \\right)\n$$\nThus, the quadrature points and weights for our momentum grid are:\n$$\nq_i = \\frac{\\Lambda}{2}(x_i+1), \\quad w_i = \\frac{\\Lambda}{2}w_i^{\\text{GL}}\n$$\n\nThe overall algorithm for each test case is as follows:\n1.  Given the parameters $(\\mu, a_{0}, \\Lambda, N, \\text{family})$, first compute the analytical value of the inverse coupling $C(\\Lambda)^{-1}$ using the formula derived in Section 2.\n2.  Generate the set of quadrature points $\\{q_i\\}$ and weights $\\{w_i\\}$ for the specified family (TRAP or GL), size $N$, and range $[0, \\Lambda]$.\n3.  Calculate the regulator function values $g(q_i)^2 = \\exp(-2(q_i/\\Lambda)^2)$ on the grid.\n4.  Compute the discrete loop integral $I_{N}(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\sum_{i=1}^{N} w_{i} g(q_i)^2$.\n5.  Calculate the discrete reduced amplitude $\\tau_N(0) = (C(\\Lambda)^{-1} - I_{N}(0,\\Lambda))^{-1}$.\n6.  Compute the estimated scattering length $\\hat{a}_{0} = -\\mu/(2\\pi) \\tau_N(0)$.\n7.  Finally, compute the specified output metric: either the absolute relative error $\\varepsilon = \\lvert (\\hat{a}_{0} - a_{0})/a_{0} \\rvert$ or the absolute difference $\\Delta$ between two calculations.\n\nThis procedure tests how well a given discretization scheme (quadrature rule and grid size) approximates the continuum limit, where $\\hat{a}_0$ would be exactly equal to $a_0$. The error $\\varepsilon$ quantifies the accuracy of the numerical approximation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    Designs, implements, and tests a momentum-space discretization of the\n    two-body s-wave Lippmann–Schwinger equation.\n    \"\"\"\n\n    # --- Problem constants ---\n    MU = 1.0  # Reduced mass (dimensionless)\n\n    def get_quadrature(Lambda, N, family):\n        \"\"\"\n        Generates quadrature points and weights for the integral from 0 to Lambda.\n\n        Args:\n            Lambda (float): The momentum cutoff.\n            N (int): The number of quadrature points.\n            family (str): The quadrature family ('GL' for Gauss-Legendre, 'TRAP' for Trapezoidal).\n\n        Returns:\n            tuple: A tuple containing:\n                - q (np.ndarray): The momentum grid points.\n                - w (np.ndarray): The corresponding quadrature weights.\n        \"\"\"\n        if family == 'GL':\n            # Gauss-Legendre quadrature mapped from [-1, 1] to [0, Lambda]\n            x_gl, w_gl = np.polynomial.legendre.leggauss(N)\n            q = 0.5 * Lambda * (x_gl + 1.0)\n            w = 0.5 * Lambda * w_gl\n        elif family == 'TRAP':\n            # Trapezoidal rule on a uniform grid\n            if N < 2:\n                # Handle edge case of N < 2 for trapezoidal rule\n                if N == 1:\n                    return np.array([0.0]), np.array([Lambda])\n                else: # N=0\n                    return np.array([]), np.array([])\n            q = np.linspace(0.0, Lambda, N)\n            h = Lambda / (N - 1.0)\n            w = np.full(N, h)\n            w[0] = h / 2.0\n            w[-1] = h / 2.0\n        else:\n            raise ValueError(f\"Unknown quadrature family: {family}\")\n        return q, w\n\n    def compute_scattering_length(a0, Lambda, N, family):\n        \"\"\"\n        Computes the discrete estimate of the scattering length.\n\n        Args:\n            a0 (float): The target scattering length for renormalization.\n            Lambda (float): The momentum cutoff.\n            N (int): The number of quadrature points.\n            family (str): The quadrature family ('GL' or 'TRAP').\n\n        Returns:\n            float: The computed estimate of the scattering length, a0_hat.\n        \"\"\"\n        # Regulator function g(k)^2\n        g2 = lambda k: np.exp(-2.0 * (k / Lambda)**2)\n\n        # 1. Analytically determine the inverse coupling C(Lambda)^-1\n        # This is the renormalization condition.\n        # I(0, Lambda) = - (4*mu/pi) * integral(g(q)^2 dq, 0, Lambda)\n        # integral = (Lambda * sqrt(pi)) / (2*sqrt(2)) * erf(sqrt(2))\n        I_continuum = -MU * Lambda * np.sqrt(2.0 / np.pi) * erf(np.sqrt(2.0))\n        \n        # C(Lambda)^-1 = 1/tau(0) + I(0, Lambda), with tau(0) = -2*pi*a0/mu\n        C_inv = -MU / (2.0 * np.pi * a0) + I_continuum\n\n        # 2. Generate quadrature points and weights\n        q, w = get_quadrature(Lambda, N, family)\n\n        # 3. Compute the discrete loop integral I_N(0, Lambda)\n        integrand_vals = g2(q)\n        I_discrete = - (4.0 * MU / np.pi) * np.sum(w * integrand_vals)\n\n        # 4. Compute the discrete reduced amplitude tau_N(0)\n        tau_N_0 = 1.0 / (C_inv - I_discrete)\n\n        # 5. Compute the estimated scattering length a0_hat\n        a0_hat = -MU / (2.0 * np.pi) * tau_N_0\n        \n        return a0_hat\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1: a0=5.0, Lambda=6.0, GL, N=16. Output epsilon.\n        {'a0': 5.0, 'Lambda': 6.0, 'N': 16, 'family': 'GL', 'type': 'error'},\n        # Case 2: a0=5.0, Lambda=6.0, TRAP, N=16. Output epsilon.\n        {'a0': 5.0, 'Lambda': 6.0, 'N': 16, 'family': 'TRAP', 'type': 'error'},\n        # Case 3: a0=5.0, Lambda=2.0, GL, N=8. Output epsilon.\n        {'a0': 5.0, 'Lambda': 2.0, 'N': 8, 'family': 'GL', 'type': 'error'},\n        # Case 4: a0=5.0, Lambda=2.0, TRAP, N=8. Output epsilon.\n        {'a0': 5.0, 'Lambda': 2.0, 'N': 8, 'family': 'TRAP', 'type': 'error'},\n        # Case 5: a0=5.0, GL, N=24. Compare Lambda1=3.0 and Lambda2=9.0. Output abs diff.\n        {'a0': 5.0, 'N': 24, 'family': 'GL', 'Lambda1': 3.0, 'Lambda2': 9.0, 'type': 'diff'},\n        # Case 6: a0=0.5, Lambda=20.0, GL, N=64. Output epsilon.\n        {'a0': 0.5, 'Lambda': 20.0, 'N': 64, 'family': 'GL', 'type': 'error'},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'error':\n            a0 = case['a0']\n            a0_hat = compute_scattering_length(\n                a0=a0,\n                Lambda=case['Lambda'],\n                N=case['N'],\n                family=case['family']\n            )\n            error = np.abs((a0_hat - a0) / a0)\n            results.append(error)\n        \n        elif case['type'] == 'diff':\n            a0_hat1 = compute_scattering_length(\n                a0=case['a0'],\n                Lambda=case['Lambda1'],\n                N=case['N'],\n                family=case['family']\n            )\n            a0_hat2 = compute_scattering_length(\n                a0=case['a0'],\n                Lambda=case['Lambda2'],\n                N=case['N'],\n                family=case['family']\n            )\n            diff = np.abs(a0_hat1 - a0_hat2)\n            results.append(diff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the fundamentals, this exercise demonstrates how renormalization is applied to more complex and physically motivated interactions. Here, you will work with a potential that models a singular tensor force, a common feature in nuclear physics, and includes a leading-order counterterm. The goal is to perform a nonperturbative 'fit-and-predict' calculation, testing the core tenet of effective field theory: the ability to make predictions that are independent of the arbitrary regulator cutoff .",
            "id": "3586377",
            "problem": "You are to investigate nonperturbative renormalization in a singular tensor channel by modeling the uncoupled triplet $P$-wave $^3P_0$ as an attractive long-range tensor-induced interaction plus a leading-order counterterm. Adopt natural units where $\\hbar = 1$ and $2\\mu = 1$, so that the two-body center-of-mass energy is $E = k^2$ and all quantities are dimensionless. Work entirely in momentum space and in a single partial wave.\n\nFundamental base and model:\n- Start from the Lippmann–Schwinger equation for the partial-wave reactance (K-) matrix in a single channel,\n$$\nK(p,p';E) = V(p,p') + \\frac{2}{\\pi}\\,\\mathcal{P}\\int_{0}^{\\infty} dq\\, \\frac{q^2\\, V(p,q)\\, K(q,p';E)}{E - q^2},\n$$\nwhere $\\mathcal{P}$ denotes the Cauchy principal value.\n- Model the regularized leading-order potential for the $^3P_0$ channel as the sum of a long-range separable term representing the tensor force and a leading-order $P$-wave counterterm,\n$$\nV(p,p';\\Lambda) = R_{\\Lambda}(p)\\, R_{\\Lambda}(p')\\left[-g\\, \\frac{p}{p^2+\\beta^2}\\, \\frac{p'}{{p'}^2+\\beta^2} + C(\\Lambda)\\, p\\,p' \\right],\n$$\nwith Gaussian-type regulator\n$$\nR_{\\Lambda}(p) = \\exp\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{4}\\right].\n$$\nHere $g > 0$ is a fixed coupling of the long-range part, $\\beta > 0$ sets a finite-range scale, and $C(\\Lambda)$ is a running counterterm to be fit at each cutoff $\\Lambda$.\n\nObservables and renormalization protocol:\n- Define the on-shell reactance matrix element as $K_1(k;\\Lambda) \\equiv K(k,k;E=k^2)$ in the $P$-wave. You will assess regulator independence by the following nonperturbative renormalization prescription:\n  1. For a given $\\Lambda$, determine $C(\\Lambda)$ by refitting to the datum\n     $$\n     K_1(k_{\\mathrm{ref}};\\Lambda) = K_{\\mathrm{ref}},\n     $$\n     at the reference momentum $k_{\\mathrm{ref}}$ and target value $K_{\\mathrm{ref}}$ specified below.\n  2. With the fitted $C(\\Lambda)$ fixed, predict $K_1(k_{\\mathrm{test}};\\Lambda)$ at the test momentum $k_{\\mathrm{test}}$.\n  3. Compare the predictions $K_1(k_{\\mathrm{test}};\\Lambda)$ as $\\Lambda$ varies. Regulator independence after refitting corresponds to these values approaching a common limit as $\\Lambda$ increases.\n\nComputational requirements:\n- Treat the principal value integral numerically by splitting the integration domain at $q = k$, excluding an infinitesimal neighborhood around the pole. Truncate the upper limit to a finite $Q_{\\max}$ justified by the regulator, and ensure numerical convergence.\n- You must not use perturbation theory; solve the integral equation nonperturbatively. You may exploit the separability of the model potential to reduce the integral equation to a finite-dimensional algebraic system, if you can derive it from first principles.\n\nParameter values and units:\n- Use $g = 5.0$ and $\\beta = 1.0$.\n- Use $k_{\\mathrm{ref}} = 1.0$ and $K_{\\mathrm{ref}} = -0.4$.\n- Use $k_{\\mathrm{test}} = 1.5$.\n- All quantities are dimensionless due to the choice $\\hbar = 1$ and $2\\mu = 1$.\n\nTest suite:\n- Evaluate the predicted values of $K_1(k_{\\mathrm{test}};\\Lambda)$ for the following cutoffs:\n  - Edge-case small cutoff: $\\Lambda = 2.0$.\n  - Moderate cutoff: $\\Lambda = 4.0$.\n  - Large cutoff: $\\Lambda = 8.0$.\n  - Very large cutoff: $\\Lambda = 16.0$.\n- Additionally, as a boundary sensitivity probe, include $\\Lambda = 1.5$.\n\nFinal output specification:\n- Your program must compute, for each $\\Lambda$ in the list $[1.5, 2.0, 4.0, 8.0, 16.0]$, the value of $K_1(k_{\\mathrm{test}};\\Lambda)$ after refitting $C(\\Lambda)$ at $k_{\\mathrm{ref}}$ to the datum $K_{\\mathrm{ref}}$.\n- The program must output a single line containing these five results as a comma-separated list enclosed in square brackets, in the same order of $\\Lambda$ as above. Each number must be a decimal rounded to six digits after the decimal point. For example,\n$$\n[x_1, x_2, x_3, x_4, x_5]\n$$\nwith each $x_i$ a float with exactly six digits after the decimal point.",
            "solution": "The problem requires the nonperturbative solution of the Lippmann-Schwinger (LS) equation for the partial-wave reactance matrix, $K$, in the presence of a singular potential. The prescribed renormalization procedure involves fitting a counterterm to a single datum at a reference energy scale and then predicting an observable at a different energy scale. The stability of this prediction with respect to the regulator cutoff, $\\Lambda$, is the measure of successful renormalization.\n\nThe key to solving the integral equation nonperturbatively is to exploit the separable nature of the potential, $V(p,p';\\Lambda)$. We can express the potential in matrix form as:\n$$\nV(p,p';\\Lambda) = \\mathbf{v}(p, \\Lambda)^T \\mathbf{G}(\\Lambda) \\mathbf{v}(p', \\Lambda)\n$$\nwhere $\\mathbf{v}(p, \\Lambda)$ is a column vector representing the momentum-dependent parts of the potential, and $\\mathbf{G}(\\Lambda)$ is a matrix of coupling constants. We define the basis vectors as:\n$$\nv_1(p, \\Lambda) = R_{\\Lambda}(p) \\frac{p}{p^2+\\beta^2} \\quad \\text{and} \\quad v_2(p, \\Lambda) = R_{\\Lambda}(p) p\n$$\nsuch that $\\mathbf{v}(p, \\Lambda) = \\begin{pmatrix} v_1(p, \\Lambda) \\\\ v_2(p, \\Lambda) \\end{pmatrix}$. The coupling matrix $\\mathbf{G}(\\Lambda)$ is diagonal:\n$$\n\\mathbf{G}(\\Lambda) = \\begin{pmatrix} -g & 0 \\\\ 0 & C(\\Lambda) \\end{pmatrix}\n$$\nThe separable form of the potential implies that the K-matrix, $K(p,p';E)$, is also separable in the same basis:\n$$\nK(p,p';E) = \\mathbf{v}(p, \\Lambda)^T \\mathbf{M}(E, \\Lambda) \\mathbf{v}(p', \\Lambda)\n$$\nwhere $\\mathbf{M}(E, \\Lambda)$ is a $2 \\times 2$ matrix to be determined. Substituting this ansatz into the LS equation yields an algebraic equation for $\\mathbf{M}(E, \\Lambda)$:\n$$\n\\mathbf{M}(E, \\Lambda) = \\mathbf{G}(\\Lambda) + \\mathbf{G}(\\Lambda) \\mathbf{I}(E, \\Lambda) \\mathbf{M}(E, \\Lambda)\n$$\nHere, $\\mathbf{I}(E, \\Lambda)$ is a $2 \\times 2$ matrix whose elements are the principal value integrals:\n$$\nI_{ij}(E, \\Lambda) = \\frac{2}{\\pi} \\mathcal{P}\\int_0^\\infty dq\\, \\frac{q^2\\, v_i(q, \\Lambda)\\, v_j(q, \\Lambda)}{E-q^2}\n$$\nSolving the algebraic equation for $\\mathbf{M}$ by matrix inversion gives the nonperturbative solution:\n$$\n\\mathbf{M}(E, \\Lambda) = \\left[ \\mathbf{1} - \\mathbf{G}(\\Lambda) \\mathbf{I}(E, \\Lambda) \\right]^{-1} \\mathbf{G}(\\Lambda) \\equiv \\left[ \\mathbf{G}(\\Lambda)^{-1} - \\mathbf{I}(E, \\Lambda) \\right]^{-1}\n$$\nThe observable of interest is the on-shell K-matrix element $K_1(k; \\Lambda) = K(k,k;E=k^2)$:\n$$\nK_1(k; \\Lambda) = \\mathbf{v}(k, \\Lambda)^T \\left[ \\mathbf{G}(\\Lambda)^{-1} - \\mathbf{I}(k^2, \\Lambda) \\right]^{-1} \\mathbf{v}(k, \\Lambda)\n$$\nThe matrix to be inverted is:\n$$\n\\mathbf{G}(\\Lambda)^{-1} - \\mathbf{I}(k^2, \\Lambda) = \\begin{pmatrix} -1/g - I_{11}(k^2, \\Lambda) & -I_{12}(k^2, \\Lambda) \\\\ -I_{12}(k^2, \\Lambda) & 1/C(\\Lambda) - I_{22}(k^2, \\Lambda) \\end{pmatrix}\n$$\nwhere the symmetry $I_{12}=I_{21}$ has been used. The inversion and subsequent multiplication by $\\mathbf{v}(k, \\Lambda)$ yields a closed-form expression for $K_1(k; \\Lambda)$ in terms of the integrals $I_{ij}$ and the counterterm $C(\\Lambda)$.\n\nThe numerical challenge lies in computing the integrals $I_{ij}(E, \\Lambda)$. The regulator $R_\\Lambda(p)$ ensures the integral converges, so we can truncate the integration at an upper limit $Q_{\\max}$ where the integrand becomes negligible (e.g., $Q_{\\max} = 10\\Lambda$). The Cauchy principal value is handled using the subtraction method. Let $k=\\sqrt{E}$ and $F(q) = q^2 v_i(q) v_j(q)$. The integral is computed as:\n$$\n\\mathcal{P}\\int_0^{Q_{\\max}} dq \\frac{F(q)}{k^2-q^2} = \\int_0^{Q_{\\max}} dq \\frac{F(q) - F(k)}{k^2-q^2} + F(k) \\mathcal{P}\\int_0^{Q_{\\max}} \\frac{dq}{k^2-q^2}\n$$\nThe first term's integrand is regular at $q=k$ and can be computed with standard numerical quadrature. The second term is analytic:\n$$\nF(k) \\mathcal{P}\\int_0^{Q_{\\max}} \\frac{dq}{k^2-q^2} = F(k) \\frac{1}{2k} \\ln\\left|\\frac{Q_{\\max}+k}{Q_{\\max}-k}\\right|\n$$\nThe overall algorithm is as follows:\n1.  For each given cutoff $\\Lambda$:\n    a.  **Fit $C(\\Lambda)$**: Set $k = k_{\\mathrm{ref}} = 1.0$. Compute the necessary integrals $I_{ij}(k_{\\mathrm{ref}}^2, \\Lambda)$. Invert the expression for $K_1(k_{\\mathrm{ref}}; \\Lambda)$, which is linear in $1/C(\\Lambda)$, to solve for the value of $C(\\Lambda)$ that satisfies $K_1(k_{\\mathrm{ref}}; \\Lambda) = K_{\\mathrm{ref}} = -0.4$.\n    b.  **Predict $K_1(k_{\\mathrm{test}})$**: Set $k = k_{\\mathrm{test}} = 1.5$. Compute the integrals $I_{ij}(k_{\\mathrm{test}}^2, \\Lambda)$. Using the fitted value of $C(\\Lambda)$ from the previous step, calculate the predicted value of the observable $K_1(k_{\\mathrm{test}}; \\Lambda)$.\n2.  Collect the predicted values for all $\\Lambda$ and format the output as specified.\nThis procedure is implemented in the following Python code using `numpy` for array operations and `scipy.integrate.quad` for numerical integration.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\n# Problem parameters are defined globally for clarity.\nG_COUPLING = 5.0\nBETA = 1.0\nK_REF = 1.0\nK_REF_VAL = -0.4\nK_TEST = 1.5\n\ndef regulator(p, cutoff_lambda):\n    \"\"\"Gaussian-type regulator function R_Lambda(p).\"\"\"\n    if cutoff_lambda <= 0:\n        return 0.0\n    return np.exp(- (p / cutoff_lambda)**4)\n\ndef v1(p, cutoff_lambda):\n    \"\"\"Potential basis vector v_1(p).\"\"\"\n    return regulator(p, cutoff_lambda) * p / (p**2 + BETA**2)\n\ndef v2(p, cutoff_lambda):\n    \"\"\"Potential basis vector v_2(p).\"\"\"\n    return regulator(p, cutoff_lambda) * p\n\ndef principal_value_integral(F, k, q_max):\n    \"\"\"\n    Computes the Cauchy Principal Value of the integral of F(q)/(k^2-q^2)\n    from 0 to q_max using the subtraction method.\n    \"\"\"\n    if k <= 0 or k >= q_max:\n        raise ValueError(\"Pole k must be in (0, q_max) for this PV method.\")\n\n    F_at_k = F(k)\n\n    def integrand_subtracted(q):\n        # This integrand has a removable singularity at q=k.\n        # scipy.integrate.quad can handle this robustly.\n        if np.isclose(q, k):\n            # The limit is complicated to compute analytically, but quad's adaptive\n            # nature means it will sample points around k and converge correctly.\n            # A direct hit is highly unlikely.\n            return 0.0\n        return (F(q) - F_at_k) / (k**2 - q**2)\n\n    integral_part, _ = integrate.quad(integrand_subtracted, 0, q_max)\n    log_part = F_at_k * (1.0 / (2.0 * k)) * np.log((q_max + k) / (q_max - k))\n    \n    return integral_part + log_part\n\ndef compute_integrals(k, cutoff_lambda):\n    \"\"\"\n    Computes the three unique elements of the integral matrix I(k^2).\n    \"\"\"\n    q_max = 10.0 * cutoff_lambda\n\n    # Define the functions F(q) = q^2 * v_i(q) * v_j(q) for each integral.\n    def F11(q): return q**2 * v1(q, cutoff_lambda)**2\n    def F12(q): return q**2 * v1(q, cutoff_lambda) * v2(q, cutoff_lambda)\n    def F22(q): return q**2 * v2(q, cutoff_lambda)**2\n\n    I11 = (2.0 / np.pi) * principal_value_integral(F11, k, q_max)\n    I12 = (2.0 / np.pi) * principal_value_integral(F12, k, q_max)\n    I22 = (2.0 / np.pi) * principal_value_integral(F22, k, q_max)\n\n    return I11, I12, I22\n\ndef solve():\n    \"\"\"\n    Main function to perform renormalization and prediction for each cutoff.\n    \"\"\"\n    cutoffs = [1.5, 2.0, 4.0, 8.0, 16.0]\n    results = []\n\n    for cutoff_lambda in cutoffs:\n        # --- Step 1: Fit C(Lambda) using the reference datum ---\n        # Calculate integrals at the reference momentum k_ref.\n        I11_ref, I12_ref, I22_ref = compute_integrals(K_REF, cutoff_lambda)\n\n        # Evaluate basis vectors at k_ref.\n        v1_ref = v1(K_REF, cutoff_lambda)\n        v2_ref = v2(K_REF, cutoff_lambda)\n\n        # Solve for 1/C(Lambda) algebraically.\n        A0_ref = -1.0/G_COUPLING - I11_ref\n        \n        num_c = (K_REF_VAL * (A0_ref * I22_ref + I12_ref**2) - \n                 I22_ref * v1_ref**2 + \n                 2 * I12_ref * v1_ref * v2_ref + \n                 A0_ref * v2_ref**2)\n        \n        den_c = K_REF_VAL * A0_ref - v1_ref**2\n        \n        if np.isclose(den_c, 0):\n            # This case indicates a potential issue with the chosen parameters,\n            # but is unlikely for this problem.\n            raise RuntimeError(f\"Denominator for C(Lambda) is zero at Lambda={cutoff_lambda}\")\n        \n        one_over_C = num_c / den_c\n        \n        # --- Step 2: Predict K1 at the test momentum k_test ---\n        # Calculate integrals at the test momentum k_test.\n        I11_test, I12_test, I22_test = compute_integrals(K_TEST, cutoff_lambda)\n        \n        # Evaluate basis vectors at k_test.\n        v1_test = v1(K_TEST, cutoff_lambda)\n        v2_test = v2(K_TEST, cutoff_lambda)\n        \n        # Calculate K1(k_test) using the fitted C(Lambda).\n        A = -1.0/G_COUPLING - I11_test\n        B = -I12_test\n        D = one_over_C - I22_test\n        \n        det = A * D - B**2\n        \n        if np.isclose(det, 0):\n            raise RuntimeError(f\"Matrix is singular at Lambda={cutoff_lambda}\")\n            \n        k1_predicted = (D * v1_test**2 - 2 * B * v1_test * v2_test + A * v2_test**2) / det\n        results.append(k1_predicted)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After learning how to implement renormalization, we now turn to a crucial theoretical principle guiding the *design* of regulators. This practice explores how different regularization schemes can impact the known analytic structure of the long-range nuclear force, specifically the pole associated with one-pion exchange. By testing which scheme correctly preserves this feature within the Born approximation, you will gain a deeper appreciation for how effective field theories must respect the universal properties of long-distance physics .",
            "id": "3586286",
            "problem": "You will design and test a regulator for a two-body nuclear interaction in momentum space that preserves the analytic structure associated with long-range one-pion exchange, specifically the left-hand cut encoded by the pion pole in the momentum-transfer dispersion relation. The setting is nonrelativistic two-nucleon scattering at low energy in momentum space. The long-range part is modeled by One Pion Exchange (OPE), and the short-range part is modeled by a momentum-independent contact term. Your task is to implement two regulator schemes, and to test whether the residue of the pion pole in the $t$-channel, which is fixed by analyticity and crossing via dispersion relations, is preserved by the regulator choice when approximating the scattering $T$ matrix by its Born term.\n\nFundamental base:\n- In nonrelativistic potential scattering, the leading Born term of the scattering amplitude equals the interaction in momentum space. The long-range OPE potential in momentum-transfer representation has the form\n$$\nV_{\\pi}(q^2) = -\\frac{g^2}{q^2 + m_{\\pi}^2},\n$$\nwith $q$ the magnitude of the three-momentum transfer and $m_{\\pi}$ the pion mass. This $t$-channel structure corresponds to a simple pole at $q^2 = - m_{\\pi}^2$ (equivalently $t = m_{\\pi}^2$ when $t \\equiv -q^2$) and yields a spectral representation with positive spectral density (left-hand cut).\n- Dispersion-relation constraints imply that the residue of the pion pole in the $t$-channel is fixed by the coupling $g^2$, independent of short-distance details, because it arises from single-pion exchange. Therefore, any regulator that preserves the analytic properties of the long-range piece must not modify this residue.\n- The Lippmann–Schwinger (LS) equation defines the full $T$ matrix, but at sufficiently small $g$ its Born approximation $T \\approx V$ provides a controlled probe of the $t$-channel singularity structure. This problem restricts to that leading approximation to isolate the long-range analytic constraint.\n\nRegulators to implement:\n- Define the unregulated potential in momentum-transfer space\n$$\nV(q^2) = V_{\\pi}(q^2) + C_0,\n$$\nwith $C_0$ a short-range contact interaction.\n- Scheme A (naive): regulate the entire potential by a smooth multiplicative function of the momentum transfer squared,\n$$\nR_{\\text{naive}}(q^2;\\Lambda,n) = \\exp\\left[-\\left(\\frac{q^2}{\\Lambda^2}\\right)^n\\right],\n$$\nand set $V^{(A)}(q^2) = (V_{\\pi}(q^2) + C_0) R_{\\text{naive}}(q^2;\\Lambda,n)$.\n- Scheme B (short-range-only, semi-local): regulate only the contact interaction with the same function, leaving $V_{\\pi}$ untouched,\n$$\nV^{(B)}(q^2) = V_{\\pi}(q^2) + C_0 \\, R_{\\text{naive}}(q^2;\\Lambda,n).\n$$\n\nDispersion-relation test:\n- The long-range part of the Born $T$ matrix has a simple pole at $q^2 = - m_{\\pi}^2$. Its residue must be $-g^2$ if the regulator preserves the analytic properties of the OPE contribution. For a given scheme $S \\in \\{A,B\\}$, define the long-range piece of the Born amplitude in the $t$-channel as\n$$\nT^{(S)}_{\\text{LR}}(q^2) \\equiv \\begin{cases}\n-\\frac{g^2}{q^2 + m_{\\pi}^2} R_{\\text{naive}}(q^2;\\Lambda,n),  \\text{if } S = A \\\\\n-\\frac{g^2}{q^2 + m_{\\pi}^2},  \\text{if } S = B\n\\end{cases}\n$$\n- Numerically estimate the residue at the pion pole using the complex limit\n$$\n\\operatorname{Res}\\left[T^{(S)}_{\\text{LR}}, -m_{\\pi}^2\\right] \\equiv \\lim_{\\varepsilon \\to 0^+} \\left(q^2 + m_{\\pi}^2\\right) T^{(S)}_{\\text{LR}}(q^2) \\Big|_{q^2 = -m_{\\pi}^2 + i \\varepsilon}.\n$$\nA scheme passes the dispersion-relation constraint if the absolute deviation of the numerical residue from $-g^2$ is no larger than a specified tolerance.\n\nNumerical specifications:\n- Use $m_{\\pi} = 138$ MeV, and set $g^2 = 1$ (dimensionless) and $C_0 = 0$ in all computations. All momenta and cutoffs must be interpreted in mega-electron-volts (MeV), and $q^2$ in $\\text{MeV}^2$. No other physical units are required.\n- Use $n = 2$ throughout. To estimate the complex limit, average results computed at three small imaginary offsets $\\varepsilon_k \\in \\{10^{-6} m_{\\pi}^2, 3 \\cdot 10^{-6} m_{\\pi}^2, 10^{-5} m_{\\pi}^2\\}$. Use an absolute tolerance of $\\tau = 10^{-6}$ for the residue test, i.e., accept if $\\left|\\operatorname{Res} + g^2\\right| \\le \\tau$.\n\nTest suite:\nProvide the following six parameter sets $(\\text{scheme}, \\Lambda)$, with $n=2$ held fixed:\n- Case $1$: naive, $\\Lambda = 300$ MeV.\n- Case $2$: semi, $\\Lambda = 300$ MeV.\n- Case $3$: naive, $\\Lambda = 10000$ MeV.\n- Case $4$: semi, $\\Lambda = 10000$ MeV.\n- Case $5$: naive, $\\Lambda = 400$ MeV.\n- Case $6$: semi, $\\Lambda = 400$ MeV.\n\nFor each case, compute a single boolean result indicating whether the dispersion-relation constraint on the pion-pole residue holds for the long-range part of the Born $T$ matrix under that scheme.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of integers enclosed in square brackets, with $1$ for pass and $0$ for fail, in the order of the six cases listed above. For example, an output might look like \"[1,0,1,1,0,1]\".",
            "solution": "The problem requires an analysis of two different regularization schemes for a simplified two-nucleon potential in momentum space. The core task is to verify which scheme preserves a fundamental analytic property of the long-range nuclear force, specifically the residue of the pole associated with one-pion exchange (OPE). This test is performed within the Born approximation, where the scattering $T$-matrix is approximated by the potential itself, $T \\approx V$.\n\n### Principle and Theoretical Framework\n\nIn low-energy nuclear physics, the interaction between two nucleons is modeled by an effective potential. This potential consists of a long-range part, dominated by the exchange of the lightest meson (the pion), and a short-range part that parameterizes all unresolved high-energy physics through contact interactions.\n\nThe long-range OPE potential, in the momentum-transfer representation, is given by\n$$\nV_{\\pi}(q^2) = -\\frac{g^2}{q^2 + m_{\\pi}^2}\n$$\nwhere $q$ is the magnitude of the momentum transfer, $m_{\\pi}$ is the pion mass, and $g$ is the pion-nucleon coupling constant. A crucial feature of this expression is its analytic structure in the complex $q^2$ plane. It has a simple pole at $q^2 = -m_{\\pi}^2$. This pole corresponds to the $t$-channel exchange of a single pion and gives rise to the so-called left-hand cut in the partial-wave scattering amplitude, a feature dictated by the fundamental principles of causality and unitarity, as captured by dispersion relations.\n\nDispersion theory mandates that the residue of this pole is fixed by the coupling constant $g^2$ and the pion mass $m_{\\pi}$. Any physically sensible model must preserve this long-range structure. When introducing regularization to handle divergences from the short-range part of the interaction, the regulator function must not alter the analytic properties of the OPE potential.\n\nThe problem asks us to test two regularization schemes against this principle. The total unregulated potential is a sum of the OPE potential and a momentum-independent contact term $C_0$:\n$$\nV(q^2) = V_{\\pi}(q^2) + C_0\n$$\nFor this problem, we are instructed to set the contact term strength $C_0=0$. This simplifies the expressions but does not trivialize the test, which focuses exclusively on the fate of the OPE contribution under regularization.\n\n### Regulator Schemes and the Residue Test\n\nThe test involves calculating the residue of the long-range part of the Born $T$-matrix, denoted $T^{(S)}_{\\text{LR}}(q^2)$ for a scheme $S$, at the pion pole $q^2 = -m_{\\pi}^2$. The residue is defined by the limit:\n$$\n\\operatorname{Res}\\left[T^{(S)}_{\\text{LR}}, -m_{\\pi}^2\\right] = \\lim_{q^2 \\to -m_{\\pi}^2} \\left(q^2 + m_{\\pi}^2\\right) T^{(S)}_{\\text{LR}}(q^2)\n$$\nThe dispersion-relation constraint requires this residue to be exactly $-g^2$. We will numerically estimate this limit by evaluating the expression at $q^2 = -m_{\\pi}^2 + i\\varepsilon$ for small positive $\\varepsilon$. The problem specifies using $n=2$ for the regulator exponent and provides the physical parameters $m_{\\pi} = 138 \\, \\text{MeV}$, $g^2=1$, and $C_0=0$.\n\nThe regulator function is a Gaussian in momentum transfer squared:\n$$\nR_{\\text{naive}}(q^2;\\Lambda,n) = \\exp\\left[-\\left(\\frac{q^2}{\\Lambda^2}\\right)^n\\right]\n$$\n\n#### Scheme A: Naive Regularization\n\nIn this scheme, the entire potential is multiplied by the regulator function. Because we set $C_0=0$, the regulated potential is $V^{(A)}(q^2) = V_{\\pi}(q^2) R_{\\text{naive}}(q^2;\\Lambda,n)$. The long-range part of the Born amplitude is identified as:\n$$\nT^{(A)}_{\\text{LR}}(q^2) = -\\frac{g^2}{q^2 + m_{\\pi}^2} R_{\\text{naive}}(q^2;\\Lambda,n)\n$$\nWe now calculate the residue analytically:\n$$\n\\operatorname{Res}\\left[T^{(A)}_{\\text{LR}}, -m_{\\pi}^2\\right] = \\lim_{q^2 \\to -m_{\\pi}^2} (q^2 + m_{\\pi}^2) \\left( -\\frac{g^2}{q^2 + m_{\\pi}^2} R_{\\text{naive}}(q^2;\\Lambda,n) \\right)\n$$\n$$\n\\operatorname{Res}\\left[T^{(A)}_{\\text{LR}}, -m_{\\pi}^2\\right] = -g^2 \\lim_{q^2 \\to -m_{\\pi}^2} R_{\\text{naive}}(q^2;\\Lambda,n) = -g^2 R_{\\text{naive}}(-m_{\\pi}^2;\\Lambda,n)\n$$\nSubstituting $q^2 = -m_{\\pi}^2$ and $n=2$ into the regulator:\n$$\nR_{\\text{naive}}(-m_{\\pi}^2;\\Lambda,2) = \\exp\\left[-\\left(\\frac{-m_{\\pi}^2}{\\Lambda^2}\\right)^2\\right] = \\exp\\left[-\\frac{m_{\\pi}^4}{\\Lambda^4}\\right]\n$$\nThus, the residue for Scheme A is:\n$$\n\\operatorname{Res}\\left[T^{(A)}_{\\text{LR}}, -m_{\\pi}^2\\right] = -g^2 \\exp\\left[-\\frac{m_{\\pi}^4}{\\Lambda^4}\\right]\n$$\nThis result is not equal to $-g^2$ for any finite cutoff $\\Lambda$. The regulator has distorted the analytic structure of the OPE potential. The deviation from the correct value is $\\left| -g^2 \\exp\\left[-\\frac{m_{\\pi}^4}{\\Lambda^4}\\right] + g^2 \\right| = g^2 \\left(1 - \\exp\\left[-\\frac{m_{\\pi}^4}{\\Lambda^4}\\right]\\right)$. This deviation approaches zero only as $\\Lambda \\to \\infty$. For finite $\\Lambda$, this scheme will fail the test unless $\\Lambda$ is so large that the deviation falls below the tolerance $\\tau = 10^{-6}$.\n\n#### Scheme B: Semi-local Regularization\n\nIn this scheme, the regulator is applied only to the short-range contact term. The regulated potential is $V^{(B)}(q^2) = V_{\\pi}(q^2) + C_0 R_{\\text{naive}}(q^2;\\Lambda,n)$. With $C_0=0$, this simplifies to $V^{(B)}(q^2) = V_{\\pi}(q^2)$. The long-range part of the Born amplitude is therefore:\n$$\nT^{(B)}_{\\text{LR}}(q^2) = -\\frac{g^2}{q^2 + m_{\\pi}^2}\n$$\nThe residue is calculated as:\n$$\n\\operatorname{Res}\\left[T^{(B)}_{\\text{LR}}, -m_{\\pi}^2\\right] = \\lim_{q^2 \\to -m_{\\pi}^2} (q^2 + m_{\\pi}^2) \\left( -\\frac{g^2}{q^2 + m_{\\pi}^2} \\right) = -g^2\n$$\nThe residue is exactly $-g^2$, independent of the cutoff scale $\\Lambda$. This scheme correctly preserves the analytic structure of the OPE potential by construction. Therefore, it should pass the residue test for any value of $\\Lambda$.\n\n### Numerical Implementation and Algorithm\n\nThe algorithm will implement the residue test for each of the six specified cases.\n\n1.  Set the physical constants: $m_{\\pi} = 138$, $g^2 = 1$, $n = 2$, and the tolerance $\\tau = 10^{-6}$.\n2.  Define the set of imaginary offsets for the numerical limit: $\\varepsilon \\in \\{10^{-6} m_{\\pi}^2, 3 \\cdot 10^{-6} m_{\\pi}^2, 10^{-5} m_{\\pi}^2\\}$.\n3.  For each test case $(\\text{scheme}, \\Lambda)$:\n    a. Initialize an empty list to store the three residue estimates.\n    b. For each $\\varepsilon_k$ in the set of offsets:\n        i.  Calculate the complex evaluation point $q^2_{\\text{eval}} = -m_{\\pi}^2 + i\\varepsilon_k$.\n        ii. Calculate the residue estimate. The term $(q^2 + m_{\\pi}^2)$ becomes $i\\varepsilon_k$ at the evaluation point, which cancels with the denominator of the OPE potential.\n        iii. For Scheme A, the residue estimate is $\\operatorname{Res}_k = -g^2 \\exp\\left[-\\left(\\frac{q^2_{\\text{eval}}}{\\Lambda^2}\\right)^n\\right]$.\n        iv. For Scheme B, the residue estimate is simply $\\operatorname{Res}_k = -g^2$.\n        v. Append $\\operatorname{Res}_k$ to the list.\n    c. Compute the average of the three residue estimates: $\\overline{\\operatorname{Res}} = \\frac{1}{3} \\sum_{k=1}^3 \\operatorname{Res}_k$.\n    d. Calculate the absolute deviation from the expected value: $\\Delta = \\left| \\overline{\\operatorname{Res}} + g^2 \\right|$.\n    e. Compare the deviation to the tolerance $\\tau$. If $\\Delta \\le \\tau$, the test passes (result is $1$). Otherwise, it fails (result is $0$).\n4.  Collect the boolean results ($1$ or $0$) for all six cases into a list and format the output as specified.\n\nThis procedure will numerically confirm our analytical findings: Scheme B will consistently pass, while Scheme A will fail for \"hard\" (low) cutoffs and pass only for \"soft\" (very high) cutoffs where the regulator's effect at the pole becomes negligible.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nuclear physics regularization problem by testing two schemes\n    against a dispersion-relation constraint on the pion-pole residue.\n    \"\"\"\n\n    # Numerical specifications from the problem statement\n    m_pi = 138.0  # Pion mass in MeV\n    g_sq = 1.0    # Pion-nucleon coupling squared (dimensionless)\n    C_0 = 0.0     # Contact term strength (set to zero)\n    n = 2         # Regulator exponent\n    tau = 1.0e-6  # Absolute tolerance for the residue test\n\n    m_pi_sq = m_pi**2\n    \n    # Epsilon values for numerical limit estimation\n    epsilons = [1.0e-6 * m_pi_sq, 3.0e-6 * m_pi_sq, 1.0e-5 * m_pi_sq]\n\n    # Test suite from the problem statement\n    test_cases = [\n        ('naive', 300.0),   # Case 1\n        ('semi', 300.0),    # Case 2\n        ('naive', 10000.0), # Case 3\n        ('semi', 10000.0),  # Case 4\n        ('naive', 400.0),   # Case 5\n        ('semi', 400.0),    # Case 6\n    ]\n\n    results = []\n    \n    for scheme, Lambda in test_cases:\n        residue_estimates = []\n        \n        # The pole is at q^2 = -m_pi^2\n        pole_q2 = -m_pi_sq\n        \n        for eps in epsilons:\n            # Evaluate near the pole in the complex plane\n            q2_eval = pole_q2 + 1j * eps\n            \n            # The residue is lim_{q^2 - pole} (q^2 - pole) * T(q^2).\n            # Numerically, this is ((pole + i*eps) - pole) * T(pole + i*eps)\n            # = i*eps * T(pole + i*eps).\n            # For T(q^2) = -g^2/(q^2+m_pi^2) * R(q^2), this simplifies to\n            # i*eps * (-g^2 / (i*eps)) * R(q^2_eval) = -g^2 * R(q^2_eval).\n            \n            residue_val = 0.0\n            if scheme == 'naive':\n                # Scheme A: Regulate the entire potential\n                # V_A = (V_pi + C0) * R. With C0=0, V_A = V_pi * R.\n                # The residue is modified by the regulator.\n                Lambda_sq = Lambda**2\n                regulator = np.exp(-((q2_eval / Lambda_sq)**n))\n                residue_val = -g_sq * regulator\n            \n            elif scheme == 'semi':\n                # Scheme B: Regulate only the contact term\n                # V_B = V_pi + C0 * R. With C0=0, V_B = V_pi.\n                # The residue is Unaffected.\n                residue_val = -g_sq\n            \n            residue_estimates.append(residue_val)\n            \n        # Average the results from the different epsilon values\n        avg_residue = np.mean(residue_estimates)\n        \n        # The expected residue is -g^2. Test if the numerical result is close enough.\n        # Test condition: |Res_numerical + g^2| = tau\n        deviation = np.abs(avg_residue + g_sq)\n        \n        if deviation = tau:\n            results.append(1)  # Pass\n        else:\n            results.append(0)  # Fail\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}