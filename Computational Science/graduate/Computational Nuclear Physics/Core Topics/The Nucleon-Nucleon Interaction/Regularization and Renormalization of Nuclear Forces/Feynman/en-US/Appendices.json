{
    "hands_on_practices": [
        {
            "introduction": "Solving scattering equations on a computer requires discretizing continuous variables like momentum, a process that can introduce numerical artifacts. This foundational exercise  guides you through building a numerical solver for the Lippmann-Schwinger equation. You will learn how to implement a renormalization condition to fix a low-energy constant, ensuring that your calculated physical observable—the scattering length—remains stable and independent of the unphysical momentum cutoff you impose.",
            "id": "3586306",
            "problem": "You are asked to design, implement, and test a momentum-space discretization of the two-body $s$-wave Lippmann–Schwinger (LS) equation that preserves renormalization with a sharp ultraviolet momentum cutoff $\\Lambda$ and a regulated contact interaction. Your program must compute a renormalized low-energy observable and analyze numerical convergence as both the grid size $N$ and the quadrature family and order are varied.\n\nThe starting point is the momentum-space $s$-wave LS equation for the half-off-shell transition matrix $T(k',k;E)$ with a sharp cutoff $\\Lambda$:\n$$\nT(k',k;E) \\,=\\, V(k',k) \\, + \\, \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, V(k',q) \\, G_{0}(E,q) \\, T(q,k;E),\n$$\nwhere $k$ and $k'$ are relative momenta, $E$ is the center-of-mass energy, and $G_{0}(E,q) = \\big(E - q^{2}/(2\\mu) + i0\\big)^{-1}$ is the free resolvent for reduced mass $\\mu$. Use units in which $\\hbar = 1$ so that energies and momenta are dimensionally consistent; all outputs requested below are dimensionless numbers (no physical units are required).\n\nConsider a regulated, separable, contact interaction,\n$$\nV(k',k) \\,=\\, C(\\Lambda)\\, g(k')\\,g(k),\\quad g(k) \\,=\\, \\exp\\big(- (k/\\Lambda)^{2} \\big),\n$$\nwhere $C(\\Lambda)$ is a cutoff-dependent low-energy constant adjusted by renormalization. Because the interaction is separable, the LS equation admits the separable form $T(k',k;E) = g(k')\\, \\tau(E)\\, g(k)$, where the reduced amplitude $\\tau(E)$ satisfies\n$$\n\\tau(E) \\,=\\, \\frac{1}{\\,C(\\Lambda)^{-1} - I(E,\\Lambda)\\,},\n\\quad\nI(E,\\Lambda) \\,=\\, \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, g(q)^{2} \\, G_{0}(E,q).\n$$\n\nAt zero energy $E=0$, impose the standard threshold relation between the $s$-wave on-shell transition matrix and the scattering length $a_{0}$ for the chosen LS normalization,\n$$\nT(0,0;0) \\,=\\, -\\frac{2\\pi}{\\mu} a_{0}.\n$$\nWith the separable ansatz $T(0,0;0) = \\tau(0)$, this fixes $\\tau(0)$. The renormalization condition then yields a running coupling $C(\\Lambda)$ such that the low-energy observable $a_{0}$ is exactly reproduced in the continuum limit.\n\nYour tasks:\n\n1) From the LS equation and the separable ansatz, derive the discrete approximation of $I(0,\\Lambda)$ on a momentum grid $\\{q_{i}, w_{i}\\}_{i=1}^{N}$ designed to approximate $\\int_{0}^{\\Lambda} dq\\, f(q)$ by $\\sum_{i=1}^{N} w_{i} f(q_{i})$. Show explicitly that for $E=0$ the free resolvent simplifies the integrand so that\n$$\nI(0,\\Lambda) \\,=\\, -\\frac{4\\mu}{\\pi} \\int_{0}^{\\Lambda} dq\\, g(q)^{2},\n\\quad\nI_{N}(0,\\Lambda) \\,=\\, -\\frac{4\\mu}{\\pi} \\sum_{i=1}^{N} w_{i}\\, g(q_{i})^{2}.\n$$\nThen, express the discrete reduced amplitude as\n$$\n\\tau_{N}(0) \\,=\\, \\frac{1}{\\,C(\\Lambda)^{-1} - I_{N}(0,\\Lambda)\\,}.\n$$\n\n2) Using the threshold relation $T(0,0;0) = - 2\\pi a_{0}/\\mu$ and the separable form, determine $\\tau(0)$ at threshold and use it to construct the renormalization condition for $C(\\Lambda)$,\n$$\n\\frac{1}{\\tau(0)} \\,=\\, C(\\Lambda)^{-1} - I(0,\\Lambda).\n$$\nFor the regulator $g(k)=\\exp\\big(- (k/\\Lambda)^{2} \\big)$, evaluate $I(0,\\Lambda)$ analytically as a function of $\\mu$ and $\\Lambda$. Use this analytic result to obtain $C(\\Lambda)$ that reproduces the target $a_{0}$ in the continuum. This $C(\\Lambda)$ must then be used in the discretized scheme to test whether the discretization preserves renormalization as $N$ and quadrature choices vary.\n\n3) Implement two quadrature families for the momentum integral over $q \\in [0, \\Lambda]$:\n- A uniform grid with trapezoidal rule (denote by TRAP) with $N$ points including endpoints.\n- A Gauss–Legendre (GL) quadrature of order $N$ mapped from $[-1,1]$ to $[0,\\Lambda]$.\n\nFor a given $(\\mu, a_{0}, \\Lambda, N, \\text{family})$, compute the discrete estimate of the scattering length,\n$$\n\\hat{a}_{0}^{(N,\\text{family})} \\,=\\, -\\frac{\\mu}{2\\pi} \\, \\tau_{N}(0),\n$$\nand the absolute relative error $\\varepsilon \\,=\\, \\lvert (\\hat{a}_{0}^{(N,\\text{family})} - a_{0})/a_{0} \\rvert$.\n\n4) Design your program to produce a single line of output collecting the results for the test suite given below as a comma-separated list enclosed in square brackets. For all computations use $\\mu = 1.0$ (dimensionless), $\\hbar = 1$ (dimensionless), and $g(k)$ as specified. All outputs are pure numbers without units.\n\nTest suite:\n- Case $1$ (happy path, accuracy of GL): $a_{0} = 5.0$, $\\Lambda = 6.0$, GL quadrature, $N = 16$. Output the absolute relative error $\\varepsilon$ as a float.\n- Case $2$ (same parameters, TRAP vs GL comparison): $a_{0} = 5.0$, $\\Lambda = 6.0$, TRAP quadrature, $N = 16$. Output $\\varepsilon$.\n- Case $3$ (small cutoff, modest $N$): $a_{0} = 5.0$, $\\Lambda = 2.0$, GL quadrature, $N = 8$. Output $\\varepsilon$.\n- Case $4$ (small cutoff, TRAP): $a_{0} = 5.0$, $\\Lambda = 2.0$, TRAP quadrature, $N = 8$. Output $\\varepsilon$.\n- Case $5$ (renormalization invariance across cutoffs): $a_{0} = 5.0$, GL quadrature, $N = 24$, compare results at $\\Lambda_{1} = 3.0$ and $\\Lambda_{2} = 9.0$. Output the absolute difference $\\Delta = \\lvert \\hat{a}_{0}^{(N,\\text{GL})}(\\Lambda_{1}) - \\hat{a}_{0}^{(N,\\text{GL})}(\\Lambda_{2}) \\rvert$ as a float.\n- Case $6$ (edge case, large cutoff, smaller scattering length): $a_{0} = 0.5$, $\\Lambda = 20.0$, GL quadrature, $N = 64$. Output $\\varepsilon$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[r1,r2,r3,r4,r5,r6]`), where each $r_{i}$ is the float specified by the corresponding case above. No additional text should be printed.",
            "solution": "The user-provided problem is a valid and well-posed exercise in computational nuclear physics, specifically focusing on the numerical solution of the Lippmann-Schwinger equation and the principles of renormalization. The problem is scientifically grounded, internally consistent, and requires the application of standard, non-trivial techniques from quantum scattering theory and numerical analysis. We will proceed with a full, reasoned solution.\n\n### 1. Derivation of the Discrete Lippmann-Schwinger Equation at Threshold\n\nThe starting point is the $s$-wave Lippmann-Schwinger (LS) equation for the half-off-shell transition matrix $T(k',k;E)$ with an ultraviolet momentum cutoff $\\Lambda$:\n$$\nT(k',k;E) \\,=\\, V(k',k) \\, + \\, \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, V(k',q) \\, G_{0}(E,q) \\, T(q,k;E)\n$$\nThe potential $V(k',k)$ is a regulated, separable, contact interaction of the form $V(k',k) = C(\\Lambda) g(k') g(k)$, where $g(k) = \\exp(-(k/\\Lambda)^2)$. This separable form for the potential implies a separable solution for the T-matrix, $T(k',k;E) = g(k') \\tau(E) g(k)$. Substituting the separable forms for $V$ and $T$ into the LS equation yields:\n$$\ng(k') \\tau(E) g(k) = C(\\Lambda) g(k') g(k) + \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} [C(\\Lambda) g(k') g(q)] G_{0}(E,q) [g(q) \\tau(E) g(k)]\n$$\nWe can cancel the common factor of $g(k')g(k)$ from all terms (assuming they are non-zero), resulting in an algebraic equation for the reduced amplitude $\\tau(E)$:\n$$\n\\tau(E) = C(\\Lambda) + C(\\Lambda) \\tau(E) \\left[ \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, g(q)^{2} \\, G_{0}(E,q) \\right]\n$$\nDefining the loop integral $I(E,\\Lambda)$ as\n$$\nI(E,\\Lambda) \\,=\\, \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, g(q)^{2} \\, G_{0}(E,q),\n$$\nthe equation for $\\tau(E)$ becomes $\\tau(E) = C(\\Lambda) + C(\\Lambda) \\tau(E) I(E,\\Lambda)$. Solving for $\\tau(E)$:\n$$\n\\tau(E) (1 - C(\\Lambda)I(E,\\Lambda)) = C(\\Lambda) \\implies \\tau(E) = \\frac{C(\\Lambda)}{1 - C(\\Lambda)I(E,\\Lambda)} = \\frac{1}{C(\\Lambda)^{-1} - I(E,\\Lambda)}\n$$\nThis is the expression provided in the problem statement.\n\nFor Task 1, we must evaluate this at zero energy, $E=0$. The free resolvent $G_{0}(E,q) = (E - q^2/(2\\mu) + i0)^{-1}$ simplifies to:\n$$\nG_{0}(0,q) = \\left( -\\frac{q^2}{2\\mu} \\right)^{-1} = -\\frac{2\\mu}{q^2}\n$$\nSubstituting this into the expression for the loop integral $I(E, \\Lambda)$ at $E=0$:\n$$\nI(0,\\Lambda) = \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, g(q)^{2} \\left(-\\frac{2\\mu}{q^2}\\right) = -\\frac{4\\mu}{\\pi} \\int_{0}^{\\Lambda} dq\\, g(q)^{2}\n$$\nThis confirms the required expression for $I(0,\\Lambda)$.\n\nTo discretize this integral, we employ a numerical quadrature scheme defined by a set of momentum grid points $\\{q_i\\}_{i=1}^N$ and corresponding weights $\\{w_i\\}_{i=1}^N$. The integral is approximated by a weighted sum:\n$$\n\\int_{0}^{\\Lambda} dq\\, f(q) \\approx \\sum_{i=1}^{N} w_{i} f(q_{i})\n$$\nApplying this to our expression for $I(0,\\Lambda)$, we obtain its discrete approximation $I_{N}(0,\\Lambda)$:\n$$\nI_{N}(0,\\Lambda) \\,=\\, -\\frac{4\\mu}{\\pi} \\sum_{i=1}^{N} w_{i}\\, g(q_{i})^{2}\n$$\nThe corresponding discrete reduced amplitude $\\tau_N(0)$ is found by replacing the continuum integral $I(0,\\Lambda)$ with its discrete counterpart $I_N(0,\\Lambda)$ in the formula for $\\tau(E)$:\n$$\n\\tau_{N}(0) \\,=\\, \\frac{1}{\\,C(\\Lambda)^{-1} - I_{N}(0,\\Lambda)\\,}\n$$\n\n### 2. Renormalization Condition and Analytic Evaluation\n\nTask 2 requires us to determine the cutoff-dependent coupling constant $C(\\Lambda)$ by enforcing a physical condition. We anchor the theory to reproduce a known low-energy observable, the $s$-wave scattering length $a_0$. The relationship between the on-shell T-matrix at zero energy and $a_0$ is given as:\n$$\nT(0,0;0) = -\\frac{2\\pi}{\\mu} a_0\n$$\nUsing our separable T-matrix ansatz, $T(k',k;E) = g(k')\\tau(E)g(k)$, at $k=k'=E=0$, we have:\n$$\nT(0,0;0) = g(0) \\tau(0) g(0)\n$$\nWith the regulator $g(k) = \\exp(-(k/\\Lambda)^2)$, we have $g(0)=\\exp(0)=1$. Therefore, $T(0,0;0) = \\tau(0)$. Equating the two expressions for the on-shell T-matrix gives the physical value of the reduced amplitude at threshold:\n$$\n\\tau(0) = -\\frac{2\\pi a_0}{\\mu}\n$$\nThis serves as our renormalization condition. We demand that our continuum theory reproduces this exact value for $\\tau(0)$. By inverting the expression for $\\tau(0)$, we obtain the condition on the running coupling $C(\\Lambda)$:\n$$\n\\frac{1}{\\tau(0)} = C(\\Lambda)^{-1} - I(0,\\Lambda) \\implies C(\\Lambda)^{-1} = \\frac{1}{\\tau(0)} + I(0,\\Lambda)\n$$\nSubstituting $\\tau(0) = -2\\pi a_0/\\mu$, we get:\n$$\nC(\\Lambda)^{-1} = -\\frac{\\mu}{2\\pi a_0} + I(0,\\Lambda)\n$$\nTo obtain a fully analytic expression for $C(\\Lambda)$, we must evaluate the integral $I(0,\\Lambda)$ for the specific regulator $g(q)^2 = \\exp(-2(q/\\Lambda)^2)$:\n$$\nI(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\int_{0}^{\\Lambda} dq\\, e^{-2(q/\\Lambda)^2}\n$$\nWe perform a change of variables. Let $u = \\sqrt{2} q/\\Lambda$, which implies $dq = (\\Lambda/\\sqrt{2}) du$. The integration limits change from $[0, \\Lambda]$ to $[0, \\sqrt{2}]$.\n$$\nI(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\int_{0}^{\\sqrt{2}} e^{-u^2} \\frac{\\Lambda}{\\sqrt{2}} du = -\\frac{4\\mu\\Lambda}{\\pi\\sqrt{2}} \\int_{0}^{\\sqrt{2}} e^{-u^2} du\n$$\nThe integral is related to the error function, $\\mathrm{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{-t^2} dt$, so $\\int_0^x e^{-t^2} dt = \\frac{\\sqrt{\\pi}}{2}\\mathrm{erf}(x)$.\n$$\nI(0,\\Lambda) = -\\frac{4\\mu\\Lambda}{\\pi\\sqrt{2}} \\left( \\frac{\\sqrt{\\pi}}{2} \\mathrm{erf}(\\sqrt{2}) \\right) = -\\frac{2\\mu\\Lambda}{\\sqrt{2\\pi}} \\mathrm{erf}(\\sqrt{2}) = -\\mu\\Lambda\\sqrt{\\frac{2}{\\pi}} \\mathrm{erf}(\\sqrt{2})\n$$\nFinally, substituting this analytic result back into the expression for $C(\\Lambda)^{-1}$:\n$$\nC(\\Lambda)^{-1} = -\\frac{\\mu}{2\\pi a_0} - \\mu\\Lambda\\sqrt{\\frac{2}{\\pi}} \\mathrm{erf}(\\sqrt{2})\n$$\nThis expression defines the value of the coupling $C(\\Lambda)$ required at any cutoff $\\Lambda$ to exactly reproduce the scattering length $a_0$ in the continuum theory. This is the coupling that must be used in our discrete calculation to test whether the discretization preserves this property.\n\n### 3. Numerical Implementation and Quadrature Schemes\n\nThe goal is to compute a numerical estimate of the scattering length, $\\hat{a}_{0}^{(N,\\text{family})}$, and compare it to the target value $a_0$. The estimated scattering length is obtained from the discrete reduced amplitude $\\tau_N(0)$:\n$$\n\\hat{a}_{0}^{(N,\\text{family})} = -\\frac{\\mu}{2\\pi} \\tau_{N}(0) = -\\frac{\\mu}{2\\pi} \\left( \\frac{1}{C(\\Lambda)^{-1} - I_{N}(0,\\Lambda)} \\right)\n$$\nThe core of the numerical task is the computation of the discrete loop integral $I_{N}(0, \\Lambda)$ for two different quadrature families.\n\n- **Trapezoidal Rule (TRAP) on a Uniform Grid:**\nFor a grid of $N$ points including the endpoints $0$ and $\\Lambda$, the step size is $h = \\Lambda/(N-1)$. The grid points are $q_i = (i-1)h$ for $i=1, ..., N$. The trapezoidal rule approximates the integral as a sum with weights $w_1 = h/2$, $w_N = h/2$, and $w_i = h$ for $i=2, ..., N-1$.\n\n- **Gauss–Legendre (GL) Quadrature:**\nThis method is typically defined on the interval $[-1, 1]$. We use a linear transformation to map the standard GL nodes $x_i \\in [-1, 1]$ and weights $w_i^{\\text{GL}}$ to the momentum interval $q \\in [0, \\Lambda]$.\nThe transformation is $q(x) = \\frac{\\Lambda}{2}(x+1)$, with differential $dq = \\frac{\\Lambda}{2}dx$. The integral becomes:\n$$\n\\int_0^\\Lambda f(q) dq = \\int_{-1}^1 f\\left( \\frac{\\Lambda}{2}(x+1) \\right) \\frac{\\Lambda}{2} dx \\approx \\sum_{i=1}^N \\frac{\\Lambda}{2} w_i^{\\text{GL}} f\\left( \\frac{\\Lambda}{2}(x_i+1) \\right)\n$$\nThus, the quadrature points and weights for our momentum grid are:\n$$\nq_i = \\frac{\\Lambda}{2}(x_i+1), \\quad w_i = \\frac{\\Lambda}{2}w_i^{\\text{GL}}\n$$\n\nThe overall algorithm for each test case is as follows:\n1.  Given the parameters $(\\mu, a_{0}, \\Lambda, N, \\text{family})$, first compute the analytical value of the inverse coupling $C(\\Lambda)^{-1}$ using the formula derived in Section 2.\n2.  Generate the set of quadrature points $\\{q_i\\}$ and weights $\\{w_i\\}$ for the specified family (TRAP or GL), size $N$, and range $[0, \\Lambda]$.\n3.  Calculate the regulator function values $g(q_i)^2 = \\exp(-2(q_i/\\Lambda)^2)$ on the grid.\n4.  Compute the discrete loop integral $I_{N}(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\sum_{i=1}^{N} w_{i} g(q_i)^2$.\n5.  Calculate the discrete reduced amplitude $\\tau_N(0) = (C(\\Lambda)^{-1} - I_{N}(0,\\Lambda))^{-1}$.\n6.  Compute the estimated scattering length $\\hat{a}_{0} = -\\mu/(2\\pi) \\tau_N(0)$.\n7.  Finally, compute the specified output metric: either the absolute relative error $\\varepsilon = \\lvert (\\hat{a}_{0} - a_{0})/a_{0} \\rvert$ or the absolute difference $\\Delta$ between two calculations.\n\nThis procedure tests how well a given discretization scheme (quadrature rule and grid size) approximates the continuum limit, where $\\hat{a}_0$ would be exactly equal to $a_0$. The error $\\varepsilon$ quantifies the accuracy of the numerical approximation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    Designs, implements, and tests a momentum-space discretization of the\n    two-body s-wave Lippmann–Schwinger equation.\n    \"\"\"\n\n    # --- Problem constants ---\n    MU = 1.0  # Reduced mass (dimensionless)\n\n    def get_quadrature(Lambda, N, family):\n        \"\"\"\n        Generates quadrature points and weights for the integral from 0 to Lambda.\n\n        Args:\n            Lambda (float): The momentum cutoff.\n            N (int): The number of quadrature points.\n            family (str): The quadrature family ('GL' for Gauss-Legendre, 'TRAP' for Trapezoidal).\n\n        Returns:\n            tuple: A tuple containing:\n                - q (np.ndarray): The momentum grid points.\n                - w (np.ndarray): The corresponding quadrature weights.\n        \"\"\"\n        if family == 'GL':\n            # Gauss-Legendre quadrature mapped from [-1, 1] to [0, Lambda]\n            x_gl, w_gl = np.polynomial.legendre.leggauss(N)\n            q = 0.5 * Lambda * (x_gl + 1.0)\n            w = 0.5 * Lambda * w_gl\n        elif family == 'TRAP':\n            # Trapezoidal rule on a uniform grid\n            if N < 2:\n                # Handle edge case of N < 2 for trapezoidal rule\n                if N == 1:\n                    return np.array([0.0]), np.array([Lambda])\n                else: # N=0\n                    return np.array([]), np.array([])\n            q = np.linspace(0.0, Lambda, N)\n            h = Lambda / (N - 1.0)\n            w = np.full(N, h)\n            w[0] = h / 2.0\n            w[-1] = h / 2.0\n        else:\n            raise ValueError(f\"Unknown quadrature family: {family}\")\n        return q, w\n\n    def compute_scattering_length(a0, Lambda, N, family):\n        \"\"\"\n        Computes the discrete estimate of the scattering length.\n\n        Args:\n            a0 (float): The target scattering length for renormalization.\n            Lambda (float): The momentum cutoff.\n            N (int): The number of quadrature points.\n            family (str): The quadrature family ('GL' or 'TRAP').\n\n        Returns:\n            float: The computed estimate of the scattering length, a0_hat.\n        \"\"\"\n        # Regulator function g(k)^2\n        g2 = lambda k: np.exp(-2.0 * (k / Lambda)**2)\n\n        # 1. Analytically determine the inverse coupling C(Lambda)^-1\n        # This is the renormalization condition.\n        # I(0, Lambda) = - (4*mu/pi) * integral(g(q)^2 dq, 0, Lambda)\n        # integral = (Lambda * sqrt(pi)) / (2*sqrt(2)) * erf(sqrt(2))\n        I_continuum = -MU * Lambda * np.sqrt(2.0 / np.pi) * erf(np.sqrt(2.0))\n        \n        # C(Lambda)^-1 = 1/tau(0) + I(0, Lambda), with tau(0) = -2*pi*a0/mu\n        C_inv = -MU / (2.0 * np.pi * a0) + I_continuum\n\n        # 2. Generate quadrature points and weights\n        q, w = get_quadrature(Lambda, N, family)\n\n        # 3. Compute the discrete loop integral I_N(0, Lambda)\n        integrand_vals = g2(q)\n        I_discrete = - (4.0 * MU / np.pi) * np.sum(w * integrand_vals)\n\n        # 4. Compute the discrete reduced amplitude tau_N_0\n        tau_N_0 = 1.0 / (C_inv - I_discrete)\n\n        # 5. Compute the estimated scattering length a0_hat\n        a0_hat = -MU / (2.0 * np.pi) * tau_N_0\n        \n        return a0_hat\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1: a0=5.0, Lambda=6.0, GL, N=16. Output epsilon.\n        {'a0': 5.0, 'Lambda': 6.0, 'N': 16, 'family': 'GL', 'type': 'error'},\n        # Case 2: a0=5.0, Lambda=6.0, TRAP, N=16. Output epsilon.\n        {'a0': 5.0, 'Lambda': 6.0, 'N': 16, 'family': 'TRAP', 'type': 'error'},\n        # Case 3: a0=5.0, Lambda=2.0, GL, N=8. Output epsilon.\n        {'a0': 5.0, 'Lambda': 2.0, 'N': 8, 'family': 'GL', 'type': 'error'},\n        # Case 4: a0=5.0, Lambda=2.0, TRAP, N=8. Output epsilon.\n        {'a0': 5.0, 'Lambda': 2.0, 'N': 8, 'family': 'TRAP', 'type': 'error'},\n        # Case 5: a0=5.0, GL, N=24. Compare Lambda1=3.0 and Lambda2=9.0. Output abs diff.\n        {'a0': 5.0, 'N': 24, 'family': 'GL', 'Lambda1': 3.0, 'Lambda2': 9.0, 'type': 'diff'},\n        # Case 6: a0=0.5, Lambda=20.0, GL, N=64. Output epsilon.\n        {'a0': 0.5, 'Lambda': 20.0, 'N': 64, 'family': 'GL', 'type': 'error'},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'error':\n            a0 = case['a0']\n            a0_hat = compute_scattering_length(\n                a0=a0,\n                Lambda=case['Lambda'],\n                N=case['N'],\n                family=case['family']\n            )\n            error = np.abs((a0_hat - a0) / a0)\n            results.append(error)\n        \n        elif case['type'] == 'diff':\n            a0_hat1 = compute_scattering_length(\n                a0=case['a0'],\n                Lambda=case['Lambda1'],\n                N=case['N'],\n                family=case['family']\n            )\n            a0_hat2 = compute_scattering_length(\n                a0=case['a0'],\n                Lambda=case['Lambda2'],\n                N=case['N'],\n                family=case['family']\n            )\n            diff = np.abs(a0_hat1 - a0_hat2)\n            results.append(diff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While some interactions can be treated perturbatively, many components of the nuclear force are singular and require a more robust, nonperturbative approach. This practice  explores the nonperturbative renormalization of a singular potential, a central task in modern Effective Field Theory. You will implement a \"fit-and-predict\" paradigm, introducing a counterterm to absorb cutoff-dependent divergences and fitting its value to an experimental datum to make a reliable prediction for another observable.",
            "id": "3586377",
            "problem": "You are to investigate nonperturbative renormalization in a singular tensor channel by modeling the uncoupled triplet $P$-wave $\\,^{3}P_{0}$ as an attractive long-range tensor-induced interaction plus a leading-order counterterm. Adopt natural units where $\\hbar = 1$ and $2\\mu = 1$, so that the two-body center-of-mass energy is $E = k^2$ and all quantities are dimensionless. Work entirely in momentum space and in a single partial wave.\n\nFundamental base and model:\n- Start from the Lippmann–Schwinger equation for the partial-wave reactance (K-) matrix in a single channel,\n$$\nK(p,p';E) \\;=\\; V(p,p') \\;+\\; \\frac{2}{\\pi}\\,\\mathcal{P}\\!\\!\\int_{0}^{\\infty} dq\\, \\frac{q^2\\, V(p,q)\\, K(q,p';E)}{E - q^2}\\,,\n$$\nwhere $\\mathcal{P}$ denotes the Cauchy principal value.\n- Model the regularized leading-order potential for the $\\,^{3}P_{0}$ channel as the sum of a long-range separable term representing the tensor force and a leading-order $P$-wave counterterm,\n$$\nV(p,p';\\Lambda) \\;=\\; R_{\\Lambda}(p)\\, R_{\\Lambda}(p')\\left[\\,-\\,g\\, \\frac{p}{p^2+\\beta^2}\\, \\frac{p'}{{p'}^2+\\beta^2} \\;+\\; C(\\Lambda)\\, p\\,p' \\right]\\,,\n$$\nwith Gaussian-type regulator\n$$\nR_{\\Lambda}(p) \\;=\\; \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{4}\\right].\n$$\nHere $g > 0$ is a fixed coupling of the long-range part, $\\beta > 0$ sets a finite-range scale, and $C(\\Lambda)$ is a running counterterm to be fit at each cutoff $\\Lambda$.\n\nObservables and renormalization protocol:\n- Define the on-shell reactance matrix element as $K_1(k;\\Lambda) \\equiv K(k,k;E=k^2)$ in the $P$-wave. You will assess regulator independence by the following nonperturbative renormalization prescription:\n  1. For a given $\\Lambda$, determine $C(\\Lambda)$ by refitting to the datum\n     $K_1(k_{\\mathrm{ref}};\\Lambda) \\;=\\; K_{\\mathrm{ref}}$,\n     at the reference momentum $k_{\\mathrm{ref}}$ and target value $K_{\\mathrm{ref}}$ specified below.\n  2. With the fitted $C(\\Lambda)$ fixed, predict $K_1(k_{\\mathrm{test}};\\Lambda)$ at the test momentum $k_{\\mathrm{test}}$.\n  3. Compare the predictions $K_1(k_{\\mathrm{test}};\\Lambda)$ as $\\Lambda$ varies. Regulator independence after refitting corresponds to these values approaching a common limit as $\\Lambda$ increases.\n\nComputational requirements:\n- Treat the principal value integral numerically by splitting the integration domain at $q = k$, excluding an infinitesimal neighborhood around the pole. Truncate the upper limit to a finite $Q_{\\max}$ justified by the regulator, and ensure numerical convergence.\n- You must not use perturbation theory; solve the integral equation nonperturbatively. You may exploit the separability of the model potential to reduce the integral equation to a finite-dimensional algebraic system, if you can derive it from first principles.\n\nParameter values and units:\n- Use $g = 5.0$ and $\\beta = 1.0$.\n- Use $k_{\\mathrm{ref}} = 1.0$ and $K_{\\mathrm{ref}} = -0.4$.\n- Use $k_{\\mathrm{test}} = 1.5$.\n- All quantities are dimensionless due to the choice $\\hbar = 1$ and $2\\mu = 1$.\n\nTest suite:\n- Evaluate the predicted values of $K_1(k_{\\mathrm{test}};\\Lambda)$ for the following cutoffs:\n  - Edge-case small cutoff: $\\Lambda = 2.0$.\n  - Moderate cutoff: $\\Lambda = 4.0$.\n  - Large cutoff: $\\Lambda = 8.0$.\n  - Very large cutoff: $\\Lambda = 16.0$.\n- Additionally, as a boundary sensitivity probe, include $\\Lambda = 1.5$.\n\nFinal output specification:\n- Your program must compute, for each $\\Lambda$ in the list $[\\;1.5,\\;2.0,\\;4.0,\\;8.0,\\;16.0\\;]$, the value of $K_1(k_{\\mathrm{test}};\\Lambda)$ after refitting $C(\\Lambda)$ at $k_{\\mathrm{ref}}$ to the datum $K_{\\mathrm{ref}}$.\n- The program must output a single line containing these five results as a comma-separated list enclosed in square brackets, in the same order of $\\Lambda$ as above. Each number must be a decimal rounded to six digits after the decimal point. For example, `[x_1,x_2,x_3,x_4,x_5]` with each $x_i$ a float with exactly six digits after the decimal point.",
            "solution": "The problem requires the nonperturbative solution of the Lippmann-Schwinger (LS) equation for the partial-wave reactance matrix, $K$, in the presence of a singular potential. The prescribed renormalization procedure involves fitting a counterterm to a single datum at a reference energy scale and then predicting an observable at a different energy scale. The stability of this prediction with respect to the regulator cutoff, $\\Lambda$, is the measure of successful renormalization.\n\nFirst, we validate the problem statement.\n\n**Step 1: Extract Givens**\n- Lippmann-Schwinger equation: $K(p,p';E) = V(p,p') + \\frac{2}{\\pi}\\,\\mathcal{P}\\int_{0}^{\\infty} dq\\, \\frac{q^2\\, V(p,q)\\, K(q,p';E)}{E - q^2}$.\n- Potential model: $V(p,p';\\Lambda) = R_{\\Lambda}(p)\\, R_{\\Lambda}(p')\\left[\\,-\\,g\\, \\frac{p}{p^2+\\beta^2}\\, \\frac{p'}{{p'}^2+\\beta^2} + C(\\Lambda)\\, p\\,p' \\right]$.\n- Regulator: $R_{\\Lambda}(p) = \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{4}\\right]$.\n- Units and Kinematics: $\\hbar = 1$, $2\\mu = 1$, so $E = k^2$.\n- Observable: On-shell reactance matrix element $K_1(k;\\Lambda) \\equiv K(k,k;E=k^2)$.\n- Renormalization Condition: $K_1(k_{\\mathrm{ref}};\\Lambda) = K_{\\mathrm{ref}}$.\n- Parameters: $g = 5.0$, $\\beta = 1.0$, $k_{\\mathrm{ref}} = 1.0$, $K_{\\mathrm{ref}} = -0.4$, $k_{\\mathrm{test}} = 1.5$.\n- Test Suite: $\\Lambda \\in \\{\\;1.5,\\;2.0,\\;4.0,\\;8.0,\\;16.0\\;\\}$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, rooted in standard quantum scattering theory and effective field theory principles. The potential is a rank-2 separable potential, a common and well-understood model. The LS equation is a fundamental equation in this field. The renormalization protocol is a standard procedure for handling nonrenormalizable interactions in a cutoff framework. All parameters and functions are explicitly defined, making the problem self-contained and well-posed. The task is a non-trivial but computationally feasible numerical exercise. There are no contradictions, ambiguities, or factual inaccuracies.\n\n**Step 3: Verdict and Action**\nThe problem is valid. We proceed with the solution.\n\nThe key to solving the integral equation nonperturbatively is to exploit the separable nature of the potential, $V(p,p';\\Lambda)$. We can express the potential in matrix form as:\n$$\nV(p,p';\\Lambda) = \\mathbf{v}(p, \\Lambda)^T \\mathbf{G}(\\Lambda) \\mathbf{v}(p', \\Lambda)\n$$\nwhere $\\mathbf{v}(p, \\Lambda)$ is a column vector representing the momentum-dependent parts of the potential, and $\\mathbf{G}(\\Lambda)$ is a matrix of coupling constants. We define the basis vectors as:\n$$\nv_1(p, \\Lambda) = R_{\\Lambda}(p) \\frac{p}{p^2+\\beta^2} \\quad \\text{and} \\quad v_2(p, \\Lambda) = R_{\\Lambda}(p) p\n$$\nsuch that $\\mathbf{v}(p, \\Lambda) = \\begin{pmatrix} v_1(p, \\Lambda) \\\\ v_2(p, \\Lambda) \\end{pmatrix}$. The coupling matrix $\\mathbf{G}(\\Lambda)$ is diagonal:\n$$\n\\mathbf{G}(\\Lambda) = \\begin{pmatrix} -g & 0 \\\\ 0 & C(\\Lambda) \\end{pmatrix}\n$$\nThe separable form of the potential implies that the K-matrix, $K(p,p';E)$, is also separable in the same basis:\n$$\nK(p,p';E) = \\mathbf{v}(p, \\Lambda)^T \\mathbf{M}(E, \\Lambda) \\mathbf{v}(p', \\Lambda)\n$$\nwhere $\\mathbf{M}(E, \\Lambda)$ is a $2 \\times 2$ matrix to be determined. Substituting this ansatz into the LS equation yields an algebraic equation for $\\mathbf{M}(E, \\Lambda)$:\n$$\n\\mathbf{M}(E, \\Lambda) = \\mathbf{G}(\\Lambda) + \\mathbf{G}(\\Lambda) \\mathbf{I}(E, \\Lambda) \\mathbf{M}(E, \\Lambda)\n$$\nHere, $\\mathbf{I}(E, \\Lambda)$ is a $2 \\times 2$ matrix whose elements are the principal value integrals:\n$$\nI_{ij}(E, \\Lambda) = \\frac{2}{\\pi} \\mathcal{P}\\!\\!\\int_0^\\infty dq\\, \\frac{q^2\\, v_i(q, \\Lambda)\\, v_j(q, \\Lambda)}{E-q^2}\n$$\nSolving the algebraic equation for $\\mathbf{M}$ by matrix inversion gives the nonperturbative solution:\n$$\n\\mathbf{M}(E, \\Lambda) = \\left[ \\mathbf{1} - \\mathbf{G}(\\Lambda) \\mathbf{I}(E, \\Lambda) \\right]^{-1} \\mathbf{G}(\\Lambda) \\equiv \\left[ \\mathbf{G}(\\Lambda)^{-1} - \\mathbf{I}(E, \\Lambda) \\right]^{-1}\n$$\nThe observable of interest is the on-shell K-matrix element $K_1(k; \\Lambda) = K(k,k;E=k^2)$:\n$$\nK_1(k; \\Lambda) = \\mathbf{v}(k, \\Lambda)^T \\left[ \\mathbf{G}(\\Lambda)^{-1} - \\mathbf{I}(k^2, \\Lambda) \\right]^{-1} \\mathbf{v}(k, \\Lambda)\n$$\nThe matrix to be inverted is:\n$$\n\\mathbf{G}(\\Lambda)^{-1} - \\mathbf{I}(k^2, \\Lambda) = \\begin{pmatrix} -1/g - I_{11}(k^2, \\Lambda) & -I_{12}(k^2, \\Lambda) \\\\ -I_{12}(k^2, \\Lambda) & 1/C(\\Lambda) - I_{22}(k^2, \\Lambda) \\end{pmatrix}\n$$\nwhere the symmetry $I_{12}=I_{21}$ has been used. The inversion and subsequent multiplication by $\\mathbf{v}(k, \\Lambda)$ yields a closed-form expression for $K_1(k; \\Lambda)$ in terms of the integrals $I_{ij}$ and the counterterm $C(\\Lambda)$.\n\nThe numerical challenge lies in computing the integrals $I_{ij}(E, \\Lambda)$. The regulator $R_\\Lambda(p)$ ensures the integral converges, so we can truncate the integration at an upper limit $Q_{\\max}$ where the integrand becomes negligible (e.g., $Q_{\\max} = 10\\Lambda$). The Cauchy principal value is handled using the subtraction method. Let $k=\\sqrt{E}$ and $F(q) = q^2 v_i(q) v_j(q)$. The integral is computed as:\n$$\n\\mathcal{P}\\!\\!\\int_0^{Q_{\\max}} dq \\frac{F(q)}{k^2-q^2} = \\int_0^{Q_{\\max}} dq \\frac{F(q) - F(k)}{k^2-q^2} + F(k) \\mathcal{P}\\!\\!\\int_0^{Q_{\\max}} \\frac{dq}{k^2-q^2}\n$$\nThe first term's integrand is regular at $q=k$ and can be computed with standard numerical quadrature. The second term is analytic:\n$$\nF(k) \\mathcal{P}\\!\\!\\int_0^{Q_{\\max}} \\frac{dq}{k^2-q^2} = F(k) \\frac{1}{2k} \\ln\\left|\\frac{Q_{\\max}+k}{Q_{\\max}-k}\\right|\n$$\nThe overall algorithm is as follows:\n1.  For each given cutoff $\\Lambda$:\n    a.  **Fit $C(\\Lambda)$**: Set $k = k_{\\mathrm{ref}} = 1.0$. Compute the necessary integrals $I_{ij}(k_{\\mathrm{ref}}^2, \\Lambda)$. Invert the expression for $K_1(k_{\\mathrm{ref}}; \\Lambda)$, which is linear in $1/C(\\Lambda)$, to solve for the value of $C(\\Lambda)$ that satisfies $K_1(k_{\\mathrm{ref}}; \\Lambda) = K_{\\mathrm{ref}} = -0.4$.\n    b.  **Predict $K_1(k_{\\mathrm{test}})$**: Set $k = k_{\\mathrm{test}} = 1.5$. Compute the integrals $I_{ij}(k_{\\mathrm{test}}^2, \\Lambda)$. Using the fitted value of $C(\\Lambda)$ from the previous step, calculate the predicted value of the observable $K_1(k_{\\mathrm{test}}; \\Lambda)$.\n2.  Collect the predicted values for all $\\Lambda$ and format the output as specified.\nThis procedure is implemented in the following Python code using `numpy` for array operations and `scipy.integrate.quad` for numerical integration.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\n# Problem parameters are defined globally for clarity.\nG_COUPLING = 5.0\nBETA = 1.0\nK_REF = 1.0\nK_REF_VAL = -0.4\nK_TEST = 1.5\n\ndef regulator(p, cutoff_lambda):\n    \"\"\"Gaussian-type regulator function R_Lambda(p).\"\"\"\n    if cutoff_lambda <= 0:\n        return 0.0\n    return np.exp(- (p / cutoff_lambda)**4)\n\ndef v1(p, cutoff_lambda):\n    \"\"\"Potential basis vector v_1(p).\"\"\"\n    return regulator(p, cutoff_lambda) * p / (p**2 + BETA**2)\n\ndef v2(p, cutoff_lambda):\n    \"\"\"Potential basis vector v_2(p).\"\"\"\n    return regulator(p, cutoff_lambda) * p\n\ndef principal_value_integral(F, k, q_max):\n    \"\"\"\n    Computes the Cauchy Principal Value of the integral of F(q)/(k^2-q^2)\n    from 0 to q_max using the subtraction method.\n    \"\"\"\n    if k <= 0 or k >= q_max:\n        raise ValueError(\"Pole k must be in (0, q_max) for this PV method.\")\n\n    F_at_k = F(k)\n\n    def integrand_subtracted(q):\n        # This integrand has a removable singularity at q=k.\n        # scipy.integrate.quad can handle this robustly.\n        if np.isclose(q, k):\n            # The limit is complicated to compute analytically, but quad's adaptive\n            # nature means it will sample points around k and converge correctly.\n            # A direct hit is highly unlikely.\n            return 0.0\n        return (F(q) - F_at_k) / (k**2 - q**2)\n\n    integral_part, _ = integrate.quad(integrand_subtracted, 0, q_max)\n    log_part = F_at_k * (1.0 / (2.0 * k)) * np.log((q_max + k) / (q_max - k))\n    \n    return integral_part + log_part\n\ndef compute_integrals(k, cutoff_lambda):\n    \"\"\"\n    Computes the three unique elements of the integral matrix I(k^2).\n    \"\"\"\n    q_max = 10.0 * cutoff_lambda\n\n    # Define the functions F(q) = q^2 * v_i(q) * v_j(q) for each integral.\n    def F11(q): return q**2 * v1(q, cutoff_lambda)**2\n    def F12(q): return q**2 * v1(q, cutoff_lambda) * v2(q, cutoff_lambda)\n    def F22(q): return q**2 * v2(q, cutoff_lambda)**2\n\n    I11 = (2.0 / np.pi) * principal_value_integral(F11, k, q_max)\n    I12 = (2.0 / np.pi) * principal_value_integral(F12, k, q_max)\n    I22 = (2.0 / np.pi) * principal_value_integral(F22, k, q_max)\n\n    return I11, I12, I22\n\ndef solve():\n    \"\"\"\n    Main function to perform renormalization and prediction for each cutoff.\n    \"\"\"\n    cutoffs = [1.5, 2.0, 4.0, 8.0, 16.0]\n    results = []\n\n    for cutoff_lambda in cutoffs:\n        # --- Step 1: Fit C(Lambda) using the reference datum ---\n        # Calculate integrals at the reference momentum k_ref.\n        I11_ref, I12_ref, I22_ref = compute_integrals(K_REF, cutoff_lambda)\n\n        # Evaluate basis vectors at k_ref.\n        v1_ref = v1(K_REF, cutoff_lambda)\n        v2_ref = v2(K_REF, cutoff_lambda)\n\n        # Solve for 1/C(Lambda) algebraically.\n        A0_ref = -1.0/G_COUPLING - I11_ref\n        \n        num_c = (K_REF_VAL * (A0_ref * I22_ref + I12_ref**2) - \n                 I22_ref * v1_ref**2 + \n                 2 * I12_ref * v1_ref * v2_ref + \n                 A0_ref * v2_ref**2)\n        \n        den_c = K_REF_VAL * A0_ref - v1_ref**2\n        \n        if np.isclose(den_c, 0):\n            # This case indicates a potential issue with the chosen parameters,\n            # but is unlikely for this problem.\n            raise RuntimeError(f\"Denominator for C(Lambda) is zero at Lambda={cutoff_lambda}\")\n        \n        one_over_C = num_c / den_c\n        \n        # --- Step 2: Predict K1 at the test momentum k_test ---\n        # Calculate integrals at the test momentum k_test.\n        I11_test, I12_test, I22_test = compute_integrals(K_TEST, cutoff_lambda)\n        \n        # Evaluate basis vectors at k_test.\n        v1_test = v1(K_TEST, cutoff_lambda)\n        v2_test = v2(K_TEST, cutoff_lambda)\n        \n        # Calculate K1(k_test) using the fitted C(Lambda).\n        A = -1.0/G_COUPLING - I11_test\n        B = -I12_test\n        D = one_over_C - I22_test\n        \n        det = A * D - B**2\n        \n        if np.isclose(det, 0):\n            raise RuntimeError(f\"Matrix is singular at Lambda={cutoff_lambda}\")\n            \n        k1_predicted = (D * v1_test**2 - 2 * B * v1_test * v2_test + A * v2_test**2) / det\n        results.append(k1_predicted)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The principles of renormalization extend from two-body scattering to the complex nuclear many-body problem, where consistency requires the inclusion of induced many-body forces. This exercise  provides a window into this advanced topic by modeling a key feature of the In-Medium Similarity Renormalization Group (IMSRG). You will quantify the error introduced by the ubiquitous normal-ordered two-body approximation, gaining hands-on experience with how its accuracy depends on the choice of reference state.",
            "id": "3586330",
            "problem": "Consider a simplified second-quantized model of a closed-shell nucleus intended to probe how normal-ordering choices in the In-Medium Similarity Renormalization Group (IMSRG) impact the scale dependence of induced many-body forces and the resulting ground-state energy. The aim is to quantify, in a controlled and computationally tractable way, the error introduced by the normal-ordered two-body (NO2B) approximation when different normal-ordering reference states are used and when the Similarity Renormalization Group (SRG) resolution scale parameter $\\lambda$ is varied.\n\nThe model Hamiltonian is defined in a finite set of $M$ single-particle orbitals with one-body energies $\\{\\epsilon_i\\}_{i=0}^{M-1}$ and number operators $N_i = a_i^{\\dagger} a_i$. It has three parts,\n$$\nH = \\sum_{i=0}^{M-1} \\epsilon_i N_i + H_2(\\lambda) + H_3(\\lambda),\n$$\nwhere $H_2(\\lambda)$ is a two-body interaction softened by the SRG and $H_3(\\lambda)$ is an induced three-body interaction that emerges under SRG evolution. The NO2B approximation maps $H_3(\\lambda)$ to zero-, one-, and two-body operators by normal ordering with respect to a chosen reference state.\n\nThe model uses the following widely-accepted and fundamental constructs:\n- Second quantization with fermionic creation operators $a_i^{\\dagger}$ and annihilation operators $a_i$, with $N_i = a_i^{\\dagger} a_i$.\n- Normal ordering with respect to a Slater-determinant or ensemble reference characterized by single-particle occupation numbers $\\{r_i\\}$, defined by the identity $N_i = :N_i: + r_i$, where $:\\cdots:$ denotes normal ordering with respect to the chosen reference.\n- Wick factorization for products of normal-ordered number operators, such that $:N_i N_j N_k:$ decomposes into contractions built from $\\{r_i\\}$.\n\nTo construct a tractable and scientifically consistent computational problem, use the following concrete definitions and assumptions:\n1. The single-particle spectrum is a harmonic-oscillator-like ladder,\n   $$\n   \\epsilon_i = \\hbar \\omega \\left(i + \\tfrac{1}{2}\\right),\n   $$\n   with $\\hbar \\omega$ specified below.\n2. Define a regulator form factor $f_i$ associated with each orbital via\n   $$\n   f_i = \\exp\\!\\left[-\\left(\\frac{\\epsilon_i}{\\Lambda_{\\mathrm{reg}}}\\right)^2\\right],\n   $$\n   where $\\Lambda_{\\mathrm{reg}}$ is a fixed energy scale.\n3. Use a simplified attractive pairing-type two-body interaction,\n   $$\n   H_2(\\lambda) = -g(\\lambda)\\sum_{i<j} f_i f_j\\, a_i^{\\dagger} a_j^{\\dagger} a_j a_i,\n   $$\n   with $g(\\lambda)$ a scale-dependent coupling. Although $H_2(\\lambda)$ contributes to the total energy, the error metric in this task will isolate and quantify only the contribution associated with normal-ordering of the induced three-body term.\n4. Model the induced three-body interaction in diagonal form (in the orbital index sense),\n   $$\n   H_3(\\lambda) = c(\\lambda)\\sum_{i<j<k} f_i f_j f_k\\, a_i^{\\dagger} a_j^{\\dagger} a_k^{\\dagger} a_k a_j a_i.\n   $$\n   In this diagonal model, for Slater determinants the operator reduces to a product of number operators, $a_i^{\\dagger} a_j^{\\dagger} a_k^{\\dagger} a_k a_j a_i = N_i N_j N_k$, which is a valid identity in second quantization. The scale dependence is encoded in\n   $$\n   c(\\lambda) = c_0 \\left(\\frac{\\lambda_0}{\\lambda}\\right)^2,\n   $$\n   with fixed $c_0$ and $\\lambda_0$.\n\nLet $\\{s_i\\}$ denote the ground-state occupations for a closed-shell nucleus in this truncated space, with $s_i \\in \\{0,1\\}$ determined by filling the lowest $N$ orbitals. The exact contribution of $H_3(\\lambda)$ to the ground-state energy is\n$$\nE_3^{\\mathrm{exact}}(\\lambda; \\{s_i\\}) = c(\\lambda)\\sum_{i<j<k} f_i f_j f_k\\, s_i s_j s_k.\n$$\nTo probe normal-ordering reference dependence, choose a reference occupation set $\\{r_i\\}$ and perform normal ordering of $H_3(\\lambda)$ with respect to this reference, then apply the NO2B approximation by discarding the fully normal-ordered three-body term $:N_i N_j N_k:$. The resulting mapped operator contains zero-, one-, and two-body normal-ordered pieces whose expectation value in the closed-shell state $\\{s_i\\}$ defines an approximate three-body energy $E_3^{\\mathrm{NO2B}}(\\lambda;\\{r_i\\},\\{s_i\\})$. The normal-ordering error to be quantified is\n$$\n\\Delta E(\\lambda;\\{r_i\\},\\{s_i\\}) = E_3^{\\mathrm{NO2B}}(\\lambda;\\{r_i\\},\\{s_i\\}) - E_3^{\\mathrm{exact}}(\\lambda;\\{s_i\\}).\n$$\n\nStarting from the operator identity $a_i^{\\dagger} a_i = N_i$, the normal-ordering definition $N_i = :N_i: + r_i$, and the expansion of $N_i N_j N_k$ into normal-ordered products and contractions with $\\{r_i\\}$, derive an explicit expression for $E_3^{\\mathrm{NO2B}}(\\lambda;\\{r_i\\},\\{s_i\\})$ suitable for numerical implementation. Then write a program that:\n- Constructs the single-particle spectrum and $f_i$ values.\n- Builds closed-shell occupations $\\{s_i\\}$ by filling the lowest $N$ orbitals.\n- Constructs three distinct normal-ordering references $\\{r_i\\}$:\n  1. Hartree-Fock (HF) reference at zero temperature, which for this closed shell coincides with $\\{s_i\\}$.\n  2. Ensemble Normal Ordering (ENO) reference from a Fermi-Dirac distribution\n     $$\n     r_i = \\frac{1}{1 + \\exp\\left(\\frac{\\epsilon_i - \\mu}{T_{\\mathrm{ref}}}\\right)},\n     $$\n     with temperature $T_{\\mathrm{ref}}$ and chemical potential $\\mu$ chosen such that $\\sum_i r_i = N$.\n  3. An empty-vacuum reference with $r_i = 0$ for all $i$.\n- Computes $E_3^{\\mathrm{exact}}(\\lambda;\\{s_i\\})$ and $E_3^{\\mathrm{NO2B}}(\\lambda;\\{r_i\\},\\{s_i\\})$ for specified $\\lambda$ values and references, and outputs the error $\\Delta E(\\lambda;\\{r_i\\},\\{s_i\\})$ in mega-electronvolts (MeV).\n\nUse the following fixed model parameters:\n- Number of orbitals $M = 8$.\n- Number of particles $N = 4$ (closed shell).\n- $\\hbar \\omega = 10\\,\\mathrm{MeV}$.\n- Regulator scale $\\Lambda_{\\mathrm{reg}} = 100\\,\\mathrm{MeV}$.\n- Three-body scale parameters $c_0 = 1.0\\,\\mathrm{MeV}$ and $\\lambda_0 = 2.0\\,\\mathrm{fm}^{-1}$.\n\nDefine the test suite consisting of the following input tuples $(\\lambda, \\text{reference\\_type}, T_{\\mathrm{ref}})$:\n- $(2.0, \\text{HF}, 0.0)$, boundary case where the reference equals the closed-shell occupations.\n- $(2.0, \\text{ENO}, 8.0)$, typical IMSRG ensemble normal-ordering at finite temperature.\n- $(6.0, \\text{ENO}, 8.0)$, large $\\lambda$ to probe reduced scale dependence.\n- $(1.5, \\text{ENO}, 8.0)$, small $\\lambda$ to probe enhanced scale dependence.\n- $(2.0, \\text{EMPTY}, 0.0)$, extreme reference choice.\n\nYour program should produce a single line of output containing the errors $\\Delta E(\\lambda;\\{r_i\\},\\{s_i\\})$ for the above five test cases, as a comma-separated list enclosed in square brackets, with each value expressed in $\\mathrm{MeV}$ and rounded to six decimal places, for example, `[x1,x2,x3,x4,x5]`.",
            "solution": "The problem is valid. It is scientifically grounded in the principles of many-body quantum mechanics and computational nuclear physics, specifically concerning the In-Medium Similarity Renormalization Group (IMSRG) and the normal-ordered two-body (NO2B) approximation. The problem is well-posed, with all necessary parameters and definitions provided, leading to a unique and computable solution. The language is objective and formal.\n\nOur objective is to compute the normal-ordering error, $\\Delta E$, which quantifies the difference between the exact contribution of an induced three-body force to the ground-state energy and its approximation under the NO2B scheme. The error is defined as:\n$$\n\\Delta E(\\lambda;\\{r_i\\},\\{s_i\\}) = E_3^{\\mathrm{NO2B}}(\\lambda;\\{r_i\\},\\{s_i\\}) - E_3^{\\mathrm{exact}}(\\lambda;\\{s_i\\})\n$$\nHere, $\\{s_i\\}$ are the occupation numbers of the true ground state, a closed-shell Slater determinant, and $\\{r_i\\}$ are the occupation numbers of the reference state used for normal ordering.\n\nThe derivation proceeds as follows. First, we establish the expressions for the exact and approximate energies, which requires deriving the expectation value of the NO2B-approximated three-body operator.\n\nThe induced three-body interaction is given by:\n$$\nH_3(\\lambda) = c(\\lambda)\\sum_{i<j<k} f_i f_j f_k\\, a_i^{\\dagger} a_j^{\\dagger} a_k^{\\dagger} a_k a_j a_i\n$$\nwhere $c(\\lambda) = c_0 (\\lambda_0/\\lambda)^2$. For states that are eigenstates of the number operator $N_p=a_p^\\dagger a_p$ (such as Slater determinants), we can replace the string of creation and annihilation operators with the product of number operators, $a_i^{\\dagger} a_j^{\\dagger} a_k^{\\dagger} a_k a_j a_i = N_i N_j N_k$, for distinct indices $i, j, k$.\n$$\nH_3(\\lambda) = c(\\lambda)\\sum_{i<j<k} f_i f_j f_k\\, N_i N_j N_k\n$$\n\nThe exact contribution to the ground-state energy is the expectation value of $H_3(\\lambda)$ in the state $|\\Psi_s\\rangle$ defined by the occupations $\\{s_i\\}$. Since $|\\Psi_s\\rangle$ is an eigenstate of $N_p$ with eigenvalue $s_p$, we have:\n$$\nE_3^{\\mathrm{exact}}(\\lambda;\\{s_i\\}) = \\langle\\Psi_s| H_3(\\lambda) |\\Psi_s\\rangle = c(\\lambda)\\sum_{i<j<k} f_i f_j f_k\\, s_i s_j s_k\n$$\nThis matches the expression provided in the problem statement.\n\nNext, we derive the approximate energy $E_3^{\\mathrm{NO2B}}$. This involves normal ordering the operator $N_i N_j N_k$ with respect to a reference state characterized by occupations $\\{r_i\\}$. The normal ordering of a number operator is defined by $N_p = :N_p: + r_p$, where $:\\cdots:$ denotes the normal-ordered part. We expand the product $N_i N_j N_k$:\n$$\n\\begin{align*}\nN_i N_j N_k &= (:N_i: + r_i)(:N_j: + r_j)(:N_k: + r_k) \\\\\n&= :N_i N_j N_k: + r_i:N_j N_k: + r_j:N_i N_k: + r_k:N_i N_j: \\\\\n&\\quad + r_i r_j :N_k: + r_i r_k :N_j: + r_j r_k :N_i: + r_i r_j r_k\n\\end{align*}\nIn this expansion, we have used the property that for distinct indices, $:N_p::N_q: = :N_p N_q:$, as there are no contractions. The NO2B approximation consists of discarding the fully normal-ordered three-body term, $:N_i N_j N_k:$. Thus, the approximated operator is:\n$$\n(N_i N_j N_k)_{\\mathrm{NO2B}} = N_i N_j N_k - :N_i N_j N_k:\n$$\nTo find $E_3^{\\mathrm{NO2B}}$, we take the expectation value of the corresponding operator $(H_3(\\lambda))_{\\mathrm{NO2B}}$ in the ground state $|\\Psi_s\\rangle$. The expectation value of a normal-ordered operator product in state $|\\Psi_s\\rangle$ is given by:\n$$\n\\langle\\Psi_s| :N_{p_1} N_{p_2} \\cdots N_{p_m}: |\\Psi_s\\rangle = (s_{p_1} - r_{p_1})(s_{p_2} - r_{p_2})\\cdots(s_{p_m} - r_{p_m})\n$$\nThe expectation value of $(N_i N_j N_k)_{\\mathrm{NO2B}}$ is the expectation value of the full product minus the expectation value of the discarded term:\n$$\n\\langle(N_i N_j N_k)_{\\mathrm{NO2B}}\\rangle_s = \\langle N_i N_j N_k \\rangle_s - \\langle :N_i N_j N_k: \\rangle_s = s_i s_j s_k - (s_i - r_i)(s_j - r_j)(s_k - r_k)\n$$\nSumming over all triplets $(i,j,k)$ gives the total approximate energy:\n$$\nE_3^{\\mathrm{NO2B}}(\\lambda;\\{r_i\\},\\{s_i\\}) = c(\\lambda)\\sum_{i<j<k} f_i f_j f_k \\left[ s_i s_j s_k - (s_i - r_i)(s_j - r_j)(s_k - r_k) \\right]\n$$\nFinally, we compute the error $\\Delta E$:\n$$\n\\begin{align*}\n\\Delta E &= E_3^{\\mathrm{NO2B}} - E_3^{\\mathrm{exact}} \\\\\n&= c(\\lambda)\\sum_{i<j<k} f_i f_j f_k \\left[ s_i s_j s_k - (s_i - r_i)(s_j - r_j)(s_k - r_k) \\right] - c(\\lambda)\\sum_{i<j<k} f_i f_j f_k s_i s_j s_k \\\\\n&= -c(\\lambda)\\sum_{i<j<k} f_i f_j f_k (s_i - r_i)(s_j - r_j)(s_k - r_k)\n\\end{align*}\n$$\nThis concise formula is the basis for our computation. It reveals that the error is the negative of the expectation value of the discarded three-body operator.\n\nThe computational algorithm proceeds as follows:\n1.  Initialize model parameters: $M=8$, $N=4$, $\\hbar\\omega=10\\,\\mathrm{MeV}$, $\\Lambda_{\\mathrm{reg}}=100\\,\\mathrm{MeV}$, $c_0=1.0\\,\\mathrm{MeV}$, and $\\lambda_0=2.0\\,\\mathrm{fm}^{-1}$.\n2.  Construct the single-particle basis. The energies $\\epsilon_i = \\hbar\\omega(i+1/2)$ and regulator form factors $f_i = \\exp[-(\\epsilon_i/\\Lambda_{\\mathrm{reg}})^2]$ are computed for $i=0, \\dots, M-1$.\n3.  Define the ground-state occupations $\\{s_i\\}$. For a closed shell of $N=4$ particles, $s_i=1$ for $i=0,1,2,3$ and $s_i=0$ for $i \\ge 4$.\n4.  For each test case $(\\lambda, \\text{reference\\_type}, T_{\\mathrm{ref}})$:\n    a. Determine the scale-dependent coupling $c(\\lambda)$.\n    b. Construct the reference occupations $\\{r_i\\}$ based on the reference type:\n        - **HF**: $\\{r_i\\}$ are identical to $\\{s_i\\}$.\n        - **EMPTY**: $r_i=0$ for all $i$.\n        - **ENO**: The occupations are given by a Fermi-Dirac distribution, $r_i = [1 + \\exp((\\epsilon_i - \\mu)/T_{\\mathrm{ref}})]^{-1}$. The chemical potential $\\mu$ must be determined numerically by solving the non-linear equation $\\sum_i r_i(\\mu) = N$ using a root-finding algorithm like the Brent-Dekker method.\n    c. Apply the derived formula for $\\Delta E$. The summation is performed over all unique index triplets $(i,j,k)$ where $0 \\le i < j < k < M$.\n5.  Collect the results for all test cases and format the output as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Computes the normal-ordering error for an induced three-body force\n    in a simplified nuclear model.\n    \"\"\"\n\n    # Define fixed model parameters\n    M = 8  # Number of orbitals\n    N = 4  # Number of particles (closed shell)\n    hw = 10.0  # MeV\n    Lambda_reg = 100.0  # MeV\n    c0 = 1.0  # MeV\n    lambda0 = 2.0  # fm^-1\n\n    # Define the test cases from the problem statement.\n    # Format: (lambda [fm^-1], reference_type, T_ref [MeV])\n    test_cases = [\n        (2.0, 'HF', 0.0),\n        (2.0, 'ENO', 8.0),\n        (6.0, 'ENO', 8.0),\n        (1.5, 'ENO', 8.0),\n        (2.0, 'EMPTY', 0.0),\n    ]\n\n    # Step 1: Construct single-particle spectrum and form factors\n    indices = np.arange(M)\n    epsilons = hw * (indices + 0.5)\n    form_factors = np.exp(- (epsilons / Lambda_reg)**2)\n\n    # Step 2: Build closed-shell ground-state occupations {s_i}\n    s_occupations = np.zeros(M)\n    s_occupations[:N] = 1.0\n\n    def calculate_delta_E(lambda_val, r_occupations):\n        \"\"\"\n        Calculates the normal-ordering error Delta E based on the derived formula.\n        \n        Delta_E = -c(lambda) * sum_{i<j<k} [f_i*f_j*f_k * (s_i-r_i)*(s_j-r_j)*(s_k-r_k)]\n        \"\"\"\n        c_lambda = c0 * (lambda0 / lambda_val)**2\n        \n        s_minus_r = s_occupations - r_occupations\n        \n        sum_term = 0.0\n        # Sum over all unique triplets of indices (i, j, k)\n        for i, j, k in combinations(indices, 3):\n            term = form_factors[i] * form_factors[j] * form_factors[k]\n            term *= s_minus_r[i] * s_minus_r[j] * s_minus_r[k]\n            sum_term += term\n            \n        delta_E = -c_lambda * sum_term\n        return delta_E\n\n    results = []\n    for case in test_cases:\n        lambda_val, ref_type, T_ref = case\n        \n        r_occupations = np.zeros(M)\n\n        if ref_type == 'HF':\n            # For the Hartree-Fock reference, r_i = s_i.\n            r_occupations = s_occupations.copy()\n        \n        elif ref_type == 'EMPTY':\n            # For the empty vacuum reference, r_i = 0 for all i.\n            pass  # r_occupations is already initialized to zeros.\n        \n        elif ref_type == 'ENO':\n            # For the Ensemble Normal Ordering reference, we must find mu\n            # such that sum_i r_i = N.\n            if T_ref == 0.0:\n                # To avoid division by zero, handle T=0 case separately.\n                # Fermi-Dirac becomes a step function.\n                # In this specific problem, T_ref for ENO is always > 0.\n                # However, this is good practice.\n                r_occupations = s_occupations.copy() \n            else:\n                def particle_number_error(mu, T, eps, N_target):\n                    r_vec = 1.0 / (1.0 + np.exp((eps - mu) / T))\n                    return np.sum(r_vec) - N_target\n\n                # Use brentq to find the chemical potential mu.\n                # The bracket [a, b] is chosen to be wide enough to guarantee a root.\n                try:\n                    mu = brentq(particle_number_error, a=-200.0, b=200.0, args=(T_ref, epsilons, N))\n                    r_occupations = 1.0 / (1.0 + np.exp((epsilons - mu) / T_ref))\n                except ValueError:\n                    # Fallback or error handling if root finding fails\n                    # For this well-posed problem, it should not fail.\n                    results.append(np.nan)\n                    continue\n\n        # Calculate the error for the current case\n        delta_E = calculate_delta_E(lambda_val, r_occupations)\n        results.append(delta_E)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{res:.6f}' for res in results])}]\")\n\nsolve()\n```"
        }
    ]
}