{
    "hands_on_practices": [
        {
            "introduction": "核力的丰富结构可以通过将其投影到具有确定总自旋（$S$）和同位旋（$T$）的通道上进行系统地组织。这项动手实践将指导您完成从第一性原理构建这些投影算符，并使用它们来分析给定的势。您将实现一种强大的诊断方法，以量化特定正则化因子的选择如何在这些基本通道之间引入非物理性的混合 。",
            "id": "3555487",
            "problem": "在手征有效场论 (Chiral Effective Field Theory, EFT) 的框架下，给定一个双核子势算符 $V_{2N}$，考虑分解为自旋和同位旋子空间的双粒子希尔伯特空间。令自旋子空间为两个自旋-$\\tfrac{1}{2}$ 空间的张量积（维度为 $4$），同位旋子空间为两个同位旋-$\\tfrac{1}{2}$ 空间的张量积（维度为 $4$）。总空间的维度为 $16$，是自旋与同位旋空间的张量积。使用泡利矩阵 (Pauli matrices) $\\sigma_x$, $\\sigma_y$, $\\sigma_z$ 表示自旋，$\\tau_x$, $\\tau_y$, $\\tau_z$ 表示同位旋，它们满足标准关系 $\\sigma_i \\sigma_j = \\delta_{ij} I_2 + i \\epsilon_{ijk} \\sigma_k$ 和 $\\tau_i \\tau_j = \\delta_{ij} I_2 + i \\epsilon_{ijk} \\tau_k$，以及 $\\mathrm{Tr}(\\sigma_i) = 0, \\mathrm{Tr}(\\sigma_i \\sigma_j) = 2 \\delta_{ij}$（$\\tau_i$ 具有相同的关系）。定义作用在自旋子空间上的双粒子算符 $\\sigma_1^i = \\sigma_i \\otimes I_2$, $\\sigma_2^i = I_2 \\otimes \\sigma_i$，以及类似地作用在同位旋子空间上的算符 $\\tau_1^i = \\tau_i \\otimes I_2$, $\\tau_2^i = I_2 \\otimes \\tau_i$。定义 $\\sigma_1 \\cdot \\sigma_2 = \\sigma_1^x \\sigma_2^x + \\sigma_1^y \\sigma_2^y + \\sigma_1^z \\sigma_2^z$ 和 $\\tau_1 \\cdot \\tau_2 = \\tau_1^x \\tau_2^x + \\tau_1^y \\tau_2^y + \\tau_1^z \\tau_2^z$。\n\n使用到总自旋 $S$ 和总同位旋 $T$ 道的投影算符定义：\n$$\nP_{S=0} = \\frac{I_4 - \\sigma_1 \\cdot \\sigma_2}{4}, \\quad\nP_{S=1} = \\frac{3 I_4 + \\sigma_1 \\cdot \\sigma_2}{4},\n$$\n$$\nP_{T=0} = \\frac{I_4 - \\tau_1 \\cdot \\tau_2}{4}, \\quad\nP_{T=1} = \\frac{3 I_4 + \\tau_1 \\cdot \\tau_2}{4}.\n$$\n到组合的自旋-同位旋道的总投影算符为 $P_{ST} = P_S \\otimes P_T$，其中 $(S,T) \\in \\{(0,0),(0,1),(1,0),(1,1)\\}$。矩阵 $A$ 的弗罗贝尼乌斯范数 (Frobenius norm) 定义为 $\\|A\\|_F = \\sqrt{\\mathrm{Tr}(A^\\dagger A)}$。\n\n假设一个依赖于动量的通用手征 EFT 双核子势算符，其形式为\n$$\nV_{2N}(p, p', \\Lambda) =\na_I(p,p',\\Lambda) \\, I_4 \\otimes I_4\n+ a_S(p,p',\\Lambda) \\, (\\sigma_1 \\cdot \\sigma_2) \\otimes I_4\n+ a_T(p,p',\\Lambda) \\, I_4 \\otimes (\\tau_1 \\cdot \\tau_2)\n+ a_{ST}(p,p',\\Lambda) \\, (\\sigma_1 \\cdot \\sigma_2) \\otimes (\\tau_1 \\cdot \\tau_2),\n$$\n其标量系数函数为\n$$\nf_0(p,p',\\Lambda) = \\exp\\!\\left(-\\frac{p^2 + p'^2}{\\Lambda^2}\\right), \\quad\ng_1(p,p',\\Lambda) = \\frac{p^2 + p'^2}{\\Lambda^2},\n\\quad\ng_2(p,p',\\Lambda) = \\frac{p\\, p'}{\\Lambda^2},\n$$\n$$\na_I = c_I \\, f_0, \\quad\na_S = c_S \\, g_1 \\, f_0, \\quad\na_T = c_T \\, f_0, \\quad\na_{ST} = c_{ST} \\, g_2 \\, f_0,\n$$\n其中 $c_I$, $c_S$, $c_T$, $c_{ST}$ 是不依赖于 $(p,p',\\Lambda)$ 的常数。\n\n考虑一个正则化算符 (regulator operator)，当它与投影算符不对易时，可能会在 $(S,T)$ 道之间引起混合：\n$$\nR(p,p',\\Lambda) = r_0(p,p',\\Lambda) \\left[\n\\left(I_4 + \\epsilon_s \\, h(p,p',\\Lambda) \\, (\\sigma_z \\otimes I_2)\\right) \\otimes\n\\left(I_4 + \\epsilon_t \\, h(p,p',\\Lambda) \\, (\\tau_z \\otimes I_2)\\right)\n\\right],\n$$\n其中\n$$\nr_0(p,p',\\Lambda) = \\exp\\!\\left(-\\frac{p^2 + p'^2}{\\Lambda^2}\\right), \\quad\nh(p,p',\\Lambda) = \\exp\\!\\left(-\\frac{(p - p')^2}{\\Lambda^2}\\right),\n$$\n且 $\\epsilon_s, \\epsilon_t$ 是小的无量纲正则化参数。正则化后的势为\n$$\nV_{\\mathrm{reg}} = R \\, V_{2N} \\, R.\n$$\n\n任务：\n1. 构造自旋和同位旋的泡利算符以及复合算符 $\\sigma_1 \\cdot \\sigma_2$ 和 $\\tau_1 \\cdot \\tau_2$，作为作用在相应子空间上的矩阵，然后在完整的 $16$ 维空间中构造投影算符 $P_{ST}$。\n2. 通过为所有 $(S,T)$ 和 $(S',T')$ 对计算 $\\| P_{ST} P_{S'T'} - \\delta_{SS'} \\delta_{TT'} P_{ST} \\|_F$，数值地验证 $(S,T)$ 道的正交性，并报告所有这些范数是否都低于容差 $\\delta = 10^{-12}$。\n3. 通过以下公式提取 $V_{2N}$ 在每个 $(S,T)$ 道中的分量强度：\n$$\nv_{ST} = \\frac{\\mathrm{Tr}\\left(P_{ST} V_{2N}\\right)}{\\mathrm{Tr}\\left(P_{ST}\\right)},\n$$\n注意在 $16$ 维空间中 $\\mathrm{Tr}(P_{ST}) = (2S+1)(2T+1)$。\n4. 通过为每个 $(S,T)$ 道计算泄漏度量 (leakage measure) 来诊断由正则化引起的污染：\n$$\nL_{ST} = \\frac{\\left\\| P_{ST} \\, V_{\\mathrm{reg}} \\, (I_{16} - P_{ST}) \\right\\|_F}{\\left\\| P_{ST} \\, V_{\\mathrm{reg}} \\right\\|_F},\n$$\n约定如果分母为零，则 $L_{ST}$ 定义为 $0$。为每个测试用例报告所有道中的最大泄漏。\n\n动量和正则化标度使用兆电子伏特 (Mega electron Volts, MeV) 单位。输出为无量纲浮点数和布尔值；最终输出值中不需要物理单位。此问题不使用角度。百分比（如有）必须表示为小数，但算法将直接输出无量纲浮点数。\n\n使用的常数：\n- $c_I = 1.0$, $c_S = -0.5$, $c_T = 0.8$, $c_{ST} = -0.3$。\n\n测试套件：\n- 用例 A（基准，无混合）：$(p, p', \\Lambda, \\epsilon_s, \\epsilon_t) = (100, 150, 600, 0.0, 0.0)$，\n- 用例 B（自旋偏向正则化算符，轻度混合）：$(p, p', \\Lambda, \\epsilon_s, \\epsilon_t) = (100, 150, 600, 10^{-3}, 0.0)$，\n- 用例 C（同位旋偏向正则化算符，轻度混合）：$(p, p', \\Lambda, \\epsilon_s, \\epsilon_t) = (50, 50, 600, 0.0, 5 \\times 10^{-3})$，\n- 用例 D（强混合，低动量下的边界检查）：$(p, p', \\Lambda, \\epsilon_s, \\epsilon_t) = (0, 0, 600, 0.1, 0.1)$。\n\n你的程序应生成单行输出，其中按顺序包含每个测试用例的列表，形式为 $[\\mathrm{leak\\_max}, [L_{00}, L_{01}, L_{10}, L_{11}], \\mathrm{ortho}]$，其中 $\\mathrm{leak\\_max}$ 是四个泄漏值的最大值，$L_{ST}$ 是按指定道顺序排列的泄漏值，$\\mathrm{ortho}$ 是一个布尔值，表明所有投影算符的正交性范数是否都低于 $\\delta$。将四个用例的列表聚合为单个列表，并将其打印为用方括号括起来的逗号分隔列表，例如：\n$[[\\mathrm{leak\\_max}_A,[L_{00}^A,L_{01}^A,L_{10}^A,L_{11}^A],\\mathrm{ortho}_A],[\\mathrm{leak\\_max}_B,[\\cdots],\\mathrm{ortho}_B],[\\mathrm{leak\\_max}_C,[\\cdots],\\mathrm{ortho}_C],[\\mathrm{leak\\_max}_D,[\\cdots],\\mathrm{ortho}_D]]$。",
            "solution": "用户提供的问题已经过验证，并被确定为计算核物理领域中一个良构的、有科学依据的问题。该问题是自洽的、客观的，并且为获得唯一解提供了所有必要的参数和定义。解决该问题的步骤如下。\n\n### 1. 算符的矩阵表示\n基础步骤是在指定的希尔伯特空间中为所有量子力学算符构造矩阵表示。总希尔伯特空间是一个 $4$ 维双核子自旋空间和一个 $4$ 维双核子同位旋空间的张量积，从而得到一个 $16$ 维空间。\n\n首先，将基本的 $2 \\times 2$ 单位矩阵 $I_2$ 和泡利矩阵 $\\sigma_i$（以及与之相同的 $\\tau_i$）定义为复矩阵。\n$$\nI_2 = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}, \\quad \\sigma_x = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}, \\quad \\sigma_y = \\begin{pmatrix} 0  -i \\\\ i  0 \\end{pmatrix}, \\quad \\sigma_z = \\begin{pmatrix} 1  0 \\\\ 0  -1 \\end{pmatrix}\n$$\n作用于 $4$ 维自旋或同位旋子空间上的双粒子算符是使用克罗内克（张量）积（Kronecker (tensor) product，用 $\\otimes$ 表示）构造的。例如，粒子 1 和 2 的自旋算符为 $\\sigma_1^i = \\sigma_i \\otimes I_2$ 和 $\\sigma_2^i = I_2 \\otimes \\sigma_i$。由此，计算出点积算符 $\\sigma_1 \\cdot \\sigma_2 = \\sum_{i=x,y,z} (\\sigma_i \\otimes I_2)(I_2 \\otimes \\sigma_i)$ 和 $\\tau_1 \\cdot \\tau_2$。这些是 $4 \\times 4$ 矩阵。\n\n### 2. 投影算符的构造与验证\n从点积算符构造到确定的总自旋 ($S$) 和同位旋 ($T$) 的投影算符。对于自旋子空间：\n$$\nP_{S=0} = \\frac{I_4 - \\sigma_1 \\cdot \\sigma_2}{4}, \\quad P_{S=1} = \\frac{3 I_4 + \\sigma_1 \\cdot \\sigma_2}{4}\n$$\n类似的表达式定义了同位旋投影算符 $P_{T=0}$ 和 $P_{T=1}$。到四个组合的自旋-同位旋道 $(S,T)$ 的投影算符是通过张量积 $P_{ST} = P_S \\otimes P_T$ 形成的 $16 \\times 16$ 矩阵。\n\n执行一次关键的验证，以确保这些构造的投影算符是标准正交的（它们必须如此）。这是通过为所有 $16$ 对道数值计算弗罗贝尼乌斯范数 $\\| P_{ST} P_{S'T'} - \\delta_{SS'}\\delta_{TT'} P_{ST} \\|_F$ 并确认其低于数值容差 $\\delta = 10^{-12}$ 来完成的。此检查的布尔结果将为所有测试用例报告。\n\n### 3. 势和正则化算符的构造\n对于每个由一组参数 $(p, p', \\Lambda, \\epsilon_s, \\epsilon_t)$ 定义的测试用例，构造势和正则化算符矩阵。\n\n未正则化的势 $V_{2N}$ 具有以下形式：\n$$\nV_{2N} = a_I I_{16} + a_S (\\sigma_1 \\cdot \\sigma_2 \\otimes I_4) + a_T (I_4 \\otimes \\tau_1 \\cdot \\tau_2) + a_{ST} (\\sigma_1 \\cdot \\sigma_2 \\otimes \\tau_1 \\cdot \\tau_2)\n$$\n其中算符部分是常数 $16 \\times 16$ 矩阵，系数 $a_I, a_S, a_T, a_{ST}$ 是 $(p, p', \\Lambda)$ 的标量函数。对每个测试用例计算这些标量。\n\n正则化算符 $R$ 引入了道混合。其形式为：\n$$\nR = r_0(p,p',\\Lambda) \\left[ \\left(I_4 + \\epsilon_s h(p,p',\\Lambda) \\sigma_1^z\\right) \\otimes \\left(I_4 + \\epsilon_t h(p,p',\\Lambda) \\tau_1^z\\right) \\right]\n$$\n这里，$\\sigma_1^z \\equiv \\sigma_z \\otimes I_2$ 和 $\\tau_1^z \\equiv \\tau_z \\otimes I_2$ 是 $4 \\times 4$ 的算符。完整算符 $R$ 是一个 $16 \\times 16$ 矩阵。对每个用例，计算标量函数 $r_0$ 和 $h$ 的值。然后，正则化后的势为 $V_{\\mathrm{reg}} = R V_{2N} R$。\n\n### 4. 泄漏计算\n中心任务是量化由正则化算符引起的道混合。一个道 $(S,T)$ 的泄漏 $L_{ST}$ 定义为正则化势相对于该道投影算符的非对角部分与对角部分的范数之比：\n$$\nL_{ST} = \\frac{\\left\\| P_{ST} V_{\\mathrm{reg}} (I_{16} - P_{ST}) \\right\\|_F}{\\left\\| P_{ST} V_{\\mathrm{reg}} \\right\\|_F}\n$$\n分子代表势中将态从 $(S,T)$ 道散射到任何其他道的部分。分母代表从 $(S,T)$ 道开始的势的总作用。它们的比率是衡量混合相对重要性的一个指标。对每个测试用例的四个 $(S,T)$ 道都执行此计算。同时也会确定这四个泄漏值的最大值。如果分母范数为零，则 $L_{ST}=0$ 的约定通过数值容差检查来处理。\n\n最后，每个测试用例的结果，包括最大泄漏值、四个单独泄漏值的列表以及来自正交性检查的布尔值，将按指定要求聚合和格式化为单个字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational nuclear physics problem by constructing operators,\n    verifying projector orthogonality, and calculating regulator-induced channel leakage.\n    \"\"\"\n    # Define physical and numerical constants\n    c_I, c_S, c_T, c_ST = 1.0, -0.5, 0.8, -0.3\n    delta_ortho = 1e-12\n\n    # Define test suite parameters\n    test_cases = [\n        (100.0, 150.0, 600.0, 0.0, 0.0),        # Case A\n        (100.0, 150.0, 600.0, 1e-3, 0.0),       # Case B\n        (50.0, 50.0, 600.0, 0.0, 5e-3),        # Case C\n        (0.0, 0.0, 600.0, 0.1, 0.1),            # Case D\n    ]\n\n    # --- Task 1: Construct constant operators and projectors ---\n    I2 = np.eye(2, dtype=np.complex128)\n    sigma_x = np.array([[0, 1], [1, 0]], dtype=np.complex128)\n    sigma_y = np.array([[0, -1j], [1j, 0]], dtype=np.complex128)\n    sigma_z = np.array([[1, 0], [0, -1]], dtype=np.complex128)\n    pauli_matrices = [sigma_x, sigma_y, sigma_z]\n    \n    # 4x4 operators\n    I4 = np.kron(I2, I2)\n    sig1_ops = [np.kron(s, I2) for s in pauli_matrices]\n    sig2_ops = [np.kron(I2, s) for s in pauli_matrices]\n    tau1_ops = sig1_ops\n    tau2_ops = sig2_ops\n\n    sig1_dot_sig2 = sum(s1 @ s2 for s1, s2 in zip(sig1_ops, sig2_ops))\n    tau1_dot_tau2 = sum(t1 @ t2 for t1, t2 in zip(tau1_ops, tau2_ops))\n\n    # 4x4 projectors\n    P_S0 = (I4 - sig1_dot_sig2) / 4.0\n    P_S1 = (3 * I4 + sig1_dot_sig2) / 4.0\n    P_T0 = (I4 - tau1_dot_tau2) / 4.0\n    P_T1 = (3 * I4 + tau1_dot_tau2) / 4.0\n    \n    Ps = {0: P_S0, 1: P_S1}\n    Pt = {0: P_T0, 1: P_T1}\n\n    # 16x16 projectors\n    I16 = np.kron(I4, I4)\n    P_ST_map = {}\n    st_channels = [(S, T) for S in [0, 1] for T in [0, 1]]\n    for S, T in st_channels:\n        P_ST_map[(S, T)] = np.kron(Ps[S], Pt[T])\n\n    # --- Task 2: Verify projector orthogonality (one-time check) ---\n    ortho_check_passed = True\n    for S1, T1 in st_channels:\n        for S2, T2 in st_channels:\n            P1 = P_ST_map[(S1, T1)]\n            P2 = P_ST_map[(S2, T2)]\n            \n            is_same_channel = (S1 == S2) and (T1 == T2)\n            target = P1 if is_same_channel else np.zeros_like(P1)\n            \n            # Use explicit formula from problem statement\n            # P_ST P_S'T' - delta_SS' delta_TT' P_ST\n            P_ST = P_ST_map[(S1,T1)]\n            P_SprimeTprime = P_ST_map[(S2, T2)]\n            kronecker_delta = 1.0 if is_same_channel else 0.0\n            matrix_to_norm = P_ST @ P_SprimeTprime - kronecker_delta * P_ST\n\n            norm = np.linalg.norm(matrix_to_norm, 'fro')\n            \n            if norm > delta_ortho:\n                ortho_check_passed = False\n                break\n        if not ortho_check_passed:\n            break\n            \n    # Pre-build constant 16x16 operator matrices for V_2N and R\n    sig1_dot_sig2_16 = np.kron(sig1_dot_sig2, I4)\n    tau1_dot_tau2_16 = np.kron(I4, tau1_dot_tau2)\n    sig_tau_dot_16 = np.kron(sig1_dot_sig2, tau1_dot_tau2)\n    sig1z_4 = sig1_ops[2]\n    tau1z_4 = tau1_ops[2]\n\n    all_results = []\n    # --- Loop over test cases to perform Tasks 3  4 ---\n    for case in test_cases:\n        p, pp, Lambda, eps_s, eps_t = case\n        \n        # Calculate scalar coefficients for V_2N\n        p2_pp2 = p**2 + pp**2\n        Lambda2 = Lambda**2\n        \n        f0 = np.exp(-p2_pp2 / Lambda2)\n        g1 = p2_pp2 / Lambda2\n        g2 = (p * pp) / Lambda2\n        \n        aI = c_I * f0\n        aS = c_S * g1 * f0\n        aT = c_T * f0\n        aST = c_ST * g2 * f0\n        \n        # Construct V_2N matrix\n        V_2N = (aI * I16 +\n                aS * sig1_dot_sig2_16 +\n                aT * tau1_dot_tau2_16 +\n                aST * sig_tau_dot_16)\n        \n        # Calculate scalar coefficients for regulator R\n        r0 = np.exp(-p2_pp2 / Lambda2)\n        h = np.exp(-((p - pp)**2) / Lambda2)\n        \n        # Construct R matrix\n        R_s_part = I4 + eps_s * h * sig1z_4\n        R_t_part = I4 + eps_t * h * tau1z_4\n        R_bracket = np.kron(R_s_part, R_t_part)\n        R = r0 * R_bracket\n        \n        # Construct regulated potential V_reg\n        V_reg = R @ V_2N @ R\n        \n        # --- Task 4: Calculate leakages ---\n        leakages = {}\n        for S, T in st_channels:\n            PST = P_ST_map[(S, T)]\n            \n            off_diagonal_part = PST @ V_reg @ (I16 - PST)\n            numer_norm = np.linalg.norm(off_diagonal_part, 'fro')\n            \n            diagonal_part = PST @ V_reg\n            denom_norm = np.linalg.norm(diagonal_part, 'fro')\n            \n            if denom_norm  1e-15:  # Handle division by zero\n                leakages[(S, T)] = 0.0\n            else:\n                leakages[(S, T)] = numer_norm / denom_norm\n        \n        # Order results as specified: (0,0), (0,1), (1,0), (1,1)\n        leakages_list = [leakages[(0,0)], leakages[(0,1)], leakages[(1,0)], leakages[(1,1)]]\n        max_leakage = max(leakages_list) if leakages_list else 0.0\n        \n        all_results.append([max_leakage, leakages_list, ortho_check_passed])\n\n    # Format the final output string exactly as required (no spaces)\n    output_parts = []\n    for res in all_results:\n        leak_max, l_list, ortho = res\n        l_list_str = '[' + ','.join(f'{x:.17g}' for x in l_list) + ']'\n        ortho_str = 'True' if ortho else 'False'\n        res_str = f'[{f\"{leak_max:.17g}\"},{l_list_str},{ortho_str}]'\n        output_parts.append(res_str)\n        \n    final_output = '[' + ','.join(output_parts) + ']'\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "任何量子力学哈密顿量的一个基本要求是厄米性，它保证了能量本征值为实数。在动量空间中，这转化为势核的对称性，即 $V(p, p') = V(p', p)$。本练习要求您进行一项数值实验，以探究某些不对称的正则化因子选择如何破坏这一关键性质，并实现和比较为恢复厄米性而设计的不同对称化方案 。",
            "id": "3555456",
            "problem": "你的任务是设计并执行一个数值实验，以检验用于二核子相互作用的手征有效场论中的动量空间调节子是否保持厄米性（Hermiticity）和时间反演不变性。在此背景下，对于实的相互作用核，厄米性要求对所有离壳动量 $p$ 和 $p'$ 满足条件 $V_{2N}(p,p') = V_{2N}(p',p)$。\n\n从以下基本出发点开始：\n- 手征有效场论 (EFT) 的二核子势被构建为接触相互作用和介子交換贡献的总和。对于最低阶分析，只考虑一项中心接触相互作用和单π介子交換的中心部分。\n- 动量空间中的裸（未调节的）二核子势取为一个对称函数\n$$\nV_{\\text{bare}}(p,p') = C_0 + C_2\\,(p^2 + p'^2) - \\frac{C_{\\pi}}{q^2 + m_\\pi^2},\n$$\n其中 $q = |p - p'|$，$C_0$ 和 $C_2$ 是代表接触项的低能常数，$C_{\\pi}$ 是中心单π介子交換 (OPE) 贡献的有效强度，$m_\\pi$ 是π介子质量。所有量均为实数。在没有调节子的情况下，此构造与时间反演不变性和厄米性一致。\n\n引入调节子以抑制高动量分量。你将分析几种调节子的选择：\n- 非定域对称高斯调节子：\n$$\nf_{\\Lambda}^{\\text{nl}}(p,p') = \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2n}\\right]\\exp\\!\\left[-\\left(\\frac{p'}{\\Lambda}\\right)^{2n}\\right],\n$$\n其中整数 $n \\geq 1$。\n- 半定域动量转移调节子：\n$$\nf_{\\Lambda}^{q}(p,p') = \\exp\\!\\left[-\\left(\\frac{q}{\\Lambda}\\right)^{2n}\\right],\\quad q=|p-p'|.\n$$\n- 非对称单边调节子：\n$$\nf_{\\Lambda}^{\\text{left}}(p,p') = \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2n}\\right],\n$$\n它只抑制入射动量腿。\n- 非对称混合指数调节子：\n$$\nf_{\\Lambda}^{\\text{asym}}(p,p') = \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2}\\right]\\exp\\!\\left[-\\left(\\frac{p'}{\\Lambda}\\right)^{4}\\right].\n$$\n\n将调节后的相互作用定义为\n$$\nV_{\\text{reg}}(p,p') = f_{\\Lambda}(p,p')\\,V_{\\text{bare}}(p,p').\n$$\n\n你必须实现并比较两种对称化方案，以修正由 $f_{\\Lambda}$ 引入的势的厄米性破缺：\n- 算术对称化：\n$$\nV_{\\text{sym,arith}}(p,p') = \\frac{1}{2}\\left[V_{\\text{reg}}(p,p') + V_{\\text{reg}}(p',p)\\right].\n$$\n- 几何平均（平方根）调节子对称化：\n$$\nf_{\\Lambda}^{\\text{geom}}(p,p') = \\sqrt{f_{\\Lambda}(p,p')\\,f_{\\Lambda}(p',p)},\\qquad V_{\\text{sym,geom}}(p,p') = f_{\\Lambda}^{\\text{geom}}(p,p')\\,V_{\\text{bare}}(p,p').\n$$\n\n执行以下任务：\n1. 使用固定常数 $C_0=-0.5$、$C_2=0.2$、$C_{\\pi}=0.8$ 和 $m_\\pi=0.7$ 构建 $V_{\\text{bare}}(p,p')$，所有动量单位均为反费米 $\\text{fm}^{-1}$。\n2. 对于上述每种调节子选择 $f_{\\Lambda}$，以及截断值 $\\Lambda \\in \\{1.0,\\,2.0,\\,3.0\\}$ $\\text{fm}^{-1}$ 和 $n=2$，评估厄米性破缺度量\n$$\n\\Delta(p,p') = \\left|V_{\\text{reg}}(p,p') - V_{\\text{reg}}(p',p)\\right|\n$$\n在以下动量对测试集（单位为 $\\text{fm}^{-1}$）上进行：\n$$\n(p,p') \\in \\{(0.0,0.0),\\,(0.1,2.5),\\,(1.0,1.0),\\,(0.5,1.5),\\,(2.0,2.6)\\}.\n$$\n3. 对于每种调节子和截断值，计算对称化之前的最大厄米性破缺，\n$$\n\\Delta_{\\max}^{\\text{pre}} = \\max_{(p,p')}\\Delta(p,p'),\n$$\n以及应用每种对称化方案之后的最大厄米性破缺，\n$$\n\\Delta_{\\max}^{\\text{arith}} = \\max_{(p,p')}\\left|V_{\\text{sym,arith}}(p,p') - V_{\\text{sym,arith}}(p',p)\\right|,\n$$\n$$\n\\Delta_{\\max}^{\\text{geom}} = \\max_{(p,p')}\\left|V_{\\text{sym,geom}}(p,p') - V_{\\text{sym,geom}}(p',p)\\right|.\n$$\n\n你的程序必须严格按照以下调节子类型的顺序，\n$$\n\\text{types} = [\\text{nl\\_sym},\\;\\text{left\\_only},\\;\\text{q\\_semi},\\;\\text{asym\\_exp}],\n$$\n对每个 $\\Lambda \\in [1.0,\\,2.0,\\,3.0]$ 计算浮点值三元组\n$$\n\\left[\\Delta_{\\max}^{\\text{pre}},\\;\\Delta_{\\max}^{\\text{arith}},\\;\\Delta_{\\max}^{\\text{geom}}\\right].\n$$\n\n最终输出格式要求：\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，结果按上面列出的调节子类型以及递增的 $\\Lambda$ 值排序。对于每个调节子-截断值组合，按顺序附加三个数字 $\\Delta_{\\max}^{\\text{pre}}$、$\\Delta_{\\max}^{\\text{arith}}$ 和 $\\Delta_{\\max}^{\\text{geom}}$。例如，输出必须类似于\n$$\n[\\Delta_{\\max}^{\\text{pre}},\\Delta_{\\max}^{\\text{arith}},\\Delta_{\\max}^{\\text{geom}},\\ldots],\n$$\n总共包含 $4 \\times 3 \\times 3 = 36$ 个浮点数条目。所有动量单位均为 $\\text{fm}^{-1}$，输出的差值为无量綱浮点数。",
            "solution": "所述问题是有效的。它在核力的手征有效场论 (EFT) 的标准框架内具有科学依据，提供了一个适定且客观的数值任务。唯一解所需的所有必要常数、函数和参数均已提供。因此，我们可以继续进行推导和计算实现。\n\n问题的核心是在动量空间中研究二核子势 $V_{2N}$ 的厄米性。对于本问题中的实势核，厄米性条件简化为在交换初始和末态动量下的对称性：$V_{2N}(p, p') = V_{2N}(p', p)$。这个性质至关重要，因为它确保哈密頓量是自伴的，从而得到实的能量本征值和幺正的时间演化。我们将分析这个性质如何受到 EFT 中常用的各种调节子函数的影响。\n\n首先，我们定义裸势，它作为我们分析的基础。它由接触相互作用和单π介子交換 (OPE) 项组成。\n$$\nV_{\\text{bare}}(p,p') = C_0 + C_2\\,(p^2 + p'^2) - \\frac{C_{\\pi}}{q^2 + m_\\pi^2}\n$$\n这里，$p$ 和 $p'$ 分别代表入射和出射动量的大小。参数 $C_0$ 和 $C_2$ 是 S 波接触项 $(l=0)$ 的低能常数 (LEC)，最后一项代表 OPE 势的中心部分，其中 $C_{\\pi}$ 是其有效强度，$m_{\\pi}$ 是π介子质量。动量转移定义为 $q = |p - p'|$。\n\n我们必须首先验证这个裸势是厄米性的。我们通过交换 $p$ 和 $p'$ 来检查对称性：\n$$\nV_{\\text{bare}}(p',p) = C_0 + C_2\\,(p'^2 + p^2) - \\frac{C_{\\pi}}{(|p'-p|)^2 + m_\\pi^2}\n$$\n由于加法和乘法是可交換的，$(p'^2 + p^2) = (p^2 + p'^2)$。此外，绝对值函数具有性质 $|p'-p| = |-(p-p')| = |p-p'|$。因此，$V_{\\text{bare}}(p',p)$ 的表达式与 $V_{\\text{bare}}(p,p')$ 的表达式相同。裸势是内禀对称的，因此是厄米的。\n\n接下来，我们引入一个调节子函数 $f_{\\Lambda}(p,p')$，以抑制 EFT 预期会失效的高动量贡献。调节后的势定义为调节子和裸势的乘积：\n$$\nV_{\\text{reg}}(p,p') = f_{\\Lambda}(p,p')\\,V_{\\text{bare}}(p,p')\n$$\n由于 $V_{\\text{bare}}$ 已经是对的，$V_{\\text{reg}}$ 的厄米性现在取决于调节子函数 $f_{\\Lambda}(p,p')$ 的对称性质。如果 $f_{\\Lambda}(p,p') = f_{\\Lambda}(p',p)$，那么 $V_{\\text{reg}}$ 将是厄米的。如果 $f_{\\Lambda}(p,p') \\neq f_{\\Lambda}(p',p)$，厄米性就被破坏了。我们检查每个指定的调节子：\n\n1.  **非定域对称高斯调节子**，$f_{\\Lambda}^{\\text{nl}}(p,p') = \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2n}\\right]\\exp\\!\\left[-\\left(\\frac{p'}{\\Lambda}\\right)^{2n}\\right]$：交换 $p$ 和 $p'$ 会得到相同的表达式。这个调节子是对称的，并保持厄米性。\n2.  **半定域动量转移调节子**，$f_{\\Lambda}^{q}(p,p') = \\exp\\!\\left[-\\left(\\frac{q}{\\Lambda}\\right)^{2n}\\right]$：由于 $q=|p-p'|$ 在交换 $p \\leftrightarrow p'$ 下是对稱的，这个调节子也是对称的，并保持厄米性。\n3.  **非对称单边调节子**，$f_{\\Lambda}^{\\text{left}}(p,p') = \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2n}\\right]$：这里，$f_{\\Lambda}^{\\text{left}}(p',p) = \\exp\\!\\left[-\\left(\\frac{p'}{\\Lambda}\\right)^{2n}\\right]$，它不等于 $f_{\\Lambda}^{\\text{left}}(p,p')$，除非 $p=p'$。这个调节子明确地破坏了厄米性。\n4.  **非对称混合指数调节子**，$f_{\\Lambda}^{\\text{asym}}(p,p') = \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2}\\right]\\exp\\!\\left[-\\left(\\frac{p'}{\\Lambda}\\right)^{4}\\right]$：交换动量得到 $f_{\\Lambda}^{\\text{asym}}(p',p) = \\exp\\!\\left[-\\left(\\frac{p'}{\\Lambda}\\right)^{2}\\right]\\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{4}\\right]$，这与原始表达式不同。这个調節子也破坏了厄米性。\n\n对于非厄米调节子，势必须被显式地对称化。提出了两种方案：\n\n1.  **算术对称化**：\n    $$\n    V_{\\text{sym,arith}}(p,p') = \\frac{1}{2}\\left[V_{\\text{reg}}(p,p') + V_{\\text{reg}}(p',p)\\right]\n    $$\n    这种形式通过构造就是对称的：交换 $p$ 和 $p'$ 只是交换了和中的两项，结果保持不变。它恢复了厄米性。\n\n2.  **几何平均（平方根）对称化**：这作用于调节子函数本身。\n    $$\n    f_{\\Lambda}^{\\text{geom}}(p,p') = \\sqrt{f_{\\Lambda}(p,p')\\,f_{\\Lambda}(p',p)}\n    $$\n    得到的势是 $V_{\\text{sym,geom}}(p,p') = f_{\\Lambda}^{\\text{geom}}(p,p')\\,V_{\\text{bare}}(p,p')$。对称化的调节子 $f_{\\Lambda}^{\\text{geom}}(p,p')$ 根据构造是对称的，因为平方根内的乘积是可交换的。由于 $V_{\\text{bare}}$ 是对称的，最终的势 $V_{\\text{sym,geom}}$ 也保证是对称的。\n\n数值实验将量化厄米性破缺的程度，并验证这些对称化方案的有效性。对于每种调节子类型和截断值 $\\Lambda$，我们在一个动量对 $(p,p')$ 测试集上计算三个度量。这些度量是势与其转置之间的最大绝对差：\n-   $\\Delta_{\\max}^{\\text{pre}} = \\max_{(p,p')}\\left|V_{\\text{reg}}(p,p') - V_{\\text{reg}}(p',p)\\right|$\n-   $\\Delta_{\\max}^{\\text{arith}} = \\max_{(p,p')}\\left|V_{\\text{sym,arith}}(p,p') - V_{\\text{sym,arith}}(p',p)\\right|$\n-   $\\Delta_{\\max}^{\\text{geom}} = \\max_{(p,p')}\\left|V_{\\text{sym,geom}}(p,p') - V_{\\text{sym,geom}}(p',p)\\right|$\n\n理论上，对于对称调节子（$f_{\\Lambda}^{\\text{nl}}$ 和 $f_{\\Lambda}^{q}$），$\\Delta_{\\max}^{\\text{pre}}$ 应该为零。对于非对称调节子（$f_{\\Lambda}^{\\text{left}}$ 和 $f_{\\Lambda}^{\\text{asym}}$），它将为非零。对于所有调节子，$\\Delta_{\\max}^{\\text{arith}}$ 和 $\\Delta_{\\max}^{\\text{geom}}$ 都应该为零，因为两种方案根据定义都恢复了对称性。在数值实现中，这些值将在机器浮点精度范围内为零。计算将使用提供的常数：$C_0=-0.5$、$C_2=0.2$、$C_{\\pi}=0.8$、$m_\\pi=0.7$ 以及适用的指数修饰符 $n=2$（得出 $2n=4$ 的幂次）。\n\n算法流程如下：\n1.  实现 $V_{\\text{bare}}(p,p')$ 以及四种调节子类型的函数。\n2.  按照 [`nl_sym`, `left_only`, `q_semi`, `asym_exp`] 的顺序遍历指定的調節子類型。\n3.  在此循环内，遍历截断值 $\\Lambda \\in \\{1.0, 2.0, 3.0\\}$。\n4.  对于每个 (调节子, $\\Lambda$) 组合，初始化列表以存储每个动量对的破缺度量。\n5.  遍历测试动量对 $(p,p')$。在这个最内层循环中：\n    a. 计算 $V_{\\text{bare}}(p,p')$。注意 $V_{\\text{bare}}(p',p)=V_{\\text{bare}}(p,p')$。\n    b. 计算调节后的势 $V_{\\text{reg}}(p,p')=f_{\\Lambda}(p,p')V_{\\text{bare}}(p,p')$ 及其转置对应项 $V_{\\text{reg}}(p',p)=f_{\\Lambda}(p',p)V_{\\text{bare}}(p',p)$。\n    c. 计算并存储对称化前的破缺 $\\Delta(p,p') = |V_{\\text{reg}}(p,p') - V_{\\text{reg}}(p',p)|$。\n    d. 计算算术对称化的势 $V_{\\text{sym,arith}}(p,p')$ 及其转置，并存储它们的绝对差（预期接近于零）。\n    e. 计算几何对称化的势 $V_{\\text{sym,geom}}(p,p')$ 及其转置，并存储它们的绝对差（预期接近于零）。\n6.  遍历所有动量对后，从三个破缺列表中找出最大值：$\\Delta_{\\max}^{\\text{pre}}$、$\\Delta_{\\max}^{\\text{arith}}$ 和 $\\Delta_{\\max}^{\\text{geom}}$。\n7.  将这三个最大值附加到主结果列表中。\n8.  最后，将主列表格式化为指定的、用方括号括起来的逗号分隔字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Hermiticity violation for different regulators in chiral EFT.\n    \"\"\"\n    # Define the constants from the problem statement.\n    C0 = -0.5\n    C2 = 0.2\n    Cpi = 0.8\n    mpi = 0.7\n    n = 2  # Regulator exponent parameter\n\n    # Define the test cases from the problem statement.\n    cutoffs = [1.0, 2.0, 3.0]\n    momenta_pairs = [\n        (0.0, 0.0),\n        (0.1, 2.5),\n        (1.0, 1.0),\n        (0.5, 1.5),\n        (2.0, 2.6)\n    ]\n\n    # --- Define Potential and Regulator Functions ---\n\n    def v_bare(p, p_prime):\n        \"\"\"Calculates the bare two-nucleon potential.\"\"\"\n        q = np.abs(p - p_prime)\n        contact_term = C0 + C2 * (p**2 + p_prime**2)\n        pion_exchange = -Cpi / (q**2 + mpi**2)\n        return contact_term + pion_exchange\n\n    def f_nl_sym(p, p_prime, Lambda):\n        \"\"\"Nonlocal symmetric Gaussian regulator.\"\"\"\n        return np.exp(-(p / Lambda)**(2 * n)) * np.exp(-(p_prime / Lambda)**(2 * n))\n\n    def f_q_semi(p, p_prime, Lambda):\n        \"\"\"Semi-local momentum-transfer regulator.\"\"\"\n        q = np.abs(p - p_prime)\n        return np.exp(-(q / Lambda)**(2 * n))\n\n    def f_left_only(p, p_prime, Lambda):\n        \"\"\"Asymmetric one-sided regulator.\"\"\"\n        return np.exp(-(p / Lambda)**(2 * n))\n\n    def f_asym_exp(p, p_prime, Lambda):\n        \"\"\"Asymmetric mixed-exponent regulator.\"\"\"\n        return np.exp(-(p / Lambda)**2) * np.exp(-(p_prime / Lambda)**4)\n\n    # Map names to functions according to the specified order.\n    regulator_funcs = {\n        \"nl_sym\": f_nl_sym,\n        \"left_only\": f_left_only,\n        \"q_semi\": f_q_semi,\n        \"asym_exp\": f_asym_exp\n    }\n    regulator_order = [\"nl_sym\", \"left_only\", \"q_semi\", \"asym_exp\"]\n\n    # --- Main Calculation Loop ---\n    \n    all_results = []\n    \n    for reg_name in regulator_order:\n        reg_func = regulator_funcs[reg_name]\n        \n        for Lambda in cutoffs:\n            \n            delta_pre_list = []\n            delta_arith_list = []\n            delta_geom_list = []\n\n            for p, p_prime in momenta_pairs:\n                # --- Pre-symmetrization ---\n                # Calculate V_bare(p, p') and V_bare(p', p), which are identical\n                v_bare_pp = v_bare(p, p_prime)\n                \n                # Calculate regulated potential V_reg(p, p')\n                f_pp = reg_func(p, p_prime, Lambda)\n                v_reg_pp = f_pp * v_bare_pp\n                \n                # Calculate transposed regulated potential V_reg(p', p)\n                f_p_p = reg_func(p_prime, p, Lambda)\n                v_reg_p_p = f_p_p * v_bare(p_prime, p) # v_bare(p',p) = v_bare_pp\n\n                # Calculate violation metric delta_pre\n                delta_pre_list.append(np.abs(v_reg_pp - v_reg_p_p))\n                \n                # --- Arithmetic Symmetrization ---\n                v_sym_arith_pp = 0.5 * (v_reg_pp + v_reg_p_p)\n                v_sym_arith_p_p = 0.5 * (v_reg_p_p + v_reg_pp)\n                delta_arith_list.append(np.abs(v_sym_arith_pp - v_sym_arith_p_p))\n                \n                # --- Geometric Symmetrization ---\n                # Symmetrize the regulator first\n                f_geom_pp = np.sqrt(f_pp * f_p_p)\n                \n                # Calculate potential with symmetrized regulator\n                v_sym_geom_pp = f_geom_pp * v_bare_pp\n                \n                # Transposed version is identical by construction\n                f_geom_p_p = np.sqrt(f_p_p * f_pp)\n                v_sym_geom_p_p = f_geom_p_p * v_bare(p_prime, p)\n                delta_geom_list.append(np.abs(v_sym_geom_pp - v_sym_geom_p_p))\n\n            # Find the maximum violation for the current (regulator, Lambda) pair\n            delta_max_pre = np.max(delta_pre_list)\n            delta_max_arith = np.max(delta_arith_list)\n            delta_max_geom = np.max(delta_geom_list)\n            \n            all_results.extend([delta_max_pre, delta_max_arith, delta_max_geom])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然散射计算天然地在动量空间中进行，但我们的物理直觉往往植根于坐标空间中的势。本练习通过要求您对标准的有效场论势（如单π和双π交换势）进行数值傅里叶变换，从而弥合了这一差距。您不仅将实现这一变换，还将验证所得到的坐标空间势 $V(r)$ 是否在长程（类汤川衰变）和短程都正确地再现了预期的理论行为 。",
            "id": "3555522",
            "problem": "考虑在手征有效场论 (ChEFT) 框架内，从动量空间表达式推导坐标空间的两核子力。使用自然单位制，其中约化普朗克常数和光速均为1。长度单位使用飞米 (fm)，动量单位使用反飞米 (fm⁻¹)，且不转换为任何其他单位体系。目标是通过直接数值计算，验证长程单π介子交换和双π介子交换贡献的动量空间和坐标空间表示之间的等价性，并检验它们在光滑调节子下的短程有限性。\n\n从以下基本依据开始：\n- 从球对称动量空间势 $\\tilde{V}(q)$ 到坐标空间中心势 $V(r)$ 的三维傅里叶变换由下式给出\n$$\nV(r) = \\frac{1}{2\\pi^2} \\int_{0}^{\\infty} dq\\, q^2\\, j_0(q r)\\, \\tilde{V}(q), \\quad j_0(x) = \\frac{\\sin x}{x}.\n$$\n- 动量空间中的单π介子交换 (OPE) 标量核，用于捕捉OPE底层的径向汤川结构，其模型为\n$$\n\\tilde{V}_{\\text{OPE}}(q) = -\\frac{C_{\\text{OPE}}}{q^2 + m_\\pi^2}\\, F_\\Lambda(q),\n$$\n其中 $C_{\\text{OPE}} = \\frac{g_A^2}{4 f_\\pi^2}$，$g_A$ 是轴矢量耦合常数，$f_\\pi$ 是π介子衰变常数，$m_\\pi$ 是π介子质量，$F_\\Lambda(q)$ 是一个光滑调节子。\n- 动量空间中的次领头阶中心双π介子交换 (TPE) 核（忽略一个全局常数）的模型为\n$$\n\\tilde{V}_{\\text{TPE}}(q) = C_{\\text{TPE}}\\,(4 m_\\pi^2 + q^2)\\, L(q)\\, F_\\Lambda(q),\n$$\n其中\n$$\nL(q) = \\frac{\\sqrt{4 m_\\pi^2 + q^2}}{q}\\, \\ln\\!\\left(\\frac{\\sqrt{4 m_\\pi^2 + q^2} + q}{2 m_\\pi}\\right),\n$$\n且 $C_{\\text{TPE}} = -\\frac{3 g_A^4}{64 \\pi f_\\pi^4}$。函数 $L(q)$ 编码了双π割线，并确保了 $V(r)$ 中正确的长程标度。\n\n使用光滑调节子\n$$\nF_\\Lambda(q) = \\exp\\!\\left(-\\left(\\frac{q}{\\Lambda}\\right)^4\\right),\n$$\n其中截断 $\\Lambda$ 的单位为 fm⁻¹。\n\n数值计算中要使用的常数：\n- $g_A = 1.27$ (无量纲),\n- $f_\\pi = 92.4\\,\\text{MeV}$,\n- $m_\\pi = 138.0\\,\\text{MeV}$,\n- 必须使用转换因子 $1\\,\\text{fm}^{-1} = 197.3269804\\,\\text{MeV}$，在公式中使用前将 $f_\\pi$ 和 $m_\\pi$ 表示为 fm⁻¹。\n\n待数值检验的解析期望：\n- 对于大分离 $r \\to \\infty$ 时的OPE，坐标空间势趋近于汤川形式\n$$\nV_{\\text{OPE}}(r) \\sim -\\frac{C_{\\text{OPE}}}{4\\pi}\\, \\frac{e^{-m_\\pi r}}{r},\n$$\n因此组合 $Y(r) \\equiv V_{\\text{OPE}}(r)\\, r\\, e^{m_\\pi r}$ 趋向于常数 $-C_{\\text{OPE}}/(4\\pi)$。\n- 对于大 $r$ 时的TPE，势以双π介子质量标度呈指数衰减，\n$$\nV_{\\text{TPE}}(r) \\propto e^{-2 m_\\pi r} \\times \\text{(power of $r$)},\n$$\n因此由下式定义的有效指数斜率\n$$\nm_{\\text{eff}}(r;\\Delta) = -\\frac{1}{\\Delta}\\, \\ln\\!\\left(\\frac{|V_{\\text{TPE}}(r+\\Delta)|}{|V_{\\text{TPE}}(r)|}\\right)\n$$\n在固定的小 $\\Delta$ 下，当 $r \\to \\infty$ 时趋向于 $2 m_\\pi$。\n- 对于使用光滑调节子 $F_\\Lambda(q)$ 的OPE和TPE，短程极限 $r \\to 0$ 是有限的，且等于\n$$\nV(0) = \\frac{1}{2\\pi^2} \\int_0^\\infty dq\\, q^2\\, \\tilde{V}(q),\n$$\n这是由 $r \\to 0$ 时 $j_0(q r) \\to 1$ 推导出来的。\n\n实现一个自适应求积方法来计算上述用于 $V(r)$ 和 $r=0$ 极限的傅里叶变换积分。你可以选择合理的积分上限以确保数值收敛，但这需要基于调节子标度 $\\Lambda$ 和 $r$ 的值，并记录和实现一个清晰的策略来确保积分的收敛性。不涉及角度。所有长度必须以飞米 (fm) 为单位，动量必须以反飞米 (fm⁻¹) 为单位。所有要求的输出均为无量纲浮点数或布尔值，具体如下所述。\n\n测试套件。使用以下参数值来检验计算的不同方面：\n- 物理常数：$g_A = 1.27$，$f_\\pi = 92.4\\,\\text{MeV}$，$m_\\pi = 138.0\\,\\text{MeV}$，以及 $1\\,\\text{fm}^{-1} = 197.3269804\\,\\text{MeV}$（因此 $f_\\pi$ 和 $m_\\pi$ 在使用前必须内部转换为 fm⁻¹）。\n- 截断：$\\Lambda_1 = 2.0\\,\\text{fm}^{-1}$，$\\Lambda_2 = 3.0\\,\\text{fm}^{-1}$。\n- 半径和步长：$r_{\\text{large}} = 5.0\\,\\text{fm}$，$r_{\\text{Yuk}} = 5.0\\,\\text{fm}$ 用于OPE汤川检验，$r_{\\text{slope}} = 3.0\\,\\text{fm}$，$\\Delta = 0.2\\,\\text{fm}$ 用于TPE斜率，$r_{\\text{small}} = 0.05\\,\\text{fm}$ 用于短程检验。\n\n你的程序必须计算并输出以下六个结果，并严格按照此顺序，以逗号分隔列表的形式包含在方括号中，并打印在单行上：\n1. 一个浮点数，等于使用 $\\Lambda=\\Lambda_2$ 对 $\\tilde{V}_{\\text{OPE}}(q)$ 进行数值傅里叶变换计算出的 $Y(r_{\\text{Yuk}})$ 与解析常数 $-C_{\\text{OPE}}/(4\\pi)$ 之间的绝对相对误差，即\n$$\n\\epsilon_{\\text{OPE,large}} = \\frac{\\left|V_{\\text{OPE}}(r_{\\text{Yuk}})\\, r_{\\text{Yuk}}\\, e^{m_\\pi r_{\\text{Yuk}}} + \\frac{C_{\\text{OPE}}}{4\\pi}\\right|}{\\left|\\frac{C_{\\text{OPE}}}{4\\pi}\\right|}.\n$$\n2. 一个浮点数，等于使用 $\\Lambda=\\Lambda_2$ 时，$V_{\\text{OPE}}(r_{\\text{small}})$ 与通过非振荡积分计算出的 $r\\to 0$ 极限之间的绝对相对差异：\n$$\n\\epsilon_{\\text{OPE,small}} = \\frac{\\left|V_{\\text{OPE}}(r_{\\text{small}}) - V_{\\text{OPE}}(0)\\right|}{\\left|V_{\\text{OPE}}(0)\\right|}.\n$$\n3. 一个浮点数，等于使用 $\\Lambda=\\Lambda_2$ 从 $\\tilde{V}_{\\text{TPE}}(q)$ 的数值傅里叶变换中提取的有效斜率 $m_{\\text{eff}}(r_{\\text{slope}};\\Delta)$ 与期望值 $2 m_\\pi$ 之间的绝对相对误差：\n$$\n\\epsilon_{\\text{TPE,large}} = \\frac{\\left|m_{\\text{eff}}(r_{\\text{slope}};\\Delta) - 2 m_\\pi\\right|}{2 m_\\pi}.\n$$\n4. 一个浮点数，等于使用 $\\Lambda=\\Lambda_2$ 时，$V_{\\text{TPE}}(r_{\\text{small}})$ 与通过非振荡积分计算出的 $r \\to 0$ 极限之间的绝对相对差异：\n$$\n\\epsilon_{\\text{TPE,small}} = \\frac{\\left|V_{\\text{TPE}}(r_{\\text{small}}) - V_{\\text{TPE}}(0)\\right|}{\\left|V_{\\text{TPE}}(0)\\right|}.\n$$\n5. 一个布尔值，表示短程OPE势的绝对值是否随截断的增加而增加，即 $\\left|V_{\\text{OPE}}(r_{\\text{small}};\\Lambda_2)\\right|  \\left|V_{\\text{OPE}}(r_{\\text{small}};\\Lambda_1)\\right|$ 是否成立。\n6. 一个浮点数，等于分别使用 $\\Lambda=\\Lambda_2$ 和 $\\Lambda=\\Lambda_1$ 计算出的OPE大距离汤川归一化常数 $Y(r_{\\text{Yuk}})$ 之间的绝对相对差异：\n$$\n\\epsilon_{\\text{OPE,reg-indep}} = \\frac{\\left|Y_{\\Lambda_2}(r_{\\text{Yuk}}) - Y_{\\Lambda_1}(r_{\\text{Yuk}})\\right|}{\\max\\!\\left(\\left|Y_{\\Lambda_2}(r_{\\text{Yuk}})\\right|,\\left|Y_{\\Lambda_1}(r_{\\text{Yuk}})\\right|\\right)}.\n$$\n\n算法要求：\n- 使用自适应求积来计算所有必需的积分，并具有足够的精度以使上述量在数值上稳定。你可以根据调节子标度 $\\Lambda$ 和 $r$ 的值来选择积分上限，但需记录并实现一个清晰的策略来确保积分的收敛。\n- 使用适当的极限形式来安全地处理 $L(q)$ 和 $j_0(q r)$ 在 $q \\to 0$ 时的极限，以避免浮点不确定性。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4,result5,result6]”）。\n- 所有浮点数都是无量纲的，必须以标准十进制表示法打印。布尔值必须是 True 或 False。不得打印任何附加文本。",
            "solution": "该问题要求对单π介子交换 (OPE) 和双π介子交换 (TPE) 核子-核子势的几个关键性质进行数值验证，这些性质是在手征有效场论 (ChEFT) 框架内推导出来的。该过程涉及通过三维傅里叶变换从其动量空间表示 $\\tilde{V}(q)$ 计算坐标空间势 $V(r)$，然后使用这些数值结果来检验关于其长程和短程行为的理论预期。\n\n首先，我们为计算建立理论和数值基础。所有物理量都必须用一致的单位制表示。问题指定长度单位为飞米 (fm)，动量单位为反飞米 (fm⁻¹)。所提供的常数必须进行相应转换。转换因子给定为 $1\\,\\text{fm}^{-1} = 197.3269804\\,\\text{MeV}$。\nπ介子质量 $m_\\pi$ 和π介子衰变常数 $f_\\pi$ 转换如下：\n$$\nm_\\pi = 138.0\\,\\text{MeV} = \\frac{138.0}{197.3269804}\\,\\text{fm}^{-1} \\approx 0.6993\\,\\text{fm}^{-1}\n$$\n$$\nf_\\pi = 92.4\\,\\text{MeV} = \\frac{92.4}{197.3269804}\\,\\text{fm}^{-1} \\approx 0.4682\\,\\text{fm}^{-1}\n$$\n使用轴矢量耦合常数 $g_A = 1.27$，我们可以计算无量纲的OPE耦合常数 $C_{\\text{OPE}}$ 和TPE耦合常数 $C_{\\text{TPE}}$（单位为 fm²）：\n$$\nC_{\\text{OPE}} = \\frac{g_A^2}{4 f_\\pi^2} = \\frac{(1.27)^2}{4 (0.4682)^2} \\approx 1.840\n$$\n$$\nC_{\\text{TPE}} = -\\frac{3 g_A^4}{64 \\pi f_\\pi^4} = -\\frac{3 (1.27)^4}{64 \\pi (0.4682)^4} \\approx -0.814\\,\\text{fm}^2\n$$\n\n核心问题是球对称势的傅里叶变换的数值计算：\n$$\nV(r) = \\frac{1}{2\\pi^2} \\int_{0}^{\\infty} dq\\, q^2\\, j_0(q r)\\, \\tilde{V}(q)\n$$\n其中 $j_0(x) = \\frac{\\sin x}{x}$ 是0阶球贝塞尔函数。OPE和TPE的动量空间势 $\\tilde{V}(q)$ 分别给出：\n$$\n\\tilde{V}_{\\text{OPE}}(q) = -\\frac{C_{\\text{OPE}}}{q^2 + m_\\pi^2}\\, F_\\Lambda(q)\n$$\n$$\n\\tilde{V}_{\\text{TPE}}(q) = C_{\\text{TPE}}\\,(4 m_\\pi^2 + q^2)\\, L(q)\\, F_\\Lambda(q)\n$$\n两个表达式都包含调节函数 $F_\\Lambda(q) = \\exp(-(q/\\Lambda)^4)$，它通过抑制高动量 $q \\gg \\Lambda$ 的贡献来确保积分收敛。\n\n积分的数值计算需要仔细实现。我们采用自适应求积例程，特别是 `scipy.integrate.quad`，它非常适合此类定积分。积分的无限上界可以替换为一个有限值 $q_{\\text{max}}$，因为调节子 $F_\\Lambda(q)$ 会使被积函数衰减得非常快。选择 $q_{\\text{max}} = 8\\Lambda$ 就足够了，因为 $F_\\Lambda(8\\Lambda) = \\exp(-8^4) \\approx 10^{-1779}$，这在双精度下是数值上的零。\n\n此外，我们必须处理某些函数在 $q=0$ 时的行为：\n1. 球贝塞尔函数 $j_0(qr) = \\frac{\\sin(qr)}{qr}$ 在其自变量 $qr \\to 0$ 时有极限值 $1$。数值实现必须使用此极限以避免 `0/0` 不确定性。\n2. TPE圈函数 $L(q)$ 由下式给出：\n$$\nL(q) = \\frac{\\sqrt{4 m_\\pi^2 + q^2}}{q}\\, \\ln\\!\\left(\\frac{\\sqrt{4 m_\\pi^2 + q^2} + q}{2 m_\\pi}\\right)\n$$\n当 $q \\to 0$ 时，该函数也呈现 `0/0` 形式。其极限值为 $L(0) = 1$。为了在小 $q$ 处保持数值稳定性，我们使用泰勒级数展开 $L(q) \\approx 1 + \\frac{q^2}{12 m_\\pi^2}$。一个小的阈值可以用来隔离使用此近似的区域。\n\n我们被要求计算六个量：\n\n1.  **长程OPE行为, $\\epsilon_{\\text{OPE,large}}$**: 我们在 $r=r_{\\text{Yuk}}=5.0\\,\\text{fm}$ 处使用 $\\Lambda=\\Lambda_2=3.0\\,\\text{fm}^{-1}$ 计算 $V_{\\text{OPE}}(r)$。然后我们构建量 $Y(r_{\\text{Yuk}}) = V_{\\text{OPE}}(r_{\\text{Yuk}})\\, r_{\\text{Yuk}}\\, e^{m_\\pi r_{\\text{Yuk}}}$，并将其与纯汤川势的解析预期极限 $-C_{\\text{OPE}}/(4\\pi)$ 进行比较。计算相对误差。\n\n2.  **短程OPE行为, $\\epsilon_{\\text{OPE,small}}$**: 在原点的势 $V(0)$ 由一个简化的、非振荡的积分给出，因为 $j_0(0)=1$：\n    $$\n    V(0) = \\frac{1}{2\\pi^2} \\int_0^\\infty dq\\, q^2\\, \\tilde{V}(q)\n    $$\n    我们计算 $V_{\\text{OPE}}(0)$ 和在 $r_{\\text{small}}=0.05\\,\\text{fm}$ 处的 $V_{\\text{OPE}}(r_{\\text{small}})$（使用 $\\Lambda=\\Lambda_2=3.0\\,\\text{fm}^{-1}$）。计算这两个值之间的相对差异，以验证势在原点确实是光滑和有限的。\n\n3.  **长程TPE行为, $\\epsilon_{\\text{TPE,large}}$**: TPE势的长程行为预计由一个标度为 $2m_\\pi$ 的指数衰减主导。我们通过计算一个有效质量 $m_{\\text{eff}}(r_{\\text{slope}};\\Delta) = -\\frac{1}{\\Delta}\\, \\ln(|V_{\\text{TPE}}(r_{\\text{slope}}+\\Delta)|/|V_{\\text{TPE}}(r_{\\text{slope}})|)$ 来检验这一点，其中使用 $r_{\\text{slope}}=3.0\\,\\text{fm}$ 和 $r_{\\text{slope}}+\\Delta=3.2\\,\\text{fm}$ 处的 $V_{\\text{TPE}}(r)$ 的数值（使用 $\\Delta=0.2\\,\\text{fm}$, $\\Lambda=\\Lambda_2=3.0\\,\\text{fm}^{-1}$）。计算 $m_{\\text{eff}}$ 相对于期望值 $2m_\\pi$ 的相对误差。\n\n4.  **短程TPE行为, $\\epsilon_{\\text{TPE,small}}$**: 与OPE情况类似，我们计算 $V_{\\text{TPE}}(r_{\\text{small}})$ 和 $V_{\\text{TPE}}(0)$ 在 $r_{\\text{small}}=0.05\\,\\text{fm}$ 处的相对差异（使用 $\\Lambda=\\Lambda_2=3.0\\,\\text{fm}^{-1}$），以确认TPE势在原点的有限性。\n\n5.  **短程OPE的截断依赖性**: 我们计算 $|V_{\\text{OPE}}(r_{\\text{small}})|$ 对于两个不同的截断 $\\Lambda_1=2.0\\,\\text{fm}^{-1}$ 和 $\\Lambda_2=3.0\\,\\text{fm}^{-1}$。更大的截断 ($\\Lambda_2$) 允许更大的动量贡献，这与更短的距离标度相关联。对于吸引势，这应该会增加其绝对值。我们验证 $|V_{\\text{OPE}}(r_{\\text{small}};\\Lambda_2)| > |V_{\\text{OPE}}(r_{\\text{small}};\\Lambda_1)|$ 是否成立。\n\n6.  **长程OPE的调节子无关性, $\\epsilon_{\\text{OPE,reg-indep}}$**: 势的长程部分应该与短程调节子无关。我们通过计算两种截断下的汤川归一化常数 $Y_{\\Lambda_1}(r_{\\text{Yuk}})$ 和 $Y_{\\Lambda_2}(r_{\\text{Yuk}})$ 来检验这一点，然后计算它们的相对差异。这个差异预计会非常小。\n\n该实现将这些步骤封装到一个单一的过程中，使用指定的常数和参数，以生成所需的六个数值结果列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    # --- Problem Constants and Parameters ---\n    g_A = 1.27\n    f_pi_mev = 92.4\n    m_pi_mev = 138.0\n    CONV_FACTOR = 197.3269804  # MeV per fm^-1\n\n    # Convert to fm^-1\n    m_pi = m_pi_mev / CONV_FACTOR\n    f_pi = f_pi_mev / CONV_FACTOR\n\n    # ChEFT coupling constants\n    C_OPE = (g_A**2) / (4 * f_pi**2)\n    C_TPE = -3 * (g_A**4) / (64 * np.pi * f_pi**4)\n\n    # Test suite parameters\n    Lambda1 = 2.0  # fm^-1\n    Lambda2 = 3.0  # fm^-1\n    r_yuk = 5.0    # fm\n    r_slope = 3.0  # fm\n    delta = 0.2    # fm\n    r_small = 0.05 # fm\n\n    # --- Helper Functions for Physics ---\n\n    def F_Lambda(q, Lambda):\n        \"\"\"Smooth regulator function.\"\"\"\n        return np.exp(-(q / Lambda)**4)\n\n    def j0(x):\n        \"\"\"Spherical Bessel function of order 0, j_0(x) = sin(x)/x.\"\"\"\n        # Use np.sinc which is sin(pi*x)/(pi*x) to handle x=0 correctly.\n        # j0(x) = sinc(x/pi)\n        return np.sinc(x / np.pi)\n\n    def L_func(q, m_pi_val):\n        \"\"\"TPE loop function L(q).\"\"\"\n        # Threshold for using Taylor expansion\n        q_threshold = 1e-6\n        if q  q_threshold:\n            # L(q) approx 1 + q^2 / (12 * m_pi^2)\n            return 1.0 + q**2 / (12 * m_pi_val**2)\n        \n        sqrt_term = np.sqrt(4 * m_pi_val**2 + q**2)\n        log_arg = (sqrt_term + q) / (2 * m_pi_val)\n        return (sqrt_term / q) * np.log(log_arg)\n\n    # --- Momentum-Space Potentials ---\n\n    def V_OPE_tilde(q, Lambda):\n        \"\"\"Momentum-space OPE potential kernel.\"\"\"\n        return -C_OPE / (q**2 + m_pi**2) * F_Lambda(q, Lambda)\n    \n    def V_TPE_tilde(q, Lambda):\n        \"\"\"Momentum-space TPE potential kernel.\"\"\"\n        return C_TPE * (4 * m_pi**2 + q**2) * L_func(q, m_pi) * F_Lambda(q, Lambda)\n\n    # --- Fourier Transform Calculation ---\n\n    def calculate_V(r, V_tilde_func, Lambda):\n        \"\"\"\n        Calculates the coordinate-space potential V(r) via Fourier transform.\n        \"\"\"\n        # The integral is from 0 to infinity. We use a practical upper limit.\n        q_max = 8.0 * Lambda\n        \n        def integrand(q):\n            return q**2 * j0(q * r) * V_tilde_func(q, Lambda)\n\n        integral_val, _ = quad(integrand, 0, q_max, epsabs=1e-12, epsrel=1e-12)\n        \n        return integral_val / (2 * np.pi**2)\n\n    def calculate_V0(V_tilde_func, Lambda):\n        \"\"\"\n        Calculates V(r=0), where j_0(q*r) = 1.\n        \"\"\"\n        q_max = 8.0 * Lambda\n\n        def integrand_V0(q):\n            return q**2 * V_tilde_func(q, Lambda)\n\n        integral_val, _ = quad(integrand_V0, 0, q_max, epsabs=1e-12, epsrel=1e-12)\n\n        return integral_val / (2 * np.pi**2)\n\n    results = []\n\n    # --- 1. OPE long-range behavior ---\n    V_OPE_r_yuk_L2 = calculate_V(r_yuk, V_OPE_tilde, Lambda2)\n    Y_r_yuk_L2_numerical = V_OPE_r_yuk_L2 * r_yuk * np.exp(m_pi * r_yuk)\n    Y_analytic = -C_OPE / (4 * np.pi)\n    epsilon_OPE_large = np.abs((Y_r_yuk_L2_numerical - Y_analytic) / Y_analytic)\n    results.append(epsilon_OPE_large)\n\n    # --- 2. OPE short-range behavior ---\n    V_OPE_r_small_L2 = calculate_V(r_small, V_OPE_tilde, Lambda2)\n    V_OPE_0_L2 = calculate_V0(V_OPE_tilde, Lambda2)\n    epsilon_OPE_small = np.abs(V_OPE_r_small_L2 - V_OPE_0_L2) / np.abs(V_OPE_0_L2)\n    results.append(epsilon_OPE_small)\n\n    # --- 3. TPE long-range behavior ---\n    V_TPE_r_slope = calculate_V(r_slope, V_TPE_tilde, Lambda2)\n    V_TPE_r_slope_plus_delta = calculate_V(r_slope + delta, V_TPE_tilde, Lambda2)\n    # Potentials can be negative, so use absolute value inside log\n    m_eff_numerical = (-1.0 / delta) * np.log(np.abs(V_TPE_r_slope_plus_delta) / np.abs(V_TPE_r_slope))\n    m_eff_analytic = 2 * m_pi\n    epsilon_TPE_large = np.abs((m_eff_numerical - m_eff_analytic) / m_eff_analytic)\n    results.append(epsilon_TPE_large)\n\n    # --- 4. TPE short-range behavior ---\n    V_TPE_r_small_L2 = calculate_V(r_small, V_TPE_tilde, Lambda2)\n    V_TPE_0_L2 = calculate_V0(V_TPE_tilde, Lambda2)\n    epsilon_TPE_small = np.abs(V_TPE_r_small_L2 - V_TPE_0_L2) / np.abs(V_TPE_0_L2)\n    results.append(epsilon_TPE_small)\n    \n    # --- 5. Cutoff dependence of short-range OPE ---\n    V_OPE_r_small_L1 = calculate_V(r_small, V_OPE_tilde, Lambda1)\n    # V_OPE_r_small_L2 already calculated for test 2\n    is_magnitude_increasing = np.abs(V_OPE_r_small_L2) > np.abs(V_OPE_r_small_L1)\n    results.append(is_magnitude_increasing)\n\n    # --- 6. Regulator independence of long-range OPE ---\n    V_OPE_r_yuk_L1 = calculate_V(r_yuk, V_OPE_tilde, Lambda1)\n    Y_r_yuk_L1_numerical = V_OPE_r_yuk_L1 * r_yuk * np.exp(m_pi * r_yuk)\n    # Y_r_yuk_L2_numerical is from test 1\n    numerator_reg_indep = np.abs(Y_r_yuk_L2_numerical - Y_r_yuk_L1_numerical)\n    denominator_reg_indep = max(np.abs(Y_r_yuk_L2_numerical), np.abs(Y_r_yuk_L1_numerical))\n    epsilon_OPE_reg_indep = numerator_reg_indep / denominator_reg_indep\n    results.append(epsilon_OPE_reg_indep)\n\n    # Final print statement\n    # Convert boolean to Python's True/False string representation\n    formatted_results = []\n    for res in results:\n        if isinstance(res, (bool, np.bool_)):\n            formatted_results.append(str(res))\n        else:\n            formatted_results.append(f\"{res}\")\n            \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}