{
    "hands_on_practices": [
        {
            "introduction": "实验物理学中最基本的任务之一是从截面数据中提取共振的性质，例如其能量 $E_R$ 和宽度 $\\Gamma$。本实践将指导您使用非线性最小二乘法来拟合共振线型。更重要的是，它侧重于分析所得的参数协方差矩阵，这对于理解 $E_R$ 和 $\\Gamma$ 之间的不确定性和相关性，以及评估它们是否能被数据唯一确定至关重要。",
            "id": "3596468",
            "problem": "要求您编写一个完整且可运行的程序，对一个基于物理的核散射截面共振模型进行加权非线性最小二乘拟合，然后分析共振能量和宽度的参数相关性与可辨识性。该模型包含一个由洛伦兹线型描述的孤立共振，该线型与概率守恒和幺正性一致，以及一个平滑的线性本底。您的程序必须从散射矩阵的定义和共振散射的基本结构出发，并在代码注释中证明所用拟合模型的合理性。拟合应针对具有已知测量不确定度的合成数据集进行，这些不确定度被视为独立的高斯分布，并且必须从与加权最小二乘目标函数相关的费雪信息中估计参数协方差。程序必须计算共振能量和宽度的协方差矩阵、相应的相关系数，以及基于一个数值指定准则的可辨识性标志。\n\n定义和要求：\n\n- 设自变量为质心能量 $E$（单位为 $\\mathrm{MeV}$），可观测量为截面 $y(E)$（单位为靶）。共振结构由散射矩阵中靠近实能量轴的一个极点来表征，其极点位置为 $E_R - i \\Gamma/2$，其中 $E_R$ 是共振能量（单位为 $\\mathrm{MeV}$），$\\Gamma$ 是总宽度（单位为 $\\mathrm{MeV}$）。假设本底在能量窗口内变化缓慢。\n- 定义参数向量为 $\\theta = (E_R, \\Gamma, A, B_0, B_1)$，其中 $A$ 是一个正的振幅参数（单位为靶），$B_0$ 是本底截距（单位为靶），$B_1$ 是本底斜率（单位为靶/$\\mathrm{MeV}$）。\n- 给定 $N$ 个数据点 $\\{(E_i, y_i, \\sigma_i)\\}_{i=1}^N$，其中 $\\sigma_i$ 是已知的标准差（单位为靶），加权非线性最小二乘的目标函数为\n$$\n\\chi^2(\\theta) = \\sum_{i=1}^N \\frac{\\left[y_i - y(E_i;\\theta)\\right]^2}{\\sigma_i^2}.\n$$\n- 在最佳拟合 $\\hat{\\theta}$ 处，参数协方差矩阵可通过独立高斯误差的费雪信息的逆来近似，\n$$\n\\mathrm{Cov}(\\hat{\\theta}) \\approx \\left(J^\\top W J\\right)^{-1},\n$$\n其中 $J$ 是雅可比矩阵，其元素 $J_{ij} = \\partial y(E_i;\\theta)/\\partial \\theta_j$ 在 $\\hat{\\theta}$ 处求值，而 $W$ 是对角矩阵，其元素 $W_{ii} = 1/\\sigma_i^2$。\n- 提取对应于 $(E_R, \\Gamma)$ 的 $2\\times 2$ 协方差子矩阵，计算其相关系数\n$$\n\\rho_{E_R,\\Gamma} = \\frac{\\mathrm{Cov}(E_R,\\Gamma)}{\\sqrt{\\mathrm{Var}(E_R)\\,\\mathrm{Var}(\\Gamma)}},\n$$\n并计算此 $2\\times 2$ 协方差子矩阵的 2-范数条件数，\n$$\n\\kappa = \\|C\\|_2 \\,\\|C^{-1}\\|_2,\n$$\n其中 $C$ 是 $(E_R, \\Gamma)$ 的协方差子矩阵。\n- 为 $(E_R, \\Gamma)$ 定义一个可辨识性标志 $I$ 如下：如果 $|\\rho_{E_R,\\Gamma}| > 0.95$ 或 $\\kappa > 10^8$ 之一成立，则设置 $I$ 为 $\\mathrm{False}$（不可辨识），否则设置为 $\\mathrm{True}$。\n\n您的程序必须使用与单能级共振散射和线性本底一致的共振线型来生成合成数据集。能量单位必须是 $\\mathrm{MeV}$，截面单位必须是靶。使用关于 $E_R$ 对称的等间距能量网格，窗口半宽与 $\\Gamma$ 成正比。不要添加随机噪声；使用模型精确生成 $y_i$，并为每个测试案例分配一个恒定的 $\\sigma_i$。\n\n为每个测试案例实现加权非线性最小二乘拟合，并强制执行不确定度的绝对权重，然后计算：\n- 相关系数 $\\rho_{E_R,\\Gamma}$（无量纲）。\n- 条件数 $\\kappa$（无量纲）。\n- 可辨识性标志 $I$（布尔值）。\n\n测试套件：\n\n提供并解决以下三个测试案例。对于每个案例，能量单位必须是 $\\mathrm{MeV}$，宽度单位是 $\\mathrm{MeV}$，截面单位是靶，不确定度单位是靶。每个能量网格必须从 $E_{\\min} = E_R - m\\,\\Gamma$ 到 $E_{\\max} = E_R + m\\,\\Gamma$，包含 $N$ 个等间距点，其中 $m$ 是一个无量纲的乘数：\n\n- 案例1（采样良好的共振，中等本底）：\n  - $E_R = 5.0\\,\\mathrm{MeV}$，$\\Gamma = 0.2\\,\\mathrm{MeV}$，$A = 10.0\\,\\mathrm{barn}$，$B_0 = 1.0\\,\\mathrm{barn}$，$B_1 = 0.2\\,\\mathrm{barn}/\\mathrm{MeV}$，\n  - $m = 8$，$N = 121$，对于所有 $i$，$\\sigma_i \\equiv 0.05\\,\\mathrm{barn}$。\n\n- 案例2（采样粗糙的窄共振）：\n  - $E_R = 5.0\\,\\mathrm{MeV}$，$\\Gamma = 0.01\\,\\mathrm{MeV}$，$A = 10.0\\,\\mathrm{barn}$，$B_0 = 1.0\\,\\mathrm{barn}$，$B_1 = 0.2\\,\\mathrm{barn}/\\mathrm{MeV}$，\n  - $m = 6$，$N = 21$，对于所有 $i$，$\\sigma_i \\equiv 0.05\\,\\mathrm{barn}$。\n\n- 案例3（窗口受限且本底斜率大）：\n  - $E_R = 5.0\\,\\mathrm{MeV}$，$\\Gamma = 0.5\\,\\mathrm{MeV}$，$A = 5.0\\,\\mathrm{barn}$，$B_0 = 1.0\\,\\mathrm{barn}$，$B_1 = 5.0\\,\\mathrm{barn}/\\mathrm{MeV}$，\n  - $m = 2$，$N = 41$，对于所有 $i$，$\\sigma_i \\equiv 0.05\\,\\mathrm{barn}$。\n\n算法期望：\n\n- 您的代码必须从共振散射的基本原理出发，证明共振线型的合理性，并使用现代数值程序实现加权非线性最小二乘拟合。\n- 使用适当的权重计算参数协方差，其中 $\\sigma_i$ 被视为绝对不确定度。\n- 提取 $(E_R, \\Gamma)$ 的协方差子矩阵，计算 $\\rho_{E_R,\\Gamma}$ 和 $\\kappa$，并根据上述准则设置可辨识性标志 $I$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试案例，其本身是一个形式为 $[\\rho_{E_R,\\Gamma}, \\kappa, I]$ 的列表。例如，打印的行必须看起来像\n$[[r_1, c_1, b_1],[r_2, c_2, b_2],[r_3, c_3, b_3]]$，\n其中 $r_k$ 和 $c_k$ 是浮点数，$b_k$ 是案例 $k$ 的布尔值。",
            "solution": "该问题要求实现对一个基于物理的共振模型进行加权非线性最小二乘拟合，并随后分析参数的相关性和可辨识性。解决方案围绕三个核心部分构建：物理模型的定义、数值拟合过程以及参数不确定度的统计分析。\n\n**1. 物理模型：Breit-Wigner 共振**\n\n核散射截面模型基于量子力学中共振散射的基本原理。共振对应于一个准稳中间态的形成，该中间态具有特征能量 $E_R$ 和有限的寿命，其寿命与衰变宽度 $\\Gamma$ 成反比。这种状态的存在导致能量依赖的截面出现一个尖锐的峰。\n\n这种行为由散射矩阵（$S$矩阵）形式化描述。为了保证概率守恒，$S$矩阵必须是幺正的，即 $S^\\dagger S = I$。对于单个散射道中的单个孤立共振，在共振附近，$S$矩阵元可以通过位于复能量平面上 $E = E_R - i\\Gamma/2$ 的一个极点来参数化。这导出了 $S$矩阵元的 Breit-Wigner 公式：\n$$\nS(E) \\approx e^{2i\\delta_{bg}} \\frac{E - E_R - i\\Gamma/2}{E - E_R + i\\Gamma/2}\n$$\n其中 $\\delta_{bg}$ 代表一个缓慢变化的本底相移。对于我们的唯象模型，我们可以通过设置 $\\delta_{bg}=0$ 来简化。弹性散射截面的共振部分 $\\sigma_{\\text{res}}(E)$ 与 $|1 - S(E)|^2$ 成正比。直接计算可得：\n$$\n\\sigma_{\\text{res}}(E) \\propto \\left|1 - \\frac{E - E_R - i\\Gamma/2}{E - E_R + i\\Gamma/2}\\right|^2 = \\left|\\frac{(E - E_R + i\\Gamma/2) - (E - E_R - i\\Gamma/2)}{E - E_R + i\\Gamma/2}\\right|^2 = \\left|\\frac{i\\Gamma}{E - E_R + i\\Gamma/2}\\right|^2 = \\frac{\\Gamma^2}{(E - E_R)^2 + (\\Gamma/2)^2}\n$$\n此函数具有洛伦兹形状。问题指定了一个将此共振结构与简单线性本底相结合的模型。因此，截面 $y(E)$ 的完整模型定义为：\n$$\ny(E; \\theta) = A \\frac{(\\Gamma/2)^2}{(E - E_R)^2 + (\\Gamma/2)^2} + B_0 + B_1 E\n$$\n参数向量为 $\\theta = (E_R, \\Gamma, A, B_0, B_1)$，其中 $E_R$ 是共振能量，$\\Gamma$ 是其半高全宽（FWHM），$A$ 是共振部分的峰值振幅，$B_0$ 和 $B_1$ 分别是线性本底的截距和斜率。\n\n**2. 加权非线性最小二乘拟合**\n\n任务是为一组给定的合成数据点 $\\{(E_i, y_i, \\sigma_i)\\}_{i=1}^N$ 找到最佳拟合参数 $\\hat{\\theta}$。这是通过最小化加权残差平方和，即卡方统计量 $\\chi^2$ 来实现的：\n$$\n\\chi^2(\\theta) = \\sum_{i=1}^N \\left(\\frac{y_i - y(E_i;\\theta)}{\\sigma_i}\\right)^2\n$$\n最小化此值是一个非线性最小二乘问题。该算法将利用 `scipy.optimize.curve_fit`，这是一个基于 Levenberg-Marquardt 算法的标准程序。每个测试案例的合成数据都是由模型本身生成，没有添加随机噪声，这意味着真实参数 $\\theta_{\\text{true}}$ 对应于 $\\chi^2(\\theta_{\\text{true}}) = 0$ 的全局最小值。拟合使用 $\\theta_{\\text{true}}$ 进行初始化，以确保立即且精确地收敛。将 `absolute_sigma=True` 参数传递给 `curve_fit` 以确保不确定度 $\\sigma_i$ 被视作绝对值，这对于输出协方差矩阵的正确缩放至关重要。\n\n**3. 参数协方差与可辨识性分析**\n\n最后一步是评估共振能量 $E_R$ 和宽度 $\\Gamma$ 的可辨识性。这是通过分析参数协方差矩阵 $\\mathrm{Cov}(\\hat{\\theta})$ 来完成的，该矩阵量化了最佳拟合参数的不确定度和相关性。在非线性最小二乘法中，该矩阵通过费雪信息矩阵的逆来近似。对于独立高斯误差，其形式为：\n$$\n\\mathrm{Cov}(\\hat{\\theta}) \\approx (J^\\top W J)^{-1}\n$$\n其中 $J$ 是模型关于参数的雅可比矩阵，$J_{ij} = \\frac{\\partial y(E_i;\\theta)}{\\partial \\theta_j}$，在最佳拟合解 $\\hat{\\theta}$ 处求值；$W$ 是对角权重矩阵，其元素为 $W_{ii} = 1/\\sigma_i^2$。带有 `absolute_sigma=True` 的 `curve_fit` 函数返回的正是这个矩阵。\n\n分析集中于 $\\mathrm{Cov}(\\hat{\\theta})$ 中对应于参数 $(E_R, \\Gamma)$ 的 $2 \\times 2$ 子矩阵 $C$：\n$$\nC = \\begin{pmatrix} \\mathrm{Var}(E_R) & \\mathrm{Cov}(E_R, \\Gamma) \\\\ \\mathrm{Cov}(\\Gamma, E_R) & \\mathrm{Var}(\\Gamma) \\end{pmatrix}\n$$\n从该子矩阵中计算两个度量：\na) **相关系数** $\\rho_{E_R,\\Gamma}$，它衡量 $E_R$ 和 $\\Gamma$ 估计量之间的线性相互依赖性：\n$$\n\\rho_{E_R,\\Gamma} = \\frac{C_{12}}{\\sqrt{C_{11}C_{22}}}\n$$\n$|\\rho_{E_R,\\Gamma}|$ 的值接近 1 表示强相关性，这使得区分这两个参数的影响变得困难。\n\nb) 协方差子矩阵 $C$ 的 **2-范数条件数** $\\kappa$，定义为 $\\kappa = \\|C\\|_2 \\|C^{-1}\\|_2$。对于像 $C$ 这样的对称正定矩阵，这是其最大特征值与最小特征值之比，即 $\\kappa = \\lambda_{\\max}/\\lambda_{\\min}$。大的条件数表明确定 $E_R$ 和 $\\Gamma$ 的问题是病态的，意味着数据中的小扰动可能导致参数估计值的大变化。\n\n最后，根据指定准则确定一个**可辨识性标志** $I$：如果 $|\\rho_{E_R,\\Gamma}| > 0.95$ 或 $\\kappa > 10^8$ 之一成立，则 $I$ 设置为 $\\mathrm{False}$，否则设置为 $\\mathrm{True}$。程序为提供的三个测试案例（每个案例代表一个不同的实验场景）实现了这一完整工作流程，并为每个案例输出结果元组 $[\\rho_{E_R,\\Gamma}, \\kappa, I]$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\nfrom numpy.linalg import cond\n\ndef solve():\n    \"\"\"\n    Performs a weighted nonlinear least-squares fit of a Breit-Wigner resonance model\n    to synthetic data and analyzes the parameter identifiability.\n    \"\"\"\n\n    # --- Model Definition and Justification ---\n    # In nuclear scattering, an isolated resonance can be described by the Breit-Wigner formula.\n    # This arises from parameterizing the S-matrix near a pole E_R - i*Gamma/2 on the complex energy plane,\n    # a consequence of a quasi-bound state with finite lifetime. For single-channel scattering,\n    # the cross-section exhibits a Lorentzian energy dependence. The phenomenological model used here\n    # combines a Lorentzian peak with a linear background, which is a common approach for analyzing\n    # experimental data. The model is:\n    # y(E) = A * (Gamma/2)^2 / ((E - E_R)^2 + (Gamma/2)^2) + B_0 + B_1 * E\n    # The parameters are theta = (E_R, Gamma, A, B_0, B_1).\n    def resonance_model(E, E_R, Gamma, A, B0, B1):\n        \"\"\"\n        Defines the resonance model: a Breit-Wigner-like Lorentzian plus a linear background.\n\n        Args:\n            E (float or array): Center-of-mass energy in MeV.\n            E_R (float): Resonance energy in MeV.\n            Gamma (float): Resonance total width in MeV.\n            A (float): Resonance amplitude in barns.\n            B0 (float): Background intercept in barns.\n            B1 (float): Background slope in barns/MeV.\n\n        Returns:\n            float or array: Cross section in barns.\n        \"\"\"\n        lorentzian = A * (Gamma / 2.0)**2 / ((E - E_R)**2 + (Gamma / 2.0)**2)\n        background = B0 + B1 * E\n        return lorentzian + background\n\n    test_cases = [\n        # Case 1: Well-sampled resonance, moderate background.\n        {\"params\": (5.0, 0.2, 10.0, 1.0, 0.2), \"m\": 8.0, \"N\": 121, \"sigma\": 0.05},\n        # Case 2: Narrow resonance with coarse sampling.\n        {\"params\": (5.0, 0.01, 10.0, 1.0, 0.2), \"m\": 6.0, \"N\": 21, \"sigma\": 0.05},\n        # Case 3: Limited window with strong background slope.\n        {\"params\": (5.0, 0.5, 5.0, 1.0, 5.0), \"m\": 2.0, \"N\": 41, \"sigma\": 0.05},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        p_true = case[\"params\"]\n        E_R_true, Gamma_true, _, _, _ = p_true\n        m, N, sigma_val = case[\"m\"], case[\"N\"], case[\"sigma\"]\n\n        # --- Step 1: Generate Synthetic Data ---\n        # The data is generated without noise, so y_i = y(E_i; theta_true).\n        E_min = E_R_true - m * Gamma_true\n        E_max = E_R_true + m * Gamma_true\n        E_data = np.linspace(E_min, E_max, N)\n        y_data = resonance_model(E_data, *p_true)\n        sigma_data = np.full_like(y_data, sigma_val)\n\n        # --- Step 2: Perform Weighted Nonlinear Least-Squares Fit ---\n        # We use the true parameters as the initial guess to ensure convergence\n        # to the exact solution, as the data is noise-free.\n        # 'absolute_sigma=True' is crucial. It ensures the covariance matrix pcov\n        # is calculated as (J^T W J)^-1, where W_ii = 1/sigma_i^2, as required.\n        try:\n            _, pcov = curve_fit(\n                resonance_model,\n                E_data,\n                y_data,\n                p0=p_true,\n                sigma=sigma_data,\n                absolute_sigma=True,\n                check_finite=True\n            )\n        except RuntimeError:\n            # In ill-conditioned cases, the fit might fail.\n            # Represent this scenario with NaN values.\n            all_results.append([np.nan, np.nan, False])\n            continue\n        \n        # --- Step 3: Analyze Parameter Covariance and Identifiability ---\n        # Extract the 2x2 covariance submatrix for (E_R, Gamma).\n        # The order of parameters is (E_R, Gamma, A, B0, B1).\n        C_ER_Gamma = pcov[0:2, 0:2]\n\n        # Compute the correlation coefficient rho_{E_R, Gamma}.\n        var_ER = C_ER_Gamma[0, 0]\n        var_Gamma = C_ER_Gamma[1, 1]\n        cov_ER_Gamma = C_ER_Gamma[0, 1]\n        \n        # Avoid division by zero if variances are zero or negative (numerical instability)\n        if var_ER == 0 or var_Gamma == 0:\n            rho = np.nan\n        else:\n            rho = cov_ER_Gamma / np.sqrt(var_ER * var_Gamma)\n\n        # Compute the 2-norm condition number kappa of the submatrix.\n        kappa = cond(C_ER_Gamma, 2)\n\n        # Determine the identifiability flag I based on the given criteria.\n        is_identifiable = not (np.abs(rho) > 0.95 or kappa > 1e8)\n\n        # Append results for this case. Ensure boolean is a native Python bool.\n        all_results.append([rho, kappa, bool(is_identifiable)])\n\n    # --- Final Output Formatting ---\n    # The output must be a single line: [[r1, c1, b1],[r2, c2, b2],...].\n    # The `str` representation of a list of lists matches this format.\n    formatted_results = \",\".join(map(str, all_results))\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本拟合方法的基础上，我们现在来解决一个关键的实际问题：数值稳定性。非线性最小二乘拟合有时可能会失败或收敛缓慢，这通常是由于问题本身的病态性（ill-conditioned）所致。本实践将通过检验雅可比矩阵及其条件数，深入探讨拟合过程的诊断方法。您将学习如何识别参数之间的潜在共线性，并探索如何通过参数缩放和使用先验进行正则化等标准技术，来显著提高拟合的稳定性和可靠性。",
            "id": "3596455",
            "problem": "给定一个用于描述单一核共振及多项式本底的非线性最小二乘模型，其中因变量是作为能量函数的截面。该模型假设观测数据点为 $\\{(E_i, y_i, \\sigma_i)\\}_{i=1}^N$，其中能量 $E_i$ 的单位为 $\\mathrm{MeV}$，截面 $y_i$ 的单位为 $\\mathrm{barn}$，测量不确定度 $\\sigma_i$ 的单位为 $\\mathrm{barn}$。参数模型是 Breit-Wigner 共振与多项式本底之和，\n$$\n\\hat{y}(E;\\boldsymbol{\\theta}) = A\\,S(E;E_0,\\Gamma) + \\sum_{k=0}^{m} c_k\\,x(E)^k,\n$$\n其中 $A$ 是共振振幅（单位 $\\mathrm{barn}$），$E_0$ 是共振中心（单位 $\\mathrm{MeV}$），$\\Gamma$ 是总宽度（单位 $\\mathrm{MeV}$），本底系数 $c_k$ 的单位为 $\\mathrm{barn}$。归一化本底基使用\n$$\nx(E) = \\frac{E - E_c}{E_s},\n$$\n其中 $E_c$ 为能量窗口的中心（单位 $\\mathrm{MeV}$），$E_s$ 为其半宽（单位 $\\mathrm{MeV}$），因此 $x(E) \\in [-1,1]$。非相对论性 Breit-Wigner 形状为\n$$\nS(E;E_0,\\Gamma) = \\frac{(\\Gamma/2)^2}{(E - E_0)^2 + (\\Gamma/2)^2}.\n$$\n\n考虑未加权最小二乘的残差向量，\n$$\n\\mathbf{r}(\\boldsymbol{\\theta}) = \\mathbf{y} - \\hat{\\mathbf{y}}(\\boldsymbol{\\theta}),\n$$\n及其雅可比矩阵 $J(\\boldsymbol{\\theta}) = \\partial \\mathbf{r}/\\partial \\boldsymbol{\\theta} \\in \\mathbb{R}^{N \\times P}$，其中 $P = m+4$ 是参数的数量。$J$ 的条件直接影响高斯-牛顿算法的收敛性。您的任务是计算雅可比矩阵，评估其条件，并研究缩放和简单高斯先验如何改善近似 Hessian 矩阵的条件和正定性。使用以下基本依据：\n\n- 最小二乘残差定义 $\\mathbf{r}(\\boldsymbol{\\theta}) = \\mathbf{y} - \\hat{\\mathbf{y}}(\\boldsymbol{\\theta})$。\n- 雅可比矩阵定义 $J(\\boldsymbol{\\theta}) = \\partial \\mathbf{r}/\\partial \\boldsymbol{\\theta}$。\n- 奇异值分解条件数 $\\kappa(J) = \\sigma_{\\max}(J)/\\sigma_{\\min}(J)$，其中 $\\sigma_{\\max}$、$\\sigma_{\\min}$ 分别是最大和最小奇异值。\n- 高斯-牛顿近似 Hessian 矩阵，对于未加权最小二乘为 $H \\approx J^\\top J$，对于加权最小二乘为 $H \\approx J_w^\\top J_w$，其中 $J_w = WJ$ 且 $W = \\mathrm{diag}(1/\\sigma_i)$。\n\n请从第一性原理出发，通过对 $\\hat{y}(E;\\boldsymbol{\\theta})$ 直接微分来计算雅可比矩阵的元素。不要假设任何已给定的捷径。然后：\n\n1. 在指定的初始猜测值 $\\boldsymbol{\\theta}_0$ 处计算未加权雅可比矩阵 $J(\\boldsymbol{\\theta})$ 及其对应的条件数 $\\kappa_{\\mathrm{raw}}$。\n2. 定义一个缩放后的雅可比矩阵 $J_{\\mathrm{scaled}} = W J C^{-1}$，其中 $W = \\mathrm{diag}(1/\\sigma_i)$ 用于白化残差，而 $C$ 是一个对角矩阵，其元素为 $WJ$ 的列范数，使得 $J_{\\mathrm{scaled}}$ 的每一列都具有单位欧几里得范数。计算 $\\kappa_{\\mathrm{scaled}}$。\n3. 为参数构建一个高斯先验精度矩阵 $\\Lambda = \\mathrm{diag}(\\lambda_j)$，其中各参数的先验是独立的：\n   - $A \\sim \\mathcal{N}(0, \\sigma_A^2)$，其中 $\\sigma_A = 10\\,\\mathrm{barn}$，因此 $\\lambda_A = 1/\\sigma_A^2$。\n   - $E_0 \\sim \\mathcal{N}(0, \\sigma_{E_0}^2)$，其中 $\\sigma_{E_0} = 0.5\\,\\mathrm{MeV}$，因此 $\\lambda_{E_0} = 1/\\sigma_{E_0}^2$。\n   - $\\Gamma \\sim \\mathcal{N}(0, \\sigma_{\\Gamma}^2)$，其中 $\\sigma_{\\Gamma} = 0.2\\,\\mathrm{MeV}$，因此 $\\lambda_{\\Gamma} = 1/\\sigma_{\\Gamma}^2$。\n   - $c_k \\sim \\mathcal{N}(0, \\sigma_{c,k}^2)$，其中 $\\sigma_{c,k} = \\sigma_c/(k+1)$，$\\sigma_c = 0.5\\,\\mathrm{barn}$，因此 $\\lambda_{c,k} = 1/\\sigma_{c,k}^2$。\n   评估未正则化的近似 Hessian 矩阵 $H_0 = J^\\top J$ 的最小特征值，并报告其是否严格为正（布尔值），以及正则化的近似 Hessian 矩阵 $H_{\\mathrm{prior}} = J_w^\\top J_w + \\Lambda$ 的最小特征值，并报告其是否严格为正（布尔值）。在相应的参数单位下，使用严格正性阈值 $\\varepsilon = 10^{-12}$。\n\n设计一个程序，对以下测试用例集执行上述计算。每个案例指定了能量窗口与采样、用于生成合成数据（尽管雅可比矩阵仅依赖于当前的参数值，但这样做是为了真实性）的真实参数，以及评估雅可比矩阵时使用的初始猜测值 $\\boldsymbol{\\theta}_0$。所有能量单位必须是 $\\mathrm{MeV}$，宽度单位是 $\\mathrm{MeV}$，截面和本底系数单位是 $\\mathrm{barn}$。\n\n- 案例 1（理想情况，良态）：\n  - 能量窗口：$E \\in [3,7]\\,\\mathrm{MeV}$，在 $N=200$ 个等间距点上采样。\n  - 真实参数：$E_0 = 5\\,\\mathrm{MeV}$，$\\Gamma = 0.5\\,\\mathrm{MeV}$，$A = 2.0\\,\\mathrm{barn}$，多项式阶数 $m=2$，$c_0 = 0.5\\,\\mathrm{barn}$，$c_1 = 0.1\\,\\mathrm{barn}$，$c_2 = -0.02\\,\\mathrm{barn}$。\n  - 测量不确定度：对于所有 $i$，$\\sigma_i = 0.02\\,\\mathrm{barn}$。\n  - 初始猜测值：$E_0^{(0)} = 5.1\\,\\mathrm{MeV}$，$\\Gamma^{(0)} = 0.55\\,\\mathrm{MeV}$，$A^{(0)} = 1.8\\,\\mathrm{barn}$，对于所有 $k$，$c_k^{(0)} = c_k$。\n\n- 案例 2（边界情况，非常窄的宽度，可能存在欠采样）：\n  - 能量窗口：$E \\in [4.8,5.2]\\,\\mathrm{MeV}$，在 $N=100$ 个等间距点上采样。\n  - 真实参数：$E_0 = 5.0\\,\\mathrm{MeV}$，$\\Gamma = 0.05\\,\\mathrm{MeV}$，$A = 2.0\\,\\mathrm{barn}$，多项式阶数 $m=2$，$c_0 = 0.5\\,\\mathrm{barn}$，$c_1 = 0.1\\,\\mathrm{barn}$，$c_2 = -0.02\\,\\mathrm{barn}$。\n  - 测量不确定度：对于所有 $i$，$\\sigma_i = 0.02\\,\\mathrm{barn}$。\n  - 初始猜测值：$E_0^{(0)} = 5.02\\,\\mathrm{MeV}$，$\\Gamma^{(0)} = 0.06\\,\\mathrm{MeV}$，$A^{(0)} = 1.9\\,\\mathrm{barn}$，对于所有 $k$，$c_k^{(0)} = c_k$。\n\n- 案例 3（边缘情况，具有潜在共线性的高阶本底）：\n  - 能量窗口：$E \\in [0,10]\\,\\mathrm{MeV}$，在 $N=300$ 个等间距点上采样。\n  - 真实参数：$E_0 = 5.0\\,\\mathrm{MeV}$，$\\Gamma = 0.3\\,\\mathrm{MeV}$，$A = 1.5\\,\\mathrm{barn}$，多项式阶数 $m=5$，$c_0 = 0.3\\,\\mathrm{barn}$，$c_1 = -0.15\\,\\mathrm{barn}$，$c_2 = 0.05\\,\\mathrm{barn}$，$c_3 = -0.02\\,\\mathrm{barn}$，$c_4 = 0.01\\,\\mathrm{barn}$，$c_5 = -0.005\\,\\mathrm{barn}$。\n  - 测量不确定度：对于所有 $i$，$\\sigma_i = 0.03\\,\\mathrm{barn}$。\n  - 初始猜测值：$E_0^{(0)} = 5.2\\,\\mathrm{MeV}$，$\\Gamma^{(0)} = 0.27\\,\\mathrm{MeV}$，$A^{(0)} = 1.35\\,\\mathrm{barn}$，对于所有 $k$，$c_k^{(0)} = c_k$。\n\n- 案例 4（边缘情况，被本底掩盖的低振幅共振）：\n  - 能量窗口：$E \\in [3,7]\\,\\mathrm{MeV}$，在 $N=200$ 个等间距点上采样。\n  - 真实参数：$E_0 = 5.0\\,\\mathrm{MeV}$，$\\Gamma = 0.5\\,\\mathrm{MeV}$，$A = 0.1\\,\\mathrm{barn}$，多项式阶数 $m=2$，$c_0 = 0.5\\,\\mathrm{barn}$，$c_1 = 0.1\\,\\mathrm{barn}$，$c_2 = -0.02\\,\\mathrm{barn}$。\n  - 测量不确定度：对于所有 $i$，$\\sigma_i = 0.02\\,\\mathrm{barn}$。\n  - 初始猜测值：$E_0^{(0)} = 5.1\\,\\mathrm{MeV}$，$\\Gamma^{(0)} = 0.55\\,\\mathrm{MeV}$，$A^{(0)} = 0.12\\,\\mathrm{barn}$，对于所有 $k$，$c_k^{(0)} = c_k$。\n\n对于每个案例，您的程序必须计算并返回一个列表，其中包含：\n- $\\kappa_{\\mathrm{raw}}$ (浮点数),\n- $\\kappa_{\\mathrm{scaled}}$ (浮点数),\n- 改善比率 $\\rho = \\kappa_{\\mathrm{raw}}/\\kappa_{\\mathrm{scaled}}$ (浮点数),\n- 一个布尔值，指示是否 $\\min\\operatorname{eig}(H_0) > \\varepsilon$,\n- 一个布尔值，指示是否 $\\min\\operatorname{eig}(H_{\\mathrm{prior}}) > \\varepsilon$。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个案例的结果，格式为一个由四个子列表组成的逗号分隔列表，每个子列表按上述规定格式化并用方括号括起来，不含空格（例如，$\\big[\\,[1.0,0.5,2.0,\\mathrm{True},\\mathrm{True}],\\ldots\\,\\big]$）。$\\kappa_{\\mathrm{raw}}$、$\\kappa_{\\mathrm{scaled}}$ 和 $\\rho$ 的值是无量纲浮点数。正定性布尔值必须是精确的逻辑值。在内部以以上提供的单位表示所有物理量；输出如规定为无单位或布尔值。",
            "solution": "该问题要求对一个核共振非线性最小二乘模型的雅可比矩阵的条件进行分析。该分析涉及在给定的参数猜测值下计算雅可比矩阵，评估其在有无缩放情况下的条件数，并评估相应的近似 Hessian 矩阵在有无源自高斯先验的 Tikhonov 正则化的情况下的正定性。\n\n截面 $\\hat{y}$ 作为能量 $E$ 的函数的参数模型由 Breit-Wigner 共振项和多项式本底项的和给出：\n$$\n\\hat{y}(E;\\boldsymbol{\\theta}) = A\\,S(E;E_0,\\Gamma) + \\sum_{k=0}^{m} c_k\\,x(E)^k\n$$\n大小为 $P=m+4$ 的参数向量 $\\boldsymbol{\\theta}$ 由共振振幅 $A$、共振能量 $E_0$、共振宽度 $\\Gamma$ 以及 $m+1$ 个本底系数 $\\{c_k\\}_{k=0}^m$ 组成。我们将参数向量排序为 $\\boldsymbol{\\theta} = [A, E_0, \\Gamma, c_0, c_1, \\dots, c_m]^\\top$。\n\nBreit-Wigner 线形函数 $S(E;E_0,\\Gamma)$ 定义为：\n$$\nS(E;E_0,\\Gamma) = \\frac{(\\Gamma/2)^2}{(E - E_0)^2 + (\\Gamma/2)^2}\n$$\n本底多项式以归一化基 $x(E)$ 表示：\n$$\nx(E) = \\frac{E - E_c}{E_s}\n$$\n其中 $E_c$ 是能量区间的中心，$E_s$ 是其半宽，确保在拟合窗口内 $x(E) \\in [-1,1]$。\n\n对于一组 $N$ 个能量点 $\\{E_i\\}_{i=1}^N$，最小二乘问题旨在最小化残差平方和。残差向量为 $\\mathbf{r}(\\boldsymbol{\\theta}) = \\mathbf{y} - \\hat{\\mathbf{y}}(\\boldsymbol{\\theta})$，其中 $\\mathbf{y}$ 是观测截面向量，$\\hat{\\mathbf{y}}(\\boldsymbol{\\theta})$ 是模型预测向量。残差向量的雅可比矩阵是高斯-牛顿等迭代求解器中的关键组成部分。其定义为：\n$$\nJ(\\boldsymbol{\\theta}) = \\frac{\\partial \\mathbf{r}(\\boldsymbol{\\theta})}{\\partial \\boldsymbol{\\theta}} = - \\frac{\\partial \\hat{\\mathbf{y}}(\\boldsymbol{\\theta})}{\\partial \\boldsymbol{\\theta}}\n$$\n元素 $J_{ij}$ 对应于第 $i$ 个残差对第 $j$ 个参数的偏导数，在 $E_i$ 处求值。我们从第一性原理计算这些导数。\n\n$\\hat{y}(E; \\boldsymbol{\\theta})$ 对各参数的偏导数如下：\n1.  对振幅 $A$ 的导数：\n    $$ \\frac{\\partial \\hat{y}}{\\partial A} = S(E;E_0,\\Gamma) $$\n2.  对共振能量 $E_0$ 的导数：\n    $$ \\frac{\\partial \\hat{y}}{\\partial E_0} = A \\frac{\\partial S}{\\partial E_0} = A \\left( (\\Gamma/2)^2 \\frac{-1}{((E-E_0)^2+(\\Gamma/2)^2)^2} (2(E-E_0)(-1)) \\right) = A \\frac{2(E-E_0)(\\Gamma/2)^2}{((E-E_0)^2+(\\Gamma/2)^2)^2} $$\n3.  对共振宽度 $\\Gamma$ 的导数：\n    $$ \\frac{\\partial \\hat{y}}{\\partial \\Gamma} = A \\frac{\\partial S}{\\partial \\Gamma} = A \\frac{ \\frac{\\partial}{\\partial\\Gamma}((\\Gamma/2)^2) \\cdot ((E-E_0)^2+(\\Gamma/2)^2) - (\\Gamma/2)^2 \\cdot \\frac{\\partial}{\\partial\\Gamma}((E-E_0)^2+(\\Gamma/2)^2) }{ ((E-E_0)^2+(\\Gamma/2)^2)^2 } $$\n    $$ \\frac{\\partial \\hat{y}}{\\partial \\Gamma} = A \\frac{ (\\Gamma/2) \\cdot ((E-E_0)^2+(\\Gamma/2)^2) - (\\Gamma/2)^2 \\cdot (\\Gamma/2) }{ ((E-E_0)^2+(\\Gamma/2)^2)^2 } = A \\frac{(\\Gamma/2)(E-E_0)^2}{((E-E_0)^2+(\\Gamma/2)^2)^2} $$\n4.  对本底系数 $c_k$ 的导数：\n    $$ \\frac{\\partial \\hat{y}}{\\partial c_k} = \\frac{\\partial}{\\partial c_k} \\sum_{j=0}^{m} c_j\\,x(E)^j = x(E)^k $$\n\n雅可比矩阵 $J$ 的列是在特定参数猜测值 $\\boldsymbol{\\theta}_0$ 下，使用这些表达式在每个能量点 $E_i$ 和对 $\\boldsymbol{\\theta}_0$ 中的每个参数求值的负值来构建的。\n\n第一个任务是计算这个未加权雅可比矩阵 $J$ 的条件数 $\\kappa_{\\mathrm{raw}}$。它由其最大奇异值与最小奇异值的比值给出：$\\kappa_{\\mathrm{raw}}(J) = \\sigma_{\\max}(J) / \\sigma_{\\min}(J)$。大的条件数表明最小二乘问题是病态的。\n\n第二个任务是通过缩放来改善相关的条件数。我们定义一个加权雅可比矩阵 $J_w = WJ$，其中 $W = \\mathrm{diag}(1/\\sigma_i)$ 是一个由测量不确定度倒数构成的对角矩阵。这个变换等价于白化残差。进一步对 $J_w$ 的列应用缩放。我们定义一个对角矩阵 $C$，其对角元素 $C_{jj}$ 是 $J_w$ 各列的欧几里得范数，即 $C_{jj} = \\|(J_w)_{:,j}\\|_2$。完全缩放后的雅可比矩阵是 $J_{\\mathrm{scaled}} = J_w C^{-1}$。根据构造，$J_{\\mathrm{scaled}}$ 的每一列都具有单位欧几里得范数。然后我们计算其条件数 $\\kappa_{\\mathrm{scaled}}$，这通常比 $\\kappa_{\\mathrm{raw}}$ 有很大改善。改善程度由比率 $\\rho = \\kappa_{\\mathrm{raw}} / \\kappa_{\\mathrm{scaled}}$ 来量化。\n\n第三个任务涉及 Hessian 矩阵的高斯-牛顿近似。对于未加权最小二乘，这是 $H_0 \\approx J^\\top J$。为使算法稳定，$H_0$ 必须是正定的。我们通过计算其特征值并验证最小特征值是否严格为正来检查这一点，即 $\\min\\operatorname{eig}(H_0) > \\varepsilon$，其中 $\\varepsilon = 10^{-12}$ 是一个小阈值。\n当 $H_0$ 是病态或奇异的时，可以引入正则化。对参数使用高斯先验会导致一个正则化的或最大后验 (MAP) 估计问题。相应目标函数的 Hessian 矩阵近似为 $H_{\\mathrm{prior}} = J_w^\\top J_w + \\Lambda$，其中 $\\Lambda$ 是先验精度矩阵（先验协方差矩阵的逆）。对于指定的独立高斯先验，$\\Lambda = \\mathrm{diag}(\\lambda_j)$，其中 $\\lambda_j = 1/\\sigma_j^2$，$\\sigma_j$ 是参数 $\\theta_j$ 先验的标准差。具体值为 $\\lambda_A = 1/\\sigma_A^2 = 1/10^2 = 0.01$，$\\lambda_{E_0} = 1/\\sigma_{E_0}^2 = 1/0.5^2 = 4$，$\\lambda_{\\Gamma} = 1/\\sigma_{\\Gamma}^2 = 1/0.2^2 = 25$，以及 $\\lambda_{c,k} = 1/\\sigma_{c,k}^2 = ((k+1)/\\sigma_c)^2 = (2(k+1))^2$ (其中 $\\sigma_c=0.5$)。将对角正定矩阵 $\\Lambda$ 加到半正定的 $J_w^\\top J_w$ 上，通常能确保得到的正则化 Hessian 矩阵 $H_{\\mathrm{prior}}$ 是严格正定的。我们通过检查是否 $\\min\\operatornameoperatorname{eig}(H_{\\mathrm{prior}}) > \\varepsilon$ 来验证这一点。\n\n每个测试用例的计算步骤如下：\n1.  设置能量网格 $\\{E_i\\}$ 和初始参数猜测值 $\\boldsymbol{\\theta}_0$。\n2.  使用在 $\\boldsymbol{\\theta}_0$ 处求值的派生偏导数，构建 $N \\times P$ 的未加权雅可比矩阵 $J$。\n3.  计算 $\\kappa_{\\mathrm{raw}} = \\operatorname{cond}(J)$。\n4.  构建加权矩阵 $W$ 和加权雅可比矩阵 $J_w = WJ$。\n5.  计算 $J_w$ 的列范数以形成对角矩阵 $C$。\n6.  构建缩放后的雅可比矩阵 $J_{\\mathrm{scaled}} = J_w C^{-1}$ 并计算 $\\kappa_{\\mathrm{scaled}} = \\operatorname{cond}(J_{\\mathrm{scaled}})$。\n7.  计算改善比率 $\\rho = \\kappa_{\\mathrm{raw}} / \\kappa_{\\mathrm{scaled}}$。\n8.  计算未正则化的 Hessian 矩阵 $H_0 = J^\\top J$ 并确定其最小特征值是否大于 $\\varepsilon = 10^{-12}$。\n9.  构建先验精度矩阵 $\\Lambda$。\n10. 计算正则化的 Hessian 矩阵 $H_{\\mathrm{prior}} = J_w^\\top J_w + \\Lambda$ 并确定其最小特征值是否大于 $\\varepsilon = 10^{-12}$。\n11. 收集这五项结果：$\\kappa_{\\mathrm{raw}}$、$\\kappa_{\\mathrm{scaled}}$、$\\rho$ 以及两个表示正定性的布尔值。\n对所有四个指定的测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the final result.\n    \"\"\"\n    \n    # Test cases defined as a list of dictionaries.\n    test_cases = [\n        {\n            \"E_range\": (3.0, 7.0), \"N\": 200, \"m\": 2,\n            \"sigma\": 0.02,\n            \"theta0\": np.array([1.8, 5.1, 0.55, 0.5, 0.1, -0.02])\n        },\n        {\n            \"E_range\": (4.8, 5.2), \"N\": 100, \"m\": 2,\n            \"sigma\": 0.02,\n            \"theta0\": np.array([1.9, 5.02, 0.06, 0.5, 0.1, -0.02])\n        },\n        {\n            \"E_range\": (0.0, 10.0), \"N\": 300, \"m\": 5,\n            \"sigma\": 0.03,\n            \"theta0\": np.array([1.35, 5.2, 0.27, 0.3, -0.15, 0.05, -0.02, 0.01, -0.005])\n        },\n        {\n            \"E_range\": (3.0, 7.0), \"N\": 200, \"m\": 2,\n            \"sigma\": 0.02,\n            \"theta0\": np.array([0.12, 5.1, 0.55, 0.5, 0.1, -0.02])\n        }\n    ]\n\n    # Prior definitions\n    prior_params = {\n        \"sigma_A\": 10.0,\n        \"sigma_E0\": 0.5,\n        \"sigma_Gamma\": 0.2,\n        \"sigma_c\": 0.5\n    }\n\n    epsilon = 1e-12\n    \n    results = []\n    for case in test_cases:\n        result = process_case(case, prior_params, epsilon)\n        results.append(result)\n\n    # Format output to be a list of lists string with no spaces.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef get_jacobian(E, theta0, m, E_c, E_s):\n    \"\"\"\n    Computes the Jacobian matrix for the given model.\n    J = -d(y_hat)/d(theta)\n    \"\"\"\n    N = len(E)\n    P = m + 4\n    J = np.zeros((N, P))\n    \n    A, E0, Gamma = theta0[0], theta0[1], theta0[2]\n    \n    # Breit-Wigner common terms\n    G2 = Gamma / 2.0\n    G2_sq = G2**2\n    E_minus_E0 = E - E0\n    E_minus_E0_sq = E_minus_E0**2\n    den = E_minus_E0_sq + G2_sq\n    den_sq = den**2\n    \n    # Column for A\n    # d(y_hat)/dA = S(E)\n    S = G2_sq / den\n    J[:, 0] = -S\n    \n    # Column for E0\n    # d(y_hat)/dE0 = A * 2 * (E - E0) * (Gamma/2)^2 / ((E-E0)^2 + (Gamma/2)^2)^2\n    J[:, 1] = -A * 2 * E_minus_E0 * G2_sq / den_sq\n    \n    # Column for Gamma\n    # d(y_hat)/dGamma = A * (Gamma/2) * (E-E0)^2 / ((E-E0)^2 + (Gamma/2)^2)^2\n    J[:, 2] = -A * G2 * E_minus_E0_sq / den_sq\n    \n    # Columns for c_k\n    # d(y_hat)/dc_k = x(E)^k\n    x = (E - E_c) / E_s\n    for k in range(m + 1):\n        J[:, 3 + k] = -np.power(x, k)\n        \n    return J\n\ndef process_case(case_params, prior_params, epsilon):\n    \"\"\"\n    Processes a single test case to compute all required values.\n    \"\"\"\n    E_min, E_max = case_params[\"E_range\"]\n    N = case_params[\"N\"]\n    m = case_params[\"m\"]\n    sigma = case_params[\"sigma\"]\n    theta0 = case_params[\"theta0\"]\n    \n    E = np.linspace(E_min, E_max, N)\n    E_c = (E_max + E_min) / 2.0\n    E_s = (E_max - E_min) / 2.0\n    \n    # 1. Unweighted Jacobian and condition number\n    J = get_jacobian(E, theta0, m, E_c, E_s)\n    kappa_raw = np.linalg.cond(J)\n    \n    # 2. Scaled Jacobian and condition number\n    W = np.diag(np.full(N, 1.0/sigma))\n    J_w = W @ J\n    \n    col_norms = np.linalg.norm(J_w, axis=0)\n    # Handle potential zero columns to avoid division by zero\n    col_norms[col_norms == 0] = 1.0\n    C_inv = np.diag(1.0 / col_norms)\n    \n    J_scaled = J_w @ C_inv\n    kappa_scaled = np.linalg.cond(J_scaled)\n    \n    improvement_ratio = kappa_raw / kappa_scaled if kappa_scaled > 0 else float('inf')\n\n    # 3. Hessian analysis\n    # Unregularized Hessian H0\n    H0 = J.T @ J\n    eigvals_H0 = np.linalg.eigvalsh(H0)\n    is_H0_pos_def = bool(np.min(eigvals_H0) > epsilon)\n    \n    # Regularized Hessian H_prior\n    sigma_A = prior_params[\"sigma_A\"]\n    sigma_E0 = prior_params[\"sigma_E0\"]\n    sigma_Gamma = prior_params[\"sigma_Gamma\"]\n    sigma_c = prior_params[\"sigma_c\"]\n    \n    lambda_A = 1.0 / sigma_A**2\n    lambda_E0 = 1.0 / sigma_E0**2\n    lambda_Gamma = 1.0 / sigma_Gamma**2\n    lambda_c = [((k + 1) / sigma_c)**2 for k in range(m + 1)]\n    \n    Lambda_diag = np.concatenate(([lambda_A, lambda_E0, lambda_Gamma], lambda_c))\n    Lambda = np.diag(Lambda_diag)\n    \n    H_prior = J_w.T @ J_w + Lambda\n    eigvals_H_prior = np.linalg.eigvalsh(H_prior)\n    is_H_prior_pos_def = bool(np.min(eigvals_H_prior) > epsilon)\n    \n    return [kappa_raw, kappa_scaled, improvement_ratio, is_H0_pos_def, is_H_prior_pos_def]\n    \n\n# The problem defines a specific program structure. Calling solve() will execute it.\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "简单的Breit-Wigner模型虽然有用，但它是一个近似，在强相互作用或重叠共振的情况下可能会因违反幺正性这一基本原理而失效。本实践介绍了一种更严谨、更强大的方法：K矩阵形式（K-matrix formalism）。您将亲手实现这一幺正化方案，观察它如何在适当的极限下自然地产生我们熟悉的Breit-Wigner线型，并理解它如何为描述复杂的共振结构提供一个稳定且物理上合理的框架。",
            "id": "3596485",
            "problem": "要求您通过一个实值$K$矩阵，为能量为$E$的本底加极点模型实现单通道弹性散射的幺正化，并演示从$K(E)$到散射矩阵的映射如何展现类布莱特-维格纳行为，同时在存在重叠结构时稳定描述。请在约化单位下进行，其中相空间因子为常数$1$（无量纲），并将散射振幅视为无量纲。能量必须以兆电子伏（$\\mathrm{MeV}$）表示。您的程序必须生成单行输出，其中包含指定测试套件的结果，格式为方括号括起来的逗号分隔列表。\n\n从单通道弹性散射的基本原理出发：\n\n- 散射矩阵（S矩阵）在阈值以上的实能量下是幺正的，因此其形式为 $S(E)=e^{2 i \\delta(E)}$，其中$\\delta(E)$是实相移。\n- 必须构建分波散射振幅$T(E)$，使其满足幺正性，并且对于足够小的实相互作用强度，$T(E)$趋向于该实相互作用强度。\n\n利用这些原理，推导一个唯一的代数映射，该映射将一个实值$K$矩阵$K(E)$转换为一个幺正$S$矩阵$S(E)$和相应的振幅$T(E)$，该振幅在小量级时与$K(E)$匹配，并强制满足精确的单通道幺正性。在推导过程中，不要假设$K(E)$的任何特定形式；仅使用幺正性条件和弱相互作用极限来确定该映射。\n\n然后为$K$矩阵实现以下本底加极点模型：\n$$\nK(E) \\;=\\; a \\;+\\; b \\,\\big(E - E_{\\mathrm{ref}}\\big) \\;+\\; \\sum_{i=1}^{N} \\frac{g_i}{E_i - E}\\,,\n$$\n其中$a$和$b$是实值本底参数，$E_{\\mathrm{ref}}$是一个固定的参考能量，极点参数为$\\{(E_i,g_i)\\}_{i=1}^{N}$，其中$E_i$是极点能量，$g_i$是具有能量量纲的正实数。所有能量都必须以$\\mathrm{MeV}$为单位提供，在所选的约化单位中，$K(E)$是无量纲的。\n\n为了参考和数值比较，还需定义一个朴素的非幺正振幅，即取$T_{\\mathrm{naive}}(E) := K(E)$和$S_{\\mathrm{naive}}(E) := 1 + 2 i \\, K(E)$。\n\n您的程序必须：\n\n- 推导并实现从$K(E)$到$S(E)$和$T(E)$的幺正化映射，其方式需能对实数$E$精确地强制执行单通道幺正性。\n- 为上述本底加极点模型实现$K(E)$。\n- 在指定的均匀能量格点上评估以下测试套件。通过处理或排除与$E_i$完全重合的能量来避免数值溢出或除零错误；所有运算必须保持稳健且有限。\n\n度量指标中使用的定义：\n\n- 令$I(E) := |T(E)|^2$，该值为无量纲。\n- 将$I(E)$中单个主导峰的半峰全宽（FWHM）定义为$I(E)$等于其最大值一半的两个能量点之差，如果需要，可在格点之间使用线性插值。\n- 将幺正性偏差定义为在格点上$\\max_{E}\\big||S(E)| - 1\\big|$。\n- 将稳定化比率定义为\n$$\nR \\;=\\; \\frac{\\max_{E} |K(E)|}{\\max_{E} |T(E)|}\\,,\n$$\n其中最大值是在评估格点上排除任何未定义或无穷大值后取。\n\n测试套件：\n\n1. 带有弱本底的孤立极点（类布莱特-维格纳线型）：\n   - 参数：$a = 0.02$, $b = 0$, $E_{\\mathrm{ref}} = 1500\\,\\mathrm{MeV}$，一个极点$(E_1,g_1)=(1500\\,\\mathrm{MeV}, 25\\,\\mathrm{MeV})$。\n   - 格点：$E \\in [1450\\,\\mathrm{MeV}, 1550\\,\\mathrm{MeV}]$，均匀间距为$\\Delta E = 0.2\\,\\mathrm{MeV}$。\n   - 要求的度量指标：数值提取的$I(E)$的$\\mathrm{FWHM}$与期望宽度$2 g_1$之间的相对误差，即：\n     $$\n     \\varepsilon_{\\Gamma} \\;=\\; \\frac{\\big|\\mathrm{FWHM} - 2 g_1\\big|}{2 g_1}\\,,\n     $$\n     以浮点数形式报告。\n\n2. 两个重叠的极点（幺正性与稳定化）：\n   - 参数：$a = 0.1$, $b = 0$, $E_{\\mathrm{ref}} = 1000\\,\\mathrm{MeV}$，两个极点$(E_1,g_1)=(1000\\,\\mathrm{MeV}, 60\\,\\mathrm{MeV})$和$(E_2,g_2)=(1040\\,\\mathrm{MeV}, 40\\,\\mathrm{MeV})$。\n   - 格点：$E \\in [900\\,\\mathrm{MeV}, 1100\\,\\mathrm{MeV}]$，均匀间距为$\\Delta E = 0.2\\,\\mathrm{MeV}$。\n   - 要求的度量指标：\n     - 幺正性偏差$\\max_{E}\\big||S(E)| - 1\\big|$，以浮点数形式报告。\n     - 如上定义的稳定化比率$R$，以浮点数形式报告。\n\n3. 带有斜坡本底的强重叠极点（由干涉和本底引起的峰位移动）：\n   - 参数：$a = 0.2$, $b = 0.001\\,\\mathrm{MeV}^{-1}$, $E_{\\mathrm{ref}} = 1300\\,\\mathrm{MeV}$，两个极点$(E_1,g_1)=(1300\\,\\mathrm{MeV}, 70\\,\\mathrm{MeV})$和$(E_2,g_2)=(1320\\,\\mathrm{MeV}, 60\\,\\mathrm{MeV})$。\n   - 格点：$E \\in [1200\\,\\mathrm{MeV}, 1400\\,\\mathrm{MeV}]$，均匀间距为$\\Delta E = 0.2\\,\\mathrm{MeV}$。\n   - 要求的度量指标：$E_1$附近主导峰的移动，定义为$\\Delta E_{\\mathrm{peak}} = E_{\\mathrm{peak}} - E_1$，其中$E_{\\mathrm{peak}}$是在窗口$[E_1 - 50\\,\\mathrm{MeV}, E_1 + 50\\,\\mathrm{MeV}]$内$I(E)$的局部最大值的位置（在格点上，如果需要，可通过在最大值周围进行局部线性插值来进行亚格点精化）。以$\\mathrm{MeV}$为单位，将$\\Delta E_{\\mathrm{peak}}$报告为浮点数。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，顺序如下：\n  - 测试 $1$：浮点数$\\varepsilon_{\\Gamma}$。\n  - 测试 $2$：浮点数幺正性偏差，后跟浮点数稳定化比率$R$。\n  - 测试 $3$：以$\\mathrm{MeV}$为单位的浮点数峰位移动$\\Delta E_{\\mathrm{peak}}$。\n- 例如：[$x_1,x_2,x_3,x_4$]，其中每个$x_i$都是一个浮点数。所有计算都必须使用以$\\mathrm{MeV}$为单位的能量，并且除最后一个必须以$\\mathrm{MeV}$为单位外，所有报告的量都是无量纲的。",
            "solution": "用户提供了一个计算核物理领域的问题，涉及使用K矩阵形式理论对散射振幅进行幺正化。该问题在科学上根据充分，内容自洽，且算法上已明确指定。它是散射理论中一个标准且有效的练习。\n\n该问题要求从一个实值K矩阵$K(E)$推导出到幺正单通道S矩阵$S(E)$及其相应散射振幅$T(E)$的映射。此推导必须基于基本原理。随后，该形式理论将应用于一个特定的本底加极点模型$K(E)$，并为定义的测试用例计算若干数值度量。\n\n我们从推导开始。\n\n在单通道弹性散射中，关联散射过程的初态和末态的S矩阵是能量的复函数$S(E)$。对于高于产生阈值的实能量$E$，概率流守恒要求S矩阵是幺正的。对于单通道，这意味着$S(E)^{\\dagger}S(E) = |S(E)|^2 = 1$。这表明$S(E)$可以由一个单一的实数量，即相移$\\delta(E)$，参数化为$S(E) = e^{2i\\delta(E)}$。\n\n散射振幅$T(E)$与S矩阵相关。在问题指定的归一化中，相空间因子$\\rho(E)$被设为常数值$1$，它们的关系是：\n$$\nS(E) = 1 + 2iT(E)\n$$\n$S(E)$的幺正性对$T(E)$施加了一个约束。将$S(E)$的表达式代入幺正性条件$|S(E)|^2 = 1$中：\n$$\n|1 + 2iT(E)|^2 = 1\n$$\n$$\n(1 - 2iT(E)^{\\dagger})(1 + 2iT(E)) = 1\n$$\n$$\n1 + 2iT(E) - 2iT(E)^{\\dagger} + 4T(E)^{\\dagger}T(E) = 1\n$$\n$$\n2i(T(E) - T(E)^{\\dagger}) + 4|T(E)|^2 = 0\n$$\n由于$T - T^{\\dagger} = 2i\\,\\mathrm{Im}(T)$，这简化为：\n$$\n-4\\,\\mathrm{Im}(T(E)) + 4|T(E)|^2 = 0\n$$\n$$\n\\mathrm{Im}(T(E)) = |T(E)|^2\n$$\n这就是单通道幺正性条件，在这种归一化下也称为光学定理。\n\nK矩阵$K(E)$被引入作为一个参数化相互作用的实对称矩阵（对于多通道情况）。对于单通道，$K(E)$是实能量的实值函数。问题要求，在小相互作用强度的极限下，得到的散射振幅$T(E)$必须简化为$K(E)$，即当$|K(E)| \\ll 1$时，$T(E) \\approx K(E)$。\n\n为了找到从$K(E)$到$T(E)$的映射，我们寻求一个函数形式$T(K)$，它满足两个条件：$\\mathrm{Im}(T) = |T|^2$和在$K$很小时$T \\approx K$。一个常用且成功的拟设是将T矩阵的逆与K矩阵的逆关联起来：\n$$\nT(E)^{-1} = K(E)^{-1} - i\n$$\n求解$T(E)$：\n$$\nT(E) = \\left(K(E)^{-1} - i\\right)^{-1} = \\left(\\frac{1 - iK(E)}{K(E)}\\right)^{-1} = \\frac{K(E)}{1 - iK(E)}\n$$\n我们来验证此映射是否满足所需条件。\n1.  **弱相互作用极限**：如果$|K(E)| \\ll 1$，分母$(1 - iK(E)) \\approx 1$。因此，$T(E) \\approx K(E)$，满足条件。\n2.  **幺正性**：我们检查是否$\\mathrm{Im}(T) = |T|^2$。首先，我们将$T(E)$的表达式进行有理化：\n    $$\n    T(E) = \\frac{K(E)}{1 - iK(E)} \\cdot \\frac{1 + iK(E)}{1 + iK(E)} = \\frac{K(E) + iK(E)^2}{1 + K(E)^2}\n    $$\n    虚部是$\\mathrm{Im}(T(E)) = \\frac{K(E)^2}{1 + K(E)^2}$。\n    模的平方是$|T(E)|^2 = \\left|\\frac{K(E)}{1 - iK(E)}\\right|^2 = \\frac{|K(E)|^2}{|1 - iK(E)|^2} = \\frac{K(E)^2}{1^2 + (-K(E))^2} = \\frac{K(E)^2}{1 + K(E)^2}$。\n    由于$\\mathrm{Im}(T(E)) = |T(E)|^2$，该映射正确地强制执行了单通道幺正性。\n\nS矩阵现在可以用$K(E)$表示：\n$$\nS(E) = 1 + 2iT(E) = 1 + 2i\\frac{K(E)}{1 - iK(E)} = \\frac{1 - iK(E) + 2iK(E)}{1 - iK(E)} = \\frac{1 + iK(E)}{1 - iK(E)}\n$$\n这种形式使幺正性显而易见，因为对于实数$K(E)$，分子是分母的复共轭，所以$|S(E)|=1$。\n\n对于一个无本底的单极点K矩阵$K(E) = \\frac{g_1}{E_1 - E}$，其与布莱特-维格纳共振形式的联系是显而易见的。将此代入$T(E)$的公式中：\n$$\nT(E) = \\frac{\\frac{g_1}{E_1 - E}}{1 - i\\frac{g_1}{E_1 - E}} = \\frac{g_1}{(E_1 - E) - ig_1}\n$$\n强度$I(E) = |T(E)|^2$则为：\n$$\nI(E) = \\frac{g_1^2}{(E_1 - E)^2 + g_1^2}\n$$\n这是标准的布莱特-维格纳线型。最大强度为$I(E_1)=1$。半峰全宽（FWHM）可以通过设置$I(E) = 1/2$来找到，这得到$(E_1 - E)^2 = g_1^2$，即$E = E_1 \\pm g_1$。因此，FWHM是$(E_1+g_1) - (E_1-g_1) = 2g_1$。这为测试用例1中的参考宽度提供了依据。\n\nK矩阵形式理论是一个强大的工具，因为它能保证幺正性。一个朴素的模型，例如简单地将振幅相加$T_{\\mathrm{naive}}(E) \\approx K(E)$，很容易违反幺正性界限$|T(E)| \\leq 1$，尤其是在重叠共振的情况下，$|K(E)|$可能会变得很大。幺正化映射$T = K/(1-iK)$自然地“稳定化”了振幅，确保对于所有实数$E$，$|T(E)| \\leq 1$。这是后续计算的物理和数学基础。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Solves the computational nuclear physics problem involving K-matrix unitarization.\n    It processes three distinct test cases and computes the required metrics for each.\n    \"\"\"\n    \n    def get_K(E, a, b, E_ref, poles):\n        \"\"\"\n        Calculates the K-matrix for a given energy or array of energies.\n        \n        Args:\n            E (np.ndarray or float): Energy/ies in MeV.\n            a (float): Background parameter.\n            b (float): Background slope parameter in MeV^-1.\n            E_ref (float): Reference energy in MeV.\n            poles (list of tuples): List of (E_i, g_i) pole parameters in MeV.\n            \n        Returns:\n            np.ndarray or float: The value of the K-matrix.\n        \"\"\"\n        k_val = a + b * (E - E_ref)\n        for E_i, g_i in poles:\n            # The calling context ensures that E != E_i.\n            k_val += g_i / (E_i - E)\n        return k_val\n\n    results = []\n\n    # Test Case 1: Isolated pole with weak background\n    a1, b1, E_ref1 = 0.02, 0.0, 1500.0\n    poles1 = [(1500.0, 25.0)]\n    g1 = poles1[0][1]\n    E_grid1_full = np.arange(1450.0, 1550.0 + 0.1, 0.2)\n    \n    pole_energies1 = [p[0] for p in poles1]\n    mask1 = ~np.isin(E_grid1_full, pole_energies1)\n    E_grid1 = E_grid1_full[mask1]\n\n    K1 = get_K(E_grid1, a1, b1, E_ref1, poles1)\n    I1 = K1**2 / (1 + K1**2)\n\n    I_max1 = np.max(I1)\n    I_half1 = I_max1 / 2.0\n    \n    peak_grid_idx = np.searchsorted(E_grid1, poles1[0][0])\n    \n    # Left side of the peak\n    E_left = E_grid1[:peak_grid_idx]\n    I_left = I1[:peak_grid_idx]\n    E_low = np.nan\n    if len(I_left) > 1 and I_left[0] < I_half1 and I_half1 < I_left[-1]:\n        f_left = interp1d(I_left, E_left, kind='linear')\n        E_low = f_left(I_half1)\n\n    # Right side of the peak\n    E_right = E_grid1[peak_grid_idx:]\n    I_right = I1[peak_grid_idx:]\n    E_high = np.nan\n    if len(I_right) > 1 and I_right[-1] < I_half1 and I_half1 < I_right[0]:\n        f_right = interp1d(I_right[::-1], E_right[::-1], kind='linear')\n        E_high = f_right(I_half1)\n\n    fwhm = E_high - E_low\n    expected_width = 2 * g1\n    eps_Gamma = np.abs(fwhm - expected_width) / expected_width\n    results.append(eps_Gamma)\n\n    # Test Case 2: Two overlapping poles\n    a2, b2, E_ref2 = 0.1, 0.0, 1000.0\n    poles2 = [(1000.0, 60.0), (1040.0, 40.0)]\n    E_grid2_full = np.arange(900.0, 1100.0 + 0.1, 0.2)\n    \n    pole_energies2 = [p[0] for p in poles2]\n    mask2 = ~np.isin(E_grid2_full, pole_energies2)\n    E_grid2 = E_grid2_full[mask2]\n    \n    K2 = get_K(E_grid2, a2, b2, E_ref2, poles2)\n    \n    # Metric 1: Unitarity deviation\n    S2 = (1 + 1j * K2) / (1 - 1j * K2)\n    unitarity_dev = np.max(np.abs(np.abs(S2) - 1))\n    results.append(unitarity_dev)\n    \n    # Metric 2: Stabilization ratio\n    max_K_abs = np.max(np.abs(K2))\n    T2 = K2 / (1 - 1j * K2)\n    max_T_abs = np.max(np.abs(T2))\n    stabilization_ratio = max_K_abs / max_T_abs\n    results.append(stabilization_ratio)\n\n    # Test Case 3: Strongly overlapping poles with sloped background\n    a3, b3, E_ref3 = 0.2, 0.001, 1300.0\n    poles3 = [(1300.0, 70.0), (1320.0, 60.0)]\n    E1_3 = poles3[0][0]\n    grid_step = 0.2\n    E_grid3_full = np.arange(1200.0, 1400.0 + 0.1, grid_step)\n\n    pole_energies3 = [p[0] for p in poles3]\n    mask3 = ~np.isin(E_grid3_full, pole_energies3)\n    E_grid3 = E_grid3_full[mask3]\n\n    K3 = get_K(E_grid3, a3, b3, E_ref3, poles3)\n    I3 = K3**2 / (1 + K3**2)\n    \n    # Metric: Peak shift\n    window_mask = (E_grid3 >= (E1_3 - 50.0))  (E_grid3 = (E1_3 + 50.0))\n    E_window = E_grid3[window_mask]\n    I_window = I3[window_mask]\n    \n    peak_idx_window = np.argmax(I_window)\n    \n    # Quadratic interpolation for sub-grid peak position\n    if 0  peak_idx_window  len(I_window) - 1:\n        p_idx = peak_idx_window\n        I_m1, I_0, I_p1 = I_window[p_idx-1], I_window[p_idx], I_window[p_idx+1]\n        E_0 = E_window[p_idx]\n        \n        denominator = I_m1 - 2*I_0 + I_p1\n        if np.abs(denominator)  1e-12: # Avoid division by zero for linear regions\n            p_offset = 0.5 * (I_m1 - I_p1) / denominator\n            E_peak = E_0 + p_offset * grid_step\n        else:\n            E_peak = E_0 \n    else:\n        # Peak is at the edge of the window, no interpolation\n        E_peak = E_window[peak_idx_window]\n\n    delta_E_peak = E_peak - E1_3\n    results.append(delta_E_peak)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}