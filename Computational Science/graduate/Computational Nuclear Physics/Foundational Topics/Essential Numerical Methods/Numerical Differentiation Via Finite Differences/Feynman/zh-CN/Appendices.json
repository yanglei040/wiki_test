{
    "hands_on_practices": [
        {
            "introduction": "数值微分的核心在于用离散的函数值来近似导数。中心差分法通过在某点两侧对称取样，提供了比单边差分更高的精度。这个练习将指导你从泰勒级数出发，推导二阶中心差分公式及其主要的截断误差项，并通过一个具体的高斯函数算例，将理论误差与实际计算误差进行比较，从而验证该方法的精度和误差行为。",
            "id": "3576237",
            "problem": "考虑在计算核物理中对一维单粒子轨道的数值微分，该轨道通常由高斯分布建模，例如在平均场近似和含时Hartree-Fock (TDHF) 实现中出现的那些轨道。令测试函数为 $f(x) = e^{-x^{2}}$，该函数是无量纲的。目标是为一阶导数构建并分析二阶中心差分估计量，并将其观测误差与泰勒展开预测的主截断项联系起来。\n\n从第一性原理出发，使用导数的定义以及解析函数在点 $x_{0}$ 附近的泰勒级数展开，来推导 $f'(x_{0})$ 的二阶中心差分近似及其主截断项。不要从任何预先给出的有限差分公式开始。在推导出近似及其主截断项后，为指定的 $x_{0}$ 和 $h$ 值实现以下量的计算：\n- 二阶中心差分估计 $D(x_{0}, h) = \\dfrac{f(x_{0}+h) - f(x_{0}-h)}{2h}$。\n- 精确导数 $f'(x_{0})$。\n- 测量误差 $E(x_{0}, h) = D(x_{0}, h) - f'(x_{0})$。\n- 理论主截断项 $T(x_{0}, h)$，由您的推导得出，用在 $x_{0}$ 处求值的 $f$ 的导数和 $h$ 的幂表示。\n- 比较标量 $\\Delta(x_{0}, h) = E(x_{0}, h) - T(x_{0}, h)$。\n\n所有量都是无量纲的。不涉及角度。程序必须为下面列出的每个测试用例计算 $\\Delta(x_{0}, h)$，并生成一行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，顺序与测试套件一致。\n\n使用以下涵盖典型、缩放和边界条件的测试套件：\n1. $x_{0} = 0.0$, $h = 10^{-2}$。\n2. $x_{0} = 0.5$, $h = 10^{-2}$。\n3. $x_{0} = 0.5$, $h = 10^{-3}$。\n4. $x_{0} = 1.5$, $h = 10^{-2}$。\n5. $x_{0} = 0.0$, $h = 10^{-8}$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如 $[r_{1},r_{2},r_{3},r_{4},r_{5}]$），其中每个 $r_{i}$ 是对应测试用例的 $\\Delta(x_{0}, h)$ 的浮点值，以完整的双精度进行评估，在打印输出时不进行四舍五入。",
            "solution": "为了推导中心差分公式及其主截断误差项，我们从函数 $f(x)$ 在点 $x_0$ 附近的泰勒级数展开开始：\n$$\nf(x_0+h) = f(x_0) + h f'(x_0) + \\frac{h^2}{2!} f''(x_0) + \\frac{h^3}{3!} f'''(x_0) + O(h^4)\n$$\n$$\nf(x_0-h) = f(x_0) - h f'(x_0) + \\frac{h^2}{2!} f''(x_0) - \\frac{h^3}{3!} f'''(x_0) + O(h^4)\n$$\n将第二个展开式从第一个中减去：\n$$\nf(x_0+h) - f(x_0-h) = 2h f'(x_0) + \\frac{h^3}{3} f'''(x_0) + O(h^5)\n$$\n整理后求解 $f'(x_0)$：\n$$\n\\frac{f(x_0+h) - f(x_0-h)}{2h} = f'(x_0) + \\frac{h^2}{6} f'''(x_0) + O(h^4)\n$$\n因此，一阶导数 $f'(x_0)$ 的二阶中心差分估计为：\n$$\nD(x_0, h) = \\frac{f(x_0+h) - f(x_0-h)}{2h}\n$$\n主截断项是近似值与精确值之间的差的主导部分，即：\n$$\nT(x_0, h) = \\frac{h^2}{6} f'''(x_0)\n$$\nPython 实现将直接使用这些结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the difference between the measured error and the theoretical\n    leading truncation term for the central difference approximation of the\n    first derivative of f(x) = exp(-x^2).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 1e-2),\n        (0.5, 1e-2),\n        (0.5, 1e-3),\n        (1.5, 1e-2),\n        (0.0, 1e-8),\n    ]\n\n    results = []\n    \n    # Define the required functions and their derivatives.\n    # f(x) = exp(-x^2)\n    def f(x):\n        return np.exp(-x**2)\n    \n    # f'(x) = -2x * exp(-x^2)\n    def f_prime(x):\n        return -2.0 * x * np.exp(-x**2)\n\n    # f'''(x) = (-8x^3 + 12x) * exp(-x^2)\n    def f_triple_prime(x):\n        return (-8.0 * x**3 + 12.0 * x) * np.exp(-x**2)\n\n    for x0, h in test_cases:\n        # Calculate the second-order central difference estimate D(x0, h).\n        # D(x0, h) = (f(x0 + h) - f(x0 - h)) / (2h)\n        d_val = (f(x0 + h) - f(x0 - h)) / (2.0 * h)\n        \n        # Calculate the exact derivative f'(x0).\n        fp_exact = f_prime(x0)\n        \n        # Calculate the measured error E(x0, h).\n        # E(x0, h) = D(x0, h) - f'(x0)\n        e_val = d_val - fp_exact\n        \n        # Calculate the theoretical leading truncation term T(x0, h).\n        # T(x0, h) = (h^2 / 6) * f'''(x0)\n        t_val = (h**2 / 6.0) * f_triple_prime(x0)\n        \n        # Calculate the comparison scalar Delta(x0, h).\n        # Delta(x0, h) = E(x0, h) - T(x0, h)\n        delta_val = e_val - t_val\n        \n        results.append(delta_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在求解偏微分方程时，我们不仅需要处理计算域内部的点，还必须正确地实现边界条件。对于像中子输运问题中的反射壁这类诺伊曼（Neumann）边界条件，一种优雅且能保持精度的方法是引入“幽灵单元”（ghost cell）。这个练习将引导你为诺伊曼边界条件 $f'(0)=0$ 推导幽灵单元的外推公式，并将其应用于中心差分格式中，以确保在边界处也能维持计算的准确性。",
            "id": "3576260",
            "problem": "考虑一个一维均匀网格，该网格在区间 $[0,1]$ 上由 $x_i = i h$ 定义，其中 $i$ 为整数，网格间距为 $h = 1/N$。令 $f(x)$ 表示一个足够光滑的标量场，在计算核物理中，它可以代表在 $x=0$ 处具有反射边界的平板中的一维中子标量通量。反射边界通过诺伊曼 (Neumann) 边界条件 $f'(0)=0$ 来建模。为了在边界附近统一应用标准的二阶中心差分，引入一个位于 $x_{-1} = -h$ 的虚构单元（ghost cell），其值 $f_{-1}$ 将通过外插法确定，以使离散格式与 $f'(0)=0$ 一致。\n\n从导数的基本定义 $f'(x) = \\lim_{h \\to 0} \\frac{f(x+h) - f(x)}{h}$ 出发，并使用 $f(h)$ 和 $f(-h)$ 在 $x=0$ 附近的泰勒级数展开，展开到足以评估截断误差的阶数，推导一个外插公式，该公式用网格点上的值来表示虚构单元的值 $f_{-1}$，从而以二阶精度强制满足诺伊曼边界条件 $f'(0)=0$。简要证明你的外插法的精度阶数。\n\n推导出公式后，编写一个完整的程序，该程序能够：\n- 对指定的整数 $N$ 构建网格 $x_i = i h$（其中 $h = 1/N$），对一组测试函数 $f$ 计算 $f(x_i)$，并通过你推导的外插法计算虚构单元的值 $f_{-1}$。\n- 使用标准的二阶中心差分公式来近似计算第一个内部点 $x=h$ 处的 $f'(x)$，即\n$$\n\\left.\\frac{df}{dx}\\right|_{x=h} \\approx \\frac{f(2h) - f(0)}{2h},\n$$\n并计算每个测试案例中与精确导数 $f'(h)$ 的绝对误差。\n- 使用虚构单元的值，通过引用该虚构单元的中心差分公式来近似计算边界 $x=0$ 处的导数，\n$$\n\\left.\\frac{df}{dx}\\right|_{x=0} \\approx \\frac{f(h) - f(-h)}{2h},\n$$\n并检查此近似值是否在 $10^{-12}$ 的容差范围内满足诺伊曼边界条件 $f'(0)=0$。\n\n使用以下测试套件，其中三角函数的参数以弧度为单位：\n1. $f(x) = \\cos(\\pi x)$，其中 $N = 10$。\n2. $f(x) = e^{-x^2}$，其中 $N = 100$。\n3. $f(x) = 1 + x^4$，其中 $N = 2$。\n4. 边缘情况：$f(x) = x$，其中 $N = 10$（此函数不满足 $f'(0)=0$；包含它是为了探究虚构单元强制执行的效果）。\n\n对于每个测试案例，你的程序必须按以下顺序输出三个值：\n- $f'(h)$ 的中心差分近似值（浮点数）。\n- 绝对误差 $|\\text{approx} - f'(h)|$（浮点数）。\n- 一个布尔值，表示使用虚构单元计算的 $x=0$ 处的边界导数近似值是否满足 $|\\left.\\frac{df}{dx}\\right|_{x=0}| \\le 10^{-12}$。\n\n最终输出格式：你的程序应生成单行输出，其中包含四个测试案例的所有结果，结果连接成一个逗号分隔的列表，并用方括号括起来。例如，输出形式应为\n$[r_1,e_1,b_1,r_2,e_2,b_2,r_3,e_3,b_3,r_4,e_4,b_4]$，\n其中 $r_k$ 是浮点数，$e_k$ 是浮点数，$b_k$ 是对应于第 $k$ 个测试案例的布尔值。",
            "solution": "该问题是有效的。这是一个适定、有科学依据的数值分析问题，具体涉及使用虚构单元技术为有限差分法实现诺伊曼边界条件。所有必要信息都已提供，任务是可形式化的，并且这是计算科学中的一个标准练习。\n\n### 第一部分：虚构单元外插公式的推导\n\n中心任务是找到一个函数 $f(x)$ 在虚构单元点 $x_{-1} = -h$（记为 $f_{-1}$）处的值的外插公式，使得诺伊曼边界条件 $f'(0)=0$ 能够以二阶精度得到满足。我们使用标准的二阶中心差分公式来计算在边界 $x=0$ 处的一阶导数。\n\n对于一个足够光滑的函数 $f(x)$，其在点 $x=0$ 附近的泰勒级数展开为：\n$$\nf(x) = f(0) + x f'(0) + \\frac{x^2}{2!} f''(0) + \\frac{x^3}{3!} f'''(0) + \\dots\n$$\n在网格点 $x_1 = h$ 和 $x_{-1} = -h$ 处计算此展开式：\n$$\nf(h) = f(0) + h f'(0) + \\frac{h^2}{2} f''(0) + \\frac{h^3}{6} f'''(0) + O(h^4)\n$$\n$$\nf(-h) = f(0) - h f'(0) + \\frac{h^2}{2} f''(0) - \\frac{h^3}{6} f'''(0) + O(h^4)\n$$\n从第一个表达式中减去第二个表达式，得到：\n$$\nf(h) - f(-h) = 2h f'(0) + \\frac{h^3}{3} f'''(0) + O(h^5)\n$$\n重新整理此式以构建 $f'(0)$ 的近似，得到对称中心差分公式：\n$$\n\\frac{f(h) - f(-h)}{2h} = f'(0) + \\frac{h^2}{6} f'''(0) + O(h^4)\n$$\n该公式近似 $f'(0)$ 的截断误差为 $O(h^2)$，使其成为一个二阶精度格式。\n\n问题要求我们强制执行诺伊曼边界条件 $f'(0)=0$。使用虚构单元实现此条件的标准方法是要求边界上导数的离散近似满足该条件。因此，我们将我们的离散算子（它使用网格值 $f_1 = f(h)$ 和虚构单元值 $f_{-1} = f(-h)$）设为零：\n$$\n\\frac{f_1 - f_{-1}}{2h} = 0\n$$\n求解虚构单元值 $f_{-1}$ 得到所需的外插公式：\n$$\nf_{-1} = f_1\n$$\n\n### 第二部分：精度证明\n\n问题要求证明此外插法能以二阶精度强制满足该条件。证明的关键在于底层有限差分算子的精度。如上所推导，中心差分算子 $\\frac{f(h) - f(-h)}{2h}$ 是真实导数 $f'(0)$ 的一个二阶精度近似。通过定义虚构单元值 $f_{-1}$ 使得该离散算子的计算结果恰好为零，我们实际上是用一个形式上二阶精度的方法来强制执行条件 $f'(0)=0$。也就是说，如果我们不强制它为零，该方法将以 $O(h^2)$ 的速率收敛到真实导数。对于一个真正满足 $f'(0)=0$ 的函数，离散算子*应该*得到的值并非零，而是 $\\frac{h^2}{6}f'''(0)$。通过选择 $f_{-1}=f_1$ 将算子设为零，我们在边界条件的表示中引入了一个与 $h^2$ 成正比的误差，这与一个二阶精度格式是一致的。\n\n### 第三部分：算法实现\n\n对于每个测试案例 $(f, f', N)$，程序将按以下步骤执行：\n1.  定义网格间距 $h = 1/N$。\n2.  计算所需网格点上的函数值：$f_0 = f(0)$，$f_1 = f(h)$ 和 $f_2 = f(2h)$。\n3.  应用推导出的外插公式找到虚构单元的值：$f_{-1} = f_1$。\n4.  使用指定的中心差分公式计算第一个内部点 $x=h$ 处导数的近似值：\n    $$\n    f'(h)_{\\text{approx}} = \\frac{f_2 - f_0}{2h}\n    $$\n5.  计算此近似值与精确导数 $f'(h)$ 的绝对误差。\n    $$\n    \\text{Error}_h = |f'(h)_{\\text{approx}} - f'(h)|\n    $$\n6.  使用包含虚构单元的中心差分公式计算边界 $x=0$ 处导数的近似值：\n    $$\n    f'(0)_{\\text{approx}} = \\frac{f_1 - f_{-1}}{2h}\n    $$\n    根据我们的外插法，该值将恰好为零。\n7.  验证此边界导数近似值的绝对值是否在指定的 $10^{-12}$ 容差范围内。\n    $$\n    |f'(0)_{\\text{approx}}| \\le 10^{-12}\n    $$\n每个测试案例的结果——$h$ 处的导数近似值、其误差以及边界处的布尔验证——将被收集并格式化为单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of deriving and applying a ghost-cell extrapolation for a\n    Neumann boundary condition.\n    \"\"\"\n\n    # Define the test suite: a list of tuples, each containing:\n    # 1. The function f(x)\n    # 2. The exact derivative f'(x)\n    # 3. The number of grid intervals N\n    test_cases = [\n        (lambda x: np.cos(np.pi * x), lambda x: -np.pi * np.sin(np.pi * x), 10),\n        (lambda x: np.exp(-x**2), lambda x: -2 * x * np.exp(-x**2), 100),\n        (lambda x: 1.0 + x**4, lambda x: 4 * x**3, 2),\n        (lambda x: x, lambda x: 1.0, 10),\n    ]\n\n    all_results = []\n    TOLERANCE = 1e-12\n\n    for f, f_prime, N in test_cases:\n        # 1. Construct grid and evaluate function at required points\n        h = 1.0 / N\n        x0, x1, x2 = 0.0, h, 2 * h\n        \n        f0 = f(x0)\n        f1 = f(x1)\n        f2 = f(x2)\n\n        # 2. Derive ghost-cell value using f_{-1} = f_1\n        # This formula enforces the discrete derivative (f_1 - f_{-1})/(2h) = 0\n        fm1 = f1\n\n        # 3. Compute the central-difference approximation of f'(h)\n        # Formula: (f(x+h) - f(x-h)) / (2h) evaluated at x=h.\n        # This is (f(2h) - f(0)) / (2h)\n        dfdx_h_approx = (f2 - f0) / (2 * h)\n\n        # 4. Compute the absolute error of the f'(h) approximation\n        dfdx_h_exact = f_prime(x1)\n        abs_error_h = np.abs(dfdx_h_approx - dfdx_h_exact)\n\n        # 5. Compute the boundary derivative at x=0 using the ghost cell\n        # Formula: (f(h) - f(-h)) / (2h)\n        # Using the ghost cell value, this is (f1 - fm1) / (2h)\n        dfdx_0_approx = (f1 - fm1) / (2 * h)\n\n        # 6. Check if the boundary condition is satisfied to within tolerance\n        boundary_check = np.abs(dfdx_0_approx) = TOLERANCE\n        \n        # Append the three required results for this test case\n        all_results.append(dfdx_h_approx)\n        all_results.append(abs_error_h)\n        all_results.append(boundary_check)\n\n    # Final print statement in the exact required format.\n    # The output format is a single line with a flat list of results.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多物理现象，从热传导到量子力学，都由涉及拉普拉斯算子（$\\nabla^2$）的方程描述。将一维的二阶导数中心差分公式扩展到三维空间，便自然地得到了拉普拉斯算子的七点差分格式。本练习将带你构建并验证这个在计算物理中至关重要的三维离散算子，通过计算离散 $L^2$ 误差范数并确认其在网格加密下的二阶收敛性，你将掌握从一维基础到多维应用的关键一步。",
            "id": "3576233",
            "problem": "本题要求您推导、实现并验证一个三维拉普拉斯算子的二阶精度七点格式有限差分离散化方法，然后测量其离散误差，并通过网格加密来验证其二阶收敛性。本练习的背景源于计算核物理中对偏微分方程的计算处理，例如中子扩散或平均场方程，在这些领域，对拉普拉斯算子进行精确且高效的近似至关重要。\n\n从基本定义出发，一个足够光滑的标量场 $f(x,y,z)$ 的拉普拉斯算子是其非混合二阶偏导数的和，即 $\\nabla^{2} f = \\frac{\\partial^{2} f}{\\partial x^{2}} + \\frac{\\partial^{2} f}{\\partial y^{2}} + \\frac{\\partial^{2} f}{\\partial z^{2}}$。在一个结构化的笛卡尔网格上，其沿 $x$、$y$、$z$ 方向的均匀间距分别为 $h_{x}$、$h_{y}$ 和 $h_{z}$，七点格式近似仅使用坐标轴对齐方向上的最近邻采样点。请利用泰勒级数展开为每个二阶导数推导一个相容的、二阶精度的中心差分离散格式，然后将它们组合起来，形成一个作用于内部网格点上的离散拉普拉斯算子。对于边界处理，通过在区域边界上对精确解析函数进行采样来施加狄利克雷边界条件。\n\n考虑光滑测试函数 $f(x,y,z) = \\sin x \\,\\cos y \\,\\exp z$，该函数形式代表了核系统简化模型中遇到的可分离的角向和径向依赖关系。角度必须以弧度为单位。请对该函数 $f$ 解析地推导其精确的拉普拉斯算子 $\\nabla^{2} f$，并用它作为参考来评估离散化误差。\n\n在内部网格上定义离散 $L^{2}$ 误差范数如下。设区域为一个矩形盒 $[0,L_{x}]\\times[0,L_{y}]\\times[0,L_{z}]$，在每个方向上由 $N_{x}$、$N_{y}$、$N_{z}$ 个网格点（包括边界）剖分，其中 $h_{x} = L_{x}/(N_{x}-1)$、$h_{y} = L_{y}/(N_{y}-1)$、$h_{z} = L_{z}/(N_{z}-1)$。令 $\\mathcal{I}$ 表示内部索引 $(i,j,k)$ 的集合，其中 $1 \\le i \\le N_{x}-2$，$1 \\le j \\le N_{y}-2$，$1 \\le k \\le N_{z}-2$。如果 $\\mathcal{L}_{h} f$ 表示应用于 $f$ 的网格采样点上的离散拉普拉斯算子，而 $(\\nabla^{2}f)_{\\text{exact}}$ 表示在网格节点上求值的精确解析拉普拉斯算子，则定义\n$$\nE_{2}(h_{x},h_{y},h_{z}) \\equiv \\left( \\sum_{(i,j,k)\\in \\mathcal{I}} \\left[ \\mathcal{L}_{h} f - (\\nabla^{2}f)_{\\text{exact}} \\right]^{2} \\, h_{x} h_{y} h_{z} \\right)^{1/2}.\n$$\n通过将每个坐标方向的网格加密一倍（即每个间距减半）来验证二阶收敛性。给定一个基础网格 $(N_{x},N_{y},N_{z})$，将加密后的网格定义为 $(N'_{x},N'_{y},N'_{z})$，其中\n$$\nN'_{x} = 2\\,(N_{x}-1) + 1,\\quad N'_{y} = 2\\,(N_{y}-1) + 1,\\quad N'_{z} = 2\\,(N_{z}-1) + 1,\n$$\n因此 $h'_{x} = h_{x}/2$，$h'_{y} = h_{y}/2$，$h'_{z} = h_{z}/2$。对每个测试用例，计算其观测到的收敛阶\n$$\np \\equiv \\log_{2} \\left( \\frac{E_{2}(h_{x},h_{y},h_{z})}{E_{2}(h'_{x},h'_{y},h'_{z})} \\right).\n$$\n\n实现一个完整、可运行的程序，该程序需：\n- 构建网格并在所有节点上计算 $f$ 和 $(\\nabla^{2}f)_{\\text{exact}}$。\n- 通过将 $f$ 的边界值设为精确的 $f$ 值来强制施加狄利克雷边界条件。\n- 仅对内部节点应用您的七点离散拉普拉斯算子 $\\mathcal{L}_{h}$。\n- 对每个测试用例计算 $E_{2}(h_{x},h_{y},h_{z})$ 和 $E_{2}(h'_{x},h'_{y},h'_{z})$。\n- 报告每个测试用例的观测阶 $p$。\n\n角度必须以弧度为单位。除了声明角度单位为弧度外，不需要进行任何物理单位转换。\n\n使用以下测试套件来检验常规和边界情况下的行为：\n- 测试用例 A（常规情况，近立方体网格）：$L_{x}=\\pi$，$L_{y}=\\pi/2$，$L_{z}=1$，基础网格为 $(N_{x},N_{y},N_{z})=(17,17,17)$，加密后网格为 $(33,33,33)$。\n- 测试用例 B（各向异性间距和非立方体点数）：$L_{x}=\\pi$，$L_{y}=\\pi$，$L_{z}=1/2$，基础网格为 $(N_{x},N_{y},N_{z})=(18,14,10)$，加密后网格为 $(35,27,19)$。\n- 测试用例 C（中等规模、强各向异性区域范围）：$L_{x}=2$，$L_{y}=1$，$L_{z}=1/4$，基础网格为 $(N_{x},N_{y},N_{z})=(5,7,9)$，加密后网格为 $(9,13,17)$。\n\n您的程序必须生成单行输出，其中包含三个测试用例（按 A、B、C 的顺序）的观测阶 $p$，格式为方括号内以逗号分隔的列表。为了可复现性和比较，请将每个报告的 $p$ 值四舍五入到 $6$ 位小数。例如，输出格式必须为\n[p_A,p_B,p_C]\n其中每个条目都是小数点后有 $6$ 位数字的浮点数。",
            "solution": "该问题要求对三维拉普拉斯算子 $\\nabla^2$ 推导、实现并验证一个二阶精度的有限差分格式。验证将通过测量一个已知光滑函数的离散化误差的收敛率来执行。\n\n### 1. 七点有限差分格式的推导\n\n标量场 $f(x,y,z)$ 的拉普拉斯算子定义为 $\\nabla^2 f = \\frac{\\partial^2 f}{\\partial x^2} + \\frac{\\partial^2 f}{\\partial y^2} + \\frac{\\partial^2 f}{\\partial z^2}$。我们寻求在笛卡尔网格点 $(x_i, y_j, z_k)$ 上对此算子进行离散近似，其中 $x_i = i h_x$，$y_j = j h_y$，$z_k = k h_z$，且网格间距 $h_x, h_y, h_z$ 均为常数。\n\n该方法的核心是二阶导数的中心差分近似。考虑一维函数 $u(x)$。其在点 $x$ 附近的泰勒级数展开为：\n$$ u(x+h) = u(x) + h u'(x) + \\frac{h^2}{2!} u''(x) + \\frac{h^3}{3!} u'''(x) + \\frac{h^4}{4!} u^{(4)}(x) + O(h^5) $$\n$$ u(x-h) = u(x) - h u'(x) + \\frac{h^2}{2!} u''(x) - \\frac{h^3}{3!} u'''(x) + \\frac{h^4}{4!} u^{(4)}(x) - O(h^5) $$\n将这两个表达式相加，可以消去奇数次幂的导数项：\n$$ u(x+h) + u(x-h) = 2u(x) + h^2 u''(x) + \\frac{h^4}{12} u^{(4)}(x) + O(h^6) $$\n解出 $u''(x)$：\n$$ u''(x) = \\frac{u(x+h) - 2u(x) + u(x-h)}{h^2} - \\frac{h^2}{12} u^{(4)}(x) + O(h^4) $$\n有限差分近似即为等式右边的第一项。截断误差为 $-\\frac{h^2}{12}u^{(4)}(x) + O(h^4)$，其量级为 $O(h^2)$。因此，该近似是二阶精度的。\n\n为了离散化三维拉普拉斯算子，我们将此公式应用于每个二阶偏导数。令 $f_{i,j,k} = f(x_i, y_j, z_k)$。\n$$ \\left.\\frac{\\partial^2 f}{\\partial x^2}\\right|_{i,j,k} \\approx \\frac{f_{i+1,j,k} - 2f_{i,j,k} + f_{i-1,j,k}}{h_x^2} $$\n$$ \\left.\\frac{\\partial^2 f}{\\partial y^2}\\right|_{i,j,k} \\approx \\frac{f_{i,j+1,k} - 2f_{i,j,k} + f_{i,j-1,k}}{h_y^2} $$\n$$ \\left.\\frac{\\partial^2 f}{\\partial z^2}\\right|_{i,j,k} \\approx \\frac{f_{i,j,k+1} - 2f_{i,j,k} + f_{i,j,k-1}}{h_z^2} $$\n在网格点 $(i,j,k)$ 处的离散拉普拉斯算子（记为 $\\mathcal{L}_h f$）是这些近似值之和：\n$$ (\\mathcal{L}_h f)_{i,j,k} = \\frac{f_{i+1,j,k} - 2f_{i,j,k} + f_{i-1,j,k}}{h_x^2} + \\frac{f_{i,j+1,k} - 2f_{i,j,k} + f_{i,j-1,k}}{h_y^2} + \\frac{f_{i,j,k+1} - 2f_{i,j,k} + f_{i,j,k-1}}{h_z^2} $$\n该公式被称为七点格式，因为它涉及一个中心点及其沿坐标轴的六个最近邻点的值。总截断误差的量级为 $O(h_x^2, h_y^2, h_z^2)$，证实了该格式为二阶精度。\n\n### 2. 测试函数的解析拉普拉斯算子\n\n为评估我们离散算子的精度，我们需要一个已知其精确拉普拉斯算子的测试函数。问题指定了函数 $f(x,y,z) = \\sin x \\, \\cos y \\, e^z$。我们解析地计算其二阶偏导数：\n$$ \\frac{\\partial f}{\\partial x} = \\cos x \\, \\cos y \\, e^z \\quad \\implies \\quad \\frac{\\partial^2 f}{\\partial x^2} = -\\sin x \\, \\cos y \\, e^z = -f(x,y,z) $$\n$$ \\frac{\\partial f}{\\partial y} = -\\sin x \\, \\sin y \\, e^z \\quad \\implies \\quad \\frac{\\partial^2 f}{\\partial y^2} = -\\sin x \\, \\cos y \\, e^z = -f(x,y,z) $$\n$$ \\frac{\\partial f}{\\partial z} = \\sin x \\, \\cos y \\, e^z \\quad \\implies \\quad \\frac{\\partial^2 f}{\\partial z^2} = \\sin x \\, \\cos y \\, e^z = f(x,y,z) $$\n将它们相加，得到精确的解析拉普拉斯算子：\n$$ (\\nabla^2 f)_{\\text{exact}} = (-f) + (-f) + (f) = -f(x,y,z) = -\\sin x \\, \\cos y \\, e^z $$\n这个解析结果将作为衡量我们数值近似误差的基准。\n\n### 3. 误差测量与收敛阶\n\n近似的质量通过离散 $L^2$ 误差范数来量化，该范数在内部网格点集 $\\mathcal{I}$ 上计算。误差定义为：\n$$ E_{2}(h_{x},h_{y},h_{z}) = \\left( \\sum_{(i,j,k)\\in \\mathcal{I}} \\left[ (\\mathcal{L}_{h} f)_{i,j,k} - (\\nabla^{2}f)_{\\text{exact},i,j,k} \\right]^{2} \\, h_{x} h_{y} h_{z} \\right)^{1/2} $$\n对于一个二阶精度的格式，误差 $E_2$ 预期与网格间距的平方成正比。即，$E_2(h) \\approx C h^2$，其中 $C$ 是某个常数，$h$ 是一个特征网格间距。如果我们将网格加密，使间距减半（$h' = h/2$），则新误差应为 $E_2(h') \\approx C (h/2)^2 = E_2(h)/4$。因此，误差比率应为 $E_2(h)/E_2(h') \\approx 4$。\n\n观测到的收敛阶 $p$ 由此比率计算得出：\n$$ p = \\log_{2} \\left( \\frac{E_{2}(h)}{E_{2}(h')} \\right) $$\n对于二阶格式，我们预期 $p \\approx \\log_2(4) = 2$。数值实验将计算几种网格配置下的 $p$ 值，以验证这一理论预测。\n\n### 4. 实现设计\n\n实现将针对每个测试用例遵循一个系统化的流程。一个计算子程序将负责为给定的区域、网格尺寸和测试函数计算 $L^2$ 误差。\n1.  **网格生成**：对于尺寸为 $[0,L_x] \\times [0,L_y] \\times [0,L_z]$ 的区域和网格点数 $(N_x, N_y, N_z)$，网格间距为 $h_x = L_x/(N_x-1)$，$h_y = L_y/(N_y-1)$，$h_z = L_z/(N_z-1)$。使用 `numpy.meshgrid` 并设置 `indexing='ij'` 来生成三维坐标数组 `X`、`Y`、`Z`，以与 $(i,j,k)$ 索引约定保持一致。\n2.  **函数求值**：在网格的每个点上计算解析测试函数 $f(x,y,z)$ 及其精确拉普拉斯算子 $(\\nabla^2 f)_{\\text{exact}} = -f(x,y,z)$，得到数组 `F` 和 `Lap_F_exact`。用精确值填充 `F` 数组，即隐式地施加了所要求的狄利克雷边界条件。\n3.  **离散拉普拉斯算子计算**：将七点格式应用于 `F` 数组的内部点。这可以通过 `numpy` 的向量化数组切片高效完成。例如，项 $(f_{i+1,j,k} - 2f_{i,j,k} + f_{i-1,j,k})/h_x^2$ 会同时为所有内部点计算。三个方向导数近似值之和即为离散拉普拉斯算子数组 `Lap_F_discrete`。\n4.  **误差计算**：通过计算 `Lap_F_discrete` 与 `Lap_F_exact` 相应内部点之间的逐元素差值，将结果平方，对所有内部点求和，乘以体积元 $h_x h_y h_z$，然后取平方根，来计算 $L^2$ 误差范数。\n\n首先对基础网格 $(N_x, N_y, N_z)$ 执行整个过程以求得 $E_2(h)$，然后对加密后的网格 $(N'_x, N'_y, N'_z)$ 再次执行以求得 $E_2(h')$。最后，根据这两个误差值计算观测到的收敛阶 $p$。对每个指定的测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and verifies a second-order accurate finite-difference \n    discretization of the 3D Laplacian, measuring convergence order.\n    \"\"\"\n    \n    test_cases = [\n        # Test case A: Happy path, cubic-ish grid\n        {\n            \"name\": \"A\",\n            \"L_xyz\": (np.pi, np.pi / 2.0, 1.0),\n            \"N_base\": (17, 17, 17)\n        },\n        # Test case B: Anisotropic spacings and non-cubic counts\n        {\n            \"name\": \"B\",\n            \"L_xyz\": (np.pi, np.pi, 0.5),\n            \"N_base\": (18, 14, 10)\n        },\n        # Test case C: Moderate, strongly anisotropic domain extents\n        {\n            \"name\": \"C\",\n            \"L_xyz\": (2.0, 1.0, 0.25),\n            \"N_base\": (5, 7, 9)\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L_xyz = case[\"L_xyz\"]\n        N_base = case[\"N_base\"]\n\n        def compute_l2_error(domain_lengths, grid_points):\n            \"\"\"\n            Computes the discrete L2 error of the 7-point Laplacian stencil.\n\n            Args:\n                domain_lengths (tuple): (Lx, Ly, Lz) of the domain.\n                grid_points (tuple): (Nx, Ny, Nz) number of points in each dimension.\n\n            Returns:\n                float: The computed L2 error norm.\n            \"\"\"\n            Lx, Ly, Lz = domain_lengths\n            Nx, Ny, Nz = grid_points\n\n            # Ensure grid points allow for interior points\n            if any(n  3 for n in grid_points):\n                raise ValueError(\"Grid must have at least 3 points in each dimension for an interior.\")\n\n            # Calculate grid spacings\n            hx = Lx / (Nx - 1)\n            hy = Ly / (Ny - 1)\n            hz = Lz / (Nz - 1)\n            \n            # Create grid coordinates\n            x_vec = np.linspace(0.0, Lx, Nx)\n            y_vec = np.linspace(0.0, Ly, Ny)\n            z_vec = np.linspace(0.0, Lz, Nz)\n            X, Y, Z = np.meshgrid(x_vec, y_vec, z_vec, indexing='ij')\n\n            # Evaluate the test function and its exact Laplacian on the grid\n            # f(x,y,z) = sin(x) * cos(y) * exp(z)\n            # ∇²f = -f(x,y,z)\n            F = np.sin(X) * np.cos(Y) * np.exp(Z)\n            lap_F_exact = -F\n\n            # Apply the 7-point stencil to compute the discrete Laplacian on interior points\n            # F[i, j, k] corresponds to (x_i, y_j, z_k)\n            F_ijk  = F[1:-1, 1:-1, 1:-1]\n            \n            term_x = (F[2:, 1:-1, 1:-1] - 2 * F_ijk + F[:-2, 1:-1, 1:-1]) / hx**2\n            term_y = (F[1:-1, 2:, 1:-1] - 2 * F_ijk + F[1:-1, :-2, 1:-1]) / hy**2\n            term_z = (F[1:-1, 1:-1, 2:] - 2 * F_ijk + F[1:-1, 1:-1, :-2]) / hz**2\n            \n            lap_F_discrete = term_x + term_y + term_z\n\n            # Isolate the exact Laplacian on the same interior grid\n            lap_F_exact_interior = lap_F_exact[1:-1, 1:-1, 1:-1]\n\n            # Calculate the L2 error norm on the interior\n            diff_sq = (lap_F_discrete - lap_F_exact_interior)**2\n            volume_element = hx * hy * hz\n            error_norm = np.sqrt(np.sum(diff_sq) * volume_element)\n            \n            return error_norm\n\n        # Compute error for the base grid\n        E_base = compute_l2_error(L_xyz, N_base)\n\n        # Define and compute error for the refined grid\n        Nx, Ny, Nz = N_base\n        N_refined = (2 * (Nx - 1) + 1, 2 * (Ny - 1) + 1, 2 * (Nz - 1) + 1)\n        E_refined = compute_l2_error(L_xyz, N_refined)\n        \n        # Calculate the observed order of convergence\n        p = np.log2(E_base / E_refined)\n        results.append(p)\n\n    # Format the final output string\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}