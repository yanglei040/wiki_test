{
    "hands_on_practices": [
        {
            "introduction": "在计算物理中，我们不仅要执行数值计算，还必须深刻理解计算结果中误差的来源。本练习旨在计算一个典型的中子反应率积分，它要求我们将一个无穷积分截断为一个有限积分以便进行数值处理。这个过程引导我们亲手实践如何应用复合辛普森法则，并更重要地，教会我们如何量化和区分两种根本不同类型的误差：由物理模型简化引入的截断误差，以及由数值近似方法引入的离散化误差 。",
            "id": "3550859",
            "problem": "考虑一个非相对论性的中子致反应率，其定义为微观截面、粒子速率和能量概率密度的乘积在能量空间上的期望值。设反应率是由以下反常积分给出的标量 $\\lambda$\n$$\n\\lambda=\\int_{0}^{\\infty}\\sigma(E)\\,v(E)\\,\\phi_E(E;T)\\,dE,\n$$\n其中 $E$ 是动能，$\\sigma(E)$ 是能量依赖的微观截面， $v(E)$ 是作为能量函数的速率，$\\phi_E(E;T)$ 是在绝对温度 $T$ 下气体的归一化 Maxwell–Boltzmann 能量概率密度。使用以下经过充分检验的物理定义作为基础：\n1. 非相对论动能-速率关系 $E=\\tfrac{1}{2}m v^2$，其中 $m$ 是中子质量，这意味着 $v(E)=\\sqrt{2E/m}$。\n2. 三维空间中的归一化 Maxwell–Boltzmann 能量分布（能量概率密度），\n$$\n\\phi_E(E;T)=\\frac{2}{\\sqrt{\\pi}}\\frac{1}{(k_{\\mathrm{B}}T)^{3/2}}\\sqrt{E}\\,e^{-E/(k_{\\mathrm{B}}T)},\n$$\n其中 $k_{\\mathrm{B}}$ 是 Boltzmann 常数，$T$ 是绝对温度。\n3. 一个在 $[0,\\infty)$ 上光滑的参数化截面模型，\n$$\n\\sigma(E)=\\sigma_0+\\sigma_1 E+\\sigma_2 E^2,\n$$\n其固定参数 $\\sigma_0$、$\\sigma_1$ 和 $\\sigma_2$ 的选择应符合物理实际且数值上是良态的。\n\n在计算核物理中，通常将积分上限 $\\infty$ 替换为一个有限的截止能量 $E_{\\max}$，以获得一个截断积分，该积分可以通过复合求积法进行数值计算。您的任务是，在区间 $[0,E_{\\max}]$ 上实现具有偶数个子区间 $N$ 的复合 Simpson 法则来近似计算\n$$\n\\lambda_{\\text{Simpson}}(E_{\\max},N)\\approx\\int_{0}^{E_{\\max}}\\sigma(E)\\,v(E)\\,\\phi_E(E;T)\\,dE,\n$$\n并为每个测试用例分别量化截断误差和离散化误差，其定义如下\n$$\n\\varepsilon_{\\text{trunc}}=\\left|\\lambda-\\lambda_{\\text{trunc}}(E_{\\max})\\right|,\\quad\n\\varepsilon_{\\text{disc}}=\\left|\\lambda_{\\text{Simpson}}(E_{\\max},N)-\\lambda_{\\text{trunc}}(E_{\\max})\\right|,\n$$\n其中 $\\lambda_{\\text{trunc}}(E_{\\max})=\\int_{0}^{E_{\\max}}\\sigma(E)\\,v(E)\\,\\phi_E(E;T)\\,dE$ 是截断积分，而 $\\lambda=\\int_{0}^{\\infty}\\sigma(E)\\,v(E)\\,\\phi_E(E;T)\\,dE$ 是真实反应率。您必须基于给定的基本定义，从第一性原理出发计算 $\\lambda$ 和 $\\lambda_{\\text{trunc}}(E_{\\max})$，而不能对这两个量使用数值求积。所有积分都必须用所提供的模型和物理常数来表示和计算。\n\n使用以下国际单位制（SI）中的固定常数：\n- 中子质量 $m=1.67492749804\\times 10^{-27}\\,\\mathrm{kg}$。\n- Boltzmann 常数 $k_{\\mathrm{B}}=1.380649\\times 10^{-23}\\,\\mathrm{J/K}$。\n- 截面参数 $\\sigma_0=1.0\\times 10^{-28}\\,\\mathrm{m^2}$，$\\sigma_1=5.0\\times 10^{-49}\\,\\mathrm{m^2/J}$，$\\sigma_2=2.0\\times 10^{-69}\\,\\mathrm{m^2/J^2}$。\n\n构建一个覆盖不同数值区域的测试套件。对于每个测试用例，指定元组 $(T,\\alpha,N)$，其中 $T$ 是绝对温度，$N$ 是复合 Simpson 法则的偶数子区间数，且 $E_{\\max}=\\alpha\\,k_{\\mathrm{B}}T$。使用以下测试套件：\n- 用例 1：$(T=\\;600\\,\\mathrm{K},\\;\\alpha=\\;5.0,\\;N=\\;100)$。\n- 用例 2：$(T=\\;600\\,\\mathrm{K},\\;\\alpha=\\;1.0,\\;N=\\;100)$。\n- 用例 3：$(T=\\;600\\,\\mathrm{K},\\;\\alpha=\\;5.0,\\;N=\\;2)$。\n- 用例 4：$(T=\\;3000\\,\\mathrm{K},\\;\\alpha=\\;2.0,\\;N=\\;50)$。\n- 用例 5：$(T=\\;300\\,\\mathrm{K},\\;\\alpha=\\;0.1,\\;N=\\;20)$。\n\n您的程序必须为每个测试用例计算并返回四元组\n$$\n\\left[\\lambda,\\ \\lambda_{\\text{Simpson}}(E_{\\max},N),\\ \\varepsilon_{\\text{trunc}},\\ \\varepsilon_{\\text{disc}}\\right],\n$$\n所有四个量都以 $\\mathrm{m^3/s}$ 为单位，表示为实数值。本问题不涉及角度。最终输出必须将五个测试用例的结果汇总为一行，包含一个由逗号分隔的四元组列表，并用方括号括起来，例如\n$$\n\\left[\\,[a_1,b_1,c_1,d_1],\\,[a_2,b_2,c_2,d_2],\\,[a_3,b_3,c_3,d_3],\\,[a_4,b_4,c_4,d_4],\\,[a_5,b_5,c_5,d_5]\\,\\right],\n$$\n且必须精确地打印为单行。所有数值答案的单位必须是 $\\mathrm{m^3/s}$。",
            "solution": "该问题经评估有效。它在科学上基于非相对论统计力学和核反应理论的原理，在数学上是适定的、客观的且自洽的。所有提供的物理模型、常数和定义都是标准且一致的。该任务是一个定义明确的计算物理练习，需要解析推导和数值实现。\n\n主要目标是计算中子致反应率 $\\lambda$，其由以下积分定义：\n$$\n\\lambda=\\int_{0}^{\\infty}\\sigma(E)\\,v(E)\\,\\phi_E(E;T)\\,dE\n$$\n我们还将计算其截断近似和数值近似，以及相关的误差。\n\n首先，我们通过代入给定的表达式来构造被积函数 $f(E) = \\sigma(E)\\,v(E)\\,\\phi_E(E;T)$：\n1. 截面：$\\sigma(E)=\\sigma_0+\\sigma_1 E+\\sigma_2 E^2$\n2. 速率：$v(E)=\\sqrt{2E/m}$\n3. Maxwell-Boltzmann 能量密度：$\\phi_E(E;T)=\\frac{2}{\\sqrt{\\pi}}\\frac{1}{(k_{\\mathrm{B}}T)^{3/2}}\\sqrt{E}\\,e^{-E/(k_{\\mathrm{B}}T)}$\n\n合并这些项，被积函数 $f(E)$ 变为：\n$$\nf(E) = (\\sigma_0+\\sigma_1 E+\\sigma_2 E^2) \\left(\\sqrt{\\frac{2E}{m}}\\right) \\left(\\frac{2}{\\sqrt{\\pi}(k_{\\mathrm{B}}T)^{3/2}}\\sqrt{E}\\,e^{-E/(k_{\\mathrm{B}}T)}\\right)\n$$\n通过合并 $\\sqrt{E}$ 项来简化此表达式：\n$$\nf(E) = \\frac{2\\sqrt{2}}{\\sqrt{m\\pi}(k_{\\mathrm{B}}T)^{3/2}} (\\sigma_0+\\sigma_1 E+\\sigma_2 E^2) E e^{-E/(k_{\\mathrm{B}}T)}\n$$\n我们定义一个常数前置因子 $C_T = \\frac{2\\sqrt{2/m}}{\\sqrt{\\pi}(k_{\\mathrm{B}}T)^{3/2}}$。被积函数可以写作：\n$$\nf(E) = C_T (\\sigma_0 E + \\sigma_1 E^2 + \\sigma_2 E^3) e^{-E/(k_{\\mathrm{B}}T)}\n$$\n\n**1. 真实反应率 $\\lambda$ 的解析计算**\n\n为了求得真实反应率 $\\lambda$，我们必须对 $f(E)$ 从 $0$ 积分到 $\\infty$。\n$$\n\\lambda = \\int_0^\\infty f(E) dE = C_T \\int_0^\\infty (\\sigma_0 E + \\sigma_1 E^2 + \\sigma_2 E^3) e^{-E/(k_{\\mathrm{B}}T)} dE\n$$\n这需要求解形如 $\\int_0^\\infty E^n e^{-aE} dE$ 的积分，其中 $a=1/(k_{\\mathrm{B}}T)$。这是一个与 Gamma 函数 $\\Gamma(z) = \\int_0^\\infty t^{z-1} e^{-t} dt$ 相关的标准积分。使用换元法 $t=aE$，我们得到：\n$$\n\\int_0^\\infty E^n e^{-aE} dE = \\frac{1}{a^{n+1}} \\int_0^\\infty t^n e^{-t} dt = \\frac{\\Gamma(n+1)}{a^{n+1}} = \\frac{n!}{a^{n+1}}\n$$\n将此结果应用于我们积分的每一项，其中 $a=1/(k_{\\mathrm{B}}T)$：\n- $\\int_0^\\infty E^1 e^{-E/(k_{\\mathrm{B}}T)} dE = \\frac{1!}{(1/k_{\\mathrm{B}}T)^2} = (k_{\\mathrm{B}}T)^2$\n- $\\int_0^\\infty E^2 e^{-E/(k_{\\mathrm{B}}T)} dE = \\frac{2!}{(1/k_{\\mathrm{B}}T)^3} = 2(k_{\\mathrm{B}}T)^3$\n- $\\int_0^\\infty E^3 e^{-E/(k_{\\mathrm{B}}T)} dE = \\frac{3!}{(1/k_{\\mathrm{B}}T)^4} = 6(k_{\\mathrm{B}}T)^4$\n\n将这些结果代回 $\\lambda$ 的表达式中：\n$$\n\\lambda = C_T \\left[ \\sigma_0(k_{\\mathrm{B}}T)^2 + \\sigma_1(2(k_{\\mathrm{B}}T)^3) + \\sigma_2(6(k_{\\mathrm{B}}T)^4) \\right]\n$$\n$$\n\\lambda = \\frac{2\\sqrt{2/m}}{\\sqrt{\\pi}(k_{\\mathrm{B}}T)^{3/2}} (k_{\\mathrm{B}}T)^2 \\left[ \\sigma_0 + 2\\sigma_1(k_{\\mathrm{B}}T) + 6\\sigma_2(k_{\\mathrm{B}}T)^2 \\right]\n$$\n$$\n\\lambda = \\frac{2\\sqrt{2k_{\\mathrm{B}}T/m}}{\\sqrt{\\pi}} \\left[ \\sigma_0 + 2\\sigma_1(k_{\\mathrm{B}}T) + 6\\sigma_2(k_{\\mathrm{B}}T)^2 \\right]\n$$\n这就是真实反应率 $\\lambda$ 的解析公式。\n\n**2. 截断反应率 $\\lambda_{\\text{trunc}}(E_{\\max})$ 的解析计算**\n\n截断反应率 $\\lambda_{\\text{trunc}}$ 是 $f(E)$ 从 $0$ 到有限截止能量 $E_{\\max} = \\alpha k_{\\mathrm{B}}T$ 的积分。\n$$\n\\lambda_{\\text{trunc}} = \\int_0^{E_{\\max}} f(E) dE\n$$\n这涉及到形如 $\\int_0^{E_{\\max}} E^n e^{-aE} dE$ 的积分，其与下不完全 Gamma 函数 $\\gamma(s, x) = \\int_0^x t^{s-1} e^{-t} dt$ 有关。通过换元 $t=aE$，其中 $a=1/(k_{\\mathrm{B}}T)$，积分上限变为 $x=aE_{\\max} = \\frac{1}{k_{\\mathrm{B}}T}(\\alpha k_{\\mathrm{B}}T) = \\alpha$。\n$$\n\\int_0^{E_{\\max}} E^n e^{-aE} dE = \\frac{1}{a^{n+1}} \\int_0^{\\alpha} t^n e^{-t} dt = \\frac{\\gamma(n+1, \\alpha)}{a^{n+1}} = (k_{\\mathrm{B}}T)^{n+1} \\gamma(n+1, \\alpha)\n$$\n将此应用于 $\\lambda_{\\text{trunc}}$ 积分的各项：\n$$\n\\lambda_{\\text{trunc}} = C_T \\left[ \\sigma_0(k_{\\mathrm{B}}T)^2 \\gamma(2, \\alpha) + \\sigma_1(k_{\\mathrm{B}}T)^3 \\gamma(3, \\alpha) + \\sigma_2(k_{\\mathrm{B}}T)^4 \\gamma(4, \\alpha) \\right]\n$$\n$$\n\\lambda_{\\text{trunc}} = \\frac{2\\sqrt{2k_{\\mathrm{B}}T/m}}{\\sqrt{\\pi}} \\left[ \\sigma_0 \\frac{\\gamma(2, \\alpha)}{1!} + \\sigma_1 (k_{\\mathrm{B}}T) \\frac{\\gamma(3, \\alpha)}{2!} + \\sigma_2 (k_{\\mathrm{B}}T)^2 \\frac{\\gamma(4, \\alpha)}{3!} \\right]\n$$\n引入因子 $n!$ 是为了显示其与正则化不完全 Gamma 函数 $P(s,x) = \\gamma(s,x)/\\Gamma(s)$ 的联系，后者通常在科学计算库中实现。由于 $\\Gamma(n+1)=n!$，我们有 $\\gamma(n+1,\\alpha) = n!P(n+1, \\alpha)$。函数 $\\gamma(s,x)$ 可以使用标准库函数（例如 `scipy.special.gammainc` 和 `scipy.special.gamma`）来计算。\n\n**3. 通过复合 Simpson 法则进行数值计算, $\\lambda_{\\text{Simpson}}(E_{\\max},N)$**\n\n复合 Simpson 法则用于近似计算在偶数个子区间 $N$ 上的定积分 $\\int_a^b g(x) dx$。区间 $[a, b]$被划分为 $N$ 个宽度为 $h=(b-a)/N$ 的子区间。其公式为：\n$$\n\\int_a^b g(x) dx \\approx \\frac{h}{3} \\left[ g(x_0) + 4\\sum_{i=1, i\\text{ odd}}^{N-1} g(x_i) + 2\\sum_{i=2, i\\text{ even}}^{N-2} g(x_i) + g(x_N) \\right]\n$$\n其中 $x_i = a+ih$。在我们的问题中，积分是针对 $\\lambda_{\\text{trunc}}(E_{\\max}, N)$，因此 $g(E) = f(E)$，$a=0$，且 $b=E_{\\max}$。步长为 $h=E_{\\max}/N$。\n实现过程将在 $N+1$ 个网格点 $E_i = i h$（其中 $i=0, \\dots, N$）上计算被积函数 $f(E)$ 的值，并根据上述公式应用加权和。注意 $f(0)=0$。\n\n**4. 误差量化**\n\n两种误差源定义如下：\n- 截断误差：$\\varepsilon_{\\text{trunc}} = \\left|\\lambda-\\lambda_{\\text{trunc}}(E_{\\max})\\right|$。该误差源于用有限截止能量 $E_{\\max}$ 替代无限积分上限。\n- 离散化误差：$\\varepsilon_{\\text{disc}} = \\left|\\lambda_{\\text{Simpson}}(E_{\\max},N)-\\lambda_{\\text{trunc}}(E_{\\max})\\right|$。该误差源于使用数值求积法则来近似计算在 $[0, E_{\\max}]$ 上的定积分。\n\n这些量将针对每个测试用例，使用推导出的解析公式和 Simpson 法则的数值实现来计算。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import gamma, gammainc\n\ndef solve():\n    \"\"\"\n    Computes neutron-induced reaction rates and associated errors for\n    a set of test cases using analytical and numerical methods.\n    \"\"\"\n    \n    # Fixed constants in SI units\n    M_N = 1.67492749804e-27  # Neutron mass (kg)\n    K_B = 1.380649e-23         # Boltzmann constant (J/K)\n    SIGMA_0 = 1.0e-28          # Cross section parameter (m^2)\n    SIGMA_1 = 5.0e-49          # Cross section parameter (m^2/J)\n    SIGMA_2 = 2.0e-69          # Cross section parameter (m^2/J^2)\n\n    # Test suite: (T in Kelvin, alpha, N panels)\n    test_cases = [\n        (600.0, 5.0, 100),\n        (600.0, 1.0, 100),\n        (600.0, 5.0, 2),\n        (3000.0, 2.0, 50),\n        (300.0, 0.1, 20),\n    ]\n\n    all_results = []\n\n    for T, alpha, N in test_cases:\n        # Characteristic energy\n        kT = K_B * T\n        \n        # --- Analytical Calculation of the True Reaction Rate (lambda) ---\n        # lambda = (2 * sqrt(2*kT/m) / sqrt(pi)) * [s0 + 2*s1*kT + 6*s2*kT^2]\n        \n        common_factor = (2.0 * np.sqrt(2.0 * kT / M_N)) / np.sqrt(np.pi)\n        poly_full = SIGMA_0 + 2.0 * SIGMA_1 * kT + 6.0 * SIGMA_2 * kT**2\n        lambda_true = common_factor * poly_full\n\n        # --- Analytical Calculation of the Truncated Rate (lambda_trunc) ---\n        # lambda_trunc = C_factor * sqrt(kT) * \n        #                [s0*g(2,a) + s1*kT*g(3,a) + s2*kT^2*g(4,a)]\n        # where g(s,x) is the lower incomplete gamma function.\n        # g(s,x) = Gamma(s) * P(s,x), where P is regularized version.\n        g2_alpha = gamma(2) * gammainc(2, alpha)\n        g3_alpha = gamma(3) * gammainc(3, alpha)\n        g4_alpha = gamma(4) * gammainc(4, alpha)\n\n        poly_trunc = (SIGMA_0 * g2_alpha +\n                      SIGMA_1 * kT * g3_alpha +\n                      SIGMA_2 * kT**2 * g4_alpha)\n        \n        # The factor outside the polynomial is slightly different.\n        # It's (2*sqrt(2*kT/m) / sqrt(pi)) * (1/n!) term-by-term.\n        # The (1/n!) is already in the ratio of g(n+1,a)/Gamma(n+1)\n        # So it's: \n        # lambda_trunc = (common_factor/poly_full) * [s0*g(2,a)/1! + s1*2kT*g(3,a)/2! + s2*6kT^2*g(4,a)/3!]\n        # The simplest way is to use the full expression.\n        \n        lambda_trunc = common_factor * (\n            SIGMA_0 * gammainc(2, alpha) +\n            2 * SIGMA_1 * kT * gammainc(3, alpha) +\n            6 * SIGMA_2 * kT**2 * gammainc(4, alpha)\n        )\n        \n        # --- Numerical Calculation using Composite Simpson's Rule (lambda_simpson) ---\n        E_max = alpha * kT\n\n        # Define the integrand f(E) = sigma(E) * v(E) * phi_E(E)\n        # Simplified form: f(E) = C_T * (s0*E + s1*E^2 + s2*E^3) * exp(-E/kT)\n        c_T = (2.0 * np.sqrt(2.0 / M_N)) / (np.sqrt(np.pi) * kT**1.5)\n        \n        def integrand(E_vals):\n            # Vectorized integrand evaluation\n            # Handle E=0 case to avoid 0*inf from 1/sqrt(E) if original form used.\n            # The simplified form with E as factor is 0 at E=0.\n            if isinstance(E_vals, (int, float)):\n                if E_vals == 0: return 0.0\n            \n            poly_E = SIGMA_0 * E_vals + SIGMA_1 * E_vals**2 + SIGMA_2 * E_vals**3\n            return c_T * poly_E * np.exp(-E_vals / kT)\n\n        E_points = np.linspace(0, E_max, N + 1)\n        y_points = integrand(E_points)\n        \n        h = E_max / N\n        lambda_simpson = (h / 3.0) * (\n            y_points[0] + \n            4.0 * np.sum(y_points[1:-1:2]) + \n            2.0 * np.sum(y_points[2:-1:2]) + \n            y_points[-1]\n        )\n\n        # --- Error Calculation ---\n        eps_trunc = np.abs(lambda_true - lambda_trunc)\n        eps_disc = np.abs(lambda_simpson - lambda_trunc)\n\n        all_results.append([lambda_true, lambda_simpson, eps_trunc, eps_disc])\n    \n    # Format the final output string exactly as specified.\n    # e.g., [[a1,b1,c1,d1],[a2,b2,c2,d2],...]\n    formatted_quads = [f\"[{','.join(map(str, quad))}]\" for quad in all_results]\n    final_output_string = f\"[{','.join(formatted_quads)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "物理学中的许多积分，特别是在阈值能量附近，都表现出奇异性，这对标准均匀网格的求积方法构成了挑战。与其诉诸于高度专业化的求积法则，一种更巧妙的策略是通过坐标变换来“平滑”被积函数，从而使其适用于简单的数值方法。本练习将引导你通过分析变换后被積函數的性質，推导出恢复复合梯形法则名义收敛阶数所需的最佳网格分级指数$p$ 。",
            "id": "3550921",
            "problem": "在计算核物理中，反应率积分通常涉及依赖于能量的核截面，这些核截面在阈值附近表现出代数端点奇点。考虑一个热中子吸收率的确定性计算\n$$\nI \\;=\\; \\int_{a}^{b} \\sigma(x)\\,\\phi(x)\\,dx,\n$$\n其中 $x$ 表示动能，$a$ 是一个阈值能量（$a \\geq 0$），$b > a$ 是一个有限上界，$\\phi(x)$ 是光滑有界的中子通量，且截面在阈值附近的行为如下\n$$\n\\sigma(x) \\;\\sim\\; C\\,(x-a)^{-\\alpha} \\quad \\text{as } x \\to a^{+},\n$$\n其中 $C>0$ 为某个常数且 $0  \\alpha  1$。这个端点奇点是可积的，但它会降低等步长求积法则的性能。为解决此问题，采用一个由以下映射定义的分级网格\n$$\nx(t) \\;=\\; a + (b-a)\\,t^{p}, \\qquad t \\in [0,1], \\qquad p0,\n$$\n并在变量 $t$ 的 $[0,1]$ 区间上应用具有 $N$ 个等长子区间的复化梯形法则来近似 $I$。\n\n从积分的变量替换公式和单个区间上梯形法则的泰勒展开余项出发，通过分析变换后被积函数在 $t=0$ 附近的正则性以及在 $N$ 个区间上累积的全局误差，来证明使用分级网格的合理性。然后，确定分级指数 $p$ 的显式选择（作为 $\\alpha$ 的函数），该选择能够恢复复化梯形法则的标称二阶全局收敛率，即当 $N \\to \\infty$ 时，误差行为如同 $\\mathcal{O}(N^{-2})$。\n\n将 $p$ 的最终答案表示为单个闭式解析表达式。无需进行数值取整。",
            "solution": "具有端点奇点的积分可以通过分级映射 $x(t) = a + (b-a)\\,t^{p}$ 进行变换，其中 $t \\in [0,1]$ 且 $p0$。根据变量替换公式，\n$$\nI \\;=\\; \\int_{0}^{1} f(x(t))\\,x'(t)\\,dt,\n$$\n其中 $f(x) = \\sigma(x)\\,\\phi(x)$ 且\n$$\nx'(t) \\;=\\; p\\,(b-a)\\,t^{p-1}.\n$$\n在 $x=a$ 附近，我们有 $f(x) \\sim C\\,(x-a)^{-\\alpha}\\,\\phi(x)$，并且由于 $\\phi(x)$ 是光滑有界的，其在 $x=a$ 附近的行为不会引入额外的奇点。使用 $x-a = (b-a)\\,t^{p}$，变换后的被积函数变为\n$$\ng(t) \\;=\\; f(x(t))\\,x'(t) \\;\\sim\\; \\big(C\\,(b-a)^{-\\alpha}\\,t^{-\\alpha p}\\big)\\,\\big(p\\,(b-a)\\,t^{p-1}\\big)\n\\;=\\; C\\,p\\,(b-a)^{1-\\alpha}\\,t^{p(1-\\alpha)-1}.\n$$\n定义 $\\beta := p\\,(1-\\alpha)$。那么，在 $t=0$ 附近，\n$$\ng(t) \\;\\sim\\; K\\,t^{\\beta-1}, \\qquad K := C\\,p\\,(b-a)^{1-\\alpha}.\n$$\n\n我们现在来分析应用于 $g(t)$ 的复化梯形法则，其中 $[0,1]$ 区间被均匀划分为 $N$ 个长度为 $h=1/N$ 的子区间。对于一个足够光滑的函数，在单个区间 $[t_{i-1},t_{i}]$（其中 $t_{i}=i\\,h$）上的局部截断误差由带余项的泰勒定理给出：\n$$\n\\varepsilon_{i} \\;=\\; -\\frac{h^{3}}{12}\\,g''(\\xi_{i}),\n$$\n其中 $\\xi_{i}\\in(t_{i-1},t_{i})$。虽然 $g$ 在 $t=0$ 处不是全局二阶连续可微的，但我们仍然可以通过分析 $g''(t)$ 在 $t=0$ 附近的奇异行为来估计误差。对主阶行为 $g(t)\\sim K\\,t^{\\beta-1}$ 求导可得\n$$\ng'(t) \\;\\sim\\; K\\,(\\beta-1)\\,t^{\\beta-2}, \\qquad\ng''(t) \\;\\sim\\; K\\,(\\beta-1)\\,(\\beta-2)\\,t^{\\beta-3}.\n$$\n因此，对于 $i=1,2,\\dots,N$，在主阶意义下有 $\\xi_{i}\\approx t_{i}\\approx i/N$，局部误差满足\n$$\n|\\varepsilon_{i}| \\;\\approx\\; \\frac{h^{3}}{12}\\,\\big|g''(\\xi_{i})\\big|\n\\;\\lesssim\\; C_{1}\\,N^{-3}\\,\\left(\\frac{i}{N}\\right)^{\\beta-3}\n\\;=\\; C_{1}\\,N^{-\\beta}\\,i^{\\beta-3},\n$$\n其中 $C_{1}0$ 是某个吸收了 $K$ 和因子 $(\\beta-1)(\\beta-2)$ 的常数。\n\n对局部误差求和，全局误差的量级（在阶数上）由以下不等式界定\n$$\n|E_{N}| \\;\\lesssim\\; C_{1}\\,N^{-\\beta}\\,\\sum_{i=1}^{N} i^{\\beta-3}.\n$$\n我们使用幂和的标准渐近行为来估计这个求和。令 $\\gamma := \\beta-3$。那么\n- 如果 $\\gamma-1$ （即 $\\beta2$），$\\sum_{i=1}^{N} i^{\\gamma} \\sim \\frac{N^{\\gamma+1}}{\\gamma+1}$，因此\n$$\n|E_{N}| \\;\\lesssim\\; C_{2}\\,N^{-\\beta}\\,N^{\\beta-2} \\;=\\; C_{2}\\,N^{-2},\n$$\n其中 $C_{2}0$ 为某个常数。\n- 如果 $\\gamma=-1$ （即 $\\beta=2$），$\\sum_{i=1}^{N} i^{-1} \\sim \\ln N$，因此\n$$\n|E_{N}| \\;\\lesssim\\; C_{3}\\,N^{-2}\\,\\ln N,\n$$\n其中 $C_{3}0$ 为某个常数。\n- 如果 $\\gamma-1$ （即 $\\beta2$），$\\sum_{i=1}^{N} i^{\\gamma}$ 关于 $N$ 一致有界，因此\n$$\n|E_{N}| \\;\\lesssim\\; C_{4}\\,N^{-\\beta},\n$$\n其中 $C_{4}0$ 为某个常数。\n\n因此，在分级网格上，变换后的复化梯形法则具有如下的全局误差率\n$$\n|E_{N}| \\;=\\; \\mathcal{O}\\!\\left(N^{-\\min\\{2,\\,\\beta\\}}\\right),\n$$\n当 $\\beta=2$ 时带有一个对数因子。为了恢复在二阶连续可微函数上梯形法则所特有的标称二阶全局收敛率 $\\mathcal{O}(N^{-2})$，我们需要 $\\beta2$，即，\n$$\np\\,(1-\\alpha) \\;\\; 2.\n$$\n满足此阈值条件的最小代数选择是\n$$\np \\;=\\; \\frac{2}{1-\\alpha}.\n$$\n在实践中，任何选择 $p\\frac{2}{1-\\alpha}$ 都可以消除临界的对数因子并保证 $\\mathcal{O}(N^{-2})$ 的收敛率，而显式表达式 $p=\\frac{2}{1-\\alpha}$ 确定了在变换后的设定中恢复标称阶数的阈值分级。\n\n因此，具有指数\n$$\np \\;=\\; \\frac{2}{1-\\alpha}\n$$\n的分级网格 $x=a+(b-a)\\,t^{p}$ 证明了该方法的合理性，并确定了在存在代数端点奇点 $f(x)\\sim (x-a)^{-\\alpha}$（其中 $0  \\alpha  1$）的情况下，为恢复复化梯形法则的二阶全局收敛性所需的分级。",
            "answer": "$$\\boxed{\\frac{2}{1-\\alpha}}$$"
        },
        {
            "introduction": "核反应截面中常见的布莱特-维格纳共振峰等局部尖銳特征，使得采用均匀网格的数值积分效率低下。解决此类问题的现代方法是自适应求积，该算法能自动在被积函数变化剧烈的区域加密网格。本练习是一个综合性的实践，要求你从零开始构建一个自适应高斯-勒让德积分器，以精确计算包含多个共振峰的反应率，从而掌握处理真实物理模型中复杂函数的关键计算技术 。",
            "id": "3550919",
            "problem": "设计并实现一种自适应复合高斯-勒让德积分方法，用于在计算核物理中计算关于一维能量变量的能量加权反应率积分。需要计算的积分为\n$$\nI \\;=\\; \\int_{E_\\min}^{E_\\max} \\sigma(E)\\,\\phi(E)\\,dE,\n$$\n其中 $\\sigma(E)$ 是一个具有多个共振结构的横截面，$\\phi(E)$ 是一个代表中子通量密度的能量分布。目标是构建一个复合规则，该规则能够自动在窄共振峰周围加密积分区间，并通过自适应细分来控制局部截断误差。\n\n使用以下具有物理动机且被广泛接受的形式：\n\n- 具有多个 Breit–Wigner (洛伦兹) 共振的横截面，\n$$\n\\sigma(E) \\;=\\; \\sum_{i=1}^{N_r} A_i \\,\\frac{\\left(\\frac{\\Gamma_i}{2}\\right)^2}{(E - E_i)^2 + \\left(\\frac{\\Gamma_i}{2}\\right)^2},\n$$\n其中 $E$ 是能量，$E_i$ 是共振中心能量，$\\Gamma_i$ 是半高全宽，$A_i$ 是振幅。$\\sigma(E)$ 的单位为靶恩 (barns)。\n\n- 选择在有限区间上归一化的类麦克斯韦-玻尔兹曼分布作为中子通量密度，\n$$\n\\phi(E) \\;=\\; C \\, E^{1/2} \\, \\exp\\!\\left(-\\frac{E}{kT}\\right),\n$$\n其中 $kT$ 是以电子伏特为单位的热能标度，$C$ 是一个归一化常数，使得\n$$\n\\int_{E_\\min}^{E_\\max} \\phi(E)\\, dE \\;=\\; 1.\n$$\n经过此归一化后，$\\phi(E)$ 的单位为逆电子伏特，积分 $I$ 的单位为靶恩。您必须通过已知的归一化积分来精确处理 $C$\n$$\n\\int_{E_\\min}^{E_\\max} E^{1/2}\\, e^{-E/(kT)}\\, dE \\;=\\; (kT)^{3/2}\\,\\Big[\\gamma\\!\\left(\\tfrac{3}{2},\\tfrac{E_\\max}{kT}\\right) - \\gamma\\!\\left(\\tfrac{3}{2},\\tfrac{E_\\min}{kT}\\right)\\Big],\n$$\n其中 $\\gamma(\\cdot,\\cdot)$ 是下不完全伽马函数。因此，\n$$\nC \\;=\\; \\left[(kT)^{3/2}\\,\\Big(\\gamma\\!\\left(\\tfrac{3}{2},\\tfrac{E_\\max}{kT}\\right) - \\gamma\\!\\left(\\tfrac{3}{2},\\tfrac{E_\\min}{kT}\\right)\\Big)\\right]^{-1}.\n$$\n\n用于推导和算法设计的基础原理：\n\n- 黎曼积分的定义，以及光滑的被积函数可以在积分区间上通过多项式插值来近似的事实。\n- 勒让德多项式在 $[-1,1]$ 上的正交性，以及高斯-勒让德积分的性质，即使用 $n$ 个节点可以精确地积出最高为 $2n-1$ 次的多项式。\n- 对于足够光滑的函数，通过区间对分来减小误差，从而能够通过单区间积分与两个子区间积分之和的差来估计局部误差。\n- 使用不完全伽马函数进行归一化，以确保物理单位的一致性。\n\n您的程序必须实现：\n\n- 一个 $n$ 阶复合高斯-勒让德积分，其中每个区间的节点数 $n$ 固定为 $n=8$。\n- 一种自适应加密策略，该策略通过比较在 $[a,b]$ 上的单个 $n$ 节点区间估计值与在 $[a,m]$ 和 $[m,b]$（其中 $m=(a+b)/2$）上的两个 $n$ 节点区间估计值之和，来获得局部误差估计器。使用一个加密准则，如果估计的局部误差 $\\varepsilon_\\text{loc}$ 满足 $\\varepsilon_\\text{loc} \\le \\max(\\tau_\\text{abs}, \\tau_\\text{rel}\\,|I_\\text{panel}|)$，则接受该区间。其中绝对容差 $\\tau_\\text{abs}$ 和相对容差 $\\tau_\\text{rel}$ 均设置为 $\\tau_\\text{abs}=\\tau_\\text{rel}=10^{-8}$。\n- 通过在初始分区中植入断点，实现窄共振峰周围的区间自动加密。这些断点位于 $E_i \\pm m\\,(\\Gamma_i/2)$（其中 $m \\in \\{-3,-2,-1,0,1,2,3\\}$），且落在 $[E_\\min,E_\\max]$ 范围内。将这些断点与端点合并并排序。随后的自适应加密将基于这些种子区间进行。\n\n题目不涉及角度；不使用带有角度单位的三角函数。所有能量单位均为电子伏特。最终数值结果必须以靶恩为单位报告。\n\n测试套件。您的程序必须对以下四种情况计算积分 $I$，每种情况由 $\\{E_\\min,E_\\max,kT; (E_i,\\Gamma_i,A_i)_{i=1}^{N_r}\\}$ 指定：\n\n- 情况 1（单个宽共振峰）：\n  - 区间 $[E_\\min,E_\\max] = [\\,0.0,\\,10.0\\,]$ eV, $kT=1.0$ eV。\n  - 共振峰：$N_r=1$，参数为 $(E_1,\\Gamma_1,A_1)=(\\,3.0,\\,1.0,\\,10.0\\,)$。\n\n- 情况 2（多个峰，包括一个非常窄的峰）：\n  - 区间 $[E_\\min,E_\\max] = [\\,0.0,\\,20.0\\,]$ eV, $kT=2.0$ eV。\n  - 共振峰：$N_r=3$，参数为 $(E_1,\\Gamma_1,A_1)=(\\,5.0,\\,0.2,\\,80.0\\,)$、$(E_2,\\Gamma_2,A_2)=(\\,12.0,\\,1.5,\\,30.0\\,)$、$(E_3,\\Gamma_3,A_3)=(\\,8.0,\\,0.05,\\,150.0\\,)$。\n\n- 情况 3（靠近边界的窄共振峰）：\n  - 区间 $[E_\\min,E_\\max] = [\\,0.0,\\,5.0\\,]$ eV, $kT=0.5$ eV。\n  - 共振峰：$N_r=2$，参数为 $(E_1,\\Gamma_1,A_1)=(\\,0.1,\\,0.01,\\,200.0\\,)$、$(E_2,\\Gamma_2,A_2)=(\\,4.5,\\,0.02,\\,100.0\\,)$。\n\n- 情况 4（重叠的共振峰）：\n  - 区间 $[E_\\min,E_\\max] = [\\,5.0,\\,15.0\\,]$ eV, $kT=1.5$ eV。\n  - 共振峰：$N_r=3$，参数为 $(E_1,\\Gamma_1,A_1)=(\\,9.5,\\,0.4,\\,70.0\\,)$、$(E_2,\\Gamma_2,A_2)=(\\,10.0,\\,0.5,\\,65.0\\,)$、$(E_3,\\Gamma_3,A_3)=(\\,10.3,\\,0.3,\\,80.0\\,)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含四个积分估计值，按情况 1 到 4 的顺序排列，形式为逗号分隔的列表并用方括号括起来，例如\n$[\\;I_1,I_2,I_3,I_4\\;]$，\n每个 $I_j$ 是一个以靶恩为单位的浮点数。不要打印单位或任何附加文本；只输出列表字面量。根据 $\\sigma(E)$ 的单位和 $\\phi(E)$ 的归一化，数值答案的单位应为靶恩。",
            "solution": "该问题要求设计并实现一个自适应复合高斯-勒让德积分方案，用以计算能量加权反应率积分 $I = \\int_{E_\\min}^{E_\\max} \\sigma(E)\\,\\phi(E)\\,dE$。这是计算物理学中的一项任务，它将物理建模与数值分析相结合。解决方案包括精确定义被积函数，构建一个稳健的数值积分算法，并根据指定的测试用例进行实现。\n\n### 1. 被积函数：反应率核函数\n\n被积函数是两个函数的乘积：横截面 $\\sigma(E)$ 和中子通量密度 $\\phi(E)$。\n\n**横截面 $\\sigma(E)$：** 横截面被建模为 $N_r$ 个 Breit-Wigner 共振峰的总和。每个共振峰是一个以能量 $E_i$ 为中心、半高全宽 (FWHM) 为 $\\Gamma_i$、振幅为 $A_i$ 的洛伦兹峰。其公式由下式给出：\n$$\n\\sigma(E) = \\sum_{i=1}^{N_r} A_i \\,\\frac{\\left(\\frac{\\Gamma_i}{2}\\right)^2}{(E - E_i)^2 + \\left(\\frac{\\Gamma_i}{2}\\right)^2}\n$$\n该函数的单位是靶恩。窄共振峰（小的 $\\Gamma_i$）的存在会产生尖锐的峰值，在这些地方函数变化剧烈，对数值积分构成了挑战。\n\n**中子通量密度 $\\phi(E)$：** 通量由一个截断在有限能量区间 $[E_\\min, E_\\max]$ 上的类麦克斯韦-玻尔兹曼分布描述。其函数形式为：\n$$\n\\phi(E) = C \\, E^{1/2} \\, \\exp\\!\\left(-\\frac{E}{kT}\\right)\n$$\n其中 $k$ 是玻尔兹曼常数，$T$ 是温度，$kT$ 代表一个热能标度。常数 $C$ 由归一化条件 $\\int_{E_\\min}^{E_\\max} \\phi(E)\\, dE = 1$ 确定。这确保了 $\\phi(E)$ 是指定能量范围上的一个概率密度函数，其单位为逆能量（例如 $\\text{eV}^{-1}$）。因此，积分 $I$ 的单位正确地为靶恩。\n\n为了求出 $C$，我们必须计算归一化积分：\n$$\n\\int_{E_\\min}^{E_\\max} E^{1/2}\\, e^{-E/(kT)}\\, dE\n$$\n使用换元法 $u = E/(kT)$，我们有 $E = u(kT)$ 和 $dE = (kT)du$。积分变换为：\n$$\n\\int_{E_{\\min}/(kT)}^{E_{\\max}/(kT)} (u kT)^{1/2}\\, e^{-u}\\, (kT)du = (kT)^{3/2} \\int_{E_{\\min}/(kT)}^{E_{\\max}/(kT)} u^{1/2}\\, e^{-u}\\, du\n$$\n该定积分可以用下不完全伽马函数 $\\gamma(s,x) = \\int_0^x t^{s-1} e^{-t} dt$ 来表示。当 $s = 3/2$ 时，积分变为：\n$$\n(kT)^{3/2} \\left[ \\gamma\\!\\left(\\frac{3}{2}, \\frac{E_\\max}{kT}\\right) - \\gamma\\!\\left(\\frac{3}{2}, \\frac{E_\\min}{kT}\\right) \\right]\n$$\n归一化常数 $C$ 是这个值的倒数：\n$$\nC = \\left[ (kT)^{3/2} \\left( \\gamma\\!\\left(\\frac{3}{2}, \\frac{E_\\max}{kT}\\right) - \\gamma\\!\\left(\\frac{3}{2}, \\frac{E_\\min}{kT}\\right) \\right) \\right]^{-1}\n$$\n\n### 2. 数值积分方法\n\n对于具有尖锐、局域化特征的被积函数，标准的固定区间积分法则效率低下。需要采用自适应积分方法，该方法能在函数值变化剧烈的区域自动加密积分网格。\n\n**高斯-勒让德积分：** 基本的构建模块是一个 $n$ 点高斯-勒让德积分法则。对于指定的 $n=8$，该法则将函数 $g(x)$ 在标准区间 $[-1, 1]$ 上的积分近似为一个加权和：\n$$\n\\int_{-1}^{1} g(x)\\,dx \\approx \\sum_{i=1}^{n} w_i g(x_i)\n$$\n其中 $x_i$ 是 $n$ 次勒让德多项式 $P_n(x)$ 的根，$w_i$ 是相应的权重。该法则对于次数最高为 $2n-1 = 15$ 的多项式是精确的。为了将其应用于任意区间 $[a, b]$，我们使用线性变换 $E(x) = \\frac{b-a}{2}x + \\frac{a+b}{2}$：\n$$\n\\int_{a}^{b} f(E)\\,dE = \\frac{b-a}{2} \\int_{-1}^{1} f(E(x))\\,dx \\approx \\frac{b-a}{2} \\sum_{i=1}^{n} w_i f\\left(\\frac{b-a}{2}x_i + \\frac{a+b}{2}\\right)\n$$\n\n**自适应细分与误差估计：** 自适应算法的核心在于误差估计和区间细分。对于给定的区间 $[a, b]$，我们计算积分的两个近似值：\n1. $I_1$：使用单个 $n$ 点法则在 $[a, b]$ 上估计的积分。\n2. $I_2$：一个更精确的估计，通过在 $m=(a+b)/2$ 处将区间二分，并对每个子区间 $[a,m]$ 和 $[m,b]$ 应用 $n$ 点法则后的结果求和得到。\n\n较粗糙估计 $I_1$ 的局部误差估计为 $\\varepsilon_\\text{loc} = |I_2 - I_1|$。如果该误差满足指定的容差准则，则接受该区间，并将其贡献（更精确的值 $I_2$）加到总积分中。该准则为：\n$$\n\\varepsilon_\\text{loc} \\le \\max(\\tau_\\text{abs}, \\tau_\\text{rel}\\,|I_2|)\n$$\n其中 $\\tau_\\text{abs} = 10^{-8}$ 和 $\\tau_\\text{rel} = 10^{-8}$ 分别是绝对容差和相对容差。如果未满足准则，则拒绝区间 $[a,b]$，并将两个子区间 $[a,m]$ 和 $[m,b]$ 添加到待处理的区间列表中。\n\n**初始区间植入：** 为提高效率，算法会植入一组初始区间，这些区间已预先集中在被积函数的难点部分——即窄共振峰周围。对于每个共振峰 $(E_i, \\Gamma_i, A_i)$，我们生成一组断点 $E_i \\pm m(\\Gamma_i/2)$，其中 $m \\in \\{-3, -2, -1, 0, 1, 2, 3\\}$。收集这些点以及区间端点 $E_\\min$ 和 $E_\\max$，限制它们在 $(E_\\min, E_\\max)$ 范围内，进行去重和排序。这样就创建了 $[E_\\min, E_\\max]$ 的一个初始分区，其区间在共振峰附近密集，在其他地方稀疏。然后，自适应算法在这些初始区间上逐一进行。\n\n### 3. 算法实现\n\n整个算法实现如下：\n1. 对每个测试用例，获取参数 $\\{E_\\min, E_\\max, kT\\}$ 和共振峰列表。\n2. 使用科学计算库（如 `SciPy`）提供的涉及下不完全伽马函数的公式，计算通量 $\\phi(E)$ 的归一化常数 $C$。\n3. 构建被积函数 $f(E) = \\sigma(E)\\,\\phi(E)$。\n4. 根据共振峰的位置和宽度生成初始的、已排序的断点列表。这定义了初始的区间集合。\n5. 将总积分初始化为 $0$。\n6. 使用一个栈（LIFO 数据结构）来管理自适应积分的区间。初始时，将植入分区中的所有区间压入栈中。\n7. 当栈不为空时：\n    a. 从栈中弹出一个区间 $[a, b]$。\n    b. 计算单区间积分 $I_1$ 和双区间积分 $I_2$。\n    c. 计算误差估计 $\\varepsilon_\\text{loc} = |I_2 - I_1|$ 和容差 $T = \\max(\\tau_\\text{abs}, \\tau_\\text{rel}\\,|I_2|)$。\n    d. 如果 $\\varepsilon_\\text{loc} \\le T$，则将 $I_2$ 加到总积分上。\n    e. 否则，将两个子区间 $[a, (a+b)/2]$ 和 $[(a+b)/2, b]$ 压入栈中。\n8. 总积分的最终值即为该测试用例的结果。对所有四个用例重复此过程。实现中使用 `NumPy` 进行高效的向量化计算，使用 `SciPy` 计算特殊函数 $\\gamma(s,x)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma, gammainc\n\n# Global constants from the problem\nN_NODES = 8\nTOL_ABS = 1e-8\nTOL_REL = 1e-8\nINITIAL_BREAKPOINT_M = [-3, -2, -1, 0, 1, 2, 3]\n\n# Pre-compute Gauss-Legendre nodes and weights for the base rule\nLG_NODES, LG_WEIGHTS = np.polynomial.legendre.leggauss(N_NODES)\n\ndef _sigma(E, resonances):\n    \"\"\"\n    Computes the Breit-Wigner cross section.\n    E can be a scalar or a numpy array for vectorized computation.\n    \"\"\"\n    total_sigma = np.zeros_like(E, dtype=float)\n    for E_i, Gamma_i, A_i in resonances:\n        gamma_half_sq = (Gamma_i / 2.0)**2\n        total_sigma += A_i * gamma_half_sq / ((E - E_i)**2 + gamma_half_sq)\n    return total_sigma\n\ndef _phi(E, C, kT):\n    \"\"\"\n    Computes the normalized Maxwell-Boltzmann-like flux density.\n    E can be a scalar or a numpy array.\n    \"\"\"\n    E = np.asanyarray(E)\n    phi_val = np.zeros_like(E, dtype=float)\n    # The condition E > 0 prevents incorrect values or warnings for sqrt(0) or log(0)\n    # in more complex models, and correctly evaluates phi(0) = 0.\n    mask = E > 0\n    phi_val[mask] = C * np.sqrt(E[mask]) * np.exp(-E[mask] / kT)\n    return phi_val\n\ndef _integrate_panel(f, a, b):\n    \"\"\"\n    Computes the integral of a function f over a single panel [a, b]\n    using the pre-computed n-point Gaussian-Legendre rule.\n    \"\"\"\n    h = (b - a) / 2.0\n    c = (a + b) / 2.0\n    eval_points = c + h * LG_NODES\n    f_values = f(eval_points)\n    integral = h * np.sum(LG_WEIGHTS * f_values)\n    return integral\n\ndef compute_rate_integral(params):\n    \"\"\"\n    Computes the reaction rate integral for a given set of physical parameters.\n    \"\"\"\n    E_min, E_max, kT = params['E_min'], params['E_max'], params['kT']\n    resonances = params['resonances']\n\n    # 1. Calculate normalization constant C for phi(E)\n    s = 1.5\n    # The lower incomplete gamma function is needed: gamma(s,x)\n    # scipy.special.gammainc(s, x) computes the regularized version P(s,x).\n    # gamma(s,x) = P(s,x) * Gamma(s).\n    gamma_s = gamma(s)\n    \n    # an argument to gammainc cannot be 0 if s is not integer; however scipy handles it.\n    if kT == 0: return 0.0\n    x_max = E_max / kT\n    x_min = E_min / kT\n    \n    if E_min >= E_max: return 0.0\n\n    term_max = gammainc(s, x_max) * gamma_s if x_max > 0 else 0.0\n    term_min = gammainc(s, x_min) * gamma_s if x_min > 0 else 0.0\n    \n    norm_integral_part = term_max - term_min\n    norm_integral = (kT**1.5) * norm_integral_part\n    \n    C = 1.0 / norm_integral if norm_integral > 1e-100 else 0.0\n\n    # 2. Define the full integrand f(E)\n    def integrand(E):\n        return _sigma(E, resonances) * _phi(E, C, kT)\n\n    # 3. Generate initial breakpoints\n    breakpoints = {E_min, E_max}\n    for E_i, Gamma_i, _ in resonances:\n        for m in INITIAL_BREAKPOINT_M:\n            pt = E_i + m * (Gamma_i / 2.0)\n            if E_min  pt  E_max:\n                breakpoints.add(pt)\n    \n    sorted_breakpoints = sorted(list(breakpoints))\n\n    # 4. Perform adaptive quadrature using a stack (LIFO)\n    panel_stack = [(sorted_breakpoints[i], sorted_breakpoints[i+1]) for i in range(len(sorted_breakpoints)-1)]\n    \n    total_integral = 0.0\n    \n    max_panels_processed = 1_000_000 # Safety break\n    panel_count = 0\n\n    while panel_stack:\n        if panel_count > max_panels_processed:\n            raise RuntimeError(\"Exceeded maximum number of panel subdivisions. Tolerance may be too strict.\")\n\n        a, b = panel_stack.pop()\n        m = (a + b) / 2.0\n        \n        # Integral over one coarse panel\n        I1 = _integrate_panel(integrand, a, b)\n        \n        # Integral over two finer sub-panels\n        I_left = _integrate_panel(integrand, a, m)\n        I_right = _integrate_panel(integrand, m, b)\n        I2 = I_left + I_right\n        \n        error_est = abs(I2 - I1)\n        # Use the more accurate integral I2 for the relative tolerance check\n        tolerance = max(TOL_ABS, TOL_REL * abs(I2))\n\n        if error_est = tolerance:\n            # Panel is accepted. Add its contribution (the more accurate I2).\n            total_integral += I2\n            panel_count += 1\n        else:\n            # Panel is rejected. Push sub-panels onto stack for further refinement.\n            # Push right panel first, then left, so left sub-panel is processed first.\n            panel_stack.append((m, b))\n            panel_stack.append((a, m))\n\n    return total_integral\n\ndef solve():\n    \"\"\"\n    Main orchestrator function that defines test cases and prints results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'E_min': 0.0, 'E_max': 10.0, 'kT': 1.0, \n         'resonances': [(3.0, 1.0, 10.0)]},\n        # Case 2\n        {'E_min': 0.0, 'E_max': 20.0, 'kT': 2.0, \n         'resonances': [(5.0, 0.2, 80.0), (12.0, 1.5, 30.0), (8.0, 0.05, 150.0)]},\n        # Case 3\n        {'E_min': 0.0, 'E_max': 5.0, 'kT': 0.5, \n         'resonances': [(0.1, 0.01, 200.0), (4.5, 0.02, 100.0)]},\n        # Case 4\n        {'E_min': 5.0, 'E_max': 15.0, 'kT': 1.5, \n         'resonances': [(9.5, 0.4, 70.0), (10.0, 0.5, 65.0), (10.3, 0.3, 80.0)]}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_rate_integral(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}