{
    "hands_on_practices": [
        {
            "introduction": "在为核物理问题选择合适的数值求解器时，首要任务是理解其稳定性和收敛阶。这些基本属性决定了求解器在给定步长下能否产生一个有物理意义的解，以及其计算精度如何随步长减小而提高。本练习  提供了一个实践机会，通过构建一个模拟核反应网络中典型时间尺度分离的线性测试问题，亲手验证前向欧拉、后向欧拉和梯形法则等基本方法的理论稳定性边界和误差阶。",
            "id": "3565661",
            "problem": "考虑一个常微分方程 (ODE) 的线性、时不变初值问题，$\\,\\dfrac{d\\mathbf{y}}{dt} = J\\,\\mathbf{y}\\,$，初始条件为 $\\,\\mathbf{y}(0)=\\mathbf{y}_0\\,$，其中 $\\,J\\in\\mathbb{R}^{n\\times n}\\,$ 具有已知的实谱，其谱模拟了核反应时间尺度的大跨度分离（许多跨越多个数量级的负实特征值）。您将分析用于以时间步长 $\\,h>0\\,$ 推进解的单步法，将其绝对稳定性预测与观测到的放大情况进行比较，并从第一性原理验证其误差阶。\n\n从以下基本出发点开始：\n- 线性常系数系统的精确解为 $\\,\\mathbf{y}(t+h)=\\exp(h J)\\,\\mathbf{y}(t)\\,$，\n- 单步法产生形如 $\\,\\mathbf{y}_{n+1} = \\mathcal{R}_h(J)\\,\\mathbf{y}_n\\,$ 的更新，其中 $\\,\\mathcal{R}_h(J)\\,$ 是一个依赖于方法的放大算子，\n- 对于一个全局阶为 $\\,p\\,$ 的方法，当从 $\\,t\\,$ 时刻的精确状态开始时，其单步局部截断误差的量级为 $\\,\\mathcal{O}(h^{p+1})\\,$，\n\n请为以下每种方法推导：\n- 根据定义的离散更新推导出放大算子 $\\,\\mathcal{R}_h(J)\\,$，不要使用预先记下的快捷公式，\n- 用特征值 $\\,\\lambda\\in\\Lambda(J)\\,$ 和步长 $\\,h\\,$ 表述的绝对稳定性预测，\n- 当从 $\\,t\\,$ 时刻的精确状态开始时，预期的单步误差阶。\n\n需要分析的方法是：\n- Forward Euler (explicit Euler),\n- Backward Euler (implicit Euler),\n- Trapezoidal rule (Crank–Nicolson).\n\n为确保科学真实性，使用具有严格负实特征值的对称矩阵 $\\,J\\,$，以使 $\\,J\\,$ 可被正交矩阵对角化。通过 $\\,\\mathrm{QR}\\,$ 分解（其中 $\\,R\\,$ 的对角元为正）得到的唯一正交因子，从一个固定的 $\\,3\\times 3\\,$ 实矩阵确定性地构造 $\\,J\\,$ 为 $\\,J = Q\\,\\mathrm{diag}(\\Lambda)\\,Q^\\top\\,$：\n- 设 $\\,M \\in \\mathbb{R}^{3\\times 3}\\,$ 为\n$$\nM=\\begin{bmatrix}\n1  2  3\\\\\n4  5  6\\\\\n7  8  10\n\\end{bmatrix}.\n$$\n通过 $\\,\\mathrm{QR}\\,$ 分解定义 $\\,Q R = M\\,$，其中 $\\,Q^\\top Q = I\\,$ 且 $\\,R\\,$ 的所有对角元均为正。使用这个相同的 $\\,Q\\,$ 来构建下面的每个 $\\,J\\,$，并取初始条件为单位范数向量 $\\,\\mathbf{y}_0 = \\dfrac{1}{\\|\\mathbf{v}\\|_2}\\,\\mathbf{v}\\,$，其中 $\\,\\mathbf{v}=[1,-1,2]^\\top\\,$。\n\n实现并测试以下情况：\n\n- 情况 A (显式稳定性的边界及其外部)：令 $\\,\\Lambda_1=\\{-1,-10,-100\\}\\,$ 且 $\\,J_1=Q\\,\\mathrm{diag}(\\Lambda_1)\\,Q^\\top\\,$。\n  - 对 Forward Euler 方法使用步长 $\\,h_1=10^{-2}\\,$ 和 $\\,h_2=3\\times 10^{-2}\\,$。\n  - 将观测到的单步放大定义为诱导谱范数 $\\,\\|\\mathcal{R}_{h}(J_1)\\|_2\\,$，如果 $\\,\\|\\mathcal{R}_{h}(J_1)\\|_21\\,$，则称该方法为“观测上稳定”。\n  - 与用 $\\,\\Lambda_1\\,$ 和 $\\,h\\,$ 表述的理论绝对稳定性预测进行比较。报告两个布尔值：该方法在 $\\,h_1\\,$ 处是否观测上稳定，以及在 $\\,h_2\\,$ 处是否观测上稳定。\n\n- 情况 B (隐式方法的绝对稳定性)：使用相同的 $\\,J_1\\,$，对 Backward Euler 方法使用 $\\,h_3=5\\,$。报告一个布尔值，指示该方法是否观测上稳定（同样使用 $\\,\\|\\mathcal{R}_{h_3}(J_1)\\|_21\\,$）。\n\n- 情况 C (大负特征值与最刚性模式的阻尼)：令 $\\,\\Lambda_2=\\{-1,-10,-10^6\\}\\,$ 且 $\\,J_2=Q\\,\\mathrm{diag}(\\Lambda_2)\\,Q^\\top\\,$。使用时间步长 $\\,h_4=10^{-2}\\,$，考虑与最刚性特征值 $\\,\\lambda_\\ast=-10^6\\,$ 相关的特征方向上的放大因子。\n  - 报告 Backward Euler 方法在 $\\,z_\\ast = h_4\\,\\lambda_\\ast\\,$ 处计算的标量单步放大率。\n  - 报告 Trapezoidal rule 在相同的 $\\,z_\\ast\\,$ 处计算的标量单步放大率。\n  这两个数字都必须以无单位的浮点数值形式报告。\n\n- 情况 D (单步局部误差阶的验证)：令 $\\,\\Lambda_3=\\{-\\tfrac{1}{2},-1,-2\\}\\,$ 且 $\\,J_3=Q\\,\\mathrm{diag}(\\Lambda_3)\\,Q^\\top\\,$。对于 Forward Euler、Backward Euler 和 Trapezoidal rule 中的每一种方法，计算从 $\\,t=0\\,$ 时刻的精确状态开始的单步误差：\n  - 对于 $\\,h_{\\mathrm{big}}=10^{-1}\\,$，计算 $\\,\\mathbf{y}_{\\mathrm{num}}=\\mathcal{R}_{h_{\\mathrm{big}}}(J_3)\\,\\mathbf{y}_0\\,$ 和 $\\,\\mathbf{y}_{\\mathrm{exact}}=\\exp(h_{\\mathrm{big}} J_3)\\,\\mathbf{y}_0\\,$，并取误差 $\\,e_{\\mathrm{big}}=\\|\\mathbf{y}_{\\mathrm{num}}-\\mathbf{y}_{\\mathrm{exact}}\\|_2\\,$。\n  - 对于 $\\,h_{\\mathrm{small}}=5\\times 10^{-2}\\,$，重复上述步骤以获得 $\\,e_{\\mathrm{small}}\\,$。\n  - 分别报告 Forward Euler、Backward Euler 和 Trapezoidal rule 的三个比率 $\\,\\rho_{\\mathrm{FE}}=\\dfrac{e_{\\mathrm{big}}}{e_{\\mathrm{small}}}\\,$、$\\,\\rho_{\\mathrm{BE}}=\\dfrac{e_{\\mathrm{big}}}{e_{\\mathrm{small}}}\\,$ 和 $\\,\\rho_{\\mathrm{TR}}=\\dfrac{e_{\\mathrm{big}}}{e_{\\mathrm{small}}}\\,$。\n  - 同时，报告三个布尔值，指示每个比率是否在方法单步局部截断误差的理论预期因子 $\\,2^{p+1}\\,$ 的相对容差 $\\,\\tau=0.15\\,$ 范围内，其中 $\\,p\\,$ 是全局阶。即，检查 $\\,\\left|\\dfrac{\\rho}{2^{p+1}}-1\\right|  \\tau\\,$。\n\n不涉及角度单位。所有报告的量都是无单位的。您的程序必须实现上述构造，并生成以下单行输出，其中包含所有结果，以逗号分隔的列表形式并用方括号括起，顺序完全如下：\n- 情况 A：在 $\\,h_1\\,$ 处的观测稳定性 (布尔值)，在 $\\,h_2\\,$ 处的观测稳定性 (布尔值)；\n- 情况 B：在 $\\,h_3\\,$ 处的观测稳定性 (布尔值)；\n- 情况 C：Backward Euler 的刚性模式放大率 (浮点数)，Trapezoidal rule 的刚性模式放大率 (浮点数)；\n- 情况 D：$\\,\\rho_{\\mathrm{FE}}\\,$ (浮点数)，$\\,\\rho_{\\mathrm{BE}}\\,$ (浮点数)，$\\,\\rho_{\\mathrm{TR}}\\,$ (浮点数)，Forward Euler 的比率在容差内 (布尔值)，Backward Euler 的比率在容差内 (布尔值)，以及 Trapezoidal rule 的比率在容差内 (布尔值)。\n\n您的程序应生成包含结果的单行输出，形式为逗号分隔的列表并用方括号括起（例如，$\\,\\left[\\text{result}_1,\\text{result}_2,\\ldots\\right]\\,$）。不应打印任何额外文本。所有计算必须使用上述定义进行数值计算，并且必须严格按照规定进行比较。",
            "solution": "该问题要求分析三种用于线性初值问题 $\\frac{d\\mathbf{y}}{dt} = J\\,\\mathbf{y}$ 的单步数值方法，其中 $J$ 是一个具有负实特征值的可对角化实矩阵。分析涉及推导放大算子、陈述稳定性条件以及确定每种方法的局部误差阶。然后在一系列指定的情况下对这些理论发现进行数值检验。\n\n**理论推导**\n\n单步法将时间 $t_{n+1}=t_n+h$ 的解近似为 $\\mathbf{y}_{n+1} = \\mathcal{R}_h(J)\\,\\mathbf{y}_n$，其中 $\\mathcal{R}_h(J)$ 是放大算子。如果方法的应用不放大数值解的任何分量，则该方法是绝对稳定的。对于正规矩阵 $J$（包括对称矩阵），这等价于要求放大算子的谱半径至多为 1：$\\rho(\\mathcal{R}_h(J)) \\le 1$。对于 $J$ 的所有特征值 $\\lambda$，此条件又可简化为 $|R(h\\lambda)| \\le 1$，其中 $R(z)$ 是与算子对应的标量稳定性函数。\n\n**1. Forward Euler (显式) 方法**\n该方法通过近似时间 $t_n$ 处的导数来定义：\n$$ \\frac{\\mathbf{y}_{n+1} - \\mathbf{y}_n}{h} = J\\,\\mathbf{y}_n $$\n\n- **放大算子**：求解 $\\mathbf{y}_{n+1}$ 得到显式更新 $\\mathbf{y}_{n+1} = \\mathbf{y}_n + hJ\\,\\mathbf{y}_n = (I + hJ)\\mathbf{y}_n$。因此，放大算子是：\n  $$ \\mathcal{R}_h(J) = I + hJ $$\n\n- **绝对稳定性预测**：标量稳定性函数为 $R(z) = 1+z$。稳定性要求对 $\\Lambda(J)$ 中所有的 $\\lambda$ 都有 $|1+h\\lambda| \\le 1$。由于 $\\lambda$ 是负实数，设 $\\lambda  0$。条件变为 $-1 \\le 1+h\\lambda \\le 1$，可简化为 $-2 \\le h\\lambda \\le 0$。因为 $h>0$ 且 $\\lambda0$，条件 $h\\lambda \\le 0$ 总是满足的。剩下的条件是 $h\\lambda \\ge -2$，即 $h \\le -2/\\lambda$。这必须对模最大的特征值成立，从而对步长 $h$ 施加了限制。\n\n- **单步误差阶**：假设 $\\mathbf{y}_n$ 是精确的，单步误差是精确解 $\\mathbf{y}(t_n+h) = \\exp(hJ)\\mathbf{y}(t_n)$ 与数值近似 $\\mathbf{y}_{n+1}$ 之间的差。对指数进行泰勒展开得到 $\\exp(hJ) = I + hJ + \\frac{1}{2}h^2J^2 + \\mathcal{O}(h^3)$。误差算子为 $\\exp(hJ) - \\mathcal{R}_h(J) = \\frac{1}{2}h^2J^2 + \\mathcal{O}(h^3)$。单步局部截断误差为 $\\mathcal{O}(h^2)$，对应于全局收敛阶 $p=1$。\n\n**2. Backward Euler (隐式) 方法**\n该方法通过近似时间 $t_{n+1}$ 处的导数来定义：\n$$ \\frac{\\mathbf{y}_{n+1} - \\mathbf{y}_n}{h} = J\\,\\mathbf{y}_{n+1} $$\n\n- **放大算子**：为了找到 $\\mathbf{y}_{n+1}$，必须解一个线性系统：$(I - hJ)\\mathbf{y}_{n+1} = \\mathbf{y}_n$。这得到 $\\mathbf{y}_{n+1} = (I - hJ)^{-1}\\mathbf{y}_n$。放大算子是：\n  $$ \\mathcal{R}_h(J) = (I - hJ)^{-1} $$\n\n- **绝对稳定性预测**：标量稳定性函数为 $R(z) = (1-z)^{-1}$。稳定性要求 $|1-h\\lambda| \\ge 1$。对于任何具有 $\\text{Re}(\\lambda) \\le 0$ 的 $\\lambda$ 和 $h>0$，此条件都成立。特别地，对于负实数 $\\lambda$，$1-h\\lambda > 1$，因此条件总是满足的。该方法是 A-稳定的，对此类问题的稳定性没有步长限制。\n\n- **单步误差阶**：误差算子为 $\\exp(hJ) - (I - hJ)^{-1}$。仔细展开表明其为 $-\\frac{1}{2}h^2J^2 + \\mathcal{O}(h^3)$。单步局部截断误差为 $\\mathcal{O}(h^2)$，对应于全局阶 $p=1$。\n\n**3. Trapezoidal Rule (Crank-Nicolson)**\n该方法对 $t_n$ 和 $t_{n+1}$ 处的右端项求平均：\n$$ \\frac{\\mathbf{y}_{n+1} - \\mathbf{y}_n}{h} = \\frac{1}{2} (J\\,\\mathbf{y}_n + J\\,\\mathbf{y}_{n+1}) $$\n\n- **放大算子**：重新整理得到 $(I - \\frac{h}{2}J)\\mathbf{y}_{n+1} = (I + \\frac{h}{2}J)\\mathbf{y}_n$。放大算子是：\n  $$ \\mathcal{R}_h(J) = \\left(I - \\frac{h}{2}J\\right)^{-1} \\left(I + \\frac{h}{2}J\\right) $$\n\n- **绝对稳定性预测**：标量稳定性函数为 $R(z) = (1+z/2)/(1-z/2)$。对于所有具有 $\\text{Re}(\\lambda) \\le 0$ 的 $\\lambda$，稳定性条件 $|R(h\\lambda)| \\le 1$ 都满足。该方法是 A-稳定的。\n\n- **单步误差阶**：误差算子是 $\\exp(hJ) - \\mathcal{R}_h(J)$。稳定性函数 $R(z)$ 是 $\\exp(z)$ 的 $(1,1)$-Padé 近似。误差级数从三阶项开始：$\\exp(z) - R(z) = -\\frac{1}{12}z^3 + \\mathcal{O}(z^4)$。单步局部截断误差为 $\\mathcal{O}(h^3)$，对应于全局阶 $p=2$。\n\n**数值实现**\n数值测试按照问题的具体要求进行。矩阵 $Q$ 从给定矩阵 $M$ 的 QR 分解中获得，并强制 $R$ 的对角元为正。矩阵 $J_k$ 构造为 $J_k = Q\\,\\mathrm{diag}(\\Lambda_k)\\,Q^\\top$。对于每种情况，使用这些组件数值计算所需的量。情况 D 中的误差比率预期遵循 $\\rho = (h_{\\mathrm{big}}/h_{\\mathrm{small}})^{p+1} = 2^{p+1}$，对于欧拉方法 ($p=1$) 该值为 $4$，对于 Trapezoidal rule ($p=2$) 该值为 $8$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the specified numerical analysis problem regarding ODE solvers.\n    \"\"\"\n    \n    # --- Common Setup ---\n    M = np.array([\n        [1., 2., 3.],\n        [4., 5., 6.],\n        [7., 8., 10.]\n    ])\n    \n    # Unique QR factorization with R having a positive diagonal\n    Q, R = np.linalg.qr(M)\n    s = np.diag(np.sign(np.diag(R)))\n    Q = Q @ s\n    # R_new = s @ R # not needed for problem but completes the factorization\n    \n    v = np.array([1., -1., 2.])\n    y0 = v / np.linalg.norm(v)\n\n    results = []\n\n    # --- Case A: Forward Euler Stability ---\n    Lambda1 = np.diag([-1., -10., -100.])\n    J1 = Q @ Lambda1 @ Q.T\n    h1 = 1e-2\n    h2 = 3e-2\n    I = np.identity(3)\n\n    # h1 test\n    R_h1_J1 = I + h1 * J1\n    norm1 = np.linalg.norm(R_h1_J1, ord=2)\n    stable_h1 = norm1  1.0\n    results.append(stable_h1)\n\n    # h2 test\n    R_h2_J1 = I + h2 * J1\n    norm2 = np.linalg.norm(R_h2_J1, ord=2)\n    stable_h2 = norm2  1.0\n    results.append(stable_h2)\n\n    # --- Case B: Backward Euler Stability ---\n    h3 = 5.0\n    # R_h3_J1 = inv(I - h3 * J1)\n    # Using np.linalg.solve is more stable than explicit inversion.\n    # We need the operator matrix itself for the norm, so inversion is appropriate here.\n    R_h3_J1 = np.linalg.inv(I - h3 * J1)\n    norm3 = np.linalg.norm(R_h3_J1, ord=2)\n    stable_h3 = norm3  1.0\n    results.append(stable_h3)\n\n    # --- Case C: Stiff Mode Amplification ---\n    lambda_star = -1e6\n    h4 = 1e-2\n    z_star = h4 * lambda_star\n\n    # Backward Euler amplification magnitude\n    amp_be = np.abs(1.0 / (1.0 - z_star))\n    results.append(amp_be)\n\n    # Trapezoidal rule amplification magnitude\n    amp_tr = np.abs((1.0 + z_star/2.0) / (1.0 - z_star/2.0))\n    results.append(amp_tr)\n    \n    # --- Case D: Verification of Error Orders ---\n    Lambda3 = np.diag([-0.5, -1.0, -2.0])\n    J3 = Q @ Lambda3 @ Q.T\n    h_big = 1e-1\n    h_small = 5e-2\n    tau = 0.15\n\n    methods_spec = {\n        'FE': {'p': 1, 'op': lambda J, h: I + h * J},\n        'BE': {'p': 1, 'op': lambda J, h: np.linalg.inv(I - h * J)},\n        'TR': {'p': 2, 'op': lambda J, h: np.linalg.inv(I - h*J/2.0) @ (I + h*J/2.0)},\n    }\n    \n    error_ratios = []\n    ratio_checks = []\n\n    method_order = ['FE', 'BE', 'TR']\n    \n    for method_key in method_order:\n        spec = methods_spec[method_key]\n        p = spec['p']\n        op_func = spec['op']\n\n        # Calculate numerical and exact solutions for h_big\n        R_big = op_func(J3, h_big)\n        y_num_big = R_big @ y0\n        y_exact_big = expm(h_big * J3) @ y0\n        e_big = np.linalg.norm(y_num_big - y_exact_big)\n\n        # Calculate numerical and exact solutions for h_small\n        R_small = op_func(J3, h_small)\n        y_num_small = R_small @ y0\n        y_exact_small = expm(h_small * J3) @ y0\n        e_small = np.linalg.norm(y_num_small - y_exact_small)\n\n        # Calculate error ratio\n        rho = e_big / e_small\n        error_ratios.append(rho)\n        \n        # Verify ratio against theory\n        theoretical_ratio = (h_big / h_small)**(p + 1)\n        check = np.abs(rho / theoretical_ratio - 1.0)  tau\n        ratio_checks.append(check)\n\n    results.extend(error_ratios)\n    results.extend(ratio_checks)\n    \n    # --- Final Output ---\n    # Convert booleans to lowercase 'true'/'false' as per standard Python str()\n    # and format floats. The problem implies standard string conversion is fine.\n    # Example format: [True,False,1.23] - [true,false,1.23] which is JSON-like.\n    # Python str(True) is 'True'. The example in the prompt is math, not code output.\n    # We will let python's default string conversion for bools handle it.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多物理过程，例如向平衡态的弛豫，本质上是耗散的，其特征是某个类似自由能的量（李雅普诺夫函数）随时间单调递减。一个优秀的数值方法应该能在离散时间步上保持这一关键物理特性。本练习  将引导你从线性稳定性分析过渡到非线性系统，通过实现并测试代数稳定的隐式方法（如Radau IIA），来验证它们如何在数值上保证一个二次李雅普诺夫函数的衰减，即使在使用大时间步长求解刚性问题时也是如此。",
            "id": "3565705",
            "problem": "考虑一个用于简化核反应网络中近平衡弛豫的无量纲耗散模型。设 $y(t) \\in \\mathbb{R}^3$ 表示物种丰度与平衡态的偏差，并假设其动力学由自治常微分方程 (ODE) 控制\n$$\n\\dot{y}(t) = f(y(t)) = -M \\nabla V(y(t)),\n$$\n其中 $V(y)$ 是一个光滑的类自由能李雅普诺夫函数，$M$ 是一个常数、对称正定的迁移率矩阵。假设一个二次李雅普诺夫函数\n$$\nV(y) = \\tfrac{1}{2} y^\\top H y,\n$$\n其中 $H$ 是一个常数、对称正定矩阵，表示自由能在平衡点附近的局部曲率（海森矩阵）。在此设定下，\n$$\n\\nabla V(y) = H y, \\quad f(y) = -M H y.\n$$\n所有量均为无量纲。\n\n对于耗散梯度流，其基本事实如下：\n- 如果 $M$ 和 $H$ 是对称正定的，那么 $V$ 是该连续时间系统的一个严格李雅普诺夫函数，沿着解的轨迹满足 $\\frac{d}{dt} V(y(t)) \\le 0$。\n- 应用于此类单调耗散系统的代数稳定隐式时间积分格式，在适当条件下，预计会产生一个关于 $n$ 非增的离散时间序列 $V(y_n)$。\n\n你的任务是实现三种隐式初值 ODE 求解器，并针对一个固定的刚性线性梯度流实例，在多个时间步上数值验证离散李雅普诺夫衰减 $V(y_{n+1}) \\le V(y_n)$。需要实现的求解器是：\n- 后向欧拉法（隐式欧拉法）。\n- 隐式中点法（梯形法则）。\n- $3$ 阶两级 Radau IIA 龙格-库塔法。\n\n不要使用此处陈述的任何特殊公式；相反，应从它们对自治系统的标准定义出发，推导并实现这些隐式格式。由于对于所选的 $V(y)$，$f(y)$ 是线性的，因此每个隐式步都简化为求解一个线性系统，该系统依赖于所用方法、步长以及矩阵 $A = M H$。\n\n使用以下具体的、科学上合理的矩阵和初始条件：\n$$\nH = \\begin{bmatrix}\n4.0  0.5  0.0 \\\\\n0.5  2.0  0.3 \\\\\n0.0  0.3  10.0\n\\end{bmatrix}, \\quad\nM = \\begin{bmatrix}\n1.5  0.1  0.0 \\\\\n0.1  0.5  0.0 \\\\\n0.0  0.0  3.0\n\\end{bmatrix}, \\quad\ny_0 = \\begin{bmatrix}\n1.0 \\\\ -0.8 \\\\ 0.5\n\\end{bmatrix}.\n$$\n定义 $A = M H$ 和 $V(y) = \\tfrac{1}{2} y^\\top H y$。\n\n对于每个测试用例，从 $y_0$ 开始，使用指定的方法和恒定步长 $h$ 模拟 $N$ 步。模拟结束后，评估离散李雅普诺夫序列在每一步是否非增，即对于所有从 $0$ 到 $N-1$ 的 $n$，$V(y_{n+1}) \\le V(y_n)$ 是否成立。为了考虑浮点舍入误差，将小于容差 $\\varepsilon = 10^{-10}$ 的违规情况视为非违规；形式上，要求在所有步中 $V(y_{n+1}) \\le V(y_n) + \\varepsilon$。\n\n实现并测试以下参数集（方法、步长、步数），构成测试套件：\n- 后向欧拉法，$h = 0.05$，$N = 40$。\n- 隐式中点法（梯形法则），$h = 0.5$，$N = 20$。\n- 两级 Radau IIA，$h = 5.0$，$N = 6$。\n- 后向欧拉法，$h = 10.0$，$N = 4$。\n- 隐式中点法（梯形法则），$h = 10.0$，$N = 4$。\n- 两级 Radau IIA，$h = 20.0$，$N = 3$。\n\n对于每个测试用例，产生一个布尔结果：如果在容差 $\\varepsilon$ 内，离散李雅普诺夫序列 $V(y_n)$ 在所有步中都是非增的，则为 $\\,\\texttt{True}\\,$，否则为 $\\,\\texttt{False}\\,$。\n\n最终输出格式：你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，$[r_1,r_2,\\dots,r_6]$）。每个 $r_i$ 必须是对应于上面所列顺序中第 $i$ 个测试用例的布尔值。由于问题是无量纲的，因此不需要物理单位，也不涉及角度。",
            "solution": "该问题被评估为有效。它在科学上基于常微分方程（ODE）的数值方法理论，特别是在耗散动力系统的背景下，这在物理学和化学中很常见。该问题是适定的，为获得唯一解提供了所有必需的矩阵、初始条件和参数。矩阵 $H$ 和 $M$ 被指定为对称正定，这是系统成为具有有效李雅普诺夫函数的梯度流的关键条件。一项检查证实了此属性：\n对于 $H = \\begin{bmatrix} 4.0  0.5  0.0 \\\\ 0.5  2.0  0.3 \\\\ 0.0  0.3  10.0 \\end{bmatrix}$，其顺序主子式为 $D_1 = 4.0 > 0$，$D_2 = 4.0 \\cdot 2.0 - 0.5^2 = 7.75 > 0$，以及 $D_3 = \\det(H) = 77.14 > 0$。\n对于 $M = \\begin{bmatrix} 1.5  0.1  0.0 \\\\ 0.1  0.5  0.0 \\\\ 0.0  0.0  3.0 \\end{bmatrix}$，其顺序主子式为 $D_1 = 1.5 > 0$，$D_2 = 1.5 \\cdot 0.5 - 0.1^2 = 0.74 > 0$，以及 $D_3 = \\det(M) = 2.22 > 0$。\n由于所有顺序主子式均为正，因此 $H$ 和 $M$ 都是对称正定的。“$V(y) = \\frac{1}{2}y^\\top H y$ 是连续系统 $\\dot{y} = -M \\nabla V(y)$ 的严格李雅普诺夫函数”这一前提是正确的，因为其沿轨迹的时间导数为 $\\frac{d}{dt}V(y) = (\\nabla V)^\\top \\dot{y} = (Hy)^\\top(-MHy) = -y^\\top H M H y$。由于 $M$ 是对称正定（SPD）但不一定与 $H$ 可交换，一个更简单的论证是 $\\frac{d}{dt}V(y) = (\\nabla V)^\\top (-M \\nabla V)$。令 $z=\\nabla V$，我们得到 $\\frac{d}{dt}V = -z^\\top M z \\le 0$ 对任何 $z \\neq 0$ 成立，因为 $M$ 是对称正定的。因为 $H$ 可逆，这对任何 $y \\neq 0$ 也成立。因此，该问题是内部一致且形式上可解的。\n\n问题的核心是分析三种隐式时间积分格式应用于刚性线性 ODE 系统 $\\dot{y}(t) = -A y(t)$ 时的行为，其中 $A = MH$。矩阵 $A$ 计算如下：\n$$\nA = M H =\n\\begin{bmatrix}\n1.5  0.1  0.0 \\\\\n0.1  0.5  0.0 \\\\\n0.0  0.0  3.0\n\\end{bmatrix}\n\\begin{bmatrix}\n4.0  0.5  0.0 \\\\\n0.5  2.0  0.3 \\\\\n0.0  0.3  10.0\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n6.05  0.95  0.03 \\\\\n0.65  1.05  0.15 \\\\\n0.0  0.9  30.0\n\\end{bmatrix}\n$$\n李雅普诺夫函数为 $V(y) = \\frac{1}{2} y^\\top H y$。任务是验证在一系列时间步中是否满足 $V(y_{n+1}) \\le V(y_n) + \\varepsilon$，其中 $\\varepsilon = 10^{-10}$ 是一个数值容差。\n\n每种数值方法的更新步推导如下。\n\n**1. 后向欧拉法**\n用于自治 ODE $\\dot{y}=f(y)$ 的后向欧拉法由以下隐式方程定义：\n$$\ny_{n+1} = y_n + h f(y_{n+1})\n$$\n对于线性系统 $\\dot{y} = -Ay$，该方程变为：\n$$\ny_{n+1} = y_n + h (-A y_{n+1}) = y_n - h A y_{n+1}\n$$\n重新整理各项以求解 $y_{n+1}$，得到一个线性系统：\n$$\n(I + hA) y_{n+1} = y_n\n$$\n其中 $I$ 是单位矩阵。通过对给定的 $y_n$ 求解此系统，可以找到新的状态 $y_{n+1}$。\n\n**2. 隐式中点法（梯形法则）**\n用于 $\\dot{y}=f(y)$ 的梯形法则由下式给出：\n$$\ny_{n+1} = y_n + \\frac{h}{2} \\left( f(y_n) + f(y_{n+1}) \\right)\n$$\n对于 $\\dot{y} = -Ay$，代入该公式：\n$$\ny_{n+1} = y_n + \\frac{h}{2} \\left( -A y_n - A y_{n+1} \\right)\n$$\n将包含 $y_{n+1}$ 的项收集到左侧，将包含 $y_n$ 的项收集到右侧，我们得到：\n$$\n\\left(I + \\frac{h}{2}A\\right) y_{n+1} = \\left(I - \\frac{h}{2}A\\right) y_n\n$$\n在每个时间步求解此线性系统以得到 $y_{n+1}$。该方法是 A-稳定的，但不是 L-稳定的，当步长 $h$ 较大时，可能导致刚性分量出现持续的、不衰减的振荡。\n\n**3. 3 阶两级 Radau IIA 方法**\n这是一种具有 $s=2$ 级的隐式龙格-库塔法。其布卓表示为：\n$$\n\\begin{array}{c|cc}\n1/3  5/12  -1/12 \\\\\n1    3/4   1/4 \\\\\n\\hline\n     3/4   1/4\n\\end{array}\n$$\n对于 $\\dot{y} = -Ay$ 的级方程为：\n$$\nk_1 = -A \\left( y_n + h \\left( \\frac{5}{12}k_1 - \\frac{1}{12}k_2 \\right) \\right)\n$$\n$$\nk_2 = -A \\left( y_n + h \\left( \\frac{3}{4}k_1 + \\frac{1}{4}k_2 \\right) \\right)\n$$\n这些方程构成了一个关于级向量 $k_1$ 和 $k_2$ 的耦合线性系统：\n$$\n\\left(I + \\frac{5h}{12}A\\right) k_1 - \\frac{h}{12}A k_2 = -A y_n\n$$\n$$\n-\\frac{3h}{4}A k_1 + \\left(I + \\frac{h}{4}A\\right) k_2 = -A y_n\n$$\n这个 $6 \\times 6$ 的分块系统可以写成：\n$$\n\\begin{bmatrix}\nI + \\frac{5h}{12}A  -\\frac{h}{12}A \\\\\n-\\frac{3h}{4}A  I + \\frac{h}{4}A\n\\end{bmatrix}\n\\begin{pmatrix} k_1 \\\\ k_2 \\end{pmatrix}\n=\n\\begin{pmatrix} -A y_n \\\\ -A y_n \\end{pmatrix}\n$$\n在求解此系统得到 $k_1, k_2 \\in \\mathbb{R}^3$ 后，使用权重 $b_i$ 更新状态：\n$$\ny_{n+1} = y_n + h \\left( \\frac{3}{4}k_1 + \\frac{1}{4}k_2 \\right)\n$$\n该方法是 L-稳定的，能确保对高频分量有强阻尼作用，这对于刚性系统是理想的。\n\n对于每个测试用例，从 $y_0$ 开始，应用相应的方法和步长 $h$ 进行 $N$ 步计算。在每一步 $n \\in \\{0, \\dots, N-1\\}$，计算 $V_n = V(y_n)$ 和 $V_{n+1} = V(y_{n+1})$，并检查条件 $V_{n+1} \\le V_n + \\varepsilon$ 是否满足。如果在任何一步该条件被违反，则该测试用例的结果为 `False`；否则为 `True`。L-稳定方法（后向欧拉法，Radau IIA）预计对于任何步长都能保持李雅普诺夫衰减，而 A-稳定但非 L-稳定的梯形法则在步长较大（即 $h\\lambda_{\\max}$ 很大）时可能会失败，因为其稳定函数趋近于 $-1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests three implicit ODE solvers on a stiff linear gradient-flow system\n    to verify the discrete Lyapunov decay property.\n    \"\"\"\n    \n    # Define problem constants and initial conditions\n    H = np.array([\n        [4.0, 0.5, 0.0],\n        [0.5, 2.0, 0.3],\n        [0.0, 0.3, 10.0]\n    ])\n    M = np.array([\n        [1.5, 0.1, 0.0],\n        [0.1, 0.5, 0.0],\n        [0.0, 0.0, 3.0]\n    ])\n    y0 = np.array([1.0, -0.8, 0.5])\n    epsilon = 1e-10\n    \n    # System matrix and dimension\n    A = M @ H\n    dim = A.shape[0]\n    I = np.identity(dim)\n\n    # Lyapunov function V(y) = 0.5 * y^T * H * y\n    def lyapunov_V(y, H_mat):\n        return 0.5 * y.T @ H_mat @ y\n\n    # Define the six test cases: (method, step size h, number of steps N)\n    test_cases = [\n        ('be', 0.05, 40),\n        ('im', 0.5, 20),\n        ('r2', 5.0, 6),\n        ('be', 10.0, 4),\n        ('im', 10.0, 4),\n        ('r2', 20.0, 3),\n    ]\n\n    results = []\n\n    for method, h, N in test_cases:\n        y = y0.copy()\n        is_nonincreasing = True\n        \n        # Pre-compute solver matrices if they are constant over the steps\n        if method == 'be':\n            solver_mat = I + h * A\n        elif method == 'im':\n            solver_mat = I + h * 0.5 * A\n            rhs_mat = I - h * 0.5 * A\n        elif method == 'r2':\n            # Butcher tableau for 2-stage Radau IIA\n            a11, a12 = 5/12, -1/12\n            a21, a22 = 3/4, 1/4\n            b1, b2 = 3/4, 1/4\n\n            # Construct the 2d x 2d block matrix for stage equations\n            M_radau = np.block([\n                [I + h * a11 * A, h * a12 * A],\n                [h * a21 * A, I + h * a22 * A]\n            ])\n\n        for n in range(N):\n            V_prev = lyapunov_V(y, H)\n            \n            if method == 'be':\n                y_next = np.linalg.solve(solver_mat, y)\n            \n            elif method == 'im':\n                rhs_vec = rhs_mat @ y\n                y_next = np.linalg.solve(solver_mat, rhs_vec)\n            \n            elif method == 'r2':\n                # Solve for stage derivatives k1, k2\n                rhs_k = -A @ y\n                rhs_block = np.concatenate([rhs_k, rhs_k])\n                \n                k_block = np.linalg.solve(M_radau, rhs_block)\n                k1 = k_block[:dim]\n                k2 = k_block[dim:]\n\n                # Update step\n                y_next = y + h * (b1 * k1 + b2 * k2)\n            \n            y = y_next\n            V_next = lyapunov_V(y, H)\n            \n            if V_next  V_prev + epsilon:\n                is_nonincreasing = False\n                break\n        \n        results.append(is_nonincreasing)\n\n    # Print the final results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "核合成网络常常涉及跨越多个数量级的时间尺度，例如快的中子俘获与慢的$\\beta$衰变。在这种情况下，对整个系统使用单一的全隐式方法可能计算成本过高。本练习  介绍了一种高效的策略：隐式-显式（IMEX）多速率积分。你将亲手构建一个混合求解器，用隐式方法处理慢（通常是刚性）过程，用显式方法处理快过程，并学习如何量化这种方法拆分所引入的“分裂误差”，这对于理解和控制多尺度模拟的精度至关重要。",
            "id": "3565707",
            "problem": "考虑一个富中子核合成流中，科学上合理的、极简程式化的双同位素等待点子系统。设丰度由向量 $\\mathbf{N}(t) = [N_1(t), N_2(t)]^\\top$ 表示，其中 $N_1(t)$ 代表等待点前同位素的布居数，$N_2(t)$ 代表等待点同位素的布居数。假设中子环境恒定，且有效的单中子俘获率和β衰变率不随时间变化。其耦合速率方程为\n$$\n\\frac{d}{dt}\\mathbf{N}(t) = \\mathbf{R}_{\\text{cap}}(\\mathbf{N}(t)) + \\mathbf{R}_{\\beta}(\\mathbf{N}(t)),\n$$\n其中，俘获过程将 $N_1$ 驱动为 $N_2$，而β衰变过程将 $N_2$ 变回 $N_1$。各分量由充分混合布居的基本反应速率定律（在静态热力学环境中具有恒定速率系数的线性质量作用）定义：\n$$\n\\mathbf{R}_{\\text{cap}}(\\mathbf{N}) = \\begin{bmatrix} -\\lambda_{\\text{cap}} N_1 \\\\ +\\lambda_{\\text{cap}} N_1 \\end{bmatrix}, \\quad\n\\mathbf{R}_{\\beta}(\\mathbf{N}) = \\begin{bmatrix} +\\lambda_{\\beta} N_2 \\\\ -\\lambda_{\\beta} N_2 \\end{bmatrix},\n$$\n其中 $\\lambda_{\\text{cap}}$ 和 $\\lambda_{\\beta}$ 的单位均为 $\\mathrm{s}^{-1}$。这个简化的同位素对构成一个 $N_1(t)+N_2(t)$ 为常数的守恒封闭子系统，适合用于孤立等待点的分配效应。\n\n您需要基于第一性原理，为此初值问题构建一个隐式-显式（IMEX）多速率积分器。在此构建中：\n- 将 $\\mathbf{R}_{\\beta}$ 视为“慢”刚性分量，通过后向欧拉法，在宏观步长 $\\Delta t_s$ 上进行隐式推进。\n- 将 $\\mathbf{R}_{\\text{cap}}$ 视为“快”分量，通过 $m$ 个大小为 $\\Delta t_f = \\Delta t_s/m$ 的前向欧拉法微观步进行显式推进。\n- 在每个宏观步长内，首先应用隐式慢更新，然后使用 $m$ 个显式微观步推进快分量。\n\n从常微分方程的定义、慢分量的后向欧拉更新以及快分量的前向欧拉更新出发，推导一个宏观步长的离散更新映射并实现它。不要使用预先组合或简化的更新公式；直接从上述定义中为隐式求解推导所需的任何代数。\n\n为了量化等待点附近的分配误差，请将 IMEX 多速率解与一个参考解进行比较。该参考解是通过使用基于反向微分公式（BDF）法的高精度刚性求解器对完整的未分裂系统进行积分得到的。两次积分使用相同的初始条件、物理参数和最终时间。将最终等待点丰度的偏差定义为\n$$\n\\delta N_2 = N_{2,\\text{IMEX}}(T) - N_{2,\\text{ref}}(T),\n$$\n您必须报告每个测试用例的该值。\n\n所有测试用例的初始条件：$N_1(0) = 1$（无量纲数分数），$N_2(0) = 0$（无量纲数分数）。所有时间以 $\\mathrm{s}$ 表示，所有速率以 $\\mathrm{s}^{-1}$ 表示。量 $\\delta N_2$ 是无量纲的。\n\n实现程序以运行以下参数集的测试套件，这些参数集用于探究各种动力学区域，包括一般情况、等待点主导区域、平衡区域，以及一个用于暴露分配误差的粗糙多速率情况：\n\n- 测试用例1（一般“理想路径”）：$\\lambda_{\\text{cap}} = 10$，$\\lambda_{\\beta} = 1$，$T = 1$，$\\Delta t_s = 0.1$，$m = 10$。\n- 测试用例2（由快俘获和慢衰变主导的等待点）：$\\lambda_{\\text{cap}} = 1000$，$\\lambda_{\\beta} = 0.1$，$T = 0.1$，$\\Delta t_s = 0.05$，$m = 100$。\n- 测试用例3（平衡速率）：$\\lambda_{\\text{cap}} = 5$，$\\lambda_{\\beta} = 5$，$T = 1$，$\\Delta t_s = 0.2$，$m = 5$。\n- 测试用例4（暴露分配误差的粗糙多速率微观步）：$\\lambda_{\\text{cap}} = 100$，$\\lambda_{\\beta} = 0.5$，$T = 0.5$，$\\Delta t_s = 0.25$，$m = 25$。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4]$），其中每个 $x_i$ 是测试用例 $i$ 的 $\\delta N_2$ 的数值，表示为十进制数。使用高精度的参考积分来确保观察到的偏差归因于分配和多速率效应，而不是基准求解器本身。通过选择给定的 $\\Delta t_f$ 和 $m$ 来确保在整个显式更新过程中丰度的数值非负性；不要添加人为截断。",
            "solution": "问题陈述具有科学依据、是良定的，并提供了继续进行所需的所有必要信息。它描述了核天体物理学中一个简化但有效的双同位素系统的物理模型，并提出了一个标准的、尽管具体的数值分析任务。在该模型的背景下，参数是物理上貌似合理的，并且目标定义清晰，可通过计算验证。因此，该问题是有效的。\n\n这个问题的核心是为一个耦合常微分方程（ODE）系统推导并实现一个特定的一阶隐式-显式（IMEX）多速率积分格式，并将其结果与高精度参考解进行比较。该系统描述了由中子俘获和β衰变控制的两种同位素丰度 $N_1(t)$ 和 $N_2(t)$ 的演化。\n\n控制ODE系统由 $\\frac{d}{dt}\\mathbf{N}(t) = \\mathbf{F}(\\mathbf{N}(t))$ 给出，其中 $\\mathbf{N}(t) = [N_1(t), N_2(t)]^\\top$。总变化率 $\\mathbf{F}(\\mathbf{N})$ 被分裂为一个“快”分量 $\\mathbf{R}_{\\text{cap}}(\\mathbf{N})$ 和一个“慢”分量 $\\mathbf{R}_{\\beta}(\\mathbf{N})$。\n$$\n\\frac{d}{dt}\\mathbf{N}(t) = \\mathbf{R}_{\\text{cap}}(\\mathbf{N}(t)) + \\mathbf{R}_{\\beta}(\\mathbf{N}(t))\n$$\n各分量为：\n$$\n\\mathbf{R}_{\\text{cap}}(\\mathbf{N}) = \\begin{bmatrix} -\\lambda_{\\text{cap}} N_1 \\\\ +\\lambda_{\\text{cap}} N_1 \\end{bmatrix}, \\quad\n\\mathbf{R}_{\\beta}(\\mathbf{N}) = \\begin{bmatrix} +\\lambda_{\\beta} N_2 \\\\ -\\lambda_{\\beta} N_2 \\end{bmatrix}\n$$\nIMEX 格式在一个大小为 $\\Delta t_s$ 的宏观步长上推进解。设 $\\mathbf{N}^k$ 为时间 $t_k$ 处的数值解。时间 $t_{k+1} = t_k + \\Delta t_s$ 处的解记为 $\\mathbf{N}^{k+1}$。指定的格式每个宏观步长涉及两个阶段：慢分量的隐式更新，随后是快分量的显式更新。\n\n**阶段1：隐式慢更新**\n\n慢分量 $\\mathbf{R}_{\\beta}$ 使用后向欧拉法在宏观步长 $\\Delta t_s$ 上进行隐式处理。这将状态从 $\\mathbf{N}^k$ 更新到一个中间状态 $\\mathbf{N}^*$。后向欧拉公式为：\n$$\n\\frac{\\mathbf{N}^* - \\mathbf{N}^k}{\\Delta t_s} = \\mathbf{R}_{\\beta}(\\mathbf{N}^*)\n$$\n对于 $\\mathbf{N}^* = [N_1^*, N_2^*]^\\top$ 和 $\\mathbf{N}^k = [N_1^k, N_2^k]^\\top$，以分量形式写出：\n$$\n\\frac{N_1^* - N_1^k}{\\Delta t_s} = \\lambda_{\\beta} N_2^*\n$$\n$$\n\\frac{N_2^* - N_2^k}{\\Delta t_s} = -\\lambda_{\\beta} N_2^*\n$$\n这是一个关于 $N_1^*$ 和 $N_2^*$ 的线性方程组。我们首先求解关于 $N_2^*$ 的第二个方程，因为它与 $N_1^*$ 无关：\n$$\nN_2^* - N_2^k = -\\Delta t_s \\lambda_{\\beta} N_2^* \\implies N_2^*(1 + \\Delta t_s \\lambda_{\\beta}) = N_2^k\n$$\n$$\nN_2^* = \\frac{N_2^k}{1 + \\Delta t_s \\lambda_{\\beta}}\n$$\n将此结果代入第一个方程，我们可以解出 $N_1^*$：\n$$\nN_1^* = N_1^k + \\Delta t_s \\lambda_{\\beta} N_2^*\n$$\n这就定义了中间状态 $\\mathbf{N}^*$。注意，将两个分量方程相加可得 $N_1^* + N_2^* = N_1^k + N_2^k$，这证实了总丰度在此隐式步骤中是守恒的，这对于封闭的 $\\mathbf{R}_{\\beta}$ 子系统是应有的性质。因此，一种数值上更稳健的计算 $N_1^*$ 的方法是：\n$$\nN_1^* = N_1^k + N_2^k - N_2^*\n$$\n\n**阶段2：显式快更新**\n\n快分量 $\\mathbf{R}_{\\text{cap}}$ 使用 $m$ 个前向欧拉法的微观步进行显式处理。每个微观步的大小为 $\\Delta t_f = \\Delta t_s / m$。这个更新序列将状态从 $\\mathbf{N}^*$ 推进到最终状态 $\\mathbf{N}^{k+1}$。\n\n设 $\\mathbf{N}^{(j)}$ 为 $j$ 个微观步之后的状态，初始状态为 $\\mathbf{N}^{(0)} = \\mathbf{N}^*$。从状态 $\\mathbf{N}^{(j-1)}$ 到 $\\mathbf{N}^{(j)}$ 的一个微观步的前向欧拉更新为：\n$$\n\\frac{\\mathbf{N}^{(j)} - \\mathbf{N}^{(j-1)}}{\\Delta t_f} = \\mathbf{R}_{\\text{cap}}(\\mathbf{N}^{(j-1)})\n$$\n以分量形式表示：\n$$\nN_1^{(j)} = N_1^{(j-1)} - \\Delta t_f \\lambda_{\\text{cap}} N_1^{(j-1)} = (1 - \\Delta t_f \\lambda_{\\text{cap}}) N_1^{(j-1)}\n$$\n$$\nN_2^{(j)} = N_2^{(j-1)} + \\Delta t_f \\lambda_{\\text{cap}} N_1^{(j-1)}\n$$\n我们从 $\\mathbf{N}^{(0)} = \\mathbf{N}^*$ 开始，应用此更新 $m$ 次。$N_1$ 的方程可以通过重复应用求解：\n$$\nN_1^{(m)} = (1 - \\Delta t_f \\lambda_{\\text{cap}})^m N_1^{(0)} = (1 - \\Delta t_f \\lambda_{\\text{cap}})^m N_1^*\n$$\n由于算子 $\\mathbf{R}_{\\text{cap}}$ 也是守恒的，对于每个微观步我们都有 $N_1^{(j)} + N_2^{(j)} = N_1^{(j-1)} + N_2^{(j-1)}$。这意味着总丰度在整个 $m$ 个微观步的序列中是守恒的：$N_1^{(m)} + N_2^{(m)} = N_1^{(0)} + N_2^{(0)}$。利用这个守恒性质，我们可以直接求出 $N_2^{(m)}$：\n$$\nN_2^{(m)} = N_1^{(0)} + N_2^{(0)} - N_1^{(m)} = N_1^* + N_2^* - N_1^{(m)}\n$$\n宏观步长结束时的状态是 $\\mathbf{N}^{k+1} = \\mathbf{N}^{(m)}$。\n\n**完整的 IMEX 宏观步长更新映射**\n\n结合两个阶段，从 $\\mathbf{N}^k$到 $\\mathbf{N}^{k+1}$ 的完整更新为：\n1.  **隐式部分：**\n    $$\n    N_2^* = \\frac{N_2^k}{1 + \\Delta t_s \\lambda_{\\beta}}\n    $$\n    $$\n    N_1^* = N_1^k + N_2^k - N_2^*\n    $$\n2.  **显式部分：**\n    $$\n    N_1^{k+1} = \\left(1 - \\frac{\\Delta t_s \\lambda_{\\text{cap}}}{m}\\right)^m N_1^*\n    $$\n    $$\n    N_2^{k+1} = N_1^* + N_2^* - N_1^{k+1}\n    $$\n这组方程定义了要为 IMEX 求解器实现的算法。\n\n**参考解与误差度量**\n为了评估准确性，将最终时间 $T$ 时的 IMEX 解（记为 $\\mathbf{N}_{\\text{IMEX}}(T)$）与一个高精度参考解 $\\mathbf{N}_{\\text{ref}}(T)$进行比较。参考解是通过使用基于反向微分公式（BDF）的刚性求解器（具体为设置了 `method='BDF'` 和严格误差容限的 `scipy.integrate.solve_ivp`）对完整的未分裂 ODE 系统进行积分得到的。完整的系统是：\n$$\n\\frac{dN_1}{dt} = -\\lambda_{\\text{cap}} N_1 + \\lambda_{\\beta} N_2\n$$\n$$\n\\frac{dN_2}{dt} = +\\lambda_{\\text{cap}} N_1 - \\lambda_{\\beta} N_2\n$$\n比较是通过最终等待点丰度的偏差来量化的：\n$$\n\\delta N_2 = N_{2,\\text{IMEX}}(T) - N_{2,\\text{ref}}(T)\n$$\n对每个指定的测试用例都执行此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the problem by running the specified test suite to compare\n    a custom IMEX integrator with a high-accuracy reference solver.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Format: (lambda_cap, lambda_beta, T_final, dt_s, m)\n    test_cases = [\n        (10.0, 1.0, 1.0, 0.1, 10),\n        (1000.0, 0.1, 0.1, 0.05, 100),\n        (5.0, 5.0, 1.0, 0.2, 5),\n        (100.0, 0.5, 0.5, 0.25, 25),\n    ]\n\n    # Initial condition for all cases\n    N0 = np.array([1.0, 0.0])\n\n    results = []\n    for case in test_cases:\n        l_cap, l_beta, T_final, dt_s, m = case\n\n        # Run the IMEX multirate solver\n        N_imex_final = run_imex_solver(l_cap, l_beta, T_final, dt_s, m, N0)\n\n        # Run the high-accuracy reference solver\n        N_ref_final = run_reference_solver(l_cap, l_beta, T_final, N0)\n\n        # Calculate the bias in the waiting-point abundance\n        delta_N2 = N_imex_final[1] - N_ref_final[1]\n        results.append(delta_N2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\ndef run_imex_solver(l_cap, l_beta, T_final, dt_s, m, N0):\n    \"\"\"\n    Implements the derived IMEX multirate integrator.\n    \n    - Slow component (beta-decay) is advanced implicitly with backward-Euler.\n    - Fast component (capture) is advanced explicitly with m forward-Euler steps.\n    \"\"\"\n    # Ensure a whole number of steps\n    num_steps = int(round(T_final / dt_s))\n    \n    dt_f = dt_s / m\n    N = np.array(N0, dtype=float)\n\n    for _ in range(num_steps):\n        # Store current state\n        N_k = N\n\n        # Stage 1: Implicit slow update (Backward Euler for R_beta)\n        # N2_star = N_k[1] / (1 + dt_s * l_beta)\n        # N1_star = N_k[0] + dt_s * l_beta * N2_star\n        # Using the conservative form for N1_star for better numerical stability:\n        N2_star = N_k[1] / (1.0 + dt_s * l_beta)\n        N1_star = N_k[0] + N_k[1] - N2_star\n\n        N_star = np.array([N1_star, N2_star])\n\n        # Stage 2: Explicit fast updates (m steps of Forward Euler for R_cap)\n        # The m-step update can be expressed in a closed form derived in the solution.\n        # This avoids an inner loop for micro-steps.\n        factor = (1.0 - dt_f * l_cap)**m\n        N1_next = N_star[0] * factor\n        # Use conservation of particles for N2\n        N2_next = N_star[0] + N_star[1] - N1_next\n\n        N = np.array([N1_next, N2_next])\n\n    return N\n\ndef run_reference_solver(l_cap, l_beta, T_final, N0):\n    \"\"\"\n    Integrates the full unsplit system using a high-accuracy stiff (BDF) solver.\n    \"\"\"\n    def ode_system(t, N):\n        \"\"\" The right-hand side of the full ODE system. \"\"\"\n        N1, N2 = N\n        dN1_dt = -l_cap * N1 + l_beta * N2\n        dN2_dt =  l_cap * N1 - l_beta * N2\n        return np.array([dN1_dt, dN2_dt])\n\n    # `solve_ivp` with BDF method and tight tolerances for high accuracy.\n    sol = solve_ivp(\n        ode_system,\n        (0, T_final),\n        N0,\n        method='BDF',\n        rtol=1e-13,\n        atol=1e-13\n    )\n\n    # Return the state at the final time T_final\n    return sol.y[:, -1]\n\nsolve()\n```"
        }
    ]
}