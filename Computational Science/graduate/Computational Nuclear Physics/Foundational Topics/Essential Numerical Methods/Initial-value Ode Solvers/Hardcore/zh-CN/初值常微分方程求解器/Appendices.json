{
    "hands_on_practices": [
        {
            "introduction": "在线性稳定性的基础上，本实践将探索如何保持物理性质，这是长期模拟中的一个关键方面。你将处理一个耗散梯度流系统，这是一个平衡过程的模型，它拥有一个类似于自由能的李雅普诺夫函数。通过实现包括先进的Radau IIA方法在内的几种隐式求解器，你将数值验证它们维持李雅普诺夫函数非增性质的能力，这一特性被称为代数稳定性 。",
            "id": "3565705",
            "problem": "考虑一个用于简化核反应网络中近平衡弛豫的无量纲耗散模型。令 $y(t) \\in \\mathbb{R}^3$ 表示物种丰度与平衡态的偏差，并假设其动力学由自治常微分方程（ODE）决定\n$$\n\\dot{y}(t) = f(y(t)) = -M \\nabla V(y(t)),\n$$\n其中 $V(y)$ 是一个光滑的类自由能李雅普诺夫函数，$M$ 是一个常数对称正定迁移率矩阵。假设一个二次李雅普诺夫函数\n$$\nV(y) = \\tfrac{1}{2} y^\\top H y,\n$$\n其中 $H$ 是一个常数对称正定矩阵，表示自由能在平衡点附近的局部曲率（海森矩阵）。在这种设定下，\n$$\n\\nabla V(y) = H y, \\quad f(y) = -M H y.\n$$\n所有量均为无量纲。\n\n对于耗散梯度流，基本事实如下：\n- 如果 $M$ 和 $H$ 是对称正定的，则 $V$ 是该连续时间系统的严格李雅普诺夫函数，沿解满足 $\\frac{d}{dt} V(y(t)) \\le 0$。\n- 在适当条件下，将代数稳定的隐式时间积分格式应用于此类单调耗散系统，预期会产生一个在 $n$ 上非增的离散时间序列 $V(y_n)$。\n\n您的任务是实现三种隐式初值常微分方程求解器，并针对一个固定的刚性线性梯度流实例，在多个时间步长上数值验证离散李雅普诺夫衰减 $V(y_{n+1}) \\le V(y_n)$。需要实现的求解器包括：\n- 后向欧拉法（隐式欧拉法）。\n- 隐式中点法（梯形法则）。\n- $3$ 阶两级 Radau IIA 龙格-库塔法。\n\n请勿使用此处陈述的任何专用公式；相反，应从它们对自治系统的标准定义出发，推导并实现这些隐式格式。因为对于所选的 $V(y)$，$f(y)$ 是线性的，所以每个隐式步骤都简化为求解一个线性系统，该系统取决于所用方法、步长以及矩阵 $A = M H$。\n\n使用以下具体的、科学上合理的矩阵和初始条件：\n$$\nH = \\begin{bmatrix}\n4.0  0.5  0.0 \\\\\n0.5  2.0  0.3 \\\\\n0.0  0.3  10.0\n\\end{bmatrix}, \\quad\nM = \\begin{bmatrix}\n1.5  0.1  0.0 \\\\\n0.1  0.5  0.0 \\\\\n0.0  0.0  3.0\n\\end{bmatrix}, \\quad\ny_0 = \\begin{bmatrix}\n1.0 \\\\ -0.8 \\\\ 0.5\n\\end{bmatrix}.\n$$\n定义 $A = M H$ 和 $V(y) = \\tfrac{1}{2} y^\\top H y$。\n\n对于每个测试用例，从 $y_0$ 开始，使用指定方法和恒定步长 $h$ 模拟 $N$ 步。模拟结束后，评估离散李雅普诺夫序列在每一步是否都是非递增的，即对于从 $0$ 到 $N-1$ 的所有 $n$，$V(y_{n+1}) \\le V(y_n)$ 是否成立。为考虑浮点舍入误差，将小于容差 $\\varepsilon = 10^{-10}$ 的违规视为非违规；形式上，要求对所有步骤都满足 $V(y_{n+1}) \\le V(y_n) + \\varepsilon$。\n\n实现并测试以下参数集（方法、步长、步数），构成测试套件：\n- 后向欧拉法，$h = 0.05$，$N = 40$。\n- 隐式中点法（梯形法则），$h = 0.5$，$N = 20$。\n- 两级 Radau IIA 法，$h = 5.0$，$N = 6$。\n- 后向欧拉法，$h = 10.0$，$N = 4$。\n- 隐式中点法（梯形法则），$h = 10.0$，$N = 4$。\n- 两级 Radau IIA 法，$h = 20.0$，$N = 3$。\n\n对于每个测试用例，生成一个布尔结果：如果在容差 $\\varepsilon$ 下，离散李雅普诺夫序列 $V(y_n)$ 在所有步骤中均为非递增，则为 $\\,\\texttt{True}\\,$，否则为 $\\,\\texttt{False}\\,$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[r_1,r_2,\\dots,r_6]$）。每个 $r_i$ 必须是对应于上面列出顺序的第 $i$ 个测试用例的布尔值。由于问题是无量纲的，因此不需要物理单位，也不涉及角度。",
            "solution": "该问题被评估为有效。它在科学上植根于常微分方程（ODE）数值方法的理论，特别是在耗散动力系统的背景下，这在物理学和化学中很常见。该问题是适定的，为获得唯一解提供了所有必需的矩阵、初始条件和参数。矩阵 $H$ 和 $M$ 被指定为对称正定，这是系统成为具有有效李雅普诺夫函数的梯度流的关键条件。一次检验确认了此属性：\n对于 $H = \\begin{bmatrix} 4.0  0.5  0.0 \\\\ 0.5  2.0  0.3 \\\\ 0.0  0.3  10.0 \\end{bmatrix}$，其顺序主子式为 $D_1 = 4.0  0$，$D_2 = 4.0 \\cdot 2.0 - 0.5^2 = 7.75  0$，以及 $D_3 = \\det(H) = 77.14  0$。\n对于 $M = \\begin{bmatrix} 1.5  0.1  0.0 \\\\ 0.1  0.5  0.0 \\\\ 0.0  0.0  3.0 \\end{bmatrix}$，其顺序主子式为 $D_1 = 1.5  0$，$D_2 = 1.5 \\cdot 0.5 - 0.1^2 = 0.74  0$，以及 $D_3 = \\det(M) = 2.22  0$。\n由于所有顺序主子式均为正，因此 $H$ 和 $M$ 都是对称正定的。前提 $V(y) = \\frac{1}{2}y^\\top H y$ 是连续系统 $\\dot{y} = -M \\nabla V(y)$ 的严格李雅普诺夫函数是正确的，因为其沿轨迹的时间导数为 $\\frac{d}{dt}V(y) = (\\nabla V)^\\top \\dot{y} = (Hy)^\\top(-MHy) = -y^\\top H M H y$。由于 $M$ 是对称正定（SPD）但不必与 $H$ 对易，一个更简单的论证是 $\\frac{d}{dt}V(y) = (\\nabla V)^\\top (-M \\nabla V)$。令 $z=\\nabla V$，我们得到 $\\frac{d}{dt}V = -z^\\top M z  0$ 对任何 $z \\neq 0$ 成立，因为 $M$ 是对称正定的。由于 $H$ 是可逆的，这对任何 $y \\neq 0$ 都成立。因此，该问题内部一致且形式上可解。\n\n问题的核心是分析三种隐式时间积分格式应用于刚性线性常微分方程组 $\\dot{y}(t) = -A y(t)$ 时的行为，其中 $A = MH$。矩阵 $A$ 计算如下：\n$$\nA = M H =\n\\begin{bmatrix}\n1.5  0.1  0.0 \\\\\n0.1  0.5  0.0 \\\\\n0.0  0.0  3.0\n\\end{bmatrix}\n\\begin{bmatrix}\n4.0  0.5  0.0 \\\\\n0.5  2.0  0.3 \\\\\n0.0  0.3  10.0\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n6.05  0.95  0.03 \\\\\n0.65  1.05  0.15 \\\\\n0.0  0.9  30.0\n\\end{bmatrix}\n$$\n李雅普诺夫函数为 $V(y) = \\frac{1}{2} y^\\top H y$。任务是验证在一个时间步序列中是否满足 $V(y_{n+1}) \\le V(y_n) + \\varepsilon$，其中 $\\varepsilon = 10^{-10}$ 是一个数值容差。\n\n每种数值方法的更新步骤推导如下。\n\n**1. 后向欧拉法**\n对于自治常微分方程 $\\dot{y}=f(y)$，后向欧拉法由以下隐式方程定义：\n$$\ny_{n+1} = y_n + h f(y_{n+1})\n$$\n对于线性系统 $\\dot{y} = -Ay$，这变为：\n$$\ny_{n+1} = y_n + h (-A y_{n+1}) = y_n - h A y_{n+1}\n$$\n重新整理各项以求解 $y_{n+1}$，得到一个线性系统：\n$$\n(I + hA) y_{n+1} = y_n\n$$\n其中 $I$ 是单位矩阵。通过求解这个关于给定 $y_n$ 的系统，可以找到新状态 $y_{n+1}$。\n\n**2. 隐式中点法（梯形法则）**\n对于 $\\dot{y}=f(y)$，梯形法则由下式给出：\n$$\ny_{n+1} = y_n + \\frac{h}{2} \\left( f(y_n) + f(y_{n+1}) \\right)\n$$\n对于 $\\dot{y} = -Ay$，代入公式：\n$$\ny_{n+1} = y_n + \\frac{h}{2} \\left( -A y_n - A y_{n+1} \\right)\n$$\n将包含 $y_{n+1}$ 的项收集到左侧，将包含 $y_n$ 的项收集到右侧，我们得到：\n$$\n\\left(I + \\frac{h}{2}A\\right) y_{n+1} = \\left(I - \\frac{h}{2}A\\right) y_n\n$$\n在每个时间步，求解此线性系统以得到 $y_{n+1}$。该方法是 A-稳定的，但非 L-稳定的，这可能导致当步长 $h$ 较大时，刚性分量出现持续的、不衰减的振荡。\n\n**3. 两级 Radau IIA 法（3 阶）**\n这是一种具有 $s=2$ 个阶段的隐式龙格-库塔法。其 Butcher 格式表为：\n$$\n\\begin{array}{c|cc}\n1/3  5/12  -1/12 \\\\\n1  3/4  1/4 \\\\\n\\hline\n 3/4  1/4\n\\end{array}\n$$\n对于 $\\dot{y} = -Ay$ 的阶段方程为：\n$$\nk_1 = -A \\left( y_n + h \\left( \\frac{5}{12}k_1 - \\frac{1}{12}k_2 \\right) \\right)\n$$\n$$\nk_2 = -A \\left( y_n + h \\left( \\frac{3}{4}k_1 + \\frac{1}{4}k_2 \\right) \\right)\n$$\n这些方程构成了一个关于阶段向量 $k_1$ 和 $k_2$ 的耦合线性系统：\n$$\n\\left(I + \\frac{5h}{12}A\\right) k_1 - \\frac{h}{12}A k_2 = -A y_n\n$$\n$$\n-\\frac{3h}{4}A k_1 + \\left(I + \\frac{h}{4}A\\right) k_2 = -A y_n\n$$\n这个 $6 \\times 6$ 的分块系统可以写成：\n$$\n\\begin{bmatrix}\nI + \\frac{5h}{12}A  -\\frac{h}{12}A \\\\\n-\\frac{3h}{4}A  I + \\frac{h}{4}A\n\\end{bmatrix}\n\\begin{pmatrix} k_1 \\\\ k_2 \\end{pmatrix}\n=\n\\begin{pmatrix} -A y_n \\\\ -A y_n \\end{pmatrix}\n$$\n在求解该系统得到 $k_1, k_2 \\in \\mathbb{R}^3$ 后，使用权重 $b_i$ 更新状态：\n$$\ny_{n+1} = y_n + h \\left( \\frac{3}{4}k_1 + \\frac{1}{4}k_2 \\right)\n$$\n该方法是 L-稳定的，确保了对高频分量的强阻尼，这对于刚性系统是理想的。\n\n对于每个测试用例，从 $y_0$ 开始，使用相应的方法和步长 $h$ 应用 $N$ 步。在每一步 $n \\in \\{0, \\dots, N-1\\}$，计算 $V_n = V(y_n)$ 和 $V_{n+1} = V(y_{n+1})$，并检查条件 $V_{n+1} \\le V_n + \\varepsilon$。如果在任何步骤违反了该条件，则该测试用例的结果为 `False`；否则为 `True`。L-稳定方法（后向欧拉法，Radau IIA 法）预期对任何步长都能保持李雅普诺夫衰减，而 A-稳定但非 L-稳定的梯形法则在步长 $h$ 较大、$h\\lambda_{\\max}$ 很大时可能会失效，因为其稳定函数趋近于 $-1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests three implicit ODE solvers on a stiff linear gradient-flow system\n    to verify the discrete Lyapunov decay property.\n    \"\"\"\n    \n    # Define problem constants and initial conditions\n    H = np.array([\n        [4.0, 0.5, 0.0],\n        [0.5, 2.0, 0.3],\n        [0.0, 0.3, 10.0]\n    ])\n    M = np.array([\n        [1.5, 0.1, 0.0],\n        [0.1, 0.5, 0.0],\n        [0.0, 0.0, 3.0]\n    ])\n    y0 = np.array([1.0, -0.8, 0.5])\n    epsilon = 1e-10\n    \n    # System matrix and dimension\n    A = M @ H\n    dim = A.shape[0]\n    I = np.identity(dim)\n\n    # Lyapunov function V(y) = 0.5 * y^T * H * y\n    def lyapunov_V(y, H_mat):\n        return 0.5 * y.T @ H_mat @ y\n\n    # Define the six test cases: (method, step size h, number of steps N)\n    test_cases = [\n        ('be', 0.05, 40),\n        ('im', 0.5, 20),\n        ('r2', 5.0, 6),\n        ('be', 10.0, 4),\n        ('im', 10.0, 4),\n        ('r2', 20.0, 3),\n    ]\n\n    results = []\n\n    for method, h, N in test_cases:\n        y = y0.copy()\n        is_nonincreasing = True\n        \n        # Pre-compute solver matrices if they are constant over the steps\n        if method == 'be':\n            solver_mat = I + h * A\n        elif method == 'im':\n            solver_mat = I + h * 0.5 * A\n            rhs_mat = I - h * 0.5 * A\n        elif method == 'r2':\n            # Butcher tableau for 2-stage Radau IIA\n            a11, a12 = 5/12, -1/12\n            a21, a22 = 3/4, 1/4\n            b1, b2 = 3/4, 1/4\n\n            # Construct the 2d x 2d block matrix for stage equations\n            M_radau = np.block([\n                [I + h * a11 * A, h * a12 * A],\n                [h * a21 * A, I + h * a22 * A]\n            ])\n\n        for n in range(N):\n            V_prev = lyapunov_V(y, H)\n            \n            if method == 'be':\n                y_next = np.linalg.solve(solver_mat, y)\n            \n            elif method == 'im':\n                rhs_vec = rhs_mat @ y\n                y_next = np.linalg.solve(solver_mat, rhs_vec)\n            \n            elif method == 'r2':\n                # Solve for stage derivatives k1, k2\n                rhs_k = -A @ y\n                rhs_block = np.concatenate([rhs_k, rhs_k])\n                \n                k_block = np.linalg.solve(M_radau, rhs_block)\n                k1 = k_block[:dim]\n                k2 = k_block[dim:]\n\n                # Update step\n                y_next = y + h * (b1 * k1 + b2 * k2)\n            \n            y = y_next\n            V_next = lyapunov_V(y, H)\n            \n            if V_next > V_prev + epsilon:\n                is_nonincreasing = False\n                break\n        \n        results.append(is_nonincreasing)\n\n    # Print the final results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多核物理问题，尤其是在核合成领域，涉及发生在迥异时间尺度上的过程。最后一项实践将向你介绍使用隐式-显式（IMEX）格式的多速率积分法，这是一种处理此类系统的强大技术。你将为一个简化的“等待点”模型构建一个定制的积分器，其中快速的中子俘获被显式处理，而缓慢的$\\beta$衰变被隐式处理，并量化由此产生的分解误差，从而深入了解复杂、特定领域求解器的设计与分析 。",
            "id": "3565707",
            "problem": "考虑一个中子俘获流中，科学上合理的、最小化的、程式化的双同位素等待点子系统。设丰度由向量 $\\mathbf{N}(t) = [N_1(t), N_2(t)]^\\top$ 表示，其中 $N_1(t)$ 代表等待点前同位素的布居数，$N_2(t)$ 代表等待点同位素的布居数。假设中子环境恒定，且有效的单中子俘获率和 $\\beta$ 衰变率不随时间变化。耦合的速率方程为\n$$\n\\frac{d}{dt}\\mathbf{N}(t) = \\mathbf{R}_{\\text{cap}}(\\mathbf{N}(t)) + \\mathbf{R}_{\\beta}(\\mathbf{N}(t)),\n$$\n其中，俘获驱动 $N_1$ 变为 $N_2$，而 $\\beta$ 衰变使 $N_2$ 返回 $N_1$。各分量由充分混合布居的基本反应速率定律定义（在静态热力学环境中，具有恒定速率系数的线性质量作用定律）：\n$$\n\\mathbf{R}_{\\text{cap}}(\\mathbf{N}) = \\begin{bmatrix} -\\lambda_{\\text{cap}} N_1 \\\\ +\\lambda_{\\text{cap}} N_1 \\end{bmatrix}, \\quad\n\\mathbf{R}_{\\beta}(\\mathbf{N}) = \\begin{bmatrix} +\\lambda_{\\beta} N_2 \\\\ -\\lambda_{\\beta} N_2 \\end{bmatrix},\n$$\n其中 $\\lambda_{\\text{cap}}$ 的单位是 $\\mathrm{s}^{-1}$，$\\lambda_{\\beta}$ 的单位是 $\\mathrm{s}^{-1}$。这对简化的同位素对形成一个保守的封闭子系统，其 $N_1(t)+N_2(t)$ 保持恒定，适合用来分离等待点分配效应。\n\n你需要基于第一性原理，为这个初值问题构建一个隐式-显式（IMEX）多速率积分器。在此构建中：\n- 将 $\\mathbf{R}_{\\beta}$ 视为“慢”的刚性分量，通过后向欧拉法（backward-Euler method）在一个宏观步长 $\\Delta t_s$ 上进行隐式推进。\n- 将 $\\mathbf{R}_{\\text{cap}}$ 视为“快”的分量，通过每个宏观步长内 $m$ 个大小为 $\\Delta t_f = \\Delta t_s/m$ 的微观步长，使用前向欧拉法（forward-Euler method）进行显式推进。\n- 在每个宏观步长内，首先应用隐式的慢分量更新，然后使用 $m$ 个显式的微观步长推进快分量。\n\n从常微分方程、慢分量的后向欧拉更新以及快分量的前向欧拉更新的定义出发，推导一个宏观步长的离散更新映射并加以实现。不要使用预先组合或简化的更新公式；直接从上述定义推导隐式求解所需的任何代数运算。\n\n为量化等待点附近的分配误差，请将 IMEX 多速率解与一个参考解进行比较。该参考解是通过使用基于后向分化公式（Backward Differentiation Formula, BDF）方法的高精度刚性求解器对完整的未分裂系统进行积分得到的。两次积分使用相同的初始条件、物理参数和相同的最终时间。将最终等待点丰度的偏差定义为\n$$\n\\delta N_2 = N_{2,\\text{IMEX}}(T) - N_{2,\\text{ref}}(T),\n$$\n你必须报告每个测试案例的此值。\n\n所有测试案例的初始条件：$N_1(0) = 1$（无量纲数分数），$N_2(0) = 0$（无量纲数分数）。所有时间以 $\\mathrm{s}$ 表示，所有速率以 $\\mathrm{s}^{-1}$ 表示。量 $\\delta N_2$ 是无量纲的。\n\n实现程序以运行以下参数集的测试套件，这些参数集探测了多种动力学机制，包括一般情况、等待点主导机制、平衡机制以及一个用于暴露分配误差的粗糙多速率情况：\n\n- 测试案例 1 (一般的“理想路径”)：$\\lambda_{\\text{cap}} = 10$, $\\lambda_{\\beta} = 1$, $T = 1$, $\\Delta t_s = 0.1$, $m = 10$。\n- 测试案例 2 (由快俘获和慢衰变主导的等待点)：$\\lambda_{\\text{cap}} = 1000$, $\\lambda_{\\beta} = 0.1$, $T = 0.1$, $\\Delta t_s = 0.05$, $m = 100$。\n- 测试案例 3 (平衡速率)：$\\lambda_{\\text{cap}} = 5$, $\\lambda_{\\beta} = 5$, $T = 1$, $\\Delta t_s = 0.2$, $m = 5$。\n- 测试案例 4 (暴露分配误差的粗糙多速率微观步长)：$\\lambda_{\\text{cap}} = 100$, $\\lambda_{\\beta} = 0.5$, $T = 0.5$, $\\Delta t_s = 0.25$, $m = 25$。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4]$），其中每个 $x_i$ 是测试案例 $i$ 的 $\\delta N_2$ 的数值，以十进制数表示。使用高精度的参考积分来确保观察到的偏差可归因于分配和多速率效应，而非基准求解器的原因。通过选择给定的 $\\Delta t_f$ 和 $m$ 来确保在整个显式更新过程中丰度的数值非负性；不要添加人为的截断。",
            "solution": "问题陈述具有科学依据，提法恰当，并提供了继续进行所需的所有必要信息。它描述了一个简化的但有效的天体物理学双同位素系统物理模型，并提出了一个标准的、尽管是特定的数值分析任务。在模型背景下，参数是物理上合理的，且目标定义清晰，可通过计算验证。因此，该问题是有效的。\n\n这个问题的核心是为一个耦合常微分方程（ODE）系统推导并实现一个特定的一阶隐式-显式（IMEX）多速率积分方案，并将其结果与高精度参考解进行比较。该系统描述了由中子俘获和 $\\beta$ 衰变控制的两个同位素丰度 $N_1(t)$ 和 $N_2(t)$ 的演化。\n\n控制该系统的 ODE 系统由 $\\frac{d}{dt}\\mathbf{N}(t) = \\mathbf{F}(\\mathbf{N}(t))$ 给出，其中 $\\mathbf{N}(t) = [N_1(t), N_2(t)]^\\top$。总变化率 $\\mathbf{F}(\\mathbf{N})$ 被分解为一个“快”分量 $\\mathbf{R}_{\\text{cap}}(\\mathbf{N})$ 和一个“慢”分量 $\\mathbf{R}_{\\beta}(\\mathbf{N})$。\n$$\n\\frac{d}{dt}\\mathbf{N}(t) = \\mathbf{R}_{\\text{cap}}(\\mathbf{N}(t)) + \\mathbf{R}_{\\beta}(\\mathbf{N}(t))\n$$\n各分量为：\n$$\n\\mathbf{R}_{\\text{cap}}(\\mathbf{N}) = \\begin{bmatrix} -\\lambda_{\\text{cap}} N_1 \\\\ +\\lambda_{\\text{cap}} N_1 \\end{bmatrix}, \\quad\n\\mathbf{R}_{\\beta}(\\mathbf{N}) = \\begin{bmatrix} +\\lambda_{\\beta} N_2 \\\\ -\\lambda_{\\beta} N_2 \\end{bmatrix}\n$$\nIMEX 方案在一个大小为 $\\Delta t_s$ 的宏观步长上推进解。设 $\\mathbf{N}^k$ 是时间 $t_k$ 的数值解。时间 $t_{k+1} = t_k + \\Delta t_s$ 的解记为 $\\mathbf{N}^{k+1}$。指定的方案在每个宏观步长中包含两个阶段：对慢分量的隐式更新，然后是对快分量的显式更新。\n\n**第一阶段：隐式慢分量更新**\n\n慢分量 $\\mathbf{R}_{\\beta}$ 使用后向欧拉法（backward-Euler method）在宏观步长 $\\Delta t_s$ 上进行隐式处理。这将状态从 $\\mathbf{N}^k$ 更新到一个中间状态 $\\mathbf{N}^*$。后向欧拉公式为：\n$$\n\\frac{\\mathbf{N}^* - \\mathbf{N}^k}{\\Delta t_s} = \\mathbf{R}_{\\beta}(\\mathbf{N}^*)\n$$\n对于 $\\mathbf{N}^* = [N_1^*, N_2^*]^\\top$ 和 $\\mathbf{N}^k = [N_1^k, N_2^k]^\\top$，将其写成分量形式：\n$$\n\\frac{N_1^* - N_1^k}{\\Delta t_s} = \\lambda_{\\beta} N_2^*\n$$\n$$\n\\frac{N_2^* - N_2^k}{\\Delta t_s} = -\\lambda_{\\beta} N_2^*\n$$\n这是一个关于 $N_1^*$ 和 $N_2^*$ 的线性方程组。我们首先求解第二个关于 $N_2^*$ 的方程，因为它独立于 $N_1^*$：\n$$\nN_2^* - N_2^k = -\\Delta t_s \\lambda_{\\beta} N_2^* \\implies N_2^*(1 + \\Delta t_s \\lambda_{\\beta}) = N_2^k\n$$\n$$\nN_2^* = \\frac{N_2^k}{1 + \\Delta t_s \\lambda_{\\beta}}\n$$\n将此结果代入第一个方程，我们可以解出 $N_1^*$：\n$$\nN_1^* = N_1^k + \\Delta t_s \\lambda_{\\beta} N_2^*\n$$\n这就定义了中间状态 $\\mathbf{N}^*$。注意，将两个分量方程相加可得 $N_1^* + N_2^* = N_1^k + N_2^k$，这证实了总丰度在此隐式步骤中是守恒的，对于封闭的 $\\mathbf{R}_{\\beta}$ 子系统来说也理应如此。因此，一种数值上更稳健的计算 $N_1^*$ 的方法是：\n$$\nN_1^* = N_1^k + N_2^k - N_2^*\n$$\n\n**第二阶段：显式快分量更新**\n\n快分量 $\\mathbf{R}_{\\text{cap}}$ 使用 $m$ 个前向欧拉法（forward-Euler method）的微观步长进行显式处理。每个微观步长的大小是 $\\Delta t_f = \\Delta t_s / m$。这一系列更新将状态从 $\\mathbf{N}^*$ 推进到最终状态 $\\mathbf{N}^{k+1}$。\n\n设 $\\mathbf{N}^{(j)}$ 为经过 $j$ 个微观步长后的状态，初始状态为 $\\mathbf{N}^{(0)} = \\mathbf{N}^*$。从状态 $\\mathbf{N}^{(j-1)}$ 到 $\\mathbf{N}^{(j)}$ 的一个微观步长的前向欧拉更新为：\n$$\n\\frac{\\mathbf{N}^{(j)} - \\mathbf{N}^{(j-1)}}{\\Delta t_f} = \\mathbf{R}_{\\text{cap}}(\\mathbf{N}^{(j-1)})\n$$\n分量形式为：\n$$\nN_1^{(j)} = N_1^{(j-1)} - \\Delta t_f \\lambda_{\\text{cap}} N_1^{(j-1)} = (1 - \\Delta t_f \\lambda_{\\text{cap}}) N_1^{(j-1)}\n$$\n$$\nN_2^{(j)} = N_2^{(j-1)} + \\Delta t_f \\lambda_{\\text{cap}} N_1^{(j-1)}\n$$\n我们从 $\\mathbf{N}^{(0)} = \\mathbf{N}^*$ 开始，应用此更新 $m$ 次。对 $N_1$ 的方程可以通过重复应用来求解：\n$$\nN_1^{(m)} = (1 - \\Delta t_f \\lambda_{\\text{cap}})^m N_1^{(0)} = (1 - \\Delta t_f \\lambda_{\\text{cap}})^m N_1^*\n$$\n由于算子 $\\mathbf{R}_{\\text{cap}}$ 也是保守的，对于每个微观步长，我们有 $N_1^{(j)} + N_2^{(j)} = N_1^{(j-1)} + N_2^{(j-1)}$。这意味着在整个 $m$ 个微观步长序列中总丰度是守恒的：$N_1^{(m)} + N_2^{(m)} = N_1^{(0)} + N_2^{(0)}$。\n使用这个守恒性质，我们可以直接求出 $N_2^{(m)}$：\n$$\nN_2^{(m)} = N_1^{(0)} + N_2^{(0)} - N_1^{(m)} = N_1^* + N_2^* - N_1^{(m)}\n$$\n宏观步长结束时的状态是 $\\mathbf{N}^{k+1} = \\mathbf{N}^{(m)}$。\n\n**完整的 IMEX 宏观步长更新映射**\n\n结合两个阶段，从 $\\mathbf{N}^k$ 到 $\\mathbf{N}^{k+1}$ 的完整更新过程是：\n1.  **隐式部分：**\n    $$\n    N_2^* = \\frac{N_2^k}{1 + \\Delta t_s \\lambda_{\\beta}}\n    $$\n    $$\n    N_1^* = N_1^k + N_2^k - N_2^*\n    $$\n2.  **显式部分：**\n    $$\n    N_1^{k+1} = \\left(1 - \\frac{\\Delta t_s \\lambda_{\\text{cap}}}{m}\\right)^m N_1^*\n    $$\n    $$\n    N_2^{k+1} = N_1^* + N_2^* - N_1^{k+1}\n    $$\n这组方程定义了要为 IMEX 求解器实现的算法。\n\n**参考解和误差度量**\n为评估准确性，将最终时间 $T$ 的 IMEX 解（记为 $\\mathbf{N}_{\\text{IMEX}}(T)$）与高精度参考解 $\\mathbf{N}_{\\text{ref}}(T)$ 进行比较。参考解是通过使用基于后向分化公式（Backward Differentiation Formula, BDF）的刚性求解器（特别是 `scipy.integrate.solve_ivp`，其中 `method='BDF'` 并设置了严格的误差容限）对完整的、未分裂的 ODE 系统进行积分得到的。完整的系统是：\n$$\n\\frac{dN_1}{dt} = -\\lambda_{\\text{cap}} N_1 + \\lambda_{\\beta} N_2\n$$\n$$\n\\frac{dN_2}{dt} = +\\lambda_{\\text{cap}} N_1 - \\lambda_{\\beta} N_2\n$$\n比较通过最终等待点丰度的偏差来量化：\n$$\n\\delta N_2 = N_{2,\\text{IMEX}}(T) - N_{2,\\text{ref}}(T)\n$$\n对每个指定的测试案例执行此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the problem by running the specified test suite to compare\n    a custom IMEX integrator with a high-accuracy reference solver.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Format: (lambda_cap, lambda_beta, T_final, dt_s, m)\n    test_cases = [\n        (10.0, 1.0, 1.0, 0.1, 10),\n        (1000.0, 0.1, 0.1, 0.05, 100),\n        (5.0, 5.0, 1.0, 0.2, 5),\n        (100.0, 0.5, 0.5, 0.25, 25),\n    ]\n\n    # Initial condition for all cases\n    N0 = np.array([1.0, 0.0])\n\n    results = []\n    for case in test_cases:\n        l_cap, l_beta, T_final, dt_s, m = case\n\n        # Run the IMEX multirate solver\n        N_imex_final = run_imex_solver(l_cap, l_beta, T_final, dt_s, m, N0)\n\n        # Run the high-accuracy reference solver\n        N_ref_final = run_reference_solver(l_cap, l_beta, T_final, N0)\n\n        # Calculate the bias in the waiting-point abundance\n        delta_N2 = N_imex_final[1] - N_ref_final[1]\n        results.append(delta_N2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\ndef run_imex_solver(l_cap, l_beta, T_final, dt_s, m, N0):\n    \"\"\"\n    Implements the derived IMEX multirate integrator.\n    \n    - Slow component (beta-decay) is advanced implicitly with backward-Euler.\n    - Fast component (capture) is advanced explicitly with m forward-Euler steps.\n    \"\"\"\n    # Ensure a whole number of steps\n    num_steps = int(round(T_final / dt_s))\n    \n    dt_f = dt_s / m\n    N = np.array(N0, dtype=float)\n\n    for _ in range(num_steps):\n        # Store current state\n        N_k = N\n\n        # Stage 1: Implicit slow update (Backward Euler for R_beta)\n        # N2_star = N_k[1] / (1 + dt_s * l_beta)\n        # N1_star = N_k[0] + dt_s * l_beta * N2_star\n        # Using the conservative form for N1_star for better numerical stability:\n        N2_star = N_k[1] / (1.0 + dt_s * l_beta)\n        N1_star = N_k[0] + N_k[1] - N2_star\n\n        N_star = np.array([N1_star, N2_star])\n\n        # Stage 2: Explicit fast updates (m steps of Forward Euler for R_cap)\n        # The m-step update can be expressed in a closed form derived in the solution.\n        # This avoids an inner loop for micro-steps.\n        factor = (1.0 - dt_f * l_cap)**m\n        N1_next = N_star[0] * factor\n        # Use conservation of particles for N2\n        N2_next = N_star[0] + N_star[1] - N1_next\n\n        N = np.array([N1_next, N2_next])\n\n    return N\n\ndef run_reference_solver(l_cap, l_beta, T_final, N0):\n    \"\"\"\n    Integrates the full unsplit system using a high-accuracy stiff (BDF) solver.\n    \"\"\"\n    def ode_system(t, N):\n        \"\"\" The right-hand side of the full ODE system. \"\"\"\n        N1, N2 = N\n        dN1_dt = -l_cap * N1 + l_beta * N2\n        dN2_dt =  l_cap * N1 - l_beta * N2\n        return np.array([dN1_dt, dN2_dt])\n\n    # `solve_ivp` with BDF method and tight tolerances for high accuracy.\n    sol = solve_ivp(\n        ode_system,\n        (0, T_final),\n        N0,\n        method='BDF',\n        rtol=1e-13,\n        atol=1e-13\n    )\n\n    # Return the state at the final time T_final\n    return sol.y[:, -1]\n\nsolve()\n```"
        }
    ]
}