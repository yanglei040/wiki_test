{
    "hands_on_practices": [
        {
            "introduction": "在核理论中，许多积分是在有限离散格点上近似计算的。本练习直接比较了两种基本的高斯求积方法：高斯-勒让德（Gauss-Legendre）和高斯-洛巴托（Gauss-Lobatto）求积。通过对一个典型的、行为良好的对关联矩阵元进行数值计算，您将探索它们不同的节点配置如何影响收敛性，这是理解离散变量表示（DVR）等方法的关键基础。",
            "id": "3561526",
            "problem": "考虑球对称场下的哈特里-福克-博戈留波夫 (HFB) 对关联矩阵元积分的计算，其径向表达式由下式给出\n$$\nI \\equiv \\int_{0}^{\\infty} r^{2} \\, dr \\, u(r) \\, v(r) \\, \\Delta(r),\n$$\n其中 $u(r)$ 和 $v(r)$ 是准粒子径向振幅，$\\Delta(r)$ 是对关联场。在许多基于离散变量表示 (DVR) 的计算核物理算法中，高斯求积方法被用于在有限域上近似此类积分。你的任务是实现一个程序，在一个解析可解且物理上合理的模型下，比较 Gauss–Legendre DVR 网格与 Gauss–Lobatto DVR 网格对于此积分的收敛性。\n\n使用以下模型函数：\n- 通过下式定义准粒子振幅和对关联场\n$$\nu(r) = r \\, \\exp\\!\\left(-\\frac{r^{2}}{2 b_{u}^{2}}\\right), \\quad\nv(r) = \\exp\\!\\left(-\\frac{r^{2}}{2 b_{v}^{2}}\\right), \\quad\n\\Delta(r) = \\Delta_{0} \\, \\exp\\!\\left(-\\frac{r^{2}}{2 a^{2}}\\right),\n$$\n其中参数 $a$、$b_{u}$、$b_{v}$ 的单位是飞米，$\\Delta_{0}$ 的单位是兆电子伏。这样的选择使得被积函数随 $r$ 快速衰减，并且在 $r=0$ 处是光滑的。\n\n你将通过截断到一个有限区间 $[0,R]$ 来近似这个半无限积分，并通过仿射映射 $r(x) = \\frac{R}{2} (x+1)$ 和雅可比 $dr = \\frac{R}{2} dx$ 在参考区间 $[-1,1]$ 上应用高斯求积。必须实现两种求积族：\n- Gauss–Legendre（在 $(-1,1)$ 内有 $N$ 个节点），对于 $[-1,1]$ 上的单位权重，它对最高为 $2N-1$ 次的多项式是精确的。\n- Gauss–Lobatto（有 $N$ 个节点，包括端点 $\\{-1,1\\}$ 和由 $P_{N-1}'(x)$ 的零点给出的 $N-2$ 个内部节点，其中 $P_{n}(x)$ 是 $n$ 次勒让德多项式），对于 $[-1,1]$ 上的单位权重，它对最高为 $2N-3$ 次的多项式是精确的。\n\n从基本的、经过充分检验的基础出发：\n- 勒让德多项式的性质，高斯求积对单位权重多项式的精确性，以及求积规则在不同区间之间的仿射映射。\n- 拉普拉斯型高斯积分的积分恒等式，\n$$\n\\int_{0}^{\\infty} r^{2n+1} e^{-\\alpha r^{2}} \\, dr = \\frac{n!}{2 \\alpha^{n+1}} \\quad \\text{for} \\quad \\alpha > 0 \\quad \\text{and integer} \\quad n \\ge 0,\n$$\n该恒等式可由伽马函数的定义和变量代换得出。\n\n任务：\n1. 从第一性原理出发，推导 $I$ 关于 $a$、$b_{u}$、$b_{v}$ 和 $\\Delta_{0}$ 的精确解析表达式，不要引用任何专门的核结构公式。\n2. 在 $[-1,1]$ 上实现两个求积程序：Gauss–Legendre 和 Gauss–Lobatto，两者都使用单位权重。对于有 $N$ 个节点的 Gauss–Lobatto，使用由 $P_{N-1}'(x)$ 的零点给出的 $N-2$ 个内部节点和以下权重：\n$$\nw_{i} = \\frac{2}{N(N-1)\\left[P_{N-1}(x_{i})\\right]^{2}} \\quad \\text{for interior nodes}, \\quad\nw_{\\text{end}} = \\frac{2}{N(N-1)} \\quad \\text{for} \\quad x=\\pm 1.\n$$\n3. 使用映射 $r = \\frac{R}{2}(x+1)$ 和 $dr = \\frac{R}{2} dx$ 来近似\n$$\nI \\approx \\sum_{i=1}^{N} w_{i} \\, \\frac{R}{2} \\, \\left[r(x_{i})\\right]^{2} \\, u\\!\\left(r(x_{i})\\right) \\, v\\!\\left(r(x_{i})\\right) \\, \\Delta\\!\\left(r(x_{i})\\right).\n$$\n选择足够大的 $R$，使得相对于精确的半无限积分，截断误差在所提供的测试套件上可以忽略不计。\n\n测试套件和参数：\n- 程序必须评估两种求积族的绝对相对误差，定义如下：\n$$\n\\varepsilon_{\\mathrm{GL}}(N) = \\frac{\\left| I_{\\mathrm{GL}}^{(N)} - I_{\\text{exact}} \\right|}{\\left| I_{\\text{exact}} \\right|}, \\quad\n\\varepsilon_{\\mathrm{GLL}}(N) = \\frac{\\left| I_{\\mathrm{GLL}}^{(N)} - I_{\\text{exact}} \\right|}{\\left| I_{\\text{exact}} \\right|}.\n$$\n- 使用以下三组参数 $(a, b_{u}, b_{v}, \\Delta_{0}, R)$，其中 $a$、$b_{u}$、$b_{v}$、$R$ 的单位是飞米，$\\Delta_{0}$ 的单位是兆电子伏：\n  1. $(a, b_{u}, b_{v}, \\Delta_{0}, R) = (2.5, 2.0, 2.0, 1.2, 12.0)$。\n  2. $(a, b_{u}, b_{v}, \\Delta_{0}, R) = (1.8, 1.2, 2.8, 0.8, 12.0)$。\n  3. $(a, b_{u}, b_{v}, \\Delta_{0}, R) = (0.8, 0.8, 0.8, 2.0, 8.0)$。\n- 对每组参数，计算 $N \\in \\{8, 16, 24, 32\\}$ 时的误差。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的扁平、逗号分隔的浮点数列表。顺序必须是：对于按所列顺序的每组参数，以及对于按升序排列的每个 $N$，首先是 Gauss–Legendre 误差，然后是 Gauss–Lobatto 误差：\n$$\n\\left[ \\varepsilon_{\\mathrm{GL}}^{(1)}(8), \\varepsilon_{\\mathrm{GLL}}^{(1)}(8), \\varepsilon_{\\mathrm{GL}}^{(1)}(16), \\varepsilon_{\\mathrm{GLL}}^{(1)}(16), \\ldots, \\varepsilon_{\\mathrm{GL}}^{(1)}(32), \\varepsilon_{\\mathrm{GLL}}^{(1)}(32), \\varepsilon_{\\mathrm{GL}}^{(2)}(8), \\ldots, \\varepsilon_{\\mathrm{GLL}}^{(3)}(32) \\right].\n$$\n- 每个条目都是一个无量纲的小数。该列表必须恰好包含 24 个数字。\n\n科学真实性和约束：\n- 对于给定的 $R$，所有情况都是光滑、快速衰减且数值稳定的。使用双精度浮点运算。\n- 角度没有出现，因此不需要角度单位。由于要求的输出是相对误差，最终输出中不出现物理单位。",
            "solution": "我们从模型函数的定义开始\n$$\nu(r) = r \\, \\exp\\!\\left(-\\frac{r^{2}}{2 b_{u}^{2}}\\right), \\quad\nv(r) = \\exp\\!\\left(-\\frac{r^{2}}{2 b_{v}^{2}}\\right), \\quad\n\\Delta(r) = \\Delta_{0} \\, \\exp\\!\\left(-\\frac{r^{2}}{2 a^{2}}\\right),\n$$\n以及 HFB 对关联矩阵元积分\n$$\nI = \\int_{0}^{\\infty} r^{2} \\, dr \\, u(r) \\, v(r) \\, \\Delta(r).\n$$\n代入 $u(r)$、$v(r)$ 和 $\\Delta(r)$ 得\n$$\nI = \\int_{0}^{\\infty} r^{2} \\, dr \\, \\left[r \\, e^{-r^{2}/(2 b_{u}^{2})}\\right] \\, \\left[e^{-r^{2}/(2 b_{v}^{2})}\\right] \\, \\left[\\Delta_{0} \\, e^{-r^{2}/(2 a^{2})}\\right]\n= \\Delta_{0} \\int_{0}^{\\infty} r^{3} \\, \\exp\\!\\left[-\\left(\\frac{1}{2 b_{u}^{2}} + \\frac{1}{2 b_{v}^{2}} + \\frac{1}{2 a^{2}}\\right) r^{2}\\right] dr.\n$$\n定义\n$$\n\\alpha \\equiv \\frac{1}{2} \\left( \\frac{1}{b_{u}^{2}} + \\frac{1}{b_{v}^{2}} + \\frac{1}{a^{2}} \\right),\n$$\n当 $a$、$b_{u}$、$b_{v}$ 为正时，$\\alpha > 0$。于是\n$$\nI = \\Delta_{0} \\int_{0}^{\\infty} r^{3} e^{-\\alpha r^{2}} dr.\n$$\n为精确计算此积分，我们从经过充分检验的高斯矩恒等式出发，\n$$\n\\int_{0}^{\\infty} r^{2n+1} e^{-\\alpha r^{2}} dr = \\frac{n!}{2 \\alpha^{n+1}}, \\quad \\alpha > 0, \\quad n \\in \\mathbb{Z}_{\\ge 0}.\n$$\n这可以通过代入 $t = \\alpha r^{2}$，$dt = 2 \\alpha r \\, dr$ 来推导，从而有 $r^{2n+1} dr = \\frac{1}{2 \\alpha^{n+1}} t^{n} dt$，因此\n$$\n\\int_{0}^{\\infty} r^{2n+1} e^{-\\alpha r^{2}} dr = \\frac{1}{2 \\alpha^{n+1}} \\int_{0}^{\\infty} t^{n} e^{-t} dt = \\frac{\\Gamma(n+1)}{2 \\alpha^{n+1}} = \\frac{n!}{2 \\alpha^{n+1}}.\n$$\n对于 $n=1$，我们得到\n$$\n\\int_{0}^{\\infty} r^{3} e^{-\\alpha r^{2}} dr = \\frac{1}{2 \\alpha^{2}}.\n$$\n因此，精确的解析值为\n$$\nI_{\\text{exact}} = \\Delta_{0} \\cdot \\frac{1}{2 \\alpha^{2}} = \\frac{\\Delta_{0}}{2 \\alpha^{2}}.\n$$\n\n接下来，我们设计求积算法。在 $[-1,1]$ 上使用单位权重的高斯求积可近似为\n$$\n\\int_{-1}^{1} g(x) \\, dx \\approx \\sum_{i=1}^{N} w_{i} \\, g(x_{i}).\n$$\n- 对于 Gauss–Legendre，节点 $\\{x_{i}\\}$ 是 $P_{N}(x)$ 的 $N$ 个零点，权重 $\\{w_{i}\\}$ 的选择使其能对最高为 $2N-1$ 次的多项式达到精确。\n- 对于 Gauss–Lobatto，节点包括端点 $x=\\pm 1$ 和 $P_{N-1}'(x)$ 的零点所构成的 $N-2$ 个内部节点。权重为\n$$\nw_{\\text{end}} = \\frac{2}{N(N-1)}, \\quad\nw_{i} = \\frac{2}{N(N-1)\\left[P_{N-1}(x_{i})\\right]^{2}} \\quad \\text{for interior nodes}.\n$$\n该规则对最高为 $2N-3$ 次的多项式是精确的。\n\n我们希望近似\n$$\nI = \\int_{0}^{\\infty} r^{2} dr \\, u(r) v(r) \\Delta(r).\n$$\n我们截断到 $[0,R]$ 并使用仿射映射 $r(x) = \\frac{R}{2}(x+1)$，$dr = \\frac{R}{2} dx$，从而\n$$\nI \\approx \\int_{-1}^{1} \\left[ \\left( r(x) \\right)^{2} u(r(x)) v(r(x)) \\Delta(r(x)) \\right] \\left( \\frac{R}{2} \\right) dx.\n$$\n因此求积近似式为\n$$\nI^{(N)} \\approx \\sum_{i=1}^{N} w_{i} \\left( \\frac{R}{2} \\right) \\left[ r(x_{i}) \\right]^{2} u\\!\\left(r(x_{i})\\right) v\\!\\left(r(x_{i})\\right) \\Delta\\!\\left(r(x_{i})\\right).\n$$\n在我们的高斯模型中，选择 $R$ 使得 $R \\gg a, b_{u}, b_{v}$ 可以确保截断误差可忽略不计，因为被积函数的行为类似于 $r^{3} e^{-\\alpha r^{2}}$（其中 $\\alpha > 0$），这使得尾部积分 $\\int_{R}^{\\infty}$ 呈指数级小。\n\n算法步骤：\n1. 对于给定的 $(a, b_{u}, b_{v}, \\Delta_{0})$，计算 $\\alpha = \\frac{1}{2}\\left( b_{u}^{-2} + b_{v}^{-2} + a^{-2} \\right)$，然后计算 $I_{\\text{exact}} = \\Delta_{0}/(2 \\alpha^{2})$。\n2. 对于每个 $N$ 和每种求积族，计算在 $[-1,1]$ 上的节点 $\\{x_{i}\\}$ 和权重 $\\{w_{i}\\}$。对于 Gauss–Legendre，使用标准程序构建 $P_{N}$ 的零点和权重。对于 Gauss–Lobatto，构造 $P_{N-1}(x)$，找到 $P_{N-1}'(x)$ 的根作为内部节点，并使用给定的公式计算包括端点 $x=\\pm 1$ 在内的权重。\n3. 映射到 $r_{i} = \\frac{R}{2}(x_{i}+1)$ 并计算被积函数\n$$\nf(r) = r^{2} \\, u(r) \\, v(r) \\, \\Delta(r) = \\Delta_{0} \\, r^{3} \\, \\exp\\!\\left[-\\left(\\frac{1}{2 b_{u}^{2}} + \\frac{1}{2 b_{v}^{2}} + \\frac{1}{2 a^{2}}\\right) r^{2}\\right].\n$$\n4. 构成求积和\n$$\nI_{\\mathrm{GL}}^{(N)} = \\sum_{i=1}^{N} w_{i}^{\\mathrm{GL}} \\left( \\frac{R}{2} \\right) f\\!\\left( r(x_{i}^{\\mathrm{GL}}) \\right), \\quad\nI_{\\mathrm{GLL}}^{(N)} = \\sum_{i=1}^{N} w_{i}^{\\mathrm{GLL}} \\left( \\frac{R}{2} \\right) f\\!\\left( r(x_{i}^{\\mathrm{GLL}}) \\right).\n$$\n5. 计算绝对相对误差\n$$\n\\varepsilon_{\\mathrm{GL}}(N) = \\frac{| I_{\\mathrm{GL}}^{(N)} - I_{\\text{exact}} |}{| I_{\\text{exact}} |}, \\quad\n\\varepsilon_{\\mathrm{GLL}}(N) = \\frac{| I_{\\mathrm{GLL}}^{(N)} - I_{\\text{exact}} |}{| I_{\\text{exact}} |}.\n$$\n\n收敛性讨论：\n- 对于 $[-1,1]$ 上的解析被积函数，Gauss–Legendre 和 Gauss–Lobatto 都具有谱精度，意味着误差随 $N$ 的减小速度快于 $N$ 的任何次幂。然而，对于多项式，Gauss–Legendre 达到的精确度 ($2N-1$) 高于 Gauss–Lobatto ($2N-3$)；并且其内部节点避开了端点，这对于没有端点奇点的光滑被积函数，通常会导致渐近误差中的常数更小。在此模型中，映射后的被积函数是光滑的，并在左端点处为零（因为当 $r \\to 0$ 时，$f(r) \\sim r^{3}$），在 $r=R$ 处呈指数级小。因此，在固定的 $N$ 值下，Gauss–Legendre 预计会收敛得稍快一些，尽管 Gauss–Lobatto 仍然保持高精度。整个测试套件的数值结果通过报告的 $\\varepsilon_{\\mathrm{GL}}(N)$ 和 $\\varepsilon_{\\mathrm{GLL}}(N)$ 值来量化这种影响。\n\n测试套件实现细节：\n- 参数集：\n  1. $(a, b_{u}, b_{v}, \\Delta_{0}, R) = (2.5, 2.0, 2.0, 1.2, 12.0)$。\n  2. $(a, b_{u}, b_{v}, \\Delta_{0}, R) = (1.8, 1.2, 2.8, 0.8, 12.0)$。\n  3. $(a, b_{u}, b_{v}, \\Delta_{0}, R) = (0.8, 0.8, 0.8, 2.0, 8.0)$。\n- 每个案例的节点数：$N \\in \\{8, 16, 24, 32\\}$。\n- 输出：一个包含 24 个浮点数的扁平列表，按每个案例和每个 $N$ 的顺序排列，先是 $\\varepsilon_{\\mathrm{GL}}(N)$，然后是 $\\varepsilon_{\\mathrm{GLL}}(N)$。\n\n这种方法完全分离了 Gauss–Lobatto DVR 网格与 Gauss–Legendre DVR 网格对一个光滑的、受核物理启发的对关联矩阵元的收敛行为的影响，同时保留了一个用于定量误差评估的解析参考。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gauss_legendre(n: int):\n    \"\"\"\n    Return nodes and weights for Gauss–Legendre quadrature on [-1, 1].\n    \"\"\"\n    x, w = np.polynomial.legendre.leggauss(n)\n    return x, w\n\ndef gauss_lobatto(n: int):\n    \"\"\"\n    Return nodes and weights for Gauss–Lobatto quadrature on [-1, 1] with unit weight.\n    Nodes include endpoints -1 and 1; interior nodes are roots of P_{n-1}'(x).\n    Weights:\n        w_end = 2/(n*(n-1)),\n        w_i = 2/(n*(n-1)*[P_{n-1}(x_i)]^2) for interior nodes.\n    \"\"\"\n    if n  2:\n        raise ValueError(\"Gauss–Lobatto requires n >= 2.\")\n    # Construct Legendre polynomial P_{n-1}\n    P = np.polynomial.legendre.Legendre.basis(n - 1)\n    dP = P.deriv()\n    # Interior nodes are roots of derivative\n    if n == 2:\n        interior = np.array([], dtype=float)\n    else:\n        interior = dP.roots()\n        interior.sort()\n    nodes = np.concatenate((np.array([-1.0]), interior, np.array([1.0])))\n    weights = np.empty_like(nodes)\n    w_end = 2.0 / (n * (n - 1))\n    weights[0] = w_end\n    weights[-1] = w_end\n    # Interior weights\n    for i in range(1, len(nodes) - 1):\n        xi = nodes[i]\n        Pi = P(xi)\n        weights[i] = 2.0 / (n * (n - 1) * (Pi * Pi))\n    return nodes, weights\n\ndef map_to_radius(x, R):\n    \"\"\"\n    Affine map from x in [-1,1] to r in [0, R].\n    r = (R/2)*(x + 1)\n    \"\"\"\n    return 0.5 * R * (x + 1.0)\n\ndef integrand_r(r, a, bu, bv, Delta0):\n    \"\"\"\n    f(r) = r^2 * u(r) * v(r) * Delta(r)\n         = Delta0 * r^3 * exp(-r^2/2 * (1/bu^2 + 1/bv^2 + 1/a^2))\n    \"\"\"\n    inv_bu2 = 1.0 / (bu * bu)\n    inv_bv2 = 1.0 / (bv * bv)\n    inv_a2 = 1.0 / (a * a)\n    expo = -0.5 * (inv_bu2 + inv_bv2 + inv_a2) * (r * r)\n    return Delta0 * (r ** 3) * np.exp(expo)\n\ndef exact_integral(a, bu, bv, Delta0):\n    \"\"\"\n    I_exact = Delta0 * integral_0^inf r^3 exp(-alpha * r^2) dr\n            = Delta0 * (1 / (2 * alpha^2))\n    where alpha = 0.5 * (1/bu^2 + 1/bv^2 + 1/a^2).\n    \"\"\"\n    inv_bu2 = 1.0 / (bu * bu)\n    inv_bv2 = 1.0 / (bv * bv)\n    inv_a2 = 1.0 / (a * a)\n    alpha = 0.5 * (inv_bu2 + inv_bv2 + inv_a2)\n    return Delta0 / (2.0 * alpha * alpha)\n\ndef quadrature_integral(method, N, a, bu, bv, Delta0, R):\n    \"\"\"\n    Compute the quadrature approximation on [0, R] via mapping from [-1,1].\n    method: 'GL' or 'GLL'\n    \"\"\"\n    if method == 'GL':\n        x, w = gauss_legendre(N)\n    elif method == 'GLL':\n        x, w = gauss_lobatto(N)\n    else:\n        raise ValueError(\"Unknown method\")\n    r = map_to_radius(x, R)\n    drdx = 0.5 * R\n    f = integrand_r(r, a, bu, bv, Delta0)\n    return np.sum(w * drdx * f)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (a, bu, bv, Delta0, R)\n    test_cases = [\n        (2.5, 2.0, 2.0, 1.2, 12.0),\n        (1.8, 1.2, 2.8, 0.8, 12.0),\n        (0.8, 0.8, 0.8, 2.0, 8.0),\n    ]\n    Ns = [8, 16, 24, 32]\n\n    results = []\n    for (a, bu, bv, Delta0, R) in test_cases:\n        I_exact = exact_integral(a, bu, bv, Delta0)\n        for N in Ns:\n            I_GL = quadrature_integral('GL', N, a, bu, bv, Delta0, R)\n            I_GLL = quadrature_integral('GLL', N, a, bu, bv, Delta0, R)\n            err_GL = abs(I_GL - I_exact) / abs(I_exact)\n            err_GLL = abs(I_GLL - I_exact) / abs(I_exact)\n            results.append(err_GL)\n            results.append(err_GLL)\n\n    # Final print statement in the exact required format.\n    # Format with scientific notation for clarity and reproducibility.\n    formatted = \",\".join(f\"{x:.12e}\" for x in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "当被积函数具有尖锐特征时，例如反应截面中的阈值行为，标准求积网格往往会失效。本练习要求您超越标准方法，通过实现一个自定义的非线性坐标变换来应对这一挑战。您的目标是创建一个能够将计算节点“聚集”在最需要它们的地方的网格，从而显著提高对奇异或急剧变化函数的计算精度。",
            "id": "3561465",
            "problem": "您的任务是构建并测试一个高斯求积法则，该法则通过在 $x=1$ 附近呈指数形式聚集节点，以解析计算核物理中典型的破裂截面阈值行为。在阈值附近，截面通常表现为 $\\sigma(E) \\sim (E - E_{\\text{th}})^{\\nu}$，其中指数为 $\\nu$，$E_{\\text{th}}$ 是阈值能量，且 $\\nu  -1$ 确保了可积性。将能量线性缩放到无量纲变量 $x \\in [0,1]$，使得 $x=1$ 对应于 $E=E_{\\text{th}}$，阈值行为变为 $\\sigma(x) \\propto (1-x)^{\\nu}$。您的任务是设计一种在 $[0,1]$ 上的高斯求积方法，该方法使用指数变量变换在 $x=1$ 附近聚集节点，并量化从矩形式的积分表示中提取 $\\nu$ 的准确性。\n\n基本原理：使用 $[-1,1]$ 上高斯求积的定义、积分的变量替换定理以及用于精确矩的贝塔函数恒等式。具体来说，对于 $[a,b]$ 上任何足够光滑的函数 $f(x)$，具有 $N$ 个节点 $\\{x_i\\}_{i=1}^N$ 和权重 $\\{w_i\\}_{i=1}^N$ 的高斯求积近似为\n$$\n\\int_a^b f(x)\\,dx \\approx \\sum_{i=1}^N w_i f(x_i).\n$$\n变量替换 $x = \\varphi(s)$（其雅可比行列式为 $dx/ds$）可将积分变换为\n$$\n\\int_0^1 f(x)\\,dx = \\int_0^1 f(\\varphi(s)) \\frac{d\\varphi}{ds}(s) \\, ds.\n$$\n对于模型截面 $\\sigma(x) = (1-x)^{\\nu}$，定义整数 $m \\ge 1$ 的矩，\n$$\nI_m(\\nu) \\equiv \\int_0^1 x^m (1-x)^{\\nu} \\, dx = B(m+1,\\nu+1) = \\frac{\\Gamma(m+1)\\Gamma(\\nu+1)}{\\Gamma(m+\\nu+2)}.\n$$\n那么，比率\n$$\nR_m(\\nu) \\equiv \\frac{I_m(\\nu)}{I_{m-1}(\\nu)} = \\frac{m}{m+\\nu+1},\n$$\n给定一个数值估计值 $\\widehat{R}_m$，可以得出一个 $\\nu$ 的估计量\n$$\n\\widehat{\\nu} = \\frac{m}{\\widehat{R}_m} - m - 1.\n$$\n\n按如下方式设计在 $[0,1]$ 上的指数聚集求积。从 $[-1,1]$ 上的Gauss–Legendre求积开始，其节点为 $\\{u_i\\}$，权重为 $\\{\\omega_i\\}$（$i=1,\\dots,N$）。通过 $s_i = (u_i+1)/2$ 和 $\\tilde{\\omega}_i = \\omega_i/2$ 映射到 $s \\in [0,1]$。然后应用由参数 $\\alpha  0$ 控制的指数聚集映射 $\\varphi_{\\alpha}(s)$，\n$$\nx = \\varphi_{\\alpha}(s) \\equiv \\frac{1 - e^{-\\alpha s}}{1 - e^{-\\alpha}},\n$$\n该映射满足 $\\varphi_{\\alpha}(0)=0$，$\\varphi_{\\alpha}(1)=1$，并且随着 $\\alpha$ 的增大，在 $x=1$ 附近聚集更多节点。其雅可比行列式为\n$$\n\\frac{d\\varphi_{\\alpha}}{ds}(s) = \\frac{\\alpha e^{-\\alpha s}}{1 - e^{-\\alpha}}.\n$$\n于是，指数聚集求積的近似值为\n$$\n\\int_0^1 f(x)\\,dx \\approx \\sum_{i=1}^N \\tilde{\\omega}_i \\, f(\\varphi_{\\alpha}(s_i)) \\, \\frac{d\\varphi_{\\alpha}}{ds}(s_i).\n$$\n\n任务：\n- 实现两种数值求积方法来近似 $I_{m-1}(\\nu)$ 和 $I_m(\\nu)$：\n  1. 在 $[0,1]$ 上的标准Gauss–Legendre求积，使用 $N$ 个节点。\n  2. 在 $[0,1]$ 上的指数聚集求积，使用 $N$ 个节点和如上定义的聚集参数 $\\alpha$。\n- 对两种求积方法，都使用矩比率估计量计算 $\\widehat{\\nu}$，并量化绝对误差 $|\\widehat{\\nu} - \\nu|$。\n- 不涉及物理单位；所有量均为无量纲。\n- 不涉及角度。\n- 任何分数或小数在最终输出中都应表示为小数。\n\n测试套件：\n评估以下参数集 $(\\nu, N, \\alpha, m)$ 的绝对误差：\n1. $(\\nu, N, \\alpha, m) = (0.5, 8, 4.0, 3)$，一个典型的近阈值半整数情况。\n2. $(\\nu, N, \\alpha, m) = (1.5, 8, 4.0, 3)$，更陡峭的阈值行为。\n3. $(\\nu, N, \\alpha, m) = (0.5, 4, 4.0, 2)$，使用少量节点以测试低分辨率行为。\n4. $(\\nu, N, \\alpha, m) = (0.1, 8, 2.0, 3)$，弱阈值。\n5. $(\\nu, N, \\alpha, m) = (-0.4, 12, 6.0, 3)$，近阈值的可积发散（$\\nu  -1$ 的边界情况）。\n\n对于每个测试用例，计算三个浮点数：\n- 指数聚集求積的绝对误差， $|\\widehat{\\nu}_{\\text{cluster}} - \\nu|$。\n- 普通Gauss–Legendre求积的绝对误差， $|\\widehat{\\nu}_{\\text{plain}} - \\nu|$。\n- 改进比率，定义为 $|\\widehat{\\nu}_{\\text{plain}} - \\nu| / \\max(|\\widehat{\\nu}_{\\text{cluster}} - \\nu|, 10^{-18})$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，按测试用例排序，且每个测试用例内按上述顺序排序。也就是说，输出必须是\n$$\n\\big[ \\; \\text{err}_{\\text{cluster},1}, \\text{err}_{\\text{plain},1}, \\text{improv}_1, \\dots, \\text{err}_{\\text{cluster},5}, \\text{err}_{\\text{plain},5}, \\text{improv}_5 \\; \\big].\n$$",
            "solution": "审查问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n-   **物理动机**：模拟核破裂截面在阈值能量 $E_{\\text{th}}$ 附近的行为，其中截面 $\\sigma(E)$ 表现为 $(E - E_{\\text{th}})^{\\nu}$，且 $\\nu  -1$。经过缩放至 $x \\in [0,1]$ 后，该行为变为 $\\sigma(x) \\propto (1-x)^{\\nu}$。\n-   **积分近似**：一个 $N$ 点高斯求积在 $[a,b]$ 上将积分近似为 $\\int_a^b f(x)\\,dx \\approx \\sum_{i=1}^N w_i f(x_i)$。\n-   **变量替换**：给定了恒等式 $\\int_0^1 f(x)\\,dx = \\int_0^1 f(\\varphi(s)) \\frac{d\\varphi}{ds}(s) \\, ds$。\n-   **模型积分（矩）**：$I_m(\\nu) \\equiv \\int_0^1 x^m (1-x)^{\\nu} \\, dx$。\n-   **精确解析形式**：矩由贝塔函数给出，$I_m(\\nu) = B(m+1,\\nu+1) = \\frac{\\Gamma(m+1)\\Gamma(\\nu+1)}{\\Gamma(m+\\nu+2)}$。\n-   **矩比率**：对于整数 $m \\ge 1$，$R_m(\\nu) \\equiv \\frac{I_m(\\nu)}{I_{m-1}(\\nu)} = \\frac{m}{m+\\nu+1}$。\n-   **指数估计量**：根据估计的比率 $\\widehat{R}_m$，指数 $\\nu$ 的估计值为 $\\widehat{\\nu} = \\frac{m}{\\widehat{R}_m} - m - 1$。\n-   **求积构建**：\n    1.  从 $[-1,1]$ 上的 $N$ 点Gauss–Legendre求积开始，其节点为 $\\{u_i\\}$，权重为 $\\{\\omega_i\\}$。\n    2.  通过 $s_i = (u_i+1)/2$ 和权重 $\\tilde{\\omega}_i = \\omega_i/2$ 映射到 $s \\in [0,1]$。\n    3.  应用指数聚集映射 $x = \\varphi_{\\alpha}(s) \\equiv \\frac{1 - e^{-\\alpha s}}{1 - e^{-\\alpha}}$，参数为 $\\alpha  0$。\n    4.  此映射的雅可比行列式为 $\\frac{d\\varphi_{\\alpha}}{ds}(s) = \\frac{\\alpha e^{-\\alpha s}}{1 - e^{-\\alpha}}$。\n-   **聚集求积法则**：$\\int_0^1 f(x)\\,dx \\approx \\sum_{i=1}^N \\tilde{\\omega}_i \\, f(\\varphi_{\\alpha}(s_i)) \\, \\frac{d\\varphi_{\\alpha}}{ds}(s_i)$。\n-   **任务**：比较两种求积方案在计算矩和估计 $\\nu$ 方面的表现。\n    1.  在 $[0,1]$ 上的标准 $N$ 点Gauss–Legendre求积。\n    2.  在 $[0,1]$ 上带有参数 $\\alpha$ 的 $N$ 点指数聚集求积。\n-   **性能指标**：对每个测试用例，计算：\n    1.  聚集求积的绝对误差：$|\\widehat{\\nu}_{\\text{cluster}} - \\nu|$。\n    2.  普通求积的绝对误差：$|\\widehat{\\nu}_{\\text{plain}} - \\nu|$。\n    3.  改进比率：$|\\widehat{\\nu}_{\\text{plain}} - \\nu| / \\max(|\\widehat{\\nu}_{\\text{cluster}} - \\nu|, 10^{-18})$。\n-   **测试参数**：需要在五组 $(\\nu, N, \\alpha, m)$ 参数下进行评估：$(0.5, 8, 4.0, 3)$、$(1.5, 8, 4.0, 3)$、$(0.5, 4, 4.0, 2)$、$(0.1, 8, 2.0, 3)$ 和 $(-0.4, 12, 6.0, 3)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题在数值分析和计算物理学中有充分的依据。使用变量替换来调整求积法则以适应被积函数的解析结构是一种标准且强大的技术。模型函数 $(1-x)^{\\nu}$ 是阈值行为的典型表示。所有提供的数学公式，包括矩的贝塔函数恒等式、矩比率、$\\nu$ 的估计量、坐标变换及其雅可比行列式都是正确的。条件 $\\nu  -1$ 确保了模型函数的可积性，所有测试用例都正确地满足了这一条件。\n-   **适定性**：该问题定义精确。它要求基于一套清晰的指令和测试参数，实现并定量比较两种数值方法。每个测试用例都保证存在唯一、稳定且有意义的数值解。\n-   **客观性**：该问题以客观的数学语言陈述，没有歧义或主观断言。任务是执行数值计算，这本质上是客观的。\n\n该问题没有表现出验证标准中列出的任何缺陷。它科学合理、形式明确、完整、现实且适定。在改进比率的分母中包含一个穩定化的小数（$10^{-18}$）表明了仔细的数值考虑。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供一个解决方案。\n\n目标是比较两种数值求积方法在估计表现出阈值行为的函数 $f(x) \\propto (1-x)^{\\nu}$ 的指数 $\\nu$ 时的准确性。该比较通过评估从数值计算的函数矩中导出的估计指数 $\\widehat{\\nu}$ 的绝对误差来进行。\n\n数值程序的核心是计算形如 $I_m(\\nu) = \\int_0^1 x^m (1-x)^{\\nu} dx$ 的积分。这将通过两种类型的高斯求积来完成，两者都源自区间 $[-1,1]$ 上的基本Gauss-Legendre求积。设 $[-1,1]$ 上 $N$ 点Gauss-Legendre求积的节点和权重分别为 $\\{u_i\\}_{i=1}^N$ 和 $\\{\\omega_i\\}_{i=1}^N$。\n\n**1. 在 $[0,1]$ 上的标准Gauss–Legendre求积**\n\n这种方法，我们称之为“普通”求积，是通过将区间从 $[-1,1]$ 线性变换到 $[0,1]$ 获得的。变量 $u \\in [-1,1]$ 通过 $x(u) = (u+1)/2$ 映射到 $x \\in [0,1]$。对积分应用变量替换定理，得到：\n$$\n\\int_0^1 f(x) \\, dx = \\int_{-1}^1 f\\left(\\frac{u+1}{2}\\right) \\frac{1}{2} \\, du\n$$\n对关于 $u$ 的积分应用Gauss-Legendre法则，得出近似值：\n$$\n\\int_0^1 f(x) \\, dx \\approx \\sum_{i=1}^N \\omega_i f\\left(\\frac{u_i+1}{2}\\right) \\frac{1}{2} = \\sum_{i=1}^N w_i^{\\text{plain}} f(x_i^{\\text{plain}})\n$$\n其中在 $[0,1]$ 上的节点为 $x_i^{\\text{plain}} = (u_i+1)/2$，对应的权重为 $w_i^{\\text{plain}} = \\omega_i/2$。这种方法将节点对称地分布在区间内，这对于像 $(1-x)^{\\nu}$ 这样在端点处有急剧变化或奇异性的被积函数来说并非最优。\n\n**2. 在 $[0,1]$ 上的指数聚集求积**\n\n此方法采用非线性变量替换，旨在将求积节点聚集在感兴趣的点 $x=1$ 附近。我们首先使用 $s(u)=(u+1)/2$ 将基准区间 $[-1,1]$ 映射到中间区间 $s \\in [0,1]$。然后，我们应用指数映射 $x = \\varphi_{\\alpha}(s)$ 将积分从 $x$ 域变换到 $s$ 域：\n$$\n\\int_0^1 f(x) \\, dx = \\int_0^1 f(\\varphi_{\\alpha}(s)) \\frac{d\\varphi_{\\alpha}}{ds}(s) \\, ds\n$$\n其中映射及其雅可比行列式由下式给出：\n$$\n\\varphi_{\\alpha}(s) = \\frac{1 - e^{-\\alpha s}}{1 - e^{-\\alpha}} \\quad \\text{和} \\quad \\frac{d\\varphi_{\\alpha}}{ds}(s) = \\frac{\\alpha e^{-\\alpha s}}{1 - e^{-\\alpha}}\n$$\n对于聚集参数 $\\alpha  0$。然后使用区间 $[0,1]$ 的标准Gauss-Legendre法则来近似关于 $s$ 的积分：\n$$\n\\int_0^1 f(x) \\, dx \\approx \\sum_{i=1}^N w_i^{\\text{plain}} \\left[ f(\\varphi_{\\alpha}(s_i)) \\frac{d\\varphi_{\\alpha}}{ds}(s_i) \\right]\n$$\n其中 $s_i = (u_i+1)/2$ 且 $w_i^{\\text{plain}} = \\omega_i/2$。这可以看作是原始变量 $x$ 中的一个求积法则，其节点为 $x_i^{\\text{cluster}} = \\varphi_{\\alpha}(s_i)$，有效权重为 $w_i^{\\text{cluster}} = w_i^{\\text{plain}} \\cdot \\frac{d\\varphi_{\\alpha}}{ds}(s_i)$。随着 $\\alpha$ 的增加，该变换将（在某种意义上均匀分布的）节点 $s_i$ 集中为在 $x=1$ 附近变得密集的节点 $x_i^{\\text{cluster}}$，从而更好地解析被积函数在阈值附近的行为。\n\n**3. $\\nu$ 的估计与误差分析**\n\n对于每种求积方法，矩 $I_{m-1}(\\nu)$ 和 $I_m(\\nu)$ 都被数值近似，得到估计值 $\\widehat{I}_{m-1}$ 和 $\\widehat{I}_{m}$。计算比率 $\\widehat{R}_m = \\widehat{I}_m / \\widehat{I}_{m-1}$，然后使用给定的公式得到指数的估计值 $\\widehat{\\nu}$：\n$$\n\\widehat{\\nu} = \\frac{m}{\\widehat{R}_m} - m - 1\n$$\n然后，通过绝对误差 $|\\widehat{\\nu} - \\nu|$ 来量化每种方法的准确性。实现将为每个指定的测试用例计算普通求积和聚集求积的此误差。最后，这些误差的比率提供了对聚集节点方法所提供改进的定量度量。\n\n实现将使用 `scipy.special.roots_legendre` 来获取基本节点 $\\{u_i\\}$ 和权重 $\\{\\omega_i\\}$。所有计算将使用 `numpy` 进行高效的向量化操作。将定义辅助函数来为每种求积方案计算 $\\widehat{\\nu}$，并通过一个主循环遍历所有测试用例以生成最终结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\n# Ensure floating point precision in calculations and output\nnp.set_printoptions(precision=16)\n\ndef compute_nu_hat_plain(nu, N, m):\n    \"\"\"\n    Computes the estimated exponent nu_hat using standard Gauss-Legendre quadrature on [0,1].\n    \"\"\"\n    # Get base Gauss-Legendre nodes and weights on [-1, 1]\n    u, omega = roots_legendre(N)\n    \n    # Linearly transform nodes and weights to [0, 1]\n    x_nodes = (u + 1.0) / 2.0\n    w_nodes = omega / 2.0\n    \n    # Define the integrands for moments m-1 and m\n    # f(x) = x^k * (1-x)^nu\n    integrand_m_minus_1 = np.power(x_nodes, m - 1) * np.power(1.0 - x_nodes, nu)\n    integrand_m = np.power(x_nodes, m) * np.power(1.0 - x_nodes, nu)\n    \n    # Compute the moments via quadrature sum\n    I_hat_m_minus_1 = np.sum(w_nodes * integrand_m_minus_1)\n    I_hat_m = np.sum(w_nodes * integrand_m)\n    \n    # Compute the ratio and estimate nu\n    if I_hat_m_minus_1 == 0:\n        # Avoid division by zero, return NaN to indicate failure\n        return np.nan\n        \n    R_hat_m = I_hat_m / I_hat_m_minus_1\n    nu_hat = m / R_hat_m - m - 1.0\n    \n    return nu_hat\n\ndef compute_nu_hat_clustered(nu, N, alpha, m):\n    \"\"\"\n    Computes the estimated exponent nu_hat using exponentially clustered quadrature on [0,1].\n    \"\"\"\n    # Get base Gauss-Legendre nodes and weights on [-1, 1]\n    u, omega = roots_legendre(N)\n    \n    # Linearly transform to intermediate variable s on [0, 1]\n    s_nodes = (u + 1.0) / 2.0\n    w_tilde = omega / 2.0\n    \n    # Apply the exponential clustering map: x = phi(s)\n    common_denom = 1.0 - np.exp(-alpha)\n    x_nodes = (1.0 - np.exp(-alpha * s_nodes)) / common_denom\n    \n    # Calculate the Jacobian of the map at each node\n    jacobian = (alpha * np.exp(-alpha * s_nodes)) / common_denom\n    \n    # The effective weights for the integral over x are w_tilde * jacobian\n    w_effective = w_tilde * jacobian\n    \n    # Define the integrands at the new clustered nodes\n    # Note: (1-x_nodes) is guaranteed to be > 0 because u_i are in (-1,1)\n    integrand_m_minus_1 = np.power(x_nodes, m - 1) * np.power(1.0 - x_nodes, nu)\n    integrand_m = np.power(x_nodes, m) * np.power(1.0 - x_nodes, nu)\n    \n    # Compute the moments via quadrature sum\n    I_hat_m_minus_1 = np.sum(w_effective * integrand_m_minus_1)\n    I_hat_m = np.sum(w_effective * integrand_m)\n    \n    # Compute the ratio and estimate nu\n    if I_hat_m_minus_1 == 0:\n        return np.nan\n        \n    R_hat_m = I_hat_m / I_hat_m_minus_1\n    nu_hat = m / R_hat_m - m - 1.0\n    \n    return nu_hat\n\ndef solve():\n    \"\"\"\n    Main solver function to run through test cases and print results.\n    \"\"\"\n    test_cases = [\n        (0.5, 8, 4.0, 3),\n        (1.5, 8, 4.0, 3),\n        (0.5, 4, 4.0, 2),\n        (0.1, 8, 2.0, 3),\n        (-0.4, 12, 6.0, 3),\n    ]\n\n    results = []\n    for nu, N, alpha, m in test_cases:\n        # Calculate nu_hat for both methods\n        nu_hat_cluster = compute_nu_hat_clustered(nu, N, alpha, m)\n        nu_hat_plain = compute_nu_hat_plain(nu, N, m)\n        \n        # Calculate absolute errors\n        err_cluster = abs(nu_hat_cluster - nu)\n        err_plain = abs(nu_hat_plain - nu)\n        \n        # Calculate improvement ratio with a small number to prevent division by zero\n        improvement = err_plain / max(err_cluster, 1e-18)\n        \n        results.extend([err_cluster, err_plain, improvement])\n\n    # Format the final output string as required\n    output_str = f\"[{','.join(f'{r:.15f}' for r in results)}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "核物理中的动量空间积分常常跨越多个数量级，这对标准的线性网格构成了严峻挑战。本练习展示了对数映射在高效处理这种宽动态范围问题上的威力。此外，它还引入了至关重要的数值稳定性概念，分析了在处理“刚性”被积函数时，不同的求积方案如何可能受到舍入误差的影响。",
            "id": "3561470",
            "problem": "考虑计算核物理中出现的动量空间积分，其中一个典型的三维 (3D) 径向动量积分可简化为形式为 $\\int f(p)\\,dp$ 的一维积分，积分范围覆盖了很宽的动量动态范围。为解决跨越多个数量级的刚性问题，使用对数映射 $x=\\log p$，从而在变量 $x$ 中进行求积。从换元定理和高斯求积的核心定义出发（除了映射和用于$[-1,1]$上高斯求积的线性区间变换外，不假设任何专门的公式），推导在映射 $x=\\log p$ 下，从 $p\\in[10^{-3}\\Lambda,10^{3}\\Lambda]$ 的 $p$ 域转换到 $x\\in[\\log(10^{-3}\\Lambda),\\log(10^{3}\\Lambda)]$ 的 $x$ 域时，高斯节点和权重的变换。对数的参数必须是无量纲的；因此，在动量由一个固定的参考尺度 $\\Lambda$ 进行缩放的单位制中进行计算，并定义无量纲动量 $q=p/\\Lambda$，使得 $q\\in[10^{-3},10^{3}]$ 且 $x=\\log q$。\n\n你的任务是为一组代表动量核的刚性测试被积函数，实现带和不带对数映射的高斯求积，并评估其稳定性。使用以下基础：\n- 积分的换元定理：如果 $q=\\phi(x)$ 是在 $[a,b]$ 上的一个可微双射，则 $\\int_{q(a)}^{q(b)} f(q)\\,dq=\\int_{a}^{b} f(\\phi(x))\\,\\phi'(x)\\,dx$。\n- $[-1,1]$ 上的高斯-勒让德求积定义：对于一个足够光滑的函数 $g(x)$，$\\int_{-1}^{1} g(x)\\,dx\\approx\\sum_{i=1}^{N} w_i\\,g(t_i)$，其中 $t_i$ 和 $w_i$ 是高斯-勒让德节点和权重，并且线性映射将此求积推广到任何有限区间。\n\n对于形式为 $\\int_{10^{-3}}^{10^{3}} f(q)\\,dq$ 的积分，在进行 $x=\\log q$ 映射后，构建其求积公式，并讨论变换后的权重如何依赖于 $x$。将给定求积评估的数值稳定性度量定义为比率\n$$\nR=\\frac{\\max_i \\left|c_i\\right|}{\\sum_{j} \\left|c_j\\right|},\n$$\n其中 $c_i$ 是每个节点对求积和的单独加权贡献。解释 $R$ 如何反映少数节点的主导作用，以及这与刚性问题有何关联。设计并实现一个数值稳定的求和策略。\n\n实现两种求积方案：\n- 在 $q\\in[10^{-3},10^{3}]$ 上直接使用高斯-勒让德求积。\n- 通过 $x=\\log q$ 在 $x\\in[\\log 10^{-3},\\log 10^{3}]$ 上使用对数映射的高斯-勒让德求積。\n\n两种方案均使用 $N=64$ 个节点。为了获得高精度的参考值，使用一个自适应积分器以严格的容差计算 $\\int_{10^{-3}}^{10^{3}} f(q)\\,dq$。\n\n测试套件：\n处理以下在 $q\\in[10^{-3},10^{3}]$ 上的无量纲被积函数 $f(q)$，这些函数被选择用来检验各种刚性特征。所有结果都是无量纲的，因此不需要物理单位。\n1. 理想情况（正则化主体）：$f_1(q)=q^2\\,e^{-q^2}$。\n2. 在 $q=1$ 附近的窄局域峰：其中 $\\gamma=10^{-3}$，$f_2(q)=\\dfrac{q^2\\,e^{-q^2}}{(q-1)^2+\\gamma^2}$。\n3. 重尾抑制：$f_3(q)=\\dfrac{q^2}{1+q^8}$。\n4. 在下边界附近的边缘局域化：其中 $\\gamma=10^{-4}$，$f_4(q)=\\dfrac{q^2}{(q-10^{-3})^2+\\gamma^2}$。\n5. 在上边界附近的边缘局域化：其中 $\\gamma=1$，$f_5(q)=\\dfrac{q^2}{(q-10^{3})^2+\\gamma^2}$。\n\n对每个 $f_k$ 计算：\n- 对数映射求积的相对误差，$E^{\\mathrm{log}}_k=\\left|\\dfrac{I^{\\mathrm{log}}_k-I^{\\mathrm{ref}}_k}{I^{\\mathrm{ref}}_k}\\right|$，其中 $I^{\\mathrm{log}}_k$ 是 $N=64$ 对数映射高斯-勒让德求积的估计值，$I^{\\mathrm{ref}}_k$ 是高精度参考值。\n- 在 $q$ 上的直接求积的相对误差，$E^{\\mathrm{dir}}_k=\\left|\\dfrac{I^{\\mathrm{dir}}_k-I^{\\mathrm{ref}}_k}{I^{\\mathrm{ref}}_k}\\right|$。\n- 使用对数映射贡献值的稳定性度量 $R^{\\mathrm{log}}_k$。\n- 使用直接求积贡献值的稳定性度量 $R^{\\mathrm{dir}}_k$。\n\n数值求和必须采用补偿方法来减少舍入误差。如果出现任何角度，均以弧度表示；所有测试函数都不涉及角度。所有输出均为无量纲实数。你的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，按如下顺序排列\n$$\n\\left[ E^{\\mathrm{log}}_1,E^{\\mathrm{dir}}_1,R^{\\mathrm{log}}_1,R^{\\mathrm{dir}}_1,\\;E^{\\mathrm{log}}_2,E^{\\mathrm{dir}}_2,R^{\\mathrm{log}}_2,R^{\\mathrm{dir}}_2,\\;\\dots,\\;E^{\\mathrm{log}}_5,E^{\\mathrm{dir}}_5,R^{\\mathrm{log}}_5,R^{\\mathrm{dir}}_5\\right].\n$$\n每个条目必须打印为十进制浮点数。两种求积方案至少使用 $N=64$ 个高斯-勒让德节点，并为参考积分使用严格的绝对和相对容差。\n\n你的推导和实现必须基于换元定理和高斯求积的定义。不要提供快捷公式；展示变换后的权重和节点如何从第一性原理得出，并分析稳定性度量如何捕捉求积和中的刚性。",
            "solution": "该问题要求针对大对数尺度上的动量空间积分，推导并实现两种高斯求积方案，并分析其数值稳定性。我们首先按照要求，从第一性原理推导求积公式。\n\n设我们感兴趣的积分是 $I = \\int_{q_a}^{q_b} f(q) dq$，其中对于无量纲动量 $q$，积分域为 $[q_a, q_b] = [10^{-3}, 10^{3}]$。两种方案的基础都是在标准区间 $[-1, 1]$ 上的 N 点高斯-勒让德求积法则：\n$$\n\\int_{-1}^{1} g(t)\\,dt \\approx \\sum_{i=1}^{N} w_i^{\\text{std}} g(t_i^{\\text{std}})\n$$\n其中 $t_i^{\\text{std}}$ 是节点（第N阶勒让德多项式的零点），$w_i^{\\text{std}}$ 是相应的权重。\n\n**1. 在 $q \\in [q_a, q_b]$ 上的直接高斯-勒让德求积**\n\n为了将高斯求积应用于区间 $[q_a, q_b]$，我们引入一个线性变换，将标准变量 $t \\in [-1, 1]$ 映射到物理变量 $q \\in [q_a, q_b]$。设该映射为 $q(t) = c_1 t + c_0$。边界条件 $q(-1) = q_a$ 和 $q(1) = q_b$ 决定了常数：\n$$\n-c_1 + c_0 = q_a \\quad \\text{和} \\quad c_1 + c_0 = q_b\n$$\n解此方程组可得 $c_1 = \\frac{q_b - q_a}{2}$ 和 $c_0 = \\frac{q_b + q_a}{2}$。变换为：\n$$\nq(t) = \\frac{q_b - q_a}{2}t + \\frac{q_b + q_a}{2}\n$$\n微分元变换为 $dq = \\frac{dq}{dt}dt = \\frac{q_b - q_a}{2}dt$。将此代入原积分，我们得到一个在标准区间 $[-1, 1]$ 上的积分：\n$$\nI = \\int_{q_a}^{q_b} f(q)\\,dq = \\int_{-1}^{1} f(q(t)) \\frac{dq}{dt}\\,dt = \\int_{-1}^{1} f\\left(\\frac{q_b - q_a}{2}t + \\frac{q_b + q_a}{2}\\right) \\frac{q_b - q_a}{2}\\,dt\n$$\n应用高斯-勒让德法则，该积分可近似为以下和式：\n$$\nI^{\\text{dir}} \\approx \\sum_{i=1}^{N} w_i^{\\text{std}} \\left[ f\\left(\\frac{q_b - q_a}{2}t_i^{\\text{std}} + \\frac{q_b + q_a}{2}\\right) \\right] \\left( \\frac{q_b - q_a}{2} \\right)\n$$\n这可以表示为一个标准的求积和 $I^{\\text{dir}} = \\sum_{i=1}^{N} w_i^{\\text{dir}}f(q_i)$，其中 $q$ 域中的节点 $q_i$ 和权重 $w_i^{\\text{dir}}$ 为：\n$$\nq_i = \\frac{q_b - q_a}{2}t_i^{\\text{std}} + \\frac{q_b + q_a}{2}\n$$\n$$\nw_i^{\\text{dir}} = w_i^{\\text{std}} \\left( \\frac{q_b - q_a}{2} \\right)\n$$\n对和的各项贡献为 $c_i^{\\text{dir}} = w_i^{\\text{dir}}f(q_i)$。\n\n**2. 对数映射的高斯-勒让德求积**\n\n对于宽动态范围上的积分，对数换元通常是有利的。我们应用映射 $x = \\log q$，这意味着 $q = e^x$。微分变换为 $dq = e^x dx$。新变量 $x$ 的积分限变为 $x_a = \\log q_a$ 和 $x_b = \\log q_b$。\n根据换元定理，积分变换为：\n$$\nI = \\int_{q_a}^{q_b} f(q)\\,dq = \\int_{x_a}^{x_b} f(e^x)e^x\\,dx\n$$\n让我们将变换后的被积函数定义为 $G(x) = f(e^x)e^x$。问题现在变为计算 $I = \\int_{x_a}^{x_b} G(x)\\,dx$。我们再次使用从标准区间 $t \\in [-1, 1]$ 到 $x$ 域区间 $[x_a, x_b]$ 的线性映射：\n$$\nx(t) = \\frac{x_b - x_a}{2}t + \\frac{x_b + x_a}{2}\n$$\n微分为 $dx = \\frac{x_b - x_a}{2}dt$。积分变为：\n$$\nI = \\int_{-1}^{1} G(x(t)) \\frac{dx}{dt}\\,dt = \\int_{-1}^{1} G\\left(\\frac{x_b - x_a}{2}t + \\frac{x_b + x_a}{2}\\right) \\frac{x_b - x_a}{2}\\,dt\n$$\n应用高斯-勒让德法则得到近似值：\n$$\nI^{\\text{log}} \\approx \\sum_{i=1}^{N} w_i^{\\text{std}} \\left[ G\\left(\\frac{x_b - x_a}{2}t_i^{\\text{std}} + \\frac{x_b + x_a}{2}\\right) \\right] \\left( \\frac{x_b - x_a}{2} \\right)\n$$\n为了用原始被积函数 $f(q)$ 来解释这个结果，我们代回 $G(x) = f(e^x)e^x$。$x$ 域中的节点是 $x_i = \\frac{x_b - x_a}{2}t_i^{\\text{std}} + \\frac{x_b + x_a}{2}$。原始 $q$ 域中对应的节点是 $q_i = e^{x_i}$。求积和为：\n$$\nI^{\\text{log}} = \\sum_{i=1}^{N} w_i^{\\text{std}} \\left[ f(e^{x_i})e^{x_i} \\right] \\left( \\frac{x_b - x_a}{2} \\right) = \\sum_{i=1}^{N} w_i^{\\text{std}} \\left[ f(q_i) q_i \\right] \\left( \\frac{\\log q_b - \\log q_a}{2} \\right)\n$$\n这可以写成 $I^{\\text{log}} = \\sum_{i=1}^{N} w_i^{\\text{log}}f(q_i)$ 形式的和，其中 $q$ 域中的有效权重 $w_i^{\\text{log}}$ 为：\n$$\nw_i^{\\text{log}} = w_i^{\\text{std}} \\cdot q_i \\cdot \\left( \\frac{\\log q_b - \\log q_a}{2} \\right)\n$$\n各项贡献为 $c_i^{\\text{log}} = w_i^{\\log}f(q_i)$。与直接法不同，这些有效权重不是恒定的；它们与节点位置 $q_i$ 成正比。这意味着位于较大动量处的节点被赋予更大的权重，这抵消了节点 $q_i=e^{x_i}$ 按 $1/q$ 密度分布的效应。\n\n**3. 数值稳定性度量与刚性**\n\n稳定性度量定义为 $R = \\frac{\\max_i |c_i|}{\\sum_j |c_j|}$，其中 $c_i$ 是每个节点的加权贡献 $w_i f(q_i)$。该度量量化了各项贡献对积分总值的均匀程度。\n- 较小的 $R$ 值（接近理想值 $1/N$）表示许多节点都对总和做出了显著贡献。求积是稳定的，因为结果是许多点的平均值，使其对函数求值或节点配置中的小误差具有鲁棒性。\n- 较大的 $R$ 值（接近 1）意味着求和由单个贡献项主导。积分实际上被一个点近似，即 $I \\approx c_k = w_k f(q_k)$。这对所选的求积方案来说是一个“刚性”问题的信号。结果是数值不稳定的：它对主导节点 $q_k$ 的精确位置高度敏感，并且由于求积网格未能解析被积函数的结构，容易产生大的截断误差。当被积函数有一个被大多数节点错过的尖锐窄峰时，通常会发生这种主导情况。\n\n直接求积法分布节点的密度在 $[q_a, q_b]$ 中心附近近似均匀，并向端点处增加。如果被积函数具有在对数尺度上局域化的特征（例如，在小 $q$ 处的尖峰或跨越多个数量级的重尾），这种线性节点配置是低效的。它可能会在感兴趣的区域分配过少的节点，导致稳定性度量 $R^{\\text{dir}}$ 很大且精度很差。\n\n对数映射求积法分布节点 $q_i=e^{x_i}$，使得每个动量数量级内的节点数是恒定的。这对于具有多尺度行为、低动量尖锐特征或幂律尾的被积函数非常有效。通过变量替换，被积函数在新坐标 $x$ 中通常被转换为一个更平滑的函数，对于这样的函数，标准的高斯-勒让德求积非常高效。这导致了更均匀分布的贡献 $|c_i^{\\text{log}}|$，从而得到一个更小、更理想的稳定性度量 $R^{\\text{log}}$。\n\n为了确保求和的准确性，特别是当贡献项 $c_i$ 跨越多个数量级变化时，需要使用补偿求和算法（如 Kahan 求和）来减轻浮点舍入误差造成的精度损失。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Derives, implements, and compares direct and log-mapped Gaussian quadrature\n    for stiff integrands in computational physics.\n    \"\"\"\n\n    def kahan_sum(arr):\n        \"\"\"Numerically stable summation using the Kahan algorithm.\"\"\"\n        s = 0.0\n        c = 0.0\n        for x in arr:\n            y = x - c\n            t = s + y\n            c = (t - s) - y\n            s = t\n        return s\n\n    # Problem Parameters\n    N = 64\n    q_min, q_max = 1e-3, 1e3\n    \n    # Test suite of integrands\n    gamma2 = 1e-3\n    gamma4 = 1e-4\n    gamma5 = 1.0\n\n    functions = [\n        (\"f1\", lambda q: q**2 * np.exp(-q**2)),\n        (\"f2\", lambda q: (q**2 * np.exp(-q**2)) / ((q - 1.0)**2 + gamma2**2)),\n        (\"f3\", lambda q: q**2 / (1.0 + q**8)),\n        (\"f4\", lambda q: q**2 / ((q - q_min)**2 + gamma4**2)),\n        (\"f5\", lambda q: q**2 / ((q - q_max)**2 + gamma5**2)),\n    ]\n\n    # Standard Gauss-Legendre nodes and weights on [-1, 1]\n    t_std, w_std = np.polynomial.legendre.leggauss(N)\n\n    # --- Direct Gauss-Legendre Quadrature Setup ---\n    # Linear mapping t -> q\n    # q(t) = a*t + b, where a = (q_max-q_min)/2, b = (q_max+q_min)/2\n    a_q = 0.5 * (q_max - q_min)\n    b_q = 0.5 * (q_max + q_min)\n    q_nodes_dir = a_q * t_std + b_q\n    w_dir = a_q * w_std\n\n    # --- Log-Mapped Gauss-Legendre Quadrature Setup ---\n    x_min, x_max = np.log(q_min), np.log(q_max)\n    # Linear mapping t -> x\n    # x(t) = a*t + b, where a = (x_max-x_min)/2, b = (x_max+x_min)/2\n    a_x = 0.5 * (x_max - x_min)\n    b_x = 0.5 * (x_max + x_min)\n    x_nodes = a_x * t_std + b_x\n    q_nodes_log = np.exp(x_nodes)\n    \n    # Effective weights in q-space for log mapping\n    # w_log_i = w_std_i * q_i * (x_max - x_min) / 2\n    w_log_factor = a_x\n    w_log = w_std * q_nodes_log * w_log_factor\n\n    results = []\n\n    for name, f in functions:\n        # 1. High-accuracy reference integral\n        i_ref, _ = quad(f, q_min, q_max, epsabs=1e-15, epsrel=1e-15, limit=200)\n\n        # 2. Direct Quadrature\n        f_vals_dir = f(q_nodes_dir)\n        contributions_dir = w_dir * f_vals_dir\n        i_dir = kahan_sum(contributions_dir)\n        \n        abs_contributions_dir = np.abs(contributions_dir)\n        r_dir = np.max(abs_contributions_dir) / kahan_sum(abs_contributions_dir) if kahan_sum(abs_contributions_dir) != 0 else 0.0\n        e_dir = np.abs((i_dir - i_ref) / i_ref) if i_ref != 0 else np.abs(i_dir)\n\n        # 3. Log-Mapped Quadrature\n        f_vals_log = f(q_nodes_log)\n        contributions_log = w_log * f_vals_log\n        i_log = kahan_sum(contributions_log)\n\n        abs_contributions_log = np.abs(contributions_log)\n        r_log = np.max(abs_contributions_log) / kahan_sum(abs_contributions_log) if kahan_sum(abs_contributions_log) != 0 else 0.0\n        e_log = np.abs((i_log - i_ref) / i_ref) if i_ref != 0 else np.abs(i_log)\n\n        results.extend([e_log, e_dir, r_log, r_dir])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}