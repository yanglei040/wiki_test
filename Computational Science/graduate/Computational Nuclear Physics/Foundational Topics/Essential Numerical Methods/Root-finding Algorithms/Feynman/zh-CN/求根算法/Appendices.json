{
    "hands_on_practices": [
        {
            "introduction": "理论上优秀的算法在实践中可能会出人意料地失败。本练习将通过一个看似简单的例子 $f(x)=\\tan(x)$，探讨牛顿法在奇点附近的灾难性失效问题 。您将分析为何在有限精度计算中，即使精确的牛顿步长很小，巨大的中间计算结果也会导致算法崩溃，并学习如何通过变换方程和使用稳健的二分法来规避此类问题。",
            "id": "3532425",
            "problem": "在计算高能散射分析中出现的有限体积量子化条件中，必须求解一个相位变量的超越边界条件。考虑一个求解余弦函数奇数半周期附近根的代理子问题，其中一个朴素的公式使用了正切函数。设 $f(x)=\\tan(x)$，并假设应用牛顿法 $x_{n+1}=x_n - f(x_n)/f'(x_n)$，初始猜测值为 $x_0=\\frac{\\pi}{2}-\\epsilon$，其中 $0\\epsilon\\ll 1$（角度以弧度为单位）。假设在有限动态范围的算术中，即使真实的更新量很小，无界增长的中间值也可能导致失败。\n\nA部分。仅使用三角函数的标准定义和牛顿法，分析 $f(x)=\\tan(x)$ 在 $x=\\frac{\\pi}{2}$ 附近的牛顿更新量，并根据与 $\\epsilon$ 的标度关系解释为什么直接计算 $f(x_n)$ 和 $f'(x_n)$ 在有限精度算术中可能导致灾难性步骤，尽管精确的牛顿更新量仍然是 $\\mathcal{O}(\\epsilon)$。\n\nB部分。提出一种安全措施方法，将方程变换为 $g(x)=\\cos(x)$，其在 $x\\approx \\frac{\\pi}{2}$ 附近的根等价于目标条件，并将此变换与在包含根的区间 $[a,b]=[1.4,1.8]$ 上使用二分法相结合。仅使用从介值定理推导出的二分法性质以及每次迭代将区间长度减半的事实，确定保证 $N$ 次二分法步骤后的中点在 $x$ 上的绝对误差小于或等于容差 $\\tau=10^{-12}$ 所需的最小整数迭代次数 $N$。\n\n你的最终答案应该是单个整数 $N$。除了报告这个整数外，不需要其他四舍五入的说明。角度以弧度为单位，$N$ 不需要物理单位。",
            "solution": "我们从牛顿法的定义开始：对于一个可微函数 $f(x)$，迭代公式为 $x_{n+1}=x_n-\\frac{f(x_n)}{f'(x_n)}$。对于 $f(x)=\\tan(x)$，我们有 $f'(x)=\\sec^{2}(x)=\\frac{1}{\\cos^{2}(x)}$。\n\nA部分。设 $x_n=\\frac{\\pi}{2}-\\epsilon$，其中 $0\\epsilon\\ll 1$。使用象限角附近的标准三角展开，我们有 $\\sin\\!\\left(\\frac{\\pi}{2}-\\epsilon\\right)=\\cos(\\epsilon)$ 和 $\\cos\\!\\left(\\frac{\\pi}{2}-\\epsilon\\right)=\\sin(\\epsilon)$。对于小的 $\\epsilon$，它们的行为如同 $\\cos(\\epsilon)=1+\\mathcal{O}(\\epsilon^{2})$ 和 $\\sin(\\epsilon)=\\epsilon+\\mathcal{O}(\\epsilon^{3})$。因此，\n$$\n\\tan\\!\\left(\\tfrac{\\pi}{2}-\\epsilon\\right)=\\frac{\\sin\\!\\left(\\tfrac{\\pi}{2}-\\epsilon\\right)}{\\cos\\!\\left(\\tfrac{\\pi}{2}-\\epsilon\\right)}=\\frac{\\cos(\\epsilon)}{\\sin(\\epsilon)}=\\cot(\\epsilon)\\sim \\frac{1}{\\epsilon},\n$$\n并且\n$$\n\\sec^{2}\\!\\left(\\tfrac{\\pi}{2}-\\epsilon\\right)=\\frac{1}{\\cos^{2}\\!\\left(\\tfrac{\\pi}{2}-\\epsilon\\right)}=\\frac{1}{\\sin^{2}(\\epsilon)}\\sim \\frac{1}{\\epsilon^{2}}.\n$$\n因此，朴素地计算的牛顿修正项 $-\\frac{f(x_n)}{f'(x_n)}=-\\frac{\\tan(x_n)}{\\sec^{2}(x_n)}$ 的精确大小为\n$$\n-\\frac{\\tan(x_n)}{\\sec^{2}(x_n)}=-\\tan(x_n)\\cos^{2}(x_n)=-\\frac{\\sin(x_n)}{\\cos(x_n)}\\cos^{2}(x_n)=-\\sin(x_n)\\cos(x_n).\n$$\n使用 $\\sin\\!\\left(\\tfrac{\\pi}{2}-\\epsilon\\right)\\sim 1$ 和 $\\cos\\!\\left(\\tfrac{\\pi}{2}-\\epsilon\\right)\\sim \\epsilon$，精确的更新量简化为\n$$\n-\\sin(x_n)\\cos(x_n)\\sim -\\epsilon,\n$$\n其量级为 $\\mathcal{O}(\\epsilon)$，因此在精确算术中是小的且表现良好。\n\n然而，在具有有限动态范围的浮点算术中，直接构造 $f(x_n)=\\tan(x_n)\\sim \\epsilon^{-1}$ 和 $f'(x_n)=\\sec^{2}(x_n)\\sim \\epsilon^{-2}$ 会产生随着 $\\epsilon\\to 0^{+}$ 而无界增长的中间量。尽管最终的比率是 $\\epsilon$ 量级，但在除法运算恢复出一个小结果之前，分别计算 $\\epsilon^{-1}$ 和 $\\epsilon^{-2}$ 可能会发生溢出或严重损失精度。这就是灾难性行为的本质：牛顿步长本身并非内在地大，但通过其标准形式的 $f$ 和 $f'$ 进行的朴素计算需要处理像 $\\epsilon^{-1}$ 和 $\\epsilon^{-2}$ 那样缩放的中间量，这些量可能超出可表示的范围或遭受严重的舍入误差，从而导致失败或极不准确的更新。一个代数上稳定的计算，如 $-\\sin(x_n)\\cos(x_n)$，可以避免这个问题，但一个更稳健的补救措施是改变目标函数以完全消除附近的奇点。\n\nB部分。一种安全措施方法是将方程变换为 $g(x)=\\cos(x)$，它在 $x\\approx \\frac{\\pi}{2}$ 附近有相同的目标根，但在该根的邻域内没有奇点。在区间 $[a,b]=[1.4,1.8]$ 上，我们验证 $g(a)\\,g(b)0$，因为 $\\cos(1.4)>0$ 且 $\\cos(1.8)0$，所以根据介值定理，该区间内至少有一个根。二分法通过重复地将包含根的区间减半来进行。设初始区间长度为 $L_{0}=b-a$。经过 $N$ 次二分法步骤后，区间长度为\n$$\nL_{N}=\\frac{L_{0}}{2^{N}}.\n$$\n如果我们将 $N$ 步后的中点作为近似值 $\\tilde{x}_{N}$，那么绝对误差满足\n$$\n|\\,\\tilde{x}_{N}-x^{\\ast}\\,|\\leq \\frac{L_{N}}{2}=\\frac{L_{0}}{2^{N+1}},\n$$\n其中 $x^{\\ast}$ 是在 $[a,b]$ 中的真实根。为保证绝对误差不超过容差 $\\tau=10^{-12}$，我们需要\n$$\n\\frac{L_{0}}{2^{N+1}}\\leq \\tau.\n$$\n当 $L_{0}=b-a=1.8-1.4=0.4$ 时，此条件变为\n$$\n\\frac{0.4}{2^{N+1}}\\leq 10^{-12}\\quad\\Longleftrightarrow\\quad 2^{N+1}\\geq \\frac{0.4}{10^{-12}}=4\\times 10^{11}.\n$$\n等价地，\n$$\n2^{N}\\geq \\frac{4\\times 10^{11}}{2}=2\\times 10^{11}.\n$$\n两边取以2为底的对数，并利用 $N$ 必须是整数这一事实，最小的 $N$ 是\n$$\nN=\\left\\lceil \\log_{2}\\!\\left(2\\times 10^{11}\\right)\\right\\rceil.\n$$\n由于 $\\log_{2}\\!\\left(2\\times 10^{11}\\right)=\\log_{2}(2)+\\log_{2}\\!\\left(10^{11}\\right)=1+11\\log_{2}(10)\\approx 1+11\\times 3.32192809489\\approx 37.5412090438$，我们得到\n$$\nN = 38.\n$$\n因此，$N=38$ 次二分法迭代足以保证中点近似值的绝对误差至多为 $\\tau=10^{-12}$，同时完全避免了在 $x=\\frac{\\pi}{2}$ 附近对 $f(x)=\\tan(x)$ 进行牛顿迭代时出现的不稳定奇异行为。",
            "answer": "$$\\boxed{38}$$"
        },
        {
            "introduction": "奇点和梯度剧变不仅是数学上的抽象概念，它们也频繁出现在真实的物理模型中，例如量子力学中的方势阱问题。本练习将引导您深入分析牛顿法在物理方程的极点附近的行为，并探讨多种关键的保护策略，如区间限定和线搜索 。掌握这些分析技巧对于构建专业级的数值计算工具至关重要，它能确保您的求解器在面对复杂函数时依然保持稳定和收敛。",
            "id": "3588646",
            "problem": "考虑一个宽度为 $a>0$、深度为 $V_0>0$ 的一维有限方势阱，在计算核物理中用作玩具模型，以近似平均场中的单粒子束缚态。在区间 $0  E  V_0$ 内的束缚态能量 $E$ 由超越方程 $k\\tan(ka/2) = \\kappa$ 决定，其中 $k=\\sqrt{2mE/\\hbar^2}$ 且 $\\kappa=\\sqrt{2m(V_0-E)/\\hbar^2}$（$m$ 为粒子质量，$\\hbar$ 为约化普朗克常数）。通过定义 $\\alpha = \\frac{a}{2}\\sqrt{\\frac{2m}{\\hbar^2}}$，该方程可以重写为关于 $E$ 的寻根问题 $f(E)=0$，其中\n$$\nf(E) = \\sqrt{E} \\tan(\\alpha\\sqrt{E}) - \\sqrt{V_0-E}\n$$\n当直接应用牛顿法求解 $f(E)=0$ 时，会出现一些数值上的挑战。\n\n以下哪些关于处理这个特定寻根问题的数值策略的陈述是真实的？\nA. 函数 $f(E)$ 在 $\\tan(\\alpha\\sqrt{E})$ 的极点处存在奇点（即当 $\\alpha\\sqrt{E_n} = \\pi/2 + n\\pi$ 对整数 $n$ 成立时）。在这些点附近，朴素的牛顿法会因函数值和导数的发散而失效。\nB. 方程可以通过乘以分母 $\\cos(\\alpha\\sqrt{E})$ 进行正则化，从而得到一个等价的、在整个定义域内无奇点的寻根问题 $g(E) = \\sqrt{E}\\sin(\\alpha\\sqrt{E}) - \\sqrt{V_0-E}\\cos(\\alpha\\sqrt{E}) = 0$。\nC. 如果一个牛顿步导致迭代点远离当前位置或增加了函数值的绝对值，应采用线搜索或信赖域等全局化策略来修改步长，以确保稳健收敛。\nD. 如果已知一个包含根的区间（例如通过初步的函数评估或物理洞察），那么结合牛顿法和二分法的混合方法是一种保证收敛的稳健策略。",
            "solution": "### 问题验证与分析\n\n任务是评估关于求解超越方程 $f(E) = \\sqrt{E} \\tan(\\alpha\\sqrt{E}) - \\sqrt{V_0-E} = 0$ 的四个数值策略陈述的真实性。\n\n**步骤 1：分析问题**\n- **物理背景**：一维有限方势阱的束缚态能量。\n- **数学方程**：$f(E) = 0$，其中 $f(E)$ 包含一个正切函数 $\\tan(\\alpha\\sqrt{E})$。\n- **核心挑战**：正切函数在其参数等于 $\\pi/2 + n\\pi$ 时具有垂直渐近线（极点），这会导致函数 $f(E)$ 在这些点附近出现奇点。直接应用牛顿法会遇到困难。\n\n**步骤 2：逐一评估每个陈述**\n\n- **陈述 A**：该陈述指出 $f(E)$ 在 $\\tan(\\alpha\\sqrt{E})$ 的极点处有奇点。这是正确的。当自变量 $\\alpha\\sqrt{E}$ 接近 $\\pi/2 + n\\pi$ 时，$\\tan(\\alpha\\sqrt{E})$ 的值趋于 $\\pm\\infty$。因此，$f(E)$ 的值和其导数 $f'(E)$ 都会发散。牛顿法的迭代步长 $E_{k+1} = E_k - f(E_k)/f'(E_k)$ 会变得不可预测且通常非常大，导致算法无法收敛。因此，陈述A是**真实**的。\n\n- **陈述 B**：该陈述建议通过乘以 $\\cos(\\alpha\\sqrt{E})$ 来消除奇点。原始方程是 $\\sqrt{E}\\frac{\\sin(\\alpha\\sqrt{E})}{\\cos(\\alpha\\sqrt{E})} = \\sqrt{V_0-E}$。将两边都乘以 $\\cos(\\alpha\\sqrt{E})$ 得到 $\\sqrt{E}\\sin(\\alpha\\sqrt{E}) = \\sqrt{V_0-E}\\cos(\\alpha\\sqrt{E})$，整理后即为 $g(E) = \\sqrt{E}\\sin(\\alpha\\sqrt{E}) - \\sqrt{V_0-E}\\cos(\\alpha\\sqrt{E}) = 0$。这个新函数 $g(E)$ 是连续且可微的，它与 $f(E)$ 具有相同的根（除了在 $\\cos(\\alpha\\sqrt{E})=0$ 的点，但这些点不是 $f(E)=0$ 的解），并且没有奇点。这种“正则化”是处理此类问题的标准技巧。因此，陈述B是**真实**的。\n\n- **陈述 C**：该陈述描述了牛顿法的“全局化”策略。纯牛顿法仅保证在足够接近根的邻域内收敛（局部收敛）。当迭代点离根较远时，一个完整的牛顿步长可能会“过冲”，导致迭代发散。线搜索（通过减小步长来确保函数值的绝对值下降）和信赖域方法是两种标准技术，用于增强牛顿法的收敛范围和稳健性，防止其因不良步长而失败。因此，陈述C是**真实**的。\n\n- **陈述 D**：该陈述描述了混合（或混合）算法。二分法虽然收敛慢，但只要初始区间包含根，它就保证收敛。牛顿法收敛快，但不可靠。将两者结合的混合方法（如布伦特方法）是一种非常强大和流行的策略。其基本思想是：尝试一个快速的牛顿步；如果该步骤“安全”（例如，仍在包围区间内并显著减小了区间长度），则接受它；否则，回退到更慢但绝对可靠的二分步。这确保了最坏情况下的收敛性，同时在函数表现良好时利用了牛顿法的速度。因此，陈述D是**真实**的。\n\n### 结论\n所有四个陈述都准确地描述了在求解具有奇点的非线性方程时所面临的挑战以及用于克服这些挑战的有效数值策略。因此，所有选项都是正确的。",
            "answer": "$$\\boxed{ABCD}$$"
        },
        {
            "introduction": "作为总结性练习，我们将综合运用前面学到的知识，解决一个来自现代核物理研究的复杂问题：求解有限温度下的能隙方程 。这项实践要求您亲手实现一个混合算法——牛顿-二分法，它巧妙地结合了牛顿法的快速收敛性与二分法的绝对可靠性。通过完成这个练习，您将掌握在科研实践中开发高效且稳健的数值求解器的核心技术。",
            "id": "3532433",
            "problem": "考虑一个在自然单位制（普朗克常数 $\\hbar$、光速 $c$ 和玻尔兹曼常数 $k_{\\mathrm{B}}$ 均设为 $1$）下表述的相对论性 Nambu-Jona-Lasinio 类型有限温能隙方程，其中所有能量、动量和温度都以吉电子伏特 (GeV) 为单位进行测量。对于动力学质量能隙 $\\Delta \\ge 0$，准粒子色散建模为 $E_{p}(\\Delta) = \\sqrt{p^{2} + \\Delta^{2}}$，有限温能隙方程由非线性函数定义\n$$\nf(\\Delta) \\equiv \\Delta - \\lambda \\int_{|p| \\le \\Lambda} d^{3}p \\,\\frac{\\tanh\\!\\left(\\dfrac{E_{p}(\\Delta)}{2T}\\right)}{2\\,E_{p}(\\Delta)} \\,,\n$$\n其中 $\\lambda$ 为耦合参数（单位为 $\\mathrm{GeV}^{-1}$），$\\Lambda$ 为紫外动量截断（单位为 $\\mathrm{GeV}$），$T$ 为温度（单位为 $\\mathrm{GeV}$）。利用球对称性，该积分可以表示为\n$$\n\\int_{|p| \\le \\Lambda} d^{3}p \\,\\frac{\\tanh\\!\\left(\\dfrac{E_{p}(\\Delta)}{2T}\\right)}{2\\,E_{p}(\\Delta)} \\;=\\; 4\\pi \\int_{0}^{\\Lambda} p^{2}\\,\\frac{\\tanh\\!\\left(\\dfrac{\\sqrt{p^{2}+\\Delta^{2}}}{2T}\\right)}{2\\,\\sqrt{p^{2}+\\Delta^{2}}}\\,dp \\,.\n$$\n双曲正切函数遵循恒等式 $\\tanh\\!\\left(\\dfrac{E}{2T}\\right) = 1 - 2\\,n_{\\mathrm{F}}(E)$，其中 $n_{\\mathrm{F}}(E) = \\dfrac{1}{e^{E/T}+1}$ 是费米–狄拉克分布。从 $n_{\\mathrm{F}}(E)$ 的基本性质和 $E_{p}(\\Delta)$ 的正性可以得出，对于 $\\Delta \\ge 0$，$f(\\Delta)$ 在 $\\Delta$ 上是严格单调递增的，并且 $f(0)  0$ 而 $\\lim_{\\Delta \\to \\infty} f(\\Delta) > 0$，这保证了存在唯一的正根 $\\Delta^{\\star} > 0$。\n\n任务：\n- 从第一性原理出发，推导一个算法，通过结合牛顿–拉夫逊方法和二分法，为给定的 $(\\lambda,\\Lambda,T)$ 稳健地找到 $f(\\Delta) = 0$ 的唯一根 $\\Delta^{\\star}$。设计必须满足：\n  1. 利用 $f(\\Delta)$ 的单调性，从一个有数学依据的括号区间 $[\\Delta_{\\mathrm{L}}, \\Delta_{\\mathrm{R}}]$ 开始。\n  2. 通过从基本定义推导出的导数 $\\dfrac{df}{d\\Delta}$ 计算牛顿–拉夫逊步，并且仅当该步长保持在当前括号区间内且能减小残差时才接受它；否则，回退到二分步。\n  3. 对于 $\\Delta > 0$，使用数值稳定的求积法来计算 $f(\\Delta)$ 及其导数 $\\dfrac{df}{d\\Delta}$ 的积分。\n- 在一个完整、可运行的程序中实现这种牛顿–二分混合方法，该程序为指定的测试套件输出 $\\Delta^{\\star}$ 的数值。\n\n单位与答案：\n- 所有输入 $\\lambda$、$\\Lambda$ 和 $T$ 必须分别以 $\\mathrm{GeV}^{-1}$、$\\mathrm{GeV}$ 和 $\\mathrm{GeV}$ 为单位处理。\n- 程序必须以浮点数形式输出能隙值 $\\Delta^{\\star}$，单位为 $\\mathrm{GeV}$。\n- 每个报告的 $\\Delta^{\\star}$ 值必须四舍五入到6位小数。\n\n测试套件：\n- 使用以下参数三元组 $(\\lambda,\\Lambda,T)$，这些三元组探测了不同的物理区域：\n  1. $(\\lambda, \\Lambda, T) = (\\,\\;0.10\\,\\mathrm{GeV}^{-1},\\;\\;1.00\\,\\mathrm{GeV},\\;\\;0.05\\,\\mathrm{GeV}\\;\\,)$\n  2. $(\\lambda, \\Lambda, T) = (\\,\\;0.20\\,\\mathrm{GeV}^{-1},\\;\\;1.00\\,\\mathrm{GeV},\\;\\;0.01\\,\\mathrm{GeV}\\;\\,)$\n  3. $(\\lambda, \\Lambda, T) = (\\,\\;0.10\\,\\mathrm{GeV}^{-1},\\;\\;1.00\\,\\mathrm{GeV},\\;\\;0.20\\,\\mathrm{GeV}\\;\\,)$\n  4. $(\\lambda, \\Lambda, T) = (\\,\\;0.05\\,\\mathrm{GeV}^{-1},\\;\\;0.50\\,\\mathrm{GeV},\\;\\;0.02\\,\\mathrm{GeV}\\;\\,)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按上述测试套件顺序计算的四个 $\\Delta^{\\star}$ 值，格式为用方括号括起来的逗号分隔列表，例如：\n$$\n\\texttt{[0.123456,0.234567,0.345678,0.456789]}\n$$\n不应打印任何额外文本。",
            "solution": "该问题陈述是计算物理学中一个有效且适定的问题。它要求推导并实现一个稳健的数值算法，以求解一个特定的非线性方程。\n\n**问题陈述分析**\n任务是找到方程 $f(\\Delta) = 0$ 的唯一正根 $\\Delta^{\\star}$，其中函数 $f(\\Delta)$ 由一个 Nambu-Jona-Lasinio 类型的能隙方程给出。该函数定义为：\n$$f(\\Delta) \\equiv \\Delta - \\lambda \\int_{|p| \\le \\Lambda} d^{3}p \\,\\frac{\\tanh\\!\\left(\\dfrac{E_{p}(\\Delta)}{2T}\\right)}{2\\,E_{p}(\\Delta)}$$\n此处，$E_{p}(\\Delta) = \\sqrt{p^{2} + \\Delta^{2}}$ 是准粒子能量，$\\lambda$ 是耦合常数，$\\Lambda$ 是动量截断，而 $T$ 是温度。使用球坐标，积分简化为：\n$$f(\\Delta) = \\Delta - 2\\pi\\lambda \\int_{0}^{\\Lambda} p^{2}\\,\\frac{\\tanh\\!\\left(\\dfrac{\\sqrt{p^{2}+\\Delta^{2}}}{2T}\\right)}{\\sqrt{p^{2}+\\Delta^{2}}}\\,dp$$\n问题保证了对于 $\\Delta \\ge 0$，$f(\\Delta)$ 是严格单调递增的，且 $f(0)  0$ 和 $\\lim_{\\Delta \\to \\infty} f(\\Delta) > 0$。这些性质确保了唯一正根 $\\Delta^{\\star} > 0$ 的存在。\n\n**算法的推导**\n所要求的算法是牛顿-拉夫逊方法和二分法的混合体。\n\n**1. 牛顿-拉夫逊分量与导数计算**\n牛顿-拉夫逊方法通过迭代寻找根：$\\Delta_{k+1} = \\Delta_k - \\frac{f(\\Delta_k)}{f'(\\Delta_k)}$。这需要计算 $f(\\Delta)$ 关于 $\\Delta$ 的导数。由于积分限 $0$ 和 $\\Lambda$ 相对于 $\\Delta$ 是常数，我们使用莱布尼茨积分法则（在积分符号下求导）来计算这个导数。\n$$f'(\\Delta) = \\frac{d}{d\\Delta} \\left( \\Delta - 2\\pi\\lambda \\int_{0}^{\\Lambda} p^{2}\\,\\frac{\\tanh\\left(\\frac{E_{p}(\\Delta)}{2T}\\right)}{E_{p}(\\Delta)}\\,dp \\right)$$\n$$f'(\\Delta) = 1 - 2\\pi\\lambda \\int_{0}^{\\Lambda} p^{2} \\frac{d}{d\\Delta} \\left[ \\frac{\\tanh\\left(\\frac{E_{p}(\\Delta)}{2T}\\right)}{E_{p}(\\Delta)} \\right] dp$$\n使用链式法则 $\\frac{d}{d\\Delta} = \\frac{dE_p}{d\\Delta} \\frac{d}{dE_p}$，其中 $\\frac{dE_p}{d\\Delta} = \\frac{\\Delta}{E_p}$。将括号中的项对 $E_p$ 求导得到：\n$$\\frac{d}{dE_p}\\left[ \\frac{\\tanh(E_p/2T)}{E_p} \\right] = \\frac{\\left(\\frac{1}{2T}\\text{sech}^2\\left(\\frac{E_p}{2T}\\right)\\right)E_p - \\tanh\\left(\\frac{E_p}{2T}\\right)}{E_p^2}$$\n将其代回，我们得到导数的完整表达式：\n$$ f'(\\Delta) = 1 - 2\\pi\\lambda\\Delta \\int_{0}^{\\Lambda} \\frac{p^2}{E_p^3(\\Delta)} \\left[ \\frac{E_p(\\Delta)}{2T}\\text{sech}^2\\left(\\frac{E_p(\\Delta)}{2T}\\right) - \\tanh\\left(\\frac{E_p(\\Delta)}{2T}\\right) \\right] dp $$\n这个导数对于牛顿-拉夫逊步至关重要，但在 $\\Delta = 0$ 时是未定义的，因为被积函数会发散。因此，任何计算都必须在 $\\Delta > 0$ 的条件下进行。\n\n**2. 括号区间**\n一个稳健的求根算法始于一个保证包含根的区间 $[\\Delta_L, \\Delta_R]$，即 $f(\\Delta_L)  0$ 且 $f(\\Delta_R) > 0$。\n- **下界 $\\Delta_L$**：问题陈述 $f(0)  0$。为避免 $f'(0)$ 的奇异性，我们选择一个小的正数 $\\Delta_L = \\epsilon > 0$（例如 $\\epsilon=10^{-12}$）。由于 $f$ 是连续的，$f(\\epsilon) \\approx f(0)  0$。\n- **上界 $\\Delta_R$**：可以构建一个有数学依据的上界。我们需要 $f(\\Delta_R) > 0$，这意味着 $\\Delta_R > 2\\pi\\lambda\\int_{0}^{\\Lambda}p^2\\frac{\\tanh(E_p(\\Delta_R)/2T)}{E_p(\\Delta_R)}dp$。函数 $g(x) = \\frac{\\tanh(x)}{x}$ 在 $x>0$ 时是严格递减的。由于对于 $\\Delta > 0$，有 $E_p(\\Delta) = \\sqrt{p^2+\\Delta^2} > p = E_p(0)$，我们得到 $E_p(\\Delta)/2T > p/2T$，这意味着 $\\frac{\\tanh(E_p/2T)}{E_p/2T}  \\frac{\\tanh(p/2T)}{p/2T}$。这导致了被积函数之间的不等式：$p^2\\frac{\\tanh(E_p(\\Delta_R)/2T)}{E_p(\\Delta_R)}  p^2 \\frac{\\tanh(p/2T)}{p} = p \\tanh(p/2T)$。对两边积分可以得到一个上界的候选。我们定义 $\\Delta_{R} = -f(0) = 2\\pi\\lambda \\int_{0}^{\\Lambda} p \\tanh\\left(\\frac{p}{2T}\\right) dp$。通过这个选择，我们有：\n$$ f(\\Delta_R) = \\Delta_R - 2\\pi\\lambda \\int_{0}^{\\Lambda} p^2 \\frac{\\tanh(E_p(\\Delta_R)/2T)}{E_p(\\Delta_R)} dp > \\Delta_R - 2\\pi\\lambda \\int_{0}^{\\Lambda} p \\tanh\\left(\\frac{p}{2T}\\right) dp = \\Delta_R - \\Delta_R = 0 $$\n因此，区间 $[\\epsilon, -f(0)]$ 为根 $\\Delta^{\\star}$ 提供了一个稳健且有数学依据的括号。\n\n**3. 混合迭代策略**\n对于给定的容差 $\\tau$，算法按以下步骤进行：\n1. 按上文推导初始化括号区间 $[\\Delta_L, \\Delta_R]$。设 $\\Delta_k$ 为当前对根的最佳猜测。\n2. 在每次迭代中，从 $\\Delta_k$ 计算牛顿-拉夫逊步：$\\Delta_{NR} = \\Delta_k - f(\\Delta_k)/f'(\\Delta_k)$。\n3. **接受条件**：如果牛顿步落在当前括号区间内（即 $\\Delta_L  \\Delta_{NR}  \\Delta_R$），则认为这是一个安全且有效的步骤。将下一个候选根设为 $\\Delta_{k+1} = \\Delta_{NR}$。\n4. **回退**：如果牛顿步超出括号区间，则认为其不可靠。算法必须回退到保证收敛（尽管速度较慢）的二分法。将下一个候选根设为括号区间的中点：$\\Delta_{k+1} = (\\Delta_L + \\Delta_R)/2$。\n5. **括号更新**：计算 $f(\\Delta_{k+1})$。根据其符号，将 $\\Delta_L$ 或 $\\Delta_R$ 更新为 $\\Delta_{k+1}$，以确保根在新的、更小的区间内仍然被包围。\n6. **终止**：重复此过程，直到括号区间的宽度 $\\Delta_R - \\Delta_L$ 小于指定的容差 $\\tau$。根的最终近似值是最终括号区间的中点。\n\n**4. 数值求积**\n$f(\\Delta)$ 和 $f'(\\Delta)$ 的积分没有初等的解析解，必须进行数值计算。为此，采用了稳健的自适应求积方法，例如 `scipy.integrate.quad` 提供的方法。对于 $\\Delta > 0$ 和 $p \\in [0, \\Lambda]$，被积函数是良态的，这确保了数值积分的可靠性。\n\n这种快速收敛（牛顿-拉夫逊）和稳健（二分）方法的结合，产生了一种高效可靠的寻找根 $\\Delta^{\\star}$ 的算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the NJL gap equation for a series of test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda [GeV^-1], Lambda [GeV], T [GeV])\n        (0.10, 1.00, 0.05),\n        (0.20, 1.00, 0.01),\n        (0.10, 1.00, 0.20),\n        (0.05, 0.50, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        lam, L, T = case\n        # Find the root for the given parameters.\n        try:\n            delta_star = find_gap_root(lam, L, T)\n            results.append(delta_star)\n        except (ValueError, RuntimeError) as e:\n            # Handle cases where root finding might fail, for robustness.\n            print(f\"Error solving for case {case}: {e}\")\n            results.append(np.nan)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\ndef find_gap_root(lam, L, T):\n    \"\"\"\n    Finds the root of the gap equation using a hybrid Newton-bisection method.\n\n    Args:\n        lam (float): Coupling parameter in GeV^-1.\n        L (float): Ultraviolet momentum cutoff in GeV.\n        T (float): Temperature in GeV.\n\n    Returns:\n        float: The calculated gap Delta* in GeV, rounded to 6 decimal places.\n    \"\"\"\n    PI = np.pi\n    TOL = 1e-9      # Convergence tolerance\n    MAX_ITER = 100  # Maximum number of iterations\n    EPS = 1e-12     # Small positive number to avoid singularities at Delta=0\n\n    # --- Integrands for f(Delta) and f'(Delta) ---\n    def integrand_f(p, delta, lam_p, L_p, T_p):\n        E = np.sqrt(p**2 + delta**2)\n        # The tanh can be numerically unstable if E/T is huge, but np.tanh handles it.\n        return p**2 * np.tanh(E / (2 * T_p)) / E\n\n    def integrand_fprime(p, delta, lam_p, L_p, T_p):\n        if delta  EPS:\n            return np.inf  # Derivative diverges at Delta=0\n        E = np.sqrt(p**2 + delta**2)\n        x = E / (2 * T_p)\n        # Using np.cosh for sech to avoid potential overflow/underflow with np.exp\n        sech_x = 1.0 / np.cosh(x)\n        tanh_x = np.tanh(x)\n        term_in_brackets = x * sech_x**2 - tanh_x\n        return p**2 / E**3 * term_in_brackets\n    \n    # Integrand for calculating the initial upper bound Delta_R = -f(0)\n    def integrand_f0(p, lam_p, L_p, T_p):\n        return p * np.tanh(p / (2 * T_p))\n\n    # --- Functions f(Delta) and f'(Delta) using numerical quadrature ---\n    def f(delta):\n        integral_val, _ = quad(integrand_f, 0, L, args=(delta, lam, L, T))\n        return delta - 2 * PI * lam * integral_val\n\n    def fprime(delta):\n        integral_val, _ = quad(integrand_fprime, 0, L, args=(delta, lam, L, T))\n        return 1.0 - 2 * PI * lam * delta * integral_val\n\n    # --- Step 1: Establish a bracketing interval [Delta_L, Delta_R] ---\n    delta_L = EPS\n    f_L = f(delta_L)\n\n    # Calculate Delta_R = -f(0)\n    integral_f0_val, _ = quad(integrand_f0, 0, L, args=(lam, L, T))\n    f0 = -2 * PI * lam * integral_f0_val\n    delta_R = -f0\n    f_R = f(delta_R)\n\n    if not (f_L  0 and f_R > 0):\n        # This fallback should not be needed based on the derivation, but is good practice.\n        delta_R = PI * lam * L**2 # A safe but loose upper bound\n        f_R = f(delta_R)\n        if f_R  0:\n            raise RuntimeError(\"Failed to bracket the root. The model parameters may be unphysical.\")\n\n    # --- Step 2: Hybrid Newton-Bisection Iteration ---\n    delta_k = (delta_L + delta_R) / 2.0  # Initial guess\n    \n    for i in range(MAX_ITER):\n        f_k = f(delta_k)\n        \n        # Check for convergence on the function value\n        if abs(f_k)  TOL:\n            break\n        \n        # Fallback to bisection if bracket is small enough\n        if (delta_R - delta_L)  TOL:\n            delta_k = (delta_L + delta_R) / 2.0\n            break\n        \n        # Calculate Newton step\n        fp_k = fprime(delta_k)\n        if abs(fp_k) > 1e-15:\n            delta_NR = delta_k - f_k / fp_k\n        else:\n            delta_NR = delta_L - 1 # Force bisection by making the step invalid\n        \n        # Accept Newton step only if it's within the current bracket\n        if delta_L  delta_NR  delta_R:\n            delta_k = delta_NR\n        else:\n            # Fallback to bisection if Newton step is not safe\n            delta_k = (delta_L + delta_R) / 2.0\n        \n        # Update the bracket\n        f_k_new = f(delta_k)\n        if f_k_new  0:\n            delta_L = delta_k\n        else:\n            delta_R = delta_k\n\n    return round(delta_k, 6)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}