{
    "hands_on_practices": [
        {
            "introduction": "Many functions in nuclear physics, such as the interaction potential between two nuclei, exhibit behavior across multiple length scales. They often vary sharply at short distances due to the interplay of nuclear and Coulomb forces, and transition to a much smoother, long-range tail. This exercise () demonstrates how a physically motivated, non-uniform grid, such as a logarithmic mesh, can provide a much more accurate spline interpolation than a simple uniform grid for the same number of sample points, a crucial technique for efficient and accurate calculations.",
            "id": "3566085",
            "problem": "You will quantify how a logarithmic coordinate mapping affects cubic spline interpolation error for a spherically symmetric potential that models the near-origin curvature typical of Coulomb-modified nuclear potentials. Consider a radially symmetric function $f(r)$, with $r$ measured in femtometers, defined as the sum of a finite-size-charge Coulomb potential and a Woods–Saxon (WS) nuclear potential. The Coulomb component is modeled by a uniformly charged sphere of radius $R_C$, so that $V_C(r)$ is given by\n$$\nV_C(r) = \n\\begin{cases}\n\\displaystyle \\frac{k}{2 R_C}\\left(3 - \\frac{r^2}{R_C^2}\\right), & r \\le R_C, \\\\\n\\displaystyle \\frac{k}{r}, & r > R_C,\n\\end{cases}\n$$\nwhere $k = \\left(\\frac{e^2}{4\\pi \\varepsilon_0}\\right) Z$ with $Z$ equal to the product $Z_1 Z_2$ of the projectile and target charges and $\\left(\\frac{e^2}{4\\pi \\varepsilon_0}\\right) \\approx 1.439964$ $\\mathrm{MeV \\cdot fm}$. The Woods–Saxon nuclear potential is defined as\n$$\nV_N(r) = -\\frac{V_0}{1 + \\exp\\left(\\frac{r - R_N}{a}\\right)},\n$$\nwith depth $V_0$ in mega-electron-volts, nuclear radius $R_N$ in femtometers, and diffuseness $a$ in femtometers. The total potential is $f(r) = V_C(r) + V_N(r)$, expressed in mega-electron-volts.\n\nTwo interpolation schemes must be constructed:\n- Scheme $\\mathrm{A}$: cubic spline interpolation using $N$ samples taken on a uniform grid in $r \\in [0, r_{\\max}]$.\n- Scheme $\\mathrm{B}$: cubic spline interpolation using $N$ samples taken uniformly in the logarithmic coordinate $x = \\ln\\left(1 + \\frac{r}{r_0}\\right)$ over $x \\in \\left[0, \\ln\\left(1 + \\frac{r_{\\max}}{r_0}\\right)\\right]$, mapped back to $r$ via $r = r_0\\left(e^x - 1\\right)$.\n\nFor both schemes, the spline is constructed in the physical coordinate $r$, and evaluated on a dense uniform grid of $M$ points in $r \\in [0, r_{\\max}]$ (with $M$ chosen large enough to be representative). The interpolation error for scheme $\\mathrm{A}$ is\n$$\nE_A = \\max_{i=1,\\dots,M} \\left| S_A(r_i) - f(r_i) \\right|,\n$$\nand for scheme $\\mathrm{B}$ is\n$$\nE_B = \\max_{i=1,\\dots,M} \\left| S_B(r_i) - f(r_i) \\right|,\n$$\nwhere $S_A$ and $S_B$ are the respective cubic spline interpolants and $\\{r_i\\}$ are the evaluation points. The effect of the logarithmic mapping is quantified by the error reduction factor\n$$\nR = \\frac{E_A}{E_B}.\n$$\n\nYou must implement a complete, runnable program that computes $E_A$, $E_B$, and $R$ for the following test suite of parameter sets. All energies and errors must be computed and reported in mega-electron-volts (MeV). Radii and lengths are in femtometers (fm). The evaluation grid size is $M = 1000$:\n- Test $1$ (general case): $Z = 20$, $R_C = 4.1$ $\\mathrm{fm}$, $R_N = 4.5$ $\\mathrm{fm}$, $a = 0.6$ $\\mathrm{fm}$, $V_0 = 50$ $\\mathrm{MeV}$, $r_0 = 1.0$ $\\mathrm{fm}$, $N = 50$, $r_{\\max} = 20.0$ $\\mathrm{fm}$.\n- Test $2$ (strong Coulomb, fewer samples): $Z = 82$, $R_C = 7.1$ $\\mathrm{fm}$, $R_N = 7.0$ $\\mathrm{fm}$, $a = 0.5$ $\\mathrm{fm}$, $V_0 = 50$ $\\mathrm{MeV}$, $r_0 = 0.5$ $\\mathrm{fm}$, $N = 30$, $r_{\\max} = 25.0$ $\\mathrm{fm}$.\n- Test $3$ (weak Coulomb, nuclear-dominated): $Z = 1$, $R_C = 1.0$ $\\mathrm{fm}$, $R_N = 1.2$ $\\mathrm{fm}$, $a = 0.5$ $\\mathrm{fm}$, $V_0 = 50$ $\\mathrm{MeV}$, $r_0 = 1.0$ $\\mathrm{fm}$, $N = 60$, $r_{\\max} = 15.0$ $\\mathrm{fm}$.\n- Test $4$ (large mapping scale, near-uniform sampling): $Z = 50$, $R_C = 5.6$ $\\mathrm{fm}$, $R_N = 5.6$ $\\mathrm{fm}$, $a = 0.6$ $\\mathrm{fm}$, $V_0 = 50$ $\\mathrm{MeV}$, $r_0 = 10.0$ $\\mathrm{fm}$, $N = 60$, $r_{\\max} = 20.0$ $\\mathrm{fm}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a triplet $[E_A,E_B,R]$ in mega-electron-volts, and the final output is the list of these triplets in order. For example, the output format must be exactly like $[[E_{A,1},E_{B,1},R_1],[E_{A,2},E_{B,2},R_2],[E_{A,3},E_{B,3},R_3],[E_{A,4},E_{B,4},R_4]]$.",
            "solution": "The problem requires a quantitative comparison of two cubic spline interpolation schemes for a spherically symmetric nuclear potential. The total potential, $f(r)$, is a sum of a Coulomb potential from a finite-sized charge distribution, $V_C(r)$, and a Woods-Saxon nuclear potential, $V_N(r)$. The goal is to compute the interpolation errors for a uniform radial grid (Scheme A) and a logarithmically spaced radial grid (Scheme B) and to quantify the improvement via their ratio.\n\nFirst, we define the potential function $f(r) = V_C(r) + V_N(r)$. All energies are in mega-electron-volts ($\\mathrm{MeV}$) and distances are in femtometers ($\\mathrm{fm}$). The Coulomb component, $V_C(r)$, models a uniformly charged sphere of radius $R_C$. Its functional form is piecewise:\n$$\nV_C(r) = \n\\begin{cases}\n\\displaystyle \\frac{k}{2 R_C}\\left(3 - \\frac{r^2}{R_C^2}\\right), & r \\le R_C, \\\\\n\\displaystyle \\frac{k}{r}, & r > R_C,\n\\end{cases}\n$$\nThe parameter $k$ is given by $k = \\left(\\frac{e^2}{4\\pi \\varepsilon_0}\\right) Z$, with the physical constant $\\left(\\frac{e^2}{4\\pi \\varepsilon_0}\\right) \\approx 1.439964 \\, \\mathrm{MeV \\cdot fm}$. This potential is continuous and has a continuous first derivative with respect to $r$ across the boundary $r=R_C$. However, the second derivative, $\\frac{d^2V_C}{dr^2}$, is discontinuous at $r=R_C$. Specifically, $\\frac{d^2V_C}{dr^2} = -\\frac{k}{R_C^3}$ for $r < R_C$ and $\\frac{d^2V_C}{dr^2} = \\frac{2k}{r^3}$ for $r > R_C$. This discontinuity at $r=R_C$ presents a challenge for high-order polynomial interpolation methods, such as cubic splines, which typically assume a higher degree of smoothness.\n\nThe nuclear potential, $V_N(r)$, is given by the standard Woods-Saxon form:\n$$\nV_N(r) = -\\frac{V_0}{1 + \\exp\\left(\\frac{r - R_N}{a}\\right)}\n$$\nThis function is infinitely differentiable ($C^\\infty$) for all $r>0$. The total potential $f(r)$ thus inherits the $C^1$ continuity and the second-derivative discontinuity from its Coulomb component.\n\nNext, we establish the two interpolation schemes. Both schemes use $N$ sample points to construct a cubic spline interpolant of $f(r)$ over the interval $[0, r_{\\max}]$.\n\nScheme A involves sampling the potential $f(r)$ at $N$ points distributed uniformly on the radial grid $r \\in [0, r_{\\max}]$. The sample points are $r_j = j \\cdot \\frac{r_{\\max}}{N-1}$ for $j=0, 1, \\dots, N-1$. A cubic spline, $S_A(r)$, is constructed using the data pairs $(r_j, f(r_j))$.\n\nScheme B uses a sampling grid that is uniform in a logarithmic coordinate $x$, defined by the transformation $x = \\ln\\left(1 + \\frac{r}{r_0}\\right)$. The $N$ sample points are chosen to be uniform in $x$ over the interval $\\left[0, \\ln\\left(1 + \\frac{r_{\\max}}{r_0}\\right)\\right]$. These points are then mapped back to the radial coordinate using the inverse transformation $r = r_0(e^x - 1)$. This results in a set of radial sample points $\\{r_j'\\}$ that are spaced more densely near the origin ($r=0$) and more sparsely at large $r$. The density of points $dN/dr$ is proportional to $(r_0+r)^{-1}$. A cubic spline, $S_B(r)$, is then constructed using the data pairs $(r_j', f(r_j'))$. This non-uniform distribution is intended to better capture the rapid variation of the potential near the origin.\n\nTo evaluate the accuracy of each scheme, we compute the maximum absolute error over a dense, uniform evaluation grid of $M=1000$ points $\\{r_i\\}$ in the interval $[0, r_{\\max}]$. The errors are defined as:\n$$\nE_A = \\max_{i=1,\\dots,M} \\left| S_A(r_i) - f(r_i) \\right|\n$$\n$$\nE_B = \\max_{i=1,\\dots,M} \\left| S_B(r_i) - f(r_i) \\right|\n$$\nThe effect of the logarithmic mapping is then quantified by the error reduction factor, $R = E_A / E_B$. A value of $R > 1$ indicates that the logarithmic sampling grid provides a more accurate interpolation than the uniform grid for the same number of sample points.\n\nThe implementation will proceed by first defining a Python function for the potential $f(r)$ based on its parameters. For each test case, we will generate the two sets of sample points for Scheme A and Scheme B. Using the `scipy.interpolate.CubicSpline` class, we will construct the interpolants $S_A(r)$ and $S_B(r)$. Finally, we will evaluate these splines and the exact function on the dense grid, compute the maximum errors $E_A$ and $E_B$, and calculate their ratio $R$. This process is repeated for each parameter set provided in the test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Solves the interpolation problem for the given test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (general case)\n        {'Z': 20, 'Rc': 4.1, 'Rn': 4.5, 'a': 0.6, 'V0': 50, 'r0': 1.0, 'N': 50, 'rmax': 20.0},\n        # Test 2 (strong Coulomb, fewer samples)\n        {'Z': 82, 'Rc': 7.1, 'Rn': 7.0, 'a': 0.5, 'V0': 50, 'r0': 0.5, 'N': 30, 'rmax': 25.0},\n        # Test 3 (weak Coulomb, nuclear-dominated)\n        {'Z': 1, 'Rc': 1.0, 'Rn': 1.2, 'a': 0.5, 'V0': 50, 'r0': 1.0, 'N': 60, 'rmax': 15.0},\n        # Test 4 (large mapping scale, near-uniform sampling)\n        {'Z': 50, 'Rc': 5.6, 'Rn': 5.6, 'a': 0.6, 'V0': 50, 'r0': 10.0, 'N': 60, 'rmax': 20.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_one_case(case)\n        results.append(result)\n\n    # Format the final output string as per the problem specification.\n    # [[E_A1,E_B1,R1],[E_A2,E_B2,R2],...]\n    output_str_parts = []\n    for res in results:\n        # Format each number to avoid excessively long floating point representations\n        e_a_str = f\"{res[0]:.10g}\"\n        e_b_str = f\"{res[1]:.10g}\"\n        r_str = f\"{res[2]:.10g}\"\n        output_str_parts.append(f\"[{e_a_str},{e_b_str},{r_str}]\")\n    \n    final_output = f\"[{','.join(output_str_parts)}]\"\n    print(final_output)\n\ndef _potential_function(r, func_params):\n    \"\"\"\n    Calculates the total potential f(r) = V_C(r) + V_N(r).\n    \n    Args:\n        r (np.ndarray or float): Radial coordinate(s) in fm.\n        func_params (dict): Dictionary of potential parameters.\n    \n    Returns:\n        np.ndarray or float: Total potential in MeV.\n    \"\"\"\n    k_const = 1.439964  # MeV * fm\n    Z, Rc, Rn, a, V0 = func_params['Z'], func_params['Rc'], func_params['Rn'], func_params['a'], func_params['V0']\n    \n    k = k_const * Z\n    \n    r_arr = np.atleast_1d(r)\n    \n    # Coulomb potential V_C(r) for a uniformly charged sphere\n    # Using np.where for vectorized piecewise calculation.\n    # This is safe as r > Rc ensures r is not zero for the second part.\n    vc_inside = (k / (2.0 * Rc)) * (3.0 - (r_arr**2 / Rc**2))\n    vc_outside = k / r_arr\n    Vc = np.where(r_arr <= Rc, vc_inside, vc_outside)\n    \n    # Woods-Saxon nuclear potential V_N(r)\n    Vn = -V0 / (1.0 + np.exp((r_arr - Rn) / a))\n    \n    f_r = Vc + Vn\n    \n    return f_r[0] if isinstance(r, (int, float)) else f_r\n\ndef _solve_one_case(case_params):\n    \"\"\"\n    Performs the interpolation and error analysis for a single test case.\n    \"\"\"\n    N = case_params['N']\n    rmax = case_params['rmax']\n    r0 = case_params['r0']\n    M = 1000\n\n    func_params = {k: case_params[k] for k in ('Z', 'Rc', 'Rn', 'a', 'V0')}\n\n    # Dense evaluation grid for accurate error measurement\n    r_eval = np.linspace(0, rmax, M)\n    f_exact = _potential_function(r_eval, func_params)\n\n    # Scheme A: Cubic spline with uniform grid in r\n    r_samples_A = np.linspace(0, rmax, N)\n    y_samples_A = _potential_function(r_samples_A, func_params)\n    spline_A = CubicSpline(r_samples_A, y_samples_A)\n    f_spline_A = spline_A(r_eval)\n    E_A = np.max(np.abs(f_spline_A - f_exact))\n\n    # Scheme B: Cubic spline with logarithmic grid\n    x_max = np.log(1 + rmax / r0)\n    x_samples_B = np.linspace(0, x_max, N)\n    r_samples_B = r0 * (np.exp(x_samples_B) - 1)\n    \n    # CubicSpline needs strictly increasing points. Floating point arithmetic can\n    # occasionally create tiny non-monotonicities or duplicates, especially at r=0.\n    # A simple check and fix ensures robustness.\n    if r_samples_B[1] <= r_samples_B[0]:\n        r_samples_B[1] = r_samples_B[0] + np.finfo(float).eps\n    \n    y_samples_B = _potential_function(r_samples_B, func_params)\n    spline_B = CubicSpline(r_samples_B, y_samples_B)\n    f_spline_B = spline_B(r_eval)\n    E_B = np.max(np.abs(f_spline_B - f_exact))\n\n    # Error reduction factor\n    R = E_A / E_B if E_B != 0 else np.inf\n\n    return [E_A, E_B, R]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Physical laws often dictate that functions have a specific, non-analytic behavior at a certain point. A prime example is the Wigner threshold law, which governs how reaction cross sections and decay widths turn on from zero at a channel's energy threshold, often with a non-integer power law like $(E - E_{\\mathrm{th}})^{\\ell + 1/2}$. This practice () shows how to correctly interpolate such functions by factoring out the known non-analytic part—the penetrability—and applying the spline to the remaining, much smoother, \"reduced-width\" function, thereby embedding the correct physical scaling into the interpolant.",
            "id": "3566057",
            "problem": "You are tasked with designing and implementing a cubic-spline-based interpolant for energy-dependent partial decay widths in a nuclear reaction model that respects threshold behavior mandated by the Wigner threshold law. Consider a set of decay channels indexed by $c$, each characterized by an orbital angular momentum quantum number $\\ell_c$ and a channel threshold energy $E_{\\mathrm{th},c}$. For a neutral emitted particle and a short-range interaction, the Wigner threshold law asserts that near threshold the decay width scales with the penetrability as $\\Gamma_c(E) \\propto P_{\\ell_c}(E)$ with $P_{\\ell}(E) \\propto k^{2\\ell+1}$, where $k$ is the wave number. In units where $2\\mu/\\hbar^2 = 1$, one has $k = \\sqrt{E - E_{\\mathrm{th},c}}$ for $E \\ge E_{\\mathrm{th},c}$, and thus $P_{\\ell}(E) \\propto (E - E_{\\mathrm{th},c})^{\\ell + 1/2}$. In this problem, adopt the concrete neutral-particle penetrability model\n$$\nP_{\\ell}(E;E_{\\mathrm{th}}) = \\left[\\max\\left(E - E_{\\mathrm{th}},\\,0\\right)\\right]^{\\ell + \\tfrac{1}{2}},\n$$\nwith all energies expressed in $\\mathrm{MeV}$ and with the proportionality constant set to $1$.\n\nYour goal is to construct for each channel $c$ a cubic spline interpolant $S_c(E)$ for $\\Gamma_c(E)$ that enforces the correct low-energy scaling as follows:\n- For $E \\le E_{\\mathrm{th},c}$, set $S_c(E) = 0$ (closed channel).\n- For $E > E_{\\mathrm{th},c}$, require that the ratio $W_c(E) \\equiv S_c(E)/P_{\\ell_c}(E;E_{\\mathrm{th},c})$ is a natural cubic spline in $E$ on the interval $[E_{\\mathrm{th},c}+\\Delta,\\,E_{\\max,c}]$, where $\\Delta = 10^{-4}\\,\\mathrm{MeV}$, fitted to training data. Equivalently, construct a natural cubic spline for the reduced-width function $W_c(E)$ through the training ordinates $W_c(E_i) = \\Gamma_c(E_i)/P_{\\ell_c}(E_i;E_{\\mathrm{th},c})$ at the given knots $\\{E_i\\}$, then define $S_c(E) = P_{\\ell_c}(E;E_{\\mathrm{th},c})\\,W_c(E)$ for $E > E_{\\mathrm{th},c}$.\n\nTo make the task fully specified and testable, use the following synthetic but physically plausible ground-truth model for each channel $c$:\n- Let the true reduced-width function be\n$$\nH_c(E) = a_c + b_c\\,(E - E_{\\mathrm{th},c}) + c_c \\cos\\!\\big(d_c\\,(E - E_{\\mathrm{th},c})\\big),\n$$\nand define the true partial width as\n$$\n\\Gamma_c^{\\mathrm{true}}(E) = \n\\begin{cases}\n0, & E \\le E_{\\mathrm{th},c},\\\\\nP_{\\ell_c}(E;E_{\\mathrm{th},c})\\,H_c(E), & E > E_{\\mathrm{th},c}.\n\\end{cases}\n$$\n\nUse the following channel definitions and parameters (all energies in $\\mathrm{MeV}$, angles dimensionless, and with $E_{\\max,c}$ specifying the upper end of the training and evaluation interval):\n- Channel $c=1$: $\\ell_1 = 0$, $E_{\\mathrm{th},1} = 0.1\\,\\mathrm{MeV}$, $E_{\\max,1} = 3.0\\,\\mathrm{MeV}$, $a_1 = 0.3$, $b_1 = 0.2$, $c_1 = 0.05$, $d_1 = 3.0$.\n- Channel $c=2$: $\\ell_2 = 1$, $E_{\\mathrm{th},2} = 1.0\\,\\mathrm{MeV}$, $E_{\\max,2} = 5.0\\,\\mathrm{MeV}$, $a_2 = 0.1$, $b_2 = 0.05$, $c_2 = 0.02$, $d_2 = 5.0$.\n- Channel $c=3$: $\\ell_3 = 2$, $E_{\\mathrm{th},3} = 0.0\\,\\mathrm{MeV}$, $E_{\\max,3} = 4.0\\,\\mathrm{MeV}$, $a_3 = 0.5$, $b_3 = 0.0$, $c_3 = 0.1$, $d_3 = 2.0$.\n\nTraining data specification for all channels:\n- Use $N_c = 8$ training knots uniformly spaced in energy on $[E_{\\mathrm{th},c} + \\Delta,\\,E_{\\max,c}]$ with $\\Delta = 10^{-4}\\,\\mathrm{MeV}$. Denote these knots by $\\{E_{i,c}\\}_{i=1}^{N_c}$.\n- The training ordinates are $\\Gamma_c^{\\mathrm{true}}(E_{i,c})$ at these knots.\n\nProgram requirements:\n1. For each channel $c$, build the spline-constrained interpolant $S_c(E)$ as specified above by fitting a natural cubic spline to $W_c(E)$ through the training data points $\\{(E_{i,c},\\,\\Gamma_c^{\\mathrm{true}}(E_{i,c})/P_{\\ell_c}(E_{i,c};E_{\\mathrm{th},c}))\\}$.\n2. For each channel $c$, evaluate the interpolant and the ground truth on a dense test grid of $N_{\\mathrm{test}} = 200$ points uniformly spaced on $[E_{\\mathrm{th},c} + \\Delta,\\,E_{\\max,c}]$. Define the maximum relative error\n$$\n\\varepsilon_c = \\max_{E \\in \\mathrm{grid}} \\frac{\\left|S_c(E) - \\Gamma_c^{\\mathrm{true}}(E)\\right|}{\\max\\!\\left(\\Gamma_c^{\\mathrm{true}}(E),\\,\\epsilon\\right)},\n$$\nwith $\\epsilon = 10^{-14}$ to regularize near $E \\downarrow E_{\\mathrm{th},c}$.\n3. For each channel $c$, also evaluate the below-threshold value $B_c = S_c(E_{\\mathrm{th},c} - \\delta)$ with $\\delta = 10^{-6}\\,\\mathrm{MeV}$, which should be exactly $0$ by construction.\n4. Your program must output the six numbers $[\\varepsilon_1,\\,\\varepsilon_2,\\,\\varepsilon_3,\\,B_1,\\,B_2,\\,B_3]$ as a single line in the exact format described below.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[x_1,x_2,x_3,x_4,x_5,x_6]$.\n- Each numeric entry must be printed as a floating-point value rounded to $8$ decimal places.\n- Energies must be in $\\mathrm{MeV}$ wherever applicable, but the printed outputs are dimensionless for $\\varepsilon_c$ and in $\\mathrm{MeV}$ for $B_c$ (the latter are expected to be $0.00000000$ due to the construction).\n\nThe solution must be a complete, runnable program without reading any input, and it must implement the construction described above exactly. The internal definitions of the ground-truth functions $H_c(E)$ and $\\Gamma_c^{\\mathrm{true}}(E)$ must match the specifications given here. The final output must strictly follow the required single-line format.",
            "solution": "The problem requires the construction and validation of a cubic spline interpolant for nuclear partial decay widths, $\\Gamma_c(E)$, that correctly incorporates the physical behavior near the channel energy threshold, $E_{\\mathrm{th},c}$, as dictated by the Wigner threshold law.\n\nThe core principle of the specified method is to separate the function to be interpolated, $\\Gamma_c(E)$, into two factors: a part with known, non-analytic behavior near the threshold, and a residual part that is expected to be smooth and well-behaved. The Wigner threshold law for a neutral emitted particle with orbital angular momentum $\\ell_c$ states that the decay width is proportional to the a penetrability factor, $\\Gamma_c(E) \\propto P_{\\ell_c}(E)$. For the given model where $2\\mu/\\hbar^2=1$, this penetrability is $P_{\\ell_c}(E;E_{\\mathrm{th},c}) = (E - E_{\\mathrm{th},c})^{\\ell_c + 1/2}$ for $E > E_{\\mathrm{th},c}$. The problem defines a complete model for this factor:\n$$\nP_{\\ell}(E;E_{\\mathrm{th}}) = \\left[\\max\\left(E - E_{\\mathrm{th}},\\,0\\right)\\right]^{\\ell + \\tfrac{1}{2}}\n$$\nThis function captures the sharp turn-on at $E=E_{\\mathrm{th},c}$ and its derivative is singular at the threshold for $\\ell=0$. Direct spline interpolation of $\\Gamma_c(E)$ would be inaccurate due to this non-analytic behavior.\n\nThe strategy is to instead interpolate the \"reduced-width\" function, $W_c(E)$, defined by the ratio:\n$$\nW_c(E) \\equiv \\frac{\\Gamma_c(E)}{P_{\\ell_c}(E;E_{\\mathrm{th},c})}\n$$\nThis function $W_c(E)$ is expected to be much smoother than $\\Gamma_c(E)$ and thus more amenable to polynomial-based interpolation like cubic splines. We construct a natural cubic spline, which we denote as the interpolant for $W_c(E)$, through a set of training points. The final interpolant for the full decay width, $S_c(E)$, is then reconstructed by multiplying the spline interpolant of the reduced width by the known penetrability factor:\n$$\nS_c(E) = P_{\\ell_c}(E;E_{\\mathrm{th},c}) W_c(E) \\quad \\text{for } E > E_{\\mathrm{th},c}\n$$\nBy construction, for $E \\le E_{\\mathrm{th},c}$, we have $P_{\\ell_c}(E;E_{\\mathrm{th},c}) = 0$, so we define $S_c(E) = 0$, which correctly enforces the channel closure below threshold.\n\nThe full procedure for each channel $c$ is as follows:\n\n1.  **Define Ground-Truth Functions**: The problem provides a synthetic \"true\" model for the decay width, which is used to generate training data and to assess the accuracy of our interpolant. The true reduced-width function is given as:\n    $$\n    H_c(E) = a_c + b_c\\,(E - E_{\\mathrm{th},c}) + c_c \\cos\\!\\big(d_c\\,(E - E_{\\mathrm{th},c})\\big)\n    $$\n    The true partial width is then:\n    $$\n    \\Gamma_c^{\\mathrm{true}}(E) = \n    \\begin{cases}\n    0, & E \\le E_{\\mathrm{th},c}\\\\\n    P_{\\ell_c}(E;E_{\\mathrm{th},c})\\,H_c(E), & E > E_{\\mathrm{th},c}\n    \\end{cases}\n    $$\n    The parameters $\\{a_c, b_c, c_c, d_c, \\ell_c, E_{\\mathrm{th},c}, E_{\\max,c}\\}$ are provided for three distinct channels.\n\n2.  **Generate Training Data**: For each channel $c$, we generate $N_c = 8$ training knots, $\\{E_{i,c}\\}_{i=1}^{N_c}$, uniformly spaced in the energy interval $[E_{\\mathrm{th},c} + \\Delta, E_{\\max,c}]$, with $\\Delta = 10^{-4}\\,\\mathrm{MeV}$. The small offset $\\Delta$ is crucial to avoid the point $E=E_{\\mathrm{th},c}$ where the derivative of $P_{\\ell=0}(E)$ is infinite. The corresponding ordinates for the spline of the reduced width are:\n    $$\n    y_{i,c} = \\frac{\\Gamma_c^{\\mathrm{true}}(E_{i,c})}{P_{\\ell_c}(E_{i,c};E_{\\mathrm{th},c})} = \\frac{P_{\\ell_c}(E_{i,c};E_{\\mathrm{th},c}) H_c(E_{i,c})}{P_{\\ell_c}(E_{i,c};E_{\\mathrm{th},c})} = H_c(E_{i,c})\n    $$\n    Thus, we fit the spline to the points $\\{(E_{i,c}, H_c(E_{i,c}))\\}$.\n\n3.  **Construct Natural Cubic Spline**: Using the training points from the previous step, we construct a natural cubic spline interpolant for $W_c(E)$. A natural spline has the additional constraint that its second derivative is zero at the endpoints of the interval, which is a common choice when no other information about the function's behavior at the boundaries is available.\n\n4.  **Define the Full Interpolant $S_c(E)$**: The final interpolant for the decay width is given by:\n    $$\n    S_c(E) = \n    \\begin{cases}\n    0, & E \\le E_{\\mathrm{th},c}\\\\\n    P_{\\ell_c}(E;E_{\\mathrm{th},c})\\,W_c(E), & E > E_{\\mathrm{th},c}\n    \\end{cases}\n    $$\n    where $W_c(E)$ is the value of the natural cubic spline evaluated at energy $E$.\n\n5.  **Evaluate Performance**:\n    - The maximum relative error, $\\varepsilon_c$, is computed over a dense grid of $N_{\\mathrm{test}}=200$ points in $[E_{\\mathrm{th},c} + \\Delta, E_{\\max,c}]$. The error is defined as:\n      $$\n      \\varepsilon_c = \\max_{E \\in \\mathrm{grid}} \\frac{\\left|S_c(E) - \\Gamma_c^{\\mathrm{true}}(E)\\right|}{\\max\\!\\left(\\Gamma_c^{\\mathrm{true}}(E),\\,\\epsilon\\right)}\n      $$\n      where $\\epsilon = 10^{-14}$ is a regularization constant to prevent division by zero in regions where $\\Gamma_c^{\\mathrm{true}}(E)$ is very small.\n    - The below-threshold value, $B_c = S_c(E_{\\mathrm{th},c} - \\delta)$ for $\\delta = 10^{-6}\\,\\mathrm{MeV}$, is evaluated to confirm that the interpolation scheme correctly sets the width to zero for closed channels. By our construction of $S_c(E)$, this value must be exactly $0$.\n\nThe implementation will perform these steps for each of the three specified channels and report the resulting six values $[\\varepsilon_1, \\varepsilon_2, \\varepsilon_3, B_1, B_2, B_3]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Solves the problem of constructing and evaluating a cubic-spline-based\n    interpolant for nuclear decay widths that respects Wigner threshold laws.\n    \"\"\"\n    \n    # Define the problem parameters for each channel\n    channels = {\n        1: {'ell': 0, 'E_th': 0.1, 'E_max': 3.0, 'a': 0.3, 'b': 0.2, 'c': 0.05, 'd': 3.0},\n        2: {'ell': 1, 'E_th': 1.0, 'E_max': 5.0, 'a': 0.1, 'b': 0.05, 'c': 0.02, 'd': 5.0},\n        3: {'ell': 2, 'E_th': 0.0, 'E_max': 4.0, 'a': 0.5, 'b': 0.0, 'c': 0.1, 'd': 2.0}\n    }\n    \n    # Global constants from the problem statement\n    DELTA = 1e-4      # MeV, offset for training and evaluation domain\n    EPSILON = 1e-14   # Regularization for relative error\n    DELTA_B = 1e-6    # MeV, offset for below-threshold evaluation\n    N_TRAIN = 8       # Number of training knots\n    N_TEST = 200      # Number of test grid points\n\n    results = []\n\n    for c in sorted(channels.keys()):\n        p = channels[c]\n        ell, E_th, E_max = p['ell'], p['E_th'], p['E_max']\n        a, b, c_param, d = p['a'], p['b'], p['c'], p['d']\n\n        # 1. Define the model functions\n        \n        # Penetrability function P_l(E)\n        def P_ell(E, ell_val, E_th_val):\n            # Use np.maximum for element-wise operation\n            E_diff = np.maximum(E - E_th_val, 0)\n            return E_diff**(ell_val + 0.5)\n\n        # True reduced-width function H_c(E)\n        def H_c(E, E_th_val, a_val, b_val, c_val, d_val):\n            return a_val + b_val * (E - E_th_val) + c_val * np.cos(d_val * (E - E_th_val))\n\n        # True partial width function Gamma_true(E)\n        def Gamma_true(E, ell_val, E_th_val, a_val, b_val, c_val, d_val):\n            E_above_thresh = E > E_th_val\n            width = np.zeros_like(E, dtype=float)\n            if np.any(E_above_thresh):\n                P_vals = P_ell(E[E_above_thresh], ell_val, E_th_val)\n                H_vals = H_c(E[E_above_thresh], E_th_val, a_val, b_val, c_val, d_val)\n                width[E_above_thresh] = P_vals * H_vals\n            return width\n\n        # 2. Generate Training Data\n        train_knots = np.linspace(E_th + DELTA, E_max, N_TRAIN)\n        \n        # The ordinates for the spline are the values of the reduced-width function H_c\n        train_ordinates_W = H_c(train_knots, E_th, a, b, c_param, d)\n\n        # 3. Construct Natural Cubic Spline for W_c(E)\n        W_c_spline = CubicSpline(train_knots, train_ordinates_W, bc_type='natural')\n        \n        # 4. Define the Full Interpolant S_c(E)\n        def S_c(E):\n            y = np.zeros_like(E, dtype=float)\n            # Find energies above threshold\n            mask_above = E > E_th\n            \n            if np.any(mask_above):\n                E_above = E[mask_above]\n                # Evaluate spline and penetrability for E > E_th\n                W_vals = W_c_spline(E_above)\n                P_vals = P_ell(E_above, ell, E_th)\n                y[mask_above] = P_vals * W_vals\n\n            return y\n\n        # 5. Evaluate Performance\n        \n        # a. Calculate maximum relative error epsilon_c\n        test_grid = np.linspace(E_th + DELTA, E_max, N_TEST)\n        \n        S_c_on_grid = S_c(test_grid)\n        Gamma_true_on_grid = Gamma_true(test_grid, ell, E_th, a, b, c_param, d)\n        \n        # To avoid division by zero or near-zero\n        denominator = np.maximum(Gamma_true_on_grid, EPSILON)\n        \n        relative_errors = np.abs(S_c_on_grid - Gamma_true_on_grid) / denominator\n        epsilon_c = np.max(relative_errors)\n        results.append(epsilon_c)\n        \n        # b. Calculate below-threshold value B_c\n        B_c = S_c(np.array([E_th - DELTA_B]))[0]\n        # This is handled as an append for the final list, but is a separate calculation conceptually.\n\n    # Calculate B values for all channels\n    B_values = []\n    for c in sorted(channels.keys()):\n        p = channels[c]\n        E_th = p['E_th']\n        # The function S_c as defined will return 0 for any E <= E_th.\n        # We can directly assign 0.0, as per the construction.\n        B_c = 0.0\n        B_values.append(B_c)\n        \n    final_results = results + B_values\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{x:.8f}' for x in final_results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Numerical methods must respect the fundamental symmetries of the physical system they aim to describe. In nuclear physics, observables for different quantum channels are often linked by linear relationships derived from principles like angular momentum coupling and the Pauli exclusion principle. This exercise () critically compares two interpolation schemes to show that a naive application of splines can violate these symmetries, leading to unphysical results, while a \"preserving\" scheme that interpolates the underlying components maintains the integrity of the physical model.",
            "id": "3566060",
            "problem": "Consider a simplified, physically consistent model of the nucleon-nucleon interaction in the relative coordinate, restricted to central and spin-exchange components. Let the two-body potential be written as $V(r) = V_{\\mathrm{c}}(r) + V_{\\sigma}(r)\\,\\boldsymbol{\\sigma}_1 \\cdot \\boldsymbol{\\sigma}_2$, where $V_{\\mathrm{c}}(r)$ is a central part and $V_{\\sigma}(r)$ multiplies the spin scalar product operator $\\boldsymbol{\\sigma}_1 \\cdot \\boldsymbol{\\sigma}_2$. For two spin-$\\tfrac{1}{2}$ particles, the operator $\\boldsymbol{\\sigma}_1 \\cdot \\boldsymbol{\\sigma}_2$ has eigenvalues $-3$ in the spin-singlet state $S=0$ and $+1$ in the spin-triplet state $S=1$. For identical nucleons, the Pauli exclusion principle imposes the antisymmetry selection rule that for orbital angular momentum $L=0$, one must have $S+T$ odd, where $T$ is the total isospin. Since $J=L+S$ for $L=0$, it follows that the only physically allowed channels are $(J=0,T=1)$ (spin singlet) and $(J=1,T=0)$ (spin triplet). Under these conditions, the coupled-channel effective radial interactions are $V_{J=0,T=1}(r) = V_{\\mathrm{c}}(r) - 3\\,V_{\\sigma}(r)$ and $V_{J=1,T=0}(r) = V_{\\mathrm{c}}(r) + V_{\\sigma}(r)$, and all other $(J,T)$ channels vanish identically due to antisymmetry.\n\nYou are given discrete samples of $V_{\\mathrm{c}}(r)$ and $V_{\\sigma}(r)$ on a finite grid in $r$ and must construct cubic Basis spline (B-spline) interpolants. The overarching numerical requirement is that the interpolation must preserve the linear angular-momentum coupling identities between $V_{\\mathrm{c}}(r)$, $V_{\\sigma}(r)$, and $V_{JT}(r)$, and enforce the antisymmetry selection rule in the $L=0$ sector. Two interpolation schemes should be compared:\n1. A \"preserving\" scheme that builds cubic B-spline interpolants $\\mathcal{S}[V_{\\mathrm{c}}](r)$ and $\\mathcal{S}[V_{\\sigma}](r)$ from their samples, and then defines $V_{J=0,T=1}^{\\mathrm{pres}}(r) = \\mathcal{S}[V_{\\mathrm{c}}](r) - 3\\,\\mathcal{S}[V_{\\sigma}](r)$ and $V_{J=1,T=0}^{\\mathrm{pres}}(r) = \\mathcal{S}[V_{\\mathrm{c}}](r) + \\mathcal{S}[V_{\\sigma}](r)$, with $V_{JT}^{\\mathrm{pres}}(r) = 0$ for forbidden channels $(J,T)\\in\\{(0,0),(1,1)\\}$.\n2. A \"naive\" scheme that constructs cubic B-spline interpolants directly for the coupled-channel samples $V_{J=0,T=1}(r)$ and $V_{J=1,T=0}(r)$, namely $\\mathcal{S}[V_{J=0,T=1}](r)$ and $\\mathcal{S}[V_{J=1,T=0}](r)$, and uses these for the allowed channels while failing to enforce the antisymmetry selection rule by assigning the same functional forms to the forbidden channels, i.e., $V_{J=0,T=0}^{\\mathrm{naive}}(r)=\\mathcal{S}[V_{J=0,T=1}](r)$ and $V_{J=1,T=1}^{\\mathrm{naive}}(r)=\\mathcal{S}[V_{J=1,T=0}](r)$.\n\nTo test the impact on a simple shell-model spectrum, approximate the two-body interaction energy in the relative $S$-wave using a normalized Harmonic Oscillator (HO) ground-state relative wavefunction. Let the HO length be $b$ and the normalized three-dimensional ground-state wavefunction be $\\psi_{0}(r) = \\left(\\pi^{-\\tfrac{3}{4}} b^{-\\tfrac{3}{2}}\\right)\\exp\\!\\left(-\\tfrac{r^{2}}{2 b^{2}}\\right)$, so that $|\\psi_{0}(r)|^{2} = \\left(\\pi^{-\\tfrac{3}{2}} b^{-3}\\right)\\exp\\!\\left(-\\tfrac{r^{2}}{b^{2}}\\right)$. The expectation value of the interaction in a given channel $(J,T)$ is then\n$$\nE_{JT} = \\int_{0}^{R_{\\max}} 4\\pi\\,r^{2}\\,|\\psi_{0}(r)|^{2}\\,V_{JT}(r)\\,\\mathrm{d}r,\n$$\nwhich should be expressed in mega-electronvolts (MeV). The naive and preserving schemes yield two sets of energies, which will differ when the angular-momentum coupling identities are not preserved by the interpolation.\n\nFor realism and numerical stability, take sampled potentials that are smooth and short-ranged:\n$$\nV_{\\mathrm{c}}(r) = V_{0}\\,\\frac{e^{-\\mu r}}{r + a},\\quad V_{\\sigma}(r) = V_{s}\\,r\\,e^{-\\mu_{s} r},\n$$\nwith $r$ in femtometers (fm), $V_{0}$ and $V_{s}$ in mega-electronvolts (MeV), and $\\mu$ and $\\mu_{s}$ in inverse femtometers ($\\mathrm{fm}^{-1}$). Use cubic B-splines for interpolation.\n\nYour program must implement both interpolation schemes, perform the HO expectation value integral numerically by a stable quadrature on a fine radial grid, and produce, for each test case, the following outputs:\n- The difference in the shell-model interaction energies between the preserving and naive schemes for the allowed channels, namely $\\Delta E_{J=0,T=1} = E_{J=0,T=1}^{\\mathrm{pres}} - E_{J=0,T=1}^{\\mathrm{naive}}$ and $\\Delta E_{J=1,T=0} = E_{J=1,T=0}^{\\mathrm{pres}} - E_{J=1,T=0}^{\\mathrm{naive}}$, each in MeV as floating-point numbers.\n- The root-mean-square deviation of the angular-momentum coupling identities when comparing the naive $V_{JT}$ spline to the linear combination of component splines, computed on a set of $200$ evaluation points across the sample domain, namely\n$$\n\\mathrm{RMS}_{J=0,T=1} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\left[\\mathcal{S}\\!\\left(V_{J=0,T=1}\\right)(r_{i}) - \\left(\\mathcal{S}\\!\\left(V_{\\mathrm{c}}\\right)(r_{i}) - 3\\,\\mathcal{S}\\!\\left(V_{\\sigma}\\right)(r_{i})\\right)\\right]^{2}},\n$$\nand\n$$\n\\mathrm{RMS}_{J=1,T=0} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\left[\\mathcal{S}\\!\\left(V_{J=1,T=0}\\right)(r_{i}) - \\left(\\mathcal{S}\\!\\left(V_{\\mathrm{c}}\\right)(r_{i}) + \\mathcal{S}\\!\\left(V_{\\sigma}\\right)(r_{i})\\right)\\right]^{2}},\n$$\nas floating-point numbers in MeV.\n- Two boolean flags indicating whether the antisymmetry rule is enforced in the $L=0$ sector, specifically whether $E_{J=0,T=0}^{\\mathrm{pres}}$ and $E_{J=1,T=1}^{\\mathrm{pres}}$ are numerically zero within a tolerance of $10^{-10}$ MeV, and whether $E_{J=0,T=0}^{\\mathrm{naive}}$ and $E_{J=1,T=1}^{\\mathrm{naive}}$ are numerically zero within the same tolerance.\n\nDesign and evaluate the following three test cases, which together test a general case, coarse sampling, and near-origin behavior:\n- Test case $1$: $V_{0}=-60.0$ MeV, $V_{s}=15.0$ MeV, $\\mu=1.5\\,\\mathrm{fm}^{-1}$, $\\mu_{s}=1.0\\,\\mathrm{fm}^{-1}$, $a=0.2$ fm, $r_{\\min}=10^{-3}$ fm, $r_{\\max}=8.0$ fm, $N_{\\mathrm{data}}=25$, $b=1.8$ fm, $R_{\\max}=8.0$ fm, and $N_{\\mathrm{int}}=4000$ integration points.\n- Test case $2$: $V_{0}=-45.0$ MeV, $V_{s}=18.0$ MeV, $\\mu=1.3\\,\\mathrm{fm}^{-1}$, $\\mu_{s}=0.8\\,\\mathrm{fm}^{-1}$, $a=0.3$ fm, $r_{\\min}=10^{-3}$ fm, $r_{\\max}=8.0$ fm, $N_{\\mathrm{data}}=8$ (coarse grid), $b=2.2$ fm, $R_{\\max}=8.0$ fm, and $N_{\\mathrm{int}}=4000$ integration points.\n- Test case $3$: $V_{0}=-75.0$ MeV, $V_{s}=10.0$ MeV, $\\mu=1.7\\,\\mathrm{fm}^{-1}$, $\\mu_{s}=1.2\\,\\mathrm{fm}^{-1}$, $a=0.05$ fm, $r_{\\min}=10^{-3}$ fm, $r_{\\max}=6.0$ fm, $N_{\\mathrm{data}}=30$ (fine grid near origin), $b=1.4$ fm, $R_{\\max}=6.0$ fm, and $N_{\\mathrm{int}}=3000$ integration points.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order for the three test cases: $[\\Delta E_{J=0,T=1}^{(1)},\\Delta E_{J=1,T=0}^{(1)},\\mathrm{RMS}_{J=0,T=1}^{(1)},\\mathrm{RMS}_{J=1,T=0}^{(1)},\\mathrm{AntiPres}^{(1)},\\mathrm{AntiNaive}^{(1)},\\Delta E_{J=0,T=1}^{(2)},\\Delta E_{J=1,T=0}^{(2)},\\mathrm{RMS}_{J=0,T=1}^{(2)},\\mathrm{RMS}_{J=1,T=0}^{(2)},\\mathrm{AntiPres}^{(2)},\\mathrm{AntiNaive}^{(2)},\\Delta E_{J=0,T=1}^{(3)},\\Delta E_{J=1,T=0}^{(3)},\\mathrm{RMS}_{J=0,T=1}^{(3)},\\mathrm{RMS}_{J=1,T=0}^{(3)},\\mathrm{AntiPres}^{(3)},\\mathrm{AntiNaive}^{(3)}]$, where each energy is in MeV (floating-point), each root-mean-square deviation is in MeV (floating-point), and the antisymmetry flags are boolean values.",
            "solution": "The user requests a comparison of two cubic B-spline interpolation schemes within the context of a simplified nucleon-nucleon interaction model. The central task is to evaluate the degree to which a \"naive\" interpolation scheme violates the linear relationships and physical symmetries that are preserved by construction in a \"preserving\" scheme. The comparison is quantified by computing differences in physical observables (interaction energies) and the root-mean-square deviation between the potential models.\n\n### Problem Formulation and Physical Principles\n\nThe nucleon-nucleon interaction potential is given in a simplified operator form for the relative coordinate $r$:\n$$V(r) = V_{\\mathrm{c}}(r) + V_{\\sigma}(r)\\,\\boldsymbol{\\sigma}_1 \\cdot \\boldsymbol{\\sigma}_2$$\nHere, $V_{\\mathrm{c}}(r)$ is the central potential and $V_{\\sigma}(r)$ is the spin-dependent part. The operator $\\boldsymbol{\\sigma}_1 \\cdot \\boldsymbol{\\sigma}_2$ acts on the spin states of the two-nucleon system. For two spin-$\\frac{1}{2}$ particles, it has distinct eigenvalues depending on the total spin $S$: $-3$ for the spin-singlet state ($S=0$) and $+1$ for the spin-triplet state ($S=1$).\n\nThe Pauli exclusion principle imposes strict constraints on the allowed quantum states for identical nucleons. For relative S-wave states (orbital angular momentum $L=0$), the sum of total spin $S$ and total isospin $T$ must be odd ($S+T$ odd). This selection rule permits only two channels for $L=0$:\n1.  Spin-singlet ($S=0$, total angular momentum $J=L+S=0$): requires $T=1$. The effective potential is $V_{J=0,T=1}(r) = V_{\\mathrm{c}}(r) - 3V_{\\sigma}(r)$.\n2.  Spin-triplet ($S=1$, total angular momentum $J=L+S=1$): requires $T=0$. The effective potential is $V_{J=1,T=0}(r) = V_{\\mathrm{c}}(r) + V_{\\sigma}(r)$.\n\nThe channels $(J=0, T=0)$ and $(J=1, T=1)$ are forbidden by the Pauli principle for $L=0$, meaning their interaction potentials are identically zero: $V_{J=0,T=0}(r)=0$ and $V_{J=1,T=1}(r)=0$.\n\n### Interpolation Schemes and Preservation of Linearity\n\nThe problem investigates the numerical consequences of interpolating discrete potential data.\nThe analytic forms for the potentials are given as:\n$$\nV_{\\mathrm{c}}(r) = V_{0}\\,\\frac{e^{-\\mu r}}{r + a},\\quad V_{\\sigma}(r) = V_{s}\\,r\\,e^{-\\mu_{s} r}\n$$\nThese potentials are sampled on a discrete radial grid $\\{r_i\\}$.\n\n1.  **\"Preserving\" Scheme:** This method respects the underlying linear structure of the model. First, cubic B-spline interpolants for the component potentials, $\\mathcal{S}[V_{\\mathrm{c}}](r)$ and $\\mathcal{S}[V_{\\sigma}](r)$, are constructed from their respective samples. The channel potentials are then defined as linear combinations of these splines:\n    $$V_{J=0,T=1}^{\\mathrm{pres}}(r) = \\mathcal{S}[V_{\\mathrm{c}}](r) - 3\\,\\mathcal{S}[V_{\\sigma}](r)$$\n    $$V_{J=1,T=0}^{\\mathrm{pres}}(r) = \\mathcal{S}[V_{\\mathrm{c}}](r) + \\mathcal{S}[V_{\\sigma}](r)$$\n    This scheme explicitly enforces the Pauli principle by setting the potentials for forbidden channels to zero: $V_{J=0,T=0}^{\\mathrm{pres}}(r)=0$ and $V_{J=1,T=1}^{\\mathrm{pres}}(r)=0$.\n\n2.  **\"Naive\" Scheme:** This method interpolates the final channel potentials directly. First, the samples for the allowed channel potentials, $V_{J=0,T=1}(r_i)$ and $V_{J=1,T=0}(r_i)$, are calculated. Then, separate cubic B-spline interpolants are constructed for each channel: $\\mathcal{S}[V_{J=0,T=1}](r)$ and $\\mathcal{S}[V_{J=1,T=0}](r)$.\n    This approach fails to preserve the linear relations because, in general, the spline operator $\\mathcal{S}$ does not commute with linear combinations when constructed from discrete data:\n    $$\\mathcal{S}[V_{\\mathrm{c}} - 3V_{\\sigma}] \\neq \\mathcal{S}[V_{\\mathrm{c}}] - 3\\mathcal{S}[V_{\\sigma}]$$\n    Furthermore, this scheme violates the antisymmetry rule by assigning the functional forms of the allowed channels to the forbidden ones: $V_{J=0,T=0}^{\\mathrm{naive}}(r)=\\mathcal{S}[V_{J=0,T=1}](r)$ and $V_{J=1,T=1}^{\\mathrm{naive}}(r)=\\mathcal{S}[V_{J=1,T=0}](r)$.\n\n### Calculation of Observables and Discrepancy Metrics\n\nTo assess the impact of the interpolation scheme, we calculate the interaction energy expectation value $E_{JT}$ for a relative S-wave state described by a normalized Harmonic Oscillator ground-state wavefunction $\\psi_0(r)$:\n$$E_{JT} = \\int_{0}^{R_{\\max}} 4\\pi\\,r^{2}\\,|\\psi_{0}(r)|^{2}\\,V_{JT}(r)\\,\\mathrm{d}r$$\nwhere $|\\psi_{0}(r)|^{2} = (\\pi^{-\\frac{3}{2}} b^{-3})\\exp(-\\frac{r^{2}}{b^{2}})$. The integral is computed numerically on a fine grid using Simpson's rule.\n\nThe following quantities are computed for each test case:\n-   **Energy Difference ($\\Delta E_{JT}$):** The difference $E_{JT}^{\\mathrm{pres}} - E_{JT}^{\\mathrm{naive}}$ for the two allowed channels. This measures the impact of the numerical inconsistency on a calculated physical observable.\n-   **Root-Mean-Square Deviation ($\\mathrm{RMS}_{JT}$):** The RMS difference between the potential functions generated by the two schemes over the sampling domain. This directly quantifies the failure of the naive scheme to preserve the linear coupling identities. For instance, for the $(J=0,T=1)$ channel:\n    $$\\mathrm{RMS}_{J=0,T=1} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\left[\\mathcal{S}[V_{J=0,T=1}](r_{i}) - \\left(\\mathcal{S}[V_{\\mathrm{c}}](r_{i}) - 3\\,\\mathcal{S}[V_{\\sigma}](r_{i})\\right)\\right]^{2}}$$\n    This is evaluated on a grid of $N=200$ points.\n-   **Antisymmetry Flags:** Two boolean flags check if the energies for the forbidden channels are numerically zero (within a tolerance of $10^{-10}\\,\\mathrm{MeV}$). $E_{JT}^{\\mathrm{pres}}$ for forbidden channels will be zero by construction. $E_{JT}^{\\mathrm{naive}}$ will be non-zero, demonstrating the violation of the Pauli principle.\n\n### Algorithmic Implementation\n\nThe solution is implemented as a Python program utilizing the `numpy` and `scipy` libraries. For each test case:\n1.  The analytic potentials $V_{\\mathrm{c}}(r)$ and $V_{\\sigma}(r)$ are defined.\n2.  Data points are generated for $V_{\\mathrm{c}}$, $V_{\\sigma}$, and the combined channel potentials $V_{J=0,T=1}$ and $V_{J=1,T=0}$ on a uniform radial grid of $N_{\\mathrm{data}}$ points from $r_{\\min}$ to $r_{\\max}$.\n3.  Cubic B-spline interpolants are created using `scipy.interpolate.make_interp_spline` with `k=3`.\n4.  The integrands for the energy expectation values are constructed using the appropriate interpolated potentials and the HO wavefunction weighting factor.\n5.  The energies $E_{JT}$ for all channels and both schemes are calculated via numerical quadrature using `scipy.integrate.simpson` over a dense grid of $N_{\\mathrm{int}}$ points.\n6.  The final output quantities—$\\Delta E_{JT}$, $\\mathrm{RMS}_{JT}$, and the antisymmetry flags—are computed from the integrated energies and spline evaluations. The results from all test cases are then consolidated and formatted into the specified output string.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import make_interp_spline\nfrom scipy.integrate import simpson\n\ndef solve():\n    \"\"\"\n    Solves the computational nuclear physics problem by comparing two B-spline\n    interpolation schemes for a simplified nucleon-nucleon interaction.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General case\n        {'V0': -60.0, 'Vs': 15.0, 'mu': 1.5, 'mus': 1.0, 'a': 0.2, 'r_min': 1e-3, 'r_max_data': 8.0, 'N_data': 25, 'b': 1.8, 'R_max_int': 8.0, 'N_int': 4000},\n        # Case 2: Coarse sampling grid\n        {'V0': -45.0, 'Vs': 18.0, 'mu': 1.3, 'mus': 0.8, 'a': 0.3, 'r_min': 1e-3, 'r_max_data': 8.0, 'N_data': 8, 'b': 2.2, 'R_max_int': 8.0, 'N_int': 4000},\n        # Case 3: Fine grid near origin, smaller range\n        {'V0': -75.0, 'Vs': 10.0, 'mu': 1.7, 'mus': 1.2, 'a': 0.05, 'r_min': 1e-3, 'r_max_data': 6.0, 'N_data': 30, 'b': 1.4, 'R_max_int': 6.0, 'N_int': 3000},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Extract parameters for the current test case\n        V0, Vs, mu, mus, a = case['V0'], case['Vs'], case['mu'], case['mus'], case['a']\n        r_min, r_max_data, N_data = case['r_min'], case['r_max_data'], case['N_data']\n        b, R_max_int, N_int = case['b'], case['R_max_int'], case['N_int']\n        \n        # 1. Define analytic potential functions\n        def Vc_func(r):\n            return V0 * np.exp(-mu * r) / (r + a)\n\n        def Vsigma_func(r):\n            return Vs * r * np.exp(-mus * r)\n\n        # 2. Generate sample data on a linear grid\n        r_data = np.linspace(r_min, r_max_data, N_data)\n        Vc_data = Vc_func(r_data)\n        Vsigma_data = Vsigma_func(r_data)\n        \n        # Data for coupled-channel potentials\n        V01_data = Vc_data - 3 * Vsigma_data\n        V10_data = Vc_data + Vsigma_data\n\n        # 3. Construct cubic B-spline interpolants (k=3)\n        k = 3\n        # Splines for the 'preserving' scheme components\n        spline_Vc = make_interp_spline(r_data, Vc_data, k=k)\n        spline_Vsigma = make_interp_spline(r_data, Vsigma_data, k=k)\n        \n        # Splines for the 'naive' scheme\n        spline_V01_naive = make_interp_spline(r_data, V01_data, k=k)\n        spline_V10_naive = make_interp_spline(r_data, V10_data, k=k)\n\n        # 4. Set up for numerical integration\n        r_int = np.linspace(0.0, R_max_int, N_int)\n        # Integrand weight: 4*pi*r^2 * |psi_0(r)|^2\n        integrand_weight = 4 * np.pi**(-0.5) * b**(-3) * r_int**2 * np.exp(-r_int**2 / b**2)\n\n        # 5. Evaluate potentials and calculate energies for both schemes\n        \n        # Preserving scheme\n        V01_pres_vals = spline_Vc(r_int) - 3 * spline_Vsigma(r_int)\n        V10_pres_vals = spline_Vc(r_int) + spline_Vsigma(r_int)\n        \n        E_01_pres = simpson(integrand_weight * V01_pres_vals, r_int)\n        E_10_pres = simpson(integrand_weight * V10_pres_vals, r_int)\n        E_00_pres = 0.0  # By definition for forbidden channel\n        E_11_pres = 0.0  # By definition for forbidden channel\n\n        # Naive scheme\n        V01_naive_vals = spline_V01_naive(r_int)\n        V10_naive_vals = spline_V10_naive(r_int)\n\n        E_01_naive = simpson(integrand_weight * V01_naive_vals, r_int)\n        E_10_naive = simpson(integrand_weight * V10_naive_vals, r_int)\n        # For forbidden channels, naive scheme uses the same functional forms\n        E_00_naive = E_01_naive\n        E_11_naive = E_10_naive\n\n        # 6. Calculate required output metrics\n        \n        # Energy differences\n        delta_E_01 = E_01_pres - E_01_naive\n        delta_E_10 = E_10_pres - E_10_naive\n\n        # RMS deviation calculation\n        N_eval = 200\n        r_eval = np.linspace(r_min, r_max_data, N_eval)\n\n        # For channel (J=0, T=1)\n        V_01_pres_eval = spline_Vc(r_eval) - 3 * spline_Vsigma(r_eval)\n        V_01_naive_eval = spline_V01_naive(r_eval)\n        rms_01 = np.sqrt(np.mean((V_01_naive_eval - V_01_pres_eval)**2))\n        \n        # For channel (J=1, T=0)\n        V_10_pres_eval = spline_Vc(r_eval) + spline_Vsigma(r_eval)\n        V_10_naive_eval = spline_V10_naive(r_eval)\n        rms_10 = np.sqrt(np.mean((V_10_naive_eval - V_10_pres_eval)**2))\n\n        # Antisymmetry flags\n        tolerance = 1e-10\n        anti_pres = (abs(E_00_pres) < tolerance) and (abs(E_11_pres) < tolerance)\n        anti_naive = (abs(E_00_naive) < tolerance) and (abs(E_11_naive) < tolerance)\n\n        # Append results for this case in the specified order\n        all_results.extend([delta_E_01, delta_E_10, rms_01, rms_10, anti_pres, anti_naive])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}