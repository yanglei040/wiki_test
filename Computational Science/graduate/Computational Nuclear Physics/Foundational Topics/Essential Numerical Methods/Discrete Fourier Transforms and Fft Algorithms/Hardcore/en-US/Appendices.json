{
    "hands_on_practices": [
        {
            "introduction": "In any scientific computing endeavor, verifying the correctness of your numerical tools is the first and most crucial step. A powerful method for validating a Fast Fourier Transform (FFT) implementation is to use a function whose transform is known analytically, allowing for a direct comparison of the numerical output against the exact result. This exercise  guides you through this fundamental practice using a Gaussian wave packet, whose Fourier transform is also a Gaussian, to quantify both the amplitude and phase accuracy of the discrete transform.",
            "id": "3556144",
            "problem": "Design and implement a fully self-contained numerical unit test that validates the correctness of a Fast Fourier Transform (FFT) implementation by comparing the discrete Fourier transform of a sampled Gaussian wave packet against its analytic continuous Fourier transform. The context is momentum-space transforms used in computational nuclear physics, where the spatial coordinate is measured in femtometers and the conjugate momentum (wave number) is measured in inverse femtometers. Your program must compute both amplitude and phase accuracy metrics and report them for a test suite of parameter sets.\n\nStart from the following fundamental base:\n- Define the continuous Fourier transform by the convention $F(k) = \\int_{-\\infty}^{\\infty} f(x)\\,e^{-i k x}\\,dx$ and its inverse $f(x) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} F(k)\\,e^{i k x}\\,dk$, where $k$ is the angular wave number with unit $\\mathrm{fm}^{-1}$ and $x$ is the position in $\\mathrm{fm}$, and angles are in radians.\n- The discrete approximation to the continuous transform on a uniform grid of $N$ points with spacing $dx$ is $F(k_m) \\approx dx \\sum_{n=0}^{N-1} f(x_n)\\,e^{-i k_m x_n}$, where $x_n = n\\,dx$ and $k_m = 2\\pi\\,m/(N\\,dx)$ for integer $m$ on the frequency grid generated by the discrete Fourier transform. This uses the numerical Fast Fourier Transform algorithm to evaluate the discrete sum efficiently.\n\nConsider the Gaussian wave packet\n$$\nf(x) = A \\exp\\!\\left(-\\frac{(x - x_0)^2}{2\\sigma^2}\\right)\\exp(i k_0 x),\n$$\nwith real parameters $A$ (dimensionless amplitude), $\\sigma$ (width in $\\mathrm{fm}$), $x_0$ (shift in $\\mathrm{fm}$), and $k_0$ (carrier in $\\mathrm{fm}^{-1}$). Using the Gaussian integral $\\int_{-\\infty}^{\\infty} e^{-a y^2 + b y}\\,dy = \\sqrt{\\frac{\\pi}{a}}\\,e^{b^2/(4a)}$ for $\\Re(a) > 0$, it follows that the exact continuous Fourier transform is another Gaussian in $k$ with a linear phase:\n$$\nF_{\\mathrm{analytic}}(k) = A \\sqrt{2\\pi}\\,\\sigma \\exp\\!\\left(-\\frac{\\sigma^2 (k - k_0)^2}{2}\\right)\\exp\\!\\left(i (k_0 - k) x_0\\right).\n$$\nThus, the amplitude envelope is $|F_{\\mathrm{analytic}}(k)| = A \\sqrt{2\\pi}\\,\\sigma \\exp\\!\\left(-\\frac{\\sigma^2 (k - k_0)^2}{2}\\right)$ and the phase is $\\arg F_{\\mathrm{analytic}}(k) = (k_0 - k)x_0$.\n\nYour task is to:\n1. Implement the discrete approximation $F_{\\mathrm{FFT}}(k_m) = dx \\sum_{n=0}^{N-1} f(x_n)\\,e^{-i k_m x_n}$ using a Fast Fourier Transform and the discrete frequency grid $k_m = 2\\pi\\,m/(N\\,dx)$ with $m$ as returned by a standard FFT frequency generator. Use $x_n = n\\,dx$ for $n = 0,1,\\dots,N-1$. Ensure that $dx$ is in $\\mathrm{fm}$, $k$ is in $\\mathrm{fm}^{-1}$, and angles are in radians.\n2. Compute the analytic transform $F_{\\mathrm{analytic}}(k_m)$ evaluated on the same discrete $k_m$ grid.\n3. Define an amplitude accuracy metric as the maximum relative error over the subset of $k_m$ where the analytic amplitude is not negligible:\n$$\n\\varepsilon_{\\mathrm{amp}} = \\max_{m \\in \\mathcal{M}} \\frac{\\left|\\left|F_{\\mathrm{FFT}}(k_m)\\right| - \\left|F_{\\mathrm{analytic}}(k_m)\\right|\\right|}{\\left|F_{\\mathrm{analytic}}(k_m)\\right|},\n$$\nwhere $\\mathcal{M} = \\{ m : |F_{\\mathrm{analytic}}(k_m)| \\ge \\eta \\,\\max_{m'} |F_{\\mathrm{analytic}}(k_{m'})| \\}$ and $\\eta$ is a small cutoff chosen to avoid division by numbers dominated by numerical noise. Use $\\eta = 10^{-6}$.\n4. Define a phase accuracy metric as the root-mean-square error of the phase difference between the numerical and analytic transforms over the same set $\\mathcal{M}$:\n$$\n\\varepsilon_{\\mathrm{phase}} = \\sqrt{\\frac{1}{|\\mathcal{M}|}\\sum_{m \\in \\mathcal{M}} \\Delta\\phi_m^2}, \\quad \\Delta\\phi_m = \\mathrm{unwrap}\\!\\left(\\arg\\left(\\frac{F_{\\mathrm{FFT}}(k_m)}{F_{\\mathrm{analytic}}(k_m)}\\right)\\right),\n$$\nwhere $\\mathrm{unwrap}$ denotes a continuous unwrapping in radians to remove $2\\pi$ jumps. Angles must be in radians.\n5. For each test case, compare $\\varepsilon_{\\mathrm{amp}}$ and $\\varepsilon_{\\mathrm{phase}}$ against the tolerances $\\tau_{\\mathrm{amp}} = 10^{-2}$ and $\\tau_{\\mathrm{phase}} = 10^{-2}$, respectively, and record boolean pass/fail values $p_{\\mathrm{amp}} = (\\varepsilon_{\\mathrm{amp}} \\le \\tau_{\\mathrm{amp}})$ and $p_{\\mathrm{phase}} = (\\varepsilon_{\\mathrm{phase}} \\le \\tau_{\\mathrm{phase}})$.\n\nImplement the program to compute these metrics for the following test suite of parameter sets, chosen to probe accuracy, resolution, and edge conditions relevant to computational nuclear physics transforms between coordinate and momentum space:\n- Test 1: $N = 2048$, $dx = 0.05\\,\\mathrm{fm}$, $\\sigma = 2.0\\,\\mathrm{fm}$, $A = 1.3$, $x_0 = 10.0\\,\\mathrm{fm}$, $k_0 = 0.6\\,\\mathrm{fm}^{-1}$.\n- Test 2: $N = 1024$, $dx = 0.10\\,\\mathrm{fm}$, $\\sigma = 0.5\\,\\mathrm{fm}$, $A = 0.9$, $x_0 = 30.0\\,\\mathrm{fm}$, $k_0 = 0.0\\,\\mathrm{fm}^{-1}$.\n- Test 3: $N = 1024$, $dx = 0.10\\,\\mathrm{fm}$, $\\sigma = 3.0\\,\\mathrm{fm}$, $A = 0.7$, $x_0 = 5.0\\,\\mathrm{fm}$, $k_0 = 0.8\\,\\pi/dx \\approx 25.132741\\,\\mathrm{fm}^{-1}$.\n- Test 4: $N = 2048$, $dx = 0.05\\,\\mathrm{fm}$, $\\sigma = 0.2\\,\\mathrm{fm}$, $A = 1.0$, $x_0 = 2.0\\,\\mathrm{fm}$, $k_0 = 1.5\\,\\mathrm{fm}^{-1}$.\n\nAngle units must be radians throughout. All computations must be carried out in double precision.\n\nFinal output format: Your program should produce a single line of output containing a Python-style list, where each test case contributes a sublist with four entries in the order $[\\varepsilon_{\\mathrm{amp}}, \\varepsilon_{\\mathrm{phase}}, p_{\\mathrm{amp}}, p_{\\mathrm{phase}}]$. For example, the overall output should look like $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$, where $a_j$ and $b_j$ are floats and $c_j$ and $d_j$ are booleans.",
            "solution": "The user-provided problem statement has been analyzed and validated as scientifically sound, well-posed, and objective. It constitutes a valid and meaningful exercise in computational physics. The task is to create a numerical unit test to validate a Fast Fourier Transform (FFT) implementation against an analytically known Fourier transform pair. The test case is a Gaussian wave packet, a standard and fundamental model in physics. The problem specifies all necessary physical and numerical parameters, definitions for error metrics, and test cases.\n\nThe methodological approach to solving this problem will be as follows:\n\nFirst, we establish the fundamental relationship between the continuous Fourier transform and its discrete approximation via the FFT algorithm. The continuous Fourier transform integral is approximated by a discrete sum over a finite grid. The problem states this approximation as $F(k_m) \\approx dx \\sum_{n=0}^{N-1} f(x_n)\\,e^{-i k_m x_n}$. The sum $\\sum_{n=0}^{N-1} f(x_n)\\,e^{-i 2\\pi m n / N}$ is the standard definition of the Discrete Fourier Transform (DFT), which is computed efficiently by the FFT algorithm. Given the specified relationship between the spatial grid $x_n = n\\,dx$ and the wave number grid $k_m = 2\\pi m / (N\\,dx)$, we can confirm that the discrete sum is equivalent to the definition of the DFT. Therefore, the numerical approximation of the transform is $F_{\\mathrm{FFT}}(k_m) = dx \\cdot \\mathrm{FFT}[f(x_n)]_m$.\n\nThe core of the solution involves the following sequence of steps for each test case:\n\n1.  **Grid Generation**: A uniform spatial grid $x_n = n \\cdot dx$ for $n = 0, \\ldots, N-1$ will be created. The corresponding angular wave number grid $k_m$ will be generated using the `numpy.fft.fftfreq` function, scaled by $2\\pi$ to convert from frequency (cycles per unit distance) to angular wave number (radians per unit distance). All calculations will use double-precision floating-point numbers (`np.float64` and `np.complex128`).\n\n2.  **Wave Packet Sampling**: The continuous Gaussian wave packet function $f(x) = A \\exp(-\\frac{(x - x_0)^2}{2\\sigma^2})\\exp(i k_0 x)$ will be sampled on the discrete spatial grid $x_n$ to produce the input array for the FFT.\n\n3.  **Numerical Transform (FFT)**: The FFT of the sampled wave packet will be computed using `numpy.fft.fft`. The result will be scaled by the spatial grid spacing $dx$ to obtain $F_{\\mathrm{FFT}}(k_m)$.\n\n4.  **Analytic Transform**: The exact analytical Fourier transform, $F_{\\mathrm{analytic}}(k) = A \\sqrt{2\\pi}\\,\\sigma \\exp(-\\frac{\\sigma^2 (k - k_0)^2}{2})\\exp(i (k_0 - k) x_0)$, will be evaluated on the discrete wave number grid $k_m$.\n\n5.  **Frequency Ordering**: A critical step in the comparison, especially for the phase, is to ensure that the transforms are processed along a monotonically increasing frequency axis. The standard output of an FFT algorithm orders frequencies from zero up to the positive Nyquist frequency, followed by negative frequencies. This non-monotonic ordering can cause issues with phase unwrapping. To rectify this, both the wave number grid $k_m$ and the numerical transform $F_{\\mathrm{FFT}}(k_m)$ will be rearranged using `numpy.fft.fftshift`. This function centers the zero-frequency component, resulting in a monotonically ordered grid from negative to positive wave numbers. The analytical transform will be computed directly on this shifted, monotonic grid.\n\n6.  **Error Metric Calculation**:\n    a.  A boolean mask, corresponding to the set $\\mathcal{M}$, will be created. This mask identifies the wave numbers $k_m$ where the analytic transform's amplitude is significant, defined as being greater than or equal to a fraction $\\eta=10^{-6}$ of the maximum analytic amplitude. This prevents numerical instabilities from division by zero or near-zero values.\n    b.  The amplitude accuracy metric, $\\varepsilon_{\\mathrm{amp}}$, will be computed as the maximum relative error between the amplitudes of the numerical and analytical transforms over the domain defined by the mask $\\mathcal{M}$.\n    c.  The phase accuracy metric, $\\varepsilon_{\\mathrm{phase}}$, will be calculated. The phase difference is computed from the argument of the complex ratio $F_{\\mathrm{FFT}}(k_m) / F_{\\mathrm{analytic}}(k_m)$ for points within $\\mathcal{M}$. The `numpy.unwrap` function is then applied to this sequence of phase differences to correct for $2\\pi$ discontinuities, yielding $\\Delta\\phi_m$. Finally, the root-mean-square (RMS) of these unwrapped phase differences is calculated to obtain $\\varepsilon_{\\mathrm{phase}}$.\n\n7.  **Validation**: The computed error metrics, $\\varepsilon_{\\mathrm{amp}}$ and $\\varepsilon_{\\mathrm{phase}}$, will be compared against their respective tolerances, $\\tau_{\\mathrm{amp}} = 10^{-2}$ and $\\tau_{\\mathrm{phase}} = 10^{-2}$. The results will determine the boolean pass/fail flags, $p_{\\mathrm{amp}}$ and $p_{\\mathrm{phase}}$.\n\nThis procedure will be executed for each of the four parameter sets provided in the problem statement. The results, comprising the two error metrics and two boolean flags for each test, will be collected and formatted into the specified output string, which represents a Python list of lists.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the FFT validation test suite and print results.\n    \"\"\"\n\n    def run_fft_validation_test(N, dx, sigma, A, x_0, k_0, eta, tau_amp, tau_phase):\n        \"\"\"\n        Performs a single validation test for the FFT against the analytic\n        Fourier transform of a Gaussian wave packet.\n\n        Args:\n            N (int): Number of sample points.\n            dx (float): Spatial grid spacing in fm.\n            sigma (float): Width of the Gaussian wave packet in fm.\n            A (float): Dimensionless amplitude of the wave packet.\n            x_0 (float): Center of the wave packet in fm.\n            k_0 (float): Carrier wave number in fm^-1.\n            eta (float): Cutoff for significant amplitude region.\n            tau_amp (float): Tolerance for amplitude error.\n            tau_phase (float): Tolerance for phase error.\n\n        Returns:\n            list: A list containing [eps_amp, eps_phase, p_amp, p_phase].\n        \"\"\"\n        # 1. Define Grids\n        # Spatial grid\n        x_n = np.arange(N, dtype=np.float64) * dx\n        # Angular wave number grid\n        k_m = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n        # 2. Sample the Gaussian wave packet in position space\n        f_x = A * np.exp(-(x_n - x_0)**2 / (2 * sigma**2)) * np.exp(1j * k_0 * x_n)\n        f_x = f_x.astype(np.complex128)\n\n        # 3. Compute the numerical transform using FFT\n        # The factor dx scales the DFT sum to approximate the continuous integral\n        F_fft = dx * np.fft.fft(f_x)\n\n        # 4. Shift grids for monotonic frequency axis for correct phase unwrapping\n        k_m_shifted = np.fft.fftshift(k_m)\n        F_fft_shifted = np.fft.fftshift(F_fft)\n\n        # 5. Compute the analytic transform on the shifted (monotonic) k-grid\n        F_analytic_shifted = (A * np.sqrt(2 * np.pi) * sigma *\n                              np.exp(-sigma**2 * (k_m_shifted - k_0)**2 / 2) *\n                              np.exp(1j * (k_0 - k_m_shifted) * x_0))\n        F_analytic_shifted = F_analytic_shifted.astype(np.complex128)\n\n        # 6. Define the region M where the analytic amplitude is significant\n        amp_analytic = np.abs(F_analytic_shifted)\n        amp_max = np.max(amp_analytic)\n        mask = amp_analytic = eta * amp_max\n\n        # Ensure mask is not empty to avoid errors in max/mean\n        if not np.any(mask):\n            eps_amp = np.inf\n            eps_phase = np.inf\n        else:\n            # 7. Compute amplitude accuracy metric (eps_amp)\n            amp_fft_shifted = np.abs(F_fft_shifted)\n            # We only evaluate the error where amplitude is significant\n            rel_err_amp_masked = (np.abs(amp_fft_shifted[mask] - amp_analytic[mask]) / \n                                  amp_analytic[mask])\n            eps_amp = np.max(rel_err_amp_masked)\n\n            # 8. Compute phase accuracy metric (eps_phase)\n            # Phase difference is taken from the argument of the ratio\n            ratio_masked = F_fft_shifted[mask] / F_analytic_shifted[mask]\n            \n            # Unwrap the phase difference to handle 2*pi jumps\n            phase_diff_raw = np.angle(ratio_masked)\n            phase_diff_unwrapped = np.unwrap(phase_diff_raw)\n            \n            # RMS of the unwrapped phase difference\n            eps_phase = np.sqrt(np.mean(phase_diff_unwrapped**2))\n\n        # 9. Compare against tolerances to get pass/fail booleans\n        p_amp = bool(eps_amp = tau_amp)\n        p_phase = bool(eps_phase = tau_phase)\n\n        return [eps_amp, eps_phase, p_amp, p_phase]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1\n        {'N': 2048, 'dx': 0.05, 'sigma': 2.0, 'A': 1.3, 'x_0': 10.0, 'k_0': 0.6},\n        # Test 2\n        {'N': 1024, 'dx': 0.10, 'sigma': 0.5, 'A': 0.9, 'x_0': 30.0, 'k_0': 0.0},\n        # Test 3\n        {'N': 1024, 'dx': 0.10, 'sigma': 3.0, 'A': 0.7, 'x_0': 5.0, 'k_0': 0.8 * np.pi / 0.10},\n        # Test 4\n        {'N': 2048, 'dx': 0.05, 'sigma': 0.2, 'A': 1.0, 'x_0': 2.0, 'k_0': 1.5},\n    ]\n\n    # Constants for metric calculation\n    eta = 1e-6\n    tau_amp = 1e-2\n    tau_phase = 1e-2\n\n    results = []\n    for case_params in test_cases:\n        result = run_fft_validation_test(\n            N=case_params['N'],\n            dx=case_params['dx'],\n            sigma=case_params['sigma'],\n            A=case_params['A'],\n            x_0=case_params['x_0'],\n            k_0=case_params['k_0'],\n            eta=eta,\n            tau_amp=tau_amp,\n            tau_phase=tau_phase\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format [[a,b,c,d],[e,f,g,h]] requires generating string representations\n    # of the inner lists and joining them. str() of a list includes spaces,\n    # so they are removed to match the implied format.\n    sublist_strs = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(sublist_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having validated our FFT implementation, we now turn to a common application: extracting precise spectral information from a finite data sample. The Discrete Fourier Transform (DFT) of a finite signal suffers from inherent artifacts, such as spectral leakage and the picket-fence effect, which can obscure the true frequency content. This practice  explores two essential signal processing techniques—windowing and zero-padding—to demonstrate how they mitigate these issues and enable more accurate frequency estimation for signals resembling physical resonances.",
            "id": "3556277",
            "problem": "You are given a synthetic detector signal model relevant to computational nuclear physics, where a narrowband oscillation in the reactor core (for example, flow-induced mechanical vibration manifesting in neutron noise) is modeled as a Gaussian-modulated cosine. The continuous Fourier transform of this signal is analytic and has a well-defined peak at the carrier frequency. Your task is to implement Discrete Fourier Transform (DFT) based estimators and compare peak localization error with and without zero-padding and with and without windowing, using an identical set of time-domain samples for each case.\n\nStart from the following bases:\n- The definition of sampling and the Discrete Fourier Transform (DFT): given a sampling frequency $F_s$, a sequence $x[n]$ of length $N$, and the time step $\\Delta t = 1/F_s$, the DFT samples the Discrete-Time Fourier Transform (DTFT) at frequencies $f_k = k \\Delta f$ where $\\Delta f = F_s/N$ and $k \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$ for the one-sided spectrum of a real-valued signal.\n- The Fast Fourier Transform (FFT) is an algorithm to compute the DFT efficiently without altering the DFT definition.\n- Windowing in time corresponds to multiplication by a deterministic sequence $w[n]$, which in frequency acts as a convolution with the window’s spectrum. Zero-padding increases the density of DFT sample points in frequency without changing the underlying band-limited information.\n\nSignal model and analytic spectrum:\n- Let the continuous-time signal be $x(t) = \\exp\\!\\left(-\\dfrac{t^2}{2\\sigma^2}\\right)\\cos\\!\\left(2\\pi f_0 t\\right)$. The continuous Fourier transform magnitude is a sum of two Gaussian lobes centered at $f = \\pm f_0$, each having peak exactly at $f_0$. This provides a ground truth for peak localization at the carrier frequency $f_0$.\n\nComputational experiment:\n- For each test case, sample $x(t)$ uniformly to form $x[n] = x(t_n)$ with $t_n = \\dfrac{n - (N-1)/2}{F_s}$ for $n \\in \\{0,1,\\dots,N-1\\}$ so the Gaussian envelope is centered in the sample.\n- Compute four peak frequency estimates from the magnitude of the one-sided DFT (via a Fast Fourier Transform algorithm):\n  1. Rectangular window with no zero-padding. Use $w_{\\mathrm{rect}}[n] = 1$ for all $n$ and compute the DFT of length $N$.\n  2. Rectangular window with zero-padding by an integer factor $P$. Pad the windowed sequence with zeros to length $N_{\\mathrm{pad}} = P N$ before computing the DFT.\n  3. Hann window (also known as Hanning) with no zero-padding. Use $w_{\\mathrm{Hann}}[n] = \\dfrac{1}{2}\\left(1 - \\cos\\left(\\dfrac{2\\pi n}{N-1}\\right)\\right)$ for $n \\in \\{0,\\dots,N-1\\}$ and compute the DFT of length $N$.\n  4. Hann window with zero-padding by factor $P$ to length $N_{\\mathrm{pad}} = P N$.\n\n- In all four cases, estimate the peak frequency by selecting the frequency $f_k$ corresponding to the maximum magnitude of the one-sided spectrum. The reference (true) peak location is $f_0$ from the analytic spectrum.\n- For each case, report the absolute localization error $|f_{\\mathrm{est}} - f_0|$ in Hertz, as a floating-point number.\n\nTest suite:\n- Use $N = 1024$ samples and $F_s = 2048\\,\\mathrm{Hz}$ for all tests.\n- Use zero-padding factor $P = 8$ where required.\n- Consider the following 4 test cases, each specified by $(N, F_s, \\sigma, f_0)$ in International System of Units (SI):\n  - Case 1: $(N, F_s, \\sigma, f_0) = (1024, 2048\\,\\mathrm{Hz}, 0.05\\,\\mathrm{s}, 128.0\\,\\mathrm{Hz})$.\n  - Case 2: $(N, F_s, \\sigma, f_0) = (1024, 2048\\,\\mathrm{Hz}, 0.05\\,\\mathrm{s}, 129.0\\,\\mathrm{Hz})$.\n  - Case 3: $(N, F_s, \\sigma, f_0) = (1024, 2048\\,\\mathrm{Hz}, 0.15\\,\\mathrm{s}, 4.0\\,\\mathrm{Hz})$.\n  - Case 4: $(N, F_s, \\sigma, f_0) = (1024, 2048\\,\\mathrm{Hz}, 0.03\\,\\mathrm{s}, 511.0\\,\\mathrm{Hz})$.\n\nYour program must:\n- Implement the sampling as specified and compute the four frequency estimates for each test case using the magnitude of the one-sided DFT.\n- Compute the absolute error $|f_{\\mathrm{est}} - f_0|$ in $\\mathrm{Hz}$ for each of the four methods per test case.\n- Produce a single line of output containing the errors for all test cases aggregated in order, as a comma-separated list enclosed in square brackets, in the order:\n  $[\\text{Case 1 Rect-NoPad}, \\text{Case 1 Rect-Pad}, \\text{Case 1 Hann-NoPad}, \\text{Case 1 Hann-Pad}, \\text{Case 2 Rect-NoPad}, \\dots, \\text{Case 4 Hann-Pad}]$.\nAll reported errors must be in $\\mathrm{Hz}$, expressed as floating-point numbers without a percentage sign.",
            "solution": "The problem requires an analysis of frequency estimation accuracy using the Discrete Fourier Transform (DFT) under different signal processing conditions. The core of the task is to quantify the error in locating the peak frequency of a known synthetic signal, a Gaussian-modulated cosine, when applying windowing and zero-padding.\n\nThe continuous-time signal is defined as $x(t) = \\exp\\!\\left(-\\frac{t^2}{2\\sigma^2}\\right)\\cos(2\\pi f_0 t)$. This represents a transient oscillation with a carrier frequency of $f_0$ and a Gaussian envelope with a characteristic width determined by $\\sigma$. The analytic Fourier transform of this signal has its magnitude peak precisely at the carrier frequency $f_0$, which serves as our ground truth.\n\n**1. Signal Discretization**\n\nTo perform a DFT, the continuous signal $x(t)$ must be sampled. The problem specifies a sampling frequency $F_s$ and a total of $N$ samples. The time instances for sampling are given by $t_n = \\frac{n - (N-1)/2}{F_s}$ for $n \\in \\{0, 1, \\dots, N-1\\}$. This choice of $t_n$ centers the time window $[t_0, t_{N-1}]$ symmetrically around $t=0$, ensuring the peak of the Gaussian envelope $\\exp(-t^2/(2\\sigma^2))$ is at the center of the sampled data record, $x[n] = x(t_n)$. This minimizes truncation effects at the edges of the sampling window.\n\n**2. The Discrete Fourier Transform and Peak Estimation**\n\nThe DFT of a sequence $x[n]$ of length $L$ is given by $X[k] = \\sum_{n=0}^{L-1} x[n] \\exp(-j2\\pi kn/L)$. The DFT provides samples of the signal's spectrum at discrete frequencies $f_k = k \\cdot \\frac{F_s}{L} = k \\cdot \\Delta f$, where $\\Delta f$ is the frequency resolution, or bin spacing. For a real-valued input signal, we analyze the one-sided spectrum for $k \\in \\{0, 1, \\dots, \\lfloor L/2 \\rfloor\\}$.\n\nThe peak frequency $f_{\\mathrm{est}}$ is estimated by finding the index $k_{\\mathrm{max}}$ that maximizes the DFT magnitude $|X[k]|$, and then setting $f_{\\mathrm{est}} = f_{k_{\\mathrm{max}}} = k_{\\mathrm{max}} \\cdot \\Delta f$. The accuracy of this estimation is subject to several effects, which this problem explores.\n\n**3. Analysis Techniques and Their Effects**\n\n**a) The Picket-Fence Effect and the Rectangular Window**\nThe DFT samples the continuous spectrum of the finite-length discrete signal at intervals of $\\Delta f$. If the true peak frequency $f_0$ does not happen to be an exact multiple of $\\Delta f$, the DFT bins will \"miss\" the true peak. This is known as the *picket-fence effect* or *scalloping loss*. The estimated peak will be the frequency of the nearest DFT bin with the highest energy, leading to an inherent localization error.\n\nSampling a finite duration of a signal is equivalent to multiplying the infinite signal by a rectangular window function, $w_{\\mathrm{rect}}[n] = 1$ over the interval and $0$ otherwise. The Fourier transform of a rectangular window is a `sinc` function ($\\sin(\\pi f)/(\\pi f)$). In the frequency domain, the signal's true spectrum is convolved with this `sinc` function. The `sinc` has a narrow main lobe, which is good for resolving closely spaced frequencies, but it also has high sidelobes. These sidelobes cause *spectral leakage*, where energy from a strong frequency component \"leaks\" into other frequency bins, potentially obscuring weaker signals or biasing peak locations.\n\n**b) The Hann Window**\nTo mitigate spectral leakage, tapering window functions are used. The Hann window, $w_{\\mathrm{Hann}}[n] = \\frac{1}{2}(1 - \\cos(\\frac{2\\pi n}{N-1}))$, smoothly tapers the signal to zero at the beginning and end of the sampling interval. This operation corresponds to convolution in the frequency domain with the Hann window's spectrum. The Hann spectrum has a main lobe that is approximately twice as wide as the rectangular window's main lobe (poorer frequency resolution), but its sidelobes are drastically lower. This reduction in spectral leakage generally leads to a more accurate amplitude estimation and can improve frequency estimation when the underlying spectrum is smooth or when there are interfering signals.\n\n**c) Zero-Padding**\nZero-padding consists of appending a large number of zeros to the (windowed) time-domain signal before computing the DFT. If we pad a signal of length $N$ to a new length $N_{\\mathrm{pad}} = P \\cdot N$, the resulting DFT will have a finer frequency resolution of $\\Delta f' = F_s / N_{\\mathrm{pad}} = \\Delta f / P$. This does *not* improve the fundamental spectral resolution (the ability to distinguish two closely spaced frequencies), which is determined by the original signal duration $N/F_s$ and the window function. Instead, zero-padding provides a densely interpolated version of the underlying Discrete-Time Fourier Transform (DTFT). This interpolation can reveal the shape of the spectral peaks more clearly and allow for a more accurate estimation of the true peak's location, especially when it falls between the original, coarse DFT bins.\n\n**4. Computational Procedure**\nFor each test case defined by $(\\sigma, f_0)$:\n1.  Generate the $N$-point time vector $t_n$ and the corresponding signal $x[n]$.\n2.  Define the Hann window $w_{\\mathrm{Hann}}[n]$.\n3.  Calculate four DFTs using a Fast Fourier Transform (FFT) algorithm:\n    -   Rectangular, no pad: FFT of $x[n]$ with length $N$.\n    -   Rectangular, padded: FFT of $x[n]$ with length $N_{\\mathrm{pad}} = P \\cdot N$.\n    -   Hann, no pad: FFT of $x[n] \\cdot w_{\\mathrm{Hann}}[n]$ with length $N$.\n    -   Hann, padded: FFT of $x[n] \\cdot w_{\\mathrm{Hann}}[n]$ with length $N_{\\mathrm{pad}}$.\n4.  For each DFT, construct the corresponding frequency axis.\n5.  Find the frequency bin corresponding to the maximum magnitude in the one-sided spectrum. This gives the estimated peak frequency $f_{\\mathrm{est}}$.\n6.  Calculate and store the absolute error $|f_{\\mathrm{est}} - f_0|$.\n\nThis procedure is systematically applied to all test cases to compare the performance of the four estimation strategies. The results will demonstrate how zero-padding is crucial for accurate peak localization when a peak falls between DFT bins and how windowing affects the outcome.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares peak frequency estimation errors for a synthetic signal\n    using the DFT with different windowing and zero-padding configurations.\n    \"\"\"\n    # Define global parameters from the problem statement.\n    N = 1024\n    Fs = 2048.0\n    P = 8\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (sigma in seconds, f0 in Hertz)\n    test_cases = [\n        (0.05, 128.0),\n        (0.05, 129.0),\n        (0.15, 4.0),\n        (0.03, 511.0),\n    ]\n\n    results = []\n\n    # Process each test case\n    for sigma, f0 in test_cases:\n        # Step 1: Generate the signal\n        # Create the time vector centered at t=0 as specified.\n        n_indices = np.arange(N)\n        t = (n_indices - (N - 1) / 2.0) / Fs\n        \n        # Create the Gaussian-modulated cosine signal.\n        signal = np.exp(-t**2 / (2 * sigma**2)) * np.cos(2 * np.pi * f0 * t)\n\n        # Step 2: Define the Hann window\n        hann_window = np.hanning(N)\n\n        # Apply the Hann window to the signal. The \"rectangular\" window is implicit.\n        signal_hann = signal * hann_window\n\n        # Step 3: Perform the four analyses for the current case\n        \n        # --- Analysis 1: Rectangular window, no zero-padding ---\n        dft_len_nopad = N\n        freqs_nopad = np.fft.rfftfreq(dft_len_nopad, d=1.0/Fs)\n        \n        fft_rect_nopad = np.fft.rfft(signal, n=dft_len_nopad)\n        peak_idx_rect_nopad = np.argmax(np.abs(fft_rect_nopad))\n        f_est_rect_nopad = freqs_nopad[peak_idx_rect_nopad]\n        error_rect_nopad = np.abs(f_est_rect_nopad - f0)\n        results.append(error_rect_nopad)\n\n        # --- Analysis 2: Rectangular window, with zero-padding ---\n        dft_len_pad = P * N\n        freqs_pad = np.fft.rfftfreq(dft_len_pad, d=1.0/Fs)\n\n        fft_rect_pad = np.fft.rfft(signal, n=dft_len_pad)\n        peak_idx_rect_pad = np.argmax(np.abs(fft_rect_pad))\n        f_est_rect_pad = freqs_pad[peak_idx_rect_pad]\n        error_rect_pad = np.abs(f_est_rect_pad - f0)\n        results.append(error_rect_pad)\n\n        # --- Analysis 3: Hann window, no zero-padding ---\n        fft_hann_nopad = np.fft.rfft(signal_hann, n=dft_len_nopad)\n        peak_idx_hann_nopad = np.argmax(np.abs(fft_hann_nopad))\n        f_est_hann_nopad = freqs_nopad[peak_idx_hann_nopad]\n        error_hann_nopad = np.abs(f_est_hann_nopad - f0)\n        results.append(error_hann_nopad)\n\n        # --- Analysis 4: Hann window, with zero-padding ---\n        fft_hann_pad = np.fft.rfft(signal_hann, n=dft_len_pad)\n        peak_idx_hann_pad = np.argmax(np.abs(fft_hann_pad))\n        f_est_hann_pad = freqs_pad[peak_idx_hann_pad]\n        error_hann_pad = np.abs(f_est_hann_pad - f0)\n        results.append(error_hann_pad)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "One of the most powerful applications of the FFT is in pseudo-spectral methods for solving nonlinear partial differential equations, which are central to modeling complex systems like atomic nuclei. While FFTs make computing spatial derivatives highly efficient, the evaluation of nonlinear terms in real space can introduce a pernicious numerical artifact known as aliasing, where unresolved high-frequency components contaminate the solution. This advanced exercise  delves into this critical issue within a model relevant to Time-Dependent Hartree-Fock (TDHF) theory, challenging you to implement diagnostics that detect aliasing and to apply a dealiasing scheme that ensures the physical fidelity of the simulation.",
            "id": "3556200",
            "problem": "Consider a one-dimensional periodic field with domain length $L$, discretized on a uniform grid of $N$ points with spacing $\\Delta x = L/N$. Let $x_j = j \\Delta x$ for $j \\in \\{0,1,\\dots,N-1\\}$. Define the discrete Fourier transform (DFT) of a grid function $u_j = u(x_j)$ by\n$$\n\\hat{u}_k = \\sum_{j=0}^{N-1} u_j \\exp\\left(-i \\frac{2\\pi}{N} j k\\right), \\quad k \\in \\{0,1,\\dots,N-1\\},\n$$\nwith inverse transform\n$$\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{u}_k \\exp\\left(+i \\frac{2\\pi}{N} j k\\right).\n$$\nLet the physical wavenumbers be $k_n = \\frac{2\\pi}{L} n$ with $n$ obtained via the usual frequency ordering of the Fast Fourier Transform (FFT). The Nyquist wavenumber is $k_{\\mathrm{N}} = \\pi/\\Delta x$. The convolution theorem states that multiplication in physical space corresponds to convolution in Fourier space. On a finite grid, the DFT implements circular convolution, so if nonlinear products generate Fourier support beyond $k_{\\mathrm{N}}$, those contributions alias back into the resolved band, corrupting the high-$k$ content.\n\nStarting from these definitions and the convolution theorem, derive the following dealiasing constraints for pseudo-spectral evaluation of polynomial nonlinearities:\n- For a quadratic nonlinearity (product of two fields each band-limited to $|k| \\leq k_c$), absence of aliasing requires $2 k_c \\leq k_{\\mathrm{N}}$. In a fixed $N$-mode representation, a sufficient in-place rule is to project all fields to a low-pass set with $|k| \\leq \\tfrac{2}{3} k_{\\mathrm{N}}$ before forming products involving two fields and to truncate back after evaluating the nonlinearity.\n- For a cubic nonlinearity (product of three fields each band-limited to $|k| \\leq k_c$), absence of aliasing requires $3 k_c \\leq k_{\\mathrm{N}}$. In a fixed $N$-mode representation, a sufficient in-place rule is to project all fields to a low-pass set with $|k| \\leq \\tfrac{1}{3} k_{\\mathrm{N}}$ before forming products involving three fields and to truncate back after evaluating the nonlinearity.\n\nWith these principles, implement a pseudo-spectral split-step time integrator for a simplified one-dimensional Time-Dependent Hartree-Fock (TDHF) analog, namely the cubic nonlinear Schrödinger-type equation (a standard surrogate for mean-field dynamics with a contact interaction):\n$$\ni \\frac{\\partial \\psi}{\\partial t} = -\\frac{1}{2} \\frac{\\partial^2 \\psi}{\\partial x^2} + g \\, |\\psi|^2 \\psi,\n$$\non a periodic domain of length $L = 2\\pi$. Use nondimensionalized units where Planck’s constant $\\hbar = 1$ and mass $m = 1$. The nonlinearity $g \\, |\\psi|^2 \\psi$ represents a local mean field proportional to the density $|\\psi|^2$, as in simplified treatments of nuclear mean-field dynamics in Time-Dependent Hartree-Fock (TDHF).\n\nAlgorithmic requirements:\n1. Use a Strang split-step scheme: apply a half-step linear (kinetic) propagator in Fourier space, a full-step nonlinear (potential) propagator in physical space, and a final half-step linear propagator in Fourier space. The linear propagator is given by multiplication with $\\exp\\left(-i \\frac{k^2}{2} \\Delta t\\right)$ in Fourier space for time step $\\Delta t$.\n2. To evaluate the nonlinear step at time $t$, compute the density $\\rho(x,t) = |\\psi(x,t)|^2$ from a possibly filtered field, and update $\\psi \\mapsto \\exp\\left(-i g \\rho \\Delta t\\right)\\psi$. To enforce a dealiasing strategy for the cubic product $|\\psi|^2 \\psi$, you may project the field used to form $\\rho$ to a low-pass band $|k| \\leq \\alpha k_{\\mathrm{N}}$, where $\\alpha \\in \\{1, \\tfrac{2}{3}, \\tfrac{1}{3}\\}$ corresponds to the chosen dealiasing strategy. Do not otherwise filter $\\psi$ after the nonlinear step; the point is to expose or suppress aliasing through the choice of $\\alpha$ when forming $\\rho$.\n3. Initialize the field at $t=0$ by a superposition of two plane waves:\n$$\n\\psi(x,0) = A \\left(e^{i k_1 x} + e^{i k_2 x}\\right),\n$$\nwith $k_1 = 8$, $k_2 = 12$, and choose $A$ such that $\\int_0^L |\\psi(x,0)|^2 \\, dx = 1$.\n4. Evolve to a final time $T$ with a fixed time step $\\Delta t$.\n\nDefine physically motivated diagnostics to detect spurious energy transfer to high-$k$ modes due to insufficient dealiasing:\n- Tail kinetic energy fraction growth. Let the kinetic energy spectrum be\n$$\n\\mathcal{K}(k) = \\frac{1}{2} k^2 |\\hat{\\psi}(k)|^2,\n$$\nwith the discrete total kinetic energy approximated by $K = \\frac{\\Delta x}{N} \\sum_k \\mathcal{K}(k)$ using the DFT convention above. Define the high-$k$ tail as modes with $|k| \\geq \\beta k_{\\mathrm{N}}$ with $\\beta = 0.85$. Compute the tail kinetic energy at $t=0$ and at $t=T$, denoted $K^{\\mathrm{tail}}_0$ and $K^{\\mathrm{tail}}_T$, respectively. Define the tail growth factor\n$$\nG = \\frac{K^{\\mathrm{tail}}_T}{K^{\\mathrm{tail}}_0 + \\varepsilon},\n$$\nwith a small regularization $\\varepsilon = 10^{-12}$ to avoid division by zero. A large value of $G$ indicates anomalous transfer to the highest modes.\n- Total energy drift. Define the discrete total energy\n$$\nE(t) = \\frac{\\Delta x}{N} \\sum_k \\frac{1}{2} k^2 |\\hat{\\psi}(k,t)|^2 + \\frac{g}{2} \\Delta x \\sum_j |\\psi(x_j,t)|^4.\n$$\nCompute the relative drift\n$$\nD = \\frac{|E(T) - E(0)|}{|E(0)|}.\n$$\nSignificant drift suggests numerical pathology that can stem from aliasing in nonlinear products.\n- High-$k$ spectral upturn. Let $P(k) = |\\hat{\\psi}(k)|^2$ and form a one-dimensional shell spectrum versus nonnegative $|k|$ by summing symmetric $\\pm k$ contributions. Fit a least-squares slope of $\\log P$ versus $k$ over the last $M$ nonzero shells nearest $k_{\\mathrm{N}}$ (take $M=8$). If this slope is positive, it indicates an unphysical upturn in the tail.\n\nConstruct a composite aliasing detector that returns true if at least two of the following three conditions hold: $G > G_{\\mathrm{thr}}$, $D > D_{\\mathrm{thr}}$, and the tail slope is positive. Use thresholds $G_{\\mathrm{thr}} = 50$ and $D_{\\mathrm{thr}} = 0.02$.\n\nUse the following fixed numerical parameters unless otherwise specified: $L = 2\\pi$, $N = 256$, $T = 0.8$, and $\\Delta t = 10^{-3}$. All quantities are nondimensional, so no physical unit conversion is required.\n\nImplement a program that executes the following test suite and prints the detection results:\n- Case 1 (happy path for detecting aliasing): $g = 20$, no dealiasing in the nonlinear step ($\\alpha = 1$). Expect aliasing to be detected.\n- Case 2 (boundary condition for quadratic but insufficient for cubic): $g = 20$, apply the $\\tfrac{2}{3}$-rule in forming $\\rho$ ($\\alpha = \\tfrac{2}{3}$). Expect aliasing to be detected because the nonlinearity is cubic.\n- Case 3 (sufficient for cubic): $g = 20$, apply the $\\tfrac{1}{3}$-rule in forming $\\rho$ ($\\alpha = \\tfrac{1}{3}$). Expect aliasing not to be detected.\n- Case 4 (edge case control): $g = 0$ (linear evolution), no dealiasing ($\\alpha = 1$). Expect aliasing not to be detected.\n\nYour program should produce a single line of output containing the results as a comma-separated list of Python boolean literals enclosed in square brackets, in the order of the cases above, for example, \"[True,False,True,False]\".",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the domain of computational physics and numerical analysis, specifically concerning the pseudo-spectral solution of nonlinear partial differential equations. The problem is well-posed, providing a defined equation, initial and boundary conditions, and a clear algorithmic and analytical task. The language is objective and the parameters are specific, allowing for a unique and verifiable solution. All definitions and constants are internally consistent and align with standard conventions in the field.\n\n### Derivation of Dealiasing Constraints\n\nThe core of the pseudo-spectral method is the use of the Fast Fourier Transform (FFT) to compute spatial derivatives. For a function $u(x)$, its spatial derivative $\\partial_x u(x)$ has a Fourier transform $\\widehat{\\partial_x u}(k) = ik\\hat{u}(k)$. This turns differential operators into simple multiplications in Fourier space. However, nonlinear terms, such as products of fields, are evaluated in physical space. The transform of a product $w(x) = u(x)v(x)$ is the convolution of their individual transforms:\n$$\n\\hat{w}_k = (\\hat{u} * \\hat{v})_k = \\sum_{p=0}^{N-1} \\hat{u}_p \\hat{v}_{k-p}\n$$\nOn a discrete grid of $N$ points, this convolution is circular, meaning the sum of indices is taken modulo $N$:\n$$\n\\hat{w}_k = \\sum_{p+q=k \\pmod N} \\hat{u}_p \\hat{v}_q\n$$\nIf the fields $u(x)$ and $v(x)$ are band-limited, meaning their transforms $\\hat{u}_p$ and $\\hat{v}_q$ are non-zero only for a range of wavenumbers (modes), say $|p| \\le k_c$ and $|q| \\le k_c$, then their true convolution product $\\hat{w}_k$ will be band-limited to $|k| \\le 2k_c$.\n\nHowever, on a discrete grid, any wavenumber $k'$ is indistinguishable from its aliases $k' + mN$ for any integer $m$. The range of uniquely represented wavenumbers is typically taken as $k \\in [ -k_{\\mathrm{N}}, k_{\\mathrm{N}} )$, where the Nyquist wavenumber is $k_{\\mathrm{N}} = \\pi/\\Delta x = N/2$ for the given domain length $L=2\\pi$. If the product generates wavenumbers with magnitude greater than $k_{\\mathrm{N}}$, these modes \"fold back\" into the resolved range $[ -k_{\\mathrm{N}}, k_{\\mathrm{N}} )$, contaminating the transform of the physical product. This phenomenon is called aliasing.\n\n1.  **Quadratic Nonlinearity**: For a product of two fields, $u(x)v(x)$, each band-limited to $|k| \\leq k_c$, the product $w=uv$ has a spectrum supported on $|k| \\leq 2k_c$. To prevent aliasing, this spectral support must lie entirely within the representable range of the grid, which requires $2k_c \\leq k_{\\mathrm{N}}$. This is the fundamental constraint. For an \"in-place\" calculation on a fixed grid of $N$ modes, a common sufficient strategy is to truncate the input fields before multiplication. If we zero out all modes in $\\hat{u}$ and $\\hat{v}$ for which $|k| > K_{trunc}$, the product's spectrum will extend to $2K_{trunc}$. Aliasing pollutes the computation if modes from the sum $\\sum_{p+q=k+mN, m \\neq 0} \\hat{u}_p \\hat{v}_q$ are non-zero for $|k| \\leq K_{trunc}$. A sufficient condition to prevent this is that the sum of the largest possible wavenumbers from the truncated inputs does not alias back into the truncated region. This requires $K_{trunc} + K_{trunc}  N - K_{trunc}$, which simplifies to $3K_{trunc}  N$. In terms of physical wavenumbers, this translates to $K_{trunc}  N/3 = (2/3)(N/2) = \\frac{2}{3}k_{\\mathrm{N}}$. Therefore, filtering the fields to $|k| \\leq \\frac{2}{3}k_{\\mathrm{N}}$ before forming a quadratic product is a sufficient dealiasing rule, commonly known as the Orszag 2/3-rule.\n\n2.  **Cubic Nonlinearity**: For a product of three fields, $u(x)v(x)w(x)$, each band-limited to $|k| \\leq k_c$, the product has a spectrum supported on $|k| \\leq 3k_c$. To prevent any aliasing, we require $3k_c \\leq k_{\\mathrm{N}}$. The corresponding in-place rule can be derived similarly. For a term like $|\\psi|^2\\psi$, one can view this as a sequential product. Let $\\psi$ be filtered to $|k|\\le K_{trunc}$. The density $\\rho = |\\psi|^2$ has spectral support up to $2K_{trunc}$. The final product $\\rho\\psi$ then has support up to $2K_{trunc} + K_{trunc} = 3K_{trunc}$. To prevent aliasing from contaminating the desired modes $|k|\\le K_{trunc}$, we require $3K_{trunc}  N - K_{trunc}$, which gives $4K_{trunc}  N$, or $K_{trunc}  N/4$. In terms of Nyquist wavenumber, $K_{trunc}  N/4 = (1/2)(N/2) = \\frac{1}{2}k_{\\mathrm{N}}$. The problem states a rule of $|k| \\leq \\frac{1}{3}k_{\\mathrm{N}}$. This corresponds to $K_{trunc} \\le N/6$. This is an even stricter, and thus sufficient, condition: if we truncate to $N/6$, the product support extends to $3(N/6)=N/2=k_{\\mathrm{N}}$, which fits perfectly within the non-aliased domain. Thus, the $\\frac{1}{3}$-rule is a valid, conservative dealiasing strategy for cubic nonlinearities.\n\n### Algorithmic Design for the Split-Step Integrator\n\nThe problem requires solving the cubic nonlinear Schrödinger equation using a Strang split-step method. The equation is split into a linear part, $i\\partial_t\\psi = \\hat{L}\\psi$, and a nonlinear part, $i\\partial_t\\psi = \\hat{V}\\psi$, where $\\hat{L} = -\\frac{1}{2}\\partial_{xx}$ and $\\hat{V} = g|\\psi|^2$.\n\nThe Strang splitting scheme for evolving the solution from time $t$ to $t+\\Delta t$ is a symmetric second-order method:\n$$\n\\psi(t+\\Delta t) = e^{-i\\hat{L}\\Delta t/2} e^{-i\\hat{V}\\Delta t} e^{-i\\hat{L}\\Delta t/2} \\psi(t)\n$$\n\nThe steps for a single time step are as follows:\n1.  **First Linear Half-Step**: The linear operator $\\hat{L}$ is diagonal in Fourier space. We transform $\\psi(x, t)$ to $\\hat{\\psi}(k, t)$ via FFT. Then we apply the propagator by multiplying with $e^{-i\\hat{L}(k)\\Delta t/2}$, where $\\hat{L}(k) = k^2/2$.\n    $$\n    \\hat{\\psi}'(k) = \\hat{\\psi}(k,t) \\exp\\left(-i \\frac{k^2}{2} \\frac{\\Delta t}{2}\\right)\n    $$\n2.  **Nonlinear Full-Step**: This step is performed in physical space. First, transform $\\hat{\\psi}'(k)$ back to $\\psi'(x)$ via inverse FFT. The nonlinear update is $\\psi''(x) = e^{-i\\hat{V}(x)\\Delta t} \\psi'(x)$. The potential $\\hat{V}(x) = g\\rho(x)$, where $\\rho(x) = |\\psi(x)|^2$ is the density. Crucially, this is where the dealiasing strategy is applied.\n    a. To compute a dealiased density, we start with the current state $\\psi'(x)$ (or $\\psi(x,t)$ for the first step).\n    b. Transform to Fourier space: $\\hat{\\psi}'(k) = \\mathcal{F}\\{\\psi'(x)\\}$.\n    c. Apply a low-pass filter based on the parameter $\\alpha$: create a mask that is $1$ for $|k| \\le \\alpha k_{\\mathrm{N}}$ and $0$ otherwise. Multiply $\\hat{\\psi}'(k)$ by this mask to get $\\hat{\\psi}_f(k)$.\n    d. Transform back to physical space: $\\psi_f(x) = \\mathcal{F}^{-1}\\{\\hat{\\psi}_f(k)\\}$.\n    e. Compute the dealiased density: $\\rho(x) = |\\psi_f(x)|^2$.\n    f. Apply the nonlinear update to the unfiltered field $\\psi'(x)$:\n    $$\n    \\psi''(x) = \\psi'(x) \\exp\\left(-i g \\rho(x) \\Delta t\\right)\n    $$\n3.  **Second Linear Half-Step**: Transform $\\psi''(x)$ to $\\hat{\\psi}''(k)$ via FFT and apply the second linear propagator.\n    $$\n     \\hat{\\psi}(k, t+\\Delta t) = \\hat{\\psi}''(k) \\exp\\left(-i \\frac{k^2}{2} \\frac{\\Delta t}{2}\\right)\n    $$\nThis process is repeated for the total number of time steps, $T/\\Delta t$.\n\n### Calculation of Diagnostics\n\nThe initial condition is $\\psi(x,0) = A(e^{ik_1x} + e^{ik_2x})$ with $k_1=8, k_2=12$. The normalization constant $A$ is determined by the condition $\\int_0^L |\\psi(x,0)|^2 dx = 1$. With $L=2\\pi$, this gives $\\int_0^{2\\pi} |A|^2 (2 + 2\\cos((k_1-k_2)x)) dx = 1$, which solves to $4\\pi|A|^2 = 1$, so we choose real $A=1/\\sqrt{4\\pi}$.\n\nThe numerical grid and parameters are: $L=2\\pi, N=256, \\Delta x = L/N = \\pi/128$. The physical wavenumbers are integer-valued, $k_n = n$, and are computed via `numpy.fft.fftfreq(N) * N`. The Nyquist wavenumber is $k_{\\mathrm{N}} = N/2 = 128$.\n\nThe diagnostics are computed as follows:\n- **Total Energy Drift ($D$)**: The total energy $E(t) = K(t) + V(t)$ is calculated at $t=0$ and $t=T$.\n  - Kinetic Energy: $K(t) = \\frac{\\Delta x}{N} \\sum_k \\frac{1}{2} k^2 |\\hat{\\psi}(k,t)|^2$.\n  - Potential Energy: $V(t) = \\frac{g}{2} \\Delta x \\sum_j |\\psi(x_j,t)|^4$.\n  - Drift: $D = |E(T) - E(0)| / |E(0)|$.\n- **Tail Kinetic Energy Growth ($G$)**: The high-$k$ tail is defined by $|k| \\geq \\beta k_{\\mathrm{N}} = 0.85 \\times 128 = 108.8$. We use modes with $|k| \\ge 109$.\n  - Tail KE at time $t$: $K^{\\mathrm{tail}}(t)$ is the sum of $\\frac{\\Delta x}{N} \\frac{1}{2} k^2 |\\hat{\\psi}(k,t)|^2$ over modes in the tail.\n  - Growth Factor: $G = K^{\\mathrm{tail}}(T) / (K^{\\mathrm{tail}}(0) + \\varepsilon)$ with $\\varepsilon=10^{-12}$.\n- **High-$k$ Spectral Upturn (Slope)**: The power spectrum is $P(k)=|\\hat{\\psi}(k,T)|^2$. The one-dimensional shell spectrum is $S(k_{shell}) = P(k_{shell}) + P(-k_{shell})$ for $k_{shell}  0$. We find the last $M=8$ non-zero values of $S(k)$ for $k$ approaching $k_{\\mathrm{N}}$ and perform a linear least-squares fit of $\\log(S(k))$ versus $k$ to find the slope. A positive slope indicates an unphysical pile-up of energy.\n\nThe composite aliasing detector returns `True` if at least two of these conditions are met: $G  50$, $D  0.02$, and slope $ 0$. The implementation will execute this logic for each of the four test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D cubic NLSE using a split-step Fourier method and\n    evaluates aliasing based on several diagnostics.\n    \"\"\"\n\n    def run_simulation(g_val, alpha, L, N, T, dt):\n        \"\"\"\n        Performs a single simulation run for a given set of parameters.\n\n        Args:\n            g_val (float): Nonlinear coupling constant.\n            alpha (float): Dealiasing filter factor (1, 2/3, or 1/3).\n            L (float): Domain length.\n            N (int): Number of grid points.\n            T (float): Total simulation time.\n            dt (float): Time step.\n\n        Returns:\n            tuple: A tuple containing the diagnostics (G, D, tail_slope).\n        \"\"\"\n        # Grid and wavenumber setup\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        k = np.fft.fftfreq(N) * N\n\n        k_sq = k**2\n        k_N = N / 2\n\n        # Initial condition\n        k1, k2 = 8, 12\n        A = 1.0 / np.sqrt(4 * np.pi)\n        psi0_cont = A * (np.exp(1j * k1 * x) + np.exp(1j * k2 * x))\n\n        # Recalculate A based on discrete sum for consistency\n        norm_factor = np.sqrt(np.sum(np.abs(psi0_cont)**2) * dx)\n        psi0 = psi0_cont / norm_factor\n        \n        psi = psi0.copy()\n        psi_hat = np.fft.fft(psi)\n\n        # Calculate initial energy\n        ke0 = (dx / N) * 0.5 * np.sum(k_sq * np.abs(psi_hat)**2)\n        pe0 = (g_val / 2) * dx * np.sum(np.abs(psi)**4)\n        E0 = ke0 + pe0\n        if np.isclose(np.abs(E0), 0): E0 = 1.0 # Avoid division by zero for g=0 case\n\n        # Calculate initial tail kinetic energy\n        beta = 0.85\n        tail_mask = np.abs(k) >= beta * k_N\n        ke_tail_0 = (dx / N) * 0.5 * np.sum(k_sq[tail_mask] * np.abs(psi_hat[tail_mask])**2)\n\n        # Time-stepping loop\n        num_steps = int(round(T / dt))\n        linear_propagator_half = np.exp(-0.5j * k_sq * (dt / 2.0))\n        dealias_mask = np.abs(k) = alpha * k_N\n\n        for step in range(num_steps):\n            # First linear half-step\n            psi_hat *= linear_propagator_half\n\n            # Nonlinear full-step\n            psi_temp = np.fft.ifft(psi_hat)\n            \n            # Dealiasing for density calculation\n            psi_hat_filtered = psi_hat * dealias_mask\n            psi_filtered = np.fft.ifft(psi_hat_filtered)\n\n            rho = np.abs(psi_filtered)**2\n            nonlinear_propagator = np.exp(-1j * g_val * rho * dt)\n            psi = psi_temp * nonlinear_propagator\n\n            psi_hat = np.fft.fft(psi)\n            \n            # Second linear half-step\n            psi_hat *= linear_propagator_half\n\n        psi_final = np.fft.ifft(psi_hat)\n\n        # ---- Calculate final diagnostics ----\n\n        # 1. Tail kinetic energy growth (G)\n        ke_tail_T = (dx / N) * 0.5 * np.sum(k_sq[tail_mask] * np.abs(psi_hat[tail_mask])**2)\n        epsilon = 1e-12\n        G = ke_tail_T / (ke_tail_0 + epsilon)\n\n        # 2. Total energy drift (D)\n        keT = (dx / N) * 0.5 * np.sum(k_sq * np.abs(psi_hat)**2)\n        peT = (g_val / 2) * dx * np.sum(np.abs(psi_final)**4)\n        ET = keT + peT\n        D = np.abs(ET - E0) / np.abs(E0)\n\n        # 3. High-k spectral upturn (slope)\n        M = 8\n        power_spectrum = np.abs(psi_hat)**2\n        \n        # Symmetrized 1D shell spectrum for k > 0\n        k_pos = k[1:N//2]\n        shell_spec = power_spectrum[1:N//2] + power_spectrum[N-1:N//2:-1]\n\n        # Find last M non-zero shells to fit\n        non_zero_indices = np.where(shell_spec > 1e-40)[0]\n        if len(non_zero_indices) >= M:\n            fit_indices = non_zero_indices[-M:]\n            k_fit = k_pos[fit_indices]\n            log_spec_fit = np.log(shell_spec[fit_indices])\n            \n            # Perform linear fit: log(P) = slope * k + intercept\n            slope, _ = np.polyfit(k_fit, log_spec_fit, 1)\n        else:\n            slope = -np.inf # No upturn if spectrum decays too fast\n\n        return G, D, slope\n\n    # Fixed numerical parameters\n    L_param = 2 * np.pi\n    N_param = 256\n    T_param = 0.8\n    dt_param = 1e-3\n\n    # Thresholds for aliasing detector\n    G_thr = 50.0\n    D_thr = 0.02\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (g, alpha)\n        (20.0, 1.0),            # Case 1: No dealiasing\n        (20.0, 2.0 / 3.0),      # Case 2: 2/3 rule (insufficient for cubic)\n        (20.0, 1.0 / 3.0),      # Case 3: 1/3 rule (sufficient for cubic)\n        (0.0, 1.0)              # Case 4: Linear evolution (control)\n    ]\n\n    results = []\n    for g, alpha in test_cases:\n        G, D, tail_slope = run_simulation(g, alpha, L_param, N_param, T_param, dt_param)\n\n        # Composite aliasing detector\n        cond1 = G > G_thr\n        cond2 = D > D_thr\n        cond3 = tail_slope > 0\n        \n        aliasing_detected = (int(cond1) + int(cond2) + int(cond3)) >= 2\n        results.append(aliasing_detected)\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}