{
    "hands_on_practices": [
        {
            "introduction": "Before employing a numerical tool for scientific discovery, one must first establish trust in its correctness. This practice guides you through a fundamental validation exercise: creating a unit test for your Fast Fourier Transform (FFT) implementation by comparing its output against a known analytic truth . By using a Gaussian wave packet, whose Fourier transform is also a Gaussian, you will learn to manage the crucial details of transform conventions, scaling factors, and frequency-grid ordering while developing quantitative metrics to assess both the amplitude and phase accuracy of your computational tool.",
            "id": "3556144",
            "problem": "Design and implement a fully self-contained numerical unit test that validates the correctness of a Fast Fourier Transform (FFT) implementation by comparing the discrete Fourier transform of a sampled Gaussian wave packet against its analytic continuous Fourier transform. The context is momentum-space transforms used in computational nuclear physics, where the spatial coordinate is measured in femtometers and the conjugate momentum (wave number) is measured in inverse femtometers. Your program must compute both amplitude and phase accuracy metrics and report them for a test suite of parameter sets.\n\nStart from the following fundamental base:\n- Define the continuous Fourier transform by the convention $F(k) = \\int_{-\\infty}^{\\infty} f(x)\\,e^{-i k x}\\,dx$ and its inverse $f(x) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} F(k)\\,e^{i k x}\\,dk$, where $k$ is the angular wave number with unit $\\mathrm{fm}^{-1}$ and $x$ is the position in $\\mathrm{fm}$, and angles are in radians.\n- The discrete approximation to the continuous transform on a uniform grid of $N$ points with spacing $dx$ is $F(k_m) \\approx dx \\sum_{n=0}^{N-1} f(x_n)\\,e^{-i k_m x_n}$, where $x_n = n\\,dx$ and $k_m = 2\\pi\\,m/(N\\,dx)$ for integer $m$ on the frequency grid generated by the discrete Fourier transform. This uses the numerical Fast Fourier Transform algorithm to evaluate the discrete sum efficiently.\n\nConsider the Gaussian wave packet\n$$\nf(x) = A \\exp\\!\\left(-\\frac{(x - x_0)^2}{2\\sigma^2}\\right)\\exp(i k_0 x),\n$$\nwith real parameters $A$ (dimensionless amplitude), $\\sigma$ (width in $\\mathrm{fm}$), $x_0$ (shift in $\\mathrm{fm}$), and $k_0$ (carrier in $\\mathrm{fm}^{-1}$). Using the Gaussian integral $\\int_{-\\infty}^{\\infty} e^{-a y^2 + b y}\\,dy = \\sqrt{\\frac{\\pi}{a}}\\,e^{b^2/(4a)}$ for $\\Re(a) > 0$, it follows that the exact continuous Fourier transform is another Gaussian in $k$ with a linear phase:\n$$\nF_{\\mathrm{analytic}}(k) = A \\sqrt{2\\pi}\\,\\sigma \\exp\\!\\left(-\\frac{\\sigma^2 (k - k_0)^2}{2}\\right)\\exp\\!\\left(i (k_0 - k) x_0\\right).\n$$\nThus, the amplitude envelope is $|F_{\\mathrm{analytic}}(k)| = A \\sqrt{2\\pi}\\,\\sigma \\exp\\!\\left(-\\frac{\\sigma^2 (k - k_0)^2}{2}\\right)$ and the phase is $\\arg F_{\\mathrm{analytic}}(k) = (k_0 - k)x_0$.\n\nYour task is to:\n1. Implement the discrete approximation $F_{\\mathrm{FFT}}(k_m) = dx \\sum_{n=0}^{N-1} f(x_n)\\,e^{-i k_m x_n}$ using a Fast Fourier Transform and the discrete frequency grid $k_m = 2\\pi\\,m/(N\\,dx)$ with $m$ as returned by a standard FFT frequency generator. Use $x_n = n\\,dx$ for $n = 0,1,\\dots,N-1$. Ensure that $dx$ is in $\\mathrm{fm}$, $k$ is in $\\mathrm{fm}^{-1}$, and angles are in radians.\n2. Compute the analytic transform $F_{\\mathrm{analytic}}(k_m)$ evaluated on the same discrete $k_m$ grid.\n3. Define an amplitude accuracy metric as the maximum relative error over the subset of $k_m$ where the analytic amplitude is not negligible:\n$$\n\\varepsilon_{\\mathrm{amp}} = \\max_{m \\in \\mathcal{M}} \\frac{\\left|\\left|F_{\\mathrm{FFT}}(k_m)\\right| - \\left|F_{\\mathrm{analytic}}(k_m)\\right|\\right|}{\\left|F_{\\mathrm{analytic}}(k_m)\\right|},\n$$\nwhere $\\mathcal{M} = \\{ m : |F_{\\mathrm{analytic}}(k_m)| \\ge \\eta \\,\\max_{m'} |F_{\\mathrm{analytic}}(k_{m'})| \\}$ and $\\eta$ is a small cutoff chosen to avoid division by numbers dominated by numerical noise. Use $\\eta = 10^{-6}$.\n4. Define a phase accuracy metric as the root-mean-square error of the phase difference between the numerical and analytic transforms over the same set $\\mathcal{M}$:\n$$\n\\varepsilon_{\\mathrm{phase}} = \\sqrt{\\frac{1}{|\\mathcal{M}|}\\sum_{m \\in \\mathcal{M}} \\Delta\\phi_m^2}, \\quad \\Delta\\phi_m = \\mathrm{unwrap}\\!\\left(\\arg\\left(\\frac{F_{\\mathrm{FFT}}(k_m)}{F_{\\mathrm{analytic}}(k_m)}\\right)\\right),\n$$\nwhere $\\mathrm{unwrap}$ denotes a continuous unwrapping in radians to remove $2\\pi$ jumps. Angles must be in radians.\n5. For each test case, compare $\\varepsilon_{\\mathrm{amp}}$ and $\\varepsilon_{\\mathrm{phase}}$ against the tolerances $\\tau_{\\mathrm{amp}} = 10^{-2}$ and $\\tau_{\\mathrm{phase}} = 10^{-2}$, respectively, and record boolean pass/fail values $p_{\\mathrm{amp}} = (\\varepsilon_{\\mathrm{amp}} \\le \\tau_{\\mathrm{amp}})$ and $p_{\\mathrm{phase}} = (\\varepsilon_{\\mathrm{phase}} \\le \\tau_{\\mathrm{phase}})$.\n\nImplement the program to compute these metrics for the following test suite of parameter sets, chosen to probe accuracy, resolution, and edge conditions relevant to computational nuclear physics transforms between coordinate and momentum space:\n- Test $1$: $N = 2048$, $dx = 0.05\\,\\mathrm{fm}$, $\\sigma = 2.0\\,\\mathrm{fm}$, $A = 1.3$, $x_0 = 10.0\\,\\mathrm{fm}$, $k_0 = 0.6\\,\\mathrm{fm}^{-1}$.\n- Test $2$: $N = 1024$, $dx = 0.10\\,\\mathrm{fm}$, $\\sigma = 0.5\\,\\mathrm{fm}$, $A = 0.9$, $x_0 = 30.0\\,\\mathrm{fm}$, $k_0 = 0.0\\,\\mathrm{fm}^{-1}$.\n- Test $3$: $N = 1024$, $dx = 0.10\\,\\mathrm{fm}$, $\\sigma = 3.0\\,\\mathrm{fm}$, $A = 0.7$, $x_0 = 5.0\\,\\mathrm{fm}$, $k_0 = 0.8\\,\\pi/dx \\approx 25.132741\\,\\mathrm{fm}^{-1}$.\n- Test $4$: $N = 2048$, $dx = 0.05\\,\\mathrm{fm}$, $\\sigma = 0.2\\,\\mathrm{fm}$, $A = 1.0$, $x_0 = 2.0\\,\\mathrm{fm}$, $k_0 = 1.5\\,\\mathrm{fm}^{-1}$.\n\nAngle units must be radians throughout. All computations must be carried out in double precision.\n\nFinal output format: Your program should produce a single line of output containing a Python-style list, where each test case contributes a sublist with four entries in the order $[\\varepsilon_{\\mathrm{amp}}, \\varepsilon_{\\mathrm{phase}}, p_{\\mathrm{amp}}, p_{\\mathrm{phase}}]$. For example, the overall output should look like $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$, where $a_j$ and $b_j$ are floats and $c_j$ and $d_j$ are booleans.",
            "solution": "The user-provided problem statement has been analyzed and validated as scientifically sound, well-posed, and objective. It constitutes a valid and meaningful exercise in computational physics. The task is to create a numerical unit test to validate a Fast Fourier Transform (FFT) implementation against an analytically known Fourier transform pair. The test case is a Gaussian wave packet, a standard and fundamental model in physics. The problem specifies all necessary physical and numerical parameters, definitions for error metrics, and test cases.\n\nThe methodological approach to solving this problem will be as follows:\n\nFirst, we establish the fundamental relationship between the continuous Fourier transform and its discrete approximation via the FFT algorithm. The continuous Fourier transform integral is approximated by a discrete sum over a finite grid. The problem states this approximation as $F(k_m) \\approx dx \\sum_{n=0}^{N-1} f(x_n)\\,e^{-i k_m x_n}$. The sum $\\sum_{n=0}^{N-1} f(x_n)\\,e^{-i 2\\pi m n / N}$ is the standard definition of the Discrete Fourier Transform (DFT), which is computed efficiently by the FFT algorithm. Given the specified relationship between the spatial grid $x_n = n\\,dx$ and the wave number grid $k_m = 2\\pi m / (N\\,dx)$, we can confirm that the discrete sum is equivalent to the definition of the DFT. Therefore, the numerical approximation of the transform is $F_{\\mathrm{FFT}}(k_m) = dx \\cdot \\mathrm{FFT}[f(x_n)]_m$.\n\nThe core of the solution involves the following sequence of steps for each test case:\n\n1.  **Grid Generation**: A uniform spatial grid $x_n = n \\cdot dx$ for $n = 0, \\ldots, N-1$ will be created. The corresponding angular wave number grid $k_m$ will be generated using the `numpy.fft.fftfreq` function, scaled by $2\\pi$ to convert from frequency (cycles per unit distance) to angular wave number (radians per unit distance). All calculations will use double-precision floating-point numbers (`np.float64` and `np.complex128`).\n\n2.  **Wave Packet Sampling**: The continuous Gaussian wave packet function $f(x) = A \\exp(-\\frac{(x - x_0)^2}{2\\sigma^2})\\exp(i k_0 x)$ will be sampled on the discrete spatial grid $x_n$ to produce the input array for the FFT.\n\n3.  **Numerical Transform (FFT)**: The FFT of the sampled wave packet will be computed using `numpy.fft.fft`. The result will be scaled by the spatial grid spacing $dx$ to obtain $F_{\\mathrm{FFT}}(k_m)$.\n\n4.  **Analytic Transform**: The exact analytical Fourier transform, $F_{\\mathrm{analytic}}(k) = A \\sqrt{2\\pi}\\,\\sigma \\exp(-\\frac{\\sigma^2 (k - k_0)^2}{2})\\exp(i (k_0 - k) x_0)$, will be evaluated on the discrete wave number grid $k_m$.\n\n5.  **Frequency Ordering**: A critical step in the comparison, especially for the phase, is to ensure that the transforms are processed along a monotonically increasing frequency axis. The standard output of an FFT algorithm orders frequencies from zero up to the positive Nyquist frequency, followed by negative frequencies. This non-monotonic ordering can cause issues with phase unwrapping. To rectify this, both the wave number grid $k_m$ and the numerical transform $F_{\\mathrm{FFT}}(k_m)$ will be rearranged using `numpy.fft.fftshift`. This function centers the zero-frequency component, resulting in a monotonically ordered grid from negative to positive wave numbers. The analytical transform will be computed directly on this shifted, monotonic grid.\n\n6.  **Error Metric Calculation**:\n    a.  A boolean mask, corresponding to the set $\\mathcal{M}$, will be created. This mask identifies the wave numbers $k_m$ where the analytic transform's amplitude is significant, defined as being greater than or equal to a fraction $\\eta=10^{-6}$ of the maximum analytic amplitude. This prevents numerical instabilities from division by zero or near-zero values.\n    b.  The amplitude accuracy metric, $\\varepsilon_{\\mathrm{amp}}$, will be computed as the maximum relative error between the amplitudes of the numerical and analytical transforms over the domain defined by the mask $\\mathcal{M}$.\n    c.  The phase accuracy metric, $\\varepsilon_{\\mathrm{phase}}$, will be calculated. The phase difference is computed from the argument of the complex ratio $F_{\\mathrm{FFT}}(k_m) / F_{\\mathrm{analytic}}(k_m)$ for points within $\\mathcal{M}$. The `numpy.unwrap` function is then applied to this sequence of phase differences to correct for $2\\pi$ discontinuities, yielding $\\Delta\\phi_m$. Finally, the root-mean-square (RMS) of these unwrapped phase differences is calculated to obtain $\\varepsilon_{\\mathrm{phase}}$.\n\n7.  **Validation**: The computed error metrics, $\\varepsilon_{\\mathrm{amp}}$ and $\\varepsilon_{\\mathrm{phase}}$, will be compared against their respective tolerances, $\\tau_{\\mathrm{amp}} = 10^{-2}$ and $\\tau_{\\mathrm{phase}} = 10^{-2}$. The results will determine the boolean pass/fail flags, $p_{\\mathrm{amp}}$ and $p_{\\mathrm{phase}}$.\n\nThis procedure will be executed for each of the four parameter sets provided in the problem statement. The results, comprising the two error metrics and two boolean flags for each test, will be collected and formatted into the specified output string, which represents a Python list of lists.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the FFT validation test suite and print results.\n    \"\"\"\n\n    def run_fft_validation_test(N, dx, sigma, A, x_0, k_0, eta, tau_amp, tau_phase):\n        \"\"\"\n        Performs a single validation test for the FFT against the analytic\n        Fourier transform of a Gaussian wave packet.\n\n        Args:\n            N (int): Number of sample points.\n            dx (float): Spatial grid spacing in fm.\n            sigma (float): Width of the Gaussian wave packet in fm.\n            A (float): Dimensionless amplitude of the wave packet.\n            x_0 (float): Center of the wave packet in fm.\n            k_0 (float): Carrier wave number in fm^-1.\n            eta (float): Cutoff for significant amplitude region.\n            tau_amp (float): Tolerance for amplitude error.\n            tau_phase (float): Tolerance for phase error.\n\n        Returns:\n            list: A list containing [eps_amp, eps_phase, p_amp, p_phase].\n        \"\"\"\n        # 1. Define Grids\n        # Spatial grid\n        x_n = np.arange(N, dtype=np.float64) * dx\n        # Angular wave number grid\n        k_m = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n        # 2. Sample the Gaussian wave packet in position space\n        f_x = A * np.exp(-(x_n - x_0)**2 / (2 * sigma**2)) * np.exp(1j * k_0 * x_n)\n        f_x = f_x.astype(np.complex128)\n\n        # 3. Compute the numerical transform using FFT\n        # The factor dx scales the DFT sum to approximate the continuous integral\n        F_fft = dx * np.fft.fft(f_x)\n\n        # 4. Shift grids for monotonic frequency axis for correct phase unwrapping\n        k_m_shifted = np.fft.fftshift(k_m)\n        F_fft_shifted = np.fft.fftshift(F_fft)\n\n        # 5. Compute the analytic transform on the shifted (monotonic) k-grid\n        F_analytic_shifted = (A * np.sqrt(2 * np.pi) * sigma *\n                              np.exp(-sigma**2 * (k_m_shifted - k_0)**2 / 2) *\n                              np.exp(1j * (k_0 - k_m_shifted) * x_0))\n        F_analytic_shifted = F_analytic_shifted.astype(np.complex128)\n\n        # 6. Define the region M where the analytic amplitude is significant\n        amp_analytic = np.abs(F_analytic_shifted)\n        amp_max = np.max(amp_analytic)\n        mask = amp_analytic >= eta * amp_max\n\n        # Ensure mask is not empty to avoid errors in max/mean\n        if not np.any(mask):\n            eps_amp = np.inf\n            eps_phase = np.inf\n        else:\n            # 7. Compute amplitude accuracy metric (eps_amp)\n            amp_fft_shifted = np.abs(F_fft_shifted)\n            # We only evaluate the error where amplitude is significant\n            rel_err_amp_masked = (np.abs(amp_fft_shifted[mask] - amp_analytic[mask]) / \n                                  amp_analytic[mask])\n            eps_amp = np.max(rel_err_amp_masked)\n\n            # 8. Compute phase accuracy metric (eps_phase)\n            # Phase difference is taken from the argument of the ratio\n            ratio_masked = F_fft_shifted[mask] / F_analytic_shifted[mask]\n            \n            # Unwrap the phase difference to handle 2*pi jumps\n            phase_diff_raw = np.angle(ratio_masked)\n            phase_diff_unwrapped = np.unwrap(phase_diff_raw)\n            \n            # RMS of the unwrapped phase difference\n            eps_phase = np.sqrt(np.mean(phase_diff_unwrapped**2))\n\n        # 9. Compare against tolerances to get pass/fail booleans\n        p_amp = bool(eps_amp = tau_amp)\n        p_phase = bool(eps_phase = tau_phase)\n\n        return [eps_amp, eps_phase, p_amp, p_phase]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1\n        {'N': 2048, 'dx': 0.05, 'sigma': 2.0, 'A': 1.3, 'x_0': 10.0, 'k_0': 0.6},\n        # Test 2\n        {'N': 1024, 'dx': 0.10, 'sigma': 0.5, 'A': 0.9, 'x_0': 30.0, 'k_0': 0.0},\n        # Test 3\n        {'N': 1024, 'dx': 0.10, 'sigma': 3.0, 'A': 0.7, 'x_0': 5.0, 'k_0': 0.8 * np.pi / 0.10},\n        # Test 4\n        {'N': 2048, 'dx': 0.05, 'sigma': 0.2, 'A': 1.0, 'x_0': 2.0, 'k_0': 1.5},\n    ]\n\n    # Constants for metric calculation\n    eta = 1e-6\n    tau_amp = 1e-2\n    tau_phase = 1e-2\n\n    results = []\n    for case_params in test_cases:\n        result = run_fft_validation_test(\n            N=case_params['N'],\n            dx=case_params['dx'],\n            sigma=case_params['sigma'],\n            A=case_params['A'],\n            x_0=case_params['x_0'],\n            k_0=case_params['k_0'],\n            eta=eta,\n            tau_amp=tau_amp,\n            tau_phase=tau_phase\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format [[a,b,c,d],[e,f,g,h]] requires generating string representations\n    # of the inner lists and joining them. str() of a list includes spaces,\n    # so they are removed to match the implied format.\n    sublist_strs = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(sublist_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a validated FFT, we can now use it as a powerful engine for solving differential equations. This exercise tackles a classic problem in quantum mechanics and nuclear theory: solving the inhomogeneous Schrödinger equation to find the system's response to a localized source . You will implement a Fourier-space Green's function method, which elegantly transforms the differential operator into algebraic multiplication, and confront the singularity that arises by applying the physically-motivated complex energy shift ($E \\to E + i\\eta$), a standard technique in scattering theory.",
            "id": "3556238",
            "problem": "Consider the time-independent inhomogeneous Schrödinger equation in three spatial dimensions,\n$$\n(E - H)\\,\\psi(\\mathbf{r}) = S(\\mathbf{r}),\n$$\nwhere $E$ is a real scalar energy parameter, $H$ is the Hamiltonian operator, $\\psi(\\mathbf{r})$ is the complex-valued wavefield, and $S(\\mathbf{r})$ is a prescribed source. In a homogeneous medium without external potential, take the Hamiltonian to be the kinetic-energy operator only,\n$$\nH = -\\nabla^2,\n$$\nin a dimensionless formulation where $\\hbar^2/(2m) = 1$ so that all quantities are non-dimensional. The computational domain is a cube of side length $L=2\\pi$ with periodic boundary conditions, discretized on a uniform Cartesian grid of $N\\times N\\times N$ points with $N=32$. Let the source be a localized isotropic Gaussian,\n$$\nS(\\mathbf{r}) = A \\exp\\!\\left(-\\frac{\\|\\mathbf{r}\\|^2}{2\\sigma^2}\\right),\n$$\nwith amplitude $A=1$ and width parameter $\\sigma0$. Angles and angular wavenumbers are to be understood in radians.\n\nThe task is to solve the above equation numerically using a Fourier-domain Green’s function evaluated via the Fast Fourier Transform (FFT). The Green’s function has a singularity at $k^2=E$, where $k^2 = k_x^2+k_y^2+k_z^2$ is the squared angular wavenumber. To regularize this singularity and select the physically meaningful outgoing solution in the sense of scattering theory, perform the standard complex energy shift $E \\to E + i\\eta$ with $\\eta0$.\n\nYour program must implement the following steps in a mathematically consistent way:\n- Construct the three-dimensional (3D) source $S(\\mathbf{r})$ on the periodic grid centered at the origin, using the specified $L$ and $N$.\n- Use the Discrete Fourier Transform (DFT), computed by the FFT, to map the source to Fourier space. Identify the angular wavenumbers on the grid consistent with the periodic domain and the chosen discretization.\n- Form the Fourier-domain solution by applying the Green’s function with the complex shift $E\\to E+i\\eta$ to regularize the pole, ensuring all operations are numerically well-defined.\n- Transform the solution back to real space. From the resulting $\\psi(\\mathbf{r})$, extract the real part of $\\psi(\\mathbf{0})$ at the spatial origin $\\mathbf{r}=\\mathbf{0}$.\n\nTest Suite:\nUse $L=2\\pi$, $N=32$, and $A=1$. For each of the following parameter sets $(E,\\eta,\\sigma)$, compute the real part of the solution at the origin, $\\operatorname{Re}[\\psi(\\mathbf{0})]$, as a floating-point number:\n1. $(E,\\eta,\\sigma) = (1.0, 0.05, 0.40)$\n2. $(E,\\eta,\\sigma) = (1.0, 10^{-6}, 0.20)$\n3. $(E,\\eta,\\sigma) = (0.0, 0.05, 0.30)$\n4. $(E,\\eta,\\sigma) = (-0.5, 0.05, 0.50)$\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). The list should contain the values of $\\operatorname{Re}[\\psi(\\mathbf{0})]$ for the four test cases in the order listed above. All outputs are dimensionless real numbers.",
            "solution": "The problem is scientifically and mathematically sound, well-posed, and contains all necessary information for a unique solution. We may therefore proceed with the derivation and implementation.\n\nThe problem asks for the numerical solution of the time-independent inhomogeneous Schrödinger equation in a three-dimensional homogeneous medium with no external potential. In the provided dimensionless units, this equation is\n$$\n(E - H)\\,\\psi(\\mathbf{r}) = S(\\mathbf{r})\n$$\nwhere the Hamiltonian $H$ is purely kinetic, $H = -\\nabla^2$. The equation thus takes the form of an inhomogeneous Helmholtz equation:\n$$\n(\\nabla^2 + E)\\,\\psi(\\mathbf{r}) = -S(\\mathbf{r})\n$$\nThe domain is a cube of side length $L=2\\pi$ with periodic boundary conditions, discretized on a uniform Cartesian grid of $N \\times N \\times N$ points, where $N=32$. The source $S(\\mathbf{r})$ is a specified isotropic Gaussian function centered at the origin.\n\nThis linear partial differential equation with constant coefficients is ideally suited for a solution in the Fourier domain, leveraging the fact that the Fourier transform diagonalizes the differential operator $\\nabla^2$. Let $\\tilde{f}(\\mathbf{k}) = \\mathcal{F}[f(\\mathbf{r})]$ denote the Fourier transform of a function $f(\\mathbf{r})$. Applying the Fourier transform to the equation yields:\n$$\n\\mathcal{F}[(\\nabla^2 + E)\\,\\psi(\\mathbf{r})] = \\mathcal{F}[-S(\\mathbf{r})]\n$$\nUsing the property $\\mathcal{F}[\\nabla^2 f(\\mathbf{r})] = -\\|\\mathbf{k}\\|^2 \\tilde{f}(\\mathbf{k})$, where $\\mathbf{k}=(k_x, k_y, k_z)$ is the angular wavevector and $k^2 = \\|\\mathbf{k}\\|^2 = k_x^2 + k_y^2 + k_z^2$ is its squared magnitude, the equation in Fourier space becomes an algebraic equation:\n$$\n(-k^2 + E)\\,\\tilde{\\psi}(\\mathbf{k}) = -\\tilde{S}(\\mathbf{k})\n$$\nWe can solve for the Fourier transform of the wavefield, $\\tilde{\\psi}(\\mathbf{k})$:\n$$\n\\tilde{\\psi}(\\mathbf{k}) = \\frac{\\tilde{S}(\\mathbf{k})}{E - k^2}\n$$\nThe term $\\tilde{G}(\\mathbf{k}) = 1/(E - k^2)$ is the Green's function in the Fourier domain. The solution in real space, $\\psi(\\mathbf{r})$, is then obtained by the inverse Fourier transform:\n$$\n\\psi(\\mathbf{r}) = \\mathcal{F}^{-1}[\\tilde{\\psi}(\\mathbf{k})] = \\mathcal{F}^{-1}\\left[ \\frac{\\tilde{S}(\\mathbf{k})}{E - k^2} \\right]\n$$\nA critical issue arises when the energy parameter $E$ is positive, as the denominator $E-k^2$ can become zero for wavevectors $\\mathbf{k}$ that lie on the sphere of radius $\\sqrt{E}$. This leads to a non-integrable singularity, and the solution is ill-defined. To obtain a physically meaningful outgoing wave solution, as required in scattering theory, we regularize this singularity by introducing a small imaginary part to the energy, $E \\to E + i\\eta$, where $\\eta$ is a small positive real number. This procedure, known as the limiting absorption principle, shifts the poles of the Green's function off the real axis, ensuring a well-defined integral. The regularized solution in Fourier space is:\n$$\n\\tilde{\\psi}(\\mathbf{k}) = \\frac{\\tilde{S}(\\mathbf{k})}{E + i\\eta - k^2}\n$$\nThe numerical solution involves discretizing this continuous formalism.\n\n**Numerical Implementation using the Fast Fourier Transform (FFT)**\n\n1.  **Grid and Wavenumber Discretization:** The computational domain is a cube of side length $L=2\\pi$ with $N=32$ points along each axis. The grid spacing is $\\Delta x = L/N = 2\\pi/32 = \\pi/16$. Due to the periodic boundary conditions, the allowed angular wavenumbers are discrete. For a given axis, the wavenumbers are $k_j = 2\\pi n_j / L$, where $n_j$ are integers. The set of integers corresponding to the standard FFT ordering for an even $N$ is $n_j \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$. For the specific case of $L=2\\pi$, the wavenumbers simplify to the integers themselves, $k_j = n_j$. We construct three-dimensional grids for the wavevector components $(k_x, k_y, k_z)$ and compute the squared magnitude $k^2 = k_x^2 + k_y^2 + k_z^2$ at each point in the discrete Fourier space.\n\n2.  **Source Construction:** The source is an isotropic Gaussian centered at the origin, $S(\\mathbf{r}) = A \\exp(-\\|\\mathbf{r}\\|^2 / (2\\sigma^2))$, with $A=1$. On the discrete grid, we must calculate the distance $\\|\\mathbf{r}\\|$ from the origin to each grid point $(x_i, y_j, z_l)$, respecting the periodic boundary conditions. The displacement vector from the origin for a grid point with indices $(i,j,l)$ can be represented by coordinates that wrap around the periodic domain, i.e., values in $[-L/2, L/2)$. Using the coordinate representation that matches the FFT's frequency ordering is most convenient. For each dimension, the coordinate vector is given by $x_n = L \\times \\text{fftfreq}(N)$, which for $L=2\\pi$ simplifies to $x_n = 2\\pi \\times \\{0, 1/N, \\dots, -1/N\\}$. We generate $3$D coordinate arrays $(X, Y, Z)$ using this scheme and compute the squared distance $r^2 = X^2 + Y^2 + Z^2$ to construct the source array $S_{ijk}$.\n\n3.  **Algorithmic Steps:**\n    a. Construct the $N \\times N \\times N$ array for the source $S(\\mathbf{r})$ on the grid as described above.\n    b. Compute the $3$D Discrete Fourier Transform (DFT) of the source array, $\\tilde{S}(\\mathbf{k})$, using an FFT algorithm (`numpy.fft.fftn`).\n    c. Construct the $N \\times N \\times N$ array for the squared wavenumber $k^2$.\n    d. Compute the Fourier-domain solution $\\tilde{\\psi}(\\mathbf{k}) = \\tilde{S}(\\mathbf{k}) / (E + i\\eta - k^2)$ for each point in the discrete Fourier space.\n    e. Compute the inverse $3$D DFT of $\\tilde{\\psi}(\\mathbf{k})$ using an inverse FFT algorithm (`numpy.fft.ifftn`) to obtain the solution $\\psi(\\mathbf{r})$ on the real-space grid.\n    f. Extract the real part of the solution at the origin, $\\operatorname{Re}[\\psi(\\mathbf{r}=\\mathbf{0})]$. In our discrete setup, the origin corresponds to the grid point with indices $(0,0,0)$.\n\nThis procedure is implemented for each set of parameters $(E, \\eta, \\sigma)$ provided in the test suite.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the inhomogeneous Schrödinger equation in 3D on a periodic grid\n    using a Fourier-space Green's function method.\n    \"\"\"\n\n    def compute_psi0_real(E, eta, sigma, L=2 * np.pi, N=32, A=1):\n        \"\"\"\n        Computes the real part of the wavefield at the origin for a given\n        set of parameters.\n\n        Args:\n            E (float): Energy parameter.\n            eta (float): Regularization parameter for the complex energy shift.\n            sigma (float): Width of the Gaussian source.\n            L (float): Side length of the cubic domain.\n            N (int): Number of grid points along each dimension.\n            A (float): Amplitude of the source.\n\n        Returns:\n            float: The value of Re[psi(0)].\n        \"\"\"\n        # 1. Construct the real-space grid coordinates that align with FFT ordering.\n        # This represents the displacement from the origin on a periodic grid.\n        # coords_1d = L * np.fft.fftfreq(N) gives coordinates in [-L/2, L/2)\n        # corresponding to FFT indices [0, 1, ..., N/2-1, -N/2, ..., -1].\n        coords_1d = L * np.fft.fftfreq(N)\n        X, Y, Z = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n\n        # Calculate the squared distance from the origin for each grid point.\n        r_sq = X**2 + Y**2 + Z**2\n\n        # 2. Construct the source term S(r) on the grid.\n        # S(r) = A * exp(-r^2 / (2*sigma^2))\n        S_r = A * np.exp(-r_sq / (2 * sigma**2))\n\n        # 3. Compute the 3D Fast Fourier Transform of the source.\n        S_k = np.fft.fftn(S_r)\n\n        # 4. Construct the wavenumber grid in Fourier space.\n        # For L=2*pi, the angular wavenumbers are integers.\n        # k_1d = 2 * pi * np.fft.fftfreq(N, d=L/N) = integers.\n        k_1d = N * np.fft.fftfreq(N)\n        kx, ky, kz = np.meshgrid(k_1d, k_1d, k_1d, indexing='ij')\n\n        # Calculate the squared magnitude of the wavevector k.\n        k_sq = kx**2 + ky**2 + kz**2\n\n        # 5. Apply the regularized Green's function in Fourier space.\n        # The denominator is E + i*eta - k^2. A complex number is used for E.\n        E_complex = E + 1j * eta\n        \n        # The Green's function is G(k) = 1 / (E_complex - k^2)\n        # We compute psi(k) = S(k) * G(k)\n        # To avoid division by zero (though unlikely with eta>0), handle k^2=E_complex case if needed.\n        # The problem statement ensures eta > 0, so the denominator is never zero for real E.\n        psi_k = S_k / (E_complex - k_sq)\n\n        # 6. Compute the inverse 3D FFT to get the solution in real space.\n        psi_r = np.fft.ifftn(psi_k)\n\n        # 7. Extract the real part of the solution at the origin (r=0),\n        # which corresponds to the first element of the array (index 0,0,0).\n        result = np.real(psi_r[0, 0, 0])\n\n        return result\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 0.05, 0.40),\n        (1.0, 1e-6, 0.20),\n        (0.0, 0.05, 0.30),\n        (-0.5, 0.05, 0.50),\n    ]\n\n    results = []\n    for case in test_cases:\n        E_val, eta_val, sigma_val = case\n        res = compute_psi0_real(E=E_val, eta=eta_val, sigma=sigma_val)\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Our final practice ventures into the realm of nonlinear dynamics, a cornerstone of advanced simulations in nuclear physics such as Time-Dependent Hartree-Fock (TDHF). You will implement a pseudo-spectral solver for a nonlinear Schrödinger equation, a common analog for mean-field evolution, and confront a subtle but critical numerical artifact known as aliasing . This exercise will demonstrate how nonlinear interactions generate high-frequency components that can spuriously \"fold back\" onto the grid, and you will develop and test dealiasing strategies and diagnostic tools essential for ensuring the physical fidelity of your simulations.",
            "id": "3556200",
            "problem": "Consider a one-dimensional periodic field with domain length $L$, discretized on a uniform grid of $N$ points with spacing $\\Delta x = L/N$. Let $x_j = j \\Delta x$ for $j \\in \\{0,1,\\dots,N-1\\}$. Define the discrete Fourier transform (DFT) of a grid function $u_j = u(x_j)$ by\n$$\n\\hat{u}_k = \\sum_{j=0}^{N-1} u_j \\exp\\left(-i \\frac{2\\pi}{N} j k\\right), \\quad k \\in \\{0,1,\\dots,N-1\\},\n$$\nwith inverse transform\n$$\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{u}_k \\exp\\left(+i \\frac{2\\pi}{N} j k\\right).\n$$\nLet the physical wavenumbers be $k_n = \\frac{2\\pi}{L} n$ with $n$ obtained via the usual frequency ordering of the Fast Fourier Transform (FFT). The Nyquist wavenumber is $k_{\\mathrm{N}} = \\pi/\\Delta x$. The convolution theorem states that multiplication in physical space corresponds to convolution in Fourier space. On a finite grid, the DFT implements circular convolution, so if nonlinear products generate Fourier support beyond $k_{\\mathrm{N}}$, those contributions alias back into the resolved band, corrupting the high-$k$ content.\n\nStarting from these definitions and the convolution theorem, derive the following dealiasing constraints for pseudo-spectral evaluation of polynomial nonlinearities:\n- For a quadratic nonlinearity (product of two fields each band-limited to $|k| \\leq k_c$), absence of aliasing requires $2 k_c \\leq k_{\\mathrm{N}}$. In a fixed $N$-mode representation, a sufficient in-place rule is to project all fields to a low-pass set with $|k| \\leq \\tfrac{2}{3} k_{\\mathrm{N}}$ before forming products involving two fields and to truncate back after evaluating the nonlinearity.\n- For a cubic nonlinearity (product of three fields each band-limited to $|k| \\leq k_c$), absence of aliasing requires $3 k_c \\leq k_{\\mathrm{N}}$. In a fixed $N$-mode representation, a sufficient in-place rule is to project all fields to a low-pass set with $|k| \\leq \\tfrac{1}{3} k_{\\mathrm{N}}$ before forming products involving three fields and to truncate back after evaluating the nonlinearity.\n\nWith these principles, implement a pseudo-spectral split-step time integrator for a simplified one-dimensional Time-Dependent Hartree-Fock (TDHF) analog, namely the cubic nonlinear Schrödinger-type equation (a standard surrogate for mean-field dynamics with a contact interaction):\n$$\ni \\frac{\\partial \\psi}{\\partial t} = -\\frac{1}{2} \\frac{\\partial^2 \\psi}{\\partial x^2} + g \\, |\\psi|^2 \\psi,\n$$\non a periodic domain of length $L = 2\\pi$. Use nondimensionalized units where Planck’s constant $\\hbar = 1$ and mass $m = 1$. The nonlinearity $g \\, |\\psi|^2 \\psi$ represents a local mean field proportional to the density $|\\psi|^2$, as in simplified treatments of nuclear mean-field dynamics in Time-Dependent Hartree-Fock (TDHF).\n\nAlgorithmic requirements:\n1. Use a Strang split-step scheme: apply a half-step linear (kinetic) propagator in Fourier space, a full-step nonlinear (potential) propagator in physical space, and a final half-step linear propagator in Fourier space. The linear propagator is given by multiplication with $\\exp\\left(-i \\frac{k^2}{2} \\Delta t\\right)$ in Fourier space for time step $\\Delta t$.\n2. To evaluate the nonlinear step at time $t$, compute the density $\\rho(x,t) = |\\psi(x,t)|^2$ from a possibly filtered field, and update $\\psi \\mapsto \\exp\\left(-i g \\rho \\Delta t\\right)\\psi$. To enforce a dealiasing strategy for the cubic product $|\\psi|^2 \\psi$, you may project the field used to form $\\rho$ to a low-pass band $|k| \\leq \\alpha k_{\\mathrm{N}}$, where $\\alpha \\in \\{1, \\tfrac{2}{3}, \\tfrac{1}{3}\\}$ corresponds to the chosen dealiasing strategy. Do not otherwise filter $\\psi$ after the nonlinear step; the point is to expose or suppress aliasing through the choice of $\\alpha$ when forming $\\rho$.\n3. Initialize the field at $t=0$ by a superposition of two plane waves:\n$$\n\\psi(x,0) = A \\left(e^{i k_1 x} + e^{i k_2 x}\\right),\n$$\nwith $k_1 = 8$, $k_2 = 12$, and choose $A$ such that $\\int_0^L |\\psi(x,0)|^2 \\, dx = 1$.\n4. Evolve to a final time $T$ with a fixed time step $\\Delta t$.\n\nDefine physically motivated diagnostics to detect spurious energy transfer to high-$k$ modes due to insufficient dealiasing:\n- Tail kinetic energy fraction growth. Let the kinetic energy spectrum be\n$$\n\\mathcal{K}(k) = \\frac{1}{2} k^2 |\\hat{\\psi}(k)|^2,\n$$\nwith the discrete total kinetic energy approximated by $K = \\frac{\\Delta x}{N} \\sum_k \\mathcal{K}(k)$ using the DFT convention above. Define the high-$k$ tail as modes with $|k| \\geq \\beta k_{\\mathrm{N}}$ with $\\beta = 0.85$. Compute the tail kinetic energy at $t=0$ and at $t=T$, denoted $K^{\\mathrm{tail}}_0$ and $K^{\\mathrm{tail}}_T$, respectively. Define the tail growth factor\n$$\nG = \\frac{K^{\\mathrm{tail}}_T}{K^{\\mathrm{tail}}_0 + \\varepsilon},\n$$\nwith a small regularization $\\varepsilon = 10^{-12}$ to avoid division by zero. A large value of $G$ indicates anomalous transfer to the highest modes.\n- Total energy drift. Define the discrete total energy\n$$\nE(t) = \\frac{\\Delta x}{N} \\sum_k \\frac{1}{2} k^2 |\\hat{\\psi}(k,t)|^2 + \\frac{g}{2} \\Delta x \\sum_j |\\psi(x_j,t)|^4.\n$$\nCompute the relative drift\n$$\nD = \\frac{|E(T) - E(0)|}{|E(0)|}.\n$$\nSignificant drift suggests numerical pathology that can stem from aliasing in nonlinear products.\n- High-$k$ spectral upturn. Let $P(k) = |\\hat{\\psi}(k)|^2$ and form a one-dimensional shell spectrum versus nonnegative $|k|$ by summing symmetric $\\pm k$ contributions. Fit a least-squares slope of $\\log P$ versus $k$ over the last $M$ nonzero shells nearest $k_{\\mathrm{N}}$ (take $M=8$). If this slope is positive, it indicates an unphysical upturn in the tail.\n\nConstruct a composite aliasing detector that returns true if at least two of the following three conditions hold: $G  G_{\\mathrm{thr}}$, $D  D_{\\mathrm{thr}}$, and the tail slope is positive. Use thresholds $G_{\\mathrm{thr}} = 50$ and $D_{\\mathrm{thr}} = 0.02$.\n\nUse the following fixed numerical parameters unless otherwise specified: $L = 2\\pi$, $N = 256$, $T = 0.8$, and $\\Delta t = 10^{-3}$. All quantities are nondimensional, so no physical unit conversion is required.\n\nImplement a program that executes the following test suite and prints the detection results:\n- Case 1 (happy path for detecting aliasing): $g = 20$, no dealiasing in the nonlinear step ($\\alpha = 1$). Expect aliasing to be detected.\n- Case 2 (boundary condition for quadratic but insufficient for cubic): $g = 20$, apply the $\\tfrac{2}{3}$-rule in forming $\\rho$ ($\\alpha = \\tfrac{2}{3}$). Expect aliasing to be detected because the nonlinearity is cubic.\n- Case 3 (sufficient for cubic): $g = 20$, apply the $\\tfrac{1}{3}$-rule in forming $\\rho$ ($\\alpha = \\tfrac{1}{3}$). Expect aliasing not to be detected.\n- Case 4 (edge case control): $g = 0$ (linear evolution), no dealiasing ($\\alpha = 1$). Expect aliasing not to be detected.\n\nYour program should produce a single line of output containing the results as a comma-separated list of Python boolean literals enclosed in square brackets, in the order of the cases above, for example, \"[True,False,True,False]\".",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the domain of computational physics and numerical analysis, specifically concerning the pseudo-spectral solution of nonlinear partial differential equations. The problem is well-posed, providing a defined equation, initial and boundary conditions, and a clear algorithmic and analytical task. The language is objective and the parameters are specific, allowing for a unique and verifiable solution. All definitions and constants are internally consistent and align with standard conventions in the field.\n\n### Derivation of Dealiasing Constraints\n\nThe core of the pseudo-spectral method is the use of the Fast Fourier Transform (FFT) to compute spatial derivatives. For a function $u(x)$, its spatial derivative $\\partial_x u(x)$ has a Fourier transform $\\widehat{\\partial_x u}(k) = ik\\hat{u}(k)$. This turns differential operators into simple multiplications in Fourier space. However, nonlinear terms, such as products of fields, are evaluated in physical space. The transform of a product $w(x) = u(x)v(x)$ is the convolution of their individual transforms:\n$$\n\\hat{w}_k = (\\hat{u} * \\hat{v})_k = \\sum_{p+q=k \\pmod N} \\hat{u}_p \\hat{v}_q\n$$\nIf the fields $u(x)$ and $v(x)$ are band-limited to $|k| \\le k_c$, their true convolution product $\\hat{w}_k$ will be band-limited to $|k| \\le 2k_c$. On a discrete grid, any wavenumber $k'$ is indistinguishable from its aliases $k' + mN$. The range of uniquely represented wavenumbers is typically taken as $k \\in [ -k_{\\mathrm{N}}, k_{\\mathrm{N}} )$, where the Nyquist wavenumber is $k_{\\mathrm{N}} = \\pi/\\Delta x = N/2$ for the given domain length $L=2\\pi$. If the product generates wavenumbers with magnitude greater than $k_{\\mathrm{N}}$, these modes \"fold back\" into the resolved range, contaminating the transform. This is aliasing.\n\nFor an \"in-place\" calculation on a fixed grid of $N$ modes where inputs are truncated to $|k| \\le K_{trunc}$, we need to ensure aliased modes do not pollute the truncated band. This requires that the highest frequency mode generated by the product, when aliased back, falls outside the truncated band.\n\n1.  **Quadratic Nonlinearity**: For a product $u(x)v(x)$, each band-limited to $|k| \\leq K_{trunc}$, the product's spectrum extends to $2K_{trunc}$. To prevent the aliases from contaminating the truncated region, we need the lowest-frequency alias of the product spectrum to be above $K_{trunc}$. The lowest alias comes from the highest product mode, $2K_{trunc}$, so we need $N - 2K_{trunc} > K_{trunc}$, which simplifies to $3K_{trunc}  N$. This gives the condition $K_{trunc}  N/3 = (2/3)(N/2) = \\frac{2}{3}k_{\\mathrm{N}}$. Filtering the input fields to satisfy this is the Orszag 2/3-rule.\n\n2.  **Cubic Nonlinearity**: For a product like $|\\psi|^2\\psi$, if $\\psi$ is truncated to $|k| \\le K_{trunc}$, the product has a spectrum supported up to $|k| \\le 3K_{trunc}$. The non-aliasing condition becomes $N - 3K_{trunc} > K_{trunc}$, which gives $4K_{trunc}  N$, or $K_{trunc}  N/4 = (1/2) k_{\\mathrm{N}}$. This is the \"1/2 rule\". The $\\tfrac{1}{3}$-rule proposed in the problem, which truncates to $|k| \\le K_{trunc} = N/6 = \\frac{1}{3}k_N$, is an even stricter condition. With this rule, the product spectrum extends to $3(N/6) = N/2 = k_N$, which fits perfectly into the representable domain, leaving no buffer but also causing no aliasing. It is therefore a valid, albeit conservative, sufficient condition for dealiasing a cubic nonlinearity.\n\n### Algorithmic Design for the Split-Step Integrator\n\nThe problem requires solving the cubic nonlinear Schrödinger equation using a Strang split-step method. The equation is split into a linear part, $i\\partial_t\\psi = \\hat{L}\\psi$, and a nonlinear part, $i\\partial_t\\psi = \\hat{V}\\psi$, where $\\hat{L} = -\\frac{1}{2}\\partial_{xx}$ and $\\hat{V} = g|\\psi|^2$.\n\nThe Strang splitting scheme for evolving the solution from time $t$ to $t+\\Delta t$ is a symmetric second-order method:\n$$\n\\psi(t+\\Delta t) = e^{-i\\hat{L}\\Delta t/2} e^{-i\\hat{V}\\Delta t} e^{-i\\hat{L}\\Delta t/2} \\psi(t)\n$$\n\nThe steps for a single time step are as follows:\n1.  **First Linear Half-Step**: Transform $\\psi(x, t)$ to $\\hat{\\psi}(k, t)$ via FFT and apply the propagator by multiplying with $\\exp(-i (k^2/2) (\\Delta t/2))$.\n2.  **Nonlinear Full-Step**: This step is performed in physical space.\n    a. Transform the current state back to physical space: $\\psi'(x) = \\mathcal{F}^{-1}\\{\\hat{\\psi}'(k)\\}$.\n    b. To compute a dealiased density, start with the Fourier-space field $\\hat{\\psi}'(k)$.\n    c. Apply a low-pass filter based on $\\alpha$: multiply $\\hat{\\psi}'(k)$ by a mask that is $1$ for $|k| \\le \\alpha k_{\\mathrm{N}}$ and $0$ otherwise to get $\\hat{\\psi}_f(k)$.\n    d. Transform back to physical space: $\\psi_f(x) = \\mathcal{F}^{-1}\\{\\hat{\\psi}_f(k)\\}$.\n    e. Compute the density from the filtered field: $\\rho(x) = |\\psi_f(x)|^2$.\n    f. Apply the nonlinear update to the unfiltered field $\\psi'(x)$: $\\psi''(x) = \\psi'(x) \\exp\\left(-i g \\rho(x) \\Delta t\\right)$.\n3.  **Second Linear Half-Step**: Transform $\\psi''(x)$ to $\\hat{\\psi}''(k)$ via FFT and apply the second linear propagator.\n\nThis process is repeated for the total number of time steps, $T/\\Delta t$.\n\n### Calculation of Diagnostics\n\nThe initial condition is $\\psi(x,0) = A(e^{ik_1x} + e^{ik_2x})$ with $k_1=8, k_2=12$. The normalization constant $A$ is determined by the condition $\\int_0^L |\\psi(x,0)|^2 dx = 1$. With $L=2\\pi$, this gives $A=1/\\sqrt{4\\pi}$.\n\nThe numerical grid and parameters are: $L=2\\pi, N=256, \\Delta x = L/N = \\pi/128$. The physical wavenumbers are integer-valued, $k_n = n$, and the Nyquist wavenumber is $k_{\\mathrm{N}} = N/2 = 128$.\n\nThe diagnostics are computed as follows:\n- **Total Energy Drift ($D$)**: The total energy $E(t) = K(t) + V(t)$ is calculated at $t=0$ and $t=T$.\n  - Kinetic Energy: $K(t) = \\frac{1}{2}\\frac{\\Delta x}{N} \\sum_k k^2 |\\hat{\\psi}(k,t)|^2$. (This follows from Parseval's theorem for the specified DFT convention).\n  - Potential Energy: $V(t) = \\frac{g}{2} \\Delta x \\sum_j |\\psi(x_j,t)|^4$.\n  - Drift: $D = |E(T) - E(0)| / |E(0)|$.\n- **Tail Kinetic Energy Growth ($G$)**: The high-$k$ tail is defined by $|k| \\geq \\beta k_{\\mathrm{N}} = 0.85 \\times 128 = 108.8$. We use modes with integer $|k| \\ge 109$.\n  - Tail KE at time $t$: $K^{\\mathrm{tail}}(t)$ is the sum of $\\frac{1}{2} \\frac{\\Delta x}{N} k^2 |\\hat{\\psi}(k,t)|^2$ over modes in the tail.\n  - Growth Factor: $G = K^{\\mathrm{tail}}(T) / (K^{\\mathrm{tail}}(0) + \\varepsilon)$ with $\\varepsilon=10^{-12}$.\n- **High-$k$ Spectral Upturn (Slope)**: The one-dimensional shell spectrum $S(k_{shell}) = |\\hat{\\psi}(k_{shell})|^2 + |\\hat{\\psi}(-k_{shell})|^2$ for $k_{shell} > 0$ is formed. We find the last $M=8$ non-zero values of $S(k)$ for $k$ approaching $k_{\\mathrm{N}}$ and perform a linear least-squares fit of $\\log(S(k))$ versus $k$ to find the slope. A positive slope indicates an unphysical pile-up of energy.\n\nThe composite aliasing detector returns `True` if at least two of these conditions are met: $G > 50$, $D > 0.02$, and slope $ > 0$. The implementation will execute this logic for each of the four test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D cubic NLSE using a split-step Fourier method and\n    evaluates aliasing based on several diagnostics.\n    \"\"\"\n\n    def run_simulation(g_val, alpha, L, N, T, dt):\n        \"\"\"\n        Performs a single simulation run for a given set of parameters.\n\n        Args:\n            g_val (float): Nonlinear coupling constant.\n            alpha (float): Dealiasing filter factor (1, 2/3, or 1/3).\n            L (float): Domain length.\n            N (int): Number of grid points.\n            T (float): Total simulation time.\n            dt (float): Time step.\n\n        Returns:\n            tuple: A tuple containing the diagnostics (G, D, tail_slope).\n        \"\"\"\n        # Grid and wavenumber setup\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        k = np.fft.fftfreq(N) * N\n\n        k_sq = k**2\n        k_N = N / 2\n\n        # Initial condition\n        k1, k2 = 8, 12\n        A_analytic = 1.0 / np.sqrt(4 * np.pi)\n        psi0_func = A_analytic * (np.exp(1j * k1 * x) + np.exp(1j * k2 * x))\n        \n        # Normalize discretely for consistency\n        norm_initial_sq = np.sum(np.abs(psi0_func)**2) * dx\n        psi0 = psi0_func / np.sqrt(norm_initial_sq)\n        \n        psi = psi0.copy()\n        psi_hat = np.fft.fft(psi)\n\n        # Calculate initial energy\n        ke0 = (dx / N) * 0.5 * np.sum(k_sq * np.abs(psi_hat)**2)\n        pe0 = (g_val / 2) * dx * np.sum(np.abs(psi)**4)\n        E0 = ke0 + pe0\n        if np.isclose(E0, 0): E0 = 1.0 # Avoid division by zero for g=0 case\n\n        # Calculate initial tail kinetic energy\n        beta = 0.85\n        tail_mask = np.abs(k) >= beta * k_N\n        ke_tail_0 = (dx / N) * 0.5 * np.sum(k_sq[tail_mask] * np.abs(psi_hat[tail_mask])**2)\n\n        # Time-stepping loop\n        num_steps = int(round(T / dt))\n        linear_propagator_half = np.exp(-0.5j * k_sq * (dt / 2.0))\n        dealias_mask = np.abs(k) = alpha * k_N\n\n        for step in range(num_steps):\n            # First linear half-step\n            psi_hat *= linear_propagator_half\n\n            # Nonlinear full-step\n            psi_temp = np.fft.ifft(psi_hat)\n            \n            # Dealiasing for density calculation\n            psi_hat_filtered = psi_hat * dealias_mask\n            psi_filtered = np.fft.ifft(psi_hat_filtered)\n\n            rho = np.abs(psi_filtered)**2\n            nonlinear_propagator = np.exp(-1j * g_val * rho * dt)\n            psi = psi_temp * nonlinear_propagator\n\n            psi_hat = np.fft.fft(psi)\n            \n            # Second linear half-step\n            psi_hat *= linear_propagator_half\n\n        psi_final = np.fft.ifft(psi_hat)\n\n        # ---- Calculate final diagnostics ----\n\n        # 1. Tail kinetic energy growth (G)\n        ke_tail_T = (dx / N) * 0.5 * np.sum(k_sq[tail_mask] * np.abs(psi_hat[tail_mask])**2)\n        epsilon = 1e-12\n        G = ke_tail_T / (ke_tail_0 + epsilon)\n\n        # 2. Total energy drift (D)\n        keT = (dx / N) * 0.5 * np.sum(k_sq * np.abs(psi_hat)**2)\n        peT = (g_val / 2) * dx * np.sum(np.abs(psi_final)**4)\n        ET = keT + peT\n        D = np.abs(ET - E0) / np.abs(E0)\n\n        # 3. High-k spectral upturn (slope)\n        M = 8\n        power_spectrum = np.abs(psi_hat)**2\n        \n        # Symmetrized 1D shell spectrum for k > 0\n        k_pos = k[1:N//2]\n        shell_spec = power_spectrum[1:N//2] + power_spectrum[N-1:N//2:-1]\n\n        # Find last M non-zero shells to fit\n        non_zero_indices = np.where(shell_spec > 1e-30)[0] # Use a small threshold\n        if len(non_zero_indices) >= M:\n            fit_indices = non_zero_indices[-M:]\n            k_fit = k_pos[fit_indices]\n            log_spec_fit = np.log(shell_spec[fit_indices])\n            \n            # Perform linear fit: log(P) = slope * k + intercept\n            slope, _ = np.polyfit(k_fit, log_spec_fit, 1)\n        else:\n            slope = -np.inf # No upturn if spectrum decays too fast\n\n        return G, D, tail_slope\n\n    # Fixed numerical parameters\n    L_param = 2 * np.pi\n    N_param = 256\n    T_param = 0.8\n    dt_param = 1e-3\n\n    # Thresholds for aliasing detector\n    G_thr = 50.0\n    D_thr = 0.02\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (g, alpha)\n        (20.0, 1.0),            # Case 1: No dealiasing\n        (20.0, 2.0 / 3.0),      # Case 2: 2/3 rule (insufficient for cubic)\n        (20.0, 1.0 / 3.0),      # Case 3: 1/3 rule (sufficient for cubic)\n        (0.0, 1.0)              # Case 4: Linear evolution (control)\n    ]\n\n    results = []\n    for g, alpha in test_cases:\n        G, D, tail_slope = run_simulation(g, alpha, L_param, N_param, T_param, dt_param)\n\n        # Composite aliasing detector\n        cond1 = G > G_thr\n        cond2 = D > D_thr\n        cond3 = tail_slope > 0\n        \n        aliasing_detected = (int(cond1) + int(cond2) + int(cond3)) >= 2\n        results.append(aliasing_detected)\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}