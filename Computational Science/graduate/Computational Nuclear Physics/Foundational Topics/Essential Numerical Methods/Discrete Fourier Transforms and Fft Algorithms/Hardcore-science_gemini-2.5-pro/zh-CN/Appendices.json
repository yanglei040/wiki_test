{
    "hands_on_practices": [
        {
            "introduction": "在计算科学中，任何数值工具的正确性都是开展可靠研究的基石，对于像快速傅里叶变换 (FFT) 这样基础的算法尤其如此。本练习旨在通过一个经典的解析基准来建立验证数值代码正确性的核心技能。你将利用高斯波包的傅里叶变换仍然是高斯函数这一优美特性，设计一个单元测试来量化评估你的FFT实现的精度，这包括对振幅和相位的严格检验，从而确保你的计算工具是值得信赖的。通过这个实践 ，你不仅能加深对连续变换与离散变换之间关系的理解，还将掌握处理频率排序和相位展开等实际问题的关键技术。",
            "id": "3556144",
            "problem": "设计并实现一个完全独立的数值单元测试，通过将采样高斯波包的离散傅里叶变换与其解析连续傅里叶变换进行比较，来验证快速傅里叶变换 (FFT) 实现的正确性。其背景是计算核物理中使用的动量空间变换，其中空间坐标以飞米 (femtometer) 为单位，共轭动量（波数）以反飞米 (inverse femtometer) 为单位。您的程序必须计算振幅和相位精度指标，并为一组参数集测试套件报告这些指标。\n\n从以下基本基础开始：\n- 根据惯例定义连续傅里叶变换 $F(k) = \\int_{-\\infty}^{\\infty} f(x)\\,e^{-i k x}\\,dx$ 及其逆变换 $f(x) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} F(k)\\,e^{i k x}\\,dk$，其中 $k$ 是角波数，单位为 $\\mathrm{fm}^{-1}$，$x$ 是位置，单位为 $\\mathrm{fm}$，角度以弧度为单位。\n- 在具有间距 $dx$ 的 $N$ 个点的均匀网格上，对连续变换的离散近似为 $F(k_m) \\approx dx \\sum_{n=0}^{N-1} f(x_n)\\,e^{-i k_m x_n}$，其中 $x_n = n\\,dx$，对于由离散傅里叶变换生成的频率网格上的整数 $m$，$k_m = 2\\pi\\,m/(N\\,dx)$。这使用数值快速傅里叶变换算法来有效评估离散和。\n\n考虑高斯波包\n$$\nf(x) = A \\exp\\!\\left(-\\frac{(x - x_0)^2}{2\\sigma^2}\\right)\\exp(i k_0 x),\n$$\n其真实参数为 $A$ (无量纲振幅)、$\\sigma$ (宽度，单位为 $\\mathrm{fm}$)、$x_0$ (位移，单位为 $\\mathrm{fm}$) 和 $k_0$ (载波，单位为 $\\mathrm{fm}^{-1}$)。使用高斯积分 $\\int_{-\\infty}^{\\infty} e^{-a y^2 + b y}\\,dy = \\sqrt{\\frac{\\pi}{a}}\\,e^{b^2/(4a)}$ (对于 $\\Re(a)  0$)，可得出精确的连续傅里叶变换是另一个关于 $k$ 的具有线性相位的高斯函数：\n$$\nF_{\\mathrm{analytic}}(k) = A \\sqrt{2\\pi}\\,\\sigma \\exp\\!\\left(-\\frac{\\sigma^2 (k - k_0)^2}{2}\\right)\\exp\\!\\left(i (k_0 - k) x_0\\right).\n$$\n因此，振幅包络为 $|F_{\\mathrm{analytic}}(k)| = A \\sqrt{2\\pi}\\,\\sigma \\exp\\!\\left(-\\frac{\\sigma^2 (k - k_0)^2}{2}\\right)$，相位为 $\\arg F_{\\mathrm{analytic}}(k) = (k_0 - k)x_0$。\n\n您的任务是：\n1. 使用快速傅里叶变换和离散频率网格 $k_m = 2\\pi\\,m/(N\\,dx)$（其中 $m$ 由标准 FFT 频率生成器返回）实现离散近似 $F_{\\mathrm{FFT}}(k_m) = dx \\sum_{n=0}^{N-1} f(x_n)\\,e^{-i k_m x_n}$。使用 $x_n = n\\,dx$ (对于 $n = 0,1,\\dots,N-1$)。确保 $dx$ 的单位是 $\\mathrm{fm}$，$k$ 的单位是 $\\mathrm{fm}^{-1}$，角度以弧度为单位。\n2. 在相同的离散 $k_m$ 网格上计算解析变换 $F_{\\mathrm{analytic}}(k_m)$。\n3. 将振幅精度指标定义为在解析振幅不可忽略的 $k_m$ 子集上的最大相对误差：\n$$\n\\varepsilon_{\\mathrm{amp}} = \\max_{m \\in \\mathcal{M}} \\frac{\\left|\\left|F_{\\mathrm{FFT}}(k_m)\\right| - \\left|F_{\\mathrm{analytic}}(k_m)\\right|\\right|}{\\left|F_{\\mathrm{analytic}}(k_m)\\right|},\n$$\n其中 $\\mathcal{M} = \\{ m : |F_{\\mathrm{analytic}}(k_m)| \\ge \\eta \\,\\max_{m'} |F_{\\mathrm{analytic}}(k_{m'})| \\}$ 且 $\\eta$ 是一个为避免除以由数值噪声主导的数而选择的小截止值。使用 $\\eta = 10^{-6}$。\n4. 将相位精度指标定义为在同一集合 $\\mathcal{M}$ 上，数值变换与解析变换之间相位差的均方根误差：\n$$\n\\varepsilon_{\\mathrm{phase}} = \\sqrt{\\frac{1}{|\\mathcal{M}|}\\sum_{m \\in \\mathcal{M}} \\Delta\\phi_m^2}, \\quad \\Delta\\phi_m = \\mathrm{unwrap}\\!\\left(\\arg\\left(\\frac{F_{\\mathrm{FFT}}(k_m)}{F_{\\mathrm{analytic}}(k_m)}\\right)\\right),\n$$\n其中 $\\mathrm{unwrap}$ 表示以弧度为单位的连续相位展开，以消除 $2\\pi$ 的跳变。角度必须以弧度为单位。\n5. 对于每个测试用例，将 $\\varepsilon_{\\mathrm{amp}}$ 和 $\\varepsilon_{\\mathrm{phase}}$ 分别与容差 $\\tau_{\\mathrm{amp}} = 10^{-2}$ 和 $\\tau_{\\mathrm{phase}} = 10^{-2}$ 进行比较，并记录布尔值的通过/失败值 $p_{\\mathrm{amp}} = (\\varepsilon_{\\mathrm{amp}} \\le \\tau_{\\mathrm{amp}})$ 和 $p_{\\mathrm{phase}} = (\\varepsilon_{\\mathrm{phase}} \\le \\tau_{\\mathrm{phase}})$。\n\n实现程序，为以下参数集测试套件计算这些指标，这些测试套件旨在探测与坐标空间和动量空间之间的计算核物理变换相关的精度、分辨率和边缘条件：\n- 测试 $1$：$N = 2048$，$dx = 0.05\\,\\mathrm{fm}$，$\\sigma = 2.0\\,\\mathrm{fm}$，$A = 1.3$，$x_0 = 10.0\\,\\mathrm{fm}$，$k_0 = 0.6\\,\\mathrm{fm}^{-1}$。\n- 测试 $2$：$N = 1024$，$dx = 0.10\\,\\mathrm{fm}$，$\\sigma = 0.5\\,\\mathrm{fm}$，$A = 0.9$，$x_0 = 30.0\\,\\mathrm{fm}$，$k_0 = 0.0\\,\\mathrm{fm}^{-1}$。\n- 测试 $3$：$N = 1024$，$dx = 0.10\\,\\mathrm{fm}$，$\\sigma = 3.0\\,\\mathrm{fm}$，$A = 0.7$，$x_0 = 5.0\\,\\mathrm{fm}$，$k_0 = 0.8\\,\\pi/dx \\approx 25.132741\\,\\mathrm{fm}^{-1}$。\n- 测试 $4$：$N = 2048$，$dx = 0.05\\,\\mathrm{fm}$，$\\sigma = 0.2\\,\\mathrm{fm}$，$A = 1.0$，$x_0 = 2.0\\,\\mathrm{fm}$，$k_0 = 1.5\\,\\mathrm{fm}^{-1}$。\n\n所有角度单位必须是弧度。所有计算都必须以双精度进行。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个 Python 风格的列表，每个测试用例贡献一个包含四个条目的子列表，顺序为 $[\\varepsilon_{\\mathrm{amp}}, \\varepsilon_{\\mathrm{phase}}, p_{\\mathrm{amp}}, p_{\\mathrm{phase}}]$。例如，整体输出应类似于 $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$，其中 $a_j$ 和 $b_j$ 是浮点数，$c_j$ 和 $d_j$ 是布尔值。",
            "solution": "用户提供的问题陈述经分析和验证，是科学上合理、定义明确且客观的。它构成了计算物理学中一个有效且有意义的练习。任务是创建一个数值单元测试，用一个解析已知的傅里叶变换对来验证快速傅里叶变换 (FFT) 的实现。测试用例是一个高斯波包，这是物理学中一个标准且基本的模型。该问题详细说明了所有必要的物理和数值参数、误差度量定义以及测试用例。\n\n解决此问题的方法论步骤如下：\n\n首先，我们通过 FFT 算法建立连续傅里叶变换与其离散近似之间的基本关系。连续傅里叶变换积分通过有限网格上的离散和来近似。问题将此近似表述为 $F(k_m) \\approx dx \\sum_{n=0}^{N-1} f(x_n)\\,e^{-i k_m x_n}$。和 $\\sum_{n=0}^{N-1} f(x_n)\\,e^{-i 2\\pi m n / N}$ 是离散傅里叶变换 (DFT) 的标准定义，它通过 FFT 算法得到高效计算。给定空间网格 $x_n = n\\,dx$ 和波数网格 $k_m = 2\\pi m / (N\\,dx)$ 之间的指定关系，我们可以确认离散和等同于 DFT 的定义。因此，变换的数值近似为 $F_{\\mathrm{FFT}}(k_m) = dx \\cdot \\mathrm{FFT}[f(x_n)]_m$。\n\n解决方案的核心涉及每个测试用例的以下步骤顺序：\n\n1.  **网格生成**：将创建一个均匀的空间网格 $x_n = n \\cdot dx$（对于 $n = 0, \\ldots, N-1$）。相应的角波数网格 $k_m$ 将使用 `numpy.fft.fftfreq` 函数生成，并乘以 $2\\pi$ 以将频率（单位距离的周期数）转换为角波数（单位距离的弧度数）。所有计算将使用双精度浮点数（`np.float64` 和 `np.complex128`）。\n\n2.  **波包采样**：将在离散空间网格 $x_n$ 上对连续高斯波包函数 $f(x) = A \\exp(-\\frac{(x - x_0)^2}{2\\sigma^2})\\exp(i k_0 x)$ 进行采样，以生成 FFT 的输入数组。\n\n3.  **数值变换 (FFT)**：将使用 `numpy.fft.fft` 计算采样波包的 FFT。结果将乘以空间网格间距 $dx$ 以获得 $F_{\\mathrm{FFT}}(k_m)$。\n\n4.  **解析变换**：将在离散波数网格 $k_m$ 上评估精确的解析傅里叶变换 $F_{\\mathrm{analytic}}(k) = A \\sqrt{2\\pi}\\,\\sigma \\exp(-\\frac{\\sigma^2 (k - k_0)^2}{2})\\exp(i (k_0 - k) x_0)$。\n\n5.  **频率排序**：比较中的一个关键步骤，尤其是对于相位，是确保变换沿着单调递增的频率轴进行处理。FFT 算法的标准输出将频率从零排序到正奈奎斯特频率，然后是负频率。这种非单调排序可能会导致相位展开问题。为了纠正这一点，波数网格 $k_m$ 和数值变换 $F_{\\mathrm{FFT}}(k_m)$ 都将使用 `numpy.fft.fftshift`进行重排。此函数将零频率分量居中，从而得到一个从负到正波数的单调有序网格。解析变换将直接在这个移位的单调网格上计算。\n\n6.  **误差度量计算**：\n    a.  将创建一个对应于集合 $\\mathcal{M}$ 的布尔掩码。此掩码标识解析变换振幅显著的波数 $k_m$，定义为大于或等于最大解析振幅的一小部分 $\\eta=10^{-6}$。这可以防止因除以零或接近零的值而引起的数值不稳定性。\n    b.  振幅精度指标 $\\varepsilon_{\\mathrm{amp}}$ 将计算为在掩码 $\\mathcal{M}$ 定义的域上，数值变换和解析变换振幅之间的最大相对误差。\n    c.  将计算相位精度指标 $\\varepsilon_{\\mathrm{phase}}$。相位差是根据在 $\\mathcal{M}$ 内各点的复数比率 $F_{\\mathrm{FFT}}(k_m) / F_{\\mathrm{analytic}}(k_m)$ 的辐角计算的。然后应用 `numpy.unwrap` 函数于此相位差序列，以校正 $2\\pi$ 不连续性，得到 $\\Delta\\phi_m$。最后，计算这些展开后相位差的均方根 (RMS) 以获得 $\\varepsilon_{\\mathrm{phase}}$。\n\n7.  **验证**：计算出的误差指标 $\\varepsilon_{\\mathrm{amp}}$ 和 $\\varepsilon_{\\mathrm{phase}}$ 将与其各自的容差 $\\tau_{\\mathrm{amp}} = 10^{-2}$ 和 $\\tau_{\\mathrm{phase}} = 10^{-2}$进行比较。结果将决定布尔值的通过/失败标志 $p_{\\mathrm{amp}}$ 和 $p_{\\mathrm{phase}}$。\n\n此过程将对问题陈述中提供的四个参数集中的每一个执行。结果（包括每个测试的两个误差指标和两个布尔标志）将被收集并格式化为指定的输出字符串，该字符串表示一个 Python 列表的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the FFT validation test suite and print results.\n    \"\"\"\n\n    def run_fft_validation_test(N, dx, sigma, A, x_0, k_0, eta, tau_amp, tau_phase):\n        \"\"\"\n        Performs a single validation test for the FFT against the analytic\n        Fourier transform of a Gaussian wave packet.\n\n        Args:\n            N (int): Number of sample points.\n            dx (float): Spatial grid spacing in fm.\n            sigma (float): Width of the Gaussian wave packet in fm.\n            A (float): Dimensionless amplitude of the wave packet.\n            x_0 (float): Center of the wave packet in fm.\n            k_0 (float): Carrier wave number in fm^-1.\n            eta (float): Cutoff for significant amplitude region.\n            tau_amp (float): Tolerance for amplitude error.\n            tau_phase (float): Tolerance for phase error.\n\n        Returns:\n            list: A list containing [eps_amp, eps_phase, p_amp, p_phase].\n        \"\"\"\n        # 1. Define Grids\n        # Spatial grid\n        x_n = np.arange(N, dtype=np.float64) * dx\n        # Angular wave number grid\n        k_m = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n        # 2. Sample the Gaussian wave packet in position space\n        f_x = A * np.exp(-(x_n - x_0)**2 / (2 * sigma**2)) * np.exp(1j * k_0 * x_n)\n        f_x = f_x.astype(np.complex128)\n\n        # 3. Compute the numerical transform using FFT\n        # The factor dx scales the DFT sum to approximate the continuous integral\n        F_fft = dx * np.fft.fft(f_x)\n\n        # 4. Shift grids for monotonic frequency axis for correct phase unwrapping\n        k_m_shifted = np.fft.fftshift(k_m)\n        F_fft_shifted = np.fft.fftshift(F_fft)\n\n        # 5. Compute the analytic transform on the shifted (monotonic) k-grid\n        F_analytic_shifted = (A * np.sqrt(2 * np.pi) * sigma *\n                              np.exp(-sigma**2 * (k_m_shifted - k_0)**2 / 2) *\n                              np.exp(1j * (k_0 - k_m_shifted) * x_0))\n        F_analytic_shifted = F_analytic_shifted.astype(np.complex128)\n\n        # 6. Define the region M where the analytic amplitude is significant\n        amp_analytic = np.abs(F_analytic_shifted)\n        amp_max = np.max(amp_analytic)\n        mask = amp_analytic >= eta * amp_max\n\n        # Ensure mask is not empty to avoid errors in max/mean\n        if not np.any(mask):\n            eps_amp = np.inf\n            eps_phase = np.inf\n        else:\n            # 7. Compute amplitude accuracy metric (eps_amp)\n            amp_fft_shifted = np.abs(F_fft_shifted)\n            # We only evaluate the error where amplitude is significant\n            rel_err_amp_masked = (np.abs(amp_fft_shifted[mask] - amp_analytic[mask]) / \n                                  amp_analytic[mask])\n            eps_amp = np.max(rel_err_amp_masked)\n\n            # 8. Compute phase accuracy metric (eps_phase)\n            # Phase difference is taken from the argument of the ratio\n            ratio_masked = F_fft_shifted[mask] / F_analytic_shifted[mask]\n            \n            # Unwrap the phase difference to handle 2*pi jumps\n            phase_diff_raw = np.angle(ratio_masked)\n            phase_diff_unwrapped = np.unwrap(phase_diff_raw)\n            \n            # RMS of the unwrapped phase difference\n            eps_phase = np.sqrt(np.mean(phase_diff_unwrapped**2))\n\n        # 9. Compare against tolerances to get pass/fail booleans\n        p_amp = bool(eps_amp = tau_amp)\n        p_phase = bool(eps_phase = tau_phase)\n\n        return [eps_amp, eps_phase, p_amp, p_phase]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1\n        {'N': 2048, 'dx': 0.05, 'sigma': 2.0, 'A': 1.3, 'x_0': 10.0, 'k_0': 0.6},\n        # Test 2\n        {'N': 1024, 'dx': 0.10, 'sigma': 0.5, 'A': 0.9, 'x_0': 30.0, 'k_0': 0.0},\n        # Test 3\n        {'N': 1024, 'dx': 0.10, 'sigma': 3.0, 'A': 0.7, 'x_0': 5.0, 'k_0': 0.8 * np.pi / 0.10},\n        # Test 4\n        {'N': 2048, 'dx': 0.05, 'sigma': 0.2, 'A': 1.0, 'x_0': 2.0, 'k_0': 1.5},\n    ]\n\n    # Constants for metric calculation\n    eta = 1e-6\n    tau_amp = 1e-2\n    tau_phase = 1e-2\n\n    results = []\n    for case_params in test_cases:\n        result = run_fft_validation_test(\n            N=case_params['N'],\n            dx=case_params['dx'],\n            sigma=case_params['sigma'],\n            A=case_params['A'],\n            x_0=case_params['x_0'],\n            k_0=case_params['k_0'],\n            eta=eta,\n            tau_amp=tau_amp,\n            tau_phase=tau_phase\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format [[a,b,c,d],[e,f,g,h]] requires generating string representations\n    # of the inner lists and joining them. str() of a list includes spaces,\n    # so they are removed to match the implied format.\n    sublist_strs = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(sublist_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在验证了FFT工具的准确性之后，我们转向一个更高级的应用：利用它作为求解偏微分方程的强大引擎。本练习将引导你使用傅里叶空间中的格林函数方法，来求解量子力学和核物理中的一个核心方程——非齐次薛定谔方程。你将学到，通过傅里叶变换，复杂的微分算符 $\\nabla^2$ 如何简化为代数乘积 $-k^2$，从而将一个偏微分方程转化为一个简单的代数问题。此过程还将引入一个关键的物理概念：通过给能量增加一个小的虚部 $E \\to E + i\\eta$ 来正则化格林函数中的奇点，这对应于在散射问题中选择正确的出射波边界条件。这项实践  深刻地揭示了卷积定理的威力，并将抽象的FFT算法与一个广泛适用的物理问题求解技术直接联系起来。",
            "id": "3556238",
            "problem": "考虑三维空间中的时间无关非齐次薛定谔方程，\n$$\n(E - H)\\,\\psi(\\mathbf{r}) = S(\\mathbf{r}),\n$$\n其中 $E$ 是一个实标量能量参数，$H$ 是哈密顿算符，$\\psi(\\mathbf{r})$ 是复值波场，$S(\\mathbf{r})$ 是一个给定的源项。在没有外势的均匀介质中，将哈密顿算符仅取为动能算符，\n$$\nH = -\\nabla^2,\n$$\n在一个无量纲体系中，$\\hbar^2/(2m) = 1$，因此所有量都是无量纲的。计算域是一个边长为 $L=2\\pi$ 的立方体，具有周期性边界条件，并在一个 $N \\times N \\times N$（其中 $N=32$）的均匀笛卡尔网格上进行离散化。设源项为一个局域各向同性高斯函数，\n$$\nS(\\mathbf{r}) = A \\exp\\!\\left(-\\frac{\\|\\mathbf{r}\\|^2}{2\\sigma^2}\\right),\n$$\n其振幅 $A=1$，宽度参数 $\\sigma0$。角度和角波数应以弧度为单位。\n\n您的任务是使用通过快速傅里叶变换 (FFT) 求值的傅里叶域格林函数，对上述方程进行数值求解。格林函数在 $k^2=E$ 处有一个奇异点，其中 $k^2 = k_x^2+k_y^2+k_z^2$ 是角波数的平方。为了对该奇异点进行正则化，并从散射理论的意义上选择具有物理意义的出射解，我们执行标准的复能量移 $E \\to E + i\\eta$，其中 $\\eta0$。\n\n您的程序必须以数学上一致的方式实现以下步骤：\n- 使用指定的 $L$ 和 $N$，在以原点为中心的周期性网格上构建三维 (3D) 源项 $S(\\mathbf{r})$。\n- 使用通过 FFT 计算的离散傅里叶变换 (DFT) 将源项映射到傅里叶空间。确定网格上与周期性域和所选离散化一致的角波数。\n- 通过应用带有复数位移 $E\\to E+i\\eta$ 的格林函数来正则化极点，从而形成傅里叶域解，确保所有操作在数值上都是良定的。\n- 将解变换回实空间。从得到的 $\\psi(\\mathbf{r})$ 中，提取空间原点 $\\mathbf{r}=\\mathbf{0}$ 处 $\\psi(\\mathbf{0})$ 的实部。\n\n测试套件：\n使用 $L=2\\pi$、$N=32$ 和 $A=1$。对于以下每一组参数 $(E,\\eta,\\sigma)$，计算原点处解的实部 $\\operatorname{Re}[\\psi(\\mathbf{0})]$，结果为一个浮点数：\n1. $(E,\\eta,\\sigma) = (1.0, 0.05, 0.40)$\n2. $(E,\\eta,\\sigma) = (1.0, 10^{-6}, 0.20)$\n3. $(E,\\eta,\\sigma) = (0.0, 0.05, 0.30)$\n4. $(E,\\eta,\\sigma) = (-0.5, 0.05, 0.50)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4]”）。该列表应按上面列出的顺序包含四个测试用例的 $\\operatorname{Re}[\\psi(\\mathbf{0})]$ 值。所有输出均为无量纲实数。",
            "solution": "该问题在科学和数学上是合理的、良定的，并包含了获得唯一解所需的所有信息。因此，我们可以继续进行推导和实现。\n\n该问题要求在没有外势的三维均匀介质中，数值求解时间无关的非齐次薛定谔方程。在给定的无量纲单位下，该方程为\n$$\n(E - H)\\,\\psi(\\mathbf{r}) = S(\\mathbf{r})\n$$\n其中哈密顿算符 $H$ 是纯动能项，$H = -\\nabla^2$。因此，该方程具有非齐次亥姆霍兹方程的形式：\n$$\n(\\nabla^2 + E)\\,\\psi(\\mathbf{r}) = -S(\\mathbf{r})\n$$\n计算域是一个边长为 $L=2\\pi$ 的立方体，具有周期性边界条件，并在一个 $N \\times N \\times N$（其中 $N=32$）的均匀笛卡尔网格上进行离散化。源项 $S(\\mathbf{r})$ 是一个以原点为中心的、给定的各向同性高斯函数。\n\n这种具有常系数的线性偏微分方程非常适合在傅里叶域中求解，因为它利用了傅里叶变换能够将微分算符 $\\nabla^2$ 对角化这一事实。令 $\\tilde{f}(\\mathbf{k}) = \\mathcal{F}[f(\\mathbf{r})]$ 表示函数 $f(\\mathbf{r})$ 的傅里叶变换。对该方程应用傅里叶变换可得：\n$$\n\\mathcal{F}[(\\nabla^2 + E)\\,\\psi(\\mathbf{r})] = \\mathcal{F}[-S(\\mathbf{r})]\n$$\n利用性质 $\\mathcal{F}[\\nabla^2 f(\\mathbf{r})] = -\\|\\mathbf{k}\\|^2 \\tilde{f}(\\mathbf{k})$，其中 $\\mathbf{k}=(k_x, k_y, k_z)$ 是角波矢量，$k^2 = \\|\\mathbf{k}\\|^2 = k_x^2 + k_y^2 + k_z^2$ 是其模的平方，方程在傅里叶空间中变为一个代数方程：\n$$\n(-k^2 + E)\\,\\tilde{\\psi}(\\mathbf{k}) = -\\tilde{S}(\\mathbf{k})\n$$\n我们可以解出波场的傅里叶变换 $\\tilde{\\psi}(\\mathbf{k})$：\n$$\n\\tilde{\\psi}(\\mathbf{k}) = \\frac{\\tilde{S}(\\mathbf{k})}{E - k^2}\n$$\n项 $\\tilde{G}(\\mathbf{k}) = 1/(E - k^2)$ 是傅里叶域中的格林函数。然后通过傅里叶逆变换得到实空间中的解 $\\psi(\\mathbf{r})$：\n$$\n\\psi(\\mathbf{r}) = \\mathcal{F}^{-1}[\\tilde{\\psi}(\\mathbf{k})] = \\mathcal{F}^{-1}\\left[ \\frac{\\tilde{S}(\\mathbf{k})}{E - k^2} \\right]\n$$\n当能量参数 $E$ 为正时，会出现一个关键问题，因为对于位于半径为 $\\sqrt{E}$ 的球面上的波矢量 $\\mathbf{k}$，分母 $E-k^2$ 可能为零。这导致了一个不可积的奇异点，解是病态的。为了获得散射理论中所要求的、具有物理意义的出射波解，我们通过为能量引入一个小的虚部来对该奇异点进行正则化，$E \\to E + i\\eta$，其中 $\\eta$ 是一个小的正实数。这个过程被称为极限吸收原理，它将格林函数的极点移出实轴，从而确保积分是良定的。傅里叶空间中的正则化解为：\n$$\n\\tilde{\\psi}(\\mathbf{k}) = \\frac{\\tilde{S}(\\mathbf{k})}{E + i\\eta - k^2}\n$$\n数值解涉及将此连续形式离散化。\n\n**使用快速傅里叶变换 (FFT) 的数值实现**\n\n1.  **网格与波数离散化：** 计算域是一个边长为 $L=2\\pi$ 的立方体，每个轴上有 $N=32$ 个点。网格间距为 $\\Delta x = L/N = 2\\pi/32 = \\pi/16$。由于周期性边界条件，允许的角波数是离散的。对于给定的轴，波数为 $k_j = 2\\pi n_j / L$，其中 $n_j$ 是整数。对于偶数 $N$，与标准 FFT 排序相对应的整数集合是 $n_j \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$。在 $L=2\\pi$ 的特定情况下，波数简化为整数本身，$k_j = n_j$。我们为波矢量分量 $(k_x, k_y, k_z)$ 构建三维网格，并计算离散傅里叶空间中每个点的模平方 $k^2 = k_x^2 + k_y^2 + k_z^2$。\n\n2.  **源项构造：** 源项是一个以原点为中心的各向同性高斯函数，$S(\\mathbf{r}) = A \\exp(-\\|\\mathbf{r}\\|^2 / (2\\sigma^2))$，其中 $A=1$。在离散网格上，我们必须计算从原点到每个网格点 $(x_i, y_j, z_l)$ 的距离 $\\|\\mathbf{r}\\|$，同时要遵守周期性边界条件。对于索引为 $(i,j,l)$ 的网格点，从原点出发的位移矢量可以用环绕周期性域的坐标表示，即值在 $[-L/2, L/2)$ 范围内。使用与 FFT 频率排序相匹配的坐标表示最为方便。对于每个维度，坐标矢量由 $x_n = L \\times \\text{fftfreq}(N)$ 给出，对于 $L=2\\pi$，这简化为 $x_n = 2\\pi \\times \\{0, 1/N, \\dots, -1/N\\}$。我们使用此方案生成三维坐标数组 $(X, Y, Z)$，并计算距离的平方 $r^2 = X^2 + Y^2 + Z^2$ 来构建源数组 $S_{ijk}$。\n\n3.  **算法步骤：**\n    a. 如上所述，在网格上构建源项 $S(\\mathbf{r})$ 的 $N \\times N \\times N$ 数组。\n    b. 使用 FFT 算法 (`numpy.fft.fftn`) 计算源数组的三维离散傅里叶变换 (DFT)，得到 $\\tilde{S}(\\mathbf{k})$。\n    c. 构建波数平方 $k^2$ 的 $N \\times N \\times N$ 数组。\n    d. 对于离散傅里叶空间中的每个点，计算傅里叶域解 $\\tilde{\\psi}(\\mathbf{k}) = \\tilde{S}(\\mathbf{k}) / (E + i\\eta - k^2)$。\n    e. 使用逆 FFT 算法 (`numpy.fft.ifftn`) 计算 $\\tilde{\\psi}(\\mathbf{k})$ 的三维逆 DFT，以获得实空间网格上的解 $\\psi(\\mathbf{r})$。\n    f. 提取原点处解的实部 $\\operatorname{Re}[\\psi(\\mathbf{r}=\\mathbf{0})]$。在我们的离散设置中，原点对应于索引为 $(0,0,0)$ 的网格点。\n\n对测试套件中提供的每一组参数 $(E, \\eta, \\sigma)$ 执行此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the inhomogeneous Schrödinger equation in 3D on a periodic grid\n    using a Fourier-space Green's function method.\n    \"\"\"\n\n    def compute_psi0_real(E, eta, sigma, L=2 * np.pi, N=32, A=1):\n        \"\"\"\n        Computes the real part of the wavefield at the origin for a given\n        set of parameters.\n\n        Args:\n            E (float): Energy parameter.\n            eta (float): Regularization parameter for the complex energy shift.\n            sigma (float): Width of the Gaussian source.\n            L (float): Side length of the cubic domain.\n            N (int): Number of grid points along each dimension.\n            A (float): Amplitude of the source.\n\n        Returns:\n            float: The value of Re[psi(0)].\n        \"\"\"\n        # 1. Construct the real-space grid coordinates that align with FFT ordering.\n        # This represents the displacement from the origin on a periodic grid.\n        # coords_1d = L * np.fft.fftfreq(N) gives coordinates in [-L/2, L/2)\n        # corresponding to FFT indices [0, 1, ..., N/2-1, -N/2, ..., -1].\n        coords_1d = L * np.fft.fftfreq(N)\n        X, Y, Z = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n\n        # Calculate the squared distance from the origin for each grid point.\n        r_sq = X**2 + Y**2 + Z**2\n\n        # 2. Construct the source term S(r) on the grid.\n        # S(r) = A * exp(-r^2 / (2*sigma^2))\n        S_r = A * np.exp(-r_sq / (2 * sigma**2))\n\n        # 3. Compute the 3D Fast Fourier Transform of the source.\n        S_k = np.fft.fftn(S_r)\n\n        # 4. Construct the wavenumber grid in Fourier space.\n        # For L=2*pi, the angular wavenumbers are integers.\n        # k_1d = 2 * pi * np.fft.fftfreq(N, d=L/N) = integers.\n        k_1d = N * np.fft.fftfreq(N)\n        kx, ky, kz = np.meshgrid(k_1d, k_1d, k_1d, indexing='ij')\n\n        # Calculate the squared magnitude of the wavevector k.\n        k_sq = kx**2 + ky**2 + kz**2\n\n        # 5. Apply the regularized Green's function in Fourier space.\n        # The denominator is E + i*eta - k^2. A complex number is used for E.\n        E_complex = E + 1j * eta\n        \n        # The Green's function is G(k) = 1 / (E_complex - k^2)\n        # We compute psi(k) = S(k) * G(k)\n        # To avoid division by zero (though unlikely with eta>0), handle k^2=E_complex case if needed.\n        # The problem statement ensures eta > 0, so the denominator is never zero for real E.\n        psi_k = S_k / (E_complex - k_sq)\n\n        # 6. Compute the inverse 3D FFT to get the solution in real space.\n        psi_r = np.fft.ifftn(psi_k)\n\n        # 7. Extract the real part of the solution at the origin (r=0),\n        # which corresponds to the first element of the array (index 0,0,0).\n        result = np.real(psi_r[0, 0, 0])\n\n        return result\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 0.05, 0.40),\n        (1.0, 1e-6, 0.20),\n        (0.0, 0.05, 0.30),\n        (-0.5, 0.05, 0.50),\n    ]\n\n    results = []\n    for case in test_cases:\n        E_val, eta_val, sigma_val = case\n        res = compute_psi0_real(E=E_val, eta=eta_val, sigma=sigma_val)\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现在，我们将挑战提升到非线性动力学领域，这是含时Hartree-Fock (TDHF) 等多体理论中的常见情景。虽然FFT在处理线性算符时表现出色，但当通过伪谱法将其应用于非线性问题时，会引入一些微妙的陷阱，其中最主要的就是混淆误差 (aliasing)。本练习  旨在让你直面这一挑战：你将模拟一个非线性薛定谔方程，并亲自设计和实现一组物理诊断工具，以探测由于非线性项产生的高频模式被错误地“折叠”回解析频域而导致的虚假能量转移。通过探索和应用“2/3法则”等去混淆技术，你将学会如何在模拟中抑制这种潜在的、破坏性的数值污染，这是确保非线性系统模拟结果可靠性的关键一步。",
            "id": "3556200",
            "problem": "考虑一个域长度为 $L$ 的一维周期场，在包含 $N$ 个点的均匀网格上进行离散化，网格间距为 $\\Delta x = L/N$。令 $x_j = j \\Delta x$，其中 $j \\in \\{0,1,\\dots,N-1\\}$。将网格函数 $u_j = u(x_j)$ 的离散傅里叶变换 (DFT) 定义为\n$$\n\\hat{u}_k = \\sum_{j=0}^{N-1} u_j \\exp\\left(-i \\frac{2\\pi}{N} j k\\right), \\quad k \\in \\{0,1,\\dots,N-1\\},\n$$\n其逆变换为\n$$\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{u}_k \\exp\\left(+i \\frac{2\\pi}{N} j k\\right).\n$$\n令物理波数为 $k_n = \\frac{2\\pi}{L} n$，其中 $n$ 是通过快速傅里叶变换 (FFT) 的常用频率排序获得的。奈奎斯特波数为 $k_{\\mathrm{N}} = \\pi/\\Delta x$。卷积定理指出，物理空间中的乘法对应于傅里叶空间中的卷积。在有限网格上，DFT 实现的是循环卷积，因此如果非线性乘积产生的傅里叶支持超出了 $k_{\\mathrm{N}}$，这些贡献会混叠回解析频带内，从而破坏高波数 $k$ 的内容。\n\n从这些定义和卷积定理出发，推导用于多项式非线性伪谱计算的以下去混叠约束：\n- 对于二次非线性（两个场相乘，每个场的带限均为 $|k| \\leq k_c$），避免混叠需要 $2 k_c \\leq k_{\\mathrm{N}}$。在固定的 $N$ 模态表示中，一个充分的就地规则是在形成涉及两个场的乘积之前，将所有场投影到一个 $|k| \\leq \\tfrac{2}{3} k_{\\mathrm{N}}$ 的低通集合，并在计算非线性项后进行截断。\n- 对于三次非线性（三个场相乘，每个场的带限均为 $|k| \\leq k_c$），避免混叠需要 $3 k_c \\leq k_{\\mathrm{N}}$。在固定的 $N$ 模态表示中，一个充分的就地规则是在形成涉及三个场的乘积之前，将所有场投影到一个 $|k| \\leq \\tfrac{1}{3} k_{\\mathrm{N}}$ 的低通集合，并在计算非线性项后进行截断。\n\n根据这些原理，为一个简化的一维时变 Hartree-Fock (TDHF) 类似物，即三次非线性薛定谔型方程（一种具有接触相互作用的平均场动力学的标准替代模型），实现一个伪谱分裂步长时间积分器：\n$$\ni \\frac{\\partial \\psi}{\\partial t} = -\\frac{1}{2} \\frac{\\partial^2 \\psi}{\\partial x^2} + g \\, |\\psi|^2 \\psi,\n$$\n该方程定义在长度为 $L = 2\\pi$ 的周期域上。使用无量纲单位，其中普朗克常数 $\\hbar = 1$ 且质量 $m = 1$。非线性项 $g \\, |\\psi|^2 \\psi$ 代表一个与密度 $|\\psi|^2$ 成正比的局域平均场，这与时变 Hartree-Fock (TDHF) 中对原子核平均场动力学的简化处理类似。\n\n算法要求：\n1. 使用 Strang 分裂步格式：在傅里叶空间中应用半步线性（动能）传播子，在物理空间中应用全步非线性（势能）传播子，最后在傅里叶空间中应用另一个半步线性传播子。对于时间步长 $\\Delta t$，线性传播子通过在傅里叶空间中乘以 $\\exp\\left(-i \\frac{k^2}{2} \\Delta t\\right)$ 给出。\n2. 为了计算时间 $t$ 的非线性步，从可能已滤波的场计算密度 $\\rho(x,t) = |\\psi(x,t)|^2$，并更新 $\\psi \\mapsto \\exp\\left(-i g \\rho \\Delta t\\right)\\psi$。为了对三次乘积 $|\\psi|^2 \\psi$ 强制执行去混叠策略，你可以将用于形成 $\\rho$ 的场投影到一个低通频带 $|k| \\leq \\alpha k_{\\mathrm{N}}$，其中 $\\alpha \\in \\{1, \\tfrac{2}{3}, \\tfrac{1}{3}\\}$ 对应于所选的去混叠策略。在非线性步之后不要对 $\\psi$ 进行其他滤波；关键在于通过形成 $\\rho$ 时选择的 $\\alpha$ 来暴露或抑制混叠。\n3. 通过两个平面波的叠加来初始化 $t=0$ 时的场：\n$$\n\\psi(x,0) = A \\left(e^{i k_1 x} + e^{i k_2 x}\\right),\n$$\n其中 $k_1 = 8$, $k_2 = 12$，并选择 $A$ 使得 $\\int_0^L |\\psi(x,0)|^2 \\, dx = 1$。\n4. 使用固定的时间步长 $\\Delta t$ 将系统演化到最终时间 $T$。\n\n定义具有物理动机的诊断方法，以检测由于去混叠不足导致到高波数模式的伪能量转移：\n- 尾部动能分数增长。令动能谱为\n$$\n\\mathcal{K}(k) = \\frac{1}{2} k^2 |\\hat{\\psi}(k)|^2,\n$$\n其中离散总动能通过 $K = \\frac{\\Delta x}{N} \\sum_k \\mathcal{K}(k)$ 使用上述 DFT 约定来近似。将高波数 $k$ 尾部定义为满足 $|k| \\geq \\beta k_{\\mathrm{N}}$ 且 $\\beta = 0.85$ 的模式。计算 $t=0$ 和 $t=T$ 时的尾部动能，分别记为 $K^{\\mathrm{tail}}_0$ 和 $K^{\\mathrm{tail}}_T$。定义尾部增长因子\n$$\nG = \\frac{K^{\\mathrm{tail}}_T}{K^{\\mathrm{tail}}_0 + \\varepsilon},\n$$\n其中小的正则化项 $\\varepsilon = 10^{-12}$ 用于避免除以零。$G$ 的大值表示向最高模式的异常转移。\n- 总能量漂移。定义离散总能量\n$$\nE(t) = \\frac{\\Delta x}{N} \\sum_k \\frac{1}{2} k^2 |\\hat{\\psi}(k,t)|^2 + \\frac{g}{2} \\Delta x \\sum_j |\\psi(x_j,t)|^4.\n$$\n计算相对漂移\n$$\nD = \\frac{|E(T) - E(0)|}{|E(0)|}.\n$$\n显著的漂移表明存在数值病态，这可能源于非线性乘积中的混叠。\n- 高波数 $k$ 谱的上翘。令 $P(k) = |\\hat{\\psi}(k)|^2$ 并通过对对称的 $\\pm k$ 贡献求和，形成一个关于非负 $|k|$ 的一维壳层谱。对最接近 $k_{\\mathrm{N}}$ 的最后 $M$ 个非零壳层（取 $M=8$）的 $\\log P$ 对 $k$ 的关系进行最小二乘斜率拟合。如果此斜率为正，则表明尾部存在不符合物理规律的上翘。\n\n构建一个复合混叠检测器，如果以下三个条件中至少有两个成立，则返回 true：$G  G_{\\mathrm{thr}}$、$D  D_{\\mathrm{thr}}$ 以及尾部斜率为正。使用阈值 $G_{\\mathrm{thr}} = 50$ 和 $D_{\\mathrm{thr}} = 0.02$。\n\n除非另有说明，否则使用以下固定的数值参数：$L = 2\\pi$，$N = 256$，$T = 0.8$，以及 $\\Delta t = 10^{-3}$。所有量都是无量纲的，因此不需要物理单位转换。\n\n实现一个程序，执行以下测试套件并打印检测结果：\n- 情况 1（检测混叠的理想情况）：$g = 20$，非线性步中无去混叠（$\\alpha = 1$）。预期会检测到混叠。\n- 情况 2（二次非线性的边界条件，但对三次非线性不足）：$g = 20$，在形成 $\\rho$ 时应用 $\\tfrac{2}{3}$-规则（$\\alpha = \\tfrac{2}{3}$）。由于非线性是三次的，预期会检测到混叠。\n- 情况 3（对三次非线性足够）：$g = 20$，在形成 $\\rho$ 时应用 $\\tfrac{1}{3}$-规则（$\\alpha = \\tfrac{1}{3}$）。预期不会检测到混叠。\n- 情况 4（边缘情况控制）：$g = 0$（线性演化），无去混叠（$\\alpha = 1$）。预期不会检测到混叠。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的 Python 布尔字面量列表，顺序与上述情况一致，例如，“[True,False,True,False]”。",
            "solution": "问题陈述被评估为有效。它在计算物理和数值分析领域具有科学依据，特别是关于非线性偏微分方程的伪谱解法。该问题是适定的，提供了明确的方程、初始和边界条件，以及清晰的算法和分析任务。其语言客观，参数具体，从而允许唯一且可验证的解。所有定义和常数均内部一致，并与该领域的标准惯例相符。\n\n### 去混叠约束的推导\n\n伪谱法的核心是使用快速傅里叶变换 (FFT) 来计算空间导数。对于函数 $u(x)$，其空间导数 $\\partial_x u(x)$ 的傅里叶变换为 $\\widehat{\\partial_x u}(k) = ik\\hat{u}(k)$。这将微分算子变为傅里叶空间中的简单乘法。然而，非线性项（如场的乘积）是在物理空间中计算的。乘积 $w(x) = u(x)v(x)$ 的变换是其各自变换的卷积：\n$$\n\\hat{w}_k = (\\hat{u} * \\hat{v})_k = \\sum_{p=0}^{N-1} \\hat{u}_p \\hat{v}_{k-p}\n$$\n在 $N$ 个点的离散网格上，此卷积是循环的，意味着索引的和是对 $N$ 取模的：\n$$\n\\hat{w}_k = \\sum_{p+q=k \\pmod N} \\hat{u}_p \\hat{v}_q\n$$\n如果场 $u(x)$ 和 $v(x)$ 是带限的，即其变换 $\\hat{u}_p$ 和 $\\hat{v}_q$ 仅在一定波数（模式）范围内非零，例如 $|p| \\le k_c$ 和 $|q| \\le k_c$，那么它们的真实卷积积 $\\hat{w}_k$ 将带限于 $|k| \\le 2k_c$。\n\n然而，在离散网格上，任何波数 $k'$ 与其混叠项 $k' + mN$（对于任何整数 $m$）是无法区分的。唯一表示的波数范围通常取为 $k \\in [ -k_{\\mathrm{N}}, k_{\\mathrm{N}} )$，其中对于给定的域长度 $L=2\\pi$，奈奎斯特波数为 $k_{\\mathrm{N}} = \\pi/\\Delta x = N/2$。如果乘积生成的波数的幅值大于 $k_{\\mathrm{N}}$，这些模式会“折叠”回解析范围 $[ -k_{\\mathrm{N}}, k_{\\mathrm{N}} )$ 内，从而污染物理乘积的变换。这种现象称为混叠。\n\n1.  **二次非线性**：对于两个场的乘积 $u(x)v(x)$，每个场都带限于 $|k| \\leq k_c$，乘积 $w=uv$ 的谱支持在 $|k| \\leq 2k_c$ 上。为防止混叠，此谱支持必须完全位于网格的可表示范围内，这要求 $2k_c \\leq k_{\\mathrm{N}}$。这是基本约束。对于在固定 $N$ 个模式的网格上的“就地”计算，一个常见的充分策略是在乘法前截断输入场。如果我们将 $\\hat{u}$ 和 $\\hat{v}$ 中 $|k|  K_{trunc}$ 的所有模式置零，则乘积的谱将扩展到 $2K_{trunc}$。如果来自和 $\\sum_{p+q=k+mN, m \\neq 0} \\hat{u}_p \\hat{v}_q$ 的模式对于 $|k| \\leq K_{trunc}$ 是非零的，混叠会污染计算。防止这种情况的一个充分条件是，来自截断输入的最大可能波数之和不会混叠回截断区域。这要求 $K_{trunc} + K_{trunc}  N - K_{trunc}$，简化为 $3K_{trunc}  N$。用物理波数表示，这转化为 $K_{trunc}  N/3 = (2/3)(N/2) = \\frac{2}{3}k_{\\mathrm{N}}$。因此，在形成二次乘积前将场滤波到 $|k| \\leq \\frac{2}{3}k_{\\mathrm{N}}$ 是一个充分的去混叠规则，通常称为 Orszag 2/3-规则。\n\n2.  **三次非线性**：对于三个场的乘积 $u(x)v(x)w(x)$，每个场都带限于 $|k| \\leq k_c$，乘积的谱支持在 $|k| \\leq 3k_c$ 上。为防止任何混叠，我们要求 $3k_c \\leq k_{\\mathrm{N}}$。相应的就地规则可以类似地推导出来。对于像 $|\\psi|^2\\psi$ 这样的项，可以将其视为一个顺序乘积。假设 $\\psi$ 被滤波到 $|k|\\le K_{trunc}$。密度 $\\rho = |\\psi|^2$ 的谱支持高达 $2K_{trunc}$。最终乘积 $\\rho\\psi$ 的支持则高达 $2K_{trunc} + K_{trunc} = 3K_{trunc}$。为防止混叠污染所需的模式 $|k|\\le K_{trunc}$，我们要求 $3K_{trunc}  N - K_{trunc}$，得出 $4K_{trunc}  N$，或 $K_{trunc}  N/4$。以奈奎斯特波数表示，$K_{trunc}  N/4 = (1/2)(N/2) = \\frac{1}{2}k_{\\mathrm{N}}$。问题陈述了一个 $|k| \\leq \\frac{1}{3}k_{\\mathrm{N}}$ 的规则。这对应于 $K_{trunc} \\le N/6$。这是一个更严格、因此也是充分的条件：如果我们截断到 $N/6$，乘积的支持扩展到 $3(N/6)=N/2=k_{\\mathrm{N}}$，这完美地吻合在非混叠域内。因此，$\\frac{1}{3}$-规则是三次非线性的一种有效的、保守的去混叠策略。\n\n### 分裂步积分器的算法设计\n\n该问题要求使用 Strang 分裂步方法求解三次非线性薛定谔方程。方程被分为线性部分 $i\\partial_t\\psi = \\hat{L}\\psi$ 和非线性部分 $i\\partial_t\\psi = \\hat{V}\\psi$，其中 $\\hat{L} = -\\frac{1}{2}\\partial_{xx}$ 和 $\\hat{V} = g|\\psi|^2$。\n\n将解从时间 $t$ 演化到 $t+\\Delta t$ 的 Strang 分裂格式是一种对称的二阶方法：\n$$\n\\psi(t+\\Delta t) = e^{-i\\hat{L}\\Delta t/2} e^{-i\\hat{V}\\Delta t} e^{-i\\hat{L}\\Delta t/2} \\psi(t)\n$$\n\n单个时间步的步骤如下：\n1.  **第一个线性半步**：线性算子 $\\hat{L}$ 在傅里叶空间中是对角的。我们通过 FFT 将 $\\psi(x, t)$ 变换为 $\\hat{\\psi}(k, t)$。然后通过乘以 $e^{-i\\hat{L}(k)\\Delta t/2}$ 来应用传播子，其中 $\\hat{L}(k) = k^2/2$。\n    $$\n    \\hat{\\psi}'(k) = \\hat{\\psi}(k,t) \\exp\\left(-i \\frac{k^2}{2} \\frac{\\Delta t}{2}\\right)\n    $$\n2.  **非线性全步**：此步在物理空间中执行。首先，通过逆 FFT 将 $\\hat{\\psi}'(k)$ 变换回 $\\psi'(x)$。非线性更新为 $\\psi''(x) = e^{-i\\hat{V}(x)\\Delta t} \\psi'(x)$。势 $\\hat{V}(x) = g\\rho(x)$，其中密度 $\\rho(x) = |\\psi(x)|^2$。关键在于，这是应用去混叠策略的地方。\n    a.  要计算去混叠的密度，我们从当前状态 $\\psi'(x)$（或第一步的 $\\psi(x,t)$）开始。\n    b.  变换到傅里叶空间：$\\hat{\\psi}'(k) = \\mathcal{F}\\{\\psi'(x)\\}$。\n    c.  基于参数 $\\alpha$ 应用低通滤波器：创建一个掩码，对于 $|k| \\le \\alpha k_{\\mathrm{N}}$ 为 1，否则为 0。将 $\\hat{\\psi}'(k)$ 与此掩码相乘以得到 $\\hat{\\psi}_f(k)$。\n    d.  变换回物理空间：$\\psi_f(x) = \\mathcal{F}^{-1}\\{\\hat{\\psi}_f(k)\\}$。\n    e.  计算去混叠的密度：$\\rho(x) = |\\psi_f(x)|^2$。\n    f.  将非线性更新应用于未滤波的场 $\\psi'(x)$：\n    $$\n    \\psi''(x) = \\psi'(x) \\exp\\left(-i g \\rho(x) \\Delta t\\right)\n    $$\n3.  **第二个线性半步**：通过 FFT 将 $\\psi''(x)$ 变换为 $\\hat{\\psi}''(k)$，并应用第二个线性传播子。\n    $$\n     \\hat{\\psi}(k, t+\\Delta t) = \\hat{\\psi}''(k) \\exp\\left(-i \\frac{k^2}{2} \\frac{\\Delta t}{2}\\right)\n    $$\n此过程重复总时间步数 $T/\\Delta t$ 次。\n\n### 诊断量的计算\n\n初始条件为 $\\psi(x,0) = A(e^{ik_1x} + e^{ik_2x})$，其中 $k_1=8, k_2=12$。归一化常数 $A$ 由条件 $\\int_0^L |\\psi(x,0)|^2 dx = 1$ 确定。当 $L=2\\pi$ 时，这得到 $\\int_0^{2\\pi} |A|^2 (2 + 2\\cos((k_1-k_2)x)) dx = 1$，解为 $4\\pi|A|^2 = 1$，因此我们选择实数 $A=1/\\sqrt{4\\pi}$。\n\n数值网格和参数为：$L=2\\pi, N=256, \\Delta x = L/N = \\pi/128$。物理波数是整数值的，$k_n = n$，通过 `numpy.fft.fftfreq(N) * N` 计算。奈奎斯特波数为 $k_{\\mathrm{N}} = N/2 = 128$。\n\n诊断量计算如下：\n- **总能量漂移 ($D$)**：总能量 $E(t) = K(t) + V(t)$ 在 $t=0$ 和 $t=T$ 时计算。\n  - 动能：$K(t) = \\frac{\\Delta x}{N} \\sum_k \\frac{1}{2} k^2 |\\hat{\\psi}(k,t)|^2$。\n  - 势能：$V(t) = \\frac{g}{2} \\Delta x \\sum_j |\\psi(x_j,t)|^4$。\n  - 漂移：$D = |E(T) - E(0)| / |E(0)|$。\n- **尾部动能增长 ($G$)**：高波数 $k$ 尾部由 $|k| \\geq \\beta k_{\\mathrm{N}} = 0.85 \\times 128 = 108.8$ 定义。我们使用 $|k| \\ge 109$ 的模式。\n  - 时间 $t$ 的尾部动能：$K^{\\mathrm{tail}}(t)$ 是在尾部模式上对 $\\frac{\\Delta x}{N} \\frac{1}{2} k^2 |\\hat{\\psi}(k,t)|^2$ 的求和。\n  - 增长因子：$G = K^{\\mathrm{tail}}(T) / (K^{\\mathrm{tail}}(0) + \\varepsilon)$，其中 $\\varepsilon=10^{-12}$。\n- **高波数 $k$ 谱上翘（斜率）**：功率谱为 $P(k)=|\\hat{\\psi}(k,T)|^2$。一维壳层谱是 $S(k_{shell}) = P(k_{shell}) + P(-k_{shell})$，对于 $k_{shell}  0$。我们找到当 $k$ 接近 $k_{\\mathrm{N}}$ 时，$S(k)$ 的最后 $M=8$ 个非零值，并对 $\\log(S(k))$ versus $k$ 进行线性最小二乘拟合以找到斜率。正斜率表示能量的不符合物理规律的堆积。\n\n复合混叠检测器在满足以下条件中至少两个时返回 `True`：$G  50$，$D  0.02$，以及斜率 $ 0$。该实现将对四个测试案例中的每一个执行此逻辑。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D cubic NLSE using a split-step Fourier method and\n    evaluates aliasing based on several diagnostics.\n    \"\"\"\n\n    def run_simulation(g_val, alpha, L, N, T, dt):\n        \"\"\"\n        Performs a single simulation run for a given set of parameters.\n\n        Args:\n            g_val (float): Nonlinear coupling constant.\n            alpha (float): Dealiasing filter factor (1, 2/3, or 1/3).\n            L (float): Domain length.\n            N (int): Number of grid points.\n            T (float): Total simulation time.\n            dt (float): Time step.\n\n        Returns:\n            tuple: A tuple containing the diagnostics (G, D, tail_slope).\n        \"\"\"\n        # Grid and wavenumber setup\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        k = np.fft.fftfreq(N) * N\n\n        k_sq = k**2\n        k_N = N / 2\n\n        # Initial condition\n        k1, k2 = 8, 12\n        psi0_unnorm = (np.exp(1j * k1 * x) + np.exp(1j * k2 * x))\n        \n        # Normalize based on discrete sum\n        norm_factor = np.sqrt(np.sum(np.abs(psi0_unnorm)**2) * dx)\n        psi0 = psi0_unnorm / norm_factor\n        \n        psi = psi0.copy()\n        psi_hat = np.fft.fft(psi)\n\n        # Calculate initial energy\n        ke0 = (dx / N) * 0.5 * np.sum(k_sq * np.abs(psi_hat)**2)\n        pe0 = (g_val / 2) * dx * np.sum(np.abs(psi)**4)\n        E0 = ke0 + pe0\n        if np.isclose(E0, 0): E0 = 1.0 # Avoid division by zero for g=0 case\n\n        # Calculate initial tail kinetic energy\n        beta = 0.85\n        tail_mask = np.abs(k) >= beta * k_N\n        ke_tail_0 = (dx / N) * 0.5 * np.sum(k_sq[tail_mask] * np.abs(psi_hat[tail_mask])**2)\n\n        # Time-stepping loop\n        num_steps = int(round(T / dt))\n        linear_propagator_half = np.exp(-0.5j * k_sq * (dt / 2.0))\n        dealias_mask = np.abs(k) = alpha * k_N\n\n        for step in range(num_steps):\n            # First linear half-step\n            psi_hat *= linear_propagator_half\n\n            # Nonlinear full-step\n            psi_temp = np.fft.ifft(psi_hat)\n            \n            # Dealiasing for density calculation\n            psi_hat_filtered = psi_hat * dealias_mask\n            psi_filtered = np.fft.ifft(psi_hat_filtered)\n\n            rho = np.abs(psi_filtered)**2\n            nonlinear_propagator = np.exp(-1j * g_val * rho * dt)\n            psi = psi_temp * nonlinear_propagator\n\n            psi_hat = np.fft.fft(psi)\n            \n            # Second linear half-step\n            psi_hat *= linear_propagator_half\n\n        psi_final = np.fft.ifft(psi_hat)\n\n        # ---- Calculate final diagnostics ----\n\n        # 1. Tail kinetic energy growth (G)\n        ke_tail_T = (dx / N) * 0.5 * np.sum(k_sq[tail_mask] * np.abs(psi_hat[tail_mask])**2)\n        epsilon = 1e-12\n        G = ke_tail_T / (ke_tail_0 + epsilon)\n\n        # 2. Total energy drift (D)\n        keT = (dx / N) * 0.5 * np.sum(k_sq * np.abs(psi_hat)**2)\n        peT = (g_val / 2) * dx * np.sum(np.abs(psi_final)**4)\n        ET = keT + peT\n        D = np.abs(ET - E0) / np.abs(E0)\n\n        # 3. High-k spectral upturn (slope)\n        M = 8\n        power_spectrum = np.abs(psi_hat)**2\n        \n        # Symmetrized 1D shell spectrum for k > 0\n        k_pos = k[1:N//2]\n        shell_spec = power_spectrum[1:N//2] + power_spectrum[N-1:N//2:-1]\n\n        # Find last M non-zero shells to fit\n        non_zero_indices = np.where(shell_spec > 1e-30)[0] # Use a small floor\n        if len(non_zero_indices) >= M:\n            fit_indices = non_zero_indices[-M:]\n            k_fit = k_pos[fit_indices]\n            log_spec_fit = np.log(shell_spec[fit_indices])\n            \n            # Perform linear fit: log(P) = slope * k + intercept\n            slope, _ = np.polyfit(k_fit, log_spec_fit, 1)\n        else:\n            slope = -np.inf # No upturn if spectrum decays too fast\n\n        return G, D, slope\n\n    # Fixed numerical parameters\n    L_param = 2 * np.pi\n    N_param = 256\n    T_param = 0.8\n    dt_param = 1e-3\n\n    # Thresholds for aliasing detector\n    G_thr = 50.0\n    D_thr = 0.02\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (g, alpha)\n        (20.0, 1.0),            # Case 1: No dealiasing\n        (20.0, 2.0 / 3.0),      # Case 2: 2/3 rule (insufficient for cubic)\n        (20.0, 1.0 / 3.0),      # Case 3: 1/3 rule (sufficient for cubic)\n        (0.0, 1.0)              # Case 4: Linear evolution (control)\n    ]\n\n    results = []\n    for g, alpha in test_cases:\n        G, D, tail_slope = run_simulation(g, alpha, L_param, N_param, T_param, dt_param)\n\n        # Composite aliasing detector\n        cond1 = G > G_thr\n        cond2 = D > D_thr\n        cond3 = tail_slope > 0\n        \n        aliasing_detected = (int(cond1) + int(cond2) + int(cond3)) >= 2\n        results.append(aliasing_detected)\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}