{
    "hands_on_practices": [
        {
            "introduction": "To bridge the gap between abstract theory and physical application, we begin with a foundational exercise. This practice  demonstrates how the Wigner $3j$ symbol naturally arises from the integral of three spherical harmonics, known as a Gaunt coefficient. By deriving this relationship and calculating a specific example, you will solidify your understanding of how angular momentum selection rules are encoded within the structure of these symbols.",
            "id": "3611568",
            "problem": "In a spherical mean-field description of a single nucleon, angular momentum coupling is handled through spherical harmonics and tensor operators. Consider the one-body electric quadrupole operator defined by $T^{(2)}_{\\mu} = e\\, r^{2} Y_{2 \\mu}(\\Omega)$, where $Y_{l m}(\\Omega)$ are the standard Condon–Shortley spherical harmonics normalized by $\\int Y_{l m}^{*}(\\Omega) Y_{l' m'}(\\Omega)\\, d\\Omega = \\delta_{l l'} \\delta_{m m'}$. The angular dependence of matrix elements of $T^{(2)}_{\\mu}$ factors into Gaunt coefficients, defined for integer $l_{1}, l_{2}, l_{3}$ and $m_{1}, m_{2}, m_{3}$ by\n$$\nG(l_{1} m_{1}; l_{2} m_{2}; l_{3} m_{3}) = \\int Y_{l_{1} m_{1}}(\\Omega)\\, Y_{l_{2} m_{2}}(\\Omega)\\, Y_{l_{3} m_{3}}(\\Omega)\\, d\\Omega.\n$$\nStarting from the definitions of spherical harmonics, their orthogonality, and the statement of the Wigner–Eckart theorem (WET), derive the expression of the Gaunt coefficient in terms of Wigner $3j$ symbols and the overall normalization, and then compute explicitly the integral\n$$\nI = \\int Y_{1,0}(\\Omega)\\, Y_{2,0}(\\Omega)\\, Y_{1,0}(\\Omega)\\, d\\Omega.\n$$\nExplain any selection rules you use, and present the final result as a closed-form analytic expression with no numerical approximation. No units are required for the final answer. Do not round your answer.",
            "solution": "The problem is valid. It is scientifically grounded in the quantum theory of angular momentum, well-posed with sufficient information for a unique solution, and stated objectively. All definitions and requests are standard within theoretical and computational physics.\n\nThe problem asks for two main tasks: first, to derive the general expression for a Gaunt coefficient in terms of Wigner $3j$ symbols, and second, to compute a specific instance of this integral.\n\n**Part 1: Derivation of the Gaunt Coefficient Expression**\n\nThe Gaunt coefficient is defined as the integral of the product of three spherical harmonics over the solid angle $\\Omega$:\n$$\nG(l_{1} m_{1}; l_{2} m_{2}; l_{3} m_{3}) = \\int Y_{l_{1} m_{1}}(\\Omega)\\, Y_{l_{2} m_{2}}(\\Omega)\\, Y_{l_{3} m_{3}}(\\Omega)\\, d\\Omega\n$$\nThe spherical harmonics have a dependence on the azimuthal angle $\\phi$ of the form $Y_{lm}(\\theta, \\phi) \\propto \\exp(im\\phi)$. The integral over $d\\Omega = \\sin\\theta\\,d\\theta\\,d\\phi$ thus contains a factor\n$$\n\\int_{0}^{2\\pi} \\exp(im_{1}\\phi) \\exp(im_{2}\\phi) \\exp(im_{3}\\phi)\\, d\\phi = \\int_{0}^{2\\pi} \\exp(i(m_1+m_2+m_3)\\phi)\\, d\\phi = 2\\pi \\delta_{m_1+m_2+m_3, 0}\n$$\nThis immediately establishes a fundamental selection rule: the Gaunt coefficient is non-zero only if the sum of the magnetic quantum numbers is zero, i.e., $m_1+m_2+m_3=0$. This is a consequence of the rotational invariance of the scalar quantity formed by the product of the three functions.\n\nTo proceed with the derivation, we utilize the product theorem for two spherical harmonics. This theorem is a direct consequence of the rules for adding angular momenta, the principles of which are generalized by the Wigner-Eckart theorem (WET). The product of two spherical harmonics can be expanded in the basis of single spherical harmonics:\n$$\nY_{l_{2} m_{2}}(\\Omega)\\, Y_{l_{3} m_{3}}(\\Omega) = \\sum_{L, M} \\sqrt{\\frac{(2l_2+1)(2l_3+1)}{4\\pi(2L+1)}} \\langle l_2 0 l_3 0 | L 0 \\rangle \\langle l_2 m_2 l_3 m_3 | L M \\rangle Y_{L M}(\\Omega)\n$$\nHere, $\\langle j_1 m_1 j_2 m_2 | j_3 m_3 \\rangle$ is a Clebsch-Gordan coefficient. Substituting this expansion into the integral for the Gaunt coefficient gives:\n$$\nG = \\int Y_{l_{1} m_{1}}(\\Omega) \\left( \\sum_{L, M} \\sqrt{\\frac{(2l_2+1)(2l_3+1)}{4\\pi(2L+1)}} \\langle l_2 0 l_3 0 | L 0 \\rangle \\langle l_2 m_2 l_3 m_3 | L M \\rangle Y_{L M}(\\Omega) \\right) d\\Omega\n$$\nRearranging the sum and integral:\n$$\nG = \\sum_{L, M} \\sqrt{\\frac{(2l_2+1)(2l_3+1)}{4\\pi(2L+1)}} \\langle l_2 0 l_3 0 | L 0 \\rangle \\langle l_2 m_2 l_3 m_3 | L M \\rangle \\int Y_{l_{1} m_{1}}(\\Omega) Y_{L M}(\\Omega) d\\Omega\n$$\nThe integral of two spherical harmonics can be related to the orthogonality condition $\\int Y_{l'm'}^*(\\Omega) Y_{lm}(\\Omega) d\\Omega = \\delta_{ll'}\\delta_{mm'}$. Using the property $Y_{l'm'}^*(\\Omega) = (-1)^{m'} Y_{l', -m'}(\\Omega)$, we can write:\n$$\n\\int Y_{l_{1} m_{1}} Y_{L M} d\\Omega = \\int (-1)^{-m_1} (Y_{l_1, -m_1})^* Y_{L M} d\\Omega = (-1)^{-m_1} \\delta_{l_1 L} \\delta_{-m_1 M}\n$$\nSubstituting this back into the expression for $G$, the sum over $L$ and $M$ collapses to a single term where $L=l_1$ and $M=-m_1$:\n$$\nG(l_{1} m_{1}; \\dots) = \\sqrt{\\frac{(2l_2+1)(2l_3+1)}{4\\pi(2l_1+1)}} \\langle l_2 0 l_3 0 | l_1 0 \\rangle \\langle l_2 m_2 l_3 m_3 | l_1, -m_1 \\rangle (-1)^{-m_1}\n$$\nNext, we convert the Clebsch-Gordan coefficients to the more symmetric Wigner $3j$ symbols using the relation:\n$$\n\\langle j_1 m_1 j_2 m_2 | j_3 m_3 \\rangle = (-1)^{j_1-j_2+m_3} \\sqrt{2j_3+1} \\begin{pmatrix} j_1 & j_2 & j_3 \\\\ m_1 & m_2 & -m_3 \\end{pmatrix}\n$$\nApplying this to our two Clebsch-Gordan coefficients:\n\\begin{enumerate}\n    \\item $\\langle l_2 0 l_3 0 | l_1 0 \\rangle = (-1)^{l_2-l_3} \\sqrt{2l_1+1} \\begin{pmatrix} l_2 & l_3 & l_1 \\\\ 0 & 0 & 0 \\end{pmatrix}$\n    \\item $\\langle l_2 m_2 l_3 m_3 | l_1, -m_1 \\rangle = (-1)^{l_2-l_3-m_1} \\sqrt{2l_1+1} \\begin{pmatrix} l_2 & l_3 & l_1 \\\\ m_2 & m_3 & m_1 \\end{pmatrix}$\n\\end{enumerate}\nSubstituting these into the expression for $G$:\n$$\nG = \\sqrt{\\frac{(2l_2+1)(2l_3+1)}{4\\pi(2l_1+1)}} \\left[(-1)^{l_2-l_3} \\sqrt{2l_1+1} \\begin{pmatrix} l_2 & l_3 & l_1 \\\\ 0 & 0 & 0 \\end{pmatrix}\\right] \\left[(-1)^{l_2-l_3-m_1} \\sqrt{2l_1+1} \\begin{pmatrix} l_2 & l_3 & l_1 \\\\ m_2 & m_3 & m_1 \\end{pmatrix}\\right] (-1)^{-m_1}\n$$\nSimplifying the terms:\n$$\nG = \\sqrt{\\frac{(2l_2+1)(2l_3+1)}{4\\pi(2l_1+1)}} (2l_1+1) (-1)^{2(l_2-l_3)-m_1} (-1)^{-m_1} \\begin{pmatrix} l_2 & l_3 & l_1 \\\\ 0 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} l_2 & l_3 & l_1 \\\\ m_2 & m_3 & m_1 \\end{pmatrix}\n$$\nThe phase factor simplifies as $(-1)^{2(l_2-l_3)-m_1-m_1} = (-1)^{2(l_2-l_3-m_1)} = 1$. The expression becomes:\n$$\nG = \\sqrt{\\frac{(2l_1+1)(2l_2+1)(2l_3+1)}{4\\pi}} \\begin{pmatrix} l_2 & l_3 & l_1 \\\\ 0 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} l_2 & l_3 & l_1 \\\\ m_2 & m_3 & m_1 \\end{pmatrix}\n$$\nFinally, using the property that an even permutation of columns leaves a $3j$ symbol unchanged (e.g., $(231) \\to (123)$), we arrive at the standard form:\n$$\nG(l_{1} m_{1}; l_{2} m_{2}; l_{3} m_{3}) = \\sqrt{\\frac{(2l_1+1)(2l_2+1)(2l_3+1)}{4\\pi}} \\begin{pmatrix} l_1 & l_2 & l_3 \\\\ 0 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} l_1 & l_2 & l_3 \\\\ m_1 & m_2 & m_3 \\end{pmatrix}\n$$\nThis formula encodes two additional selection rules from the properties of the $3j$ symbols:\n\\begin{itemize}\n    \\item The triangle inequality: The angular momenta $\\{l_1, l_2, l_3\\}$ must satisfy $|l_i - l_j| \\le l_k \\le l_i + l_j$ for any permutation $(i,j,k)$.\n    \\item The parity rule: The sum $l_1+l_2+l_3$ must be an even integer for the first $3j$ symbol with all $m=0$ to be non-zero.\n\\end{itemize}\n\n**Part 2: Calculation of the Integral**\nWe are asked to compute $I = \\int Y_{1,0}(\\Omega)\\, Y_{2,0}(\\Omega)\\, Y_{1,0}(\\Omega)\\, d\\Omega$. This is a Gaunt coefficient $G(l_1 m_1; l_2 m_2; l_3 m_3)$ with parameters:\n$l_1=1, m_1=0$\n$l_2=2, m_2=0$\n$l_3=1, m_3=0$\n\nFirst, we check the selection rules:\n\\begin{enumerate}\n    \\item $m_1+m_2+m_3 = 0+0+0=0$. This is satisfied.\n    \\item Triangle inequality for $\\{1,2,1\\}$: $|1-2| \\le 1 \\le 1+2$, which is $1 \\le 1 \\le 3$. This is satisfied.\n    \\item Parity rule: $l_1+l_2+l_3 = 1+2+1=4$. This is an even integer, so the rule is satisfied.\n\\end{enumerate}\nSince all selection rules are satisfied, the integral is non-zero. We apply the derived formula:\n$$\nI = \\sqrt{\\frac{(2(1)+1)(2(2)+1)(2(1)+1)}{4\\pi}} \\begin{pmatrix} 1 & 2 & 1 \\\\ 0 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} 1 & 2 & 1 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\n$$\nI = \\sqrt{\\frac{3 \\cdot 5 \\cdot 3}{4\\pi}} \\left( \\begin{pmatrix} 1 & 2 & 1 \\\\ 0 & 0 & 0 \\end{pmatrix} \\right)^2 = \\sqrt{\\frac{45}{4\\pi}} \\left( \\begin{pmatrix} 1 & 2 & 1 \\\\ 0 & 0 & 0 \\end{pmatrix} \\right)^2\n$$\nWe must now evaluate the $3j$ symbol. The general formula for $\\begin{pmatrix} j_1 & j_2 & j_3 \\\\ 0 & 0 & 0 \\end{pmatrix}$ where $2g = j_1+j_2+j_3$ is an even integer is:\n$$\n\\begin{pmatrix} j_1 & j_2 & j_3 \\\\ 0 & 0 & 0 \\end{pmatrix} = (-1)^g \\sqrt{\\frac{(2g-2j_1)!(2g-2j_2)!(2g-2j_3)!}{(2g+1)!}} \\frac{g!}{(g-j_1)!(g-j_2)!(g-j_3)!}\n$$\nFor our case, $j_1=1, j_2=2, j_3=1$, so $2g=4$ and $g=2$. The phase is $(-1)^2=1$.\n$$\n\\begin{pmatrix} 1 & 2 & 1 \\\\ 0 & 0 & 0 \\end{pmatrix} = \\sqrt{\\frac{(4-2)!(4-4)!(4-2)!}{(4+1)!}} \\frac{2!}{(2-1)!(2-2)!(2-1)!}\n$$\n$$\n= \\sqrt{\\frac{2! \\cdot 0! \\cdot 2!}{5!}} \\frac{2!}{1! \\cdot 0! \\cdot 1!} = \\sqrt{\\frac{2 \\cdot 1 \\cdot 2}{120}} \\frac{2}{1} = \\sqrt{\\frac{4}{120}} \\cdot 2 = \\sqrt{\\frac{1}{30}} \\cdot 2 = \\frac{2}{\\sqrt{30}} = \\sqrt{\\frac{4}{30}} = \\sqrt{\\frac{2}{15}}\n$$\nThe square of the $3j$ symbol is therefore:\n$$\n\\left( \\begin{pmatrix} 1 & 2 & 1 \\\\ 0 & 0 & 0 \\end{pmatrix} \\right)^2 = \\left(\\sqrt{\\frac{2}{15}}\\right)^2 = \\frac{2}{15}\n$$\nSubstituting this value back into the expression for $I$:\n$$\nI = \\sqrt{\\frac{45}{4\\pi}} \\cdot \\frac{2}{15} = \\frac{\\sqrt{9 \\cdot 5}}{2\\sqrt{\\pi}} \\cdot \\frac{2}{15} = \\frac{3\\sqrt{5}}{2\\sqrt{\\pi}} \\cdot \\frac{2}{15} = \\frac{6\\sqrt{5}}{30\\sqrt{\\pi}} = \\frac{\\sqrt{5}}{5\\sqrt{\\pi}}\n$$\nThis can be written in a more compact form:\n$$\nI = \\frac{\\sqrt{5}}{\\sqrt{25}\\sqrt{\\pi}} = \\sqrt{\\frac{5}{25\\pi}} = \\sqrt{\\frac{1}{5\\pi}}\n$$\nThe exact value of the integral is $\\sqrt{\\frac{1}{5\\pi}}$.",
            "answer": "$$\\boxed{\\sqrt{\\frac{1}{5\\pi}}}$$"
        },
        {
            "introduction": "Nuclear structure calculations often involve complex interactions between many particles. This exercise  moves from single-operator matrix elements to the more complex case of a two-body operator acting on a coupled two-nucleon state. You will apply the Wigner-Eckart theorem in a more sophisticated context, leading to an expression involving a Wigner $9j$ symbol, a crucial tool for handling recoupling transformations in many-body physics.",
            "id": "3611519",
            "problem": "In a computational nuclear physics shell-model calculation, consider a two-nucleon system consisting of one proton in a single-particle orbit with total angular momentum $j_{p} = \\frac{3}{2}$ and one neutron in a single-particle orbit with total angular momentum $j_{n} = \\frac{5}{2}$. The two-body operator is constructed from a one-body spherical tensor $t^{(k)}$ of rank $k$ (defined on the single-particle space) as a coupled tensor product,\n$$\nO^{(K)} \\equiv \\left[t^{(k)}(p) \\otimes t^{(k)}(n)\\right]^{(K)},\n$$\nwhere $K$ is the resultant rank of the two-body operator in the total angular momentum space, and the labels $(p)$ and $(n)$ specify action on the proton and neutron, respectively. Assume that the one-body reduced matrix elements\n$$\nq_{p} \\equiv \\left\\langle j_{p} \\left\\| t^{(k)} \\right\\| j_{p} \\right\\rangle, \\qquad q_{n} \\equiv \\left\\langle j_{n} \\left\\| t^{(k)} \\right\\| j_{n} \\right\\rangle\n$$\nare finite and nonzero.\n\nStarting from first principles of angular momentum coupling in quantum mechanics, specifically the properties of spherical tensor operators, the Clebsch–Gordan coefficients, and the Wigner–Eckart theorem, derive an analytic expression for the reduced matrix element\n$$\n\\left\\langle (j_{p} j_{n}) J \\left\\| O^{(K)} \\right\\| (j_{p} j_{n}) J' \\right\\rangle\n$$\nbetween the two-particle coupled states $\\left|(j_{p} j_{n}) J M\\right\\rangle$ and $\\left|(j_{p} j_{n}) J' M'\\right\\rangle$. Then, specialize to the physically allowed case with $k = 2$, $K = 2$, $J = 4$, and $J' = 2$, and express the final result explicitly in terms of $q_{p}$, $q_{n}$, and a single angular momentum recoupling coefficient. Your final answer must be a single closed-form analytic expression. No numerical rounding is required, and no physical units should be included in the final expression.",
            "solution": "The problem is valid as it is scientifically grounded in the quantum theory of angular momentum, is well-posed with all necessary information provided, and is mathematically consistent. We can therefore proceed with the derivation.\n\nThe objective is to derive an expression for the reduced matrix element of a two-body tensor operator, $O^{(K)}$, between coupled two-nucleon states. The operator is defined as the coupled tensor product of two single-body spherical tensor operators, $t^{(k)}(p)$ and $t^{(k)}(n)$, which act on the proton and neutron spaces, respectively:\n$$\nO^{(K)} \\equiv \\left[t^{(k)}(p) \\otimes t^{(k)}(n)\\right]^{(K)}\n$$\nThe states are coupled states of the form $\\left|(j_{p} j_{n}) J M\\right\\rangle$. We are asked to find the reduced matrix element $\\left\\langle (j_{p} j_{n}) J \\left\\| O^{(K)} \\right\\| (j_{p} j_{n}) J' \\right\\rangle$.\n\nThis is a standard problem in the application of angular momentum algebra. The reduced matrix element of a coupled tensor operator $X^{(K)} = [T^{(k_1)}(1) \\otimes T^{(k_2)}(2)]^{(K)}$ acting between coupled states $\\left|(j_1 j_2) J\\right\\rangle$ and $\\left|(j'_1 j'_2) J'\\right\\rangle$ is given by a well-established formula involving the Wigner 9j-symbol. This formula is a direct consequence of the Wigner-Eckart theorem and the rules for recoupling angular momenta. The general formula is:\n$$\n\\left\\langle (j_1 j_2) J \\left\\| \\left[T^{(k_1)}(1) \\otimes T^{(k_2)}(2)\\right]^{(K)} \\right\\| (j'_1 j'_2) J' \\right\\rangle = \\sqrt{(2J+1)(2J'+1)(2K+1)} \\begin{Bmatrix} j_1 & j_2 & J \\\\ j'_1 & j'_2 & J' \\\\ k_1 & k_2 & K \\end{Bmatrix} \\left\\langle j_1 \\left\\| T^{(k_1)} \\right\\| j'_1 \\right\\rangle \\left\\langle j_2 \\left\\| T^{(k_2)} \\right\\| j'_2 \\right\\rangle\n$$\nIn this expression, the quantities $\\left\\langle j \\left\\| T^{(k)} \\right\\| j' \\right\\rangle$ are the reduced matrix elements of the single-body operators.\n\nWe adapt this general formula to the specifics of the current problem. The correspondences are as follows:\n- The two subsystems are the proton ($1 \\to p$) and the neutron ($2 \\to n$).\n- The single-particle angular momenta are $j_1=j'_1=j_p$ and $j_2=j'_2=j_n$, since we are calculating matrix elements diagonal in the single-particle spaces.\n- The single-body tensor operators are identical, $T^{(k_1)} = T^{(k_2)} = t^{(k)}$, so their ranks are equal, $k_1=k_2=k$.\n- The two-body operator is $O^{(K)}$ and the coupled states are $\\left|(j_p j_n) J\\right\\rangle$ and $\\left|(j_p j_n) J'\\right\\rangle$.\n\nSubstituting these into the general formula, we obtain:\n$$\n\\left\\langle (j_{p} j_{n}) J \\left\\| O^{(K)} \\right\\| (j_{p} j_{n}) J' \\right\\rangle = \\sqrt{(2J+1)(2J'+1)(2K+1)} \\begin{Bmatrix} j_p & j_n & J \\\\ j_p & j_n & J' \\\\ k & k & K \\end{Bmatrix} \\left\\langle j_p \\left\\| t^{(k)} \\right\\| j_p \\right\\rangle \\left\\langle j_n \\left\\| t^{(k)} \\right\\| j_n \\right\\rangle\n$$\nThe problem defines the single-body reduced matrix elements as $q_{p} \\equiv \\left\\langle j_{p} \\left\\| t^{(k)} \\right\\| j_{p} \\right\\rangle$ and $q_{n} \\equiv \\left\\langle j_{n} \\left\\| t^{(k)} \\right\\| j_{n} \\right\\rangle$. Substituting these definitions yields the general analytic expression for the desired two-body reduced matrix element:\n$$\n\\left\\langle (j_{p} j_{n}) J \\left\\| O^{(K)} \\right\\| (j_{p} j_{n}) J' \\right\\rangle = q_p q_n \\sqrt{(2J+1)(2J'+1)(2K+1)} \\begin{Bmatrix} j_p & j_n & J \\\\ j_p & j_n & J' \\\\ k & k & K \\end{Bmatrix}\n$$\nThis completes the first part of the derivation.\n\nNext, we specialize this result to the specific values provided in the problem statement:\n- Proton angular momentum: $j_p = \\frac{3}{2}$\n- Neutron angular momentum: $j_n = \\frac{5}{2}$\n- Rank of the one-body tensor operator: $k = 2$\n- Total rank of the two-body operator: $K = 2$\n- Initial total angular momentum: $J = 4$\n- Final total angular momentum: $J' = 2$\n\nWe substitute these values into our derived expression. First, we evaluate the pre-factor involving the angular momentum quantum numbers:\n$$\n\\sqrt{(2J+1)(2J'+1)(2K+1)} = \\sqrt{(2(4)+1)(2(2)+1)(2(2)+1)} = \\sqrt{(9)(5)(5)} = \\sqrt{225} = 15\n$$\nThe Wigner 9j-symbol becomes:\n$$\n\\begin{Bmatrix}\nj_p & j_n & J \\\\ j_p & j_n & J' \\\\ k & k & K\n\\end{Bmatrix}\n=\n\\begin{Bmatrix}\n\\frac{3}{2} & \\frac{5}{2} & 4 \\\\\n\\frac{3}{2} & \\frac{5}{2} & 2 \\\\\n2 & 2 & 2\n\\end{Bmatrix}\n$$\nThe validity of these quantum numbers is confirmed by the triangle inequalities. For the couplings:\n- $(j_p, j_n) \\to J, J'$: $|\\frac{5}{2} - \\frac{3}{2}| = 1 \\le \\{2, 4\\} \\le \\frac{5}{2} + \\frac{3}{2} = 4$. This is satisfied.\n- $(J', K) \\to J$: $|2 - 2| = 0 \\le 4 \\le 2 + 2 = 4$. This is satisfied.\n- $(k,k) \\to K$: $|2-2|=0 \\le 2 \\le 2+2=4$. This is satisfied.\n\nCombining the pre-factor and the specific 9j-symbol, the final expression for the specialized reduced matrix element is:\n$$\n\\left\\langle \\left(j_{p}=\\frac{3}{2}, j_{n}=\\frac{5}{2}\\right) J=4 \\left\\| O^{(K=2)} \\right\\| \\left(j_{p}=\\frac{3}{2}, j_{n}=\\frac{5}{2}\\right) J'=2 \\right\\rangle = 15 \\, q_p \\, q_n \\begin{Bmatrix} \\frac{3}{2} & \\frac{5}{2} & 4 \\\\ \\frac{3}{2} & \\frac{5}{2} & 2 \\\\ 2 & 2 & 2 \\end{Bmatrix}\n$$\nThis expression is in terms of the given quantities $q_p$, $q_n$, and a single angular momentum recoupling coefficient (the Wigner 9j-symbol), as requested. The 9j-symbol is a fundamental quantity and represents a closed-form analytic expression.",
            "answer": "$$ \\boxed{15 \\, q_p \\, q_n \\begin{Bmatrix} \\frac{3}{2} & \\frac{5}{2} & 4 \\\\ \\frac{3}{2} & \\frac{5}{2} & 2 \\\\ 2 & 2 & 2 \\end{Bmatrix}} $$"
        },
        {
            "introduction": "In computational physics, ensuring the validity of your calculations is paramount. The non-vanishing of any Wigner symbol depends on strict adherence to triangle selection rules, and manually checking these in a complex calculation is prone to error. This final practice  transitions from analytical derivation to practical coding, tasking you with building a diagnostic tool to automate the validation of angular momentum coupling chains involving $6j$ and $9j$ symbols, a fundamental skill for any practitioner in this field.",
            "id": "3611517",
            "problem": "Construct a program that implements a diagnostic tool for angular momentum recoupling chains expressed via Wigner $6j$ and Wigner $9j$ symbols. The program must accept a specification consisting of discrete steps, where each step is one of two types: a Wigner $6j$ symbol or a Wigner $9j$ symbol. The goal is to automatically check the angular momentum triangle conditions at each intermediate coupling and suggest minimal fixes when illegal couplings appear.\n\nBegin from the fundamental base: the rules of addition of angular momenta and the associated non-vanishing conditions of Clebsch-Gordan coefficients. In this base, the allowed couplings are constrained by the triangle conditions. For any triple $(j_{1}, j_{2}, j_{3})$ representing the coupling of $j_{1}$ and $j_{2}$ to the resultant $j_{3}$, the triangle conditions are:\n- The triangle inequality: $$|j_{1} - j_{2}| \\leq j_{3} \\leq j_{1} + j_{2}.$$\n- The parity (integrality) condition: $j_{1} + j_{2} + j_{3} \\in \\mathbb{Z}$.\n\nTo avoid floating-point ambiguity in half-integer angular momenta, represent each angular momentum $j$ by the integer $n = 2j$. Thus, each $j$ is represented by a nonnegative integer $n = 2j$. The triangle conditions then become\n- $$|n_{1} - n_{2}| \\leq n_{3} \\leq n_{1} + n_{2},$$\n- $$n_{1} + n_{2} + n_{3} \\equiv 0 \\pmod{2}.$$\n\nFor a Wigner $6j$ symbol written as\n$$\\left\\{\\begin{array}{ccc}\na & b & c \\\\\nd & e & f\n\\end{array}\\right\\},$$\nthe non-vanishing conditions imply that four distinct triangle conditions must hold simultaneously:\n- $(a, b, c)$,\n- $(a, e, f)$,\n- $(d, b, f)$,\n- $(d, e, c)$,\nmeaning each of these triples must satisfy the triangle inequality and parity condition stated above.\n\nFor a Wigner $9j$ symbol written as\n$$\\left\\{\\begin{array}{ccc}\na & b & c \\\\\nd & e & f \\\\\ng & h & i\n\\end{array}\\right\\},$$\nthe non-vanishing conditions imply that six distinct triangle conditions must hold simultaneously: all three rows and all three columns must form valid coupling triples:\n- Row triangles: $(a, b, c)$, $(d, e, f)$, $(g, h, i)$,\n- Column triangles: $(a, d, g)$, $(b, e, h)$, $(c, f, i)$.\n\nIn this problem, each step supplies integer labels for the entries in the $6j$ or $9j$ symbol. A global mapping assigns each label an integer value $n = 2j$. Some labels are primary (external) angular momenta, while others are intermediates produced by couplings; however, your checking procedure only requires the current values to validate triangles and propose fixes. At each triangle, consider the third entry as the target for a minimal fix, which is the standard convention for a coupling $(j_{1}, j_{2}) \\to j_{3}$.\n\nMinimal fix rule: for an invalid triangle $(n_{1}, n_{2}, n_{3})$, propose a correction for $n_{3}$ that minimizes the absolute change $|n_{3}^{\\text{new}} - n_{3}|$, subject to the constraints\n- $$|n_{1} - n_{2}| \\leq n_{3}^{\\text{new}} \\leq n_{1} + n_{2},$$\n- $$n_{1} + n_{2} + n_{3}^{\\text{new}} \\equiv 0 \\pmod{2}.$$\nIf there is a tie in the minimal absolute change (two candidates equally close), choose the smaller $n_{3}^{\\text{new}}$.\n\nYour program must:\n- Encode test cases deterministically.\n- For each test case, validate all triangles implied by the chain of symbols.\n- For each invalid triangle, suggest a minimal fix for the third entry of the triple as per the rule above.\n- Aggregate per-test-case results into the final output format specified below.\n\nRepresent each angular momentum by its doubled integer $n = 2j$, as described above. There are no physical units to report.\n\nTest Suite:\nProvide the following test cases. In each case, the mapping specifies label identifiers to values, and the steps specify the sequence of checks. All labels and arguments are integers representing $2j$.\n\n- Test case $1$ (valid $6j$):\n  - Label mapping: $1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 3$, $4 \\mapsto 4$, $5 \\mapsto 3$, $6 \\mapsto 2$.\n  - Steps: one $6j$ step with entries $(1,2,3;4,5,6)$.\n\n- Test case $2$ (valid $6j$ at boundary):\n  - Label mapping: $1 \\mapsto 4$, $2 \\mapsto 2$, $3 \\mapsto 4$, $4 \\mapsto 5$, $5 \\mapsto 1$, $6 \\mapsto 3$.\n  - Steps: one $6j$ step with entries $(1,2,3;4,5,6)$.\n\n- Test case $3$ (invalid $6j$ due to parity of the resultant):\n  - Label mapping: $1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 2$, $4 \\mapsto 4$, $5 \\mapsto 3$, $6 \\mapsto 2$.\n  - Steps: one $6j$ step with entries $(1,2,3;4,5,6)$.\n\n- Test case $4$ (valid $9j$):\n  - Label mapping: $1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 3$, $4 \\mapsto 1$, $5 \\mapsto 3$, $6 \\mapsto 4$, $7 \\mapsto 2$, $8 \\mapsto 3$, $9 \\mapsto 5$.\n  - Steps: one $9j$ step with matrix rows $[1,2,3]$, $[4,5,6]$, $[7,8,9]$.\n\n- Test case $5$ (invalid $9j$ with conflicting triangles):\n  - Label mapping: $1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 3$, $4 \\mapsto 1$, $5 \\mapsto 3$, $6 \\mapsto 4$, $7 \\mapsto 2$, $8 \\mapsto 2$, $9 \\mapsto 5$.\n  - Steps: one $9j$ step with matrix rows $[1,2,3]$, $[4,5,6]$, $[7,8,9]$.\n\n- Test case $6$ (invalid $6j$ with resultant outside range):\n  - Label mapping: $1 \\mapsto 2$, $2 \\mapsto 1$, $3 \\mapsto 1$, $4 \\mapsto 3$, $5 \\mapsto 2$, $6 \\mapsto 5$.\n  - Steps: one $6j$ step with entries $(1,2,3;4,5,6)$.\n\nFinal Output Format:\nFor each test case, produce a list result\n$$[\\text{valid}, V, F],$$\nwhere $\\text{valid}$ is a boolean indicating whether all triangles in the chain are valid ($\\text{True}$ or $\\text{False}$), $V$ is the integer count of violated triangles, and $F$ is a list containing pairs $[\\,\\ell, n_{\\text{new}}\\,]$ for each violated triangle, where $\\ell$ is the label identifier and $n_{\\text{new}}$ is the suggested corrected value for that label under the minimal fix rule. If multiple triangles suggest a correction to the same label, include each suggestion separately in order of occurrence in the chain.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces, for example\n$$[r_{1},r_{2},\\dots],$$\nwhere each $r_{k}$ is the list for test case $k$ serialized similarly with no spaces. The output corresponding to the above test suite must be printed exactly in this serialized form.",
            "solution": "The problem requires the construction of a computational tool to validate coupling schemes in quantum angular momentum theory, specifically those involving Wigner $6j$ and $9j$ symbols. The core of this task lies in the repeated application of the fundamental triangle conditions that govern the addition of angular momenta.\n\nAn angular momentum coupling, denoted as $\\vec{J} = \\vec{J}_1 + \\vec{J}_2$, where $J$, $J_1$, and $J_2$ are the quantum numbers for the respective operators, is only permissible if the triad of quantum numbers $(j_1, j_2, j)$ satisfies certain conditions. These conditions ensure that the Clebsch-Gordan coefficient $\\langle j_1, m_1; j_2, m_2 | j, m \\rangle$ does not vanish. The quantum numbers $j$ must be non-negative integers or half-integers. To handle both cases uniformly and avoid floating-point arithmetic, it is standard practice to represent each angular momentum $j$ by the non-negative integer $n \\equiv 2j$. Under this transformation, the conditions for a valid coupling triad $(n_1, n_2, n_3)$ become:\n1. The triangle inequality: $|n_1 - n_2| \\leq n_3 \\leq n_1 + n_2$. This ensures the magnitudes of the vectors can form a closed triangle.\n2. The parity condition: $n_1 + n_2 + n_3 \\equiv 0 \\pmod{2}$. This is equivalent to the condition that $j_1 + j_2 + j_3$ must be an integer, which preserves the rotational properties of the wavefunction.\n\nThe Wigner $6j$ and $9j$ symbols are scalar quantities that arise in the recoupling of multiple angular momenta. Their non-vanishing is contingent upon several such triangle conditions being met simultaneously.\n\nFor a Wigner $6j$ symbol,\n$$\\left\\{\\begin{array}{ccc}\na & b & c \\\\\nd & e & f\n\\end{array}\\right\\}$$\nwhere each entry is a $j$ quantum number, there are four associated coupling triads that must all be valid. These triads represent the four couplings in the tetrahedal diagram associated with the $6j$ symbol. In terms of the $n=2j$ integer representation, these are: $(n_a, n_b, n_c)$, $(n_a, n_e, n_f)$, $(n_d, n_b, n_f)$, and $(n_d, n_e, n_c)$.\n\nFor a Wigner $9j$ symbol,\n$$\\left\\{\\begin{array}{ccc}\na & b & c \\\\\nd & e & f \\\\\ng & h & i\n\\end{array}\\right\\}$$\nwhich describes the transformation between two different coupling schemes of four angular momenta, the non-vanishing conditions are that each row and each column must form a valid coupling triad. This results in six triads to validate:\n- Rows: $(n_a, n_b, n_c)$, $(n_d, n_e, n_f)$, $(n_g, n_h, n_i)$.\n- Columns: $(n_a, n_d, n_g)$, $(n_b, n_e, n_h)$, $(n_c, n_f, n_i)$.\n\nThe algorithm to solve the problem is implemented as follows:\nFirst, a function `check_triangle` is defined to validate a single triad $(n_1, n_2, n_3)$. It checks if both the triangle inequality and the parity condition are satisfied. If the triad is invalid, it proceeds to find a \"minimal fix\" for the third element, $n_3$, as per the problem's specification.\n\nThe minimal fix logic is encapsulated in a function `find_minimal_fix`. For a given pair $(n_1, n_2)$ and an invalid $n_3$, this function determines the set of all possible allowed values for a new third element, $n_3^{\\text{new}}$. An integer $k$ is an allowed value if it satisfies $|n_1 - n_2| \\leq k \\leq n_1 + n_2$ and $n_1 + n_2 + k \\equiv 0 \\pmod{2}$. The function then iterates through this set of allowed values and finds the one, $n_{3,\\text{best}}^{\\text{new}}$, that minimizes the absolute difference $|n_3^{\\text{new}} - n_3|$. In case of a tie, where two allowed values are equidistant from $n_3$, the smaller of the two is chosen.\n\nThe main program logic iterates through a series of test cases. For each case, it resolves the integer labels into their corresponding $n=2j$ values from a provided mapping. It then identifies the type of symbol ($6j$ or $9j$) to be checked.\n\n- If a $6j$ symbol is specified by labels $(l_a,l_b,l_c; l_d,l_e,l_f)$, the program forms the four required triads of values $(n_a, n_b, n_c)$, $(n_a, n_e, n_f)$, $(n_d, n_b, n_f)$, and $(n_d, n_e, n_c)$. It calls `check_triangle` for each, passing the appropriate target label for the third element of each triad ($l_c$, $l_f$, $l_f$, $l_c$ respectively).\n\n- If a $9j$ symbol is specified, the program forms the six triads corresponding to the three rows and three columns. It then sequentially calls `check_triangle` for each of these triads. The target label for a row triad $(n_1, n_2, n_3)$ is the label of the third element. Similarly, for a column triad $(n_1, n_2, n_3)$, the target is the label of its third element.\n\nFor each test case, the program aggregates the results: a boolean flag indicating if all triads were valid, the total count of violations, and a list of all proposed minimal fixes. A custom serialization function is used to format these results into the precise string representation required, ensuring no extraneous spaces and converting boolean values to `True` or `False` as specified. This systematic, principle-based approach ensures a correct and robust diagnostic tool.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_minimal_fix(n1, n2, n3):\n    \"\"\"\n    Calculates the minimal fix for n3 in the invalid triangle (n1, n2, n3).\n\n    Args:\n        n1 (int): 2*j1\n        n2 (int): 2*j2\n        n3 (int): The original, incorrect 2*j3\n\n    Returns:\n        int: The corrected value n3_new that minimizes |n3_new - n3|.\n    \"\"\"\n    n_min = np.abs(n1 - n2)\n    n_max = n1 + n2\n    \n    # Required parity for n3_new: (n1 + n2 + n3_new) % 2 == 0\n    required_parity = (n1 + n2) % 2\n    \n    # Generate all valid candidates for n3_new\n    candidates = []\n    current_n = n_min\n    if current_n % 2 != required_parity:\n        current_n += 1\n    \n    while current_n = n_max:\n        candidates.append(current_n)\n        current_n += 2\n        \n    if not candidates:\n        # This should be an unreachable state for non-negative n1, n2.\n        return None \n        \n    # Find the candidate that minimizes the absolute change from n3\n    min_delta = float('inf')\n    best_n3_new = -1\n    \n    for cand in candidates:\n        delta = np.abs(cand - n3)\n        if delta  min_delta:\n            min_delta = delta\n            best_n3_new = cand\n        elif delta == min_delta:\n            # Tie-breaking rule: choose the smaller n3_new\n            best_n3_new = min(best_n3_new, cand)\n            \n    return best_n3_new\n\ndef check_triangle(triangle_values, target_label_id):\n    \"\"\"\n    Validates a single triangle and returns a fix if invalid.\n    \n    Args:\n        triangle_values (tuple): A tuple of three integers (n1, n2, n3).\n        target_label_id (int): The label of the third element, n3.\n        \n    Returns:\n        tuple: A pair (is_valid, fix_suggestion). \n               fix_suggestion is None if valid, or a list [label, n_new] if invalid.\n    \"\"\"\n    n1, n2, n3 = triangle_values\n    \n    is_inequality_ok = (np.abs(n1 - n2) = n3) and (n3 = n1 + n2)\n    is_parity_ok = ((n1 + n2 + n3) % 2) == 0\n    \n    if is_inequality_ok and is_parity_ok:\n        return (True, None)\n    else:\n        n3_new = find_minimal_fix(n1, n2, n3)\n        return (False, [target_label_id, n3_new])\n\ndef serialize_result(data):\n    \"\"\"\n    Serializes test case results into the specified string format.\n    \"\"\"\n    if isinstance(data, bool):\n        return 'True' if data else 'False'\n    if isinstance(data, (int, np.integer)):\n        return str(data)\n    if isinstance(data, list):\n        return f\"[{','.join(map(serialize_result, data))}]\"\n    return str(data)\n    \ndef solve():\n    \"\"\"\n    Main function to run the diagnostic tool on all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"label_map\": {1: 3, 2: 2, 3: 3, 4: 4, 5: 3, 6: 2},\n            \"steps\": [(\"6j\", (1, 2, 3, 4, 5, 6))]\n        },\n        {\n            \"label_map\": {1: 4, 2: 2, 3: 4, 4: 5, 5: 1, 6: 3},\n            \"steps\": [(\"6j\", (1, 2, 3, 4, 5, 6))]\n        },\n        {\n            \"label_map\": {1: 3, 2: 2, 3: 2, 4: 4, 5: 3, 6: 2},\n            \"steps\": [(\"6j\", (1, 2, 3, 4, 5, 6))]\n        },\n        {\n            \"label_map\": {1: 3, 2: 2, 3: 3, 4: 1, 5: 3, 6: 4, 7: 2, 8: 3, 9: 5},\n            \"steps\": [(\"9j\", ((1, 2, 3), (4, 5, 6), (7, 8, 9)))]\n        },\n        {\n            \"label_map\": {1: 3, 2: 2, 3: 3, 4: 1, 5: 3, 6: 4, 7: 2, 8: 2, 9: 5},\n            \"steps\": [(\"9j\", ((1, 2, 3), (4, 5, 6), (7, 8, 9)))]\n        },\n        {\n            \"label_map\": {1: 2, 2: 1, 3: 1, 4: 3, 5: 2, 6: 5},\n            \"steps\": [(\"6j\", (1, 2, 3, 4, 5, 6))]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        label_map = case[\"label_map\"]\n        steps = case[\"steps\"]\n\n        is_overall_valid = True\n        violated_count = 0\n        fixes = []\n\n        for step_type, labels in steps:\n            if step_type == \"6j\":\n                l_a, l_b, l_c, l_d, l_e, l_f = labels\n                v_a, v_b, v_c, v_d, v_e, v_f = (label_map[l] for l in labels)\n                \n                triangles_to_check = [\n                    ((v_a, v_b, v_c), l_c),\n                    ((v_a, v_e, v_f), l_f),\n                    ((v_d, v_b, v_f), l_f),\n                    ((v_d, v_e, v_c), l_c)\n                ]\n            \n            elif step_type == \"9j\":\n                l_a, l_b, l_c = labels[0]\n                l_d, l_e, l_f = labels[1]\n                l_g, l_h, l_i = labels[2]\n                \n                v_a, v_b, v_c = (label_map[l] for l in labels[0])\n                v_d, v_e, v_f = (label_map[l] for l in labels[1])\n                v_g, v_h, v_i = (label_map[l] for l in labels[2])\n                \n                triangles_to_check = [\n                    # Rows\n                    ((v_a, v_b, v_c), l_c), ((v_d, v_e, v_f), l_f), ((v_g, v_h, v_i), l_i),\n                    # Columns\n                    ((v_a, v_d, v_g), l_g), ((v_b, v_e, v_h), l_h), ((v_c, v_f, v_i), l_i)\n                ]\n\n            for tri_values, target_label in triangles_to_check:\n                is_valid, fix = check_triangle(tri_values, target_label)\n                if not is_valid:\n                    is_overall_valid = False\n                    violated_count += 1\n                    fixes.append(fix)\n        \n        all_results.append([is_overall_valid, violated_count, fixes])\n\n    # Final print statement in the exact required format.\n    output_str = f\"[{','.join(map(serialize_result, all_results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}