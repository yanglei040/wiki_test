{
    "hands_on_practices": [
        {
            "introduction": "角动量理论的威力在于它能将复杂的积分计算转化为简洁的代数运算。本练习将通过推导高斯系数（三个球谐函数的积分）与维格纳$3j$符号之间的关系，来巩固这一核心思想。完成这项练习将帮助你理解$3j$符号的物理起源，并熟练运用其选择定则来解决实际问题。",
            "id": "3611568",
            "problem": "在单个核子的球形平均场描述中，角动量耦合通过球谐函数和张量算符来处理。考虑由 $T^{(2)}_{\\mu} = e\\, r^{2} Y_{2 \\mu}(\\Omega)$ 定义的单体电四极矩算符，其中 $Y_{l m}(\\Omega)$ 是标准的 Condon–Shortley 球谐函数，其归一化条件为 $\\int Y_{l m}^{*}(\\Omega) Y_{l' m'}(\\Omega)\\, d\\Omega = \\delta_{l l'} \\delta_{m m'}$。$T^{(2)}_{\\mu}$ 矩阵元的角向依赖性可以分解为 Gaunt 系数，其对整数 $l_{1}, l_{2}, l_{3}$ 和 $m_{1}, m_{2}, m_{3}$ 的定义如下：\n$$\nG(l_{1} m_{1}; l_{2} m_{2}; l_{3} m_{3}) = \\int Y_{l_{1} m_{1}}(\\Omega)\\, Y_{l_{2} m_{2}}(\\Omega)\\, Y_{l_{3} m_{3}}(\\Omega)\\, d\\Omega.\n$$\n从球谐函数的定义、其正交性以及 Wigner–Eckart 定理 (WET) 的表述出发，推导 Gaunt 系数用 Wigner $3j$ 符号和总归一化因子表示的表达式，然后显式计算积分\n$$\nI = \\int Y_{1,0}(\\Omega)\\, Y_{2,0}(\\Omega)\\, Y_{1,0}(\\Omega)\\, d\\Omega.\n$$\n解释你使用的任何选择定则，并将最终结果以无数值近似的闭合形式解析表达式给出。最终答案无需单位。请勿对答案进行四舍五入。",
            "solution": "该问题是有效的。它在科学上基于角动量的量子理论，提法良好，有足够的信息得到唯一解，并且陈述客观。所有的定义和要求在理论和计算物理学中都是标准的。\n\n该问题要求完成两个主要任务：首先，推导用 Wigner $3j$ 符号表示的 Gaunt 系数的一般表达式；其次，计算该积分的一个具体实例。\n\n**第一部分：Gaunt 系数表达式的推导**\n\nGaunt 系数定义为三个球谐函数的乘积对立体角 $\\Omega$ 的积分：\n$$\nG(l_{1} m_{1}; l_{2} m_{2}; l_{3} m_{3}) = \\int Y_{l_{1} m_{1}}(\\Omega)\\, Y_{l_{2} m_{2}}(\\Omega)\\, Y_{l_{3} m_{3}}(\\Omega)\\, d\\Omega\n$$\n球谐函数对方位角 $\\phi$ 的依赖关系形式为 $Y_{lm}(\\theta, \\phi) \\propto \\exp(im\\phi)$。因此，对 $d\\Omega = \\sin\\theta\\,d\\theta\\,d\\phi$ 的积分包含一个因子：\n$$\n\\int_{0}^{2\\pi} \\exp(im_{1}\\phi) \\exp(im_{2}\\phi) \\exp(im_{3}\\phi)\\, d\\phi = \\int_{0}^{2\\pi} \\exp(i(m_1+m_2+m_3)\\phi)\\, d\\phi = 2\\pi \\delta_{m_1+m_2+m_3, 0}\n$$\n这立即建立了一条基本选择定则：只有当磁量子数之和为零时，即 $m_1+m_2+m_3=0$，Gaunt 系数才非零。这是由三个函数乘积构成的标量具有旋转不变性的结果。\n\n为了继续推导，我们利用两个球谐函数的乘积定理。该定理是角动量相加规则的直接推论，其原理被 Wigner-Eckart 定理 (WET) 所推广。两个球谐函数的乘积可以在单个球谐函数的基底下展开：\n$$\nY_{l_{2} m_{2}}(\\Omega)\\, Y_{l_{3} m_{3}}(\\Omega) = \\sum_{L, M} \\sqrt{\\frac{(2l_2+1)(2l_3+1)}{4\\pi(2L+1)}} \\langle l_2 0 l_3 0 | L 0 \\rangle \\langle l_2 m_2 l_3 m_3 | L M \\rangle Y_{L M}(\\Omega)\n$$\n这里，$\\langle j_1 m_1 j_2 m_2 | j_3 m_3 \\rangle$ 是一个 Clebsch-Gordan 系数。将此展开式代入 Gaunt 系数的积分中，得到：\n$$\nG = \\int Y_{l_{1} m_{1}}(\\Omega) \\left( \\sum_{L, M} \\sqrt{\\frac{(2l_2+1)(2l_3+1)}{4\\pi(2L+1)}} \\langle l_2 0 l_3 0 | L 0 \\rangle \\langle l_2 m_2 l_3 m_3 | L M \\rangle Y_{L M}(\\Omega) \\right) d\\Omega\n$$\n重新整理求和与积分：\n$$\nG = \\sum_{L, M} \\sqrt{\\frac{(2l_2+1)(2l_3+1)}{4\\pi(2L+1)}} \\langle l_2 0 l_3 0 | L 0 \\rangle \\langle l_2 m_2 l_3 m_3 | L M \\rangle \\int Y_{l_{1} m_{1}}(\\Omega) Y_{L M}(\\Omega) d\\Omega\n$$\n两个球谐函数的积分可以与正交性条件 $\\int Y_{l'm'}^*(\\Omega) Y_{lm}(\\Omega) d\\Omega = \\delta_{ll'}\\delta_{mm'}$ 联系起来。利用性质 $Y_{l'm'}^*(\\Omega) = (-1)^{m'} Y_{l', -m'}(\\Omega)$，我们可以写出：\n$$\n\\int Y_{l_{1} m_{1}} Y_{L M} d\\Omega = \\int (-1)^{-m_1} (Y_{l_1, -m_1})^* Y_{L M} d\\Omega = (-1)^{-m_1} \\delta_{l_1 L} \\delta_{-m_1 M}\n$$\n将此代回 G 的表达式中，对 L 和 M 的求和坍缩为一项，其中 $L=l_1$ 且 $M=-m_1$：\n$$\nG(l_{1} m_{1}; \\dots) = \\sqrt{\\frac{(2l_2+1)(2l_3+1)}{4\\pi(2l_1+1)}} \\langle l_2 0 l_3 0 | l_1 0 \\rangle \\langle l_2 m_2 l_3 m_3 | l_1, -m_1 \\rangle (-1)^{-m_1}\n$$\n接下来，我们使用以下关系式将 Clebsch-Gordan 系数转换为更对称的 Wigner $3j$ 符号：\n$$\n\\langle j_1 m_1 j_2 m_2 | j_3 m_3 \\rangle = (-1)^{j_1-j_2+m_3} \\sqrt{2j_3+1} \\begin{pmatrix} j_1  j_2  j_3 \\\\ m_1  m_2  -m_3 \\end{pmatrix}\n$$\n应用此关系式，并将 $m_1+m_2+m_3=0$ 代入，经过一系列代数运算和利用3j符号的对称性（列的偶置换不改变其值），我们可以得到最终表达式：\n$$\nG(l_1 m_1; l_2 m_2; l_3 m_3) = \\sqrt{\\frac{(2l_1+1)(2l_2+1)(2l_3+1)}{4\\pi}} \\begin{pmatrix} l_1  l_2  l_3 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} l_1  l_2  l_3 \\\\ m_1  m_2  m_3 \\end{pmatrix}\n$$\n该公式表明，仅当 $l_1+l_2+l_3$ 为偶数时（由第一个3j符号强制），Gaunt 系数才非零，这对应于宇称守恒。\n\n**第二部分：特定积分的计算**\n\n我们需要计算 $I = \\int Y_{1,0}(\\Omega)\\, Y_{2,0}(\\Omega)\\, Y_{1,0}(\\Omega)\\, d\\Omega$。这对应于 $G(l_1=1, m_1=0; l_2=2, m_2=0; l_3=1, m_3=0)$。\n首先检查选择定则：\n1.  磁量子数之和：$m_1+m_2+m_3 = 0+0+0=0$。满足。\n2.  三角不等式：对于角动量 $(1, 2, 1)$，我们有 $|1-2| \\le 1 \\le 1+2$，即 $1 \\le 1 \\le 3$。满足。\n3.  宇称条件：$l_1+l_2+l_3 = 1+2+1 = 4$，是偶数。满足。\n由于所有选择定则都得到满足，积分非零。\n\n使用推导出的公式：\n$$\nI = \\sqrt{\\frac{(2\\cdot1+1)(2\\cdot2+1)(2\\cdot1+1)}{4\\pi}} \\begin{pmatrix} 1  2  1 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} 1  2  1 \\\\ 0  0  0 \\end{pmatrix}\n$$\nWigner $3j$ 符号 $\\begin{pmatrix} 1  2  1 \\\\ 0  0  0 \\end{pmatrix}$ 的标准值为：\n$$\n\\begin{pmatrix} 1  2  1 \\\\ 0  0  0 \\end{pmatrix} = \\sqrt{\\frac{2}{15}}\n$$\n将此值代入 $I$ 的表达式：\n$$\nI = \\sqrt{\\frac{3 \\cdot 5 \\cdot 3}{4\\pi}} \\left(\\sqrt{\\frac{2}{15}}\\right)^2 = \\sqrt{\\frac{45}{4\\pi}} \\left(\\frac{2}{15}\\right) = \\frac{3\\sqrt{5}}{2\\sqrt{\\pi}} \\cdot \\frac{2}{15} = \\frac{3\\sqrt{5}}{15\\sqrt{\\pi}} = \\frac{\\sqrt{5}}{5\\sqrt{\\pi}} = \\sqrt{\\frac{5}{25\\pi}} = \\sqrt{\\frac{1}{5\\pi}}\n$$\n因此，该积分的精确值为 $\\sqrt{\\frac{1}{5\\pi}}$。",
            "answer": "$$\\boxed{\\sqrt{\\frac{1}{5\\pi}}}$$"
        },
        {
            "introduction": "在处理多体系统时，我们经常需要处理多个角动量的耦合和重耦合。本练习将问题从三体耦合（由$3j$符号描述）提升到更复杂的四体角动量问题，引入了维格纳$9j$符号。你将学习如何计算核壳模型中关键的两体算符的约化矩阵元，这是进行大规模核结构计算的一项基本技能。",
            "id": "3611519",
            "problem": "在一个计算核物理壳模型计算中，考虑一个由两个核子组成的系统，其中一个质子处于总角动量为 $j_{p} = \\frac{3}{2}$ 的单粒子轨道上，一个中子处于总角动量为 $j_{n} = \\frac{5}{2}$ 的单粒子轨道上。该两体算符由一个秩为 $k$ 的单体球张量 $t^{(k)}$（定义在单粒子空间上）通过耦合张量积构造而成，\n$$\nO^{(K)} \\equiv \\left[t^{(k)}(p) \\otimes t^{(k)}(n)\\right]^{(K)},\n$$\n其中 $K$ 是两体算符在总角动量空间中的合成秩，标记 $(p)$ 和 $(n)$ 分别指定作用于质子和中子。假设单体约化矩阵元\n$$\nq_{p} \\equiv \\left\\langle j_{p} \\left\\| t^{(k)} \\right\\| j_{p} \\right\\rangle, \\qquad q_{n} \\equiv \\left\\langle j_{n} \\left\\| t^{(k)} \\right\\| j_{n} \\right\\rangle\n$$\n是有限且非零的。\n\n从量子力学中角动量耦合的基本原理出发，特别是利用球张量算符的性质、Clebsch–Gordan系数和Wigner–Eckart定理，推导约化矩阵元\n$$\n\\left\\langle (j_{p} j_{n}) J \\left\\| O^{(K)} \\right\\| (j_{p} j_{n}) J' \\right\\rangle\n$$\n的解析表达式，该矩阵元位于双粒子耦合态 $\\left|(j_{p} j_{n}) J M\\right\\rangle$ 和 $\\left|(j_{p} j_{n}) J' M'\\right\\rangle$ 之间。然后，将结果具体化到物理上允许的情形，即 $k = 2$, $K = 2$, $J = 4$ 和 $J' = 2$，并用 $q_{p}$、$q_{n}$ 和一个单一的角动量重耦合系数明确表示最终结果。你的最终答案必须是一个单一的闭合形式解析表达式。不需要进行数值取整，最终表达式中也不应包含任何物理单位。",
            "solution": "该问题在科学上基于角动量的量子理论，是适定的（well-posed），提供了所有必要信息，并且在数学上是一致的。因此，我们可以进行推导。\n\n目标是推导两体张量算符 $O^{(K)}$ 在耦合的双核子态之间的约化矩阵元表达式。该算符定义为两个单体球张量算符 $t^{(k)}(p)$ 和 $t^{(k)}(n)$ 的耦合张量积，它们分别作用于质子和中子空间：\n$$\nO^{(K)} \\equiv \\left[t^{(k)}(p) \\otimes t^{(k)}(n)\\right]^{(K)}\n$$\n所述的态是形式为 $\\left|(j_{p} j_{n}) J M\\right\\rangle$ 的耦合态。我们需要求解约化矩阵元 $\\left\\langle (j_{p} j_{n}) J \\left\\| O^{(K)} \\right\\| (j_{p} j_{n}) J' \\right\\rangle$。\n\n这是角动量代数应用中的一个标准问题。一个作用于耦合态 $\\left|(j_1 j_2) J\\right\\rangle$ 和 $\\left|(j'_1 j'_2) J'\\right\\rangle$ 之间的耦合张量算符 $X^{(K)} = [T^{(k_1)}(1) \\otimes T^{(k_2)}(2)]^{(K)}$ 的约化矩阵元由一个涉及Wigner 9j符号的公认公式给出。该公式是Wigner-Eckart定理和角动量重耦合规则的直接推论。通用公式为：\n$$\n\\left\\langle (j_1 j_2) J \\left\\| \\left[T^{(k_1)}(1) \\otimes T^{(k_2)}(2)\\right]^{(K)} \\right\\| (j'_1 j'_2) J' \\right\\rangle = \\sqrt{(2J+1)(2J'+1)(2K+1)} \\begin{Bmatrix} j_1  j_2  J \\\\ j'_1  j'_2  J' \\\\ k_1  k_2  K \\end{Bmatrix} \\left\\langle j_1 \\left\\| T^{(k_1)} \\right\\| j'_1 \\right\\rangle \\left\\langle j_2 \\left\\| T^{(k_2)} \\right\\| j'_2 \\right\\rangle\n$$\n在此表达式中，量 $\\left\\langle j \\left\\| T^{(k)} \\right\\| j' \\right\\rangle$ 是单体算符的约化矩阵元。\n\n我们将此通用公式应用于当前问题的具体情况。对应关系如下：\n- 两个子系统是质子 ($1 \\to p$) 和中子 ($2 \\to n$) 。\n- 单粒子角动量为 $j_1=j'_1=j_p$ 和 $j_2=j'_2=j_n$，因为我们计算的是在单粒子空间中对角的矩阵元。\n- 单体张量算符是相同的，$T^{(k_1)} = T^{(k_2)} = t^{(k)}$，所以它们的秩相等，$k_1=k_2=k$。\n- 两体算符是 $O^{(K)}$，耦合态是 $\\left|(j_p j_n) J\\right\\rangle$ 和 $\\left|(j_p j_n) J'\\right\\rangle$。\n\n将这些代入通用公式，我们得到：\n$$\n\\left\\langle (j_{p} j_{n}) J \\left\\| O^{(K)} \\right\\| (j_{p} j_{n}) J' \\right\\rangle = \\sqrt{(2J+1)(2J'+1)(2K+1)} \\begin{Bmatrix} j_p  j_n  J \\\\ j_p  j_n  J' \\\\ k  k  K \\end{Bmatrix} \\left\\langle j_p \\left\\| t^{(k)} \\right\\| j_p \\right\\rangle \\left\\langle j_n \\left\\| t^{(k)} \\right\\| j_n \\right\\rangle\n$$\n问题将单体约化矩阵元定义为 $q_{p} \\equiv \\left\\langle j_{p} \\left\\| t^{(k)} \\right\\| j_{p} \\right\\rangle$ 和 $q_{n} \\equiv \\left\\langle j_{n} \\left\\| t^{(k)} \\right\\| j_{n} \\right\\rangle$。代入这些定义，可得到所求的两体约化矩阵元的通用解析表达式：\n$$\n\\left\\langle (j_{p} j_{n}) J \\left\\| O^{(K)} \\right\\| (j_{p} j_{n}) J' \\right\\rangle = q_p q_n \\sqrt{(2J+1)(2J'+1)(2K+1)} \\begin{Bmatrix} j_p  j_n  J \\\\ j_p  j_n  J' \\\\ k  k  K \\end{Bmatrix}\n$$\n这完成了推导的第一部分。\n\n接下来，我们将此结果具体化到问题陈述中给出的特定值：\n- 质子角动量: $j_p = \\frac{3}{2}$\n- 中子角动量: $j_n = \\frac{5}{2}$\n- 单体张量算符的秩: $k = 2$\n- 两体算符的总秩: $K = 2$\n- 初始总角动量: $J' = 2$  (注：在推导中 $J'$ 是初态， $J$ 是末态)\n- 末态总角动量: $J = 4$\n\n我们将这些值代入推导出的表达式中。首先，我们计算包含角动量量子数的前置因子：\n$$\n\\sqrt{(2J+1)(2J'+1)(2K+1)} = \\sqrt{(2(4)+1)(2(2)+1)(2(2)+1)} = \\sqrt{(9)(5)(5)} = \\sqrt{225} = 15\n$$\nWigner 9j符号变为：\n$$\n\\begin{Bmatrix}\nj_p  j_n  J \\\\\nj_p  j_n  J' \\\\\nk  k  K\n\\end{Bmatrix}\n=\n\\begin{Bmatrix}\n\\frac{3}{2}  \\frac{5}{2}  4 \\\\\n\\frac{3}{2}  \\frac{5}{2}  2 \\\\\n2  2  2\n\\end{Bmatrix}\n$$\n这些量子数的有效性可以通过三角不等式来验证。对于耦合：\n- $(j_p, j_n) \\to J, J'$: $|\\frac{5}{2} - \\frac{3}{2}| = 1 \\le \\{2, 4\\} \\le \\frac{5}{2} + \\frac{3}{2} = 4$。此条件满足。\n- $(J', K) \\to J$: $|2 - 2| = 0 \\le 4 \\le 2 + 2 = 4$。此条件满足。\n- $(k,k) \\to K$: $|2-2|=0 \\le 2 \\le 2+2=4$。此条件满足。\n\n结合前置因子和特定的9j符号，特定情况下的约化矩阵元的最终表达式为：\n$$\n\\left\\langle \\left(j_{p}=\\frac{3}{2}, j_{n}=\\frac{5}{2}\\right) J=4 \\left\\| O^{(K=2)} \\right\\| \\left(j_{p}=\\frac{3}{2}, j_{n}=\\frac{5}{2}\\right) J'=2 \\right\\rangle = 15 \\, q_p \\, q_n \\begin{Bmatrix} \\frac{3}{2}  \\frac{5}{2}  4 \\\\ \\frac{3}{2}  \\frac{5}{2}  2 \\\\ 2  2  2 \\end{Bmatrix}\n$$\n如题目所要求，此表达式用给定的量 $q_p$、$q_n$ 和一个单一的角动量重耦合系数（Wigner 9j符号）表示。9j符号是一个基本量，代表了一个闭合形式的解析表达式。",
            "answer": "$$ \\boxed{15 \\, q_p \\, q_n \\begin{Bmatrix} \\frac{3}{2}  \\frac{5}{2}  4 \\\\ \\frac{3}{2}  \\frac{5}{2}  2 \\\\ 2  2  2 \\end{Bmatrix}} $$"
        },
        {
            "introduction": "理论的精通最终要在实践中得到检验，尤其是在计算物理领域。本练习是一个综合性的实践任务，要求你将角动量耦合的代数规则转化为一个实用的计算工具。通过构建一个能够自动验证维格纳$6j$和$9j$符号三角条件的诊断程序，你将获得编写稳健、无误的物理模拟代码所必需的关键技能。",
            "id": "3611517",
            "problem": "构建一个程序，实现一个用于角动量重耦合链的诊断工具，该重耦合链通过 Wigner $6j$ 符号和 Wigner $9j$ 符号表示。该程序必须接受一个由离散步骤组成的规范，其中每个步骤是两种类型之一：Wigner $6j$ 符号或 Wigner $9j$ 符号。目标是在每个中间耦合处自动检查角动量三角形条件，并在出现非法耦合时建议最小修正。\n\n从基本原理开始：角动量相加的规则以及相关的 Clebsch-Gordan 系数的非零条件。在此基础上，允许的耦合受到三角形条件的约束。对于代表 $j_{1}$ 和 $j_{2}$ 耦合到合成角动量 $j_{3}$ 的任意三元组 $(j_{1}, j_{2}, j_{3})$，三角形条件为：\n- 三角不等式：$$|j_{1} - j_{2}| \\leq j_{3} \\leq j_{1} + j_{2}.$$\n- 宇称（整数性）条件：$$j_{1} + j_{2} + j_{3} \\in \\mathbb{Z}.$$\n\n为避免半整数角动量中的浮点数歧义，用整数 $2j$ 来表示每个角动量 $j$。因此，每个 $j$ 由一个非负整数 $n = 2j$ 表示。三角形条件随之变为：\n- $$|n_{1} - n_{2}| \\leq n_{3} \\leq n_{1} + n_{2},$$\n- $$n_{1} + n_{2} + n_{3} \\equiv 0 \\pmod{2}.$$\n\n对于一个写作\n$$\\left\\{\\begin{array}{ccc}\na  b  c \\\\\nd  e  f\n\\end{array}\\right\\}$$\n的 Wigner $6j$ 符号，其非零条件意味着四个不同的三角形条件必须同时成立：\n- $$(a, b, c),$$\n- $$(a, e, f),$$\n- $$(d, b, f),$$\n- $$(d, e, c),$$\n意味着这些三元组中的每一个都必须满足上述的三角不等式和宇称条件。\n\n对于一个写作\n$$\\left\\{\\begin{array}{ccc}\na  b  c \\\\\nd  e  f \\\\\ng  h  i\n\\end{array}\\right\\}$$\n的 Wigner $9j$ 符号，其非零条件意味着六个不同的三角形条件必须同时成立：所有三行和所有三列都必须形成有效的耦合三元组：\n- 行三角形：$$(a, b, c),\\quad (d, e, f),\\quad (g, h, i),$$\n- 列三角形：$$(a, d, g),\\quad (b, e, h),\\quad (c, f, i).$$\n\n在此问题中，每个步骤为 $6j$ 或 $9j$ 符号中的条目提供整数标签。一个全局映射为每个标签分配一个整数值 $n = 2j$。一些标签是初始（外部）角动量，而另一些是通过耦合产生的中间量；但是，您的检查过程仅需要当前值来验证三角形并提出修正。在每个三角形中，将第三个条目视为最小修正的目标，这是耦合 $(j_{1}, j_{2}) \\to j_{3}$ 的标准约定。\n\n最小修正规则：对于一个无效的三角形 $(n_{1}, n_{2}, n_{3})$，为 $n_{3}$ 提出一个修正，使绝对变化 $|n_{3}^{\\text{new}} - n_{3}|$ 最小化，同时满足以下约束条件：\n- $$|n_{1} - n_{2}| \\leq n_{3}^{\\text{new}} \\leq n_{1} + n_{2},$$\n- $$n_{1} + n_{2} + n_{3}^{\\text{new}} \\equiv 0 \\pmod{2}.$$\n如果最小绝对变化存在并列情况（两个候选值同样接近），则选择较小的 $n_{3}^{\\text{new}}$。\n\n您的程序必须：\n- 确定性地编码测试用例。\n- 对于每个测试用例，验证符号链所隐含的所有三角形。\n- 对于每个无效三角形，根据上述规则为三元组的第三个条目建议一个最小修正。\n- 将每个测试用例的结果汇总到下面指定的最终输出格式中。\n\n如上所述，用其两倍的整数值 $n = 2j$ 来表示每个角动量。没有需要报告的物理单位。\n\n测试套件：\n提供以下测试用例。在每个案例中，映射指定了标签标识符到值的对应关系，而步骤则指定了检查序列。所有标签和参数都是代表 $2j$ 的整数。\n\n- 测试用例 1 (有效的 $6j$)：\n  - 标签映射：$1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 3$, $4 \\mapsto 4$, $5 \\mapsto 3$, $6 \\mapsto 2$。\n  - 步骤：一个 $6j$ 步骤，条目为 $(1,2,3;4,5,6)$。\n\n- 测试用例 2 (边界上的有效 $6j$)：\n  - 标签映射：$1 \\mapsto 4$, $2 \\mapsto 2$, $3 \\mapsto 4$, $4 \\mapsto 5$, $5 \\mapsto 1$, $6 \\mapsto 3$。\n  - 步骤：一个 $6j$ 步骤，条目为 $(1,2,3;4,5,6)$。\n\n- 测试用例 3 (因合成角动量的宇称无效的 $6j$)：\n  - 标签映射：$1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 2$, $4 \\mapsto 4$, $5 \\mapsto 3$, $6 \\mapsto 2$。\n  - 步骤：一个 $6j$ 步骤，条目为 $(1,2,3;4,5,6)$。\n\n- 测试用例 4 (有效的 $9j$)：\n  - 标签映射：$1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 3$, $4 \\mapsto 1$, $5 \\mapsto 3$, $6 \\mapsto 4$, $7 \\mapsto 2$, $8 \\mapsto 3$, $9 \\mapsto 5$。\n  - 步骤：一个 $9j$ 步骤，矩阵行为 $[1,2,3]$, $[4,5,6]$, $[7,8,9]$。\n\n- 测试用例 5 (具有冲突三角形的无效 $9j$)：\n  - 标签映射：$1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 3$, $4 \\mapsto 1$, $5 \\mapsto 3$, $6 \\mapsto 4$, $7 \\mapsto 2$, $8 \\mapsto 2$, $9 \\mapsto 5$。\n  - 步骤：一个 $9j$ 步骤，矩阵行为 $[1,2,3]$, $[4,5,6]$, $[7,8,9]$。\n\n- 测试用例 6 (合成角动量超出范围的无效 $6j$)：\n  - 标签映射：$1 \\mapsto 2$, $2 \\mapsto 1$, $3 \\mapsto 1$, $4 \\mapsto 3$, $5 \\mapsto 2$, $6 \\mapsto 5$。\n  - 步骤：一个 $6j$ 步骤，条目为 $(1,2,3;4,5,6)$。\n\n最终输出格式：\n对于每个测试用例，生成一个列表结果\n$$[\\text{valid}, V, F],$$\n其中 $\\text{valid}$ 是一个布尔值，指示链中的所有三角形是否有效（$\\text{True}$ 或 $\\text{False}$），$V$ 是违规三角形的整数计数，而 $F$ 是一个包含对 $[\\,\\ell, n_{\\text{new}}\\,]$ 的列表，用于每个违规三角形，其中 $\\ell$ 是标签标识符，$n_{\\text{new}}$ 是根据最小修正规则为该标签建议的修正值。如果多个三角形对同一标签提出修正建议，则按照它们在链中出现的顺序分别包含每个建议。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来、以逗号分隔且无空格的结果列表，例如\n$$[r_{1},r_{2},\\dots],$$\n其中每个 $r_{k}$ 是测试用例 $k$ 的列表，同样以无空格的方式序列化。与上述测试套件相对应的输出必须严格按照此序列化形式打印。",
            "solution": "该问题要求构建一个计算工具，用于验证量子角动量理论中的耦合方案，特别是涉及 Wigner $6j$ 和 $9j$ 符号的方案。此任务的核心在于重复应用支配角动量相加的基本三角形条件。\n\n一个角动量耦合，表示为 $\\vec{J} = \\vec{J}_1 + \\vec{J}_2$，其中 $J$、$J_1$ 和 $J_2$ 是相应算子的量子数，仅当这组量子数 $(j_1, j_2, j)$ 满足特定条件时才是允许的。这些条件确保 Clebsch-Gordan 系数 $\\langle j_1, m_1; j_2, m_2 | j, m \\rangle$ 不为零。量子数 $j$ 必须是非负整数或半整数。为了统一处理这两种情况并避免浮点运算，标准做法是用非负整数 $n \\equiv 2j$ 来表示每个角动量 $j$。在这种转换下，一个有效耦合三元组 $(n_1, n_2, n_3)$ 的条件变为：\n1. 三角不等式：$|n_1 - n_2| \\leq n_3 \\leq n_1 + n_2$。这确保了矢量的大小可以构成一个闭合的三角形。\n2. 宇称条件：$n_1 + n_2 + n_3 \\equiv 0 \\pmod{2}$。这等同于 $j_1 + j_2 + j_3$ 必须是整数的条件，从而保持了波函数的旋转性质。\n\nWigner $6j$ 和 $9j$ 符号是在多个角动量重耦合中出现的标量。它们的非零性质取决于几个这样的三角形条件同时被满足。\n\n对于一个 Wigner $6j$ 符号，\n$$\\left\\{\\begin{array}{ccc}\na  b  c \\\\\nd  e  f\n\\end{array}\\right\\}$$\n其中每个条目都是一个 $j$ 量子数，有四个相关的耦合三元组必须全部有效。这些三元组代表了与 $6j$ 符号相关的四面体图中的四个耦合。用 $n=2j$ 的整数表示，它们是：$(n_a, n_b, n_c)$、$(n_a, n_e, n_f)$、$(n_d, n_b, n_f)$ 和 $(n_d, n_e, n_c)$。\n\n对于一个 Wigner $9j$ 符号，\n$$\\left\\{\\begin{array}{ccc}\na  b  c \\\\\nd  e  f \\\\\ng  h  i\n\\end{array}\\right\\}$$\n它描述了四个角动量的两种不同耦合方案之间的转换，其非零条件是每一行和每一列都必须形成一个有效的耦合三元组。这导致需要验证六个三元组：\n- 行：$(n_a, n_b, n_c)$、$(n_d, n_e, n_f)$、$(n_g, n_h, n_i)$。\n- 列：$(n_a, n_d, n_g)$、$(n_b, n_e, n_h)$、$(n_c, n_f, n_i)$。\n\n解决该问题的算法实现如下：\n首先，定义一个函数 `check_triangle` 来验证单个三元组 $(n_1, n_2, n_3)$。它检查三角不等式和宇称条件是否都满足。如果三元组无效，它会根据问题的规范，为第三个元素 $n_3$ 寻找一个“最小修正”。\n\n最小修正的逻辑封装在函数 `find_minimal_fix` 中。对于给定的配对 $(n_1, n_2)$ 和一个无效的 $n_3$，此函数确定新的第三个元素 $n_3^{\\text{new}}$ 的所有可能允许值的集合。一个整数 $k$ 是允许值，如果它满足 $|n_1 - n_2| \\leq k \\leq n_1 + n_2$ 和 $n_1 + n_2 + k \\equiv 0 \\pmod{2}$。然后，该函数遍历这组允许值，并找到使绝对差 $|n_3^{\\text{new}} - n_3|$ 最小化的那一个，即 $n_{3,\\text{best}}^{\\text{new}}$。在出现并列的情况下，即两个允许值与 $n_3$ 的距离相等，则选择两者中较小的一个。\n\n主程序逻辑遍历一系列测试用例。对于每个案例，它根据提供的映射将整数标签解析为其对应的 $n=2j$ 值。然后，它识别要检查的符号类型（$6j$ 或 $9j$）。\n\n- 如果一个 $6j$ 符号由标签 $(l_a,l_b,l_c; l_d,l_e,l_f)$ 指定，程序会形成所需的四个值的三元组 $(n_a, n_b, n_c)$、$(n_a, n_e, n_f)$、$(n_d, n_b, n_f)$ 和 $(n_d, n_e, n_c)$。它对每个三元组调用 `check_triangle`，并为每个三元组的第三个元素传递适当的目标标签（分别为 $l_c$、$l_f$、$l_f$、$l_c$）。\n\n- 如果指定了 $9j$ 符号，程序会形成对应于三行和三列的六个三元组。然后，它依次为每个三元组调用 `check_triangle`。对于行三元组 $(n_1, n_2, n_3)$，目标标签是第三个元素的标签。同样，对于列三元组 $(n_1, n_2, n_3)$，目标是其第三个元素的标签。\n\n对于每个测试用例，程序汇总结果：一个指示所有三元组是否都有效的布尔标志、违规的总数以及所有建议的最小修正的列表。使用一个自定义的序列化函数将这些结果格式化为所需的确切字符串表示，确保没有多余的空格，并按规定将布尔值转换为 `True` 或 `False`。这种系统化的、基于原理的方法确保了诊断工具的正确性和稳健性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_minimal_fix(n1, n2, n3):\n    \"\"\"\n    Calculates the minimal fix for n3 in the invalid triangle (n1, n2, n3).\n\n    Args:\n        n1 (int): 2*j1\n        n2 (int): 2*j2\n        n3 (int): The original, incorrect 2*j3\n\n    Returns:\n        int: The corrected value n3_new that minimizes |n3_new - n3|.\n    \"\"\"\n    n_min = np.abs(n1 - n2)\n    n_max = n1 + n2\n    \n    # Required parity for n3_new: (n1 + n2 + n3_new) % 2 == 0\n    required_parity = (n1 + n2) % 2\n    \n    # Generate all valid candidates for n3_new\n    candidates = []\n    current_n = n_min\n    if current_n % 2 != required_parity:\n        current_n += 1\n    \n    while current_n = n_max:\n        candidates.append(current_n)\n        current_n += 2\n        \n    if not candidates:\n        # This should be an unreachable state for non-negative n1, n2.\n        return None \n        \n    # Find the candidate that minimizes the absolute change from n3\n    min_delta = float('inf')\n    best_n3_new = -1\n    \n    for cand in candidates:\n        delta = np.abs(cand - n3)\n        if delta  min_delta:\n            min_delta = delta\n            best_n3_new = cand\n        elif delta == min_delta:\n            # Tie-breaking rule: choose the smaller n3_new\n            best_n3_new = min(best_n3_new, cand)\n            \n    return best_n3_new\n\ndef check_triangle(triangle_values, target_label_id):\n    \"\"\"\n    Validates a single triangle and returns a fix if invalid.\n    \n    Args:\n        triangle_values (tuple): A tuple of three integers (n1, n2, n3).\n        target_label_id (int): The label of the third element, n3.\n        \n    Returns:\n        tuple: A pair (is_valid, fix_suggestion). \n               fix_suggestion is None if valid, or a list [label, n_new] if invalid.\n    \"\"\"\n    n1, n2, n3 = triangle_values\n    \n    is_inequality_ok = (np.abs(n1 - n2) = n3) and (n3 = n1 + n2)\n    is_parity_ok = ((n1 + n2 + n3) % 2) == 0\n    \n    if is_inequality_ok and is_parity_ok:\n        return (True, None)\n    else:\n        n3_new = find_minimal_fix(n1, n2, n3)\n        return (False, [target_label_id, n3_new])\n\ndef serialize_result(data):\n    \"\"\"\n    Serializes test case results into the specified string format.\n    \"\"\"\n    if isinstance(data, bool):\n        return 'True' if data else 'False'\n    if isinstance(data, (int, np.integer)):\n        return str(data)\n    if isinstance(data, list):\n        return f\"[{','.join(map(serialize_result, data))}]\"\n    return str(data)\n    \ndef solve():\n    \"\"\"\n    Main function to run the diagnostic tool on all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"label_map\": {1: 3, 2: 2, 3: 3, 4: 4, 5: 3, 6: 2},\n            \"steps\": [(\"6j\", (1, 2, 3, 4, 5, 6))]\n        },\n        {\n            \"label_map\": {1: 4, 2: 2, 3: 4, 4: 5, 5: 1, 6: 3},\n            \"steps\": [(\"6j\", (1, 2, 3, 4, 5, 6))]\n        },\n        {\n            \"label_map\": {1: 3, 2: 2, 3: 2, 4: 4, 5: 3, 6: 2},\n            \"steps\": [(\"6j\", (1, 2, 3, 4, 5, 6))]\n        },\n        {\n            \"label_map\": {1: 3, 2: 2, 3: 3, 4: 1, 5: 3, 6: 4, 7: 2, 8: 3, 9: 5},\n            \"steps\": [(\"9j\", ((1, 2, 3), (4, 5, 6), (7, 8, 9)))]\n        },\n        {\n            \"label_map\": {1: 3, 2: 2, 3: 3, 4: 1, 5: 3, 6: 4, 7: 2, 8: 2, 9: 5},\n            \"steps\": [(\"9j\", ((1, 2, 3), (4, 5, 6), (7, 8, 9)))]\n        },\n        {\n            \"label_map\": {1: 2, 2: 1, 3: 1, 4: 3, 5: 2, 6: 5},\n            \"steps\": [(\"6j\", (1, 2, 3, 4, 5, 6))]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        label_map = case[\"label_map\"]\n        steps = case[\"steps\"]\n\n        is_overall_valid = True\n        violated_count = 0\n        fixes = []\n\n        for step_type, labels in steps:\n            if step_type == \"6j\":\n                l_a, l_b, l_c, l_d, l_e, l_f = labels\n                v_a, v_b, v_c, v_d, v_e, v_f = (label_map[l] for l in labels)\n                \n                triangles_to_check = [\n                    ((v_a, v_b, v_c), l_c),\n                    ((v_a, v_e, v_f), l_f),\n                    ((v_d, v_b, v_f), l_f),\n                    ((v_d, v_e, v_c), l_c)\n                ]\n            \n            elif step_type == \"9j\":\n                l_a, l_b, l_c = labels[0]\n                l_d, l_e, l_f = labels[1]\n                l_g, l_h, l_i = labels[2]\n                \n                v_a, v_b, v_c = (label_map[l] for l in labels[0])\n                v_d, v_e, v_f = (label_map[l] for l in labels[1])\n                v_g, v_h, v_i = (label_map[l] for l in labels[2])\n                \n                triangles_to_check = [\n                    # Rows\n                    ((v_a, v_b, v_c), l_c), ((v_d, v_e, v_f), l_f), ((v_g, v_h, v_i), l_i),\n                    # Columns\n                    ((v_a, v_d, v_g), l_g), ((v_b, v_e, v_h), l_h), ((v_c, v_f, v_i), l_i)\n                ]\n\n            for tri_values, target_label in triangles_to_check:\n                is_valid, fix = check_triangle(tri_values, target_label)\n                if not is_valid:\n                    is_overall_valid = False\n                    violated_count += 1\n                    fixes.append(fix)\n        \n        all_results.append([is_overall_valid, violated_count, fixes])\n\n    # Final print statement in the exact required format.\n    output_str = f\"[{','.join(map(serialize_result, all_results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}