{
    "hands_on_practices": [
        {
            "introduction": "理论与实验的连接是计算物理学的核心。本练习将引导你完成一个基本但至关重要的任务：从模拟的低能S波相移数据中，利用有效力程展开理论，提取中性粒子（如中子-质子）散射的两个基本参数——散射长度 $a$ 和有效力程 $r_e$。通过这个实践，你将掌握将非线性物理模型线性化、应用加权最小二乘法进行拟合以及进行严格的不确定性量化与相关性分析的关键技能。",
            "id": "3589013",
            "problem": "您的任务是设计并实现一个完整的、可运行的程序，在计算核物理的背景下，从低能 $s$-波相移数据中，通过有理论依据的加权最小二乘法提取散射长度和有效力程。该程序必须基于成熟的散射理论，并且必须量化参数的不确定性及其相关性。\n\n从弹性双体散射的以下基本原理出发：\n- 具有短程相互作用的径向 Schrödinger 方程会产生相移，对于低能 $s$-波散射，有效力程展开是连接可观测量和参数的一种广泛使用的表示方法。\n- 相移 $\\delta_0(k)$（其中 $k$ 是相对波数）是一个物理上可测量的量，$s$-波散射的有效力程展开通过一个级数将 $k \\cot \\delta_0(k)$ 与散射长度 $a$ 和有效力程 $r_e$ 联系起来，该级数的主导项在低 $k$ 值时有效。\n\n您的任务是：\n1. 从有效力程展开的基础上，推导出一个参数线性模型，该模型适用于使用具有已知不确定性的测量值 $\\delta_0(k)$ 进行加权最小二乘（Weighted Least Squares, WLS）回归。明确论证如何变换可观测量及其不确定性，以使模型在拟合参数上是线性的，并且权重能根据测量不确定性被正确定义。\n2. 为您得到的线性模型设计并实现 WLS 估计器，包括构建设计矩阵、根据测量不确定性计算权重以及求解正规方程组。\n3. 从拟合的线性参数中获得参数的点估计值 $(a,r_e)$，并利用 WLS 估计器的协方差矩阵，推导一个基于线性误差传播的不确定性量化过程。推导并计算参数的标准差及其相关系数。同时，提出一种补充方法来评估参数不确定性和相关性，该方法对轻微的非线性和噪声异方差性具有鲁棒性。\n4. 将您的方法应用于以下合成数据集测试套件。对于每个数据集，首先通过有效力程展开计算无噪声的 $\\delta_0(k)$，然后添加具有指定标准差 $\\sigma_\\delta$ 和固定随机种子的高斯测量噪声以构建测量的相移，从而确保可复现性。角度必须以弧度为单位，$k$ 必须以 $\\mathrm{fm}^{-1}$ 为单位。散射长度 $a$ 和有效力程 $r_e$ 必须以 $\\mathrm{fm}$ 为单位报告。\n\n用于建模的基本原理：\n- 低能下的有效力程展开：\n$$\nk \\cot \\delta_0(k) = -\\frac{1}{a} + \\frac{1}{2} r_e k^2 + \\mathcal{O}(k^4).\n$$\n- 由此，定义一个参数线性的可观测量 $y(k)$，对 $k^2$ 的多项式进行回归，并提供从 $\\delta_0(k)$ 到 $y(k)$ 及其不确定性的变换。\n\n每个测试用例的合成数据生成协议：\n- 对于每个列出的波数 $k_i$，使用以下公式计算无噪声相移 $\\delta_0(k_i)$：\n$$\n\\tan \\delta_0(k_i) = \\frac{k_i}{-\\frac{1}{a_{\\text{true}}} + \\frac{1}{2} r_{e,\\text{true}} k_i^2}.\n$$\n- 然后添加独立的高斯噪声 $\\epsilon_i \\sim \\mathcal{N}(0,\\sigma_\\delta^2)$，使用指定的 $\\sigma_\\delta$ 和随机种子，得到测量值 $\\delta_{0,\\text{meas}}(k_i) = \\delta_0(k_i) + \\epsilon_i$。\n\n测试套件规格：\n- 案例 1 (通用“理想路径”案例)：\n  - 真实参数：$a_{\\text{true}} = 5.0\\,\\mathrm{fm}$，$r_{e,\\text{true}} = 1.8\\,\\mathrm{fm}$。\n  - 波数 $k$ (单位 $\\mathrm{fm}^{-1}$)：$[0.05,0.075,0.10,0.125,0.15,0.175,0.20,0.225,0.25,0.275,0.30]$。\n  - 噪声标准差：$\\sigma_\\delta = 0.01$ 弧度。\n  - 随机种子：$42$。\n- 案例 2 (近幺正性，大散射长度)：\n  - 真实参数：$a_{\\text{true}} = 100.0\\,\\mathrm{fm}$，$r_{e,\\text{true}} = 2.0\\,\\mathrm{fm}$。\n  - 波数 $k$ (单位 $\\mathrm{fm}^{-1}$)：$[0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.10,0.11,0.12]$。\n  - 噪声标准差：$\\sigma_\\delta = 0.005$ 弧度。\n  - 随机种子：$123$。\n- 案例 3 (边缘案例：极低 $k$ 值范围，参数分离困难)：\n  - 真实参数：$a_{\\text{true}} = 5.0\\,\\mathrm{fm}$，$r_{e,\\text{true}} = 1.8\\,\\mathrm{fm}$。\n  - 波数 $k$ (单位 $\\mathrm{fm}^{-1}$)：$[0.005,0.008,0.011,0.014,0.017,0.020]$。\n  - 噪声标准差：$\\sigma_\\delta = 0.005$ 弧度。\n  - 随机种子：$2021$。\n- 案例 4 (负散射长度，类虚态场景)：\n  - 真实参数：$a_{\\text{true}} = -20.0\\,\\mathrm{fm}$，$r_{e,\\text{true}} = 2.7\\,\\mathrm{fm}$。\n  - 波数 $k$ (单位 $\\mathrm{fm}^{-1}$)：$[0.05,0.075,0.10,0.125,0.15,0.175,0.20,0.225,0.25,0.275,0.30,0.325,0.35,0.375,0.40,0.425,0.45,0.475,0.50]$。\n  - 噪声标准差：$\\sigma_\\delta = 0.02$ 弧度。\n  - 随机种子：$7$。\n\n程序要求：\n- 实现 WLS 拟合，从线性化模型中获得以 $\\mathrm{fm}$ 为单位的参数估计值 $(a,r_e)$。\n- 使用线性参数的 WLS 协方差，通过线性误差传播来量化参数的不确定性（标准差）和相关系数。\n- 您的程序必须生成单行输出，其中包含一个以逗号分隔的 Python 列表的列表形式的结果，每个测试用例对应一个子列表，每个子列表包含 $[a_{\\text{fit}}, r_{e,\\text{fit}}, \\sigma_a, \\sigma_{r_e}, \\rho]$。所有角度均以弧度为单位，$k$ 以 $\\mathrm{fm}^{-1}$ 为单位。$a_{\\text{fit}}$、$r_{e,\\text{fit}}$、$\\sigma_a$ 和 $\\sigma_{r_e}$ 的单位是 $\\mathrm{fm}$，$\\rho$ 是无量纲的。\n\n最终打印的行必须具有确切的格式：包含结果的单行括号列表，例如 $[[x_1,y_1,\\ldots],[x_2,y_2,\\ldots],\\ldots]$，不得有任何附加文本。",
            "solution": "该问题是有效的。这是一个在计算核物理领域中提法恰当、有科学依据的问题，要求推导和实现一个标准的数据分析程序。所有必要的信息都已提供，并且任务定义明确。\n\n目标是使用加权最小二乘 (WLS) 拟合，从合成的相移数据 $\\delta_0(k)$ 中提取 $s$-波散射长度 $a$ 和有效力程 $r_e$。这包括将有效力程展开 (ERE) 提供的模型线性化，执行拟合，并将不确定性传播到最终的物理参数。\n\n**1. 线性模型和权重的推导**\n\n分析始于低能 $s$-波 ($l=0$) 散射的有效力程展开，它将给定相对波数 $k$ 处的相移 $\\delta_0$ 与散射参数 $a$ 和 $r_e$ 联系起来：\n$$\nk \\cot \\delta_0(k) = -\\frac{1}{a} + \\frac{1}{2} r_e k^2 + \\mathcal{O}(k^4)\n$$\n在低能情况下，$\\mathcal{O}(k^4)$ 及更高阶项可以忽略不计。截断级数后，如果我们适当地定义变量，就可以得到一个参数线性的模型。我们定义：\n- 一个自变量 $x_i = k_i^2$。\n- 一个因变量（可观测量）$y_i = k_i \\cot \\delta_{0,\\text{meas}}(k_i)$，其中 $\\delta_{0,\\text{meas}}(k_i)$ 是在波数 $k_i$ 处的测量相移。\n- 拟合参数 $c_0 = -1/a$ 和 $c_1 = r_e/2$。\n\n通过这些定义，ERE 变成一个线性方程：\n$$\ny_i = c_0 + c_1 x_i\n$$\n这是一个简单的线性回归模型。我们可以通过拟合变换后的数据点 $(x_i, y_i)$ 来确定系数 $c_0$ 和 $c_1$。\n\n为了执行*加权*最小二乘拟合，我们需要将测量的相移 $\\delta_{0,i}$ 的不确定性传播到变换后的可观测量 $y_i$ 上。问题陈述每个测量的相移 $\\delta_{0,i}$ 都有一个相关的不确定性 $\\sigma_{\\delta,i}$。使用一阶误差传播， $y_i = k_i \\cot \\delta_{0,i}$ 的方差 $\\sigma_{y,i}^2$ 是：\n$$\n\\sigma_{y,i}^2 = \\left( \\frac{\\partial y_i}{\\partial \\delta_{0,i}} \\right)^2 \\sigma_{\\delta,i}^2\n$$\n导数是：\n$$\n\\frac{\\partial y_i}{\\partial \\delta_{0,i}} = \\frac{\\partial}{\\partial \\delta_{0,i}} (k_i \\cot \\delta_{0,i}) = k_i (-\\csc^2 \\delta_{0,i}) = -k_i (1 + \\cot^2 \\delta_{0,i})\n$$\n因此，方差是：\n$$\n\\sigma_{y,i}^2 = \\left( -k_i (1 + \\cot^2 \\delta_{0,i}) \\right)^2 \\sigma_{\\delta,i}^2 = k_i^2 (1 + \\cot^2 \\delta_{0,i})^2 \\sigma_{\\delta,i}^2\n$$\n在实践中，我们使用测量的相移 $\\delta_{0,\\text{meas}}(k_i)$ 来估计此表达式中 $\\cot \\delta_{0,i}$ 的值。在 WLS 擬合中，每個數據點 $(x_i, y_i)$ 的權重是此方差的倒數：\n$$\nw_i = \\frac{1}{\\sigma_{y,i}^2} = \\frac{1}{k_i^2 (1 + \\cot^2 \\delta_{0,\\text{meas}}(k_i))^2 \\sigma_{\\delta,i}^2}\n$$\n\n**2. 加权最小二乘 (WLS) 形式体系**\n\nWLS 方法寻找使卡方函数 $\\chi^2$ 最小化的参数矢量 $\\mathbf{p} = [c_0, c_1]^T$：\n$$\n\\chi^2(\\mathbf{p}) = \\sum_{i=1}^{N} w_i (y_i - (c_0 + c_1 x_i))^2\n$$\n其中 $N$ 是数据点的数量。这可以用矩阵形式表示。设 $\\mathbf{y}$ 是观测值的 $N \\times 1$ 向量 $[y_1, \\dots, y_N]^T$，$\\mathbf{X}$ 是 $N \\times 2$ 的设计矩阵，$\\mathbf{W}$ 是 $N \\times N$ 的对角权重矩阵。\n$$\n\\mathbf{X} = \\begin{pmatrix} 1  x_1 \\\\ 1  x_2 \\\\ \\vdots  \\vdots \\\\ 1  x_N \\end{pmatrix} = \\begin{pmatrix} 1  k_1^2 \\\\ 1  k_2^2 \\\\ \\vdots  \\vdots \\\\ 1  k_N^2 \\end{pmatrix}, \\quad \\mathbf{W} = \\begin{pmatrix} w_1  0  \\dots \\\\ 0  w_2  \\dots \\\\ \\vdots  \\vdots  \\ddots \\end{pmatrix}\n$$\n$\\chi^2$ 函数则为 $\\chi^2 = (\\mathbf{y} - \\mathbf{Xp})^T \\mathbf{W} (\\mathbf{y} - \\mathbf{Xp})$。通过求解正规方程组可以找到最小值：\n$$\n(\\mathbf{X}^T \\mathbf{W} \\mathbf{X}) \\hat{\\mathbf{p}} = \\mathbf{X}^T \\mathbf{W} \\mathbf{y}\n$$\n估计参数矢量 $\\hat{\\mathbf{p}}$ 的解是：\n$$\n\\hat{\\mathbf{p}} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{W} \\mathbf{y}\n$$\n这提供了最佳拟合估计值 $\\hat{c}_0$ 和 $\\hat{c}_1$。\n\n**3. 不确定性量化**\n\n拟合参数 $\\hat{\\mathbf{p}}$ 的协方差矩阵由 $\\chi^2$ 函数的海森矩阵的逆给出：\n$$\n\\mathbf{C}_p = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} = \\begin{pmatrix} \\sigma_{c_0}^2  \\operatorname{cov}(c_0, c_1) \\\\ \\operatorname{cov}(c_0, c_1)  \\sigma_{c_1}^2 \\end{pmatrix}\n$$\n从拟合参数 $\\hat{c}_0$ 和 $\\hat{c}_1$ 中，我们获得物理参数 $\\hat{a}$ 和 $\\hat{r}_e$：\n$$\n\\hat{a} = -\\frac{1}{\\hat{c}_0}, \\quad \\hat{r}_e = 2 \\hat{c}_1\n$$\n$\\hat{a}$ 和 $\\hat{r}_e$ 的不确定性是通过使用协方差矩阵 $\\mathbf{C}_p$ 从 $\\hat{\\mathbf{p}}$ 的不确定性传播得到的。对于 $\\hat{a}$：\n$$\n\\sigma_a^2 \\approx \\left( \\frac{\\partial a}{\\partial c_0} \\right)^2 \\sigma_{c_0}^2 = \\left( \\frac{1}{c_0^2} \\right)^2 \\sigma_{c_0}^2 = a^4 \\sigma_{c_0}^2 \\implies \\sigma_a = |\\hat{a}^2| \\sigma_{c_0}\n$$\n对于 $\\hat{r}_e$：\n$$\n\\sigma_{r_e}^2 \\approx \\left( \\frac{\\partial r_e}{\\partial c_1} \\right)^2 \\sigma_{c_1}^2 = (2)^2 \\sigma_{c_1}^2 \\implies \\sigma_{r_e} = 2 \\sigma_{c_1}\n$$\n$\\hat{a}$ 和 $\\hat{r}_e$ 之间的协方差主要由 $\\hat{c}_0$ 和 $\\hat{c}_1$ 之间的协方差驱动，因为变换是独立的：\n$$\n\\operatorname{cov}(a, r_e) \\approx \\frac{\\partial a}{\\partial c_0} \\frac{\\partial r_e}{\\partial c_1} \\operatorname{cov}(c_0, c_1) = \\left(\\frac{1}{c_0^2}\\right) (2) \\operatorname{cov}(c_0, c_1) = 2 a^2 \\operatorname{cov}(c_0, c_1)\n$$\n相关系数 $\\rho$ 定义为 $\\rho = \\frac{\\operatorname{cov}(a, r_e)}{\\sigma_a \\sigma_{r_e}}$。代入推导出的表达式：\n$$\n\\rho = \\frac{2 a^2 \\operatorname{cov}(c_0, c_1)}{( |a^2| \\sigma_{c_0} ) (2 \\sigma_{c_1})} = \\frac{\\operatorname{cov}(c_0, c_1)}{\\sigma_{c_0} \\sigma_{c_1}} = \\rho_{c_0, c_1}\n$$\n物理参数 $(a, r_e)$ 的相关系数与线性拟合参数 $(c_0, c_1)$ 的相关系数相同，可以直接从协方差矩阵 $\\mathbf{C}_p$ 计算得出。\n\n一种用于评估不确定性的补充方法，对模型非线性和其他假设违规具有鲁棒性，是非参数自助法 (non-parametric bootstrap)。此过程包括：\n1. 通过从原始测量对 $(k_i, \\delta_{0,i})$ 集合中有放回地抽取 $N$ 个数据点，创建大量重采样数据集。\n2. 对每个重采样数据集执行整个 WLS 分析，以获得一对估计值 $(\\hat{a}^*, \\hat{r}_e^*)$。\n3. 这些估计值的集合构成了 $(\\hat{a}, \\hat{r}_e)$ 的经验分布。\n4. 这些分布的标准差可作为 $\\sigma_a$ 和 $\\sigma_{r_e}$ 的鲁棒估计，它们的样本相关系数提供了 $\\rho$ 的估计。\n根据主要要求，这里没有实现此方法，但它代表了一种标准且强大的验证技术。\n\n**4. 实现策略**\n\nPython 程序将对每个测试用例遵循以下步骤：\n1.  使用指定的种子初始化随机数生成器以保证可复现性。\n2.  对于给定的真实参数 $(a_{\\text{true}}, r_{e,\\text{true}})$ 和波数 $\\{k_i\\}$，生成无噪声相移 $\\delta_0(k_i) = \\arctan( k_i / (-1/a_{\\text{true}} + 0.5 r_{e,\\text{true}} k_i^2) )$。\n3.  添加均值为 $0$、标准差为 $\\sigma_\\delta$ 的高斯噪声，以创建“测量”的相移 $\\delta_{0,\\text{meas}}(k_i)$。\n4.  转换数据：构建向量 $\\mathbf{y}$，其元素为 $y_i = k_i \\cot(\\delta_{0,\\text{meas}}(k_i))$，以及设计矩阵 $\\mathbf{X}$，其行为 $[1, k_i^2]$。\n5.  使用上面推导的公式计算权重 $w_i = 1/\\sigma_{y,i}^2$，并构建对角权重矩阵 $\\mathbf{W}$。\n6.  求解正规方程组 $\\hat{\\mathbf{p}} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} (\\mathbf{X}^T \\mathbf{W} \\mathbf{y})$ 以找到 $\\hat{\\mathbf{p}} = [\\hat{c}_0, \\hat{c}_1]^T$。这可以通过首先计算 $\\mathbf{A} = \\mathbf{X}^T \\mathbf{W} \\mathbf{X}$ 和 $\\mathbf{b} = \\mathbf{X}^T \\mathbf{W} \\mathbf{y}$，然后求解系统 $\\mathbf{A}\\hat{\\mathbf{p}} = \\mathbf{b}$ 来高效完成。\n7.  计算参数协方差矩阵 $\\mathbf{C}_p = \\mathbf{A}^{-1}$。\n8.  将拟合参数转换为物理参数：$\\hat{a} = -1/\\hat{c}_0$ 和 $\\hat{r}_e = 2\\hat{c}_1$。\n9.  使用 $\\mathbf{C}_p$ 的元素传播不确定性，以找到 $\\sigma_a$、$\\sigma_{r_e}$ 和相关系数 $\\rho$。\n10. 存储结果元组 $(\\hat{a}, \\hat{r}_e, \\sigma_a, \\sigma_{r_e}, \\rho)$ 以用于最终输出。\n对于问题陈述中提供的所有四个测试用例，将重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for scattering length and effective range from synthetic phase-shift data\n    using a weighted least-squares fit on the linearized effective range expansion.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"a_true\": 5.0,\n            \"r_e_true\": 1.8,\n            \"k_values\": np.array([0.05, 0.075, 0.10, 0.125, 0.15, 0.175, 0.20, 0.225, 0.25, 0.275, 0.30]),\n            \"sigma_delta\": 0.01,\n            \"seed\": 42,\n        },\n        {\n            \"a_true\": 100.0,\n            \"r_e_true\": 2.0,\n            \"k_values\": np.array([0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.10, 0.11, 0.12]),\n            \"sigma_delta\": 0.005,\n            \"seed\": 123,\n        },\n        {\n            \"a_true\": 5.0,\n            \"r_e_true\": 1.8,\n            \"k_values\": np.array([0.005, 0.008, 0.011, 0.014, 0.017, 0.020]),\n            \"sigma_delta\": 0.005,\n            \"seed\": 2021,\n        },\n        {\n            \"a_true\": -20.0,\n            \"r_e_true\": 2.7,\n            \"k_values\": np.array([0.05, 0.075, 0.10, 0.125, 0.15, 0.175, 0.20, 0.225, 0.25, 0.275, 0.30, 0.325, 0.35, 0.375, 0.40, 0.425, 0.45, 0.475, 0.50]),\n            \"sigma_delta\": 0.02,\n            \"seed\": 7,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        a_true = case[\"a_true\"]\n        r_e_true = case[\"r_e_true\"]\n        k_values = case[\"k_values\"]\n        sigma_delta = case[\"sigma_delta\"]\n        seed = case[\"seed\"]\n\n        # Set random seed for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # 1. Generate synthetic data\n        # Theoretical k*cot(delta)\n        k_cot_delta_true = -1.0 / a_true + 0.5 * r_e_true * k_values**2\n        # Noiseless phase shifts\n        delta_true = np.arctan(k_values / k_cot_delta_true)\n        # Add Gaussian noise to create measured phase shifts\n        noise = rng.normal(0.0, sigma_delta, size=k_values.shape)\n        delta_meas = delta_true + noise\n\n        # 2. Linearize the model for WLS\n        # The model is y = c0 + c1*x, where y = k*cot(delta), x = k^2\n        x = k_values**2\n        cot_delta_meas = 1.0 / np.tan(delta_meas)\n        y = k_values * cot_delta_meas\n\n        # 3. Calculate weights for WLS\n        # sigma_y^2 = (d(k*cot(delta))/d(delta))^2 * sigma_delta^2\n        # d(k*cot(delta))/d(delta) = -k * csc^2(delta) = -k * (1 + cot^2(delta))\n        # We use the measured delta to estimate this.\n        sigma_y_sq = (k_values * (1 + cot_delta_meas**2))**2 * sigma_delta**2\n        weights = 1.0 / sigma_y_sq\n\n        # 4. Perform Weighted Least Squares fit\n        # We solve the normal equations: (X^T W X) p = X^T W y\n        # where p = [c0, c1]^T\n        \n        # Construct the design matrix X\n        X = np.vstack([np.ones_like(x), x]).T\n        \n        # Construct the diagonal weight matrix W\n        W = np.diag(weights)\n\n        # Form the matrices for the normal equations\n        XT_W_X = X.T @ W @ X\n        XT_W_y = X.T @ W @ y\n\n        # Solve for the parameter vector p_hat = [c0, c1]\n        try:\n            p_hat = np.linalg.solve(XT_W_X, XT_W_y)\n        except np.linalg.LinAlgError:\n            # Handle singular matrix case if it ever occurs\n            results.append([np.nan, np.nan, np.nan, np.nan, np.nan])\n            continue\n            \n        c0_fit, c1_fit = p_hat\n\n        # 5. Calculate physical parameters\n        a_fit = -1.0 / c0_fit\n        r_e_fit = 2.0 * c1_fit\n\n        # 6. Quantify uncertainties\n        # Covariance matrix of the fitted parameters p_hat is (X^T W X)^-1\n        cov_p = np.linalg.inv(XT_W_X)\n        sigma_c0_sq, sigma_c1_sq = cov_p[0, 0], cov_p[1, 1]\n        cov_c0_c1 = cov_p[0, 1]\n\n        # Propagate uncertainties to a and r_e\n        # sigma_a^2 = (da/dc0)^2 * sigma_c0^2 = (1/c0^2)^2 * sigma_c0^2 = a^4 * sigma_c0^2\n        sigma_a = np.abs(a_fit**2) * np.sqrt(sigma_c0_sq)\n        \n        # sigma_re^2 = (dre/dc1)^2 * sigma_c1^2 = 2^2 * sigma_c1^2\n        sigma_r_e = 2.0 * np.sqrt(sigma_c1_sq)\n\n        # Correlation coefficient rho(a, r_e) = rho(c0, c1)\n        rho = cov_c0_c1 / np.sqrt(sigma_c0_sq * sigma_c1_sq)\n\n        results.append([a_fit, r_e_fit, sigma_a, sigma_r_e, rho])\n\n    # Final print statement in the exact required format.\n    # The format required is a Python list literal string representation.\n    print(results)\n\nsolve()\n```"
        },
        {
            "introduction": "在现实的核物理问题中，我们常常需要处理带电粒子间的相互作用，例如质子-质子散射，其中长程库仑力不可忽略。本练习在前一个实践的基础上，引入了库仑修正的有效力程展开，这是一个更为复杂的理论框架。你将学习如何通过包含特殊库仑函数（如索末菲参数 $\\eta$ 和函数 $h(\\eta)$）的表达式来分离短程核力与长程库仑力的效应，并定量比较有无库仑力时散射参数的差异。",
            "id": "3588976",
            "problem": "你需要为低能核子-核子散射情境下的库仑修正有效力程展开推导、实现并验证一个计算程序。重点是在有和没有库仑相互作用情况下的$S$波（$l=0$）散射。从非相对论性薛定谔方程开始，该方程包含一个短程核势$V_N(r)$，对于带电粒子，还包含一个库仑势$V_C(r)=\\alpha Z_1 Z_2 / r$，其中$\\alpha$是精细结构常数，$Z_1, Z_2$是以质子电荷为单位的电荷量。利用分波散射理论和$S$矩阵在阈值附近的解析行为，构建一个在足够低的能量下与$k^2$呈线性的有效力程函数。对于中性粒子散射，这就是通常的有效力程展开。对于带电粒子，核相移是相对于库仑畸变波定义的，并且有效力程函数必须通过明确定义的库仑函数进行修正。\n\n你的任务是：\n- 从散射相移的基本定义和$S$矩阵在阈值附近的解析结构出发，推导$S$波的库仑修正有效力程展开，并指明修正中出现的特定库仑函数。仔细定义索末菲参数$\\eta$和库仑穿透因子，并说明为分离短程物理，需要从$k\\cot\\delta_0^C$中减去的函数形式。\n- 实现一个程序，该程序：\n  1. 使用推导出的领头阶库仑修正有效力程展开，为质子-质子（$pp$）散射构建合成的$S$波相移$\\delta_0^C(k)$。使用物理上一致的约化质量和一组指定的质心系能量，以产生科学上合理的$\\delta_0^C(k)$值。\n  2. 通过构建库仑修正的有效力程函数并对$k^2$进行线性回归，从合成的$\\delta_0^C(k)$中拟合库仑修正的散射长度$a_C$和有效力程$r_C$。\n  3. 使用领头阶的中性粒子有效力程展开，为中子-质子（$np$）散射构建合成的$S$波相移$\\delta_0(k)$，并以同样的方式拟合散射长度$a$和有效力程$r$。\n  4. 通过计算差值$a_C-a$和$r_C-r$，比较$pp$散射的拟合结果$(a_C,r_C)$和$np$散射的拟合结果$(a,r)$。\n\n实现所需的定义和单位：\n- 令$E_{\\mathrm{cm}}$为质心系能量，单位为$\\mathrm{MeV}$。波数$k=\\sqrt{2\\mu E_{\\mathrm{cm}}}/(\\hbar c)$，单位为$\\mathrm{fm}^{-1}$，其中$\\mu$是约化质量，单位为$\\mathrm{MeV}$，$\\hbar c$是约化普朗克常数与光速的乘积，单位为$\\mathrm{MeV\\,fm}$。使用$m_p c^2=938.2720813\\,\\mathrm{MeV}$、$m_n c^2=939.5654133\\,\\mathrm{MeV}$、$\\mu_{pp}=m_p/2$以及$\\mu_{np}=m_p m_n/(m_p+m_n)$。\n- $pp$散射的索末菲参数为$\\eta=\\alpha \\mu /(\\hbar c\\,k)$，其中$\\alpha=1/137.035999084$。\n- 所有相移$\\delta$的角度单位均为弧度。\n- 输出的散射长度和有效力程必须以飞米（$\\mathrm{fm}$）表示。\n\n测试套件规范：\n- 情况1（正常路径，$pp$带库仑相互作用）：$E_{\\mathrm{cm}}$值为$[0.25,0.5,1.0,2.0]$，单位为$\\mathrm{MeV}$。使用基准库仑修正参数$a_C^{\\mathrm{true}}=-7.82\\,\\mathrm{fm}$和$r_C^{\\mathrm{true}}=2.79\\,\\mathrm{fm}$来生成$\\delta_0^C(k)$。\n- 情况2（近阈值稳定性，$pp$带库仑相互作用）：$E_{\\mathrm{cm}}$值为$[0.05,0.10,0.20]$，单位为$\\mathrm{MeV}$，使用相同的$a_C^{\\mathrm{true}}$和$r_C^{\\mathrm{true}}$。\n- 情况3（中性粒子比较，$np$不带库仑相互作用）：$E_{\\mathrm{cm}}$值为$[0.25,0.5,1.0,2.0]$，单位为$\\mathrm{MeV}$。使用基准中性粒子参数$a^{\\mathrm{true}}=-23.75\\,\\mathrm{fm}$和$r^{\\mathrm{true}}=2.70\\,\\mathrm{fm}$来生成$\\delta_0(k)$。\n\n你的程序应产生单行输出，包含一个由方括号括起来的逗号分隔列表，其结果顺序如下：\n- 为情况1拟合的$a_C$和$r_C$，\n- 为情况2拟合的$a_C$和$r_C$，\n- 为情况3拟合的$a$和$r$，\n- 比较情况1（$pp$）与情况3（$np$）的差值$a_C-a$和$r_C-r$。\n\n因此，输出格式应严格为：\n\"[$a_C^{(1)},r_C^{(1)},a_C^{(2)},r_C^{(2)},a^{(3)},r^{(3)},a_C^{(1)}-a^{(3)},r_C^{(1)}-r^{(3)}]\"\n\n所有八个数字都必须是浮点数，$a_C$、$r_C$、$a$、$r$及其差值的单位必须是$\\mathrm{fm}$。",
            "solution": "该问题要求对$S$波（$l=0$）核子-核子散射（包括中性粒子$np$和带电粒子$pp$）的有效力程展开（ERE）进行推导和实现。解决方案在逻辑上分为两部分：首先，对必要公式进行理论推导；其次，描述实现该理论的计算过程。\n\n**第一部分：有效力程展开的理论推导**\n\n有效力程展开是低能弹性散射截面的一种不依赖于模型的参数化表示。它将散射相移与表征相互作用势的基本长度尺度——散射长度和有效力程——联系起来。其推导依赖于散射振幅在零能阈值（$k \\to 0$）附近的解析性质。\n\n**1.A. 中性粒子散射（例如，$np$）**\n\n对于两个通过短程核势$V_N(r)$相互作用的中性粒子的散射，约化质量粒子的$S$波（$l=0$）径向薛定谔方程为：\n$$\n\\frac{d^2u_0(r)}{dr^2} + \\left(k^2 - U_N(r)\\right)u_0(r) = 0\n$$\n其中$u_0(r)$是径向波函数，$k^2 = 2\\mu E_{\\mathrm{cm}}/\\hbar^2$是质心系波数的平方，$E_{\\mathrm{cm}}$是质心系能量，$\\mu$是约化质量，$U_N(r) = 2\\mu V_N(r)/\\hbar^2$是约化势。边界条件为$u_0(0)=0$。\n\n对于有限力程$R$的势（即当$r  R$时$V_N(r)=0$），势场区域外的波函数形式为：\n$$\nu_0(r) \\propto \\sin(kr + \\delta_0(k)), \\quad r  R\n$$\n其中$\\delta_0(k)$是$S$波核相移。散射过程的信息完全包含在$\\delta_0(k)$中。\n\n由Schwinger和Bethe发展的有效力程理论确立，对于短程势，函数$k \\cot\\delta_0(k)$在低能下是$k^2$的解析函数。因此，它可以在$k^2=0$附近展开为泰勒级数：\n$$\nk \\cot\\delta_0(k) = -\\frac{1}{a} + \\frac{1}{2} r k^2 + O(k^4)\n$$\n这就是标准的**有效力程展开**。参数$a$和$r$分别是散射长度和有效力程。\n- **散射长度$a$**定义为零能极限：$a = -\\lim_{k\\to 0} \\frac{\\tan\\delta_0(k)}{k}$。它表征了在零能量时相互作用的强度。\n- **有效力程$r$**表征了散射的能量依赖性，并与势的空间范围有关。\n\n**1.B. 带电粒子散射（例如，$pp$）**\n\n当散射粒子带电时，如在质子-质子（$pp$）散射中，必须包含长程库仑势$V_C(r) = \\alpha \\hbar c Z_1 Z_2 / r$。对于$pp$散射，$Z_1=Z_2=1$。$S$波径向薛定谔方程变为：\n$$\n\\frac{d^2u_0^C(r)}{dr^2} + \\left(k^2 - \\frac{2\\eta k}{r} - U_N(r)\\right)u_0^C(r) = 0\n$$\n这里，我们引入了无量纲的**索末菲参数$\\eta$**，它量化了库仑相互作用相对于动能的强度：\n$$\n\\eta = \\frac{\\alpha \\mu c^2}{\\hbar c k}\n$$\n其中$\\alpha$是精细结构常数。\n\n库仑势的长程性质（$1/r$）从根本上改变了波函数的渐近行为。简单的$\\sin(kr + \\delta_0)$形式不再有效。相反，$V_N(r)$力程范围外的解必须表示为正则（$F_0$）和非正则（$G_0$）$S$波库仑函数的线性组合：\n$$\nu_0^C(r) \\propto \\cos\\delta_0^C F_0(\\eta, kr) + \\sin\\delta_0^C G_0(\\eta, kr)\n$$\n相移$\\delta_0^C$是相对于纯库仑散射波测量的核相移。\n\n由于库仑相互作用，函数$k \\cot\\delta_0^C$在$k^2=0$处不是解析的。它包含与长程尾部相关的奇点。然而，可以构造一个在$k^2$中解析的修正函数。这个由Jackson和Blatt得出的结果就是**库仑修正的有效力程展开**：\n$$\nC_0^2(\\eta) k \\cot\\delta_0^C + 2k\\eta h(\\eta) = -\\frac{1}{a_C} + \\frac{1}{2} r_C k^2 + O(k^4)\n$$\n新的量是库仑穿透因子$C_0^2(\\eta)$和库仑函数$h(\\eta)$。$a_C$和$r_C$是库仑修正的散射长度和有效力程。\n\n此展开所需的函数是：\n- **$l=0$的库仑穿透因子**，$C_0^2(\\eta)$，它解释了排斥性库仑势垒对原点处波函数的抑制作用。它由下式给出：\n  $$\n  C_0^2(\\eta) = \\frac{2\\pi\\eta}{e^{2\\pi\\eta} - 1}\n  $$\n- 函数$h(\\eta)$的定义是为了抵消由库仑相互作用产生的剩余非解析项。它由下式给出：\n  $$\n  h(\\eta) = \\mathrm{Re}\\left[\\psi(i\\eta)\\right] - \\ln\\eta\n  $$\n  其中$\\psi(z) = \\frac{d}{dz}\\ln\\Gamma(z)$是digamma函数。\n\n问题要求指出必须从$k\\cot\\delta_0^C$中减去的函数形式。该公式并非简单的减法。$k\\cot\\delta_0^C$项首先乘以$C_0^2(\\eta)$，然后加上函数$2k\\eta h(\\eta)$。这个组合分离出了短程物理，产生一个在低能下近似与$k^2$成线性的函数：\n$$\nf(k^2) = C_0^2(\\eta) k \\cot\\delta_0^C + 2k\\eta h(\\eta)\n$$\n\n**第二部分：计算过程**\n\n实现过程包括两个主要步骤：（1）使用ERE公式和给定的“真实”参数生成合成相移数据，以及（2）从合成数据中拟合这些参数以验证该过程。\n\n**2.A. 数据生成**\n对于给定的一组质心系能量$E_{\\mathrm{cm},i}$，我们首先计算相应的波数$k_i = \\sqrt{2\\mu E_{\\mathrm{cm},i}} / (\\hbar c)$。然后，使用提供的真实参数（$a^{\\mathrm{true}}, r^{\\mathrm{true}}$），我们生成相移$\\delta_{0,i}$。\n\n- **对于中性粒子散射（$np$）**：\n  1. 计算ERE函数的值：$Y_i = -1/a^{\\mathrm{true}} + \\frac{1}{2}r^{\\mathrm{true}} k_i^2$。\n  2. 从定义$Y_i = k_i \\cot\\delta_{0,i}$解出相移：$\\delta_{0,i} = \\mathrm{arccot}(Y_i / k_i)$。\n\n- **对于带电粒子散射（$pp$）**：\n  1. 对每个$k_i$，计算相应的索末菲参数$\\eta_i = \\alpha \\mu_{pp} / (\\hbar c k_i)$。\n  2. 计算库仑函数$C_0^2(\\eta_i)$和$h(\\eta_i)$的值。\n  3. 计算库仑修正的ERE函数的值：$Y_i = -1/a_C^{\\mathrm{true}} + \\frac{1}{2}r_C^{\\mathrm{true}} k_i^2$。\n  4. 从定义$Y_i = C_0^2(\\eta_i) k_i \\cot\\delta_{0,i}^C + 2k_i\\eta_i h(\\eta_i)$解出相移：\n     $$\n     \\cot\\delta_{0,i}^C = \\frac{Y_i - 2k_i\\eta_i h(\\eta_i)}{C_0^2(\\eta_i) k_i}\n     $$\n     因此，$\\delta_{0,i}^C = \\mathrm{arccot}\\left(\\frac{Y_i - 2k_i\\eta_i h(\\eta_i)}{C_0^2(\\eta_i) k_i}\\right)$。\n\n在数值计算上，$\\mathrm{arccot}(x)$可以稳健地计算为$\\arctan(1/x)$，或者更好的方法是使用一个双参数反正切函数，如`numpy.arctan2`，以正确处理不同的象限和符号。\n\n**2.B. 参数拟合**\n有了合成数据集$\\{ (k_i, \\delta_{0,i}) \\}$和$\\{ (k_i, \\delta_{0,i}^C) \\}$，我们可以执行线性回归来提取散射参数。模型是$y = A + Bx$，其中$x=k^2$，$A = -1/a$，$B = r/2$。\n\n- **对于中性粒子散射（$np$）**：\n  1. 构建用于拟合的数据点：$(x_i, y_i) = (k_i^2, k_i \\cot\\delta_{0,i})$。\n  2. 对这些点进行线性拟合$y = A + Bx$。确定斜率$B$和截距$A$。\n  3. 拟合参数为$a_{\\mathrm{fit}} = -1/A$和$r_{\\mathrm{fit}} = 2B$。\n\n- **对于带电粒子散射（$pp$）**：\n  1. 构建用于拟合的数据点：$(x_i, y_i) = (k_i^2, C_0^2(\\eta_i) k_i \\cot\\delta_{0,i}^C + 2k_i\\eta_i h(\\eta_i))$。\n  2. 进行线性拟合$y = A + Bx$。\n  3. 拟合参数为$a_{C, \\mathrm{fit}} = -1/A$和$r_{C, \\mathrm{fit}} = 2B$。\n\n这个生成数据并用相同模型将其拟合回去的过程，是对理论公式数值实现正确性的一个关键验证测试。一个成功的实现应该能够高精度地恢复输入的基准参数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import psi\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates the Coulomb-modified effective-range expansion\n    for low-energy nucleon-nucleon scattering.\n    \"\"\"\n\n    # Physical constants and definitions\n    m_p_c2 = 938.2720813  # MeV\n    m_n_c2 = 939.5654133  # MeV\n    hbar_c = 197.3269804  # MeV fm\n    alpha = 1.0 / 137.035999084\n\n    # Reduced masses in MeV\n    mu_pp = m_p_c2 / 2.0\n    mu_np = (m_p_c2 * m_n_c2) / (m_p_c2 + m_n_c2)\n\n    # Test suite specification\n    test_cases = [\n        {\n            \"name\": \"Case 1 (pp)\",\n            \"type\": \"pp\",\n            \"mu\": mu_pp,\n            \"E_cm_MeV\": np.array([0.25, 0.5, 1.0, 2.0]),\n            \"a_true\": -7.82,  # fm\n            \"r_true\": 2.79,   # fm\n        },\n        {\n            \"name\": \"Case 2 (pp)\",\n            \"type\": \"pp\",\n            \"mu\": mu_pp,\n            \"E_cm_MeV\": np.array([0.05, 0.10, 0.20]),\n            \"a_true\": -7.82,  # fm\n            \"r_true\": 2.79,   # fm\n        },\n        {\n            \"name\": \"Case 3 (np)\",\n            \"type\": \"np\",\n            \"mu\": mu_np,\n            \"E_cm_MeV\": np.array([0.25, 0.5, 1.0, 2.0]),\n            \"a_true\": -23.75,  # fm\n            \"r_true\": 2.70,   # fm\n        },\n    ]\n\n    results = {}\n\n    for case in test_cases:\n        E_cm = case[\"E_cm_MeV\"]\n        mu = case[\"mu\"]\n        a_true = case[\"a_true\"]\n        r_true = case[\"r_true\"]\n        case_type = case[\"type\"]\n        case_name = case[\"name\"]\n\n        # Calculate wave number k in fm^-1\n        k = np.sqrt(2.0 * mu * E_cm) / hbar_c\n\n        # --- 1. Generate synthetic phase shifts ---\n        delta = None\n        if case_type == \"np\":\n            # Neutral particle ERE: k * cot(delta) = -1/a + 0.5 * r * k^2\n            Y_true = -1.0 / a_true + 0.5 * r_true * k**2\n            # delta = arccot(Y_true / k)\n            delta = np.arctan2(k, Y_true)\n        \n        elif case_type == \"pp\":\n            # Coulomb-modified ERE\n            eta = alpha * mu / (hbar_c * k)\n            \n            # C_0^2(eta) = 2*pi*eta / (exp(2*pi*eta) - 1)\n            C0_squared = 2.0 * np.pi * eta / np.expm1(2.0 * np.pi * eta)\n            \n            # h(eta) = Re[psi(i*eta)] - ln(eta)\n            h_eta = np.real(psi(1j * eta)) - np.log(eta)\n            \n            # Y_true = -1/a_C + 0.5 * r_C * k^2\n            Y_true = -1.0 / a_true + 0.5 * r_true * k**2\n            \n            # Y_true = C0_squared * k * cot(delta) + 2*k*eta*h(eta)\n            # -- cot(delta) = (Y_true - 2*k*eta*h(eta)) / (C0_squared * k)\n            cot_delta_numerator = Y_true - 2.0 * k * eta * h_eta\n            cot_delta_denominator = C0_squared * k\n            delta = np.arctan2(cot_delta_denominator, cot_delta_numerator)\n\n        # --- 2. Fit parameters from synthetic data ---\n        \n        # Construct the linear system y = A + B*x for fitting\n        # x = k^2, y = ERE function\n        x_fit = k**2\n        y_fit = None\n        \n        if case_type == \"np\":\n            y_fit = k * (1.0 / np.tan(delta))\n        \n        elif case_type == \"pp\":\n            eta = alpha * mu / (hbar_c * k)\n            C0_squared = 2.0 * np.pi * eta / np.expm1(2.0 * np.pi * eta)\n            h_eta = np.real(psi(1j * eta)) - np.log(eta)\n            y_fit = C0_squared * k * (1.0 / np.tan(delta)) + 2.0 * k * eta * h_eta\n            \n        # Perform linear regression: y_fit = slope * x_fit + intercept\n        # slope = B = r/2, intercept = A = -1/a\n        # np.polyfit returns [slope, intercept]\n        p = np.polyfit(x_fit, y_fit, 1)\n        slope, intercept = p[0], p[1]\n        \n        a_fit = -1.0 / intercept\n        r_fit = 2.0 * slope\n        \n        results[case_name] = (a_fit, r_fit)\n\n    # --- 3. Compile final output list ---\n    aC1, rC1 = results[\"Case 1 (pp)\"]\n    aC2, rC2 = results[\"Case 2 (pp)\"]\n    a3, r3 = results[\"Case 3 (np)\"]\n\n    diff_a = aC1 - a3\n    diff_r = rC1 - r3\n    \n    final_output = [aC1, rC1, aC2, rC2, a3, r3, diff_a, diff_r]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_output))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了在坐标空间求解薛定谔方程，动量空间中的Lippmann-Schwinger (LS) 方程为散射问题提供了另一种强大而深刻的视角。本练习将引导你在动量空间中求解S波散射的LS积分方程，并使用可分离势这一经典模型。你将通过解析推导将积分方程简化为代数方程，并学习如何使用高斯-勒让德求积法和坐标变换技术，来处理在数值计算中遇到的主值奇点和半无穷积分区间等高级挑战。",
            "id": "3589031",
            "problem": "考虑在动量空间中，由球对称短程相互作用引起的无自旋粒子的非相对论性双体弹性散射。以非相对论性不含时薛定谔方程和中心势为基本出发点。通过投影到分波上并使用自由预解算符（能量格林函数），可以得到分波跃迁矩阵的动量空间Lippmann-Schwinger方程，在当前归一化下其形式为\n$$\nt_l(p',p;E)= v_l(p',p) + \\int_0^\\infty dq\\, q^2\\, \\frac{v_l(p',q)\\, t_l(q,p;E)}{E - \\hbar^2 q^2/(2\\mu) + i0},\n$$\n其中$l$是轨道角动量，$p$和$p'$是入射和出射动量的大小，$E$是质心系能量，$\\mu$是约化质量，$\\hbar$是约化普朗克常数。$+i0$项表示选取向外传播波边界条件的极限过程。\n\n您的任务是，在无量纲单位下，使用可分离的Yamaguchi型势，为$l=0$（s波）情况推导、离散化并实现一个求解器，并计算s波相移。您必须从第一性原理和定义（薛定谔方程和Lippmann-Schwinger方程）出发，不使用任何简便公式，并使用带有理红外-紫外映射的Gauss-Legendre求积法来设计离散化。离散化过程必须得到精确的描述和实现。\n\n为确保普遍适用性和数学清晰度，请采用以下无量纲设置：\n- 设$\\hbar^2/(2\\mu)=1$，使得能量和动量的平方具有相同的单位。\n- 使用一个可分离的s波势\n$$\nv_0(p',p) = -\\lambda \\frac{1}{(p'^2+1)}\\frac{1}{(p^2+1)},\n$$\n其中$\\lambda0$是一个无量纲耦合强度，且通过定义无量纲动量$p\\to p/\\beta$并选择合适的$\\beta$使得分母为$p^2+1$，已将力程参数缩放为1。\n\n在这些单位中，通过$k=\\sqrt{E}$定义在壳动量$k$。为避免能量分母在$q=k$处引入的奇点，您必须通过将预解算符替换为其柯西主值来计算实主值$K$矩阵，\n$$\nK_0(p',p;E)= v_0(p',p) + \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{v_0(p',q)\\, K_0(q,p;E)}{E - q^2}.\n$$\n对于可分离势，在壳s波$K$矩阵可简化为一个关于主值积分的标量有理函数。请从第一性原理出发展示此简化过程并予以实现。\n\n您必须为半无限积分设计求积方法，使用在有限区间上的Gauss-Legendre求积（基于Legendre多项式的高斯求积），并采用一个有理映射，该映射能同时解析红外（$q\\to 0$）和紫外（$q\\to\\infty$）区域。具体来说，通过以下方式将$x\\in[-1,1]$映射到$q\\in[0,\\infty)$：\n$$\nq(x) = \\alpha\\,\\frac{1+x}{1-x},\\quad \\frac{dq}{dx} = \\frac{2\\alpha}{(1-x)^2},\n$$\n其中$\\alpha0$是一个无量纲尺度，用于平衡红外和紫外区域的分辨率。使用$[-1,1]$上的Gauss-Legendre节点$x_i$和权重$w_i$，近似计算\n$$\n\\int_0^\\infty dq\\, F(q) \\approx \\sum_{i=1}^N w_i\\,F(q(x_i))\\,\\frac{dq}{dx}\\Big|_{x=x_i}.\n$$\n为在$q=k$处实施主值，使用一种明确移除奇点的减法：\n$$\n\\operatorname{P}\\!\\int_0^\\infty dq\\, \\frac{f(q)}{k^2 - q^2} = \\int_0^\\infty dq\\, \\frac{f(q)-f(k)}{k^2 - q^2},\n$$\n如果$f$是光滑的，该表达式是有限且数值上表现良好的。在当前问题中，设$f(q)=q^2\\,g^2(q)$，其中$g(q)=(q^2+1)^{-1}$。\n\n根据基本散射理论，通过匹配在选定归一化下实势的渐近边界条件，将此在壳实$K$矩阵与s波相移$\\delta_0(E)$联系起来。在指定的无量纲单位中，相移由下式导出：\n$$\n\\delta_0(E) = \\arctan\\!\\big(-k\\,K_0(k,k;E)\\big),\n$$\n其中$k=\\sqrt{E}$，角度以弧度为单位。\n\n实现一个完整的、可运行的程序，该程序：\n- 为选定的$N$构建Gauss-Legendre节点和权重。\n- 应用带有雅可比行列式的映射$q(x)$来近似计算可分离s波$K$矩阵所需的主值积分。\n- 为每个测试案例计算s波相移$\\delta_0(E)$（以弧度为单位）。\n\n物理和数值单位及输出：\n- 所有计算均在由$\\hbar^2/(2\\mu)=1$和力程参数缩放为1所定义的无量纲单位中进行。\n- 角度必须以弧度表示。\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如$[\\delta_1,\\delta_2,\\delta_3,\\delta_4]$。\n\n测试套件：\n使用以下测试案例集来评估实现的不同方面：\n- 案例1（近阈值，典型耦合）：$E=0.01$, $\\lambda=1.0$, $\\alpha=1.0$。\n- 案例2（中等能量，典型耦合）：$E=0.5$, $\\lambda=1.0$, $\\alpha=1.0$。\n- 案例3（较高能量，典型耦合）：$E=2.0$, $\\lambda=1.0$, $\\alpha=1.0$。\n- 案例4（弱耦合，中等能量）：$E=0.5$, $\\lambda=0.1$, $\\alpha=1.0$。\n\n算法与科学要求：\n- 从薛定谔方程和Lippmann-Schwinger积分方程作为基本出发点；推导可分离简化和主值处理方法。\n- 使用带有指定映射的Gauss-Legendre求积法来近似半无限积分。\n- 通过您选择的$N$（可选择任何合理的整数$N\\ge 100$）来检查数值稳定性、光滑性和收敛行为，从而确保科学真实性。\n- 最终输出必须是单行、格式完全符合描述的文本，包含四个以浮点数表示的相移（单位：弧度）。",
            "solution": "该问题要求在一个无量纲框架内计算非相对论性双体弹性散射的s波相移。这是通过求解具有特定可分离势的动量空间Lippmann-Schwinger方程来计算反应矩阵（$K$矩阵）来实现的。该解法涉及将积分方程解析地简化为代数方程，然后使用带有坐标映射的Gauss-Legendre求积法对一个主值积分进行数值计算。\n\n出发点是分波$K$矩阵的Lippmann-Schwinger方程。在指定的无量纲单位中，其中$\\hbar^2/(2\\mu)=1$且能量$E=k^2$（$k$为在壳动量），轨道角动量$l=0$（s波）的方程为：\n$$\nK_0(p',p;E)= v_0(p',p) + \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{v_0(p',q)\\, K_0(q,p;E)}{E - q^2}\n$$\n这里，$\\operatorname{P}$表示柯西主值，这是处理$q=\\sqrt{E}=k$处奇点所必需的。势$v_0(p',p)$是给定的可分离Yamaguchi型势：\n$$\nv_0(p',p) = -\\lambda g(p') g(p)\n$$\n其中$\\lambda  0$是耦合强度，形状因子$g(p)$由$g(p) = (p^2+1)^{-1}$给出。\n\n关键的简化源于势的可分离性。我们将$v_0(p',p)$的形式代入$K_0$的方程中：\n$$\nK_0(p',p;E) = -\\lambda g(p')g(p) + \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{[-\\lambda g(p')g(q)]\\, K_0(q,p;E)}{E - q^2}\n$$\n$g(p')$项可以从积分中提出：\n$$\nK_0(p',p;E) = -\\lambda g(p') \\left[ g(p) + \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{g(q) K_0(q,p;E)}{E - q^2} \\right]\n$$\n此方程表明，$K_0(p',p;E)$对动量$p'$的全部依赖性都通过乘法因子$g(p')$体现。这提示我们对$K_0$本身的结构做出如下拟设：\n$$\nK_0(p',p;E) = g(p') C(p,E)\n$$\n其中$C(p,E)$是一个未知函数。将此拟设代入Lippmann-Schwinger方程得到：\n$$\ng(p') C(p,E) = -\\lambda g(p')g(p) + \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{[-\\lambda g(p')g(q)]\\, [g(q)C(p,E)]}{E - q^2}\n$$\n$g(p')$和$C(p,E)$项可以分别从方程两边和积分中提出。假设$g(p') \\neq 0$，我们可以用它来除方程两边：\n$$\nC(p,E) = -\\lambda g(p) - \\lambda C(p,E) \\left[ \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{g(q)^2}{E - q^2} \\right]\n$$\n积分表达式仅依赖于能量$E$。我们将此标量积分定义为：\n$$\nI(E) = \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{g(q)^2}{E - q^2}\n$$\n现在，$C(p,E)$的方程是一个简单的代数方程：\n$$\nC(p,E) = -\\lambda g(p) - \\lambda C(p,E) I(E)\n$$\n解出$C(p,E)$：\n$$\nC(p,E) (1 + \\lambda I(E)) = -\\lambda g(p) \\implies C(p,E) = \\frac{-\\lambda g(p)}{1 + \\lambda I(E)}\n$$\n将此结果代回我们对$K_0$的拟设，我们得到$K$矩阵的闭式解：\n$$\nK_0(p',p;E) = \\frac{-\\lambda g(p')g(p)}{1 + \\lambda I(E)}\n$$\n因此，问题被简化为对主值积分$I(E)$的数值计算。\n\n为了计算$I(E)$，我们使用指定的减法方法。令$k = \\sqrt{E}$并定义$f(q) = q^2 g(q)^2 = q^2 / (q^2+1)^2$。积分变为：\n$$\nI(E) = \\operatorname{P}\\!\\int_0^\\infty dq\\, \\frac{f(q)}{k^2 - q^2} = \\int_0^\\infty dq\\, \\frac{f(q) - f(k)}{k^2-q^2}\n$$\n新的被积函数，我们称之为$F(q) = \\frac{f(q) - f(k)}{k^2-q^2}$，现在在$q=k$处是数值上表现良好的。当$q\\to k$时，该表达式的极限为$f'(k)/(2k)$，避免了任何奇点。\n\n接下来，我们通过使用有理映射将半无限积分域$[0, \\infty)$映射到有限区间$[-1,1]$来处理它：\n$$\nq(x) = \\alpha\\,\\frac{1+x}{1-x}, \\quad \\text{其雅可比行列式为} \\quad \\frac{dq}{dx} = \\frac{2\\alpha}{(1-x)^2}\n$$\n积分$I(E)$变换为：\n$$\nI(E) = \\int_{-1}^{1} F(q(x)) \\frac{dq}{dx} dx = \\int_{-1}^{1} \\frac{f(q(x)) - f(k)}{k^2 - q(x)^2} \\frac{2\\alpha}{(1-x)^2} dx\n$$\n这个定积分现在适合进行$N$点Gauss-Legendre求积。使用区间$[-1,1]$的节点$x_i$和权重$w_i$，积分可由以下求和近似：\n$$\nI(E) \\approx \\sum_{i=1}^N w_i \\left( \\frac{f(q(x_i)) - f(k)}{k^2 - q(x_i)^2} \\right) \\left( \\frac{2\\alpha}{(1-x_i)^2} \\right)\n$$\n其中$q(x_i) = \\alpha(1+x_i)/(1-x_i)$。\n\n最后，我们将此在壳$K$矩阵与s波相移$\\delta_0(E)$联系起来。在壳$K$矩阵在$p=p'=k=\\sqrt{E}$处求值：\n$$\nK_0(k,k;E) = \\frac{-\\lambda g(k)^2}{1 + \\lambda I(E)}\n$$\n问题给出了在给定归一化下，在壳$K$矩阵与相移之间的关系：\n$$\n\\delta_0(E) = \\arctan(-k K_0(k,k;E))\n$$\n代入我们得到的$K_0(k,k;E)$表达式：\n$$\n\\delta_0(E) = \\arctan\\left(-k \\left[ \\frac{-\\lambda g(k)^2}{1 + \\lambda I(E)} \\right]\\right) = \\arctan\\left(\\frac{k \\lambda g(k)^2}{1 + \\lambda I(E)}\\right)\n$$\n其中$g(k) = (k^2+1)^{-1} = (E+1)^{-1}$。该表达式现在已完全确定，可以进行数值实现。\n\n对于每个测试案例$(E, \\lambda, \\alpha)$，算法如下：\n1.  设$k=\\sqrt{E}$并选择一个足够大的求积点数$N$（例如，$N=128$）。\n2.  生成在$[-1,1]$上的$N$个Gauss-Legendre节点$x_i$和权重$w_i$。\n3.  计算$f(k) = k^2/(k^2+1)^2$的值。\n4.  对于每个节点$x_i$，计算相应的动量点$q_i=q(x_i)$、函数值$f(q_i)$和雅可比行列式$dq/dx|_{x_i}$。\n5.  通过求和评估$I(E)$的近似值。\n6.  使用计算出的$I(E)$值，通过最终推导出的公式计算$\\delta_0(E)$（以弧度为单位）。\n这个过程依据散射理论的原理，系统地实现了该解法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# The following import for Gauss-Legendre quadrature is standard and necessary.\n# numpy.polynomial.legendre.leggauss is the canonical source for this in numpy.\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Solves the Lippmann-Schwinger equation for the s-wave K-matrix with a\n    separable potential and computes the phase shift.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (E, lambda, alpha)\n        (0.01, 1.0, 1.0),  # Case 1\n        (0.5, 1.0, 1.0),   # Case 2\n        (2.0, 1.0, 1.0),   # Case 3\n        (0.5, 0.1, 1.0),   # Case 4\n    ]\n\n    # Set the number of quadrature points as required (N = 100).\n    # A choice of N=128 is a power of 2, often good for numerical algorithms,\n    # and safely above the minimum requirement.\n    N = 128\n\n    results = []\n    \n    # Generate Gauss-Legendre nodes and weights for the interval [-1, 1]\n    x_nodes, w_weights = leggauss(N)\n\n    for E, lam, alpha in test_cases:\n        # On-shell momentum k\n        k = np.sqrt(E)\n\n        # Define the form factor g(p) and the function f(p) = p^2 * g(p)^2\n        def g(p):\n            return 1.0 / (p**2 + 1.0)\n\n        def f(p):\n            return p**2 / (p**2 + 1.0)**2\n\n        # Value of f at the on-shell momentum k for the subtraction method\n        f_k = f(k)\n\n        # --- Numerical Integration for I(E) ---\n        # 1. Map Gauss-Legendre nodes x_i in [-1, 1] to momentum points q_i in [0, inf)\n        # The mapping is q(x) = alpha * (1 + x) / (1 - x)\n        q_nodes = alpha * (1.0 + x_nodes) / (1.0 - x_nodes)\n        \n        # 2. Calculate the Jacobian of the transformation\n        # dq/dx = 2 * alpha / (1 - x)^2\n        jacobian = 2.0 * alpha / (1.0 - x_nodes)**2\n        \n        # 3. Evaluate the integrand for the principal value integral\n        # The integrand is (f(q) - f(k)) / (k^2 - q^2)\n        # which is numerically stable due to the subtraction.\n        f_q_nodes = f(q_nodes)\n        \n        # We must handle the case where a quadrature node q_i might numerically\n        # equal k. While unlikely, it can lead to 0/0 - NaN.\n        # The limit of the integrand as q-k is f'(k)/(2k).\n        # f'(p) = (2p * (1 - p^2)) / (p^2 + 1)^3\n        # limit_val = f'(k) / (2k) = (1 - k^2) / (k^2 + 1)^3\n        # However, numpy's float arithmetic typically handles this subtraction\n        # correctly without explicit NaN, so direct evaluation is robust enough.\n        pv_integrand_values = (f_q_nodes - f_k) / (k**2 - q_nodes**2)\n        \n        # 4. Compute the integral I(E) by summing over the quadrature points\n        I_E = np.sum(w_weights * pv_integrand_values * jacobian)\n        \n        # --- Phase Shift Calculation ---\n        # Calculate the on-shell K-matrix K_0(k,k;E)\n        # K_0(k,k;E) = -lambda * g(k)^2 / (1 + lambda * I(E))\n        g_k_squared = g(k)**2\n        K_on_shell = (-lam * g_k_squared) / (1.0 + lam * I_E)\n        \n        # Calculate the s-wave phase shift delta_0(E) in radians\n        # delta_0(E) = arctan(-k * K_0(k,k;E))\n        delta_0 = np.arctan(-k * K_on_shell)\n        \n        results.append(delta_0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.8f}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}