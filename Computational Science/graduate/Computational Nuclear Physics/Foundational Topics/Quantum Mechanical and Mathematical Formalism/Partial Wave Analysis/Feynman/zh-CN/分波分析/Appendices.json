{
    "hands_on_practices": [
        {
            "introduction": "分波分析的第一步通常是将给定的相互作用势从其坐标或动量空间表示转换为分波分量。这个练习将指导你完成这一核心任务，将一个模型势投影到特定的角动量通道上。通过这个过程，你不仅需要推导出一个精确的解析解作为基准，还将实现一个高斯-勒让德求积的数值方法，从而在理论推导和数值计算两方面获得实践经验。",
            "id": "3579009",
            "problem": "考虑一个在动量空间中进行两体散射分波分析 (PWA) 的计算任务。令 $l \\in \\mathbb{N}_0$ 为轨道角动量量子数，$p \\ge 0$ 和 $p' \\ge 0$ 分别为入射和出射动量的大小（通过适当的缩放处理为无量纲量），并令 $\\alpha  0$ 为一个无量纲的程参数。一个球对称模型核的分波投影 $V_l(p,p')$ 定义为\n$$\nV_l(p,p') \\equiv \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x)\\, V(p,p',x),\n$$\n其中 $x \\equiv \\cos \\theta$，$P_l(x)$ 是 $l$ 次 Legendre 多项式。对于本问题，使用以下光滑、旋转不变的模型\n$$\nV(p,p',x) \\equiv \\exp\\!\\big(-\\alpha\\,[p^2 + p'^2 - 2 p p' x]\\big).\n$$\n你的任务是：\n- 从 Legendre 多项式的基本定义、在区间 $[-1,1]$ 上的正交性以及 Gauss 求积的性质出发，推导出一个用已知特殊函数表示的 $V_l(p,p')$ 的闭式表达式。该表达式可作为数值误差评估的参考（基准真相）。除已声明的解析性和球对称性外，不要引入任何新的假设。\n- 实现一个具有 $N$ 个节点的高精度 Gauss–Legendre 求积来近似计算 $V_l(p,p')$ 的积分：\n$$\nV_l^{(N)}(p,p') \\approx \\sum_{i=1}^{N} w_i \\, P_l(x_i)\\, V(p,p',x_i),\n$$\n其中 $\\{x_i,w_i\\}_{i=1}^N$ 是在 $[-1,1]$ 上的 Gauss–Legendre 求积的节点和权重。\n- 对于下述的每个测试用例，计算绝对截断误差\n$$\n\\varepsilon \\equiv \\big|V_l^{(N)}(p,p') - V_l(p,p')\\big|,\n$$\n其中 $V_l(p,p')$ 是你推导出的闭式参考解。\n\n角度通过 $x=\\cos\\theta$ 以弧度度量，但积分变量是 $x$，无需进行角度转换。所有量根据构造都是无量纲的，因此最终答案中不需要物理单位。\n\n你必须实现一个仅使用指定数值库的自包含程序来计算这些误差。你的实现必须具有通用性，并适用于任意允许的参数。\n\n使用以下测试套件，其设计旨在覆盖一般情况、高 $l$ 值的振荡行为、一个边界条件、一个具有大有效自变量的近共线构型，以及一个在高 $l$ 值下使用相对较小 $N$ 的挑战性情况：\n- 情况 1：$l=0$, $p=0.8$, $p'=1.1$, $\\alpha=0.6$, $N=16$。\n- 情况 2：$l=12$, $p=1.0$, $p'=1.0$, $\\alpha=0.4$, $N=32$。\n- 情况 3：$l=5$, $p=0.0$, $p'=1.7$, $\\alpha=0.3$, $N=8$。\n- 情况 4：$l=4$, $p=2.0$, $p'=2.0$, $\\alpha=0.75$, $N=24$。\n- 情况 5：$l=20$, $p=1.5$, $p'=1.5$, $\\alpha=0.2$, $N=12$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含 5 个测试用例的绝对误差，格式为一个由方括号括起来的逗号分隔列表。每个误差采用科学记数法格式，小数点后有 10 位有效数字（例如，$1.2345678900\\mathrm{e}{-6}$），即严格遵循 $\\big[$误差$_1$,误差$_2$,误差$_3$,误差$_4$,误差$_5\\big]$ 的形式，无空格。",
            "solution": "该问题提法明确，具有科学依据，并且是自包含的。所有必要的定义和参数均已提供，且无矛盾之处。因此，我们可以着手求解。\n\n任务是解析和数值计算一个特定模型核的分波投影 $V_l(p,p')$，然后对一组给定的测试用例，确定数值近似的绝对误差。\n\n分波投影由以下积分定义：\n$$\nV_l(p,p') \\equiv \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x)\\, V(p,p',x)\n$$\n其中 $P_l(x)$ 是 $l$ 次 Legendre 多项式，模型核由下式给出：\n$$\nV(p,p',x) \\equiv \\exp\\!\\big(-\\alpha\\,[p^2 + p'^2 - 2 p p' x]\\big)\n$$\n所有参数 $l$、$p$、$p'$ 和 $\\alpha$ 均为无量纲量。\n\n**1. 闭式表达式的推导**\n\n为推导 $V_l(p,p')$ 的闭式表达式，我们将核函数代入积分定义中。我们可以将指数项中不依赖于积分变量 $x$ 的部分提取出来：\n$$\nV_l(p,p') = \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x)\\, \\exp\\!\\big(-\\alpha(p^2 + p'^2)\\big) \\exp\\!\\big(2 \\alpha p p' x\\big)\n$$\n$$\nV_l(p,p') = \\exp\\big(-\\alpha(p^2 + p'^2)\\big) \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x)\\, \\exp\\big( (2 \\alpha p p') x\\big)\n$$\n我们定义指数的自变量为 $z \\equiv 2\\alpha p p'$。该积分变为：\n$$\nI_l(z) = \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x)\\, e^{zx}\n$$\n该积分是与第一类修正球 Bessel 函数（记为 $i_l(z)$）相关的一个标准积分表示。函数 $i_l(z)$ 可以通过指数函数展开为 Legendre 多项式级数来定义：\n$$\ne^{zx} = \\sum_{n=0}^{\\infty} (2n+1) i_n(z) P_n(x)\n$$\n该级数在 $x \\in [-1,1]$ 上一致收敛。我们可以将此展开式代入积分 $I_l(z)$，乘以 $P_l(x)$，并在 $x \\in [-1,1]$ 上积分。利用 Legendre 多项式的正交性，\n$$\n\\int_{-1}^{1} P_l(x) P_n(x) \\mathrm{d}x = \\frac{2}{2l+1} \\delta_{ln}\n$$\n其中 $\\delta_{ln}$ 是 Kronecker delta，我们可以确定积分 $I_l(z)$：\n$$\nI_l(z) = \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x) \\sum_{n=0}^{\\infty} (2n+1) i_n(z) P_n(x)\n$$\n$$\nI_l(z) = \\sum_{n=0}^{\\infty} (2n+1) i_n(z) \\int_{-1}^{1} P_l(x) P_n(x) \\mathrm{d}x\n$$\n$$\nI_l(z) = \\sum_{n=0}^{\\infty} (2n+1) i_n(z) \\left(\\frac{2}{2l+1} \\delta_{ln}\\right)\n$$\n当 $n=l$ 时，该求和化简为单项：\n$$\nI_l(z) = (2l+1) i_l(z) \\left(\\frac{2}{2l+1}\\right) = 2 i_l(z)\n$$\n将此结果代回 $V_l(p,p')$ 的表达式，我们得到闭式解：\n$$\nV_l(p,p') = 2 \\exp\\big(-\\alpha(p^2 + p'^2)\\big) \\, i_l(2 \\alpha p p')\n$$\n该表达式作为我们误差分析的精确参考值。函数 $i_l(z)$ 与第一类修正 Bessel 函数 $I_{\\nu}(z)$ 的关系为 $i_l(z) = \\sqrt{\\frac{\\pi}{2z}} I_{l+1/2}(z)$。在计算上，我们将依赖于 $i_l(z)$ 的高精度库实现。\n\n当 $p=0$ 或 $p'=0$ 时会出现一个特殊情况。在这种情况下，自变量 $z=2\\alpha p p'$ 变为零。积分简化为：\n$$\nV_l(p, p')|_{p=0} = \\exp(-\\alpha p'^2) \\int_{-1}^{1} P_l(x) \\mathrm{d}x\n$$\n根据与 $P_0(x)=1$ 的正交关系，我们有 $\\int_{-1}^{1} P_l(x) \\mathrm{d}x = 2\\delta_{l0}$。因此，对于 $p=0$ 或 $p'=0$：\n$$\nV_l(p, p') =\n\\begin{cases}\n2 \\exp\\big(-\\alpha(p^2+p'^2)\\big)  \\text{若 } l=0 \\\\\n0  \\text{若 } l0\n\\end{cases}\n$$\n该结果与闭式公式一致，因为修正球 Bessel 函数在原点附近的行为是，当 $z \\to 0$ 时，$i_l(z) \\to \\delta_{l0}$。\n\n**2. 通过 Gauss-Legendre 求积进行数值近似**\n\n问题指定使用具有 $N$ 个节点的 Gauss-Legendre 求积来近似该积分。该近似值记为 $V_l^{(N)}(p,p')$，由下式给出：\n$$\nV_l^{(N)}(p,p') = \\sum_{i=1}^{N} w_i \\, P_l(x_i)\\, V(p,p',x_i)\n$$\n此处，$\\{x_i\\}_{i=1}^N$ 是 Legendre 多项式 $P_N(x)$ 的根，称为求积节点，而 $\\{w_i\\}_{i=1}^N$ 是相应的求积权重。该方法对于次数最高为 $2N-1$ 的任意多项式被积函数都是精确的。我们的被积函数 $P_l(x)\\exp(2\\alpha p p' x)$ 不是多项式，但它是解析且通常是光滑的。求积的精度取决于被积函数能被一个 $2N-1$ 次多项式近似的程度。\n\n数值计算的算法步骤如下：\n1.  对于给定的求积阶数 $N$，获取区间 $[-1,1]$ 上的节点集 $\\{x_i\\}$ 和权重集 $\\{w_i\\}$。\n2.  在每个节点 $x_i$ 处，计算被积函数的各组成部分：Legendre 多项式 $P_l(x_i)$ 和核函数 $V(p,p',x_i) = \\exp\\big(-\\alpha(p^2 + p'^2 - 2 p p' x_i)\\big)$。\n3.  计算这些值与相应权重的乘积之和：$\\sum_{i=1}^{N} w_i P_l(x_i) V(p,p',x_i)$。\n\n**3. 误差计算与实现**\n\n绝对截断误差 $\\varepsilon$ 是数值近似解与精确解析解之差的绝对值：\n$$\n\\varepsilon \\equiv \\big|V_l^{(N)}(p,p') - V_l(p,p')\\big|\n$$\n实现将使用 Python 的 `numpy` 和 `scipy` 库来完成。\n- Gauss-Legendre 节点和权重使用 `scipy.special.roots_legendre(N)` 计算。\n- Legendre 多项式 $P_l(x_i)$ 使用 `scipy.special.eval_legendre(l, nodes)` 计算。\n- 用于精确解的修正球 Bessel 函数 $i_l(z)$ 使用 `scipy.special.spherical_in(l, z)` 计算。\n\n最终的程序将定义一个函数，该函数接收一个测试用例的参数 $(l, p, p', \\alpha, N)$，计算 $V_l(p,p')$ 和 $V_l^{(N)}(p,p')$，计算绝对误差 $\\varepsilon$，并返回该误差。此函数将应用于每个指定的测试用例，结果将按要求格式化为单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre, eval_legendre, spherical_in\n\ndef solve():\n    \"\"\"\n    Computes the absolute truncation error for the partial-wave projection integral\n    for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (l, p, p_prime, alpha, N)\n        (0, 0.8, 1.1, 0.6, 16),\n        (12, 1.0, 1.0, 0.4, 32),\n        (5, 0.0, 1.7, 0.3, 8),\n        (4, 2.0, 2.0, 0.75, 24),\n        (20, 1.5, 1.5, 0.2, 12),\n    ]\n\n    results = []\n    for l, p, p_prime, alpha, N in test_cases:\n        # Step 1: Calculate the exact analytical solution V_l(p, p')\n        # V_l(p,p') = 2 * exp(-alpha*(p^2 + p'^2)) * i_l(2*alpha*p*p')\n        # where i_l is the modified spherical Bessel function of the first kind.\n        \n        prefactor = 2.0 * np.exp(-alpha * (p**2 + p_prime**2))\n        argument_bessel = 2.0 * alpha * p * p_prime\n        \n        # The scipy function spherical_in correctly handles the z=0 case,\n        # where i_l(0) is 1 for l=0 and 0 for l0.\n        i_l_val = spherical_in(l, argument_bessel)\n        exact_Vl = prefactor * i_l_val\n\n        # Step 2: Calculate the numerical approximation V_l^(N)(p, p')\n        # using N-point Gauss-Legendre quadrature.\n        \n        # Get Gauss-Legendre nodes (x_i) and weights (w_i) on [-1, 1]\n        nodes, weights = roots_legendre(N)\n        \n        # Evaluate the components of the integrand at the nodes\n        # Legendre polynomials P_l(x_i)\n        legendre_vals = eval_legendre(l, nodes)\n        \n        # Kernel V(p, p', x_i) = exp(-alpha * (p^2 + p'^2 - 2*p*p'*x_i))\n        kernel_vals = np.exp(-alpha * (p**2 + p_prime**2 - 2.0 * p * p_prime * nodes))\n\n        # Compute the quadrature sum\n        numerical_Vl = np.sum(weights * legendre_vals * kernel_vals)\n\n        # Step 3: Compute the absolute truncation error\n        error = np.abs(numerical_Vl - exact_Vl)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.10e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "分波分析的最终目标之一是连接理论与实验。这个练习模拟了一个真实的物理分析任务：从散射相移的“实验”数据中提取基本的物理参数，如散射长度$a_{0}$和有效力程$r_{0}$。你将应用有效力程展开理论，构建一个统计上合理的拟合模型，并学习如何量化由于理论截断带来的系统不确定性。",
            "id": "3579075",
            "problem": "给定 s-波分波的低能弹性散射相移数据。您的目标是根据带有不确定度的相移测量值，构建一个基于统计原理的 s-波散射长度 $a_{0}$ 和有效力程 $r_{0}$ 的提取方法，并量化在低能展开中截断高阶形状参数的影响。所用单位制中，动量以反费米（inverse femtometers）为单位，即 $k$ 的单位为 $\\mathrm{fm}^{-1}$，而长度如 $a_{0}$ 和 $r_{0}$ 的单位为费米（femtometers） $\\mathrm{fm}$。角度必须以弧度处理。\n\n从非相对论量子散射理论的基本原理以及在复能量平面上在壳散射振幅的解析性出发，您必须首先论证 s-波相移允许一个关于碰撞动量大小 $k$ 的收敛的低能展开，并且该展开可以组织成一个层次结构。仅基于这些原理和定义，并且不假设任何预先给定的最终公式，执行以下步骤：\n\n1. 从 s-波相移 $\\delta_{0}(k)$ 的定义以及短程相互作用的分波散射振幅的解析性出发，推导一个可观测量的低能展开式。该展开式在 $k^{2}$ 阶之前是两个参数的线性函数，当包含下一个更高阶的形状参数时，在 $k^{4}$ 阶会增加一个额外的线性项。确定如何将测量的相移转换为这个可观测量，以便可以应用具有已知高斯误差的加权线性回归。清晰地指出回归参数及其与 $a_{0}$ 和 $r_{0}$ 的映射关系。\n\n2. 在测量的相移具有已知标准差的独立高斯误差的假设下，构建一个统计上可靠的估计器。使用等效于加权最小二乘法的最大似然估计器。从不确定度传播的角度，论证您选择的权重是合理的，该传播将相移不确定度与所选线性可观测量的不确定度联系起来。提供一种有原则的方法，将线性拟合中的参数不确定度传播到 $a_{0}$ 和 $r_{0}$ 的不确定度上。\n\n3. 对提供的数据拟合两个模型：\n   - 一个截断到 $k^{2}$ 阶的模型（双参数拟合），从中提取 $a_{0}$ 和 $r_{0}$。\n   - 一个扩展到 $k^{4}$ 阶的模型（三参数拟合），同样从中提取 $a_{0}$ 和 $r_{0}$，同时对额外的线性形状参数进行边缘化处理。\n   使用这两个结果，通过比较双参数和三参数估计的 $a_{0}$ 和 $r_{0}$ 值，来量化截断高阶项的影响。您的比较应表示为绝对差异，并以组合标准差为单位的统计显著性表示，即，根据两次拟合传播的不确定度构建的 $z$-分数。\n\n4. 物理和数值单位：\n   - 使用 $k$，单位为 $\\mathrm{fm}^{-1}$。\n   - 使用 $\\delta$，单位为弧度。\n   - 报告 $a_{0}$ 和 $r_{0}$，单位为 $\\mathrm{fm}$。\n   - 所有中间角度量必须以弧度为单位。\n   - 您最终报告的数值必须四舍五入到六位小数。\n\n5. 测试套件和要求的输出：\n   使用以下三个数据集。在每个数据集中，动量值 $k_{i}$ 的单位为 $\\mathrm{fm}^{-1}$，测量的 s-波相移 $\\delta_{i}$ 的单位为弧度，单西格玛不确定度 $\\sigma_{\\delta,i}$ 的单位为弧度。\n\n   - 数据集 A（一般低能情况）：\n     - $k = [0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40]$\n     - $\\delta = [0.371000, 0.631000, 0.775000, 0.851000, 0.888000, 0.900000, 0.896000, 0.889000]$\n     - $\\sigma_{\\delta} = [0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000]$\n\n   - 数据集 B（动量极小的近阈值情况）：\n     - $k = [0.01, 0.02, 0.03, 0.04, 0.05]$\n     - $\\delta = [0.020000, 0.040000, 0.059800, 0.079400, 0.099100]$\n     - $\\sigma_{\\delta} = [0.002000, 0.002000, 0.002000, 0.002000, 0.002000]$\n\n   - 数据集 C（高阶项更重要、范围更广的低能区）：\n     - $k = [0.05, 0.10, 0.15, 0.20, 0.30, 0.40, 0.50, 0.60]$\n     - $\\delta = [0.243000, 0.444000, 0.597000, 0.703000, 0.811000, 0.849000, 0.844000, 0.818000]$\n     - $\\sigma_{\\delta} = [0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000]$\n\n   对于每个数据集，执行两种拟合（到 $k^{2}$ 阶和到 $k^{4}$ 阶），传播不确定度以获得 $a_{0}$ 和 $r_{0}$ 的不确定度，然后计算双参数和三参数估计的 $a_{0}$ 和 $r_{0}$ 之间差异的绝对 $z$-分数，分母使用它们的单西格玛标准差的正交和。\n\n   您的程序必须产生单行输出，包含一个列表，内有三个子列表，每个子列表对应一个数据集，每个子列表中的顺序如下：\n   - $a_{0}^{(k^{2})}$，单位 $\\mathrm{fm}$，\n   - $r_{0}^{(k^{2})}$，单位 $\\mathrm{fm}$，\n   - $a_{0}^{(k^{4})}$，单位 $\\mathrm{fm}$，\n   - $r_{0}^{(k^{4})}$，单位 $\\mathrm{fm}$，\n   - $a_{0}$ 差异的 $z$-分数，\n   - $r_{0}$ 差异的 $z$-分数。\n\n   所有数字必须四舍五入到六位小数。最终输出格式为单行：\n   “您的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，[[a0_k2_A,r0_k2_A,a0_k4_A,r0_k4_A,zA0_A,zR0_A],[...dataset B...],[...dataset C...]]）。”",
            "solution": "用户提供了一个计算核物理领域的问题，涉及从相移数据中提取 s-波散射参数。解决方案要求从第一性原理推导相关物理模型，制定统计上可靠的拟合程序，并将其应用于多个数据集以评估模型截断的影响。\n\n该问题被验证为科学上合理、定义明确、客观且自洽。它是分波分析中的一个标准的、非平凡的练习，植根于基本的量子力学和统计数据分析。因此，我们可以着手提供完整的解决方案。\n\n解决方案分为三部分：\n1.  推导有效力程展开（ERE）作为理论模型。\n2.  构建加权最小二乘拟合程序和误差传播。\n3.  指定模型拟合和比较的计算协议。\n\n### 1. 理论基础：有效力程展开\n\n短程相互作用的低能散射理论的基础是散射振幅的解析性。对于 s-波（$l=0$）分波，散射矩阵元 $S_0(k)$ 通过 $S_0(k) = e^{2i\\delta_0(k)}$ 与相移 $\\delta_0(k)$ 相关联，其中 $k$ 是相对动量的大小。\n\n分波散射振幅 $f_0(k)$ 定义为：\n$$f_0(k) = \\frac{S_0(k) - 1}{2ik} = \\frac{e^{2i\\delta_0(k)} - 1}{2ik} = \\frac{e^{i\\delta_0(k)}(e^{i\\delta_0(k)} - e^{-i\\delta_0(k)})}{2ik} = \\frac{e^{i\\delta_0(k)}\\sin\\delta_0(k)}{k}$$\n这个表达式可以反转，通过函数 $\\cot\\delta_0(k)$ 将 $f_0(k)$ 与相移联系起来：\n$$f_0(k) = \\frac{1}{k \\cot\\delta_0(k) - ik}$$\n由 Bethe 建立的散射理论的一个基本结果是，对于短程势，函数 $k\\cot\\delta_0(k)$ 是能量 $E \\propto k^2$ 的解析函数。因此，它允许一个在 $k=0$ 附近关于 $k^2$ 幂次的收敛泰勒级数展开。这被称为有效力程展开（ERE）：\n$$k\\cot\\delta_0(k) = c_0 + c_1 k^2 + c_2 k^4 + O(k^6)$$\n这个展开式的系数定义了低能散射参数。s-波散射长度 $a_0$ 由零能极限定义：\n$$\\lim_{k \\to 0} (-k \\cot\\delta_0(k)) = \\frac{1}{a_0}$$\n这意味着首项系数为 $c_0 = -1/a_0$。下一项系数定义了有效力程 $r_0$：\n$$c_1 = \\frac{1}{2}r_0$$\n更高阶的项定义了形状参数。一个常见的约定将 $k^4$ 项的系数设为 $c_2 = -P_0 r_0^3$，其中 $P_0$ 是第一个形状参数。因此，ERE 可以写为：\n$$k\\cot\\delta_0(k) = -\\frac{1}{a_0} + \\frac{1}{2}r_0k^2 - P_0 r_0^3 k^4 + O(k^6)$$\n这个方程为线性回归分析提供了基础。让我们定义一个可观测量 $y(k) = k\\cot\\delta_0(k)$ 和一个自变量 $x = k^2$。然后，ERE 可以被转换为线性模型。\n\n-   **截断模型（$k^2$ 阶）：** 将级数截断到 $k^2$ 阶，我们得到一个双参数线性模型：\n    $$y(k) \\approx \\beta_0 + \\beta_1 x \\quad \\text{其中} \\quad x=k^2$$\n    回归参数与物理参数直接相关：$\\beta_0 = -1/a_0$ 和 $\\beta_1 = r_0/2$。\n\n-   **扩展模型（$k^4$ 阶）：** 包含下一项，得到一个三参数线性模型：\n    $$y(k) \\approx \\beta_0 + \\beta_1 x + \\beta_2 x^2 \\quad \\text{其中} \\quad x=k^2$$\n    这里，$\\beta_0 = -1/a_0$，$\\beta_1 = r_0/2$，以及 $\\beta_2 = -P_0 r_0^3$。目标是从 $\\beta_0$ 和 $\\beta_1$ 中提取 $a_0$ 和 $r_0$，并将 $\\beta_2$ 视为一个由拟合确定的参数。\n\n### 2. 统计方法和不确定度传播\n\n我们有 $N$ 个数据点 $(k_i, \\delta_i)$，其相移具有不确定度 $\\sigma_{\\delta,i}$。为了进行线性拟合，我们首先将它们转换为我们线性模型的数据点：$(x_i, y_i) = (k_i^2, k_i\\cot\\delta_i)$。\n\n不确定度必须从 $\\delta_i$ 传播到 $y_i$。使用一阶泰勒展开进行误差传播， $y_i$ 的方差，记为 $\\sigma_{y,i}^2$，是：\n$$\\sigma_{y,i}^2 \\approx \\left( \\frac{\\partial y_i}{\\partial \\delta_i} \\right)^2 \\sigma_{\\delta,i}^2$$\n导数为 $\\frac{\\partial}{\\partial\\delta}(k\\cot\\delta) = -k\\csc^2\\delta = -k/\\sin^2\\delta$。因此，每个 $y_i$ 的方差是：\n$$\\sigma_{y,i}^2 = \\left( \\frac{-k_i}{\\sin^2\\delta_i} \\right)^2 \\sigma_{\\delta,i}^2 = \\frac{k_i^2}{(\\sin^2\\delta_i)^2} \\sigma_{\\delta,i}^2$$\n假设测量误差 $\\sigma_{\\delta,i}$ 是高斯的且独立的，参数 $\\beta$ 的最佳线性无偏估计量是通过加权最小二乘法（WLS）最小化 $\\chi^2$ 统计量得到的。$\\chi^2$ 定义为：\n$$\\chi^2 = \\sum_{i=1}^{N} \\left( \\frac{y_i - f(x_i; \\beta)}{\\sigma_{y,i}} \\right)^2 = \\sum_{i=1}^{N} w_i \\left(y_i - \\sum_{j=0}^{m-1} \\beta_j X_{ij}\\right)^2$$\n其中 $f(x_i; \\beta)$ 是线性模型，$w_i = 1/\\sigma_{y,i}^2$ 是权重，$X$ 是设计矩阵，其元素 $X_{ij}$ 是在数据点 $i$ 处计算的基函数。对于 $k^4$ 模型，$X_{i0}=1$, $X_{i1}=k_i^2$, $X_{i2}=k_i^4$。\n\n用矩阵形式表示，最小化 $\\chi^2$ 的解为：\n$$\\hat{\\beta} = (X^T W X)^{-1} X^T W y$$\n这里，$\\hat{\\beta}$ 是估计参数的向量，$y$ 是观测值 $y_i$ 的列向量，$W$ 是一个对角矩阵，其对角元素为 $W_{ii} = w_i$。\n\n估计参数 $\\hat{\\beta}$ 的协方差矩阵由下式给出：\n$$C_{\\beta} = (X^T W X)^{-1}$$\n每个参数的方差 $\\sigma_{\\beta_j}^2$ 是该矩阵的第 $j$ 个对角元素，即 $\\sigma_{\\beta_j}^2 = (C_{\\beta})_{jj}$。\n\n最后，物理参数 $a_0$ 和 $r_0$ 的不确定度是通过从 $\\hat{\\beta}_0$ 和 $\\hat{\\beta}_1$ 传播不确定度得到的：\n-   对于 $a_0 = -1/\\beta_0$：\n    $$\\sigma_{a_0}^2 = \\left( \\frac{\\partial a_0}{\\partial \\beta_0} \\right)^2 \\sigma_{\\beta_0}^2 = \\left( \\frac{1}{\\beta_0^2} \\right)^2 \\sigma_{\\beta_0}^2 = \\frac{\\sigma_{\\beta_0}^2}{\\beta_0^4} = a_0^4 \\sigma_{\\beta_0}^2 \\implies \\sigma_{a_0} = a_0^2 \\sigma_{\\beta_0}$$\n-   对于 $r_0 = 2\\beta_1$：\n    $$\\sigma_{r_0}^2 = \\left( \\frac{\\partial r_0}{\\partial \\beta_1} \\right)^2 \\sigma_{\\beta_1}^2 = (2)^2 \\sigma_{\\beta_1}^2 = 4\\sigma_{\\beta_1}^2 \\implies \\sigma_{r_0} = 2\\sigma_{\\beta_1}$$\n\n### 3. 计算协议和模型比较\n\n对于提供的每个数据集，执行以下协议：\n1.  **数据转换：** 对所有数据点计算 $y_i = k_i\\cot\\delta_i$ 和相应的权重 $w_i = (\\sin^2\\delta_i / (k_i \\sigma_{\\delta,i}))^2$。\n2.  **拟合 $k^2$ 阶模型：**\n    -   构建设计矩阵 $X^{(2)}$，其列为基函数 $1$ 和 $k^2$。\n    -   使用 WLS 公式计算 $\\hat{\\beta}^{(k^2)}$ 及其协方差矩阵 $C_{\\beta}^{(k^2)}$。\n    -   计算 $a_0^{(k^2)} = -1/\\hat{\\beta}_0^{(k^2)}$、$r_0^{(k^2)} = 2\\hat{\\beta}_1^{(k^2)}$ 及其不确定度 $\\sigma_{a_0}^{(k^2)}$ 和 $\\sigma_{r_0}^{(k^2)}$。\n3.  **拟合 $k^4$ 阶模型：**\n    -   构建设计矩阵 $X^{(4)}$，其列为基函数 $1$、$k^2$ 和 $k^4$。\n    -   计算 $\\hat{\\beta}^{(k^4)}$ 及其协方差矩阵 $C_{\\beta}^{(k^4)}$。\n    -   使用 $C_{\\beta}^{(k^4)}$ 中前两个参数的方差，计算 $a_0^{(k^4)} = -1/\\hat{\\beta}_0^{(k^4)}$、$r_0^{(k^4)} = 2\\hat{\\beta}_1^{(k^4)}$ 及其不确定度 $\\sigma_{a_0}^{(k^4)}$ 和 $\\sigma_{r_0}^{(k^4)}$。\n4.  **模型比较：** 为了量化截断 ERE 引入的系统不确定性，我们计算从两个模型中提取的参数之间差异的统计显著性。这是通过 z-分数完成的，定义为两个估计值之间的绝对差除以它们的组合不确定度（正交相加）：\n    $$z_{a_0} = \\frac{|a_0^{(k^2)} - a_0^{(k^4)}|}{\\sqrt{(\\sigma_{a_0}^{(k^2)})^2 + (\\sigma_{a_0}^{(k^4)})^2}}$$\n    $$z_{r_0} = \\frac{|r_0^{(k^2)} - r_0^{(k^4)}|}{\\sqrt{(\\sigma_{r_0}^{(k^2)})^2 + (\\sigma_{r_0}^{(k^4)})^2}}$$\n一个大的 z-分数（例如，$z  2$）表明高阶 $k^4$ 项在统计上是显著的，并且截断模型对于给定的数据范围是不充分的。一个小的 z-分数意味着更简单的模型是足够的，并且数据没有提供足够的信息来分辨更高阶的项。这整个过程将对提供的三个数据集中的每一个进行数值实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all datasets and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Dataset A (general low-energy case)\n        {\n            \"k\": [0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40],\n            \"delta\": [0.371000, 0.631000, 0.775000, 0.851000, 0.888000, 0.900000, 0.896000, 0.889000],\n            \"sigma_delta\": [0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000]\n        },\n        # Dataset B (near-threshold case with tiny momenta)\n        {\n            \"k\": [0.01, 0.02, 0.03, 0.04, 0.05],\n            \"delta\": [0.020000, 0.040000, 0.059800, 0.079400, 0.099100],\n            \"sigma_delta\": [0.002000, 0.002000, 0.002000, 0.002000, 0.002000]\n        },\n        # Dataset C (broader low-energy range where higher orders matter more)\n        {\n            \"k\": [0.05, 0.10, 0.15, 0.20, 0.30, 0.40, 0.50, 0.60],\n            \"delta\": [0.243000, 0.444000, 0.597000, 0.703000, 0.811000, 0.849000, 0.844000, 0.818000],\n            \"sigma_delta\": [0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = _solve_for_dataset(case[\"k\"], case[\"delta\"], case[\"sigma_delta\"])\n        all_results.append(result)\n\n    # Format the final output string as specified.\n    # [[a0_k2_A,r0_k2_A,a0_k4_A,r0_k4_A,zA0_A,zR0_A],[...B...],[...C...]]\n    formatted_sublists = []\n    for res_list in all_results:\n        # Round each number to six decimal places\n        formatted_numbers = [f\"{x:.6f}\" for x in res_list]\n        formatted_sublists.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_sublists)}]\"\n    print(final_output_string)\n\ndef _solve_for_dataset(k_vals, delta_vals, sigma_delta_vals):\n    \"\"\"\n    Performs the effective range expansion analysis for a single dataset.\n    \n    Args:\n        k_vals (list): Momenta in fm^-1.\n        delta_vals (list): Phase shifts in radians.\n        sigma_delta_vals (list): Uncertainties on phase shifts in radians.\n        \n    Returns:\n        list: A list containing [a0_k2, r0_k2, a0_k4, r0_k4, z_a0, z_r0].\n    \"\"\"\n    k = np.array(k_vals)\n    delta = np.array(delta_vals)\n    sigma_delta = np.array(sigma_delta_vals)\n    \n    # 1. Transform data and propagate uncertainties\n    # y = k * cot(delta)\n    y = k / np.tan(delta)\n    \n    # Uncertainty propagation: sigma_y^2 = (dy/d_delta)^2 * sigma_delta^2\n    # dy/d_delta = -k / sin^2(delta)\n    dyd_delta = -k / (np.sin(delta)**2)\n    sigma_y_sq = (dyd_delta**2) * (sigma_delta**2)\n    \n    # Weights for WLS: w = 1 / sigma_y^2\n    weights = 1.0 / sigma_y_sq\n    W = np.diag(weights)\n    \n    # --- 2. Fit truncated model (order k^2) ---\n    # Model: y = beta_0 + beta_1 * k^2\n    X2 = np.vstack([np.ones_like(k), k**2]).T\n    \n    # WLS solution: beta = (X^T W X)^-1 X^T W y\n    # Covariance matrix: C_beta = (X^T W X)^-1\n    XTWX2 = X2.T @ W @ X2\n    XTWy2 = X2.T @ W @ y\n    \n    C_beta2 = np.linalg.inv(XTWX2)\n    beta_hat2 = C_beta2 @ XTWy2\n    \n    beta0_k2, beta1_k2 = beta_hat2\n    var_beta0_k2, var_beta1_k2 = np.diag(C_beta2)\n    \n    # Extract physical parameters and propagate errors\n    a0_k2 = -1.0 / beta0_k2\n    r0_k2 = 2.0 * beta1_k2\n    \n    sigma_a0_k2 = np.abs(a0_k2**2) * np.sqrt(var_beta0_k2)\n    sigma_r0_k2 = 2.0 * np.sqrt(var_beta1_k2)\n\n    # --- 3. Fit extended model (order k^4) ---\n    # Model: y = beta_0 + beta_1 * k^2 + beta_2 * k^4\n    X4 = np.vstack([np.ones_like(k), k**2, k**4]).T\n    \n    XTWX4 = X4.T @ W @ X4\n    XTWy4 = X4.T @ W @ y\n    \n    C_beta4 = np.linalg.inv(XTWX4)\n    beta_hat4 = C_beta4 @ XTWy4\n    \n    beta0_k4, beta1_k4, _ = beta_hat4\n    var_beta0_k4, var_beta1_k4, _ = np.diag(C_beta4)\n    \n    # Extract physical parameters and propagate errors\n    a0_k4 = -1.0 / beta0_k4\n    r0_k4 = 2.0 * beta1_k4\n    \n    sigma_a0_k4 = np.abs(a0_k4**2) * np.sqrt(var_beta0_k4)\n    sigma_r0_k4 = 2.0 * np.sqrt(var_beta1_k4)\n\n    # --- 4. Calculate z-scores for comparison ---\n    # z = |val1 - val2| / sqrt(sigma1^2 + sigma2^2)\n    z_a0 = np.abs(a0_k2 - a0_k4) / np.sqrt(sigma_a0_k2**2 + sigma_a0_k4**2)\n    z_r0 = np.abs(r0_k2 - r0_k4) / np.sqrt(sigma_r0_k2**2 + sigma_r0_k4**2)\n    \n    return [a0_k2, r0_k2, a0_k4, r0_k4, z_a0, z_r0]\n\nsolve()\n```"
        },
        {
            "introduction": "在将物理理论转化为计算程序时，确保数值结果的物理自洽性至关重要。由于数值误差，计算出的散射矩阵（$S$矩阵）可能微小地偏离幺正性，导致从不同物理原理（如光学定理）计算出的总截面不一致。这个练习将教你如何识别这种不一致性，并实施一种后处理方法来恢复$S$矩阵的幺正性，从而保证计算结果的物理可靠性。",
            "id": "3579058",
            "problem": "给定一项计算任务，该任务源于计算核物理中无自旋、中心势散射的分波分析。考虑一个波数为 $k$（单位为 $\\mathrm{fm}^{-1}$）、有限分波截断为 $L_{\\max}$ 的单通道散射问题。分波散射振幅定义为 $f(\\theta) = \\dfrac{1}{2 i k} \\sum_{\\ell=0}^{L_{\\max}} (2 \\ell + 1) \\left(S_{\\ell} - 1\\right) P_{\\ell}(\\cos \\theta)$，其中 $P_{\\ell}$ 是 $\\ell$ 阶 Legendre 多项式，$S_{\\ell}$ 是散射矩阵的分波元。光学定理指出，总截面满足 $\\sigma_{\\text{tot}} = \\dfrac{4 \\pi}{k} \\operatorname{Im} f(0)$，当使用 $P_{\\ell}(1)=1$ 计算 $f(0)$ 时，可得到分波表达式 $\\sigma_{\\text{tot}}(S) = \\dfrac{2 \\pi}{k^{2}} \\sum_{\\ell=0}^{L_{\\max}} (2 \\ell + 1) \\left(1 - \\operatorname{Re} S_{\\ell}\\right)$。对于纯弹性的单通道中心势，幺正性要求 $|S_{\\ell}| = 1$，因此可以写作 $S_{\\ell} = e^{2 i \\delta_{\\ell}}$，其中相移 $\\delta_{\\ell} \\in \\mathbb{R}$。于是 $\\sigma_{\\text{tot}} = \\dfrac{4 \\pi}{k^{2}} \\sum_{\\ell=0}^{L_{\\max}} (2 \\ell + 1) \\sin^{2} \\delta_{\\ell}$。然而，在数值实践中，计算出的 $S_{\\ell}$ 可能会表现出对幺正性的微小违背，即 $|S_{\\ell}| \\neq 1$。如果试图同时通过光学定理和仅使用相位的弹性公式来计算 $\\sigma_{\\text{tot}}$，这会导致不一致性。\n\n您的任务是：\n- 仅从上述定义和纯弹性单通道中心势的幺正性要求出发，分析当 $S_{\\ell}$ 偏离单位圆时所引起的不一致性。然后，实现一种后处理幺正化方法，通过将每个 $S_{\\ell}$ 投影回单位模而不改变其相位，来恢复弹性情况下 $\\sigma_{\\text{tot}}$ 与光学定理的一致性。\n- 对每个给定的测试用例，计算两个绝对不一致性度量（单位为 $\\mathrm{fm}^{2}$）：\n  1. 幺正化前的绝对差，$\\Delta_{\\text{before}} = \\left| \\sigma_{\\text{opt}}(S) - \\sigma_{\\text{phase}}(S) \\right|$，其中 $\\sigma_{\\text{opt}}(S) = \\dfrac{2 \\pi}{k^{2}} \\sum_{\\ell=0}^{L_{\\max}} (2 \\ell + 1) \\left(1 - \\operatorname{Re} S_{\\ell} \\right)$ 且 $\\sigma_{\\text{phase}}(S) = \\dfrac{4 \\pi}{k^{2}} \\sum_{\\ell=0}^{L_{\\max}} (2 \\ell + 1) \\sin^{2} \\left(\\tfrac{1}{2} \\arg S_{\\ell} \\right)$。\n  2. 幺正化后的绝对差，$\\Delta_{\\text{after}} = \\left| \\sigma_{\\text{opt}}(S^{\\prime}) - \\sigma_{\\text{phase}}(S^{\\prime}) \\right|$，其中幺正化的矩阵元为：当 $|S_{\\ell}| \\neq 0$ 时 $S_{\\ell}^{\\prime} = \\dfrac{S_{\\ell}}{|S_{\\ell}|}$，当 $|S_{\\ell}| = 0$ 时 $S_{\\ell}^{\\prime} = 1$。\n- 所有角度必须以弧度处理。所有截面必须以 $\\mathrm{fm}^{2}$ 表示，仅通过实现语言的默认浮点输出进行舍入。\n\n定义以下测试套件。在每个案例中，通过 $S_{\\ell} = \\rho_{\\ell} \\exp\\left(2 i \\delta_{\\ell}\\right)$ 从幅度-相位数据 $(\\rho_{\\ell}, \\delta_{\\ell})$ 构建 $S_{\\ell}$。波数 $k$ 以 $\\mathrm{fm}^{-1}$ 为单位指定。\n\n- 案例 $\\mathbf{1}$（微小违背的正常路径）：$k = 1.0$, $L_{\\max} = 3$，其中\n  - $\\ell = 0$: $\\rho_{0} = 1.002$, $\\delta_{0} = 0.35$,\n  - $\\ell = 1$: $\\rho_{1} = 0.998$, $\\delta_{1} = 0.20$,\n  - $\\ell = 2$: $\\rho_{2} = 1.001$, $\\delta_{2} = 0.05$,\n  - $\\ell = 3$: $\\rho_{3} = 0.997$, $\\delta_{3} = 0.01$。\n- 案例 $\\mathbf{2}$（边界，可能为负）：$k = 0.5$, $L_{\\max} = 0$，其中\n  - $\\ell = 0$: $\\rho_{0} = 1.01$, $\\delta_{0} = 0.02$。\n- 案例 $\\mathbf{3}$（已经幺正）：$k = 1.2$, $L_{\\max} = 2$，其中\n  - $\\ell = 0$: $\\rho_{0} = 1.0$, $\\delta_{0} = 0.40$,\n  - $\\ell = 1$: $\\rho_{1} = 1.0$, $\\delta_{1} = 0.15$,\n  - $\\ell = 2$: $\\rho_{2} = 1.0$, $\\delta_{2} = 0.02$。\n- 案例 $\\mathbf{4}$（更严重但仍然微小的违背）：$k = 0.8$, $L_{\\max} = 4$，其中\n  - $\\ell = 0$: $\\rho_{0} = 1.03$, $\\delta_{0} = 0.30$,\n  - $\\ell = 1$: $\\rho_{1} = 0.97$, $\\delta_{1} = 0.25$,\n  - $\\ell = 2$: $\\rho_{2} = 1.02$, $\\delta_{2} = 0.10$,\n  - $\\ell = 3$: $\\rho_{3} = 0.99$, $\\delta_{3} = 0.04$,\n  - $\\ell = 4$: $\\rho_{4} = 1.01$, $\\delta_{4} = 0.01$。\n\n您的程序必须：\n- 从第一性原理出发，实现上述 $\\sigma_{\\text{opt}}$、$\\sigma_{\\text{phase}}$ 的公式以及幺正化映射 $S_{\\ell} \\mapsto S_{\\ell}^{\\prime}$。\n- 对每个案例，返回以 $\\mathrm{fm}^{2}$ 为单位的数对 $\\left(\\Delta_{\\text{before}}, \\Delta_{\\text{after}}\\right)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $\\left[\\Delta_{\\text{before}}^{(1)}, \\Delta_{\\text{after}}^{(1)}, \\Delta_{\\text{before}}^{(2)}, \\Delta_{\\text{after}}^{(2)}, \\Delta_{\\text{before}}^{(3)}, \\Delta_{\\text{after}}^{(3)}, \\Delta_{\\text{before}}^{(4)}, \\Delta_{\\text{after}}^{(4)}\\right]$，其中上标按递增顺序标记案例。",
            "solution": "该问题要求在量子散射理论的分波形式中，对总截面 $\\sigma_{\\text{tot}}$ 的计算进行分析和实现。具体来说，它解决了当为纯弹性散射过程计算的分波S矩阵元 $S_{\\ell}$ 表现出对幺正性条件 $|S_{\\ell}| = 1$ 的微小偏离时出现的数值不一致性问题。任务是量化这种不一致性，然后通过对S矩阵进行后处理幺正化来展示其解决方案。\n\n该问题背后的科学原理植根于光学定理和S矩阵的幺正性。对于弹性散射，如果理论得到遵守，总截面可以通过两种等效的方式计算。\n\n第一种方法是光学定理的直接应用，$\\sigma_{\\text{tot}} = \\frac{4 \\pi}{k} \\operatorname{Im} f(0)$，其中 $f(0)$ 是前向散射振幅。使用分波展开 $f(\\theta) = \\frac{1}{2 i k} \\sum_{\\ell=0}^{L_{\\max}} (2 \\ell + 1) (S_{\\ell} - 1) P_{\\ell}(\\cos \\theta)$ 和性质 $P_{\\ell}(1)=1$，前向振幅为 $f(0) = \\frac{1}{2 i k} \\sum_{\\ell=0}^{L_{\\max}} (2 \\ell + 1) (S_{\\ell} - 1)$。取其虚部并代入光学定理，得到记为 $\\sigma_{\\text{opt}}$ 的公式：\n$$\n\\sigma_{\\text{opt}}(S) = \\frac{2 \\pi}{k^{2}} \\sum_{\\ell=0}^{L_{\\max}} (2 \\ell + 1) (1 - \\operatorname{Re} S_{\\ell})\n$$\n这个公式是通用的，即使对于非幺正的 $S_{\\ell}$（即当非弹性通道开放时）也成立，此时它代表弹性和反应截面之和。\n\n第二种方法专用于纯弹性散射。幺正性要求对所有分波 $\\ell$ 都有 $|S_{\\ell}| = 1$。这使得每个 $S_{\\ell}$ 都可以通过一个单一的实数量，即相移 $\\delta_{\\ell}$，来参数化为 $S_{\\ell} = e^{2 i \\delta_{\\ell}}$。将此代入 $\\sigma_{\\text{opt}}$ 公式，其中 $\\operatorname{Re} S_{\\ell} = \\cos(2\\delta_{\\ell})$，可得：\n$$\n\\sigma_{\\text{tot}} = \\frac{2 \\pi}{k^{2}} \\sum_{\\ell=0}^{L_{\\max}} (2 \\ell + 1) (1 - \\cos(2\\delta_{\\ell}))\n$$\n使用三角恒等式 $1 - \\cos(2\\delta_{\\ell}) = 2\\sin^2(\\delta_{\\ell})$，上式变为：\n$$\n\\sigma_{\\text{tot}} = \\frac{4 \\pi}{k^{2}} \\sum_{\\ell=0}^{L_{\\max}} (2 \\ell + 1) \\sin^2(\\delta_{\\ell})\n$$\n问题将此定义为 $\\sigma_{\\text{phase}}(S)$，并指出相移 $\\delta_{\\ell}$ 可以通过 $\\delta_{\\ell} = \\frac{1}{2} \\arg S_{\\ell}$ 从一个通用的复数 $S_{\\ell}$ 中恢复。因此，第二个公式是：\n$$\n\\sigma_{\\text{phase}}(S) = \\frac{4 \\pi}{k^{2}} \\sum_{\\ell=0}^{L_{\\max}} (2 \\ell + 1) \\sin^{2} \\left(\\tfrac{1}{2} \\arg S_{\\ell} \\right)\n$$\n\n当 $|S_{\\ell}| \\neq 1$ 时，不一致性就出现了。让我们以极坐标形式表示一个非幺正的 $S_{\\ell}$：$S_{\\ell} = \\rho_{\\ell} e^{2 i \\delta_{\\ell}}$，其中 $\\rho_{\\ell} = |S_{\\ell}|$ 是幅度， $2\\delta_{\\ell} = \\arg S_{\\ell}$ 是相位。\n第一个公式使用 $\\operatorname{Re} S_{\\ell} = \\rho_{\\ell} \\cos(2\\delta_{\\ell})$。其求和项与 $(1 - \\rho_{\\ell}\\cos(2\\delta_{\\ell}))$ 成比例。\n第二个公式使用 $\\sin^2(\\delta_{\\ell})$。其求和项与 $2\\sin^2(\\delta_{\\ell}) = 1 - \\cos(2\\delta_{\\ell})$ 成比例。\n仅当 $\\rho_{\\ell} = 1$ 时，这两个表达式逐项等价。当 $\\rho_{\\ell} \\neq 1$ 时，就会出现一个差异 $\\Delta_{\\text{before}} = |\\sigma_{\\text{opt}}(S) - \\sigma_{\\text{phase}}(S)|$。这是我们必须首先计算的量。\n\n任务的第二部分是解决这种不一致性。指定的方法是将每个 $S_{\\ell}$ 投影到复平面上的单位圆上，这可以在保持相位不变的同时恢复幺正性。幺正化的矩阵元 $S'_{\\ell}$ 定义为：\n$$\nS'_{\\ell} = \\frac{S_{\\ell}}{|S_{\\ell}|} = \\frac{\\rho_{\\ell} e^{2 i \\delta_{\\ell}}}{\\rho_{\\ell}} = e^{2 i \\delta_{\\ell}} \\quad (\\text{对于 } |S_{\\ell}| \\neq 0)\n$$\n特殊情况 $|S_{\\ell}|=0$ 映射到 $S'_{\\ell}=1$。对于这些新的、严格幺正的元 $S'_{\\ell}$，我们有幅度 $|\\rho'_{\\ell}|=1$ 且相位不变。当我们使用 $S'$ 重新计算截面时：\n$\\sigma_{\\text{opt}}(S')$ 公式包含项 $(1 - \\operatorname{Re} S'_{\\ell}) = (1 - \\cos(2\\delta_{\\ell}))$。\n$\\sigma_{\\text{phase}}(S')$ 公式包含项 $\\sin^2(\\frac{1}{2}\\arg S'_{\\ell}) = \\sin^2(\\delta_{\\ell})$。\n因此，$\\sigma_{\\text{opt}}(S') = \\frac{2\\pi}{k^2} \\sum (2\\ell+1)(1-\\cos(2\\delta_\\ell))$ 且 $\\sigma_{\\text{phase}}(S') = \\frac{4\\pi}{k^2} \\sum (2\\ell+1)\\sin^2(\\delta_\\ell)$。如恒等式 $1-\\cos(2x)=2\\sin^2(x)$ 所示，这两个表达式在数学上是相同的。\n因此，幺正化后的不一致性 $\\Delta_{\\text{after}} = |\\sigma_{\\text{opt}}(S') - \\sigma_{\\text{phase}}(S')|$ 必须为零，直至浮点精度的极限。\n\n该算法旨在直接实现这些公式。对于每个由波数 $k$、分波截断 $L_{\\max}$ 和一组对应于 $\\ell \\in [0, L_{\\max}]$ 的 $(\\rho_{\\ell}, \\delta_{\\ell})$ 对指定的测试用例：\n1. 构建复数S矩阵元数组 $S_{\\ell} = \\rho_{\\ell} \\exp(2 i \\delta_{\\ell})$。\n2. 根据定义对分波贡献求和，计算 $\\sigma_{\\text{opt}}(S)$ 和 $\\sigma_{\\text{phase}}(S)$。为了效率，使用了 `numpy` 中的矢量化操作。\n3. 计算 $\\Delta_{\\text{before}} = |\\sigma_{\\text{opt}}(S) - \\sigma_{\\text{phase}}(S)|$。\n4. 通过将每个 $S_{\\ell}$ 除以其模 $\\rho_{\\ell}$（如果模为 $0$ 则设为 $1$）来构建幺正化S矩阵元数组 $S'_{\\ell}$。\n5. 使用相同的求和逻辑计算 $\\sigma_{\\text{opt}}(S')$ 和 $\\sigma_{\\text{phase}}(S')$。\n6. 计算 $\\Delta_{\\text{after}} = |\\sigma_{\\text{opt}}(S') - \\sigma_{\\text{phase}}(S')|$。\n7. 对每个案例，存储数对 $(\\Delta_{\\text{before}}, \\Delta_{\\text{after}})$，并按要求将最终结果格式化为单行输出。\n此过程直接遵循所概述的第一性原理，为该概念提供了清晰的数值演示。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_inconsistencies(k, L_max, rho_delta_pairs):\n    \"\"\"\n    Calculates the inconsistency metrics for a given scattering setup.\n\n    Args:\n        k (float): The wavenumber in fm^-1.\n        L_max (int): The maximum partial wave angular momentum.\n        rho_delta_pairs (list of tuples): A list of (rho_l, delta_l) pairs\n                                           for l from 0 to L_max.\n\n    Returns:\n        tuple: A pair (delta_before, delta_after) in fm^2.\n    \"\"\"\n    l_values = np.arange(L_max + 1)\n    weights = 2 * l_values + 1\n    \n    rhos = np.array([p[0] for p in rho_delta_pairs])\n    deltas = np.array([p[1] for p in rho_delta_pairs])\n\n    # 1. Before unitarization\n    # Construct S_l from given rho_l and delta_l\n    S_l = rhos * np.exp(2j * deltas)\n    \n    # Calculate sigma_opt(S)\n    sum_opt_before = np.sum(weights * (1 - np.real(S_l)))\n    sigma_opt_before = (2 * np.pi / k**2) * sum_opt_before\n    \n    # Calculate sigma_phase(S). The phase shift delta_l is (1/2)*arg(S_l).\n    # Since we construct S_l from delta_l, we can use delta_l directly.\n    sum_phase_before = np.sum(weights * (np.sin(deltas)**2))\n    sigma_phase_before = (4 * np.pi / k**2) * sum_phase_before\n    \n    delta_before = np.abs(sigma_opt_before - sigma_phase_before)\n\n    # 2. After unitarization\n    # Construct unitarized S'_l\n    S_l_prime = np.zeros_like(S_l)\n    # The problem specifies S'_l = 1 if |S_l|=0, and S_l/|S_l| otherwise.\n    # In our data, rho_l = |S_l| is never zero.\n    non_zero_rhos = rhos != 0\n    S_l_prime[non_zero_rhos] = S_l[non_zero_rhos] / rhos[non_zero_rhos]\n    S_l_prime[~non_zero_rhos] = 1.0 + 0.0j # Corresponds to S_l = 0\n\n    # Calculate sigma_opt(S')\n    sum_opt_after = np.sum(weights * (1 - np.real(S_l_prime)))\n    sigma_opt_after = (2 * np.pi / k**2) * sum_opt_after\n    \n    # Calculate sigma_phase(S'). The phase of S'_l is the same as S_l.\n    # So we can use the same `deltas` array.\n    sum_phase_after = np.sum(weights * (np.sin(deltas)**2))\n    sigma_phase_after = (4 * np.pi / k**2) * sum_phase_after\n\n    delta_after = np.abs(sigma_opt_after - sigma_phase_after)\n\n    return delta_before, delta_after\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            'k': 1.0, 'L_max': 3,\n            'data': [(1.002, 0.35), (0.998, 0.20), (1.001, 0.05), (0.997, 0.01)]\n        },\n        # Case 2\n        {\n            'k': 0.5, 'L_max': 0,\n            'data': [(1.01, 0.02)]\n        },\n        # Case 3\n        {\n            'k': 1.2, 'L_max': 2,\n            'data': [(1.0, 0.40), (1.0, 0.15), (1.0, 0.02)]\n        },\n        # Case 4\n        {\n            'k': 0.8, 'L_max': 4,\n            'data': [(1.03, 0.30), (0.97, 0.25), (1.02, 0.10), (0.99, 0.04), (1.01, 0.01)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        k = case['k']\n        L_max = case['L_max']\n        rho_delta_pairs = case['data']\n        \n        delta_before, delta_after = calculate_inconsistencies(k, L_max, rho_delta_pairs)\n        results.append(delta_before)\n        results.append(delta_after)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}