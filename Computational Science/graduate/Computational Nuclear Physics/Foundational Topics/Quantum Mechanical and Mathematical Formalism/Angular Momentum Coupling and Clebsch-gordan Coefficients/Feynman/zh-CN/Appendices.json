{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，首要任务是将其应用于具体计算。本练习旨在连接角动量耦合的抽象理论与一项具体的物理计算，即高恩特系数（Gaunt coefficient）的求解()。通过这个练习，你将看到在处理球谐函数乘积的积分时，克莱布施-戈登系数是如何自然出现的——这在量子力学中计算相互作用矩阵元时是一个非常普遍的场景。完成此题将加深你对选择定则以及高恩特系数与克莱布施-戈登系数之间关系的理解。",
            "id": "3541865",
            "problem": "在计算核物理中，两体算符和平均场通常在球张量基中表示，这将许多角积分简化为对球谐函数乘积的积分。根据 Condon–Shortley 相位约定，复球谐函数的高恩特系数定义为\n$$\nG(\\ell_{1} m_{1};\\, \\ell_{2} m_{2};\\, \\ell_{3} m_{3}) \\equiv \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{\\pi} Y_{\\ell_{1} m_{1}}(\\theta,\\phi)\\,Y_{\\ell_{2} m_{2}}(\\theta,\\phi)\\,Y_{\\ell_{3} m_{3}}(\\theta,\\phi)\\,\\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi,\n$$\n其正交归一约定为\n$$\n\\int Y_{\\ell m}^{*}(\\Omega)\\,Y_{\\ell' m'}(\\Omega)\\,\\mathrm{d}\\Omega \\;=\\; \\delta_{\\ell \\ell'}\\,\\delta_{m m'}.\n$$\n从球谐函数作为转动下的不可约球张量分量的定义以及克莱布施-戈登系数 (CGC) 的标准性质出发，计算特定的高恩特系数\n$$\nG(1\\,1;\\,1\\,{-}1;\\,2\\,0).\n$$\n作为推导的一部分，明确论证此情况下关于 $\\ell$ 的三角选择定则和 $m$-求和选择定则。将最终答案表示为精确的闭合形式表达式。不要四舍五入。无需单位。",
            "solution": "题目要求使用球谐函数作为不可约球张量的性质以及克莱布施-戈登系数的代数来计算一个特定的高恩特系数 $G(1\\,1;\\,1\\,{-}1;\\,2\\,0)$。\n\n高恩特系数定义为三个复球谐函数的乘积在立体角 $\\Omega$ 上的积分：\n$$\nG(\\ell_{1} m_{1};\\, \\ell_{2} m_{2};\\, \\ell_{3} m_{3}) \\equiv \\int Y_{\\ell_{1} m_{1}}(\\Omega)\\,Y_{\\ell_{2} m_{2}}(\\Omega)\\,Y_{\\ell_{3} m_{3}}(\\Omega)\\,\\mathrm{d}\\Omega\n$$\n这个积分代表一个标量，因为它是对在转动下以特定方式变换的函数乘积的全空间积分。为了使积分为非零，被积函数本身必须像标量一样变换，即它必须在转动下保持不变。这种转动不变性对量子数 $\\ell_i$ 和 $m_i$ 施加了几个选择定则。\n\n首先，我们按要求论证选择定则：\n1.  **$m$-求和选择定则**：考虑坐标系绕 $z$ 轴旋转一个角度 $\\alpha$。在这样的转动下，球谐函数 $Y_{\\ell m}(\\theta, \\phi)$ 的变换为 $Y_{\\ell m} \\rightarrow \\exp(im\\alpha) Y_{\\ell m}$。因此，三个球谐函数的乘积变换为：\n    $$\n    Y_{\\ell_{1} m_{1}} Y_{\\ell_{2} m_{2}} Y_{\\ell_{3} m_{3}} \\rightarrow \\exp(i(m_1+m_2+m_3)\\alpha) Y_{\\ell_{1} m_{1}} Y_{\\ell_{2} m_{2}} Y_{\\ell_{3} m_{3}}\n    $$\n    由于积分是一个标量，它必须与坐标系的方向无关。因此，被积函数必须在此转动下保持不变，这要求对于任意角度 $\\alpha$，相位因子都为 1。这仅在 $m_1 + m_2 + m_3 = 0$ 时成立。对于 $G(1\\,1;\\,1\\,{-}1;\\,2\\,0)$ 的具体情况，我们有 $m_1=1$，$m_2=-1$ 和 $m_3=0$。它们的和是 $1 + (-1) + 0 = 0$，所以这个选择定则得到满足。\n\n2.  **三角选择定则**：根据角动量理论，两个秩为 $\\ell_1$ 和 $\\ell_2$ 的不可约球张量（由 $Y_{\\ell_1 m_1}$ 和 $Y_{\\ell_2 m_2}$ 表示）的乘积可以分解为一系列秩为 $L$ 的不可约球张量之和，其中 $L$ 受矢量耦合规则 $|\\ell_1 - \\ell_2| \\le L \\le \\ell_1 + \\ell_2$ 的约束。高恩特积分可以看作是张量 $Y_{\\ell_3 m_3}$ 与这个分解后的乘积的标量积。由于正交性，只有当秩 $\\ell_3$ 包含在由 $\\ell_1$ 和 $\\ell_2$ 耦合产生的可能秩 $L$ 之内时，积分才为非零。这直接导出了三角选择定则：$|\\ell_1 - \\ell_2| \\le \\ell_3 \\le \\ell_1 + \\ell_2$。对于给定的问题，$\\ell_1=1$，$\\ell_2=1$ 和 $\\ell_3=2$。条件是 $|1-1| \\le 2 \\le 1+1$，简化为 $0 \\le 2 \\le 2$。此条件得到满足。\n\n第三个重要的选择定则与宇称有关。球谐函数 $Y_{\\ell m}$ 的宇称为 $(-1)^\\ell$。只有当被积函数具有偶宇称时，积分才非零，即 $(-1)^{\\ell_1} (-1)^{\\ell_2} (-1)^{\\ell_3} = 1$。这要求和 $\\ell_1+\\ell_2+\\ell_3$ 为偶数。在我们的例子中，$1+1+2=4$，是偶数。\n\n为了计算高恩特系数，我们使用一个标准公式，该公式将三个球谐函数的积分与克莱布施-戈登系数 (CGCs) 的乘积联系起来。这个公式是通过展开两个球谐函数的乘积，然后使用正交归一关系推导出来的。一个关键步骤是将高恩特积分与包含复共轭的标准形式联系起来。使用 Condon-Shortley 相位约定，$Y_{\\ell m}^* = (-1)^m Y_{\\ell, -m}$，我们可以写出 $Y_{\\ell_3 m_3} = (-1)^{m_3}(Y_{\\ell_3, -m_3})^*$。高恩特系数变为：\n$$\nG(\\ell_{1} m_{1}; \\ell_{2} m_{2}; \\ell_{3} m_{3}) = (-1)^{m_3} \\int Y_{\\ell_{1} m_{1}}(\\Omega)\\,Y_{\\ell_{2} m_{2}}(\\Omega)\\, (Y_{\\ell_{3} -m_{3}}(\\Omega))^* \\,\\mathrm{d}\\Omega\n$$\n右边的积分是众所周知的，其表达式为：\n$$\n\\int Y_{\\ell_{1} m_{1}} Y_{\\ell_{2} m_{2}} Y_{L M}^* \\,\\mathrm{d}\\Omega = \\sqrt{\\frac{(2\\ell_1+1)(2\\ell_2+1)}{4\\pi(2L+1)}} \\langle \\ell_1 0 \\ell_2 0 | L 0 \\rangle \\langle \\ell_1 m_1 \\ell_2 m_2 | L M \\rangle\n$$\n令 $L=\\ell_3$ 和 $M=-m_3$ 可得到高恩特系数的最终表达式：\n$$\nG(\\ell_{1} m_{1}; \\ell_{2} m_{2}; \\ell_{3} m_{3}) = (-1)^{m_3} \\sqrt{\\frac{(2\\ell_1+1)(2\\ell_2+1)}{4\\pi(2\\ell_3+1)}} \\langle \\ell_1 0 \\ell_2 0 | \\ell_3 0 \\rangle \\langle \\ell_1 m_1 \\ell_2 m_2 | \\ell_3 (-m_3) \\rangle\n$$\n现在我们将此公式应用于特定情况 $G(1\\,1;\\,1\\,{-}1;\\,2\\,0)$。参数为 $\\ell_1=1$，$m_1=1$；$\\ell_2=1$，$m_2=-1$；以及 $\\ell_3=2$，$m_3=0$。\n代入这些值：\n$$\nG(1,1; 1,{-}1; 2,0) = (-1)^0 \\sqrt{\\frac{(2(1)+1)(2(1)+1)}{4\\pi(2(2)+1)}} \\langle 1 0 1 0 | 2 0 \\rangle \\langle 1 1 1 {-1} | 2 0 \\rangle\n$$\n$$\nG(1,1; 1,{-}1; 2,0) = \\sqrt{\\frac{3 \\cdot 3}{4\\pi \\cdot 5}} \\langle 1 0 1 0 | 2 0 \\rangle \\langle 1 1 1 {-1} | 2 0 \\rangle = \\frac{3}{2\\sqrt{5\\pi}} \\langle 1 0 1 0 | 2 0 \\rangle \\langle 1 1 1 {-1} | 2 0 \\rangle\n$$\n所需的克莱布施-戈登系数是用于耦合两个角动量 $j_1=1$ 和 $j_2=1$ 以形成总角动量 $J=2$ 的情况。这些是标准系数。态 $|J=2, M=0\\rangle$ 由乘积态 $|j_1, m_1\\rangle |j_2, m_2\\rangle$ 构造如下：\n$$\n|2,0\\rangle = \\frac{1}{\\sqrt{6}} |1,1\\rangle|1,{-}1\\rangle + \\frac{2}{\\sqrt{6}} |1,0\\rangle|1,0\\rangle + \\frac{1}{\\sqrt{6}} |1,{-}1\\rangle|1,1\\rangle\n$$\n从这个展开式中，我们可以读出系数：\n$$\n\\langle 1 1 1 {-1} | 2 0 \\rangle = \\frac{1}{\\sqrt{6}}\n$$\n$$\n\\langle 1 0 1 0 | 2 0 \\rangle = \\frac{2}{\\sqrt{6}}\n$$\n将这些值代入我们关于高恩特系数的表达式中：\n$$\nG(1,1; 1,{-}1; 2,0) = \\frac{3}{2\\sqrt{5\\pi}} \\left(\\frac{2}{\\sqrt{6}}\\right) \\left(\\frac{1}{\\sqrt{6}}\\right)\n$$\n$$\nG(1,1; 1,{-}1; 2,0) = \\frac{3}{2\\sqrt{5\\pi}} \\left(\\frac{2}{6}\\right) = \\frac{3}{2\\sqrt{5\\pi}} \\left(\\frac{1}{3}\\right)\n$$\n$$\nG(1,1; 1,{-}1; 2,0) = \\frac{1}{2\\sqrt{5\\pi}}\n$$\n这就是指定的高恩特系数的精确闭合形式表达式。",
            "answer": "$$\\boxed{\\frac{1}{2\\sqrt{5\\pi}}}$$"
        },
        {
            "introduction": "从单个计算走向大规模问题，需要系统化的数据管理方法。在核壳模型等计算中，需要用到大量的克莱布希-高登系数，如何高效地存储和访问它们是一个关键的实践挑战()。在此练习中，你将设计并实现一个紧凑的索引方案，这要求你将角动量耦合的物理选择定则转化为高效的计算机算法。这是计算物理学家的必备核心技能之一。",
            "id": "3541884",
            "problem": "您需要为计算核物理中存储Clebsch–Gordan系数设计并实现一个紧凑、连续的索引方案。这些系数由两个角动量相加的六元量子数组 $\\left(j_1, j_2, J, m_1, m_2, M\\right)$ 作为键值，其中 $j_1$ 和 $j_2$ 是单粒子总角动量，$m_1$ 和 $m_2$ 是它们的分量，$J$ 是耦合后的总角动量，$M$ 是耦合后的分量。您的方案必须严格执行角动量耦合的选择定则，并且您必须估算在几个典型的壳模型空间中存储所有这些系数所需的内存占用。\n\n将使用的基本和核心定义：\n- 在量子力学中，两个角动量的相加通过使用Clebsch–Gordan系数 $\\left\\langle j_1 m_1 j_2 m_2 \\mid J M \\right\\rangle$ 从非耦合的张量积基 $\\left| j_1 m_1 \\right\\rangle \\otimes \\left| j_2 m_2 \\right\\rangle$ 构建耦合基 $\\left| J M \\right\\rangle$，其定义为\n$$\n\\left| J M \\right\\rangle = \\sum_{m_1, m_2} \\left| j_1 m_1 \\right\\rangle \\otimes \\left| j_2 m_2 \\right\\rangle \\, \\left\\langle j_1 m_1 j_2 m_2 \\mid J M \\right\\rangle.\n$$\n- 经过充分检验的选择定则如下：\n  1. 三角条件：$\\left| j_1 - j_2 \\right| \\le J \\le j_1 + j_2$。\n  2. 分量守恒：$M = m_1 + m_2$。\n  3. 取值范围：对于 $i \\in \\{1,2\\}$ 有 $-j_i \\le m_i \\le j_i$，以及 $-J \\le M \\le J$。\n  4. 半整数一致性：$j_1$, $j_2$, $J$, $m_1$, $m_2$, $M$ 要么全部是整数，要么全部是半整数，使得 $j_1 + j_2 + J$ 是一个整数，并且 $m_1 + m_2 = M$ 在所有磁量子数都以单位1为步长的情况下成立。\n\n任务：\n1. 将所有半整数量子数表示为双倍整数，以获得纯整数域。也就是说，将 $2j_1$, $2j_2$, $2J$, $2m_1$, $2m_2$, $2M$ 存储为整数。在此表示下，有效的枚举使用步长 $2$ 来保持半整数格点结构。\n2. 定义一个对所有允许的六元组 $\\left(2j_1, 2j_2, 2J, 2m_1, 2m_2, 2M\\right)$ 的规范字典序枚举，该枚举通过构造来强制执行选择定则：\n   - 将允许的单粒子 $j$ 值的输入集合按升序排序，并转换为双倍整数。\n   - 按升序字典序枚举有序对 $\\left(2j_1, 2j_2\\right)$。对于对称折叠的变体，限制为 $\\left(2j_1 \\le 2j_2\\right)$。\n   - 对于每对，从 $\\left|2j_1 - 2j_2\\right|$ 到 $\\left(2j_1 + 2j_2\\right)$ 以步长 $2$ 枚举 $2J$。\n   - 对于每个 $2J$，从 $-2J$ 到 $2J$ 以步长 $2$ 枚举 $2M$。\n   - 对于每个 $2M$，从 $-2j_1$ 到 $2j_1$ 以步长 $2$ 枚举 $2m_1$，设置 $2m_2 = 2M - 2m_1$，如果满足 $-2j_2 \\le 2m_2 \\le 2j_2$，则包含该六元组。\n   - 一个六元组的线性索引是它在此枚举中从 $0$ 开始的位次。\n3. 对于下面测试套件中的每个壳模型空间，计算存储的系数总数以及将每个Clebsch–Gordan系数存储为 $64$ 位浮点数（即每个系数 $8$ 字节）时的内存占用。报告“有序对”存储（所有 $\\left(2j_1,2j_2\\right)$，包括 $2j_1 > 2j_2$）和“对称折叠”存储（仅 $\\left(2j_1 \\le 2j_2\\right)$）。\n4. 您的程序必须实现上述枚举和索引方案，并且必须通过在双倍整数空间中显式执行选择定则来计算数量。它不得要求任何用户输入。\n\n测试套件：\n- 测试 $\\mathcal{T}_1$：$j$-集 $S_1 = \\{ \\tfrac{1}{2} \\}$。\n- 测试 $\\mathcal{T}_2$：$j$-集 $S_2 = \\{ \\tfrac{1}{2}, \\tfrac{3}{2}, \\tfrac{5}{2} \\}$（一个 $sd$-壳模型空间）。\n- 测试 $\\mathcal{T}_3$：$j$-集 $S_3 = \\{ \\tfrac{1}{2}, \\tfrac{3}{2}, \\tfrac{5}{2}, \\tfrac{7}{2} \\}$（一个 $pf$-壳模型空间）。\n- 测试 $\\mathcal{T}_4$：$j$-集 $S_4 = \\{ \\tfrac{9}{2} \\}$（一个单轨道 $g_{9/2}$ 空间）。\n\n对于每个测试 $\\mathcal{T}_k$，计算：\n- $N_{\\mathrm{ord}}$：有序对枚举下存储的六元组数量，\n- $B_{\\mathrm{ord}}$：有序对存储的总字节数，等于 $N_{\\mathrm{ord}} \\times 8$，\n- $N_{\\mathrm{fold}}$：在 $2j_1 \\le 2j_2$ 的对称折叠枚举下存储的六元组数量，\n- $B_{\\mathrm{fold}}$：折叠存储的总字节数，等于 $N_{\\mathrm{fold}} \\times 8$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个类JSON列表，每个测试一个条目，顺序为 $\\left[\\mathcal{T}_1,\\mathcal{T}_2,\\mathcal{T}_3,\\mathcal{T}_4\\right]$。\n- 每个条目本身必须是使用整数值的列表 $\\left[N_{\\mathrm{ord}}, B_{\\mathrm{ord}}, N_{\\mathrm{fold}}, B_{\\mathrm{fold}}\\right]$。\n- 示例示意图（非实际值）：$\\left[\\left[n_1,b_1,n'_1,b'_1\\right],\\left[n_2,b_2,n'_2,b'_2\\right],\\left[n_3,b_3,n'_3,b'_3\\right],\\left[n_4,b_4,n'_4,b'_4\\right]\\right]$。\n\n不涉及角度，因此无需指定角度单位。所有内存必须以字节为单位报告。程序必须是自包含的，并且不得读取输入。",
            "solution": "问题陈述经评估有效。它在科学上基于量子角动量理论的原理，问题设定良好，具有明确的算法目标，并使用客观、正式的语言。所提供的数据和约束是完整且一致的。\n\n任务是为几个指定的单粒子角动量 $j$ 集合，实现一个计数方案，用于计算非零Clebsch-Gordan系数 $\\left\\langle j_1 m_1 j_2 m_2 \\mid J M \\right\\rangle$ 的数量。这个计数决定了存储这些系数所需的内存。解决方案涉及开发一种算法，该算法根据角动量耦合的基本选择定则，系统地枚举六个量子数 $(j_1, j_2, J, m_1, m_2, M)$ 的所有有效组合。\n\n**1. 整数表示**\n\n一个关键要求是使用纯整数表示来处理整数和半整数量子数。这通过将所有量子数加倍来实现。一个量子数 $j$ 变成 $2j$，$m$ 变成 $2m$，依此类推。在这种表示中，所有量子数都是整数。量子数以1为步长变化的物理约束（例如，$m, m+1, \\ldots$）转化为双倍整数以2为步长变化（例如，$2m, 2m+2, \\ldots$）。这在避免潜在的浮点精度问题的同时，保留了量子力学状态空间的结构。对于给定的角动量 $j$，双倍分量 $2m$ 的范围是从 $-2j$ 到 $2j$，步长为 $2$。\n\n**2. 枚举和计数策略**\n\n问题指定了对双倍整数六元组 $(2j_1, 2j_2, 2J, 2m_1, 2m_2, 2M)$ 的字典序枚举。有效六元组的总数即为所需的计数值。直接的暴力实现将涉及一组与此枚举顺序对应的嵌套循环。然而，这里采用了一种计算效率更高的策略。\n\n计算按单粒子角动量对 $(j_1, j_2)$ 分解。对于给定的一对，其系数数量，我们称之为 $C(j_1, j_2)$，与其他对无关。Clebsch-Gordan系数的选择定则对于两个耦合粒子的交换是对称的，这意味着 $C(j_1, j_2) = C(j_2, j_1)$。利用此对称性来优化“有序对”（$N_{\\mathrm{ord}}$）和“对称折叠”（$N_{\\mathrm{fold}}$）存储方案的计数计算。\n\n总计数由以下公式给出：\n- $N_{\\mathrm{fold}} = \\sum_{j_1 \\le j_2} C(j_1, j_2) = \\sum_{j_1",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _count_for_j1j2_pair(two_j1, two_j2):\n    \"\"\"\n    Counts the number of valid Clebsch-Gordan sextuples for a fixed (j1, j2) pair.\n    The enumeration follows the rules specified in the problem statement, with an\n    analytical optimization for the innermost loop.\n    \"\"\"\n    count = 0\n    # Loop over 2J from |2j1 - 2j2| to 2j1 + 2j2 in steps of 2.\n    for two_J in range(abs(two_j1 - two_j2), two_j1 + two_j2 + 1, 2):\n        # Loop over 2M from -2J to 2J in steps of 2.\n        for two_M in range(-two_J, two_J + 1, 2):\n            # Analytically determine the number of valid m1 values.\n            # Constraint from m1: -2j1 = 2m1 = 2j1\n            # Constraint from m2: -2j2 = 2M - 2m1 = 2j2\n            # Which is: 2M - 2j2 = 2m1 = 2M + 2j2\n            lower_bound_m1 = max(-two_j1, two_M - two_j2)\n            upper_bound_m1 = min(two_j1, two_M + two_j2)\n\n            # If the range is invalid, there are no solutions.\n            if lower_bound_m1 > upper_bound_m1:\n                continue\n            \n            # The start of the valid range for 2m1 must have the same parity as 2j1.\n            start_m1 = lower_bound_m1\n            if (start_m1 - two_j1) % 2 != 0:\n                start_m1 += 1\n            \n            # If the adjusted start is out of bounds, no solutions.\n            if start_m1 > upper_bound_m1:\n                continue\n\n            # Count the number of valid 2m1 values (step size 2)\n            num_valid_m1 = (upper_bound_m1 - start_m1) // 2 + 1\n            count += num_valid_m1\n    return count\n\ndef _calculate_storages(j_set_frac):\n    \"\"\"\n    Calculates the coefficient counts and memory storage for a given j-set.\n    This function leverages the symmetry C(j1, j2) = C(j2, j1) to optimize\n    the calculation of ordered and folded counts.\n    \"\"\"\n    two_j_list = sorted([int(2 * j) for j in j_set_frac])\n    \n    n_diag = 0\n    for two_j in two_j_list:\n        n_diag += _count_for_j1j2_pair(two_j, two_j)\n        \n    n_off_diag_fold = 0\n    num_j = len(two_j_list)\n    for i in range(num_j):\n        for j in range(i + 1, num_j):\n            two_j1 = two_j_list[i]\n            two_j2 = two_j_list[j]\n            n_off_diag_fold += _count_for_j1j2_pair(two_j1, two_j2)\n\n    # N_fold = sum over j1 = j2\n    n_fold = n_diag + n_off_diag_fold\n    # N_ord = sum over all (j1, j2), which is sum(diag) + 2 * sum(off-diag)\n    n_ord = n_diag + 2 * n_off_diag_fold\n\n    b_ord = n_ord * 8\n    b_fold = n_fold * 8\n\n    return [n_ord, b_ord, n_fold, b_fold]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # T1: S1 = {1/2}\n        [0.5],\n        # T2: S2 = {1/2, 3/2, 5/2} (sd-shell)\n        [0.5, 1.5, 2.5],\n        # T3: S3 = {1/2, 3/2, 5/2, 7/2} (pf-shell)\n        [0.5, 1.5, 2.5, 3.5],\n        # T4: S4 = {9/2} (g_9/2 orbital)\n        [4.5]\n    ]\n\n    results = []\n    for j_set in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        result = _calculate_storages(j_set)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # str(list) produces space after comma, which we remove.\n    print(str(results).replace(' ', ''))\n\nsolve()\n```"
        },
        {
            "introduction": "在高性能科学计算中，最优算法往往取决于计算任务与硬件架构之间的复杂互动。最后的这个练习将让你扮演一名计算物理学家的角色，任务是优化一个大规模的核壳模型程序()。你需要分析“预计算并存储”与“即时计算”这两种策略的利弊，并结合对内存访问模式、缓存行为的理解，做出关键的性能优化决策。这种战略层面的思考对于在现代并行计算环境中实现卓越性能至关重要。",
            "id": "3541900",
            "problem": "在大规模核壳模型计算中，构建多体哈密顿量矩阵元和跃迁算符通常需要重复计算克莱布施-戈登（CG）系数。这些系数将两个角动量 $j_1$ 和 $j_2$ 耦合为合成角动量 $J$，其磁量子数分别为 $m_1$、$m_2$ 和 $M=m_1+m_2$。克莱布施-戈登系数由乘积基 $\\lvert j_1 m_1 \\rangle \\otimes \\lvert j_2 m_2 \\rangle$ 与耦合基 $\\lvert J M \\rangle$ 之间的幺正基变换定义，遵循正交性以及选择定则，如三角形条件 $\\lvert j_1-j_2 \\rvert \\le J \\le j_1+j_2$ 和投影约束 $m_1+m_2=M$。在计算核物理中，许多代码要么（i）预计算并存储所需的CG值，然后执行内存查找；要么（ii）通过稳定的递推关系或与 Wigner $3j$ 符号的关系进行动态计算，并利用对称性（例如，相位关系、投影的宇称）来减少冗余工作。\n\n考虑一个在一个拥有 $N_{\\mathrm{core}}=64$ 个相同核心的节点上执行 Lanczos 迭代的壳模型代码。该处理器的每个核心拥有 $S_{L1}=64\\,\\mathrm{KB}$ 的 L1 缓存和 $S_{L2}=1\\,\\mathrm{MB}$ 的 L2 缓存，以及一个共享的末级缓存 $S_{L3}=128\\,\\mathrm{MB}$。假设以下经过经验验证的架构级参数：L1 命中延迟 $t_{L1}\\approx 1\\,\\mathrm{ns}$（每 $64\\,\\mathrm{B}$ 缓存行），L2 命中延迟 $t_{L2}\\approx 4\\,\\mathrm{ns}$，L3 命中延迟 $t_{L3}\\approx 12\\,\\mathrm{ns}$；主内存峰值带宽 $B_{\\mathrm{peak}}=200\\,\\mathrm{GB/s}$，单个 $64\\,\\mathrm{B}$ 缓存行的随机访问延迟为 $t_{\\mathrm{DRAM}}\\approx 80\\,\\mathrm{ns}$。每个 CG 系数存储为一个 $8\\,\\mathrm{B}$ 的双精度浮点数。在计算密集型核心程序上，每核心的双精度持续性能为 $\\rho\\approx 50\\,\\mathrm{GFLOP/s}$，并且现代编译器会对稳定的动态 CG 例程进行矢量化，使得单次 CG 计算平均耗费 $F\\approx 300$ 次浮点运算。\n\n在形成矩阵向量乘积的内层核心程序中，观察到两种工作负载模式：\n\n- 模式 I（局部耦合）：对于一个给定的内层核心程序，每个线程主要重用一小组 $(j_1,j_2,J)$ 三元组及其允许的 $(m_1,m_2)$ 组合，每个线程的工作集 $S_{\\mathrm{WS}}\\lesssim 512\\,\\mathrm{KB}$，并且在迭代之间具有高时间局部性。在所有线程中，被重复访问的聚合的不同 CG 值能够容纳在共享的 $S_{L3}$ 内，并通常能容纳在每个核心的 $S_{L2}$ 内。\n\n- 模式 II（随机耦合）：每个线程接触各种各样的 $(j_1,j_2,J)$ 和 $(m_1,m_2)$ 组合，局部性很弱，因此 CG 值的聚合工作集超过了 $S_{L3}$，并且每个线程的数据流呈现出近乎随机的访问。由于内存级并行性有限和预取效率低下，这些随机加载的有效内存带宽降低至 $B_{\\mathrm{eff}}\\approx 50\\,\\mathrm{GB/s}$。\n\n在一个代表性的 Lanczos 步骤中，所有线程共使用了 $N_{\\mathrm{CG}}=5\\times 10^{9}$ 次 CG 系数。在预计算并查找的策略中，单次查找通过一次缓存行加载将 $8\\,\\mathrm{B}$ 的值读入寄存器；在动态计算策略中，每个 CG 系数都以 $F$ 次浮点运算的成本重新计算，忽略可忽略不计的分支开销。你可以假设，在模式 I 中，查找主要命中 $S_{L2}$ 或 $S_{L3}$，并且带宽维持在接近 $B_{\\mathrm{peak}}$ 的水平；而在模式 II 中，查找会遭遇以 $B_{\\mathrm{eff}}$ 为特征的随机访问行为；无论在哪种模式下，动态计算都能维持接近峰值的浮点吞吐量。\n\n仅使用上述基本定义和性能事实，推导出预计算并查找策略和动态计算策略在每种模式下的量级时间估计，然后选择一个由这些估计以及缓存行为与并行化相互作用所最佳支持的陈述。\n\n选项：\nA. 预计算 CG 系数在两种模式下都普遍更优，因为它们的值是固定的；查找总是比算术运算快，并且并行化有利于共享的只读表，其带宽限制可以忽略不计。\nB. 在模式 II 中，当工作集超过末级缓存且内存带宽/延迟占主导地位时，动态计算的性能可以超过预计算表；而在模式 I 中，当重用使工作集保持在缓存中时，预计算并查找更优；此外，计算密集型的动态计算方法在多核心的强随机访问模式下具有更好的伸缩性。\nC. 并行化内在地偏好预计算表；访问共享只读表的线程将主要实现 L1 命中，而动态递推计算需要在核心之间进行同步，这会降低伸缩性，从而使得预计算在两种模式下都更优。\nD. 应用三角形和投影选择定则会极大地减小表的大小，以至于对于实际的壳模型空间，所有需要的 CG 值都能容纳在每核心的 $S_{L2}$ 内，使得预计算并查找无论局部性如何都更优；动态计算在实践中没有任何优势。",
            "solution": "在进行求解之前，对问题陈述的有效性进行严格评估。\n\n### 步骤 1：提取给定条件\n从问题陈述中逐字提取以下参数和条件：\n- **系统架构：**\n    - 核心数：$N_{\\mathrm{core}} = 64$\n    - 每核心 L1 缓存：$S_{L1} = 64\\,\\mathrm{KB}$\n    - 每核心 L2 缓存：$S_{L2} = 1\\,\\mathrm{MB}$\n    - 共享末级缓存：$S_{L3} = 128\\,\\mathrm{MB}$\n- **性能参数：**\n    - L1 命中延迟：$t_{L1} \\approx 1\\,\\mathrm{ns}$ 每 $64\\,\\mathrm{B}$ 缓存行\n    - L2 命中延迟：$t_{L2} \\approx 4\\,\\mathrm{ns}$ 每 $64\\,\\mathrm{B}$ 缓存行\n    - L3 命中延迟：$t_{L3} \\approx 12\\,\\mathrm{ns}$ 每 $64\\,\\mathrm{B}$ 缓存行\n    - DRAM 随机访问延迟：$t_{\\mathrm{DRAM}} \\approx 80\\,\\mathrm{ns}$ 对于单个 $64\\,\\mathrm{B}$ 行\n    - 主内存峰值带宽：$B_{\\mathrm{peak}} = 200\\,\\mathrm{GB/s}$\n    - 每核心持续双精度性能：$\\rho \\approx 50\\,\\mathrm{GFLOP/s}$\n- **工作负载参数：**\n    - 克莱布施-戈登（CG）系数大小：$8\\,\\mathrm{B}$\n    - 动态 CG 计算成本：$F \\approx 300$ 次浮点运算 (FLOPs)\n    - CG 系数总使用次数：$N_{\\mathrm{CG}} = 5 \\times 10^9$\n- **工作负载模式：**\n    - **模式 I（局部耦合）：** 每线程工作集 $S_{\\mathrm{WS}} \\lesssim 512\\,\\mathrm{KB}$。高时间局部性。聚合的不同 CG 值可容纳于 $S_{L3}$ 内，通常可容纳于每核心的 $S_{L2}$ 内。\n    - **模式 II（随机耦合）：** CG 值的聚合工作集超过 $S_{L3}$。弱局部性，每线程近乎随机访问。随机加载的有效内存带宽降低至 $B_{\\mathrm{eff}} \\approx 50\\,\\mathrm{GB/s}$。\n- **策略假设：**\n    - **预计算并查找：** 一次查找通过缓存行加载将 $8\\,\\mathrm{B}$ 的值读入寄存器。\n    - **动态计算：** 每个 CG 系数都重新计算，无论在哪种模式下都能维持接近峰值的浮点吞吐量。\n\n### 步骤 2：使用提取的给定条件进行验证\n基于科学合理性、适定性和客观性标准对问题陈述进行评估。\n\n- **科学依据：** 该问题牢固地植根于计算核物理和高性能计算领域。所描述的情景——对于像克莱布施-戈登系数这样频繁使用的值，在重新计算和内存查找之间进行权衡——是科学软件优化中的一个典型问题。硬件参数（$S_{L1}$、$S_{L2}$、$S_{L3}$、延迟、带宽、FLOPS）对于现代 HPC 计算节点是切合实际的。物理背景（壳模型、Lanczos、角动量耦合）是准确的。该问题没有科学缺陷。\n- **适定性：** 该问题提供了足够的定量数据，以便对两种策略在两种模式下进行量级估计。问题要求得出一个由这些估计支持的结论，这是一个明确定义的任务。问题的设定是自洽且内部一致的（例如，内存层次结构的延迟和容量排序正确）。\n- **客观性：** 问题以精确的技术语言陈述。参数以客观数值给出，模式由定量指标（工作集大小、访问模式）定义。没有主观或模糊的语言。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。它科学合理、适定、客观，并为进行严格的定量分析提供了充分的基础。现在开始求解过程。\n\n### 时间估计的推导\n\n分析需要估计在一个拥有 $N_{\\mathrm{core}} = 64$ 个核心的系统上，执行 $N_{\\mathrm{CG}} = 5 \\times 10^9$ 次 CG 系数操作的总墙上时钟时间，分别针对两种策略和两种模式。我们假设负载完美均衡，因此工作被均匀分配。\n\n**1. 动态计算策略**\n\n如所述，此策略是计算密集型的。其性能取决于处理器的浮点计算能力。\n- 每次 CG 计算的成本：$F = 300$ FLOPs\n- 所需总浮点运算次数：$N_{\\mathrm{total\\_FLOPs}} = N_{\\mathrm{CG}} \\times F = (5 \\times 10^9) \\times 300 = 1.5 \\times 10^{12}$ FLOPs。\n- 每核心持续性能：$\\rho = 50\\,\\mathrm{GFLOP/s} = 50 \\times 10^9\\,\\mathrm{FLOP/s}$。\n- 所有核心的总持续性能：$\\rho_{\\mathrm{total}} = N_{\\mathrm{core}} \\times \\rho = 64 \\times 50 \\times 10^9\\,\\mathrm{FLOP/s} = 3200 \\times 10^9\\,\\mathrm{FLOP/s} = 3.2\\,\\mathrm{TFLOP/s}$。\n- 动态计算的估计时间：\n$$ T_{\\mathrm{compute}} = \\frac{N_{\\mathrm{total\\_FLOPs}}}{\\rho_{\\mathrm{total}}} = \\frac{1.5 \\times 10^{12}\\,\\mathrm{FLOPs}}{3.2 \\times 10^{12}\\,\\mathrm{FLOP/s}} = 0.46875\\,\\mathrm{s} $$\n问题陈述指出此性能“无论在哪种模式下”都能维持。\n因此，$T_{\\mathrm{compute, I}} \\approx T_{\\mathrm{compute, II}} \\approx 0.47\\,\\mathrm{s}$。\n\n**2. 预计算并查找策略**\n\n此策略是内存密集型的。其性能取决于从内存层次结构加载 CG 值的时间。\n- 每个 CG 值的大小：$8\\,\\mathrm{B}$。\n- 运行期间传输到寄存器的总数据量：$D_{\\mathrm{total}} = N_{\\mathrm{CG}} \\times 8\\,\\mathrm{B} = (5 \\times 10^9) \\times 8\\,\\mathrm{B} = 40 \\times 10^9\\,\\mathrm{B} = 40\\,\\mathrm{GB}$。\n所花费的时间取决于有效带宽，而有效带宽由每种模式中描述的访问模式和数据局部性决定。\n\n- **模式 I（局部化，缓存驻留）：**\n问题陈述指出，每线程工作集（$S_{\\mathrm{WS}} \\lesssim 512\\,\\mathrm{KB}$）可以容纳在每核心的 L2 缓存（$S_{L2} = 1\\,\\mathrm{MB}$）内，并且查找的“带宽维持在接近 $B_{\\mathrm{peak}}$ 的水平”。这意味着内存子系统得益于高缓存命中率，能够以接近系统峰值内存带宽的速率满足核心的数据需求。\n- 峰值带宽：$B_{\\mathrm{peak}} = 200\\,\\mathrm{GB/s}$。\n- 模式 I 中查找的估计时间：\n$$ T_{\\mathrm{lookup, I}} = \\frac{D_{\\mathrm{total}}}{B_{\\mathrm{peak}}} = \\frac{40\\,\\mathrm{GB}}{200\\,\\mathrm{GB/s}} = 0.2\\,\\mathrm{s} $$\n\n- **模式 II（随机化，内存驻留）：**\n聚合工作集超过了共享的 $S_{L3}$ 缓存，且访问是随机的。这将导致各级缓存频繁未命中，大多数请求最终由主内存（DRAM）服务。问题为此场景给出了一个特定的有效带宽，该带宽考虑了高延迟和有限的内存级并行性。\n- 有效带宽：$B_{\\mathrm{eff}} = 50\\,\\mathrm{GB/s}$。\n- 模式 II 中查找的估计时间：\n$$ T_{\\mathrm{lookup, II}} = \\frac{D_{\\mathrm{total}}}{B_{\\mathrm{eff}}} = \\frac{40\\,\\mathrm{GB}}{50\\,\\mathrm{GB/s}} = 0.8\\,\\mathrm{s} $$\n\n**时间估计总结：**\n- 模式 I：$T_{\\mathrm{lookup, I}} \\approx 0.20\\,\\mathrm{s}$ vs. $T_{\\mathrm{compute, I}} \\approx 0.47\\,\\mathrm{s}$。**查找**策略更优。\n- 模式 II：$T_{\\mathrm{lookup, II}} \\approx 0.80\\,\\mathrm{s}$ vs. $T_{\\mathrm{compute, II}} \\approx 0.47\\,\\mathrm{s}$。**动态计算**策略更优。\n\n### 逐项分析选项\n\n**A. 预计算 CG 系数在两种模式下都普遍更优，因为它们的值是固定的；查找总是比算术运算快，并且并行化有利于共享的只读表，其带宽限制可以忽略不计。**\n这个陈述在事实上是错误的。我们的估计表明，在模式 II 中，动态计算（$T \\approx 0.47\\,\\mathrm{s}$）明显快于查找（$T \\approx 0.80\\,\\mathrm{s}$）。“查找总是比算术运算快”这一前提是错误的；一次耗费约 300 FLOPs 的计算在单个核心上需要 $F/\\rho = 300 / (50 \\times 10^9) = 6\\,\\mathrm{ns}$ 的量级，而一次随机 DRAM 访问的成本为 $t_{\\mathrm{DRAM}} \\approx 80\\,\\mathrm{ns}$。“可忽略的带宽限制”的说法也是错误的，因为模式 II 中的性能明确地受限于内存带宽。\n**结论：不正确。**\n\n**B. 在模式 II 中，当工作集超过末级缓存且内存带宽/延迟占主导地位时，动态计算的性能可以超过预计算表；而在模式 I 中，当重用使工作集保持在缓存中时，预计算并查找更优；此外，计算密集型的动态计算方法在多核心的强随机访问模式下具有更好的伸缩性。**\n这个陈述与推导出的估计完全一致。\n- “在模式 II 中……动态计算的性能可以超过预计算表”：正确（$0.47\\,\\mathrm{s}$ vs. $0.80\\,\\mathrm{s}$）。给出的原因，即内存带宽/延迟占主导地位，是正确的物理解释。\n- “在模式 I 中……预计算并查找更优”：正确（$0.20\\,\\mathrm{s}$ vs. $0.47\\,\\mathrm{s}$）。给出的原因，即由于重用而导致的缓存驻留，是正确的。\n- “计算密集型的动态计算方法伸缩性更好……”：这也是正确的。动态计算方法是一个易于并行的问题，每个核心独立工作，因此性能随核心数量线性扩展。而模式 II 中的查找方法受到共享内存带宽资源（$B_{\\mathrm{eff}}$）的瓶颈限制，该资源不随核心数量扩展并且会饱和，导致伸缩性差。\n**结论：正确。**\n\n**C. 并行化内在地偏好预计算表；访问共享只读表的线程将主要实现 L1 命中，而动态递推计算需要在核心之间进行同步，这会降低伸缩性，从而使得预计算在两种模式下都更优。**\n这个陈述包含多个基本错误。\n- “线程……将主要实现 L1 命中”：不正确。模式 I 中的每线程工作集（$S_{\\mathrm{WS}} \\approx 512\\,\\mathrm{KB}$）大于 L1 缓存（$S_{L1} = 64\\,\\mathrm{KB}$），因此会频繁发生未命中，命中主要发生在 L2。在模式 II 中，大多数访问在所有缓存层级都未命中。\n- “动态递推计算需要在核心之间进行同步”：不正确。CG 系数的计算是一个自包含的数学函数，仅依赖于其输入参数（$j_1, j_2, J, m_1, m_2$）。不同 CG 计算之间没有数据依赖或必需的通信，因此核心可以独立计算它们，无需任何同步。\n- “使得预计算在两种模式下都更优”：这与我们发现动态计算在模式 II 中更优的结论相矛盾。\n**结论：不正确。**\n\n**D. 应用三角形和投影选择定则会极大地减小表的大小，以至于对于实际的壳模型空间，所有需要的 CG 值都能容纳在每核心的 $S_{L2}$ 内，使得预计算并查找无论局部性如何都更优；动态计算在实践中没有任何优势。**\n这个陈述试图使问题的假设无效。问题明确定义了模式 II 是一种观察到的情况，其中“CG 值的聚合工作集超过 $S_{L3}$”。选项 D 将此模式视为不切实际而予以否定。然而，在解决给定问题的背景下，必须接受其前提。大规模核壳模型计算确实可能涉及非常大的模型空间，以至于所需的 CG 系数集超过了缓存容量。通过与问题的一个既定前提相矛盾，该选项未能正确回答所提出的问题。我们基于问题前提的分析表明，查找方法并非无论局部性如何都更优。\n**结论：不正确。**",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}