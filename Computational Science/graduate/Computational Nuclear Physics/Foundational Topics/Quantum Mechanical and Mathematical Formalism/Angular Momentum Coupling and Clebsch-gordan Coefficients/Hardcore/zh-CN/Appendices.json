{
    "hands_on_practices": [
        {
            "introduction": "理论的基石是计算。本练习将抽象的角动量耦合理论与一个具体的物理量——高特系数（Gaunt coefficient）——联系起来，它是在计算核相互作用矩阵元时频繁出现的球面谐函数积分。通过这个练习，您将亲手实践如何利用克莱布希-戈登系数的代数性质，来直接并精确地计算这些看似复杂的积分，从而深刻理解对称性原理在简化物理计算中的强大威力。",
            "id": "3541865",
            "problem": "在计算核物理中，两体算符和平均场通常用球张量基表示，这将许多角积分简化为球谐函数乘积的积分。根据Condon–Shortley相角约定，复球谐函数的Gaunt系数定义为\n$$\nG(\\ell_{1} m_{1};\\, \\ell_{2} m_{2};\\, \\ell_{3} m_{3}) \\equiv \\int_{0}^{2\\pi}\\!\\!\\int_{0}^{\\pi} Y_{\\ell_{1} m_{1}}(\\theta,\\phi)\\,Y_{\\ell_{2} m_{2}}(\\theta,\\phi)\\,Y_{\\ell_{3} m_{3}}(\\theta,\\phi)\\,\\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi,\n$$\n其正交归一化约定为\n$$\n\\int Y_{\\ell m}^{*}(\\Omega)\\,Y_{\\ell' m'}(\\Omega)\\,\\mathrm{d}\\Omega \\;=\\; \\delta_{\\ell \\ell'}\\,\\delta_{m m'}.\n$$\n从球谐函数作为旋转下不可约球张量分量的定义以及Clebsch–Gordan系数（CGC）的标准性质出发，计算特定的Gaunt系数\n$$\nG(1\\,1;\\,1\\,{-}1;\\,2\\,0).\n$$\n作为推导的一部分，明确证明本例中关于$\\ell$的三角选择定则和$m$求和选择定则。将最终答案表示为精确的封闭形式表达式。不要四舍五入。无需单位。",
            "solution": "本题要求使用球谐函数作为不可约球张量的性质和Clebsch–Gordan系数的代数来计算一个特定的Gaunt系数，$G(1\\,1;\\,1\\,{-}1;\\,2\\,0)$。\n\nGaunt系数定义为三个复球谐函数的乘积在立体角$\\Omega$上的积分：\n$$\nG(\\ell_{1} m_{1};\\, \\ell_{2} m_{2};\\, \\ell_{3} m_{3}) \\equiv \\int Y_{\\ell_{1} m_{1}}(\\Omega)\\,Y_{\\ell_{2} m_{2}}(\\Omega)\\,Y_{\\ell_{3} m_{3}}(\\Omega)\\,\\mathrm{d}\\Omega\n$$\n这个积分代表一个标量，因为它是函数乘积在整个空间上的积分，而这些函数在旋转下会以特定的方式变换。为了使积分非零，被积函数本身必须像标量一样变换，即它必须在旋转下保持不变。这种旋转不变性对量子数$\\ell_i$和$m_i$施加了几个选择定则。\n\n首先，我们按要求证明选择定则：\n1.  **$m$求和选择定则**：考虑坐标系绕$z$轴旋转一个角度$\\alpha$。在这样的旋转下，一个球谐函数$Y_{\\ell m}(\\theta, \\phi)$变换为$Y_{\\ell m} \\rightarrow \\exp(im\\alpha) Y_{\\ell m}$。因此，三个球谐函数的乘积变换为：\n    $$\n    Y_{\\ell_{1} m_{1}} Y_{\\ell_{2} m_{2}} Y_{\\ell_{3} m_{3}} \\rightarrow \\exp(i(m_1+m_2+m_3)\\alpha) Y_{\\ell_{1} m_{1}} Y_{\\ell_{2} m_{2}} Y_{\\ell_{3} m_{3}}\n    $$\n    由于积分是标量，它必须与坐标系的方向无关。因此，被积函数在这种旋转下必须是不变的，这要求对于任意角度$\\alpha$，相位因子都为1。这仅在$m_1 + m_2 + m_3 = 0$时成立。对于$G(1\\,1;\\,1\\,{-}1;\\,2\\,0)$的特定情况，我们有$m_1=1$, $m_2=-1$, 和$m_3=0$。它们的和是$1 + (-1) + 0 = 0$，所以这个选择定则被满足。\n\n2.  **三角选择定则**：根据角动量理论，两个阶为$\\ell_1$和$\\ell_2$的不可约球张量（由$Y_{\\ell_1 m_1}$和$Y_{\\ell_2 m_2}$表示）的乘积可以分解为一系列阶为$L$的不可约球张量的和，其中$L$受矢量耦合规则$|\\ell_1 - \\ell_2| \\le L \\le \\ell_1 + \\ell_2$的约束。Gaunt积分可以看作是张量$Y_{\\ell_3 m_3}$与这个分解后的乘积的标量积。由于正交性，只有当阶$\\ell_3$包含在由$\\ell_1$和$\\ell_2$耦合产生的可能阶$L$之内时，积分才非零。这直接导致了三角选择定则：$|\\ell_1 - \\ell_2| \\le \\ell_3 \\le \\ell_1 + \\ell_2$。对于给定的问题，$\\ell_1=1$, $\\ell_2=1$, 并且$\\ell_3=2$。条件是$|1-1| \\le 2 \\le 1+1$，简化为$0 \\le 2 \\le 2$。此条件被满足。\n\n第三个重要的选择定则与宇称有关。球谐函数$Y_{\\ell m}$的宇称为$(-1)^\\ell$。只有当被积函数具有偶宇称时，积分才非零，即$(-1)^{\\ell_1} (-1)^{\\ell_2} (-1)^{\\ell_3} = 1$。这要求和$\\ell_1+\\ell_2+\\ell_3$是一个偶数。在我们的例子中，$1+1+2=4$，是偶数。\n\n为了计算Gaunt系数，我们使用一个标准公式，该公式将三个球谐函数的积分与Clebsch-Gordan系数（CGCs）的乘积联系起来。这个公式是通过展开两个球谐函数的乘积然后使用正交归一化关系推导出来的。一个关键步骤是将Gaunt积分与包含复共轭的标准形式联系起来。使用Condon-Shortley相角约定，$Y_{\\ell m}^* = (-1)^m Y_{\\ell, -m}$，我们可以写出$Y_{\\ell_3 m_3} = (-1)^{m_3}(Y_{\\ell_3, -m_3})^*$。\nGaunt系数变为：\n$$\nG(\\ell_{1} m_{1}; \\ell_{2} m_{2}; \\ell_{3} m_{3}) = (-1)^{m_3} \\int Y_{\\ell_{1} m_{1}}(\\Omega)\\,Y_{\\ell_{2} m_{2}}(\\Omega)\\, (Y_{\\ell_{3} -m_{3}}(\\Omega))^* \\,\\mathrm{d}\\Omega\n$$\n右侧的积分是众所周知的，其形式为：\n$$\n\\int Y_{\\ell_{1} m_{1}} Y_{\\ell_{2} m_{2}} Y_{L M}^* \\,\\mathrm{d}\\Omega = \\sqrt{\\frac{(2\\ell_1+1)(2\\ell_2+1)}{4\\pi(2L+1)}} \\langle \\ell_1, 0; \\ell_2, 0 | L, 0 \\rangle \\langle \\ell_1, m_1; \\ell_2, m_2 | L, M \\rangle\n$$\n令$L=\\ell_3$和$M=-m_3$，得到Gaunt系数的最终表达式：\n$$\nG(\\ell_{1} m_{1}; \\ell_{2} m_{2}; \\ell_{3} m_{3}) = (-1)^{m_3} \\sqrt{\\frac{(2\\ell_1+1)(2\\ell_2+1)}{4\\pi(2\\ell_3+1)}} \\langle \\ell_1, 0; \\ell_2, 0 | \\ell_3, 0 \\rangle \\langle \\ell_1, m_1; \\ell_2, m_2 | \\ell_3, -m_3 \\rangle\n$$\n现在我们将此公式应用于特定情况$G(1\\,1;\\,1\\,{-}1;\\,2\\,0)$。参数为$\\ell_1=1$, $m_1=1$；$\\ell_2=1$, $m_2=-1$；以及$\\ell_3=2$, $m_3=0$。\n代入这些值：\n$$\nG(1,1; 1,{-}1; 2,0) = (-1)^0 \\sqrt{\\frac{(2(1)+1)(2(1)+1)}{4\\pi(2(2)+1)}} \\langle 1,0; 1,0 | 2,0 \\rangle \\langle 1,1; 1,{-}1 | 2,0 \\rangle\n$$\n$$\nG(1,1; 1,{-}1; 2,0) = \\sqrt{\\frac{3 \\cdot 3}{4\\pi \\cdot 5}} \\langle 1,0; 1,0 | 2,0 \\rangle \\langle 1,1; 1,{-}1 | 2,0 \\rangle = \\frac{3}{2\\sqrt{5\\pi}} \\langle 1,0; 1,0 | 2,0 \\rangle \\langle 1,1; 1,{-}1 | 2,0 \\rangle\n$$\n所需的Clebsch-Gordan系数是用于将两个角动量$j_1=1$和$j_2=1$耦合形成总角动量$J=2$的情况。这些是标准系数。态$|J=2, M=0\\rangle$由乘积态$|j_1, m_1\\rangle|j_2, m_2\\rangle$构造如下：\n$$\n|2,0\\rangle = \\frac{1}{\\sqrt{6}} |1,1\\rangle|1,{-}1\\rangle + \\frac{2}{\\sqrt{6}} |1,0\\rangle|1,0\\rangle + \\frac{1}{\\sqrt{6}} |1,{-}1\\rangle|1,1\\rangle\n$$\n从这个展开式中，我们可以读出系数：\n$$\n\\langle 1,1; 1,{-}1 | 2,0 \\rangle = \\frac{1}{\\sqrt{6}}\n$$\n$$\n\\langle 1,0; 1,0 | 2,0 \\rangle = \\frac{2}{\\sqrt{6}}\n$$\n将这些值代入我们关于Gaunt系数的表达式中：\n$$\nG(1,1; 1,{-}1; 2,0) = \\frac{3}{2\\sqrt{5\\pi}} \\left(\\frac{2}{\\sqrt{6}}\\right) \\left(\\frac{1}{\\sqrt{6}}\\right)\n$$\n$$\nG(1,1; 1,{-}1; 2,0) = \\frac{3}{2\\sqrt{5\\pi}} \\left(\\frac{2}{6}\\right) = \\frac{3}{2\\sqrt{5\\pi}} \\left(\\frac{1}{3}\\right)\n$$\n$$\nG(1,1; 1,{-}1; 2,0) = \\frac{1}{2\\sqrt{5\\pi}}\n$$\n这就是指定Gaunt系数的精确、封闭形式的表达式。",
            "answer": "$$\\boxed{\\frac{1}{2\\sqrt{5\\pi}}}$$"
        },
        {
            "introduction": "从单个计算到大规模模拟，我们面临的下一个挑战是数据管理。一个实际的核壳模型计算可能需要数百万甚至数十亿个克莱布希-戈登系数。本练习要求您设计一个紧凑的索引方案，用于高效地存储和检索这些系数。这不仅仅是一个编程任务，更是一次深入理解角动量耦合选择规则如何直接转化为计算效率和内存优化的实践，这是计算物理学家必备的核心技能之一。",
            "id": "3541884",
            "problem": "要求您形式化并实现一种紧凑、连续的索引方案，用于在计算核物理中存储克莱布施-戈登系数。这些系数由两个角动量相加的六元量子数组 $\\left(j_1, j_2, J, m_1, m_2, M\\right)$ 索引，其中 $j_1$ 和 $j_2$ 是单粒子总角动量，$m_1$ 和 $m_2$ 是它们的投影，$J$ 是耦合后的总角动量，$M$ 是耦合后的投影。您的方案必须严格执行角动量耦合的选择定则，并且您必须估计在几个典型的壳模型空间中存储所有这些系数所需的内存占用。\n\n使用的基本和核心定义：\n- 在量子力学中，两个角动量的相加通过使用克莱布施-戈登系数 $\\langle j_1, m_1; j_2, m_2 | J, M \\rangle$ 从非耦合的张量积基 $|j_1, m_1\\rangle \\otimes |j_2, m_2\\rangle$ 构建耦合基 $|J, M\\rangle$，其定义为\n$$\n|J, M\\rangle = \\sum_{m_1, m_2} |j_1, m_1\\rangle \\otimes |j_2, m_2\\rangle \\, \\langle j_1, m_1; j_2, m_2 | J, M \\rangle.\n$$\n- 经过充分检验的选择定则如下：\n  1. 三角条件：$\\left| j_1 - j_2 \\right| \\le J \\le j_1 + j_2$。\n  2. 投影守恒：$M = m_1 + m_2$。\n  3. 边界条件：$-j_i \\le m_i \\le j_i$（对于 $i \\in \\{1,2\\}$）以及 $-J \\le M \\le J$。\n  4. 半整数一致性：$j_1$、$j_2$、$J$、$m_1$、$m_2$、$M$ 要么全部是整数，要么全部是半整数，使得 $j_1 + j_2 + J$ 为整数，并且 $m_1 + m_2 = M$ 成立，所有磁量子数均以1为单位步长变化。\n\n任务：\n1. 将所有半整数量子数表示为双倍整数，以获得一个纯整数域。也就是说，将 $2j_1$、$2j_2$、$2J$、$2m_1$、$2m_2$、$2M$ 存储为整数。在这种表示下，有效的枚举使用步长 $2$ 来保持半整数格点结构。\n2. 定义一个对所有允许的六元组 $\\left(2j_1, 2j_2, 2J, 2m_1, 2m_2, 2M\\right)$ 的规范字典序枚举，该枚举通过其构造来强制执行选择定则：\n   - 将允许的单粒子 $j$ 值的输入集合按升序排序，并转换为双倍整数。\n   - 按升序字典序枚举有序对 $\\left(2j_1, 2j_2\\right)$。对于对称折叠的变体，限制为 $\\left(2j_1 \\le 2j_2\\right)$。\n   - 对每一对，将 $2J$ 从 $\\left|2j_1 - 2j_2\\right|$ 到 $\\left(2j_1 + 2j_2\\right)$ 以步长 $2$ 进行枚举。\n   - 对每个 $2J$，将 $2M$ 从 $-2J$ 到 $2J$ 以步长 $2$ 进行枚举。\n   - 对每个 $2M$，将 $2m_1$ 从 $-2j_1$ 到 $2j_1$ 以步长 $2$ 进行枚举，设置 $2m_2 = 2M - 2m_1$，并且当 $-2j_2 \\le 2m_2 \\le 2j_2$ 时，包含该六元组。\n   - 一个六元组的线性索引是它在此枚举中从 $0$ 开始的排名。\n3. 对于下面测试套件中的每个壳模型空间，计算存储的系数总数以及将每个克莱布施-戈登系数存储为 $64$ 位浮点数（即每个系数 $8$ 字节）时的内存占用。报告“有序对”存储（所有 $\\left(2j_1,2j_2\\right)$，包括 $2j_1 > 2j_2$）和“对称折叠”存储（仅 $\\left(2j_1 \\le 2j_2\\right)$）两种情况。\n4. 您的程序必须实现上述枚举和索引方案，并且必须通过在双倍整数空间中显式执行选择定则来计算数量。它不得要求任何用户输入。\n\n测试套件：\n- 测试 $\\mathcal{T}_1$：$j$ 集合 $S_1 = \\{ \\tfrac{1}{2} \\}$。\n- 测试 $\\mathcal{T}_2$：$j$ 集合 $S_2 = \\{ \\tfrac{1}{2}, \\tfrac{3}{2}, \\tfrac{5}{2} \\}$（一个 $sd$ 壳模型空间）。\n- 测试 $\\mathcal{T}_3$：$j$ 集合 $S_3 = \\{ \\tfrac{1}{2}, \\tfrac{3}{2}, \\tfrac{5}{2}, \\tfrac{7}{2} \\}$（一个 $pf$ 壳模型空间）。\n- 测试 $\\mathcal{T}_4$：$j$ 集合 $S_4 = \\{ \\tfrac{9}{2} \\}$（一个单轨道 $g_{9/2}$ 空间）。\n\n对于每个测试 $\\mathcal{T}_k$，计算：\n- $N_{\\mathrm{ord}}$：有序对枚举下存储的六元组数量，\n- $B_{\\mathrm{ord}}$：有序对存储的总字节数，等于 $N_{\\mathrm{ord}} \\times 8$，\n- $N_{\\mathrm{fold}}$：在 $2j_1 \\le 2j_2$ 的对称折叠枚举下存储的六元组数量，\n- $B_{\\mathrm{fold}}$：折叠存储的总字节数，等于 $N_{\\mathrm{fold}} \\times 8$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个类 JSON 列表，每个测试一个条目，顺序为 $\\left[\\mathcal{T}_1,\\mathcal{T}_2,\\mathcal{T}_3,\\mathcal{T}_4\\right]$。\n- 每个条目本身必须是使用整数值的列表 $\\left[N_{\\mathrm{ord}}, B_{\\mathrm{ord}}, N_{\\mathrm{fold}}, B_{\\mathrm{fold}}\\right]$。\n- 示例示意图（非实际值）：$\\left[\\left[n_1,b_1,n'_1,b'_1\\right],\\left[n_2,b_2,n'_2,b'_2\\right],\\left[n_3,b_3,n'_3,b'_3\\right],\\left[n_4,b_4,n'_4,b'_4\\right]\\right]$。\n\n不涉及角度，因此无需指定角度单位。所有内存必须以字节为单位报告。程序必须是自包含的，且不得读取输入。",
            "solution": "问题陈述经评估有效。它在科学上基于量子角动量理论的原理，问题设定良好，具有明确的算法目标，并使用客观、正式的语言。所提供的数据和约束是完整且一致的。\n\n任务是为几个指定的单粒子角动量 $j$ 的集合，实现一个计数方案，用于计算非零克莱布施-戈登系数 $\\langle j_1, m_1; j_2, m_2 | J, M \\rangle$ 的数量。这个计数决定了存储这些系数所需的内存。解决方案涉及开发一种算法，该算法根据角动量耦合的基本选择定则，系统地枚举六个量子数 $(j_1, j_2, J, m_1, m_2, M)$ 的所有有效组合。\n\n**1. 整数表示**\n\n一个关键要求是使用纯整数表示来处理整数和半整数量子数。这通过将所有量子数加倍来实现。一个量子数 $j$ 变为 $2j$，$m$ 变为 $2m$，依此类推。在这种表示中，所有量子数都是整数。量子数以1为步长变化的物理约束（例如，$m, m+1, \\ldots$）转化为双倍整数以2为步长变化（例如，$2m, 2m+2, \\ldots$）。这保留了量子力学状态空间的结构，同时避免了潜在的浮点精度问题。对于给定的角动量 $j$，其双倍投影 $2m$ 的范围是从 $-2j$ 到 $2j$，步长为 $2$。\n\n**2. 枚举和计数策略**\n\n问题指定了对双倍整数六元组 $(2j_1, 2j_2, 2J, 2m_1, 2m_2, 2M)$ 的字典序枚举。有效六元组的总数即为所需的计数值。直接的暴力实现将涉及与此枚举顺序对应的一组嵌套循环。然而，这里采用了一种计算效率更高的策略。\n\n计算按单粒子角动量对 $(j_1, j_2)$ 分解。对于给定的一对，其系数数量（我们称之为 $C(j_1, j_2)$）与其他对无关。克莱布施-戈登系数的选择定则对于交换两个耦合粒子是对称的，这意味着 $C(j_1, j_2) = C(j_2, j_1)$。利用此对称性来优化“有序对”($N_{\\mathrm{ord}}$)和“对称折叠”($N_{\\mathrm{fold}}$)存储方案的计数计算。\n\n总计数由以下公式给出：\n- $N_{\\mathrm{fold}} = \\sum_{j_1 \\le j_2} C(j_1, j_2)$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _count_for_j1j2_pair(two_j1, two_j2):\n    \"\"\"\n    Counts the number of valid Clebsch-Gordan sextuples for a fixed (j1, j2) pair.\n    The enumeration follows the rules specified in the problem statement, with an\n    analytical optimization for the innermost loop.\n    \"\"\"\n    count = 0\n    # Loop over 2J from |2j1 - 2j2| to 2j1 + 2j2 in steps of 2.\n    for two_J in range(abs(two_j1 - two_j2), two_j1 + two_j2 + 1, 2):\n        # Loop over 2M from -2J to 2J in steps of 2.\n        for two_M in range(-two_J, two_J + 1, 2):\n            # Analytically determine the number of valid m1 values.\n            # Constraint from m1: -2j1 = 2m1 = 2j1\n            # Constraint from m2: -2j2 = 2M - 2m1 = 2j2\n            # Which is: 2M - 2j2 = 2m1 = 2M + 2j2\n            lower_bound_m1 = max(-two_j1, two_M - two_j2)\n            upper_bound_m1 = min(two_j1, two_M + two_j2)\n\n            # If the range is invalid, there are no solutions.\n            if lower_bound_m1 > upper_bound_m1:\n                continue\n            \n            # The start of the valid range for 2m1 must have the same parity as 2j1.\n            start_m1 = lower_bound_m1\n            if (start_m1 - two_j1) % 2 != 0:\n                start_m1 += 1\n            \n            # If the adjusted start is out of bounds, no solutions.\n            if start_m1 > upper_bound_m1:\n                continue\n\n            # Count the number of valid 2m1 values (step size 2)\n            num_valid_m1 = (upper_bound_m1 - start_m1) // 2 + 1\n            count += num_valid_m1\n    return count\n\ndef _calculate_storages(j_set_frac):\n    \"\"\"\n    Calculates the coefficient counts and memory storage for a given j-set.\n    This function leverages the symmetry C(j1, j2) = C(j2, j1) to optimize\n    the calculation of ordered and folded counts.\n    \"\"\"\n    two_j_list = sorted([int(2 * j) for j in j_set_frac])\n    \n    n_diag = 0\n    for two_j in two_j_list:\n        n_diag += _count_for_j1j2_pair(two_j, two_j)\n        \n    n_off_diag_fold = 0\n    num_j = len(two_j_list)\n    for i in range(num_j):\n        for j in range(i + 1, num_j):\n            two_j1 = two_j_list[i]\n            two_j2 = two_j_list[j]\n            n_off_diag_fold += _count_for_j1j2_pair(two_j1, two_j2)\n\n    # N_fold = sum over j1 = j2\n    n_fold = n_diag + n_off_diag_fold\n    # N_ord = sum over all (j1, j2), which is sum(diag) + 2 * sum(off-diag)\n    n_ord = n_diag + 2 * n_off_diag_fold\n\n    b_ord = n_ord * 8\n    b_fold = n_fold * 8\n\n    return [n_ord, b_ord, n_fold, b_fold]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # T1: S1 = {1/2}\n        [0.5],\n        # T2: S2 = {1/2, 3/2, 5/2} (sd-shell)\n        [0.5, 1.5, 2.5],\n        # T3: S3 = {1/2, 3/2, 5/2, 7/2} (pf-shell)\n        [0.5, 1.5, 2.5, 3.5],\n        # T4: S4 = {9/2} (g_9/2 orbital)\n        [4.5]\n    ]\n\n    results = []\n    for j_set in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        result = _calculate_storages(j_set)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # str(list) produces space after comma, which we remove.\n    print(str(results).replace(' ', ''))\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了单个耦合步骤后，我们将进入多体问题的核心：如何构建由多个核子组成的复杂系统的总角动量本征态。本练习通过动态规划算法，模拟了逐个耦合多个单粒子角动量的过程。您将构建一个耦合树，追踪所有可能的中间和最终总角动量及其简并度，从而直观地感受到核多体问题中组合复杂性的来源，并学会使用有效的算法策略来驾驭这种复杂性。",
            "id": "3541906",
            "problem": "请考虑量子力学中$N$个单粒子角动量的逐次耦合，这在计算核物理中用于构建多体总角动量多重态。这个问题的基本原理如下：总角动量算符$\\hat{\\mathbf{J}}$由各组成角动量的矢量相加产生，而相应的态空间耦合由克莱布希-高登系数（Clebsch-Gordan (CG) coefficients）决定。当耦合两个角动量$j$和$k$时，合成角动量的大小$J$的允许值遵循三角形定则和宇称约束：$J$的取值范围是从$|j - k|$到$j + k$，步长为整数或半整数。\n\n您的任务是设计一个动态规划算法，构建一个用于连续CG相加的树，该树将$N$个具有给定单粒子角动量$\\{j_1, j_2, \\dots, j_N\\}$的核子耦合到所有可能的最终总角动量$J$。该动态规划树应通过每次依次添加一个角动量来构建。在每一步中，对于每个当前可达的中间总角动量$J_{\\text{parent}}$，当它与下一个单粒子$j$耦合时，根据三角形定则和宇称约束生成所有子中间总角动量$J_{\\text{child}}$。\n\n为确保一个通用且精确的计算表示，避免浮点数模糊性，所有角动量都用加倍单位表示，即使用整数$2j$和$2J$。因此，在每个相加步骤中，允许的$2J_{\\text{child}}$值位于一个步长为$2$的等差网格上，范围从$|2J_{\\text{parent}} - 2j|$到$2J_{\\text{parent}} + 2j$（包含两端）。动态规划的状态应跟踪每个中间$2J$值，以及通向它的不同耦合路径的数量（即该状态在树中的多重性）。定义以下动态规划过程的复杂度指标：\n- 最大分支宽度，定义为在所有步骤中，从任何单个父状态$2J_{\\text{parent}}$生成的不同子状态$2J_{\\text{child}}$的最大数量。如果$N = 1$，则此量定义为$0$。\n- 处理的总边数，定义为在所有步骤和所有父状态上，来自该父状态的子状态数量之和，并按父状态的多重性加权。\n- 不同的最终$2J$值的数量（最终可达$2J$集合的大小）。\n- 到达最终态的总耦合路径数，定义为所有最终$2J$的多重性之和。\n- 树中可达到的最大最终$2J$值。\n\n构建一个程序，对于每个指定的测试用例，计算并返回一个列表，其中包含与上述指标完全对应的五个整数，顺序如下：\n$[$distinct\\_final\\_J\\_count, total\\_paths, max\\_branching\\_width, total\\_edges, max\\_final\\_2J$]$。\n\n使用以下测试套件（每个测试用例是一个表示$[2j_1, 2j_2, \\dots, 2j_N]$的整数列表）：\n- 测试用例 1：$[1, 1, 1, 1]$。\n- 测试用例 2：$[1, 3, 3, 2, 4, 1]$。\n- 测试用例 3：$[5]$。\n- 测试用例 4：$[2, 2, 2]$。\n- 测试用例 5：$[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]$。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，这些结果聚合在一个用方括号括起来的逗号分隔列表中，不含空格。外部列表的每个元素必须是为相应测试用例描述的五元组列表。例如，输出格式必须类似于$[[a_1,a_2,a_3,a_4,a_5],[b_1,b_2,b_3,b_4,b_5],\\dots]$。\n\n此计算不涉及物理单位。不使用角度。所有输出必须是加倍角动量单位$2J$的整数。\n\n设计覆盖范围包括：\n- 一个混合了多个半整数和整数单粒子值的一般情况。\n- $N = 1$的边界情况，以验证退化树的定义。\n- 测试宇称模式以及小宽度与大宽度分支行为的情况。",
            "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于量子角动量耦合原理，定义明确，目标清晰，数据充分，并且没有任何问题指南中列出的无效缺陷。任务是实现一个特定的动态规划算法，以计算与$N$个角动量逐次耦合相关的五个不同指标。\n\n其核心原理是量子力学中角动量的矢量相加。当耦合两个角动量量子数分别为$j_1$和$j_2$的角动量时，得到的总角动量量子数$J$的取值范围为$|j_1 - j_2| \\leq J \\leq j_1 + j_2$，其值以整数步长分隔。为避免处理半整数动量时的浮点数运算，问题指定使用加倍的整数表示，即$2j$和$2J$。在这种表示法中，一个总角动量为$2J_{\\text{parent}}$的父状态与一个动量为$2j$的单粒子耦合的规则是：\n$$\n2J_{\\text{child}} \\in \\{ |2J_{\\text{parent}} - 2j|, |2J_{\\text{parent}} - 2j| + 2, \\dots, 2J_{\\text{parent}} + 2j \\}\n$$\n这构成了我们迭代算法的基础。\n\n问题要求采用动态规划方法来跟踪所有可能的总角动量及其多重性。一个状态$J$的多重性表示可以导致该总角动量的不同耦合路径的数量。在任何步骤$k$（耦合完前$k$个粒子后），我们动态规划算法的状态可以高效地用字典或哈希图表示，其中键是可达到的加倍总角动量$2J$，值是它们对应的多重性。\n\n设输入为一个加倍单粒子角动量的列表，$\\{2j_1, 2j_2, \\dots, 2j_N\\}$。\n\n**算法步骤：**\n\n1.  **初始化：** 过程从第一个粒子$2j_1$开始。系统的初始状态是平凡的：唯一可能的总角动量是$2j_1$本身，多重性为$1$。因此，对于$k=1$，状态图为 `current_states` $= \\{2j_1: 1\\}$。指标`max_branching_width`和`total_edges`初始化为$0$。\n\n2.  **迭代耦合：** 对于每个后续的粒子$2j_k$（其中$k$从$2$到$N$），我们更新状态图。我们遍历上一步中`current_states`里存在的每个父状态$(2J_{\\text{parent}}, \\text{multiplicity})$。\n    a. 对于每个父状态，我们应用耦合规则，找到与当前粒子$2j_k$耦合时所有可能的子状态$2J_{\\text{child}}$。\n    b. 我们创建一个新的空图 `next_states`，用于存储当前步骤$k$的结果。\n    c. 对于`current_states`中的每个$2J_{\\text{parent}}$及其`multiplicity`：\n        i.  确定子状态的范围：$2J_{\\text{child}}$从$|2J_{\\text{parent}} - 2j_k|$到$2J_{\\text{parent}} + 2j_k$，步长为$2$。\n        ii. 计算该父状态的不同子状态数量，这有助于确定分支宽度，计算公式为 $B = (|2J_{\\text{parent}} + 2j_k| - |2J_{\\text{parent}} - 2j_k|)/2 + 1$。我们更新`max_branching_width` $= \\max(\\text{max\\_branching\\_width}, B)$。\n        iii. 所有通向此父状态的路径所产生的边数为`multiplicity` $\\times B$。此值被加到`total_edges`中。\n        iv. 对于每个生成的$2J_{\\text{child}}$，其在`next_states`中的多重性增加其父状态$2J_{\\text{parent}}$的`multiplicity`。如果$2J_{\\text{child}}$尚未在`next_states`中，则以该多重性添加它。\n    d. 遍历完`current_states`中的所有父状态后，`next_states`图成为下一次迭代的新`current_states`。\n\n3.  **最终化：** 在所有$N$个粒子都已耦合后，最终的`current_states`图包含所有可能的总角动量$2J$及其总路径多重性。然后计算所需的五个指标：\n    - **`distinct_final_J_count`**：不同最终$2J$值的数量，即最终状态图中的键的数量：`len(final_states)`。\n    - **`total_paths`**：到达所有最终态的总耦合路径数，即最终状态图中所有多重性（值）的总和：$\\sum \\text{multiplicity}_i$。\n    - **`max_branching_width`**：在迭代过程中记录的最大分支宽度。对于$N=1$的特殊情况，此值定义为$0$。\n    - **`total_edges`**：在所有耦合步骤中累积的处理的总边数。对于$N=1$，此值为$0$。\n    - **`max_final_2J`**：最大的最终$2J$值，即最终状态图中的最大键。\n\n该算法系统地构建了完整的耦合树，正确地跟踪了所有中间和最终状态的多重性，并允许直接计算指定的过程指标。使用字典作为状态图对于效率至关重要，因为它自然地处理了可达$J$值的稀疏和动态变化的集合。最终输出列表中的指标顺序将是`[distinct_final_J_count, total_paths, max_branching_width, total_edges, max_final_2J]`，如问题中所指定。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the angular momentum coupling problem.\n    \"\"\"\n    test_cases = [\n        [1, 1, 1, 1],\n        [1, 3, 3, 2, 4, 1],\n        [5],\n        [2, 2, 2],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    ]\n\n    results = []\n    for two_j_list in test_cases:\n        result = calculate_metrics(two_j_list)\n        results.append(result)\n\n    # Format the output string to be a list of lists with no spaces.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_metrics(two_j_list):\n    \"\"\"\n    Calculates the five specified metrics for coupling a list of angular momenta.\n\n    Args:\n        two_j_list: A list of integers representing doubled angular momenta [2j_1, 2j_2, ...].\n\n    Returns:\n        A list of five integers:\n        [distinct_final_J_count, total_paths, max_branching_width, total_edges, max_final_2J]\n    \"\"\"\n    n = len(two_j_list)\n    if n == 0:\n        return [0, 0, 0, 0, 0]\n\n    # Handle the N=1 case as specified.\n    if n == 1:\n        two_j_1 = two_j_list[0]\n        # distinct_final_J_count, total_paths, max_branching_width, total_edges, max_final_2J\n        return [1, 1, 0, 0, two_j_1]\n\n    # Initialize dynamic programming state and metrics\n    # The state is a dictionary {2J: multiplicity}\n    current_states = {two_j_list[0]: 1}\n    max_branching_width = 0\n    total_edges = 0\n\n    # Iterate through the rest of the particles\n    for k in range(1, n):\n        two_j_k = two_j_list[k]\n        next_states = {}\n        \n        # Couple the new particle with each state from the previous step\n        for two_j_parent, multiplicity in current_states.items():\n            # Calculate the range of children states 2J_child\n            two_j_child_min = np.abs(two_j_parent - two_j_k)\n            two_j_child_max = two_j_parent + two_j_k\n\n            # Calculate number of children for this parent (branching width)\n            num_children = (two_j_child_max - two_j_child_min) // 2 + 1\n            \n            # Update metrics\n            if num_children > max_branching_width:\n                max_branching_width = num_children\n            total_edges += multiplicity * num_children\n\n            # Generate children states and update their multiplicities\n            for two_j_child in range(two_j_child_min, two_j_child_max + 1, 2):\n                next_states[two_j_child] = next_states.get(two_j_child, 0) + multiplicity\n        \n        current_states = next_states\n\n    final_states = current_states\n    \n    # Calculate final metrics\n    distinct_final_J_count = len(final_states)\n    total_paths = sum(final_states.values())\n    max_final_2J = max(final_states.keys()) if final_states else 0\n\n    return [distinct_final_J_count, total_paths, max_branching_width, total_edges, max_final_2J]\n\nsolve()\n```"
        }
    ]
}