{
    "hands_on_practices": [
        {
            "introduction": "In computational physics, a robust and well-verified toolkit is essential before tackling complex simulations. This first exercise focuses on that crucial foundation by having you implement and benchmark the fundamental relationships of the non-interacting Fermi gas model. By deriving and verifying the conversions between natural units (where $\\hbar=c=k_B=1$) and the more practical MeV-fm system, you will build a solid, error-free framework for all subsequent calculations .",
            "id": "3599442",
            "problem": "Implement a program that benchmarks unit conversions between natural units and mixed megaelectronvolt–femtometer units for an ideal noninteracting Fermi gas model of nuclear matter and verifies dimensional consistency of computed outputs. Natural units are defined by setting the reduced Planck constant, the speed of light, and the Boltzmann constant to unity, that is, $\\hbar=c=k_B=1$. Mixed megaelectronvolt–femtometer units (MeV–fm) represent energies and temperatures in megaelectronvolts and lengths in femtometers. Your program must use the following physical constants as given: the reduced Planck constant times the speed of light $\\hbar c = 197.3269804\\,\\mathrm{MeV\\cdot fm}$, and the nucleon rest mass $m_N = 939.56542052\\,\\mathrm{MeV}$. Temperatures must be handled as energies via the Boltzmann constant because $k_B=1$ in natural units, so temperature $T$ is in $\\mathrm{MeV}$ in both systems.\n\nStart from fundamental principles of phase-space counting and classical mechanics:\n- The single-particle state count in momentum space follows from the phase-space cell size being $(2\\pi\\hbar)^3$ and the volume of a sphere in momentum space.\n- The Fermi momentum $k_F$ at zero temperature is defined by filling all single-particle states up to $k_F$.\n- The number density $n$ is the total number of particles per unit volume $V$.\n- In the nonrelativistic kinetic energy limit, the single-particle kinetic energy is $E = p^2/(2m_N)$, where $p$ is momentum.\n\nUsing these base facts, derive, implement, and use the relations needed to:\n1. Compute the number density $n$ from a given Fermi momentum $k_F$ and spin-isospin degeneracy $g$.\n2. Compute the Fermi momentum $k_F$ from a given number density $n$ and $g$.\n3. Compute the zero-temperature Fermi energy $E_F$ from $k_F$ and $m_N$.\n4. Compute $k_F$ from $E_F$ and $m_N$.\n5. Convert between unit systems for all of $n$, $k_F$, $E_F$, and $T$.\n\nYour conversions must be derived from the definitions of units and the constant $\\hbar c$:\n- In natural units, momentum, energy, and temperature all have the same dimensions, and length has dimensions of inverse energy. Therefore, $k_F$ is in $\\mathrm{MeV}$, $E_F$ is in $\\mathrm{MeV}$, $T$ is in $\\mathrm{MeV}$, and $n$ is in $\\mathrm{MeV}^3$.\n- In MeV–fm units, $k_F$ is in $\\mathrm{fm^{-1}}$, $E_F$ is in $\\mathrm{MeV}$, $T$ is in $\\mathrm{MeV}$, and $n$ is in $\\mathrm{fm^{-3}}$.\n- Use $\\hbar c$ to convert between lengths and energies: $1\\,\\mathrm{fm}^{-1}$ corresponds to $(\\hbar c)\\,\\mathrm{MeV}$, and $1\\,\\mathrm{fm}^{-3}$ corresponds to $(\\mathrm{MeV}/\\hbar c)^3$.\n\nDimensional consistency verification:\n- For each test case, you will be provided a unit system flag, a known primary quantity among $n$, $k_F$, or $E_F$, a degeneracy $g$, and a temperature $T$ in $\\mathrm{MeV}$.\n- Compute the full set $(n,k_F,E_F,T)$ in the native unit system of the test case using only the fundamental principles above.\n- Convert the set to the other unit system and then convert back to the native unit system. Define the relative discrepancy for two numbers $x$ and $y$ as\n$$\n\\delta(x,y) \\equiv \\frac{|x-y|}{\\max(1,|x|,|y|)}.\n$$\n- Check two conditions: (i) the Fermi gas relations linking $n$ and $k_F$ hold in the native unit system and (ii) the round-trip conversion discrepancies for each of $n$, $k_F$, $E_F$, and $T$ are all below a tolerance $\\epsilon = 10^{-12}$. A test case passes if and only if both conditions hold.\n\nUnits to use in all numeric outputs: number density $n$ in $\\mathrm{fm^{-3}}$ or $\\mathrm{MeV^3}$ consistent with the chosen system, Fermi momentum $k_F$ in $\\mathrm{fm^{-1}}$ or $\\mathrm{MeV}$ consistent with the chosen system, Fermi energy $E_F$ in $\\mathrm{MeV}$ in both systems, and temperature $T$ in $\\mathrm{MeV}$ in both systems.\n\nTest suite:\n- Case $1$: Unit system MeV–fm, known primary $n = 0.16\\,\\mathrm{fm^{-3}}$, degeneracy $g = 4$, temperature $T = 0\\,\\mathrm{MeV}$.\n- Case $2$: Unit system MeV–fm, known primary $k_F = 0.05\\,\\mathrm{fm^{-1}}$, degeneracy $g = 2$, temperature $T = 5\\,\\mathrm{MeV}$.\n- Case $3$: Unit system natural units, known primary $k_F = 262.444883932\\,\\mathrm{MeV}$, degeneracy $g = 4$, temperature $T = 15\\,\\mathrm{MeV}$. This value corresponds to $1.33\\,\\mathrm{fm^{-1}}$ multiplied by $\\hbar c$.\n- Case $4$: Unit system natural units, known primary $E_F = 37\\,\\mathrm{MeV}$, degeneracy $g = 4$, temperature $T = 1\\,\\mathrm{MeV}$.\n\nYour program must:\n- Hard-code the above physical constants and test suite.\n- For each test case, compute the pass or fail boolean as defined above.\n- Produce a single line of output containing the four boolean results as a comma-separated list enclosed in square brackets, for example, $[{\\tt True},{\\tt False},{\\tt True},{\\tt True}]$.\n\nThe final printed output must be exactly one line in the described format.",
            "solution": "The problem requires the implementation and verification of unit conversions for the non-interacting Fermi gas model of nuclear matter. The task involves deriving fundamental relations, handling two different unit systems (natural units and MeV-fm units), and performing a round-trip conversion benchmark for a set of test cases. The solution must be scientifically rigorous and algorithmically precise.\n\n### Part 1: Theoretical Framework of the Fermi Gas Model\n\nWe begin by deriving the essential equations from the principles stated in the problem. The model assumes a non-interacting gas of fermions (nucleons) at zero or non-zero temperature.\n\n**1.1. Number Density and Fermi Momentum**\n\nThe number of single-particle states within a phase-space volume element $d^3r d^3p$ is $d^3r d^3p / (2\\pi\\hbar)^3$. For a uniform gas in a spatial volume $V$, the number of states with momentum magnitude up to $p$ is obtained by integrating over the momentum-space sphere of radius $p$:\n$$ N_{states}(p) = \\frac{V}{(2\\pi\\hbar)^3} \\int_0^p 4\\pi p'^2 dp' = \\frac{V \\cdot 4\\pi p^3}{3(2\\pi\\hbar)^3} = \\frac{V p^3}{6\\pi^2\\hbar^3} $$\nNucleons are fermions with a spin-isospin degeneracy factor $g$. For symmetric nuclear matter (equal numbers of protons and neutrons, spin up and down), $g=4$. For pure neutron matter, $g=2$. At zero temperature ($T=0$), all states up to the Fermi momentum, $p_F$, are filled. The total number of particles $N$ is thus $g$ times the number of states up to $p_F$:\n$$ N = g \\cdot N_{states}(p_F) = \\frac{g V p_F^3}{6\\pi^2\\hbar^3} $$\nThe number density $n$ is defined as $n = N/V$. By substituting $p_F = \\hbar k_F$, where $k_F$ is the Fermi wave number (often called Fermi momentum in this context), we obtain the relation between number density and Fermi momentum:\n$$ n = \\frac{g (\\hbar k_F)^3}{6\\pi^2\\hbar^3} = \\frac{g k_F^3}{6\\pi^2} $$\nThis equation holds irrespective of the unit system, provided the units of $n$ and $k_F$ are consistent. Inverting this relation allows us to compute $k_F$ from a given $n$:\n$$ k_F = \\left( \\frac{6\\pi^2 n}{g} \\right)^{1/3} $$\n\n**1.2. Fermi Energy and Fermi Momentum**\n\nThe problem specifies the non-relativistic approximation for the kinetic energy of a nucleon with mass $m_N$ and momentum $p$: $E = p^2 / (2m_N)$. The Fermi energy, $E_F$, is the kinetic energy of a nucleon at the Fermi surface, i.e., with momentum $p_F = \\hbar k_F$.\n$$ E_F = \\frac{p_F^2}{2m_N} = \\frac{(\\hbar k_F)^2}{2m_N} $$\nThis relation allows for the calculation of $E_F$ from $k_F$. The inverse relation to find $k_F$ from $E_F$ is:\n$$ k_F = \\frac{\\sqrt{2m_N E_F}}{\\hbar} $$\nThe temperature $T$ is given in units of energy (MeV), consistent with the natural unit convention where the Boltzmann constant $k_B=1$.\n\n### Part 2: Unit Systems and Conversions\n\nCorrectly handling units is critical. The problem defines two systems and the conversion factor $\\hbar c = 197.3269804\\,\\mathrm{MeV\\cdot fm}$. Let's denote this constant as $HC$. The nucleon mass $m_N$ is given in units of MeV, representing $m_N c^2 = 939.56542052\\,\\mathrm{MeV}$.\n\n**2.1. MeV–fm Units**\nThis is a mixed system practical for nuclear physics calculations.\n-   Length: femtometers (fm)\n-   Energy / Temperature: megaelectronvolts (MeV)\n-   Number Density $n$: $\\mathrm{fm^{-3}}$\n-   Fermi Momentum $k_F$: $\\mathrm{fm^{-1}}$\n-   Fermi Energy $E_F$: $\\mathrm{MeV}$\n\nIn this system, $\\hbar$ is not unity. The formula for $E_F$ must explicitly include $\\hbar$. To maintain correct dimensions, we express $\\hbar$ in terms of $\\hbar c$: $\\hbar = \\hbar c / c$. The energy equation becomes $E_F = (\\hbar c)^2 k_F^2 / (2 m_N c^2)$. Using $m_N$ for the rest energy $m_N c^2$, the practical formula is:\n$$ E_F = \\frac{(HC)^2 k_F^2}{2 m_N} $$\nThe corresponding inverse relation is:\n$$ k_F = \\frac{\\sqrt{2m_N E_F}}{HC} $$\nThe relation $n = g k_F^3 / (6\\pi^2)$ remains valid as its components are dimensionally consistent in this system.\n\n**2.2. Natural Units**\nIn this system, $\\hbar=c=k_B=1$. All quantities (energy, mass, momentum, inverse length) are expressed in a single unit, which we take as MeV.\n-   Length: $\\mathrm{MeV^{-1}}$\n-   Energy / Temperature: $\\mathrm{MeV}$\n-   Number Density $n$: $\\mathrm{MeV^{3}}$\n-   Fermi Momentum $k_F$: $\\mathrm{MeV}$\n-   Fermi Energy $E_F$: $\\mathrm{MeV}$\n\nThe relations simplify due to $\\hbar=1$:\n$$ n = \\frac{g k_F^3}{6\\pi^2} $$\n$$ E_F = \\frac{k_F^2}{2m_N} $$\n$$ k_F = \\sqrt{2m_N E_F} $$\n\n**2.3. Conversion Formulas**\nThe constant $HC$ provides the bridge: $1 = \\frac{HC}{\\mathrm{MeV \\cdot fm}}$, which implies $1\\,\\mathrm{fm}^{-1} = HC\\,\\mathrm{MeV}$.\nLet quantities in MeV-fm units be indexed by $M$ and those in natural units by $N$.\n\n-   **Momentum ($k_F$)**:\n    $k_{F, M} \\,[\\mathrm{fm}^{-1}]$ becomes $k_{F, N} \\,[\\mathrm{MeV}]$. The conversion is $k_{F, N} = k_{F, M} \\cdot HC$.\n-   **Number Density ($n$)**:\n    $n_{M} \\,[\\mathrm{fm}^{-3}]$ becomes $n_{N} \\,[\\mathrm{MeV^3}]$. Since $1\\,\\mathrm{fm}^{-3} \\leftrightarrow (1/HC\\,\\mathrm{MeV}^{-1})^{-3} = (HC\\,\\mathrm{MeV})^3$, the conversion is $n_N = n_M / (HC)^3$. The original solution had a typo here. $1 fm = 1/(HC) MeV^-1$, so $1 fm^-3 = (HC)^3 MeV^3$. No, this is also confusing. Let's be precise. A length $L$ in fm is $L_{MeV^{-1}} = L_{fm} / HC$. So a volume $V_{fm^3}$ becomes $V_{MeV^{-3}} = V_{fm^3} / HC^3$. Density $n = N/V$. So $n_{MeV^3} = N / V_{MeV^{-3}} = N / (V_{fm^3}/HC^3) = n_{fm^{-3}} * HC^3$. Let's check the code: `mevfm_to_natural` `state['n'] * hc3`. `natural_to_mevfm` `'n': state['n'] / hc3`. This is correct. The original solution text had the formula wrong, but the code was right. Let's fix the text. Conversion is $n_{N} = n_M \\cdot (HC)^3$.\n-   **Energy ($E_F$) and Temperature ($T$)**:\n    These are in MeV in both systems, so no conversion is needed: $E_{F, N} = E_{F, M}$ and $T_N = T_M$.\n\n### Part 3: Algorithm for Verification\n\nFor each test case, we perform a series of calculations to determine a single boolean pass/fail result.\n\n**3.1. Calculation in Native Units**\nGiven one primary quantity ($n$, $k_F$, or $E_F$), we compute the other two to establish a complete set $(n, k_F, E_F, T)$ in the native unit system of the test case. The formulas from Part 2.1 or 2.2 are used depending on the system.\n\n**3.2. Verification of Physical Relations**\nThe problem requires checking that the Fermi gas relations hold for the computed set. This serves as a self-consistency check of our calculations. We verify two relations:\n1.  The relation between $n$ and $k_F$: We compute a check value $n_{check} = g k_F^3 / (6\\pi^2)$ and verify that the relative discrepancy $\\delta(n, n_{check})$ is less than a tolerance $\\epsilon = 10^{-12}$.\n2.  The relation between $E_F$ and $k_F$: We compute $E_{F, check}$ from $k_F$ using the appropriate formula for the unit system and verify that $\\delta(E_F, E_{F, check})  \\epsilon$.\nThe test case passes this stage only if both checks are satisfied. The discrepancy function is defined as:\n$$ \\delta(x,y) \\equiv \\frac{|x-y|}{\\max(1,|x|,|y|)} $$\n\n**3.3. Round-Trip Conversion and Discrepancy Check**\nThe set of quantities $(n, k_F, E_F, T)$ is converted from its native system to the other system, and then immediately converted back. This round trip should, in theory, recover the original values. Floating-point arithmetic may introduce minuscule errors. We check that these errors are negligible.\n1.  **Convert**: Apply the conversion formulas from Part 2.3 to transform the native set to the alternate unit system.\n2.  **Convert Back**: Apply the inverse conversion formulas to return to the native unit system.\n3.  **Check Discrepancies**: For each of the four quantities ($n, k_F, E_F, T$), calculate the relative discrepancy $\\delta$ between the original native value and the round-trip value.\nThe test case passes this stage only if all four discrepancies are below the tolerance $\\epsilon = 10^{-12}$.\n\n**3.4. Final Verdict**\nA test case receives a final verdict of `True` if and only if it passes both the physical relation verification (Step 3.2) and the round-trip conversion check (Step 3.3). Otherwise, the verdict is `False`. The program will execute this logic for all test cases and report the list of boolean results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants and tolerance as defined in the problem.\nHBAR_C_MEV_FM = 197.3269804  # MeV*fm\nNUCLEON_MASS_MEV = 939.56542052  # MeV\nTOLERANCE = 1e-12\n\ndef delta(x, y):\n    \"\"\"\n    Calculates the relative discrepancy between two numbers x and y.\n    The normalization is max(1, |x|, |y|) to handle values close to zero.\n    \"\"\"\n    return np.abs(x - y) / np.max([1.0, np.abs(x), np.abs(y)])\n\ndef compute_native_set(is_mev_fm, known_var, val, g):\n    \"\"\"\n    Computes the full set of (n, kF, EF) from a single known quantity\n    in the specified native unit system.\n    \"\"\"\n    n, kf, ef = 0.0, 0.0, 0.0\n    pi_squared = np.pi**2\n    \n    if is_mev_fm:  # MeV-fm unit system\n        if known_var == 'n':\n            n = val\n            kf = (6 * pi_squared * n / g)**(1/3)\n            ef = (HBAR_C_MEV_FM * kf)**2 / (2 * NUCLEON_MASS_MEV)\n        elif known_var == 'kF':\n            kf = val\n            n = g * kf**3 / (6 * pi_squared)\n            ef = (HBAR_C_MEV_FM * kf)**2 / (2 * NUCLEON_MASS_MEV)\n        elif known_var == 'eF':\n            ef = val\n            kf = np.sqrt(2 * NUCLEON_MASS_MEV * ef) / HBAR_C_MEV_FM\n            n = g * kf**3 / (6 * pi_squared)\n    else:  # Natural unit system\n        if known_var == 'n':\n            n = val\n            kf = (6 * pi_squared * n / g)**(1/3)\n            ef = kf**2 / (2 * NUCLEON_MASS_MEV)\n        elif known_var == 'kF':\n            kf = val\n            n = g * kf**3 / (6 * pi_squared)\n            ef = kf**2 / (2 * NUCLEON_MASS_MEV)\n        elif known_var == 'eF':\n            ef = val\n            kf = np.sqrt(2 * NUCLEON_MASS_MEV * ef)\n            n = g * kf**3 / (6 * pi_squared)\n            \n    return {'n': n, 'kf': kf, 'ef': ef}\n\ndef verify_relations(state, g, is_mev_fm):\n    \"\"\"\n    Verifies that the fundamental Fermi gas relations hold for the given state.\n    \"\"\"\n    n, kf, ef = state['n'], state['kf'], state['ef']\n    \n    # Check n -> kF relation\n    n_check = g * kf**3 / (6 * np.pi**2)\n    pass_n_kf = delta(n, n_check)  TOLERANCE\n\n    # Check eF -> kF relation, using the appropriate formula for the unit system\n    if is_mev_fm:\n        ef_check = (HBAR_C_MEV_FM * kf)**2 / (2 * NUCLEON_MASS_MEV)\n    else:\n        ef_check = kf**2 / (2 * NUCLEON_MASS_MEV)\n    pass_ef_kf = delta(ef, ef_check)  TOLERANCE\n\n    return pass_n_kf and pass_ef_kf\n    \ndef mevfm_to_natural(state):\n    \"\"\"Converts a state from MeV-fm units to natural units.\"\"\"\n    hc3 = HBAR_C_MEV_FM**3\n    return {\n        'n': state['n'] * hc3,\n        'kf': state['kf'] * HBAR_C_MEV_FM,\n        'ef': state['ef'],\n        't': state['t']\n    }\n\ndef natural_to_mevfm(state):\n    \"\"\"Converts a state from natural units to MeV-fm units.\"\"\"\n    hc3 = HBAR_C_MEV_FM**3\n    return {\n        'n': state['n'] / hc3,\n        'kf': state['kf'] / HBAR_C_MEV_FM,\n        'ef': state['ef'],\n        't': state['t']\n    }\n\ndef verify_roundtrip(native_set, round_trip_set):\n    \"\"\"\n    Checks the discrepancies between an original and a round-trip converted state.\n    \"\"\"\n    d_n = delta(native_set['n'], round_trip_set['n'])\n    d_kf = delta(native_set['kf'], round_trip_set['kf'])\n    d_ef = delta(native_set['ef'], round_trip_set['ef'])\n    d_t = delta(native_set['t'], round_trip_set['t'])\n    \n    return (d_n  TOLERANCE and\n            d_kf  TOLERANCE and\n            d_ef  TOLERANCE and\n            d_t  TOLERANCE)\n\ndef process_case(is_mev_fm, known_var, val, g, T):\n    \"\"\"\n    Runs a single test case through the full validation procedure.\n    \"\"\"\n    # 1. Compute the full set of physical quantities in the native unit system.\n    native_set = compute_native_set(is_mev_fm, known_var, val, g)\n    native_set['t'] = T\n\n    # 2. Verify that the Fermi gas relations hold for the computed set.\n    pass_relations = verify_relations(native_set, g, is_mev_fm)\n\n    # 3. Perform a round-trip conversion and verify negligible discrepancies.\n    if is_mev_fm:\n        converted_set = mevfm_to_natural(native_set)\n        round_trip_set = natural_to_mevfm(converted_set)\n    else:  # is_natural\n        converted_set = natural_to_mevfm(native_set)\n        round_trip_set = mevfm_to_natural(converted_set)\n\n    pass_roundtrip = verify_roundtrip(native_set, round_trip_set)\n    \n    return pass_relations and pass_roundtrip\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (is_mev_fm, known_var, value, degeneracy g, temperature T in MeV)\n        (True, 'n', 0.16, 4, 0.0),            # Case 1\n        (True, 'kF', 0.05, 2, 5.0),           # Case 2\n        (False, 'kF', 262.444883932, 4, 15.0), # Case 3\n        (False, 'eF', 37.0, 4, 1.0)            # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        is_mev_fm, known_var, val, g, T = case\n        result = process_case(is_mev_fm, known_var, val, g, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The boolean values are converted to string format 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "With a reliable computational framework in place, we can now apply the Fermi gas model to explore the thermal properties of nuclear matter. This practice guides you through the calculation of the heat capacity at constant volume, $C_V$, a fundamental quantity that reveals how a system stores thermal energy. You will confront the full numerical evaluation of Fermi-Dirac integrals and compare your results to the well-known linear-in-temperature Sommerfeld expansion, gaining deep insight into the behavior of a degenerate fermion system as it is heated .",
            "id": "3599424",
            "problem": "Consider a three-dimensional, non-relativistic, non-interacting nucleonic system within the Fermi gas model of nuclear matter. Let the single-particle energy be $\\varepsilon = p^{2}/(2m)$, and assume the system is in thermal equilibrium at temperature $T$, with chemical potential $\\mu(T)$ determined by fixed particle number density. The occupation probability of a single-particle state is given by the Fermi–Dirac distribution (FD), defined as $f(\\varepsilon;\\mu,T) = \\left(1 + \\exp\\left((\\varepsilon - \\mu)/(k_{B}T)\\right)\\right)^{-1}$, where $k_{B}$ is the Boltzmann constant. The density of states per unit volume for a non-relativistic particle in three dimensions scales as a constant times $\\varepsilon^{1/2}$; proportionality constants cancel in all ratios considered below. Introduce the Fermi temperature $T_{F}$ through $k_{B}T_{F} = \\varepsilon_{F}$, where $\\varepsilon_{F}$ is the zero-temperature Fermi energy for the given density. Define the degeneracy parameter $\\theta = T/T_{F}$ and the reduced chemical potential $\\eta = \\mu/(k_{B}T)$. Define the dimensionless integrals $I_{\\alpha}(\\eta) = \\int_{0}^{\\infty} \\frac{x^{\\alpha}}{1 + \\exp(x - \\eta)} \\, dx$ for exponents $\\alpha \\in \\{1/2, 3/2\\}$, where $x = \\varepsilon/(k_{B}T)$.\n\nYour tasks are:\n- Derive, starting from the FD distribution and the density of states, the fixed-density constraint in terms of $\\theta$ and $\\eta$ and the expression for the internal energy per particle $E/A$ at finite $T$ as a function of $I_{3/2}(\\eta)$ and $I_{1/2}(\\eta)$.\n- Using only these foundational relations, design a computational method to evaluate the heat capacity at constant volume per particle $C_{V}/A$ along the fixed-density path (constant $T_{F}$), expressed in units of $k_{B}$, namely as the dimensionless quantity $(C_{V}/A)/k_{B}$. You must compute $(C_{V}/A)/k_{B}$ numerically by differentiating $E/A$ with respect to $T$ while enforcing the fixed-density constraint to obtain $\\eta(T)$ for each $T$.\n- For comparison at low temperature, also compute the leading-order low-temperature estimate given by the well-known Sommerfeld expansion for $(C_{V}/A)/k_{B}$ as a function linear in $T/T_{F}$, and quantify the deviation at moderate degeneracy by reporting the normalized difference $(\\text{numerical} - \\text{Sommerfeld})/(\\text{Sommerfeld})$.\n\nPhysical and numerical units and outputs:\n- Express $(C_{V}/A)$ in units of $k_{B}$, i.e., report $(C_{V}/A)/k_{B}$ as a dimensionless number. No other physical units are required in the output.\n- For each test case, report four values: the input $\\theta = T/T_{F}$, the computed $(C_{V}/A)/k_{B}$, the low-temperature linear estimate from the Sommerfeld expansion evaluated at the same $\\theta$, and the normalized deviation $(\\text{numerical} - \\text{Sommerfeld})/(\\text{Sommerfeld})$.\n- Round all reported floats to six decimal places.\n\nTest suite:\n- Evaluate your program for the following degeneracy parameters $\\theta$: $0.05$, $0.20$, $0.50$, $1.00$, $2.00$, and $5.00$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, where each inner list is of the form $[\\theta, (C_{V}/A)/k_{B}, \\text{Sommerfeld}(\\theta), \\text{deviation}]$. For example, $[[\\theta_{1},c_{1},s_{1},d_{1}],[\\theta_{2},c_{2},s_{2},d_{2}],\\dots]$. No additional text should be printed.",
            "solution": "The problem requires us to derive the theoretical framework for calculating the heat capacity of a non-relativistic Fermi gas and then implement a numerical solution. The solution involves analytical derivation, numerical root-finding, numerical integration, and numerical differentiation.\n\n### 1. Analytical Derivations\n\nFirst, we establish the key relationships based on the provided definitions. Let the single-particle density of states per unit volume be $g(\\varepsilon) = C \\varepsilon^{1/2}$, where $C$ is a constant incorporating degeneracy and fundamental constants.\n\n**Fixed-Density Constraint:**\nThe particle number density $n = A/V$ is obtained by integrating the density of states multiplied by the Fermi-Dirac (FD) distribution over all energies:\n$$n = \\int_{0}^{\\infty} g(\\varepsilon) f(\\varepsilon; \\mu, T) d\\varepsilon = C \\int_{0}^{\\infty} \\frac{\\varepsilon^{1/2}}{1 + \\exp((\\varepsilon - \\mu)/(k_{B}T))} d\\varepsilon$$\nAt $T=0$, the FD distribution is a step function, and the integral is taken up to the Fermi energy $\\varepsilon_{F}$:\n$$n = C \\int_{0}^{\\varepsilon_{F}} \\varepsilon^{1/2} d\\varepsilon = C \\frac{2}{3} \\varepsilon_{F}^{3/2}$$\nSince density $n$ is fixed, $\\varepsilon_{F}$ (and thus $T_F = \\varepsilon_F/k_B$) is a constant property of the system.\n\nAt finite temperature $T > 0$, we switch to the dimensionless variable $x = \\varepsilon/(k_{B}T)$ and the reduced chemical potential $\\eta = \\mu/(k_{B}T)$. The density integral becomes:\n$$n = C (k_{B}T)^{3/2} \\int_{0}^{\\infty} \\frac{x^{1/2}}{1 + \\exp(x - \\eta)} dx = C (k_{B}T)^{3/2} I_{1/2}(\\eta)$$\nBy equating the expressions for the fixed density $n$, we find the constraint:\n$$C \\frac{2}{3} \\varepsilon_{F}^{3/2} = C (k_{B}T)^{3/2} I_{1/2}(\\eta) \\implies \\frac{2}{3} (k_B T_F)^{3/2} = (k_B T)^{3/2} I_{1/2}(\\eta)$$\nUsing the definition $\\theta = T/T_F$, this simplifies to the required constraint equation, which implicitly defines $\\eta$ as a function of $\\theta$:\n$$\\frac{2}{3} = \\theta^{3/2} I_{1/2}(\\eta)$$\n\n**Internal Energy per Particle:**\nThe internal energy density $E/V$ is calculated by including an extra factor of $\\varepsilon$ in the integral:\n$$ \\frac{E}{V} = \\int_{0}^{\\infty} \\varepsilon g(\\varepsilon) f(\\varepsilon; \\mu, T) d\\varepsilon = C (k_{B}T)^{5/2} I_{3/2}(\\eta) $$\nThe internal energy per particle, $E/A$, is the ratio of energy density to number density:\n$$ \\frac{E}{A} = \\frac{E/V}{n} = \\frac{C (k_{B}T)^{5/2} I_{3/2}(\\eta)}{C (k_{B}T)^{3/2} I_{1/2}(\\eta)} = k_{B}T \\frac{I_{3/2}(\\eta)}{I_{1/2}(\\eta)} $$\n\n### 2. Computational Method\n\n**Heat Capacity $(C_V/A)/k_B$:**\nThe heat capacity at constant volume per particle is $C_V/A = \\frac{\\partial (E/A)}{\\partial T}$. We need its dimensionless value, $(C_V/A)/k_B$.\n$$ \\frac{C_V/A}{k_B} = \\frac{1}{k_B} \\frac{\\partial}{\\partial T}\\left(k_B T \\frac{I_{3/2}(\\eta)}{I_{1/2}(\\eta)}\\right) = \\frac{\\partial}{\\partial T}\\left(T \\frac{I_{3/2}(\\eta)}{I_{1/2}(\\eta)}\\right) $$\nSince $T_F$ is constant, we can write $T = \\theta T_F$, and the derivative becomes $\\frac{\\partial}{\\partial (\\theta T_F)} \\left(\\theta T_F \\frac{I_{3/2}(\\eta(\\theta))}{I_{1/2}(\\eta(\\theta))}\\right) = \\frac{\\partial}{\\partial \\theta} \\left(\\theta \\frac{I_{3/2}(\\eta(\\theta))}{I_{1/2}(\\eta(\\theta))}\\right)$.\nThis derivative is computed numerically using a central difference formula:\n$$ \\frac{C_V/A}{k_B} \\approx \\frac{U(\\theta + h) - U(\\theta - h)}{2h} $$\nwhere $U(\\theta) = (E/A)/(k_B T_F) = \\theta \\frac{I_{3/2}(\\eta(\\theta))}{I_{1/2}(\\eta(\\theta))}$ and $h$ is a small step. For each value of $\\theta$ in the finite difference stencil, we must first solve the constraint equation for $\\eta$, which requires a numerical root-finder (e.g., Brent's method) and a numerical integrator (e.g., `scipy.integrate.quad`) for the Fermi-Dirac integrals $I_{1/2}$ and $I_{3/2}$.\n\n**Sommerfeld Low-Temperature Approximation:**\nFor low temperatures ($\\theta \\ll 1$), the heat capacity is given by the linear term of the Sommerfeld expansion:\n$$ \\frac{C_V}{A k_B} \\approx \\frac{\\pi^2}{2} \\frac{k_B T}{\\varepsilon_F} = \\frac{\\pi^2}{2} \\frac{T}{T_F} = \\frac{\\pi^2}{2} \\theta $$\n\n**Normalized Deviation:**\nThe relative difference between the full numerical result and the Sommerfeld approximation is:\n$$ \\text{deviation} = \\frac{(C_V/A)_{\\text{numerical}} - (C_V/A)_{\\text{Sommerfeld}}}{(C_V/A)_{\\text{Sommerfeld}}} $$\nThis quantifies the accuracy of the low-temperature expansion as temperature increases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate, optimize\n\n# A cache to store results of the expensive Fermi-Dirac integral calculations,\n# which are frequently called by the root-finding algorithm.\n_integral_cache = {}\n\ndef fermi_dirac_integral(alpha, eta):\n    \"\"\"\n    Computes the dimensionless Fermi-Dirac integral I_alpha(eta).\n    \n    I_alpha(eta) = integral from 0 to inf of x^alpha / (1 + exp(x - eta)) dx.\n    \"\"\"\n    # Use tuple (alpha, eta) as the dictionary key.\n    if (alpha, eta) in _integral_cache:\n        return _integral_cache[(alpha, eta)]\n    \n    # The integrand function.\n    integrand = lambda x: np.power(x, alpha) / (1.0 + np.exp(x - eta))\n    \n    # For alpha  0, the integrand has a singularity at x=0, which quad can handle\n    # if informed via the 'points' argument.\n    points_of_interest = [0] if alpha  0 else None\n    \n    # Numerically integrate using SciPy's quad function.\n    # The upper limit can be set to a large number like eta + 50 for efficiency,\n    # as the integrand decays exponentially for x > eta. Inf is also fine.\n    upper_bound = np.inf\n    result, _ = integrate.quad(integrand, 0, upper_bound, points=points_of_interest)\n    \n    _integral_cache[(alpha, eta)] = result\n    return result\n\ndef find_eta_for_theta(theta):\n    \"\"\"\n    Solves the fixed-density constraint equation to find the reduced chemical\n    potential 'eta' for a given degeneracy parameter 'theta'.\n    \n    The constraint is: I_{1/2}(eta) = (2/3) * theta^(-3/2).\n    \"\"\"\n    target_value = (2.0 / 3.0) * np.power(theta, -1.5)\n    \n    def root_function(eta):\n        \"\"\" The function whose root needs to be found: f(eta) = I_{1/2}(eta) - C = 0. \"\"\"\n        return fermi_dirac_integral(0.5, eta) - target_value\n        \n    # Use a robust root-finding algorithm (Brent's method) with a wide, safe bracket.\n    # For low theta, eta is large positive. For high theta, eta is negative.\n    # The bracket [-40, 400] is sufficiently large to contain the root for all test cases.\n    try:\n        sol = optimize.root_scalar(root_function, bracket=[-40, 400], method='brentq')\n        return sol.root\n    except ValueError:\n        # This may happen if the root is not in the bracket, which indicates a problem.\n        # For this well-behaved function, it is not expected.\n        print(f\"Error: Root not found for theta = {theta}\")\n        return np.nan\n\ndef get_energy_per_particle_div_kb(theta):\n    \"\"\"\n    Calculates the internal energy per particle in units of k_B, (E/A)/k_B.\n    \n    (E/A)/k_B = T * I_{3/2}(eta) / I_{1/2}(eta)\n    With T_F=1, this is theta * I_{3/2}(eta) / I_{1/2}(eta).\n    \"\"\"\n    if theta = 0:\n        return 0.0\n\n    eta = find_eta_for_theta(theta)\n    \n    # Get the integral values.\n    i_3_2 = fermi_dirac_integral(1.5, eta)\n    i_1_2 = fermi_dirac_integral(0.5, eta) # This could also be replaced by target_value from find_eta\n    \n    if i_1_2 == 0:\n        return 0.0 # Avoid division by zero\n        \n    return theta * i_3_2 / i_1_2\n\ndef calculate_numerical_cv(theta):\n    \"\"\"\n    Computes the dimensionless heat capacity (C_V/A)/k_B by numerically\n    differentiating the energy per particle with respect to temperature.\n    \"\"\"\n    # Use a central difference formula for the derivative, with a small relative step size.\n    h = 1e-6 * theta\n    \n    # Ensure h is not too small to cause floating point precision issues.\n    h = max(h, 1e-9)\n\n    energy_plus_h = get_energy_per_particle_div_kb(theta + h)\n    energy_minus_h = get_energy_per_particle_div_kb(theta - h)\n    \n    # Derivative is dU/dT. With T_F=1, T=theta. So dU/d(theta)\n    cv_numerical = (energy_plus_h - energy_minus_h) / (2.0 * h)\n    \n    return cv_numerical\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [0.05, 0.20, 0.50, 1.00, 2.00, 5.00]\n    \n    results = []\n    \n    for theta in test_cases:\n        # Clear the cache for each new theta value to avoid excessive memory usage\n        # in a more extensive calculation.\n        global _integral_cache\n        _integral_cache.clear()\n        \n        # 1. Compute the heat capacity numerically.\n        cv_numerical = calculate_numerical_cv(theta)\n        \n        # 2. Compute the low-temperature Sommerfeld approximation.\n        cv_sommerfeld = (np.pi**2 / 2.0) * theta\n        \n        # 3. Compute the normalized deviation.\n        if cv_sommerfeld != 0:\n            deviation = (cv_numerical - cv_sommerfeld) / cv_sommerfeld\n        else:\n            deviation = np.nan # Should not happen for theta > 0\n\n        # Assemble the results for this test case, rounding to six decimal places.\n        results.append([\n            round(theta, 6),\n            round(cv_numerical, 6),\n            round(cv_sommerfeld, 6),\n            round(deviation, 6)\n        ])\n\n    # Final print statement in the exact required format.\n    # The conversion to string handles list formatting automatically.\n    # Joining with ',' creates the comma-separated list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Our final practice moves beyond symmetric nuclear matter to address the crucial concept of isospin asymmetry, the imbalance between neutron and proton numbers. You will investigate how the kinetic energy of the system changes as a function of this asymmetry, $\\delta = (\\rho_n - \\rho_p)/\\rho$, and extract the kinetic symmetry energy, $S_{\\mathrm{kin}}$, which is the leading-order energy cost of this imbalance. This exercise not only deepens your understanding of nuclear composition but also introduces the powerful technique of determining physical parameters by fitting a theoretical model to numerically generated data .",
            "id": "3599449",
            "problem": "Consider a two-component, non-relativistic Fermi gas model of nuclear matter composed of neutrons and protons with equal bare nucleon mass. Let the total number density be denoted by $\\rho$ (in $\\mathrm{fm}^{-3}$), and define the isospin asymmetry $\\delta$ by $\\delta=(\\rho_n-\\rho_p)/\\rho$, where $\\rho_n$ and $\\rho_p$ are the neutron and proton number densities, respectively. Assume spin degeneracy $g=2$ for each component and ignore interactions (free gas). Work in units where energy is measured in megaelectronvolts ($\\mathrm{MeV}$) and length in femtometers ($\\mathrm{fm}$), using $\\hbar c = 197.3269804\\,\\mathrm{MeV}\\cdot\\mathrm{fm}$ and bare nucleon mass $m=939.0\\,\\mathrm{MeV}$. Let temperature $T$ be measured in $\\mathrm{MeV}$ so that $k_B T$ is absorbed in $T$.\n\nStarting from first principles, namely:\n- The Fermi-Dirac distribution function $f(E,\\mu,T)=\\left[1+\\exp\\left((E-\\mu)/T\\right)\\right]^{-1}$ for fermions at chemical potential $\\mu$ and temperature $T$ (with the zero-temperature limit given by the Heaviside step function at the Fermi energy),\n- The definitions of number density and kinetic energy density for a free gas in momentum space,\nderive expressions that allow computation of the total kinetic energy per particle $E/A(\\delta)$ for a given $\\rho$ and $T$. Express everything in terms of the wave number $k$ (in $\\mathrm{fm}^{-1}$), where the single-particle kinetic energy is $E(k)=\\hbar^2 k^2/(2m)$, and the measure is set by the standard counting of states:\n$$\n\\rho_i(\\mu_i,T)=\\frac{g}{2\\pi^2}\\int_0^{\\infty} k^2\\, f\\!\\left(E(k),\\mu_i,T\\right)\\, dk,\n$$\n$$\n\\varepsilon_i(\\mu_i,T)=\\frac{g}{2\\pi^2}\\int_0^{\\infty} k^2\\, E(k)\\, f\\!\\left(E(k),\\mu_i,T\\right)\\, dk,\n$$\nfor $i\\in\\{n,p\\}$, and the total kinetic energy per particle is $E/A(\\delta)=\\left[\\varepsilon_n+\\varepsilon_p\\right]/\\rho$. At zero temperature, use the zero-temperature limit of the distribution and the corresponding exact integrals.\n\nDefine the kinetic symmetry energy $S_{\\mathrm{kin}}(\\rho,T)$ as the coefficient of $\\delta^2$ in the expansion of $E/A(\\delta)$ around $\\delta=0$:\n$$\nE/A(\\delta) = E/A(0) + S_{\\mathrm{kin}}(\\rho,T)\\,\\delta^2 + \\mathcal{O}(\\delta^4).\n$$\nYou must determine $S_{\\mathrm{kin}}(\\rho,T)$ numerically by computing $E/A(\\delta)$ on a small, symmetric grid of $\\delta$ values around $0$ and performing a least-squares fit to the even polynomial basis $\\{1,\\delta^2\\}$ to extract the quadratic coefficient. At zero temperature, analytically derive the exact zero-temperature limit of $S_{\\mathrm{kin}}(\\rho,T)$ from the same first principles and verify numerically that your fitted value agrees with the analytic result.\n\nAlgorithmic instructions:\n- For a given total density $\\rho$ and asymmetry $\\delta$, assign $\\rho_n=\\rho(1+\\delta)/2$ and $\\rho_p=\\rho(1-\\delta)/2$.\n- For $T=0$, compute $E/A(\\delta)$ using the zero-temperature limit of the distribution and exact integrals over $k$ up to the Fermi wave number. For $T0$, for each component $i$, determine $\\mu_i$ by solving $\\rho_i(\\mu_i,T)=\\rho_i$ numerically (use a robust, monotonic root-bracketing method), then compute $\\varepsilon_i(\\mu_i,T)$.\n- Use a symmetric grid $\\delta\\in\\{-0.4,-0.2,0.0,0.2,0.4\\}$ to fit $E/A(\\delta)$ and extract $S_{\\mathrm{kin}}(\\rho,T)$ as the coefficient of $\\delta^2$ in the least-squares fit to $\\{1,\\delta^2\\}$.\n- All computed energies must be expressed in $\\mathrm{MeV}$. Report floats rounded to six decimal places.\n\nTest suite:\n- Case $1$: $\\rho=0.16\\,\\mathrm{fm}^{-3}$, $T=0\\,\\mathrm{MeV}$; return the fitted $S_{\\mathrm{kin}}(\\rho,T)$ and also a boolean stating whether it matches the analytically derived zero-temperature limit within an absolute tolerance of $10^{-3}\\,\\mathrm{MeV}$.\n- Case $2$: $\\rho=0.08\\,\\mathrm{fm}^{-3}$, $T=0\\,\\mathrm{MeV}$; return the fitted $S_{\\mathrm{kin}}(\\rho,T)$ and also a boolean stating whether it matches the analytically derived zero-temperature limit within an absolute tolerance of $10^{-3}\\,\\mathrm{MeV}$.\n- Case $3$: $\\rho=0.16\\,\\mathrm{fm}^{-3}$, $T=5\\,\\mathrm{MeV}$; return the fitted $S_{\\mathrm{kin}}(\\rho,T)$.\n- Case $4$: $\\rho=0.16\\,\\mathrm{fm}^{-3}$, $T=20\\,\\mathrm{MeV}$; return the fitted $S_{\\mathrm{kin}}(\\rho,T)$.\n- Case $5$: $\\rho=10^{-6}\\,\\mathrm{fm}^{-3}$, $T=5\\,\\mathrm{MeV}$; return the fitted $S_{\\mathrm{kin}}(\\rho,T)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order: the float for Case $1$, the boolean for Case $1$ verification, the float for Case $2$, the boolean for Case $2$ verification, the float for Case $3$, the float for Case $4$, and the float for Case $5$. For example: $[x_1,\\mathrm{True},x_2,\\mathrm{False},x_3,x_4,x_5]$, where each $x_i$ is a float rounded to six decimal places and expressed in $\\mathrm{MeV}$.",
            "solution": "The problem is scientifically grounded, well-posed, and contains all necessary information to derive a unique solution. We proceed by first outlining the theoretical framework of the non-relativistic, free Fermi gas model, then detailing the computational strategy for both zero and finite temperatures, and finally explaining the procedure for extracting the kinetic symmetry energy.\n\n**1. Theoretical Framework: The Free Fermi Gas Model**\n\nThe system is a two-component gas of non-interacting neutrons ($n$) and protons ($p$) of mass $m$. The state of the system is determined by the total nucleon number density $\\rho = \\rho_n + \\rho_p$ and the temperature $T$. The relative proportions of neutrons and protons are given by the isospin asymmetry $\\delta = (\\rho_n - \\rho_p)/\\rho$, which implies $\\rho_n = \\rho(1+\\delta)/2$ and $\\rho_p = \\rho(1-\\delta)/2$.\n\nThe single-particle kinetic energy for a nucleon with wave number $k$ is non-relativistic:\n$$E(k) = \\frac{\\hbar^2 k^2}{2m}$$\nwhere we use the constant $\\frac{\\hbar^2}{2m} = \\frac{(\\hbar c)^2}{2mc^2}$. Given $\\hbar c = 197.3269804\\,\\mathrm{MeV}\\cdot\\mathrm{fm}$ and $m \\equiv mc^2 = 939.0\\,\\mathrm{MeV}$, this constant is approximately $20.7337\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^2$.\n\nThe particles obey the Fermi-Dirac distribution, which gives the probability of a state with energy $E$ being occupied:\n$$f(E, \\mu, T) = \\frac{1}{1 + \\exp\\left(\\frac{E-\\mu}{T}\\right)}$$\nHere, $\\mu$ is the chemical potential of the particle species and $T$ is the temperature in units of $\\mathrm{MeV}$.\n\nThe number density $\\rho_i$ and kinetic energy density $\\varepsilon_i$ for each species $i \\in \\{n,p\\}$ are found by integrating over all momentum states, with a spin degeneracy factor of $g=2$:\n$$ \\rho_i(\\mu_i, T) = \\frac{g}{2\\pi^2} \\int_0^{\\infty} k^2 f(E(k), \\mu_i, T) dk $$\n$$ \\varepsilon_i(\\mu_i, T) = \\frac{g}{2\\pi^2} \\int_0^{\\infty} k^2 E(k) f(E(k), \\mu_i, T) dk $$\nThe total kinetic energy per particle, $E/A$, is the sum of the kinetic energy densities divided by the total number density:\n$$ E/A(\\delta) = \\frac{\\varepsilon_n + \\varepsilon_p}{\\rho} $$\n\n**2. Zero-Temperature Case ($T=0\\,\\mathrm{MeV}$)**\n\nAt zero temperature, the Fermi-Dirac distribution becomes a Heaviside step function, $f(E,\\mu,0) = \\Theta(\\mu - E)$, where the chemical potential $\\mu(T=0)$ is the Fermi energy $E_{F_i}$. The integrals are sharply cut off at the Fermi wave number $k_{F_i}$, where $E(k_{F_i}) = E_{F_i}$.\n\nThe number density integral becomes:\n$$ \\rho_i = \\frac{g}{2\\pi^2} \\int_0^{k_{F_i}} k^2 dk = \\frac{g}{6\\pi^2} k_{F_i}^3 $$\nWith $g=2$, we have $\\rho_i = k_{F_i}^3 / (3\\pi^2)$, which gives the Fermi wave number as $k_{F_i} = (3\\pi^2 \\rho_i)^{1/3}$.\n\nThe kinetic energy density integral becomes:\n$$ \\varepsilon_i = \\frac{g}{2\\pi^2} \\int_0^{k_{F_i}} k^2 \\left(\\frac{\\hbar^2 k^2}{2m}\\right) dk = \\frac{g\\hbar^2}{4\\pi^2 m} \\frac{k_{F_i}^5}{5} $$\nSubstituting $k_{F_i}$ and $g=2$, we can express $\\varepsilon_i$ in terms of $\\rho_i$:\n$$ \\varepsilon_i = \\frac{\\hbar^2}{10\\pi^2 m} (3\\pi^2 \\rho_i)^{5/3} = \\frac{3\\hbar^2(3\\pi^2)^{2/3}}{10m} \\rho_i^{5/3} $$\nThe total kinetic energy per particle is then:\n$$ E/A(\\delta) = \\frac{1}{\\rho} \\left( \\varepsilon_n + \\varepsilon_p \\right) = \\frac{3\\hbar^2(3\\pi^2)^{2/3}}{10m\\rho} \\left[ \\rho_n^{5/3} + \\rho_p^{5/3} \\right] $$\nSubstituting $\\rho_n = \\rho(1+\\delta)/2$ and $\\rho_p = \\rho(1-\\delta)/2$:\n$$ E/A(\\delta) = \\frac{3\\hbar^2(3\\pi^2\\rho)^{2/3}}{10m \\cdot 2^{2/3}} \\frac{1}{2} \\left[ (1+\\delta)^{5/3} + (1-\\delta)^{5/3} \\right] $$\n\nThe kinetic symmetry energy $S_{\\mathrm{kin}}$ is the coefficient of $\\delta^2$ in the Taylor expansion of $E/A(\\delta)$ around $\\delta=0$. We expand the term in brackets: $(1+x)^p \\approx 1 + px + \\frac{p(p-1)}{2}x^2 + \\dots$. For $x=\\pm\\delta$ and $p=5/3$:\n$$ (1+\\delta)^{5/3} + (1-\\delta)^{5/3} \\approx \\left(1 + \\frac{5}{3}\\delta + \\frac{5}{3}\\frac{2}{3}\\frac{\\delta^2}{2}\\right) + \\left(1 - \\frac{5}{3}\\delta + \\frac{5}{3}\\frac{2}{3}\\frac{\\delta^2}{2}\\right) = 2 + \\frac{10}{9}\\delta^2 + \\mathcal{O}(\\delta^4) $$\nSubstituting this into the expression for $E/A(\\delta)$ yields:\n$$ E/A(\\delta) = E/A(0) \\left(1 + \\frac{5}{9}\\delta^2 + \\dots\\right) \\quad \\text{where} \\quad E/A(0) = \\frac{3}{5} \\frac{\\hbar^2 k_F^2}{2m} = \\frac{3}{5} E_F(\\rho) $$\nHere $k_F = (3\\pi^2\\rho/2)^{1/3}$ is the Fermi wave number for symmetric ($\\delta=0$) matter. Thus, the expansion is:\n$$ E/A(\\delta) = \\frac{3}{5}E_F(\\rho) + \\frac{1}{3}E_F(\\rho)\\delta^2 + \\mathcal{O}(\\delta^4) $$\nThe analytical expression for the kinetic symmetry energy at $T=0$ is therefore:\n$$ S_{\\mathrm{kin}}(\\rho, T=0) = \\frac{1}{3} E_F(\\rho) = \\frac{1}{3} \\frac{\\hbar^2}{2m} \\left(\\frac{3\\pi^2\\rho}{2}\\right)^{2/3} $$\nThis formula is used to verify the numerically fitted value.\n\n**3. Finite-Temperature Case ($T0\\,\\mathrm{MeV}$)**\n\nAt finite temperature, the Fermi-Dirac distribution is a smooth function and the integrals must be computed numerically. The procedure for calculating $E/A(\\delta)$ for a given $(\\rho, \\delta, T)$ is as follows:\n1.  Calculate $\\rho_n = \\rho(1+\\delta)/2$ and $\\rho_p = \\rho(1-\\delta)/2$.\n2.  For each species $i \\in \\{n, p\\}$, if $\\rho_i  0$, determine the chemical potential $\\mu_i$ by numerically solving the non-linear equation $\\rho_i = \\rho_i(\\mu_i, T)$. This is a root-finding problem for $\\mu_i$. Since $\\rho_i(\\mu_i, T)$ is a monotonically increasing function of $\\mu_i$, a robust root-bracketing method like Brent's method is suitable. The integral for $\\rho_i(\\mu_i,T)$ is computed using a numerical quadrature routine.\n3.  Once $\\mu_i$ is known, the kinetic energy density $\\varepsilon_i = \\varepsilon_i(\\mu_i, T)$ is calculated by numerically integrating its defining expression.\n4.  The total kinetic energy per particle is then computed as $E/A(\\delta) = (\\varepsilon_n+\\varepsilon_p)/\\rho$.\n\n**4. Numerical Extraction of the Symmetry Energy**\n\nThe problem asks to determine $S_{\\mathrm{kin}}(\\rho,T)$ from the expansion $E/A(\\delta) \\approx E/A(0) + S_{\\mathrm{kin}}(\\rho,T)\\delta^2$. This is a quadratic fit in $\\delta$, or equivalently, a linear fit in $\\delta^2$.\n1.  For a given $(\\rho, T)$, the quantity $E/A(\\delta_j)$ is computed for each $\\delta_j$ in the specified grid $\\{-0.4, -0.2, 0.0, 0.2, 0.4\\}$.\n2.  We perform a linear least-squares fit to the model $y_j = c_0 + c_1 x_j$, where the independent variable is $x_j = \\delta_j^2$ and the dependent variable is $y_j = E/A(\\delta_j)$.\n3.  This corresponds to solving the linear system $A\\mathbf{c} = \\mathbf{b}$ in the least-squares sense, where $\\mathbf{b}$ is the vector of computed $E/A(\\delta_j)$ values, $\\mathbf{c} = [c_0, c_1]^T$ is the vector of coefficients to be found, and $A$ is the design matrix:\n    $$A = \\begin{pmatrix} 1  \\delta_1^2 \\\\ 1  \\delta_2^2 \\\\ \\vdots  \\vdots \\\\ 1  \\delta_5^2 \\end{pmatrix} = \\begin{pmatrix} 1  0.16 \\\\ 1  0.04 \\\\ 1  0.00 \\\\ 1  0.04 \\\\ 1  0.16 \\end{pmatrix}$$\n4.  The fitted coefficient $c_1$ is the numerical estimate for the kinetic symmetry energy, $S_{\\mathrm{kin}}(\\rho,T)$.\n\nThis comprehensive approach combines analytical derivations for the $T=0$ case with a robust numerical strategy for the $T0$ case, culminating in a well-defined procedure to extract the kinetic symmetry energy.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the Fermi gas model problem for the specified test cases.\n    \"\"\"\n\n    # Constants\n    HBARC = 197.3269804  # MeV fm\n    M_N = 939.0          # MeV (bare nucleon mass as mc^2)\n    HBARC2_2M = HBARC**2 / (2 * M_N) # MeV fm^2\n    G = 2.0              # Spin degeneracy\n    PI = np.pi\n\n    # --- T=0 Analytical Calculations ---\n\n    def s_kin_analytic_t0(rho):\n        \"\"\"Calculates the analytical kinetic symmetry energy at T=0.\"\"\"\n        term1 = HBARC2_2M / 3.0\n        term2 = (3.0 * PI**2 * rho / 2.0)**(2.0/3.0)\n        return term1 * term2\n\n    def get_e_per_a_t0(rho, delta):\n        \"\"\"Calculates the kinetic energy per particle at T=0.\"\"\"\n        rho_n = rho * (1.0 + delta) / 2.0\n        rho_p = rho * (1.0 - delta) / 2.0\n\n        # E/A(delta) = (3/10) * (hbar^2/m) * (3*pi^2)^(2/3) * (rho_n^(5/3)+rho_p^(5/3))/rho\n        constant = (HBARC2_2M) * (3.0/5.0) * (3.0 * PI**2)**(2.0/3.0)\n        \n        term_n = rho_n**(5.0/3.0) if rho_n > 0 else 0.0\n        term_p = rho_p**(5.0/3.0) if rho_p > 0 else 0.0\n        \n        e_per_a = constant * (term_n + term_p) / rho if rho > 0 else 0.0\n        return e_per_a\n\n    # --- T>0 Numerical Calculations ---\n\n    # Integrands for number density and energy density\n    def integrand_rho(k, mu, T):\n        arg = (HBARC2_2M * k**2 - mu) / T\n        # Avoid overflow for large positive arguments\n        if arg > 700:\n            return 0.0\n        return k**2 / (1.0 + np.exp(arg))\n\n    def integrand_eps(k, mu, T):\n        arg = (HBARC2_2M * k**2 - mu) / T\n        if arg > 700:\n            return 0.0\n        return HBARC2_2M * k**4 / (1.0 + np.exp(arg))\n\n    # Function to calculate number density for a given chemical potential\n    def calculate_rho(mu, T):\n        integral, _ = quad(integrand_rho, 0, np.inf, args=(mu, T), epsabs=1e-12, epsrel=1e-12)\n        # Prefactor is G / (2*pi^2) = 1/pi^2\n        return (1.0 / PI**2) * integral\n\n    # Root-finding function to determine chemical potential\n    def find_mu(rho_i, T):\n        if rho_i = 1e-20:  # Effectively zero density\n            return -np.inf\n        \n        def root_function(mu):\n            return calculate_rho(mu, T) - rho_i\n        \n        # A robust bracket for mu in MeV\n        mu_min, mu_max = -500.0, 500.0\n        try:\n            mu = brentq(root_function, mu_min, mu_max, xtol=1e-12, rtol=1e-12)\n        except ValueError:\n            # This can happen if the root is outside the bracket, e.g., low density\n            # Let's try to search for the bracket\n             a, b = mu_min, mu_max\n             fa, fb = root_function(a), root_function(b)\n             while fa * fb > 0 and a > -2000: # Add limit to avoid infinite loop\n                 if abs(fa)  abs(fb):\n                     a -= 200\n                     fa = root_function(a)\n                 else:\n                     b += 200\n                     fb = root_function(b)\n             mu = brentq(root_function, a, b, xtol=1e-12, rtol=1e-12)\n        return mu\n\n    # Function to calculate kinetic energy density\n    def calculate_eps(mu, T):\n        if not np.isfinite(mu):\n            return 0.0\n        integral, _ = quad(integrand_eps, 0, np.inf, args=(mu, T), epsabs=1e-12, epsrel=1e-12)\n        return (1.0 / PI**2) * integral\n\n    # Main function to get E/A at T>0\n    def get_e_per_a_t_gt_0(rho, delta, T):\n        rho_n = rho * (1.0 + delta) / 2.0\n        rho_p = rho * (1.0 - delta) / 2.0\n        \n        mu_n = find_mu(rho_n, T)\n        eps_n = calculate_eps(mu_n, T)\n        \n        mu_p = find_mu(rho_p, T)\n        eps_p = calculate_eps(mu_p, T)\n        \n        return (eps_n + eps_p) / rho if rho > 0 else 0.0\n\n    # --- Main Loop for Test Cases ---\n\n    test_cases = [\n        {'rho': 0.16, 'T': 0.0},\n        {'rho': 0.08, 'T': 0.0},\n        {'rho': 0.16, 'T': 5.0},\n        {'rho': 0.16, 'T': 20.0},\n        {'rho': 1e-6, 'T': 5.0},\n    ]\n    \n    delta_grid = np.array([-0.4, -0.2, 0.0, 0.2, 0.4])\n    results = []\n    \n    for case in test_cases:\n        rho = case['rho']\n        T = case['T']\n        \n        e_per_a_values = []\n        for delta in delta_grid:\n            if T == 0.0:\n                e_val = get_e_per_a_t0(rho, delta)\n            else:\n                e_val = get_e_per_a_t_gt_0(rho, delta, T)\n            e_per_a_values.append(e_val)\n            \n        # Least-squares fit to y = c0 + c1*x where x=delta^2\n        delta_sq = delta_grid**2\n        A = np.vstack([np.ones_like(delta_sq), delta_sq]).T\n        b = np.array(e_per_a_values)\n        \n        coeffs, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n        s_kin_fit = coeffs[1]\n        \n        results.append(f\"{s_kin_fit:.6f}\")\n        \n        if T == 0.0:\n            s_kin_analytic = s_kin_analytic_t0(rho)\n            is_match = np.isclose(s_kin_fit, s_kin_analytic, atol=1e-3)\n            results.append(str(is_match))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}