{
    "hands_on_practices": [
        {
            "introduction": "定量描述氘核性质的基础是求解薛定谔方程。本练习  将指导你通过将微分方程转化为矩阵本征值问题，来为一个给定的核子-核子相互作用势数值求解氘核的结合能。通过实现并比较有限差分法和谱方法这两种截然不同的数值方法，你将获得计算量子力学的核心技术实践经验，并理解不同数值策略之间的优劣权衡。",
            "id": "3582617",
            "problem": "考虑质子-中子系统（氘核）在非相对论极限下的束缚态，该束缚态由S波通道中约化径向波函数 $u(r)$ 的径向不含时薛定谔方程描述：\n$$\n-\\frac{\\hbar^2}{2\\mu}\\frac{d^2 u(r)}{dr^2} + V(r)\\,u(r) = E\\,u(r),\n$$\n边界条件为 $u(0)=0$ 且当 $r\\to \\infty$ 时 $u(r)\\to 0$。此处，$\\mu$ 是质子-中子系统的约化质量，$E$ 是结合能（对于束缚态为负值）。使用以费米 (femtometer) 为长度单位、兆电子伏特 (mega-electronvolt) 为能量单位的单位制。使用 $\\hbar c$ 以便将 $\\hbar^2/(2\\mu)$ 的单位一致地表示为兆电子伏特·费米平方。约化质量 $\\mu$ 由质子质量 $m_p$ 和中子质量 $m_n$ 计算得出：$\\mu = \\frac{m_p m_n}{m_p + m_n}$。\n\n假设核相互作用由单π介子交换 (OPE) 中心汤川势和正则化接触相互作用给出，这与低能手征有效场论一致，定义为\n$$\nV(r) = V_{\\text{Y}}(r) + V_{\\text{C}}(r),\n$$\n其中中心汤川势为\n$$\nV_{\\text{Y}}(r) = -C_Y \\frac{e^{-m_\\pi r}}{r},\n$$\n正则化接触相互作用为\n$$\nV_{\\text{C}}(r) = C_0 \\exp\\left(-\\left(\\frac{r}{R_0}\\right)^2\\right).\n$$\n使用以下常数：\n- $\\hbar c = 197.3269804$ 兆电子伏特·费米，\n- $m_p = 938.2720813$ 兆电子伏特，\n- $m_n = 939.5654133$ 兆电子伏特，\n- $m_\\pi = 138.0$ 兆电子伏特，\n- $C_Y = 40.0$ 兆电子伏特·费米，\n- $C_0 = -300.0$ 兆电子伏特，\n- $R_0 = 0.6$ 费米。\n\n使用 $m_\\pi^{(\\text{fm}^{-1})} = \\frac{m_\\pi}{\\hbar c}$ 将π介子质量 $m_\\pi$ 转换为逆费米单位，以便在汤川因子中使用。箱体尺寸为 $L$ 费米，问题在区间 $r\\in[0,L]$ 上提出，并采用狄利克雷边界条件 $u(0)=0$ 和 $u(L)=0$ 来近似 $u(r\\to\\infty)=0$。\n\n实现两种数值方法来近似基态结合能：\n1. 在具有 $N$ 个内部点和间距 $\\Delta r = \\frac{L}{N+1}$ 的均匀网格上进行标准的二阶中心有限差分，得到一个三对角哈密顿矩阵，其元素为\n$$\nH_{jj} = \\frac{\\hbar^2}{\\mu \\Delta r^2} + V(r_j), \\quad H_{j,j\\pm 1} = -\\frac{\\hbar^2}{2\\mu \\Delta r^2},\n$$\n对于内部网格点 $r_j = j \\Delta r$（其中 $j = 1,2,\\dots,N$），$V(r_j)$ 在这些点上求值。\n2. 使用傅里叶正弦基（伪谱配点法）在 $[0,L]$ 上进行谱伽辽金方法，基函数为 $N$ 个，即 $\\{\\phi_n(r)\\}_{n=1}^N$，其中\n$$\n\\phi_n(r) = \\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi r}{L}\\right).\n$$\n动能算符在此基下是对角的，其本征值为\n$$\nT_n = \\frac{\\hbar^2}{2\\mu}\\left(\\frac{n\\pi}{L}\\right)^2.\n$$\n使用相同的 $N$ 个内部点 $r_j = j \\Delta r$ 上的均匀求积来近似势能矩阵元，即\n$$\nV_{nm} \\approx \\Delta r \\sum_{j=1}^N \\phi_n(r_j)\\,V(r_j)\\,\\phi_m(r_j),\n$$\n以构建稠密哈密顿矩阵 $H_{nm} = T_n \\delta_{nm} + V_{nm}$。\n\n对于这两种方法，计算各自哈密顿量的最小本征值，并将其解释为基态能量 $E$（单位为兆电子伏特）。通过在相同箱体尺寸 $L$ 上使用大基组的谱伽辽金方法，定义一个高精度参考解 $E_{\\text{ref}}$。\n\n你的程序必须：\n- 使用上述常数，并从 $m_p$ 和 $m_n$ 计算约化质量 $\\mu$。\n- 实现所述的两种数值方法。\n- 使用谱方法，在 $N_{\\text{ref}} = 512$ 和箱体尺寸 $L = 20.0$ 费米的条件下，计算参考基态能量 $E_{\\text{ref}}$。\n- 对以下测试套件评估绝对误差 $|E - E_{\\text{ref}}|$：\n    - 情况 1：$L = 20.0$ 费米, $N = 64$，\n    - 情况 2：$L = 20.0$ 费米, $N = 128$，\n    - 情况 3：$L = 20.0$ 费米, $N = 256$。\n对每种情况，计算有限差分法和谱方法的绝对误差。\n\n所有能量和误差均以兆电子伏特表示，报告的误差四舍五入到六位小数。此问题不涉及角度。你的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，列表包含六个结果，顺序如下：\n$$\n[\\;|E_{\\text{FD}}^{(64)} - E_{\\text{ref}}|,\\;|E_{\\text{SP}}^{(64)} - E_{\\text{ref}}|,\\;|E_{\\text{FD}}^{(128)} - E_{\\text{ref}}|,\\;|E_{\\text{SP}}^{(128)} - E_{\\text{ref}}|,\\;|E_{\\text{FD}}^{(256)} - E_{\\text{ref}}|,\\;|E_{\\text{SP}}^{(256)} - E_{\\text{ref}}|\\;],\n$$\n其中 $E_{\\text{FD}}^{(N)}$ 和 $E_{\\text{SP}}^{(N)}$ 分别表示在箱体 $[0,L]$ 上使用 $N$ 个内部点或基函数，通过有限差分法和谱方法获得的基态能量。最终输出必须严格采用格式“[result1,result2,result3,result4,result5,result6]”。",
            "solution": "出发点是S波氘核的非相对论径向薛定谔方程，其形式为\n$$\n-\\frac{\\hbar^2}{2\\mu}\\frac{d^2 u(r)}{dr^2} + V(r)\\,u(r) = E\\,u(r),\n$$\n边界条件为 $u(0)=0$ 和 $u(r\\to\\infty)=0$，且 $l=0$，因此没有离心项。质子-中子系统的约化质量 $\\mu$ 由质子质量 $m_p$ 和中子质量 $m_n$ 计算得出：\n$$\n\\mu = \\frac{m_p m_n}{m_p + m_n}.\n$$\n我们在有限区间 $[0,L]$ 上求解，并施加狄利克雷边界条件 $u(0)=0$ 和 $u(L)=0$ 来近似束缚态条件。\n\n核势被建模为单π介子交换 (OPE) 中心汤川项和正则化接触相互作用之和。OPE 中心汤川项为\n$$\nV_{\\text{Y}}(r) = -C_Y \\frac{e^{-m_\\pi r}}{r},\n$$\n其中 $m_\\pi$ 是以逆费米为单位的π介子质量。为使用以兆电子伏特为单位给出的 $m_\\pi$，我们通过以下方式转换：\n$$\nm_\\pi^{(\\text{fm}^{-1})} = \\frac{m_\\pi^{(\\text{MeV})}}{\\hbar c},\n$$\n其中 $\\hbar c$ 以兆电子伏特·费米为单位。正则化接触相互作用模拟了短程物理，并选择高斯型正则化子：\n$$\nV_{\\text{C}}(r) = C_0 \\exp\\left(-\\left(\\frac{r}{R_0}\\right)^2\\right).\n$$\n因此，总势能为\n$$\nV(r) = -C_Y \\frac{e^{-m_\\pi r}}{r} + C_0 \\exp\\left(-\\left(\\frac{r}{R_0}\\right)^2\\right).\n$$\n\n为了数值计算束缚态能量，我们将问题离散化并求解相应的矩阵本征值问题。采用了两种方法：\n\n1. 有限差分法 (FDM)：\n我们定义一个包含 $N$ 个内部点且间距为\n$$\n\\Delta r = \\frac{L}{N+1},\n$$\n的均匀网格，网格点为 $r_j = j \\Delta r$，$j=1,2,\\dots,N$。二阶导数使用标准中心有限差分近似：\n$$\n\\frac{d^2 u}{dr^2}\\bigg|_{r_j} \\approx \\frac{u_{j+1} - 2 u_j + u_{j-1}}{\\Delta r^2}.\n$$\n动能算符 $-\\frac{\\hbar^2}{2\\mu}\\frac{d^2}{dr^2}$ 随之产生一个三对角矩阵，其元素为\n$$\nH_{jj} = \\frac{\\hbar^2}{\\mu \\Delta r^2} + V(r_j), \\quad H_{j,j\\pm 1} = -\\frac{\\hbar^2}{2\\mu \\Delta r^2}.\n$$\n这个 $N\\times N$ 的三对角哈密顿量通过在 $r=0$ 和 $r=L$ 处不设置点来隐式地包含狄利克雷边界条件。该矩阵的最小本征值近似于基态能量 $E$。\n\n2. 谱伽辽金方法（使用傅里叶正弦基）：\n我们使用在 $[0,L]$ 上的标准正交基函数，\n$$\n\\phi_n(r) = \\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi r}{L}\\right), \\quad n=1,2,\\dots,N.\n$$\n这些基函数满足狄利克雷边界条件 $\\phi_n(0)=\\phi_n(L)=0$。动能算符在此基中是对角的，其本征值为\n$$\nT_n = \\frac{\\hbar^2}{2\\mu}\\left(\\frac{n\\pi}{L}\\right)^2.\n$$\n势能矩阵元由积分给出：\n$$\nV_{nm} = \\int_0^L \\phi_n(r)\\,V(r)\\,\\phi_m(r)\\,dr.\n$$\n我们通过在相同的 $N$ 个内部点 $r_j = j \\Delta r$ 上使用均匀求积（黎曼和）来近似此积分：\n$$\nV_{nm} \\approx \\Delta r \\sum_{j=1}^N \\phi_n(r_j)\\,V(r_j)\\,\\phi_m(r_j).\n$$\n在此基中的哈密顿矩阵为\n$$\nH_{nm} = T_n \\delta_{nm} + V_{nm}.\n$$\n然后我们计算这个稠密对称矩阵的最小本征值，以近似基态能量 $E$。\n\n参考解：\n为了衡量精度，我们使用谱伽辽金方法，在尺寸为 $L=20.0$ 费米的箱体上，采用 $N_{\\text{ref}}=512$ 个基函数来计算一个高精度的参考基态能量 $E_{\\text{ref}}$。这提供了一个基准，我们可以据此计算其他离散化方法的绝对误差：\n$$\n\\text{error} = |E - E_{\\text{ref}}|.\n$$\n\n算法步骤：\n- 计算常数：$\\hbar c$、$m_p$、$m_n$ 以及约化质量 $\\mu = \\frac{m_p m_n}{m_p + m_n}$。\n- 通过 $m_\\pi^{(\\text{fm}^{-1})} = \\frac{m_\\pi}{\\hbar c}$ 将 $m_\\pi$ 从兆电子伏特转换为逆费米。\n- 实现一个函数，使用给定的 $C_Y$、$C_0$ 和 $R_0$ 在任意 $r>0$ 处计算 $V(r)$。\n- 针对给定的 $N$ 和 $L$ 实现 FDM 哈密顿量的构建，并使用三对角本征求解器计算其最小本征值。\n- 针对给定的 $N$ 和 $L$ 使用正弦基实现谱伽辽金哈密顿量，组装对角动能矩阵和基于求积的势能矩阵，并使用稠密对称本征求解器计算其最小本征值。\n- 使用谱方法，在 $N_{\\text{ref}}=512$ 和 $L=20.0$ 的条件下计算 $E_{\\text{ref}}$。\n- 对于测试套件中的情况 $(N,L) = (64,20.0)$、$(128,20.0)$ 和 $(256,20.0)$，计算有限差分法和谱方法的基态能量，以及它们相对于 $E_{\\text{ref}}$ 的绝对误差。\n- 将每个误差四舍五入到六位小数，并以指定的单行列表格式打印它们。\n\n科学原理：\n薛定谔方程是在非相对论范畴内控制氘核束缚态波函数的基本定律。在手征有效场论中，OPE 中心汤川势是核力的领头长程分量，而短程物理则由正则化接触相互作用来描述。有限差分法在均匀网格上离散化拉普拉斯算符，提供了一种简单而系统化的近似方法。谱伽辽金方法利用了满足边界条件的动能算符的已知本征函数，对光滑势能能够实现快速收敛。将这两种方法与高分辨率的谱参考解进行比较，可以量化在固定箱体尺寸下，随着 $N$ 增加时方法的精度和收敛行为。\n\n单位：\n所有能量（包括 $E$ 和 $E_{\\text{ref}}$）和误差都必须以兆电子伏特表示，并以十进制浮点数报告。最终输出必须是单行文本\n$$\n[\\;|E_{\\text{FD}}^{(64)} - E_{\\text{ref}}|,\\;|E_{\\text{SP}}^{(64)} - E_{\\text{ref}}|,\\;|E_{\\text{FD}}^{(128)} - E_{\\text{ref}}|,\\;|E_{\\text{SP}}^{(128)} - E_{\\text{ref}}|,\\;|E_{\\text{FD}}^{(256)} - E_{\\text{ref}}|,\\;|E_{\\text{SP}}^{(256)} - E_{\\text{ref}}|\\;],\n$$\n每个浮点数四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\nfrom numpy.linalg import eigh\n\n# Constants (in MeV and fm units)\nHBAR_C = 197.3269804  # MeV*fm\nM_P = 938.2720813     # MeV\nM_N = 939.5654133     # MeV\n\n# Reduced mass (MeV) in natural units (c=1)\nMU = (M_P * M_N) / (M_P + M_N)\n\n# Potential parameters\nM_PI_MEV = 138.0                 # MeV\nM_PI_FM_INV = M_PI_MEV / HBAR_C  # 1/fm\nC_Y = 40.0                       # MeV*fm for Yukawa\nC0 = -300.0                      # MeV for contact\nR0 = 0.6                         # fm for contact regulator\n\ndef potential(r):\n    \"\"\"\n    Compute the nuclear potential V(r) = Yukawa + Gaussian contact at radial distance r (fm).\n    Returns energy in MeV.\n    \"\"\"\n    # Avoid division by zero; r is never zero on interior points.\n    vy = -C_Y * np.exp(-M_PI_FM_INV * r) / r\n    vc = C0 * np.exp(-(r / R0) ** 2)\n    return vy + vc\n\ndef fd_ground_energy(N, L):\n    \"\"\"\n    Finite-difference method ground-state energy for given N interior points and box size L (fm).\n    Returns the smallest eigenvalue (MeV).\n    \"\"\"\n    dr = L / (N + 1)\n    r = (np.arange(1, N + 1)) * dr\n    V = potential(r)\n\n    # Kinetic prefactor: - (hbar^2 / (2 mu)) d^2/dr^2\n    # For the discrete Hamiltonian, diag and off-diagonal entries as per central difference.\n    kinetic_diag = (HBAR_C ** 2) / (MU * dr * dr)   # MeV\n    kinetic_off = - (HBAR_C ** 2) / (2.0 * MU * dr * dr)  # MeV\n\n    d = kinetic_diag + V                # main diagonal\n    e = np.full(N - 1, kinetic_off)     # off-diagonal entries\n\n    # Compute eigenvalues of tridiagonal symmetric matrix\n    evals = eigh_tridiagonal(d, e, select='i', select_range=(0, 0))[0]\n    return float(evals[0])\n\ndef spectral_ground_energy(N, L):\n    \"\"\"\n    Spectral Galerkin method using Fourier sine basis with N modes on [0, L] (fm).\n    Constructs the Hamiltonian in the sine basis and returns the smallest eigenvalue (MeV).\n    \"\"\"\n    dr = L / (N + 1)\n    r = (np.arange(1, N + 1)) * dr  # interior points\n    V = potential(r)\n\n    # Build the basis function values Phi[j, n] = sqrt(2/L) * sin(n*pi*r_j/L)\n    n_idx = np.arange(1, N + 1)\n    k = (n_idx * np.pi) / L\n    Phi = np.sqrt(2.0 / L) * np.sin(np.outer(r, k))  # shape (N, N)\n\n    # Kinetic energy diagonal in the sine basis: T_n = (hbar^2 / (2 mu)) * k_n^2\n    T_diag = (HBAR_C ** 2) * (k ** 2) / (2.0 * MU)\n\n    # Potential matrix via quadrature: V_nm ≈ dr * sum_j Phi[j,n] * V(r_j) * Phi[j,m]\n    # Compute S = sqrt(dr) * Phi, then V_nm = (S^T * diag(V) * S) for numerical stability\n    # But since dr is scalar, we can do directly:\n    # temp = (V[:, None] * Phi) has shape (N, N)\n    temp = V[:, None] * Phi\n    V_mat = dr * (Phi.T @ temp)  # (N, N)\n\n    # Hamiltonian in the basis\n    H = V_mat + np.diag(T_diag)\n\n    # Dense symmetric eigenvalue problem\n    evals = eigh(H)[0]\n    return float(evals[0])\n\ndef solve():\n    # Box size for all test cases\n    L = 20.0\n\n    # Reference energy using spectral method with high resolution\n    N_ref = 512\n    E_ref = spectral_ground_energy(N_ref, L)\n\n    # Test suite: (N, L) values\n    test_cases = [\n        (64, L),\n        (128, L),\n        (256, L),\n    ]\n\n    results = []\n    for N, L_case in test_cases:\n        E_fd = fd_ground_energy(N, L_case)\n        E_sp = spectral_ground_energy(N, L_case)\n        err_fd = abs(E_fd - E_ref)\n        err_sp = abs(E_sp - E_ref)\n        # Round to six decimal places as required\n        results.append(round(err_fd, 6))\n        results.append(round(err_sp, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "现代大规模核物理计算（例如格点计算）必须在有限的体积内进行，这会引入系统效应。本练习  将让你在周期性立方盒子中计算氘核结合能的移动，从而为这一关键课题提供一个实践性的入门。通过在动量空间中使用一个可分离势，你将验证有限体积修正的著名指数标度行为，这是联系无限空间中的理论计算与计算机上的实际执行之间的桥梁。",
            "id": "3582632",
            "problem": "考虑一个由相对坐标的、具有约化质量 $\\mu$ 的不含时薛定谔方程所描述的非相对论量子力学中的双核子束缚态（氘核）。在三维空间中进行计算。使用动量空间中针对束缚态的 Lippmann–Schwinger 方程，并采用一阶可分离 Yamaguchi 相互作用，其形状因子 $g(\\mathbf{q})$ 和耦合强度 $\\lambda$ 由下式给出\n$V(\\mathbf{k},\\mathbf{k}') = -\\lambda\\, g(\\mathbf{k})\\, g(\\mathbf{k}'), \\quad g(\\mathbf{q}) = \\dfrac{1}{\\mathbf{q}^2 + \\beta^2},$\n其中 $\\beta$ 是一个以逆费米为单位的固定正参数。令 $\\hbar$ 表示约化普朗克常数，$c$ 表示光速。使用以下物理常数和参数：\n- $\\hbar c = 197.3269804\\ \\text{MeV}\\cdot\\text{fm}$，\n- 质子质量 $m_p = 938.2720813\\ \\text{MeV}/c^2$，\n- 中子质量 $m_n = 939.5654133\\ \\text{MeV}/c^2$，\n- 约化质量 $\\mu = \\dfrac{m_p m_n}{m_p + m_n}$，\n- Yamaguchi 作用程参数 $\\beta = 1.4\\ \\text{fm}^{-1}$，\n- 目标无限体积氘核结合能 $B_d^{(\\infty)} = 2.224575\\ \\text{MeV}$。\n\n在无限体积中，束缚态条件源于 $T$ 矩阵的齐次 Lippmann–Schwinger 方程，对于所选的可分离相互作用，该条件简化为极点条件\n$1 + \\lambda\\, J_{\\infty}(E) = 0,$\n其中 $E$ 是质心系中的总能量（对于束缚态为负值），且\n$J_{\\infty}(E) = \\int \\dfrac{d^3 q}{(2\\pi)^3}\\, \\dfrac{g(\\mathbf{q})^2}{E - \\dfrac{(\\hbar c)^2 \\mathbf{q}^2}{2\\mu}}\\ .$\n在边长为 $L$ 的立方盒子中、采用周期性边界条件的有限体积内，该积分被替换为对动量 $\\mathbf{q} = \\dfrac{2\\pi}{L}\\, \\mathbf{n}$（其中 $\\mathbf{n} \\in \\mathbb{Z}^3$）的离散求和，即\n$J_{L}(E) = \\dfrac{1}{L^3} \\sum_{\\mathbf{n}\\in\\mathbb{Z}^3} \\dfrac{g\\!\\left(\\dfrac{2\\pi}{L}\\mathbf{n}\\right)^2}{E - \\dfrac{(\\hbar c)^2}{2\\mu}\\left(\\dfrac{2\\pi}{L}\\right)^2 \\|\\mathbf{n}\\|^2}\\ .$\n必须选择无限体积耦合 $\\lambda$ 以通过条件 $1 + \\lambda\\, J_{\\infty}(-B_d^{(\\infty)}) = 0$ 再现目标结合能 $B_d^{(\\infty)}$。然后，对于每个有限的 $L$，有限体积结合能 $B_d(L)$ 由 $1 + \\lambda\\, J_L(E)=0$ 的唯一负能解 $E=-B_d(L)$ 定义。\n\n当 $L \\to \\infty$ 时，有限体积位移 $\\Delta B_d(L) = B_d(L) - B_d^{(\\infty)}$ 预期是指数级小的，并由无限体积结合动量 $\\kappa = \\sqrt{\\dfrac{2\\mu B_d^{(\\infty)}}{(\\hbar c)^2}}$ 控制，其渐近形式为 $\\Delta B_d(L) \\propto \\dfrac{e^{-\\kappa L}}{L}$（不计次领头修正）。您的任务是实现一个程序，在数值上完成以下操作：\n- 使用上述 $J_{\\infty}(E)$，根据在 $E=-B_d^{(\\infty)}$ 处的无限体积条件校准 $\\lambda$，\n- 通过求解 $1 + \\lambda\\, J_L(E)=0$（其中 $E0$），计算几个 $L$ 值对应的 $B_d(L)$，\n- 估算有限体积位移 $\\Delta B_d(L)$，并通过将 $\\ln\\!\\big(\\Delta B_d(L)\\, L\\big)$ 对 $L$ 的关系拟合为一条直线来验证指数除以 $L$ 的标度关系，并提取斜率的数值估计值 $-\\,\\kappa_{\\text{fit}}$，\n- 将 $\\kappa_{\\text{fit}}$ 与直接从 $B_d^{(\\infty)}$ 和 $\\mu$ 计算出的 $\\kappa$ 进行比较。\n\n使用以下计算细节以确保计算是适定和自洽的：\n- 使用 $J_L(E)$ 的离散求和定义，并对 $\\|\\mathbf{q}\\| \\le \\Lambda$ 应用以逆费米为单位的球形动量截断 $\\Lambda$。选择 $\\Lambda = 6.0\\ \\text{fm}^{-1}$。将求和截断至所有满足 $\\left\\|\\dfrac{2\\pi}{L}\\mathbf{n}\\right\\| \\le \\Lambda$ 的整数三元组 $\\mathbf{n}$；这确保了对 $J_L(E)$ 的一个有限且可系统改进的近似。不需要对 $\\Lambda$ 进行进一步外推。\n- 对于 $J_{\\infty}(E)$，在球坐标中执行三维积分，即 $J_{\\infty}(E) = \\dfrac{1}{2\\pi^2}\\int_{0}^{\\infty} dq\\, \\dfrac{q^2}{E - \\dfrac{(\\hbar c)^2 q^2}{2\\mu}}\\dfrac{1}{(q^2+\\beta^2)^2}$，使用在 $q \\in [0,\\infty)$ 上可靠的数值积分方法，并保证有足够的精度来确定 $\\lambda$。\n- 对于固定的 $L$，通过在负能域内进行稳健的一维求根来求解 $E=-B_d(L)$，使用一个能安全包围根的区间。\n\n采用以下盒子尺寸（以费米为单位）的测试集：\n- 集合 $\\mathcal{A}$：$L \\in \\{12.0, 14.0, 16.0\\}$，\n- 集合 $\\mathcal{B}$：$L \\in \\{8.0, 10.0, 12.0\\}$，\n- 集合 $\\mathcal{C}$：$L \\in \\{6.0, 7.0, 8.0\\}$。\n\n对于每个集合，计算所列 $L$ 值处的 $\\Delta B_d(L)$，对 $y(L) = \\ln\\!\\big(\\Delta B_d(L)\\, L\\big)$ 与 $L$ 的关系进行线性最小二乘拟合，并提取 $\\kappa_{\\text{fit}}$ 作为拟合斜率的负值。同时，通过 $\\kappa = \\sqrt{\\dfrac{2\\mu B_d^{(\\infty)}}{(\\hbar c)^2}}$ 从约化质量和 $B_d^{(\\infty)}$ 计算参考值 $\\kappa$。所有 $\\kappa$ 值必须以逆费米报告。\n\n物理和数值单位：\n- 能量必须以 $\\text{MeV}$ 计算和处理。\n- 长度和动量空间截断必须分别以 $\\text{fm}$ 和 $\\text{fm}^{-1}$ 处理。\n- 最终输出必须以 $\\text{fm}^{-1}$ 表示。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。要求的输出是列表 $[\\kappa,\\ \\kappa_{\\text{fit}}(\\mathcal{A}),\\ \\kappa_{\\text{fit}}(\\mathcal{B}),\\ \\kappa_{\\text{fit}}(\\mathcal{C})]$，并按此顺序。每个条目必须是 $\\text{fm}^{-1}$ 单位的浮点数。程序不得读取任何输入，并且必须使用上面指定的常数和参数。您可以将浮点结果格式化为固定的小数位数，但必须确保它们是有效的十进制数。不应打印任何其他文本。",
            "solution": "用户想要解决一个关于有限体积中氘核束缚态的计算核物理问题。\n\n### 问题验证\n\n1.  **已知条件提取**：\n    *   **系统**：非相对论量子力学中的氘核（双核子束缚态）。\n    *   **相互作用**：一阶可分离 Yamaguchi 势，$V(\\mathbf{k},\\mathbf{k}') = -\\lambda\\, g(\\mathbf{k})\\, g(\\mathbf{k}')$，其形状因子为 $g(\\mathbf{q}) = 1/(\\mathbf{q}^2 + \\beta^2)$。\n    *   **物理常数**：$\\hbar c = 197.3269804\\ \\text{MeV}\\cdot\\text{fm}$，$m_p = 938.2720813\\ \\text{MeV}/c^2$，$m_n = 939.5654133\\ \\text{MeV}/c^2$。\n    *   **模型参数**：Yamaguchi 作用程 $\\beta = 1.4\\ \\text{fm}^{-1}$，无限体积中的氘核结合能 $B_d^{(\\infty)} = 2.224575\\ \\text{MeV}$。\n    *   **导出量**：约化质量 $\\mu = (m_p m_n)/(m_p + m_n)$，结合动量 $\\kappa = \\sqrt{2\\mu B_d^{(\\infty)}/(\\hbar c)^2}$。\n    *   **核心方程**：束缚态条件在无限体积中为 $1 + \\lambda\\, J_{\\infty}(E) = 0$，在边长为 $L$ 的立方盒子中为 $1 + \\lambda\\, J_L(E) = 0$。\n    *   **核函数**：\n        *   $J_{\\infty}(E) = \\int \\frac{d^3 q}{(2\\pi)^3}\\, \\frac{g(\\mathbf{q})^2}{E - \\frac{(\\hbar c)^2 \\mathbf{q}^2}{2\\mu}} = \\frac{1}{2\\pi^2}\\int_{0}^{\\infty} dq\\, \\frac{q^2}{(q^2+\\beta^2)^2}\\frac{1}{E - \\frac{(\\hbar c)^2 q^2}{2\\mu}}$。\n        *   $J_{L}(E) = \\frac{1}{L^3} \\sum_{\\mathbf{n}\\in\\mathbb{Z}^3} \\frac{g((2\\pi/L)\\mathbf{n})^2}{E - \\frac{(\\hbar c)^2}{2\\mu}(\\frac{2\\pi}{L})^2 \\|\\mathbf{n}\\|^2}$。\n    *   **计算约束**：有限体积求和由球形动量截断 $\\|\\mathbf{q}\\| \\le \\Lambda$ 截断，其中 $\\Lambda = 6.0\\ \\text{fm}^{-1}$。\n    *   **任务**：\n        1.  使用在 $E = -B_d^{(\\infty)}$ 处的无限体积条件校准耦合强度 $\\lambda$。\n        2.  对于给定的 $L$ 集合，求解有限体积结合能 $B_d(L) = -E$。\n        3.  计算能量位移 $\\Delta B_d(L) = B_d(L) - B_d^{(\\infty)}$。\n        4.  对于每组 $L$ 值，对 $y(L) = \\ln(\\Delta B_d(L) \\cdot L)$ 与 $x(L) = L$ 进行线性拟合，以求得斜率 $m$。\n        5.  提取拟合的结合动量为 $\\kappa_{\\text{fit}} = -m$。\n    *   **测试用例**：集合 $\\mathcal{A}: L \\in \\{12, 14, 16\\}$ fm；集合 $\\mathcal{B}: L \\in \\{8, 10, 12\\}$ fm；集合 $\\mathcal{C}: L \\in \\{6, 7, 8\\}$ fm。\n    *   **输出**：一个包含理论值 $\\kappa$ 和三个拟合值 $\\kappa_{\\text{fit}}(\\mathcal{A})$、$\\kappa_{\\text{fit}}(\\mathcal{B})$ 和 $\\kappa_{\\text{fit}}(\\mathcal{C})$ 的列表，所有单位均为 $\\text{fm}^{-1}$。\n\n2.  **验证分析**：\n    *   **科学依据**：该问题在非相对论量子力学和有效场论中有坚实的理论基础。Lippmann-Schwinger 方程、可分离势以及对有限体积效应的研究是理论和计算核物理中的标准课题。所提供的方程是在此框架内的正确表述。\n    *   **适定性**：该问题在数学和计算上都是适定的。它提供了所有必需的常数、参数，以及一个清晰、逐步的流程来获得唯一的数值结果。寻找有限体积结合能的任务涉及求解单调函数的根，这保证了唯一解的存在。\n    *   **客观性**：问题以精确、客观的语言陈述，没有歧义或主观论断。\n    *   **一致性检查**：一个潜在问题来自 $\\ln(\\Delta B_d(L) \\cdot L)$ 项，该项要求 $\\Delta B_d(L) = B_d(L) - B_d^{(\\infty)}$ 为正。朴素的物理直觉可能表明，禁闭会降低结合能，使 $\\Delta B_d(L)$ 为负。然而，更详细的分析表明，对于这种特定的（吸引人的 Yamaguchi）势，有限体积中动量空间的离散化导致对于任何给定的能量 $E0$，都有 $J_L(E)  J_{\\infty}(E)$。由于对于 $E0$，$J_L(E)$ 是 $E$ 的单调递减函数，并且束缚态条件是 $J(-B) = -1/\\lambda$，因此可以得出 $-B_d(L)  -B_d^{(\\infty)}$，这意味着 $B_d(L) > B_d^{(\\infty)}$。因此，$\\Delta B_d(L)$ 确实是正的，问题是内部一致的。\n\n3.  **结论**：问题是**有效的**。\n\n### 求解方法论\n\n解决方案将遵循从所提供的理论框架中导出的一系列计算步骤来构建。\n\n**1. 常数和初始计算**\n首先，我们定义所有指定的物理常数和模型参数。\n- $\\hbar c = 197.3269804\\ \\text{MeV}\\cdot\\text{fm}$\n- $m_p = 938.2720813\\ \\text{MeV}/c^2$\n- $m_n = 939.5654133\\ \\text{MeV}/c^2$\n- $B_d^{(\\infty)} = 2.224575\\ \\text{MeV}$\n- $\\beta = 1.4\\ \\text{fm}^{-1}$\n- $\\Lambda = 6.0\\ \\text{fm}^{-1}$\n\n根据这些，我们计算约化质量 $\\mu$ 和理论上的无限体积结合动量 $\\kappa$。\n$$ \\mu = \\frac{m_p m_n}{m_p + m_n} $$\n$$ \\kappa = \\sqrt{\\frac{2\\mu B_d^{(\\infty)}}{(\\hbar c)^2}} $$\n$\\kappa$ 的值将作为我们数值拟合的基准。\n\n**2. 耦合强度 $\\lambda$ 的校准**\n耦合强度 $\\lambda$ 通过要求模型在无限体积中再现实验测得的氘核结合能来确定。这是通过 $T$ 矩阵的极点条件 $1 + \\lambda\\, J_{\\infty}(-B_d^{(\\infty)}) = 0$ 来强制执行的。这给出了：\n$$ \\lambda = -\\frac{1}{J_{\\infty}(-B_d^{(\\infty)})} $$\n为了计算这个值，我们必须首先计算在 $E = -B_d^{(\\infty)}$ 处的积分 $J_{\\infty}(E)$。问题中给出了球坐标下的表达式：\n$$ J_{\\infty}(E) = \\frac{1}{2\\pi^2} \\int_0^{\\infty} dq\\, \\frac{q^2}{(q^2+\\beta^2)^2} \\frac{1}{E - \\frac{(\\hbar c)^2 q^2}{2\\mu}} $$\n其中 $q = \\|\\mathbf{q}\\|$。对于 $E0$，被积函数对所有 $q \\ge 0$ 都是良定义且非奇异的。我们将使用一个稳健的数值积分程序（`scipy.integrate.quad`）来执行这个一维积分。由于 $E0$，项 $E - \\frac{(\\hbar c)^2 q^2}{2\\mu}$ 总是负的，使得积分 $J_{\\infty}(E)$ 为负。因此，$\\lambda$ 将为正，对应于吸引势。\n\n**3. 有限体积结合能计算**\n在边长为 $L$、具有周期性边界条件的立方体积中，连续的动量积分被替换为对允许的动量矢量 $\\mathbf{q}_{\\mathbf{n}} = \\frac{2\\pi}{L}\\mathbf{n}$（其中 $\\mathbf{n} \\in \\mathbb{Z}^3$）的离散求和。核函数 $J_L(E)$ 由下式给出：\n$$ J_{L}(E) = \\frac{1}{L^3} \\sum_{\\mathbf{n}\\in\\mathbb{Z}^3, \\, \\|\\mathbf{q}_{\\mathbf{n}}\\| \\le \\Lambda} \\frac{g(\\mathbf{q}_{\\mathbf{n}})^2}{E - \\frac{(\\hbar c)^2}{2\\mu}\\left(\\frac{2\\pi}{L}\\right)^2 \\|\\mathbf{n}\\|^2} $$\n该求和由截断条件 $\\|\\frac{2\\pi}{L}\\mathbf{n}\\| \\le \\Lambda$ 截断，这等价于 $\\|\\mathbf{n}\\|^2 \\le (\\frac{L\\Lambda}{2\\pi})^2$。该求和通过在此球形边界内迭代整数矢量 $\\mathbf{n}=(n_x, n_y, n_z)$ 来实现。\n\n对于每个给定的盒子尺寸 $L$，有限体积结合能 $B_d(L)$ 通过求解方程 $f(E) = 1 + \\lambda J_L(E) = 0$ 得到能量 $E0$。核函数对能量的导数为 $\\frac{dJ_L}{dE} = -\\frac{1}{L^3} \\sum_{\\mathbf{n}} \\frac{g(\\mathbf{q}_{\\mathbf{n}})^2}{(E - E_{\\mathbf{n}})^2}$，对于 $E0$ 恒为负。这确保了 $f(E)$ 在负能域内是 $E$ 的单调递减函数。当 $E \\to 0^-$ 时，$\\mathbf{n}=\\mathbf{0}$ 的项导致 $J_L(E) \\to -\\infty$，所以 $f(E) \\to -\\infty$。当 $E \\to -\\infty$ 时，$J_L(E) \\to 0$，所以 $f(E) \\to 1$。因此，在 $E0$ 域内保证存在唯一的根 $E = -B_d(L)$。我们使用像 `scipy.optimize.brentq` 这样的数值求解器来找到这个根，该方法需要一个函数变号的区间，例如 $[-10, -0.1]$ MeV。\n\n**4. 通过线性回归提取 $\\kappa_{\\text{fit}}$**\n对于大的 $L$，有限体积能量位移的领头阶渐近行为预期是指数形式的：\n$$ \\Delta B_d(L) = B_d(L) - B_d^{(\\infty)} \\approx C \\frac{e^{-\\kappa L}}{L} $$\n其中 $C$ 是一个常数。这可以通过取自然对数重写：\n$$ \\ln(\\Delta B_d(L) \\cdot L) \\approx \\ln(C) - \\kappa L $$\n这表明 $y(L) = \\ln(\\Delta B_d(L) \\cdot L)$ 与 $x(L) = L$ 之间存在线性关系，斜率为 $-\\kappa$。\n对于每组给定的 $L$ 值（$\\mathcal{A}$、$\\mathcal{B}$、$\\mathcal{C}$），我们首先计算相应的有限体积结合能 $B_d(L)$。然后，我们构建数据点 $(x_i, y_i) = (L_i, \\ln((B_d(L_i) - B_d^{(\\infty)}) \\cdot L_i))$。对这些点进行线性最小二乘拟合，以找到最佳拟合直线 $y = m x + c$。期望的参数 $\\kappa_{\\text{fit}}$ 则由斜率的负值给出：\n$$ \\kappa_{\\text{fit}} = -m $$\n对所有三组 $L$ 值重复此过程。最终结果是一个包含理论推导的 $\\kappa$ 和三个数值拟合值 $\\kappa_{\\text{fit}}(\\mathcal{A})$、$\\kappa_{\\text{fit}}(\\mathcal{B})$ 和 $\\kappa_{\\text{fit}}(\\mathcal{C})$ 的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the deuteron finite-volume binding energy problem as specified.\n    \"\"\"\n    # Physical constants and parameters\n    HBARC = 197.3269804  # MeV * fm\n    M_P = 938.2720813    # MeV/c^2\n    M_N = 939.5654133    # MeV/c^2\n    BETA = 1.4           # fm^-1\n    B_D_INF = 2.224575   # MeV\n    LAMBDA_CUTOFF = 6.0  # fm^-1\n\n    # Derived constants\n    MU = (M_P * M_N) / (M_P + M_N)\n    TWO_MU_OVER_HBARC_SQ = (2.0 * MU) / (HBARC**2) # fm^-2 / MeV\n\n    # --- Step 1: Calculate theoretical kappa ---\n    kappa_theory = np.sqrt(TWO_MU_OVER_HBARC_SQ * B_D_INF)\n    \n    # --- Step 2: Calibrate lambda from infinite-volume condition ---\n    \n    def integrand_J_infty(q, E):\n        \"\"\"Integrand for the J_infty integral.\"\"\"\n        # Using the formulation J = 1/(2pi^2) * int(...) dq\n        # The equation for J_infty in the problem is per d^3q/(2pi)^3\n        # J_inf = 1/(2pi^2) integral_0^inf dq q^2 * g(q)^2 / (E-T(q))\n        # This matches the provided spherical coordinate version.\n        g_q_sq = (1.0 / (q**2 + BETA**2))**2\n        T_q = q**2 / TWO_MU_OVER_HBARC_SQ\n        return (1.0 / (2.0 * np.pi**2)) * q**2 * g_q_sq / (E - T_q)\n\n    # Calculate J_infty at E = -B_d_inf\n    val_J_infty, _ = quad(integrand_J_infty, 0, np.inf, args=(-B_D_INF,), epsabs=1e-12, epsrel=1e-12)\n    \n    # Calculate lambda\n    lambda_coupling = -1.0 / val_J_infty\n\n    # --- Step 3: Functions for finite-volume calculation ---\n\n    # Store J_L results to avoid re-computation\n    j_l_cache = {}\n\n    def calc_J_L(E, L):\n        \"\"\"Calculates the finite-volume sum J_L(E).\"\"\"\n        if (E, L) in j_l_cache:\n            return j_l_cache[(E, L)]\n\n        n_sq_max_val = (L * LAMBDA_CUTOFF / (2.0 * np.pi))**2\n        n_max = int(np.floor(np.sqrt(n_sq_max_val)))\n        \n        total_sum = 0.0\n        \n        # Precompute constants for the loop\n        q_sq_factor = (2.0 * np.pi / L)**2\n        E_kin_factor = q_sq_factor / TWO_MU_OVER_HBARC_SQ\n\n        for nx in range(-n_max, n_max + 1):\n            for ny in range(-n_max, n_max + 1):\n                for nz in range(-n_max, n_max + 1):\n                    n_sq = float(nx**2 + ny**2 + nz**2)\n                    \n                    if n_sq > n_sq_max_val:\n                        continue\n                        \n                    q_sq = n_sq * q_sq_factor\n                    g_q_sq = (1.0 / (q_sq + BETA**2))**2\n                    \n                    E_kin = n_sq * E_kin_factor\n                    \n                    denominator = E - E_kin\n                    # The n=0 contribution has a pole at E=0.\n                    # This check is for robustness, though brentq should avoid E=0.\n                    if abs(denominator)  1e-15:\n                        total_sum += np.inf # Should signal issues\n                    else:\n                        total_sum += g_q_sq / denominator\n                        \n        result = total_sum / L**3\n        j_l_cache[(E, L)] = result\n        return result\n\n    def root_function(E, L):\n        \"\"\"Function whose root E gives the finite-volume energy.\"\"\"\n        return 1.0 + lambda_coupling * calc_J_L(E, L)\n\n    # --- Step 4: Calculate B_d(L) and fit for kappa ---\n\n    def calculate_kappa_fit(L_values):\n        \"\"\"\n        Calculates B_d(L) for a list of L values and performs the linear fit\n        to extract kappa_fit.\n        \"\"\"\n        delta_B_vals = []\n        \n        for L in L_values:\n            # Find the root E for B_d(L) = -E\n            # Bracket [-10, -0.1] safely encloses the root away from the E=0 pole.\n            try:\n                E_L = brentq(root_function, -10.0, -0.1, args=(L,), xtol=1e-12, rtol=1e-12)\n            except ValueError:\n                # This would happen if the function doesn't change sign in the bracket\n                print(f\"Error: Root not bracketed for L={L}.\")\n                return np.nan\n            \n            Bd_L = -E_L\n            delta_B = Bd_L - B_D_INF\n            delta_B_vals.append(delta_B)\n\n        y_fit = np.log(np.array(delta_B_vals) * np.array(L_values))\n        x_fit = np.array(L_values)\n        \n        # Perform linear fit: y = m*x + c\n        # np.polyfit returns [m, c]\n        slope, _ = np.polyfit(x_fit, y_fit, 1)\n        \n        kappa_fit = -slope\n        return kappa_fit\n\n    # Define test sets\n    test_sets = {\n        'A': [12.0, 14.0, 16.0],\n        'B': [8.0, 10.0, 12.0],\n        'C': [6.0, 7.0, 8.0]\n    }\n    \n    results = [kappa_theory]\n    for key in ['A', 'B', 'C']:\n        L_vals = test_sets[key]\n        kappa_fit = calculate_kappa_fit(L_vals)\n        results.append(kappa_fit)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.8f}', results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现代物理学的一项核心任务是通过约束理论的自由参数并将由此产生的不确定性进行量化，从而将理论模型与实验现实联系起来。本练习  介绍了强大的贝叶斯推断框架，用于校准一个简化的手征有效场论模型的低能常数。你将学习如何将先验知识与实验数据相结合，以获得模型参数的后验分布，然后将这种不确定性传播到对其他氘核性质的预测中，这是稳健科学建模的基石。",
            "id": "3582583",
            "problem": "您将为针对氘核性质的中子-质子系统的手征有效场论（EFT）低能常数，实现线性化的贝叶斯校准和不确定性传播。从贝叶斯定理和高斯线性模型假设出发，获得模型参数的后验分布，然后将该后验传播到氘核的可观测量。您的程序必须是一个完整的、可运行的程序，无需任何用户输入即可产生所需的输出。\n\n未知参数矢量是无量纲低能常数对 $\\boldsymbol{\\theta} = [c_0, c_2]^{\\mathsf{T}}$。一个一阶线性化代理模型（局部模拟器）将 $\\boldsymbol{\\theta}$ 映射到从中子-质子相移分析中提取的低能数据以及氘核的可观测量。数据矢量由以飞米为单位的三重态中子-质子散射长度 $a_t$、以飞米为单位的三重态有效力程 $r_t$ 和以兆电子伏特为单位的氘核结合能 $B_d$ 组成。测量模型为\n$$\n\\mathbf{y} = \\mathbf{H}\\,\\boldsymbol{\\theta} + \\mathbf{b} + \\boldsymbol{\\varepsilon},\n$$\n其中高斯噪声 $\\boldsymbol{\\varepsilon}$ 的均值为零，协方差矩阵为 $\\mathbf{R}$。使用以下与公认的经验测定值一致的数值：\n- 数据矢量为\n$$\n\\mathbf{y}_{\\text{exp}} = \\begin{bmatrix} a_t \\\\ r_t \\\\ B_d \\end{bmatrix}\n= \\begin{bmatrix} 5.419 \\\\ 1.753 \\\\ 2.224575 \\end{bmatrix},\n$$\n其中 $a_t$ 和 $r_t$ 的单位是 $\\mathrm{fm}$，$B_d$ 的单位是 $\\mathrm{MeV}$。\n- 线性响应矩阵和基线矢量为\n$$\n\\mathbf{H} = \\begin{bmatrix}\n0.6  0.12 \\\\\n0.05  0.28 \\\\\n0.25  0.08\n\\end{bmatrix}, \\quad\n\\mathbf{b} = \\begin{bmatrix}\n5.419 \\\\ 1.753 \\\\ 2.224575\n\\end{bmatrix}.\n$$\n- 名义数据协方差是对角的，\n$$\n\\mathbf{R} = \\mathrm{diag}\\left(\\sigma_a^2, \\sigma_r^2, \\sigma_B^2\\right),\n$$\n标准差为 $\\sigma_a = 0.01\\,\\mathrm{fm}$、$\\sigma_r = 0.005\\,\\mathrm{fm}$ 和 $\\sigma_B = 0.00001\\,\\mathrm{MeV}$。\n\n我们感兴趣的氘核可观测量是单位为平方飞米的四极矩 $Q_d$、单位为核磁子的磁偶极矩 $\\mu_d$ 和单位为飞米的电荷半径 $r_d$。使用一个线性化代理映射\n$$\n\\mathbf{z} = \\mathbf{L}\\,\\boldsymbol{\\theta} + \\mathbf{b}_z,\n$$\n其中\n$$\n\\mathbf{L} = \\begin{bmatrix}\n0.006  0.020 \\\\\n0.001  -0.010 \\\\\n-0.050  -0.020\n\\end{bmatrix}, \\quad\n\\mathbf{b}_z = \\begin{bmatrix}\n0.2859 \\\\\n0.857438 \\\\\n2.127\n\\end{bmatrix},\n$$\n其中 $Q_d$ 的单位是 $\\mathrm{fm}^2$，$\\mu_d$ 的单位是核磁子，$r_d$ 的单位是 $\\mathrm{fm}$。\n\n假设 $\\boldsymbol{\\theta}$ 服从均值为 $\\mathbf{m}_0$、协方差为 $\\mathbf{S}_0$ 的高斯先验分布。在线性-高斯假设下，使用贝叶斯定理获得给定数据的 $\\boldsymbol{\\theta}$ 的后验分布，然后将该后验传播到 $\\mathbf{z}$ 的预测分布。\n\n数值单位和输出：\n- 所有输入均以上述单位提供，并且必须被一致地处理。\n- 对于每个指定的测试用例，您的程序必须报告 $Q_d$、$\\mu_d$ 和 $r_d$ 各自的后验预测均值和标准差。\n- 以 $\\mathrm{fm}^2$ 为单位表示 $Q_d$ 的均值和标准差，以核磁子为单位表示 $\\mu_d$ 的均值和标准差，以 $\\mathrm{fm}$ 为单位表示 $r_d$ 的均值和标准差。\n- 将报告的每个数字四舍五入到恰好 $6$ 位小数。\n\n测试套件规范：\n实现三个测试用例，以探究不同的先验-数据机制。对于每个用例，使用上面给出的相同的 $\\mathbf{H}$、$\\mathbf{b}$、$\\mathbf{L}$、$\\mathbf{b}_z$ 和 $\\mathbf{y}_{\\text{exp}}$，但按如下方式改变先验和数据协方差缩放。\n- 用例 1（数据主导，中性先验）：\n  - 先验均值 $\\mathbf{m}_0 = [0, 0]^{\\mathsf{T}}$。\n  - 先验协方差 $\\mathbf{S}_0 = \\mathrm{diag}([0.5^2, 0.5^2])$。\n  - 数据协方差缩放因子 $s_R = 1$，意味着按给定值使用 $\\mathbf{R}$。\n- 用例 2（信息丰富的非零中心先验）：\n  - 先验均值 $\\mathbf{m}_0 = [0.5, -0.3]^{\\mathsf{T}}$。\n  - 先验协方差 $\\mathbf{S}_0 = \\mathrm{diag}([0.2^2, 0.2^2])$。\n  - 数据协方差缩放因子 $s_R = 1$。\n- 用例 3（通过增大数据不确定性实现先验主导）：\n  - 先验均值 $\\mathbf{m}_0 = [0, 0]^{\\mathsf{T}}$。\n  - 先验协方差 $\\mathbf{S}_0 = \\mathrm{diag}([1.0^2, 1.0^2])$。\n  - 数据协方差缩放因子 $s_R = 100$，意味着用 $s_R \\mathbf{R}$ 替换 $\\mathbf{R}$。\n\n对于每个用例：\n1. 计算给定指定先验和数据模型的 $\\boldsymbol{\\theta}$ 的后验均值和协方差。\n2. 通过线性映射传播后验分布，计算 $\\mathbf{z}$ 的预测均值和协方差。\n3. 提取 $Q_d$、$\\mu_d$ 和 $r_d$ 的预测均值和标准差（预测协方差对角线的平方根），并以规定单位表示。\n4. 将每个值四舍五入到恰好 $6$ 位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。按顺序连接三个用例的结果。对于每个用例，按以下顺序列出六个数字\n$$\n[ \\overline{Q}_d, \\sigma(Q_d), \\overline{\\mu}_d, \\sigma(\\mu_d), \\overline{r}_d, \\sigma(r_d) ].\n$$\n因此，完整的输出是一个包含 $18$ 个数字的扁平列表：\n$$\n[\\text{用例 1 的六个数字}, \\text{用例 2 的六个数字}, \\text{用例 3 的六个数字}],\n$$\n每个数字都四舍五入到 $6$ 位小数，没有附加文本。",
            "solution": "该问题要求为源自手征有效场论（EFT）的线性化模型实现一个贝叶斯校准和不确定性传播程序。该模型的参数是无量纲的低能常数（LECs）$\\boldsymbol{\\theta} = [c_0, c_2]^{\\mathsf{T}}$。该过程涉及使用贝叶斯定理根据实验数据更新关于 $\\boldsymbol{\\theta}$ 的知识，然后将得到的后验不确定性传播到对其他氘核可观测量的预测中。\n\n### 1. 贝叶斯框架构建\n\n该问题是在贝叶斯推断的框架内提出的。其核心是贝叶斯定理，该定理将给定实验数据 $\\mathbf{y}_{\\text{exp}}$ 时参数 $\\boldsymbol{\\theta}$ 的后验概率与数据的似然和参数的先验概率联系起来：\n$$\np(\\boldsymbol{\\theta} | \\mathbf{y}_{\\text{exp}}) \\propto p(\\mathbf{y}_{\\text{exp}} | \\boldsymbol{\\theta}) \\, p(\\boldsymbol{\\theta})\n$$\n\n#### 1.1. 先验分布\n关于参数 $\\boldsymbol{\\theta}$ 的先验知识被指定为均值为 $\\mathbf{m}_0$、协方差矩阵为 $\\mathbf{S}_0$ 的多元高斯分布。其概率密度函数为：\n$$\np(\\boldsymbol{\\theta}) = \\mathcal{N}(\\boldsymbol{\\theta} | \\mathbf{m}_0, \\mathbf{S}_0)\n$$\n对于每个测试用例，都提供了 $\\mathbf{m}_0$ 和 $\\mathbf{S}_0$ 的具体值。\n\n#### 1.2. 似然函数\n似然函数 $p(\\mathbf{y}_{\\text{exp}} | \\boldsymbol{\\theta})$ 量化了在给定一组参数 $\\boldsymbol{\\theta}$ 的情况下观测到实验数据 $\\mathbf{y}_{\\text{exp}}$ 的概率。它源自测量模型：\n$$\n\\mathbf{y} = \\mathbf{H}\\,\\boldsymbol{\\theta} + \\mathbf{b} + \\boldsymbol{\\varepsilon}\n$$\n在这里，$\\mathbf{y}$ 是校准数据的模型预测矢量，$\\mathbf{H}$ 是线性响应矩阵，$\\mathbf{b}$ 是基线矢量，$\\boldsymbol{\\varepsilon}$ 代表测量和模型不确定性，假设为均值为零、协方差为 $\\mathbf{R}$ 的高斯随机变量，即 $\\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{R})$。这种结构意味着给定 $\\boldsymbol{\\theta}$ 的数据 $\\mathbf{y}$ 的条件分布也是高斯的：\n$$\n\\mathbf{y} | \\boldsymbol{\\theta} \\sim \\mathcal{N}(\\mathbf{H}\\,\\boldsymbol{\\theta} + \\mathbf{b}, \\mathbf{R})\n$$\n因此，似然函数是通过在观测数据点 $\\mathbf{y}_{\\text{exp}}$ 处评估此密度得到的。\n\n### 2. 参数的后验分布\n\n鉴于先验和似然都是高斯分布，它们的乘积，即后验分布 $p(\\boldsymbol{\\theta} | \\mathbf{y}_{\\text{exp}})$，也是高斯分布。这是贝叶斯统计中共轭族的一个标准结果。我们将后验分布表示为：\n$$\np(\\boldsymbol{\\theta} | \\mathbf{y}_{\\text{exp}}) = \\mathcal{N}(\\boldsymbol{\\theta} | \\mathbf{m}_1, \\mathbf{S}_1)\n$$\n后验均值 $\\mathbf{m}_1$ 和协方差 $\\mathbf{S}_1$ 是通过结合先验和似然的信息来确定的。后验精度（协方差的逆）是先验精度和基于数据的精度的和：\n$$\n\\mathbf{S}_1^{-1} = \\mathbf{S}_0^{-1} + \\mathbf{H}^{\\mathsf{T}}\\mathbf{R}^{-1}\\mathbf{H}\n$$\n这给出了后验协方差矩阵：\n$$\n\\mathbf{S}_1 = (\\mathbf{S}_0^{-1} + \\mathbf{H}^{\\mathsf{T}}\\mathbf{R}^{-1}\\mathbf{H})^{-1}\n$$\n后验均值 $\\mathbf{m}_1$ 是一个精度加权的平均值：\n$$\n\\mathbf{m}_1 = \\mathbf{S}_1 \\left( \\mathbf{S}_0^{-1}\\mathbf{m}_0 + \\mathbf{H}^{\\mathsf{T}}\\mathbf{R}^{-1}(\\mathbf{y}_{\\text{exp}} - \\mathbf{b}) \\right)\n$$\n问题规定实验数据矢量 $\\mathbf{y}_{\\text{exp}}$ 在数值上与基线矢量 $\\mathbf{b}$ 相同。这导致了一个显著的简化，因为项 $(\\mathbf{y}_{\\text{exp}} - \\mathbf{b})$ 变成了零矢量。因此，后验均值的表达式简化为：\n$$\n\\mathbf{m}_1 = \\mathbf{S}_1 (\\mathbf{S}_0^{-1}\\mathbf{m}_0)\n$$\n这个简化形式表明，后验均值是先验均值的线性变换，其中变换矩阵取决于先验和似然的相对精度。\n\n### 3. 可观测量的预测分布\n\n最后一步是使用 $\\boldsymbol{\\theta}$ 的后验分布来对一组新的可观测量 $\\mathbf{z} = [Q_d, \\mu_d, r_d]^{\\mathsf{T}}$ 进行预测。这些可观测量也通过一个线性模型与参数相关：\n$$\n\\mathbf{z} = \\mathbf{L}\\,\\boldsymbol{\\theta} + \\mathbf{b}_z\n$$\n$\\mathbf{z}$ 的预测分布，以观测数据 $\\mathbf{y}_{\\text{exp}}$ 为条件，是通过将 $\\boldsymbol{\\theta}$ 的后验分布通过这个线性变换传播得到的。一个高斯随机变量（$\\boldsymbol{\\theta}$）经过线性函数的变换会得到另一个高斯随机变量（$\\mathbf{z}$）。因此，预测分布为 $p(\\mathbf{z} | \\mathbf{y}_{\\text{exp}}) = \\mathcal{N}(\\mathbf{z} | \\mathbf{m}_z, \\mathbf{S}_z)$。\n\n预测分布的均值 $\\mathbf{m}_z$ 是 $\\mathbf{z}$ 关于 $\\boldsymbol{\\theta}$ 后验分布的期望：\n$$\n\\mathbf{m}_z = E_{\\boldsymbol{\\theta} | \\mathbf{y}_{\\text{exp}}}[\\mathbf{z}] = E[\\mathbf{L}\\boldsymbol{\\theta} + \\mathbf{b}_z] = \\mathbf{L}E[\\boldsymbol{\\theta}] + \\mathbf{b}_z = \\mathbf{L}\\mathbf{m}_1 + \\mathbf{b}_z\n$$\n预测分布的协方差 $\\mathbf{S}_z$ 是通过将线性变换的误差传播定律应用于后验协方差 $\\mathbf{S}_1$ 得到的：\n$$\n\\mathbf{S}_z = \\text{Cov}_{\\boldsymbol{\\theta} | \\mathbf{y}_{\\text{exp}}}[\\mathbf{z}] = \\text{Cov}[\\mathbf{L}\\boldsymbol{\\theta} + \\mathbf{b}_z] = \\mathbf{L}\\,\\text{Cov}[\\boldsymbol{\\theta}]\\,\\mathbf{L}^{\\mathsf{T}} = \\mathbf{L}\\mathbf{S}_1\\mathbf{L}^{\\mathsf{T}}\n$$\n我们感兴趣的量是 $\\mathbf{z}$ 的每个分量的预测均值和标准差。第 $i$ 个可观测量的预测均值是 $(\\mathbf{m}_z)_i$，其标准差是 $\\sigma(z_i) = \\sqrt{(\\mathbf{S}_z)_{ii}}$。\n\n### 4. 计算算法\n\n数值解是通过对三个指定的测试用例中的每一个执行以下算法来实现的：\n1.  定义常量矩阵和矢量：$\\mathbf{H}$、$\\mathbf{b}$、$\\mathbf{y}_{\\text{exp}}$、$\\mathbf{L}$、$\\mathbf{b}_z$。\n2.  对于每个测试用例，设置先验均值 $\\mathbf{m}_0$，构造对角先验协方差矩阵 $\\mathbf{S}_0$，并确定数据协方差缩放因子 $s_R$。\n3.  计算数据协方差矩阵 $\\mathbf{R} = s_R \\cdot \\mathrm{diag}(\\sigma_a^2, \\sigma_r^2, \\sigma_B^2)$。\n4.  计算矩阵的逆 $\\mathbf{S}_0^{-1}$ 和 $\\mathbf{R}^{-1}$。由于这些矩阵是对角的，通过取每个对角元素的倒数可以高效地找到它们的逆。\n5.  计算后验协方差矩阵 $\\mathbf{S}_1 = (\\mathbf{S}_0^{-1} + \\mathbf{H}^{\\mathsf{T}}\\mathbf{R}^{-1}\\mathbf{H})^{-1}$。\n6.  计算后验均值矢量 $\\mathbf{m}_1 = \\mathbf{S}_1 (\\mathbf{S}_0^{-1}\\mathbf{m}_0)$。\n7.  计算预测均值矢量 $\\mathbf{m}_z = \\mathbf{L}\\mathbf{m}_1 + \\mathbf{b}_z$。\n8.  计算预测协方差矩阵 $\\mathbf{S}_z = \\mathbf{L}\\mathbf{S}_1\\mathbf{L}^{\\mathsf{T}}$。\n9.  从 $\\mathbf{m}_z$ 的元素中提取预测均值，从 $\\mathbf{S}_z$ 的对角元素的平方根中提取预测标准差。\n10. 将得到的六个值（$Q_d$、$\\mu_d$ 和 $r_d$ 的均值和标准差）格式化，四舍五入到 $6$ 位小数，并将它们附加到列表中以供最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a linearized Bayesian calibration for chiral EFT LECs.\n    \"\"\"\n    # --- Define constants from the problem statement ---\n    # Linear response matrix for calibration data\n    H = np.array([\n        [0.6, 0.12],\n        [0.05, 0.28],\n        [0.25, 0.08]\n    ])\n    \n    # Baseline vector for calibration data (equal to y_exp)\n    b = np.array([5.419, 1.753, 2.224575])\n    y_exp = b # Experimental data vector\n    \n    # Standard deviations for the calibration data\n    sigma_a = 0.01  # fm\n    sigma_r = 0.005  # fm\n    sigma_B = 0.00001  # MeV\n    \n    # Base data covariance matrix (diagonal)\n    R_base = np.diag([sigma_a**2, sigma_r**2, sigma_B**2])\n    \n    # Linear response matrix for predicted observables\n    L = np.array([\n        [0.006, 0.020],   # Q_d\n        [0.001, -0.010],  # mu_d\n        [-0.050, -0.020]  # r_d\n    ])\n    \n    # Baseline vector for predicted observables\n    b_z = np.array([0.2859, 0.857438, 2.127])\n\n    # --- Define the test cases ---\n    test_cases = [\n        # Case 1: data-dominated, neutral prior\n        {\n            \"m0\": np.array([0.0, 0.0]),\n            \"S0_diag\": np.array([0.5**2, 0.5**2]),\n            \"sR\": 1.0\n        },\n        # Case 2: informative prior shifted from zero\n        {\n            \"m0\": np.array([0.5, -0.3]),\n            \"S0_diag\": np.array([0.2**2, 0.2**2]),\n            \"sR\": 1.0\n        },\n        # Case 3: prior-dominated via inflated data uncertainty\n        {\n            \"m0\": np.array([0.0, 0.0]),\n            \"S0_diag\": np.array([1.0**2, 1.0**2]),\n            \"sR\": 100.0\n        }\n    ]\n\n    all_results = []\n    \n    # --- Process each test case ---\n    for case in test_cases:\n        m0 = case[\"m0\"]\n        S0 = np.diag(case[\"S0_diag\"])\n        sR = case[\"sR\"]\n        \n        # 1. Construct data covariance matrix for this case\n        R = sR * R_base\n        \n        # 2. Compute inverses (numerically stable for diagonal matrices)\n        S0_inv = np.diag(1.0 / case[\"S0_diag\"])\n        R_inv = np.diag(1.0 / np.diag(R))\n        \n        # 3. Calculate posterior distribution for theta\n        # Posterior covariance S1 = (S0^-1 + H^T * R^-1 * H)^-1\n        posterior_cov_inv = S0_inv + H.T @ R_inv @ H\n        posterior_cov = np.linalg.inv(posterior_cov_inv)\n        \n        # Posterior mean m1 = S1 * (S0^-1 * m0 + H^T * R^-1 * (y_exp - b))\n        # Since y_exp = b, the second term in the parenthesis is zero.\n        posterior_mean = posterior_cov @ (S0_inv @ m0)\n\n        # 4. Propagate to predictive distribution for z\n        # Predictive mean mz = L * m1 + bz\n        predictive_mean = L @ posterior_mean + b_z\n        \n        # Predictive covariance Sz = L * S1 * L^T\n        predictive_cov = L @ posterior_cov @ L.T\n        \n        # 5. Extract means and standard deviations\n        predictive_stds = np.sqrt(np.diag(predictive_cov))\n        \n        # 6. Store results for this case\n        # Order: mean_Qd, std_Qd, mean_mu_d, std_mu_d, mean_r_d, std_r_d\n        results_for_case = []\n        for i in range(3):\n            results_for_case.append(predictive_mean[i])\n            results_for_case.append(predictive_stds[i])\n        \n        all_results.extend(results_for_case)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{num:.6f}\" for num in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}