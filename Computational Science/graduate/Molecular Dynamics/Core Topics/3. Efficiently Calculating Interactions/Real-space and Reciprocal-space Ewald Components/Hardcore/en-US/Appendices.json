{
    "hands_on_practices": [
        {
            "introduction": "The first step in mastering the Ewald summation is to implement the force calculation from first principles. This exercise guides you through translating the Ewald decomposition equations for real- and reciprocal-space into a working computational algorithm. By testing for boundary artifacts and verifying translational invariance, you will build a robust implementation and gain a concrete understanding of how Ewald summation correctly handles long-range forces in periodic systems. ",
            "id": "2390997",
            "problem": "You will implement a three-dimensional periodic electrostatics computation using Ewald summation to evaluate forces on point charges located near the edges of a cubic simulation box, and verify that the results are free of boundary artifacts. You must work from first principles starting at Coulomb’s law and the definition of periodic boundary conditions, and derive a computational algorithm that splits the interactions into a short-range real-space contribution and a long-range reciprocal-space contribution via a smooth screening procedure. You must assume conducting (tin-foil) boundary conditions. All calculations will use reduced, dimensionless units where the Coulomb prefactor is unity, that is, $1/(4\\pi\\epsilon_0) = 1$, and no physical unit conversion is required. There are no angles to report. All numerical answers must be printed as raw decimal numbers without any unit.\n\nStarting principles and definitions:\n- The system is a cubic box of side length $L$ with three-dimensional periodic boundary conditions (PBC). For any particle at position $\\mathbf{r}_i \\in [0,L)^3$ and any distinct particle at position $\\mathbf{r}_j \\in [0,L)^3$, interactions include all lattice images displaced by $\\mathbf{n}L$ with $\\mathbf{n} \\in \\mathbb{Z}^3$.\n- The electrostatic potential for point charges is governed by Coulomb’s law, and the total energy in a periodic system is conditionally convergent unless the total charge is zero. You must restrict to net-neutral charge configurations, $\\sum_i q_i = 0$.\n- The Ewald approach introduces a smooth Gaussian screening of width controlled by a parameter $\\alpha > 0$ to split the interaction into a rapidly decaying real-space sum over near images and a complementary reciprocal-space sum over wave vectors $\\mathbf{k} = \\frac{2\\pi}{L} \\mathbf{m}$ with $\\mathbf{m} \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$, omitting $\\mathbf{k} = \\mathbf{0}$. The real-space sum is truncated at a radius $r_\\mathrm{cut} > 0$, and the reciprocal-space sum is truncated by limiting the integer vector components to $|m_x|,|m_y|,|m_z| \\le k_\\mathrm{max}$.\n\nYour task:\n- Derive from the above principles an explicit and numerically stable algorithm to compute the electrostatic force $\\mathbf{F}_i$ on each particle $i$ using an Ewald sum, including the real-space and reciprocal-space contributions and the self-interaction correction. Use conducting boundary conditions so that no additional surface term is included. The algorithm must respect periodic boundary conditions exactly.\n- Implement the algorithm in a program that evaluates the following test suite. All positions are given in the interval $[0,L)$ and all quantities are dimensionless. Use the same cubic box side length $L = 10.0$ for all tests. Use the complementary error function where needed. Let $\\pi$ be the usual mathematical constant.\n\nGlobal Ewald parameters for the baseline evaluation:\n- Use $\\alpha = 0.35$, $r_\\mathrm{cut} = 4.5$, and $k_\\mathrm{max} = 6$ for the baseline computations.\n- For the alternate-parameter test, use $\\alpha' = 0.28$, $r_\\mathrm{cut}' = 4.5$, and $k_\\mathrm{max}' = 8$.\n\nTest systems:\n1. System $\\mathcal{S}_\\mathrm{edge}$ (two opposite charges near the edge across the boundary):\n   - Charges: $q_1 = +1.0$, $q_2 = -1.0$.\n   - Positions: $\\mathbf{r}_1 = (9.8, 5.0, 5.0)$, $\\mathbf{r}_2 = (0.2, 5.0, 5.0)$.\n2. System $\\mathcal{S}_\\mathrm{center}$ (same charges, same minimum-image separation, centered away from the edge):\n   - Charges: $q_1 = +1.0$, $q_2 = -1.0$.\n   - Positions: $\\mathbf{r}_1 = (0.2, 5.0, 5.0)$, $\\mathbf{r}_2 = (0.6, 5.0, 5.0)$.\n3. Translation vector for invariance test: $\\mathbf{t} = (3.7, 0.0, -1.1)$, applied via $\\mathbf{r}_i \\mapsto (\\mathbf{r}_i + \\mathbf{t}) \\bmod L$ componentwise.\n\nQuantities to compute:\n- Let $\\mathbf{F}^{(\\mathrm{edge})}$ denote the forces for system $\\mathcal{S}_\\mathrm{edge}$ computed with $(\\alpha, r_\\mathrm{cut}, k_\\mathrm{max})$.\n- Let $\\mathbf{F}^{(\\mathrm{center})}$ denote the forces for system $\\mathcal{S}_\\mathrm{center}$ with $(\\alpha, r_\\mathrm{cut}, k_\\mathrm{max})$.\n- Let $\\mathbf{F}^{(\\mathrm{trans})}$ denote the forces for system $\\mathcal{S}_\\mathrm{edge}$ after applying the translation $\\mathbf{t}$ and wrapping positions back into the box, computed with $(\\alpha, r_\\mathrm{cut}, k_\\mathrm{max})$.\n- Let $\\mathbf{F}^{(\\mathrm{alt})}$ denote the forces for system $\\mathcal{S}_\\mathrm{edge}$ computed with the alternate parameters $(\\alpha', r_\\mathrm{cut}', k_\\mathrm{max}')$.\n\nFrom these, compute the following four scalar diagnostics:\n- $D_1$: the maximum absolute componentwise difference between $\\mathbf{F}^{(\\mathrm{edge})}$ and $\\mathbf{F}^{(\\mathrm{center})}$, that is, $D_1 = \\max_{i\\in\\{1,2\\}, a\\in\\{x,y,z\\}} \\left|F^{(\\mathrm{edge})}_{i,a} - F^{(\\mathrm{center})}_{i,a}\\right|$.\n- $D_2$: the Euclidean norm of the net force vector in system $\\mathcal{S}_\\mathrm{edge}$, summed over both particles, $D_2 = \\left\\|\\sum_{i=1}^2 \\mathbf{F}^{(\\mathrm{edge})}_i \\right\\|_2$.\n- $D_3$: the maximum absolute componentwise difference between $\\mathbf{F}^{(\\mathrm{edge})}$ and $\\mathbf{F}^{(\\mathrm{trans})}$, $D_3 = \\max_{i\\in\\{1,2\\}, a\\in\\{x,y,z\\}} \\left|F^{(\\mathrm{edge})}_{i,a} - F^{(\\mathrm{trans})}_{i,a}\\right|$.\n- $D_4$: the maximum absolute componentwise difference between $\\mathbf{F}^{(\\mathrm{edge})}$ computed with the baseline parameters and the alternate parameters, $D_4 = \\max_{i\\in\\{1,2\\}, a\\in\\{x,y,z\\}} \\left|F^{(\\mathrm{edge})}_{i,a} - F^{(\\mathrm{alt})}_{i,a}\\right|$.\n\nInterpretation guidelines:\n- Small values of $D_1$ confirm that placing charges near the boundary yields the same forces as an equivalent centered configuration, indicating no boundary artifacts.\n- A small value of $D_2$ confirms that the total force vanishes for a neutral system under conducting boundary conditions, as required by translational invariance.\n- A small value of $D_3$ confirms invariance of the forces under global translation and periodic wrapping.\n- A small value of $D_4$ confirms that the physical result is independent of the arbitrary splitting parameter within numerical truncation error.\n\nFinal output format:\n- Your program must print a single line containing the four results as a comma-separated list enclosed in square brackets, in the order $[D_1, D_2, D_3, D_4]$. For example, a valid output format is $[0.0001,2.3e-06,0.0,1.2e-05]$.\n\nConstraints and notes:\n- You must implement the Ewald force computation directly. Do not call any black-box electrostatics solvers. You may use standard numerical libraries for basic functions such as exponentials and the complementary error function.\n- Use only net-neutral systems; all provided tests satisfy $\\sum_i q_i = 0$.\n- Ensure numerical stability and reasonable convergence with the specified truncations $(r_\\mathrm{cut}, k_\\mathrm{max})$.",
            "solution": "We base the computation on Coulomb’s law and the definition of periodic boundary conditions, then derive the Ewald decomposition to obtain a numerically convergent algorithm for the forces. All symbols in the derivation refer to reduced, dimensionless quantities with $1/(4\\pi\\epsilon_0) = 1$.\n\nFoundational principles:\n- Coulomb’s law gives the pair potential between charges $q_i$ and $q_j$ as $\\phi(\\mathbf{r}) = q_j / \\|\\mathbf{r}\\|$, where $\\mathbf{r} = \\mathbf{r}_i - \\mathbf{r}_j$.\n- In a periodic cubic box of side $L$, the interaction sums over all lattice images, which is only conditionally convergent. Ewald’s method regularizes this by introducing a Gaussian screening density that splits the interaction into rapidly convergent real-space and reciprocal-space series.\n\nEwald splitting:\nWe add and subtract a neutralizing Gaussian of width governed by $\\alpha > 0$. The potential from a screened point charge decomposes into a short-range contribution that decays like the complementary error function, and a long-range contribution expressible via Fourier components. For a neutral system, the $\\mathbf{k} = \\mathbf{0}$ component is omitted under conducting boundary conditions.\n\nForce expression conceptual derivation:\n- Real space. Define $\\mathbf{R} = \\mathbf{r}_i - \\mathbf{r}_j + \\mathbf{n}L$ for $\\mathbf{n} \\in \\mathbb{Z}^3$, and $R = \\|\\mathbf{R}\\|$. The pair potential in the screened representation is $q_j \\operatorname{erfc}(\\alpha R)/R$. The force on particle $i$ is $\\mathbf{F}_{ij}^{(\\mathrm{real})} = -q_i \\nabla_i \\left[q_j \\operatorname{erfc}(\\alpha R)/R\\right]$. Using the product rule and $\\frac{d}{dR}\\operatorname{erfc}(\\alpha R) = -\\frac{2\\alpha}{\\sqrt{\\pi}} e^{-\\alpha^2 R^2}$, and the identity $\\nabla_i R = \\mathbf{R}/R$, we obtain\n$$\n\\mathbf{F}_{ij}^{(\\mathrm{real})} = q_i q_j \\left( \\frac{\\operatorname{erfc}(\\alpha R)}{R^3} + \\frac{2\\alpha}{\\sqrt{\\pi}} \\frac{e^{-\\alpha^2 R^2}}{R^2} \\right) \\mathbf{R}.\n$$\nThis sum is truncated to $R \\le r_\\mathrm{cut}$ for numerical efficiency, as the neglected tail decays very rapidly.\n\n- Reciprocal space. Let $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$ for integer triplets $\\mathbf{m} \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$. The reciprocal-space potential at $\\mathbf{r}_i$ is\n$$\n\\phi^{(\\mathrm{rec})}(\\mathbf{r}_i) = \\frac{1}{V}\\sum_{\\mathbf{k}\\ne\\mathbf{0}} \\frac{4\\pi}{k^2} e^{-k^2/(4\\alpha^2)} \\sum_j q_j e^{i \\mathbf{k}\\cdot (\\mathbf{r}_i - \\mathbf{r}_j)},\n$$\nwith $V = L^3$ and $k = \\|\\mathbf{k}\\|$. The force is $\\mathbf{F}_i^{(\\mathrm{rec})} = -q_i \\nabla_i \\phi^{(\\mathrm{rec})}(\\mathbf{r}_i)$. Differentiating gives an $i\\mathbf{k}$ factor from $e^{i \\mathbf{k}\\cdot \\mathbf{r}_i}$ and yields a manifestly real form using sines:\n$$\n\\mathbf{F}_i^{(\\mathrm{rec})} = \\frac{4\\pi}{V}\\, q_i \\sum_{\\mathbf{k}\\ne\\mathbf{0}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\left[\\sum_j q_j \\sin\\left(\\mathbf{k}\\cdot (\\mathbf{r}_i - \\mathbf{r}_j)\\right)\\right] \\mathbf{k}.\n$$\nTo evaluate efficiently, we use the identity $\\sum_j q_j \\sin(\\mathbf{k}\\cdot(\\mathbf{r}_i - \\mathbf{r}_j)) = \\sin(\\mathbf{k}\\cdot \\mathbf{r}_i)\\sum_j q_j \\cos(\\mathbf{k}\\cdot \\mathbf{r}_j) - \\cos(\\mathbf{k}\\cdot \\mathbf{r}_i)\\sum_j q_j \\sin(\\mathbf{k}\\cdot \\mathbf{r}_j)$, so we only need global structure factors per $\\mathbf{k}$.\n\n- Self term. The self-interaction correction in the Ewald energy is $- \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_i q_i^2$, which has zero gradient with respect to particle positions. Therefore, the self term contributes no force and can be omitted for forces.\n\nConducting boundary conditions:\n- For conducting (tin-foil) boundaries, the $\\mathbf{k} = \\mathbf{0}$ term is dropped and there is no surface (dipole) correction. The system must be neutral, $\\sum_i q_i = 0$, to avoid divergence.\n\nAlgorithmic design:\n1. Input the particle positions $\\{\\mathbf{r}_i\\}$, charges $\\{q_i\\}$, box length $L$, and Ewald parameters $\\alpha$, $r_\\mathrm{cut}$, $k_\\mathrm{max}$.\n2. Real-space force:\n   - Determine the integer bound $n_\\mathrm{max} = \\lceil r_\\mathrm{cut}/L \\rceil$; loop over $\\mathbf{n} \\in \\{-n_\\mathrm{max},\\ldots,n_\\mathrm{max}\\}^3$.\n   - For each unordered pair $(i,j)$ with $i<j$, compute $\\mathbf{R} = \\mathbf{r}_i - \\mathbf{r}_j + \\mathbf{n}L$, its norm $R$, and if $R > 0$ and $R \\le r_\\mathrm{cut}$, accumulate the symmetric pair force using\n   $$\n   f(R) = \\frac{\\operatorname{erfc}(\\alpha R)}{R^3} + \\frac{2\\alpha}{\\sqrt{\\pi}} \\frac{e^{-\\alpha^2 R^2}}{R^2},\\qquad \\Delta\\mathbf{F} = q_i q_j f(R) \\mathbf{R}.\n   $$\n   - Add $+\\Delta\\mathbf{F}$ to $\\mathbf{F}_i$ and $-\\Delta\\mathbf{F}$ to $\\mathbf{F}_j$.\n3. Reciprocal-space force:\n   - Generate all integer triplets $\\mathbf{m}$ with $-k_\\mathrm{max} \\le m_x,m_y,m_z \\le k_\\mathrm{max}$, excluding $\\mathbf{m}=\\mathbf{0}$. For each, form $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$, $k^2 = \\mathbf{k}\\cdot \\mathbf{k}$, and the coefficient\n   $$\n   c(\\mathbf{k}) = \\frac{4\\pi}{V}\\,\\frac{e^{-k^2/(4\\alpha^2)}}{k^2}.\n   $$\n   - Compute the structure factors $C(\\mathbf{k}) = \\sum_j q_j \\cos(\\mathbf{k}\\cdot \\mathbf{r}_j)$ and $S(\\mathbf{k}) = \\sum_j q_j \\sin(\\mathbf{k}\\cdot \\mathbf{r}_j)$.\n   - For each particle $i$, compute $s_i = \\sin(\\mathbf{k}\\cdot \\mathbf{r}_i)$ and $c_i = \\cos(\\mathbf{k}\\cdot \\mathbf{r}_i)$, then accumulate\n   $$\n   \\Delta \\mathbf{F}_i = q_i\\, c(\\mathbf{k})\\, \\left( s_i\\, C(\\mathbf{k}) - c_i\\, S(\\mathbf{k}) \\right)\\, \\mathbf{k}.\n   $$\n4. The total force is $\\mathbf{F}_i = \\mathbf{F}_i^{(\\mathrm{real})} + \\mathbf{F}_i^{(\\mathrm{rec})}$ for each $i$.\n5. Validation diagnostics:\n   - Compute $D_1$ as the maximum absolute componentwise difference between forces for $\\mathcal{S}_\\mathrm{edge}$ and $\\mathcal{S}_\\mathrm{center}$ under the baseline parameters.\n   - Compute $D_2$ as the Euclidean norm of the net force for $\\mathcal{S}_\\mathrm{edge}$ under baseline parameters.\n   - Compute $D_3$ as the maximum absolute componentwise difference between forces for $\\mathcal{S}_\\mathrm{edge}$ and its globally translated-and-wrapped version under baseline parameters.\n   - Compute $D_4$ as the maximum absolute componentwise difference between forces for $\\mathcal{S}_\\mathrm{edge}$ under baseline parameters and under the alternate parameters.\n\nNumerical considerations:\n- The choice $\\alpha = 0.35$ with $r_\\mathrm{cut} = 4.5$ and $k_\\mathrm{max} = 6$ for $L=10.0$ strikes a reasonable balance between real- and reciprocal-space truncation errors for this small system. The alternate parameters $\\alpha' = 0.28$, $r_\\mathrm{cut}' = 4.5$, $k_\\mathrm{max}' = 8$ shift more work to reciprocal space, and the forces should agree closely, validating parameter independence.\n- All test systems have net charge zero, satisfying $\\sum_i q_i = 0$ as required for the Ewald sum to converge under conducting boundary conditions.\n- Invariance expectations: translating all positions by any $\\mathbf{t}$ and wrapping modulo $L$ does not change $\\mathbf{R}$-set distances or the set of phase factors $e^{i\\mathbf{k}\\cdot \\mathbf{r}}$ up to a common phase that cancels in the force expression, so forces are invariant. Likewise, centering a configuration that is equivalent under periodicity should yield indistinguishable forces. Therefore $D_1$, $D_2$, and $D_3$ should be small (close to machine precision within truncation error), and $D_4$ should be small as well, confirming parameter robustness.\n\nThe program implements the above algorithm, constructs the specified test cases, computes $\\mathbf{F}$ via Ewald summation, evaluates $D_1$, $D_2$, $D_3$, and $D_4$, and prints them as a single list $[D_1, D_2, D_3, D_4]$ on one line.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef ewald_forces(positions, charges, L, alpha, rcut, kmax):\n    \"\"\"\n    Compute Ewald forces for a 3D periodic cubic box with conducting boundary conditions.\n    positions: (N,3) array in [0,L)\n    charges: (N,) array, must sum to zero\n    L: box length\n    alpha: Ewald splitting parameter\n    rcut: real-space cutoff\n    kmax: maximum integer index for reciprocal vectors\n    Returns: (N,3) array of forces\n    \"\"\"\n    positions = np.asarray(positions, dtype=float)\n    charges = np.asarray(charges, dtype=float)\n    N = positions.shape[0]\n    assert positions.shape == (N, 3)\n    assert charges.shape == (N,)\n    # Neutrality check\n    if abs(np.sum(charges)) > 1e-12:\n        raise ValueError(\"System is not neutral; Ewald summation diverges.\")\n    forces = np.zeros_like(positions)\n    V = L**3\n    pi = np.pi\n    sqrt_pi = np.sqrt(pi)\n\n    # Real-space sum\n    nmax = int(np.ceil(rcut / L))\n    # Precompute image shifts\n    shifts = []\n    for nx in range(-nmax, nmax + 1):\n        for ny in range(-nmax, nmax + 1):\n            for nz in range(-nmax, nmax + 1):\n                shifts.append(np.array([nx, ny, nz], dtype=int))\n    shifts = np.array(shifts, dtype=int)\n\n    for i in range(N - 1):\n        ri = positions[i]\n        qi = charges[i]\n        for j in range(i + 1, N):\n            rj = positions[j]\n            qj = charges[j]\n            qiqj = qi * qj\n            # Loop over lattice vectors within cutoff\n            for nvec in shifts:\n                # Displacement including image\n                Rvec = ri - rj + L * nvec\n                R2 = np.dot(Rvec, Rvec)\n                if R2 == 0.0:\n                    continue\n                R = np.sqrt(R2)\n                if R <= rcut:\n                    aR = alpha * R\n                    erfc_term = erfc(aR)\n                    exp_term = np.exp(-(aR * aR))\n                    # Force scalar factor\n                    f = erfc_term / (R2 * R) + (2.0 * alpha / sqrt_pi) * exp_term / R2\n                    fij = qiqj * f * Rvec\n                    forces[i] += fij\n                    forces[j] -= fij\n\n    # Reciprocal-space sum\n    # Generate k-vectors\n    ms = np.arange(-kmax, kmax + 1, dtype=int)\n    k_list = []\n    for mx in ms:\n        for my in ms:\n            for mz in ms:\n                if mx == 0 and my == 0 and mz == 0:\n                    continue\n                m = np.array([mx, my, mz], dtype=float)\n                kvec = (2.0 * np.pi / L) * m\n                ksq = np.dot(kvec, kvec)\n                if ksq == 0.0:\n                    continue\n                k_list.append((kvec, ksq))\n    # Structure factors and force accumulation\n    # Precompute dot products k·r for all k and all particles can be memory heavy; loop over k\n    for kvec, ksq in k_list:\n        # Coefficient c(k)\n        ck = (4.0 * np.pi / V) * np.exp(-ksq / (4.0 * alpha * alpha)) / ksq\n        # Structure factors\n        kr = positions @ kvec  # shape (N,)\n        cos_kr = np.cos(kr)\n        sin_kr = np.sin(kr)\n        Ck = np.sum(charges * cos_kr)\n        Sk = np.sum(charges * sin_kr)\n        # Per-particle contributions\n        s_i = sin_kr\n        c_i = cos_kr\n        # term = (s_i * Ck - c_i * Sk)\n        term = (s_i * Ck - c_i * Sk) * charges * ck  # shape (N,)\n        # Add to forces: term[:, None] * kvec\n        forces += term[:, None] * kvec\n\n    return forces\n\ndef translate_and_wrap(positions, tvec, L):\n    \"\"\"Translate positions by tvec and wrap back into [0,L).\"\"\"\n    pos_new = positions + np.asarray(tvec, dtype=float)\n    pos_new = pos_new % L\n    return pos_new\n\ndef max_abs_componentwise_diff(A, B):\n    \"\"\"Max absolute component-wise difference between two (N,3) arrays.\"\"\"\n    return float(np.max(np.abs(A - B)))\n\ndef solve():\n    # Define global parameters\n    L = 10.0\n    alpha = 0.35\n    rcut = 4.5\n    kmax = 6\n\n    alpha_alt = 0.28\n    rcut_alt = 4.5\n    kmax_alt = 8\n\n    # Define systems\n    charges = np.array([+1.0, -1.0], dtype=float)\n\n    # Edge configuration (across boundary)\n    r_edge = np.array([\n        [9.8, 5.0, 5.0],\n        [0.2, 5.0, 5.0],\n    ], dtype=float)\n\n    # Centered configuration with same minimum-image separation (0.4 along +x)\n    r_center = np.array([\n        [0.2, 5.0, 5.0],\n        [0.6, 5.0, 5.0],\n    ], dtype=float)\n\n    # Translation vector\n    tvec = np.array([3.7, 0.0, -1.1], dtype=float)\n\n    # Compute forces with baseline parameters\n    F_edge = ewald_forces(r_edge, charges, L, alpha, rcut, kmax)\n    F_center = ewald_forces(r_center, charges, L, alpha, rcut, kmax)\n\n    # D1: max componentwise difference between edge and center\n    D1 = max_abs_componentwise_diff(F_edge, F_center)\n\n    # D2: norm of total force for edge system\n    total_force_edge = np.sum(F_edge, axis=0)\n    D2 = float(np.linalg.norm(total_force_edge))\n\n    # D3: translation invariance\n    r_edge_trans = translate_and_wrap(r_edge, tvec, L)\n    F_trans = ewald_forces(r_edge_trans, charges, L, alpha, rcut, kmax)\n    D3 = max_abs_componentwise_diff(F_edge, F_trans)\n\n    # D4: parameter invariance (alternate parameters)\n    F_alt = ewald_forces(r_edge, charges, L, alpha_alt, rcut_alt, kmax_alt)\n    D4 = max_abs_componentwise_diff(F_edge, F_alt)\n\n    results = [D1, D2, D3, D4]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "A correct implementation of forces is necessary but not sufficient; it must also be consistent with an underlying potential energy to be useful in molecular dynamics simulations. This practice explores the concept of conservative forces, where the force $\\mathbf{F}$ is the negative gradient of the potential energy $U$. You will verify this fundamental relationship by comparing your analytical force calculation to a numerical gradient and then confirm its most important consequence: the near-conservation of total energy in a microcanonical (NVE) simulation. ",
            "id": "3441713",
            "problem": "Consider a cubic, periodic system of point charges in molecular dynamics under long-range electrostatics. The goal is to demonstrate implementation consistency of the real-space and reciprocal-space components of the Ewald decomposition and to check energy conservation under a single-step molecular dynamics integrator. Work in dimensionless reduced units where the Coulomb constant is one, the length unit is the cubic box edge, and all masses are one. All reported quantities must be dimensionless.\n\nStarting from fundamental laws and definitions, including Coulomb’s law and the Poisson equation under periodic boundary conditions, derive a mathematically sound Ewald splitting that separates the total electrostatic energy into a short-ranged real-space sum, a long-ranged reciprocal-space sum, and any self-interaction and boundary-condition corrections required for a conducting (tin-foil) boundary. Derive the corresponding forces by taking the negative gradient of the energy. The derivation must begin from first principles, such as the screened decomposition of the Green’s function and the Poisson summation theorem, without relying on shortcut formulas stated outright in the problem statement.\n\nAlgorithmic requirements:\n- Implement a minimum-image convention for the real-space component with a real-space cutoff $r_{\\mathrm{c}}$ not exceeding $L/2$, where $L$ is the cubic box edge length.\n- Implement the reciprocal-space component by summing over nonzero wavevectors $\\mathbf{k}$ constructed from integer triples $(n_x,n_y,n_z)$ with magnitude bounded by an integer cutoff $k_{\\max}$, using $\\mathbf{k} = 2\\pi \\mathbf{n}/L$ and excluding $\\mathbf{k}=\\mathbf{0}$.\n- Include the self-interaction term appropriate for the chosen splitting and adopt the conducting boundary condition such that the surface term vanishes.\n- Compute total energy and forces by summing real-space and reciprocal-space contributions plus the self-energy.\n- Verify implementation consistency by comparing the analytically computed force to a numerical estimate of the negative energy gradient obtained via central finite differences in position.\n- Verify that the total energy is nearly invariant to the choice of splitting parameter when both real-space and reciprocal-space components are included with consistent cutoffs.\n- Verify near energy conservation under a single velocity-Verlet time step with periodic boundary conditions and forces derived from the Ewald decomposition.\n\nTest suite:\nUse the following three test cases, which together probe general behavior, sensitivity to the splitting parameter, and dynamical conservation. All inputs and outputs are dimensionless.\n\n1. Implementation consistency (maximum force-gradient mismatch):\n   - Number of particles $N=4$.\n   - Charges $\\{q_i\\} = [1,-1,1,-1]$.\n   - Positions $\\{\\mathbf{r}_i\\}$ within the primary cell: $[ [0.7,1.3,2.1], [2.9,3.5,1.8], [4.2,0.4,3.7], [1.1,4.6,0.9] ]$.\n   - Box length $L=6.0$.\n   - Real-space cutoff $r_{\\mathrm{c}}=3.0$.\n   - Splitting parameter $\\alpha=0.35$.\n   - Reciprocal cutoff $k_{\\max}=6$.\n   Compute the analytical force from the Ewald sum and the numerical negative gradient of the energy using central finite differences with a small displacement step of $10^{-6}$ in each Cartesian direction for each particle, keeping positions wrapped in the primary cell. Report the single float equal to the maximum norm of the difference between analytical force and numerical negative gradient over all particles.\n\n2. Splitting parameter invariance (energy difference across two $\\alpha$):\n   - Number of particles $N=2$.\n   - Charges $\\{q_i\\} = [1,-1]$.\n   - Positions $\\{\\mathbf{r}_i\\} = [ [0.5,0.5,0.5], [1.5,1.0,3.0] ]$.\n   - Box length $L=4.0$.\n   - Real-space cutoff $r_{\\mathrm{c}}=2.0$.\n   - Reciprocal cutoff $k_{\\max}=7$.\n   - Splitting parameters $\\alpha_1=0.25$ and $\\alpha_2=0.45$.\n   Compute the total energy for $\\alpha_1$ and $\\alpha_2$ using the same cutoffs. Report the single float equal to the absolute difference of the two total energies.\n\n3. Single-step energy conservation (absolute total energy change):\n   - Number of particles $N=3$.\n   - Charges $\\{q_i\\} = [-1,-1,2]$.\n   - Positions $\\{\\mathbf{r}_i\\} = [ [0.3,1.1,2.2], [2.7,3.3,4.1], [1.4,2.0,0.9] ]$.\n   - Initial velocities $\\{\\mathbf{v}_i\\} = [ [0.02,-0.01,0.015], [ -0.03,0.025,-0.02 ], [ 0.01, -0.015, 0.005 ] ]$.\n   - Box length $L=5.0$.\n   - Real-space cutoff $r_{\\mathrm{c}}=2.5$.\n   - Reciprocal cutoff $k_{\\max}=6$.\n   - Splitting parameter $\\alpha=0.40$.\n   - Time step $\\Delta t=10^{-3}$.\n   Perform one velocity-Verlet integration step with positions wrapped back into the primary cell after the position update. Compute the absolute change in the sum of potential and kinetic energy between the initial and final states and report it as a single float.\n\nFinal output format:\nYour program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each result must be a float in dimensionless units. No extra text may be printed.",
            "solution": "The user has provided a well-defined problem in computational physics, requiring the derivation and implementation of the Ewald summation method for calculating electrostatic interactions in a periodic system. The problem is scientifically sound, internally consistent, and all parameters for the test cases are specified. I will therefore proceed with a full solution.\n\n### 1. Theoretical Derivation of the Ewald Summation\n\nThe electrostatic potential energy $U$ of a system of $N$ point charges $q_i$ at positions $\\mathbf{r}_i$ within a cubic simulation box of length $L$, replicated over a periodic lattice, is given by the conditionally convergent sum:\n$$\nU = \\frac{1}{2} \\sum_{i=1}^N \\sum_{j=1}^N \\sideset{}{'}\\sum_{\\mathbf{n} \\in \\mathbb{Z}^3} \\frac{q_i q_j}{|\\mathbf{r}_{ij} + \\mathbf{n}L|}\n$$\nwhere $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$ and the prime on the sum over lattice vectors $\\mathbf{n}$ indicates that for $\\mathbf{n}=\\mathbf{0}$, the term $i=j$ is excluded. The Coulomb constant $k_e$ is set to $1$.\n\nThe Ewald method splits the long-range $1/r$ interaction into two parts using the identity $1 = \\text{erf}(\\alpha r) + \\text{erfc}(\\alpha r)$, where $\\alpha$ is a parameter that controls the range of the separation:\n$$\n\\frac{1}{r} = \\frac{\\text{erfc}(\\alpha r)}{r} + \\frac{\\text{erf}(\\alpha r)}{r}\n$$\nThe first term, containing the complementary error function $\\text{erfc}$, is short-ranged and can be summed efficiently in real space. The second term, with the error function $\\text{erf}$, is smooth and long-ranged, making it suitable for summation in reciprocal (Fourier) space.\n\nThis splitting can be visualized by considering each point charge $q_i$ as the sum of its true self plus a neutralizing Gaussian charge distribution of opposite sign, $-q_i$, and simultaneously adding back a screening Gaussian charge distribution of the same sign, $+q_i$. The total potential is then the sum of potentials from:\n1.  Point charges interacting via a short-range screened potential (sum of point charge and neutralizing Gaussian).\n2.  The smooth screening Gaussian charge distributions interacting with each other.\n\n#### 1.1. Real-Space Component\nThe real-space energy $U_{\\text{real}}$ arises from the interaction via the short-range potential $\\text{erfc}(\\alpha r)/r$:\n$$\nU_{\\text{real}} = \\frac{1}{2} \\sum_{i=1}^N \\sum_{j=1}^N \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3} \\frac{q_i q_j \\text{erfc}(\\alpha|\\mathbf{r}_{ij} + \\mathbf{n}L|)}{|\\mathbf{r}_{ij} + \\mathbf{n}L|}\n$$\nDue to the rapid decay of $\\text{erfc}(x)$, this sum can be truncated at a cutoff distance $r_c$. Applying the minimum image convention (MIC), we only consider the closest periodic image of each particle, simplifying the sum over pairs:\n$$\nU_{\\text{real}} = \\sum_{i<j, |\\mathbf{r}_{ij,\\text{mic}}|<r_c} \\frac{q_i q_j \\text{erfc}(\\alpha|\\mathbf{r}_{ij,\\text{mic}}|)}{|\\mathbf{r}_{ij,\\text{mic}}|}\n$$\nThe force on particle $k$ is $\\mathbf{F}_{k,\\text{real}} = -\\nabla_{\\mathbf{r}_k}U_{\\text{real}}$:\n$$\n\\mathbf{F}_{k,\\text{real}} = \\sum_{j \\neq k, |\\mathbf{r}_{kj,\\text{mic}}|<r_c} q_k q_j \\left[ \\frac{\\text{erfc}(\\alpha r_{kj})}{r_{kj}^3} + \\frac{2\\alpha}{\\sqrt{\\pi}} \\frac{e^{-\\alpha^2 r_{kj}^2}}{r_{kj}^2} \\right] \\mathbf{r}_{kj,\\text{mic}}\n$$\nwhere $r_{kj} = |\\mathbf{r}_{kj,\\text{mic}}|$.\n\n#### 1.2. Reciprocal-Space Component\nThe long-range contribution comes from the smooth screening Gaussian charge distributions, $\\rho_{\\text{Gauss}}(\\mathbf{r}) = \\sum_i q_i(\\alpha/\\sqrt{\\pi})^3 \\exp(-\\alpha^2|\\mathbf{r}-\\mathbf{r}_i|^2)$. The potential from these charges is calculated in reciprocal space. We expand the charge density in a Fourier series:\n$$\n\\rho_{\\text{Gauss}}(\\mathbf{r}) = \\frac{1}{L^3} \\sum_{\\mathbf{k}} \\tilde{\\rho}_{\\text{Gauss}}(\\mathbf{k}) e^{i\\mathbf{k}\\cdot\\mathbf{r}}\n$$\nwhere the wavevectors are $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{n}$ for $\\mathbf{n} \\in \\mathbb{Z}^3$. The Fourier coefficients are $\\tilde{\\rho}_{\\text{Gauss}}(\\mathbf{k}) = \\exp(-k^2/4\\alpha^2)S(\\mathbf{k})$, where $S(\\mathbf{k}) = \\sum_j q_j e^{-i\\mathbf{k}\\cdot\\mathbf{r}_j}$ is the structure factor.\n\nThe reciprocal-space energy $U_{\\text{recip}}$ is the interaction energy of the point charges with the potential generated by the Gaussian distributions. In Fourier space, Poisson's equation $\\nabla^2\\phi = -4\\pi\\rho$ becomes $-k^2\\tilde{\\phi} = -4\\pi\\tilde{\\rho}$, yielding $\\tilde{\\phi}_{\\text{Gauss}}(\\mathbf{k}) = (4\\pi/k^2)\\tilde{\\rho}_{\\text{Gauss}}(\\mathbf{k})$. The energy is:\n$$\nU_{\\text{recip}} = \\frac{1}{2L^3} \\sum_{\\mathbf{k}\\neq\\mathbf{0}} \\tilde{\\phi}_{\\text{Gauss}}(\\mathbf{k}) S(-\\mathbf{k}) = \\frac{2\\pi}{L^3} \\sum_{\\mathbf{k}\\neq\\mathbf{0}} \\frac{e^{-k^2 / (4\\alpha^2)}}{k^2} |S(\\mathbf{k})|^2\n$$\nThe $\\mathbf{k}=\\mathbf{0}$ term is excluded. For the charge-neutral systems in this problem, this term is naturally zero. The force on particle $k$ is $\\mathbf{F}_{k,\\text{recip}} = -\\nabla_{\\mathbf{r}_k}U_{\\text{recip}}$:\n$$\n\\mathbf{F}_{k, \\text{recip}} = \\frac{4\\pi q_k}{L^3} \\sum_{\\mathbf{k}\\neq\\mathbf{0}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\left[ \\sum_{j=1}^N q_j \\sin(\\mathbf{k}\\cdot(\\mathbf{r}_k-\\mathbf{r}_j)) \\right] \\mathbf{k}\n$$\n\n#### 1.3. Self-Interaction and Boundary Conditions\nThe sum in reciprocal space incorrectly includes the interaction of each screening Gaussian with its own central point charge. This spurious self-interaction energy must be subtracted. The term for particle $i$ corresponds to the potential of a Gaussian of charge $q_i$ at its own center, which is $2\\alpha q_i/\\sqrt{\\pi}$. The total correction is thus:\n$$\nU_{\\text{self}} = -\\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{i=1}^N q_i^2\n$$\nThis term does not depend on position, so it does not contribute to the force.\n\nThe problem specifies \"conducting (tin-foil)\" boundary conditions. This standard convention in Ewald methods implies that the periodic system is surrounded by a perfect conductor, which nullifies the surface dipole term that would otherwise appear. Therefore, no additional surface term is needed.\n\nThe total potential energy is $U = U_{\\text{real}} + U_{\\text{recip}} + U_{\\text{self}}$, and the total force is $\\mathbf{F}_k = \\mathbf{F}_{k,\\text{real}} + \\mathbf{F}_{k,\\text{recip}}$.\n\n### 2. Algorithmic Implementation and Verification\n\nThe test cases require:\n1.  **Force-Gradient Consistency**: Numerical verification of $\\mathbf{F} = -\\nabla U$ using central finite differences.\n2.  **Splitting Parameter Invariance**: Demonstrating that the total energy $U$ is nearly independent of the choice of $\\alpha$, provided the cutoffs $r_c$ and $k_{\\max}$ are sufficiently large.\n3.  **Energy Conservation**: Verifying that the total energy (kinetic + potential) is conserved over a single step of the velocity-Verlet integrator. The integrator steps are:\n    a.  $\\mathbf{r}(t+\\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\mathbf{a}(t)\\Delta t^2$\n    b.  Apply periodic boundary conditions to $\\mathbf{r}(t+\\Delta t)$.\n    c.  $\\mathbf{a}(t+\\Delta t) = \\mathbf{F}(\\mathbf{r}(t+\\Delta t))/m$\n    d.  $\\mathbf{v}(t+\\Delta t) = \\mathbf{v}(t) + \\frac{1}{2}[\\mathbf{a}(t) + \\mathbf{a}(t+\\Delta t)]\\Delta t$\n\nThe implementation follows these derived formulas and verification procedures.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Solves the Ewald summation problem for the three specified test cases.\n    The implementation is self-contained within this function.\n    \"\"\"\n\n    # ------------------ Core Ewald Implementation ------------------\n    \n    def _get_k_vectors(k_max, L):\n        \"\"\"Generates reciprocal space vectors up to a spherical cutoff.\"\"\"\n        k_vectors_list = []\n        k_sq_magnitudes_list = []\n        if k_max <= 0:\n            return np.array([]), np.array([])\n        \n        k_max_sq = k_max**2\n        n_range = range(-k_max, k_max + 1)\n        \n        for nx in n_range:\n            for ny in n_range:\n                for nz in n_range:\n                    if nx == 0 and ny == 0 and nz == 0:\n                        continue\n                    n_sq = nx**2 + ny**2 + nz**2\n                    if n_sq <= k_max_sq:\n                        k_vec = (2 * np.pi / L) * np.array([nx, ny, nz])\n                        k_vectors_list.append(k_vec)\n                        k_sq_magnitudes_list.append(np.dot(k_vec, k_vec))\n        \n        return np.array(k_vectors_list), np.array(k_sq_magnitudes_list)\n\n    def _apply_mic(diff_vec, L):\n        \"\"\"Applies minimum image convention to a vector.\"\"\"\n        return diff_vec - L * np.round(diff_vec / L)\n\n    def ewald_energy(charges, positions, L, alpha, r_c, k_max):\n        \"\"\"Computes the total Ewald potential energy.\"\"\"\n        N = len(charges)\n        \n        # Real-space component\n        U_real = 0.0\n        for i in range(N):\n            for j in range(i + 1, N):\n                r_ij_vec = _apply_mic(positions[i] - positions[j], L)\n                r_ij = np.linalg.norm(r_ij_vec)\n                if r_ij > 0 and r_ij < r_c:\n                    U_real += charges[i] * charges[j] * erfc(alpha * r_ij) / r_ij\n        \n        # Reciprocal-space component\n        U_recip = 0.0\n        k_vectors, k_sq_mags = _get_k_vectors(k_max, L)\n        if k_vectors.size > 0:\n            k_dot_r = np.dot(positions, k_vectors.T)\n            exp_ikr = np.exp(-1j * k_dot_r)\n            S_k = np.dot(charges, exp_ikr)\n            \n            U_recip_sum = np.sum(np.exp(-k_sq_mags / (4 * alpha**2)) / k_sq_mags * np.abs(S_k)**2)\n            U_recip = (2 * np.pi / L**3) * U_recip_sum\n\n        # Self-interaction correction\n        U_self = -(alpha / np.sqrt(np.pi)) * np.sum(charges**2)\n\n        return U_real + U_recip + U_self\n\n    def ewald_forces(charges, positions, L, alpha, r_c, k_max):\n        \"\"\"Computes the Ewald forces on all particles.\"\"\"\n        N = len(charges)\n        forces = np.zeros((N, 3))\n        \n        # Real-space forces\n        for i in range(N):\n            for j in range(N):\n                if i == j:\n                    continue\n                r_ij_vec = _apply_mic(positions[i] - positions[j], L)\n                r_ij = np.linalg.norm(r_ij_vec)\n                if r_ij > 0 and r_ij < r_c:\n                    term_in_brackets = (erfc(alpha * r_ij) / r_ij**2 + \n                                       (2 * alpha / np.sqrt(np.pi)) * np.exp(-alpha**2 * r_ij**2) / r_ij)\n                    forces[i] += charges[i] * charges[j] * term_in_brackets * r_ij_vec / r_ij\n\n        # Reciprocal-space forces\n        k_vectors, k_sq_mags = _get_k_vectors(k_max, L)\n        if k_vectors.size > 0:\n            prefactors_base = (4 * np.pi / L**3) * np.exp(-k_sq_mags / (4 * alpha**2)) / k_sq_mags\n            \n            # S(k) = sum_j q_j exp(-i*k.r_j)\n            exp_minus_ikr = np.exp(-1j * np.dot(positions, k_vectors.T))\n            S_k = np.dot(charges, exp_minus_ikr)\n            \n            # Term to sum is Im[S(k) * exp(i*k.r_i)] for each particle i\n            sin_term_matrix = np.imag(S_k[np.newaxis, :] * np.conj(exp_minus_ikr))\n            \n            force_contrib_per_k = prefactors_base[np.newaxis, :] * sin_term_matrix\n            \n            recip_forces = charges[:, np.newaxis] * np.dot(force_contrib_per_k, k_vectors)\n            forces += recip_forces\n            \n        return forces\n\n    # ------------------ Test Case Functions ------------------\n\n    def run_case_1():\n        N = 4\n        charges = np.array([1.0, -1.0, 1.0, -1.0])\n        positions = np.array([\n            [0.7, 1.3, 2.1], [2.9, 3.5, 1.8], [4.2, 0.4, 3.7], [1.1, 4.6, 0.9]\n        ])\n        L = 6.0\n        r_c = 3.0\n        alpha = 0.35\n        k_max = 6\n        \n        F_analytic = ewald_forces(charges, positions, L, alpha, r_c, k_max)\n        \n        F_numeric = np.zeros_like(positions)\n        h = 1e-6\n        for i in range(N):\n            for j in range(3):\n                pos_plus = positions.copy()\n                pos_plus[i, j] += h\n                pos_plus %= L\n                U_plus = ewald_energy(charges, pos_plus, L, alpha, r_c, k_max)\n                \n                pos_minus = positions.copy()\n                pos_minus[i, j] -= h\n                pos_minus %= L\n                U_minus = ewald_energy(charges, pos_minus, L, alpha, r_c, k_max)\n                \n                F_numeric[i, j] = -(U_plus - U_minus) / (2 * h)\n                \n        diff_norms = np.linalg.norm(F_analytic - F_numeric, axis=1)\n        return np.max(diff_norms)\n\n    def run_case_2():\n        charges = np.array([1.0, -1.0])\n        positions = np.array([[0.5, 0.5, 0.5], [1.5, 1.0, 3.0]])\n        L = 4.0\n        r_c = 2.0\n        k_max = 7\n        alpha1, alpha2 = 0.25, 0.45\n        \n        U1 = ewald_energy(charges, positions, L, alpha1, r_c, k_max)\n        U2 = ewald_energy(charges, positions, L, alpha2, r_c, k_max)\n        \n        return np.abs(U1 - U2)\n\n    def run_case_3():\n        charges = np.array([-1.0, -1.0, 2.0])\n        positions = np.array([[0.3, 1.1, 2.2], [2.7, 3.3, 4.1], [1.4, 2.0, 0.9]])\n        velocities = np.array([\n            [0.02, -0.01, 0.015], [-0.03, 0.025, -0.02], [0.01, -0.015, 0.005]\n        ])\n        L = 5.0\n        r_c = 2.5\n        k_max = 6\n        alpha = 0.40\n        dt = 1e-3\n        masses = np.ones(len(charges))\n        \n        pos0, vel0 = positions, velocities\n        forces0 = ewald_forces(charges, pos0, L, alpha, r_c, k_max)\n        accel0 = forces0 / masses[:, np.newaxis]\n        \n        U0 = ewald_energy(charges, pos0, L, alpha, r_c, k_max)\n        K0 = 0.5 * np.sum(masses * np.sum(vel0**2, axis=1))\n        E0 = U0 + K0\n        \n        pos1 = pos0 + vel0 * dt + 0.5 * accel0 * dt**2\n        pos1 %= L\n        \n        forces1 = ewald_forces(charges, pos1, L, alpha, r_c, k_max)\n        accel1 = forces1 / masses[:, np.newaxis]\n        \n        vel1 = vel0 + 0.5 * (accel0 + accel1) * dt\n        \n        U1 = ewald_energy(charges, pos1, L, alpha, r_c, k_max)\n        K1 = 0.5 * np.sum(masses * np.sum(vel1**2, axis=1))\n        E1 = U1 + K1\n        \n        return np.abs(E1 - E0)\n\n    # ------------------ Main Execution ------------------\n    \n    results = [\n        run_case_1(),\n        run_case_2(),\n        run_case_3()\n    ]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a verified Ewald implementation, we can shift our focus from algorithmic correctness to scientific application. This final exercise demonstrates how to manage the trade-off between real- and reciprocal-space calculations by choosing the splitting parameter $\\alpha$ and associated cutoffs to achieve a target accuracy. By examining the effect of these choices on a physical observable like the charge-charge radial distribution function $g_{qq}(r)$, you will learn how to ensure your simulation results are robust and independent of arbitrary numerical parameters. ",
            "id": "3441666",
            "problem": "Consider a neutral, strongly correlated ionic system under three-dimensional periodic boundary conditions, with an equal number of point ions of charges $+1$ and $-1$. The electrostatic interaction between ions in a periodic system is evaluated using the Ewald summation method (Ewald), which decomposes the interaction into a short-ranged real-space part and a long-ranged reciprocal-space part controlled by a positive splitting parameter $\\alpha$. In the infinite-sum, zero-truncation limit, the Ewald sum is independent of $\\alpha$, but in practical computations with finite cutoffs the real-space and reciprocal-space contributions are truncated, yielding $\\alpha$-dependent errors. This problem asks you to implement a principled computation that tests whether varying $\\alpha$ within prescribed error constraints perturbs a measurable structural correlation.\n\nYou are to start from Coulomb’s law and the definition of the Ewald decomposition, and use the following scientifically well-tested facts and definitions as foundational starting points:\n- The pair potential between charges $q_i$ and $q_j$ in vacuum is $V(r) = q_i q_j / r$ for separation $r$.\n- The Ewald method splits $V(r)$ into a real-space contribution that decays as the complementary error function and a reciprocal-space contribution that decays as a Gaussian in wavevector magnitude. The self-energy and tin-foil (conducting) boundary surface terms can be included to stabilize energy but do not affect forces between distinct particles.\n- Under periodic boundary conditions, wavevectors are $\\mathbf{k} = \\frac{2\\pi}{L}(n_x, n_y, n_z)$ with $n_x, n_y, n_z \\in \\mathbb{Z}$ and cubic box edge length $L$. The system volume is $V = L^3$.\n- The real-space truncation error is bounded by the complementary error function at the cutoff, and the reciprocal-space truncation error is bounded by the Gaussian factor at the cutoff shell:\n  - Require $\\mathrm{erfc}(\\alpha r_{\\mathrm{cut}}) \\le \\varepsilon_{\\mathrm{real}}$ to choose the real-space cutoff $r_{\\mathrm{cut}}$.\n  - Require $\\exp\\!\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4\\alpha^2}\\right) \\le \\varepsilon_{\\mathrm{rec}}$ to choose the reciprocal cutoff wavevector magnitude.\n- The minimum-image convention is applied for real-space pair separations.\n\nDefine the charge–charge radial distribution function (RDF) $g_{qq}(r)$ as the spherically averaged, dimensionless correlation of charge density at separation $r$, normalized by the expected pair density in a homogeneous reference:\n$$\ng_{qq}(r) = \\frac{1}{N \\rho \\, 4\\pi r^2 \\Delta r} \\sum_{i \\ne j} q_i q_j \\, \\chi\\!\\left(r \\le r_{ij} < r + \\Delta r\\right),\n$$\nwhere $N$ is the total number of ions, $\\rho = N/V$ is the number density, $q_i \\in \\{+1,-1\\}$, $r_{ij}$ is the minimum-image separation, $\\Delta r$ is the radial bin width, and $\\chi(\\cdot)$ is the indicator function. The function $g_{qq}(r)$ is dimensionless.\n\nYour task is to implement a complete program that:\n1. Constructs a neutral, strongly correlated ionic configuration in a cubic box of edge length $L$ using two interpenetrating simple-cubic sublattices offset by $L/4$ in each direction, with small random displacements added to each particle to break perfect symmetry. Use $N=16$ ions, $V=L^3$, and dimensionless reduced units (i.e., set the Coulomb constant to unity; no physical units are to be used anywhere in the program).\n2. For a given choice of $\\alpha$, selects a real-space cutoff $r_{\\mathrm{cut}}$ and a reciprocal-space integer cutoff $n_{\\max}$ using the bounds\n   $$\n   \\mathrm{erfc}(\\alpha r_{\\mathrm{cut}}) \\le \\varepsilon_{\\mathrm{real}}, \\quad \\exp\\!\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4\\alpha^2}\\right) \\le \\varepsilon_{\\mathrm{rec}} \\text{ at } \\lVert \\mathbf{k} \\rVert = K,\n   $$\n   with $K = \\frac{2\\pi}{L} n_{\\max}$. Enforce $r_{\\mathrm{cut}} \\le L/2$ and $n_{\\max} \\ge 1$. The reciprocal-space sum should include all integer wavevectors with components in $\\{-n_{\\max}, \\ldots, n_{\\max}\\}$ except the zero vector.\n3. Computes the total electrostatic force on each ion using the Ewald real-space and reciprocal-space components consistent with the above truncations and tin-foil (conducting) boundary conditions. The real-space force between a pair at separation $\\mathbf{r}$ of magnitude $r$ is obtained by differentiating the real-space potential $q_i q_j \\, \\mathrm{erfc}(\\alpha r)/r$ with respect to $\\mathbf{r}$. The reciprocal-space force uses the structure factor $S(\\mathbf{k}) = \\sum_j q_j e^{-i \\mathbf{k}\\cdot \\mathbf{r}_j}$ and the Gaussian attenuation factor. Apply the minimum-image convention in real space.\n4. Performs a fixed number of gradient-descent relaxation steps, updating positions as $\\mathbf{r}_i \\leftarrow \\mathbf{r}_i + \\gamma \\mathbf{F}_i$ with a small step size $\\gamma$, wrapping positions into the box after each step.\n5. Computes $g_{qq}(r)$ over $[0,L/2)$ using $M$ bins of width $\\Delta r = (L/2)/M$.\n6. Repeats steps 2–5 for three different $\\alpha$ values while holding the error bounds $\\varepsilon_{\\mathrm{real}}$ and $\\varepsilon_{\\mathrm{rec}}$ fixed, starting each relaxation from the same initial configuration. Let the first $\\alpha$ be the baseline. For each $\\alpha$ (including the baseline), compute the maximum absolute binwise difference in $g_{qq}(r)$ relative to the baseline curve, and test whether this maximum difference is less than or equal to a prescribed tolerance $\\tau$.\n\nDesign choices to ensure scientific realism:\n- Use tin-foil boundary conditions (conducting boundary) for the reciprocal-space term so that macroscopic surface-term forces vanish.\n- Use the minimum-image convention in real space and impose $r_{\\mathrm{cut}} \\le L/2$.\n- Select $r_{\\mathrm{cut}}$ and $n_{\\max}$ from the stated bounds to maintain consistent truncation error constraints for all $\\alpha$ tested.\n\nTest suite and parameters:\n- Box edge length $L = 1$ (dimensionless).\n- Number of ions $N = 16$ with charges $q_i \\in \\{+1,-1\\}$ arranged on two interpenetrating simple-cubic sublattices with an offset of $L/4$ in each direction, plus small random displacements of magnitude less than $0.02 L$.\n- Ewald parameters and error bounds:\n  - Case A (baseline): $\\alpha = 2$, $\\varepsilon_{\\mathrm{real}} = 10^{-3}$, $\\varepsilon_{\\mathrm{rec}} = 10^{-2}$.\n  - Case B: $\\alpha = 4$, $\\varepsilon_{\\mathrm{real}} = 10^{-3}$, $\\varepsilon_{\\mathrm{rec}} = 10^{-2}$.\n  - Case C: $\\alpha = 6$, $\\varepsilon_{\\mathrm{real}} = 10^{-3}$, $\\varepsilon_{\\mathrm{rec}} = 10^{-2}$.\n- Gradient-descent relaxation: number of steps $S = 15$, step size $\\gamma = 0.002$.\n- Radial distribution function parameters: number of bins $M = 20$ over $[0,L/2)$.\n- Tolerance: $\\tau = 0.1$ (dimensionless).\n\nYour program should evaluate the maximum absolute deviation in $g_{qq}(r)$ for each of the three cases relative to the baseline and compare to $\\tau$, producing a boolean for each case indicating whether the deviation condition holds. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[True,False,True]\").\n\nThe final output is strictly this single line with booleans for Case A, Case B, and Case C, in that order. No physical units are to be used; all quantities are in reduced, dimensionless form consistent with the described setup.",
            "solution": "The electrostatic interaction in a periodic ionic system can be computed using the Ewald summation method (Ewald), which splits the Coulomb potential into a rapidly decaying real-space component and a smoothly varying reciprocal-space component. The decomposition is controlled by a positive parameter $\\alpha$, and for complete, infinite sums the total energy and forces are independent of $\\alpha$. In practice, truncating both sums introduces errors that depend on $\\alpha$ because the real-space truncation error decays like $\\mathrm{erfc}(\\alpha r)$ while the reciprocal-space truncation error decays like $\\exp(-\\lVert \\mathbf{k} \\rVert^2/(4 \\alpha^2))$. Consequently, for fixed computational cost, different $\\alpha$ values can shift the error budget between the two domains, which motivates testing whether structural observables are sensitive to $\\alpha$ when the truncation errors are bounded.\n\nWe start from Coulomb’s law for point charges in vacuum: for two ions with charges $q_i$ and $q_j$ at positions $\\mathbf{r}_i$ and $\\mathbf{r}_j$ with separation vector $\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$, the pair potential is $V(r) = q_i q_j / r$ where $r = \\lVert \\mathbf{r} \\rVert$. Under periodic boundary conditions in a cubic box of edge length $L$ and volume $V = L^3$, the Ewald method expresses the energy as the sum of real-space and reciprocal-space contributions plus a self-term and a surface-term. For forces between distinct particles, only the real-space and reciprocal-space components contribute.\n\nReal-space component: The real-space pair potential is $q_i q_j \\, \\mathrm{erfc}(\\alpha r)/r$, where $\\mathrm{erfc}(\\cdot)$ is the complementary error function, and the corresponding force vector is obtained by differentiating with respect to $\\mathbf{r}$:\n$$\n\\mathbf{F}_{ij}^{\\mathrm{real}}(\\mathbf{r}) = q_i q_j \\left[ \\frac{\\mathrm{erfc}(\\alpha r)}{r^3} + \\frac{2\\alpha}{\\sqrt{\\pi}} \\frac{e^{-(\\alpha r)^2}}{r^2} \\right] \\mathbf{r}.\n$$\nThis expression follows from $-\\nabla \\left( \\mathrm{erfc}(\\alpha r)/r \\right)$. The minimum-image convention is enforced to compute $\\mathbf{r}$ such that its components lie in $(-L/2, L/2]$, and we truncate pairs at $r_{\\mathrm{cut}} \\le L/2$.\n\nReciprocal-space component: The reciprocal-space contribution uses the structure factor $S(\\mathbf{k}) = \\sum_j q_j e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j}$ and attenuates higher wavevectors by a Gaussian factor. For tin-foil (conducting) boundary conditions, the force on ion $i$ due to reciprocal-space modes is\n$$\n\\mathbf{F}_i^{\\mathrm{rec}} = \\frac{4\\pi q_i}{V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{\\exp\\left(-k^2/4\\alpha^2\\right)}{k^2} \\left( \\sum_j q_j \\sin(\\mathbf{k} \\cdot (\\mathbf{r}_i - \\mathbf{r}_j)) \\right) \\mathbf{k},\n$$\nwhere the sum runs over all integer triplets $(n_x, n_y, n_z)$ with components in $\\{-n_{\\max}, \\ldots, n_{\\max}\\}$, excluding the zero vector, and $\\mathbf{k} = \\frac{2\\pi}{L}(n_x, n_y, n_z)$ and $k=|\\mathbf{k}|$. The prefactor is for Coulomb interactions under tin-foil boundary conditions with the Coulomb constant set to unity (dimensionless reduced units).\n\nError constraints and cutoffs: To maintain consistent truncation errors across different $\\alpha$ values, we select cutoffs from the following bounds:\n- Real-space cutoff $r_{\\mathrm{cut}}$ such that $\\mathrm{erfc}(\\alpha r_{\\mathrm{cut}}) \\le \\varepsilon_{\\mathrm{real}}$ and $r_{\\mathrm{cut}} \\le L/2$.\n- Reciprocal-space magnitude cutoff $K$ such that $\\exp(-K^2/(4\\alpha^2)) \\le \\varepsilon_{\\mathrm{rec}}$, yielding $K \\ge 2\\alpha \\sqrt{\\ln(1/\\varepsilon_{\\mathrm{rec}})}$. This translates to an integer cutoff $n_{\\max} = \\left\\lfloor \\frac{K L}{2\\pi} \\right\\rfloor$, with $n_{\\max} \\ge 1$.\n\nStructural correlation: The charge–charge radial distribution function is defined as\n$$\ng_{qq}(r) = \\frac{1}{N \\rho \\, 4\\pi r^2 \\Delta r} \\sum_{i \\ne j} q_i q_j \\, \\chi\\!\\left(r \\le r_{ij} < r + \\Delta r\\right),\n$$\nwith $r_{ij}$ computed using the minimum-image convention. The normalization $N \\rho \\, 4\\pi r^2 \\Delta r$ equals the expected number of pairs in a shell in a homogeneous reference with unit charge-squared density per ion, making $g_{qq}(r)$ dimensionless.\n\nAlgorithmic design:\n1. Initialize a strongly correlated configuration as two interpenetrating simple-cubic sublattices, with the second sublattice offset by $(L/4, L/4, L/4)$ so that nearest neighbors are oppositely charged at separations less than $L/2$. Add small random displacements to each particle to break perfect symmetry.\n2. For each test case $(\\alpha, \\varepsilon_{\\mathrm{real}}, \\varepsilon_{\\mathrm{rec}})$, compute $r_{\\mathrm{cut}}$ from $\\mathrm{erfc}(\\alpha r_{\\mathrm{cut}}) \\le \\varepsilon_{\\mathrm{real}}$ and clamp to $L/2$, and compute $K$ from $\\exp(-K^2/(4\\alpha^2)) \\le \\varepsilon_{\\mathrm{rec}}$ to obtain $n_{\\max} = \\lfloor K L/(2\\pi) \\rfloor$ with $n_{\\max} \\ge 1$. Construct the list of reciprocal wavevectors accordingly.\n3. Compute total forces as $\\mathbf{F}_i = \\mathbf{F}_i^{\\mathrm{real}} + \\mathbf{F}_i^{\\mathrm{rec}}$. The real-space sum runs over all distinct pairs $i<j$ with $r_{ij} \\le r_{\\mathrm{cut}}$, enforcing Newton’s third law by adding $\\mathbf{F}_{ij}^{\\mathrm{real}}$ to $i$ and subtracting it from $j$. The reciprocal-space sum precomputes $S(\\mathbf{k})$ and accumulates the force on each ion via the formula above.\n4. Perform $S$ gradient-descent relaxation steps with a small step size $\\gamma$, updating positions $\\mathbf{r}_i \\leftarrow \\mathbf{r}_i + \\gamma \\mathbf{F}_i$ and applying periodic wrapping $\\mathbf{r}_i \\leftarrow \\mathbf{r}_i \\bmod L$ after each step.\n5. Compute $g_{qq}(r)$ using $M$ bins over $[0, L/2)$ with width $\\Delta r = (L/2)/M$. For each pair $i<j$, compute $r_{ij}$ via the minimum-image convention, place it in the appropriate bin, and accumulate $2 q_i q_j$ (the factor of $2$ accounts for $i \\ne j$ in the definition).\n6. Use the baseline $\\alpha$ curve as a reference and compute, for each case including the baseline, the maximum absolute binwise difference compared to the baseline. Compare this maximum deviation to the tolerance $\\tau$ to obtain a boolean.\n\nWhy this tests the effect of $\\alpha$: In the full Ewald sum, observables are independent of $\\alpha$. With truncations constrained by fixed $\\varepsilon_{\\mathrm{real}}$ and $\\varepsilon_{\\mathrm{rec}}$, varying $\\alpha$ shifts the allocation of error between real and reciprocal spaces but bounds the overall error. If the computed structural correlation $g_{qq}(r)$ is robust with respect to $\\alpha$ under these constraints, the maximum deviation will be small. The gradient-descent relaxation is a physically motivated proxy: it moves the ions along forces computed under the chosen $\\alpha$ and cutoffs, producing slightly different relaxed configurations that reflect the sensitivity of forces and hence structure to $\\alpha$ within the bounded truncation errors.\n\nTest suite specifics:\n- Box edge length $L = 1$; volume $V=1$; number of ions $N=16$.\n- Charges alternate between $+1$ and $-1$ on the two sublattices as described.\n- Random displacement magnitude less than $0.02 L$.\n- Baseline and test cases:\n  - Case A: $\\alpha = 2$, $\\varepsilon_{\\mathrm{real}}=10^{-3}$, $\\varepsilon_{\\mathrm{rec}}=10^{-2}$.\n  - Case B: $\\alpha = 4$, $\\varepsilon_{\\mathrm{real}}=10^{-3}$, $\\varepsilon_{\\mathrm{rec}}=10^{-2}$.\n  - Case C: $\\alpha = 6$, $\\varepsilon_{\\mathrm{real}}=10^{-3}$, $\\varepsilon_{\\mathrm{rec}}=10^{-2}$.\n- Relaxation parameters: $S=15$, $\\gamma=0.002$.\n- Radial distribution function: $M=20$ bins over $[0, L/2)$.\n- Tolerance: $\\tau = 0.1$.\n\nThe final output is a single line: a list of three booleans for Case A (baseline), Case B, and Case C, indicating whether the maximum deviation of $g_{qq}(r)$ relative to the baseline is less than or equal to $\\tau$. No units are used because all quantities are dimensionless.\n\nThis design integrates foundational principles (Coulomb’s law, periodic boundary conditions, Ewald decomposition) with algorithmic choices (error-bounded cutoffs, gradient descent, histogram-based $g_{qq}(r)$) to assess the robustness of a structural observable to the Ewald parameter under controlled truncation errors.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc, erfcinv\n\ndef build_initial_configuration(L: float, jitter_amp: float = 0.02):\n    \"\"\"\n    Build two interpenetrating simple-cubic sublattices in a cubic box of edge L.\n    Sublattice B is offset by (L/4, L/4, L/4) relative to sublattice A.\n    Charges: +1 on A, -1 on B. Add small random jitter to each particle.\n    Returns positions (N,3) and charges (N,).\n    \"\"\"\n    # Simple-cubic grid with spacing L/2: points at {0, L/2} in each dimension.\n    base_coords = []\n    for ix in [0.0, 0.5 * L]:\n        for iy in [0.0, 0.5 * L]:\n            for iz in [0.0, 0.5 * L]:\n                base_coords.append([ix, iy, iz])\n    base_coords = np.array(base_coords, dtype=float)  # shape (8,3)\n\n    # Sublattice A: base coords (8 points), charge +1\n    A_positions = base_coords.copy()\n    A_charges = np.ones(len(A_positions), dtype=float)\n\n    # Sublattice B: base coords offset by L/4 in each direction, modulo L, charge -1\n    offset = np.array([0.25 * L, 0.25 * L, 0.25 * L], dtype=float)\n    B_positions = (base_coords + offset) % L\n    B_charges = -np.ones(len(B_positions), dtype=float)\n\n    positions = np.vstack([A_positions, B_positions])  # (16,3)\n    charges = np.concatenate([A_charges, B_charges])   # (16,)\n\n    # Add small random jitter to break perfect symmetry\n    rng = np.random.default_rng(seed=42)\n    jitter = (rng.random(positions.shape) - 0.5) * 2.0 * jitter_amp * L\n    positions = (positions + jitter) % L\n\n    return positions, charges\n\ndef minimum_image(dr, L):\n    \"\"\"\n    Apply minimum-image convention to displacement vectors dr with box length L.\n    \"\"\"\n    return dr - L * np.round(dr / L)\n\ndef select_cutoffs(alpha: float, L: float, eps_real: float, eps_rec: float):\n    \"\"\"\n    Select real-space cutoff rcut and reciprocal-space integer cutoff nmax\n    based on the error bounds:\n        erfc(alpha * rcut) <= eps_real\n        exp(-K^2 / (4 alpha^2)) <= eps_rec, where K = 2*pi*nmax / L\n    Enforce rcut <= L/2 and nmax >= 1.\n    \"\"\"\n    # Real-space cutoff from erfc(alpha rcut) <= eps_real\n    # erfcinv returns x such that erfc(x) = y, so rcut >= erfcinv(eps_real)/alpha\n    rcut_min = float(erfcinv(eps_real) / alpha)\n    # Clamp to [0, L/2]\n    rcut = min(L / 2.0, max(rcut_min, 0.0))\n\n    # Reciprocal cutoff magnitude K >= 2*alpha*sqrt(log(1/eps_rec))\n    K_min = 2.0 * alpha * np.sqrt(np.log(1.0 / eps_rec))\n    # Integer cutoff nmax such that (2*pi/L) * nmax >= K_min\n    nmax = int(np.floor((K_min * L) / (2.0 * np.pi)))\n    nmax = max(1, nmax)\n\n    return rcut, nmax\n\ndef build_k_vectors(L: float, nmax: int):\n    \"\"\"\n    Build list of reciprocal-space k-vectors up to integer cutoff nmax,\n    excluding the zero vector. Returns array of shape (M,3).\n    \"\"\"\n    ks = []\n    two_pi_over_L = 2.0 * np.pi / L\n    for nx in range(-nmax, nmax + 1):\n        for ny in range(-nmax, nmax + 1):\n            for nz in range(-nmax, nmax + 1):\n                if nx == 0 and ny == 0 and nz == 0:\n                    continue\n                k = np.array([nx, ny, nz], dtype=float) * two_pi_over_L\n                ks.append(k)\n    return np.array(ks, dtype=float)\n\ndef ewald_forces(positions: np.ndarray, charges: np.ndarray, L: float,\n                 alpha: float, rcut: float, k_vectors: np.ndarray):\n    \"\"\"\n    Compute Ewald forces under tin-foil boundary conditions with given alpha,\n    real-space cutoff rcut, and a set of reciprocal-space k-vectors.\n    Returns forces array of shape (N,3).\n    \"\"\"\n    N = positions.shape[0]\n    V = L ** 3\n    forces = np.zeros_like(positions)\n\n    # Real-space sum: pairwise forces for r <= rcut under minimum image\n    for i in range(N - 1):\n        ri = positions[i]\n        qi = charges[i]\n        for j in range(i + 1, N):\n            rj = positions[j]\n            qj = charges[j]\n            dr = rj - ri\n            dr = minimum_image(dr, L)\n            r = np.linalg.norm(dr)\n            if r <= 1e-12:\n                continue\n            if r <= rcut:\n                # Real-space force vector\n                # F = q_i q_j [ erfc(alpha r)/r^3 + 2 alpha / sqrt(pi) * exp(-(alpha r)^2)/r^2 ] * dr\n                term = erfc(alpha * r) / (r ** 3)\n                term += (2.0 * alpha / np.sqrt(np.pi)) * np.exp(-(alpha * r) ** 2) / (r ** 2)\n                fij = qi * qj * term * dr\n                forces[i] += fij\n                forces[j] -= fij\n\n    # Reciprocal-space sum: structure factor and forces\n    if k_vectors.size > 0:\n        # Compute structure factor S'(k) = sum_j q_j exp(i k·r_j)\n        phases = positions @ k_vectors.T  # shape (N, M)\n        Sk = (charges[:, None] * np.exp(1j * phases)).sum(axis=0)  # shape (M,)\n        # Accumulate forces\n        for m in range(k_vectors.shape[0]):\n            k = k_vectors[m]\n            k2 = float(np.dot(k, k))\n            if k2 <= 1e-20:\n                continue\n            # Prefactor for Coulomb under tin-foil boundary\n            pref = (4.0 * np.pi / V) * np.exp(-k2 / (4.0 * alpha ** 2)) / k2\n            # For each ion i: F_i += q_i * Im[ S'(k) * exp(-i k·r_i) ] * pref * k\n            # Where S'(k) is sum(q_j * exp(+ik.r_j)). This results in a negative sign relative to the standard force expression.\n            e_terms = np.exp(-1j * phases[:, m])\n            im_vals = np.imag(Sk[m] * e_terms)  # shape (N,)\n            forces -= (charges * im_vals * pref)[:, None] * k\n\n    return forces\n\ndef relax_positions(positions: np.ndarray, charges: np.ndarray, L: float,\n                    alpha: float, eps_real: float, eps_rec: float,\n                    steps: int, step_size: float):\n    \"\"\"\n    Perform gradient-descent relaxation under Ewald forces with cutoffs selected\n    from error bounds. Returns relaxed positions and the cutoffs used.\n    \"\"\"\n    rcut, nmax = select_cutoffs(alpha, L, eps_real, eps_rec)\n    k_vectors = build_k_vectors(L, nmax)\n    pos = positions.copy()\n    for _ in range(steps):\n        F = ewald_forces(pos, charges, L, alpha, rcut, k_vectors)\n        pos = (pos + step_size * F) % L\n    return pos, rcut, nmax\n\ndef g_qq(positions: np.ndarray, charges: np.ndarray, L: float, M: int):\n    \"\"\"\n    Compute charge–charge radial distribution function g_qq(r) using M bins over [0, L/2).\n    Returns bin centers and g_qq values.\n    \"\"\"\n    N = positions.shape[0]\n    V = L ** 3\n    rho = N / V\n    r_max = L / 2.0\n    dr = r_max / M\n    r_centers = (np.arange(M) + 0.5) * dr\n    accum = np.zeros(M, dtype=float)\n\n    # Accumulate pair contributions\n    for i in range(N - 1):\n        ri = positions[i]\n        qi = charges[i]\n        for j in range(i + 1, N):\n            rj = positions[j]\n            qj = charges[j]\n            dr_vec = minimum_image(rj - ri, L)\n            r = np.linalg.norm(dr_vec)\n            if r >= r_max or r <= 1e-12:\n                continue\n            b = int(r / r_max * M)\n            if 0 <= b < M:\n                accum[b] += 2.0 * qi * qj  # account for i != j\n\n    # Normalize\n    shell_volumes = 4.0 * np.pi * (r_centers ** 2) * dr\n    # Avoid division by zero for the first bin if r_center is 0\n    shell_volumes[shell_volumes < 1e-12] = 1.0\n    g = accum / (N * rho * shell_volumes)\n    g[shell_volumes < 1e-12] = 0.0\n    return r_centers, g\n\ndef solve():\n    # Define constants and test cases from the problem statement.\n    L = 1.0  # dimensionless box length\n    N = 16\n    steps = 15\n    step_size = 0.002\n    M_bins = 20\n    tau = 0.1  # tolerance for max absolute difference in g_qq\n\n    # Build initial configuration\n    positions0, charges = build_initial_configuration(L, jitter_amp=0.02)\n\n    # Test cases: (alpha, eps_real, eps_rec)\n    test_cases = [\n        (2.0, 1e-3, 1e-2),  # Case A (baseline)\n        (4.0, 1e-3, 1e-2),  # Case B\n        (6.0, 1e-3, 1e-2),  # Case C\n    ]\n\n    # Relax and compute g_qq for each case, starting from the same initial configuration\n    g_curves = []\n    for alpha, eps_real, eps_rec in test_cases:\n        pos_relaxed, rcut, nmax = relax_positions(\n            positions0, charges, L, alpha, eps_real, eps_rec, steps, step_size\n        )\n        _, g = g_qq(pos_relaxed, charges, L, M_bins)\n        g_curves.append(g)\n\n    # Use Case A as baseline\n    g_base = g_curves[0]\n    results = []\n    for idx, g in enumerate(g_curves):\n        max_dev = float(np.max(np.abs(g - g_base)))\n        results.append(max_dev <= tau)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}