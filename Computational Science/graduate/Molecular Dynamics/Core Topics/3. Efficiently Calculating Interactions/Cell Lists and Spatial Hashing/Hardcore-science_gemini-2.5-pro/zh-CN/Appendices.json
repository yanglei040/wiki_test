{
    "hands_on_practices": [
        {
            "introduction": "在开发任何科学计算算法时，首要任务是确保其正确性。本练习将指导您建立一个“黄金标准”测试，通过将高效的 $\\mathcal{O}(N)$ 单元列表算法的计算结果与一个简单但缓慢的 $\\mathcal{O}(N^2)$ 暴力计算方法进行比较 。完成此练习将使您对自己的实现充满信心，并对算法的边界情况，特别是涉及周期性边界条件的情况，有更深刻的理解。",
            "id": "3400627",
            "problem": "要求您编写一个完整、可运行的程序，通过与高精度暴力参考方法进行比较，来验证基于均匀单元列表（空间哈希）的邻居搜索的完备性。其上下文为分子动力学（MD），其中成对相互作用取决于粒子间的欧几里得距离。计算域是一个边长为 $L$ 的周期性超立方体，采用周期性边界条件（PBC），邻居关系由最小镜像约定（MIC）定义。该程序必须适用于维度 $d \\in \\{2,3\\}$。\n\n基本原理和定义：\n- 牛顿粒子系统通过距离进行成对相互作用；因此，根据 Newton 运动定律和成对相互作用的定义，要一致地计算力，前提是识别出截断半径 $r_c$ 内的所有粒子对。\n- $\\mathbb{R}^d$ 中的欧几里得范数定义了距离。在 PBC下，MIC 将两个位置 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$ 之间的位移定义为 $\\mathbf{r}_{ij} = \\mathbf{x}_j - \\mathbf{x}_i - L \\,\\mathrm{round}\\!\\left((\\mathbf{x}_j - \\mathbf{x}_i)/L\\right)$，其中除法和四舍五入是逐分量应用的。\n- 单元列表将计算域离散化为一个边长为 $h$ 的均匀单元网格，通过整数除法将每个粒子哈希到一个单元中，然后仅检查相邻单元中的粒子，足以保证任何两个在 $r_c$ 距离内的粒子都被考虑到。\n\n您的程序必须为每个测试用例执行以下操作：\n1. 在 $[0,L)^d$ 范围内均匀随机生成粒子位置，或通过指定的构造方法生成，适用时使用提供的随机种子。\n2. 使用双精度暴力检查，计算所有满足 $\\lVert \\mathbf{r}_{ij} \\rVert \\le r_c$ 的无序索引对 $\\{i,j\\}$（其中 $i  j$）的集合 $S_{\\mathrm{BF}}$。使用上面定义的 MIC，并包含一个小的非负容差来处理浮点数比较。\n3. 通过正确的单元列表邻居搜索计算所有找到的无序索引对 $\\{i,j\\}$ 的集合 $S_{\\mathrm{CL}}$。该搜索使用名义单元边长为 $h$ 的均匀网格、周期性边界条件，并搜索欧几里得几何要求的所有偏移单元，以确保任何间隔距离至多为 $r_c$ 的粒子对都必须被枚举。实现不得假设 $h \\ge r_c$，并且对于任何 $h  0$ 都必须保持正确。\n4. 为测试用例返回一个布尔值，指示 $S_{\\mathrm{CL}} = S_{\\mathrm{BF}}$ 是否成立。\n\n假设和约束：\n- 位置采用约化的无量纲单位；您必须报告無量纲的结果。不需要物理单位。\n- 截断关系“在 $r_c$ 内”解释为 $\\lVert \\mathbf{r}_{ij} \\rVert \\le r_c$。\n- 盒子是一个边长为 $L$ 的 $d$ 维立方体，每个维度上都有 PBC。\n- 所有索引都是从零开始的整数。\n\n测试套件：\n为以下六个测试用例提供结果。对于每个用例，您将获得维度 $d$、粒子数 $N$、边长 $L$、截断半径 $r_c$、名义单元尺寸 $h$、需要的随机种子以及配置类型。\n\n- 情况 A（理想路径，三维，$h = r_c$）：$d=3$, $N=256$, $L=10.0$, $r_c=1.1$, $h=1.1$, 种子 $=1234$, 配置：在 $[0,L)^d$ 上均匀随机。\n- 情况 B（非整数网格，$h  r_c$，强调邻居偏移半径）：$d=3$, $N=1000$, $L=20.0$, $r_c=1.9$, $h=1.71$, 种子 $=7$, 配置：在 $[0,L)^d$ 上均匀随机。\n- 情况 C（二维，$h = r_c$）：$d=2$, $N=400$, $L=10.0$, $r_c=2.5$, $h=2.5$, 种子 $=2023$, 配置：在 $[0,L)^d$ 上均匀随机。\n- 情况 D（边界集中以强调 PBC）：$d=3$, $N=200$, $L=6.0$, $r_c=2.9$, $h=2.9$, 种子 $=99$, 配置：一半粒子均匀分布在 $[0,w)^d$ 中，一半分布在 $[L-w,L)^d$ 中，其中 $w=0.3$。\n- 情况 E（PBC 下具有解析期望的微小系统）：$d=3$, $N=3$, $L=1.0$, $r_c=0.25$, $h=0.25$, 配置：显式位置 $\\mathbf{x}_0=(0.02,0.02,0.02)$, $\\mathbf{x}_1=(0.21,0.02,0.02)$, $\\mathbf{x}_2=(0.85,0.02,0.02)$。\n- 情况 F（密集，多邻居，$h$ 小于 $r_c$）：$d=3$, $N=500$, $L=5.0$, $r_c=1.2$, $h=0.6$, 种子 $=555$, 配置：在 $[0,L)^d$ 上均匀随机。\n\n输出规格：\n- 对于每种情况，计算一个布尔值，指示单元列表找到的邻居对是否与暴力破解找到的邻居对完全匹配。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[true,false,true]”）。使用 Python布尔字面量“True”或“False”，不带额外的空格。\n\n交付成果：\n- 一个单一、完整、可运行的程序，执行所有计算并打印指定的最后一行。不需要用户输入。所有计算必须是自包含的，并且可以从上述参数重现。",
            "solution": "问题陈述被评估为有效。它提出了一个来自计算物理领域的明确定义的任务，具体是在分子动力学模拟中验证用于邻居查找的单元列表算法。该问题具有科学依据，逻辑一致，并且所有参数都已指定，从而允许一个唯一且可验证的解决方案。关于在给定“名义”单元边长 $h$ 的情况下将模拟盒子离散化为单元的确切方法存在一个轻微的模糊之处，通过采用一个标准且合理的实现选择得以解决，下文将详述。类似地，关于浮点容差的说明通过确保参考算法和测试算法中的算術运算在位级别上完全相同来解决，这是最严格的验证方法。\n\n该解决方案的实现方式是：为每个测试用例执行两个独立的计算并比较它们的结果。第一个是暴力（$S_{\\mathrm{BF}}$）计算，作为高精度参考。第二个是单元列表（$S_{\\mathrm{CL}}$）算法，即被测试的方法。当且仅当 $S_{\\mathrm{CL}} = S_{\\mathrm{BF}}$ 时，验证成功。\n\n**1. 暴力参考计算 ($S_{\\mathrm{BF}}$)**\n真实邻居对的集合 $S_{\\mathrm{BF}}$ 是通过检查粒子索引 $i  j$ 的每个可能的唯一粒子对 $\\{i,j\\}$ 来计算的。对于每对粒子，计算位移矢量 $\\Delta\\mathbf{x} = \\mathbf{x}_j - \\mathbf{x}_i$。为了考虑周期性边界条件 (PBC)，使用最小镜像约定 (MIC) 对该矢量进行校正。MIC 位移矢量 $\\mathbf{r}_{ij}$ 由问题中指定的公式给出：\n$$\n\\mathbf{r}_{ij} = \\Delta\\mathbf{x} - L \\cdot \\mathrm{round}(\\Delta\\mathbf{x} / L)\n$$\n其中 $L$ 是立方体域的边长，并且操作是逐分量执行的。然后，欧几里得距离的平方为 $\\lVert \\mathbf{r}_{ij} \\rVert^2$。如果该距离满足截断标准，则将一对粒子 $\\{i,j\\}$ 添加到集合 $S_{\\mathrm{BF}}$ 中：\n$$\n\\lVert \\mathbf{r}_{ij} \\rVert^2 \\le r_c^2\n$$\n其中 $r_c$ 是截断半径。对 $N$ 个粒子的所有 $\\frac{N(N-1)}{2}$ 个唯一粒子对执行此过程。生成的粒子对集合（存储为 $i  j$ 的元组）构成了“黄金标准”参考。\n\n**2. 单元列表算法 ($S_{\\mathrm{CL}}$)**\n此方法分三个阶段进行：(1) 将模拟盒子离散化为均匀的单元网格；(2) 将每个粒子哈希（或分箱）到其对应的单元格中；(3) 对每个粒子，搜索其所在单元格及邻近单元格以查找邻居。\n\n- **网格离散化：** 给定一个“名义”单元边长 $h$，一个标准方法是确定每个维度上的单元数 $m_d$，使得实际单元边长 $h_{\\mathrm{actual},d} = L/m_d$ 尽可能接近 $h$。对于立方体盒子，我们计算 $m = \\max(1, \\mathrm{round}(L/h))$，并对所有维度使用这个值，从而得到实际单元边长 $h_{\\mathrm{actual}} = L/m$。\n- **粒子哈希：** 将每个粒子 $i$ 的坐标 $\\mathbf{x}_i$ 除以实际单元边长 $h_{\\mathrm{actual}}$ 并取整，得到其整数单元索引 $(c_x, c_y, c_z)$。然后，将所有粒子存储在一个数据结构中，该结构允许按单元索引进行高效查找。一个`defaultdict(list)` 是一个简单的实现。\n- **邻居搜索：** 为了保证完备性，对于一个给定的粒子，我们不仅要检查其自身单元格内的粒子，还要检查其邻近单元格内的粒子。所需的搜索半径（以单元为单位）为 $s_{rad} = \\lceil r_c / h_{\\mathrm{actual}} \\rceil$。这意味着我们必须检查一个以粒子所在单元格为中心的、尺寸为 $(2s_{rad}+1)^d$ 的单元格块。对于每个粒子 $i$，我们遍历这个邻居模板中的所有单元格。对于在这些单元格中找到的每个粒子 $j$，为了避免重复计数和自相互作用，我们只考虑满足 $j>i$ 的对。然后，我们计算它们之间的 MIC 距离，如果距离小于等于 $r_c$，则将该对 $\\{i,j\\}$ 添加到集合 $S_{\\mathrm{CL}}$ 中。\n\n**3. 验证**\n最后，对两个集合进行比较：`s_bf == s_cl`。如果它们相等，则测试通过。\n\n**代码实现**\n该实现遵循了上述逻辑。`run_case` 函数封装了单个测试用例的逻辑。`solve` 函数定义了测试套件并以指定的格式打印最终结果。`numpy` 用于高效的向量化操作，`itertools.product` 用于生成邻居单元偏移量，`defaultdict` 用于单元列表数据结构。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nimport itertools\nfrom collections import defaultdict\n\ndef run_case(d, N, L, r_c, h, seed, config_type, config_params=None):\n    \"\"\"\n    Runs a single test case, comparing a brute-force neighbor search\n    with a cell-list-based search. Returns True if the results match.\n    \n    Args:\n        d (int): Dimension of the system.\n        N (int): Number of particles.\n        L (float): Side length of the periodic box.\n        r_c (float): Cutoff radius for neighbor search.\n        h (float): Nominal cell edge length.\n        seed (int or None): Random seed for particle generation.\n        config_type (str): Type of particle configuration ('uniform', 'boundary', 'explicit').\n        config_params (dict or None): Additional parameters for configuration.\n        \n    Returns:\n        bool: True if the set of pairs from cell list matches brute force, False otherwise.\n    \"\"\"\n    \n    # 1. Generate Particle Positions\n    if seed is not None:\n        rng = np.random.default_rng(seed)\n    \n    if config_type == \"uniform\":\n        positions = rng.uniform(0.0, L, size=(N, d))\n    elif config_type == \"boundary\":\n        w = config_params['w']\n        N_half = N // 2\n        pos1 = rng.uniform(0.0, w, size=(N_half, d))\n        pos2 = rng.uniform(L - w, L, size=(N - N_half, d))\n        positions = np.vstack((pos1, pos2))\n    elif config_type == \"explicit\":\n        positions = np.array(config_params['positions'], dtype=np.float64)\n    else:\n        raise ValueError(f\"Unknown configuration type: {config_type}\")\n\n    r_c_sq = r_c * r_c\n\n    # 2. Brute-Force Reference Calculation (S_BF)\n    s_bf = set()\n    for i in range(N):\n        for j in range(i + 1, N):\n            dr = positions[j] - positions[i]\n            # Apply Minimum Image Convention (MIC)\n            dr_mic = dr - L * np.round(dr / L)\n            dist_sq = np.sum(dr_mic**2)\n            \n            # The problem mentions a tolerance, but for validation of two computational\n            # methods on the same machine, bit-wise identical comparisons are the most\n            # stringent test. Both methods use the same floating-point arithmetic.\n            if dist_sq = r_c_sq:\n                s_bf.add((i, j))\n\n    # 3. Cell List Algorithm (S_CL)\n    s_cl = set()\n\n    # 3.1. Grid Discretization\n    m_per_dim = max(1, int(round(L / h)))\n    h_actual = L / m_per_dim\n    \n    # 3.2. Particle Hashing\n    cell_list = defaultdict(list)\n    for i in range(N):\n        # Particle coordinates are in [0, L), so floor(pos/h_actual) gives indices in [0, m_per_dim-1].\n        cell_idx = tuple(np.floor(positions[i] / h_actual).astype(int))\n        cell_list[cell_idx].append(i)\n\n    # 3.3. Neighbor Search\n    s_rad = math.ceil(r_c / h_actual)\n    offsets = list(itertools.product(range(-s_rad, s_rad + 1), repeat=d))\n    \n    for i in range(N):\n        pos_i = positions[i]\n        home_cell_idx = np.floor(pos_i / h_actual).astype(int)\n        \n        for offset in offsets:\n            np_offset = np.array(offset)\n            neighbor_cell_idx = tuple((home_cell_idx + np_offset) % m_per_dim)\n            \n            if neighbor_cell_idx in cell_list:\n                for j in cell_list[neighbor_cell_idx]:\n                    # Enforce j > i to check each pair only once and avoid self-pairs.\n                    if j = i:\n                        continue\n                    \n                    pos_j = positions[j]\n                    dr = pos_j - pos_i\n                    dr_mic = dr - L * np.round(dr / L)\n                    dist_sq = np.sum(dr_mic**2)\n                    \n                    if dist_sq = r_c_sq:\n                        s_cl.add((min(i,j), max(i,j)))\n    \n    # 4. Validation: Compare the two sets of pairs\n    return s_bf == s_cl\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the results.\n    \"\"\"\n    test_cases = [\n        # Case A: happy path, 3D, h = r_c\n        {'d': 3, 'N': 256, 'L': 10.0, 'r_c': 1.1, 'h': 1.1, 'seed': 1234, 'config_type': 'uniform', 'config_params': None},\n        # Case B: h  r_c, stress neighbor offset radius\n        {'d': 3, 'N': 1000, 'L': 20.0, 'r_c': 1.9, 'h': 1.71, 'seed': 7, 'config_type': 'uniform', 'config_params': None},\n        # Case C: 2D, h = r_c\n        {'d': 2, 'N': 400, 'L': 10.0, 'r_c': 2.5, 'h': 2.5, 'seed': 2023, 'config_type': 'uniform', 'config_params': None},\n        # Case D: boundary concentration to stress PBC\n        {'d': 3, 'N': 200, 'L': 6.0, 'r_c': 2.9, 'h': 2.9, 'seed': 99, 'config_type': 'boundary', 'config_params': {'w': 0.3}},\n        # Case E: tiny system with analytic expectation\n        {'d': 3, 'N': 3, 'L': 1.0, 'r_c': 0.25, 'h': 0.25, 'seed': None, 'config_type': 'explicit', 'config_params': {'positions': [[0.02, 0.02, 0.02], [0.21, 0.02, 0.02], [0.85, 0.02, 0.02]]}},\n        # Case F: dense, many neighbors, h  r_c\n        {'d': 3, 'N': 500, 'L': 5.0, 'r_c': 1.2, 'h': 0.6, 'seed': 555, 'config_type': 'uniform', 'config_params': None},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(**case)\n        results.append(str(result))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "使用单元列表算法的主要动机是将计算复杂度从 $\\mathcal{O}(N^2)$ 降低到 $\\mathcal{O}(N)$。本练习涉及建立一个简单的线性性能模型，该模型捕捉了单元列表构建过程中的核心成本。您将使用假设的性能数据来拟合该模型，从而将抽象的复杂度分析与实际的性能预测联系起来 。这项技能对于优化科学计算代码至关重要。",
            "id": "3400658",
            "problem": "一个短程相互作用的分子动力学（MD）模拟使用带有空间哈希的单元列表来加速邻居搜索。在每次构建邻居列表时，会出现两个主要的算法阶段：通过将其位置哈希到单元格中，将 $N$ 个粒子中的每一个分配到离散的空间单元格中；以及扫描附近的单元格以评估固定截断半径内的候选对。假设粒子数密度均匀，截断半径固定，每个粒子的平均候选邻居数表示为 $n$。在这些假设下，将单次邻居列表构建的总壁钟运行时间 $T(N,n)$ 建模为两个贡献的总和：一个是由于每个粒子的分箱操作而与 $N$ 成比例，另一个是由于每个邻居对的评估而与候选对总数 $N n$ 成比例。每个粒子的分箱操作和每个邻居的评估分别产生未知的、正常数平均成本 $c_b$ 和 $c_p$。\n\n您获得了来自固定硬件平台上的单线程实现的三个经验测量值，每个测量值报告了一次邻居列表构建的 $(N, n, T)$：\n- 运行 $1$：$N = 1.0 \\times 10^{5}$，$n = 40$，$T = 0.241 \\ \\mathrm{s}$。\n- 运行 $2$：$N = 2.0 \\times 10^{5}$，$n = 60$，$T = 0.730 \\ \\mathrm{s}$。\n- 运行 $3$：$N = 4.0 \\times 10^{5}$，$n = 80$，$T = 1.93 \\ \\mathrm{s}$。\n\n从刚才描述的算法步骤及其缩放比例的第一性原理出发，首先推导出一个关于 $N$ 和 $Nn$ 线性且不包含加性常数偏移的 $T(N,n)$ 成本模型。接下来，使用所提供的数据，通过线性最小二乘法拟合参数 $c_b$ 和 $c_p$。\n\n最后，使用您拟合的参数，预测在 $N = 3.0 \\times 10^{5}$ 和 $n = 50$ 时构建邻居列表的运行时间。将您预测的运行时间四舍五入到四位有效数字，并以 $\\mathrm{s}$ 为单位表示。",
            "solution": "该问题要求根据给定的经验数据建立并拟合一个邻居列表构建的性能模型，然后用该模型进行预测。\n\n**1. 成本模型的推导**\n\n问题描述指出了总时间 $T(N,n)$ 的两个主要来源：\n1.  **分箱成本 ($T_{binning}$)**：将 $N$ 个粒子分配到单元格中。此操作对每个粒子执行一次，因此成本与 $N$ 成正比。$T_{binning} = c_b N$，其中 $c_b$ 是每个粒子的平均分箱成本。\n2.  **对评估成本 ($T_{pairs}$)**：检查候选邻居对。平均而言，每个粒子有 $n$ 个候选邻居，因此总共有 $Nn$ 个候选对需要评估。此成本与总对数 $Nn$ 成正比。$T_{pairs} = c_p (Nn)$，其中 $c_p$ 是评估每对邻居的平均成本。\n\n总成本模型是这两个贡献的总和，且不包含常数偏移项：\n$$ T(N,n) = c_b N + c_p Nn $$\n该模型在参数 $c_b$ 和 $c_p$ 上是线性的。\n\n**2. 线性最小二乘拟合**\n\n我们可以将模型重写为 $T = c_b N + c_p (Nn)$。这可以表示为线性系统 $\\mathbf{y} = \\mathbf{X}\\mathbf{c}$，其中 $\\mathbf{y}$ 是观测时间向量，$\\mathbf{X}$ 是设计矩阵，$\\mathbf{c}$ 是待求参数的向量。\n\n根据给定的三组数据，我们有：\n$$\n\\mathbf{X} = \\begin{pmatrix}\nN_1  N_1 n_1 \\\\\nN_2  N_2 n_2 \\\\\nN_3  N_3 n_3\n\\end{pmatrix} = \\begin{pmatrix}\n1.0 \\times 10^5  4.0 \\times 10^6 \\\\\n2.0 \\times 10^5  12.0 \\times 10^6 \\\\\n4.0 \\times 10^5  32.0 \\times 10^6\n\\end{pmatrix}\n$$\n$$\n\\mathbf{y} = \\begin{pmatrix} T_1 \\\\ T_2 \\\\ T_3 \\end{pmatrix} = \\begin{pmatrix} 0.241 \\\\ 0.730 \\\\ 1.93 \\end{pmatrix}, \\quad \\mathbf{c} = \\begin{pmatrix} c_b \\\\ c_p \\end{pmatrix}\n$$\n参数 $\\mathbf{c}$ 的最小二乘解由正规方程给出：$\\mathbf{c} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}$。\n\n为了简化计算，我们可以对 $\\mathbf{X}$ 和 $\\mathbf{c}$ 进行缩放。设 $x_{1,i} = N_i / 10^5$，$x_{2,i} = (N_i n_i) / 10^6$。模型变为 $T_i = c'_b x_{1,i} + c'_p x_{2,i}$，其中 $c'_b = 10^5 c_b$ 和 $c'_p = 10^6 c_p$。\n新设计矩阵为 $\\mathbf{X}' = \\begin{pmatrix} 1  4 \\\\ 2  12 \\\\ 4  32 \\end{pmatrix}$。\n\n计算 $\\mathbf{X}'^T \\mathbf{X}' = \\begin{pmatrix} 21  156 \\\\ 156  1184 \\end{pmatrix}$ 和 $\\mathbf{X}'^T \\mathbf{y} = \\begin{pmatrix} 9.421 \\\\ 71.484 \\end{pmatrix}$。\n矩阵的行列式为 $\\det(\\mathbf{X}'^T \\mathbf{X}') = 21 \\cdot 1184 - 156^2 = 528$。\n逆矩阵为 $(\\mathbf{X}'^T \\mathbf{X}')^{-1} = \\frac{1}{528} \\begin{pmatrix} 1184  -156 \\\\ -156  21 \\end{pmatrix}$。\n\n求解缩放后的参数 $\\mathbf{c}'$：\n$$\n\\begin{pmatrix} c'_b \\\\ c'_p \\end{pmatrix} = \\frac{1}{528} \\begin{pmatrix} 1184  -156 \\\\ -156  21 \\end{pmatrix} \\begin{pmatrix} 9.421 \\\\ 71.484 \\end{pmatrix} = \\frac{1}{528} \\begin{pmatrix} 2.96 \\\\ 31.488 \\end{pmatrix}\n$$\n所以 $c'_b = 2.96 / 528 \\approx 0.005606$ 和 $c'_p = 31.488 / 528 = 0.059636$。\n\n**3. 运行时间预测**\n\n我们使用拟合的模型来预测 $N_{new} = 3.0 \\times 10^5$ 和 $n_{new} = 50$ 时的运行时间 $T_{pred}$。\n首先计算新的缩放变量：\n- $x_{1,new} = N_{new} / 10^5 = 3.0$\n- $x_{2,new} = (N_{new} n_{new}) / 10^6 = (3.0 \\times 10^5 \\times 50) / 10^6 = 15.0$\n\n现在，预测运行时间：\n$$\nT_{pred} = c'_b x_{1,new} + c'_p x_{2,new} = (2.96/528) \\cdot 3 + (31.488/528) \\cdot 15 = \\frac{8.88 + 472.32}{528} = \\frac{481.2}{528} \\approx 0.9113636... \\ \\mathrm{s}\n$$\n\n**4. 四舍五入**\n\n将结果四舍五入到四位有效数字，得到 $0.9114$ s。",
            "answer": "$$\n\\boxed{0.9114}\n$$"
        },
        {
            "introduction": "许多高级模拟，例如研究晶体结构或剪切应力下的系统，需要使用非正交（三斜）的模拟盒子。本练习将单元列表的概念推广到由晶格矩阵 $H$ 定义的一般周期性区域，并引入了数值稳定性的关键概念，通过分析矩阵的条件数来评估潜在的计算误差 。通过解决这个问题，您将学会如何处理复杂的几何形状，并意识到当模拟单元高度倾斜时可能出现的数值陷阱。",
            "id": "3400609",
            "problem": "考虑一个由晶格矩阵 $H \\in \\mathbb{R}^{3 \\times 3}$ 表示的周期性分子动力学域，其中笛卡尔位置向量 $r \\in \\mathbb{R}^{3}$ 通过线性关系 $r = H s$ 与分数坐标 $s \\in \\mathbb{R}^{3}$ 相关联。周期性边界条件通过识别相差晶格向量整数倍组合的位置来强制执行，即对于任何整数向量 $k \\in \\mathbb{Z}^{3}$，$s$ 和 $s + k$ 代表等效点。在构建单元列表和空间哈希时，一个常见的需求是使用模运算将分数坐标卷绕回规范的单位晶胞中，然后将卷绕后的分数坐标映射到离散的单元索引。\n\n从周期性边界和线性坐标变换的基本定义出发，实现以下内容：\n\n1.  给定 $H$ 和一组笛卡尔位置 $\\{r_i\\}$，通过求解 $H s_i = r_i$ 来计算分数坐标 $s_i$。使用一个不显式构造 $H^{-1}$ 的数值稳定的线性求解器。\n2.  使用模1运算将 $s_i$ 的每个分量卷绕到半开区间 $[0, 1)$ 中，以获得 $s_i^{\\mathrm{wrap}}$。使用一种对接近 $0$ 和 $1$ 的浮点舍入误差具有鲁棒性的卷绕规则。\n3.  给定一个每个维度的单元计数的向量 $m = (m_x, m_y, m_z) \\in \\mathbb{N}^3$，通过将 $[0, 1)$ 沿维度 $d \\in \\{x, y, z\\}$ 均匀分箱成 $m_d$ 个箱子，将每个卷绕后的分数坐标 $s_i^{\\mathrm{wrap}}$ 映射到整数单元索引 $(c_x, c_y, c_z)$。然后通过无冲突的线性化 $h_i = c_x \\cdot m_y \\cdot m_z + c_y \\cdot m_z + c_z$ 计算空间哈希 $h_i \\in \\mathbb{N}$。\n4.  通过计算谱条件数 $\\kappa_2(H)$ 和放大因子 $A(H, r_0, \\delta)$ 来量化数值稳定性，其中 $A(H, r_0, \\delta) = \\frac{\\lVert s(r_0 + \\delta) - s(r_0) \\rVert_2}{\\lVert \\delta \\rVert_2}$ 且 $s(\\cdot)$ 表示 $H s = r$ 的解。讨论 $A$ 和 $\\kappa_2(H)$ 之间的预期关系。\n5.  通过为每个测试用例计算 $k_i = s_i - s_i^{\\mathrm{wrap}}$ 在所有位置和维度上与整数的最大绝对偏差，即 $\\max_{i,d} \\left| k_{i,d} - \\mathrm{round}(k_{i,d}) \\right|$，来验证卷绕操作与周期性识别的一致性。\n\n物理单位：$H$ 和 $r_i$ 的所有条目均以纳米 (nm) 表示。此问题不涉及角度。程序输出是无量纲的，因为它包含无量纲的索引、条件数和比率。\n\n测试套件：使用以下3个测试用例。对每个用例，计算上述量。\n\n- 用例 1（正交盒子）：\n  - $H = \\mathrm{diag}(3.0, 2.0, 1.5)$ (nm)。\n  - 位置 $r_1 = (3.1, -0.1, 1.6)$ (nm)，$r_2 = (-0.01, 0.99, -1.5)$ (nm)，$r_3 = (2.9999999999, 1.9999999999, 1.4999999999)$ (nm)。\n  - 单元 $m = (4, 5, 6)$。\n  - 用于放大的扰动：$\\delta = (10^{-9}, -2 \\cdot 10^{-9}, 10^{-9})$ (nm)，应用于 $r_1$。\n\n- 用例 2（中度倾斜的三斜盒子）：\n  - $H = \\begin{pmatrix} 2.0  0.5  0.2 \\\\ 0.0  2.5  0.3 \\\\ 0.0  0.0  3.0 \\end{pmatrix}$ (nm)。\n  - 位置 $r_1 = (2.3, 1.2, 3.1)$ (nm)，$r_2 = (-0.2, 2.6, -0.1)$ (nm)，$r_3 = (4.1, 0.0, 0.0)$ (nm)。\n  - 单元 $m = (5, 4, 3)$。\n  - 用于放大的扰动：$\\delta = (10^{-9}, -2 \\cdot 10^{-9}, 10^{-9})$ (nm)，应用于 $r_1$。\n\n- 用例 3（高度倾斜且近奇异的盒子）：\n  - $H = \\begin{pmatrix} 1.0  0.999999  0.0 \\\\ 0.0  10^{-6}  0.0 \\\\ 0.0  0.0  2.0 \\end{pmatrix}$ (nm)。\n  - 位置 $r_1 = (1.0, 0.0, 0.0)$ (nm)，$r_2 = (10^{-6}, 10^{-6}, 0.0)$ (nm)，$r_3 = (0.0, 0.0, 0.1)$ (nm)。\n  - 单元 $m = (10, 10, 2)$。\n  - 用于放大的扰动：$\\delta = (10^{-9}, -2 \\cdot 10^{-9}, 10^{-9})$ (nm)，应用于 $r_1$。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个方括号括起来的逗号分隔列表。每个元素对应一个测试用例，并且本身是一个包含四个元素的列表：\n- 条件数 $\\kappa_2(H)$（浮点数），\n- 放大因子 $A(H, r_0, \\delta)$（浮点数），\n- $k_i = s_i - s_i^{\\mathrm{wrap}}$ 与整数的最大绝对偏差（浮点数），\n- 所提供位置的空间哈希整数列表 $[h_1, h_2, \\dots]$。\n\n例如，对于三个用例，输出的结构必须是 $[[\\kappa_2, A, \\mathrm{dev}, [h_1,h_2,h_3]], [\\kappa_2, A, \\mathrm{dev}, [h_1,h_2,h_3]], [\\kappa_2, A, \\mathrm{dev}, [h_1,h_2,h_3]]]$。",
            "solution": "问题陈述已通过验证，并被认为是合理的。这是一个在计算物理和数值方法领域中适定、有科学依据的问题，所有必要的数据和定义都已提供。\n\n解决方案通过为每个测试用例实现五个指定的任务来进行。每个任务的基本原理和实现细节概述如下。\n\n**1. 分数坐标（$s_i$）的计算**\n\n笛卡尔位置向量 $r$ 与其对应的分数坐标向量 $s$ 之间的关系由线性系统 $r = H s$ 给出，其中 $H$ 是 $3 \\times 3$ 的晶格矩阵。要为一组给定的笛卡尔位置 $\\{r_i\\}$ 找到分数坐标，我们必须对每个 $s_i$ 求解线性方程组 $H s_i = r_i$。\n\n问题要求使用一个数值稳定的求解器，该求解器不显式计算矩阵逆 $H^{-1}$。在数值线性代数中通常不鼓励使用显式逆矩阵，因为它可能精度较低，并且计算成本比直接求解法更高。标准的数值库提供了基于矩阵分解（例如，带部分主元选择的 LU 分解）的求解器，这些求解器满足这些要求。我们将使用 `numpy.linalg.solve`，它实现了这样一个稳定的算法。对于一组 $N$ 个位置向量，我们可以将这些向量组合成一个矩阵并有效地求解该系统。如果笛卡尔坐标作为行存储在矩阵 $R \\in \\mathbb{R}^{N \\times 3}$ 中，我们通过求解系统 $H S^T = R^T$ 来求解分数坐标 $S \\in \\mathbb{R}^{N \\times 3}$。\n\n**2. 卷绕分数坐标（$s_i^{\\mathrm{wrap}}$）**\n\n分子模拟中的周期性边界条件意味着一个粒子从模拟盒子的一侧离开时，会从相对的一侧重新进入。这在数学上通过将分数坐标 $s$ 和 $s+k$（对于任何整数向量 $k \\in \\mathbb{Z}^3$）视为等同来处理。通常会选择一种规范表示，即将所有分数坐标映射到一个单位晶胞中，例如 $[0, 1) \\times [0, 1) \\times [0, 1)$。\n\n此卷绕操作通过对分数坐标向量 $s_i$ 的每个分量进行模1运算来执行。一种将值 $x$ 映射到半开区间 $[0, 1)$ 的数值鲁棒方法由公式 $x^{\\mathrm{wrap}} = x - \\lfloor x \\rfloor$ 给出。这种方法正确处理正、负和零值的坐标，并避免了在整数边界附近的浮点问题。例如，如果 $s_d = 2.1$，则 $s_d^{\\mathrm{wrap}} = 2.1 - 2.0 = 0.1$。如果 $s_d = -0.2$，则 $s_d^{\\mathrm{wrap}} = -0.2 - (-1.0) = 0.8$。如果 $s_d = 3.0$，则 $s_d^{\\mathrm{wrap}} = 3.0 - 3.0 = 0.0$。\n\n**3. 单元索引和空间哈希（$c_i$, $h_i$）**\n\n为了加速寻找邻近粒子，模拟域通常被划分为一个由更小单元组成的网格。粒子的单元由其位置决定。给定卷绕后的分数坐标 $s_i^{\\mathrm{wrap}} \\in [0, 1)^3$ 和一个 $m = (m_x, m_y, m_z)$ 的单元网格，我们可以通过均匀分箱将 $s_i^{\\mathrm{wrap}}$ 映射到一个整数单元索引向量 $c_i = (c_x, c_y, c_z)$。维度 $d \\in \\{x, y, z\\}$ 的索引 $c_d$ 计算如下：\n$$c_d = \\lfloor s_{i,d}^{\\mathrm{wrap}} \\cdot m_d \\rfloor$$\n由于 $s_{i,d}^{\\mathrm{wrap}} \\in [0, 1)$，乘积 $s_{i,d}^{\\mathrm{wrap}} \\cdot m_d$ 在 $[0, m_d)$ 区间内，floor 函数正确地将其映射到 $m_d$ 个整数索引 $\\{0, 1, \\dots, m_d - 1\\}$ 中的一个。\n\n然后将三维单元索引 $c_i$ 线性化为单个整数哈希值 $h_i$。所提供的公式执行行主序映射：\n$$h_i = c_x \\cdot (m_y \\cdot m_z) + c_y \\cdot m_z + c_z$$\n只要单元索引 $(c_x, c_y, c_z)$ 在其有效范围内，即 $c_d \\in [0, m_d-1]$，此映射就是唯一且无冲突的。\n\n**4. 数值稳定性分析（$\\kappa_2(H)$, $A$）**\n\n$H s = r$ 的解相对于 $r$ 中扰动的稳定性是一个关键问题，特别是对于高度倾斜（非正交）的模拟盒子。\n\n谱条件数 $\\kappa_2(H) = \\lVert H \\rVert_2 \\lVert H^{-1} \\rVert_2$ 提供了这种敏感性的一般度量。一个大的 $\\kappa_2(H)$ 表示矩阵 $H$ 接近奇异（病态），输入 $r$ 中的小相对误差可能导致输出 $s$ 中的大相对误差。我们使用 `numpy.linalg.cond` 来计算它。\n\n放大因子 $A(H, r_0, \\delta) = \\frac{\\lVert s(r_0 + \\delta) - s(r_0) \\rVert_2}{\\lVert \\delta \\rVert_2}$ 量化了施加在特定位置 $r_0$ 上的特定扰动 $\\delta$ 的放大效果。令 $\\Delta r = \\delta$ 和 $\\Delta s = s(r_0 + \\delta) - s(r_0)$。根据系统的线性性质，$H(s_0 + \\Delta s) = r_0 + \\Delta r$，这意味着 $H \\Delta s = \\Delta r$。因此，$\\Delta s = H^{-1} \\Delta r$。放大因子则为：\n$$A = \\frac{\\lVert H^{-1} \\delta \\rVert_2}{\\lVert \\delta \\rVert_2}$$\n根据诱导矩阵2-范数的定义，$\\lVert H^{-1} \\rVert_2 = \\sup_{\\delta \\neq 0} \\frac{\\lVert H^{-1} \\delta \\rVert_2}{\\lVert \\delta \\rVert_2}$。因此，放大因子 $A$ 受逆矩阵范数的限制：$A \\le \\lVert H^{-1} \\rVert_2$。当 $\\delta$ 与 $H$ 对应其最小奇异值的右奇异向量对齐时，达到最大可能的放大。\n预期的关系是，大的条件数 $\\kappa_2(H)$ 意味着大的 $\\lVert H^{-1} \\rVert_2$（因为 $\\lVert H^{-1} \\rVert_2 = \\kappa_2(H) / \\lVert H \\rVert_2$），这反过来又意味着高的潜在放大 $A$。这些测试用例，特别是用例3，旨在展示这种关系：一个病态矩阵对于一个精心选择的扰动会导致大的放大因子。\n\n**5. 卷绕一致性验证**\n\n此任务验证整数向量 $k_i = s_i - s_i^{\\mathrm{wrap}}$ 确实是整数值的，正如其定义所示。我们定义 $k_i = s_i - s_i^{\\mathrm{wrap}}$。代入卷绕操作的定义 $s_i^{\\mathrm{wrap}} = s_i - \\lfloor s_i \\rfloor$，我们发现 $k_i = s_i - (s_i - \\lfloor s_i \\rfloor) = \\lfloor s_i \\rfloor$。在精确算术中，$k_i$ 的分量是整数。\n\n在浮点算术中，计算出的 $\\lfloor s_i \\rfloor$ 值可能存在微小的表示误差。量 $\\max_{i,d} \\left| k_{i,d} - \\mathrm{round}(k_{i,d}) \\right|$ 测量了 $k_i$ 的计算分量与其最近整数的最大偏差。对于一个数值上合理的实现，该值应在机器精度的数量级上，从而证实卷绕过程的完整性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases, performing coordinate transformation,\n    wrapping, hashing, and numerical stability analysis.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"H\": np.diag([3.0, 2.0, 1.5]),\n            \"r\": np.array([\n                [3.1, -0.1, 1.6],\n                [-0.01, 0.99, -1.5],\n                [2.9999999999, 1.9999999999, 1.4999999999]\n            ]),\n            \"m\": np.array([4, 5, 6]),\n            \"delta\": np.array([1e-9, -2e-9, 1e-9]),\n            \"r0_idx\": 0  # Apply perturbation to r1\n        },\n        {\n            \"H\": np.array([\n                [2.0, 0.5, 0.2],\n                [0.0, 2.5, 0.3],\n                [0.0, 0.0, 3.0]\n            ]),\n            \"r\": np.array([\n                [2.3, 1.2, 3.1],\n                [-0.2, 2.6, -0.1],\n                [4.1, 0.0, 0.0]\n            ]),\n            \"m\": np.array([5, 4, 3]),\n            \"delta\": np.array([1e-9, -2e-9, 1e-9]),\n            \"r0_idx\": 0  # Apply perturbation to r1\n        },\n        {\n            \"H\": np.array([\n                [1.0, 0.999999, 0.0],\n                [0.0, 1e-6, 0.0],\n                [0.0, 0.0, 2.0]\n            ]),\n            \"r\": np.array([\n                [1.0, 0.0, 0.0],\n                [1e-6, 1e-6, 0.0],\n                [0.0, 0.0, 0.1]\n            ]),\n            \"m\": np.array([10, 10, 2]),\n            \"delta\": np.array([1e-9, -2e-9, 1e-9]),\n            \"r0_idx\": 0  # Apply perturbation to r1\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        H = case[\"H\"]\n        r_cartesian = case[\"r\"]\n        m = case[\"m\"]\n        delta = case[\"delta\"]\n        r0 = r_cartesian[case[\"r0_idx\"]]\n\n        # Task 1: Compute fractional coordinates s_i\n        # We solve H * s_T = r_T, where T denotes transpose.\n        # r_cartesian is (N, 3), so r_cartesian.T is (3, N).\n        # s_T will be (3, N), so s is (N, 3).\n        s_T = np.linalg.solve(H, r_cartesian.T)\n        s = s_T.T\n\n        # Task 2: Wrap fractional coordinates into [0, 1)\n        s_wrap = s - np.floor(s)\n\n        # Task 3: Map to cell indices and compute spatial hash\n        m_x, m_y, m_z = m\n        # Broadcasting s_wrap (N, 3) with m (3,) automatically works element-wise\n        cell_indices = np.floor(s_wrap * m).astype(np.int64)\n        c_x = cell_indices[:, 0]\n        c_y = cell_indices[:, 1]\n        c_z = cell_indices[:, 2]\n        hashes = (c_x * m_y * m_z + c_y * m_z + c_z).tolist()\n\n        # Task 4: Quantify numerical stability\n        # Condition number\n        kappa_2 = np.linalg.cond(H, 2)\n        \n        # Amplification factor\n        s0 = np.linalg.solve(H, r0)\n        s_pert = np.linalg.solve(H, r0 + delta)\n        delta_s = s_pert - s0\n        \n        norm_delta_s_2 = np.linalg.norm(delta_s, 2)\n        norm_delta_2 = np.linalg.norm(delta, 2)\n        \n        amplification_A = norm_delta_s_2 / norm_delta_2 if norm_delta_2 > 0 else 0.0\n\n        # Task 5: Verify wrapping consistency\n        k = s - s_wrap  # By definition, this is floor(s)\n        # The deviation from the nearest integer should be near machine epsilon\n        deviation = np.max(np.abs(k - np.round(k)))\n\n        # Compile results for this case\n        case_results = [kappa_2, amplification_A, deviation, hashes]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The default string conversion for list might have spaces, so we build it carefully.\n    final_output_str = \"[\"\n    for i, res in enumerate(all_results):\n        # Format: [kappa, A, dev, [h1, h2, h3]]\n        # The inner list of hashes needs to be formatted without spaces.\n        hashes_str = f\"[{','.join(map(str, res[3]))}]\"\n        # The outer list elements need to be formatted without spaces around commas.\n        res_str = f\"[{res[0]},{res[1]},{res[2]},{hashes_str}]\"\n        final_output_str += res_str\n        if i  len(all_results) - 1:\n            final_output_str += \",\"\n    final_output_str += \"]\"\n    \n    # Using repr() on the list of lists would introduce spaces, which the prompt disallows.\n    # The custom string building above avoids this issue.\n    # Example: print(str(all_results).replace(\" \", \"\")) is another way, but less robust.\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}