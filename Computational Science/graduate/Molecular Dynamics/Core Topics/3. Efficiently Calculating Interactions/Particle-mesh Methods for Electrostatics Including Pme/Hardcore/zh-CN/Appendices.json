{
    "hands_on_practices": [
        {
            "introduction": "在周期性系统中，一个电荷会与其无限的周期性映像相互作用。任何稳健的静电学方法都必须满足一个关键要求：一个粒子不应感受到由其自身的周期性阵列及相关屏蔽电荷产生的净力。此练习  提供了一个理论推导，旨在证明粒子网格埃瓦尔德（PME）方法利用倒易点阵的基本对称性原理，内在满足了其倒易空间分量中无自相互作用力的条件。",
            "id": "3433341",
            "problem": "考虑一个电荷量为 $q$ 的单点电荷，位于边长为 $L$、体积为 $V = L^{3}$ 的立方体三重周期性模拟盒子内的位置 $\\mathbf{r}_0$。盒子中存在一个电荷密度为 $\\rho_{\\mathrm{b}} = -q/V$ 的均匀中和背景，以使盒子中的总电荷为零。在 $4\\pi \\epsilon_0 = 1$ 的高斯静电单位制下进行计算。\n\n在粒子网格埃瓦尔德 (PME) 方法中，通过使用宽度参数为 $\\alpha  0$ 的高斯屏蔽，将库仑核分裂为实空间和倒易空间两部分贡献来获得静电势，其中倒易空间的贡献是在网格上使用具有限支撑的电荷分配窗来计算的。设倒易晶格矢量为 $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{n}$，其中 $\\mathbf{n} \\in \\mathbb{Z}^{3}$，并由于电荷中性，通过构造排除了零模式 $\\mathbf{k}=\\mathbf{0}$。假设用于在倒易空间中求解泊松方程的 PME 影响函数是关于 $\\mathbf{k}$ 的实偶函数，并且电荷分配窗的傅里叶变换也是关于 $\\mathbf{k}$ 的实偶函数。\n\n从泊松方程和带有中和背景的周期性边界条件的傅里叶表示出发，并仅使用上述性质（周期性、中性、宽度参数为 $\\alpha$ 的高斯屏蔽，以及倒易空间中实偶的影响函数和分配函数），推导在电荷位置 $\\mathbf{r}_0$ 处的倒易空间电场，并由此推导作用在粒子上的倒易空间力。使用倒易晶格的对称性论证来简化表达式。\n\n在约化静电单位下，作用在粒子上的倒易空间力的精确大小 $|\\mathbf{F}^{\\mathrm{rec}}|$ 是多少？请将您的最终答案表述为一个精确的数字（不要四舍五入）。",
            "solution": "该问题要求计算在具有中和背景的周期性系统中，通过粒子网格埃瓦尔德 (PME) 方法计算的单个点电荷所受的倒易空间静电力。我们已知 PME 算法中使用的函数的几个关键性质，这些性质对于推导至关重要。\n\n首先，我们建立数学框架。该系统包含一个位于体积为 $V=L^3$、具有周期性边界条件的立方体盒子中位置 $\\mathbf{r}_0$ 处的单个电荷 $q$。电荷密度为 $\\rho(\\mathbf{r}) = q \\delta(\\mathbf{r} - \\mathbf{r}_0) - q/V$，其中第二项是均匀中和背景。我们在高斯单位制下进行计算，其中自由空间介电常数因子 $4\\pi \\epsilon_0$ 被设为 $1$。\n\n静电势 $\\phi(\\mathbf{r})$ 和电荷密度 $\\rho(\\mathbf{r})$ 可以通过关于倒易晶格矢量 $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{n}$（其中 $\\mathbf{n} \\in \\mathbb{Z}^3$）的傅里叶级数表示：\n$$ \\phi(\\mathbf{r}) = \\frac{1}{V} \\sum_{\\mathbf{k}} \\hat{\\phi}(\\mathbf{k}) e^{i\\mathbf{k}\\cdot\\mathbf{r}}, \\quad \\rho(\\mathbf{r}) = \\frac{1}{V} \\sum_{\\mathbf{k}} \\hat{\\rho}(\\mathbf{k}) e^{i\\mathbf{k}\\cdot\\mathbf{r}} $$\n其中傅里叶系数由体积积分给出：\n$$ \\hat{\\phi}(\\mathbf{k}) = \\int_V \\phi(\\mathbf{r}) e^{-i\\mathbf{k}\\cdot\\mathbf{r}} d^3r, \\quad \\hat{\\rho}(\\mathbf{k}) = \\int_V \\rho(\\mathbf{r}) e^{-i\\mathbf{k}\\cdot\\mathbf{r}} d^3r $$\n电荷密度的傅里叶系数是：\n$$ \\hat{\\rho}(\\mathbf{k}) = \\int_V \\left(q \\delta(\\mathbf{r} - \\mathbf{r}_0) - \\frac{q}{V}\\right) e^{-i\\mathbf{k}\\cdot\\mathbf{r}} d^3r = q e^{-i\\mathbf{k}\\cdot\\mathbf{r}_0} - \\frac{q}{V} \\int_V e^{-i\\mathbf{k}\\cdot\\mathbf{r}} d^3r $$\n该积分的值为 $V\\delta_{\\mathbf{k},\\mathbf{0}}$。对于 $\\mathbf{k}=\\mathbf{0}$，$\\hat{\\rho}(\\mathbf{0}) = q - q = 0$，这反映了系统的整体电荷中性。对于 $\\mathbf{k}\\neq\\mathbf{0}$，我们有 $\\hat{\\rho}(\\mathbf{k}) = q e^{-i\\mathbf{k}\\cdot\\mathbf{r}_0}$。PME 方法基于此中性条件，从倒易空间计算中排除了 $\\mathbf{k}=\\mathbf{0}$ 项。\n\n在 PME 方法中，粒子所受的力是通过分阶段构建的势来计算的。首先，点电荷被分配到网格上，这对应于与一个窗函数 $W(\\mathbf{r})$ 的卷积。在傅里叶空间中，这意味着网格化电荷密度 $\\hat{\\rho}_g(\\mathbf{k})$ 的傅里叶系数为 $\\hat{\\rho}_g(\\mathbf{k}) = \\hat{W}(\\mathbf{k}) \\hat{\\rho}(\\mathbf{k})$，其中 $\\hat{W}(\\mathbf{k})$ 是窗函数的傅里叶变换。\n\n倒易空间中的泊松方程 $-\\nabla^2\\phi = 4\\pi\\rho$ 变为 $k^2\\hat{\\phi}(\\mathbf{k}) = 4\\pi\\hat{\\rho}(\\mathbf{k})$。PME 方法使用一个包含高斯屏蔽效应的影响函数 $\\tilde{G}(\\mathbf{k})$ 来求解势的长程（倒易空间）部分。网格上势的傅里叶系数由以下公式给出：\n$$ \\hat{\\phi}_g(\\mathbf{k}) = \\tilde{G}(\\mathbf{k}) \\hat{\\rho}_g(\\mathbf{k}) = \\tilde{G}(\\mathbf{k}) \\hat{W}(\\mathbf{k}) \\hat{\\rho}(\\mathbf{k}) $$\n为了找到在 $\\mathbf{r}_0$ 处的点电荷所受的力，必须将网格势插值回粒子的位置。这个插值步骤等效于与窗函数的卷积，在傅里叶空间中，这对应于乘以其变换的复共轭 $\\hat{W}^*(\\mathbf{k})$。因此，粒子感受到的势 $\\phi_{\\text{felt}}(\\mathbf{r})$ 被构建为：\n$$ \\phi_{\\text{felt}}(\\mathbf{r}) = \\frac{1}{V} \\sum_{\\mathbf{k}\\neq\\mathbf{0}} \\hat{W}^*(\\mathbf{k}) \\hat{\\phi}_g(\\mathbf{k}) e^{i\\mathbf{k}\\cdot\\mathbf{r}} = \\frac{1}{V} \\sum_{\\mathbf{k}\\neq\\mathbf{0}} \\hat{W}^*(\\mathbf{k})\\tilde{G}(\\mathbf{k})\\hat{W}(\\mathbf{k}) \\hat{\\rho}(\\mathbf{k}) e^{i\\mathbf{k}\\cdot\\mathbf{r}} $$\n我们定义一个有效影响函数 $I(\\mathbf{k}) = |\\hat{W}(\\mathbf{k})|^2 \\tilde{G}(\\mathbf{k})$。问题陈述指明，PME 影响函数 $\\tilde{G}(\\mathbf{k})$ 是关于 $\\mathbf{k}$ 的实偶函数，并且电荷分配窗的傅里叶变换 $\\hat{W}(\\mathbf{k})$ 也是关于 $\\mathbf{k}$ 的实偶函数。\n因为 $\\hat{W}(\\mathbf{k})$ 是实的，所以 $|\\hat{W}(\\mathbf{k})|^2 = (\\hat{W}(\\mathbf{k}))^2$。因为 $\\hat{W}(\\mathbf{k})$ 和 $\\tilde{G}(\\mathbf{k})$ 都是关于 $\\mathbf{k}$ 的偶函数（即 $f(-\\mathbf{k}) = f(\\mathbf{k})$），它们的乘积 $I(\\mathbf{k}) = (\\hat{W}(\\mathbf{k}))^2 \\tilde{G}(\\mathbf{k})$ 也必须是关于 $\\mathbf{k}$ 的实偶函数。\n\n代入 $\\hat{\\rho}(\\mathbf{k})$ 并使用 $I(\\mathbf{k})$，在一般位置 $\\mathbf{r}$ 处感受到的势为：\n$$ \\phi_{\\text{felt}}(\\mathbf{r}) = \\frac{1}{V} \\sum_{\\mathbf{k}\\neq\\mathbf{0}} I(\\mathbf{k}) \\left(q e^{-i\\mathbf{k}\\cdot\\mathbf{r}_0}\\right) e^{i\\mathbf{k}\\cdot\\mathbf{r}} = \\frac{q}{V} \\sum_{\\mathbf{k}\\neq\\mathbf{0}} I(\\mathbf{k}) e^{i\\mathbf{k}\\cdot(\\mathbf{r}-\\mathbf{r}_0)} $$\n倒易空间电场为 $\\mathbf{E}^{\\mathrm{rec}}(\\mathbf{r}) = -\\nabla \\phi_{\\text{felt}}(\\mathbf{r})$。对级数逐项关于 $\\mathbf{r}$ 求导：\n$$ \\mathbf{E}^{\\mathrm{rec}}(\\mathbf{r}) = -\\frac{q}{V} \\sum_{\\mathbf{k}\\neq\\mathbf{0}} I(\\mathbf{k}) (i\\mathbf{k}) e^{i\\mathbf{k}\\cdot(\\mathbf{r}-\\mathbf{r}_0)} $$\n我们需要在电荷自身的位置 $\\mathbf{r}=\\mathbf{r}_0$ 处计算这个场：\n$$ \\mathbf{E}^{\\mathrm{rec}}(\\mathbf{r}_0) = -\\frac{iq}{V} \\sum_{\\mathbf{k}\\neq\\mathbf{0}} I(\\mathbf{k}) \\mathbf{k} e^{i\\mathbf{k}\\cdot(\\mathbf{r}_0-\\mathbf{r}_0)} = -\\frac{iq}{V} \\sum_{\\mathbf{k}\\neq\\mathbf{0}} I(\\mathbf{k}) \\mathbf{k} $$\n作用在粒子上的倒易空间力为 $\\mathbf{F}^{\\mathrm{rec}} = q \\mathbf{E}^{\\mathrm{rec}}(\\mathbf{r}_0)$：\n$$ \\mathbf{F}^{\\mathrm{rec}} = - \\frac{iq^2}{V} \\sum_{\\mathbf{k}\\neq\\mathbf{0}} I(\\mathbf{k}) \\mathbf{k} $$\n最后一步是利用对称性计算和式 $\\mathcal{S} = \\sum_{\\mathbf{k}\\neq\\mathbf{0}} I(\\mathbf{k}) \\mathbf{k}$。求和遍及所有非零的倒易晶格矢量。这些矢量的集合关于反演对称；对于和式中的每个矢量 $\\mathbf{k}$，其相反矢量 $-\\mathbf{k}$ 也存在。\n\n设被加项为矢量函数 $\\mathbf{f}(\\mathbf{k}) = I(\\mathbf{k})\\mathbf{k}$。我们分析其奇偶性。我们已经确定 $I(\\mathbf{k})$ 是一个偶函数，即 $I(-\\mathbf{k}) = I(\\mathbf{k})$。矢量 $\\mathbf{k}$ 本身是一个奇函数，$(-\\mathbf{k}) = -\\mathbf{k}$。因此，被加项是一个奇函数：\n$$ \\mathbf{f}(-\\mathbf{k}) = I(-\\mathbf{k})(-\\mathbf{k}) = I(\\mathbf{k})(-\\mathbf{k}) = -I(\\mathbf{k})\\mathbf{k} = -\\mathbf{f}(\\mathbf{k}) $$\n当在一个对称域上对一个奇函数求和时，来自每对点 $(\\mathbf{k}, -\\mathbf{k})$ 的贡献会相互抵消：\n$$ \\mathbf{f}(\\mathbf{k}) + \\mathbf{f}(-\\mathbf{k}) = \\mathbf{f}(\\mathbf{k}) - \\mathbf{f}(\\mathbf{k}) = \\mathbf{0} $$\n由于整个和式可以被排成这样的抵消对，总和为零矢量：\n$$ \\mathcal{S} = \\sum_{\\mathbf{k}\\neq\\mathbf{0}} I(\\mathbf{k}) \\mathbf{k} = \\mathbf{0} $$\n因此，作用在粒子上的倒易空间力为零：\n$$ \\mathbf{F}^{\\mathrm{rec}} = - \\frac{iq^2}{V} \\cdot \\mathbf{0} = \\mathbf{0} $$\n这个力的大小为 $|\\mathbf{F}^{\\mathrm{rec}}| = 0$。这是一个基本结果，确保了在 PME 形式体系中，粒子在倒易空间计算中不会受到来自其自身周期性镜像和屏蔽电荷的非物理“自作用力”。\n对于零值而言，具体的单位制，无论是“约化静电单位”还是其他单位制，都是无关紧要的。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "分子动力学模拟的准确性在很大程度上取决于所计算作用力的平滑度。在粒子网格方法中，当粒子穿越网格单元边界时，可能会出现力的不连续性，这会导致能量不守恒。这项动手编程练习  旨在探索B样条电荷分配方案的阶数、力的连续性以及微正则系综模拟中能量漂移之间的关系，从而让您直观地理解计算精度与计算成本之间的重要权衡。",
            "id": "3433420",
            "problem": "考虑一个边长为$L$的三维周期性立方域，其中包含一个电荷为$q$、质量为$M$的点粒子。静电势$\\phi(\\mathbf{r})$由该域中带周期性边界条件的泊松方程定义，电场为$\\mathbf{E}(\\mathbf{r}) = -\\nabla \\phi(\\mathbf{r})$。粒子-网格算法使用一个$m$阶基本B样条分配函数，将粒子电荷分配到大小为$N_x \\times N_y \\times N_z$的均匀网格上，然后以谱方法求解泊松方程，并使用相同的分配函数将电场插值回粒子位置。为了避免净电荷带来的奇异性，势的零空间频率模式被设为零。粒子使用速度Verlet方案在微正则系综动力学下进行演化，并对其位置应用周期性边界条件。\n\n仅从以下基本原理出发：微分形式的高斯定律、带周期性边界条件的泊松方程、电场定义为势的负梯度、分配过程中的电荷守恒，以及微正则时间演化中的牛顿第二定律，推导一个算法来：\n\n1.  使用$m$阶基本B样条将粒子电荷分配到网格上，使得离散化的电荷密度$\\rho(\\mathbf{r})$是守恒的，并且在每个空间维度上局域化到$m$个单元格内。\n2.  以谱方法求解离散化的泊松方程，以获得网格上的$\\phi(\\mathbf{r})$和$\\mathbf{E}(\\mathbf{r})$，并移除零模。\n3.  使用与分配时相同的$m$阶B样条，将$\\phi(\\mathbf{r})$和$\\mathbf{E}(\\mathbf{r})$插值到粒子位置。\n4.  在无量纲单位下，使用速度Verlet方法对粒子的位置和速度进行积分，其中总能量定义为$E(t) = \\frac{1}{2} M \\|\\mathbf{v}(t)\\|^2 + q \\, \\phi(\\mathbf{r}(t))$。\n\n将在网格单元边界处观察到的力不连续性定义如下：如果$i_x(t) = \\lfloor N_x x(t)/L \\rfloor$，$i_y(t) = \\lfloor N_y y(t)/L \\rfloor$和$i_z(t) = \\lfloor N_z z(t)/L \\rfloor$表示在时间$t$包含粒子的网格单元索引，那么只要$\\left(i_x(t+\\Delta t), i_y(t+\\Delta t), i_z(t+\\Delta t)\\right) \\neq \\left(i_x(t), i_y(t), i_z(t)\\right)$，就记录力的跳跃幅度$J_t = \\|\\mathbf{F}(t+\\Delta t) - \\mathbf{F}(t)\\|$。在整个包含$T$步的微正则轨道上，将最大跳跃定义为$J = \\max_t J_t$。将能量漂移定义为$\\Delta E = E(T) - E(0)$。\n\n在无量纲单位中工作，其中$L=1$，$M=1$，$q=1$。任何三角计算均隐式使用弧度。程序必须实现上述算法，并为下面测试套件中的每个测试用例计算两个量：最大力跳跃$J$和能量漂移$\\Delta E$，两者都以无量纲单位的浮点数表示。\n\n测试套件：\n-   案例1（正常路径，粗糙网格，低分配阶数）：$m=1$，$N_x=N_y=N_z=16$，$\\Delta t = 0.005$，$T=250$，初始位置$\\mathbf{r}_0 = (0.25, 0.37, 0.41)$，初始速度$\\mathbf{v}_0 = (0.2, 0, 0)$。\n-   案例2（增加平滑度）：$m=2$，$N_x=N_y=N_z=16$，$\\Delta t = 0.005$，$T=250$，初始位置$\\mathbf{r}_0 = (0.25, 0.37, 0.41)$，初始速度$\\mathbf{v}_0 = (0.2, 0, 0)$。\n-   案例3（更高平滑度）：$m=3$，$N_x=N_y=N_z=16$，$\\Delta t = 0.005$，$T=250$，初始位置$\\mathbf{r}_0 = (0.25, 0.37, 0.41)$，初始速度$\\mathbf{v}_0 = (0.2, 0, 0)$。\n-   案例4（集合中最高平滑度）：$m=4$，$N_x=N_y=N_z=16$，$\\Delta t = 0.005$，$T=250$，初始位置$\\mathbf{r}_0 = (0.25, 0.37, 0.41)$，初始速度$\\mathbf{v}_0 = (0.2, 0, 0)$。\n-   案例5（边缘案例，环绕边界穿越和粗糙网格）：$m=1$，$N_x=N_y=N_z=8$，$\\Delta t = 0.02$，$T=80$，初始位置$\\mathbf{r}_0 = (0.98, 0.20, 0.20)$，初始速度$\\mathbf{v}_0 = (0.05, 0, 0)$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，每个条目是一个双元素列表$[J,\\Delta E]$，对应一个测试用例，两个值都四舍五入到六位小数。例如，输出必须看起来像$[[J_1,\\Delta E_1],[J_2,\\Delta E_2],\\dots]$。",
            "solution": "我们从与粒子-网格方法相关的静电学和分子动力学基本关系开始。微分形式的高斯定律指出$\\nabla \\cdot \\mathbf{E}(\\mathbf{r}) = \\rho(\\mathbf{r})/\\varepsilon_0$，其中$\\rho(\\mathbf{r})$是电荷密度，$\\varepsilon_0$是自由空间介电常数。将其与$\\mathbf{E}(\\mathbf{r}) = -\\nabla \\phi(\\mathbf{r})$结合，我们得到泊松方程$\\nabla^2 \\phi(\\mathbf{r}) = -\\rho(\\mathbf{r})/\\varepsilon_0$。在一个三维周期性域中，该解可以通过傅里叶变换高效计算。设傅里叶变换定义为$\\hat{f}(\\mathbf{k}) = \\int_{\\text{box}} f(\\mathbf{r}) e^{-i \\mathbf{k}\\cdot \\mathbf{r}} \\, d^3 r$，其逆变换为$f(\\mathbf{r}) = (1/V)\\sum_{\\mathbf{k}} \\hat{f}(\\mathbf{k}) e^{i \\mathbf{k}\\cdot \\mathbf{r}}$，其中体积为$V=L^3$。\n\n对于非零波矢$\\mathbf{k}$，泊松方程的谱解为$\\hat{\\phi}(\\mathbf{k}) = \\hat{\\rho}(\\mathbf{k}) / (\\varepsilon_0 \\|\\mathbf{k}\\|^2)$和$\\widehat{\\nabla \\phi}(\\mathbf{k}) = i \\mathbf{k} \\hat{\\phi}(\\mathbf{k})$。零模$\\mathbf{k}=\\mathbf{0}$被设置为零，以避免在存在净电荷时出现发散，这在周期性边界条件下是一种标准且物理上一致的修正，对应于移除未定义的平均电势。\n\n粒子-网格方法通过将粒子电荷以权重总和为一的方式分配到一组相邻网格点上，从而用一个守恒的离散分布替代了连续的$\\rho(\\mathbf{r})$。对于一维中的$m$阶基本B样条分配，权重$w_j(s)$（$j=0,1,\\dots,m-1$）仅依赖于粒子在其网格单元内的分数坐标$s$，并且具有大小为$m$个单元格的紧支集，同时满足$\\sum_{j=0}^{m-1} w_j(s)=1$和非负性。在三维中，分配权重是可分离的，由一维权重的乘积给出。B样条分配确保了电荷是守恒的，并且在每个方向上平滑地分布在$m$个相邻单元格上，更高的$m$值会提供更高的连续性。\n\n一旦网格电荷密度已知，我们计算离散网格上的傅里叶变换$\\hat{\\rho}(\\mathbf{k})$。对于大小为$N_x \\times N_y \\times N_z$且边长为$L$的均匀网格，离散波数分量为$k_x = 2\\pi n_x / L$，$k_y = 2\\pi n_y / L$和$k_z = 2\\pi n_z / L$，其中$n_x \\in \\{0,1,\\dots,N_x-1\\}$，对$n_y$和$n_z$也类似，负频率由快速傅里叶变换的排序隐式表示。傅里叶空间中的格林函数是$G(\\mathbf{k}) = 1/(\\varepsilon_0 \\|\\mathbf{k}\\|^2)$（对于$\\mathbf{k}\\neq \\mathbf{0}$）和$G(\\mathbf{0})=0$。那么，傅里叶空间中的电势和电场为$\\hat{\\phi}(\\mathbf{k}) = \\hat{\\rho}(\\mathbf{k}) G(\\mathbf{k})$和$\\hat{\\mathbf{E}}(\\mathbf{k}) = -i \\mathbf{k} \\hat{\\phi}(\\mathbf{k})$。通过逆快速傅里叶变换回到实空间，得到网格点上的$\\phi(\\mathbf{r})$和$\\mathbf{E}(\\mathbf{r})$。将这些场插值到粒子位置使用相同的B样条权重，以保持分配和收集操作之间的一致性。\n\n在微正则条件下，粒子的运动由牛顿第二定律$M \\, d\\mathbf{v}/dt = \\mathbf{F}(\\mathbf{r})$决定，其中$\\mathbf{F}(\\mathbf{r}) = q \\mathbf{E}(\\mathbf{r})$。我们使用速度Verlet算法进行无量纲单位下的时间积分。从时间$t$到$t+\\Delta t$的更新是\n$$\n\\mathbf{r}(t+\\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t) \\Delta t + \\frac{\\mathbf{F}(t)}{2M} \\Delta t^2,\n$$\n同时将$\\mathbf{r}(t+\\Delta t)$周期性地包裹到域$[0,L)^3$中，然后计算新的力$\\mathbf{F}(t+\\Delta t)$，接着\n$$\n\\mathbf{v}(t+\\Delta t) = \\mathbf{v}(t) + \\frac{\\mathbf{F}(t) + \\mathbf{F}(t+\\Delta t)}{2M} \\Delta t.\n$$\n总能量取为$E(t) = \\frac{1}{2} M \\|\\mathbf{v}(t)\\|^2 + q \\phi(\\mathbf{r}(t))$。使用相同的势能和相同的场力确保了离散化模型中功-能关系的一致性。能量漂移最终定义为$\\Delta E = E(T) - E(0)$，对于一个包含$T$步的轨道。\n\n当粒子穿过网格单元边界时，力的不连续性源于$m$阶B样条分配的有限支集和连续性类别。对于低$m$值（例如$m=1$，最近邻网格点），当穿越单元边界时，分配的密度会不连续地变化，导致网格求解的场出现不连续性，从而在插值力中产生跳跃。对于更高的$m$值（例如$m=3$和$m=4$），分配会产生达到特定阶数的连续导数，这会减少或消除力的不连续性。我们通过监测整数网格索引何时变化来量化这一点：定义$i_x(t) = \\lfloor N_x x(t)/L \\rfloor$，对$i_y$和$i_z$也类似；每当这些索引中的任何一个在连续的时间步之间发生变化时，我们就记录跳跃幅度$J_t = \\|\\mathbf{F}(t+\\Delta t) - \\mathbf{F}(t)\\|$。在整个运行过程中的最大值是$J$，它是对所选$m$值和网格的力不连续性严重程度的度量。\n\n算法构建：\n-   表示域和网格。使用离散傅里叶频率缩放到$2\\pi/L$来计算波数$k_x$，$k_y$和$k_z$数组。\n-   实现任意整数阶$m \\geq 1$的基本B样条权重。一个稳定的递归（类似于Cox–de Boor风格，但适用于基本节点）从$s \\in [0,1)$构建$m$个非负权重$w_j(s)$，确保单位分解$\\sum_j w_j(s) = 1$。\n-   对于分配，计算每个维度的一维权重和相应的索引偏移量。利用可分离性，通过乘积$w^{(x)}_a(s_x) w^{(y)}_b(s_y) w^{(z)}_c(s_z)$计算三维权重，并将电荷$q$以周期性包裹的方式存放到网格索引$(i_x + \\delta_a, i_y + \\delta_b, i_z + \\delta_c)$处。为了使支集以局部单元格为中心，维度$d$中的索引选择为$i_d - \\lfloor (m-1)/2 \\rfloor + j$，$j=0,\\dots,m-1$。\n-   分配后，通过三维快速傅里叶变换计算$\\hat{\\rho}(\\mathbf{k})$，构建$G(\\mathbf{k})$（零模设为零），并计算$\\hat{\\phi}(\\mathbf{k})$和$\\hat{\\mathbf{E}}(\\mathbf{k}) = -i \\mathbf{k} \\hat{\\phi}(\\mathbf{k})$。通过逆变换得到网格上的$\\phi(\\mathbf{r})$和$\\mathbf{E}(\\mathbf{r})$。\n-   对于插值，使用相同的$m$阶B样条权重，通过对支持网格点上的网格值进行加权求和，来计算$\\phi(\\mathbf{r}(t))$和$\\mathbf{E}(\\mathbf{r}(t))$，从而在粒子位置得到一致的场和势。\n-   执行速度Verlet积分，周期性地包裹位置。在每一步，跟踪网格单元索引，并在索引变化时记录跳跃幅度。累积最大跳跃$J$并计算最终的能量漂移$\\Delta E$。\n\n因为我们使用的是单个粒子，基于网格的势和场体现了网格引起的自相互作用，这在连续介质中是不存在的。这种自相互作用相对于网格是位置相关的，并导致网格诱导力，其平滑度由$m$决定。上述算法隔离了分配阶数$m$对力连续性和相应微正则积分下数值能量漂移的作用。\n\n最终程序评估所描述的五个测试用例，为每个用例计算最大力跳跃$J$和能量漂移$\\Delta E$，并输出单行，其中包含一个逗号分隔的$[J,\\Delta E]$对的列表，用方括号括起来，两个值都四舍五入到六位小数，以无量纲单位表示。",
            "answer": "```python\nimport numpy as np\n\n# Particle-Mesh Electrostatics: Force discontinuities and energy drift for different assignment orders.\n\ndef b_spline_weights(s: float, m: int) - np.ndarray:\n    \"\"\"\n    Compute cardinal B-spline weights of order m for fractional coordinate s in [0,1).\n    Uses a stable recursion ensuring partition of unity and non-negativity.\n    Returns an array of length m with weights w[0..m-1].\n    \"\"\"\n    w = np.zeros(m, dtype=float)\n    w[0] = 1.0\n    for k in range(1, m):\n        saved = 0.0\n        for j in range(0, k):\n            tmp = w[j]\n            w[j] = ((k - s) * tmp + saved) / k\n            saved = (s * tmp) / k\n        w[k] = saved\n    return w\n\n\ndef compute_k_grids(Nx, Ny, Nz, L):\n    \"\"\"\n    Compute wave-number grids kx, ky, kz for a 3D periodic box of side L\n    with Nx, Ny, Nz points per dimension.\n    \"\"\"\n    kx = 2.0 * np.pi * np.fft.fftfreq(Nx, d=L / Nx)\n    ky = 2.0 * np.pi * np.fft.fftfreq(Ny, d=L / Ny)\n    kz = 2.0 * np.pi * np.fft.fftfreq(Nz, d=L / Nz)\n    kxg, kyg, kzg = np.meshgrid(kx, ky, kz, indexing='ij')\n    return kxg, kyg, kzg\n\n\ndef deposit_charge(q, pos, grid_shape, L, m):\n    \"\"\"\n    Deposit a single particle charge q at position pos (3-vector) onto a grid of shape grid_shape\n    using m-order cardinal B-spline weights. Returns rho grid.\n    \"\"\"\n    Nx, Ny, Nz = grid_shape\n    rho = np.zeros(grid_shape, dtype=float)\n    # Compute indices and weights in each dimension\n    indices_list = []\n    weights_list = []\n    for d, N in enumerate([Nx, Ny, Nz]):\n        u = pos[d] / L * N\n        i = int(np.floor(u)) % N\n        s = u - np.floor(u)\n        w = b_spline_weights(s, m)\n        base = i - ((m - 1) // 2)\n        idx = (base + np.arange(m)) % N\n        indices_list.append(idx)\n        weights_list.append(w)\n    ix = indices_list[0]\n    iy = indices_list[1]\n    iz = indices_list[2]\n    wx = weights_list[0]\n    wy = weights_list[1]\n    wz = weights_list[2]\n    # Separable deposition\n    for a in range(m):\n        for b in range(m):\n            for c in range(m):\n                rho[ix[a], iy[b], iz[c]] += q * wx[a] * wy[b] * wz[c]\n    return rho\n\n\ndef spectral_field_and_potential(rho, L):\n    \"\"\"\n    Compute potential phi and electric field E = -grad(phi) on the grid via spectral Poisson solver.\n    Zero mode handled by setting Green's function to zero at k=0.\n    \"\"\"\n    Nx, Ny, Nz = rho.shape\n    rho_hat = np.fft.fftn(rho)\n    kxg, kyg, kzg = compute_k_grids(Nx, Ny, Nz, L)\n    k2 = kxg * kxg + kyg * kyg + kzg * kzg\n    G = np.zeros_like(k2, dtype=float)\n    nonzero = k2  0.0\n    G[nonzero] = 1.0 / k2[nonzero]\n    phi_hat = rho_hat * G\n    # Electric field in Fourier space: E_hat = -i k phi_hat\n    Ex_hat = -1j * kxg * phi_hat\n    Ey_hat = -1j * kyg * phi_hat\n    Ez_hat = -1j * kzg * phi_hat\n    # Back to real space\n    phi = np.fft.ifftn(phi_hat).real\n    Ex = np.fft.ifftn(Ex_hat).real\n    Ey = np.fft.ifftn(Ey_hat).real\n    Ez = np.fft.ifftn(Ez_hat).real\n    return phi, Ex, Ey, Ez\n\n\ndef gather_at_position(pos, field_grid, L, m):\n    \"\"\"\n    Interpolate a grid field (scalar or vector components) to the particle position pos\n    using m-order cardinal B-spline weights. field_grid may be scalar grid (phi) or component grid (Ex).\n    \"\"\"\n    Nx, Ny, Nz = field_grid.shape\n    # Compute indices and weights in each dimension\n    indices_list = []\n    weights_list = []\n    for d, N in enumerate([Nx, Ny, Nz]):\n        u = pos[d] / L * N\n        i = int(np.floor(u)) % N\n        s = u - np.floor(u)\n        w = b_spline_weights(s, m)\n        base = i - ((m - 1) // 2)\n        idx = (base + np.arange(m)) % N\n        indices_list.append(idx)\n        weights_list.append(w)\n    ix = indices_list[0]\n    iy = indices_list[1]\n    iz = indices_list[2]\n    wx = weights_list[0]\n    wy = weights_list[1]\n    wz = weights_list[2]\n    # Weighted sum\n    val = 0.0\n    for a in range(m):\n        for b in range(m):\n            for c in range(m):\n                val += wx[a] * wy[b] * wz[c] * field_grid[ix[a], iy[b], iz[c]]\n    return val\n\n\ndef compute_force_and_energy(q, pos, L, m, grid_shape):\n    \"\"\"\n    Given particle position, compute mesh-based force F and potential energy U = q * phi(pos),\n    using spectral solution of Poisson equation.\n    \"\"\"\n    rho = deposit_charge(q, pos, grid_shape, L, m)\n    phi, Ex, Ey, Ez = spectral_field_and_potential(rho, L)\n    # Interpolate field components and potential at particle pos\n    Ex_p = gather_at_position(pos, Ex, L, m)\n    Ey_p = gather_at_position(pos, Ey, L, m)\n    Ez_p = gather_at_position(pos, Ez, L, m)\n    phi_p = gather_at_position(pos, phi, L, m)\n    F = q * np.array([Ex_p, Ey_p, Ez_p], dtype=float)\n    U = q * phi_p\n    return F, U\n\n\ndef velocity_verlet_microcanonical(case):\n    \"\"\"\n    Perform microcanonical integration for a single particle under mesh-based electrostatics,\n    tracking max force jump J and energy drift DeltaE over the trajectory.\n    \"\"\"\n    # Unpack parameters\n    m = case['m']\n    Nx, Ny, Nz = case['N']\n    L = case['L']\n    dt = case['dt']\n    nsteps = case['nsteps']\n    pos = np.array(case['pos'], dtype=float)\n    vel = np.array(case['vel'], dtype=float)\n    q = case['q']\n    M = case['M']\n    grid_shape = (Nx, Ny, Nz)\n\n    # Initial force and energy\n    F, U = compute_force_and_energy(q, pos, L, m, grid_shape)\n    E_total = 0.5 * M * np.dot(vel, vel) + U\n    E_initial = E_total\n\n    # Initialize max force jump tracking\n    def cell_indices(p):\n        return (int(np.floor(p[0] / L * Nx)) % Nx,\n                int(np.floor(p[1] / L * Ny)) % Ny,\n                int(np.floor(p[2] / L * Nz)) % Nz)\n\n    idx_old = cell_indices(pos)\n    J_max = 0.0\n\n    # Time stepping\n    for _ in range(nsteps):\n        # Position update\n        pos = pos + vel * dt + (F / (2.0 * M)) * (dt ** 2)\n        # Periodic wrapping\n        pos = np.mod(pos, L)\n        # New force and potential energy\n        F_new, U_new = compute_force_and_energy(q, pos, L, m, grid_shape)\n        # Velocity update\n        vel = vel + (F + F_new) / (2.0 * M) * dt\n        # Track force jump on crossing cell boundaries\n        idx_new = cell_indices(pos)\n        if idx_new != idx_old:\n            jump = np.linalg.norm(F_new - F)\n            if jump  J_max:\n                J_max = jump\n        idx_old = idx_new\n        # Update for next iteration\n        F = F_new\n        U = U_new\n\n    # Final energy\n    E_final = 0.5 * M * np.dot(vel, vel) + U\n    DeltaE = E_final - E_initial\n    return J_max, DeltaE\n\n\ndef solve():\n    # Define test cases\n    test_cases = [\n        # Case 1\n        {'m': 1, 'N': (16, 16, 16), 'L': 1.0, 'dt': 0.005, 'nsteps': 250,\n         'pos': (0.25, 0.37, 0.41), 'vel': (0.2, 0.0, 0.0), 'q': 1.0, 'M': 1.0},\n        # Case 2\n        {'m': 2, 'N': (16, 16, 16), 'L': 1.0, 'dt': 0.005, 'nsteps': 250,\n         'pos': (0.25, 0.37, 0.41), 'vel': (0.2, 0.0, 0.0), 'q': 1.0, 'M': 1.0},\n        # Case 3\n        {'m': 3, 'N': (16, 16, 16), 'L': 1.0, 'dt': 0.005, 'nsteps': 250,\n         'pos': (0.25, 0.37, 0.41), 'vel': (0.2, 0.0, 0.0), 'q': 1.0, 'M': 1.0},\n        # Case 4\n        {'m': 4, 'N': (16, 16, 16), 'L': 1.0, 'dt': 0.005, 'nsteps': 250,\n         'pos': (0.25, 0.37, 0.41), 'vel': (0.2, 0.0, 0.0), 'q': 1.0, 'M': 1.0},\n        # Case 5 (wrap-around crossing, coarse grid)\n        {'m': 1, 'N': (8, 8, 8), 'L': 1.0, 'dt': 0.02, 'nsteps': 80,\n         'pos': (0.98, 0.20, 0.20), 'vel': (0.05, 0.0, 0.0), 'q': 1.0, 'M': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        J, dE = velocity_verlet_microcanonical(case)\n        # Round to six decimals\n        results.append([round(J, 6), round(float(dE), 6)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "除了力之外，精确计算总静电能对许多模拟应用也至关重要。PME方法的精度由网格大小和电荷分配阶数等参数决定，这些参数会引入不同来源的误差。这项计算实践  将指导您对PME倒易空间能量进行误差分析，教您如何区分k空间截断误差和插值误差，这是建立可靠且高效模拟的一项基本技能。",
            "id": "3433381",
            "problem": "考虑一个边长为 $L$ 的三维周期性立方盒子，其中包含一个 $2 \\times 2 \\times 2$ 的简单立方晶格，晶格上的点电荷符号交替：晶格位置 $(i,j,k)$ 上的电荷（其中 $i,j,k \\in \\{0,1\\}$）电量大小为 $q$，符号为 $(-1)^{i+j+k}$。这八个电荷位于位置 $\\mathbf{r}_{ijk} = \\left(\\frac{i+\\tfrac{1}{2}}{2}L, \\frac{j+\\tfrac{1}{2}}{2}L, \\frac{k+\\tfrac{1}{2}}{2}L\\right)$，形成一个电中性体系。在约化单位制下进行计算，其中库仑常数为1，基本电荷为1，长度无量纲化（$L = 1$），因此能量也无量纲化。\n\n在周期性静电学的 Ewald 求和方法中，能量的倒易空间部分由以下经过充分检验的公式给出\n$$\nE_{\\mathrm{rec}} = \\frac{1}{2V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{4\\pi}{k^2} e^{-k^2/(4\\alpha^2)} \\left| \\sum_{n} q_n e^{-i \\mathbf{k} \\cdot \\mathbf{r}_n} \\right|^2,\n$$\n其中 $V = L^3$，$k = \\|\\mathbf{k}\\|$，$\\alpha  0$ 是 Ewald 分裂参数，求和遍及倒易晶格矢量 $\\mathbf{k} = 2\\pi (m_x, m_y, m_z)/L$，其中 $m_x, m_y, m_z$ 为整数。目标量 $E_{\\mathrm{rec}}$ 可以通过将求和截断到每个轴上指标范围为 $\\{-m_{\\max},\\ldots,m_{\\max}\\}$ 的有限波矢 $\\mathbf{k}$ 集合来高精度地近似。\n\n粒子网格 Ewald (PME) 方法通过以下步骤近似计算倒易能量：\n- 使用沿各轴可分离的 $p$ 阶（$p-1$ 次）基本 B-样条权重，将电荷分配到大小为 $M \\times M \\times M$ 的规则网格上，生成网格化电荷密度。\n- 计算网格化电荷密度的离散傅里叶变换，以获得由整数三元组 $(m_x,m_y,m_z)$ 索引的网格频率分量，对应于 $\\mathbf{k} = 2\\pi (m_x,m_y,m_z)/L$。\n- 在倒易空间中应用反卷积（影响函数），以校正因 B-样条分配引起的平滑效应。对于 $p$ 阶基本 B-样条，一维影响因子由分配函数的傅里叶变换给出，在离散情况下，该变换与非归一化 sinc 函数的幂成正比，因此三维反卷积因子为\n$$\nB(\\mathbf{m}) = \\prod_{d \\in \\{x,y,z\\}} \\left[ \\operatorname{sinc}\\left( \\frac{\\pi m_d}{M} \\right) \\right]^p,\n$$\n其中 $\\operatorname{sinc}(x) = \\frac{\\sin x}{x}$，PME 影响函数将格林函数除以 $\\left|B(\\mathbf{m})\\right|^2$。\n- 在网格上计算近似倒易能量为\n$$\nE_{\\mathrm{PME}}(M,p) = \\frac{1}{2V} \\sum_{\\mathbf{m} \\neq \\mathbf{0}} \\left( \\frac{4\\pi}{k^2} e^{-k^2/(4\\alpha^2)} \\frac{1}{\\left|B(\\mathbf{m})\\right|^2} \\right) \\left| \\hat{\\rho}(\\mathbf{m}) \\right|^2,\n$$\n其中 $\\hat{\\rho}(\\mathbf{m})$ 是网格化电荷密度的离散傅里叶变换，且 $\\mathbf{k} = 2\\pi \\mathbf{m}/L$。\n\n您的任务是实现上述定义以：\n1. 通过直接计算倒易空间求和来计算高精度参考倒易能量 $E_{\\mathrm{ref}}$。求和在每个轴上使用大的截断范围 $\\{-m_{\\max},\\ldots,m_{\\max}\\}$（不包括 $\\mathbf{m} = \\mathbf{0}$），并使用精确的结构因子 $\\sum_n q_n e^{-i \\mathbf{k} \\cdot \\mathbf{r}_n}$。设置 $m_{\\max} = 20$，$L = 1$，$q = 1$ 和 $\\alpha = 4$。\n2. 对于所提供测试套件中的每个 PME 参数对 $(M,p)$，计算：\n   - 使用 $p$ 阶 B-样条电荷分配（带周期性环绕）到 $M \\times M \\times M$ 网格上，计算 PME 倒易能量 $E_{\\mathrm{PME}}(M,p)$。\n   - 截断的精确倒易能量 $E_{\\mathrm{trunc}}(M)$，其定义为仅在每个轴上的波矢指标 $m_d \\in \\{-\\lfloor M/2 \\rfloor, \\ldots, \\lfloor M/2 \\rfloor\\}$（不包括 $\\mathbf{m}=\\mathbf{0}$）范围内对精确结构因子求和，即使用与网格上可用的相同指标支持范围。\n   - 绝对总误差 $\\Delta_{\\mathrm{tot}} = \\left| E_{\\mathrm{PME}}(M,p) - E_{\\mathrm{ref}} \\right|$。\n   - k空间截断贡献 $\\Delta_{k} = \\left| E_{\\mathrm{ref}} - E_{\\mathrm{trunc}}(M) \\right|$。\n   - 插值/反卷积贡献 $\\Delta_{\\mathrm{interp}} = \\left| E_{\\mathrm{PME}}(M,p) - E_{\\mathrm{trunc}}(M) \\right|$。\n   - 优势标志 $d$，定义为：如果 $\\Delta_k  \\Delta_{\\mathrm{interp}}$（误差由有限网格范围引起的 k 空间截断主导），则 $d=0$；否则（误差由有限 B-样条阶数和分配引起插值/反卷积主导），$d=1$。\n\n使用以下测试套件，涵盖收敛性和误差来源的不同方面：\n- 测试用例 1（理想情况）：$(M,p) = (16,4)$。\n- 测试用例 2（粗网格边界）：$(M,p) = (8,4)$。\n- 测试用例 3（低 B-样条阶数边缘情况）：$(M,p) = (32,2)$。\n- 测试用例 4（高 B-样条阶数）：$(M,p) = (32,6)$。\n\n所有能量必须以指定的约化无量纲单位计算和报告。指数函数中隐含的角度以弧度为单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个包含六个数字的列表，顺序为\n$$\n\\left[ E_{\\mathrm{PME}}(M,p),\\, E_{\\mathrm{ref}},\\, \\Delta_{\\mathrm{tot}},\\, \\Delta_{k},\\, \\Delta_{\\mathrm{interp}},\\, d \\right].\n$$\n因此，整体输出格式为\n$[ [r_{11},r_{12},r_{13},r_{14},r_{15},r_{16}], [r_{21},\\ldots,r_{26}], [r_{31},\\ldots,r_{36}], [r_{41},\\ldots,r_{46}] ]$，\n其中每个 $r_{ij}$ 都是浮点数，除了 $d$ 是整数。",
            "solution": "用户提供了一个定义明确的计算问题，用于评估粒子网格 Ewald (PME) 方法计算静电能量的准确性。该问题在科学上是合理的，规范是完整的，并且计算上是可行的。我将逐步实现所需的计算。\n\n### 基于原理的设计\n\n解决方案将构建为几个函数，每个函数对应于问题陈述中描述的一个独特的物理或算法概念。这种模块化方法增强了清晰度和正确性。\n\n1.  **体系和常数定义**：首先，我们按照规定定义物理常数和粒子体系。该体系由单位周期性盒子内的一个简单立方亚晶格上的八个电荷组成。位置 $\\mathbf{r}_{ijk}$ 和电荷 $q_{ijk} = (-1)^{i+j+k}$ 已确定。整个过程使用约化单位制（$L=1$，$q=1$，库仑常数 $k_e=1$）。\n\n2.  **高精度参考能量 ($E_{\\mathrm{ref}}$)**：这是基准值。它是通过在大量倒易晶格矢量 $\\mathbf{k} = 2\\pi\\mathbf{m}/L$ 上直接对倒易能量公式求和计算得出的。求和范围覆盖分量 $m_d \\in \\{-m_{\\max}, \\dots, m_{\\max}\\}$ 的整数矢量 $\\mathbf{m}$。结构因子 $S(\\mathbf{k}) = \\sum_n q_n e^{-i\\mathbf{k} \\cdot \\mathbf{r}_n}$ 是一个关键组成部分。对于指定的交替电荷晶格，只有当 $\\mathbf{m}=(m_x, m_y, m_z)$ 的所有分量都是奇数时，$S(\\mathbf{k})$ 才非零，此时 $|S(\\mathbf{k})|^2 = 64$。利用这一特性可以显著加速 $E_{\\mathrm{ref}}$ 的计算。\n\n3.  **截断参考能量 ($E_{\\mathrm{trunc}}(M)$)**：该量分离出了因将 k 空间求和截断到 $M \\times M \\times M$ 网格上可访问的有限波矢集合而产生的误差。它的计算方式与 $E_{\\mathrm{ref}}$ 相同，但求和仅限于波矢 $\\mathbf{k} = 2\\pi\\mathbf{m}/L$，其中整数指标 $m_d$ 对应于 $M$ 点离散傅里叶变换中使用的指标（通常是 $m_d \\in \\{-\\lfloor M/2 \\rfloor, \\dots, \\lceil M/2 \\rceil - 1\\}$）。\n\n4.  **PME 能量 ($E_{\\mathrm{PME}}(M, p)$)**：这是 PME 方法计算的核心，涉及三个主要步骤：\n    a.  **电荷分配**：每个点电荷被散布到规则的 $M \\times M \\times M$ 网格上。分配到附近网格点的电荷比例由一个 $p$ 阶 B-样条决定。对于位于标度化坐标 $s$ 处的粒子，网格点 $i$ 的权重由 $B_p(s-i+c)$ 给出，其中 $B_p(x)$ 是 $p$ 阶 B-样条函数，$c$ 是一个常数偏移量。我们将使用 B-样条的标准递归定义，它在有限的支撑集上非零。为了提高效率，将使用记忆化（`@lru_cache`）实现一个 `b_spline(p, x)` 函数。\n    b.  **傅里叶变换**：使用三维快速傅里叶变换（FFT）将网格化电荷密度 $\\rho(\\mathbf{j})$ 变换到倒易空间，以获得 $\\hat{\\rho}(\\mathbf{m})$。\n    c.  **倒易空间求和**：PME 能量通过在倒易网格上求和来计算。求和中的每一项都包括傅里叶变换后电荷密度的模平方 $|\\hat{\\rho}(\\mathbf{m})|^2$、Ewald 核的倒易空间部分（“格林函数”）以及一个校正因子 $1/|B(\\mathbf{m})|^2$。这个校正或称“影响函数”解释了 B-样条电荷分配的平滑效应。函数 $B(\\mathbf{m})$ 是 B-样条本身的傅里叶变换，表示为带幂次的 sinc 函数的乘积。\n\n5.  **误差分析**：对于给定的测试用例 $(M,p)$，一旦计算出 $E_{\\mathrm{ref}}$、$E_{\\mathrm{trunc}}(M)$ 和 $E_{\\mathrm{PME}}(M, p)$，就根据定义通过它们的绝对差值计算各种误差贡献（$\\Delta_{\\mathrm{tot}}$、$\\Delta_{k}$、$\\Delta_{\\mathrm{interp}}$）。优势标志 $d$ 根据 k 空间截断误差 $\\Delta_k$ 和插值误差 $\\Delta_{\\mathrm{interp}}$ 的相对大小来设置。\n\n对所提供套件中的每个测试用例重复这整个过程。实现将使用 `numpy` 进行高效的数组操作，不需要 `scipy`，因为 `numpy` 提供了所有必需的 FFT 和数学函数。",
            "answer": "```python\nimport numpy as np\nimport math\nfrom functools import lru_cache\n\n# ==========================================================\n# Constants and System Definition\n# ==========================================================\nL = 1.0\nV = L**3\nALPHA = 4.0\nQ = 1.0\nM_MAX_REF = 20\n\n# Define the 8 charges in the system\nPARTICLES = []\nfor i in range(2):\n    for j in range(2):\n        for k in range(2):\n            pos = np.array([\n                (i + 0.5) / 2.0 * L,\n                (j + 0.5) / 2.0 * L,\n                (k + 0.5) / 2.0 * L\n            ])\n            charge = Q * (-1)**(i + j + k)\n            PARTICLES.append({'pos': pos, 'charge': charge})\n\n# ==========================================================\n# Helper Functions\n# ==========================================================\n\n@lru_cache(maxsize=None)\ndef b_spline(p, x):\n    \"\"\"\n    Recursively computes the value of a cardinal B-spline of order p at position x.\n    The B-spline B_p(x) has a support on the open interval (0, p).\n    \"\"\"\n    if p == 1:\n        return 1.0 if 0.0  x = 1.0 else 0.0\n    \n    # Check for support boundaries\n    if x = 0.0 or x = p:\n        return 0.0\n\n    term1 = (x / (p - 1)) * b_spline(p - 1, x)\n    term2 = ((p - x) / (p - 1)) * b_spline(p - 1, x - 1)\n    \n    return term1 + term2\n\ndef custom_sinc(x):\n    \"\"\"\n    Computes sin(x)/x, as specified in the problem statement.\n    \"\"\"\n    if x == 0.0:\n        return 1.0\n    return math.sin(x) / x\n\ndef calculate_e_direct(m_indices):\n    \"\"\"\n    Calculates reciprocal energy by direct summation over a given set of m-vectors.\n    Used for both E_ref and E_trunc.\n    \"\"\"\n    total_term = 0.0\n    for mx in m_indices:\n        # The structure factor is non-zero only if all m components are odd.\n        # Since fftfreq produces floats, we check this after converting to int.\n        mx_i = int(round(mx))\n        if mx_i % 2 == 0:\n            continue\n        for my in m_indices:\n            my_i = int(round(my))\n            if my_i % 2 == 0:\n                continue\n            for mz in m_indices:\n                mz_i = int(round(mz))\n                if mz_i % 2 == 0:\n                    continue\n                \n                # The m=(0,0,0) case is implicitly skipped because 0 is even.\n                m_sq = mx*mx + my*my + mz*mz\n                k_sq = (2 * math.pi / L)**2 * m_sq\n                \n                # For this lattice, |S(k)|^2 = 64 if all m are odd, 0 otherwise.\n                s_k_sq = 64.0\n                \n                term = (4 * math.pi / k_sq) * math.exp(-k_sq / (4 * ALPHA**2)) * s_k_sq\n                total_term += term\n    \n    return total_term / (2.0 * V)\n\ndef calculate_e_pme(M, p):\n    \"\"\"\n    Calculates the PME reciprocal energy for a given mesh size M and spline order p.\n    \"\"\"\n    # 1. Charge Assignment\n    rho_grid = np.zeros((M, M, M), dtype=np.float64)\n    for particle in PARTICLES:\n        q = particle['charge']\n        s = particle['pos'] / L * M  # Scaled coordinates\n        \n        weights_dims = []\n        indices_dims = []\n\n        for dim in range(3):\n            s_d = s[dim]\n            # The support of B_p(s_d - i + 1) is where 0  s_d - i + 1  p,\n            # which implies s_d + 1 - p  i  s_d + 1.\n            # This covers a range of p integers.\n            i_start = math.floor(s_d + 1.0 - p) + 1\n            \n            dim_weights = []\n            dim_indices = []\n            for i_offset in range(p):\n                i = i_start + i_offset\n                weight = b_spline(p, s_d - i + 1.0)\n                if weight  1e-15:  # Avoid storing zero-weight entries\n                    dim_weights.append(weight)\n                    dim_indices.append(i % M)\n            \n            weights_dims.append(dim_weights)\n            indices_dims.append(dim_indices)\n    \n        # Spread charge using separable B-spline weights\n        for i_x, ix in enumerate(indices_dims[0]):\n            wx = weights_dims[0][i_x]\n            for i_y, iy in enumerate(indices_dims[1]):\n                wy = weights_dims[1][i_y]\n                for i_z, iz in enumerate(indices_dims[2]):\n                    wz = weights_dims[2][i_z]\n                    rho_grid[ix, iy, iz] += q * wx * wy * wz\n\n    # 2. Fast Fourier Transform\n    hat_rho = np.fft.fftn(rho_grid)\n\n    # 3. Reciprocal Space Summation\n    m_vals = np.fft.fftfreq(M) * M\n    mx, my, mz = np.meshgrid(m_vals, m_vals, m_vals, indexing='ij')\n\n    m_sq = mx*mx + my*my + mz*mz\n    # Handle m=0 case by setting its k^2 to infinity to yield a zero contribution.\n    if M  0:\n        m_sq[0, 0, 0] = np.inf\n    \n    k_sq = (2 * math.pi / L)**2 * m_sq\n    \n    # Ewald Green's function part\n    green_k_part = (4 * math.pi / k_sq) * np.exp(-k_sq / (4 * ALPHA**2))\n    \n    # B-spline deconvolution part\n    vsinc = np.vectorize(custom_sinc)\n    sinc_mx = vsinc(math.pi * mx / M)\n    sinc_my = vsinc(math.pi * my / M)\n    sinc_mz = vsinc(math.pi * mz / M)\n    \n    b_sq = (sinc_mx * sinc_my * sinc_mz)**(2 * p)\n    # The m where sinc is zero is not in the fftfreq range, except m=0.\n    # At m=0, sinc=1, b_sq=1. green_k_part is 0, so no div-by-zero issue.\n    b_inv_sq = 1.0 / b_sq\n\n    energy_density = green_k_part * b_inv_sq * np.abs(hat_rho)**2\n    total_energy = np.sum(energy_density)\n    \n    return total_energy / (2.0 * V)\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the calculations for all test cases.\n    \"\"\"\n    # Pre-compute E_ref\n    m_ref_indices = np.arange(-M_MAX_REF, M_MAX_REF + 1)\n    e_ref = calculate_e_direct(m_ref_indices)\n\n    test_cases = [\n        (16, 4),  # happy path\n        (8, 4),   # coarse mesh boundary\n        (32, 2),  # low B-spline order edge\n        (32, 6)   # high B-spline order\n    ]\n\n    all_results = []\n    for M, p in test_cases:\n        e_pme = calculate_e_pme(M, p)\n        \n        # Calculate E_trunc for the current mesh size M\n        m_trunc_indices = np.fft.fftfreq(M) * M\n        e_trunc = calculate_e_direct(m_trunc_indices)\n        \n        delta_tot = abs(e_pme - e_ref)\n        delta_k = abs(e_ref - e_trunc)\n        delta_interp = abs(e_pme - e_trunc)\n        \n        # d=0 for k-space error dominance, d=1 for interpolation error dominance\n        d_flag = 1 if delta_interp = delta_k else 0\n        \n        case_results = [e_pme, e_ref, delta_tot, delta_k, delta_interp, d_flag]\n        all_results.append(case_results)\n\n    # Format the final output string as specified\n    # The format [r1, r2, ...] is handled by map(str,...) and join\n    # The outer brackets and comma separators for the list of lists are done similarly.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}