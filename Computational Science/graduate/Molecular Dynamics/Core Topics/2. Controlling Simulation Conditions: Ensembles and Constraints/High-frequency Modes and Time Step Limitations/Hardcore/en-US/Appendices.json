{
    "hands_on_practices": [
        {
            "introduction": "The choice of time step, $\\Delta t$, is arguably the most critical parameter in a molecular dynamics simulation. To understand its limits, we must go beyond rules of thumb and analyze the numerical integrator itself. This exercise guides you through a foundational linear stability analysis of the velocity Verlet algorithm for a simple harmonic oscillator, which serves as a proxy for any high-frequency bond vibration . By completing this derivation, you will not only determine the absolute stability condition $\\omega_{\\max} \\Delta t \\le 2$, but also explore the crucial distinction between a simulation that is merely stable and one that is physically accurate.",
            "id": "3415676",
            "problem": "A one-dimensional high-frequency vibrational mode in Molecular Dynamics (MD) can be modeled as a harmonic oscillator with potential energy $U(x) = \\frac{1}{2} k x^{2}$ and mass $m$, where $x$ is the displacement, $k$ is the force constant, and $m$ is the mass. The equation of motion follows from Newton’s second law, $m \\frac{d^{2} x}{d t^{2}} = -k x$, which defines the angular frequency $\\omega$ by $\\omega = \\sqrt{k/m}$. Consider the velocity Verlet integrator for numerical time evolution with time step $\\Delta t$. The update equations are\n$$x_{n+1} = x_{n} + v_{n} \\Delta t + \\frac{1}{2} a_{n} (\\Delta t)^{2}, \\quad v_{n+1} = v_{n} + \\frac{1}{2} \\big(a_{n} + a_{n+1}\\big) \\Delta t,$$\nwhere $a_{n} = -\\omega^{2} x_{n}$ is the acceleration at step $n$.\n\nStarting from these definitions and equations, perform a linear stability analysis of the discrete dynamics to obtain the stability condition that ensures bounded motion of the numerical solution. Then, using that result, determine the maximum time step $\\Delta t_{\\max}$ for the following physically realistic parameters:\n- $k = 500\\,\\mathrm{N/m}$,\n- $m = 1.000\\,\\mathrm{amu}$ with the conversion $1\\,\\mathrm{amu} = 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$.\n\nExpress $\\Delta t_{\\max}$ in femtoseconds and round your answer to four significant figures. Finally, justify why, in practice, one often chooses a time step substantially smaller than the maximum allowed by stability, discussing accuracy considerations for high-frequency modes beyond mere numerical stability.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of classical mechanics and numerical analysis, is well-posed with a clear objective and sufficient data, and is formulated objectively. The analysis pertains to the stability of the velocity Verlet algorithm, a cornerstone of molecular dynamics simulations.\n\nThe solution proceeds in three parts: first, a linear stability analysis to derive the stability condition; second, the calculation of the maximum stable time step for the given physical parameters; and third, a discussion on why practical time steps are chosen to be smaller than this maximum value.\n\n**1. Linear Stability Analysis**\n\nThe system is a one-dimensional harmonic oscillator with the equation of motion $m \\ddot{x} = -k x$, which can be written as $\\ddot{x} = -\\omega^2 x$, where $\\omega = \\sqrt{k/m}$ is the angular frequency. The acceleration at time step $n$ is $a_n = -\\omega^2 x_n$.\n\nThe velocity Verlet algorithm is given by the update equations:\n$$x_{n+1} = x_{n} + v_{n} \\Delta t + \\frac{1}{2} a_{n} (\\Delta t)^{2}$$\n$$v_{n+1} = v_{n} + \\frac{1}{2} \\big(a_{n} + a_{n+1}\\big) \\Delta t$$\n\nTo perform a stability analysis, we express the state of the system at step $n+1$, represented by the vector $\\mathbf{z}_{n+1} = \\begin{pmatrix} x_{n+1} \\\\ v_{n+1} \\end{pmatrix}$, as a linear transformation of the state at step $n$, $\\mathbf{z}_{n} = \\begin{pmatrix} x_{n} \\\\ v_{n} \\end{pmatrix}$. This defines the transfer matrix $\\mathbf{T}$ such that $\\mathbf{z}_{n+1} = \\mathbf{T} \\mathbf{z}_{n}$.\n\nFirst, we substitute $a_n = -\\omega^2 x_n$ into the position update equation:\n$$x_{n+1} = x_{n} + v_{n} \\Delta t - \\frac{1}{2} \\omega^{2} x_{n} (\\Delta t)^{2} = \\left(1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\\right) x_n + v_n \\Delta t$$\n\nNext, we express $v_{n+1}$ in terms of $x_n$ and $v_n$. We use $a_{n+1} = -\\omega^2 x_{n+1}$ in the velocity update equation:\n$$v_{n+1} = v_{n} + \\frac{1}{2} \\left(-\\omega^2 x_n - \\omega^2 x_{n+1}\\right) \\Delta t = v_n - \\frac{1}{2} \\omega^2 \\Delta t (x_n + x_{n+1})$$\nSubstituting the expression for $x_{n+1}$:\n$$v_{n+1} = v_n - \\frac{1}{2} \\omega^2 \\Delta t \\left(x_n + \\left(1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\\right) x_n + v_n \\Delta t\\right)$$\n$$v_{n+1} = v_n - \\frac{1}{2} \\omega^2 \\Delta t \\left(\\left(2 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\\right) x_n + v_n \\Delta t\\right)$$\n$$v_{n+1} = -\\omega^2 \\Delta t \\left(1 - \\frac{1}{4}\\omega^2 (\\Delta t)^2\\right) x_n + \\left(1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\\right) v_n$$\n\nWe can now write the system in matrix form:\n$$\\begin{pmatrix} x_{n+1} \\\\ v_{n+1} \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2  \\Delta t \\\\ -\\omega^2 \\Delta t \\left(1 - \\frac{1}{4}\\omega^2 (\\Delta t)^2\\right)  1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2 \\end{pmatrix} \\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}$$\n\nThe transfer matrix is:\n$$\\mathbf{T} = \\begin{pmatrix} 1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2  \\Delta t \\\\ -\\omega^2 \\Delta t \\left(1 - \\frac{1}{4}\\omega^2 (\\Delta t)^2\\right)  1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2 \\end{pmatrix}$$\n\nFor the numerical solution to remain bounded (stable), the magnitudes of the eigenvalues $\\lambda$ of $\\mathbf{T}$ must not exceed $1$, i.e., $|\\lambda| \\le 1$. The eigenvalues are the roots of the characteristic equation $\\lambda^2 - \\mathrm{Tr}(\\mathbf{T})\\lambda + \\det(\\mathbf{T}) = 0$. One can show that $\\det(\\mathbf{T})=1$. For the eigenvalues to have $|\\lambda|=1$, we must have $|\\mathrm{Tr}(\\mathbf{T})| \\le 2$. The trace is $\\mathrm{Tr}(\\mathbf{T}) = 2 - \\omega^2(\\Delta t)^2$.\nThus, the stability condition is:\n$$|2 - \\omega^2 (\\Delta t)^2| \\le 2$$\nThis inequality requires $2 - \\omega^2(\\Delta t)^2 \\ge -2$, which simplifies to $4 \\ge \\omega^2(\\Delta t)^2$. Since $\\omega > 0$ and $\\Delta t > 0$, we take the square root:\n$$\\omega \\Delta t \\le 2$$\nThis is the stability condition for the velocity Verlet integrator applied to a harmonic oscillator.\n\n**2. Calculation of the Maximum Time Step**\n\nThe stability condition $\\omega \\Delta t \\le 2$ gives the maximum allowed time step as $\\Delta t_{\\max} = \\frac{2}{\\omega}$. We are given the physical parameters to calculate this value.\n- $k = 500 \\, \\mathrm{N/m} = 500 \\, \\mathrm{kg/s^2}$\n- $m = 1.000 \\, \\mathrm{amu}$\n- $1 \\, \\mathrm{amu} = 1.66053906660 \\times 10^{-27} \\, \\mathrm{kg}$\n\nFirst, we calculate the mass in SI units:\n$$m = 1.000 \\times (1.66053906660 \\times 10^{-27} \\, \\mathrm{kg}) = 1.66053906660 \\times 10^{-27} \\, \\mathrm{kg}$$\n\nNext, we calculate the angular frequency $\\omega$:\n$$\\omega = \\sqrt{\\frac{k}{m}} = \\sqrt{\\frac{500 \\, \\mathrm{kg/s^2}}{1.66053906660 \\times 10^{-27} \\, \\mathrm{kg}}}$$\n$$\\omega \\approx \\sqrt{3.01106031 \\times 10^{29} \\, \\mathrm{s}^{-2}} \\approx 5.48731305 \\times 10^{14} \\, \\mathrm{rad/s}$$\n\nNow, we calculate the maximum time step $\\Delta t_{\\max}$:\n$$\\Delta t_{\\max} = \\frac{2}{\\omega} = \\frac{2}{5.48731305 \\times 10^{14} \\, \\mathrm{s}^{-1}} \\approx 3.644743 \\times 10^{-15} \\, \\mathrm{s}$$\n\nFinally, we convert the result to femtoseconds ($1 \\, \\mathrm{fs} = 10^{-15} \\, \\mathrm{s}$) and round to four significant figures:\n$$\\Delta t_{\\max} \\approx 3.644743 \\, \\mathrm{fs}$$\n$$\\Delta t_{\\max} \\approx 3.645 \\, \\mathrm{fs}$$\n\n**3. Justification for Using a Smaller Time Step**\n\nThe stability condition $\\omega \\Delta t \\le 2$ only ensures that the numerical trajectory does not diverge exponentially; it does not guarantee accuracy. In practice, molecular dynamics simulations must accurately reproduce the physical dynamics, which imposes a much stricter constraint on the time step.\n\nThe primary measure of accuracy for an oscillator is how well the numerical integration reproduces the correct frequency of oscillation. The frequency of the numerical oscillator, $\\omega_{\\text{num}}$, can be related to the true frequency $\\omega$ by:\n$$\\omega_{\\text{num}} = \\frac{1}{\\Delta t} \\arccos\\left(1 - \\frac{1}{2}(\\omega \\Delta t)^2\\right)$$\nAt the stability limit, where $\\omega \\Delta t = 2$, the equation becomes $\\cos(\\omega_{\\text{num}} \\Delta t) = 1 - \\frac{1}{2}(2)^2 = -1$. This gives $\\omega_{\\text{num}} \\Delta t = \\pi$, or $\\omega_{\\text{num}} = \\frac{\\pi}{\\Delta t} = \\frac{\\pi}{2/\\omega} = \\frac{\\pi}{2}\\omega$. The ratio of frequencies is $\\omega_{\\text{num}}/\\omega = \\pi/2 \\approx 1.57$, an error of over 57%, which is unacceptably large for any physical simulation. This illustrates that while the simulation is stable, it is highly inaccurate.\n\nIn contrast, the Taylor expansion, $\\omega_{\\text{num}} \\approx \\omega(1 - \\frac{1}{24}(\\omega \\Delta t)^2)$, which is valid for small $\\omega \\Delta t$, is more relevant for practical time step selection. It shows how the numerical frequency approaches the true frequency as the time step is reduced. The relative error in frequency is approximately $\\frac{\\omega_{\\text{num}} - \\omega}{\\omega} \\approx -\\frac{1}{24}(\\omega \\Delta t)^2$. To maintain high fidelity, this error must be kept small. For instance, to keep the relative frequency error below $1\\%$ ($0.01$), we would need:\n$$\\frac{1}{24}(\\omega \\Delta t)^2 \\lesssim 0.01 \\implies \\omega \\Delta t \\lesssim \\sqrt{0.24} \\approx 0.49$$\nThis condition, $\\omega \\Delta t \\lesssim 0.5$, is four times more restrictive than the stability condition $\\omega \\Delta t \\le 2$.\n\nA general rule of thumb in MD is to use a time step that is at least an order of magnitude smaller than the period of the fastest vibrational mode ($T = 2\\pi/\\omega$). This corresponds to $\\Delta t \\approx T/10 = (2\\pi/\\omega)/10$, or $\\omega \\Delta t \\approx 0.63$. This choice ensures that the fastest oscillation is sampled multiple times per cycle, leading to an accurate integration of its dynamics and maintaining acceptable energy conservation and phase accuracy. For the system in this problem, this practical rule would suggest a timestep of $\\Delta t \\approx \\frac{0.63}{5.487 \\times 10^{14}} \\approx 1.15 \\, \\mathrm{fs}$, which is substantially smaller than $\\Delta t_{\\max}=3.645 \\, \\mathrm{fs}$.\n\nIn summary, numerical stability is merely the threshold to prevent a simulation from exploding. Accurate and physically meaningful results require a much smaller time step to minimize the integration errors, particularly the phase error for high-frequency modes.",
            "answer": "$$\\boxed{3.645}$$"
        },
        {
            "introduction": "The stability condition derived from a simple harmonic oscillator is universally applicable to the fastest motion in any system. This principle becomes particularly important when using advanced models like polarizable force fields, which often introduce fictitious particles with very high vibrational frequencies. This practice asks you to apply the stability criterion to a Drude oscillator, a common feature in such force fields used to model electronic polarization . Calculating the maximum stable time step for this system will provide a concrete example of how new physical models can dramatically increase the computational challenge of a simulation.",
            "id": "3415640",
            "problem": "A polarizable force field can be represented by attaching to each polarizable site a one-dimensional harmonic Drude oscillator with mass $m_{D}$ and spring constant $k_{D}$. Consider a single Drude oscillator governed by Newton’s second law with a Hookean restoring force. You will analyze the explicit velocity Verlet time discretization applied to this harmonic motion to determine a conservative time step constraint that avoids numerical instability arising from the highest-frequency mode.\n\nStarting from the fundamental base that a Drude oscillator satisfies $m_{D}\\frac{d^{2}x}{dt^{2}}=-k_{D}x$ and that the velocity Verlet scheme is equivalent, for linear stability analysis, to the central-difference discretization of the second derivative, perform the following:\n\n1. Derive the discrete-time linear stability condition for integrating the harmonic oscillator $x$ governed by $m_{D}\\frac{d^{2}x}{dt^{2}}+k_{D}x=0$ with a constant time step $\\Delta t$. Your derivation must proceed by substituting a trial solution of the form $x_{n}=\\lambda^{n}$ into the central-difference equation and enforcing that the amplification factor satisfies $|\\lambda|\\leq 1$.\n\n2. Using your stability condition and the oscillator frequency $\\omega_{D}=\\sqrt{k_{D}/m_{D}}$, define the linear stability limit $\\Delta t_{\\max}$ in terms of $\\omega_{D}$, and then adopt a conservative safety factor $s=0.5$ to define $\\Delta t_{\\text{safe}}=s\\,\\Delta t_{\\max}$.\n\n3. For a representative polarizable model with $k_{D}=6.642\\times 10^{4}\\,\\text{N}\\,\\text{m}^{-1}$ and $m_{D}=6.642\\times 10^{-28}\\,\\text{kg}$, evaluate $\\Delta t_{\\text{safe}}$ numerically. Express your final time step in femtoseconds (fs), where $1\\,\\text{fs}=10^{-15}\\,\\text{s}$, and round your answer to three significant figures.\n\nProvide, in words, a brief comparison of your computed $\\Delta t_{\\text{safe}}$ to typical atomic time steps used in Molecular Dynamics (MD), such as $1\\,\\text{fs}$ and $2\\,\\text{fs}$, explaining why the presence of this high-frequency Drude mode constrains the global time step. Your final reported value must be a single number.",
            "solution": "The problem requires an analysis of the numerical stability of the velocity Verlet integration scheme applied to a harmonic Drude oscillator, which is used to model polarizability in molecular dynamics. The analysis will determine a safe integration time step $\\Delta t_{\\text{safe}}$. The problem is divided into three parts: deriving the stability condition, defining the safe time step, and calculating its numerical value for given parameters.\n\nFirst, we address the derivation of the discrete-time linear stability condition. The equation of motion for the one-dimensional Drude oscillator is given as $m_{D}\\frac{d^{2}x}{dt^{2}}=-k_{D}x$, which can be written in the standard form for a simple harmonic oscillator:\n$$\\frac{d^{2}x}{dt^{2}} + \\omega_{D}^{2}x = 0$$\nwhere $\\omega_{D} = \\sqrt{k_{D}/m_{D}}$ is the natural frequency of the oscillator.\n\nThe problem states that for linear stability analysis, the velocity Verlet scheme is equivalent to using a central-difference discretization for the second derivative. For a discrete time step $\\Delta t$, we approximate the acceleration at time $t_n = n\\Delta t$ as:\n$$\\frac{d^{2}x}{dt^{2}}\\bigg|_{t=t_n} \\approx \\frac{x_{n+1} - 2x_n + x_{n-1}}{(\\Delta t)^2}$$\nwhere $x_n = x(t_n)$. Substituting this into the equation of motion gives the finite-difference equation:\n$$\\frac{x_{n+1} - 2x_n + x_{n-1}}{(\\Delta t)^2} + \\omega_{D}^{2}x_n = 0$$\nThis can be rearranged into a linear recurrence relation for the position $x_n$:\n$$x_{n+1} = \\left(2 - (\\omega_{D}\\Delta t)^2\\right)x_n - x_{n-1}$$\nTo analyze the stability of this recurrence, we propose a trial solution of the form $x_n = \\lambda^n$, where $\\lambda$ is a complex amplification factor. A stable solution requires that the magnitude of $\\lambda$ does not exceed unity, i.e., $|\\lambda| \\le 1$. Substituting the trial solution yields:\n$$\\lambda^{n+1} = \\left(2 - (\\omega_{D}\\Delta t)^2\\right)\\lambda^n - \\lambda^{n-1}$$\nAssuming a non-trivial solution where $\\lambda \\neq 0$, we can divide by $\\lambda^{n-1}$ to get the characteristic equation, which is a quadratic equation for $\\lambda$:\n$$\\lambda^2 - \\left(2 - (\\omega_{D}\\Delta t)^2\\right)\\lambda + 1 = 0$$\nThe roots of this equation determine the behavior of the numerical solution. For the solution to remain bounded, the roots must lie within or on the unit circle in the complex plane. The roots are given by the quadratic formula:\n$$\\lambda_{\\pm} = \\frac{\\left(2 - (\\omega_{D}\\Delta t)^2\\right) \\pm \\sqrt{\\left(2 - (\\omega_{D}\\Delta t)^2\\right)^2 - 4}}{2}$$\nFor the roots to be complex or repeated real, the discriminant must be non-positive:\n$$\\Delta = \\left(2 - (\\omega_{D}\\Delta t)^2\\right)^2 - 4 \\le 0$$\nThis inequality is equivalent to:\n$$\\left(2 - (\\omega_{D}\\Delta t)^2\\right)^2 \\le 4$$\nTaking the square root of both sides, we get:\n$$-2 \\le 2 - (\\omega_{D}\\Delta t)^2 \\le 2$$\nThis compound inequality consists of two conditions. The first, $2 - (\\omega_{D}\\Delta t)^2 \\le 2$, simplifies to $-(\\omega_{D}\\Delta t)^2 \\le 0$, which is always satisfied for real $\\omega_{D}$ and $\\Delta t$. The second, $-2 \\le 2 - (\\omega_{D}\\Delta t)^2$, provides the critical constraint:\n$$(\\omega_{D}\\Delta t)^2 \\le 4$$\nSince $\\omega_D$ and $\\Delta t$ are inherently positive, we can take the square root to obtain the linear stability condition:\n$$\\omega_{D}\\Delta t \\le 2$$\nWhen this condition holds, the roots are complex conjugates with $|\\lambda|=1$, leading to a stable, non-dissipative oscillatory solution. If $\\omega_{D}\\Delta t > 2$, one root becomes real with a magnitude greater than one, leading to exponential growth and numerical instability.\n\nSecond, we use this condition to define the maximum and safe time steps. The maximum time step $\\Delta t_{\\max}$ for which the integration is stable is given by the equality:\n$$\\Delta t_{\\max} = \\frac{2}{\\omega_{D}}$$\nA conservative safety factor $s=0.5$ is applied to define a safe time step $\\Delta t_{\\text{safe}}$:\n$$\\Delta t_{\\text{safe}} = s \\cdot \\Delta t_{\\max} = 0.5 \\cdot \\frac{2}{\\omega_{D}} = \\frac{1}{\\omega_{D}}$$\n\nThird, we evaluate $\\Delta t_{\\text{safe}}$ numerically for the given parameters: $k_{D}=6.642\\times 10^{4}\\,\\text{N}\\,\\text{m}^{-1}$ and $m_{D}=6.642\\times 10^{-28}\\,\\text{kg}$.\nThe angular frequency $\\omega_D$ is:\n$$\\omega_{D} = \\sqrt{\\frac{k_{D}}{m_{D}}} = \\sqrt{\\frac{6.642\\times 10^{4}\\,\\text{N}\\,\\text{m}^{-1}}{6.642\\times 10^{-28}\\,\\text{kg}}} = \\sqrt{10^{32}\\,\\text{s}^{-2}} = 10^{16}\\,\\text{rad/s}$$\nUsing this frequency, we calculate the safe time step:\n$$\\Delta t_{\\text{safe}} = \\frac{1}{\\omega_{D}} = \\frac{1}{10^{16}\\,\\text{s}^{-1}} = 10^{-16}\\,\\text{s}$$\nTo express this value in femtoseconds ($1\\,\\text{fs} = 10^{-15}\\,\\text{s}$):\n$$\\Delta t_{\\text{safe}} = 10^{-16}\\,\\text{s} \\times \\frac{1\\,\\text{fs}}{10^{-15}\\,\\text{s}} = 0.1\\,\\text{fs}$$\nRounding to three significant figures as requested, the final value is $0.100\\,\\text{fs}$.\n\nThe computed safe time step of $\\Delta t_{\\text{safe}} = 0.100\\,\\text{fs}$ is an order of magnitude smaller than typical time steps of $1\\,\\text{fs}$ or $2\\,\\text{fs}$ used in standard molecular dynamics simulations. The reason for this severe constraint is that the numerical stability of an explicit integrator like velocity Verlet is governed by the highest-frequency motion in the system. The Drude oscillator frequency $\\omega_D = 10^{16}\\,\\text{rad/s}$ is exceptionally high, corresponding to an oscillation period of $T_D = 2\\pi/\\omega_D \\approx 0.628\\,\\text{fs}$. To prevent the numerical integration from becoming unstable, the time step must be short enough to resolve this fastest motion, requiring $\\Delta t$ to be a small fraction of $T_D$. If a typical $1\\,\\text{fs}$ time step were used, it would violate the stability criterion $\\omega_{D}\\Delta t \\le 2$ (since $10^{16}\\,\\text{s}^{-1} \\times 10^{-15}\\,\\text{s} = 10 > 2$), leading to a catastrophic failure of the simulation. Therefore, the inclusion of high-frequency Drude modes necessitates a much smaller global time step, substantially increasing the computational cost of the simulation.",
            "answer": "$$\\boxed{0.100}$$"
        },
        {
            "introduction": "While analytical derivations provide essential insight, the stability limit in a complex, non-linear system is often confirmed empirically. Instability does not simply mean the simulation stops; it manifests as a cascade of unphysical behaviors, such as exploding temperatures and a complete loss of energy conservation. In this hands-on coding exercise, you will write a program to systematically scan a range of time steps and monitor key physical observables to pinpoint the exact moment of destabilization . This practice bridges the gap between theory and application, giving you a practical tool for validating the setup of your own future simulations.",
            "id": "3415667",
            "problem": "Construct a fully specified program that empirically locates the critical time step at which high-frequency modes destabilize a simple molecular dynamics system by scanning time step values and evaluating stability diagnostics. Work entirely in reduced units where mass $m$, Boltzmann constant $k_{\\mathrm{B}}$, and characteristic length and energy scales are all equal to $1$, so no physical units are required.\n\nConsider a one-dimensional system of two identical point particles with mass $m = 1$, positions $x_0(t)$ and $x_1(t)$, and velocities $v_0(t)$ and $v_1(t)$. The pair is connected by a harmonic bond with spring constant $k_b$ and zero rest length, and each particle is tethered to the origin by a harmonic spring with spring constant $k_t$. The total potential energy is\n$$\nU(x_0,x_1) = \\tfrac{1}{2} k_t x_0^2 + \\tfrac{1}{2} k_t x_1^2 + \\tfrac{1}{2} k_b (x_1 - x_0)^2.\n$$\nFrom Newton's second law, the total forces on particle $0$ and particle $1$ are\n$$\nF_0 = -\\frac{\\partial U}{\\partial x_0} = -k_t x_0 + k_b (x_1 - x_0), \\quad F_1 = -\\frac{\\partial U}{\\partial x_1} = -k_t x_1 - k_b (x_1 - x_0).\n$$\nThe equations of motion are\n$$\nm \\frac{d^2 x_i}{dt^2} = F_i, \\quad i \\in \\{0,1\\}, \\quad m = 1.\n$$\nIntegrate the dynamics using the velocity Verlet method with uniform time step $\\Delta t$:\n- Given positions $x_i(t)$, velocities $v_i(t)$, and accelerations $a_i(t) = F_i(t)/m$ at time $t$, update\n$$\nx_i(t+\\Delta t) = x_i(t) + v_i(t)\\,\\Delta t + \\tfrac{1}{2} a_i(t)\\,\\Delta t^2,\n$$\ncompute $F_i(t+\\Delta t)$ and $a_i(t+\\Delta t) = F_i(t+\\Delta t)/m$, then update\n$$\nv_i(t+\\Delta t) = v_i(t) + \\tfrac{1}{2}\\left[a_i(t) + a_i(t+\\Delta t)\\right]\\Delta t.\n$$\n\nInitialization and observables:\n- Initialize positions at $x_0(0) = -x_{\\mathrm{init}}$, $x_1(0) = +x_{\\mathrm{init}}$, with $x_{\\mathrm{init}} = 0.1$.\n- Initialize velocities by independent draws from a normal distribution with zero mean and variance $\\sigma_v^2 = T_0/m$, with target temperature $T_0 = 1$. Use a fixed pseudorandom number generator seed of $13579$ for reproducibility, and reinitialize the random number generator with this same seed for each new scan value of $\\Delta t$ and each test case.\n- Define the instantaneous kinetic energy\n$$\nK(t) = \\tfrac{1}{2} m\\left[v_0(t)^2 + v_1(t)^2\\right],\n$$\nthe instantaneous total energy\n$$\nE(t) = K(t) + U\\big(x_0(t),x_1(t)\\big),\n$$\nand the instantaneous temperature (in reduced units with $k_{\\mathrm{B}}=1$)\n$$\nT(t) = \\frac{2\\,K(t)}{\\mathrm{dof}},\n$$\nwith total number of degrees of freedom $\\mathrm{dof} = 2$.\n- Define the root-mean-square force as the time-and-particle averaged value\n$$\nF_{\\mathrm{RMS}} = \\left(\\frac{1}{2N_s}\\sum_{n=1}^{N_s}\\sum_{i=0}^{1} F_i(t_n)^2 \\right)^{1/2},\n$$\nwhere $N_s$ is the number of sampled time points after discarding an initial equilibration segment.\n\nStability diagnostics and decision rule:\n- For a given $\\Delta t$, run $N_{\\mathrm{steps}}$ integration steps, discard the first $N_{\\mathrm{burn}}$ samples as equilibration, then evaluate:\n    - The relative standard deviation of temperature,\n    $$\n    \\delta_T = \\frac{\\mathrm{std}\\left(T\\right)}{\\mathrm{mean}\\left(T\\right)},\n    $$\n      computed over the sampled segment after burn-in.\n    - The relative peak-to-peak oscillation amplitude of total energy,\n    $$\n    \\delta_E = \\frac{\\max(E) - \\min(E)}{\\mathrm{mean}(E)},\n    $$\n      computed over the sampled segment after burn-in.\n    - The root-mean-square force $F_{\\mathrm{RMS}}$ computed over the entire trajectory after burn-in.\n- A simulation at time step $\\Delta t$ is deemed unstable if any of the following conditions are met:\n    - Early-termination triggers: at any time during integration, $|x_0|$ or $|x_1|$ exceeds $X_{\\max}$, or $|E|$ exceeds $E_{\\max}$, or any non-finite value is encountered in positions, velocities, or energies.\n    - Post-run metric thresholds: $\\delta_T > \\tau_T$, or $\\delta_E > \\tau_E$, or $F_{\\mathrm{RMS}} > \\tau_F$.\n- Use the thresholds\n$$\n\\tau_T = 0.25,\\quad \\tau_E = 0.20,\\quad \\tau_F = 10^3,\\quad X_{\\max} = 10^3,\\quad E_{\\max} = 10^6.\n$$\n\nTime step scan and threshold reporting:\n- For each test case, scan a specified range of $\\Delta t$ values on a uniform grid. The critical threshold is the smallest $\\Delta t$ in the scan for which instability is detected. If no instability is detected across the entire scan, return $-1.0$ for that test case.\n\nImplementation details and constants to use:\n- Use $N_{\\mathrm{steps}} = 5000$ and $N_{\\mathrm{burn}} = 200$ for all runs.\n- For each $\\Delta t$, reinitialize the positions and velocities from the same initial conditions and the same random seed $13579$ as specified above.\n- Use mass $m=1$, $k_{\\mathrm{B}}=1$, and degrees of freedom $\\mathrm{dof}=2$ as defined above.\n\nTest suite:\n- Case A (very stiff bond):\n    - $k_b = 1000$, $k_t = 1$, $\\Delta t$ in the interval $[0.005, 0.08]$ with increment $0.0025$.\n- Case B (moderately stiff bond):\n    - $k_b = 200$, $k_t = 1$, $\\Delta t$ in the interval $[0.01, 0.20]$ with increment $0.005$.\n- Case C (soft bond):\n    - $k_b = 20$, $k_t = 1$, $\\Delta t$ in the interval $[0.02, 0.30]$ with increment $0.01$.\n\nProgram requirements:\n- Your program must implement the above dynamics and diagnostics exactly and produce a single line of output containing the three detected thresholds for Cases A, B, and C, in that order, rounded to $6$ decimal places. If no threshold is found for a given case, output $-1.000000$ for that case.\n- Final output format: a single line containing a comma-separated Python-style list, e.g., $\"[0.045000,0.105000,-1.000000]\"$.\n\nNo input is to be read from standard input. The result must be computed entirely within the program using the specified test suite and constants, and printed in the exact output format.",
            "solution": "The problem presented is a well-posed and scientifically sound exercise in computational physics, specifically in the field of molecular dynamics. It is deemed valid and a full solution is provided below. The task is to empirically determine the critical integration time step, $\\Delta t$, at which a simple two-particle harmonic oscillator system becomes numerically unstable. This is accomplished by performing a series of molecular dynamics simulations over a range of $\\Delta t$ values and applying a set of explicit stability criteria.\n\nThe core of the problem lies in the trade-off between computational efficiency (favoring larger $\\Delta t$) and numerical accuracy and stability (requiring smaller $\\Delta t$). The stability of numerical integrators like the velocity Verlet method is limited by the highest frequency of motion within the system. For a harmonic system, this frequency is determined by the masses and spring constants. The problem is designed to demonstrate this principle by testing systems with progressively stiffer bonds (higher $k_b$), which introduce higher-frequency oscillations and thus demand smaller, more carefully chosen time steps.\n\nThe solution is implemented by following a rigorous, step-by-step procedure for each test case.\n\n**1. System Definition and Equations of Motion**\n\nThe physical system consists of two particles of mass $m=1$ at positions $x_0(t)$ and $x_1(t)$. Their interaction and confinement are described by the potential energy function:\n$$\nU(x_0, x_1) = \\frac{1}{2} k_t x_0^2 + \\frac{1}{2} k_t x_1^2 + \\frac{1}{2} k_b (x_1 - x_0)^2\n$$\nHere, $k_t$ is the spring constant tethering each particle to the origin, and $k_b$ is the spring constant of the harmonic bond connecting the two particles.\n\nThe forces acting on each particle are derived from the negative gradient of the potential energy, $F_i = -\\frac{\\partial U}{\\partial x_i}$:\n$$\nF_0 = -k_t x_0 + k_b (x_1 - x_0) = -(k_t + k_b) x_0 + k_b x_1\n$$\n$$\nF_1 = -k_t x_1 - k_b (x_1 - x_0) = k_b x_0 - (k_t + k_b) x_1\n$$\nThe accelerations are then given by Newton's second law, $a_i = F_i / m$. Since mass $m=1$, we have $a_i = F_i$.\n\n**2. Numerical Integration: The Velocity Verlet Algorithm**\n\nThe equations of motion are integrated numerically using the velocity Verlet algorithm. This is a standard, robust method that exhibits good energy conservation over long simulations. Given the state of the system—positions $x_i(t)$, velocities $v_i(t)$, and accelerations $a_i(t)$—at time $t$, the state at time $t+\\Delta t$ is computed in two stages:\n- **Stage 1 (Position Update):** The positions are advanced by a full time step $\\Delta t$:\n$$\nx_i(t+\\Delta t) = x_i(t) + v_i(t)\\,\\Delta t + \\frac{1}{2} a_i(t)\\,\\Delta t^2\n$$\n- **Stage 2 (Velocity Update):** New forces $F_i(t+\\Delta t)$ and accelerations $a_i(t+\\Delta t)$ are computed using the updated positions $x_i(t+\\Delta t)$. The velocities are then advanced by a full time step using a symmetric average of the old and new accelerations:\n$$\nv_i(t+\\Delta t) = v_i(t) + \\frac{1}{2}\\left[a_i(t) + a_i(t+\\Delta t)\\right]\\Delta t\n$$\n\n**3. Simulation Protocol and Stability Assessment**\n\nFor each parameter set (a \"test case\"), a scan is performed across a specified range of $\\Delta t$ values. For each individual $\\Delta t$ in the scan, a complete simulation is executed.\n\n- **Initialization:** For each simulation run, the system is re-initialized to ensure an independent test. Positions are set to fixed values: $x_0(0) = -0.1$ and $x_1(0) = 0.1$. Velocities $v_0(0)$ and $v_1(0)$ are drawn from a normal distribution with mean $0$ and variance $\\sigma_v^2 = T_0/m = 1/1 = 1$. Critically, the pseudorandom number generator is re-seeded with the value $13579$ for each $\\Delta t$. This guarantees that every time step is tested against the exact same initial microscopic state, making the comparison fair and reproducible.\n\n- **Integration:** The system is evolved for $N_{\\mathrm{steps}} = 5000$ steps. During the integration, two *early-termination* checks for gross instability are performed at every step:\n    1. If the absolute position of either particle, $|x_i|$, exceeds a large value $X_{\\max} = 10^3$.\n    2. If the absolute total energy, $|E|$, exceeds $E_{\\max} = 10^6$.\n    If any of these occur, or if a non-finite number (e.g., `NaN`, `inf`) is generated, the simulation for that $\\Delta t$ is immediately halted and flagged as unstable.\n\n- **Post-Run Analysis:** If the simulation completes all $5000$ steps, the trajectory data from the first $N_{\\mathrm{burn}} = 200$ steps are discarded to allow the system to equilibrate. The remaining $N_s = 4800$ steps are used to compute three diagnostic metrics:\n    1. **Temperature Fluctuation $\\delta_T$**: The relative standard deviation of the instantaneous temperature, $\\delta_T = \\mathrm{std}(T)/\\mathrm{mean}(T)$. The temperature is defined as $T(t) = 2K(t)/\\mathrm{dof} = K(t)$, where $K(t)$ is the total kinetic energy and the number of degrees of freedom is $\\mathrm{dof}=2$.\n    2. **Energy Fluctuation $\\delta_E$**: The relative peak-to-peak fluctuation of the total energy, $\\delta_E = (\\max(E) - \\min(E))/\\mathrm{mean}(E)$.\n    3. **Root-Mean-Square Force $F_{\\mathrm{RMS}}$**: The time-and-particle averaged RMS force, $F_{\\mathrm{RMS}} = \\left(\\frac{1}{2N_s}\\sum_{n=1}^{N_s}\\sum_{i=0}^{1} F_i(t_n)^2 \\right)^{1/2}$.\n\n- **Decision Rule:** The run is classified as unstable if any of the computed metrics exceed their predefined thresholds: $\\delta_T > 0.25$, $\\delta_E > 0.20$, or $F_{\\mathrm{RMS}} > 10^3$.\n\n**4. Determining the Critical Time Step**\n\nThe scan for each test case proceeds from the smallest $\\Delta t$ to the largest. The first $\\Delta t$ value for which the simulation is deemed unstable (by either early termination or post-run analysis) is the critical time step for that case. The search for that case is then terminated. If the scan completes without any simulation being flagged as unstable, a value of $-1.0$ is reported, indicating that the stability limit is beyond the tested range.\n\nThis entire procedure is automated in the provided Python code, which methodically implements each step to arrive at the final numerical results for the three specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef potential_energy(x, kb, kt):\n    \"\"\"Calculates the potential energy of the system.\"\"\"\n    x0, x1 = x\n    return 0.5 * kt * x0**2 + 0.5 * kt * x1**2 + 0.5 * kb * (x1 - x0)**2\n\ndef forces(x, kb, kt):\n    \"\"\"Calculates the forces on the particles.\"\"\"\n    x0, x1 = x\n    F0 = -kt * x0 + kb * (x1 - x0)\n    F1 = -kt * x1 - kb * (x1 - x0)\n    return np.array([F0, F1])\n\ndef run_simulation(kb, kt, dt, params):\n    \"\"\"\n    Runs a single molecular dynamics simulation for a given set of parameters.\n    Returns True if stable, False if unstable.\n    \"\"\"\n    # Unpack parameters\n    m, T0, dof, x_init_val, seed = params['m'], params['T0'], params['dof'], params['x_init'], params['seed']\n    N_steps, N_burn = params['N_steps'], params['N_burn']\n    X_max, E_max = params['X_max'], params['E_max']\n    tau_T, tau_E, tau_F = params['tau_T'], params['tau_E'], params['tau_F']\n    N_samples = N_steps - N_burn\n\n    # 1. Initialization for each run\n    rng = np.random.default_rng(seed)\n    x = np.array([-x_init_val, x_init_val])\n    v = rng.normal(loc=0.0, scale=np.sqrt(T0 / m), size=2)\n\n    # Initial calculations\n    F = forces(x, kb, kt)\n    a = F / m\n    U = potential_energy(x, kb, kt)\n    K = 0.5 * m * np.sum(v**2)\n    E = K + U\n\n    if not np.isfinite(E):\n        return False\n\n    # Data storage for post-run analysis\n    E_samples = []\n    T_samples = []\n    F_squared_sum = 0.0\n\n    # 2. Integration loop (Velocity Verlet)\n    for step in range(N_steps):\n        # Position update\n        x = x + v * dt + 0.5 * a * dt**2\n\n        # Early termination check: position\n        if np.any(np.abs(x)  X_max):\n            return False\n\n        # Force/acceleration update\n        F_new = forces(x, kb, kt)\n        a_new = F_new / m\n\n        # Velocity update\n        v = v + 0.5 * (a + a_new) * dt\n\n        # Update acceleration for next step\n        a = a_new\n\n        # Energy and other observables\n        U = potential_energy(x, kb, kt)\n        K = 0.5 * m * np.sum(v**2)\n        E = K + U\n\n        # Early termination checks: energy and finite values\n        if not np.isfinite(E) or abs(E)  E_max:\n            return False\n            \n        # 3. Data Sampling\n        if step = N_burn:\n            T = 2.0 * K / dof\n            E_samples.append(E)\n            T_samples.append(T)\n            F_squared_sum += np.sum(F_new**2)\n\n    # 4. Post-run analysis\n    E_arr = np.array(E_samples)\n    T_arr = np.array(T_samples)\n\n    if E_arr.size == 0 or T_arr.size == 0 or not np.all(np.isfinite(E_arr)) or not np.all(np.isfinite(T_arr)):\n        return False\n        \n    mean_T = np.mean(T_arr)\n    std_T = np.std(T_arr)\n    mean_E = np.mean(E_arr)\n    \n    if mean_T == 0 or mean_E == 0: # Avoid division by zero\n        return False\n\n    delta_T = std_T / mean_T\n    delta_E = (np.max(E_arr) - np.min(E_arr)) / mean_E\n    F_rms = np.sqrt(F_squared_sum / (2 * N_samples))\n\n    # 5. Decision rule\n    if delta_T  tau_T or delta_E  tau_E or F_rms  tau_F:\n        return False\n\n    return True # Stable\n\ndef find_critical_dt(case_params, sim_params):\n    \"\"\"\n    Scans a range of dt values to find the first unstable one.\n    \"\"\"\n    kb, kt, dt_start, dt_end, dt_inc = case_params\n\n    # Generate the scan range for dt, ensuring endpoint is included\n    dt_scan = np.arange(dt_start, dt_end + dt_inc * 0.5, dt_inc)\n\n    for dt in dt_scan:\n        is_stable = run_simulation(kb, kt, dt, sim_params)\n        if not is_stable:\n            return dt\n            \n    return -1.0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    sim_params = {\n        'm': 1.0, \n        'T0': 1.0, \n        'dof': 2,\n        'x_init': 0.1,\n        'seed': 13579,\n        'N_steps': 5000, \n        'N_burn': 200,\n        'X_max': 1.0e3, \n        'E_max': 1.0e6,\n        'tau_T': 0.25, \n        'tau_E': 0.20, \n        'tau_F': 1.0e3\n    }\n\n    test_cases = [\n        # (kb, kt, dt_start, dt_end, dt_inc)\n        (1000.0, 1.0, 0.005, 0.08, 0.0025),  # Case A\n        (200.0, 1.0, 0.01, 0.20, 0.005),   # Case B\n        (20.0, 1.0, 0.02, 0.30, 0.01),      # Case C\n    ]\n    \n    results = []\n    for case in test_cases:\n        critical_dt = find_critical_dt(case, sim_params)\n        results.append(critical_dt)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}