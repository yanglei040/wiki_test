{
    "hands_on_practices": [
        {
            "introduction": "在分子动力学模拟中，约束算法不仅是保持分子几何形状的工具，它们施加的约束力也是系统内部力场的组成部分，并对压力等宏观热力学性质有明确的贡献。这项练习将引导你从第一性原理出发，推导约束力对系统维里（virial）的具体贡献，从而将约束效应正确地纳入到压力计算中。完成这项推导对于在约束模拟中准确估算系统压力至关重要 。",
            "id": "3421524",
            "problem": "考虑一个包含 $N$ 个原子的系统，在恒定温度 $T$ 和体积 $V$ 下进行分子动力学 (MD) 模拟。该系统受到 $M$ 个完整距离约束，这些约束通过线性约束求解器 (LINCS) 算法强制执行。每个约束 $\\alpha \\in \\{1,\\dots,M\\}$ 通过约束函数将特定原子对 $(a_{\\alpha}, b_{\\alpha})$ 之间的距离平方固定为一个预设值 $d_{\\alpha}^{2}$\n$$\ng_{\\alpha}(\\mathbf{r}) = |\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}|^{2} - d_{\\alpha}^{2} = 0,\n$$\n其中 $\\mathbf{r}_{i}$ 是原子 $i$ 的位置向量。假设使用包含拉格朗日乘子 $\\lambda_{\\alpha}$ 的标准公式，产生约束力\n$$\n\\mathbf{f}_{c,i} = \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} \\nabla_{\\mathbf{r}_{i}} g_{\\alpha}.\n$$\n原子 $i$ 上的总力为 $\\mathbf{f}_{i} = \\mathbf{f}_{nb,i} + \\mathbf{f}_{c,i}$，其中 $\\mathbf{f}_{nb,i}$ 来自非键相互作用。假设没有外场，并且周期性边界条件消除了表面项，因此标准的维里定理适用。\n\n从牛顿第二定律和维里定义出发，推导约束力对维里贡献的闭式表达式，然后将压力写成一个包含动能项和带约束的完整维里的单一解析表达式。你的最终表达式应以 $N$、$k_{B}$ (玻尔兹曼常数)、$T$、$V$、非键维里\n$$\nW_{nb} = \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\mathbf{f}_{nb,i},\n$$\n以及约束参数 $\\{\\lambda_{\\alpha}, d_{\\alpha}\\}_{\\alpha=1}^{M}$ 来表示。压力以帕斯卡为单位表示。最终答案必须是单一的闭式解析表达式，而不是一个需要求解的方程。",
            "solution": "用户希望我解决一个问题。作为一名严谨的教授，我必须首先验证问题的陈述。\n\n**第 1 步：提取已知条件**\n- 一个包含 $N$ 个原子的系统，在恒定温度下进行分子动力学 (MD) 模拟。\n- 温度：$T$。\n- 体积：$V$。\n- 完整距离约束的数量：$M$。\n- 约束算法：LINCS。\n- 约束函数 $\\alpha$：$g_{\\alpha}(\\mathbf{r}) = |\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}|^{2} - d_{\\alpha}^{2} = 0$。\n- 粒子位置向量：$\\mathbf{r}_{i}$。\n- 拉格朗日乘子：$\\lambda_{\\alpha}$。\n- 约束力：$\\mathbf{f}_{c,i} = \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} \\nabla_{\\mathbf{r}_{i}} g_{\\alpha}$。\n- 原子 $i$ 上的总力：$\\mathbf{f}_{i} = \\mathbf{f}_{nb,i} + \\mathbf{f}_{c,i}$。\n- 非键维里：$W_{nb} = \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\mathbf{f}_{nb,i}$。\n- 条件：无外场，周期性边界条件，标准维里定理适用。\n- 任务 1：推导约束力对维里贡献的闭式表达式。\n- 任务 2：将压力 $P$ 写成一个以 $N, k_{B}, T, V, W_{nb}, \\{\\lambda_{\\alpha}, d_{\\alpha}\\}_{\\alpha=1}^{M}$ 表示的单一解析表达式。\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题具有科学依据，提法明确且客观。它描述了计算化学和统计物理学中的一个标准场景。通过拉格朗日乘子定义的约束力、维里以及压力状态方程都是标准的。该问题是自洽的，并提供了执行所要求的推导所需的所有必要信息。不存在科学缺陷、矛盾或模糊之处。\n\n**结论：** 问题有效。\n\n**求解推导：**\n\n体积为 $V$、温度为 $T$ 的系统的压力 $P$ 可以使用维里状态方程计算。对于一个包含 $N$ 个粒子的系统，在分子动力学中通常表示为：\n$$\nP V = N k_{B} T + \\frac{1}{3} \\langle W \\rangle\n$$\n其中 $k_{B}$ 是玻尔兹曼常数，$\\langle W \\rangle$ 是时间平均的总内维里。在 MD 轨迹的瞬时构型背景下，我们可以使用瞬时维里 $W$ 来写出瞬时压力：\n$$\nP = \\frac{N k_{B} T}{V} + \\frac{W}{3V}\n$$\n总维里 $W$ 定义为所有粒子 $i$ 的位置向量 $\\mathbf{r}_{i}$ 与作用在其上的总力 $\\mathbf{f}_{i}$ 的点积之和：\n$$\nW = \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\mathbf{f}_{i}\n$$\n总力 $\\mathbf{f}_{i}$ 是非键力 $\\mathbf{f}_{nb,i}$ 和约束力 $\\mathbf{f}_{c,i}$ 的和。因此，总维里可以分解为相应的两个部分：\n$$\nW = \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot (\\mathbf{f}_{nb,i} + \\mathbf{f}_{c,i}) = \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\mathbf{f}_{nb,i} + \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\mathbf{f}_{c,i}\n$$\n第一项在问题陈述中已给出，即非键维里 $W_{nb}$。第二项是来自约束力的贡献，我们将其表示为 $W_{c}$：\n$$\nW_{c} = \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\mathbf{f}_{c,i}\n$$\n我们的第一个任务是推导 $W_{c}$ 的闭式表达式。我们代入给定的约束力 $\\mathbf{f}_{c,i}$ 的表达式：\n$$\nW_{c} = \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\left( \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} \\nabla_{\\mathbf{r}_{i}} g_{\\alpha} \\right)\n$$\n通过交换求和顺序，我们可以按约束 $\\alpha$ 对各项进行分组：\n$$\nW_{c} = \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} \\left( \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\nabla_{\\mathbf{r}_{i}} g_{\\alpha} \\right)\n$$\n现在我们必须为单个约束 $\\alpha$ 计算内部的和。约束函数 $g_{\\alpha}$ 是：\n$$\ng_{\\alpha}(\\mathbf{r}) = |\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}|^{2} - d_{\\alpha}^{2} = (\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}) \\cdot (\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}) - d_{\\alpha}^{2}\n$$\n梯度 $\\nabla_{\\mathbf{r}_{i}} g_{\\alpha}$ 仅对参与约束的两个原子非零，即当 $i=a_{\\alpha}$ 或 $i=b_{\\alpha}$ 时。我们来计算这两个梯度。为简单起见，令 $\\mathbf{r}_{a} = \\mathbf{r}_{a_{\\alpha}}$ 和 $\\mathbf{r}_{b} = \\mathbf{r}_{b_{\\alpha}}$。\n$$\n\\nabla_{\\mathbf{r}_{a}} g_{\\alpha} = \\nabla_{\\mathbf{r}_{a}} \\left[ (\\mathbf{r}_{a} - \\mathbf{r}_{b}) \\cdot (\\mathbf{r}_{a} - \\mathbf{r}_{b}) \\right] = 2(\\mathbf{r}_{a} - \\mathbf{r}_{b})\n$$\n$$\n\\nabla_{\\mathbf{r}_{b}} g_{\\alpha} = \\nabla_{\\mathbf{r}_{b}} \\left[ (\\mathbf{r}_{a} - \\mathbf{r}_{b}) \\cdot (\\mathbf{r}_{a} - \\mathbf{r}_{b}) \\right] = -2(\\mathbf{r}_{a} - \\mathbf{r}_{b})\n$$\n$W_{c}$ 表达式中的内部和因此减少到只有两项：\n$$\n\\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\nabla_{\\mathbf{r}_{i}} g_{\\alpha} = \\mathbf{r}_{a_{\\alpha}} \\cdot (\\nabla_{\\mathbf{r}_{a_{\\alpha}}} g_{\\alpha}) + \\mathbf{r}_{b_{\\alpha}} \\cdot (\\nabla_{\\mathbf{r}_{b_{\\alpha}}} g_{\\alpha})\n$$\n代入计算出的梯度：\n$$\n= \\mathbf{r}_{a_{\\alpha}} \\cdot [2(\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}})] + \\mathbf{r}_{b_{\\alpha}} \\cdot [-2(\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}})]\n$$\n$$\n= 2 \\left( \\mathbf{r}_{a_{\\alpha}} \\cdot (\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}) - \\mathbf{r}_{b_{\\alpha}} \\cdot (\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}) \\right)\n$$\n提出公因式 $(\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}})$：\n$$\n= 2 (\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}) \\cdot (\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}) = 2 |\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}|^{2}\n$$\n根据约束方程 $g_{\\alpha}=0$，这意味着原子间的距离平方被固定为其预设值：$|\\mathbf{r}_{a_{\\alpha}} - \\mathbf{r}_{b_{\\alpha}}|^{2} = d_{\\alpha}^{2}$。\n因此，内部的和简化为：\n$$\n\\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\nabla_{\\mathbf{r}_{i}} g_{\\alpha} = 2 d_{\\alpha}^{2}\n$$\n现在我们将此结果代回到约束维里 $W_{c}$ 的表达式中：\n$$\nW_{c} = \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} (2 d_{\\alpha}^{2}) = 2 \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} d_{\\alpha}^{2}\n$$\n这就是约束力对维里贡献的闭式表达式。\n\n最后一步是组装压力 $P$ 的完整表达式。总维里为 $W = W_{nb} + W_{c}$。代入推导出的 $W_{c}$ 表达式：\n$$\nW = W_{nb} + 2 \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} d_{\\alpha}^{2}\n$$\n将这个总维里代入压力方程：\n$$\nP = \\frac{N k_{B} T}{V} + \\frac{1}{3V} \\left( W_{nb} + 2 \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} d_{\\alpha}^{2} \\right)\n$$\n这就是压力的最终表达式。如果所有量都以国际单位制 (SI) 给出（$N$ 是无量纲的，$k_B$ 单位为 $\\text{J/K}$，$T$ 单位为 $\\text{K}$，$V$ 单位为 $\\text{m}^3$，$W_{nb}$ 单位为 $\\text{J}$，$\\lambda_{\\alpha}$ 单位为 $\\text{J/m}^2$，$d_{\\alpha}$ 单位为 $\\text{m}$），则得到的压力 $P$ 将以帕斯卡 ($\\text{N/m}^2$ 或 $\\text{J/m}^3$) 为单位，符合要求。",
            "answer": "$$\n\\boxed{P = \\frac{N k_{B} T}{V} + \\frac{1}{3V} \\left( W_{nb} + 2 \\sum_{\\alpha=1}^{M} \\lambda_{\\alpha} d_{\\alpha}^{2} \\right)}\n$$"
        },
        {
            "introduction": "LINCS 算法虽然高效，但其稳定性并非无条件的，特别是在处理特定的分子几何构型时。此练习旨在通过一个精心设计的思想实验，让你亲手构建一个导致 LINCS 算法数值不稳定的分子构型 。你将通过编程实现 LINCS 算法中的核心矩阵，并计算其迭代矩阵的谱半径，从而直观地理解约束之间的线性依赖性是如何破坏算法收敛性的，这对于深刻理解 LINCS 的适用边界和潜在陷阱非常有帮助。",
            "id": "3421489",
            "problem": "您需要通过构建一个特意引入近似相关约束行的小分子几何结构，来分析分子动力学中线性约束求解器（LINCS）的约束投影的稳定性。从经典力学的基本原理和完整约束出发，推导出评估基于诺伊曼级数的 LINCS 定点校正穩定性所需的代数对象。然后，针对一个趋近于奇异构型的参数化几何族，实现并执行所推导的公式。\n\n考虑一个三维空间中由 $N=4$ 个等质量 $m$ 的质点组成的系统。设其位置为 $\\mathbf{r}_i \\in \\mathbb{R}^3$，其中 $i \\in \\{1,2,3,4\\}$。我们指定如下参数化几何结构\n$$\n\\mathbf{r}_1 = (0,0,0),\\quad\n\\mathbf{r}_2 = (1,\\varepsilon,0),\\quad\n\\mathbfr_3 = (2,0,0),\\quad\n\\mathbfr_4 = (3,\\varepsilon,0),\n$$\n参数为 $\\varepsilon \\ge 0$。当 $\\varepsilon$ 很小时，这将形成一个近乎共线的链。施加 $K=5$ 个固定键长约束，对应于原子对\n$$\n(1,2),\\ (2,3),\\ (3,4),\\ (1,3),\\ (2,4),\n$$\n这些约束被解释为 $g_k(\\mathbf{q}) = 0$ 形式的完整约束，其中 $g_k(\\mathbf{q})$ 强制原子对之间的平方距离固定不变，即对于原子对 $(i,j)$，约束为 $g_{ij}(\\mathbf{q}) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d_{ij}^2=0$。此处 $\\mathbf{q}$ 堆叠了所有原子的笛卡尔坐标，$d_{ij}$ 是原子对 $(i,j)$ 的目标键长。使用上述瞬时几何结构来定义目标距离 $d_{ij}$，从而使所有约束在初始时都得到精确满足。\n\n从带拉格朗日乘子的牛顿第二定律和完整约束出发，并对笛卡尔坐标下的 $g_k(\\mathbf{q})=0$ 进行线性化处理，执行以下推导和计算：\n\n1. 推导约束雅可比矩阵 $J \\in \\mathbb{R}^{K \\times 3N}$，其第 $k$ 行为在给定几何结构下计算的梯度 $\\nabla_{\\mathbf{q}} g_k(\\mathbf{q})$。对于原子对 $(i,j)$，非零块应反映对 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 的依赖关系。使用平方距离形式，使得块梯度分别与 $(\\mathbf{r}_i - \\mathbf{r}_j)$ 和 $(\\mathbf{r}_j - \\mathbf{r}_i)$ 成比例。\n\n2. 引入对角线上元素为相同质量 $m$ 的对角质量矩阵 $M \\in \\mathbb{R}^{3N \\times 3N}$。从线性化的约束冲量平衡中，确定对称半正定矩阵\n$$\nS_{\\mathrm{raw}} = J M^{-1} J^\\top \\in \\mathbb{R}^{K \\times K}.\n$$\n\n3. 对 $S_{\\mathrm{raw}}$ 进行归一化，以获得一个对角线元素为单位元的耦合矩阵。定义 $D = \\mathrm{diag}(S_{\\mathrm{raw}})$ 并构造\n$$\nS = D^{-1/2} S_{\\mathrm{raw}} D^{-1/2}.\n$$\n这种归一化产生一个对角线元素等于 $1$ 的矩阵 $S$。\n\n4. 考虑在线性约束求解器（LINCS）中使用的定点（诺伊曼级数）近似，其中 $S$ 的逆矩阵由矩阵\n$$\nC = I - S.\n$$\n的截断级数来近似。根据 $(I - C)^{-1}$ 的诺伊曼级数，收敛准则要求谱半径 $\\rho(C)  1$。利用此原理，将谱半径 $\\rho(C)$ 定义为稳定性度量。\n\n5. 实现一个程序，对于质量选择 $m=1$（无量纲），针对参数值 $\\varepsilon \\in \\{0.2, 0.02, 0.0\\}$ 构建几何结构，形成 $J$，建立 $S_{\\mathrm{raw}}$，归一化得到 $S$，计算 $C=I-S$，并返回每个 $\\varepsilon$ 对应的谱半径 $\\rho(C)$。\n\n6. 科学和数值预期：当 $\\varepsilon \\to 0$ 时，闭环中的约束变得近似冗余，$J$ 的行变得近似线性相关，使得 $S$ 近似奇异。因此，您应该会看到 $\\rho(C)$ 接近或超过 $1$，这标志着由于诺伊曼级数不再收敛，LINCS 可能会失效。\n\n您的程序必须精确实现上述推导，并输出三个参数值的结果。此问题中没有物理单位；将所有量视为无量纲数。输出必须是单行，包含一个用方括号括起来的逗号分隔列表。列表必须按 $[\\rho(C;\\varepsilon=0.2),\\rho(C;\\varepsilon=0.02),\\rho(C;\\varepsilon=0.0)]$ 的顺序排列，其中每个条目都是一个精确到小数点后六位的浮点数。例如，输出行可能看起来像 $[0.123456,0.987654,1.234567]$。\n\n涵盖不同情况的测试套件：\n- $\\varepsilon=0.2$ 的规则、良态几何结构（正常路径）。\n- $\\varepsilon=0.02$ 的近似奇异几何结构（接近失效）。\n- $\\varepsilon=0.0$ 的精确共线几何结构（秩亏的边缘情况）。\n\n您的程序应按照上述确切格式生成单行输出。",
            "solution": "我们从经典力学和完整约束出发，构建线性约束求解器（LINCS）的稳定性分析，然后将其归结为关于一个耦合矩阵的代数条件。\n\n我们考虑 $N=4$ 个等质量 $m$ 的质点。设 $\\mathbf{q} \\in \\mathbb{R}^{3N}$ 是堆叠了 $\\mathbf{r}_1,\\dots,\\mathbf{r}_N$ 的笛卡尔坐标。我们施加 $K=5$ 个 $g_k(\\mathbf{q})=0$ 形式的完整约束，每个约束都是针对一对原子 $(i,j)$ 的固定平方距离：\n$$\ng_{ij}(\\mathbf{q}) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d_{ij}^2.\n$$\n我们选择 $d_{ij}$ 等于所构建几何结构中的瞬时距离，因此初始时 $g_{ij}(\\mathbf{q})=0$。$g_{ij}$ 相对于 $\\mathbf{q}$ 的梯度集中在原子 $i$ 和 $j$ 上：\n$$\n\\nabla_{\\mathbf{r}_i} g_{ij} = 2(\\mathbf{r}_i - \\mathbf{r}_j),\\quad\n\\nabla_{\\mathbf{r}_j} g_{ij} = 2(\\mathbf{r}_j - \\mathbf{r}_i),\\quad\n\\nabla_{\\mathbf{r}_k} g_{ij} = \\mathbf{0}\\ \\text{for}\\ k \\notin \\{i,j\\}.\n$$\n将所有约束的这些行梯度堆叠起来，得到雅可比矩阵 $J \\in \\mathbb{R}^{K \\times 3N}$，其中第 $k$ 行为 $\\nabla_{\\mathbf{q}} g_k(\\mathbf{q})^\\top$。\n\n根据带完整约束的牛顿第二定律，约束冲量强制满足\n$$\nM \\Delta \\dot{\\mathbf{q}} = \\mathbf{f}\\Delta t + J^\\top \\boldsymbol{\\lambda},\\quad \\text{with}\\quad J \\Delta \\mathbf{q} = -\\mathbf{g},\n$$\n其中 $M \\in \\mathbb{R}^{3N \\times 3N}$ 是对角质量矩阵，$\\boldsymbol{\\lambda} \\in \\mathbb{R}^{K}$ 是拉格朗日乘子，$\\mathbf{g}$ 是当前的约束值。在时间上进行线性化并消去 $\\Delta \\mathbf{q}$ 或 $\\Delta \\dot{\\mathbf{q}}$，会得到一个关于 $\\boldsymbol{\\lambda}$ 的对称系统，其中包含 $J M^{-1} J^\\top$。核心矩阵是\n$$\nS_{\\mathrm{raw}} = J M^{-1} J^\\top \\in \\mathbb{R}^{K \\times K},\n$$\n这是一个对称半正定矩阵。如果约束梯度是线性无关的，则 $S_{\\mathrm{raw}}$ 是对称正定的。\n\n为了模拟线性约束求解器（LINCS）中固有的归一化过程，我们将行缩放至单位质量加权范数。设 $D = \\mathrm{diag}(S_{\\mathrm{raw}})$ 是包含逐行二次型的对角矩阵，并定义归一化耦合矩阵\n$$\nS = D^{-1/2} S_{\\mathrm{raw}} D^{-1/2}.\n$$\n根据构造，$S$ 的对角线元素为单位元，即对所有 $k$ 都有 $S_{kk} = 1$。在这种表示中，非对角元素衡量了约束之间的成对耦合。\n\n线性约束求解器（LINCS）通过截断的诺伊曼级数来近似 $S^{-1}$。设\n$$\nC = I - S.\n$$\n如果谱半径 $\\rho(C)  1$，则诺伊曼级数收敛，并且\n$$\nS^{-1} = (I - C)^{-1} = \\sum_{\\ell=0}^{\\infty} C^\\ell,\n$$\n在 $p$ 阶截断产生的误差在一个一致的算子范数下有界\n$$\n\\left\\| \\sum_{\\ell=p+1}^{\\infty} C^\\ell \\right\\| \\le \\frac{\\|C\\|^{p+1}}{1 - \\|C\\|},\\quad \\text{valid when}\\ \\|C\\|  1.\n$$\n因此，关键的稳定性度量是 $\\rho(C)$：如果 $\\rho(C) \\ge 1$，级数不收敛，LINCS 在原理上会失效；如果 $\\rho(C)$ 接近 $1$，截断误差会变大。\n\n我们现在构建参数化几何结构以趋近秩亏。将原子放置在\n$$\n\\mathbf{r}_1 = (0,0,0),\\ \n\\mathbf{r}_2 = (1,\\varepsilon,0),\\ \n\\mathbf{r}_3 = (2,0,0),\\ \n\\mathbf{r}_4 = (3,\\varepsilon,0),\n$$\n参数 $\\varepsilon \\in \\{0.2, 0.02, 0.0\\}$。约束形成一个环：\n$$\n(1,2),\\ (2,3),\\ (3,4),\\ (1,3),\\ (2,4).\n$$\n当 $\\varepsilon \\to 0$ 时，所有四个原子都位于一条直线上。在该极限下，约束梯度在环周围变成近似共线的组合。更精确地说，考虑 $J$ 中对应于这些约束的行向量；在共线几何结构中，环的闭合在这些行之间引入了近似线性相关性。因此，$S_{\\mathrm{raw}}$ 变得近似奇异，并且由于 $S$是 $S_{\\mathrm{raw}}$ 的归一化版本，$S$ 的最小特征值趋于 $0$。$C = I - S$ 的特征值是 $1 - \\lambda_i(S)$。因此，当最小的 $\\lambda_i(S) \\to 0$ 时，$C$ 的一个特征值会趋近于 $1$，所以 $\\rho(C) \\to 1$ 或者如果某个 $\\lambda_i(S) > 2$ 则可能超过 $1$。这反映了诺伊曼级数收敛性的丧失以及 LINCS 在接近奇异几何结构时的实际失效。\n\n计算的实现细节：\n- 设置 $m=1$，因此 $M = I$ 且 $S_{\\mathrm{raw}} = J J^\\top$。\n- 对于每个约束 $(i,j)$，通过放置\n$$\n\\text{row}_{ij}[\\mathbf{r}_i] = 2(\\mathbf{r}_i - \\mathbf{r}_j),\\quad\n\\text{row}_{ij}[\\mathbf{r}_j] = 2(\\mathbf{r}_j - \\mathbf{r}_i),\\quad\n\\text{zeros elsewhere}.\n$$\n来构造 $J$。\n- 形成 $S_{\\mathrm{raw}}$，计算 $D$ 和 $S$，然后计算 $C = I - S$。\n- 将 $\\rho(C)$ 计算为 $C$ 的特征值中的最大绝对值。\n- 按照要求格式报告 $\\varepsilon \\in \\{0.2, 0.02, 0.0\\}$ 的三个值 $\\rho(C;\\varepsilon)$，每个值四舍五入到小数点后 $6$ 位。\n\n定性结果：\n- 对于 $\\varepsilon = 0.2$，几何结构是良态的；我们预期 $\\rho(C)$ 显著小于 $1$。\n- 对于 $\\varepsilon = 0.02$，几何结构近似奇异；我们预期 $\\rho(C)$ 接近 $1$。\n- 对于 $\\varepsilon = 0.0$，几何结构是精确共线的；我们预期 $S$ 的至少一个特征值为零，因此 $C$ 的一个特征值等于 $1$，使得 $\\rho(C) \\ge 1$ 并指示失效。\n\n提供的程序相应地构造矩阵并计算谱半径，生成所要求的单行输出，其中包含三个四舍五入到六位小数的浮点数。",
            "answer": "```python\nimport numpy as np\n\ndef build_geometry(epsilon: float):\n    # Four atoms with small zig-zag in y to control near-colinearity\n    r1 = np.array([0.0, 0.0, 0.0])\n    r2 = np.array([1.0, epsilon, 0.0])\n    r3 = np.array([2.0, 0.0, 0.0])\n    r4 = np.array([3.0, epsilon, 0.0])\n    R = np.vstack([r1, r2, r3, r4])  # shape (4,3)\n    return R\n\ndef constraints_pairs():\n    # Pairs: (1,2),(2,3),(3,4),(1,3),(2,4) using 0-based indexing\n    return [(0,1),(1,2),(2,3),(0,2),(1,3)]\n\ndef build_J(R: np.ndarray, pairs):\n    N = R.shape[0]\n    K = len(pairs)\n    J = np.zeros((K, 3*N), dtype=float)\n    for k, (i, j) in enumerate(pairs):\n        rij = R[i] - R[j]\n        # Gradient for squared-distance constraint: 2*(ri - rj) and 2*(rj - ri)\n        gi = 2.0 * rij\n        gj = -2.0 * rij\n        # Place into row k at blocks for atoms i and j\n        J[k, 3*i:3*i+3] = gi\n        J[k, 3*j:3*j+3] = gj\n    return J\n\ndef normalized_S(J: np.ndarray, mass: float = 1.0):\n    # M = m * I, so M^{-1} = (1/m) * I; thus S_raw = (1/m) * J J^T\n    S_raw = (J @ J.T) / mass\n    # Normalize to unit diagonal: S = D^{-1/2} S_raw D^{-1/2}\n    d = np.diag(S_raw).copy()\n    # Guard against numerical zeros on diagonal (should not occur since rows nonzero)\n    d_sqrt_inv = 1.0 / np.sqrt(d)\n    D_half_inv = np.diag(d_sqrt_inv)\n    S = D_half_inv @ S_raw @ D_half_inv\n    return S\n\ndef spectral_radius_C(S: np.ndarray):\n    # C = I - S; compute spectral radius of C (max abs eigenvalue)\n    K = S.shape[0]\n    C = np.eye(K) - S\n    # Use eigh for symmetric matrix to improve numerical stability\n    evals = np.linalg.eigvalsh(C)\n    rho = float(np.max(np.abs(evals)))\n    return rho\n\ndef compute_rho_for_epsilon(epsilon: float):\n    R = build_geometry(epsilon)\n    pairs = constraints_pairs()\n    J = build_J(R, pairs)\n    S = normalized_S(J, mass=1.0)\n    rho = spectral_radius_C(S)\n    return rho\n\ndef solve():\n    test_cases = [0.2, 0.02, 0.0]\n    results = []\n    for eps in test_cases:\n        rho = compute_rho_for_epsilon(eps)\n        results.append(rho)\n    # Format with exactly six digits after decimal, no spaces\n    out = \"[\" + \",\".join(f\"{x:.6f}\" for x in results) + \"]\"\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在真实的分子系统中，除了几何构型可能导致数值问题外，连接原子间巨大的质量差异（例如，重原子上的氢原子）是另一个挑战 LINCS 稳定性的常见因素。这项实践将前一个练习中对稳定性的分析提升到新的层次，引导你探究极端质量比如何影响约束耦合矩阵的性质 。更重要的是，你将基于这一分析，设计并实现一种实用的质量缩放策略，这是一种在现代分子动力学模拟中广泛用于增强含氢键系统稳定性的关键技术。",
            "id": "3421519",
            "problem": "考虑一个质点系统，其位置为 $\\mathbf{q} \\in \\mathbb{R}^{3N}$，质量为 $m_i > 0$（$i \\in \\{1,\\dots,N\\}$）。该系统在牛顿第二定律下演化，并受到完整键长约束 $g_k(\\mathbf{q}) = \\|\\mathbf{r}_{a(k)} - \\mathbf{r}_{b(k)}\\| - \\ell_k = 0$（$k \\in \\{1,\\dots,n_c\\}$）的作用。其中，$a(k), b(k) \\in \\{1,\\dots,N\\}$ 是原子索引，$\\mathbf{r}_i \\in \\mathbb{R}^3$ 是原子 $i$ 的位置，$\\ell_k > 0$ 是约束 $k$ 的目标键长。令 $G(\\mathbf{q}) \\in \\mathbb{R}^{n_c \\times 3N}$ 为约束关于 $\\mathbf{q}$ 的雅可比矩阵，令 $M \\in \\mathbb{R}^{3N \\times 3N}$ 为对角质量矩阵，$M = \\mathrm{diag}(m_1 I_3, \\dots, m_N I_3)$。质量加权约束耦合矩阵定义为 $C(\\mathbf{q}, M) = G(\\mathbf{q}) M^{-1} G(\\mathbf{q})^\\top \\in \\mathbb{R}^{n_c \\times n_c}$。定义严格非对角、对称归一化的耦合矩阵 $S \\in \\mathbb{R}^{n_c \\times n_c}$ 如下：\n$$\nS_{ij} =\n\\begin{cases}\n\\displaystyle \\frac{C_{ij}}{\\sqrt{C_{ii}\\, C_{jj}}},  i \\neq j, \\\\\n0,  i = j.\n\\end{cases}\n$$\n用于约束分子动力学的线性约束求解器 (LINCS) 算法使用截断的诺伊曼级数来近似一个预处理系统的逆，该系统的收敛性和稳定性由谱半径 $\\rho(S)$ 决定。\n\n任务：从上述定义出发，分析极端质量比（例如，一个轻原子连接到重邻居原子，使得 $m_{\\mathrm{light}}/m_{\\mathrm{heavy}} \\to 0$）对矩阵 $S$ 的元素及其谱半径 $\\rho(S)$ 的影响。基于此分析，提出并实现一个鲁棒的质量缩放策略，该策略通过修改一部分原子的质量，将 $\\rho(S)$ 限制在预设目标 $\\rho_{\\mathrm{target}} \\in (0,1)$ 以内。你的策略必须：\n- 从第一性原理推导，为何增加被多个约束共享的原子的质量会减小 $S$ 中非对角元素的大小，并单调减小 $\\rho(S)$。\n- 仅使用 $G(\\mathbf{q})$ 中的几何信息和 $M$ 的对角质量结构。\n- 具有构造性且可数值实现：对于给定的 $\\rho_{\\mathrm{target}}$，为选定的原子子集返回一组缩放后的质量 $\\tilde{m}_i \\ge m_i$，以确保 $\\rho(S(\\tilde{M})) \\le \\rho_{\\mathrm{target}}$，其中 $\\tilde{M} = \\mathrm{diag}(\\tilde{m}_1 I_3,\\dots,\\tilde{m}_N I_3)$。\n\n你的程序应遵循以下实现细节：\n1. 构建 $G(\\mathbf{q})$：对于每个连接原子 $a$ 和 $b$ 的约束 $k$，构造一个行向量。该行向量在对应于原子 $a$ 的列处的 3 维向量块等于 $(\\mathbf{r}_a - \\mathbf{r}_b)/\\|\\mathbf{r}_a - \\mathbf{r}_b\\|$，在对应于原子 $b$ 的列处的向量块等于 $(\\mathbf{r}_b - \\mathbf{r}_a)/\\|\\mathbf{r}_a - \\mathbf{r}_b\\|$，其他位置均为零。\n2. 构造 $C = G M^{-1} G^\\top$，然后如上所述构造 $S$。将 $\\rho(S)$ 计算为 $S$ 的最大绝对值特征值。\n3. 提出一个鲁棒的质量缩放策略，该策略针对至少与两个约束相关联的原子，并将其质量统一增加到一个下限值 $\\mu$（其他原子的质量保持不变），即对这些原子有 $\\tilde{m}_i = \\max\\{m_i, \\mu\\}$。$\\mu$ 的选择应是能确保 $\\rho(S(\\tilde{M})) \\le \\rho_{\\mathrm{target}}$ 的最小值。你的程序应通过数值稳定的一维搜索确定 $\\mu$，并输出缩放前后的谱半径。\n\n科学假设与要求：\n- 最终结果中只使用无量纲量；不需要物理单位。\n- 如果构建几何结构需要角度，则角度单位必须默认为弧度；然而，在本问题中，几何结构由笛卡尔坐标指定，因此不需要显式地计算角度。\n- 所有数值结果必须以双精度计算。\n- 确保所有构建的构型在物理上是合理的：所有键长必须严格为正。\n\n需要实现和评估的测试套件：\n你的程序必须硬编码并评估以下四个测试用例，每个用例由 $(\\mathbf{q}, \\text{constraints}, m, \\rho_{\\mathrm{target}})$ 指定：\n\n- 用例 A（中心为轻原子的线性三原子分子）：\n  - $N=3$ 个原子，位置为 $\\mathbf{r}_1 = (0,0,0)$, $\\mathbf{r}_2 = (1,0,0)$, $\\mathbf{r}_3 = (2,0,0)$。\n  - 约束：化学键 $(1,2)$ 和 $(2,3)$。\n  - 质量：$m = [12.0, 0.1, 12.0]$。\n  - 目标：$\\rho_{\\mathrm{target}} = 0.8$。\n\n- 用例 B（中心为极轻原子的直角三原子分子）：\n  - 位置 $\\mathbf{r}_1 = (0,0,0)$, $\\mathbf{r}_2 = (1,0,0)$, $\\mathbf{r}_3 = (1,1,0)$。\n  - 约束：化学键 $(1,2)$ 和 $(2,3)$。\n  - 质量：$m = [12.0, 0.001, 12.0]$。\n  - 目标：$\\rho_{\\mathrm{target}} = 0.8$。\n\n- 用例 C（包含两个轻内部原子的线性四原子链）：\n  - 位置 $\\mathbf{r}_1 = (0,0,0)$, $\\mathbf{r}_2 = (1,0,0)$, $\\mathbf{r}_3 = (2,0,0)$, $\\mathbf{r}_4 = (3,0,0)$。\n  - 约束：化学键 $(1,2)$, $(2,3)$, $(3,4)$。\n  - 质量：$m = [12.0, 0.1, 0.1, 12.0]$。\n  - 目标：$\\rho_{\\mathrm{target}} = 0.8$。\n\n- 用例 D（中心为轻原子、中心角为钝角 $\\approx 150^\\circ$ 的弯曲三原子分子）：\n  - 位置 $\\mathbf{r}_1 = (0,0,0)$, $\\mathbf{r}_2 = (1,0,0)$, $\\mathbf{r}_3 = (1 + \\cos(30^\\circ), \\sin(30^\\circ), 0)$，即 $\\mathbf{r}_3 = (1 + \\sqrt{3}/2, 1/2, 0)$。\n  - 约束：化学键 $(1,2)$ 和 $(2,3)$。\n  - 质量：$m = [12.0, 0.05, 12.0]$。\n  - 目标：$\\rho_{\\mathrm{target}} = 0.8$。\n\n对于每个用例，你的程序必须：\n- 计算初始谱半径 $\\rho_{\\mathrm{init}} = \\rho(S(M))$。\n- 根据你的策略计算缩放后的质量 $\\tilde{m}$，然后计算 $\\rho_{\\mathrm{scaled}} = \\rho(S(\\tilde{M}))$。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个包含两个浮点数 $[\\rho_{\\mathrm{init}}, \\rho_{\\mathrm{scaled}}]$ 的列表。最终输出格式必须为：\n`[[rA_init,rA_scaled],[rB_init,rB_scaled],[rC_init,rC_scaled],[rD_init,rD_scaled]]`\n所有数字都以十进制浮点数打印。所有输出均为无量纲。",
            "solution": "该问题要求分析 LINCS 算法中使用的归一化耦合矩阵 $S$ 的谱半径，其在极端质量比下的行为，并开发一种质量缩放策略来限制该谱半径。\n\n### 理论分析\n\n设系统包含 $N$ 个原子，其位置为 $\\mathbf{q} \\in \\mathbb{R}^{3N}$，质量为 $m_i > 0$。$n_c$ 个完整键约束为 $g_k(\\mathbf{q}) = \\|\\mathbf{r}_{a(k)} - \\mathbf{r}_{b(k)}\\| - \\ell_k = 0$，其中 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 是原子 $i$ 的位置，$a(k)$ 和 $b(k)$ 是参与约束 $k$ 的原子索引。\n\n约束的雅可比矩阵 $G(\\mathbf{q}) \\in \\mathbb{R}^{n_c \\times 3N}$ 的行由约束函数的梯度 $\\nabla_{\\mathbf{q}} g_k$ 给出。$G$ 的第 $k$ 行（记为 $G_k$）仅在原子 $a(k)$ 和 $b(k)$ 对应的位置有非零的 3 维块。令 $\\mathbf{u}_k = (\\mathbf{r}_{a(k)} - \\mathbf{r}_{b(k)}) / \\|\\mathbf{r}_{a(k)} - \\mathbf{r}_{b(k)}\\|$ 为约束 $k$ 的归一化键矢量。梯度块为 $\\nabla_{\\mathbf{r}_{a(k)}} g_k = \\mathbf{u}_k^\\top$ 和 $\\nabla_{\\mathbf{r}_{b(k)}} g_k = -\\mathbf{u}_k^\\top$。\n\n对角质量矩阵为 $M = \\mathrm{diag}(m_1 I_3, \\dots, m_N I_3)$，其中 $I_3$ 是 $3 \\times 3$ 单位矩阵。其逆矩阵为 $M^{-1} = \\mathrm{diag}(m_1^{-1} I_3, \\dots, m_N^{-1} I_3)$。质量加权约束耦合矩阵为 $C = G M^{-1} G^\\top$。元素 $C_{ij}$ 由 $C_{ij} = G_i M^{-1} G_j^\\top$ 给出。这可以计算为对所有原子 $p$ 的求和：\n$$C_{ij} = \\sum_{p=1}^{N} \\frac{1}{m_p} (\\nabla_{\\mathbf{r}_p} g_i) \\cdot (\\nabla_{\\mathbf{r}_p} g_j)$$\n\n对角元素 $C_{ii}$ 为：\n$$C_{ii} = \\frac{1}{m_{a(i)}} (\\mathbf{u}_i \\cdot \\mathbf{u}_i) + \\frac{1}{m_{b(i)}} ((-\\mathbf{u}_i) \\cdot (-\\mathbf{u}_i)) = \\frac{1}{m_{a(i)}} + \\frac{1}{m_{b(i)}}$$\n这是参与约束 $i$ 的两个原子的逆质量之和。\n\n非对角元素 $C_{ij}$ 仅在约束 $i$ 和 $j$ 共享至少一个原子时才非零。考虑两个通过单个共同原子 $p$ 连接的约束 $i$ 和 $j$。设约束 $i$ 涉及原子 $(p_1, p)$，约束 $j$ 涉及原子 $(p_2, p)$。我们可以设定约束内的原子排序，使得 $b(i) = p$ 和 $b(j) = p$。那么 $\\nabla_{\\mathbf{r}_p} g_i = -\\mathbf{u}_i$ 和 $\\nabla_{\\mathbf{r}_p} g_j = -\\mathbf{u}_j$。对 $C_{ij}$ 求和的唯一非零贡献来自原子 $p$：\n$$C_{ij} = \\frac{1}{m_p} (-\\mathbf{u}_i) \\cdot (-\\mathbf{u}_j) = \\frac{1}{m_p} \\mathbf{u}_i \\cdot \\mathbf{u}_j$$\n此处，$\\mathbf{u}_i \\cdot \\mathbf{u}_j$ 表示指向共享原子 $p$ 的两个键矢量之间的夹角 $\\theta_{ij}$ 的余弦值。因此，$C_{ij} = \\frac{\\cos\\theta_{ij}}{m_p}$。注意，$C_{ij}$ 的符号取决于约束定义中任意的原子排序，但谱半径 $\\rho(S)$ 对此选择是不变的。我们继续假设一种排序方式，得到 $C_{ij} = \\frac{\\cos\\theta_{ij}}{m_p}$，其中 $\\theta_{ij}$ 是原子 $p$ 处的键之间的夹角。\n\n归一化耦合矩阵 $S$ 定义为 $S_{ij} = C_{ij} / \\sqrt{C_{ii}C_{jj}}$（$i \\neq j$）且 $S_{ii}=0$。对于在原子 $p$ 处耦合的约束 $i, j$：\n$$S_{ij} = \\frac{\\frac{\\cos\\theta_{ij}}{m_p}}{\\sqrt{\\left(\\frac{1}{m_{p_1}} + \\frac{1}{m_p}\\right) \\left(\\frac{1}{m_{p_2}} + \\frac{1}{m_p}\\right)}}$$\n\n### 极端质量比的影响\n\n考虑共享原子 $p$ 与其邻居相比非常轻的情况，即 $m_p \\to 0$，而 $m_{p_1}$ 和 $m_{p_2}$ 较大且固定。在此极限下，$1/m_p$ 项在 $C_{ii}$ 和 $C_{jj}$ 的表达式中占主导地位：\n$$ C_{ii} \\approx \\frac{1}{m_p}, \\quad C_{jj} \\approx \\frac{1}{m_p} $$\n非对角元素 $S_{ij}$ 变为：\n$$ S_{ij} \\approx \\frac{\\frac{\\cos\\theta_{ij}}{m_p}}{\\sqrt{\\frac{1}{m_p} \\cdot \\frac{1}{m_p}}} = \\cos\\theta_{ij} $$\n大小 $|S_{ij}|$ 接近 $|\\cos\\theta_{ij}|$。对于远非 $90^\\circ$（此时 $\\cos\\theta_{ij}=0$）的键角，该值可能接近 1。对于一个简单的双约束系统，$\\rho(S) = |S_{12}|$。如果 $|S_{12}|$ 接近 1，LINCS 算法的诺伊曼级数展开 $(I-S)^{-1} = \\sum_{k=0}^{\\infty} S^k$ 的收敛性就会被破坏。在模拟含有与多个重原子成键的轻原子（如氢）的系统时，这是一个关键的数值稳定性问题。\n\n### 质量缩放策略\n\n为了抵消这种效应，我们提出一个策略来增加被两个或更多约束共享的原子的质量。设 $I_{\\text{shared}}$ 为此类共享原子的索引集合。我们为这些原子引入一个统一的质量下限 $\\mu$。缩放后的质量矩阵 $\\tilde{M}$ 使用质量 $\\tilde{m}_i$ 构建：\n$$ \\tilde{m}_i = \\begin{cases} \\max(m_i, \\mu),  i \\in I_{\\text{shared}} \\\\ m_i,  i \\notin I_{\\text{shared}} \\end{cases} $$\n我们必须找到最小的 $\\mu$，使得对于新的矩阵 $S(\\tilde{M})$，其谱半径 $\\rho(S(\\tilde{M})) \\le \\rho_{\\mathrm{target}}$。\n\n让我们分析将一个共享原子 $p$ 的质量从 $m_p$ 缩放到 $\\tilde{m}_p = \\max(m_p, \\mu) \\ge m_p$ 的效果。相应的非对角元素 $|S_{ij}|$ 的大小为：\n$$ |S_{ij}(\\tilde{m}_p)| = \\frac{\\frac{|\\cos\\theta_{ij}|}{\\tilde{m}_p}}{\\sqrt{\\left(\\frac{1}{m_{p_1}} + \\frac{1}{\\tilde{m}_p}\\right) \\left(\\frac{1}{m_{p_2}} + \\frac{1}{\\tilde{m}_p}\\right)}} = \\frac{|\\cos\\theta_{ij}|}{\\sqrt{\\left(\\frac{\\tilde{m}_p}{m_{p_1}} + 1\\right) \\left(\\frac{\\tilde{m}_p}{m_{p_2}} + 1\\right)}} $$\n对于 $\\tilde{m}_p > 0$，这个表达式显然是 $\\tilde{m}_p$ 的一个单调递减函数。因此，增加共享原子的质量会直接减小在该原子处相交的约束之间的耦合强度。这些耦合项正是在质量较小时会变大的项。尽管 $|S|$ 的其他较小元素可能会略微增加，但对 $\\rho(S)$ 的主导影响来自于这些最大非对角元素的减小。因此，我们预期 $\\rho(S(\\mu))$ 是质量下限 $\\mu$ 的一个单调递减函数。\n\n这种单调性使我们能够使用高效的一维求根算法来找到所需的最小 $\\mu$。我们定义一个目标函数 $f(\\mu) = \\rho(S(\\mu)) - \\rho_{\\mathrm{target}}$，并搜索满足 $f(\\mu) \\le 0$ 的最小 $\\mu \\ge \\max_{i \\in I_{\\text{shared}}} m_i$。像 Brent 方法这样的区间法很适合这个任务，因为我们可以很容易地找到一个区间 $[\\mu_{\\text{low}}, \\mu_{\\text{high}}]$，使得 $f(\\mu_{\\text{low}}) > 0$（对应未缩放的系统）和 $f(\\mu_{\\text{high}})  0$（对应足够大的质量下限）。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef calculate_rho(positions, constraints, masses):\n    \"\"\"\n    Computes the spectral radius rho(S) for a given molecular system.\n\n    Parameters:\n    positions (np.ndarray): (N, 3) array of atomic positions.\n    constraints (np.ndarray): (nc, 2) array of atom indices for each constraint bond.\n    masses (np.ndarray): (N,) array of atomic masses.\n\n    Returns:\n    float: The spectral radius rho(S).\n    \"\"\"\n    num_atoms = len(masses)\n    num_constraints = len(constraints)\n\n    if num_constraints == 0:\n        return 0.0\n\n    # 1. Construct the Jacobian G\n    G = np.zeros((num_constraints, 3 * num_atoms), dtype=np.float64)\n    for k, (a_idx, b_idx) in enumerate(constraints):\n        r_a = positions[a_idx]\n        r_b = positions[b_idx]\n        r_ab = r_a - r_b\n        dist = np.linalg.norm(r_ab)\n        if dist  1e-9:\n            raise ValueError(f\"Constraint {k} has zero length.\")\n        u = r_ab / dist\n        \n        G[k, 3 * a_idx : 3 * a_idx + 3] = u\n        G[k, 3 * b_idx : 3 * b_idx + 3] = -u\n        \n    # 2. Form C = G M^-1 G^T\n    inv_masses_rep = np.repeat(1.0 / masses, 3)\n    GM_inv = G * inv_masses_rep # Broadcasting\n    C = GM_inv @ G.T\n    \n    # 3. Form S\n    C_diag = np.diag(C)\n    if np.any(C_diag = 0):\n        raise ValueError(\"Non-positive diagonal elements in C.\")\n    \n    denom = np.sqrt(np.outer(C_diag, C_diag))\n    # Handle potential division by zero if C_diag has zero elements, though it shouldn't\n    denom[denom  1e-30] = 1.0\n    \n    S = C / denom\n    np.fill_diagonal(S, 0.0)\n\n    # 4. Compute spectral radius rho(S)\n    if S.shape[0] = 1:\n        return 0.0\n    \n    eigvals = np.linalg.eigvals(S)\n    rho = np.max(np.abs(eigvals))\n    \n    return rho\n\ndef solve():\n    \"\"\"\n    Main function to run the mass-scaling analysis for the given test cases.\n    \"\"\"\n    # Test cases defined with 0-based indexing for atoms.\n    test_cases = [\n        # Case A: linear triatomic with light center\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [2.0, 0.0, 0.0]], dtype=np.float64),\n            \"constraints\": np.array([[0, 1], [1, 2]], dtype=int),\n            \"masses\": np.array([12.0, 0.1, 12.0], dtype=np.float64),\n            \"rho_target\": 0.8\n        },\n        # Case B: right-angle triatomic, extreme light center\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 1.0, 0.0]], dtype=np.float64),\n            \"constraints\": np.array([[0, 1], [1, 2]], dtype=int),\n            \"masses\": np.array([12.0, 0.001, 12.0], dtype=np.float64),\n            \"rho_target\": 0.8\n        },\n        # Case C: linear four-atom chain with two light interior atoms\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [2.0, 0.0, 0.0], [3.0, 0.0, 0.0]], dtype=np.float64),\n            \"constraints\": np.array([[0, 1], [1, 2], [2, 3]], dtype=int),\n            \"masses\": np.array([12.0, 0.1, 0.1, 12.0], dtype=np.float64),\n            \"rho_target\": 0.8\n        },\n        # Case D: bent triatomic with light center\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0 + np.cos(np.pi/6), np.sin(np.pi/6), 0.0]], dtype=np.float64),\n            \"constraints\": np.array([[0, 1], [1, 2]], dtype=int),\n            \"masses\": np.array([12.0, 0.05, 12.0], dtype=np.float64),\n            \"rho_target\": 0.8\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        q, constraints, m, rho_target = case[\"positions\"], case[\"constraints\"], case[\"masses\"], case[\"rho_target\"]\n        \n        rho_init = calculate_rho(q, constraints, m)\n        \n        if rho_init = rho_target:\n            results.append([rho_init, rho_init])\n            continue\n            \n        atom_counts = np.bincount(constraints.flatten(), minlength=len(m))\n        shared_atoms_indices = np.where(atom_counts >= 2)[0]\n        \n        if len(shared_atoms_indices) == 0:\n            results.append([rho_init, rho_init])\n            continue\n\n        def rho_objective_func(mu):\n            scaled_masses = m.copy()\n            for i in shared_atoms_indices:\n                scaled_masses[i] = max(m[i], mu)\n            return calculate_rho(q, constraints, scaled_masses) - rho_target\n\n        mu_low = np.max(m[shared_atoms_indices])\n\n        mu_high = mu_low + 1.0  # Initial guess for upper bound\n        if mu_low == 0: mu_high = 1.0\n        \n        max_iter = 100\n        iter_count = 0\n        while rho_objective_func(mu_high) > 0 and iter_count  max_iter:\n            mu_high *= 2.0\n            iter_count += 1\n        if iter_count == max_iter:\n            raise RuntimeError(\"Failed to find an upper bound for the mass search.\")\n\n        optimal_mu = brentq(rho_objective_func, mu_low, mu_high)\n        \n        final_masses = m.copy()\n        for i in shared_atoms_indices:\n            final_masses[i] = max(m[i], optimal_mu)\n            \n        rho_scaled = calculate_rho(q, constraints, final_masses)\n        \n        results.append([rho_init, rho_scaled])\n\n    output_str = f\"[{','.join([f'[{r[0]},{r[1]}]' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}