{
    "hands_on_practices": [
        {
            "introduction": "在实现任何约束算法之前，理解其操作的数学对象至关重要。本练习  将带你从第一性原理出发，推导刚性水分子约束函数的梯度。这些梯度向量不仅在理论上定义了维持分子刚性的内力方向，在实践中也构成了SETTLE等校正算法中原子位移的基本方向，是连接拉格朗日力学与高效计算方法的桥梁。",
            "id": "3444600",
            "problem": "考虑一个刚性三位点水分子，其原子标记为氧（$O$）、氢一（$\\mathrm{H}1$）和氢二（$\\mathrm{H}2$），它们在$\\mathbb{R}^3$中的位置向量分别为$\\mathbf{r}_O$、$\\mathbf{r}_{\\mathrm{H}1}$和$\\mathbf{r}_{\\mathrm{H}2}$。在具有完整约束的分子动力学中，刚性是通过要求原子坐标的特定函数随时间保持恒定来实现的。对于SETTLE算法中的刚性水，一个方便的选择是约束两个氧氢键长和氢氢间距，使用以下三个约束条件\n$$\nC_1(\\mathbf{r}_O,\\mathbf{r}_{\\mathrm{H}1},\\mathbf{r}_{\\mathrm{H}2}) \\equiv \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O\\|^2 - d_{\\mathrm{OH}}^2,\n$$\n$$\nC_2(\\mathbf{r}_O,\\mathbf{r}_{\\mathrm{H}1},\\mathbf{r}_{\\mathrm{H}2}) \\equiv \\|\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O\\|^2 - d_{\\mathrm{OH}}^2,\n$$\n$$\nC_3(\\mathbf{r}_O,\\mathbf{r}_{\\mathrm{H}1},\\mathbf{r}_{\\mathrm{H}2}) \\equiv \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2}\\|^2 - d_{\\mathrm{HH}}^2,\n$$\n其中，$d_{\\mathrm{OH}}$是固定的氧氢键长，$d_{\\mathrm{HH}}$是固定的氢氢间距，当两个氧氢键的长度均为$d_{\\mathrm{OH}}$时，它通过$d_{\\mathrm{HH}}^2 = 2 d_{\\mathrm{OH}}^2 (1 - \\cos\\theta_0)$与平衡时的氢氧氢键角$\\theta_0$相关联。\n\n仅从多元微积分的基本规则和欧几里得范数的定义出发，推导所有约束$k \\in \\{1,2,3\\}$和原子$i \\in \\{O,\\mathrm{H}1,\\mathrm{H}2\\}$相对于每个原子坐标$\\mathbf{r}_i$的梯度$\\nabla_{\\mathbf{r}_i} C_k$的显式解析表达式。然后，在完整约束动力学中约束力的背景下，解释它们的几何意义，并评论这些梯度如何与SETTLE算法为满足刚性而校正位置的瞬时方向相关联。\n\n您的最终答案必须将九个梯度向量呈现在一个解析表达式中。仅使用符号；不要代入数值。不需要单位。最终答案不需要四舍五入。",
            "solution": "该问题要求推导刚性水分子三个约束函数相对于其三个原子位置的梯度。它还要求在约束力的背景下对这些梯度进行几何解释，并阐述它们在SETTLE算法中的作用。\n\n首先，我们从多元微积分中建立计算两个位置向量之间欧几里得距离平方的梯度的基本规则。设两个粒子$i$和$j$的位置由$\\mathbb{R}^3$中的向量$\\mathbf{r}_i$和$\\mathbf{r}_j$给出。它们之间的距离平方是一个标量函数$f(\\mathbf{r}_i, \\mathbf{r}_j) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2$。令$\\mathbf{r}_i = (x_i, y_i, z_i)$和$\\mathbf{r}_j = (x_j, y_j, z_j)$。平方范数为：\n$$\nf(\\mathbf{r}_i, \\mathbf{r}_j) = (x_i - x_j)^2 + (y_i - y_j)^2 + (z_i - z_j)^2\n$$\n$f$相对于$\\mathbf{r}_i$的梯度定义为其偏导数向量：$\\nabla_{\\mathbf{r}_i} f = \\left(\\frac{\\partial f}{\\partial x_i}, \\frac{\\partial f}{\\partial y_i}, \\frac{\\partial f}{\\partial z_i}\\right)$。计算相对于$x_i$的偏导数：\n$$\n\\frac{\\partial f}{\\partial x_i} = \\frac{\\partial}{\\partial x_i} \\left[ (x_i - x_j)^2 + (y_i - y_j)^2 + (z_i - z_j)^2 \\right] = 2(x_i - x_j)\n$$\n根据对称性，其他分量为$\\frac{\\partial f}{\\partial y_i} = 2(y_i - y_j)$和$\\frac{\\partial f}{\\partial z_i} = 2(z_i - z_j)$。将它们组合起来得到梯度向量：\n$$\n\\nabla_{\\mathbf{r}_i} \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 = 2(x_i - x_j, y_i - y_j, z_i - z_j) = 2(\\mathbf{r}_i - \\mathbf{r}_j)\n$$\n类似地，计算相对于$\\mathbf{r}_j$的梯度：\n$$\n\\frac{\\partial f}{\\partial x_j} = \\frac{\\partial}{\\partial x_j} \\left[ (x_i - x_j)^2 \\right] = 2(x_i - x_j)(-1) = -2(x_i - x_j)\n$$\n这导出了梯度向量：\n$$\n\\nabla_{\\mathbf{r}_j} \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 = -2(\\mathbf{r}_i - \\mathbf{r}_j)\n$$\n对于任何其他位置为$\\mathbf{r}_k$（其中$k \\neq i,j$）的粒子，函数$f$不依赖于$\\mathbf{r}_k$，因此其梯度为零向量：$\\nabla_{\\mathbf{r}_k} \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 = \\mathbf{0}$。\n\n现在我们将这些规则应用于给定的三个约束函数：\n$C_1 \\equiv \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O\\|^2 - d_{\\mathrm{OH}}^2$\n$C_2 \\equiv \\|\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O\\|^2 - d_{\\mathrm{OH}}^2$\n$C_3 \\equiv \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2}\\|^2 - d_{\\mathrm{HH}}^2$\n\n由于$d_{\\mathrm{OH}}^2$和$d_{\\mathrm{HH}}^2$是常数项，它们的导数为零。因此，我们只需要对平方范数项进行微分。\n\n**约束$C_1(\\mathbf{r}_O, \\mathbf{r}_{\\mathrm{H}1}, \\mathbf{r}_{\\mathrm{H}2})$的梯度：**\n函数为$C_1 = \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O\\|^2 - d_{\\mathrm{OH}}^2$。\n- 相对于$\\mathbf{r}_O$的梯度：这对应于我们通用公式中$i=\\mathrm{H}1$和$j=O$时$\\mathbf{r}_j$的角色。\n$$\n\\nabla_{\\mathbf{r}_O} C_1 = \\nabla_{\\mathbf{r}_O} \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O\\|^2 = -2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O)\n$$\n- 相对于$\\mathbf{r}_{\\mathrm{H}1}$的梯度：这对应于$\\mathbf{r}_i$的角色。\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{H}1}} C_1 = \\nabla_{\\mathbf{r}_{\\mathrm{H}1}} \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O\\|^2 = 2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O)\n$$\n- 相对于$\\mathbf{r}_{\\mathrm{H}2}$的梯度：$C_1$不依赖于$\\mathbf{r}_{\\mathrm{H}2}$。\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{H}2}} C_1 = \\mathbf{0}\n$$\n\n**约束$C_2(\\mathbf{r}_O, \\mathbf{r}_{\\mathrm{H}1}, \\mathbf{r}_{\\mathrm{H}2})$的梯度：**\n函数为$C_2 = \\|\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O\\|^2 - d_{\\mathrm{OH}}^2$。\n- 相对于$\\mathbf{r}_O$的梯度：\n$$\n\\nabla_{\\mathbf{r}_O} C_2 = \\nabla_{\\mathbf{r}_O} \\|\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O\\|^2 = -2(\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O)\n$$\n- 相对于$\\mathbf{r}_{\\mathrm{H}1}$的梯度：$C_2$不依赖于$\\mathbf{r}_{\\mathrm{H}1}$。\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{H}1}} C_2 = \\mathbf{0}\n$$\n- 相对于$\\mathbf{r}_{\\mathrm{H}2}$的梯度：\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{H}2}} C_2 = \\nabla_{\\mathbf{r}_{\\mathrm{H}2}} \\|\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O\\|^2 = 2(\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O)\n$$\n\n**约束$C_3(\\mathbf{r}_O, \\mathbf{r}_{\\mathrm{H}1}, \\mathbf{r}_{\\mathrm{H}2})$的梯度：**\n函数为$C_3 = \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2}\\|^2 - d_{\\mathrm{HH}}^2$。\n- 相对于$\\mathbf{r}_O$的梯度：$C_3$不依赖于$\\mathbf{r}_O$。\n$$\n\\nabla_{\\mathbf{r}_O} C_3 = \\mathbf{0}\n$$\n- 相对于$\\mathbf{r}_{\\mathrm{H}1}$的梯度：\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{H}1}} C_3 = \\nabla_{\\mathbf{r}_{\\mathrm{H}1}} \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2}\\|^2 = 2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2})\n$$\n- 相对于$\\mathbf{r}_{\\mathrm{H}2}$的梯度：\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{H}2}} C_3 = \\nabla_{\\mathbf{r}_{\\mathrm{H}2}} \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2}\\|^2 = -2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2})\n$$\n\n**几何意义及与约束算法的关系**\n\n在具有完整约束$C_k=0$的经典力学的拉格朗日表述中，维持这些条件的约束力由$\\mathbf{F}_i^c = \\sum_k -\\lambda_k \\nabla_{\\mathbf{r}_i} C_k$给出，其中$\\lambda_k$是由动力学决定的拉格朗日乘子。\n\n梯度向量$\\nabla_{\\mathbf{r}_i} C_k$指向的方向是原子$i$的位置$\\mathbf{r}_i$发生变化时，会引起约束函数$C_k$值最快增加的方向。对于我们的距离约束，这个方向总是沿着约束中涉及的两个原子之间的连线。例如，$\\nabla_{\\mathbf{r}_{\\mathrm{H}1}} C_1 = 2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O)$是一个从原子$O$指向原子$\\mathrm{H}1$的向量。因此，由第一个约束施加在原子$\\mathrm{H}1$上的约束力$\\mathbf{F}_{\\mathrm{H}1,1}^c = -\\lambda_1 \\nabla_{\\mathbf{r}_{\\mathrm{H}1}} C_1$是一个沿着O–H1键的有心力。来自同一约束施加在原子$O$上的力，$\\mathbf{F}_{O,1}^c = -\\lambda_1 \\nabla_{\\mathbf{r}_O} C_1 = -\\lambda_1 (-2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O)) = - \\mathbf{F}_{\\mathrm{H}1,1}^c$，与之大小相等、方向相反，这符合牛顿第三定律。因此，梯度定义了保持分子刚性的内力的作用线。\n\n在像SHAKE和SETTLE这样的计算算法中，首先在没有约束的情况下对运动方程进行积分，得到通常会违反刚性条件（$C_k(\\mathbf{r}') \\neq 0$）的试验性新位置$\\mathbf{r}_i'$。然后，算法计算校正位移$\\Delta\\mathbf{r}_i = \\mathbf{r}_i - \\mathbf{r}_i'$，以找到满足约束的新位置$\\mathbf{r}_i$。这些校正是作为约束梯度的线性组合构建的。具体来说，原子$i$的位移形式为$\\Delta \\mathbf{r}_i \\propto \\sum_k g_k \\nabla_{\\mathbf{r}_i} C_k$，其中$g_k$是与拉格朗日乘子相关的标量系数。\n\n这意味着SETTLE算法通过沿着这些梯度定义的方向——即沿着原子间键向量——移动原子来校正原子位置。例如，为了校正O–H1键长的偏差，SETTLE会沿着连接$O$和$\\mathrm{H}1$原子的直线移动它们。为了校正H1–H2的距离，它会沿着连接两个氢原子的直线移动它们。SETTLE算法在计算上是高效的，因为它利用了水分子简单、固定的几何形状（一个等腰三角形）来找到一个精确的、非迭代的解析解，用于计算这些校正位移的大小，从而同时满足所有三个约束条件。梯度向量是这个解析解的基本构建模块。",
            "answer": "$$\n\\boxed{\\pmatrix{ -2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O)  2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O)  \\mathbf{0}  -2(\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O)  \\mathbf{0}  2(\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O)  \\mathbf{0}  2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2})  -2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2}) }}\n$$"
        },
        {
            "introduction": "理论上的完美算法在面对计算机有限的浮点精度时，常常会暴露出脆弱性，尤其是在处理几何上的简并情况时。本编码练习  旨在解决这一核心挑战，要求你设计并实现一个稳健的SETTLE解析投影算法。通过处理原子共线或重合等极端测试用例，你将学会如何构建能够应对真实世界数值问题的、具有工业级强度的模拟代码。",
            "id": "3444670",
            "problem": "要求您为刚性三位点水分子设计并实现一个稳健的解析约束投影算法，以避免在SETTLE算法中可能出现的因数值误差导致两个氢原子几乎重合时产生的支割和简并问题。该约束投影必须从第一性原理推导得出，并且在氢-氢间距趋于零时，即 $r_{\\mathrm{HH}}\\to 0$ 时，必须保持良定义。\n\n刚性水分子由一个位于位置 $\\mathbf{r}_{\\mathrm{O}}$ 的氧原子和两个位于位置 $\\mathbf{r}_{\\mathrm{H}_1}$ 和 $\\mathbf{r}_{\\mathrm{H}_2}$ 的氢原子组成，这些位置均在 $\\mathbb{R}^3$ 中。其刚性几何构型的完整约束为：\n- 固定的氧-氢键长：$\\lVert \\mathbf{r}_{\\mathrm{H}_1}-\\mathbf{r}_{\\mathrm{O}}\\rVert = r_{\\mathrm{OH}}$ 和 $\\lVert \\mathbf{r}_{\\mathrm{H}_2}-\\mathbf{r}_{\\mathrm{O}}\\rVert = r_{\\mathrm{OH}}$。\n- 固定的氢-氧-氢键角：$\\angle \\mathrm{H}_1\\mathrm{O}\\mathrm{H}_2 = \\theta$。\n\n这些约束意味着一个固定的氢-氢距离 $r_{\\mathrm{HH}} = 2 r_{\\mathrm{OH}} \\sin\\!\\left(\\tfrac{\\theta}{2}\\right)$，这是一个几何恒等式，通过将余弦定理应用于由两个氢原子和氧原子组成的三角形推导得出。\n\n从分子动力学 (MD) 中的牛顿定律和完整约束出发，您的任务是：\n- 使用分子平面内的标准正交基向量，推导一个相对于氧原子的氢原子位置的重新参数化方法，该方法不依赖于具有模糊分支的反三角函数。\n- 设计稳健的后备规则，即使在 $\\mathbf{r}_{\\mathrm{H}_1}\\approx \\mathbf{r}_{\\mathrm{H}_2}$，$\\mathbf{r}_{\\mathrm{H}_1}-\\mathbf{r}_{\\mathrm{O}}$ 和 $\\mathbf{r}_{\\mathrm{H}_2}-\\mathbf{r}_{\\mathrm{O}}$ 几乎为零，或者两个氧-氢方向反平行导致角平分线无法明确定义的情况下，也能确定性地选择一个有意义的角平分线方向和平面内垂直方向。\n- 实现由此得到的解析投影，该投影在给定临时位置 $(\\mathbf{r}_{\\mathrm{O}},\\mathbf{r}_{\\mathrm{H}_1},\\mathbf{r}_{\\mathrm{H}_2})$ 后，输出满足约束条件的校正后位置 $(\\mathbf{r}'_{\\mathrm{O}},\\mathbf{r}'_{\\mathrm{H}_1},\\mathbf{r}'_{\\mathrm{H}_2})$，其精度达到数值精度上限。\n\n使用以下物理上合理的液态水几何参数：\n- 氧-氢键长 $r_{\\mathrm{OH}} = 0.9572$ $\\mathrm{\\AA}$。\n- 氢-氧-氢键角 $\\theta = 104.52^\\circ$，以弧度为单位指定。即，使用 $\\theta = 104.52\\times \\pi/180$ $\\mathrm{rad}$。\n\n您的程序必须实现这个稳健的解析投影，并在一系列临时位置组成的测试集上进行评估。在所有情况下，校正后的氧原子位置必须保持为 $\\mathbf{r}'_{\\mathrm{O}}=\\mathbf{r}_{\\mathrm{O}}$（纯粹的分子内校正，无平移位移）。对于每种情况，报告两个标量误差：\n- 三个约束中的最大长度偏差，以 $\\mathrm{\\AA}$ 为单位：\n  $$\\varepsilon_{\\mathrm{len}} = \\max\\left(\\left|\\lVert \\mathbf{r}'_{\\mathrm{H}_1}-\\mathbf{r}_{\\mathrm{O}}\\rVert - r_{\\mathrm{OH}}\\right|,\\ \\left|\\lVert \\mathbf{r}'_{\\mathrm{H}_2}-\\mathbf{r}_{\\mathrm{O}}\\rVert - r_{\\mathrm{OH}}\\right|,\\ \\left|\\lVert \\mathbf{r}'_{\\mathrm{H}_1}-\\mathbf{r}'_{\\mathrm{H}_2}\\rVert - 2 r_{\\mathrm{OH}}\\sin\\!\\left(\\tfrac{\\theta}{2}\\right)\\right|\\right)。$$\n- 氢-氧-氢键角误差，以 $\\mathrm{rad}$ 为单位：\n  $$\\varepsilon_{\\mathrm{ang}} = \\left|\\arccos\\left(\\frac{(\\mathbf{r}'_{\\mathrm{H}_1}-\\mathbf{r}_{\\mathrm{O}})\\cdot(\\mathbf{r}'_{\\mathrm{H}_2}-\\mathbf{r}_{\\mathrm{O}})}{\\lVert \\mathbf{r}'_{\\mathrm{H}_1}-\\mathbf{r}_{\\mathrm{O}}\\rVert\\,\\lVert \\mathbf{r}'_{\\mathrm{H}_2}-\\mathbf{r}_{\\mathrm{O}}\\rVert}\\right) - \\theta\\right|。$$\n\n角度必须以 $\\mathrm{rad}$ 计算，长度以 $\\mathrm{\\AA}$ 计算。在诊断计算中，将 $\\arccos$ 的任何余弦参数限制在区间 $[-1,1]$ 内，以避免数值问题。\n\n使用以下五个以 $\\mathrm{\\AA}$ 为单位的临时几何构型定义测试集：\n- 情况 1（接近理想情况，有小扰动）：\n  - $\\mathbf{r}_{\\mathrm{O}} = (0,0,0)$,\n  - 设 $p = r_{\\mathrm{OH}}\\cos\\!\\left(\\tfrac{\\theta}{2}\\right)$ 且 $q = r_{\\mathrm{OH}}\\sin\\!\\left(\\tfrac{\\theta}{2}\\right)$,\n  - $\\mathbf{r}_{\\mathrm{H}_1} = (q + 1.0\\times 10^{-4},\\ 0,\\ p)$,\n  - $\\mathbf{r}_{\\mathrm{H}_2} = (-q - 1.0\\times 10^{-4},\\ 0,\\ p)$。\n- 情况 2（氢原子几乎重合，$r_{\\mathrm{HH}}\\to 0$）：\n  - $\\mathbf{r}_{\\mathrm{O}} = (1,\\ 2,\\ 3)$,\n  - $\\mathbf{r}_{\\mathrm{H}_1} = \\mathbf{r}_{\\mathrm{O}} + (1.0\\times 10^{-10},\\ 0,\\ 0)$,\n  - $\\mathbf{r}_{\\mathrm{H}_2} = \\mathbf{r}_{\\mathrm{O}} + (1.1\\times 10^{-10},\\ 0,\\ 0)$。\n- 情况 3（氧-氢方向反平行，角平分线无法明确定义）：\n  - $\\mathbf{r}_{\\mathrm{O}} = (0,\\ 1,\\ 0)$,\n  - $\\mathbf{r}_{\\mathrm{H}_1} = \\mathbf{r}_{\\mathrm{O}} + (1,\\ 0,\\ 0)$,\n  - $\\mathbf{r}_{\\mathrm{H}_2} = \\mathbf{r}_{\\mathrm{O}} - (1,\\ 0,\\ 0)$。\n- 情况 4（完全简并，所有三个原子重合）：\n  - $\\mathbf{r}_{\\mathrm{O}} = (0,\\ 0,\\ 0)$,\n  - $\\mathbf{r}_{\\mathrm{H}_1} = (0,\\ 0, 0)$,\n  - $\\mathbf{r}_{\\mathrm{H}_2} = (0,\\ 0, 0)$。\n- 情况 5（远离约束流形的大扰动）：\n  - $\\mathbf{r}_{\\mathrm{O}} = (5,\\ -3,\\ 2)$,\n  - $\\mathbf{r}_{\\mathrm{H}_1} = (3,\\ 7,\\ -4)$,\n  - $\\mathbf{r}_{\\mathrm{H}_2} = (-2,\\ 1,\\ 9)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含 10 个浮点数，序列为 $[\\varepsilon_{\\mathrm{len}}^{(1)}, \\varepsilon_{\\mathrm{ang}}^{(1)}, \\varepsilon_{\\mathrm{len}}^{(2)}, \\varepsilon_{\\mathrm{ang}}^{(2)}, \\dots, \\varepsilon_{\\mathrm{len}}^{(5)}, \\varepsilon_{\\mathrm{ang}}^{(5)}]$，其中上标表示从 1 到 5 的案例索引。\n\n在放置原子过程中，实现解析投影时不得调用迭代求解器或进行三角函数反演。任何诊断计算（如角度误差计算）都必须进行稳健处理，以避免数值上的支割问题。",
            "solution": "该问题要求为刚性三位点水分子设计并实现一个稳健的解析约束算法。该算法必须将一组临时原子位置 $(\\mathbf{r}_{\\mathrm{O}}, \\mathbf{r}_{\\mathrm{H}_1}, \\mathbf{r}_{\\mathrm{H}_2})$ 投影到约束流形上，从而得到校正后的位置 $(\\mathbf{r}'_{\\mathrm{O}}, \\mathbf{r}'_{\\mathrm{H}_1}, \\mathbf{r}'_{\\mathrm{H}_2})$，这些位置精确满足分子内的几何约束。主要挑战是确保该算法即使在简并构型中（例如原子几乎重合或共线时）也具有良定义和数值稳定性，这种情况可能导致像 SETTLE 这类算法的标准实现失败。\n\n约束规定了固定的氧-氢键长 $r_{\\mathrm{OH}}$ 和固定的氢-氧-氢键角 $\\theta$。由于要求氧原子的位置保持不变，即 $\\mathbf{r}'_{\\mathrm{O}} = \\mathbf{r}_{\\mathrm{O}}$，投影过程得以简化。\n\n### 基于原理的推导\n\n解决方案是基于临时几何构型构建一个局部标准正交基（一个坐标系），然后根据理想几何构型将氢原子放置到这个新框架中。该方法的稳健性取决于此基的构建，它必须能确定性地处理输入原子的所有可能的简并排列。\n\n设氧原子和两个氢原子的临时位置分别为 $\\mathbf{r}_{\\mathrm{O}}$、$\\mathbf{r}_{\\mathrm{H}_1}$ 和 $\\mathbf{r}_{\\mathrm{H}_2}$。我们处理相对于氧原子的向量：\n$$\n\\mathbf{v}_1 = \\mathbf{r}_{\\mathrm{H}_1} - \\mathbf{r}_{\\mathrm{O}} \\quad \\text{和} \\quad \\mathbf{v}_2 = \\mathbf{r}_{\\mathrm{H}_2} - \\mathbf{r}_{\\mathrm{O}}\n$$\n氢原子的校正后位置 $\\mathbf{r}'_{\\mathrm{H}_1}$ 和 $\\mathbf{r}'_{\\mathrm{H}_2}$ 将相对于一个以 $\\mathbf{r}_{\\mathrm{O}}$ 为中心新构建的局部坐标系 $\\{\\hat{\\mathbf{e}}_x, \\hat{\\mathbf{e}}_y, \\hat{\\mathbf{e}}_z\\}$ 来定义。\n\n在这个局部框架内的理想几何构型由从约束中推导出的两个关键参数定义：\n1.  从氧原子到 $\\mathrm{H}_1-\\mathrm{H}_2$ 线段中点的距离：$h = r_{\\mathrm{OH}} \\cos(\\theta/2)$。此距离位于角平分线上。\n2.  两个氢原子之间距离的一半：$w = r_{\\mathrm{OH}} \\sin(\\theta/2)$。此距离位于连接两个氢原子的直线上。\n\n我们定义局部基向量，使得 $\\hat{\\mathbf{e}}_y$ 与分子的对称轴（$\\angle \\mathrm{H_1OH_2}$ 的角平分线）对齐，$\\hat{\\mathbf{e}}_x$ 与连接两个氢原子的向量对齐。$\\hat{\\mathbf{e}}_z$ 是分子平面的法向量。\n\n### 标准正交基的稳健构建\n\n算法的核心是一个逐案处理的程序，用于定义基向量，其依据是从临时几何构型中导出的特征向量的稳定性。设 $\\epsilon^2$ 为一个小的容差（例如 $10^{-24} \\, \\AA^2$），用于向量范数的平方。\n\n**1. 定义特征向量：**\n- 从 $\\mathrm{H}_1$ 到 $\\mathrm{H}_2$ 的向量：$\\mathbf{d} = \\mathbf{r}_{\\mathrm{H}_2} - \\mathbf{r}_{\\mathrm{H}_1} = \\mathbf{v}_2 - \\mathbf{v}_1$。\n- 与角平分线相关的向量：$\\mathbf{s} = \\mathbf{v}_1 + \\mathbf{v}_2$。\n\n**2. 处理简并情况并构建基：**\n\n**情况 A：完全重合** ($\\lVert \\mathbf{v}_1 \\rVert^2  \\epsilon^2$ 且 $\\lVert \\mathbf{v}_2 \\rVert^2  \\epsilon^2$)\n所有三个原子位于同一位置。方向未定义。我们选择一个标准的、任意的基：\n$$\n\\hat{\\mathbf{e}}_x = (1, 0, 0), \\quad \\hat{\\mathbf{e}}_y = (0, 1, 0), \\quad \\hat{\\mathbf{e}}_z = (0, 0, 1)\n$$\n\n**情况 B：氢原子重合** ($\\lVert \\mathbf{d} \\rVert^2  \\epsilon^2$，但非情况 A)\n氢原子几乎在同一位置。向量 $\\mathbf{d}$ 定义不良。该几何构型中最具描述性的特征是从氧原子到重合氢原子的向量，由 $\\mathbf{s} = \\mathbf{v}_1 + \\mathbf{v}_2$ 近似表示。\n- 角平分线轴 $\\hat{\\mathbf{e}}_y$ 通过归一化 $\\mathbf{s}$ 来定义：$\\hat{\\mathbf{e}}_y = \\mathbf{s} / \\lVert \\mathbf{s} \\rVert$。\n- 分子平面未定义。我们必须确定性地创建一个。选择一个保证与 $\\hat{\\mathbf{e}}_y$ 不共线的第二个向量 $\\mathbf{ref}$。一个稳健的方法是选择与 $\\hat{\\mathbf{e}}_y$ 最垂直的笛卡尔轴向量（$\\hat{\\mathbf{i}}$, $\\hat{\\mathbf{j}}$ 或 $\\hat{\\mathbf{k}}$）。\n- 平面的法向量 $\\hat{\\mathbf{e}}_z$ 通过叉积构建：$\\hat{\\mathbf{e}}_z = (\\hat{\\mathbf{e}}_y \\times \\mathbf{ref}) / \\lVert \\hat{\\mathbf{e}}_y \\times \\mathbf{ref} \\rVert$。\n- 然后通过补全右手坐标系找到 H-H 轴 $\\hat{\\mathbf{e}}_x$：$\\hat{\\mathbf{e}}_x = \\hat{\\mathbf{e}}_y \\times \\hat{\\mathbf{e}}_z$。\n\n**情况 C：一般情况** ($\\lVert \\mathbf{d} \\rVert^2 \\ge \\epsilon^2$)\n氢原子是不同的，因此向量 $\\mathbf{d}$ 是良定义的，并作为主轴。\n- H-H 轴为 $\\hat{\\mathbf{e}}_x = \\mathbf{d} / \\lVert \\mathbf{d} \\rVert$。\n- 然后我们检查这三个原子是否共线。临时平面的法向量为 $\\mathbf{n} = \\mathbf{v}_1 \\times \\mathbf{v}_2$。\n  - **如果 $\\lVert \\mathbf{n} \\rVert^2 > \\epsilon^2$（非共线）：** 平面是良定义的。\n    - 平面法向量为 $\\hat{\\mathbf{e}}_z = \\mathbf{n} / \\lVert \\mathbf{n} \\rVert$。\n    - 角平分线轴为 $\\hat{\\mathbf{e}}_y = \\hat{\\mathbf{e}}_z \\times \\hat{\\mathbf{e}}_x$。\n  - **如果 $\\lVert \\mathbf{n} \\rVert^2 \\le \\epsilon^2$（共线）：** 平面定义不良。这包括反平行情况（$\\mathbf{v}_1 \\approx -\\mathbf{v}_2$）。\n    - 我们已有 $\\hat{\\mathbf{e}}_x$，必须定义一个正交平面。我们使用与情况 B 中相同的稳健方法：选择一个不与 $\\hat{\\mathbf{e}}_x$ 平行的参考向量 $\\mathbf{ref}$。\n    - 第二个轴 $\\hat{\\mathbf{e}}_y$ 的构建方式为：$\\hat{\\mathbf{e}}_y = (\\mathbf{ref} \\times \\hat{\\mathbf{e}}_x) / \\lVert \\mathbf{ref} \\times \\hat{\\mathbf{e}}_x \\rVert$。\n    - 第三个轴为 $\\hat{\\mathbf{e}}_z = \\hat{\\mathbf{e}}_x \\times \\hat{\\mathbf{e}}_y$。\n\n这个过程保证了对于任何输入几何构型，都能得到一个唯一的右手标准正交基。\n\n### 原子位置的重构\n\n在建立了基 $\\{\\hat{\\mathbf{e}}_x, \\hat{\\mathbf{e}}_y, \\hat{\\mathbf{e}}_z\\}$ 之后，可以直接计算校正后的氢原子位置，无需使用任何反三角函数：\n$$\n\\mathbf{r}'_{\\mathrm{O}} = \\mathbf{r}_{\\mathrm{O}}\n$$\n$$\n\\mathbf{r}'_{\\mathrm{H}_1} = \\mathbf{r}_{\\mathrm{O}} - w \\cdot \\hat{\\mathbf{e}}_x + h \\cdot \\hat{\\mathbf{e}}_y\n$$\n$$\n\\mathbf{r}'_{\\mathrm{H}_2} = \\mathbf{r}_{\\mathrm{O}} + w \\cdot \\hat{\\mathbf{e}}_x + h \\cdot \\hat{\\mathbf{e}}_y\n$$\n符号的选择与定义 $\\mathbf{d} = \\mathbf{r}_{\\mathrm{H}_2} - \\mathbf{r}_{\\mathrm{H}_1}$ 保持一致，确保校正后的向量 $\\mathbf{r}'_{\\mathrm{H}_2} - \\mathbf{r}'_{\\mathrm{H}_1}$ 指向与 $\\hat{\\mathbf{e}}_x$ 相同的方向。\n\n至此，解析投影完成。最后一步是使用校正后的位置计算指定的误差度量 $\\varepsilon_{\\mathrm{len}}$ 和 $\\varepsilon_{\\mathrm{ang}}$，以验证约束是否在机器精度内得到满足。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that defines test cases, applies the robust\n    analytic projection, computes errors, and prints the final results.\n    \"\"\"\n    \n    # Geometric parameters for the rigid water model\n    R_OH = 0.9572  # Angstrom\n    THETA_DEG = 104.52  # degrees\n    THETA_RAD = np.deg2rad(THETA_DEG)\n\n    # Derived geometric constants used for reconstruction\n    H_LEN = R_OH * np.cos(THETA_RAD / 2.0)\n    W_LEN = R_OH * np.sin(THETA_RAD / 2.0)\n    R_HH = 2.0 * W_LEN\n    \n    # Numerical tolerance for squared norms to detect degeneracy\n    TOL_SQ = 1e-24\n\n    def analytic_projection(r_o, r_h1, r_h2):\n        \"\"\"\n        Applies a robust analytic projection to a provisional water geometry\n        to satisfy the rigid constraints, handling degenerate cases.\n\n        Args:\n            r_o (np.ndarray): Provisional position of the oxygen atom.\n            r_h1 (np.ndarray): Provisional position of the first hydrogen atom.\n            r_h2 (np.ndarray): Provisional position of the second hydrogen atom.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray, np.ndarray]: Corrected positions\n            (r_o_prime, r_h1_prime, r_h2_prime) satisfying constraints.\n        \"\"\"\n        v1 = r_h1 - r_o\n        v2 = r_h2 - r_o\n\n        # Case A: Total Coincidence (all three atoms at the same point)\n        # This handles Case 4.\n        if np.dot(v1, v1)  TOL_SQ and np.dot(v2, v2)  TOL_SQ:\n            ex = np.array([1.0, 0.0, 0.0])\n            ey = np.array([0.0, 1.0, 0.0])\n        else:\n            # Vector connecting the two hydrogens\n            d = r_h2 - r_h1\n            d_sq_norm = np.dot(d, d)\n\n            # Case B: Coincident Hydrogens (r_h1 ≈ r_h2)\n            # This handles Case 2.\n            if d_sq_norm  TOL_SQ:\n                # The bisector vector is the most stable direction.\n                s = v1 + v2\n                ey = s / np.linalg.norm(s)\n\n                # Construct a perpendicular reference vector robustly by selecting\n                # the Cartesian axis most perpendicular to ey.\n                abs_ey = np.abs(ey)\n                if abs_ey[0]  abs_ey[1] and abs_ey[0]  abs_ey[2]:\n                    ref = np.array([1.0, 0.0, 0.0])\n                elif abs_ey[1]  abs_ey[2]:\n                    ref = np.array([0.0, 1.0, 0.0])\n                else:\n                    ref = np.array([0.0, 0.0, 1.0])\n\n                ez_unnormalized = np.cross(ey, ref)\n                ez = ez_unnormalized / np.linalg.norm(ez_unnormalized)\n                ex = np.cross(ey, ez)\n            \n            # Case C: General Case (Hydrogens are distinct)\n            # This handles Cases 1, 3, and 5.\n            else:\n                ex = d / np.sqrt(d_sq_norm)\n                n = np.cross(v1, v2) # Normal to the provisional plane\n                n_sq_norm = np.dot(n, n)\n\n                # If plane is well-defined (non-collinear atoms)\n                if n_sq_norm > TOL_SQ:\n                    ez = n / np.sqrt(n_sq_norm)\n                    ey = np.cross(ez, ex)\n                # If atoms are collinear (plane is ill-defined, e.g., Case 3)\n                else:\n                    # Construct perpendiculars using a robust reference vector\n                    abs_ex = np.abs(ex)\n                    if abs_ex[0]  abs_ex[1] and abs_ex[0]  abs_ex[2]:\n                        ref = np.array([1.0, 0.0, 0.0])\n                    elif abs_ex[1]  abs_ex[2]:\n                        ref = np.array([0.0, 1.0, 0.0])\n                    else:\n                        ref = np.array([0.0, 0.0, 1.0])\n                    \n                    # Order of cross products defines ey and ez\n                    ey_unnormalized = np.cross(ref, ex)\n                    ey = ey_unnormalized / np.linalg.norm(ey_unnormalized)\n                    ez = np.cross(ex, ey)\n\n        # Reconstruct hydrogen positions in the new frame\n        r_o_prime = r_o\n        r_h1_prime = r_o - W_LEN * ex + H_LEN * ey\n        r_h2_prime = r_o + W_LEN * ex + H_LEN * ey\n\n        return r_o_prime, r_h1_prime, r_h2_prime\n\n    def calculate_errors(r_o_p, r_h1_p, r_h2_p):\n        \"\"\"Calculates the length and angle errors for a given geometry.\"\"\"\n        # Length errors\n        len_oh1 = np.linalg.norm(r_h1_p - r_o_p)\n        len_oh2 = np.linalg.norm(r_h2_p - r_o_p)\n        len_hh = np.linalg.norm(r_h1_p - r_h2_p)\n        \n        eps_len = max(abs(len_oh1 - R_OH), abs(len_oh2 - R_OH), abs(len_hh - R_HH))\n        \n        # Angle error\n        v1_p = r_h1_p - r_o_p\n        v2_p = r_h2_p - r_o_p\n        \n        cos_val = np.dot(v1_p, v2_p) / (np.linalg.norm(v1_p) * np.linalg.norm(v2_p))\n        cos_val = np.clip(cos_val, -1.0, 1.0)\n        angle_prime = np.arccos(cos_val)\n        eps_ang = abs(angle_prime - THETA_RAD)\n        \n        return eps_len, eps_ang\n\n    # Define the test cases from the problem statement.\n    p = R_OH * np.cos(THETA_RAD / 2)\n    q = R_OH * np.sin(THETA_RAD / 2)\n    \n    test_cases = [\n        # Case 1 (near-ideal with small perturbation)\n        (np.array([0.0, 0.0, 0.0]), np.array([q + 1e-4, 0.0, p]), np.array([-q - 1e-4, 0.0, p])),\n        # Case 2 (nearly coincident hydrogens)\n        (np.array([1.0, 2.0, 3.0]), np.array([1.0 + 1e-10, 2.0, 3.0]), np.array([1.0 + 1.1e-10, 2.0, 3.0])),\n        # Case 3 (antiparallel oxygen-hydrogen directions)\n        (np.array([0.0, 1.0, 0.0]), np.array([1.0, 1.0, 0.0]), np.array([-1.0, 1.0, 0.0])),\n        # Case 4 (complete degeneracy, all atoms coincident)\n        (np.array([0.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.0])),\n        # Case 5 (large perturbation)\n        (np.array([5.0, -3.0, 2.0]), np.array([3.0, 7.0, -4.0]), np.array([-2.0, 1.0, 9.0]))\n    ]\n    \n    results = []\n    for r_o, r_h1, r_h2 in test_cases:\n        r_o_p, r_h1_p, r_h2_p = analytic_projection(r_o, r_h1, r_h2)\n        eps_len, eps_ang = calculate_errors(r_o_p, r_h1_p, r_h2_p)\n        results.extend([eps_len, eps_ang])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "即使是像SETTLE这样每步都解析地满足约束的算法，在经历数百万个时间步的长时程模拟后，也无法完全避免浮点运算带来的微小误差累积，即所谓的“约束漂移”。本练习  是一个数值实验，它将量化这种误差累积过程，并让你亲手检验不同计算精度和周期性重新归一化策略对维持模拟长期稳定性的影响。通过这个实践，你将深刻理解数值稳定性在分子动力学模拟中的重要性。",
            "id": "3444630",
            "problem": "考虑一个在分子动力学 (MD) 中建模的单个刚性水分子，其具有强制水分子三角形几何形状的完整约束。设位置为 $\\mathbf{r} = (\\mathbf{r}_{\\mathrm{O}}, \\mathbf{r}_{\\mathrm{H}_1}, \\mathbf{r}_{\\mathrm{H}_2}) \\in \\mathbb{R}^9$，并定义三个约束函数 $\\{g_i(\\mathbf{r})\\}_{i=1}^3$，分别对应于两个氧-氢 (O–H) 键长和一个氢-氢 (H–H) 间距：\n- $g_1(\\mathbf{r}) = \\|\\mathbf{r}_{\\mathrm{H}_1} - \\mathbf{r}_{\\mathrm{O}}\\|^2 - d_{\\mathrm{OH}}^2$,\n- $g_2(\\mathbf{r}) = \\|\\mathbf{r}_{\\mathrm{H}_2} - \\mathbf{r}_{\\mathrm{O}}\\|^2 - d_{\\mathrm{OH}}^2$,\n- $g_3(\\mathbf{r}) = \\|\\mathbf{r}_{\\mathrm{H}_2} - \\mathbf{r}_{\\mathrm{H}_1}\\|^2 - d_{\\mathrm{HH}}^2$,\n\n其中 $d_{\\mathrm{OH}}$ 是 O–H 平衡距离，$d_{\\mathrm{HH}}$ 是由氢-氧-氢 (H–O–H) 角 $\\theta$ 所决定的 H–H 平衡距离。假设采用一种常用的刚性几何结构：$d_{\\mathrm{OH}} = 0.9572\\,\\text{\\AA}$ 且 $\\theta = 104.52^\\circ$。使用余弦定理表示 $d_{\\mathrm{HH}}^2 = 2 d_{\\mathrm{OH}}^2 (1 - \\cos\\theta)$，并在国际单位制 (SI) 中进行计算，即将距离转换为米，并以 $\\text{m}^2$ 为单位报告距离的平方。在任何计算中，角度都必须以弧度处理。\n\n在一个约束 MD 积分器中，完整约束由诸如 SETTLE (一种用于刚性水的快速精确约束求解器)之类的解析求解器在每个时间步强制执行，理论上约束 $g_i(\\mathbf{r}) = 0$ 在每一步都得到满足。然而，有限精度算术会引入舍入误差。将每步的约束残差扰动建模为零均值随机增量 $\\delta g_i^{(n)}$，其幅度缩放关系为 $\\sigma_i \\propto \\epsilon \\, s_i$，其中 $\\epsilon$ 是浮点类型的机器ε，$s_i$ 是 $g_i$ 的一个特征尺度。对于此刚性三角形，取 $s_1 = d_{\\mathrm{OH}}^2$，$s_2 = d_{\\mathrm{OH}}^2$ 以及 $s_3 = d_{\\mathrm{HH}}^2$。累积约束残差随后按随机递推关系 $e_i^{(n+1)} = e_i^{(n)} + \\delta g_i^{(n)}$ 演化，并可选择性地通过重归一化策略每 $K$ 步重置一次。将第 $n$ 步的约束满足误差定义为 $\\max_i |g_i(\\mathbf{r}^{(n)})|$，在本模型中取 $g_i(\\mathbf{r}^{(n)}) \\approx e_i^{(n)}$。\n\n您的任务是：\n- 针对两种不同的浮点精度：单精度 ($\\epsilon_{\\mathrm{single}}$) 和双精度 ($\\epsilon_{\\mathrm{double}}$)，模拟在 $N = 10^7$ 步内约束满足误差的累积。\n- 比较每 $K$ 步执行一次的两种周期性重归一化策略：\n    1. 完全投影：在重归一化步骤中，将所有 $e_i^{(n)} \\leftarrow 0$。\n    2. 仅键长投影：在重归一化步骤中，将 $e_1^{(n)} \\leftarrow 0$ 和 $e_2^{(n)} \\leftarrow 0$，但保持 $e_3^{(n)}$ 不变。\n- 对于每种情况，测量单个标量值 $\\max_{0 \\le n  N} \\max_{i \\in \\{1,2,3\\}} |e_i^{(n)}|$，单位为 $\\text{m}^2$，并以浮点数形式报告。\n\n使用的基本原理：\n- 用于无约束动力学的牛顿第二定律 $m \\,\\frac{d^2 \\mathbf{r}}{dt^2} = \\mathbf{F}$。\n- 通过拉格朗日乘子和投影强制执行完整约束，在精确算术中保证 $g_i(\\mathbf{r}) = 0$。\n- 将有限精度舍入建模为一个零均值随机过程，其特征尺度与机器ε以及约束量的大小成正比。\n- 用于三角形几何的余弦定理。\n\n您必须使用可复现的伪随机数生成器，对指定重归一化下的随机累积 $e_i^{(n)}$ 进行纯数值模拟。不要假定上确界有任何闭式解；应使用向量化操作和分块处理进行数值计算，以在 $N = 10^7$ 的情况下保持高效。\n\n单位和角度说明：\n- 在平方前将 $d_{\\mathrm{OH}} = 0.9572\\,\\text{\\AA}$ 转换为米。$1\\,\\text{\\AA} = 10^{-10}\\,\\text{m}$。\n- 在计算 $\\cos\\theta$ 之前将 $\\theta = 104.52^\\circ$ 转换为弧度。\n\n测试套件：\n为以下参数集提供结果，每个结果以 $\\text{m}^2$ 为单位报告为单个浮点数：\n1. 精度：单精度，重归一化周期 $K = N$ (即无重归一化)，完全投影。\n2. 精度：单精度，重归一化周期 $K = 1000$，完全投影。\n3. 精度：双精度，重归一化周期 $K = N$ (即无重归一化)，完全投影。\n4. 精度：双精度，重归一化周期 $K = 100000$，完全投影。\n5. 精度：单精度，重归一化周期 $K = 1$，仅键长投影。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表 (例如 $[r_1,r_2,r_3,r_4,r_5]$)，其中每个 $r_j$ 是测试用例 $j$ 的最大误差，以 $\\text{m}^2$ 为单位的浮点数。",
            "solution": "用户希望解决一个关于模拟刚性水分子分子动力学 (MD) 模拟中约束满足误差累积的问题。\n\n### **问题验证**\n\n**步骤1：提取给定信息**\n\n-   **模型：** 分子动力学 (MD) 中的单个刚性水分子。\n-   **完整约束：**\n    -   $g_1(\\mathbf{r}) = \\|\\mathbf{r}_{\\mathrm{H}_1} - \\mathbf{r}_{\\mathrm{O}}\\|^2 - d_{\\mathrm{OH}}^2 = 0$\n    -   $g_2(\\mathbf{r}) = \\|\\mathbf{r}_{\\mathrm{H}_2} - \\mathbf{r}_{\\mathrm{O}}\\|^2 - d_{\\mathrm{OH}}^2 = 0$\n    -   $g_3(\\mathbf{r}) = \\|\\mathbf{r}_{\\mathrm{H}_2} - \\mathbf{r}_{\\mathrm{H}_1}\\|^2 - d_{\\mathrm{HH}}^2 = 0$\n-   **几何参数：**\n    -   O-H 平衡距离: $d_{\\mathrm{OH}} = 0.9572\\,\\text{\\AA}$\n    -   H-O-H 角: $\\theta = 104.52^\\circ$\n-   **导出参数：** $d_{\\mathrm{HH}}^2 = 2 d_{\\mathrm{OH}}^2 (1 - \\cos\\theta)$\n-   **单位：** 在 SI 单位制中进行计算。将 $\\text{\\AA}$ 转换为米，度转换为弧度。以 $\\text{m}^2$ 报告结果。\n-   **误差模型：**\n    -   每步的约束残差扰动: $\\delta g_i^{(n)}$\n    -   $\\delta g_i^{(n)}$ 是零均值随机增量。\n    -   幅度缩放: $\\sigma_i \\propto \\epsilon \\, s_i$，其中 $\\epsilon$ 是机器ε。\n    -   特征尺度: $s_1 = d_{\\mathrm{OH}}^2$, $s_2 = d_{\\mathrm{OH}}^2$, 以及 $s_3 = d_{\\mathrm{HH}}^2$。\n-   **误差演化：**\n    -   累积约束残差: $e_i^{(n+1)} = e_i^{(n)} + \\delta g_i^{(n)}$。\n    -   近似: $g_i(\\mathbf{r}^{(n)}) \\approx e_i^{(n)}$。\n    -   总步数: $N = 10^7$。\n-   **重归一化策略：** 每 K 步执行一次。\n    1.  **完全投影：** 在重归一化步骤中将所有 $e_i^{(n)} \\leftarrow 0$。\n    2.  **仅键长投影：** 在重归一化步骤中将 $e_1^{(n)} \\leftarrow 0$ 和 $e_2^{(n)} \\leftarrow 0$，但保持 $e_3^{(n)}$ 不变。\n-   **任务：**\n    -   模拟两种浮点精度（单精度，双精度）下的误差累积。\n    -   比较两种重归一化策略。\n    -   测量单个标量值 $\\max_{0 \\le n  N} \\max_{i \\in \\{1,2,3\\}} |e_i^{(n)}|$，单位为 $\\text{m}^2$。\n-   **实现：** 使用可复现的伪随机数生成器和高效的向量化操作。\n-   **测试套件：** 五个特定的参数集，组合了精度、重归一化周期 K 和投影策略。\n\n**步骤2：使用提取的给定信息进行验证**\n\n-   **科学依据：** 该问题牢固地植根于计算物理学和计算化学的原理，特别是分子动力学。约束算法（如SETTLE）的使用、完整约束的概念以及数值精度误差的建模都是该领域的标准课题。所提供的水分子几何参数是标准的（例如，TIP3P 或 SPC/E 模型）。将误差累积建模为随机游走是数值分析中一种有效且常见的简化方法。该设置在科学上是合理的。\n-   **适定性：** 该问题在很大程度上是适定的。它定义了一个随机过程，并要求从模拟中获得特定统计量（轨迹的最大值）的数值估计。陈述“幅度按 $\\sigma_i \\propto \\epsilon \\, s_i$ 比例缩放”中存在轻微的模糊性，因为它没有指定比例常数或随机增量的确切概率分布。然而，在基于物理的建模中，这是典型情况，必须做出合理的假设。假设比例常数为 $1$ 和标准的均匀分布（例如，$U[-\\sigma_i, \\sigma_i]$）是一个合理的选择，它允许获得唯一的数值解。对可复现伪随机数生成器的要求证实了期望得到一个特定的数值答案。\n-   **有效性与完整性：** 该问题以客观、定量的术语陈述。所有必要的参数（$d_{\\mathrm{OH}}, \\theta, N, K$, 精度）都已提供。任务是明确的。设置是自洽的，没有矛盾。\n\n**步骤3：结论与行动**\n\n该问题被认为是有效的。它是一个定义明确的计算问题，旨在测试对数值模拟中误差传播的理解，并要求高效的实现。误差模型中的轻微模糊性是可以接受的，因为它要求做出一个标准的、合理的建模选择。\n\n### **求解过程**\n\n问题的核心是模拟一个随机过程，该过程代表了刚性水分子约束方程中数值误差的累积。在第 $n$ 步，系统的状态是约束违反向量 $e^{(n)} = (e_1^{(n)}, e_2^{(n)}, e_3^{(n)})$，它根据递推关系演化：\n$$\ne_i^{(n+1)} = e_i^{(n)} + \\delta g_i^{(n)}\n$$\n从 $e^{(0)} = (0, 0, 0)$ 开始。\n\n**1. 误差项建模**\n每步误差增量 $\\delta g_i^{(n)}$ 是一个随机变量。问题陈述其为零均值，且其幅度按 $\\sigma_i \\propto \\epsilon s_i$ 缩放。我们将做出标准且合理的假设，即比例常数为 $1$，因此尺度为 $\\sigma_i = \\epsilon s_i$。我们将该增量建模为均匀分布的随机变量，$\\delta g_i^{(n)} \\sim U[-\\sigma_i, \\sigma_i]$。这一选择为对称舍入误差提供了一个简单而有代表性的模型。\n\n**2. 物理尺度的计算**\n首先，将所有参数转换为 SI 单位。\n-   O-H 键长为 $d_{\\mathrm{OH}} = 0.9572\\,\\text{\\AA} = 0.9572 \\times 10^{-10}\\,\\text{m}$。\n-   H-O-H 键角为 $\\theta = 104.52^\\circ$，为进行三角函数计算，将其转换为弧度：$\\theta_{\\text{rad}} = 104.52 \\times \\frac{\\pi}{180}$。\n-   平方距离约束的特征尺度 $s_i$ 为：\n    -   $s_1 = s_2 = d_{\\mathrm{OH}}^2 = (0.9572 \\times 10^{-10})^2\\,\\text{m}^2 \\approx 9.1623 \\times 10^{-21}\\,\\text{m}^2$。\n    -   $s_3 = d_{\\mathrm{HH}}^2 = 2 d_{\\mathrm{OH}}^2 (1 - \\cos\\theta_{\\text{rad}}) \\approx 2.2917 \\times 10^{-20}\\,\\text{m}^2$。\n\n**3. 浮点精度和扰动尺度**\n机器ε，$\\epsilon$，取决于浮点精度：\n-   单精度 (`float32`): $\\epsilon_{\\text{single}} \\approx 1.192 \\times 10^{-7}$。\n-   双精度 (`float64`): $\\epsilon_{\\text{double}} \\approx 2.220 \\times 10^{-16}$。\n\n然后为每种精度计算扰动尺度 $\\sigma_i = \\epsilon s_i$。对于单精度，$\\sigma_1 = \\sigma_2 \\approx 1.09 \\times 10^{-27}\\,\\text{m}^2$ 且 $\\sigma_3 \\approx 2.73 \\times 10^{-27}\\,\\text{m}^2$。对于双精度，这些尺度要小很多个数量级。\n\n**4. 模拟算法（一般情况）**\n对 $N=10^7$ 步进行直接的步进模拟在 Python 中会很低效。如建议所述，我们使用一种向量化的、基于块的方法。该模拟的结构是以对应于重归一化周期 $K$ 的数据块来处理数据。这样做是高效的，因为 Python 循环仅运行 $N/K$ 次，并且每次迭代都在大小为 $K$ 的数组上执行快速的 NumPy 向量化操作。\n\n对于给定的测试用例，算法按以下步骤进行：\n1.  初始化误差向量 $e = (0,0,0)$ 和总体最大绝对误差 `max_abs_error = 0`。为一个可复现的伪随机数生成器设置种子。\n2.  当已处理的总步数小于 $N$ 时进行循环。在每次循环迭代中，模拟一个最多为 $K$ 步的“周期”。\n3.  使用 `numpy.random.uniform` 为 3 个约束中的每一个生成一个包含 $K$ 个随机增量 $(\\delta g^{(n)})$ 的数组。\n4.  使用 `numpy.cumsum` 计算此周期内误差向量的轨迹。该周期的初始误差是前一个周期的最终误差。\n5.  通过在新生成的轨迹部分中找到最大绝对值来更新 `max_abs_error`。\n6.  误差向量 $e$ 更新为此周期轨迹的最后一个值。\n7.  在周期结束时（如果已执行 `K` 步），根据指定的重归一化策略（'full' 或 'bond-only'）重置误差向量 $e$。\n\n**5. 模拟算法（特殊情况 $K=1$）**\n测试用例 5，其中 $K=1$ 且采用 'bond-only' 投影，代表了一种独特的场景，它允许一个更高效、完全向量化的实现。\n-   在 $K=1$ 时进行 'bond-only' 投影意味着在每一步，$e_1$ 和 $e_2$ 都会被重置为 $0$。因此，它们的误差不会累积：$e_{1,2}^{(n)} = \\delta g_{1,2}^{(n)}$。这些分量的最大误差就是 $N$ 步中抽取的任何随机增量的最大幅度。\n-   第三个分量 $e_3$ 从不重置。它在所有 $N$ 步中都经历一个标准的随机游走：$e_3^{(n)} = \\sum_{j=0}^{n-1} \\delta g_3^{(j)}$。\n-   因此，总体最大误差为 $\\max\\left( \\max_{n, i \\in \\{1,2\\}} |\\delta g_i^{(n)}|, \\max_{n} |e_3^{(n)}| \\right)$。\n-   这可以通过在单次操作中为所有 3 个分量生成所有 $N$ 个随机增量，然后计算分量 1 和 2 的绝对值的最大值，以及分量 3 的累积和的绝对值的最大值来非常高效地计算。\n-   这两种算法方法允许按要求对所有五个测试用例进行高效和准确的模拟。\n这两种算法方法允许按要求对所有五个测试用例进行高效和准确的模拟。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation_generic(precision: str, K: int, strategy: str, N: int, seed: int) - float:\n    \"\"\"\n    Simulates error accumulation for the general case using K-step cycles.\n    \"\"\"\n    if precision == 'single':\n        dtype = np.float32\n    else:\n        dtype = np.float64\n    epsilon = np.finfo(dtype).eps\n\n    d_OH = 0.9572e-10  # meters\n    theta_deg = 104.52\n    theta_rad = np.deg2rad(theta_deg)\n\n    s1 = dtype(d_OH**2)\n    s2 = s1\n    s3 = dtype(2 * s1 * (1 - np.cos(theta_rad)))\n    scales = np.array([s1, s2, s3], dtype=dtype)\n    sigmas = epsilon * scales\n\n    rng = np.random.default_rng(seed)\n    e = np.zeros(3, dtype=dtype)\n    max_abs_error = dtype(0.0)\n\n    num_steps_processed = 0\n    while num_steps_processed  N:\n        steps_in_cycle = min(K, N - num_steps_processed)\n        \n        deltas = rng.uniform(-sigmas, sigmas, size=(steps_in_cycle, 3)).astype(dtype)\n\n        cycle_errors = e + np.cumsum(deltas, axis=0)\n        \n        if steps_in_cycle > 0:\n            current_max = np.max(np.abs(cycle_errors))\n            max_abs_error = np.maximum(max_abs_error, current_max)\n        \n        if steps_in_cycle > 0:\n            e = cycle_errors[-1]\n            \n        num_steps_processed += steps_in_cycle\n\n        if num_steps_processed % K == 0 and num_steps_processed  N:\n            if strategy == 'full':\n                e[:] = 0.0\n            elif strategy == 'bond-only':\n                e[0:2] = 0.0\n    \n    return float(max_abs_error)\n\n\ndef run_simulation_case5(precision: str, N: int, seed: int) - float:\n    \"\"\"\n    Simulates error accumulation for the special case with K=1 and bond-only projection.\n    \"\"\"\n    if precision == 'single':\n        dtype = np.float32\n    else: # double\n        dtype = np.float64\n    epsilon = np.finfo(dtype).eps\n\n    d_OH = 0.9572e-10  # meters\n    theta_deg = 104.52\n    theta_rad = np.deg2rad(theta_deg)\n\n    s1 = dtype(d_OH**2)\n    s2 = s1\n    s3 = dtype(2 * s1 * (1 - np.cos(theta_rad)))\n    scales = np.array([s1, s2, s3], dtype=dtype)\n    sigmas = epsilon * scales\n\n    rng = np.random.default_rng(seed)\n    \n    deltas = rng.uniform(-sigmas, sigmas, size=(N, 3)).astype(dtype)\n    \n    # For components 1 and 2, error is reset every step, so e_i(n) = delta_i(n).\n    max_abs_e12 = np.max(np.abs(deltas[:, 0:2])) if N > 0 else dtype(0.0)\n    \n    # For component 3, error accumulates in a random walk.\n    e3_walk = np.cumsum(deltas[:, 2])\n    max_abs_e3 = np.max(np.abs(e3_walk)) if N > 0 else dtype(0.0)\n\n    return float(np.maximum(max_abs_e12, max_abs_e3))\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    N_steps = 10**7\n\n    test_cases = [\n        {'precision': 'single', 'K': N_steps, 'strategy': 'full'},\n        {'precision': 'single', 'K': 1000, 'strategy': 'full'},\n        {'precision': 'double', 'K': N_steps, 'strategy': 'full'},\n        {'precision': 'double', 'K': 100000, 'strategy': 'full'},\n        {'precision': 'single', 'K': 1, 'strategy': 'bond-only'},\n    ]\n\n    results = []\n    # Use a different seed for each case to ensure statistical independence\n    # while maintaining reproducibility for each case individually.\n    base_seed = 42\n\n    for i, case in enumerate(test_cases):\n        seed = base_seed + i\n        if case['K'] == 1 and case['strategy'] == 'bond-only':\n            # Use the specialized, efficient function for Case 5\n            result = run_simulation_case5(case['precision'], N_steps, seed)\n        else:\n            # Use the generic function for all other cases\n            result = run_simulation_generic(case['precision'], case['K'], case['strategy'], N_steps, seed)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}