{
    "hands_on_practices": [
        {
            "introduction": "在约束分子动力学中，计算由拉格朗日乘子 $\\lambda$ 表示的约束力是至关重要的一步。这个计算通常涉及求解一个称为舒尔补（Schur complement）系统的线性方程组，$S \\lambda = b$，其中 $S = C M^{-1} C^\\top$。\n\n本练习将指导您推导这个基本方程组，并实现两种关键的求解方法：适用于小型系统的直接求解器，以及对大规模模拟至关重要的迭代共轭梯度法。掌握这些技术是实现 SHAKE 或 RATTLE 等约束算法的基石。",
            "id": "3416388",
            "problem": "在一个带有完整约束的约束分子动力学系统中，设有$N$个粒子，其位置为$q \\in \\mathbb{R}^{3N}$，速度为$v \\in \\mathbb{R}^{3N}$，以及一个对角质量矩阵$M \\in \\mathbb{R}^{3N \\times 3N}$，其中$M = \\mathrm{diag}(m_1 I_3, m_2 I_3, \\dots, m_N I_3)$，$m_i > 0$且$I_3$是$3 \\times 3$的单位矩阵。考虑一组$m$个完整约束，形式为$g_k(q) = 0$，其雅可比矩阵的行向量为$C_k \\in \\mathbb{R}^{1 \\times 3N}$，这些行向量组成了约束雅可比矩阵$C \\in \\mathbb{R}^{m \\times 3N}$。为了使用拉格朗日乘子强制或投影速度层级的约束$C \\Delta v = \\dot{\\eta}$，会施加一个形式为$\\Delta v = M^{-1} C^\\top \\lambda$的速度修正，其中$\\lambda \\in \\mathbb{R}^{m}$是拉格朗日乘子。消去$\\Delta v$后，得到舒尔补线性系统\n$$\n(C M^{-1} C^\\top) \\lambda = \\dot{\\eta}.\n$$\n请从牛顿第二定律和带拉格朗日乘子的完整约束的定义出发，在速度层级上推导出上述舒尔补系统。然后实现一个程序，对于给定的测试套件，从成对距离约束中构造$C$，组装$S = C M^{-1} C^\\top$，并分别使用直接稠密线性求解器和针对对称正定（SPD）矩阵的迭代共轭梯度法求解$\\lambda$。对于近乎奇异的情况，使用吉洪诺夫正则化，即求解$(S + \\varepsilon I)\\lambda = \\dot{\\eta}$，其中给定了$\\varepsilon \\ge 0$。\n\n在此问题中，所有变量都是无量纲的。不使用角度。不需要物理单位。\n\n成对距离约束的约束构造：对于粒子$i$和$j$（位置分别为$r_i, r_j \\in \\mathbb{R}^3$）之间的一个约束，定义$d_{ij} = r_j - r_i \\in \\mathbb{R}^3$。相应的雅可比矩阵行向量$C_k$在除了粒子$i$和粒子$j$的$3$-维块之外处处为零，其中粒子$i$的块为$-d_{ij}^\\top$，粒子$j$的块为$+d_{ij}^\\top$。这种选择对应于距离平方约束的时间导数，并产生与$d_{ij} \\cdot (v_j - v_i)$成比例的速度层级约束。\n\n您必须：\n- 从第一性原理出发，推导出舒尔补系统$(C M^{-1} C^\\top) \\lambda = \\dot{\\eta}$。\n- 实现两种求解$\\lambda$的方法：一个直接稠密求解器和一个迭代共轭梯度求解器，其停止准则为$\\lVert r_k \\rVert_2 \\le \\max(\\tau_{\\mathrm{rel}} \\lVert \\dot{\\eta} \\rVert_2, \\tau_{\\mathrm{abs}})$，其中$r_k$是第$k$次迭代的残差。使用$\\tau_{\\mathrm{rel}} = 10^{-12}$和$\\tau_{\\mathrm{abs}} = 10^{-14}$，以及最大迭代次数$10^4$。\n- 对于下方的每个测试用例，根据位置和约束对构造$C$，组装$S = C M^{-1} C^\\top$，构成$A = S + \\varepsilon I$，用两种方法求解$A \\lambda = \\dot{\\eta}$，并报告：\n  - 两种解法所得解之差的无穷范数，$\\lVert \\lambda_{\\mathrm{direct}} - \\lambda_{\\mathrm{CG}} \\rVert_{\\infty}$。\n  - 2-范数残差$\\lVert A \\lambda_{\\mathrm{direct}} - \\dot{\\eta} \\rVert_2$和$\\lVert A \\lambda_{\\mathrm{CG}} - \\dot{\\eta} \\rVert_2$。\n\n测试套件（以下描述中所有索引均为从1开始；根据需要使用从0开始的索引实现）：\n- 情况1（正常路径，单个约束）：\n  - $N = 2$, $m = 1$。\n  - 质量：$[12, 16]$。\n  - 位置：$r_1 = (0, 0, 0)$，$r_2 = (1, 0, 0)$。\n  - 约束：$(1, 2)$。\n  - 右端项$\\dot{\\eta} = [0.1]$。\n  - 正则化$\\varepsilon = 0$。\n- 情况2（多个约束，链式结构）：\n  - $N = 3$, $m = 2$。\n  - 质量：$[12, 14, 12]$。\n  - 位置：$r_1 = (0, 0, 0)$，$r_2 = (1, 0, 0)$，$r_3 = (2, 0, 0)$。\n  - 约束：$(1, 2)$和$(2, 3)$。\n  - 右端项$\\dot{\\eta} = [0, 0.05]$。\n  - 正则化$\\varepsilon = 0$。\n- 情况3（近乎冗余的约束，正则化处理）：\n  - $N = 3$, $m = 2$。\n  - 质量：$[12, 12, 12]$。\n  - 位置：$r_1 = (0, 0, 0)$，$r_2 = (1, 0, 0)$，$r_3 = (1, 10^{-6}, 0)$。\n  - 约束：$(1, 2)$和$(1, 3)$。\n  - 右端项$\\dot{\\eta} = [0.01, 0.01]$。\n  - 正则化$\\varepsilon = 10^{-12}$。\n- 情况4（边界情况，零右端项，极端质量）：\n  - $N = 2$, $m = 1$。\n  - 质量：$[10^{-6}, 10]$。\n  - 位置：$r_1 = (0, 0, 0)$，$r_2 = (0.5, 0, 0)$。\n  - 约束：$(1, 2)$。\n  - 右端项$\\dot{\\eta} = [0]$。\n  - 正则化$\\varepsilon = 0$。\n- 情况5（极端质量比，约束链）：\n  - $N = 4$, $m = 3$。\n  - 质量：$[100, 0.1, 0.1, 100]$。\n  - 位置：$r_1 = (0, 0, 0)$，$r_2 = (1, 0, 0)$，$r_3 = (2, 0, 0)$，$r_4 = (3, 0, 0)$。\n  - 约束：$(1, 2)$, $(2, 3)$, $(3, 4)$。\n  - 右端项$\\dot{\\eta} = [0.02, -0.01, 0]$。\n  - 正则化$\\varepsilon = 0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表用方括号括起来。对于每个情况，按以下顺序输出三个浮点数：$[\\lVert \\lambda_{\\mathrm{direct}} - \\lambda_{\\mathrm{CG}} \\rVert_{\\infty}, \\lVert A \\lambda_{\\mathrm{direct}} - \\dot{\\eta} \\rVert_2, \\lVert A \\lambda_{\\mathrm{CG}} - \\dot{\\eta} \\rVert_2]$。将所有情况的结果依次聚合到一个扁平列表中。例如，如果有两个情况，输出可能看起来像$[d_1, r_{d,1}, r_{i,1}, d_2, r_{d,2}, r_{i,2}]$。\n- 不应打印任何其他文本。",
            "solution": "我们从带有通过拉格朗日乘子施加的完整约束的牛顿第二定律开始。设$q \\in \\mathbb{R}^{3N}$为位置，$v = \\dot{q} \\in \\mathbb{R}^{3N}$为速度。无约束的运动方程为$M \\dot{v} = f(q, v, t)$，其中$M \\in \\mathbb{R}^{3N \\times 3N}$对于点质量而言是对称正定的对角矩阵。对于形式为$g_k(q) = 0$（其中$k \\in \\{1, \\dots, m\\}$）的完整约束，其约束雅可比矩阵$C(q) \\in \\mathbb{R}^{m \\times 3N}$的行向量为$C_k = \\partial g_k / \\partial q$。引入拉格朗日乘子$\\lambda \\in \\mathbb{R}^m$，约束方程为\n$$\nM \\dot{v} = f + C^\\top \\lambda,\n$$\n同时在速度层级有运动学约束\n$$\nC v = 0,\n$$\n以便在时间上精确地施加完整约束。\n\n为了投影速度或施加一个校正冲量以达到满足\n$$\nC \\Delta v = \\dot{\\eta}\n$$\n的期望速度变化$\\Delta v$，我们考虑一个瞬时校正，期间忽略其他力。与乘子$\\lambda$相关的冲量会引起速度变化\n$$\n\\Delta v = M^{-1} C^\\top \\lambda.\n$$\n代入速度层级的约束中，得到\n$$\nC \\Delta v = C M^{-1} C^\\top \\lambda = \\dot{\\eta},\n$$\n这就是舒尔补系统\n$$\n(C M^{-1} C^\\top) \\lambda = \\dot{\\eta}.\n$$\n对于独立的约束，$S := C M^{-1} C^\\top$是对称正定（SPD）的，因此是可逆的，系统有唯一解。当约束近乎冗余时，$S$可能是病态的；吉洪诺夫正则化通过用$A := S + \\varepsilon I$（其中$\\varepsilon \\ge 0$）替换$S$来稳定求解过程。\n\n成对距离约束的约束构造：考虑形式为$g_{ij}(q) = \\|r_j - r_i\\|^2 - \\ell_{ij}^2 = 0$的完整约束。其雅可比矩阵行向量为\n$$\nC_{ij} = \\left[ \\dots, \\frac{\\partial g_{ij}}{\\partial r_i}, \\dots, \\frac{\\partial g_{ij}}{\\partial r_j}, \\dots \\right] = \\left[ \\dots, -2 (r_j - r_i)^\\top, \\dots, 2 (r_j - r_i)^\\top, \\dots \\right].\n$$\n在速度层级，$\\dot{g}_{ij} = C_{ij} v = 2 (r_j - r_i) \\cdot (v_j - v_i)$。标量因子$2$可以被吸收到乘子中而不失一般性；因此，我们等价地使用一个与方向向量成比例的雅可比行向量，\n$$\n\\tilde{C}_{ij} = \\left[ \\dots, -(r_j - r_i)^\\top, \\dots, (r_j - r_i)^\\top, \\dots \\right],\n$$\n这会生成相同的零空间，并导致一个按常数缩放的等价舒尔补系统。使用这种线性化形式，我们通过堆叠所有约束的此类行向量来组装$C$。\n\n每个测试用例的算法步骤：\n- 构建$M^{-1}$作为一个对角矩阵，其中每个质量$m_i$为其三个空间分量重复出现，使得$M^{-1} = \\mathrm{diag}(m_1^{-1} I_3, \\dots, m_N^{-1} I_3)$。\n- 使用上述规则和$d_{ij} = r_j - r_i$组装$C \\in \\mathbb{R}^{m \\times 3N}$。\n- 通过用相应的逆质量缩放$C$的列，然后将$S$作为稠密乘积来高效计算$S = C M^{-1} C^\\top$。\n- 构成$A = S + \\varepsilon I$。\n- 通过以下方法求解$A \\lambda = \\dot{\\eta}$：\n  - 使用高斯消去法的直接稠密求解（例如，一个通用的稠密线性求解器）。\n  - 共轭梯度（CG）法，该方法适用是因为当$\\varepsilon \\ge 0$且约束独立时，$A$是SPD的。使用停止准则$\\lVert r_k \\rVert_2 \\le \\max(\\tau_{\\mathrm{rel}} \\lVert \\dot{\\eta} \\rVert_2, \\tau_{\\mathrm{abs}})$，其中$\\tau_{\\mathrm{rel}} = 10^{-12}$，$\\tau_{\\mathrm{abs}} = 10^{-14}$，最大迭代次数为$10^4$。\n- 报告诊断信息：\n  - 解之间差值的无穷范数，$\\lVert \\lambda_{\\mathrm{direct}} - \\lambda_{\\mathrm{CG}} \\rVert_{\\infty}$。\n  - 残差范数$\\lVert A \\lambda_{\\mathrm{direct}} - \\dot{\\eta} \\rVert_2$和$\\lVert A \\lambda_{\\mathrm{CG}} - \\dot{\\eta} \\rVert_2$。\n\n为什么共轭梯度法适用：对于独立约束，由于对于任何非零$x \\in \\mathbb{R}^m$，\n$$\nx^\\top S x = x^\\top C M^{-1} C^\\top x = (C^\\top x)^\\top M^{-1} (C^\\top x) > 0,\n$$\n$S = C M^{-1} C^\\top$是对称正定的，因为$M^{-1}$是SPD的，且对于独立约束，$C^\\top x \\ne 0$。对于$\\varepsilon \\ge 0$，加上$\\varepsilon I$保持了对称性和正定性；当$\\varepsilon > 0$时，即使$C$是秩亏的，也能保证严格正定性。因此CG方法会收敛。\n\n测试套件覆盖范围的基本原理：\n- 情况1验证了基本的单约束场景。\n- 情况2测试了多个约束以及通过链式结构的耦合。\n- 情况3探究了近乎冗余的情况以及使用$\\varepsilon = 10^{-12}$进行正则化的必要性。\n- 情况4强制一个零右端项和极端的质量缩放，此时精确解为$\\lambda = 0$，残差应达到机器精度。\n- 情况5通过极端质量比和多个耦合约束来考验条件的稳定性。\n\n预期结果：在所有适定情况中，直接解和CG解在数值精度范围内应保持一致，因此$\\lVert \\lambda_{\\mathrm{direct}} - \\lambda_{\\mathrm{CG}} \\rVert_{\\infty}$应接近机器精度，并且两个残差范数都应很小（在停止容差的量级或更小）。正则化的情况3也应产生微小的差异，因为正则化后的系统是SPD的。\n\n最终程序实现了这些步骤，并按要求为每个案例打印一个包含三个诊断指标的扁平列表。",
            "answer": "```python\nimport numpy as np\n\ndef build_C(positions, constraints):\n    \"\"\"\n    Build the constraint Jacobian C for pairwise distance constraints.\n    positions: array of shape (N,3)\n    constraints: list of (i,j) with 0-based indices\n    Returns C of shape (m, 3N)\n    \"\"\"\n    N = positions.shape[0]\n    m = len(constraints)\n    C = np.zeros((m, 3 * N), dtype=float)\n    for k, (i, j) in enumerate(constraints):\n        d = positions[j] - positions[i]  # vector r_j - r_i\n        # Place -d^T in block for i, +d^T in block for j\n        C[k, 3 * i:3 * i + 3] = -d\n        C[k, 3 * j:3 * j + 3] = +d\n    return C\n\ndef assemble_S(C, masses):\n    \"\"\"\n    Assemble S = C M^{-1} C^T given C and masses.\n    masses: array of length N\n    \"\"\"\n    N = len(masses)\n    inv_masses = 1.0 / np.asarray(masses, dtype=float)\n    # Scale columns of C by inverse masses for each 3-block\n    C_scaled = C.copy()\n    for i in range(N):\n        C_scaled[:, 3 * i:3 * i + 3] *= inv_masses[i]\n    S = C_scaled @ C.T\n    return S\n\ndef conjugate_gradient(A, b, tol_rel=1e-12, tol_abs=1e-14, maxiter=10_000):\n    \"\"\"\n    Conjugate Gradient for SPD dense matrix A and vector b.\n    Stops when ||r||_2 = max(tol_rel * ||b||_2, tol_abs)\n    Returns x, iters, final_res_norm\n    \"\"\"\n    n = A.shape[0]\n    x = np.zeros(n, dtype=float)\n    r = b - A @ x\n    p = r.copy()\n    rsold = float(r @ r)\n    bnorm = np.linalg.norm(b)\n    tol = max(tol_rel * bnorm, tol_abs)\n    if np.sqrt(rsold) = tol:\n        return x, 0, np.sqrt(rsold)\n    for k in range(1, maxiter + 1):\n        Ap = A @ p\n        pAp = float(p @ Ap)\n        if pAp == 0.0:\n            # Breakdown; return current iterate\n            resn = np.sqrt(rsold)\n            return x, k - 1, resn\n        alpha = rsold / pAp\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = float(r @ r)\n        if np.sqrt(rsnew) = tol:\n            return x, k, np.sqrt(rsnew)\n        beta = rsnew / rsold\n        p = r + beta * p\n        rsold = rsnew\n    return x, maxiter, np.sqrt(rsold)\n\ndef solve_case(masses, positions, constraint_pairs, dot_eta, epsilon):\n    \"\"\"\n    Solve one test case:\n    - Build C from positions and constraints\n    - Assemble S = C M^{-1} C^T\n    - Form A = S + epsilon * I\n    - Solve A lambda = dot_eta by direct solve and CG\n    - Return diagnostics: inf-norm difference, residual norms for direct and CG\n    \"\"\"\n    masses = np.array(masses, dtype=float)\n    positions = np.array(positions, dtype=float)\n    C = build_C(positions, constraint_pairs)\n    S = assemble_S(C, masses)\n    m = S.shape[0]\n    if epsilon != 0.0:\n        A = S + epsilon * np.eye(m)\n    else:\n        A = S.copy()\n    b = np.array(dot_eta, dtype=float)\n\n    # Direct solve\n    try:\n        lam_direct = np.linalg.solve(A, b)\n    except np.linalg.LinAlgError:\n        # Fallback to least squares if singular (should not happen with epsilon > 0)\n        lam_direct, *_ = np.linalg.lstsq(A, b, rcond=None)\n\n    # CG solve\n    lam_cg, iters, res_cg = conjugate_gradient(A, b, tol_rel=1e-12, tol_abs=1e-14, maxiter=10000)\n\n    # Diagnostics\n    diff_inf = float(np.max(np.abs(lam_direct - lam_cg))) if lam_direct.size > 0 else 0.0\n    resid_direct = float(np.linalg.norm(A @ lam_direct - b))\n    resid_cg = float(np.linalg.norm(A @ lam_cg - b))\n\n    return diff_inf, resid_direct, resid_cg\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"masses\": [12.0, 16.0],\n            \"positions\": [\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n            ],\n            \"constraints\": [(0, 1)],\n            \"dot_eta\": [0.1],\n            \"epsilon\": 0.0,\n        },\n        # Case 2\n        {\n            \"masses\": [12.0, 14.0, 12.0],\n            \"positions\": [\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [2.0, 0.0, 0.0],\n            ],\n            \"constraints\": [(0, 1), (1, 2)],\n            \"dot_eta\": [0.0, 0.05],\n            \"epsilon\": 0.0,\n        },\n        # Case 3\n        {\n            \"masses\": [12.0, 12.0, 12.0],\n            \"positions\": [\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [1.0, 1e-6, 0.0],\n            ],\n            \"constraints\": [(0, 1), (0, 2)],\n            \"dot_eta\": [0.01, 0.01],\n            \"epsilon\": 1e-12,\n        },\n        # Case 4\n        {\n            \"masses\": [1e-6, 10.0],\n            \"positions\": [\n                [0.0, 0.0, 0.0],\n                [0.5, 0.0, 0.0],\n            ],\n            \"constraints\": [(0, 1)],\n            \"dot_eta\": [0.0],\n            \"epsilon\": 0.0,\n        },\n        # Case 5\n        {\n            \"masses\": [100.0, 0.1, 0.1, 100.0],\n            \"positions\": [\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [2.0, 0.0, 0.0],\n                [3.0, 0.0, 0.0],\n            ],\n            \"constraints\": [(0, 1), (1, 2), (2, 3)],\n            \"dot_eta\": [0.02, -0.01, 0.0],\n            \"epsilon\": 0.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        diff_inf, resid_direct, resid_cg = solve_case(\n            case[\"masses\"],\n            case[\"positions\"],\n            case[\"constraints\"],\n            case[\"dot_eta\"],\n            case[\"epsilon\"],\n        )\n        results.extend([diff_inf, resid_direct, resid_cg])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在理解了如何求解拉格朗日乘子之后，一个自然而然的进阶问题是思考如何更有效地构建问题。坐标系的选择——无论是笛卡尔坐标还是广义内坐标——并不仅仅是符号上的便利。\n\n这个选择深刻地影响着约束雅可比矩阵 $C$ 及其导出的舒尔补矩阵的结构和数值条件。在这个动手练习中，您将通过推导不同坐标系下雅可比矩阵之间的联系，并数值化地比较它们的稳定性，来探索这一关系。您将发现为何一组精心选择的内坐标可以实现更稳定、更高效的约束执行，这是构建稳健模拟软件的关键洞见。",
            "id": "3416352",
            "problem": "考虑一个平面三原子分子，其原子标记为 $1$、$2$ 和 $3$。设广义内坐标为 $q = [r_{12}, r_{23}, \\theta]^\\top$，其中 $r_{12}$ 是原子 $1$ 和原子 $2$ 之间的键长（以埃为单位），$r_{23}$ 是原子 $2$ 和原子 $3$ 之间的键长（以埃为单位），$\\theta$ 是在原子 $2$ 处形成的角度（从原子 $2$ 到原子 $1$ 的向量与从原子 $2$ 到原子 $3$ 的向量之间的夹角，以弧度为单位）。通过将原子 $1$ 置于原点，原子 $2$ 置于 $x$ 轴上，原子 $3$ 置于由 $r_{23}$ 和 $\\theta$ 决定的位置，来定义一个从内坐标 $q$ 到笛卡尔坐标 $x \\in \\mathbb{R}^{6}$ 的固定体坐标系映射。具体来说，使用以下映射\n$$\nx(q) = \\begin{bmatrix}\nx_{1x} \\\\ x_{1y} \\\\ x_{2x} \\\\ x_{2y} \\\\ x_{3x} \\\\ x_{3y}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\ 0 \\\\\nr_{12} \\\\ 0 \\\\\nr_{12} + r_{23}\\cos\\theta \\\\\nr_{23}\\sin\\theta\n\\end{bmatrix}.\n$$\n考虑两个完整约束（holonomic constraints），使键长保持在目标值附近：\n$$\ng_1(x) = \\left\\| x_2 - x_1 \\right\\| - r_{12}^{\\text{target}}, \\quad\ng_2(x) = \\left\\| x_3 - x_2 \\right\\| - r_{23}^{\\text{target}},\n$$\n其中 $r_{12}^{\\text{target}}$ 和 $r_{23}^{\\text{target}}$ 是目标键长（以埃为单位）。在分子动力学 (MD) 的背景下，这些约束通过拉格朗日乘子（Lagrange multipliers）来强制执行。定义笛卡尔坐标下的约束雅可比矩阵 $C_{\\text{cartesian}}(x) = \\partial g/\\partial x \\in \\mathbb{R}^{2\\times 6}$ 和坐标映射的雅可比矩阵 $J(q) = \\partial x/\\partial q \\in \\mathbb{R}^{6\\times 3}$。\n\n您的任务是：\n- 从完整约束的定义和多元函数的链式法则出发，推导在映射 $x(q)$ 下，以广义内坐标表示的约束梯度与以笛卡尔坐标表示的约束梯度之间的关系。\n- 对于给定的平面三原子映射，显式计算雅可比矩阵 $J(q)$。\n- 实现一个数值程序来构建 $C_{\\text{cartesian}}(x)$、$J(q)$ 以及通过链式法则计算的内坐标约束雅可比矩阵。数值验证对于此特定映射，内坐标约束雅可比矩阵与解析的内坐标梯度相匹配。\n- 通过求解最小范数线性化校正问题，比较在笛卡尔坐标与内坐标中强制执行线性化约束的效果：\n    - 笛卡尔空间校正：在最小范数意义下，求解 $C_{\\text{cartesian}}\\delta x = -g(x)$ 得到 $\\delta x$。\n    - 内坐标空间校正：在最小范数意义下，求解 $C_{\\text{internal}}\\delta q = -g(x)$ 得到 $\\delta q$，然后通过 $\\delta x = J \\delta q$ 映射到笛卡尔坐标。\n  在 $2\\times 2$ 的格拉姆矩阵（Gram matrix）中添加一个小的 Tikhonov 正则化项，以处理潜在的近奇异几何构型。\n\n分析数值条件和准确性：\n- 计算 $2\\times 2$ 格拉姆矩阵 $G_{\\text{cartesian}} = C_{\\text{cartesian}}C_{\\text{cartesian}}^\\top$ 和 $G_{\\text{internal}} = C_{\\text{internal}}C_{\\text{internal}}^\\top$ 的条件数。\n- 对笛卡尔和内坐标两种强制执行方式，评估定义为 $\\|\\delta x\\|_2 / \\|g\\|_2$ 的放大因子。\n- 对两种方法，评估校正后精确的约束残差范数 $\\|g(x+\\delta x)\\|_2$。\n- 评估通过链式法则计算的 $C_{\\text{internal}}$ 与为此映射解析推导的内坐标梯度之间的弗罗贝尼乌斯范数（Frobenius-norm）差异。\n\n使用以下参数测试套件。对于每个测试用例，设置 $r_{12}^{\\text{target}} = r_{12}(1+\\varepsilon_1)$ 和 $r_{23}^{\\text{target}} = r_{23}(1+\\varepsilon_2)$，其中 $\\varepsilon_1$ 和 $\\varepsilon_2$ 是给定的。角度必须以弧度为单位，长度必须以埃为单位。向约束残差向量中添加一个小的确定性噪声向量 $n = [s, -s]^\\top$（其中 $s = 10^{-6}$ 埃），以探测灵敏度。\n\n测试套件（每个用例为 $(r_{12}, r_{23}, \\theta, \\varepsilon_1, \\varepsilon_2)$）：\n- 用例 A（正常路径）：$(1.5, 1.2, 1.0, 0.02, -0.015)$。\n- 用例 B（近共线）：$(1.0, 1.0, 0.001, 0.05, 0.05)$。\n- 用例 C（接近 $\\pi$）：$(1.0, 1.0, \\pi - 0.001, -0.02, 0.03)$。\n- 用例 D（键长差异）：$(2.0, 0.5, 1.5, 0.01, -0.01)$。\n\n您的程序必须为每个测试用例计算并按固定顺序输出以下七个浮点结果：\n1. $G_{\\text{cartesian}}$ 的条件数（无量纲）。\n2. $G_{\\text{internal}}$ 的条件数（无量纲）。\n3. 笛卡尔坐标中的放大因子 $\\|\\delta x_{\\text{cartesian}}\\|_2 / \\|g\\|_2$（无量纲）。\n4. 内坐标中的放大因子 $\\|\\delta x_{\\text{internal}}\\|_2 / \\|g\\|_2$（无量纲）。\n5. 笛卡尔坐标中校正后的精确残差范数 $\\|g(x+\\delta x_{\\text{cartesian}})\\|_2$（以埃为单位）。\n6. 内坐标中校正后的精确残差范数 $\\|g(x+\\delta x_{\\text{internal}})\\|_2$（以埃为单位）。\n7. 链式法则计算的内坐标约束雅可比矩阵与解析的内坐标约束雅可比矩阵之间的弗罗贝尼乌斯范数差异（无量纲）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的列表的逗号分隔列表。每个内部列表对应一个测试用例，按测试套件的顺序排列，并包含上述指定的七个值，例如，“[[v11,v12,...,v17],[v21,v22,...,v27],...]”。",
            "solution": "该问题要求对两种在平面三原子分子上强制执行完整约束的方法进行详细分析和比较：一种在笛卡尔坐标中操作，另一种在广义内坐标中操作。分析涉及推导相关的雅可比矩阵，求解线性化的约束方程，以及评估数值稳定性和准确性指标。\n\n### 步骤1：理论推导\n\n首先，我们建立连接笛卡尔坐标和内坐标表示的数学框架。\n\n**通过链式法则建立雅可比矩阵之间的关系**\n设完整约束是笛卡尔坐标的向量函数，$g(x) \\in \\mathbb{R}^2$。笛卡尔坐标 $x \\in \\mathbb{R}^6$ 本身是广义内坐标 $q \\in \\mathbb{R}^3$ 的函数，由映射 $x(q)$ 给出。通过复合函数 $g(x(q))$，约束可以用内坐标表示。\n\n多元函数的链式法则提供了内坐标中的约束雅可比矩阵 $C_{\\text{internal}} = \\partial g / \\partial q$ 与笛卡尔坐标中的约束雅可比矩阵 $C_{\\text{cartesian}} = \\partial g / \\partial x$ 之间的关系。\n$$\n\\frac{\\partial g}{\\partial q} = \\frac{\\partial g}{\\partial x} \\frac{\\partial x}{\\partial q}\n$$\n使用问题中的符号，其中 $J(q) = \\partial x / \\partial q$ 是坐标映射的雅可比矩阵，该关系为：\n$$\nC_{\\text{internal}}(q) = C_{\\text{cartesian}}(x(q)) J(q)\n$$\n这里，$C_{\\text{cartesian}}$ 是一个 $2 \\times 6$ 矩阵，$J(q)$ 是一个 $6 \\times 3$ 矩阵，它们的乘积 $C_{\\text{internal}}$ 是一个 $2 \\times 3$ 矩阵，符合预期。\n\n**坐标映射的显式雅可比矩阵 $J(q)$**\n广义坐标为 $q = [r_{12}, r_{23}, \\theta]^\\top$。到笛卡尔坐标 $x = [x_{1x}, x_{1y}, x_{2x}, x_{2y}, x_{3x}, x_{3y}]^\\top$ 的映射为：\n$$\nx(q) = [0, 0, r_{12}, 0, r_{12} + r_{23}\\cos\\theta, r_{23}\\sin\\theta]^\\top\n$$\n雅可比矩阵 $J(q) = \\partial x / \\partial q$ 是一个 $6 \\times 3$ 矩阵，其列是 $x$ 对 $q$ 的每个分量的偏导数。\n$$\n\\frac{\\partial x}{\\partial r_{12}} = [0, 0, 1, 0, 1, 0]^\\top\n$$\n$$\n\\frac{\\partial x}{\\partial r_{23}} = [0, 0, 0, 0, \\cos\\theta, \\sin\\theta]^\\top\n$$\n$$\n\\frac{\\partial x}{\\partial \\theta} = [0, 0, 0, 0, -r_{23}\\sin\\theta, r_{23}\\cos\\theta]^\\top\n$$\n将这些列组合起来得到雅可比矩阵：\n$$\nJ(q) = \\begin{bmatrix}\n0   0   0 \\\\\n0   0   0 \\\\\n1   0   0 \\\\\n0   0   0 \\\\\n1   \\cos\\theta   -r_{23}\\sin\\theta \\\\\n0   \\sin\\theta   r_{23}\\cos\\theta\n\\end{bmatrix}\n$$\n\n**显式笛卡尔约束雅可比矩阵 $C_{\\text{cartesian}}(x)$**\n约束为 $g_1(x) = \\|x_2 - x_1\\| - r_{12}^{\\text{target}}$ 和 $g_2(x) = \\|x_3 - x_2\\| - r_{23}^{\\text{target}}$，其中 $x_i = [x_{ix}, x_{iy}]^\\top$。$C_{\\text{cartesian}} = \\partial g / \\partial x$ 的行是 $g_1$ 和 $g_2$ 的梯度。范数 $\\|v\\|$ 的梯度是 $v/\\|v\\|$。\n$$\n\\nabla_x g_1 = \\left[ \\frac{-(x_2-x_1)^\\top}{\\|x_2-x_1\\|}, \\frac{(x_2-x_1)^\\top}{\\|x_2-x_1\\|}, \\mathbf{0}^\\top \\right]\n$$\n$$\n\\nabla_x g_2 = \\left[ \\mathbf{0}^\\top, \\frac{-(x_3-x_2)^\\top}{\\|x_3-x_2\\|}, \\frac{(x_3-x_2)^\\top}{\\|x_3-x_2\\|} \\right]\n$$\n在构型 $x=x(q)$ 处求值，我们有 $x_2-x_1 = [r_{12}, 0]^\\top$ 和 $x_3-x_2 = [r_{23}\\cos\\theta, r_{23}\\sin\\theta]^\\top$。它们的范数分别为 $r_{12}$ 和 $r_{23}$。\n将这些代入梯度表达式中得到：\n$$\nC_{\\text{cartesian}}(x(q)) = \\begin{bmatrix}\n-1   0   1   0   0   0 \\\\\n0   0   -\\cos\\theta   -\\sin\\theta   \\cos\\theta   \\sin\\theta\n\\end{bmatrix}\n$$\n\n**内坐标约束雅可比矩阵 $C_{\\text{internal}}(q)$**\n我们现在可以使用链式法则计算 $C_{\\text{internal}}$：\n$$\nC_{\\text{internal}} = C_{\\text{cartesian}}(x(q)) J(q) = \n\\begin{bmatrix}\n-1   0   1   0   0   0 \\\\\n0   0   -\\cos\\theta   -\\sin\\theta   \\cos\\theta   \\sin\\theta\n\\end{bmatrix}\n\\begin{bmatrix}\n0   0   0 \\\\\n0   0   0 \\\\\n1   0   0 \\\\\n0   0   0 \\\\\n1   \\cos\\theta   -r_{23}\\sin\\theta \\\\\n0   \\sin\\theta   r_{23}\\cos\\theta\n\\end{bmatrix}\n= \\begin{bmatrix}\n1   0   0 \\\\\n0   1   0\n\\end{bmatrix}\n$$\n这个通过链式法则推导出的结果，必须与解析的雅可比矩阵进行比较。\n从解析上看，直接用内坐标表示的约束是 $g_1(q) = r_{12} - r_{12}^{\\text{target}}$ 和 $g_2(q) = r_{23} - r_{23}^{\\text{target}}$。因此，解析的雅可比矩阵 $\\partial g / \\partial q$ 为：\n$$\nC_{\\text{internal}}^{\\text{analytical}} = \\frac{\\partial}{\\partial (r_{12}, r_{23}, \\theta)} \\begin{bmatrix} r_{12} - r_{12}^{\\text{target}} \\\\ r_{23} - r_{23}^{\\text{target}} \\end{bmatrix} = \\begin{bmatrix} 1   0   0 \\\\ 0   1   0 \\end{bmatrix}\n$$\n链式法则的结果与解析推导完全匹配，符合预期。数值实现将在机器精度范围内验证这一点。\n\n### 步骤2：数值程序与分析\n\n任务的核心是求解线性化约束方程 $C \\delta y = -g$ 以获得校正向量 $\\delta y$，其中 $(C, \\delta y, g)$ 可以在笛卡尔坐标或内坐标中。由于该系统是欠定的，我们寻求最小范数解，这可以通过求解拉格朗日乘子来找到。\n\n**笛卡尔坐标中的校正**\n我们求解 $C_{\\text{cartesian}} \\delta x = -g(x)$ 以获得最小范数的 $\\delta x$。该解通过拉格朗日乘子 $\\lambda \\in \\mathbb{R}^2$ 来构建：\n$$\n\\delta x = C_{\\text{cartesian}}^\\top \\lambda, \\quad \\text{where} \\quad (C_{\\text{cartesian}}C_{\\text{cartesian}}^\\top) \\lambda = -g(x)\n$$\n矩阵 $G_{\\text{cartesian}} = C_{\\text{cartesian}}C_{\\text{cartesian}}^\\top$ 是格拉姆矩阵。使用推导出的 $C_{\\text{cartesian}}$，我们有：\n$$\nG_{\\text{cartesian}} = \\begin{bmatrix} 2   -\\cos\\theta \\\\ -\\cos\\theta   2 \\end{bmatrix}\n$$\n为处理潜在的近奇异性，我们引入一个 Tikhonov 正则化参数 $\\alpha  0$（选择为 $\\alpha = 10^{-14}$）并求解 $(G_{\\text{cartesian}} + \\alpha I) \\lambda = -(g(x)+n)$，其中 $n$ 是指定的噪声项。\n\n**内坐标中的校正**\n类似地，我们求解 $C_{\\text{internal}} \\delta q = -g(x(q))$ 以获得最小范数的 $\\delta q$。解为：\n$$\n\\delta q = C_{\\text{internal}}^\\top \\mu, \\quad \\text{where} \\quad (C_{\\text{internal}}C_{\\text{internal}}^\\top) \\mu = -g(x(q))\n$$\n格拉姆矩阵是 $G_{\\text{internal}} = C_{\\text{internal}}C_{\\text{internal}}^\\top = I_{2 \\times 2}$，即 $2 \\times 2$ 的单位矩阵。该矩阵是完美条件的。我们求解正则化系统 $(G_{\\text{internal}} + \\alpha I) \\mu = -(g(x(q))+n)$。然后通过线性映射 $\\delta x = J(q) \\delta q$ 找到笛卡尔校正。\n\n**分析指标**\n数值分析侧重于以下指标：\n1.  **条件数：** $\\kappa(G) = \\|\\lambda_{\\max}\\|/\\|\\lambda_{\\min}\\|$。对于 $G_{\\text{cartesian}}$，$\\kappa = (2+|\\cos\\theta|)/(2-|\\cos\\theta|)$，当 $\\theta$ 接近 $0$ 或 $\\pi$（共线几何构型）时，条件数会恶化。对于 $G_{\\text{internal}}$，所有几何构型的条件数均为 $\\kappa=1$。\n2.  **放大因子：** $\\|\\delta x\\|_2 / \\|g+n\\|_2$。这衡量了输出校正对输入约束违反的灵敏度。\n3.  **校正后残差：** $\\|g(x+\\delta x)\\|_2$。由于约束是非线性的，线性校正步骤不会将残差完全清零。较小的值表示更准确的校正。\n4.  **雅可比矩阵验证：** $\\|C_{\\text{internal}}^{\\text{chain}} - C_{\\text{internal}}^{\\text{analytical}}\\|_F$，该值应接近浮点零。\n\n该实现将为每个测试用例计算这七个量，从而为两种坐标系下的约束强制执行提供定量比较。由于格拉姆矩阵是完美条件的，预计内坐标将显示出更优的数值稳定性和效率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics constraint problem for a series of test cases.\n    \"\"\"\n\n    def perform_analysis(r12, r23, theta, eps1, eps2):\n        \"\"\"\n        Performs the full numerical analysis for a single test case.\n        \"\"\"\n        # A small Tikhonov regularization parameter\n        alpha = 1e-14\n        \n        # Small deterministic noise vector\n        s = 1e-6\n        noise = np.array([s, -s])\n\n        # 1. Define internal coordinates and map to Cartesian\n        q = np.array([r12, r23, theta])\n        \n        c, s_theta = np.cos(theta), np.sin(theta)\n\n        # Mapping x(q)\n        x = np.array([\n            0.0,\n            0.0,\n            r12,\n            0.0,\n            r12 + r23 * c,\n            r23 * s_theta\n        ])\n\n        # 2. Define constraint function and target values\n        r12_target = r12 * (1.0 + eps1)\n        r23_target = r23 * (1.0 + eps2)\n\n        def g(x_vec):\n            # x_vec is a 6-element NumPy array\n            x1 = x_vec[0:2]\n            x2 = x_vec[2:4]\n            x3 = x_vec[4:6]\n            g1 = np.linalg.norm(x2 - x1) - r12_target\n            g2 = np.linalg.norm(x3 - x2) - r23_target\n            return np.array([g1, g2])\n\n        # Evaluate initial constraint violation vector and add noise\n        g_val = g(x)\n        g_noisy = g_val + noise\n\n        # 3. Compute Jacobians\n        # Mapping Jacobian J(q) = dx/dq\n        J = np.array([\n            [0.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0],\n            [1.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0],\n            [1.0, c, -r23 * s_theta],\n            [0.0, s_theta, r23 * c]\n        ])\n\n        # Cartesian constraint Jacobian C_cartesian(x(q))\n        C_cart = np.array([\n            [-1.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n            [0.0, 0.0, -c, -s_theta, c, s_theta]\n        ])\n\n        # Internal constraint Jacobian via chain rule\n        C_int_chain = C_cart @ J\n        \n        # Analytical internal constraint Jacobian\n        C_int_analytical = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]])\n        \n        # Metric 7: Frobenius norm difference\n        fro_diff = np.linalg.norm(C_int_chain - C_int_analytical, 'fro')\n\n        # 4. Cartesian-space correction\n        G_cart = C_cart @ C_cart.T\n        cond_G_cart = np.linalg.cond(G_cart) # Metric 1\n        \n        # Solve for Lagrange multipliers lambda\n        rhs = -g_noisy\n        lambda_p = np.linalg.solve(G_cart + alpha * np.identity(2), rhs)\n        \n        # Compute correction dx_cart\n        dx_cart = C_cart.T @ lambda_p\n        \n        # Compute amplification factor\n        g_norm = np.linalg.norm(g_noisy)\n        amp_factor_cart = np.linalg.norm(dx_cart) / g_norm # Metric 3\n        \n        # Compute post-correction residual\n        residual_norm_cart = np.linalg.norm(g(x + dx_cart)) # Metric 5\n        \n        # 5. Internal-space correction\n        G_int = C_int_chain @ C_int_chain.T\n        cond_G_int = np.linalg.cond(G_int) # Metric 2\n        \n        # Solve for Lagrange multipliers mu\n        mu_p = np.linalg.solve(G_int + alpha * np.identity(2), rhs)\n        \n        # Compute correction dq and map to dx_int\n        dq = C_int_chain.T @ mu_p\n        dx_int = J @ dq\n        \n        # Compute amplification factor\n        amp_factor_int = np.linalg.norm(dx_int) / g_norm # Metric 4\n        \n        # Compute post-correction residual\n        residual_norm_int = np.linalg.norm(g(x + dx_int)) # Metric 6\n        \n        return [\n            cond_G_cart,\n            cond_G_int,\n            amp_factor_cart,\n            amp_factor_int,\n            residual_norm_cart,\n            residual_norm_int,\n            fro_diff\n        ]\n\n    # Test suite from the problem description\n    test_cases = [\n        # (r12, r23, theta, eps1, eps2)\n        (1.5, 1.2, 1.0, 0.02, -0.015),          # Case A (happy path)\n        (1.0, 1.0, 0.001, 0.05, 0.05),         # Case B (near-collinear)\n        (1.0, 1.0, np.pi - 0.001, -0.02, 0.03), # Case C (near pi)\n        (2.0, 0.5, 1.5, 0.01, -0.01)           # Case D (bond-length disparity)\n    ]\n\n    results = []\n    for case in test_cases:\n        result_vector = perform_analysis(*case)\n        results.append(result_vector)\n\n    # Format the final output string\n    output_str_parts = []\n    for res_vec in results:\n        # Format each float to a consistent representation\n        formatted_vec = [f\"{v:.7e}\" for v in res_vec]\n        output_str_parts.append(f\"[{','.join(formatted_vec)}]\")\n    \n    print(f\"[{','.join(output_str_parts)}]\")\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "一个稳健的模拟算法不仅要能处理良好设定的问题，还必须能优雅地应对棘手的边界情况。过度约束（over-constraint）就是其中之一，此时约束条件并非线性无关，导致求解拉格朗日乘子的线性系统奇异或病态。\n\n这种冗余通常源于拓扑特征，例如分子约束图中的环。这项高级练习将为您装备诊断和处理此类情况的工具。您将实现一个结合了线性代数（奇异值分解）和图论（圈数）的算法来检测这些过度约束，并探索两种实用的解决方案：数值正则化和系统性的约束剪枝。",
            "id": "3416369",
            "problem": "考虑一个由 $N$ 个质点组成的分子动力学系统，其位置为 $q = (r_{1,x}, r_{1,y}, r_{1,z}, \\dots, r_{N,x}, r_{N,y}, r_{N,z}) \\in \\mathbb{R}^{3N}$，该系统受完整约束的作用。这些约束通过拉格朗日乘子施加，用于固定一个无向约束图中各边上的相对位移。每个约束与图的一条无向边 $(i,j)$ 和一个笛卡尔分量 $\\alpha \\in \\{x,y,z\\}$ 相关联，其形式为 $g_{(i,j),\\alpha}(q) = r_{i,\\alpha} - r_{j,\\alpha} - d_{(i,j),\\alpha} = 0$，其中 $d_{(i,j),\\alpha} \\in \\mathbb{R}$ 是为边 $(i,j)$ 指定的目标位移分量。约束雅可比矩阵 $C(q) = \\partial g / \\partial q$ 每行对应一个标量约束，共有 $3N$ 列；对于约束 $g_{(i,j),\\alpha}$，对应的行在坐标 $(i,\\alpha)$ 处的元素为 $+1$，在 $(j,\\alpha)$ 处的元素为 $-1$，其他位置为零。令 $m$ 表示标量约束的总数，即 $m = 3|E|$，其中 $|E|$ 是约束图中的边数。\n\n如果约束是独立的，并且与 $C$ 相关的拉格朗日乘子系统是可解的，则该系统是相容的。当约束在代数上相关时，通常是由于约束图中存在环，就会出现过约束情况。秩 $\\operatorname{rank} C$ 检测独立约束的数量，如果 $\\operatorname{rank} C  m$，则某些约束是冗余的。控制拉格朗日乘子的质量加权形式矩阵为 $G = C M^{-1} C^{\\top}$，其中 $M$ 是对角质量矩阵，其对角线元素为每个坐标上的粒子质量。在过约束情况下，$G$ 会变得奇异或病态。有两种解决方法：(i) Tikhonov正则化，即向 $G$ 中添加 $\\lambda I$ 以将其最小特征值提高到数值阈值之上；(ii) 约束剪枝，即沿着环移除一个最小的约束集合以恢复独立性。\n\n你的任务是推导、实现并测试一个算法，该算法能够：\n\n1. 为指定的位移约束集构建约束雅可比矩阵 $C$。\n2. 使用带容差的奇异值分解，计算 $\\operatorname{rank} C$ 的一个数值稳健的估计。\n3. 检测无向约束图中的环，并计算圈复杂度 $\\mu = |E| - |V| + c$，其中 $|V|$ 是顶点数，$c$ 是连通分量的数量。\n4. 通过检查 $\\operatorname{rank} C  m$ 且 $\\mu  0$ 是否成立，判断是否存在特别由环引起的过约束。\n5. 提出一个正则化参数 $\\lambda \\ge 0$，使得 $G + \\lambda I$ 的最小特征值至少达到一个目标阈值 $\\tau$，其中 $\\tau$ 根据 $G$ 的最大特征值和机器精度来选择。使用由粒子质量构成的 $M^{-1}$；质量矩阵 $M$ 是对角块矩阵，每个粒子 $i$ 对应一个块 $(m_i, m_i, m_i)$。\n6. 提出一种约束剪枝策略，通过丢弃在生成森林构建过程中发现的非树边，为每个独立环恰好移除一条无向边（从而每移除一条边就移除3个标量约束），然后在剪枝后的集合上重新计算 $\\operatorname{rank} C$ 以验证独立性。\n\n从以下基本原理出发：牛顿第二定律 $\\mathbf{F} = m \\mathbf{a}$；通过拉格朗日乘子施加的完整约束 $g(q) = 0$；约束雅可比矩阵的定义 $C = \\partial g / \\partial q$；以及对于 $\\lambda$ 必须可解的质量加权拉格朗日乘子系统 $G = C M^{-1} C^{\\top} \\lambda = -C M^{-1} f$。使用奇异值分解确定秩，使用圈复杂度进行环检测。除了这些基础知识外，不要假定任何快捷公式。\n\n实现该算法并在以下测试套件上进行评估。每个测试用例提供了 $N$、位置 $r_i$（用于通过 $d_{(i,j)} = r_i - r_j$ 构建相容的 $d_{(i,j)}$ 值）、一个无向边列表 $E$ 和一个质量数组 $(m_1, \\dots, m_N)$。\n\n- 测试用例 1 (正常路径，无环)：\n  - $N = 4$\n  - 位置: $r_0 = (0,0,0)$, $r_1 = (1,0,0)$, $r_2 = (2,0,0)$, $r_3 = (3,0,0)$\n  - 边: $(0,1), (1,2), (2,3)$\n  - 质量: $(1.0, 1.0, 1.0, 1.0)$\n\n- 测试用例 2 (单环，方形环)：\n  - $N = 4$\n  - 位置: $r_0 = (0,0,0)$, $r_1 = (1,0,0)$, $r_2 = (1,1,0)$, $r_3 = (0,1,0)$\n  - 边: $(0,1), (1,2), (2,3), (3,0)$\n  - 质量: $(1.0, 2.0, 1.5, 1.0)$\n\n- 测试用例 3 (双环，8字形)：\n  - $N = 5$\n  - 位置: $r_0 = (0,0,0)$, $r_1 = (1,0,0)$, $r_2 = (1,1,0)$, $r_3 = (2,1,0)$, $r_4 = (2,2,0)$\n  - 边: $(0,1), (1,2), (2,0), (2,3), (3,4), (4,2)$\n  - 质量: $(1.0, 1.2, 1.0, 0.8, 1.5)$\n\n- 测试用例 4 (边界情况，断开的环)：\n  - $N = 4$\n  - 位置: $r_0 = (0,0,0)$, $r_1 = (1,0,0)$, $r_2 = (1,1,0)$, $r_3 = (0,1,0)$\n  - 边: $(0,1), (1,2), (2,3)$\n  - 质量: $(1.0, 3.0, 1.0, 2.0)$\n\n对于每个测试用例，你的程序必须计算以下量：\n\n- $\\operatorname{rank} C$ (整数),\n- $m$ (标量约束总数，整数),\n- $\\mu$ (圈复杂度，整数),\n- 剪枝移除的标量约束数量 (整数),\n- 剪枝后的 $\\operatorname{rank} C$ (整数),\n- 正则化参数 $\\lambda$ (浮点数),\n- 一个布尔值，指示过约束是否由环引起 (如果 $\\operatorname{rank} C  m$ 且 $\\mu  0$ 则为 true，否则为 false)。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也应是按上述顺序排列的列表。例如，输出格式必须为 $[\\,[r_1, m_1, \\mu_1, \\Delta m_1, r^{\\text{pruned}}_1, \\lambda_1, b_1], \\dots, [r_4, m_4, \\mu_4, \\Delta m_4, r^{\\text{pruned}}_4, \\lambda_4, b_4]\\,]$。不需要物理单位，也不涉及角度。所有布尔值都应以其编程语言的规范形式打印（例如，true 或 false）。",
            "solution": "该问题要求对一个具有完整约束的分子系统进行分析，重点是检测和解决由约束图中的环引起的过约束。该解决方案涉及一个多步骤算法，它整合了线性代数、图论和数值分析的概念，并基于经典力学原理。\n\n其基本原理是在一个由 $N$ 个粒子组成的系统（广义坐标为 $q \\in \\mathbb{R}^{3N}$）上施加完整约束 $g(q) = 0$。这些约束通过拉格朗日乘子被纳入运动方程。拉格朗日乘子 $\\lambda$ 的方程组涉及约束雅可比矩阵 $C(q) = \\partial g / \\partial q$ 和质量矩阵 $M$。具体来说，矩阵 $G = C M^{-1} C^{\\top}$ 必须被求逆。如果约束不是线性无关的，这个矩阵就会变成奇异矩阵，从而导致一个过约束系统。\n\n我们的算法为每个测试用例系统地处理问题陈述中指定的任务。\n\n**1. 约束图和雅可比矩阵的构建**\n\n约束定义在一个图上，其中顶点代表粒子，边 $(i,j)$ 代表一个固定的相对位移。每条边 $(i,j)$ 对应三个标量约束，每个笛卡尔分量 $\\alpha \\in \\{x,y,z\\}$ 一个：\n$$g_{(i,j),\\alpha}(q) = r_{i,\\alpha} - r_{j,\\alpha} - d_{(i,j),\\alpha} = 0$$\n其中 $r_{i,\\alpha}$ 是粒子 $i$ 的 $\\alpha$ 坐标，$d_{(i,j),\\alpha}$ 是一个恒定的目标位移。标量约束的总数是 $m = 3|E|$，其中 $|E|$ 是约束图中的边数。\n\n约束雅可比矩阵 $C$ 是一个 $m \\times 3N$ 的矩阵。$C$ 的每一行对应一个标量约束函数的梯度。对于约束 $g_{(i,j),\\alpha}$，对应的行向量在坐标 $r_{i,\\alpha}$ 的列索引处为 $+1$，在坐标 $r_{j,\\alpha}$ 的列索引处为 $-1$。所有其他元素均为零。位置 $r_i$ 和目标位移 $d_{(i,j),\\alpha}$ 的具体值不影响雅可比矩阵 $C$。\n\n**2. 通过奇异值分解 (SVD) 进行秩分析**\n\n线性无关约束的数量由雅可比矩阵的秩 $\\operatorname{rank} C$ 给出。一种计算秩的数值稳健方法是通过SVD。$C$ 的奇异值中大于一个小编差的奇异值数量决定了其秩。如果 $\\operatorname{rank} C  m$，则约束集是线性相关的，表明存在冗余和过约束系统。\n\n**3. 图的环检测与圈复杂度**\n\n这种约束系统中的冗余与底层约束图中的环直接相关。任何粒子闭环周围的相对位移矢量之和必须为零，例如 $(r_i-r_j) + (r_j-r_k) + (r_k-r_i) = 0$。这个几何恒等式意味着每个笛卡尔分量的相应约束函数之间存在线性相关性。\n\n为了量化环的数量，我们计算约束图 G=($V$, $E$) 的圈复杂度：\n$$\\mu = |E| - |V| + c$$\n其中 $|V|=N$ 是顶点数（粒子数），$|E|$ 是边数（位移约束数），$c$ 是图中连通分量的数量。$\\mu  0$ 的值表示存在一个或多个独立环。我们通过执行图遍历（例如广度优先搜索, BFS）来确定 $c$，以计算内部连通的不同子图的数量。\n\n**4. 识别由环引起的过约束**\n\n如果同时满足两个条件：系统在数学上是过约束的 ($\\operatorname{rank} C  m$) 并且约束图包含环 ($\\mu  0$)，那么就特别地将过约束识别为由环引起的。\n\n**5. Tikhonov 正则化**\n\n处理奇异矩阵 $G = C M^{-1} C^{\\top}$ 的一种方法是 Tikhonov 正则化。我们寻找一个参数 $\\lambda \\ge 0$ 来构成一个正则化矩阵 $G' = G + \\lambda I$，该矩阵非奇异且良态。$G'$ 的特征值是 $\\lambda'_k = \\lambda_k + \\lambda$，其中 $\\lambda_k$ 是 $G$ 的特征值。由于 $G$ 是对称半正定矩阵，其特征值是实数且非负。如果 $G$ 是奇异的，其最小特征值 $\\lambda_{\\text{min}}$ 为 $0$。\n\n我们的目标是确保 $G'$ 的最小特征值 $\\lambda_{\\text{min}} + \\lambda$ 高于一个数值稳定性阈值 $\\tau$。该阈值的一个合理选择是 $\\tau = \\lambda_{\\text{max}} \\cdot \\epsilon_{\\text{machine}}$，其中 $\\lambda_{\\text{max}}$ 是 $G$ 的最大特征值，$\\epsilon_{\\text{machine}}$ 是机器精度。那么所需的正则化参数是：\n$$\\lambda = \\max(0, \\tau - \\lambda_{\\text{min}})$$\n质量矩阵 $M$ 是一个 $3N \\times 3N$ 的对角矩阵，其中与粒子 $i$ 对应的对角元素都等于其质量 $m_i$。其逆矩阵 $M^{-1}$ 也是对角的，元素为 $1/m_i$。\n\n**6. 约束剪枝**\n\n消除冗余的一个直接方法是移除约束，直到它们线性无关。对于基于环的冗余，这对应于使约束图变为无环图。这可以通过找到图的生成森林来实现。生成森林包含不产生环路可能的最大边数。原始图中不属于生成森林的边就是那些构成环的边。\n\n我们使用图遍历（例如 BFS）构建生成森林，在发现未访问顶点时将边添加到森林中。一个具有 $N$ 个顶点和 $c$ 个连通分量的图的生成森林中的边数是 $N-c$。需要移除的边数是 $|E| - (N-c) = \\mu$。每移除一条边，我们都移除其关联的三个标量约束。移除的标量约束总数为 $3\\mu$。然后我们仅使用生成森林中的边来构建一个新的、剪枝后的雅可比矩阵 $C_{\\text{pruned}}$，并验证其秩等于其行数，从而确认所有冗余已被移除。\n\n通过实施这些步骤，我们可以按要求完全刻画每个测试用例。",
            "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef process_case(N, edges, masses):\n    \"\"\"\n    Processes a single test case according to the problem description.\n    \"\"\"\n    \n    # Task 3 (Part 1): Graph Analysis to find connected components and spanning forest\n    adj = {i: [] for i in range(N)}\n    unique_edges = set()\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        unique_edges.add(tuple(sorted((u, v))))\n    \n    num_edges = len(unique_edges)\n    visited = [False] * N\n    num_components = 0\n    spanning_forest_edges = []\n    \n    for i in range(N):\n        if not visited[i]:\n            num_components += 1\n            q = deque([i])\n            visited[i] = True\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n                        spanning_forest_edges.append(tuple(sorted((u, v))))\n\n    # Task 3 (Part 2): Compute cyclomatic number\n    mu = num_edges - N + num_components\n\n    # Helper function to construct the Jacobian\n    def construct_jacobian(n_particles, edge_list):\n        n_constraints = 3 * len(edge_list)\n        if n_constraints == 0:\n            return np.zeros((0, 3 * n_particles)), 0\n        \n        C = np.zeros((n_constraints, 3 * n_particles))\n        constraint_idx = 0\n        for u, v in edge_list:\n            for alpha in range(3):\n                col_i = 3 * u + alpha\n                col_j = 3 * v + alpha\n                C[constraint_idx, col_i] = 1\n                C[constraint_idx, col_j] = -1\n                constraint_idx += 1\n        return C, n_constraints\n\n    # Task 1: Construct the full constraint Jacobian\n    C, m = construct_jacobian(N, unique_edges)\n\n    # Task 2: Compute rank of the full Jacobian\n    if m > 0:\n        rank_C = np.linalg.matrix_rank(C)\n    else:\n        rank_C = 0\n\n    # Task 4: Detect overconstraint due to cycles\n    is_overconstrained_by_cycles = bool((rank_C  m) and (mu > 0))\n\n    # Task 6: Propose and evaluate pruning strategy\n    num_removed_scalar_constraints = 3 * mu\n    C_pruned, m_pruned = construct_jacobian(N, spanning_forest_edges)\n    if m_pruned > 0:\n        rank_C_pruned = np.linalg.matrix_rank(C_pruned)\n    else:\n        rank_C_pruned = 0\n\n    # Task 5: Propose regularization parameter lambda\n    if m == 0:\n        lambda_reg = 0.0\n    else:\n        masses_array = np.array(masses, dtype=float)\n        inv_masses_rep = np.repeat(1.0 / masses_array, 3)\n        \n        # G = C M^-1 C^T, computed efficiently\n        # C_scaled_by_mass = C * inv_masses_rep (broadcasting)\n        # G = C_scaled_by_mass @ C.T\n        temp = C * inv_masses_rep\n        G = temp @ C.T\n        \n        eigvals_G = np.linalg.eigvalsh(G)\n        lambda_min = eigvals_G[0]\n        lambda_max = eigvals_G[-1]\n        \n        # Set threshold tau\n        tau = lambda_max * np.finfo(float).eps\n        \n        # Compute lambda\n        lambda_reg = max(0.0, tau - lambda_min)\n\n    return [\n        int(rank_C),\n        int(m),\n        int(mu),\n        int(num_removed_scalar_constraints),\n        int(rank_C_pruned),\n        float(lambda_reg),\n        is_overconstrained_by_cycles\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 4,\n            \"positions\": {0:(0,0,0), 1:(1,0,0), 2:(2,0,0), 3:(3,0,0)},\n            \"edges\": [(0,1), (1,2), (2,3)],\n            \"masses\": [1.0, 1.0, 1.0, 1.0]\n        },\n        {\n            \"N\": 4,\n            \"positions\": {0:(0,0,0), 1:(1,0,0), 2:(1,1,0), 3:(0,1,0)},\n            \"edges\": [(0,1), (1,2), (2,3), (3,0)],\n            \"masses\": [1.0, 2.0, 1.5, 1.0]\n        },\n        {\n            \"N\": 5,\n            \"positions\": {0:(0,0,0), 1:(1,0,0), 2:(1,1,0), 3:(2,1,0), 4:(2,2,0)},\n            \"edges\": [(0,1), (1,2), (2,0), (2,3), (3,4), (4,2)],\n            \"masses\": [1.0, 1.2, 1.0, 0.8, 1.5]\n        },\n        {\n            \"N\": 4,\n            \"positions\": {0:(0,0,0), 1:(1,0,0), 2:(1,1,0), 3:(0,1,0)},\n            \"edges\": [(0,1), (1,2), (2,3)],\n            \"masses\": [1.0, 3.0, 1.0, 2.0]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = process_case(case['N'], case['edges'], case['masses'])\n        all_results.append(result)\n\n    # Format the output as specified\n    formatted_results = []\n    for res in all_results:\n        res[-1] = str(res[-1]).lower()  # Convert boolean to \"true\"/\"false\"\n        str_res = [str(x) for x in res]\n        formatted_results.append(f\"[{','.join(str_res)}]\")\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}