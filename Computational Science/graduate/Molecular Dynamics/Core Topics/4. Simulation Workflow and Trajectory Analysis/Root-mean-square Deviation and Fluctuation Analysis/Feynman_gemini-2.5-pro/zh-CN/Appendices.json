{
    "hands_on_practices": [
        {
            "introduction": "在计算两种分子构象之间的均方根偏差（RMSD）之前，我们必须首先将它们以最佳方式对齐。这个练习将引导你从第一性原理出发，推导加权最小二乘叠合方法，该方法通过最小化原子坐标的加权平方偏差来找到最佳的旋转和平移。理解这个过程是掌握 RMSD 分析核心算法的关键。",
            "id": "3443709",
            "problem": "考虑用于分子动力学中均方根偏差 (RMSD) 分析的，处于三维空间中的一个大分子的两种构象。这些构象由原子坐标集 $\\{x_{i}\\}_{i=1}^{N}$ 和 $\\{y_{i}\\}_{i=1}^{N}$ 表示，其中 $x_{i}, y_{i} \\in \\mathbb{R}^{3}$，以及严格为正的原子质量 $\\{m_{i}\\}_{i=1}^{N}$。最佳叠合定义为一种刚体运动，包括旋转 $R \\in \\mathrm{SO}(3)$（即三维特殊正交群，满足 $R^{\\top}R = I$ 和 $\\det(R) = 1$）和平移 $t \\in \\mathbb{R}^{3}$，该运动使得质量加权的平方偏差和最小化\n$$\nJ(R,t) = \\sum_{i=1}^{N} m_{i} \\left\\| R x_{i} + t - y_{i} \\right\\|^{2}.\n$$\n从第一性原理（即质量加权最小二乘目标的定义和对 $R$ 的约束）出发，通过最小化 $J(R,t)$ 来推导质量加权的最佳叠合。首先对平移 $t$ 进行最小化，然后用中心化坐标重新表达目标函数，以确定用于计算最佳旋转 $R$ 的量。具体来说，需要获得以下各项的显式解析表达式：\n- x-坐标的质量加权质心，\n- y-坐标的质量加权质心，\n- 用于旋转计算的质量加权协方差矩阵（例如，通过奇异值分解 (SVD)），\n- 以及用 $R$ 和质心表示的最佳平移 $t^{\\star}$。\n\n你的最终答案必须是一个单一的闭式解析表达式，集合这四个量。不需要进行数值计算。如果需要任何中间标量归一化，请用符号表示。最终答案中不要包含任何单位。",
            "solution": "用户提供了一个科学严谨、问题明确、客观且自洽的问题陈述。这是计算结构生物学和分子动力学领域中的一个标准推导，具体涉及两个分子结构的最佳叠合。该问题基于多元微积分和线性代数的既定数学原理。所有必要的数据和定义都已提供，没有矛盾或歧义之处。因此，该问题被认为是有效的，并将提供解答。\n\n目标是找到最佳旋转 $R \\in \\mathrm{SO}(3)$ 和平移 $t \\in \\mathbb{R}^{3}$，以最小化两组原子坐标 $\\{x_{i}\\}_{i=1}^{N}$ 和 $\\{y_{i}\\}_{i=1}^{N}$ 之间的质量加权平方偏差和。目标函数由下式给出：\n$$\nJ(R,t) = \\sum_{i=1}^{N} m_{i} \\left\\| R x_{i} + t - y_{i} \\right\\|^{2}\n$$\n其中 $\\{m_{i}\\}_{i=1}^{N}$ 是严格为正的原子质量。\n\n最小化可以分两步进行：首先是关于平移向量 $t$ 的最小化，然后是关于旋转矩阵 $R$ 的最小化。\n\n**第1步：关于平移 $t$ 的最小化**\n\n对于一个固定的旋转 $R$，最佳平移 $t^{\\star}$ 可通过将 $J(R,t)$ 关于 $t$ 的梯度设为零向量来求得。梯度 $\\nabla_{t} J$ 的计算如下：\n$$\n\\nabla_{t} J(R,t) = \\nabla_{t} \\sum_{i=1}^{N} m_{i} (R x_{i} + t - y_{i})^{\\top}(R x_{i} + t - y_{i})\n$$\n使用恒等式 $\\nabla_{v} (u^{\\top}u) = 2 u^{\\top} \\nabla_{v}u$，并注意到 $\\nabla_{t}(R x_{i} + t - y_{i}) = I$（单位矩阵），我们得到：\n$$\n\\nabla_{t} J(R,t) = \\sum_{i=1}^{N} m_{i} \\cdot 2(R x_{i} + t - y_{i})^{\\top}\n$$\n将梯度（转置为列向量）设为零：\n$$\n\\sum_{i=1}^{N} 2 m_{i} (R x_{i} + t^{\\star} - y_{i}) = 0\n$$\n由于 $m_i > 0$，我们可以除以 $2$ 并重新排列求和项：\n$$\n\\sum_{i=1}^{N} m_{i} R x_{i} + \\sum_{i=1}^{N} m_{i} t^{\\star} - \\sum_{i=1}^{N} m_{i} y_{i} = 0\n$$\n$$\nR \\left(\\sum_{i=1}^{N} m_{i} x_{i}\\right) + t^{\\star} \\left(\\sum_{i=1}^{N} m_{i}\\right) - \\left(\\sum_{i=1}^{N} m_{i} y_{i}\\right) = 0\n$$\n为简化此表达式，我们定义总质量 $M$ 和两组坐标集的质量加权质心。设总质量为 $M = \\sum_{k=1}^{N} m_{k}$。质量加权质心为：\n- $\\{x_{i}\\}$ 坐标的质心：$x_{c} = \\frac{1}{M} \\sum_{i=1}^{N} m_{i} x_{i}$。\n- $\\{y_{i}\\}$ 坐标的质心：$y_{c} = \\frac{1}{M} \\sum_{i=1}^{N} m_{i} y_{i}$。\n\n将这些定义代入 $t^{\\star}$ 的方程中：\n$$\nR (M x_{c}) + M t^{\\star} - M y_{c} = 0\n$$\n由于 $M > 0$，我们可以除以 $M$ 得到：\n$$\nR x_{c} + t^{\\star} - y_{c} = 0\n$$\n这就得出了用旋转 $R$ 和质心表示的最佳平移 $t^{\\star}$ 的表达式：\n$$\nt^{\\star} = y_{c} - R x_{c}\n$$\n这是问题要求的第四个量。前两个量是质心 $x_c$ 和 $y_c$ 的显式表达式。\n\n**第2步：重新表达目标函数并确定协方差矩阵**\n\n现在，我们将最佳平移 $t^{\\star}$ 代回目标函数 $J(R,t)$，得到一个仅依赖于旋转 $R$ 的函数：\n$$\nJ(R) = J(R, t^{\\star}) = \\sum_{i=1}^{N} m_{i} \\left\\| R x_{i} + (y_{c} - R x_{c}) - y_{i} \\right\\|^{2}\n$$\n重新排列范数内的项：\n$$\nJ(R) = \\sum_{i=1}^{N} m_{i} \\left\\| (R x_{i} - R x_{c}) - (y_{i} - y_{c}) \\right\\|^{2} = \\sum_{i=1}^{N} m_{i} \\left\\| R(x_{i} - x_{c}) - (y_{i} - y_{c}) \\right\\|^{2}\n$$\n我们引入中心化坐标：\n- $x'_{i} = x_{i} - x_{c}$\n- $y'_{i} = y_{i} - y_{c}$\n目标函数变为一个寻找能够最佳对齐两组中心化坐标集的旋转的问题：\n$$\nJ(R) = \\sum_{i=1}^{N} m_{i} \\left\\| R x'_{i} - y'_{i} \\right\\|^{2}\n$$\n展开平方范数：\n$$\n\\left\\| R x'_{i} - y'_{i} \\right\\|^{2} = (R x'_{i} - y'_{i})^{\\top}(R x'_{i} - y'_{i}) = (R x'_{i})^{\\top}(R x'_{i}) - 2(R x'_{i})^{\\top}y'_{i} + (y'_{i})^{\\top}y'_{i}\n$$\n由于 $R$ 是一个正交矩阵（$R^{\\top}R = I$），我们有 $(R x'_{i})^{\\top}(R x'_{i}) = (x'_{i})^{\\top}R^{\\top}R x'_{i} = (x'_{i})^{\\top}I x'_{i} = \\|x'_{i}\\|^{2}$。\n展开后的项为 $\\|x'_{i}\\|^{2} - 2(x'_{i})^{\\top}R^{\\top}y'_{i} + \\|y'_{i}\\|^{2}$。\n将此代回 $J(R)$ 的表达式中：\n$$\nJ(R) = \\sum_{i=1}^{N} m_{i} \\left( \\|x'_{i}\\|^{2} + \\|y'_{i}\\|^{2} \\right) - 2 \\sum_{i=1}^{N} m_{i} (x'_{i})^{\\top}R^{\\top}y'_{i}\n$$\n为了最小化 $J(R)$，我们必须最大化依赖于 $R$ 的项。求和的第一部分，$\\sum_{i=1}^{N} m_{i} ( \\|x'_{i}\\|^{2} + \\|y'_{i}\\|^{2} )$，相对于 $R$ 是一个常数。因此，最小化 $J(R)$ 等价于最大化量 $S(R)$：\n$$\nS(R) = \\sum_{i=1}^{N} m_{i} (x'_{i})^{\\top}R^{\\top}y'_{i}\n$$\n我们可以使用迹算子来表示这个和。对于任意标量 $a$，有 $a = \\mathrm{Tr}(a)$。\n$$\nS(R) = \\sum_{i=1}^{N} m_{i} \\mathrm{Tr}\\left( (x'_{i})^{\\top}R^{\\top}y'_{i} \\right)\n$$\n利用迹的循环性质，$\\mathrm{Tr}(ABC) = \\mathrm{Tr}(BCA)$：\n$$\nS(R) = \\sum_{i=1}^{N} m_{i} \\mathrm{Tr}\\left( R^{\\top}y'_{i}(x'_{i})^{\\top} \\right)\n$$\n根据迹算子的线性性质：\n$$\nS(R) = \\mathrm{Tr}\\left( R^{\\top} \\left( \\sum_{i=1}^{N} m_{i} y'_{i}(x'_{i})^{\\top} \\right) \\right)\n$$\n这个表达式确定了控制问题旋转部分的矩阵。这就是质量加权协方差矩阵 $C$：\n$$\nC = \\sum_{i=1}^{N} m_{i} y'_{i}(x'_{i})^{\\top} = \\sum_{i=1}^{N} m_{i} (y_{i} - y_{c})(x_{i} - x_{c})^{\\top}\n$$\n因此，寻找最佳旋转 $R$ 的问题就简化为最大化 $\\mathrm{Tr}(R^{\\top}C)$。这通常通过计算矩阵 $C$ 的奇异值分解 (SVD) 来解决。这个矩阵 $C$ 是问题要求的第三个量。\n\n因此，所需的四个量是：\n1.  x-坐标的质量加权质心：$x_{c} = \\frac{\\sum_{i=1}^{N} m_{i} x_{i}}{\\sum_{k=1}^{N} m_{k}}$。\n2.  y-坐标的质量加权质心：$y_{c} = \\frac{\\sum_{i=1}^{N} m_{i} y_{i}}{\\sum_{k=1}^{N} m_{k}}$。\n3.  质量加权协方差矩阵：$C = \\sum_{i=1}^{N} m_{i} (y_{i} - y_{c})(x_{i} - x_{c})^{\\top}$。\n4.  最佳平移：$t^{\\star} = y_{c} - R x_{c}$。\n\n这些量在最终答案中被汇总成一个单一的解析表达式。",
            "answer": "$$\n\\boxed{\n\\pmatrix{\n\\frac{\\sum_{i=1}^{N} m_{i} x_{i}}{\\sum_{k=1}^{N} m_{k}}  \\\\\n\\frac{\\sum_{i=1}^{N} m_{i} y_{i}}{\\sum_{k=1}^{N} m_{k}}  \\\\\n\\sum_{i=1}^{N} m_{i} \\left(y_{i} - \\frac{\\sum_{j=1}^{N} m_{j} y_{j}}{\\sum_{k=1}^{N} m_{k}}\\right)\\left(x_{i} - \\frac{\\sum_{l=1}^{N} m_{l} x_{l}}{\\sum_{k=1}^{N} m_{k}}\\right)^{\\top}  \\\\\n\\frac{\\sum_{i=1}^{N} m_{i} y_{i}}{\\sum_{k=1}^{N} m_{k}} - R\\left(\\frac{\\sum_{i=1}^{N} m_{i} x_{i}}{\\sum_{k=1}^{N} m_{k}}\\right)\n}\n}\n$$"
        },
        {
            "introduction": "分子动力学模拟通常在周期性边界条件（PBC）下进行，这可能导致原子“跳跃”穿过盒子边界，从而产生伪影。直接使用这些包裹的坐标计算 RMSD 或 RMSF 会得到物理上无意义的巨大数值。这个编程练习旨在量化 PBC 对计算的影响，并让你亲手实现必要的最小镜像约定（minimal-image convention）来校正轨迹，从而获得准确的结构偏差和涨落信息。",
            "id": "3443654",
            "problem": "您必须编写一个完整且可运行的程序，对于正交周期性盒子中的原子轨迹，通过比较朴素的包裹坐标与最小镜像校正位移，来量化周期性边界条件 (PBC) 对均方根偏差 (RMSD) 和均方根涨落 (RMSF) 的影响。该程序必须是自包含的，并能为指定的测试套件以精确的输出格式生成所要求的数值结果。\n\n使用的基本原理和定义：\n- 欧几里得几何：对于任何向量 $\\mathbf{a}\\in\\mathbb{R}^3$，其范数的平方为 $\\|\\mathbf{a}\\|^2 = a_x^2 + a_y^2 + a_z^2$，且 $\\|\\mathbf{a}\\| = \\sqrt{\\|\\mathbf{a}\\|^2}$。\n- 时间平均：对于时间序列 $\\{x(t)\\}_{t=1}^T$，其平均值为 $\\overline{x} = \\frac{1}{T}\\sum_{t=1}^T x(t)$。\n- 正交盒子中的周期性边界条件 (PBC)：盒子长度由 $\\mathbf{L} = (L_x, L_y, L_z)$ 给出，在每个笛卡尔分量 $\\alpha\\in\\{x,y,z\\}$ 上，位置被包裹在区间 $[0,L_\\alpha)$ 内。\n- 最小镜像校正：对于每个原子 $i$ 在时间 $t$，逐分量地选择 $\\mathbf{n}_{i}(t)\\in \\mathbb{Z}^3$，使得校正后的位移向量 $\\Delta\\mathbf{r}_i^{MIC}(t) = \\Delta\\mathbf{r}_i^{wrap}(t) + \\mathbf{n}_i(t)\\circ \\mathbf{L}$ 具有最小的欧几里得范数，其中 $\\Delta\\mathbf{r}_i^{wrap}(t) = \\mathbf{r}_i(t) - \\mathbf{r}_i^{ref}$，$\\circ$ 表示逐元素乘法。必须在每个分量上独立地进行选择，方法是选择最接近 $\\Delta r_{i,\\alpha}(t)/L_\\alpha$ 的整数；当恰好在盒子一半处出现相等情况时（$\\Delta r_{i,\\alpha}(t)/L_\\alpha = \\pm \\tfrac{1}{2}$），必须解析为最近的偶数，以确保确定性行为。\n- 均方根偏差 (RMSD)：对于 $N$ 个原子，在时间 $t$ 采用一种位移约定 $\\Delta\\mathbf{r}_i(t)$，定义 $R(t) = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\|\\Delta\\mathbf{r}_i(t)\\|^2}$，并报告其时间平均值 $\\overline{R} = \\frac{1}{T}\\sum_{t=1}^T R(t)$。\n- 均方根涨落 (RMSF)：对于每个原子 $i$，通过将位移加到参考坐标上重构坐标 $\\mathbf{u}_i(t) = \\mathbf{r}_i^{ref} + \\Delta\\mathbf{r}_i(t)$，计算时间平均值 $\\overline{\\mathbf{u}}_i = \\frac{1}{T}\\sum_{t=1}^T \\mathbf{u}_i(t)$，并定义 $\\mathrm{RMSF}_i = \\sqrt{\\frac{1}{T}\\sum_{t=1}^T \\|\\mathbf{u}_i(t) - \\overline{\\mathbf{u}}_i\\|^2}$。报告所有原子的平均值 $\\overline{\\mathrm{F}} = \\frac{1}{N}\\sum_{i=1}^N \\mathrm{RMSF}_i$。\n- 必须比较两种位移约定：\n  1. 朴素包裹位移：$\\Delta\\mathbf{r}_i^{wrap}(t) = \\mathbf{r}_i(t) - \\mathbf{r}_i^{ref}$。\n  2. 最小镜像校正位移：如上构建的 $\\Delta\\mathbf{r}_i^{MIC}(t)$。\n对于每个测试用例，计算并报告四个浮点数：$\\overline{R}^{wrap}$、$\\overline{R}^{MIC}$、$\\overline{\\mathrm{F}}^{wrap}$、$\\overline{\\mathrm{F}}^{MIC}$。\n\n所有位置和盒子长度的单位均为纳米，所有输出也必须以纳米为单位报告，并四舍五入到 $6$ 位小数。\n\n测试套件：\n- 用例 $1$（单个原子穿越边界）：\n  - 盒子：$\\mathbf{L} = (\\,1.0,\\,1.0,\\,1.0\\,)$，单位 $\\mathrm{nm}$。\n  - 原子数：$N=1$。\n  - 帧数：$T=4$。\n  - 参考位置：$\\mathbf{r}_1^{ref} = (\\,0.90,\\,0.00,\\,0.00\\,)$，单位 $\\mathrm{nm}$。\n  - 轨迹帧（包裹坐标，单位 $\\mathrm{nm}$）：\n    $t=1$: $\\mathbf{r}_1(1) = (\\,0.90,\\,0.00,\\,0.00\\,)$，\n    $t=2$: $\\mathbf{r}_1(2) = (\\,0.95,\\,0.00,\\,0.00\\,)$，\n    $t=3$: $\\mathbf{r}_1(3) = (\\,0.98,\\,0.00,\\,0.00\\,)$，\n    $t=4$: $\\mathbf{r}_1(4) = (\\,0.02,\\,0.00,\\,0.00\\,)$。\n- 用例 $2$（三个原子在不同维度上穿越）：\n  - 盒子：$\\mathbf{L} = (\\,2.0,\\,1.0,\\,1.5\\,)$，单位 $\\mathrm{nm}$。\n  - 原子数：$N=3$。\n  - 帧数：$T=3$。\n  - 参考位置（单位 $\\mathrm{nm}$）：\n    $\\mathbf{r}_1^{ref} = (\\,1.80,\\,0.20,\\,0.75\\,)$，\n    $\\mathbf{r}_2^{ref} = (\\,0.10,\\,0.90,\\,0.10\\,)$，\n    $\\mathbf{r}_3^{ref} = (\\,1.99,\\,0.05,\\,1.49\\,)$。\n  - 轨迹帧（包裹坐标，单位 $\\mathrm{nm}$）：\n    $t=1$:\n      $\\mathbf{r}_1(1) = (\\,1.85,\\,0.22,\\,0.78\\,)$，\n      $\\mathbf{r}_2(1) = (\\,0.15,\\,0.92,\\,0.14\\,)$，\n      $\\mathbf{r}_3(1) = (\\,1.98,\\,0.06,\\,1.48\\,)$。\n    $t=2$:\n      $\\mathbf{r}_1(2) = (\\,0.05,\\,0.22,\\,0.78\\,)$，\n      $\\mathbf{r}_2(2) = (\\,0.15,\\,0.02,\\,0.14\\,)$，\n      $\\mathbf{r}_3(2) = (\\,1.98,\\,0.06,\\,0.01\\,)$。\n    $t=3$:\n      $\\mathbf{r}_1(3) = (\\,0.10,\\,0.24,\\,0.77\\,)$，\n      $\\mathbf{r}_2(3) = (\\,0.18,\\,0.05,\\,0.08\\,)$，\n      $\\mathbf{r}_3(3) = (\\,0.02,\\,0.04,\\,0.02\\,)$。\n- 用例 $3$（分量上恰好处于半盒子位移的边界情况）：\n  - 盒子：$\\mathbf{L} = (\\,1.0,\\,1.0,\\,1.0\\,)$，单位 $\\mathrm{nm}$。\n  - 原子数：$N=2$。\n  - 帧数：$T=2$。\n  - 参考位置（单位 $\\mathrm{nm}$）：\n    $\\mathbf{r}_1^{ref} = (\\,0.25,\\,0.25,\\,0.25\\,)$，\n    $\\mathbf{r}_2^{ref} = (\\,0.75,\\,0.75,\\,0.75\\,)$。\n  - 轨迹帧（包裹坐标，单位 $\\mathrm{nm}$）：\n    $t=1$:\n      $\\mathbf{r}_1(1) = (\\,0.75,\\,0.25,\\,0.25\\,)$，\n      $\\mathbf{r}_2(1) = (\\,0.25,\\,0.75,\\,0.75\\,)$。\n    $t=2$:\n      $\\mathbf{r}_1(2) = (\\,0.75,\\,0.75,\\,0.25\\,)$，\n      $\\mathbf{r}_2(2) = (\\,0.25,\\,0.25,\\,0.75\\,)$。\n\n程序要求：\n- 实现函数以完全按照上述描述计算 $\\overline{R}^{wrap}$、$\\overline{R}^{MIC}$、$\\overline{\\mathrm{F}}^{wrap}$ 和 $\\overline{\\mathrm{F}}^{MIC}$，在每个笛卡尔分量上独立地使用指定的相等情况处理规则进行最小镜像选择（最近整数，相等情况解析为偶数）。\n- 单位：输入单位为 $\\mathrm{nm}$，输出单位也必须为 $\\mathrm{nm}$。\n- 输出四舍五入：将每个报告的浮点数四舍五入到 $6$ 位小数。\n- 最终输出格式：一个单行，包含所有测试用例的结果列表，其中每个测试用例贡献一个包含四个浮点数的列表，顺序为 `[\\,\\overline{R}^{wrap},\\,\\overline{R}^{MIC},\\,\\overline{\\mathrm{F}}^{wrap},\\,\\overline{\\mathrm{F}}^{MIC}\\,]`。总输出必须是这些列表的单个列表，并精确地以 Python 列表字面量的形式打印，例如 `[\\,[a_1,b_1,c_1,d_1],\\,[a_2,b_2,c_2,d_2],\\,[a_3,b_3,c_3,d_3]\\,]`。",
            "solution": "所提出的问题是分子动力学模拟分析领域一个明确定义的计算任务。它要求在两种处理周期性边界条件 (PBC) 系统中粒子位移的不同约定下，计算两个标准度量：均方根偏差 (RMSD) 和均方根涨落 (RMSF)。该问题具有科学依据、内部一致，并为获得唯一、可验证的解决方案提供了所有必要的数据和定义。因此，该问题被认定为有效，并将构建一个解决方案。\n\n问题的核心在于比较一种忽略粒子穿越周期性边界的“朴素”计算方法，与一种使用最小镜像约定 (MIC) 来解释此类穿越的“校正”计算方法。我们的任务是量化 RMSD 和 RMSF 在这两种方法下的差异。让我们系统地定义所需的量并概述计算过程。\n\n所有位置 $\\mathbf{r}$ 和盒子长度 $\\mathbf{L}$ 都是 $\\mathbb{R}^3$ 中的向量。给定一个包含 $N$ 个原子的集合，一个参考构型 $\\{\\mathbf{r}_i^{ref}\\}_{i=1}^N$，以及一个包含 $T$ 个时间帧的轨迹 $\\{\\mathbf{r}_i(t)\\}_{i=1, t=1}^{N, T}$。\n\n**1. 位移约定**\n\n指定了两种计算位移向量 $\\Delta\\mathbf{r}_i(t) = \\mathbf{r}_i(t) - \\mathbf{r}_i^{ref}$ 的约定。\n\n*   **朴素包裹位移 ($\\Delta\\mathbf{r}^{wrap}$):** 这是时间 $t$ 时的包裹坐标与参考坐标之间的简单向量差。\n    $$ \\Delta\\mathbf{r}_i^{wrap}(t) = \\mathbf{r}_i(t) - \\mathbf{r}_i^{ref} $$\n    如果一个原子穿过了周期性边界，这种计算可能会产生人为的巨大位移。\n\n*   **最小镜像校正位移 ($\\Delta\\mathbf{r}^{MIC}$):** 此约定通过寻找时间 $t$ 时原子 $i$ 的周期性镜像中离其参考位置最近的一个，来校正包裹位移。对于边长为 $\\mathbf{L}=(L_x, L_y, L_z)$ 的正交盒子，校正后的位移为：\n    $$ \\Delta\\mathbf{r}_i^{MIC}(t) = \\Delta\\mathbf{r}_i^{wrap}(t) + \\mathbf{n}_i(t) \\circ \\mathbf{L} $$\n    其中 $\\circ$ 表示逐元素（Hadamard）积，$\\mathbf{n}_i(t)$ 是一个整数向量，其选择旨在最小化范数 $\\|\\Delta\\mathbf{r}_i^{MIC}(t)\\|$。这是通过独立最小化每个分量来实现的。对于每个笛卡尔分量 $\\alpha \\in \\{x, y, z\\}$，我们必须选择一个整数 $n_{i, \\alpha}(t)$，使得 $|\\Delta r_{i,\\alpha}^{wrap}(t) + n_{i, \\alpha}(t) L_{\\alpha}|$ 最小化。这等效于确保校正后的分量位于区间 $[-L_{\\alpha}/2, L_{\\alpha}/2]$ 内。整数 $n_{i, \\alpha}(t)$ 计算如下：\n    $$ n_{i, \\alpha}(t) = -\\text{round}\\left(\\frac{\\Delta r_{i, \\alpha}^{wrap}(t)}{L_{\\alpha}}\\right) $$\n    问题为标度化位移恰好为 $\\pm 0.5$ 时指定了相等情况处理规则：该值四舍五入到最近的偶数。这确保了确定性行为。\n\n**2. 均方根偏差 (RMSD)**\n\nRMSD 衡量给定构型中原子与参考构型之间的平均距离。\n首先，对于每个时间帧 $t$，我们计算瞬时均方根距离 $R(t)$：\n$$ R(t) = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\|\\Delta\\mathbf{r}_i(t)\\|^2} $$\n其中 $\\|\\cdot\\|$ 是欧几里得范数。最终报告的 RMSD, $\\overline{R}$，是 $R(t)$ 的时间平均值：\n$$ \\overline{R} = \\frac{1}{T}\\sum_{t=1}^T R(t) $$\n我们将为两种位移约定计算此值，得到 $\\overline{R}^{wrap}$ 和 $\\overline{R}^{MIC}$。\n\n**3. 均方根涨落 (RMSF)**\n\nRMSF 衡量每个原子在其轨迹上的平均位置周围的涨落。\n首先，我们必须根据选定的位移约定重构一个连续（未包裹）的轨迹 $\\mathbf{u}_i(t)$：\n$$ \\mathbf{u}_i(t) = \\mathbf{r}_i^{ref} + \\Delta\\mathbf{r}_i(t) $$\n接下来，我们计算每个原子的时间平均位置 $\\overline{\\mathbf{u}}_i$：\n$$ \\overline{\\mathbf{u}}_i = \\frac{1}{T}\\sum_{t=1}^T \\mathbf{u}_i(t) $$\n原子 $i$ 的 RMSF, $\\mathrm{RMSF}_i$，是其与平均位置偏差的均方根：\n$$ \\mathrm{RMSF}_i = \\sqrt{\\frac{1}{T}\\sum_{t=1}^T \\|\\mathbf{u}_i(t) - \\overline{\\mathbf{u}}_i\\|^2} $$\n最终报告的值 $\\overline{\\mathrm{F}}$ 是单个原子 RMSF 值在所有原子上的平均值：\n$$ \\overline{\\mathrm{F}} = \\frac{1}{N}\\sum_{i=1}^N \\mathrm{RMSF}_i $$\n我们将为两种位移约定计算此值，得到 $\\overline{\\mathrm{F}}^{wrap}$ 和 $\\overline{\\mathrm{F}}^{MIC}$。\n\n**算法实现**\n\n解决方案将使用 Python 的 `numpy` 库来实现，以进行高效的向量化运算。\n\n1.  对于每个测试用例，将输入数据（盒子尺寸 $\\mathbf{L}$、参考位置 $\\mathbf{r}^{ref}$ 和轨迹位置 $\\mathbf{r}(t)$）加载到 `numpy` 数组中。\n2.  将包裹位移 $\\Delta\\mathbf{r}^{wrap}$ 计算为一个 $T \\times N \\times 3$ 的数组。\n3.  使用一个实现 MIC 规则的函数来计算 MIC 位移 $\\Delta\\mathbf{r}^{MIC}$，同样作为一个 $T \\times N \\times 3$ 的数组。`numpy.round` 自然地实现了指定的‘四舍五入到最近的偶数’的相等情况处理规则。\n4.  实现独立的函数，从给定的位移数组（$T \\times N \\times 3$）和参考位置计算 $\\overline{R}$ 和 $\\overline{\\mathrm{F}}$。\n5.  使用 $\\Delta\\mathbf{r}^{wrap}$ 和 $\\Delta\\mathbf{r}^{MIC}$ 调用这些函数，以获得四个所需的度量：$\\overline{R}^{wrap}$、$\\overline{R}^{MIC}$、$\\overline{\\mathrm{F}}^{wrap}$ 和 $\\overline{\\mathrm{F}}^{MIC}$。\n6.  将每个用例的结果四舍五入到 6 位小数并收集起来。\n7.  最后，将所有测试用例收集到的结果按照规定格式化为表示列表的列表的单个字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"L\": (1.0, 1.0, 1.0),\n            \"N\": 1,\n            \"T\": 4,\n            \"ref_pos\": [[0.90, 0.00, 0.00]],\n            \"traj\": [\n                [[0.90, 0.00, 0.00]],\n                [[0.95, 0.00, 0.00]],\n                [[0.98, 0.00, 0.00]],\n                [[0.02, 0.00, 0.00]],\n            ],\n        },\n        {\n            \"L\": (2.0, 1.0, 1.5),\n            \"N\": 3,\n            \"T\": 3,\n            \"ref_pos\": [\n                [1.80, 0.20, 0.75],\n                [0.10, 0.90, 0.10],\n                [1.99, 0.05, 1.49],\n            ],\n            \"traj\": [\n                [\n                    [1.85, 0.22, 0.78],\n                    [0.15, 0.92, 0.14],\n                    [1.98, 0.06, 1.48],\n                ],\n                [\n                    [0.05, 0.22, 0.78],\n                    [0.15, 0.02, 0.14],\n                    [1.98, 0.06, 0.01],\n                ],\n                [\n                    [0.10, 0.24, 0.77],\n                    [0.18, 0.05, 0.08],\n                    [0.02, 0.04, 0.02],\n                ],\n            ],\n        },\n        {\n            \"L\": (1.0, 1.0, 1.0),\n            \"N\": 2,\n            \"T\": 2,\n            \"ref_pos\": [\n                [0.25, 0.25, 0.25],\n                [0.75, 0.75, 0.75],\n            ],\n            \"traj\": [\n                [\n                    [0.75, 0.25, 0.25],\n                    [0.25, 0.75, 0.75],\n                ],\n                [\n                    [0.75, 0.75, 0.25],\n                    [0.25, 0.25, 0.75],\n                ]\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = _compute_metrics_for_case(case)\n        results.append(case_results)\n\n    # The string representation of a list of lists is the required format.\n    print(str(results))\n\ndef _get_mic_displacements(delta_r_wrap, L_array):\n    \"\"\"\n    Computes minimal-image corrected displacements from wrapped displacements.\n    The tie-breaking rule (round half to nearest even integer) is the default\n    behavior of numpy.round().\n    \"\"\"\n    scaled_dr = delta_r_wrap / L_array\n    n = -np.round(scaled_dr)\n    delta_r_mic = delta_r_wrap + n * L_array\n    return delta_r_mic\n\ndef _compute_avg_rmsd(displacements, N, T):\n    \"\"\"Computes time-averaged RMSD from a displacement array.\"\"\"\n    sq_norms = np.sum(displacements**2, axis=2)  # Shape: (T, N)\n    msd_t = np.mean(sq_norms, axis=1)           # Shape: (T,)\n    R_t = np.sqrt(msd_t)\n    avg_R = np.mean(R_t)\n    return avg_R\n\ndef _compute_avg_rmsf(displacements, ref_pos, N, T):\n    \"\"\"Computes atom-averaged RMSF from a displacement array and reference positions.\"\"\"\n    # Reconstruct continuous trajectory u_i(t) = r_ref_i + delta_r_i(t)\n    # ref_pos has shape (N, 3). Add new axis to broadcast to (T, N, 3)\n    u = ref_pos[np.newaxis, :, :] + displacements\n    \n    # Compute time-averaged position for each atom, u_mean has shape (N, 3)\n    u_mean = np.mean(u, axis=0)\n    \n    # Calculate deviations from the mean: u(t) - u_mean\n    # u_mean has shape (N, 3). Add new axis to broadcast to (T, N, 3)\n    dev_from_mean = u - u_mean[np.newaxis, :, :]\n    \n    # Compute RMSF per atom\n    sq_norms_dev = np.sum(dev_from_mean**2, axis=2) # Shape: (T, N)\n    msd_i = np.mean(sq_norms_dev, axis=0)          # Shape: (N,)\n    RMSF_i = np.sqrt(msd_i)\n    \n    # Average RMSF over all atoms\n    avg_F = np.mean(RMSF_i)\n    return avg_F\n\ndef _compute_metrics_for_case(case_data):\n    \"\"\"\n    Processes a single test case to compute all four required metrics.\n    \"\"\"\n    L = np.array(case_data[\"L\"])\n    ref_pos = np.array(case_data[\"ref_pos\"])\n    traj = np.array(case_data[\"traj\"])\n    N = case_data[\"N\"]\n    T = case_data[\"T\"]\n\n    # Calculate wrapped displacements: traj - ref_pos\n    # ref_pos has shape (N, 3). Add a new axis to broadcast to (T, N, 3).\n    delta_r_wrap = traj - ref_pos[np.newaxis, :, :]\n\n    # Calculate minimal-image corrected displacements\n    delta_r_mic = _get_mic_displacements(delta_r_wrap, L)\n\n    # Compute RMSD for both conventions\n    R_wrap = _compute_avg_rmsd(delta_r_wrap, N, T)\n    R_mic = _compute_avg_rmsd(delta_r_mic, N, T)\n\n    # Compute RMSF for both conventions\n    F_wrap = _compute_avg_rmsf(delta_r_wrap, ref_pos, N, T)\n    F_mic = _compute_avg_rmsf(delta_r_mic, ref_pos, N, T)\n\n    # Round results to 6 decimal places\n    return [\n        round(R_wrap, 6),\n        round(R_mic, 6),\n        round(F_wrap, 6),\n        round(F_mic, 6)\n    ]\n\n# Run the solution\nsolve()\n```"
        },
        {
            "introduction": "在比较两种不同条件下模拟得到的均方根涨落（RMSF）谱时，仅仅观察到差异是不够的；我们必须确定这种差异是否具有统计显著性。这个练习将引导你建立一个假设检验框架，用于比较两个独立模拟中的原子涨落，并应用 Benjamini-Hochberg 程序来控制多重检验中的伪发现率（False Discovery Rate）。通过这个实践，你将学会如何从模拟数据中得出可靠的科学结论。",
            "id": "3443697",
            "problem": "考虑对同一蛋白质在两种条件下进行的两项独立的全原子分子动力学（MD）模拟。对于每个原子索引 $i \\in \\{1,\\dots,m\\}$，将单位原子的均方根涨落（RMSF）定义为 \n$$f_{i}(t) = \\sqrt{\\langle \\|\\mathbf{r}_{i}(t) - \\langle \\mathbf{r}_{i}(t) \\rangle_{t}\\|^{2} \\rangle_{t}}$$\n其中 $\\mathbf{r}_{i}(t)$ 是原子 $i$ 在时间 $t$ 的笛卡尔坐标位置，而 $\\langle \\cdot \\rangle_{t}$ 表示在单次模拟的轨迹上进行的时间平均。为了减轻时间相关性，每次模拟被划分为 $n$ 个等时长的非重叠块。在每个块内，计算一个块级 RMSF 估计值；跨块的样本均值作为原子 $i$ 的每次模拟 RMSF 摘要，而跨块的样本方差量化了块间的变异性。假设满足平稳性、遍历性，并且块的大小足够大，以至于块级 RMSF 估计值在各块之间近似独立。\n\n给定以下针对 $m = 6$ 个原子，在 $n^{(1)} = n^{(2)} = n = 40$ 个块上汇总的单位原子、单位模拟的摘要统计数据。对于每个原子 $i$，$\\bar{f}_{i}^{(1)}$ 和 $s_{i,1}^{2}$ 分别表示模拟 1 中块级 RMSF 估计值的跨块样本均值和样本方差；类似地，$\\bar{f}_{i}^{(2)}$ 和 $s_{i,2}^{2}$ 来自模拟 2。所有方差的单位均为平方埃格斯特姆（Ångströms），所有均值的单位均为埃格斯特姆（Ångströms）。数据如下：\n- 原子 1：$\\bar{f}_{1}^{(1)} = 1.934164079$, $s_{1,1}^{2} = 0.04$；$\\bar{f}_{1}^{(2)} = 1.800000000$, $s_{1,2}^{2} = 0.04$。\n- 原子 2：$\\bar{f}_{2}^{(1)} = 2.061803399$, $s_{2,1}^{2} = 0.04$；$\\bar{f}_{2}^{(2)} = 1.950000000$, $s_{2,2}^{2} = 0.04$。\n- 原子 3：$\\bar{f}_{3}^{(1)} = 2.198386991$, $s_{3,1}^{2} = 0.04$；$\\bar{f}_{3}^{(2)} = 2.100000000$, $s_{3,2}^{2} = 0.04$。\n- 原子 4：$\\bar{f}_{4}^{(1)} = 1.780498447$, $s_{4,1}^{2} = 0.04$；$\\bar{f}_{4}^{(2)} = 1.700000000$, $s_{4,2}^{2} = 0.04$。\n- 原子 5：$\\bar{f}_{5}^{(1)} = 2.267082040$, $s_{5,1}^{2} = 0.04$；$\\bar{f}_{5}^{(2)} = 2.200000000$, $s_{5,2}^{2} = 0.04$。\n- 原子 6：$\\bar{f}_{6}^{(1)} = 1.622360680$, $s_{6,1}^{2} = 0.04$；$\\bar{f}_{6}^{(2)} = 1.600000000$, $s_{6,2}^{2} = 0.04$。\n\n任务：\n- 从均方根涨落（RMSF）的定义和样本均值的基本极限定理出发，构建一个双样本假设检验，以评估对于每个原子 $i$ 的零假设——即两次模拟之间的长时间平均块级 RMSF 相等，备择假设为双侧。明确指出检验统计量及其在零假设下当块数较大且块级估计值独立时的渐近抽样分布。\n- 仅使用给定的摘要统计数据，计算您检验下每个原子的双侧 $p$ 值。\n- 为了在 $m = 6$ 个原子级假设中将错误发现率（FDR；定义为所有拒绝中错误拒绝的预期比例）控制在目标水平 $q = 0.10$，从排序 $p$ 值的基本原理推导 Benjamini–Hochberg (BH) 决策规则，并将其应用于您的六个 $p$ 值。\n- 报告在 FDR 水平 $q = 0.10$ 下，被宣布在两次模拟之间存在显著差异的原子数量 $k$。您的最终答案必须是一个无单位的整数。不要对任何中间 $p$ 值进行四舍五入；BH 决策仅取决于它们的顺序以及与 $q$ 和 $m$ 的有理数阈值的比较。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n- 原子数：$m = 6$。\n- 独立的 MD 模拟次数：$2$。\n- 每次模拟的非重叠块数：$n^{(1)} = n^{(2)} = n = 40$。\n- 单位原子的均方根涨落（RMSF）定义：$f_{i}(t) = \\sqrt{\\langle \\|\\mathbf{r}_{i}(t) - \\langle \\mathbf{r}_{i}(t) \\rangle_{t}\\|^{2} \\rangle_{t}}$。\n- 原子 $i$ 的摘要统计数据：\n  - 模拟 1：块 RMSF 的样本均值 $\\bar{f}_{i}^{(1)}$；块 RMSF 的样本方差 $s_{i,1}^{2}$。\n  - 模拟 2：块 RMSF 的样本均值 $\\bar{f}_{i}^{(2)}$；块 RMSF 的样本方差 $s_{i,2}^{2}$。\n- 数据：\n  - 原子 1：$\\bar{f}_{1}^{(1)} = 1.934164079$, $s_{1,1}^{2} = 0.04$；$\\bar{f}_{1}^{(2)} = 1.800000000$, $s_{1,2}^{2} = 0.04$。\n  - 原子 2：$\\bar{f}_{2}^{(1)} = 2.061803399$, $s_{2,1}^{2} = 0.04$；$\\bar{f}_{2}^{(2)} = 1.950000000$, $s_{2,2}^{2} = 0.04$。\n  - 原子 3：$\\bar{f}_{3}^{(1)} = 2.198386991$, $s_{3,1}^{2} = 0.04$；$\\bar{f}_{3}^{(2)} = 2.100000000$, $s_{3,2}^{2} = 0.04$。\n  - 原子 4：$\\bar{f}_{4}^{(1)} = 1.780498447$, $s_{4,1}^{2} = 0.04$；$\\bar{f}_{4}^{(2)} = 1.700000000$, $s_{4,2}^{2} = 0.04$。\n  - 原子 5：$\\bar{f}_{5}^{(1)} = 2.267082040$, $s_{5,1}^{2} = 0.04$；$\\bar{f}_{5}^{(2)} = 2.200000000$, $s_{5,2}^{2} = 0.04$。\n  - 原子 6：$\\bar{f}_{6}^{(1)} = 1.622360680$, $s_{6,1}^{2} = 0.04$；$\\bar{f}_{6}^{(2)} = 1.600000000$, $s_{6,2}^{2} = 0.04$。\n- 假设：平稳性、遍历性、块级 RMSF 估计值近似独立。\n- 目标错误发现率（FDR）：$q = 0.10$。\n\n**第 2 步：使用提取的已知条件进行验证**\n- **科学依据**：该问题使用了分子动力学（RMSF）和生物统计学（假设检验、FDR 控制）中的标准概念。该设置是分析模拟数据中的常见情景。所作的假设在该领域是标准的。\n- **问题定义明确**：问题提供了所有必要的数据（$\\bar{f}_i^{(k)}$, $s_{i,k}^2$, $n$），以及一套明确的任务，这些任务导向一个唯一的数值答案。\n- **客观性**：问题以精确、量化的术语陈述。\n- **完整性与一致性**：提供了双样本检验和后续多重检验校正所需的所有数据。单位（埃格斯特姆和平方埃格斯特姆）是一致的。所有样本方差都相同（$s_{i,k}^2=0.04$）是一个简化，但并非矛盾。\n- **其他缺陷**：问题并非微不足道、不切实际、定义不清或无法验证。结构逻辑清晰，所要求的任务是标准的统计程序。\n\n**第 3 步：结论与行动**\n问题有效。将提供完整解答。\n\n### 解答\n\n**任务 1：构建假设检验**\n\n对于每个原子 $i \\in \\{1,\\dots,6\\}$，我们希望检验两次模拟中块级 RMSF 的真实长时间平均值是否相同。设 $\\mu_{i}^{(1)}$ 和 $\\mu_{i}^{(2)}$ 分别为模拟 1 和模拟 2 中原子 $i$ 的真实平均块级 RMSF。我们为每个原子构建一个双样本假设检验：\n- 零假设 $H_{0,i}: \\mu_{i}^{(1)} = \\mu_{i}^{(2)}$\n- 备择假设 $H_{A,i}: \\mu_{i}^{(1)} \\neq \\mu_{i}^{(2)}$（双侧）\n\n我们给出了来自两次独立模拟的样本均值（$\\bar{f}_{i}^{(1)}$, $\\bar{f}_{i}^{(2)}$）、样本方差（$s_{i,1}^{2}$, $s_{i,2}^{2}$）和样本大小（$n^{(1)}=n^{(2)}=n=40$）。假设块的大小足够大，使得块级估计值近似独立。由于块数 $n=40$ 很大，根据中心极限定理，样本均值 $\\bar{f}_{i}^{(k)}$ 的抽样分布近似为正态分布。\n\n合适的检验统计量是针对两个独立样本的 Welch t-统计量，它不假设总体方差相等。原子 $i$ 的统计量为：\n$$ T_i = \\frac{(\\bar{f}_{i}^{(1)} - \\bar{f}_{i}^{(2)}) - (\\mu_{i}^{(1)} - \\mu_{i}^{(2)})}{ \\sqrt{ \\frac{s_{i,1}^{2}}{n^{(1)}} + \\frac{s_{i,2}^{2}}{n^{(2)}} } } $$\n在零假设 $H_{0,i}$ 下，$\\mu_{i}^{(1)} - \\mu_{i}^{(2)} = 0$。对于大样本量（$n \\ge 30$），t-分布收敛于标准正态分布。因此，检验统计量在零假设下的渐近抽样分布是标准正态分布，$Z \\sim N(0,1)$。我们将检验统计量的值表示为 $Z_i$：\n$$ Z_i = \\frac{\\bar{f}_{i}^{(1)} - \\bar{f}_{i}^{(2)}}{ \\sqrt{ \\frac{s_{i,1}^{2}}{n^{(1)}} + \\frac{s_{i,2}^{2}}{n^{(2)}} } } $$\n\n**任务 2：计算 p 值**\n\n首先，我们计算均值差的标准误。由于对于所有原子，$s_{i,1}^{2} = s_{i,2}^{2} = 0.04$ 且 $n^{(1)}=n^{(2)}=40$，所以这一项是恒定的：\n$$ SE_{\\Delta} = \\sqrt{\\frac{0.04}{40} + \\frac{0.04}{40}} = \\sqrt{2 \\times \\frac{0.04}{40}} = \\sqrt{2 \\times 0.001} = \\sqrt{0.002} = \\sqrt{\\frac{2}{1000}} = \\sqrt{\\frac{1}{500}} = \\frac{1}{10\\sqrt{5}} = \\frac{\\sqrt{5}}{50} $$\n接下来，我们为每个原子计算 $Z_i$ 统计量：\n- 原子 1：$\\Delta_1 = \\bar{f}_{1}^{(1)} - \\bar{f}_{1}^{(2)} = 1.934164079 - 1.8 = 0.134164079$。\n  $Z_1 = \\frac{0.134164079}{\\sqrt{5}/50} \\approx \\frac{0.134164079}{0.04472136} \\approx 3.000...$。我们取 $Z_1 = 3$。\n- 原子 2：$\\Delta_2 = 2.061803399 - 1.95 = 0.111803399$。\n  $Z_2 = \\frac{0.111803399}{\\sqrt{5}/50} \\approx 2.500...$。我们取 $Z_2 = 2.5$。\n- 原子 3：$\\Delta_3 = 2.198386991 - 2.1 = 0.098386991$。\n  $Z_3 = \\frac{0.098386991}{\\sqrt{5}/50} \\approx 2.200...$。我们取 $Z_3 = 2.2$。\n- 原子 4：$\\Delta_4 = 1.780498447 - 1.7 = 0.080498447$。\n  $Z_4 = \\frac{0.080498447}{\\sqrt{5}/50} \\approx 1.800...$。我们取 $Z_4 = 1.8$。\n- 原子 5：$\\Delta_5 = 2.267082040 - 2.2 = 0.067082040$。\n  $Z_5 = \\frac{0.067082040}{\\sqrt{5}/50} \\approx 1.500...$。我们取 $Z_5 = 1.5$。\n- 原子 6：$\\Delta_6 = 1.622360680 - 1.6 = 0.022360680$。\n  $Z_6 = \\frac{0.022360680}{\\sqrt{5}/50} \\approx 0.500...$。我们取 $Z_6 = 0.5$。\n\n每个原子的双侧 $p$ 值为 $p_i = 2 \\cdot P(Z > |Z_i|) = 2(1 - \\Phi(|Z_i|))$，其中 $\\Phi$ 是标准正态分布的累积分布函数。\n- $p_1 = 2(1 - \\Phi(3.0)) \\approx 2(1 - 0.99865) = 0.0027$\n- $p_2 = 2(1 - \\Phi(2.5)) \\approx 2(1 - 0.99379) = 0.0124$\n- $p_3 = 2(1 - \\Phi(2.2)) \\approx 2(1 - 0.98610) = 0.0278$\n- $p_4 = 2(1 - \\Phi(1.8)) \\approx 2(1 - 0.96407) = 0.0719$\n- $p_5 = 2(1 - \\Phi(1.5)) \\approx 2(1 - 0.93319) = 0.1336$\n- $p_6 = 2(1 - \\Phi(0.5)) \\approx 2(1 - 0.69146) = 0.6171$\n\n**任务 3：应用 Benjamini–Hochberg (BH) 程序**\n\nBenjamini-Hochberg 程序将错误发现率（FDR）控制在指定的水平 $q$。FDR 是在所有被拒绝的假设中，错误拒绝的零假设（I 型错误）的预期比例。该程序基于对 $p$ 值进行排序，并将其与一系列调整后的显著性阈值进行比较的原理。与控制族系误差率相比，这提供了一个更强大的检验，尤其是在检验多个假设时。\n\nBH 决策规则如下：\n1.  设 $m$ 个独立的 $p$ 值为 $p_1, p_2, \\dots, p_m$。对于我们的问题，$m = 6$。\n2.  将这些 $p$ 值从小到大排序：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。\n3.  为每个排序后的 $p$ 值定义 BH 临界值：$c_j = \\frac{j}{m}q$，其中 $q = 0.10$ 是目标 FDR。\n4.  找到最大的整数 $k$，使得 $p_{(k)} \\le \\frac{k}{m}q$。\n5.  拒绝与这 $k$ 个最小的 $p$ 值相对应的零假设 $H_{0,(1)}, \\dots, H_{0,(k)}$。\n\n我们的 $Z$ 分数已按大小排序：$|Z_1| > |Z_2| > |Z_3| > |Z_4| > |Z_5| > |Z_6|$。这意味着 $p$ 值的排序为 $p_1  p_2  p_3  p_4  p_5  p_6$。因此，排序后的 $p$ 值为 $p_{(j)} = p_j$。我们将每个 $p_{(j)}$ 与其临界值 $\\frac{j}{6}(0.10)$ 进行比较：\n\n- 对于 $j=1$：$p_{(1)} = p_1 \\approx 0.0027$。阈值为 $\\frac{1}{6}(0.10) \\approx 0.0167$。\n  $0.0027 \\le 0.0167$。条件成立。\n- 对于 $j=2$：$p_{(2)} = p_2 \\approx 0.0124$。阈值为 $\\frac{2}{6}(0.10) \\approx 0.0333$。\n  $0.0124 \\le 0.0333$。条件成立。\n- 对于 $j=3$：$p_{(3)} = p_3 \\approx 0.0278$。阈值为 $\\frac{3}{6}(0.10) = 0.05$。\n  $0.0278 \\le 0.05$。条件成立。\n- 对于 $j=4$：$p_{(4)} = p_4 \\approx 0.0719$。阈值为 $\\frac{4}{6}(0.10) \\approx 0.0667$。\n  $0.0719  0.0667$。条件不成立。\n- 对于 $j=5$：$p_{(5)} = p_5 \\approx 0.1336$。阈值为 $\\frac{5}{6}(0.10) \\approx 0.0833$。\n  $0.1336  0.0833$。条件不成立。\n- 对于 $j=6$：$p_{(6)} = p_6 \\approx 0.6171$。阈值为 $\\frac{6}{6}(0.10) = 0.10$。\n  $0.6171  0.10$。条件不成立。\n\n满足条件 $p_{(k)} \\le \\frac{k}{m}q$ 的最大索引 $k$ 是 $k=3$。\n\n**任务 4：报告显著差异的数量**\n\n根据 BH 程序，我们拒绝前 $k=3$ 个原子（原子 1、原子 2 和原子 3）的零假设。在 FDR 水平 $q=0.10$ 下，被宣布在两次模拟之间具有显著不同 RMSF 的原子数量是 $3$。",
            "answer": "$$\n\\boxed{3}\n$$"
        }
    ]
}