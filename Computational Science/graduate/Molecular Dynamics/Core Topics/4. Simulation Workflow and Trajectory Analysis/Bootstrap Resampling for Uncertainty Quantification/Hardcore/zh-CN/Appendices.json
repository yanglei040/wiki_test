{
    "hands_on_practices": [
        {
            "introduction": "在应用 bootstrap 方法时，一个关键的实践问题是：需要多少次 bootstrap 重抽样（$B$）才足够？bootstrap 估计本身会因为有限的 $B$ 而引入蒙特卡洛误差，这个误差可以被分析和限定。本练习将指导您推导重抽样次数与 bootstrap 分位数估计精度之间的关系，为在您自己的研究中选择 $B$ 提供一个定量的依据。",
            "id": "3399625",
            "problem": "对一种 Lennard-Jones 流体进行分子动力学 (MD) 模拟，运行时间足够长，使得每摩尔势能在非重叠时间块上的块平均值可以被视为近似独立同分布。设这 $m$ 个块平均值表示为 $\\{X_{i}\\}_{i=1}^{m}$，单位为 $\\mathrm{kJ}\\ \\mathrm{mol}^{-1}$。为量化由有限采样引起的平均势能估计的不确定性，采用非参数 bootstrap 方法：从 $\\{X_{i}\\}_{i=1}^{m}$ 的经验分布中，生成 $B$ 个 bootstrap 重抽样样本，并从每个重抽样样本中计算相应的统计量 $T^{*}$（重抽样均值）。将 $T^{*}$ 的 bootstrap 分布表示为 $F^{*}$，其 $\\alpha$-分位数表示为 $q_{\\alpha}^{*}$。\n\n关注当通过 $B$ 个 bootstrap 复制样本 $\\{T^{*}_{b}\\}_{b=1}^{B}$ 的经验 $\\alpha$-分位数 $\\hat{q}_{\\alpha}^{(B)}$ 来估计 $\\alpha$-分位数 $q_{\\alpha}^{*}$ 时，仅由有限数量 $B$ 的 bootstrap 重抽样引起的蒙特卡罗误差。从经验累积分布函数 (CDF) 的定义以及分位数作为 CDF 反函数的定义出发，并仅使用关于指示随机变量的基本概率事实以及 CDF 在分位数处的可微性，推导 $\\hat{q}_{\\alpha}^{(B)}$ 的蒙特卡罗标准误差关于 $B$ 的函数的上界。此推导需在以下正则性假设下进行：bootstrap 分布具有一个密度函数 $f^{*}$，该函数在 $q_{\\alpha}^{*}$ 处连续，并且在该点有一个已知的正常数 $c0$ 作为下界，即 $f^{*}(q_{\\alpha}^{*}) \\ge c$。\n\n然后，对于上述特定的 MD 研究，假设一个具有非常大重抽样数量的引导性 bootstrap 和核密度估计表明，在 $\\alpha = 0.95$ 处，密度满足 $f^{*}(q_{0.95}^{*}) \\ge c$，其中 $c = 2.0 \\times 10^{-2}\\ (\\mathrm{kJ}\\ \\mathrm{mol}^{-1})^{-1}$。如果您要求由有限 $B$ 引起的 $\\alpha$-分位数估计器的蒙特卡罗标准误差不大于 $\\delta = 0.20\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}$，请使用您推导出的上界选择 $B$ 以满足此要求。\n\n- 用 $\\alpha$、$B$ 和 $c$ 的符号形式推导该上界。\n- 然后计算保证蒙特卡罗标准误差的上界最多为 $\\delta$ 的最小整数值 $B$。\n\n将最终答案表示为最小整数 bootstrap 重抽样数 $B$。最终答案中不应包含任何单位。",
            "solution": "该问题要求我们首先推导一个 bootstrap 分位数估计器的蒙特卡罗标准误差的上界，然后利用这个上界来确定达到期望精度水平所需的最小 bootstrap 重抽样数 $B$。\n\n设 bootstrap 统计量 $T^{*}$ 的真实累积分布函数 (CDF) 为 $F^{*}(t) = P(T^{*} \\le t)$，其概率密度函数 (PDF) 为 $f^{*}(t) = (F^{*})'(t)$。真实 $\\alpha$-分位数 $q_{\\alpha}^{*}$ 由关系 $F^{*}(q_{\\alpha}^{*}) = \\alpha$ 定义。\n\n我们有一组 $B$ 个 bootstrap 复制样本 $\\{T^{*}_{b}\\}_{b=1}^{B}$，它们是从分布 $F^{*}$ 中抽取的独立同分布 (i.i.d.) 随机变量。基于这些复制样本的经验 CDF 由下式给出：\n$$ \\hat{F}_{B}^{*}(t) = \\frac{1}{B} \\sum_{b=1}^{B} I(T^{*}_{b} \\le t) $$\n其中 $I(\\cdot)$ 是指示函数。经验 $\\alpha$-分位数 $\\hat{q}_{\\alpha}^{(B)}$ 是 $q_{\\alpha}^{*}$ 的估计器，定义为经验 CDF 的反函数：$\\hat{q}_{\\alpha}^{(B)} = (\\hat{F}_{B}^{*})^{-1}(\\alpha) = \\inf\\{t : \\hat{F}_{B}^{*}(t) \\ge \\alpha\\}$。\n\n我们的目标是求出蒙特卡罗标准误差 $\\mathrm{SE}(\\hat{q}_{\\alpha}^{(B)}) = \\sqrt{\\mathrm{Var}(\\hat{q}_{\\alpha}^{(B)})}$，其中方差是针对 $B$ 个 bootstrap 复制样本的分布计算的。\n\n推导的核心在于将分位数估计器 $\\hat{q}_{\\alpha}^{(B)}$ 的变异性与经验 CDF 估计器 $\\hat{F}_{B}^{*}(t)$ 的变异性联系起来。后者更易于分析。这种关系可以通过一阶近似来建立，在 $f^{*}$ 于 $q_{\\alpha}^{*}$ 处连续且非零的假设下，该近似对较大的 $B$ 有效。这是样本分位数渐近理论中的一个公认结果（与 Bahadur 表示有关）。近似式为：\n$$ \\hat{q}_{\\alpha}^{(B)} - q_{\\alpha}^{*} \\approx -\\frac{\\hat{F}_{B}^{*}(q_{\\alpha}^{*}) - F^{*}(q_{\\alpha}^{*})}{f^{*}(q_{\\alpha}^{*})} $$\n代入 $F^{*}(q_{\\alpha}^{*}) = \\alpha$，我们得到：\n$$ \\hat{q}_{\\alpha}^{(B)} \\approx q_{\\alpha}^{*} - \\frac{\\hat{F}_{B}^{*}(q_{\\alpha}^{*}) - \\alpha}{f^{*}(q_{\\alpha}^{*})} $$\n现在我们可以计算 $\\hat{q}_{\\alpha}^{(B)}$ 的方差。由于 $q_{\\alpha}^{*}$、$\\alpha$ 和 $f^{*}(q_{\\alpha}^{*})$ 相对于蒙特卡罗抽样是常数（它们是真实的、潜在的 bootstrap 分布 $F^{*}$ 的属性），该表达式的方差由 $\\hat{F}_{B}^{*}(q_{\\alpha}^{*})$ 的方差决定。\n$$ \\mathrm{Var}(\\hat{q}_{\\alpha}^{(B)}) \\approx \\mathrm{Var}\\left( q_{\\alpha}^{*} - \\frac{\\hat{F}_{B}^{*}(q_{\\alpha}^{*}) - \\alpha}{f^{*}(q_{\\alpha}^{*})} \\right) = \\mathrm{Var}\\left( - \\frac{\\hat{F}_{B}^{*}(q_{\\alpha}^{*})}{f^{*}(q_{\\alpha}^{*})} \\right) = \\frac{1}{[f^{*}(q_{\\alpha}^{*})]^2} \\mathrm{Var}(\\hat{F}_{B}^{*}(q_{\\alpha}^{*})) $$\n接下来，我们确定 $\\mathrm{Var}(\\hat{F}_{B}^{*}(q_{\\alpha}^{*}))$。$\\hat{F}_{B}^{*}(q_{\\alpha}^{*})$ 项是 $B$ 个独立同分布的伯努利随机变量 $Y_b = I(T^{*}_{b} \\le q_{\\alpha}^{*})$ 的平均值。每次试验“成功”的概率是 $p = P(T^{*}_{b} \\le q_{\\alpha}^{*}) = F^{*}(q_{\\alpha}^{*}) = \\alpha$。单个伯努利($p$)随机变量的方差是 $p(1-p)$。\n$B$ 个此类独立同分布变量的平均值的方差是单个变量方差的 $\\frac{1}{B}$ 倍：\n$$ \\mathrm{Var}(\\hat{F}_{B}^{*}(q_{\\alpha}^{*})) = \\mathrm{Var}\\left(\\frac{1}{B}\\sum_{b=1}^{B} Y_b\\right) = \\frac{1}{B^2} \\sum_{b=1}^{B} \\mathrm{Var}(Y_b) = \\frac{1}{B^2} (B \\cdot p(1-p)) = \\frac{p(1-p)}{B} $$\n代入 $p=\\alpha$，我们有：\n$$ \\mathrm{Var}(\\hat{F}_{B}^{*}(q_{\\alpha}^{*})) = \\frac{\\alpha(1-\\alpha)}{B} $$\n将此结果代回分位数估计器的方差表达式中：\n$$ \\mathrm{Var}(\\hat{q}_{\\alpha}^{(B)}) \\approx \\frac{\\alpha(1-\\alpha)}{B [f^{*}(q_{\\alpha}^{*})]^2} $$\n蒙特卡罗标准误差是方差的平方根：\n$$ \\mathrm{SE}(\\hat{q}_{\\alpha}^{(B)}) = \\sqrt{\\mathrm{Var}(\\hat{q}_{\\alpha}^{(B)})} \\approx \\frac{\\sqrt{\\alpha(1-\\alpha)}}{\\sqrt{B} f^{*}(q_{\\alpha}^{*})} $$\n问题提供了正则性条件，即密度 $f^{*}(q_{\\alpha}^{*})$ 由一个已知的正常数 $c$ 作为下界，即 $f^{*}(q_{\\alpha}^{*}) \\ge c  0$。由于 $f^{*}(q_{\\alpha}^{*})$ 出现在分母中，这个下界使我们能够确定标准误差的上界：\n$$ \\mathrm{SE}(\\hat{q}_{\\alpha}^{(B)}) \\le \\frac{\\sqrt{\\alpha(1-\\alpha)}}{c\\sqrt{B}} $$\n这就是 $\\alpha$-分位数估计器的蒙特卡罗标准误差的符号上界。\n\n现在，我们进行问题的数值计算部分。我们已知以下数值：\n我们关心的分位数对应于 $\\alpha = 0.95$。\n密度的下界是 $c = 2.0 \\times 10^{-2}\\ (\\mathrm{kJ}\\ \\mathrm{mol}^{-1})^{-1}$。\n标准误差要求的上限是 $\\delta = 0.20\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}$。\n\n我们需要找到满足条件 $\\mathrm{SE}(\\hat{q}_{\\alpha}^{(B)}) \\le \\delta$ 的最小整数 $B$。为保证这一点，我们将此条件施加于我们推导出的上界：\n$$ \\frac{\\sqrt{\\alpha(1-\\alpha)}}{c\\sqrt{B}} \\le \\delta $$\n我们求解这个关于 $B$ 的不等式。由于所有量都为正，我们可以重新整理并平方，而不用改变不等号的方向。\n$$ \\sqrt{B} \\ge \\frac{\\sqrt{\\alpha(1-\\alpha)}}{c\\delta} $$\n$$ B \\ge \\frac{\\alpha(1-\\alpha)}{(c\\delta)^2} $$\n现在，我们代入数值：\n$$ \\alpha(1-\\alpha) = 0.95 \\times (1 - 0.95) = 0.95 \\times 0.05 = 0.0475 $$\n$$ c\\delta = (2.0 \\times 10^{-2}) \\times 0.20 = 0.02 \\times 0.2 = 0.004 = 4 \\times 10^{-3} $$\n$$ (c\\delta)^2 = (4 \\times 10^{-3})^2 = 16 \\times 10^{-6} = 1.6 \\times 10^{-5} $$\n将这些代入关于 $B$ 的不等式中：\n$$ B \\ge \\frac{0.0475}{1.6 \\times 10^{-5}} = \\frac{4.75 \\times 10^{-2}}{1.6 \\times 10^{-5}} = \\frac{4.75}{1.6} \\times 10^3 = 2.96875 \\times 10^3 = 2968.75 $$\n由于 bootstrap 重抽样数 $B$ 必须是整数，我们必须取该值的上取整（ceiling）以满足不等式。\n$$ B = \\lceil 2968.75 \\rceil = 2969 $$\n因此，为确保所估计的 $0.95$-分位数的蒙特卡罗标准误差不超过 $0.20\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}$，所需的最小整数 bootstrap 重抽样数是 $2969$。",
            "answer": "$$ \\boxed{2969} $$"
        },
        {
            "introduction": "Jarzynski 等式是计算自由能差异的强大工具，但其估计量对罕见事件极为敏感，导致方差很大。分层 bootstrap 是一种方差缩减技术，它能确保分布的各个部分（尤其是尾部）在重抽样中得到充分的代表。通过这个编码练习，您将为 Jarzynski 估计量实现一个稳健的不确定性量化方法，学习如何处理重尾数据，并将更复杂的 bootstrap 方法应用于一个真实的分子动力学问题。",
            "id": "3399592",
            "problem": "给定一个非平衡分子动力学 (MD) 的情境，其中自由能差通过 Jarzynski 等式进行估计。其基本基础是来自非平衡统计力学的 Jarzynski 等式。该等式指出，对于一个初始在温度 $T$ 下处于平衡态的系统，两个状态之间的自由能差 $\\Delta G$ 可以通过在切换过程中所做的非平衡功 $W$ 的重复实现得到，具体如下：\n$$\n\\Delta G = - k_{\\mathrm{B}} T \\ln \\left\\langle e^{-\\beta W} \\right\\rangle,\n$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度，$\\beta = \\frac{1}{k_{\\mathrm{B}} T}$，尖括号表示对独立实现的系综平均，$W$ 是沿每条轨迹所做的功。经验估计量使用从分子动力学轨迹中获得的独立功值的有限样本 $\\{W_i\\}_{i=1}^N$。由于指数权重 $e^{-\\beta W}$ 的存在，稀有的低功事件可能会主导估计值，从而产生重尾行为和巨大的不确定性。目标是使用分层自助法 (stratified bootstrap) 来量化这种不确定性，该方法在功分布的由分位数定义的层内进行重采样，以稳定重尾部分的贡献。\n\n从上述基本原理和非参数自助重采样 (nonparametric bootstrap resampling) 的定义出发，设计一个算法，该算法能够：\n- 使用样本分位数或秩，将样本 $\\{W_i\\}_{i=1}^N$ 划分为 $S$ 个频率大致相等的层，以构建一个基于 $W$ 分位数的分层自助法。\n- 通过在每个层内进行有放回的抽样生成 $B$ 个自助法复制样本，并保持原始层的大小，然后对每个复制样本使用重采样的数据计算 Jarzynski 估计量 $\\widehat{\\Delta G}$。\n- 报告来自原始数据的点估计 $\\widehat{\\Delta G}$、自助法标准误 $\\sigma_{\\mathrm{boot}}$，以及一个基于置信水平为 $95\\%$ 的百分位数法的双侧置信区间 $[\\mathrm{CI}_{\\mathrm{low}}, \\mathrm{CI}_{\\mathrm{high}}]$（即，位于 $2.5$ 和 $97.5$ 的下和上经验分位数，以小数而非百分比形式表示）。\n\n在为重尾数据计算 $\\ln \\left\\langle e^{-\\beta W} \\right\\rangle$ 时，要求具备数值稳定性。您的算法必须实现一个能够避免上溢和下溢的稳定计算，例如通过使用 log-sum-exp 恒等式。\n\n所有能量单位均以焦耳 $\\mathrm{J}$ 表示。温度必须以开尔文 $\\mathrm{K}$ 为单位。不涉及角度。所使用的玻尔兹曼常数为 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J}/\\mathrm{K}$。为保证可复现性，请将伪随机数生成器的种子设置为 $123$。\n\n测试套件。您的程序必须从一个科学上合理的混合模型中生成合成的功数据 $\\{W_i\\}$，该模型模仿在非平衡 MD 拉伸实验中观察到的重尾行为，其中 $W$是从两个正态分布的混合分布中独立抽样的：\n- 以概率 $p$，$W$ 从均值为 $\\mu_{\\mathrm{main}}$、标准差为 $\\sigma_{\\mathrm{main}}$ 的正态分布中抽取。\n- 以概率 $1-p$，$W$ 从均值为 $\\mu_{\\mathrm{tail}}$、标准差为 $\\sigma_{\\mathrm{tail}}$ 的正态分布中抽取。\n为了保持物理尺度，以 $k_{\\mathrm{B}} T$ 为单位对均值和标准差进行参数化，即设置 $\\mu_{\\mathrm{main}} = c_{\\mu,\\mathrm{main}}\\,k_{\\mathrm{B}}T$, $\\sigma_{\\mathrm{main}} = c_{\\sigma,\\mathrm{main}}\\,k_{\\mathrm{B}}T$, $\\mu_{\\mathrm{tail}} = c_{\\mu,\\mathrm{tail}}\\,k_{\\mathrm{B}}T$, 以及 $\\sigma_{\\mathrm{tail}} = c_{\\sigma,\\mathrm{tail}}\\,k_{\\mathrm{B}}T$，然后转换为焦耳。令 $N$ 表示样本大小，$S$ 表示分层数，$B$ 表示自助法复制样本数。使用以下三个测试用例，它们分别涵盖典型情况、小样本情况和极端重尾情况：\n\n- 案例 1 (典型的重尾)：$N = 1000$, $T = 300\\,\\mathrm{K}$, $p = 0.95$, $c_{\\mu,\\mathrm{main}} = 10$, $c_{\\sigma,\\mathrm{main}} = 3$, $c_{\\mu,\\mathrm{tail}} = -5$, $c_{\\sigma,\\mathrm{tail}} = 2$, $S = 10$, $B = 1000$。\n- 案例 2 (小样本，更重的尾部)：$N = 200$, $T = 300\\,\\mathrm{K}$, $p = 0.90$, $c_{\\mu,\\mathrm{main}} = 6$, $c_{\\sigma,\\mathrm{main}} = 2$, $c_{\\mu,\\mathrm{tail}} = -8$, $c_{\\sigma,\\mathrm{tail}} = 3$, $S = 8$, $B = 1500$。\n- 案例 3 (稀有但极端的负功事件)：$N = 1000$, $T = 300\\,\\mathrm{K}$, $p = 0.98$, $c_{\\mu,\\mathrm{main}} = 12$, $c_{\\sigma,\\mathrm{main}} = 2$, $c_{\\mu,\\mathrm{tail}} = -20$, $c_{\\sigma,\\mathrm{tail}} = 5$, $S = 10$, $B = 1000$。\n\n您的程序必须：\n- 对每个案例，使用上面定义的混合模型生成 $\\{W_i\\}$。\n- 以 $\\mathrm{J}$ 为单位，计算点估计 $\\widehat{\\Delta G}$、自助法标准误 $\\sigma_{\\mathrm{boot}}$ 以及百分位数置信区间的端点 $\\mathrm{CI}_{\\mathrm{low}}$ 和 $\\mathrm{CI}_{\\mathrm{high}}$。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个案例的结果为列表 $[\\widehat{\\Delta G},\\sigma_{\\mathrm{boot}},\\mathrm{CI}_{\\mathrm{low}},\\mathrm{CI}_{\\mathrm{high}}]$。所有数字必须以科学记数法打印，保留六位有效数字，并以 $\\mathrm{J}$ 为单位。例如，输出格式必须为 $[[x_1,y_1,z_1,w_1],[x_2,y_2,z_2,w_2],[x_3,y_3,z_3,w_3]]$ 的形式，其中每个 $x_i$、$y_i$、$z_i$、$w_i$ 都是科学记数法表示的浮点数。",
            "solution": "该问题要求设计并实现一个算法，以使用 Jarzynski 等式从一组非平衡功值 $\\{W_i\\}$ 中计算自由能差 $\\Delta G$。此任务的核心是使用分层自助法 (stratified bootstrap) 程序为 $\\Delta G$ 估计值提供一个稳健的不确定性量化，该方法特别适用于此类问题中常见的重尾功分布。\n\n基本原理是 Jarzynski 等式：\n$$\n\\Delta G = -k_{\\mathrm{B}} T \\ln \\left\\langle e^{-\\beta W} \\right\\rangle\n$$\n其中 $\\Delta G$ 是 Helmholtz 自由能差，$k_{\\mathrm{B}}$ 是玻尔兹曼常数 ($1.380649 \\times 10^{-23}\\,\\mathrm{J}/\\mathrm{K}$)，$T$ 是绝对温度，$\\beta = (k_{\\mathrm{B}} T)^{-1}$，尖括号 $\\left\\langle \\cdot \\right\\rangle$ 表示对无限个非平衡轨迹的系综平均。在实践中，我们有一个包含 $N$ 个功值的有限样本 $\\{W_i\\}_{i=1}^N$，从而得到经验估计量：\n$$\n\\widehat{\\Delta G} = -k_{\\mathrm{B}} T \\ln \\left( \\frac{1}{N} \\sum_{i=1}^{N} e^{-\\beta W_i} \\right)\n$$\n一个巨大的挑战来自于指数权重项 $e^{-\\beta W}$。具有小功值或负功值的轨迹，虽然稀有，但可能对总和做出不成比例的贡献，导致估计量被少数事件主导并表现出高方差。这使得估计值在数值上不稳定，其不确定性也难以评估。\n\n在求和中减轻数值上溢的一个标准技巧是 log-sum-exp 恒等式。我们可以将估计量重写为更稳定的形式。令 $W_{\\min} = \\min_{i} \\{W_i\\}$。对数的参数变为：\n$$\n\\frac{1}{N} \\sum_{i=1}^{N} e^{-\\beta W_i} = \\frac{1}{N} \\sum_{i=1}^{N} e^{-\\beta (W_i - W_{\\min} + W_{\\min})} = \\frac{e^{-\\beta W_{\\min}}}{N} \\sum_{i=1}^{N} e^{-\\beta (W_i - W_{\\min})}\n$$\n将其代回到 $\\widehat{\\Delta G}$ 的估计量中：\n$$\n\\widehat{\\Delta G} = -k_{\\mathrm{B}} T \\ln \\left( \\frac{e^{-\\beta W_{\\min}}}{N} \\sum_{i=1}^{N} e^{-\\beta (W_i - W_{\\min})} \\right)\n$$\n$$\n\\widehat{\\Delta G} = -k_{\\mathrm{B}} T \\left( -\\beta W_{\\min} + \\ln \\left( \\frac{1}{N} \\sum_{i=1}^{N} e^{-\\beta (W_i - W_{\\min})} \\right) \\right)\n$$\n由于 $\\beta = (k_{\\mathrm{B}} T)^{-1}$，这可以简化为一个数值上稳健的表达式：\n$$\n\\widehat{\\Delta G} = W_{\\min} - k_{\\mathrm{B}} T \\ln \\left( \\frac{1}{N} \\sum_{i=1}^{N} e^{-\\frac{W_i - W_{\\min}}{k_{\\mathrm{B}} T}} \\right)\n$$\n这种形式可以防止浮点数上溢，因为和中最大的指数是 $0$，对应于 $W_i = W_{\\min}$ 的情况。\n\n为了量化不确定性，我们采用分层自助法 (stratified bootstrap) 程序。对于重尾分布，此方法优于简单的自助法，因为它能确保分布的所有部分，包括关键的尾部区域，在每个自助法复制样本中都有代表。该算法流程如下：\n\n1.  **分层**：将包含 $N$ 个功值的原始样本 $\\{W_i\\}$ 按升序排序。然后将排序后的样本划分为 $S$ 个层，每个层包含大约 $N/S$ 个连续的数据点。这种划分确保了最低的功值被隔离在它们自己的层中，从而保证了它们在重采样过程中的代表性。\n\n2.  **重采样**：生成 $B$ 个自助法复制样本。每个复制样本是通过以下过程构建的大小为 $N$ 的新样本：对于每个包含 $n_j$ 个数据点的层 $j$，我们从该层中*有放回地*抽取 $n_j$ 个样本。所有层的重采样数据组合起来形成一个自助法复制样本。这个过程保留了源自原始分布中每个分位数范围的数据点数量。\n\n3.  **估计与分析**：对于 $B$ 个自助法复制样本中的每一个（记为 $\\{W_i^*\\}_{k}$，其中 $k=1, \\dots, B$），使用数值稳定的公式计算 Jarzynski 估计值 $\\widehat{\\Delta G}_k^*$。这会产生一个包含 $B$ 个自助法估计值的集合 $\\{\\widehat{\\Delta G}_k^*\\}_{k=1}^B$。\n    - 自助法标准误 $\\sigma_{\\mathrm{boot}}$ 是这个集合的样本标准差：\n      $$\n      \\sigma_{\\mathrm{boot}} = \\sqrt{\\frac{1}{B-1} \\sum_{k=1}^{B} (\\widehat{\\Delta G}_k^* - \\overline{\\widehat{\\Delta G}^*})^2}\n      $$\n      其中 $\\overline{\\widehat{\\Delta G}^*}$ 是自助法估计值的均值。\n    - 一个 $95\\%$ 百分位数置信区间 $[\\mathrm{CI}_{\\mathrm{low}}, \\mathrm{CI}_{\\mathrm{high}}]$ 是通过找到自助法估计值 $\\{\\widehat{\\Delta G}_k^*\\}$ 排序后分布的第 $2.5$ 和第 $97.5$ 百分位数来构建的。\n\n用于测试此算法的合成功数据是从一个双组分正态混合模型生成的，这是对单分子拉伸实验中功分布的一种合理解释。一个数据点 $W$ 以概率 $p$ 从“主”分布 $\\mathcal{N}(\\mu_{\\mathrm{main}}, \\sigma_{\\mathrm{main}}^2)$ 中抽取，并以概率 $1-p$ 从“尾”分布 $\\mathcal{N}(\\mu_{\\mathrm{tail}}, \\sigma_{\\mathrm{tail}}^2)$ 中抽取。这些分布的参数通过热能 $k_{\\mathrm{B}} T$ 进行缩放，以保持其物理相关性。\n\n最终的算法综合了这些组成部分：它生成指定的合成数据，从完整数据集中计算点估计 $\\widehat{\\Delta G}$，然后执行分层自助法程序以计算 $\\sigma_{\\mathrm{boot}}$ 和置信区间端点 $\\mathrm{CI}_{\\mathrm{low}}$ 和 $\\mathrm{CI}_{\\mathrm{high}}$。所有能量值均以焦耳报告。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    解决 Jarzynski 等式问题，并使用分层自助法进行不确定性量化。\n    \"\"\"\n    \n    # 定义物理常数和随机数生成器\n    K_B = 1.380649e-23  # 玻尔兹曼常数，单位 J/K\n    RNG = np.random.default_rng(123)\n\n    # 根据问题描述定义测试用例\n    test_cases = [\n        # 案例 1 (典型的重尾)\n        {'N': 1000, 'T': 300.0, 'p': 0.95, 'c_mu_main': 10.0, 'c_sigma_main': 3.0, \n         'c_mu_tail': -5.0, 'c_sigma_tail': 2.0, 'S': 10, 'B': 1000},\n        # 案例 2 (小样本，更重的尾部)\n        {'N': 200, 'T': 300.0, 'p': 0.90, 'c_mu_main': 6.0, 'c_sigma_main': 2.0, \n         'c_mu_tail': -8.0, 'c_sigma_tail': 3.0, 'S': 8, 'B': 1500},\n        # 案例 3 (稀有但极端的负功事件)\n        {'N': 1000, 'T': 300.0, 'p': 0.98, 'c_mu_main': 12.0, 'c_sigma_main': 2.0, \n         'c_mu_tail': -20.0, 'c_sigma_tail': 5.0, 'S': 10, 'B': 1000},\n    ]\n\n    results = []\n\n    def jarzynski_estimator(work_values, T):\n        \"\"\"\n        使用数值稳定的 log-sum-exp 公式计算 Jarzynski 自由能估计值。\n        \n        参数:\n            work_values (np.ndarray): 功值的数组，单位为焦耳。\n            T (float): 温度，单位为开尔文。\n        \n        返回:\n            float: 估计的自由能差，单位为焦耳。\n        \"\"\"\n        if len(work_values) == 0:\n            return np.nan\n        \n        kBT = K_B * T\n        beta = 1.0 / kBT\n        \n        w_min = np.min(work_values)\n        \n        # 数值稳定的计算: delta_G = W_min - kBT * log(mean(exp(-beta*(W-W_min))))\n        shifted_exp_terms = np.exp(-beta * (work_values - w_min))\n        mean_of_exponentials = np.mean(shifted_exp_terms)\n        \n        delta_g = w_min - kBT * np.log(mean_of_exponentials)\n        return delta_g\n\n    for case in test_cases:\n        N, T, p, S, B = case['N'], case['T'], case['p'], case['S'], case['B']\n        kBT = K_B * T\n\n        # 从混合模型生成合成功数据\n        # 1. 确定每个分布的样本数量\n        num_main = RNG.binomial(N, p)\n        num_tail = N - num_main\n\n        # 2. 以焦耳为单位定义分布参数\n        mu_main = case['c_mu_main'] * kBT\n        sigma_main = case['c_sigma_main'] * kBT\n        mu_tail = case['c_mu_tail'] * kBT\n        sigma_tail = case['c_sigma_tail'] * kBT\n\n        # 3. 生成样本\n        work_main = RNG.normal(loc=mu_main, scale=sigma_main, size=num_main)\n        work_tail = RNG.normal(loc=mu_tail, scale=sigma_tail, size=num_tail)\n        W = np.concatenate((work_main, work_tail))\n        RNG.shuffle(W)\n\n        # 根据原始数据计算点估计\n        delta_g_hat = jarzynski_estimator(W, T)\n\n        # --- 分层自助法程序 ---\n        \n        # 1. 对数据进行分层\n        W_sorted = np.sort(W)\n        strata = np.array_split(W_sorted, S)\n        \n        # 2. 重采样与估计\n        bootstrap_estimates = np.empty(B)\n        for i in range(B):\n            bootstrap_sample_parts = []\n            for stratum in strata:\n                n_stratum = len(stratum)\n                resampled_part = RNG.choice(stratum, size=n_stratum, replace=True)\n                bootstrap_sample_parts.append(resampled_part)\n            \n            bootstrap_sample = np.concatenate(bootstrap_sample_parts)\n            bootstrap_estimates[i] = jarzynski_estimator(bootstrap_sample, T)\n            \n        # 3. 分析自助法结果\n        # 自助法标准误（样本标准差，ddof=1）\n        sigma_boot = np.std(bootstrap_estimates, ddof=1)\n        \n        # 95% 百分位置信区间\n        ci_low = np.percentile(bootstrap_estimates, 2.5)\n        ci_high = np.percentile(bootstrap_estimates, 97.5)\n        \n        # 存储此案例的结果\n        results.append([delta_g_hat, sigma_boot, ci_low, ci_high])\n\n    # 格式化最终输出字符串\n    output_str = f\"[{','.join([f'[{\",\".join([f\"{v:.6e}\" for v in r])}]' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "从能量涨落计算热容等热力学性质是标准做法，但当这些涨落大到理论方差为无穷大时，我们该怎么办？对于这类重尾分布，标准的 bootstrap 方法会失效，而 $m$-out-of-$n$ bootstrap 则是一个理论上一致的替代方案。本练习将基础统计力学与高等统计方法相结合，要求您首先推导热容公式，然后在标准方法失效时，通过实现 $m$-out-of-$n$ bootstrap 来稳健地估计其不确定性。",
            "id": "3399551",
            "problem": "考虑一个正则系综分子动力学可观测量，其瞬时能量用 $E$ 表示。在正则系综中，$E$ 的分布由玻尔兹曼权重决定，定容热容定义为平均能量对温度的导数。重尾涨落可能会使得对估计量抽样分布的高斯假设失效。您的任务是设计一个程序，在能量样本呈重尾分布时，使用 $m$-out-of-$n$ bootstrap 方法对热容进行不确定性量化。\n\n从以下基础出发：\n- 正则系综的逆温度 $\\beta$ 由 $\\beta = 1/(k_B T)$ 给出，其中 $k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。\n- 配分函数为 $Z(\\beta) = \\sum_E g(E)\\, e^{-\\beta E}$（对于离散 $E$）或类似的积分形式（对于连续 $E$），其中 $g(E)$ 是态密度。\n- 平均能量为 $\\langle E \\rangle = -\\frac{\\partial}{\\partial \\beta}\\ln Z(\\beta)$，其涨落与 $\\ln Z(\\beta)$ 的导数相关。\n\n基于这些，推导出用平衡态能量涨落表示的热容，并实现一个使用有限能量样本的估计量。不要使用任何高斯近似的捷径；您的推理应基于上述正则系综的定义。\n\n合成的重尾能量样本应按如下方式生成。对于给定的样本大小 $n$，定义参数 $E_0$（基准能量偏移）、$\\sigma$（高斯涨落尺度）、$p_{\\mathrm{tail}}$（重尾跳跃概率）、$x_m$（Pareto 尺度）和 $\\nu$（Pareto 形状）。对于每个 $i \\in \\{1,\\dots,n\\}$：\n- 抽取一个高斯涨落 $G_i \\sim \\mathcal{N}(0,\\sigma^2)$。\n- 抽取一个伯努利指示变量 $J_i \\in \\{0,1\\}$，其中 $\\mathbb{P}(J_i=1) = p_{\\mathrm{tail}}$。\n- 抽取一个 Pareto 跳跃 $P_i = x_m \\left(1 + Y_i\\right)$，其中 $Y_i \\sim \\mathrm{Pareto}(\\nu)$，支撑集为 $Y_i \\ge 1$。\n- 通过 $E_i = E_0 + G_i + J_i\\, P_i$ 定义能量样本。\n\n对于每个合成数据集，使用您推导的基于涨落的定义，从大小为 $n$ 的全样本中计算热容估计量，并使用 $m$-out-of-$n$ bootstrap 方法量化其不确定性，其中 $m = \\lfloor n^\\alpha \\rfloor$，$0  \\alpha  1$。在 bootstrap 过程中：\n- 从 $\\{1,\\dots,n\\}$ 中有放回地重抽样 $m$ 个索引。\n- 在重抽样的能量值上计算相同的热容估计量。\n- 重复 $B$ 次 bootstrap 复制，以获得估计量的 bootstrap 分布。\n- 从 bootstrap 分布中，计算 bootstrap 标准误和置信水平为 $0.95$ 的双边百分位数置信区间。\n\n以物理单位报告结果：热容必须以焦耳/开尔文（J/K）表示，bootstrap 标准误必须以焦耳/开尔文（J/K）表示，置信区间的端点也必须以焦耳/开尔文（J/K）表示。温度必须以开尔文（K）表示。不涉及角度。数值输出以十进制浮点数表示。\n\n测试套件。您的程序必须运行以下四个参数集并汇总输出：\n- 情况 1（一般重尾，有限方差）：$n=1000$，$\\alpha=0.7$，$T=300\\,\\mathrm{K}$，$E_0=1.0\\times 10^{-19}\\,\\mathrm{J}$，$\\sigma=2.0\\times 10^{-21}\\,\\mathrm{J}$，$p_{\\mathrm{tail}}=0.02$，$x_m=3.0\\times 10^{-20}\\,\\mathrm{J}$，$\\nu=2.5$，$B=1000$。\n- 情况 2（强重尾，无限方差）：$n=100$，$\\alpha=0.5$，$T=300\\,\\mathrm{K}$，$E_0=8.0\\times 10^{-20}\\,\\mathrm{J}$，$\\sigma=4.0\\times 10^{-21}\\,\\mathrm{J}$，$p_{\\mathrm{tail}}=0.05$，$x_m=1.0\\times 10^{-19}\\,\\mathrm{J}$，$\\nu=1.5$，$B=1000$。\n- 情况 3（大样本，弱重尾）：$n=10000$，$\\alpha=0.9$，$T=300\\,\\mathrm{K}$，$E_0=1.2\\times 10^{-19}\\,\\mathrm{J}$，$\\sigma=2.0\\times 10^{-21}\\,\\mathrm{J}$，$p_{\\mathrm{tail}}=0.01$，$x_m=2.0\\times 10^{-20}\\,\\mathrm{J}$，$\\nu=3.0$，$B=300$。\n- 情况 4（小 $m$ 边界行为）：$n=500$，$\\alpha=0.3$，$T=350\\,\\mathrm{K}$，$E_0=1.0\\times 10^{-19}\\,\\mathrm{J}$，$\\sigma=1.5\\times 10^{-21}\\,\\mathrm{J}$，$p_{\\mathrm{tail}}=0.03$，$x_m=5.0\\times 10^{-20}\\,\\mathrm{J}$，$\\nu=2.0$，$B=1000$。\n\n将玻尔兹曼常数取为 $k_B = 1.380649\\times 10^{-23}\\,\\mathrm{J}/\\mathrm{K}$。为每种情况使用固定的、可复现的伪随机种子，以使结果具有确定性。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表由四个四元组列表组成，每个对应一种情况，每个内部列表包含全样本热容估计值、bootstrap 标准误以及置信水平为 $0.95$ 的双边百分位数置信区间的下限和上限。输出必须包含在方括号中且不含空格，例如：$[[c_1,s_1,\\ell_1,u_1],[c_2,s_2,\\ell_2,u_2],[c_3,s_3,\\ell_3,u_3],[c_4,s_4,\\ell_4,u_4]]$，其中 $c_i, s_i, \\ell_i, u_i$ 是情况 $i$ 的十进制浮点数，单位为 $\\mathrm{J}/\\mathrm{K}$。",
            "solution": "该问题要求设计一个程序，用于从正则系综中抽取的有限能量样本来估计定容热容 $C_V$，并使用 $m$-out-of-$n$ bootstrap 方法量化此估计的不确定性。能量样本由一个表现出重尾分布的合成模型生成。解决方案分为四个部分：首先，从统计力学原理推导热容公式；其次，构建基于有限样本的估计量；第三，描述合成数据的生成过程；第四，详细阐述用于不确定性量化的 $m$-out-of-$n$ bootstrap 程序。\n\n**1. 热容公式的推导**\n\n定容热容 $C_V$ 定义为平均能量 $\\langle E \\rangle$ 在定容 $V$ 条件下对温度 $T$ 的偏导数：\n$$\nC_V = \\left( \\frac{\\partial \\langle E \\rangle}{\\partial T} \\right)_V\n$$\n在正则系综中，使用逆温度 $\\beta = 1/(k_B T)$ 更为方便，其中 $k_B$ 是玻尔兹曼常数。使用链式法则，我们可以将对 $T$ 的导数用对 $\\beta$ 的导数表示：\n$$\n\\frac{\\partial}{\\partial T} = \\frac{d\\beta}{dT} \\frac{\\partial}{\\partial \\beta} = \\left( -\\frac{1}{k_B T^2} \\right) \\frac{\\partial}{\\partial \\beta} = -k_B \\beta^2 \\frac{\\partial}{\\partial \\beta}\n$$\n将此代入 $C_V$ 的定义，得到：\n$$\nC_V = -k_B \\beta^2 \\left( \\frac{\\partial \\langle E \\rangle}{\\partial \\beta} \\right)_V\n$$\n平均能量 $\\langle E \\rangle$ 与正则配分函数 $Z(\\beta) = \\sum_i g(E_i) e^{-\\beta E_i}$ 相关，其中 $g(E_i)$ 是能级 $E_i$ 的态密度。该关系由下式给出：\n$$\n\\langle E \\rangle = -\\frac{\\partial}{\\partial \\beta} \\ln Z(\\beta)\n$$\n将此 $\\langle E \\rangle$ 的表达式代入 $C_V$ 的方程，我们得到：\n$$\nC_V = -k_B \\beta^2 \\frac{\\partial}{\\partial \\beta} \\left( -\\frac{\\partial}{\\partial \\beta} \\ln Z(\\beta) \\right) = k_B \\beta^2 \\frac{\\partial^2}{\\partial \\beta^2} \\ln Z(\\beta)\n$$\n为了计算二阶导数，我们首先回顾 $\\frac{\\partial}{\\partial \\beta} \\ln Z(\\beta) = -\\langle E \\rangle$。对此式关于 $\\beta$ 求导，得到：\n$$\n\\frac{\\partial^2}{\\partial \\beta^2} \\ln Z(\\beta) = -\\frac{\\partial \\langle E \\rangle}{\\partial \\beta}\n$$\n平均能量 $\\langle E \\rangle = (\\sum_i E_i e^{-\\beta E_i})/Z$ 对 $\\beta$ 的导数是：\n$$\n\\frac{\\partial \\langle E \\rangle}{\\partial \\beta} = \\frac{(\\sum_i -E_i^2 e^{-\\beta E_i})Z - (\\sum_i E_i e^{-\\beta E_i})(\\sum_j -E_j e^{-\\beta E_j})}{Z^2} = -\\frac{\\langle E^2 \\rangle Z^2}{Z^2} + \\frac{(\\langle E \\rangle Z)^2}{Z^2} = -(\\langle E^2 \\rangle - \\langle E \\rangle^2)\n$$\n项 $\\langle E^2 \\rangle - \\langle E \\rangle^2$ 是能量的方差，记作 $\\sigma_E^2$。因此，我们有：\n$$\n\\frac{\\partial^2}{\\partial \\beta^2} \\ln Z(\\beta) = \\langle E^2 \\rangle - \\langle E \\rangle^2 = \\sigma_E^2\n$$\n最后，将此结果代回我们的 $C_V$ 表达式，我们得到了热容的涨落-耗散公式：\n$$\nC_V = k_B \\beta^2 \\sigma_E^2 = k_B \\left( \\frac{1}{k_B T} \\right)^2 \\sigma_E^2 = \\frac{\\sigma_E^2}{k_B T^2}\n$$\n这个基本结果将宏观热力学性质——热容，与系统能量的微观涨落联系起来。\n\n**2. 有限样本的估计量**\n\n给定一个来自 molecular dynamics 模拟的包含 $n$ 个能量值的有限样本 $\\{E_1, E_2, \\dots, E_n\\}$，我们可以构造一个 $C_V$ 的估计量。我们用基于样本的估计值来代替真实的总体方差 $\\sigma_E^2$。样本方差由下式给出：\n$$\n\\hat{\\sigma}_E^2 = \\frac{1}{n} \\sum_{i=1}^n (E_i - \\bar{E})^2 = \\left(\\frac{1}{n} \\sum_{i=1}^n E_i^2\\right) - \\left(\\frac{1}{n} \\sum_{i=1}^n E_i\\right)^2\n$$\n其中 $\\bar{E} = \\frac{1}{n} \\sum_{i=1}^n E_i$ 是样本均值。因此，热容的估计量 $\\hat{C}_V$ 为：\n$$\n\\hat{C}_{V,n} = \\frac{\\hat{\\sigma}_E^2}{k_B T^2}\n$$\n这是需要从大小为 $n$ 的完整合成数据集中计算的估计量。\n\n**3. 合成重尾能量模型**\n\n问题指定了一个合成数据生成过程，用于模拟包含稀有、大幅值事件的能量涨落，这是重尾分布的特征。对于一个大小为 $n$ 的样本，每个能量值 $E_i$（其中 $i \\in \\{1, \\dots, n\\}$）生成如下：\n$$\nE_i = E_0 + G_i + J_i P_i\n$$\n各组成部分为：\n- $E_0$：一个恒定的基准能量。\n- $G_i$：一个高斯涨落，$G_i \\sim \\mathcal{N}(0, \\sigma^2)$，代表围绕均值的典型热涨落。\n- $J_i$：一个伯努利随机变量，$J_i \\sim \\text{Bernoulli}(p_{\\mathrm{tail}})$，作为重尾事件的指示器。$J_i=1$ 的概率为 $p_{\\mathrm{tail}}$，否则 $J_i=0$。\n- $P_i$：重尾跳跃的幅度。它定义为 $P_i = x_m(1 + Y_i)$，其中 $x_m$ 是一个尺度参数，$Y_i$ 是一个来自 Pareto 分布的随机变量，其形状参数为 $\\nu$，支撑集在 $[1, \\infty)$ 上。一个形状为 $\\nu$、尺度（最小值）为 $1$ 的标准 Pareto 分布具有所需的支撑集。此 Pareto 分布的方差仅在 $\\nu  2$ 时有限。因此，总能量 $E_i$ 的方差仅在 $\\nu  2$ 时有限。这个模型允许在有限和无限方差的条件下测试统计方法。\n\n**4. 用于不确定性量化的 $m$-out-of-$n$ Bootstrap**\n\n当底层数据分布具有重尾，特别是无限方差（即 $\\nu \\le 2$）时，标准的 bootstrap 方法（其中重抽样大小为 $n$）无法对抽样分布产生一致的估计。$m$-out-of-$n$ bootstrap 是一种为处理此类情况而设计的修正方法。它涉及重抽样一个较小的数据点数 $m  n$，其中 $m$ 的选择使其增长速度慢于 $n$（例如，$m = \\lfloor n^\\alpha \\rfloor$，$0  \\alpha  1$）。这种子抽样方法确保了在较弱的矩条件下 bootstrap 近似的相合性。\n\n程序如下：\n1.  从大小为 $n$ 的数据集中计算全样本估计值 $\\hat{C}_{V,n}$。\n2.  将 bootstrap 重抽样大小设置为 $m = \\lfloor n^\\alpha \\rfloor$。\n3.  对于 $B$ 个 bootstrap 复制中的每一个：\n    a. 从原始的 $n$ 个能量值中有放回地抽取一个大小为 $m$ 的样本。这得到一个 bootstrap 样本 $\\{E_1^*, \\dots, E_m^*\\}$。\n    b. 在此 bootstrap 样本上计算热容估计值：$\\hat{C}_{V,m}^* = \\frac{\\text{Var}(\\{E_j^*\\})}{k_B T^2}$。\n4.  这个过程产生了一个包含 $B$ 个估计值的 bootstrap 分布，即 $\\{\\hat{C}_{V,m,1}^*, \\dots, \\hat{C}_{V,m,B}^*\\}$。\n\n从这个 bootstrap 分布中，我们计算标准误和置信区间。公式必须考虑原始估计（大小为 $n$）和 bootstrap 复制（大小为 $m$）之间样本大小的差异。\n\n-   **Bootstrap 标准误：** bootstrap 分布的标准差 $\\text{std}(\\{\\hat{C}_{V,m,i}^*\\})$, 是基于大小为 $m$ 的样本的估计量的标准误的估计。为了估计基于大小为 $n$ 的原始估计量的标准误，需要一个缩放因子。假设估计量的方差按 $1/(\\text{样本大小})$ 缩放，则标准误按 $1/\\sqrt{\\text{sample size}}$ 缩放。因此，$\\hat{C}_{V,n}$ 的估计标准误为：\n    $$\n    \\widehat{\\text{SE}}(\\hat{C}_{V,n}) = \\sqrt{\\frac{m}{n}} \\cdot \\text{std}(\\{\\hat{C}_{V,m,i}^*\\})\n    $$\n\n-   **百分位数置信区间：**直接从 $\\{\\hat{C}_{V,m,i}^*\\}$ 的分位数构建的简单百分位数区间将是不正确的，因为它估计的是基于大小为 $m$ 而非 $n$ 的统计量的区间。一种理论上可靠的 $m$-out-of-$n$ bootstrap 方法是使用经过适当缩放的枢轴量法。枢轴量 $\\sqrt{n}(\\hat{C}_{V,n} - C_V)$ 的分布由 $\\sqrt{m}(\\hat{C}_{V,m}^* - \\hat{C}_{V,n})$ 的 bootstrap 分布来近似。\n    令 $q^*_{p}$ 表示 $\\{\\sqrt{m}(\\hat{C}_{V,m,i}^* - \\hat{C}_{V,n})\\}_{i=1}^B$ 经验分布的第 $p$ 个分位数。则 $C_V$ 的一个 $(1-\\gamma)$ 置信区间由下式给出：\n    $$\n    \\left[ \\hat{C}_{V,n} - \\frac{q^*_{1-\\gamma/2}}{\\sqrt{n}}, \\quad \\hat{C}_{V,n} - \\frac{q^*_{\\gamma/2}}{\\sqrt{n}} \\right]\n    $$\n    对于 $95\\%$ 的置信区间，$\\gamma = 0.05$，因此我们使用中心化和缩放后的 bootstrap 分布的第 $2.5$ 和第 $97.5$ 个百分位数。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import pareto\n\ndef run_case(n, alpha, T, E0, sigma, p_tail, xm, nu, B, seed):\n    \"\"\"\n    为热容估计和不确定性量化运行单个测试用例。\n\n    参数:\n        n (int): 总能量样本数。\n        alpha (float): 用于确定 m-out-of-n 自助法样本大小的指数。\n        T (float): 温度，单位为开尔文。\n        E0 (float): 基准能量偏移，单位为焦耳。\n        sigma (float): 高斯涨落尺度，单位为焦耳。\n        p_tail (float): 重尾跳跃的概率。\n        xm (float): Pareto 跳跃尺度参数，单位为焦耳。\n        nu (float): Pareto 形状参数。\n        B (int): 自助法复制次数。\n        seed (int): 随机数生成器的种子。\n\n    返回:\n        tuple: 一个包含4个元素的元组：\n            - c_v_n (float): 全样本的热容估计值 (J/K)。\n            - se_c_v (float): 估计的自助法标准误 (J/K)。\n            - ci_low (float): 95% 置信区间的下限 (J/K)。\n            - ci_high (float): 95% 置信区间的上限 (J/K)。\n    \"\"\"\n    # 玻尔兹曼常数，单位 J/K\n    K_B = 1.380649e-23\n\n    # 初始化随机数生成器以保证可复现性\n    rng = np.random.default_rng(seed)\n\n    # 1. 生成合成的重尾能量样本\n    gauss_fluct = rng.normal(0.0, sigma, n)\n    jump_indicator = rng.binomial(1, p_tail, n)\n    # scipy.stats.pareto 的 'b' 参数是形状参数 nu。\n    pareto_y = pareto.rvs(b=nu, size=n, random_state=rng)\n    pareto_jump = xm * (1.0 + pareto_y)\n    \n    energies = E0 + gauss_fluct + jump_indicator * pareto_jump\n\n    # 2. 从大小为 n 的全样本计算热容估计量\n    # C_V = Var(E) / (k_B * T^2)\n    var_n = np.var(energies, ddof=0) # 使用总体方差（除以n）\n    c_v_n = var_n / (K_B * T**2)\n    \n    # 3. 执行 m-out-of-n 自助法\n    m = int(np.floor(n**alpha))\n    bootstrap_estimates = np.zeros(B)\n    \n    # 为提高效率，一次性生成所有自助法样本的索引\n    bootstrap_indices = rng.choice(n, size=(B, m), replace=True)\n    \n    # 使用数组操作计算所有自助法样本的方差\n    bootstrap_samples = energies[bootstrap_indices]\n    var_m_star = np.var(bootstrap_samples, axis=1, ddof=0)\n    \n    bootstrap_estimates = var_m_star / (K_B * T**2)\n\n    # 4. 计算自助法标准误和置信区间\n    \n    # 自助法标准误\n    # SE(C_V_n) ≈ sqrt(m/n) * std(C_V_m*)\n    std_bootstrap_dist = np.std(bootstrap_estimates, ddof=1)\n    se_c_v = np.sqrt(m / n) * std_bootstrap_dist\n    \n    # 自助法置信区间（缩放枢轴量法）\n    # C_V 的区间是 [C_V_n - q*_0.975/√n, C_V_n - q*_0.025/√n]\n    # 其中 q* 是 sqrt(m)(C_V_m* - C_V_n) 的分位数\n    scaled_deltas = np.sqrt(m) * (bootstrap_estimates - c_v_n)\n    \n    # 2.5% 和 97.5% 的分位数\n    q_low_star = np.percentile(scaled_deltas, 2.5)\n    q_high_star = np.percentile(scaled_deltas, 97.5)\n    \n    # 置信区间\n    ci_low = c_v_n - q_high_star / np.sqrt(n)\n    ci_high = c_v_n - q_low_star / np.sqrt(n)\n    \n    return c_v_n, se_c_v, ci_low, ci_high\n\ndef solve():\n    \"\"\"\n    主函数，运行所有测试用例并打印结果。\n    \"\"\"\n    test_cases = [\n        # 案例 1：一般重尾，有限方差\n        {'n': 1000, 'alpha': 0.7, 'T': 300.0, 'E0': 1.0e-19, 'sigma': 2.0e-21, \n         'p_tail': 0.02, 'xm': 3.0e-20, 'nu': 2.5, 'B': 1000, 'seed': 0},\n        # 案例 2：强重尾，无限方差\n        {'n': 100, 'alpha': 0.5, 'T': 300.0, 'E0': 8.0e-20, 'sigma': 4.0e-21,\n         'p_tail': 0.05, 'xm': 1.0e-19, 'nu': 1.5, 'B': 1000, 'seed': 1},\n        # 案例 3：大样本，弱重尾\n        {'n': 10000, 'alpha': 0.9, 'T': 300.0, 'E0': 1.2e-19, 'sigma': 2.0e-21,\n         'p_tail': 0.01, 'xm': 2.0e-20, 'nu': 3.0, 'B': 300, 'seed': 2},\n        # 案例 4：小 m 边界行为\n        {'n': 500, 'alpha': 0.3, 'T': 350.0, 'E0': 1.0e-19, 'sigma': 1.5e-21,\n         'p_tail': 0.03, 'xm': 5.0e-20, 'nu': 2.0, 'B': 1000, 'seed': 3}\n    ]\n\n    results_str_list = []\n    for params in test_cases:\n        result = run_case(**params)\n        results_str_list.append(f\"[{result[0]},{result[1]},{result[2]},{result[3]}]\")\n    \n    # 按确切要求的格式进行最终打印\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```"
        }
    ]
}