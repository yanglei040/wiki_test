{
    "hands_on_practices": [
        {
            "introduction": "波动-耗散定理是连接微观涨落与宏观响应的基石。本章的第一个实践将带您直击该定理的核心应用：Green-Kubo关系式。通过这项练习，您将使用理想化的解析模型，亲手计算剪切黏度和热导率等输运系数，从而专注于理解线性响应理论的计算精髓及其适用范围的边界。",
            "id": "3453814",
            "problem": "考虑一个处于约化单位下的均相 Lennard–Jones 流体，其中特征能量 $\\,\\epsilon\\,$、长度 $\\,\\sigma\\,$、质量 $\\,m\\,$ 以及玻尔兹曼常数 $\\,k_{\\mathrm{B}}\\,$ 均设为 $\\,1\\,$。在这些 Lennard-Jones 约化单位中，所有报告的量均为无量纲。给定两个微观通量的平衡时间自相关函数：压力张量的非对角剪切分量 $\\,P_{xy}\\,$ 和热流 $\\,J_{Q}\\,$。令 $\\,C_{P}(t) = \\langle P_{xy}(0) P_{xy}(t)\\rangle/V\\,$ 和 $\\,C_{J}(t) = \\langle J_{Q}(0) J_{Q}(t)\\rangle/V\\,$ 表示单位体积相关函数，其中 $\\,V\\,$ 是体积，$\\,\\langle \\cdot \\rangle\\,$ 表示平衡系综平均。假设线性响应理论在弱驱动极限下成立，并考虑在较大振幅下可能引起非线性响应的非平衡驱动。\n\n您的任务是编写一个完整、可运行的程序，对下面指定的每个测试用例执行以下操作：\n\n- 从涨落-耗散框架和 Green–Kubo 构建出发，通过在一个有限时间窗口上使用收敛的求积法对 $\\,C_{P}(t)\\,$ 和 $\\,C_{J}(t)\\,$ 分别进行时间上的数值积分，来计算线性区中的剪切黏度 $\\,\\eta_{0}\\,$ 和热导率 $\\,\\kappa_{0}\\,$。所选时间窗口应使余项可忽略不计。\n- 对于非平衡驱动振幅 $\\,\\dot{\\gamma}\\,$（剪切速率）和 $\\,|\\nabla T|\\,$（温度梯度大小），通过与各向同性和宇称性一致的弱非线性展开来对有效输运系数 $\\eta(\\dot{\\gamma})$ 和 $\\kappa(|\\nabla T|)$ 进行建模：\n  $$ \\eta_{\\mathrm{eff}}(\\dot{\\gamma}) = \\eta_{0}\\left[1 - a\\left(\\frac{\\dot{\\gamma}}{\\dot{\\gamma}_{c}}\\right)^{2}\\right], \\qquad \\kappa_{\\mathrm{eff}}(|\\nabla T|) = \\kappa_{0}\\left[1 - b\\left(\\frac{|\\nabla T|}{G_{c}}\\right)^{2}\\right], $$\n  其中 $\\,a\\,$、$\\,b\\,$、$\\,\\dot{\\gamma}_{c}\\,$ 和 $\\,G_{c}\\,$ 是与具体用例相关的参数。\n- 通过扫描所提供的振幅列表，找出与 $\\,\\eta_{0}\\,$ 或 $\\,\\kappa_{0}\\,$ 的相对偏差超过 $\\,0.05\\,$（即以小数表示的 $\\,0.05\\,$ 阈值）的最小振幅，从而分别为 $\\eta(\\dot{\\gamma})$ 和 $\\kappa(|\\nabla T|)$ 确定非线性响应的起始点。如果列表中的振幅均未超过该阈值，则将起始振幅定义为 $\\,0.0\\,$。\n- 通过验证在为 $\\,\\dot{\\gamma}\\,$ 和 $\\,|\\nabla T|\\,$ 提供的最小振幅下，相对偏差 $\\,\\left|\\eta_{\\mathrm{eff}}/\\eta_{0} - 1\\right|\\,$ 和 $\\,\\left|\\kappa_{\\mathrm{eff}}/\\kappa_{0} - 1\\right|\\,$ 均小于 $\\,0.01\\,$，来检查线性区中的涨落-耗散一致性。如果两个偏差都满足此界限，则报告布尔值 $\\,\\mathrm{True}\\,$，否则报告 $\\,\\mathrm{False}\\,$。\n\n使用的基本原理：\n- 平衡时间自相关函数和涨落-耗散定理将输运系数与线性响应区中积分后的平衡涨落联系起来。\n- 对于单位体积相关函数，Green–Kubo 表达式为\n  $$ \\eta_{0} = \\frac{1}{k_{\\mathrm{B}} T}\\int_{0}^{\\infty} C_{P}(t)\\,dt, \\qquad \\kappa_{0} = \\frac{1}{k_{\\mathrm{B}} T^{2}}\\int_{0}^{\\infty} C_{J}(t)\\,dt, $$\n  在 Lennard-Jones 约化单位中 $\\,k_{\\mathrm{B}}=1\\,$，$\\,T\\,$ 为温度。\n- 通量的非平衡本构关系为 $\\,\\langle P_{xy}\\rangle = -\\eta(\\dot{\\gamma})\\,\\dot{\\gamma}\\,$ 和 $\\,\\langle J_{Q}\\rangle = -\\kappa(|\\nabla T|)\\,|\\nabla T|\\,$，其中有效系数已如上建模。\n\n数值计算方案：\n- 使用均匀时间步长 $\\Delta t = 10^{-3}$，在 $t \\in [0, t_{\\max}]$ 上进行积分，其中每个测试用例的 $t_{\\max}$ 选为 $\\,C_{P}\\,$ 和 $\\,C_{J}\\,$ 中最大衰减时间参数的 $\\,10\\,$ 倍。在奇数个网格点上使用复合辛普森法则以确保精度。\n- 所有输出必须以 Lennard–Jones 约化单位表示。\n\n测试套件和模型相关函数：\n对于每个测试用例 $\\,i \\in \\{1,2,3\\}\\,$，温度 $\\,T\\,$ 和相关函数规定如下，其参数被约束以实现物理上合理的衰减和振荡：\n\n- 用例 $\\,1\\,$：\n  - 温度： $\\,T = 1.0\\,$。\n  - 剪切应力相关： \n    $$ C_{P}(t) = A_{P1}\\,e^{-t/\\tau_{P1}} + A_{P2}\\,e^{-t/\\tau_{P2}}\\cos(\\omega_{P}\\,t), $$\n    其中 $\\,A_{P1} = 0.5\\,$, $\\,\\tau_{P1} = 0.3\\,$, $\\,A_{P2} = 0.2\\,$, $\\,\\tau_{P2} = 1.5\\,$, $\\,\\omega_{P} = 2.0\\,$。\n  - 热流相关：\n    $$ C_{J}(t) = B_{J1}\\,e^{-t/\\theta_{J1}} + B_{J2}\\,e^{-t/\\theta_{J2}}, $$\n    其中 $\\,B_{J1} = 1.0\\,$, $\\,\\theta_{J1} = 0.2\\,$, $\\,B_{J2} = 0.3\\,$, $\\,\\theta_{J2} = 1.0\\,$。\n  - 非平衡参数： $\\,a = 1.0\\,$, $\\,\\dot{\\gamma}_{c} = 0.02\\,$, $\\,b = 1.0\\,$, $\\,G_{c} = 0.03\\,$。\n\n- 用例 $\\,2\\,$：\n  - 温度： $\\,T = 0.7\\,$。\n  - 剪切应力相关： \n    $$ C_{P}(t) = A_{P1}\\,e^{-t/\\tau_{P1}} + A_{P2}\\,e^{-t/\\tau_{P2}}\\cos(\\omega_{P}\\,t), $$\n    其中 $\\,A_{P1} = 0.8\\,$, $\\,\\tau_{P1} = 0.5\\,$, $\\,A_{P2} = 0.25\\,$, $\\,\\tau_{P2} = 2.5\\,$, $\\,\\omega_{P} = 1.5\\,$。\n  - 热流相关：\n    $$ C_{J}(t) = B_{J1}\\,e^{-t/\\theta_{J1}} + B_{J2}\\,e^{-t/\\theta_{J2}}, $$\n    其中 $\\,B_{J1} = 0.9\\,$, $\\,\\theta_{J1} = 0.3\\,$, $\\,B_{J2} = 0.4\\,$, $\\,\\theta_{J2} = 1.5\\,$。\n  - 非平衡参数： $\\,a = 1.0\\,$, $\\,\\dot{\\gamma}_{c} = 0.015\\,$, $\\,b = 1.0\\,$, $\\,G_{c} = 0.02\\,$。\n\n- 用例 $\\,3\\,$：\n  - 温度： $\\,T = 1.5\\,$。\n  - 剪切应力相关： \n    $$ C_{P}(t) = A_{P1}\\,e^{-t/\\tau_{P1}} + A_{P2}\\,e^{-t/\\tau_{P2}}\\cos(\\omega_{P}\\,t), $$\n    其中 $\\,A_{P1} = 0.4\\,$, $\\,\\tau_{P1} = 0.25\\,$, $\\,A_{P2} = 0.15\\,$, $\\,\\tau_{P2} = 1.0\\,$, $\\,\\omega_{P} = 3.0\\,$。\n  - 热流相关：\n    $$ C_{J}(t) = B_{J1}\\,e^{-t/\\theta_{J1}} + B_{J2}\\,e^{-t/\\theta_{J2}}, $$\n    其中 $\\,B_{J1} = 0.7\\,$, $\\,\\theta_{J1} = 0.15\\,$, $\\,B_{J2} = 0.2\\,$, $\\,\\theta_{J2} = 0.8\\,$。\n  - 非平衡参数： $\\,a = 1.0\\,$, $\\,\\dot{\\gamma}_{c} = 0.04\\,$, $\\,b = 1.0\\,$, $\\,G_{c} = 0.05\\,$。\n\n对于所有用例，使用以下振幅列表评估有效系数：\n- 剪切速率 $\\,\\dot{\\gamma}\\,$: $\\,\\{10^{-4}, 10^{-3}, 5\\times 10^{-3}, 10^{-2}, 5\\times 10^{-2}\\}\\,$。\n- 温度梯度 $\\,|\\nabla T|\\,$: $\\,\\{10^{-4}, 5\\times 10^{-4}, 10^{-3}, 5\\times 10^{-3}, 10^{-2}\\}\\,$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个包含五个元素的列表 $\\,\\left[\\eta_{0},\\kappa_{0},\\dot{\\gamma}_{\\mathrm{onset}},G_{\\mathrm{onset}},\\mathrm{FDT}\\right]\\,$，其中 $\\,\\dot{\\gamma}_{\\mathrm{onset}}\\,$ 和 $\\,G_{\\mathrm{onset}}\\,$ 是已确定的起始振幅，$\\,\\mathrm{FDT}\\,$ 是如上定义的布尔值。例如，整体打印结构应如下所示：$\\,\\big[\\,[\\cdots], [\\cdots], [\\cdots]\\,\\big]\\,$。\n\n所有输出必须以 Lennard–Jones 约化单位（无量纲）表示，并且程序必须是自包含的，不需要外部输入。",
            "solution": "该问题要求根据模型时间自相关函数计算 Lennard-Jones 流体的输运系数，包括线性响应区和弱非线性驱动两种情况。解决方案围绕线性响应理论的原理构建，特别是 Green-Kubo 关系式，并扩展到一个描述非线性行为的唯象模型。任务涉及数值积分、代数操作以及用于测试特定条件的程序逻辑。\n\n解决方案的基础是涨落-耗散定理，该定理将系统对外部扰动的响应与系统在热平衡状态下的统计涨落联系起来。对于输运现象，这种联系由 Green-Kubo 关系式表达。在指定的 Lennard-Jones 约化单位中，玻尔兹曼常数 $k_{\\mathrm{B}}=1$，剪切黏度 $\\eta_{0}$ 和热导率 $\\kappa_{0}$ 由相应微观通量的平衡自相关函数的时间积分给出。压力张量分量 $P_{xy}$ 是与剪切应力相关的通量，热流 $J_Q$ 是热输运的通量。单位体积相关函数表示为 $C_{P}(t) = \\langle P_{xy}(0) P_{xy}(t)\\rangle/V$ 和 $C_{J}(t) = \\langle J_Q(0) J_Q(t)\\rangle/V$。Green-Kubo 关系式为：\n$$ \\eta_{0} = \\frac{1}{T}\\int_{0}^{\\infty} C_{P}(t)\\,dt $$\n$$ \\kappa_{0} = \\frac{1}{T^{2}}\\int_{0}^{\\infty} C_{J}(t)\\,dt $$\n其中 $T$ 是流体的平衡温度。积分遍及所有时间，但在实际计算中，我们在有限区间 $[0, t_{\\max}]$ 上积分，选择此区间的目的是使相关函数衰减到可忽略的值。问题指定，对于每种情况，$t_{\\max}$ 为 $C_P(t)$ 和 $C_J(t)$ 中所有指数项里最长衰减时间常数的 $10$ 倍。这确保了截断误差很小。对于数值积分，在步长为 $\\Delta t = 10^{-3}$ 的均匀时间网格上采用复合辛普森法则。对于此法则，区间数 $N = t_{\\max}/\\Delta t$ 必须为偶数，这等价于奇数个网格点 $N+1$。所有测试用例的指定参数都满足此条件。\n\n首先，对于每个测试用例，我们根据提供的参数定义 $C_P(t)$ 和 $C_J(t)$ 的模型函数。例如，在用例 $1$ 中：\n$$ C_{P}(t) = 0.5\\,e^{-t/0.3} + 0.2\\,e^{-t/1.5}\\cos(2.0\\,t) $$\n$$ C_{J}(t) = 1.0\\,e^{-t/0.2} + 0.3\\,e^{-t/1.0} $$\n接下来，我们确定 $t_{\\max}$。对于用例 $1$，衰减时间常数为 $\\tau_{P1}=0.3$、$\\tau_{P2}=1.5$、$\\theta_{J1}=0.2$ 和 $\\theta_{J2}=1.0$。最大值为 $1.5$，所以 $t_{\\max} = 10 \\times 1.5 = 15.0$。生成一个从 $0$ 到 $t_{\\max}$、间距为 $\\Delta t=10^{-3}$ 的时间数组 $t$。我们在此网格上计算 $C_P(t)$ 和 $C_J(t)$ 的值。然后使用复合辛普森法则计算积分 $\\int_0^{t_{\\max}} C_P(t) dt$ 和 $\\int_0^{t_{\\max}} C_J(t) dt$。最后，使用给定的温度 $T$ 和 Green-Kubo 公式计算 $\\eta_0$ 和 $\\kappa_0$。\n\n其次，我们分析非线性响应。有效输运系数 $\\eta_{\\mathrm{eff}}(\\dot{\\gamma})$ 和 $\\kappa_{\\mathrm{eff}}(|\\nabla T|)$ 通过弱非线性展开进行建模：\n$$ \\eta_{\\mathrm{eff}}(\\dot{\\gamma}) = \\eta_{0}\\left[1 - a\\left(\\frac{\\dot{\\gamma}}{\\dot{\\gamma}_{c}}\\right)^{2}\\right] $$\n$$ \\kappa_{\\mathrm{eff}}(|\\nabla T|) = \\kappa_{0}\\left[1 - b\\left(\\frac{|\\nabla T|}{G_{c}}\\right)^{2}\\right] $$\n与线性响应值的相对偏差，对于黏度是 $|\\eta_{\\mathrm{eff}}/\\eta_0 - 1| = a(\\dot{\\gamma}/\\dot{\\gamma}_c)^2$，对于热导率是 $|\\kappa_{\\mathrm{eff}}/\\kappa_0 - 1| = b(|\\nabla T|/G_c)^2$。我们遍历所提供的按升序排列的驱动振幅列表（$\\dot{\\gamma}$ 和 $|\\nabla T|$）。非线性响应的起始点 $\\dot{\\gamma}_{\\mathrm{onset}}$ 或 $G_{\\mathrm{onset}}$ 被确定为列表中使此相对偏差超过 $0.05$ 阈值的第一个振幅。如果列表中的振幅均未导致偏差超过此阈值，则起始振幅定义为 $0.0$。\n\n第三，我们进行一致性检查。作为 Green-Kubo 关系式来源的线性响应理论，在外部驱动力极小的极限下有效。所提供的非线性模型应在驱动振幅 $\\dot{\\gamma}$ 和 $|\\nabla T|$ 趋于零时收敛到线性响应结果。我们通过计算在所提供列表中最小可用振幅（$\\dot{\\gamma}_{\\min} = 10^{-4}$ 和 $|\\nabla T|_{\\min} = 10^{-4}$）下的相对偏差来验证此一致性。然后我们检查两个偏差 $|\\eta_{\\mathrm{eff}}(\\dot{\\gamma}_{\\min})/\\eta_0 - 1|$ 和 $|\\kappa_{\\mathrm{eff}}(|\\nabla T|_{\\min})/\\kappa_0 - 1|$ 是否都小于更严格的容差 $0.01$。此检查的结果以布尔值形式存储。\n\n对所有三个测试用例重复整个过程，并将每个用例计算出的五个值——$\\eta_0$、$\\kappa_0$、$\\dot{\\gamma}_{\\mathrm{onset}}$、$G_{\\mathrm{onset}}$ 和布尔值的 FDT 一致性检查——收集并格式化为指定的输出结构。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import simpson\n\ndef solve():\n    \"\"\"\n    Solves the thermodynamic fluctuations and response problem for three test cases.\n    \"\"\"\n    \n    # Define parameters for the three test cases\n    test_cases = [\n        {\n            \"case_id\": 1,\n            \"T\": 1.0,\n            \"cp_params\": {\"A_P1\": 0.5, \"tau_P1\": 0.3, \"A_P2\": 0.2, \"tau_P2\": 1.5, \"omega_P\": 2.0},\n            \"cj_params\": {\"B_J1\": 1.0, \"theta_J1\": 0.2, \"B_J2\": 0.3, \"theta_J2\": 1.0},\n            \"nl_params\": {\"a\": 1.0, \"gammadot_c\": 0.02, \"b\": 1.0, \"G_c\": 0.03},\n        },\n        {\n            \"case_id\": 2,\n            \"T\": 0.7,\n            \"cp_params\": {\"A_P1\": 0.8, \"tau_P1\": 0.5, \"A_P2\": 0.25, \"tau_P2\": 2.5, \"omega_P\": 1.5},\n            \"cj_params\": {\"B_J1\": 0.9, \"theta_J1\": 0.3, \"B_J2\": 0.4, \"theta_J2\": 1.5},\n            \"nl_params\": {\"a\": 1.0, \"gammadot_c\": 0.015, \"b\": 1.0, \"G_c\": 0.02},\n        },\n        {\n            \"case_id\": 3,\n            \"T\": 1.5,\n            \"cp_params\": {\"A_P1\": 0.4, \"tau_P1\": 0.25, \"A_P2\": 0.15, \"tau_P2\": 1.0, \"omega_P\": 3.0},\n            \"cj_params\": {\"B_J1\": 0.7, \"theta_J1\": 0.15, \"B_J2\": 0.2, \"theta_J2\": 0.8},\n            \"nl_params\": {\"a\": 1.0, \"gammadot_c\": 0.04, \"b\": 1.0, \"G_c\": 0.05},\n        },\n    ]\n\n    # Amplitude lists for evaluation\n    gammadot_list = [1e-4, 1e-3, 5e-3, 1e-2, 5e-2]\n    gradT_list = [1e-4, 5e-4, 1e-3, 5e-3, 1e-2]\n    \n    dt = 1e-3\n    \n    all_results = []\n\n    for case in test_cases:\n        # Define correlation functions for the current case\n        def C_P(t, p):\n            return p[\"A_P1\"] * np.exp(-t / p[\"tau_P1\"]) + p[\"A_P2\"] * np.exp(-t / p[\"tau_P2\"]) * np.cos(p[\"omega_P\"] * t)\n\n        def C_J(t, p):\n            return p[\"B_J1\"] * np.exp(-t / p[\"theta_J1\"]) + p[\"B_J2\"] * np.exp(-t / p[\"theta_J2\"])\n\n        # Step 1: Compute linear transport coefficients\n        cp_p = case[\"cp_params\"]\n        cj_p = case[\"cj_params\"]\n        \n        # Determine integration limit t_max\n        max_decay_time = max(cp_p[\"tau_P1\"], cp_p[\"tau_P2\"], cj_p[\"theta_J1\"], cj_p[\"theta_J2\"])\n        t_max = 10.0 * max_decay_time\n        \n        # Create time grid for integration\n        num_points = int(t_max / dt) + 1\n        t_grid = np.linspace(0, t_max, num_points)\n        \n        # Evaluate functions on the grid\n        cp_values = C_P(t_grid, cp_p)\n        cj_values = C_J(t_grid, cj_p)\n        \n        # Integrate using composite Simpson's rule\n        integral_cp = simpson(cp_values, t_grid)\n        integral_cj = simpson(cj_values, t_grid)\n        \n        # Calculate eta_0 and kappa_0\n        T = case[\"T\"]\n        eta_0 = (1.0 / T) * integral_cp\n        kappa_0 = (1.0 / (T**2)) * integral_cj\n\n        # Step 2: Identify onset of nonlinear response\n        nl_p = case[\"nl_params\"]\n        \n        # Onset for shear viscosity\n        gammadot_onset = 0.0\n        for gdot in gammadot_list:\n            dev_eta = nl_p['a'] * (gdot / nl_p['gammadot_c'])**2\n            if dev_eta > 0.05:\n                gammadot_onset = gdot\n                break\n        \n        # Onset for thermal conductivity\n        G_onset = 0.0\n        for gT in gradT_list:\n            dev_kappa = nl_p['b'] * (gT / nl_p['G_c'])**2\n            if dev_kappa > 0.05:\n                G_onset = gT\n                break\n\n        # Step 3: Check fluctuation-dissipation consistency\n        gammadot_min = gammadot_list[0]\n        gradT_min = gradT_list[0]\n        \n        dev_eta_min = nl_p['a'] * (gammadot_min / nl_p['gammadot_c'])**2\n        dev_kappa_min = nl_p['b'] * (gradT_min / nl_p['G_c'])**2\n        \n        fdt_check = (dev_eta_min  0.01) and (dev_kappa_min  0.01)\n\n        # Collate results for the current case\n        case_results = [eta_0, kappa_0, gammadot_onset, G_onset, fdt_check]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # We use str() and replace to match the no-space comma-separated format.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了Green-Kubo关系的基本原理后，我们来解决一个分子动力学模拟中的关键实际问题：有限尺寸效应。由于长程流体动力学相互作用的存在，模拟盒子的有限尺寸会对扩散系数等输运性质产生显著影响。这个练习将引导您从一个物理图像出发——即有限盒子尺寸对速度自相关函数（VACF）长时尾巴的截断——来推导这种效应。通过理论推导与数值验证相结合，您将深刻理解模拟参数如何影响物理结果，并学会如何将模拟结果外推至热力学极限。",
            "id": "3453864",
            "problem": "考虑一个在边长为 $L$ 的立方周期性盒子中使用分子动力学模拟的三维平衡流体。自扩散系数 $D$ 通过 Green–Kubo 关系式 $D=\\frac{1}{3}\\int_{0}^{\\infty} C(t)\\,dt$ 与速度自相关函数 (VACF) $C(t)=\\langle \\mathbf{v}(0)\\cdot \\mathbf{v}(t)\\rangle$ 相关。在无限系统中，流体动力学预测 VACF 存在一个长时尾，其大 $t$ 时的渐近形式为 $C(t)\\sim A\\,t^{-3/2}$，其中 $A$ 是一个依赖于热力学和输运参数的正振幅。在有限周期性域中，流体动力学长波模式被离散化：最小的非零波数为 $k_{\\min}=2\\pi/L$，剪切模式以衰减率 $\\nu k^{2}$ 进行扩散衰减，其中 $\\nu$ 是运动粘度。这引入了一个流体动力学时间尺度 $\\tau_{L}\\sim 1/(\\nu k_{\\min}^{2})$，超过该时间尺度，无限系统的渐近尾部便不再贡献。\n\n仅从以下基本原则出发：\n- Green–Kubo 关系式 $D=\\frac{1}{3}\\int_{0}^{\\infty} C(t)\\,dt$。\n- 立方周期性盒子中的有限尺寸流体动力学模式离散化 $k_{\\min}=2\\pi/L$。\n- 剪切模式的扩散衰减率 $\\nu k^{2}$，因此存在一个流体动力学时间尺度 $\\tau_{L}=1/(\\nu k_{\\min}^{2})$。\n- 三维空间中长时间下的渐近 VACF 形式 $C(t)\\sim A\\,t^{-3/2}$。\n\n推导有限系统尺寸 $L$ 如何相对于其无限系统值 $D_{\\infty}$ 来修正测量的扩散系数 $D(L)$。您的推导过程应首先确定长时尾对 $D$ 的贡献，然后解释在 $t\\sim \\tau_{L}$ 处的有限时间截断如何在有限系统中移除了这部分贡献。由此，用 $A$、$\\nu$ 和 $L$ 表示 $D(L)$ 的领头阶有限尺寸修正，并说明其随 $L$ 的标度关系。\n\n然后，实现所推导的表达式，以预测给定参数下的 $D(L)$，并通过对 $D(L)$ 与 $1/L$ 进行线性最小二乘拟合来验证预测的 $1/L$ 标度关系，以恢复斜率和截距。将拟合的斜率大小与您的解析预测进行比较，并将拟合的截距与输入的 $D_{\\infty}$ 进行比较。\n\n数值和算法要求：\n- 对于每个指定的参数集 $\\{D_{\\infty}, \\nu, A, \\{L_{i}\\}\\}$，使用您推导的领头阶有限尺寸修正表达式计算 $D(L_{i})$ 的值。\n- 对于每个参数集，对所提供的列表 $\\{L_{i}\\}$ 上的 $D(L)$ 与 $1/L$ 进行线性回归，报告以下两者之间的绝对差值：\n  1. 拟合斜率的大小与您的解析斜率预测，以 $\\mathrm{m^{3}/s}$ 表示。\n  2. 拟合截距与输入的 $D_{\\infty}$，以 $\\mathrm{m^{2}/s}$ 表示。\n- 所有计算出的扩散系数 $D(L)$ 必须以 $\\mathrm{m^{2}/s}$ 为单位报告。\n- 所有输出必须四舍五入到 $12$ 位有效数字。\n- 此问题不使用角度；无需指定角度单位。\n\n测试套件：\n使用以下三个参数集全面测试您的实现。所有量均采用国际单位制 (SI)。\n- 案例 1 (正常路径)：\n  - $D_{\\infty}=2.3\\times 10^{-9}\\,\\mathrm{m^{2}/s}$，\n  - $\\nu=1.0\\times 10^{-6}\\,\\mathrm{m^{2}/s}$，\n  - $A=6.2\\times 10^{-17}\\,\\mathrm{m^{2}\\,s^{-1/2}}$，\n  - $L\\in\\{5.0\\times 10^{-8}\\,\\mathrm{m},\\,1.0\\times 10^{-7}\\,\\mathrm{m},\\,2.0\\times 10^{-7}\\,\\mathrm{m}\\}$。\n- 案例 2 (不同输运机制)：\n  - $D_{\\infty}=1.0\\times 10^{-9}\\,\\mathrm{m^{2}/s}$，\n  - $\\nu=5.0\\times 10^{-7}\\,\\mathrm{m^{2}/s}$，\n  - $A=1.0\\times 10^{-16}\\,\\mathrm{m^{2}\\,s^{-1/2}}$，\n  - $L\\in\\{1.0\\times 10^{-7}\\,\\mathrm{m},\\,3.0\\times 10^{-7}\\,\\mathrm{m},\\,1.0\\times 10^{-6}\\,\\mathrm{m}\\}$。\n- 案例 3 (无尾部的边缘情况)：\n  - $D_{\\infty}=1.0\\times 10^{-9}\\,\\mathrm{m^{2}/s}$，\n  - $\\nu=1.0\\times 10^{-6}\\,\\mathrm{m^{2}/s}$，\n  - $A=0.0\\,\\mathrm{m^{2}\\,s^{-1/2}}$，\n  - $L\\in\\{1.0\\times 10^{-7}\\,\\mathrm{m},\\,2.0\\times 10^{-7}\\,\\mathrm{m}\\}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n- 对于每个案例，按顺序附加：所列 $L_{i}$ 的 $D(L_{i})$ 值（每个值以 $\\mathrm{m^{2}/s}$ 为单位，四舍五入到 $12$ 位有效数字），然后是该案例的两个验证指标：\n  1. 拟合斜率大小与解析斜率预测之间的绝对误差（以 $\\mathrm{m^{3}/s}$ 为单位，四舍五入到 $12$ 位有效数字）。\n  2. 拟合截距与 $D_{\\infty}$ 之间的绝对误差（以 $\\mathrm{m^{2}/s}$ 为单位，四舍五入到 $12$ 位有效数字）。\n- 将案例 1、案例 2、然后案例 3 的结果连接成一个单一的扁平列表。例如，输出应具有形式 $[D(L_{1}^{(1)}),D(L_{2}^{(1)}),\\dots,\\text{slope\\_err}^{(1)},\\text{intercept\\_err}^{(1)},D(L_{1}^{(2)}),\\dots]$，其中上标表示案例索引。",
            "solution": "用户希望推导分子动力学模拟中自扩散系数的领头阶有限尺寸修正，然后实现一个对所推导公式的数值测试。\n\n### 步骤 1：提取已知条件\n- 扩散系数 $D$ 的 Green-Kubo 关系式：$D=\\frac{1}{3}\\int_{0}^{\\infty} C(t)\\,dt$，其中 $C(t)=\\langle \\mathbf{v}(0)\\cdot \\mathbf{v}(t)\\rangle$ 是速度自相关函数 (VACF)。\n- 模拟域：边长为 $L$ 的立方周期性盒子。\n- 有限域中的最小非零波数：$k_{\\min}=2\\pi/L$。\n- 剪切模式的衰减率：$\\nu k^{2}$，其中 $\\nu$ 是运动粘度。\n- 有限系统的流体动力学时间尺度：$\\tau_{L}=1/(\\nu k_{\\min}^{2})$。\n- $3$D 无限系统中大 $t$ 时 VACF 的渐近形式：$C(t)\\sim A\\,t^{-3/2}$，其中 $A$ 是一个正振幅。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题牢固地基于统计力学和凝聚态物理的既定原理。Green-Kubo 关系、VACF 中的流体动力学长时尾概念（由 Alder 和 Wainwright 发现的效应），以及通过波矢离散化处理有限尺寸效应的标准方法，都是该领域的基石。前提是科学合理的。\n- **适定性**：该问题是适定的。它要求推导一个特定的物理关系，然后使用提供的参数进行数值验证。输入是充分的，要求的输出被明确指定，从而导出一个唯一且有意义的解。\n- **客观性**：该问题以精确、客观的语言陈述，没有任何主观或基于意见的主张。所有量都经过了正式定义。\n\n该问题没有表现出指令中列出的任何无效性缺陷。它不是科学上不合理、不可形式化、不完整、矛盾、不切实际、不适定、琐碎或不可验证的。\n\n### 步骤 3：结论与行动\n问题是有效的。将提供一个完整的、有理有据的解。\n\n### 推导与求解\n任务是推导有限系统尺寸 $L$ 如何影响测量的扩散系数 $D(L)$，并与其无限系统对应值 $D_{\\infty}$ 进行比较。\n\n扩散系数 $D$ 由三维中的 Green-Kubo 关系式给出：\n$$D = \\frac{1}{3} \\int_{0}^{\\infty} C(t) \\, dt$$\n在无限系统中 ($L \\to \\infty$)，该积分得到真实的扩散系数 $D_{\\infty}$。\n\n问题指出，在长时间下，VACF 以幂律形式衰减，这种现象被称为“长时尾”：\n$$C(t) \\sim A t^{-3/2} \\quad (\\text{对于大 } t)$$\n完整值 $D_{\\infty}$ 包括该尾部积分到无穷大的贡献。\n\n在一个尺寸为 $L$ 的有限周期系统中，流体动力学模式的连续谱被一组离散的波矢所取代。最小的非零波数是 $k_{\\min} = 2\\pi/L$。长时尾源于粒子运动与流体中缓慢衰减的剪切模式的耦合。在有限盒子中，最慢衰减的模式对应于 $k_{\\min}$。该模式的衰减率为 $\\gamma = \\nu k_{\\min}^2$，其中 $\\nu$ 是运动粘度。这引入了一个有限系统的流体动力学时间尺度 $\\tau_L = 1/\\gamma$，超过该时间尺度，导致 $t^{-3/2}$ 尾部的集体模式被有效截断。\n让我们用 $L$ 和 $\\nu$ 来表示 $\\tau_L$：\n$$\\tau_L = \\frac{1}{\\nu k_{\\min}^2} = \\frac{1}{\\nu \\left(\\frac{2\\pi}{L}\\right)^2} = \\frac{L^2}{4\\pi^2\\nu}$$\n在有限系统中测量的扩散系数 $D(L)$ 是通过将 VACF 积分到这个截断时间 $\\tau_L$ 的量级得到的。$D_{\\infty}$ 和 $D(L)$ 之间的差异是长时尾积分中“缺失”的部分。\n$$D_{\\infty} - D(L) = \\frac{1}{3} \\int_{\\tau_L}^{\\infty} C(t) \\, dt$$\n我们可以使用 $C(t)$ 的渐近形式来近似这个差异：\n$$D_{\\infty} - D(L) \\approx \\frac{1}{3} \\int_{\\tau_L}^{\\infty} A t^{-3/2} \\, dt$$\n计算定积分：\n$$\\int t^{-3/2} \\, dt = \\frac{t^{-1/2}}{-1/2} = -2 t^{-1/2}$$\n$$ \\int_{\\tau_L}^{\\infty} A t^{-3/2} \\, dt = A \\left[ -2t^{-1/2} \\right]_{\\tau_L}^{\\infty} = A \\left( \\lim_{t\\to\\infty}(-2t^{-1/2}) - (-2\\tau_L^{-1/2}) \\right) = A(0 + 2\\tau_L^{-1/2}) = 2A\\tau_L^{-1/2} $$\n将此结果代回，我们得到有限尺寸修正：\n$$D_{\\infty} - D(L) = \\frac{1}{3} (2A\\tau_L^{-1/2}) = \\frac{2A}{3\\sqrt{\\tau_L}}$$\n现在，我们代入 $\\tau_L$ 的表达式：\n$$D_{\\infty} - D(L) = \\frac{2A}{3\\sqrt{\\frac{L^2}{4\\pi^2\\nu}}} = \\frac{2A}{3 \\left( \\frac{L}{2\\pi\\sqrt{\\nu}} \\right)} = \\frac{4\\pi A \\sqrt{\\nu}}{3L}$$\n这个方程量化了领头阶的有限尺寸效应。通过重新整理，我们得到 $D(L)$ 的表达式：\n$$D(L) = D_{\\infty} - \\frac{4\\pi A \\sqrt{\\nu}}{3L}$$\n这个结果证实了扩散系数的领头阶修正与 $1/L$ 成标度关系。当 $D(L)$ 对 $1/L$ 作图时，关系是线性的：\n$$D(L) = m \\cdot \\left(\\frac{1}{L}\\right) + c$$\n对于截距 $c$ 的解析预测是 $D_{\\infty}$，对于斜率 $m$ 的解析预测是：\n$$m = S_{\\text{analytic}} = -\\frac{4\\pi A \\sqrt{\\nu}}{3}$$\n因此，解析斜率的大小为 $|S_{\\text{analytic}}| = \\frac{4\\pi A \\sqrt{\\nu}}{3}$。\n\n任务的数值部分包括：\n1.  使用推导出的公式 $D(L) = D_{\\infty} - (|S_{\\text{analytic}}|/L)$ 来计算几个 $L_i$ 对应的 $D(L_i)$。\n2.  对生成的数据点 $(1/L_i, D(L_i))$ 进行线性回归，以获得拟合斜率 $S_{\\text{fit}}$ 和拟合截距 $c_{\\text{fit}}$。\n3.  计算拟合斜率大小与解析预测之间的绝对误差：$|\\,|S_{\\text{fit}}| - |S_{\\text{analytic}}|\\,|$。\n4.  计算拟合截距与已知输入之间的绝对误差：$|c_{\\text{fit}} - D_{\\infty}|$。\n由于用于回归的数据点是直接从线性模型生成的，拟合应该是精确的，两个误差指标都应为零（在浮点精度范围内）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Derives and applies the finite-size correction for the self-diffusion coefficient\n    in molecular dynamics simulations, and validates the result via linear regression.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # All quantities are in SI units.\n    test_cases = [\n        {\n            \"D_inf\": 2.3e-9,  # m^2/s\n            \"nu\": 1.0e-6,   # m^2/s\n            \"A\": 6.2e-17,   # m^2*s^(-1/2)\n            \"L_values\": [5.0e-8, 1.0e-7, 2.0e-7],  # m\n        },\n        {\n            \"D_inf\": 1.0e-9,\n            \"nu\": 5.0e-7,\n            \"A\": 1.0e-16,\n            \"L_values\": [1.0e-7, 3.0e-7, 1.0e-6],\n        },\n        {\n            \"D_inf\": 1.0e-9,\n            \"nu\": 1.0e-6,\n            \"A\": 0.0,\n            \"L_values\": [1.0e-7, 2.0e-7],\n        },\n    ]\n\n    results = []\n    \n    # Custom formatter for 12 significant figures\n    def format_num(n):\n        return f\"{n:.12g}\"\n\n    for case in test_cases:\n        D_inf = case[\"D_inf\"]\n        nu = case[\"nu\"]\n        A = case[\"A\"]\n        L_values = case[\"L_values\"]\n\n        # 1. Calculate the magnitude of the analytic slope from the derived formula.\n        # The relationship is D(L) = D_inf - C/L, where C is the slope magnitude.\n        # C = (4 * pi * A * sqrt(nu)) / 3\n        analytic_slope_magnitude = (4 * np.pi * A * np.sqrt(nu)) / 3\n\n        x_reg = []  # will store 1/L values\n        y_reg = []  # will store D(L) values\n\n        # 2. Compute D(L) for each L and prepare data for regression\n        for L in L_values:\n            # The derived formula for D(L) is D_inf - (analytic_slope_magnitude) * (1/L)\n            d_l = D_inf - analytic_slope_magnitude / L\n            results.append(d_l)\n            \n            x_reg.append(1.0 / L)\n            y_reg.append(d_l)\n\n        # 3. Perform linear regression of D(L) vs 1/L\n        # Convert to numpy arrays for scipy\n        x_reg_np = np.array(x_reg)\n        y_reg_np = np.array(y_reg)\n        \n        # linregress will return a perfect fit since the data is generated from the model\n        fit_result = linregress(x_reg_np, y_reg_np)\n        fitted_slope = fit_result.slope\n        fitted_intercept = fit_result.intercept\n\n        # 4. Calculate the error metrics\n        # Abs difference between fitted slope magnitude and analytic slope magnitude\n        slope_error = abs(abs(fitted_slope) - analytic_slope_magnitude)\n        \n        # Abs difference between fitted intercept and D_inf\n        intercept_error = abs(fitted_intercept - D_inf)\n\n        results.append(slope_error)\n        results.append(intercept_error)\n\n    # 5. Final print statement in the exact required format.\n    formatted_results = [format_num(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在拥挤的细胞环境等复杂系统中，粒子的扩散行为常常偏离简单的布朗运动，表现出长程记忆效应。这种“反常”扩散现象直接体现在速度自相关函数的长时幂律衰减行为中，即所谓的“长时尾”。这个练习将挑战您构建一个包含这种记忆效应的动力学模型，并以此探讨遍历性破缺和记忆效应对输运系数计算的实际影响，从而弥合理论公式与复杂模拟数据分析之间的鸿沟。",
            "id": "3453827",
            "problem": "考虑一个在连续时间内演化的单个扩散粒子，其速度过程受到拥挤诱导的记忆效应的影响。其背景为分子动力学，重点关注热力学涨落和响应。目标是使用两种途径估计扩散系数，检验时间平均和系综平均之间的差异，并量化该差异中由速度自相关函数的长时尾所贡献的比例。推导必须从基本定义开始，不得使用简便公式。\n\n您必须实现一个程序，该程序使用与平稳高斯统计和拥挤诱导记忆效应一致的离散化微观动力学模型，在三维空间中构建合成轨迹。每条轨迹的速度必须由两个统计上独立的部分组成：一个基线的、指数弛豫的贡献，以及一个通过将白噪声序列与幂律记忆核进行卷积而产生的拥挤诱导相关贡献。位置必须通过对速度进行时间积分得到。所有量必须以国际单位制（SI）表示，最终的扩散系数必须以平方米/秒为单位报告。不涉及角度。结果必须是浮点数。\n\n程序必须根据这些轨迹为每个测试用例计算以下内容：\n1. 基于对单个速度分量的时间相关函数在有限时间内积分的估计值。此方法使用标准的平衡态时间相关定义来估计与线性响应相关的系数，但积分在最大延迟处被截断，以避免循环卷绕伪影。\n2. 第一个估计值的尾部校正版本，通过将速度自相关的长时衰减拟合为幂律，并使用拟合的尾部解析地将积分延拓到截断时间之外得到。\n3. 基于长时间下系综平均均方根位移的斜率的估计值，该斜率除以两倍的空间维度，这是从位移方差的增长中获得标量扩散系数所必需的。\n4. 基于单条轨迹在长时间下的时间平均均方根位移的斜率的估计值，该斜率除以两倍的空间维度。\n5. 一个介于零和一之间的标量，用于量化系综平均和时间平均估计值之间的差异中，可由积分中截断时间之外的长时尾所缺失的贡献来解释的部分。该分数定义为解析延拓的尾部贡献的量值除以系综平均和时间平均扩散估计值之间的绝对差，如果结果超过1，则截断为1。\n\n您必须通过使用物理上合理的参数，并基于平稳性和遍历性论证实现数值上稳定且无偏的估计量，来确保科学真实性。具体而言，在频域中使用卷积定理计算相关函数，并将所有积分和拟合限制在循环卷积不会损害估计值的延迟时间内。模拟必须在没有任何外部文件或输入的情况下执行。\n\n使用以下测试套件，其中每个测试集都是一个参数元组：\n- 轨迹数 $M$，时间步数 $N$，时间步长 $dt$（单位：秒），空间维度 $d$，基线弛豫率 $\\gamma$（单位：1/秒），每个分量的平稳速度方差 $v_{\\mathrm{var}}$（单位：$(\\mathrm{m}/\\mathrm{s})^2$），拥挤强度 $a_{\\mathrm{tail}}$（单位：$\\mathrm{m}/\\mathrm{s}$），幂律核指数参数 $\\beta$（无量纲），以及核长度 $L$（整数）：\n1. $(10,16384,10^{-12},3,10^{12},10^{3},0.5,1.25,2048)$\n2. $(10,16384,10^{-12},3,10^{12},10^{3},1.0,1.25,2048)$\n3. $(10,16384,10^{-12},3,10^{12},10^{3},0.0,1.25,2048)$\n\n您的程序必须：\n- 在 $d$ 维空间中生成 $M$ 条独立的速度轨迹，方法是求和一个指数相关的基线分量和一个拥挤诱导分量。后者通过将白噪声与一个有限长度的核进行卷积来构建，该核的系数对于 $n=0,\\ldots,L-1$ 满足 $(n+1)^{-\\beta}$ 的比例关系，并进行归一化，以使卷积输出在通过 $a_{\\mathrm{tail}}$ 缩放前具有单位方差。\n- 通过前向欧拉法对速度进行时间积分以获得位置。\n- 计算系综平均均方根位移，即对各轨迹相对于原点的位移范数的平方进行平均；并通过对时间原点进行循环平均来计算单条轨迹的时间平均均方根位移。\n- 对每条轨迹和每个分量，通过卷积定理计算速度自相关函数，然后对所有轨迹和分量进行平均，并将其积分到总时间的一半，以避免循环伪影。\n- 将平均速度自相关函数的正值长时尾（在 $10/\\gamma$ 之后）拟合为时间的幂律，并解析地估计截断时间之后的剩余积分；将此剩余值相加得到尾部校正的估计值。\n- 通过对可用延迟窗口的后半部分进行线性回归，提取两种均方根位移变体的长时斜率，并通过除以 $2d$ 将其转换为扩散系数。\n- 为每个测试用例返回上述指定的五个值。所有扩散系数必须以 $\\mathrm{m}^2/\\mathrm{s}$ 为单位作为浮点数报告。该分数必须作为 $[0,1]$ 范围内的浮点数报告。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例对应一个包含五个浮点数的子列表，顺序如上所述，不含空格。例如，输出格式必须为 `[[x1,x2,x3,x4,x5],[y1,y2,y3,y4,y5],[z1,z2,z3,z4,z5]]`，所有数字均为十进制或科学计数法。不得打印任何其他文本。",
            "solution": "分子动力学中扩散的基本基础是，将位置定义为速度的时间积分，并通过平稳相关函数来表征热涨落。设粒子在 $d$ 维空间中的位置为 $\\mathbf{r}(t)$，速度为 $\\mathbf{v}(t)=\\dot{\\mathbf{r}}(t)$。系综均方根位移定义为 $\\mathrm{MSD}(t)=\\left\\langle\\lVert \\mathbf{r}(t)-\\mathbf{r}(0)\\rVert^2\\right\\rangle$，其中尖括号表示在平衡态下对实现进行系综平均。对于任何均值为零且分量自相关为 $C(t)=\\left\\langle v_x(0)v_x(t)\\right\\rangle$ 的平稳速度过程，我们使用恒等式\n$$\n\\mathbf{r}(t)-\\mathbf{r}(0)=\\int_0^t \\mathbf{v}(\\tau)\\, \\mathrm{d}\\tau,\n$$\n因此\n$$\n\\mathrm{MSD}(t)=2d\\int_0^t (t-\\tau) C(\\tau)\\, \\mathrm{d}\\tau,\n$$\n这可由平稳性和自相关的定义推导出。对时间求导可得\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\mathrm{MSD}(t)=2d\\int_0^t C(\\tau)\\, \\mathrm{d}\\tau.\n$$\n在长时间下，如果 $C(t)$ 的积分收敛，则其导数趋于一个常数，$\\mathrm{MSD}(t)$ 的增长变为线性：\n$$\n\\mathrm{MSD}(t)\\sim 2d D\\, t \\quad \\text{as } t\\to\\infty,\n$$\n这定义了 Einstein 关系，其中 $D$ 是标量扩散系数。\n\n线性响应理论和涨落-耗散定理将输运系数与平衡态时间相关函数联系起来。对于在各向同性介质中的扩散，\n$$\nD = \\int_0^\\infty C(t)\\, \\mathrm{d}t,\n$$\n其中 $C(t)$ 是速度单个笛卡尔分量的自相关；这是 Green–Kubo 关系。在平衡和遍历性条件下，这两个关系都是精确的。在具有缓慢弛豫的拥挤系统中，相关函数可能表现出长时尾，通常具有 $C(t)\\sim A t^{-\\alpha}$（其中 $\\alpha1$）形式的幂律衰减，这意味着积分收敛但速度很慢。对于有限的观测时间 $T$，在 $T$ 处截断积分会相对于无限时间值产生一个偏差，该偏差由剩余的尾部贡献给出：\n$$\n\\Delta D_{\\mathrm{tail}}(T) = \\int_T^\\infty C(t)\\, \\mathrm{d}t \\approx \\int_T^\\infty A t^{-\\alpha}\\, \\mathrm{d}t = \\frac{A}{\\alpha-1} T^{1-\\alpha}.\n$$\n该量衡量了在 $T$ 处截断积分所遗漏的扩散系数的大小。由于单个有限轨迹的时间平均均方根位移斜率受到长延迟采样不完全和持续相关性的影响，时间平均估计和系综平均估计之间的差异会受到使截断积分产生偏差的同一长时尾的显著影响。一种量化该贡献的原则性方法是计算分数\n$$\nf_{\\mathrm{tail}} = \\min\\left\\{1, \\frac{\\left|\\Delta D_{\\mathrm{tail}}(T)\\right|}{\\left|D_{\\mathrm{Ein,ens}} - D_{\\mathrm{Ein,time}}\\right|} \\right\\},\n$$\n其中 $D_{\\mathrm{Ein,ens}}$ 和 $D_{\\mathrm{Ein,time}}$ 是在相同延迟窗口上从系综平均和时间平均均方根位移斜率获得的扩散系数。该分数估计了观测到的差异中，有多少可以由截断时间之外的长时尾的解析延拓来解释。\n\n与上述原理一致的算法构建：\n1. 速度模型。我们在 $d$ 维空间中合成为一个和 $\\mathbf{v}(t)=\\mathbf{v}^{\\mathrm{OU}}(t)+\\mathbf{w}(t)$ 的平稳高斯速度过程，其中 $\\mathbf{v}^{\\mathrm{OU}}(t)$ 是一个 Ornstein–Uhlenbeck 过程，其分量弛豫率为 $\\gamma$，平稳方差为 $v_{\\mathrm{var}}$；$\\mathbf{w}(t)$ 是一个拥挤诱导的贡献，通过将单位方差白噪声序列与有限长度的记忆核 $k_n\\propto (n+1)^{-\\beta}$ 进行卷积得到，并进行归一化，使得卷积输出在被 $a_{\\mathrm{tail}}$ 缩放前具有单位方差。在时间步长为 $dt$ 的离散时间中，每个分量的精确更新 Ornstein–Uhlenbeck 递归式为\n$$\nv_{n+1}^{\\mathrm{OU}} = a v_{n}^{\\mathrm{OU}} + \\sigma \\xi_n,\\quad a=e^{-\\gamma\\, dt},\\quad \\sigma=\\sqrt{v_{\\mathrm{var}}\\,(1-a^2)},\n$$\n其中 $\\xi_n$ 是独立的标准正态随机数。拥挤贡献为 $w_n = (k * z)_n$，即独立的标准正态随机数 $z_n$ 与一个归一化到单位卷积方差的核 $k_n$ 的循环卷积；然后我们通过 $a_{\\mathrm{tail}}$ 进行缩放以调整拥挤强度。其和是一个平稳高斯过程，其相关性继承自两部分，对于 $\\beta1$，诱导的相关性呈代数衰减。\n\n2. 位置积分。从 $\\mathbf{r}_0=\\mathbf{0}$ 开始，通过前向欧拉积分 $\\mathbf{r}_{n+1}=\\mathbf{r}_n + \\mathbf{v}_n\\, dt$ 计算位置。\n\n3. 速度自相关和 Green–Kubo。对于每条轨迹和每个分量，通过卷积定理（Wiener–Khinchin）计算自相关。对于长度为 $N$ 的序列 $v_n$，循环自相关估计为\n$$\n\\widehat{C}_\\mathrm{circ}[\\ell] = \\frac{1}{N}\\,\\mathcal{F}^{-1}\\left\\{ \\mathcal{F}\\{v\\}\\cdot \\overline{\\mathcal{F}\\{v\\}} \\right\\}[\\ell],\n$$\n其中 $\\mathcal{F}$ 表示离散傅里叶变换，上划线表示复共轭。对所有分量和轨迹的 $\\widehat{C}$ 进行平均以获得系综估计 $C(\\ell\\, dt)$，并使用梯形法则积分到 $\\ell_{\\max}=N/2$ 以避免循环卷绕：\n$$\nD_{\\mathrm{GK,trunc}} \\approx \\sum_{\\ell=0}^{\\ell_{\\max}} C(\\ell\\, dt)\\, dt.\n$$\n为了校正尾部，使用对数-对数线性回归 $\\log C(t)\\approx \\log A - \\alpha \\log t$ 对指数部分已衰减的区域 $\\ell\\ge\\ell_{\\mathrm{fit}}$（其中 $\\ell_{\\mathrm{fit}}\\approx \\lceil 10/(\\gamma\\, dt)\\rceil$）且 $C(t)0$ 的点进行拟合，然后加上在 $T=\\ell_{\\max}\\, dt$ 处计算的 $\\Delta D_{\\mathrm{tail}}$：\n$$\nD_{\\mathrm{GK,corr}} = D_{\\mathrm{GK,trunc}} + \\frac{A}{\\alpha-1}\\, T^{1-\\alpha},\\quad \\alpha1.\n$$\n\n4. 系综 Einstein 估计。系综平均均方根位移为 $\\mathrm{MSD}_{\\mathrm{ens}}(n\\, dt)=\\frac{1}{M}\\sum_{m=1}^M \\lVert \\mathbf{r}^{(m)}_n - \\mathbf{r}^{(m)}_0\\rVert^2$。对可用延迟窗口的后半部分拟合一条直线并计算斜率 $s_{\\mathrm{ens}}$，得到\n$$\nD_{\\mathrm{Ein,ens}} = \\frac{s_{\\mathrm{ens}}}{2d}.\n$$\n\n5. 时间平均 Einstein 估计。对于单条轨迹，在循环近似下，延迟 $\\ell$ 处的时间平均均方根位移通过对时间原点求平均来定义，\n$$\n\\mathrm{MSD}_{\\mathrm{time}}(\\ell\\, dt) = \\frac{1}{N}\\sum_{n=0}^{N-1} \\lVert \\mathbf{r}_{n+\\ell}-\\mathbf{r}_n\\rVert^2.\n$$\n这可以通过卷积定理，使用位置自相关 $\\widehat{R}(\\ell)=\\frac{1}{N}\\sum_n \\mathbf{r}_n\\cdot \\mathbf{r}_{n+\\ell}$ 来高效计算：\n$$\n\\mathrm{MSD}_{\\mathrm{time}}(\\ell\\, dt)=2\\sum_{i=1}^d\\left( \\frac{1}{N}\\sum_{n} x_{i,n}^2 - \\widehat{R}_i(\\ell)\\right).\n$$\n对可访问延迟的后半部分进行拟合以获得斜率 $s_{\\mathrm{time}}$ 并计算\n$$\nD_{\\mathrm{Ein,time}}=\\frac{s_{\\mathrm{time}}}{2d}.\n$$\n\n6. 尾部贡献分数。当 $T=\\ell_{\\max}\\, dt$ 时，\n$$\nf_{\\mathrm{tail}} = \\min\\left\\{1, \\frac{\\left|\\frac{A}{\\alpha-1} T^{1-\\alpha}\\right|}{\\left|D_{\\mathrm{Ein,ens}}-D_{\\mathrm{Ein,time}}\\right|}\\right\\}.\n$$\n该分数定量地描述了截断时间之外缺失的长时尾在多大程度上解释了时间平均和系综平均扩散估计值之间的差异。\n\n数值细节：\n- 使用 Ornstein–Uhlenbeck 递归的精确更新形式，以确保每个分量的平稳目标方差为 $v_{\\mathrm{var}}$。\n- 将记忆核构建为 $k_n=(n+1)^{-\\beta}$ 并进行归一化，使得与白噪声的循环卷积产生单位方差：如果 $z_n$ 是独立的标准正态随机变量，且 $w_n=(k*z)_n$ 是循环卷积，则 $\\mathrm{Var}(w_n)=\\sum_{n=0}^{L-1}k_n^2$；定义 $k_n\\leftarrow k_n/\\sqrt{\\sum k_n^2}$，以在通过 $a_{\\mathrm{tail}}$ 缩放之前将此方差设置为1。\n- 通过卷积定理使用离散傅里叶变换计算自相关和循环时间平均。将估计限制在延迟 $\\ell\\le N/2$。\n- 在尾部区域对自相关的正值执行对数-对数线性回归。如果可用点数少于最低要求或拟合的指数不大于1，则将尾部校正设置为零。\n- 使用最小二乘法进行线性回归，以拟合可用窗口后半部分的均方根位移的斜率。\n\n测试套件覆盖范围：\n- 第一种情况设置中等拥挤强度 $a_{\\mathrm{tail}}=0.5\\,\\mathrm{m}/\\mathrm{s}$，产生可辨别的长时尾和中等程度的差异。\n- 第二种情况设置强拥挤强度 $a_{\\mathrm{tail}}=1.0\\,\\mathrm{m}/\\mathrm{s}$，加剧了长时尾并增大了差异。\n- 第三种情况设置 $a_{\\mathrm{tail}}=0$，恢复为纯指数弛豫的基线，其长时尾可忽略不计，作为一种边界条件，在该条件下，截断积分和 Einstein 估计在统计误差范围内一致。\n\n程序将每个测试用例的五个标量结果聚合为单行输出，其嵌套列表的格式与指定格式完全一致。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_velocities(M, N, dt, d, gamma, v_var, a_tail, beta, L, rng):\n    \"\"\"\n    Generate M velocity trajectories, each with d components and length N, as\n    the sum of an OU process and a crowding-induced correlated component\n    constructed by circular convolution of white noise with a power-law kernel.\n    \"\"\"\n    # Precompute OU parameters\n    a = np.exp(-gamma * dt)\n    sigma = np.sqrt(v_var * (1.0 - a * a))\n\n    # Build and normalize the memory kernel (length N, padding zeros beyond L)\n    k = np.zeros(N)\n    n = np.arange(L)\n    # Power-law kernel k_n ~ (n+1)^(-beta)\n    k_vals = (n + 1.0) ** (-beta)\n    k_norm = np.sqrt(np.sum(k_vals ** 2))\n    if k_norm == 0.0:\n        k_norm = 1.0\n    k[:L] = k_vals / k_norm  # normalized so that variance of convolution output ~ 1\n\n    K_fft = np.fft.rfft(k)  # FFT of kernel for circular convolution\n\n    # Storage for velocities: shape (M, d, N)\n    v = np.zeros((M, d, N), dtype=float)\n\n    # Generate trajectories\n    for m in range(M):\n        for comp in range(d):\n            # Ornstein-Uhlenbeck component\n            v_ou = np.empty(N, dtype=float)\n            v_ou[0] = rng.normal(0.0, np.sqrt(v_var))\n            # Exact-update recursion\n            xi = rng.normal(0.0, 1.0, size=N - 1)\n            for i in range(N - 1):\n                v_ou[i + 1] = a * v_ou[i] + sigma * xi[i]\n\n            if a_tail != 0.0:\n                # Crowding-induced correlated component via circular convolution\n                z = rng.normal(0.0, 1.0, size=N)\n                Z_fft = np.fft.rfft(z)\n                w = np.fft.irfft(Z_fft * K_fft, n=N)\n                # Scale by a_tail to set the strength in m/s\n                v[m, comp, :] = v_ou + a_tail * w\n            else:\n                v[m, comp, :] = v_ou\n\n    return v\n\ndef integrate_positions(v, dt):\n    \"\"\"\n    Integrate velocities to positions via forward Euler.\n    v: shape (M, d, N)\n    Returns positions r: shape (M, d, N)\n    \"\"\"\n    M, d, N = v.shape\n    r = np.zeros((M, d, N), dtype=float)\n    # Forward Euler integration\n    r[:, :, 1:] = np.cumsum(v[:, :, :-1] * dt, axis=2)\n    return r\n\ndef autocorr_fft(x):\n    \"\"\"\n    Circular autocorrelation via FFT, normalized by sequence length.\n    For input array x of length N, returns length-N autocorrelation estimate.\n    \"\"\"\n    N = x.shape[-1]\n    X = np.fft.rfft(x)\n    S = X * np.conj(X)\n    acf = np.fft.irfft(S, n=N) / N\n    return acf\n\ndef ensemble_velocity_acf(v, max_lag):\n    \"\"\"\n    Compute ensemble- and component-averaged velocity autocorrelation up to max_lag.\n    v: shape (M, d, N)\n    Returns acf_avg[0:max_lag+1]\n    \"\"\"\n    M, d, N = v.shape\n    acf_sum = np.zeros(N, dtype=float)\n    for m in range(M):\n        for comp in range(d):\n            acf = autocorr_fft(v[m, comp, :])\n            acf_sum += acf\n    acf_avg_full = acf_sum / (M * d)\n    return acf_avg_full[:max_lag + 1]\n\ndef fit_power_law_tail(times, values):\n    \"\"\"\n    Fit values ~ A * t^(-alpha) using log-log linear regression on positive values.\n    times: array of t>0\n    values: array of corresponding C(t)\n    Returns (A, alpha, ok) where ok indicates fit validity with alpha>1 and sufficient points.\n    \"\"\"\n    # Select positive times and positive values\n    mask = (times > 0)  (values > 0)\n    t_pos = times[mask]\n    v_pos = values[mask]\n    if t_pos.size  10:\n        return 0.0, 0.0, False\n    log_t = np.log(t_pos)\n    log_v = np.log(v_pos)\n    # Linear regression log_v = b + m * log_t\n    m, b = np.polyfit(log_t, log_v, deg=1)\n    alpha = -m\n    A = np.exp(b)\n    if alpha = 1.0 or not np.isfinite(alpha) or not np.isfinite(A):\n        return 0.0, 0.0, False\n    return A, alpha, True\n\ndef slope_linear_fit(times, values):\n    \"\"\"\n    Compute slope via linear regression of values vs times.\n    Returns slope (float).\n    \"\"\"\n    # Fit y = a * t + c\n    A = np.vstack([times, np.ones_like(times)]).T\n    # Least squares solution\n    coeffs, _, _, _ = np.linalg.lstsq(A, values, rcond=None)\n    slope = coeffs[0]\n    return slope\n\ndef compute_msd_ensemble(r):\n    \"\"\"\n    Compute ensemble-averaged MSD(t) = mean over trajectories of |r(t) - r(0)|^2.\n    r: shape (M, d, N)\n    Returns msd_ens of shape (N,)\n    \"\"\"\n    # r(0) = 0 by construction; displacement norm squared is sum over dimensions of r^2\n    disp2 = np.sum(r ** 2, axis=1)  # shape (M, N)\n    msd_ens = np.mean(disp2, axis=0)  # shape (N,)\n    return msd_ens\n\ndef compute_tamsd_single(r_single):\n    \"\"\"\n    Compute time-averaged MSD for a single trajectory via circular averaging.\n    r_single: shape (d, N)\n    Returns tamsd of shape (N,), derived up to N lags (circular).\n    \"\"\"\n    d, N = r_single.shape\n    # For each component, compute autocorrelation of x via FFT\n    acf_sum = np.zeros(N, dtype=float)\n    mean_x2_sum = 0.0\n    for comp in range(d):\n        x = r_single[comp, :]\n        mean_x2_sum += np.mean(x ** 2)\n        acf_x = autocorr_fft(x)  # circular autocorrelation\n        acf_sum += acf_x\n    # TAMSD(ell) = 2 * (sum_d mean(x^2) - sum_d acf_x(ell))\n    tamsd = 2.0 * (mean_x2_sum - acf_sum)\n    return tamsd\n\ndef run_case(params):\n    \"\"\"\n    Run a single test case and return results:\n    [D_GK_trunc, D_GK_tailcorr, D_Ein_ensemble, D_Ein_time, f_tail]\n    \"\"\"\n    (M, N, dt, d, gamma, v_var, a_tail, beta, L) = params\n    rng = np.random.default_rng(seed=12345)  # fixed seed for reproducibility per run_case\n\n    # Generate synthetic velocities and positions\n    v = generate_velocities(M, N, dt, d, gamma, v_var, a_tail, beta, L, rng)\n    r = integrate_positions(v, dt)\n\n    # Maximum lag to avoid wrap-around artifacts\n    max_lag = N // 2  # use half-length\n    times = np.arange(max_lag + 1) * dt\n\n    # Ensemble-averaged velocity autocorrelation and Green-Kubo integrals\n    acf_avg = ensemble_velocity_acf(v, max_lag)\n    # Truncated integral\n    D_GK_trunc = np.trapz(acf_avg, times)\n\n    # Fit tail beyond t_fit_start = 10/gamma\n    t_fit_start = 10.0 / gamma\n    fit_mask = times >= t_fit_start\n    A_tail, alpha_tail, ok_tail = fit_power_law_tail(times[fit_mask], acf_avg[fit_mask])\n    # Tail correction beyond truncation time T = times[-1]\n    if ok_tail:\n        T_trunc = times[-1]\n        delta_D_tail = (A_tail / (alpha_tail - 1.0)) * (T_trunc ** (1.0 - alpha_tail))\n    else:\n        delta_D_tail = 0.0\n    D_GK_tailcorr = D_GK_trunc + delta_D_tail\n\n    # Ensemble Einstein estimate from ensemble MSD\n    msd_ens = compute_msd_ensemble(r)\n    # Fit on the last half of usable lags\n    t_fit_ens = times[1:max_lag]  # exclude time zero\n    y_fit_ens = msd_ens[1:max_lag]\n    # Use latter half\n    start_idx = len(t_fit_ens) // 2\n    t_seg_ens = t_fit_ens[start_idx:]\n    y_seg_ens = y_fit_ens[start_idx:]\n    slope_ens = slope_linear_fit(t_seg_ens, y_seg_ens)\n    D_Ein_ensemble = slope_ens / (2.0 * d)\n\n    # Time-averaged MSD for first trajectory\n    tamsd = compute_tamsd_single(r[0, :, :])\n    # Fit on the last half of usable lags\n    y_fit_time = tamsd[1:max_lag]\n    t_seg_time = t_fit_ens[start_idx:]\n    y_seg_time = y_fit_time[start_idx:]\n    slope_time = slope_linear_fit(t_seg_time, y_seg_time)\n    D_Ein_time = slope_time / (2.0 * d)\n\n    # Fraction of discrepancy explained by tail\n    denom = abs(D_Ein_ensemble - D_Ein_time)\n    # Use absolute tail correction magnitude (per-component diffusion correction)\n    f_tail = min(1.0, abs(delta_D_tail) / (denom + 1e-30))\n\n    return [D_GK_trunc, D_GK_tailcorr, D_Ein_ensemble, D_Ein_time, f_tail]\n\ndef format_results(results):\n    \"\"\"\n    Format nested list of floats with no spaces, each float in scientific notation.\n    \"\"\"\n    def fmt_float(x):\n        return f\"{x:.6e}\"\n    inner_lists = []\n    for res in results:\n        inner = \",\".join(fmt_float(x) for x in res)\n        inner_lists.append(f\"[{inner}]\")\n    return \"[\" + \",\".join(inner_lists) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10, 16384, 1e-12, 3, 1e12, 1e3, 0.5, 1.25, 2048),\n        (10, 16384, 1e-12, 3, 1e12, 1e3, 1.0, 1.25, 2048),\n        (10, 16384, 1e-12, 3, 1e12, 1e3, 0.0, 1.25, 2048),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(format_results(results))\n\nsolve()\n```"
        }
    ]
}