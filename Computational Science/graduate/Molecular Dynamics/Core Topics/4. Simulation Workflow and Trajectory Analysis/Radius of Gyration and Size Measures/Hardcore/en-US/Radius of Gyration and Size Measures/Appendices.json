{
    "hands_on_practices": [
        {
            "introduction": "This exercise grounds our understanding of molecular size in a discrete bead-chain model, which is the foundation of many coarse-grained simulations. By first deriving the radius of gyration, $R_g^2$, for an idealized linear chain, we build intuition from a simple, analytically tractable system. The problem then challenges us to connect this purely geometric measure to the hydrodynamic radius, $R_H$, a quantity linked to transport properties like diffusion and accessible through experimental techniques like dynamic light scattering .",
            "id": "3440317",
            "problem": "Consider a linear chain of $N$ identical point beads of mass $m$ arranged along the $x$-axis with uniform spacing $a$, such that the center of mass is at the origin. In classical molecular dynamics, the mass-weighted radius of gyration $R_{g}$ is defined by $R_{g}^{2} = \\frac{1}{M}\\sum_{i=1}^{N} m\\,|\\mathbf{r}_{i} - \\mathbf{r}_{\\mathrm{cm}}|^{2}$, where $M = \\sum_{i=1}^{N} m$ and $\\mathbf{r}_{\\mathrm{cm}} = \\frac{1}{M}\\sum_{i=1}^{N} m\\,\\mathbf{r}_{i}$. For this one-dimensional configuration, you may treat $|\\mathbf{r}_{i} - \\mathbf{r}_{\\mathrm{cm}}|$ as $|x_{i} - x_{\\mathrm{cm}}|$.\n\nStarting only from these definitions and well-tested summation facts, derive a closed-form expression for $R_{g}^{2}$ in terms of $N$ and $a$ for this chain. Express your final result as a single analytic expression in $N$ and $a$; no numerical substitution is required.\n\nThen, using low-Reynolds-number hydrodynamics and the Kirkwood diffusion relation for bead-spring models in the Oseen limit, outline a systematic procedure to estimate the hydrodynamic radius $R_{H}$ of this chain in the point-bead approximation (vanishing bead hydrodynamic radius). Derive an explicit finite-$N$ expression for $R_{H}^{-1}$ in terms of $N$, $a$, and any standard special functions that naturally arise, and obtain the leading large-$N$ scaling of $R_{H}$.\n\nAnswer specification:\n- Provide only the closed-form expression for $R_{g}^{2}$ as your final boxed answer. No other quantity should be boxed.\n- No rounding is required; report an exact symbolic expression.\n- Do not include units in the final boxed answer; express the result purely in terms of $N$ and $a$.",
            "solution": "The solution is presented in two parts as requested by the problem statement. First, the derivation of the radius of gyration squared, $R_{g}^{2}$. Second, the procedure and derivation for the hydrodynamic radius, $R_H$.\n\n**Part 1: Derivation of the Radius of Gyration, $R_{g}^{2}$**\n\nThe definition of the mass-weighted-radius of gyration squared is given as:\n$$R_{g}^{2} = \\frac{1}{M}\\sum_{i=1}^{N} m_{i}\\,|\\mathbf{r}_{i} - \\mathbf{r}_{\\mathrm{cm}}|^{2}$$\nFor a chain of $N$ identical beads of mass $m$, the total mass is $M = Nm$. The bead mass $m_i=m$ is constant. The expression simplifies to:\n$$R_{g}^{2} = \\frac{1}{Nm}\\sum_{i=1}^{N} m\\,|\\mathbf{r}_{i} - \\mathbf{r}_{\\mathrm{cm}}|^{2} = \\frac{1}{N}\\sum_{i=1}^{N} |\\mathbf{r}_{i} - \\mathbf{r}_{\\mathrm{cm}}|^{2}$$\nThe chain is arranged along the $x$-axis, so we can replace the vector difference with the scalar difference in position, $|\\mathbf{r}_{i} - \\mathbf{r}_{\\mathrm{cm}}| \\rightarrow |x_{i} - x_{\\mathrm{cm}}|$. The problem states that the center of mass is at the origin, so $x_{\\mathrm{cm}} = 0$. The expression for $R_{g}^{2}$ becomes:\n$$R_{g}^{2} = \\frac{1}{N}\\sum_{i=1}^{N} x_{i}^{2}$$\nNext, we must determine the positions $x_{i}$ of the $N$ beads. Let us index the beads from $i=1$ to $N$. The position of the $i$-th bead can be written as $x_{i} = x_1 + (i-1)a$. The center of mass is at the origin, so:\n$$x_{\\mathrm{cm}} = \\frac{1}{N}\\sum_{i=1}^{N} x_{i} = 0$$\nTo satisfy this condition, the positions must be symmetric about $x=0$. A convenient way to define these positions is to express them relative to the geometric center of the chain. We can set the position of the $i$-th bead as:\n$$x_{i} = a\\left(i - c\\right)$$\nwhere $c$ is a constant offset. Enforcing $x_{\\mathrm{cm}}=0$:\n$$\\frac{1}{N}\\sum_{i=1}^{N} a(i-c) = \\frac{a}{N}\\left(\\sum_{i=1}^{N} i - \\sum_{i=1}^{N} c\\right) = \\frac{a}{N}\\left(\\frac{N(N+1)}{2} - Nc\\right) = 0$$\nSolving for $c$, we find $c = \\frac{N+1}{2}$. Thus, the position of the $i$-th bead is:\n$$x_{i} = a\\left(i - \\frac{N+1}{2}\\right)$$\nNow we substitute this into the expression for $R_{g}^{2}$:\n$$R_{g}^{2} = \\frac{1}{N}\\sum_{i=1}^{N} \\left[a\\left(i - \\frac{N+1}{2}\\right)\\right]^{2} = \\frac{a^{2}}{N}\\sum_{i=1}^{N} \\left(i - \\frac{N+1}{2}\\right)^{2}$$\nLet $k = \\frac{N+1}{2}$. The sum is $\\sum_{i=1}^{N} (i-k)^2 = \\sum_{i=1}^{N} (i^2 - 2ki + k^2)$. We use the standard summation formulas:\n$\\sum_{i=1}^{N} i^{2} = \\frac{N(N+1)(2N+1)}{6}$\n$\\sum_{i=1}^{N} i = \\frac{N(N+1)}{2}$\n$\\sum_{i=1}^{N} 1 = N$\n\nThe sum becomes:\n$$\\sum_{i=1}^{N} (i-k)^2 = \\frac{N(N+1)(2N+1)}{6} - 2\\left(\\frac{N+1}{2}\\right)\\frac{N(N+1)}{2} + N\\left(\\frac{N+1}{2}\\right)^{2}$$\n$$= \\frac{N(N+1)(2N+1)}{6} - \\frac{N(N+1)^{2}}{2} + \\frac{N(N+1)^{2}}{4}$$\n$$= \\frac{N(N+1)(2N+1)}{6} - \\frac{N(N+1)^{2}}{4}$$\n$$= N(N+1)\\left[\\frac{2N+1}{6} - \\frac{N+1}{4}\\right] = N(N+1)\\left[\\frac{2(2N+1) - 3(N+1)}{12}\\right]$$\n$$= N(N+1)\\left[\\frac{4N+2 - 3N-3}{12}\\right] = N(N+1)\\left[\\frac{N-1}{12}\\right] = \\frac{N(N^{2}-1)}{12}$$\nFinally, we substitute this sum back into the expression for $R_{g}^{2}$:\n$$R_{g}^{2} = \\frac{a^{2}}{N} \\left(\\frac{N(N^{2}-1)}{12}\\right) = \\frac{a^{2}(N^{2}-1)}{12}$$\nThis is the closed-form expression for the radius of gyration squared for a rigid linear chain of $N$ beads.\n\n**Part 2: Hydrodynamic Radius, $R_H$**\n\nThe problem asks for a procedure to estimate $R_H$, an expression for $R_H^{-1}$, and its large-$N$ scaling.\n\n**Procedure:**\nThe hydrodynamic radius $R_H$ is typically defined via the Stokes-Einstein relation for the translational diffusion coefficient $D$:\n$$D = \\frac{k_{B}T}{6\\pi\\eta_{0}R_{H}}$$\nwhere $k_{B}$ is the Boltzmann constant, $T$ is the absolute temperature, and $\\eta_{0}$ is the viscosity of the solvent. The Kirkwood approximation provides a way to calculate $D$ and thus $R_H$ from the molecular structure. In this approximation, the inverse hydrodynamic radius is given by the pairwise average of the inverse of the inter-bead distances:\n$$R_{H}^{-1} = \\left\\langle \\frac{1}{N^{2}} \\sum_{i=1}^{N} \\sum_{j \\neq i} \\frac{1}{|\\mathbf{r}_{i} - \\mathbf{r}_{j}|} \\right\\rangle$$\nFor a rigid structure, the orientational average $\\langle \\dots \\rangle$ is not needed, and the positions $\\mathbf{r}_i$ are fixed. The procedure is thus to calculate this double summation for the given bead positions.\n\n**Derivation of $R_{H}^{-1}$:**\nFor our rigid linear chain, the distance between bead $i$ and bead $j$ is $|x_{i} - x_{j}| = |a(i - \\frac{N+1}{2}) - a(j - \\frac{N+1}{2})| = a|i-j|$.\nThe expression for $R_{H}^{-1}$ becomes:\n$$R_{H}^{-1} = \\frac{1}{N^{2}} \\sum_{i=1}^{N} \\sum_{j \\neq i} \\frac{1}{a|i-j|} = \\frac{1}{aN^{2}} \\sum_{i=1}^{N} \\sum_{j \\neq i} \\frac{1}{|i-j|}$$\nThe summation can be rewritten by exploiting symmetry:\n$$\\sum_{i=1}^{N} \\sum_{j \\neq i} \\frac{1}{|i-j|} = 2 \\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} \\frac{1}{j-i}$$\nLet $k = j-i$. The inner sum is $\\sum_{k=1}^{N-i} \\frac{1}{k}$, which is the definition of the $(N-i)$-th harmonic number, $H_{N-i}$.\nThe double summation becomes:\n$$2 \\sum_{i=1}^{N-1} H_{N-i}$$\nLet's change the index of summation to $m=N-i$. As $i$ runs from $1$ to $N-1$, $m$ runs from $N-1$ to $1$.\n$$2 \\sum_{m=1}^{N-1} H_{m}$$\nWe use the well-known identity for the sum of harmonic numbers: $\\sum_{m=1}^{n} H_{m} = (n+1)H_{n} - n$. With $n=N-1$:\n$$2 \\left[ (N-1+1)H_{N-1} - (N-1) \\right] = 2(NH_{N-1} - (N-1))$$\nSubstituting this back into the expression for $R_{H}^{-1}$:\n$$R_{H}^{-1} = \\frac{2}{aN^{2}}(NH_{N-1} - N + 1)$$\nThis is the explicit finite-$N$ expression for $R_{H}^{-1}$ in terms of $N$, $a$, and the harmonic number function $H_n$, which is a standard special function.\n\n**Large-$N$ Scaling:**\nTo find the behavior for large $N$, we use the asymptotic expansion for the harmonic number: $H_{n} \\approx \\ln(n) + \\gamma + \\mathcal{O}(1/n)$, where $\\gamma \\approx 0.577$ is the Euler-Mascheroni constant.\nFor large $N$, $H_{N-1} \\approx \\ln(N-1) + \\gamma \\approx \\ln(N) + \\gamma$.\n$$R_{H}^{-1} \\approx \\frac{2}{aN^{2}}(N(\\ln(N)+\\gamma) - N + 1)$$\n$$R_{H}^{-1} \\approx \\frac{2}{aN^{2}}(N\\ln(N) + (\\gamma-1)N + 1)$$\nFor the leading term, we retain a lowest power of $1/N$:\n$$R_{H}^{-1} \\approx \\frac{2\\ln(N)}{aN}$$\nTherefore, the hydrodynamic radius $R_H$ has the following large-$N$ scaling:\n$$R_{H} \\approx \\frac{aN}{2\\ln(N)}$$\nThe leading scaling behavior is $R_{H} \\propto \\frac{N}{\\ln(N)}$. This shows that $R_H$ grows almost linearly with the number of beads $N$ (and thus the total length $L=(N-1)a$), with a logarithmic correction.",
            "answer": "$$\n\\boxed{\\frac{a^{2}(N^{2}-1)}{12}}\n$$"
        },
        {
            "introduction": "Moving from idealized models to practical simulation analysis requires confronting the complexities of periodic boundary conditions (PBC). This hands-on coding exercise is designed to give you direct experience with a common and critical pitfall: the incorrect application of the Minimum Image Convention (MIC) when using pairwise formulas to calculate $R_g^2$. By setting up targeted numerical experiments, you will verify the equivalence of different $R_g^2$ formulations and visually diagnose the exact conditions under which the computationally convenient pairwise MIC approach fails, solidifying your understanding of how to correctly analyze data from periodic simulations .",
            "id": "3440335",
            "problem": "Design and implement a program that constructs three finite point configurations inside a three-dimensional periodic cubic box and computes the squared radius of gyration in two mathematically equivalent ways, then assesses when periodic boundary conditions invalidate the pairwise-distance form under a minimum-image convention. The base of the derivation must be the definition of the center of mass, Euclidean norms, and the structure of periodic lattices. You must not rely on any specialized domain shortcuts beyond these foundational elements.\n\nDefinitions to be used:\n- The center of mass position is defined as $\\mathbf{R}_{\\mathrm{cm}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{r}_i$ for $N$ points with positions $\\mathbf{r}_i \\in \\mathbb{R}^3$.\n- The squared radius of gyration is defined by the centered second moment as $R_g^2 = \\frac{1}{N}\\sum_{i=1}^{N}\\lVert \\mathbf{r}_i - \\mathbf{R}_{\\mathrm{cm}}\\rVert^2$.\n- The pairwise-distance identity to be verified is $R_g^2 = \\frac{1}{2N^2}\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\lVert \\mathbf{r}_i - \\mathbf{r}_j\\rVert^2$, under the condition that all $\\mathbf{r}_i$ are represented in a single Euclidean embedding.\n\nIn a cubic periodic box of side length $L$, wrapped coordinates are defined modulo $L$ in each dimension. The minimum-image convention replaces any difference vector $\\Delta \\mathbf{r}$ by $\\Delta \\mathbf{r} - L \\cdot \\mathrm{round}(\\Delta \\mathbf{r}/L)$ applied componentwise, which yields the nearest periodic image separation. Under periodic boundary conditions, unwrapping a connected chain of points can be performed by integrating the minimum-image differences along the connectivity, yielding a single consistent embedding $\\{\\tilde{\\mathbf{r}}_i\\}$ for the chain.\n\nYour program must:\n- Construct three test configurations inside a periodic cubic box of side length $L$ measured in nanometers, and compute all outputs in square nanometers.\n- For each configuration, compute three quantities:\n  - $R_{g,\\mathrm{cm}}^2$ from the unwrapped coordinates via the centered definition.\n  - $R_{g,\\mathrm{pair,unwrapped}}^2$ from the unwrapped coordinates via the pairwise-distance identity.\n  - $R_{g,\\mathrm{pair,MIC}}^2$ from the wrapped coordinates by applying the minimum-image convention to each pairwise difference independently.\n- Diagnose whether the minimum-image convention preserves the pairwise form by checking a sufficient condition: the span of the unwrapped configuration in each Cartesian dimension is strictly less than $L/2$. Concretely, compute the unwrapped bounding-box edge lengths $s_\\alpha = \\max_i \\tilde{r}_{i,\\alpha} - \\min_i \\tilde{r}_{i,\\alpha}$ for $\\alpha \\in \\{x,y,z\\}$ and set a boolean flag $\\mathrm{MIC\\_valid} = \\bigwedge_{\\alpha}(s_\\alpha < L/2 - \\varepsilon)$ for a small tolerance $\\varepsilon$.\n- Report the absolute difference $\\Delta_{\\mathrm{MIC}} = \\lvert R_{g,\\mathrm{cm}}^2 - R_{g,\\mathrm{pair,MIC}}^2\\rvert$.\n\nImplement the following test suite, where all positions are in nanometers and the final outputs must be expressed in square nanometers:\n- Test case $1$ (compact Gaussian random walk, “happy path”): $N=32$, $L=10.0$, Gaussian steps with standard deviation $\\sigma=0.2$ along each Cartesian component, starting at $\\mathbf{r}_0 = (1.0,2.0,3.0)$. Generate steps with a fixed pseudorandom number generator seed $\\mathrm{seed}=12345$ and wrap the resulting positions into the box by componentwise modulo $L$.\n- Test case $2$ (highly extended straight chain, failure of minimum-image pairwise form): $N=64$, $L=10.0$, straight line steps of magnitude $d=0.45$ along the $x$ axis, starting at $\\mathbf{r}_0=(0.1,0.2,0.3)$, then wrapped into the box by componentwise modulo $L$.\n- Test case $3$ (near-boundary compact bimodal cluster, boundary condition): $N=20$, $L=10.0$, two clusters of $10$ points each. The first cluster is centered at $(1.0,1.0,1.0)$, the second at $(1.0 + L/2 - \\epsilon, 1.0, 1.0)$ with $\\epsilon=0.05$, both with independent Gaussian perturbations of standard deviation $\\sigma=0.01$ applied to each component. Use $\\mathrm{seed}=4242$ for the perturbations, then wrap all positions into the box by componentwise modulo $L$. For unwrapping connectivity, order the points by their array index, thus forming a single chain whose edges connect consecutive indices.\n\nFor all cases, use the same unwrapping rule: construct unwrapped coordinates $\\tilde{\\mathbf{r}}_i$ by setting $\\tilde{\\mathbf{r}}_0$ equal to the wrapped $\\mathbf{r}_0$ and, for $i\\ge 1$, updating $\\tilde{\\mathbf{r}}_i = \\tilde{\\mathbf{r}}_{i-1} + \\mathrm{MIC}(\\mathbf{r}_i - \\mathbf{r}_{i-1})$ componentwise, where $\\mathrm{MIC}(\\cdot)$ applies the minimum-image convention using the box length $L$.\n\nNumerical details and units:\n- Express all squared radius of gyration values in $\\mathrm{nm}^2$.\n- Use a small tolerance $\\varepsilon = 10^{-9}$ in the $\\mathrm{MIC\\_valid}$ criterion.\n- For reporting, round all floating-point outputs to $6$ decimal places.\n\nRequired final output format:\n- Your program must produce a single line containing a list of per-test-case results, where each test case contributes a list of five elements in the order $[R_{g,\\mathrm{cm}}^2, R_{g,\\mathrm{pair,unwrapped}}^2, R_{g,\\mathrm{pair,MIC}}^2, \\Delta_{\\mathrm{MIC}}, \\mathrm{MIC\\_valid}]$.\n- The final printed line must therefore look like a single Python-style list of lists, for example $[[a_1,b_1,c_1,d_1,e_1],[a_2,b_2,c_2,d_2,e_2],[a_3,b_3,c_3,d_3,e_3]]$, where $a_k,b_k,c_k,d_k$ are floats in $\\mathrm{nm}^2$ rounded to $6$ decimals and $e_k$ is a boolean.",
            "solution": "The problem requires the implementation of a program to compute the squared radius of gyration, $R_g^2$, for three distinct point configurations within a three-dimensional periodic cubic box. The core of the task is to compare the results from two different computational formulas for $R_g^2$ under periodic boundary conditions (PBC) and to identify a sufficient condition under which they are equivalent.\n\n### 1. Theoretical Foundation: Radius of Gyration\n\nThe squared radius of gyration, $R_g^2$, is a measure of the spatial extent of a set of points. For a collection of $N$ points with position vectors $\\{\\mathbf{r}_i\\}_{i=1}^N$ in Euclidean space, it is defined via the second moment of the positions with respect to their center of mass, $\\mathbf{R}_{\\mathrm{cm}}$.\n\nThe center of mass is given by:\n$$\n\\mathbf{R}_{\\mathrm{cm}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{r}_i\n$$\nThe primary definition of $R_g^2$, based on the mean squared distance from the center of mass, is:\n$$\nR_{g,\\mathrm{cm}}^2 = \\frac{1}{N}\\sum_{i=1}^{N}\\lVert \\mathbf{r}_i - \\mathbf{R}_{\\mathrm{cm}}\\rVert^2\n$$\nAn alternative, mathematically equivalent formula expresses $R_g^2$ in terms of the mean squared distance between all pairs of points:\n$$\nR_{g,\\mathrm{pair}}^2 = \\frac{1}{2N^2}\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\lVert \\mathbf{r}_i - \\mathbf{r}_j\\rVert^2\n$$\nThe equivalence of these two expressions in standard Euclidean space can be shown by expanding the terms. This equivalence serves as a crucial validation for any implementation.\n\n### 2. Periodic Boundary Conditions and the Minimum Image Convention\n\nIn computational simulations, systems are often modeled within a periodic box to approximate an infinite medium. For a cubic box of side length $L$, a point at position $\\mathbf{r}=(x,y,z)$ is equivalent to all points $\\mathbf{r} + (n_x L, n_y L, n_z L)$ for any integers $(n_x, n_y, n_z)$.\n\nThis periodicity complicates the calculation of distances. The distance between two points $\\mathbf{r}_i$ and $\\mathbf{r}_j$ is typically taken to be the distance between their closest periodic images. This is calculated using the minimum image convention (MIC). For a displacement vector $\\Delta \\mathbf{r} = \\mathbf{r}_i - \\mathbf{r}_j$, the minimum image displacement is found by applying the function $\\mathrm{MIC}(\\Delta \\mathbf{r}) = \\Delta \\mathbf{r} - L \\cdot \\mathrm{round}(\\Delta \\mathbf{r}/L)$ to each Cartesian component. This maps each component of the displacement into the interval $[-L/2, L/2]$.\n\n### 3. Comparing Computational Approaches for $R_g^2$ under PBC\n\nThe problem investigates two distinct approaches to calculating $R_g^2$ in a periodic system:\n\n1.  **Reference Method (Unwrapped Coordinates)**: A connected structure (like a polymer chain) can be \"unwrapped\" to create a single, continuous representation in Euclidean space, $\\{\\tilde{\\mathbf{r}}_i\\}$. This is achieved by integrating the minimum-image displacements along the chain's connectivity, starting from a reference point. For a chain ordered by index $i$, the unwrapped coordinates $\\tilde{\\mathbf{r}}_i$ are reconstructed as:\n    $$\n    \\tilde{\\mathbf{r}}_0 = \\mathbf{r}_0 \\quad (\\text{the wrapped coordinate})\n    $$\n    $$\n    \\tilde{\\mathbf{r}}_i = \\tilde{\\mathbf{r}}_{i-1} + \\mathrm{MIC}(\\mathbf{r}_i - \\mathbf{r}_{i-1}) \\quad \\text{for } i \\ge 1\n    $$\n    Once these unwrapped coordinates $\\{\\tilde{\\mathbf{r}}_i\\}$ are obtained, we can compute the true $R_g^2$ using either the center-of-mass formula ($R_{g,\\mathrm{cm}}^2$) or the pairwise formula ($R_{g,\\mathrm{pair,unwrapped}}^2$). These two must agree, providing a self-consistency check.\n\n2.  **Approximate Method (Pairwise MIC)**: A computationally simpler but potentially incorrect approach is to use the wrapped coordinates $\\{\\mathbf{r}_i\\}$ directly in the pairwise formula, but apply the MIC to every pairwise difference:\n    $$\n    R_{g,\\mathrm{pair,MIC}}^2 = \\frac{1}{2N^2}\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\lVert \\mathrm{MIC}(\\mathbf{r}_i - \\mathbf{r}_j)\\rVert^2\n    $$\n\nThe key question is under what conditions $R_{g,\\mathrm{cm}}^2 = R_{g,\\mathrm{pair,MIC}}^2$. The equality holds if and only if for every pair $(i, j)$, the true displacement vector $\\tilde{\\mathbf{r}}_i - \\tilde{\\mathbf{r}}_j$ is identical to its minimum image. This is true if every component of the true displacement vector has a magnitude less than $L/2$. A sufficient (but not necessary) condition for this is that the entire object is contained within a volume smaller than the primary simulation cell. Specifically, the span of the unwrapped object in each Cartesian dimension $\\alpha \\in \\{x,y,z\\}$, defined as $s_\\alpha = \\max_i \\tilde{r}_{i,\\alpha} - \\min_i \\tilde{r}_{i,\\alpha}$, must be less than $L/2$. The program will test the condition $\\mathrm{MIC\\_valid} = \\bigwedge_{\\alpha}(s_\\alpha < L/2 - \\varepsilon)$ for a small tolerance $\\varepsilon$.\n\n### 4. Algorithmic Design and Test Cases\n\nThe program proceeds by first generating coordinates for three specific test cases. For each case, it obtains a set of \"ideal\" coordinates in Euclidean space, which are then wrapped into the periodic box to yield the input coordinates $\\{\\mathbf{r}_i\\}$. Then, the full analysis is performed.\n\n*   **Test Case 1 (Compact Gaussian Walk)**: A $32$-particle random walk with small steps ($\\sigma=0.2$ nm) inside a $L=10.0$ nm box. The resulting structure is expected to be compact, satisfying the validity condition ($s_\\alpha < L/2$). Thus, we predict $R_{g,\\mathrm{cm}}^2 \\approx R_{g,\\mathrm{pair,MIC}}^2$.\n*   **Test Case 2 (Extended Straight Chain)**: A $64$-particle straight line with step size $d=0.45$ nm. The total length is $(64-1) \\times 0.45 \\approx 28.35$ nm, which is much larger than $L/2=5.0$ nm. This case is designed to violate the validity condition, and we predict $R_{g,\\mathrm{cm}}^2 \\neq R_{g,\\mathrm{pair,MIC}}^2$.\n*   **Test Case 3 (Bimodal Cluster on Boundary)**: Two $10$-particle clusters are placed such that their centers are separated by $L/2-\\epsilon$ along one axis. The total span will be very close to, but slightly less than, $L/2$. This case tests the boundary of the validity condition, where we expect the MIC-based pairwise calculation to remain valid.\n\nFor each case, the program executes the following steps:\n1.  Generate the set of wrapped coordinates $\\{\\mathbf{r}_i\\}$ according to the case specification.\n2.  Construct the unwrapped coordinates $\\{\\tilde{\\mathbf{r}}_i\\}$ using the iterative unwrapping algorithm.\n3.  Calculate $R_{g,\\mathrm{cm}}^2$ from $\\{\\tilde{\\mathbf{r}}_i\\}$ using the center-of-mass definition. This is the ground truth.\n4.  Calculate $R_{g,\\mathrm{pair,unwrapped}}^2$ from $\\{\\tilde{\\mathbf{r}}_i\\}$ using the pairwise definition, as a cross-check.\n5.  Calculate $R_{g,\\mathrm{pair,MIC}}^2$ from the wrapped coordinates $\\{\\mathbf{r}_i\\}$ and the pairwise MIC formula.\n6.  Compute the absolute difference $\\Delta_{\\mathrm{MIC}} = \\lvert R_{g,\\mathrm{cm}}^2 - R_{g,\\mathrm{pair,MIC}}^2 \\rvert$.\n7.  Evaluate the boolean flag $\\mathrm{MIC\\_valid}$ based on the span of the unwrapped coordinates.\n8.  Report the five final quantities, with floating-point values rounded to $6$ decimal places.\n\nThis structured analysis will empirically demonstrate the principles governing the use of different $R_g^2$ formulae in periodic systems.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs three point configurations, computes the squared radius of gyration\n    in multiple ways under periodic boundary conditions, and assesses the validity\n    of the minimum-image convention pairwise shortcut.\n    \"\"\"\n    \n    # Define parameters for the three test cases as specified in the problem.\n    test_cases_params = [\n        {'case': 1, 'N': 32, 'L': 10.0, 'sigma': 0.2, 'r0': np.array([1.0, 2.0, 3.0]), 'seed': 12345},\n        {'case': 2, 'N': 64, 'L': 10.0, 'd': 0.45, 'r0': np.array([0.1, 0.2, 0.3])},\n        {'case': 3, 'N': 20, 'L': 10.0, 'sigma': 0.01, 'epsilon': 0.05, 'seed': 4242}\n    ]\n\n    all_results = []\n    \n    for params in test_cases_params:\n        L = params['L']\n        N = params['N']\n        \n        # --- 1. Generate Ideal and Wrapped Coordinates ---\n        if params['case'] == 1:\n            # Case 1: Compact Gaussian random walk\n            rng = np.random.default_rng(params['seed'])\n            r0 = params['r0']\n            ideal_coords = np.zeros((N, 3))\n            ideal_coords[0] = r0\n            steps = rng.normal(loc=0.0, scale=params['sigma'], size=(N - 1, 3))\n            ideal_coords[1:] = r0 + np.cumsum(steps, axis=0)\n        \n        elif params['case'] == 2:\n            # Case 2: Highly extended straight chain\n            r0 = params['r0']\n            ideal_coords = np.zeros((N, 3))\n            ideal_coords[0] = r0\n            steps = np.zeros((N - 1, 3))\n            steps[:, 0] = params['d']\n            ideal_coords[1:] = r0 + np.cumsum(steps, axis=0)\n\n        elif params['case'] == 3:\n            # Case 3: Near-boundary compact bimodal cluster\n            rng = np.random.default_rng(params['seed'])\n            N1 = 10\n            N2 = 10\n            c1 = np.array([1.0, 1.0, 1.0])\n            c2 = np.array([1.0 + L / 2.0 - params['epsilon'], 1.0, 1.0])\n            cluster1 = c1 + rng.normal(loc=0.0, scale=params['sigma'], size=(N1, 3))\n            cluster2 = c2 + rng.normal(loc=0.0, scale=params['sigma'], size=(N2, 3))\n            ideal_coords = np.vstack((cluster1, cluster2))\n\n        # Wrap the ideal coordinates into the periodic box [0, L)\n        coords_wrapped = ideal_coords % L\n\n        # --- 2. Unwrap Chain from Wrapped Coordinates ---\n        # This reconstructs a single connected image of the chain.\n        coords_unwrapped = np.zeros_like(coords_wrapped)\n        coords_unwrapped[0] = coords_wrapped[0]\n        for i in range(1, N):\n            dr_wrapped = coords_wrapped[i] - coords_wrapped[i-1]\n            # Minimum Image Convention (MIC) for the displacement vector\n            dr_mic = dr_wrapped - L * np.round(dr_wrapped / L)\n            coords_unwrapped[i] = coords_unwrapped[i-1] + dr_mic\n\n        # --- 3. Compute Rg^2 values ---\n        \n        # Rg_cm^2: From unwrapped coordinates via centered definition (the ground truth)\n        R_cm = np.mean(coords_unwrapped, axis=0)\n        rg2_cm = np.mean(np.sum((coords_unwrapped - R_cm)**2, axis=1))\n\n        # Rg_pair_unwrapped^2: From unwrapped coordinates via pairwise identity\n        # Using broadcasting for an efficient O(N^2) calculation.\n        diffs = coords_unwrapped[:, np.newaxis, :] - coords_unwrapped[np.newaxis, :, :]\n        sum_sq_dist = np.sum(diffs**2)\n        rg2_pair_unwrapped = sum_sq_dist / (2 * N**2)\n\n        # Rg_pair_MIC^2: From wrapped coordinates applying MIC to each pairwise difference\n        diffs_wrapped = coords_wrapped[:, np.newaxis, :] - coords_wrapped[np.newaxis, :, :]\n        mic_diffs = diffs_wrapped - L * np.round(diffs_wrapped / L)\n        sum_sq_dist_mic = np.sum(mic_diffs**2)\n        rg2_pair_mic = sum_sq_dist_mic / (2 * N**2)\n\n        # --- 4. Diagnose and Compare ---\n        \n        # Absolute difference between ground truth and MIC-shortcut\n        delta_mic = np.abs(rg2_cm - rg2_pair_mic)\n        \n        # Check the sufficient condition for MIC validity\n        span = np.max(coords_unwrapped, axis=0) - np.min(coords_unwrapped, axis=0)\n        epsilon = 1e-9\n        mic_valid = np.all(span < (L / 2.0 - epsilon))\n        \n        # --- 5. Collect results for this case ---\n        all_results.append([rg2_cm, rg2_pair_unwrapped, rg2_pair_mic, delta_mic, bool(mic_valid)])\n\n    # --- 6. Format and Print Final Output ---\n    # Construct the final output string exactly as specified.\n    final_output_str_list = []\n    for res in all_results:\n        # Format the four float values to 6 decimal places and get the string for the boolean.\n        formatted_res = [f\"{v:.6f}\" for v in res[:4]] + [str(res[4])]\n        s = f\"[{','.join(formatted_res)}]\"\n        final_output_str_list.append(s)\n\n    # Print the single line containing the list of lists.\n    print(f\"[{','.join(final_output_str_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In the era of large-scale molecular dynamics, analyzing massive trajectory files requires algorithms that are not only correct but also efficient and numerically robust. This practice addresses the advanced challenge of computing $R_g^2$ from a data stream in a single pass without suffering from catastrophic cancellation or loss of precision. You will derive and implement a mass-weighted, online update scheme analogous to the Welford algorithm, a powerful technique for calculating variance-like quantities that is essential for developing professional-grade scientific software .",
            "id": "3440388",
            "problem": "You are given a stream of particle data, where each particle is specified by a nonnegative mass and a position in three-dimensional space. Using only a single pass over the stream, derive from first principles an online update scheme to compute both the mass-weighted center of mass and the mass-weighted radius of gyration squared. Your derivation must start from the fundamental definitions of center of mass and radius of gyration in classical mechanics, and proceed by algebraic manipulation that avoids forming large intermediate sums that would be numerically unstable for sequences with large dynamic range in masses or coordinates. The online scheme must be analogous in spirit to Welford’s method for variance but generalized to vector-valued, mass-weighted data in three dimensions.\n\nDefinitions to start from:\n- For particles indexed by $i \\in \\{1,\\dots,n\\}$ with masses $m_i \\ge 0$ and positions $\\mathbf{r}_i \\in \\mathbb{R}^3$, the total mass is $M_n = \\sum_{i=1}^{n} m_i$ and the mass-weighted center of mass (COM) is $\\mathbf{R}_n = \\frac{1}{M_n}\\sum_{i=1}^{n} m_i \\mathbf{r}_i$ when $M_n \\gt 0$.\n- The mass-weighted radius of gyration squared is $R_{g,n}^2 = \\frac{1}{M_n}\\sum_{i=1}^{n} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_n \\rVert^2$ when $M_n \\gt 0$.\n\nYour task has two parts:\n1. Derive, using only the definitions above and general algebra, a one-pass update for a new particle of mass $m$ at position $\\mathbf{r}$ that updates the current total mass $M$, the current COM $\\mathbf{R}$, and an auxiliary scalar accumulator $S$ such that after processing all particles, $R_g^2 = S/M$ holds exactly in exact arithmetic when $M \\gt 0$. Your update must be well-defined for $m = 0$ and must avoid subtractive cancellation paths that would degrade numerical stability for large $M$ or large dynamic range in $\\mathbf{r}$.\n2. Implement the derived update in a program that processes the following test suite. Each test case is a sequence of $(m_i,\\mathbf{r}_i)$ values. Input units: positions are in nanometers (nm) and masses are in any consistent mass unit. Output units: report $R_g^2$ in square nanometers (nm$^2$).\n\nTest suite to implement:\n- Case A (happy path, symmetry): $[(1.0,(0.0,0.0,0.0)),(1.0,(1.0,0.0,0.0))]$.\n- Case B (asymmetric masses in a plane): $[(2.0,(0.0,0.0,0.0)),(1.0,(1.0,0.0,0.0)),(1.0,(0.0,1.0,0.0))]$.\n- Case C (degenerate geometry, large dynamic range): $[(1.0\\times 10^{6},(2.0,2.0,2.0)),(2.0\\times 10^{-6},(2.0,2.0,2.0)),(3.0,(2.0,2.0,2.0))]$.\n- Case D (colinear positions, varied masses): $[(1.0,(0.0,0.0,0.0)),(2.0,(2.0,0.0,0.0)),(3.0,(4.0,0.0,0.0)),(4.0,(6.0,0.0,0.0))]$.\n- Case E (single particle edge case): $[(1.23,(3.4,-5.6,7.8))]$.\n\nProgram requirements:\n- Process each case strictly in a single pass over the particles using your online update scheme, without storing all positions for batch recomputation.\n- For each case, compute $R_g^2$ in nm$^2$.\n- Final Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each result must be a floating-point number rounded to exactly $6$ decimal places.\n\nAssumptions and constraints:\n- You may assume all masses are finite and nonnegative and all coordinates are finite.\n- If the total mass is zero, $R_g^2$ is undefined; however, the provided test cases avoid this condition.\n- Angles are not used in this problem, so no angle unit is required.\n\nDeliverables:\n- A derivation of the online update from the definitions.\n- A complete, runnable program that implements the derived update and applies it to the specified test suite, outputting a single line with the formatted results.",
            "solution": "We are tasked with deriving an online, single-pass update scheme for the mass-weighted center of mass, $\\mathbf{R}$, and the mass-weighted radius of gyration squared, $R_g^2$. The derivation must begin from the provided first principles and yield a numerically stable algorithm.\n\nLet us denote the state of the system after processing $n$ particles by the triplet $(M_n, \\mathbf{R}_n, S_n)$, where $M_n$ is the total mass, $\\mathbf{R}_n$ is the center of mass, and $S_n$ is an auxiliary accumulator. The definitions for the first $n$ particles with masses $m_i$ and positions $\\mathbf{r}_i$ are:\nTotal mass:\n$$ M_n = \\sum_{i=1}^{n} m_i $$\nMass-weighted center of mass (COM):\n$$ \\mathbf{R}_n = \\frac{1}{M_n} \\sum_{i=1}^{n} m_i \\mathbf{r}_i $$\nThe mass-weighted radius of gyration squared is given by $R_{g,n}^2 = S_n/M_n$, where $S_n$ is defined as the mass-weighted sum of squared distances from the COM:\n$$ S_n = M_n R_{g,n}^2 = \\sum_{i=1}^{n} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_n \\rVert^2 $$\nOur goal is to find recurrence relations for $M_{n+1}$, $\\mathbf{R}_{n+1}$, and $S_{n+1}$ in terms of $M_n$, $\\mathbf{R}_n$, $S_n$, and the properties of the new $(n+1)$-th particle, which has mass $m$ and position $\\mathbf{r}$.\n\n1.  **Update for Total Mass ($M_n$)**\n    The update rule for the total mass is derived directly from its definition:\n    $$ M_{n+1} = \\sum_{i=1}^{n+1} m_i = \\left(\\sum_{i=1}^{n} m_i\\right) + m_{n+1} $$\n    Letting $m_{n+1}=m$, the update rule is:\n    $$ M_{n+1} = M_n + m $$\n\n2.  **Update for Center of Mass ($\\mathbf{R}_n$)**\n    The COM for $n+1$ particles is:\n    $$ \\mathbf{R}_{n+1} = \\frac{1}{M_{n+1}} \\sum_{i=1}^{n+1} m_i \\mathbf{r}_i = \\frac{1}{M_{n+1}} \\left( \\sum_{i=1}^{n} m_i \\mathbf{r}_i + m\\mathbf{r} \\right) $$\n    Using the definition $\\sum_{i=1}^{n} m_i \\mathbf{r}_i = M_n \\mathbf{R}_n$:\n    $$ \\mathbf{R}_{n+1} = \\frac{1}{M_{n+1}} (M_n \\mathbf{R}_n + m\\mathbf{r}) $$\n    To obtain a form analogous to Welford's algorithm, which involves updates based on the deviation from the current mean, we add and subtract $m\\mathbf{R}_n$ in the numerator:\n    $$ \\mathbf{R}_{n+1} = \\frac{1}{M_{n+1}} (M_n \\mathbf{R}_n + m\\mathbf{R}_n - m\\mathbf{R}_n + m\\mathbf{r}) = \\frac{1}{M_{n+1}} ((M_n + m)\\mathbf{R}_n + m(\\mathbf{r} - \\mathbf{R}_n)) $$\n    Since $M_{n+1} = M_n + m$:\n    $$ \\mathbf{R}_{n+1} = \\mathbf{R}_n + \\frac{m}{M_{n+1}}(\\mathbf{r} - \\mathbf{R}_n) $$\n    This update rule is numerically robust as it adds a small correction term to the existing COM, mitigating potential floating-point precision loss if $\\mathbf{R}_n$ and $\\mathbf{r}$ are large but their difference is small.\n\n3.  **Update for the Auxiliary Accumulator ($S_n$)**\n    The accumulator $S_{n+1}$ is defined as:\n    $$ S_{n+1} = \\sum_{i=1}^{n+1} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_{n+1} \\rVert^2 = \\left( \\sum_{i=1}^{n} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_{n+1} \\rVert^2 \\right) + m \\lVert \\mathbf{r} - \\mathbf{R}_{n+1} \\rVert^2 $$\n    We must express $\\mathbf{R}_{n+1}$ in terms of $\\mathbf{R}_n$. Let $\\mathbf{\\Delta_R} = \\mathbf{R}_{n+1} - \\mathbf{R}_n = \\frac{m}{M_{n+1}}(\\mathbf{r} - \\mathbf{R}_n)$.\n    Consider the sum term:\n    $$ \\sum_{i=1}^{n} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_{n+1} \\rVert^2 = \\sum_{i=1}^{n} m_i \\lVert (\\mathbf{r}_i - \\mathbf{R}_n) - \\mathbf{\\Delta_R} \\rVert^2 $$\n    Expanding the squared norm:\n    $$ = \\sum_{i=1}^{n} m_i \\left( \\lVert \\mathbf{r}_i - \\mathbf{R}_n \\rVert^2 - 2(\\mathbf{r}_i - \\mathbf{R}_n) \\cdot \\mathbf{\\Delta_R} + \\lVert \\mathbf{\\Delta_R} \\rVert^2 \\right) $$\n    $$ = \\left( \\sum_{i=1}^{n} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_n \\rVert^2 \\right) - 2\\mathbf{\\Delta_R} \\cdot \\left( \\sum_{i=1}^{n} m_i(\\mathbf{r}_i - \\mathbf{R}_n) \\right) + \\left( \\sum_{i=1}^{n} m_i \\right) \\lVert \\mathbf{\\Delta_R} \\rVert^2 $$\n    The first term is $S_n$. The second term is zero because $\\sum m_i(\\mathbf{r}_i - \\mathbf{R}_n) = \\sum m_i \\mathbf{r}_i - \\mathbf{R}_n \\sum m_i = M_n \\mathbf{R}_n - M_n \\mathbf{R}_n = \\mathbf{0}$. The third term is $M_n \\lVert \\mathbf{\\Delta_R} \\rVert^2$. Thus, the sum term becomes $S_n + M_n \\lVert \\mathbf{\\Delta_R} \\rVert^2$.\n\n    Now consider the new particle's term, $m \\lVert \\mathbf{r} - \\mathbf{R}_{n+1} \\rVert^2$:\n    $$ \\mathbf{r} - \\mathbf{R}_{n+1} = \\mathbf{r} - (\\mathbf{R}_n + \\mathbf{\\Delta_R}) = (\\mathbf{r} - \\mathbf{R}_n) - \\mathbf{\\Delta_R} = (\\mathbf{r} - \\mathbf{R}_n) - \\frac{m}{M_{n+1}}(\\mathbf{r} - \\mathbf{R}_n) $$\n    $$ = \\left(1 - \\frac{m}{M_{n+1}}\\right) (\\mathbf{r} - \\mathbf{R}_n) = \\frac{M_{n+1}-m}{M_{n+1}} (\\mathbf{r} - \\mathbf{R}_n) = \\frac{M_n}{M_{n+1}} (\\mathbf{r} - \\mathbf{R}_n) $$\n    The new particle's contribution to $S_{n+1}$ is:\n    $$ m \\left\\lVert \\frac{M_n}{M_{n+1}} (\\mathbf{r} - \\mathbf{R}_n) \\right\\rVert^2 = m \\left(\\frac{M_n}{M_{n+1}}\\right)^2 \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 $$\n    Combining the parts:\n    $$ S_{n+1} = S_n + M_n \\lVert \\mathbf{\\Delta_R} \\rVert^2 + m \\left(\\frac{M_n}{M_{n+1}}\\right)^2 \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 $$\n    Substitute $\\mathbf{\\Delta_R} = \\frac{m}{M_{n+1}}(\\mathbf{r} - \\mathbf{R}_n)$:\n    $$ S_{n+1} = S_n + M_n \\left(\\frac{m}{M_{n+1}}\\right)^2 \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 + m \\left(\\frac{M_n}{M_{n+1}}\\right)^2 \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 $$\n    $$ S_{n+1} = S_n + \\frac{\\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2}{M_{n+1}^2} \\left[ M_n m^2 + m M_n^2 \\right] $$\n    Factoring the term in brackets $M_n m(m + M_n) = M_n m M_{n+1}$:\n    $$ S_{n+1} = S_n + \\frac{\\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2}{M_{n+1}^2} (M_n m M_{n+1}) $$\n    $$ S_{n+1} = S_n + \\frac{m M_n}{M_{n+1}} \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 = S_n + \\frac{m M_n}{m+M_n} \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 $$\n    This update rule is purely additive for non-negative masses, avoiding the subtractive cancellation inherent in the naive parallel axis theorem approach ($S_n = \\sum m_i \\lVert \\mathbf{r}_i \\rVert^2 - M_n \\lVert \\mathbf{R}_n \\rVert^2$). This form is the mass-weighted, vector generalization of Welford's algorithm for sum of squared differences.\n\n**Final Algorithm:**\n\nInitialize the state: $N = 0$ (particle count), $M = 0$, $\\mathbf{R} = \\mathbf{0}$, $S = 0$.\n\nFor each incoming particle $(m_i, \\mathbf{r}_i)$:\n1.  If $N = 0$:\n    $M \\leftarrow m_i$, $\\mathbf{R} \\leftarrow \\mathbf{r}_i$, $S \\leftarrow 0$.\n2.  Else if $m_i > 0$ (the case $m_i=0$ results in no change):\n    a. Store old state variables: $M_{old} \\leftarrow M$, $\\mathbf{R}_{old} \\leftarrow \\mathbf{R}$.\n    b. Update total mass: $M \\leftarrow M_{old} + m_i$.\n    c. Update COM: $\\mathbf{R} \\leftarrow \\mathbf{R}_{old} + \\frac{m_i}{M}(\\mathbf{r}_i - \\mathbf{R}_{old})$.\n    d. Update accumulator: Let $\\mathbf{\\delta} = \\mathbf{r}_i - \\mathbf{R}_{old}$. Then $S \\leftarrow S + \\frac{m_i M_{old}}{M} (\\mathbf{\\delta} \\cdot \\mathbf{\\delta})$.\n3.  Increment particle count: $N \\leftarrow N + 1$.\n\nAfter processing all particles, if $M > 0$, the mass-weighted radius of gyration squared is $R_g^2 = S/M$. For a single particle ($N=1$), $M=m_1, \\mathbf{R}=\\mathbf{r}_1, S=0$, so $R_g^2 = 0$, which is correct. For a system where all particles are at the same location, the update to $S$ is always zero, correctly yielding $R_g^2 = 0$.\nThis algorithm fulfills all requirements of the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_rg2_online(particles):\n    \"\"\"\n    Calculates the mass-weighted radius of gyration squared using a one-pass\n    online algorithm derived from first principles.\n\n    The algorithm is a mass-weighted, vector generalization of Welford's method.\n    It maintains three running quantities:\n    - M: Total mass\n    - R: Mass-weighted center of mass (COM)\n    - S: Mass-weighted sum of squared distances from the COM, S = M * Rg^2\n\n    The state is initialized with the first particle. For each subsequent\n    particle (m, r), the state (M, R, S) is updated.\n\n    Args:\n        particles (list of tuples): A list where each tuple contains\n                                    (mass, position_vector).\n\n    Returns:\n        float: The mass-weighted radius of gyration squared, Rg^2.\n    \"\"\"\n    if not particles:\n        return 0.0\n\n    n_particles = 0\n    total_mass = 0.0\n    com = np.zeros(3, dtype=np.float64)\n    # S is the accumulator for M * Rg^2\n    s_accumulator = 0.0\n    \n    for m, r_tuple in particles:\n        r_vec = np.array(r_tuple, dtype=np.float64)\n        \n        # Skip zero-mass particles as they don't contribute\n        if m <= 0:\n            continue\n\n        n_particles += 1\n        \n        if n_particles == 1:\n            total_mass = m\n            com = r_vec\n            s_accumulator = 0.0\n        else:\n            old_mass = total_mass\n            old_com = com\n            \n            total_mass = old_mass + m\n            \n            # Update COM using the stable online formula\n            delta_r = r_vec - old_com\n            com = old_com + (m / total_mass) * delta_r\n            \n            # Update S (the M*Rg^2 accumulator) using the derived stable formula\n            # S_new = S_old + (m_old * m_new / m_total) * ||r_new - com_old||^2\n            update_term = (m * old_mass / total_mass) * np.dot(delta_r, delta_r)\n            s_accumulator += update_term\n            \n    if total_mass == 0:\n        return 0.0\n        \n    rg2 = s_accumulator / total_mass\n    return rg2\n\ndef solve():\n    \"\"\"\n    Processes a suite of test cases, each a stream of particle data,\n    to compute the radius of gyration squared in a single pass.\n    \"\"\"\n    test_cases = [\n        # Case A: happy path, symmetry\n        [(1.0, (0.0, 0.0, 0.0)), (1.0, (1.0, 0.0, 0.0))],\n        \n        # Case B: asymmetric masses in a plane\n        [(2.0, (0.0, 0.0, 0.0)), (1.0, (1.0, 0.0, 0.0)), (1.0, (0.0, 1.0, 0.0))],\n        \n        # Case C: degenerate geometry, large dynamic range\n        [(1.0e6, (2.0, 2.0, 2.0)), (2.0e-6, (2.0, 2.0, 2.0)), (3.0, (2.0, 2.0, 2.0))],\n\n        # Case D: colinear positions, varied masses\n        [(1.0, (0.0, 0.0, 0.0)), (2.0, (2.0, 0.0, 0.0)), (3.0, (4.0, 0.0, 0.0)), (4.0, (6.0, 0.0, 0.0))],\n        \n        # Case E: single particle edge case\n        [(1.23, (3.4, -5.6, 7.8))],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_rg2_online(case)\n        results.append(result)\n\n    # Format the final output string with results rounded to 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}