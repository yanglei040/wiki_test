{
    "hands_on_practices": [
        {
            "introduction": "理论上，在微正则系综（NVE）中，一个孤立系统的总能量应该是一个守恒量。然而，在实际的分子动力学模拟中，由于数值积分、力计算和约束算法中引入的系统误差，我们经常观察到总能量的系统性漂移。\n\n这项练习将您置于一个常见的诊断场景中：面对非物理的能量增长，您需要像一位经验丰富的研究者一样，系统地思考并确定最可能的误差来源，从而为确保模拟的物理真实性奠定基础。",
            "id": "3438091",
            "problem": "一个溶剂化的肽在微正则系综 (NVE) 中进行模拟，使用了时间步长为 $2\\,\\mathrm{fs}$ 的辛速度-Verlet积分器，通过线性约束求解器 (LINCS) 处理对涉及氢原子的键的完整约束，通过粒子网格Ewald (PME) 方法计算静电相互作用，并在图形处理器 (GPU) 上使用Verlet邻居列表。观察到总能量 $E(t) = K(t) + U(t)$ 在 $100\\,\\mathrm{ps}$ 内以 $+0.002\\,\\mathrm{kJ\\,mol^{-1}\\,ps^{-1}}$ 的速率近似线性增加。没有启用恒温器或恒压器。从牛顿第二定律 $m_i \\ddot{\\mathbf{r}}_i = \\mathbf{F}_i$ 和保守力的定义 $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U(\\mathbf{r})$ 出发，并回顾对于被精确施加的完整约束 $g_j(\\mathbf{r})=0$，相关的约束力不做功的原理，请论证计算出的力和约束中的系统误差如何导致 NVE 系综下 $E(t)$ 出现单调漂移。然后，在以下选项中，选择一个最恰当地对约束、PME容差、精度模式和邻居列表设置的诊断检查进行优先级排序的选项，并提出与最小化能量漂移、同时保持物理保真度和计算稳定性在科学上一致的修正性参数更改。\n\n选项：\n\nA. 首先优先考虑邻居列表的安全性：验证GPU上的对称粒子对列表，将邻居列表缓冲区 $\\Delta r$ 从 $0.1\\,\\mathrm{nm}$ 增加到 $0.3\\,\\mathrm{nm}$，并将邻居列表更新周期从每 $10$ 步缩短到每 $1$ 步，以避免错过截断半径附近的相互作用。接下来，通过将相对力误差容差从 $10^{-3}$ 降低到 $10^{-5}$ 并增加快速傅里叶变换 (FFT) 网格来收紧PME精度，以维持目标容差。然后，通过将LINCS容差从 $10^{-4}$ 降低到 $10^{-6}$ 并增加最大迭代次数（例如，从 $50$ 次到 $100$ 次）来加强约束的执行；如果约束迭代饱和，则考虑将时间步长减小到 $1\\,\\mathrm{fs}$。最后，通过切换到带有双精度累加的混合精度或用于力和能量求和的完全双精度来提高算术精度。\n\nB. 应用弱恒温器以消除漂移，同时保留NVE标签；放宽PME容差从 $10^{-3}$ 到 $10^{-2}$ 以提高性能；将所有计算切换到单精度以最大化GPU吞吐量；并保持邻居列表缓冲区和更新周期在 $\\Delta r=0.1\\,\\mathrm{nm}$ 和 $20$ 步不变。\n\nC. 大幅将时间步长减小到 $0.5\\,\\mathrm{fs}$，禁用所有约束以避免LINCS迭代，粗化PME网格以降低计算成本，并保持邻居列表参数不变。依赖于更小的时间步长来抑制观察到的能量漂移。\n\nD. 从约束执行开始：将LINCS容差从 $10^{-4}$ 降低到 $10^{-6}$，增加最大迭代次数，并考虑从LINCS切换到SHAKE算法。接下来，将PME容差从 $10^{-3}$ 调整到 $10^{-5}$。然后增加邻居列表缓冲区 $\\Delta r$ 和更新频率以避免粒子对的遗漏。最后，通过使用双精度进行力的累加来提高数值精度，同时保持时间步长为 $2\\,\\mathrm{fs}$。",
            "solution": "该问题要求对在微正则 (NVE) 分子动力学模拟中观察到的能量漂移提供一个论证，并选择最合适的策略来诊断和修正它。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n- 系综：微正则 (NVE)，无恒温器或恒压器。\n- 系统：溶剂化的肽。\n- 积分器：辛速度-Verlet。\n- 时间步长 ($\\Delta t$)：$2\\,\\mathrm{fs}$。\n- 约束：对涉及氢原子的键的完整约束，使用线性约束求解器 (LINCS) 求解。\n- 静电相互作用：粒子网格 Ewald (PME)。\n- 邻居搜索：Verlet 邻居列表。\n- 硬件：图形处理器 (GPU)。\n- 观察现象：总能量 $E(t) = K(t) + U(t)$ 表现出近似线性的增加。\n- 能量漂移速率：$+0.002\\,\\mathrm{kJ\\,mol^{-1}\\,ps^{-1}}$。\n- 观察持续时间：$100\\,\\mathrm{ps}$。\n- 基本方程：$m_i \\ddot{\\mathbf{r}}_i = \\mathbf{F}_i$, $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U(\\mathbf{r})$，以及来自精确完整约束 $g_j(\\mathbf{r})=0$ 的约束力不做功的原理。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题陈述具有科学依据、提法得当且客观。它描述了一个标准的分子动力学模拟设置和一个常见的数值赝象（能量漂移）。所提到的组件（NVE、velocity-Verlet、LINCS、PME）都是标准方法。在给定速率下观察到的正能量漂移或“数值加热”，对于一个时间步长中等偏大（$2\\,\\mathrm{fs}$）的模拟来说是一个现实情景。该问题要求基于第一性原理对此现象进行论证，并评估修正策略，这是计算科学中的一项标准任务。该问题是自洽的，并提供了足够的信息，可以根据该领域已建立的最佳实践来评估所提出的选项。不存在科学、逻辑或事实上的缺陷。\n\n**步骤3：结论和行动**\n问题有效。将提供完整解答。\n\n**能量漂移的论证**\n\n在理想的微正则系综模拟中，总能量 $E(t)$ 必须守恒。这种守恒源于对牛顿运动方程 $m_i \\ddot{\\mathbf{r}}_i = \\mathbf{F}_i$ 的积分，其中力 $\\mathbf{F}_i$ 是保守的，即它们是势能函数 $U(\\mathbf{r})$ 的负梯度，$\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U$。总能量的时间导数为\n$$ \\frac{dE}{dt} = \\frac{d}{dt} \\left( \\sum_i \\frac{1}{2} m_i \\dot{\\mathbf{r}}_i^2 + U(\\mathbf{r}) \\right) = \\sum_i (m_i \\dot{\\mathbf{r}}_i \\cdot \\ddot{\\mathbf{r}}_i + \\nabla_{\\mathbf{r}_i} U \\cdot \\dot{\\mathbf{r}}_i) $$\n代入 $m_i \\ddot{\\mathbf{r}}_i = \\mathbf{F}_i$ 和 $\\nabla_{\\mathbf{r}_i} U = -\\mathbf{F}_i$，我们得到：\n$$ \\frac{dE}{dt} = \\sum_i (\\dot{\\mathbf{r}}_i \\cdot \\mathbf{F}_i - \\mathbf{F}_i \\cdot \\dot{\\mathbf{r}}_i) = 0 $$\n然而，数值模拟引入了若干近似，这些近似破坏了这种精确的守恒，导致能量漂移。\n\n$1$. **离散化误差**：velocity-Verlet 积分器以有限步长 $\\Delta t$ 对时间进行离散化。尽管它是辛的，意味着它守恒一个接近真实哈密顿量的“影子”哈密顿量，但此属性被其他误差源破坏，这些误差可能将有界的能量振荡转变为系统性漂移。\n\n$2$. **力计算中的误差**：计算出的力不是完全保守的。\n    - **邻居列表**：短程力通常是为截断半径内的粒子对计算的。为了避免 $\\mathcal{O}(N^2)$ 的复杂度，会构建一个邻居列表并定期更新。如果缓冲区（$\\Delta r$）太小或更新频率太低，一个粒子可能在下一次更新前移动到超出截断半径加缓冲区的范围。这会导致现有相互作用的突然消失或新相互作用的突然出现。这种力的不连续变化是非保守的，并向系统中注入能量。GPU 实现有时可能存在微妙的错误，例如构建非对称的粒子对列表（其中考虑了粒子 $i$ 对 $j$ 的相互作用，但没有考虑 $j$ 对 $i$ 的），这违反了牛顿第三定律并直接破坏了能量和动量守恒。\n    - **PME 静电学**：PME 方法将计算分为实空间部分（受截断影响，如邻居列表）和倒易空间部分（通过在网格上进行FFT计算）。其精度由一个在两部分误差之间取得平衡的容差参数控制。电荷在网格上的离散化以及在倒易空间中使用的有限傅里叶级数会引入误差，这意味着得到的静电力不是Ewald势的精确梯度。宽松的容差会导致更大的非保守力分量，从而导致能量漂移。\n\n$3$. **约束执行中的误差**：完整约束，例如用LINCS固定键长，是迭代求解至有限容差 $\\epsilon_{LINCS}$ 的。因此，约束条件 $g_j(\\mathbf{r})=0$ 未被精确满足。施加的约束力是近似满足约束所需的力。虽然理想的约束力不做功，但这些近似力可以在许多时间步长内做少量的净功，导致总能量的系统性变化。对于相对较大的 $2\\,\\mathrm{fs}$ 时间步长，约束算法会承受巨大的压力，未能在最大迭代次数内收敛或容差过宽是能量漂移的常见来源。\n\n$4$. **有限精度算术**：所有计算都使用有限精度的浮点数（例如，单精度或双精度）执行。舍入误差会累积，尤其是在大规模求和（如力和能量的计算）中。这会逐渐降低积分的时间可逆性和辛性，导致长期的能量漂移。\n\n观察到的能量线性增加是这些系统误差共同作用，成为“数值加热”源头的典型特征。\n\n**逐项分析选项**\n\n目标是找到诊断检查和修复的最恰当优先级。一种有效的策略是从最可能和影响最大的误差源着手，再到较不常见的误差源，并且倾向于选择计算成本较低的修复方法，而不是成本较高的。\n\n**A. 首先优先考虑邻居列表的安全性：验证GPU上的对称粒子对列表，将邻居列表缓冲区 $\\Delta r$ 从 $0.1\\,\\mathrm{nm}$ 增加到 $0.3\\,\\mathrm{nm}$，并将邻居列表更新周期从每 $10$ 步缩短到每 $1$ 步，以避免错过截断半径附近的相互作用。接下来，通过将相对力误差容差从 $10^{-3}$ 降低到 $10^{-5}$ 并增加快速傅里叶变换 (FFT) 网格来收紧PME精度，以维持目标容差。然后，通过将LINCS容差从 $10^{-4}$ 降低到 $10^{-6}$ 并增加最大迭代次数（例如，从 $50$ 次到 $100$ 次）来加强约束的执行；如果约束迭代饱和，则考虑将时间步长减小到 $1\\,\\mathrm{fs}$。最后，通过切换到带有双精度累加的混合精度或用于力和能量求和的完全双精度来提高算术精度。**\n\n该选项提出了一个高度逻辑化和系统化的诊断层级。\n$1$. **邻居列表：** 它正确地将确保力计算本身没有因缺少相互作用而存在根本性缺陷放在首位。这是不稳定性和能量漂移的主要原因。检查GPU特定的实现细节（如对称粒子对列表）是专家级别的诊断步骤。所提出的参数更改虽然激进，但保证了邻居搜索的安全性，从而将此作为一个潜在问题隔离开来。\n$2$. **PME：** 下一步是提高长程力计算的准确性，这是非保守力的另一个主要来源。\n$3$. **约束：** 然后它处理约束算法的准确性，这对于 $2\\,\\mathrm{fs}$ 时间步长的稳定性至关重要。它正确地提供了在约束算法未能收敛时的应急措施（减小 $\\Delta t$）。\n$4$. **精度：** 最后，它处理了数值精度这个更微妙的问题，这通常是最后的手段。\n这个优先级排序（力计算的正确性 -> 力的准确性 -> 积分的准确性 -> 数值精度）在科学上是合理的，并反映了最佳实践。所提出的更改对于减少能量漂移是恰当的。\n\n**结论：正确**\n\n**B. 应用弱恒温器以消除漂移，同时保留NVE标签；放宽PME容差从 $10^{-3}$ 到 $10^{-2}$ 以提高性能；将所有计算切换到单精度以最大化GPU吞吐量；并保持邻居列表缓冲区和更新周期在 $\\Delta r=0.1\\,\\mathrm{nm}$ 和 $20$ 步不变。**\n\n这个选项存在根本性缺陷。\n$1$. 应用恒温器掩盖了数值不稳定性，而不是修复它。在仍使用恒温器的情况下将模拟标记为NVE是具有欺骗性的；目标是修复导致NVE模拟非保守的根本问题。\n$2$. 将PME容差从 $10^{-3}$ 放宽到 $10^{-2}$ 会*增加*力的误差并*加剧*能量漂移。\n$3$. 如果尚未全部使用单精度，切换到单精度计算更可能增加舍入误差并加剧漂移，而不是减少它。\n$4$. 忽略邻居列表这个主要嫌疑对象是不良实践。\n\n**结论：不正确**\n\n**C. 大幅将时间步长减小到 $0.5\\,\\mathrm{fs}$，禁用所有约束以避免LINCS迭代，粗化PME网格以降低计算成本，并保持邻居列表参数不变。依赖于更小的时间步长来抑制观察到的能量漂移。**\n\n这个选项也存在严重缺陷。\n$1$. 将时间步长减小到 $0.5\\,\\mathrm{fs}$ 是一种暴力方法，由于其高昂的计算成本（增加 $4$ 倍），应作为最后手段。虽然它很可能会减少漂移，但它并没有诊断出实际问题。\n$2$. 禁用约束从根本上改变了所模拟的物理模型。虽然这需要更小的时间步长，但这并不是“修复”，而是改变了研究问题。\n$3$. 粗化PME网格会降低准确性并*增加*能量漂移，直接与目标相矛盾。\n$4$. 保持邻居列表参数不变忽略了一个关键的潜在误差源。\n\n**结论：不正确**\n\n**D. 从约束执行开始：将LINCS容差从 $10^{-4}$ 降低到 $10^{-6}$，增加最大迭代次数，并考虑从LINCS切换到SHAKE算法。接下来，将PME容差从 $10^{-3}$ 调整到 $10^{-5}$。然后增加邻居列表缓冲区 $\\Delta r$ 和更新频率以避免粒子对的遗漏。最后，通过使用双精度进行力的累加来提高数值精度，同时保持时间步长为 $2\\,\\mathrm{fs}$。**\n\n这个选项提出了一套科学上合理的行动，与选项A类似。然而，其优先级次优。它将约束的优先级置于邻居列表之上。虽然在 $2\\,\\mathrm{fs}$ 的时间步长下，约束误差是一个非常可能的罪魁祸首，但一个有缺陷的邻居列表意味着输入到积分器和约束算法中的力从一开始就是不正确的。更合乎逻辑的做法是，首先确保所有相互作用都被正确捕捉（邻居列表的安全性），然后再微调力分量（PME）的准确性以及使用这些力的算法（积分器/约束）。因此，选项A中的层级，即从邻居列表的安全性开始，是更优的。\n\n**结论：不正确**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在认识到精确计算力的重要性之后，我们转向一个具体的优化挑战：为粒子网格Ewald（PME）方法选择最佳参数。PME是处理长程静电相互作用的黄金标准，但其计算成本和精度高度依赖于一系列相互关联的参数，如Ewald分离参数 $\\alpha$、实空间截断半径 $r_c$ 和傅里叶变换网格密度 $n$。\n\n这项实践将指导您通过一个系统的参数扫描过程，在满足给定精度要求的前提下，找到最小化计算成本的“最佳”参数组合，这是规划大规模、高效率模拟的一项核心技能。",
            "id": "3438102",
            "problem": "您正在为将要使用粒子网格埃瓦尔德（PME）方法的经典分子动力学模拟规划生产阶段的静电设置。您必须构建一个程序，对于给定测试套件中的每个系统，选择PME参数以在固定的精度约束下最小化成本模型。您的选择变量是埃瓦尔德分裂参数 $\\,\\alpha\\,$、实空间截断半径 $\\,r_c\\,$、以及一个各向同性的三维网格尺寸 $\\,\\mathbf{n}_{\\mathrm{grid}} = (n,n,n)\\,$，该尺寸受限于快速傅里叶变换（FFT）友好。任务是生成单行输出，汇总所有测试用例的最优选择。\n\n基本原理和定义：\n- 埃瓦尔德求和法将库仑相互作用分解为实空间和倒易空间两部分，由埃瓦尔德分裂参数 $\\,\\alpha\\,$ 控制，使得互补误差函数对短程部分进行加权，高斯屏蔽对长程部分进行加权。\n- 均方根（RMS）力误差被建模为实空间截断误差和倒易空间离散化误差的正交和。我们使用一对被广泛采用且保守的误差模型，这些模型随密度和特征谱隙缩放：\n  1. 实空间均方根力误差模型：\n     $$\\mathcal{E}_{\\mathrm{real}}(\\alpha, r_c; \\rho, q_{\\mathrm{rms}}) \\;=\\; k_{\\mathrm{real}}\\; q_{\\mathrm{rms}}^2 \\, \\sqrt{\\rho}\\, \\exp\\!\\left(-(\\alpha r_c)^2\\right).$$\n  2. 对于使用 $\\,p\\,$ 阶基本B样条分配的光滑粒子网格埃瓦尔德法的倒易空间均方根力误差模型：\n     $$\\mathcal{E}_{\\mathrm{recip}}(\\alpha, n; L, \\rho, q_{\\mathrm{rms}}, p) \\;=\\; k_{\\mathrm{recip}}\\; q_{\\mathrm{rms}}^2 \\, \\sqrt{\\rho}\\; n^{-p}\\, \\exp\\!\\left(-\\left(\\frac{\\pi n}{\\alpha L}\\right)^2\\right).$$\n  总均方根力误差为：\n     $$\\mathcal{E}_{\\mathrm{tot}}(\\alpha, r_c, n) \\;=\\; \\sqrt{\\mathcal{E}_{\\mathrm{real}}(\\alpha, r_c)^2 + \\mathcal{E}_{\\mathrm{recip}}(\\alpha, n)^2}.$$\n- 网格尺寸向量受限于 $\\,\\mathbf{n}_{\\mathrm{grid}} = (n,n,n)\\,$，其中 $\\,n\\,$ 被限制为5-光滑数（其质因数仅为 $\\,2,3,5\\,$），从有界区间 $[n_{\\min}, n_{\\max}]$ 中选取。\n- 模拟盒子是边长为 $\\,L\\,$ 的立方体，包含 $\\,N\\,$ 个粒子，数密度为 $\\,\\rho = N/L^3\\,$。对于此规划问题，所有量均视为无量纲。误差容限 $\\,\\varepsilon\\,$ 是特征力标度的无量纲分数。成本以每步的任意时间单位计。\n- 每个时间步的计算成本建模为三个分量的总和：\n  - 在截断半径 $\\,r_c\\,$ 内使用 Verlet 列表的实空间对计算：\n    $$C_{\\mathrm{real}}(N, \\rho, r_c) \\;=\\; c_{\\mathrm{pair}}\\; N\\, \\rho\\, r_c^3.$$\n  - 使用 $\\,p\\,$ 阶B样条在网格上进行电荷分布和力收集：\n    $$C_{\\mathrm{spread}}(n, p) \\;=\\; c_{\\mathrm{spread}}\\, p^3\\, n^3.$$\n  - 三维快速傅里叶变换（FFT）：\n    $$C_{\\mathrm{FFT}}(n) \\;=\\; c_{\\mathrm{FFT}}\\, n^3 \\log_2(n^3).$$\n  总成本为：\n    $$C_{\\mathrm{tot}} \\;=\\; C_{\\mathrm{real}} + C_{\\mathrm{spread}} + C_{\\mathrm{FFT}}.$$\n\n优化问题：\n- 给定 $\\,N, L, q_{\\mathrm{rms}}, p, \\varepsilon\\,$、常数 $\\,k_{\\mathrm{real}}, k_{\\mathrm{recip}}, c_{\\mathrm{pair}}, c_{\\mathrm{spread}}, c_{\\mathrm{FFT}}\\,$ 以及 $\\,r_c, \\alpha, n\\,$ 的界限，选择 $\\,(\\alpha, r_c, n)\\,$ 以最小化 $\\,C_{\\mathrm{tot}}\\,$，约束条件为：\n  $$\\mathcal{E}_{\\mathrm{tot}}(\\alpha, r_c, n) \\;\\le\\; \\varepsilon.$$\n- 为实际的生产运行，搜索域受到以下约束：\n  - 截断范围：$\\,r_c \\in [r_{c,\\min}, r_{c,\\max}]$，其中 $\\,r_{c,\\min} = 0.5\\,$ 且 $\\,r_{c,\\max} = 0.49 L\\,$。\n  - 与 $\\,r_c\\,$ 相关的埃瓦尔德分裂范围：$\\,\\alpha \\in [\\alpha_{\\min}(r_c), \\alpha_{\\max}(r_c)]\\,$，其中 $\\,\\alpha_{\\min}(r_c) = 0.5/r_c\\,$ 且 $\\,\\alpha_{\\max}(r_c) = 3.5/r_c\\,$。\n  - 网格尺寸：$\\,n \\in \\mathcal{N}\\,$，即在 $[n_{\\min}, n_{\\max}]$ 区间内的5-光滑数集合，其中 $\\,n_{\\min} = 32\\,$ 且 $\\,n_{\\max} = 128\\,$。\n- 如果没有可行的三元组 $\\,(\\alpha, r_c, n)\\,$ 满足误差约束，则报告不可行的结果。\n\n使用的常数：\n- 误差模型常数：$\\,k_{\\mathrm{real}} = 1.0\\,$ 和 $\\,k_{\\mathrm{recip}} = 1.0\\,$。\n- 成本模型常数：$\\,c_{\\mathrm{pair}} = 10^{-6}\\,$、$\\,c_{\\mathrm{spread}} = 2\\times 10^{-7}\\,$ 和 $\\,c_{\\mathrm{FFT}} = 5\\times 10^{-6}\\,$。\n\n所需输出：\n- 对于每个测试用例，您的程序必须将所选参数和度量指标输出为一个列表：\n  $$[\\alpha^\\star, r_c^\\star, n^\\star, C_{\\mathrm{tot}}^\\star, \\mathcal{E}_{\\mathrm{tot}}^\\star, \\text{feasible}],$$\n  其中 $\\,\\text{feasible}\\,$ 是一个布尔值，当存在可行解时为真，否则为假。所有浮点输出必须四舍五入到 $\\,6\\,$ 位小数。如果不可行，则为该测试用例返回 $\\,[-1,-1,-1,-1,-1,\\text{False}]\\,$。\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的各测试用例列表的列表，并用一对单独的方括号括起来。例如：`[[...],[...],[...]]`。\n\n测试套件：\n使用以下四个测试用例，每个用例由元组 $\\, (N, L, q_{\\mathrm{rms}}, p, \\varepsilon)\\,$ 描述：\n1. $\\, (100000,\\, 10.0,\\, 0.30,\\, 4,\\, 10^{-3})\\,$.\n2. $\\, (100000,\\, 10.0,\\, 0.30,\\, 4,\\, 3\\times 10^{-5})\\,$.\n3. $\\, (5000,\\, 6.0,\\, 0.50,\\, 6,\\, 5\\times 10^{-4})\\,$.\n4. $\\, (200000,\\, 8.0,\\, 0.25,\\, 6,\\, 10^{-5})\\,$.\n\n算法要求：\n- 您的程序必须在离散集合 $\\,\\mathcal{N}\\,$ 中搜索 $\\,n\\,$，并在指定范围内对 $\\,r_c\\,$ 和 $\\,\\alpha\\,$ 进行均匀网格采样。在 $[r_{c,\\min}, r_{c,\\max}]$ 内为 $\\,r_c\\,$ 使用至少 $\\,40\\,$ 个线性间隔的样本，对于每个 $\\,r_c\\,$，在 $[\\alpha_{\\min}(r_c), \\alpha_{\\max}(r_c)]$ 内为 $\\,\\alpha\\,$ 使用至少 $\\,40\\,$ 个线性间隔的样本。\n- 对于每个可行的组合，计算总成本并选择成本最小的组合。通过优先选择较小的 $\\,n\\,$，然后是较小的 $\\,r_c\\,$，再然后是较小的 $\\,\\alpha\\,$ 来打破僵局。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个列表，该列表内含四个子列表，分别对应四个测试用例，每个子列表都具有上面指定的格式和舍入要求，不得包含其他文本。例如：\n  `[[a1,rc1,n1,c1,e1,True],[a2,rc2,n2,c2,e2,True],[...],[...]]`。",
            "solution": "所呈现的问题是一个约束优化任务，是规划采用粒子网格埃瓦尔德（PME）方法处理长程静电相互作用的分子动力学模拟的核心。目标是选择一组PME参数——埃瓦尔德分裂参数 $\\alpha$、实空间截断距离 $r_c$ 和FFT网格维度 $n$——以最小化每个时间步的计算成本 $C_{\\mathrm{tot}}$，同时满足用户定义的对均方根（RMS）力误差 $\\mathcal{E}_{\\mathrm{tot}}$ 的容限 $\\varepsilon$。\n\n首先，我们重申所提供的控制性数学模型。总均方根力误差 $\\mathcal{E}_{\\mathrm{tot}}$ 是实空间求和与倒易空间求和贡献的正交和：\n$$\n\\mathcal{E}_{\\mathrm{tot}}(\\alpha, r_c, n) = \\sqrt{\\mathcal{E}_{\\mathrm{real}}(\\alpha, r_c)^2 + \\mathcal{E}_{\\mathrm{recip}}(\\alpha, n)^2}\n$$\n实空间误差 $\\mathcal{E}_{\\mathrm{real}}$ 源于在截断半径 $r_c$ 处截断短程相互作用：\n$$\n\\mathcal{E}_{\\mathrm{real}}(\\alpha, r_c; \\rho, q_{\\mathrm{rms}}) = k_{\\mathrm{real}} q_{\\mathrm{rms}}^2 \\sqrt{\\rho} \\exp(-(\\alpha r_c)^2)\n$$\n倒易空间误差 $\\mathcal{E}_{\\mathrm{recip}}$ 源于将倒易空间离散化到尺寸为 $\\mathbf{n}_{\\mathrm{grid}} = (n,n,n)$ 的网格上：\n$$\n\\mathcal{E}_{\\mathrm{recip}}(\\alpha, n; L, \\rho, q_{\\mathrm{rms}}, p) = k_{\\mathrm{recip}} q_{\\mathrm{rms}}^2 \\sqrt{\\rho} n^{-p} \\exp\\left(-\\left(\\frac{\\pi n}{\\alpha L}\\right)^2\\right)\n$$\n这里，$\\rho = N/L^3$ 是粒子数密度，$q_{\\mathrm{rms}}$ 是均方根粒子电荷，$L$ 是立方盒子边长，$p$ 是B样条插值阶数。常数 $k_{\\mathrm{real}}$ 和 $k_{\\mathrm{recip}}$ 给定为 $1.0$。\n\n总计算成本 $C_{\\mathrm{tot}}$ 建模为三个主要分量的总和：\n$$\nC_{\\mathrm{tot}}(r_c, n; N, \\rho, p) = C_{\\mathrm{real}}(r_c) + C_{\\mathrm{spread}}(n) + C_{\\mathrm{FFT}}(n)\n$$\n其中：\n- $C_{\\mathrm{real}}(N, \\rho, r_c) = c_{\\mathrm{pair}} N \\rho r_c^3$ 是实空间对计算的成本。\n- $C_{\\mathrm{spread}}(n, p) = c_{\\mathrm{spread}} p^3 n^3$ 是将电荷分布到网格和收集力的成本。\n- $C_{\\mathrm{FFT}}(n) = c_{\\mathrm{FFT}} n^3 \\log_2(n^3)$ 是三维快速傅里叶变换的成本。\n成本常数指定为 $c_{\\mathrm{pair}} = 10^{-6}$，$c_{\\mathrm{spread}} = 2\\times 10^{-7}$，以及 $c_{\\mathrm{FFT}} = 5\\times 10^{-6}$。\n\n优化问题是找到 $(\\alpha^\\star, r_c^\\star, n^\\star)$，在约束条件 $\\mathcal{E}_{\\mathrm{tot}} \\le \\varepsilon$ 下最小化 $C_{\\mathrm{tot}}$。搜索空间由以下参数定义：\n- $n \\in \\mathcal{N}$，即在区间 $[32, 128]$ 内的5-光滑数（质因数 $\\in \\{2,3,5\\}$）集合。\n- $r_c \\in [r_{c,\\min}, r_{c,\\max}] = [0.5, 0.49 L]$。\n- $\\alpha \\in [\\alpha_{\\min}(r_c), \\alpha_{\\max}(r_c)] = [0.5/r_c, 3.5/r_c]$。\n\n鉴于误差函数和成本函数的非线性及耦合特性，解析解是难以处理的。规定的求解方法是在离散化的参数空间上进行系统性的网格搜索。$n$ 的离散性构成了搜索的基础。对于每个有效的整数 $n$，对 $r_c$ 和 $\\alpha$ 的连续域进行均匀采样。具体来说，我们在 $r_c$ 的范围内使用 $40$ 个采样点，并且对于每个 $r_c$，在其对应的 $\\alpha$ 范围内使用 $40$ 个采样点。\n\n对于每个测试用例，算法按以下步骤进行：\n1.  生成在 $[32, 128]$ 范围内已排序的5-光滑数列表 $\\mathcal{N}$。\n2.  为最优参数初始化一个跟踪元组 $(C_{\\mathrm{best}}, n_{\\mathrm{best}}, r_{c, \\mathrm{best}}, \\alpha_{\\mathrm{best}})$，其中 $C_{\\mathrm{best}}$ 设置为无穷大。选择此结构是为了方便进行字典序比较，这自然地实现了指定的打破僵局规则：优先考虑更低的成本，然后是更小的 $n$，接着是更小的 $r_c$，最后是更小的 $\\alpha$。\n3.  遍历 $\\mathcal{N}$ 中的每个 $n$。对于每个 $n$，遍历 $r_c$ 的 $40$ 个样本。对于每对 $(n, r_c)$，遍历 $\\alpha$ 的 $40$ 个样本。\n4.  在搜索网格的每个点 $(\\alpha, r_c, n)$ 处，计算总误差 $\\mathcal{E}_{\\mathrm{tot}}$。\n5.  通过将计算出的误差与容限进行比较来检查可行性：$\\mathcal{E}_{\\mathrm{tot}} \\le \\varepsilon$。\n6.  如果参数集是可行的，则计算总成本 $C_{\\mathrm{tot}}$。\n7.  将当前可行解的字典序元组 $(C_{\\mathrm{tot}}, n, r_c, \\alpha)$ 与迄今为止的最佳元组进行比较。如果当前元组更小，它就成为新的最优解，并存储其参数和误差。\n8.  在搜索完整个网格后，如果找到了一个可行解，则记录最优参数 $(\\alpha^\\star, r_c^\\star, n^\\star)$、最小成本 $C_{\\mathrm{tot}}^\\star$ 和相应的误差 $\\mathcal{E}_{\\mathrm{tot}}^\\star$。否则，该案例被标记为不可行。\n9.  根据要求，将每个测试用例的最终结果格式化并汇总到单个列表结构中。浮点值格式化为6位小数。\n\n这种暴力搜索保证了在离散化空间内找到最优参数。输出是为所提供的测试系统套件收集的这些最优设置。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Finds optimal PME parameters by performing a grid search for a series of test cases.\n    \"\"\"\n\n    # Define constants from the problem statement.\n    K_REAL = 1.0\n    K_RECIP = 1.0\n    C_PAIR = 1.0e-6\n    C_SPREAD = 2.0e-7\n    C_FFT = 5.0e-6\n    N_MIN = 32\n    N_MAX = 128\n    RC_MIN_VAL = 0.5\n    NUM_SAMPLES = 40\n\n    test_cases = [\n        (100000, 10.0, 0.30, 4, 1e-3),\n        (100000, 10.0, 0.30, 4, 3e-5),\n        (5000, 6.0, 0.50, 6, 5e-4),\n        (200000, 8.0, 0.25, 6, 1e-5),\n    ]\n\n    def generate_smooth_numbers(n_min, n_max):\n        \"\"\"Generates 5-smooth integers within a given range.\"\"\"\n        nums = {1}\n        q = [1]\n        head = 0\n        # Generate all 5-smooth numbers up to n_max\n        while head  len(q):\n            curr = q[head]\n            head += 1\n            for factor in [2, 3, 5]:\n                next_val = curr * factor\n                if next_val = n_max and next_val not in nums:\n                    nums.add(next_val)\n                    q.append(next_val)\n        # Filter by n_min and sort\n        return sorted([x for x in nums if x >= n_min])\n\n    n_smooth_list = generate_smooth_numbers(N_MIN, N_MAX)\n    \n    all_results = []\n    \n    for case in test_cases:\n        N, L, q_rms, p, epsilon = case\n        rho = N / (L**3)\n\n        best_params_tuple = (float('inf'), -1, -1.0, -1.0)  # (cost, n, rc, alpha)\n        best_error = -1.0\n        found_feasible = False\n\n        # Pre-calculate reciprocal space cost components which only depend on n and p\n        cost_recip_map = {}\n        for n_val in n_smooth_list:\n            c_spread = C_SPREAD * (p**3) * (n_val**3)\n            c_fft = C_FFT * (n_val**3) * np.log2(n_val**3)\n            cost_recip_map[n_val] = c_spread + c_fft\n\n        for n in n_smooth_list:\n            rc_max = 0.49 * L\n            rc_samples = np.linspace(RC_MIN_VAL, rc_max, NUM_SAMPLES)\n            \n            cost_recip = cost_recip_map[n]\n\n            for r_c in rc_samples:\n                alpha_min = 0.5 / r_c\n                alpha_max = 3.5 / r_c\n                alpha_samples = np.linspace(alpha_min, alpha_max, NUM_SAMPLES)\n\n                cost_real = C_PAIR * N * rho * r_c**3\n\n                common_err_factor = (q_rms**2) * np.sqrt(rho)\n                e_real_base = K_REAL * common_err_factor\n                e_recip_base = K_RECIP * common_err_factor * (n**(-p))\n                \n                for alpha in alpha_samples:\n                    # Error Calculation\n                    e_real_sq_arg = -((alpha * r_c)**2)\n                    e_real = e_real_base * np.exp(e_real_sq_arg)\n\n                    e_recip_sq_arg = -((np.pi * n) / (alpha * L))**2\n                    e_recip = e_recip_base * np.exp(e_recip_sq_arg)\n\n                    e_tot = np.sqrt(e_real**2 + e_recip**2)\n\n                    if e_tot = epsilon:\n                        found_feasible = True\n                        \n                        # Cost Calculation\n                        cost_tot = cost_real + cost_recip\n                        \n                        current_params_tuple = (cost_tot, n, r_c, alpha)\n                        if current_params_tuple  best_params_tuple:\n                            best_params_tuple = current_params_tuple\n                            best_error = e_tot\n        \n        if found_feasible:\n            opt_cost, opt_n, opt_rc, opt_alpha = best_params_tuple\n            result = [opt_alpha, opt_rc, opt_n, opt_cost, best_error, True]\n        else:\n            result = [-1, -1, -1, -1, -1, False]\n        \n        all_results.append(result)\n\n    # Format the final output string exactly as specified.\n    output_parts = []\n    for res in all_results:\n        if res[-1] is False:\n            output_parts.append(\"[-1,-1,-1,-1,-1,False]\")\n        else:\n            alpha, rc, n, cost, error, _ = res\n            part = (f\"[{alpha:.6f},{rc:.6f},{n},\"\n                    f\"{cost:.6f},{error:.6f},True]\")\n            output_parts.append(part)\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    print(final_output_string)\n\nsolve()\n\n```"
        },
        {
            "introduction": "一旦我们建立了一个数值稳定且计算高效的模拟方案，下一个关键问题便是：“模拟需要运行多长时间？” 这个问题的答案取决于我们希望达到的统计精度。\n\n这项练习将引导您推导并应用一个基础但至关重要的关系，该关系将模拟总时长 $T$ 与可观测量 $A$ 的统计不确定性联系起来。通过理解可观测量方差 $\\sigma_A^2$ 和积分自相关时间 $\\tau_{\\mathrm{int}}$ 的作用，您将学会如何预估所需的生产阶段时长，以确保您的模拟结果具有指定的统计可靠性。",
            "id": "3438067",
            "problem": "计划进行一次生产性的分子动力学（MD）模拟，以估算某个可观测量 $A(t)$（例如，瞬时摩尔势能）的时间平均值，并达到预设的精度。已经进行了一次简短的引导性模拟，并且在丢弃平衡阶段后，时间序列 $A(t)$ 表现出平稳性和遍历性。从引导性模拟数据中，获得了以下估计值：积分自相关时间 $\\tau_{\\mathrm{int}}$ 和方差 $\\sigma_{A}^{2} \\equiv \\langle (A - \\langle A \\rangle)^{2} \\rangle$。生产性模拟的轨迹将足够长，使得总生产时间 $T$ 满足 $T \\gg \\tau_{\\mathrm{int}}$，并且采样在时间上是均匀的。\n\n对于一个平稳过程，从时间平均值 $\\bar{A}_{T} \\equiv \\frac{1}{T} \\int_{0}^{T} A(t) \\, dt$ 和自协方差函数 $C_{A}(t) \\equiv \\langle (A(0) - \\langle A \\rangle)(A(t) - \\langle A \\rangle) \\rangle$ 的定义出发，推导 $\\bar{A}_{T}$ 的渐近方差的表达式，用 $\\sigma_{A}^{2}$、$\\tau_{\\mathrm{int}}$ 和 $T$ 表示。然后使用此表达式确定为使估计量 $\\bar{A}_{T}$ 达到目标标准误差 $\\sigma_{\\bar{A}}$ 所需的生产时间 $T$。\n\n为了规划，请使用引导性模拟的估计值 $\\tau_{\\mathrm{int}} = 25\\,\\mathrm{ps}$ 和 $\\sigma_{A}^{2} = 400\\,(\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2}$，并要求目标标准误差为 $\\sigma_{\\bar{A}} = 1\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。将最终所需的生产时间 $T$ 以纳秒表示，并将答案四舍五入到三位有效数字。",
            "solution": "该问题要求从分子动力学（MD）模拟中推导时间平均可观测量的方差，并随后计算达到目标精度所需的模拟时长。该问题具有科学依据，提法明确，并包含了所有必要信息。我们可以开始求解。\n\n首先，我们推导时间平均值 $\\bar{A}_{T}$ 的方差表达式。在总时间 $T$ 内，可观测量 $A(t)$ 的时间平均值定义为：\n$$\n\\bar{A}_{T} \\equiv \\frac{1}{T} \\int_{0}^{T} A(t) \\, dt\n$$\n该估计量的方差，记为 $\\sigma_{\\bar{A}_{T}}^{2}$，由 $\\sigma_{\\bar{A}_{T}}^{2} = \\langle (\\bar{A}_{T} - \\langle \\bar{A}_{T} \\rangle)^{2} \\rangle$ 给出，其中 $\\langle \\cdot \\rangle$ 表示系综平均。对于平稳过程，系综平均 $\\langle A(t) \\rangle$ 与时间无关，等于我们记为 $\\langle A \\rangle$ 的真实平均值。估计量 $\\bar{A}_{T}$ 的系综平均为：\n$$\n\\langle \\bar{A}_{T} \\rangle = \\left\\langle \\frac{1}{T} \\int_{0}^{T} A(t) \\, dt \\right\\rangle = \\frac{1}{T} \\int_{0}^{T} \\langle A(t) \\rangle \\, dt = \\frac{1}{T} \\int_{0}^{T} \\langle A \\rangle \\, dt = \\frac{1}{T} \\langle A \\rangle [t]_{0}^{T} = \\langle A \\rangle\n$$\n这表明 $\\bar{A}_{T}$ 是 $\\langle A \\rangle$ 的一个无偏估计量。因此，方差可以写为：\n$$\n\\sigma_{\\bar{A}_{T}}^{2} = \\langle (\\bar{A}_{T} - \\langle A \\rangle)^{2} \\rangle\n$$\n代入 $\\bar{A}_{T}$ 的定义并引入涨落项 $\\delta A(t) = A(t) - \\langle A \\rangle$：\n$$\n\\sigma_{\\bar{A}_{T}}^{2} = \\left\\langle \\left( \\frac{1}{T} \\int_{0}^{T} A(t) \\, dt - \\langle A \\rangle \\right)^{2} \\right\\rangle = \\left\\langle \\left( \\frac{1}{T} \\int_{0}^{T} (A(t) - \\langle A \\rangle) \\, dt \\right)^{2} \\right\\rangle = \\frac{1}{T^{2}} \\left\\langle \\left( \\int_{0}^{T} \\delta A(t) \\, dt \\right)^{2} \\right\\rangle\n$$\n我们可以将积分的平方写成一个二重积分：\n$$\n\\sigma_{\\bar{A}_{T}}^{2} = \\frac{1}{T^{2}} \\left\\langle \\int_{0}^{T} \\delta A(t) \\, dt \\int_{0}^{T} \\delta A(t') \\, dt' \\right\\rangle\n$$\n根据期望算子的线性性质，我们可以将其移到积分内部：\n$$\n\\sigma_{\\bar{A}_{T}}^{2} = \\frac{1}{T^{2}} \\int_{0}^{T} dt \\int_{0}^{T} dt' \\, \\langle \\delta A(t) \\delta A(t') \\rangle\n$$\n对于平稳过程，相关性 $\\langle \\delta A(t) \\delta A(t') \\rangle$ 仅取决于时间差 $|t' - t|$。这正是自协方差函数 $C_{A}(\\tau) = \\langle \\delta A(0) \\delta A(\\tau) \\rangle$ 的定义。因此，$\\langle \\delta A(t) \\delta A(t') \\rangle = C_{A}(t' - t)$。\n$$\n\\sigma_{\\bar{A}_{T}}^{2} = \\frac{1}{T^{2}} \\int_{0}^{T} dt \\int_{0}^{T} dt' \\, C_{A}(t' - t)\n$$\n这个在方形域上的二重积分可以被简化。使用恒等式 $\\int_{0}^{L} \\int_{0}^{L} f(|x-y|) \\, dy \\, dx = 2 \\int_{0}^{L} (L-z) f(z) \\, dz$ 并注意到自协方差函数是偶函数，即 $C_{A}(\\tau) = C_{A}(-\\tau)$，我们有：\n$$\n\\sigma_{\\bar{A}_{T}}^{2} = \\frac{2}{T^{2}} \\int_{0}^{T} (T - \\tau) C_{A}(\\tau) \\, d\\tau = \\frac{2}{T} \\int_{0}^{T} \\left(1 - \\frac{\\tau}{T}\\right) C_{A}(\\tau) \\, d\\tau\n$$\n问题陈述总生产时间 $T$ 远大于积分自相关时间，即 $T \\gg \\tau_{\\mathrm{int}}$。自协方差 $C_{A}(\\tau)$ 在以 $\\tau_{\\mathrm{int}}$ 为特征的时间尺度上衰减至零。因此，在积分区间内 $C_{A}(\\tau)$ 不为零的主要部分，我们有 $\\tau \\ll T$。这允许我们做两个近似：\n1.  项 $(1 - \\frac{\\tau}{T}) \\approx 1$。\n2.  积分上限可以从 $T$ 扩展到 $\\infty$，误差可以忽略不计。\n应用这些近似，我们得到渐近方差：\n$$\n\\sigma_{\\bar{A}_{T}}^{2} \\approx \\frac{2}{T} \\int_{0}^{\\infty} C_{A}(\\tau) \\, d\\tau\n$$\n问题给出了方差 $\\sigma_{A}^{2}$ 和积分自相关时间 $\\tau_{\\mathrm{int}}$ 的定义。可观测量 $A$ 的方差是 $\\sigma_{A}^{2} = C_{A}(0)$。积分自相关时间的标准定义是*归一化*自相关函数的积分：\n$$\n\\tau_{\\mathrm{int}} = \\int_{0}^{\\infty} \\frac{C_{A}(\\tau)}{C_{A}(0)} \\, d\\tau = \\frac{1}{\\sigma_{A}^{2}} \\int_{0}^{\\infty} C_{A}(\\tau) \\, d\\tau\n$$\n由此，我们发现 $\\int_{0}^{\\infty} C_{A}(\\tau) \\, d\\tau = \\sigma_{A}^{2} \\tau_{\\mathrm{int}}$。将此代入我们关于均值方差的表达式，得到所需的关系：\n$$\n\\sigma_{\\bar{A}_{T}}^{2} \\approx \\frac{2 \\sigma_{A}^{2} \\tau_{\\mathrm{int}}}{T}\n$$\n接下来，我们使用这个表达式来确定所需的生产时间 $T$。估计量的目标标准误差是 $\\sigma_{\\bar{A}}$，它是方差的平方根，即 $\\sigma_{\\bar{A}} = \\sqrt{\\sigma_{\\bar{A}_{T}}^{2}}$。两边平方得到 $\\sigma_{\\bar{A}}^{2} = \\sigma_{\\bar{A}_{T}}^{2}$。现在我们可以解出 $T$：\n$$\nT \\approx \\frac{2 \\sigma_{A}^{2} \\tau_{\\mathrm{int}}}{\\sigma_{\\bar{A}}^{2}}\n$$\n我们已知以下引导性模拟估计值和目标精度：\n- $\\tau_{\\mathrm{int}} = 25\\,\\mathrm{ps}$\n- $\\sigma_{A}^{2} = 400\\,(\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2}$\n- $\\sigma_{\\bar{A}} = 1\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$，这意味着 $\\sigma_{\\bar{A}}^{2} = (1\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2} = 1\\,(\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2}$。\n\n将这些值代入 $T$ 的表达式中：\n$$\nT \\approx \\frac{2 \\times 400\\,(\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2} \\times 25\\,\\mathrm{ps}}{1\\,(\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2}}\n$$\n$(\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2}$ 的单位相互抵消，剩下时间的单位是皮秒：\n$$\nT \\approx (2 \\times 400 \\times 25)\\,\\mathrm{ps} = (800 \\times 25)\\,\\mathrm{ps} = 20000\\,\\mathrm{ps}\n$$\n问题要求答案以纳秒（ns）为单位。因为 $1\\,\\mathrm{ns} = 1000\\,\\mathrm{ps}$：\n$$\nT \\approx 20000\\,\\mathrm{ps} \\times \\frac{1\\,\\mathrm{ns}}{1000\\,\\mathrm{ps}} = 20\\,\\mathrm{ns}\n$$\n最后，我们必须将答案四舍五入到三位有效数字。\n$$\nT = 20.0\\,\\mathrm{ns}\n$$\n作为一致性检查，我们的结果 $T = 20000\\,\\mathrm{ps}$ 确实远大于 $\\tau_{\\mathrm{int}} = 25\\,\\mathrm{ps}$（大了800倍），这验证了推导中使用的渐近近似的有效性。",
            "answer": "$$\\boxed{20.0}$$"
        }
    ]
}