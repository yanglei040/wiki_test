{
    "hands_on_practices": [
        {
            "introduction": "在分析构象系综时，一个基本挑战是如何正确处理像二面角这样的周期性数据。直接进行算术平均可能会因任意选择的边界（如 $-\\pi$ 和 $\\pi$）而导致错误的结论。本练习将引导你从第一性原理出发 ，推导出一个适用于环形空间（如拉氏图）的聚类中心定义，从而掌握处理周期性数据的核心原则。",
            "id": "3401852",
            "problem": "在分子动力学（MD）分析构象系综时，主链二面角是圆的元素，这意味着任何二面角 $\\theta$ 对于任意整数 $k$ 都物理等价于 $\\theta + 2\\pi k$。在类拉马钱德兰空间中，一个构象由一对 $(\\phi, \\psi)$ 描述，其中两个坐标都位于圆的乘积（一个2-环面）上。考虑通过平均来为一组构象定义一个簇中心的目标。仅从二面角以 $2\\pi$ 为周期以及旋转在圆上复合这些基本事实出发，分析在实直线上进行算术平均是否合适，并推导出一个尊重圆上旋转对称性的、有原则的簇中心构造方法。\n\n给定一个由3个构象组成的系综，其二面角对 $(\\phi, \\psi)$ 分别为：\n- $x_1 = (\\pi - 0.1, \\pi - 0.2)$，\n- $x_2 = (-\\pi + 0.1, -\\pi + 0.2)$，\n- $x_3 = (-\\pi, -\\pi)$。\n\n除非另有说明，假设角度在数值上表示于主分支 $(-\\pi, \\pi]$ 内。基于角度周期性和圆上对称性的第一性原理，评估欧几里得平均的失效模式，并提出一个适用于2-环面的簇中心定义。然后，将你的推理应用于此数据集以确定簇中心的位置。\n\n下列哪个陈述是正确的？\n\nA. 因为三个 $\\phi$ 值和三个 $\\psi$ 值对称地排列在分支切割周围，所以在 $(-\\pi, \\pi]$ 区间内角度的欧几里得平均值产生正确的中心；数值上，该中心为 $(\\bar{\\phi}, \\bar{\\psi}) = (-\\pi/3, -\\pi/3)$。\n\nB. 任何角度的平均过程都必须对于加上 $2\\pi$ 的整数倍是不变的。一种尊重此不变性的构造方法，通过组合圆上的方向然后提取平均方向，对于此数据集得出的簇中心 $(\\bar{\\phi}, \\bar{\\psi})$ 在模 $2\\pi$ 意义下等于 $(\\pi, \\pi)$。\n\nC. 在进行欧几里得平均之前，将角度重新包装到 $[0, 2\\pi)$ 区间通常可以解决分支切割问题；它能为任何角度数据集保证一个与表示无关且正确的中心。\n\nD. 对于类拉马钱德兰空间上的k-均值聚类，一种有原则的修改方法是用每个圆上单位向量的弦距离的平方替换角度坐标中的欧几里得距离的平方，并通过归一化每个角度坐标中的向量和来更新质心；这会产生一个对旋转是等变的质心，并且当合向量长度非零时有良好定义。",
            "solution": "从二面角作为单位圆上一点的基本表示开始。任何物理角度 $\\theta$ 是一个等价类，遵循 $\\theta \\sim \\theta + 2\\pi k$（对于任何整数 $k$），因此平均必须尊重这种商关系。欧几里得平均的失败源于实直线上的算术平均值依赖于所选的分支切割，而分支切割是一个没有物理意义的任意表示选择。\n\n基于原理推导圆上的圆周平均值：\n- 圆带有一种自然的旋转概念：如果 $\\theta_i$ 是观测到的角度，并且我们将所有观测值旋转一个角度 $\\alpha$，任何合理的平均值 $\\mu$ 都应该旋转到 $\\mu + \\alpha$。这就是旋转等变性。\n- 获得此类估计量的一种标准方法是将每个角度 $\\theta_i$ 嵌入为圆上的单位向量 $\\mathbf{u}_i = (\\cos\\theta_i, \\sin\\theta_i)$，在平面中对这些向量进行平均 $\\mathbf{R} = \\sum_i \\mathbf{u}_i$，并将平均方向取为 $\\mathbf{R}$ 的辐角：$\\mu = \\operatorname{atan2}(R_y, R_x)$，其中 $(R_x, R_y)$ 是 $\\mathbf{R}$ 的分量。等价地，在复数表示法中，映射 $\\theta_i \\mapsto e^{\\mathrm{i}\\theta_i}$ 并设 $\\mu = \\arg\\left(\\sum_i e^{\\mathrm{i}\\theta_i}\\right)$。这种构造在 $\\theta_i \\mapsto \\theta_i + 2\\pi k_i$ 下是不变的，是旋转等变的，并且与冯·米塞斯分布（一种经典的圆周分布）下位置参数的最大似然估计（MLE）相吻合。\n- 在用于 $(\\phi, \\psi)$ 的2-环面上，使用乘积度量，圆周平均是解耦的，并且可以通过在每个圆上应用上述构造逐分量获得，前提是合向量长度非零，从而使方向有定义。\n\n对数据集的定量应用：\n- 计算在 $(-\\pi, \\pi]$ 区间内的欧几里得平均值以展示其失败。对于 $\\phi$：\n$$\\bar{\\phi}_{\\text{Euc}} = \\frac{(\\pi - 0.1) + (-\\pi + 0.1) + (-\\pi)}{3} = \\frac{-\\pi}{3} = -\\frac{\\pi}{3}.$$\n对于 $\\psi$：\n$$\\bar{\\psi}_{\\text{Euc}} = \\frac{(\\pi - 0.2) + (-\\pi + 0.2) + (-\\pi)}{3} = \\frac{-\\pi}{3} = -\\frac{\\pi}{3}.$$\n这些值远离靠近分支切割的实际密集区域。这种对所选分支 $(-\\pi, \\pi]$ 的依赖性立即显示了表示依赖性。\n\n- 如果我们转而将角度重新包装到 $[0, 2\\pi)$，则数值表示变为，对于 $\\phi$：$\\pi - 0.1$, $\\pi + 0.1$, 和 $\\pi$（因为 $-\\pi \\equiv \\pi$），其欧几里得平均值为\n$$\\frac{(\\pi - 0.1) + (\\pi + 0.1) + \\pi}{3} = \\pi.$$\n对于 $\\psi$，类似地：\n$$\\frac{(\\pi - 0.2) + (\\pi + 0.2) + \\pi}{3} = \\pi.$$\n这得出 $(\\pi, \\pi)$，表明欧几里得平均值依赖于任意的分支切割，因此它不是表示无关的，也不是一个有原则的构造方法。\n\n- 现在使用向量加法计算圆周平均值。对于任何小的 $\\epsilon > 0$，我们有\n$$e^{\\mathrm{i}(\\pi - \\epsilon)} = -\\cos\\epsilon + \\mathrm{i}\\sin\\epsilon,\\quad e^{\\mathrm{i}(-\\pi + \\epsilon)} = -\\cos\\epsilon - \\mathrm{i}\\sin\\epsilon,\\quad e^{\\mathrm{i}(-\\pi)} = -1.$$\n因此，对于 $\\phi$ 且 $\\epsilon = 0.1$，\n$$\\sum_{j=1}^{3} e^{\\mathrm{i}\\phi_j} = \\left(-\\cos 0.1 + \\mathrm{i}\\sin 0.1\\right) + \\left(-\\cos 0.1 - \\mathrm{i}\\sin 0.1\\right) + (-1) = -2\\cos 0.1 - 1.$$\n虚部抵消，留下一个负实数；因此平均方向是\n$$\\bar{\\phi}_{\\text{circ}} = \\arg\\left(\\sum_{j=1}^{3} e^{\\mathrm{i}\\phi_j}\\right) = \\pi \\quad \\text{mod } 2\\pi.$$\n对于 $\\psi$ 且 $\\epsilon = 0.2$，发生同样的抵消，得到\n$$\\bar{\\psi}_{\\text{circ}} = \\pi \\quad \\text{mod } 2\\pi.$$\n因此，圆周平均的簇中心是 $(\\bar{\\phi}, \\bar{\\psi}) = (\\pi, \\pi)$，模 $2\\pi$，这与输入数值的包装方式无关。\n\n扩展到2-环面上的聚类更新：\n- 在k-均值中，质心最小化到指定点的距离平方和。在圆上，与旋转对称性一致的自然平方距离是单位向量之间的弦距离的平方，对于两个角度 $\\theta$ 和 $\\mu$ 而言，它是\n$$d^2_{\\text{chord}}(\\theta, \\mu) = \\left\\|\\begin{pmatrix}\\cos\\theta \\\\ \\sin\\theta\\end{pmatrix} - \\begin{pmatrix}\\cos\\mu \\\\ \\sin\\mu\\end{pmatrix}\\right\\|^2 = 2 - 2\\cos(\\theta - \\mu).$$\n最小化 $\\sum_i d^2_{\\text{chord}}(\\theta_i, \\mu)$ 等价于最大化 $\\sum_i \\cos(\\theta_i - \\mu)$，当合向量长度非零时，其最大化者恰好是 $\\mu = \\arg\\left(\\sum_i e^{\\mathrm{i}\\theta_i}\\right)$。在具有乘积度量的2-环面上，质心更新通过将此方法逐分量应用于 $\\phi$ 和 $\\psi$ 来获得。该质心在旋转下是等变的，并且与角度分支的选择无关。\n\n逐项分析：\n- 选项A：它断言在 $(-\\pi, \\pi]$ 中的欧几里得平均是正确的。我们计算出在该分支上的欧几里得平均值为 $\\left(-\\frac{\\pi}{3}, -\\frac{\\pi}{3}\\right)$，这远离 $(\\pi, \\pi)$ 附近的密集区域，并且关键是，如果选择不同的分支，该值会改变。这违反了圆上所需的不变性；因此，声称它是正确的中心是错误的。结论：不正确。\n\n- 选项B：它陈述了不变性要求（加上 $2\\pi$ 的倍数不改变物理性质），并提出了一种基于组合圆上方向的平均构造方法，对于此数据集得到的结果是 $(\\pi, \\pi)$ 模 $2\\pi$。这与基于原理的推导和显式计算相符。结论：正确。\n\n- 选项C：它声称将角度重新包装到 $[0, 2\\pi)$ 然后进行欧几里得平均可以普遍解决问题。尽管对于这个数据集，$[0, 2\\pi)$ 的欧几里得平均恰好等于 $(\\pi, \\pi)$，但结果依赖于所选的分支切割，并且在重新包装下可能改变。如前所示，对于相同的物理数据，$(-\\pi, \\pi]$ 的欧几里得平均给出 $\\left(-\\frac{\\pi}{3}, -\\frac{\\pi}{3}\\right)$，而 $[0, 2\\pi)$ 的欧几里得平均给出 $(\\pi, \\pi)$。因此，这种方法不是表示无关的，也不能普遍解决问题。结论：不正确。\n\n- 选项D：它为2-环面上的k-均值聚类提出了一种有原则的修改方法，使用弦距离的平方和通过每个坐标的归一化向量和来更新质心。这遵循最小化弦距离平方和的原则，并在合向量长度非零时产生圆周平均方向。它是旋转等变的并尊重周期性。结论：正确。",
            "answer": "$$\\boxed{BD}$$"
        },
        {
            "introduction": "在确立了处理角度周期性的正确方法后，下一步是构建一个能全面描述构象相似性的距离度量。单纯的 RMSD 只关注笛卡尔坐标，而忽略了决定分子柔性的关键扭转自由度。本练习要求你设计并实现一个复合距离度量 ，它巧妙地将 RMSD 与一个能正确处理周期性的扭转角距离相结合，从而创建出一个更具物理意义的“标尺”。",
            "id": "3401829",
            "problem": "设计并实现一种复合距离，用于比较分子构象。该距离通过将二面角映射到单位圆上，融合了笛卡尔坐标系的均方根偏差（RMSD）和扭转角的周期性。目标是探究当角度跨越 $\\,-\\pi/\\pi\\,$ 边界时聚类的敏感性。请完全采用纯数学规范进行描述，该规范可在任何编程语言中实现。\n\n定义和要求：\n- 每个构象由一组 $M$ 个三维笛卡尔坐标（单位为埃）和一个包含 $K$ 个扭转角（单位为弧度）的向量指定。角度必须以弧度处理。\n- 两组坐标集之间的均方根偏差（RMSD）必须在最优刚体叠合（无镜像）后计算。最优叠合通过最小化欧几里得平方距离和的正交旋转获得。这是经典的 Kabsch 对齐方法，使用奇异值分解（SVD），然后进行平移以对齐质心。\n- 为了处理扭转角的周期性，通过 $\\phi(\\theta) = (\\cos \\theta, \\sin \\theta) \\in \\mathbb{R}^2$ 将每个扭转角 $\\theta \\in \\mathbb{R}$ 映射到单位圆上。对于一个扭转角向量 $\\boldsymbol{\\theta} \\in \\mathbb{R}^K$，将其嵌入定义为 $\\Phi(\\boldsymbol{\\theta}) = (\\cos \\theta_1, \\sin \\theta_1, \\ldots, \\cos \\theta_K, \\sin \\theta_K) \\in \\mathbb{R}^{2K}$。\n- 定义两个扭转角向量 $\\boldsymbol{\\theta}^{(A)}$ 和 $\\boldsymbol{\\theta}^{(B)}$ 之间的环形扭转距离为欧几里得范数 $\\left\\|\\Phi(\\boldsymbol{\\theta}^{(A)}) - \\Phi(\\boldsymbol{\\theta}^{(B)})\\right\\|_2$，该距离对于在 $\\,-\\pi/\\pi\\,$ 边界上的环绕是不变的。\n- 定义朴素线性扭转距离为 $\\left\\|\\boldsymbol{\\theta}^{(A)} - \\boldsymbol{\\theta}^{(B)}\\right\\|_2$（无模运算环绕）。\n- 定义构象 $A$ 和 $B$ 之间的复合环形距离为\n$$\nd_{\\mathrm{circ}}(A,B) = \\sqrt{\\alpha \\cdot \\mathrm{RMSD}(A,B)^2 + \\beta \\cdot \\left\\|\\Phi(\\boldsymbol{\\theta}^{(A)}) - \\Phi(\\boldsymbol{\\theta}^{(B)})\\right\\|_2^2},\n$$\n以及复合线性角度距离为\n$$\nd_{\\mathrm{lin}}(A,B) = \\sqrt{\\alpha \\cdot \\mathrm{RMSD}(A,B)^2 + \\beta \\cdot \\left\\|\\boldsymbol{\\theta}^{(A)} - \\boldsymbol{\\theta}^{(B)}\\right\\|_2^2}.\n$$\n此处 $\\alpha$ 和 $\\beta$ 为非负权重。\n\n聚类规则（带阈值的单链接）：\n- 给定一组构象、一个距离函数 $d(\\cdot,\\cdot)$ 和一个阈值 $\\tau \\ge 0$，在构象上构建一个无向图，当且仅当 $d(i,j) \\le \\tau$ 时，节点 $i$ 和 $j$ 之间存在一条边。簇是该图的连通分量。\n- 对于一个包含 $N$ 个构象的有序集合，其簇标签必须是一个包含 $N$ 个整数的列表，其中标签按首次出现的顺序分配，并从 $0$ 开始；也就是说，第一个构象获得标签 $0$，后续每个构象获得其已标记的连通分量成员尚未使用过的最小非负整数。\n\n数据集（所有测试共享）：\n- 每个构象的原子数：$M = 4$。\n- 每个构象的扭转角数：$K = 2$。\n- 六个构象，索引为 $0$ 到 $5$。对每个构象，笛卡尔坐标（单位为埃）以 $4 \\times 3$ 数组列出，扭转角（单位为弧度）以 $2$ 维向量列出。\n\n构象 $0$：\n- 坐标：\n  $[ [\\,0.00,\\, 0.00,\\, 0.00\\,], [\\,1.54,\\, 0.00,\\, 0.00\\,], [\\,3.08,\\, 0.10,\\, 0.00\\,], [\\,4.62,\\, 0.10,\\, 0.05\\,] ]$\n- 扭转角：\n  $[\\,3.091592653589793,\\, 0.30\\,]$。\n\n构象 $1$：\n- 坐标：\n  $[ [\\,0.00,\\, 0.00,\\, 0.00\\,], [\\,1.54,\\, 0.01,\\, 0.00\\,], [\\,3.08,\\, 0.08,\\, 0.00\\,], [\\,4.62,\\, 0.12,\\, 0.05\\,] ]$\n- 扭转角：\n  $[\\, -3.101592653589793,\\, 0.31\\,]$。\n\n构象 $2$：\n- 坐标：\n  $[ [\\,0.00,\\, 0.00,\\, 0.00\\,], [\\,1.54,\\, -0.01,\\, 0.00\\,], [\\,3.08,\\, 0.11,\\, 0.00\\,], [\\,4.62,\\, 0.09,\\, 0.05\\,] ]$\n- 扭转角：\n  $[\\,3.081592653589793,\\, 0.29\\,]$。\n\n构象 $3$：\n- 坐标：\n  $[ [\\,0.00,\\, 0.00,\\, 0.00\\,], [\\,1.54,\\, 0.05,\\, 0.00\\,], [\\,3.08,\\, 0.25,\\, 0.05\\,], [\\,4.62,\\, 0.35,\\, 0.10\\,] ]$\n- 扭转角：\n  $[\\,1.20,\\, -2.00\\,]$。\n\n构象 $4$：\n- 坐标：\n  $[ [\\,0.00,\\, 0.00,\\, 0.00\\,], [\\,1.54,\\, 0.06,\\, 0.00\\,], [\\,3.08,\\, 0.26,\\, 0.04\\,], [\\,4.62,\\, 0.36,\\, 0.12\\,] ]$\n- 扭转角：\n  $[\\,1.22,\\, -2.02\\,]$。\n\n构象 $5$（与构象 $4$ 相同）：\n- 坐标：\n  $[ [\\,0.00,\\, 0.00,\\, 0.00\\,], [\\,1.54,\\, 0.06,\\, 0.00\\,], [\\,3.08,\\, 0.26,\\, 0.04\\,], [\\,4.62,\\, 0.36,\\, 0.12\\,] ]$\n- 扭转角：\n  $[\\,1.22,\\, -2.02\\,]$。\n\n测试套件：\n- 测试 $1$（正常路径，在环形度量下两个清晰分离的簇）：\n  - 子集索引：$[\\,0,\\,1,\\,2,\\,3,\\,4\\,]$。\n  - 权重：$\\alpha = 1.0$，$\\beta = 1.0$。\n  - 阈值：$\\tau = 1.0$。\n  - 距离：$d_{\\mathrm{circ}}$。\n  - 输出：簇的整数数量。\n\n- 测试 $2$（在 $\\,-\\pi/\\pi\\,$ 处的边界敏感性）：\n  - 子集索引：$[\\,0,\\,1\\,]$。\n  - 权重：$\\alpha = 1.0$，$\\beta = 1.0$。\n  - 阈值：$\\tau = 0.3$。\n  - 距离：比较 $d_{\\mathrm{lin}}$ 和 $d_{\\mathrm{circ}}$。\n  - 输出：簇数量的整数差，定义为 $\\text{clusters}_{\\mathrm{lin}} - \\text{clusters}_{\\mathrm{circ}}$。\n\n- 测试 $3$（退化的重复项）：\n  - 子集索引：$[\\,4,\\,5\\,]$。\n  - 权重：$\\alpha = 1.0$，$\\beta = 1.0$。\n  - 阈值：$\\tau = 10^{-12}$。\n  - 距离：$d_{\\mathrm{lin}}$ 或 $d_{\\mathrm{circ}}$ 均可（对于相同的构象，它们的结果一致）。\n  - 输出：簇的整数数量。\n\n- 测试 $4$（环形度量下的权重敏感性）：\n  - 子集索引：$[\\,0,\\,2,\\,3\\,]$。\n  - 阈值：$\\tau = 0.3$。\n  - 距离：$d_{\\mathrm{circ}}$，使用两种权重设置：\n    - 情况 A：$\\alpha = 1.0$，$\\beta = 1.0$。\n    - 情况 B：$\\alpha = 1.0$，$\\beta = 0.0$。\n  - 输出：一个布尔值，指示情况 A 和情况 B 的簇标签是否相同（如果相同则为 True，否则为 False）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试 $1$ 到 $4$ 的结果，格式为逗号分隔的 Python 风格列表，例如 $[\\,r_1, r_2, r_3, r_4\\,]$，其中 $r_1$ 和 $r_3$是整数，$r_2$是整数，$r_4$ 是布尔值。输出行中不得包含此列表之外的任何额外文本。",
            "solution": "用户提供了一个问题，要求设计和实现一个用于分子构象的复合距离度量以及后续的聚类算法。在尝试解决方案之前，需要对该问题的科学合理性、良构性（well-posedness）和客观性进行验证。\n\n### 步骤 1：提取给定信息\n- **构象表示**：每个构象由 $M$ 个 $\\mathbb{R}^3$ 中的笛卡尔坐标和 $K$ 个 $\\mathbb{R}$ 中的扭转角组成。\n- **均方根偏差（RMSD）**：在使用 Kabsch 算法（基于 SVD，并处理镜像问题）进行最优刚体叠合后计算。\n- **扭转角映射**：一个角度 $\\theta$ 被映射到单位圆上，即 $\\phi(\\theta) = (\\cos \\theta, \\sin \\theta) \\in \\mathbb{R}^2$。一个包含 $K$ 个角度的向量 $\\boldsymbol{\\theta}$ 被映射到 $\\Phi(\\boldsymbol{\\theta}) \\in \\mathbb{R}^{2K}$。\n- **距离度量**：\n    - **环形扭转距离**：$d_{\\mathrm{tors,circ}}(\\boldsymbol{\\theta}^{(A)}, \\boldsymbol{\\theta}^{(B)}) = \\left\\|\\Phi(\\boldsymbol{\\theta}^{(A)}) - \\Phi(\\boldsymbol{\\theta}^{(B)})\\right\\|_2$。\n    - **线性扭转距离**：$d_{\\mathrm{tors,lin}}(\\boldsymbol{\\theta}^{(A)}, \\boldsymbol{\\theta}^{(B)}) = \\left\\|\\boldsymbol{\\theta}^{(A)} - \\boldsymbol{\\theta}^{(B)}\\right\\|_2$。\n    - **复合环形距离**：$d_{\\mathrm{circ}}(A,B) = \\sqrt{\\alpha \\cdot \\mathrm{RMSD}(A,B)^2 + \\beta \\cdot d_{\\mathrm{tors,circ}}(\\boldsymbol{\\theta}^{(A)}, \\boldsymbol{\\theta}^{(B)})^2}$。\n    - **复合线性角度距离**：$d_{\\mathrm{lin}}(A,B) = \\sqrt{\\alpha \\cdot \\mathrm{RMSD}(A,B)^2 + \\beta \\cdot d_{\\mathrm{tors,lin}}(\\boldsymbol{\\theta}^{(A)}, \\boldsymbol{\\theta}^{(B)})^2}$。\n- **聚类规则**：\n    - 构建一个图，其中节点是构象，如果构象 $i$ 和 $j$ 之间的距离 $d(i,j) \\le \\tau$（$\\tau$ 是给定的阈值），则它们之间存在一条边。\n    - 簇是该图的连通分量。\n    - 标签分配：对于一个有序的构象集合，标签是从 $0$ 开始的整数。构象的标签由在有序遍历构象时其所在连通分量首次遇到的标签决定。\n- **数据集**：$M=4$， $K=2$。提供了六个构象（索引从 $0$ 到 $5$）及其笛卡尔坐标和扭转角。构象 $4$ 和 $5$ 是相同的。\n- **测试套件**：定义了四个具体的测试，每个测试都有一组构象子集、参数（$\\alpha, \\beta, \\tau$）、要使用的距离度量，以及要计算的特定输出（簇的数量、簇数之差或标签的布尔比较）。\n\n### 步骤 2：使用提取的给定信息进行验证\n1.  **科学依据**：该问题在计算生物物理学和结构生物学领域有坚实的基础。RMSD、Kabsch 算法、扭转角和聚类都是标准概念。对周期性数据（角度）使用环形度量是一种常见且有效的方法。该问题在科学上是合理的。\n2.  **良构性**：问题提供了所有必要的定义、数据和参数。距离公式是明确的。基于阈值距离图寻找连通分量的聚类算法是一个定义明确的过程。标签规则的表述虽然略显复杂，但对应一个标准的确定性算法：找到连通分量，然后按照遍历输入构象时首次遇到的顺序为这些分量分配标签。这确保了每个测试用例都有唯一的解。该问题是良构的。\n3.  **客观性**：语言精确且数学化。所有要求都以形式化方式陈述，没有歧义或主观因素。该问题是客观的。\n4.  **完整性和一致性**：问题是自包含的。所有数据和常量都已提供。没有矛盾之处。构象 4 和 5 相同是为测试 3 而刻意设计的，并非错误。\n5.  **可行性**：指定的计算（SVD、矩阵运算、图分量分析）在计算上是可行的，并且是科学计算库中的标准功能。数据值对于分子结构是现实的。\n\n### 步骤 3：结论与行动\n问题有效。这是一个基于既定科学原理的、表述良好的计算任务。我将着手提供一个解决方案。\n\n### 基于原则的解决方案设计\n解决方案的结构是创建一系列封装问题中定义的核心概念的函数，然后由一个主程序来执行指定的测试。\n\n1.  **RMSD 计算 (`calculate_rmsd`)**：该函数实现用于最优分子叠合的 Kabsch 算法。\n    -   **输入**：两个点集 $P$ 和 $Q$，作为 $M \\times 3$ 的 NumPy 数组。\n    -   **原理**：目标是找到一个旋转矩阵 $R$ 和平移向量 $t$，以最小化均方根偏差，$\\mathrm{RMSD}(P, Q) = \\min_{R,t} \\sqrt{\\frac{1}{M}\\sum_{i=1}^M \\| (R P_i + t) - Q_i \\|^2}$。\n    -   **算法**：\n        1.  最优平移使两个点集的质心对齐。我们首先平移 $P$ 和 $Q$，使其质心位于原点：$P' = P - \\bar{P}$，$Q' = Q - \\bar{Q}$。\n        2.  最优旋转通过最大化 $R^T C$ 的迹来找到，其中 $C = P'^T Q'$ 是协方差矩阵。这个最大化问题通过对 $C$ 进行奇异值分解（SVD）来解决。\n        3.  设 $C = U S V^T$。最优旋转矩阵为 $R = V U^T$。\n        4.  如果 $\\det(R) = -1$，则会出现特殊情况，这对应于一个镜像（非正常旋转）。为确保是正常旋转（$\\det(R)=+1$），我们必须修正 $R$。这通过在计算 $R$ 之前，反转 $V$ 中对应于最小奇异值的列的符号来完成。\n        5.  找到 $R$ 后，我们将其应用于 $P$ 的中心化坐标，即 $P'' = P' R$。\n        6.  然后，RMSD 计算为变换后的点 $P''$ 和中心化点 $Q'$ 之间的欧几里得距离，在所有点上取平均：$\\mathrm{RMSD} = \\sqrt{\\frac{1}{M} \\sum_{i=1}^M \\| P''_i - Q'_i \\|^2}$。\n\n2.  **距离度量 (`calculate_composite_distance`)**：该函数根据所选的度量类型计算两个构象之间的复合距离。\n    -   **输入**：两个构象（每个都包含坐标和扭转角）、权重 $\\alpha$ 和 $\\beta$，以及一个指示是使用环形还是线性扭转距离的标志。\n    -   **原理**：它将笛卡尔坐标距离和内坐标距离组合成一个单一的度量。环形度量正确处理了扭转角的 $2\\pi$ 周期性。\n    -   **算法**：\n        1.  使用 `calculate_rmsd` 函数计算 $\\mathrm{RMSD}(A,B)$。\n        2.  计算扭转距离项。对于线性距离，它是扭转角向量之差的 $L^2$-范数。对于环形距离，它首先将每个扭转角向量 $\\boldsymbol{\\theta}$ 映射到其在单位圆上的 $2K$ 维表示 $\\Phi(\\boldsymbol{\\theta})$，然后计算这些表示之差的 $L^2$-范数。\n        3.  根据 $d_{\\mathrm{circ}}$ 或 $d_{\\mathrm{lin}}$ 的公式，使用权重 $\\alpha$ 和 $\\beta$ 组合平方 RMSD 和平方扭转距离。\n\n3.  **聚类 (`perform_clustering`)**：该函数实现指定的带阈值的单链接聚类。\n    -   **输入**：构象列表、距离函数、阈值 $\\tau$ 以及距离函数的任何参数（例如 $\\alpha, \\beta$）。\n    -   **原理**：聚类将相似的对象分组。在这里，“相似性”定义为两个构象之间的距离小于或等于阈值 $\\tau$。这定义了一个图，簇是其连通分量。\n    -   **算法**：\n        1.  为给定的构象子集计算一个 $N \\times N$ 的成对距离矩阵。\n        2.  构建一个邻接矩阵，如果构象 $i$ 和 $j$ 之间的距离 $\\le \\tau$，则条目 $(i,j)$ 为 $1$，否则为 $0$。\n        3.  使用 `scipy.sparse.csgraph.connected_components` 函数来找到由邻接矩阵表示的图的连通分量。该函数返回分量的数量和一个包含每个构象原始整数标签的数组。\n        4.  为了满足问题中“首次出现顺序”的标签规则，需要对这些原始标签进行重新映射。我们按原始输入顺序遍历构象。当第一次遇到一个原始分量标签时，为其分配下一个可用的最终标签，从 $0$ 开始。然后使用此映射生成最终的标签列表。\n\n4.  **主执行逻辑 (`solve`)**：该函数设置数据并协调执行问题陈述中描述的四个测试，以指定格式打印结果。它使用适合每个测试的参数调用辅助函数。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import connected_components\n\ndef calculate_rmsd(coords_p, coords_q):\n    \"\"\"\n    Calculates the Root Mean Square Deviation (RMSD) between two sets of\n    3D coordinates (P and Q) after optimal rigid-body superposition.\n    \"\"\"\n    # Number of atoms must be the same\n    if coords_p.shape[0] != coords_q.shape[0]:\n        raise ValueError(\"Coordinate sets must have the same number of atoms.\")\n\n    # 1. Center coordinates by subtracting their centroids\n    p_centroid = coords_p.mean(axis=0)\n    q_centroid = coords_q.mean(axis=0)\n    p_centered = coords_p - p_centroid\n    q_centered = coords_q - q_centroid\n\n    # 2. Compute the covariance matrix\n    cov_matrix = p_centered.T @ q_centered\n\n    # 3. Compute the SVD of the covariance matrix\n    U, S, Vt = np.linalg.svd(cov_matrix)\n\n    # 4. Determine the optimal rotation matrix, correcting for reflections\n    # The determinant of Vt.T @ U.T can be -1 (reflection).\n    # If so, we must invert the sign of the last column of V (or last row of Vt)\n    # to ensure a proper rotation.\n    det_check = np.linalg.det(Vt.T @ U.T)\n    if det_check  0:\n        Vt[-1, :] *= -1\n\n    R = Vt.T @ U.T\n\n    # 5. Apply the rotation to the centered coordinates of P\n    p_rotated = p_centered @ R\n\n    # 6. Calculate the squared differences and the RMSD\n    diff = p_rotated - q_centered\n    rmsd_sq = np.sum(diff * diff) / coords_p.shape[0]\n    return np.sqrt(rmsd_sq)\n\ndef calculate_composite_distance(conf_a, conf_b, alpha, beta, use_circular_torsion):\n    \"\"\"\n    Calculates the composite distance between two conformations A and B.\n    \"\"\"\n    rmsd_val = calculate_rmsd(conf_a['coords'], conf_b['coords'])\n    \n    if use_circular_torsion:\n        # Map torsions to the unit circle\n        phi_a = np.empty(2 * len(conf_a['torsions']))\n        phi_a[0::2] = np.cos(conf_a['torsions'])\n        phi_a[1::2] = np.sin(conf_a['torsions'])\n        \n        phi_b = np.empty(2 * len(conf_b['torsions']))\n        phi_b[0::2] = np.cos(conf_b['torsions'])\n        phi_b[1::2] = np.sin(conf_b['torsions'])\n        \n        torsion_dist_sq = np.sum((phi_a - phi_b)**2)\n    else:\n        torsion_dist_sq = np.sum((conf_a['torsions'] - conf_b['torsions'])**2)\n        \n    composite_dist_sq = alpha * (rmsd_val**2) + beta * torsion_dist_sq\n    return np.sqrt(composite_dist_sq)\n\ndef perform_clustering(subset_indices, conformations, alpha, beta, tau, use_circular_torsion):\n    \"\"\"\n    Performs single-linkage clustering with a threshold and returns the\n    number of clusters and the final labels.\n    \"\"\"\n    num_confs = len(subset_indices)\n    if num_confs == 0:\n        return 0, []\n\n    dist_matrix = np.zeros((num_confs, num_confs))\n    \n    for i in range(num_confs):\n        for j in range(i + 1, num_confs):\n            conf_i = conformations[subset_indices[i]]\n            conf_j = conformations[subset_indices[j]]\n            dist = calculate_composite_distance(conf_i, conf_j, alpha, beta, use_circular_torsion)\n            dist_matrix[i, j] = dist_matrix[j, i] = dist\n            \n    # Build adjacency matrix based on the threshold\n    adjacency_matrix = dist_matrix = tau\n    \n    # Find connected components, which are the clusters\n    graph = csr_matrix(adjacency_matrix)\n    n_components, raw_labels = connected_components(csgraph=graph, directed=False, return_labels=True)\n    \n    # Re-label according to the \"first appearance\" rule\n    final_labels = -np.ones(num_confs, dtype=int)\n    label_map = {}\n    next_label = 0\n    for i in range(num_confs):\n        raw_label = raw_labels[i]\n        if raw_label not in label_map:\n            label_map[raw_label] = next_label\n            next_label += 1\n        final_labels[i] = label_map[raw_label]\n        \n    return n_components, final_labels.tolist()\n\ndef solve():\n    \"\"\"\n    Main function to define data, run tests, and print results.\n    \"\"\"\n    conformations_data = {\n        0: {'coords': np.array([[0.00, 0.00, 0.00], [1.54, 0.00, 0.00], [3.08, 0.10, 0.00], [4.62, 0.10, 0.05]]),\n            'torsions': np.array([3.091592653589793, 0.30])},\n        1: {'coords': np.array([[0.00, 0.00, 0.00], [1.54, 0.01, 0.00], [3.08, 0.08, 0.00], [4.62, 0.12, 0.05]]),\n            'torsions': np.array([-3.101592653589793, 0.31])},\n        2: {'coords': np.array([[0.00, 0.00, 0.00], [1.54, -0.01, 0.00], [3.08, 0.11, 0.00], [4.62, 0.09, 0.05]]),\n            'torsions': np.array([3.081592653589793, 0.29])},\n        3: {'coords': np.array([[0.00, 0.00, 0.00], [1.54, 0.05, 0.00], [3.08, 0.25, 0.05], [4.62, 0.35, 0.10]]),\n            'torsions': np.array([1.20, -2.00])},\n        4: {'coords': np.array([[0.00, 0.00, 0.00], [1.54, 0.06, 0.00], [3.08, 0.26, 0.04], [4.62, 0.36, 0.12]]),\n            'torsions': np.array([1.22, -2.02])},\n        5: {'coords': np.array([[0.00, 0.00, 0.00], [1.54, 0.06, 0.00], [3.08, 0.26, 0.04], [4.62, 0.36, 0.12]]),\n            'torsions': np.array([1.22, -2.02])},\n    }\n\n    # Test 1\n    subset1 = [0, 1, 2, 3, 4]\n    alpha1, beta1, tau1 = 1.0, 1.0, 1.0\n    num_clusters1, _ = perform_clustering(subset1, conformations_data, alpha1, beta1, tau1, use_circular_torsion=True)\n    result1 = num_clusters1\n\n    # Test 2\n    subset2 = [0, 1]\n    alpha2, beta2, tau2 = 1.0, 1.0, 0.3\n    num_clusters_lin, _ = perform_clustering(subset2, conformations_data, alpha2, beta2, tau2, use_circular_torsion=False)\n    num_clusters_circ, _ = perform_clustering(subset2, conformations_data, alpha2, beta2, tau2, use_circular_torsion=True)\n    result2 = num_clusters_lin - num_clusters_circ\n\n    # Test 3\n    subset3 = [4, 5]\n    alpha3, beta3, tau3 = 1.0, 1.0, 1e-12\n    # Distance function doesn't matter since conformations are identical (dist=0)\n    num_clusters3, _ = perform_clustering(subset3, conformations_data, alpha3, beta3, tau3, use_circular_torsion=True)\n    result3 = num_clusters3\n\n    # Test 4\n    subset4 = [0, 2, 3]\n    tau4 = 0.3\n    # Case A\n    alpha4a, beta4a = 1.0, 1.0\n    _, labels_A = perform_clustering(subset4, conformations_data, alpha4a, beta4a, tau4, use_circular_torsion=True)\n    # Case B\n    alpha4b, beta4b = 1.0, 0.0\n    _, labels_B = perform_clustering(subset4, conformations_data, alpha4b, beta4b, tau4, use_circular_torsion=True)\n    result4 = labels_A == labels_B\n    \n    results = [result1, result2, result3, result4]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了更深入地理解构象状态，我们不仅需要考虑其静态几何结构，还需考虑其动态演化行为。本练习将带你进入多视图聚类的前沿领域，挑战你推导出一个联合目标函数 。该框架旨在同时整合基于 RMSD 的几何特征和基于跃迁概率的动力学特征，从而实现对构象系综更全面、更深刻的划分。",
            "id": "3401832",
            "problem": "一条在延迟时间 $\\tau$ 采样的分子动力学轨迹，产生了一组包含 $N$ 个已对齐构象的集合，其笛卡尔坐标已被预处理成 $d$ 维几何描述符 $\\{ \\mathbf{g}_{i} \\in \\mathbb{R}^{d} \\}_{i=1}^{N}$，使得欧几里得距离的平方 $\\| \\mathbf{g}_{i} - \\mathbf{g}_{j} \\|^{2}$ 与最佳叠加后的均方根偏差 (RMSD) 的平方成正比。此外，根据观测到的构象之间的转移计数，估计了一个在延迟时间 $\\tau$ 的行随机转移概率矩阵 $\\mathbf{T} \\in \\mathbb{R}^{N \\times N}$。因此，对于每个 $i \\in \\{1,\\dots,N\\}$，行向量 $\\mathbf{t}_{i}^{\\top}$ 满足 $\\sum_{j=1}^{N} T_{ij} = 1$ 和 $T_{ij} \\ge 0$。\n\n要求您提出一个多视图聚类框架，通过软分配来整合几何特征（基于 RMSD 的描述符）和动力学特征（转移概率）。设几何视图的软分配矩阵为 $\\mathbf{U} \\in \\mathbb{R}_{+}^{N \\times K}$，动力学视图的软分配矩阵为 $\\mathbf{V} \\in \\mathbb{R}_{+}^{N \\times K}$，其中 $\\mathbf{U}$ 的每一行和 $\\mathbf{V}$ 的每一行之和均为 $1$，代表了对 $K$ 个聚类的概率性隶属度。设几何视图的聚类原型为 $\\{ \\mathbf{c}_{k} \\in \\mathbb{R}^{d} \\}_{k=1}^{K}$，汇集成矩阵 $\\mathbf{C} = [\\mathbf{c}_{1},\\dots,\\mathbf{c}_{K}] \\in \\mathbb{R}^{d \\times K}$。对于动力学，设 $\\mathbf{Q} \\in \\mathbb{R}_{+}^{K \\times K}$ 是一个行随机矩阵，其中 $Q_{k k'}$ 表示一个来自源聚类 $k$ 的构象在延迟时间 $\\tau$ 转移到目标聚类 $k'$ 的概率。\n\n使用以下建模假设作为基本基础：\n- 对于几何视图，在给定聚类 $k$ 的条件下，描述符 $\\mathbf{g}_{i}$ 从一个均值为 $\\mathbf{c}_{k}$、协方差为 $\\sigma^{2} \\mathbf{I}_{d}$ 的各向同性高斯分布中抽样，其中 $\\sigma^{2}  0$ 在所有聚类中均为常数。\n- 对于动力学视图，在给定构象 $i$ 的源聚类为 $k$ 的条件下，其到 $K$ 个聚类的出射转移的诱导分布是一个多项分布，其参数向量由 $\\mathbf{Q}$ 的第 $k$ 行给出。对于构象 $i$，观测到的关于目标聚类的经验分布是通过软目标分配矩阵 $\\mathbf{V}$ 聚合微观状态的转移概率得到的，即 $\\mathbf{s}_{i}^{\\top} = \\mathbf{t}_{i}^{\\top} \\mathbf{V}$，其分量为 $s_{i k'} = \\sum_{j=1}^{N} T_{ij} V_{j k'}$。\n- 为了耦合这两个视图，引入一个二次协同正则化惩罚项，以鼓励 $\\mathbf{U}$ 和 $\\mathbf{V}$ 之间的一致性。\n\n从这些假设出发，利用最大似然原理和标准的负对数似然构造，推导出一个待最小化的联合目标函数 $J(\\mathbf{U}, \\mathbf{V}, \\mathbf{C}, \\mathbf{Q} ; \\mathbf{G}, \\mathbf{T}, \\alpha, \\lambda, \\mu)$（可忽略不依赖于决策变量的加性常数）。其中 $\\mathbf{G} = [\\mathbf{g}_{1},\\dots,\\mathbf{g}_{N}]^{\\top} \\in \\mathbb{R}^{N \\times d}$ 汇集了描述符，而 $\\alpha  0$、$\\lambda  0$ 和 $\\mu  0$ 分别是加权几何似然项、动力学似然项和协同正则化项的超参数。\n\n将您的最终答案表示为 $J(\\mathbf{U}, \\mathbf{V}, \\mathbf{C}, \\mathbf{Q} ; \\mathbf{G}, \\mathbf{T}, \\alpha, \\lambda, \\mu)$ 的单个闭式解析表达式，使用诱导的聚类出射分布 $\\mathbf{s}_{i}^{\\top} = \\mathbf{t}_{i}^{\\top} \\mathbf{V}$，并明确地用关于 $i$、$k$ 和 $k'$ 的求和、范数 $\\| \\cdot \\|^{2}$ 以及对数 $\\ln(\\cdot)$ 来表示。忽略不依赖于 $\\mathbf{U}$、$\\mathbf{V}$、$\\mathbf{C}$ 或 $\\mathbf{Q}$ 的加性常数。不需要四舍五入。目标函数值没有物理单位。",
            "solution": "我们首先对这两个信息源及其概率模型进行形式化。对于几何视图，$k$-means 聚类的标准概率基础是一个各向同性高斯模型。具体来说，对于每个构象 $i \\in \\{1,\\dots,N\\}$ 和聚类 $k \\in \\{1,\\dots,K\\}$，我们假设\n$$\np(\\mathbf{g}_{i} \\mid z^{\\text{geo}}_{i} = k, \\mathbf{c}_{k}) = \\frac{1}{(2 \\pi \\sigma^{2})^{d/2}} \\exp\\!\\left( - \\frac{\\| \\mathbf{g}_{i} - \\mathbf{c}_{k} \\|^{2}}{2 \\sigma^{2}} \\right),\n$$\n其中 $z^{\\text{geo}}_{i}$ 是几何视图中的潜在聚类标签，$\\sigma^{2}  0$ 在所有聚类中共享。对构象 $i$ 引入满足 $\\sum_{k=1}^{K} u_{i k} = 1$ 和 $u_{i k} \\ge 0$ 的软分配 $\\{ u_{i k} \\}_{k=1}^{K}$，对所有构象聚合后，几何视图的期望完整数据负对数似然为\n$$\n\\sum_{i=1}^{N} \\sum_{k=1}^{K} u_{i k} \\left[ \\frac{d}{2} \\ln(2 \\pi \\sigma^{2}) + \\frac{1}{2 \\sigma^{2}} \\| \\mathbf{g}_{i} - \\mathbf{c}_{k} \\|^{2} \\right].\n$$\n省略不依赖于 $\\mathbf{U}$ 或 $\\mathbf{C}$ 的加性常数，该式可简化为一个类似失真的项\n$$\n\\frac{1}{2 \\sigma^{2}} \\sum_{i=1}^{N} \\sum_{k=1}^{K} u_{i k} \\| \\mathbf{g}_{i} - \\mathbf{c}_{k} \\|^{2}.\n$$\n引入一个吸收了因子 $1/(2 \\sigma^{2})$ 的几何权重 $\\alpha  0$，我们将几何贡献定义为\n$$\n\\alpha \\sum_{i=1}^{N} \\sum_{k=1}^{K} u_{i k} \\| \\mathbf{g}_{i} - \\mathbf{c}_{k} \\|^{2}.\n$$\n\n对于动力学视图，设 $\\mathbf{T} \\in \\mathbb{R}^{N \\times N}$ 为延迟时间 $\\tau$ 的行随机转移矩阵，满足 $\\sum_{j=1}^{N} T_{i j} = 1$ 和 $T_{i j} \\ge 0$。为了将微观状态转移与聚类级别的转移联系起来，我们使用软目标分配矩阵 $\\mathbf{V} \\in \\mathbb{R}_{+}^{N \\times K}$ 来聚合从构象 $i$ 到各个聚类的出射概率。将构象 $i$ 的诱导聚类出射分布定义为 $K$ 维向量\n$$\n\\mathbf{s}_{i}^{\\top} = \\mathbf{t}_{i}^{\\top} \\mathbf{V}, \\quad \\text{so that} \\quad s_{i k'} = \\sum_{j=1}^{N} T_{i j} V_{j k'} \\quad \\text{and} \\quad \\sum_{k'=1}^{K} s_{i k'} = 1.\n$$\n假设在给定构象 $i$ 的源聚类为 $k$ 的条件下，聚类级别的出射概率向量由行随机矩阵 $\\mathbf{Q} \\in \\mathbb{R}_{+}^{K \\times K}$ 的第 $k$ 行给出：$\\sum_{k'=1}^{K} Q_{k k'} = 1$ 且 $Q_{k k'} \\ge 0$。如果我们将从 $i$ 出发的观测到的聚类聚合转移视为来自经验分布为 $\\mathbf{s}_{i}$ 的多项式样本，那么将 $i$ 分配给源聚类 $k$ 的每单位计数的负对数似然就是交叉熵\n$$\nH(\\mathbf{s}_{i}, \\mathbf{q}_{k}) = - \\sum_{k'=1}^{K} s_{i k'} \\ln Q_{k k'},\n$$\n其中 $\\mathbf{q}_{k}^{\\top}$ 是 $\\mathbf{Q}$ 的第 $k$ 行。引入满足 $\\sum_{k=1}^{K} v_{i k} = 1$ 和 $v_{i k} \\ge 0$ 的动力学视图软分配 $\\{ v_{i k} \\}_{k=1}^{K}$，所有构象上的期望负对数似然为\n$$\n\\sum_{i=1}^{N} \\sum_{k=1}^{K} v_{i k} \\left[ - \\sum_{k'=1}^{K} s_{i k'} \\ln Q_{k k'} \\right].\n$$\n用 $\\lambda  0$ 加权此项，得到动力学贡献\n$$\n\\lambda \\sum_{i=1}^{N} \\sum_{k=1}^{K} v_{i k} \\left[ - \\sum_{k'=1}^{K} s_{i k'} \\ln Q_{k k'} \\right].\n$$\n\n为了耦合几何视图和动力学视图，我们引入一个二次协同正则化惩罚项，以鼓励 $\\mathbf{U}$ 和 $\\mathbf{V}$ 之间的一致性：\n$$\n\\mu \\| \\mathbf{U} - \\mathbf{V} \\|_{F}^{2} = \\mu \\sum_{i=1}^{N} \\sum_{k=1}^{K} (u_{i k} - v_{i k})^{2},\n$$\n其中 $\\mu  0$。这是一个标准的 Tikhonov 正则化器，用于惩罰两组软分配之间的差异。\n\n结合这三项贡献，并舍去不依赖于 $\\mathbf{U}$、$\\mathbf{V}$、$\\mathbf{C}$ 或 $\\mathbf{Q}$ 的加性常数，待最小化的联合目标函数为\n$$\nJ(\\mathbf{U}, \\mathbf{V}, \\mathbf{C}, \\mathbf{Q} ; \\mathbf{G}, \\mathbf{T}, \\alpha, \\lambda, \\mu) = \\alpha \\sum_{i=1}^{N} \\sum_{k=1}^{K} u_{i k} \\| \\mathbf{g}_{i} - \\mathbf{c}_{k} \\|^{2} + \\lambda \\sum_{i=1}^{N} \\sum_{k=1}^{K} v_{i k} \\left[ - \\sum_{k'=1}^{K} s_{i k'} \\ln Q_{k k'} \\right] + \\mu \\sum_{i=1}^{N} \\sum_{k=1}^{K} (u_{i k} - v_{i k})^{2},\n$$\n其中 $\\mathbf{s}_{i}^{\\top} = \\mathbf{t}_{i}^{\\top} \\mathbf{V}$ 且 $s_{i k'} = \\sum_{j=1}^{N} T_{i j} V_{j k'}$。该目标函数是一个多视图负对数后验概率（在加性常数的意义上），它整合了一个各向同性高斯几何似然、一个由 $\\mathbf{V}$ 聚合的多项式动力学似然，以及一个强制两个视图之间一致性的二次协同正则化项。",
            "answer": "$$\\boxed{\\alpha \\sum_{i=1}^{N} \\sum_{k=1}^{K} u_{i k} \\| \\mathbf{g}_{i} - \\mathbf{c}_{k} \\|^{2} \\;+\\; \\lambda \\sum_{i=1}^{N} \\sum_{k=1}^{K} v_{i k} \\left[ - \\sum_{k'=1}^{K} \\left( \\sum_{j=1}^{N} T_{i j} V_{j k'} \\right) \\ln Q_{k k'} \\right] \\;+\\; \\mu \\sum_{i=1}^{N} \\sum_{k=1}^{K} (u_{i k} - v_{i k})^{2}}$$"
        }
    ]
}