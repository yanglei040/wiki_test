{
    "hands_on_practices": [
        {
            "introduction": "准确的原子部分电荷是描述静电相互作用的基础，也是任何力场参数化的起点。本练习将指导您实现一个标准的约束静电势 (RESP) 拟合方案，在将电荷拟合到量子化学数据的同时，施加电中性和化学对称性等关键物理约束 。",
            "id": "3400174",
            "problem": "您的任务是实现一个基于物理基础、带等式约束的静电势 (ESP) 电荷拟合协议，该协议适用于分子动力学中碳水化合物羟基的参数化。该协议必须将以原子为中心的点电荷与使用 6-31G* 基组在 Hartree-Fock (HF) 水平上计算的量子力学静电势数据进行拟合，同时强制执行化学驱动的对称性和等价性约束，并确保精确的电中性。拟合必须同时对多个羟基旋转异构体进行，且每个原子在所有旋转异构体中共享同一个电荷。\n\n从以下基本原理出发：\n- 由固定点电荷在场点产生的静电势定义为 $V(\\mathbf{r})=\\sum_{i=1}^{N} \\dfrac{q_i}{\\lVert \\mathbf{r}-\\mathbf{R}_i\\rVert}$，其中 $q_i$ 是未知的局部电荷（单位为元电荷 $e$），$\\mathbf{R}_i$ 是原子坐标（单位为 $\\mathrm{\\AA}$），$\\mathbf{r}$ 是网格点位置（单位为 $\\mathrm{\\AA}$）。\n- 带等式约束的最小二乘准则，是在受物理约束的条件下，用一个简约的点电荷集合来协调大量 ESP 观测值的逻辑上最简约的方法。\n- 可以对 $q_i$ 值施加一个小的二次约束（岭），以确保数值稳定性并模拟约束静电势拟合。\n\n您的拟合目标是一个用于模拟碳水化合物羟基取代基的最小含羟基片段：一个类甲醇部分，包含 $N=6$ 个原子，索引如下：$1$（氧 O）、$2$（羟基氢 H$_\\mathrm{oh}$）、$3$（碳 C）、$4$（甲基氢 H$_\\mathrm{c1}$）、$5$（甲基氢 H$_\\mathrm{c2}$）、$6$（甲基氢 H$_\\mathrm{c3}$）。考虑了两种羟基旋转异构体，必须使用一套共享的电荷 $\\{q_i\\}_{i=1}^6$ 对它们同时进行拟合。\n\n两种旋转异构体的几何结构（单位为 $\\mathrm{\\AA}$）由原子笛卡尔坐标定义：\n\n- 旋转异构体 A：\n  - O: $(1.43, 0.00, 0.00)$\n  - H$_\\mathrm{oh}$: $(0.95, 0.00, 0.831)$\n  - C: $(0.00, 0.00, 0.00)$\n  - H$_\\mathrm{c1}$: $(-1.09, 0.00, 0.00)$\n  - H$_\\mathrm{c2}$: $(0.00, 1.09, 0.00)$\n  - H$_\\mathrm{c3}$: $(0.00, 0.00, 1.09)$\n\n- 旋转异构体 B（羟基氢围绕 C–O 键旋转）：\n  - O: $(1.43, 0.00, 0.00)$\n  - H$_\\mathrm{oh}$: $(0.95, 0.00, -0.831)$\n  - C: $(0.00, 0.00, 0.00)$\n  - H$_\\mathrm{c1}$: $(-1.09, 0.00, 0.00)$\n  - H$_\\mathrm{c2}$: $(0.00, 1.09, 0.00)$\n  - H$_\\mathrm{c3}$: $(0.00, 0.00, 1.09)$\n\n用于每个旋转异构体的静电势网格点（单位为 $\\mathrm{\\AA}$）被定义为笛卡尔坐标集。对于测试用例 1 和测试用例 2 中的旋转异构体 A 和旋转异构体 B，每个旋转异构体使用以下 8 个网格点：\n- $(2.50, 0.00, 0.00)$\n- $(2.50, 2.50, 0.00)$\n- $(0.00, 2.50, 2.50)$\n- $(-2.50, 0.00, 0.00)$\n- $(0.00, -2.50, 2.50)$\n- $(2.00, 0.00, 2.00)$\n- $(-2.00, -2.00, 0.00)$\n- $(0.00, 0.00, -2.50)$\n\n对于测试用例 3，每个旋转异构体使用以下 6 个网格点（通过 $y=z$ 对称性选择，以强制到 H$_\\mathrm{c2}$ 和 H$_\\mathrm{c3}$ 的距离相同）：\n- $(2.00, 1.00, 1.00)$\n- $(0.00, 2.00, 2.00)$\n- $(-2.00, -1.00, -1.00)$\n- $(1.00, 0.50, 0.50)$\n- $(-1.00, -0.50, -0.50)$\n- $(0.50, 1.50, 1.50)$\n\n对于给定的旋转异构体，将设计矩阵 $\\mathbf{A}$ 定义为 $\\mathbf{A}_{k i}=\\dfrac{1}{r_{k i}}$，其中 $r_{k i}$ 是网格点 $k$ 和原子 $i$ 之间的欧几里得距离（单位为 $\\mathrm{\\AA}$）。将所有旋转异构体特定的行拼接起来，形成一个跨旋转异构体的全局 $\\mathbf{A}$。令 $\\mathbf{q}\\in\\mathbb{R}^{6}$ 为电荷向量，$\\mathbf{V}^{\\mathrm{QM}}\\in\\mathbb{R}^{M}$ 为所有旋转异构体中所有 $M$ 个网格点处的量子力学静电势向量（单位为 $e/\\mathrm{\\AA}$）。\n\n为确保测试套件的数值定义自洽，您必须使用从参考电荷\n$$\n\\mathbf{q}^{\\mathrm{ref}}=\\big[-0.66,\\; 0.43,\\; -0.02,\\; 0.083,\\; 0.083,\\; 0.083\\big]\n$$\n（单位为 $e$）通过 $V^{\\mathrm{QM}}_k=\\sum_{i=1}^{6}\\dfrac{q^{\\mathrm{ref}}_i}{r_{k i}}$ 生成的人工合成但物理上一致的 $\\mathbf{V}^{\\mathrm{QM}}$，且不添加任何噪声。所有距离 $r_{k i}$ 均由上述坐标（单位为 $\\mathrm{\\AA}$）计算，因此 $V^{\\mathrm{QM}}$ 的单位为 $e/\\mathrm{\\AA}$。\n\n通过最小化带微小二次约束的加权最小二乘目标函数来拟合 $\\mathbf{q}$：\n$$\n\\min_{\\mathbf{q}} \\;\\; \\frac{1}{2}\\left\\lVert \\mathbf{A}\\mathbf{q}-\\mathbf{V}^{\\mathrm{QM}}\\right\\rVert_2^2+\\frac{\\kappa}{2}\\left\\lVert \\mathbf{q}\\right\\rVert_2^2\n$$\n同时满足编码物理需求的线性等式约束：\n- 精确总电中性：$\\sum_{i=1}^{6} q_i=0$。\n- 甲基氢等价性：$q_4=q_5$ 和 $q_5=q_6$。\n\n角度不是必需的；如果您需要在内部引入任何角度，请以度为单位表示，但该问题不要求任何角度计算。\n\n实现一个程序，对三个测试用例执行此拟合，这些测试用例在网格点的数量和位置以及约束强度 $\\kappa$ 上有所不同：\n\n- 测试用例 1（一般情况，超定）：对两个旋转异构体各使用全部 8 个网格点（总共 $M=16$），$\\kappa=10^{-5}$。\n- 测试用例 2（边界情况，无约束时欠定）：从上述列表中每个旋转异构体仅使用前 3 个网格点（总共 $M=6$），$\\kappa=10^{-3}$。\n- 测试用例 3（对称性引起的列简并）：每个旋转异构体使用 6 个 $y=z$ 的特殊网格点（总共 $M=12$），$\\kappa=10^{-4}$。\n\n对于每个测试用例，计算满足约束条件的拟合电荷向量 $\\mathbf{q}^{\\ast}$，然后计算中性符合度，即总电荷的绝对值，\n$$\n\\left|\\sum_{i=1}^{6} q^{\\ast}_i\\right| \\;\\; \\text{单位为 } e。\n$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\text{result1},\\text{result2},\\text{result3}]$），其中每个元素是表示一个测试用例的中性符合度的浮点数（单位 $e$）。如果约束被正确执行，其量级应接近于零。所有距离的计算必须使用 $\\mathrm{\\AA}$，静电势必须以 $e/\\mathrm{\\AA}$ 为单位，电荷必须以 $e$ 为单位。",
            "solution": "该问题提出了一个任务：通过将甲醇样分子片段的以原子为中心的局部电荷与量子力学静电势 (ESP) 数据进行拟合，来确定这些电荷。这是分子力学力场开发中的一个标准流程，通常称为约束静电势 (RESP) 拟合。该问题被表述为一个数学上良构的、带线性约束的二次优化问题。\n\n首先，对问题陈述进行验证。\n\n**第 1 步：提取给定信息**\n- **静电势模型**：由 $N$ 个位于位置 $\\mathbf{R}_i$ 的原子电荷 $q_i$ 在点 $\\mathbf{r}$ 产生的势为 $V(\\mathbf{r})=\\sum_{i=1}^{N} \\dfrac{q_i}{\\lVert \\mathbf{r}-\\mathbf{R}_i\\rVert}$。\n- **目标函数**：通过最小化目标函数 $J(\\mathbf{q}) = \\frac{1}{2}\\left\\lVert \\mathbf{A}\\mathbf{q}-\\mathbf{V}^{\\mathrm{QM}}\\right\\rVert_2^2+\\frac{\\kappa}{2}\\left\\lVert \\mathbf{q}\\right\\rVert_2^2$ 来找到电荷 $\\mathbf{q}$，其中 $\\kappa$ 是一个约束参数。\n- **分子系统**：一个包含 $N=6$ 个原子的片段，索引为 $1$(O)、$2$(H$_\\mathrm{oh}$)、$3$(C)、$4$(H$_\\mathrm{c1}$)、$5$(H$_\\mathrm{c2}$) 和 $6$(H$_\\mathrm{c3}$)。\n- **构象**：同时考虑两种旋转异构体（A 和 B）。\n- **几何结构**（单位为 $\\mathrm{\\AA}$）：\n  - 旋转异构体 A：O: $(1.43, 0.00, 0.00)$，H$_\\mathrm{oh}$: $(0.95, 0.00, 0.831)$，C: $(0.00, 0.00, 0.00)$，H$_\\mathrm{c1}$: $(-1.09, 0.00, 0.00)$，H$_\\mathrm{c2}$: $(0.00, 1.09, 0.00)$，H$_\\mathrm{c3}$: $(0.00, 0.00, 1.09)$。\n  - 旋转异构体 B：O: $(1.43, 0.00, 0.00)$，H$_\\mathrm{oh}$: $(0.95, 0.00, -0.831)$，C: $(0.00, 0.00, 0.00)$，H$_\\mathrm{c1}$: $(-1.09, 0.00, 0.00)$，H$_\\mathrm{c2}$: $(0.00, 1.09, 0.00)$，H$_\\mathrm{c3}$: $(0.00, 0.00, 1.09)$。\n- **ESP 网格点**（单位为 $\\mathrm{\\AA}$）：\n  - 对于测试用例 1 和 2：每个旋转异构体一组 8 个点：$(2.50, 0.00, 0.00)$、$(2.50, 2.50, 0.00)$、$(0.00, 2.50, 2.50)$、$(-2.50, 0.00, 0.00)$、$(0.00, -2.50, 2.50)$、$(2.00, 0.00, 2.00)$、$(-2.00, -2.00, 0.00)$、$(0.00, 0.00, -2.50)$。\n  - 对于测试用例 3：每个旋转异构体一组 6 个点：$(2.00, 1.00, 1.00)$、$(0.00, 2.00, 2.00)$、$(-2.00, -1.00, -1.00)$、$(1.00, 0.50, 0.50)$、$(-1.00, -0.50, -0.50)$、$(0.50, 1.50, 1.50)$。\n- **设计矩阵**：矩阵元素 $\\mathbf{A}_{ki}$ 定义为 $\\dfrac{1}{r_{ki}}$，其中 $r_{ki}$ 是网格点 $k$ 和原子 $i$ 之间的距离。\n- **人工合成目标数据**：向量 $\\mathbf{V}^{\\mathrm{QM}}$ 使用参考电荷向量 $\\mathbf{q}^{\\mathrm{ref}}=\\big[-0.66,\\; 0.43,\\; -0.02,\\; 0.083,\\; 0.083,\\; 0.083\\big]$（单位为 $e$）计算为 $\\mathbf{V}^{\\mathrm{QM}} = \\mathbf{A}\\mathbf{q}^{\\mathrm{ref}}$。\n- **等式约束**：\n  - 电中性：$\\sum_{i=1}^{6} q_i=0$。\n  - 甲基氢等价性：$q_4=q_5$ 和 $q_5=q_6$。\n- **测试用例**：\n  - 测试用例 1：$M=16$ 个网格点，$\\kappa=10^{-5}$。\n  - 测试用例 2：$M=6$ 个网格点，$\\kappa=10^{-3}$。\n  - 测试用例 3：$M=12$ 个网格点，$\\kappa=10^{-4}$。\n- **要求输出**：对于每个测试用例，输出中性符合度，定义为 $\\left|\\sum_{i=1}^{6} q^{\\ast}_i\\right|$。\n\n**第 2 步：给定信息验证**\n该问题在科学上是合理的，再现了计算化学中的一种标准方法。物理基础（库仑定律）、数学公式（约束最小二乘法）和化学概念（电中性、原子等价性）都是正确且一致的。所有需要的数据（几何结构、网格点、参数）均已提供，使得问题自洽且可进行数值验证。目标函数是凸的，约束是线性的，这定义了一个具有唯一解的良构二次规划问题。包含 Tikhonov 正则化项（$\\kappa  0$）确保了数值稳定性，即使在设计矩阵 $\\mathbf{A}$ 可能秩亏的情况下（如测试用例 3 中故意设计的那样）。\n\n**第 3 步：结论与行动**\n该问题被判定为**有效**。将开发一个解决方案。\n\n**基于原理的解决方案设计**\n\n该问题是找到电荷向量 $\\mathbf{q} \\in \\mathbb{R}^6$，以最小化正则化的最小二乘目标函数：\n$$ J(\\mathbf{q}) = \\frac{1}{2} \\left( \\mathbf{A}\\mathbf{q} - \\mathbf{V}^{\\mathrm{QM}} \\right)^T \\left( \\mathbf{A}\\mathbf{q} - \\mathbf{V}^{\\mathrm{QM}} \\right) + \\frac{\\kappa}{2} \\mathbf{q}^T \\mathbf{q} $$\n这可以写成标准的二次型，忽略常数项：\n$$ \\min_{\\mathbf{q}} \\frac{1}{2} \\mathbf{q}^T (\\mathbf{A}^T\\mathbf{A} + \\kappa\\mathbf{I}) \\mathbf{q} - \\mathbf{q}^T \\mathbf{A}^T \\mathbf{V}^{\\mathrm{QM}} $$\n其中 $\\mathbf{I}$ 是单位矩阵。\n\n最小化受一组线性等式约束：\n1.  中性：$q_1 + q_2 + q_3 + q_4 + q_5 + q_6 = 0$\n2.  等价性：$q_4 - q_5 = 0$\n3.  等价性：$q_5 - q_6 = 0$\n\n这些约束可以以矩阵形式表示为 $\\mathbf{Cq} = \\mathbf{d}$，其中：\n$$\n\\mathbf{C} = \\begin{pmatrix} 1  1  1  1  1  1 \\\\ 0  0  0  1  -1  0 \\\\ 0  0  0  0  1  -1 \\end{pmatrix}, \\quad\n\\mathbf{q} = \\begin{pmatrix} q_1 \\\\ q_2 \\\\ q_3 \\\\ q_4 \\\\ q_5 \\\\ q_6 \\end{pmatrix}, \\quad\n\\mathbf{d} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n\n这个约束优化问题使用拉格朗日乘子法求解。通过拉格朗日乘子向量 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^3$ 将约束附加到目标函数上，构建拉格朗日函数 $\\mathcal{L}$：\n$$ \\mathcal{L}(\\mathbf{q}, \\boldsymbol{\\lambda}) = J(\\mathbf{q}) + \\boldsymbol{\\lambda}^T (\\mathbf{Cq} - \\mathbf{d}) $$\n\n通过将 $\\mathcal{L}$ 对 $\\mathbf{q}$ 和 $\\boldsymbol{\\lambda}$ 的梯度设为零，找到最小值的必要条件：\n$$ \\nabla_{\\mathbf{q}} \\mathcal{L} = (\\mathbf{A}^T\\mathbf{A} + \\kappa\\mathbf{I})\\mathbf{q} - \\mathbf{A}^T\\mathbf{V}^{\\mathrm{QM}} + \\mathbf{C}^T\\boldsymbol{\\lambda} = \\mathbf{0} $$\n$$ \\nabla_{\\boldsymbol{\\lambda}} \\mathcal{L} = \\mathbf{Cq} - \\mathbf{d} = \\mathbf{0} $$\n\n这两个方程构成一个线性方程组。令 $\\mathbf{P} = \\mathbf{A}^T\\mathbf{A} + \\kappa\\mathbf{I}$ 和 $\\mathbf{s} = \\mathbf{A}^T\\mathbf{V}^{\\mathrm{QM}}$。该系统可以写成：\n$$ \\mathbf{Pq} + \\mathbf{C}^T\\boldsymbol{\\lambda} = \\mathbf{s} $$\n$$ \\mathbf{Cq} = \\mathbf{d} $$\n\n这是一个 Karush-Kuhn-Tucker (KKT) 系统，可以表示为单个分块矩阵方程：\n$$\n\\begin{pmatrix}\n\\mathbf{P}  \\mathbf{C}^T \\\\\n\\mathbf{C}  \\mathbf{0}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{q} \\\\\n\\boldsymbol{\\lambda}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{s} \\\\\n\\mathbf{d}\n\\end{pmatrix}\n$$\n这里，左侧的分块矩阵是一个 $(6+3) \\times (6+3) = 9 \\times 9$ 的矩阵，右侧是一个 $9 \\times 1$ 的向量。\n\n算法流程如下：\n1.  对于每个测试用例，定义由旋转异构体 A 和旋转异构体 B 组成的系统。ESP 网格点的总数 $M$ 是每个旋转异构体点数的总和。\n2.  构建大小为 $M \\times 6$ 的全局设计矩阵 $\\mathbf{A}$。对于 $M$ 个网格点中的每一个，计算一行，其中第 $i$ 个元素是该网格点到原子 $i$ 的距离的倒数。\n3.  构建大小为 $M \\times 1$ 的全局人工合成势向量 $\\mathbf{V}^{\\mathrm{QM}}$。对于每个网格点 $k$，使用给定的参考电荷，通过 $\\sum_{i=1}^{6} q_i^{\\mathrm{ref}} / r_{ki}$ 计算值 $V_k^{\\mathrm{QM}}$。\n4.  形成矩阵 $\\mathbf{P} = \\mathbf{A}^T\\mathbf{A} + \\kappa\\mathbf{I}$ 和向量 $\\mathbf{s} = \\mathbf{A}^T\\mathbf{V}^{\\mathrm{QM}}$。\n5.  组装 $9 \\times 9$ 的 KKT 矩阵和 $9 \\times 1$ 的右侧向量。\n6.  求解线性系统，得到包含最优电荷 $\\mathbf{q}^*$（前 6 个元素）和拉格朗日乘子 $\\boldsymbol{\\lambda}$（后 3 个元素）的解向量。\n7.  提取电荷向量 $\\mathbf{q}^*$ 并计算中性符合度，即其元素之和的绝对值 $\\left|\\sum_{i=1}^{6} q_i^*\\right|$。这个由有限精度算术产生的值，可作为对约束正确实现的验证。\n此过程将应用于三个指定的测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the constrained ESP charge fitting problem for three test cases.\n    \"\"\"\n\n    # --- Geometries and Reference Charges ---\n    # Atomic coordinates are given in Angstroms.\n    coords_rot_A = np.array([\n        [1.43, 0.00, 0.000],  # O (1)\n        [0.95, 0.00, 0.831],  # H_oh (2)\n        [0.00, 0.00, 0.000],  # C (3)\n        [-1.09, 0.00, 0.000], # H_c1 (4)\n        [0.00, 1.09, 0.000],  # H_c2 (5)\n        [0.00, 0.00, 1.090],  # H_c3 (6)\n    ])\n\n    coords_rot_B = np.array([\n        [1.43, 0.00, 0.000],   # O (1)\n        [0.95, 0.00, -0.831],  # H_oh (2)\n        [0.00, 0.00, 0.000],   # C (3)\n        [-1.09, 0.00, 0.000],  # H_c1 (4)\n        [0.00, 1.09, 0.000],   # H_c2 (5)\n        [0.00, 0.00, 1.090],   # H_c3 (6)\n    ])\n    \n    rotamer_coords = [coords_rot_A, coords_rot_B]\n\n    # Reference charges (in elementary charge e) for generating synthetic V_QM.\n    q_ref = np.array([-0.66, 0.43, -0.02, 0.083, 0.083, 0.083])\n    \n    # --- Grid Points for Test Cases ---\n    grid_points_12 = np.array([\n        [2.50, 0.00, 0.00],\n        [2.50, 2.50, 0.00],\n        [0.00, 2.50, 2.50],\n        [-2.50, 0.00, 0.00],\n        [0.00, -2.50, 2.50],\n        [2.00, 0.00, 2.00],\n        [-2.00, -2.00, 0.00],\n        [0.00, 0.00, -2.50],\n    ])\n\n    grid_points_3 = np.array([\n        [2.00, 1.00, 1.00],\n        [0.00, 2.00, 2.00],\n        [-2.00, -1.00, -1.00],\n        [1.00, 0.50, 0.50],\n        [-1.00, -0.50, -0.50],\n        [0.50, 1.50, 1.50],\n    ])\n\n    test_cases = [\n        {'kappa': 1e-5, 'grid_points': grid_points_12, 'num_points_per_rotamer': 8, 'case_id': 1},\n        {'kappa': 1e-3, 'grid_points': grid_points_12, 'num_points_per_rotamer': 3, 'case_id': 2},\n        {'kappa': 1e-4, 'grid_points': grid_points_3, 'num_points_per_rotamer': 6, 'case_id': 3},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        kappa = case['kappa']\n        grid_points = case['grid_points'][:case['num_points_per_rotamer']]\n        \n        A_rows = []\n        V_qm_vals = []\n\n        # Build the global design matrix A and target vector V_qm\n        for R_atoms in rotamer_coords:\n            for r_grid in grid_points:\n                # Calculate distances from grid point to all atoms\n                distances = np.linalg.norm(R_atoms - r_grid, axis=1)\n                \n                # Append row to design matrix A (1/r)\n                A_rows.append(1.0 / distances)\n                \n                # Calculate and append V_qm from reference charges\n                v_k = np.sum(q_ref / distances)\n                V_qm_vals.append(v_k)\n\n        A = np.array(A_rows)\n        V_qm = np.array(V_qm_vals)\n\n        num_charges = q_ref.shape[0]\n\n        # --- Set up and solve the KKT system for constrained optimization ---\n        \n        # P = A.T @ A + kappa * I\n        P = A.T @ A + kappa * np.identity(num_charges)\n        \n        # s = A.T @ V_qm\n        s = A.T @ V_qm\n\n        # Constraint matrix C\n        C = np.zeros((3, num_charges))\n        C[0, :] = 1.0        # Sum of charges = 0\n        C[1, 3] = 1.0; C[1, 4] = -1.0  # q4 - q5 = 0\n        C[2, 4] = 1.0; C[2, 5] = -1.0  # q5 - q6 = 0\n        \n        # Constraint vector d\n        d = np.zeros(C.shape[0])\n\n        # Assemble the KKT block matrix\n        num_constraints = C.shape[0]\n        KKT_matrix = np.block([\n            [P, C.T],\n            [C, np.zeros((num_constraints, num_constraints))]\n        ])\n        \n        # Assemble the KKT right-hand side vector\n        KKT_rhs = np.concatenate([s, d])\n\n        # Solve the linear system KKT_matrix * x = KKT_rhs\n        solution = np.linalg.solve(KKT_matrix, KKT_rhs)\n        \n        # Extract the fitted charges q*\n        q_fit = solution[:num_charges]\n        \n        # Calculate neutrality compliance\n        neutrality_compliance = np.abs(np.sum(q_fit))\n        results.append(neutrality_compliance)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在建立了静电模型后，我们必须确保模型能维持分子的基本三维结构，尤其是其手性。本练习旨在解决模拟中非物理性手性翻转的问题，并演示如何基于统计力学原理设计一个最小谐波限制（非正常二面角）来保持正确的立体化学构型 。",
            "id": "3400183",
            "problem": "您接到一项源于分子动力学中碳水化合物参数化的协议设计任务。在对碳水化合物异頭碳中心进行高温采样时，观察到一个手性中心发生了反转。您必须设计一个单独的非正常二面角约束来抑制此反转，同时对附近的正常二面角产生最小程度的扰动。使用一个锚定于观察到的几何构型的谐振非正常势，并确定在指定高温下满足概率性反转抑制目标的最弱力常数。您的程序必须从第一性原理出发计算此值。\n\n使用的基本原理：\n- 玻尔兹曼分布意味着，对于一个具有谐振能量的坐标，其涨落是高斯分布的，方差由热能决定。如果势是谐振的，$$U(\\phi) = \\tfrac{1}{2} k \\left(\\phi - \\phi_{0}\\right)^{2},$$ 那么在温度 $$T$$下，$$\\phi$$ 的稳态分布是均值为 $$\\phi_{0}$$、方差为 $$\\sigma^{2} = \\dfrac{R T}{k}$$ 的高斯分布，其中 $$R$$ 是摩尔通用气体常数。\n- 对于均值为 $$\\mu$$、标准差为 $$\\sigma$$ 的单变量高斯分布，超出阈值（与均值相距 $$\\mu/\\sigma$$）的单侧尾部概率为 $$\\tfrac{1}{2}\\,\\mathrm{erfc}\\!\\left(\\dfrac{\\mu}{\\sqrt{2}\\,\\sigma}\\right),$$ 其中 $$\\mathrm{erfc}$$ 是互补误差函数。\n\n设计目标与定义：\n- 您必须从定义非正常四元组的四个原子位置计算带符号的非正常二面角 $$\\phi_{0}$$（以弧度为单位），四元组排序为 $$(\\text{外围 }1,\\, \\text{中心},\\, \\text{外围 }2,\\, \\text{外围 }3)$$。非正常二面角是由 $$(\\text{外围 }1,\\, \\text{中心},\\, \\text{外围 }2)$$ 和 $$(\\text{中心},\\, \\text{外围 }2,\\, \\text{外围 }3)$$ 所形成平面之间的带符号夹角，通过标量三重积和点积之比的标准反正切函数计算。使用以下矢量几何约定。给定位置 $$\\mathbf{r}_{0}, \\mathbf{r}_{1}, \\mathbf{r}_{2}, \\mathbf{r}_{3},$$ 定义\n- $$\\mathbf{b}_{0} = \\mathbf{r}_{1} - \\mathbf{r}_{0},\\quad \\mathbf{b}_{1} = \\mathbf{r}_{2} - \\mathbf{r}_{1},\\quad \\mathbf{b}_{2} = \\mathbf{r}_{3} - \\mathbf{r}_{2},$$\n- $$\\mathbf{n}_{0} = \\mathbf{b}_{0} \\times \\mathbf{b}_{1},\\quad \\mathbf{n}_{1} = \\mathbf{b}_{1} \\times \\mathbf{b}_{2},$$\n并计算\n- $$x = \\mathbf{n}_{0} \\cdot \\mathbf{n}_{1},\\quad y = \\lVert \\mathbf{b}_{1} \\rVert\\, \\mathbf{b}_{0} \\cdot \\mathbf{n}_{1},\\quad \\phi = \\mathrm{atan2}(y, x).$$\n取 $$\\phi_{0} = \\phi,$$ 确保 $$\\phi_{0} \\in (-\\pi,\\pi].$$\n- 为抑制手性反转，要求在指定的高温 $$T_{\\mathrm{high}}$$下，热涨落导致 $$\\phi$$ 穿过 $$\\phi = 0$$ 处反转边界的单侧概率最多为目标比例 $$p_{\\max}$$。因为非正常角以 $$\\phi_{0}$$ 为中心，反转需要至少量值为 $$\\lvert \\phi_{0}\\rvert$$ 的涨落。使用上述高斯模型，选择满足此单侧概率界限的最小谐振力常数 $$k$$（单位为千焦耳/摩尔/弧度平方）；此选择可最小化对附近正常二面角的扰动。\n\n常数和单位：\n- 使用 $$R = 8.31446261815324 \\times 10^{-3}$$ 千焦耳/摩尔/开尔文。\n- 温度单位为开尔文，角度为弧度，能量为千焦耳/摩尔。\n\n您的任务：\n- 对于下方的每个测试用例，根据坐标计算 $$\\phi_{0}$$，然后计算在 $$T_{\\mathrm{high}}$$ 下使单侧穿越概率不大于 $$p_{\\max}$$ 的最小 $$k$$ 值。同时报告您选择的 $$k$$ 值所实现的概率，以验证设计。\n\n需实现的数值细节：\n- 使用单侧高斯尾部概率 $$p = \\tfrac{1}{2}\\,\\mathrm{erfc}\\!\\left(\\dfrac{\\lvert \\phi_{0}\\rvert}{\\sqrt{2}\\,\\sigma}\\right)$$，其中 $$\\sigma = \\sqrt{\\dfrac{R T_{\\mathrm{high}}}{k}}$$。\n- 选择满足 $$p \\le p_{\\max}$$ 的最小 $$k$$ 值。\n- 在最终输出中，将每个报告的浮点数四舍五入到恰好 $$6$$ 位小数。\n\n测试套件：\n为以下每个独立参数化的案例提供一个解决方案。在每个案例中，四元组按 $$(\\text{外围 }1,\\, \\text{中心},\\, \\text{外围 }2,\\, \\text{外围 }3)$$ 排序。位置是笛卡尔坐标，单位为埃（单位在角度计算中会抵消），温度单位为开尔文，概率是无单位的分数。\n\n- 案例 $$1$$:\n  - 坐标: $$\\left( (1.0,\\, 0.0,\\, 0.0),\\ (0.1,\\, 0.2,\\, 0.0),\\ (0.0,\\, 1.0,\\, 0.0),\\ (0.0,\\, 0.2,\\, 0.9) \\right)$$\n  - $$T_{\\mathrm{high}} = 600.0$$\n  - $$p_{\\max} = 1.0\\times 10^{-6}$$\n- 案例 $$2$$:\n  - 坐标: $$\\left( (1.0,\\, 0.0,\\, 0.0),\\ (0.1,\\, 0.2,\\, 0.0),\\ (0.0,\\, 1.0,\\, 0.0),\\ (0.0,\\, 0.2,\\, -0.9) \\right)$$\n  - $$T_{\\mathrm{high}} = 600.0$$\n  - $$p_{\\max} = 1.0\\times 10^{-8}$$\n- 案例 $$3$$:\n  - 坐标: $$\\left( (1.0,\\, 0.0,\\, 0.0),\\ (0.1,\\, 0.2,\\, 0.0),\\ (0.0,\\, 1.0,\\, 0.0),\\ (0.0,\\, 0.2,\\, 0.02) \\right)$$\n  - $$T_{\\mathrm{high}} = 800.0$$\n  - $$p_{\\max} = 1.0\\times 10^{-4}$$\n- 案例 $$4$$:\n  - 坐标: $$\\left( (1.5,\\, -0.2,\\, 0.0),\\ (0.0,\\, 0.0,\\, 0.0),\\ (0.0,\\, 1.2,\\, 0.0),\\ (-0.1,\\, 0.1,\\, 1.0) \\right)$$\n  - $$T_{\\mathrm{high}} = 1200.0$$\n  - $$p_{\\max} = 1.0\\times 10^{-6}$$\n\n输出规格：\n- 对每个测试用例，输出一个列表 $$[\\ k,\\ \\phi_{0},\\ p\\ ]$$，其中 $$k$$ 是设计的力常数，单位为千焦耳/摩尔/弧度平方，$$\\phi_{0}$$ 是平衡非正常角，单位为弧度，$$p$$ 是在您的 $$k$$ 值下于 $$T_{\\mathrm{high}}$$ 时的单侧反转概率。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个由四个列表组成的逗号分隔列表，并用方括号括起来，例如 $$\\left[\\ [\\cdot,\\cdot,\\cdot],\\ [\\cdot,\\cdot,\\cdot],\\ [\\cdot,\\cdot,\\cdot],\\ [\\cdot,\\cdot,\\cdot]\\ \\right].$$\n- 将输出中的每个浮点数四舍五入到恰好 $$6$$ 位小数。\n\n关于科学真实性的说明：\n- 在碳水化合物参数化协议的背景下，所选的非正常中心是手性碳，三个外围原子是定义其局部立体化学的取代基。选择满足概率性反转约束的最小 $$k$$ 值可确保约束尽可能弱，从而最小程度地扰动相邻的扭转自由度，这与无创伤性手性强制的最佳实践相一致。",
            "solution": "问题要求设计一个谐振非正常扭转势，以抑制特定原子中心的手性反转。核心任务是确定势 $$U(\\phi) = \\frac{1}{2} k (\\phi - \\phi_{0})^2$$ 的最小力常数 $$k$$，该常数需将在给定的高温 $$T_{\\mathrm{high}}$$ 下，非正常角 $$\\phi$$ 穿过反转边界 $$\\phi = 0$$ 的概率限制在一个最大值 $$p_{\\max}$$ 以内。解决方案包含两个主要步骤：首先，根据提供的原子坐标计算平衡非正常角 $$\\phi_{0}$$；其次，基于统计力学原理推导出力常数 $$k$$。\n\n**步骤1：平衡非正常角（$$\\phi_{0}$$）的计算**\n\n平衡非正常角 $$\\phi_{0}$$ 由所涉及的四个原子的几何构型定义。问题指定了一个原子四元组，顺序为$$(\\text{外围 }1,\\, \\text{中心},\\, \\text{外围 }2,\\, \\text{外围 }3)$$，分别对应位置矢量 $$\\mathbf{r}_{0}, \\mathbf{r}_{1}, \\mathbf{r}_{2}, \\mathbf{r}_{3}$$。非正常二面角是由原子 $$(\\mathbf{r}_{0}, \\mathbf{r}_{1}, \\mathbf{r}_{2})$$ 定义的平面与由原子 $$(\\mathbf{r}_{1}, \\mathbf{r}_{2}, \\mathbf{r}_{3})$$ 定义的平面之间的带符号夹角。\n\n计算过程如下：\n1.  定义连接四个原子的三个矢量：\n    $$ \\mathbf{b}_{0} = \\mathbf{r}_{1} - \\mathbf{r}_{0} $$\n    $$ \\mathbf{b}_{1} = \\mathbf{r}_{2} - \\mathbf{r}_{1} $$\n    $$ \\mathbf{b}_{2} = \\mathbf{r}_{3} - \\mathbf{r}_{2} $$\n\n2.  使用叉积计算两个平面的法向量。第一个平面由 $$\\mathbf{b}_{0}$$ 和 $$\\mathbf{b}_{1}$$ 张成，第二个平面由 $$\\mathbf{b}_{1}$$ 和 $$\\mathbf{b}_{2}$$ 张成。\n    $$ \\mathbf{n}_{0} = \\mathbf{b}_{0} \\times \\mathbf{b}_{1} $$\n    $$ \\mathbf{n}_{1} = \\mathbf{b}_{1} \\times \\mathbf{b}_{2} $$\n\n3.  这两个平面之间的夾角 $$\\phi_{0}$$ 使用 `atan2` 函数确定，该函数能正确处理象限问题，并得出 $$(-\\pi, \\pi]$$ 范围内的结果。`atan2` 的参数，记为 $$y$$ 和 $$x$$，根据指定约定计算：\n    $$ x = \\mathbf{n}_{0} \\cdot \\mathbf{n}_{1} $$\n    $$ y = \\lVert \\mathbf{b}_{1} \\rVert (\\mathbf{b}_{0} \\cdot \\mathbf{n}_{1}) $$\n    涉及 $$\\lVert \\mathbf{b}_{1} \\rVert$$ 和标量三重积 $$\\mathbf{b}_{0} \\cdot (\\mathbf{b}_{1} \\times \\mathbf{b}_{2})$$ 的项给出了正确的角度符号。\n\n4.  平衡非正常角于是为：\n    $$ \\phi_{0} = \\mathrm{atan2}(y, x) $$\n\n**步骤2：最小力常数（$$k$$）的推导**\n\n问题指出，对于谐振势，在温度 $$T$$下，角 $$\\phi$$ 的分布是高斯分布，其均值等于平衡角 $$\\phi_{0}$$，方差为 $$\\sigma^2 = \\frac{R T}{k}$$，其中 $$R$$ 是通用气体常数。\n\n当 $$\\phi$$ 穿过 $$\\phi = 0$$ 的边界时，发生手性反转。对于一个以 $$\\phi_{0}$$ 为中心的分布，这需要一个幅度至少为 $$|\\phi_{0}|$$ 的涨落。此类事件的概率 $$p$$ 由高斯分布的单侧尾部概率给出：\n$$ p = \\frac{1}{2} \\mathrm{erfc}\\left( \\frac{|\\phi_{0}|}{\\sqrt{2} \\sigma} \\right) $$\n其中 $$\\mathrm{erfc}$$ 是互补误差函数。\n\n将 $$T = T_{\\mathrm{high}}$$时代入 $$\\sigma$$ 的表达式：\n$$ p = \\frac{1}{2} \\mathrm{erfc}\\left( \\frac{|\\phi_{0}|}{\\sqrt{2} \\sqrt{R T_{\\mathrm{high}} / k}} \\right) = \\frac{1}{2} \\mathrm{erfc}\\left( |\\phi_{0}| \\sqrt{\\frac{k}{2 R T_{\\mathrm{high}}}} \\right) $$\n\n设计目标是找到满足约束条件 $$p \\le p_{\\max}$$ 的最小 $$k$$。由于 $$\\mathrm{erfc}(z)$$ 对于非负 $$z$$ 是一个单调递减函数，概率 $$p$$ 随着 $$k$$ 的增加而减小。为了找到最小的 $$k$$，我们将概率 $$p$$ 设置为其允许的最大值 $$p_{\\max}$$。\n$$ p_{\\max} = \\frac{1}{2} \\mathrm{erfc}\\left( |\\phi_{0}| \\sqrt{\\frac{k}{2 R T_{\\mathrm{high}}}} \\right) $$\n\n现在我们求解此方程以得到 $$k$$：\n1.  两边乘以 $$2$$：\n    $$ 2 p_{\\max} = \\mathrm{erfc}\\left( |\\phi_{0}| \\sqrt{\\frac{k}{2 R T_{\\mathrm{high}}}} \\right) $$\n2.  对两边应用反互补误差函数 $$\\mathrm{erfcinv}$$：\n    $$ \\mathrm{erfcinv}(2 p_{\\max}) = |\\phi_{0}| \\sqrt{\\frac{k}{2 R T_{\\mathrm{high}}}} $$\n3.  两边平方以消去平方根：\n    $$ \\left[ \\mathrm{erfcinv}(2 p_{\\max}) \\right]^2 = \\phi_{0}^2 \\left( \\frac{k}{2 R T_{\\mathrm{high}}} \\right) $$\n4.  最后，分離出 $$k$$：\n    $$ k = \\frac{2 R T_{\\mathrm{high}} \\left[ \\mathrm{erfcinv}(2 p_{\\max}) \\right]^2}{\\phi_{0}^2} $$\n\n此方程给出了最小力常数 $$k$$，单位为千焦耳/摩尔/弧度平方，使用给定的 $$R = 8.31446261815324 \\times 10^{-3} \\text{ kJ mol}^{-1} \\text{ K}^{-1}$$ 值。\n\n**每个测试用例的算法摘要：**\n1.  给定四个原子坐标矢量、$$T_{\\mathrm{high}}$$ 和 $$p_{\\max}$$。\n2.  计算矢量 $$\\mathbf{b}_{0}, \\mathbf{b}_{1}, \\mathbf{b}_{2}$$ 和法向量 $$\\mathbf{n}_{0}, \\mathbf{n}_{1}$$。\n3.  使用 `atan2` 公式计算 $$\\phi_{0}$$。\n4.  使用涉及 $$\\mathrm{erfcinv}$$ 的推导公式计算 $$k$$。\n5.  作为验证步骤，使用计算出的 $$k$$ 和高斯尾部概率公式计算实现的概率 $$p$$。此值应在浮点精度范围内等于 $$p_{\\max}$$。\n6.  报告 $$k$$、$$\\phi_{0}$$ 和 $$p$$ 的值，每个值都四舍五入到 $$6$$ 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfcinv, erfc\n\ndef solve():\n    \"\"\"\n    Calculates the minimal harmonic force constant for an improper torsion restraint\n    to suppress chiral inversion in molecular dynamics simulations.\n    \"\"\"\n    # Universal gas constant in kJ/(mol·K)\n    R = 8.31446261815324e-3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"coords\": np.array([\n                [1.0, 0.0, 0.0],\n                [0.1, 0.2, 0.0],\n                [0.0, 1.0, 0.0],\n                [0.0, 0.2, 0.9]\n            ]),\n            \"T_high\": 600.0,\n            \"p_max\": 1.0e-6\n        },\n        {\n            \"coords\": np.array([\n                [1.0, 0.0, 0.0],\n                [0.1, 0.2, 0.0],\n                [0.0, 1.0, 0.0],\n                [0.0, 0.2, -0.9]\n            ]),\n            \"T_high\": 600.0,\n            \"p_max\": 1.0e-8\n        },\n        {\n            \"coords\": np.array([\n                [1.0, 0.0, 0.0],\n                [0.1, 0.2, 0.0],\n                [0.0, 1.0, 0.0],\n                [0.0, 0.2, 0.02]\n            ]),\n            \"T_high\": 800.0,\n            \"p_max\": 1.0e-4\n        },\n        {\n            \"coords\": np.array([\n                [1.5, -0.2, 0.0],\n                [0.0, 0.0, 0.0],\n                [0.0, 1.2, 0.0],\n                [-0.1, 0.1, 1.0]\n            ]),\n            \"T_high\": 1200.0,\n            \"p_max\": 1.0e-6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        coords = case[\"coords\"]\n        T_high = case[\"T_high\"]\n        p_max = case[\"p_max\"]\n\n        # Step 1: Calculate the equilibrium improper angle (phi_0)\n        r0, r1, r2, r3 = coords[0], coords[1], coords[2], coords[3]\n        \n        b0 = r1 - r0\n        b1 = r2 - r1\n        b2 = r3 - r2\n\n        n0 = np.cross(b0, b1)\n        n1 = np.cross(b1, b2)\n\n        x = np.dot(n0, n1)\n        y = np.linalg.norm(b1) * np.dot(b0, n1)\n        \n        phi0 = np.arctan2(y, x)\n\n        # Step 2: Calculate the minimal force constant (k)\n        # Handle the case of a perfectly planar structure, though not expected\n        # in these test cases. If phi0 is zero, any finite k results in p=0.5.\n        if np.isclose(phi0, 0.0):\n            # This case is ill-defined for p_max  0.5.\n            # We can assign infinity or NaN, but based on test data, this path isn't taken.\n            k = np.inf\n        else:\n            # Z = erfcinv(2 * p_max)\n            Z = erfcinv(2.0 * p_max)\n            # k = (2 * R * T_high * Z^2) / phi0^2\n            k = (2.0 * R * T_high * Z**2) / (phi0**2)\n\n        # Step 3: Verify the achieved probability (p) with the calculated k\n        # sigma = sqrt(R * T_high / k)\n        sigma = np.sqrt(R * T_high / k)\n        # p = 0.5 * erfc(|phi0| / (sqrt(2) * sigma))\n        p_achieved = 0.5 * erfc(np.abs(phi0) / (np.sqrt(2.0) * sigma))\n        \n        results.append([k, phi0, p_achieved])\n\n    # Final print statement in the exact required format.\n    # Format: [[k1,phi0_1,p1],[k2,phi0_2,p2],...]\n    formatted_results = []\n    for res in results:\n        # Round every floating-point number to exactly 6 decimal places.\n        k_str = f\"{res[0]:.6f}\"\n        phi0_str = f\"{res[1]:.6f}\"\n        p_str = f\"{res[2]:.6f}\"\n        formatted_results.append(f\"[{k_str},{phi0_str},{p_str}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "碳水化合物的构象灵活性主要由糖苷键二面角 $\\phi$ 和 $\\psi$ 决定，因此精确描述其势能面是参数化的核心。这项综合练习将引导您完成参数化的完整工作流程：拟合势能面，并验证模型能否再现如核奥弗豪泽效应 (NOE) 距离等实验可观测量，从而将理论模型与真实世界的实验数据联系起来 。",
            "id": "3400156",
            "problem": "您的任务是实现一个物理上合理、基于算法的方案，用于为葡萄糖二糖重新拟合糖苷二面角参数。该方案使用截断傅里叶展开来模拟糖苷扭转，并通过再现核奥弗豪森效应（NOE）导出的距离来验证重新拟合的结果。重点在于糖苷二面角 $\\phi$ 和 $\\psi$，以及匹配由六阶矩平均值 $\\langle r^{-6}\\rangle^{-1/6}$ 定义的、源自NOE强度的有效距离。该计算方案必须从基本原理出发，特别是扭转势的周期性和用于系综平均的玻尔兹曼统计，并且不得依赖于预先给定的拟合参数或经验性捷径。\n\n从以下基本基础开始：\n- 对于一个二面角，其经典扭转势是周期函数。任何足够平滑的 $2\\pi$ 周期函数 $V(\\theta)$ 都可以用傅里叶级数表示，而截断级数在分子力学力场中被常规使用。使用在一组三角基函数上展开的 $V(\\phi,\\psi)$ 表示。\n- 扭转态上的平衡布居遵循玻尔兹曼统计。对于温度为 $T$ 的势 $V(\\phi,\\psi)$，其概率密度为 $p(\\phi,\\psi)\\propto\\exp\\left(-\\beta V(\\phi,\\psi)\\right)$，其中 $\\beta=1/\\left(k_{\\mathrm{B}}T\\right)$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。\n- 核奥弗豪森效应（NOE）的有效质子-质子距离为 $r_{\\mathrm{eff}}=\\left\\langle r^{-6}\\right\\rangle^{-1/6}$，其中系综平均是在玻尔兹曼分布上进行的。\n\n您的程序必须实现以下方案：\n1. 生成合成的从头算（ab initio）扭转扫描能量，以模拟使用相关一致性极化价三重泽塔基组（cc-pVTZ）的二阶 Møller–Plesset 微扰理论（MP2）。扫描覆盖了两个扭转角 $\\phi$ 和 $\\psi$（以弧度为单位）的均匀网格。合成的“真实”能量面由一组已知的傅里叶振幅和相位，外加一个实际的交叉项构成，然后通过添加小的高斯噪声来模拟量子化学计算的不完美性，以此作为输入数据。\n2. 使用线性最小二乘法将一个截断傅里叶模型拟合到带噪声的合成能量上，拟合基于三角基函数。使用以下线性基来表示重新拟合的势 $V_{\\mathrm{fit}}(\\phi,\\psi)$：一个常数项，对于 $n=1,2,3$ 的 $\\cos(n\\phi)$ 和 $\\sin(n\\phi)$，对于 $m=1,2,3$ 的 $\\cos(m\\psi)$ 和 $\\sin(m\\psi)$，以及一个包含 $\\cos(\\phi-\\psi)$ 和 $\\sin(\\phi-\\psi)$ 的耦合项。求解线性系数，以最小化在整个网格上与带噪声能量的平方误差。\n3. 通过计算一个代表性质子-质子对的 $r_{\\mathrm{eff}}$ 来验证重新拟合的结果，该质子对的距离通过一个物理上合理的三角映射 $r(\\phi,\\psi)=r_{0}+a\\cos\\left(\\phi-\\phi_{0}\\right)+b\\cos\\left(\\psi-\\psi_{0}\\right)$ 依赖于糖苷扭转角，其中的常数在每个测试案例中提供。计算两个有效距离：使用 $V_{\\mathrm{fit}}(\\phi,\\psi)$ 计算的 $r_{\\mathrm{eff}}^{\\mathrm{fit}}$ 和使用无噪声的“真实”势计算的 $r_{\\mathrm{eff}}^{\\mathrm{true}}$。使用在均匀网格上的离散玻尔兹曼平均来评估 $\\left\\langle r^{-6}\\right\\rangle$，然后取其-6次根。\n4. 报告重新拟合的势与带噪声的合成能量之间的均方根误差（RMSE）以量化拟合质量，并通过检查是否满足 $\\left|r_{\\mathrm{eff}}^{\\mathrm{fit}}-r_{\\mathrm{eff}}^{\\mathrm{true}}\\right|\\leq \\mathrm{tol}$ 来确定重新拟合是否再现了NOE导出的距离，其中 $\\mathrm{tol}$ 是每个测试案例指定的容差。\n\n角度必须以弧度为单位，能量必须以千焦/摩尔为单位，温度必须以开尔文为单位，距离必须以埃为单位。报告RMSE和 $r_{\\mathrm{eff}}^{\\mathrm{fit}}$ 时，四舍五入到三位小数。玻尔兹曼常数必须使用千焦/摩尔/开尔文的单位。\n\n为模型构建和验证实现以下细节：\n- 使用一个均匀网格，包含 $N_{\\phi}=36$ 和 $N_{\\psi}=36$ 个样本点，覆盖 $\\phi\\in[-\\pi,\\pi)$ 和 $\\psi\\in[-\\pi,\\pi)$ 的范围。\n- 合成的“真实”能量面定义为\n$$\nV_{\\mathrm{true}}(\\phi,\\psi)=\\sum_{n=1}^{3}K_{\\phi,n}\\left[1-\\cos\\left(n\\phi-\\delta_{\\phi,n}\\right)\\right]+\\sum_{m=1}^{3}K_{\\psi,m}\\left[1-\\cos\\left(m\\psi-\\delta_{\\psi,m}\\right)\\right]+K_{c}\\left[1-\\cos\\left(\\phi-\\psi-\\delta_{c}\\right)\\right],\n$$\n其中所有的 $K$ 以千焦/摩尔为单位，所有的相移 $\\delta$ 以弧度为单位。带噪声的合成能量为 $V_{\\mathrm{QM}}(\\phi,\\psi)=V_{\\mathrm{true}}(\\phi,\\psi)+\\epsilon$，其中 $\\epsilon$ 是均值为零、标准差为 $\\sigma_{E}$（单位为千焦/摩尔）的高斯噪声。为保证可复现性，每个案例使用指定的随机种子。\n- 重新拟合的模型是线性展开式\n$$\nV_{\\mathrm{fit}}(\\phi,\\psi)=C+\\sum_{n=1}^{3}\\left[A_{\\phi,n}\\cos(n\\phi)+B_{\\phi,n}\\sin(n\\phi)\\right]+\\sum_{m=1}^{3}\\left[A_{\\psi,m}\\cos(m\\psi)+B_{\\psi,m}\\sin(m\\psi)\\right]+A_{c}\\cos(\\phi-\\psi)+B_{c}\\sin(\\phi-\\psi),\n$$\n其中系数通过对在整个网格上评估的 $V_{\\mathrm{QM}}(\\phi,\\psi)$ 进行最小二乘法确定。\n\n关于网格上的玻尔兹曼平均：\n- 定义 $\\beta=1/\\left(k_{\\mathrm{B}}T\\right)$，其中 $k_{\\mathrm{B}}=0.008314462618$ 千焦/摩尔/开尔文。\n- 为提高数值稳定性，在指数化之前从能量面中减去最小能量 $V_{\\min}$，即使用权重 $w_{ij}=\\exp\\left(-\\beta\\left[V(\\phi_{i},\\psi_{j})-V_{\\min}\\right]\\right)$ 并通过 $Z=\\sum_{ij}w_{ij}$ 进行归一化。\n- 计算 $\\left\\langle r^{-6}\\right\\rangle=\\sum_{ij}\\left[w_{ij}/Z\\right]\\cdot r(\\phi_{i},\\psi_{j})^{-6}$，然后 $r_{\\mathrm{eff}}=\\left\\langle r^{-6}\\right\\rangle^{-1/6}$。\n\n测试套件：\n实现三个测试案例，以检验不同的行为。对于每个案例，给定用于 $\\phi$、$\\psi$ 和耦合项的“真实”振幅和相位；距离映射常数；温度 $T$；能量噪声水平 $\\sigma_{E}$；容差 $\\mathrm{tol}$；以及随机种子。\n\n- 案例 1（代表性的 $\\alpha$ 糖苷键）：\n  - $K_{\\phi}=\\left[2.5,1.2,0.5\\right]$, $\\delta_{\\phi}=\\left[0.0,\\frac{\\pi}{3},\\frac{\\pi}{2}\\right]$。\n  - $K_{\\psi}=\\left[3.0,0.8,0.4\\right]$, $\\delta_{\\psi}=\\left[\\frac{\\pi}{6},\\frac{\\pi}{2},\\frac{\\pi}{3}\\right]$。\n  - $K_{c}=0.6$, $\\delta_{c}=\\frac{\\pi}{4}$。\n  - 距离映射常数：$r_{0}=3.0$, $a=0.35$, $b=0.25$, $\\phi_{0}=0.0$, $\\psi_{0}=\\frac{\\pi}{3}$。\n  - $T=300$, $\\sigma_{E}=0.1$, $\\mathrm{tol}=0.06$, seed $=42$。\n\n- 案例 2（代表性的 $\\beta$ 糖苷键）：\n  - $K_{\\phi}=\\left[1.5,0.7,0.3\\right]$, $\\delta_{\\phi}=\\left[\\frac{\\pi}{2},0.0,\\frac{\\pi}{2}\\right]$。\n  - $K_{\\psi}=\\left[2.2,1.0,0.4\\right]$, $\\delta_{\\psi}=\\left[0.0,\\frac{\\pi}{3},\\frac{\\pi}{2}\\right]$。\n  - $K_{c}=0.2$, $\\delta_{c}=0.0$。\n  - 距离映射常数：$r_{0}=2.8$, $a=0.30$, $b=0.35$, $\\phi_{0}=\\frac{\\pi}{6}$, $\\psi_{0}=\\frac{\\pi}{4}$。\n  - $T=298$, $\\sigma_{E}=0.15$, $\\mathrm{tol}=0.05$, seed $=123$。\n\n- 案例 3（近乎平坦的边缘案例）：\n  - $K_{\\phi}=\\left[0.2,0.1,0.0\\right]$, $\\delta_{\\phi}=\\left[0.0,0.0,0.0\\right]$。\n  - $K_{\\psi}=\\left[0.2,0.1,0.0\\right]$, $\\delta_{\\psi}=\\left[0.0,0.0,0.0\\right]$。\n  - $K_{c}=0.0$, $\\delta_{c}=0.0$。\n  - 距离映射常数：$r_{0}=3.2$, $a=0.20$, $b=0.20$, $\\phi_{0}=0.0$, $\\psi_{0}=0.0$。\n  - $T=310$, $\\sigma_{E}=0.05$, $\\mathrm{tol}=0.08$, seed $=7$。\n\n您的程序应为每个案例计算：\n- $V_{\\mathrm{fit}}$ 与 $V_{\\mathrm{QM}}$ 在网格上的均方根误差 $\\mathrm{RMSE}$（单位为千焦/摩尔），四舍五入到三位小数。\n- NOE有效距离 $r_{\\mathrm{eff}}^{\\mathrm{fit}}$（单位为埃），四舍五入到三位小数。\n- 一个布尔值，指示是否满足 $\\left|r_{\\mathrm{eff}}^{\\mathrm{fit}}-r_{\\mathrm{eff}}^{\\mathrm{true}}\\right|\\leq \\mathrm{tol}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，列表由每个案例的结果三元组构成，每个三元组用方括号括起来，整个列表也用方括号括起来。例如，输出应类似于 $\\left[\\left[\\mathrm{RMSE}_{1},r_{\\mathrm{eff},1},\\mathrm{pass}_{1}\\right],\\left[\\mathrm{RMSE}_{2},r_{\\mathrm{eff},2},\\mathrm{pass}_{2}\\right],\\left[\\mathrm{RMSE}_{3},r_{\\mathrm{eff},3},\\mathrm{pass}_{3}\\right]\\right]$，其中 $\\mathrm{pass}_{i}$ 为 $\\mathrm{True}$ 或 $\\mathrm{False}$。所有角度必须以弧度为单位，能量以千焦/摩尔为单位，温度以开尔文为单位，距离以埃为单位，并且所有浮点值必须在指定处四舍五入到三位小数。",
            "solution": "该问题提出了一个在计算化学领域，特别是在分子力学力场参数化领域中，有效且定义明确的任务。它要求实现一个算法协议，以重新拟合二糖的糖苷键二面角参数。该协议基于统计力学的基本原理，并根据物理上有意义的可观测量——核奥弗豪森效应（NOE）导出的质子间距离进行验证。问题本身是自洽的、科学上合理的，并且在计算上是可行的。我们将着手提供一个详细的解决方案。\n\n目标是重新拟合控制糖苷扭转角 $\\phi$ 和 $\\psi$ 的势能面 $V(\\phi,\\psi)$，并通过其再现系综平均结构性质的能力来验证此拟合。该协议从第一性原理设计，避免了经验主义的捷径。\n\n**1. 理论与物理基础**\n\n分子的构象景观由其势能面（PES）决定。对于二面角，势能是一个周期函数。任何足够平滑的 $2\\pi$ 周期函数都可以通过截断傅里叶级数来近似。这是大多数经典力场中二面角参数化的基石。\n\n我们从一个合成的“真实”势能面 $V_{\\mathrm{true}}(\\phi,\\psi)$ 开始，它模拟了高质量的量子力学扫描。其函数形式是每个扭转角的周期项与一个耦合项之和：\n$$\nV_{\\mathrm{true}}(\\phi,\\psi)=\\sum_{n=1}^{3}K_{\\phi,n}\\left[1-\\cos\\left(n\\phi-\\delta_{\\phi,n}\\right)\\right]+\\sum_{m=1}^{3}K_{\\psi,m}\\left[1-\\cos\\left(m\\psi-\\delta_{\\psi,m}\\right)\\right]+K_{c}\\left[1-\\cos\\left(\\phi-\\psi-\\delta_{c}\\right)\\right]\n$$\n此处，$K$ 表示振幅（势垒高度），单位为千焦/摩尔（kJ/mol），$\\delta$ 是相移，单位为弧度。通过向这个真实表面添加标准差为 $\\sigma_E$ 的高斯噪声 $\\epsilon$，生成合成的“量子力学”数据 $V_{\\mathrm{QM}}(\\phi,\\psi)$：$V_{\\mathrm{QM}}(\\phi,\\psi)=V_{\\mathrm{true}}(\\phi,\\psi)+\\epsilon$。\n\n待拟合的模型 $V_{\\mathrm{fit}}(\\phi,\\psi)$ 由三角基函数的线性组合构成。这种选择确保了所需的周期性，并允许通过线性最小二乘法直接求解。该基组包括一个常数项和每个角度频率最高为3的正弦和余弦函数，外加一个交叉项：\n$$\nV_{\\mathrm{fit}}(\\phi,\\psi)=C+\\sum_{n=1}^{3}\\left[A_{\\phi,n}\\cos(n\\phi)+B_{\\phi,n}\\sin(n\\phi)\\right]+\\sum_{m=1}^{3}\\left[A_{\\psi,m}\\cos(m\\psi)+B_{\\psi,m}\\sin(m\\psi)\\right]+A_{c}\\cos(\\phi-\\psi)+B_{c}\\sin(\\phi-\\psi)\n$$\n微观势能面与宏观可观测量之间的联系由统计力学建立。在温度为 $T$ 的热平衡下，系统处于坐标为 $(\\phi,\\psi)$ 状态的概率由玻尔兹曼分布给出：\n$$\np(\\phi,\\psi) = \\frac{1}{Z} \\exp\\left(-\\beta V(\\phi,\\psi)\\right)\n$$\n其中 $\\beta = 1/(k_{\\mathrm{B}}T)$ 是逆热能，$k_{\\mathrm{B}}$ 是玻尔兹曼常数 ($0.008314462618~\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$)，$Z = \\int \\int \\exp(-\\beta V(\\phi,\\psi)) d\\phi d\\psi$ 是配分函数。\n\n验证依赖于NOE，它为质子间距离提供了实验约束。NOE信号强度与 $\\langle r^{-6} \\rangle$ 成正比，其中 $r$ 是质子间距离，尖括号表示在玻尔兹曼分布上的系综平均。因此，有效距离定义为：\n$$\nr_{\\mathrm{eff}}=\\left\\langle r^{-6}\\right\\rangle^{-1/6}\n$$\n距离 $r$ 本身是二面角的函数，由三角映射 $r(\\phi,\\psi)=r_{0}+a\\cos\\left(\\phi-\\phi_{0}\\right)+b\\cos\\left(\\psi-\\psi_{0}\\right)$ 给出。\n\n**2. 算法协议与实现**\n\n该协议作为一系列离散的计算步骤来实现。所有操作都在一个覆盖 $\\phi, \\psi \\in [-\\pi, \\pi)$ 的 $N_{\\phi}=36 \\times N_{\\psi}=36$ 个点的均匀网格上进行。\n\n**步骤 1：数据生成**\n对于每个测试案例，我们首先构建扭转角 $(\\phi_i, \\psi_j)$ 的二维网格。然后，我们在每个网格点上评估 $V_{\\mathrm{true}}(\\phi_i, \\psi_j)$ 的解析表达式。使用特定的随机种子生成一个高斯噪声值网格 $\\epsilon_{ij}$，其均值为0，标准差为 $\\sigma_E$。将这些噪声值添加到 $V_{\\mathrm{true}}$ 上，以产生用于拟合的目标数据 $V_{\\mathrm{QM}}$。\n\n**步骤 2：线性最小二乘拟合**\n重新拟合程序的核心是确定 $V_{\\mathrm{fit}}$ 模型的系数 $\\{C, A_{\\phi,n}, B_{\\phi,n}, \\ldots, B_c\\}$。这被表述为一个线性最小二乘问题 $\\mathbf{A}\\mathbf{c} \\approx \\mathbf{v}_{\\mathrm{QM}}$。\n- 向量 $\\mathbf{v}_{\\mathrm{QM}}$ 是一个由 $V_{\\mathrm{QM}}$ 表面上的 $N_{\\phi} \\times N_{\\psi} = 1296$ 个值展平而成的数组。\n- 向量 $\\mathbf{c}$ 包含待确定的15个未知系数。\n- 设计矩阵 $\\mathbf{A}$ 的维度为 $(1296 \\times 15)$。每一行对应一个网格点 $(\\phi_i, \\psi_j)$，每一列对应在该点上求值的15个基函数之一。例如，第一列全为1（对应系数 $C$），第二列是 $\\cos(\\phi_i)$，第三列是 $\\sin(\\phi_i)$，以此类推。\n\n使用标准的线性最小二乘求解器，特别是 `numpy.linalg.lstsq`，找到最小化平方欧几里得范数 $\\|\\mathbf{A}\\mathbf{c} - \\mathbf{v}_{\\mathrm{QM}}\\|^2$ 的最优系数向量 $\\mathbf{c}$。一旦获得 $\\mathbf{c}$，通过计算矩阵-向量积 $\\mathbf{A}\\mathbf{c}$ 并将结果重塑为 $36 \\times 36$ 的网格，来重建拟合的势能面 $V_{\\mathrm{fit}}$。拟合的质量由拟合表面 $V_{\\mathrm{fit}}$ 和噪声数据 $V_{\\mathrm{QM}}$ 之间的均方根误差（RMSE）来量化：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N_{\\phi}N_{\\psi}}\\sum_{i,j}\\left(V_{\\mathrm{fit}}(\\phi_i,\\psi_j) - V_{\\mathrm{QM}}(\\phi_i,\\psi_j)\\right)^2}\n$$\n\n**步骤 3：通过系综平均进行验证**\n关键的验证步骤评估拟合的势是否能再现“真实”系统的物理性质。我们通过对网格点进行离散求和来计算系综平均 $\\langle r^{-6} \\rangle$，并按其玻尔兹曼概率加权。对于一个通用的势能面 $V$，函数 $f(\\phi,\\psi)$ 的平均值为：\n$$\n\\langle f \\rangle \\approx \\frac{\\sum_{i,j} f(\\phi_i, \\psi_j) w_{ij}}{\\sum_{i,j} w_{ij}}\n$$\n其中统计权重为 $w_{ij}=\\exp\\left(-\\beta\\left[V(\\phi_{i},\\psi_{j})-V_{\\min}\\right]\\right)$。在指数化之前减去最小能量 $V_{\\min}$ 是一种防止数值溢出的标准技术。\n\n此计算执行两次：\n1. 使用 $V_{\\mathrm{true}}$ 计算“基准真相”有效距离 $r_{\\mathrm{eff}}^{\\mathrm{true}}$。\n2. 使用 $V_{\\mathrm{fit}}$ 计算我们模型的有效距离 $r_{\\mathrm{eff}}^{\\mathrm{fit}}$。\n\n如果这两个距离之间的绝对差在指定容差范围内，即 $|r_{\\mathrm{eff}}^{\\mathrm{fit}} - r_{\\mathrm{eff}}^{\\mathrm{true}}| \\leq \\mathrm{tol}$，则认为重新拟合是成功的。最终的程序为每个测试案例实现这套完整的工作流程，并报告拟合的RMSE、计算出的 $r_{\\mathrm{eff}}^{\\mathrm{fit}}$ 以及验证检查的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Implements a full protocol for refitting and validating glycosidic\n    dihedral parameters based on synthetic QM data and NOE-derived distances.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (representative alpha linkage)\n        {\n            \"K_phi\": [2.5, 1.2, 0.5], \"d_phi\": [0.0, np.pi/3, np.pi/2],\n            \"K_psi\": [3.0, 0.8, 0.4], \"d_psi\": [np.pi/6, np.pi/2, np.pi/3],\n            \"K_c\": 0.6, \"d_c\": np.pi/4,\n            \"dist_map\": {\"r0\": 3.0, \"a\": 0.35, \"b\": 0.25, \"phi0\": 0.0, \"psi0\": np.pi/3},\n            \"T\": 300, \"sigma_E\": 0.1, \"tol\": 0.06, \"seed\": 42\n        },\n        # Case 2 (representative beta linkage)\n        {\n            \"K_phi\": [1.5, 0.7, 0.3], \"d_phi\": [np.pi/2, 0.0, np.pi/2],\n            \"K_psi\": [2.2, 1.0, 0.4], \"d_psi\": [0.0, np.pi/3, np.pi/2],\n            \"K_c\": 0.2, \"d_c\": 0.0,\n            \"dist_map\": {\"r0\": 2.8, \"a\": 0.30, \"b\": 0.35, \"phi0\": np.pi/6, \"psi0\": np.pi/4},\n            \"T\": 298, \"sigma_E\": 0.15, \"tol\": 0.05, \"seed\": 123\n        },\n        # Case 3 (near-flat edge case)\n        {\n            \"K_phi\": [0.2, 0.1, 0.0], \"d_phi\": [0.0, 0.0, 0.0],\n            \"K_psi\": [0.2, 0.1, 0.0], \"d_psi\": [0.0, 0.0, 0.0],\n            \"K_c\": 0.0, \"d_c\": 0.0,\n            \"dist_map\": {\"r0\": 3.2, \"a\": 0.20, \"b\": 0.20, \"phi0\": 0.0, \"psi0\": 0.0},\n            \"T\": 310, \"sigma_E\": 0.05, \"tol\": 0.08, \"seed\": 7\n        }\n    ]\n\n    # Global parameters\n    N_PHI = 36\n    N_PSI = 36\n    K_B = 0.008314462618  # kJ/mol/K\n\n    def generate_true_potential(phi, psi, K_phi, d_phi, K_psi, d_psi, K_c, d_c):\n        \"\"\"Generates the true potential energy surface V_true.\"\"\"\n        V = np.zeros_like(phi)\n        for n in range(1, 4):\n            if n-1  len(K_phi):\n                V += K_phi[n-1] * (1 - np.cos(n * phi - d_phi[n-1]))\n        for m in range(1, 4):\n            if m-1  len(K_psi):\n                V += K_psi[m-1] * (1 - np.cos(m * psi - d_psi[m-1]))\n        V += K_c * (1 - np.cos(phi - psi - d_c))\n        return V\n\n    def build_design_matrix(phi, psi):\n        \"\"\"Builds the design matrix A for the linear least squares fit.\"\"\"\n        num_points = phi.size\n        # 1(const) + 3*2(phi) + 3*2(psi) + 2(couple) = 15 columns\n        A = np.zeros((num_points, 15))\n        \n        phi_flat = phi.flatten()\n        psi_flat = psi.flatten()\n        \n        A[:, 0] = 1.0  # Constant term\n        col_idx = 1\n        for n in range(1, 4):\n            A[:, col_idx] = np.cos(n * phi_flat)\n            A[:, col_idx+1] = np.sin(n * phi_flat)\n            col_idx += 2\n            \n        for m in range(1, 4):\n            A[:, col_idx] = np.cos(m * psi_flat)\n            A[:, col_idx+1] = np.sin(m * psi_flat)\n            col_idx += 2\n            \n        A[:, col_idx] = np.cos(phi_flat - psi_flat)\n        A[:, col_idx+1] = np.sin(phi_flat - psi_flat)\n        \n        return A\n\n    def calculate_effective_distance(V, phi, psi, T, r0, a, b, phi0, psi0):\n        \"\"\"Calculates the NOE effective distance r_eff from a potential surface V.\"\"\"\n        beta = 1.0 / (K_B * T)\n        \n        # Numerically stable Boltzmann weights\n        V_min = np.min(V)\n        weights = np.exp(-beta * (V - V_min))\n        Z = np.sum(weights)\n        probs = weights / Z\n        \n        # Distance map\n        R = r0 + a * np.cos(phi - phi0) + b * np.cos(psi - psi0)\n        \n        # Ensemble average of r^-6\n        r_m6_avg = np.sum(probs * (R**(-6)))\n        \n        # Effective distance\n        r_eff = r_m6_avg**(-1.0/6.0)\n        \n        return r_eff\n\n    results = []\n    \n    # Grid setup\n    phi_1d = np.linspace(-np.pi, np.pi, N_PHI, endpoint=False)\n    psi_1d = np.linspace(-np.pi, np.pi, N_PSI, endpoint=False)\n    PHI, PSI = np.meshgrid(phi_1d, psi_1d)\n\n    A_matrix = build_design_matrix(PHI, PSI)\n\n    for case in test_cases:\n        # 1. Generate synthetic data\n        V_true = generate_true_potential(PHI, PSI, case[\"K_phi\"], case[\"d_phi\"],\n                                         case[\"K_psi\"], case[\"d_psi\"], case[\"K_c\"], case[\"d_c\"])\n        \n        rng = np.random.default_rng(case[\"seed\"])\n        noise = rng.normal(0, case[\"sigma_E\"], size=(N_PSI, N_PHI))\n        V_QM = V_true + noise\n        \n        # 2. Fit the model using linear least squares\n        b = V_QM.flatten()\n        coeffs, _, _, _ = np.linalg.lstsq(A_matrix, b, rcond=None)\n        \n        V_fit_flat = A_matrix @ coeffs\n        V_fit = V_fit_flat.reshape((N_PSI, N_PHI))\n        \n        # 4. Calculate RMSE\n        rmse = np.sqrt(np.mean((V_fit - V_QM)**2))\n        \n        # 3. Validate with NOE distance\n        r_eff_true = calculate_effective_distance(V_true, PHI, PSI, case[\"T\"], **case[\"dist_map\"])\n        r_eff_fit = calculate_effective_distance(V_fit, PHI, PSI, case[\"T\"], **case[\"dist_map\"])\n        \n        # 4. Check tolerance\n        passes_check = np.abs(r_eff_fit - r_eff_true) = case[\"tol\"]\n        \n        # Format results\n        results.append([round(rmse, 3), round(r_eff_fit, 3), bool(passes_check)])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\").replace(\"True\", \"True\").replace(\"False\", \"False\"))\n\nsolve()\n```"
        }
    ]
}