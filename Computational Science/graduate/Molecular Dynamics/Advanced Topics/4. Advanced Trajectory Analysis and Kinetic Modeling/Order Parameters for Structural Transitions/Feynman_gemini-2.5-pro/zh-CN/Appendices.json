{
    "hands_on_practices": [
        {
            "introduction": "静态结构因子 $S(\\mathbf{k})$ 是一个强大的序参量，它通过傅里叶变换将原子系统的实空间结构与倒易空间中的可观测衍射图样联系起来。这项实践将指导您编写程序，从原子坐标出发计算 $S(\\mathbf{k})$，并利用其峰位特征来区分无序的液相、体心立方（BCC）和面心立方（FCC）等不同晶相。通过这项练习，您将掌握从模拟数据中识别和表征晶体结构的基本计算方法，这与分析实验散射数据的原理直接相关。",
            "id": "3430930",
            "problem": "给你一个三维周期性晶胞中的小规模原子坐标集，要求你在一组离散波矢网格上计算静态结构因子，然后根据得到的峰图样对相进行分类。静态结构因子由微观数密度定义，并且必须从第一性原理计算。\n\n基本原理：\n- 微观数密度定义为 $\\rho(\\mathbf{r}) = \\sum_{j=1}^{N} \\delta(\\mathbf{r} - \\mathbf{r}_j)$，其中 $N$ 是原子数，$\\mathbf{r}_j$ 是它们的位置。\n- 其傅里叶变换为 $\\rho_{\\mathbf{k}} = \\int \\rho(\\mathbf{r}) e^{i \\mathbf{k} \\cdot \\mathbf{r}} \\, d^3r = \\sum_{j=1}^{N} e^{i \\mathbf{k} \\cdot \\mathbf{r}_j}$。\n- 静态结构因子定义为 $S(\\mathbf{k}) = \\frac{1}{N} \\left| \\rho_{\\mathbf{k}} \\right|^2 = \\frac{1}{N} \\left| \\sum_{j=1}^{N} e^{i \\mathbf{k} \\cdot \\mathbf{r}_j} \\right|^2$。\n\n周期性边界条件意味着，对于一个线性尺寸为 $L_x = L_y = L_z = a$ 的立方晶胞，与周期性盒子相容的离散波矢为 $\\mathbf{k} = \\frac{2\\pi}{a} (m_x, m_y, m_z)$，其中 $m_x, m_y, m_z$ 为整数。在本问题中，使用一个均匀的整数三元组 $(m_x, m_y, m_z)$ 网格，其中对于 $\\alpha \\in \\{x,y,z\\}$，整数分量 $m_\\alpha$ 的取值范围为 $m_\\alpha \\in \\{-M, -M+1, \\dots, M-1, M\\}$，并排除零矢量 $(0,0,0)$。所有位置 $\\mathbf{r}_j$ 均以埃（Å）表示，所有波矢分量 $k_\\alpha$ 均以逆埃（Å$^{-1}$）表示。\n\n相分类目标：\n- 使用计算出的 $S(\\mathbf{k})$ 值将构型分类为以下三类之一，并用整数编码：\n  - $0$：无序（类液体），\n  - $1$：体心立方（BCC），\n  - $2$：面心立方（FCC）。\n- 分类必须仅基于 $S(\\mathbf{k})$ 的峰图样和由基元引起的干涉所推导出的倒易点阵选择定则：\n  - 对于体心立方基元，原子位于 $\\mathbf{0}$ 和 $\\frac{a}{2}(1,1,1)$，其基元的结构因子为 $F(h,k,l) = 1 + e^{i\\pi(h+k+l)}$，因此当 $h+k+l$ 为偶数时出现非零峰。模长最小的非零峰满足 $h^2 + k^2 + l^2 = 2$（{110} 晶面族）。\n  - 对于面心立方基元，原子位于 $\\mathbf{0}$、$\\frac{a}{2}(0,1,1)$、$\\frac{a}{2}(1,0,1)$ 和 $\\frac{a}{2}(1,1,0)$，其基元的结构因子为 $F(h,k,l) = 1 + e^{i\\pi(k+l)} + e^{i\\pi(h+l)} + e^{i\\pi(h+k)}$，因此当 $h,k,l$ 全为偶数或全为奇数时出现非零峰。模长最小的非零峰满足 $h^2 + k^2 + l^2 = 3$（{111} 晶面族）。\n- 为区分无序与晶态，按如下方式将 $S(\\mathbf{k})$ 的最大值与 $N$ 进行比较。定义 $R = \\frac{\\max_{\\mathbf{k}} S(\\mathbf{k})}{N}$。如果 $R  \\tau$（其中 $\\tau = 0.6$），则分类为无序（$0$）。否则，若为晶态，则确定最强的峰是否遵循 BCC 或 FCC 的奇偶规则，以及它们最低的非零 $h^2+k^2+l^2$ 是否分别匹配 $2$ 或 $3$。使用这些标准将其分类为 BCC（$1$）或 FCC（$2$）。如果标准冲突，则退而采用与大多数顶峰匹配的奇偶规则。\n\n算法任务：\n1. 对于每个测试用例，使用上述定义在指定的网格上计算 $S(\\mathbf{k})$。使用网格范围参数 $M=3$。\n2. 对于每个用例，计算 $R = \\max_{\\mathbf{k}} S(\\mathbf{k}) / N$。如果 $R  0.6$，输出 $0$。\n3. 如果 $R \\ge 0.6$，识别顶峰集合，定义为满足 $S(\\mathbf{k}) \\ge 0.99 \\cdot \\max_{\\mathbf{k}} S(\\mathbf{k})$ 的那些 $\\mathbf{k}$。在这些顶峰中，计算：\n   - $(h,k,l) = (m_x, m_y, m_z)$ 的 $h^2+k^2+l^2$ 的最小非零值，并检查其是否等于 $2$ 或 $3$。\n   - 奇偶规则计数：$h+k+l$ 为偶数（BCC 允许）的顶峰数量，以及 $h,k,l$ 全为偶数或全为奇数（FCC 允许）的顶峰数量。\n4. 如果顶峰中的最小非零 $h^2+k^2+l^2$ 为 $2$ 且大多数顶峰满足 $h+k+l$ 为偶数，则分类为 BCC（$1$）；如果顶峰中的最小非零 $h^2+k^2+l^2$ 为 $3$ 且大多数顶峰满足全偶或全奇规则，则分类为 FCC（$2$）。在任何其他晶态情况下，根据计数较多的奇偶规则（BCC 或 FCC）选择类别。如果没有哪个规则占严格多数，则分类为无序（$0$）。\n\n测试套件：\n使用以下四个测试用例。在所有用例中，立方盒子的边长为 $a = 3.0$ Å，波矢网格使用 $M=3$。\n- 用例 $1$（理想 BCC）：$N=2$ 个原子，位置为 $\\mathbf{r}_1 = (0,0,0)$ Å 和 $\\mathbf{r}_2 = \\left(\\frac{a}{2},\\frac{a}{2},\\frac{a}{2}\\right)$ Å。\n- 用例 $2$（理想 FCC）：$N=4$ 个原子，位置为 $\\mathbf{r}_1 = (0,0,0)$ Å、$\\mathbf{r}_2 = \\left(0,\\frac{a}{2},\\frac{a}{2}\\right)$ Å、$\\mathbf{r}_3 = \\left(\\frac{a}{2},0,\\frac{a}{2}\\right)$ Å 和 $\\mathbf{r}_4 = \\left(\\frac{a}{2},\\frac{a}{2},0\\right)$ Å。\n- 用例 $3$（无序）：$N=64$ 个原子，其位置是使用固定种子 $s=42$ 的伪随机数生成器，沿着每个笛卡尔轴从 $[0,a)$ 区间独立均匀采样得到的；也就是说，对于 $j=1,\\dots,64$，$\\mathbf{r}_j$ 的分量 $x_j, y_j, z_j \\sim \\mathrm{Uniform}(0,a)$，使用指定的种子。\n- 用例 $4$（含噪声的 BCC）：从用例 $1$ 的 BCC 位置开始，为每个原子的每个笛卡尔分量添加均值为零、标准差为 $\\sigma = 0.1$ Å 的独立高斯位移，即 $\\mathbf{r}_j \\leftarrow \\mathbf{r}_j + \\boldsymbol{\\eta}_j$，其中 $\\boldsymbol{\\eta}_j$ 的分量从 $\\mathcal{N}(0,\\sigma^2)$ 中采样，使用种子 $s=7$。\n\n最终输出格式：\n你的程序应产生单行输出，其中包含用例 1 到 4 的分类结果，形式为方括号括起来的逗号分隔整数列表（例如，\"[1,2,0,1]\"）。不应打印任何额外文本。这些整数必须按照上面列出的用例顺序排列。",
            "solution": "该问题要求将原子构型分类为无序相、体心立方（BCC）相或面心立方（FCC）相。这是通过计算静态结构因子 $S(\\mathbf{k})$ 并分析其在倒易空间中的峰图样来实现的。该过程基于晶体学和统计力学的基本原理。\n\n第一步是为给定的一组 $N$ 个原子位置 $\\{\\mathbf{r}_j\\}$ 计算静态结构因子 $S(\\mathbf{k})$。结构因子通过微观数密度 $\\rho(\\mathbf{r}) = \\sum_{j=1}^{N} \\delta(\\mathbf{r} - \\mathbf{r}_j)$ 的傅里叶变换来定义。在给定波矢 $\\mathbf{k}$ 处的傅里叶分量 $\\rho_{\\mathbf{k}}$ 为：\n$$\n\\rho_{\\mathbf{k}} = \\int \\rho(\\mathbf{r}) e^{i \\mathbf{k} \\cdot \\mathbf{r}} \\, d^3r = \\sum_{j=1}^{N} e^{i \\mathbf{k} \\cdot \\mathbf{r}_j}\n$$\n静态结构因子 $S(\\mathbf{k})$ 随后被定义为该复数量的归一化模长的平方：\n$$\nS(\\mathbf{k}) = \\frac{1}{N} \\left| \\rho_{\\mathbf{k}} \\right|^2 = \\frac{1}{N} \\left| \\sum_{j=1}^{N} e^{i \\mathbf{k} \\cdot \\mathbf{r}_j} \\right|^2\n$$\n对于边长为 $a$ 的立方周期性晶胞内的系统，与周期性边界条件兼容的波矢 $\\mathbf{k}$ 在倒易空间中形成一个离散网格：\n$$\n\\mathbf{k} = \\frac{2\\pi}{a} (m_x, m_y, m_z)\n$$\n其中 $m_x$、$m_y$ 和 $m_z$ 是整数。问题指明，我们需要在一个网格上计算 $S(\\mathbf{k})$，其中每个整数分量 $m_\\alpha$ 的取值范围为 $-M$ 到 $M$，且 $M=3$。中心点 $\\mathbf{k}=\\mathbf{0}$（对应于 $(m_x, m_y, m_z)=(0,0,0)$）被排除，因为 $S(\\mathbf{0})=N$，它不携带结构信息。\n\n第二步是分类算法，该算法分析计算出的 $S(\\mathbf{k})$ 值。首先，要区分无序（类液体）状态和有序（晶态）状态。在完美晶体中，相长干涉导致尖锐的布拉格峰，此时 $S(\\mathbf{k})$ 与 $N$ 成正比。在液体中，对于 $\\mathbf{k} \\neq \\mathbf{0}$，$S(\\mathbf{k})$ 通常为 $1$ 的量级。我们通过计算比率 $R = \\frac{\\max_{\\mathbf{k}} S(\\mathbf{k})}{N}$ 来量化这一点。如果 $R$ 低于阈值 $\\tau=0.6$，系统就被分类为无序（类别 $0$）。\n\n如果 $R \\ge 0.6$，则认为该构型是晶态的，我们进而区分 BCC 和 FCC 结构。这通过检查倒易空间中最强烈的峰的位置来完成。这些位置由晶体基元决定的选择定则所支配。\n- 对于 BCC 晶格，当米勒指数 $(h,k,l)$（对应于我们的整数三元组 $(m_x,m_y,m_z)$）之和 $h+k+l$ 为偶数时，会发生相长干涉（出现非零峰）。模长最小的倒易点阵矢量集对应于 $\\{110\\}$ 晶面族，其中 $h^2+k^2+l^2=2$。\n- 对于 FCC 晶格，当指数 $(h,k,l)$ 全为偶数或全为奇数（奇偶性未混合）时，会发生相长干涉。模长最小的非零倒易点阵矢量集是 $\\{111\\}$ 晶面族，其中 $h^2+k^2+l^2=3$。\n\n该算法识别出“顶峰”集合，其中 $S(\\mathbf{k})$ 至少是全局最大值的 $99\\%$。利用这个峰集，它检查两个条件：\n1.  顶峰中 $m_x^2+m_y^2+m_z^2$ 的最小非零值。\n2.  顶峰的指数对 BCC 和 FCC 奇偶选择定则的遵守情况。\n\n最终的分类遵循一个分层逻辑：\n- 如果一个构型的顶峰指数的最小模方为 $2$，且其大多数顶峰满足 BCC 奇偶规则（$m_x+m_y+m_z$ 为偶数），则将其分类为 BCC（类别 $1$）。\n- 如果最小模方为 $3$，且其大多数顶峰满足 FCC 奇偶规则（所有指数全为偶数或全为奇数），则将其分类为 FCC（类别 $2$）。\n- 如果这些主要条件均未满足，则使用后备机制：结构被分配到其奇偶规则被更多顶峰满足的类别（BCC 或 FCC）。\n- 如果两种奇偶规则的计数相等，则该结构无法被明确分类，并被分配为无序类别 $0$。\n\n此程序应用于四个测试用例：一个理想的 BCC 基元、一个理想的 FCC 基元、一个随机生成的无序构型，以及一个添加了类热噪声的 BCC 基元。实现过程涉及生成波矢网格，为每个用例计算 $S(\\mathbf{k})$，并应用分类逻辑来确定最终的相指派。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Computes the static structure factor for several atomic configurations\n    and classifies them as disordered, BCC, or FCC.\n    \"\"\"\n\n    # Define common parameters from the problem statement.\n    a = 3.0  # Angstrom\n    M = 3\n    tau = 0.6\n    \n    # --- Test Case Definitions ---\n    test_cases = []\n\n    # Case 1: Ideal BCC\n    pos1 = np.array([[0.0, 0.0, 0.0], [a / 2, a / 2, a / 2]])\n    test_cases.append(pos1)\n\n    # Case 2: Ideal FCC\n    pos2 = np.array([[0.0, 0.0, 0.0], [0.0, a / 2, a / 2], [a / 2, 0.0, a / 2], [a / 2, a / 2, 0.0]])\n    test_cases.append(pos2)\n\n    # Case 3: Disordered\n    rng_disordered = np.random.default_rng(seed=42)\n    pos3 = rng_disordered.uniform(0, a, size=(64, 3))\n    test_cases.append(pos3)\n\n    # Case 4: Noisy BCC\n    rng_noisy = np.random.default_rng(seed=7)\n    pos4_ideal = np.array([[0.0, 0.0, 0.0], [a / 2, a / 2, a / 2]])\n    noise = rng_noisy.normal(loc=0.0, scale=0.1, size=pos4_ideal.shape)\n    pos4 = pos4_ideal + noise\n    test_cases.append(pos4)\n\n    results = []\n    for positions in test_cases:\n        classification = process_case(positions, a, M, tau)\n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(positions: np.ndarray, a: float, M: int, tau: float) -> int:\n    \"\"\"\n    Performs classification for a single set of atomic positions.\n    \"\"\"\n    N = positions.shape[0]\n    if N == 0:\n        return 0\n\n    # 1. Generate k-vector grid and compute S(k)\n    m_range = range(-M, M + 1)\n    m_triplets = [m for m in itertools.product(m_range, repeat=3) if m != (0, 0, 0)]\n    m_array = np.array(m_triplets, dtype=np.float64)\n    \n    k_vectors = (2 * np.pi / a) * m_array\n    \n    # Vectorized computation of S(k)\n    k_dot_r = k_vectors @ positions.T\n    rho_k = np.sum(np.exp(1j * k_dot_r), axis=1)\n    s_k_values = (1.0 / N) * np.abs(rho_k)**2\n\n    # 2. Compute R = max(S(k)) / N and check for disordered state\n    s_max = np.max(s_k_values)\n    R = s_max / N\n    if R  tau:\n        return 0  # Classify as disordered\n        \n    # 3. Crystalline analysis\n    # Identify top peaks\n    top_peaks_indices = np.where(s_k_values >= 0.99 * s_max)[0]\n    top_m_triplets = [m_triplets[i] for i in top_peaks_indices]\n\n    if not top_m_triplets:\n        return 0 # Should not happen, but as a safeguard\n\n    # Compute minimal non-zero h^2+k^2+l^2 for top peaks\n    hkl_sq_sums = [h**2 + k**2 + l**2 for h, k, l in top_m_triplets]\n    min_h2k2l2 = min(hkl_sq_sums)\n\n    # Count peaks satisfying BCC and FCC parity rules\n    bcc_count = 0\n    fcc_count = 0\n    for h, k, l in top_m_triplets:\n        # BCC rule: h+k+l is even\n        if (h + k + l) % 2 == 0:\n            bcc_count += 1\n        # FCC rule: h, k, l all even or all odd\n        if (h % 2 == k % 2) and (k % 2 == l % 2):\n            fcc_count += 1\n            \n    # 4. Apply hierarchical classification logic\n    num_top_peaks = len(top_m_triplets)\n    \n    # Primary classification rules\n    if min_h2k2l2 == 2 and bcc_count > num_top_peaks / 2.0:\n        return 1\n    if min_h2k2l2 == 3 and fcc_count > num_top_peaks / 2.0:\n        return 2\n\n    # Fallback rules based on larger count\n    if bcc_count > fcc_count:\n        return 1\n    if fcc_count > bcc_count:\n        return 2\n        \n    # Final tie-breaker: if counts are equal, classify as disordered\n    return 0\n\nsolve()\n```"
        },
        {
            "introduction": "与描述系统全局有序度的结构因子不同，键合方向序参量（如 Steinhardt 序参量 $Q_l$）专注于量化单个原子周围的局部几何环境。这项实践是一项理论推导，要求您利用球谐函数的基本性质来确定 $Q_l$ 的归一化常数，从而确保其在理想结构下取值为1。掌握这一推导过程对于深刻理解这些序参量的数学构造和在实践中正确解释其数值至关重要。",
            "id": "3430955",
            "problem": "考虑一个分子动力学 (MD) 模拟中的粒子，其局域环境由 $N_b$ 个近邻键矢量 $\\{\\mathbf{r}_j\\}_{j=1}^{N_b}$ 及其相应的单位方向 $\\hat{\\mathbf{r}}_j = \\mathbf{r}_j/|\\mathbf{r}_j|$ 描述。通过将这些方向投影到 $l$ 阶复球谐函数 $Y_{l m}(\\hat{\\mathbf{r}})$（其中 $m \\in \\{-l,\\dots,l\\}$）上，可以构建一个键取向有序度量。设每个近邻被赋予一个非负权重 $w_j$，并定义未归一化的谐波振幅为 $q_{l m} = \\sum_{j=1}^{N_b} w_j Y_{l m}(\\hat{\\mathbf{r}}_j)$，总权重为 $W = \\sum_{j=1}^{N_b} w_j$。通过对 $m$ 进行聚合，定义一个标量键取向有序参数 $Q_l = C_l \\left(\\sum_{m=-l}^{l} |q_{l m}|^2\\right)^{1/2}/W$，其中 $C_l$ 是一个待定的归一化常数。\n\n请仅使用球谐函数的基本性质，包括其在单位球面上的正交归一性和加法定理，推导归一化常数 $C_l$，使得对于所有近邻方向都相同（即对所有 $j$ 都有 $\\hat{\\mathbf{r}}_j = \\hat{\\mathbf{n}}$）的任何构型，$Q_l = 1$ 恒成立，且与所选权重 $\\{w_j\\}$ 无关。请用 $l$、$Y_{l m}$、$\\hat{\\mathbf{r}}_j$ 和 $w_j$ 显式地表示最终归一化后的 $Q_l$。\n\n然后，从第一性原理出发，分析加权方案的选择如何影响 $Q_l$ 在近邻列表受到扰动时的值和稳健性。特别是，比较以下两种情况：\n- 均匀加权 $w_j = 1$（对所有 $j$）。\n- 反比距离加权 $w_j = |\\mathbf{r}_j|^{-p}$（对于某个固定的 $p  0$）。\n\n你的分析应考虑将一个方向为 $\\hat{\\mathbf{s}}$、权重为 $w_s$ 的伪近邻添加到一个方向为 $\\hat{\\mathbf{n}}$ 的完全对齐的近邻集合中对 $Q_l$ 的影响，并使用球谐函数加法定理，将 $Q_l$ 的一阶变化量化为归一化扰动振幅 $\\alpha = w_s/W_{\\text{new}}$ 的函数，其中 $W_{\\text{new}}$ 是添加伪近邻后的新权重总和。不要计算任何数值；请提供符号表达式和标度分析。你的最终答案必须是归一化 $Q_l$ 的闭式解析表达式。不需要单位。不需要四舍五入。",
            "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- 局域环境由 $N_b$ 个近邻键矢量 $\\{\\mathbf{r}_j\\}_{j=1}^{N_b}$ 描述。\n- 单位方向矢量：$\\hat{\\mathbf{r}}_j = \\mathbf{r}_j/|\\mathbf{r}_j|$。\n- $l$ 阶复球谐函数：$Y_{l m}(\\hat{\\mathbf{r}})$，其中 $m \\in \\{-l,\\dots,l\\}$。\n- 每个近邻的非负权重：$w_j \\ge 0$。\n- 未归一化的谐波振幅：$q_{l m} = \\sum_{j=1}^{N_b} w_j Y_{l m}(\\hat{\\mathbf{r}}_j)$。\n- 总权重：$W = \\sum_{j=1}^{N_b} w_j$。\n- 标量键取向有序参数：$Q_l = C_l \\left(\\sum_{m=-l}^{l} |q_{l m}|^2\\right)^{1/2}/W$。\n- $C_l$ 是一个归一化常数。\n- 归一化条件：当所有近邻方向相同时，$Q_l = 1$，即对于所有 $j=1, \\dots, N_b$，都有 $\\hat{\\mathbf{r}}_j = \\hat{\\mathbf{n}}$。\n- 待使用的工具：球谐函数的基本性质，包括正交归一性和加法定理。\n- 任务 1：推导常数 $C_l$ 和归一化 $Q_l$ 的显式表达式。\n- 任务 2：分析均匀加权 ($w_j = 1$) 与反比距离加权 ($w_j = |\\mathbf{r}_j|^{-p}$) 对 $Q_l$ 稳健性的影响。\n- 任务 3：使用球谐函数加法定理，量化由单个伪近邻引起的 $Q_l$ 的一阶变化。要求的最终答案是归一化 $Q_l$ 的闭式表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于标准的 Steinhardt-Nelson-Ronchetti 键取向有序参数，这是凝聚态物理和分子模拟中结构分析的基石。其公式是正确且被广泛使用的。\n- **适定性**：该问题是适定的。它提供了所有必要的定义和一个清晰、具有物理意义的条件来确定未知常数 $C_l$。后续的分析是有导向性的，并且基于标准的数学物理方法。\n- **客观性**：语言是技术性的、精确的，并且没有任何主观或模糊的术语。\n- **完备性与一致性**：该问题是自洽的。它指定了要使用的数学工具（球谐函数的性质），这些工具足以进行完整的推导。没有内部矛盾。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整的解答。\n\n### 归一化常数 $C_l$ 的推导\n\n键取向有序参数定义为：\n$$Q_l = C_l \\frac{\\left(\\sum_{m=-l}^{l} |q_{l m}|^2\\right)^{1/2}}{W}$$\n其中 $q_{l m} = \\sum_{j=1}^{N_b} w_j Y_{l m}(\\hat{\\mathbf{r}}_j)$ 且 $W = \\sum_{j=1}^{N_b} w_j$。\n\n我们施加归一化条件，即对于一个所有键矢量都沿着单一方向 $\\hat{\\mathbf n}$ 对齐的完全有序构型，$Q_l=1$。也就是说，对于所有 $j \\in \\{1, \\dots, N_b\\}$，都有 $\\hat{\\mathbf{r}}_j = \\hat{\\mathbf n}$。\n\n在此特定情况下，未归一化的谐波振幅 $q_{l m}$ 变为：\n$$q_{l m} = \\sum_{j=1}^{N_b} w_j Y_{l m}(\\hat{\\mathbf{n}}) = Y_{l m}(\\hat{\\mathbf{n}}) \\sum_{j=1}^{N_b} w_j = W Y_{l m}(\\hat{\\mathbf{n}})$$\n总权重 $W$ 仅是所有权重的总和，对于任何非平凡的近邻集合，该值都是非零的。\n\n现在，我们计算这些振幅的模平方和：\n$$\\sum_{m=-l}^{l} |q_{l m}|^2 = \\sum_{m=-l}^{l} |W Y_{l m}(\\hat{\\mathbf{n}})|^2 = W^2 \\sum_{m=-l}^{l} |Y_{l m}(\\hat{\\mathbf{n}})|^2$$\n对 $m$ 的求和可以使用球谐函数加法定理来计算，该定理指出：\n$$\\sum_{m=-l}^{l} Y_{l m}^*(\\hat{\\mathbf{r}}_1) Y_{l m}(\\hat{\\mathbf{r}}_2) = \\frac{2l+1}{4\\pi} P_l(\\hat{\\mathbf{r}}_1 \\cdot \\hat{\\mathbf{r}}_2)$$\n其中 $P_l(x)$ 是 $l$ 阶勒让德多项式。设 $\\hat{\\mathbf{r}}_1 = \\hat{\\mathbf{r}}_2 = \\hat{\\mathbf{n}}$，并注意到 $Y_{l m}^*(\\hat{\\mathbf{n}})Y_{l m}(\\hat{\\mathbf{n}}) = |Y_{l m}(\\hat{\\mathbf{n}})|^2$，该定理给出：\n$$\\sum_{m=-l}^{l} |Y_{l m}(\\hat{\\mathbf{n}})|^2 = \\frac{2l+1}{4\\pi} P_l(\\hat{\\mathbf{n}} \\cdot \\hat{\\mathbf{n}})$$\n由于 $\\hat{\\mathbf{n}}$ 是单位矢量，$\\hat{\\mathbf{n}} \\cdot \\hat{\\mathbf{n}} = 1$。勒让德多项式具有性质 $P_l(1)=1$（对所有 $l$）。因此：\n$$\\sum_{m=-l}^{l} |Y_{l m}(\\hat{\\mathbf{n}})|^2 = \\frac{2l+1}{4\\pi}$$\n将此结果代回到 $\\sum |q_{l m}|^2$ 的表达式中：\n$$\\sum_{m=-l}^{l} |q_{l m}|^2 = W^2 \\left(\\frac{2l+1}{4\\pi}\\right)$$\n现在我们将此结果代入 $Q_l$ 的定义，并应用归一化条件 $Q_l=1$：\n$$1 = Q_l = C_l \\frac{\\left( W^2 \\left(\\frac{2l+1}{4\\pi}\\right) \\right)^{1/2}}{W} = C_l \\frac{W \\sqrt{\\frac{2l+1}{4\\pi}}}{W} = C_l \\sqrt{\\frac{2l+1}{4\\pi}}$$\n解出归一化常数 $C_l$：\n$$C_l = \\sqrt{\\frac{4\\pi}{2l+1}}$$\n有了此常数，完全归一化的键取向有序参数 $Q_l$ 由下式给出：\n$$Q_l = \\sqrt{\\frac{4\\pi}{2l+1}} \\frac{\\left(\\sum_{m=-l}^{l} \\left| \\sum_{j=1}^{N_b} w_j Y_{l m}(\\hat{\\mathbf{r}}_j) \\right|^2\\right)^{1/2}}{\\sum_{j=1}^{N_b} w_j}$$\n此表达式即为所要求的闭式解析结果。\n\n### 加权方案与稳健性分析\n\n我们通过考虑一个包含 $N_b$ 个近邻的系统来分析 $Q_l$ 的稳健性。这些近邻初始时完全沿 $\\hat{\\mathbf n}$ 方向对齐，权重为 $w_j^0$，然后向该系统中添加一个方向为 $\\hat{\\mathbf s}$、权重为 $w_s$ 的单个伪近邻。\n\n对齐系统的初始谐波振幅为 $q_{lm}^{(0)} = (\\sum_j w_j^0) Y_{lm}(\\hat{\\mathbf n}) = W_0 Y_{lm}(\\hat{\\mathbf n})$。初始有序参数为 $Q_l=1$。\n\n添加伪近邻后，新的谐波振幅为：\n$$q'_{l m} = q_{lm}^{(0)} + w_s Y_{l m}(\\hat{\\mathbf{s}}) = W_0 Y_{l m}(\\hat{\\mathbf{n}}) + w_s Y_{l m}(\\hat{\\mathbf{s}})$$\n新的总权重为 $W_{\\text{new}} = W_0 + w_s$。模平方和为：\n$$\\sum_{m=-l}^{l} |q'_{l m}|^2 = \\sum_{m=-l}^{l} |W_0 Y_{l m}(\\hat{\\mathbf{n}}) + w_s Y_{l m}(\\hat{\\mathbf{s}})|^2$$\n展开求和内的项：\n$$|q'_{l m}|^2 = (W_0 Y_{l m}(\\hat{\\mathbf{n}}) + w_s Y_{l m}(\\hat{\\mathbf{s}}))(W_0 Y_{l m}^*(\\hat{\\mathbf{n}}) + w_s Y_{l m}^*(\\hat{\\mathbf{s}}))$$\n$$|q'_{l m}|^2 = W_0^2 |Y_{l m}(\\hat{\\mathbf{n}})|^2 + w_s^2 |Y_{l m}(\\hat{\\mathbf{s}})|^2 + W_0 w_s [Y_{l m}(\\hat{\\mathbf{n}})Y_{l m}^*(\\hat{\\mathbf{s}}) + Y_{l m}^*(\\hat{\\mathbf{n}})Y_{l m}(\\hat{\\mathbf{s}})]$$\n对 $m$ 求和并像之前一样应用加法定理：\n$$ \\sum_{m=-l}^{l} |q'_{l m}|^2 = W_0^2\\left(\\frac{2l+1}{4\\pi}\\right) + w_s^2\\left(\\frac{2l+1}{4\\pi}\\right) + W_0 w_s \\left[ \\frac{2l+1}{4\\pi}P_l(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{s}}) + \\frac{2l+1}{4\\pi}P_l(\\hat{\\mathbf{s}}\\cdot\\hat{\\mathbf{n}}) \\right] $$\n由于 $P_l(x)$ 是实函数且 $\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{s}} = \\hat{\\mathbf{s}}\\cdot\\hat{\\mathbf{n}}$，上式简化为：\n$$ \\sum_{m=-l}^{l} |q'_{l m}|^2 = \\left( \\frac{2l+1}{4\\pi} \\right) \\left[ W_0^2 + w_s^2 + 2 W_0 w_s P_l(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{s}}) \\right] $$\n新的有序参数 $Q'_l$ 是：\n$$Q'_l = \\sqrt{\\frac{4\\pi}{2l+1}} \\frac{\\left( \\sum_{m=-l}^{l} |q'_{l m}|^2 \\right)^{1/2}}{W_{\\text{new}}} = \\frac{\\sqrt{W_0^2 + w_s^2 + 2 W_0 w_s P_l(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{s}})}}{W_0 + w_s}$$\n为了分析一阶变化，我们定义归一化扰动振幅 $\\alpha = w_s / W_{\\text{new}}$。由此可得 $w_s = \\alpha W_{\\text{new}}$ 和 $W_0 = W_{\\text{new}} - w_s = (1-\\alpha)W_{\\text{new}}$。将这些代入 $Q'_l$ 的表达式中：\n$$Q'_l = \\frac{\\sqrt{(1-\\alpha)^2 W_{\\text{new}}^2 + \\alpha^2 W_{\\text{new}}^2 + 2(1-\\alpha)\\alpha W_{\\text{new}}^2 P_l(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{s}})}}{W_{\\text{new}}}$$\n$$Q'_l = \\sqrt{(1-2\\alpha+\\alpha^2) + \\alpha^2 + (2\\alpha-2\\alpha^2) P_l(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{s}})} = \\sqrt{1 - 2\\alpha(1 - P_l(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{s}})) + 2\\alpha^2(1 - P_l(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{s}}))}$$\n对于小扰动，$\\alpha \\ll 1$。我们在 $\\alpha=0$ 附近对 $Q'_l$ 进行泰勒展开：\n$$Q'_l = (1-x)^{1/2} \\approx 1 - \\frac{1}{2}x \\quad \\text{其中} \\quad x = 2\\alpha(1-P_l(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{s}})) + O(\\alpha^2)$$\n对 $\\alpha$ 取一阶近似，受扰动后的有序参数为：\n$$Q'_l \\approx 1 - \\alpha(1-P_l(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{s}}))$$\n有序参数的变化量为 $\\Delta Q_l = Q'_l - 1 \\approx -\\alpha(1 - P_l(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{s}}))$。这是对扰动的一阶响应。\n\n现在我们比较不同的加权方案：\n1.  **均匀加权：** 对所有近邻，$w_j = 1$。初始的 $N_b$ 个近邻有 $W_0 = N_b$。伪近邻的权重为 $w_s=1$。新的总权重为 $W_{\\text{new}} = N_b+1$。扰动振幅为 $\\alpha = w_s / W_{\\text{new}} = 1/(N_b+1)$。$Q_l$ 的变化量标度关系为 $\\Delta Q_l \\propto 1/N_b$。在此方案中，稳健性完全由近邻数决定；更大的配位数 $N_b$ 会使该度量更稳定。其缺点是，一个伪近邻，无论其距离多远（只要它被包含在近邻列表中），其影响都与一个真实近邻相同。\n\n2.  **反比距离加权：** 对 $p0$，$w_j = |\\mathbf{r}_j|^{-p}$。假设 $N_b$ 个初始近邻位于典型距离 $R$ 处，则 $W_0 \\approx N_b R^{-p}$。伪近邻位于距离 $r_s$ 处，因此 $w_s = r_s^{-p}$。扰动振幅为：\n$$\\alpha = \\frac{w_s}{W_0+w_s} \\approx \\frac{r_s^{-p}}{N_b R^{-p} + r_s^{-p}} = \\frac{(R/r_s)^p}{N_b + (R/r_s)^p}$$\n   - 如果伪近邻距离很远 ($r_s \\gg R$)，则 $(R/r_s)^p \\to 0$，且 $\\alpha \\approx (R/r_s)^p/N_b$。扰动被一个因子 $(r_s)^{-p}$ 严重抑制。这种加权方案提供了一个自然的“软截断”，使得有序参数对于将远处粒子错误地包含在近邻列表中的情况具有稳健性。\n   - 如果伪近邻距离非常近 ($r_s \\ll R$)，那么 $(R/r_s)^p$ 可能会很大。如果 $(R/r_s)^p \\gg N_b$，则 $\\alpha \\to 1$。在这种情况下，单个非常近的近邻将主导整个计算，导致 $Q_l$ 值急剧下降。这表明该方法对非物理的近距离粒子很敏感，而这种情况在模拟中可能瞬时发生。\n\n总之，与更简单的均匀加权方案相比，反比距离加权提高了对远处伪近邻的稳健性，但代价是增加了对极近邻居异常值的敏感性。两者之间的选择取决于粒子构型和近邻搜索算法中预期的噪声和误差的性质。",
            "answer": "$$\n\\boxed{ \\sqrt{\\frac{4\\pi}{2l+1}} \\frac{\\left(\\sum_{m=-l}^{l} \\left| \\sum_{j=1}^{N_b} w_j Y_{l m}(\\hat{\\mathbf{r}}_j) \\right|^2\\right)^{1/2}}{\\sum_{j=1}^{N_b} w_j} }\n$$"
        },
        {
            "introduction": "序参量不仅能表征静态结构，更是连接微观动力学和宏观相变动力学的桥梁。本项高级实践将引导您进入马尔可夫状态模型（MSM）的世界，这是一种强大的工具，可利用序参量的时间序列来揭示结构转变的动力学机制和时间尺度。您将通过一个合成数据案例，学习如何通过将序参量离散化来构建一个简单的MSM，并使用查普曼-科尔莫戈罗夫检验来验证模型的马尔可夫性，这是构建可靠动力学模型的关键一步。",
            "id": "3430948",
            "problem": "给定一个一维结构序参量 $q(t)$，它是从合成的分子动力学中以均匀时间间隔 $\\Delta t$ 采样的。目标是通过将 $q(t)$ 分箱到离散状态来构建一个马尔可夫状态模型（MSM），并检验结构转变动力学的 Chapman–Kolmogorov 属性。请将您的方法建立在离散时间马尔可夫链、转移概率矩阵和 Chapman–Kolmogorov 方程的基本定义之上。使用以下原则：马尔可夫过程具有未来演化仅取决于当前状态的属性；如果 $X_t$ 是一个具有单步转移矩阵 $T(\\Delta t)$ 的平稳马尔可夫链，那么对于任何整数 $k \\geq 1$，其 $k$ 步转移矩阵满足 $T(k \\Delta t) = T(\\Delta t)^k$。MSM 的构建方法是：将连续的序参量 $q(t)$ 离散化为 $M$ 个分箱，并估计在选定的延迟时间 $\\tau = \\ell \\Delta t$ 下分箱之间的转移概率。\n\n按如下方式构建 MSM：\n- 将时间序列 $q(t)$ 按指定的分箱边界离散化为 $M$ 个分箱，产生一个离散序列 $b_t \\in \\{0,1,\\dots,M-1\\}$。\n- 对于给定的延迟步长 $\\ell \\in \\mathbb{N}$（因此延迟时间为 $\\tau = \\ell \\Delta t$），估计计数矩阵 $C(\\tau)$，其元素 $C_{ij}(\\tau)$ 等于在离散序列中观察到的转移 $b_t = i \\rightarrow b_{t+\\ell} = j$ 的次数，对所有有效的索引对求和。\n- 使用 $\\alpha = 1$ 的拉普拉斯平滑来获取转移概率矩阵 $T(\\tau)$：对每一行 $i$，计算\n$$\nT_{ij}(\\tau) = \\frac{C_{ij}(\\tau) + \\alpha}{\\sum_{k=0}^{M-1} \\left(C_{ik}(\\tau) + \\alpha\\right)}.\n$$\n- 为检验 Chapman–Kolmogorov 属性，计算偏差\n$$\n\\delta(\\ell,k) = \\max_{i,j} \\left| T_{ij}(k \\tau) - \\left[T(\\tau)^k\\right]_{ij} \\right|,\n$$\n其中 $k \\in \\mathbb{N}$ 是一个乘数，$T(\\tau)^k$ 是第 $k$ 次矩阵幂。如果对于指定的阈值 $\\varepsilon  0$，有 $\\delta(\\ell,k) \\leq \\varepsilon$，则声明该属性“成立”。\n\n假设采样间隔为 $\\Delta t = 1$ 皮秒 (ps)。所有延迟时间都应以皮秒为单位处理。不涉及角度量。此任务中没有百分比。\n\n实现一个程序，生成合成数据 $q(t)$ 并针对以下三个测试案例评估 $\\delta(\\ell,k)$。为保证可复现性，请使用提供的种子进行确定性的伪随机初始化。在每个案例中，确保状态到 $q$ 的映射使 $q(t)$ 保持在给定的分箱范围内，并且分箱操作是通过将 $q(t)$ 分配到包含它的唯一分箱区间来执行的。\n\n测试案例1（构建良好的 MSM；预期满足 Chapman–Kolmogorov）：\n- 在 $S_t \\in \\{0,1\\}$ 上的隐马尔可夫链，转移矩阵为\n$$\nT^{(1)} = \\begin{pmatrix}\n0.999  0.001 \\\\\n0.001  0.999\n\\end{pmatrix}.\n$$\n- 长度 $N^{(1)} = 200{,}000$ 步。\n- 初始化种子 $s_1 = 123$。\n- 状态到序参量的映射：$q(t) = \\mu_{S_t}$，其中 $\\mu_0 = -1.0$ 和 $\\mu_1 = +1.0$（无观测噪声）。\n- 分箱数 $M^{(1)} = 2$，边界为 $\\{-2.0, 0.0, 2.0\\}$，得到分箱 $[-2.0,0.0)$ 和 $[0.0,2.0]$。\n- 延迟步长 $\\ell^{(1)} = 1$，因此 $\\tau^{(1)} = 1$ ps。\n- 乘数 $k^{(1)} = 5$。\n- 阈值 $\\varepsilon^{(1)} = 0.01$。\n\n测试案例2（不可集总的粗粒化；预期违反 Chapman–Kolmogorov）：\n- 在 $S_t \\in \\{0,1,2\\}$ 上的隐马尔可夫链，转移矩阵为\n$$\nT^{(2)} = \\begin{pmatrix}\n0.90  0.10  0.00 \\\\\n0.05  0.90  0.05 \\\\\n0.10  0.00  0.90\n\\end{pmatrix}.\n$$\n- 长度 $N^{(2)} = 300{,}000$ 步。\n- 初始化种子 $s_2 = 456$。\n- 状态到序参量的映射：$q(t) = \\mu_{S_t}$，其中 $\\mu_0 = -1.0$，$\\mu_1 = -0.2$，$\\mu_2 = +1.0$（无观测噪声）。\n- 粗粒化分箱，集总了状态：$M^{(2)} = 2$，边界为 $\\{-2.0, 0.0, 2.0\\}$，因此 $\\{S_t=0,1\\} \\mapsto$ 分箱 $0$，$\\{S_t=2\\} \\mapsto$ 分箱 $1$。\n- 延迟步长 $\\ell^{(2)} = 1$，因此 $\\tau^{(2)} = 1$ ps。\n- 乘数 $k^{(2)} = 5$。\n- 阈值 $\\varepsilon^{(2)} = 0.05$。\n\n测试案例3（边界条件；单分箱平凡划分；预期满足 Chapman–Kolmogorov）：\n- 在 $S_t \\in \\{0,1\\}$ 上的隐马尔可夫链，转移矩阵为\n$$\nT^{(3)} = \\begin{pmatrix}\n0.95  0.05 \\\\\n0.10  0.90\n\\end{pmatrix}.\n$$\n- 长度 $N^{(3)} = 50{,}000$ 步。\n- 初始化种子 $s_3 = 789$。\n- 状态到序参量的映射：$q(t) = \\mu_{S_t}$，其中 $\\mu_0 = -0.5$ 和 $\\mu_1 = +0.5$（无观测噪声）。\n- 单个分箱：$M^{(3)} = 1$，边界为 $\\{-2.0, 2.0\\}$，因此所有样本都属于这唯一的分箱。\n- 延迟步长 $\\ell^{(3)} = 10$，因此 $\\tau^{(3)} = 10$ ps。\n- 乘数 $k^{(3)} = 3$。\n- 阈值 $\\varepsilon^{(3)} = 10^{-12}$。\n\n您的程序必须：\n1. 使用给定的转移矩阵 $T^{(i)}$ 和种子 $s_i$ 模拟每个长度为 $N^{(i)}$ 的隐马尔可夫链（从状态 $0$ 开始；较大的 $N^{(i)}$ 确保瞬态效应可以忽略不计）。\n2. 在每个案例中，通过提供的映射转换为 $q(t)$，并使用给定的边界离散化到分箱中。\n3. 使用 $\\alpha = 1$ 的拉普拉斯平滑估计器构建 $T(\\tau)$ 和 $T(k \\tau)$。\n4. 为每个案例计算 $\\delta(\\ell,k)$ 并与 $\\varepsilon^{(i)}$ 比较，以产生一个布尔结果：如果 $\\delta(\\ell,k) \\leq \\varepsilon^{(i)}$ 则为 $\\text{True}$，否则为 $\\text{False}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个布尔结果，形式为方括号括起来的逗号分隔列表（例如，“[True,False,True]”）。不得打印任何其他文本。所有延迟时间和采样间隔都以皮秒 (ps) 为单位，但程序输出的是布尔值，而非物理量。",
            "solution": "该问题要求从一个合成的一维序参量时间序列 $q(t)$ 构建并验证一个马尔可夫状态模型（MSM）。验证是通过检验 Chapman-Kolmogorov（CK）属性来执行的。整个过程针对三个不同的测试案例执行，旨在探讨 MSM 理论的不同方面。\n\n对于每个测试案例，求解方法遵循以下步骤序列：\n1.  基于一个底层的（或“隐藏的”）离散时间马尔可夫链生成合成数据集。\n2.  通过离散化（分箱）序参量时间序列来构建 MSM。\n3.  评估所构建 MSM 的 Chapman-Kolmogorov 属性。\n\n**1. 合成数据生成**\n首先，模拟一个离散时间、离散状态的隐马尔可夫链（HMC），以表示系统的真实底层动力学。生成一个状态轨迹 $S_t \\in \\{0, 1, \\dots\\}$，总共 $N$ 步。该链的演化由给定的转移概率矩阵 $T^{(\\text{hidden})}$ 控制，其中 $T_{ij}^{(\\text{hidden})}$ 是在单个时间步长 $\\Delta t$ 内从状态 $i$ 转移到状态 $j$ 的概率。根据定义，这个底层过程是马尔可夫的。为了保证可复现性，模拟从状态 $S_0=0$ 开始，并使用一个以特定种子初始化的伪随机数生成器。\n\n然后，使用确定性映射 $q(t) = \\mu_{S_t}$ 将离散状态轨迹 $\\{S_t\\}$ 转换为连续的序参量时间序列 $\\{q(t)\\}$，其中每个隐藏状态 $S_t$ 被赋予一个特定值 $\\mu_{S_t}$。采样间隔给定为 $\\Delta t = 1$ ps。\n\n**2. 马尔可夫状态模型构建**\n构建 MSM 的核心是将连续的状态空间（由 $q(t)$ 表示）粗粒化为有限数量的离散状态的过程。\n\n- **离散化**：时间序列 $q(t)$ 被划分为由一组分箱边界定义的 $M$ 个分箱。每个值 $q(t)$ 被分配一个唯一的分箱索引 $b_t \\in \\{0, 1, \\dots, M-1\\}$，从而产生一个离散轨迹 $\\{b_t\\}$。\n\n- **转移计数**：对于选定的延迟时间 $\\tau = \\ell \\Delta t$（其中 $\\ell$ 是一个整数延迟步长），我们计算在一对分箱 $(i, j)$ 之间观察到的转移次数。结果是一个大小为 $M \\times M$ 的计数矩阵 $C(\\tau)$，其中元素 $C_{ij}(\\tau)$ 是在延迟时间 $\\tau$ 内观察到从分箱 $i$ 转移到分箱 $j$ 的总次数。即 $C_{ij}(\\tau) = \\sum_{t} \\mathbb{I}(b_t=i, b_{t+\\ell}=j)$，其中 $\\mathbb{I}$ 是指示函数。\n\n- **转移概率估计**：计数矩阵被转换为一个行随机的转移概率矩阵 $T(\\tau)$。为了处理有限数据并避免未观察到的转移出现零概率，我们采用拉普拉斯平滑，伪计数 $\\alpha=1$。转移矩阵的元素估计如下：\n$$\nT_{ij}(\\tau) = \\frac{C_{ij}(\\tau) + \\alpha}{\\sum_{k=0}^{M-1} \\left(C_{ik}(\\tau) + \\alpha\\right)}\n$$\n该公式确保每一行 $\\sum_{j=0}^{M-1} T_{ij}(\\tau) = 1$。\n\n**3. Chapman-Kolmogorov 检验**\n任何平稳马尔可夫过程的一个基本属性是，其在时间 $k\\tau$ 内的演化可以从其在时间 $\\tau$ 内的演化推导出来。具体来说，离散时间马尔可夫链的 Chapman-Kolmogorov 方程指出，$k$ 步转移矩阵等于单步转移矩阵的 $k$ 次幂。对于我们的 MSM，这意味着以下关系：\n$$\nT(k\\tau) = [T(\\tau)]^k\n$$\n只有当离散化过程 $\\{b_t\\}$ 在延迟时间 $\\tau$ 下是真正的马尔可夫过程时，此属性才成立。检验通过比较该方程的两边来进行。\n\n- **等式左边 (LHS)**：矩阵 $T(k\\tau)$ 是直接从数据计算的。我们使用 $k\\tau = (k\\ell)\\Delta t$ 的延迟时间构建一个计数矩阵 $C(k\\tau)$，然后应用相同的拉普拉斯平滑估计来获得 $T(k\\tau)$。\n\n- **等式右边 (RHS)**：矩阵 $[T(\\tau)]^k$ 是通过将先前估计的矩阵 $T(\\tau)$（在较短的延迟时间下）用标准矩阵乘法提升到整数次幂 $k$ 来计算的。\n\n- **偏差度量**：两个矩阵之间的差异通过它们所有元素的最大绝对差来量化：\n$$\n\\delta(\\ell,k) = \\max_{i,j} \\left| [T(k\\tau)]_{ij} - \\left[T(\\tau)^k\\right]_{ij} \\right|\n$$\n一个小的 $\\delta(\\ell,k)$ 值表明 MSM 是系统动力学的一个良好马尔可夫近似。如果该偏差低于指定的容差阈值，即 $\\delta(\\ell,k) \\leq \\varepsilon$，则声明该属性成立。\n\n**实现**\n该过程使用 `numpy` 库在 Python 中实现。HMC 模拟使用 `numpy.random.default_rng` 进行带种子的随机数生成。离散化使用 `numpy.digitize` 执行。计数矩阵通过对转移对的计数进行向量化来高效构建。转移矩阵使用数组算术计算，而矩阵幂 $[T(\\tau)]^k$ 则用 `numpy.linalg.matrix_power` 计算。该逻辑按规定应用于三个测试案例中的每一个，并记录每个案例中比较 $\\delta(\\ell,k) \\leq \\varepsilon$ 的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_hmc_trace(T_hidden, N, seed):\n    \"\"\"Generates a state trajectory from a hidden Markov chain.\"\"\"\n    rng = np.random.default_rng(seed)\n    num_states = T_hidden.shape[0]\n    states = np.empty(N, dtype=int)\n    states[0] = 0  # Start from state 0 as specified.\n    for t in range(N - 1):\n        current_state = states[t]\n        probabilities = T_hidden[current_state]\n        next_state = rng.choice(num_states, p=probabilities)\n        states[t + 1] = next_state\n    return states\n\ndef build_count_matrix(binned_seq, lag, M):\n    \"\"\"Builds a transition count matrix from a binned sequence.\"\"\"\n    C = np.zeros((M, M), dtype=np.int64)\n    if M == 0:\n        return C\n    n_points = len(binned_seq)\n    if lag >= n_points:\n        return C\n    \n    # Get the indices of the start and end states for each transition\n    i_indices = binned_seq[:-lag]\n    j_indices = binned_seq[lag:]\n    \n    # Use np.add.at for efficient counting of transitions\n    np.add.at(C, (i_indices, j_indices), 1)\n    \n    return C\n\ndef counts_to_T(C, alpha):\n    \"\"\"Converts a count matrix to a transition probability matrix with Laplace smoothing.\"\"\"\n    M = C.shape[0]\n    if M == 0:\n        return np.array([[]])\n        \n    C_smoothed = C + alpha\n    row_sums = C_smoothed.sum(axis=1, keepdims=True)\n    \n    # Avoid division by zero for rows that were never visited, though Laplace\n    # smoothing with alpha > 0 prevents this unless M=0.\n    # The sum will be M*alpha for an unvisited row.\n    if np.any(row_sums == 0):\n        # This case should not be reached with alpha > 0 and M > 0.\n        # If it happens, assign uniform probability to avoid NaN.\n        T = np.zeros_like(C_smoothed, dtype=float)\n        non_zero_rows = row_sums.flatten() > 0\n        T[non_zero_rows] = C_smoothed[non_zero_rows] / row_sums[non_zero_rows]\n        \n        # Handle zero-sum rows by assigning uniform probability\n        zero_rows = ~non_zero_rows\n        if np.any(zero_rows) and M > 0:\n            T[zero_rows] = 1.0 / M\n    else:\n        T = C_smoothed / row_sums\n        \n    return T\n\ndef run_test_case(T_hidden, N, seed, state_map, bin_edges, l, k, epsilon, alpha=1):\n    \"\"\"Runs a single test case for Chapman-Kolmogorov validation.\"\"\"\n    \n    # 1. Simulate hidden Markov chain and generate q(t)\n    states = generate_hmc_trace(T_hidden, N, seed)\n    q_t = np.array([state_map[s] for s in states])\n    \n    # 2. Discretize q(t) into bins\n    # np.digitize returns 1-based indices, so subtract 1 for 0-based binning.\n    # Bins are [edge_i, edge_{i+1})\n    binned_seq = np.digitize(q_t, bin_edges) - 1\n    M = len(bin_edges) - 1\n\n    # Define lag times in steps\n    tau = l\n    k_tau = k * l\n\n    # 3. Construct T(tau)\n    C_tau = build_count_matrix(binned_seq, tau, M)\n    T_tau = counts_to_T(C_tau, alpha)\n\n    # 4. Construct T(k*tau) directly\n    C_k_tau = build_count_matrix(binned_seq, k_tau, M)\n    T_k_tau_estimated = counts_to_T(C_k_tau, alpha)\n\n    # 5. Compute T(tau)^k\n    if M > 0:\n        T_tau_k_predicted = np.linalg.matrix_power(T_tau, k)\n    else: # Handle M=0 case\n        T_tau_k_predicted = np.array([[]])\n\n    # 6. Compute deviation and compare with threshold\n    delta = np.max(np.abs(T_k_tau_estimated - T_tau_k_predicted)) if M > 0 else 0.0\n    \n    return delta = epsilon\n\ndef solve():\n    \"\"\"\n    Main function to define and run the test cases, and print the results.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: Well-constructed MSM\n        {\n            \"T_hidden\": np.array([[0.999, 0.001], [0.001, 0.999]]),\n            \"N\": 200000,\n            \"seed\": 123,\n            \"state_map\": [-1.0, 1.0],\n            \"bin_edges\": [-2.0, 0.0, 2.0],\n            \"l\": 1,\n            \"k\": 5,\n            \"epsilon\": 0.01\n        },\n        # Test Case 2: Non-lumpable coarse-graining\n        {\n            \"T_hidden\": np.array([[0.90, 0.10, 0.00], [0.05, 0.90, 0.05], [0.10, 0.00, 0.90]]),\n            \"N\": 300000,\n            \"seed\": 456,\n            \"state_map\": [-1.0, -0.2, 1.0],\n            \"bin_edges\": [-2.0, 0.0, 2.0],\n            \"l\": 1,\n            \"k\": 5,\n            \"epsilon\": 0.05\n        },\n        # Test Case 3: Boundary condition (single bin)\n        {\n            \"T_hidden\": np.array([[0.95, 0.05], [0.10, 0.90]]),\n            \"N\": 50000,\n            \"seed\": 789,\n            \"state_map\": [-0.5, 0.5],\n            \"bin_edges\": [-2.0, 2.0],\n            \"l\": 10,\n            \"k\": 3,\n            \"epsilon\": 1e-12\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_test_case(**case_params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}