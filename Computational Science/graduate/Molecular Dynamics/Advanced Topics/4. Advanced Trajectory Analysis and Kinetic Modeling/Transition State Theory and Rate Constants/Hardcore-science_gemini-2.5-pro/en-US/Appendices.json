{
    "hands_on_practices": [
        {
            "introduction": "A central goal of computational chemistry is to predict reaction rates directly from molecular principles. This exercise guides you through the process of calculating a TST rate constant by combining two common outputs from molecular dynamics simulations: a Potential of Mean Force (PMF), which describes the equilibrium landscape, and constrained velocity data, which captures the dynamics at the barrier top. This practice solidifies the flux-over-a-barrier picture of chemical reactions and allows for direct validation against unbiased simulation results. ",
            "id": "3458168",
            "problem": "You are asked to design a complete, runnable program that computes a transition state theory rate constant and validates it against an unbiased molecular dynamics measurement using data that emulates umbrella-sampling and constrained-velocity statistics. The derivation must start from fundamental principles of statistical mechanics and dynamics appropriate for molecular dynamics and transition state theory, and the algorithm must implement the derived expression without shortcut formulas provided in the statement. The program must implement the following steps for each test case: infer a barrier height from a one-dimensional potential of mean force, compute a constrained average of the absolute velocity at the dividing surface, and use equilibrium statistical mechanics to obtain a rate constant which is then compared to an observed rate from unbiased dynamics data. The objective is to test reasoning from first principles by deriving why a flux-based estimate relates the constrained velocity statistics and the equilibrium barrier height to a rate constant.\n\nDefine the reaction coordinate as a single, dimensionless coordinate $s$ with a discrete grid $s_i$ and a potential of mean force $F(s_i)$ in kilojoules per mole. The dividing surface is located at the barrier top along $s$. The temperature $T$ is specified in kelvin. The constrained-velocity statistics at the dividing surface is provided as samples of $\\dot{s}$ in inverse seconds collected while maintaining $s$ at the dividing surface. The unbiased molecular dynamics rate is inferred from an integer transition count over a total simulation time in seconds. All quantities are to be treated in a scientifically self-consistent manner.\n\nUse the universal gas constant $R$ in kilojoules per mole per kelvin, specifically $R = 8.314462618 \\times 10^{-3}$, so that the inverse thermal energy is $\\beta = 1 / (R T)$ when $F$ is a molar free energy in kilojoules per mole. The rate constant must be expressed in inverse seconds.\n\nYour program must implement the following steps for each test case:\n- Identify the dividing surface location $s^\\ddagger$ as the grid point with the maximum $F(s)$ over the provided grid.\n- Identify the reactant basin reference location $s_{\\mathrm{R}}$ as the grid point with the minimum $F(s)$ among those with $s \\leq s_{\\mathrm{cut}}$, where $s_{\\mathrm{cut}}$ is a supplied threshold that isolates the reactant side.\n- Compute the barrier height $\\Delta F^\\ddagger = F(s^\\ddagger) - F(s_{\\mathrm{R}})$ in kilojoules per mole.\n- Compute the constrained average of the absolute velocity at the dividing surface $\\langle |\\dot{s}| \\rangle^\\ddagger$ as the arithmetic mean of the absolute values of the provided $\\dot{s}$ samples in inverse seconds:\n$$\n\\langle |\\dot{s}| \\rangle^\\ddagger = \\frac{1}{N} \\sum_{j=1}^{N} \\left| \\dot{s}_j \\right| .\n$$\n- Using equilibrium statistical mechanics and the flux interpretation of the rate across the dividing surface, derive the transition state theory estimate for the rate constant in inverse seconds. Implement the resulting expression in your program using only the above computed quantities and fundamental constants, with $F$ treated as a molar free energy and $\\beta = 1 / (R T)$.\n- Compute the unbiased molecular dynamics rate $k_{\\mathrm{MD}}$ in inverse seconds as the observed integer transition count divided by the total simulation time in seconds.\n- Validate the transition state theory result against the unbiased molecular dynamics result by checking whether the absolute relative difference is at most a specified tolerance $\\varepsilon$ expressed as a decimal:\n$$\n\\left| \\frac{k_{\\mathrm{TST}} - k_{\\mathrm{MD}}}{k_{\\mathrm{MD}}} \\right| \\leq \\varepsilon .\n$$\n\nUnits and output requirements:\n- All rate constants must be in inverse seconds.\n- All energies must be in kilojoules per mole.\n- All velocities $\\dot{s}$ must be in inverse seconds.\n- All times must be in seconds.\n- Angles do not appear in this problem.\n- The validation tolerance is provided as a decimal.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of three elements in the order $[k_{\\mathrm{TST}}, k_{\\mathrm{MD}}, \\text{pass}]$. For example, the output must have the shape $[[x_1,y_1,b_1],[x_2,y_2,b_2],[x_3,y_3,b_3]]$ with $x_i$ and $y_i$ floats and $b_i$ booleans.\n\nTest suite specification:\n- Use $R = 8.314462618 \\times 10^{-3}$ in kilojoules per mole per kelvin.\n- Tolerance $\\varepsilon = 0.1$.\n\nTest case $1$ (happy path, moderate barrier):\n- Temperature $T = 300$ kelvin.\n- Reactant-side cutoff $s_{\\mathrm{cut}} = -0.5$.\n- Grid $s$ values:\n$[-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0]$.\n- Potential of mean force $F(s)$ in kilojoules per mole:\n$[2.0, 1.0, 0.0, 1.5, 6.0, 10.0, 6.0, 1.5, 0.5, 0.8, 1.8]$.\n- Constrained velocity samples at the dividing surface in inverse seconds:\n$[-8.0 \\times 10^{11}, 1.2 \\times 10^{12}, -5.5 \\times 10^{11}, 6.0 \\times 10^{11}, -1.0 \\times 10^{11}, 9.0 \\times 10^{11}, -1.1 \\times 10^{12}, 7.0 \\times 10^{11}, 3.0 \\times 10^{11}, -4.0 \\times 10^{11}]$.\n- Unbiased molecular dynamics observed transition count $= 3463$, total simulation time $= 5.0 \\times 10^{-7}$ seconds.\n\nTest case $2$ (boundary case, nearly barrierless):\n- Temperature $T = 300$ kelvin.\n- Reactant-side cutoff $s_{\\mathrm{cut}} = -0.5$.\n- Grid $s$ values:\n$[-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0]$.\n- Potential of mean force $F(s)$ in kilojoules per mole:\n$[0.2, 0.1, 0.0, 0.1, 0.3, 0.5, 0.3, 0.1, 0.05, 0.08, 0.15]$.\n- Constrained velocity samples at the dividing surface in inverse seconds:\n$[-4.0 \\times 10^{11}, 6.0 \\times 10^{11}, -3.0 \\times 10^{11}, 5.5 \\times 10^{11}, -2.0 \\times 10^{11}, 5.0 \\times 10^{11}, -4.5 \\times 10^{11}, 4.0 \\times 10^{11}, 3.5 \\times 10^{11}, -3.2 \\times 10^{11}]$.\n- Unbiased molecular dynamics observed transition count $= 1665$, total simulation time $= 1.0 \\times 10^{-8}$ seconds.\n\nTest case $3$ (edge case, large barrier):\n- Temperature $T = 300$ kelvin.\n- Reactant-side cutoff $s_{\\mathrm{cut}} = -0.5$.\n- Grid $s$ values:\n$[-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0]$.\n- Potential of mean force $F(s)$ in kilojoules per mole:\n$[4.0, 2.5, 0.0, 5.0, 15.0, 25.0, 15.0, 6.0, 3.0, 2.0, 3.5]$.\n- Constrained velocity samples at the dividing surface in inverse seconds:\n$[-9.0 \\times 10^{11}, 1.0 \\times 10^{12}, -7.5 \\times 10^{11}, 8.0 \\times 10^{11}, -6.0 \\times 10^{11}, 9.0 \\times 10^{11}, -1.1 \\times 10^{12}, 7.0 \\times 10^{11}, 5.0 \\times 10^{11}, -8.0 \\times 10^{11}]$.\n- Unbiased molecular dynamics observed transition count $= 179$, total simulation time $= 1.0 \\times 10^{-5}$ seconds.\n\nYour program should produce a single line of output containing a list of results for the three test cases in the exact format:\n$[[k_{\\mathrm{TST}}^{(1)}, k_{\\mathrm{MD}}^{(1)}, \\text{pass}^{(1)}],[k_{\\mathrm{TST}}^{(2)}, k_{\\mathrm{MD}}^{(2)}, \\text{pass}^{(2)}],[k_{\\mathrm{TST}}^{(3)}, k_{\\mathrm{MD}}^{(3)}, \\text{pass}^{(3)}]]$,\nwhere each $k$ is a float in inverse seconds and each $\\text{pass}$ is a boolean.",
            "solution": "The problem requires the derivation and implementation of a formula for the transition state theory (TST) rate constant, $k_{\\mathrm{TST}}$, using provided data from molecular simulations, and its validation against a direct molecular dynamics (MD) rate, $k_{\\mathrm{MD}}$. The derivation must be grounded in fundamental principles of statistical mechanics and dynamics.\n\nThe TST rate constant for a reaction describes the rate of population flow from a reactant state to a product state. In its common formulation, it is expressed as the product of an equilibrium constant for the formation of the transition state from reactants, $K^\\ddagger$, and a frequency factor, $\\nu$, that characterizes the rate of passage over the transition state barrier.\n$$\nk_{\\mathrm{TST}} = \\nu K^\\ddagger\n$$\nThis expression partitions the problem into an equilibrium component (statistical mechanics) and a dynamical component (kinetics).\n\nFirst, we address the equilibrium constant, $K^\\ddagger$. In statistical mechanics, for a reaction $R \\rightleftharpoons TS$ where $TS$ represents the transition state, the equilibrium constant is related to the change in the standard Gibbs free energy, $\\Delta G^\\ddagger$, or, in this context, the potential of mean force (PMF), $\\Delta F^\\ddagger$. The PMF, $F(s)$, represents the free energy of the system as a function of the reaction coordinate $s$. The equilibrium constant is given by:\n$$\nK^\\ddagger = \\frac{[TS]}{[R]} = e^{-\\Delta F^\\ddagger / (RT)} = e^{-\\beta \\Delta F^\\ddagger}\n$$\nHere, $[TS]$ and $[R]$ are the populations or partition functions of the transition state and reactant state, respectively. The term $\\Delta F^\\ddagger$ is the free energy barrier, calculated as the difference between the PMF at the transition state (the dividing surface, $s^\\ddagger$) and the PMF at the reactant state minimum ($s_R$). The problem provides the means to compute this directly.\n$$\n\\Delta F^\\ddagger = F(s^\\ddagger) - F(s_R)\n$$\nThe value $s^\\ddagger$ is the location of the maximum of $F(s)$, and $s_R$ is the location of the minimum of $F(s)$ in the reactant basin. The inverse thermal energy is $\\beta = 1/(RT)$, where $R$ is the molar gas constant, consistent with $F(s)$ being a molar free energy in $\\text{kJ/mol}$.\n\nNext, we must determine the frequency factor, $\\nu$, representing the rate of crossing the dividing surface for a system that has reached the transition state. The problem provides constrained-velocity samples, $\\dot{s}_j$, at the dividing surface $s^\\ddagger$. The reaction coordinate $s$ is dimensionless, so its time derivative, $\\dot{s}$, has units of inverse time ($s^{-1}$), which is a frequency. The one-way flux from reactants to products depends on the average velocity of systems moving in the forward direction ($\\dot{s}  0$). This average forward velocity is denoted $\\langle \\dot{s} \\rangle_{\\dot{s}0}^\\ddagger$. This quantity can be interpreted as the characteristic frequency for a system at the transition state to successfully cross into the product basin. Therefore, we identify $\\nu = \\langle \\dot{s} \\rangle_{\\dot{s}0}^\\ddagger$.\n\nThe problem supplies samples of $\\dot{s}$ at $s^\\ddagger$ from which we can compute the constrained average of the absolute velocity, $\\langle |\\dot{s}| \\rangle^\\ddagger$. At the transition state, which is a point of unstable equilibrium, we assume there is no net flux, meaning the velocity distribution is symmetric around $\\dot{s}=0$. Consequently, the average forward velocity is half of the average speed:\n$$\n\\langle \\dot{s} \\rangle_{\\dot{s}0}^\\ddagger = \\frac{1}{2} \\langle |\\dot{s}| \\rangle^\\ddagger\n$$\nwhere $\\langle |\\dot{s}| \\rangle^\\ddagger$ is computed as the arithmetic mean of the absolute values of the velocity samples:\n$$\n\\langle |\\dot{s}| \\rangle^\\ddagger = \\frac{1}{N} \\sum_{j=1}^{N} \\left| \\dot{s}_j \\right|\n$$\n\nBy combining these components, we arrive at the final expression for the TST rate constant, which connects the provided equilibrium and dynamical quantities as requested:\n$$\nk_{\\mathrm{TST}} = \\nu K^\\ddagger = \\left( \\frac{1}{2} \\langle |\\dot{s}| \\rangle^\\ddagger \\right) e^{-\\beta \\Delta F^\\ddagger}\n$$\nThis formula is dimensionally consistent, with $k_{\\mathrm{TST}}$ having units of $s^{-1}$, and it utilizes exclusively the quantities derived from the problem's input data: the barrier height $\\Delta F^\\ddagger$ and the average absolute velocity at the dividing surface $\\langle |\\dot{s}| \\rangle^\\ddagger$.\n\nThe algorithm implemented in the program proceeds as follows for each test case:\n1.  The value of $\\beta = 1/(RT)$ is computed using the given temperature $T$ and gas constant $R$.\n2.  The potential of mean force grid $F(s)$ is scanned to find its maximum value. The corresponding coordinate and energy are identified as $s^\\ddagger$ and $F(s^\\ddagger)$.\n3.  The reactant portion of the grid ($s \\leq s_{\\mathrm{cut}}$) is scanned to find the minimum value of $F(s)$. This defines the reactant reference state with coordinate $s_R$ and energy $F(s_R)$.\n4.  The free energy barrier is calculated as $\\Delta F^\\ddagger = F(s^\\ddagger) - F(s_R)$.\n5.  The constrained average absolute velocity, $\\langle |\\dot{s}| \\rangle^\\ddagger$, is computed from the provided velocity samples.\n6.  The TST rate constant, $k_{\\mathrm{TST}}$, is calculated using the derived formula: $k_{\\mathrm{TST}} = \\frac{1}{2} \\langle |\\dot{s}| \\rangle^\\ddagger e^{-\\beta \\Delta F^\\ddagger}$.\n7.  The unbiased molecular dynamics rate, $k_{\\mathrm{MD}}$, is calculated as the total number of observed transitions divided by the total simulation time.\n8.  Finally, the TST rate is validated against the MD rate by checking if the absolute relative difference is within the tolerance $\\varepsilon=0.1$: $|\\frac{k_{\\mathrm{TST}} - k_{\\mathrm{MD}}}{k_{\\mathrm{MD}}}| \\leq \\varepsilon$.\nThe results, comprising $k_{\\mathrm{TST}}$, $k_{\\mathrm{MD}}$, and a boolean indicating the validation outcome, are collected for all test cases and formatted into the required output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and validates TST rate constants against MD measurements.\n    \"\"\"\n    # Universal gas constant in kJ/(mol·K)\n    R = 8.314462618e-3\n    # Validation tolerance\n    TOLERANCE = 0.1\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"T\": 300,  # Kelvin\n            \"s_cut\": -0.5,\n            \"s_grid\": [-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0],\n            \"F_s\": [2.0, 1.0, 0.0, 1.5, 6.0, 10.0, 6.0, 1.5, 0.5, 0.8, 1.8],  # kJ/mol\n            \"s_dot_samples\": [-8.0e11, 1.2e12, -5.5e11, 6.0e11, -1.0e11, 9.0e11, -1.1e12, 7.0e11, 3.0e11, -4.0e11],  # s^-1\n            \"md_transitions\": 3463,\n            \"md_time\": 5.0e-7  # seconds\n        },\n        {\n            \"T\": 300,\n            \"s_cut\": -0.5,\n            \"s_grid\": [-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0],\n            \"F_s\": [0.2, 0.1, 0.0, 0.1, 0.3, 0.5, 0.3, 0.1, 0.05, 0.08, 0.15],\n            \"s_dot_samples\": [-4.0e11, 6.0e11, -3.0e11, 5.5e11, -2.0e11, 5.0e11, -4.5e11, 4.0e11, 3.5e11, -3.2e11],\n            \"md_transitions\": 1665,\n            \"md_time\": 1.0e-8\n        },\n        {\n            \"T\": 300,\n            \"s_cut\": -0.5,\n            \"s_grid\": [-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0],\n            \"F_s\": [4.0, 2.5, 0.0, 5.0, 15.0, 25.0, 15.0, 6.0, 3.0, 2.0, 3.5],\n            \"s_dot_samples\": [-9.0e11, 1.0e12, -7.5e11, 8.0e11, -6.0e11, 9.0e11, -1.1e12, 7.0e11, 5.0e11, -8.0e11],\n            \"md_transitions\": 179,\n            \"md_time\": 1.0e-5\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract data for the current case\n        T = case[\"T\"]\n        s_cut = case[\"s_cut\"]\n        s_grid = np.array(case[\"s_grid\"])\n        F_s = np.array(case[\"F_s\"])\n        s_dot_samples = np.array(case[\"s_dot_samples\"])\n        md_transitions = case[\"md_transitions\"]\n        md_time = case[\"md_time\"]\n\n        # Step 1: Compute inverse thermal energy\n        beta = 1.0 / (R * T)  # (mol/kJ)\n\n        # Step 2: Identify dividing surface (transition state)\n        idx_ts = np.argmax(F_s)\n        F_ts = F_s[idx_ts]\n\n        # Step 3: Identify reactant basin reference\n        reactant_mask = s_grid = s_cut\n        F_s_reactant_side = F_s[reactant_mask]\n        idx_r_local = np.argmin(F_s_reactant_side)\n        F_r = F_s_reactant_side[idx_r_local]\n        \n        # Step 4: Compute the barrier height\n        delta_F_ddagger = F_ts - F_r  # kJ/mol\n\n        # Step 5: Compute the constrained average of the absolute velocity\n        avg_abs_s_dot_ddagger = np.mean(np.abs(s_dot_samples))  # s^-1\n\n        # Step 6: Compute the TST rate constant\n        # k_TST = (1/2) * |s_dot|`> * exp(-beta * dF`)\n        k_tst = 0.5 * avg_abs_s_dot_ddagger * np.exp(-beta * delta_F_ddagger)\n\n        # Step 7: Compute the unbiased molecular dynamics rate\n        k_md = md_transitions / md_time\n\n        # Step 8: Validate TST result against MD result\n        if k_md == 0:\n            # Avoid division by zero, though not expected for these test cases.\n            # If MD rate is zero, TST rate should also be zero for a match.\n            validation_passed = (k_tst == 0)\n        else:\n            rel_diff = np.abs((k_tst - k_md) / k_md)\n            validation_passed = rel_diff = TOLERANCE\n            \n        results.append([k_tst, k_md, validation_passed])\n\n    # Final print statement in the exact required format.\n    # The format [[x1,y1,b1],[x2,y2,b2],...] requires converting Python list to string.\n    # Python's default str() for lists and booleans matches the requirement.\n    print(str(results).replace(\"'\", \"\"))\n\nsolve()\n\n```"
        },
        {
            "introduction": "The TST rate expression elegantly separates the rate into an equilibrium probability and a kinetic frequency factor. This practice focuses on the kinetic component, exploring its physical origins in phase space and its dependence on particle masses and the geometry of the reaction coordinate. By deriving the effective mass, $m_{\\mathrm{eff}}$, and verifying how the rate constant scales, you will gain a deeper intuition for the inertial effects that govern the dynamics of barrier crossing. ",
            "id": "3458183",
            "problem": "Consider a classical system with $n=4$ Cartesian coordinates collected in the vector $\\mathbf{q}\\in\\mathbb{R}^4$. Define a linear reaction coordinate $s=\\hat{\\mathbf{a}}^\\top \\mathbf{q}$, where $\\hat{\\mathbf{a}}=\\mathbf{a}/\\lVert \\mathbf{a}\\rVert$ and $\\mathbf{a}=(1.0,-2.0,0.5,0.25)$. Complete $\\hat{\\mathbf{a}}$ to an orthonormal basis of $\\mathbb{R}^4$ to define transverse coordinates $\\mathbf{y}\\in\\mathbb{R}^3$ such that the orthogonal change of variables $\\mathbf{q}\\mapsto (s,\\mathbf{y})$ has unit Jacobian. The potential energy function is assumed to be separable in these coordinates and given by\n$$\nU(s,\\mathbf{y})=\\frac{1}{2}k_R\\,(s+s_0)^2+\\frac{1}{2}\\kappa_\\perp \\sum_{i=1}^{3} y_i^2,\n$$\nwith parameters $k_R=5.0$, $s_0=1.0$, and $\\kappa_\\perp=3.0$. The reactant region is defined by the indicator $h_R=\\Theta(-s)$ and the dividing surface by $s=0$, where $\\Theta(\\cdot)$ is the Heaviside step function. The system is coupled to a heat bath at absolute temperature $T=0.7$ in reduced units where the Boltzmann constant $k_B=1$ (that is, energies are in the same reduced unit as $k_B T$). The mass matrix in Cartesian coordinates is diagonal, $\\mathbf{M}=\\mathrm{diag}(m_1,m_2,m_3,m_4)$, with a base mass set $\\mathbf{m}^{(0)}=(1.0,2.0,3.0,4.0)$.\n\nYour task is to write a complete program that, starting from the canonical Transition State Theory (TST) definition of the rate constant as a phase-space average and from the Maxwell–Boltzmann statistics of velocities, performs the following steps:\n\n- Derive an expression for the effective mass along the reaction coordinate, $m_{\\mathrm{eff}}$, as a function of the mass matrix $\\mathbf{M}$ and the unit vector $\\hat{\\mathbf{a}}$.\n- Starting from the canonical TST definition with a delta-function constraint on the dividing surface and the characteristic function for the reactant region, derive a closed-form expression for the TST rate constant $k_{\\mathrm{TST}}$ for the given harmonic form of $U(s,\\mathbf{y})$.\n- Use these derivations to compute $k_{\\mathrm{TST}}$ and the barrier free energy $\\Delta F^\\ddagger$ defined by\n$$\n\\Delta F^\\ddagger = -T \\ln\\left(\\frac{\\int d\\mathbf{y}\\,e^{-U(0,\\mathbf{y})/T}}{\\int_{s0} ds\\, d\\mathbf{y}\\,e^{-U(s,\\mathbf{y})/T}}\\right),\n$$\nfor multiple mass-scaling scenarios described below.\n\nScientific constraints and requirements:\n- Treat the canonical ensemble factorization of momentum and coordinate distributions as fundamental, and do not assume any result about $k_{\\mathrm{TST}}$ beyond what follows from this factorization and elementary Gaussian integrals.\n- The program must verify two properties for each mass-scaling case: (i) the $k_{\\mathrm{TST}}$ prefactor scales with the inverse square root of the effective mass along $s$ (that is, $k_{\\mathrm{TST}}\\propto \\sqrt{T/m_{\\mathrm{eff}}}$ at fixed potential and temperature), and (ii) the free-energy barrier $\\Delta F^\\ddagger$ is invariant under mass rescaling when the potential $U$ is unchanged.\n\nUse the following test suite of mass-scaling cases, each starting from the base mass vector $\\mathbf{m}^{(0)}$:\n- Case A (uniform scaling): multiply all masses by $\\alpha_A=0.5$.\n- Case B (single-coordinate scaling): multiply only the second mass by $\\alpha_B=4.0$ and leave the others unchanged.\n- Case C (uniform extreme scaling): multiply all masses by $\\alpha_C=10^6$.\n- Case D (uniform extreme scaling): multiply all masses by $\\alpha_D=10^{-6}$.\n\nFor each case $X\\in\\{A,B,C,D\\}$:\n- Compute the effective masses $m_{\\mathrm{eff}}^{(0)}$ (base) and $m_{\\mathrm{eff}}^{(X)}$ (scaled), and the corresponding TST rates $k_{\\mathrm{TST}}^{(0)}$ and $k_{\\mathrm{TST}}^{(X)}$, as well as $\\Delta F^{\\ddagger(0)}$ and $\\Delta F^{\\ddagger(X)}$.\n- Define a numerical tolerance $\\varepsilon=10^{-10}$.\n- Check the prefactor-scaling statement by verifying that\n$$\n\\left|\\frac{k_{\\mathrm{TST}}^{(X)}}{k_{\\mathrm{TST}}^{(0)}}-\\sqrt{\\frac{m_{\\mathrm{eff}}^{(0)}}{m_{\\mathrm{eff}}^{(X)}}}\\right|\\le \\varepsilon,\n$$\nand output a boolean for this check.\n- Check the mass-invariance of the barrier by verifying that\n$$\n\\left|\\Delta F^{\\ddagger(X)}-\\Delta F^{\\ddagger(0)}\\right|\\le \\varepsilon,\n$$\nand output a boolean for this check.\n\nAngle units are not involved. All internal computations are in the reduced unit system described above. The output must consist only of booleans, which are dimensionless.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$$\n[\\text{prefactor\\_ok}^{(A)},\\text{barrier\\_ok}^{(A)},\\text{prefactor\\_ok}^{(B)},\\text{barrier\\_ok}^{(B)},\\text{prefactor\\_ok}^{(C)},\\text{barrier\\_ok}^{(C)},\\text{prefactor\\_ok}^{(D)},\\text{barrier\\_ok}^{(D)}].\n$$",
            "solution": "The problem requires the derivation and calculation of the Transition State Theory (TST) rate constant, $k_{\\mathrm{TST}}$, and the associated free-energy barrier, $\\Delta F^\\ddagger$, for a given classical system. The solution involves three primary theoretical steps followed by numerical computation and verification.\n\n### Theoretical Derivation\n\n#### 1. General Expression for the TST Rate Constant\n\nThe canonical TST rate constant, $k_{\\mathrm{TST}}$, is defined as the forward flux through the dividing surface $s=0$ normalized by the reactant population.\n$$\nk_{\\mathrm{TST}} = \\frac{\\text{Flux}_{\\text{forward}}(s=0)}{\\text{Population}_{\\text{reactants}}} = \\frac{\\langle \\delta(s) \\dot{s} \\Theta(\\dot{s}) \\rangle}{\\langle h_R \\rangle}\n$$\nwhere $\\langle \\cdot \\rangle$ denotes a canonical ensemble average, $s=\\hat{\\mathbf{a}}^\\top \\mathbf{q}$ is the reaction coordinate, $\\dot{s}$ is its time derivative, $\\delta(\\cdot)$ is the Dirac delta function, $\\Theta(\\cdot)$ is the Heaviside step function enforcing forward flux ($\\dot{s}0$), and $h_R = \\Theta(-s)$ is the indicator function for the reactant region ($s0$).\n\nThe Hamiltonian is separable, $H(\\mathbf{q}, \\mathbf{p}) = K(\\mathbf{p}) + U(\\mathbf{q})$, where $K(\\mathbf{p}) = \\frac{1}{2}\\mathbf{p}^\\top\\mathbf{M}^{-1}\\mathbf{p}$. Consequently, the ensemble average factorizes into momentum and coordinate parts.\n$$\nk_{\\mathrm{TST}} = \\frac{\\frac{1}{Z_p Z_q} \\left( \\int d\\mathbf{p} \\, \\dot{s} \\Theta(\\dot{s}) e^{-K(\\mathbf{p})/T} \\right) \\left( \\int d\\mathbf{q} \\, \\delta(s) e^{-U(\\mathbf{q})/T} \\right)}{\\frac{1}{Z_p Z_q} \\left( \\int d\\mathbf{p} \\, e^{-K(\\mathbf{p})/T} \\right) \\left( \\int d\\mathbf{q} \\, \\Theta(-s) e^{-U(\\mathbf{q})/T} \\right)}\n$$\nwhere $Z_p$ and $Z_q$ are the momentum and configuration partition functions, respectively, and the temperature $T$ is in units where $k_B=1$. This simplifies to a product of a kinetic prefactor and a configurational ratio:\n$$\nk_{\\mathrm{TST}} = \\left( \\frac{\\int d\\mathbf{p} \\, \\dot{s} \\Theta(\\dot{s}) e^{-K(\\mathbf{p})/T}}{\\int d\\mathbf{p} \\, e^{-K(\\mathbf{p})/T}} \\right) \\times \\left( \\frac{\\int d\\mathbf{q} \\, \\delta(s) e^{-U(\\mathbf{q})/T}}{\\int d\\mathbf{q} \\, \\Theta(-s) e^{-U(\\mathbf{q})/T}} \\right) = \\nu_{\\mathrm{kin}} \\times K_{\\mathrm{conf}}\n$$\n\n#### 2. Kinetic Prefactor ($\\nu_{\\mathrm{kin}}$) and Effective Mass ($m_{\\mathrm{eff}}$)\n\nThe velocity along the reaction coordinate is $\\dot{s} = \\hat{\\mathbf{a}}^\\top\\dot{\\mathbf{q}} = \\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}\\mathbf{p}$. The Cartesian momenta $p_i$ are independent variables drawn from a Gaussian distribution with mean $0$ and variance $\\langle p_i^2 \\rangle = m_i T$. Therefore, $\\dot{s}$ is a Gaussian random variable with mean $\\langle \\dot{s} \\rangle = 0$ and variance:\n$$\n\\sigma_{\\dot{s}}^2 = \\langle \\dot{s}^2 \\rangle = \\langle (\\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}\\mathbf{p})(\\mathbf{p}^\\top\\mathbf{M}^{-1}\\hat{\\mathbf{a}}) \\rangle = \\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}\\langle \\mathbf{p}\\mathbf{p}^\\top \\rangle \\mathbf{M}^{-1}\\hat{\\mathbf{a}}\n$$\nSince $\\langle \\mathbf{p}\\mathbf{p}^\\top \\rangle = T\\mathbf{M}$, the variance is:\n$$\n\\sigma_{\\dot{s}}^2 = \\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}(T\\mathbf{M})\\mathbf{M}^{-1}\\hat{\\mathbf{a}} = T(\\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}\\hat{\\mathbf{a}})\n$$\nThe kinetic prefactor $\\nu_{\\mathrm{kin}} = \\langle \\dot{s} \\Theta(\\dot{s}) \\rangle_p$ is the average of positive velocities:\n$$\n\\nu_{\\mathrm{kin}} = \\int_0^\\infty \\dot{s} \\frac{1}{\\sqrt{2\\pi\\sigma_{\\dot{s}}^2}} e^{-\\dot{s}^2/(2\\sigma_{\\dot{s}}^2)} d\\dot{s} = \\frac{\\sigma_{\\dot{s}}}{\\sqrt{2\\pi}} = \\sqrt{\\frac{T}{2\\pi}} \\sqrt{\\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}\\hat{\\mathbf{a}}}\n$$\nThe problem requires verifying that $k_{\\mathrm{TST}} \\propto \\sqrt{T/m_{\\mathrm{eff}}}$. Since $\\nu_{\\mathrm{kin}}$ is the only mass-dependent factor in $k_{\\mathrm{TST}}$, we identify the effective mass $m_{\\mathrm{eff}}$ such that $\\nu_{\\mathrm{kin}} = \\sqrt{T/(2\\pi m_{\\mathrm{eff}})}$. This implies $1/m_{\\mathrm{eff}} = \\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}\\hat{\\mathbf{a}}$. The expression for the effective mass is thus:\n$$\nm_{\\mathrm{eff}} = \\left( \\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}\\hat{\\mathbf{a}} \\right)^{-1} = \\left( \\sum_{i=1}^4 \\frac{\\hat{a}_i^2}{m_i} \\right)^{-1}\n$$\nwhere $\\hat{\\mathbf{a}} = \\mathbf{a}/\\lVert\\mathbf{a}\\rVert$ and $\\mathbf{M}=\\mathrm{diag}(m_1,m_2,m_3,m_4)$.\n\n#### 3. Configurational Ratio ($K_{\\mathrm{conf}}$) and Free Energy Barrier ($\\Delta F^\\ddagger$)\n\nWe use the orthogonal coordinate transformation $\\mathbf{q} \\to (s, \\mathbf{y})$ with unit Jacobian specified in the problem, so $d\\mathbf{q} = ds\\,d\\mathbf{y}$. The potential energy is separable: $U(s,\\mathbf{y})=U_s(s)+U_y(\\mathbf{y})$, with $U_s(s)=\\frac{1}{2}k_R(s+s_0)^2$ and $U_y(\\mathbf{y})=\\frac{1}{2}\\kappa_\\perp\\sum_{i=1}^3 y_i^2$.\n\nThe configurational ratio $K_{\\mathrm{conf}}$ becomes:\n$$\nK_{\\mathrm{conf}} = \\frac{\\int ds\\,d\\mathbf{y}\\,\\delta(s) e^{-(U_s(s)+U_y(\\mathbf{y}))/T}}{\\int ds\\,d\\mathbf{y}\\,\\Theta(-s) e^{-(U_s(s)+U_y(\\mathbf{y}))/T}} = \\frac{e^{-U_s(0)/T} \\int d\\mathbf{y}\\,e^{-U_y(\\mathbf{y})/T}}{(\\int_{-\\infty}^0 ds\\,e^{-U_s(s)/T}) (\\int d\\mathbf{y}\\,e^{-U_y(\\mathbf{y})/T})} = \\frac{e^{-U_s(0)/T}}{\\int_{-\\infty}^0 ds\\,e^{-U_s(s)/T}}\n$$\nSubstituting $U_s(s)$, we get $U_s(0) = \\frac{1}{2}k_R s_0^2$. The integral in the denominator is a truncated Gaussian integral:\n$$\n\\int_{-\\infty}^0 e^{-\\frac{k_R}{2T}(s+s_0)^2} ds = \\sqrt{\\frac{2\\pi T}{k_R}} \\frac{1}{2} \\left[1 + \\mathrm{erf}\\left(s_0\\sqrt{\\frac{k_R}{2T}}\\right)\\right]\n$$\nThe problem defines the free energy barrier as:\n$$\n\\Delta F^\\ddagger = -T \\ln\\left(\\frac{\\int d\\mathbf{y}\\,e^{-U(0,\\mathbf{y})/T}}{\\int_{s0} ds\\, d\\mathbf{y}\\,e^{-U(s,\\mathbf{y})/T}}\\right)\n$$\nThis is precisely $-T \\ln(K_{\\mathrm{conf}})$. Thus, $\\Delta F^\\ddagger$ is purely dependent on the potential energy function and temperature, not on the masses. This confirms the expectation of mass-invariance.\n$$\n\\Delta F^\\ddagger = -T \\ln \\left( \\frac{e^{-k_R s_0^2 / (2T)}}{\\sqrt{\\frac{2\\pi T}{k_R}} \\frac{1}{2} \\left[1 + \\mathrm{erf}\\left(s_0\\sqrt{\\frac{k_R}{2T}}\\right)\\right]} \\right) = \\frac{k_R s_0^2}{2} + T \\ln\\left(\\sqrt{\\frac{2\\pi T}{k_R}} \\frac{1}{2} \\left[1 + \\mathrm{erf}\\left(s_0\\sqrt{\\frac{k_R}{2T}}\\right)\\right]\\right)\n$$\n\n### Final Expression for $k_{\\mathrm{TST}}$\n\nCombining the kinetic and configurational parts:\n$$\nk_{\\mathrm{TST}} = \\sqrt{\\frac{T}{2\\pi m_{\\mathrm{eff}}}} \\frac{e^{-k_R s_0^2 / (2T)}}{\\sqrt{\\frac{2\\pi T}{k_R}} \\frac{1}{2} \\left[1 + \\mathrm{erf}\\left(s_0\\sqrt{\\frac{k_R}{2T}}\\right)\\right]}\n$$\nSimplifying this expression yields:\n$$\nk_{\\mathrm{TST}} = \\frac{1}{2\\pi} \\sqrt{\\frac{k_R}{m_{\\mathrm{eff}}}} \\frac{e^{-k_R s_0^2 / (2T)}}{\\frac{1}{2} \\left[1 + \\mathrm{erf}\\left(s_0\\sqrt{\\frac{k_R}{2T}}\\right)\\right]}\n$$\nThis expression explicitly shows that $k_{\\mathrm{TST}} \\propto 1/\\sqrt{m_{\\mathrm{eff}}}$, confirming the scaling relationship to be tested.\n\nThese derived formulas will be implemented to compute the required quantities for the specified mass-scaling scenarios and verify the theoretical predictions.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Solves the transition state theory problem by deriving and computing\n    the rate constant and free energy barrier for various mass-scaling scenarios.\n    \"\"\"\n\n    #\n    # Step 1: Define givens from the problem statement\n    #\n    a_vec = np.array([1.0, -2.0, 0.5, 0.25])\n    k_R = 5.0\n    s_0 = 1.0\n    # kappa_perp is only needed for the derivation, not the final formulas for k_TST and delta_F\n    # kappa_perp = 3.0\n    T = 0.7\n    m0 = np.array([1.0, 2.0, 3.0, 4.0])\n    epsilon = 1e-10\n\n    # Define mass-scaling test cases\n    test_cases = [\n        ('A', lambda m: m * 0.5),         # Uniform scaling\n        ('B', lambda m: np.array([m[0], m[1] * 4.0, m[2], m[3]])), # Single-coordinate scaling\n        ('C', lambda m: m * 1e6),         # Uniform extreme scaling (large)\n        ('D', lambda m: m * 1e-6),        # Uniform extreme scaling (small)\n    ]\n\n    #\n    # Step 2: Implement the derived formulas\n    #\n\n    # Pre-calculate components that do not depend on mass\n    a_norm_sq = np.dot(a_vec, a_vec)\n    a_hat_sq_components = a_vec**2 / a_norm_sq\n    \n    s0_sqrt_arg = s_0 * np.sqrt(k_R / (2.0 * T))\n    erf_term_val = 0.5 * (1.0 + erf(s0_sqrt_arg))\n    exp_term_val = np.exp(-k_R * s_0**2 / (2.0 * T))\n\n    def calc_m_eff(m, a_hat_sq_comps):\n        \"\"\"Calculates the effective mass along the reaction coordinate.\"\"\"\n        m_eff_inv = np.sum(a_hat_sq_comps / m)\n        return 1.0 / m_eff_inv\n\n    def calc_k_tst(m_eff, k_R, exp_term, erf_term):\n        \"\"\"Calculates the TST rate constant.\"\"\"\n        prefactor = (1.0 / (2.0 * np.pi)) * np.sqrt(k_R / m_eff)\n        rate = prefactor * exp_term / erf_term\n        return rate\n\n    def calc_delta_F(k_R, s_0, T, erf_term):\n        \"\"\"Calculates the free energy barrier.\"\"\"\n        E_b = 0.5 * k_R * s_0**2\n        log_arg = np.sqrt(2.0 * np.pi * T / k_R) * erf_term\n        delta_F = E_b + T * np.log(log_arg)\n        return delta_F\n\n    #\n    # Step 3: Perform calculations for base case and test cases\n    #\n\n    # Calculate base case (0) values\n    m_eff_0 = calc_m_eff(m0, a_hat_sq_components)\n    k_tst_0 = calc_k_tst(m_eff_0, k_R, exp_term_val, erf_term_val)\n    delta_F_0 = calc_delta_F(k_R, s_0, T, erf_term_val)\n\n    results = []\n    for _name, scaling_func in test_cases:\n        # Apply mass scaling for the current case\n        m_X = scaling_func(m0)\n        \n        # Calculate quantities for the scaled case\n        m_eff_X = calc_m_eff(m_X, a_hat_sq_components)\n        k_tst_X = calc_k_tst(m_eff_X, k_R, exp_term_val, erf_term_val)\n        delta_F_X = calc_delta_F(k_R, s_0, T, erf_term_val)\n\n        #\n        # Step 4: Verify the scientific constraints\n        #\n\n        # Check 1: Prefactor scaling (k_TST proportional to 1/sqrt(m_eff))\n        ratio_k = k_tst_X / k_tst_0\n        ratio_m_sqrt = np.sqrt(m_eff_0 / m_eff_X)\n        prefactor_ok = np.abs(ratio_k - ratio_m_sqrt) = epsilon\n        results.append(prefactor_ok)\n\n        # Check 2: Mass invariance of the free energy barrier\n        barrier_ok = np.abs(delta_F_X - delta_F_0) = epsilon\n        results.append(barrier_ok)\n        \n    #\n    # Step 5: Format and print the final output\n    #\n    output_str = f\"[{','.join(map(str, results))}]\"\n    # Convert Python booleans to lowercase for the final output string.\n    print(output_str.lower())\n\nsolve()\n```"
        },
        {
            "introduction": "Transition State Theory fundamentally models reactions as rare, uncorrelated events, which mathematically implies that the waiting times between them should follow an exponential distribution. This exercise shifts the focus from simply calculating a rate constant to validating this core statistical assumption, a critical task when analyzing data from rare-event simulations. You will implement a maximum likelihood estimator to extract the rate from first-passage times and use the memoryless property of the exponential distribution to test whether the underlying kinetic model is sound. ",
            "id": "3458145",
            "problem": "You are to design and implement a complete program that estimates a rate constant and validates exponential first-passage time statistics in the context of Molecular Dynamics (MD) with infrequent metadynamics, grounded in Transition State Theory (TST). Begin from first principles: treat rare barrier-crossing events as a Poisson process with a constant hazard rate. Under infrequent metadynamics, a bias is deposited with stride $\\tau_{\\mathrm{dep}}$ such that the transition state region is minimally perturbed, preserving kinetics. Your task is to use first-passage times measured under specified deposition strides to validate exponential statistics and extract the rate constant.\n\nStarting point and assumptions:\n- Assume a single barrier-crossing event is observed when a collective variable $s$ first reaches a product basin from a reactant basin.\n- When kinetics are preserved (that is, when $\\tau_{\\mathrm{dep}}$ is large relative to the fast crossing time over the barrier top), the first-passage times $t_i$ should be independent and identically distributed as an exponential random variable with a constant rate $k$.\n- For testing the exponential assumption, use the defining memoryless property of the exponential distribution: the conditional distribution of the residual time $T-c$ given $Tc$ is the same as the original distribution of $T$, for any $c0$.\n\nYour program must:\n- Derive and implement a maximum likelihood estimator for the rate constant $k$ using $n$ independent first-passage times $t_1,\\dots,t_n$.\n- Validate that the first-passage times are consistent with exponential statistics by testing the memoryless property via censoring at a threshold $c$, chosen as the sample median. Compute an estimator from the full data and another estimator from the residuals of those $t_i$ exceeding $c$, and assess their relative agreement.\n\nScientific realism:\n- Interpret the deposition stride $\\tau_{\\mathrm{dep}}$ as the interval at which bias Gaussians are deposited in metadynamics. Larger $\\tau_{\\mathrm{dep}}$ aims to reduce bias interference with barrier-crossing dynamics, making the exponential assumption more plausible, while too-small $\\tau_{\\mathrm{dep}}$ may break kinetics and distort first-passage statistics.\n\nUnits and outputs:\n- All times must be treated in picoseconds, written as $\\mathrm{ps}$, and the rate constant must be expressed in inverse picoseconds, written as $\\mathrm{ps}^{-1}$.\n- For each test case, compute the estimated rate constant $k$ returned as a floating-point number in $\\mathrm{ps}^{-1}$ and a boolean that indicates whether the exponential memoryless validation passed.\n- The final output line must be a single comma-separated list enclosed in square brackets of the form $[k_1,\\mathrm{pass}_1,k_2,\\mathrm{pass}_2,k_3,\\mathrm{pass}_3]$, where $k_j$ are floats in $\\mathrm{ps}^{-1}$ and $\\mathrm{pass}_j$ are booleans. No other text may be printed.\n\nTest suite:\nImplement exactly the following three cases. The first-passage times are to be constructed deterministically from specified Uniform random variates via the standard inverse transform approach, and mixtures, so the program is self-contained.\n\n- Case $1$ (happy path, kinetics preserved):\n  - Deposition stride: $\\tau_{\\mathrm{dep}} = 100\\,\\mathrm{ps}$.\n  - True underlying rate for data generation (not used by your estimator): $k_{\\mathrm{true}} = 0.0015\\,\\mathrm{ps}^{-1}$.\n  - Uniform seeds: $U = [0.05,0.10,0.20,0.30,0.40,0.60,0.80,0.90,0.95,0.33,0.57,0.77,0.12,0.21,0.69,0.88,0.15,0.45,0.63,0.99]$.\n  - Construct first-passage times by $t_i = -\\ln(1-U_i)/k_{\\mathrm{true}}$ for each element of $U$.\n\n- Case $2$ (edge case, frequent deposition breaks kinetics):\n  - Deposition stride: $\\tau_{\\mathrm{dep}} = 10\\,\\mathrm{ps}$.\n  - Use the same $k_{\\mathrm{true}} = 0.0015\\,\\mathrm{ps}^{-1}$.\n  - Uniform seeds for an exponential component: take the first $18$ values of $U$ from Case $1$ and compute $t_i = -\\ln(1-U_i)/k_{\\mathrm{true}}$.\n  - Add $12$ artificially short times to emulate kinetics distortion: $t = 50\\,\\mathrm{ps}$ repeated $12$ times.\n  - The full dataset is the concatenation of these $18$ exponential times and the $12$ short times.\n\n- Case $3$ (boundary case, small sample but preserved kinetics):\n  - Deposition stride: $\\tau_{\\mathrm{dep}} = 500\\,\\mathrm{ps}$.\n  - True underlying rate for data generation (not used by your estimator): $k_{\\mathrm{true}} = 0.0009\\,\\mathrm{ps}^{-1}$.\n  - Uniform seeds: $U = [0.08,0.25,0.50,0.70,0.85,0.95]$.\n  - Construct first-passage times by $t_i = -\\ln(1-U_i)/k_{\\mathrm{true}}$ for each element of $U$.\n\nAlgorithmic requirements:\n- Derive the maximum likelihood estimator for $k$ from first principles of the exponential model and implement it as $k_{\\mathrm{ML}}$ computed from the full dataset $\\{t_i\\}$ of a case.\n- Let $c$ be the sample median of $\\{t_i\\}$. Construct the residual dataset $\\{t_i-c\\,|\\,t_ic\\}$ and compute $k_{\\mathrm{resid}}$ from these residuals.\n- Define the validation boolean as $\\mathrm{pass} = \\left(\\left|k_{\\mathrm{resid}} - k_{\\mathrm{ML}}\\right|/k_{\\mathrm{ML}} \\le r_{\\mathrm{tol}}\\right)$ with a relative tolerance $r_{\\mathrm{tol}} = 0.30$. If there are no residuals (that is, if no $t_i$ exceeds $c$), the validation must be $\\mathrm{false}$.\n- Return $k_{\\mathrm{ML}}$ as a float in $\\mathrm{ps}^{-1}$ and $\\mathrm{pass}$ as a boolean.\n\nAnswer specification:\n- The program must produce a single line of output containing a comma-separated list enclosed in square brackets with the results for the cases in order $1,2,3$, namely $[k_1,\\mathrm{pass}_1,k_2,\\mathrm{pass}_2,k_3,\\mathrm{pass}_3]$.",
            "solution": "The problem requires the design and implementation of a method to estimate the rate constant of a rare event from a series of first-passage times, and to validate the statistical model upon which the estimation is based. The physical context is that of molecular dynamics simulations enhanced with infrequent metadynamics, where barrier-crossing events are modeled as a Poisson process. This implies that the first-passage times for these events are independent and identically distributed (i.i.d.) according to an exponential distribution.\n\nThe core tasks are to derive the maximum likelihood estimator (MLE) for the rate constant $k$ of the exponential distribution, and to implement a statistical test to check if the observed data is consistent with the memoryless property, a defining feature of the exponential distribution.\n\n**1. Maximum Likelihood Estimator for the Exponential Rate Constant**\n\nThe exponential distribution is characterized by a single parameter, the rate constant $k$. Its probability density function (PDF) for a random variable $T$ representing the first-passage time is given by:\n$$\np(t; k) = k e^{-kt} \\quad \\text{for } t \\ge 0, k  0\n$$\nGiven a set of $n$ independent and identically distributed first-passage times, $\\{t_1, t_2, \\dots, t_n\\}$, the likelihood function $L(k)$ is the joint probability of observing this specific dataset. Due to the independence of the observations, the joint probability is the product of the individual probabilities:\n$$\nL(k; \\{t_i\\}) = \\prod_{i=1}^{n} p(t_i; k) = \\prod_{i=1}^{n} k e^{-kt_i}\n$$\nThis can be simplified to:\n$$\nL(k) = k^n \\exp\\left(-k \\sum_{i=1}^{n} t_i\\right)\n$$\nThe maximum likelihood estimator $k_{\\mathrm{ML}}$ is the value of $k$ that maximizes $L(k)$. It is often more convenient to maximize the natural logarithm of the likelihood function, the log-likelihood $\\ln L(k)$, since the logarithm is a monotonically increasing function and the location of the maximum will be the same.\n$$\n\\ln L(k) = \\ln\\left(k^n \\exp\\left(-k \\sum_{i=1}^{n} t_i\\right)\\right) = n \\ln k - k \\sum_{i=1}^{n} t_i\n$$\nTo find the maximum, we take the derivative of the log-likelihood with respect to $k$ and set it to zero:\n$$\n\\frac{d}{dk} \\ln L(k) = \\frac{n}{k} - \\sum_{i=1}^{n} t_i = 0\n$$\nSolving this equation for $k$ yields the maximum likelihood estimator, $k_{\\mathrm{ML}}$:\n$$\n\\frac{n}{k_{\\mathrm{ML}}} = \\sum_{i=1}^{n} t_i\n$$\n$$\nk_{\\mathrm{ML}} = \\frac{n}{\\sum_{i=1}^{n} t_i} = \\frac{1}{\\frac{1}{n}\\sum_{i=1}^{n} t_i}\n$$\nThis is a fundamental result: the maximum likelihood estimate of the rate constant for an exponential distribution is the reciprocal of the sample mean of the observations. We denote the sample mean as $\\langle t \\rangle = \\frac{1}{n}\\sum_{i=1}^{n} t_i$, so $k_{\\mathrm{ML}} = 1/\\langle t \\rangle$.\n\n**2. Validation of the Exponential Model via the Memoryless Property**\n\nThe validity of the rate constant estimate relies on the correctness of the underlying exponential model. A key property of the exponential distribution is that it is \"memoryless\". For a random variable $T \\sim \\text{Exponential}(k)$, this property is formally stated as:\n$$\nP(T  t_1 + t_2 \\mid T  t_1) = P(T  t_2) \\quad \\text{for all } t_1, t_2 \\ge 0\n$$\nThis means that the remaining lifetime of an object, given that it has already survived for some time $t_1$, is distributed in the same way as the original lifetime. The distribution of the residual time, $T' = T - t_1$ conditional on $T  t_1$, is also exponential with the same rate $k$.\n\nWe can use this property to construct a validation test for our dataset. The procedure is as follows:\n1.  Calculate the rate constant $k_{\\mathrm{ML}}$ from the full set of $n$ first-passage times $\\{t_i\\}$ using the derived MLE formula, $k_{\\mathrm{ML}} = 1 / \\langle t \\rangle$.\n2.  Choose a censoring time $c  0$. The problem specifies using the sample median of the dataset $\\{t_i\\}$ for $c$.\n3.  Create a new dataset of residual times. This set, $\\{t'_j\\}$, is composed of all times $t_i$ from the original dataset that are greater than the median $c$, with the median subtracted from them: $\\{t'_j\\} = \\{t_i - c \\mid t_i  c \\}$. Let the number of such data points be $n_{\\mathrm{resid}}$.\n4.  If the exponential model is correct, this residual dataset should also be exponentially distributed with the same rate $k$. We can estimate the rate from this new dataset, $k_{\\mathrm{resid}}$, using the same MLE formula:\n    $$\n    k_{\\mathrm{resid}} = \\frac{1}{\\langle t' \\rangle} = \\frac{n_{\\mathrm{resid}}}{\\sum_j t'_j}\n    $$\n    If no data points exist in the residual set (i.e., $n_{\\mathrm{resid}} = 0$, which can happen if multiple data points are equal to the median in an even-sized sample), the test cannot be performed, and the validation fails.\n5.  Compare the two estimates, $k_{\\mathrm{ML}}$ and $k_{\\mathrm{resid}}$. If the data truly follows an exponential distribution, these two estimates should be close, within the bounds of statistical sampling error. The problem defines a validation criterion based on their relative difference:\n    $$\n    \\mathrm{pass} = \\left( \\frac{|k_{\\mathrm{resid}} - k_{\\mathrm{ML}}|}{k_{\\mathrm{ML}}} \\le r_{\\mathrm{tol}} \\right)\n    $$\n    where the relative tolerance $r_{\\mathrm{tol}}$ is given as $0.30$. A $\\mathrm{pass}$ value of $\\mathrm{True}$ indicates that the data is consistent with the memoryless property, supporting the exponential model. A value of $\\mathrm{False}$ suggests a deviation from exponential statistics, which in the context of metadynamics could imply that the biasing protocol is distorting the free energy landscape and breaking the kinetic assumptions of Transition State Theory.\n\n**3. Test Cases Analysis**\n\nThe implementation will apply this procedure to three test cases, each designed to simulate a different physical scenario:\n-   **Case 1 (Happy Path)**: Data is generated from a pure exponential distribution with a large deposition stride $\\tau_{\\mathrm{dep}}$. We expect $k_{\\mathrm{ML}}$ and $k_{\\mathrm{resid}}$ to be similar, leading to a successful validation.\n-   **Case 2 (Distorted Kinetics)**: Data is a mixture of an exponential distribution and a set of artificially short passage times, simulating the effect of a small $\\tau_{\\mathrm{dep}}$ that perturbs the kinetics. The presence of these short times will skew the overall mean, making $k_{\\mathrm{ML}}$ differ significantly from $k_{\\mathrm{resid}}$, which is estimated from the tail of the distribution (likely dominated by the exponential part). We expect the validation to fail.\n-   **Case 3 (Small Sample)**: Data is from a pure exponential distribution but with a very small sample size. While the underlying physics is correct, large statistical fluctuations might cause the validation test to fail, highlighting the challenge of statistical inference with limited data. The generous tolerance of $r_{tol}=0.30$ may still allow it to pass.\n\nThe program will deterministically generate the data for each case, perform the analysis to compute $k_{\\mathrm{ML}}$ and the validation boolean, and report the results in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It defines the test cases, generates the data for each,\n    analyzes the data, and prints the final formatted output.\n    \"\"\"\n\n    # Uniform random variates for data generation, as specified in the problem.\n    U_seeds_case1 = [\n        0.05, 0.10, 0.20, 0.30, 0.40, 0.60, 0.80, 0.90, 0.95, 0.33,\n        0.57, 0.77, 0.12, 0.21, 0.69, 0.88, 0.15, 0.45, 0.63, 0.99\n    ]\n    U_seeds_case3 = [0.08, 0.25, 0.50, 0.70, 0.85, 0.95]\n\n    # Definition of the three test cases based on the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1: Happy Path\",\n            \"k_true\": 0.0015,  # ps^-1\n            \"tau_dep\": 100,     # ps\n            \"data_generator\": lambda k_true: -np.log(1 - np.array(U_seeds_case1)) / k_true\n        },\n        {\n            \"name\": \"Case 2: Broken Kinetics\",\n            \"k_true\": 0.0015,  # ps^-1\n            \"tau_dep\": 10,      # ps\n            \"data_generator\": lambda k_true: np.concatenate([\n                -np.log(1 - np.array(U_seeds_case1[:18])) / k_true,\n                np.full(12, 50.0) # 12 artificially short times\n            ])\n        },\n        {\n            \"name\": \"Case 3: Small Sample\",\n            \"k_true\": 0.0009,  # ps^-1\n            \"tau_dep\": 500,     # ps\n            \"data_generator\": lambda k_true: -np.log(1 - np.array(U_seeds_case3)) / k_true\n        }\n    ]\n\n    results = []\n    \n    # Relative tolerance for validation\n    r_tol = 0.30\n\n    for case in test_cases:\n        # Generate first-passage times for the current case\n        times = case[\"data_generator\"](case[\"k_true\"])\n        k_ml, passed = analyze_passage_times(times, r_tol)\n        results.extend([k_ml, str(passed).lower()])\n\n    # Print the final output in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef analyze_passage_times(times, r_tol):\n    \"\"\"\n    Analyzes a set of first-passage times to estimate the rate constant\n    and validate the exponential statistics assumption.\n\n    Args:\n        times (np.ndarray): An array of first-passage times in ps.\n        r_tol (float): The relative tolerance for the validation check.\n\n    Returns:\n        tuple[float, bool]: A tuple containing the estimated rate constant k_ML (in ps^-1)\n                            and a boolean indicating if the validation passed.\n    \"\"\"\n    times = np.asarray(times)\n    n = len(times)\n\n    if n == 0:\n        # Cannot compute rate constant from no data. This case is not in the problem spec\n        # but is good practice to handle. Returning NaN and False.\n        return np.nan, False\n\n    # 1. Compute the Maximum Likelihood Estimator (MLE) for the rate constant k\n    # k_ML = 1 / t = n / sum(t_i)\n    mean_time = np.mean(times)\n    k_ml = 1.0 / mean_time\n\n    # 2. Validate using the memoryless property\n    # Find the censoring threshold c, defined as the sample median.\n    c = np.median(times)\n    \n    # 3. Construct the residual dataset {t_i - c | t_i  c}\n    residuals = times[times > c] - c\n\n    # 4. If there are no residuals, the validation test fails.\n    if residuals.size == 0:\n        return k_ml, False\n\n    # 5. Compute the MLE from the residuals, k_resid\n    mean_residual_time = np.mean(residuals)\n    k_resid = 1.0 / mean_residual_time\n\n    # 6. Compare k_ml and k_resid to get the validation boolean\n    relative_difference = np.abs(k_resid - k_ml) / k_ml\n    passed = relative_difference = r_tol\n    \n    return k_ml, passed\n\n# Run the simulation and print the final answer\nsolve()\n```"
        }
    ]
}