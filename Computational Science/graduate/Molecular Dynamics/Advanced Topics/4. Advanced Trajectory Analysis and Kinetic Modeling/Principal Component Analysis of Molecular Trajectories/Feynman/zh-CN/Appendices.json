{
    "hands_on_practices": [
        {
            "introduction": "第一个实践提供了一个完整的端到端工作流程，从模拟一个简单系统到应用主成分分析（PCA）。通过分析一个二维双稳态势中的轨迹，您将获得关于PCA如何识别和表示重要集体运动（例如关键的越过能垒的坐标）的具体经验。本练习旨在建立对系统动力学与从轨迹数据中提取的主成分之间联系的基础直觉。",
            "id": "3437411",
            "problem": "给定一个二维双稳态玩具势，用于模拟分子动力学中的势垒穿越。您的任务是：在此势中通过过阻尼朗之万动力学模拟样本，对采样的分子轨迹执行主成分分析（PCA），并为每个测试用例确定在指定的均方误差阈值内重建势垒穿越坐标所需的最小主成分数量。\n\n在您的推导和实现中，请使用以下基本且被广泛接受的基础：\n- 在势 $U(\\mathbf{q})$ 中，一个处于逆温 $\\beta$ 的粒子的过阻尼朗之万动力学遵循随机微分方程 $d \\mathbf{q}_t = - \\nabla U(\\mathbf{q}_t) \\, dt + \\sqrt{2 \\beta^{-1}} \\, d \\mathbf{W}_t$，其中 $\\mathbf{W}_t$ 是标准维纳过程。在时间步长为 $\\Delta t$ 的离散时间中，Euler–Maruyama 更新规则为 $\\mathbf{q}_{n+1} = \\mathbf{q}_n - \\Delta t \\, \\nabla U(\\mathbf{q}_n) + \\sqrt{2 \\Delta t / \\beta} \\, \\boldsymbol{\\xi}_n$，其中 $\\boldsymbol{\\xi}_n$ 是一个由独立标准正态变量组成的向量。\n- 势垒穿越坐标定义为势在鞍点处的 Hessian 矩阵的不稳定特征向量上的投影。对于位于 $\\mathbf{q}^\\ast = \\mathbf{0}$ 的鞍点，Hessian 矩阵是二阶导数矩阵 $H_{ij} = \\partial^2 U / \\partial q_i \\partial q_j \\big|_{\\mathbf{q}=\\mathbf{0}}$。其与最小特征值相关联的特征向量给出了负曲率的方向，我们将其表示为 $\\mathbf{v}_{\\mathrm{b}}$。势垒穿越标量坐标为 $s = \\mathbf{v}_{\\mathrm{b}}^\\top \\mathbf{q}$。\n- 主成分分析 (PCA) 定义如下：给定均值中心化的数据矩阵 $X \\in \\mathbb{R}^{N \\times d}$，计算其奇异值分解 $X = U \\Sigma V^\\top$，其中 $V$ 的列是主轴。中心化数据的 $k$ 分量重构是 $X_k = X V_k V_k^\\top$，其中 $V_k$ 包含 $V$ 的前 $k$ 列。通过加回均值，可以获得原始坐标下的完整重构。\n\n考虑二维势\n$$\nU(x,y) = \\left(x^2 - a^2\\right)^2 + \\frac{k_y}{2} y^2 + c \\, x y,\n$$\n其中 $a > 0$ 控制了沿 $x$ 轴的势阱位置，$k_y > 0$ 是沿 $y$ 轴的刚度，$c$ 则耦合了 $x$ 和 $y$。所有量都是无量纲的；不需要物理单位。\n\n每个测试用例需要实现的任务：\n1. 使用指定的参数 $(a, k_y, c, \\beta, \\Delta t, N_{\\mathrm{steps}}, N_{\\mathrm{burn}})$，通过 Euler–Maruyama 方案模拟一条过阻尼朗之万轨迹。使用初始条件 $\\mathbf{q}_0 = (a, 0)$，丢弃前 $N_{\\mathrm{burn}}$ 步作为“燃烧期”(burn-in)，并保留剩余的样本，不进行子采样。\n2. 计算 $U$ 在 $(x,y) = (0,0)$ 处的 Hessian 矩阵 $H$，并获得与最小特征值相关联的归一化特征向量 $\\mathbf{v}_{\\mathrm{b}}$。对于任意样本 $\\mathbf{q}$，定义 $s = \\mathbf{v}_{\\mathrm{b}}^\\top \\mathbf{q}$ 为势垒穿越标量坐标。\n3. 对中心化的样本执行 PCA。对于每个 $k \\in \\{0,1,2\\}$，构建每个样本的 $k$ 分量重构 $\\widehat{\\mathbf{q}}^{(k)}$。对于 $k = 0$，重构即为样本均值。对于 $k \\ge 1$，使用到前 $k$ 个主轴上的投影。对于每个 $k$，计算重构后的标量坐标 $\\hat{s}^{(k)} = \\mathbf{v}_{\\mathrm{b}}^\\top \\widehat{\\mathbf{q}}^{(k)}$。\n4. 对于每个 $k$，计算均方误差\n$$\n\\mathrm{MSE}(k) = \\frac{1}{N} \\sum_{i=1}^N \\left(\\hat{s}^{(k)}_i - s_i\\right)^2.\n$$\n5. 设 $\\varepsilon$ 为测试用例的误差阈值。确定满足 $\\mathrm{MSE}(k) \\le \\varepsilon$ 的最小 $k \\in \\{0, 1, 2\\}$。如果多个 $k$ 满足该不等式，选择最小的一个。报告该最小的 $k$。\n\n测试套件包含三个用例。每个用例指定一个元组 $(a, k_y, c, \\beta, \\Delta t, N_{\\mathrm{steps}}, N_{\\mathrm{burn}}, \\varepsilon)$：\n- 用例 1：$(1.2, 5.0, 1.0, 0.7, 5 \\times 10^{-4}, 200000, 20000, 10.0)$。\n- 用例 2：$(1.2, 5.0, 1.0, 0.7, 5 \\times 10^{-4}, 200000, 20000, 0.2)$。\n- 用例 3：$(1.2, 5.0, 1.0, 0.7, 5 \\times 10^{-4}, 200000, 20000, 10^{-10})$。\n\n注意与约束：\n- 所有计算必须以无量纲形式进行；输出中不需要物理单位。\n- 初始条件、数值时间步长和步数已在上面指定，必须严格按照给定的值使用。\n- 必须使用固定的种子来控制随机性，以确保结果可复现；为每个测试用例使用一个从用例索引中确定性派生出的不同整数种子。\n- 最终程序不得读取任何输入；它必须在内部构建测试用例，并在一行中输出结果。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含每个测试用例的最小 $k$ 值，格式为方括号内以逗号分隔的列表，例如 $[k_1,k_2,k_3]$。数字 $k_i$ 必须是整数。",
            "solution": "该问题是有效的，因为它科学地基于统计力学和线性代数的原理，问题设定良好，具有明确的目标和充足的数据，并且表述客观。它构成了分子动力学领域的一个标准计算练习。我们开始求解。\n\n核心任务是确定在给定的误差容限内，从模拟的分子轨迹中重建一个特定的集体变量——势垒穿越坐标——所需的最小主成分数。这涉及一系列步骤：模拟系统动力学、定义感兴趣的坐标、执行主成分分析 (PCA) 以及评估重构误差。\n\n首先，我们定义系统。粒子的运动发生在一个由下式给出的二维势中\n$$\nU(x,y) = \\left(x^2 - a^2\\right)^2 + \\frac{k_y}{2} y^2 + c \\, x y\n$$\n该势具有两个势阱，使其成为研究势垒穿越事件的合适模型。动力学由过阻尼朗之万方程控制，该方程描述了粒子在势场力、摩擦力和随机热力作用下的运动。在其离散形式中，Euler-Maruyama 方案给出了粒子在步骤 $n$ 的位置向量 $\\mathbf{q}_n = (x_n, y_n)$ 的更新规则：\n$$\n\\mathbf{q}_{n+1} = \\mathbf{q}_n - \\Delta t \\, \\nabla U(\\mathbf{q}_n) + \\sqrt{\\frac{2 \\Delta t}{\\beta}} \\, \\boldsymbol{\\xi}_n\n$$\n其中 $\\Delta t$ 是时间步长，$\\beta$ 是逆温，$\\boldsymbol{\\xi}_n$ 是从标准正态分布中抽取的独立随机数向量，$\\nabla U(\\mathbf{q})$ 是势的梯度：\n$$\n\\nabla U(x,y) = \\begin{pmatrix} \\frac{\\partial U}{\\partial x} \\\\ \\frac{\\partial U}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 4x(x^2 - a^2) + c y \\\\ k_y y + c x \\end{pmatrix}\n$$\n按照问题说明，我们从 $\\mathbf{q}_0 = (a, 0)$ 开始模拟一条轨迹，共 $N_{\\mathrm{steps}}$ 步，并丢弃最初的 $N_{\\mathrm{burn}}$ 步以确保系统达到平衡。这留下了 $N = N_{\\mathrm{steps}} - N_{\\mathrm{burn}}$ 个样本用于分析。\n\n接下来，我们定义势垒穿越坐标 $s$。在物理上，这个坐标被解释为远离过渡态的最慢运动方向，该过渡态位于两个稳定态（势阱）之间的最高能量路径上。在数学上，它被定义为位置向量 $\\mathbf{q}$ 在势的鞍点处最大不稳定方向上的投影。主鞍点位于原点 $\\mathbf{q}^\\ast = (0,0)$。该点势的局部几何形状由二阶导数的海森矩阵表征：\n$$\nH = \\left. \\begin{pmatrix} \\frac{\\partial^2 U}{\\partial x^2}  \\frac{\\partial^2 U}{\\partial x \\partial y} \\\\ \\frac{\\partial^2 U}{\\partial y \\partial x}  \\frac{\\partial^2 U}{\\partial y^2} \\end{pmatrix} \\right|_{\\mathbf{q}=\\mathbf{0}} = \\begin{pmatrix} -4a^2  c \\\\ c  k_y \\end{pmatrix}\n$$\n由于 $H$ 是一个实对称矩阵，其特征值是实数，其特征向量是正交的。一个鞍点至少有一个负特征值。与最小（最负）特征值对应的特征向量 $\\mathbf{v}_{\\mathrm{b}}$ 指向负曲率方向，该方向代表势垒穿越方向。我们找到这个特征向量并将其归一化为单位长度。那么，任何样本位置 $\\mathbf{q}_i$ 的势垒穿越标量坐标由投影 $s_i = \\mathbf{v}_{\\mathrm{b}}^\\top \\mathbf{q}_i$ 给出。\n\n第三步是对 $N$ 个轨迹样本集合执行主成分分析 (PCA)，我们将其表示为数据矩阵 $Q \\in \\mathbb{R}^{N \\times 2}$。PCA 识别数据中变化的主轴。首先，我们计算平均位置 $\\boldsymbol{\\mu} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{q}_i$ 并构成均值中心化的数据矩阵 $X$，其中每一行是 $X_i = \\mathbf{q}_i - \\boldsymbol{\\mu}$。$X$ 的奇异值分解 (SVD) 计算为 $X = U \\Sigma V^\\top$。正交矩阵 $V \\in \\mathbb{R}^{2 \\times 2}$ 的列是数据的主成分（主轴）。\n\n然后我们使用有限数量的主成分 $k \\in \\{0, 1, 2\\}$ 来重构轨迹。\n对于 $k=0$，重构就是数据的均值：对所有 $i$，$\\widehat{\\mathbf{q}}_i^{(0)} = \\boldsymbol{\\mu}$。这代表了最佳的零维近似。\n对于 $k \\in \\{1, 2\\}$，中心化数据的重构是通过将数据投影到前 $k$ 个主轴上，然后变换回原始坐标空间得到的：$X_k = X V_k V_k^\\top$，其中 $V_k$ 是包含 $V$ 的前 $k$ 列的矩阵。通过加回均值获得完整的重构：$\\widehat{\\mathbf{q}}_i^{(k)} = \\boldsymbol{\\mu} + (X_k)_i$。对于 $k=2$，我们使用所有主成分，因此 $V_2=V$。由于 $V$ 是正交的（$V V^\\top = I$），重构是完美的：$\\widehat{\\mathbf{q}}_i^{(2)} = \\boldsymbol{\\mu} + (\\mathbf{q}_i - \\boldsymbol{\\mu}) = \\mathbf{q}_i$。\n\n最后，对于每个重构水平 $k$，我们计算重构的标量坐标 $\\hat{s}_i^{(k)} = \\mathbf{v}_{\\mathrm{b}}^\\top \\widehat{\\mathbf{q}}_i^{(k)}$ 并使用均方误差 (MSE) 评估其质量：\n$$\n\\mathrm{MSE}(k) = \\frac{1}{N} \\sum_{i=1}^N \\left(\\hat{s}^{(k)}_i - s_i\\right)^2\n$$\n对于给定的误差阈值 $\\varepsilon$，我们寻找满足 $\\mathrm{MSE}(k) \\le \\varepsilon$ 的最小整数 $k \\in \\{0, 1, 2\\}$。由于 $\\mathrm{MSE}(2)=0$（在数值精度范围内），对于 $\\varepsilon \\ge 0$ 总存在一个解。\n\n将此完整过程应用于指定的三个测试用例中的每一个，并为每个用例使用一个独特的、确定性的随机种子以确保可复现性。报告每个用例的最小 $k$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, k_y, c, beta, dt, n_steps, n_burn, epsilon)\n        (1.2, 5.0, 1.0, 0.7, 5e-4, 200000, 20000, 10.0),\n        (1.2, 5.0, 1.0, 0.7, 5e-4, 200000, 20000, 0.2),\n        (1.2, 5.0, 1.0, 0.7, 5e-4, 200000, 20000, 1e-10),\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        # Unpack parameters\n        a, k_y, c, beta, dt, n_steps, n_burn, epsilon = case\n        \n        # Set a deterministic seed for reproducibility for each case\n        np.random.seed(i)\n\n        # Task 1: Simulate an overdamped Langevin trajectory\n        q = np.zeros((n_steps, 2))\n        q[0] = [a, 0.0]\n        noise_factor = np.sqrt(2 * dt / beta)\n\n        for n in range(n_steps - 1):\n            x, y = q[n]\n            grad_x = 4 * x * (x**2 - a**2) + c * y\n            grad_y = k_y * y + c * x\n            grad = np.array([grad_x, grad_y])\n            xi = np.random.randn(2)\n            q[n+1] = q[n] - dt * grad + noise_factor * xi\n        \n        # Discard burn-in samples\n        samples = q[n_burn:]\n        N = len(samples)\n\n        # Task 2: Compute the barrier-crossing eigenvector\n        Hessian = np.array([[-4 * a**2, c], [c, k_y]])\n        # np.linalg.eigh sorts eigenvalues in ascending order\n        # and returns normalized eigenvectors.\n        eigvals, eigvecs = np.linalg.eigh(Hessian)\n        v_b = eigvecs[:, 0]\n        \n        # True barrier-crossing scalar coordinate for all samples\n        s = samples @ v_b\n\n        # Task 3: Perform PCA and reconstruct\n        q_mean = np.mean(samples, axis=0)\n        centered_samples = samples - q_mean\n        \n        # SVD: a is centered_samples, vh is V.T\n        u, s_vals, vh = np.linalg.svd(centered_samples, full_matrices=False)\n        V = vh.T\n        \n        # Task 4: Compute Mean Squared Error for each k\n        mse_values = []\n\n        # k = 0: Reconstruction is the mean\n        q_hat_0 = q_mean\n        s_hat_0 = q_hat_0 @ v_b\n        mse_0 = np.mean((s - s_hat_0)**2)\n        mse_values.append(mse_0)\n\n        # k = 1: Reconstruction using the first PC\n        V1 = V[:, 0:1] # Shape (2, 1) to ensure correct matrix multiplication\n        reconstructed_centered_1 = (centered_samples @ V1) @ V1.T\n        q_hat_1 = reconstructed_centered_1 + q_mean\n        s_hat_1 = q_hat_1 @ v_b\n        mse_1 = np.mean((s - s_hat_1)**2)\n        mse_values.append(mse_1)\n\n        # k = 2: Perfect reconstruction\n        # MSE is theoretically 0, practically close to machine epsilon.\n        mse_2 = 0.0\n        mse_values.append(mse_2)\n\n        # Task 5: Determine the minimal k\n        min_k = -1\n        for k, mse in enumerate(mse_values):\n            if mse = epsilon:\n                min_k = k\n                break\n        \n        results.append(min_k)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基础知识之后，本实践将处理一个分析真实分子模拟数据时的关键挑战：周期性边界条件（PBCs）的正确处理。您将探索不同的成像选择——朴素的包裹处理、最小镜像约定（MIC）和坐标解包裹——如何显著改变基于内部坐标（如对距离）的PCA结果。本练习强调了仔细进行数据预处理以避免分析伪影并确保结论物理有效性的重要性。",
            "id": "3437455",
            "problem": "您的任务是实现一个完整的程序，该程序在周期性边界条件下构建合成的分子动力学轨迹，计算不同映象选择下的两两距离涨落，并对这些涨落执行主成分分析（PCA）。目标是量化周期性边界解卷绕和映象选择如何影响两两距离特征的协方差特征结构。\n\n从以下基本基础和定义开始：\n\n- 在边长为 $L$ 的周期性立方模拟盒子中，分子动力学位置根据 Newton 定律演化，但为本问题之目的，您将直接构建合成的、时间离散的位置。\n- 立方盒子中的周期性边界条件（PBC）将位置 $\\mathbf{r}$ 处的粒子与其任何映象 $\\mathbf{r} + \\mathbf{n} L$ 等同，其中 $\\mathbf{n} \\in \\mathbb{Z}^{3}$。\n- 卷绕坐标 $\\mathbf{r}^{\\mathrm{wrap}}$ 是使用模 $L$ 沿每个笛卡尔轴归约到区间 $[0, L)$ 内的代表。\n- 最小映象约定（MIC）将两个卷绕位置 $\\mathbf{r}_{i}^{\\mathrm{wrap}}$ 和 $\\mathbf{r}_{j}^{\\mathrm{wrap}}$ 之间的位移定义为 $\\Delta \\mathbf{r}_{ij}^{\\mathrm{MIC}} = \\mathbf{r}_{i}^{\\mathrm{wrap}} - \\mathbf{r}_{j}^{\\mathrm{wrap}} - L \\,\\mathrm{round}\\!\\left( \\dfrac{\\mathbf{r}_{i}^{\\mathrm{wrap}} - \\mathbf{r}_{j}^{\\mathrm{wrap}}}{L} \\right)$，该操作逐分量应用，将位移带入 $[-L/2, L/2)$ 区间。\n- 解卷绕轨迹 $\\mathbf{r}_{i}^{\\mathrm{unw}}(t)$ 通过逐帧累积最小映象位移来重建连续的原子路径：如果 $\\mathbf{r}_{i}^{\\mathrm{wrap}}(t)$ 是卷绕位置，则 $\\Delta \\mathbf{d}_{i}(t) = \\mathbf{r}_{i}^{\\mathrm{wrap}}(t) - \\mathbf{r}_{i}^{\\mathrm{wrap}}(t-1)$，$\\Delta \\mathbf{d}_{i}^{\\mathrm{MIC}}(t) = \\Delta \\mathbf{d}_{i}(t) - L \\,\\mathrm{round}\\!\\left( \\dfrac{\\Delta \\mathbf{d}_{i}(t)}{L} \\right)$，并且 $\\mathbf{r}_{i}^{\\mathrm{unw}}(t) = \\mathbf{r}_{i}^{\\mathrm{unw}}(t-1) + \\Delta \\mathbf{d}_{i}^{\\mathrm{MIC}}(t)$，其中 $\\mathbf{r}_{i}^{\\mathrm{unw}}(0) = \\mathbf{r}_{i}^{\\mathrm{wrap}}(0)$。\n- 对于 $N$ 个原子，将时间 $t$ 的特征向量定义为所有唯一的两两欧几里得距离 $d_{ij}(t)$（其中 $1 \\le i  j \\le N$）按固定顺序排列的列表。对于 $T$ 帧的时间序列，将这些特征组合成一个 $T \\times M$ 的矩阵 $\\mathbf{F}$，其中 $M = N(N-1)/2$。\n- 通过减去时间平均值来计算涨落：$\\tilde{\\mathbf{F}} = \\mathbf{F} - \\mathbf{1}\\,\\boldsymbol{\\mu}^{\\top}$，其中 $\\boldsymbol{\\mu}$ 是随时间变化的平均值，$\\mathbf{1}$ 是长度为 $T$ 的全一向量。特征间的协方差矩阵为 $\\mathbf{C} = \\dfrac{1}{T-1}\\,\\tilde{\\mathbf{F}}^{\\top}\\tilde{\\mathbf{F}}$。\n- 协方差 $\\mathbf{C}$ 的主成分分析（PCA）由其特征分解给出：$\\mathbf{C}\\mathbf{v}_{k} = \\lambda_{k}\\mathbf{v}_{k}$，其中特征值 $\\lambda_{k}$ 按非递增顺序排序。最大特征值 $\\lambda_{\\max}$ 量化了主导方差模式。协方差矩阵的迹 $\\mathrm{tr}(\\mathbf{C})$ 等于特征方差之和。\n\n您必须实现三种映象选择来计算两两距离 $d_{ij}(t)$：\n- 卷绕-朴素法：使用 $\\|\\mathbf{r}^{\\mathrm{wrap}}_{i}(t) - \\mathbf{r}^{\\mathrm{wrap}}_{j}(t)\\|_{2}$，不使用 MIC。\n- 最小映象：使用 $\\|\\Delta \\mathbf{r}_{ij}^{\\mathrm{MIC}}(t)\\|_{2}$。\n- 解卷绕：如上计算 $\\mathbf{r}^{\\mathrm{unw}}(t)$，然后使用 $\\|\\mathbf{r}^{\\mathrm{unw}}_{i}(t) - \\mathbf{r}^{\\mathrm{unw}}_{j}(t)\\|_{2}$。\n\n所有距离都以埃（Å）为单位处理，但要求的输出是无量纲的比率。\n\n构建以下包含三个轨迹的测试套件，每个轨迹都在一个立方盒子中，并以从初始位置和恒定的每帧位移生成、全部为三维空间的卷绕位置给出：\n\n- 测试用例 1（无边界穿越，基线）：\n  - 盒子长度 $L = 10$。\n  - 原子数 $N = 3$，帧数 $T = 5$，帧索引为 $t \\in \\{0,1,2,3,4\\}$。\n  - 对于原子 0：初始位置 $(1.0, 2.0, 3.0)$，每帧增量 $(0.1, -0.05, 0.0)$。\n  - 对于原子 1：初始位置 $(2.0, 2.5, 3.5)$，每帧增量 $(0.0, 0.05, 0.0)$。\n  - 对于原子 2：初始位置 $(8.5, 1.0, 2.0)$，每帧增量 $(0.0, 0.0, 0.1)$。\n  - 卷绕位置是通过在加上 $t$ 次增量后对每个分量应用模 $L$ 运算得到的；在此情况下，没有分量达到 $L$。\n\n- 测试用例 2（单原子边界穿越，对于朴素卷绕法易产生伪影）：\n  - 盒子长度 $L = 10$。\n  - 原子数 $N = 3$，帧数 $T = 5$，其中 $t \\in \\{0,1,2,3,4\\}$。\n  - 对于原子 0：初始位置 $(9.8, 1.0, 1.0)$，每帧增量 $(0.3, 0.0, 0.0)$，每帧对模 $L$ 进行卷绕。\n  - 对于原子 1：初始位置 $(1.5, 1.0, 1.0)$，每帧增量 $(0.0, 0.0, 0.0)$。\n  - 对于原子 2：初始位置 $(5.0, 5.0, 5.0)$，每帧增量 $(0.0, 0.0, 0.0)$。\n\n- 测试用例 3（跨边界的反向传播，MIC 的稳定性与解卷绕的发散性）：\n  - 盒子长度 $L = 10$。\n  - 原子数 $N = 3$，帧数 $T = 6$，其中 $t \\in \\{0,1,2,3,4,5\\}$。\n  - 对于原子 0：初始位置 $(9.5, 0.0, 0.0)$，每帧增量 $(0.4, 0.0, 0.0)$，每帧对模 $L$ 进行卷绕。\n  - 对于原子 1：初始位置 $(0.5, 0.0, 0.0)$，每帧增量 $(-0.4, 0.0, 0.0)$，每帧对模 $L$ 进行卷绕。\n  - 对于原子 2：初始位置 $(5.0, 0.0, 0.0)$，每帧增量 $(0.0, 0.0, 0.0)$。\n\n对于每个测试用例，您必须：\n- 根据指定的初始位置和增量，使用每个分量的模 $L$ 运算来构建卷绕轨迹 $\\mathbf{r}^{\\mathrm{wrap}}_{i}(t)$。\n- 根据三种映象选择，计算由每帧所有唯一的两两距离组成的三个特征矩阵 $\\mathbf{F}^{\\mathrm{wrap}}$、$\\mathbf{F}^{\\mathrm{MIC}}$ 和 $\\mathbf{F}^{\\mathrm{unw}}$。\n- 根据上述定义，计算相应的特征协方差矩阵 $\\mathbf{C}^{\\mathrm{wrap}}$、$\\mathbf{C}^{\\mathrm{MIC}}$ 和 $\\mathbf{C}^{\\mathrm{unw}}$。\n- 计算最大特征值 $\\lambda_{\\max}^{\\mathrm{wrap}}$、$\\lambda_{\\max}^{\\mathrm{MIC}}$ 和 $\\lambda_{\\max}^{\\mathrm{unw}}$，以及迹 $\\tau^{\\mathrm{wrap}} = \\mathrm{tr}(\\mathbf{C}^{\\mathrm{wrap}})$ 和 $\\tau^{\\mathrm{MIC}} = \\mathrm{tr}(\\mathbf{C}^{\\mathrm{MIC}})$。\n\n对于每个测试用例，您的程序必须按顺序 $\\{1,2,3\\}$ 输出以下三个量：\n- $r_{w} = \\dfrac{\\lambda_{\\max}^{\\mathrm{wrap}}}{\\lambda_{\\max}^{\\mathrm{MIC}}}$，\n- $r_{u} = \\dfrac{\\lambda_{\\max}^{\\mathrm{unw}}}{\\lambda_{\\max}^{\\mathrm{MIC}}}$，\n- $r_{\\tau} = \\dfrac{\\tau^{\\mathrm{wrap}}}{\\tau^{\\mathrm{MIC}}}$。\n\n数值输出要求：\n- 将上述三个比率中的每一个表示为小数点后精确到 $6$ 位的小数。\n- 将三个测试用例的结果聚合到单行中，格式完全如下：一个用方括号括起来的逗号分隔列表，按测试用例的顺序将三元组展平。例如，输出应类似于 $[r_{w}^{(1)},r_{u}^{(1)},r_{\\tau}^{(1)},r_{w}^{(2)},r_{u}^{(2)},r_{\\tau}^{(2)},r_{w}^{(3)},r_{u}^{(3)},r_{\\tau}^{(3)}]$，其中每个条目都四舍五入到小数点后六位。\n\n此问题不涉及角度。最终输出不需要进行物理单位转换，因为所有比率都是无量纲的。您的程序必须完全自包含，不接受任何输入，并且只使用指定的库。",
            "solution": "用户提供的问题陈述已经过仔细验证，被确定为具有科学依据、定义明确且客观。它为解决一个与计算化学和分子生物物理学相关的问题提供了一套完整且一致的定义和数据。该问题要求实现一种算法，以量化周期性边界条件（PBC）的映象选择对两两分子距离统计特性的影响，特别是通过主成分分析（PCA）。\n\n解决方案通过以下步骤系统地进行：\n1.  在周期性边界条件下生成合成的原子轨迹。\n2.  使用三种不同的映象方法计算两两距离特征矩阵。\n3.  计算每个特征集的协方差矩阵及其随后的特征分解（PCA）。\n4.  计算指定的特征值和迹的比率，以量化不同映象方法之间的差异。\n\n每个步骤都根据问题陈述中定义的数学形式进行详细说明。\n\n首先，我们构建原子位置的时间序列。对于 $N$ 个原子中的每一个，生成一个包含 $T$ 个时间帧的卷绕轨迹 $\\mathbf{r}_{i}^{\\mathrm{wrap}}(t)$，时间帧索引为 $t \\in \\{0, 1, \\dots, T-1\\}$。给定一个初始位置 $\\mathbf{r}_{i}(0)$ 和一个恒定的每帧位移向量 $\\Delta\\mathbf{r}_{i}$，在卷绕前计算时间 $t$ 的位置为 $\\mathbf{r}_{i}^{\\mathrm{unbounded}}(t) = \\mathbf{r}_{i}(0) + t\\Delta\\mathbf{r}_{i}$。然后通过逐分量应用模 $L$ 运算来获得卷绕轨迹，其中 $L$ 是立方模拟盒子的边长：\n$$\n\\mathbf{r}_{i}^{\\mathrm{wrap}}(t) = \\mathbf{r}_{i}^{\\mathrm{unbounded}}(t) \\pmod L\n$$\n这将每个原子的每个坐标都置于由区间 $[0, L)$ 定义的主模拟盒子内。\n\n从卷绕轨迹 $\\mathbf{r}^{\\mathrm{wrap}}(t)$，我们推导出解卷绕轨迹 $\\mathbf{r}^{\\mathrm{unw}}(t)$。此过程为每个原子重建一条连续的路径，考虑了跨越周期性边界的跳跃。它是递归定义的。初始条件是 $\\mathbf{r}_{i}^{\\mathrm{unw}}(0) = \\mathbf{r}_{i}^{\\mathrm{wrap}}(0)$。对于后续的帧 $t  0$，更新规则是：\n$$\n\\mathbf{r}_{i}^{\\mathrm{unw}}(t) = \\mathbf{r}_{i}^{\\mathrm{unw}}(t-1) + \\Delta \\mathbf{d}_{i}^{\\mathrm{MIC}}(t)\n$$\n其中 $\\Delta \\mathbf{d}_{i}^{\\mathrm{MIC}}(t)$ 是原子 $i$ 在帧 $t-1$ 和 $t$ 之间的最小映象位移：\n$$\n\\Delta \\mathbf{d}_{i}^{\\mathrm{MIC}}(t) = \\left( \\mathbf{r}_{i}^{\\mathrm{wrap}}(t) - \\mathbf{r}_{i}^{\\mathrm{wrap}}(t-1) \\right) - L \\,\\mathrm{round}\\!\\left( \\frac{\\mathbf{r}_{i}^{\\mathrm{wrap}}(t) - \\mathbf{r}_{i}^{\\mathrm{wrap}}(t-1)}{L} \\right)\n$$\n`round` 函数逐分量应用于向量参数。这确保了任何单帧位移在幅度上大于 $L/2$ 都被解释为跨越边界进入最近周期性映象的运动。\n\n接下来，我们定义特征向量。特征是在每个时间帧 $t$ 时，原子 $i$ 和 $j$ 之间的 $M = N(N-1)/2$ 个唯一的两两欧几里得距离 $d_{ij}(t)$。我们使用三种不同的映象选择来计算这些距离，从而得到三个不同的特征矩阵：$\\mathbf{F}^{\\mathrm{wrap}}$、$\\mathbf{F}^{\\mathrm{MIC}}$ 和 $\\mathbf{F}^{\\mathrm{unw}}$，每个矩阵的大小均为 $T \\times M$。\n1.  **卷绕-朴素距离 ($d_{ij}^{\\mathrm{wrap}}$)**：该方法忽略 PBC，并直接计算存储在卷绕轨迹文件中的坐标之间的距离。当一对原子被边界隔开时，这可能导致巨大的、人为的距离伪影。\n    $$\n    d_{ij}^{\\mathrm{wrap}}(t) = \\left\\| \\mathbf{r}_{i}^{\\mathrm{wrap}}(t) - \\mathbf{r}_{j}^{\\mathrm{wrap}}(t) \\right\\|_{2}\n    $$\n2.  **最小映象距离 ($d_{ij}^{\\mathrm{MIC}}$)**：该方法通过对其位移向量应用最小映象约定（MIC），正确计算周期性系统中两个原子之间的最短距离。\n    $$\n    d_{ij}^{\\mathrm{MIC}}(t) = \\left\\| \\Delta \\mathbf{r}_{ij}^{\\mathrm{MIC}}(t) \\right\\|_{2} = \\left\\| \\left( \\mathbf{r}_{i}^{\\mathrm{wrap}}(t) - \\mathbf{r}_{j}^{\\mathrm{wrap}}(t) \\right) - L \\,\\mathrm{round}\\!\\left( \\frac{\\mathbf{r}_{i}^{\\mathrm{wrap}}(t) - \\mathbf{r}_{j}^{\\mathrm{wrap}}(t)}{L} \\right) \\right\\|_{2}\n    $$\n3.  **解卷绕距离 ($d_{ij}^{\\mathrm{unw}}$)**：该方法在解卷绕的、连续的坐标系中计算原子间的距离。\n    $$\n    d_{ij}^{\\mathrm{unw}}(t) = \\left\\| \\mathbf{r}_{i}^{\\mathrm{unw}}(t) - \\mathbf{r}_{j}^{\\mathrm{unw}}(t) \\right\\|_{2}\n    $$\n\n特征矩阵组合完毕后，我们进行统计分析。对于每个特征矩阵 $\\mathbf{F}$（代表 $\\mathbf{F}^{\\mathrm{wrap}}$、$\\mathbf{F}^{\\mathrm{MIC}}$ 或 $\\mathbf{F}^{\\mathrm{unw}}$ 中的任何一个），我们计算其协方差矩阵 $\\mathbf{C}$。首先，计算特征的时间平均向量 $\\boldsymbol{\\mu}$。\n$$\n\\boldsymbol{\\mu} = \\frac{1}{T} \\sum_{t=0}^{T-1} \\mathbf{F}_{t,:}\n$$\n然后，对特征矩阵进行均值中心化：$\\tilde{\\mathbf{F}} = \\mathbf{F} - \\mathbf{1}\\boldsymbol{\\mu}^{\\top}$，其中 $\\mathbf{1}$ 是长度为 $T$ 的全一列向量。样本协方差矩阵则计算为：\n$$\n\\mathbf{C} = \\frac{1}{T-1} \\tilde{\\mathbf{F}}^{\\top} \\tilde{\\mathbf{F}}\n$$\n这个 $M \\times M$ 矩阵在其对角线上描述了每个特征的方差，在其非对角线元素中描述了特征对之间的协方差。\n\n分析的核心是主成分分析（PCA），它涉及协方差矩阵的特征分解：\n$$\n\\mathbf{C}\\mathbf{v}_{k} = \\lambda_{k}\\mathbf{v}_{k}\n$$\n其中 $\\mathbf{v}_k$ 是特征向量（主成分），$\\lambda_k$ 是对应的特征值。特征值按非递增顺序排序 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_M \\ge 0$，表示每个主成分捕获的方差量。最大特征值 $\\lambda_{\\max} = \\lambda_1$ 量化了特征集中最主要涨落模式的方差。协方差矩阵的迹 $\\mathrm{tr}(\\mathbf{C}) = \\sum_{k=1}^{M} \\lambda_k$ 代表所有特征的总方差。\n\n最后，对于每个测试用例，我们计算以下无量纲比率，以比较三种映象方法的统计特征：\n-   $r_{w} = \\dfrac{\\lambda_{\\max}^{\\mathrm{wrap}}}{\\lambda_{\\max}^{\\mathrm{MIC}}}$：该比率衡量了相对于物理上正确的 MIC，由朴素卷绕 PBC 伪影引起的主导方差模式的膨胀程度。\n-   $r_{u} = \\dfrac{\\lambda_{\\max}^{\\mathrm{unw}}}{\\lambda_{\\max}^{\\mathrm{MIC}}}$：该比率将全局连续的解卷绕轨迹的主导方差与局部正确的 MIC 的主导方差进行比较。这可以突显出解卷绕表示中由长时间尺度扩散引起的伪影。\n-   $r_{\\tau} = \\dfrac{\\tau^{\\mathrm{wrap}}}{\\tau^{\\mathrm{MIC}}}$，其中 $\\tau = \\mathrm{tr}(\\mathbf{C})$：该比率衡量了由朴素卷绕 PBC 伪影引起的总特征方差的膨胀程度。\n\n该实现封装了整个过程，将其应用于三个指定的测试用例中的每一个，并生成所需格式（精确到小数点后六位）的比率。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the final result.\n    \"\"\"\n\n    def mic_displacement(delta_r, L):\n        \"\"\"\n        Computes the minimum image convention displacement vector(s).\n        \n        Args:\n            delta_r (np.ndarray): The displacement vector(s) without PBC.\n            L (float): The box length.\n        \n        Returns:\n            np.ndarray: The displacement vector(s) under MIC.\n        \"\"\"\n        return delta_r - L * np.round(delta_r / L)\n\n    def perform_pca(F):\n        \"\"\"\n        Computes the covariance matrix, its leading eigenvalue, and its trace.\n        \n        Args:\n            F (np.ndarray): The T x M feature matrix.\n        \n        Returns:\n            tuple[float, float]: The leading eigenvalue and the trace of the covariance matrix.\n        \"\"\"\n        T = F.shape[0]\n        if T  2:\n            return 0.0, 0.0\n\n        # rowvar=False: columns are variables (features), rows are observations (time)\n        # ddof=1: use sample covariance (divide by T-1)\n        C = np.cov(F, rowvar=False, ddof=1)\n        \n        # If F has only one feature column, np.cov returns a 0-dim array (scalar)\n        if C.ndim == 0:\n            eigenvalues = np.array([C.item()])\n        else:\n            # eigh returns eigenvalues in ascending order for symmetric matrices\n            eigenvalues = np.linalg.eigh(C)[0]\n        \n        lambda_max = eigenvalues[-1] if len(eigenvalues) > 0 else 0.0\n        trace = np.trace(C)\n        \n        return lambda_max, trace\n\n    def process_case(case_params):\n        \"\"\"\n        Processes a single test case from trajectory generation to ratio calculation.\n        \n        Args:\n            case_params (tuple): A tuple containing L, N, T, initial_pos, and increments.\n        \n        Returns:\n            tuple[float, float, float]: The calculated ratios r_w, r_u, r_tau.\n        \"\"\"\n        L, N, T, initial_pos, increments = case_params\n\n        # 1. Generate wrapped trajectory\n        t_vals = np.arange(T).reshape(T, 1, 1)\n        initial_pos_b = np.expand_dims(initial_pos, 0)\n        increments_b = np.expand_dims(increments, 0)\n        unbounded_traj = initial_pos_b + t_vals * increments_b\n        wrapped_traj = np.mod(unbounded_traj, L)\n\n        # 2. Generate unwrapped trajectory\n        unwrapped_traj = np.zeros_like(wrapped_traj)\n        unwrapped_traj[0] = wrapped_traj[0]\n        for t in range(1, T):\n            delta_d = wrapped_traj[t] - wrapped_traj[t-1]\n            delta_d_mic = mic_displacement(delta_d, L)\n            unwrapped_traj[t] = unwrapped_traj[t-1] + delta_d_mic\n\n        # 3. Compute feature matrices\n        M = N * (N - 1) // 2\n        F_wrap = np.zeros((T, M))\n        F_mic = np.zeros((T, M))\n        F_unw = np.zeros((T, M))\n\n        pairs = [(i, j) for i in range(N) for j in range(i + 1, N)]\n\n        for t in range(T):\n            r_wrap_t = wrapped_traj[t]\n            r_unw_t = unwrapped_traj[t]\n            for k, (i, j) in enumerate(pairs):\n                # Wrapped-naive\n                delta_r_wrap_naive = r_wrap_t[i] - r_wrap_t[j]\n                F_wrap[t, k] = np.linalg.norm(delta_r_wrap_naive)\n\n                # MIC\n                delta_r_mic = mic_displacement(delta_r_wrap_naive, L)\n                F_mic[t, k] = np.linalg.norm(delta_r_mic)\n\n                # Unwrapped\n                delta_r_unw = r_unw_t[i] - r_unw_t[j]\n                F_unw[t, k] = np.linalg.norm(delta_r_unw)\n\n        # 4. Perform PCA for each feature matrix\n        lambda_max_wrap, trace_wrap = perform_pca(F_wrap)\n        lambda_max_mic, trace_mic = perform_pca(F_mic)\n        lambda_max_unw, _ = perform_pca(F_unw)\n\n        # 5. Calculate and return ratios\n        # Handle potential division by zero if MIC variance is zero\n        r_w = (lambda_max_wrap / lambda_max_mic) if lambda_max_mic != 0 else 0.0\n        r_u = (lambda_max_unw / lambda_max_mic) if lambda_max_mic != 0 else 0.0\n        r_tau = (trace_wrap / trace_mic) if trace_mic != 0 else 0.0\n        \n        return r_w, r_u, r_tau\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10.0, 3, 5, \n         np.array([[1.0, 2.0, 3.0], [2.0, 2.5, 3.5], [8.5, 1.0, 2.0]]),\n         np.array([[0.1, -0.05, 0.0], [0.0, 0.05, 0.0], [0.0, 0.0, 0.1]])),\n        (10.0, 3, 5,\n         np.array([[9.8, 1.0, 1.0], [1.5, 1.0, 1.0], [5.0, 5.0, 5.0]]),\n         np.array([[0.3, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])),\n        (10.0, 3, 6,\n         np.array([[9.5, 0.0, 0.0], [0.5, 0.0, 0.0], [5.0, 0.0, 0.0]]),\n         np.array([[0.4, 0.0, 0.0], [-0.4, 0.0, 0.0], [0.0, 0.0, 0.0]]))\n    ]\n\n    results = []\n    for case in test_cases:\n        ratios = process_case(case)\n        results.extend(ratios)\n\n    # Format the final output string with rounding to 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一旦确定了主要的运动模式，一个关键的科学问题随之而来：这些运动在统计上是否显著，或者它们是否可能由随机噪声产生？这个高级实践介绍了一种强大的非参数技术——置换检验——来严格回答这个关于时间相关数据的问题。您将实现一个基于时间延迟协方差的统计检验，以区分真实的慢集体动力学与任何有限轨迹中预期的背景噪声。",
            "id": "3437460",
            "problem": "您的任务是形式化并实现一个基于统计学原理的检验，用以评估在分子轨迹中观察到的主导集体运动是否比在时间不相关噪声的原假设下预期的更强。在分子动力学（MD）的背景下，一条分子轨迹可以表示为笛卡尔坐标的时间序列，从而形成欧几里得空间中的一个向量序列。考虑一条轨迹表示为序列 $\\{ \\mathbf{x}_t \\}_{t=0}^{T-1}$，其中 $\\mathbf{x}_t \\in \\mathbb{R}^d$，$t$ 是模拟帧的索引，$T$ 是总帧数，$d$ 是自由度数。该问题涉及通过源于时间延迟协方差的特征值问题来分析慢集体运动，并通过打乱帧顺序以破坏时间相关性来构建一个置换检验。\n\n从时间序列分析中的协方差和时间延迟协方差的基本定义以及线性代数特征值问题出发，按以下步骤进行，不要引入任何外部的启发式捷径：\n\n1. 从轨迹 $\\{ \\mathbf{x}_t \\}$ 出发，定义一个时间延迟 $\\tau \\in \\mathbb{N}$，满足 $0  \\tau  T$。仅使用向量值时间序列的协方差和相关性的定义，基于样本 $\\{ \\mathbf{x}_t \\}_{t=0}^{T-1}$ 构建在延迟 $\\tau$ 时的瞬时协方差和时间延迟协方差的估计量。仅使用有限样本均值和通过样本均值进行的中心化。然后，仅使用标准线性代数，推导并计算与延迟 $\\tau$ 下最慢去相关的线性模式相关的主导特征值 $\\lambda_{\\text{obs}}$。推导必须严格从 $\\mathbb{R}^d$ 上的协方差矩阵和线性算子的定义开始。如果您构建的任何矩阵由于有限样本效应而不是严格正定的，您必须应用一个极小的岭正则化，该正则化不改变问题的结构（例如，通过添加 $\\epsilon \\mathbf{I}$，其中 $\\epsilon  0$ 是一个小数）。\n\n2. 为了在保持构象边际分布的同时实现时间不相关噪声的原假设，请按如下方式构建一个置换检验。生成 $B$ 个独立的帧索引随机置换，每个置换都是一个双射 $\\pi: \\{0,1,\\dots,T-1\\} \\to \\{0,1,\\dots,T-1\\}$。对于每个置换，重排轨迹以获得一个置换序列 $\\{ \\mathbf{y}_t \\}$，其中 $\\mathbf{y}_t = \\mathbf{x}_{\\pi(t)}$。对于每个置换后的轨迹，使用与步骤1完全相同的过程计算在相同延迟 $\\tau$ 下的主导特征值 $\\lambda^{(b)}$。收集多重集 $\\{ \\lambda^{(b)} \\}_{b=1}^B$，并计算在此原假设下对应于概率水平 $0.95$ 的上分位数阈值。将此阈值表示为 $q_{0.95}$。\n\n3. 通过评估布尔条件 $\\lambda_{\\text{obs}}  q_{0.95}$ 来判断观察到的主导特征值在原假设下是否显著。\n\n您必须在单个程序中实现上述整个流程，并将其应用于以下测试套件。在每个测试用例中，轨迹 $\\{ \\mathbf{x}_t \\}$ 由一个一阶线性高斯自回归模型生成，该模型近似于局部盆地中的近谐波分子动力学：$\\mathbf{x}_{t+1} = \\mathbf{A} \\mathbf{x}_t + \\boldsymbol{\\eta}_t$，其中 $\\boldsymbol{\\eta}_t \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I}_d)$ 是独立同分布的高斯噪声，$\\mathbf{A}$ 是一个谱半径严格小于1的稳定线性算子。构建 $\\mathbf{A}$ 为 $\\mathbf{A} = \\mathbf{Q} \\, \\mathrm{diag}(\\rho_1, \\rho_2, \\dots, \\rho_d) \\, \\mathbf{Q}^\\top$，其中 $\\mathbf{Q}$ 是一个正交矩阵，$\\rho_i \\in (-1,1)$ 是指定的。在收集 $T$ 帧之前，使用至少 $200$ 步的预烧期以达到平稳性。每个测试用例使用固定的随机种子以确保可复现性。模型、估计量和检验必须完全按照描述对每个测试用例执行。\n\n测试套件的参数以元组 $(d, T, \\tau, B, \\sigma, \\rho_{\\text{slow}}, \\rho_{\\text{fast}}, \\text{seed})$ 的形式给出：\n\n- 案例 A（预期可检测到的强慢模式）：$(6, 4000, 10, 128, 0.05, 0.995, 0.4, 12345)$。此处，设置 $\\rho_1 = \\rho_{\\text{slow}}$ 且 $\\rho_2 = \\rho_3 = \\dots = \\rho_6 = \\rho_{\\text{fast}}$。\n- 案例 B（时间上纯粹不相关）：$(6, 4000, 10, 128, 1.0, 0.0, 0.0, 23456)$。\n- 案例 C（弱慢模式，接近原假设行为）：$(6, 4000, 10, 128, 0.1, 0.6, 0.2, 34567)$。\n\n实现要求：\n\n- 仅使用指定的运行时环境和库。\n- 所有计算必须使用浮点运算，并采用一致的中心化约定，该约定完全基于可用数据对的样本均值。\n- 对于每个测试用例，原假设的置换必须在所有 $T!$ 个置换上是独立且均匀随机的；使用给定的种子生成轨迹，并对置换生成器使用确定性派生（例如，种子的固定偏移量）。\n- 对于时间延迟协方差，仅使用样本 $\\{ (\\mathbf{x}_t, \\mathbf{x}_{t+\\tau}) \\}_{t=0}^{T-\\tau-1}$，并对延迟的每一侧使用相应的样本均值。\n- 如果需要确保特征值问题的对称性，您可以用其与转置的平均值，即其对称化版本，来替换任何非对称的时间延迟协方差估计。\n- 对于每个测试用例，返回一个布尔决策，判断观察到的主导特征值是否超过上述的零阈值。\n\n最终输出格式：\n\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的、逗号分隔的布尔值列表（例如，“[True,False,True]”），结果顺序与测试用例 A、B、C 的顺序一致。\n- 此问题不涉及物理单位。",
            "solution": "该问题要求实现一个统计检验，以确定分子轨迹中最慢的集体运动与时间不相关噪声预期的情况相比是否显著。这是通过分析时间延迟相关算子的特征值，并使用置换检验来建立原分布来实现的。该分析建立在时间序列分析和线性代数的原理之上，特别是时间延迟独立成分分析（TICA）或 Koopman 算子分析框架。\n\n轨迹以状态向量序列 $\\{ \\mathbf{x}_t \\}_{t=0}^{T-1}$ 的形式给出，其中 $\\mathbf{x}_t \\in \\mathbb{R}^d$，$T$ 是帧数，$d$ 是自由度数。测试用例的数据由一阶向量自回归（AR(1)）模型生成，该模型可作为连续随机动力学的离散时间近似：\n$$\n\\mathbf{x}_{t+1} = \\mathbf{A} \\mathbf{x}_t + \\boldsymbol{\\eta}_t\n$$\n此处，$\\mathbf{A}$ 是一个稳定的 $d \\times d$ 转移矩阵，$\\boldsymbol{\\eta}_t$ 是一个均值为 $\\mathbf{0}$、协方差为 $\\sigma^2 \\mathbf{I}_d$ 的独立同分布高斯噪声项。矩阵 $\\mathbf{A}$ 的构造方式为 $\\mathbf{A} = \\mathbf{Q} \\, \\text{diag}(\\rho_1, \\dots, \\rho_d) \\, \\mathbf{Q}^\\top$，其中 $\\mathbf{Q}$ 是一个随机正交矩阵，而 $|\\rho_i|  1$ 是定义了潜在过程时间尺度的自相关系数。\n\n核心任务是找到坐标的线性组合 $z_t = \\mathbf{v}^\\top \\mathbf{x}_t$，使其在时间延迟 $\\tau$ 上的去相关速度最慢。慢度由投影序列的自相关来量化，我们的目标是将其最大化。$z_t$ 在延迟 $\\tau$ 的样本自相关通过瑞利商来估计：\n$$\nR_z(\\tau; \\mathbf{v}) = \\frac{\\text{cov}(z_t, z_{t+\\tau})}{\\sqrt{\\text{var}(z_t)\\text{var}(z_{t+\\tau})}} \\approx \\frac{\\mathbf{v}^\\top C_\\tau \\mathbf{v}}{\\mathbf{v}^\\top C_0 \\mathbf{v}}\n$$\n其中 $C_\\tau$ 是样本时间延迟协方差矩阵，$C_0$ 是样本瞬时协方差矩阵。\n\n根据问题规范，我们使用 $N = T-\\tau$ 个可用数据对 $\\{ (\\mathbf{x}_t, \\mathbf{x}_{t+\\tau}) \\}_{t=0}^{N-1}$ 的集合来定义这些估计量。令 $X_0 = \\{ \\mathbf{x}_t \\}_{t=0}^{N-1}$ 和 $X_\\tau = \\{ \\mathbf{x}_{t+\\tau} \\}_{t=0}^{N-1}$。我们计算它们各自的样本均值：\n$$\n\\boldsymbol{\\mu}_0 = \\frac{1}{N} \\sum_{t=0}^{N-1} \\mathbf{x}_t \\quad \\text{and} \\quad \\boldsymbol{\\mu}_\\tau = \\frac{1}{N} \\sum_{t=0}^{N-1} \\mathbf{x}_{t+\\tau}\n$$\n中心化后的数据为 $\\tilde{\\mathbf{x}}_t = \\mathbf{x}_t - \\boldsymbol{\\mu}_0$ 和 $\\tilde{\\mathbf{x}}_{t+\\tau} = \\mathbf{x}_{t+\\tau} - \\boldsymbol{\\mu}_\\tau$。所需的协方差矩阵估计量则为：\n$$\nC_{00} = \\frac{1}{N-1} \\sum_{t=0}^{N-1} \\tilde{\\mathbf{x}}_t \\tilde{\\mathbf{x}}_t^\\top\n\\quad \\text{and} \\quad\nC_{\\tau\\tau} = \\frac{1}{N-1} \\sum_{t=0}^{N-1} \\tilde{\\mathbf{x}}_{t+\\tau} \\tilde{\\mathbf{x}}_{t+\\tau}^\\top\n$$\n瞬时协方差矩阵 $C_0$ 取为平均值，以确保它能稳健地代表过程的方差：\n$$\nC_0 = \\frac{1}{2}(C_{00} + C_{\\tau\\tau})\n$$\n时间延迟协方差矩阵为：\n$$\nC_\\tau = \\frac{1}{N-1} \\sum_{t=0}^{N-1} \\tilde{\\mathbf{x}}_t \\tilde{\\mathbf{x}}_{t+\\tau}^\\top\n$$\n最大化瑞利商 $R_z(\\tau; \\mathbf{v})$ 会导出广义特征值问题 $C_\\tau \\mathbf{v} = \\lambda C_0 \\mathbf{v}$。样本矩阵 $C_\\tau$ 通常不是对称的。为了获得一个具有实特征值的适定问题，我们使用其对称化版本 $C_\\tau^{\\text{sym}} = \\frac{1}{2}(C_\\tau + C_\\tau^\\top)$，这对于满足细致平衡的动力学系统是合理的。该问题于是变为：\n$$\nC_\\tau^{\\text{sym}} \\mathbf{v} = \\lambda C_0 \\mathbf{v}\n$$\n为确保 $C_0$ 可逆，添加一个小的岭正则化项 $\\epsilon \\mathbf{I}_d$（其中 $\\epsilon = 10^{-8}$），使其成为严格正定矩阵。该问题的最大特征值 $\\lambda_{\\text{obs}}$ 是数据中找到的最慢集体模式的自相关。\n\n为了评估 $\\lambda_{\\text{obs}}$ 的统计显著性，我们执行一个置换检验。原假设 $H_0$ 是轨迹帧在时间上不相关。为了在 $H_0$ 下生成数据，我们通过随机打乱原始轨迹的时间索引来创建 $B$ 个置换轨迹 $\\{ \\mathbf{y}_t^{(b)} \\}_{b=1}^B$。对于每个根据构造没有时间相关性但保留了构象边际分布的置换轨迹，我们使用与计算 $\\lambda_{\\text{obs}}$ 完全相同的过程来计算其主导特征值 $\\lambda^{(b)}$。集合 $\\{ \\lambda^{(b)} \\}_{b=1}^B$ 提供了主导特征值在原分布下的经验抽样。然后我们计算该分布的第95百分位数，记为 $q_{0.95}$。如果观察到的运动其关联特征值超过此阈值，则认为该运动具有统计显著性。最终决策是比较 $\\lambda_{\\text{obs}} > q_{0.95}$ 的布尔结果。这整个流程将应用于每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: Strong slow mode\n        {'d': 6, 'T': 4000, 'tau': 10, 'B': 128, 'sigma': 0.05,\n         'rho_slow': 0.995, 'rho_fast': 0.4, 'seed': 12345},\n        # Case B: Uncorrelated noise\n        {'d': 6, 'T': 4000, 'tau': 10, 'B': 128, 'sigma': 1.0,\n         'rho_slow': 0.0, 'rho_fast': 0.0, 'seed': 23456},\n        # Case C: Weak slow mode\n        {'d': 6, 'T': 4000, 'tau': 10, 'B': 128, 'sigma': 0.1,\n         'rho_slow': 0.6, 'rho_fast': 0.2, 'seed': 34567},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        d, T, tau, B, sigma, rho_slow, rho_fast, seed = (\n            case['d'], case['T'], case['tau'], case['B'], case['sigma'],\n            case['rho_slow'], case['rho_fast'], case['seed']\n        )\n        \n        # Consistent epsilon for regularization\n        epsilon = 1e-8\n        \n        # --- Data Generation ---\n        rng = np.random.default_rng(seed)\n        \n        # Generate a random orthonormal matrix Q\n        A_rand = rng.standard_normal(size=(d, d))\n        Q, _ = np.linalg.qr(A_rand)\n        \n        # Define rho vector\n        rhos = np.full(d, rho_fast)\n        rhos[0] = rho_slow\n        \n        # Construct the transition matrix A\n        A = Q @ np.diag(rhos) @ Q.T\n        \n        burn_in = 500\n        total_steps = T + burn_in\n        \n        x_t = np.zeros(d)\n        trajectory_full = np.zeros((total_steps, d))\n        \n        for t in range(total_steps - 1):\n            noise = sigma * rng.standard_normal(d)\n            x_t = A @ x_t + noise\n            trajectory_full[t + 1, :] = x_t\n            \n        trajectory = trajectory_full[burn_in:, :]\n\n        def calculate_leading_eigenvalue(traj, t_lag):\n            \"\"\"\n            Calculates the leading eigenvalue of the TICA generalized eigenproblem.\n            \"\"\"\n            n_frames, n_dims = traj.shape\n            n_pairs = n_frames - t_lag\n            \n            if n_pairs = 1:\n                return 0.0 # Not enough data\n\n            X0 = traj[:-t_lag, :]\n            X_tau = traj[t_lag:, :]\n            \n            mu0 = np.mean(X0, axis=0)\n            mu_tau = np.mean(X_tau, axis=0)\n            \n            X0_c = X0 - mu0\n            X_tau_c = X_tau - mu_tau\n            \n            # Covariance matrices with (N-1) denominator for unbiased estimator\n            C00 = (X0_c.T @ X0_c) / (n_pairs - 1)\n            C_tau_tau = (X_tau_c.T @ X_tau_c) / (n_pairs - 1)\n            \n            C0 = 0.5 * (C00 + C_tau_tau) + epsilon * np.identity(n_dims)\n            \n            C_tau = (X0_c.T @ X_tau_c) / (n_pairs - 1)\n            C_tau_sym = 0.5 * (C_tau + C_tau.T)\n            \n            try:\n                # Solve generalized eigenvalue problem C_tau_sym v = lambda C0 v\n                eigenvalues = linalg.eigh(C_tau_sym, C0, eigvals_only=True)\n                return np.max(eigenvalues)\n            except linalg.LinAlgError:\n                # Fallback for numerical instability\n                return 0.0\n\n        # --- Calculate Observed Eigenvalue ---\n        lambda_obs = calculate_leading_eigenvalue(trajectory, tau)\n        \n        # --- Permutation Test ---\n        null_eigenvalues = np.zeros(B)\n        # Use a deterministic, separate RNG for permutations\n        perm_rng = np.random.default_rng(seed + 1)\n        \n        permuted_trajectory = np.copy(trajectory)\n        for i in range(B):\n            perm_indices = perm_rng.permutation(T)\n            permuted_trajectory = trajectory[perm_indices, :]\n            null_eigenvalues[i] = calculate_leading_eigenvalue(permuted_trajectory, tau)\n            \n        # --- Decision ---\n        q_95 = np.quantile(null_eigenvalues, 0.95)\n        decision = lambda_obs > q_95\n        results.append(decision)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}