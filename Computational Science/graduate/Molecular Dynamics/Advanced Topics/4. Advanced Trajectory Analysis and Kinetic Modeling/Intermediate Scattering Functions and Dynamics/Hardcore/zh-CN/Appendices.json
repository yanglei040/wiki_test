{
    "hands_on_practices": [
        {
            "introduction": "要掌握一个复杂的函数，最好的方法莫过于先从最简单的系统——理想气体——入手进行推导。本练习将引导你通过第一性原理，将自中间散射函数（Self-Intermediate Scattering Function, SISF）的抽象定义与一个具体的解析公式联系起来 。通过这个过程，你将加深对粒子运动（在此为弹道运动）如何转化为ISF函数形式的基础理解。",
            "id": "3418495",
            "problem": "考虑一个三维理想气体，由质量为 $m$ 的相同点状粒子组成，在绝对温度 $T$ 下处于热平衡状态。粒子动力学遵循牛顿定律，且粒子间没有相互作用力。自中间散射函数（Self Intermediate Scattering Function, SISF），记为 $F_s(\\mathbf{k},t)$，从第一性原理定义为由位移产生的复相位的系综平均，该平均针对所有粒子和时间原点进行，即\n$$\nF_s(\\mathbf{k},t) = \\left\\langle \\exp\\left(i\\,\\mathbf{k}\\cdot\\left[\\mathbf{r}(t+\\tau)-\\mathbf{r}(\\tau)\\right]\\right)\\right\\rangle_{\\text{particles},\\,\\tau}.\n$$\n对于各向同性系统，物理可观测量仅取决于模长 $k=\\lVert\\mathbf{k}\\rVert$。在半径为 $k$ 的波矢壳层（$k$-壳层）上的各向同性平均，是在固定 $k$ 的情况下，$F_s(\\mathbf{k},t)$ 在单位球面上所有方向 $\\hat{\\mathbf{k}}=\\mathbf{k}/k$ 上的平均值，这得到了一个各向同性平均的SISF，记为 $\\overline{F_s}(k,t)$。\n\n仅使用上述基本定律和核心定义，以及关于平衡速度统计的已充分验证的事实，编写一个程序来计算所述三维理想气体的各向同性平均SISF $\\overline{F_s}(k,t)$。计算必须从 $F_s(\\mathbf{k},t)$ 的定义出发，并正确实现对 $k$-壳层的各向同性平均。气体处于热平衡状态，因此粒子速度遵循与指定的 $m$ 和 $T$ 一致的麦克斯韦-玻尔兹曼分布。\n\n单位与数值要求：\n- 全程使用国际单位制（SI）。质量 $m$ 的单位为千克（kg），温度 $T$ 的单位为开尔文（K），时间 $t$ 的单位为秒（s），波矢大小 $k$ 的单位为米分之一（$\\text{m}^{-1}$）。\n- 玻尔兹曼常数 $k_B$ 必须取为 $k_B = 1.380649\\times 10^{-23}\\,\\text{J/K}$。\n- SISF $\\overline{F_s}(k,t)$ 是无量纲的。您的程序必须输出四舍五入到六位小数的值。\n\n测试套件：\n为以下四个参数集计算 $\\overline{F_s}(k,t)$：\n1. $m = 39.948\\,\\text{原子质量单位}$ 转换为千克，$T=300\\,\\text{K}$，$t=1.0\\times 10^{-12}\\,\\text{s}$，$k=5.0\\times 10^{9}\\,\\text{m}^{-1}$。\n2. $m = 39.948\\,\\text{原子质量单位}$ 转换为千克，$T=300\\,\\text{K}$，$t=1.0\\times 10^{-12}\\,\\text{s}$，$k=0.0\\,\\text{m}^{-1}$。\n3. $m = 39.948\\,\\text{原子质量单位}$ 转换为千克，$T=300\\,\\text{K}$，$t=0.0\\,\\text{s}$，$k=5.0\\times 10^{9}\\,\\text{m}^{-1}$。\n4. $m = 39.948\\,\\text{原子质量单位}$ 转换为千克，$T=300\\,\\text{K}$，$t=1.0\\times 10^{-9}\\,\\text{s}$，$k=1.0\\times 10^{10}\\,\\text{m}^{-1}$。\n\n原子质量单位必须使用 $1\\,\\text{原子质量单位} = 1.66053906660\\times 10^{-27}\\,\\text{kg}$ 进行转换。\n\n覆盖性设计：\n- 情况1是散射实验中典型的皮秒和亚埃级范围内的通用非平凡场景。\n- 情况2是 $k=0$ 的边界情况，用于探测零波矢下的归一化和各向同性平均。\n- 情况3是 $t=0$ 的边界情况，用于探测零时间下的归一化。\n- 情况4是大时间和大波矢的极限情况，用于探测强退相干行为。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的四个浮点数列表，每个浮点数按上述测试套件的顺序精确到六位小数。例如，输出行必须如下所示\n$$\n[\\text{value}_1,\\text{value}_2,\\text{value}_3,\\text{value}_4].\n$$",
            "solution": "用户要求推导和计算三维理想气体的各向同性平均自中间散射函数（SISF），记为 $\\overline{F_s}(k,t)$。该问题在科学上是有效的，定义明确，并包含了唯一解所需的所有信息。我们按照规定，从第一性原理出发推导 $\\overline{F_s}(k,t)$ 的表达式。\n\nSISF，$F_s(\\mathbf{k},t)$，定义为系综平均：\n$$\nF_s(\\mathbf{k},t) = \\left\\langle \\exp\\left(i\\,\\mathbf{k}\\cdot\\left[\\mathbf{r}(t+\\tau)-\\mathbf{r}(\\tau)\\right]\\right)\\right\\rangle_{\\text{particles},\\,\\tau}\n$$\n其中 $\\mathbf{r}(t)$ 是粒子在时间 $t$ 的位置，$\\mathbf{k}$ 是波矢，平均是对所有粒子和时间原点 $\\tau$ 进行的。\n\n对于理想气体，不存在粒子间作用力。根据牛顿第一定律，每个粒子都以恒定速度 $\\mathbf{v}$ 运动。粒子的轨迹由 $\\mathbf{r}(t) = \\mathbf{r}(0) + \\mathbf{v}t$ 给出。因此，粒子在时间间隔 $t$ 内的位移为：\n$$\n\\Delta\\mathbf{r}(t) = \\mathbf{r}(t+\\tau) - \\mathbf{r}(\\tau) = \\left(\\mathbf{r}(\\tau) + \\mathbf{v}t\\right) - \\mathbf{r}(\\tau) = \\mathbf{v}t\n$$\n该位移与初始位置 $\\mathbf{r}(\\tau)$ 和时间原点 $\\tau$ 无关。将其代入 $F_s(\\mathbf{k},t)$ 的定义，对 $\\tau$ 的平均变得无关紧要，表达式简化为：\n$$\nF_s(\\mathbf{k},t) = \\left\\langle \\exp\\left(i\\,\\mathbf{k}\\cdot(\\mathbf{v}t)\\right)\\right\\rangle_{\\text{particles}}\n$$\n对于处于热平衡的系统，对粒子的系综平均等同于对粒子速度分布的平均。设 $P(\\mathbf{v})$ 为速度概率分布函数。则SISF由以下积分给出：\n$$\nF_s(\\mathbf{k},t) = \\int \\exp\\left(i\\,t\\,\\mathbf{k}\\cdot\\mathbf{v}\\right) P(\\mathbf{v}) \\, d^3\\mathbf{v}\n$$\n该系统是在绝对温度 $T$ 下的理想气体。粒子速度遵循三维麦克斯韦-玻尔兹曼分布：\n$$\nP(\\mathbf{v}) = \\left(\\frac{m}{2\\pi k_B T}\\right)^{3/2} \\exp\\left(-\\frac{m |\\mathbf{v}|^2}{2 k_B T}\\right)\n$$\n其中 $m$ 是粒子质量，$k_B$ 是玻尔兹曼常数。$P(\\mathbf{v})$ 是三个独立的高斯分布的乘积，分别对应于速度分量 $v_x$、$v_y$ 和 $v_z$：\n$$\nP(\\mathbf{v}) = P_1(v_x) P_1(v_y) P_1(v_z) \\quad \\text{with} \\quad P_1(v_j) = \\left(\\frac{m}{2\\pi k_B T}\\right)^{1/2} \\exp\\left(-\\frac{m v_j^2}{2 k_B T}\\right)\n$$\n指数中的点积为 $\\mathbf{k}\\cdot\\mathbf{v} = k_x v_x + k_y v_y + k_z v_z$。$F_s(\\mathbf{k},t)$ 的积分可以分解为三个一维积分的乘积：\n$$\nF_s(\\mathbf{k},t) = \\left(\\int_{-\\infty}^{\\infty} e^{i t k_x v_x} P_1(v_x) dv_x\\right) \\left(\\int_{-\\infty}^{\\infty} e^{i t k_y v_y} P_1(v_y) dv_y\\right) \\left(\\int_{-\\infty}^{\\infty} e^{i t k_z v_z} P_1(v_z) dv_z\\right)\n$$\n每个积分都是一个高斯函数的傅里叶变换。让我们对一个通用分量 $j \\in \\{x, y, z\\}$ 计算这样一个积分：\n$$\nI_j = \\int_{-\\infty}^{\\infty} \\exp(i t k_j v_j) \\left(\\frac{m}{2\\pi k_B T}\\right)^{1/2} \\exp\\left(-\\frac{m v_j^2}{2 k_B T}\\right) dv_j\n$$\n这是一个标准的高斯积分，形式为 $\\int_{-\\infty}^{\\infty} e^{-ax^2+bx} dx = \\sqrt{\\pi/a} e^{b^2/(4a)}$。此处，$a = \\frac{m}{2k_B T}$ 且 $b = i t k_j$。该积分的计算结果为：\n$$\nI_j = \\left(\\frac{m}{2\\pi k_B T}\\right)^{1/2} \\sqrt{\\frac{2\\pi k_B T}{m}} \\exp\\left(\\frac{(i t k_j)^2}{4(m / (2 k_B T))}\\right) = \\exp\\left(-\\frac{t^2 k_j^2 k_B T}{2m}\\right)\n$$\n将三个分量（$j=x,y,z$）的结果相乘：\n$$\nF_s(\\mathbf{k},t) = \\exp\\left(-\\frac{t^2 k_x^2 k_B T}{2m}\\right) \\exp\\left(-\\frac{t^2 k_y^2 k_B T}{2m}\\right) \\exp\\left(-\\frac{t^2 k_z^2 k_B T}{2m}\\right)\n$$\n$$\nF_s(\\mathbf{k},t) = \\exp\\left(-\\frac{(k_x^2+k_y^2+k_z^2) k_B T}{2m} t^2\\right) = \\exp\\left(-\\frac{k^2 k_B T}{2m} t^2\\right)\n$$\n其中 $k = \\lVert\\mathbf{k}\\rVert = \\sqrt{k_x^2+k_y^2+k_z^2}$。这个结果表明，对于理想气体，$F_s(\\mathbf{k},t)$ 仅取决于波矢的模长 $k$，而与其方向无关。该函数本身就是各向同性的。\n\n各向同性平均SISF，$\\overline{F_s}(k,t)$，定义为在固定模长 $k$ 的情况下，$F_s(\\mathbf{k},t)$ 在 $\\mathbf{k}$ 的所有方向上的平均值。由于 $F_s(\\mathbf{k},t)$ 不依赖于 $\\mathbf{k}$ 的方向，对其在所有方向上进行平均不会改变其值。\n$$\n\\overline{F_s}(k,t) = \\frac{1}{4\\pi} \\int_{\\text{unit sphere}} F_s(\\mathbf{k},t) \\, d\\Omega = \\frac{1}{4\\pi} \\int_{\\text{unit sphere}} \\exp\\left(-\\frac{k^2 k_B T}{2m} t^2\\right) \\, d\\Omega\n$$\n被积函数在积分球面上是常数，因此可以提取出来：\n$$\n\\overline{F_s}(k,t) = \\exp\\left(-\\frac{k^2 k_B T}{2m} t^2\\right) \\left(\\frac{1}{4\\pi} \\int d\\Omega\\right) = \\exp\\left(-\\frac{k^2 k_B T}{2m} t^2\\right) \\left(\\frac{4\\pi}{4\\pi}\\right)\n$$\n因此，三维理想气体的各向同性平均SISF的最终表达式为：\n$$\n\\overline{F_s}(k,t) = \\exp\\left(-\\frac{k^2 t^2 k_B T}{2m}\\right)\n$$\n这是一个在 $k$ 和 $t$ 上都呈高斯衰减的函数。此公式将被用于计算指定测试用例的值。参数 $m$、$T$、$k$、$t$ 和常数 $k_B$ 均已给出。质量 $m$ 以原子质量单位（u）提供，必须使用给定的转换因子转换为千克（kg）。\n\n该解析表达式自然地处理了边界情况。当 $t=0$ 时，指数的参数为 $0$，因此 $\\overline{F_s}(k,0) = e^0 = 1$，这是正确的归一化条件，反映了在零时间位移为零。当 $k=0$ 时，参数也为 $0$，因此 $\\overline{F_s}(0,t) = 1$，这对应于探测无限大长度尺度，在该尺度下有限的粒子位移没有影响。在 $k$ 或 $t$ 很大的极限下，函数衰减到 $0$，表示完全退相干。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates the problem, derives the formula for the isotropically averaged\n    Self Intermediate Scattering Function (SISF) for an ideal gas, and\n    computes it for a given set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (mass in u, temperature in K, time in s, wavevector magnitude in m^-1)\n    test_cases = [\n        (39.948, 300.0, 1.0e-12, 5.0e9),\n        (39.948, 300.0, 1.0e-12, 0.0),\n        (39.948, 300.0, 0.0, 5.0e9),\n        (39.948, 300.0, 1.0e-9, 1.0e10),\n    ]\n\n    results = []\n    for case in test_cases:\n        m_u, T, t, k = case\n        result = compute_sisf(m_u, T, t, k)\n        results.append(result)\n\n    # Format the final output string as a comma-separated list of floats\n    # enclosed in square brackets, with each value rounded to six decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_sisf(m_u: float, T: float, t: float, k: float) -> float:\n    \"\"\"\n    Computes the isotropically averaged Self Intermediate Scattering Function\n    for a 3D ideal gas.\n\n    The formula is: F_s(k, t) = exp(-(k^2 * t^2 * k_B * T) / (2 * m))\n\n    Args:\n        m_u (float): Mass of the particle in atomic mass units (u).\n        T (float): Absolute temperature in Kelvin (K).\n        t (float): Time in seconds (s).\n        k (float): Wavevector magnitude in inverse meters (m^-1).\n\n    Returns:\n        float: The dimensionless value of the SISF.\n    \"\"\"\n    # Physical constants in SI units\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n    amu_to_kg = 1.66053906660e-27  # Conversion factor from u to kg\n\n    # Convert mass from atomic mass units to kilograms\n    m_kg = m_u * amu_to_kg\n\n    # The formula is well-behaved for t=0 or k=0, both leading to an exponent of 0.\n    # Explicitly checking for these boundary conditions is good practice but not\n    # strictly necessary for the correctness of this specific formula.\n    if t == 0.0 or k == 0.0:\n        return 1.0\n\n    # Calculate the argument of the exponential function.\n    # The expression is rearranged for numerical stability, although for the given\n    # parameters, a direct calculation would also be safe.\n    exponent = - (k**2 * t**2 * k_B * T) / (2.0 * m_kg)\n\n    # The exponential of a very large negative number will correctly underflow to 0.0\n    sisf_value = np.exp(exponent)\n    \n    return sisf_value\n\n# Execute the main function\nsolve()\n\n```"
        },
        {
            "introduction": "在推导出解析公式之后，我们将转向一种在真实模拟中更为通用和实际的方法：从粒子轨迹数据中计算中间散射函数（Intermediate Scattering Function, ISF）。本练习将介绍该任务的主力算法，它利用维纳-辛钦定理（Wiener–Khinchin theorem）和快速傅里叶变换（Fast Fourier Transform, FFT）来高效地计算时间自相关函数 。通过生成模拟轨迹并应用此方法，你将学习到从数据中提取相关函数的基本分析流程。",
            "id": "3418516",
            "problem": "您的任务是设计并实现一种高效的算法，利用快速傅里叶变换（FFT）从离散的分子动力学（MD）轨迹中计算相干中间散射函数。相干中间散射函数量化了在指定波矢下密度涨落的时间相关性，是将微观动力学与散射可观测量联系起来的核心物理量。\n\n从以下基本原理开始：\n\n- 微观数密度定义为 $$\\rho(\\mathbf{r},t) = \\sum_{j=1}^{N} \\delta\\!\\left(\\mathbf{r} - \\mathbf{r}_j(t)\\right),$$ 其中 $N$ 是粒子数，$\\mathbf{r}_j(t)$ 是粒子 $j$ 在时间 $t$ 的位置。\n\n- 波矢为 $\\mathbf{k}$ 时的密度模式定义为 $$\\rho_{\\mathbf{k}}(t) = \\sum_{j=1}^{N} \\exp\\!\\left(i \\mathbf{k}\\cdot\\mathbf{r}_j(t)\\right).$$\n\n- 相干中间散射函数定义为 $$F(\\mathbf{k},t) = \\frac{1}{N} \\left\\langle \\rho_{\\mathbf{k}}(t_0+t)\\,\\rho_{\\mathbf{k}}(t_0)^{\\ast} \\right\\rangle_{t_0},$$ 其中 $\\langle\\cdot\\rangle_{t_0}$ 表示对时间起点 $t_0$ 的平均，${}^{\\ast}$ 表示复共轭。对于一个平稳过程，这是复数时间序列 $\\rho_{\\mathbf{k}}(t)$ 的时间自相关函数。\n\n- 对于经历独立布朗运动的理想气体，每个粒子的位移分量在每个笛卡尔轴上都是一个均值为零、方差为 $2 D t$ 的高斯随机变量（其中 $D$ 是扩散系数，单位为 $\\mathrm{m}^2/\\mathrm{s}$）。在这种情况下，对于任何非零波矢大小 $k = \\|\\mathbf{k}\\|$，理论上预期的相干中间散射函数等于自中间散射函数，即 $$F(\\mathbf{k},t) = \\exp\\!\\left(-D k^2 t\\right) \\quad \\text{for } k > 0.$$ 对于 $k=0$ 的特殊情况，有 $$\\rho_{\\mathbf{0}}(t) = N \\quad \\Rightarrow \\quad F(\\mathbf{0},t) = \\frac{1}{N} \\langle N \\cdot N \\rangle = N.$$\n\n您的目标是：\n\n1. 实现一种高效算法，利用离散维纳-辛钦定理和快速傅里叶变换（FFT），从离散时间序列 $\\{\\rho_{\\mathbf{k}}(n \\Delta t)\\}_{n=0}^{T-1}$ 计算 $F(\\mathbf{k},t)$。对于一个有限离散时间序列 $r_n = \\rho_{\\mathbf{k}}(n \\Delta t)$，其中 $n \\in \\{0,1,\\dots,T-1\\}$，定义线性自相关\n$$C_m = \\sum_{n=0}^{T-1-m} r_{n+m}\\,r_n^{\\ast}, \\quad m \\in \\{0,1,\\dots,T-1\\}.$$\n展示如何通过补零和FFT计算 $\\{C_m\\}$，以避免循环卷积。然后得到\n$$F(\\mathbf{k},m \\Delta t) = \\frac{1}{N}\\,\\frac{C_m}{T-m}$$\n作为无偏的时间起点平均相干中间散射函数。\n\n2. 为经历三维独立布朗运动的粒子生成合成的MD轨迹。使用边长为 $L$ 的立方体域，初始粒子位置从 $[0,L]^3$ 中独立同分布地均匀采样，以确保随机的初始相位。在每个离散时间步 $\\Delta t$，通过沿每个轴添加均值为零、标准差为 $\\sqrt{2 D \\Delta t}$ 的独立高斯增量来更新位置。使用一个固定的、与 $x$ 轴对齐的波矢 $\\mathbf{k}$，其大小为 $k$（方向的选择是任意的，但必须固定）。\n\n3. 对于每个测试用例，使用您基于FFT的算法计算 $F(\\mathbf{k},t)$，并与理论期望值进行比较：\n   - 如果 $k > 0$，与 $$F_{\\mathrm{theory}}(t) = \\exp\\!\\left(-D k^2 t\\right)$$ 进行比较。\n   - 如果 $k = 0$，与 $$F_{\\mathrm{theory}}(t) = N$$ 进行比较。\n   计算在 $F_{\\mathrm{theory}}(m \\Delta t) \\geq \\theta$ 的延迟 $m$ 上的最大相对误差（$\\theta$ 是一个阈值，以避免在期望值极小时出现数值不稳定性）。对于 $k=0$，使用所有延迟，因为 $F_{\\mathrm{theory}}$ 是常数。使用相对误差定义\n   $$\\varepsilon_m = \\frac{\\left|F(\\mathbf{k},m \\Delta t) - F_{\\mathrm{theory}}(m \\Delta t)\\right|}{\\left|F_{\\mathrm{theory}}(m \\Delta t)\\right|}.$$\n\n4. 对于每个测试用例，返回一个布尔值，指示在规定的延迟范围内的最大相对误差是否严格小于指定的容差。\n\n科学真实性和单位：\n\n- 位置必须以米（$\\mathrm{m}$）为单位。\n- 时间必须以秒（$\\mathrm{s}$）为单位。\n- 扩散系数 $D$ 必须以平方米/秒（$\\mathrm{m}^2/\\mathrm{s}$）为单位。\n- 波矢大小 $k$ 必须以米分之一（$\\mathrm{m}^{-1}$）为单位。\n\n测试套件：\n\n实现您的程序以评估以下三个测试用例。请精确使用给定的参数，并将 $L$ 视为初始均匀位置分布的边长。为保证可复现性，每个测试用例使用一个固定的伪随机种子。在所有情况下，波矢为 $\\mathbf{k} = (k,0,0)$。\n\n- 测试用例 1（一般情况，非零波矢）：\n  - $N = 1024$\n  - $T = 2048$\n  - $\\Delta t = 1\\times 10^{-12}\\ \\mathrm{s}$\n  - $D = 2\\times 10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$\n  - $k = 2\\times 10^{9}\\ \\mathrm{m}^{-1}$\n  - $L = 1\\times 10^{-6}\\ \\mathrm{m}$\n  - 阈值 $\\theta = 1\\times 10^{-3}$ (无量纲)\n  - 容差 $= 2\\times 10^{-1}$ (无量纲)\n  - 种子 $= 123$\n\n- 测试用例 2（边界情况，零波矢）：\n  - $N = 512$\n  - $T = 1024$\n  - $\\Delta t = 1\\times 10^{-12}\\ \\mathrm{s}$\n  - $D = 1\\times 10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$\n  - $k = 0$\n  - $L = 1\\times 10^{-6}\\ \\mathrm{m}$\n  - 阈值 $\\theta = 0$ (无量纲)\n  - 容差 $= 1\\times 10^{-10}$ (无量纲)\n  - 种子 $= 456$\n\n- 测试用例 3（小样本量和中等波矢）：\n  - $N = 256$\n  - $T = 512$\n  - $\\Delta t = 5\\times 10^{-12}\\ \\mathrm{s}$\n  - $D = 1\\times 10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$\n  - $k = 1\\times 10^{9}\\ \\mathrm{m}^{-1}$\n  - $L = 1\\times 10^{-6}\\ \\mathrm{m}$\n  - 阈值 $\\theta = 1\\times 10^{-3}$ (无量纲)\n  - 容差 $= 3\\times 10^{-1}$ (无量纲)\n  - 种子 $= 789$\n\n最终输出格式规范：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$$[r_1,r_2,r_3]$$），其中每个 $r_i$ 是一个布尔值，指示相应的测试用例是否满足其容差标准。不允许有其他输出。",
            "solution": "该问题被评估为有效。它在科学上基于统计力学和信号处理的原理，问题阐述清晰，目标明确，数据充分，语言客观。因此，我们可以着手解决。\n\n任务是从模拟的分子动力学轨迹中计算相干中间散射函数 $F(\\mathbf{k},t)$，并根据已知的理论模型验证结果。整个过程包括三个主要阶段：首先，为经历独立布朗运动的粒子生成合成轨迹；其次，计算集体密度模式 $\\rho_{\\mathbf{k}}(t)$ 的时间序列；第三，使用高效的基于快速傅里叶变换（FFT）的方法计算该序列的时间自相关，以获得 $F(\\mathbf{k},t)$。\n\n**1. 布朗运动轨迹的生成**\n\n物理模型是三维空间中由 $N$ 个无相互作用粒子组成的理想气体。每个粒子 $j$ 的动力学是独立的，并由布朗运动支配。粒子 $j$ 在时间 $t$ 的位置用 $\\mathbf{r}_j(t)$ 表示。模拟从时间 $t=0$ 开始，进行 $T$ 个离散时间步，步长为 $\\Delta t$。\n\n初始位置 $\\{\\mathbf{r}_j(0)\\}_{j=1}^N$ 从边长为 $L$ 的立方体体积内的独立同均匀分布中抽取。也就是说，对于每个粒子 $j$，其初始坐标 $(x_j(0), y_j(0), z_j(0))$ 从 $U(0, L)$ 中采样。这种初始位置的随机化确保了在密度模式计算中初始相位的去相关性。\n\n轨迹通过布朗运动的离散时间更新规则进行传播。粒子在时间间隔 $\\Delta t$ 内的位移是一个随机向量，其笛卡尔分量是独立的、均值为 $0$、方差为 $2D\\Delta t$ 的高斯随机变量，其中 $D$ 是扩散系数。因此，第 $n+1$ 步的位置由第 $n$ 步的位置更新得到：\n$$ \\mathbf{r}_j((n+1)\\Delta t) = \\mathbf{r}_j(n\\Delta t) + \\Delta\\mathbf{r}_j(n) $$\n其中位移向量 $\\Delta\\mathbf{r}_j(n)$ 的每个分量都从标准差为 $\\sigma = \\sqrt{2D\\Delta t}$ 的正态分布 $\\mathcal{N}(0, \\sigma^2)$ 中抽取。\n\n**2. 密度模式时间序列的计算**\n\n相干中间散射函数是密度模式 $\\rho_{\\mathbf{k}}(t)$ 的自相关，定义为：\n$$ \\rho_{\\mathbf{k}}(t) = \\sum_{j=1}^{N} \\exp\\!\\left(i \\mathbf{k}\\cdot\\mathbf{r}_j(t)\\right) $$\n对于我们生成的离散轨迹 $\\{\\mathbf{r}_j(n\\Delta t)\\}$，我们计算一个离散的复数值时间序列 $r_n = \\rho_{\\mathbf{k}}(n\\Delta t)$，其中 $n \\in \\{0, 1, \\dots, T-1\\}$。问题指定了一个与 $x$ 轴对齐的波矢 $\\mathbf{k} = (k, 0, 0)$。点积简化为 $\\mathbf{k}\\cdot\\mathbf{r}_j(t) = k\\,x_j(t)$，其中 $x_j(t)$ 是粒子 $j$ 位置的 $x$ 分量。因此，时间序列为：\n$$ r_n = \\rho_{\\mathbf{k}}(n\\Delta t) = \\sum_{j=1}^{N} \\exp\\!\\left(i k\\,x_j(n\\Delta t)\\right) $$\n\n**3. 基于FFT的自相关计算（维纳-辛钦定理）**\n\n问题要求计算时间序列 $\\{r_n\\}_{n=0}^{T-1}$ 的线性自相关，定义为：\n$$ C_m = \\sum_{n=0}^{T-1-m} r_{n+m}\\,r_n^{\\ast}, \\quad m \\in \\{0, 1, \\dots, T-1\\} $$\n对所有 $m$直接计算这个和将是一个 $\\mathcal{O}(T^2)$ 的操作。一种更高效的 $\\mathcal{O}(T\\log T)$ 方法是使用维纳-辛钦定理，该定理通过傅里叶变换将自相关函数与功率谱密度联系起来。对于离散信号，必须注意计算的是*线性*自相关，而不是由离散傅里叶变换（DFT）的周期性引起的*循环*自相关。\n\n正确的步骤包括对信号进行补零：\n1.  设原始时间序列为 $r = \\{r_0, r_1, \\dots, r_{T-1}\\}$。\n2.  通过对 $r$ 补零，创建一个长度为 $M$ 的新信号 $r'$。为确保结果是线性相关，补零后的长度 $M$ 必须至少为 $2T-1$。为了FFT算法的计算效率，$M$ 通常被选为下一个更高的2的幂，或更一般地，一个“平滑”数（高度合成数）。我们将选择 $M$ 使得 $M \\ge 2T-1$。\n3.  计算补零信号的DFT：$R' = \\mathcal{F}(r')$。\n4.  通过取 $R'$ 每个分量的模的平方来计算功率谱密度（PSD）：$S_k = |R'_k|^2 = R'_k \\cdot (R'_k)^{\\ast}$。\n5.  计算PSD的逆DFT：$C' = \\mathcal{F}^{-1}(S)$。\n所得序列 $C'$ 的前 $T$ 个元素就是所求的线性自相关值 $\\{C_m\\}_{m=0}^{T-1}$。\n\n**4. 最终计算与误差分析**\n\n根据计算出的自相关和 $\\{C_m\\}$，对每个延迟时间 $m\\Delta t$ 计算相干中间散射函数的无偏估计量：\n$$ F(\\mathbf{k}, m\\Delta t) = \\frac{1}{N} \\frac{C_m}{T-m} $$\n然后将此计算函数与理想布朗粒子气体的理论期望值进行比较。\n-   对于非零波矢大小 $k > 0$，理论函数是一个指数衰减：\n    $$ F_{\\mathrm{theory}}(t) = \\exp(-Dk^2t) $$\n-   对于特殊情况 $k=0$，点积 $\\mathbf{k}\\cdot\\mathbf{r}_j(t)$ 始终为 $0$，所以 $\\rho_{\\mathbf{0}}(t) = \\sum_j e^0 = N$。函数变为常数：\n    $$ F_{\\mathrm{theory}}(t) = \\frac{1}{N}\\langle N \\cdot N^{\\ast} \\rangle = N $$\n\n在每个延迟 $m$ 处计算相对误差 $\\varepsilon_m$：\n$$ \\varepsilon_m = \\frac{|F(\\mathbf{k}, m\\Delta t) - F_{\\mathrm{theory}}(m\\Delta t)|}{|F_{\\mathrm{theory}}(m\\Delta t)|} $$\n然后在一个相关的延迟范围内找到最大相对误差。对于 $k>0$，该范围包括所有理论函数值未衰减到阈值 $\\theta$ 以下的延迟 $m$，即 $F_{\\mathrm{theory}}(m\\Delta t) \\ge \\theta$。这避免了因除以非常小的数而引起的数值不稳定性。对于 $k=0$，$F_{\\mathrm{theory}}$ 是一个大的常数，所以使用所有延迟。最后，将此最大相对误差与指定的容差进行比较，以确定每个测试用例的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, ifft, next_fast_len\n\ndef run_test_case(N, T, dt, D, k, L, theta, tolerance, seed):\n    \"\"\"\n    Runs a single test case for computing the coherent intermediate scattering function.\n    \n    Args:\n        N (int): Number of particles.\n        T (int): Number of time steps.\n        dt (float): Time step duration in seconds.\n        D (float): Diffusion coefficient in m^2/s.\n        k (float): Wavevector magnitude in 1/m.\n        L (float): Side length of the initial distribution box in meters.\n        theta (float): Threshold for theoretical F(k,t) to consider in error analysis.\n        tolerance (float): Tolerance for maximum relative error.\n        seed (int): Seed for the pseudorandom number generator.\n        \n    Returns:\n        bool: True if the max relative error is less than the tolerance, False otherwise.\n    \"\"\"\n    # 1. Set seed for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # 2. Generate trajectory for independent Brownian motion\n    positions = np.zeros((T, N, 3))\n    # Initial positions are uniformly distributed in a cube of side L\n    positions[0, :, :] = rng.uniform(0, L, size=(N, 3))\n    \n    # Propagate positions using Gaussian increments\n    std_dev = np.sqrt(2 * D * dt)\n    for t_idx in range(T - 1):\n        displacements = rng.normal(0, std_dev, size=(N, 3))\n        positions[t_idx + 1] = positions[t_idx] + displacements\n        # For an ideal gas model, no periodic boundary conditions are applied.\n\n    # 3. Compute the density mode time series, rho_k(t)\n    # The wavevector is k_vec = (k, 0, 0), so k.r = k * x-position.\n    if k == 0:\n        # For k=0, exp(i*0) = 1, so rho_k(t) is a constant sum of 1s, which is N.\n        rho_k_t = np.full(T, float(N), dtype=np.complex128)\n    else:\n        # General case: rho_k(t) = sum_j exp(i * k * r_j_x(t))\n        # Vectorized calculation over all time steps and particles.\n        k_dot_r = k * positions[:, :, 0]  # Shape (T, N)\n        rho_k_t = np.sum(np.exp(1j * k_dot_r), axis=1)  # Shape (T,)\n\n    # 4. Compute the linear autocorrelation using the Wiener-Khinchin theorem via FFT\n    # Pad the signal to a length >= 2*T - 1 to avoid circular convolution effects.\n    # next_fast_len finds an efficient length for FFT.\n    n_padded = next_fast_len(2 * T - 1)\n    \n    # FFT of the zero-padded signal\n    rho_k_fft = fft(rho_k_t, n=n_padded)\n    \n    # Power spectral density is the squared magnitude of the FFT\n    psd = np.abs(rho_k_fft)**2\n    \n    # Inverse FFT of the PSD gives the autocorrelation function\n    autocorr_raw = ifft(psd)\n    \n    # The first T elements of the result correspond to the desired linear autocorrelation C_m.\n    # The result should be real; the imaginary part is numerical noise.\n    C_m = np.real(autocorr_raw[:T])\n\n    # 5. Compute the unbiased estimator for F(k,t)\n    # F(k, m*dt) = (1/N) * C_m / (T - m)\n    # The denominator (T-m) is the number of samples for each lag m.\n    denominators = np.arange(T, 0, -1)\n    F_computed = (1 / N) * (C_m / denominators)\n\n    # 6. Compute the theoretical F(k,t) for comparison\n    times = np.arange(T) * dt\n    if k > 0:\n        F_theory = np.exp(-D * k**2 * times)\n    else:  # k == 0\n        F_theory = np.full(T, float(N))\n        \n    # 7. Compute relative error and check against tolerance\n    # The denominator np.abs(F_theory) is always positive here.\n    relative_error = np.abs(F_computed - F_theory) / np.abs(F_theory)\n\n    # Select the lags over which to evaluate the error based on the threshold theta.\n    if k > 0:\n        # For k>0, consider only lags where the theoretical value is significant.\n        valid_indices = np.where(F_theory >= theta)[0]\n        # If the function decays so fast that no points are above threshold,\n        # we can default to checking lag 0, which is always 1.0.\n        if len(valid_indices) == 0:\n            valid_indices = [0]\n    else: # k == 0\n        # For k=0, the theoretical value is constant, so all lags are used.\n        valid_indices = np.arange(T)\n        \n    max_rel_error = np.max(relative_error[valid_indices])\n\n    return max_rel_error  tolerance\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1: General case, nonzero wavevector\n        {'N': 1024, 'T': 2048, 'dt': 1e-12, 'D': 2e-9, 'k': 2e9, 'L': 1e-6, \n         'theta': 1e-3, 'tolerance': 2e-1, 'seed': 123},\n        # Test case 2: Boundary case, zero wavevector\n        {'N': 512, 'T': 1024, 'dt': 1e-12, 'D': 1e-9, 'k': 0, 'L': 1e-6, \n         'theta': 0, 'tolerance': 1e-10, 'seed': 456},\n        # Test case 3: Small sample size and moderate wavevector\n        {'N': 256, 'T': 512, 'dt': 5e-12, 'D': 1e-9, 'k': 1e9, 'L': 1e-6, \n         'theta': 1e-3, 'tolerance': 3e-1, 'seed': 789},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(**case)\n        results.append(result)\n\n    # Format the final output as a single line: [True,True,False]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "掌握了计算ISF的方法后，我们现在可以将其用于更高级的分析，例如检验基本的物理定律。本练习将指导你数值验证f-求和规则（f-sum rule），这是一条揭示动力学和静态特性之间深刻联系的准则 。更重要的是，这个练习旨在揭示常见的数值计算陷阱，从而教会你批判性地审视计算数据，并理解离散化选择如何影响物理结论。",
            "id": "3418532",
            "problem": "考虑一个处于热平衡状态的经典单原子流体，通过弹性密度涨落对其进行探测。令中间散射函数 (ISF) 定义为 $F(\\mathbf{q}, t) = N^{-1} \\langle \\rho(\\mathbf{q}, t)\\rho(-\\mathbf{q}, 0) \\rangle$，其中 $\\rho(\\mathbf{q}, t)$ 是微观数密度的空间傅里叶模式，$\\mathbf{q}$ 是波矢，其大小为 $q = \\|\\mathbf{q}\\|$，$\\langle \\cdot \\rangle$ 表示系综平均。通过傅里叶变换定义动态结构因子 $S(\\mathbf{q}, \\omega) = (2\\pi)^{-1} \\int_{-\\infty}^{\\infty} \\mathrm{d}t\\, e^{i \\omega t} F(\\mathbf{q}, t)$，并通过 $S(\\mathbf{q}) = F(\\mathbf{q}, 0)$ 定义静态结构因子。经典的 $f$-求和规则断言了 $S(\\mathbf{q}, \\omega)$ 的二阶频率矩与热速度标度之间存在一种关系。\n\n您的任务是使用合成的分子动力学 (MD) 时间序列来实施对 $f$-求和规则的测试，该时间序列精确地体现了具有 Maxwell–Boltzmann 速度的理想气体弹道动力学。在这种理想单原子情况下，可以根据温度 $T$ 和质量 $m$ 下的 Newtonian 运动学和 Maxwell–Boltzmann 统计来构建 $F(q, t)$；然后通过傅里叶变换得到 $S(q, \\omega)$。基于这些，通过对时间采样的 $F(q, t)$ 进行离散傅里叶变换得到的频率网格，使用离散求积法数值近似 $\\int_{-\\infty}^{\\infty} \\omega^{2} S(q, \\omega)\\, \\mathrm{d}\\omega$。将数值估计的左侧与右侧 $(q^{2} k_{\\mathrm{B}} T/m)\\, S(q)$ 进行比较，其中 $k_{\\mathrm{B}}$ 是 Boltzmann 常数。报告在指定离散化设置下的相对误差，并在您的解题思路中讨论数值离散化在何种条件下会违反 $f$-求和规则。\n\n仅使用以下基础且经过充分检验的出发点：无相互作用粒子的 Newtonian 运动学、处于平衡态的单原子理想气体的 Maxwell–Boltzmann 速度分布、上面给出的中间散射函数和动态结构因子的定义，以及傅里叶变换的标准性质。除了 $f$-求和规则的陈述本身，不要假设任何关于它的结果；相反，应将其与这些定义联系起来。\n\n全程使用的物理和数值单位及约定：\n- 使用 $q$ 单位为米倒数 ($\\mathrm{m}^{-1}$)，$t$ 单位为秒 ($\\mathrm{s}$)，角频率 $\\omega$ 单位为弧度每秒 ($\\mathrm{rad}\\,\\mathrm{s}^{-1}$)，质量 $m$ 单位为千克 ($\\mathrm{kg}$)，温度 $T$ 单位为开尔文 ($\\mathrm{K}$)，$k_{\\mathrm{B}}$ 单位为焦耳每开尔文 ($\\mathrm{J}\\,\\mathrm{K}^{-1}$)。\n- 傅里叶变换约定为 $S(q,\\omega) = (2\\pi)^{-1} \\int_{-\\infty}^{\\infty} \\mathrm{d}t\\, e^{i \\omega t} F(q,t)$。\n- 静态结构因子为 $S(q) = F(q,0)$。\n\n数值测试的算法规范：\n- 使用 Newtonian 运动学和 Maxwell–Boltzmann 统计，为处于平衡态、温度为 $T$、粒子质量为 $m$ 且给定波矢大小为 $q$ 的理想单原子气体合成 $F(q,t)$。然后，在时间网格 $t_{n} = (n - N/2)\\,\\Delta t$上对 $F(q,t)$ 进行均匀采样（$n = 0, 1, \\ldots, N-1$），应用选定的窗函数 $w_{n}$ 获得采样数据 $G_{n} = F(q,t_{n})\\, w_{n}$，并计算离散傅里叶变换，以在均匀角频率网格 $\\omega_{k}$ 上获得 $S(q,\\omega)$ 的数值近似，记为 $\\widehat{S}(q,\\omega_{k})$。\n- 使用离散求积 $\\sum_{k} \\omega_{k}^{2}\\, \\widehat{S}(q,\\omega_{k})\\, \\Delta \\omega$ 来近似 $\\int \\omega^{2} S(q,\\omega)\\, \\mathrm{d}\\omega$，其中 $\\Delta \\omega$ 是由离散傅里叶变换所隐含的均匀角频率间隔。确保缩放比例与上面给出的 $S(q,\\omega)$ 定义以及所使用的网格间距一致。\n- 使用 $S(q)=F(q,0)$，将此数值左侧与右侧 $(q^{2} k_{\\mathrm{B}} T/m) S(q)$ 进行比较，并报告相对误差 $(\\mathrm{LHS} - \\mathrm{RHS})/\\mathrm{RHS}$。\n\n测试套件：\n使用以下四个测试用例，它们具有固定的物理参数和变化的离散化设置。对于所有用例，使用 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\,\\mathrm{J}\\,\\mathrm{K}^{-1}$，$m = 39.948\\times 1.66053906660\\times 10^{-27}\\,\\mathrm{kg}$，$T = 300\\,\\mathrm{K}$，以及 $q = 1.0\\times 10^{9}\\,\\mathrm{m}^{-1}$。窗函数“rectangular”（矩形窗）表示对于所有 $n$，$w_{n} = 1$；窗函数“Hann”（汉宁窗）表示对于 $n \\in \\{0,\\ldots,N-1\\}$，$w_{n} = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right)\\right)$。\n\n- 用例 1（高分辨率，矩形窗）：$N = 4096$，$\\Delta t = 1.0\\times 10^{-13}\\,\\mathrm{s}$，矩形窗。\n- 用例 2（由于时间步长过大导致 Nyquist 频率不足）：$N = 4096$，$\\Delta t = 2.0\\times 10^{-12}\\,\\mathrm{s}$，矩形窗。\n- 用例 3（总时间短且频率分辨率粗糙）：$N = 256$，$\\Delta t = 1.0\\times 10^{-13}\\,\\mathrm{s}$，矩形窗。\n- 用例 4（Hann 窗修改时间信号）：$N = 4096$，$\\Delta t = 1.0\\times 10^{-13}\\,\\mathrm{s}$，Hann 窗。\n\n要求的最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述四个用例的顺序排列结果。每个条目必须是该用例的相对误差，以浮点数表示（无量纲）。例如，输出格式为 $[x_{1},x_{2},x_{3},x_{4}]$，其中每个 $x_{i}$ 是用例 $i$ 的相对误差。",
            "solution": "该问题要求对理想单原子气体的经典 $f$-求和规则进行数值测试。验证过程确认了该问题在科学上是合理的、定义明确的，并且包含了所有必要信息。因此，我们可以着手解决。\n\n解决方案包括三个主要部分：\n1.  对理想气体的中间散射函数 $F(q, t)$ 进行解析推导，这为合成时间序列提供了基础。\n2.  对该系统的 $f$-求和规则进行解析验证，以确立被测试的精确理论关系。\n3.  一个数值实现，它从合成的 $F(q, t)$ 计算动态结构因子的二阶频率矩，并将其与理论预测进行比较，然后分析在指定测试用例中观察到的数值误差。\n\n**1. 理想气体中间散射函数的解析形式**\n\n中间散射函数 (ISF) 定义为 $F(\\mathbf{q}, t) = N^{-1} \\langle \\rho(\\mathbf{q}, t)\\rho(-\\mathbf{q}, 0) \\rangle$，其中 $\\rho(\\mathbf{q}, t) = \\sum_{j=1}^{N} e^{-i\\mathbf{q}\\cdot\\mathbf{r}_j(t)}$ 是密度的傅里叶分量。对于理想气体，粒子的位置和速度是不相关的。因此，对于均匀系统，$F(\\mathbf{q}, t)$ 展开式中的交叉项（$j \\neq k$）消失，总和简化为对单个粒子轨迹的平均：$F(\\mathbf{q}, t) = \\langle e^{-i\\mathbf{q}\\cdot(\\mathbf{r}(t) - \\mathbf{r}(0))} \\rangle$。\n\n理想气体中的粒子进行弹道运动，因此 $\\mathbf{r}(t) = \\mathbf{r}(0) + \\mathbf{v}t$。位移为 $\\mathbf{r}(t) - \\mathbf{r}(0) = \\mathbf{v}t$。ISF 变为对速度分布的平均：\n$$F(\\mathbf{q}, t) = \\langle e^{-i\\mathbf{q}\\cdot\\mathbf{v}t} \\rangle$$\n该平均是对质量为 $m$、温度为 $T$ 的单原子气体的 Maxwell-Boltzmann 速度分布进行的：\n$$P(\\mathbf{v}) = \\left(\\frac{m}{2\\pi k_{\\mathrm{B}} T}\\right)^{3/2} \\exp\\left(-\\frac{m |\\mathbf{v}|^2}{2 k_{\\mathrm{B}} T}\\right)$$\n该平均是此高斯分布的特征函数。通过将一个轴（例如 $v_z$）与 $\\mathbf{q}$ 对齐，积分可以分离，并通过配方法或识别其为高斯函数的傅里叶变换来求解。结果仅取决于大小 $q = |\\mathbf{q}|$，为：\n$$F(q, t) = \\exp\\left(-\\frac{q^2 k_{\\mathrm{B}} T}{2m} t^2\\right)$$\n这个关于时间的高斯函数是理想气体的精确 ISF。静态结构因子是 $S(q) = F(q, 0) = 1$，这是无相互作用系统的一个已知结果。\n\n**2. $f$-求和规则的解析验证**\n\n$f$-求和规则将动态结构因子 $S(q, \\omega)$ 的二阶频率矩与热学性质联系起来：\n$$\\int_{-\\infty}^{\\infty} \\omega^{2} S(q, \\omega)\\, \\mathrm{d}\\omega = \\frac{q^{2} k_{\\mathrm{B}} T}{m} S(q)$$\n对于我们的理想气体，$S(q)=1$，因此右侧 (RHS) 为 $\\frac{q^{2} k_{\\mathrm{B}} T}{m}$。\n\n左侧 (LHS) 可以使用傅里叶变换的矩定理计算。根据问题给定的约定 $S(q, \\omega) = (2\\pi)^{-1} \\int_{-\\infty}^{\\infty} e^{i \\omega t} F(q, t) \\mathrm{d}t$，二阶矩与 $F(q, t)$ 在 $t=0$ 处的二阶导数相关：\n$$\\int_{-\\infty}^{\\infty} \\omega^{2} S(q, \\omega)\\, \\mathrm{d}\\omega = i^2 \\frac{\\mathrm{d}^2 F(q, t)}{\\mathrm{d}t^2}\\bigg|_{t=0} = -\\frac{\\mathrm{d}^2 F(q, t)}{\\mathrm{d}t^2}\\bigg|_{t=0}$$\n我们定义 $\\alpha = \\frac{q^2 k_{\\mathrm{B}} T}{2m}$，因此 $F(q, t) = e^{-\\alpha t^2}$。其导数为：\n$$\\frac{\\mathrm{d}F}{\\mathrm{d}t} = -2\\alpha t e^{-\\alpha t^2}$$\n$$\\frac{\\mathrm{d}^2F}{\\mathrm{d}t^2} = (-2\\alpha + 4\\alpha^2 t^2) e^{-\\alpha t^2}$$\n在 $t=0$ 处求值得到 $\\frac{\\mathrm{d}^2F}{\\mathrm{d}t^2}\\big|_{t=0} = -2\\alpha$。\n因此，LHS 为 $-(-2\\alpha) = 2\\alpha = 2\\left(\\frac{q^2 k_{\\mathrm{B}} T}{2m}\\right) = \\frac{q^2 k_{\\mathrm{B}} T}{m}$。\nLHS 等于 RHS，因此 $f$-求和规则在解析上是满足的。\n\n**3. 数值测试与误差分析**\n\n任务是数值计算 LHS 并将其与解析的 RHS 进行比较。指定的数值程序是：\n1.  在离散时间网格 $t_n = (n-N/2)\\Delta t$ 上对函数 $G(t) = F(q, t)w(t)$ 进行采样。\n2.  计算其离散傅里叶变换 (DFT)，$\\tilde{G}_k$。\n3.  使用 DFT 来近似傅里叶积分 $\\tilde{G}(\\omega) \\approx \\Delta t \\cdot \\tilde{G}_k$（相位因子由 `fftshift` 处理）。\n4.  使用在 DFT 频率 $\\omega_k$ 上的离散和来近似积分 $\\int \\omega^2 S(q,\\omega) \\mathrm{d}\\omega$。\n\n连续傅里叶变换和 DFT 之间的关系，以及 $S(q,\\omega)$ 的指定定义，导出了数值估计 LHS 的以下公式：\n$$LHS_{\\text{num}} = \\frac{1}{N} \\sum_{k=0}^{N-1} \\omega_k^2 \\tilde{G}_k$$\n其中 $\\tilde{G}_k$ 是时间中心化、加窗信号 $G_n$ 的 DFT，而 $\\omega_k$ 是来自 DFT 的相应角频率。相对误差则为 $(\\mathrm{LHS}_{\\text{num}} - \\mathrm{RHS}) / \\mathrm{RHS}$。\n\n指定的测试用例旨在揭示数值信号处理中的常见陷阱：\n\n-   **用例 1 (基准):** 当点数 $N$ 很大且时间步长 $\\Delta t$ 很小时，时域信号 $F(q,t)$ 在其振幅可忽略不计的时间范围内得到了很好的采样。这既最小化了混叠（由于 $\\Delta t$ 小）又最小化了截断/泄漏（由于总时间 $N\\Delta t$ 长）。频率分辨率很高。我们预计数值误差会非常小。\n\n-   **用例 2 (混叠):** 时间步长 $\\Delta t = 2.0 \\times 10^{-12}\\,\\mathrm{s}$ 大于 $F(q,t)$ 的特征衰减时间 $\\tau = \\sqrt{2m/(q^2 k_{\\mathrm{B}} T)} \\approx 1.79 \\times 10^{-12}\\,\\mathrm{s}$。这违反了 Nyquist 采样准则，因为 Nyquist 频率 $\\omega_{\\text{Nyq}} = \\pi/\\Delta t$ 与 $S(q,\\omega)$ 的谱宽相当。来自频率 $|\\omega| > \\omega_{\\text{Nyq}}$ 的谱功率被“折叠”到采样频率范围内。因为求和规则积分按 $\\omega^2$ 对频谱进行加权，所以高频分量至关重要。混叠将这些大的贡献映射到较低的频率，在那里它们被较小的 $\\omega^2$ 加权，导致对积分的显著低估和大的负误差。\n\n-   **用例 3 (频率分辨率差):** 点数 $N=256$ 较小，导致总时间跨度 $T_{\\text{tot}} = N\\Delta t$ 较短。这导致了粗糙的频率网格，因为频率分辨率为 $\\Delta\\omega = 2\\pi/T_{\\text{tot}}$。函数 $\\omega^2 S(q,\\omega)$ 仅在少数几个点上被采样，使得离散和成为连续积分的一个很差的近似（求积误差）。这会导致一个明显但并非灾难性的误差。\n\n-   **用例 4 (加窗):** 应用非矩形窗，例如 Hann 窗，会修改信号。时域中的乘法对应于频域中的卷积。计算出的频谱是真实 $S(q,\\omega)$ 与窗函数傅里叶变换 $\\tilde{w}(\\omega)$ 的卷积。假设归一化适当，这个卷积频谱的二阶矩是原始谱二阶矩之和：$M_2(G) = M_2(F) + M_2(w)$。物理矩为 $M_2(F) = -F''(0)$。窗函数贡献了一个附加项 $M_2(w) = -w''(0)$。因此，数值测试计算的是 $-F''(0)w(0) - F(0)w''(0)$，而不仅仅是 $-F''(0)$。这引入了一个取决于窗在 $t=0$ 处的值和二阶导数的系统误差。对于指定的 Hann 窗和时间网格，这会导致一个微小但明显的正误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a numerical test of the f-sum rule for an ideal gas\n    based on synthesized intermediate scattering function data.\n    \"\"\"\n    \n    # Physical and numerical parameters from the problem statement.\n    test_cases = [\n        # Case 1: Well-resolved, rectangular window\n        {'N': 4096, 'dt': 1.0e-13, 'window_name': 'rectangular'},\n        # Case 2: Insufficient Nyquist frequency (aliasing)\n        {'N': 4096, 'dt': 2.0e-12, 'window_name': 'rectangular'},\n        # Case 3: Short total time (poor frequency resolution)\n        {'N': 256, 'dt': 1.0e-13, 'window_name': 'rectangular'},\n        # Case 4: Hann window modifies the time signal\n        {'N': 4096, 'dt': 1.0e-13, 'window_name': 'hann'},\n    ]\n\n    # Fixed physical constants\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n    m_u = 1.66053906660e-27  # Atomic mass unit in kg\n    \n    # System parameters for Argon at 300K\n    m = 39.948 * m_u  # Mass of Argon atom in kg\n    T = 300.0  # Temperature in K\n    q = 1.0e9  # Wavevector magnitude in m^-1\n\n    # Analytically calculate the right-hand side (RHS) of the f-sum rule.\n    # For an ideal gas, the static structure factor S(q) = 1.\n    rhs_analytical = (q**2 * k_B * T) / m\n\n    results = []\n    \n    for case in test_cases:\n        N = case['N']\n        dt = case['dt']\n        window_name = case['window_name']\n        \n        # 1. Define time and frequency grids\n        # Time grid is centered at t=0, as per problem spec\n        t = (np.arange(N) - N / 2) * dt\n        # Angular frequencies from np.fft.fftfreq correspond to the output of np.fft.fft\n        omega = 2 * np.pi * np.fft.fftfreq(N, d=dt)\n\n        # 2. Synthesize the intermediate scattering function F(q,t) for an ideal gas\n        alpha = (q**2 * k_B * T) / (2 * m)\n        F_t = np.exp(-alpha * t**2)\n\n        # 3. Apply the specified window function\n        if window_name == 'rectangular':\n            w = np.ones(N)\n        elif window_name == 'hann':\n            # Per problem spec: w_n = 0.5 * (1 - cos(2*pi*n/(N-1))) for n in {0..N-1}\n            n_idx = np.arange(N)\n            w = 0.5 * (1 - np.cos(2 * np.pi * n_idx / (N - 1)))\n        \n        # Windowed time-domain signal\n        G_t = F_t * w\n\n        # 4. Compute the Discrete Fourier Transform (DFT)\n        # The signal G_t is defined on a centered time grid [-T/2, T/2).\n        # To use np.fft.fft, which assumes a grid [0, T), we must rearrange\n        # the signal using np.fft.ifftshift.\n        G_shifted_for_fft = np.fft.ifftshift(G_t)\n        dft_G = np.fft.fft(G_shifted_for_fft)\n\n        # 5. Numerically evaluate the LHS of the sum rule via discrete quadrature\n        # The second moment integral is approximated by a sum over discrete frequencies.\n        # Based on the Fourier moment theorem and DFT properties, this is:\n        # integral(omega^2 * S(q,omega)) d(omega) = -F''(t=0)\n        # The DFT relation for the second derivative at t=0 for a centered signal is\n        # - (1/(N*dt^2)) * sum_k (DFT(G)_k * (e^(i*pi*k) - 1)^2 )\n        # A simpler, more direct approach given the problem formulation:\n        # S(q, omega_k) is approximated by (1/2pi) * dt * dft_G_shifted\n        # where dft_G_shifted is fftshifted to match the omega grid.\n        # integral(omega^2 S(q, omega)) d(omega) ~= sum(omega_k^2 * S(q, omega_k) * d_omega)\n        dft_G_shifted = np.fft.fftshift(dft_G)\n        omega_shifted = np.fft.fftshift(omega)\n        S_q_omega = (1 / (2 * np.pi)) * dt * dft_G_shifted\n        d_omega = 2 * np.pi / (N * dt)\n        \n        # The formula in the solution text is derived from the relation between the DFT of a\n        # sequence and the DTFT of the same sequence, leading to a simpler expression\n        # without needing explicit delta_omega scaling. Let's use that one.\n        # LHS_numerical = (1/N) * sum_k omega_k^2 * DFT(G)_k\n        # This formula is correct if G is NOT ifftshifted. Let's stick to the unshifted DFT result.\n        summand = omega**2 * dft_G\n        \n        # G_t is a real-valued function with near-perfect even symmetry. Its DFT\n        # should be real-valued. We take np.real to discard negligible\n        # imaginary components arising from floating-point inaccuracies.\n        lhs_numerical = np.real(np.sum(summand)) / N\n\n        # 6. Calculate the relative error\n        relative_error = (lhs_numerical - rhs_analytical) / rhs_analytical\n        results.append(relative_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}