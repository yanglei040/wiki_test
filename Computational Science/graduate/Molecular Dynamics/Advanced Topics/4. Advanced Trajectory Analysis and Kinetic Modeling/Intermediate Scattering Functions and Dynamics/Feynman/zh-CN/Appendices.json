{
    "hands_on_practices": [
        {
            "introduction": "理论与实践的第一步是从一个可解的模型开始。本练习将引导你从第一性原理出发，推导并计算理想气体的自中间散射函数（SISF）。通过将牛顿运动定律和麦克斯韦-玻尔兹曼统计应用于这个最简单的系统，你可以将 SISF 的抽象定义与一个具体的解析解联系起来，为理解更复杂的系统奠定坚实的基础。",
            "id": "3418495",
            "problem": "考虑一个三维理想气体，由质量为 $m$ 的相同点状粒子组成，在绝对温度 $T$ 下处于热平衡状态。粒子动力学遵循牛顿定律，且粒子间无相互作用力。自中间散射函数 (SISF)，记为 $F_s(\\mathbf{k},t)$，根据第一性原理定义为由位移产生的复相位的系综平均，即对粒子和时间原点进行平均：\n$$\nF_s(\\mathbf{k},t) = \\left\\langle \\exp\\left(i\\,\\mathbf{k}\\cdot\\left[\\mathbf{r}(t+\\tau)-\\mathbf{r}(\\tau)\\right]\\right)\\right\\rangle_{\\text{particles},\\,\\tau}.\n$$\n对于各向同性系统，物理可观测量仅依赖于其大小 $k=\\lVert\\mathbf{k}\\rVert$。在半径为 $k$ 的波矢壳层（$k$-壳层）上的各向同性平均，是指在固定 $k$ 的情况下，对单位球面上所有方向 $\\hat{\\mathbf{k}}=\\mathbf{k}/k$ 上的 $F_s(\\mathbf{k},t)$ 进行平均，从而得到各向同性平均的 SISF，记为 $\\overline{F_s}(k,t)$。\n\n请仅使用上述基本定律、核心定义以及关于平衡态速度统计的成熟结论，编写一个程序来计算所述三维理想气体的各向同性平均 SISF $\\overline{F_s}(k,t)$。计算必须从 $F_s(\\mathbf{k},t)$ 的定义出发，并正确实现对 $k$-壳层的各向同性平均。该气体处于热平衡状态，因此粒子速度遵循与指定的 $m$ 和 $T$ 相符的麦克斯韦-玻尔兹曼分布。\n\n单位和数值要求：\n- 全程使用国际单位制（SI）。质量 $m$ 的单位为千克 (kg)，温度 $T$ 的单位为开尔文 (K)，时间 $t$ 的单位为秒 (s)，波矢大小 $k$ 的单位为米分之一 ($\\text{m}^{-1}$)。\n- 玻尔兹曼常数 $k_B$ 必须取值为 $k_B = 1.380649\\times 10^{-23}\\,\\text{J/K}$。\n- SISF $\\overline{F_s}(k,t)$ 是无量纲的。你的程序必须输出四舍五入到六位小数的值。\n\n测试集：\n为以下四组参数计算 $\\overline{F_s}(k,t)$：\n1. $m = 39.948\\,\\text{原子质量单位}$（需转换为千克），$T=300\\,\\text{K}$，$t=1.0\\times 10^{-12}\\,\\text{s}$，$k=5.0\\times 10^{9}\\,\\text{m}^{-1}$。\n2. $m = 39.948\\,\\text{原子质量单位}$（需转换为千克），$T=300\\,\\text{K}$，$t=1.0\\times 10^{-12}\\,\\text{s}$，$k=0.0\\,\\text{m}^{-1}$。\n3. $m = 39.948\\,\\text{原子质量单位}$（需转换为千克），$T=300\\,\\text{K}$，$t=0.0\\,\\text{s}$，$k=5.0\\times 10^{9}\\,\\text{m}^{-1}$。\n4. $m = 39.948\\,\\text{原子质量单位}$（需转换为千克），$T=300\\,\\text{K}$，$t=1.0\\times 10^{-9}\\,\\text{s}$，$k=1.0\\times 10^{10}\\,\\text{m}^{-1}$。\n\n原子质量单位必须使用 $1\\,\\text{原子质量单位} = 1.66053906660\\times 10^{-27}\\,\\text{kg}$ 进行转换。\n\n覆盖性设计：\n- 情况 1 是散射实验中典型的皮秒和亚埃级范围内的通用非平凡场景。\n- 情况 2 是 $k=0$ 的边界条件，用于探测零波矢下的归一化和各向同性平均。\n- 情况 3 是 $t=0$ 的边界条件，用于探测零时间下的归一化。\n- 情况 4 是大时间和大波矢的极限情况，用于探测强退相干行为。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的四个浮点数列表，每个浮点数按上述测试集的顺序精确到六位小数。例如，输出行必须如下所示：\n$$\n[\\text{value}_1,\\text{value}_2,\\text{value}_3,\\text{value}_4].\n$$",
            "solution": "用户要求推导并计算三维理想气体的各向同性平均自中间散射函数 (SISF)，记为 $\\overline{F_s}(k,t)$。该问题在科学上是有效的、适定的，并包含了获得唯一解所需的所有信息。我们按照要求，从第一性原理开始推导 $\\overline{F_s}(k,t)$ 的表达式。\n\nSISF, $F_s(\\mathbf{k},t)$，定义为系综平均：\n$$\nF_s(\\mathbf{k},t) = \\left\\langle \\exp\\left(i\\,\\mathbf{k}\\cdot\\left[\\mathbf{r}(t+\\tau)-\\mathbf{r}(\\tau)\\right]\\right)\\right\\rangle_{\\text{particles},\\,\\tau}\n$$\n其中 $\\mathbf{r}(t)$ 是粒子在时间 $t$ 的位置，$\\mathbf{k}$ 是波矢，平均是对所有粒子和时间原点 $\\tau$ 进行的。\n\n对于理想气体，粒子间没有相互作用力。根据牛顿第一定律，每个粒子都以恒定速度 $\\mathbf{v}$ 运动。粒子的轨迹由 $\\mathbf{r}(t) = \\mathbf{r}(0) + \\mathbf{v}t$ 给出。因此，粒子在时间间隔 $t$ 内的位移为：\n$$\n\\Delta\\mathbf{r}(t) = \\mathbf{r}(t+\\tau) - \\mathbf{r}(\\tau) = \\left(\\mathbf{r}(\\tau) + \\mathbf{v}t\\right) - \\mathbf{r}(\\tau) = \\mathbf{v}t\n$$\n该位移与初始位置 $\\mathbf{r}(\\tau)$ 和时间原点 $\\tau$ 无关。将其代入 $F_s(\\mathbf{k},t)$ 的定义中，对 $\\tau$ 的平均变得无关紧要，表达式简化为：\n$$\nF_s(\\mathbf{k},t) = \\left\\langle \\exp\\left(i\\,\\mathbf{k}\\cdot(\\mathbf{v}t)\\right)\\right\\rangle_{\\text{particles}}\n$$\n对于处于热平衡的系统，对粒子的系综平均等同于对粒子速度分布的平均。设 $P(\\mathbf{v})$ 为速度概率分布函数。则 SISF 由以下积分给出：\n$$\nF_s(\\mathbf{k},t) = \\int \\exp\\left(i\\,t\\,\\mathbf{k}\\cdot\\mathbf{v}\\right) P(\\mathbf{v}) \\, d^3\\mathbf{v}\n$$\n该系统是在绝对温度 $T$ 下的理想气体。粒子速度遵循三维麦克斯韦-玻尔兹曼分布：\n$$\nP(\\mathbf{v}) = \\left(\\frac{m}{2\\pi k_B T}\\right)^{3/2} \\exp\\left(-\\frac{m |\\mathbf{v}|^2}{2 k_B T}\\right)\n$$\n其中 $m$ 是粒子质量，$k_B$ 是玻尔兹曼常数。$P(\\mathbf{v})$ 是三个独立的高斯分布的乘积，分别对应于速度分量 $v_x$、$v_y$ 和 $v_z$：\n$$\nP(\\mathbf{v}) = P_1(v_x) P_1(v_y) P_1(v_z) \\quad \\text{with} \\quad P_1(v_j) = \\left(\\frac{m}{2\\pi k_B T}\\right)^{1/2} \\exp\\left(-\\frac{m v_j^2}{2 k_B T}\\right)\n$$\n指数中的点积为 $\\mathbf{k}\\cdot\\mathbf{v} = k_x v_x + k_y v_y + k_z v_z$。$F_s(\\mathbf{k},t)$ 的积分可以分解为三个一维积分的乘积：\n$$\nF_s(\\mathbf{k},t) = \\left(\\int_{-\\infty}^{\\infty} e^{i t k_x v_x} P_1(v_x) dv_x\\right) \\left(\\int_{-\\infty}^{\\infty} e^{i t k_y v_y} P_1(v_y) dv_y\\right) \\left(\\int_{-\\infty}^{\\infty} e^{i t k_z v_z} P_1(v_z) dv_z\\right)\n$$\n每个积分都是高斯函数的傅里叶变换。我们来计算其中一个分量 $j \\in \\{x, y, z\\}$ 的积分：\n$$\nI_j = \\int_{-\\infty}^{\\infty} \\exp(i t k_j v_j) \\left(\\frac{m}{2\\pi k_B T}\\right)^{1/2} \\exp\\left(-\\frac{m v_j^2}{2 k_B T}\\right) dv_j\n$$\n这是一个标准的高斯积分，形式为 $\\int_{-\\infty}^{\\infty} e^{-ax^2+bx} dx = \\sqrt{\\pi/a} e^{b^2/(4a)}$。此处，$a = \\frac{m}{2k_B T}$ 且 $b = i t k_j$。该积分的计算结果为：\n$$\nI_j = \\left(\\frac{m}{2\\pi k_B T}\\right)^{1/2} \\sqrt{\\frac{2\\pi k_B T}{m}} \\exp\\left(\\frac{(i t k_j)^2}{4(m / (2 k_B T))}\\right) = \\exp\\left(-\\frac{t^2 k_j^2 k_B T}{2m}\\right)\n$$\n将三个分量（$j=x,y,z$）的结果相乘：\n$$\nF_s(\\mathbf{k},t) = \\exp\\left(-\\frac{t^2 k_x^2 k_B T}{2m}\\right) \\exp\\left(-\\frac{t^2 k_y^2 k_B T}{2m}\\right) \\exp\\left(-\\frac{t^2 k_z^2 k_B T}{2m}\\right)\n$$\n$$\nF_s(\\mathbf{k},t) = \\exp\\left(-\\frac{(k_x^2+k_y^2+k_z^2) k_B T}{2m} t^2\\right) = \\exp\\left(-\\frac{k^2 k_B T}{2m} t^2\\right)\n$$\n其中 $k = \\lVert\\mathbf{k}\\rVert = \\sqrt{k_x^2+k_y^2+k_z^2}$。此结果表明，对于理想气体，$F_s(\\mathbf{k},t)$ 仅依赖于波矢的大小 $k$，而与其方向无关。该函数本质上是各向同性的。\n\n各向同性平均 SISF，$\\overline{F_s}(k,t)$，定义为在固定大小 $k$ 的情况下，对 $\\mathbf{k}$ 的所有方向上的 $F_s(\\mathbf{k},t)$ 进行平均。由于 $F_s(\\mathbf{k},t)$ 不依赖于 $\\mathbf{k}$ 的方向，对其进行全方向平均不会改变其值。\n$$\n\\overline{F_s}(k,t) = \\frac{1}{4\\pi} \\int_{\\text{unit sphere}} F_s(\\mathbf{k},t) \\, d\\Omega = \\frac{1}{4\\pi} \\int_{\\text{unit sphere}} \\exp\\left(-\\frac{k^2 k_B T}{2m} t^2\\right) \\, d\\Omega\n$$\n被积函数在积分球面上是常数，因此可以提取出来：\n$$\n\\overline{F_s}(k,t) = \\exp\\left(-\\frac{k^2 k_B T}{2m} t^2\\right) \\left(\\frac{1}{4\\pi} \\int d\\Omega\\right) = \\exp\\left(-\\frac{k^2 k_B T}{2m} t^2\\right) \\left(\\frac{4\\pi}{4\\pi}\\right)\n$$\n因此，三维理想气体的各向同性平均 SISF 的最终表达式为：\n$$\n\\overline{F_s}(k,t) = \\exp\\left(-\\frac{k^2 t^2 k_B T}{2m}\\right)\n$$\n这是一个在 $k$ 和 $t$ 上都呈高斯衰减的函数。此公式将用于计算指定测试用例的值。参数 $m$、$T$、$k$、$t$ 和常数 $k_B$ 均已给出。质量 $m$ 以原子质量单位 (u) 给出，必须使用给定的转换因子将其转换为千克 (kg)。\n\n该解析表达式可以自然地处理边界情况。当 $t=0$ 时，指数的参数为 $0$，因此 $\\overline{F_s}(k,0) = e^0 = 1$，这是正确的归一化条件，反映了在零时间位移为零。当 $k=0$ 时，参数也为 $0$，因此 $\\overline{F_s}(0,t) = 1$，这对应于探测无限大长度尺度的情况，此时有限的粒子位移没有影响。在 $k$ 或 $t$ 很大的极限下，函数衰减到 $0$，表示完全退相干。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates the problem, derives the formula for the isotropically averaged\n    Self Intermediate Scattering Function (SISF) for an ideal gas, and\n    computes it for a given set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (mass in u, temperature in K, time in s, wavevector magnitude in m^-1)\n    test_cases = [\n        (39.948, 300.0, 1.0e-12, 5.0e9),\n        (39.948, 300.0, 1.0e-12, 0.0),\n        (39.948, 300.0, 0.0, 5.0e9),\n        (39.948, 300.0, 1.0e-9, 1.0e10),\n    ]\n\n    results = []\n    for case in test_cases:\n        m_u, T, t, k = case\n        result = compute_sisf(m_u, T, t, k)\n        results.append(result)\n\n    # Format the final output string as a comma-separated list of floats\n    # enclosed in square brackets, with each value rounded to six decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_sisf(m_u: float, T: float, t: float, k: float) -> float:\n    \"\"\"\n    Computes the isotropically averaged Self Intermediate Scattering Function\n    for a 3D ideal gas.\n\n    The formula is: F_s(k, t) = exp(-(k^2 * t^2 * k_B * T) / (2 * m))\n\n    Args:\n        m_u (float): Mass of the particle in atomic mass units (u).\n        T (float): Absolute temperature in Kelvin (K).\n        t (float): Time in seconds (s).\n        k (float): Wavevector magnitude in inverse meters (m^-1).\n\n    Returns:\n        float: The dimensionless value of the SISF.\n    \"\"\"\n    # Physical constants in SI units\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n    amu_to_kg = 1.66053906660e-27  # Conversion factor from u to kg\n\n    # Convert mass from atomic mass units to kilograms\n    m_kg = m_u * amu_to_kg\n\n    # The formula is well-behaved for t=0 or k=0, both leading to an exponent of 0.\n    # Explicitly checking for these boundary conditions is good practice but not\n    # strictly necessary for the correctness of this specific formula.\n    if t == 0.0 or k == 0.0:\n        return 1.0\n\n    # Calculate the argument of the exponential function.\n    # The expression is rearranged for numerical stability, although for the given\n    # parameters, a direct calculation would also be safe.\n    exponent = - (k**2 * t**2 * k_B * T) / (2.0 * m_kg)\n\n    # The exponential of a very large negative number will correctly underflow to 0.0\n    sisf_value = np.exp(exponent)\n    \n    return sisf_value\n\n# Execute the main function\nsolve()\n\n```"
        },
        {
            "introduction": "在实际研究中，我们通常需要分析分子动力学模拟产生的轨迹数据，而不仅仅是处理解析公式。本练习将教你如何从离散的时间序列数据中高效地计算相干中间散射函数 $F(\\mathbf{k},t)$。你将学习并应用基于快速傅里叶变换（FFT）的维纳-辛钦定理，这是计算时间相关函数的标准方法，也是计算物理学中的一项核心技能。",
            "id": "3418516",
            "problem": "您的任务是设计并实现一种高效算法，使用快速傅里叶变换 (FFT) 从离散的分子动力学 (MD) 轨迹中计算相干中间散射函数。相干中间散射函数量化了在指定波矢下密度涨落的时间相关性，是将微观动力学与散射可观测量联系起来的核心量。\n\n从以下基本基础开始：\n\n- 微观数密度定义为 $$\\rho(\\mathbf{r},t) = \\sum_{j=1}^{N} \\delta\\!\\left(\\mathbf{r} - \\mathbf{r}_j(t)\\right),$$ 其中 $N$ 是粒子数，$\\mathbf{r}_j(t)$ 是粒子 $j$ 在时间 $t$ 的位置。\n\n- 波矢为 $\\mathbf{k}$ 时的密度模式定义为 $$\\rho_{\\mathbf{k}}(t) = \\sum_{j=1}^{N} \\exp\\!\\left(i \\mathbf{k}\\cdot\\mathbf{r}_j(t)\\right).$$\n\n- 相干中间散射函数定义为 $$F(\\mathbf{k},t) = \\frac{1}{N} \\left\\langle \\rho_{\\mathbf{k}}(t_0+t)\\,\\rho_{\\mathbf{k}}(t_0)^{\\ast} \\right\\rangle_{t_0},$$ 其中 $\\langle\\cdot\\rangle_{t_0}$ 表示对时间起点 $t_0$ 的平均，而 ${}^{\\ast}$ 表示复共轭。对于一个平稳过程，这是复数时间序列 $\\rho_{\\mathbf{k}}(t)$ 的时间自相关函数。\n\n- 对于进行独立布朗运动的理想气体，每个粒子的位移分量是沿每个笛卡尔轴的高斯随机变量，其均值为零，方差为 $2 D t$（其中 $D$ 是扩散系数，单位为 $\\mathrm{m}^2/\\mathrm{s}$）。在这种情况下，对于任何非零波矢大小 $k = \\|\\mathbf{k}\\|$，理论上预期的相干中间散射函数等于自中间散射函数，并且为 $$F(\\mathbf{k},t) = \\exp\\!\\left(-D k^2 t\\right) \\quad \\text{for } k > 0.$$ 对于 $k=0$ 的特殊情况，有 $$\\rho_{\\mathbf{0}}(t) = N \\quad \\Rightarrow \\quad F(\\mathbf{0},t) = \\frac{1}{N} \\langle N \\cdot N \\rangle = N.$$\n\n您的目标是：\n\n1. 实现一种高效算法，使用离散维纳-辛钦定理和快速傅里叶变换 (FFT) 从离散时间序列 $\\{\\rho_{\\mathbf{k}}(n \\Delta t)\\}_{n=0}^{T-1}$ 计算 $F(\\mathbf{k},t)$。对于一个有限离散时间序列 $r_n = \\rho_{\\mathbf{k}}(n \\Delta t)$，其中 $n \\in \\{0,1,\\dots,T-1\\}$，定义线性自相关\n$$C_m = \\sum_{n=0}^{T-1-m} r_{n+m}\\,r_n^{\\ast}, \\quad m \\in \\{0,1,\\dots,T-1\\}.$$\n展示如何通过补零和FFT计算 $\\{C_m\\}$ 以避免循环卷积。然后获得\n$$F(\\mathbf{k},m \\Delta t) = \\frac{1}{N}\\,\\frac{C_m}{T-m}$$\n作为无偏时间原点平均的相干中间散射函数。\n\n2. 为进行三维独立布朗运动的粒子生成合成的MD轨迹。使用边长为 $L$ 的立方域，其中初始粒子位置从 $[0,L]^3$ 中独立同分布地均匀采样，以确保初始相位是随机的。在每个离散时间步 $\\Delta t$，通过沿每个轴添加均值为零、标准差为 $\\sqrt{2 D \\Delta t}$ 的独立高斯增量来更新位置。使用一个固定的波矢 $\\mathbf{k}$，其与 $x$ 轴对齐，大小为 $k$（方向的选择是任意的，但必须固定）。\n\n3. 对于每个测试用例，使用您基于FFT的算法计算 $F(\\mathbf{k},t)$，并与理论期望值进行比较：\n   - 如果 $k > 0$，与 $$F_{\\mathrm{theory}}(t) = \\exp\\!\\left(-D k^2 t\\right)$$ 进行比较。\n   - 如果 $k = 0$，与 $$F_{\\mathrm{theory}}(t) = N$$ 进行比较。\n   计算在延迟 $m$ 上的最大相对误差，其中 $F_{\\mathrm{theory}}(m \\Delta t) \\geq \\theta$（这是一个阈值，以避免在期望值极小时出现数值不稳定性）。对于 $k=0$，使用所有延迟，因为 $F_{\\mathrm{theory}}$ 是常数。使用相对误差定义\n   $$\\varepsilon_m = \\frac{\\left|F(\\mathbf{k},m \\Delta t) - F_{\\mathrm{theory}}(m \\Delta t)\\right|}{\\left|F_{\\mathrm{theory}}(m \\Delta t)\\right|}.$$\n\n4. 对于每个测试用例，返回一个布尔值，指示在规定的延迟范围内的最大相对误差是否严格小于指定的容差。\n\n科学真实性和单位：\n\n- 位置必须以米（$\\mathrm{m}$）为单位。\n- 时间必须以秒（$\\mathrm{s}$）为单位。\n- 扩散系数 $D$ 必须以平方米每秒（$\\mathrm{m}^2/\\mathrm{s}$）为单位。\n- 波矢大小 $k$ 必须以反米（$\\mathrm{m}^{-1}$）为单位。\n\n测试套件：\n\n实现您的程序以评估以下三个测试用例。请精确使用给定的参数，并将 $L$ 视为初始均匀位置分布的边长。为确保可复现性，每个测试用例使用一个固定的伪随机种子。在所有情况下，波矢为 $\\mathbf{k} = (k,0,0)$。\n\n- 测试用例 1（一般情况，非零波矢）：\n  - $N = 1024$\n  - $T = 2048$\n  - $\\Delta t = 1\\times 10^{-12}\\ \\mathrm{s}$\n  - $D = 2\\times 10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$\n  - $k = 2\\times 10^{9}\\ \\mathrm{m}^{-1}$\n  - $L = 1\\times 10^{-6}\\ \\mathrm{m}$\n  - 阈值 $\\theta = 1\\times 10^{-3}$ (无量纲)\n  - 容差 $= 2\\times 10^{-1}$ (无量纲)\n  - 种子 $= 123$\n\n- 测试用例 2（边界情况，零波矢）：\n  - $N = 512$\n  - $T = 1024$\n  - $\\Delta t = 1\\times 10^{-12}\\ \\mathrm{s}$\n  - $D = 1\\times 10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$\n  - $k = 0$\n  - $L = 1\\times 10^{-6}\\ \\mathrm{m}$\n  - 阈值 $\\theta = 0$ (无量纲)\n  - 容差 $= 1\\times 10^{-10}$ (无量纲)\n  - 种子 $= 456$\n\n- 测试用例 3（小样本量和中等波矢）：\n  - $N = 256$\n  - $T = 512$\n  - $\\Delta t = 5\\times 10^{-12}\\ \\mathrm{s}$\n  - $D = 1\\times 10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$\n  - $k = 1\\times 10^{9}\\ \\mathrm{m}^{-1}$\n  - $L = 1\\times 10^{-6}\\ \\mathrm{m}$\n  - 阈值 $\\theta = 1\\times 10^{-3}$ (无量纲)\n  - 容差 $= 3\\times 10^{-1}$ (无量纲)\n  - 种子 $= 789$\n\n最终输出格式规范：\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$$[r_1,r_2,r_3]$$），其中每个 $r_i$ 是一个布尔值，指示相应的测试用例是否满足其容差标准。不允许有其他输出。",
            "solution": "该问题被评估为有效。它在科学上基于统计力学和信号处理的原理，问题设定清晰，目标明确，数据充分，语言客观。因此，我们可以着手解决。\n\n任务是从模拟的分子动力学轨迹中计算相干中间散射函数 $F(\\mathbf{k},t)$，并根据已知的理论模型验证结果。整个过程包括三个主要阶段：首先，为进行独立布朗运动的粒子生成合成轨迹；其次，计算集体密度模式 $\\rho_{\\mathbf{k}}(t)$ 的时间序列；第三，使用高效的基于快速傅里叶变换 (FFT) 的方法计算该序列的时间自相关，以获得 $F(\\mathbf{k},t)$。\n\n**1. 布朗运动轨迹的生成**\n\n物理模型是三维空间中由 $N$ 个无相互作用粒子组成的理想气体。每个粒子 $j$ 的动力学是独立的，并由布朗运动控制。粒子 $j$ 在时间 $t$ 的位置用 $\\mathbf{r}_j(t)$ 表示。模拟从时间 $t=0$ 开始，进行 $T$ 个离散时间步，步长为 $\\Delta t$。\n\n初始位置 $\\{\\mathbf{r}_j(0)\\}_{j=1}^N$ 从边长为 $L$ 的立方体积内的独立同均匀分布中抽取。也就是说，对于每个粒子 $j$，其初始坐标 $(x_j(0), y_j(0), z_j(0))$ 从 $U(0, L)$ 中采样。这种初始位置的随机化确保了在密度模式计算中初始相位是不相关的。\n\n轨迹通过布朗运动的离散时间更新规则进行传播。粒子在时间间隔 $\\Delta t$ 内的位移是一个随机向量，其笛卡尔分量是独立的、均值为 $0$、方差为 $2D\\Delta t$ 的高斯随机变量，其中 $D$ 是扩散系数。因此，第 $n+1$ 步的位置由第 $n$ 步的位置更新如下：\n$$ \\mathbf{r}_j((n+1)\\Delta t) = \\mathbf{r}_j(n\\Delta t) + \\Delta\\mathbf{r}_j(n) $$\n其中位移向量 $\\Delta\\mathbf{r}_j(n)$ 的每个分量都从标准差为 $\\sigma = \\sqrt{2D\\Delta t}$ 的正态分布 $\\mathcal{N}(0, \\sigma^2)$ 中抽取。\n\n**2. 密度模式时间序列的计算**\n\n相干中间散射函数是密度模式 $\\rho_{\\mathbf{k}}(t)$ 的自相关，定义为：\n$$ \\rho_{\\mathbf{k}}(t) = \\sum_{j=1}^{N} \\exp\\!\\left(i \\mathbf{k}\\cdot\\mathbf{r}_j(t)\\right) $$\n对于我们生成的离散轨迹 $\\{\\mathbf{r}_j(n\\Delta t)\\}$，我们计算一个离散的复数值时间序列 $r_n = \\rho_{\\mathbf{k}}(n\\Delta t)$，其中 $n \\in \\{0, 1, \\dots, T-1\\}$。问题指定了一个与 $x$ 轴对齐的波矢 $\\mathbf{k} = (k, 0, 0)$。点积简化为 $\\mathbf{k}\\cdot\\mathbf{r}_j(t) = k\\,x_j(t)$，其中 $x_j(t)$ 是粒子 $j$ 位置的 $x$ 分量。因此，时间序列为：\n$$ r_n = \\rho_{\\mathbf{k}}(n\\Delta t) = \\sum_{j=1}^{N} \\exp\\!\\left(i k\\,x_j(n\\Delta t)\\right) $$\n\n**3. 基于FFT的自相关（维纳-辛钦定理）**\n\n问题要求计算时间序列 $\\{r_n\\}_{n=0}^{T-1}$ 的线性自相关，定义为：\n$$ C_m = \\sum_{n=0}^{T-1-m} r_{n+m}\\,r_n^{\\ast}, \\quad m \\in \\{0, 1, \\dots, T-1\\} $$\n对所有 $m$ 直接计算此和将是一个 $\\mathcal{O}(T^2)$ 的操作。一种更高效的 $\\mathcal{O}(T\\log T)$ 方法是使用维纳-辛钦定理，该定理通过傅里叶变换将自相关函数与功率谱密度联系起来。对于离散信号，必须注意计算*线性*自相关，而不是由离散傅里叶变换 (DFT) 的周期性引起的*循环*自相关。\n\n正确的步骤包括对信号进行补零：\n1.  设原始时间序列为 $r = \\{r_0, r_1, \\dots, r_{T-1}\\}$。\n2.  通过对 $r$ 补零创建一个长度为 $M$ 的新信号 $r'$。为确保结果是线性相关，填充后的长度 $M$ 必须至少为 $2T-1$。为了 FFT 算法的计算效率，$M$ 通常被选为下一个更高的2的幂，或更一般地，一个“平滑”数（高合成数）。我们将选择 $M$ 使得 $M \\ge 2T-1$。\n3.  计算填充后信号的DFT：$R' = \\mathcal{F}(r')$。\n4.  通过取 $R'$ 每个分量的模的平方来计算功率谱密度 (PSD)：$S_k = |R'_k|^2 = R'_k \\cdot (R'_k)^{\\ast}$。\n5.  计算PSD的逆DFT：$C' = \\mathcal{F}^{-1}(S)$。\n所得序列 $C'$ 的前 $T$ 个元素是所需的线性自相关值 $\\{C_m\\}_{m=0}^{T-1}$。\n\n**4. 最终计算与误差分析**\n\n从计算出的自相关和 $\\{C_m\\}$ 中，为每个延迟时间 $m\\Delta t$ 计算相干中间散射函数的无偏估计量：\n$$ F(\\mathbf{k}, m\\Delta t) = \\frac{1}{N} \\frac{C_m}{T-m} $$\n然后将此计算出的函数与布朗粒子理想气体的理论期望进行比较。\n-   对于非零波矢大小 $k > 0$，理论函数是指数衰减：\n    $$ F_{\\mathrm{theory}}(t) = \\exp(-Dk^2t) $$\n-   对于 $k=0$ 的特殊情况，点积 $\\mathbf{k}\\cdot\\mathbf{r}_j(t)$ 始终为 $0$，所以 $\\rho_{\\mathbf{0}}(t) = \\sum_j e^0 = N$。函数变为常数：\n    $$ F_{\\mathrm{theory}}(t) = \\frac{1}{N}\\langle N \\cdot N^{\\ast} \\rangle = N $$\n\n在每个延迟 $m$ 处计算相对误差 $\\varepsilon_m$：\n$$ \\varepsilon_m = \\frac{|F(\\mathbf{k}, m\\Delta t) - F_{\\mathrm{theory}}(m\\Delta t)|}{|F_{\\mathrm{theory}}(m\\Delta t)|} $$\n然后在相关延迟范围内找到最大相对误差。对于 $k>0$，该范围包括所有理论函数未衰减到阈值 $\\theta$ 以下的延迟 $m$，即 $F_{\\mathrm{theory}}(m\\Delta t) \\ge \\theta$。这避免了因除以非常小的数而产生的数值不稳定性。对于 $k=0$，$F_{\\mathrm{theory}}$ 是一个大的常数，因此使用所有延迟。最后，将此最大相对误差与指定的容差进行比较，以确定每个测试用例的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, ifft, next_fast_len\n\ndef run_test_case(N, T, dt, D, k, L, theta, tolerance, seed):\n    \"\"\"\n    Runs a single test case for computing the coherent intermediate scattering function.\n    \n    Args:\n        N (int): Number of particles.\n        T (int): Number of time steps.\n        dt (float): Time step duration in seconds.\n        D (float): Diffusion coefficient in m^2/s.\n        k (float): Wavevector magnitude in 1/m.\n        L (float): Side length of the initial distribution box in meters.\n        theta (float): Threshold for theoretical F(k,t) to consider in error analysis.\n        tolerance (float): Tolerance for maximum relative error.\n        seed (int): Seed for the pseudorandom number generator.\n        \n    Returns:\n        bool: True if the max relative error is less than the tolerance, False otherwise.\n    \"\"\"\n    # 1. Set seed for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # 2. Generate trajectory for independent Brownian motion\n    positions = np.zeros((T, N, 3))\n    # Initial positions are uniformly distributed in a cube of side L\n    positions[0, :, :] = rng.uniform(0, L, size=(N, 3))\n    \n    # Propagate positions using Gaussian increments\n    std_dev = np.sqrt(2 * D * dt)\n    for t_idx in range(T - 1):\n        displacements = rng.normal(0, std_dev, size=(N, 3))\n        positions[t_idx + 1] = positions[t_idx] + displacements\n        # For an ideal gas model, no periodic boundary conditions are applied.\n\n    # 3. Compute the density mode time series, rho_k(t)\n    # The wavevector is k_vec = (k, 0, 0), so k.r = k * x-position.\n    if k == 0:\n        # For k=0, exp(i*0) = 1, so rho_k(t) is a constant sum of 1s, which is N.\n        rho_k_t = np.full(T, float(N), dtype=np.complex128)\n    else:\n        # General case: rho_k(t) = sum_j exp(i * k * r_j_x(t))\n        # Vectorized calculation over all time steps and particles.\n        k_dot_r = k * positions[:, :, 0]  # Shape (T, N)\n        rho_k_t = np.sum(np.exp(1j * k_dot_r), axis=1)  # Shape (T,)\n\n    # 4. Compute the linear autocorrelation using the Wiener-Khinchin theorem via FFT\n    # Pad the signal to a length >= 2*T - 1 to avoid circular convolution effects.\n    # next_fast_len finds an efficient length for FFT.\n    n_padded = next_fast_len(2 * T - 1)\n    \n    # FFT of the zero-padded signal\n    rho_k_fft = fft(rho_k_t, n=n_padded)\n    \n    # Power spectral density is the squared magnitude of the FFT\n    psd = np.abs(rho_k_fft)**2\n    \n    # Inverse FFT of the PSD gives the autocorrelation function\n    autocorr_raw = ifft(psd)\n    \n    # The first T elements of the result correspond to the desired linear autocorrelation C_m.\n    # The result should be real; the imaginary part is numerical noise.\n    C_m = np.real(autocorr_raw[:T])\n\n    # 5. Compute the unbiased estimator for F(k,t)\n    # F(k, m*dt) = (1/N) * C_m / (T - m)\n    # The denominator (T-m) is the number of samples for each lag m.\n    denominators = np.arange(T, 0, -1)\n    F_computed = (1 / N) * (C_m / denominators)\n\n    # 6. Compute the theoretical F(k,t) for comparison\n    times = np.arange(T) * dt\n    if k > 0:\n        F_theory = np.exp(-D * k**2 * times)\n    else:  # k == 0\n        F_theory = np.full(T, float(N))\n        \n    # 7. Compute relative error and check against tolerance\n    # The denominator np.abs(F_theory) is always positive here.\n    relative_error = np.abs(F_computed - F_theory) / np.abs(F_theory)\n\n    # Select the lags over which to evaluate the error based on the threshold theta.\n    if k > 0:\n        # For k>0, consider only lags where the theoretical value is significant.\n        valid_indices = np.where(F_theory >= theta)[0]\n        # If the function decays so fast that no points are above threshold,\n        # we can default to checking lag 0, which is always 1.0.\n        if len(valid_indices) == 0:\n            valid_indices = [0]\n    else: # k == 0\n        # For k=0, the theoretical value is constant, so all lags are used.\n        valid_indices = np.arange(T)\n        \n    max_rel_error = np.max(relative_error[valid_indices])\n\n    return max_rel_error  tolerance\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1: General case, nonzero wavevector\n        {'N': 1024, 'T': 2048, 'dt': 1e-12, 'D': 2e-9, 'k': 2e9, 'L': 1e-6, \n         'theta': 1e-3, 'tolerance': 2e-1, 'seed': 123},\n        # Test case 2: Boundary case, zero wavevector\n        {'N': 512, 'T': 1024, 'dt': 1e-12, 'D': 1e-9, 'k': 0, 'L': 1e-6, \n         'theta': 0, 'tolerance': 1e-10, 'seed': 456},\n        # Test case 3: Small sample size and moderate wavevector\n        {'N': 256, 'T': 512, 'dt': 5e-12, 'D': 1e-9, 'k': 1e9, 'L': 1e-6, \n         'theta': 1e-3, 'tolerance': 3e-1, 'seed': 789},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(**case)\n        results.append(result)\n\n    # Format the final output as a single line: [True,True,False]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "计算中间散射函数 $F(q,t)$ 通常是通向更深层次物理洞见的途径。我们可以利用它来探索其他物理定律，其中许多定律是在频率空间中通过动态结构因子 $S(q,\\omega)$ 来表述的。这个练习将向你展示如何利用计算出的 $F(q,t)$ 来检验一个基本的物理定律——f-求和规则，并深刻理解数值离散化（如时间步长和窗函数的选择）如何引入误差，这对于严谨的数据分析至关重要。",
            "id": "3418532",
            "problem": "考虑一个处于热平衡状态的经典单原子流体，该流体通过弹性密度涨落进行探测。令中间散射函数 (ISF) 定义为 $F(\\mathbf{q}, t) = N^{-1} \\langle \\rho(\\mathbf{q}, t)\\rho(-\\mathbf{q}, 0) \\rangle$，其中 $\\rho(\\mathbf{q}, t)$ 是微观数密度的空间傅里叶模式，$\\mathbf{q}$ 是波矢量，其大小为 $q = \\|\\mathbf{q}\\|$，而 $\\langle \\cdot \\rangle$ 表示系综平均。通过傅里叶变换定义动态结构因子 $S(\\mathbf{q}, \\omega) = (2\\pi)^{-1} \\int_{-\\infty}^{\\infty} \\mathrm{d}t\\, e^{i \\omega t} F(\\mathbf{q}, t)$，并通过 $S(\\mathbf{q}) = F(\\mathbf{q}, 0)$ 定义静态结构因子。经典的 $f$-求和规则断言了 $S(\\mathbf{q}, \\omega)$ 的二阶频率矩与热速度标度之间存在一种关系。\n\n您的任务是使用精确体现了具有 Maxwell–Boltzmann 速度的理想气体弹道动力学的合成“分子动力学 (MD)”时间序列，来实现一个对 $f$-求和规则的测试。在这种理想单原子情况下，可以根据温度 $T$ 和质量 $m$ 下的牛顿运动学和 Maxwell–Boltzmann 统计来构建 $F(q, t)$；然后通过傅里叶变换得到 $S(q, \\omega)$。基于这些，通过对时间采样的 $F(q, t)$ 进行离散傅里叶变换得到的频率网格，使用离散求积法来数值近似 $\\int_{-\\infty}^{\\infty} \\omega^{2} S(q, \\omega)\\, \\mathrm{d}\\omega$。将数值估算的左侧与右侧 $(q^{2} k_{\\mathrm{B}} T/m)\\, S(q)$ 进行比较，其中 $k_{\\mathrm{B}}$ 是 Boltzmann 常数。报告在指定离散化设置下的相对误差，并在您的解题思路中讨论数值离散化在何种条件下会违反 $f$-求和规则。\n\n仅使用以下基础且经过充分检验的出发点：无相互作用粒子的牛顿运动学，处于平衡态的单原子理想气体的 Maxwell–Boltzmann 速度分布，上文给出的中间散射函数和动态结构因子的定义，以及傅里叶变换的标准性质。除了 $f$-求和规则的陈述本身，不要假定任何关于它的结果；相反，应将其与这些定义联系起来。\n\n整个过程使用以下物理和数值单位及约定：\n- 使用 $q$（单位：米分之一，$\\mathrm{m}^{-1}$），$t$（单位：秒，$\\mathrm{s}$），角频率 $\\omega$（单位：弧度/秒，$\\mathrm{rad}\\,\\mathrm{s}^{-1}$），质量 $m$（单位：千克，$\\mathrm{kg}$），温度 $T$（单位：开尔文，$\\mathrm{K}$），以及 $k_{\\mathrm{B}}$（单位：焦耳/开尔文，$\\mathrm{J}\\,\\mathrm{K}^{-1}$）。\n- 傅里叶变换的约定是 $S(q,\\omega) = (2\\pi)^{-1} \\int_{-\\infty}^{\\infty} \\mathrm{d}t\\, e^{i \\omega t} F(q,t)$。\n- 静态结构因子是 $S(q) = F(q,0)$。\n\n数值测试的算法规范：\n- 使用牛顿运动学和 Maxwell–Boltzmann 统计，为处于平衡态、温度为 $T$、粒子质量为 $m$ 且给定波矢量大小为 $q$ 的理想单原子气体合成 $F(q,t)$。然后，在时间网格 $t_{n} = (n - N/2)\\,\\Delta t$（其中 $n = 0, 1, \\ldots, N-1$）上均匀采样 $F(q,t)$，应用选定的窗函数 $w_{n}$ 得到采样数据 $G_{n} = F(q,t_{n})\\, w_{n}$，并计算离散傅里叶变换，以在均匀角频率网格 $\\omega_{k}$ 上获得 $S(q,\\omega)$ 的数值近似，记为 $\\widehat{S}(q,\\omega_{k})$。\n- 使用离散求积 $\\sum_{k} \\omega_{k}^{2}\\, \\widehat{S}(q,\\omega_{k})\\, \\Delta \\omega$ 来近似 $\\int \\omega^{2} S(q,\\omega)\\, \\mathrm{d}\\omega$，其中 $\\Delta \\omega$ 是由离散傅里叶变换所隐含的均匀角频率间距。确保缩放比例与上面给出的 $S(q,\\omega)$ 定义和所使用的网格间距一致。\n- 使用 $S(q)=F(q,0)$ 将此数值计算的左侧与右侧 $(q^{2} k_{\\mathrm{B}} T/m) S(q)$进行比较，并报告相对误差 $(\\mathrm{LHS} - \\mathrm{RHS})/\\mathrm{RHS}$。\n\n测试套件：\n使用以下四个测试用例，这些用例具有固定的物理参数和变化的离散化设置。对于所有情况，使用 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\,\\mathrm{J}\\,\\mathrm{K}^{-1}$，$m = 39.948\\times 1.66053906660\\times 10^{-27}\\,\\mathrm{kg}$，$T = 300\\,\\mathrm{K}$，以及 $q = 1.0\\times 10^{9}\\,\\mathrm{m}^{-1}$。窗函数“rectangular”表示对于所有 $n$，$w_{n} = 1$；窗函数“Hann”表示对于 $n \\in \\{0,\\ldots,N-1\\}$，$w_{n} = \\tfrac{1}{2}\\left(1 - \\cos\\left(2\\pi n/(N-1)\\right)\\right)$。\n\n- 情况1（良好解析，矩形窗）：$N = 4096$，$\\Delta t = 1.0\\times 10^{-13}\\,\\mathrm{s}$，矩形窗。\n- 情况2（由于时间步长过大导致 Nyquist 频率不足）：$N = 4096$，$\\Delta t = 2.0\\times 10^{-12}\\,\\mathrm{s}$，矩形窗。\n- 情况3（总时间短且频率分辨率粗糙）：$N = 256$，$\\Delta t = 1.0\\times 10^{-13}\\,\\mathrm{s}$，矩形窗。\n- 情况4（Hann 窗修改了时间信号）：$N = 4096$，$\\Delta t = 1.0\\times 10^{-13}\\,\\mathrm{s}$，Hann 窗。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述四个情况的顺序排列结果。每个条目必须是该情况下的相对误差，表示为一个浮点数（无量纲）。例如，形如 $[x_{1},x_{2},x_{3},x_{4}]$ 的输出，其中每个 $x_{i}$ 是情况 $i$ 的相对误差。",
            "solution": "该问题要求对理想单原子气体的经典 $f$-求和规则进行数值测试。验证过程确认了该问题在科学上是合理的、提法是适定的，并且包含了所有必要信息。因此，我们可以着手进行求解。\n\n解决方案包括三个主要部分：\n1.  理想气体中间散射函数 $F(q, t)$ 的解析推导，它构成了合成时间序列的基础。\n2.  对该系统的 $f$-求和规则进行解析验证，以确立所要测试的精确理论关系。\n3.  一个数值实现，该实现从合成的 $F(q, t)$ 计算动态结构因子的二阶频率矩，并将其与理论预测进行比较，然后分析在指定测试用例中观察到的数值误差。\n\n**1. 理想气体中间散射函数的解析形式**\n\n中间散射函数 (ISF) 定义为 $F(\\mathbf{q}, t) = N^{-1} \\langle \\rho(\\mathbf{q}, t)\\rho(-\\mathbf{q}, 0) \\rangle$，其中 $\\rho(\\mathbf{q}, t) = \\sum_{j=1}^{N} e^{-i\\mathbf{q}\\cdot\\mathbf{r}_j(t)}$ 是密度的傅里叶分量。对于理想气体，粒子的位置和速度是不相关的。因此，对于均匀系统，$F(\\mathbf{q}, t)$ 展开式中的交叉项（$j \\neq k$）消失，求和简化为对单个粒子轨迹的平均：$F(\\mathbf{q}, t) = \\langle e^{-i\\mathbf{q}\\cdot(\\mathbf{r}(t) - \\mathbf{r}(0))} \\rangle$。\n\n理想气体中的粒子进行弹道运动，因此 $\\mathbf{r}(t) = \\mathbf{r}(0) + \\mathbf{v}t$。位移为 $\\mathbf{r}(t) - \\mathbf{r}(0) = \\mathbf{v}t$。ISF 变为对速度分布的平均：\n$$F(\\mathbf{q}, t) = \\langle e^{-i\\mathbf{q}\\cdot\\mathbf{v}t} \\rangle$$\n该平均是针对质量为 $m$、温度为 $T$ 的单原子气体的 Maxwell-Boltzmann 速度分布进行的：\n$$P(\\mathbf{v}) = \\left(\\frac{m}{2\\pi k_{\\mathrm{B}} T}\\right)^{3/2} \\exp\\left(-\\frac{m |\\mathbf{v}|^2}{2 k_{\\mathrm{B}} T}\\right)$$\n该平均是此高斯分布的特征函数。通过将一个轴（例如 $v_z$）与 $\\mathbf{q}$ 对齐，积分可以分离，并通过配方法或识别其为高斯函数的傅里叶变换来求解。其结果仅取决于大小 $q = |\\mathbf{q}|$，为：\n$$F(q, t) = \\exp\\left(-\\frac{q^2 k_{\\mathrm{B}} T}{2m} t^2\\right)$$\n这个关于时间的高斯函数是理想气体的精确 ISF。静态结构因子为 $S(q) = F(q, 0) = 1$，这是无相互作用系统的一个已知结果。\n\n**2. $f$-求和规则的解析验证**\n\n$f$-求和规则将动态结构因子 $S(q, \\omega)$ 的二阶频率矩与热学性质联系起来：\n$$\\int_{-\\infty}^{\\infty} \\omega^{2} S(q, \\omega)\\, \\mathrm{d}\\omega = \\frac{q^{2} k_{\\mathrm{B}} T}{m} S(q)$$\n对于我们的理想气体，$S(q)=1$，因此右侧 (RHS) 为 $\\frac{q^{2} k_{\\mathrm{B}} T}{m}$。\n\n左侧 (LHS) 可以使用傅里叶变换的矩定理来计算。根据问题给出的约定 $S(q, \\omega) = (2\\pi)^{-1} \\int_{-\\infty}^{\\infty} e^{i \\omega t} F(q, t) \\mathrm{d}t$，二阶矩与 $F(q, t)$ 在 $t=0$ 处的二阶导数相关：\n$$\\int_{-\\infty}^{\\infty} \\omega^{2} S(q, \\omega)\\, \\mathrm{d}\\omega = i^2 \\frac{\\mathrm{d}^2 F(q, t)}{\\mathrm{d}t^2}\\bigg|_{t=0} = -\\frac{\\mathrm{d}^2 F(q, t)}{\\mathrm{d}t^2}\\bigg|_{t=0}$$\n让我们定义 $\\alpha = \\frac{q^2 k_{\\mathrm{B}} T}{2m}$，因此 $F(q, t) = e^{-\\alpha t^2}$。其导数为：\n$$\\frac{\\mathrm{d}F}{\\mathrm{d}t} = -2\\alpha t e^{-\\alpha t^2}$$\n$$\\frac{\\mathrm{d}^2F}{\\mathrm{d}t^2} = (-2\\alpha + 4\\alpha^2 t^2) e^{-\\alpha t^2}$$\n在 $t=0$ 处求值得到 $\\frac{\\mathrm{d}^2F}{\\mathrm{d}t^2}\\big|_{t=0} = -2\\alpha$。\n因此，LHS 为 $-(-2\\alpha) = 2\\alpha = 2\\left(\\frac{q^2 k_{\\mathrm{B}} T}{2m}\\right) = \\frac{q^2 k_{\\mathrm{B}} T}{m}$。\nLHS 等于 RHS，因此 $f$-求和规则在解析上得到满足。\n\n**3. 数值测试和误差分析**\n\n任务是数值计算 LHS 并将其与解析的 RHS 进行比较。指定的数值步骤如下：\n1.  在离散时间网格 $t_n = (n-N/2)\\Delta t$ 上对函数 $G(t) = F(q, t)w(t)$ 进行采样。\n2.  计算其离散傅里叶变换 (DFT)，$\\tilde{G}_k$。\n3.  使用 DFT 来近似傅里叶积分 $\\tilde{G}(\\omega) \\approx \\Delta t \\cdot \\tilde{G}_k$（相位因子由 `fftshift` 处理）。\n4.  使用对 DFT 频率 $\\omega_k$ 的离散求和来近似积分 $\\int \\omega^2 S(q,\\omega) \\mathrm{d}\\omega$。\n\n连续傅里叶变换与 DFT 之间的关系，加上 $S(q,\\omega)$ 的指定定义，导出了数值估算的 LHS 的以下公式：\n$$LHS_{\\text{num}} = \\frac{1}{N} \\sum_{k=0}^{N-1} \\omega_k^2 \\tilde{G}_k$$\n其中 $\\tilde{G}_k$ 是时间中心化的加窗信号 $G_n$ 的 DFT，$\\omega_k$ 是来自 DFT 的相应角频率。相对误差则为 $(\\mathrm{LHS}_{\\text{num}} - \\mathrm{RHS}) / \\mathrm{RHS}$。\n\n指定的测试用例旨在揭示数值信号处理中的常见陷阱：\n\n-   **情况1（基准）：** 使用大量的点 $N$ 和小的时间步长 $\\Delta t$，时域信号 $F(q,t)$ 在其振幅可忽略不计的时间范围内都得到了很好的采样。这最大限度地减少了混叠（由于小 $\\Delta t$）和截断/泄漏（由于总时间 $N\\Delta t$ 较长）。频率分辨率很好。我们预计数值误差会非常小。\n\n-   **情况2（混叠）：** 时间步长 $\\Delta t = 2.0 \\times 10^{-12}\\,\\mathrm{s}$ 大于 $F(q,t)$ 的特征衰减时间 $\\tau = \\sqrt{2m/(q^2 k_{\\mathrm{B}} T)} \\approx 1.79 \\times 10^{-12}\\,\\mathrm{s}$。这违反了 Nyquist 采样准则，因为 Nyquist 频率 $\\omega_{\\text{Nyq}} = \\pi/\\Delta t$ 与 $S(q,\\omega)$ 的谱宽相当。来自频率 $|\\omega|  \\omega_{\\text{Nyq}}$ 的谱功率被“折叠”到采样频率范围内。由于求和规则积分按 $\\omega^2$ 对频谱进行加权，高频分量至关重要。混叠将这些大的贡献映射到较低的频率，在这些频率上它们被较小的 $\\omega^2$ 加权，导致对积分的显著低估和大的负误差。\n\n-   **情况3（频率分辨率差）：** 点数 $N=256$ 很小，导致总时间跨度 $T_{\\text{tot}} = N\\Delta t$ 很短。这导致了粗糙的频率网格，因为频率分辨率为 $\\Delta\\omega = 2\\pi/T_{\\text{tot}}$。函数 $\\omega^2 S(q,\\omega)$ 仅在几个点上采样，使得离散和成为连续积分的一个很差的近似（求积误差）。这会导致一个明显但并非灾难性的误差。\n\n-   **情况4（加窗）：** 应用非矩形窗（例如 Hann 窗）会修改信号。时域中的乘法对应于频域中的卷积。计算出的频谱是真实 $S(q,\\omega)$ 与窗函数傅里叶变换 $\\tilde{w}(\\omega)$ 的卷积。这个卷积频谱的二阶矩是原始谱二阶矩之和：$M_2(G) = M_2(F) + M_2(w)$，假设进行了适当的归一化。物理矩为 $M_2(F) = -F''(0)$。窗函数贡献了一个附加项 $M_2(w) = -w''(0)$。因此，数值测试计算的是 $-F''(0)w(0) - F(0)w''(0)$，而不仅仅是 $-F''(0)$。这引入了一个系统误差，该误差取决于窗函数在 $t=0$ 处的值和二阶导数。对于指定的 Hann 窗和时间网格，这会导致一个微小但明显的正误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a numerical test of the f-sum rule for an ideal gas\n    based on synthesized intermediate scattering function data.\n    \"\"\"\n    \n    # Physical and numerical parameters from the problem statement.\n    test_cases = [\n        # Case 1: Well-resolved, rectangular window\n        {'N': 4096, 'dt': 1.0e-13, 'window_name': 'rectangular'},\n        # Case 2: Insufficient Nyquist frequency (aliasing)\n        {'N': 4096, 'dt': 2.0e-12, 'window_name': 'rectangular'},\n        # Case 3: Short total time (poor frequency resolution)\n        {'N': 256, 'dt': 1.0e-13, 'window_name': 'rectangular'},\n        # Case 4: Hann window modifies the time signal\n        {'N': 4096, 'dt': 1.0e-13, 'window_name': 'hann'},\n    ]\n\n    # Fixed physical constants\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n    m_u = 1.66053906660e-27  # Atomic mass unit in kg\n    \n    # System parameters for Argon at 300K\n    m = 39.948 * m_u  # Mass of Argon atom in kg\n    T = 300.0  # Temperature in K\n    q = 1.0e9  # Wavevector magnitude in m^-1\n\n    # Analytically calculate the right-hand side (RHS) of the f-sum rule.\n    # For an ideal gas, the static structure factor S(q) = 1.\n    rhs_analytical = (q**2 * k_B * T) / m\n\n    results = []\n    \n    for case in test_cases:\n        N = case['N']\n        dt = case['dt']\n        window_name = case['window_name']\n        \n        # 1. Define time and frequency grids\n        # Time grid is centered at t=0, as per problem spec\n        t = (np.arange(N) - N / 2) * dt\n        # Angular frequencies from np.fft.fftfreq correspond to the output of np.fft.fft\n        omega = 2 * np.pi * np.fft.fftfreq(N, d=dt)\n\n        # 2. Synthesize the intermediate scattering function F(q,t) for an ideal gas\n        alpha = (q**2 * k_B * T) / (2 * m)\n        F_t = np.exp(-alpha * t**2)\n\n        # 3. Apply the specified window function\n        if window_name == 'rectangular':\n            w = np.ones(N)\n        elif window_name == 'hann':\n            # Per problem spec: w_n = 0.5 * (1 - cos(2*pi*n/(N-1))) for n in {0..N-1}\n            n_idx = np.arange(N)\n            w = 0.5 * (1 - np.cos(2 * np.pi * n_idx / (N - 1)))\n        \n        # Windowed time-domain signal\n        G_t = F_t * w\n\n        # 4. Compute the Discrete Fourier Transform (DFT)\n        # The signal G_t is defined on a centered time grid [-T/2, T/2).\n        # To use np.fft.fft, which assumes a grid [0, T), we must rearrange\n        # the signal using np.fft.ifftshift.\n        G_shifted_for_fft = np.fft.ifftshift(G_t)\n        dft_G = np.fft.fft(G_shifted_for_fft)\n\n        # 5. Numerically evaluate the LHS of the sum rule via discrete quadrature\n        # The second moment integral is approximated by a sum over discrete frequencies.\n        # The derivation in the solution text shows this simplifies to:\n        # LHS_numerical = (1/N) * sum(omega_k^2 * DFT(G)_k)\n        # Note: In the Fourier transform convention S(q,w) = (1/2pi) * integral,\n        # the moment theorem is integral w^n S(q,w) dw = (-i)^n d^n F(t)/dt^n at t=0.\n        # The DFT relation to the integral is DFT[f(t)] * dt approx FT[f(t)].\n        # So S(q,w_k) approx (1/2pi) * dft_G_k * dt.\n        # integral w^2 S(q,w) dw approx sum(w_k^2 * S(q,w_k) * dw)\n        # dw = 2pi / (N*dt).\n        # So approx sum(w_k^2 * (1/2pi) * dft_G_k * dt * 2pi / (N*dt))\n        # = sum(w_k^2 * dft_G_k / N)\n        summand = omega**2 * dft_G\n        \n        # G_t is a real-valued function with near-perfect even symmetry. Its DFT\n        # should be real-valued. We take np.real to discard negligible\n        # imaginary components arising from floating-point inaccuracies.\n        lhs_numerical = np.real(np.sum(summand)) / N\n\n        # 6. Calculate the relative error\n        relative_error = (lhs_numerical - rhs_analytical) / rhs_analytical\n        results.append(relative_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}