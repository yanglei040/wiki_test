{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在连接理论与实践，演示如何将物理模型拟合到模拟数据。通过推导逻辑斯谛提交者模型的最大似然估计，您将练习一种基本统计技术，该技术用于从短“发射”轨迹的结果中参数化反应坐标 。此问题巩固了随机模拟结果与反应进程定量模型之间的联系。",
            "id": "3402803",
            "problem": "考虑一个高维分子动力学（MD）模拟中，在两个亚稳态盆 $A$ 和 $B$ 之间发生的稀有事件跃迁。提交函数（committor function） $q_{B}(\\mathbf{x})$ 定义为从构型 $\\mathbf{x}$ 开始的轨迹在到达盆 $A$ 之前先到达盆 $B$ 的概率。假设动力学过程是马尔可夫的，并遵循微观可逆性原理，且存在一个一维反应坐标 $r(\\mathbf{x})$，使得 $r=0$ 近似为分割面，并且映射 $r \\mapsto q_{B}$ 是严格递增的，并且由于盆沿 $r$ 的对称性，满足 $q_{B}(-r)=1-q_{B}(r)$。\n\n一个标准且有科学依据的建模选择是，假定反应坐标与提交函数之间存在逻辑斯谛联系：\n$$\nq_{B}(r)=\\frac{1}{1+\\exp\\!\\left(-\\beta r\\right)},\n$$\n其中 $\\beta$ 是一个未知的斜率参数，需要通过短轨迹“发射”（shooting）实验来推断。在发射结果相互独立的假设下，从一个固定的 $r$ 值发射的每条轨迹都会产生一个伯努利结果，其成功概率为 $q_{B}(r)$。\n\n你进行了以下实验。在 $r=+r_{0}$ 处，你发射了 $N_{+}$ 条独立的短轨迹，并观察到 $m_{+}$ 条轨迹在到达盆 $A$ 之前先到达了盆 $B$。在 $r=-r_{0}$ 处，你发射了 $N_{-}$ 条独立的短轨迹，并观察到 $m_{-}$ 条轨迹在到达盆 $A$ 之前先到达了盆 $B$。反应坐标 $r$ 是无量纲的，因此斜率 $\\beta$ 也是无量纲的。给定由微观可逆性和上述逻辑斯谛联系所蕴含的对称性 $q_{B}(-r)=1-q_{B}(r)$，构建观测数据的似然函数，并从第一性原理出发，推导出 $\\beta$ 的最大似然估计（以 $N_{+}$、$N_{-}$、$m_{+}$、$m_{-}$ 和 $r_{0}$ 表示）。\n\n然后，使用数值 $r_{0}=0.85$、$N_{+}=40$、$m_{+}=29$、$N_{-}=45$ 和 $m_{-}=11$，计算最大似然估计 $\\hat{\\beta}$ 的数值。将你的最终答案四舍五入到四位有效数字。由于 $\\beta$ 是无量纲的，报告数值时无需单位。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于统计力学和最大似然估计的原理，问题设定完整且一致，表述清晰，并以客观、正式的语言表达。因此，我们可以着手求解。\n\n目标是基于两组发射实验的数据，为给定的提交函数逻辑斯谛模型，找到斜率参数 $\\beta$ 的最大似然估计（MLE）。\n\n提交函数被建模为反应坐标 $r$ 的逻辑斯谛函数，形式如下：\n$$\nq_{B}(r) = \\frac{1}{1 + \\exp(-\\beta r)}\n$$\n短轨迹的结果是独立的伯努利试验。对于从反应坐标值为 $r$ 的构型发射的轨迹，到达盆 $B$ 的概率是 $p = q_{B}(r)$，到达盆 $A$ 的概率是 $1-p = 1-q_{B}(r)$。\n\n该实验包括两部分：\n1.  在 $r = +r_{0}$ 处，我们进行了 $N_{+}$ 次试验，其中有 $m_{+}$ 次成功（到达 $B$）。此结果的概率由二项概率质量函数给出：\n    $$\n    P(m_{+}|N_{+}, \\beta, r_0) = \\binom{N_{+}}{m_{+}} [q_{B}(r_{0})]^{m_{+}} [1-q_{B}(r_{0})]^{N_{+}-m_{+}}\n    $$\n2.  在 $r = -r_{0}$ 处，我们进行了 $N_{-}$ 次试验，其中有 $m_{-}$ 次成功。此结果的概率为：\n    $$\n    P(m_{-}|N_{-}, \\beta, r_0) = \\binom{N_{-}}{m_{-}} [q_{B}(-r_{0})]^{m_{-}} [1-q_{B}(-r_{0})]^{N_{-}-m_{-}}\n    $$\n\n由于这两个实验是独立的，观测数据的总似然函数 $L(\\beta)$ 是这些概率的乘积：\n$$\nL(\\beta) = \\binom{N_{+}}{m_{+}} [q_{B}(r_{0})]^{m_{+}} [1-q_{B}(r_{0})]^{N_{+}-m_{+}} \\binom{N_{-}}{m_{-}} [q_{B}(-r_{0})]^{m_{-}} [1-q_{B}(-r_{0})]^{N_{-}-m_{-}}\n$$\n为了找到最大似然估计 $\\hat\\beta$，我们对 $L(\\beta)$ 关于 $\\beta$ 进行最大化。由于对数是单调函数，最大化对数似然函数 $\\ell(\\beta) = \\ln L(\\beta)$ 更为方便。二项式系数不依赖于 $\\beta$，因此在优化过程中可以忽略。\n$$\n\\ell(\\beta) = m_{+} \\ln(q_{B}(r_{0})) + (N_{+} - m_{+}) \\ln(1 - q_{B}(r_{0})) + m_{-} \\ln(q_{B}(-r_{0})) + (N_{-} - m_{-}) \\ln(1 - q_{B}(-r_{0})) + C\n$$\n其中 $C$ 是一个常数。我们现在代入 $q_B(r)$ 和 $1-q_B(r)$ 的表达式。\n对于 $q_B(r_0)$：\n$$\nq_{B}(r_{0}) = \\frac{1}{1+\\exp(-\\beta r_{0})} \\implies \\ln(q_{B}(r_{0})) = -\\ln(1+\\exp(-\\beta r_{0}))\n$$\n$$\n1-q_{B}(r_{0}) = \\frac{\\exp(-\\beta r_{0})}{1+\\exp(-\\beta r_{0})} \\implies \\ln(1-q_{B}(r_{0})) = -\\beta r_{0} - \\ln(1+\\exp(-\\beta r_{0}))\n$$\n对于 $q_B(-r_0)$：\n$$\nq_{B}(-r_{0}) = \\frac{1}{1+\\exp(\\beta r_{0})} \\implies \\ln(q_{B}(-r_{0})) = -\\ln(1+\\exp(\\beta r_{0}))\n$$\n$$\n1-q_{B}(-r_{0}) = \\frac{\\exp(\\beta r_{0})}{1+\\exp(\\beta r_{0})} \\implies \\ln(1-q_{B}(-r_{0})) = \\beta r_{0} - \\ln(1+\\exp(\\beta r_{0}))\n$$\n将这些代入对数似然函数：\n$$\n\\ell(\\beta) = m_{+}[-\\ln(1+\\exp(-\\beta r_{0}))] + (N_{+}-m_{+})[-\\beta r_{0} - \\ln(1+\\exp(-\\beta r_{0}))] + m_{-}[-\\ln(1+\\exp(\\beta r_{0}))] + (N_{-}-m_{-})[\\beta r_{0} - \\ln(1+\\exp(\\beta r_{0}))]\n$$\n合并各项：\n$$\n\\ell(\\beta) = - N_{+} \\ln(1+\\exp(-\\beta r_{0})) - N_{-} \\ln(1+\\exp(\\beta r_{0})) - (N_{+}-m_{+})\\beta r_{0} + (N_{-}-m_{-})\\beta r_{0}\n$$\n为了求最大值，我们将 $\\ell(\\beta)$ 对 $\\beta$ 求导，并令导数等于零：\n$$\n\\frac{d\\ell}{d\\beta} = -N_{+}\\left(\\frac{-r_{0}\\exp(-\\beta r_{0})}{1+\\exp(-\\beta r_{0})}\\right) - N_{-}\\left(\\frac{r_{0}\\exp(\\beta r_{0})}{1+\\exp(\\beta r_{0})}\\right) - (N_{+}-m_{+})r_{0} + (N_{-}-m_{-})r_{0} = 0\n$$\n由于 $r_0 \\neq 0$，我们可以将整个方程除以 $r_{0}$：\n$$\nN_{+}\\frac{\\exp(-\\beta r_{0})}{1+\\exp(-\\beta r_{0})} - N_{-}\\frac{\\exp(\\beta r_{0})}{1+\\exp(\\beta r_{0})} - N_{+} + m_{+} + N_{-} - m_{-} = 0\n$$\n注意到 $\\frac{\\exp(-\\beta r_0)}{1+\\exp(-\\beta r_0)} = 1 - q_B(r_0)$ 以及 $\\frac{\\exp(\\beta r_0)}{1+\\exp(\\beta r_0)} = 1-q_B(-r_0)$，我们可以写出：\n$$\nN_{+}(1-q_{B}(r_{0})) - N_{-}(1-q_{B}(-r_{0})) - N_{+} + m_{+} + N_{-} - m_{-} = 0\n$$\n$$\nN_{+} - N_{+}q_{B}(r_{0}) - N_{-} + N_{-}q_{B}(-r_{0}) - N_{+} + m_{+} + N_{-} - m_{-} = 0\n$$\n简化该表达式得到最大似然估计 $\\hat{\\beta}$ 的条件：\n$$\n-N_{+}q_{B}(r_{0}) + N_{-}q_{B}(-r_{0}) + m_{+} - m_{-} = 0\n$$\n$$\nm_{+} - m_{-} = N_{+}q_{B}(r_{0}) - N_{-}q_{B}(-r_{0})\n$$\n现在，我们代回逻辑斯谛函数形式来求解 $\\beta$：\n$$\nm_{+} - m_{-} = \\frac{N_{+}}{1+\\exp(-\\beta r_{0})} - \\frac{N_{-}}{1+\\exp(\\beta r_{0})}\n$$\n为了解这个关于 $\\beta$ 的方程，令 $x = \\exp(\\beta r_{0})$。那么 $\\exp(-\\beta r_{0}) = 1/x$。\n$$\nm_{+} - m_{-} = \\frac{N_{+}}{1+1/x} - \\frac{N_{-}}{1+x} = \\frac{N_{+}x}{x+1} - \\frac{N_{-}}{x+1} = \\frac{N_{+}x - N_{-}}{x+1}\n$$\n现在，我们用代数方法解出 $x$：\n$$\n(m_{+} - m_{-})(x+1) = N_{+}x - N_{-}\n$$\n$$\n(m_{+} - m_{-})x + (m_{+} - m_{-}) = N_{+}x - N_{-}\n$$\n$$\n(m_{+} - m_{-}) + N_{-} = N_{+}x - (m_{+} - m_{-})x\n$$\n$$\nN_{-} + m_{+} - m_{-} = (N_{+} - m_{+} + m_{-})x\n$$\n$$\nx = \\frac{N_{-} + m_{+} - m_{-}}{N_{+} - m_{+} + m_{-}}\n$$\n代回 $x = \\exp(\\beta r_0)$，我们得到：\n$$\n\\exp(\\hat{\\beta} r_0) = \\frac{N_{-} + m_{+} - m_{-}}{N_{+} - m_{+} + m_{-}}\n$$\n最后，通过取自然对数，解出最大似然估计 $\\hat{\\beta}$：\n$$\n\\hat{\\beta} r_0 = \\ln\\left(\\frac{N_{-} + m_{+} - m_{-}}{N_{+} - m_{+} + m_{-}}\\right)\n$$\n$$\n\\hat{\\beta} = \\frac{1}{r_0} \\ln\\left(\\frac{N_{-} + m_{+} - m_{-}}{N_{+} - m_{+} + m_{-}}\\right)\n$$\n这就是 $\\beta$ 的最大似然估计的解析表达式。\n\n现在我们使用给定的数据计算数值：$r_{0}=0.85$，$N_{+}=40$，$m_{+}=29$，$N_{-}=45$ 和 $m_{-}=11$。\n\n首先，我们计算对数函数参数的分子和分母：\n分子：$N_{-} + m_{+} - m_{-} = 45 + 29 - 11 = 63$。\n分母：$N_{+} - m_{+} + m_{-} = 40 - 29 + 11 = 11 + 11 = 22$。\n\n将这些值代入 $\\hat{\\beta}$ 的表达式中：\n$$\n\\hat{\\beta} = \\frac{1}{0.85} \\ln\\left(\\frac{63}{22}\\right)\n$$\n我们计算这些值：\n$$\n\\frac{63}{22} \\approx 2.863636...\n$$\n$$\n\\ln\\left(\\frac{63}{22}\\right) \\approx \\ln(2.863636...) \\approx 1.052184...\n$$\n$$\n\\hat{\\beta} \\approx \\frac{1.052184...}{0.85} \\approx 1.237863...\n$$\n将结果四舍五入到四位有效数字，得到 $1.238$。",
            "answer": "$$\n\\boxed{1.238}\n$$"
        },
        {
            "introduction": "本练习让您亲身体验使用金标准提交者检验来验证反应坐标的过程。您将实现一个完整的计算流程，从业朗之万动力学模拟分子轨迹，到分析所提出等值面上的提交者分布 。这种动手经验对于培养对“好”反应坐标的直觉以及如何通过编程检验其充分性至关重要。",
            "id": "3402833",
            "problem": "您的任务是构建一个基于原理的交叉检验方法，用于验证分子动力学（MD）中提出的一维反应坐标。该方法将使用基于分子系统基本随机动力学的 Committor 分析。考虑一个坐标为 $x$ 和 $y$ 的二维构型空间。该动力学在无量纲单位下通过过阻尼朗之万方程（也称为 Smoluchowski 动力学）进行建模，对于势能 $U(x,y)$，该方程表示为\n$$\ndx_t = -\\mu \\,\\partial_x U(x_t,y_t)\\, dt + \\sqrt{2 D \\, dt}\\, \\eta_x(t), \\quad dy_t = -\\mu \\,\\partial_y U(x_t,y_t)\\, dt + \\sqrt{2 D \\, dt}\\, \\eta_y(t),\n$$\n其中 $\\mu$ 是迁移率，$D$ 是扩散系数，$\\eta_x(t)$ 和 $\\eta_y(t)$ 是每个时间步长上独立的标准正态随机变量。Committor 函数 $q(x_0,y_0)$ 定义为从 $(x_0,y_0)$ 开始的轨迹在到达势阱 $A$ 之前先到达势阱 $B$ 的概率。这里的势阱由 $x$ 上的阈值条件定义，具体来说，势阱 $A$ 是满足 $x \\le x_A$ 的构型集合，势阱 $B$ 是满足 $x \\ge x_B$ 的构型集合，其中 $x_A  0  x_B$。一个提议的反应坐标是一个标量函数 $\\xi(x,y)$；“等值面”是满足 $\\xi(x,y)=c$（其中 $c$ 为常数）的点集。\n\n您的程序必须实现以下验证过程：\n1.  使用过阻尼朗之万动力学作为基本演化定律（无惯性项）。使用 Euler–Maruyama 方法和指定的无量纲单位参数对随机微分方程进行积分。\n2.  对于每个提议的反应坐标 $\\xi(x,y)$ 和每个指定的等值面水平 $c$，通过在一个对称区间内均匀改变 $y$ 并确定满足等值面条件的相应 $x$，来构建等值面 $\\xi(x,y)=c$ 上的一组初始条件。\n3.  对于等值面上的每个初始条件 $(x_0,y_0)$，通过“打靶”来近似 Committor $q(x_0,y_0)$：从 $(x_0,y_0)$ 发射多条独立的过阻尼朗之万轨迹，演化每一条轨迹直到它到达势阱 $A$ 或势阱 $B$ 或达到最大步数，并记录是否在到达势阱 $A$ 之前先到达了势阱 $B$。估计的 Committor $q(x_0,y_0)$ 是首先到达势阱 $B$ 的轨迹所占的比例。\n4.  在固定的等值面水平 $c$ 下，聚合不同初始条件的集合 $\\{q(x_0,y_0)\\}$，并检验 $q$ 的经验分布是否是单峰且窄的。如果对于任何测试的 $c$ 值，固定 $c$ 时的 $q$ 分布未能满足单峰性或不够窄，则判定该反应坐标不充分。\n5.  单峰性必须通过估计经验 $q$ 值的平滑密度并计算不同模式的数量来评估。狭窄性必须通过将 $q$ 值的经验标准差与一个阈值进行比较来评估。\n\n势能指定为\n$$\nU(x,y) = (x^2 - 1)^2 + k \\, y^2,\n$$\n其梯度为\n$$\n\\partial_x U(x,y) = 4x(x^2 - 1), \\quad \\partial_y U(x,y) = 2k y.\n$$\n这在 $x$ 方向上产生一个对称双势阱，其最小值在 $x=\\pm 1$ 附近，在 $y$ 方向上有一个弱约束的二次项。完全在无量纲单位下工作。势阱由 $x_A=-0.9$ 和 $x_B=0.9$ 定义。迁移率为 $\\mu=1$，扩散系数为 $D=0.4$，势能参数为 $k=0.1$。使用时间步长 $dt=0.005$ 和每条轨迹的最大步数 $N_{\\text{max}}=1500$。对于每个等值面和每个初始条件，使用 $N_{\\text{shoot}}=30$ 条打靶轨迹。为了构建等值面初始条件，在区间 $[-Y_{\\max},Y_{\\max}]$（其中 $Y_{\\max}=1$）内均匀采样 $N_{\\text{iso}}=21$ 个 $y$ 值。将到达势阱视为吸收：一旦轨迹满足 $x\\le x_A$ 或 $x\\ge x_B$，它就会终止并被认为分别到达了 $A$ 或 $B$。如果一条轨迹在 $N_{\\text{max}}$ 步内未到达任一势阱，则计为两者都未到达；对于 Committor 估计，只有记录到的首次到达才计入比例中。如果给定初始条件的所有轨迹都未能到达任一势阱，则该初始条件的 Committor 估计应根据对称性设置为 $0.5$。\n\n您必须验证两个候选反应坐标：\n1. $\\xi_1(x,y) = x$。\n2. $\\xi_2(x,y) = x + \\alpha y$，其中 $\\alpha = 1.5$。\n\n要测试的等值面水平为 $c \\in \\{-0.5, 0.0, 0.5\\}$。对于每个候选 $\\xi$ 和每个 $c$，计算在构建的等值面初始条件下的 Committor 估计集 $\\{q(x_0,y_0)\\}$，然后：\n- 在 $q \\in [0,1]$ 上估计平滑密度，并确定最多只有一个模式（单峰性）。\n- 计算 $\\{q\\}$ 值的经验标准差 $\\sigma_q$，并确定它是否最多为狭窄性阈值 $\\sigma_{\\text{th}}=0.12$。\n\n如果对于所有测试的 $c$，固定 $c$ 时的 $q$ 分布都是单峰且窄的，则反应坐标 $\\xi$ 被认为是“充分的”。否则，结论为“不充分”。\n\n您的程序必须生成一行输出，其中包含 $\\xi_1$ 和 $\\xi_2$ 的充分性结论，格式为一个逗号分隔的 Python 布尔值列表，并用方括号括起来，例如 $[{\\rm True},{\\rm False}]$。不允许有其他输出。\n\n必须严格实现的测试套件参数：\n- 势能参数：$k=0.1$。\n- 势阱：$x_A=-0.9$, $x_B=0.9$。\n- 动力学：$\\mu=1$, $D=0.4$, $dt=0.005$, $N_{\\text{max}}=1500$。\n- 打靶：每个初始条件 $N_{\\text{shoot}}=30$ 条轨迹。\n- 等值面采样：$N_{\\text{iso}}=21$ 个点，其中 $y$ 在 $[-1,1]$ 内均匀分布，$Y_{\\max}=1$。\n- 反应坐标：$\\xi_1(x,y)=x$, $\\xi_2(x,y)=x+\\alpha y$ 其中 $\\alpha=1.5$。\n- 等值面水平：$c=-0.5, 0.0, 0.5$。\n- 单峰性检测：在 $q \\in [0,1]$ 上使用平滑密度估计并计算模式数。\n- 狭窄性阈值：$\\sigma_{\\text{th}}=0.12$。\n- 单位：以无量纲单位报告和计算。\n\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，布尔值使用 Python 语法，顺序为 $[\\text{sufficient}(\\xi_1),\\text{sufficient}(\\xi_2)]$。",
            "solution": "用户提供了一个在分子动力学和反应坐标验证领域中定义明确的计算问题。我将首先根据指定标准验证问题陈述。\n\n### 第一步：提取已知条件\n- **势能函数**：$U(x,y) = (x^2 - 1)^2 + k \\, y^2$，其中 $k=0.1$。\n- **势能梯度**：$\\partial_x U(x,y) = 4x(x^2 - 1)$，$\\partial_y U(x,y) = 2k y$。\n- **动力学**：过阻尼朗之万方程（Smoluchowski 动力学），使用 Euler-Maruyama 方法积分。\n  - 迁移率 $\\mu=1$。\n  - 扩散系数 $D=0.4$。\n  - 时间步长 $dt=0.005$。\n- **势阱**：势阱 A 定义为 $x \\le x_A = -0.9$。势阱 B 定义为 $x \\ge x_B = 0.9$。\n- **轨迹终止**：轨迹在到达一个势阱或达到最大步数 $N_{\\text{max}}=1500$ 后终止。\n- **Committor 估计**：基于每个初始点的 $N_{\\text{shoot}}=30$ 条轨迹。Committor $q$ 是先到达 B 的轨迹所占的比例。如果没有轨迹到达任一势阱，则 $q$ 设置为 $0.5$。\n- **等值面采样**：对于每个等值面，通过在 $[-1,1]$（$Y_{\\max}=1$）中均匀采样 $y$ 并求解 $x$ 来生成 $N_{\\text{iso}}=21$ 个初始点。\n- **待测试的反应坐标 (RCs)**：\n  1. $\\xi_1(x,y) = x$。\n  2. $\\xi_2(x,y) = x + \\alpha y$，其中 $\\alpha = 1.5$。\n- **待测试的等值面水平**：$c \\in \\{-0.5, 0.0, 0.5\\}$。\n- **验证标准**：一个 RC 被视为“充分的”，如果对于所有测试的等值面水平 $c$，其 Committor 值 $\\{q\\}$ 的分布同时满足：\n  1. **单峰性**：$\\{q\\}$ 值的估计平滑概率密度最多只有一个模式。\n  2. **狭窄性**：$\\{q\\}$ 值的经验标准差 $\\sigma_q$ 小于或等于阈值 $\\sigma_{\\text{th}}=0.12$。\n- **输出格式**：一个 Python 布尔值列表，表示 $\\xi_1$ 和 $\\xi_2$ 的充分性：`[sufficient(xi_1), sufficient(xi_2)]`。\n\n### 第二步：使用提取的已知条件进行验证\n1.  **科学基础**：该问题植根于统计力学和计算化学的基本原理。使用朗之万方程、Committor 分析和等值面测试来验证反应坐标是分子模拟和稀有事件动力学领域的标准、成熟方法。势函数是用于此类研究的经典双势阱模型。\n2.  **定义明确**：问题定义清晰，所有必要的参数、方程和数值程序都已指定。判断标准（“充分的”vs.“不充分的”）是客观和定量的。这种结构确保了可以通过算法确定唯一的解决方案。\n3.  **客观性**：问题以精确、无偏见的术语陈述。验证标准（单峰性、狭窄性）基于定量度量（KDE 的模式计数、标准差阈值），消除了主观性。\n4.  **完整性与一致性**：问题陈述是自洽的。没有矛盾。虽然“平滑密度估计”没有具体到核函数和带宽，但使用像高斯核密度估计（KDE）这样的标准方法，并采用默认的带宽启发式方法（如 `scipy.stats.gaussian_kde` 使用的 Scott's 或 Silverman's rule），是一种合理且标准的解释，不会损害问题的有效性。\n5.  **可行性**：计算量很大但可控。总模拟步数约为 $2 \\text{ (RCs)} \\times 3 \\text{ (levels)} \\times 21 \\text{ (points)} \\times 30 \\text{ (shots)} \\times 1500 \\text{ (steps)} \\approx 5.67 \\times 10^6$。这对于现代计算机进行单次运行是完全可行的。\n6.  **未检测到其他缺陷**：问题不是微不足道的、隐喻性的或超出科学验证范围的。\n\n### 第三步：结论与行动\n该问题是**有效的**。我将继续构建解决方案。\n\n解决方案将以单个 Python 脚本的形式实现。核心逻辑涉及一系列嵌套函数来管理模拟和分析工作流程。\n\n1.  **`solve()`**：协调整个过程的主函数。它将定义所有问题参数和辅助函数。它将遍历两种反应坐标，评估其充分性，并格式化最终输出。\n2.  **`grad_U(x, y)`**：一个计算势能梯度的辅助函数，该梯度决定了朗之万方程中的确定性力。\n3.  **`run_trajectory(x0, y0)`**：该函数使用 Euler-Maruyama 方法从 `(x0, y0)` 开始模拟单个轨迹。它返回首先到达的势阱（'A' 或 'B'），如果轨迹超时则返回 'None'。\n4.  **`calculate_committor(x0, y0)`**：该函数通过从给定起始点调用 `run_trajectory` $N_{\\text{shoot}}$ 次来执行“打靶”。然后，它计算 Committor 估计值，即首先到达势阱 B 的轨迹比例，并应用没有轨迹到达任一势阱的特殊规则。\n5.  **`count_modes(data)`**：该函数将接收一个 Committor 值列表，使用 `scipy.stats.gaussian_kde` 计算平滑概率密度，然后计算所得密度曲线中的模式数量。这对于单峰性测试至关重要。我的实现将计算离散化密度函数中的局部最大值。为稳健处理各种分布形状（包括单调分布），它将检查域内部以及边界处的峰值。\n6.  **`test_rc(rc_x_generator, levels)`**：该函数整合了对单个反应坐标的验证。它遍历指定的等值面 `levels`。对于每个水平，它生成等值面上的初始条件，计算这些点的 Committor 值，然后检查单峰性和狭窄性。如果任何水平未能通过任一测试，函数立即返回 `False`，表示该 RC 不充分。如果所有水平都通过，则返回 `True`。\n\n这种结构化方法将问题的要求直接映射到计算算法中，确保所有条件和参数都得到遵守。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import gaussian_kde\n\ndef solve():\n    \"\"\"\n    Main function to validate reaction coordinates using committor analysis.\n    \"\"\"\n    # Define problem parameters\n    K = 0.1\n    X_A = -0.9\n    X_B = 0.9\n    MU = 1.0\n    D = 0.4\n    DT = 0.005\n    N_MAX = 1500\n    N_SHOOT = 30\n    N_ISO = 21\n    Y_MAX = 1.0\n    ALPHA = 1.5\n    SIGMA_TH = 0.12\n    ISO_LEVELS = [-0.5, 0.0, 0.5]\n    \n    # Pre-calculate noise standard deviation for efficiency\n    NOISE_STD = np.sqrt(2 * D * DT)\n\n    def grad_U(x, y):\n        \"\"\"Computes the gradient of the potential energy U(x,y).\"\"\"\n        grad_x = 4.0 * x * (x**2 - 1.0)\n        grad_y = 2.0 * K * y\n        return grad_x, grad_y\n\n    def run_trajectory(x0, y0):\n        \"\"\"\n        Simulates a single overdamped Langevin trajectory.\n        Returns 'A' or 'B' if a basin is reached, otherwise 'None'.\n        \"\"\"\n        x, y = x0, y0\n        # Generate all random numbers at once for vectorization\n        noise_x = np.random.randn(N_MAX) * NOISE_STD\n        noise_y = np.random.randn(N_MAX) * NOISE_STD\n        \n        for i in range(N_MAX):\n            grad_x, grad_y = grad_U(x, y)\n            x += -MU * grad_x * DT + noise_x[i]\n            y += -MU * grad_y * DT + noise_y[i]\n            \n            if x = X_A:\n                return 'A'\n            if x >= X_B:\n                return 'B'\n        return 'None'\n\n    def calculate_committor(x0, y0):\n        \"\"\"\n        Estimates the committor value q(x0, y0) by shooting multiple trajectories.\n        \"\"\"\n        a_hits = 0\n        b_hits = 0\n        for _ in range(N_SHOOT):\n            result = run_trajectory(x0, y0)\n            if result == 'A':\n                a_hits += 1\n            elif result == 'B':\n                b_hits += 1\n        \n        total_hits = a_hits + b_hits\n        if total_hits == 0:\n            return 0.5\n        return b_hits / total_hits\n\n    def count_modes(data, grid_size=100):\n        \"\"\"\n        Estimates the number of modes in a dataset using KDE.\n        At most one mode is considered 'unimodal'.\n        \"\"\"\n        if len(data)  2 or np.allclose(data, data[0]):\n            return 1\n\n        try:\n            # Use default bandwidth selection (Scott's rule)\n            kde = gaussian_kde(data)\n            grid = np.linspace(0, 1, grid_size)\n            density = kde.evaluate(grid)\n        except (np.linalg.LinAlgError, ValueError):\n            return 1  # Fallback for singular matrix cases\n\n        # Find local maxima to count modes\n        modes = 0\n        # Check for internal modes (peaks)\n        for i in range(1, len(density) - 1):\n            if density[i] > density[i-1] and density[i] > density[i+1]:\n                modes += 1\n        \n        # Check for modes at the boundaries\n        if density[0] > density[1]:\n            modes += 1\n        if density[-1] > density[-2]:\n            modes += 1\n            \n        # A montonic distribution will have 1 mode at a boundary.\n        # A flat distribution will have 0 modes. We consider 0 modes as passing the\n        # \"at most one mode\" test.\n        if modes == 0 and not np.allclose(density, density[0]):\n             # This means monotonic or a single very broad peak, treat as unimodal\n             return 1\n        \n        return modes\n\n    def test_rc (rc_x_generator, levels_to_test):\n        \"\"\"\n        Tests a reaction coordinate for sufficiency across specified isosurface levels.\n        \"\"\"\n        for c in levels_to_test:\n            y_values = np.linspace(-Y_MAX, Y_MAX, N_ISO)\n            initial_conditions = [(rc_x_generator(y, c), y) for y in y_values]\n            \n            q_values = [calculate_committor(x0, y0) for x0, y0 in initial_conditions]\n            \n            q_std = np.std(q_values)\n            is_narrow = (q_std = SIGMA_TH)\n            \n            num_modes = count_modes(q_values)\n            is_unimodal = (num_modes = 1)\n            \n            if not (is_unimodal and is_narrow):\n                return False  # Fails early if any level is insufficient\n        return True\n\n    # Define generators for x-coordinates on isosurfaces\n    rc1_gen = lambda y, c: c\n    rc2_gen = lambda y, c: c - ALPHA * y\n    \n    # Perform validation for both reaction coordinates\n    results = [\n        test_rc(rc1_gen, ISO_LEVELS),\n        test_rc(rc2_gen, ISO_LEVELS)\n    ]\n    \n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的分子模拟总是会受到数值误差的影响，区分这些人为误差和真实的物理效应至关重要。本练习处理了提交者计算中积分器时间步长偏差的关键问题，教您如何使用理查森外推法提高准确性，并利用统计检验来诊断观察到的不一致性是由数值误差还是真正无效的反应坐标引起的 。此实践有助于培养确保模拟研究数值严谨性的基本技能。",
            "id": "3402822",
            "problem": "考虑一个在过阻尼朗之万随机微分方程下演化的系统，其构型 $\\mathbf{x}$ 的动力学遵循 $d\\mathbf{x}_t = -\\beta D \\nabla U(\\mathbf{x}_t)\\, dt + \\sqrt{2D}\\, d\\mathbf{W}_t$，其中 $\\beta$ 是温度参数，$D$ 是扩散系数，$U(\\mathbf{x})$ 是势能，$\\mathbf{W}_t$ 是维纳过程。committor 函数 $q(\\mathbf{x})$ 定义为从 $\\mathbf{x}$ 开始的轨迹在到达反应物集 $A$ 之前先到达目标集 $B$ 的概率，并且该函数满足在 $A$ 和 $B$ 上具有吸收边界条件的后向 Kolmogorov 方程。在分子模拟实践中，$q(\\mathbf{x})$ 通过经验方式估计，即当使用有限时间步长 $\\Delta t$ 和选定的积分器进行积分时，击中 $B$ 先于 $A$ 的发射轨迹所占的比例。将这种有限时间步长的估计值记为 $q_{\\Delta t}(\\mathbf{x})$。对于一个弱阶为 $p$（其中 $p$ 是正整数）的积分器，在固定 $\\mathbf{x}$ 处，committor 估计中的弱离散化偏差通常可展开为如下形式：$q_{\\Delta t}(\\mathbf{x}) = q_{0}(\\mathbf{x}) + c(\\mathbf{x}) \\, (\\Delta t)^{p} + \\mathcal{O}((\\Delta t)^{p+1})$，其中 $q_{0}(\\mathbf{x})$ 是 $\\Delta t \\to 0$ 时的极限，$c(\\mathbf{x})$ 是一个依赖于积分器和状态的系数。此外，从 $n$ 条独立的发射轨迹计算出的每个 $q_{\\Delta t}(\\mathbf{x})$ 的经验估计都是一个二项比例，其随机抽样误差的量级为 $\\sqrt{q_{\\Delta t}(\\mathbf{x})(1-q_{\\Delta t}(\\mathbf{x}))/n}$。\n\n您的任务是实现一个有原则的程序，该程序在给定两个步长 $\\Delta t$ 和 $\\Delta t/2$ 下、针对单个反应坐标值 $s$ 的有限时间步长 committor 实验的经验计数后，将：\n- 基于积分器已知的弱阶 $p$ 使用 Richardson 外推法来估计 $q_{0}(\\mathbf{x})$。\n- 执行统计检验，以判断观测到的 $q_{\\Delta t}(\\mathbf{x})$ 和 $q_{\\Delta t/2}(\\mathbf{x})$ 之间的差异相对于二项抽样噪声是否具有统计显著性，从而表明在测试尺度上存在可检测的积分器偏差。\n- 对共享相同反应坐标值 $s$ 但在正交自由度上有所不同的多个微观状态 $\\{\\mathbf{x}_i\\}$ 执行“等 committor 一致性”过度离散检验。仅使用较小的时间步长 $\\Delta t/2$ 以最小化偏差，确定在 $\\{\\mathbf{x}_i\\}$ 中，经验 committor 估计值的变异性是否超过了仅由二项抽样所预期的变异性（这将表明反应坐标在 $s$ 处无效）。\n\n从第一性原理出发，您的方法应基于以下核心定义和经过充分检验的事实：\n- committor $q(\\mathbf{x})$ 是具有吸收集 $A$ 和 $B$ 的马尔可夫过程的分裂概率。\n- 对于一个弱阶为 $p$ 的积分器，足够光滑的可观测量期望值的弱误差尺度为 $\\mathcal{O}((\\Delta t)^p)$。\n- 来自 $n$ 次独立试验且有 $k$ 次“成功”（在到达 $A$ 之前到达 $B$）的经验 committor 比例 $\\hat{q} = k/n$ 是一个二项比例。\n- 对于两个独立的二项比例 $\\hat{q}_1$ 和 $\\hat{q}_2$，其计数分别为 $(k_1,n_1)$ 和 $(k_2,n_2)$，可以使用合并比例 $z$ 检验来评估在指定的显著性水平下，$\\hat{q}_1 - \\hat{q}_2$ 是否超出抽样误差范围而偏离零。\n- 比较观测计数 $\\{k_i\\}$ 与跨微观状态的具有试验次数 $\\{n_i\\}$ 的共同概率零假设模型，可以使用 Pearson 卡方统计量来检验是否存在超出二项抽样的过度离散（过度变异）。\n\n请用纯数学和逻辑术语实现以下内容：\n- 给定弱阶 $p$ 以及在步长 $\\Delta t$ 和 $\\Delta t/2$ 下的经验比例 $\\hat{q}_{\\Delta t}$ 和 $\\hat{q}_{\\Delta t/2}$，使用 Richardson 外推法构建一个偏差减小的 $q_0$ 估计器，该估计器能消除领先的 $\\mathcal{O}((\\Delta t)^p)$ 项。不要假设高阶系数的具体形式，只需考虑其数量级。\n- 使用双边显著性水平 $\\alpha = 0.05$ 的双比例合并 $z$ 检验来确定 $\\hat{q}_{\\Delta t}$ 和 $\\hat{q}_{\\Delta t/2}$ 之间的差异是否表明在测试尺度上存在可检测的积分器偏差。以布尔值形式回答该决策，其中 $True$ 表示“检测到积分器偏差”，$False$ 表示“未检测到积分器偏差”。\n- 对于等 committor 一致性检验，仅使用在相同 $s$ 值的多个微观状态下 $\\Delta t/2$ 的数据，检验所有微观状态共享一个共同的 committor $q$ 且任何变异性仅由二项噪声引起的零假设。使用自由度为微观状态数减一的 Pearson 卡方统计量和双边显著性水平 $\\alpha = 0.05$。返回一个布尔值，其中 $True$ 表示“检测到反应坐标无效性”，$False$ 表示“在测试精度下没有反应坐标无效的证据”。\n- 此外，返回一个布尔值，报告 Richardson 外推估计的 $q_0$ 是否落在物理上允许的区间 $[0,1]$ 之外，这可能表明在测试尺度上存在模型不匹配或未解决的高阶效应。\n\n测试套件：\n您的程序必须将上述过程应用于以下三种情况。每种情况都提供了弱阶 $p$、在 $\\Delta t$ 和 $\\Delta t/2$ 下的聚合计数，以及用于等 committor 一致性检验的一组在 $\\Delta t/2$ 下的微观状态级计数。所有计数都是独立的二项式结果。\n\n- 情况 1（垒中，一阶积分器）：\n  - 弱阶：$p = 1$。\n  - $\\Delta t$ 下的聚合计数：$n_1 = 20000$, $k_1 = 10400$。\n  - $\\Delta t/2$ 下的聚合计数：$n_2 = 20000$, $k_2 = 10200$。\n  - $\\Delta t/2$ 下的微观状态（相同的 $s$，四个不同的微观状态）：$(n_i, k_i) \\in \\{(4000, 1400), (4000, 2000), (4000, 2600), (4000, 2000)\\}$。\n\n- 情况 2（近反应物盆，二阶积分器）：\n  - 弱阶：$p = 2$。\n  - $\\Delta t$ 下的聚合计数：$n_1 = 10000$, $k_1 = 520$。\n  - $\\Delta t/2$ 下的聚合计数：$n_2 = 10000$, $k_2 = 505$。\n  - $\\Delta t/2$ 下的微观状态（相同的 $s$，四个不同的微观状态）：$(n_i, k_i) \\in \\{(4000, 192), (4000, 204), (4000, 208), (4000, 196)\\}$。\n\n- 情况 3（近产物，一阶积分器，边界效应）：\n  - 弱阶：$p = 1$。\n  - $\\Delta t$ 下的聚合计数：$n_1 = 8000$, $k_1 = 7760$。\n  - $\\Delta t/2$ 下的聚合计数：$n_2 = 8000$, $k_2 = 7920$。\n  - $\\Delta t/2$ 下的微观状态（相同的 $s$，四个不同的微观状态）：$(n_i, k_i) \\in \\{(4000, 3960), (4000, 3975), (4000, 3965), (4000, 3972)\\}$。\n\n最终输出规范：\n- 对于每种情况，生成一个包含四个条目的列表：$[q^{\\mathrm{Rich}}_{0}, \\mathrm{bias\\_detected}, \\mathrm{rc\\_invalid}, \\mathrm{out\\_of\\_bounds}]$，其中：\n  - $q^{\\mathrm{Rich}}_{0}$ 是零时间步长 committor 的 Richardson 外推估计值，四舍五入到六位小数。\n  - $\\mathrm{bias\\_detected}$ 是一个来自显著性水平为 $\\alpha = 0.05$ 的双比例 $z$ 检验的布尔值。\n  - $\\mathrm{rc\\_invalid}$ 是一个来自显著性水平为 $\\alpha = 0.05$ 的等 committor 卡方检验的布尔值。\n  - $\\mathrm{out\\_of\\_bounds}$ 是一个布尔值，如果 $q^{\\mathrm{Rich}}_{0} \\notin [0,1]$ 则为 $True$，否则为 $False$。\n- 您的程序应生成一行输出，其中包含三个情况的结果，形式为一个逗号分隔的列表，并用方括号括起来，每个情况都格式化为自己的方括号列表，且 $q^{\\mathrm{Rich}}_{0}$ 精确打印到小数点后六位。例如：$[[0.123456,True,False,False],[\\dots],[\\dots]]$。",
            "solution": "该问题是有效的，因为它在计算统计力学方面具有科学依据，问题陈述清晰，并以客观、精确的语言呈现。所提供的数据和要求的任务是一致且可行的。我们将逐步推导所需的过程。\n\n总体任务是分析数值模拟得出的经验 committor 数据。对于每个测试案例，我们必须执行四个子任务：\n1.  使用 Richardson 外推法估计真实的零时间步长 committor $q_0$。\n2.  检验在时间步长 $\\Delta t$ 和 $\\Delta t/2$ 的模拟之间是否存在统计上显著的积分器偏差。\n3.  检验等 committor 一致性，以评估反应坐标的有效性。\n4.  检查外推的 committor 估计值是否在物理上合理。\n\n令从 $n$ 次试验中的 $k$ 次成功得到的经验 committor 估计值为 $\\hat{q} = k/n$。我们给出了时间步长为 $\\Delta t$ 时的计数 $(k_1, n_1)$ 和时间步长为 $\\Delta t/2$ 时的计数 $(k_2, n_2)$。\n\n### 1. $q_0$ 的 Richardson 外推法\n\n问题指出，对于一个弱阶为 $p$ 的积分器，committor 估计值 $q_{\\Delta t}$ 有一个弱误差展开式：\n$$q_{\\Delta t}(\\mathbf{x}) = q_{0}(\\mathbf{x}) + c(\\mathbf{x}) (\\Delta t)^{p} + \\mathcal{O}((\\Delta t)^{p+1})$$\n其中 $q_0(\\mathbf{x})$ 是在 $\\Delta t \\to 0$ 极限下的精确 committor。我们可以使用在两个不同时间步长 $\\Delta t$ 和 $\\Delta t/2$ 下的经验估计值来写出两个方程，将它们视为期望的近似值：\n$$ \\hat{q}_1 \\approx q_0 + c (\\Delta t)^p $$\n$$ \\hat{q}_2 \\approx q_0 + c (\\Delta t/2)^p = q_0 + \\frac{c (\\Delta t)^p}{2^p} $$\n其中 $\\hat{q}_1 = k_1/n_1$ 和 $\\hat{q}_2 = k_2/n_2$。这就构成了关于未知数 $q_0$ 和误差系数项 $C' = c(\\Delta t)^p$ 的两个线性方程组。为了消除 $C'$ 并解出 $q_0$，我们可以将第二个方程乘以 $2^p$ 然后减去第一个方程：\n$$ 2^p \\hat{q}_2 \\approx 2^p q_0 + c (\\Delta t)^p $$\n$$ 2^p \\hat{q}_2 - \\hat{q}_1 \\approx (2^p q_0 + c (\\Delta t)^p) - (q_0 + c (\\Delta t)^p) = q_0(2^p - 1) $$\n解出 $q_0$ 得到 Richardson 外推估计值，我们记为 $q^{\\mathrm{Rich}}_{0}$：\n$$ q^{\\mathrm{Rich}}_{0} = \\frac{2^p \\hat{q}_2 - \\hat{q}_1}{2^p - 1} $$\n假设展开式成立，该估计器的主要误差阶数比 $\\mathcal{O}((\\Delta t)^p)$ 更高。\n\n### 2. 积分器偏差检测\n\n为确定 $\\hat{q}_1$ 和 $\\hat{q}_2$ 之间的观测差异是否具有统计显著性，我们检验零假设 $H_0: q_{\\Delta t} = q_{\\Delta t/2}$ 对备择假设 $H_A: q_{\\Delta t} \\neq q_{\\Delta t/2}$。这是一个双比例 $z$ 检验。在 $H_0$ 下，存在一个单一的、共同的 committor 概率，其最佳估计是合并比例 $\\hat{q}_{pool}$：\n$$ \\hat{q}_{pool} = \\frac{k_1 + k_2}{n_1 + n_2} $$\n在 $H_0$ 下，比例差异的标准误是：\n$$ SE(\\hat{q}_1 - \\hat{q}_2) = \\sqrt{\\hat{q}_{pool}(1 - \\hat{q}_{pool}) \\left( \\frac{1}{n_1} + \\frac{1}{n_2} \\right)} $$\n$z$ 统计量是观测差异除以标准误：\n$$ z = \\frac{\\hat{q}_1 - \\hat{q}_2}{SE(\\hat{q}_1 - \\hat{q}_2)} $$\n对于显著性水平为 $\\alpha = 0.05$ 的双边检验，我们找到临界值 $z_{crit} = \\Phi^{-1}(1-\\alpha/2)$，其中 $\\Phi^{-1}$ 是标准正态累积分布函数的反函数。对于 $\\alpha=0.05$，$z_{crit} \\approx 1.95996$。\n决策规则是：如果 $|z|  z_{crit}$，我们拒绝 $H_0$，并得出结论，存在可检测的积分器偏差。\n\n### 3. 等 committor 一致性检验\n\n一个好的反应坐标 $s$ 应该能捕捉所有慢动力学过程，这意味着所有具有相同 $s(\\mathbf{x}_i) = s_0$ 值的微观状态 $\\mathbf{x}_i$ 都应具有相同的 committor 值，即 $q(\\mathbf{x}_i) = q_{s_0}$。我们使用 Pearson 卡方检验来检验这个零假设，$H_0: q_1 = q_2 = \\dots = q_M$（对于 $M$ 个微观状态），进行比例同质性检验。数据来自较小时间步长 $\\Delta t/2$ 下的计数 $\\{(k_i, n_i)\\}_{i=1}^M$。\n\n在 $H_0$ 下，共同 committor 的最佳估计是所有微观状态的合并比例：\n$$ \\hat{q}_{pool, \\text{micro}} = \\frac{\\sum_{i=1}^M k_i}{\\sum_{i=1}^M n_i} $$\n对于每个微观状态 $i$，成功的期望计数是 $E_i = n_i \\hat{q}_{pool, \\text{micro}}$。观测计数是 $k_i$。卡方统计量的计算方法如下：\n$$ \\chi^2 = \\sum_{i=1}^M \\frac{(k_i - E_i)^2}{n_i \\hat{q}_{pool, \\text{micro}}(1-\\hat{q}_{pool, \\text{micro}})} $$\n该统计量服从自由度为 $df = M-1$ 的卡方分布。在显著性水平 $\\alpha = 0.05$ 下，我们找到临界值 $\\chi^2_{crit} = F_{\\chi^2_{df}}^{-1}(1-\\alpha)$，其中 $F_{\\chi^2_{df}}^{-1}$ 是具有 $df$ 自由度的卡方分布的逆累积分布函数。\n决策规则是：如果 $\\chi^2  \\chi^2_{crit}$，我们拒绝 $H_0$，并得出结论，该反应坐标在此值处无效，因为微观状态之间的变异性太大，无法仅用抽样噪声来解释。\n\n### 4. 物理边界检查\n\ncommittor $q(\\mathbf{x})$ 是一个概率，必须位于区间 $[0, 1]$ 内。外推估计值 $q^{\\mathrm{Rich}}_{0}$ 是一个数值构造，不保证遵守这些物理边界。如果 $q^{\\mathrm{Rich}}_{0}  0$ 或 $q^{\\mathrm{Rich}}_{0}  1$，这表明用于外推的简单误差模型对于给定的数据是不充分的，可能是由于强大的高阶效应或边界附近的行为不能用简单的幂律展开很好地描述。我们报告 $q^{\\mathrm{Rich}}_{0}$ 是否越界。\n\n对每个测试案例按规定实施这四个过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm, chi2\n\ndef solve():\n    \"\"\"\n    Applies a validation procedure for committor analysis to three test cases.\n\n    The procedure includes:\n    1. Richardson extrapolation to estimate the zero-timestep committor.\n    2. A two-proportion z-test to detect integrator bias.\n    3. A chi-square test for isocommittor consistency to validate the reaction coordinate.\n    4. A check for the physical validity of the extrapolated committor value.\n    \"\"\"\n    \n    # Critical value for the statistical tests at a two-sided significance level alpha = 0.05\n    alpha = 0.05\n    z_critical = norm.ppf(1 - alpha / 2)\n\n    test_cases = [\n        {\n            \"p\": 1,\n            \"agg_dt\": {\"n\": 20000, \"k\": 10400},\n            \"agg_dt_half\": {\"n\": 20000, \"k\": 10200},\n            \"microstates_dt_half\": [\n                {\"n\": 4000, \"k\": 1400},\n                {\"n\": 4000, \"k\": 2000},\n                {\"n\": 4000, \"k\": 2600},\n                {\"n\": 4000, \"k\": 2000},\n            ]\n        },\n        {\n            \"p\": 2,\n            \"agg_dt\": {\"n\": 10000, \"k\": 520},\n            \"agg_dt_half\": {\"n\": 10000, \"k\": 505},\n            \"microstates_dt_half\": [\n                {\"n\": 4000, \"k\": 192},\n                {\"n\": 4000, \"k\": 204},\n                {\"n\": 4000, \"k\": 208},\n                {\"n\": 4000, \"k\": 196},\n            ]\n        },\n        {\n            \"p\": 1,\n            \"agg_dt\": {\"n\": 8000, \"k\": 7760},\n            \"agg_dt_half\": {\"n\": 8000, \"k\": 7920},\n            \"microstates_dt_half\": [\n                {\"n\": 4000, \"k\": 3960},\n                {\"n\": 4000, \"k\": 3975},\n                {\"n\": 4000, \"k\": 3965},\n                {\"n\": 4000, \"k\": 3972},\n            ]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        p = case[\"p\"]\n        n1, k1 = case[\"agg_dt\"][\"n\"], case[\"agg_dt\"][\"k\"]\n        n2, k2 = case[\"agg_dt_half\"][\"n\"], case[\"agg_dt_half\"][\"k\"]\n        microstates = case[\"microstates_dt_half\"]\n\n        # --- 1. Richardson Extrapolation ---\n        q1_hat = k1 / n1\n        q2_hat = k2 / n2\n        q_rich_0 = (2**p * q2_hat - q1_hat) / (2**p - 1)\n\n        # --- 4. Physical Bounds Check ---\n        out_of_bounds = not (0 = q_rich_0 = 1)\n\n        # --- 2. Integrator Bias Test (Two-Proportion Z-Test) ---\n        q_pool_bias = (k1 + k2) / (n1 + n2)\n        if q_pool_bias == 0 or q_pool_bias == 1:\n            z_stat_bias = 0.0\n        else:\n            se_bias = np.sqrt(q_pool_bias * (1 - q_pool_bias) * (1/n1 + 1/n2))\n            z_stat_bias = (q1_hat - q2_hat) / se_bias\n        \n        bias_detected = np.abs(z_stat_bias) > z_critical\n\n        # --- 3. Isocommittor Consistency Test (Chi-Square Test) ---\n        num_microstates = len(microstates)\n        df_rc = num_microstates - 1\n        chi2_critical = chi2.ppf(1 - alpha, df=df_rc)\n\n        k_micro = np.array([m[\"k\"] for m in microstates])\n        n_micro = np.array([m[\"n\"] for m in microstates])\n\n        k_total_micro = np.sum(k_micro)\n        n_total_micro = np.sum(n_micro)\n        \n        q_pool_rc = k_total_micro / n_total_micro\n\n        if q_pool_rc == 0 or q_pool_rc == 1:\n            chi2_stat_rc = 0.0\n        else:\n            expected_k = n_micro * q_pool_rc\n            # This is the Pearson's chi-square test statistic for homogeneity of proportions\n            chi2_stat_rc = np.sum((k_micro - expected_k)**2 / (n_micro * q_pool_rc * (1-q_pool_rc)))\n        \n        rc_invalid = chi2_stat_rc > chi2_critical\n\n        current_result = [q_rich_0, bias_detected, rc_invalid, out_of_bounds]\n        results.append(current_result)\n    \n    # Format the final output string to match the problem specification\n    formatted_results = []\n    for res in results:\n        q_str = f\"{res[0]:.6f}\"\n        # Convert Python booleans to required string representation\n        bias_str = str(res[1])\n        rc_str = str(res[2])\n        oob_str = str(res[3])\n        formatted_results.append(f\"[{q_str},{bias_str},{rc_str},{oob_str}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}