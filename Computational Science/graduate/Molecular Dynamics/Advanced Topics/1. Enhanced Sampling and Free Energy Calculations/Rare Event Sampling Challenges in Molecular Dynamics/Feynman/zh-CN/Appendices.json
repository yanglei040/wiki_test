{
    "hands_on_practices": [
        {
            "introduction": "本练习将带你回归第一性原理。我们将为一个穿越势垒的粒子推导著名的克拉默斯（Kramers）速率公式。这项实践旨在巩固随机动力学（朗之万方程）与宏观速率之间的联系，并揭示势垒高度和局部曲率如何决定了转变的时间尺度 。",
            "id": "3440646",
            "problem": "考虑一个在一维空间中演化的单个粒子，其过阻尼朗之万动力学受双势阱 $U(x) = a x^{4} - b x^{2}$（其中 $a>0$ 且 $b>0$）的控制。其运动方程为\n$$\n\\gamma \\,\\dot{x}(t) \\;=\\; -\\,U'(x) \\;+\\; \\sqrt{2\\,\\gamma\\,k_{B}T}\\,\\eta(t),\n$$\n其中 $\\gamma$ 是摩擦系数，$k_{B}$ 是玻尔兹曼常数，$T$ 是绝对温度，$\\eta(t)$ 是单位方差的白噪声，满足 $\\langle \\eta(t)\\eta(t')\\rangle=\\delta(t-t')$。定义平均首通时间（MFPT）为从左势阱极小值点 $x_{L}=-\\sqrt{b/(2a)}$ 出发，首次到达右势阱盆地的期望时间。在右势阱极小值点 $x_{R}=+\\sqrt{b/(2a)}$ 处设置吸收边界，在 $x\\to -\\infty$ 处设置反射边界（由于当 $x\\to -\\infty$ 时 $U(x)\\to +\\infty$，这实际上起到了限制作用）。考虑高势垒极限，此时活化能 $\\Delta U=U(0)-U(x_{L})$ 满足 $\\beta \\,\\Delta U \\gg 1$，其中 $\\beta = 1/(k_{B}T)$。\n\n仅从斯莫鲁霍夫斯基（过阻尼福克-普朗克）描述和 MFPT 的后向方程出发，推导从左势阱到右势阱的 MFPT 的主导阶渐近表达式，该表达式应包含阿伦尼乌斯因子和以 $U(x)$ 在左势阱极小值点和势垒顶点的局部曲率表示的完整前置因子。然后将您的结果具体化到势 $U(x)=a x^{4}-b x^{2}$ 的情况，并将其简化为一个以 $a$、$b$、$\\gamma$、$k_{B}$ 和 $T$ 表示的闭式解析表达式。\n\n将您的最终答案表示为 MFPT 的解析表达式，单位为秒。在您的方框最终答案中不要包含任何单位。无需进行数值四舍五入。",
            "solution": "该问题陈述已经过验证，被认为是科学上可靠、适定且客观的。它提出了一个统计物理学中的标准问题，涉及计算一个在双势阱中受过阻尼朗之万动力学支配的粒子的平均首通时间（MFPT）。Kramers 速率公式的推导是该领域的经典练习。\n\n分析从 MFPT $\\tau(x)$ 的后向福克-普朗克方程开始，$\\tau(x)$ 是指从位置 $x$ 出发的粒子首次到达吸收边界的期望时间。过阻尼朗之万方程为\n$$ \\gamma \\dot{x}(t) = -U'(x) + \\sqrt{2\\gamma k_B T} \\eta(t) $$\n其中 $U'(x)$ 是势 $U(x)$ 的导数，$\\gamma$ 是摩擦系数，$k_B$ 是玻尔兹曼常数，$T$ 是温度，$\\eta(t)$ 是高斯白噪声。这对应一个随机微分方程，其漂移项为 $\\mu(x) = -U'(x)/\\gamma$，扩散系数为 $D = k_B T / \\gamma$。MFPT $\\tau(x)$ 的后向方程是一个二阶常微分方程，形式如下：\n$$ \\mu(x) \\frac{d\\tau}{dx} + D \\frac{d^2\\tau}{dx^2} = -1 $$\n代入 $\\mu(x)$ 和 $D$ 的表达式，我们得到：\n$$ -\\frac{U'(x)}{\\gamma} \\frac{d\\tau}{dx} + \\frac{k_B T}{\\gamma} \\frac{d^2\\tau}{dx^2} = -1 $$\n令 $\\beta = 1/(k_B T)$。该方程可以改写为：\n$$ D \\frac{d^2\\tau}{dx^2} - D \\beta U'(x) \\frac{d\\tau}{dx} = -1 $$\n该问题定义了起始位置在左势阱极小值点 $x_L = -\\sqrt{b/(2a)}$，吸收边界在右势阱极小值点 $x_R = +\\sqrt{b/(2a)}$，以及在 $x \\to -\\infty$ 处的反射边界。因此，$\\tau(x)$ 的边界条件为：\n1. 在 $x_R$ 处的吸收边界：$\\tau(x_R) = 0$。\n2. 在 $x \\to -\\infty$ 处的反射边界。该条件意味着概率流为零，对于后向方程，这转化为 $\\lim_{x \\to -\\infty} \\frac{d\\tau}{dx} = 0$。\n\n令 $y(x) = d\\tau/dx$。方程变为关于 $y(x)$ 的一阶线性常微分方程：\n$$ \\frac{dy}{dx} - \\beta U'(x) y = -\\frac{1}{D} $$\n积分因子为 $\\exp\\left(-\\int \\beta U'(x) dx\\right) = \\exp(-\\beta U(x))$。乘以积分因子得到：\n$$ \\frac{d}{dx} \\left( y(x) e^{-\\beta U(x)} \\right) = -\\frac{1}{D} e^{-\\beta U(x)} $$\n从任意点 $c$ 积分到 $x$：\n$$ y(x) e^{-\\beta U(x)} - y(c) e^{-\\beta U(c)} = -\\frac{1}{D} \\int_c^x e^{-\\beta U(s)} ds $$\n为满足反射边界条件 $\\lim_{x \\to -\\infty} y(x) = 0$，我们取极限 $c \\to -\\infty$。注意到当 $x \\to -\\infty$ 时 $U(x) \\to \\infty$，只要 $y(c)$ 的增长速度不超过 $e^{\\beta U(c)}$（这是物理上所要求的），则 $y(c) e^{-\\beta U(c)}$ 项消失。因此，我们有：\n$$ y(x) e^{-\\beta U(x)} = -\\frac{1}{D} \\int_{-\\infty}^x e^{-\\beta U(s)} ds $$\n$$ y(x) = \\frac{d\\tau}{dx} = -\\frac{1}{D} e^{\\beta U(x)} \\int_{-\\infty}^x e^{-\\beta U(s)} ds $$\n为了求出 $\\tau(x)$，我们将 $y(x)$ 从 $x_R$ 积分到 $x$，并使用吸收边界条件 $\\tau(x_R)=0$：\n$$ \\tau(x) = \\int_{x_R}^x y(s) ds = -\\frac{1}{D} \\int_{x_R}^x e^{\\beta U(s)} \\left( \\int_{-\\infty}^s e^{-\\beta U(q)} dq \\right) ds $$\n我们要求的是从左势阱极小值点出发的 MFPT，即 $\\tau(x_L)$：\n$$ \\tau(x_L) = -\\frac{1}{D} \\int_{x_R}^{x_L} e^{\\beta U(s)} \\left( \\int_{-\\infty}^s e^{-\\beta U(q)} dq \\right) ds = \\frac{1}{D} \\int_{x_L}^{x_R} e^{\\beta U(s)} \\left( \\int_{-\\infty}^s e^{-\\beta U(q)} dq \\right) ds $$\n这是精确表达式。现在我们在高势垒极限 $\\beta \\Delta U \\gg 1$ 下对其进行求值。这意味着被积函数是尖峰状的，允许我们使用拉普拉斯方法（鞍点近似）。\n\n外层积分 $\\int_{x_L}^{x_R} \\dots ds$ 主要由其被积函数取最大值的区域决定。$e^{\\beta U(s)}$ 项在势垒顶点 $s=x_B=0$ 处有一个尖锐的极大值。内层积分项在该区域是一个缓变函数。\n内层积分 $I_{in}(s) = \\int_{-\\infty}^s e^{-\\beta U(q)} dq$，对于势垒顶点 $x_B$ 附近的 $s$ 值，主要由 $e^{-\\beta U(q)}$ 取最大值的区域决定。这发生在左势阱底部 $q=x_L$ 处。我们在 $x_L$ 附近用谐振展开来近似 $U(q)$：$U(q) \\approx U(x_L) + \\frac{1}{2}U''(x_L)(q-x_L)^2$。\n于是，内层积分变为：\n$$ I_{in}(s) \\approx \\int_{-\\infty}^{\\infty} e^{-\\beta \\left( U(x_L) + \\frac{1}{2}U''(x_L)(q-x_L)^2 \\right)} dq = e^{-\\beta U(x_L)} \\sqrt{\\frac{2\\pi}{\\beta U''(x_L)}} $$\n积分上限 $s$（接近 0）距离 $x_L$ 足够远，因此可以将积分上限扩展到 $\\infty$。\n\n现在，将此结果代入 $\\tau(x_L)$ 的表达式中：\n$$ \\tau(x_L) \\approx \\frac{1}{D} \\left( e^{-\\beta U(x_L)} \\sqrt{\\frac{2\\pi}{\\beta U''(x_L)}} \\right) \\int_{x_L}^{x_R} e^{\\beta U(s)} ds $$\n剩下的积分通过在势垒顶点 $s=x_B=0$ 附近近似 $U(s)$ 来计算：$U(s) \\approx U(x_B) + \\frac{1}{2}U''(x_B)s^2 = U(x_B) - \\frac{1}{2}|U''(x_B)|s^2$。\n$$ \\int_{x_L}^{x_R} e^{\\beta U(s)} ds \\approx \\int_{-\\infty}^{\\infty} e^{\\beta \\left( U(x_B) - \\frac{1}{2}|U''(x_B)|s^2 \\right)} ds = e^{\\beta U(x_B)} \\sqrt{\\frac{2\\pi}{\\beta |U''(x_B)|}} $$\n结合所有部分：\n$$ \\tau(x_L) \\approx \\frac{1}{D} \\left( e^{-\\beta U(x_L)} \\sqrt{\\frac{2\\pi}{\\beta U''(x_L)}} \\right) \\left( e^{\\beta U(x_B)} \\sqrt{\\frac{2\\pi}{\\beta |U''(x_B)|}} \\right) $$\n$$ \\tau(x_L) \\approx \\frac{2\\pi}{D\\beta\\sqrt{U''(x_L)|U''(x_B)|}} e^{\\beta (U(x_B)-U(x_L))} $$\n代入 $D = 1/(\\beta\\gamma)$ 并定义活化能 $\\Delta U = U(x_B) - U(x_L)$，我们得到过阻尼极限下 MFPT 的通用 Kramers 公式：\n$$ \\tau_{Kramers} = \\frac{2\\pi\\gamma}{\\sqrt{U''(x_L)|U''(x_B)|}} e^{\\beta \\Delta U} $$\n接下来，我们将此结果应用于势 $U(x) = ax^4 - bx^2$（其中 $a>0, b>0$）。\n首先，我们通过令 $U'(x) = 4ax^3 - 2bx = 2x(2ax^2-b) = 0$ 来找到驻点。解为 $x=0$ 和 $x=\\pm\\sqrt{b/(2a)}$。\n二阶导数为 $U''(x) = 12ax^2 - 2b$。\n在 $x=0$ 处，$U''(0) = -2b  0$，因此这是一个局部极大值点（势垒顶点，$x_B=0$）。\n在 $x=\\pm\\sqrt{b/(2a)}$ 处，$U''(\\pm\\sqrt{b/(2a)}) = 12a(b/(2a)) - 2b = 6b - 2b = 4b  0$，因此这些是局部极小值点。左侧极小值点为 $x_L = -\\sqrt{b/(2a)}$。\n\n我们计算公式所需的量：\n- 左侧极小值点的曲率：$U''(x_L) = 4b$。\n- 势垒顶点的曲率大小：$|U''(x_B)| = |-2b| = 2b$。\n- 势能值为 $U(x_L) = a(-\\sqrt{b/(2a)})^4 - b(-\\sqrt{b/(2a)})^2 = a\\frac{b^2}{4a^2} - b\\frac{b}{2a} = \\frac{b^2}{4a} - \\frac{b^2}{2a} = -\\frac{b^2}{4a}$。\n- 且 $U(x_B) = U(0) = 0$。\n- 活化能为 $\\Delta U = U(x_B) - U(x_L) = 0 - (-\\frac{b^2}{4a}) = \\frac{b^2}{4a}$。\n\n最后，我们将这些值代入 Kramers 公式：\n$$ \\tau(x_L) \\approx \\frac{2\\pi\\gamma}{\\sqrt{(4b)(2b)}} \\exp\\left( \\beta \\frac{b^2}{4a} \\right) $$\n$$ \\tau(x_L) \\approx \\frac{2\\pi\\gamma}{\\sqrt{8b^2}} \\exp\\left( \\frac{b^2}{4a k_B T} \\right) $$\n$$ \\tau(x_L) \\approx \\frac{2\\pi\\gamma}{2\\sqrt{2}b} \\exp\\left( \\frac{b^2}{4a k_B T} \\right) $$\n$$ \\tau(x_L) \\approx \\frac{\\pi\\gamma}{\\sqrt{2}b} \\exp\\left( \\frac{b^2}{4a k_B T} \\right) $$\n该表达式是在高势垒极限下，对于给定势场，从左势阱到右势阱的平均首通时间的主导阶渐近结果。",
            "answer": "$$\n\\boxed{\\frac{\\pi \\gamma}{\\sqrt{2} b} \\exp\\left(\\frac{b^2}{4 a k_B T}\\right)}\n$$"
        },
        {
            "introduction": "现实世界中的势垒通常由自由能而非仅仅是势能决定。本练习将引入“熵瓶颈”的概念，即转变过程缓慢并非因为能量壁垒高，而是因为路径狭窄。你将为一个自定义的二维势能面推导过渡态理论（Transition State Theory, TST）速率，并实现一个数值算法来计算它，从而获得关于熵如何影响反应速率的实践经验 。",
            "id": "3440663",
            "problem": "要求您构建一个数学上定义的二维势能面，该势能面表现出熵瓶颈，即势能垒低而自由能垒高，并计算稀有事件转变速率如何随温度变化。您的推导和算法必须仅从以下基础出发：牛顿运动定律、使用玻尔兹曼分布的正则系综，以及稀有事件速率作为跨越分界面的平衡通量的定义。该物理场景以纯数学术语提出，以确保普遍适用性和明确的计算。\n\n将二维势能定义为\n$$\nU(x,y) \\equiv V(x) + \\tfrac{1}{2}\\,k(x)\\,y^2,\n$$\n其中一维双阱分量为\n$$\nV(x) \\equiv a\\,(x^2 - b^2)^2\n$$\n与位置相关的横向刚度为\n$$\nk(x) \\equiv k_0 + k_1 \\exp\\!\\big(-(x/\\sigma)^2\\big).\n$$\n选择区域 $x  0$ 作为反应物盆地，区域 $x > 0$ 作为产物盆地。分界面位于 $x=0$。势能垒高度为 $V(0)=a\\,b^4$，可以通过选择较小的 $a$ 来使其降低。熵瓶颈的实现方式是使 $k(x)$ 在 $x=0$ 附近较大，而在盆地中较小，这样可及的横向构型在鞍点附近收缩，从而增加了自由能垒。\n\n在约化单位下工作，设置玻尔兹曼常数 $k_B=1$，质量 $m=1$，单位长度 $L_0=1$。所有速率均以约化时间单位的倒数报告。不出现角度，因此不需要角度单位。此任务中没有百分比。\n\n仅从正则系综和跨分界面的平衡通量定义出发，使用过渡态理论 (TST) 推导此模型的温变转变速率 $k(T)$。使用跨越 $x=0$ 的精确平衡通量表达式除以处于反应物盆地的平衡概率，并对横向坐标 $y$ 进行解析积分。您的最终算法应通过对 $x$ 的一维求积来精确计算上述模型的 $k(T)$。\n\n实现一个完整、可运行的程序，对于每个指定的测试用例，通过以下方式评估\n$$\nk(T) = \\left\\langle \\delta(x)\\,\\dot{x}\\,\\Theta(\\dot{x}) \\right\\rangle \\big/ \\Pr(x  0)\n$$\n：\n- 在正则玻尔兹曼分布下解析地执行 $y$ 积分，\n- 通过对 $x\\in(-\\infty,0)$ 进行数值积分来计算剩余的 $x$ 积分，\n- 使用速度的麦克斯韦-玻尔兹曼分布来获得正法向速度因子。\n\n程序必须仅使用指定的运行时环境和库。最终输出必须是包含所有测试用例结果的单行，格式为逗号分隔的列表并用方括号括起，例如 $\\texttt{[r_1,r_2,r_3]}$，其中每个 $r_i$ 是一个浮点数，表示以约化时间单位的倒数表示的速率。\n\n测试套件参数集，每个为元组 $(a,b,k_0,k_1,\\sigma,m,T)$，如下：\n- 案例 1（正常路径，低势垒，强熵瓶颈）：$(0.02,\\,1.0,\\,1.0,\\,100.0,\\,0.3,\\,1.0,\\,0.5)$。\n- 案例 2（低温，相同瓶颈）：$(0.02,\\,1.0,\\,1.0,\\,100.0,\\,0.3,\\,1.0,\\,0.1)$。\n- 案例 3（高温，相同瓶颈）：$(0.02,\\,1.0,\\,1.0,\\,100.0,\\,0.3,\\,1.0,\\,1.0)$。\n- 案例 4（无熵瓶颈，均匀横向刚度）：$(0.02,\\,1.0,\\,1.0,\\,0.0,\\,0.3,\\,1.0,\\,0.5)$。\n- 案例 5（极窄瓶颈）：$(0.02,\\,1.0,\\,1.0,\\,100.0,\\,0.1,\\,1.0,\\,0.5)$。\n\n您的程序应生成单行输出，包含以逗号分隔的列表形式的结果并用方括号括起（例如 $\\texttt{[r_1,r_2,r_3,r_4,r_5]}$），其中每个 $r_i$ 是对应案例的计算速率，单位为约化时间单位的倒数。",
            "solution": "问题陈述经过严格验证，被认为是**有效的**。它在科学上基于统计力学，定义和参数齐全、问题良构，并以客观的数学语言表述。该任务是化学反应速率理论中一个标准的、非平凡的问题，可以从所提供的第一性原理出发进行严格求解。\n\n从反应物盆地（$x  0$）到产物盆地（$x > 0$）的转变速率 $k(T)$ 定义为，在正 $x$ 方向上穿过位于 $x=0$ 的分界面的轨迹的平衡通量，并以处于反应物盆地的平衡概率进行归一化。\n$$\nk(T) = \\frac{\\left\\langle \\delta(x)\\,\\dot{x}\\,\\Theta(\\dot{x}) \\right\\rangle}{\\Pr(x  0)}\n$$\n其中 $\\langle \\cdot \\rangle$ 表示正则系综平均，$\\dot{x}$ 是沿 $x$ 的速度，$\\delta(x)$ 是选择分界面的狄拉克δ函数，$\\Theta(\\dot{x})$ 是亥维赛阶跃函数，确保只计算正向（产物方向）的通量。\n\n在相空间 $(\\mathbf{q}, \\mathbf{p})$ 中，可观测量 $A(\\mathbf{q}, \\mathbf{p})$ 的正则平均由 $\\langle A \\rangle = Z^{-1} \\int A(\\mathbf{q}, \\mathbf{p}) e^{-\\beta H(\\mathbf{q}, \\mathbf{p})} d\\mathbf{q} d\\mathbf{p}$ 给出，其中 $H$ 是哈密顿量，$\\beta = (k_B T)^{-1}$，$Z$ 是总配分函数。设 $k_B=1$，则 $\\beta = 1/T$。该二维系统的哈密顿量为\n$$\nH(x, y, p_x, p_y) = \\frac{p_x^2}{2m} + \\frac{p_y^2}{2m} + U(x, y)\n$$\n其中 $U(x,y) = V(x) + \\frac{1}{2}k(x)y^2$。粒子质量为 $m$。\n\n分子是通量 $J = \\left\\langle \\delta(x)\\,\\dot{x}\\,\\Theta(\\dot{x}) \\right\\rangle$。将其写成相空间积分形式：\n$$\nJ = \\frac{1}{Z} \\int_{-\\infty}^{\\infty} dx \\int_{-\\infty}^{\\infty} dy \\int_{-\\infty}^{\\infty} dp_x \\int_{-\\infty}^{\\infty} dp_y \\, \\delta(x) \\frac{p_x}{m} \\Theta(p_x) e^{-\\beta H}\n$$\n关于 $x$ 的积分被 delta 函数消除，它将积分函数其余部分的 $x$ 设为0。表达式分离成剩余变量上积分的乘积：\n$$\nJ = \\frac{1}{Z} \\left(\\int_0^{\\infty} \\frac{p_x}{m} e^{-\\beta p_x^2/(2m)} dp_x\\right) \\left(\\int_{-\\infty}^{\\infty} e^{-\\beta p_y^2/(2m)} dp_y\\right) \\left(\\int_{-\\infty}^{\\infty} e^{-\\beta U(0,y)} dy\\right)\n$$\n计算动量积分：\n1. $\\int_0^{\\infty} \\frac{p_x}{m} e^{-\\beta p_x^2/(2m)} dp_x = \\left[-\\frac{1}{\\beta} e^{-\\beta p_x^2/(2m)}\\right]_0^{\\infty} = \\frac{1}{\\beta} = T$。\n2. $\\int_{-\\infty}^{\\infty} e^{-\\beta p_y^2/(2m)} dp_y = \\sqrt{2\\pi m/\\beta} = \\sqrt{2\\pi m T}$。\n\n在过渡态 $x=0$ 处的构型积分将表示为 $Z_q^\\ddagger$：\n$Z_q^\\ddagger = \\int_{-\\infty}^{\\infty} e^{-\\beta U(0,y)} dy$。\n因此，通量为 $J = \\frac{1}{Z} (T) (\\sqrt{2\\pi m T}) Z_q^\\ddagger$。\n\n分母是处于反应物盆地的概率，$\\Pr(x  0) = Z_R/Z$，其中 $Z_R$ 是反应物配分函数：\n$$\nZ_R = \\int_{-\\infty}^{0} dx \\int_{-\\infty}^{\\infty} dy \\int_{-\\infty}^{\\infty} dp_x \\int_{-\\infty}^{\\infty} dp_y \\, e^{-\\beta H}\n$$\n这也可以分离为动量和构型部分：\n$$\nZ_R = \\left(\\int_{-\\infty}^{\\infty} e^{-\\beta p_x^2/(2m)} dp_x\\right) \\left(\\int_{-\\infty}^{\\infty} e^{-\\beta p_y^2/(2m)} dp_y\\right) \\left(\\int_{-\\infty}^{0} dx \\int_{-\\infty}^{\\infty} dy \\, e^{-\\beta U(x,y)}\\right)\n$$\n动量积分的计算结果为 $(\\sqrt{2\\pi m T})^2 = 2\\pi m T$。构型部分是构型空间中的反应物配分函数，$Z_{R,q} = \\int_{-\\infty}^{0} dx \\int_{-\\infty}^{\\infty} dy \\, e^{-\\beta U(x,y)}$。\n所以，$Z_R = (2\\pi m T) Z_{R,q}$。\n\n将这些结果合并，得到速率常数 $k(T)$：\n$$\nk(T) = \\frac{J}{\\Pr(x  0)} = \\frac{J Z}{Z_R} = \\frac{ \\frac{1}{Z} (T \\sqrt{2\\pi m T}) Z_q^\\ddagger \\cdot Z}{(2\\pi m T) Z_{R,q}} = \\frac{T \\sqrt{2\\pi m T}}{2\\pi m T} \\frac{Z_q^\\ddagger}{Z_{R,q}} = \\sqrt{\\frac{T}{2\\pi m}} \\frac{Z_q^\\ddagger}{Z_{R,q}}\n$$\n这是过渡态理论在构型空间中的标准表述。\n\n现在，我们对横向坐标 $y$ 进行解析积分。\n对于任意 $x$，关于 $y$ 的积分为：\n$$\n\\int_{-\\infty}^{\\infty} e^{-\\beta U(x,y)} dy = \\int_{-\\infty}^{\\infty} e^{-\\beta(V(x) + \\frac{1}{2}k(x)y^2)} dy = e^{-\\beta V(x)} \\int_{-\\infty}^{\\infty} e^{-\\beta \\frac{k(x)}{2} y^2} dy\n$$\n这是一个标准高斯积分，其值为 $\\sqrt{2\\pi/(\\beta k(x))} = \\sqrt{2\\pi T/k(x)}$。\n所以，$\\int_{-\\infty}^{\\infty} e^{-\\beta U(x,y)} dy = e^{-V(x)/T} \\sqrt{2\\pi T/k(x)}$。\n\n将此结果应用于 $Z_q^\\ddagger$（在 $x=0$ 处）和 $Z_{R,q}$（在 $x  0$ 上积分）：\n$$\nZ_q^\\ddagger = \\int_{-\\infty}^{\\infty} e^{-\\beta U(0,y)} dy = e^{-V(0)/T} \\sqrt{2\\pi T/k(0)}\n$$\n$$\nZ_{R,q} = \\int_{-\\infty}^{0} dx \\left( \\int_{-\\infty}^{\\infty} e^{-\\beta U(x,y)} dy \\right) = \\int_{-\\infty}^{0} dx \\, e^{-V(x)/T} \\sqrt{2\\pi T/k(x)}\n$$\n将这些代入 $k(T)$ 的表达式中：\n$$\nk(T) = \\sqrt{\\frac{T}{2\\pi m}} \\frac{e^{-V(0)/T} \\sqrt{2\\pi T/k(0)}}{\\int_{-\\infty}^{0} e^{-V(x)/T} \\sqrt{2\\pi T/k(x)} dx} = \\sqrt{\\frac{T}{2\\pi m}} \\frac{e^{-V(0)/T}/\\sqrt{k(0)}}{\\int_{-\\infty}^{0} e^{-V(x)/T}/\\sqrt{k(x)} dx}\n$$\n使用所提供的具体函数形式：\n$V(x) = a(x^2 - b^2)^2 \\implies V(0) = ab^4$。\n$k(x) = k_0 + k_1 \\exp(-(x/\\sigma)^2) \\implies k(0) = k_0+k_1$。\n最终需要计算的表达式为：\n$$\nk(T) = \\sqrt{\\frac{T}{2\\pi m}} \\frac{\\exp(-ab^4/T) / \\sqrt{k_0+k_1}}{\\int_{-\\infty}^{0} \\frac{\\exp(-a(x^2-b^2)^2/T)}{\\sqrt{k_0 + k_1 \\exp(-(x/\\sigma)^2)}} dx}\n$$\n分母中的积分无法解析求解，必须通过数值积分来计算。所提供的算法将为每个测试用例实现此公式。",
            "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes the transition rate k(T) for a 2D potential energy surface \n    exhibiting an entropic bottleneck, based on Transition State Theory (TST).\n    \n    The rate is calculated using an analytical expression derived from first principles,\n    with the final step involving a 1D numerical quadrature.\n    \"\"\"\n    \n    # Test suite parameter sets, each a tuple (a, b, k0, k1, sigma, m, T)\n    test_cases = [\n        (0.02, 1.0, 1.0, 100.0, 0.3, 1.0, 0.5), # Case 1: Happy path\n        (0.02, 1.0, 1.0, 100.0, 0.3, 1.0, 0.1), # Case 2: Low temperature\n        (0.02, 1.0, 1.0, 100.0, 0.3, 1.0, 1.0), # Case 3: High temperature\n        (0.02, 1.0, 1.0, 0.0, 0.3, 1.0, 0.5),  # Case 4: No entropic bottleneck\n        (0.02, 1.0, 1.0, 100.0, 0.1, 1.0, 0.5), # Case 5: Narrow bottleneck\n    ]\n\n    results = []\n    for case in test_cases:\n        a, b, k0, k1, sigma, m, T = case\n\n        # Define the potential component V(x) and transverse stiffness k(x)\n        def V_func(x_val):\n            return a * (x_val**2 - b**2)**2\n\n        def k_func(x_val):\n            return k0 + k1 * np.exp(-(x_val / sigma)**2)\n\n        # Define the integrand for the denominator of the rate expression.\n        # This corresponds to exp(-V(x)/T) / sqrt(k(x)).\n        def integrand(x_val):\n            return np.exp(-V_func(x_val) / T) / np.sqrt(k_func(x_val))\n\n        # --- Calculate the components of the TST rate formula ---\n\n        # 1. Prefactor derived from kinetic terms\n        prefactor = np.sqrt(T / (2 * np.pi * m))\n\n        # 2. Numerator term, related to the transition state configuration\n        V_at_0 = a * b**4\n        k_at_0 = k0 + k1\n        \n        # This term is exp(-V(0)/T) / sqrt(k(0))\n        numerator_term = np.exp(-V_at_0 / T) / np.sqrt(k_at_0)\n\n        # 3. Denominator term, related to the reactant basin configuration\n        # This is the integral over x from -infinity to 0 of the integrand.\n        denominator_integral, _ = integrate.quad(integrand, -np.inf, 0, limit=100)\n        \n        # Combine all parts to get the final TST rate\n        rate = prefactor * numerator_term / denominator_integral\n        results.append(rate)\n\n    # Format the final output as a single comma-separated list in brackets,\n    # with each rate expressed in scientific notation for clarity.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在进行了长时间的模拟以收集稀有事件后，我们如何确定结果在统计上是可靠的？本练习提供了一个关键的验证工具。你将基于时间重整定理（time-rescaling theorem）实现一种方法，用于检验一系列事件的等待时间是否遵循预期的泊松（Poisson）统计分布，这是良好表现的稀有过程的一个关键标志 。",
            "id": "3440725",
            "problem": "您的任务是在分子动力学稀有事件采样的背景下，设计并实现一个基于统计学原理的检测器，用于检测非泊松等待时间，并特别关注经元动力学校正的事件时间。您的算法必须从第一性原理出发，仅使用公认的定义，并根据一个固定的测试套件产生可量化的输出。\n\n定义与基本原理：\n- 一个恒定事件率 $k$ 的齐次泊松过程是一个连续时间上的点过程，其事件间的等待时间是独立同分布的随机变量，每个变量都服从率为 $k$ 的指数分布。\n- 对于率为 $k$ 的指数分布，其概率密度函数为 $f(t) = k \\, e^{-k t}$ ($t \\ge 0$)，累积分布函数为 $F(t) = 1 - e^{-k t}$，生存函数为 $S(t) = e^{-k t}$。\n- 时间重标度定理指出，对于一个条件强度被正确指定的点过程，存在一个对事件间时间的单调变换，该变换能产生服从一个已知的、简单的参考分布的同分布变量。对于齐次泊松过程，请推导出一个特定的变换，该变换将每个等待时间映射到一个在 $[0,1]$ 上服从标准均匀分布的变量。您的推导必须从上述定义开始，并且不得假设超出这些定义的任何结论。\n- 对于一个独立指数等待时间的序列，请推导常数率 $k$ 的最大似然估计量。\n\n经元动力学校正的事件：\n- 在如元动力学之类的偏置加速模拟中，在时间加速因子 $a$ 下观测到的事件具有一个有偏等待时间 $t_{\\mathrm{b}}$，其分布与无偏等待时间不同。在每个事件的加速是分段恒定的简化模型下，无偏等待时间可以通过校正 $t_{\\mathrm{corr}} = a \\, t_{\\mathrm{b}}$ 精确恢复。在实践中，$a$ 的估计可能带有噪声，从而产生一个错误校正的时间 $t_{\\mathrm{corr}}^{\\mathrm{wrong}}$。\n- 您的算法必须将每个提供的等待时间序列视为假设的无偏时间，从数据中估计恒定速率参数，通过时间重标度定理对齐次泊松过程所蕴含的变换来转换等待时间，然后使用 Kolmogorov–Smirnov (KS) 统计量来量化其与 $[0,1]$ 上均匀分布的偏差。\n\n算法要求：\n- 给定一个等待时间序列 $\\{t_i\\}_{i=1}^n$，使用最大似然原理从数据中估计恒定速率 $\\hat{k}$。\n- 使用您推导的齐次泊松变换，计算变换后的变量 $\\{u_i\\}_{i=1}^n$，并使用 Kolmogorov–Smirnov 統計量检验它们与 $[0,1]$ 上标准均匀分布的一致性。报告 KS 统计量的值及其对应的 $p$ 值。\n- 所有输出均为无量纲实数。无需物理单位。\n\n测试套件与数据生成：\n实现以下五个独立的测试用例。在每个用例中，使用由指定种子初始化的新的伪随机数生成器流。除通过构造显式耦合的情况外，一个用例内的所有随机变量必须是独立的。将所有时间变量视为无单位的。\n\n- 案例 A (基准齐次泊松)：\n  - 样本大小 $n = 500$。\n  - 真实速率 $k = 0.5$。\n  - 种子 $12345$。\n  - 生成 $n$ 个率为 $k$ 的独立指数等待时间。\n\n- 案例 B (元动力学校正，精确校正)：\n  - 样本大小 $n = 500$。\n  - 真实速率 $k = 0.2$。\n  - 种子 $12346$。\n  - 对于每个事件 $i$，从对数正态分布中抽取一个独立的加速因子 $a_i$，其底层正态分布的参数为 $\\mu = \\ln(10)$ 和 $\\sigma = 0.5$。\n  - 在给定 $a_i$ 的条件下，从率为 $a_i \\, k$ 的指数分布中抽取一个有偏等待时间 $t_{{\\mathrm{b}}, i}$。\n  - 构成精确校正时间 $t_i = a_i \\, t_{{\\mathrm{b}}, i}$。\n  - 使用 $\\{t_i\\}$ 作为您的检测算法的输入。\n\n- 案例 C (元动力学校正，错误校正)：\n  - 样本大小 $n = 500$。\n  - 真实速率 $k = 0.2$。\n  - 种子 $12347$。\n  - 对于每个事件 $i$，如案例 B 中一样抽取 $a_i$。\n  - 在给定 $a_i$ 的条件下，从率为 $a_i \\, k$ 的指数分布中抽取 $t_{{\\mathrm{b}}, i}$。\n  - 从均值为 $0$、标准差为 $0.6$ 的正态分布中抽取一个独立的估计噪声 $\\epsilon_i$，并定义 $a_i^{\\mathrm{est}} = a_i \\, e^{\\epsilon_i}$。\n  - 构成错误校正时间 $t_i = a_i^{\\mathrm{est}} \\, t_{{\\mathrm{b}}, i}$。\n  - 使用 $\\{t_i\\}$ 作为您的检测算法的输入。\n\n- 案例 D (非指数更新，伽马形状)：\n  - 样本大小 $n = 500$。\n  - 基准速率参数 $k_0 = 0.5$。\n  - 种子 $12348$。\n  - 抽取 $n$ 个独立的伽马分布等待时间，其形状参数为 $r = 2$，速率参数为 $\\lambda = r \\, k_0$（等效于尺度参数 $\\theta = 1/\\lambda$）。这将产生一个更新过程，其平均等待时间与 $1/k_0$ 相匹配，但具有非指数的变异性。\n  - 使用这些时间作为您的检测算法的输入。\n\n- 案例 E (小样本齐次泊松边缘用例)：\n  - 样本大小 $n = 10$。\n  - 真实速率 $k = 0.5$。\n  - 种子 $12349$。\n  - 生成 $n$ 个率为 $k$ 的独立指数等待时间。\n\n要求的输出：\n- 对于按 A, B, C, D, E 顺序排列的每个案例，计算并返回两个值：Kolmogorov–Smirnov 统计量 $D$ 及其在原假设（即变换后的变量是独立同分布的标准均匀随机变量）下的 $p$ 值。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的扁平实数列表，用方括号括起来，顺序为 $[D_{\\mathrm{A}}, p_{\\mathrm{A}}, D_{\\mathrm{B}}, p_{\\mathrm{B}}, D_{\\mathrm{C}}, p_{\\mathrm{C}}, D_{\\mathrm{D}}, p_{\\mathrm{D}}, D_{\\mathrm{E}}, p_{\\mathrm{E}}]$。\n- 在打印前将每个报告的实数四舍五入到 $6$ 位小数。\n\n约束条件：\n- 您的推导必须从上文所述的定义和事实出发。在未推导的情况下，请勿假设或引用目标变换或估计量。\n- 您的实现不得假设对真实参数有先验知识。测试套件所需的所有参数仅用于生成合成数据；您的检测算法必须在每种情况下分别从提供的等待时间中估计速率。",
            "solution": "任务是设计一个基于统计学原理的检测器，用于检测非泊松等待时间，这是分析分子动力学模拟中稀有事件时的一个常见挑战。该检测器的基础是原假设，即观测到的事件间时间 $\\{t_i\\}_{i=1}^n$ 是来自速率为常数 $k$ 的指数分布的独立同分布（i.i.d.）样本，这是齐次泊松过程（HPP）的定义性特征。先验未知的速率 $k$ 必须从数据中估计。该方法的核心涉及将观测到的时间变换为一组变量，在原假设下，这些变量应服从标准均匀分布。然后使用 Kolmogorov-Smirnov (KS) 检验来量化与均匀分布的偏差。\n\n解决方案分三个阶段进行：首先，我们按要求从第一性原理推导必要的理论部分；其次，我们概述完整的算法流程；第三，我们分析每个指定测试用例的预期结果。\n\n### 理论推导\n\n必须推导两个关键结果：将指数变量映射到均匀变量的变换，以及指数速率参数的最大似然估计量。\n\n**1. 齐次泊松过程的时间重标度变换**\n\n该问题要求推导一个变换，将一个服从指数分布的等待时间 $T$ 映射到一个在区间 $[0, 1]$ 上均匀分布的随机变量 $U$。这是概率积分变换定理的一个具体应用。\n\n设 $T$ 是一个代表事件间等待时间的随机变量。在 HPP 假设下，$T$ 服从速率参数为 $k  0$ 的指数分布。其概率密度函数 (PDF) 和累积分布函数 (CDF) 如下所示：\n$$\nf(t; k) = k e^{-kt} \\quad \\text{for } t \\ge 0\n$$\n$$\nF_T(t; k) = P(T \\le t) = \\int_0^t k e^{-k\\tau} d\\tau = \\left[ -e^{-k\\tau} \\right]_0^t = 1 - e^{-kt}\n$$\n\n概率积分变换定理指出，如果 $X$ 是一个具有累积分布函数 $F_X(x)$ 的连续随机变量，那么随机变量 $Y = F_X(X)$ 在 $[0, 1]$ 上均匀分布。将此定理应用于我们的等待时间变量 $T$：\n设 $U = F_T(T; k)$。因此，变换为：\n$$\nU = 1 - e^{-kT}\n$$\n\n为了证明 $U \\sim U[0, 1]$，我们求其累积分布函数，记为 $F_U(u)$。\n$T$ 的支集是 $[0, \\infty)$。这意味着 $e^{-kT}$ 在 $(0, 1]$ 区间内，因此 $U = 1 - e^{-kT}$ 在 $[0, 1)$ 区间内。\n对于任何 $u \\in [0, 1)$， $U$ 的累积分布函数为：\n$$\nF_U(u) = P(U \\le u) = P(1 - e^{-kT} \\le u)\n$$\n重新整理不等式以解出 $T$：\n$$\nP(-e^{-kT} \\le u - 1) \\implies P(e^{-kT} \\ge 1 - u)\n$$\n对两边取自然对数（这是一个单调函数）：\n$$\nP(-kT \\ge \\ln(1 - u))\n$$\n由于 $k  0$，乘以 $-1/k$ 会反转不等号：\n$$\nP\\left(T \\le -\\frac{1}{k}\\ln(1 - u)\\right)\n$$\n根据定义，$P(T \\le t) = F_T(t; k)$。因此：\n$$\nF_U(u) = F_T\\left(-\\frac{1}{k}\\ln(1 - u); k\\right) = 1 - \\exp\\left[-k \\left(-\\frac{1}{k}\\ln(1 - u)\\right)\\right]\n$$\n$$\nF_U(u) = 1 - \\exp[\\ln(1 - u)] = 1 - (1 - u) = u\n$$\n$U$ 的累积分布函数为 $F_U(u) = u$ (对于 $u \\in [0, 1)$)，$F_U(u) = 0$ (对于 $u  0$)，以及 $F_U(u) = 1$ (对于 $u \\ge 1$)。这是标准均匀分布 $U[0, 1]$ 的累积分布函数。\n在实践中，真实速率 $k$ 是未知的，并由其估计值 $\\hat{k}$ 代替。因此，应用于每个观测时间 $t_i$ 的变换是 $u_i = 1 - e^{-\\hat{k}t_i}$。\n\n**2. 速率参数的最大似然估计量 (MLE)**\n\n给定从未知速率为 $k$ 的指数分布中抽取的 $n$ 个独立同分布的等待时间 $\\{t_i\\}_{i=1}^n$，我们推导 $k$ 的最大似然估计量。\n\n似然函数 $\\mathcal{L}(k)$ 是观测数据的联合概率密度，被视为参数 $k$ 的函数：\n$$\n\\mathcal{L}(k; \\{t_i\\}_{i=1}^n) = \\prod_{i=1}^n f(t_i; k) = \\prod_{i=1}^n \\left(k e^{-kt_i}\\right) = k^n \\exp\\left(-k \\sum_{i=1}^n t_i\\right)\n$$\n为简化最大化过程，我们使用对数似然函数 $\\ell(k) = \\ln \\mathcal{L}(k)$：\n$$\n\\ell(k) = \\ln\\left(k^n\\right) + \\ln\\left(\\exp\\left(-k \\sum_{i=1}^n t_i\\right)\\right) = n \\ln(k) - k \\sum_{i=1}^n t_i\n$$\n为找到使 $\\ell(k)$ 最大化的 $k$ 值，我们计算其关于 $k$ 的导数并将其设为零：\n$$\n\\frac{d\\ell(k)}{dk} = \\frac{n}{k} - \\sum_{i=1}^n t_i\n$$\n将导数设为零，得到最大似然估计量 $\\hat{k}$：\n$$\n\\frac{n}{\\hat{k}} - \\sum_{i=1}^n t_i = 0 \\implies \\frac{n}{\\hat{k}} = \\sum_{i=1}^n t_i\n$$\n$$\n\\hat{k} = \\frac{n}{\\sum_{i=1}^n t_i}\n$$\n估计量 $\\hat{k}$ 是等待时间样本均值 $\\bar{t} = \\frac{1}{n}\\sum_{i=1}^n t_i$ 的倒数。\n为确认这是一个最大值，我们检查二阶导数：\n$$\n\\frac{d^2\\ell(k)}{dk^2} = -\\frac{n}{k^2}\n$$\n由于对于任何非平凡情况都有 $n  0$ 和 $k^2  0$，二阶导数恒为负，这证实了 $\\hat{k}$ 对应于似然函数的一个最大值。\n\n### 算法流程\n\n对于每个测试用例，应用以下算法：\n1.  **数据生成**：根据测试用例的特定规则，使用由指定种子初始化的伪随机数生成器生成一个包含 $n$ 个等待时间的时间序列 $\\{t_i\\}_{i=1}^n$，以确保可复现性。\n2.  **速率估计**：使用推导出的公式，从生成的数据中计算速率的最大似然估计值 $\\hat{k}$：\n    $$\n    \\hat{k} = \\frac{n}{\\sum_{i=1}^n t_i}\n    $$\n3.  **时间重标度**：使用推导的时间重标度变换和估计的速率 $\\hat{k}$，将序列中的每个等待时间 $t_i$ 转换为一个新变量 $u_i$：\n    $$\n    u_i = 1 - e^{-\\hat{k}t_i}\n    $$\n    这将产生一个新的重标度时间序列 $\\{u_i\\}_{i=1}^n$。\n4.  **假设检验**：使用 Kolmogorov-Smirnov (KS) 检验来量化 $\\{u_i\\}$ 的经验分布与理论标准均匀分布 $U[0, 1]$ 之间的差异。KS 统计量 $D$ 是 $\\{u_i\\}$ 的经验累积分布函数与 $U[0, 1]$ 的累积分布函数之间的最大绝对差。该检验还会产生一个 $p$ 值，它是在原假设（即 $\\{u_i\\}$ 确实是来自 $U[0, 1]$ 的独立同分布样本）下，观测到至少与测量值一样大的 $D$ 统计量的概率。一个小的 $p$ 值（例如  0.05）表明与原 HPP 模型存在统计上显著的偏差。\n\n### 测试用例分析\n\n该测试套件旨在不同定义明确的场景下验证算法：\n- **案例 A (基准 HPP)**：数据从一个真实的齐次泊松过程生成。我们预期算法会确认原假设。估计速率 $\\hat{k}$ 应接近真实速率 $k=0.5$。变换后的变量 $\\{u_i\\}$ 应近似均匀分布，从而得到一个小的 KS 统计量 $D$ 和一个大的 $p$ 值。\n- **案例 B (精确校正的元动力学)**：此构造确保校正后的时间 $\\{t_i = a_i t_{\\mathrm{b},i}\\}$ 是来自速率为 $k=0.2$ 的指数分布的独立同分布样本。该案例在理论上等同于案例 A。因此，我们预期结果相似：一个小的 $D$ 值和一个大的 $p$ 值，这表明该算法即使在从有偏模拟中恢复统计数据时，也能够正确识别有效的 HPP。\n- **案例 C (错误校正的元动力学)**：加速因子估计中的噪声为校正后的时间引入了乘性误差。由此产生的 $\\{t_i\\}$ 将不再服从指数分布。预期算法将检测到这种偏差。这应该表现为一个大的 KS 统计量 $D$ 和一个相应的小的 $p$ 值，从而导致拒绝 HPP 假设。\n- **案例 D (伽马更新过程)**：等待时间从伽马分布（$r=2$）中抽取，其形状与指数分布（$r=1$ 的伽马分布）不同，尽管其平均等待时间与一个可比较的 HPP 相匹配。检测器应该对这种分布形状的差异敏感。我们预期会得到一个大的 $D$ 统计量和一个非常小的 $p$ 值。\n- **案例 E (小样本 HPP)**：这是一个边缘用例，用于测试在数据有限（$n=10$）时的行为。虽然数据生成过程是真实的 HPP，但对于如此小的样本量，KS 检验的统计功效较低。因此，我们预期不会拒绝原假设（即获得一个大的 $p$ 值），但与大样本情况（案例 A）相比，估计的 $\\hat{k}$ 和 KS 统计量 $D$ 可能显示出更高的方差。\n\n现在，实现将对所有五个案例执行此程序，并按规定报告结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import kstest\n\ndef solve():\n    \"\"\"\n    Solves the problem of detecting non-Poissonian waiting times\n    by implementing and applying a statistical test based on the\n    time-rescaling theorem and Kolmogorov-Smirnov statistic.\n    \"\"\"\n\n    test_cases = [\n        {'name': 'A', 'n': 500, 'k': 0.5, 'seed': 12345},\n        {'name': 'B', 'n': 500, 'k': 0.2, 'seed': 12346},\n        {'name': 'C', 'n': 500, 'k': 0.2, 'seed': 12347},\n        {'name': 'D', 'n': 500, 'k0': 0.5, 'seed': 12348},\n        {'name': 'E', 'n': 10, 'k': 0.5, 'seed': 12349},\n    ]\n\n    results = []\n    for case in test_cases:\n        rng = np.random.default_rng(case['seed'])\n        n = case['n']\n        \n        # --- Data Generation ---\n        if case['name'] == 'A':\n            # Case A: baseline homogeneous Poisson\n            k = case['k']\n            # numpy's exponential uses scale = 1/rate\n            times = rng.exponential(scale=1.0/k, size=n)\n        \n        elif case['name'] == 'B':\n            # Case B: metadynamics-corrected, exact correction\n            k = case['k']\n            # Lognormal parameters are for the underlying Normal distribution\n            log_a_mu = np.log(10)\n            log_a_sigma = 0.5\n            a_i = rng.lognormal(mean=log_a_mu, sigma=log_a_sigma, size=n)\n            \n            # Biased waiting time t_b has rate a_i * k\n            # Scale for exponential is 1 / (a_i * k)\n            t_b_i = rng.exponential(scale=1.0/(a_i * k))\n            \n            # Exactly corrected time\n            times = a_i * t_b_i\n            \n        elif case['name'] == 'C':\n            # Case C: metadynamics-corrected, mis-correction\n            k = case['k']\n            log_a_mu = np.log(10)\n            log_a_sigma = 0.5\n            a_i = rng.lognormal(mean=log_a_mu, sigma=log_a_sigma, size=n)\n            \n            t_b_i = rng.exponential(scale=1.0/(a_i * k))\n            \n            # Estimation noise for acceleration factor\n            epsilon_i = rng.normal(loc=0, scale=0.6, size=n)\n            a_est_i = a_i * np.exp(epsilon_i)\n            \n            # Mis-corrected time\n            times = a_est_i * t_b_i\n\n        elif case['name'] == 'D':\n            # Case D: non-exponential renewal, gamma shape\n            k0 = case['k0']\n            shape_r = 2.0\n            rate_lambda = shape_r * k0\n            # numpy's gamma uses scale = 1/rate\n            scale_theta = 1.0 / rate_lambda\n            times = rng.gamma(shape=shape_r, scale=scale_theta, size=n)\n\n        elif case['name'] == 'E':\n            # Case E: small-sample homogeneous Poisson\n            k = case['k']\n            times = rng.exponential(scale=1.0/k, size=n)\n        \n        # --- Algorithmic Analysis ---\n        \n        # 1. Estimate rate k using MLE\n        # handle case where sum of times is zero to avoid division by zero\n        sum_times = np.sum(times)\n        if sum_times == 0:\n            # This is highly unlikely for exponential waiting times but is good practice\n            k_hat = np.inf\n        else:\n            k_hat = n / sum_times\n\n        # 2. Compute transformed variables (rescaled times)\n        # Using the transformation u = 1 - exp(-k*t)\n        u_values = 1.0 - np.exp(-k_hat * times)\n\n        # 3. Perform Kolmogorov-Smirnov test against standard uniform distribution\n        # kstest returns a result object with statistic and pvalue\n        ks_result = kstest(u_values, 'uniform')\n        D_statistic = ks_result.statistic\n        p_value = ks_result.pvalue\n        \n        # 4. Store rounded results\n        results.append(round(D_statistic, 6))\n        results.append(round(p_value, 6))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}