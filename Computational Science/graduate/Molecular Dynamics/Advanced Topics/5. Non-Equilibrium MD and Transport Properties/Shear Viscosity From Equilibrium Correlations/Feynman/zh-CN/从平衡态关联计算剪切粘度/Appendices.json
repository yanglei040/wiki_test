{
    "hands_on_practices": [
        {
            "introduction": "格林-久保关系的核心是应力自相关函数 (SACF) 的时间积分。因此，我们实践的第一步是从分子动力学模拟产生的离散时间序列数据中，准确地计算出这个函数。本练习将指导你推导并实现一个无偏的自相关函数估计器，这需要将连续的统计力学定义转化为一个稳健的离散算法，是后续所有计算的基础。",
            "id": "3445587",
            "problem": "本题要求您推导并实现一个使用多时间原点和重叠窗口的离散、无偏估计量，用于计算平衡态剪切应力自相关函数，然后用它来计算一个截断的 Green–Kubo 黏度估计值。请在分子动力学（MD）的背景下进行，其中非对角微观剪切应力分量表示为 $P_{xy}(t)$，并且在平衡态下其系综平均为零。您必须从第一性原理和核心定义出发，而不是从已有的相关估计量开始。\n\n出发点与假设：\n- 对于一个系综平均为零的平稳随机过程 $X(t)$，其时间自相关函数定义为\n$$\nC_{X}(t) \\equiv \\lim_{T \\to \\infty} \\frac{1}{T-t} \\int_{0}^{T-t} \\langle X(t_{0}) X(t_{0}+t) \\rangle \\,\\mathrm{d}t_{0}.\n$$\n- 对本问题而言，$X(t) \\equiv P_{xy}(t)$，您可以假设平衡态下的非对角应力系综平均为零，即 $\\langle P_{xy}(t) \\rangle = 0$。\n- 该过程是平稳且各态历经的，因此在长时间极限下，时间平均可以近似系综平均。\n\n任务：\n1) 仅根据上述定义和假设，推导一个使用多时间原点和重叠窗口的、用于剪切应力自相关函数的离散时间无偏估计量。考虑一个长度为 $N$、以时间步长 $\\Delta t$ 均匀采样的离散记录 $P[n] \\equiv P_{xy}(n \\,\\Delta t)$。设有一系列长度为 $L$ 的窗口，其起始索引为 $r \\in \\mathcal{R}$，其中 $\\mathcal{R} \\equiv \\{0, h, 2h, \\dots\\}$ 包括所有满足 $r + L \\le N$ 的起始索引，当 $h  L$ 时允许窗口重叠。对于一个整数延迟 $k \\ge 0$，构建估计量 $\\widehat{C}[k]$，使其在所述假设下是无偏的。明确写出以 $P[n]$、窗口起始点 $r \\in \\mathcal{R}$ 和 $L$ 表示的相应离散时间求和公式，并确定归一化因子如何依赖于 $k$ 和贡献对的数量。\n\n2) 使用您的估计量 $\\widehat{C}[k]$，推导在有限延迟截断 $K$、体积 $V$、温度 $T$ 和 Boltzmann 常数 $k_{\\mathrm{B}}$ 下的剪切黏度 $\\widehat{\\eta}$ 的离散、截断 Green–Kubo 估计，其形式为一个梯形法则时间积分，\n$$\n\\widehat{\\eta} = \\frac{V}{k_{\\mathrm{B}} T} \\int_{0}^{t_{\\max}} \\widehat{C}(t)\\,\\mathrm{d}t, \\quad t_{\\max} = K \\,\\Delta t,\n$$\n并以 $\\{\\widehat{C}[k]\\}_{k=0}^{K}$、$\\Delta t$ 和适当的梯形权重进行离散化。\n\n实现要求：\n- 实现一个程序，根据下面给出的闭式规定为每个测试用例构建 $P[n]$。假设 $\\langle P_{xy} \\rangle = 0$，并且不减去任何样本均值。\n- 对每个测试用例，使用您的无偏、多时间原点、重叠窗口自相关估计量计算 $k = 0,1,\\dots,K$ 时的 $\\widehat{C}[k]$。\n- 通过将您的梯形离散化应用于 $\\{\\widehat{C}[k]\\}_{k=0}^{K}$ 来计算截断的 Green–Kubo 黏度 $\\widehat{\\eta}$。\n- 将每个最终的黏度值以帕斯卡-秒（即 $\\mathrm{Pa \\cdot s}$）为单位表示为一个浮点数。\n- 物理常数必须与单位一致使用，其中 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$。\n\n测试套件：\n对于每个测试，您将获得 $(N, \\Delta t, A, \\alpha, V, T, L, h, K)$ 以及 $P[n]$ 的确定性构造方法，其中 $n=0,1,\\dots,N-1$：\n- 为每个测试用例构造 $P[n] = A \\,(-\\alpha)^{n}$。\n\n为以下所有参数集提供黏度结果：\n- 测试 A（通用重叠、多窗口）：\n  - $N = 32$，$\\Delta t = 1.0 \\times 10^{-15}\\,\\mathrm{s}$，$A = 1.0 \\times 10^{8}\\,\\mathrm{Pa}$，$\\alpha = 0.8$，$V = 1.0 \\times 10^{-24}\\,\\mathrm{m^{3}}$，$T = 300\\,\\mathrm{K}$，$L = 16$，$h = 4$，$K = 10$。\n- 测试 B（非重叠窗口、边界延迟）：\n  - $N = 12$，$\\Delta t = 2.0 \\times 10^{-15}\\,\\mathrm{s}$，$A = 5.0 \\times 10^{7}\\,\\mathrm{Pa}$，$\\alpha = 0.5$，$V = 2.0 \\times 10^{-24}\\,\\mathrm{m^{3}}$，$T = 300\\,\\mathrm{K}$，$L = 6$，$h = 6$，$K = 5$。\n- 测试 C（强重叠、小记录）：\n  - $N = 10$，$\\Delta t = 0.5 \\times 10^{-15}\\,\\mathrm{s}$，$A = 8.0 \\times 10^{7}\\,\\mathrm{Pa}$，$\\alpha = 0.4$，$V = 0.5 \\times 10^{-24}\\,\\mathrm{m^{3}}$，$T = 500\\,\\mathrm{K}$，$L = 7$，$h = 1$，$K = 5$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个黏度估计值，格式为一个无空格、逗号分隔的 Python 列表，顺序为 $[\\widehat{\\eta}_{\\mathrm{A}},\\widehat{\\eta}_{\\mathrm{B}},\\widehat{\\eta}_{\\mathrm{C}}]$，单位为 $\\mathrm{Pa \\cdot s}$。",
            "solution": "该问题被评估为有效，因为它具有科学依据、问题适定且客观。它基于统计力学（Green-Kubo 关系）和时间序列分析的既定原理，为得到唯一、可验证的解提供了所有必要的参数和定义。\n\n根据要求，解答分为两部分：首先，推导剪切应力自相关函数的无偏估计量；其次，推导离散的 Green-Kubo 黏度估计。\n\n### 1. 无偏自相关估计量的推导\n\n目标是为剪切应力 $P_{xy}(t)$ 在离散时间延迟 $t = k\\Delta t$ 处的真实平衡态自相关函数 $C(t)$ 推导一个无偏估计量，记为 $\\widehat{C}[k]$。我们给定一个离散时间序列 $P[n] \\equiv P_{xy}(n\\Delta t)$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。该过程是平稳且均值为零的，因此真实的离散自相关函数为 $C[k] \\equiv \\langle P[n] P[n+k] \\rangle$，它与时间原点 $n$ 无关。如果一个估计量 $\\widehat{C}[k]$ 的期望值等于真值，即 $E[\\widehat{C}[k]] = C[k]$，则该估计量是无偏的。\n\n估计将使用多个时间原点，这些原点来自由长度为 $L$、起始索引为 $r \\in \\mathcal{R}$ 的数据段（窗口）。起始索引的集合是 $\\mathcal{R} = \\{ih \\mid i \\in \\mathbb{N}_0, ih+L \\le N\\}$，其中 $h$ 是窗口原点之间的步长。此类窗口的数量 $M_w$ 由 $i$ 的可能取值个数决定，其范围从 $0$ 到 $\\lfloor(N-L)/h\\rfloor$。因此，$M_w = \\lfloor \\frac{N-L}{h} \\rfloor + 1$。\n\n在每个以索引 $r$ 开始的窗口内，对于给定的延迟 $k$，我们可以构成乘积 $P[n]P[n+k]$。为了使这样的乘积能从该窗口内的数据计算得出，索引 $n$ 和 $n+k$ 都必须位于窗口边界内，即 $r \\le n$ 且 $n+k \\le r+L-1$。这限制了时间原点 $n$ 的范围为 $r \\le n \\le r+L-1-k$。这对于满足 $0 \\le k  L$ 的延迟 $k$ 是有效的。\n\n我们构建原始和 $S[k]$，方法是在所有指定的窗口内对所有可用的时间原点上的所有此类乘积求和：\n$$\nS[k] = \\sum_{r \\in \\mathcal{R}} \\sum_{n=r}^{r+L-1-k} P[n] P[n+k]\n$$\n为了找到使估计量无偏的归一化因子，我们取 $S[k]$ 的期望值：\n$$\nE[S[k]] = E\\left[ \\sum_{r \\in \\mathcal{R}} \\sum_{n=r}^{r+L-1-k} P[n] P[n+k] \\right]\n$$\n根据期望的线性性，我们可以将算子移到求和符号内：\n$$\nE[S[k]] = \\sum_{r \\in \\mathcal{R}} \\sum_{n=r}^{r+L-1-k} E[P[n] P[n+k]]\n$$\n由于过程的平稳性，期望 $E[P[n] P[n+k]]$ 是真实的自相关函数 $C[k]$，它不依赖于 $n$。\n$$\nE[S[k]] = \\sum_{r \\in \\mathcal{R}} \\sum_{n=r}^{r+L-1-k} C[k]\n$$\n该表达式现在简化为 $C[k]$ 乘以求和中的总项数。我们将这个数称为 $N_{pairs}(k)$。对于一个从 $r$ 开始的单个窗口，关于 $n$ 的内层求和有 $(r+L-1-k) - r + 1 = L-k$ 项。由于此计数与 $r$ 无关，且集合 $\\mathcal{R}$ 中有 $M_w$ 个窗口，总对数为：\n$$\nN_{pairs}(k) = \\sum_{r \\in \\mathcal{R}} (L-k) = M_w (L-k)\n$$\n因此，原始和的期望值为：\n$$\nE[S[k]] = N_{pairs}(k) C[k] = M_w (L-k) C[k]\n$$\n为得到无偏估计量 $\\widehat{C}[k]$，我们必须用 $N_{pairs}(k)$ 来归一化 $S[k]$：\n$$\n\\widehat{C}[k] = \\frac{S[k]}{N_{pairs}(k)} = \\frac{1}{M_w (L-k)} \\sum_{r \\in \\mathcal{R}} \\sum_{n=r}^{r+L-1-k} P[n] P[n+k]\n$$\n其中 $M_w = \\lfloor \\frac{N-L}{h} \\rfloor + 1$ 且 $\\mathcal{R} = \\{ih \\mid i = 0, 1, \\dots, M_w-1\\}$。这是无偏估计量的最终表达式。归一化因子 $1/(M_w(L-k))$ 依赖于延迟 $k$，这是有限长度信号的无偏自相关估计量的特征。\n\n### 2. Green-Kubo 积分用于剪切黏度的离散化\n\n剪切黏度 $\\eta$ 通过 Green-Kubo 公式与剪切应力自相关函数（SACF）的时间积分相关。给定我们在离散时间 $t_k = k\\Delta t$ 处对 SACF 的估计量 $\\widehat{C}[k]$，我们需要计算黏度的估计值 $\\widehat{\\eta}$。公式为：\n$$\n\\widehat{\\eta} = \\frac{V}{k_{\\mathrm{B}} T} \\int_{0}^{t_{\\max}} \\widehat{C}(t)\\,\\mathrm{d}t\n$$\n其中 $V$ 是体积，$k_{\\mathrm{B}}$ 是 Boltzmann 常数，$T$ 是温度，积分在 $t_{\\max} = K\\Delta t$ 处截断。\n\n我们使用梯形法则来近似该积分。积分区间为 $[0, K\\Delta t]$，该区间被点集 $\\{t_0, t_1, \\dots, t_K\\}$ 划分为 $K$ 个等宽 $\\Delta t$ 的子区间。梯形法则近似为：\n$$\n\\int_{0}^{K\\Delta t} \\widehat{C}(t)\\,\\mathrm{d}t \\approx \\sum_{k=0}^{K-1} \\frac{\\Delta t}{2} (\\widehat{C}[k] + \\widehat{C}[k+1])\n$$\n展开求和项得到：\n$$\n\\frac{\\Delta t}{2} [(\\widehat{C}[0]+\\widehat{C}[1]) + (\\widehat{C}[1]+\\widehat{C}[2]) + \\dots + (\\widehat{C}[K-1]+\\widehat{C}[K])]\n$$\n$$\n= \\frac{\\Delta t}{2} [\\widehat{C}[0] + 2\\widehat{C}[1] + 2\\widehat{C}[2] + \\dots + 2\\widehat{C}[K-1] + \\widehat{C}[K]]\n$$\n这可以用权重 $w_k$ 紧凑地表示，其中 $w_0=w_K=1/2$ 且对于 $1 \\le k \\le K-1$ 有 $w_k=1$：\n$$\n\\int_{0}^{K\\Delta t} \\widehat{C}(t)\\,\\mathrm{d}t \\approx \\Delta t \\left( \\frac{\\widehat{C}[0] + \\widehat{C}[K]}{2} + \\sum_{k=1}^{K-1} \\widehat{C}[k] \\right)\n$$\n将此离散近似代入 Green-Kubo 公式，得到截断黏度估计的最终表达式：\n$$\n\\widehat{\\eta} = \\frac{V \\Delta t}{k_{\\mathrm{B}} T} \\left( \\frac{\\widehat{C}[0] + \\widehat{C}[K]}{2} + \\sum_{k=1}^{K-1} \\widehat{C}[k] \\right)\n$$\n该公式将用于实现。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the truncated Green-Kubo shear viscosity for three test cases\n    based on a derived unbiased, multi-origin, overlapping-window\n    autocorrelation function estimator.\n    \"\"\"\n    \n    # Physical constants\n    KB = 1.380649e-23  # Boltzmann constant in J/K\n\n    # Test suite parameters\n    test_cases = [\n        # Test A: general overlapping, multiple windows\n        (32, 1.0e-15, 1.0e8, 0.8, 1.0e-24, 300, 16, 4, 10),\n        # Test B: non-overlapping windows, boundary lag\n        (12, 2.0e-15, 5.0e7, 0.5, 2.0e-24, 300, 6, 6, 5),\n        # Test C: strongly overlapping, small record\n        (10, 0.5e-15, 8.0e7, 0.4, 0.5e-24, 500, 7, 1, 5),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, dt, A, alpha, V, T, L, h, K = case\n\n        # 1. Construct the discrete shear stress signal P[n]\n        n_indices = np.arange(N)\n        P = A * (-alpha) ** n_indices\n\n        # 2. Compute the unbiased autocorrelation function C_hat[k]\n        #    using multiple time origins and overlapping windows.\n        \n        # Determine the number of windows and their starting indices\n        if N  L:\n             Mw = 0\n        else:\n             Mw = (N - L) // h + 1\n        \n        window_starts = [i * h for i in range(Mw)]\n        \n        C_hat = np.zeros(K + 1)\n\n        # The derivation requires K  L. Let's ensure this holds.\n        if K >= L:\n            raise ValueError(f\"Lag cutoff K={K} must be less than window length L={L}.\")\n\n        for k in range(K + 1):\n            if Mw == 0:\n                C_hat[k] = 0.0 # Or nan, but 0 is safe if it's not integrated\n                continue\n\n            # Un-normalized sum of products P[n]P[n+k]\n            S_k = 0.0\n            \n            # Sum over all windows\n            for r in window_starts:\n                # Sum over all valid time origins n within the window\n                # Range for n is [r, r + L - 1 - k]\n                for n in range(r, r + L - k):\n                    S_k += P[n] * P[n + k]\n            \n            # Normalization factor for unbiased estimator\n            # Number of pairs = (Number of windows) * (Pairs per window)\n            N_pairs_k = Mw * (L - k)\n            \n            if N_pairs_k > 0:\n                C_hat[k] = S_k / N_pairs_k\n            else:\n                 # This case should not be reached if K  L and Mw > 0\n                C_hat[k] = 0.0\n\n        # 3. Compute the truncated Green-Kubo viscosity estimate\n        #    using the trapezoidal rule for the integral.\n        \n        integral_sum = 0.0\n        if K > 0:\n            # sum(C_hat[k]) with weights (0.5, 1, 1, ..., 1, 0.5)\n            integral_sum = 0.5 * (C_hat[0] + C_hat[K]) + np.sum(C_hat[1:K])\n        \n        # Handle the K=0 case separately: integral from 0 to 0 is 0.\n        # But for K>0, we multiply by dt.\n        integral_val = dt * integral_sum if K > 0 else 0.0\n\n        # Viscosity calculation\n        prefactor = V / (KB * T)\n        eta = prefactor * integral_val\n        results.append(eta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "得到粘度的估计值后，下一个关键问题是：“这个结果的置信度有多高？”。由于模拟数据点之间存在时间相关性，简单的统计方法会低估误差。本练习将介绍分块平均法，这是一种处理相关时间序列数据的标准误差分析技术，并让你计算积分自相关时间，以量化系统的“记忆”时长和模拟的统计效率。",
            "id": "3445615",
            "problem": "您将实现一个完整的程序，用于分析以均匀时间步长 $\\Delta t$ 采样的非对角微观应力分量 $P_{xy}(t)$ 的平衡分子动力学时间序列，并估算与从平衡相关性计算剪切粘度相关的关键量。您的程序必须推导并计算归一化应力自相关函数的积分自相关时间 $\\tau_{\\mathrm{int}}$，并使用分块平均法量化粘度估算量的统计不确定性。程序必须是自包含的，并按规定产生单行输出。\n\n使用以下基本原理：用于粒子运动的牛顿动力学、微观应力张量分量的定义、平衡相关函数的系综平均，以及将输运系数与平衡自相关函数的时间积分联系起来的平衡线性响应范式。您不得假设或使用任何未经原则性推导而直接得出目标的快捷公式。\n\n要实现的定义和任务：\n\n- 令 $P_{xy}(t_i)$ 表示在时间 $t_i = i \\Delta t$（其中 $i \\in \\{0,1,\\dots,N-1\\}$ 且 $\\Delta t  0$）采样的微观非对角应力时间序列。应减去样本均值 $\\bar{P}$ 以形成一个零均值序列 $X_i = P_{xy}(t_i) - \\bar{P}$。\n- 将延迟指数为 $k$ 的无偏时间原点平均离散自相关函数定义为\n$$\nC(k) = \\frac{1}{N-k}\\sum_{n=0}^{N-k-1} X_n X_{n+k},\n$$\n其中 $k \\in \\{0,1,\\dots,N-1\\}$。将归一化自相关函数定义为\n$$\n\\phi(k) = \\frac{C(k)}{C(0)}。\n$$\n- 将积分自相关时间（单位：秒）定义为具有基于物理动机的截断的离散时间积分：\n$$\n\\tau_{\\mathrm{int}} = \\sum_{k=0}^{K_{\\mathrm{cut}}} \\phi(k) \\,\\Delta t,\n$$\n其中 $K_{\\mathrm{cut}}$ 使用以下窗口规则选择：找到满足 $\\phi(j) \\le 0$ 的最小延迟 $j \\ge 1$；如果存在这样的 $j$，则设置 $K_{\\mathrm{cut}} = j-1$。如果在最大可用延迟内没有符号变化，则将 $K_{\\mathrm{cut}}$ 设置为不超过给定上界 $t_{\\max}$ 的最大延迟，即 $K_{\\mathrm{cut}} = \\min\\{N-1, \\lfloor t_{\\max}/\\Delta t \\rfloor\\}$。\n- 粘度估算量 $\\hat{\\eta}$ 来自未归一化自相关函数的时间积分，并按平衡线性响应所要求的正确热力学预因子进行缩放。您必须使用与上述相同的截断值 $K_{\\mathrm{cut}}$ 计算 $\\hat{\\eta}$（单位：帕斯卡·秒）。使用提供的物理参数：系统体积 $V$（单位：$\\mathrm{m^3}$）、绝对温度 $T$（单位：$\\mathrm{K}$）以及玻尔兹曼常数 $k_{\\mathrm{B}}$（单位：$\\mathrm{J/K}$）。所有涉及粘度的输出都必须以 $\\mathrm{Pa\\cdot s}$ 表示。\n- 使用分块平均法量化 $\\hat{\\eta}$ 的统计不确定性：将时间序列划分为 $B$ 个长度相等的非重叠连续块 $L_{\\mathrm{block}}$（舍弃任何余数）。对每个块 $b$，使用与上述相同的过程计算一个块级粘度估计值 $\\hat{\\eta}_b$。计算这 $B$ 个块估计值的样本标准差 $s_{\\hat{\\eta}}$（分母为 $B-1$），并估算 $\\hat{\\eta}$ 的标准误差为\n$$\n\\mathrm{SE}(\\hat{\\eta}) = \\frac{s_{\\hat{\\eta}}}{\\sqrt{B}}。\n$$\n- 根据 $\\tau_{\\mathrm{int}}$ 估算统计上独立的样本的有效数量：\n$$\nN_{\\mathrm{eff}} = \\frac{N\\,\\Delta t}{2 \\,\\tau_{\\mathrm{int}}}。\n$$\n\n您的程序必须使用数值稳定的方法，为所有延迟高效且可复现地实现无偏自相关。数值积分应严格按照上述规定，使用带有截断规则的离散求和来执行，分块平均不确定性必须遵循此处给出的定义。\n\n物理单位和输出要求：\n\n- 所有时间量必须以秒为单位。\n- 应力 $P_{xy}$ 必须以帕斯卡为单位。\n- 体积 $V$ 必须以 $\\mathrm{m^3}$ 为单位。\n- 温度 $T$ 必须以开尔文为单位。\n- 玻尔兹曼常数 $k_{\\mathrm{B}}$ 为 $1.380649 \\times 10^{-23}$ $\\mathrm{J/K}$。\n- 粘度必须以 $\\mathrm{Pa\\cdot s}$ 报告。\n- 您的程序必须将每个报告的浮点数四舍五入到六位有效数字。\n\n测试套件：\n\n为以下三个确定性的合成测试用例实现您的程序。在每个用例中，时间序列 $P_{xy}(t_i)$ 被定义为模拟平衡应力涨落的多个物理上合理的零均值分量之和：一个指数衰减项、一个振荡衰减项，以及一个来自逻辑斯谛映射的有界确定性混沌项。令逻辑斯谛序列 $\\{s_n\\}$ 由 $s_{n+1} = r s_n (1 - s_n)$ 定义，初始值为 $s_0$，参数为 $r$，并令 $s_n'$ 表示其中心化版本 $s_n' = s_n - \\frac{1}{N}\\sum_{m=0}^{N-1} s_m$。对于每个用例，定义\n$$\nP_{xy}(t_i) = A \\,\\mathrm{e}^{-\\alpha t_i} + B \\cos(\\omega t_i)\\,\\mathrm{e}^{-\\beta t_i} + C \\, s_i',\n$$\n其中常数 $A$、$B$、$C$ 的单位为帕斯卡，$\\alpha$、$\\beta$ 的单位为 $\\mathrm{s^{-1}}$，$\\omega$ 的单位为 $\\mathrm{rad/s}$。\n\n- 用例1（带弱振荡的一般衰减）：\n    - $N = 4096$，$\\Delta t = 5.0 \\times 10^{-15}$ $\\mathrm{s}$，$V = 1.0 \\times 10^{-27}$ $\\mathrm{m^3}$，$T = 300$ $\\mathrm{K}$，$t_{\\max} = 5.0 \\times 10^{-12}$ $\\mathrm{s}$，$L_{\\mathrm{block}} = 512$。\n    - 参数：$A = 5.0 \\times 10^{6}$ $\\mathrm{Pa}$，$\\alpha = 7.0 \\times 10^{11}$ $\\mathrm{s^{-1}}$，$B = 2.0 \\times 10^{6}$ $\\mathrm{Pa}$，$\\beta = 2.0 \\times 10^{12}$ $\\mathrm{s^{-1}}$，$\\omega = 2.0 \\times 10^{12}$ $\\mathrm{rad/s}$，$C = 1.0 \\times 10^{6}$ $\\mathrm{Pa}$。\n    - 逻辑斯谛映射：$r = 3.9$，$s_0 = 0.123$。\n\n- 用例2（带啁啾振荡的长尾衰减）：\n    - $N = 6000$，$\\Delta t = 2.0 \\times 10^{-15}$ $\\mathrm{s}$，$V = 5.0 \\times 10^{-28}$ $\\mathrm{m^3}$，$T = 350$ $\\mathrm{K}$，$t_{\\max} = 8.0 \\times 10^{-12}$ $\\mathrm{s}$，$L_{\\mathrm{block}} = 500$。\n    - 参数：$A = 4.0 \\times 10^{6}$ $\\mathrm{Pa}$，用拉伸衰减 $\\mathrm{e}^{-(\\gamma t)^{1/2}}$ 替代 $\\mathrm{e}^{-\\alpha t}$，其中 $\\gamma = 5.0 \\times 10^{11}$ $\\mathrm{s^{-1}}$，$B = 5.0 \\times 10^{5}$ $\\mathrm{Pa}$，$\\beta = 1.0 \\times 10^{12}$ $\\mathrm{s^{-1}}$，$\\omega_0 = 5.0 \\times 10^{12}$ $\\mathrm{rad/s}$，$\\alpha_2 = 1.0 \\times 10^{12}$ $\\mathrm{s^{-2}}$，并对振荡项使用 $\\cos(\\omega_0 t + \\tfrac{1}{2}\\alpha_2 t^2)$，$C = 5.0 \\times 10^{5}$ $\\mathrm{Pa}$。\n    - 逻辑斯谛映射：$r = 3.9$，$s_0 = 0.231$。\n\n- 用例3（穿越零点的强振荡）：\n    - $N = 3000$，$\\Delta t = 1.0 \\times 10^{-15}$ $\\mathrm{s}$，$V = 2.0 \\times 10^{-27}$ $\\mathrm{m^3}$，$T = 250$ $\\mathrm{K}$，$t_{\\max} = 4.0 \\times 10^{-12}$ $\\mathrm{s}$，$L_{\\mathrm{block}} = 300$。\n    - 参数：$A = 1.0 \\times 10^{6}$ $\\mathrm{Pa}$，$\\alpha = 4.0 \\times 10^{12}$ $\\mathrm{s^{-1}}$，$B = 6.0 \\times 10^{6}$ $\\mathrm{Pa}$，$\\beta = 1.0 \\times 10^{12}$ $\\mathrm{s^{-1}}$，$\\omega = 8.0 \\times 10^{12}$ $\\mathrm{rad/s}$，$C = 3.0 \\times 10^{5}$ $\\mathrm{Pa}$。\n    - 逻辑斯谛映射：$r = 3.9$，$s_0 = 0.345$。\n\n对于用例2，将第一项解释为 $A \\,\\mathrm{e}^{-(\\gamma t)^{1/2}}$ 而不是 $A \\,\\mathrm{e}^{-\\alpha t}$，并将振荡项解释为 $B \\cos\\!\\big(\\omega_0 t + \\tfrac{1}{2}\\alpha_2 t^2\\big)\\,\\mathrm{e}^{-\\beta t}$。\n\n最终输出格式：\n\n- 对于每个测试用例，计算并报告三元组 $\\big[\\tau_{\\mathrm{int}}, \\mathrm{SE}(\\hat{\\eta}), N_{\\mathrm{eff}}\\big]$，其中 $\\tau_{\\mathrm{int}}$ 单位为秒，$\\mathrm{SE}(\\hat{\\eta})$ 单位为 $\\mathrm{Pa\\cdot s}$，$N_{\\mathrm{eff}}$ 为无单位浮点数。\n- 您的程序应生成单行输出，其中包含三个测试用例的结果，格式为包含在方括号中的、由逗号分隔的列表的列表，例如：“[[tau1,se1,neff1],[tau2,se2,neff2],[tau3,se3,neff3]]”。\n- 每个浮点数必须四舍五入到六位有效数字。",
            "solution": "该问题已经过验证，被认为是合理的。它在科学上基于平衡统计力学的原理，特别是关于输运系数的 Green-Kubo 形式主义。该问题是良构的，提供了所有必要的定义、数据和清晰的确定性计算流程，确保了唯一解的存在。其语言是客观的，参数在分子动力学模拟背景下是物理上合理的。没有发现矛盾、歧义或不合理的假设。\n\n此处提出的解决方案系统地实现了所需的计算。问题的核心是从微观应力张量分量 $P_{xy}(t)$ 的时间序列中估算剪切粘度 $\\eta$。这是通过利用 Green-Kubo 关系实现的，该关系将宏观输运系数与平衡时间相关函数的时间积分联系起来。\n\n剪切粘度的基本关系是：\n$$\n\\eta = \\frac{V}{k_{\\mathrm{B}}T} \\int_0^\\infty \\langle P_{xy}(0) P_{xy}(t) \\rangle \\, dt\n$$\n其中 $V$ 是系统体积，$T$ 是温度，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$\\langle \\cdot \\rangle$ 表示系综平均。在计算环境中，我们使用长度为 $N$、时间步长为 $\\Delta t$ 的离散时间序列 $P_{xy}(t_i)$，并且系综平均被时间平均所取代。\n\n算法流程如下：\n\n首先，通过减去样本均值 $\\bar{P}$，使输入的时间序列 $P_{xy}(t_i)$ 变为零均值。这得到了涨落序列 $X_i = P_{xy}(t_i) - \\bar{P}$。对于一个平衡系统，非对角应力分量的平均值为零，因此 $\\bar{P}$ 预期接近于零，此步骤校正了任何有限样本偏差。\n\n其次，计算无偏的、时间原点平均的离散自相关函数 (ACF)。对于 $k$ 步的时间延迟，ACF 由下式给出：\n$$\nC(k) = \\frac{1}{N-k}\\sum_{n=0}^{N-k-1} X_n X_{n+k}\n$$\n该函数测量应力涨落与其自身在稍后时间的相互关系。因子 $\\frac{1}{N-k}$ 为每个延迟 k 提供了无偏估计。对所有延迟 $k \\in \\{0, 1, \\dots, N-1\\}$ 执行此计算。为了更直观的理解，还计算了归一化 ACF, $\\phi(k) = C(k)/C(0)$。根据定义，$\\phi(0)=1$。\n\n第三，ACF 的积分通过离散求和来近似。一个关键步骤是确定此求和的上限 $K_{\\mathrm{cut}}$。在长时间下，ACF 尾部的噪声会降低积分估计的质量。一种如问题中所述的常用启发式方法是，在 ACF 首次失去其正相关性时终止积分。截断值 $K_{\\mathrm{cut}}$ 定义为 $j-1$，其中 $j$ 是满足 $\\phi(j) \\le 0$ 的最小延迟指数（$j \\ge 1$）。如果 ACF 保持为正，则使用最大积分时间 $t_{\\max}$ 来定义截断值, $K_{\\mathrm{cut}} = \\min\\{N-1, \\lfloor t_{\\max}/\\Delta t \\rfloor\\}$。\n\n第四，使用此截断值计算两个关键量。积分自相关时间 $\\tau_{\\mathrm{int}}$ 是*归一化* ACF 的积分：\n$$\n\\tau_{\\mathrm{int}} = \\sum_{k=0}^{K_{\\mathrm{cut}}} \\phi(k) \\,\\Delta t\n$$\n$\\tau_{\\mathrm{int}}$ 代表了应力涨落的特征时间尺度。粘度估算量 $\\hat{\\eta}$ 是根据*未归一化* ACF 的积分计算得出的，并按 Green-Kubo 关系中的热力学预因子进行缩放：\n$$\n\\hat{\\eta} = \\frac{V}{k_{\\mathrm{B}} T} \\sum_{k=0}^{K_{\\mathrm{cut}}} C(k) \\,\\Delta t\n$$\n此估算量必须以帕斯卡·秒（$\\mathrm{Pa \\cdot s}$）为单位报告。\n\n第五，使用分块平均法估算 $\\hat{\\eta}$ 的统计不确定性。将长度为 $N$ 的完整时间序列划分为 $B$ 个长度为 $L_{\\mathrm{block}}$ 的不重叠块。对于每个块，使用与完整序列完全相同的过程（即，在块内进行零均值化、计算块的 ACF 并进行积分）来计算特定于块的粘度估计值 $\\hat{\\eta}_b$。然后，这些块估计值均值的标准误差计算如下：\n$$\n\\mathrm{SE}(\\hat{\\eta}) = \\frac{s_{\\hat{\\eta}}}{\\sqrt{B}}\n$$\n其中 $s_{\\hat{\\eta}}$ 是集合 $\\{\\hat{\\eta}_1, \\hat{\\eta}_2, \\dots, \\hat{\\eta}_B\\}$ 的样本标准差，计算时分母为 $B-1$，以作为方差的无偏估计量。\n\n最后，估算原始时间序列中统计上独立样本的有效数量。这个量 $N_{\\mathrm{eff}}$ 考虑了数据的相关时间，并由下式给出：\n$$\nN_{\\mathrm{eff}} = \\frac{T_{\\mathrm{total}}}{2 \\,\\tau_{\\mathrm{int}}} = \\frac{N\\,\\Delta t}{2 \\,\\tau_{\\mathrm{int}}}\n$$\n因子 2 的引入是因为一个相关序列均值的方差约是一个同样长度的不相关序列方差的 $2\\tau_{\\mathrm{int}} / T_{\\mathrm{total}}$ 倍。\n\n所提供的程序实现了这一完整流程。它首先根据指定的函数形式为每个测试用例生成合成时间序列，这些形式包括指数和振荡衰减，以及来自逻辑斯谛映射的确定性混沌分量。设计了一个中央辅助函数，用于计算任何给定时间序列的 $\\tau_{\\mathrm{int}}$ 和 $\\hat{\\eta}$，然后将其应用于完整数据集和每个单独的块。每个测试用例的最终结果 $[\\tau_{\\mathrm{int}}, \\mathrm{SE}(\\hat{\\eta}), N_{\\mathrm{eff}}]$ 被收集、四舍五入到六位有效数字，并格式化为指定的单行输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It generates synthetic time series, computes viscosity-related quantities,\n    and formats the output as specified.\n    \"\"\"\n    \n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"N\": 4096, \"delta_t\": 5.0e-15, \"V\": 1.0e-27, \"T\": 300, \n            \"t_max\": 5.0e-12, \"L_block\": 512,\n            \"func_type\": 1,\n            \"params\": {\n                \"A\": 5.0e6, \"alpha\": 7.0e11, \"B\": 2.0e6, \"beta\": 2.0e12,\n                \"omega\": 2.0e12, \"C\": 1.0e6, \"r\": 3.9, \"s0\": 0.123\n            }\n        },\n        {\n            \"name\": \"Case 2\",\n            \"N\": 6000, \"delta_t\": 2.0e-15, \"V\": 5.0e-28, \"T\": 350,\n            \"t_max\": 8.0e-12, \"L_block\": 500,\n            \"func_type\": 2,\n            \"params\": {\n                \"A\": 4.0e6, \"gamma\": 5.0e11, \"B\": 5.0e5, \"beta\": 1.0e12,\n                \"omega0\": 5.0e12, \"alpha2\": 1.0e12, \"C\": 5.0e5, \"r\": 3.9, \"s0\": 0.231\n            }\n        },\n        {\n            \"name\": \"Case 3\",\n            \"N\": 3000, \"delta_t\": 1.0e-15, \"V\": 2.0e-27, \"T\": 250,\n            \"t_max\": 4.0e-12, \"L_block\": 300,\n            \"func_type\": 1, \n            \"params\": {\n                \"A\": 1.0e6, \"alpha\": 4.0e12, \"B\": 6.0e6, \"beta\": 1.0e12,\n                \"omega\": 8.0e12, \"C\": 3.0e5, \"r\": 3.9, \"s0\": 0.345\n            }\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        N, delta_t = case[\"N\"], case[\"delta_t\"]\n        params = case[\"params\"]\n        \n        t = np.arange(N) * delta_t\n\n        # Generate logistic map sequence\n        s = np.zeros(N)\n        s[0] = params[\"s0\"]\n        for n in range(N - 1):\n            s[n+1] = params[\"r\"] * s[n] * (1 - s[n])\n        s_prime = s - np.mean(s)\n\n        # Generate P_xy time series\n        if case[\"func_type\"] == 1:\n            P_xy = (params[\"A\"] * np.exp(-params[\"alpha\"] * t) +\n                    params[\"B\"] * np.cos(params[\"omega\"] * t) * np.exp(-params[\"beta\"] * t) +\n                    params[\"C\"] * s_prime)\n        else: # Case 2\n            P_xy = (params[\"A\"] * np.exp(-(params[\"gamma\"] * t)**0.5) +\n                    params[\"B\"] * np.cos(params[\"omega0\"] * t + 0.5 * params[\"alpha2\"] * t**2) * np.exp(-params[\"beta\"] * t) +\n                    params[\"C\"] * s_prime)\n\n        # Full series analysis for tau_int and N_eff\n        tau_int_full, _ = _calculate_viscosity_bundle(\n            P_xy, delta_t, case[\"V\"], case[\"T\"], case[\"t_max\"], k_B\n        )\n        \n        if tau_int_full > 0:\n            N_eff = (N * delta_t) / (2 * tau_int_full)\n        else:\n            N_eff = float('inf')\n\n        # Block averaging for uncertainty\n        L_block = case[\"L_block\"]\n        num_blocks = N // L_block\n        block_viscosities = []\n        \n        for i in range(num_blocks):\n            start_idx = i * L_block\n            end_idx = start_idx + L_block\n            block_Pxy = P_xy[start_idx:end_idx]\n            \n            _, eta_b = _calculate_viscosity_bundle(\n                block_Pxy, delta_t, case[\"V\"], case[\"T\"], case[\"t_max\"], k_B\n            )\n            block_viscosities.append(eta_b)\n        \n        if num_blocks > 1:\n            s_eta = np.std(block_viscosities, ddof=1)\n            SE_eta = s_eta / np.sqrt(num_blocks)\n        else:\n            SE_eta = float('nan')\n\n        all_results.append([tau_int_full, SE_eta, N_eff])\n\n    # Format output\n    formatted_results = [\n        [format(val, '.6g') for val in res]\n        for res in all_results\n    ]\n    case_strings = [f\"[{','.join(sublist)}]\" for sublist in formatted_results]\n    final_string = f\"[{','.join(case_strings)}]\"\n    print(final_string)\n\ndef _calculate_viscosity_bundle(series_Pxy, delta_t, V, T, t_max, k_B):\n    \"\"\"\n    Calculates tau_int and eta_hat for a given time series.\n    \n    Args:\n        series_Pxy (np.array): The time series data for P_xy.\n        delta_t (float): Time step in seconds.\n        V (float): System volume in m^3.\n        T (float): Temperature in Kelvin.\n        t_max (float): Max integration time for cutoff rule.\n        k_B (float): Boltzmann constant.\n        \n    Returns:\n        (float, float): A tuple containing (tau_int, eta_hat).\n    \"\"\"\n    M = len(series_Pxy)\n    if M == 0:\n        return 0.0, 0.0\n        \n    X = series_Pxy - np.mean(series_Pxy)\n\n    # Unbiased autocorrelation function C(k)\n    C = np.zeros(M)\n    for k in range(M):\n        # The formula in the problem is C(k) = 1/(N-k) * sum(X_n * X_{n+k})\n        # This is well-defined for k=0...N-1. At k=N-1, N-k=1.\n        C[k] = np.dot(X[0:M-k], X[k:M]) / (M-k)\n\n    if C[0] == 0:\n        return 0.0, 0.0\n    \n    phi = C / C[0]\n\n    # Determine integration cutoff K_cut\n    # Find smallest j >= 1 where phi(j) = 0\n    # Search in phi starting from index 1.\n    neg_indices = np.where(phi[1:] = 0)[0] \n    if len(neg_indices) > 0:\n        j = neg_indices[0] + 1\n        K_cut = j - 1\n    else:\n        K_cut = int(min(M - 1, np.floor(t_max / delta_t)))\n\n    # Perform discrete integration up to K_cut\n    k_range = np.arange(K_cut + 1)\n    \n    tau_int = np.sum(phi[k_range]) * delta_t\n    \n    eta_hat = (V / (k_B * T)) * np.sum(C[k_range]) * delta_t\n    \n    return tau_int, eta_hat\n\nsolve()\n```"
        },
        {
            "introduction": "我们的最终目标是预测宏观材料的性质，但模拟总是在有限尺寸的周期性盒子中进行。为了弥合这一差距，我们需要处理由系统尺寸限制引入的系统误差。本练习将引导你运用流体动力学理论预测的标度律，对不同尺寸下的模拟数据进行拟合与外推，从而估算出无限大系统（即热力学极限）下的粘度值。",
            "id": "3445656",
            "problem": "考虑一个通过平衡态分子动力学模拟的、遵循牛顿运动方程的周期性经典多粒子体系。剪切黏度 $\\eta$ 可以通过平衡态应力自相关的时间积分（Green–Kubo 关系）在约化单位下计算，其通用形式可写作 $\\eta = \\frac{V}{k_{\\mathrm{B}} T} \\int_{0}^{\\infty} C_{P_{xy}}(t) \\, dt$，其中 $V$ 是体系体积，$T$ 是绝对温度，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$P_{xy}$ 是微观应力张量的非对角分量，$C_{P_{xy}}(t)$ 是 $P_{xy}$ 的平衡态自相关函数。由于线性尺寸为 $L$ 的周期性盒子中的有限尺寸效应，流体动力学涨落和长波模式会使测量到的 $\\hat{\\eta}(L)$ 偏离其无限大尺寸极限 $\\eta_{\\infty}$。理论流体动力学约束了主导的有限尺寸修正项，其在二维和三维中具有不同的渐近形式，这促使我们用特定的标度 ansatz 对数据进行检验，以提取 $\\eta_{\\infty}$。\n\n你的任务是编写一个程序，给定一个包含体系尺寸 $L$、测量的剪切黏度 $\\hat{\\eta}(L)$ 及其已知标准差 $\\sigma(L)$（反映了 Green–Kubo 积分的采样不确定性），以及名义空间维度 $d$ 的小型测试套件，执行受控的外推，以估计以约化无量纲单位表示的无限大尺寸剪切黏度 $\\eta_{\\infty}$。该外推必须基于对受流体动力学启发的候选模型的加权非线性最小二乘拟合（使用报告的 $\\sigma(L)$），并且在报告 $\\eta_{\\infty}$ 之前，必须使用一个模型选择准则来选择最合适的标度形式。\n\n你必须将你的推理建立在适用于分子动力学和连续介质流体动力学的基本原理之上：导致平衡态时间相关的牛顿微观动力学、用于输运系数的 Green–Kubo 关系，以及产生有限尺寸修正的流体动力学模式和长时间拖尾的存在。在此基础上，实现一个鲁棒的算法来拟合和比较以下候选的有限尺寸标度模型：\n\n- 三维候选模型：$\\eta(L) = \\eta_{\\infty} \\left( 1 + \\frac{A}{L} \\right)$，振幅 $A$ 由数据确定。\n- 二维候选模型：$\\eta(L) = \\eta_{\\infty} \\left( 1 + \\frac{A_{\\log} \\ln(L/L_{0})}{L} \\right)$，振幅 $A_{\\log}$ 由数据确定，且 $L_{0} = 1$（以使对数参数无量纲）。\n- 基线常数模型（用于比较，并在修正可忽略时捕捉大 $L$ 区域的行为）：$\\eta(L) = \\eta_{\\infty}$。\n\n你必须使用提供的 $\\sigma(L)$ 作为标准差来实现加权非线性最小二乘拟合，并且必须使用适用于具有已知方差的高斯误差的赤池信息量准则 (Akaike Information Criterion, AIC) 来选择模型。通过定义 $\\,\\mathrm{AIC} = 2k + \\sum_{i} \\left( \\frac{r_{i}}{\\sigma_{i}} \\right)^{2} \\,$ 来处理 AIC（不考虑一个加性常数），其中 $k$ 是拟合参数的数量，$r_{i}$ 是拟合的残差。对于每个测试用例，仅应用与其维度 $d$ 相关的物理流体动力学模型以及基线常数模型，为每个模型计算 AIC，选择 AIC 最低的模型，并报告相应的 $\\eta_{\\infty}$ 估计值。为清楚起见：对于 $d = 3$，将三维候选模型与基线模型进行比较；对于 $d = 2$，将二维候选模型与基线模型进行比较。\n\n将最终结果 $\\eta_{\\infty}$ 以约化的无量纲单位（无单位）表示，并四舍五入到六位小数。\n\n测试套件：\n为你的程序提供以下四个测试用例。每个测试用例是一个元组，包含维度 $d$、尺寸 $L$、测量值 $\\hat{\\eta}(L)$ 和标准差 $\\sigma(L)$。所有数组都是按索引对齐的有序列表。\n\n- 测试用例 1（三维，通用“理想路径”）：\n  - $d = 3$，\n  - $L = [10, 20, 40, 80, 160]$，\n  - $\\hat{\\eta}(L) = [3.52, 2.99, 2.765, 2.62, 2.5625]$，\n  - $\\sigma(L) = [0.02, 0.02, 0.015, 0.015, 0.01]$。\n- 测试用例 2（二维，对数修正区域）：\n  - $d = 2$，\n  - $L = [10, 20, 40, 80, 160]$，\n  - $\\hat{\\eta}(L) = [2.0189306, 1.75423181, 1.526999151, 1.397191199, 1.324191411]$，\n  - $\\sigma(L) = [0.02, 0.02, 0.015, 0.015, 0.01]$。\n- 测试用例 3（三维，具有精确值的小尺寸边界情况）：\n  - $d = 3$，\n  - $L = [5, 8, 12]$，\n  - $\\hat{\\eta}(L) = [3.0, 2.25, 1.8333333333]$，\n  - $\\sigma(L) = [0.05, 0.03, 0.02]$。\n- 测试用例 4（二维，具有弱修正的大尺寸——模型模糊性挑战）：\n  - $d = 2$，\n  - $L = [20, 40, 80, 160, 320]$，\n  - $\\hat{\\eta}(L) = [1.929807953, 1.886999788, 1.850297800, 1.830547853, 1.816223403]$，\n  - $\\sigma(L) = [0.02, 0.015, 0.015, 0.01, 0.01]$。\n\n算法要求：\n- 为每个候选模型实现加权非线性最小二乘法，并计算参数估计值和残差。\n- 按照上述定义计算赤池信息量准则，并在与指定维度 $d$ 相关的模型和基线常数模型中选择 AIC 最低的模型。\n- 从所选模型中提取 $\\eta_{\\infty}$ 并四舍五入到六位小数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含四个估计的无限大尺寸黏度，以逗号分隔的列表形式包含在方括号中，按测试用例的顺序排列，每个值都四舍五入到六位小数。例如，要求输出格式为 $[\\eta_{\\infty,1},\\eta_{\\infty,2},\\eta_{\\infty,3},\\eta_{\\infty,4}]$，其中每个条目都是一个四舍五入到六位小数的浮点数。",
            "solution": "该问题要求根据一系列在不同有限尺寸 $L$ 的体系上进行的平衡态分子动力学模拟，来估计无限大尺寸的剪切黏度 $\\eta_{\\infty}$。这是计算统计力学中的一个标准程序，其基础是线性响应理论和流体动力学原理。\n\n出发点是剪切黏度 $\\eta$ 的 Green-Kubo 关系，该关系将一个宏观输运系数与一个微观通量的平衡态时间相关函数的时间积分联系起来。在此情况下，通量是应力张量的非对角分量 $P_{xy}$。该关系由以下公式给出：\n$$ \\eta = \\frac{V}{k_{\\mathrm{B}} T} \\int_{0}^{\\infty} C_{P_{xy}}(t) \\, dt $$\n其中 $V$ 是体系体积，$T$ 是温度，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$C_{P_{xy}}(t) = \\langle P_{xy}(t) P_{xy}(0) \\rangle$ 是应力自相关函数。\n\n在线性维度为 $L$ 的周期性体系的计算机模拟中，该积分通过数值方法计算，得到一个依赖于尺寸的估计值 $\\hat{\\eta}(L)$。模拟盒子的有限尺寸会引入系统误差，因为周期性边界条件人为地截断了长波涨落。流体动力学理论预测了对黏度的领头阶修正。该修正的形式取决于体系的空间维度 $d$。\n对于三维体系（$d=3$），已知领头阶修正的标度行为为 $1/L$。这启发了以下用于拟合模拟数据的标度 ansatz：\n$$ \\eta(L) = \\eta_{\\infty} \\left( 1 + \\frac{A}{L} \\right) $$\n其中 $\\eta_{\\infty}$ 是我们希望得到的无限大体系黏度，$A$ 是一个非普适振幅。\n\n对于二维体系（$d=2$），修正更为复杂，涉及一个对数项，由下式给出：\n$$ \\eta(L) = \\eta_{\\infty} \\left( 1 + \\frac{A_{\\log} \\ln(L/L_{0})}{L} \\right) $$\n此处，$A_{\\log}$ 是相应的振幅，$L_{0}$ 是一个参考长度，按规定在约化单位中设为 $L_{0}=1$。\n\n为了确定 $\\eta_{\\infty}$ 的最佳估计值，我们将这些有理论依据的模型拟合到所提供的数据 $(\\{L_i\\}, \\{\\hat{\\eta}(L_i)\\})$。由于测量值 $\\hat{\\eta}(L_i)$ 具有相关的不确定度 $\\sigma_i$，加权非线性最小二乘程序是合适的统计方法。该方法旨在找到一组模型参数 $\\mathbf{p}$（例如，$\\mathbf{p} = [\\eta_{\\infty}, A]$），以最小化卡方统计量 $\\chi^2$：\n$$ \\chi^2(\\mathbf{p}) = \\sum_{i} \\left( \\frac{\\hat{\\eta}(L_i) - \\eta(L_i; \\mathbf{p})}{\\sigma_i} \\right)^2 $$\n每个数据点的权重为 $w_i = 1/\\sigma_i^2$，从而给予更精确的测量更大的重要性。\n\n该问题提出了在一个包含有限尺寸修正的模型和一个更简单的基线常数模型 $\\eta(L) = \\eta_{\\infty}$ 之间做出选择。常数模型对应于在 $L$ 的范围内和统计不确定度内，有限尺寸效应可以忽略不计的情况。在不同复杂度的模型（即不同数量的拟合参数）之间进行选择需要一个正式的模型选择准则以避免过拟合。赤池信息量准则（Akaike Information Criterion, AIC）提供了这样一个框架。根据规定，我们使用以下形式：\n$$ \\mathrm{AIC} = 2k + \\chi^2_{\\text{min}} $$\n其中 $k$ 是模型中自由参数的数量，$\\chi^2_{\\text{min}}$ 是拟合所达到的 $\\chi^2$ 的最小值。$2k$ 项对模型的复杂度进行惩罚。AIC 值较低的模型被认为是数据的更好描述，因为它在拟合优度和简洁性之间提供了更为简约的平衡。基线常数模型有 $k=1$（对于 $\\eta_{\\infty}$），而三维和二维标度模型有 $k=2$（对于 $\\eta_{\\infty}$ 和振幅 $A$ 或 $A_{\\log}$）。\n\n每个测试用例的算法如下：\n1. 识别体系维度 $d$。\n2. 选择候选模型集：基线常数模型和适用于维度 $d$ 的流体动力学模型。\n3. 对每个候选模型：\n    a. 对数据 $(\\{L_i\\}, \\{\\hat{\\eta}(L_i)\\}, \\{\\sigma_i\\})$ 进行加权非线性最小二乘拟合，以找到最优参数和相应的最小卡方值 $\\chi^2_{\\text{min}}$。\n    b. 使用公式 $\\mathrm{AIC} = 2k + \\chi^2_{\\text{min}}$ 计算 AIC。\n4. 比较候选模型的 AIC 值。\n5. 选择产生最小 AIC 的模型。\n6. 无限大尺寸黏度的最终估计值是从所选模型中获得的 $\\eta_{\\infty}$ 值。然后按要求将该值四舍五入到六位小数。\n\n此过程应用于所提供的四个测试用例中的每一个。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Solves for the infinite-size shear viscosity by fitting finite-size data\n    to hydrodynamic models and using AIC for model selection.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"d\": 3,\n            \"L\": np.array([10, 20, 40, 80, 160]),\n            \"eta_hat\": np.array([3.52, 2.99, 2.765, 2.62, 2.5625]),\n            \"sigma\": np.array([0.02, 0.02, 0.015, 0.015, 0.01]),\n        },\n        {\n            \"d\": 2,\n            \"L\": np.array([10, 20, 40, 80, 160]),\n            \"eta_hat\": np.array([2.0189306, 1.75423181, 1.526999151, 1.397191199, 1.324191411]),\n            \"sigma\": np.array([0.02, 0.02, 0.015, 0.015, 0.01]),\n        },\n        {\n            \"d\": 3,\n            \"L\": np.array([5, 8, 12]),\n            \"eta_hat\": np.array([3.0, 2.25, 1.8333333333]),\n            \"sigma\": np.array([0.05, 0.03, 0.02]),\n        },\n        {\n            \"d\": 2,\n            \"L\": np.array([20, 40, 80, 160, 320]),\n            \"eta_hat\": np.array([1.929807953, 1.886999788, 1.850297800, 1.830547853, 1.816223403]),\n            \"sigma\": np.array([0.02, 0.015, 0.015, 0.01, 0.01]),\n        },\n    ]\n\n    # --- Model Functions ---\n    def model_3d(L, eta_inf, A):\n        return eta_inf * (1 + A / L)\n\n    def model_2d(L, eta_inf, A_log):\n        # L0 is 1, so ln(L/L0) = ln(L)\n        return eta_inf * (1 + A_log * np.log(L) / L)\n\n    def model_const(L, eta_inf):\n        return np.full_like(L, eta_inf, dtype=np.float64)\n\n    results = []\n\n    for case in test_cases:\n        d = case[\"d\"]\n        L = case[\"L\"]\n        eta_hat = case[\"eta_hat\"]\n        sigma = case[\"sigma\"]\n\n        # Define candidate models based on dimensionality\n        models_to_test = [\n            {'name': 'Constant', 'func': model_const, 'k': 1}\n        ]\n        if d == 3:\n            models_to_test.append({'name': '3D Hydro', 'func': model_3d, 'k': 2})\n        elif d == 2:\n            models_to_test.append({'name': '2D Hydro', 'func': model_2d, 'k': 2})\n\n        best_model_info = {'aic': np.inf, 'eta_inf': np.nan}\n\n        for model in models_to_test:\n            try:\n                # Perform weighted nonlinear least squares fit\n                popt, _ = curve_fit(\n                    model['func'],\n                    L,\n                    eta_hat,\n                    sigma=sigma,\n                    absolute_sigma=True,\n                    # Provide reasonable initial guesses for stability\n                    p0=[np.mean(eta_hat)] * model['k'] \n                )\n                \n                # Calculate residuals\n                eta_pred = model['func'](L, *popt)\n                residuals = eta_hat - eta_pred\n                \n                # Calculate chi-squared\n                chi_squared = np.sum((residuals / sigma)**2)\n                \n                # Calculate AIC\n                k = model['k']\n                aic = 2 * k + chi_squared\n                \n                # Check if this model is better\n                if aic  best_model_info['aic']:\n                    best_model_info['aic'] = aic\n                    best_model_info['eta_inf'] = popt[0]\n\n            except RuntimeError:\n                # curve_fit can fail if the fit is poor.\n                # In this case, this model will not be selected as its AIC remains infinite.\n                pass\n        \n        results.append(best_model_info['eta_inf'])\n\n    # Format the final output string\n    output_str = f\"[{','.join([f'{r:.6f}' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}