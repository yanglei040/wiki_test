{
    "hands_on_practices": [
        {
            "introduction": "To master the complexities of time-dependent density functional theory (TD-DFT) for dynamics, we begin with its most fundamental concept: the evolution of a quantum system in the absence of external perturbations. This first practice focuses on a minimalist two-level system prepared in a superposition of its ground and first excited states. By calculating the time-evolution of the electric dipole moment, you will directly observe how electronic coherence—the definite phase relationship between quantum states—is the engine that drives all subsequent electron dynamics and gives rise to time-dependent observables .",
            "id": "2461440",
            "problem": "You are given a minimal two-level representation of field-free real-time dynamics as encountered in Time-Dependent Density Functional Theory (TD-DFT). Consider a closed system restricted to the two Kohn-Sham (KS) eigenstates, the ground state $\\lvert 0 \\rangle$ with energy $E_0$ and the first excited state $\\lvert 1 \\rangle$ with energy $E_1$. The system is initialized at time $t=0$ in a normalized superposition\n$$\\lvert \\psi(0) \\rangle = c_0 \\lvert 0 \\rangle + c_1 e^{i \\phi} \\lvert 1 \\rangle,$$\nwith $c_0 \\ge 0$, $c_1 \\ge 0$, $c_0^2 + c_1^2 = 1$, and relative phase $\\phi$. There is no external field at any time. Assume the electric dipole operator along the $x$-axis, $\\hat{\\mu}_x$, has real matrix elements in this basis: $\\mu_{00} = \\langle 0 \\lvert \\hat{\\mu}_x \\rvert 0 \\rangle$, $\\mu_{11} = \\langle 1 \\lvert \\hat{\\mu}_x \\rvert 1 \\rangle$, and $\\mu_{01} = \\mu_{10} = \\langle 0 \\lvert \\hat{\\mu}_x \\rvert 1 \\rangle \\in \\mathbb{R}$. Units: use atomic units throughout, with energies in Hartree ($E_h$), time in atomic units of time ($\\hbar / E_h$), and dipole moments in $e a_0$. Angles are to be expressed in radians.\n\nTask: From first principles, determine the evolution of the state $\\lvert \\psi(t) \\rangle$ in the absence of an external field, and compute the time-dependent expectation value of the $x$-component of the dipole moment,\n$$\\mu_x(t) = \\langle \\psi(t) \\lvert \\hat{\\mu}_x \\rvert \\psi(t) \\rangle,$$\nat the specified sampling times for each parameter set in the following test suite. Report numerical values of $\\mu_x(t)$ in $e a_0$, rounded to six decimal places.\n\nTest suite (all quantities are given in atomic units):\n- Case A (general superposition with nonzero transition dipole): $E_0 = -0.5$, $E_1 = -0.125$, $c_0 = \\sqrt{0.8}$, $c_1 = \\sqrt{0.2}$, $\\phi = 0.3$, $\\mu_{00} = 0.0$, $\\mu_{11} = 1.0$, $\\mu_{01} = 0.5$, sampling times $[0.0,\\,5.0,\\,10.0,\\,15.0]$.\n- Case B (boundary: pure ground state, no coherence): $E_0 = -0.5$, $E_1 = -0.125$, $c_0 = 1.0$, $c_1 = 0.0$, $\\phi = 0.0$, $\\mu_{00} = 0.2$, $\\mu_{11} = 0.8$, $\\mu_{01} = 1.0$, sampling times $[0.0,\\,1.0,\\,2.0]$.\n- Case C (boundary: zero transition dipole, no oscillation): $E_0 = -1.0$, $E_1 = -0.9$, $c_0 = 1/\\sqrt{2}$, $c_1 = 1/\\sqrt{2}$, $\\phi = 0.7$, $\\mu_{00} = -0.3$, $\\mu_{11} = 0.4$, $\\mu_{01} = 0.0$, sampling times $[0.0,\\,20.0]$.\n- Case D (edge: degenerate levels, stationary phase difference): $E_0 = -0.2$, $E_1 = -0.2$, $c_0 = \\sqrt{0.3}$, $c_1 = \\sqrt{0.7}$, $\\phi = 1.0$, $\\mu_{00} = 0.0$, $\\mu_{11} = 0.0$, $\\mu_{01} = 1.2$, sampling times $[0.0,\\,3.0]$.\n\nRequired final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each case must contribute a list of the sampled $\\mu_x(t)$ values in order, so the overall output is a list of $4$ lists in the order A, B, C, D. For example, the printed line must look like\n$[ [a_1, a_2, \\dots], [b_1, b_2, \\dots], [c_1, c_2, \\dots], [d_1, d_2, \\dots] ]$\nbut with no spaces anywhere in the line. Each numeric entry must be rounded to six decimal places as specified.",
            "solution": "The problem statement submitted for analysis is scientifically grounded, well-posed, and objective. It provides a complete set of parameters and conditions necessary for a unique solution based on the fundamental principles of quantum mechanics. It is a standard exercise in the time evolution of a two-level quantum system. Therefore, we proceed with the solution.\n\nThe core of the problem is to determine the time evolution of a quantum state and then compute the expectation value of an observable. The system is unperturbed by any external field, so its dynamics are governed by the time-independent Schrödinger equation (in atomic units, where $\\hbar=1$).\n\nFirst, we define the state of the system. The basis is composed of two Kohn-Sham eigenstates, the ground state $\\lvert 0 \\rangle$ and the first excited state $\\lvert 1 \\rangle$. These are, by definition, eigenstates of the field-free Hamiltonian $\\hat{H}$:\n$$\n\\hat{H} \\lvert 0 \\rangle = E_0 \\lvert 0 \\rangle\n$$\n$$\n\\hat{H} \\lvert 1 \\rangle = E_1 \\lvert 1 \\rangle\n$$\nwhere $E_0$ and $E_1$ are the corresponding eigenenergies. In this basis, the Hamiltonian operator is represented by a diagonal matrix:\n$$\n\\mathbf{H} = \\begin{pmatrix} E_0  0 \\\\ 0  E_1 \\end{pmatrix}\n$$\nThe system is initialized at time $t=0$ in a superposition state:\n$$\n\\lvert \\psi(0) \\rangle = c_0 \\lvert 0 \\rangle + c_1 e^{i \\phi} \\lvert 1 \\rangle\n$$\nThe time evolution of this state is found by applying the time evolution operator, $U(t) = e^{-i\\hat{H}t}$. Since $\\lvert 0 \\rangle$ and $\\lvert 1 \\rangle$ are eigenstates of $\\hat{H}$, the action of $U(t)$ is straightforward:\n$$\n\\lvert \\psi(t) \\rangle = e^{-i\\hat{H}t} \\lvert \\psi(0) \\rangle = e^{-i\\hat{H}t} (c_0 \\lvert 0 \\rangle + c_1 e^{i \\phi} \\lvert 1 \\rangle)\n$$\n$$\n\\lvert \\psi(t) \\rangle = c_0 (e^{-i\\hat{H}t} \\lvert 0 \\rangle) + c_1 e^{i \\phi} (e^{-i\\hat{H}t} \\lvert 1 \\rangle)\n$$\n$$\n\\lvert \\psi(t) \\rangle = c_0 e^{-iE_0t} \\lvert 0 \\rangle + c_1 e^{i \\phi} e^{-iE_1t} \\lvert 1 \\rangle\n$$\nThis gives the state vector at any time $t0$:\n$$\n\\lvert \\psi(t) \\rangle = c_0 e^{-iE_0t} \\lvert 0 \\rangle + c_1 e^{-i(E_1t - \\phi)} \\lvert 1 \\rangle\n$$\nNext, we must compute the time-dependent expectation value of the dipole operator, $\\mu_x(t) = \\langle \\psi(t) \\lvert \\hat{\\mu}_x \\rvert \\psi(t) \\rangle$. The corresponding bra vector is:\n$$\n\\langle \\psi(t) \\rvert = c_0 e^{iE_0t} \\langle 0 \\rvert + c_1 e^{i(E_1t - \\phi)} \\langle 1 \\rvert\n$$\nWe substitute $\\lvert \\psi(t) \\rangle$ and $\\langle \\psi(t) \\rvert$ into the expectation value expression:\n$$\n\\mu_x(t) = \\left( c_0 e^{iE_0t} \\langle 0 \\rvert + c_1 e^{i(E_1t - \\phi)} \\langle 1 \\rvert \\right) \\hat{\\mu}_x \\left( c_0 e^{-iE_0t} \\lvert 0 \\rangle + c_1 e^{-i(E_1t - \\phi)} \\lvert 1 \\rangle \\right)\n$$\nExpanding this expression yields four terms. We use the notation $\\mu_{ij} = \\langle i \\lvert \\hat{\\mu}_x \\rvert j \\rangle$ for the matrix elements of the dipole operator.\n$$\n\\mu_x(t) = c_0^2 e^{iE_0t} e^{-iE_0t} \\langle 0 \\lvert \\hat{\\mu}_x \\rvert 0 \\rangle + c_0 c_1 e^{iE_0t} e^{-i(E_1t - \\phi)} \\langle 0 \\lvert \\hat{\\mu}_x \\rvert 1 \\rangle + c_1 c_0 e^{i(E_1t - \\phi)} e^{-iE_0t} \\langle 1 \\lvert \\hat{\\mu}_x \\rvert 0 \\rangle + c_1^2 e^{i(E_1t - \\phi)} e^{-i(E_1t - \\phi)} \\langle 1 \\lvert \\hat{\\mu}_x \\rvert 1 \\rangle\n$$\nSimplifying the exponential terms and using the dipole matrix element notation:\n$$\n\\mu_x(t) = c_0^2 \\mu_{00} + c_1^2 \\mu_{11} + c_0 c_1 e^{i(E_0 - E_1)t + i\\phi} \\mu_{01} + c_1 c_0 e^{i(E_1 - E_0)t - i\\phi} \\mu_{10}\n$$\nThe dipole operator $\\hat{\\mu}_x$ is an observable and therefore Hermitian, so $\\mu_{10} = \\mu_{01}^*$. The problem states that $\\mu_{01}$ is real, thus $\\mu_{10} = \\mu_{01}$. Let us define the transition frequency $\\omega_{10} = E_1 - E_0$. The expression becomes:\n$$\n\\mu_x(t) = c_0^2 \\mu_{00} + c_1^2 \\mu_{11} + c_0 c_1 \\mu_{01} \\left( e^{-i( \\omega_{10} t - \\phi )} + e^{i( \\omega_{10} t - \\phi )} \\right)\n$$\nUsing Euler's identity, $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$, we arrive at the final analytical expression for the time-dependent dipole moment:\n$$\n\\mu_x(t) = c_0^2 \\mu_{00} + c_1^2 \\mu_{11} + 2 c_0 c_1 \\mu_{01} \\cos(\\omega_{10} t - \\phi)\n$$\nThis equation reveals that the dipole moment consists of a static component, which is the weighted average of the permanent dipole moments of the basis states, and a dynamic component that oscillates at the frequency corresponding to the energy difference between the two states. The amplitude of this oscillation is proportional to the product of the coefficients $c_0, c_1$ and the transition dipole moment $\\mu_{01}$. If any of these three quantities ($c_0, c_1, \\mu_{01}$) are zero, or if the states are degenerate ($\\omega_{10}=0$), the oscillation vanishes or becomes a static offset.\n\nThis derived formula will be applied to each test case to compute the required numerical values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the time-dependent expectation value of the dipole moment\n    for a two-level quantum system based on a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: general superposition with nonzero transition dipole\n        {\n            \"E0\": -0.5, \"E1\": -0.125, \"c0\": np.sqrt(0.8), \"c1\": np.sqrt(0.2), \"phi\": 0.3,\n            \"mu00\": 0.0, \"mu11\": 1.0, \"mu01\": 0.5, \"times\": [0.0, 5.0, 10.0, 15.0]\n        },\n        # Case B: boundary: pure ground state, no coherence\n        {\n            \"E0\": -0.5, \"E1\": -0.125, \"c0\": 1.0, \"c1\": 0.0, \"phi\": 0.0,\n            \"mu00\": 0.2, \"mu11\": 0.8, \"mu01\": 1.0, \"times\": [0.0, 1.0, 2.0]\n        },\n        # Case C: boundary: zero transition dipole, no oscillation\n        {\n            \"E0\": -1.0, \"E1\": -0.9, \"c0\": 1/np.sqrt(2), \"c1\": 1/np.sqrt(2), \"phi\": 0.7,\n            \"mu00\": -0.3, \"mu11\": 0.4, \"mu01\": 0.0, \"times\": [0.0, 20.0]\n        },\n        # Case D: edge: degenerate levels, stationary phase difference\n        {\n            \"E0\": -0.2, \"E1\": -0.2, \"c0\": np.sqrt(0.3), \"c1\": np.sqrt(0.7), \"phi\": 1.0,\n            \"mu00\": 0.0, \"mu11\": 0.0, \"mu01\": 1.2, \"times\": [0.0, 3.0]\n        }\n    ]\n\n    all_results = []\n    \n    # The analytical formula for the time-dependent dipole moment is:\n    # mu_x(t) = c0^2*mu00 + c1^2*mu11 + 2*c0*c1*mu01*cos(omega10*t - phi)\n    # where omega10 = E1 - E0.\n\n    for case in test_cases:\n        E0 = case[\"E0\"]\n        E1 = case[\"E1\"]\n        c0 = case[\"c0\"]\n        c1 = case[\"c1\"]\n        phi = case[\"phi\"]\n        mu00 = case[\"mu00\"]\n        mu11 = case[\"mu11\"]\n        mu01 = case[\"mu01\"]\n        times = case[\"times\"]\n\n        omega10 = E1 - E0\n        \n        # Static part of the dipole moment\n        static_part = c0**2 * mu00 + c1**2 * mu11\n        \n        # Amplitude of the oscillating part\n        osc_amplitude = 2 * c0 * c1 * mu01\n        \n        case_results = []\n        for t in times:\n            # Dynamic part calculation\n            dynamic_part = osc_amplitude * np.cos(omega10 * t - phi)\n            \n            # Total dipole moment at time t\n            mu_t = static_part + dynamic_part\n            \n            # Append rounded result\n            case_results.append(mu_t)\n\n        all_results.append(case_results)\n\n    # Format the final output string as per the requirements:\n    # A list of lists, with no spaces, and numbers rounded to six decimal places.\n    case_strings = []\n    for case_result in all_results:\n        # Format each number to 6 decimal places and join with commas\n        num_strings = [f\"{val:.6f}\" for val in case_result]\n        case_strings.append(f\"[{','.join(num_strings)}]\")\n    \n    # Join the case strings into the final output format\n    final_output_str = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Real-time TD-DFT simulations generate a wealth of time-series data, such as the oscillating dipole moment explored in the previous exercise. To connect this raw data to experimental observables like an absorption spectrum, one must perform a Fourier transform. This practice delves into the critical, and often overlooked, signal processing steps involved, demonstrating how the finite duration of a simulation invariably leads to numerical artifacts like spectral leakage. You will learn to quantify this leakage and explore how tools like window functions and zero-padding are essential for obtaining clean, physically meaningful spectra from your simulations .",
            "id": "3497345",
            "problem": "You are asked to design and implement a program that quantifies spectral leakage in the Fourier transform of the time-dependent dipole moment signal that arises in real-time Time-Dependent Density Functional Theory (TDDFT). In real-time TDDFT, a weak impulsive perturbation (a delta-kick) produces a dipole response whose linear regime can be modeled as an exponentially damped sinusoid. Finite observation time, discretization, and the choice of window function introduce spectral leakage from a narrow excitonic line into neighboring frequencies. Your task is to quantify this leakage and to compare the effect of window functions $w(t)$ versus zero-padding.\n\nStart from the following fundamental bases:\n- The Kohn–Sham equations of Density Functional Theory (DFT) describe electron dynamics, and in the linear response regime of Time-Dependent Density Functional Theory (TDDFT), the induced dipole moment signal can be modeled as an exponentially damped sinusoid when dominated by a single excitonic resonance.\n- The dipole moment $d(t)$ is sampled for a finite time $T$ with a uniform timestep.\n- Multiplying $d(t)$ by a window function $w(t)$ in time corresponds to a convolution in the frequency domain, which can reduce side lobes at the cost of broadening the main lobe.\n- Zero-padding the time-domain signal increases the density of the discrete frequency grid but does not alter the underlying spectral leakage; it improves interpolation of the spectrum.\n\nDefine the synthetic dipole signal as\n$d(t) = A \\exp(-\\gamma t) \\sin(\\omega_0 t)$\nfor $t \\ge 0$ up to the total observation time $T$, where $A$ is the amplitude, $\\gamma$ is the damping rate, and $\\omega_0$ is the angular frequency of a single narrow excitonic resonance. The signal represents the linear response of the dipole to a very weak delta-kick. You will compare different window functions $w(t)$ and different zero-padding factors.\n\nThe spectral leakage fraction $L$ must be defined as follows. Compute the discrete Fourier transform of the windowed and zero-padded dipole and obtain the one-sided positive-angular-frequency spectrum. Define a symmetric main-band width $B$ around $\\omega_0$ as $B = \\alpha \\gamma$ with $\\alpha = 3$. Let $S(\\omega)$ be the nonnegative power spectrum proportional to the squared magnitude of the Fourier transform. The leakage fraction $L$ is the ratio of the total power lying outside the interval $[\\omega_0 - B, \\omega_0 + B]$ to the total power for all positive angular frequencies. This $L$ is a dimensionless decimal in $[0,1]$.\n\nYou must:\n- Construct $d(t)$ with fixed $A = 1$ and the specified $N$ and $\\Delta t$ (see the test suite below), so $T = N \\Delta t$.\n- Apply each specified window $w(t)$, then zero-pad the windowed signal by an integer factor $p$ before computing the discrete Fourier transform.\n- Use the one-sided spectrum over positive angular frequencies (in radians per femtosecond), compute $L$ as defined, and return the leakage fractions for all test cases.\n\nAll angles must be treated in radians, and angular frequencies must be in radians per femtosecond. The time step must be in femtoseconds. The final output must be a single line containing the results as a comma-separated list enclosed in square brackets.\n\nImplement the following test suite. Use $N = 32768$ samples and $\\Delta t = 10^{-3}$ femtoseconds, so $T = 32.768$ femtoseconds. Define the base angular frequency grid spacing $\\Delta \\omega = 2\\pi / T$. For a given integer index $k$ and offset $\\delta \\in [0,1)$, set $\\omega_0 = (k + \\delta)\\Delta \\omega$.\n\nSpecify the five test cases as tuples $(\\text{window}, p, k, \\delta, \\gamma)$:\n\n1. $(\\text{\"hann\"}, 4, 1000, 0.37, 0.01)$\n2. $(\\text{\"rect\"}, 1, 1000, 0.00, 0.01)$\n3. $(\\text{\"blackman\"}, 16, 1000, 0.37, 0.001)$\n4. $(\\text{\"rect\"}, 16, 1000, 0.37, 0.01)$\n5. $(\\text{\"hann\"}, 1, 1000, 0.00, 0.001)$\n\nIn each case:\n- Build $d(t)$ with the specified $\\omega_0$ and $\\gamma$, using $A = 1$, $N$, and $\\Delta t$ defined above.\n- Choose $w(t)$ as the specified window type: rectangular (\"rect\"), Hann (\"hann\"), or Blackman (\"blackman\"), using their standard signal-processing definitions.\n- Zero-pad by factor $p$ before computing the discrete Fourier transform.\n- Compute the leakage fraction $L$ as defined above.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[0.12345,0.23456,0.34567]\"), in the same order as the test cases above. Each element must be a float. No other text should be printed.",
            "solution": "The problem is valid. It is scientifically grounded in the established principles of time-dependent density functional theory (TDDFT) and digital signal processing. The problem is well-posed, with all necessary parameters, equations, and definitions provided to compute a unique, verifiable numerical result for each test case.\n\nThe objective is to quantify spectral leakage in a synthetic real-time TDDFT dipole signal. The signal, representing the response to a delta-kick perturbation near a single electronic excitation, is modeled as an exponentially damped sinusoid. We are tasked with calculating a leakage fraction $L$ under various signal processing conditions: different window functions, zero-padding factors, and for signal frequencies that are either on-grid or off-grid with respect to the Discrete Fourier Transform (DFT) bins.\n\nThe algorithm proceeds as follows:\n\n1.  **Signal Generation**:\n    The discrete time-domain dipole signal $d[n]$ is synthesized at discrete time points $t_n = n \\Delta t$ for $n = 0, 1, \\dots, N-1$. The governing equation is:\n    $$d[n] = A \\exp(-\\gamma t_n) \\sin(\\omega_0 t_n)$$\n    The parameters are specified as: amplitude $A=1$, number of samples $N=32768$, and time step $\\Delta t = 10^{-3} \\, \\text{fs}$. This defines a total observation time of $T = N \\Delta t = 32.768 \\, \\text{fs}$. The angular frequency of the resonance, $\\omega_0$, and the damping rate, $\\gamma$, are given for each test case. The frequency $\\omega_0$ is defined relative to the fundamental frequency resolution of the time series, $\\Delta \\omega = \\frac{2\\pi}{T}$, as:\n    $$\\omega_0 = (k + \\delta) \\Delta \\omega$$\n    where $k$ and $\\delta$ are case-specific integer and fractional parts, respectively.\n\n2.  **Windowing**:\n    To mitigate spectral leakage caused by the abrupt truncation of the signal at time $T$, the signal $d[n]$ is multiplied by a window function $w[n]$ of length $N$. The windowed signal is $d_w[n] = d[n] \\cdot w[n]$. We will implement three standard window functions:\n    -   **Rectangular (`rect`)**: $w[n] = 1$ for $n = 0, \\dots, N-1$. This is equivalent to no windowing.\n    -   **Hann (`hann`)**: $w[n] = 0.5 \\left(1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right)\\right)$ for $n = 0, \\dots, N-1$.\n    -   **Blackman (`blackman`)**: $w[n] = 0.42 - 0.5 \\cos\\left(\\frac{2\\pi n}{N-1}\\right) + 0.08 \\cos\\left(\\frac{4\\pi n}{N-1}\\right)$ for $n = 0, \\dots, N-1$.\n\n3.  **Zero-Padding and Discrete Fourier Transform (DFT)**:\n    The windowed signal $d_w[n]$ is zero-padded by a factor $p$. This means appending zeros until the total signal length is $N_{\\text{pad}} = p \\times N$. The DFT of this padded signal is then computed, typically using a Fast Fourier Transform (FFT) algorithm. Let the resulting complex DFT coefficients be $D[m]$ for $m = 0, \\dots, N_{\\text{pad}}-1$. Zero-padding does not add new information to the signal but increases the sampling density of the frequency spectrum, providing a better-interpolated view of the continuous Fourier transform. The discrete angular frequencies of the transform are given by:\n    $$\\omega'_m = m \\frac{2\\pi}{N_{\\text{pad}} \\Delta t} = m \\frac{2\\pi}{p T} = m \\frac{\\Delta \\omega}{p}$$\n\n4.  **Power Spectrum Calculation**:\n    The power spectrum $S[m]$ is proportional to the squared magnitude of the DFT coefficients, $S[m] = |D[m]|^2$. Since the input signal is real, we can use the `rfft` algorithm, which efficiently computes the transform for non-negative frequencies only. Let this \"one-sided\" power spectrum be denoted $S_{\\text{one-sided}}$.\n\n5.  **Leakage Fraction Calculation**:\n    The spectral leakage fraction $L$ is calculated as the ratio of the power outside a specified main band to the total power, considering only positive frequencies.\n    -   The main band is defined as the interval $[\\omega_0 - B, \\omega_0 + B]$, where the bandwidth parameter $B$ is given by $B = \\alpha \\gamma$ with $\\alpha = 3$.\n    -   The total power for positive frequencies, $P_{\\text{total}}$, is the sum of all spectral components, excluding the DC component at $\\omega=0$:\n    $$P_{\\text{total}} = \\sum_{m \\text{ s.t. } \\omega'_m  0} S[m]$$\n    -   The power within the main band, $P_{\\text{band}}$, is the sum of spectral components whose frequencies fall within the interval $[\\omega_0 - B, \\omega_0 + B]$. We must also ensure the DC component is not counted here if the band happens to include $\\omega=0$:\n    $$P_{\\text{band}} = \\sum_{m \\text{ s.t. } \\omega_0 - B \\le \\omega'_m \\le \\omega_0 + B \\text{ and } \\omega'_m0} S[m]$$\n    -   The leakage fraction $L$ is then:\n    $$L = \\frac{P_{\\text{total}} - P_{\\text{band}}}{P_{\\text{total}}} = 1 - \\frac{P_{\\text{band}}}{P_{\\text{total}}}$$\n    This calculation is performed for each of the five test cases provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spectral leakage problem for the given test cases.\n    \"\"\"\n    # Define fixed parameters from the problem statement.\n    N = 32768\n    dt = 1e-3\n    A = 1.0\n    alpha = 3.0\n\n    # Define the five test cases as tuples: (window, p, k, delta, gamma)\n    test_cases = [\n        (\"hann\", 4, 1000, 0.37, 0.01),\n        (\"rect\", 1, 1000, 0.00, 0.01),\n        (\"blackman\", 16, 1000, 0.37, 0.001),\n        (\"rect\", 16, 1000, 0.37, 0.01),\n        (\"hann\", 1, 1000, 0.00, 0.001),\n    ]\n\n    results = []\n\n    # Process each test case\n    for window_type, p, k, delta, gamma in test_cases:\n        # 1. Calculate derived parameters\n        T = N * dt\n        d_omega = 2 * np.pi / T\n        omega0 = (k + delta) * d_omega\n\n        # 2. Generate the synthetic dipole signal\n        t = np.arange(N) * dt\n        signal = A * np.exp(-gamma * t) * np.sin(omega0 * t)\n\n        # 3. Apply the specified window function\n        if window_type == \"hann\":\n            # numpy.hanning is periodic, problem definitions often use symmetric.\n            # For large N, the difference is negligible. Sticking to the standard library function.\n            window = np.hanning(N)\n        elif window_type == \"blackman\":\n            window = np.blackman(N)\n        elif window_type == \"rect\":\n            window = np.ones(N)\n        else:\n            # This case should not be reached with the given test suite\n            raise ValueError(f\"Unknown window type: {window_type}\")\n            \n        windowed_signal = signal * window\n\n        # 4. Zero-pad and compute the DFT and power spectrum\n        N_pad = p * N\n        \n        # Use rfft for real-valued input signals for efficiency\n        dft_coeffs = np.fft.rfft(windowed_signal, n=N_pad)\n        power_spectrum = np.abs(dft_coeffs)**2\n\n        # 5. Get the corresponding angular frequency grid\n        # rfftfreq returns frequency in cycles/unit_time; convert to angular freq.\n        freq_grid_hz = np.fft.rfftfreq(N_pad, d=dt)\n        omega_grid = 2 * np.pi * freq_grid_hz\n\n        # 6. Compute the leakage fraction L\n        # Define the main band\n        B = alpha * gamma\n        omega_min = omega0 - B\n        omega_max = omega0 + B\n\n        # Total power for positive frequencies (excluding DC component at index 0)\n        P_total = np.sum(power_spectrum[1:])\n\n        # Find power within the main band\n        # Create a boolean mask for frequencies inside the band\n        band_mask = (omega_grid >= omega_min)  (omega_grid = omega_max)\n        \n        # Explicitly exclude the DC component from the band sum,\n        # as per definition of studying leakage for positive frequencies.\n        band_mask[0] = False\n        \n        P_band = np.sum(power_spectrum[band_mask])\n        \n        # Calculate the leakage fraction\n        if P_total > 0:\n            leakage_fraction = (P_total - P_band) / P_total\n        else:\n            leakage_fraction = 0.0\n            \n        results.append(leakage_fraction)\n\n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many crucial phenomena in chemistry and physics, such as ionization or electron detachment, involve electrons escaping the finite potential of a molecule. Simulating these \"open\" quantum systems presents a significant challenge: how to prevent the unphysical reflection of the outgoing electron wavefunction from the artificial boundaries of the simulation box. This advanced practice introduces a powerful solution: the complex absorbing potential (CAP). By implementing and testing different CAPs, you will gain hands-on experience in modeling unbound electron dynamics and quantifying the effectiveness of absorbing boundaries, a vital skill for simulating strong-field and photochemical processes .",
            "id": "3455965",
            "problem": "Consider a one-dimensional real-time Time-Dependent Density Functional Theory (TDDFT) simulation of a single Kohn–Sham orbital under free propagation with absorbing boundaries. Start from the time-dependent Kohn–Sham equation in atomic units (Hartree atomic units, where $\\hbar = 1$, $m = 1$, and $e = 1$): $$ i \\frac{\\partial}{\\partial t} \\psi(x,t) = \\left[-\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} + V(x) + V_{\\text{ext}}(x,t) + V_{\\text{abs}}(x)\\right]\\psi(x,t), $$ where $\\psi(x,t)$ is the Kohn–Sham orbital, $V(x)$ is a static potential (set $V(x) = 0$ for this problem), $V_{\\text{ext}}(x,t)$ is an external driving potential (set $V_{\\text{ext}}(x,t) = 0$ for this problem), and $V_{\\text{abs}}(x)$ is a non-Hermitian absorbing potential implementing absorbing boundary conditions. The complex absorbing potential (CAP) is defined as $$ V_{\\text{abs}}(x) = -i\\,\\eta\\,f(x), $$ with CAP strength $\\eta \\ge 0$ and dimensionless shape function $f(x) \\ge 0$ that is nonzero only inside a boundary layer of width $w$ near both ends of the domain. The domain is $x \\in [-L/2, L/2]$ with fixed Dirichlet boundaries. The electron density is $n(x,t) = |\\psi(x,t)|^2$. From the continuity equation, the current density is given by $$ j(x,t) = \\operatorname{Im}\\!\\left(\\psi^*(x,t)\\frac{\\partial \\psi(x,t)}{\\partial x}\\right). $$\n\nYou will implement a second-order-in-time stable propagation scheme for the above equation using a uniform spatial grid and time step, with Dirichlet boundary conditions at the domain ends $x = -L/2$ and $x = L/2$. The absorbing boundary $V_{\\text{abs}}(x)$ must be implemented as a diagonal operator with a tunable shape $f(x)$ and strength $\\eta$ that activates in the boundary layer $|x|  x_{\\text{cap}}$, where $x_{\\text{cap}} = L/2 - w$.\n\nDefine the initial Kohn–Sham orbital as a Gaussian wave packet with nonzero mean momentum to the right: $$ \\psi(x,0) = \\left( \\frac{1}{\\pi \\sigma^2} \\right)^{1/4} \\exp\\!\\left( -\\frac{(x - x_0)^2}{2\\sigma^2} \\right)\\exp\\!\\left(i k_0 x\\right), $$ with parameters specified below. The wave packet propagates to the right and interacts with the absorbing boundary. Reflection artifacts due to imperfect absorption and numerical boundary conditions can be quantified by comparing outgoing and inward currents at a fixed probe point $x_{\\text{probe}}$ located just inside the absorbing region.\n\nDefine the probe current functional at the probe position as $$ j_{\\text{probe}}(t) = j(x_{\\text{probe}},t), $$ and define the non-negative outgoing and inward time-integrated currents $$ J^{+} = \\int_{0}^{T} \\max\\big(j_{\\text{probe}}(t), 0\\big)\\,dt,\\quad J^{-} = \\int_{0}^{T} \\max\\big(-j_{\\text{probe}}(t), 0\\big)\\,dt. $$ The reflection artifact metric is the dimensionless ratio $$ R = \\begin{cases} \\dfrac{J^{-}}{J^{+}},  \\text{if } J^{+}  0, \\\\ 0,  \\text{if } J^{+} = 0. \\end{cases} $$ A smaller value of $R$ indicates more effective absorption with fewer reflections.\n\nImplement the simulation using the following fixed numerical parameters (all in atomic units; no conversion is required):\n- Spatial domain length: $L = 40.0$.\n- Number of spatial grid points: $N = 1024$.\n- Spatial grid spacing: $dx = L/(N-1)$.\n- Time step: $dt = 0.005$.\n- Number of time steps: $N_t = 2000$ (total duration $T = N_t \\cdot dt$).\n- Initial packet center: $x_0 = -10.0$.\n- Initial packet width: $\\sigma = 2.0$.\n- Initial packet wavenumber: $k_0 = 4.0$.\n- Absorbing layer width: $w = 6.0$, so $x_{\\text{cap}} = L/2 - w$.\n- Probe position: $x_{\\text{probe}} = x_{\\text{cap}} - 2.0$.\n\nUse a second-order accurate implicit Crank–Nicolson time propagation scheme for the spatially discretized Hamiltonian. At each time step, compute the current density $j(x,t)$ using a central finite difference approximation for $\\partial \\psi/\\partial x$, and accumulate $J^{+}$ and $J^{-}$ according to the definitions above.\n\nDefine the shape function $f(x)$ for the CAP in the absorbing region $|x|  x_{\\text{cap}}$ as follows:\n- For $|x| \\le x_{\\text{cap}}$, set $f(x) = 0$.\n- For $|x|  x_{\\text{cap}}$, let $s(x) = \\dfrac{|x| - x_{\\text{cap}}}{w}$ (so $s \\in [0,1]$ in the absorbing layer). The following shape options are to be implemented:\n  1. \"none\": $f(x) = 0$ for all $x$.\n  2. \"linear\": $f(x) = s(x)$.\n  3. \"quadratic\": $f(x) = s(x)^2$.\n  4. \"step\": $f(x) = 1$.\n\nFor each test case, propagate the system and compute the reflection metric $R$. Express the final results as dimensionless floats.\n\nTest Suite:\nRun the simulation for the following five parameter sets $(\\text{shape}, \\eta)$:\n1. $\\text{shape} = \\text{\"none\"}$, $\\eta = 0.0$.\n2. $\\text{shape} = \\text{\"linear\"}$, $\\eta = 0.2$.\n3. $\\text{shape} = \\text{\"quadratic\"}$, $\\eta = 1.0$.\n4. $\\text{shape} = \\text{\"quadratic\"}$, $\\eta = 3.0$.\n5. $\\text{shape} = \\text{\"step\"}$, $\\eta = 1.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\text{[}R_1,R_2,R_3,R_4,R_5\\text{]}$. The values $R_k$ are the reflection metrics computed for the corresponding test cases above, in the exact order given. The outputs are dimensionless and should be printed as floating-point numbers. Angles are not involved. No physical unit conversion is required because all parameters are specified in atomic units.",
            "solution": "The user wants to solve a one-dimensional time-dependent quantum mechanics problem to evaluate the effectiveness of different complex absorbing potentials (CAPs).\n\n### **1. Problem Validation**\n\nThe problem statement has been evaluated against the specified criteria.\n\n**Step 1: Extract Givens**\n\n- **Governing Equation**: $i \\frac{\\partial}{\\partial t} \\psi(x,t) = \\left[-\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} + V(x) + V_{\\text{ext}}(x,t) + V_{\\text{abs}}(x)\\right]\\psi(x,t)$.\n- **Potentials**: $V(x) = 0$, $V_{\\text{ext}}(x,t) = 0$.\n- **Complex Absorbing Potential (CAP)**: $V_{\\text{abs}}(x) = -i\\,\\eta\\,f(x)$, with strength $\\eta \\ge 0$.\n- **Domain**: $x \\in [-L/2, L/2]$ with fixed Dirichlet boundaries ($\\psi(-L/2, t) = \\psi(L/2, t) = 0$).\n- **CAP Shape Function $f(x)$**:\n    - $f(x) = 0$ for $|x| \\le x_{\\text{cap}}$.\n    - For $|x|  x_{\\text{cap}}$, with $s(x) = \\frac{|x| - x_{\\text{cap}}}{w}$, shapes are \"none\" ($f(x)=0$), \"linear\" ($f(x)=s(x)$), \"quadratic\" ($f(x)=s(x)^2$), \"step\" ($f(x)=1$).\n- **Initial Condition**: $\\psi(x,0) = \\left( \\frac{1}{\\pi \\sigma^2} \\right)^{1/4} \\exp\\!\\left( -\\frac{(x - x_0)^2}{2\\sigma^2} \\right)\\exp\\!\\left(i k_0 x\\right)$.\n- **Current Density**: $j(x,t) = \\operatorname{Im}\\!\\left(\\psi^*(x,t)\\frac{\\partial \\psi(x,t)}{\\partial x}\\right)$.\n- **Reflection Metric $R$**: $R = J^{-}/J^{+}$ for $J^{+}0$, else $R=0$, where $J^{+} = \\int_{0}^{T} \\max\\big(j_{\\text{probe}}(t), 0\\big)\\,dt$ and $J^{-} = \\int_{0}^{T} \\max\\big(-j_{\\text{probe}}(t), 0\\big)\\,dt$, with $j_{\\text{probe}}(t) = j(x_{\\text{probe}},t)$.\n- **Numerical Parameters**:\n    - $L = 40.0$\n    - $N = 1024$\n    - $dx = L/(N-1)$\n    - $dt = 0.005$\n    - $N_t = 2000$\n    - $x_0 = -10.0$\n    - $\\sigma = 2.0$\n    - $k_0 = 4.0$\n    - $w = 6.0$\n    - $x_{\\text{cap}} = L/2 - w = 14.0$\n    - $x_{\\text{probe}} = x_{\\text{cap}} - 2.0 = 12.0$\n- **Numerical Method**: Second-order implicit Crank-Nicolson for time propagation; central finite difference for spatial derivatives.\n- **Test Suite**:\n    1. $(\\text{shape} = \\text{\"none\"}$, $\\eta = 0.0)$\n    2. $(\\text{shape} = \\text{\"linear\"}$, $\\eta = 0.2)$\n    3. $(\\text{shape} = \\text{\"quadratic\"}$, $\\eta = 1.0)$\n    4. $(\\text{shape} = \\text{\"quadratic\"}$, $\\eta = 3.0)$\n    5. $(\\text{shape} = \\text{\"step\"}$, $\\eta = 1.0)$\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded**: The problem describes the simulation of a quantum mechanical wave packet using the time-dependent Schrödinger equation (the Kohn-Sham equation for a single non-interacting electron reduces to this). The use of a complex absorbing potential is a standard and physically motivated technique in computational physics to simulate open boundary conditions. The Crank-Nicolson method is a classic, stable algorithm for this class of problems. The problem is scientifically and mathematically sound.\n- **Well-Posed**: All necessary parameters, initial conditions, boundary conditions, and definitions are provided. The problem structure leads to a unique, stable, and meaningful numerical solution for each test case.\n- **Objective**: The problem is stated in precise, objective mathematical and computational terms. There are no subjective or ambiguous statements.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A solution will be developed.\n\n### **2. Solution Derivation and Algorithmic Design**\n\nThe problem requires the numerical solution of the one-dimensional time-dependent Schrödinger equation (TDSE) with a non-Hermitian Hamiltonian to simulate absorption.\n\n**2.1. Governing Equation and Discretization**\nThe governing equation in atomic units ($\\hbar=1$, $m_e=1$) is:\n$$ i \\frac{\\partial \\psi(x,t)}{\\partial t} = \\hat{H}\\psi(x,t) $$\nThe Hamiltonian operator $\\hat{H}$ for this problem is:\n$$ \\hat{H} = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} + V_{\\text{abs}}(x) = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} - i \\eta f(x) $$\nThe domain $x \\in [-L/2, L/2]$ is discretized into a uniform grid of $N$ points $x_j = -L/2 + j \\cdot dx$ for $j=0, 1, \\dots, N-1$, with grid spacing $dx = L/(N-1)$. The wavefunction $\\psi(x,t)$ is represented by a vector $\\Psi(t)$ of its values at the grid points, $\\Psi_j(t) = \\psi(x_j, t)$.\n\nThe second spatial derivative (the kinetic energy operator) is approximated using a second-order central finite difference formula:\n$$ \\left(\\frac{\\partial^2 \\psi}{\\partial x^2}\\right)_{j} \\approx \\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{dx^2} $$\nThe Hamiltonian operator $\\hat{H}$ is thus represented by an $N \\times N$ matrix $\\mathbf{H}$. Due to the Dirichlet boundary conditions, $\\psi_0(t) = \\psi_{N-1}(t) = 0$ for all $t$. This allows us to solve for the $N-2$ interior points, resulting in an effective $(N-2) \\times (N-2)$ tridiagonal Hamiltonian matrix $\\mathbf{H}_{\\text{inner}}$. Its elements are:\n- **Diagonal**: $(\\mathbf{H}_{\\text{inner}})_{j,j} = \\frac{1}{dx^2} - i \\eta f(x_{j+1})$\n- **Off-diagonal**: $(\\mathbf{H}_{\\text{inner}})_{j, j\\pm 1} = -\\frac{1}{2dx^2}$\n\n**2.2. Crank-Nicolson Time Propagation**\nThe TDSE is a system of first-order ordinary differential equations for the state vector $\\Psi(t)$: $i \\frac{d\\Psi}{dt} = \\mathbf{H}\\Psi$. We use the Crank-Nicolson method, which is second-order accurate in time and unconditionally stable. It is derived by averaging the Hamiltonian over the time step $[t_n, t_{n+1}]$:\n$$ i \\frac{\\Psi(t_{n+1}) - \\Psi(t_n)}{dt} = \\frac{1}{2}\\left(\\mathbf{H}\\Psi(t_{n+1}) + \\mathbf{H}\\Psi(t_n)\\right) $$\nRearranging to solve for the state at the next time step, $\\Psi(t_{n+1})$, we get:\n$$ \\left(\\mathbf{I} + \\frac{i dt}{2} \\mathbf{H}\\right) \\Psi(t_{n+1}) = \\left(\\mathbf{I} - \\frac{i dt}{2} \\mathbf{H}\\right) \\Psi(t_n) $$\nwhere $\\mathbf{I}$ is the identity matrix. Let $\\mathbf{A} = \\mathbf{I} + \\frac{i dt}{2} \\mathbf{H}$ and $\\mathbf{B} = \\mathbf{I} - \\frac{i dt}{2} \\mathbf{H}$. The propagation step is $\\Psi(t_{n+1}) = \\mathbf{A}^{-1} (\\mathbf{B} \\Psi(t_n))$. Since $\\mathbf{H}_{\\text{inner}}$ is tridiagonal, both corresponding matrices $\\mathbf{A}_{\\text{inner}}$ and $\\mathbf{B}_{\\text{inner}}$ are also tridiagonal. The inversion of $\\mathbf{A}_{\\text{inner}}$ is performed by solving a tridiagonal system of linear equations, which is computationally efficient.\n\n**2.3. Initial State and Potential Construction**\nThe initial state $\\psi(x,0)$ is a Gaussian wave packet, discretized on the spatial grid $x_j$:\n$$ \\psi(x_j, 0) = \\left( \\frac{1}{\\pi \\sigma^2} \\right)^{1/4} \\exp\\!\\left( -\\frac{(x_j - x_0)^2}{2\\sigma^2} \\right)\\exp\\!\\left(i k_0 x_j\\right) $$\nThe Dirichlet boundary conditions are enforced by setting $\\psi_0(0) = \\psi_{N-1}(0) = 0$.\n\nThe CAP shape function $f(x)$ is constructed on the grid based on the given test case. For a grid point $x_j$ in the absorbing layer ($|x_j|  x_{\\text{cap}}$), the normalized distance $s_j = (|x_j| - x_{\\text{cap}})/w$ is computed and used to define $f(x_j)$ according to the specified shape (\"linear\", \"quadratic\", etc.). The full absorbing potential is then $V_{\\text{abs}}(x_j) = -i \\eta f(x_j)$.\n\n**2.4. Current and Reflection Calculation**\nAt each time step $t_n$, after propagating the wavefunction to get $\\psi(x, t_n)$, the current density $j(x,t)$ is computed. The spatial derivative $\\partial\\psi/\\partial x$ at the probe position $x_{\\text{probe}}$ is approximated by a central finite difference on the grid. Let $k$ be the index such that $x_k \\approx x_{\\text{probe}}$.\n$$ j_{\\text{probe}}(t_n) = \\operatorname{Im}\\!\\left(\\psi_k^*(t_n) \\frac{\\psi_{k+1}(t_n) - \\psi_{k-1}(t_n)}{2dx}\\right) $$\nThe time-integrated outgoing ($J^+$) and inward ($J^-$) currents are accumulated over the total simulation time $T=N_t \\cdot dt$ using a Riemann sum:\n$$ J^{+} = \\sum_{n=0}^{N_t-1} \\max(j_{\\text{probe}}(t_n), 0) \\cdot dt $$\n$$ J^{-} = \\sum_{n=0}^{N_t-1} \\max(-j_{\\text{probe}}(t_n), 0) \\cdot dt $$\nFinally, the reflection artifact metric $R$ is calculated as the ratio $R = J^{-}/J^{+}$.\n\n**2.5. Algorithm Summary**\nFor each test case $(\\text{shape}, \\eta)$:\n1.  **Setup**: Define numerical parameters ($L, N, dx, dt, N_t$, etc.). Create the spatial grid `x`.\n2.  **Initial State**: Construct the initial wavefunction vector $\\Psi(0)$ on the grid and enforce boundary conditions.\n3.  **Hamiltonian**: Construct the CAP vector $V_{\\text{abs}}$ based on $\\eta$ and the `shape`.\n4.  **Crank-Nicolson Matrices**: Form the diagonals of the $(N-2) \\times (N-2)$ tridiagonal matrices $\\mathbf{A}_{\\text{inner}}$ and $\\mathbf{B}_{\\text{inner}}$. For efficiency, the banded representation of $\\mathbf{A}_{\\text{inner}}$ is prepared for the linear solver.\n5.  **Time Evolution**:\n    a. Initialize $J^{+} = 0$, $J^{-} = 0$, and $\\Psi_{\\text{inner}} = \\Psi(0)[1:-1]$.\n    b. Loop for $n$ from $0$ to $N_t-1$:\n        i.  Calculate the right-hand side vector $\\mathbf{v} = \\mathbf{B}_{\\text{inner}} \\Psi_{\\text{inner}}(t_n)$.\n        ii. Solve the linear system $\\mathbf{A}_{\\text{inner}} \\Psi_{\\text{inner}}(t_{n+1}) = \\mathbf{v}$ for $\\Psi_{\\text{inner}}(t_{n+1})$.\n        iii. Reconstruct the full wavefunction $\\Psi(t_{n+1})$ by padding $\\Psi_{\\text{inner}}(t_{n+1})$ with zeros.\n        iv. Calculate $j_{\\text{probe}}(t_{n+1})$ at the probe index.\n        v.  Update the integrated currents $J^{+}$ and $J^{-}$.\n6.  **Result**: Compute the reflection metric $R = J^{-}/J^{+}$.\nThe final output is a list of the computed $R$ values for all test cases.",
            "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Solves the 1D time-dependent Schrödinger equation with complex absorbing potentials\n    and computes the reflection metric for different potential shapes and strengths.\n    \"\"\"\n\n    # Fixed numerical parameters (all in atomic units)\n    L = 40.0\n    N = 1024\n    dt = 0.005\n    Nt = 2000\n    x0 = -10.0\n    sigma = 2.0\n    k0 = 4.0\n    w = 6.0\n    x_cap = L / 2.0 - w\n    x_probe = x_cap - 2.0\n\n    # Spatial grid\n    x = np.linspace(-L / 2.0, L / 2.0, N)\n    dx = x[1] - x[0]\n    \n    # Memoize matrix construction\n    memoized_matrices = {}\n\n    def get_crank_nicolson_matrices(eta, shape):\n        \"\"\"\n        Constructs and returns the Crank-Nicolson propagation matrices A and B.\n        Uses memoization to avoid redundant calculations.\n        \"\"\"\n        if (eta, shape) in memoized_matrices:\n            return memoized_matrices[(eta, shape)]\n\n        # --- Construct Complex Absorbing Potential (CAP) ---\n        f_x = np.zeros(N)\n        abs_x = np.abs(x)\n        in_cap_region = abs_x > x_cap\n        \n        s = (abs_x[in_cap_region] - x_cap) / w\n        \n        if shape == \"linear\":\n            f_x[in_cap_region] = s\n        elif shape == \"quadratic\":\n            f_x[in_cap_region] = s**2\n        elif shape == \"step\":\n            f_x[in_cap_region] = 1.0\n        # \"none\" shape corresponds to f_x = 0, which is the default\n        \n        V_abs = -1j * eta * f_x\n        \n        # --- Construct Hamiltonian for interior points (N-2 x N-2) ---\n        M = N - 2\n        \n        # Kinetic part\n        H_kin_diag = 1.0 / dx**2\n        H_kin_offdiag = -1.0 / (2.0 * dx**2)\n        \n        # Full Hamiltonian diagonals\n        H_diag = H_kin_diag + V_abs[1:-1]\n        \n        # --- Construct Crank-Nicolson matrices A and B for interior points ---\n        c = 0.5j * dt\n        \n        # Matrix A = I + c*H\n        A_diag = 1.0 + c * H_diag\n        A_offdiag_val = c * H_kin_offdiag\n        \n        # Matrix B = I - c*H\n        B_diag = 1.0 - c * H_diag\n        B_offdiag_val = -c * H_kin_offdiag\n\n        # Create banded representation of A for scipy's solver\n        # ab is a (3, M) array for a tridiagonal matrix\n        ab_A = np.zeros((3, M), dtype=np.complex128)\n        ab_A[0, 1:] = A_offdiag_val\n        ab_A[1, :] = A_diag\n        ab_A[2, :-1] = A_offdiag_val\n        \n        # Store B's diagonals for efficient matrix-vector product\n        B_matrix_diags = (B_diag, B_offdiag_val)\n        \n        result = (ab_A, B_matrix_diags)\n        memoized_matrices[(eta, shape)] = result\n        return result\n\n\n    # Test Suite\n    test_cases = [\n        {\"shape\": \"none\", \"eta\": 0.0},\n        {\"shape\": \"linear\", \"eta\": 0.2},\n        {\"shape\": \"quadratic\", \"eta\": 1.0},\n        {\"shape\": \"quadratic\", \"eta\": 3.0},\n        {\"shape\": \"step\", \"eta\": 1.0},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        shape = case[\"shape\"]\n        eta = case[\"eta\"]\n\n        # --- Initial Wave Packet ---\n        norm_factor = (1.0 / (np.pi * sigma**2))**0.25\n        psi_t0 = norm_factor * np.exp(-(x - x0)**2 / (2.0 * sigma**2)) * np.exp(1j * k0 * x)\n        psi_t0 = psi_t0.astype(np.complex128)\n        \n        # Enforce Dirichlet boundary conditions\n        psi_t0[0] = 0.0\n        psi_t0[-1] = 0.0\n        \n        # We only propagate the interior points\n        psi_inner = psi_t0[1:-1]\n        M = N - 2\n\n        # --- Get CN matrices ---\n        ab_A, (B_diag, B_offdiag_val) = get_crank_nicolson_matrices(eta, shape)\n        \n        # --- Find Probe Index ---\n        probe_idx = np.argmin(np.abs(x - x_probe))\n\n        # --- Time Propagation Loop ---\n        J_plus = 0.0\n        J_minus = 0.0\n\n        for _ in range(Nt):\n            # Calculate RHS: rhs = B @ psi_inner\n            rhs = B_diag * psi_inner\n            rhs[:-1] += B_offdiag_val * psi_inner[1:]\n            rhs[1:] += B_offdiag_val * psi_inner[:-1]\n            \n            # Solve for next time step: A @ psi_new = rhs\n            psi_inner = scipy.linalg.solve_banded((1, 1), ab_A, rhs)\n\n            # --- Calculate Current Density at Probe ---\n            # Reconstruct full psi vector to handle boundaries in derivative\n            psi_full = np.zeros(N, dtype=np.complex128)\n            psi_full[1:-1] = psi_inner\n            \n            # Central finite difference for dpsi/dx\n            dpsi_dx = (psi_full[probe_idx + 1] - psi_full[probe_idx - 1]) / (2.0 * dx)\n            \n            # j = Im(psi* * dpsi/dx)\n            j_probe = np.imag(np.conj(psi_full[probe_idx]) * dpsi_dx)\n\n            # Accumulate integrated currents\n            J_plus += max(j_probe, 0.0) * dt\n            J_minus += max(-j_probe, 0.0) * dt\n\n        # --- Calculate Reflection Metric R ---\n        if J_plus > 0:\n            R = J_minus / J_plus\n        else:\n            R = 0.0\n        \n        results.append(R)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}