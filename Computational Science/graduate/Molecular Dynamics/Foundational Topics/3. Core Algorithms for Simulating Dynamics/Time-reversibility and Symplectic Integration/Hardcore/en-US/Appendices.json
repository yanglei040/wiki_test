{
    "hands_on_practices": [
        {
            "introduction": "Before building complex integrators, we must understand the mathematical foundation of a symplectic map. This exercise explores this foundation using the concept of generating functions from classical mechanics. By deriving a canonical transformation from a given generating function, you will directly verify the condition for symplecticity, reinforcing the principle that transformations derived from non-degenerate generating functions are inherently structure-preserving .",
            "id": "3456299",
            "problem": "Consider a single-degree-of-freedom Hamiltonian system used in Molecular Dynamics (MD), where discrete time updates are constructed via canonical transformations that preserve the symplectic two-form. A type-2 generating function $F_2(q,P)$ defines a canonical map from old variables $(q,p)$ to new variables $(Q,P)$ through the fundamental relations of Hamiltonian mechanics,\n$$\np = \\frac{\\partial F_2}{\\partial q}, \\qquad Q = \\frac{\\partial F_2}{\\partial P}.\n$$\nSuppose the discrete update at a time step is defined by the quadratic type-2 generating function\n$$\nF_2(q,P) = \\frac{1}{2} a q^2 + b q P + \\frac{1}{2} c P^2,\n$$\nwith real parameters $(a,b,c)$ and $b \\neq 0$. Starting only from the above definitions, derive the explicit canonical map $(q,p) \\mapsto (Q,P)$ and compute its Jacobian determinant. Use the characterization of symplecticity in one degree of freedom to state the condition on $(a,b,c)$ that ensures the map is symplectic. Express your final answer as the pair of linear formulas for $Q$ and $P$ in terms of $(q,p)$ together with the value of the determinant of the Jacobian matrix of the map. No rounding is required.",
            "solution": "The problem asks for the derivation of a canonical map from a given type-2 generating function, the computation of its Jacobian determinant, and the condition for the map to be symplectic.\n\nThe provided type-2 generating function is\n$$\nF_2(q, P) = \\frac{1}{2} a q^2 + b q P + \\frac{1}{2} c P^2\n$$\nwhere $(q,p)$ are the old canonical coordinates and $(Q,P)$ are the new ones. The parameters $a$, $b$, and $c$ are real constants, with the constraint $b \\neq 0$.\n\nThe canonical transformation is defined by the relations:\n$$\np = \\frac{\\partial F_2}{\\partial q} \\quad \\text{and} \\quad Q = \\frac{\\partial F_2}{\\partial P}.\n$$\n\nFirst, we derive the explicit transformation equations by computing the partial derivatives of $F_2(q,P)$.\nThe derivative with respect to $q$ gives the old momentum $p$:\n$$\np = \\frac{\\partial}{\\partial q} \\left( \\frac{1}{2} a q^2 + b q P + \\frac{1}{2} c P^2 \\right) = a q + b P.\n$$\nThe derivative with respect to the new momentum $P$ gives the new coordinate $Q$:\n$$\nQ = \\frac{\\partial}{\\partial P} \\left( \\frac{1}{2} a q^2 + b q P + \\frac{1}{2} c P^2 \\right) = b q + c P.\n$$\nWe now have a system of two linear equations relating the old and new variables:\n1. $p = a q + b P$\n2. $Q = b q + c P$\n\nTo find the explicit map $(q,p) \\mapsto (Q,P)$, we must express $Q$ and $P$ in terms of $q$ and $p$. From equation (1), we can solve for $P$. The condition $b \\neq 0$ is crucial here, as it allows us to invert the relation:\n$$\nb P = p - a q \\implies P = \\frac{1}{b} p - \\frac{a}{b} q.\n$$\nNow, we substitute this expression for $P$ into equation (2) to find $Q$:\n$$\nQ = b q + c \\left( \\frac{1}{b} p - \\frac{a}{b} q \\right) = b q + \\frac{c}{b} p - \\frac{ac}{b} q.\n$$\nCombining the terms with $q$, we get:\n$$\nQ = \\left( b - \\frac{ac}{b} \\right) q + \\frac{c}{b} p = \\frac{b^2 - ac}{b} q + \\frac{c}{b} p.\n$$\nThus, the explicit canonical map is given by the pair of linear equations:\n$$\nQ = \\frac{b^2 - ac}{b} q + \\frac{c}{b} p\n$$\n$$\nP = -\\frac{a}{b} q + \\frac{1}{b} p\n$$\n\nNext, we compute the Jacobian determinant of this transformation. The transformation can be written in matrix form as $\\vec{Z} = M \\vec{z}$, where $\\vec{z} = \\begin{pmatrix} q \\\\ p \\end{pmatrix}$ and $\\vec{Z} = \\begin{pmatrix} Q \\\\ P \\end{pmatrix}$. The matrix $M$ is the Jacobian matrix of the map, $M = \\frac{\\partial(Q,P)}{\\partial(q,p)}$:\n$$\nM = \\begin{pmatrix} \\frac{\\partial Q}{\\partial q} & \\frac{\\partial Q}{\\partial p} \\\\ \\frac{\\partial P}{\\partial q} & \\frac{\\partial P}{\\partial p} \\end{pmatrix} = \\begin{pmatrix} \\frac{b^2 - ac}{b} & \\frac{c}{b} \\\\ -\\frac{a}{b} & \\frac{1}{b} \\end{pmatrix}.\n$$\nThe determinant of the Jacobian matrix is:\n$$\n\\det(M) = \\left( \\frac{b^2 - ac}{b} \\right) \\left( \\frac{1}{b} \\right) - \\left( \\frac{c}{b} \\right) \\left( -\\frac{a}{b} \\right)\n$$\n$$\n\\det(M) = \\frac{b^2 - ac}{b^2} - \\left( -\\frac{ac}{b^2} \\right) = \\frac{b^2 - ac + ac}{b^2} = \\frac{b^2}{b^2} = 1.\n$$\nThe Jacobian determinant of the map is exactly $1$.\n\nFinally, we address the condition for the map to be symplectic. A transformation is canonical if it preserves the structure of Hamilton's equations. For a one-degree-of-freedom system, a linear map $\\vec{Z} = M \\vec{z}$ is symplectic if and only if its Jacobian matrix $M$ satisfies $M^T J M = J$, where $J = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}$ is the standard symplectic matrix. For a $2 \\times 2$ matrix, this condition is equivalent to requiring that its determinant be equal to $1$.\nAs we have just calculated, the Jacobian determinant of the map derived from the generating function $F_2(q,P)$ is $\\det(M) = 1$. This result holds for any real parameters $a$, $b$, and $c$, provided that the map is well-defined. The map is well-defined if and only if we can uniquely solve for $(Q,P)$ in terms of $(q,p)$, which required $b \\neq 0$.\nTherefore, the transformation is symplectic for any choice of parameters $(a,b,c)$ as long as the initial condition $b \\neq 0$ is met. This is a general property: any transformation derived from a non-degenerate generating function is, by construction, a canonical transformation and thus symplectic. The calculation of the determinant confirms this principle. The sole condition on the parameters $(a,b,c)$ is the one required for the map to be well-defined, which is $b \\neq 0$.\n\nThe problem requests the pair of linear formulas for $Q$ and $P$ and the value of the Jacobian determinant as the final answer.\nThe formulas are:\n$Q(q,p) = \\frac{b^2 - ac}{b} q + \\frac{c}{b} p$\n$P(q,p) = -\\frac{a}{b} q + \\frac{1}{b} p$\nThe determinant is $1$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{b^2-ac}{b}q + \\frac{c}{b}p & -\\frac{a}{b}q + \\frac{1}{b}p & 1 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "A key feature of many widely-used symplectic integrators, like the velocity Verlet method, is time-reversibility. This theoretical property has a powerful practical consequence: the ability to reverse a simulation perfectly. In this hands-on coding practice , you will implement a stringent test for time-reversibility by evolving a system forward, reversing its momenta, and evolving it back to the start, checking for perfect, bitwise recovery of the initial state. This will provide a tangible demonstration of how algorithmic symmetry can lead to the cancellation of floating-point errors.",
            "id": "3456282",
            "problem": "Consider a molecular dynamics system with configuration coordinates $q \\in \\mathbb{R}^{n}$, conjugate momenta $p \\in \\mathbb{R}^{n}$, mass parameters $m \\in \\mathbb{R}^{n}$ with strictly positive components, and a potential energy $V(q)$. The equations of motion follow from Newton's Second Law and Hamiltonian mechanics, with the Hamiltonian $H(q,p) = \\sum_{i=1}^{n} \\frac{p_i^2}{2m_i} + V(q)$, and the evolution determined by $\\dot{q} = \\partial H / \\partial p$ and $\\dot{p} = - \\partial H / \\partial q$. Define the time-reversal operator $\\mathcal{R}$ that acts as $\\mathcal{R}(q,p) = (q,-p)$. An integrator with step map $\\Phi_{\\Delta t}$ is time-reversible if $\\mathcal{R} \\circ \\Phi_{\\Delta t} \\circ \\mathcal{R} = \\Phi_{-\\Delta t}$. A symplectic integrator preserves the symplectic two-form inherited from the Hamiltonian flow.\n\nYour task is to implement a complete, runnable program that performs a stringent test of exact time-reversibility using the following procedure for multiple subsystems and code paths:\n1. Starting from an initial state $(q_0,p_0)$, integrate forward with a numerically symplectic and time-reversible scheme, for a total time $T$ using a fixed time step $\\Delta t$ and a strictly positive integer number of steps $N$ such that $T = N \\Delta t$. Denote the resulting state as $(q_T, p_T)$.\n2. Apply the time-reversal operator to momenta: $(q_T, p_T) \\mapsto (q_T, -p_T)$.\n3. Integrate forward again for the same number of steps $N$ with the same scheme and time step $\\Delta t$, producing $(q_{\\mathrm{back}}, p_{\\mathrm{back}})$.\n4. Apply the time-reversal operator again to momenta: $(q_{\\mathrm{fin}}, p_{\\mathrm{fin}}) = (q_{\\mathrm{back}}, -p_{\\mathrm{back}})$.\n5. Measure bitwise equality between $(q_{\\mathrm{fin}}, p_{\\mathrm{fin}})$ and $(q_0, p_0)$, meaning exact equality of the binary representation of all $64$-bit floating-point components of $q$ and $p$ when viewed as unsigned integers. Report a boolean result for this test.\n\nAdditionally, implement a non-time-reversible baseline integrator based on Forward Euler to contrast the behavior.\n\nUse non-dimensional units (that is, all quantities are unitless scalars consistent with the numerical model).\n\nImplement two structurally different code paths for the symplectic integrator:\n- A \"scalar-loop\" path that performs updates in-place in a sequential order.\n- A \"vectorized\" path that performs updates using vectorized array operations with different arithmetic grouping.\n\nYour program must execute the above procedure for the following test suite. For each test case, output a boolean indicating whether the final $(q_{\\mathrm{fin}}, p_{\\mathrm{fin}})$ is bitwise equal to the initial $(q_0, p_0)$:\n\n- Test Case 1 (happy path, dyadic step): One-dimensional harmonic oscillator with $V(q) = \\frac{1}{2} k q^2$, $k=1$, mass $m=1$, initial $q_0 = 1/2$, $p_0 = 1/4$, time step $\\Delta t = 1/8$, total time $T = 8$, use the symplectic time-reversible scheme with the scalar-loop path.\n\n- Test Case 2 (alternate code path): Same system and parameters as Test Case 1, but use the vectorized path.\n\n- Test Case 3 (non-dyadic step): One-dimensional harmonic oscillator with $k=1$, $m=1$, initial $q_0 = 1/2$, $p_0 = 1/4$, time step $\\Delta t = 0.1$, total time $T = 1.0$, use the symplectic time-reversible scheme with the scalar-loop path.\n\n- Test Case 4 (boundary, zero force): Two-dimensional free particle ($V(q) \\equiv 0$), $m=1$ for each degree of freedom, initial $q_0 = [1/4, -1/8]$, $p_0 = [1/16, 1/32]$, time step $\\Delta t = 1/16$, total time $T = 1$, use the symplectic time-reversible scheme with the vectorized path.\n\n- Test Case 5 (nonlinear interaction): Two particles in two dimensions interacting via the Lennard–Jones potential $V(r) = 4 \\varepsilon \\left[ (\\sigma/r)^{12} - (\\sigma/r)^6 \\right]$ with $\\varepsilon = 1$, $\\sigma = 1$, masses $m=1$ for both particles, initial positions $q_{0,1} = [1.5, 0.0]$, $q_{0,2} = [-1.5, 0.0]$, initial momenta $p_{0,1} = [0.0, 0.05]$, $p_{0,2} = [0.0, -0.05]$, time step $\\Delta t = 0.001$, total time $T = 0.01$, use the symplectic time-reversible scheme with the vectorized path.\n\n- Test Case 6 (non-time-reversible baseline): One-dimensional harmonic oscillator with $k=1$, $m=1$, initial $q_0 = 1/2$, $p_0 = 1/4$, time step $\\Delta t = 1/8$, total time $T = 8$, use the Forward Euler baseline integrator with scalar-loop path.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5,result6]\"), where each entry is either \"True\" or \"False\" corresponding to the bitwise equality test for each case, in the order listed above. Angles are not involved; no unit conversions are needed beyond the stated non-dimensionalization.",
            "solution": "The user-provided problem is valid. It is scientifically grounded in the principles of Hamiltonian mechanics and numerical integration, well-posed with a complete and unambiguous set of specifications, and objective in its formulation. The task is to test for exact, bitwise time-reversibility of numerical integrators, a standard and rigorous procedure in computational physics.\n\nThe core of the problem lies in the distinction between mathematical properties of an algorithm and their finite-precision numerical implementation. An integrator $\\Phi_{\\Delta t}$ is defined as time-reversible if it satisfies the relation $\\mathcal{R} \\circ \\Phi_{\\Delta t} \\circ \\mathcal{R} = \\Phi_{-\\Delta t}$, where $\\mathcal{R}$ is the time-reversal operator that inverts momenta, $\\mathcal{R}(q,p) = (q,-p)$. The test procedure described leverages this property. A forward integration of $N$ steps followed by a momentum reversal, another $N$ steps of forward integration, and a final momentum reversal should, for a perfectly time-reversible scheme, return the system to its exact initial state: $(\\mathcal{R} \\circ \\Phi_T \\circ \\mathcal{R}) \\circ \\Phi_T (q_0, p_0) = \\Phi_T^{-1} \\circ \\Phi_T (q_0, p_0) = (q_0, p_0)$.\n\nThe challenge is to verify if this holds to *bitwise* precision. Floating-point arithmetic introduces rounding errors. However, a key feature of a symmetric, time-reversible algorithm like the velocity Verlet method is that the sequence of arithmetic operations for the backward integration path exactly mirrors, in reverse, the operations from the forward path. This symmetry allows for the cancellation of floating-point errors, theoretically restoring the initial state bit-for-bit, provided no information is lost to underflow or overflow.\n\nThe problem requires implementing two integrators:\n\n1.  **Velocity Verlet Integrator**: This is a standard choice for a symplectic and time-reversible scheme. It can be derived from a Trotter splitting of the Liouville operator corresponding to the Hamiltonian $H(q,p) = T(p) + V(q)$. The step map $\\Phi_{\\Delta t}$ is constructed as a symmetric composition of the exact flows under the kinetic energy $T(p)$ and potential energy $V(q)$: $\\Phi_{\\Delta t} = \\Phi_V(\\Delta t/2) \\circ \\Phi_T(\\Delta t) \\circ \\Phi_V(\\Delta t/2)$. The three operations correspond to:\n    a. A half-step \"kick\" to momenta: $p(t+\\frac{\\Delta t}{2}) = p(t) + F(q(t))\\frac{\\Delta t}{2}$, where force $F = -\\nabla_q V$.\n    b. A full-step \"drift\" of positions: $q(t+\\Delta t) = q(t) + \\frac{p(t+\\frac{\\Delta t}{2})}{m}\\Delta t$.\n    c. A final half-step kick to momenta: $p(t+\\Delta t) = p(t+\\frac{\\Delta t}{2}) + F(q(t+\\Delta t))\\frac{\\Delta t}{2}$.\n    This symmetric structure is the source of its time-reversibility. We will implement this in two distinct ways as requested: a \"scalar-loop\" path with explicit loops over dimensions and a \"vectorized\" path using `numpy` array operations, which may have different arithmetic grouping.\n\n2.  **Forward Euler Integrator**: This serves as a non-time-reversible baseline. The updates are:\n    $q(t+\\Delta t) = q(t) + \\frac{p(t)}{m}\\Delta t$\n    $p(t+\\Delta t) = p(t) + F(q(t))\\Delta t$\n    The asynchronous update (force is based only on the state at time $t$) breaks the symmetry, and thus it is neither time-reversible nor symplectic. We expect it to fail the bitwise reversibility test.\n\nThe procedure is executed for six test cases, covering different potentials (harmonic oscillator, free particle, Lennard-Jones), different numerical parameters (dyadic vs. non-dyadic time steps), and the different integrator code paths. A boolean result is reported for each, indicating whether the final state is bitwise identical to the initial state. The bitwise comparison is performed by reinterpreting the 64-bit floating-point numbers of the state vectors as 64-bit unsigned integers and checking for equality.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef are_bitwise_equal(q1, p1, q2, p2):\n    \"\"\"\n    Performs a bitwise comparison of two states (q, p).\n    Each state is composed of numpy arrays q and p of dtype float64.\n    \"\"\"\n    s1 = np.concatenate((np.ravel(q1), np.ravel(p1)))\n    s2 = np.concatenate((np.ravel(q2), np.ravel(p2)))\n\n    if s1.dtype != np.float64 or s2.dtype != np.float64:\n        raise TypeError(\"Inputs must be float64 numpy arrays for bitwise comparison.\")\n\n    if s1.shape != s2.shape:\n        return False\n\n    # View arrays as 64-bit unsigned integers and check for equality.\n    return np.all(s1.view(np.uint64) == s2.view(np.uint64))\n\n# --- Force Functions ---\n\ndef force_harmonic_oscillator(q, k=1.0):\n    \"\"\"Force for a 1D harmonic oscillator: F = -kq.\"\"\"\n    return -k * q\n\ndef force_free_particle(q):\n    \"\"\"Force for a free particle: F = 0.\"\"\"\n    return np.zeros_like(q)\n\ndef force_lennard_jones(q, epsilon=1.0, sigma=1.0):\n    \"\"\"Force for two particles interacting via Lennard-Jones potential.\"\"\"\n    q1 = q[0:2]\n    q2 = q[2:4]\n    r_vec = q1 - q2\n    r_sq = np.dot(r_vec, r_vec)\n    \n    r_minus2 = 1.0 / r_sq\n    sigma_sq = sigma * sigma\n    \n    sig2_r_minus2 = sigma_sq * r_minus2\n    sig6_r_minus6 = sig2_r_minus2 * sig2_r_minus2 * sig2_r_minus2\n    sig12_r_minus12 = sig6_r_minus6 * sig6_r_minus6\n\n    # F = (24*epsilon/r^2) * [2*(sigma/r)^12 - (sigma/r)^6] * r_vec\n    force_scalar_part = (24.0 * epsilon * r_minus2) * (2.0 * sig12_r_minus12 - sig6_r_minus6)\n    \n    force_on_1 = force_scalar_part * r_vec\n    force_on_2 = -force_on_1\n    \n    return np.concatenate((force_on_1, force_on_2))\n\n# --- Integrator Implementations ---\n\nclass VelocityVerletScalar:\n    def __init__(self, force_func, m):\n        self.force_func = force_func\n        self.m = m\n\n    def step(self, q, p, dt):\n        \"\"\"In-place update using sequential scalar loops.\"\"\"\n        force = self.force_func(q)\n        for i in range(len(q)):\n            p[i] += force[i] * 0.5 * dt\n        \n        for i in range(len(q)):\n            q[i] += (p[i] / self.m[i]) * dt\n        \n        force = self.force_func(q)\n        for i in range(len(q)):\n            p[i] += force[i] * 0.5 * dt\n        \n        return q, p\n\nclass VelocityVerletVectorized:\n    def __init__(self, force_func, m):\n        self.force_func = force_func\n        self.m = m\n\n    def step(self, q, p, dt):\n        \"\"\"In-place update using vectorized numpy operations.\"\"\"\n        p += self.force_func(q) * 0.5 * dt\n        q += (p / self.m) * dt\n        p += self.force_func(q) * 0.5 * dt\n        return q, p\n\nclass ForwardEulerScalar:\n    def __init__(self, force_func, m):\n        self.force_func = force_func\n        self.m = m\n\n    def step(self, q, p, dt):\n        \"\"\"Out-of-place update using scalar loops.\"\"\"\n        force = self.force_func(q)\n        q_next = np.empty_like(q)\n        p_next = np.empty_like(p)\n        for i in range(len(q)):\n            q_next[i] = q[i] + (p[i] / self.m[i]) * dt\n            p_next[i] = p[i] + force[i] * dt\n        return q_next, p_next\n\n# --- Simulation and Test Logic ---\n\ndef test_reversibility(integrator_class, force_func, q0_list, p0_list, m_val, T, dt, force_params):\n    \"\"\"\n    Executes the time-reversibility test for a given configuration.\n    \"\"\"\n    # Bind parameters to the force function\n    bound_force_func = lambda q: force_func(q, **force_params)\n\n    # Prepare initial state as float64 numpy arrays\n    q0 = np.array(q0_list, dtype=np.float64)\n    p0 = np.array(p0_list, dtype=np.float64)\n    m = np.full_like(q0, m_val, dtype=np.float64)\n\n    # Calculate number of steps\n    num_steps = int(round(T / dt))\n\n    integrator = integrator_class(bound_force_func, m)\n\n    # --- Step 1: Forward integration ---\n    q_fwd, p_fwd = q0.copy(), p0.copy()\n    for _ in range(num_steps):\n        q_fwd, p_fwd = integrator.step(q_fwd, p_fwd, dt)\n    \n    # --- Step 2: Apply time-reversal to momenta ---\n    p_fwd = -p_fwd\n\n    # --- Step 3: Integrate forward again (\"backward\" evolution) ---\n    q_back, p_back = q_fwd.copy(), p_fwd.copy()\n    for _ in range(num_steps):\n        q_back, p_back = integrator.step(q_back, p_back, dt)\n    \n    # --- Step 4: Apply time-reversal again ---\n    q_fin, p_fin = q_back.copy(), -p_back\n\n    # --- Step 5: Measure bitwise equality ---\n    return are_bitwise_equal(q0, p0, q_fin, p_fin)\n\ndef solve():\n    test_cases = [\n        # Test Case 1 (happy path, dyadic step)\n        {\"integrator_class\": VelocityVerletScalar, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 8.0, \"dt\": 1/8},\n        # Test Case 2 (alternate code path)\n        {\"integrator_class\": VelocityVerletVectorized, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 8.0, \"dt\": 1/8},\n        # Test Case 3 (non-dyadic step)\n        {\"integrator_class\": VelocityVerletScalar, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 1.0, \"dt\": 0.1},\n        # Test Case 4 (boundary, zero force)\n        {\"integrator_class\": VelocityVerletVectorized, \"force_func\": force_free_particle, \"force_params\": {},\n         \"q0_list\": [1/4, -1/8], \"p0_list\": [1/16, 1/32], \"m_val\": 1.0, \"T\": 1.0, \"dt\": 1/16},\n        # Test Case 5 (nonlinear interaction)\n        {\"integrator_class\": VelocityVerletVectorized, \"force_func\": force_lennard_jones, \"force_params\": {\"epsilon\": 1.0, \"sigma\": 1.0},\n         \"q0_list\": [1.5, 0.0, -1.5, 0.0], \"p0_list\": [0.0, 0.05, 0.0, -0.05], \"m_val\": 1.0, \"T\": 0.01, \"dt\": 0.001},\n        # Test Case 6 (non-time-reversible baseline)\n        {\"integrator_class\": ForwardEulerScalar, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 8.0, \"dt\": 1/8},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = test_reversibility(\n            integrator_class=case[\"integrator_class\"],\n            force_func=case[\"force_func\"],\n            q0_list=case[\"q0_list\"],\n            p0_list=case[\"p0_list\"],\n            m_val=case[\"m_val\"],\n            T=case[\"T\"],\n            dt=case[\"dt\"],\n            force_params=case[\"force_params\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The theoretical advantages of symplectic integration truly manifest in long-term simulations of complex systems. This practice  delves into the famous Fermi-Pasta-Ulam-Tsingou (FPUT) problem, a system renowned for its subtle, non-ergodic behavior. By comparing the performance of a symplectic integrator against a standard non-symplectic method, you will quantify crucial differences in energy conservation and the preservation of long-term dynamical structures, illustrating why geometric integrators are indispensable tools for obtaining physically meaningful results in molecular dynamics.",
            "id": "3456295",
            "problem": "Consider a one-dimensional Fermi-Pasta-Ulam-Tsingou chain of $N$ identical particles with periodic boundary conditions and unit particle mass. Let the positions and momenta be $(q_i,p_i)$ for $i=0,1,\\dots,N-1$ arranged on a ring. The system evolves according to Hamiltonian dynamics with the $\\beta$-Fermi-Pasta-Ulam-Tsingou Hamiltonian\n$$\nH(q,p) \\equiv \\sum_{i=0}^{N-1} \\frac{1}{2} p_i^2 + \\sum_{i=0}^{N-1} \\left( \\frac{1}{2} \\left(q_{i+1} - q_i\\right)^2 + \\frac{\\beta}{4} \\left(q_{i+1} - q_i\\right)^4 \\right),\n$$\nwhere indices are understood modulo $N$ (periodicity), and $\\beta > 0$ controls the nonlinearity strength. The equations of motion are given by Newton's second law in Hamiltonian form,\n$$\n\\dot{q}_i = p_i, \\quad \\dot{p}_i = F_i(q),\n$$\nwhere the force $F_i(q)$ is obtained from $-\\partial H / \\partial q_i$.\n\nYou must implement and compare two numerical integrators for this Hamiltonian system over a long time horizon:\n- A time-reversible symplectic integrator: velocity Verlet,\n- A non-symplectic explicit integrator: classical fourth-order Runge-Kutta.\n\nFor each integrator and each test case, you must compute the following diagnostic metrics over the time interval $[0,T]$ with a fixed time step $dt$ and $n=\\lfloor T/dt \\rfloor$ total steps:\n\n1. Maximum absolute relative energy drift:\n$$\nD_{\\mathrm{energy}} \\equiv \\max_{0 \\le k \\le n} \\left| \\frac{H\\left(q^{(k)},p^{(k)}\\right) - H\\left(q^{(0)},p^{(0)}\\right)}{H\\left(q^{(0)},p^{(0)}\\right)} \\right|,\n$$\nwhere $(q^{(k)},p^{(k)})$ denotes the state after $k$ steps.\n\n2. Time–reversibility error: perform a forward integration from $t=0$ to $t=T$ using time step $dt$ to produce $(q^{(n)},p^{(n)})$, then reverse the momenta to $(q^{(n)},-p^{(n)})$ and integrate backward using the same number of steps with negative time step $-dt$ to obtain $(\\tilde{q}^{(0)},\\tilde{p}^{(0)})$. Define\n$$\nD_{\\mathrm{rev}} \\equiv \\sqrt{ \\frac{1}{N} \\sum_{i=0}^{N-1} \\left( \\left[\\tilde{q}^{(0)}_i - q^{(0)}_i\\right]^2 + \\left[\\tilde{p}^{(0)}_i - p^{(0)}_i\\right]^2 \\right) }.\n$$\n\n3. Metastability leakage based on linear normal modes: define the Discrete Fourier Transform (DFT) of $q$ and $p$ with unitary normalization $Q_k = \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1} q_j e^{-2\\pi i k j / N}$ and $P_k = \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1} p_j e^{-2\\pi i k j / N}$ for $k=0,1,\\dots,N-1$. For the linearized chain, the mode frequencies are\n$$\n\\omega_k = \\sqrt{2\\left(1 - \\cos\\left(\\frac{2\\pi k}{N}\\right)\\right)}, \\quad k=0,1,\\dots,N-1.\n$$\nDefine the linearized modal energy at time step $k_{\\mathrm{step}}$ for wavenumber $m$ as\n$$\n\\mathcal{E}_m(k_{\\mathrm{step}}) \\equiv \\frac{1}{2} \\left|P_m\\right|^2 + \\frac{1}{2} \\omega_m^2 \\left|Q_m\\right|^2,\n$$\nand the set of initially excited low-frequency conjugate modes $\\mathcal{S} \\equiv \\{1, N-1\\}$. The instantaneous leakage at step $k_{\\mathrm{step}}$ is\n$$\nL(k_{\\mathrm{step}}) \\equiv 1 - \\frac{\\sum_{m \\in \\mathcal{S}} \\mathcal{E}_m(k_{\\mathrm{step}})}{\\sum_{m=1}^{N-1} \\mathcal{E}_m(k_{\\mathrm{step}})}.\n$$\nThe metastability leakage metric is the time-average\n$$\nD_{\\mathrm{leak}} \\equiv \\frac{1}{n} \\sum_{k_{\\mathrm{step}}=1}^{n} L(k_{\\mathrm{step}}).\n$$\n\nInitialization: use the low-amplitude single-mode displacement\n$$\nq_i(0) = A \\cos\\left(\\frac{2\\pi i}{N}\\right), \\quad p_i(0) = 0,\n$$\nwith amplitude $A > 0$.\n\nFor each test case, compute the triple of differences between the two integrators' diagnostics,\n$$\n\\left[\\, D_{\\mathrm{energy}}^{\\mathrm{RK4}} - D_{\\mathrm{energy}}^{\\mathrm{VV}}, \\quad D_{\\mathrm{rev}}^{\\mathrm{RK4}} - D_{\\mathrm{rev}}^{\\mathrm{VV}}, \\quad D_{\\mathrm{leak}}^{\\mathrm{RK4}} - D_{\\mathrm{leak}}^{\\mathrm{VV}} \\,\\right],\n$$\nwhere superscripts indicate the integrator method (Runge-Kutta of order four versus velocity Verlet). All quantities are dimensionless; report numerical values as floats.\n\nYour program must produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets, for example, $\\left[ [x_1,y_1,z_1], [x_2,y_2,z_2], [x_3,y_3,z_3] \\right]$, where each inner list corresponds to one test case in the order listed below.\n\nUse the following test suite, which covers a typical scenario, a small time step case, and a stronger nonlinearity with larger time step:\n- Case 1 (typical): $N=8$, $\\beta=0.25$, $A=0.1$, $T=100$, $dt=0.02$.\n- Case 2 (small step): $N=8$, $\\beta=0.25$, $A=0.1$, $T=100$, $dt=0.005$.\n- Case 3 (stronger nonlinearity): $N=8$, $\\beta=1.0$, $A=0.2$, $T=100$, $dt=0.05$.\n\nYour final output must be a single line containing the three computed triples in the exact format $\\left[\\,[\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot]\\,\\right]$.",
            "solution": "The problem is valid. It presents a well-posed, scientifically grounded task in computational physics, providing all necessary parameters and definitions. The objective is to compare two numerical integration schemes, velocity Verlet and fourth-order Runge-Kutta, for simulating a one-dimensional Fermi-Pasta-Ulam-Tsingou (FPUT) chain. This comparison is a classic exercise in numerical analysis for Hamiltonian systems and is free of any scientific or logical flaws.\n\nThe core of the problem lies in understanding the qualitative differences between symplectic and non-symplectic integrators for long-time simulations of Hamiltonian systems. The FPUT system provides an excellent testbed for this. Its dynamics are governed by the Hamiltonian:\n$$\nH(q,p) = K(p) + V(q) = \\sum_{i=0}^{N-1} \\frac{1}{2} p_i^2 + \\sum_{i=0}^{N-1} \\left( \\frac{1}{2} \\left(q_{i+1} - q_i\\right)^2 + \\frac{\\beta}{4} \\left(q_{i+1} - q_i\\right)^4 \\right)\n$$\nwhere $q_i$ and $p_i$ are the position and momentum of the $i$-th particle, $m=1$ is the mass, and $\\beta$ controls the strength of the quartic nonlinearity. The equations of motion are $\\dot{q}_i = \\partial H / \\partial p_i = p_i$ and $\\dot{p}_i = -\\partial H / \\partial q_i = F_i(q)$. The force on particle $i$ is derived from the potential $V(q)$:\n$$\nF_i(q) = -\\frac{\\partial V}{\\partial q_i} = (q_{i+1} - q_i) + \\beta(q_{i+1} - q_i)^3 - (q_i - q_{i-1}) - \\beta(q_i - q_{i-1})^3\n$$\nwhere indices are taken modulo $N$ due to periodic boundary conditions.\n\nTwo integrators are compared:\n\n1.  **velocity Verlet (VV)**: This is a second-order, explicit integrator belonging to the class of geometric, or symplectic, integrators. A single step is performed as:\n    $$\n    \\begin{align*}\n    p\\left(t + \\frac{dt}{2}\\right) &= p(t) + F(q(t)) \\frac{dt}{2} \\\\\n    q(t + dt) &= q(t) + p\\left(t + \\frac{dt}{2}\\right) dt \\\\\n    p(t + dt) &= p\\left(t + \\frac{dt}{2}\\right) + F(q(t+dt)) \\frac{dt}{2}\n    \\end{align*}\n    $$\n    Its key properties are time-reversibility and symplecticity. Symplecticity implies that the integrator exactly preserves a \"shadow\" Hamiltonian, which is close to the true Hamiltonian. This leads to excellent long-term energy stability, where the numerical energy error remains bounded and oscillates, rather than drifting secularly over time.\n\n2.  **Classical Fourth-Order Runge-Kutta (RK4)**: This is a general-purpose, high-order explicit integrator. For a system $\\dot{y} = f(t,y)$, a step is:\n    $$\n    \\begin{align*}\n    k_1 &= f(t_n, y_n) \\\\\n    k_2 &= f\\left(t_n + \\frac{dt}{2}, y_n + \\frac{dt}{2}k_1\\right) \\\\\n    k_3 &= f\\left(t_n + \\frac{dt}{2}, y_n + \\frac{dt}{2}k_2\\right) \\\\\n    k_4 &= f(t_n + dt, y_n + dt k_3) \\\\\n    y_{n+1} &= y_n + \\frac{dt}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n    \\end{align*}\n    $$\n    While highly accurate for a single step (local error $O(dt^5)$), RK4 is not symplectic. When applied to Hamiltonian systems, it does not conserve energy or other geometric properties of the phase space flow. The numerical energy typically exhibits a secular drift, making it unsuitable for long-term simulations where such conservation laws are physically important.\n\nThe solution is evaluated using three diagnostic metrics designed to highlight these differences:\n\n1.  **Energy Drift ($D_{\\mathrm{energy}}$)**: This metric directly measures the violation of energy conservation, a fundamental property of the exact dynamics. We expect VV to show a significantly smaller value than RK4, especially over long integration times.\n\n2.  **Time–Reversibility Error ($D_{\\mathrm{rev}}$)**: The exact Hamiltonian dynamics are time-reversible. The VV integrator is constructed to share this property exactly. In contrast, RK4 is not time-reversible. This metric quantifies the error upon integrating forward to time $T$ and then backward to time $0$. The error for VV should be close to machine precision (due to floating-point round-off), while for RK4 it will be substantial.\n\n3.  **Metastability Leakage ($D_{\\mathrm{leak}}$)**: The FPUT problem is famous for its \"metastability,\" where energy, initially placed in low-frequency modes, leaks to other modes much more slowly than expected from statistical mechanics. Preserving this subtle, long-term dynamical behavior is a hallmark of a good geometric integrator. This metric, based on the energy in linearized normal modes, quantifies this leakage. We anticipate that the non-symplectic RK4 will introduce numerical artifacts that accelerate this leakage, resulting in a higher $D_{\\mathrm{leak}}$ compared to the structure-preserving VV integrator.\n\nThe implementation will proceed by defining functions for the force, the Hamiltonian, and each integration step. A main simulation loop will evolve the system from the specified initial conditions for each test case and integrator, collecting data to compute the three diagnostics. The final result is the set of differences in these diagnostic values between the two methods. Vectorized operations using NumPy, particularly `numpy.roll` for handling periodic boundary conditions, are employed for efficient computation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_force(q, beta):\n    \"\"\"Calculates the force on each particle in the FPUT chain.\"\"\"\n    dq_plus = np.roll(q, -1) - q\n    dq_minus = q - np.roll(q, 1)\n    # The term (dq + beta * dq^3) represents the force from a spring.\n    # The net force is the difference between the pull from the right and the pull from the left.\n    force = (dq_plus + beta * dq_plus**3) - (dq_minus + beta * dq_minus**3)\n    return force\n\ndef calculate_hamiltonian(q, p, beta):\n    \"\"\"Calculates the total energy (Hamiltonian) of the FPUT chain.\"\"\"\n    kinetic_energy = 0.5 * np.sum(p**2)\n    dq = np.roll(q, -1) - q\n    potential_energy = np.sum(0.5 * dq**2 + (beta / 4.0) * dq**4)\n    return kinetic_energy + potential_energy\n\ndef velocity_verlet_step(q, p, dt, beta):\n    \"\"\"Performs a single step of the velocity-Verlet integrator.\"\"\"\n    force_t = calculate_force(q, beta)\n    p_half = p + 0.5 * dt * force_t\n    q_new = q + dt * p_half\n    force_t_plus_dt = calculate_force(q_new, beta)\n    p_new = p_half + 0.5 * dt * force_t_plus_dt\n    return q_new, p_new\n\ndef rk4_step(q, p, dt, beta):\n    \"\"\"Performs a single step of the classical fourth-order Runge-Kutta integrator.\"\"\"\n    # State vector y = (q, p), ODE is y_dot = f(y) = (p, F(q))\n    # k1\n    k1_q = p\n    k1_p = calculate_force(q, beta)\n    # k2\n    q2 = q + 0.5 * dt * k1_q\n    p2 = p + 0.5 * dt * k1_p\n    k2_q = p2\n    k2_p = calculate_force(q2, beta)\n    # k3\n    q3 = q + 0.5 * dt * k2_q\n    p3 = p + 0.5 * dt * k2_p\n    k3_q = p3\n    k3_p = calculate_force(q3, beta)\n    # k4\n    q4 = q + dt * k3_q\n    p4 = p + dt * k3_p\n    k4_q = p4\n    k4_p = calculate_force(q4, beta)\n    \n    q_new = q + (dt / 6.0) * (k1_q + 2.0 * k2_q + 2.0 * k3_q + k4_q)\n    p_new = p + (dt / 6.0) * (k1_p + 2.0 * k2_p + 2.0 * k3_p + k4_p)\n    return q_new, p_new\n\ndef compute_diagnostics(integrator_name, q0, p0, N, beta, T, dt):\n    \"\"\"Computes the three diagnostic metrics for a given integrator.\"\"\"\n    if integrator_name == 'vv':\n        step_func = velocity_verlet_step\n    elif integrator_name == 'rk4':\n        step_func = rk4_step\n    else:\n        raise ValueError(\"Unknown integrator\")\n\n    n_steps = int(np.floor(T / dt))\n\n    # --- Forward integration for D_energy and D_leak ---\n    q_curr, p_curr = q0.copy(), p0.copy()\n    \n    # Store final state for reversibility test\n    q_final, p_final = None, None\n    \n    # D_energy calculation\n    H0 = calculate_hamiltonian(q0, p0, beta)\n    if H0 == 0: H0 = 1.0 # Avoid division by zero, though unlikely\n    max_energy_drift = 0.0\n\n    # D_leak calculation\n    k_modes = np.arange(N)\n    omega_sq = 2.0 * (1.0 - np.cos(2.0 * np.pi * k_modes / N))\n    total_leakage = 0.0\n\n    for k in range(n_steps):\n        q_curr, p_curr = step_func(q_curr, p_curr, dt, beta)\n        \n        # Energy drift\n        Hk = calculate_hamiltonian(q_curr, p_curr, beta)\n        drift = np.abs((Hk - H0) / H0)\n        if drift > max_energy_drift:\n            max_energy_drift = drift\n\n        # Leakage\n        Q_k = np.fft.fft(q_curr, norm='ortho')\n        P_k = np.fft.fft(p_curr, norm='ortho')\n        modal_energies = 0.5 * (np.abs(P_k)**2 + omega_sq * np.abs(Q_k)**2)\n        total_linear_energy = np.sum(modal_energies[1:])\n        energy_in_S = modal_energies[1] + modal_energies[N-1]\n        \n        if total_linear_energy > 1e-15:\n            instantaneous_leakage = 1.0 - (energy_in_S / total_linear_energy)\n        else:\n            instantaneous_leakage = 0.0\n        total_leakage += instantaneous_leakage\n    \n    q_final, p_final = q_curr, p_curr\n    D_energy = max_energy_drift\n    D_leak = total_leakage / n_steps if n_steps > 0 else 0.0\n\n    # --- Backward integration for D_rev ---\n    q_rev, p_rev = q_final.copy(), -p_final.copy() # Reverse momenta\n    \n    for _ in range(n_steps):\n        q_rev, p_rev = step_func(q_rev, p_rev, -dt, beta)\n\n    # Reversibility error\n    q_diff_sq = np.sum((q_rev - q0)**2)\n    p_diff_sq = np.sum((p_rev - p0)**2)\n    D_rev = np.sqrt((q_diff_sq + p_diff_sq) / N)\n\n    return D_energy, D_rev, D_leak\n\ndef solve():\n    test_cases = [\n        # Case 1 (typical)\n        {'N': 8, 'beta': 0.25, 'A': 0.1, 'T': 100, 'dt': 0.02},\n        # Case 2 (small step)\n        {'N': 8, 'beta': 0.25, 'A': 0.1, 'T': 100, 'dt': 0.005},\n        # Case 3 (stronger nonlinearity)\n        {'N': 8, 'beta': 1.0, 'A': 0.2, 'T': 100, 'dt': 0.05}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, beta, A, T, dt = case['N'], case['beta'], case['A'], case['T'], case['dt']\n        \n        # Initial conditions\n        i = np.arange(N)\n        q0 = A * np.cos(2.0 * np.pi * i / N)\n        p0 = np.zeros(N)\n\n        # Compute diagnostics for both integrators\n        d_energy_vv, d_rev_vv, d_leak_vv = compute_diagnostics(\n            'vv', q0, p0, N, beta, T, dt)\n        \n        d_energy_rk4, d_rev_rk4, d_leak_rk4 = compute_diagnostics(\n            'rk4', q0, p0, N, beta, T, dt)\n\n        # Calculate differences RK4 - VV\n        diffs = [\n            d_energy_rk4 - d_energy_vv,\n            d_rev_rk4 - d_rev_vv,\n            d_leak_rk4 - d_leak_vv\n        ]\n        all_results.append(diffs)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list of lists matches the required format.\n    print(str(all_results))\n\nsolve()\n```"
        }
    ]
}