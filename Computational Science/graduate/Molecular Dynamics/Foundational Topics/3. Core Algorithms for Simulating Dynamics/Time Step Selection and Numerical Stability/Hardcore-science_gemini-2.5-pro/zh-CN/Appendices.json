{
    "hands_on_practices": [
        {
            "introduction": "本练习将从时间步选择最基本的原则开始。我们将把分子中最快的振动模式简化为一个简谐振子。通过一个动手编程练习，您将凭经验确定速度Verlet算法的最大稳定时间步，并亲眼见证它与振子频率之间的关系。这个练习将巩固制约许多显式积分器稳定性的基础性$\\omega\\Delta t \\le 2$法则。",
            "id": "3455229",
            "problem": "考虑一个离散时间的分子动力学 (MD) 积分器，用于单一主导曲率模式，该模式近似于一个简单点电荷扩展 (SPC/E) 水模型中最快的内部运动。最大力曲率模式可以被建模为一个一维谐振子，其位置 $x(t)$ 遵循牛顿第二定律 $m\\,\\ddot{x}(t) = -k\\,x(t)$，其中 $m$ 是质量，$k$ 是平衡位置势能的曲率。定义角频率为 $\\omega = \\sqrt{k/m}$，可以用时间步长 $\\Delta t$ 的速度Verlet方案来离散化运动方程。该方案的经验稳定性边界可以通过逐渐增加 $\\Delta t$ 并观察数值振荡是保持有界还是发散来探索。\n\n你的任务是编写一个程序，该程序：\n- 将主导曲率模式视为单个谐振子 $\\ddot{x}(t) + \\omega^2 x(t) = 0$，其中 $\\ddot{x}(t)$ 表示 $x(t)$ 的二阶时间导数。\n- 使用速度Verlet算法，从小的初始条件开始，在固定的步数 $N$ 内对运动方程进行数值时间步进，并在数值振幅增长超过预设界限时检测不稳定性。\n- 通过从小到大扫描 $\\Delta t$ 值，并通过二分法细化边界，以经验方式定位数值解保持有界的最大稳定时间步长 $\\Delta t_{\\text{crit}}$。\n- 通过报告无量纲比率 $\\rho = \\Delta t_{\\text{crit}}\\,\\omega / 2$，将观测到的阈值 $\\Delta t_{\\text{crit}}$ 与特征角频率 $\\omega$ 联系起来。\n\n科学真实性与单位：\n- 在刚性SPC/E水模型中，约束移除了O–H伸缩自由度，因此最高频率通常与弯曲或摆动模式相关。在没有约束的情况下，最高频率由O–H伸缩振动主导。为确保科学合理性，请使用以波数（反厘米）为单位指定的特征模式频率，并使用 $\\omega = 2\\pi c\\,\\tilde{\\nu}$ 将每个频率转换为以弧度/秒为单位的角频率，其中 $c = 2.99792458\\times 10^{10}$ 厘米/秒，$\\tilde{\\nu}$ 是以 $\\text{cm}^{-1}$ 为单位的波数。\n- 以飞秒 (fs) 为单位表示最终的经验临界时间步长。一飞秒等于 $10^{-15}$ 秒。\n\n算法要求：\n- 为谐振子 $\\ddot{x}(t) + \\omega^2 x(t) = 0$ 实现速度Verlet更新，其中单位质量 $m = 1$，刚度 $k = \\omega^2$，因此每一步的加速度为 $a(t) = -\\omega^2 x(t)$。\n- 以 $x(0) = \\varepsilon$ 和 $v(0) = 0$ 进行初始化，其中 $\\varepsilon$ 是一个很小的振幅（选择一个合理的值以避免溢出并保持数值精度）。\n- 将不稳定性检测定义为：在运行过程中的任何一步，位置的绝对值 $|x|$ 超过初始振幅的固定倍数。选择一个足够大以避免假阳性，但又足够有限以检测到真实增长的界限。\n- 使用扫描方法，增加 $\\Delta t$ 直到检测到不稳定性，然后通过二分法细化边界，以产生对 $\\Delta t_{\\text{crit}}$ 的稳健估计。\n\n测试套件：\n使用以下一组以 $\\text{cm}^{-1}$ 为单位的波数 $\\tilde{\\nu}$ 来定义五个测试用例，这些用例涵盖无约束和有约束的场景，以及典型、高频和低频极限：\n1. $\\tilde{\\nu} = 3600$（无约束的O–H伸缩振动，典型的柔性模型）。\n2. $\\tilde{\\nu} = 4000$（无约束的O–H伸缩振动，更刚性的变体）。\n3. $\\tilde{\\nu} = 1600$（受约束的最高频率模式，由弯曲振动近似）。\n4. $\\tilde{\\nu} = 600$（受约束的最高频率模式，由摆动近似）。\n5. $\\tilde{\\nu} = 1800$（受约束的中间情况）。\n\n所需输出：\n- 对每个测试用例，计算以飞秒为单位的 $\\Delta t_{\\text{crit}}$ 和无量纲比率 $\\rho = \\Delta t_{\\text{crit}}\\,\\omega / 2$。\n- 将 $\\Delta t_{\\text{crit}}$ 四舍五入到三位小数（单位为fs），并将 $\\rho$ 四舍五入到六位小数。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应按顺序包含每个测试用例的 $\\Delta t_{\\text{crit}}$ (fs) 和 $\\rho$ 对，平铺成一个列表。例如，对于两个用例，格式将是 $[\\Delta t_{\\text{crit,1}}, \\rho_1, \\Delta t_{\\text{crit,2}}, \\rho_2]$。\n\n约束条件：\n- 程序必须是完全自包含的，不需要任何输入，并且仅依赖于指定的运行时环境。\n- 程序必须实现上述的经验扫描和二分法逻辑来确定每个用例的 $\\Delta t_{\\text{crit}}$，在决策逻辑中不得使用任何闭式稳定性条件。\n\n答案单位：\n- 以飞秒为单位表示 $\\Delta t_{\\text{crit}}$，四舍五入到三位小数。\n- 以小数形式表示 $\\rho$，四舍五入到六位。\n\n最终输出格式：\n- 如上所述，单行输出，包含一个用方括号括起来的逗号分隔列表，按顺序汇总所有测试用例：$[\\Delta t_{\\text{crit,1}},\\rho_1,\\Delta t_{\\text{crit,2}},\\rho_2,\\ldots,\\Delta t_{\\text{crit,5}},\\rho_5]$。",
            "solution": "该问题要求经验性地确定应用于一维谐振子的速度Verlet积分方案的临界时间步长 $\\Delta t_{\\text{crit}}$。这可以作为分子中最高频率内部运动的模型，是在分子动力学（MD）模拟中选择稳定时间步长的关键因素。需要对一组特征振动频率进行稳定性评估，并将结果表示为一个无量纲比率，该比率将临界时间步长与振子的自然周期联系起来。\n\n我们考虑的基本系统是一个谐振子，其运动方程由恢复力 $F = -k x$ 的牛顿第二定律给出：\n$$\nm \\ddot{x}(t) = -k x(t)\n$$\n其中 $m$ 是质量，$x(t)$ 是位置，$k$ 是力常数。通过定义角频率 $\\omega = \\sqrt{k/m}$，该方程可重写为其标准形式：\n$$\n\\ddot{x}(t) + \\omega^2 x(t) = 0\n$$\n问题指定使用单位质量 $m=1$，因此在任意时间 $t$ 的加速度就是 $a(t) = -\\omega^2 x(t)$。\n\n对于数值积分，我们采用速度Verlet算法，这是一种在MD中广泛使用的辛可逆积分器。给定在时间步长 $n$ 的位置 $x_n$、速度 $v_n$ 和加速度 $a_n = -\\omega^2 x_n$，使用时间步长 $\\Delta t$ 计算第 $n+1$ 步的状态如下：\n\n1.  计算半步长的速度：\n    $$\n    v_{n+1/2} = v_n + a_n \\frac{\\Delta t}{2}\n    $$\n2.  将位置更新到完整步长：\n    $$\n    x_{n+1} = x_n + v_{n+1/2} \\Delta t\n    $$\n3.  基于新位置计算新加速度：\n    $$\n    a_{n+1} = -\\omega^2 x_{n+1}\n    $$\n4.  使用新加速度将速度更新到完整步长：\n    $$\n    v_{n+1} = v_{n+1/2} + a_{n+1} \\frac{\\Delta t}{2}\n    $$\n\n主要任务是找到该算法的稳定性边界。如果初始条件的微小扰动导致有界的、不发散的解，则该数值积分方案被认为是稳定的。对于谐振子，稳定的数值轨迹的总能量（及其振幅）将保持近似恒定，围绕真实的守恒能量表现出微小、有界的振荡。不稳定的轨迹将显示出能量和振幅的系统性、无界增长。临界时间步长 $\\Delta t_{\\text{crit}}$ 是数值解保持有界的最大 $\\Delta t$ 值。\n\n为了经验性地确定 $\\Delta t_{\\text{crit}}$，我们将为每个给定的角频率 $\\omega$ 实现一个数值搜索程序。该程序包括两个主要部分：一个模拟函数和一个搜索算法。\n\n模拟函数，我们称之为 `is_stable(Δt, ω)`，将执行以下步骤：\n1.  在 $t=0$ 时用 $x_0 = \\varepsilon$ 和 $v_0 = 0$ 初始化系统。由于谐振子方程是线性的，我们可以使用一个简单的值，如 $\\varepsilon=1$。\n2.  对速度Verlet算法进行大量固定步数 $N$ 的迭代。$N=20000$ 的值足以让任何潜在的不稳定性表现出来。\n3.  在每一步 $n$，检查是否发散。如果位置的量级 $|x_n|$ 超过了初始振幅的预定义倍数，即 $|x_n|  M \\cdot \\varepsilon$，则宣告不稳定。$M=100$ 的乘数可作为检测指数增长的稳健阈值。\n4.  如果模拟完成了所有 $N$ 步而振幅未超过阈值，则认为时间步长 $\\Delta t$ 对于给定的 $\\omega$ 是稳定的。函数返回 `True`。否则，返回 `False`。\n\n搜索 $\\Delta t_{\\text{crit}}$ 的过程如下：\n1.  **区间确定：** 首先我们找到一个包含 $\\Delta t_{\\text{crit}}$ 的区间 $[\\Delta t_{\\text{lower}}, \\Delta t_{\\text{upper}}]$。这可以通过从一个非常小的、已知的稳定 $\\Delta t$（例如 $10^{-18}\\,\\text{s}$）开始，并反复将其加倍，直到 `is_stable` 返回 `False`。最后一个稳定的值成为 $\\Delta t_{\\text{lower}}$，第一个不稳定的值成为 $\\Delta t_{\\text{upper}}$。\n2.  **二分法：** 在确定了稳定性边界的区间后，我们使用二分法来精确我们的 $\\Delta t_{\\text{crit}}$ 估计值。我们反复测试中点 $\\Delta t_{\\text{mid}} = (\\Delta t_{\\text{lower}} + \\Delta t_{\\text{upper}})/2$。如果 $\\Delta t_{\\text{mid}}$ 是稳定的，我们设置 $\\Delta t_{\\text{lower}} = \\Delta t_{\\text{mid}}$；否则，我们设置 $\\Delta t_{\\text{upper}} = \\Delta t_{\\text{mid}}$。这个过程重复固定次数的迭代（例如 100 次）以达到高精度。$\\Delta t_{\\text{lower}}$ 的最终值就是我们的经验 $\\Delta t_{\\text{crit}}$。\n\n问题指定了由波数 $\\tilde{\\nu}$ ($\\text{cm}^{-1}$) 定义的五个测试用例：$\\{3600, 4000, 1600, 600, 1800\\}$。每个用例的角频率 $\\omega$ 使用关系式 $\\omega = 2\\pi c \\tilde{\\nu}$ 计算，其中光速 $c = 2.99792458 \\times 10^{10} \\text{ cm/s}$。得到的以秒为单位的 $\\Delta t_{\\text{crit}}$ 会被转换为飞秒（$1\\,\\text{fs} = 10^{-15}\\,\\text{s}$）。\n\n最后，我们计算无量纲比率 $\\rho = \\Delta t_{\\text{crit}}\\,\\omega / 2$。从解析上讲，应用于谐振子的速度Verlet算法的稳定性条件已知为 $\\Delta t \\cdot \\omega \\le 2$。这意味着理论临界时间步长为 $\\Delta t_{\\text{crit}} = 2/\\omega$。因此，该比率的理论值为 $\\rho = (2/\\omega) \\cdot \\omega / 2 = 1$。我们的经验程序应该对所有测试用例都得出非常接近 1 的 $\\rho$ 值，这为我们的实现提供了一个有力的验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It determines the critical time step for a velocity Verlet integrator\n    applied to a harmonic oscillator model of molecular vibrations.\n    \"\"\"\n\n    # --- Constants and Simulation Parameters ---\n\n    # Speed of light in cm/s as specified\n    C_CMS = 2.99792458e10\n\n    # Simulation parameters for stability check\n    NUM_STEPS = 20000  # Number of steps to run the simulation\n    # Initial condition for position. Velocity is 0. Since the system is linear,\n    # the exact value is not critical, so 1.0 is convenient.\n    X_INITIAL = 1.0\n    # Instability threshold: if |x| exceeds this multiple of the initial\n    # amplitude, the simulation is considered unstable.\n    INSTABILITY_MULTIPLIER = 100.0\n    # Number of bisection iterations for refining the critical time step\n    BISECTION_ITERATIONS = 100\n\n    # Test suite: wavenumbers in cm^-1\n    wavenumbers_cm_inv = [3600.0, 4000.0, 1600.0, 600.0, 1800.0]\n\n    # --- Helper Functions ---\n\n    def get_omega(wavenumber_cm_inv):\n        \"\"\"Converts wavenumber (cm^-1) to angular frequency (rad/s).\"\"\"\n        return 2.0 * np.pi * C_CMS * wavenumber_cm_inv\n\n    def is_stable(delta_t, omega):\n        \"\"\"\n        Runs a velocity Verlet simulation for a given dt and omega to check for stability.\n        Returns True if stable, False if unstable.\n        \"\"\"\n        x = X_INITIAL\n        v = 0.0\n        a = -omega**2 * x\n        \n        instability_threshold = X_INITIAL * INSTABILITY_MULTIPLIER\n\n        for _ in range(NUM_STEPS):\n            # Velocity Verlet algorithm\n            v_half_step = v + 0.5 * a * delta_t\n            x = x + v_half_step * delta_t\n            a = -omega**2 * x\n            v = v_half_step + 0.5 * a * delta_t\n\n            if abs(x) > instability_threshold:\n                return False\n        \n        return True\n\n    def find_critical_dt(omega):\n        \"\"\"\n        Finds the critical time step dt_crit for a given omega using a search algorithm.\n        \"\"\"\n        # 1. Bracketing the root\n        # Start with a very small dt and double it until it becomes unstable.\n        dt_lower = 1e-18  # A small, known-stable step in seconds\n        \n        # Check if the initial guess is stable. If not, this is an issue.\n        if not is_stable(dt_lower, omega):\n            # This case should not be reached with a sufficiently small initial dt.\n            raise RuntimeError(\"Initial time step is unstable.\")\n\n        dt_upper = dt_lower\n        while is_stable(dt_upper, omega):\n            dt_lower = dt_upper\n            dt_upper *= 2.0\n        \n        # Now we have a bracket [dt_lower, dt_upper] where lower is stable and upper is not.\n\n        # 2. Bisection to refine dt_crit\n        for _ in range(BISECTION_ITERATIONS):\n            dt_mid = (dt_lower + dt_upper) / 2.0\n            if is_stable(dt_mid, omega):\n                dt_lower = dt_mid\n            else:\n                dt_upper = dt_mid\n        \n        # The critical time step is the largest value that remains stable\n        return dt_lower\n\n    # --- Main Logic ---\n\n    results = []\n    for nu_tilde in wavenumbers_cm_inv:\n        # 1. Calculate angular frequency\n        omega = get_omega(nu_tilde)\n        \n        # 2. Empirically find the critical time step in seconds\n        dt_crit_s = find_critical_dt(omega)\n        \n        # 3. Convert dt_crit to femtoseconds and round\n        dt_crit_fs = dt_crit_s * 1e15\n        \n        # 4. Calculate the dimensionless ratio rho\n        rho = dt_crit_s * omega / 2.0\n        \n        # 5. Round results to the required precision\n        dt_crit_fs_rounded = round(dt_crit_fs, 3)\n        rho_rounded = round(rho, 6)\n        \n        results.append(dt_crit_fs_rounded)\n        results.append(rho_rounded)\n\n    # --- Final Output ---\n    # Convert all results to string for joining\n    str_results = [f\"{x:.3f}\" if i % 2 == 0 else f\"{x:.6f}\" for i, x in enumerate(results)]\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了高效地模拟复杂系统，我们经常使用多时间步算法（如RESPA），用不同的步长对快慢作用力分别进行积分。虽然这可以节省计算成本，但它也引入了一种与单一最高频率无关的新型不稳定性。在本练习中，您将分析一个具有两个时间尺度的简化系统，并利用线性代数构建积分器的传播矩阵，通过检查矩阵的特征值来揭示这些“共振不稳定性”。",
            "id": "3455272",
            "problem": "考虑一个具有坐标 $q$、动量 $p$ 和质量 $m$ 的单笛卡尔自由度，其受到的势可以分解为一个快的和一个慢的二次分量，表达式为 $U(q) = \\tfrac{1}{2} k_f q^2 + \\tfrac{1}{2} k_s q^2$，其中 $k_f \\gg k_s$。定义快角频率 $\\omega_f = \\sqrt{k_f/m}$ 和慢角频率 $\\omega_s = \\sqrt{k_s/m}$，并写出比率 $r = \\omega_f/\\omega_s$。整个系统遵循牛顿第二定律 $m \\ddot{q} = -\\partial U/\\partial q$ 和哈密顿方程 $\\dot{q} = \\partial H/\\partial p$，$\\dot{p} = -\\partial H/\\partial q$，其中 $H = \\tfrac{p^2}{2m} + U(q)$。\n\n一个参考系统传播算法 (Reference System Propagator Algorithm, RESPA) 类型的多时间步长分裂积分器，通过以下方式将状态推进一个大小为 $\\Delta t_{\\text{outer}}$ 的外层步长：\n- 首先施加一个慢力半踢 (half-kick)，然后\n- 执行 $N$ 个只积分快力的内层子步，最后\n- 再次施加一个慢力半踢。\n内层子步长为 $\\Delta t_{\\text{inner}} = \\Delta t_{\\text{outer}}/N$。对于二次势，每个操作都是线性的，并且可以表示为一个作用于列向量 $(q,p)^\\top$ 的 $2 \\times 2$ 矩阵。\n\n你的任务是：\n1. 从 $m \\ddot{q} = -k_f q - k_s q$ 出发，用 $m$、$k_f$、$k_s$ 和时间增量来推导：仅使用慢力将 $(q,p)$ 推进 $\\Delta t_{\\text{outer}}/2$ 的慢力半踢的线性映射，以及通过对称位置Verlet更新仅使用快力将 $(q,p)$ 推进 $\\Delta t_{\\text{inner}}$ 的一个内层子步的线性映射。\n2. 组合这些映射，得到上述RESPA方案一个完整外层步长的单步传播矩阵 $M$。解释如何使用 $M$ 的特征值来定义一个外层步长内的线性稳定性。具体来说，陈述一个 $M$ 的特征值必须满足的精确谱条件，以避免在线性化映射中 $(q,p)$ 范数的指数增长。\n3. 实现一个程序，对于下面测试套件中的每一组参数，该程序能构建 $M$，计算其特征值，并返回一个布尔值来指示单步映射的稳定性。该稳定性是比率 $r = \\omega_f/\\omega_s$ 和外层时间步长 $\\Delta t_{\\text{outer}}$ 的函数。\n\n使用以下测试套件，其中时间必须以秒 ($s$) 表示，质量以千克 ($\\mathrm{kg}$) 表示，弹簧常数以牛顿/米 ($\\mathrm{N}/\\mathrm{m}$) 表示。对于每种情况，计算任务2中定义的布尔稳定性结果：\n\n- 情况1：$m = 1$ $\\mathrm{kg}$，$k_f = 10^4$ $\\mathrm{N}/\\mathrm{m}$，$k_s = 10^2$ $\\mathrm{N}/\\mathrm{m}$，$N = 10$，$\\Delta t_{\\text{outer}} = 0.020$ $s$。\n- 情况2：$m = 1$ $\\mathrm{kg}$，$k_f = 10^4$ $\\mathrm{N}/\\mathrm{m}$，$k_s = 10^2$ $\\mathrm{N}/\\mathrm{m}$，$N = 10$，$\\Delta t_{\\text{outer}} = \\pi/100$ $s$。\n- 情况3：$m = 1$ $\\mathrm{kg}$，$k_f = 10^4$ $\\mathrm{N}/\\mathrm{m}$，$k_s = 1$ $\\mathrm{N}/\\mathrm{m}$，$N = 10$，$\\Delta t_{\\text{outer}} = \\pi/100$ $s$。\n- 情况4：$m = 1$ $\\mathrm{kg}$，$k_f = 10^4$ $\\mathrm{N}/\\mathrm{m}$，$k_s = 10^2$ $\\mathrm{N}/\\mathrm{m}$，$N = 10$，$\\Delta t_{\\text{outer}} = 0.005$ $s$。\n- 情况5：$m = 1$ $\\mathrm{kg}$，$k_f = 10^4$ $\\mathrm{N}/\\mathrm{m}$，$k_s = 10^2$ $\\mathrm{N}/\\mathrm{m}$，$N = 10$，$\\Delta t_{\\text{outer}} = 0.200$ $s$。\n\n你的程序应该生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4,result_5]$），其中每个 $result_i$ 根据任务2中设计的稳定性判据为 $\\mathrm{True}$ 或 $\\mathrm{False}$。",
            "solution": "### 问题验证\n\n**步骤1：提取已知条件**\n\n- **系统：** 一个具有坐标 $q$、动量 $p$ 和质量 $m$ 的单笛卡尔自由度。\n- **势能：** $U(q) = \\tfrac{1}{2} k_f q^2 + \\tfrac{1}{2} k_s q^2$，其中 $k_f \\gg k_s$。\n- **力：** 快力 $F_f = -k_f q$，慢力 $F_s = -k_s q$。总力 $F = - (k_f + k_s) q$。\n- **频率：** 快角频率 $\\omega_f = \\sqrt{k_f/m}$，慢角频率 $\\omega_s = \\sqrt{k_s/m}$。比率 $r = \\omega_f/\\omega_s$。\n- **哈密顿量：** $H = \\tfrac{p^2}{2m} + U(q)$。\n- **积分器：** 一个多时间步长RESPA积分器。\n    - 外层时间步长：$\\Delta t_{\\text{outer}}$。\n    - 内层子步数：$N$。\n    - 内层时间步长：$\\Delta t_{\\text{inner}} = \\Delta t_{\\text{outer}}/N$。\n    - 一个外层步长内的算法序列：\n        1. 在 $\\Delta t_{\\text{outer}}/2$ 上使用慢力进行半步踢。\n        2. $N$ 个内层子步，每个子步使用对称位置Verlet更新在 $\\Delta t_{\\text{inner}}$ 上积分快力。\n        3. 在 $\\Delta t_{\\text{outer}}/2$ 上使用慢力进行半步踢。\n- **表示：** 每个步骤都是一个作用于状态向量 $(q, p)^\\top$ 的线性映射（一个 $2 \\times 2$ 矩阵）。\n\n**步骤2：使用提取的已知条件进行验证**\n\n- **科学依据：** 该问题牢固地植根于谐振子的经典力学和常微分方程的数值分析。RESPA是分子动力学中用于处理具有多时间尺度系统的标准且广泛使用的算法。该模型和算法在科学上是有效的。\n- **适定性：** 该问题提供了所有必需的参数和定义。任务是具体且数学化的：推导传播矩阵，组合它们，根据其谱性质定义稳定性判据，并将其应用于一组给定的参数。存在唯一、稳定且有意义的解。\n- **客观性：** 该问题以精确、客观的数学语言陈述，没有主观或模糊的术语。\n\n该问题没有表现出验证清单中列出的任何缺陷（例如，科学不健全、不完整、模糊性）。这是一个计算物理学中标准且表述良好的问题。\n\n**步骤3：结论与行动**\n\n问题有效。将提供完整解答。\n\n---\n\n### 解答\n\n解答过程将按问题陈述中列出的三个任务进行。我们用列向量 $\\mathbf{x} = (q, p)^\\top$ 来表示系统状态。积分器的每一步都是一个线性变换 $\\mathbf{x}_{\\text{new}} = M_i \\mathbf{x}_{\\text{old}}$，其中 $M_i$ 是某个矩阵。\n\n#### 任务1：线性映射的推导\n\n**1. 慢力半踢的线性映射**\n\n慢力踢由只涉及慢势 $U_s(q) = \\tfrac{1}{2} k_s q^2$ 的运动方程控制。相应的哈密顿量为 $H_s = \\tfrac{p^2}{2m} + U_s(q)$。对于纯粹依赖于势的项，哈密顿方程为 $\\dot{q} = 0$ 和 $\\dot{p} = -\\partial U_s/\\partial q = -k_s q$。\n\n在算子分裂的背景下，这个“踢”步骤根据当前位置的力来更新动量，而位置保持不变。在一个时间间隔 $\\Delta t$ 内，变换为：\n$$q(t_0 + \\Delta t) = q(t_0)$$\n$$p(t_0 + \\Delta t) = p(t_0) + \\int_{t_0}^{t_0+\\Delta t} (-k_s q(\\tau)) d\\tau = p(t_0) - k_s q(t_0) \\Delta t$$\n\n对于持续时间为 $\\Delta t = \\Delta t_{\\text{outer}}/2$ 的半踢，变换为：\n$$q_{\\text{new}} = q_{\\text{old}}$$\n$$p_{\\text{new}} = p_{\\text{old}} - k_s q_{\\text{old}} \\frac{\\Delta t_{\\text{outer}}}{2}$$\n\n用矩阵形式表示，这是 $\\mathbf{x}_{\\text{new}} = M_{\\text{kick,s}} \\mathbf{x}_{\\text{old}}$，其中慢踢传播矩阵 $M_{\\text{kick,s}}$ 为：\n$$M_{\\text{kick,s}} = \\begin{pmatrix} 1   0 \\\\ -k_s \\frac{\\Delta t_{\\text{outer}}}{2}   1 \\end{pmatrix}$$\n\n**2. 快力内层子步的线性映射（位置Verlet）**\n\n内层子步积分由快势 $U_f(q) = \\tfrac{1}{2} k_f q^2$ 引起的动力学，时间步长为 $\\Delta t_{\\text{inner}}$。运动方程为 $m\\ddot{q} = -k_f q$。对于状态 $(q_n, p_n)$ 的对称位置Verlet更新是三个步骤的组合：\n1. 半步动量踢：$p_{n+1/2} = p_n + F(q_n) \\frac{\\Delta t_{\\text{inner}}}{2} = p_n - k_f q_n \\frac{\\Delta t_{\\text{inner}}}{2}$。\n2. 全步位置漂移：$q_{n+1} = q_n + \\frac{p_{n+1/2}}{m} \\Delta t_{\\text{inner}} = q_n + \\frac{1}{m} \\left( p_n - k_f q_n \\frac{\\Delta t_{\\text{inner}}}{2} \\right) \\Delta t_{\\text{inner}} = \\left(1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m}\\right)q_n + \\frac{\\Delta t_{\\text{inner}}}{m}p_n$。\n3. 半步动量踢：$p_{n+1} = p_{n+1/2} + F(q_{n+1}) \\frac{\\Delta t_{\\text{inner}}}{2} = p_{n+1/2} - k_f q_{n+1} \\frac{\\Delta t_{\\text{inner}}}{2}$。\n\n代入 $p_{n+1/2}$ 和 $q_{n+1}$ 的表达式：\n$$p_{n+1} = \\left(p_n - k_f q_n \\frac{\\Delta t_{\\text{inner}}}{2}\\right) - k_f \\left[ \\left(1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m}\\right)q_n + \\frac{\\Delta t_{\\text{inner}}}{m}p_n \\right] \\frac{\\Delta t_{\\text{inner}}}{2}$$\n$$p_{n+1} = p_n - k_f q_n \\frac{\\Delta t_{\\text{inner}}}{2} - k_f q_n \\frac{\\Delta t_{\\text{inner}}}{2} + \\frac{k_f^2 \\Delta t_{\\text{inner}}^3}{4m} q_n - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m} p_n$$\n$$p_{n+1} = -k_f \\Delta t_{\\text{inner}} \\left( 1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{4m} \\right) q_n + \\left( 1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m} \\right) p_n$$\n\n因此，完整的变换 $\\mathbf{x}_{n+1} = M_{\\text{inner}} \\mathbf{x}_n$ 由以下矩阵给出：\n$$M_{\\text{inner}} = \\begin{pmatrix} 1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m}   \\frac{\\Delta t_{\\text{inner}}}{m} \\\\ -k_f \\Delta t_{\\text{inner}} \\left(1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{4m}\\right)   1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m} \\end{pmatrix}$$\n这可以用快角频率 $\\omega_f^2 = k_f/m$ 来表示：\n$$M_{\\text{inner}} = \\begin{pmatrix} 1 - \\frac{(\\omega_f \\Delta t_{\\text{inner}})^2}{2}   \\frac{\\Delta t_{\\text{inner}}}{m} \\\\ -m\\omega_f^2 \\Delta t_{\\text{inner}} \\left(1 - \\frac{(\\omega_f \\Delta t_{\\text{inner}})^2}{4}\\right)   1 - \\frac{(\\omega_f \\Delta t_{\\text{inner}})^2}{2} \\end{pmatrix}$$\n\n#### 任务2：传播矩阵的组合与稳定性分析\n\n一个完整外层步长的传播矩阵 $M$ 是按序列中每个操作对应矩阵的乘积。状态向量是后乘的，所以矩阵乘法的顺序与操作序列的顺序相反：\n$$M = M_{\\text{kick,s}} \\cdot (M_{\\text{inner}})^N \\cdot M_{\\text{kick,s}}$$\n\n$K$ 个外层步长后系统的演化由 $\\mathbf{x}_K = M^K \\mathbf{x}_0$ 给出。如果状态向量的范数 $||\\mathbf{x}_K||$ 不随 $K \\to \\infty$ 指数增长，则系统被认为是线性稳定的。这种行为由单步传播矩阵 $M$ 的特征值 $\\lambda_i$ 决定。系统稳定的充分必要条件是 $M$ 的谱半径 $\\rho(M) = \\max_i |\\lambda_i|$ 小于或等于1。\n\n矩阵 $M_{\\text{kick,s}}$ 和 $M_{\\text{inner}}$ 是辛矩阵，意味着它们保持相空间体积。一个关键性质是它们的行列式为 $1$。\n$$\\det(M_{\\text{kick,s}}) = 1 \\cdot 1 - 0 = 1$$\n$$\\det(M_{\\text{inner}}) = \\left(1 - \\frac{(\\omega_f \\Delta t_{\\text{inner}})^2}{2}\\right)^2 + \\frac{\\Delta t_{\\text{inner}}}{m} \\cdot m\\omega_f^2 \\Delta t_{\\text{inner}} \\left(1 - \\frac{(\\omega_f \\Delta t_{\\text{inner}})^2}{4}\\right) = 1$$\n由于矩阵乘积的行列式是它们行列式的乘积，$\\det(M) = \\det(M_{\\text{kick,s}}) \\cdot (\\det(M_{\\text{inner}}))^N \\cdot \\det(M_{\\text{kick,s}}) = 1$。\n\n$2 \\times 2$ 矩阵 $M$ 的特征值 $\\lambda$ 是特征多项式 $\\lambda^2 - \\text{Tr}(M)\\lambda + \\det(M) = 0$ 的根。由于 $\\det(M)=1$，这变为：\n$$\\lambda^2 - \\text{Tr}(M)\\lambda + 1 = 0$$\n根为 $\\lambda_{1,2} = \\frac{\\text{Tr}(M) \\pm \\sqrt{\\text{Tr}(M)^2 - 4}}{2}$。\n\n- 如果 $|\\text{Tr}(M)|  2$，判别式为负。特征值为一对复共轭对，$\\lambda_{1,2} = \\frac{\\text{Tr}(M)}{2} \\pm i \\frac{\\sqrt{4 - \\text{Tr}(M)^2}}{2}$。它们的模为 $|\\lambda| = \\sqrt{(\\frac{\\text{Tr}(M)}{2})^2 + (\\frac{\\sqrt{4 - \\text{Tr}(M)^2}}{2})^2} = 1$。这对应于稳定的振荡运动。\n- 如果 $|\\text{Tr}(M)|  2$，判别式为正。特征值为实数且互为倒数，$\\lambda_1 = 1/\\lambda_2$。一个特征值的模将大于1，导致解的指数增长。这是不稳定区域。\n- 如果 $|\\text{Tr}(M)| = 2$，特征值是简并的：$\\lambda_1 = \\lambda_2 = \\pm 1$。这是一个临界稳定情况，如果矩阵不可对角化，可能导致振幅的线性（久期）增长。为避免指数增长，此边界包含在稳定区域内。\n\n**稳定性判据：** 稳定性（避免指数增长）的精确谱条件是，$M$ 的所有特征值的模必须小于或等于1。对于一个 $2 \\times 2$ 的辛矩阵，这等价于条件：\n$$|\\text{Tr}(M)| \\le 2$$\n\n#### 任务3：实现与结果\n提供的Python代码实现了此稳定性分析。对于每组测试参数，它构建矩阵 $M_{\\text{kick,s}}$ 和 $M_{\\text{inner}}$，计算完整的传播矩阵 $M = M_{\\text{kick,s}} (M_{\\text{inner}})^N M_{\\text{kick,s}}$，计算其迹 $\\text{Tr}(M)$，如果 $|\\text{Tr}(M)| \\le 2$ 则返回 `True`，否则返回 `False`。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the linear stability of a RESPA integrator for a harmonic oscillator\n    with two frequency scales.\n    \"\"\"\n    \n    # Define test cases where time is in s, mass in kg, and spring constants in N/m.\n    test_cases = [\n        # (m, k_f, k_s, N, dt_outer)\n        (1.0, 1.0e4, 1.0e2, 10, 0.020),     # Case 1\n        (1.0, 1.0e4, 1.0e2, 10, np.pi/100), # Case 2\n        (1.0, 1.0e4, 1.0,   10, np.pi/100), # Case 3\n        (1.0, 1.0e4, 1.0e2, 10, 0.005),     # Case 4\n        (1.0, 1.0e4, 1.0e2, 10, 0.200),     # Case 5\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        m, k_f, k_s, N, dt_outer = case\n        \n        # 1. Calculate time steps and define propagator for the slow kick.\n        dt_inner = dt_outer / N\n        \n        # Matrix for a half-step kick with the slow force.\n        # This updates momentum p based on the slow force F_s = -k_s * q.\n        # q_new = q_old\n        # p_new = p_old - k_s * q_old * (dt_outer / 2)\n        M_kick_s = np.array([\n            [1.0, 0.0],\n            [-k_s * dt_outer / 2.0, 1.0]\n        ])\n\n        # 2. Define the propagator for a single inner substep (fast force).\n        # This uses a symmetric position Verlet update for the fast dynamics.\n        w_f_sq = k_f / m\n        term_inner = w_f_sq * dt_inner**2\n        \n        # Diagonal element of the Verlet propagator matrix for a harmonic oscillator.\n        diag_val = 1.0 - term_inner / 2.0\n        \n        # Upper-right element (q dependence on p).\n        ur_val = dt_inner / m\n        \n        # Lower-left element (p dependence on q).\n        ll_val = -k_f * dt_inner * (1.0 - term_inner / 4.0)\n\n        M_inner = np.array([\n            [diag_val, ur_val],\n            [ll_val, diag_val]\n        ])\n\n        # 3. Compose the full one-step propagator matrix M.\n        # The RESPA scheme is (slow half-kick) - (N inner steps) - (slow half-kick).\n        # The matrix for N inner steps is M_inner raised to the power of N.\n        M_inner_N = np.linalg.matrix_power(M_inner, N)\n        \n        # The full propagator M = M_kick_s * M_inner_N * M_kick_s\n        M = M_kick_s @ M_inner_N @ M_kick_s\n        \n        # 4. Apply the stability criterion.\n        # For a 2x2 symplectic matrix (det=1), stability requires |Tr(M)| = 2.\n        trace_M = np.trace(M)\n        is_stable = np.abs(trace_M) = 2.0\n        results.append(is_stable)\n\n    # Format and print the final results as a single line.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个没有崩溃的模拟不一定是一个正确的模拟。一个时间步可能在数值上是稳定的，但仍然太大以至于无法捕捉系统的真实物理行为，尤其是在长时标上。本练习使用著名的费米–帕斯塔–乌拉姆–曾戈（FPU）链来探讨这个微妙但至关重要的问题。您将研究时间步的选择如何影响系统模式间的能量均分过程，学会区分物理上的热化和数值伪影。",
            "id": "3455232",
            "problem": "考虑一个由 $N$ 个质点组成的一维费米–帕斯塔–乌拉姆–曾戈链，其两端具有固定边界条件。每个内部质点的位置为 $x_i(t)$，其中 $i \\in \\{1,\\dots,N\\}$。其动力学由牛顿第二运动定律决定，势能是线性项和三次非线性项之和。设每个粒子的质量为 $m$，线性弹簧常数为 $k$。设三次非线性系数为 $\\alpha$。定义键伸长量 $\\Delta_i(t) = x_{i+1}(t) - x_{i}(t)$，其中 $i \\in \\{0,\\dots,N\\}$，且 $x_0(t) = 0$ 和 $x_{N+1}(t) = 0$。总势能为\n$$\nV(x) = \\sum_{i=0}^{N} \\left( \\frac{k}{2} \\Delta_i^2 + \\frac{\\alpha}{3} \\Delta_i^3 \\right),\n$$\n运动方程为\n$$\nm \\frac{d^2 x_i}{dt^2} = F_i(x),\n$$\n其中位置 $i$ 上的力由下式给出\n$$\nF_i(x) = k\\left(\\Delta_i - \\Delta_{i-1}\\right) + \\alpha \\left(\\Delta_i^2 - \\Delta_{i-1}^2\\right),\n$$\n其中 $i \\in \\{1,\\dots,N\\}$，且固定边界条件意味着 $x_0 = 0$ 和 $x_{N+1} = 0$。\n\n在纯线性链（$\\alpha = 0$）中，简正模是正弦形式的，其频率为\n$$\n\\omega_r = 2 \\sqrt{\\frac{k}{m}} \\sin\\left(\\frac{r \\pi}{2 (N+1)}\\right), \\quad r \\in \\{1,\\dots,N\\},\n$$\n以及标准正交模态振型\n$$\n\\phi_{r,i} = \\sqrt{\\frac{2}{N+1}} \\sin\\left(\\frac{r \\pi i}{N+1}\\right).\n$$\n在非线性链（$\\alpha \\neq 0$）中，这些线性模态仍然可以通过将瞬时构型和速度投影到线性模态上，来定义能量共享的诊断量。定义 $a_r(t) = \\sum_{i=1}^{N} \\phi_{r,i} x_i(t)$ 和 $p_r(t) = \\sum_{i=1}^{N} \\phi_{r,i} \\dot{x}_i(t)$，以及各模态能量\n$$\nE_r(t) = \\frac{1}{2}\\left(p_r(t)^2 + \\omega_r^2 a_r(t)^2\\right), \\quad r \\in \\{1,\\dots,N\\}.\n$$\n令 $E_{\\mathrm{tot}}(t) = \\sum_{r=1}^{N} E_r(t)$，模态间的归一化能量分布为 $p_r(t) = \\frac{E_r(t)}{E_{\\mathrm{tot}}(t)}$。定义模态能量分布的熵为 $H(t) = - \\sum_{r=1}^{N} p_r(t) \\ln p_r(t)$，以及归一化均分指标\n$$\nQ(t) = \\frac{\\exp\\left(H(t)\\right)}{N}.\n$$\n当能量在所有 $N$ 个模态中平均共享时，该指标满足 $Q(t) = 1$；当能量局域在少数几个模态中时，该指标满足 $Q(t) \\ll 1$。\n\n考虑这些方程的离散时间数值积分方案，例如速度Verlet方法和四阶龙格-库塔(RK4)方法。时间步长 $\\Delta t$ 影响数值稳定性和定性特征的保持，例如非线性链中的亚稳态能量共享。您的任务是实现一个程序，对于几组参数集，确定一个最小的 $\\Delta t$，使得在该时间步长下，观测到的均分时间尺度相对于使用一个小的 $\\Delta t$ 的基准发生了非物理性的变化。形式上，对于每组参数集，计算均分时间 $T_{\\mathrm{eq}}(\\Delta t)$，其定义为在模拟时间上限 $T_{\\max}$ 内，$Q(t)$ 首次超过固定阈值 $Q_{\\mathrm{th}}$ 的时间 $t$。使用给定网格中最小的 $\\Delta t$ 作为基准 $\\Delta t_{\\min}$，及其均分时间 $T_{\\mathrm{eq}}(\\Delta t_{\\min})$ 作为参考。对于网格中较大的 $\\Delta t$ 值，当比率\n$$\nR(\\Delta t) = \\frac{T_{\\mathrm{eq}}(\\Delta t)}{T_{\\mathrm{eq}}(\\Delta t_{\\min})}\n$$\n对于一个指定的因子 $\\rho  1$ 超出了容差带 $\\left[\\frac{1}{\\rho}, \\rho\\right]$ 时，就宣告发生了非物理性变化。报告网格中导致此情况发生的最小 $\\Delta t$。如果网格中没有 $\\Delta t$ 引起这种偏差，则报告 $-1$。\n\n使用无量纲单位：设置 $m = 1$ 和 $k = 1$。所有时间，包括 $\\Delta t$ 和 $T_{\\mathrm{eq}}$，都必须以这些自然时间单位表示，并以浮点数形式报告。三角函数内的角度以弧度为单位。均分阈值必须设置为 $Q_{\\mathrm{th}} = 0.75$，容差因子必须设置为 $\\rho = 1.5$。所有测试用例的初始条件必须通过设置 $x_i(0) = A \\, \\phi_{1,i}$ 和 $\\dot{x}_i(0) = 0$，将所有能量置于振幅为 $A$ 的第一线性模态中。\n\n您的程序必须实现速度Verlet和四阶龙格-库塔(RK4)两种积分器，并根据每个测试用例的指定来使用它们。模拟必须以规则的采样间隔计算 $Q(t)$，并将 $T_{\\mathrm{eq}}$ 确定为 $Q(t) \\ge Q_{\\mathrm{th}}$ 的首次穿越时间，如果在时间 $T_{\\max}$ 之前没有发生穿越，则设置 $T_{\\mathrm{eq}} = T_{\\max}$。\n\n测试套件：\n为实现全面覆盖，请使用以下三组参数集。对于每种情况，按升序搜索指定的 $\\Delta t$ 值网格，并找到使 $R(\\Delta t)$ 超出容差带的最小 $\\Delta t$；如果均未超出，则返回 $-1$。\n\n情况1（一般行为，辛方案）：\n- $N = 8$\n- $\\alpha = 0.25$\n- $A = 0.20$\n- 积分器：速度Verlet\n- $T_{\\max} = 200$\n- $\\Delta t$ 网格：$\\{0.0025, 0.005, 0.01, 0.02, 0.04\\}$\n\n情况2（更长的链，非辛方案）：\n- $N = 16$\n- $\\alpha = 0.10$\n- $A = 0.10$\n- 积分器：四阶龙格-库塔(RK4)\n- $T_{\\max} = 200$\n- $\\Delta t$ 网格：$\\{0.00125, 0.0025, 0.005, 0.01, 0.02\\}$\n\n情况3（弱非线性，边界情况）：\n- $N = 8$\n- $\\alpha = 0.05$\n- $A = 0.05$\n- 积分器：速度Verlet\n- $T_{\\max} = 150$\n- $\\Delta t$ 网格：$\\{0.005, 0.01, 0.02\\}$\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述顺序包含三种情况的结果。每个条目必须是该情况下网格中根据准则导致非物理性变化的最小 $\\Delta t$，如果没有，则为 $-1$。例如，输出必须类似于\n$[d_1,d_2,d_3]$\n其中 $d_1$、$d_2$ 和 $d_3$ 是时间单位的浮点值或整数 $-1$。",
            "solution": "该问题要求分析一维费米–帕斯塔–乌拉姆–曾戈 (FPU) 链模拟的数值稳定性和物理保真度。具体来说，它要求确定一个最大的数值积分时间步长 $\\Delta t$，当使用此步长时，计算出的能量均分时间尺度会非物理性地偏离高保真度基准模拟的结果。\n\n该系统由一条包含 $N$ 个质量为 $m$ 的粒子链组成，粒子之间由非线性弹簧连接。链的两端是固定的，对应于边界条件 $x_0(t) = 0$ 和 $x_{N+1}(t) = 0$。系统的势能 $V$ 由每个键伸长量 $\\Delta_i = x_{i+1} - x_i$ 的谐波项和三次项之和给出：\n$$\nV(x) = \\sum_{i=0}^{N} \\left( \\frac{k}{2} \\Delta_i^2 + \\frac{\\alpha}{3} \\Delta_i^3 \\right)\n$$\n其中 $k$ 是线性弹簧常数，$\\alpha$ 是三次非线性的系数。第 $i$ 个粒子上的力由势能导出，即 $F_i = -\\frac{\\partial V}{\\partial x_i}$，可得：\n$$\nF_i(x) = k\\left(\\Delta_i - \\Delta_{i-1}\\right) + \\alpha \\left(\\Delta_i^2 - \\Delta_{i-1}^2\\right), \\quad \\text{for } i \\in \\{1, \\dots, N\\}\n$$\n动力学由牛顿第二定律 $m \\frac{d^2 x_i}{dt^2} = F_i(x)$ 决定。在本分析中，我们使用无量纲单位，其中 $m=1$ 和 $k=1$。\n\n为了诊断系统的状态，我们将其构型和速度投影到相应谐振链（$\\alpha=0$）的线性简正模上。这些模态的频率 $\\omega_r$ 和标准正交模态振型 $\\phi_{r,i}$ 为：\n$$\n\\omega_r = 2 \\sqrt{\\frac{k}{m}} \\sin\\left(\\frac{r \\pi}{2 (N+1)}\\right), \\quad \\phi_{r,i} = \\sqrt{\\frac{2}{N+1}} \\sin\\left(\\frac{r \\pi i}{N+1}\\right)\n$$\n其中模态 $r \\in \\{1,\\dots,N\\}$，粒子 $i \\in \\{1,\\dots,N\\}$。模态振幅 $a_r(t)$ 和模态动量 $p_r(t)$ 通过投影计算得出：\n$$\na_r(t) = \\sum_{i=1}^{N} \\phi_{r,i} x_i(t), \\quad p_r(t) = \\sum_{i=1}^{N} \\phi_{r,i} \\dot{x}_i(t)\n$$\n与每个线性模态相关的能量近似为：\n$$\nE_r(t) = \\frac{1}{2}\\left(p_r(t)^2 + \\omega_r^2 a_r(t)^2\\right)\n$$\n总模态能量为 $E_{\\mathrm{tot}}(t) = \\sum_{r=1}^{N} E_r(t)$。能量分布由归一化的各模态能量 $p_r(t) = \\frac{E_r(t)}{E_{\\mathrm{tot}}(t)}$ 描述。\n\n能量共享的程度，或称热化程度，使用基于熵的度量来量化。模态能量熵为 $H(t) = - \\sum_{r=1}^{N} p_r(t) \\ln p_r(t)$。由此得出归一化均分指标 $Q(t)$：\n$$\nQ(t) = \\frac{\\exp\\left(H(t)\\right)}{N}\n$$\n当能量集中在单个模态时，该指标范围从 $Q(t) \\approx 1/N$ 开始，到完美均分（能量在所有 $N$ 个模态中平均共享）时的 $Q(t)=1$。均分时间 $T_{\\mathrm{eq}}(\\Delta t)$ 定义为 $Q(t)$ 首次超过阈值 $Q_{\\mathrm{th}} = 0.75$ 的时间 $t$。\n\n问题的核心是研究积分时间步长 $\\Delta t$ 的选择如何影响 $T_{\\mathrm{eq}}$。我们使用给定网格中最小时间步长 $\\Delta t_{\\min}$ 的模拟来建立基准均分时间 $T_{\\mathrm{eq}}(\\Delta t_{\\min})$。如果比率 $R(\\Delta t) = \\frac{T_{\\mathrm{eq}}(\\Delta t)}{T_{\\mathrm{eq}}(\\Delta t_{\\min})}$ 落入容差带 $[\\frac{1}{\\rho}, \\rho]$ 之外，则认为较大的时间步长 $\\Delta t$ 产生了非物理结果，其中容差因子 $\\rho = 1.5$。我们必须从网格中找到满足此条件的最小 $\\Delta t$。\n\n运动方程的数值积分使用两种指定的方法进行：\n$1$。**速度Verlet**方法，这是一种二阶辛积分器，因其长期能量稳定性而非常适合哈密顿系统。对于从时间 $t$ 到 $t+\\Delta t$ 的一个步长，给定位置 $x(t)$、速度 $v(t)$ 和加速度 $a(t) = F(x(t))/m$，算法如下：\n   a. $v(t + \\frac{\\Delta t}{2}) = v(t) + a(t) \\frac{\\Delta t}{2}$\n   b. $x(t + \\Delta t) = x(t) + v(t + \\frac{\\Delta t}{2}) \\Delta t$\n   c. 使用新位置 $x(t + \\Delta t)$ 计算 $a(t + \\Delta t)$。\n   d. $v(t + \\Delta t) = v(t + \\frac{\\Delta t}{2}) + a(t + \\Delta t) \\frac{\\Delta t}{2}$\n\n$2$。**四阶龙格-库塔(RK4)**方法，这是一种通用的、高精度的非辛积分器。对于一阶常微分方程组 $\\frac{dY}{dt} = f(t, Y)$，其中 $Y = [x_1, \\dots, x_N, \\dot{x}_1, \\dots, \\dot{x}_N]$，一个步长的计算如下：\n   a. $k_1 = \\Delta t \\cdot f(t, Y(t))$\n   b. $k_2 = \\Delta t \\cdot f(t + \\frac{\\Delta t}{2}, Y(t) + \\frac{k_1}{2})$\n   c. $k_3 = \\Delta t \\cdot f(t + \\frac{\\Delta t}{2}, Y(t) + \\frac{k_2}{2})$\n   d. $k_4 = \\Delta t \\cdot f(t + \\Delta t, Y(t) + k_3)$\n   e. $Y(t + \\Delta t) = Y(t) + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)$\n\n每个测试用例的总体流程如下：\n$1$。使用指定的参数（$N, \\alpha, A$）和常数（$m=1, k=1$）设置系统。初始条件为 $x_i(0) = A \\phi_{1,i}$ 和 $\\dot{x}_i(0) = 0$，仅填充最低频率的模态。\n$2$。预先计算模态振型 $\\phi_{r,i}$ 和频率的平方 $\\omega_r^2$。\n$3$。对于所提供网格中的每个 $\\Delta t$，使用指定的积分器运行模拟，直至时间达到 $T_{\\max}$。\n$4$。在每次模拟中，监控 $Q(t)$ 并记录均分时间 $T_{\\mathrm{eq}}(\\Delta t)$。如果 $Q(t)$ 未达到 $Q_{\\mathrm{th}}$，则设置 $T_{\\mathrm{eq}}(\\Delta t) = T_{\\max}$。\n$5$。从使用最小 $\\Delta t$ 的运行中确定基准 $T_{\\mathrm{eq}}(\\Delta t_{\\min})$。\n$6$。按升序遍历剩余的 $\\Delta t$ 值。计算比率 $R(\\Delta t)$。第一个使得 $R(\\Delta t)  1/1.5$ 或 $R(\\Delta t)  1.5$ 的 $\\Delta t$ 即为该情况的答案。如果未找到这样的 $\\Delta t$，则答案为 $-1$。\n\n此流程针对提供的三个测试用例进行实现。为了提高效率，计算过程使用 `numpy` 进行了矢量化，特别是在力评估和模态投影部分。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the final result.\n    \"\"\"\n\n    def calculate_forces(x, alpha, k, n_particles):\n        \"\"\"\n        Calculates the forces on each particle in the FPU chain.\n        \"\"\"\n        x_ext = np.zeros(n_particles + 2)\n        x_ext[1:-1] = x\n        \n        delta = np.diff(x_ext)\n        delta_sq = delta**2\n        \n        forces = k * (delta[1:] - delta[:-1]) + alpha * (delta_sq[1:] - delta_sq[:-1])\n        return forces\n\n    def velocity_verlet_step(x, v, dt, alpha, k, n_particles):\n        \"\"\"\n        Performs a single step of the Velocity Verlet algorithm.\n        m=1 is assumed.\n        \"\"\"\n        a = calculate_forces(x, alpha, k, n_particles)\n        v_half = v + 0.5 * a * dt\n        x_new = x + v_half * dt\n        a_new = calculate_forces(x_new, alpha, k, n_particles)\n        v_new = v_half + 0.5 * a_new * dt\n        return x_new, v_new\n\n    def rk4_step(x, v, dt, alpha, k, n_particles):\n        \"\"\"\n        Performs a single step of the Fourth-Order Runge–Kutta algorithm.\n        m=1 is assumed.\n        \"\"\"\n        def f(pos, vel):\n            dxdt = vel\n            dvdt = calculate_forces(pos, alpha, k, n_particles)\n            return dxdt, dvdt\n\n        k1_x, k1_v = f(x, v)\n        k2_x, k2_v = f(x + 0.5 * dt * k1_x, v + 0.5 * dt * k1_v)\n        k3_x, k3_v = f(x + 0.5 * dt * k2_x, v + 0.5 * dt * k2_v)\n        k4_x, k4_v = f(x + dt * k3_x, v + dt * k3_v)\n\n        x_new = x + (dt / 6.0) * (k1_x + 2*k2_x + 2*k3_x + k4_x)\n        v_new = v + (dt / 6.0) * (k1_v + 2*k2_v + 2*k3_v + k4_v)\n        return x_new, v_new\n\n    def calculate_Q(x, v, phi_matrix, omega_sq_vec, n_particles):\n        \"\"\"\n        Calculates the equipartition indicator Q.\n        \"\"\"\n        # Modal projection\n        a = phi_matrix @ x\n        p = phi_matrix @ v\n        \n        # Modal energies\n        E_r = 0.5 * (p**2 + omega_sq_vec * a**2)\n        E_tot = np.sum(E_r)\n        \n        if E_tot  1e-12:\n            return 1.0 / n_particles\n\n        # Normalized energy distribution\n        p_r_norm = E_r / E_tot\n        \n        # Entropy\n        p_r_positive = p_r_norm[p_r_norm > 1e-12]\n        H = -np.sum(p_r_positive * np.log(p_r_positive))\n        \n        # Equipartition indicator\n        Q = np.exp(H) / n_particles\n        return Q\n\n    def get_equip_time(params):\n        \"\"\"\n        Runs a single simulation and finds the equipartition time.\n        \"\"\"\n        N = params['N']\n        alpha = params['alpha']\n        A = params['A']\n        integrator_name = params['integrator']\n        T_max = params['T_max']\n        dt = params['dt']\n        Q_th = 0.75\n        m, k = 1.0, 1.0\n\n        # Pre-compute linear modes\n        r_vals = np.arange(1, N + 1)\n        i_vals = np.arange(1, N + 1)\n        \n        omega_vec = 2 * np.sqrt(k / m) * np.sin(r_vals * np.pi / (2 * (N + 1)))\n        omega_sq_vec = omega_vec**2\n        \n        phi_matrix = np.sqrt(2 / (N + 1)) * np.sin(np.outer(r_vals, i_vals * np.pi / (N + 1)))\n        \n        # Initial conditions\n        x = A * phi_matrix[0, :]\n        v = np.zeros(N)\n\n        n_steps = int(T_max / dt)\n        \n        if integrator_name == \"Velocity Verlet\":\n            integrator_step = velocity_verlet_step\n        else: # RK4\n            integrator_step = rk4_step\n        \n        for step in range(n_steps):\n            x, v = integrator_step(x, v, dt, alpha, k, N)\n            current_time = (step + 1) * dt\n            \n            # Sample Q at each step\n            q_val = calculate_Q(x, v, phi_matrix, omega_sq_vec, N)\n            \n            if q_val >= Q_th:\n                return current_time\n        \n        return T_max\n\n    def find_critical_dt(case_params):\n        \"\"\"\n        For a given test case, finds the smallest dt that causes non-physical change.\n        \"\"\"\n        dt_grid = case_params['dt_grid']\n        rho = 1.5\n        \n        T_eq_results = {}\n        for dt in dt_grid:\n            sim_params = case_params.copy()\n            sim_params['dt'] = dt\n            T_eq_results[dt] = get_equip_time(sim_params)\n\n        dt_min = dt_grid[0]\n        T_eq_baseline = T_eq_results[dt_min]\n        \n        if T_eq_baseline == 0: # Should not happen with given ICs, but for robustness\n            return -1.0\n            \n        for dt in dt_grid[1:]:\n            T_eq_current = T_eq_results[dt]\n            ratio = T_eq_current / T_eq_baseline\n            if ratio > rho or ratio  1.0 / rho:\n                return dt\n                \n        return -1.0\n\n    test_cases = [\n        {\n            \"N\": 8, \"alpha\": 0.25, \"A\": 0.20, \"integrator\": \"Velocity Verlet\",\n            \"T_max\": 200, \"dt_grid\": [0.0025, 0.005, 0.01, 0.02, 0.04]\n        },\n        {\n            \"N\": 16, \"alpha\": 0.10, \"A\": 0.10, \"integrator\": \"Fourth-Order Runge–Kutta (RK4)\",\n            \"T_max\": 200, \"dt_grid\": [0.00125, 0.0025, 0.005, 0.01, 0.02]\n        },\n        {\n            \"N\": 8, \"alpha\": 0.05, \"A\": 0.05, \"integrator\": \"Velocity Verlet\",\n            \"T_max\": 150, \"dt_grid\": [0.005, 0.01, 0.02]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        critical_dt = find_critical_dt(case)\n        results.append(critical_dt)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}